@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2007 CWI.
@' All Rights Reserved.

@f yytree
@a M. L. Kersten, P. Boncz
@+ The Parse Tree Structures
This file contains the utility routines to construct a parse tree
within a YACC environment.
@{
@h
#ifndef _YYTREE_H_
#define _YYTREE_H_

#define par_retval	yyval.len
#define old_cntxt	yyval.len

#define YYCHUNK 	256
#define YYNODESIZE(cnt) (sizeof(yystree) - (1+YYMAXSONS-(cnt))*sizeof(yystree*))

/* temporary tree construction in parser (no locks needed!!) */
m_export YYSTREE Myylognode(int tok, int tpe);
m_export YYSTREE Myylogexpand(YYSTREE parent, YYSTREE child);
m_export void    Myylogpush(void);
m_export void    Myylogpop(void);
m_export void    Myylogclean(void);

/* bulk obtaining executable (chunk-compressed) trees */
m_export YYSTREE Myylogout(YYSTREE t);
m_export YYSTREE Myycopy(YYSTREE t);
m_export YYSTREE Myysubstitute_proc(YYSTREE t, int argc, ValPtr argv);
m_export YYSTREE Myysubstitute_iter(YYSTREE t, int argc, ValPtr argv);

/* on-the-fly (non-chunked) MIL tree construction */
m_export YYSTREE Myynode(int tok, int tpe);
m_export YYSTREE Myyexpand(YYSTREE parent, YYSTREE child);

/* tree-guided MIL garbage collection */
m_export void    Myyclean(YYSTREE t);
m_export void    Myyfree(YYSTREE t);

/* statistics & debugging */
m_export size_t  Myysize(YYSTREE t, size_t *cnt);
m_export void    Myyprint(YYSTREE t);
@c
#include "monetdb4_config.h"
#include "monet.h"
#include <stdio.h>
#include <ctype.h>
#include "monet_parse.h"

#define YYBUF_TILE (1<<18)
static char*  yy_buf = NULL;
static size_t yy_free = YYBUF_TILE;

#define yyloggetlast(yytree,n) n = yytree->free.delnode?yytree->free.delnode:yytree
#define yygetlast(yytree,n) for(n=yytree; YYOVERFLOW(n) != NULL; n = YYOVERFLOW(n))

#define yylogsetlast(yytree,n) yytree->free.delnode = n
#define yysetlast(yytree,n) 


@- Node Allocation

During parsing, we hold an exclusive lock, and allocate nodes in 64K pages
in a contiguous space.  Garbage collection is done in the parser by only 
discarding this entire space after each parse action. Thus we guarantee
that no memory leaks occur (think of parsing being halted due to MIL 
syntax errors, with many nodes already allocated).

When parsing finishes, one should still call yypostprocess() while in
parsing mode. This routine does some semantic analysis on the MIL parse
tree and reshapes it into an executable MIL tree.

The nodes in the resulting tree are not memory-optimized. The Myylogout()
call makes a memory-tight copy of the executable tree from parser space
into MIL client space. Here, we can exploit the fact that at this stage 
we know exactly how the tree is shaped.  Node allocation is performed in 
chunks of 256 bytes here (to optimize CPU cache behavior). The nodes are
compressed by omitting the front (yylval, 16 bytes) and end (yysons and
overflow) fields, if possible. 

So, one may get a YSSTREE pointer t, but iff (t->noyyval == 1) then the 
t->yyval field is not there and it actually contains the end part of
the previous node in the chunk (the first node from a chunk always 
allocates a t->yyval to avoid some memory debugging tools detecting 
use of illegal pointers).
Also, the number of children in t->yysons (t->capacity) is trimmed to the 
*actual* number of children (t->cnt), and may even be 0. The overflow
field is a sentinel pointer after t->yysons; thus t->yysons[t->capacity].
It may also be omitted iff (t->extendable == 0).

A final measure to save space is the t->iscopy flag. It indicates
that any pointers (t->yyval.val.sval / t->yyval.val.pval) in the 
the t->yyval record re-uses space from some location that is known
to be stable during the lifetime of this tree. A typical example 
are MIL function names. The default behavior is to make GDKmalloc() 
copy of such pointers. For MIL procs, we always make a copy from
the base template, and the copies may refer to the pointers contained
in this base template.

All in all, the minimum node size is just *12* bytes: the bitfield
integer that contains token:noyyval:cap:cnt:iscopy, and the t->free
field for tree-guided garbage collection.
Note that on 64-bits systems, an uncompressed node is 148 bytes,
excluding any yyval.val.sval pointers.

During runtime, MIL trees may still be changed (if the nodes were created 
extendable). This feature is used sometimes for run-time optimization and
to eliminate interpretation overhead in loops. The default Myynode() and
Myyexpand() calls just allocate non memory-optimized nodes for such purposes. 
@c
#define YYNODE(t, tok, tpe, off, nbytes, cap, mal, ext) {\
	memset(((char*)t) + off, 0, nbytes - off);\
	if (off) (t)->noyyval = 1;\
	else (t)->yyval.vtype = tpe;\
	(t)->token = tok;\
	(t)->capacity = cap;\
	(t)->malloced = mal;\
	(t)->extendable = ext;\
}

YYSTREE
Myylognode(int tok, int tpe)
{
	YYSTREE t;
	if (yy_free + sizeof(yystree) > YYBUF_TILE) {
		size_t bufsize = YYBUF_TILE;
		char **buf = (char**) GDKvmalloc(bufsize, &bufsize, 1);
		if (buf == NULL) {
			GDKfatal("yyextend: out of memory.\n");
		}
		buf[0] = yy_buf; 
		yy_free = sizeof(char*); /* first bytes are the backpointer */
		yy_buf = (char*) buf;
	}
	t = (YYSTREE) (yy_buf + yy_free);
        YYNODE(t, tok, tpe, 0, sizeof(yystree), YYMAXSONS, 0, 1);
	yy_free += sizeof(yystree);
	return t;
}

static YYSTREE 
yychunkalloc(int tok, int cap, int extendable, int noyyval, char** next, char** end) {
	int malloced = 0, off = noyyval?sizeof(ValRecord):0, nbytes = YYNODESIZE(cap + extendable);
	YYSTREE t;
	if (*next + nbytes - off >= *end) {
		*next = (char*) GDKmalloc(YYCHUNK);
		*end = *next + YYCHUNK;
		malloced = 1;
		off = 0;
	}
	t = (YYSTREE) ((*next)  - off);
        YYNODE(t, tok, TYPE_void, off, nbytes, cap, malloced, extendable);
	*next += nbytes - off;
	return t;
}


static YYSTREE
yycopy(YYSTREE t, int kill_orig, int func_parent, char** next, char** end)
{
	unsigned i;
	int cap = t->cnt, extendable = func_parent || (YYOVERFLOW(t) != NULL);
	YYSTREE tn;

	if (t->token == TOK_ITERATOR && cap < 5) {
	        /* iterator nodes are expanded to five wide at runtime */
		cap = 5;
	} else if (t->token == TOK_IDENT && monet_nostalgic) {
	        /* TOK_IDENT may become a TOK_FUNTION (nostalgic) */
		cap = 2;
	} else if (func_parent && cap == 0) {
		cap = 1;
	}
	tn = yychunkalloc(t->token, cap, extendable, t->noyyval, next, end);

	/* function exec nodes (opcache) may be extended later; usually are 1 wide */
	func_parent = (t->token == TOK_FUNCTION || t->token == TOK_SETOP || t->token == TOK_SETAGGR); 

	tn->cnt = t->cnt;
	if (kill_orig && t->yyval.vtype == 0) {
		int tok = t->token;
		t->noyyval = (tok == 0) | (tok == TOK_IF) | (tok == TOK_SEQ) | 
		             (tok == TOK_BREAK) | (tok == TOK_ELSE) |
		             (tok == TOK_WHILE) | (tok == TOK_RETURN) |  
		             (tok == TOK_CONST) | (tok == TOK_ASSIGNMENT);
	}
	if (!t->noyyval) {
		tn->yyval = t->yyval;
		if (kill_orig) {
			/* steal the memory from the copied node */ 
			t->yyval.val.pval = NULL;
			t->yyval.vtype = 0;
        	} else if (t->yyval.val.pval && (t->token != TOK_TEMPLATE)) {
			/* pointers refer to the copied node */ 
			tn->iscopy = 1;
		}
	}
	for (i = 0; i < t->cnt; i++)
		if (t->yysons[i])
			tn->yysons[i] = yycopy(t->yysons[i], kill_orig, func_parent&(i==1), next, end);
	t = YYOVERFLOW(t);
	if (t) {
		assert(tn->extendable && tn->cnt == tn->capacity);
		tn->yysons[tn->capacity] = yycopy(t, kill_orig, 0, next, end);
	}
	return tn;
}

YYSTREE
Myynode(int tok, int tpe)
{
	YYSTREE t = (YYSTREE) GDKmalloc(sizeof(yystree));
        YYNODE(t, tok, tpe, 0, sizeof(yystree), YYMAXSONS, 1, 1);
	return t;
}

@- Adding Children to Nodes (expand)

@= Myyexpand
YYSTREE
Myy@1expand(YYSTREE yytree, YYSTREE y)
{
	YYSTREE n;

	if (y == NULL) return yytree;
 	yy@1getlast(yytree, n);

	assert(n->extendable);
	if (n->cnt == n->capacity){
		YYSTREE m = Myy@1node(0,0);
		n->yysons[n->capacity] = m; 
		m->cnt = 1;
		m->yysons[0] = y;
		yy@1setlast(yytree,m);
	} else {
		n->yysons[n->cnt] = y;
		n->cnt++;
	}
	return yytree;
}
@c
@:Myyexpand()@
@:Myyexpand(log)@


@- Node Free
Collect all really malloced nodes (i.e. chunk starts) first, only then delete them.
Otherwise, we may be freeing nodes that we still have to traverse.
@c
#define YYKILL(t) \
	if ((t)->noyyval == 0 && (t)->token != TOK_TEMPLATE &&\
            (t)->yyval.val.pval && ATOMextern((t)->yyval.vtype))\
	{\
		if (!(t)->iscopy) GDKfree((t)->yyval.val.pval);\
		(t)->iscopy = 0;\
		(t)->yyval.val.pval = 0;\
	}

static YYSTREE
yyfree(YYSTREE yytree)
{
	YYSTREE delnode = NULL; 

	YYKILL(yytree);
	if (yytree->malloced) {
		delnode = yytree;
		delnode->free.delnode = NULL;
	}
	while (yytree) {
		unsigned i;
		for (i = 0; i < yytree->cnt; i++) {
			if (yytree->yysons[i]) {
				YYSTREE del = yyfree(yytree->yysons[i]);
				if (del) {
					/* insert the new list in front of delnode */
					YYSTREE last = del;
					while(last->free.delnode) last = last->free.delnode;
					last->free.delnode = delnode;
					delnode = del;
				}
			}
		}
		yytree = YYOVERFLOW(yytree);
	}
	return delnode;
}

void
Myyfree(YYSTREE yytree)
{
	if (yytree) {
		yytree = yyfree(yytree);
		while(yytree) {
			YYSTREE delnode = yytree; 
			yytree = yytree->free.delnode;
			GDKfree(delnode); 
		}
	}
}

char** yy_sync = NULL;
size_t yy_backup = sizeof(char*);

void 
Myylogpush(void) 
{
	/* set an allocation syncpoint; next Myylogclean frees only up to here */
        if (yy_sync) GDKfatal("Myylogpush called twice without Myylogpop\n");
	yy_sync = (char**) yy_buf;
	yy_backup = yy_free; /* remember where we where */
}

void
Myylogpop(void)
{
	char **cur = (char**) yy_buf;
	size_t off, lim = yy_free;

	/* parsing done; free all node space allocated by the parser */
	if (yy_buf == NULL) return;

	/* clean up all allocated node contents (e.g. MIL syntax error) */
	while(TRUE) {
		char *next = cur[0];
		for(off = (cur==yy_sync)?yy_backup:sizeof(char*); 
                    off + sizeof(yystree) <= lim; 
		    off += sizeof(yystree)) 
		{
			YYSTREE t = (YYSTREE) (((char*)cur) + off);
			YYKILL(t);
		}
		if (cur == yy_sync || next == NULL) break;
		GDKvmfree(cur, YYBUF_TILE, YYBUF_TILE);
		lim = YYBUF_TILE;
		cur = (char**) next;
	}
	yy_buf = (char*) cur;
	yy_free = yy_backup;
	yy_backup = sizeof(char*);
	yy_sync = NULL;
}

void 
Myylogclean() 
{
	yy_backup = sizeof(char*);
	yy_sync = NULL;
	Myylogpop();
}

@- Postprocessing The MIL Tree 

Rewrite TOK_ASSIGNOP in the non-multiplexed case into a simple assignment.
In this way, we do not have to interpret it. It can follow the normal route.

Also rewrite the FUNCTION tree to its modern syntax with
yysons[0]=params, yysons[1]=expansion-cache, yysons[2]=deref/NULL
We store the parameter evaluation space size in the ival of the exec node.
@c
static int
yypostprocess(YYSTREE lt)
{
	int rtrn = 0;

	if (lt->token == TOK_ASSIGNOP) {
		if (lt->yyval.val.sval[0] != '[') {
			if (lt->yysons[0]->token != TOK_IDENT) {
				lt->token = 0;
				GDKerror("yypostprocess: must %s= to a variable\n", lt->yyval.val.sval);
				rtrn = -1;
			} else {
				YYSTREE var = Myylognode(0, 0);
				YYSTREE op = Myylognode(0, 0);

				yylogsetlast(var, NULL);
				*var = *lt->yysons[0];
				var->yyval.val.sval = GDKstrdup(var->yyval.val.sval);
				var->noyyval = 0;

				*op = *lt;
				op->noyyval = 0;
				op->token = TOK_FUNCTION;

				lt->token = TOK_ASSIGNMENT;
				lt->yyval.val.ival = 0;
				lt->yyval.vtype = TYPE_void;
				yylogsetlast(lt, NULL);
				lt->cnt = 2;
				lt->yysons[0] = var;
				lt->yysons[1] = op;
				lt->yysons[lt->capacity] = NULL;
				lt->noyyval = 0;
			}

		} else {
			/* multiplex_resolve will catch the ASSIGNOP */
			lt->token = TOK_FUNCTION;
			lt->yyval.len = -TOK_ASSIGNOP;
			lt->noyyval = 0;
		}
	} 
	if (lt->token == TOK_ATOM) {
		lt->token = TOK_FUNCTION;
		lt->noyyval = 0;
	} 
	if (lt->token == TOK_FUNCTION || lt->token == TOK_SETOP || lt->token == TOK_SETAGGR) {
		YYSTREE params, opcache = Myylognode(0, 0), deref;

		if (lt->yyval.vtype == TYPE_void) {
			deref = lt->yysons[0];
			params = lt->yysons[1];
			if (yypostprocess(deref) < 0) {
				rtrn = -1;
			}
		} else {
			deref = NULL;
			params = Myylognode(0, 0);
			*params = *lt;
			params->token = 0;
			params->yyval.vtype = TYPE_void;
			params->noyyval = 1;
		}

                /* find out how many actual parameters this function maximally may have */
		opcache->noyyval = 0;
		opcache->yyval.vtype = TYPE_int;
		opcache->yyval.val.ival = yypostprocess(params);
		if (opcache->yyval.val.ival < 0) {
			rtrn = -1;
			opcache->yyval.val.ival = 0;
		} else {
			opcache->yyval.val.ival *= (int) sizeof(ValRecord);
		}
		lt->cnt = 0;
		lt->yysons[lt->capacity] = NULL;
		yylogsetlast(lt, NULL);
		Myylogexpand(lt, params);
		Myylogexpand(lt, opcache);
		if (deref)
			Myylogexpand(lt, deref);
	} else {
		unsigned i;
		int sons = 1, range_sons = 0;
		YYSTREE t = lt;

		do {
			for (i = 0; i < t->cnt; i++) {
				if (t->yysons[i]) {
					range_sons |= (t->yysons[i]->token == TOK_RANGETEMP);
					if (yypostprocess(t->yysons[i]) < 0) {
						rtrn = -1;
					}
				}
				sons++;
			}
		} while ((t = YYOVERFLOW(t)) != NULL);
		return (rtrn < 0) ? rtrn : (range_sons ? MAXPARAMS : sons);
	}
	return rtrn;
}

YYSTREE
Myylogout(YYSTREE t)
{
	/* make a memory-tight copy of the tree constructed by the parser, and steal the pointers */ 
	char *t_next = NULL, *t_size = NULL;
	t->noyyval = 0;
	if (yypostprocess(t) < 0) return NULL;
	return yycopy(t, 1, 0, &t_next, &t_size);
}

YYSTREE
Myycopy(YYSTREE t)
{
	/* make a memory-tight copy of the tree constructed by the parser, and steal the pointers */ 
	char *t_next = NULL, *t_size = NULL;

	return yycopy(t, 0, 0, &t_next, &t_size);
}



@- Run-Time Proc Trees
Procedures are parsed into template trees, forming their definition.
At run-time, copies are drawn from it with @%yysubstitute()@. During
this copying phase, the @%$X@ parameters are substituted by TOK_TEMPLATE
values. @%TOK_TEMPLATE@ act as pointers in the Monet Interpreters: their
@%yyval.val.pval@ pointers point to a variable binding. The idea is
that on PROC invocation, an @%argv@ array of @%ValRecord@s exist, in which
the actual parameter values have been assembled.  The run-time copy of the
tree has pointers into this array, such that on repetitive PROC invocations,
the new values just have to be assembled in the array, without having to
traverse the MIL tree.
@c
/* debug/yysubst: get GDKmalloc block length from pointer */
size_t yysize(void* p) {
	ssize_t n = ((ssize_t*) (p))[-1];
	return (n<0)?-n:n; 
}

static YYSTREE
yysubstitute_proc(YYSTREE t, int argc, ValPtr argv, char**next, char** end)
{
	YYSTREE tt = yychunkalloc(t->token, t->capacity, t->extendable, t->noyyval, next, end);
	int i;
	unsigned j;

#if 0
	/* PETER: proc instantiation stats hack */
	argv->val.ival += YYNODESIZE(t->capacity + t->extendable);	
#endif
	if (!t->noyyval) {
		tt->yyval = t->yyval;
		if (t->token == TOK_TEMPLATE) {
			if ((i = t->yyval.val.ival) == 0) {
				tt->token = TOK_CONSTANT;
				tt->yyval.vtype = TYPE_int;
				tt->yyval.val.ival = argc;
			} else if ((i > 0) && (i <= argc)) {
				tt->yyval.vtype = TYPE_ptr;
				tt->yyval.val.pval = argv + i;
			} else {
				GDKerror("yysubstitute: illegal argument '$%d'.\n", i);
				tt->yyval.vtype = TYPE_int;
				tt->yyval.val.ival = 0;
			}
		} else if (t->yyval.val.pval && ATOMextern(t->yyval.vtype)) {
			tt->iscopy = 1; /* pointers refer to the proc template */
		}
	}
	tt->cnt = t->cnt;
	for (j = 0; j < t->cnt; j++)
		if (t->yysons[j])
			tt->yysons[j] = yysubstitute_proc(t->yysons[j], argc, argv, next, end);

	if ((t->token == TOK_VARTEMP) || (t->token == TOK_RANGETEMP)) {
		tt->yyval.val.pval = (ptr) argv;
		tt->yyval.len = argc;
	}
	t = YYOVERFLOW(t);
	if (t) {
		assert(tt->extendable && tt->cnt == tt->capacity);
		tt->yysons[tt->capacity] = yysubstitute_proc(t, argc, argv, next, end);
	}
	return tt;
}

YYSTREE
Myysubstitute_proc(YYSTREE t, int argc, ValPtr argv)
{
	char *t_next = NULL, *t_end = NULL; 
	return yysubstitute_proc(t, argc, argv, &t_next, &t_end);
}

static YYSTREE
yysubstitute_iter(YYSTREE t, int argc, ValPtr argv, char**next, char** end)
{
	YYSTREE tt = yychunkalloc(t->token, t->capacity, t->extendable, t->noyyval, next, end);
	unsigned i;

	if (!t->noyyval) {
		tt->yyval = t->yyval;
		if (t->token == TOK_ITERTEMP) {
			tt->yyval.vtype = TYPE_ptr;
			tt->yyval.val.pval = argv + t->yyval.val.ival;
		} else if (t->yyval.val.pval && ATOMextern(t->yyval.vtype)) {
			tt->iscopy = 1; /* pointers refer to the iter template */
		}
	}
	tt->cnt = t->cnt;
        if (t->cnt > 0 && t->yysons[0])
		tt->yysons[0] = (t->token == TOK_ITERATOR) ? yycopy(t->yysons[0], 0, t->yysons[0]->extendable, next, end) : 
		                                             yysubstitute_iter(t->yysons[0], argc, argv, next, end);
	for (i = 1; i < t->cnt; i++)
		if (t->yysons[i])
			tt->yysons[i] = yysubstitute_iter(t->yysons[i], argc, argv, next, end);

	t = YYOVERFLOW(t);
	if (t) tt->yysons[tt->cnt] = yysubstitute_iter(t, argc, argv, next, end);

	return tt;
}

YYSTREE
Myysubstitute_iter(YYSTREE t, int argc, ValPtr argv)
{
	char *t_next = NULL, *t_end = NULL; 
	return yysubstitute_iter(t, argc, argv, &t_next, &t_end);
}


@- Tree-guided Garbage Collection
The Monet Interpreter (mis)uses the syntax tree structures to guide the
garbage collection process. This is because:
@T
\begin{itemize}
\item {\em it is possible}. MIL has call-by value parameters. Only return
values are a problem, from the garbage collection point of view. Functions
can at most have one return value, making its possible to do the job
without specific datastructures.
\item {\em it is efficient}. We can avoid a garbage collection module, and
still collect garbage at the earliest possibe time. This is of course
gained by the restrictions put in by the language.
\end{itemize}
@
After invocation of a MIL statement, its MIL tree representation will
contain references to the allocated variables and even BATs, in
the @%free@ field. MIL has the rule that each simple statement can
generate only one return value (all other garbage (if any) must be collected
by hand!). This return value is propagated internally in during the
execution of the simple statement, and can only be deleted after the
simple statement has finished executing.
@
Garbage collection calls are therfore done carefully at dedicated
places in the Monet Interpreter.
@
To obtain high performance, the @%CLEANUP@ macros is inserted for code
expansion, rather than a direct function call to @%Myycleanup()@. Due
to the recursive nature of the trees, it will of course come to recursion
if trees are more than 2-deep.
@h
#define GARBAGE(x)							\
	if (x->dealloc) {						\
	    if (x->dealloc == TYPE_bat) {				\
	      if (x->free.batref.id != bat_nil){			\
		BAT* _b;						\
		BBPfix(x->free.batref.id);				\
		_b = (BAT*)BBPgetdesc(ABS(x->free.batref.id));		\
		if (_b == NULL) {					\
			GDKerror("Myyclean: BAT %d GONE\n", x->free.batref.id);	\
		} else if (ABS(x->free.batref.stamp) != ABS(_b->batStamp)) { \
			GDKerror("Myyclean: BAT %d OVERWRITTEN (stamp %d != %d)\n", \
				x->free.batref.id,			\
				_b->batStamp, x->free.batref.stamp);	\
		} else {						\
			ATOMunfix(x->dealloc, &x->free.batref.id);	\
		}							\
		BBPunfix(x->free.batref.id);				\
	      }								\
	    } else {							\
		ATOMunfix(x->dealloc, x->free.atmref);			\
		if (ATOMextern(x->dealloc)) GDKfree(x->free.atmref);	\
	    }								\
	    x->dealloc = 0;						\
	}

#define CLEANUP(x)	switch(((YYSTREE) x)->token) {			\
	case TOK_SEQ:        break;					\
	case TOK_SEQBLOCK:   break;					\
	case TOK_PARBLOCK:   break;					\
	case TOK_ITCOMPILED: break;					\
	case TOK_WHILE:      break;					\
	default:							\
	{       YYSTREE *cleanup_tt, cleanup_t;				\
		unsigned cleanup_j;					\
		for(cleanup_t = (YYSTREE) x; cleanup_t;			\
		    cleanup_t = YYOVERFLOW(cleanup_t)) {		\
			for(cleanup_j = 0, cleanup_tt = cleanup_t->yysons; \
			    cleanup_j < cleanup_t->cnt;			\
			    cleanup_j++, cleanup_tt++) {		\
				if (*cleanup_tt) Myyclean(*cleanup_tt);	\
			}						\
		}							\
	}								\
	GARBAGE(((YYSTREE) x));						\
}
#define CATCHVAL(stk,lt,res)						\
	if (res->vtype == TYPE_bat) {					\
		bat bid = res->val.bval;				\
		BAT* _b = BBPdescriptor(bid);				\
		assert(_b != NULL);					\
		if (_b->batStamp <= stamp) {				\
			PROPDEBUG monet_checkbat(_b, FALSE);		\
		} else if (_b->batStamp > 0) {				\
			CHECKDEBUG monet_checkbat(_b, !(_b->batDirty&2)); \
			if (!(_b->batDirty&2)) {			\
				BATsetaccess(_b, BAT_READ);		\
			}						\
			_b->batDirty &= ~2;				\
			_b->batStamp = -_b->batStamp;			\
		}							\
		BATDEBUG printf("# batstamp(%d) = %d\n",		\
			 (int) _b->batCacheid, _b->batStamp);		\
		BBPincref(bid, TRUE);					\
		BBPunfix(bid);						\
	}								\
	CATCHREF(stk,lt,res)
#define CATCHREF(stk,lt,res)						\
	lt->dealloc = res->vtype;					\
	if (res->vtype != TYPE_bat) {					\
		lt->free.atmref = res->val.pval;			\
	} else {							\
		lt->free.batref.id = res->val.bval;			\
		if (res->val.bval != bat_nil) {				\
			BAT* _b;					\
			BBPfix(res->val.bval);				\
			_b = (BAT*)BBPgetdesc(ABS(res->val.bval));	\
			if (_b) lt->free.batref.stamp = _b->batStamp;	\
			BBPunfix(res->val.bval);			\
		}							\
	}
#define CATCHRET(stk,lt,res,x)			\
	if (x == -TOK_RETURN) {			\
		CATCHREF(stk,lt,res);		\
		x=0;				\
	}
#define CATCHERR(stk,lt,res,x,fcn)\
	if (x == -TOK_BREAK) {\
		x = 0;\
	} else if ((x<0) && (res->vtype == TYPE_str) && res->val.sval) {\
		char *s = (char*) TBL_getname(fcn);			\
		GDKerror("yytree: %s: %s.\n", s?s:"null", res->val.sval); \
		CLEANUP(lt); res->vtype = TYPE_void; lt->dealloc = 0;	\
	}
#define CATCHBREAK(x) ((x==-TOK_BREAK)?0:x)

#endif /* _YYTREE_H_ */
@c
void
Myyclean(YYSTREE t)
{
	switch (t->token) {
	case TOK_SEQ:
	case TOK_SEQBLOCK:
	case TOK_PARBLOCK:
	case TOK_WHILE:
	case TOK_ITCOMPILED:
		return;
	}
	GARBAGE(t);
	for (; t; t = YYOVERFLOW(t)) {
		YYSTREE *sons;
		unsigned j;

		for (j = 0, sons = t->yysons; j < t->cnt; j++, sons++) {
			if (*sons)
				CLEANUP(*sons);
		}
	}
}


@- Debugging
@c
/* monitor the size of a MIL tree */
size_t
Myysize(YYSTREE t, size_t *attached)
{
	size_t sons_attached=0, me_attached=0, tot = YYNODESIZE(t->capacity + t->extendable);
	unsigned i;

 	if (t->noyyval == 0 && t->iscopy == 0 && t->yyval.val.pval && ATOMextern(t->yyval.vtype)) {
		me_attached = yysize(t->yyval.val.pval);
	}
	do {
		for (i = 0; i < t->cnt; i++) 
			if (t->yysons[i]) {
				size_t son_attached = 0;
				tot += Myysize(t->yysons[i], &son_attached);
				sons_attached += son_attached;
			}
	} while ((t = YYOVERFLOW(t)) != NULL);
	*attached = me_attached + sons_attached;	
	return me_attached + tot;
}
extern str LEXNAME(int);

static void
yyprint(YYSTREE yytree, unsigned int level)
{
	char num[20], tpe[20], *p = "noyyval";
	unsigned i;

	if (yytree == 0) return;
	for (i = 0; i < level; i++)
		printf("\t");

	strcpy(tpe, "void");
	if (!yytree->noyyval) {
		p = NULL;
		switch (yytree->yyval.vtype) {
		case TYPE_int:
			strcpy(tpe, "int");
			break;
		case TYPE_wrd:
			strcpy(tpe, "wrd");
			p = num;
			sprintf(num, LLFMT, (lng) yytree->yyval.val.wval);
			break;
		case TYPE_sht:
			strcpy(tpe, "sht");
			p = num;
			sprintf(num, "%d", yytree->yyval.val.shval);
			break;
		case TYPE_bte:
			strcpy(tpe, "bte");
			p = num;
			sprintf(num, "%d", yytree->yyval.val.btval);
			break;
		case TYPE_chr:
			strcpy(tpe, "chr");
			p = num;
			sprintf(num, yytree->yyval.val.cval[0] < ' ' || yytree->yyval.val.cval[0] > '~' ? "'\\%03o'" : "%c", yytree->yyval.val.cval[0]);
			break;
		case TYPE_bit:
			strcpy(tpe, "bit");
			p = yytree->yyval.val.cval[0] ? "true" : "false";
			break;
		case TYPE_oid:
			strcpy(tpe, "oid");
			p = num;
#if SIZEOF_OID == SIZEOF_INT
			sprintf(num, "%d@0", (int) yytree->yyval.val.oval);
#else
			sprintf(num, LLFMT "@0", (lng) yytree->yyval.val.oval);
#endif
			break;
		case TYPE_str:
			strcpy(tpe, "str");
			if (yytree->yyval.val.sval) {
				p = yytree->yyval.val.sval;
			} else {
				p = num;
				strcpy(num, "<null>");
			}
			break;
		case TYPE_ptr:
			strcpy(tpe, "ptr");
			p = num;
			sprintf(num, PTRFMT, PTRFMTCAST yytree->yyval.val.pval);
			break;
		case TYPE_flt:
			strcpy(tpe, "flt");
			p = num;
			sprintf(num, "%g", yytree->yyval.val.fval);
			break;
		case TYPE_dbl:
			strcpy(tpe, "dbl");
			p = num;
			sprintf(num, "%g", yytree->yyval.val.dval);
			break;
		case TYPE_lng:
			strcpy(tpe, "lng");
			p = num;
			sprintf(num, LLFMT, yytree->yyval.val.lval);
			break;
		case TYPE_bat:
			strcpy(tpe, "bat");
			break;
		default:
			sprintf(tpe, "extended%d", yytree->yyval.vtype);
		}
		if (p == NULL) {
			p = num;
			sprintf(num, "%d", yytree->yyval.val.ival);
		}
	}
	printf("%s [%s][%s]\n", LEXNAME(yytree->token), tpe, p);
	do {
		for (i = 0; i < yytree->cnt; i++) {
			if (yytree->yysons[i])
				yyprint(yytree->yysons[i], level+1);
		}
	} while ((yytree = YYOVERFLOW(yytree)) != NULL);
}

void
Myyprint(YYSTREE yytree)
{
	yyprint(yytree, 0);
}
@}
