@/
The contents of this file are subject to the MonetDB Public License
Version 1.1 (the "License"); you may not use this file except in
compliance with the License. You may obtain a copy of the License at
http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html

Software distributed under the License is distributed on an "AS IS"
basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations
under the License.

The Original Code is the MonetDB Database System.

The Initial Developer of the Original Code is CWI.
Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
Copyright August 2008-2010 MonetDB B.V.
All Rights Reserved.
@

@f mapi
@a N.J. Nes, P. Boncz
@t MonetDB's Simple Network Interface
@v 1.1

This module contains a simple interface for network connections.

@m
.MODULE mapi;
	.USE streams;

 	.COMMAND mapi_running() : bit = mapi_running;
		"Is there an mapi listen active ?"

	.BUILTIN mapi_listen(int port, str sockfile, int maxusers, bit open) = MAPIlisten; 
		"Start the Mapi listener on <port> and/or <sockfile> for <maxusers>.\n <sockfile> is the name of a Unix socket.\n If <open> is true, accept connections from everywhere, otherwise only from localhost."

	.COMMAND mapi_register(ptr) : void = MAPIregister;
		"register a frontend"

	.COMMAND mil_frontend() : ptr = mil_frontend;
		"create/return the mil_frontend"

	.COMMAND stream_until(Stream S,str stop) : str = mnstr_read_until;
		"read a string from <S> until the <stop> word"

	.BUILTIN client(stream in, stream out) : void = client; 
		"mapi-client" 

	.PRELUDE = mapi_prelude;
	.EPILOGUE = mapi_epilogue;

.END mapi;

@mil
	PROC listen(int port, str sockfile, int maxusers) : void {
		mapi_listen(port,sockfile,maxusers,false);
	}
	ADDHELP("listen", "sjoerd", "Oct  5 2004",
		"Start the Mapi listener on <port> and/or <sockfile> for <maxusers>.", mod());

	PROC listen(int port, int maxusers, bit open) : void {
		mapi_listen(port,str(nil),maxusers,open);
	}
	ADDHELP("listen", "sjoerd", "May  23 2005",
		"Start the Mapi listener on <port> for <maxusers>.\n If <open> is true, accept connections from everywhere, otherwise only from localhost.",
		mod());

	PROC listen(int port, int maxusers) : void {
		mapi_listen(port,str(nil),maxusers,false);
	}
	ADDHELP("listen", "windhouw", "June  22 2001",
		"Start the Mapi listener on <port> for <maxusers>.",
		mod());

	PROC listen(int port, int maxusers) : void {
		mapi_listen(port,str(nil),maxusers,false);
	}
	ADDHELP("listen", "windhouw", "June  22 2001",
		"Start the Mapi listener on <port> for <maxusers>.",
		mod());

	PROC listen(int port, bit open) : void {
		mapi_listen(port,str(nil),5,open);
	}
	ADDHELP("listen", "sjoerd", "May 23 2005",
		"Start the Mapi listener on <port>.\nIf <open> is true, accept connections from everywhere, otherwise only from localhost.",
		mod());

	PROC listen(int port) : void {
		mapi_listen(port,str(nil),5,false);
	}
	ADDHELP("listen", "windhouw", "June  22 2001",
		"Start the Mapi listener on <port>.",
		mod());

	PROC listen(bit open) : void {
		mapi_listen(50000,str(nil),5,open);
	}
	ADDHELP("listen", "sjoerd", "May 23 2005",
		"Start the Mapi listener on 50000.\n If <open> is true, accept connections from everywhere, otherwise only from localhost.",
		mod());

	PROC listen() : void {
		mapi_listen(50000,str(nil),5,false);
	}
	ADDHELP("listen", "windhouw", "June  22 2001",
		"Start the Mapi listener on 50000.",
		mod());

	PROC stream_strip(Stream s,str stop) : str {
		VAR res := stream_until(s,stop);
		VAR pos := r_search(res,stop);
		IF (pos != -1) {
			res := string(res,0,pos);
		}
		RETURN res;
	}
	ADDHELP("stream_strip", "windhouw", "June  22 2001",
		"Read a string from <S> until the <stop> word.\nThe <stop> word is stripped from the result string.",
		mod());

	PROC mapi_stream_read(Stream s) : str {
		RETURN stream_strip(s,(""+chr(1)));
	}
	ADDHELP("mapi_stream_read", "windhouw", "June  22 2001",
		"Read a string from <S> until a '\\1' character.",
		mod());

	PROC stream_line(Stream s) : str {
		RETURN stream_strip(s,sprintf("%c",chr(10)));
	}
	ADDHELP("stream_line", "windhouw", "June  22 2001",
		"Read a string from <S> until a newline.",
		mod());
@{
@h
#ifndef MAPI_H
#define MAPI_H

#include <streams.h>
#include <monet_context.h>
#include <mapi/mapi.proto.h>

#define NEW_ARRAY( type, size )	(type*)GDKmalloc((size)*sizeof(type))
#define STREQ(a, b) 		(strcmp(a, b)==0)

#define MAPIPORT		50000
#define MAPIMAXUSERS 		5

typedef struct mapi_client
{
	int frontend; 	/* which frontend (> MAX_FRONTENDS == UNUSED) */
	int inuse;
	Cntxt stk; 
	Client c;	/* monet client */

	Variable 
		lastvar; /* last MIL variable that should be cleared after execution */

	void *fc; 	/* frontend client */
	MT_Id t;	/* 0 (no thread assigned), or thread for this client */
	MT_Sema s;	/* sema to (de)activate thread */ 
	Thread thread;	/* monet thread */

	void (*engine)(struct mapi_client *fc);  
	void *arg;
} mapi_client;

typedef struct frontend
{
	int nr;
	int clients;
	int cache_limit;		/* max number of cached clients */
	char *name; 		
	char *(*f_alloc)(mapi_client *fc);  /* returns error string (NULL if ok) */  
	char *(*f_init)(mapi_client *fc);   /* returns error string (NULL if ok) */
	void (*f_engine)(mapi_client *fc);  /* read/parse/execute loop */
	void (*f_free)(mapi_client *fc);	/* free any resources used by the client of this frontend */

} mapi_frontend;

mapi_export mapi_client *MAPIclient(stream *fdin, stream *fdout, char *lang);
mapi_export int active_clients(char *lang);

#endif /* MAPI_H */
@c
#include "monetdb4_config.h"
#include <monet.h>
#include "mapi.h"
#include  <sys/types.h>
#include <stream_socket.h>
#ifdef HAVE_SYS_UN_H
#include <sys/un.h>
#endif
#ifdef HAVE_NETDB_H
# include <netdb.h>
# include <netinet/in.h>
#endif

#define SOCKPTR struct sockaddr *

@c
#define MAX_FRONTENDS 8
static int nr_frontends = 0;
static mapi_frontend *mapi_frontends[MAX_FRONTENDS] = { NULL };
static mapi_client mapi_clients[MAXCLIENTS];
static int nr_mapi_clients = 0;
static MT_Lock mapi_cache_lock;

static void
init_client_cache(void)
{
	int i;

	MT_init_lock(mapi_cache_lock, "mapi_cache_lock");

	for(i = 0; i < MAX_FRONTENDS; i++)
		mapi_frontends[i] = 0;
	nr_frontends = 0;
	
	for(i=0; i<MAXCLIENTS; i++) { 
		mapi_clients[i].frontend = MAX_FRONTENDS;
		mapi_clients[i].inuse = 0;
		mapi_clients[i].c = monet_clients+i;
		mapi_clients[i].stk = i;
		mapi_clients[i].fc = NULL;
	}
	nr_mapi_clients = 0;
}

static void
exit_client_cache(void)
{
	int i;

	MT_set_lock(mapi_cache_lock, "exit_client_cache");
	for(i=0; i<MAXCLIENTS; i++) { 
		if (mapi_clients[i].frontend != MAX_FRONTENDS) { 
			/* no active client killing jet */
			mapi_client *fc = mapi_clients+i;
			
			fc->inuse = 2;
			MT_up_sema(fc->s, "exit_client_cache");
		}
	}
	MT_unset_lock(mapi_cache_lock, "exit_client_cache");
	/* wait for clients to finish */
	while(nr_mapi_clients > 0) 
		MT_sleep_ms(1000);	

	for(i=0; i<nr_frontends; i++) {
		GDKfree(mapi_frontends[i]->name);
		GDKfree(mapi_frontends[i]);
	}
	nr_frontends = 0;
}

int
MAPIregister( ptr *F ) 
{
	if (F && nr_frontends < MAX_FRONTENDS) {
		mapi_frontend *f = *(mapi_frontend**)F;
		f->nr = nr_frontends;
		f->clients = 0;
		mapi_frontends[nr_frontends++] = f;
	} else {
		GDKerror("Out of frontend slots");
		return GDK_FAIL;
	}
	return GDK_SUCCEED;
} 

static char *
mil_client_alloc(mapi_client *fc)
{
	fc->fc = fc;
	return NULL; /* no error */
}

static char * 
mil_client_init(mapi_client *fc)
{
	(void)fc;
	return NULL; /* no error */
}

static void
mil_client_engine(mapi_client *fc )
{
	Client c = fc->c;
	
	while (c->mode != FINISHING && !mnstr_errnr(c->fdin) && readClient(c)){
		if (parseClient(c, FALSE)) {
			ValRecord res;
			int i = interpret(c->stk, c->tree, &res);

			CATCHRET(c->stk, c->tree, (&res), i);
			CLEANUP(c->tree);
			c->tree->par_retval = i;
		}
	}
}

static void  
mil_client_free(mapi_client *fc)
{
	(void)fc;
}

int
mil_frontend( ptr *F )
{
/* TODO caching of mil clients requires a fix for the problem of 
	created/drop procs and loaded/dropped modules 

	char *m_clients = GDKgetenv("mapi_clients");
	int nr = (m_clients)?strtol(m_clients, NULL, 10):1;
*/
	mapi_frontend *f = (mapi_frontend*)GDKmalloc(sizeof(mapi_frontend));
	*F = f;
	f->name = GDKstrdup("mil");
	f->cache_limit = 0;
	f->f_alloc  = mil_client_alloc;
	f->f_init   = mil_client_init;
	f->f_free   = mil_client_free;
	f->f_engine = mil_client_engine; /* read/parse/execute loop */
	return GDK_SUCCEED;
}

static mapi_frontend*
find_frontend( char *l )
{
	int i;

	for(i=0; i<nr_frontends; i++) {
		if (strcmp(mapi_frontends[i]->name, l) == 0) {
			return mapi_frontends[i];
		}
	}
	return NULL;
}

static void
mapi_client_end(mapi_client *fc)
{
	Variable v;
	
	for (v = monet_cntxt[fc->stk].var; v && v != fc->lastvar; v = v->next) {
		ATOMunfix(v->binding.vtype, VALptr(&v->binding));
		VALclear(&v->binding); /* -> void-nil (plus clean-up/free) */
		VALset(&v->binding, v->binding.vtype, ATOMnilptr(v->binding.vtype)); /* -> typed-nil */
	}
	if (fc->c->fdout) {
		mnstr_close(fc->c->fdout);
		mnstr_destroy(fc->c->fdout);
		fc->c->fdout = NULL;
	}
	if (fc->c->fdin) {
		mnstr_close(fc->c->fdin);
		mnstr_destroy(fc->c->fdin);
		fc->c->fdin = NULL;
	}
}

static void
mapi_client_free(mapi_client *fc)
{
	mapi_frontend *f = mapi_frontends[fc->frontend];

	MT_destroy_sema(fc->s);
	fc->c->mode = BLOCKMODE;
	closeClient(fc->c, 0);

	MT_set_lock(mapi_cache_lock, "mapi_client_free");
	f->clients --;
	nr_mapi_clients --;

	/* free this mapi slot */
	fc->frontend = MAX_FRONTENDS;
	fc->inuse = 0;

	MT_unset_lock(mapi_cache_lock, "mapi_client_free");
	if (fc->thread)
		THRdel(fc->thread); 
}

static mapi_client *
mapi_client_alloc_(mapi_frontend *f, Client c, stream* s) 
{
	char *err;
	mapi_client *mc;
	int i = (int) (c - monet_clients);

	mc = mapi_clients+i;
	mc->engine = f->f_engine;
	mc->frontend = f->nr;
	mc->inuse = 1;
	mc->c = c;
	mc->t = ~(MT_Id)0;
	MT_init_sema(mc->s, 0, "mapi_client_sema");
	mc->lastvar = monet_cntxt[mc->stk].var;
	if ((err = f->f_alloc(mc)) != NULL){
		if (s) {
			mnstr_printf(s, "!ERROR: %s\n", err);
			mnstr_flush(s);
		}
		mapi_client_end(mc); 
		mapi_client_free(mc);
		return NULL;
	}
	mc->lastvar = monet_cntxt[mc->stk].var;
	return mc;
}

static mapi_client *
mapi_client_alloc(mapi_frontend *f, Client father, Cntxt stk, stream *s)
{
	char *mp = GDKgetenv("monet_prompt");
	Client c = NULL;
	
	MT_set_lock(mapi_cache_lock, "mapi_client_alloc");
 	c = initClient("mapi", mp, FALSE);
	if (c) {
		f->clients ++;
		nr_mapi_clients ++;
	}
	MT_unset_lock(mapi_cache_lock, "mapi_client_alloc");
	if (c == 0) {
		if (s) {
			mnstr_printf(s, "!ERROR: failed to init client\n");
			mnstr_flush(s);
		}
		return NULL;
	}
	c->mode = BLOCKMODE;
	c->listing = 0;
	c->login = time(0);
	c->fdin = NULL;
	c->fdout = NULL;
	CNTXTcopy(stk, c);
	TBL_initclient(c, father);
	return mapi_client_alloc_(f, c, s);
}

static mapi_client *
mapi_client_find(mapi_frontend *f )
{
	mapi_client *res = NULL;
	int i = 0;

	MT_set_lock(mapi_cache_lock, "mapi_client_find");
	for (i=1; i<MAXCLIENTS; i++) {
		mapi_client *mc = mapi_clients+i;
		
		if (mc->inuse == 0 && mc->frontend == f->nr) {
			mc->inuse = 1;
			res = mc;
			break;
		}
	}
	MT_unset_lock(mapi_cache_lock, "mapi_client_find");
	return res;
}

static mapi_client *
mapi_client_get(mapi_frontend *f, Client c )
{
	mapi_client *mc, *res = NULL;
	int i = (int) (c - monet_clients);

	MT_set_lock(mapi_cache_lock, "mapi_client_get");
	mc = mapi_clients+i;
	mc->c = c;
	mc->thread = THRget(THRgettid());
	assert(mc->inuse == 0);
	if (mc->frontend == f->nr && mc->frontend != MAX_FRONTENDS) {
		mc->inuse = 1;
		res = mc;
	} else {
		res = mapi_client_alloc_(f, c, c->fdout);
	}
	MT_unset_lock(mapi_cache_lock, "mapi_client_get");
	return res;
}

static void
mapi_client_engine(void *FC )
{
	mapi_client *fc = (mapi_client*)FC;
	mapi_frontend *f = mapi_frontends[fc->frontend];

	fc->thread = THRnew(MT_getpid(), "mapi_client_engine"); 
	while(fc->thread) {
		MT_down_sema(fc->s, "mapi_client_engine"); /* wait for work */
		if (fc->inuse == 2)
			break;

		fc->thread->data[0] = fc->c->fdout;
		fc->thread->data[1] = fc->c->fdin;
		fc->engine(fc);
		fc->c->mode = STARTING;
	
		mapi_client_end(fc);
		fc->thread->data[0] = NULL;
		fc->thread->data[1] = NULL;
		/* possible race condition, but net result is limited */
		if (f->clients > f->cache_limit) { 
			break;
		}
		fc->inuse = 0;
	}
	fc->inuse = 2;
	f->f_free(fc);
	mapi_client_free(fc);
}

mapi_client *MAPIclient(stream *fdin, stream *fdout, char *lang ) 
{
	mapi_client *fc = NULL;
	mapi_frontend *f = NULL;
	Client c;

	f = find_frontend(lang);

	if (!f) 
		return NULL;

	fc = mapi_client_find(f);
	if (!fc) {
		if (!(fc = mapi_client_alloc(f, monet_clients, 0, fdout))) 
			return NULL;
	}
	if (strcmp(lang, "xquery") == 0 &&
			fc->t == ~(MT_Id) 0 && 
			MT_create_thread(&fc->t, mapi_client_engine, fc, MT_THR_DETACHED) != 0) 
	{
		GDKsyserror("MAPIlisten:mapi_client failed\n");
		fc->t = ~(MT_Id) 0;
	}
	fc->arg = NULL;
	c = fc->c;
	c->fdin = fdin;
	c->fdout = fdout;
	if (c->user)
		GDKfree(c->user);
	if (c->passwd)
		GDKfree(c->passwd);
	c->user = GDKstrdup("mapi_client");
	c->passwd = GDKstrdup("mapi_client");

	if (f->f_init(fc) != NULL) {
		fc->inuse = 0; 
		return NULL;
	}
	return fc;
	
}

int active_clients(char *lang)
{
	int i, nr = 0;
	mapi_frontend *f = find_frontend(lang);

	if (!f)
		return 0;

	for (i=1; i<MAXCLIENTS; i++) {
		mapi_client *mc = mapi_clients+i;

		if (mc->inuse == 1 && mc->frontend == f->nr) 
			nr ++;
	}
	return nr;
}

static mapi_client*
xchange_challenge(Client father, Cntxt stk, stream *fdin, stream *fdout, bit new_client)
{
	char buf[BLOCK+1];
	char *s, *user, *passwd = NULL, *lang = NULL, *algo = NULL, *database = NULL;
	char *err;
	mapi_client *fc = NULL;
	mapi_frontend *f = NULL;
	Client c;
	ssize_t len = 0;

	/* create blockstreams */
	fdin = block_stream(fdin);
	fdout = block_stream(fdout);

	/* write challenge string, the challenge is currently empty, and we
	 * only offer "plain" cypher algorithm to fake proto 8 support */
	s = ":mserver:8:plain:" 
#ifdef WORDS_BIGENDIAN
			"BIG"
#else
			"LIT"
#endif
	;
	mnstr_write(fdout, s, strlen(s), 1);
	mnstr_flush(fdout);

	/* get response */
	s = buf;
	len = mnstr_read_block(fdin, buf, 1, BLOCK);
	assert(len <= BLOCK);
        if (len < 0) len=0;
	buf[len] = 0;

	/* decode BIG/LIT:user:{cypher}passwordchal:lang:database: line */
	user = buf;

	/* byte order */
	s = strchr(user, ':');
	if (s) {
		*s = 0;
		mnstr_set_byteorder(fdin, strcmp(user, "BIG") == 0);
		user = s + 1;
	} else {
		/* no inspiration on how to signal this case properly */
		mnstr_printf(fdout, "!incomplete challenge '%s'\n", user);
		mnstr_flush(fdout);
		return NULL;
	}

	/* passwd */
	s = strchr(user, ':');
	if (s) {
		*s = 0;
		passwd = s + 1;
		/* decode algorithm, i.e. {plain}mypasswordchallenge */
		if (*passwd != '{') {
			mnstr_printf(fdout, "!invalid password entry\n");
			mnstr_flush(fdout);
			return NULL;
		}
		algo = passwd + 1;
		s = strchr(algo, '}');
		if (!s) {
			mnstr_printf(fdout, "!invalid password entry\n");
			mnstr_flush(fdout);
			return NULL;
		}
		*s = 0;
		if (strcmp(algo, "plain") != 0) {
			mnstr_printf(fdout, "!algorithm %s not supported (client violated the protocol)\n", algo);
			mnstr_flush(fdout);
			return NULL;
		}
		passwd = s + 1;
	} else {
		mnstr_printf(fdout, "!incomplete challenge '%s'\n", user);
		mnstr_flush(fdout);
		return NULL;
	}

	/* lang */
	s = strchr(passwd, ':');
	if (s) {
		*s = 0;
		lang = s + 1;
	} else {
		mnstr_printf(fdout, "!incomplete challenge, missing language\n");
		mnstr_flush(fdout);
		return NULL;
	}

	/* database */
	s = strchr(lang, ':');
	if (s) {
		*s = 0;
		database = s + 1;
		/* we can have stuff following, make it void */
		s = strchr(database, ':');
		if (s)
			*s = 0;
		if (strlen(database) > 0 &&
			strcmp(database, GDKgetenv("gdk_dbname")) != 0) {
			mnstr_printf(fdout, "#MonetDB v4 doesn't have multiple database support, argument ignored\n");
		}
	}


	f = find_frontend(lang);

	if (!f) {
		mnstr_printf(fdout,
		 "!xchange_challenge: frontend %s not found\n", lang);
		mnstr_flush(fdout);
		return NULL;
	}

	if (new_client)
		fc = mapi_client_find(f);
	else
		fc = mapi_client_get(f, father);
	if (!fc) {
		if (!(fc = mapi_client_alloc(f, father, stk, fdout))) 
			return NULL;
	}

	c = fc->c;
	c->fdin = fdin;
	c->fdout = fdout;
	if (c->user)
		GDKfree(c->user);
	if (c->passwd)
		GDKfree(c->passwd);
	c->user = GDKstrdup(user);
	c->passwd = GDKstrdup(passwd);

	if ((err = f->f_init(fc)) != NULL) {
		fc->inuse = 0; 
		mnstr_printf(fdout, "!%s\n", err);
		mnstr_flush(fdout);
		return NULL;
	}
	return fc;
}

@= builtin_operand
{
	int _k = interpret(stk, arg(lt, @1), res);
	if (_k < 0) {
		return _k;
	}
	@3 = VALconvert(@2, res);
	if (((ptr) @3 == ILLEGALVALUE)  || (@2 == TYPE_bat && !@3)) {
		return handle_paramerror(res,@1,res->vtype,@2);
	}
}
@c

static bit mapi_active = 0;

int
mapi_running(bit *b)
{
	*b = mapi_active;
	return GDK_SUCCEED;
}

int
MAPIlisten(Cntxt stk, YYSTREE lt, ValPtr res)
{
	struct sockaddr_in server;
	SOCKET sock = INVALID_SOCKET;

#ifdef HAVE_SYS_UN_H
	struct sockaddr_un userver;
	SOCKET usock = INVALID_SOCKET;
#endif
	char *usockfile;
	socklen_t length = 0;
	int on = 1;
	int i = 0;

	int port, *Port;
	int maxusers, *Maxusers;
	Client father;
	bit accept_any, *Accept_any;

	mapi_active = 1;
	CNTXTclient(stk, &father);
	if (lt->cnt != 4) {
		return handle_argerror(res, lt->cnt, 4);
	}
	@:builtin_operand(0,TYPE_int,Port)@
	port = *Port;
	@:builtin_operand(1,TYPE_str,usockfile)@
	if (usockfile == NULL || *usockfile == 0 || GDK_STRNIL(usockfile))
		usockfile = NULL;
	else {
#ifdef HAVE_SYS_UN_H
		usockfile = GDKstrdup(usockfile);
#else
		usockfile = NULL;
		GDKwarning("MAPIlisten: Unix domain sockets are not supported\n");
#endif
	}
	@:builtin_operand(2,TYPE_int,Maxusers)@
	maxusers = *Maxusers;
	@:builtin_operand(3,TYPE_bit,Accept_any);
	accept_any = *Accept_any;
	res->vtype = TYPE_void;

	port = (port ? port : MAPIPORT);
	maxusers = (maxusers ? maxusers : MAPIMAXUSERS);

	if (port <= 0 && usockfile == NULL) {
		GDKsyserror("MAPIlisten: no port or socket file specified\n");
		return GDK_FAIL;
	}

	if (port > 0) {
		sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
		if (sock == INVALID_SOCKET) {
			GDKsyserror("MAPIlisten:creation of stream socket failed\n");
			return GDK_FAIL;
		}
@-
Set server port and allow network connections from any workstation.
Bind the socket to the server port.
The port id should be obtained from the Homes file.
@c
		server.sin_family = AF_INET;
		if (accept_any)
			server.sin_addr.s_addr = htonl(INADDR_ANY);
		else
			server.sin_addr.s_addr = htonl(INADDR_LOOPBACK);
		server.sin_port = htons((unsigned short) ((port) & 0xFFFF));
		for (i = 0; i < 8; i++)
			server.sin_zero[i] = 0;

		setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, (char *) &on, sizeof on);

		length = (socklen_t) sizeof(server);
		if (bind(sock, (SOCKPTR) &server, length) < 0) {
			GDKsyserror("MAPIlisten:binding to stream socket (%d) failed\n", port);
			return GDK_FAIL;
		}
@-
Get the new information for the server socket and start listening.
@c
		if (getsockname(sock, (SOCKPTR) &server, &length) < 0) {
			GDKsyserror("MAPIlisten:getting socket name\n");
			return GDK_FAIL;
		}
		listen(sock, maxusers);
	}
#ifdef HAVE_SYS_UN_H
	if (usockfile) {
		usock = socket(AF_UNIX, SOCK_STREAM, 0);
		if (usock == INVALID_SOCKET) {
			GDKsyserror("MAPIlisten:creation of Unix socket failed\n");
			return GDK_FAIL;
		}
		userver.sun_family = AF_UNIX;
		strncpy(userver.sun_path, usockfile, sizeof(userver.sun_path));

		length = (socklen_t) sizeof(userver);
		if (bind(usock, (SOCKPTR) & userver, length) < 0) {
			GDKsyserror("MAPIlisten:binding to Unix socket (%s) failed\n", usockfile);
			return GDK_FAIL;
		}
		listen(usock, maxusers);
	}
#endif

	PARDEBUG {
		THRprintf(GDKerr, "MAPIlisten:Network started at %d\n", port);
	}
	do {
		int retval;
		struct timeval tv;
		fd_set fds;
		SOCKET msgsock;

		FD_ZERO(&fds);
		if (sock != INVALID_SOCKET)
			FD_SET(sock, &fds);
#ifdef HAVE_SYS_UN_H
		if (usock != INVALID_SOCKET)
			FD_SET(usock, &fds);
#endif
		/* Wait up to 2 seconds. */
		tv.tv_sec = 2;
		tv.tv_usec = 0;

		/* temporarily use msgsock to record the larger of sock and usock */
		msgsock = sock;
#ifdef HAVE_SYS_UN_H
		if (usock > sock)
			msgsock = usock;
#endif
		retval = select((int) msgsock + 1, &fds, NULL, NULL, &tv);
		if (retval == 0) {
			/* nothing interesting has happened */
			continue;
		}

		if (retval < 0) {
			if (MT_geterrno() != EINTR) {
				GDKsyserror("MAPIlisten:select failed\n");
				goto error;
			}
			continue;
		}
		if (sock != INVALID_SOCKET && FD_ISSET(sock, &fds)) {
			if ((msgsock = accept(sock, (SOCKPTR) 0, (socklen_t *) 0)) == INVALID_SOCKET) {
				if (MT_geterrno() != EINTR) {
					GDKsyserror("MAPIlisten:accept failed\n");
					goto error;
				}
				continue;
			}
#ifdef HAVE_SYS_UN_H
		} else if (usock >= 0 && FD_ISSET(usock, &fds)) {
			if ((msgsock = accept(usock, (SOCKPTR) 0, (socklen_t *) 0)) == INVALID_SOCKET) {
				if (MT_geterrno() != EINTR) {
					GDKsyserror("MAPIlisten:accept failed\n");
					goto error;
				}
				continue;
			}
#endif
		} else
			continue;
		/* in embedded mode we allow just one client */
		if (!(GDKembedded && monet_forks > 0)) {
			mapi_client *fc = NULL;
			stream *fdin = socket_rastream(msgsock, "Mserver mapi read");
			stream *fdout = socket_wastream(msgsock, "Mserver mapi write");
			if (fdin == 0 || mnstr_errnr(fdin)) {
				GDKsyserror("MAPIlisten:fdin problems\n");
				if (fdin) {
					mnstr_close(fdin);
					mnstr_destroy(fdin);
				}
				continue;
			}
			if (fdout == 0 || mnstr_errnr(fdout)) {
				GDKsyserror("MAPIlisten:fdout problems\n");
				if (fdout) {
					mnstr_close(fdout);
					mnstr_destroy(fdout);
				}
				mnstr_close(fdin);
				mnstr_destroy(fdin);
				continue;
			}

			fc = xchange_challenge(father, stk, fdin, fdout, 1);
			if (!fc) {
				/* Make sure that the write- (from-) stream is closed first,
		 		 * as the related read- (in-) stream closes the shared
		 	 	 * socket; see also src/common/stream.mx:socket_close .
		 		 */
				mnstr_close(fdout);
				mnstr_destroy(fdout);
				mnstr_close(fdin);
				mnstr_destroy(fdin);
				continue;
			}


			if (fc->t == ~(MT_Id) 0 && 
					MT_create_thread(&fc->t, mapi_client_engine, fc, MT_THR_DETACHED) != 0) {
				GDKsyserror("MAPIlisten:mapi_client failed\n");
				fc->t = ~(MT_Id) 0;
			}
			/* (re)activate thread */
			MT_up_sema(fc->s, "MAPIlisten");
			PARDEBUG THRprintf(GDKerr, "MAPIlisten:client accepted %d\n", msgsock);
		}
	} while (1);
/*
   MAPIlisten() implements an endless loop,
   and hence should/does never come here,
   unless there was an error.
*/
error:
#ifdef HAVE_SYS_UN_H
	if (usockfile)
		unlink(usockfile);
#endif
	return GDK_FAIL;
}

bat *
mapi_prelude(void)
{
	init_client_cache();
	return NULL;
}

void
mapi_epilogue(void)
{
	exit_client_cache();
}

int
mnstr_read_until(str *res, Stream *S, str stop)
{
	stream *s = *(stream **) S;
	ssize_t slen = strlen(stop);
	ptrdiff_t len = 0;
	char buf[BUFSIZ + 1], *start = buf;

	while (mnstr_read(s, start, 1, 1) > 0) {
		if (start - buf >= slen - 1 && strncmp(start - slen + 1, stop, slen) == 0) {
/*
				start = start-slen+1;
*/
			start++;
			break;
		}
		start++;
	}

	if (mnstr_errnr(s))
		return GDK_FAIL;

	len = start - buf;
	if (len > 0) {
		*res = NEW_ARRAY(char, len + 1);

		buf[len] = '\0';
		memcpy(*res, buf, len + 1);
	} else {
		*res = GDKstrdup("");
	}
	return GDK_SUCCEED;
}

int
client(Cntxt stk, YYSTREE lt, ValPtr res)
{
	mapi_frontend *f;
	stream **In, **Out;
	stream *in, *out;
	mapi_client *mc;
	Client klient;
	char *old_in;
	YYSTREE tree;

	CNTXTclient((Cntxt) (ptrdiff_t) stk, &klient);
	/* get the streams from the argument list */
	if (lt->cnt != 2) {
		closeClient(klient, 0);
		return handle_argerror(res, lt->cnt, 2);
	}
	@:builtin_operand(0,TYPE_Stream,In)@
	in = *In;
	@:builtin_operand(1,TYPE_Stream,Out)@
	out = *Out;
	if (in == 0) {
		GDKsyserror("client:stream-r problems\n");
		closeClient(klient, 0);
		return GDK_FAIL;
	}
	if (out == 0) {
		GDKsyserror("client:stream-w problems\n");
		closeClient(klient, 0);
		return GDK_FAIL;
	}
 	mc = xchange_challenge(klient, stk, in, out, 0);
	if (mc == NULL) {
		GDKsyserror("client:stream-w problems\n");
		closeClient(klient, 0);
		return GDK_FAIL;
	}

	f = mapi_frontends[mc->frontend];
	monetSetChannel(mc->thread, mc->c->fdin, mc->c->fdout);
	old_in = klient -> input; 
	klient->input = (str) GDKmalloc(4096);
	klient->limit = klient->input + 4096;
	klient->top = klient->input;
	*klient->top = 0;
	tree = klient->tree;
	klient->tree = NULL;
	f->f_engine(mc);
	klient->tree = tree;
	GDKfree(klient->input);
	klient->input = old_in;
	mapi_client_end(mc); 	
	return GDK_SUCCEED;
}


@}
@- daemon initialization
@mil
proc get_mapi_port() : int {
	if (monet_environment.exist("mapi_port")){
		return int(monet_environment.find("mapi_port"));
	}
	ERROR("mapi_port is not set\n");
}

proc get_mapi_open() : bit {
	if (monet_environment.exist("mapi_open")){
		return bit(monet_environment.find("mapi_open"));
	}
	ERROR("mapi_open is not set\n");
}

proc mapi_server() : void {
	if (monet_environment.find("gdk_embedded") = "no") {
		fork(mapi_listen(
			get_mapi_port(),
			str(nil),
			5,
			get_mapi_open()	
			)
		);
	}
}
mapi_server();

proc mil_start() : void {
	mapi_register(mil_frontend());
}
