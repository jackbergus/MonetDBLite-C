@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2008 CWI.
@' All Rights Reserved.

@f mapi
@a N.J. Nes, P. Boncz
@t MonetDB's Simple Network Interface
@v 1.1

This module contains a simple interface for network connections.

@m
.MODULE mapi;
	.USE streams;

 	.COMMAND mapi_running() : bit = mapi_running;
		"Is there an mapi listen active ?"

	.BUILTIN mapi_listen(int port, str sockfile, int maxusers, bit open) = MAPIlisten; 
		"Start the Mapi listener on <port> and/or <sockfile> for <maxusers>.\n <sockfile> is the name of a Unix socket.\n If <open> is true, accept connections from everywhere, otherwise only from localhost."

	.BUILTIN mapi_listen_ssl(int port, int maxusers, str keyfile, str certfile) = MAPIlistenSSL;
		"Start the Mapi listener on <port> for <maxusers> using SSL.\n<keyfile> and <certfile> give the path names for files with the server key and certificates in PEM format."

	.COMMAND mapi_register(ptr) : void = MAPIregister;
		"register a frontend"

	.COMMAND mil_frontend() : ptr = mil_frontend;
		"create/return the mil_frontend"

	.COMMAND stream_until(Stream S,str stop) : str = stream_read_until;
		"read a string from <S> until the <stop> word"

	.BUILTIN client(stream in, stream out) : void = client; 
		"mapi-client" 

	.PRELUDE = mapi_prelude;
	.EPILOGUE = mapi_epilogue;

.END mapi;

@mil
	PROC listen(int port, str sockfile, int maxusers) : void {
		mapi_listen(port,sockfile,maxusers,false);
	}
	ADDHELP("listen", "sjoerd", "Oct  5 2004",
		"Start the Mapi listener on <port> and/or <sockfile> for <maxusers>.", mod());

	PROC listen(int port, int maxusers, bit open) : void {
		mapi_listen(port,str(nil),maxusers,open);
	}
	ADDHELP("listen", "sjoerd", "May  23 2005",
		"Start the Mapi listener on <port> for <maxusers>.\n If <open> is true, accept connections from everywhere, otherwise only from localhost.",
		mod());

	PROC listen(int port, int maxusers) : void {
		mapi_listen(port,str(nil),maxusers,false);
	}
	ADDHELP("listen", "windhouw", "June  22 2001",
		"Start the Mapi listener on <port> for <maxusers>.",
		mod());

	PROC listen(int port, int maxusers) : void {
		mapi_listen(port,str(nil),maxusers,false);
	}
	ADDHELP("listen", "windhouw", "June  22 2001",
		"Start the Mapi listener on <port> for <maxusers>.",
		mod());

	PROC listen(int port, bit open) : void {
		mapi_listen(port,str(nil),5,open);
	}
	ADDHELP("listen", "sjoerd", "May 23 2005",
		"Start the Mapi listener on <port>.\nIf <open> is true, accept connections from everywhere, otherwise only from localhost.",
		mod());

	PROC listen(int port) : void {
		mapi_listen(port,str(nil),5,false);
	}
	ADDHELP("listen", "windhouw", "June  22 2001",
		"Start the Mapi listener on <port>.",
		mod());

	PROC listen(bit open) : void {
		mapi_listen(50000,str(nil),5,open);
	}
	ADDHELP("listen", "sjoerd", "May 23 2005",
		"Start the Mapi listener on 50000.\n If <open> is true, accept connections from everywhere, otherwise only from localhost.",
		mod());

	PROC listen() : void {
		mapi_listen(50000,str(nil),5,false);
	}
	ADDHELP("listen", "windhouw", "June  22 2001",
		"Start the Mapi listener on 50000.",
		mod());

	PROC stream_strip(Stream s,str stop) : str {
		VAR res := stream_until(s,stop);
		VAR pos := r_search(res,stop);
		IF (pos != -1) {
			res := string(res,0,pos);
		}
		RETURN res;
	}
	ADDHELP("stream_strip", "windhouw", "June  22 2001",
		"Read a string from <S> until the <stop> word.\nThe <stop> word is stripped from the result string.",
		mod());

	PROC mapi_stream_read(Stream s) : str {
		RETURN stream_strip(s,(""+chr(1)));
	}
	ADDHELP("mapi_stream_read", "windhouw", "June  22 2001",
		"Read a string from <S> until a '\\1' character.",
		mod());

	PROC stream_line(Stream s) : str {
		RETURN stream_strip(s,sprintf("%c",chr(10)));
	}
	ADDHELP("stream_line", "windhouw", "June  22 2001",
		"Read a string from <S> until a newline.",
		mod());
@{
@h
#ifndef MAPI_H
#define MAPI_H

#include <streams.h>
#include <monet_context.h>
#include <mapi/mapi.proto.h>

#define NEW_ARRAY( type, size )	(type*)GDKmalloc((size)*sizeof(type))
#define STREQ(a, b) 		(strcmp(a, b)==0)

#define MAPIPORT		50000
#define MAPISSLPORT		40000
#define MAPIMAXUSERS 		5

typedef struct mapi_client
{
	int frontend; 	/* which frontend (> MAX_FRONTENDS == UNUSED) */
	int inuse;
	Cntxt stk; 
	Client c;	/* monet client */

	Variable 
		lastvar; /* last MIL variable that should be cleared after execution */

	void *fc; 	/* frontend client */
	MT_Id t;	/* 0 (no thread assigned), or thread for this client */
	MT_Sema s;	/* sema to (de)activate thread */ 
	Thread thread;	/* monet thread */

	void (*engine)(struct mapi_client *fc);  
	void *arg;
} mapi_client;

typedef struct frontend
{
	int nr;
	int clients;
	int cache_limit;		/* max number of cached clients */
	char *name; 		
	char *(*f_alloc)(mapi_client *fc);  /* returns error string (NULL if ok) */  
	char *(*f_init)(mapi_client *fc);   /* returns error string (NULL if ok) */
	void (*f_engine)(mapi_client *fc);  /* read/parse/execute loop */
	void (*f_free)(mapi_client *fc);	/* free any resources used by the client of this frontend */

} mapi_frontend;

mapi_export mapi_client *MAPIclient(stream *fdin, stream *fdout, char *lang);
mapi_export int active_clients(char *lang);

#endif /* MAPI_H */
@c
#include "monetdb4_config.h"
#include <monet.h>
#include "mapi.h"
#include  <sys/types.h>
#include <stream_socket.h>
#ifdef HAVE_SYS_UN_H
#include <sys/un.h>
#endif
#ifdef HAVE_NETDB_H
# include <netdb.h>
# include <netinet/in.h>
#endif

#define SOCKPTR struct sockaddr *

@c
#define MAX_FRONTENDS 8
static int nr_frontends = 0;
static mapi_frontend *mapi_frontends[MAX_FRONTENDS] = { NULL };
static mapi_client mapi_clients[THREADS + 1];
static int nr_mapi_clients = 0;
static MT_Lock mapi_cache_lock;

static void
init_client_cache(void)
{
	int i;

	MT_init_lock(mapi_cache_lock, "mapi_cache_lock");

	for(i = 0; i < MAX_FRONTENDS; i++)
		mapi_frontends[i] = 0;
	nr_frontends = 0;
	
	for(i=0; i<=THREADS; i++) { 
		mapi_clients[i].frontend = MAX_FRONTENDS;
		mapi_clients[i].inuse = 0;
		mapi_clients[i].c = monet_clients+i;
		mapi_clients[i].stk = i;
		mapi_clients[i].fc = NULL;
	}
	nr_mapi_clients = 0;
}

static void
exit_client_cache(void)
{
	int i;

	MT_set_lock(mapi_cache_lock, "exit_client_cache");
	for(i=0; i<=THREADS; i++) { 
		if (mapi_clients[i].frontend != MAX_FRONTENDS) { 
			/* no active client killing jet */
			mapi_client *fc = mapi_clients+i;
			
			fc->inuse = 2;
			MT_up_sema(fc->s, "exit_client_cache");
		}
	}
	MT_unset_lock(mapi_cache_lock, "exit_client_cache");
	/* wait for clients to finish */
	while(nr_mapi_clients > 0) 
		MT_sleep_ms(1000);	

	for(i=0; i<nr_frontends; i++) {
		GDKfree(mapi_frontends[i]->name);
		GDKfree(mapi_frontends[i]);
	}
	nr_frontends = 0;
}

int
MAPIregister( ptr *F ) 
{
	if (F && nr_frontends < MAX_FRONTENDS) {
		mapi_frontend *f = *(mapi_frontend**)F;
		f->nr = nr_frontends;
		f->clients = 0;
		mapi_frontends[nr_frontends++] = f;
	} else {
		GDKerror("Out of frontend slots");
		return GDK_FAIL;
	}
	return GDK_SUCCEED;
} 

static char *
mil_client_alloc(mapi_client *fc)
{
	fc->fc = fc;
	return NULL; /* no error */
}

static char * 
mil_client_init(mapi_client *fc)
{
	(void)fc;
	return NULL; /* no error */
}

static void
mil_client_engine(mapi_client *fc )
{
	Client c = fc->c;
	
	while (c->mode != FINISHING && !stream_errnr(c->fdin) && readClient(c)){
		if (parseClient(c, FALSE)) {
			ValRecord res;
			int i = interpret(c->stk, c->tree, &res);

			CATCHRET(c->stk, c->tree, (&res), i);
			CLEANUP(c->tree);
			c->tree->par_retval = i;
		}
	}
}

static void  
mil_client_free(mapi_client *fc)
{
	(void)fc;
}

int
mil_frontend( ptr *F )
{
/* TODO caching of mil clients requires a fix for the problem of 
	created/drop procs and loaded/dropped modules 

	char *m_clients = GDKgetenv("mapi_clients");
	int nr = (m_clients)?strtol(m_clients, NULL, 10):1;
*/
	mapi_frontend *f = (mapi_frontend*)GDKmalloc(sizeof(mapi_frontend));
	*F = f;
	f->name = GDKstrdup("mil");
	f->cache_limit = 0;
	f->f_alloc  = mil_client_alloc;
	f->f_init   = mil_client_init;
	f->f_free   = mil_client_free;
	f->f_engine = mil_client_engine; /* read/parse/execute loop */
	return GDK_SUCCEED;
}

static mapi_frontend*
find_frontend( char *l )
{
	int i;

	for(i=0; i<nr_frontends; i++) {
		if (strcmp(mapi_frontends[i]->name, l) == 0) {
			return mapi_frontends[i];
		}
	}
	return NULL;
}

static void
mapi_client_end(mapi_client *fc)
{
	Variable v;
	
	for (v = monet_cntxt[fc->stk].var; v && v != fc->lastvar; v = v->next) {
		ATOMunfix(v->binding.vtype, VALptr(&v->binding));
		VALclear(&v->binding); /* -> void-nil (plus clean-up/free) */
		VALset(&v->binding, v->binding.vtype, ATOMnilptr(v->binding.vtype)); /* -> typed-nil */
	}
	if (fc->c->fdout) {
		stream_close(fc->c->fdout);
		stream_destroy(fc->c->fdout);
		fc->c->fdout = NULL;
	}
	if (fc->c->fdin) {
		stream_close(fc->c->fdin);
		stream_destroy(fc->c->fdin);
		fc->c->fdin = NULL;
	}
}

static void
mapi_client_free(mapi_client *fc)
{
	mapi_frontend *f = mapi_frontends[fc->frontend];

	MT_destroy_sema(fc->s);
	fc->c->mode = BLOCKMODE;
	closeClient(fc->c, 0);

	MT_set_lock(mapi_cache_lock, "mapi_client_free");
	f->clients --;
	nr_mapi_clients --;

	/* free this mapi slot */
	fc->frontend = MAX_FRONTENDS;
	fc->inuse = 0;

	MT_unset_lock(mapi_cache_lock, "mapi_client_free");
	if (fc->thread)
		THRdel(fc->thread); 
}

static mapi_client *
mapi_client_alloc_(mapi_frontend *f, Client c, stream* s) 
{
	char *err;
	mapi_client *mc;
	int i = (int) (c - monet_clients);

	mc = mapi_clients+i;
	mc->engine = f->f_engine;
	mc->frontend = f->nr;
	mc->inuse = 1;
	mc->t = ~(MT_Id)0;
	MT_init_sema(mc->s, 0, "mapi_client_sema");
	mc->lastvar = monet_cntxt[mc->stk].var;
	if ((err = f->f_alloc(mc)) != NULL){
		if (s) {
			stream_printf(s, "!ERROR: %s\n", err);
			stream_flush(s);
		}
		mapi_client_end(mc); 
		mapi_client_free(mc);
		return NULL;
	}
	mc->lastvar = monet_cntxt[mc->stk].var;
	return mc;
}

static mapi_client *
mapi_client_alloc(mapi_frontend *f, Client father, Cntxt stk, stream *s)
{
	char *mp = GDKgetenv("monet_prompt");
	Client c = NULL;
	
	MT_set_lock(mapi_cache_lock, "mapi_client_alloc");
	if (nr_mapi_clients < THREADS) 
 		c = initClient("mapi", mp, FALSE);
		if (c) {
			f->clients ++;
			nr_mapi_clients ++;
		}
	MT_unset_lock(mapi_cache_lock, "mapi_client_alloc");
	if (c == 0) {
		if (s) {
			stream_printf(s, "!ERROR: failed to init client\n");
			stream_flush(s);
		}
		return NULL;
	}
	c->mode = BLOCKMODE;
	c->listing = 0;
	c->login = time(0);
	c->fdin = NULL;
	c->fdout = NULL;
	CNTXTcopy(stk, c);
	TBL_initclient(c, father);
	return mapi_client_alloc_(f, c, s);
}

static mapi_client *
mapi_client_find(mapi_frontend *f )
{
	mapi_client *res = NULL;
	int i = 0;

	MT_set_lock(mapi_cache_lock, "mapi_client_find");
	for (i=1; i<THREADS; i++) {
		mapi_client *mc = mapi_clients+i;
		
		if (mc->inuse == 0 && mc->frontend == f->nr) {
			mc->inuse = 1;
			res = mc;
			break;
		}
	}
	MT_unset_lock(mapi_cache_lock, "mapi_client_find");
	return res;
}

static mapi_client *
mapi_client_get(mapi_frontend *f, Client c )
{
	mapi_client *mc, *res = NULL;
	int i = (int) (c - monet_clients);

	MT_set_lock(mapi_cache_lock, "mapi_client_get");
	mc = mapi_clients+i;
	mc->c = c;
	mc->thread = THRget(THRgettid());
	assert(mc->inuse == 0);
	if (mc->frontend == f->nr && mc->frontend != MAX_FRONTENDS) {
		mc->inuse = 1;
		res = mc;
	} else {
		res = mapi_client_alloc_(f, c, c->fdout);
	}
	MT_unset_lock(mapi_cache_lock, "mapi_client_get");
	return res;
}

static void
mapi_client_engine(void *FC )
{
	mapi_client *fc = (mapi_client*)FC;
	mapi_frontend *f = mapi_frontends[fc->frontend];

	fc->thread = THRnew(MT_getpid(), "mapi_client_engine"); 
	while(fc->thread) {
		MT_down_sema(fc->s, "mapi_client_engine"); /* wait for work */
		if (fc->inuse == 2)
			break;

		fc->thread->data[0] = fc->c->fdout;
		fc->thread->data[1] = fc->c->fdin;
		fc->engine(fc);
		fc->c->mode = STARTING;
	
		mapi_client_end(fc);
		fc->thread->data[0] = NULL;
		fc->thread->data[1] = NULL;
		/* possible race condition, but net result is limited */
		if (f->clients > f->cache_limit) { 
			break;
		}
		fc->inuse = 0;
	}
	fc->inuse = 2;
	f->f_free(fc);
	mapi_client_free(fc);
}

mapi_client *MAPIclient(stream *fdin, stream *fdout, char *lang ) 
{
	mapi_client *fc = NULL;
	mapi_frontend *f = NULL;
	Client c;

	f = find_frontend(lang);

	if (!f) 
		return NULL;

	fc = mapi_client_find(f);
	if (!fc) {
		if (!(fc = mapi_client_alloc(f, monet_clients, 0, fdout))) 
			return NULL;
	}
	if (strcmp(lang, "xquery") == 0 &&
			fc->t == ~(MT_Id) 0 && 
			MT_create_thread(&fc->t, mapi_client_engine, fc) != 0) 
	{
		GDKsyserror("MAPIlisten:mapi_client failed\n");
		fc->t = ~(MT_Id) 0;
	}
	fc->arg = NULL;
	c = fc->c;
	c->fdin = fdin;
	c->fdout = fdout;
	if (c->user)
		GDKfree(c->user);
	if (c->passwd)
		GDKfree(c->passwd);
	c->user = GDKstrdup("mapi_client");
	c->passwd = GDKstrdup("mapi_client");

	if (f->f_init(fc) != NULL) {
		fc->inuse = 0; 
		return NULL;
	}
	return fc;
	
}

int active_clients(char *lang)
{
	int i, nr = 0;
	mapi_frontend *f = find_frontend(lang);

	if (!f)
		return 0;

	for (i=1; i<THREADS; i++) {
		mapi_client *mc = mapi_clients+i;

		if (mc->inuse == 1 && mc->frontend == f->nr) 
			nr ++;
	}
	return nr;
}

static mapi_client*
xchange_challenge(Client father, Cntxt stk, stream *fdin, stream *fdout, bit new_client)
{
	char buf[BLOCK+1];
	char *s, *user, *passwd = NULL, *lang = NULL, *algo = NULL, *database = NULL;
	char *err;
	mapi_client *fc = NULL;
	mapi_frontend *f = NULL;
	Client c;
	int len = 0;

	/* create blockstreams */
	fdin = block_stream(fdin);
	fdout = block_stream(fdout);

	/* write challenge string, the challenge is currently empty, and we
	 * only offer "plain" cypher algorithm to fake proto 8 support */
	s = ":mserver:8:plain:" 
#ifdef WORDS_BIGENDIAN
			"BIG"
#else
			"LIT"
#endif
	;
	stream_write(fdout, s, strlen(s), 1);
	stream_flush(fdout);

	/* get response */
	s = buf;
	len = stream_read_block(fdin, buf, 1, BLOCK);
	assert(len <= BLOCK);
        if (len < 0) len=0;
	buf[len] = 0;

	/* decode BIG/LIT:user:{cypher}passwordchal:lang:database: line */
	user = buf;

	/* byte order */
	s = strchr(user, ':');
	if (s) {
		*s = 0;
		stream_set_byteorder(fdin, strcmp(user, "BIG") == 0);
		user = s + 1;
	} else {
		/* no inspiration on how to signal this case properly */
		stream_printf(fdout, "!incomplete challenge '%s'\n", user);
		stream_flush(fdout);
		return NULL;
	}

	/* passwd */
	s = strchr(user, ':');
	if (s) {
		*s = 0;
		passwd = s + 1;
		/* decode algorithm, i.e. {plain}mypasswordchallenge */
		if (*passwd != '{') {
			stream_printf(fdout, "!invalid password entry\n");
			stream_flush(fdout);
			return NULL;
		}
		algo = passwd + 1;
		s = strchr(algo, '}');
		if (!s) {
			stream_printf(fdout, "!invalid password entry\n");
			stream_flush(fdout);
			return NULL;
		}
		*s = 0;
		if (strcmp(algo, "plain") != 0) {
			stream_printf(fdout, "!algorithm %s not supported (client violated the protocol)\n", algo);
			stream_flush(fdout);
			return NULL;
		}
		passwd = s + 1;
	} else {
		stream_printf(fdout, "!incomplete challenge '%s'\n", user);
		stream_flush(fdout);
		return NULL;
	}

	/* lang */
	s = strchr(passwd, ':');
	if (s) {
		*s = 0;
		lang = s + 1;
	} else {
		stream_printf(fdout, "!incomplete challenge, missing language\n");
		stream_flush(fdout);
		return NULL;
	}

	/* database */
	s = strchr(lang, ':');
	if (s) {
		*s = 0;
		database = s + 1;
		/* we can have stuff following, make it void */
		s = strchr(database, ':');
		if (s)
			*s = 0;
		if (strlen(database) > 0 &&
			strcmp(database, GDKgetenv("gdk_dbname")) != 0) {
			stream_printf(fdout, "#MonetDB v4 doesn't have multiple database support, argument ignored\n");
		}
	}


	f = find_frontend(lang);

	if (!f) {
		stream_printf(fdout,
		 "!xchange_challenge: frontend %s not found\n", lang);
		stream_flush(fdout);
		return NULL;
	}

	if (new_client)
		fc = mapi_client_find(f);
	else
		fc = mapi_client_get(f, father);
	if (!fc) {
		if (!(fc = mapi_client_alloc(f, father, stk, fdout))) 
			return NULL;
	}

	c = fc->c;
	c->fdin = fdin;
	c->fdout = fdout;
	if (c->user)
		GDKfree(c->user);
	if (c->passwd)
		GDKfree(c->passwd);
	c->user = GDKstrdup(user);
	c->passwd = GDKstrdup(passwd);

	if ((err = f->f_init(fc)) != NULL) {
		fc->inuse = 0; 
		stream_printf(fdout, "!%s\n", err);
		stream_flush(fdout);
		return NULL;
	}
	return fc;
}

@= builtin_operand
{
	int _k = interpret(stk, arg(lt, @1), res);
	if (_k < 0) {
		return _k;
	}
	@3 = VALconvert(@2, res);
	if (((ptr) @3 == ILLEGALVALUE)  || (@2 == TYPE_bat && !@3)) {
		return handle_paramerror(res,@1,res->vtype,@2);
	}
}
@c

static bit mapi_active = 0;

int
mapi_running(bit *b)
{
	*b = mapi_active;
	return GDK_SUCCEED;
}

int
MAPIlisten(Cntxt stk, YYSTREE lt, ValPtr res)
{
	struct sockaddr_in server;
	SOCKET sock = -1;

#ifdef HAVE_SYS_UN_H
	struct sockaddr_un userver;
	SOCKET usock = -1;
#endif
	char *usockfile;
	socklen_t length = 0;
	int on = 1;
	int i = 0;

	int port, *Port;
	int maxusers, *Maxusers;
	Client father;
	bit accept_any, *Accept_any;

	mapi_active = 1;
	CNTXTclient(stk, &father);
	if (lt->cnt != 4) {
		return handle_argerror(res, lt->cnt, 4);
	}
	@:builtin_operand(0,TYPE_int,Port)@
	port = *Port;
	@:builtin_operand(1,TYPE_str,usockfile)@
	if (usockfile == NULL || *usockfile == 0 || GDK_STRNIL(usockfile))
		usockfile = NULL;
	else {
#ifdef HAVE_SYS_UN_H
		usockfile = GDKstrdup(usockfile);
#else
		usockfile = NULL;
		GDKwarning("MAPIlisten: Unix domain sockets are not supported\n");
#endif
	}
	@:builtin_operand(2,TYPE_int,Maxusers)@
	maxusers = *Maxusers;
	@:builtin_operand(3,TYPE_bit,Accept_any);
	accept_any = *Accept_any;
	res->vtype = TYPE_void;

	port = (port ? port : MAPIPORT);
	maxusers = (maxusers ? maxusers : MAPIMAXUSERS);

	if (port <= 0 && usockfile == NULL) {
		GDKsyserror("MAPIlisten: no port or socket file specified\n");
		return GDK_FAIL;
	}

	if (port > 0) {
		sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
		if (sock == INVALID_SOCKET) {
			GDKsyserror("MAPIlisten:creation of stream socket failed\n");
			return GDK_FAIL;
		}
@-
Set server port and allow network connections from any workstation.
Bind the socket to the server port.
The port id should be obtained from the Homes file.
@c
		server.sin_family = AF_INET;
		if (accept_any)
			server.sin_addr.s_addr = htonl(INADDR_ANY);
		else
			server.sin_addr.s_addr = htonl(INADDR_LOOPBACK);
		server.sin_port = htons((unsigned short) ((port) & 0xFFFF));
		for (i = 0; i < 8; i++)
			server.sin_zero[i] = 0;

		setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, (char *) &on, sizeof on);

		length = (socklen_t) sizeof(server);
		if (bind(sock, (SOCKPTR) &server, length) < 0) {
			GDKsyserror("MAPIlisten:binding to stream socket (%d) failed\n", port);
			return GDK_FAIL;
		}
@-
Get the new information for the server socket and start listening.
@c
		if (getsockname(sock, (SOCKPTR) &server, &length) < 0) {
			GDKsyserror("MAPIlisten:getting socket name\n");
			return GDK_FAIL;
		}
		listen(sock, maxusers);
	}
#ifdef HAVE_SYS_UN_H
	if (usockfile) {
		usock = socket(AF_UNIX, SOCK_STREAM, 0);
		if (usock == INVALID_SOCKET) {
			GDKsyserror("MAPIlisten:creation of Unix socket failed\n");
			return GDK_FAIL;
		}
		userver.sun_family = AF_UNIX;
		strncpy(userver.sun_path, usockfile, sizeof(userver.sun_path));

		length = (socklen_t) sizeof(userver);
		if (bind(usock, (SOCKPTR) & userver, length) < 0) {
			GDKsyserror("MAPIlisten:binding to Unix socket (%s) failed\n", usockfile);
			return GDK_FAIL;
		}
		listen(usock, maxusers);
	}
#endif

	PARDEBUG {
		THRprintf(GDKerr, "MAPIlisten:Network started at %d\n", port);
	}
	do {
		int retval;
		struct timeval tv;
		fd_set fds;
		SOCKET msgsock;

		FD_ZERO(&fds);
		if (sock != INVALID_SOCKET)
			FD_SET(sock, &fds);
#ifdef HAVE_SYS_UN_H
		if (usock >= 0)
			FD_SET(usock, &fds);
#endif
		/* Wait up to 0.5 seconds. */
		tv.tv_sec = 0;
		tv.tv_usec = 500;

		/* temporarily use msgsock to record the larger of sock and usock */
		msgsock = sock;
#ifdef HAVE_SYS_UN_H
		if (usock > sock)
			msgsock = usock;
#endif
		retval = select((int) msgsock + 1, &fds, NULL, NULL, &tv);
		if (retval == 0) {
			/* nothing interesting has happened */
			continue;
		}

		if (retval < 0) {
			if (MT_geterrno() != EINTR) {
				GDKsyserror("MAPIlisten:select failed\n");
				goto error;
			}
			continue;
		}
		if (sock != INVALID_SOCKET && FD_ISSET(sock, &fds)) {
			if ((msgsock = accept(sock, (SOCKPTR) 0, (socklen_t *) 0)) == INVALID_SOCKET) {
				if (MT_geterrno() != EINTR) {
					GDKsyserror("MAPIlisten:accept failed\n");
					goto error;
				}
				continue;
			}
#ifdef HAVE_SYS_UN_H
		} else if (usock >= 0 && FD_ISSET(usock, &fds)) {
			if ((msgsock = accept(usock, (SOCKPTR) 0, (socklen_t *) 0)) == INVALID_SOCKET) {
				if (MT_geterrno() != EINTR) {
					GDKsyserror("MAPIlisten:accept failed\n");
					goto error;
				}
				continue;
			}
#endif
		} else
			continue;
		/* in embedded mode we allow just one client */
		if (!(GDKembedded && monet_forks > 0)) 
		{
			mapi_client *fc = NULL;
			stream *fdin = socket_rastream(msgsock, "Mserver mapi read");
			stream *fdout = socket_wastream(msgsock, "Mserver mapi write");
			if (fdin == 0 || stream_errnr(fdin)) {
				GDKsyserror("MAPIlisten:fdin problems\n");
				continue;
			}
			if (fdout == 0 || stream_errnr(fdout)) {
				GDKsyserror("MAPIlisten:fdout problems\n");
				continue;
			}

			fc = xchange_challenge(father, stk, fdin, fdout, 1);
			if (!fc) {
				/* Make sure that the write- (from-) stream is closed first,
		 		 * as the related read- (in-) stream closes the shared
		 	 	 * socket; see also src/common/stream.mx:socket_close .
		 		 */
				stream_close(fdout);
				stream_destroy(fdout);
				stream_close(fdin);
				stream_destroy(fdin);
				continue;
			}


			if (fc->t == ~(MT_Id) 0 && 
					MT_create_thread(&fc->t, mapi_client_engine, fc) != 0) {
				GDKsyserror("MAPIlisten:mapi_client failed\n");
				fc->t = ~(MT_Id) 0;
			}
			/* (re)activate thread */
			MT_up_sema(fc->s, "MAPIlisten");
			PARDEBUG THRprintf(GDKerr, "MAPIlisten:client accepted %d\n", msgsock);
		}
	} while (1);
#ifdef HAVE_SYS_UN_H
	if (usockfile)
		unlink(usockfile);
#endif
	return GDK_SUCCEED;
error:
#ifdef HAVE_SYS_UN_H
	if (usockfile)
		unlink(usockfile);
#endif
	return GDK_FAIL;
}

#ifdef HAVE_OPENSSL
static char *
ssl_error(const char *name, int err, int ret)
{
	char *errstr, *s;
	char buf[120];
	unsigned long e;

	switch (err) {
	case SSL_ERROR_ZERO_RETURN:
		errstr = "TLS/SSL connection has been closed";
		break;
	case SSL_ERROR_WANT_READ:
		errstr = "The operation did not complete (read)";
		break;
	case SSL_ERROR_WANT_WRITE:
		errstr = "The operation did not complete (write)";
		break;
	case SSL_ERROR_WANT_X509_LOOKUP:
		errstr = "The operation did not complete (X509 lookup)";
		break;
	case SSL_ERROR_WANT_CONNECT:
		errstr = "The operation did not complete (connect)";
		break;
	case SSL_ERROR_SYSCALL:
		e = ERR_get_error();
		if (e == 0) {
			if (ret == 0) {
				errstr = "EOF occurred in violation of protocol";
			} else if (ret == -1) {
				/* the underlying BIO reported an I/O error */
				errstr = "I/O error";
			} else {	/* possible? */
				errstr = "Some I/O error occurred";
			}
		} else {
			errstr = ERR_error_string(e, buf);
		}
		break;
	case SSL_ERROR_SSL:
		e = ERR_get_error();
		if (e != 0)
			errstr = ERR_error_string(e, buf);
		else {		/* possible? */
			errstr = "A failure in the SSL library occurred";
		}
		break;
	default:
		errstr = "Invalid error code";
	}
	s = GDKmalloc(strlen(errstr) + strlen(name) + 4);
	sprintf(s, "%s: %s\n", name, errstr);	/* we allocated enough, so it fits */
	return s;
}

static MT_Lock *mutex_buf;

static void
locking_function(int mode, int n, const char *file, int line)
{
	(void) file;
	(void) line;
	if (mode & CRYPTO_LOCK) {
		MT_set_lock(mutex_buf[n], "locking_function");
	} else {
		MT_unset_lock(mutex_buf[n], "locking_function");
	}
}

static unsigned long
id_function(void)
{
	return (unsigned long) MT_getpid();
}
#endif /* HAVE_OPENSSL */

bat *
mapi_prelude(void)
{
#ifdef HAVE_OPENSSL
	int i, nlocks;
#endif

	init_client_cache();
#ifdef HAVE_OPENSSL
	nlocks = CRYPTO_num_locks();
	mutex_buf = GDKmalloc(nlocks * sizeof(*mutex_buf));
	if (mutex_buf == NULL) {
		GDKsyserror("mapi_prelude: failed to allocate %d mutexes\n", nlocks);
		return NULL;
	}
	for (i = 0; i < nlocks; i++)
		MT_init_lock(mutex_buf[i], "mapi_mutex_buf");
	CRYPTO_set_locking_callback(locking_function);
	CRYPTO_set_id_callback(id_function);
#endif
	return NULL;
}

void
mapi_epilogue(void)
{
	exit_client_cache();
#ifdef HAVE_OPENSSL
	if (mutex_buf) {
		int i, nlocks;

		nlocks = CRYPTO_num_locks();
		CRYPTO_set_id_callback(NULL);
		CRYPTO_set_locking_callback(NULL);
		for (i = 0; i < nlocks; i++)
			MT_destroy_lock(mutex_buf[i]);
		GDKfree(mutex_buf);
		mutex_buf = NULL;
	}
#endif /* HAVE_OPENSSL */
}

int
MAPIlistenSSL(Cntxt stk, YYSTREE lt, ValPtr res)
{
#ifdef HAVE_OPENSSL
	struct sockaddr_in server;
	SOCKET sock = -1;
	socklen_t length = 0;
	int on = 1;
	SOCKET msgsock;
	int i = 0;

	int port, *Port;
	int maxusers, *Maxusers;
	char *keyfile;
	char *certfile;
	Client father;
	SSL_CTX *ctx = NULL;
	SSL *ssl = NULL;

	mapi_active = 1;
	CNTXTclient(stk, &father);
	if (lt->cnt != 4) {
		return handle_argerror(res, lt->cnt, 4);
	}
	@:builtin_operand(0,TYPE_int,Port)@;
	port = *Port;
	@:builtin_operand(1,TYPE_int,Maxusers)@;
	maxusers = *Maxusers;
	@:builtin_operand(2,TYPE_str,keyfile)@;
	keyfile = GDKstrdup(keyfile);
	@:builtin_operand(3,TYPE_str,certfile)@;
	certfile = GDKstrdup(certfile);
	res->vtype = TYPE_void;

	if (!port)
		port = MAPISSLPORT;
	if (!maxusers)
		maxusers = MAPIMAXUSERS;

	ctx = SSL_CTX_new(SSLv23_method());
	if (ctx == NULL) {
		GDKsyserror("MAPIlistenSSL: creation of SSL context failed\n");
		goto fail;
	}
	if (SSL_CTX_set_cipher_list(ctx, "ALL:!LOW") == 0) {
		GDKsyserror("MAPIlistenSSL: SSL_CTX_set_cipher_list failed\n");
		goto fail;
	}
	if (keyfile && *keyfile && certfile && *certfile) {
		if (SSL_CTX_use_PrivateKey_file(ctx, keyfile, SSL_FILETYPE_PEM) < 1) {
			GDKsyserror("MAPIlistenSSL: SSL_CTX_use_PrivateKey_file %s failed\n", keyfile);
			goto fail;
		}
		if (SSL_CTX_use_certificate_chain_file(ctx, certfile) < 1) {
			GDKsyserror("MAPIlistenSSL: SSL_CTX_use_certificate_chain_file %s failed\n", certfile);
			goto fail;
		}
	}
	if (keyfile)
		GDKfree(keyfile);
	if (certfile)
		GDKfree(certfile);

	SSL_CTX_set_verify(ctx, SSL_VERIFY_NONE, NULL);

	sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
	if (sock == INVALID_SOCKET) {
		GDKsyserror("MAPIlistenSSL:creation of stream socket failed\n");
		goto fail;
	}
@-
Set server port and allow network connections from any workstation.
Bind the socket to the server port.
The port id should be obtained from the Homes file.
@c
	server.sin_family = AF_INET;
	server.sin_addr.s_addr = INADDR_ANY;
	server.sin_port = htons((unsigned short) ((port) & 0xFFFF));
	for (i = 0; i < 8; i++)
		server.sin_zero[i] = 0;

	setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, (char *) &on, sizeof on);

	length = (socklen_t) sizeof(server);
	if (bind(sock, (SOCKPTR) & server, length) < 0) {
		GDKsyserror("MAPIlistenSSL:binding to stream socket (%d) failed\n", port);
		goto fail;
	}
@-
Get the new information for the server socket and start listening.
@c
	if (getsockname(sock, (SOCKPTR) & server, &length) < 0) {
		GDKsyserror("MAPIlistenSSL:getting socket name\n");
		goto fail;
	}
	listen(sock, maxusers);

	PARDEBUG {
		THRprintf(GDKerr, "MAPIlistenSSL:Network started at %d\n", port);
	}
	do {
		int retval;
		struct timeval tv;
		fd_set fds;
		FD_ZERO(&fds);
		FD_SET(sock, &fds);
		/* Wait up to 0.5 seconds. */
		tv.tv_sec = 0;
		tv.tv_usec = 500;

		retval = select(sock + 1, &fds, &fds, &fds, &tv);
		if (retval == 0) {
			/* nothing interesting has happened */
			continue;
		}
		if (retval < 0) {
			GDKsyserror("MAPIlistenSSL:select failed\n");
			goto fail;
		}
		if ((msgsock = accept(sock, (SOCKPTR) 0, (socklen_t *) 0)) == INVALID_SOCKET) {
			if (MT_geterrno() != EINTR) {
				GDKsyserror("MAPIlistenSSL:accept failed\n");
				goto fail;
			}
			continue;
		}
		if ((ssl = SSL_new(ctx)) == 0) {
			GDKsyserror("MAPIlistenSSL: SSL_new failed\n");
			goto fail;
		}

		if (!SSL_set_fd(ssl, msgsock)) {
			GDKsyserror("MAPIlistenSSL: SSL_set_fd failed\n");
			goto fail;
		}

		for (;;) {
			int ret, err;
			char *errstr;

			ret = SSL_accept(ssl);
			err = SSL_get_error(ssl, ret);
			switch (err) {
			case SSL_ERROR_WANT_READ:
			case SSL_ERROR_WANT_WRITE:
				/* try again */
				continue;
			case SSL_ERROR_NONE:
				/* successful connect */
				break;
			case SSL_ERROR_WANT_CONNECT:
			case SSL_ERROR_WANT_ACCEPT:
			case SSL_ERROR_WANT_X509_LOOKUP:
			default:
				/* some error occurred */
				errstr = ssl_error("MAPIlistenSSL", err, ret);
				GDKsyserror(errstr);
				GDKfree(errstr);
				SSL_free(ssl);
				close(msgsock);
				goto end_loop;
			}
			break;
		}
		/* in embedded mode we allow just one client */
		if (!(GDKembedded && monet_forks > 0)) 
		{
			mapi_client *fc = NULL;
			stream *fdin = ssl_rastream(ssl, "mapi-r");
			stream *fdout = ssl_wastream(SSL_dup(ssl), "mapi-w");

			if (fdin == 0 || stream_errnr(fdin)) {
				GDKsyserror("MAPIlisten:fdin problems\n");
				continue;
			}
			if (fdout == 0 || stream_errnr(fdout)) {
				GDKsyserror("MAPIlisten:fdout problems\n");
				continue;
			}

			fc = xchange_challenge(father, stk, fdin, fdout, 1);
			if (!fc) {
				/* Make sure that the write- (from-) stream is closed first,
		 		 * as the related read- (in-) stream closes the shared
		 	 	 * socket; see also src/common/stream.mx:socket_close .
		 		 */
				stream_close(fdout);
				stream_destroy(fdout);
				stream_close(fdin);
				stream_destroy(fdin);
				continue;
			}

			if (fc->t == ~(MT_Id) 0 && 
					MT_create_thread(&fc->t, mapi_client_engine, fc) != 0) {
				GDKsyserror("MAPIlisten:mapi_client failed\n");
				fc->t = ~(MT_Id) 0;
			}
			/* (re)activate thread */
			MT_up_sema(fc->s, "MAPIlisten");
			PARDEBUG THRprintf(GDKerr, "MAPIlisten:client accepted %d\n", msgsock);
		}
end_loop:;
	} while (1);
	SSL_CTX_free(ctx);
	close(sock);
	return GDK_SUCCEED;
fail:;
	if (sock >= 0)
		close(sock);
	if (ctx)
		SSL_CTX_free(ctx);
	return GDK_FAIL;
#else
	(void) stk;
	(void) lt;
	(void) res;
	GDKerror("No SSL support\n");
	return GDK_FAIL;
#endif /* HAVE_OPENSSL */
}

int
stream_read_until(str *res, Stream *S, str stop)
{
	stream *s = *(stream **) S;
	ssize_t slen = strlen(stop);
	ptrdiff_t len = 0;
	char buf[BUFSIZ + 1], *start = buf;

	while (stream_read(s, start, 1, 1) > 0) {
		if (start - buf >= slen - 1 && strncmp(start - slen + 1, stop, slen) == 0) {
/*
				start = start-slen+1;
*/
			start++;
			break;
		}
		start++;
	}

	if (stream_errnr(s))
		return GDK_FAIL;

	len = start - buf;
	if (len > 0) {
		*res = NEW_ARRAY(char, len + 1);

		buf[len] = '\0';
		memcpy(*res, buf, len + 1);
	} else {
		*res = GDKstrdup("");
	}
	return GDK_SUCCEED;
}

int
client(Cntxt stk, YYSTREE lt, ValPtr res)
{
	mapi_frontend *f;
	stream **In, **Out;
	stream *in, *out;
	mapi_client *mc;
	Client klient;
	char *old_in; 

	CNTXTclient((Cntxt) (ptrdiff_t) stk, &klient);
	/* get the streams from the argument list */
	if (lt->cnt != 2) {
		closeClient(klient, 0);
		return handle_argerror(res, lt->cnt, 2);
	}
	@:builtin_operand(0,TYPE_Stream,In)@
	in = *In;
	@:builtin_operand(1,TYPE_Stream,Out)@
	out = *Out;
	if (in == 0) {
		GDKsyserror("client:stream-r problems\n");
		closeClient(klient, 0);
		return GDK_FAIL;
	}
	if (out == 0) {
		GDKsyserror("client:stream-w problems\n");
		closeClient(klient, 0);
		return GDK_FAIL;
	}
 	mc = xchange_challenge(klient, stk, in, out, 0);
	if (mc == NULL) {
		GDKsyserror("client:stream-w problems\n");
		closeClient(klient, 0);
		return GDK_FAIL;
	}

	f = mapi_frontends[mc->frontend];
	monetSetChannel(mc->thread, mc->c->fdin, mc->c->fdout);
	old_in = klient -> input; 
	klient->input = (str) GDKmalloc(4096);
	klient->limit = klient->input + 4096;
	klient->top = klient->input;
	*klient->top = 0;
	f->f_engine(mc);
	GDKfree(klient->input);
	klient->input = old_in;
	mapi_client_end(mc); 	
	return GDK_SUCCEED;
}


@}
@- daemon initialization
@mil
proc get_mapi_port() : int {
	if (monet_environment.exist("mapi_port")){
		return int(monet_environment.find("mapi_port"));
	}
	ERROR("mapi_port is not set\n");
}

proc get_mapi_open() : bit {
	if (monet_environment.exist("mapi_open")){
		return bit(monet_environment.find("mapi_open"));
	}
	ERROR("mapi_open is not set\n");
}

proc mapi_server() : void {
	if (monet_environment.find("gdk_embedded") = "no") {
		fork(mapi_listen(
			get_mapi_port(),
			str(nil),
			5,
			get_mapi_open()	
			)
		);
	}
}
mapi_server();

proc mil_start() : void {
	mapi_register(mil_frontend());
}
