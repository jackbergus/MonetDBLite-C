@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2007 CWI.
@' All Rights Reserved.

@f calib
@t A calibrator for Monet
@a S. Manegold
@v 0.1
@* Synopsis
The Calibrator is microbenchmark to analyze a computers (cache-) 
memory system and extract the following parameters:
@T
\begin{itemize}
\item number of cache levels
\item for each cache level:
	\begin{itemize}
        \item its size
        \item its linesize
        \item its access/miss latency
	\end{itemize}
\item main memory access latency
\item number of TLB levels
\item for each TLB level:
	\begin{itemize}
         \item its capacity (i.e. number of entries)
         \item the pagesize used
         \item the TLB miss latency
	\end{itemize}
\end{itemize}

A short description of the Calibrator is available as a
@[<a href="http://www.cwi.nl/~manegold/Calibrator/doc/calibrator.pdf">PDF</a>@ or
@[<a href="http://www.cwi.nl/~manegold/Calibrator/doc/calibrator.ps">Postscript</a>@ or
document.

See also the @[<a href="http://www.cwi.nl/~manegold/Calibrator/calibrator.shtml">Calibrator Homepage</a>@.
with a @[<a href="http://www.cwi.nl/~manegold/Calibrator/DB/DB.shtml">database</a>@ of calibrated systems.
@m
.MODULE calib;
.COMMAND calib_info() : BAT[str,dbl] = CMDcalib_info;
  "Gives results of calibrator tests as BAT. 
  First row 'ready' indicates if the tests have been performed "
.COMMAND calib_init(lng MHz, lng maxrange) : void = CMDcalib_init;
  "Runs calibrator tests with given CPU clock frequency and max memory range"
.COMMAND calib_free() : void = CMDcalib_free;
  "Frees calibrator allocated resources"

@mil
PROC calib_init(lng max_range) : void {
	return calib_init(0LL, max_range);
}

@m
.END calib;
@-
@T
Run {\tt calib_init()} once, then extract the results with {\tt calib_info()} into a BAT.
@{
@-
The remainder is a wrapper around the calibrator library.
@c
#include "monetdb4_config.h"
#include "monet.h"
#include <gdk.h>
#include    <stdlib.h>
#include	<stdio.h>
#include	<math.h>
#include	<string.h>
#include	<stdarg.h>
#ifdef HAVE_UNISTD_H
#include <unistd.h>
#endif
#ifdef HAVE_SYS_WAIT_H
#include <sys/wait.h>
#endif
#include "calib.proto.h"


#define NUMLOADS 100000
#define REDUCE	 10
#define	NUMTRIES 3
#define	MINRANGE 1024
#define MAXLEVELS 9
#define LENPLATEAU 3

#define EPSILON1 0.1
/*	#define EPSILON3 2.0	*/

/*	#define EPSILON2 0.04	*/
#define EPSILON4 1.0


/* #define CALIBRATOR_CREATE_PLOTS */
#undef CALIBRATOR_CREATE_PLOTS
/* #define CALIBRATOR_PRINT_OUTPUT */
#undef CALIBRATOR_PRINT_OUTPUT
/* #undef CALIBRATOR_CHECK_SMP */
#define CALIBRATOR_CHECK_SMP

#include "calib_common.c"
caliblng MINTIME = 10000;

#include "calib_run.c"
#include "calib_analyse.c"
/* #include "calib_plot.c" */
/* #include "calib_print.c" */
#include "calib_main.c"

static struct fullInfo *calibInfo = 0;
static caliblng MHz, maxrange;

int
CMDcalib_init(lng *setMHz, lng *setmaxrange)
{
	MHz = *setMHz;
	maxrange = *setmaxrange;
	if (calibInfo)
		freeFullInfo(calibInfo);
	calibInfo = mainRun(MHz, maxrange * 1.25, "nofile");
	return GDK_SUCCEED;
}

int
CMDcalib_info(BAT **retval)
{
	BAT *b;
	char fld[100];
	double val;
	int l;
	cacheInfo *cache;
	AssoInfo *Asso;
	TLBinfo *TLB;

	*retval = b = BATnew(TYPE_str, TYPE_dbl, 32);
	if (!b)
		return GDK_FAIL;
	val = (calibInfo != 0);
	b = BUNins(b, "ready", &val, FALSE);

	if (!calibInfo)
		return GDK_SUCCEED;
	cache = calibInfo->cache;
	Asso = calibInfo->Asso;
	TLB = calibInfo->TLB;

	if (MHz != 0) {
		val = MHz;
		b = BUNins(b, "MHz", &val, FALSE);
	}
	val = maxrange;
	b = BUNins(b, "maxrange", &val, FALSE);
#ifdef CALIBRATOR_CHECK_SMP
/* SMP info */
	val = calibInfo->smp.nrCpus;
	b = BUNins(b, "nrCpus", &val, FALSE);
#endif
/* cpu info */
	val = NSperIt(calibInfo->cache->latency1[0]);
	b = BUNins(b, "cpuloop ns", &val, FALSE);
	if (MHz != 0) {
		val = cround(CYperIt(calibInfo->cache->latency1[0]));
		b = BUNins(b, "cpuloop cc", &val, FALSE);
	}
	val = NSperIt(calibInfo->delayC);
	b = BUNins(b, "cpu delay ns", &val, FALSE);
	if (MHz != 0) {
		val = cround(CYperIt(calibInfo->delayC));
		b = BUNins(b, "cpu delay cc", &val, FALSE);
	}
/* cache info */
	val = cache->levels;
	b = BUNins(b, "cache levels", &val, FALSE);
	for (l = 0; l < cache->levels; l++) {
		sprintf(fld, "cache %d size", l + 1);
		val = cache->size[l];
		b = BUNins(b, fld, &val, FALSE);
		sprintf(fld, "cache %d linesize", l + 1);
		val = cache->linesize[l + 1];
		b = BUNins(b, fld, &val, FALSE);
		sprintf(fld, "cache %d associativity", l + 1);
		val = Asso->entries[l];
		b = BUNins(b, fld, &val, FALSE);
		sprintf(fld, "cache %d miss-latency ns", l + 1);
		val = NSperIt(cache->latency2[l + 1] - cache->latency2[l]);
		b = BUNins(b, fld, &val, FALSE);
		if (MHz != 0) {
			sprintf(fld, "cache %d miss-latency cc", l + 1);
			val = cround(CYperIt(cache->latency2[l + 1] - cache->latency2[l]));
			b = BUNins(b, fld, &val, FALSE);
		}
		sprintf(fld, "cache %d replace-time ns", l + 1);
		val = NSperIt(cache->latency1[l + 1] - cache->latency1[l]);
		b = BUNins(b, fld, &val, FALSE);
		if (MHz != 0) {
			sprintf(fld, "cache %d replace-time cc", l + 1);
			val = cround(CYperIt(cache->latency1[l + 1] - cache->latency1[l]));
			b = BUNins(b, fld, &val, FALSE);
		}
	}
/* TLB info */
	val = TLB->levels;
	b = BUNins(b, "TLB levels", &val, FALSE);
	for (l = 0; l < TLB->levels; l++) {
		sprintf(fld, "TLB %d entries", l + 1);
		val = TLB->entries[l];
		b = BUNins(b, fld, &val, FALSE);
		sprintf(fld, "TLB %d pagesize", l + 1);
		val = TLB->pagesize[l + 1];
		b = BUNins(b, fld, &val, FALSE);
		sprintf(fld, "TLB %d miss-latency ns", l + 1);
		val = NSperIt(TLB->latency2[l + 1] - TLB->latency2[l]);
		b = BUNins(b, fld, &val, FALSE);
		if (MHz != 0) {
			sprintf(fld, "TLB %d miss-latency cc", l + 1);
			val = cround(CYperIt(TLB->latency2[l + 1] - TLB->latency2[l]));
			b = BUNins(b, fld, &val, FALSE);
		}
	}
	return GDK_SUCCEED;
}


int
CMDcalib_free(void)
{
	if (!calibInfo)
		return GDK_FAIL;
	freeFullInfo(calibInfo);
	calibInfo = 0;
	return GDK_SUCCEED;
}

@}
