@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
@' Copyright August 2008-2010 MonetDB B.V.
@' All Rights Reserved.

@f decimal
@t Decimal Module
@a Peter Boncz, Martin van Dinther
@v 1.0

@+ Introduction
This module introduces the decimal atom to monet. Decimals are intended to
represent highly complex decimal numbers in a flexible way. Decimal
numbers consist of a {\em sign}, {\em number} and {\em scale} in the following
format:
\begin{verbatim}
format:  ['-'|'+'] number [ 'E' ['-'|'+'] scale ]
    or:  ['-'|'+'] [ number ] '.' number [ 'E' ['-'|'+'] scale ]
\end{verbatim}
where
\begin{description}
\item[number] is an integer consisting of maximally 16384 digits. Float notation with a dot
is also allowed (e.g. 42.3E15 = 423E14).
\item[scale] an integer from the range [-16384,16384].  If omitted, its default value is 0.
\item[precision] is the number of digits of which {\bf number} consists.
\item[value] the value of a decimal is the number multiplied by 10 to the power of the scale.
\end{description}

The interface with operations on decimals is inspired on the java.math.BigDecimal class.

Examples (small numbers for convenience):
\begin{verbatim}
  42        = 42
 -10        = -10
 127E11     = 12700000000000
-776E2      = -77600
-103E-10    = -0.0000000103
\end{verbatim}

Computations with decimals return a decimal that has a precision that is the
maximum of each of the decimal parameters of the operator. When reducing precision,
we use truncation.

In the implementation, specific care was taken in order to make bulk operations
(like hash-join and sorting) fast, as one of the foreseeable applications of
decimal columns is their use as foreign key on tables imported from another DBMS
(for imported tables, as in Monet we would preferably use the oid type as key).

@+ Definition
@m
.MODULE decimal;

.ATOM decimal;
      .TOSTR   = decimal_tostr;
      .FROMSTR = decimal_fromstr;
      .COMP    = decimal_compare;
      .HASH    = decimal_hash;
      .NULL    = decimal_null;
      .CONVERT = decimal_convert;
      .LENGTH  = decimal_length;
      .PUT     = decimal_put;
      .DEL     = decimal_del;
      .HEAP    = decimal_heap;
      .CHECK   = HEAP_check_stub;
.END;

@- construction
@m
.COMMAND "decimal" (int value) : decimal = decimal_from_int;
     "Translates an integer into a decimal."

.COMMAND "decimal" (lng value) : decimal = decimal_from_lng;
     "Translates a long into a decimal."

.COMMAND "decimal" (flt value) : decimal  = decimal_from_flt;
     "Create a decimal from a float value."

.COMMAND "decimal" (dbl value) : decimal  = decimal_from_dbl;
     "Create a decimal from a double value."

@- decomposition
@m
.COMMAND "dbl" (decimal value) : dbl = decimal_to_dbl;
     "Return the value of a decimal as a double (return dbl(nil) on overflow)."

.COMMAND "flt" (decimal value) : flt = decimal_to_flt;
     "Return the value of a decimal as a float (return flt(nil) on overflow)."

.COMMAND "int" (decimal value) : int = decimal_to_int;
     "Return the truncated value of a decimal as an integer (return int(nil) on overflow)."

.COMMAND "lng" (decimal value) : lng = decimal_to_lng;
     "Return the truncated value of a decimal as a long (return lng(nil) on overflow)."

.COMMAND "str" (decimal d, str format) : str = decimal_format;
     "Formats a decimal in a fixed-width string (truncated, if necessary).
      format = [ '+' ] ( N1 | ( N1 '.' N2 ) | ( '.' N2 ) ) [ 'E' N3 ]
       with: Nx = a number of the form [0-9]+ (possibly starting with 0)
      where: N1 = is the number of digits before the decimal point (default = 0)
             N2 = is the number of digits after the decimal point (default = 1)
             N3 = the number of digits to use for the scale (default = 2)
      A zero will be printed with only one zero digit (left space-padded), unless N1 has a
      leading zero, in which case a zero-padded number of width N1 is produced.
      If the plus at start is specified, positive numbers start with a plus. "

@- comparison
@m
.COMMAND isnil(decimal) : bit = decimal_isnil;         "decimal nil test (!DS2.2)"
.OPERATOR0 (decimal) "="  (decimal) : bit = decimal_eq; "decimal equality test (!DS2.2)"
.OPERATOR0 (decimal) "!=" (decimal) : bit = decimal_ne; "decimal non-equality test (!DS2.2)"
.OPERATOR0 (decimal) "<"  (decimal) : bit = decimal_lt; "decimal smaller-than test (!DS2.2)"
.OPERATOR0 (decimal) ">"  (decimal) : bit = decimal_gt; "decimal greater-than test (!DS2.2)"
.OPERATOR0 (decimal) "<=" (decimal) : bit = decimal_le; "decimal smaller-or-equal test (!DS2.2)"
.OPERATOR0 (decimal) ">=" (decimal) : bit = decimal_ge; "decimal greater-or-equal test (!DS2.2)"

@- arithmetic
All operators return a result decimal whose value is exactly the value of the operation,
when applied to the value of both decimal arguments. Only for division this is not possible;
as an infinite precision would in some cases be needed to describe an exact result. division
therefore truncates the result to a precision specified by the caller.
The result of all operations are always normalized by deleting all leading and trailing zeros
(and adapting the scale correspondingly).
@m
.OPERATOR (decimal val1) "+" (decimal val2) : decimal = decimal_plus;
     "Returns a decimal whose value is extactly (val1 + val2)."

.OPERATOR (decimal val1) "-" (decimal val2)  : decimal = decimal_minus;
     "Returns a decimal whose value is exactly (val1 - val2)."

.OPERATOR "-" (decimal value) : decimal = decimal_negative;
     "Returns a decimal whose value is -1 * value, with equal scale and precision as 'value'."

.COMMAND abs(decimal value) : decimal = decimal_abs;
     "Returns a decimal whose value is the absolute value of this number."

.OPERATOR1 (decimal val1) "*" (decimal val2) : decimal = decimal_multiply;
     "Returns a decimal whose value is exactly (val1 * val2)."

.OPERATOR1 (decimal val1) "/" (decimal val2) : decimal = decimal_divide_default;
     "Returns a decimal whose value is val1 DIV val2, (scale=0) like in C integer division.
      This operator can implement MOD as MOD(x,y) = x - y*DIV(d,y).
      Use the tertiary divide(num,div,prec) command for dividing with arbitrary precision.
      Division by zero returns decimal(nil)."

.COMMAND divide(decimal val1, decimal val2, int precision) : decimal = decimal_divide;
     "Returns a decimal whose value is (val1 / val2), truncated to a specified precision.
      Division by zero returns decimal(nil)."

.COMMAND pow(decimal val1, int val2, int precision) : decimal = decimal_pow;
     "Raises a decimal to the power of some integer.
      The precision argument determines the maximum precision of the result (!DS2.2)."

.COMMAND pow(decimal val1, int val2) : decimal = decimal_pow_default;
     "Raises a decimal to the power of some integer.
      The precision of the result is the precision of the decimal (!DS2.2)."

@- misc
@m
.COMMAND getprecision(decimal value) : int  = decimal_get_precision;
     "Returns the precision of this number (!DS2.2)."

.COMMAND setprecision(decimal value, int precision) : decimal  = decimal_set_precision;
     "Return the same number but with a different precision; i.e. truncated or zero-padded (!DS2.2)."

.COMMAND getscale(decimal value) : int  = decimal_get_scale;
     "Returns the scale of this number (!DS2.2)"

.COMMAND setscale(decimal value, int scale) : decimal  = decimal_set_scale;
     "Normalize the number of a decimal by setting the scale to a fixed value.
      This is compensated by making the number shorter (by truncation) or by enlarging
      it with trailing zeros (!DS2.2)."

.COMMAND addscale(decimal value, int delta) : decimal = decimal_movedot;
     "Return a  decimal with the same number as value, but with scale = value.scale + delta.
      This can be seen as shifting the dot in the floating-point value of the decimal
      to the left (delta < 0) or right (delta > 0) (!DS2.2)."

@- internal
These commands are internal to the procedures in the load section.
@m
.COMMAND bulkdivide(bat[any::1,decimal] b, decimal d, int p) : bat[any::1,decimal]
		= decimal_bulkdivide; "(!DS2.2)"
.COMMAND bulkdivide(bat[any::1,decimal] b, decimal d) : bat[any::1,decimal]
		= decimal_bulkdivide_default; "(!DS2.2)"
.COMMAND istenfold(decimal d) : bit = decimal_istenfold;
	"returns whether decimal is an exact multiple of 10 (!DS2.2)."
.COMMAND decimal_minrepeat(int x) : void = decimal_setminrepeat;
	"set number of repeating characters after which to condense decimals (!DS2.2)."



.PRELUDE = decimal_prelude;
.EPILOGUE = decimal_epilogue;

.END decimal;

@mil
    const DECIMAL_NIL     := decimal("nil");
    const DECIMAL_ZERO    := decimal("0");
    const DECIMAL_E       := decimal("2.7182818284590452354");
    const DECIMAL_LOG2E   := decimal("1.4426950408889634074");
    const DECIMAL_LOG10E  := decimal("0.43429448190325182765");
    const DECIMAL_LN2     := decimal("0.69314718055994530942");
    const DECIMAL_LN10    := decimal("2.30258509299404568402");
    const DECIMAL_PI      := decimal("3.14159265358979323846");
    const DECIMAL_PI_2    := decimal("1.57079632679489661923");
    const DECIMAL_PI_4    := decimal("0.78539816339744830962");
    const DECIMAL_1_PI    := decimal("0.31830988618379067154");
    const DECIMAL_2_PI    := decimal("0.63661977236758134308");
    const DECIMAL_2_SQRTPI:= decimal("1.12837916709551257390");
    const DECIMAL_SQRT2   := decimal("1.41421356237309504880");
    const DECIMAL_SQRT1_2 := decimal("0.70710678118654752440");

    proc "[divide]"(bat[any::1,decimal] b, decimal div, int prec) : bat[any::1,decimal] {
        if ((div = DECIMAL_ZERO) or isnil(div) or isnil(prec)) {
                return project(b, DECIMAL_NIL);
        } else if (istenfold(div)) {
                var dec := 1 - (getprecision(div) + getscale(div));
                return [setprecision]([addscale](b,dec),prec);
        }
        return bulkdivide(b, div, prec);
    }

    proc "[/]"(bat[any::1,decimal] b, decimal div) : bat[any::1,decimal] {
        if ((div = DECIMAL_ZERO) or isnil(div)) {
                return project(b, DECIMAL_NIL);
        } else if (istenfold(div)) {
                var dec := 1 - (getprecision(div) + getscale(div));
		return [setscale]([addscale](b,dec),0);
        }
        return bulkdivide(b, div);
    }

@{
@+ Implementation
There were three important design aspects for the decimal atom:
\begin{description}
\item[fixed or variable-size]
as the decimal type is intended to solve all our problems with large numbers,
the upper limit of the decimal size that can be stored should be high. Implementing
decimals as fixed-size atoms therefore would yield a very large object, that
in general will not be used fully. Hence the choice for a variable-size atom.

\item[binary or decimal storage]
we chose to represent decimals in 4-bits (i.e. 2 digits per byte) as this is both
reasonably compact and facilitates implementation of operators that are digit-oriented.
Examples of such operators are: parsing from a string input and formatting to string
output, and substring operators (for instance those that modify the precision of a number).
It is also much easier with decimal storage to implement clear rules about the precision
that is delivered by the various arithmetic operators.
Downside is the performance of computation operators (like *, /, -, +). An alternative
would have been storage in an array of binary integers. This would perform better
on the arithmetic side, but much worse on the digit-oriented tasks. Import time of
decimals from string was deemed to be very important, hence the choice for
a digit-oriented representation.

\item[join efficiency]
decimals will be often used as join columns on imported tables. This means that sorting,
merge-join and hash-join should run quickly.  These operations in turn depend on the
efficiency of the ADT compare and hash operators. To achieve efficiency, we implemented
decimal-compare and decimal-hash such that they work on 32-bits integers at-a-time. Decimals
are stored in an array of integers, where the first integer in the array holds the
digits with highest significance, etc, and within each integer, the four highest bits hold
the highest significant digit, etc.  This storage regime makes it possible to use integer
comparison when comparing decimals of the same precision; comparing 8 digits at a time.
\end{description}
@h
#ifndef _DECIMAL_H_
#define _DECIMAL_H_

typedef struct {
#if (__GNUC__ == 3)
	signed int scale:16, negative:1, precision:15;
#else
	unsigned int scale:16, negative:1, precision:15;
#endif
	unsigned int num[1];	/* array of digits: 2-digits-per-byte = 8-digits-per-integer */
	/* array extends beyond boundary */
} decimal;

#include "decimal.proto.h"	/* generated definitions by mel */

#endif /* _DECIMAL_H_ */

@-
Valid numbers have minimally 1 and maximally 16384 digits.  The valid scales are between
[-16384,16384]. There are two special values:
\begin{description}
\item[zero = +0e-32768] in order to simplify many operators, trailing zeros are removed from
decimal numbers (in that case, the number of digits is an indicator for the value of a decimal).
This has as a consequence that a zero number would not be permitted. Hence zero is treated as
a special case. Whenever a zero value decimal has to be produced, it is normalized to one canonical
form: the smallest possible positive number. This representation of zero has the benefit of that
zero does not have to be treated as a special case in the comparison operator.

\item[nil = -0xAe32767] this representation as a negative number with precision 1 consisting of
a single false digit of value 10 and an impossibly high scale, forces the nil value to be smaller
than any other decimal (again avoiding having to treat it as a special case in the compare).
\end{description}
@c
#include "monetdb4_config.h"
#include "decimal.h"

/* lookup tables that avoid having to divide and mod by 10 all the time */
unsigned char mult_table[10 * 16], plus_table[10 * 16], minus_table[10 * 16], div_table[9 * 128];
unsigned short val_table[10000];	/* 4-digit shorts with numbers from 0000 to 9999 */

#define PRECISION_MAX	16384
#define SCALE_MAX	16384
#define SCALE_MIN	(-16384)
#define HI(x)		LO((x)>>4)
#define LO(x)		((x)&15)
#define MULT(x,y)	mult_table[((x)<<4)+(y)]
#define MULT10(x)	(((x) << 3) + ((x) << 1))
#define ADD(x,y)	plus_table[((x)<<4)+(y)]
#define MINUS(x,y)	minus_table[((x)<<4)+(y)]
#define DIV(x,y)	div_table[(((y)-1)<<7)+(x)]
#define NUM(d,x)	(d)->num[(x) >> 3]
#define POS(x)		((7 - ((x) & 7)) << 2)
/* marco MASK seems to be defined in some header file on MacOS X/Darwin,
 * hence, we call it MASK_, here. */
#define MASK_(x)	(15U << POS(x))
#define GETNUM(d,x)	LO((NUM(d,x) & MASK_(x)) >> POS(x))
#define SETNUM(d,x,y)	NUM(d,x) = ((y) << POS(x)) | (NUM(d,x) & ~MASK_(x))
#define PREC(d)		((int)(sht)((d)->precision))	
#define SCALE(d)	((int)(sht)((d)->scale))	
#define ISNIL(d)	(SCALE(d) > SCALE_MAX)
#define ISZERO(d)	((d)->num[0] == 0)

/* number of ints in num field */
#define NUMLEN(x)	((((x)-1) >> 3) + 1)

/* total size in bytes of allocated structure */
/* in certain cases it is not necessary to check the upper bound, so
   provide a macro */
#define TOTLEN_NOMAXCHECK(x) (sizeof(decimal)+((NUMLEN(MAX((x),1))-1)<<2))
#define TOTLEN(x) TOTLEN_NOMAXCHECK(MIN(PRECISION_MAX,(x)))

#define DECIMAL_AVGSIZE 12

/* materialized constants */
decimal *decimal_nil = NULL, *decimal_one, *decimal_zero;
decimal *decimal_int_min, *decimal_int_max;
decimal *decimal_lng_min, *decimal_lng_max;
decimal *decimal_flt_min, *decimal_flt_max;
decimal *decimal_dbl_min, *decimal_dbl_max;
int decimal_minrepeat = 2000000000;

/* stub to get import/export declarations on Windows correct */
int
HEAP_check_stub(Heap *h, HeapRepair *hr)
{
	return HEAP_check(h, hr);
}

/* 10-folds are recognized by a leading one and all trailing zeros */
static INLINE int
ISTENFOLD(decimal *d)
{
	unsigned int *src = d->num;
	unsigned int *dst = src + NUMLEN(PREC(d));

	if (*src == (1 << 28))
		do {
			if (++src == dst)
				return 1;
		} while (*src == 0);
	return 0;
}

@- debugging
The Monet debug mask 131072 enables decimal debugging, which will print the
input and output parameters of all relevant decimal routines, and also check
them for corruption.
@c
char decimal_global_buf[1024];

#define DECIMAL_DEBUG(d,t,c)	if (GDKdebug&131072) decimal_debug(d,t,c)
#define FORMAT(f,s)		((sprintf(decimal_global_buf,f,s)||1)?decimal_global_buf:NULL)

static void
decimal_debug(decimal *d, str tag, int check)
{
	int x = 0, y, precision = PREC(d), scale = SCALE(d);

	if (tag) {
		printf("%s=", tag);
	}
	/* try to print it as good as you can */
	if (ISNIL(d)) {
		printf("nil\n");
		x = 1;
		precision = 1;
	} else if (ISZERO(d)) {
		printf("0\n");
		x = 1;
		precision = 1;
	} else {
		char buf[128], *t = buf, *s = t;

		if (precision == 0 || precision > PRECISION_MAX) {
			GDKerror("decimal_debug: illegal precision %d: == 0 || > %d.\n", PREC(d), PRECISION_MAX);
			if (precision)
				precision = 8;
		}
		if (scale < SCALE_MIN || scale > SCALE_MAX) {
			GDKerror("decimal_debug: illegal scale %d: < %d || > %d.\n", scale, SCALE_MIN, SCALE_MAX);
			scale = 0;
		}
		if (precision + 8 > 128) {
			t = s = (str) GDKmalloc(PREC(d) + 8);
		}
		if (d->negative) {
			*s++ = '-';
		}
		for (x = 0; x < precision; x++) {
			*s++ = "0123456789ABCDEF"[GETNUM(d, x)];
		}
		x = 0;
		if (scale != 0) {
			sprintf(s, "E%d", scale);
		} else {
			*s = 0;
		}
		puts(t);
		if (buf != t)
			GDKfree(t);
		x = 0;
	}
	for (y = 0; y < PREC(d); y++) {
		if (GETNUM(d, 0))
			break;
	}
	/* do the checking */
	if (check) {
		if (ISZERO(d) && y < PREC(d)) {
			GDKerror("decimal_debug: leading zeros in nonzero value.\n");
		}
		if (ISZERO(d) && PREC(d) != 1) {
			GDKerror("decimal_debug: zero has illegal precision %d.\n", PREC(d));
		}
		if (ISZERO(d) && SCALE(d) != 2 * SCALE_MIN) {
			GDKerror("decimal_debug: zero has illegal scale: %d != %d.\n", SCALE(d), 2 * SCALE_MIN);
		}
		for (y = NUMLEN(precision) << 2; x < y; x++) {
			unsigned int z = GETNUM(d, x);	/* z >= 0 due to GETNUM impl. */

			if (x >= PREC(d) ? z != 0 : z > 9) {
				GDKerror("decimal_debug: garbage %d at position %d.\n", z, x);
			}
		}
	}
}

@-
decimal_create() is the vanilla routine that allocates a new empty decimal
with a given precision, scale and sign. It is implemented by decimal_alloc,
that can also create the decimal in a preallocated buffer.
@c
#define decimal_create(precision, scale, sign) decimal_alloc(precision, scale, sign, NULL, NULL)
static decimal *
decimal_alloc(int precision, int scale, int sign, decimal *d, int *size)
{
	int len = TOTLEN(precision);

/*printf("!- decimal_alloc(%d, %d, %d): len=%d\n",precision,scale,sign,len);*/

	if (d && *size < len) {
/*printf("!- 1)\n");*/
		GDKfree(d);
		d = NULL;
	}
	if (d == NULL) {
/*printf("!- 2)\n");*/
		d = (decimal *) GDKmalloc(len);
		if (size)
			*size = len;
	}
	if (scale < SCALE_MIN || scale > SCALE_MAX || precision < 0 || precision > PRECISION_MAX) {
/*printf("!- 3) nil\n");*/
		/* generate a nil */
		*d = *decimal_nil;
	} else if (precision == 0) {
		/* generate a zero */
		d->num[0] = 0;
		d->precision = 1;
		d->scale = 2 * SCALE_MIN;
		d->negative = 0;
/*printf("!- 4) zero: %u, %d, %d, %d\n",d->num[0],PREC(d),SCALE(d),d->negative);*/
	} else {
		/* generate a decimal with empty number, and set fields */
		unsigned int *src = d->num;
		unsigned int *dst = src + NUMLEN(precision);

		d->precision = precision;
		d->scale = scale;
		d->negative = sign;
		while (src < dst)
			*src++ = 0;
/*printf("!- 5) %u, %d, %d, %d\n",d->num[0],PREC(d),SCALE(d),d->negative);*/
	}
	return d;
}

@-
Remove both leading and optionally the trailing zeros into a new decimal d (d==v is allowed).
The new decimal may be optionally truncated or enlarged (padded with trailing zeros), if
so specified in the third parameter. When trailing zeros have to be deleted, we do this in
one go and adapt the scale accordingly (10 becomes 1E1).  A special case caught here is the 0
value, which is required to have precision 1 and sign positive (this will override a given
minimum precision parameter).
@c
static INLINE void
decimal_normalize(decimal *d, decimal *v, int offset, int fixed_precision, int del_trailing)
{
	int x = offset, precision, first_nonzero = 0, last_nonzero = PREC(v);

	DECIMAL_DEBUG(v, "decimal_normalize() input", 1);

	/* find the first nonzero digit from the start */
	for (first_nonzero = 0; first_nonzero < PREC(v); first_nonzero++) {
		if (GETNUM(v, first_nonzero) != 0)
			break;
	}

	/* find the last nonzero digit from the end */
	if (del_trailing)
		for (x = first_nonzero; x < PREC(v); x++) {
			if (GETNUM(v, x) != 0)
				last_nonzero = x + 1;
		}

	/* determine the new precision */
	precision = offset + last_nonzero - first_nonzero;
	if (fixed_precision && fixed_precision < precision) {
		last_nonzero += fixed_precision - precision;
		precision = fixed_precision;
	}

	/* copy the first precision nonzero digits */
	for (x = offset; x < precision; x++) {
		SETNUM(d, x, GETNUM(v, first_nonzero + x - offset));
	}

	/* pad the total rest of d with zeros (for consistency) */
	for (; x < PREC(d); x++) {
		SETNUM(d, x, 0U);
	}

	/* fill in the fields */
	if (precision == 0) {
		*d = *decimal_zero;
	} else {
		/* PREC(d) can be > precision; rest is then padded by 0s */
		d->negative = v->negative;
		d->scale = SCALE(v) + (PREC(v) - last_nonzero);
		d->precision = precision;
		if (fixed_precision > precision && !del_trailing) {
			d->scale -= fixed_precision - precision;
			d->precision = fixed_precision;
		}
	}
	DECIMAL_DEBUG(d, "decimal_normalize() result", 1);
}

@-
decimal_copy() delivers a new decimal based on a parameter but with a decimal precision.
For adapting the precision it relies on decimal_normalize(), but it does some checking beforehand.
@c
static decimal *
decimal_copy(decimal *v, int precision)
{
	decimal *d = decimal_create(precision, 0, 0);

	DECIMAL_DEBUG(v, FORMAT("decimal_copy(precision=%d) input", precision), 0);

	if (ISNIL(v) || precision < 0 || precision > PRECISION_MAX) {
		*d = *decimal_nil;
	} else if (precision == 0) {
		*d = *decimal_zero;
	} else {
		decimal_normalize(d, v, 0, precision, FALSE);
	}

	DECIMAL_DEBUG(d, FORMAT("decimal_copy(precision=%d) result", precision), 0);
	return d;
}

@- ADT functions
The below ADT function implementations are required when adding a new atom type to Monet.
@c
int
decimal_fromstr(str buf, int *len, decimal **ret)
{
	int comma = 0, scale = 0, sign = 0, precision = 0, started = 0, scale_neg = 0;
	int c = 0, x = (int) sizeof(int), pos, repeat = 0, *rp = &repeat;
	char *base = buf, *cur = buf, *dst, cpy[PRECISION_MAX];

#if 0
	char *last = NULL;
#endif

	dst = cpy;

	/* scan number string and copy the relevant parts to cpy */
	if (*cur == '-' || (*cur == '+')) {
		sign = (*cur == '-');
		cur++;
		base++;
	}
	while (*cur) {
		if (repeat > 0) {
			repeat--;
		} else {
			c = *cur++;
		}
		if (c == '(') {
			pos = intFromStr(cur, &x, &rp);
			cur += pos;
			if (pos == 0 || repeat < 0 || decimal_minrepeat > repeat || strncmp(cur, " times ", 7) || !GDKisdigit(cur[7]) || cur[8] != ')') {
				dst = cpy;
				break;	/* syntax error */
			}
			c = cur[7];
			cur += 8;
		} else if (comma == 0 && c == '.') {
			comma = 1;
		} else {
			if (!GDKisdigit(c)) {
				cur--;
				break;
			}
			if (comma) {
				comma++;	/* correct scale for each digit after the comma */
			}
			if (!started) {
				if (c == '0') {
					continue;	/* ignore leading zeros */
				} else {
					started = 1;
				}
			}
			if ((dst - cpy) < PRECISION_MAX) {
				*dst++ = c;	/* copy digit into buffer */
#if 0
				if (c != '0') {
					last = dst;
				}
#endif
			}
			precision++;
		}
	}
	if (comma)
		comma--;

	if (cur <= base) {
		precision = -1;	/* will force a nil decimal */
	} else if ((c == 'E' || c == 'e')) {
		/* scan the E part */
		if (*(++cur) == '-') {
			cur++;
			scale_neg = 1;
		} else if (*cur == '+')
			cur++;
		while (GDKisdigit(*cur)) {
			if (scale - comma <= SCALE_MAX) {
				scale = (*cur - '0') + MULT10(scale);
			}
			cur++;
		}
		if (scale_neg)
			scale = -scale;
	}
	if (!started && cur > base) {
		cpy[0] = '0';
	}
#if 0
/* delete trailing zeros
	else if (last && precision > 0) {
		precision -= dst - last;
		comma -= dst - last;
	}
*/
#endif

	/* allocate the decimal. invalid parameters will produce a nil */
	*ret = decimal_alloc(precision, scale - comma, sign, *ret, len);
	if (!ISNIL(*ret)) {
		for (x = 0; x < precision; x++) {
			SETNUM((*ret), x, (unsigned) (cpy[x] - '0'));
		}
	}
	DECIMAL_DEBUG(*ret, FORMAT("decimal_fromstr(%s) result", buf), 1);
	return (int) (cur - buf);
}

int
decimal_tostr(str *buf, int *len, decimal *v)
{
	if (*len < PREC(v) + 7) {
		if (*buf)
			GDKfree(*buf);
		*buf = (str) GDKmalloc(*len = PREC(v) + 7);
	}
	if (ISNIL(v)) {
		strcpy(*buf, "nil");
	} else if (ISZERO(v)) {
		strcpy(*buf, "0");
	} else {
		int x, val, lastval = -1, repeat = 0;
		str s = *buf;

		if (v->negative) {
			*s++ = '-';
		}
		for (x = 0; x < PREC(v); x++, repeat++) {
			val = GETNUM(v, x) + '0';
			if (val != lastval) {
				if (repeat > decimal_minrepeat) {
					s -= repeat;
					sprintf(s, "(%d times %c)", repeat, lastval);
					s += strlen(s);
				}
				lastval = val;
				repeat = 0;
			}
			*s++ = val;
		}
		if (repeat > decimal_minrepeat) {
			s -= repeat;
			sprintf(s, "(%d times %c)", repeat, lastval);
			s += strlen(s);
		}
		if (SCALE(v) != 0) {
			sprintf(s, "E%d", SCALE(v));
		} else {
			*s = 0;
		}
	}
	DECIMAL_DEBUG(v, FORMAT("decimal_tostr(->%s) input", *buf), 1);
	return (int) strlen(*buf);
}

int
decimal_setminrepeat(int *x)
{
	decimal_minrepeat = *x;
	return GDK_SUCCEED;
}

/* Format a decimal in a string a a float with a fixed number of digits before and after the comma. */
int
decimal_format(str *ret, decimal *d, str format)
{
	chr start = ' ', pad = ' ';
	str s = format;
	int n1 = 0, n2 = 0, n3 = 0, x, y = 0;

	/* scan the format string */
	if (*s == '+') {
		start = '+';
		s++;
	}
	if (*s == '.') {
		n1 = 1;
	} else {
		if (*s == '0')
			pad = '0';
		if (!GDKisdigit(*s)) {
			n1 = -1;
		} else
			do {
				n1 = (*s++ - '0') + MULT10(n1);
			} while (GDKisdigit(*s));
	}
	if (*s == '.') {
		s++;
		if (!GDKisdigit(*s)) {
			n2 = -1;
		} else
			do {
				n2 = (*s++ - '0') + MULT10(n2);
			} while (GDKisdigit(*s));
	} else {
		n2 = 0;
	}
	if (*s == 'e' || *s == 'E') {
		s++;
		if (!GDKisdigit(*s)) {
			n3 = -1;
		} else
			do {
				n3 = (*s++ - '0') + MULT10(n3);
			} while (GDKisdigit(*s));
	} else {
		n3 = 2;
	}

	/* check && alloc if ok */
	if (n1 < 0 || n2 < 0 || (n1 + n2) == 0 || (n1 + n2) > PRECISION_MAX || n3 <= 0 || n3 > 9) {
		GDKerror("decimal_format: illegal format '%s'.\n", format);
		return GDK_FAIL;
	}
	s = (*ret) = (str) GDKmalloc(1 + n1 + 1 + n2 + 2 + n3 + 1);

	/* format the decimal */
	if (ISNIL(d)) {
		for (x = 0; x < n1 + n2 - 1; x++) {
			*s++ = ' ';
		}
		strcpy((char *) s, "nil");
	} else {
		if (ISZERO(d) && pad == ' ') {
			for (x = 0; x < n1 - 1; x++) {
				*s++ = ' ';
			}
			strcpy((char *) s, "0");
			y = 0;
		} else {
			*s++ = (d->negative) ? '-' : start;
			for (x = 0; x < n1; x++) {
				unsigned int num = (x < PREC(d)) ? GETNUM(d, x) : 0;

				*s++ = num + '0';
			}
		}
		if (n2) {
			*s++ = '.';
			for (; x < n1 + n2; x++) {
				unsigned int num = (x < PREC(d)) ? GETNUM(d, x) : 0;

				*s++ = num + '0';
			}
		}
		if (!ISZERO(d)) {
			y = SCALE(d) + PREC(d) - n1;
		}
		if (y) {
			char f[5];

			f[0] = '%';
			f[1] = '0';
			f[2] = '0' + n3;
			f[3] = 'd';
			f[4] = 0;
			*s++ = 'E';
			*s++ = (y > 0) ? '-' : '+';
			sprintf((char *) s, f, y);
		} else {
			*s = 0;
		}
	}
	return GDK_SUCCEED;
}

@-
Hash and compare are made fast by implementing them as integer operations. That is, they
look at the digit string as if it as an array of integers. In fact, each integer contains
8 digits. The digits are placed in such a way that integer comparison can be used to compare
8 digits substrings (by placing the first digit in the highest 4-bits of the integer, etc).

Hash and compare are tricky as we need ensure that numbers with the same *value* are
seen as equal and get the same hash value. Note that 10E1 == 100E0, etc. This behavior
is obtained by adding precision and base as start hash value (i.e. the number of digits
before the comma, which is both 2 for 10E1 and 100).  Important to know is that we ensure
that a decimal has never leading zeros (except for the 0 value, which is always represented
with scale=0, precision=1 and negative=0), So, equal numbers have the same starting digit
string, but may only differ by trailing zeros. The hash function ignores series of zero
digits, hence is immune for such differences. The compare function adds imaginary zeros at
the shorter digit string to obtain the same effect.
@c
BUN
decimal_hash(decimal *d)
{
	unsigned int *src = d->num;
	unsigned int *dst = src + NUMLEN(PREC(d));
	BUN y = PREC(d) + SCALE(d);

	while (src < dst) {
		unsigned int val = *src++;

		if (val) {
			unsigned int x = ((val & (15U << 28)) >> 28);

			x = MULT10(x) + ((val & (15U << 24)) >> 24);
			x = MULT10(x) + ((val & (15U << 20)) >> 20);
			x = MULT10(x) + ((val & (15U << 16)) >> 16);
			x = MULT10(x) + ((val & (15U << 12)) >> 12);
			x = MULT10(x) + ((val & (15U << 8)) >> 8);
			x = MULT10(x) + ((val & (15U << 4)) >> 4);
			x = MULT10(x) + ((val & 15U));
			y ^= mix_int(x);
		}
	}
	if (d->negative)
		y = ~y;
	DECIMAL_DEBUG(d, FORMAT("decimal_hash(->" BUNFMT ") input", y), 1);
	return y;
}

int
decimal_compare(decimal *v1, decimal *v2)
{
	unsigned int d1 = PREC(v1) + SCALE(v1);
	unsigned int d2 = PREC(v2) + SCALE(v2);
	int res = 0;

	if (v2->negative != v1->negative) {
		res = 1;
	} else if (d1 != d2) {
		res = d1 - d2;
	} else {
		unsigned int *p1 = v1->num;
		unsigned int *p2 = v2->num;
		unsigned int *q1 = p1 + NUMLEN(PREC(v1));
		unsigned int *q2 = p2 + NUMLEN(PREC(v2));

		while (p1 < q1 || p2 < q2) {
			d1 = (p1 < q1) ? *p1 : 0;
			d2 = (p2 < q2) ? *p2 : 0;
			p1++;
			p2++;
			if (d1 < d2) {
				res = -1;
				break;
			} else if (d1 > d2) {
				res = 1;
				break;
			}
		}
	}
	if (v1->negative) {
		res = -res;
	}
	DECIMAL_DEBUG(v1, FORMAT("decimal_compare(->%d) left", res), 1);
	DECIMAL_DEBUG(v2, FORMAT("decimal_compare(->%d) right", res), 1);
	return res;
}

decimal *
decimal_null(void)
{
	if (decimal_nil == NULL) {
		decimal_prelude();
	}
	return decimal_nil;
}

int
decimal_length(decimal *d)
{
	return TOTLEN_NOMAXCHECK(PREC(d));
}

void
decimal_convert(decimal *d, int dummy)
{
	int *src = (int *) d, *dst = (int *) (((char *) d) + TOTLEN_NOMAXCHECK(PREC(d)));
	short *s = (short *) d;

	(void) dummy;
	s[0] = short_int_SWAP(s[0]);
	s[1] = short_int_SWAP(s[1]);
	while (++src < dst) {
		*src = normal_int_SWAP(*src);
	}
}

void
decimal_heap(Heap *h, size_t capacity)
{
	HEAP_initialize_compact(h, capacity * DECIMAL_AVGSIZE, 0, 0, (int (*)(ptr)) decimal_length);
}

void
decimal_del(Heap *h, var_t *idx)
{
	HEAP_free(h, *idx);
}

var_t
decimal_put(Heap *h, var_t *bun, decimal *val)
{
	decimal *dst;
	int len = TOTLEN_NOMAXCHECK(PREC(val));
	unsigned int *src = val->num;
	unsigned int *end = (unsigned int *) (((char *) src) + len - sizeof(int));

	DECIMAL_DEBUG(val, "decimal_put() input", 1);
	*bun = HEAP_malloc(h, len);
	dst = (decimal *) (h->base + (*bun << GDK_VARSHIFT));
	if (*bun) {
		unsigned int *d = dst->num;

		*dst = *val;
		while (src < end)
			*d++ = *src++;
	}
	DECIMAL_DEBUG((decimal *) dst, "decimal_put() result", 1);
	return *bun;
}

@- operator implementations
@c
bat *
decimal_prelude(void)
{
	int x, y, z, r, s = 0;

	if (decimal_nil) {
		return NULL;
	}
	/* setup the lookup tables; our alorithms never do %10 and /10 (expensive operators) */
	for (x = 0; x < 10; x++) {
		for (y = 0; y < 10; y++) {
			/* val_table contains 4-digit substring representing [0-9999] */
			for (z = 0; z < 10; z++) {
				for (r = 0; r < 10; r++, s++) {
					val_table[s] = (r << 12) | (z << 8) | (y << 4) | x;
				}
			}

			z = (x << 4) + y;

			/* mult_table contains HI and LO result of [0-9] * [0-9] */
			r = x * y;
			mult_table[z] = (r / 10) << 4 | r % 10;

			/* plus-table contains HI and LO result of [0-9] + [0-9] */
			plus_table[z] = ((x + y) / 10) << 4 | (x + y) % 10;

			/* minus_table contains HI and LO result of [0-9] - [0-9] */
			minus_table[z] = ((x - y) < 0) ? (1 << 4) + 10 + x - y : x - y;
		}
		/* div_table contains HI and LO result of [0-9] / [1-9] normalized to [1-9] */
		if (x > 0) {
			for (y = 0; y < 100; y++) {
				int dv = y / x;

				div_table[((x - 1) << 7) + y] = MAX(MIN(dv, 9), 1);
			}
		}
	}

	/* nil is a normally impossible value; compare identifies it as the smallest decimal */
	decimal_nil = decimal_create(2, 0, 0);
	decimal_nil->scale = 2 * SCALE_MAX - 1;
	decimal_nil->negative = 1;
	SETNUM(decimal_nil, 0, 10U);
	DECIMAL_DEBUG(decimal_nil, "decimal_nil", 1);

	decimal_zero = decimal_create(0, 0, 0);
	DECIMAL_DEBUG(decimal_zero, "decimal_zero", 1);

	decimal_one = decimal_create(1, 0, 0);
	SETNUM(decimal_one, 0, 1U);
	DECIMAL_DEBUG(decimal_one, "decimal_one", 1);

	/* create decimals representing the maximum and minimum values of scalar types */
	decimal_fromstr("-2147483648", &y, &decimal_int_min);
	decimal_int_max = decimal_copy(decimal_int_min, PREC(decimal_int_min));
	decimal_int_max->negative = 0;

	decimal_fromstr("-3.402823466E+38F", &y, &decimal_flt_min);
	decimal_flt_max = decimal_copy(decimal_flt_min, PREC(decimal_flt_min));
	decimal_flt_max->negative = 0;

	decimal_fromstr("-9223372036854775808", &y, &decimal_lng_min);
	decimal_lng_max = decimal_copy(decimal_lng_min, PREC(decimal_lng_min));
	decimal_lng_max->negative = 0;

	decimal_fromstr("-1.7976931348623157E+308", &y, &decimal_dbl_min);
	decimal_dbl_max = decimal_copy(decimal_dbl_min, PREC(decimal_dbl_min));
	decimal_dbl_max->negative = 0;

	return NULL;
}

void
decimal_epilogue(void)
{
	GDKfree(decimal_nil);
	GDKfree(decimal_zero);
	GDKfree(decimal_one);
	GDKfree(decimal_int_min);
	GDKfree(decimal_int_max);
	GDKfree(decimal_flt_min);
	GDKfree(decimal_flt_max);
	GDKfree(decimal_lng_max);
	GDKfree(decimal_lng_min);
	GDKfree(decimal_dbl_min);
	GDKfree(decimal_dbl_max);
	decimal_nil = NULL;
}

@= decimal_cmp
int
decimal_@1(bit *ret, decimal *v1, decimal *v2)
{
        if (decimal_compare(v1, decimal_nil) && decimal_compare(v2, decimal_nil)) {
                *ret = (decimal_compare(v1, v2) @2 0);
        } else {
                *ret = bit_nil;
        }
        return GDK_SUCCEED;
}
@c
@:decimal_cmp(eq,==)@
@:decimal_cmp(ne,!=)@
@:decimal_cmp(lt,<)@
@:decimal_cmp(gt,>)@
@:decimal_cmp(le,<=)@
@:decimal_cmp(ge,>=)@

int
decimal_isnil(bit *ret, decimal *v1)
{
	*ret = (decimal_compare(v1, decimal_nil) == 0);
	return GDK_SUCCEED;
}

/* Translates a long into a decimal (no overflow possible). */
int
decimal_from_lng(decimal **ret, lng *val)
{
	if (*val == lng_nil) {
		*ret = decimal_create(-1, 0, 0);
	} else if (*val == (lng) 0) {
		*ret = decimal_create(0, 0, 0);
	} else {
		int x = 0, y = 0, rest = 0, precision = 0, sign = 0;
		sht num[PRECISION_MAX / 4];
		lng l = *val;
		decimal *d;

		num[0] = 0;
		if (l < 0) {
			sign = TRUE;
			l = -l;
		}
		if (l == 0) {
			precision = 1;
		} else {
			while (l > 0) {
				lng dv = l / 10000;	/* uhff1 */

				rest = (int) (l - dv * 10000);
				num[y++] = val_table[rest];	/* uhff2 */
				l = dv;
			}
			precision = y-- << 2;
			if (rest < 10) {
				precision -= 3;
				x = 12;
			} else if (rest < 100) {
				precision -= 2;
				x = 8;
			} else if (rest < 1000) {
				precision--;
				x = 4;
			}
		}
		d = *ret = decimal_create(precision, 0, sign);
		for (precision = 0; precision < PREC(d); precision++) {
			unsigned int value = (num[y] & (15U << x)) >> x;

			SETNUM(d, precision, value);
			if ((x += 4) > 12) {
				x = 0;
				y--;
			}
		}
	}
	DECIMAL_DEBUG(*ret, FORMAT("decimal_from_lng(" LLFMT ") result", *val), 1);
	return GDK_SUCCEED;
}

/* Create a decimal with an integer value (no overflow possible). */
int
decimal_from_int(decimal **ret, int *val)
{
	lng l = (*val == int_nil) ? lng_nil : *val;

	return decimal_from_lng(ret, &l);
}

/* Translates a double into a decimal and a certain precision. */
int
decimal_from_dbl(decimal **ret, dbl *val)
{
	if (*val == dbl_nil) {
		*ret = decimal_create(-1, 0, 0);
	} else if (*val == 0.0) {
		*ret = decimal_create(0, 0, 0);
	} else {
		char buf[64];
		int zero = 0;

		snprintf(buf, sizeof(buf), "%.17g", *val);
		decimal_fromstr(buf, &zero, ret);
	}
	return GDK_SUCCEED;
}

/* Create a decimal from a float value and a certain precision. */
int
decimal_from_flt(decimal **ret, flt *val)
{
	if (*val == flt_nil) {
		*ret = decimal_create(-1, 0, 0);
	} else if (*val == 0.0) {
		*ret = decimal_create(0, 0, 0);
	} else {
		char buf[32];
		int zero = 0;

		snprintf(buf, sizeof(buf), "%.9g", *val);
		decimal_fromstr(buf, &zero, ret);
	}
	return GDK_SUCCEED;
}

static lng
long_value(decimal *val, int digits, int padding)
{
	lng l = 0;
	int x;

	for (x = 0; x < digits; x++) {
		l = GETNUM(val, x) + MULT10(l);
	}
	for (x = 0; x < padding; x++) {
		l = MULT10(l);
	}
	return (val->negative) ? -l : l;
}

/* Return the truncated value of a decimal as a long (return lng(nil) on overflow). */
int
decimal_to_lng(lng *ret, decimal *val)
{
	if (ISNIL(val) || decimal_compare(val, decimal_lng_max) >= 0 || decimal_compare(val, decimal_lng_min) < 0) {
		*ret = lng_nil;
	} else {
		int padding = 0, digits = PREC(val);

		if (SCALE(val) < 0) {
			digits += SCALE(val);
		} else {
			padding = SCALE(val);
		}
		*ret = long_value(val, digits, padding);
	}
	DECIMAL_DEBUG(val, FORMAT("decimal_to_lng(->" LLFMT ") result", *ret), 1);
	return GDK_SUCCEED;
}

/* Return the truncated value of a decimal as an integer (return int(nil) on overflow). */
int
decimal_to_int(int *ret, decimal *val)
{
	if (ISNIL(val) || decimal_compare(val, decimal_int_max) >= 0 || decimal_compare(val, decimal_int_min) < 0) {
		*ret = int_nil;
	} else {
		lng l;

		decimal_to_lng(&l, val);
		*ret = (int) l;
	}
	return GDK_SUCCEED;
}

dbl pow10_table[8] = { 1.0, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, 10000000.0 };

/* Return the value of a decimal as a double (return dbl(nil) on overflow). */
int
decimal_to_dbl(dbl *ret, decimal *val)
{
	if (ISNIL(val) || decimal_compare(val, decimal_dbl_max) >= 0 || decimal_compare(val, decimal_dbl_min) < 0) {
		*ret = dbl_nil;
	} else {
		int scale = SCALE(val) + PREC(val) - MIN(PREC(val), 18);
		int itr = ABS(scale);
		dbl value = (dbl) long_value(val, MIN(18, PREC(val)), 0);
		dbl scl = pow10_table[itr & 7];

		for (itr >>= 3; itr; itr--) {
			scl *= 100000000.0;
		}
		if (scale < 0) {
			value /= scl;
		} else {
			value *= scl;
		}
		*ret = value;
	}
	DECIMAL_DEBUG(val, FORMAT("decimal_to_dbl(->%g) result", *ret), 1);
	return GDK_SUCCEED;
}

/* Return the value of a decimal as a double (return flt(nil) on overflow). */
int
decimal_to_flt(flt *ret, decimal *val)
{
	if (ISNIL(val) || decimal_compare(val, decimal_flt_max) >= 0 || decimal_compare(val, decimal_flt_min) < 0) {
		*ret = flt_nil;
	} else {
		dbl d;

		decimal_to_dbl(&d, val);	/* no overflow possible */
		*ret = (flt) d;
	}
	return GDK_SUCCEED;
}

@- misc operators
@c
/* Returns a decimal whose value is -1 * value. */
int
decimal_negative(decimal **ret, decimal *val)
{
	DECIMAL_DEBUG(val, "decimal_negative() val", 1);

	if (ISNIL(val) || ISZERO(val)) {
		(*ret) = decimal_copy(val, PREC(val));
	} else {
		*ret = decimal_create(PREC(val), 0, 0);
		decimal_normalize(*ret, val, 0, PREC(val), TRUE);
		(*ret)->negative = !(*ret)->negative;
	}
	DECIMAL_DEBUG(*ret, "decimal_negative() result", 1);
	return GDK_SUCCEED;
}

/* Returns a decimal whose value is the absolute value of this number. */
int
decimal_abs(decimal **ret, decimal *val)
{
	DECIMAL_DEBUG(val, "decimal_abs() val", 1);

	if (ISNIL(val) || ISZERO(val)) {
		(*ret) = decimal_copy(val, PREC(val));
	} else {
		*ret = decimal_create(PREC(val), 0, 0);
		decimal_normalize(*ret, val, 0, PREC(val), TRUE);
		(*ret)->negative = 0;
	}
	DECIMAL_DEBUG(*ret, "decimal_abs() result", 1);
	return GDK_SUCCEED;
}

/* Return the same number but with a different scale. */
int
decimal_set_scale(decimal **ret, decimal *val, int *scale)
{
	int delta = (ISNIL(val) || ISZERO(val)) ? 0 : SCALE(val) - *scale;

	DECIMAL_DEBUG(val, FORMAT("decimal_set_scale(%d) input", *scale), 1);

	*ret = decimal_copy(val, MAX(0, (PREC(val) + delta)));

	DECIMAL_DEBUG(*ret, FORMAT("decimal_set_scale(%d) result", *scale), 1);
	return GDK_SUCCEED;
}

int
decimal_movedot(decimal **ret, decimal *val, int *delta)
{
	DECIMAL_DEBUG(val, FORMAT("decimal_movedot(%d) input", *delta), 1);

	if (ISZERO(val)) {
		*ret = decimal_copy(decimal_zero, 1);
	} else if (ISNIL(val) || (SCALE(val) + *delta) < SCALE_MIN || (SCALE(val) + *delta) > SCALE_MAX) {
		*ret = decimal_copy(decimal_nil, 1);
	} else {
		*ret = decimal_copy(val, PREC(val));
		(*ret)->scale += *delta;
	}
	DECIMAL_DEBUG(*ret, FORMAT("decimal_movedot(%d) result", *delta), 1);
	return GDK_SUCCEED;
}

/* Return the same number but with a different precision (truncated or zero-padded). */
int
decimal_set_precision(decimal **ret, decimal *val, int *precision)
{
	int delta = (ISNIL(val) || ISZERO(val)) ? 0 : *precision;

	DECIMAL_DEBUG(val, FORMAT("decimal_set_precision(%d) input", *precision), 1);

	*ret = decimal_copy(val, delta);

	DECIMAL_DEBUG(*ret, FORMAT("decimal_set_precision(%d) result", *precision), 1);
	return GDK_SUCCEED;
}

/* Returns the scale of this number. */
int
decimal_get_scale(int *ret, decimal *val)
{
	*ret = ISNIL(val) ? int_nil : ISZERO(val) ? 0 : SCALE(val);

	DECIMAL_DEBUG(val, FORMAT("decimal_get_scale(scale->%d) input", *ret), 1);
	return GDK_SUCCEED;
}

/* Returns the precision of this number. */
int
decimal_get_precision(int *ret, decimal *val)
{
	*ret = ISNIL(val) ? int_nil : PREC(val);

	DECIMAL_DEBUG(val, FORMAT("decimal_get_precision(precision->%d) input", *ret), 1);
	return GDK_SUCCEED;
}

/* Returns whether the decimal is an exact tenfold */
int
decimal_istenfold(bit *ret, decimal *val)
{
	*ret = ISNIL(val) ? bit_nil : ISTENFOLD(val);
	return GDK_SUCCEED;
}

@- arithmetic
Computer hardware does not provide built-in support for arbitrarily large numbers.
The iterative algorithms employed here stem directly from Peter's primary school.

@- plus and minus
plus and minus algorithms assume positive numbers. Other cases are handled
as follows:
\begin{verbatim}
   -x + -y => -decimal_plus(x,y)     -x - -y => -decimal_minus(x,y);
    x + -y => decimal_minus(x,y)      x - -y => decimal_plus(x,y)
   -x +  y => decimal_minus(y,x)     -x -  y => decimal_plus(-x,-y)
\end{verbatim}
@c
/* auxiliary function: assumes equal sign and scale and no overflow */
static INLINE void
decimal_simple_inc(decimal *v1, decimal *v2)
{
	int x = PREC(v1), y = PREC(v2);
	unsigned int rest = 0;

	DECIMAL_DEBUG(v1, "decimal_simple_inc() acc", 0);
	DECIMAL_DEBUG(v2, "decimal_simple_inc() val", 0);

	for (x--, y--; y >= 0; x--, y--) {
		unsigned int r1 = ADD(GETNUM(v1, x), GETNUM(v2, y));
		unsigned int r2 = ADD(LO(r1), rest);

		SETNUM(v1, x, LO(r2));
		rest = HI(r1) + HI(r2);
	}
	for (; rest && x >= 0; x--) {
		unsigned int r2 = ADD(GETNUM(v1, x), rest);

		SETNUM(v1, x, LO(r2));
		rest = HI(r2);
	}
	DECIMAL_DEBUG(v1, "decimal_simple_inc() acc", 0);
}

/* auxiliary function: assumes equal sign and scale and no overflow */
static INLINE void
decimal_simple_dec(decimal *v1, decimal *v2)
{
	int x = PREC(v1), y = PREC(v2);
	unsigned int rest = 0;

	DECIMAL_DEBUG(v1, "decimal_simple_dec() acc", 0);
	DECIMAL_DEBUG(v2, "decimal_simple_dec() val", 0);

	for (x--, y--; y >= 0; x--, y--) {
		unsigned int r1 = MINUS(GETNUM(v1, x), GETNUM(v2, y));
		unsigned int r2 = MINUS(LO(r1), rest);

		SETNUM(v1, x, LO(r2));
		rest = HI(r1) + HI(r2);
	}
	for (; rest && x >= 0; x--) {
		unsigned int r2 = MINUS(GETNUM(v1, x), rest);

		SETNUM(v1, x, LO(r2));
		rest = HI(r2);
	}
	DECIMAL_DEBUG(v1, "decimal_simple_dec() acc", 0);
}

/* Returns a decimal whose value is (val1 + val2). */
int
decimal_plus(decimal **ret, decimal *v1, decimal *v2)
{
	decimal *tmp, *tot, *v3 = NULL;
	int x;

	DECIMAL_DEBUG(v1, "decimal_plus() left", 1);
	DECIMAL_DEBUG(v2, "decimal_plus() right", 1);

	/* special cases */
	if (ISNIL(v1) || ISNIL(v2)) {
		*ret = decimal_copy(decimal_nil, 1);
		return GDK_SUCCEED;
	} else if (ISZERO(v1)) {
		*ret = decimal_copy(v2, PREC(v2));
		return GDK_SUCCEED;
	} else if (ISZERO(v2)) {
		*ret = decimal_copy(v1, PREC(v1));
		return GDK_SUCCEED;
	}

	/* enforce same sign; different signs is handled by minus */
	if (v1->negative && !v2->negative) {
		tmp = v2;
		v2 = v1;
		v1 = tmp;
	}
	if (v2->negative && !v1->negative) {
		tmp = decimal_copy(v2, PREC(v2));
		tmp->negative = 0;
		x = decimal_minus(ret, v1, tmp);
		GDKfree(tmp);
		return x;
	}
	/* enforce same scale */
	if (SCALE(v2) < SCALE(v1)) {
		tmp = v2;
		v2 = v1;
		v1 = tmp;
	}
	if (SCALE(v2) > SCALE(v1)) {
		v2 = v3 = decimal_copy(v2, PREC(v2) + SCALE(v2) - SCALE(v1));
	}
	if (PREC(v2) > PREC(v1)) {
		tmp = v2;
		v2 = v1, v1 = tmp;
	}
	/* check for nil  and overflow */
	tot = *ret = decimal_create(PREC(v1) + 1, SCALE(v1), v1->negative);
	if (!ISNIL(tot)) {
		/* accumulate using simple addition */
		decimal_normalize(tot, v1, 1, PREC(v1) + 1, FALSE);
		decimal_simple_inc(tot, v2);
		decimal_normalize(tot, tot, 0, 0, TRUE);
	}
	if (v3)
		GDKfree(v3);
	DECIMAL_DEBUG(*ret, "decimal_plus() result", 1);
	return GDK_SUCCEED;
}

/* Returns a decimal whose value is (val1 - val2). */
int
decimal_minus(decimal **ret, decimal *v1, decimal *v2)
{
	decimal *tmp, *v3 = NULL;
	int x, negative = v1->negative;

	DECIMAL_DEBUG(v1, "decimal_minus() left", 1);
	DECIMAL_DEBUG(v2, "decimal_minus() right", 1);

	/* special cases */
	if (ISNIL(v1) || ISNIL(v2)) {
		*ret = decimal_copy(decimal_nil, 1);
		return GDK_SUCCEED;
	} else if (ISZERO(v1)) {
		*ret = decimal_copy(v2, PREC(v2));
		(*ret)->negative = !(*ret)->negative;
		return GDK_SUCCEED;
	} else if (ISZERO(v2)) {
		*ret = decimal_copy(v1, PREC(v1));
		return GDK_SUCCEED;
	}

	/* enforce same sign; different signs is handled by minus */
	if (v1->negative && !v2->negative) {
		tmp = v2;
		v2 = v1;
		v1 = tmp;
	}
	if (v2->negative && !v1->negative) {
		tmp = decimal_copy(v2, PREC(v2));
		tmp->negative = 0;
		x = decimal_plus(ret, v1, tmp);
		if (x == GDK_SUCCEED && negative && ISZERO(*ret) == 0 && ISNIL(*ret) == 0) {
			(*ret)->negative = !(*ret)->negative;
		}
		GDKfree(tmp);
		return x;
	}
	/* enforce same scale */
	if (SCALE(v2) < SCALE(v1)) {
		tmp = v2;
		v2 = v1;
		v1 = tmp;
		negative = !negative;
	}
	if (SCALE(v2) > SCALE(v1)) {
		v2 = v3 = decimal_copy(v2, PREC(v2) + SCALE(v2) - SCALE(v1));
	}
	/* minus without overflow by subtracting the smaller from the bigger number */
	x = decimal_compare(v1, v2);
	if ((!v1->negative && x < 0) || (v1->negative && x > 0)) {
		tmp = v2;
		v2 = v1;
		v1 = tmp;
		negative = !negative;
	}
	*ret = decimal_copy(v1, PREC(v1));
	decimal_simple_dec(*ret, v2);
	(*ret)->negative = negative;
	decimal_normalize(*ret, *ret, 0, 0, TRUE);

	if (v3)
		GDKfree(v3);
	DECIMAL_DEBUG(*ret, "decimal_minus() result", 1);
	return GDK_SUCCEED;
}

@- multiply
@c
/* Returns a decimal whose value is (val1 * val2). */
int
decimal_multiply(decimal **ret, decimal *v1, decimal *v2)
{
	int v1_precision = PREC(v1), v2_precision = PREC(v2), x;
	decimal *tot, *tmp;

	DECIMAL_DEBUG(v1, "decimal_multiply() left", 0);
	DECIMAL_DEBUG(v2, "decimal_multiply() right", 0);

	/* check special cases */
	if (ISZERO(v1) || ISZERO(v2)) {
		*ret = decimal_create(0, 0, 0);
		return GDK_SUCCEED;
	} else if (ISTENFOLD(v1) && (SCALE(v2) + PREC(v1) + SCALE(v1)) <= SCALE_MAX) {
		*ret = decimal_copy(v2, PREC(v2));
		(*ret)->negative = v1->negative ^ v2->negative;
		(*ret)->scale += SCALE(v1) + PREC(v1) - 1;
		return GDK_SUCCEED;
	} else if (ISTENFOLD(v2) && (SCALE(v1) + PREC(v2) + SCALE(v1)) <= SCALE_MAX) {
		*ret = decimal_copy(v1, PREC(v1));
		(*ret)->negative = v1->negative ^ v2->negative;
		(*ret)->scale += SCALE(v2) + PREC(v2) - 1;
		return GDK_SUCCEED;
	}

	/* during multiplication we do not waste time with trailing zeros */
	while (--v1_precision >= 0) {
		if (GETNUM(v1, v1_precision))
			break;	/* find last nonzero digit in v1 */
	}
	while (--v2_precision >= 0) {
		if (GETNUM(v2, v2_precision))
			break;	/* find last nonzero digit in v2 */
	}
	v1_precision++;
	v2_precision++;
	tot = *ret = decimal_create(v1_precision + v2_precision, (SCALE(v1) + PREC(v1) - v1_precision) + (SCALE(v2) + PREC(v2) - v2_precision), v1->negative ^ v2->negative);
	/* check for overflow */
	if (ISNIL(v1) || ISNIL(v2) || ISNIL(tot)) {
		*tot = *decimal_nil;
		return GDK_SUCCEED;
	}

	/* multiply with smallest=v1 below and biggest=v2 above */
	if (v1_precision > v2_precision) {
		int swap = v1_precision;

		v1_precision = v2_precision;
		v2_precision = swap;
		tmp = v2;
		v2 = v1;
		v1 = tmp;	/* swap if necessary */
	}

	/* for each digit in the lower number, we multiply the above number by that digit
	 * in tmp -- each time with one more trailing zero, and add tmp to tot (initially 0).
	 */
	tmp = decimal_create(v1_precision + v2_precision, 0, 0);
	x = v1_precision;

	while (--x >= 0) {
		int z, y;
		unsigned int f = GETNUM(v1, x), rest = 0;

		if (f == 0) {
			continue;	/* optimization: just skip zeros */
		}
		z = PREC(tmp);
		y = x + v2_precision;

		while (--z > y) {
			SETNUM(tmp, z, 0U);
		}
		y = v2_precision;
		while (--y >= 0) {
			unsigned int r1 = MULT(f, GETNUM(v2, y));	/* HI(r1) is at most 8 (9*9) */
			unsigned int r2 = ADD(LO(r1), rest);	/* HI(r2) is at most 1 (9+9) */

			SETNUM(tmp, z, LO(r2));
			z--;
			rest = HI(r1) + HI(r2);	/* no overflow: at most 9 (8+1) */
		}
		SETNUM(tmp, z, rest);
		z--;
		decimal_simple_inc(tot, tmp);
	}
	decimal_normalize(tot, tot, 0, 0, TRUE);

	GDKfree(tmp);
	DECIMAL_DEBUG(*ret, "decimal_multiply() result", 1);
	return GDK_SUCCEED;
}


@- divide
Uses a multiplication table containing div*1,.., div*9 to speed up matching.
@c
static INLINE void
decimal_mult_table(decimal *dv, decimal *mult[10])
{
	int i, len = TOTLEN(PREC(dv) + 1);
	char *p = (char *) GDKmalloc(i = 10 * len);

	memset(p, 0, i);
	mult[0] = decimal_alloc(PREC(dv) + 1, SCALE(dv), dv->negative, (decimal *) p, &len);
	for (i = 1; i < 10; i++) {
		decimal_simple_inc(mult[0], dv);
		mult[i] = (decimal *) (p += len);
		decimal_normalize(mult[i], mult[0], 0, 0, FALSE);
	}
}

#define CONCAT_DIGIT(dst, src, y) { /* append a digit from src[y] to dst */ \
		int pos = y;						\
		unsigned int val = (pos < PREC(src))?GETNUM(src,pos):0U; \
		if (val || PREC(dst)) {					\
			SETNUM(dst, PREC(dst), val);			\
			dst->precision++;				\
		}							\
	}

/* the guts of the "staartdeling" implementation of division */
static INLINE void
decimal_divide_intern(decimal *tot, decimal *num, decimal *dv, decimal *mult[], int precision)
{
	decimal *chunk = mult[0];
	unsigned int digit, factor = GETNUM(dv, 0);
	int dprec, dscal, dneg, cmp, z, y, x = NUMLEN(PREC(chunk));

	/* set chunk to zero */
	while (--x >= 0)
		chunk->num[x] = 0;
	chunk->precision = 0;
	dprec = PREC(chunk);	/* backup header of chunk */
	dscal = SCALE(chunk);
	dneg = chunk->negative;

	/* incremental division by multiplication and subtraction */
	x = -1;
	y = 0;
	z = precision;
	for (;;) {
		/* add digits to chunk till it has as many significant digits as dv */
		if (PREC(chunk) < PREC(dv)) {
			if (++x >= z)
				break;
			SETNUM(tot, x, 0U);
			CONCAT_DIGIT(chunk, num, y++);
			continue;
		}
		/* if the significant digits are equal, one more must make chunk > dv */
		digit = GETNUM(chunk, 0);
		cmp = decimal_compare(chunk, dv);
		if (dv->negative ? (cmp > 0) : (cmp < 0)) {
			if (++x >= z)
				break;
			SETNUM(tot, x, 0U);
			CONCAT_DIGIT(chunk, num, y++);
			digit = GETNUM(chunk, 1) + MULT10(digit);
		}
		/* guess the divisor factor by looking at the first digits */
		digit = DIV(digit, factor);
		for (;;) {
			cmp = decimal_compare(chunk, mult[digit]);
			if (dv->negative ? (cmp <= 0) : (cmp >= 0))
				break;
			digit--;
		}
		/* this is it! overwrite last zero with digit */
		SETNUM(tot, x, digit);

		/* subtract digit*dv from chunk */
		decimal_simple_dec(chunk, mult[digit]);
		decimal_normalize(chunk, chunk, 0, 0, FALSE);
		if (ISZERO(chunk)) {
			chunk->precision = dprec;	/* restore backup */
			chunk->scale = dscal;
			chunk->negative = dneg;
		}
	}
	decimal_normalize(tot, tot, 0, 0, TRUE);
}

/* Returns a decimal whose value is (val1 / val2) (division by zero return decimal(nil)). */
int
decimal_divide(decimal **ret, decimal *num, decimal *dv, int *precision)
{
	int p = MIN(MAX(0, PREC(dv) + *precision), PRECISION_MAX);
	int s = (SCALE(num) - SCALE(dv)) + (PREC(num) - p);
	decimal *mult[10];

	DECIMAL_DEBUG(num, "decimal_divide() num", 1);
	DECIMAL_DEBUG(dv, "decimal_divide() div", 1);

	/* check special cases */
	if (ISNIL(num) || ISNIL(dv) || ISZERO(dv)) {
		*ret = decimal_copy(decimal_nil, 1);
		return GDK_SUCCEED;
	} else if (ISZERO(num)) {
		*ret = decimal_copy(decimal_zero, 1);
		return GDK_SUCCEED;
	} else if (ISTENFOLD(dv) && (s - PREC(dv)) > SCALE_MIN) {
		*ret = decimal_copy(num, *precision);
		if (ISZERO(*ret) == 0 && ISNIL(*ret) == 0) {
			(*ret)->negative = num->negative ^ dv->negative;
			(*ret)->scale = (PREC(num) + SCALE(num) + 1) - (PREC(dv) + SCALE(dv) + *precision);
		}
		return GDK_SUCCEED;
	}
	/* alloc decimal */
	*ret = decimal_create(p, s, num->negative ^ dv->negative);

	/* create chunk and multiplication table in one memory alloc */
	decimal_mult_table(dv, mult);

	/* do the work */
	decimal_divide_intern(*ret, num, dv, mult, p);

	/* cleanup */
	GDKfree(mult[0]);
	DECIMAL_DEBUG(*ret, "decimal_divide() result", 1);
	return GDK_SUCCEED;
}

/* default division measures how many times div goes into num */
int
decimal_divide_default(decimal **ret, decimal *num, decimal *dv)
{
	int precision = MAX(0, (PREC(num) + SCALE(num)) - (PREC(dv) + SCALE(dv)));

	return decimal_divide(ret, num, dv, &precision);
}


/* bulkdivide divides all values in a bat by the same divisor.
 * it gains efficiency by avoiding copying the decimals into the BAT (it writes
 * directly into it) and by constructing the multiplication table only once.
 */
int
decimal_bulkdivide(BAT **ret, BAT *b, decimal *dv, int *prec)
{
	BATiter bi = bat_iterator(b);
	BUN xx = BATcount(b);
	int yy = 10;
	BAT *bn = *ret = BATnew(b->htype, TYPE_var, xx);
	BAT *bm;
	decimal *mult[10];
	BUN p, q;
	Heap hp;

	if (bn == NULL)
		return GDK_FAIL;
	bm = BATmirror(bn);

	/* create space for decimals */
	if (prec) {
		yy = MIN(PREC(dv) + MAX(1, *prec) - 1, PRECISION_MAX) + 1;
	} else if (xx) {
		decimal *d = (decimal *) BUNtvar(bi, BUNfirst(b));

		yy = TOTLEN(PREC(d) + 1);
	}
	hp.filename = NULL;
	HEAP_initialize_compact(&hp, MAX(10, xx) * yy, 0, 0, (int (*)(ptr)) decimal_length);

	/* create chunk and multiplication table just once for all invocations */
	decimal_mult_table(dv, mult);

	bn->tsorted = 0;
	bn->T->nonil = 0;
	BATloop(b, p, q) {
		decimal *src = (decimal *) BUNtvar(bi, p);
		int divprc = prec ? yy : PREC(src);
		int zero = ISZERO(src);
		int nil = ISNIL(src);
		int len = (zero || nil) ? (int) sizeof(decimal) : TOTLEN(divprc);
		var_t idx = HEAP_malloc(&hp, len);
		decimal *dst = (decimal *) (hp.base + (idx << GDK_VARSHIFT));

		if (BUNfastins(bn, BUNhead(bi, p), &idx) == NULL) {
			*ret = NULL;
			break;
		}

		/* compute the division */
		if (nil) {
			*dst = *decimal_nil;
		} else if (zero) {
			*dst = *decimal_zero;
		} else {
			((int *) ((char *) dst + len))[-1] = 0;	/* zero tail that may not be written */
			dst->precision = divprc;
			dst->scale = (SCALE(src) - SCALE(dv)) + (PREC(src) - divprc);
			dst->negative = src->negative ^ dv->negative;
			decimal_divide_intern(dst, src, dv, mult, divprc);
		}
	}

	/* trickily place the heap as tailheap into the bat */
	bn->ttype = bm->htype = TYPE_decimal;
	bn->tvarsized = bm->hvarsized = 1;

	bn->theap = (Heap*)GDKzalloc(sizeof(Heap));
	*bn->theap = hp;
	ALIGNsetH(bn, b);

	GDKfree(mult[0]);

	if (!*ret) {
		BBPreclaim(bn);
		return GDK_FAIL;
	}
	return GDK_SUCCEED;
}

int
decimal_bulkdivide_default(BAT **ret, BAT *b, decimal *dv)
{
	return decimal_bulkdivide(ret, b, dv, NULL);
}

@- power
@c
#define DEC_PRECISION(d,x) { int _x = MIN(x,PREC(d)); d->scale += (PREC(d) - _x); d->precision = _x; }

/* Raises a decimal to some (integer) power. precision determines the maximum precision of the result. */
int
decimal_pow(decimal **ret, decimal *d, int *i, int *p)
{
	int x, dprec, dneg, dscal, z, nfactors = 0, factor[32], power = *i, precision = *p;
	decimal *cache[32], *tmp, *tot = d;

	/* handle special cases */
	if (ISNIL(d) || power == int_nil || precision == int_nil || ((PREC(d) + SCALE(d)) > 0 && power * (PREC(d) + SCALE(d)) > SCALE_MAX)) {
		*ret = decimal_copy(decimal_nil, 1);
		return GDK_SUCCEED;
	} else if ((PREC(d) + SCALE(d)) < 0 && power * (PREC(d) + SCALE(d)) < SCALE_MIN) {
		*ret = decimal_copy(decimal_zero, 1);
		return GDK_SUCCEED;
	} else if (power == 0) {
		*ret = decimal_copy(decimal_one, precision);
		return GDK_SUCCEED;
	} else if (power == 1) {
		*ret = decimal_copy(d, precision);
		return GDK_SUCCEED;
	} else if (power < 0) {
		/* handle negative power as one divided by power */
		int ret_value = GDK_FAIL;

		power = -power;
		if (decimal_pow(&tot, d, &power, &precision) == GDK_SUCCEED) {
			ret_value = decimal_divide(ret, decimal_one, tot, p);
			GDKfree(tot);
		}
		return ret_value;
	}

	/* algorithm uses squaring of intermediates results; needs log2(n) multiplications */
	dprec = PREC(d);	/* backup header of d */
	dscal = SCALE(d);
	dneg = d->negative;

	/* take the multiplication precision as end_precision/2 + 2 */
	z = MIN(precision, (precision >> 1) + 2);

	/* establish which factors are required */
	for (x = 0; power; x++) {
		if (power & 1) {
			factor[nfactors++] = x;
		}
		power = (power >> 1) & 0X7FFFFFFF;
	}
	power = factor[nfactors - 1];

	/* compute all powers of two up till the highest required factor by succesive x*x */
	cache[0] = d;
	DEC_PRECISION(cache[0], z);
	for (x = 1; x <= power; x++) {
		decimal_multiply(cache + x, cache[x - 1], cache[x - 1]);
		DEC_PRECISION(cache[x], z);
	}

	/* multiply all required factors to get the result */
	tot = cache[factor[0]];
	tmp = NULL;
	for (x = 1; x < nfactors; x++) {
		decimal_multiply(&tot, tot, cache[factor[x]]);
		DEC_PRECISION(tot, precision);
		if (tmp)
			GDKfree(tmp);
		tmp = tot;
	}

	/* free all cached factors */
	for (x = 1; x <= power; x++) {
		if (cache[x] != tot)
			GDKfree(cache[x]);
	}
	d->precision = dprec;	/* restore backup */
	d->scale = dscal;
	d->negative = dneg;
	decimal_normalize(*ret = tot, tot, 0, precision, TRUE);
	return GDK_SUCCEED;
}

int
decimal_pow_default(decimal **ret, decimal *d, int *power)
{
	int precision = PREC(d);

	return decimal_pow(ret, d, power, &precision);
}

@}
@}
