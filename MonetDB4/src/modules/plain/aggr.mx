@/
The contents of this file are subject to the MonetDB Public License
Version 1.1 (the "License"); you may not use this file except in
compliance with the License. You may obtain a copy of the License at
http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html

Software distributed under the License is distributed on an "AS IS"
basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations
under the License.

The Original Code is the MonetDB Database System.

The Initial Developer of the Original Code is CWI.
Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
Copyright August 2008-2011 MonetDB B.V.
All Rights Reserved.
@

@f aggr
@a P. Boncz, S. Manegold
@t Aggregates Module
@v 1.0

This module contains some efficient aggregate functions that compute their
result in one scan, rather than in the iterative manner of the generic
MIL aggr_ implementations.

The implementation code was derived from the former tpcd module and some
test scripts were added.
@m
.MODULE aggr;

.COMMAND {sum_bte}(BAT[oid,bte] b, BAT[oid,any] e) : BAT[oid,bte] = CMDaggr_sum_bte_bte;
	"grouped tail sum"
.COMMAND {sum_sht}(BAT[oid,bte] b, BAT[oid,any] e) : BAT[oid,sht] = CMDaggr_sum_bte_sht;
	"grouped tail sum"
.COMMAND {sum_sht}(BAT[oid,sht] b, BAT[oid,any] e) : BAT[oid,sht] = CMDaggr_sum_sht_sht;
	"grouped tail sum"
.COMMAND {sum_int}(BAT[oid,bte] b, BAT[oid,any] e) : BAT[oid,int] = CMDaggr_sum_bte_int;
	"grouped tail sum"
.COMMAND {sum_int}(BAT[oid,sht] b, BAT[oid,any] e) : BAT[oid,int] = CMDaggr_sum_sht_int;
	"grouped tail sum"
.COMMAND {sum_int}(BAT[oid,int] b, BAT[oid,any] e) : BAT[oid,int] = CMDaggr_sum_int_int;
	"grouped tail sum"
.COMMAND {sum_wrd}(BAT[oid,bte] b, BAT[oid,any] e) : BAT[oid,wrd] = CMDaggr_sum_bte_wrd;
	"grouped tail sum"
.COMMAND {sum_wrd}(BAT[oid,sht] b, BAT[oid,any] e) : BAT[oid,wrd] = CMDaggr_sum_sht_wrd;
	"grouped tail sum"
.COMMAND {sum_wrd}(BAT[oid,int] b, BAT[oid,any] e) : BAT[oid,wrd] = CMDaggr_sum_int_wrd;
	"grouped tail sum"
.COMMAND {sum_wrd}(BAT[oid,wrd] b, BAT[oid,any] e) : BAT[oid,wrd] = CMDaggr_sum_wrd_wrd;
	"grouped tail sum"
.COMMAND {sum_lng}(BAT[oid,bte] b, BAT[oid,any] e) : BAT[oid,lng] = CMDaggr_sum_bte_lng;
	"grouped tail sum"
.COMMAND {sum_lng}(BAT[oid,sht] b, BAT[oid,any] e) : BAT[oid,lng] = CMDaggr_sum_sht_lng;
	"grouped tail sum"
.COMMAND {sum_lng}(BAT[oid,int] b, BAT[oid,any] e) : BAT[oid,lng] = CMDaggr_sum_int_lng;
	"grouped tail sum"
.COMMAND {sum_lng}(BAT[oid,wrd] b, BAT[oid,any] e) : BAT[oid,lng] = CMDaggr_sum_wrd_lng;
	"grouped tail sum"
.COMMAND {sum_lng}(BAT[oid,lng] b, BAT[oid,any] e) : BAT[oid,lng] = CMDaggr_sum_lng_lng;
	"grouped tail sum"
.COMMAND {sum_flt}(BAT[oid,flt] b, BAT[oid,any] e) : BAT[oid,flt] = CMDaggr_sum_flt_flt;
	"grouped tail sum"
.COMMAND {sum_dbl}(BAT[oid,flt] b, BAT[oid,any] e) : BAT[oid,dbl] = CMDaggr_sum_flt_dbl;
	"grouped tail sum"
.COMMAND {sum_dbl}(BAT[oid,dbl] b, BAT[oid,any] e) : BAT[oid,dbl] = CMDaggr_sum_dbl_dbl;
	"grouped tail sum"

.COMMAND {prod_bte}(BAT[oid,bte] b, BAT[oid,any] e) : BAT[oid,bte] = CMDaggr_prod_bte_bte;
	"grouped tail product"
.COMMAND {prod_sht}(BAT[oid,bte] b, BAT[oid,any] e) : BAT[oid,sht] = CMDaggr_prod_bte_sht;
	"grouped tail product"
.COMMAND {prod_sht}(BAT[oid,sht] b, BAT[oid,any] e) : BAT[oid,sht] = CMDaggr_prod_sht_sht;
	"grouped tail product"
.COMMAND {prod_int}(BAT[oid,bte] b, BAT[oid,any] e) : BAT[oid,int] = CMDaggr_prod_bte_int;
	"grouped tail product"
.COMMAND {prod_int}(BAT[oid,sht] b, BAT[oid,any] e) : BAT[oid,int] = CMDaggr_prod_sht_int;
	"grouped tail product"
.COMMAND {prod_int}(BAT[oid,int] b, BAT[oid,any] e) : BAT[oid,int] = CMDaggr_prod_int_int;
	"grouped tail product"
.COMMAND {prod_wrd}(BAT[oid,bte] b, BAT[oid,any] e) : BAT[oid,wrd] = CMDaggr_prod_bte_wrd;
	"grouped tail product"
.COMMAND {prod_wrd}(BAT[oid,sht] b, BAT[oid,any] e) : BAT[oid,wrd] = CMDaggr_prod_sht_wrd;
	"grouped tail product"
.COMMAND {prod_wrd}(BAT[oid,int] b, BAT[oid,any] e) : BAT[oid,wrd] = CMDaggr_prod_int_wrd;
	"grouped tail product"
.COMMAND {prod_wrd}(BAT[oid,wrd] b, BAT[oid,any] e) : BAT[oid,wrd] = CMDaggr_prod_wrd_wrd;
	"grouped tail product"
.COMMAND {prod_lng}(BAT[oid,bte] b, BAT[oid,any] e) : BAT[oid,lng] = CMDaggr_prod_bte_lng;
	"grouped tail product"
.COMMAND {prod_lng}(BAT[oid,sht] b, BAT[oid,any] e) : BAT[oid,lng] = CMDaggr_prod_sht_lng;
	"grouped tail product"
.COMMAND {prod_lng}(BAT[oid,int] b, BAT[oid,any] e) : BAT[oid,lng] = CMDaggr_prod_int_lng;
	"grouped tail product"
.COMMAND {prod_lng}(BAT[oid,wrd] b, BAT[oid,any] e) : BAT[oid,lng] = CMDaggr_prod_wrd_lng;
	"grouped tail product"
.COMMAND {prod_lng}(BAT[oid,lng] b, BAT[oid,any] e) : BAT[oid,lng] = CMDaggr_prod_lng_lng;
	"grouped tail product"
.COMMAND {prod_flt}(BAT[oid,flt] b, BAT[oid,any] e) : BAT[oid,flt] = CMDaggr_prod_flt_flt;
	"grouped tail product"
.COMMAND {prod_dbl}(BAT[oid,flt] b, BAT[oid,any] e) : BAT[oid,dbl] = CMDaggr_prod_flt_dbl;
	"grouped tail product"
.COMMAND {prod_dbl}(BAT[oid,dbl] b, BAT[oid,any] e) : BAT[oid,dbl] = CMDaggr_prod_dbl_dbl;
	"grouped tail product"

.COMMAND {avg}(BAT[oid,bte] b, BAT[oid,any] e) : BAT[oid,dbl] = CMDaggr_avg_bte;
	"grouped tail average"
.COMMAND {avg}(BAT[oid,sht] b, BAT[oid,any] e) : BAT[oid,dbl] = CMDaggr_avg_sht;
	"grouped tail average"
.COMMAND {avg}(BAT[oid,int] b, BAT[oid,any] e) : BAT[oid,dbl] = CMDaggr_avg_int;
	"grouped tail average"
.COMMAND {avg}(BAT[oid,wrd] b, BAT[oid,any] e) : BAT[oid,dbl] = CMDaggr_avg_wrd;
	"grouped tail average"
.COMMAND {avg}(BAT[oid,lng] b, BAT[oid,any] e) : BAT[oid,dbl] = CMDaggr_avg_lng;
	"grouped tail average"
.COMMAND {avg}(BAT[oid,flt] b, BAT[oid,any] e) : BAT[oid,dbl] = CMDaggr_avg_flt;
	"grouped tail average"
.COMMAND {avg}(BAT[oid,dbl] b, BAT[oid,any] e) : BAT[oid,dbl] = CMDaggr_avg_dbl;
	"grouped tail average"

.COMMAND {variance}(BAT[oid,bte] b, BAT[oid,any] e) : BAT[oid,bte] = CMDaggr_variance_bte;
        "grouped tail variance"
.COMMAND {variance}(BAT[oid,sht] b, BAT[oid,any] e) : BAT[oid,sht] = CMDaggr_variance_sht;
        "grouped tail variance"
.COMMAND {variance}(BAT[oid,int] b, BAT[oid,any] e) : BAT[oid,int] = CMDaggr_variance_int;
        "grouped tail variance"
.COMMAND {variance}(BAT[oid,wrd] b, BAT[oid,any] e) : BAT[oid,wrd] = CMDaggr_variance_wrd;
        "grouped tail variance"
.COMMAND {variance}(BAT[oid,lng] b, BAT[oid,any] e) : BAT[oid,lng] = CMDaggr_variance_lng;
        "grouped tail variance"
.COMMAND {variance}(BAT[oid,flt] b, BAT[oid,any] e) : BAT[oid,flt] = CMDaggr_variance_flt;
        "grouped tail variance"
.COMMAND {variance}(BAT[oid,dbl] b, BAT[oid,any] e) : BAT[oid,dbl] = CMDaggr_variance_dbl;
        "grouped tail variance"

.COMMAND {min}(BAT[oid,any::1] b, BAT[oid,any] e) : BAT[oid,any::1] = CMDaggr_min;
	"grouped tail minimum"
.COMMAND {max}(BAT[oid,any::1] b, BAT[oid,any] e) : BAT[oid,any::1] = CMDaggr_max;
	"grouped tail maximum"

.COMMAND {count}(BAT[oid,any] b, BAT[oid,any] e, bit ignore_nils) : BAT[oid,int] = CMDaggr_count;
	"grouped count; ignores nil values iff ignore_nils==TRUE"
.COMMAND {size}(BAT[oid,bit] b, BAT[oid,any] e) : BAT[oid,wrd] = CMDaggr_size;
	"grouped count of true values"

.COMMAND size(BAT[any,bit]) : wrd = CMDsize;
        "return the number of true values in a tail column"
.COMMAND hasNil(BAT[any,any]) : bit = CMDhasNil;
        "return if there is a nil value in the tail column"
.COMMAND card(BAT[any,any]) : wrd = CMDcard_unlimited;
        "return the number of different values in a tail column"
.COMMAND card(BAT[any,any], wrd maxelements) : wrd = CMDcard;
        "as card(b), but returns nil if card(b) > maxelements"

.END aggr;

@mil
    proc {count}(BAT[oid,any] b, BAT[oid,any] e) : BAT[oid,int] {
		return {count}(b,e,FALSE);
    }
    ADDHELP("{count}", "manegold", "Jun 03 2003",
    "short-cut for {count}(b,e,FALSE)", "aggr");

    proc {count_no_nil}(BAT[oid,any] b, BAT[oid,any] e) : BAT[oid,int] {
		return {count}(b,e,TRUE);
    }
    ADDHELP("{count_no_nil}", "manegold", "Jun 03 2003",
    "short-cut for {count}(b,e,TRUE)", "aggr");

    proc size(BAT[any,bit] b) : wrd {
	var h := b.histogram();
	if (h.exist(true))
	    return h.find(true).wrd(); # 64bit: when histogram() returns wrd, remove cast
	return wrd(0);
    }

    proc {sum}(BAT[oid, bte] b, bat[oid,any] e ) : BAT[oid,bte] {
		return	 {sum_bte}(b,e);
    }
    proc {sum}(BAT[oid, sht] b, bat[oid,any] e ) : BAT[oid,sht] {
		return	 {sum_sht}(b,e);
    }
    proc {sum}(BAT[oid, int] b, bat[oid,any] e ) : BAT[oid,int] {
		return	 {sum_int}(b,e);
    }
    proc {sum}(BAT[oid, wrd] b, bat[oid,any] e ) : BAT[oid,wrd] {
		return	 {sum_wrd}(b,e);
    }
    proc {sum}(BAT[oid, lng] b, bat[oid,any] e ) : BAT[oid,lng] {
		return	 {sum_lng}(b,e);
    }
    proc {sum}(BAT[oid, flt] b, bat[oid,any] e ) : BAT[oid,flt] {
		return	 {sum_flt}(b,e);
    }
    proc {sum}(BAT[oid, dbl] b, bat[oid,any] e ) : BAT[oid,dbl] {
		return	 {sum_dbl}(b,e);
    }

    proc {prod}(BAT[oid, bte] b, bat[oid,any] e ) : BAT[oid,bte] {
		return	 {prod_bte}(b,e);
    }
    proc {prod}(BAT[oid, sht] b, bat[oid,any] e ) : BAT[oid,sht] {
		return	 {prod_sht}(b,e);
    }
    proc {prod}(BAT[oid, int] b, bat[oid,any] e ) : BAT[oid,int] {
		return	 {prod_int}(b,e);
    }
    proc {prod}(BAT[oid, wrd] b, bat[oid,any] e ) : BAT[oid,wrd] {
		return	 {prod_wrd}(b,e);
    }
    proc {prod}(BAT[oid, lng] b, bat[oid,any] e ) : BAT[oid,lng] {
		return	 {prod_lng}(b,e);
    }
    proc {prod}(BAT[oid, flt] b, bat[oid,any] e ) : BAT[oid,flt] {
		return	 {prod_flt}(b,e);
    }
    proc {prod}(BAT[oid, dbl] b, bat[oid,any] e ) : BAT[oid,dbl] {
		return	 {prod_dbl}(b,e);
    }
    proc {card}(BAT[oid,any] b, BAT[oid,any] e) : BAT[oid,wrd] {
	return {count}(b.sunique(),e).[wrd](); # 64bit: when count() returns wrd, remove cast
    }

    proc variance(BAT[any,any::1] b) : any::1 {
	var c := dbl(b.count());
	if (c = 0.0LL) {
		return 0.cast(b.ttype());
	}
	var s := [*](b,b).sum();
	var a := b.avg();
	return ((s / c) - (a * a)).cast(b.ttype());
    }

@{
@{
@+ Implementation
These implementations need just one scan and a simple hash-maintained data
structure to compute a group of common aggregates.
@c
#include "monetdb_config.h"
#include <gdk.h>
#include "aggr.proto.h"

/*
with group OIDs spanning a range of less SMALL_AGGR_MAX (the actual number
of groups might be even less, in case there are "holes" in the group OID
range), we use a simple array as temporary sum/cnt table on order to benefit
from positional lookups; with size of sum <= 8 bytes and size of cnt == 4
bytes, we stay below 16 KBytes, i.e., within (almost) any L1 cache
*/
#define SMALL_AGGR_MAX 1024

@= large_aggr_sum
	if (BATprepareHash(bn)) {
		BBPreclaim(bn);
		return GDK_FAIL;
	}
	BATloop(b, p, q) {
		oid *h = (oid*) BUNhead(bi,p);
		@1 *t = (@1*) BUN@2(bi,p);

		BUNfndOID(r, bni, h);
		if (r != BUN_NONE) {
			@3 *dst = (@3*) BUN@2(bni, r);
			if (*dst != @3_nil) {
				if (*t == @1_nil) {
					*dst = @3_nil;
				} else {
					*dst += *t;
				}
			}
		}
	}
@c
@= small_aggr_sum
	sums = (@3*) GDKmalloc(range*sizeof(@3));
	for (i = 0; i < range; i++)
		sums[i] = zero;
	BATloop(b, p, q) {
		oid h = (*(oid*) BUNhead(bi,p)) - min;
		@1 *t = (@1*) BUN@2(bi,p);

		if (h < range) {
			@3 *dst = sums + h;
			if (*dst != @3_nil) {
				if (*t == @1_nil) {
					*dst = @3_nil;
				} else {
					*dst += *t;
				}
			}
		}
	}
	BATloop(bn, p, q) {
		oid h = (*(oid*) BUNhead(bni,p)) - min;
		*(@3*)BUN@2(bni, p) = sums[h];
	}
        GDKfree(sums);
@c
@= large_aggr_prod
	if (BATprepareHash(bn)) {
		BBPreclaim(bn);
		return GDK_FAIL;
	}
	BATloop(b, p, q) {
		oid *h = (oid*) BUNhead(bi,p);
		@1 *t = (@1*) BUN@2(bi,p);

		BUNfndOID(r, bni, h);
		if (r != BUN_NONE) {
			@3 *dst = (@3*) BUN@2(bni, r);
			if (*dst != @3_nil) {
				if (*t == @1_nil) {
					*dst = @3_nil;
				} else {
					*dst *= *t;
				}
			}
		}
	}
@c
@= small_aggr_prod
	prods = (@3*) GDKmalloc(range*sizeof(@3));
	for (i = 0; i < range; i++)
		prods[i] = one;
	BATloop(b, p, q) {
		oid h = (*(oid*) BUNhead(bi,p)) - min;
		@1 *t = (@1*) BUN@2(bi,p);

		if (h < range) {
			@3 *dst = prods + h;
			if (*dst != @3_nil) {
				if (*t == @1_nil) {
					*dst = @3_nil;
				} else {
					*dst *= *t;
				}
			}
		}
	}
	BATloop(bn, p, q) {
		oid h = (*(oid*) BUNhead(bni,p)) - min;
		*(@3*)BUN@2(bni, p) = prods[h];
	}
        GDKfree(prods);
@c
@= large_aggr_avg
	cnt  = (BUN*) GDKmalloc(BATcount(e)*sizeof(BUN));
	memset(cnt, 0, BATcount(e)*sizeof(BUN));
	if (BATprepareHash(bn)) {
		GDKfree(cnt);
		BBPreclaim(bn);
		return GDK_FAIL;
	}
	BATloop(b, p, q) {
		oid *h = (oid*) BUNhead(bi,p);
		@1 *t = (@1*) BUN@2(bi,p);

		BUNfndOID(r,bni,h);
		if (r != BUN_NONE) {
			dbl *dst = (dbl*) BUN@2(bni, r);
			if (*dst != dbl_nil) {
				if (*t == @1_nil) {
					*dst = dbl_nil;
				} else {
					*dst += *t;
				}
				cnt[r-off]++;
			}
		}
	}
	/* postprocess by dividing sums by counts */
	BATloop(bn, p, q) {
		dbl *dst = (dbl*) BUN@2(bni, p);
		if (cnt[yy] == 0) {
			*dst = dbl_nil;
		} else if (*dst != dbl_nil) {
			*dst = (dbl) (*dst / cnt[yy]);
		}
		yy++;
	}
	GDKfree(cnt);
@c
@= small_aggr_avg
	sums = (dbl*) GDKmalloc(range*sizeof(dbl));
	cnt  = (BUN*) GDKmalloc(range*sizeof(BUN));
	for (i = 0; i < range; i++)
		sums[i] = zero;
	memset(cnt, 0, range*sizeof(BUN));
	BATloop(b, p, q) {
		oid h = (*(oid*) BUNhead(bi,p)) - min;
		@1 *t = (@1*) BUN@2(bi,p);

		if (h < range) {
			dbl *dst = sums + h;
			if (*dst != dbl_nil) {
				if (*t == @1_nil) {
					*dst = dbl_nil;
				} else {
					*dst += *t;
				}
				cnt[h]++;
			}
		}
	}
	/* postprocess by dividing sums by counts */
	BATloop(bn, p, q) {
		oid h = (*(oid*) BUNhead(bni,p)) - min;
		dbl *dst = (dbl*) BUN@2(bni, p);
		if (cnt[h] == 0 || sums[h] == dbl_nil) {
			*dst = dbl_nil;
		} else {
			*dst = (dbl) (sums[h]/cnt[h]);
		}
	}
        GDKfree(sums);
	GDKfree(cnt);
@c

@= arithsumprod
int
CMDaggr_sum_@1_@3(BAT **ret, BAT *b, BAT *e)
{
	BAT *bn = BATnew(e->htype, TYPE_@3, BATcount(e));
	BATiter ei = bat_iterator(e), bi = bat_iterator(b), bni = bat_iterator(bn);
	@3 zero = (@3) 0, *sums;
	BUN p, q, r;
	oid i, range, min, max;

	if (bn == NULL)
		return GDK_FAIL;
	/* init: set all sums to zero */
	bn->tsorted = bn->hsorted = 0;
	bn->T->nonil = 0;
	ALIGNsetH(bn, e);
	if (BAThordered(e)&1) {
		min = *(oid*)BUNhead(ei, BUNfirst(e));
		BATloop(e, p, q) {
			if (BUNfastins(bn, BUNhead(ei,p), &zero) == NULL) {
				BBPreclaim(bn);
				return GDK_FAIL;
			}
		}
		max = *(oid*)BUNhead(ei, BUNlast(e)-1);
	} else {
		min = max = *(oid*)BUNhead(ei, BUNfirst(e));
		BATloop(e, p, q) {
			if (BUNfastins(bn, BUNhead(ei,p), &zero) == NULL) {
				BBPreclaim(bn);
				return GDK_FAIL;
			}
			i = *(oid*)BUNhead(ei, p);
			if (i < min)
				min = i;
			else if (i > max)
				max = i;
		}
	}
	range = max - min + 1;

	/* scan b, and add values to sums in-place */
	if (range > SMALL_AGGR_MAX) {
		ALGODEBUG THRprintf(GDKout, "#CMDaggr_sum_@1_@3: range(=" OIDFMT ") > SMALL_AGGR_MAX(=%d)  => large_aggr_sum\n",range,SMALL_AGGR_MAX);
		@:large_aggr_sum(@1,@2,@3)@
	} else {
		ALGODEBUG THRprintf(GDKout, "#CMDaggr_sum_@1_@3: range(=" OIDFMT ") <= SMALL_AGGR_MAX(=%d)  => small_aggr_sum\n",range,SMALL_AGGR_MAX);
		@:small_aggr_sum(@1,@2,@3)@
	}
	*ret = bn;
	return GDK_SUCCEED;
}

int
CMDaggr_prod_@1_@3(BAT **ret, BAT *b, BAT *e)
{
	BAT *bn = BATnew(e->htype, TYPE_@3, BATcount(e));
	BATiter ei = bat_iterator(e), bi = bat_iterator(b), bni = bat_iterator(bn);
	@3 one = (@3) 1, *prods;
	BUN p, q, r;
	oid i, range, min, max;

	if (bn == NULL)
		return GDK_FAIL;
	/* init: set all prods to one */
	bn->tsorted = bn->hsorted = 0;
	bn->T->nonil = 0;
	ALIGNsetH(bn, e);
	if (BAThordered(e)&1) {
		min = *(oid*)BUNhead(ei, BUNfirst(e));
		BATloop(e, p, q) {
			if (BUNfastins(bn, BUNhead(ei,p), &one) == NULL) {
				BBPreclaim(bn);
				return GDK_FAIL;
			}
		}
		max = *(oid*)BUNhead(ei, BUNlast(e)-1);
	} else {
		min = max = *(oid*)BUNhead(ei, BUNfirst(e));
		BATloop(e, p, q) {
			if (BUNfastins(bn, BUNhead(ei,p), &one) == NULL) {
				BBPreclaim(bn);
				return GDK_FAIL;
			}
			i = *(oid*)BUNhead(ei, p);
			if (i < min)
				min = i;
			else if (i > max)
				max = i;
		}
	}
	range = max - min + 1;

	/* scan b, and mul values to prods in-place */
	if (range > SMALL_AGGR_MAX) {
		ALGODEBUG THRprintf(GDKout, "#CMDaggr_prod_@1_@3: range(=" OIDFMT ") > SMALL_AGGR_MAX(=%d)  => large_aggr_prod\n",range,SMALL_AGGR_MAX);
		@:large_aggr_prod(@1,@2,@3)@
	} else {
		ALGODEBUG THRprintf(GDKout, "#CMDaggr_prod_@1_@3: range(=" OIDFMT ") <= SMALL_AGGR_MAX(=%d)  => small_aggr_prod\n",range,SMALL_AGGR_MAX);
		@:small_aggr_prod(@1,@2,@3)@
	}
	*ret = bn;
	return GDK_SUCCEED;
}
@c
@:arithsumprod(bte,tloc,bte)@
@:arithsumprod(bte,tloc,sht)@
@:arithsumprod(bte,tloc,int)@
@:arithsumprod(bte,tloc,wrd)@
@:arithsumprod(bte,tloc,lng)@
@:arithsumprod(sht,tloc,sht)@
@:arithsumprod(sht,tloc,int)@
@:arithsumprod(sht,tloc,wrd)@
@:arithsumprod(sht,tloc,lng)@
@:arithsumprod(int,tloc,int)@
@:arithsumprod(int,tloc,wrd)@
@:arithsumprod(int,tloc,lng)@
@:arithsumprod(wrd,tloc,wrd)@
@:arithsumprod(wrd,tloc,lng)@
@:arithsumprod(lng,tloc,lng)@
@:arithsumprod(flt,tloc,flt)@
@:arithsumprod(flt,tloc,dbl)@
@:arithsumprod(dbl,tloc,dbl)@

@= arithavg
int
CMDaggr_avg_@1(BAT **ret, BAT *b, BAT *e)
{
	BAT *bn = BATnew(e->htype, TYPE_dbl, BATcount(e));
	BATiter ei = bat_iterator(e), bi = bat_iterator(b), bni = bat_iterator(bn);
	BUN yy = 0, off;
	BUN *cnt;
	oid i, range, min, max;
	dbl zero = (dbl) 0, *sums;
	BUN p, q, r;

	if (bn == NULL)
		return GDK_FAIL;
	off = BUNfirst(bn);
	/* init sums and counts to zero */
	bn->tsorted = bn->hsorted = 0;
	bn->T->nonil = 0;
	ALIGNsetH(bn, e);
	if (BAThordered(e)&1) {
		min = *(oid*)BUNhead(ei, BUNfirst(e));
		BATloop(e, p, q) {
			if (BUNfastins(bn, BUNhead(ei,p), &zero) == NULL) {
				BBPreclaim(bn);
				return GDK_FAIL;
			}
		}
		max = *(oid*)BUNhead(ei, BUNlast(e)-1);
	} else {
		min = max = *(oid*)BUNhead(ei, BUNfirst(e));
		BATloop(e, p, q) {
			if (BUNfastins(bn, BUNhead(ei,p), &zero) == NULL) {
				BBPreclaim(bn);
				return GDK_FAIL;
			}
			i = *(oid*)BUNhead(ei, p);
			if (i < min)
				min = i;
			else if (i > max)
				max = i;
		}
	}
	range = max - min + 1;

	/* scan b, adding sums, and incrementing counts */
	if (range > SMALL_AGGR_MAX) {
		ALGODEBUG THRprintf(GDKout, "#CMDaggr_avg_@1: range(=" OIDFMT ") > SMALL_AGGR_MAX(=%d)  =>  large_aggr_avg\n",range,SMALL_AGGR_MAX);
		@:large_aggr_avg(@1,@2)@
	} else {
		ALGODEBUG THRprintf(GDKout, "#CMDaggr_avg_@1: range(=" OIDFMT ") <= SMALL_AGGR_MAX(=%d)  =>  small_aggr_avg\n",range,SMALL_AGGR_MAX);
		@:small_aggr_avg(@1,@2)@
	}
	*ret = bn;
	return GDK_SUCCEED;
}
@c
@:arithavg(bte,tloc)@
@:arithavg(sht,tloc)@
@:arithavg(int,tloc)@
@:arithavg(wrd,tloc)@
@:arithavg(lng,tloc)@
@:arithavg(flt,tloc)@
@:arithavg(dbl,tloc)@

@-
this was imported in the DD merge.
TODO: add ALGODEBUG and optimize further?

@= arithvar
int
CMDaggr_variance_@1(BAT **ret, BAT *b, BAT *e)
{
	BUN nElements = BATcount(e);
	BAT *bn = *ret = BATnew(e->htype, BATttype(b), nElements);
	BATiter ei = bat_iterator(e), bi = bat_iterator(b);
	BUN off, idx = 0;
	int *cnt ;
	dbl *sum ;
	dbl *sumsquares ;
	@1 zero = (@1) 0;
	BUN p, q, r;
	oid previousOid = oid_nil;

	if (bn == NULL)
		return GDK_FAIL;
	off = BUNfirst(e);
	cnt = (int*) GDKmalloc(nElements*sizeof(int));
	if (cnt == NULL) {
		BBPreclaim(bn);
		return GDK_FAIL;
	}
	sum = (dbl*) GDKmalloc(nElements*sizeof(dbl));
	if (sum == NULL) {
		BBPreclaim(bn);
		GDKfree(cnt);
		return GDK_FAIL;
	}
	sumsquares = (dbl*) GDKmalloc(nElements*sizeof(dbl));
	if (sumsquares == NULL) {
		BBPreclaim(bn);
		GDKfree(cnt);
		GDKfree(sum);
		return GDK_FAIL;
	}

	/* scan b, adding sums, and incrementing counts */
	if (BATprepareHash(e)) {
		BBPreclaim(bn);
		GDKfree(cnt);
		GDKfree(sum);
		GDKfree(sumsquares);
		return GDK_FAIL;
	}

	/* init sums and counts to zero */
	memset(cnt, 0, nElements*sizeof(int));
	memset(sum, 0, nElements*sizeof(dbl));
	memset(sumsquares, 0, nElements*sizeof(dbl));

	BATloop(b, p, q) {
		oid *h = (oid*) BUNhead(bi,p);
		if (*h != previousOid) {
			previousOid = *h;
			BUNfndOID(r,ei,h);
			if (r == BUN_NONE)
				continue;
			idx = r-off;
		}

		if (cnt[idx] != int_nil) {
			@1 v = *(@1*) BUNtloc(bi,p);
			if (v == @1_nil) {
				cnt[idx] = int_nil;
			} else {
				cnt[idx]++;
				sum[idx] += v;
				sumsquares[idx] += (v * v);
			}
		}
	}

	/* postprocess by dividing sumsquares and sum by counts and
	   substracting square of the averages from the average sum of
	   squares */
	idx = 0;
	BATloop(e, p, q) {
		if (cnt[idx] == int_nil) {
			@1 _nil = @1_nil;
			if (BUNfastins(bn, BUNhead(ei,p), (ptr)&_nil) == NULL) {
				*ret = NULL;
				break;
			}
		} else if (cnt[idx] <= 1) {
			if (BUNfastins(bn, BUNhead(ei,p), &zero) == NULL) {
				*ret = NULL;
				break;
			}
		} else {
			dbl avg = (sum[idx] / cnt[idx]);
			@1 variance = (@1) (sumsquares[idx] / cnt[idx] - (avg * avg));
			if (BUNfastins(bn, BUNhead(ei,p), &variance) == NULL) {
				*ret = NULL;
				break;
			}
		}
		idx++;
	}
	GDKfree(cnt);
	GDKfree(sum);
	if (!*ret) {
		BBPreclaim(bn);
		return GDK_FAIL;
	}
	bn->hsorted = bn->tsorted = 0;
	bn->T->nonil = 0;
	ALIGNsetH(bn, e);
	return GDK_SUCCEED;
}
@c
@:arithvar(bte)@
@:arithvar(sht)@
@:arithvar(int)@
@:arithvar(wrd)@
@:arithvar(lng)@
@:arithvar(flt)@
@:arithvar(dbl)@


@= extreme
static int
CMDaggr_@1_@3(BAT **ret, BAT *b, BAT *e)
{
	BAT *bn = *ret = BATnew(e->htype, BATttype(b), BATcount(e));
	BATiter ei = bat_iterator(e), bi = bat_iterator(b);
	int (*cmp)(ptr,ptr);
	ptr nil;
	BUN yy = 0, off;
	@3 *extremes;
	BUN p, q, r;

	if (bn == NULL)
		return GDK_FAIL;
	cmp = BATatoms[bn->ttype].atomCmp;
	nil = ATOMnilptr(bn->ttype);
	off = BUNfirst(e);
	extremes = (@3*) GDKmalloc(BATcount(e)*sizeof(@3));
	if (extremes == NULL) {
		BBPreclaim(bn);
		return GDK_FAIL;
	}

	/* init: set all extremes to the zero pointer */
	@:extreme_init_@3(@4)@

	/* scan b and replace totals by the extreme value (just pointers to vals in b) */
	if (BATprepareHash(e)) {
		BBPreclaim(bn);
		GDKfree(extremes);
		return GDK_FAIL;
	}
	BATloop(b, p, q) {
		oid *h = (oid*) BUNhead(bi,p);
		ptr t =  BUNtail(bi,p);

		BUNfndOID(r,ei,h);
		if (r != BUN_NONE) {
			@:extreme_body_@3(@2)@
		}
	}
	/* insert the extreme values into the result */
	yy = 0;
	BATloop(e, p, q) {
		@3 val = extremes[yy++];
		if (BUNfastins(bn, BUNhead(ei,p), @:extreme_tail_@3@) == NULL) {
			*ret = NULL;
			break;
		}
	}
	GDKfree(extremes);
	if (!*ret) {
		BBPreclaim(bn);
		return GDK_FAIL;
	}
	bn->tsorted = bn->hsorted = 0;
	bn->T->nonil = 0;
	ALIGNsetH(bn, e);
	return GDK_SUCCEED;
}
@= extreme_init_oid
	for (yy = 0 ; yy < BATcount(e) ; yy++) extremes[yy] = GDK_oid_@1;
@= extreme_init_ptr
	memset(extremes, 0, BATcount(e)*sizeof(ptr));
@= extreme_body_oid
			oid *val = extremes + r - off;
			if (*val != *(oid*)nil) {
				if ((*cmp)(t,nil) == 0) {
					*val = *(oid*)nil;
				} else if ((*cmp)(t,val) @1 0) {
					*val = *(oid*)t;
				}
			}
@= extreme_body_ptr
			ptr *val = extremes + r - off;
			if (*val != nil) {
				if ((*cmp)(t,nil) == 0) {
					*val = nil;
				} else if (*val == NULL || (*cmp)(t,*val) @1 0) {
					*val = t;
				}
			}
@= extreme_tail_oid
	&val
@= extreme_tail_ptr
	val?val:nil
@= extreme_
@:extreme(@1,@2,oid,@3)@
@:extreme(@1,@2,ptr,@3)@
int
CMDaggr_@1(BAT **ret, BAT *b, BAT *e)
{
	if (b->ttype == TYPE_void) {
		return CMDaggr_@1_oid(ret, b, e);
	} else {
		return CMDaggr_@1_ptr(ret, b, e);
	}
}
@c
@:extreme_(min,<,max)@
@:extreme_(max,>,min)@

@= large_aggr_count
	if (BATprepareHash(bn)) {
		BBPreclaim(bn);
		return GDK_FAIL;
	}
	BATloop(b, p, q) {
		oid *h = (oid*) BUNhead(bi,p);

		BUNfndOID(r, bni, h);
		if (r != BUN_NONE) {
			ptr t = BUNtail(bi,p);
			(void) t; /* silence compiler about unused variable */
			@1 {
				int *dst = (int*) BUNtloc(bni, r);
				(*dst)++;
			}
		}
	}
@c
@= small_aggr_count
	cnt  = (int*) GDKmalloc(range*sizeof(int));
	memset(cnt, 0, range*sizeof(int));
	BATloop(b, p, q) {
		oid h = (*(oid*) BUNhead(bi,p)) - min;

		if (h < range) {
			ptr t = BUNtail(bi,p);
			(void) t; /* silence compiler about unused variable */
			@1 {
				cnt[h]++;
			}
		}
	}
	BATloop(bn, p, q) {
		oid h = (*(oid*) BUNhead(bni,p)) - min;
		*(int*)BUNtloc(bni, p) = cnt[h];
	}
        GDKfree(cnt);
@c

int
CMDaggr_count(BAT **ret, BAT *b, BAT *e, bit *ignore_nils)
{
/* XXX in a large BAT, it is conceivable that there are head elements
   that occur more often than fits in an "int", so the return BAT
   should really have a tail type of BUN.
 */
	BAT *bn = BATnew(e->htype, TYPE_int, BATcount(e));
	BATiter ei = bat_iterator(e), bi = bat_iterator(b), bni = bat_iterator(bn);
	int zero = 0, *cnt;
	BUN p, q, r;
	oid i, range, min, max;
	int btt;
	ptr bt_nil;

	if (bn == NULL)
		return GDK_FAIL;
	btt = b->ttype;
	bt_nil = ATOMnilptr(b->ttype);

	/* init: set all sums to zero */
	bn->tsorted = bn->hsorted = 0;
	bn->T->nonil = 1;
	ALIGNsetH(bn, e);
	if (BAThordered(e) & 1) {
		min = *(oid *) BUNhead(ei, BUNfirst(e));
		BATloop(e, p, q) {
			if (BUNfastins(bn, BUNhead(ei, p), &zero) == NULL) {
				BBPreclaim(bn);
				return GDK_FAIL;
			}
		}
		max = *(oid *) BUNhead(ei, BUNlast(e) - 1);
	} else {
		min = max = *(oid *) BUNhead(ei, BUNfirst(e));
		BATloop(e, p, q) {
			if (BUNfastins(bn, BUNhead(ei, p), &zero) == NULL) {
				BBPreclaim(bn);
				return GDK_FAIL;
			}
			i = *(oid *) BUNhead(ei, p);
			if (i < min)
				min = i;
			else if (i > max)
				max = i;
		}
	}
	range = max - min + 1;

	/* scan b, and add increment totals for true values */
	if (range > SMALL_AGGR_MAX) {
		if (*ignore_nils && !b->T->nonil) {
			ALGODEBUG THRprintf(GDKout, "#CMDaggr_count: range(=" OIDFMT ") > SMALL_AGGR_MAX(=%d)  =>  large_aggr_count(if (ATOMcmp(btt,t,bt_nil)))\n", range, SMALL_AGGR_MAX);

			@:large_aggr_count(if(ATOMcmp(btt,t,bt_nil)))@
		} else {
			ALGODEBUG THRprintf(GDKout, "#CMDaggr_count: range(=" OIDFMT ") > SMALL_AGGR_MAX(=%d)  =>  large_aggr_count()\n", range, SMALL_AGGR_MAX);

			@:large_aggr_count()@
		}
	} else {
		if (*ignore_nils && !b->T->nonil) {
			ALGODEBUG THRprintf(GDKout, "#CMDaggr_count: range(=" OIDFMT ") <= SMALL_AGGR_MAX(=%d)  =>  small_aggr_count(if (ATOMcmp(btt,t,bt_nil)))\n", range, SMALL_AGGR_MAX);

			@:small_aggr_count(if(ATOMcmp(btt,t,bt_nil)))@
		} else {
			ALGODEBUG THRprintf(GDKout, "#CMDaggr_count: range(=" OIDFMT ") <= SMALL_AGGR_MAX(=%d)  =>  small_aggr_count()\n", range, SMALL_AGGR_MAX);

			@:small_aggr_count()@
		}
	}
	*ret = bn;
	return GDK_SUCCEED;
}

int
CMDaggr_size(BAT **ret, BAT *b, BAT *e)
{
	BAT *bn = BATnew(e->htype, TYPE_wrd, BATcount(e));
	BATiter ei = bat_iterator(e), bi = bat_iterator(b), bni = bat_iterator(bn);
	wrd zero = 0;
	BUN p, q, r;

	if (bn == NULL)
		return GDK_FAIL;
	/* init: set all sums to zero */
	bn->tsorted = bn->hsorted = 0;
	bn->T->nonil = 1;
	ALIGNsetH(bn, e);
	BATloop(e, p, q) {
		if (BUNfastins(bn, BUNhead(ei, p), &zero) == NULL) {
			BBPreclaim(bn);
			return GDK_FAIL;
		}
	}
	/* scan b, and add increment totals for true values */
	if (BATprepareHash(bn)) {
		BBPreclaim(bn);
		return GDK_FAIL;
	}
	BATloop(b, p, q) {
		if (*(bit *) BUNtloc(bi, p) == TRUE) {
			oid *h = (oid *) BUNhead(bi, p);

			BUNfndOID(r, bni, h);
			if (r != BUN_NONE) {
				wrd *dst = (wrd *) BUNtloc(bni, r);

				(*dst)++;
			}
		}
	}
	*ret = bn;
	return GDK_SUCCEED;
}

int
CMDsize(wrd *ret, BAT *b)
{
	*ret = BATgetprop_wrd(b, GDK_AGGR_SIZE);
	if (*ret < 0) {
		BATiter bi = bat_iterator(b);
		bit *cur = (bit *) BUNtail(bi, BUNfirst(b));
		bit *end = (bit *) BUNtail(bi, BUNlast(b));
		wrd cnt;

		for (cnt = 0; cur < end; cur++)
			cnt += (*cur == TRUE);
		BATsetprop_wrd(b, GDK_AGGR_SIZE, *ret = cnt);
	}
	return GDK_SUCCEED;
}

#define CARD_INC_BOUNDED(x,y) if (++(x) > (y)) break
#define CARD_INC_UNBOUNDED(x,y) ++(x)

@= card_bound_tpe
	if (BATtordered(b)&1) {
		/* the sorted algorithm: scan */
		ptr prev =  (ptr) BUNt@2(bi, BUNfirst(b));
		cursize = 1; /* start counting unique elements... (at one) */
		BATloop(b, p, q) {
			ptr cur =  (ptr) BUNt@2(bi, p);
			if (!@1_EQ(prev, cur, @5)) {
				CARD_INC_@4(cursize, maxsize);
				prev = cur;
			}
		}
	} else {
		/* default algorithm is hash based */
		BUN yy = BUNfirst(b);
		BAT *v = VIEWcreate(BATmirror(b), BATmirror(b));
		BATiter vi = bat_iterator(v);
		Heap *hp = (Heap*) GDKmalloc(sizeof(Heap));
		str nme = BBP_physical(v->batCacheid);
		hp->filename = (str) GDKmalloc(strlen(nme)+12);
		sprintf(hp->filename, "%s.%chash", nme, v->batCacheid>0?'h':'t');
		if ((v->H->hash = HASHnew(hp, any, BATcapacity(b), HASHmask(BATcount(b)))) == NULL) {
			BBPreclaim(v);
			return GDK_FAIL;
		}
		BATmirror(v)->T->hash = v->H->hash; 
		cursize = 0; /* start counting unique elements... (at zero) */
		BATloop(b, p, q) {
			ptr cur =  (ptr) BUNt@2(bi, p);
			HASHfnd_@3(r, vi, cur);
			if (r == BUN_NONE) {
				CARD_INC_@4(cursize, maxsize);
				HASHins_@3(v->H->hash, yy, cur);
			}
			yy++;
		}
		BBPreclaim(v); /* free view and hash table */
	}
	break;
@= card_bound
	{
		int any = tpe;	/* name chosen for convenience in atom macros */
		switch(ATOMstorage(any)) {
#ifndef NOEXPAND_CHR
		case TYPE_chr:
			@:card_bound_tpe(simple,loc,chr,@1,chr)@
#endif
#ifndef NOEXPAND_BTE
		case TYPE_bte:
			@:card_bound_tpe(simple,loc,bte,@1,bte)@
#endif
#ifndef NOEXPAND_SHT
		case TYPE_sht:
			@:card_bound_tpe(simple,loc,sht,@1,sht)@
#endif
#if !defined(NOEXPAND_INT) || !defined(NOEXPAND_FLT)
		case TYPE_int:
		case TYPE_flt:
			@:card_bound_tpe(simple,loc,int,@1,int)@
#endif
#if !defined(NOEXPAND_LNG) || !defined(NOEXPAND_DBL)
		case TYPE_lng:
		case TYPE_dbl:
			@:card_bound_tpe(simple,loc,lng,@1,lng)@
#endif
		case TYPE_str:
			if (b->T->vheap->hashash) {
				@:card_bound_tpe(atom,var,str_hv,@1,any)@
			}
			/* fall through */
		default:
			if (b->tvarsized) {
				@:card_bound_tpe(atom,var,any,@1,any)@
			} else {
				@:card_bound_tpe(atom,loc,any,@1,any)@
			}
		}
	}
@c

int
CMDcard(wrd *result, BAT *b, wrd *maxelements)
{
	BATiter bi = bat_iterator(b);
	wrd maxsize = *maxelements, cursize = (wrd) BATcount(b);

	if (b->ttype == TYPE_void && b->tseqbase == oid_nil) {
		cursize = 1;
	} else if (cursize > 1 && !b->tkey) {
		cursize = BATgetprop_wrd(b, GDK_AGGR_CARD);
		if ((b->ttype == TYPE_chr || b->ttype == TYPE_bte) && *maxelements > 256) {
			maxsize = 256;
		} else if (b->ttype == TYPE_sht && *maxelements > 65536) {
			maxsize = 65536;
		} else if (cursize == wrd_nil && BATcount(b) > 10000 && *maxelements > 1000 && !(BATtordered(b) & 1)) {
			/* the recursive quick-look optimization does not make sense for the sorted case */
			maxsize = *maxelements / 10;
			CMDcard(&cursize, b, &maxsize);	/* try your luck with a smaller limit... */
			maxsize = *maxelements;
		}
		if (cursize == wrd_nil) {
			BUN p, q, r;	/* if we could not figure out the cardinality by now, we must do real work.. :( */
			int tpe = b->ttype;

			if (tpe == TYPE_str && strElimDoubles(b->T->vheap)) {
				/* use offsets only in case of a double-eliminated string heap */
				tpe = b->T->width == 1 ? TYPE_bte : (b->T->width == 2 ? TYPE_sht : (b->T->width == 4 ? TYPE_int : TYPE_lng));
			}
#if 0
#endif
			if (maxsize <= (wrd) BATcount(b)) {
				@:card_bound(BOUNDED)@
			} else {
				maxsize = (wrd) BATcount(b);	/* reducing maxsize limits memory consumption in hash table */
				@:card_bound(UNBOUNDED)@	/* UNBOUNDED = no overhead for checking maxsize */
			}
		}
	}
	if (cursize <= *maxelements) {
		BATsetprop_wrd(b, GDK_AGGR_CARD, *result = cursize);
	} else {
		*result = wrd_nil;
	}
	return GDK_SUCCEED;
}

int
CMDcard_unlimited(wrd *result, BAT *b)
{
	wrd limit = (wrd) BATcount(b);

	return CMDcard(result, b, &limit);
}

int
CMDhasNil(bit *ret, BAT *b)
{
	*ret = (BATcount(b) == 0) ? FALSE : BATtdense(b) ? (b->tseqbase == oid_nil): !b->T->nonil?bit_nil : FALSE;
	if (*ret == bit_nil) {
		*ret = BUNfnd(BATmirror(b), ATOMnilptr(b->ttype)) ? TRUE : FALSE;
		b->T->nonil = *ret;
	}
	return GDK_SUCCEED;
}

@}
@}
