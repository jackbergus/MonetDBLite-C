@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2008 CWI.
@' All Rights Reserved.

@f trans
@t Transactions
@a M.L. Kersten, P. Boncz
@v 1.0
@* Introduction
In the philosophy of Monet, transaction management overhead should only
be paid when necessary. Transaction management is for this purpose
implemented as a module.
TODO: move simple 2-phase locking transaction code from ODMG to this module.

@* Module Definition
@m
.MODULE trans;

@- global transaction management
@m
.COMMAND sync() : bit = global_sync;
 "save all persistent BATs"
.COMMAND commit() : bit = global_commit;
 "global commit on all persistent BATs (to disk)"
.COMMAND abort() : bit = global_abort;
 "brings all BATs back to state at last global commit"
.COMMAND subcommit(bat[any,str]) : bit = global_subcommit;
 "commit only a set of BATnames, passed in the tail (to which you must have exclusive access!)" 

@- delta status
For each BAT, we can cheaply get the differences (deltas) with respect to a 'previous
state'. Usually, this previous state is the BAT state in the last global commit.

Since only persistent BATs play a role in global commits, for transient BATs this
'previous state' (usually) is the initial (empty) state of the BAT.

The term 'usually' does not apply if the BAT state was manipulated explicitly
with BAT-specific transaction management commands (listed below).
@m
.COMMAND prev(BAT[ANY::1,ANY::2]) : BAT[ANY::1,ANY::2] = trans_prev;
	"the previous state of this BAT"
.COMMAND alpha(BAT[ANY::1,ANY::2]) : BAT[ANY::1,ANY::2] = trans_alpha;
	"give list of insertions since the previous state."
.COMMAND delta(BAT[ANY::1,ANY::2]) : BAT[ANY::1,ANY::2] = trans_delta;
	"give list of deletions since the previous state."

@- BAT-specific transaction management

We may play with the previous state of sets of bats using the below primitives:
@itemize

@item
Commit declares the current state to be the new previous state. If the persists
parameter is true (default = false), the current state of the BATs is added to
the last commit point (it then becomes persistent on disk and this implies also 
that the BATs are made persistent).

@item
Abort undos all changes made to the BATs since the previous state.

@item
Clean is a commit, but declares the BATs clean with respect to their persistent 
state. Thus, any changes made since the last commit are *not* guaranteed to be on disk.  
Quitting or crashing MonetDB will lose those changes. Expert use only!

@end itemize
@m
.COMMAND commit(BAT[ANY,ANY], ...BAT[ANY,ANY]...) = trans_commit;
        "flush the delta status of a BAT (it is *not* written to disk)."
.COMMAND abort(BAT[ANY,ANY], ...BAT[ANY,ANY]...) = trans_abort;
        "undo the delta changes in a BAT."
.COMMAND clean(BAT[ANY,ANY], ...BAT[ANY,ANY]...) = trans_clean;
        "flush the delta status of a BAT.
         (DANGER: it is marked clean, so these changes will not be committed to disk)."

.END trans;
@

@{
@* Implementation Code
@c
#include "monetdb4_config.h"
#include "trans.proto.h"

int
global_sync(bit *ret)
{
	*ret = BBPsync(BBPsize, NULL)?FALSE:TRUE;
	return GDK_SUCCEED;
}

int
global_commit(bit *ret)
{
	*ret = TMcommit()?FALSE:TRUE;
	return GDK_SUCCEED;
}

int
global_abort(bit *ret)
{
	*ret = TMabort()?FALSE:TRUE;
	return GDK_SUCCEED;
}

int 
global_subcommit(bit* ret, BAT *bl)
{
	*ret = TMsubcommit(bl)?FALSE:TRUE;
	return GDK_SUCCEED;
}

int
trans_alpha(BAT **retval, BAT *b)
{
	*retval = BATalpha(b);
	return retval ? GDK_SUCCEED : GDK_FAIL;
}

int
trans_delta(BAT **retval, BAT *b)
{
	*retval = BATdelta(b);
	return retval ? GDK_SUCCEED : GDK_FAIL;
}

int
trans_prev(BAT **retval, BAT *b)
{
	*retval = BATprev(b);
	return retval ? GDK_SUCCEED : GDK_FAIL;
}

int
trans_commit(BAT *b, ...)
{
	va_list ap;

	va_start(ap, b);
	do {
		BATcommit(b);
	} while ((b = va_arg(ap, BAT *)) != 0);

	va_end(ap);
	return GDK_SUCCEED;
}

int
trans_abort(BAT *b, ...)
{
	va_list ap;

	va_start(ap, b);
	do {
		BATundo(b);
		if (b->batPersistence == PERSISTENT)
			BBPsave(b);
	} while ((b = va_arg(ap, BAT *)) != 0);

	va_end(ap);
	return GDK_SUCCEED;
}

int
trans_clean(BAT *b, ...)
{
	va_list ap;

	va_start(ap, b);
	do {
		BATfakeCommit(b);
	} while ((b = va_arg(ap, BAT *)) != 0);

	va_end(ap);
	return GDK_SUCCEED;
}
@
@}
