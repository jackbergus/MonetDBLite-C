@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2007 CWI.
@' All Rights Reserved.

@f aggrX3
@a S. Manegold
@t Improved & Extended Aggregates Module
@v 1.0

This module contains some efficient aggregate functions that compute their
result in one scan, rather than in the iterative manner of the generic
MIL aggregrate implementations.

The implementation code is derived from the original aggr module.
Major changes are
\begin{itemize}
\item
complete type-specific code expansion to avoid any type-checking in the inner-most loops;
\item
where feasible, replaced (expansive) hash-lookup by significantly cheaper positional
void-lookups (if the head-column of the group-extend BAT ("e") is "void") or at least by
(also positional) array lookups (in case the group-ids span a reasonably small range);
\item
in addition to the 2-parameter {}(BAT[oid,any::1] b, BAT[oid,any] e)
functions, there are now also 3-parameter {}(BAT[void,any::1] b,
BAT[void,oid] g, BAT[oid,any] e) functions, that require b & g to be
head-aligned, and do the fetchjoin(reverse(g),b) on-the-fly;
\end{itemize}

@m
.MODULE aggrX3;


@= sumprod_signatures
.COMMAND {sum_@2}(BAT[oid,@1] b, BAT[oid,any] e) : BAT[oid,@2] = CMDaggrX3_sum_@1_@2;
	"grouped tail sum on @1"
.COMMAND {sum_@2}(BAT[oid,@1] b, BAT[oid,oid] g, BAT[oid,any] e) : BAT[oid,@2] = CMDaggrX3_sum3_@1_@2;
	"grouped tail sum on @1"
.COMMAND {prod_@2}(BAT[oid,@1] b, BAT[oid,any] e) : BAT[oid,@2] = CMDaggrX3_prod_@1_@2;
	"grouped tail prod on @1"
.COMMAND {prod_@2}(BAT[oid,@1] b, BAT[oid,oid] g, BAT[oid,any] e) : BAT[oid,@2] = CMDaggrX3_prod3_@1_@2;
	"grouped tail prod on @1"
@m
@:sumprod_signatures(bte,bte)@
@:sumprod_signatures(bte,sht)@
@:sumprod_signatures(bte,int)@
@:sumprod_signatures(bte,wrd)@
@:sumprod_signatures(bte,lng)@
@:sumprod_signatures(sht,sht)@
@:sumprod_signatures(sht,int)@
@:sumprod_signatures(sht,wrd)@
@:sumprod_signatures(sht,lng)@
@:sumprod_signatures(int,int)@
@:sumprod_signatures(int,wrd)@
@:sumprod_signatures(int,lng)@
@:sumprod_signatures(wrd,wrd)@
@:sumprod_signatures(wrd,lng)@
@:sumprod_signatures(lng,wrd)@
@:sumprod_signatures(lng,lng)@
@:sumprod_signatures(flt,flt)@
@:sumprod_signatures(flt,dbl)@
@:sumprod_signatures(dbl,dbl)@

@= avg_signatures
.COMMAND {avg}(BAT[oid,@1] b, BAT[oid,any] e) : BAT[oid,dbl] = CMDaggrX3_avg_@1;
	"grouped tail average on @1"
.COMMAND {avg}(BAT[oid,@1] b, BAT[oid,oid] g, BAT[oid,any] e) : BAT[oid,dbl] = CMDaggrX3_avg3_@1;
	"grouped tail average on @1"
@m
@:avg_signatures(bte)@
@:avg_signatures(sht)@
@:avg_signatures(int)@
@:avg_signatures(wrd)@
@:avg_signatures(lng)@
@:avg_signatures(flt)@
@:avg_signatures(dbl)@

.COMMAND {min}(BAT[oid,any::1] b, BAT[oid,any] e) : BAT[oid,any::1] = CMDaggrX3_min;
	"grouped tail minimum"
.COMMAND {max}(BAT[oid,any::1] b, BAT[oid,any] e) : BAT[oid,any::1] = CMDaggrX3_max;
	"grouped tail maximum"
.COMMAND {min}(BAT[oid,any::1] b, BAT[oid,oid] g, BAT[oid,any] e) : BAT[oid,any::1] = CMDaggrX3_min3;
	"grouped tail minimum"
.COMMAND {max}(BAT[oid,any::1] b, BAT[oid,oid] g, BAT[oid,any] e) : BAT[oid,any::1] = CMDaggrX3_max3;
	"grouped tail maximum"

.COMMAND {count}(BAT[oid,any] b, BAT[oid,any] e, bit ignore_nils) : BAT[oid,int] = CMDaggrX3_count;
	"grouped count; ignores nil values iff ignore_nils==TRUE"
.COMMAND {count}(BAT[oid,any] b, BAT[oid,oid] g, BAT[oid,any] e, bit ignore_nils) : BAT[oid,int] = CMDaggrX3_count3;
	"grouped count; ignores nil values iff ignore_nils==TRUE"

.COMMAND {size}(BAT[oid,bit] b, BAT[oid,any] e) : BAT[oid,wrd] = CMDaggrX3_size;
	"grouped count of true values"

.END aggrX3;

@mil
    proc {count}(BAT[oid,any] b, BAT[oid,any] e) : BAT[oid,int] {
		return {count}(b,e,FALSE);
    }
    ADDHELP("{count}", "manegold", "Jun 03 2003",
    "short-cut for {count}(b,e,FALSE)", "aggrX3");

    proc {count_no_nil}(BAT[oid,any] b, BAT[oid,any] e) : BAT[oid,int] {
		return {count}(b,e,TRUE);
    }
    ADDHELP("{count_no_nil}", "manegold", "Jun 03 2003",
    "short-cut for {count}(b,e,TRUE)", "aggrX3");

    proc {count}(BAT[oid,any] b, BAT[oid,oid] g, BAT[oid,any] e) : BAT[oid,int] {
		return {count}(b,g,e,FALSE);
    }
    ADDHELP("{count}", "manegold", "Jun 03 2003",
    "short-cut for {count}(b,g,e,FALSE)", "aggrX3");

    proc {count_no_nil}(BAT[oid,any] b, BAT[oid,oid] g, BAT[oid,any] e) : BAT[oid,int] {
		return {count}(b,g,e,TRUE);
    }
    ADDHELP("{count_no_nil}", "manegold", "Jun 03 2003",
    "short-cut for {count}(b,g,e,TRUE)", "aggrX3");

    proc size(BAT[any,bit] b) : wrd {
	var h := b.histogram();
	if (h.exist(true))
		return h.find(true).wrd(); # 64bit: when histogram() returns wrd, remove cast
	return wrd(0);
    }

@= sumprod_defaults
    proc {sum}(BAT[oid,@1] b, bat[oid,any] e ) : BAT[oid,@1] {
		return	{sum_@1}(b,e);
    }
    proc {sum}(BAT[oid,@1] b, bat[oid,oid] g, bat[oid,any] e ) :BAT[oid,@1] {
		return	{sum_@1}(b,g,e);
    }
    proc {prod}(BAT[oid,@1] b, bat[oid,any] e ) : BAT[oid,@1] {
		return	{prod_@1}(b,e);
    }
    proc {prod}(BAT[oid,@1] b, bat[oid,oid] g, bat[oid,any] e ) :BAT[oid,@1] {
		return	{prod_@1}(b,g,e);
    }
@mil
@:sumprod_defaults(bte)@
@:sumprod_defaults(sht)@
@:sumprod_defaults(int)@
@:sumprod_defaults(wrd)@
@:sumprod_defaults(lng)@
@:sumprod_defaults(flt)@
@:sumprod_defaults(dbl)@

    proc card(BAT[any,any] b) : wrd {
	return b.tunique().count().[wrd](); # 64bit: when count() returns wrd, remove cast
    }

    proc {card}(BAT[oid,any] b, BAT[oid,any] e) : BAT[oid,wrd] {
	return {count}(b.sunique(),e).[wrd](); # 64bit: when count() returns wrd, remove cast
    }

    proc {card}(BAT[oid,any] b, bat[oid,oid] g, BAT[oid,any] e) : BAT[oid,wrd] {
	return {count}(b.sunique(),g,e).[wrd](); # 64bit: when count() returns wrd, remove cast
    }

@{
@{
@+ Implementation
These implementations need just one scan and a simple hash-maintained data
structure to compute a group of common aggregates.
@c
#include "monetdb4_config.h"
#include <gdk.h>
#include <gdk_scanselect.h>	/* for type-specific HT_bunfastins_nocheck_noinc(), until they're moved to gdk.mx */
#include "aggrX3.proto.h"

/*
with group OIDs spanning a range of less than SMALL_AGGR_MAX (the actual
number of groups might be even less, in case there are "holes" in the group
OID range), we use a simple array as temporary sum/cnt table on order to
benefit from positional lookups; with size of sum <= 8 bytes and size of
cnt == 4 bytes, we stay below 16 KBytes, i.e., within (almost) any L1 cache
*/
#define SMALL_AGGR_MAX 1024

@-
The macro CHKrange is just for array-lookups, analogously to BUNfntVOID &
HASHfnd_oid for void- and hash-lookups, respectively
@c
/* if the test succeeds, we must return something not equal to
   BUN_NONE, but the actual value doesn't matter since it is not
   otherwise used */
#define CHKrange(r, bn, h)	r = (BUN)(*(oid*)(h) >= min && *(oid*)(h) <= max ? 0 : BUN_NONE)

@- Result initialization
@c
/*	init_result
	@1:	tail-type:	bte/sht/int/wrd/lng/flt/dbl / any / void
*/
@= init_result
{
	REGISTER BUN _p = BUNlast(bn);
	REGISTER size_t _cnt = BATcount(e);
	BATiter ei = bat_iterator(e);

	bn->tsorted = bn->hsorted = 0;
	min = max = (oid) 0;
	ALIGNsetH(bn, e);
	/* set all sums/avgs/counts to zero; for prod, zero is 1 */
	/* where necessary, calculate min/max oid with minimal effort */
	if (e->htype == TYPE_void) {
		oid onil = oid_nil;
		(void) onil;	/* silence compiler about unused variable */
		ALGODEBUG THRprintf(GDKout, "#init_result(@1): e->htype == TYPE_void, e->hseqbase=" SZFMT "\n", (size_t) e->hseqbase);
		BATloop(e, p, q) {
			void@1_bunfastins_nocheck_noinc(bn, _p, &onil, &zero);
			_p++;
		}
		BATseqbase(bn,e->hseqbase);
	} else if (BAThordered(e)&1) {
		if (_cnt)
			min = *(oid*)BUNhloc(ei, BUNfirst(e));
		BATloop(e, p, q) {
			oid@1_bunfastins_nocheck_noinc(bn, _p, BUNhloc(ei,p), &zero);
			_p++;
		}
		if (_cnt)
			max = *(oid*)BUNhloc(ei, BUNlast(e)-1);
		ALGODEBUG THRprintf(GDKout, "#init_result(@1): BAThordered(e)&1, min=" SZFMT ", max=" SZFMT "\n", (size_t) min, (size_t) max);
	} else {
		oid i;
		if (_cnt)
			min = max = *(oid*)BUNhloc(ei, BUNfirst(e));
		BATloop(e, p, q) {
			oid@1_bunfastins_nocheck_noinc(bn, _p, BUNhloc(ei,p), &zero);
			_p++;
			i = *(oid*)BUNhloc(ei, p);
			if (i < min)
				min = i;
			else if (i > max)
				max = i;
		}
		ALGODEBUG THRprintf(GDKout, "#init_result(@1): min=" SZFMT ", max=" SZFMT "\n", (size_t) min, (size_t) max);
	}
	BATsetcount(bn, _p);
	if (!bn->batDirty)
		bn->batDirty = TRUE;
}
@- Sum, Product & Average
@c
/*	aggrX3_sum
		e-void-head	e-oid-head	e-oid-head
		void-lookup	hash-lookup	array-lookup

	@1:	0		0		1		use sums-array?
	@2:	0		1		0		do BATprepareHash?
	@3:	BUNfndVOID	HASHfnd_oid	CHKrange	lookup
	@4:	var		loc		loc		e/bn-head-access

	@5:	"BUNhloc(b,p)"	for  (oid) b-head-type,		b-head access
		"&bhsb; bhsb++" for (void) b-head-type

	@6:	bte / sht / int / wrd / lng / flt / dbl		b/bn-tail-type
	@7:	"loc" for fixsized b/bn-tail-type,		b/bn-tail-access
		"var" for varsized b/bn-tail-type		(only loc used currently)

	@8:	BUNt@7(bn,r)	BUNt@7(bn,r)	&sums[(*(oid*)h)-min]
								*dst: sum in-place or in sums-array ?
	@9:	result type
*/
@= aggrX3_sum
	ALGODEBUG THRprintf(GDKout, "#aggrX3_sum(@1,@2,@3,@4,@5,@6,@7,@8,@9);\n");
	if (@1) {
		/* create tmp. sums array */
		size_t i;
		sums = (@9*) GDKmalloc(range*sizeof(@9));
		for (i = 0; i < range; i++)
			sums[i] = zero;
	}
	if (@2 && BATprepareHash(bn)) {
		if (@1)
			GDKfree(sums);
		BBPreclaim(bn);
		return GDK_FAIL;
	}

	/* scan b, and add values to sums in-place or in sums-array */
	bhsb = b->hseqbase - 1;
	BATloop(b, p, q) {
		@6 *t = (@6*) BUNt@7(bi,p);
		oid *h = (oid*) @5;

		@3(r, bni, h);
		if (r != BUN_NONE) {
			@9 *dst = (@9*) @8;
			if (*dst != @9_nil) {
				if (*t == @6_nil) {
					*dst = @9_nil;
				} else {
					*dst += (@9) *t;
				}
			}
		}
	}
	if (@1) {
		/* copy sums array to final result */
		BATloop(bn, p, q) {
			oid h = (*(oid*) BUNh@4(bni,p)) - min;
			*(@9*)BUNt@7(bni, p) = sums[h];
		}
		GDKfree(sums);
	}
@
@c
/*	aggrX3_prod
		e-void-head	e-oid-head	e-oid-head
		void-lookup	hash-lookup	array-lookup

	@1:	0		0		1		use prods-array?
	@2:	0		1		0		do BATprepareHash?
	@3:	BUNfndVOID	HASHfnd_oid	CHKrange	lookup
	@4:	var		loc		loc		e/bn-head-access

	@5:	"BUNhloc(b,p)"	for  (oid) b-head-type,		b-head access
		"&bhsb; bhsb++" for (void) b-head-type

	@6:	bte / sht / int / wrd / lng / flt / dbl		b/bn-tail-type
	@7:	"loc" for fixsized b/bn-tail-type,		b/bn-tail-access
		"var" for varsized b/bn-tail-type		(only loc used currently)

	@8:	BUNt@7(bn,r)	BUNt@7(bn,r)	&prods[(*(oid*)h)-min]
								*dst: prod in-place or in prods-array ?
	@9:	result type
*/
@= aggrX3_prod
	ALGODEBUG THRprintf(GDKout, "#aggrX3_prod(@1,@2,@3,@4,@5,@6,@7,@8,@9);\n");
	if (@1) {
		/* create tmp. prods array */
		size_t i;
		prods = (@9*) GDKmalloc(range*sizeof(@9));
		for (i = 0; i < range; i++)
			prods[i] = zero;
	}
	if (@2 && BATprepareHash(bn)) {
		if (@1)
			GDKfree(prods);
		BBPreclaim(bn);
		return GDK_FAIL;
	}
	/* scan b, and mul values to prods in-place or in prods-array */
	bhsb = b->hseqbase - 1;
	BATloop(b, p, q) {
		@6 *t = (@6*) BUNt@7(bi,p);
		oid *h = (oid*) @5;

		@3(r, bni, h);
		if (r != BUN_NONE) {
			@9 *dst = (@9*) @8;
			if (*dst != @9_nil) {
				if (*t == @6_nil) {
					*dst = @9_nil;
				} else {
					*dst *= (@9) *t;
				}
			}
		}
	}
	if (@1) {
		/* copy prods array to final result */
		BATloop(bn, p, q) {
			oid h = (*(oid*) BUNh@4(bni,p)) - min;
			*(@9*)BUNt@7(bni, p) = prods[h];
		}
		GDKfree(prods);
	}
@
@c
/*	aggrX3_avg
		e-void-head	e-oid-head	e-oid-head
		void-lookup	hash-lookup	array-lookup

	@1:	0		0		1		use sums-array?
	@2:	0		1		0		do BATprepareHash?
	@3:	BUNfndVOID	HASHfnd_oid	CHKrange	lookup
	@4:	var		loc		loc		e/bn-head-access

	@5:	"BUNhloc(b,p)"	for  (oid) b-head-type,		b-head access
		"&bhsb; bhsb++" for (void) b-head-type

	@6:	bte / sht / int / wrd / lng / flt / dbl		b/bn-tail-type
	@7:	"loc" for fixsized b/bn-tail-type,		b/bn-tail-access
		"var" for varsized b/bn-tail-type		(only loc used currently)

	@8:	BUNt@7(bn,r)	BUNt@7(bn,r)	&sums[(*(oid*)h)-min]
								*dst: sum in-place or in sums-array ?

	@9:		r-off		(*(oid*)h)-min	index in cnt array
*/
@= aggrX3_avg
	ALGODEBUG THRprintf(GDKout, "#aggrX3_avg(@1,@2,@3,@4,@5,@6,@7,@8,@9);\n");
	if (@1) {
		/* create tmp. sums array */
		size_t i;
		sums = (dbl*) GDKmalloc(range*sizeof(dbl));
		for (i = 0; i < range; i++)
			sums[i] = zero;
	}
	if (@2 && BATprepareHash(bn)) {
		if (@1)
			GDKfree(sums);
		BBPreclaim(bn);
		return GDK_FAIL;
	}
	cnt = (size_t*) GDKmalloc(slots*sizeof(cnt[0]));
	memset(cnt, 0, slots*sizeof(cnt[0]));
	/* scan b, adding sums, and incrementing counts */
	bhsb = b->hseqbase - 1;
	BATloop(b, p, q) {
		@6 *t = (@6*) BUNt@7(bi,p);
		oid *h = (oid*) @5;

		@3(r, bni, h);
		if (r != BUN_NONE) {
			dbl *dst = (dbl*) @8;
			if (*dst != dbl_nil) {
				if (*t == @6_nil) {
					*dst = dbl_nil;
				} else {
					*dst += *t;
				}
				cnt[@9]++;
			}
		}
	}
	/* postprocess by dividing sums by counts */
	if (@1) {
		/* sums in sums-array */
		BATloop(bn, p, q) {
			oid h = (*(oid*) BUNh@4(bni,p)) - min;
			dbl *dst = (dbl*) BUNt@7(bni, p);
			if (cnt[h] == 0 || sums[h] == dbl_nil) {
				*dst = dbl_nil;
			} else {
				*dst = (dbl) (sums[h]/cnt[h]);
			}
		}
		GDKfree(sums);
	} else {
		/* sums in-place */
		size_t yy = 0;
		BATloop(bn, p, q) {
			dbl *dst = (dbl*) BUNt@7(bni, p);
			if (cnt[yy] == 0) {
				*dst = dbl_nil;
			} else if (*dst != dbl_nil) {
				*dst = (dbl) (*dst / cnt[yy]);
			}
			yy++;
		}

	}
	GDKfree(cnt);
@c

/*	arithsum
	@6:	bte / sht / int / wrd / lng / flt / dbl	b/bn-tail-type
	@7:	"loc" for fixsized b/bn-tail-type,	b/bn-tail-access
		"var" for varsized b/bn-tail-type	(only loc used currently)
	@9:	result type
*/
@= arithsum
int
CMDaggrX3_sum_@1_@3(BAT **ret, BAT *b, BAT *e)
{
	BAT *bn = BATnew(e->htype, TYPE_@3, BATcount(e));
	BATiter bni = bat_iterator(bn), bi = bat_iterator(b);
	@3 zero = (@3) 0, *sums;
	BUN p, q, r;
	size_t range;
	oid min, max;
	oid bhsb;

	if( bn == NULL)
		return GDK_FAIL;
	ALGODEBUG THRprintf(GDKout, "#CMDaggrX3_sum_@1_@3[@2](b=%s,e=%s);\n",
		BATgetId(b), BATgetId(e));
	/* init: set all sums to zero and calculate min/max oid */
	@:init_result(@3)@
	range = max - min + 1;

	/* scan b, and calculate sums */
	if (e->htype == TYPE_void) {
		/* void lookup */
		if (b->htype == TYPE_void) {
			@:aggrX3_sum(0,0,BUNfndVOID,var,&bhsb;bhsb++,@1,@2,BUNt@2(bni,r),@3)@
		} else {
			@:aggrX3_sum(0,0,BUNfndVOID,var,BUNhloc(bi,p),@1,@2,BUNt@2(bni,r),@3)@
		}
	/* e->htype == TYPE_oid */
	} else if (range > SMALL_AGGR_MAX) {
		/* hash lookup */
		if (b->htype == TYPE_void) {
			@:aggrX3_sum(0,1,HASHfnd_oid,loc,&bhsb;bhsb++,@1,@2,BUNt@2(bni,r),@3)@
		} else {
			@:aggrX3_sum(0,1,HASHfnd_oid,loc,BUNhloc(bi,p),@1,@2,BUNt@2(bni,r),@3)@
		}
	} else {
		/* array lookup */
		if (b->htype == TYPE_void) {
			@:aggrX3_sum(1,0,CHKrange,loc,&bhsb;bhsb++,@1,@2,&sums[(*(oid*)h)-min],@3)@
		} else {
			@:aggrX3_sum(1,0,CHKrange,loc,BUNhloc(bi,p),@1,@2,&sums[(*(oid*)h)-min],@3)@
		}
	}

	*ret = bn;
	return GDK_SUCCEED;
}
@c

/*	arithprod
	@6:	bte / sht / int / wrd / lng / flt / dbl	b/bn-tail-type
	@7:	"loc" for fixsized b/bn-tail-type,	b/bn-tail-access
		"var" for varsized b/bn-tail-type	(only loc used currently)
	@9:	result type
*/
@= arithprod
int
CMDaggrX3_prod_@1_@3(BAT **ret, BAT *b, BAT *e)
{
	BAT *bn = BATnew(e->htype, TYPE_@3, BATcount(e));
	BATiter bni = bat_iterator(bn), bi = bat_iterator(b);
	@3 zero = (@3) 1, *prods;
	BUN p, q, r;
	size_t range;
	oid min, max;
	oid bhsb;

	if( bn == NULL)
		return GDK_FAIL;
	ALGODEBUG THRprintf(GDKout, "#CMDaggrX3_prod_@1_@3[@2](b=%s,e=%s);\n",
		BATgetId(b), BATgetId(e));
	/* init: set all prods to zero and calculate min/max oid */
	@:init_result(@3)@
	range = max - min + 1;

	/* scan b, and calculate prods */
	if (e->htype == TYPE_void) {
		/* void lookup */
		if (b->htype == TYPE_void) {
			@:aggrX3_prod(0,0,BUNfndVOID,var,&bhsb;bhsb++,@1,@2,BUNt@2(bni,r),@3)@
		} else {
			@:aggrX3_prod(0,0,BUNfndVOID,var,BUNhloc(bi,p),@1,@2,BUNt@2(bni,r),@3)@
		}
	/* e->htype == TYPE_oid */
	} else if (range > SMALL_AGGR_MAX) {
		/* hash lookup */
		if (b->htype == TYPE_void) {
			@:aggrX3_prod(0,1,HASHfnd_oid,loc,&bhsb;bhsb++,@1,@2,BUNt@2(bni,r),@3)@
		} else {
			@:aggrX3_prod(0,1,HASHfnd_oid,loc,BUNhloc(bi,p),@1,@2,BUNt@2(bni,r),@3)@
		}
	} else {
		/* array lookup */
		if (b->htype == TYPE_void) {
			@:aggrX3_prod(1,0,CHKrange,loc,&bhsb;bhsb++,@1,@2,&prods[(*(oid*)h)-min],@3)@
		} else {
			@:aggrX3_prod(1,0,CHKrange,loc,BUNhloc(bi,p),@1,@2,&prods[(*(oid*)h)-min],@3)@
		}
	}

	*ret = bn;
	return GDK_SUCCEED;
}
@c

/*	arithsumprod
	@6:	bte / sht / int / wrd / lng / flt / dbl	b/bn-tail-type
	@7:	"loc" for fixsized b/bn-tail-type,	b/bn-tail-access
		"var" for varsized b/bn-tail-type	(only loc used currently)
	@9:	result type
*/
@= arithsumprod
@:arithsum(@1,@2,@3)@
@:arithprod(@1,@2,@3)@
@c
@:arithsumprod(bte,loc,bte)@
@:arithsumprod(bte,loc,sht)@
@:arithsumprod(bte,loc,int)@
@:arithsumprod(bte,loc,wrd)@
@:arithsumprod(bte,loc,lng)@
@:arithsumprod(sht,loc,sht)@
@:arithsumprod(sht,loc,int)@
@:arithsumprod(sht,loc,wrd)@
@:arithsumprod(sht,loc,lng)@
@:arithsumprod(int,loc,int)@
@:arithsumprod(int,loc,wrd)@
@:arithsumprod(int,loc,lng)@
@:arithsumprod(wrd,loc,wrd)@
@:arithsumprod(wrd,loc,lng)@
@:arithsumprod(lng,loc,wrd)@
@:arithsumprod(lng,loc,lng)@
@:arithsumprod(flt,loc,flt)@
@:arithsumprod(flt,loc,dbl)@
@:arithsumprod(dbl,loc,dbl)@

/*	arithavg
	@6:	bte / sht / int / wrd / lng / flt / dbl	b/bn-tail-type
	@7:	"loc" for fixsized b/bn-tail-type,	b/bn-tail-access
		"var" for varsized b/bn-tail-type	(only loc used currently)
*/
@= arithavg
int
CMDaggrX3_avg_@1(BAT **ret, BAT *b, BAT *e)
{
	BAT *bn = BATnew(e->htype, TYPE_dbl, BATcount(e));
	BATiter bni = bat_iterator(bn), bi = bat_iterator(b);
	size_t off;
	size_t *cnt;
	size_t slots, range;
	oid min, max;
	dbl zero = (dbl) 0, *sums;
	BUN p, q, r;
	oid bhsb;

	if( bn == NULL)
		return GDK_FAIL;
	off = BUNfirst(bn);

	ALGODEBUG THRprintf(GDKout, "#CMDaggrX3_avg_@1[@2](b=%s,e=%s);\n",
		BATgetId(b),BATgetId(e));
	/* init: set all sums & counts to zero and calculate min/max oid */
	@:init_result(dbl)@
	range = max - min + 1;

	/* scan b, calculate sums & counts, derive averages */
	if (e->htype == TYPE_void) {
		/* void lookup */
		slots = BATcount(e);
		if (b->htype == TYPE_void) {
			@:aggrX3_avg(0,0,BUNfndVOID,var,&bhsb;bhsb++,@1,@2,BUNt@2(bni,r),r-off)@
		} else {
			@:aggrX3_avg(0,0,BUNfndVOID,var,BUNhloc(bi,p),@1,@2,BUNt@2(bni,r),r-off)@
		}
	/* e->htype == TYPE_oid */
	} else if (range > SMALL_AGGR_MAX) {
		/* hash lookup */
		slots = BATcount(e);
		if (b->htype == TYPE_void) {
			@:aggrX3_avg(0,1,HASHfnd_oid,loc,&bhsb;bhsb++,@1,@2,BUNt@2(bni,r),r-off)@
		} else {
			@:aggrX3_avg(0,1,HASHfnd_oid,loc,BUNhloc(bi,p),@1,@2,BUNt@2(bni,r),r-off)@
		}
	} else {
		/* array lookup */
		slots = range;
		if (b->htype == TYPE_void) {
			@:aggrX3_avg(1,0,CHKrange,loc,&bhsb;bhsb++,@1,@2,&sums[(*(oid*)h)-min],(*(oid*)h)-min)@
		} else {
			@:aggrX3_avg(1,0,CHKrange,loc,BUNhloc(bi,p),@1,@2,&sums[(*(oid*)h)-min],(*(oid*)h)-min)@
		}
	}

	*ret = bn;
	return GDK_SUCCEED;
}
@c
@:arithavg(bte,loc)@
@:arithavg(sht,loc)@
@:arithavg(int,loc)@
@:arithavg(wrd,loc)@
@:arithavg(lng,loc)@
@:arithavg(flt,loc)@
@:arithavg(dbl,loc)@

@- "Extremes" (Min & Max)
@c
/*	aggrX3_minmax_ptr
		e-void-head	e-oid-head	e-oid-head
		void-lookup	hash-lookup	array-lookup

	@1:	</>		</>		</>		compare operator: <(min) or >(max)
	@2:	0		1		0		do BATprepareHash?
	@3:	BUNfndVOID	HASHfnd_oid	CHKrange	lookup
	@4:	var		loc		loc		e/bn-head-access

	@5:	"BUNhloc(b,p)"	for  (oid) b-head-type,		b-head access
		"&bhsb; bhsb++" for (void) b-head-type

	@6:		sht / int / lng / any			b/bn-tail-storage-type
	@7:	"loc" for fixsized b/bn-tail-type,		b/bn-tail-access
		"var" for varsized b/bn-tail-type

	@8:		r-off		(*(oid*)h)-min	index in extremes array
	@9:		max/min					initial result value
*/
@= aggrX3_minmax_ptr
	ALGODEBUG THRprintf(GDKout, "#aggrX3_minmax_ptr(@1,@2,@3,@4,@5,@6,@7,@8,@9);\n");
	if (@2 && BATprepareHash(e)) {
		GDKfree(extremes);
		BBPreclaim(e);
		return GDK_FAIL;
	}
	/* init: create extremes and set all to the zero pointer */
	extremes = (ptr*) GDKmalloc(slots*sizeof(ptr));
	memset(extremes, 0, slots*sizeof(ptr));
	/* scan b and replace totals by the extreme value (just pointers to vals in b) */
	bhsb = b->hseqbase - 1;
	BATloop(b, p, q) {
		ptr t = BUNt@7(bi,p);
		oid *h = (oid*) @5;

		@3(r, bni, h);
		if (r != BUN_NONE) {
			ptr *val = &extremes[@8];
			if (*val != nil) {
				if ((*cmp)(t,nil) == 0) {
					*val = nil;
				} else if (*val == NULL || (*cmp)(t,*val) @1 0) {
					*val = t;
				}
			}
		}
	}
	/* insert the extreme values into the result */
	BATloop(bn, r, q) {
		oid *h = (oid*)BUNh@4(bni,r);
		ptr val = extremes[@8];
		(void) h;	/* silence compiler about unused variable */
		/* trick: using a void head-type, only the tail are (over)written */
		ATOMput(bn->ttype, bn->theap, BUNtloc(bni,r), val?val:nil);
	}
@c
/*	aggrX3_minmax_oid
		e-void-head	e-oid-head	e-oid-head
		void-lookup	hash-lookup	array-lookup

	@1:	</>		</>		</>		compare operator: <(min) or >(max)
	@2:	0		1		0		do BATprepareHash?
	@3:	BUNfndVOID	HASHfnd_oid	CHKrange	lookup
	@4:	var		loc		loc		e/bn-head-access

	@5:	"BUNhloc(b,p)"	for  (oid) b-head-type,		b-head access
		"&bhsb; bhsb++" for (void) b-head-type

	@6:		sht / int / lng / any			b/bn-tail-storage-type
	@7:	"loc" for fixsized b/bn-tail-type,		b/bn-tail-access
		"var" for varsized b/bn-tail-type

	@8:		r-off		(*(oid*)h)-min	index in extremes array
	@9:		max/min					initial result value
*/
@= aggrX3_minmax_oid
	ALGODEBUG THRprintf(GDKout, "#aggrX3_minmax_oid(@1,@2,@3,@4,@5,@6,@7,@8,@9);\n");
	if (@2 && BATprepareHash(e)) {
		GDKfree(extremes);
		BBPreclaim(e);
		return GDK_FAIL;
	}
	/* init: create extremes and set all to the zero pointer */
	extremes = (oid*) GDKmalloc(slots*sizeof(oid));
	{ size_t i = 0; for (; i < slots; i++ ) extremes[i] = GDK_oid_@9; }
	/* scan b and replace totals by the extreme value (just pointers to vals in b) */
	bhsb = b->hseqbase - 1;
	BATloop(b, p, q) {
		ptr t = BUNt@7(bi,p);
		oid *h = (oid*) @5;

		@3(r, bni, h);
		if (r != BUN_NONE) {
			oid *val = &extremes[@8];
			if (*val != *(oid*)nil) {
				if ((*cmp)(t,nil) == 0) {
					*val = *(oid*)nil;
				} else if ((*cmp)(t,val) @1 0) {
					*val = *(oid*)t;
				}
			}
		}
	}
	/* insert the extreme values into the result */
	BATloop(bn, r, q) {
		oid *h = (oid*)BUNh@4(bni,r);
		oid val = extremes[@8];
		(void) h;	/* silence compiler about unused variable */
		/* trick: using a void head-type, only the tail are (over)written */
		ATOMput(bn->ttype, bn->theap, BUNtloc(bni,r), &val);
	}
@c

/*	extreme_typed
	@1:	min/max
	@2:	 < / >
	@3:	b/bn-tail-storage-type			sht/int/lng/any
	@4:	"loc" for fixsized b/bn-tail-type,	b/bn-tail-access
		"var" for varsized b/bn-tail-type
	@5:	ptr/oid					void/any
	@6:	max/min					initial result value
*/
@= extreme_typed
static int
aggrX3_@1_@3_@4_@5(BAT **ret, BAT *b, BAT *e)
{
	BAT *bn = BATnew(e->htype, BATttype(b), BATcount(e));
	BATiter bni = bat_iterator(bn), bi = bat_iterator(b);
	int (*cmp)(ptr,ptr);
	ptr nil;
	size_t off;
	@5 *extremes = NULL;
	BUN p, q, r;
	size_t slots, range;
	oid min, max;
	oid bhsb;

	if( bn == NULL)
		return GDK_FAIL;
	cmp = BATatoms[bn->ttype].atomCmp;
	nil =  ATOMnilptr(bn->ttype);
	off =  BUNfirst(bn);
	*ret = NULL;

	ALGODEBUG THRprintf(GDKout, "#aggrX3_@1_@3_@4_@5[@2,@6](b=%s,e=%s);\n",
		BATgetId(b),BATgetId(e));
	/* init: prepare the result bat;
	 * trick: by using "tail-type" void, we only write the head column, here */
	@:init_result(void)@
	range = max - min + 1;

	/* scan b and replace totals by the extreme value (just pointers to vals in b) */
	slots = BATcount(e);
	if (e->htype == TYPE_void) {
		/* void lookup */
		if (b->htype == TYPE_void) {
			@:aggrX3_minmax_@5(@2,0,BUNfndVOID,var,&bhsb; bhsb++,@3,@4,r-off,@6)@
		} else {
			@:aggrX3_minmax_@5(@2,0,BUNfndVOID,var,BUNhloc(bi,p),@3,@4,r-off,@6)@
		}
	/* e->htype == TYPE_oid */
	} else if (range > SMALL_AGGR_MAX) {
		/* hash lookup */
		if (b->htype == TYPE_void) {
			@:aggrX3_minmax_@5(@2,1,HASHfnd_oid,loc,&bhsb; bhsb++,@3,@4,r-off,@6)@
		} else {
			@:aggrX3_minmax_@5(@2,1,HASHfnd_oid,loc,BUNhloc(bi,p),@3,@4,r-off,@6)@
		}
	} else {
		/* array lookup */
		slots = range;
		if (b->htype == TYPE_void) {
			@:aggrX3_minmax_@5(@2,0,CHKrange,loc,&bhsb; bhsb++,@3,@4,(*(oid*)h)-min,@6)@
		} else {
			@:aggrX3_minmax_@5(@2,0,CHKrange,loc,BUNhloc(bi,p),@3,@4,(*(oid*)h)-min,@6)@
		}
	}
	*ret = bn;
bunins_failed:
	if (extremes)
		GDKfree(extremes);
	return *ret?GDK_SUCCEED:GDK_FAIL;
}
@c
/*	extreme
	@1:	min/max
	@2:	 < / >
	@3:	max/min
*/
@= extreme
@:extreme_typed(@1,@2,chr,loc,ptr,@3)@
@:extreme_typed(@1,@2,bte,loc,ptr,@3)@
@:extreme_typed(@1,@2,sht,loc,ptr,@3)@
@:extreme_typed(@1,@2,int,loc,ptr,@3)@
@:extreme_typed(@1,@2,lng,loc,ptr,@3)@
@:extreme_typed(@1,@2,any,loc,ptr,@3)@
@:extreme_typed(@1,@2,any,var,ptr,@3)@
@:extreme_typed(@1,@2,any,var,oid,@3)@

int
CMDaggrX3_@1(BAT **ret, BAT *b, BAT *e)
{
	int rtrn, tt = ATOMstorage(b->ttype);

	ALGODEBUG THRprintf(GDKout, "#CMDaggrX3_@1[@2,@3](b=%s,e=%s);\n",
		BATgetId(b),BATgetId(e));
	if (b->ttype == TYPE_void) {
		rtrn = aggrX3_@1_any_var_oid(ret, b, e);
	} else if (tt == TYPE_chr) {
		rtrn = aggrX3_@1_chr_loc_ptr(ret, b, e);
	} else if (tt == TYPE_bte) {
		rtrn = aggrX3_@1_bte_loc_ptr(ret, b, e);
	} else if (tt == TYPE_sht) {
		rtrn = aggrX3_@1_sht_loc_ptr(ret, b, e);
	} else if (b->ttype != TYPE_bat && (tt == TYPE_int || tt == TYPE_flt)) {
		/* ensure use of ATOMput for TYPE_bat */
		rtrn = aggrX3_@1_int_loc_ptr(ret, b, e);
	} else if (tt == TYPE_dbl || tt == TYPE_lng) {
		rtrn = aggrX3_@1_lng_loc_ptr(ret, b, e);
	} else if (b->tvarsized) {
		rtrn = aggrX3_@1_any_var_ptr(ret, b, e);
	} else {
		rtrn = aggrX3_@1_any_loc_ptr(ret, b, e);
	}
	return rtrn;
}
@c
@:extreme(min,<,max)@
@:extreme(max,>,min)@

@- Count
@c
/*	aggrX3_count
		e-void-head	e-oid-head	e-oid-head
		void-lookup	hash-lookup	array-lookup

	@1:	0		0		1		use cnt-array?
	@2:	0		1		0		do BATprepareHash?
	@3:	BUNfndVOID	HASHfnd_oid	CHKrange	lookup
	@4:	var		loc		loc		e/bn-head-access

	@5:	"BUNhloc(b,p)"	for  (oid) b-head-type,		b-head access
		"&bhsb; bhsb++" for (void) b-head-type

	@6:	BUNtloc(bn,r)	BUNtloc(bn,r)	&cnt[(*(oid*)h)-min]
								*dst: count in-place or in cnt-array ?
*/
@= aggrX3_count
	ALGODEBUG THRprintf(GDKout, "#aggrX3_count(@1,@2,@3,@4,@5,@6);\n");
	if (@1) {
		/* create tmp. cnt array */
		cnt = (int*) GDKmalloc(range*sizeof(int));
		memset(cnt, 0, range*sizeof(int));
	}
	if (@2 && BATprepareHash(bn)) {
		if (@1)
			GDKfree(cnt);
		BBPreclaim(bn);
		return GDK_FAIL;
	}
	/* scan b, and increment counts in-place or in cnt-array */
	bhsb = b->hseqbase-1;
	btt = b->ttype;
	if (*ignore_nils) {
		switch(ATOMstorage(btt)) {
		case TYPE_chr:
			@:aggrX3_count_loop(@1,@2,@3,@4,@5,@6,if (!simple_EQ(BUNtloc(bi,p),bt_nil,chr)))@
		case TYPE_bte:
			@:aggrX3_count_loop(@1,@2,@3,@4,@5,@6,if (!simple_EQ(BUNtloc(bi,p),bt_nil,bte)))@
		case TYPE_sht:
			@:aggrX3_count_loop(@1,@2,@3,@4,@5,@6,if (!simple_EQ(BUNtloc(bi,p),bt_nil,sht)))@
		case TYPE_int:
			@:aggrX3_count_loop(@1,@2,@3,@4,@5,@6,if (!simple_EQ(BUNtloc(bi,p),bt_nil,int)))@
		case TYPE_lng:
			@:aggrX3_count_loop(@1,@2,@3,@4,@5,@6,if (!simple_EQ(BUNtloc(bi,p),bt_nil,lng)))@
		case TYPE_flt:
			@:aggrX3_count_loop(@1,@2,@3,@4,@5,@6,if (!simple_EQ(BUNtloc(bi,p),bt_nil,flt)))@
		case TYPE_dbl:
			@:aggrX3_count_loop(@1,@2,@3,@4,@5,@6,if (!simple_EQ(BUNtloc(bi,p),bt_nil,dbl)))@
		default:
			if (b->tvarsized) {
				@:aggrX3_count_loop(@1,@2,@3,@4,@5,@6,if (!atom_EQ(BUNtvar(bi,p),bt_nil,btt)))@
			  } else {
				@:aggrX3_count_loop(@1,@2,@3,@4,@5,@6,if (!atom_EQ(BUNtloc(bi,p),bt_nil,btt)))@
			  }
		}
	} else {
		switch(ATOMstorage(btt)) {
		case TYPE_chr:
			@:aggrX3_count_loop(@1,@2,@3,@4,@5,@6,)@
		case TYPE_bte:
			@:aggrX3_count_loop(@1,@2,@3,@4,@5,@6,)@
		case TYPE_sht:
			@:aggrX3_count_loop(@1,@2,@3,@4,@5,@6,)@
		case TYPE_int:
			@:aggrX3_count_loop(@1,@2,@3,@4,@5,@6,)@
		case TYPE_lng:
			@:aggrX3_count_loop(@1,@2,@3,@4,@5,@6,)@
		case TYPE_flt:
			@:aggrX3_count_loop(@1,@2,@3,@4,@5,@6,)@
		case TYPE_dbl:
			@:aggrX3_count_loop(@1,@2,@3,@4,@5,@6,)@
		default:
			if (b->tvarsized) {
				@:aggrX3_count_loop(@1,@2,@3,@4,@5,@6,)@
			} else {
				@:aggrX3_count_loop(@1,@2,@3,@4,@5,@6,)@
			}
		}
	}
	if (@1) {
		/* copy cnt array to final result */
		BATloop(bn, p, q) {
			oid h = (*(oid*) BUNh@4(bni,p)) - min;
			*(int*)BUNtloc(bni, p) = cnt[h];
		}
		GDKfree(cnt);
	}
@c
/*	aggrX3_count_loop
	@7:	if (!atom_EQ(BUNt{loc,var}(b,p),bt_nil,btt))		b-tail nil check
		if (!simple_EQ(BUNtloc(b,p),bt_nil,{chr,bte,sht,int,flt,lng,dbl}))
*/
@= aggrX3_count_loop
	ALGODEBUG THRprintf(GDKout, "#aggrX3_count_loop(@1,@2,@3,@4,@5,@6,@7);\n");
	BATloop(b, p, q) {
		oid *h = (oid*) @5;

		@3(r, bni, h);
		if (r != BUN_NONE) {
			@7 {
				int *dst = (int*) @6;
				(*dst)++;
			}
		}
	}
	break;
@c
int
CMDaggrX3_count(BAT **ret, BAT *b, BAT *e, bit *ignore_nils)
{
	BATiter bni, bi = bat_iterator(b);
	BAT *bn;
	int zero = 0, *cnt;
	BUN p, q, r;
	size_t range;
	oid min, max;
	oid bhsb;
	int btt;
	ptr bt_nil = ATOMnilptr(b->ttype);

	ALGODEBUG THRprintf(GDKout, "#CMDaggrX3_count(b=%s,e=%s);\n", 
		BATgetId(b),BATgetId(e));

	if (e->htype == TYPE_void && e->ttype == TYPE_void &&
	    b->htype == TYPE_void && BATcount(b) == BATcount(e)) {
		/* simply return counts with one */
		int one = 1;
		bn = BATconst(b, TYPE_int, &one);
		*ret = bn;
		return GDK_SUCCEED;
	}

 	bn = BATnew(e->htype, TYPE_int, BATcount(e));
	bni = bat_iterator(bn);
	if (bn == NULL)
		return GDK_FAIL;

	/* init: set all counts to zero and calculate min/max oid */
	@:init_result(int)@
	range = max - min + 1;

	/* scan b, and calculate counts */
	if (e->htype == TYPE_void) {
		/* void lookup */
		if (b->htype == TYPE_void) {
			@:aggrX3_count(0,0,BUNfndVOID,var,&bhsb;bhsb++,BUNtloc(bni,r))@
		} else {
			@:aggrX3_count(0,0,BUNfndVOID,var,BUNhloc(bi,p),BUNtloc(bni,r))@
		}
		/* e->htype == TYPE_oid */
	} else if (range > SMALL_AGGR_MAX) {
		/* hash lookup */
		if (b->htype == TYPE_void) {
			@:aggrX3_count(0,1,HASHfnd_oid,loc,&bhsb;bhsb++,BUNtloc(bni,r))@
		} else {
			@:aggrX3_count(0,1,HASHfnd_oid,loc,BUNhloc(bi,p),BUNtloc(bni,r))@
		}
	} else {
		/* array lookup */
		if (b->htype == TYPE_void) {
			@:aggrX3_count(1,0,CHKrange,loc,&bhsb;bhsb++,&cnt[(*(oid*)h)-min])@
		} else {
			@:aggrX3_count(1,0,CHKrange,loc,BUNhloc(bi,p),&cnt[(*(oid*)h)-min])@
		}
	}

	*ret = bn;
	return GDK_SUCCEED;
}

@- Size
@c
int
CMDaggrX3_size(BAT **ret, BAT *b, BAT *e)
{
	BAT *bn = BATnew(e->htype, TYPE_wrd, BATcount(e));
	BATiter bni = bat_iterator(bn), bi = bat_iterator(b), ei = bat_iterator(e);
	wrd zero = 0;
	BUN p, q, r;

	if (bn == NULL)
		return GDK_FAIL;
	/* init: set all sums to zero */
	bn->tsorted = bn->hsorted = 0;
	ALIGNsetH(bn, e);
	BATloop(e, p, q) {
		if (BUNfastins(bn, BUNhead(ei, p), &zero) == NULL) {
			BBPreclaim(bn);
			return GDK_FAIL;
		}
	}
	/* scan b, and add increment totals for true values */
	if (BATprepareHash(bn)) {
		BBPreclaim(bn);
		return GDK_FAIL;
	}
	BATloop(b, p, q) {
		if (*(bit *) BUNtloc(bi, p) == TRUE) {
			oid *h = (oid *) BUNhead(bi, p);

			BUNfndOID(r, bni, h);
			if (r != BUN_NONE) {
				wrd *dst = (wrd *) BUNtloc(bni, r);

				(*dst)++;
			}
		}
	}
	*ret = bn;
	return GDK_SUCCEED;
}

@- Sum, Product & Average
@c
/*	aggrX3_sum3
		e-void-head	e-oid-head	e-oid-head
		void-lookup	hash-lookup	array-lookup

	@1:	0		0		1		use sums-array?
	@2:	0		1		0		do BATprepareHash?
	@3:	BUNfndVOID	HASHfnd_oid	CHKrange	lookup
	@4:	var		loc		loc		e/bn-head-access

	@5:	"BUNhloc(b,p)"	for  (oid) b-head-type,		b-head access
		"&bhsb; bhsb++" for (void) b-head-type

	@6:	bte / sht / int / wrd / lng / flt / dbl		b/bn-tail-type

#	not used any more as the result-type needs an argument
#	@7:	"loc" for fixsized b/bn-tail-type,		b/bn-tail-access
#		"var" for varsized b/bn-tail-type		(only loc used currently)

	@7:	BUNt@7(bn,r)	BUNt@7(bn,r)	&sums[(*(oid*)h)-min]
								*dst: sum in-place or in sums-array ?
	@8:	<empty> / if (w >= base && w < end)		check head (oid) ranges in case b & g
								are not void-headed and aligned
	@9:	result type
*/
@= aggrX3_sum3
	ALGODEBUG THRprintf(GDKout, "#aggrX3_sum3(@1,@2,@3,@4,@5,@6,@7,@8,@9);\n");
	if (@1) {
		/* create tmp. sums array */
		size_t i;
		sums = (@9*) GDKmalloc(range*sizeof(@9));
		for (i = 0; i < range; i++)
			sums[i] = zero;
	}
	if (@2 && BATprepareHash(bn)) {
		if (@1)
			GDKfree(sums);
		BBPreclaim(bn);
		return GDK_FAIL;
	}
	/* scan b & g, and add values to sums in-place or in sums-array */
	base = BUNfirst(g);
	offset = (ssize_t) (base - g->hseqbase);
	end = base + BATcount(g);
	(void) end;		/* keep compilers happy */
	bhsb = b->hseqbase;
	BATloop(b, p, q) {
		@6 *t = (@6*) BUNtloc(bi,p);
		oid v = *(oid*) @5;

		w = offset + v;
		@8 {
			oid *h = (oid*) BUNtail(gi, w);

			@3(r, bni, (oid*)h);
			if (r != BUN_NONE) {
				@9 *dst = (@9*) @7;
				if (*dst != @9_nil) {
					if (*t == @6_nil) {
						*dst = @9_nil;
					} else {
						*dst += (@9) *t;
					}
				}
			}
		}
	}
	if (@1) {
		/* copy sums array to final result */
		BATloop(bn, p, q) {
			oid h = (*(oid*) BUNh@4(bni,p)) - min;
			*(@9*)BUNtloc(bni, p) = sums[h];
		}
		GDKfree(sums);
	}
@
@c
/*	aggrX3_prod3
		e-void-head	e-oid-head	e-oid-head
		void-lookup	hash-lookup	array-lookup

	@1:	0		0		1		use prods-array?
	@2:	0		1		0		do BATprepareHash?
	@3:	BUNfndVOID	HASHfnd_oid	CHKrange	lookup
	@4:	var		loc		loc		e/bn-head-access

	@5:	"BUNhloc(b,p)"	for  (oid) b-head-type,		b-head access
		"&bhsb; bhsb++" for (void) b-head-type

	@6:	bte / sht / int / wrd / lng / flt / dbl		b/bn-tail-type

#	not used any more as the result-type needs an argument
#	@7:	"loc" for fixsized b/bn-tail-type,		b/bn-tail-access
#		"var" for varsized b/bn-tail-type		(only loc used currently)

	@7:	BUNt@7(bn,r)	BUNt@7(bn,r)	&prods[(*(oid*)h)-min]
								*dst: prod in-place or in prods-array ?
	@8:	<empty> / if (w >= base && w < end)		check head (oid) ranges in case b & g
								are not void-headed and aligned
	@9:	result type
*/
@= aggrX3_prod3
	ALGODEBUG THRprintf(GDKout, "#aggrX3_prod3(@1,@2,@3,@4,@5,@6,@7,@8,@9);\n");
	if (@1) {
		/* create tmp. prods array */
		size_t i;
		prods = (@9*) GDKmalloc(range*sizeof(@9));
		for (i = 0; i < range; i++)
			prods[i] = zero;
	}
	if (@2 && BATprepareHash(bn)) {
		if (@1)
			GDKfree(prods);
		BBPreclaim(bn);
		return GDK_FAIL;
	}
	/* scan b & g, and add values to prods in-place or in prods-array */
	base = BUNfirst(g);
	offset = (ssize_t) (base - g->hseqbase);
	end = base + BATcount(g);
	(void) end;		/* keep compilers happy */
	bhsb = b->hseqbase;
	BATloop(b, p, q) {
		@6 *t = (@6*) BUNtloc(bi,p);
		oid v = *(oid*) @5;

		w = offset + v;
		@8 {
			oid *h = (oid*) BUNtail(gi, w);

			@3(r, bni, (oid*)h);
			if (r != BUN_NONE) {
				@9 *dst = (@9*) @7;
				if (*dst != @9_nil) {
					if (*t == @6_nil) {
						*dst = @9_nil;
					} else {
						*dst *= (@9) *t;
					}
				}
			}
		}
	}
	if (@1) {
		/* copy prods array to final result */
		BATloop(bn, p, q) {
			oid h = (*(oid*) BUNh@4(bni,p)) - min;
			*(@9*)BUNtloc(bni, p) = prods[h];
		}
		GDKfree(prods);
	}
@
@c
/*	aggrX3_avg3
		e-void-head	e-oid-head	e-oid-head
		void-lookup	hash-lookup	array-lookup

	@1:	0		0		1		use sums-array?
	@2:	0		1		0		do BATprepareHash?
	@3:	BUNfndVOID	HASHfnd_oid	CHKrange	lookup
	@4:	var		loc		loc		e/bn-head-access

	@5:	"BUNhloc(b,p)"	for  (oid) b-head-type,		b-head access
		"&bhsb; bhsb++" for (void) b-head-type

	@6:	bte / sht / int / wrd / lng / flt / dbl		b/bn-tail-type
	@7:	"loc" for fixsized b/bn-tail-type,		b/bn-tail-access
		"var" for varsized b/bn-tail-type		(only loc used currently)

	@8:	BUNt@7(bn,r)	BUNt@7(bn,r)	&sums[(*(oid*)h)-min]
								*dst: sum in-place or in sums-array ?

	@9:		r-off		(*(oid*)h)-min	index in cnt array
*/
@= aggrX3_avg3
	ALGODEBUG THRprintf(GDKout, "#aggrX3_avg3(@1,@2,@3,@4,@5,@6,@7,@8,@9);\n");
	if (@1) {
		/* create tmp. sums array */
		size_t i;
		sums = (dbl*) GDKmalloc(range*sizeof(dbl));
		for (i = 0; i < range; i++)
			sums[i] = zero;
	}
	if (@2 && BATprepareHash(bn)) {
		if (@1)
			GDKfree(sums);
		BBPreclaim(bn);
		return GDK_FAIL;
	}
	cnt = (size_t*) GDKmalloc(slots*sizeof(cnt[0]));
	memset(cnt, 0, slots*sizeof(cnt[0]));
	/* scan b & g, adding sums, and incrementing counts */
	base = BUNfirst(g);
	offset = (ssize_t) (base - g->hseqbase);
	end = base + BATcount(g);
	(void) end;		/* keep compilers happy */
	bhsb = b->hseqbase;
	BATloop(b, p, q) {
		@6 *t = (@6*) BUNt@7(bi,p);
		oid v = *(oid*) @5;

		w = offset + v;
		if (w >= base && w < end) {
			oid *h = (oid*) BUNtail(gi, w);

			@3(r, bni, (oid*)h);
			if (r != BUN_NONE) {
				dbl *dst = (dbl*) @8;
				if (*dst != dbl_nil) {
					if (*t == @6_nil) {
						*dst = dbl_nil;
					} else {
						*dst += *t;
					}
					cnt[@9]++;
				}
			}
		}
	}
	/* postprocess by dividing sums by counts */
	if (@1) {
		/* sums in sums-array */
		BATloop(bn, p, q) {
			oid h = (*(oid*) BUNh@4(bni,p)) - min;
			dbl *dst = (dbl*) BUNt@7(bni, p);
			if (cnt[h] == 0 || sums[h] == dbl_nil) {
				*dst = dbl_nil;
			} else {
				*dst = sums[h]/cnt[h];
			}
		}
		GDKfree(sums);
	} else {
		/* sums in-place */
		size_t yy = 0;
		BATloop(bn, p, q) {
			dbl *dst = (dbl*) BUNt@7(bni, p);
			if (cnt[yy] == 0) {
				*dst = dbl_nil;
			} else if (*dst != dbl_nil) {
				*dst /= cnt[yy];
			}
			yy++;
		}

	}
	GDKfree(cnt);
@c

/*	arithsum3
	@6:	bte / sht / int / wrd / lng / flt / dbl		b/bn-tail-type

#	not used any more
#	@7:	"loc" for fixsized b/bn-tail-type,	b/bn-tail-access
#		"var" for varsized b/bn-tail-type	(only loc used currently)

	@9:	result type
*/
@= arithsum3

static int
aggrX3_sum3_@1_@2_EarrayBvoidGvoid (BAT *bn, BAT *b, BAT *g, BAT *e, size_t range, oid min, oid max)
{
	@2 zero = (@2) 0, *sums;
	BUN p, q, r;
	oid bhsb;
	size_t base, end, w;
	ssize_t offset;
	BATiter bni = bat_iterator(bn), bi = bat_iterator(b), gi = bat_iterator(g);

	ALGODEBUG THRprintf(GDKout, "#aggrX3_sum3_@1_@2_EarrayBvoidGvoid(bn=%s,b=%s,g=%s,e=%s,range=" SZFMT ",min=" SZFMT ",max=" SZFMT ");\n",
				BATgetId(bn),BATgetId(b),BATgetId(g),BATgetId(e),
				range,(size_t) min,(size_t) max);
	@:aggrX3_sum3(1,0,CHKrange,loc,&bhsb;bhsb++,@1,&sums[(*(oid*)h)-min],,@2)@
	return GDK_SUCCEED;
}

int
CMDaggrX3_sum3_@1_@2(BAT **ret, BAT *b, BAT *g, BAT *e)
{
	BAT *bn = BATnew(e->htype, TYPE_@2, BATcount(e));
	BATiter bni = bat_iterator(bn), bi = bat_iterator(b), gi = bat_iterator(g);
	@2 zero = (@2) 0, *sums;
	BUN p, q, r;
	size_t range;
	oid min, max;
	oid bhsb;
	size_t base, end, w;
	ssize_t offset;

	if( bn == NULL)
		return GDK_FAIL;
	ALGODEBUG THRprintf(GDKout, "#CMDaggrX3_sum3_@1_@2(b=%s,g=%s,e=%s);\n",
		BATgetId(b),BATgetId(g), BATgetId(e));
/*	ERRORcheck((BATcount(b)!=BATcount(g)), "CMDaggrX3_sum3_@1: BATs b & g must be of equal size.\n");	*/
	ERRORcheck((g->htype == TYPE_void) && (g->hseqbase == oid_nil) && (BATcount(g) > 0), "CMDaggrX3_sum3_@1: head of BAT g must not be nil.\n");

	if((g->hseqbase == oid_nil) || (!BAThdense(g)) || (!(BAThordered(b)&1)) || (!g->hkey)) {
		return CMDaggrX3_sum_@1_@2(ret, BATjoin(BATmirror(g),b,oid_nil), e);
	}

	*ret = bn;

	/* init: set all sums to zero and calculate min/max oid */
	@:init_result(@2)@
	range = max - min + 1;

	/* scan b & g, and calculate sums */
	if (e->htype == TYPE_void) {
		/* void lookup */
		if (b->htype == TYPE_void) {
			if ((g->htype == TYPE_void)&&(BATcount(b)==BATcount(g))&&(b->hseqbase==g->hseqbase)) {
				@:aggrX3_sum3(0,0,BUNfndVOID,var,&bhsb;bhsb++,@1,BUNtloc(bni,r),,@2)@
			} else {
				@:aggrX3_sum3(0,0,BUNfndVOID,var,&bhsb;bhsb++,@1,BUNtloc(bni,r),if (w >= base && w < end),@2)@
			}
		} else {
			@:aggrX3_sum3(0,0,BUNfndVOID,var,BUNhloc(bi,p),@1,BUNtloc(bni,r),if (w >= base && w < end),@2)@
		}
	/* e->htype == TYPE_oid */
	} else if (range > SMALL_AGGR_MAX) {
		/* hash lookup */
		if (b->htype == TYPE_void) {
			if ((g->htype == TYPE_void)&&(BATcount(b)==BATcount(g))&&(b->hseqbase==g->hseqbase)) {
				@:aggrX3_sum3(0,1,HASHfnd_oid,loc,&bhsb;bhsb++,@1,BUNtloc(bni,r),,@2)@
			} else {
				@:aggrX3_sum3(0,1,HASHfnd_oid,loc,&bhsb;bhsb++,@1,BUNtloc(bni,r),if (w >= base && w < end),@2)@
			}
		} else {
			@:aggrX3_sum3(0,1,HASHfnd_oid,loc,BUNhloc(bi,p),@1,BUNtloc(bni,r),if (w >= base && w < end),@2)@
		}
	} else {
		/* array lookup */
		if (b->htype == TYPE_void) {
			if ((g->htype == TYPE_void)&&(BATcount(b)==BATcount(g))&&(b->hseqbase==g->hseqbase)) {
				return aggrX3_sum3_@1_@2_EarrayBvoidGvoid (bn, b, g, e, range, min, max);
			} else {
				@:aggrX3_sum3(1,0,CHKrange,loc,&bhsb;bhsb++,@1,&sums[(*(oid*)h)-min],if (w >= base && w < end),@2)@
			}
		} else {
			@:aggrX3_sum3(1,0,CHKrange,loc,BUNhloc(bi,p),@1,&sums[(*(oid*)h)-min],if (w >= base && w < end),@2)@
		}
	}

	return GDK_SUCCEED;
}
@c

/*	arithprod3
	@6:	bte / sht / int / wrd / lng / flt / dbl		b/bn-tail-type

#	not used any more
#	@7:	"loc" for fixsized b/bn-tail-type,	b/bn-tail-access
#		"var" for varsized b/bn-tail-type	(only loc used currently)

	@9:	result type
*/
@= arithprod3

static int
aggrX3_prod3_@1_@2_EarrayBvoidGvoid (BAT *bn, BAT *b, BAT *g, BAT *e, size_t range, oid min, oid max)
{
	@2 zero = (@2) 1, *prods;
	BUN p, q, r;
	oid bhsb;
	size_t base, end, w;
	ssize_t offset;
	BATiter bni = bat_iterator(bn), bi = bat_iterator(b), gi = bat_iterator(g);

	ALGODEBUG THRprintf(GDKout, "#aggrX3_prod3_@1_@2_EarrayBvoidGvoid(bn=%s,b=%s,g=%s,e=%s,range=" SZFMT ",min=" SZFMT ",max=" SZFMT ");\n",
					BATgetId(bn),BATgetId(b),BATgetId(g),BATgetId(e),
					range,(size_t) min,(size_t) max);
	@:aggrX3_prod3(1,0,CHKrange,loc,&bhsb;bhsb++,@1,&prods[(*(oid*)h)-min],,@2)@

	return GDK_SUCCEED;
}

int
CMDaggrX3_prod3_@1_@2(BAT **ret, BAT *b, BAT *g, BAT *e)
{
	BAT *bn = BATnew(e->htype, TYPE_@2, BATcount(e));
	BATiter bni = bat_iterator(bn), bi = bat_iterator(b), gi = bat_iterator(g);
	@2 zero = (@2) 1, *prods;
	BUN p, q, r;
	size_t range;
	oid min, max;
	oid bhsb;
	size_t base, end, w;
	ssize_t offset;

	if( bn == NULL)
		return GDK_FAIL;
	ALGODEBUG THRprintf(GDKout, "#CMDaggrX3_prod3_@1_@2(b=%s,g=%s,e=%s);\n",
		BATgetId(b),BATgetId(g),BATgetId(e));
/*	ERRORcheck((BATcount(b)!=BATcount(g)), "CMDaggrX3_prod3_@1: BATs b & g must be of equal size.\n");	*/
	ERRORcheck((g->htype == TYPE_void) && (g->hseqbase == oid_nil) && (BATcount(g) > 0), "CMDaggrX3_prod3_@1: head of BAT g must not be nil.\n");

	if((g->hseqbase == oid_nil) || (!BAThdense(g)) || (!(BAThordered(b)&1)) || (!g->hkey)) {
		return CMDaggrX3_prod_@1_@2(ret, BATjoin(BATmirror(g),b,oid_nil), e);
	}

	*ret = bn;

	/* init: set all prods to zero and calculate min/max oid */
	@:init_result(@2)@
	range = max - min + 1;

	/* scan b & g, and calculate prods */
	if (e->htype == TYPE_void) {
		/* void lookup */
		if (b->htype == TYPE_void) {
			if ((g->htype == TYPE_void)&&(BATcount(b)==BATcount(g))&&(b->hseqbase==g->hseqbase)) {
				@:aggrX3_prod3(0,0,BUNfndVOID,var,&bhsb;bhsb++,@1,BUNtloc(bni,r),,@2)@
			} else {
				@:aggrX3_prod3(0,0,BUNfndVOID,var,&bhsb;bhsb++,@1,BUNtloc(bni,r),if (w >= base && w < end),@2)@
			}
		} else {
			@:aggrX3_prod3(0,0,BUNfndVOID,var,BUNhloc(bi,p),@1,BUNtloc(bni,r),if (w >= base && w < end),@2)@
		}
	/* e->htype == TYPE_oid */
	} else if (range > SMALL_AGGR_MAX) {
		/* hash lookup */
		if (b->htype == TYPE_void) {
			if ((g->htype == TYPE_void)&&(BATcount(b)==BATcount(g))&&(b->hseqbase==g->hseqbase)) {
				@:aggrX3_prod3(0,1,HASHfnd_oid,loc,&bhsb;bhsb++,@1,BUNtloc(bni,r),,@2)@
			} else {
				@:aggrX3_prod3(0,1,HASHfnd_oid,loc,&bhsb;bhsb++,@1,BUNtloc(bni,r),if (w >= base && w < end),@2)@
			}
		} else {
			@:aggrX3_prod3(0,1,HASHfnd_oid,loc,BUNhloc(bi,p),@1,BUNtloc(bni,r),if (w >= base && w < end),@2)@
		}
	} else {
		/* array lookup */
		if (b->htype == TYPE_void) {
			if ((g->htype == TYPE_void)&&(BATcount(b)==BATcount(g))&&(b->hseqbase==g->hseqbase)) {
				return aggrX3_prod3_@1_@2_EarrayBvoidGvoid (bn, b, g, e, range, min, max);
			} else {
				@:aggrX3_prod3(1,0,CHKrange,loc,&bhsb;bhsb++,@1,&prods[(*(oid*)h)-min],if (w >= base && w < end),@2)@
			}
		} else {
			@:aggrX3_prod3(1,0,CHKrange,loc,BUNhloc(bi,p),@1,&prods[(*(oid*)h)-min],if (w >= base && w < end),@2)@
		}
	}

	return GDK_SUCCEED;
}
@c

/*	arithsumprod3
	@6:	bte / sht / int / wrd / lng / flt / dbl		b/bn-tail-type

#	not used any more
#	@7:	"loc" for fixsized b/bn-tail-type,	b/bn-tail-access
#		"var" for varsized b/bn-tail-type	(only loc used currently)

	@9:	result type
*/
@= arithsumprod3
@:arithsum3(@1,@2)@
@:arithprod3(@1,@2)@
@c

@:arithsumprod3(bte,bte)@
@:arithsumprod3(bte,sht)@
@:arithsumprod3(bte,int)@
@:arithsumprod3(bte,wrd)@
@:arithsumprod3(bte,lng)@
@:arithsumprod3(sht,sht)@
@:arithsumprod3(sht,int)@
@:arithsumprod3(sht,wrd)@
@:arithsumprod3(sht,lng)@
@:arithsumprod3(int,int)@
@:arithsumprod3(int,wrd)@
@:arithsumprod3(int,lng)@
@:arithsumprod3(wrd,wrd)@
@:arithsumprod3(wrd,lng)@
@:arithsumprod3(lng,wrd)@
@:arithsumprod3(lng,lng)@
@:arithsumprod3(flt,flt)@
@:arithsumprod3(flt,dbl)@
@:arithsumprod3(dbl,dbl)@

/*	arithavg3
	@6:	bte / sht / int / wrd / lng / flt / dbl	b/bn-tail-type
	@7:	"loc" for fixsized b/bn-tail-type,	b/bn-tail-access
		"var" for varsized b/bn-tail-type	(only loc used currently)
	@9:	result type
*/
@= arithavg3
int
CMDaggrX3_avg3_@1(BAT **ret, BAT *b, BAT *g, BAT *e)
{
	BAT *bn = BATnew(e->htype, TYPE_dbl, BATcount(e));
	BATiter bni = bat_iterator(bn), bi = bat_iterator(b), gi = bat_iterator(g);
	size_t off;
	size_t *cnt;
	size_t range;
	oid min, max;
	dbl zero = (dbl) 0, *sums;
	size_t slots;
	BUN p, q, r;
	oid bhsb;
	size_t base, end, w;
	ssize_t offset;

	if( bn == NULL)
		return GDK_FAIL;
	off = BUNfirst(bn);

	ALGODEBUG THRprintf(GDKout, "#CMDaggrX3_avg3_@1[@2](b=%s,g=%s,e=%s);\n",
		BATgetId(b),BATgetId(g),BATgetId(e));
/*	ERRORcheck((BATcount(b)!=BATcount(g)), "CMDaggrX3_avg3_@1: BATs b & g must be of equal size.\n");	*/
	ERRORcheck((g->htype == TYPE_void) && (g->hseqbase == oid_nil) && (BATcount(g) > 0), "CMDaggrX3_avg3_@1: head of BAT g must not be nil.\n");

	if((g->hseqbase == oid_nil) || (!BAThdense(g)) || (!(BAThordered(b)&1)) || (!g->hkey)) {
		return CMDaggrX3_avg_@1(ret, BATjoin(BATmirror(g),b,oid_nil), e);
	}

	/* init: set all sums & counts to zero and calculate min/max oid */
	@:init_result(dbl)@
	range = max - min + 1;

	/* scan b & g, calculate sums & counts, derive averages */
	if (e->htype == TYPE_void) {
		/* void lookup */
		slots = BATcount(e);
		if (b->htype == TYPE_void) {
			@:aggrX3_avg3(0,0,BUNfndVOID,var,&bhsb;bhsb++,@1,@2,BUNt@2(bni,r),r-off)@
		} else {
			@:aggrX3_avg3(0,0,BUNfndVOID,var,BUNhloc(bi,p),@1,@2,BUNt@2(bni,r),r-off)@
		}
	/* e->htype == TYPE_oid */
	} else if (range > SMALL_AGGR_MAX) {
		/* hash lookup */
		slots = BATcount(e);
		if (b->htype == TYPE_void) {
			@:aggrX3_avg3(0,1,HASHfnd_oid,loc,&bhsb;bhsb++,@1,@2,BUNt@2(bni,r),r-off)@
		} else {
			@:aggrX3_avg3(0,1,HASHfnd_oid,loc,BUNhloc(bi,p),@1,@2,BUNt@2(bni,r),r-off)@
		}
	} else {
		/* array lookup */
		slots = range;
		if (b->htype == TYPE_void) {
			@:aggrX3_avg3(1,0,CHKrange,loc,&bhsb;bhsb++,@1,@2,&sums[(*(oid*)h)-min],(*(oid*)h)-min)@
		} else {
			@:aggrX3_avg3(1,0,CHKrange,loc,BUNhloc(bi,p),@1,@2,&sums[(*(oid*)h)-min],(*(oid*)h)-min)@
		}
	}

	*ret = bn;
	return GDK_SUCCEED;
}
@c
@:arithavg3(bte,loc)@
@:arithavg3(sht,loc)@
@:arithavg3(int,loc)@
@:arithavg3(wrd,loc)@
@:arithavg3(lng,loc)@
@:arithavg3(flt,loc)@
@:arithavg3(dbl,loc)@

@- "Extremes" (Min & Max)
@c
/*	aggrX3_minmax3_ptr
		e-void-head	e-oid-head	e-oid-head
		void-lookup	hash-lookup	array-lookup

	@1:	</>		</>		</>		compare operator: <(min) or >(max)
	@2:	0		1		0		do BATprepareHash?
	@3:	BUNfndVOID	HASHfnd_oid	CHKrange	lookup
	@4:	var		loc		loc		e/bn-head-access

	@5:	"BUNhloc(b,p)" for  (oid) b-head-type,		b-head access
		"&bhsb; bhsb++" for (void) b-head-type

	@6:	chr / sht / int / lng / any		b/bn-tail-storage-type
	@7:	"loc" for fixsized b/bn-tail-type,		b/bn-tail-access
		"var" for varsized b/bn-tail-type

	@8:		r-off		(*(oid*)h)-min	index in extremes array
	@9:		max/min					initial result value
*/
@= aggrX3_minmax3_ptr
	ALGODEBUG THRprintf(GDKout, "#aggrX3_minmax3_ptr(@1,@2,@3,@4,@5,@6,@7,@8,@9);\n");
	if (@2 && BATprepareHash(e)) {
		BBPreclaim(e);
		return GDK_FAIL;
	}
	/* init: create extremes and set all to the zero pointer */
	extremes = (ptr*) GDKmalloc(slots*sizeof(ptr));
	memset(extremes, 0, slots*sizeof(ptr));
	/* scan b & g and replace totals by the extreme value (just pointers to vals in b) */
	base = BUNfirst(g);
	offset = (ssize_t) (base - g->hseqbase);
	end = base + BATcount(g);
	bhsb = b->hseqbase;
	BATloop(b, p, q) {
		ptr t = BUNt@7(bi,p);
		oid v = *(oid*) @5;

		w = offset + v;
		if (w >= base && w < end) {
			oid *h = (oid*) BUNtail(gi, w);

			@3(r, bni, (oid*)h);
			if (r != BUN_NONE) {
				ptr *val = &extremes[@8];
				if (*val != nil) {
					if ((*cmp)(t,nil) == 0) {
						*val = nil;
					} else if (*val == NULL || (*cmp)(t,*val) @1 0) {
						*val = t;
					}
				}
			}
		}
	}
	/* insert the extreme values into the result */
	BATloop(bn, r, q) {
		oid *h = (oid*)BUNh@4(bni,r);
		ptr val = extremes[@8];
		(void) h;	/* silence compiler about unused variable */
		ATOMput(bn->ttype, bn->theap, BUNtloc(bni,r), val?val:nil);
	}
@c
/*	aggrX3_minmax3_oid
		e-void-head	e-oid-head	e-oid-head
		void-lookup	hash-lookup	array-lookup

	@1:	</>		</>		</>		compare operator: <(min) or >(max)
	@2:	0		1		0		do BATprepareHash?
	@3:	BUNfndVOID	HASHfnd_oid	CHKrange	lookup
	@4:	var		loc		loc		e/bn-head-access

	@5:	"BUNhloc(b,p)" for  (oid) b-head-type,		b-head access
		"&bhsb; bhsb++" for (void) b-head-type

	@6:	chr / sht / int / lng / any		b/bn-tail-storage-type
	@7:	"loc" for fixsized b/bn-tail-type,		b/bn-tail-access
		"var" for varsized b/bn-tail-type

	@8:		r-off		(*(oid*)h)-min	index in extremes array
	@9:		max/min					initial result value
*/
@= aggrX3_minmax3_oid
	ALGODEBUG THRprintf(GDKout, "#aggrX3_minmax3_oid(@1,@2,@3,@4,@5,@6,@7,@8,@9);\n");
	if (@2 && BATprepareHash(e)) {
		BBPreclaim(e);
		return GDK_FAIL;
	}
	/* init: create extremes and set all to the zero pointer */
	extremes = (oid*) GDKmalloc(slots*sizeof(oid));
	{ size_t i = 0; for (; i < slots; i++ ) extremes[i] = GDK_oid_@9; }
	/* scan b & g and replace totals by the extreme value (just pointers to vals in b) */
	base = BUNfirst(g);
	offset = (ssize_t) (base - g->hseqbase);
	end = base + BATcount(g);
	bhsb = b->hseqbase;
	BATloop(b, p, q) {
		ptr t = BUNt@7(bi,p);
		oid v = *(oid*) @5;

		w = offset + v;
		if (w >= base && w < end) {
			oid *h = (oid*) BUNtail(gi, w);

			@3(r, bni, (oid*)h);
			if (r != BUN_NONE) {
				oid *val = &extremes[@8];
				if (*val != *(oid*)nil) {
					if ((*cmp)(t,nil) == 0) {
						*val = *(oid*)nil;
					} else if ((*cmp)(t,val) @1 0) {
						*val = *(oid*)t;
					}
				}
			}
		}
	}
	/* insert the extreme values into the result */
	BATloop(bn, r, q) {
		oid *h = (oid*)BUNh@4(bni,r);
		oid val = extremes[@8];
		(void) h;	/* silence compiler about unused variable */
		ATOMput(bn->ttype, bn->theap, BUNtloc(bni,r), &val);
	}
@c

/*	extreme_typed
	@1:	min/max
	@2:	 < / >
	@3:	b/bn-tail-storage-type			chr/bte/sht/int/lng/any
	@4:	"loc" for fixsized b/bn-tail-type,	b/bn-tail-access
		"var" for varsized b/bn-tail-type
	@5:	ptr/oid					void/any
	@6:	max/min					initial result value
*/
@= extreme3_typed
static int
aggrX3_@13_@3_@4_@5(BAT **ret, BAT *b, BAT *g, BAT *e)
{
	BAT *bn = BATnew(e->htype, BATttype(b), BATcount(e));
	BATiter bni = bat_iterator(bn), bi = bat_iterator(b), gi = bat_iterator(g);
	int (*cmp)(ptr,ptr);
	ptr nil;
	size_t off;
	@5 *extremes = NULL;
	BUN p, q, r;
	size_t slots, range;
	oid min, max;
	oid bhsb;
	size_t base, end, w;
	ssize_t offset;

	if(bn == NULL)
		return GDK_FAIL;
	cmp = BATatoms[bn->ttype].atomCmp;
	nil = ATOMnilptr(bn->ttype);
	off = BUNfirst(bn);
	*ret = NULL;

	ALGODEBUG THRprintf(GDKout, "#aggrX3_@1_@3_@4_@5[@2,@6](b=%s,g=%s,e=%s);\n",
		BATgetId(b),BATgetId(g),BATgetId(e));
/*	ERRORcheck((BATcount(b)!=BATcount(g)), "aggrX3_@13_@3_@4: BATs b & g must be of equal size.\n");	*/
	ERRORcheck((g->htype == TYPE_void) && (g->hseqbase == oid_nil) && (BATcount(g) > 0), "aggrX3_@13_@3_@4_@5: head of BAT g must not be nil.\n");

	if((g->hseqbase == oid_nil) || (!BAThdense(g)) || (!(BAThordered(b)&1)) || (!g->hkey)) {
		return aggrX3_@1_@3_@4_@5(ret, BATjoin(BATmirror(g),b,oid_nil), e);
	}

	/* init: prepare the result bat;
	 * trick: by using "tail-type" void, we only write the head column, here */
	@:init_result(void)@
	range = max - min + 1;

	/* scan b & g and replace totals by the extreme value (just pointers to vals in b) */
	slots = BATcount(e);
	if (e->htype == TYPE_void) {
		/* void lookup */
		if (b->htype == TYPE_void) {
			@:aggrX3_minmax3_@5(@2,0,BUNfndVOID,var,&bhsb; bhsb++,@3,@4,r-off,@6)@
		} else {
			@:aggrX3_minmax3_@5(@2,0,BUNfndVOID,var,BUNhloc(bi,p),@3,@4,r-off,@6)@
		}
	/* e->htype == TYPE_oid */
	} else if (range > SMALL_AGGR_MAX) {
		/* hash lookup */
		if (b->htype == TYPE_void) {
			@:aggrX3_minmax3_@5(@2,1,HASHfnd_oid,loc,&bhsb; bhsb++,@3,@4,r-off,@6)@
		} else {
			@:aggrX3_minmax3_@5(@2,1,HASHfnd_oid,loc,BUNhloc(bi,p),@3,@4,r-off,@6)@
		}
	} else {
		/* array lookup */
		slots = range;
		if (b->htype == TYPE_void) {
			@:aggrX3_minmax3_@5(@2,0,CHKrange,loc,&bhsb; bhsb++,@3,@4,(*(oid*)h)-min,@6)@
		} else {
			@:aggrX3_minmax3_@5(@2,0,CHKrange,loc,BUNhloc(bi,p),@3,@4,(*(oid*)h)-min,@6)@
		}
	}
	*ret = bn;
bunins_failed:
	if (extremes)
		GDKfree(extremes);
	return *ret?GDK_SUCCEED:GDK_FAIL;
}
@c
/*	extreme
	@1:	min/max
	@2:	 < / >
*/
@= extreme3
@:extreme3_typed(@1,@2,chr,loc,ptr,@3)@
@:extreme3_typed(@1,@2,bte,loc,ptr,@3)@
@:extreme3_typed(@1,@2,sht,loc,ptr,@3)@
@:extreme3_typed(@1,@2,int,loc,ptr,@3)@
@:extreme3_typed(@1,@2,lng,loc,ptr,@3)@
@:extreme3_typed(@1,@2,any,loc,ptr,@3)@
@:extreme3_typed(@1,@2,any,var,ptr,@3)@
@:extreme3_typed(@1,@2,any,var,oid,@3)@

int
CMDaggrX3_@13(BAT **ret, BAT *b, BAT *g, BAT *e)
{
	int rtrn, tt = ATOMstorage(b->ttype);
	ALGODEBUG THRprintf(GDKout, "#CMDaggrX3_@1[@2](b=%s,g=%s,e=%s);\n",
		BATgetId(b),BATgetId(g),BATgetId(e));
/*	ERRORcheck((BATcount(b)!=BATcount(g)), "aggrX3_@13: BATs b & g must be of equal size.\n");	*/
	ERRORcheck((g->htype == TYPE_void) && (g->hseqbase == oid_nil) && (BATcount(g) > 0), "aggrX3_@13: head of BAT g must not be nil.\n");

	if((g->hseqbase == oid_nil) || (!BAThdense(g)) || (!(BAThordered(b)&1)) || (!g->hkey)) {
		return CMDaggrX3_@1(ret, BATjoin(BATmirror(g),b,oid_nil), e);
	}

	if (b->ttype == TYPE_void) {
		rtrn = aggrX3_@13_any_var_oid(ret, b, g, e);
	} else if (tt == TYPE_chr) {
		rtrn = aggrX3_@13_chr_loc_ptr(ret, b, g, e);
	} else if (tt == TYPE_bte) {
		rtrn = aggrX3_@13_bte_loc_ptr(ret, b, g, e);
	} else if (tt == TYPE_sht) {
		rtrn = aggrX3_@13_sht_loc_ptr(ret, b, g, e);
	} else if (b->ttype != TYPE_bat && (tt == TYPE_int || tt == TYPE_flt)) {
		/* ensure use of ATOMput for TYPE_bat */
		rtrn = aggrX3_@13_int_loc_ptr(ret, b, g, e);
	} else if (tt == TYPE_dbl || tt == TYPE_lng) {
		rtrn = aggrX3_@13_lng_loc_ptr(ret, b, g, e);
	} else if (b->tvarsized) {
		rtrn = aggrX3_@13_any_var_ptr(ret, b, g, e);
	} else {
		rtrn = aggrX3_@13_any_loc_ptr(ret, b, g, e);
	}
	return rtrn;
}
@c
@:extreme3(min,<,max)@
@:extreme3(max,>,min)@

@- Count
@c
/*	aggrX3_count3
		e-void-head	e-oid-head	e-oid-head
		void-lookup	hash-lookup	array-lookup

	@1:	0		0		1		use cnt-array?
	@2:	0		1		0		do BATprepareHash?
	@3:	BUNfndVOID	HASHfnd_oid	CHKrange	lookup
	@4:	var		loc		loc		e/bn-head-access

	@5:	"BUNhloc(b,p)" for  (oid) b-head-type,		b-head access
		"&bhsb; bhsb++" for (void) b-head-type

	@6:	BUNtloc(bn,r)	BUNtloc(bn,r)	&cnt[(*(oid*)h)-min]
								*dst: count in-place or in cnt-array ?
*/
@= aggrX3_count3
	ALGODEBUG THRprintf(GDKout, "#aggrX3_count3(@1,@2,@3,@4,@5,@6);\n");
	if (@1) {
		/* create tmp. cnt array */
		cnt = (int*) GDKmalloc(range*sizeof(int));
		memset(cnt, 0, range*sizeof(int));
	}
	if (@2 && BATprepareHash(bn)) {
		if (@1)
			GDKfree(cnt);
		BBPreclaim(bn);
		return GDK_FAIL;
	}
	/* scan b & g, and increment counts in-place or in cnt-array */
	base = BUNfirst(g);
	offset = (ssize_t) (base - g->hseqbase);
	end = base + BATcount(g);
	bhsb = b->hseqbase;
	btt = b->ttype;
	if (*ignore_nils) {
		switch(ATOMstorage(btt)) {
		case TYPE_chr:
			@:aggrX3_count3_loop(@1,@2,@3,@4,@5,@6,if (!simple_EQ(BUNtloc(bi,p),bt_nil,chr)))@
		case TYPE_bte:
			@:aggrX3_count3_loop(@1,@2,@3,@4,@5,@6,if (!simple_EQ(BUNtloc(bi,p),bt_nil,bte)))@
		case TYPE_sht:
			@:aggrX3_count3_loop(@1,@2,@3,@4,@5,@6,if (!simple_EQ(BUNtloc(bi,p),bt_nil,sht)))@
		case TYPE_int:
			@:aggrX3_count3_loop(@1,@2,@3,@4,@5,@6,if (!simple_EQ(BUNtloc(bi,p),bt_nil,int)))@
		case TYPE_lng:
			@:aggrX3_count3_loop(@1,@2,@3,@4,@5,@6,if (!simple_EQ(BUNtloc(bi,p),bt_nil,lng)))@
		case TYPE_flt:
			@:aggrX3_count3_loop(@1,@2,@3,@4,@5,@6,if (!simple_EQ(BUNtloc(bi,p),bt_nil,flt)))@
		case TYPE_dbl:
			@:aggrX3_count3_loop(@1,@2,@3,@4,@5,@6,if (!simple_EQ(BUNtloc(bi,p),bt_nil,dbl)))@
		default:
			if (b->tvarsized) {
				@:aggrX3_count3_loop(@1,@2,@3,@4,@5,@6,if (!atom_EQ(BUNtvar(bi,p),bt_nil,btt)))@
			} else {
				@:aggrX3_count3_loop(@1,@2,@3,@4,@5,@6,if (!atom_EQ(BUNtloc(bi,p),bt_nil,btt)))@
			}
		}
	} else {
		switch(ATOMstorage(btt)) {
		case TYPE_chr:
			@:aggrX3_count3_loop(@1,@2,@3,@4,@5,@6,)@
		case TYPE_bte:
			@:aggrX3_count3_loop(@1,@2,@3,@4,@5,@6,)@
		case TYPE_sht:
			@:aggrX3_count3_loop(@1,@2,@3,@4,@5,@6,)@
		case TYPE_int:
			@:aggrX3_count3_loop(@1,@2,@3,@4,@5,@6,)@
		case TYPE_lng:
			@:aggrX3_count3_loop(@1,@2,@3,@4,@5,@6,)@
		case TYPE_flt:
			@:aggrX3_count3_loop(@1,@2,@3,@4,@5,@6,)@
		case TYPE_dbl:
			@:aggrX3_count3_loop(@1,@2,@3,@4,@5,@6,)@
		default:
			if (b->tvarsized) {
				@:aggrX3_count3_loop(@1,@2,@3,@4,@5,@6,)@
			} else {
				@:aggrX3_count3_loop(@1,@2,@3,@4,@5,@6,)@
			}
		}
	}
	if (@1) {
		/* copy cnt array to final result */
		BATloop(bn, p, q) {
			oid h = (*(oid*) BUNh@4(bni,p)) - min;
			*(int*)BUNtloc(bni, p) = cnt[h];
		}
		GDKfree(cnt);
	}
@c
/*	aggrX3_count3_loop
	@7:	if (!atom_EQ(BUNt{loc,var}(b,p),bt_nil,btt))		b-tail nil check
		if (!simple_EQ(BUNtloc(b,p),bt_nil,{chr,bte,sht,int,flt,lng,dbl}))
*/
@= aggrX3_count3_loop
	ALGODEBUG THRprintf(GDKout, "#aggrX3_count3_loop(@1,@2,@3,@4,@5,@6,@7);\n");
	BATloop(b, p, q) {
		oid v = *(oid*) @5;

		w = offset + v;
		if (w >= base && w < end) {
			oid *h = (oid*) BUNtail(gi, w);

			@3(r, bni, (oid*)h);
			if (r != BUN_NONE) {
				@7 {
					int *dst = (int*) @6;
					(*dst)++;
				}
			}
		}
	}
	break;
@c
int
CMDaggrX3_count3(BAT **ret, BAT *b, BAT *g, BAT *e, bit *ignore_nils)
{
	BATiter bni, bi = bat_iterator(b), gi = bat_iterator(g);
	BAT *bn;
	int zero = 0, *cnt;
	BUN p, q, r;
	size_t range = 0;
	oid min = 0, max = 0;
	oid bhsb;
	size_t base, end, w;
	ssize_t offset;
	int btt;
	ptr bt_nil = ATOMnilptr(b->ttype);

	ALGODEBUG THRprintf(GDKout, "#CMDaggrX3_count3(b=%s,g=%s,e=%s);\n", 
		BATgetId(b),BATgetId(g),BATgetId(e));

/*	ERRORcheck((BATcount(b)!=BATcount(g)), "CMDaggrX3_count3: BATs b & g must be of equal size.\n");	*/
	ERRORcheck((g->htype == TYPE_void) && (g->hseqbase == oid_nil) && (BATcount(g) > 0), "CMDaggrX3_count3: head of BAT g must not be nil.\n");

	if ((g->hseqbase == oid_nil) || (!BAThdense(g)) || (!(BAThordered(b) & 1)) || (!g->hkey)) {
		return CMDaggrX3_count(ret, BATjoin(BATmirror(g), b, oid_nil), e, ignore_nils);
	}

	if (e->htype == TYPE_void && 
	    b->htype == TYPE_void && 
	    g->htype == TYPE_void && 
	    g->ttype == TYPE_void) {
		/* simply return counts with one */
		int one = 1;
		bn = BATconst(b, TYPE_int, &one);
		*ret = bn;
		return GDK_SUCCEED;
	}
 	bn = BATnew(e->htype, TYPE_int, BATcount(e));
	bni = bat_iterator(bn);
	if (bn == NULL)
		return GDK_FAIL;

	/* init: set all counts to zero and calculate min/max oid */
	@:init_result(int)@
	range = max - min + 1;

	/* scan b & g, and calculate counts */
	if (e->htype == TYPE_void) {
		/* void lookup */
		if (b->htype == TYPE_void) {
			@:aggrX3_count3(0,0,BUNfndVOID,var,&bhsb;bhsb++,BUNtloc(bni,r))@
		} else {
			@:aggrX3_count3(0,0,BUNfndVOID,var,BUNhloc(bi,p),BUNtloc(bni,r))@
		}
		/* e->htype == TYPE_oid */
	} else if (range > SMALL_AGGR_MAX) {
		/* hash lookup */
		if (b->htype == TYPE_void) {
			@:aggrX3_count3(0,1,HASHfnd_oid,loc,&bhsb;bhsb++,BUNtloc(bni,r))@
		} else {
			@:aggrX3_count3(0,1,HASHfnd_oid,loc,BUNhloc(bi,p),BUNtloc(bni,r))@
		}
	} else {
		/* array lookup */
		if (b->htype == TYPE_void) {
			@:aggrX3_count3(1,0,CHKrange,loc,&bhsb;bhsb++,&cnt[(*(oid*)h)-min])@
		} else {
			@:aggrX3_count3(1,0,CHKrange,loc,BUNhloc(bi,p),&cnt[(*(oid*)h)-min])@
		}
	}

	*ret = bn;
	return GDK_SUCCEED;
}

@}
@}
