@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2007 CWI.
@' All Rights Reserved.

@f tcpip
@a Peter Boncz
@v 1.2
@t TCP/IP Communication

@* Introduction
@T
With this module you can establish TCP/IP connections between Mservers,
and pass BATs {\em or any other MIL value} asynchronously between them.
Mode of operation:
\begin{itemize}
\item first you start, on at least one side of the network, the {\bf TCP/IP
listening thread} with the {\tt listen(port)} command.
\item you can then {\bf connect on the other side} using
{\tt open("<host>:<port") : int}. The returned integer number is the
{\em connection number}. Connections are bidirectional channels to pass values.
\item {\tt <conn-id>.export(<value>);} {\bf sends a value} to the other side.
It will be stored in the cache there.
\item {\tt import("<name>") : <value>} waits for a certain named value to
come in {\em from any open connection}. If the value is already cached, this
command returns immediately. If not, it {\bf blocks till the value arrives}.
\item the {\tt <conn-id>.mil(<mil-str>)} command {\bf evaluates a
MIL script} on the other end.
\item the {\tt <conn-id>.rpc(<fcn-str>, ..subst-param..) : value} command
{\bf evaluates a MIL command} on the other end. It takes care of
the correct transportation of the parameter values, and returns the
result value of the expression. The command is given as a string
containing a "cmd(...)", with "\%s" patterns where local parameters
are substituted.
\item the {\tt <conn-id>.close()} command {\bf closes the connection}.
\item the {\tt terminate(<port>)} command {\bf kills the listening thread}.
\item {\bf status monitoring}: the {\tt waits, conns} and {\tt cache}
commands all return a BAT, that contain (a copy of) the internal
connection administration tables.
\end{itemize}
If two Mservers simultaneously try to open a connection to each other,
only one will be created.

@* Module Definition
@m
.MODULE tcpip;

@- TCP/IP Server Management
@m
.COMMAND listen()  = TCPlisten_default;
"start a TCP/IP server with the default port number."
.COMMAND listen(int port) = TCPlisten;
"start a TCP/IP server"

.COMMAND TCPIP_listen()  = TCPlisten_default;
"start a TCP/IP server with the default port number."
.COMMAND TCPIP_listen(int port) = TCPlisten;
"start a TCP/IP server"

.COMMAND terminate() = TCPterminate_default;
"stop a TCP/IP server"
.COMMAND terminate(int port) = TCPterminate;
"stop a TCP/IP server"

@- Connection Management
@m
.COMMAND open(str host) : int = TCPopen;
"open a connection to another TCP/IP server."
.COMMAND close(int connect_id) = TCPclose;
"close a connection to another TCP/IP server."
.COMMAND close() = TCPcloseall;
"close all connections"
.COMMAND flush() = cache_clear;
"Empty the TCP/IP cache, and delete all items in it."

@- Communication
@m
.COMMAND export(int conn_id, any, str name) = TCPexport;
"export a value for transport on a named local TCP/IP server."
.COMMAND export(int conn_id, bat[any,any]) = TCPexport_default;
"export a value for transport on a named local TCP/IP server."

.COMMAND import(str name) : any = TCPimport_default;
"import a value from a TCP/IP server, removing it from the cache."
.COMMAND import(str name, bit remove) : any = TCPimport;
"import a value from a TCP/IP server, possibly removing it from the cache."

.COMMAND rpc(int conn_id, str fcn_call, ... any ...) : any = TCPrpc;
"remote MIL evaluation. Each argument that is represented by a %a is
 inserted with succeeding values from the parameter list of the rpc call.
 Returns the remote return value."

.COMMAND mil(int conn_id, str fcn_call, ... any ...) : void = TCParpc;
"remote MIL evaluation with parameter transport, similary to rpc.
 Does NOT return a result value."
.COMMAND mil(int conn_id, str name) : void = TCPmil;
"remote MIL string evaluation. String can be just any legal mil script
 (multiple statements allowed). Does NOT return a result value."

@- Information BATs
@m
.COMMAND conns() : BAT[int,str] = conn_bat;
"a BAT with all current connections."
.COMMAND waits() : BAT[int,int] = wait_bat;
"a BAT with all current waiting threads."
.COMMAND cache() : BAT[str,str] = cache_bat;
"a copy of the list of BATs cached via the network"

.PRELUDE = TCPprelude;
.EPILOGUE = TCPepilogue;

.END tcpip;

@mil
        PROC arpc(..any..) : any { return mil($(1..)); }  # jonas backward compatibility

@h
#ifndef _TCPIP_H_
#define _TCPIP_H_

#include "monet.h"
#include "tcpip.proto.h"

@{
@* Implementation
@c
#include "monetdb4_config.h"
#include <monet.h>
#ifdef HAVE_SYS_SOCKET_H
# include <sys/socket.h>
#endif
#ifdef NATIVE_WIN32
# include <winsock.h>
#endif
#include <sys/types.h>

#ifdef HAVE_NETDB_H
#include <netinet/in.h>
#endif
#include "tcpip.h"

#include <string.h>

@+ Auxiliary Functions
@- Socket Management
Some basic routines to open a remote socket, and to read
data from them.
@c
static SOCKET
socket_open(str host, int port, str fcn)
{
	struct sockaddr_in a;
	struct hostent *hp;
	struct sockaddr *addr = (struct sockaddr *) &a;
	SOCKET fd;
	socklen_t len = (socklen_t) sizeof(a);

	memset(&a, 0, sizeof(a));
	a.sin_family = AF_INET;
	a.sin_port = htons((unsigned short) (port & 0xFFFF));
	if (!(hp = gethostbyname(host))) {
		GDKsyserror("s(%s:d): lookup error.\n", fcn, host, port);
		return GDK_FAIL;
	}
	memcpy(&a.sin_addr, hp->h_addr, hp->h_length);
	if ((fd = socket(PF_INET, SOCK_STREAM, 0)) < 0) {
		GDKsyserror("%s(%s:%d): could not create socket.\n", fcn, host, port);
	} else if (connect(fd, addr, len)) {
		GDKsyserror("%s(%s:%d): could not connect with.\n", fcn, host, port);
	} else {
#ifdef SO_KEEPALIVE
		{
			int opt = 0;
			setsockopt(fd, SOL_SOCKET, SO_KEEPALIVE, (char *) &opt, sizeof(opt));
		}
#endif
#ifdef IPTOS_THROUGHPUT
		{
			int tos = IPTOS_THROUGHPUT;

			setsockopt(fd, IPPROTO_IP, IP_TOS, (void *) &tos, sizeof(tos));
		}
#endif
#ifdef TCP_NODELAY
		{
			int nodelay = 1;

			setsockopt(fd, IPPROTO_TCP, TCP_NODELAY, (void *) &nodelay, sizeof(nodelay));
		}
#endif
		return fd;
	}
	return 0;
}

static int
socket_close(SOCKET sock)
{
	int r = shutdown(sock, 2);
	closesocket(sock);
	return r;
}

static int
socket_read(SOCKET fd, int size, char *dst, char *msg)
{
	int n, m;

	/* some systems do not give you all at once */
	for (m = size; m > 0; m -= n, dst += n) {
		n = recv(fd, dst, m, 0);
		if (n < 0) {
			GDKsyserror("socket_read: ");
			break;
		} else if (n == 0)
			break;
	}
	if (m != 0) {
		GDKerror("socket_read: %s has illegal size %d.\n", msg, size - m);
		return FALSE;
	}
	return TRUE;
}

static int
socket_write(SOCKET fd, int len, char *src, char *msg)
{
	int ret = send(fd, src, len, 0);

	if (GDKdebug & 65536) {
		THRprintf(GDKerr, "send:%s:%d\n", src, len);
	}
	if (ret != len) {
		GDKsyserror("socket_write: %s(%d) returned %d.\n", msg, len, ret);
		return FALSE;
	}
	return TRUE;
}

static bit
socket_gets(SOCKET fd, char **buf, int *len)
{
	char *s = *buf, *end = *buf + *len;

	while (TRUE) {
		fd_set fds;
		struct timeval tv;
		int retval;

		FD_ZERO(&fds);
		FD_SET(fd, &fds);
		tv.tv_sec = 0;
		tv.tv_usec = 500;
		retval = select((int) fd + 1, &fds, NULL, NULL, &tv);
		if (retval == 0) {
			/* nothing interesting has happened */
			continue;
		}
		if (retval < 0) {
			if (MT_geterrno() != EINTR) {
				GDKsyserror("socket_get: select failed\n");
				return FALSE;
			}
			continue;
		}
		if (!FD_ISSET(fd, &fds))
			continue;
		if (s == end) {
			int oldlen = *len;

			*len *= 2;
			*buf = GDKrealloc(*buf, *len);
			s = *buf + oldlen;
			end = *buf + *len;
		}
		if (
#ifdef NATIVE_WIN32
			   recv(fd, s, 1, 0)
#else
			   read(fd, s, 1)
#endif
			   <= 0) {
			GDKsyserror("socket_gets: ");
			return FALSE;
		}
		if (*s == '\n')
			break;
		++s;
	}
	*s = 0;
	return TRUE;
}

@- MIL Types
The @%atom_type@ routine checks whether we know a certain
MIL atomic type, by its name. We accept only standard atoms,
and extension atoms installed by the database administrator
(no user atoms!). This is for simplicity; users can have many
different names..
@c
static int
atom_type(str s)
{
	int i = ATOMindex(s);

	if (i == TYPE_bat)
		return -TYPE_bat;
	if (i < 0) {
		char buf[PATHLENGTH], *p = s;

		strcpy(buf, "adm_");	/* assuming PATHLENGTH > 4... */
		strncpy(buf + 4, p, sizeof(buf) - 4);
		i = ATOMindex(buf);
	}
	return i;
}

@-
The reverse is @%atom_name()@: it provides the clean name
(without {\tt <user>_} prepended) of a type.
@c
static str
atom_name(int tpe)
{
	char *nme, *p;

	if (tpe == TYPE_ptr) {
		/* pointers are local, cannot send or receive them */
		tpe = ATOMstorage(TYPE_ptr);
	}
	nme = ATOMname(tpe);
	p = strchr(nme, '_');
	if (p != NULL)
		return p + 1;
	return nme;
}

@* Data Structures
@h
#define TCPPORT		49153
#define MAX_CONN	256

#define SOCKPTR struct sockaddr *
#if HAVE_SOCKLEN_T
#define SOCKLEN socklen_t
#else
#define SOCKLEN int
#endif

#endif /*_TCPIP_H_*/

@- TCPlock
We have a global lock for protecting the cache and connection data structures.
@c
MT_Lock TCPlock;


@+ BAT Cache
In asynchronous TCP/IP, receiver threads (see @%conn_waiter@) wait on
the connections, and receive data. This data is cached locally till it
is needed. The cache maintains a list of cached data items and their names.

@- BAT cache_idx
The @%cache_idx@ BAT[str,ptr] is non-volatile and contains a list of names, and
pointers to @%cache_t@ records.
@c
BAT *cache_idx = 0;

@- Cache Items
We cache a list of BATs or other values in non-volatile storage.
@c
union cache_t_val {
	ptr pval;
	bat bval;
};
typedef struct {
	str name;		/* name of the cached item */
	int conn;		/* conn nr from which it was retrieved, -1 if not */
	int locked;		/* #locked processes trying to import this item */
	int tpe;		/* MIL value type */
	union cache_t_val val;	/* NULL or the cached BAT */
	MT_Sema barrier;	/* barrier to make imports wait on the BAT */
	str errbuf;		/* error message if any */
} cache_t;

@- new cache item
Create a new empty cache item. Since it does not yet contain a value,
we lock it, so a subsequent lock (caused by @%TCPimport@) will block.
The lock will be unset when the value arrives.
@c
static cache_t *
cache_new(str name)
{
	BUN q = BUNlast(cache_idx);
	cache_t *c = (cache_t *) GDKmalloc(sizeof(cache_t));

	BUNins(cache_idx, name, &c, FALSE);
	c->name = (str) BUNhvar(cache_idx, q);
	c->locked = 0;
	c->val.pval = NULL;
	c->tpe = TYPE_void;
	c->conn = -1;
	c->errbuf = NULL;
	MT_init_sema(c->barrier,0);
	return c;
}

@- destroy a cache record
This means returning the lock, freeing the storage, and removing the
cache record from the @%cache_idx@ BAT.
@c
static int
cache_free(cache_t *c)
{
	MT_destroy_sema(c->barrier);
	GDKfree(c);
	return 0;
}

@- purge a cache item
Care must be taken here. You might want to destroy the reference,
but some @%TCPimports@ may be blocked on it. In this case, we defer
real deallocation; as this will be done by the last unblocked routine.
@c
static int
cache_del(cache_t *c)
{
	if (c->tpe == TYPE_bat) {
		if (c->val.bval)
			BBPdecref(c->val.bval, TRUE);
	} else if (c->val.pval) {
		GDKfree(c->val.pval);
	}
	c->val.pval = NULL;
	c->tpe = TYPE_void;
	c->conn = -1;
	if (!c->locked) {
		BUNdelHead(BATmirror(cache_idx), &c, FALSE);
		cache_free(c);
	}
	return 0;
}

@- a value arrives..
and it can be placed in its cache record. We can unlock the lock.
A blocked @%TCPimport@ (if any) can now proceed.
@c
static int
cache_fill(cache_t *c, int tpe, union cache_t_val val, int i)
{
	MT_set_lock(TCPlock, "cache_fill");
	if (c->tpe == TYPE_bat ? c->val.bval != 0 : c->val.pval != 0) {
		GDKwarning("cache_fill: replacing the value for %s.\n", c->name);
		if (c->tpe == TYPE_bat) {
			BBPdecref(c->val.bval, TRUE);
		} else {
			GDKfree(c->val.pval);
		}
	}
	c->conn = i;
	c->tpe = tpe;
	c->val = val;
	if (tpe == TYPE_bat) {
		BBPincref(c->val.bval, TRUE);
	}
	if (c->locked) {
		MT_up_sema(c->barrier, "cache_fill");
	}
	MT_unset_lock(TCPlock, "cache_fill");
	return 0;
}

@- look for a named value in the cache
@c
static cache_t *
cache_find(str name)
{
	BUN q = BUNfnd(cache_idx, name);

	if (q)
		return *(cache_t **) BUNtloc(cache_idx, q);
	return cache_new(name);
}

@- purge all items from the cache
@c
int
cache_clear(void)
{
	BUN p, q;
	int xx;

	BATloopFast(cache_idx, p, q, xx) {
		cache_del(*(cache_t **) BUNtloc(cache_idx, p));
	}
	return 1;
}

@- cache listing
@c
int
cache_bat(BAT **retval)
{
	BAT *b = BATnew(TYPE_str, TYPE_str, BATcount(cache_idx));
	BUN p, q;

	if (b == NULL)
		return GDK_FAIL;
	strcpy(b->hident, "id");
	strcpy(b->tident, "cached value");
	BATloop(cache_idx, p, q) {
		cache_t *c = *(cache_t **) BUNtloc(cache_idx, p);
		char *val = 0, *buf, *atm = atom_name(c->tpe);

		if (c->tpe == TYPE_bat) {
			bat bval = c->val.bval;

			ATOMformat(c->tpe, &bval, &val);
		} else {
			ATOMformat(c->tpe, c->val.pval, &val);
		}
		buf = (str) GDKmalloc(strlen(atm) + 5 + strlen(val));
		sprintf(buf, "%s(\"%s\")", atm, val);
		BUNins(b, BUNhvar(cache_idx, p), buf, FALSE);
		GDKfree(buf);
		GDKfree(val);
	}
	*retval = b;
	return GDK_SUCCEED;
}

@- cache error handling
@c
static int
cache_error(cache_t *c)
{
	str p, q, r = c->errbuf;

	do {
		p = strchr(r, '\n');
		q = p ? p : r + strlen(r);
		p = strstr(q, GDKWARNING);
		if (p != NULL) {
			if ((q = strstr(q, GDKERROR)) && q < p)
				p = q;
		} else {
			p = strstr(q, GDKERROR);
		}
		if (p)
			p[-1] = 0;

		if (strncmp(r, GDKWARNING, strlen(GDKWARNING)) == 0) {
			GDKwarning(r + strlen(GDKWARNING));
		} else if (strncmp(r, GDKERROR, strlen(GDKERROR)) == 0) {
			GDKerror(r + strlen(GDKERROR));
		}
	} while ((r = p) != NULL);
	GDKfree(c->errbuf);
	c->errbuf = 0;
	return 0;
}


@+ Connections
The connection table shows all currently open TCP/IP connections.
Connections are always either initiated at the one end, or the other,
with a @%TCPopen@ call. On the answering end, there the listener.
Afterwards the connection is bidirectional.  This asymmetry on how
a connection was created, shows up in the connection administration table.
@c
typedef struct {
	int me;			/* port number of the local listening thread
				 * to which was connected by the remote party;
				 * -1 if the connection was initiated locally */
	int valid;		/* is the connection still valid */
	char hostname[128];	/* remote hostname */
	int port;		/* remote listening thread port; -1 if none */
	SOCKET sock;		/* socket number */
	Thread waiter;		/* process id of waiter thread on this
				 * connection */
} conn_t;

conn_t connections[MAX_CONN] = { {0, 0, "", 0, 0, (Thread) 0}, };

@- look for a certain connection
@c
#if 0				/* not used */
static int
conn_findByThread(MT_Id pid)
{
	int i;

	MT_set_lock(TCPlock, "TCPopen");
	for (i = 0; i < MAX_CONN; i++)
		if (connections[i].waiter && connections[i].waiter->pid == pid)
			break;
	MT_unset_lock(TCPlock, "TCPopen");

	return i == MAX_CONN ? -1 : i;
}
#endif

static int
conn_find(str host, int port)
{
	int i;

	for (i = 0; i < MAX_CONN; i++)
		if (connections[i].me && connections[i].port == port && strcmp(connections[i].hostname, host) == 0)
			break;
	return i;
}

@- delete a connection
also involves killing the associated waiter.
@c
static int
conn_delete(int i)
{
	if (GDKdebug & 65536) {
		THRprintf(GDKerr, "Delete connection record %d (%d %d)\n", i, connections[i].port, connections[i].me);
	}
	if (connections[i].me) {
		connections[i].me = 0;
		connections[i].valid = 0;
		connections[i].port = 0;
		socket_close(connections[i].sock);
		return 1;
	}
	return 0;
}
static int
conn_kill(int i)
{
	if (connections[i].me) {
		if (connections[i].waiter) {
			MT_Id pid = connections[i].waiter->pid;

			THRdel(connections[i].waiter);
			MT_kill_thread(pid);
			MT_sleep_ms(1000);
		}
		return conn_delete(i);
	}
	return 0;
}

#if 0				/* not used */
static int
conn_invalidate(int i)
{
	if (GDKdebug & 65536) {
		THRprintf(GDKerr, "Invalidate connection record %d (%d %d)\n", i, connections[i].port, connections[i].me);
	}
	if (connections[i].me) {
		connections[i].valid = 0;
		return 1;
	}
	return 0;
}

static int
conn_write(int conn_id, int len, char *src, char *msg)
{
	if (!connections[conn_id].valid)
		return FALSE;

	if (socket_write(connections[conn_id].sock, len, src, msg))
		return TRUE;
	MT_set_lock(TCPlock, "TCPopen");
	conn_invalidate(conn_id);
	MT_unset_lock(TCPlock, "TCPopen");
	return FALSE;
}
#endif

@- close all connections
@c
static int
conn_closeall(void)
{
	BUN p, q;
	int i;

	for (i = 0; i < MAX_CONN; i++) {
		conn_kill(i);
	}
	BATloopFast(cache_idx, p, q, i) {
		cache_free(*(cache_t **) BUNtloc(cache_idx, p));
	}
	return 1;
}

#define NM_LEN 80
#define MAX_LINE 64
static int
TCPraise(SOCKET fd, str name)
{
	char *errbuf = GDKerrbuf;

	if (errbuf && *errbuf && *errbuf != *str_nil) {
		int errlen = (int) strlen(errbuf);
		int msglen;
		char *msg = (char *) alloca(errlen + NM_LEN + 32);

		sprintf(msg, "err:%s:%d\n", name, errlen + 1);
		msglen = (int) strlen(msg);
		memcpy(msg + msglen, errbuf, errlen + 1);
		*errbuf = '\0';
		if (GDKdebug & 65536) {
			THRprintf(GDKerr, "send err:%s\n", msg);
		}
		socket_write(fd, msglen + errlen + 1, msg, "error msg");
	}
	return GDK_SUCCEED;
}


@- the connection waiter
@T
is a thread created individually for each opened TCP/IP connection.
It waits for requests that can be one of three different things:
\begin{itemize}
\item a request to {\em cache a BAT}. This means reading the
meta-data, and then the heaps from the stream, assembling
a volatile BAT from it, and placing it in the local cache.
\item a request to {\em cache some other value}. Assemble
the value; this is simpler than for BATs, of course.
\item a request to {\em execute a MIL statement}. The result
value of the MIL expression is to be sent back, using some
system-generated cache name. Depending on the evaluation identifier,
a possible result is sent back, or not. The result will be sent with
the standard @%TCPexport@ mechanism.
The evaluation identifier is also used for generating error messages.
\end{itemize}
@c
#define M_TCPIP_ALIGN(n,b) ((b)?(b)*(1+(((n)-1)/(b))):n)

static void
conn_waiter(void *vi)
{
	int i = *(int *) vi;
	Thread thr = THRnew(MT_getpid(), "conn_waiter");

	free(vi);		/* see comment in conn_insert */
	if (thr) {
		SOCKET fd = connections[i].sock;
		Client monetClient = forkClient(0, 1);

		connections[i].waiter = thr;

		if (monetClient) {
			int lineLength = MAX_LINE;
			char *line = GDKmalloc(lineLength), nm[NM_LEN];
			char errbuf[GDKMAXERRLEN], *errbuf_bak = GDKerrbuf;

			GDKsetbuf(errbuf);
			monetClient->login = time(0);

			while (connections[i].valid && socket_gets(fd, &line, &lineLength)) {
				char *p, *r, *q, *tp = line;
				int tpe = TYPE_bat;
				cache_t *c;
				union cache_t_val dst;

@- Command Evaluation
In this case, we execute the MIL script. If errors occur, be send
back the error messages. If a result is wanted, we export this using
the standard mechanism.
@c
				p = strchr(line, '\n');
				if (p != NULL)
					*p = 0;
				if ((q = strchr(tp, ':')) == NULL || (p = strchr(q + 1, ':')) == NULL)
					continue;

				*q++ = 0;
				*p++ = 0;
				strncpy(nm, q, NM_LEN);
				nm[NM_LEN - 1] = 0;
				if (GDKdebug & 65536) {
					THRprintf(GDKerr, "%s:%s:%s\n", tp, nm, p);
				}
				if (strcmp(tp, "mil") == 0) {
					int asynchronous = (strncmp(nm, "arpc", 4) == 0);
					int expect_return = (strncmp(nm, "rpc", 3) == 0);
					ValRecord res;
					ptr val = &res.val.ival;

					res.vtype = TYPE_void;
					*errbuf = '\0';

					if (asynchronous) {
						int plen = (int) strlen(p);
						char *tmp = (char *) alloca(plen + 256);

						p[plen - 1] = '\0';	/* remove trailing ';' */
						sprintf(tmp, "export(%d,%s,\"%s\").enqueue.wakeup;", i, p, nm);
						interpret_str(monetClient->stk, tmp, &res);
					} else {
#define RETURN_PREFIX "return "
						if (expect_return) {
							p -= strlen(RETURN_PREFIX);
							strncpy(p, RETURN_PREFIX, strlen(RETURN_PREFIX));
						}
						*errbuf = '\0';
						interpret_str(0, p, &res);	/* 0=>fork off the ADM cntxt */
					}
@-
'GDKerror' messages have been stored in 'errbuf' (if any)
@c
#ifndef DDIPATCH
					if (*errbuf) {
						char msg[16384];
						size_t len;

						snprintf(msg, 16384, "err:%s:" SZFMT "\n", nm, strlen(errbuf) + 1);
						len = strlen(msg);
						memcpy(msg + len, errbuf, strlen(errbuf) + 1);
						socket_write(fd, (int) (len + strlen(errbuf) + 1), msg, "error msg");
					}
#endif

					if (res.vtype == TYPE_bat) {
						/* TCPexport needs the BAT in memory */
						val = (ptr) BATdescriptor(res.val.bval);
					} else if (ATOMextern(res.vtype)) {
						val = res.val.pval;
					} else if (res.vtype == TYPE_void) {
						res.vtype = TYPE_int;
					}
@-
Rpc request get a value back; mil requests not.
@c
					if (expect_return) {
						TCPexport(&i, val, res.vtype, nm);
					} else {
						TCPraise(fd, nm);
					}
@-
All said and done, now we clean up any returned values.
@c
					if (res.vtype == TYPE_bat)
						BBPunfix(res.val.bval);
					VALclear(&res);
					continue;
				}

@- Receiving Values
Insert an empty value into the cache.
@c
				MT_set_lock(TCPlock, "conn_waiter");
				c = cache_find(nm);
				if (c->tpe == TYPE_bat ? c->val.bval != 0 : c->val.pval != 0)
					c = cache_new(nm);
				MT_unset_lock(TCPlock, "conn_waiter");

@- err:<name>:<len>
Name is the id of a 'mil' request.
The error message is stored in the 'errbuf' field of the cache item.
@c
				if (strcmp(tp, "err") == 0) {
					int len = atoi(p);

					c->errbuf = (char *) GDKmalloc(len);
					socket_read(fd, len, c->errbuf, "errmsg");
					if (strncmp(nm, "mil", 3) == 0) {
						GDKsetbuf(errbuf_bak);
						cache_error(c);
						GDKsetbuf(errbuf);
						cache_del(c);
					}
					continue;
				}

@- bat:<name>:<cnt>*<width>:<htype>\@<off>[+][k]:<ttype>\@<off>[+][k]:
	<hheap>:<theap>:<halign>:<talign>:<oidbase>
First stop to examine its type, and heap sizes.
@c
				if (strcmp(tp, "bat") == 0) {
					int hsize = 0, tsize = 0, htpe = -1, ttpe = -1, hoff = 0, toff = 0;
					int size = -1, width = 0, hordered = 0, tordered = 0, h_key = 0, t_key = 0;
					char *ht, *tt = NULL, *hs, *ts = NULL;
					oid batSeqbase;
					BAT *b;

					if ((ht = strchr(p, ':')) && (tt = strchr(ht + 1, ':')) && (hs = strchr(tt + 1, ':')) && (ts = strchr(hs + 1, ':'))) {
						char *hmod = tt - 1;
						char *tmod = hs - 1;

						if (*hmod == 'k') {
							h_key = 1;
							hmod--;
						}
						if (*tmod == 'k') {
							t_key = 1;
							tmod--;
						}
						hordered = (*hmod == '+');
						tordered = (*tmod == '+');
						*ht++ = 0;
						*tt++ = 0;
						*hs++ = 0;
						*ts++ = 0;
						r = strchr(ht, '\@');
						if (r != NULL)
							*r++ = 0;
						htpe = atom_type(ht);
						if (r != NULL)
							hoff = atoi(r);
						r = strchr(tt, '\@');
						if (r != NULL)
							*r++ = 0;
						ttpe = atom_type(tt);
						toff = r ? atoi(r) : M_TCPIP_ALIGN(ATOMsize(htpe), ATOMalign(ttpe));
						r = strchr(p, '*');
						if (r != NULL)
							*r++ = 0;
						size = atoi(p);
						if (r == NULL) {
							width = (toff > hoff) ? toff + ATOMsize(ttpe) : hoff + ATOMsize(htpe);
							width = M_TCPIP_ALIGN(width, ATOMalign(htpe));
							width = M_TCPIP_ALIGN(width, ATOMalign(ttpe));
						} else {
							width = atoi(r);
						}
						hsize = atoi(hs);
						tsize = atoi(ts);
					}
					if (size < 0 || htpe < 0 || ttpe < 0) {
					      fail:GDKerror("conn_waiter: illegal %s[%s,%s].\n", tp, ht, tt);
						cache_del(c);
						continue;
					}
					b = BATcreatedesc(htpe, ttpe, TRUE);
					b->dims.headvarsized = BATatoms[htpe].varsized;
					b->dims.tailvarsized = BATatoms[ttpe].varsized;
					b->dims.headkey = h_key;
					b->dims.tailkey = t_key;
					b->dims.headtype = htpe;
					b->dims.headloc = hoff;
					b->dims.tailtype = ttpe;
					b->dims.tailloc = toff;
					b->dims.bunwidth = width;
					if (HEAPalloc(b->batBuns, size + 3, b->dims.bunwidth) < 0) {
						BBPclear(b->batCacheid);
						goto fail;
					}
					if (hsize && HEAPalloc(b->hheap, hsize, 1) < 0) {
						HEAPfree(b->batBuns);
						BBPclear(b->batCacheid);
						goto fail;
					}
					if (tsize && HEAPalloc(b->theap, tsize, 1) < 0) {;
						HEAPfree(b->batBuns);
						HEAPfree(b->hheap);
						BBPclear(b->batCacheid);
						goto fail;
					}
@= getoid
                if (ts && (ts = strchr(ts,':'))) {
                        int _len = sizeof(oid);
                        oid *_dst = &(@1);

                        OIDfromStr(++ts, &_len, &_dst);
                }
@c
					@:getoid(b->halign)@
					@:getoid(b->talign)@
					@:getoid(batSeqbase)@
					b->hsorted = hordered;
					b->tsorted = tordered;
					DELTAinit(b);
					BBPcacheit(b);
					dst.bval = b->batCacheid;
@-
Read the data for its heaps. A BAT at least consists of a BUN heap.
For variable sized atoms, there may be a head and/or tail heap.
@c
					if ((!socket_read(fd, size * BUNsize(b), BUNfirst(b), "BUN heap")) || (b->hheap && !socket_read(fd, hsize, b->hheap->base, "head heap")) || (b->theap && !socket_read(fd, tsize, b->theap->base, "tail heap"))) {
						BBPreclaim(b);
						goto fail;
					}
					b->batBuns->free = size * BUNsize(b);
					BATsetcount(b, size);
					if (hsize) {
						b->hheap->free = hsize;
						HEAP_init(b->hheap, b->htype);
					}
					if (tsize) {
						b->theap->free = tsize;
						HEAP_init(b->theap, b->ttype);
					}

					if (b->htype == TYPE_void) {
						BATseqbase(b, batSeqbase);
					} else if (b->htype == TYPE_void) {
						BATseqbase(b, batSeqbase);
					}
#ifndef WORDS_BIGENDIAN
					BATconvert(b, CONV_NTOH);
#endif
					BATpropcheck(b, BATPROPS_ALL);
					BATpropcheck(BATmirror(b), BATPROPS_ALL);

@- Atomic Value Receive
@c
				} else if ((tpe = atom_type(tp)) > 0) {
					int len = atoi(p);

					dst.pval = GDKmalloc(len);
					socket_read(fd, len, dst.pval, atom_name(tpe));
#ifndef WORDS_BIGENDIAN
					ATOMconvert(tpe, dst.pval, CONV_NTOH);
#endif
				}
@-
Mark the value as totally ready in the cache.
@c
				cache_fill(c, tpe, dst, i);
			}
			GDKsetbuf(errbuf_bak);
			GDKfree(line);
			closeClient(monetClient, 1);
		}
		THRdel(thr);
	}
	MT_set_lock(TCPlock, "conn_waiter");
	conn_delete(i);
	MT_unset_lock(TCPlock, "conn_waiter");
	MT_exit_thread(0);
}

@- insert a new connection
also involves forking a waiter thread
@c
static char TCPhostname[128] = { 0 };
static char *
hostname(void)
{
	if (!*TCPhostname)
		gethostname(TCPhostname, 128);
	return TCPhostname;
}

#define MAX_LISTENERS 256
static int listeners = 0, ports[MAX_LISTENERS] = { 0 };

static int
conn_insert(str host, int port, int me, SOCKET sock)
{
	int i = 0;

	for (i = 0; connections[i].me; i++)
		;
	if (i == MAX_CONN) {
		GDKerror("conn_insert: too many connections\n");
		i = -1;
	} else {
		MT_Id t = 0;

		if (GDKdebug & 65536) {
			THRprintf(GDKerr, "Allocate connection record %d (%d, %d)\n", i, port, me);
		}
		connections[i].me = me;
		connections[i].valid = 1;
		connections[i].port = port;
		connections[i].sock = sock;
		connections[i].waiter = (Thread) 0;
		strncpy(connections[i].hostname, host, sizeof(connections[i].hostname));
		connections[i].hostname[sizeof(connections[i].hostname) - 1] = 0;
		if (me) {
			/* We want to pass the value of i to conn_waiter.
			   This has to be done using a pointer to i,
			   except that i is a local variable which may not
			   exist anymore by the time conn_waiter starts in
			   the new thread.  Therefore we allocate a buffer
			   in which we put the value, and then conn_waiter
			   can deallocate the buffer after it has read the
			   value.
			 */
			int *p = malloc(sizeof(int));

			*p = i;
			if (MT_create_thread(&t, conn_waiter, (void *) p) != 0) {
				/* failed to start thread */
				free(p);
				connections[i].me = 0;
				connections[i].valid = 0;
				i = -1;
			}
		}
	}
	return i;
}

@- a list of all connections
@c
int
conn_bat(BAT **retval)
{
	BAT *b = BATnew(TYPE_int, TYPE_str, 10);
	int i;

	if (b == NULL)
		return GDK_FAIL;
	strcpy(b->hident, "conn");
	strcpy(b->tident, "remote");
	for (i = 0; i < MAX_CONN; i++)
		if (connections[i].me) {
			char buf[1024];

			sprintf(buf, "%s:%d", connections[i].hostname, connections[i].port);
			BUNins(b, &i, buf, FALSE);
		}
	*retval = b;
	return GDK_SUCCEED;
}

@- a list of all waiters
@c
int
wait_bat(BAT **retval)
{
	BAT *b = BATnew(TYPE_int, TYPE_int, 10);
	int i;

	if (b == NULL)
		return GDK_FAIL;
	strcpy(b->hident, "conn");
	strcpy(b->tident, "pid");
	for (i = 0; i < MAX_CONN; i++)
		if (connections[i].me) {
			BUNins(b, &i, &connections[i].waiter->pid, FALSE);
		}
	*retval = b;
	return GDK_SUCCEED;
}


@* Module Start and End
@+ prelude
Init the global structures.
@c
bat *
TCPprelude(void)
{
	MT_init_lock(TCPlock);
	cache_idx = BATnew(TYPE_str, TYPE_ptr, 1000);
	if (cache_idx == NULL)
		return NULL;
	BBPrename(cache_idx->batCacheid, "tcpip_idx");

	/* fork extra asynchronous interpreter, so there are always
	   two threads to handle to asynchronous requests */
	monetFork();
	return NULL;
}

@+ prelude
Cleanup the global structures.
@c
void
TCPepilogue(void)
{
	int i = 0, j = listeners;

@-
kill all listening threads.
@c
	MT_set_lock(TCPlock, "TCPepilogue");
	while (j > 0) {
		if (ports[i]) {
			TCPterminate(ports + i);
			j--;
		}
		i++;
	}
@-
now wait till they are all dead
@c
	do {
		MT_unset_lock(TCPlock, "TCPepilogue");
		GDKwarning("TCPepilogue: terminate %d listeners\n", listeners);
		MT_sleep_ms(1000);
		MT_set_lock(TCPlock, "TCPepilogue");
	} while (listeners > 0);
@-
close all connections, and destroy our global structures.
@c
	conn_closeall();
	BBPreclaim(cache_idx);
	MT_unset_lock(TCPlock, "TCPepilogue");
	MT_destroy_lock(TCPlock);

	/* kill the extra asynchronous interpreter thread */
	putkillRequest();
}

@* Listener Implementation
@+ start(int)
Start a TCP/IP server
@c
int
TCPlisten(int *port)
{
	struct sockaddr_in server, client;
	SOCKET msgsock = -1;
	SOCKET sock = socket(AF_INET, SOCK_STREAM, 0);
	int port_no = 0, i, on = 1;
	SOCKLEN server_len = (SOCKLEN) sizeof(server);
	SOCKLEN client_len = (SOCKLEN) sizeof(client);
	int lineLength = MAX_LINE;
	char *p, *line = GDKmalloc(lineLength);

@-
Register ourselves
@c
	MT_set_lock(TCPlock, "TCPlisten");
	while (port_no < MAX_LISTENERS && ports[port_no])
		port_no++;
	if (port_no == MAX_LISTENERS) {
		GDKsyserror("TCPlisten: too many listners\n");
		return GDK_FAIL;
	}
	ports[port_no] = *port;
	listeners++;
	MT_unset_lock(TCPlock, "TCPlisten");
@-
create the socket
@c
	if (sock < 0) {
		GDKsyserror("TCPserve: creation of stream socket failed\n");
		return GDK_FAIL;
	}
	server.sin_family = AF_INET;
	server.sin_addr.s_addr = INADDR_ANY;
	server.sin_port = htons((unsigned short) (*port & 0xFFFF));
	for (i = 0; i < 8; i++)
		server.sin_zero[i] = 0;
	setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, (char *) &on, sizeof on);
	if (bind(sock, (SOCKPTR) & server, server_len) < 0) {
		GDKsyserror("TCPlisten(%d): binding to socket failed.\n", *port);
	} else if (getsockname(sock, (SOCKPTR) & server, &server_len) < 0) {
		GDKsyserror("TCPlisten(%d): getting socket name.\n", *port);
	} else if (listen(sock, 5) < 0) {
		GDKsyserror("TCPlisten(%d): getting socket name\n", *port);
	} else
		while ((msgsock = accept(sock, (SOCKPTR) & client, &client_len)) > 0) {
@-
the listener heard something...
@c
#ifdef SO_KEEPALIVE
			{
				int opt = 0;
				setsockopt(msgsock, SOL_SOCKET, SO_KEEPALIVE, (char *) &opt, sizeof(opt));
			}
#endif
#ifdef IPTOS_THROUGHPUT
			{
				int tos = IPTOS_THROUGHPUT;

				setsockopt(msgsock, IPPROTO_IP, IP_TOS, (void *) &tos, sizeof(tos));
			}
#endif
#ifdef TCP_NODELAY
			{
				int nodelay = 1;

				setsockopt(msgsock, IPPROTO_TCP, TCP_NODELAY, (void *) &nodelay, sizeof(nodelay));
			}
#endif
			if (socket_gets(msgsock, &line, &lineLength) == 0) {
				closesocket(msgsock);
				continue;
			} else if (strncmp(line, "stop", 4) == 0) {
@-
This is the special command to shut down the listener.
@c
				closesocket(msgsock);
				break;
			} else if ((p = strchr(line, '\n')) != NULL) {
				*p = 0;
			}
@-
a new connection is born
@c
			MT_set_lock(TCPlock, "TCPlisten");
			conn_insert(line, client.sin_port, *port, msgsock);
			MT_unset_lock(TCPlock, "TCPlisten");
		}
	MT_set_lock(TCPlock, "TCPlisten");
	ports[port_no] = 0;
	listeners--;
	MT_unset_lock(TCPlock, "TCPlisten");
	socket_close(sock);
	GDKfree(line);
	return GDK_SUCCEED;
}

int
TCPlisten_default(void)
{
	int port = TCPPORT;

	return TCPlisten(&port);
}


@+ terminate(int)
Stop a TCP/IP server
@c
int
TCPterminate(int *port)
{
	SOCKET fd = socket_open(hostname(), *port, "TCPterminate");

	if (fd) {
		socket_write(fd, 5, "stop\n", "TCPterminate");
		return GDK_SUCCEED;
	}
	socket_close(fd);
	return GDK_FAIL;
}

int
TCPterminate_default(void)
{
	int port = TCPPORT;

	return TCPterminate(&port);
}

@* Connection Management
@+ open(str) : int
Open a connection to another TCP/IP server.
@c
int
TCPopen(int *retval, str address)
{
	SOCKET fd;
	int i, port = TCPPORT;
	char *p, host[128];

	if ((p = strchr(address, ':')) != NULL) {
		if (p - address >= (int) sizeof(host)) {
			/* address does not fit in host */
			return GDK_FAIL;
		}
		strncpy(host, address, p - address);
		host[p - address] = 0;
		port = atoi(p + 1);
	} else if (strlen(address) >= sizeof(host)) {
		/* address does not fit in host */
		return GDK_FAIL;
	} else {
		/* we know it'll fit */
		strcpy(host, address);
	}

	if (strcmp(host,"localhost") == 0 || strcmp(host,hostname()) == 0) {
		for (i = 0; i < MAX_LISTENERS; i++) {
			if (ports[i] == port) {
				GDKerror("There is no support for loopback communication\n");
				return GDK_FAIL;
			}
		}
	}

	MT_set_lock(TCPlock, "TCPopen");
	i = conn_find(host, port);
	MT_unset_lock(TCPlock, "TCPopen");
@-
If this exact connection already exists, just use it.
@c
	if (i < MAX_CONN) {
		*retval = i;
		return GDK_SUCCEED;
	}
	MT_set_lock(TCPlock, "TCPopen");
	i = conn_find(host, -1);
	MT_unset_lock(TCPlock, "TCPopen");
@-
If the connection exists the other way round, don't try to create it
@c
	if (i < MAX_CONN) {
		*retval = i;
		return GDK_SUCCEED;
	}
@-
Wait.. try to make the connection.
@c
	fd = socket_open(host, port, "TCPopen");
	MT_set_lock(TCPlock, "TCPopen");
@-
In the meantime, the other way round might have gotten through.  If so, use it.
@c
	i = conn_find(host, -1);
	if (i < MAX_CONN) {
		if (fd)
			socket_close(fd);
		*retval = i;
	} else if (fd == 0) {
		MT_unset_lock(TCPlock, "TCPopen");
		return GDK_FAIL;
	} else {
		char buf[64];

@-
We really initiated a new connection
@c
		*retval = conn_insert(host, port, -1, fd);
		sprintf(buf, "%s\n", hostname());
		if (send(fd, buf, (int) strlen(buf), 0) != (int) strlen(buf)) {
			GDKsyserror("conn_insert: could not communicate.\n");
			conn_delete(*retval);
			MT_unset_lock(TCPlock, "TCPopen");
			return GDK_FAIL;
		}
	}
	MT_unset_lock(TCPlock, "TCPopen");
	return GDK_SUCCEED;
}

@+ close(int)
Close a connection to another TCP/IP server.
@c
int
TCPclose(int *connect_id	/* pointer to integer. */
    )
{
	int ret;

	MT_set_lock(TCPlock, "TCPclose");
	ret = conn_kill(*connect_id);
	MT_unset_lock(TCPlock, "TCPclose");
	return ret;
}

int
TCPcloseall(void)
{
	MT_set_lock(TCPlock, "TCPcloseall");
	conn_closeall();
	MT_unset_lock(TCPlock, "TCPcloseall");
	return GDK_SUCCEED;
}

@* Communication Implementation
@+ export(int, any, str)
Export a value for transport on a named local TCP/IP server.
@c
#define BIG_MESSAGE 50000
int
TCPexport(int *conn_id,		/* pointer to integer. */
	  ptr val, int tpe, str name	/* string: pointer to char. */
    )
{
	char buf[BIG_MESSAGE], *p;
	int hdrlen, len = BIG_MESSAGE;
	SOCKET fd;
	size_t batlen;
	int ret = GDK_SUCCEED;

	if (*conn_id < 0 || *conn_id >= MAX_CONN || !connections[*conn_id].me) {
		GDKerror("TCPexport: invalid connection.\n");
		return GDK_FAIL;
	}
	fd = connections[*conn_id].sock;

	TCPraise(fd, name);

	if (tpe == TYPE_bat) {
@- bat:<name>:<cnt>*<width>:<htype>\@<off>[+][k]:<ttype>\@<off>[+][k]:
	<hheap>:<theap>:<halign>:<talign>:<oidbase>
@c
		BAT *b = (BAT *) val;

#ifndef WORDS_BIGENDIAN
		BATconvert(b, CONV_HTON);
#endif
		sprintf(buf, "bat:%s:" SZFMT "*%d:%s\@%d%s%s:%s\@%d%s%s:" SZFMT ":" SZFMT ":", name, BATcount(b), BUNsize(b), atom_name(b->htype), b->hloc, b->hsorted ? "+" : "", b->hkey ? "k" : "", atom_name(b->ttype), b->tloc, b->tsorted ? "+" : "",
			b->tkey ? "k" : "", b->hheap ? b->hheap->free : 0, b->theap ? b->theap->free : 0);

		p = buf + strlen(buf);
		p += OIDtoStr(&p, &len, &b->halign);
		*p++ = ':';
		p += OIDtoStr(&p, &len, &b->talign);
		*p++ = ':';
		if (b->ttype == TYPE_void) {
			p += OIDtoStr(&p, &len, &b->tseqbase);
		} else {
			p += OIDtoStr(&p, &len, &b->hseqbase);
		}

		*p++ = '\n';
		*p++ = 0;

		hdrlen = (int) strlen(buf);
		batlen = BUNlast(b) - BUNfirst(b);
@-
Small BATs are written in one go, large ones in parts.
@c
		if ((hdrlen + batlen + (b->hheap ? b->hheap->free : 0) + (b->theap ? b->theap->free : 0)) < BIG_MESSAGE) {
			int totlen = (int) (hdrlen + batlen);	/* < BIG_MESSAGE */

			memcpy(buf + hdrlen, BUNfirst(b), batlen);
			if (b->hheap) {
				memcpy(buf + totlen, b->hheap->base, b->hheap->free);
				totlen += (int) b->hheap->free;	/* < BIG_MESSAGE */
			}
			if (b->theap) {
				memcpy(buf + totlen, b->theap->base, b->theap->free);
				totlen += (int) b->theap->free;	/* < BIG_MESSAGE */
			}
			if (socket_write(fd, totlen, buf, "small BAT") == 0) {
				ret = GDK_FAIL;
			}
		} else if (socket_write(fd, (int) strlen(buf), buf, "meta info") == 0 ||
			   /* 64bit: check for overflow of batlen and b->?heap->free */
			   socket_write(fd, batlen, BUNfirst(b), "BUN heap") == 0 ||
			   (b->hheap && socket_write(fd, b->hheap->free, b->hheap->base, "head heap") == 0) ||
			   (b->theap && socket_write(fd, b->theap->free, b->theap->base, "tail heap") == 0)) {
			ret = GDK_FAIL;
		}
#ifndef WORDS_BIGENDIAN
		BATconvert(b, CONV_NTOH);
#endif
	} else if (tpe != TYPE_void) {
@- <type>:<name>:<size>
@c
		len = ATOMextern(tpe) ? ATOMlen(tpe, val) : (int) sizeof(lng);
		sprintf(buf, "%s:%s:%d\n", atom_name(tpe), name, len);
		hdrlen = (int) strlen(buf);

#ifndef WORDS_BIGENDIAN
		ATOMconvert(tpe, val, CONV_HTON);
#endif
		if (len < BIG_MESSAGE) {
			memcpy(buf + hdrlen, val, len);
@-
Writing all data at once is a lot faster!
@c
			if (socket_write(fd, hdrlen + len, buf, "atom data") == 0) {
				ret = GDK_FAIL;
			}
		} else {
@-
NOTE: some atoms can be very big (jarray, image).
don't copy them to the buffer.
@c
			if (socket_write(fd, hdrlen, buf, "header") == 0) {
				ret = GDK_FAIL;
			} else if (socket_write(fd, len, val, "atom data") == 0) {
				ret = GDK_FAIL;
			}
		}
#ifndef WORDS_BIGENDIAN
		ATOMconvert(tpe, val, CONV_NTOH);
#endif
	}
	return ret;
}

int
TCPexport_default(int *conn_id, BAT *b)
{
	return TCPexport(conn_id, b, TYPE_bat, BATgetId(b));
}

@+ import(int, str) : any
Import a value from a TCP/IP server.
@c
int
TCPimport(ptr retval,		/* put pointer atom here */
	  int *rettpe,		/* put type of atom here */
	  str name,		/* string: pointer to char. */
	  bit *rm		/* remove from the cache */
    )
{
	cache_t *c;

@-
Lookup or create (if it did not exist) a cache item by this name.
@c
	MT_set_lock(TCPlock, "TCPimport");
	c = cache_find(name);
	if (c->tpe == TYPE_bat ? c->val.bval != 0 : c->val.pval != 0)
		goto get_direct;
	c->locked++;
	MT_unset_lock(TCPlock, "TCPimport");
@-
Try to pass the barrier. This makes you wait till the BAT arrived.
@c
	MT_down_sema(c->barrier, "TCPimport");
@-
Delayed free of the cache item; this occurs when the cache
was cleared (or your line went down) while you were waiting.
@c
	MT_set_lock(TCPlock, "TCPimport");
	c->locked--;
@-
Raise remote warnings and errors here.
@c
      get_direct:
	if (c->errbuf != NULL) {
		cache_error(c);
	}
@-
check whether we really have a value
@c
	if (c->conn == -1 || (c->tpe == TYPE_bat ? c->val.bval == 0 : c->val.pval == 0)) {
		str msg;

		if (c->locked == 0)
			cache_free(c);
		MT_unset_lock(TCPlock, "TCPimport");
		if (c->conn == -1)
			msg = "c->conn == -1";
		else if (c->tpe == TYPE_bat)
			msg = "c->val.bval == 0";
		else
			msg = "c->val.pval == 0";
		GDKerror("TCPimport failed due to '%s'.\n", msg);
		return GDK_FAIL;
	}
@-
Copy from the cache into the return value.
@c
	*rettpe = c->tpe;

	if (c->tpe == TYPE_bat) {
		*(BAT **) retval = BATdescriptor(c->val.bval);
	} else if (ATOMextern(c->tpe)) {
		int len = ATOMlen(c->tpe, c->val.pval);

		*(ptr *) retval = (ptr) GDKmalloc(len);
		memcpy(*(ptr *) retval, c->val.pval, len);
	} else {
		memcpy(retval, c->val.pval, ATOMsize(c->tpe));
	}
	if (*rm) {
		cache_del(c);
	} else if (c->locked) {
		MT_up_sema(c->barrier, "TCPimport");
	}
	MT_unset_lock(TCPlock, "TCPimport");
	return GDK_SUCCEED;
}

int
TCPimport_default(ptr retval, int *rettpe, str name)
{
	bit remove_from_cache = TRUE;

	return TCPimport(retval, rettpe, name, &remove_from_cache);
}

static int evalnr = 0;

@+ mil(int, str) : void
Evaluate a MIL expression or script on the other side of the connection,
without giving back a return value.
@c
int
TCPmil(int *conn_id,		/* connection id */
       str s			/* MIL script */
    )
{
	if (*conn_id < 0 || *conn_id >= MAX_CONN || !connections[*conn_id].me) {
		GDKerror("TCPmil: invalid connection.\n");
	} else {
		char *q, *buf = (str) GDKmalloc(strlen(s) + 32);
		int ok;
		SOCKET fd = connections[*conn_id].sock;

@- format 'mil:<name>:<mil-expr>'
Compress the MIL command by removing all newlines and tabs.
@c
		MT_set_lock(TCPlock, "TCPmil");
		sprintf(buf, "mil:mil%08d:", evalnr++);
		MT_unset_lock(TCPlock, "TCPmil");
		for (q = buf + strlen(buf); *s; s++) {
			*q++ = ((*s != '\n') && (*s != '\t')) ? *s : ' ';
		}
		*q++ = '\n';
		*q = 0;
@-
just send it to the other end
@c
		ok = socket_write(fd, (int) (q - buf), buf, "MIL script");
		GDKfree(buf);
		if (!ok)
			return GDK_FAIL;
@-
Import the resulting expression using the standard mechanism.
@c
		return GDK_SUCCEED;
	}
	return GDK_FAIL;
}

@+ rpc(int, str, ...any...) : any
Evaluate a MIL command on the other side of the connection, and
give back a result value. The second parameter is a function call
possibly with '%a' in the parameter list indicating local parameters
that have to be transported;

# EXAMPLE USE OF RPC:
#
result_bat := fd.rpc("join(remote_bat, %s)", local_bat);
#
# this will send local_bat to the other side, join
# it there with 'remote_bat', and send back the result.

Implementation is taken together for both @%TCPrpc@ and @%TCParpc@
(a variant which does not expect a return). This variant is actually
available as a complex variant of the 'mil' command (for remote MIL
invocation).

@- rpc client implementation
INC_BUFLEN increases the size of the buf variable if needed.
It move the cmd pointer to the "current" position.
@c
#define INC_BUFLEN(x) {\
	int _l = totlen+(x);\
	if (_l >= buflen) buf = GDKrealloc((ptr) buf, buflen = _l+4096);\
	cmd = buf + totlen;\
	totlen = _l;\
}
@= rpc_imp
{
	str fcn_cur;

	if (*conn_id<0 || *conn_id>=MAX_CONN || !connections[*conn_id].me) {
		GDKerror("TCP@1: invalid connection.\n");
		return GDK_FAIL;
	} else {
		int eval_id, ok = 0, nparam = 0, totlen = 0, buflen = 4096;
		char *buf = (char*) GDKmalloc(buflen), *cmd=buf;
		SOCKET fd = connections[*conn_id].sock;
		ptr val;

		/* Find start in the pattern. */
		while(GDKisspace(*fcn_start))
			fcn_start++;
		fcn_cur = fcn_start;

		/* Make an unique name for retrieving the result
		 * of this expression.
		 */
		MT_set_lock(TCPlock, "TCP@1");
		eval_id = evalnr++;
		MT_unset_lock(TCPlock, "TCP@1");
		sprintf(id, "@1%08d", eval_id);

		/* Like TCPmil, we use the "mil:name:expr" protocol.
		 * The difference is in <name> in that if it starts
		 * with "rpc", the conn_waiter() will send back a
		 * result.
		 */
		sprintf(cmd, "mil:%s:", id);
		INC_BUFLEN((int) strlen(cmd));

		/* For all local parameters passed for substitution.....
		 */
		while((val = va_arg(ap, ptr)) != NULL) {
			int tpe = va_arg(ap, int);
			/* .....look for the place where it should be
			 * substituted (marked by %s).
			 */
			int instr=0, esc=0;

			while (fcn_cur[0] &&
			       (instr || esc ||
				(fcn_cur[0] != '%' && GDKisprint(fcn_cur[1])))) {
				if (!esc) {
					esc = (*fcn_cur == '\\');
					if (instr)
						instr = *fcn_cur != '"';
					else
						instr = *fcn_cur == '"';
				} else
					esc = 0;
				INC_BUFLEN(1);
				*cmd = *fcn_cur++; /* COPY THROUGH */
			}
			nparam++;
			if (*fcn_cur == 0) { /* %s NOT FOUND */
				GDKwarning("TCP@1: ignore param %d and beyond.\n", nparam);
				break;
			}
			fcn_cur += 2; /* STEP OVER %s */
			/* The local values have to be transported to the other side.
			 * Simple values are best printed as a string inside the
			 * command. Complex types or whole BATs must be transported
			 * with the export mechanism. In the function call they are
			 * replaced by import expressions. We also optimize when
			 * user-defined types are derived from standard types (then we
			 * send a cast from the standard type).
			 */
			if (tpe == TYPE_str) {
				INC_BUFLEN((int) strlen(val)+2);
				sprintf(cmd, "\"%s\"", (str) val);
			} else if (ATOMstorage(tpe) == TYPE_str) {
				str t = ATOMname(tpe);
				INC_BUFLEN((int) (strlen(t) + strlen(val) + 4));
				sprintf(cmd, "%s(\"%s\")", t, (str) val);
			} else if ((tpe == TYPE_bat) || ATOMextern(tpe)) {
				char export_id[17];
				sprintf(export_id, "p%02d%08d", nparam, eval_id);
				if (!TCPexport(conn_id, val, tpe, export_id)) {
					goto fail;
				}
				INC_BUFLEN(21);			    /* len of >import("id")< */
				sprintf(cmd, "import(\"%s\")", export_id);
			} else {
				str s = NULL, t = ATOMname(tpe);
				ATOMformat(ATOMstorage(tpe), val, &s);
				INC_BUFLEN((int) (strlen(s) + strlen(t) + 2));
				sprintf(cmd, "%s(%s)", t, s);
				GDKfree(s);
			}
		}
		va_end(ap);

		/* Copy the function call to our send buffer.
		 * Close the call with ')' if this exists in the calling prototype.
		 * (zero parameter functions don't need () in MIL). It is already
		 * expected to be finished off with semicolon. Newline is added.
		 */
		INC_BUFLEN((int) strlen(fcn_cur) + 1);
		strcat(buf, fcn_cur);
		strcat(buf, "\n");

		/* Now we send it to the other end
		 */
		ok = socket_write(fd, (int) strlen(buf), buf, "MIL command");
	fail:
		GDKfree(buf);
		if (!ok)
			return GDK_FAIL;
	}
}

@- rpc with a return value
@c
int
TCPrpc(ptr retval, int *rettp, int *conn_id, str fcn_start, ...)
{
	va_list ap;
	bit remove_from_cache = TRUE;
	char id[17];

	va_start(ap, fcn_start);
	@:rpc_imp(rpc)@
@-
Import the resulting expression using the standard mechanism.
@c
	return TCPimport(retval, rettp, id, &remove_from_cache);
}

@- rpc without a return value (i.e. 'mil')
@c
int
TCParpc(int *conn_id, str fcn_start, ...)
{
	va_list ap;
	char id[17];

	va_start(ap, fcn_start);
	@:rpc_imp(mil)@
	return GDK_SUCCEED;
}

@}

@f standalone
@* Standalone TCP/IP send
This is a minimal example program that can make contact with the
listener thread of a TCP/IP equipped Mserver, and sends a table
to the Mserver, that can be used there as a BAT.
@c
#define TABLE_SIZE 10000

typedef struct {
	int i;
	float f;
} tuple;

tuple table[TABLE_SIZE] = { 0 };

main(void)
{
	SOCKET fd = socket_open(argv[1], atoi(argv[2]), "main");
	FILE *fp = fopen(fd, "w");

@-
Init the connection
@c
	fprintf(fp, "connection identifier\n");
@-
Send one BAT.
@c
	fprintf(fp, "bat:my_table_name:%d*" SZFMT ":int=%d:flt=" SZFMT ":0:0\n", TABLE_SIZE, sizeof(tuple), 0, sizeof(int));
	fwrite(table, 1, TABLE_SIZE * sizeof(tuple), fp);
	fflush(fp);
}
