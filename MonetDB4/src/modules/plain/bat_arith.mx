@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2008 CWI.
@' All Rights Reserved.

@f bat_arith
@t Optimized Multiplexed Basic Arithmetics on BATs
@a S. Manegold, N. Nes
@v 1.0
@* Introduction

This module provides optimized code-expanded implementations of multiplexed
basic arithmetics ([+],[-],[*],[/],[%]) on void-headed, head-aligned BATs.
Only the standard types {\tt bte}, {\tt sht}, {\tt int}, {\tt wrd}, {\tt lng}, {\tt flt}, and {\tt dbl} are supported.

@* Module Definition
@m
.MODULE bat_arith;

@
\begin{verbatim}
	mel_operation
	@1:	bte, sht, int, wrd, lng, flt, dbl arithmetic type
	@2:	+,   -,  *,   /,   %   basic arithmetic operator
	@3:	add, sub, mul, div, mod basic arithmetic operator name
	@4:	type of operator
	@5-@7:	not used
\end{verbatim}
@= mel_operation
.OPERATOR@4 (BAT[void,@1]) "[@2]" (BAT[void,@1]) : BAT[void,@1] = batbat_@1_@3;
	"optimized multiplexed @3 ('@2') on head-aligned [void,@1] BATs"
.OPERATOR@4 (@1) "[@2]" (BAT[void,@1]) : BAT[void,@1] = valbat_@1_@3;
	"optimized multiplexed left-scalar @3 ('@2') on [void,@1] BAT"
.OPERATOR@4 (BAT[void,@1]) "[@2]" (@1) : BAT[void,@1] = batval_@1_@3;
	"optimized multiplexed right-scalar @3 ('@2') on [void,@1] BAT"
.OPERATOR@4 (BAT[void,@1]) "[:@2=]" (BAT[void,@1]) : BAT[void,@1] = batbat_@1_@3_inplace;
	"optimized multiplexed in-place @3 (':@2=') on head-aligned [void,@1] BATs (overwrites first operand)"
.OPERATOR@4 (@1) "[:@2=]" (BAT[void,@1]) : BAT[void,@1] = valbat_@1_@3_inplace;
	"optimized multiplexed left-scalar in-place @3 (':@2=') on [void,@1] BAT (overwrites second operand)"
.OPERATOR@4 (BAT[void,@1]) "[:@2=]" (@1) : BAT[void,@1] = batval_@1_@3_inplace;
	"optimized multiplexed right-scalar in-place @3 (':@2=') on [void,@1] BAT (overwrites first operand)"
@= mel_redefine_OP
@m

@:operations(mel)@
.END bat_arith;

@= operations
@:@1_operation(bte,+,add,,0,2)@
@:@1_operation(bte,-,sub,,0,2)@
@:@1_operation(bte,*,mul,1,0,3)@
@:@1_operation(bte,/,div,1,1,1)@
@:@1_operation(bte,%,mod,1,1,0)@
@:@1_operation(sht,+,add,,0,2)@
@:@1_operation(sht,-,sub,,0,2)@
@:@1_operation(sht,*,mul,1,0,3)@
@:@1_operation(sht,/,div,1,1,1)@
@:@1_operation(sht,%,mod,1,1,0)@
@:@1_operation(int,+,add,,0,2)@
@:@1_operation(int,-,sub,,0,2)@
@:@1_operation(int,*,mul,1,0,3)@
@:@1_operation(int,/,div,1,1,1)@
@:@1_operation(int,%,mod,1,1,0)@
@:@1_operation(wrd,+,add,,0,2)@
@:@1_operation(wrd,-,sub,,0,2)@
@:@1_operation(wrd,*,mul,1,0,3)@
@:@1_operation(wrd,/,div,1,1,1)@
@:@1_operation(wrd,%,mod,1,1,0)@
@:@1_operation(lng,+,add,,0,2)@
@:@1_operation(lng,-,sub,,0,2)@
@:@1_operation(lng,*,mul,1,0,3)@
@:@1_operation(lng,/,div,1,1,1)@
@:@1_operation(lng,%,mod,1,1,0)@
@:@1_operation(flt,+,add,,0,2)@
@:@1_operation(flt,-,sub,,0,2)@
@:@1_operation(flt,*,mul,1,0,3)@
@:@1_operation(flt,/,div,1,1,1)@
@:@1_operation(dbl,+,add,,0,2)@
@:@1_operation(dbl,-,sub,,0,2)@
@:@1_operation(dbl,*,mul,1,0,3)@
@:@1_operation(dbl,/,div,1,1,1)@
@:@1_redefine_OP()@
@:@1_operation(flt,%,mod,1,1,1,%)@
@:@1_operation(dbl,%,mod,1,1,1,%)@

@* Implementation
@c
#include "monetdb4_config.h"
#include <gdk.h>
#include <gdk_scanselect.h>	/* for type-specific HT_bunfastins_nocheck_noinc(), until they're moved to gdk.mx */
#include "bat_arith.proto.h"

@c
/*	implementation
	@1:	bte, sht, int, wrd, lng, flt, dbl arithmetic type
	@2:	+,   -,   *,   /,   %   basic arithmetic operator
	@3:	add, sub, mul, div, mod basic arithmetic operator name
	@4:	not used
	@5:		0 / 1		disable/enable division by zero check
	@6:		0 / 1 / 2	disable/enable sorting propagation
					1 propagate on bat,const
					2 propagate also on const,bat
*/
@= c_operation
int
batbat_@1_@3(BAT **ret, BAT *l, BAT *r)
{
	REGISTER @1 *lp, *lq, *rp;
	REGISTER @1 *bnp = NULL, *s = NULL;
	BAT *bn;

	ALGODEBUG THRprintf(GDKout, "#batbat_@1_@3[@7@2,@5](l=%s,r=%s);\n", 
		BATgetId(l),BATgetId(r)); 
	ERRORcheck((l->htype!=TYPE_void)||(r->htype!=TYPE_void)||(l->hseqbase!=r->hseqbase)||(BATcount(l)!=BATcount(r)),
		   "batbat_@1_@3: BATs l & r must be void-headed and head-aligned.\n");

	bn = BATnew(TYPE_void, l->ttype, BATcount(l));
	if (bn == NULL)
		return GDK_FAIL;
	BATseqbase(bn,l->hseqbase);
	bn->tsorted = 0;

	lq = (@1*)Tloc(l,BUNlast(l));
	lp = (@1*)Tloc(l,BUNfirst(l));
	rp = (@1*)Tloc(r,BUNfirst(r));
	s = bnp = (@1*)Tloc(bn,BUNlast(bn));
	for (; lp < lq; lp++, rp++) {
		if (@5 && (*rp == 0)) {
			GDKerror("[@7@2] (batbat_@1_@3): Division by Zero!");
			BBPreclaim(bn);
			return GDK_FAIL;
		} else if ((*lp != @1_nil) && (*rp != @1_nil)) {
			*bnp = (@1) OP(*lp,@2,*rp);
		} else {
			*bnp = @1_nil;
		}
		bnp++;
	}

	BATsetcount(bn, bnp-s);
	if (!bn->batDirty) bn->batDirty = TRUE;

	*ret = bn;
	return GDK_SUCCEED;
}
int
batbat_@1_@3_inplace(BAT **ret, BAT *l, BAT *r)
{
	REGISTER @1 *lp, *lq, *rp;

	ALGODEBUG THRprintf(GDKout, "#batbat_@1_@3_inplace[@7@2,@5](l=%s,r=%s);\n",
		BATgetId(l),BATgetId(r));
	ERRORcheck((l->htype!=TYPE_void)||(r->htype!=TYPE_void)||(l->hseqbase!=r->hseqbase)||(BATcount(l)!=BATcount(r)),
		   "batbat_@1_@3_inplace: BATs l & r must be void-headed and head-aligned.\n");

	l->tsorted = 0;
	lq = (@1*)Tloc(l,BUNlast(l));
	lp = (@1*)Tloc(l,BUNfirst(l));
	rp = (@1*)Tloc(r,BUNfirst(r));
	for (; lp < lq; lp++, rp++) {
		if (@5 && (*rp == 0)) {
                        GDKerror("[:@7@2=] (batbat_@1_@3_inplace): Division by Zero!");
                        return GDK_FAIL;
		} else if ((*lp != @1_nil) && (*rp != @1_nil)) {
			*lp = (@1) OP(*lp,@2,*rp);
		} else {
			*lp = @1_nil;
		}
	}
	if (!l->batDirty) l->batDirty = TRUE;

	BBPfix(l->batCacheid);
	*ret = l;
	return GDK_SUCCEED;
}
int
valbat_@1_@3(BAT **ret, @1 *v, BAT *b)
{
	REGISTER @1 *bp, *bq;
	REGISTER @1 *bnp, *s;
	REGISTER @1 vv = (((*v)!=@1_nil)?(*v):@1_nil);
	BAT *bn;

	ALGODEBUG THRprintf(GDKout, "#valbat_@1_@3[@7@2,@5](v,b=%s);\n",BATgetId(b));
	ERRORcheck((b->htype!=TYPE_void),
		   "valbat_@1_@3: BAT b must be void-headed.\n");
	/* todo for commutative operators call batval (ie. for *, + and - ) */

	bn = BATnew(TYPE_void, b->ttype, BATcount(b));
	if (bn == NULL)
		 return GDK_FAIL;
	BATseqbase(bn,b->hseqbase);
	bn->tsorted = 0;
	bq = (@1*)Tloc(b,BUNlast(b));
	bp = (@1*)Tloc(b,BUNfirst(b));
	s = bnp = (@1*)Tloc(bn,BUNlast(bn));
	if (vv != @1_nil) {
		for (; bp < bq; bp++, bnp++) {
			REGISTER @1 bv = *bp;
			if (@5 && (bv == 0)) {
                                GDKerror("[@7@2] (valbat_@1_@3): Division by Zero!");
                                BBPreclaim(bn);
                                return GDK_FAIL;
			} else if (bv != @1_nil) {
				bv = (@1) OP(vv,@2,bv);
			}
			*bnp = bv;
		}
	} else {
		for (; bp < bq; bp++, bnp++) {
			*bnp = vv;
		}
	}
	BATsetcount(bn, bnp-s);
	if (!bn->batDirty) bn->batDirty = TRUE;

	if (@6 == 2) 
		bn->tsorted = BATtordered(b);
	if (@6 == 3) { 
		if (*v > 0)
			bn->tsorted = BATtordered(b);
		else
			bn->tsorted = REVERT_SORTED(BATtordered(b));
	}

	*ret = bn;
	return GDK_SUCCEED;
}
int valbat_@1_@3_inplace(BAT **ret, @1 *v, BAT *b) {
	REGISTER @1 *bp, *bq;
	REGISTER @1 vv = (((*v)!=@1_nil)?(*v):@1_nil);

	ALGODEBUG THRprintf(GDKout, "#valbat_@1_@3_inplace[@7@2,@5](v,b=%s);\n",BATgetId(b));
	ERRORcheck((b->htype!=TYPE_void),
		   "valbat_@1_@3_inplace: BAT b must be void-headed.\n");
	/* todo for commutative operators call batval (ie. for * and /) */

	bq = (@1*)Tloc(b,BUNlast(b));
	bp = (@1*)Tloc(b,BUNfirst(b));
	if (vv != @1_nil) {
		for (; bp < bq; bp++) {
			if (@5 && (*bp == 0)) {
                                GDKerror("[:@7@2=] (valbat_@1_@3_inplace): Division by Zero!");
                                return GDK_FAIL;
			} else if (*bp != @1_nil) {
				*bp = (@1) OP(vv,@2,*bp);
			}
		}
	} else {
		for (; bp < bq; bp++) {
			*bp = vv;
		}
	}
	if (!b->batDirty) b->batDirty = TRUE;

	if (@6 == 2) 
		b->tsorted = BATtordered(b);
	if (@6 == 3) { 
		if (*v > 0)
			b->tsorted = BATtordered(b);
		else
			b->tsorted = REVERT_SORTED(BATtordered(b));
	} else 
		b->tsorted = 0;

	BBPfix(b->batCacheid);
	*ret = b;
	return GDK_SUCCEED;
}
int
batval_@1_@3(BAT **ret, BAT *b, @1 *v)
{
	REGISTER @1 *bp, *bq;
	REGISTER @1 *bnp, *s;
	REGISTER @1 vv = (((*v)!=@1_nil)?(*v):@1_nil);
	BAT *bn;

	ALGODEBUG THRprintf(GDKout, "#batval_@1_@3[@7@2,@5](v,b=%s);\n",BATgetId(b));
	ERRORcheck((b->htype!=TYPE_void),
		   "batval_@1_@3: BAT b must be void-headed.\n");

	bn = BATnew(TYPE_void, b->ttype, BATcount(b));
	if( bn == NULL)
		return GDK_FAIL;
	BATseqbase(bn,b->hseqbase);
	bn->tsorted = 0;
	bq = (@1*)Tloc(b,BUNlast(b));
	bp = (@1*)Tloc(b,BUNfirst(b));
	s = bnp = (@1*)Tloc(bn,BUNlast(bn));
	if (@5 && (vv == 0)) {
                GDKerror("[@7@2] (batval_@1_@3): Division by Zero!");
                BBPreclaim(bn);
                return GDK_FAIL;
	} else if (vv != @1_nil) {
		for (; bp < bq; bp++, bnp++) {
			REGISTER @1 bv = *bp;
			if (bv != @1_nil) {
				bv = (@1) OP(bv,@2,vv);
			}
			*bnp = bv;
		}
	} else {
		for (; bp < bq; bp++, bnp++) {
			*bnp = vv;
		}
	}
	BATsetcount(bn, bnp-s);
	if (!bn->batDirty) bn->batDirty = TRUE;
	if (@6 == 2) 
		bn->tsorted = BATtordered(b);
	if (@6 == 3) { 
		if (*v > 0)
			bn->tsorted = BATtordered(b);
		else
			bn->tsorted = REVERT_SORTED(BATtordered(b));
	} 

	*ret = bn;
	return GDK_SUCCEED;
}
int
batval_@1_@3_inplace(BAT **ret, BAT *b, @1 *v)
{
	REGISTER @1 *bp, *bq;
	REGISTER @1 vv = (((*v)!=@1_nil)?(*v):@1_nil);

	ALGODEBUG THRprintf(GDKout, "#batval_@1_@3_inplace[@7@2,@5](v,b=%s);\n",BATgetId(b));
	ERRORcheck((b->htype!=TYPE_void),
		   "batval_@1_@3_inplace: BAT b must be void-headed.\n");

	bq = (@1*)Tloc(b,BUNlast(b));
	bp = (@1*)Tloc(b,BUNfirst(b));
	if (@5 && (vv == 0)) {
                GDKerror("[:@7@2=] (batval_@1_@3_inplace): Division by Zero!");
                return GDK_FAIL;
	} else if (vv != @1_nil) {
		for (; bp < bq; bp++) {
			if (*bp != @1_nil) {
				*bp = (@1) OP(*bp,@2,vv);
			}
		}
	} else {
		for (; bp < bq; bp++) {
			*bp = vv;
		}
	}
	if (!b->batDirty) b->batDirty = TRUE;
	if (@6 == 2) 
		b->tsorted = BATtordered(b);
	if (@6 == 3) { 
		if (*v > 0)
			b->tsorted = BATtordered(b);
		else
			b->tsorted = REVERT_SORTED(BATtordered(b));
	} else
		b->tsorted = 0;

	BBPfix(b->batCacheid);
	*ret = b;
	return GDK_SUCCEED;
}
@c
/* the normal implementation of an operator is to just stick the
   operator between the operands */
#define OP(l,op,r)	((l) op (r))
@= c_redefine_OP
/* a % b when a and/or b are float (double) doesn't exist, so provide
   an alternative way of calculating the result */
#undef OP
#define OP(l,op,r)	((l) - (dbl) ((lng) ((l) / (r))) * (r))
@c
@:operations(c)@
