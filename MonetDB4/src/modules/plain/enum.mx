@/
The contents of this file are subject to the MonetDB Public License
Version 1.1 (the "License"); you may not use this file except in
compliance with the License. You may obtain a copy of the License at
http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html

Software distributed under the License is distributed on an "AS IS"
basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations
under the License.

The Original Code is the MonetDB Database System.

The Initial Developer of the Original Code is CWI.
Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
Copyright August 2008-2010 MonetDB B.V.
All Rights Reserved.
@

@f enum
@t Enumeration Data Types
@a Peter Boncz
@v 1.0
@* Introduction

When large sets of data are stored and memory is short, one
seeks for memory occupation optimizations.

One way to do this when the cardinality is low, is to substitute
the data type by a smaller ordinal data type. For instance, when
less than 256 different string values occur in an attribute, one
could store them as a byte.

This remapping can be encapsulated nicely by introducing an 'enum'
atomic type, that appears to be the original type, but is in fact
stored as something smaller. Encode and decode commands, as well
as 'tostr' and 'fromstr' ADT functions, can be generated beforehand
and use a mapping table to translate between the two representations.

This module implements encodings using 'bte' (1-byte encoding),
and 'sht' (2-byte encoding), using a dynamic check on cardinality.

Further space optimizations into values smaller than a byte are
impossible in Monet, since all values need to have a unique memory address.

Though this may by a problem may waste memory, one should realize that
main-memory databases suffer increasingly when the data representation gets
more complex. This is obviously true for complex compression schemes, but
even loading a single byte value is considerably slower on custom CPUs
than loading an entire 32-bit integer. On 64-bits architectures, this
will even be the case for long 64-bit integers.

@* Module Definition
@m
.MODULE enum;

.USE streams;

.COMMAND enum_new(str name, BAT[any,any] data) : int = enum_new;
 "create a new enumeration type."

.COMMAND enum_load(BAT[any,int] map) : int = enum_load;
 "load/activate a previously created enumeration type."

.COMMAND enum_destroy(int enum_t) = enum_destroy;
 "destroy an enumeration type"

.COMMAND encode(int enum_t, any) : any = enum_encode;
 "encode a value"

.COMMAND lower(int enum_t, any) : any = enum_lower;
 "encode to the lowest value in the encoded domain that is larger than v"

.COMMAND upper(int enum_t, any) : any = enum_upper;
 "encode to the hightes value in the encoded domain that is smaller than v"

.COMMAND [encode](int enum_t, BAT[any::1,any]) : BAT[any::1,any] = enum_encode_multi;
 "encode a BAT of tail values, into a new BAT of encoded values"

.COMMAND decode(int enum_t, any) : any = enum_decode;
 "decode a value"

.COMMAND [decode](int enum_t, BAT[any::1,any]) : BAT[any::1,any] = enum_decode_multi;
 "decode a BAT of tail values, into a new BAT of decoded values"

.COMMAND enum_table(int enum_t) : bat[any,any] = enum_table;
 "return the enumeration BAT of an enum type"

.COMMAND isenum(int tpe) : bit = isenum;
 "returns true iff tpe is an enumerated type"

.COMMAND enum_sethisto(int tpe, BAT[any,any] b) = enum_sethisto;
 "registers the fact that enum_table(tpe) is a histogram on b's head column"

.COMMAND enum_ishisto(int tpe, BAT[any,any] b) : bit = enum_ishisto;
 "returns whether enum_table(tpe) is a histogram on b's head column"

.COMMAND enum_print(Stream fp, BAT[any,int] b1, BAT[any,any] b2,
			       BAT[any,any] b3) = enum_print2;
 "quick file print of 3 synced bats, and int tail and two enumerated strings"

.COMMAND enum_print(Stream fp, BAT[any,int] b1,
			       BAT[any,any] b2) = enum_print1;
 "quick file print of 2 synced bats, an int and enumerated string tail"

.PRELUDE = enum_prelude;
.EPILOGUE = enum_epilogue;

.END enum;

@mil
    proc enum_create(str name, BAT[any,any] data) : int {
	var tpe := enum_new(name, data);
	if (monet_atomtbl != bat("adm_atomtbl"))
	    bat("adm_atomtbl").insert(sprintf("%s",name),tpe);
	monet_atomtbl.insert(sprintf("%s",name),tpe);
	return tpe;
    }
    ADDHELP("enum_create", "boncz", "Aug  5 2003",
	 "create a new enumeration type.", "enum");

    proc enum_load(str name) : void {
	var tpe := enum_load(bat(name));
	if (monet_atomtbl != bat("adm_atomtbl"))
	    bat("adm_atomtbl").insert(sprintf("%s",name),tpe);
	monet_atomtbl.insert(sprintf("%s",name),tpe);
	return tpe;
    }
    ADDHELP("enum_load", "boncz", "Sep  6 1997",
	 "activate an enumeration type from a histogram bat.", "enum");

    proc enum_drop(int tpe) : void {
	if (monet_atomtbl != bat("adm_atomtbl"))
	    bat("adm_atomtbl").reverse().delete(tpe);
	monet_atomtbl.reverse().delete(tpe);
	enum_destroy(tpe);
    }
    ADDHELP("enum_drop", "boncz", "Sep  6 1997",
	 "deactivate an enumeration type.", "enum");

    proc enum_trick(bat[oid,any] b, BAT[any,int] map) : bat[oid,any] {
	var nme := sprintf("enum_%d", abs(int(map)));
	map.rename(nme);
	var tpe := enum_load(nme);
	enum_sethisto(tpe, b.reverse());
	return [*nme](b);
    }
    ADDHELP("enum_trick", "boncz", "Dec  5 1998",
	 "create a view on a BAT with a diffrent enum map.", "enum");

@{
@* Implementation
@c
#include "monetdb4_config.h"
#include "gdk.h"
#include "streams.h"
#include "enum.proto.h"
#include "enum.h"

int enum_bte_shift = -(GDK_bte_min+1);	/* GDK_bte_min == GDK_bte_nil ==   -128 */
int enum_sht_shift = -(GDK_sht_min+1);	/* GDK_sht_min == GDK_sht_nil == -32768 */

#define ENUM_CHK(x,y)									\
		BAT *b;									\
		BATiter bi;								\
		int xx;									\
		for(xx=0; xx<MAX_ENUM; xx++)						\
			if (enum_tpe[xx] == (x))					\
				break;							\
		if ((xx>=MAX_ENUM) || ((b=BBPdescriptor(enum_map[xx])) == NULL)) {	\
			GDKerror("ENUM_CHK: %s illegal enum type.\n", (y));			\
			return GDK_FAIL;						\
		}									\
 		bi = bat_iterator(b);							\
		(void) bi;	/* keep compilers happy */

#define MAX_ENUM 80

MT_Lock enum_lock;
bat enum_map[MAX_ENUM] = { 0 };
oid enum_histo[MAX_ENUM] = { 0 };
int enum_tpe[MAX_ENUM] = { -1 };

@:imp(0)@
@:imp(1)@
@:imp(2)@
@:imp(3)@
@:imp(4)@
@:imp(5)@
@:imp(6)@
@:imp(7)@
@:imp(8)@
@:imp(9)@
@:imp(10)@
@:imp(11)@
@:imp(12)@
@:imp(13)@
@:imp(14)@
@:imp(15)@
@:imp(16)@
@:imp(17)@
@:imp(18)@
@:imp(19)@
@:imp(20)@
@:imp(21)@
@:imp(22)@
@:imp(23)@
@:imp(24)@
@:imp(25)@
@:imp(26)@
@:imp(27)@
@:imp(28)@
@:imp(29)@
@:imp(30)@
@:imp(31)@
@:imp(32)@
@:imp(33)@
@:imp(34)@
@:imp(35)@
@:imp(36)@
@:imp(37)@
@:imp(38)@
@:imp(39)@
@:imp(40)@
@:imp(41)@
@:imp(42)@
@:imp(43)@
@:imp(44)@
@:imp(45)@
@:imp(46)@
@:imp(47)@
@:imp(48)@
@:imp(49)@
@:imp(50)@
@:imp(51)@
@:imp(52)@
@:imp(53)@
@:imp(54)@
@:imp(55)@
@:imp(56)@
@:imp(57)@
@:imp(58)@
@:imp(59)@
@:imp(60)@
@:imp(61)@
@:imp(62)@
@:imp(63)@
@:imp(64)@
@:imp(65)@
@:imp(66)@
@:imp(67)@
@:imp(68)@
@:imp(69)@
@:imp(70)@
@:imp(71)@
@:imp(72)@
@:imp(73)@
@:imp(74)@
@:imp(75)@
@:imp(76)@
@:imp(77)@
@:imp(78)@
@:imp(79)@

struct {
	int (*tobte) (str *, int *, ptr);
	int (*frombte) (str, int *, ptr *);
	int (*tosht) (str *, int *, ptr);
	int (*fromsht) (str, int *, ptr *);
} enum_conv[MAX_ENUM] = {
	@:def(0)@
	@:def(1)@
	@:def(2)@
	@:def(3)@
	@:def(4)@
	@:def(5)@
	@:def(6)@
	@:def(7)@
	@:def(8)@
	@:def(9)@
	@:def(10)@
	@:def(11)@
	@:def(12)@
	@:def(13)@
	@:def(14)@
	@:def(15)@
	@:def(16)@
	@:def(17)@
	@:def(18)@
	@:def(19)@
	@:def(20)@
	@:def(21)@
	@:def(22)@
	@:def(23)@
	@:def(24)@
	@:def(25)@
	@:def(26)@
	@:def(27)@
	@:def(28)@
	@:def(29)@
	@:def(30)@
	@:def(31)@
	@:def(32)@
	@:def(33)@
	@:def(34)@
	@:def(35)@
	@:def(36)@
	@:def(37)@
	@:def(38)@
	@:def(39)@
	@:def(40)@
	@:def(41)@
	@:def(42)@
	@:def(43)@
	@:def(44)@
	@:def(45)@
	@:def(46)@
	@:def(47)@
	@:def(48)@
	@:def(49)@
	@:def(50)@
	@:def(51)@
	@:def(52)@
	@:def(53)@
	@:def(54)@
	@:def(55)@
	@:def(56)@
	@:def(57)@
	@:def(58)@
	@:def(59)@
	@:def(60)@
	@:def(61)@
	@:def(62)@
	@:def(63)@
	@:def(64)@
	@:def(65)@
	@:def(66)@
	@:def(67)@
	@:def(68)@
	@:def(69)@
	@:def(70)@
	@:def(71)@
	@:def(72)@
	@:def(73)@
	@:def(74)@
	@:def(75)@
	@:def(76)@
	@:def(77)@
	@:def(78)@
	@:def(79)@
};

@= def
	{tostr@1bte, fromstr@1bte, tostr@1sht, fromstr@1sht,},
@= imp
	@:template(@1,bte)@ @:template(@1,sht)@
@= template
static int
tostr@1@2(char** dst, int* len, ptr src)
{
	BAT *b = BBPdescriptor(enum_map[@1]);
	int l; ptr v;

	if (*(@2*)src == @2_nil) {
		v = ATOMnilptr(b->htype);
	} else {
		BATiter bi = bat_iterator(b);
		/* shift (GDK_@2_min+1)..GDK_@2_max back to 0..(2*GDK_@2_max) */
		BUN p = *(@2*)src + enum_@2_shift;
		v = BUNhead(bi,p);
	}
	if (b->htype != TYPE_str) {
		int (*tostr)(str*, int*, ptr) = BATatoms[b->htype].atomToStr;
		return (*tostr)(dst, len, v);
	}
	l = strLen(v);
	if (*len < l) {
		if (*dst)
			GDKfree(*dst);
		*dst = (char*) GDKmalloc(*len = l);
	}
	memcpy(*dst, v, l);
	return (l-1); /* return string length excluding eos */
}
static int
fromstr@1@2(str src, int* len, ptr* dst)
{
	BAT *b = BBPdescriptor(enum_map[@1]);
	int r, l = 0;
	BUN p; ptr v;

	if (b->htype != TYPE_str) {
		int (*fromstr)(str, int*, ptr*) = BATatoms[b->htype].atomFromStr;
		v = (ptr) GDKmalloc(l=32);
		r = (*fromstr)(src, &l, &v);
	} else {
		r = (int) strlen(src);
		v = src;
	}
	if (*len < (int) sizeof(@2)) {
		*(@2**)dst = (@2*) GDKmalloc(*len = sizeof(@2));
	}
	if ((p = SORTfnd(b, v)) != BUN_NONE) {
		/* shift 0..(2*GDK_@2_max) to (GDK_@2_min+1)..GDK_@2_max */
		**(@2**) dst = (@2) (p - enum_@2_shift);
	} else {
		**(@2**)dst = @2_nil;
	}
	if (l) GDKfree(v);
	return r;
}
@c
enum_export int
enum_load(int *retval, BAT *h)
{
	int i;

	MT_set_lock(enum_lock, "enum_load");
	for (i = 0; i < MAX_ENUM; i++) {
		if (enum_map[i] == 0) {
			char *name = BATgetId(h);

			if (BATcount(h) < 255) { /* without bte_nil ! */
				ATOMproperty(name, "storage", (GDKfcn) NULL, TYPE_bte);
				ATOMproperty(name, "tostr", (GDKfcn) enum_conv[i].tobte, 0);
				ATOMproperty(name, "fromstr", (GDKfcn) enum_conv[i].frombte, 0);
			} else if (BATcount(h) < 65535) { /* without sht_nil ! */
				ATOMproperty(name, "storage", (GDKfcn) (ssize_t) NULL, TYPE_sht);
				ATOMproperty(name, "tostr", (GDKfcn) enum_conv[i].tosht, 0);
				ATOMproperty(name, "fromstr", (GDKfcn) enum_conv[i].fromsht, 0);
			} else {
				MT_unset_lock(enum_lock, "enum_load");
				GDKerror("enum_load: too many values (" BUNFMT ") for enum types.\n", BATcount(h));
				return GDK_FAIL;
			}
			enum_tpe[i] = *retval = ATOMindex(name);
			enum_map[i] = h->batCacheid;
			BBPfix(h->batCacheid);
			MT_unset_lock(enum_lock, "enum_load");
			return GDK_SUCCEED;
		}
	}
	MT_unset_lock(enum_lock, "enum_load");
	GDKerror("enum_load: too many active enum types.\n");
	return GDK_FAIL;
}

int
enum_new(int *retval, str name, BAT *b)
{
	BAT *h = BAThistogram(b);
	ptr nil = ATOMnilptr(b->htype);
	int ret;

	BUNdelHead(h, nil, FALSE);
	BATorder(h);
	BATrename(h, name);
	BATmode(h, PERSISTENT);
	ret = enum_load(retval, h);
	BBPunfix(h->batCacheid);
	return ret;
}

int
enum_destroy(int *enum_t)
{
	ENUM_CHK(*enum_t, "drop");
	MT_set_lock(enum_lock, "enum_destroy");
	ATOMdelete(*enum_t);
	BBPunfix(enum_map[xx]);
	enum_histo[xx] = 0;
	enum_map[xx] = 0;
	enum_tpe[xx] = 0;
	MT_unset_lock(enum_lock, "enum_destroy");
	return GDK_SUCCEED;
}

int
enum_encode(ptr dst, int *dsttpe, int *enum_t, ptr src, int srctpe)
{
	BUN p;

	ENUM_CHK(*enum_t, "encode");
	if (srctpe != b->htype) {
		GDKerror("enum_encode: incompatible source type.\n");
		return GDK_FAIL;
	}
	*dsttpe = *enum_t;
	p = BUNfnd(b, src);
	if (ATOMstorage(*enum_t) == TYPE_bte) {
		if (p == BUN_NONE) {
			/* bte_nil = -128 */
			*(bte *) dst = bte_nil;
		} else {
			/* shift 0..254 to -127..127 (bte is signed!) */ 
			*(bte *) dst = (bte) (p - enum_bte_shift);
		}
	} else {
		if (p == BUN_NONE) {
			/* sht_nil = -32767 */
			*(sht *) dst = sht_nil;
		} else {
			/* shift 0..65534 to -32767..32767 (sht is signed!) */
			*(sht *) dst = (sht) (p - enum_sht_shift);
		}
	}
	return GDK_SUCCEED;
}

int
enum_lower(ptr dst, int *dsttpe, int *enum_t, ptr src, int srctpe)
{
	BUN p;

	ENUM_CHK(*enum_t, "lower");
	if (srctpe != b->htype || !ATOMlinear(srctpe)) {
		GDKerror("enum_lower: incompatible source type.\n");
		return GDK_FAIL;
	}
	*dsttpe = *enum_t;
	if (BAThordered(b) & 1) {
		p = SORTfndlast(BATmirror(b), src);
		if (p != BUN_NONE && p > BUNfirst(b))
			p -= 1;
		else
			p = BUN_NONE;
	} else {
		/* only sorted enum's are supported */
		return GDK_FAIL;
	}
	if (ATOMstorage(*enum_t) == TYPE_bte) {
		if (p == BUN_NONE) {
			/* bte_nil = -128 */
			*(bte *) dst = bte_nil;
		} else {
			/* shift 0..254 to -127..127 (bte is signed!) */ 
			*(bte *) dst = (bte) (p - enum_bte_shift);
		}
	} else {
		if (p == BUN_NONE) {
			/* sht_nil = -32767 */
			*(sht *) dst = sht_nil;
		} else {
			/* shift 0..65534 to -32767..32767 (sht is signed!) */
			*(sht *) dst = (sht) (p - enum_sht_shift);
		}
	}
	return GDK_SUCCEED;
}

int
enum_upper(ptr dst, int *dsttpe, int *enum_t, ptr src, int srctpe)
{
	BUN p;

	ENUM_CHK(*enum_t, "upper");
	if (srctpe != b->htype || !ATOMlinear(srctpe)) {
		GDKerror("enum_upper: incompatible source type.\n");
		return GDK_FAIL;
	}
	*dsttpe = *enum_t;
	if (BAThordered(b) & 1) {
		p = SORTfndfirst(BATmirror(b), src);
	} else {
		/* only sorted enum's are supported */
		return GDK_FAIL;
	}
	if (ATOMstorage(*enum_t) == TYPE_bte) {
		if (p == BUN_NONE) {
			/* bte_nil = -128 */
			*(bte *) dst = bte_nil;
		} else {
			/* shift 0..254 to -127..127 (bte is signed!) */ 
			*(bte *) dst = (bte) (p - enum_bte_shift);
		}
	} else {
		if (p == BUN_NONE) {
			/* sht_nil = -32767 */
			*(sht *) dst = sht_nil;
		} else {
			/* shift 0..65534 to -32767..32767 (sht is signed!) */
			*(sht *) dst = (sht) (p - enum_sht_shift);
		}
	}
	return GDK_SUCCEED;
}

int
enum_decode(ptr xdst, int *dsttpe, int *enum_t, ptr src, int srctpe)
{
	ptr *dst = (ptr *) xdst;
	ptr v;

	ENUM_CHK(*enum_t, "decode");
	if (srctpe != *enum_t) {
		GDKerror("enum_decode: incompatible source type.\n");
		return GDK_FAIL;
	}
	if (ATOMstorage(*enum_t) == TYPE_bte) {
		if (*(bte *) src == bte_nil) {
			v = ATOMnilptr(b->htype);
		} else {
			/* shift -127..127 back to 0..254 */
			v = BUNhead(bi, *(bte*)src + enum_bte_shift);
		}
	} else {
		if (*(sht *) src == sht_nil) {
			v = ATOMnilptr(b->htype);
		} else {
			/* shift -32767..32767 back to 0..65534 */
			v = BUNhead(bi, *(sht*)src + enum_sht_shift);
		}
	}
	if (b->hvarsized) {
		int l = ATOMlen(b->htype, v);

		*dst = GDKmalloc(l);
		memcpy(*dst, v, l);
	} else {
		memcpy(dst, v, ATOMsize(b->htype));
	}
	*dsttpe = b->htype;
	return GDK_SUCCEED;
}

#define HASHfnd_loc(r,bi,p) r = BUNfnd(bi.b,p)
#define HASHfnd_var(r,bi,p) r = BUNfnd(bi.b,p)

@= encode
	{
		BAT *bn = BATnew(src->htype, *enum_t, BATcount(src));
		BATiter srci = bat_iterator(src);
		BUN p,q,r; 
		@1 idx;

		if (bn == NULL)
			return GDK_FAIL;
		if (BAThordered(b)&1) {
			BATloop(src, p, q) {
				r = SORTfnd@3(b, BUNt@2(srci,p));
				if (r == BUN_NONE) {
					idx = @1_nil;
					bn->T->nonil = 0;
				} else {
					/* shift 0..(2*GDK_@1_max) to (GDK_@1_min+1)..GDK_@1_max */
					idx = (@1) (r - enum_@1_shift);
				}
				if (BUNfastins(bn, BUNhead(srci,p), &idx) == NULL) {
					BBPreclaim(bn);
					return GDK_FAIL;
				}
			}
		} else {
			BATloop(src, p, q) {
				HASHfnd@3(r, bi, BUNt@2(srci,p));
				if (r == BUN_NONE) {
					idx = @1_nil;
					bn->T->nonil = 0;
				} else {
					/* shift 0..(2*GDK_@1_max) to (GDK_@1_min+1)..GDK_@1_max */
					idx = (@1) (r - enum_@1_shift);
				}
				if (BUNfastins(bn, BUNhead(srci,p), &idx) == NULL) {
					BBPreclaim(bn);
					return GDK_FAIL;
				}
			}
		}
		*dst = bn;
		bn->tsorted = 0;
	}
	break;
@c
int
enum_encode_multi(BAT **dst, int *enum_t, BAT *src)
{
	ENUM_CHK(*enum_t, "[encode]");
	if (src->ttype != b->htype) {
		GDKerror("enum_encode_multi: incompatible source type.\n");
		return GDK_FAIL;
	}
	if (ATOMstorage(*enum_t) == TYPE_bte) {
		switch (ATOMstorage(src->ttype)) {
		case TYPE_void:
			GDKerror("enum_encode_multi: illegal tail type.\n");
			return GDK_FAIL;
		case TYPE_chr:
			@:encode(bte,loc,_chr)@

		case TYPE_bte:
			@:encode(bte,loc,_bte)@

		case TYPE_sht:
			@:encode(bte,loc,_sht)@

		case TYPE_int:
			@:encode(bte,loc,_int)@

		case TYPE_flt:
			@:encode(bte,loc,_flt)@

		case TYPE_lng:
			@:encode(bte,loc,_lng)@

		case TYPE_dbl:
			@:encode(bte,loc,_dbl)@

		default:
			if (src->tvarsized) {
			      @:encode(bte,var,_var)@
			} else {
			      @:encode(bte,loc,_loc)@
			}
		}
	} else {
		switch (ATOMstorage(src->ttype)) {
		case TYPE_void:
			GDKerror("enum_encode_multi: illegal tail type.\n");
			return GDK_FAIL;
		case TYPE_chr:
			@:encode(sht,loc,_chr)@

		case TYPE_bte:
			@:encode(sht,loc,_bte)@

		case TYPE_sht:
			@:encode(sht,loc,_sht)@

		case TYPE_int:
			@:encode(sht,loc,_int)@

		case TYPE_flt:
			@:encode(sht,loc,_flt)@

		case TYPE_lng:
			@:encode(sht,loc,_lng)@

		case TYPE_dbl:
			@:encode(sht,loc,_dbl)@

		default:
			if (src->tvarsized) {
			      @:encode(sht,var,_var)@

			} else {
			      @:encode(sht,loc,_loc)@
			}
		}
	}
	ALIGNsetH(*dst, src);
	return GDK_SUCCEED;
}

@= decode
{
	BAT *bn = BATnew(src->htype, b->htype, BATcount(src));
	BATiter srci = bat_iterator(src);
	BUN p,q; 
	ptr w,nil = ATOMnilptr(b->htype);

	if (bn == NULL)
		return GDK_FAIL;
	BATloop(src, p, q) {
		@1 *idx = (@1*) BUNtloc(srci,p);
		if (*(@1*) idx == @1_nil) {
			w = nil;
			bn->T->nonil = 0;
		} else {
			/* shift (GDK_@1_min+1)..GDK_@1_max back to 0..(2*GDK_@1_max) */
			w = BUNhead(bi, *idx + enum_@1_shift);
		}
		if (BUNfastins(bn, BUNhead(srci,p), w) == NULL) {
			BBPreclaim(bn);
			return GDK_FAIL;
		}

	}
	*dst = bn;
}
@c
int
enum_decode_multi(BAT **dst, int *enum_t, BAT *src)
{
	ENUM_CHK(*enum_t, "[decode]");
	if (src->ttype != *enum_t) {
		GDKerror("enum_decode_multi: incompatible source type.\n");
		return GDK_FAIL;
	}
	if (ATOMstorage(*enum_t) == TYPE_bte) {
		@:decode(bte)@
	} else if (ATOMstorage(*enum_t) == TYPE_sht) {
		@:decode(sht)@
	} else {
		GDKerror("enum_decode_multi: illegal tail type.\n");
		return GDK_FAIL;
	}
	ALIGNsetH(*dst, src);
	return GDK_SUCCEED;
}

enum_export int
enum_table(BAT **dst, int *enum_t)
{
	ENUM_CHK(*enum_t, "enum_table");
	BBPfix(b->batCacheid);
	*dst = b;
	return GDK_SUCCEED;
}

@h
enum_export int enum_chktpe(int tpe);

@c
enum_export int
enum_chktpe(int tpe)
{
	int i;

	for (i = 0; i < MAX_ENUM; i++)
		if (enum_tpe[i] == tpe)
			return TRUE;
	return FALSE;
}

int
isenum(bit *ret, int *tpe)
{
	*ret = enum_chktpe(*tpe);
	return GDK_SUCCEED;
}

enum_export int
enum_sethisto(int *enum_t, BAT *column)
{
	ENUM_CHK(*enum_t, "enum_table");
	if (column->halign == 0) {
		column->halign = OIDnew(1);
		column->batDirtydesc = TRUE;
	}
	enum_histo[xx] = column->halign;
	return GDK_SUCCEED;
}

int
enum_ishisto(bit *ret, int *enum_t, BAT *column)
{
	ENUM_CHK(*enum_t, "enum_table");
	*ret = (enum_histo[xx] == column->halign);
	return GDK_SUCCEED;
}

bat *
enum_prelude(void)
{
	MT_init_lock(enum_lock, "enum_lock");
	return NULL;
}

void
enum_epilogue(void)
{
	int xx;

	MT_destroy_lock(enum_lock);
	for (xx = 0; xx < MAX_ENUM; xx++) {
		if (enum_map[xx]) {
			BBPunfix(enum_map[xx]);
		}
	}
}


@+ Fast printing
On the small DD benchmark, printing proved to take up half of the
benchmark time. While this actually is a modeling error in the
benchmark (all this is caused by printing cubes with thousands of entries --
which is not very realistic) the following code was written to
produce the ASCII result more quickly.

It assumes the third column to be of type int (which is printed in octal:)
and assumes the first parameters to be enumerated string. Thus, a simple
lookup and copy can be done to construct the ASCII table. The
whole table is built in memory and flushed in one go to disk.
@c
@:enum_print1(char)@
@:enum_print1(short)@

int
enum_print1(Stream *fp, BAT *b2, BAT *b1)
{
	BAT *e1;
	int tpe1 = b1->ttype;
	str dst;
	size_t i = 1000 + 20 * BATcount(b2);
	stream *s = *(stream **) fp;

	if (ALIGNsynced(b1, b2) == 0) {
		GDKerror("enum_print: all params must be synced\n");
		return GDK_FAIL;
	}
	if (enum_table(&e1, &tpe1) == 0) {
		GDKerror("enum_print: first params must be enum-types\n");
		return GDK_FAIL;
	}
	if (e1->htype != TYPE_str) {
		GDKerror("enum_print: only string enumerations allowed\n");
		return GDK_FAIL;
	}
	dst = GDKmalloc(1000 + 20 * BATcount(b2));
	if (ATOMsize(b1->ttype) == 1) {
		i = enum_print_char(dst, dst + i, b1, e1, b2);
	} else {
		i = enum_print_short(dst, dst + i, b1, e1, b2);
	}
	if (stream_write(s, dst, i, 1) != 1 || stream_flush(s) != 0) {
		GDKerror("enum_print: error writing data\n");
		return GDK_FAIL;
	}
	return GDK_SUCCEED;
}

@= enum_print1
static size_t
enum_print_@1(str p, str q, BAT* b1, BAT* e1, BAT* b2)
{
	unsigned @1* p1 = (unsigned @1*) Tloc(b1,BUNfirst(b1));
	int *p2 = (int*) Tloc(b2,BUNfirst(b2));
	int *end = (int*) Tloc(b2,BUNlast(b2));
	int *h1 = (int*) Hloc(e1,BUNfirst(e1));
	str t1 = (str) e1->H->vheap->base;
	str src, dst=p;

	for(q -= 1000; p2<end; p1++, p2++) {
		int i = *p2;
		if (dst > q) {
			GDKerror("enum_print: running out of buffer\n");
			break;
		}
		for (src=dst+10; i; i >>= 3)
			*(--src) = ('0' + (i&7));
		*(--src) = '0';
		while (src > dst)
			*(--src) = ' ';
		dst += 10;
		*dst++ = '\t';
		for (src = t1+(h1[*p1<<1] << GDK_VARSHIFT); *src; src++,dst++)
			*dst = *src;
		*dst++ = '\n';
	}
	return dst - p;
}

@c
@:enum_print2(char,char)@
@:enum_print2(char,short)@
@:enum_print2(short,char)@
@:enum_print2(short,short)@

int
enum_print2(Stream *fp, BAT *b3, BAT *b2, BAT *b1)
{
	BAT *e1, *e2;
	int tpe1 = b1->ttype;
	int tpe2 = b2->ttype;
	str dst;
	size_t i = 1000 + 28 * BATcount(b3);
	stream *s = *(stream **) fp;

	if (ALIGNsynced(b1, b3) == 0 || ALIGNsynced(b2, b3) == 0) {
		GDKerror("enum_print: all params must be synced\n");
		return GDK_FAIL;
	}
	if (enum_table(&e1, &tpe1) == 0 || enum_table(&e2, &tpe2) == 0) {
		GDKerror("enum_print: first params must be enum-types\n");
		return GDK_FAIL;
	}
	if (e1->htype != TYPE_str || e2->htype != TYPE_str) {
		GDKerror("enum_print: only string enumerations allowed\n");
		return GDK_FAIL;
	}
	dst = GDKmalloc(i);
	if (ATOMsize(b1->ttype) == 1) {
		if (ATOMsize(b2->ttype) == 1) {
			i = enum_print_char_char(dst, dst + i, b1, e1, b2, e2, b3);
		} else {
			i = enum_print_char_short(dst, dst + i, b1, e1, b2, e2, b3);
		}
	} else {
		if (ATOMsize(b2->ttype) == 1) {
			i = enum_print_short_char(dst, dst + i, b1, e1, b2, e2, b3);
		} else {
			i = enum_print_short_short(dst, dst + i, b1, e1, b2, e2, b3);
		}
	}
	if (stream_write(s, dst, i, 1) != 1 || stream_flush(s) != 0) {
		GDKerror("enum_print: error writing data\n");
		return GDK_FAIL;
	}
	return GDK_SUCCEED;
}

@= enum_print2
static size_t
enum_print_@1_@2(str p, str q, BAT* b1, BAT* e1, BAT* b2, BAT* e2, BAT* b3)
{
	unsigned @1* p1 = (unsigned @1*) Tloc(b1,BUNfirst(b1));
	unsigned @2* p2 = (unsigned @2*) Tloc(b2,BUNfirst(b2));
	int *p3 = (int*) Tloc(b3,BUNfirst(b3));
	int *end = (int*) Tloc(b3,BUNlast(b3));
	int *h1 = (int*) Hloc(e1,BUNfirst(e1));
	int *h2 = (int*) Hloc(e2,BUNfirst(e2));
	str t1 = (str) e1->H->vheap->base;
	str t2 = (str) e2->H->vheap->base;
	str src, dst = p;

	for (q -= 1000; p3<end; p1++, p2++, p3++) {
		int i = *p3;
		if (dst > q) {
			GDKerror("enum_print: running out of buffer\n");
			break;
		}
		for (src=dst+10; i; i >>= 3)
			*(--src) = ('0' + (i&7));
		*(--src) = '0';
		while (src > dst)
			*(--src) = ' ';
		dst += 10;
		*dst++ = '\t';
		for (src = t2+(h2[*p2<<1]<<GDK_VARSHIFT); *src; src++,dst++)
			*dst = *src;
		*dst++ = '\t';
		for (src = t1+(h1[*p1<<1]<<GDK_VARSHIFT); *src; src++,dst++)
			*dst = *src;
		*dst++ = '\n';
	}
	return dst - p;
}

@}
