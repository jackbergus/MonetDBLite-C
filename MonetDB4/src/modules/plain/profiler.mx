@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2007 CWI.
@' All Rights Reserved.

@f profiler
@t Profiling the kernel
@a M.L. Kersten
@v 1.0
@* Introduction
This document introduces a few primitives to manage the dynamic profiler
facilities added to the kernel interpreter. The performance consequences
are a few extra tests for each interpreter call. A substantial delay will
be incurred when the event records should be produced as well.
To limit the output to a subset of the events you can set a filter on
the kind and function name. A convenient filter set is the following
@T
\begin{verbatim}
setFilter("proc","*");
setFilter("command","*");
setFilter("setop","*");
\end{verbatim}
@-
An alternative route is to collect the information in a few BATs
and dump the accumulated information at a convenient time.
This is supported by the routine startProfiler, which also
sets the default filters.

@* Module Definition
.BUILTIN view_var_name() : BAT[int,str] = view_var_name;
	"Pseudo bat to map variable id to its name."
@m
.MODULE profiler;

.USE streams;

.COMMAND startProfiler(): void = startProfilerCMD;
	"Collect command and proc counts"
.COMMAND startProfiler(Stream output) : int = startProfilerStreamCMD;
	"Start the event profiling stream; output is sent to Stream output"
.COMMAND startProfiler(str fname) : int = startProfilerFileCMD;
	"Start the event profiling stream; output is sent to fname"

.COMMAND stopProfiler() : int = stopProfilerCMD;
	"Stop the event profiling stream"
.COMMAND setFilter(str left, str right) : int = setFilterCmd;
	"Set the profile filter strings"

.COMMAND getProfilerCount(): BAT[str,int] = getProfilerCountCMD;
	"Get a copy of the profiler count summary table"
.COMMAND getProfilerTicks(): BAT[str,lng] = getProfilerTicksCMD;
	"Get a copy of the profiler ticks summary table"
.COMMAND resetProfiler(): void = resetProfilerCMD;
	"Set all counters to zero again"
.END profiler;

@mil
PROC profile() : int {
	return startProfiler(stdout());
}
ADDHELP("startProfiler", "manegold", "Feb 05 2004",
"Start the event profiling stream; output is sent to stdout", "_profiler");

@{
@* Implementation Code
@h
#ifndef _PROFILER_H_
#define _PROFILER_H_

#include "profiler.proto.h"

#endif
@c
#include "monetdb4_config.h"
#include "gdk.h"
#include <stdarg.h>
#include <time.h>
#include "gdk_bbp.h"
#include "monet.h"
#include "monet_context.h"
#include "monet_client.h"
#include "monet_parse.h"
#include "monet_deparse.h"
#include "monet_queue.h"
#include "monet_interpreter.h"
#include "streams.h"
#include "profiler.proto.h"

#ifdef HAVE_SYS_TIMES_H
# include <sys/times.h>
#endif

#define PARAM(x)        (argv+x)
#define RETVAL          (argv)

@+ Variables
The variable information can be turned into a BAT for inspection as well.

int
nouse(
   int          stk,    /* variable context number ("stack"). */
   YYSTREE      lt,     /* syntax tree of parsed MIL. */
   ValPtr        res     /* value record for result. */
){
        Client  c;
	(void) lt; (void) res; /* fool compiler */

        CNTXTclient(stk, &c);
	return GDK_SUCCEED;
}

@+ Modules
@c
int
startProfilerCMD(void)
{
	setProfilerMode(2);
	return GDK_SUCCEED;
}

int
startProfilerStreamCMD(int *res, Stream *output)
{
	startProfiler(*(stream **) output);
	*res = 0;
	return GDK_SUCCEED;
}

int
startProfilerFileCMD(int *res, str fname)
{
	stream *output;

	output = open_wstream(fname);
	if (output == 0) {
		GDKerror("startProfiler: could not create file\n");
		return GDK_FAIL;
	}
	startProfiler(output);
	*res = 0;
	return GDK_SUCCEED;
}

int
stopProfilerCMD(int *res)
{
	stopProfiler();
	*res = 0;
	return GDK_SUCCEED;
}

int
getProfilerCountCMD(BAT **res)
{
	BAT *bn;

	*res = NULL;
	bn = getProfilerCount();
	if (bn) {
		BBPfix(bn->batCacheid);
		*res = bn;
	}
	return GDK_SUCCEED;
}

int
getProfilerTicksCMD(BAT **res)
{
	BAT *bn;

	*res = NULL;
	bn = getProfilerTicks();
	if (bn) {
		BBPfix(bn->batCacheid);
		*res = bn;
	}
	return GDK_SUCCEED;
}

int
resetProfilerCMD(void)
{
	resetProfiler();
	return GDK_SUCCEED;
}

int
setFilterCmd(int *res, str left, str right)
{
	*res = 0;
	return setProfilerFilter(left, right);
}

@-

@T
\begin{tabular}{| l| l|}\hline
maxrss     &the maximum resident set size utilized (in kilobytes).\\
minflt     &the number of page faults serviced without any I/O\\
	 &activity; here I/O activity is avoided by "reclaiming" a\\

	 &activity; here I/O activity is avoided by "reclaiming" a\\
	 &page frame from the list of pages awaiting reallocation.\\
majflt     &the number of page faults serviced that required I/O\\
	 &activity.\\
nswap      &the number of times a process was "swapped" out of main\\
	 &memory\\
inblock    &the number of times the file system had to perform input.\\
oublock    &the number of times the file system had to perform output.\\
nvcsw      &the number of times a context switch resulted due to a\\
	 &process voluntarily giving up the processor before its\\
	 &time slice was completed (usually to await availability of\\
	 &a resource).\\
nivcsw     &the number of times a context switch resulted due to a\\
	 &higher priority process becoming runnable or because the\\
	 &current process exceeded its time slice.\\
\end{tabular}

@
@}
