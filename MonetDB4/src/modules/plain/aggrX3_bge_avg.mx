@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
@' Copyright August 2008-2009 MonetDB B.V.
@' All Rights Reserved.

@f aggrX3_bge_avg
@a S. Manegold
@t Improved & Extended Aggregates Module
@v 1.0

@{
@{

@+ Implementation
These implementations need just one scan and a simple hash-maintained data
structure to compute a group of common aggregates.
@c
#include "monetdb4_config.h"
#include <gdk.h>
#include <gdk_scanselect.h>	/* for type-specific HT_bunfastins_nocheck_noinc(), until they're moved to gdk.mx */
#include "aggrX3.proto.h"
#include "aggrX3.h"

@- Result initialization
/*	init_result
	@1:	tail-type:	bte/sht/int/wrd/lng/flt/dbl / any / void
*/
@include aggrX3_ri.mx

@- Average
@c
/*	aggrX3_avg3
		e-void-head	e-oid-head	e-oid-head	e-oid-head
		void-lookup	array-lookup	scan-lookup	hash-lookup

	@1:	0		1		0		0		use sums-array?
	@2:	0		0		0		1		do BATprepareHash?
	@3:	BUNfndVOID	CHKrange	SCANfndOID	HASHfnd_oid	lookup
	@4:	var		loc		loc		loc		e/bn-head-access

	@5:	"BUNhloc(b,p)"	for  (oid) b-head-type,		b-head access
		"&bhsb; bhsb++" for (void) b-head-type

	@6:	bte / sht / int / wrd / lng / flt / dbl		b/bn-tail-type
	@7:	"loc" for fixsized b/bn-tail-type,		b/bn-tail-access
		"var" for varsized b/bn-tail-type		(only loc used currently)

	@8:	BUNt@7(bn,r)	BUNt@7(bn,r)	&sums[(*(oid*)h)-min]
								*dst: sum in-place or in sums-array ?

	@9:		r-off		(*(oid*)h)-min	index in cnt array
*/
@= aggrX3_avg3
	ALGODEBUG THRprintf(GDKout, "#aggrX3_avg3(@1,@2,@3,@4,@5,@6,@7,@8,@9);\n");
	if (@1 && range > 0) {
		/* create tmp. sums array */
		sums = (dbl*) GDKzalloc(range*sizeof(dbl));
		if (sums == NULL) {
			GDKerror("aggrX3_avg3(@1,@2,@3,@4,@5,@6,@6,@7,@8,@9): sums = GDKzalloc("OIDFMT"*"SZFMT") failed", range, sizeof(dbl));
			BBPreclaim(bn);
			return GDK_FAIL;
		}
	}
	if (@2 && BATprepareHash(bn)) {
		GDKerror("aggrX3_avg3(@1,@2,@3,@4,@5,@6,@6,@7,@8,@9): BATprepareHash(bn) failed");
		if (@1 && sums)
			GDKfree(sums);
		BBPreclaim(bn);
		return GDK_FAIL;
	}
	cnt = (BUN*) GDKzalloc(slots*sizeof(cnt[0]));
	if (cnt == NULL) {
		GDKerror("aggrX3_avg3(@1,@2,@3,@4,@5,@6,@7,@8,@9): cnt = GDKzalloc("OIDFMT"*"SZFMT") failed", slots, sizeof(cnt[0]));
		if (@1 && sums)
			GDKfree(sums);
		BBPreclaim(bn);
		return GDK_FAIL;
	}
	/* scan b & g, adding sums, and incrementing counts */
	base = BUNfirst(g);
	offset = (ssize_t) base - (ssize_t) g->hseqbase;
	end = base + BATcount(g);
	(void) end;		/* keep compilers happy */
	bhsb = b->hseqbase;
	if (b->T->nonil) {
		BATloop(b, p, q) {
			@6 *t = (@6*) BUNt@7(bi,p);
			oid v = *(oid*) @5;

			w = (BUN) (offset + v);
			if (w >= base && w < end) {
				oid *h = (oid*) BUNtail(gi, w);

				@3(r, bni, (oid*)h);
				if (r != BUN_NONE) {
					dbl *dst = (dbl*) @8;
					*dst += *t;
					cnt[@9]++;
				}
			}
		}
	} else {
		BATloop(b, p, q) {
			@6 *t = (@6*) BUNt@7(bi,p);
			oid v = *(oid*) @5;

			w = (BUN) (offset + v);
			if (w >= base && w < end) {
				oid *h = (oid*) BUNtail(gi, w);

				@3(r, bni, (oid*)h);
				if (r != BUN_NONE) {
					dbl *dst = (dbl*) @8;
					if (*dst != dbl_nil) {
						if (*t == @6_nil) {
							*dst = dbl_nil;
						} else {
							*dst += *t;
						}
						cnt[@9]++;
					}
				}
			}
		}
	}
	/* postprocess by dividing sums by counts */
	if (@1) {
	    if (sums) {
		/* sums in sums-array */
		BATloop(bn, p, q) {
			oid h = (*(oid*) BUNh@4(bni,p)) - min;
			dbl *dst = (dbl*) BUNt@7(bni, p);
			if (cnt[h] == 0 || sums[h] == dbl_nil) {
				*dst = dbl_nil;
			} else {
				*dst = sums[h]/cnt[h];
			}
		}
		GDKfree(sums);
	    }
	} else {
		/* sums in-place */
		BUN yy = 0;
		BATloop(bn, p, q) {
			dbl *dst = (dbl*) BUNt@7(bni, p);
			if (cnt[yy] == 0) {
				*dst = dbl_nil;
			} else if (*dst != dbl_nil) {
				*dst /= cnt[yy];
			}
			yy++;
		}

	}
	if (cnt)
		GDKfree(cnt);
@c
/*	arithavg3
	@6:	bte / sht / int / wrd / lng / flt / dbl	b/bn-tail-type
	@7:	"loc" for fixsized b/bn-tail-type,	b/bn-tail-access
		"var" for varsized b/bn-tail-type	(only loc used currently)
	@9:	result type
*/
@= arithavg3
int
CMDaggrX3_avg3_@1(BAT **ret, BAT *b, BAT *g, BAT *e)
{
	BAT *bn;
	BATiter bni, bi = bat_iterator(b), gi = bat_iterator(g);
	BUN off;
	BUN *cnt = NULL;
	oid range;
	oid min, max;
	dbl zero = (dbl) 0, *sums = NULL;
	BUN slots;
	BUN p, q, r;
	oid bhsb;
	BUN base, end, w;
	ssize_t offset;

	ALGODEBUG THRprintf(GDKout, "#CMDaggrX3_avg3_@1[@2](b=%s,g=%s,e=%s);\n",
		BATgetId(b),BATgetId(g),BATgetId(e));
/*	ERRORcheck((BATcount(b)!=BATcount(g)), "CMDaggrX3_avg3_@1: BATs b & g must be of equal size.\n");	*/
	ERRORcheck((g->htype == TYPE_void) && (g->hseqbase == oid_nil) && (BATcount(g) > 0), "CMDaggrX3_avg3_@1: head of BAT g must not be nil.\n");

	if((g->hseqbase == oid_nil) || (!BAThdense(g)) || (!(BAThordered(b)&1)) || (!g->hkey)) {
		BAT *gb = BATjoin(BATmirror(g),b,BUN_NONE);
		int rtrn = CMDaggrX3_avg_@1(ret, gb, e);
		BBPunfix(gb->batCacheid);
		return rtrn;
	}

	bn = BATnew(e->htype, TYPE_dbl, BATcount(e));
	if( bn == NULL) {
		GDKerror("CMDaggrX3_avg3_@1(): BATnew() failed");
		return GDK_FAIL;
	}
	bni = bat_iterator(bn);
	off = BUNfirst(bn);

	/* init: set all sums & counts to zero and calculate min/max oid */
	@:init_result(dbl)@
	range = max - min + 1;

	/* scan b & g, calculate sums & counts, derive averages */
	slots = BATcount(e);
	if (slots == 0) {
		/* empty extend => empty result */
		*ret = bn;
		return GDK_SUCCEED;
	}
	if (e->htype == TYPE_void) {
		/* void lookup */
		if (b->htype == TYPE_void) {
			@:aggrX3_avg3(0,0,BUNfndVOID,var,&bhsb;bhsb++,@1,@2,BUNt@2(bni,r),r-off)@
		} else {
			@:aggrX3_avg3(0,0,BUNfndVOID,var,BUNhloc(bi,p),@1,@2,BUNt@2(bni,r),r-off)@
		}
	/* e->htype == TYPE_oid */
	} else if (range <= SMALL_AGGR_MAX) {
		/* array lookup */
		slots = range;
		if (b->htype == TYPE_void) {
			@:aggrX3_avg3(1,0,CHKrange,loc,&bhsb;bhsb++,@1,@2,&sums[(*(oid*)h)-min],(*(oid*)h)-min)@
		} else {
			@:aggrX3_avg3(1,0,CHKrange,loc,BUNhloc(bi,p),@1,@2,&sums[(*(oid*)h)-min],(*(oid*)h)-min)@
		}
	} else if (BATcount(e) <= SCAN_AGGR_MAX) {
		/* scan lookup */
		SCAN_aggr_init;
		if (b->htype == TYPE_void) {
			@:aggrX3_avg3(0,0,SCANfndOID,loc,&bhsb;bhsb++,@1,@2,BUNt@2(bni,r),r-off)@
		} else {
			@:aggrX3_avg3(0,0,SCANfndOID,loc,BUNhloc(bi,p),@1,@2,BUNt@2(bni,r),r-off)@
		}
	} else {
		/* hash lookup */
		if (b->htype == TYPE_void) {
			@:aggrX3_avg3(0,1,HASHfnd_oid,loc,&bhsb;bhsb++,@1,@2,BUNt@2(bni,r),r-off)@
		} else {
			@:aggrX3_avg3(0,1,HASHfnd_oid,loc,BUNhloc(bi,p),@1,@2,BUNt@2(bni,r),r-off)@
		}
	}

	*ret = bn;
	return GDK_SUCCEED;
}
@c
@:arithavg3(bte,loc)@
@:arithavg3(sht,loc)@
@:arithavg3(int,loc)@
@:arithavg3(wrd,loc)@
@:arithavg3(lng,loc)@
@:arithavg3(flt,loc)@
@:arithavg3(dbl,loc)@

@}
@}
