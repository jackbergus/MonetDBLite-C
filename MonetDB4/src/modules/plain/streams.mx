@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2007 CWI.
@' All Rights Reserved.

@f streams
@a Niels Nes
@* A simple interface to IO streams
All file IO is funneled through the stream library, which
guarantees cross-platform capabilities.
Several protocols are provided, e.g. it can be used to 
open 'non compressed, gzipped, bzipped' data files. 
It encapsulates the corresponding library managed in
.../stream.

@m
.MODULE streams;

    .ATOM Stream = ptr;
    .END;

.COMMAND stdin() : Stream = io_stdin;
	"return the input stream to the database client"
.COMMAND stderr() : Stream = io_stderr;
	"return the error stream for the database console"
.COMMAND stdout() : Stream = io_stdout;
	"return the output stream for the database client"

.COMMAND open_rstream( str filename ) : Stream = stream_open_rstream;
	"open a file stream for reading"
.COMMAND open_wstream( str filename ) : Stream = stream_open_wstream;
	"open a file stream for writing"
.COMMAND open_rastream( str filename ) : Stream = stream_open_rastream;
	"open ascii file stream for reading"
.COMMAND open_wastream( str filename ) : Stream = stream_open_wastream;
	"open ascii file stream for writing"

.COMMAND stream_rstream( Stream s ) : Stream = stream_stream_rstream;
	"convert an ascii stream to binary"
.COMMAND stream_wstream( Stream s ) : Stream = stream_stream_wstream;
	"convert an ascii stream to binary"

.COMMAND socket_rstream( int socket, str name ) : Stream =
	stream_socket_rstream; "open a socket stream for reading"
.COMMAND socket_wstream( int socket, str name ) : Stream =
	stream_socket_wstream; "open a socket stream for writing"
.COMMAND socket_rastream( int socket, str name ) : Stream =
	stream_socket_rastream; "open ascii socket stream for reading"
.COMMAND socket_wastream( int socket, str name ) : Stream =
	stream_socket_wastream; "open ascii socket stream for writing"

.COMMAND block_stream( Stream s ) : Stream =
	open_block_stream; "open a block based stream"

.COMMAND stream_write( Stream s, str data ) = stream_write_string;
	"write data on the stream"

.COMMAND stream_writeInt( Stream s, int data ) = stream_writeInt_wrap;
	"write an integer on the stream"

.COMMAND stream_readInt( Stream s ) : int = stream_readInt_wrap;
	"read an integer from the stream"

.COMMAND stream_writeLng( Stream s, lng data ) = stream_writeLng_wrap;
	"write a long integer on the stream"

.COMMAND stream_readLng( Stream s ) : lng = stream_readLng_wrap;
	"read a long integer from the stream"

.COMMAND stream_read( Stream s ) : str = stream_read_string;
	"read data from the stream"

.COMMAND stream_flush( Stream s ) = stream_flush_stream;
	"flush the stream"

.COMMAND stream_close( Stream s ) = stream_close_stream;
	"close and destroy the stream s"

    .ATOM Bstream = ptr;
    .END;

.COMMAND bstream_create( Stream s, int bufsize ) : Bstream = bstream_create_wrap;
	"create a buffered stream"

.COMMAND bstream_destroy( Bstream s ) = bstream_destroy_wrap;
	"destroy bstream"

.COMMAND bstream_read( Bstream s, int size ) : int = bstream_read_wrap;
	"read atleast size bytes into the buffer of s"

    .COMMAND fprintf( Stream filep, str format, ... ) = io_fprintf;
	"See: man fprintf"

    .COMMAND ftable( Stream filep, ...BAT[any::1,any]... ) = io_ftable_default;
	"Print an n-ary table to a file."

    .COMMAND ftable( Stream filep, int orderspec, ...BAT[any::1,any]... ) = io_ftable;
	"Print an n-ary table to a file, using order of BAT [1..argc]."

    .COMMAND fwrite( Stream filep, str buf, int nbytes ) = io_fwrite;
	"See: man fwrite"

    .COMMAND fgets( Stream filep ): str = io_fgets;
	"See: man fgets"

    .COMMAND fgetc( Stream filep ): int = io_fgetc;
	"See: man fgetc"

.END streams;

@mil

	# backward compatibility with old io module (alas: seek has gone..)
	const EOF := -1;
	proc fputs(str buf, Stream s):void		{stream_write(s, buf);}
	proc fclose(Stream s):void 			{stream_close(s);}
	proc fflush(Stream s):void 			{stream_flush(s);}
	proc fopen(str filename, str mode) : Stream {
		if (mode.startsWith("r")) {
			return open_rastream(filename);
		} else if (mode.startsWith("w")) {
			return open_wastream(filename);
		}
		return Stream(ptr(0));
	}
@-
@{
@-
The implementation follows and should be self-documenting
@h
#ifndef _STREAMS_H_
#define _STREAMS_H_

#include <gdk.h>
#include <blob.h>

typedef ptr Stream;
typedef ptr Bstream;

#include "streams.proto.h"

#endif /*_STREAMS_H_*/
@c
#include "monetdb4_config.h"
#include <monet.h>
#include "streams.h"
#include <stdio.h>

int
io_stdin(Stream *ret)
{
	*(stream **) ret = GDKin;
	return GDK_SUCCEED;
}

int
io_stdout(Stream *ret)
{
	*(stream **) ret = GDKout;
	return GDK_SUCCEED;
}

int
io_stderr(Stream *ret)
{
	*(stream **) ret = GDKerr;
	return GDK_SUCCEED;
}

@= open_stream
int
stream_open_@1(Stream *S, str filename)
{
	stream *s;

	if ((s = open_@1( filename )) == NULL || stream_errnr(s)) {
		if (s)
			stream_destroy(s);
		GDKerror("stream_open: could not open file '%s'\n", filename);
		return GDK_FAIL;
	} else {
		*(stream**)S = s;
		return GDK_SUCCEED;
	}
}
@c
@:open_stream(rstream)@
@:open_stream(wstream)@
@:open_stream(rastream)@
@:open_stream(wastream)@

@= stream_stream
int
stream_stream_@1(Stream *Sout, Stream *Sin)
{
	*(stream**)Sout = stream_@1(*(stream**)Sin);
	return GDK_SUCCEED;
}
@c
@:stream_stream(rstream)@
@:stream_stream(wstream)@

@= open_socket
int
stream_socket_@1(Stream *S, int *sockp, str name)
{
	stream *s;

	if ((s = socket_@1( *sockp, name )) == NULL || stream_errnr(s)) {
		if (s)
			stream_destroy(s);
		GDKerror("Could not open socket %s\n", name );
		return GDK_FAIL;
	} else {
		*(stream**)S = s;
		return GDK_SUCCEED;
	}
}
@c
@:open_socket(rstream)@
@:open_socket(wstream)@
@:open_socket(rastream)@
@:open_socket(wastream)@

@c
int
stream_write_string(Stream *S, str data)
{
	stream *s = *(stream **) S;

	return stream_write(s, data, 1, strlen(data)) < 0 ? GDK_FAIL : GDK_SUCCEED;
}

int
stream_writeInt_wrap(Stream *S, int *data)
{
	stream *s = *(stream **) S;

	return stream_writeInt(s, *data) ? GDK_SUCCEED : GDK_FAIL;
}

int
stream_readInt_wrap(int *data, Stream *S)
{
	stream *s = *(stream **) S;

	return stream_readInt(s, data) ? GDK_SUCCEED : GDK_FAIL;
}

int
stream_writeLng_wrap(Stream *S, long long *data)
{
	stream *s = *(stream **) S;

	return stream_writeLng(s, *data) ? GDK_SUCCEED : GDK_FAIL;
}

int
stream_readLng_wrap(long long *data, Stream *S)
{
	stream *s = *(stream **) S;

	return stream_readLng(s, data) ? GDK_SUCCEED : GDK_FAIL;
}

#define CHUNK (64*1024)
int
stream_read_string(str *res, Stream *S)
{
	stream *s = *(stream **) S;
	ssize_t len = 0;
	size_t size = CHUNK +1;
	char *buf = GDKmalloc(size), *start = buf;

	while ((len = stream_read(s, start, 1, CHUNK)) > 0) {
		size += len;
		buf = GDKrealloc(buf, size);
		start = buf + size - CHUNK -1;

		*start = '\0';
	}
	if (len < 0)
		return GDK_FAIL;
	start += len;
	*start = '\0';
	*res = buf;
	return GDK_SUCCEED;
}

int
stream_flush_stream(Stream *S)
{
	stream *s = *(stream **) S;

	if (stream_flush(s))
		return GDK_FAIL;
	return GDK_SUCCEED;
}

int
stream_close_stream(Stream *S)
{
	close_stream(*(stream **) S);
	return GDK_SUCCEED;
}

int
open_block_stream(Stream *S, Stream *is)
{
	if ((*(stream **) S = block_stream(*(stream **) is)) == NULL) {
		return GDK_FAIL;
	} else {
		return GDK_SUCCEED;
	}
}

int
bstream_create_wrap(Bstream *BS, Stream *S, int *bufsize)
{
	if ((*(bstream **) BS = bstream_create(*(stream **) S, (size_t) * bufsize)) == NULL) {
		return GDK_FAIL;
	} else {
		return GDK_SUCCEED;
	}
}

int
bstream_destroy_wrap(Bstream *BS)
{
	bstream_destroy(*(bstream **) BS);
	return GDK_SUCCEED;
}

int
bstream_read_wrap(int *res, Bstream *BS, int *size)
{
	*res = (int) bstream_read(*(bstream **) BS, (size_t) * size);
	return GDK_SUCCEED;
}

int
io_fprintf(Stream *filepp, str format, ...)
{
	stream *fp = *(stream **) filepp;
	va_list ap;
	int ret;
	str s;

	va_start(ap, format);
	ret = monet_sprintf(&s, format, ap);
	va_end(ap);
	if (ret == GDK_FAIL) {
		return GDK_FAIL;
	}
	if (stream_write(fp, s, ret, strlen(s)) <= 0) {
		GDKsyserror("io_fprintf():");
		GDKfree(s);
		return GDK_FAIL;
	}
	GDKfree(s);
	return GDK_SUCCEED;
}

#if 0
int
io_fprint(Stream *filepp, ...)
{
	stream *fp = *(stream **) filepp;
	va_list ap;
	ptr val;
	int type;

	va_start(ap, filepp);

	val = va_arg(ap, ptr);

	if (val) {
		type = va_arg(ap, int);

		if (ATOMstorage(type) != TYPE_str && stream_printf(fp, "%s(\"", ATOMname(type)) < 0)
			return GDK_FAIL;
		ATOMprint(type, val, fp);
		if (stream_errnr(fp))
			return GDK_FAIL;
		if (ATOMstorage(type) != TYPE_str && stream_printf(fp, "\")") < 0)
			return GDK_FAIL;
		val = va_arg(ap, ptr);
		while (val) {
			type = va_arg(ap, int);

			if (ATOMstorage(type) != TYPE_str) {
				if (stream_printf(fp, ", %s(\"", ATOMname(type)) < 0)
					return GDK_FAIL;
			} else {
				if (stream_printf(fp, ", ") < 0)
					return GDK_FAIL;
			}
			ATOMprint(type, val, fp);
			if (stream_errnr(fp))
				return GDK_FAIL;
			if (ATOMstorage(type) != TYPE_str && stream_printf(fp, "\")") < 0)
				return GDK_FAIL;
			val = va_arg(ap, ptr);
		}
	}
	va_end(ap);
	return GDK_SUCCEED;
}
#endif

int
io_ftable(Stream *filepp, int *orderspec, ...)
{
	stream *fp = *(stream **) filepp;
	BAT *piv[MAXPARAMS];
	int argc = 0;
	va_list ap;

	va_start(ap, orderspec);
	do {
		piv[argc] = va_arg(ap, BAT *);
	} while (piv[argc++]);
	va_end(ap);
	BATmultiprintf(fp, argc, piv, FALSE, *orderspec, 1);
	return GDK_SUCCEED;
}

int
io_ftable_default(Stream *filepp, ...)
{
	stream *fp = *(stream **) filepp;
	BAT *piv[MAXPARAMS];
	int argc = 0;
	va_list ap;

	va_start(ap, filepp);
	do {
		piv[argc] = va_arg(ap, BAT *);
	} while (piv[argc++]);
	va_end(ap);
	BATmultiprintf(fp, argc, piv, FALSE, 0, 1);
	return GDK_SUCCEED;
}

int
io_fgetc(int *res, Stream *S)
{
	stream *s = *(stream **) S;
	char c;

	if (stream_read(s, &c, 1, 1) == 1) {
		*res = c;
	} else {
		*res = -1;	/* EOF */
	}
	return stream_errnr(s) ? GDK_FAIL : GDK_SUCCEED;
}

int
io_fgets(str *res, Stream *S)
{
	stream *s = *(stream **) S;
	size_t size, len = 123;
	char *buf = (char *) GDKmalloc(1 + len);

	if (buf == NULL)
		return GDK_FAIL;
	for (size = 0; stream_read(s, buf + size, 1, 1) > 0; size++) {
		if (buf[size] == 0 || buf[size] == '\n')
			break;
		if (size + 1 == len) {
			buf = (char *) GDKrealloc(buf, 1 + (len *= 2));
			if (buf == NULL)
				return GDK_FAIL;
		}
	}
	buf[size] = 0;
	*res = buf;
	return stream_errnr(s) ? GDK_FAIL : GDK_SUCCEED;
}

#if 0
int
io_fputc(int *c, stream *S)
{
	stream *s = *(stream **) S;
	char data[2];

	data[0] = (char) *c;
	data[1] = 0;
	return stream_write(s, data, 1, 1) == 1 ? GDK_SUCCEED : GDK_FAIL;
}
#endif

int
io_fwrite(Stream *S, str buf, int *nbytes)
{
	stream *s = *(stream **) S;

	return stream_write(s, buf, 1, *nbytes) == *nbytes ? GDK_SUCCEED : GDK_FAIL;
}

@}
