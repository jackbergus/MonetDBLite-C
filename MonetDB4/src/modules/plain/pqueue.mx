@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
@' Copyright August 2008-2010 MonetDB B.V.
@' All Rights Reserved.

@f pqueue
@t implementation of a priority queue -pqueue-
@a Nikos Mamoulis, Niels Nes
@v 2.0
@* Introduction

This module includes functions for accessing and updating a pqueue.
A pqueue is an (oid,any) bat. The tail is used as a comparison key.
The first element of the pqueue is the smallest one in a min-pqueue
or the largest one in a max-pqueue. 
Each element is larger than (smaller than) or equal to 
its parent which is defined by (position/2) if position is odd or 
(position-1)/2 if position is even (positions are from 0 to n-1).
The head of the bat is used to keep track of the object-ids which are
organized in the heap with respect to their values (tail column).

@* Module Definition 
@m
.MODULE pqueue;

  .COMMAND pqueue_init(BAT[void,any::1] a, wrd maxsize): BAT[oid,any::1] = 
	pqueue_init;
  "Creates an initially empty pqueue of bat a's tailtype with maximum size maxsize"

@= mel_minmax
  .COMMAND pqueue_enqueue_@2(BAT[oid,@1] h, oid id, @1 value) = 
	pqueue_enqueue_@1@2;
  "Inserts element (oid,@1) in the @2-pqueue"

  .COMMAND pqueue_topreplace_@2(BAT[oid,@1] h, oid id, @1 value) = 
	pqueue_topreplace_@1@2;
  "Replaces top element with input and updates @2-pqueue"

  .COMMAND pqueue_dequeue_@2(BAT[oid,@1] h) = pqueue_dequeue_@1@2;
  "Removes top element of the @2-pqueue and updates it"

  .COMMAND pqueue_topn_@2(BAT[oid,@1] t, int n) : BAT[oid,@1] = pqueue_topn_@1@2;
  "Return the topn elements of the bat t using a @2-pqueue"

  .COMMAND pqueue_topn_@2(BAT[void,@1] t, int n) : BAT[oid,@1] = pqueue_topn_void@1@2;
  "Return the topn elements of the bat t using a @2-pqueue"

@= mel_pqueue
  @:mel_minmax(@1,min)@
  @:mel_minmax(@1,max)@
@m
@:mel_pqueue(any)@
@:mel_pqueue(chr)@
@:mel_pqueue(bte)@
@:mel_pqueue(sht)@
@:mel_pqueue(int)@
@:mel_pqueue(oid)@
@:mel_pqueue(wrd)@
@:mel_pqueue(ptr)@
@:mel_pqueue(lng)@
@:mel_pqueue(flt)@
@:mel_pqueue(dbl)@
@m
.END pqueue;

@{
@* Implementation
@c
#include "monetdb4_config.h"
#include "pqueue.proto.h"
  
/*returns the parent of a pqueue position*/
static INLINE BUN parent(BUN posel)
{
  if (posel%2) /*odd*/
	return posel/2;
  else
	return (posel-1)/2;
}

/*initialize pqueue*/
static void
do_pqueue_init(BAT **h, BAT *b, BUN maxsize)
{
	*h = BATnew(TYPE_oid, b->ttype, maxsize);
        if (*h)
                (*h)->batDirty |= 2;
}

int 
pqueue_init(BAT **h, BAT *b, wrd *maxsize)
{
	do_pqueue_init(h, b, (BUN) *maxsize);
  	return GDK_SUCCEED;
}

#define ht_swap(tpe,cur,ins) {					\
	  oid htmp = *(oid*)BUNhloc(hi,cur); 			\
	  tpe ttmp = *(tpe*)BUNtloc(hi,cur);			\
	  *(oid*)BUNhloc(hi,cur) = *(oid*)BUNhloc(hi,ins);	\
	  *(tpe*)BUNtloc(hi,cur) = *(tpe*)BUNtloc(hi,ins);	\
	  *(oid*)BUNhloc(hi,ins) = htmp; 			\
	  *(tpe*)BUNtloc(hi,ins) = ttmp;			\
}

#define any_swap(cur,ins,ts) {					\
	  unsigned int i;					\
	  char ch;						\
          /* only swap the locations (ie var_t's) */		\
	  char *c1 = BUNtloc(hi,cur), *c2 = BUNtloc(hi,ins);	\
	  oid htmp = *(oid*)BUNhloc(hi,cur); 			\
	  *(oid*)BUNhloc(hi,cur) = *(oid*)BUNhloc(hi,ins);	\
	  *(oid*)BUNhloc(hi,ins) = htmp; 			\
	  for(i=0;i<ts;i++) {					\
		ch= c1[i]; c1[i]=c2[i]; c2[i]=ch;		\
	  }							\
}

@= pqueueimpl_minmax
/*enqueue an element*/
int pqueue_enqueue_@1@2(BAT *h,
		 oid *idx, 
		 @3 *el)
{
  BATiter hi = bat_iterator(h);
  BUN ins,cur;

  BUN hbase = BUNfirst(h);
  BUN p, posel = BATcount(h); /*last position*/
 
  BUNins(h, (ptr)idx, (ptr)el, FALSE);
  ins = hbase+posel;
  
  while(posel >0) {
	p=parent(posel);
	cur = hbase+p;
	if (*(@3 *)BUNtloc(hi,ins) @4 *(@3 *)BUNtloc(hi,cur)) {
	  /* swap element with its parent */
	  ht_swap(@3,cur,ins);
	  ins = cur;
	  posel = parent(posel);
	}
	else break;
  }
  h->hsorted = h->tsorted = FALSE;
  
  return GDK_SUCCEED;
}

/* moves down the root element */
/* used by dequeue (see below) */
static int pqueue_movedowntop_@1@2(BAT *h)
{
  BATiter hi = bat_iterator(h);
  BUN swp, cur, hbase = BUNfirst(h);
  BUN swap, num_elems = BATcount(h);
  BUN posel = 0;

  cur = hbase;
  
  /*while posel is not a leaf and pqueue[posel].tail > any of childen*/
  while (posel*2+1 < num_elems) { /*there exists a left son*/
	if (posel*2+2< num_elems) { /*there exists a right son*/
	  if (*(@3 *)BUNtloc(hi,hbase+(posel*2+1)) @4
	      *(@3 *)BUNtloc(hi,hbase+(posel*2+2)))
		swap = posel*2+1;
	  else
		swap = posel*2+2;
	} else
		swap = posel*2+1;

	swp = hbase+swap;

	if (*(@3 *)BUNtloc(hi,swp) @4 *(@3 *)BUNtloc(hi,cur)) {
	  /*swap elements*/
	  ht_swap(@3,cur,swp);
	  cur = swp;
	  posel = swap;
	} else 
		break;
  }

  return GDK_SUCCEED;
}

/* removes the root element, puts the last element as root and moves it down */
int pqueue_dequeue_@1@2(BAT *h)
{
  BATiter hi = bat_iterator(h);
  BUN hbase;
  BUN num_elements;

  if (!(num_elements = BATcount(h))) {
    GDKerror("pqueue_dequeue: Cannot dequeue from empty queue\n");
    return GDK_FAIL;
  }

  hbase = BUNfirst(h);

  /* copy last element to the first position*/
  ht_swap(@1,hbase, hbase+(num_elements-1));

  /*delete last element*/
  BUNdelete(h, hbase+(num_elements-1), FALSE);

  pqueue_movedowntop_@1@2(h);
  return GDK_SUCCEED;
}

/* replaces the top element with the input if it is larger (smaller) and
 * updates the heap */
int pqueue_topreplace_@1@2(BAT *h,
		 oid *idx,
		 @3 *el)
{
  BATiter hi = bat_iterator(h);
  BUN hbase;

  hbase = BUNfirst(h);

  if (*(@3 *)BUNtloc(hi,hbase) @4 *el) {
	*(oid*)BUNhloc(hi,hbase) = *idx;
	*(@3*)BUNtloc(hi,hbase) = *el;
	pqueue_movedowntop_@1@2(h);
  }
  
  return GDK_SUCCEED;
}

/* TopN, based on @2-pqueue */

int pqueue_topn_void@1@2(BAT **H, BAT *t, int *N)
{
  BATiter ti = bat_iterator(t);
  @1 *v;
  BUN i, n = BATcount(t);
  oid idx = t->hseqbase;

  if ((BUN) *N < n)
	  n = (BUN) *N;
  do_pqueue_init(H,t,n);
  v = (@1*)BUNtail(ti,BUNfirst(t));

  for(i=0; i<n; i++, idx++, v++) {
	pqueue_enqueue_@1@2(*H, &idx, v); 
  }
  n = BATcount(t);
  for(; i<n; i++, idx++, v++) {
	pqueue_topreplace_@1@2(*H, &idx, v); 
  }
  return GDK_SUCCEED;
}

int pqueue_topn_@1@2(BAT **H, BAT *t, int *N)
{
  BATiter ti = bat_iterator(t);
  BUN i, n = BATcount(t);
  BUN p = BUNfirst(t);

  if ((BUN) *N < n)
	  n = (BUN) *N;
  do_pqueue_init(H,t,n);

  for(i=0; i<n; i++, p++) {
	pqueue_enqueue_@1@2(*H, (oid*)BUNhloc(ti,p), (@1*)BUNtloc(ti,p)); 
  }
  n = BATcount(t);
  for(; i<n; i++, p++) {
	pqueue_topreplace_@1@2(*H, (oid*)BUNhloc(ti,p), (@1*)BUNtloc(ti,p)); 
  }
  return GDK_SUCCEED;
}
@c
@= pqueueimpl
  @:pqueueimpl_minmax(@1,min,@1,<)@
  @:pqueueimpl_minmax(@1,max,@1,>)@
@c
@:pqueueimpl(chr)@
@:pqueueimpl(bte)@
@:pqueueimpl(sht)@
@:pqueueimpl(int)@
@:pqueueimpl(oid)@
@:pqueueimpl(wrd)@
@:pqueueimpl(ptr)@
@:pqueueimpl(lng)@
@:pqueueimpl(flt)@
@:pqueueimpl(dbl)@
@}

/* The fallback case, non optimized */

@= pqueueimpl_any
/*enqueue an element*/
int pqueue_enqueue_any@1(BAT *h, oid *idx, ptr el, int tpe)
{
  BATiter hi = bat_iterator(h);
  BUN hbase;
  BUN ins,cur;
  BUN p, posel;
  unsigned short ts = Tsize(h);

  hbase = BUNfirst(h);

  posel = BATcount(h); /*last position*/
  BUNins(h, (ptr)idx, (ptr)el, FALSE);
  ins = hbase+posel;
  
  while(posel >0) {
	p=parent(posel);
	cur = hbase+p;
	if (atom_CMP(BUNtail(hi,ins), BUNtail(hi,cur), tpe) @2 0 ) {
	  /* swap element with its parent */
	  any_swap(cur,ins,ts);
	  ins = cur;
	  posel = parent(posel);
	}
	else break;
  }
  h->hsorted = h->tsorted = FALSE;
  
  return GDK_SUCCEED;
}

/* moves down the root element */
/* used by dequeue (see below) */
static int pqueue_movedowntop_any@1(BAT *h)
{
  BATiter hi = bat_iterator(h);
  BUN hbase;
  BUN swp,cur;
  int tpe = BATttype(h);
  BUN swap, num_elems;
  BUN posel;
  unsigned short ts = Tsize(h);

  hbase = BUNfirst(h);

  cur = hbase;
  num_elems = BATcount(h);
  posel = 0;
  
  /*while posel is not a leaf and pqueue[posel].tail > any of childen*/
  while (posel*2+1 < num_elems) { /*there exists a left son*/
	if (posel*2+2< num_elems) { /*there exists a right son*/
	  if (atom_CMP(
		BUNtail(hi,hbase+(posel*2+1)),
		BUNtail(hi,hbase+(posel*2+2)), tpe) @2 0 ) {
		swap = posel*2+1;
	  } else {
		swap = posel*2+2;
	  }
	} else
		swap = posel*2+1;

	swp = hbase+swap;

	if (atom_CMP( BUNtail(hi,swp), BUNtail(hi,cur), tpe) @2 0 ) {
		/*swap elements*/
		any_swap(cur,swp,ts);
	  	cur = swp;
	  	posel = swap;
	} else 
		break;
  }
  h->hsorted = h->tsorted = FALSE;

  return GDK_SUCCEED;
}

/* removes the root element, puts the last element as root and moves it down */
int pqueue_dequeue_any@1(BAT *h)
{
  BATiter hi = bat_iterator(h);
  BUN hbase;
  BUN num_elements;
  unsigned short ts = Tsize(h);

  if (!(num_elements = BATcount(h))) {
	GDKerror("pqueue_dequeue: Cannot dequeue from empty queue\n");
	return GDK_FAIL;
  }

  hbase = BUNfirst(h);

  /* copy last element to the first position*/
  any_swap(hbase, hbase+(num_elements-1), ts);

  /*delete last element*/
  BUNdelete(h, hbase+(num_elements-1), FALSE);

  pqueue_movedowntop_any@1(h);
  return GDK_SUCCEED;
}

/* replaces the top element with the input if it is larger (smaller) and
 * updates the heap */
int pqueue_topreplace_any@1(BAT *h, oid *idx, ptr el, int tpe)
{
  BATiter hi = bat_iterator(h);
  BUN hbase = BUNfirst(h);

  if (atom_CMP(BUNtail(hi,hbase), el, tpe) @2 0) {
	BUNinplace(h, hbase, idx, el, 0);
	* (oid *) BUNhloc(hi, hbase) = *idx;
	pqueue_movedowntop_any@1(h);
    	h->hsorted = h->tsorted = FALSE;
  }
  
  return GDK_SUCCEED;
}

int pqueue_topn_voidany@1(BAT **H, BAT *t, int *N)
{
  BATiter ti = bat_iterator(t);
  BUN i, n = BATcount(t);
  oid idx = t->hseqbase;
  BUN p = BUNfirst(t);
  int tpe = BATttype(t);

  if ((BUN) *N < n)
   	n = (BUN) *N;
  do_pqueue_init(H,t,n);

  for(i=0; i<n; i++, idx++, p++) {
	pqueue_enqueue_any@1(*H, &idx, BUNtail(ti,p), tpe); 
  }
  n = BATcount(t);
  for(; i<n; i++, idx++, p++) {
	pqueue_topreplace_any@1(*H, &idx, BUNtail(ti,p), tpe); 
  }
  return GDK_SUCCEED;
}

int pqueue_topn_any@1(BAT **H, BAT *t, int *N)
{
  BATiter ti = bat_iterator(t);
  BUN i, n = BATcount(t);
  BUN p = BUNfirst(t);
  int tpe = BATttype(t);

  if ((BUN) *N < n)
   	n = (BUN) *N;
  do_pqueue_init(H,t,n);

  for(i=0; i<n; i++, p++) {
	pqueue_enqueue_any@1(*H, (oid*)BUNhloc(ti,p), BUNtail(ti,p), tpe); 
  }
  n = BATcount(t);
  for(; i<n; i++, p++) {
	pqueue_topreplace_any@1(*H, (oid*)BUNhloc(ti,p), BUNtail(ti,p), tpe); 
  }
  return GDK_SUCCEED;
}

@c
@:pqueueimpl_any(min,<)@
@:pqueueimpl_any(max,>)@

@mil

proc pqueue_init(BAT[void,any::1] a, int maxsize): BAT[oid,any::1] {
	return pqueue_init(a, wrd(maxsize));
}

proc pqueue_peek( BAT[oid,any] h ) : any {
	return h.fetch(0);
}

proc pqueue_topn( BAT[oid,any] t, int n, int direction ) : BAT[oid,any] {
	if (direction > 0) {
		return pqueue_topn_max(t,n);
	} else {
		return pqueue_topn_min(t,n);
	}
}

PROC test_pqueue_str() : void {
	#
	# Simple example of using the heap
	# A min-heap is used to find the k-largest elements 
	# in an (oid,str) BAT with m random values.
	#

	module("alarm");

	# table t has m elements
	var m := 100;
	var t := new(void,str,m);
	t.seqbase(oid(1));

	# We want the k largest elements of t
	var k := 10; 

	var h := pqueue_init(t, k); 

	srand(time());

	var i := 1;
	while (i<=k) {
		var val := str(rand()%1000);
		t.insert(oid(i), val);
		pqueue_enqueue_min(h, oid(i), val);
		i :+= 1;
	}
	while (i<=m) {
		var val := str(rand()%1000);
		t.insert(oid(i), val);
		pqueue_topreplace_min(h, oid(i), val);
		i :+= 1;
	}

	var s := sort_rev(t.reverse()).reverse().slice(0,k); # topn the old way
	var tpn := pqueue_topn(t,k,0);
	print([=](s,h));
	print([=](s,tpn));
}
PROC test_pqueue() : void {
	#
	# Simple example of using the heap
	# A min-heap is used to find the k-largest elements 
	# in an (oid,int) BAT with m random values.
	#

	module("alarm");

	# table t has m elements
	var m := 100;
	var t := new(void,int,m);
	t.seqbase(oid(1));

	# We want the k largest elements of t
	var k := 10; 

	var h := pqueue_init(t, k); 

	srand(time());

	var i := 1;
	while (i<=k) {
		var val := int(rand()%1000);
		t.insert(oid(i), val);
		pqueue_enqueue_min(h, oid(i), val);
		i :+= 1;
	}
	while (i<=m) {
		var val := int(rand()%1000);
		t.insert(oid(i), val);
		pqueue_topreplace_min(h, oid(i), val);
		i :+= 1;
	}

	var s := sort_rev(t.reverse()).reverse().slice(0,k); # topn the old way
	var tpn := pqueue_topn(t,k,0);
	print([=](s,h));
	print([=](s,tpn));
}
