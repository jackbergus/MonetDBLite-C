@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2007 CWI.
@' All Rights Reserved.

@f monettime
@t New Temporal Module
@a Peter Boncz, Martin van Dinther
@v 1.0

@* Introduction
@T
The goal of this module is to provide adequate functionality for storing
and manipulated time-related data. The minimum requirement is that data
can easily be imported from all common commercial RDBMS products.

This module supersedes the 'temporal' module that has a number of
conceptual problems and hard-to-solve bugs that stem from these problems.

The starting point of this module are SQL 92 and the ODBC time-related data types.
Also, some functionalities have been imported from the time classes of the Java
standard library.
@T
This module introduces four basic types and operations on them:
\begin{description}
\item[date] a date in the Gregorian calendar, e.g. 1999-JAN-31

\item[daytime] a time of day to the detail of milliseconds, e.g. 23:59:59:000

\item[timestamp] a combination of date and time, indicating an exact point in
time (GMT). GMT is the time at the Greenwich meridian without a daylight savings
time (DST) regime. Absence of DST means that hours are consecutive (no jumps) which
makes it easy to perform time difference calculations.
\item[timezone] the local time is often different from GMT (even at Greenwich in
summer, as the UK also has DST). Therefore, whenever a timestamp is composed
from a local daytime and date, a timezone should be specified in order to
translate the local daytime to GMT (and vice versa if a timestamp is to
be decomposed in a local date and daytime).

There is an additional atom {\bf rule} that is used to define when daylight
savings time in a timezone starts and ends. We provide predefined timezone
objects for a number of timezones below (see the init script of this module).
Also, there is one timezone called the {\bf local timezone}, which can be set
to one global value in a running Monet server, that is used if the timezone
parameter is omitted from a command that needs it (if not set, the default value
of the local timezone is plain GMT).
\end{description}

@- Limitations
@T
The valid ranges of the various data types are as follows:
\begin{description}
\item[min and max year]
The maximum and minimum dates and timestamps that can be stored are in the years 5,867,411 and
-5,867,411, respectively. Interestingly, the year 0 is not a valid year. The year before 1 is
called -1.
\item[valid dates]
Fall in a valid year, and have a month and day that is valid in that year. The first day in the year
is January 1, the last December 31. Months with 31 days are January, March, May, July, August,
October, and December, while April, June, September and November have 30 days. February has 28
days, expect in a leap year, when it has 29. A leap year is a year that is an exact multiple of
4. Years that are a multiple of 100 but not of 400 are an exception; they are no leap years.
\item[valid daytime]
The smallest daytime is 00:00:00:000 and the largest 23:59:59:999 (the hours in a daytime
range between [0,23], minutes and seconds between [0,59] and milliseconds between [0:999]).
Daytime identifies a valid time-of-day, not an amount of time (for denoting amounts of time, or
time differences, we use here concepts like "number of days" or "number of milliseconds" denoted
by some value of a standard integer type).
\item[valid timestamp]
is formed by a combination of a valid date and valid daytime.
\item[difference in days]
For difference calculations between dates (in numbers of days) we use signed integers (the {\tt int}
Monet type), hence the valid range for difference calculations is between -2147483648 and
2147483647 days (which corresponds to roughly -5,867,411 and 5,867,411 years).
\item[difference in msecs]
For difference between timestamps (in numbers of milliseconds) we use 64-bit longs (the {\tt lng} Monet type).
These are large integers of maximally 19 digits, which therefore impose a limit of about 106,000,000,000 years
on the maximum time difference used in computations.
\end{description}

There are also conceptual limitations that are inherent to the time system itself:
\begin{description}
\item[Gregorian calendar]
The basics of the Gregorian calendar stem from the time of Julius Caesar,
when the concept of a solar year as consisting of 365.25 days (365 days plus once
in 4 years one extra day) was introduced. However, this Julian Calendar, made a year 11
minutes long, which subsequently accumulated over the ages, causing a shift in
seasons. In medieval times this was noticed, and in 1582 Pope Gregory XIII issued a
decree, skipped 11 days. This measure was not adopted in the whole of Europe immediately,
however.  For this reason, there were many regions in Europe that upheld different dates.

It was only on {\bf September 14, 1752} that some consensus was reached and more countries
joined the Gregorian Calendar, which also was last modified at that time. The modifications
were twofold: first, 12 more days were skipped. Second, it was determined that the
year starts on January 1 (in England, for instance, it had been starting on March 25).

Other parts of the world have adopted the Gregorian Calendar even later.

This module implements the Gregorian Calendar in all its regularity. This means
that values before the year 1752 probably do not correspond with the dates that
people really used in times before that (what they did use, however, was very vague
anyway, as explained above). In solar terms, however, this calendar is reasonably
accurate (see the "correction seconds" note below).

\item[timezones]
The basic timezone regime was established on {\bf November 1, 1884} in the {\em International
Meridian Conference} held in Greenwich (UK). Before that, a different time held in almost
any city. The conference established 24 different time zones defined by regular longitude intervals
that all differed by one hour.	Not for long it was that national and political interest started
to erode this nicely regular system.  Timezones now often follow country borders, and some regions
(like the Guinea areas in Latin America) have times that differ with a 15 minute grain from GMT
rather than an hour or even half-an-hour grain.

An extra complication became the introduction of daylight saving time (DST), which
causes a time jump in spring, when the clock is skips one hour and in autumn, when the
clock is set back one hour (so in a one hour span, the same times occur twice).
The DST regime is a purely political decision made on a country-by-country basis. Countries
in the same timezone can have different DST regimes. Even worse, some countries have DST in
some years, and not in other years.

To avoid confusion, this module stores absolute points of time in GMT only (GMT does not
have a DST regime). When storing local times in the database, or retrieving local times
from absolute timestamps, a correct timezone object should be used for the conversion.

Applications that do not make correct use of timezones, will produce irregular results
on e.g. time difference calculations.

\item[correction seconds]
Once every such hundred years, a correction second is added on new year's night.
As I do not know the rule, and this rule would seriously complicate this module
(as then the duration of a day, which is now the fixed number of 24*60*60*1000
milliseconds, becomes parametrized by the date), it is not implemented. Hence
these seconds are lost, so time difference calculations in milliseconds (rather than
in days) have a small error if the time difference spans many hundreds of years.
\end{description}

TODO: we cannot handle well changes in the tzone rules (e.g., DST only exists since
40 years, and some countries make frequent changes to the DST policy). To accommodate
this we should make tzone\_local a function with a year parameter. The tool should
maintain and access the tzone database stored in two bats [str,tzone],[str,year].
Lookup of the correct tzone would be dynamic in this structure. The tzone\_setlocal
would just set the string name of the tzone.

@+ Concepts

@+ Monet Module Definition
@m
.MODULE monettime;

@- date atom
@T
Monet atoms can have multiple {\em parse formats}. One of these formats is
chosen as the {\em print format}.

To facilitate date descriptions, many formats are supported when parsing
date atoms from a string, as described by the below grammar.
\begin{verbatim}
print format: INT_YEAR '-' INT_MONTH '-' INT_DAY
parse format: INT_YEAR SEP1 INT_MONTH SEP1 INT_DAY
	  or: INT_YEAR SEP2 STR_MONTH SEP2 INT_DAY
	  or: STR_MONTH ' '+ INT_DAY ',' ' '* INT_YEAR

with:	INT_YEAR = integer between -5867411 and 5867411
	 INT_DAY = integer between 1 and 31
       INT_MONTH = integer between 1 and 12
       STR_MONTH = 'JANUARY' or 'FEBRUARY' or 'MARCH' or 'APRIL' or 'MAY'
		   or 'JUNE' or 'JULI' or 'AUGUST' or 'SEPTEMBER' or 'OCTOBER'
		   or 'NOVEMBER' or 'DECEMBER' (lowercase characters, and/or
		   only the first three characters are also allowed)
	    SEP1 = '-' or '/' or '\' or (' ')+
	    SEP2 = SEP1 or ''
\end{verbatim}
Printing a date uses the 1999-01-31 format, as this is both language neutral
and the lexicographical string ordering of this representation respects the
actual date ordering.

Other print formats can be achieved by writing a customized MIL procedure
that extracts year, month and day from a date as integers and formats those
in a string.
@m
.ATOM date = int;
	.FROMSTR = date_fromstr;
	.TOSTR = date_tostr;
.END;

.COMMAND isnil(date) : bit = date_isnil;	    "date nil test (!DS2.2)"
.OPERATOR0 (date) "="  (date) : bit = date_comp_EQ;  "date equality test (!DS2.2)"
.OPERATOR0 (date) "!=" (date) : bit = date_comp_NE; "date non-equality test (!DS2.2)"
.OPERATOR0 (date) "<"  (date) : bit = date_comp_LT;  "date smaller-than test (!DS2.2)"
.OPERATOR0 (date) ">"  (date) : bit = date_comp_GT;  "date greater-than test (!DS2.2)"
.OPERATOR0 (date) "<=" (date) : bit = date_comp_LE;  "date smaller-or-equal test (!DS2.2)"
.OPERATOR0 (date) ">=" (date) : bit = date_comp_GE;  "date greater-or-equal test (!DS2.2)"

@- daytime atom
@T
A valid time of day to the detail of milliseconds, like 23:59:59:000
\begin{verbatim}
print format: HOUR ':' MIN ':' SEC '.' MSEC
parse format: HOUR ':' MIN ':' SEC SEP MSEC
	  or: HOUR ':' MIN ':' SEC
	  or: HOUR ':' MIN

with: HOUR = integer between 0 and 23
       MIN = integer between 0 and 59
       SEC = integer between 0 and 59 (default = 0)
      MSEC = integer between 0 and 999 (default = 0)
       SEP = '.' or ':'
\end{verbatim}
@m
.ATOM daytime = int;
	.FROMSTR = daytime_tz_fromstr;
	.TOSTR = daytime_tostr;
.END;

.COMMAND isnil(daytime) : bit = daytime_isnil;		     "daytime nil test (!DS2.2)"
.OPERATOR0 (daytime) "="  (daytime) : bit = daytime_comp_EQ;  "daytime equality test (!DS2.2)"
.OPERATOR0 (daytime) "!=" (daytime) : bit = daytime_comp_NE; "daytime non-equality test (!DS2.2)"
.OPERATOR0 (daytime) "<"  (daytime) : bit = daytime_comp_LT;  "daytime smaller-than test (!DS2.2)"
.OPERATOR0 (daytime) ">"  (daytime) : bit = daytime_comp_GT;  "daytime greater-than test (!DS2.2)"
.OPERATOR0 (daytime) "<=" (daytime) : bit = daytime_comp_LE;  "daytime smaller-or-equal test (!DS2.2)"
.OPERATOR0 (daytime) ">=" (daytime) : bit = daytime_comp_GE;  "daytime greater-or-equal test (!DS2.2)"


@- timestamp
@T
An absolute point of time, as formed by the combination of a date a daytime in GMT
e.g. 1999-01-31@23:59:59:000. GMT is the universal time at the Greenwich meridian,
without any daylight savings time (DST). As such GMT times are 'absolute' (continuous,
without hour jumps as in DST), so accurate time difference computations can be performed.
\begin{verbatim}
print format: DATE ' ' DAYTIME
parse format: DATE ' ' DAYTIME	['GMT' ZONE ]

with:	 DATE = a valid parse format of the date atom (as decribed earlier)
      DAYTIME = a valid parse format of the daytime atom (as decribed earlier)
	 ZONE = ('+'|'-') HOUR ':' MIN [ 'DST' ]
\end{verbatim}

Though internally timestamps are stored in GMT, the printing and parsing of
timestamps is relative to the local timezone. That is, timestamps are
printed without GMT part, meaning that the time is relative to the local
timezone.   Also, if a timestamp is parsed from a string that does not have
an explicit GMT specifier, it is taken to be a timestamp in the local
timezone. The default local timezone is just GMT+00, but it can be set
arbitrarily.
@m
.ATOM timestamp = lng;
	.FROMSTR = timestamp_fromstr;
	.TOSTR = timestamp_tostr;
	.NULL	 = timestamp_null;
.END;

.COMMAND isnil(timestamp) : bit = timestamp_isnil;		   "timestamp nil test (!DS2.2)"
.OPERATOR0 (timestamp) "="  (timestamp) : bit = timestamp_comp_EQ;  "timestamp equality test (!DS2.2)"
.OPERATOR0 (timestamp) "!=" (timestamp) : bit = timestamp_comp_NE; "timestamp non-equality test (!DS2.2)"
.OPERATOR0 (timestamp) "<"  (timestamp) : bit = timestamp_comp_LT;  "timestamp smaller-than test (!DS2.2)"
.OPERATOR0 (timestamp) ">"  (timestamp) : bit = timestamp_comp_GT;  "timestamp greater-than test (!DS2.2)"
.OPERATOR0 (timestamp) "<=" (timestamp) : bit = timestamp_comp_LE;  "timestamp smaller-or-equal test (!DS2.2)"
.OPERATOR0 (timestamp) ">=" (timestamp) : bit = timestamp_comp_GE;  "timestamp greater-or-equal test (!DS2.2)"

@T
When creating a timestamp from a date and daytime, a timezone should be specified
(if timezone is omitted, the local timezone is assumed). If a timezone is specified,
it is used to convert the date and time in that timezone to GMT, which is the internal
timestamp representation. One problem here is that the first hour after DST
has ended (some Sunday night in autumn, generally), the time is set back one hour, so
the same times occur twice. Hence two translations to a timestamp are possible for
such date and time combinations. In those case, we act as if it was the first
occurrence (still within DST).

@- tzone
@T
A timezone determines a {\em time offset} from GMT with format
[-] HOUR ':' MINUTES, with HOUR between [0:23] and MINUTES between [0:59].

Possibly, {\em Daylight Savings Time} (DST) is in force in a timezone, which means that
between a start and an end date, the clock is set back {\bf one hour}. The start and
end date of DST are determined by a {\em rule}. These rules (similar to the
Java Timezone class) are made up of 4 parameters: a month {\bf M}, a day number in the
month {\bf D}, a day-of-week (monday,..,sunday) denoted {\bf W}, and a daytime {\bf T}
(only to the minute detail).

Depending of the values of these parameters, five kinds of rules can be made
(similar to the Java TimeZone class):
\begin{itemize}
\item first {\bf D}th weekday {\bf W} from start of month {\bf M}.\\
iff {\bf D} in [1,..,5], {\bf W} in [1,..,7]

\item last {\bf D}th weekday {\bf W} from end of month {\bf M}.\\
iff {\bf D} in [-5,..,-1], {\bf W} in [1,..,7]

\item first weekday {\bf W} in month {\bf M} after exact {\bf D}th day of month.\\
iff {\bf D} in [1,..,31], {\bf W} in [-7,..,-1]

\item last weekday {\bf W} in month {\bf M} before exact {\bf D}th day of month.\\
iff {\bf D} in [-31,..,-1], {\bf W} in [-7,..,-1]

\item exact {\bf D}th day of month {\bf M}.\\
iff {\bf D} in [1,..,31], {\bf W}=0;

\end{itemize}
The parameters {\bf M} is a month number between 1 and 12, and {\bf T} is a time
to the minute detail just like the time offset of the timezone.

Other values of the rule parameters on creating a timezone will produce a
nil-timezone.
@m
.ATOM tzone = lng;
	.FROMSTR = tzone_fromstr;
	.TOSTR	 = tzone_tostr;
	.NULL	 = tzone_null;
.END;

.ATOM rule = int;
	.FROMSTR = rule_fromstr;
	.TOSTR = rule_tostr;
.END;

.COMMAND tzone_local(tzone) = tzone_set_local;
	"set the local tzone; which is used for printing timestamps (!DS2.2)"
.COMMAND tzone_local() : tzone = tzone_get_local;
	"get the local tzone; which is used for printing timestamps (!DS2.2)"

@- construction
Construct temporal values from simple(r) parameters.
Out-of range result values are represented by the nil.
@m
.COMMAND "date" (int year, int month, int day) : date = date_create;
	"creates a date from (year,month,day) parameters."
.COMMAND "daytime" (int hours, int minutes, int seconds, int milliseconds) : daytime = daytime_create;
	"creates a time from (hours,minutes,seconds,milliseconds) parameters."
.COMMAND "timestamp" (date,daytime,tzone) : timestamp = timestamp_create;
	"creates a timestamp from (date,daytime,tzone) parameters (!DS2.2)."
.COMMAND "timestamp" (date,daytime) : timestamp = timestamp_create_default;
	"creates a timestamp from (date,daytime) parameters (in the local timezone)."
.COMMAND "rule" (int month, int day, int weekday, int minutes) : rule = rule_create;
	"create a DST start/end date rule. (!DS2.2)"
.COMMAND "tzone" (int minutes) : tzone = tzone_create;
	"create a tzone as a simple hour difference from GMT. (!DS2.2)"
.COMMAND "tzone" (int minutes, rule start, rule end) : tzone = tzone_create_dst;
	"create a tzone as an hour difference from GMT and a DST. (!DS2.2)"

@- decomposition
@T
There are routines that decompose a date and routines that decompose a daytime.
For decomposing a timestamp, there are routines that decompose it in a date
and daytime. The bulk variants are also provided to simplify code
generation for SQL and to improve speed.
@m
# date
.COMMAND year(date) : int = date_extract_year;
	"extracts year from date (nonzero value between -5867411 and +5867411)."
.COMMAND month(date) : int = date_extract_month;
	"extracts month from date (value between 1 and 12)"
.COMMAND day(date) : int = date_extract_day;
	"extracts day from date (value between 1 and 31)"

# daytime
.COMMAND hours(daytime) : int = daytime_extract_hours;
	"extracts hour from daytime (value between 0 and 23)"
.COMMAND minutes(daytime) : int = daytime_extract_minutes;
	"extracts minutes from daytime (value between 0 and 59)"
.COMMAND seconds(daytime) : int = daytime_extract_seconds;
	"extracts seconds from daytime (value between 0 and 59)"
.COMMAND milliseconds(daytime) : int = daytime_extract_milliseconds;
	"extracts milliseconds from daytime (value between 0 and 999)"
.COMMAND add(daytime value, lng msecs) : daytime = daytime_add;
	"returns the daytime that comes 'msecs' (possibly negative) after 'value'."

# timestamp
.COMMAND "daytime" (timestamp) : daytime = timestamp_extract_daytime_default;
	"extracts daytime from timestamp (in the local timezone)."
.COMMAND "daytime" (timestamp, tzone) : daytime = timestamp_extract_daytime;
	"extracts daytime from timestamp in a certain tzone (!DS2.2)."

.COMMAND "date" (timestamp) : date = timestamp_extract_date_default;
	"extracts date from timestamp (in the local timezone)."
.COMMAND "date" (timestamp, tzone) : date = timestamp_extract_date;
	"extracts date from timestamp in a certain tzone (!DS2.2)."

# tzone
.COMMAND start_dst(tzone) : rule = tzone_extract_start;
	"extract rule that determines start of DST from tzone (!DS2.2)."
.COMMAND end_dst(tzone) : rule = tzone_extract_end;
	"extract rule that determines end of DST from tzone (!DS2.2)."
.COMMAND minutes(tzone) : int = tzone_extract_minutes;
	"extract number of minutes that tzone is offset wrt GMT (!DS2.2)."

.COMMAND date_sub_sec_interval( date, int):date = date_sub_sec_interval_wrap;
	"subtract seconds interval"
.COMMAND date_add_sec_interval( date, int):date = date_add_sec_interval_wrap;
	"add  seconds interval"
.COMMAND date_sub_month_interval( date, int):date = date_sub_month_interval_wrap;
	"subtract months interval"
# rule
.COMMAND month(rule) : int = rule_extract_month;
	"extract month from rule (!DS2.2)."
.COMMAND day(rule) : int = rule_extract_day;
	"extract day from rule (!DS2.2)."
.COMMAND weekday(rule) : int = rule_extract_weekday;
	"extract weekday from rule (!DS2.2)."
.COMMAND minutes(rule) : int = rule_extract_minutes;
	"extract minutes from rule (!DS2.2)."

@- arithmetic
@T
We choose to represent intervals of time as numbers of days (as int, a 32-bits integer)
and numbers of milliseconds (as lng, a 64-bits integer). Using standard integer types
facilitates computation with these amounts of time (you can use all normal integer
arithmetic operators).

Arithmetic overflow returns the nil atom (no error messages). For all commands in
this modules it holds that if one of the parameters is nil, the result is also nil
(nil has the don't know semantics in MIL).
@m
.COMMAND addyears(date value, int years) : date = date_addyears;
	"returns the date after a number of years (possibly negative)."
.COMMAND addmonths(date value, int months) : date = date_addmonths;
	"returns the date after a number of months (possibly negative)."
.COMMAND adddays(date value, int days) : date = date_adddays;
	"returns the date after a number of days (possibly negative)."
.COMMAND diff(date val1, date val2) : int = date_diff;
	"returns the number of days between 'val1' and 'val2'."

.COMMAND dayofyear(date) : int = date_extract_dayofyear;
	"Returns N where d is the Nth day of the year (january 1 returns 1)"
.COMMAND weekofyear(date) : int = date_extract_weekofyear;
	"Returns the week number in the year."
.COMMAND dayofweek(date) : int = date_extract_dayofweek;
	"Returns the current day of the week where 1=sunday, .., 7=saturday"

.COMMAND add(timestamp value, lng msecs) : timestamp = timestamp_add;
	"returns the timestamp that comes 'msecs' (possibly negative) after 'value' (!DS2.2)."
.COMMAND diff(timestamp val1, timestamp val2) : lng = timestamp_diff;
	"returns the number of milliseconds between 'val1' and 'val2' (!DS2.2)."

.COMMAND dst(timestamp, tzone) : bit = timestamp_inside_dst;
	"return whether DST holds in the tzone at a certain point of time (!DS2.2)."

.COMMAND compute(rule, int year) : date = compute_rule_foryear;
	"compute the date from a rule in a certain year (!DS2.2)."

@- day and month names
One day we should introduce the concept of locale, and hook here.
@m
.COMMAND monthnum(str month) : int = month_from_str;
	"Returns month number [1-12] from a string; or nil if does not match any (!DS2.2)."
.COMMAND monthname(int month) : str = month_to_str;
	"Returns month name from a number between [1-12], str(nil) otherwise (!DS2.2)."
.COMMAND daynum(str day) : int = day_from_str;
	"Returns number of day [1-7] from a string; or nil if does not match any (!DS2.2)."
.COMMAND dayname(int day) : str = day_to_str;
	"Returns day name from a number between [1-7], str(nil) otherwise (!DS2.2)."

.COMMAND monettime_synonyms(bit allow) = monettime_synonyms;
	"Allow synonyms for the parse format of date/timestamp in addition ot their print format (!DS2.2)."

.COMMAND olddate (str format) : date = olddate;
	"create a date from the old instant format."
.COMMAND oldduration(str format) : int = oldduration;
	"parse the old duration format and return an (estimated) number of days."
# time
.COMMAND msec() : lng = CMDmsec;
	"get time of day in milliseconds since 1-1-1970."


.PRELUDE = monettime_prelude;
.EPILOGUE = monettime_epilogue;

.END monettime;

@mil
	module("alarm");

	CONST monettime_tzones := bat("monettime_tzones");

	# default time creation with zeroed secs and msecs
	proc "daytime" (int hour) : daytime {
		return daytime(hour, 0, 0, 0);
	}
	proc "daytime" (int hour, int minute) : daytime {
		return daytime(hour, minute, 0, 0);
	}
	proc "daytime" (int hour, int minute, int second) : daytime {
		return daytime(hour, minute, second, 0);
	}

	proc "[daytime]" (bat[any::1,int] hour) : bat[any::1,daytime] {
		return [daytime](hour, 0, 0, 0);
	}
	proc "[daytime]" (bat[any::1,int] hour, bat[any::1,int] minute) : bat[any::1,daytime] {
		return [daytime](hour, minute, 0, 0);
	}
	proc "[daytime]" (bat[any::1,int] hour, bat[any::1,int] minute, bat[any::1,int] second) : bat[any::1,daytime] {
		return [daytime](hour, minute, second, 0);
	}

	# rule creation synonyms
	proc "rule" (int months, int days, int weekdays, int hour, int minute) : rule{
		return rule(months, days, weekdays, (hour * 60) + minute);
	}
	proc "rule" (int months, str days, int weekdays, int hour, int minute) : rule{
		return rule(months, daynum(days), weekdays, (hour * 60) + minute);
	}
	proc "rule" (int months, str days, int weekdays, int minute) : rule{
		return rule(months, daynum(days), weekdays, minute);
	}

	proc "[rule]" (bat[any::1,int] months, bat[any::1,int] days, bat[any::1,int] weekdays,
		    bat[any::1,int] hour, bat[any::1,int] minute) : bat[any::1,rule]{
		return [rule](months, days, weekdays, [+]([*](hour,60),minute));
	}
	proc "[rule]" (bat[any::1,int] months, bat[any::1,str] days, bat[any::1,int] weekdays,
		    bat[any::1,int] hour, bat[any::1,int] minute) : bat[any::1,rule]{
		return [rule](months, [daynum](days), weekdays, [+]([*](hour,60),minute));
	}
	proc "[rule]" (bat[any::1,int] months, bat[any::1,str] days, bat[any::1,int] weekdays,
		    bat[any::1,int] minute) : bat[any::1,rule]{
		return [rule](months, [daynum](days), weekdays, minute);
	}

	# As a starting point, we provide some standard tzones
	#
	const RULE_MAR := rule("first sunday from end of march@02:00");
	const RULE_OCT := rule("first sunday from end of october@02:00");
	const TIMEZONES := new(str, tzone).rename("monettime_tzones");

	TIMEZONES.insert("Wake Island",		 tzone( 12*60));
	TIMEZONES.insert("Melbourne/Australia",	 tzone( 11*60));
	TIMEZONES.insert("Brisbane/Australia",	 tzone( 10*60));
	TIMEZONES.insert("Japan",		 tzone( 09*60));
	TIMEZONES.insert("Singapore",		 tzone( 08*60));
	TIMEZONES.insert("Thailand",		 tzone( 07*60));
	TIMEZONES.insert("Kazakhstan",		 tzone( 06*60, RULE_MAR, RULE_OCT));
	TIMEZONES.insert("Pakistan",		 tzone( 05*60));
	TIMEZONES.insert("United Arab Emirates", tzone( 04*60));
	TIMEZONES.insert("Moscow/Russia",	 tzone( 03*60, RULE_MAR, RULE_OCT));
	TIMEZONES.insert("East/Europe",		 tzone( 02*60, RULE_MAR, RULE_OCT));
	TIMEZONES.insert("West/Europe",		 tzone( 01*60, RULE_MAR, RULE_OCT));
	TIMEZONES.insert("GMT",			 tzone( 00*00));
	TIMEZONES.insert("UK",			 tzone( 00*00, RULE_MAR, RULE_OCT));
	TIMEZONES.insert("Azore Islands",	 tzone(-01*60));
	TIMEZONES.insert("Eastern/Brazil",	 tzone(-02*60, RULE_OCT, RULE_MAR));
	TIMEZONES.insert("Western/Brazil",	 tzone(-03*60, RULE_OCT, RULE_MAR));
	TIMEZONES.insert("Andes/Brazil",	 tzone(-04*60, RULE_OCT, RULE_MAR));
	TIMEZONES.insert("East/USA",		 tzone(-05*60, RULE_MAR, RULE_OCT));
	TIMEZONES.insert("Central/USA",		 tzone(-06*60, RULE_MAR, RULE_OCT));
	TIMEZONES.insert("Mountain/USA",	 tzone(-07*60, RULE_MAR, RULE_OCT));
	TIMEZONES.insert("Alaska/USA",		 tzone(-09*60, RULE_MAR, RULE_OCT));
	TIMEZONES.insert("Hawaii/USA",		 tzone(-10*60));
	TIMEZONES.insert("American Samoa",	 tzone(-11*60));

	proc TIMEZONE( str name ) : tzone {
		if (not(TIMEZONES.exist(name))) name := "GMT";
		return TIMEZONES.find(name);
	}

	tzone_local(TIMEZONE("West/Europe"));

	proc local_timezone () : lng {
		return lng(minutes(tzone_local())*60);
	}

	proc "[date]" (bat[any::1,timestamp] t) : bat[any::1,date]{
		return [date](t, tzone_local());
	}
	proc "[daytime]" (bat[any::1,timestamp] t) : bat[any::1,daytime]{
		return [daytime](t, tzone_local());
	}
	proc "[timestamp]" (bat[any::1,date] d, bat[any::1,daytime] t) : bat[any::1,timestamp]{
		return [timestamp](d, t, tzone_local());
	}

	# unix-time (epoch) support: seconds since 1-jan-1970 GMT
	const EPOCH := timestamp(date(1970,1,1),daytime(0,0,0,0),tzone("GMT"));

	proc timestamp(date d) : timestamp {
		return timestamp(d, daytime(0,0,0,0), tzone("GMT"));
	}
	proc timestamp(int secs) : timestamp{
		return EPOCH.add(lng(secs) * lng(1000));
	}
	proc timestamp(lng msecs) : timestamp{
		return EPOCH.add(lng(msecs));
	}
	proc epoch(timestamp t) : int {
		return int(diff(t, EPOCH)/lng(1000));
	}

	proc [timestamp](bat[any::1,int] secs) : bat[any::1,timestamp]{
		return [add](EPOCH, [*]([lng](secs),lng(1000)));
	}
	proc [epoch](bat[any::1,timestamp] t) : bat[any::1,int]{
		return [int]([/]([diff](t, EPOCH), lng(1000)));
	}

	proc msecs(int d, int h, int m, int s, int ms) : lng{
		return lng(ms) + (lng(1000) * (lng(s) + (lng(60) * (lng(m) +
				    (lng(60) * (lng(h) + (lng(24) * lng(d))))))));
	}

	# some utilities for the SQL front-end
proc current_timestamp() : timestamp { return timestamp(msec()); }
proc current_date() : date { return date(current_timestamp()); }
proc current_time() : daytime { return daytime(current_timestamp()); }

# utility functions (for SQL) for direct extraction of fields from timestamps
proc year(timestamp t) : int { return year(date(t)); }
proc month(timestamp t) : int { return month(date(t)); }
proc day(timestamp t) : int { return day(date(t)); }
proc hours(timestamp t) : int { return hours(daytime(t)); }
proc minutes(timestamp t) : int { return minutes(daytime(t)); }
proc seconds(timestamp t) : int { return seconds(daytime(t)); }
proc milliseconds(timestamp t) : int { return milliseconds(daytime(t)); }

proc year(int months) : int { return months/12; }
proc month(int months) : int { return months%12; }
proc day(lng secs) : lng { return secs/86400; }
proc hours(lng secs) : int { return (secs%86400)/3600; }
proc minutes(lng secs) : int { return (secs%3600)/60; }
proc seconds(lng secs) : int { return (secs%60); }

# temporary(?) HACK to distinguish type-signatures of
# date_sub_sec_interval & date_add_sec_interval (now: date,lng) from those of
# date_sub_month_interval & addmonth (date,int),
# and thus enable proper function binding in SQL.
proc date_sub_sec_interval( date d, lng s ) : date {
	return date_sub_sec_interval( d, int(s) );
}
proc date_add_sec_interval( date d, lng s ) : date {
	return date_add_sec_interval( d, int(s) );
}
proc timestamp_sub_sec_interval( timestamp ts, lng s ) : timestamp {
	return add( ts, s*lng(-1000) );
}
proc timestamp_add_sec_interval( timestamp ts, lng s ) : timestamp {
	return add( ts, s*lng(1000) );
}
proc timestamp_sub_month_interval( timestamp ts, int m ) : timestamp {
	var t := daytime(ts);
	var d := date(ts);
	d := date_sub_month_interval( d, m );
	return timestamp(d,t);
}
proc addmonths( timestamp ts, int m ) : timestamp {
	var t := daytime(ts);
	var d := date(ts);
	d := addmonths( d, m );
	return timestamp(d,t);
}
proc time_sub_sec_interval( daytime t, lng s ) : daytime {
	return add( t, s*lng(-1000) );
}
proc time_add_sec_interval( daytime t, lng s ) : daytime {
	return add( t, s*lng(1000) );
}

@{
@* Implementation

@+ Atoms

@- date
Internally, we store date as the (possibly negative) number of
days since the start of the calendar. Oddly, since I (later) learned
that the year 0 did no exist, this defines the start of the calendar to
be Jan 1 of the year -1 (in other words, a -- positive -- year component
of a date is equal to the number of years that have passed since the start
of the calendar).
@h
#ifndef _MONETTIME_H_
#define _MONETTIME_H_

#ifdef __cplusplus
extern "C" {
#endif

#include <gdk.h>

typedef int date;
#define date_nil ((date) int_nil)
@c
#include "monetdb4_config.h"
#include "monettime.h"

@- daytime
Daytime values are also stored as the number of milliseconds that passed since
the start of the day (i.e. midnight).
@h
typedef int daytime;
#define daytime_nil ((daytime) int_nil)

@- timestamp
Timestamp is implemented as a record that contains a date and a time (GMT).
@h
typedef struct {
#ifndef WORDS_BIGENDIAN
	daytime msecs;
	date days;
#else
	date days;
	daytime msecs;
#endif
} timestamp;

@- rule
rules are used to define the start and end of DST. It uses the 25 lower bits of an int.
@h
typedef union {
	struct {
		unsigned int month:4,	/* values: [1..12] */
		 minutes:11,	/* values: [0:1439] */
		 day:6,		/* values: [-31..-1,1..31] */
		 weekday:4,	/* values: [-7..-1,1..7] */
		 empty:7;	/* rule uses just 32-7=25 bits */
	} s;
	int asint;		/* the same, seen as single value */
} rule;
@c
#define get_rule(r)	((r).s.weekday | ((r).s.day<<6) | ((r).s.minutes<<10) | ((r).s.month<<21))
#define set_rule(r,i) { (r).s.weekday = (i)&15;\
			(r).s.day = ((i)&(63<<6))>>6;\
			(r).s.minutes = ((i)&(2047<<10))>>10;\
			(r).s.month = ((i)&(15<<21))>>21; }

/* phony zero values, used to get negative numbers from unsigned sub-integers in rule */
#define WEEKDAY_ZERO	8
#define DAY_ZERO	32
#define OFFSET_ZERO	4096

@- tzone
A tzone consists of an offset and two DST rules, all crammed into one lng.
@h
typedef struct {
	/* we had this as bitfields in one unsigned long long, but native sun CC does not eat that.  */
	unsigned int dst:1, off1:6, dst_start:25;
	unsigned int off2:7, dst_end:25;
} tzone;
@c
/* as the offset field got split in two, we need macros to get and set them */
#define get_offset(z)	(((int) (((z)->off1 << 7) + (z)->off2)) - OFFSET_ZERO)
#define set_offset(z,i)	{ (z)->off1 = (((i)+4096)&8064) >> 7; (z)->off2 = ((i)+OFFSET_ZERO)&127; }

tzone tzone_local;

@h
#include "monettime.proto.h"	/* generated definitions by mel */

monettime_export void fromdate(int n, int *d, int *m, int *y);
monettime_export void fromtime(int n, int *hour, int *min, int *sec, int *msec);

#ifdef __cplusplus
}
#endif
#endif	/* _MONETTIME_H_ */
@+ Defines
@c
str MONTHS[13] = { NULL, "january", "february", "march", "april", "may", "june",
	"july", "august", "september", "october", "november", "december"
};
str DAYS[8] = { NULL, "sunday", "monday", "tuesday", "wednesday", "thursday",
	"friday", "saturday"
};
str COUNT1[7] = { NULL, "first", "second", "third", "fourth", "fifth", "last" };
str COUNT2[7] = { NULL, "1st", "2nd", "3rd", "4th", "5th", "last" };
int NODAYS[13] = { 0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };

date DATE_MAX, DATE_MIN;	/* often used dates; computed once */

#define YEAR_MAX	5867411
#define YEAR_MIN	-YEAR_MAX
#define MONTHDAYS(m,y)	(((m)!=2)?NODAYS[m]:leapyear(y)?29:28)
#define YEARDAYS(y)	(leapyear(y)?366:365)
#define LEAPYEARS(y)	(leapyears(y)+((y)>=0))
#define DATE(d,m,y)	((m)>0&&(m)<=12&&(d)>0&&(y)!=0&&(y)>=YEAR_MIN&&(y)<=YEAR_MAX&&(d)<=MONTHDAYS(m,y))
#define TIME(h,m,s,x)	((h)>=0&&(h)<24&&(m)>=0&&(m)<60&&(s)>=0&&(s)<60&&(x)>=0 &&(x)<1000)
#define LOWER(c)	(((c) >= 'A' && (c) <= 'Z') ? (c)+'a'-'A' : (c))

@+ auxiliary functions
@c

#define tz_isnil(z)   (get_offset(&(z)) == get_offset(tz_nilptr))
#define ts_isnil(t)   ((t).days == ts_nilptr->days && (t).msecs == ts_nilptr->msecs)

static union {
	timestamp ts;
	lng nilval;
} ts_nil;
static union {
	tzone tz;
	lng nilval;
} tz_nil;
static timestamp *ts_nilptr = NULL;
static tzone *tz_nilptr = NULL;

static void date_prelude(void);

bat *
monettime_prelude(void)
{
	ts_nil.nilval = lng_nil;
	tz_nil.nilval = lng_nil;

	ts_nilptr = &ts_nil.ts;
	tz_nilptr = &tz_nil.tz;

	date_prelude();
	return NULL;
}

void
monettime_epilogue(void)
{
}

timestamp *
timestamp_null(void)
{
	return (ts_nilptr);
}

tzone *
tzone_null(void)
{
	return (tz_nilptr);
}

static int synonyms = TRUE;

int
monettime_synonyms(bit *allow)
{
	if (*allow != bit_nil)
		synonyms = *allow;
	return GDK_SUCCEED;
}

static INLINE int
leapyear(int year)
{
	return year % 4 == 0 && (year % 100 != 0 || year % 400 == 0);
}

static INLINE int
leapyears(int year)
{
	/* count the 4-fold years that passed since jan-1-0 */
	int y4 = year / 4;

	/* count the 100-fold years */
	int y100 = year / 100;

	/* count the 400-fold years */
	int y400 = year / 400;

	return y4 + y400 - y100;	/* may be negative */
}

static INLINE date
todate(int day, int month, int year)
{
	date n = date_nil;

	if (DATE(day, month, year)) {
		if (year < 0)
			year++;	/* HACK: hide year 0 */
		for (n = (date) (day - 1); --month > 0; n += MONTHDAYS(month, year))
			;
		/* current year does not count as leapyear */
		n += 365 * year + LEAPYEARS(year >= 0 ? year - 1 : year);
	}
	return n;
}

void
fromdate(int n, int *d, int *m, int *y)
{
	int month, year = n / 365;
	int day = (n - year * 365) - LEAPYEARS(year >= 0 ? year - 1 : year);

	if (n < 0) {
		year--;
		while (day >= 0) {
			year++;
			day -= YEARDAYS(year);
		}
		day = YEARDAYS(year) + day;
	} else {
		while (day < 0) {
			year--;
			day += YEARDAYS(year);
		}
	}
	day++;
	for (month = 1; month <= 12; month++) {
		int days = MONTHDAYS(month, year);

		if (day <= days)
			break;
		day -= days;
	}
	if (n != int_nil) {
		*d = day;
		*m = month;
		*y = (year <= 0) ? year - 1 : year;	/* HACK: hide year 0 */
	} else {
		*d = *m = *y = int_nil;
	}
}

static INLINE daytime
totime(int hour, int min, int sec, int msec)
{
	if (TIME(hour, min, sec, msec)) {
		return (daytime) (((((hour * 60) + min) * 60) + sec) * 1000 + msec);
	}
	return daytime_nil;
}

void
fromtime(int n, int *hour, int *min, int *sec, int *msec)
{
	if (n != int_nil) {
		*hour = n / 3600000;
		n -= (*hour) * 3600000;
		*min = n / 60000;
		n -= (*min) * 60000;
		*sec = n / 1000;
		n -= (*sec) * 1000;
		*msec = n;
	} else {
		*hour = *min = *sec = *msec = int_nil;
	}
}

/* matches regardless of case and extra spaces */
static INLINE int
fleximatch(str s, str pat, int min)
{
	int hit, spacy = 0;

	if (min == 0) {
		min = (int) strlen(pat);	/* default mininum required hits */
	}
	for (hit = 0; *pat; s++, hit++) {
		if (LOWER(*s) != *pat) {
			if (GDKisspace(*s) && spacy) {
				min++;
				continue;	/* extra spaces */
			}
			break;
		}
		spacy = GDKisspace(*pat);
		pat++;
	}
	return (hit >= min) ? hit : 0;
}

static INLINE int
parse_substr(int *ret, str s, int min, str list[], int size)
{
	int j = 0, i = 0;

	*ret = int_nil;
	while (++i <= size) {
		if ((j = fleximatch(s, list[i], min)) > 0) {
			*ret = i;
			break;
		}
	}
	return j;
}

static INLINE int
date_dayofweek(date v)
{
	v %= 7;
	return (v <= 0) ? v + 7 : v;
}

#define SKIP_DAYS(d,w,i) d += i; w = (w + i)%7; if (w <= 0) w += 7;

static INLINE date
compute_rule(rule *val, int y)
{
	int m = val->s.month, cnt = ABS(val->s.day - DAY_ZERO);
	date d = todate(1, m, y);
	int dayofweek = date_dayofweek(d);
	int w = ABS(val->s.weekday - WEEKDAY_ZERO);

	if (val->s.weekday == WEEKDAY_ZERO) {
		/* cnt-th of month */
		d += cnt - 1;
	} else if (val->s.day > DAY_ZERO) {
		if (val->s.weekday < WEEKDAY_ZERO) {
			/* first weekday on or after cnt-th of month */
			SKIP_DAYS(d, dayofweek, cnt - 1);
			cnt = 1;
		}		/* ELSE cnt-th weekday of month */
		while (dayofweek != w || --cnt > 0) {
			if (++dayofweek == 8)
				dayofweek = 1;
			d++;
		}
	} else {
		if (val->s.weekday > WEEKDAY_ZERO) {
			/* cnt-last weekday from end of month */
			SKIP_DAYS(d, dayofweek, MONTHDAYS(m, y) - 1);
		} else {
			/* first weekday on or before cnt-th of month */
			SKIP_DAYS(d, dayofweek, cnt - 1);
			cnt = 1;
		}
		while (dayofweek != w || --cnt > 0) {
			if (--dayofweek == 0)
				dayofweek = 7;
			d--;
		}
	}
	return d;
}

static int dummy;

#define BEFORE(d1,m1,d2,m2) (d1 < d2 || (d1 == d2 && m1 <= m2))

static INLINE int
timestamp_inside(timestamp *ret, timestamp *t, tzone *z, lng offset)
{
	/* starts with GMT time t, and returns whether it is in the DST for z */
	lng add = (offset != (lng) 0) ? offset : (get_offset(z)) * (lng) 60000;
	int start_days, start_msecs, end_days, end_msecs, year;
	rule start, end;

	timestamp_add(ret, t, &add);

	if (ts_isnil(*ret) || z->dst == 0) {
		return 0;
	}
	set_rule(start, z->dst_start);
	set_rule(end, z->dst_end);

	start_msecs = start.s.minutes * 60000;
	end_msecs = end.s.minutes * 60000;

	fromdate((int) ret->days, &dummy, &dummy, &year);
	start_days = compute_rule(&start, year);
	end_days = compute_rule(&end, year);

	return BEFORE(start_days, start_msecs, end_days, end_msecs) ? (BEFORE(start_days, start_msecs, ret->days, ret->msecs) && 
		BEFORE(ret->days, ret->msecs, end_days, end_msecs)) : (BEFORE(start_days, start_msecs, ret->days, ret->msecs) || 
		BEFORE(ret->days, ret->msecs, end_days, end_msecs));
}


@+ ADT implementations
@- date
@c
int
date_fromstr(str buf, int *len, date **d)
{
	int day = 0, month = int_nil, year = 0, yearneg = (buf[0] == '-'), yearlast = 0, pos = 0, sep;
	if (*len < (int) sizeof(date)) {
		if (*d)
			GDKfree(*d);
		*d = (date *) GDKmalloc(*len = sizeof(date));
	}
	**d = date_nil;
	if (yearneg == 0 && !GDKisdigit(buf[0])) {
		if (synonyms == 0)
			return 0;
		yearlast = 1;
		sep = ' ';
	} else {
		for (pos = yearneg; GDKisdigit(buf[pos]); pos++) {
			year = (buf[pos] - '0') + year * 10;
			if (year > YEAR_MAX)
				break;
		}
		sep = buf[pos++];
		if (synonyms == 0 && sep != '-') {
			return 0;
		}
		sep = LOWER(sep);
		if (sep >= 'a' && sep <= 'z') {
			sep = 0;
		} else if (sep == ' ') {
			while (buf[pos] == ' ')
				pos++;
		} else if (sep != '-' && sep != '/' && sep != '\\') {
			return 0;	/* syntax error */
		}
	}
	if (GDKisdigit(buf[pos])) {
		month = buf[pos++] - '0';
		if (GDKisdigit(buf[pos])) {
			month = (buf[pos++] - '0') + month * 10;
		}
	} else if (synonyms == 0) {
		return 0;
	} else {
		pos += parse_substr(&month, buf + pos, 3, MONTHS, 12);
	}
	if (month == int_nil || (sep && buf[pos++] != sep)) {
		return 0;	/* syntax error */
	}
	if (sep == ' ') {
		while (buf[pos] == ' ')
			pos++;
	}
	if (!GDKisdigit(buf[pos])) {
		return 0;	/* syntax error */
	}
	while (GDKisdigit(buf[pos])) {
		day = (buf[pos++] - '0') + day * 10;
		if (day > 31)
			break;
	}
	if (yearlast && buf[pos] == ',') {
		while (buf[++pos] == ' ')
			;
		if (buf[pos] == '-') {
			yearneg = 1;
			pos++;
		}
		while (GDKisdigit(buf[pos])) {
			year = (buf[pos++] - '0') + year * 10;
			if (year > YEAR_MAX)
				break;
		}
	}
	/* handle semantic error here (returns nil in that case) */
	**d = todate(day, month, yearneg ? -year : year);
	return pos;
}

int
date_tostr(str *buf, int *len, date *val)
{
	int day, month, year;

	fromdate((int) *val, &day, &month, &year);
	/* longest possible string: "-5867411-01-01" i.e. 14 chars
	   without NUL (see definition of YEAR_MIN/YEAR_MAX above) */
	if (*len < 15) {
		if (*buf)
			GDKfree(*buf);
		*buf = (str) GDKmalloc(*len = 15);
	}
	if (*val == date_nil || !DATE(day, month, year)) {
		strcpy(*buf, "nil");
		return 3;
	}
	sprintf(*buf, "%d-%02d-%02d", year, month, day);
	return (int) strlen(*buf);
}

@- daytime
@c
static int
daytime_fromstr(str buf, int *len, daytime **ret)
{
	int hour, min, sec = 0, msec = 0, pos = 0;

	if (*len < (int) sizeof(daytime)) {
		if (*ret)
			GDKfree(*ret);
		*ret = (daytime *) GDKmalloc(*len = sizeof(daytime));
	}
	**ret = daytime_nil;
	if (!GDKisdigit(buf[pos])) {
		return 0;	/* syntax error */
	}
	for (hour = 0; GDKisdigit(buf[pos]); pos++) {
		if (hour <= 24)
			hour = (buf[pos] - '0') + hour * 10;
	}
	if ((buf[pos++] != ':') || !GDKisdigit(buf[pos])) {
		return 0;	/* syntax error */
	}
	for (min = 0; GDKisdigit(buf[pos]); pos++) {
		if (min <= 60)
			min = (buf[pos] - '0') + min * 10;
	}
	if ((buf[pos] == ':') && GDKisdigit(buf[pos + 1])) {
		for (pos++, sec = 0; GDKisdigit(buf[pos]); pos++) {
			if (sec <= 60)
				sec = (buf[pos] - '0') + sec * 10;
		}
		if ((buf[pos] == '.' || (synonyms && buf[pos] == ':')) && GDKisdigit(buf[pos + 1])) {
			int fac = 100;

			for (pos++, msec = 0; GDKisdigit(buf[pos]); pos++) {
				msec += (buf[pos] - '0') * fac;
				fac /= 10;
			}
		}
	}
	/* handle semantic error here (returns nil in that case) */
	**ret = totime(hour, min, sec, msec);
	return pos;
}

int
daytime_tz_fromstr(str buf, int *len, daytime **ret)
{
	str s = buf;
	int pos = daytime_fromstr(s, len, ret);
	lng val, offset = 0;
	daytime mtime = 24 * 60 * 60 * 1000;

	if (!*ret || **ret == daytime_nil)
		return pos;

	s = buf + pos;
	pos = 0;
	while (GDKisspace(*s))
		s++;
	/* incase of gmt we need to add the time zone */
	if (fleximatch(s, "gmt", 0) == 3) {
		s += 3;
	}
	if ((s[0] == '-' || s[0] == '+') && GDKisdigit(s[1]) && GDKisdigit(s[2]) && GDKisdigit(s[pos = 4]) && ((s[3] == ':' && GDKisdigit(s[5])) || GDKisdigit(s[pos = 3]))) {
		offset = (((s[1] - '0') * (lng) 10 + (s[2] - '0')) * (lng) 60 + (s[pos] - '0') * (lng) 10 + (s[pos + 1] - '0')) * (lng) 60000;
		pos++;
		if (s[0] != '-')
			offset = -offset;
		s += pos;
	} else {
		/* if no tzone is specified; work with the local */
		offset = get_offset(&tzone_local) * (lng) -60000;
	}
	val = **ret + offset;
	if (val < 0)
		val = mtime + val;
	if (val >= mtime)
		val = val - mtime;
	**ret = (daytime) val;
	return (int) (s - buf);
}

int
daytime_tostr(str *buf, int *len, daytime *val)
{
	int hour, min, sec, msec;

	fromtime((int) *val, &hour, &min, &sec, &msec);
	if (*len < 12) {
		if (*buf)
			GDKfree(*buf);
		*buf = (str) GDKmalloc(*len = 13);
	}
	if (*val == daytime_nil || !TIME(hour, min, sec, msec)) {
		strcpy(*buf, "nil");
		return 3;
	}
	sprintf(*buf, "%02d:%02d:%02d.%03d", hour, min, sec, msec);
	return 12;
}

@- timestamp
@c
int
timestamp_fromstr(str buf, int *len, timestamp **ret)
{
	str s = buf;
	int pos;
	date *d;
	daytime *t;

	if (*len < (int) sizeof(timestamp)) {
		if (*ret)
			GDKfree(*ret);
		*ret = (timestamp *) GDKmalloc(*len = sizeof(timestamp));
	}
	d = &(*ret)->days;
	t = &(*ret)->msecs;
	s += date_fromstr(buf, len, &d);
	if (s > buf && (*(s) == '@' || *s == ' ' || *s == '-')) {
		while (*(++s) == ' ')
			;
		pos = daytime_fromstr(s, len, &t);
		s = pos ? s + pos : buf;
	} else {
		(*ret)->msecs = daytime_nil;
	}
	if (s <= buf || (*ret)->days == date_nil || (*ret)->msecs == daytime_nil) {
		**ret = *ts_nilptr;
	} else {
		lng offset = 0;

		while (GDKisspace(*s))
			s++;
		/* incase of gmt we need to add the time zone */
		if (fleximatch(s, "gmt", 0) == 3) {
			s += 3;
		}
		if ((s[0] == '-' || s[0] == '+') && GDKisdigit(s[1]) && GDKisdigit(s[2]) && GDKisdigit(s[pos = 4]) && ((s[3] == ':' && GDKisdigit(s[5])) || GDKisdigit(s[pos = 3]))) {
			offset = (((s[1] - '0') * (lng) 10 + (s[2] - '0')) * (lng) 60 + (s[pos] - '0') * (lng) 10 + (s[pos + 1] - '0')) * (lng) 60000;
			pos++;
			if (s[0] != '-')
				offset = -offset;
			s += pos;
		} else {
			/* if no tzone is specified; work with the local */
			timestamp tmp = **ret;

			offset = get_offset(&tzone_local) * (lng) -60000;
			if (timestamp_inside(&tmp, &tmp, &tzone_local, (lng) -3600000)) {
				**ret = tmp;
			}
		}
		timestamp_add(*ret, *ret, &offset);
	}
	return (int) (s - buf);
}

int
timestamp_tostr(str *buf, int *len, timestamp *val)
{
	int len1, len2, big = 128, off = get_offset(&tzone_local);
	char buf1[128], buf2[128], *s, *s1 = buf1, *s2 = buf2;
	timestamp tmp = *val;

	if (!ts_isnil(tmp) && timestamp_inside(&tmp, val, &tzone_local, (lng) 0)) {
		lng add = (lng) 3600000;

		timestamp_add(&tmp, &tmp, &add);
		off += 60;
	}
	len1 = date_tostr(&s1, &big, &tmp.days);
	len2 = daytime_tostr(&s2, &big, &tmp.msecs);

	if (*len < 2 + len1 + len2) {
		if (*buf)
			GDKfree(*buf);
		*buf = (str) GDKmalloc(*len = len1 + len2 + 2);
	}
	s = *buf;
	if (ts_isnil(tmp)) {
		strcpy(s, "nil");
		return 3;
	}
	strcpy(s, buf1);
	s += len1;
	*s++ = ' ';
	strcpy(s, buf2);
	s += len2;
/* omit GMT distance in order not to cinfuse the confused user
	strcpy(s, "GMT"); s += 3;
	if (off) {
		*s++ = (off>=0)?'+':'-';
		sprintf(s, "%02d%02d", ABS(off)/60, ABS(off)%60);
		s += 4;
	}
 */
	return (int) (s - *buf);
}

static str
count1(int i)
{
	static char buf[16];

	if (i <= 0) {
		return "(illegal number)";
	} else if (i < 6) {
		return COUNT1[i];
	}
	sprintf(buf, "%dth", i);
	return buf;
}

@- rule
@c
int
rule_tostr(str *buf, int *len, rule *r)
{
	int hours = r->s.minutes / 60;
	int minutes = r->s.minutes % 60;

	if (*len < 64) {
		if (*buf)
			GDKfree(*buf);
		*buf = (str) GDKmalloc(*len = 64);
	}
	if (r->asint == int_nil) {
		strcpy(*buf, "nil");
	} else if (r->s.weekday == WEEKDAY_ZERO) {
		sprintf(*buf, "%s %d\@%02d:%02d", MONTHS[r->s.month], r->s.day - DAY_ZERO, hours, minutes);
	} else if (r->s.weekday > WEEKDAY_ZERO && r->s.day > DAY_ZERO) {
		sprintf(*buf, "%s %s from start of %s\@%02d:%02d", count1(r->s.day - DAY_ZERO), DAYS[r->s.weekday - WEEKDAY_ZERO], MONTHS[r->s.month], hours, minutes);
	} else if (r->s.weekday > WEEKDAY_ZERO && r->s.day < DAY_ZERO) {
		sprintf(*buf, "%s %s from end of %s\@%02d:%02d", count1(DAY_ZERO - r->s.day), DAYS[r->s.weekday - WEEKDAY_ZERO], MONTHS[r->s.month], hours, minutes);
	} else if (r->s.day > DAY_ZERO) {
		sprintf(*buf, "first %s on or after %s %d\@%02d:%02d", DAYS[WEEKDAY_ZERO - r->s.weekday], MONTHS[r->s.month], r->s.day - DAY_ZERO, hours, minutes);
	} else {
		sprintf(*buf, "last %s on or before %s %d\@%02d:%02d", DAYS[WEEKDAY_ZERO - r->s.weekday], MONTHS[r->s.month], DAY_ZERO - r->s.day, hours, minutes);
	}
	return (int) strlen(*buf);
}

int
rule_fromstr(str buf, int *len, rule **d)
{
	int day = 0, month = 0, weekday = 0, hours = 0, minutes = 0;
	int neg_day = 0, neg_weekday = 0, pos;
	str cur = buf;

	if (*len < (int) sizeof(rule)) {
		if (*d)
			GDKfree(*d);
		*d = (rule *) GDKmalloc(*len = sizeof(rule));
	}
	(*d)->asint = int_nil;

	/* start parsing something like "first", "second", .. etc */
	pos = parse_substr(&day, cur, 0, COUNT1, 6);
	if (pos == 0) {
		pos = parse_substr(&day, cur, 0, COUNT2, 6);
	}
	if (pos && cur[pos++] == ' ') {
		/* now we must see a weekday */
		cur += pos;
		cur += parse_substr(&weekday, cur, 3, DAYS, 7);
		if (weekday == int_nil) {
			return 0;	/* syntax error */
		}
		pos = fleximatch(cur, " from start of ", 0);
		if (pos == 0) {
			pos = fleximatch(cur, " from end of ", 0);
			if (pos)
				neg_day = 1;
		}
		if (pos && day < 6) {
			/* RULE 1+2: X-th weekday from start/end of month */
			pos = parse_substr(&month, cur += pos, 3, MONTHS, 12);
		} else if (day == 1) {
			/* RULE 3: first weekday on or after-th of month */
			pos = fleximatch(cur, " on or after ", 0);
			neg_weekday = 1;
			day = int_nil;	/* re-read below */
		} else if (day == 6) {
			/* RULE 4: last weekday on or before X-th of month */
			pos = fleximatch(cur, " on or before ", 0);
			neg_weekday = neg_day = 1;
			day = int_nil;	/* re-read below */
		}
		if (pos == 0) {
			return 0;	/* syntax error */
		}
		cur += pos;
	}
	if (day == int_nil) {
		/* RULE 5:  X-th of month */
		cur += parse_substr(&month, cur, 3, MONTHS, 12);
		if (month == int_nil || *cur++ != ' ' || !GDKisdigit(*cur)) {
			return 0;	/* syntax error */
		}
		day = 0;
		while (GDKisdigit(*cur) && day < 31) {
			day = (*(cur++) - '0') + day * 10;
		}
	}

	/* parse hours:minutes */
	if (*cur++ != '\@' || !GDKisdigit(*cur)) {
		return 0;	/* syntax error */
	}
	while (GDKisdigit(*cur) && hours < 24) {
		hours = (*(cur++) - '0') + hours * 10;
	}
	if (*cur++ != ':' || !GDKisdigit(*cur)) {
		return 0;	/* syntax error */
	}
	while (GDKisdigit(*cur) && minutes < 60) {
		minutes = (*(cur++) - '0') + minutes * 10;
	}

	/* assign if semantically ok */
	if (day >= 1 && day <= NODAYS[month] && hours >= 0 && hours < 60 && minutes >= 0 && minutes < 60) {
		(*d)->s.month = month;
		(*d)->s.weekday = WEEKDAY_ZERO + (neg_weekday ? -weekday : weekday);
		(*d)->s.day = DAY_ZERO + (neg_day ? -day : day);
		(*d)->s.minutes = hours * 60 + minutes;
	}
	return (int) (cur - buf);
}

@- tzone
@c
int
tzone_fromstr(str buf, int *len, tzone **d)
{
	int hours = 0, minutes = 0, neg_offset = 0, pos = 0;
	rule r1, *rp1 = &r1, r2, *rp2 = &r2;
	str cur = buf;

	rp1->asint = rp2->asint = 0;
	if (*len < (int) sizeof(tzone)) {
		if (*d)
			GDKfree(*d);
		*d = (tzone *) GDKmalloc(*len = sizeof(tzone));
	}
	**d = *tz_nilptr;

	/* syntax checks */
	if (fleximatch(cur, "gmt", 0) == 0) {
		return 0;	/* syntax error */
	}
	cur += 3;
	if (*cur == '-' || *cur == '+') {
		str bak = cur + 1;

		neg_offset = (*cur++ == '-');
		if (!GDKisdigit(*cur)) {
			return 0;	/* syntax error */
		}
		while (GDKisdigit(*cur) && hours < 9999) {
			hours = (*(cur++) - '0') + hours * 10;
		}
		if (*cur == ':' && GDKisdigit(cur[1])) {
			cur++;
			do {
				minutes = (*(cur++) - '0') + minutes * 10;
			} while (GDKisdigit(*cur) && minutes < 60);
		} else if (*cur != ':' && (cur - bak) == 4) {
			minutes = hours % 100;
			hours = hours / 100;
		} else {
			return 0;	/* syntax error */
		}
	}
	if (fleximatch(cur, "-dst[", 0)) {
		pos = rule_fromstr(cur += 5, len, &rp1);
		if (pos == 0 || cur[pos++] != ',') {
			return 0;	/* syntax error */
		}
		pos = rule_fromstr(cur += pos, len, &rp2);
		if (pos == 0 || cur[pos++] != ']') {
			return 0;	/* syntax error */
		}
		cur += pos;
	}
	/* semantic check */
	if (hours < 24 && minutes < 60 && rp1->asint != int_nil && rp2->asint != int_nil) {
		minutes += hours * 60;
		set_offset(*d, neg_offset ? -minutes : minutes);
		if (pos) {
			(*d)->dst = TRUE;
			(*d)->dst_start = get_rule(r1);
			(*d)->dst_end = get_rule(r2);
		} else {
			(*d)->dst = FALSE;
		}
	}
	return (int) (cur - buf);
}

int
tzone_tostr(str *buf, int *len, tzone *z)
{
	str s;

	if (*len < 160) {
		if (*buf)
			GDKfree(*buf);
		*buf = (str) GDKmalloc(*len = 160);
	}
	s = *buf;
	if (tz_isnil(*z)) {
		strcpy(s, "nil");
		s += 3;
	} else {
		rule dst_start, dst_end;
		int mins = get_offset(z);

		set_rule(dst_start, z->dst_start);
		set_rule(dst_end, z->dst_end);

		strcpy(*buf, "GMT");
		s += 3;
		if (mins > 0) {
			sprintf(s, "+%02d:%02d", mins / 60, mins % 60);
			s += 6;
		} else if (mins < 0) {
			sprintf(s, "-%02d:%02d", (-mins) / 60, (-mins) % 60);
			s += 6;
		}
		if (z->dst) {
			strcpy(s, "-DST[");
			s += 5;
			s += rule_tostr(&s, len, &dst_start);
			*s++ = ',';
			s += rule_tostr(&s, len, &dst_end);
			*s++ = ']';
			*s = 0;
		}
	}
	return (int) (s - *buf);
}

@+ operator implementations
@c
static void
date_prelude(void)
{
	MONTHS[0] = (str)str_nil;
	DAYS[0] = (str)str_nil;
	NODAYS[0] = int_nil;
	DATE_MAX = todate(31, 12, YEAR_MAX);
	DATE_MIN = todate(1, 1, YEAR_MIN);
	tzone_local.dst = 0;
	set_offset(&tzone_local, 0);
}

int
oldduration(int *ndays, str s)
{
	int year = 0, month = 0, day = 0;
	int hour = 0 /*, min=0 */ ;
	char *snew = s;
	int v = 0;

	while (*snew != '\0') {
		if (GDKisdigit(*snew)) {
			v = 0;
			while (GDKisdigit(*snew)) {
				v = v * 10 + (*snew) - '0';
				snew++;
			}
		} else if (isupper((int) (*snew)) || islower((int) (*snew))) {
			switch (*snew++) {
			case 'y':
			case 'Y':
				year = v;
				v = 0;
				break;
			case 'm':
			case 'M':
				if (month || day || hour)	/*min = v */
					;
				else
					month = v;
				v = 0;
				break;
			case 'd':
			case 'D':
				day = v;
				v = 0;
				break;
			case 'h':
			case 'H':
				hour = v;
				v = 0;
				break;
			case 's':
			case 'S':
				v = 0;
				break;
			default:	/* GDKerror("duration_fromstr: wrong duration '%s'!\n",s); */
				*ndays = int_nil;
				return GDK_SUCCEED;
			}
		} else {
			snew++;
		}
	}
	*ndays = year * 365 + month * 30 + day;
	return GDK_SUCCEED;
}

int
olddate(date *d, str buf)
{
	int day = 0, month, year, yearneg = (buf[0] == '-'), pos = yearneg;

	*d = date_nil;
	if (!GDKisdigit(buf[pos])) {
		return GDK_FAIL;	/* syntax error */
	}
	for (year = 0; GDKisdigit(buf[pos]); pos++) {
		year = (buf[pos] - '0') + year * 10;
		if (year > YEAR_MAX)
			break;
	}
	pos += parse_substr(&month, buf + pos, 3, MONTHS, 12);
	if (month == int_nil) {
		return GDK_FAIL;	/* syntax error */
	}
	if (!GDKisdigit(buf[pos])) {
		return GDK_FAIL;	/* syntax error */
	}
	while (GDKisdigit(buf[pos])) {
		day = (buf[pos] - '0') + day * 10;
		pos++;
		if (day > 31)
			break;
	}
	/* handle semantic error here (returns nil in that case) */
	*d = todate(day, month, yearneg ? -year : year);
	return GDK_SUCCEED;
}

int
tzone_set_local(tzone *z)
{
	tzone_local = *z;
	return GDK_SUCCEED;
}

int
tzone_get_local(tzone *z)
{
	*z = tzone_local;
	return GDK_SUCCEED;
}

/* Returns month number [1-12] from a string (or nil if does not match any). */
int
month_from_str(int *ret, str month)
{
	parse_substr(ret, month, 3, MONTHS, 12);
	return GDK_SUCCEED;
}

/* Returns month name from a number between [1-7], str(nil) otherwise. */
int
month_to_str(str *ret, int *month)
{
	*ret = GDKstrdup(MONTHS[(*month < 1 || *month > 12) ? 0 : *month]);
	return GDK_SUCCEED;
}

/* Returns number of day [1-7] from a string (or nil if does not match any). */
int
day_from_str(int *ret, str day)
{
	parse_substr(ret, day, 3, DAYS, 7);
	return GDK_SUCCEED;
}

/* Returns day name from a number between [1-7], str(nil) otherwise. */
int
day_to_str(str *ret, int *day)
{
	*ret = GDKstrdup(DAYS[(*day < 1 || *day > 7) ? 0 : *day]);
	return GDK_SUCCEED;
}

/* creates a date from (day,month,year) parameters */
int
date_create(date *ret, int *year, int *month, int *day)
{
	*ret = todate(*day, *month, *year);
	return GDK_SUCCEED;
}

/* creates a daytime from (hours,minutes,seconds,milliseconds) parameters */
int
daytime_create(daytime *ret, int *hour, int *min, int *sec, int *msec)
{
	*ret = totime(*hour, *min, *sec, *msec);
	return GDK_SUCCEED;
}

/* creates a timestamp from (date,daytime) parameters */
int
timestamp_create(timestamp *ret, date *d, daytime *t, tzone *z)
{
	if (*d == date_nil || *t == daytime_nil || tz_isnil(*z)) {
		*ret = *ts_nilptr;
	} else {
		lng add = get_offset(z) * (lng) -60000;

		ret->days = *d;
		ret->msecs = *t;
		if (z->dst) {
			timestamp tmp;

			if (timestamp_inside(&tmp, ret, z, (lng) -3600000)) {
				*ret = tmp;
			}
		}
		timestamp_add(ret, ret, &add);
	}
	return GDK_SUCCEED;
}

int
timestamp_create_default(timestamp *ret, date *d, daytime *t)
{
	return timestamp_create(ret, d, t, &tzone_local);
}

/* extracts year from date (value between -5867411 and +5867411). */
int
date_extract_year(int *ret, date *v)
{
	if (*v == date_nil) {
		*ret = int_nil;
	} else {
		fromdate((int) *v, &dummy, &dummy, ret);
	}
	return GDK_SUCCEED;
}

/* extracts month from date (value between 1 and 12) */
int
date_extract_month(int *ret, date *v)
{
	if (*v == date_nil) {
		*ret = int_nil;
	} else {
		fromdate((int) *v, &dummy, ret, &dummy);
	}
	return GDK_SUCCEED;
}

/* extracts day from date (value between 1 and 31)*/
int
date_extract_day(int *ret, date *v)
{
	if (*v == date_nil) {
		*ret = int_nil;
	} else {
		fromdate((int) *v, ret, &dummy, &dummy);
	}
	return GDK_SUCCEED;
}

/* Returns N where d is the Nth day of the year (january 1 returns 1). */
int
date_extract_dayofyear(int *ret, date *v)
{
	if (*v == date_nil) {
		*ret = int_nil;
	} else {
		int year;

		fromdate((int) *v, &dummy, &dummy, &year);
		*ret = (int) (1 + *v - todate(1, 1, year));
	}
	return GDK_SUCCEED;
}

/* Returns the week number */
int
date_extract_weekofyear(int *ret, date *v)
{
	if (*v == date_nil) {
		*ret = int_nil;
	} else {
		int year, dayofweek;
		date year_jan_1;

		fromdate((int) *v, &dummy, &dummy, &year);
		dayofweek = date_dayofweek(year_jan_1 = todate(1, 1, year));

		if (dayofweek <= 4) {
			/* week of jan 1 belongs to this year */
			*ret = (int) (1 + (*v - year_jan_1 + dayofweek - 1) / 7);
		} else if (*v - year_jan_1 > 7 - dayofweek) {
			/* week of jan 1 belongs to last year; but this is a later week */
			*ret = (int) ((*v - year_jan_1 + dayofweek - 1) / 7);
		} else {
			/* recurse to get last weekno of previous year (it is 52 or 53) */
			date lastyear_dec_31 = todate(31, 12, (year == 1) ? -1 : year - 1);

			return date_extract_weekofyear(ret, &lastyear_dec_31);
		}
	}
	return GDK_SUCCEED;
}

/* Returns the current day  of the week where 1=monday, .., 7=sunday */
int
date_extract_dayofweek(int *ret, date *v)
{
	if (*v == date_nil) {
		*ret = int_nil;
	} else {
		*ret = date_dayofweek(*v);
	}
	return GDK_SUCCEED;
}

/* extracts hour from daytime (value between 0 and 23) */
int
daytime_extract_hours(int *ret, daytime *v)
{
	if (*v == daytime_nil) {
		*ret = int_nil;
	} else {
		fromtime((int) *v, ret, &dummy, &dummy, &dummy);
	}
	return GDK_SUCCEED;
}

/* extracts minutes from daytime (value between 0 and 59) */
int
daytime_extract_minutes(int *ret, daytime *v)
{
	if (*v == daytime_nil) {
		*ret = int_nil;
	} else {
		fromtime((int) *v, &dummy, ret, &dummy, &dummy);
	}
	return GDK_SUCCEED;
}

/* extracts seconds from daytime (value between 0 and 59) */
int
daytime_extract_seconds(int *ret, daytime *v)
{
	if (*v == daytime_nil) {
		*ret = int_nil;
	} else {
		fromtime((int) *v, &dummy, &dummy, ret, &dummy);
	}
	return GDK_SUCCEED;
}

/* extracts milliseconds from daytime (value between 0 and 999) */
int
daytime_extract_milliseconds(int *ret, daytime *v)
{
	if (*v == daytime_nil) {
		*ret = int_nil;
	} else {
		fromtime((int) *v, &dummy, &dummy, &dummy, ret);
	}
	return GDK_SUCCEED;
}

int
daytime_add(daytime *ret, daytime *v, lng *msec)
{
	if (*v == daytime_nil) {
		*ret = int_nil;
	} else {
		*ret = *v + (daytime) (*msec);
	}
	return GDK_SUCCEED;
}

/* extracts daytime from timestamp */
int
timestamp_extract_daytime(daytime *ret, timestamp *t, tzone *z)
{
	if (ts_isnil(*t) || tz_isnil(*z)) {
		*ret = daytime_nil;
	} else {
		timestamp tmp;

		if (timestamp_inside(&tmp, t, z, (lng) 0)) {
			lng add = (lng) 3600000;

			timestamp_add(&tmp, &tmp, &add);
		}
		if (ts_isnil(tmp)) {
			*ret = daytime_nil;
		} else {
			*ret = tmp.msecs;
		}
	}
	return GDK_SUCCEED;
}

int
timestamp_extract_daytime_default(daytime *ret, timestamp *t)
{
	return timestamp_extract_daytime(ret, t, &tzone_local);
}

/* extracts date from timestamp */
int
timestamp_extract_date(date *ret, timestamp *t, tzone *z)
{
	if (ts_isnil(*t) || tz_isnil(*z)) {
		*ret = date_nil;
	} else {
		timestamp tmp;

		if (timestamp_inside(&tmp, t, z, (lng) 0)) {
			lng add = (lng) 3600000;

			timestamp_add(&tmp, &tmp, &add);
		}
		if (ts_isnil(tmp)) {
			*ret = date_nil;
		} else {
			*ret = tmp.days;
		}
	}
	return GDK_SUCCEED;
}

int
timestamp_extract_date_default(date *ret, timestamp *t)
{
	return timestamp_extract_date(ret, t, &tzone_local);
}

/* returns the date that comes a number of years after 'v' (or before iff *delta < 0). */
int
date_addyears(date *ret, date *v, int *delta)
{
	if (*v == date_nil || *delta == int_nil) {
		*ret = date_nil;
	} else {
		int d, m, y, x, z = *delta;

		fromdate((int) *v, &d, &m, &y);
		if (m >= 3) {
			y++;
		}
		*ret = *v;
		while (z > 0) {
			x = YEARDAYS(y);
			date_adddays(ret, ret, &x);
			z--;
			y++;
		}
		while (z < 0) {
			z++;
			y--;
			x = -YEARDAYS(y);
			date_adddays(ret, ret, &x);
		}
	}
	return GDK_SUCCEED;
}

/* returns the date that comes a number of months after 'v' (or before iff *delta < 0). */
int
date_addmonths(date *ret, date *v, int *delta)
{
	if (*v == date_nil || *delta == int_nil) {
		*ret = date_nil;
	} else {
		int d, m, y, x, z = *delta;

		fromdate((int) *v, &d, &m, &y);
		*ret = *v;
		while (z > 0) {
			z--;
			x = MONTHDAYS(m, y);
			if (++m == 13)
				m = 1;
			date_adddays(ret, ret, &x);
		}
		while (z < 0) {
			z++;
			if (--m == 0)
				m = 12;
			x = -MONTHDAYS(m, y);
			date_adddays(ret, ret, &x);
		}
	}
	return GDK_SUCCEED;
}

/* returns the date that comes a number of day after 'v' (or before iff *delta < 0). */
int
date_adddays(date *ret, date *v, int *delta)
{
	lng min = DATE_MIN, max = DATE_MAX;
	lng cur = (lng) *v, inc = *delta;

	if (cur == int_nil || inc == int_nil || (inc > 0 && (max - cur) < inc) || (inc < 0 && (min - cur) > inc)) {
		*ret = date_nil;
	} else {
		*ret = *v + *delta;
	}
	return GDK_SUCCEED;
}




/* returns the number of days between 'val1' and 'val2'. */
int
date_diff(int *ret, date *v1, date *v2)
{
	if (*v1 == date_nil || *v2 == date_nil) {
		*ret = int_nil;
	} else {
		*ret = (int) (*v1 - *v2);
	}
	return GDK_SUCCEED;
}

/* returns the timestamp that comes 'milliseconds' after 'value'. */
int
timestamp_add(timestamp *ret, timestamp *v, lng *msecs)
{
	if (!ts_isnil(*v) && *msecs != lng_nil) {
		int days = (int) (*msecs / (24 * 60 * 60 * 1000));

		ret->msecs = (int) (v->msecs + (*msecs - ((lng) days) * (24 * 60 * 60 * 1000)));
		ret->days = v->days;
		if (ret->msecs >= (24 * 60 * 60 * 1000)) {
			days++;
			ret->msecs -= (24 * 60 * 60 * 1000);
		} else if (ret->msecs < 0) {
			days--;
			ret->msecs += (24 * 60 * 60 * 1000);
		}
		if (days) {
			date_adddays(&ret->days, &ret->days, &days);
			if (ret->days == int_nil) {
				*ret = *ts_nilptr;
			}
		}
	} else {
		*ret = *ts_nilptr;
	}
	return GDK_SUCCEED;
}


/* returns the number of milliseconds between 'val1' and 'val2'. */
int
timestamp_diff(lng *ret, timestamp *v1, timestamp *v2)
{
	if (ts_isnil(*v1) || ts_isnil(*v2)) {
		*ret = lng_nil;
	} else {
		*ret = ((lng) (v1->days - v2->days)) * ((lng) 24 * 60 * 60 * 1000) + ((lng) (v1->msecs - v2->msecs));
	}
	return GDK_SUCCEED;
}


/* return whether DST holds in the tzone at a certain point of time. */
int
timestamp_inside_dst(bit *ret, timestamp *p, tzone *z)
{
	*ret = FALSE;

	if (tz_isnil(*z)) {
		*ret = bit_nil;
	} else if (z->dst) {
		timestamp tmp;

		if (timestamp_inside(&tmp, p, z, (lng) 0)) {
			*ret = TRUE;
		}
	}
	return GDK_SUCCEED;
}

/* create a DST start/end date rule. */
int
rule_create(rule *ret, int *month, int *day, int *weekday, int *minutes)
{
	ret->asint = int_nil;
	if (*month >= 1 && *month <= 12 && ABS(*weekday) <= 7 && *minutes >= 0 && *minutes < 24 * 60 && ABS(*day) >= 1 && ABS(*day) <= NODAYS[*month] && (*weekday || *day > 0)) {
		ret->s.month = *month;
		ret->s.day = DAY_ZERO + *day;
		ret->s.weekday = WEEKDAY_ZERO + *weekday;
		ret->s.minutes = *minutes;
	}
	return GDK_SUCCEED;
}

/* create a tzone as a simple hour difference from GMT. */
int
tzone_create_dst(tzone *ret, int *minutes, rule *start, rule *end)
{
	*ret = *tz_nilptr;
	if (*minutes != int_nil && ABS(*minutes) < 24 * 60 && start->asint != int_nil && end->asint != int_nil) {
		set_offset(ret, *minutes);
		ret->dst = TRUE;
		ret->dst_start = get_rule(*start);
		ret->dst_end = get_rule(*end);
	}
	return GDK_SUCCEED;
}

/* create a tzone as an hour difference from GMT and a DST. */
int
tzone_create(tzone *ret, int *minutes)
{
	*ret = *tz_nilptr;
	if (*minutes != int_nil && ABS(*minutes) < 24 * 60) {
		set_offset(ret, *minutes);
		ret->dst = FALSE;
	}
	return GDK_SUCCEED;
}

/* extract month from rule. */
int
rule_extract_month(int *ret, rule *r)
{
	*ret = (r->asint == int_nil) ? int_nil : r->s.month;
	return GDK_SUCCEED;
}

/* extract day from rule. */
int
rule_extract_day(int *ret, rule *r)
{
	*ret = (r->asint == int_nil) ? int_nil : r->s.day - DAY_ZERO;
	return GDK_SUCCEED;
}

/* extract weekday from rule. */
int
rule_extract_weekday(int *ret, rule *r)
{
	*ret = (r->asint == int_nil) ? int_nil : r->s.weekday - WEEKDAY_ZERO;
	return GDK_SUCCEED;
}

/* extract minutes from rule. */
int
rule_extract_minutes(int *ret, rule *r)
{
	*ret = (r->asint == int_nil) ? int_nil : r->s.minutes;
	return GDK_SUCCEED;
}

/* extract rule that determines start of DST from tzone. */
int
tzone_extract_start(rule *ret, tzone *t)
{
	if (tz_isnil(*t) || !t->dst) {
		ret->asint = int_nil;
	} else {
		set_rule(*ret, t->dst_start);
	}
	return GDK_SUCCEED;
}

/* extract rule that determines end of DST from tzone. */
int
tzone_extract_end(rule *ret, tzone *t)
{
	if (tz_isnil(*t) || !t->dst) {
		ret->asint = int_nil;
	} else {
		set_rule(*ret, t->dst_end);
	}
	return GDK_SUCCEED;
}

/* extract number of minutes that tzone is offset wrt GMT. */
int
tzone_extract_minutes(int *ret, tzone *t)
{
	*ret = (tz_isnil(*t)) ? int_nil : get_offset(t);
	return GDK_SUCCEED;
}

int
date_sub_sec_interval_wrap(date *ret, date *t, int *sec)
{
	if (*sec > 0) {
		int delta = -(*sec / 86400);

		return date_adddays(ret, t, &delta);
	}

	return GDK_SUCCEED;
}
int
date_sub_sec_interval_lng_wrap(date *ret, date *t, lng *sec)
{
	if (*sec > 0) {
		int delta = (int) -(*sec / 86400);

		return date_adddays(ret, t, &delta);
	}

	return GDK_SUCCEED;
}

int
date_add_sec_interval_wrap(date *ret, date *t, int *sec)
{
	if (*sec > 0) {
		int delta = *sec / 86400;

		return date_adddays(ret, t, &delta);
	}

	return GDK_SUCCEED;
}
int
date_add_sec_interval_lng_wrap(date *ret, date *t, lng *sec)
{
	if (*sec > 0) {
		int delta = (int) (*sec / 86400);

		return date_adddays(ret, t, &delta);
	}

	return GDK_SUCCEED;
}

int
date_sub_month_interval_wrap(date *ret, date *t, int *months)
{
	return date_addmonths(ret, t, months);
}

/* compute the date from a rule in a certain year. */
int
compute_rule_foryear(date *ret, rule *val, int *year)
{
	if (*(int *) val == int_nil || *year < YEAR_MIN || *year > YEAR_MAX) {
		*ret = date_nil;
	} else {
		*ret = compute_rule(val, *year);
	}
	return GDK_SUCCEED;
}

@= isnil
int @1_isnil(bit *retval, @1 *val)
{
	*retval = *val == @1_nil;
	return GDK_SUCCEED;
}
@c
@:isnil(date)@
@:isnil(daytime)@

@= compare
int @1_comp_@2(bit *retval, @1 *val1, @1 *val2)
{
	if (*val1 == @1_nil || *val2 == @1_nil)
		*retval = bit_nil;
	else
		*retval = *val1 @3 *val2;
	return GDK_SUCCEED;
}
@c
@:compare(date,EQ,==)@
@:compare(date,NE,!=)@
@:compare(date,LT,<)@
@:compare(date,GT,>)@
@:compare(date,LE,<=)@
@:compare(date,GE,>=)@
@:compare(daytime,EQ,==)@
@:compare(daytime,NE,!=)@
@:compare(daytime,LT,<)@
@:compare(daytime,GT,>)@
@:compare(daytime,LE,<=)@
@:compare(daytime,GE,>=)@

int
timestamp_isnil(bit *retval, timestamp *val)
{
	*retval = ts_isnil(*val);
	return GDK_SUCCEED;
}

int
timestamp_comp_EQ(bit *retval, timestamp *val1, timestamp *val2)
{
	if (ts_isnil(*val1) || ts_isnil(*val2))
		*retval = bit_nil;
	else
		*retval = val1->days == val2->days && val1->msecs == val2->msecs;
	return GDK_SUCCEED;
}

int
timestamp_comp_NE(bit *retval, timestamp *val1, timestamp *val2)
{
	if (ts_isnil(*val1) || ts_isnil(*val2))
		*retval = bit_nil;
	else
		*retval = val1->days != val2->days || val1->msecs != val2->msecs;
	return GDK_SUCCEED;
}

int
timestamp_comp_LT(bit *retval, timestamp *val1, timestamp *val2)
{
	if (ts_isnil(*val1) || ts_isnil(*val2))
		*retval = bit_nil;
	else
		*retval = val1->days < val2->days || (val1->days == val2->days && val1->msecs < val2->msecs);
	return GDK_SUCCEED;
}

int
timestamp_comp_LE(bit *retval, timestamp *val1, timestamp *val2)
{
	if (ts_isnil(*val1) || ts_isnil(*val2))
		*retval = bit_nil;
	else
		*retval = val1->days < val2->days || (val1->days == val2->days && val1->msecs <= val2->msecs);
	return GDK_SUCCEED;
}

int
timestamp_comp_GT(bit *retval, timestamp *val1, timestamp *val2)
{
	if (ts_isnil(*val1) || ts_isnil(*val2))
		*retval = bit_nil;
	else
		*retval = val1->days > val2->days || (val1->days == val2->days && val1->msecs > val2->msecs);
	return GDK_SUCCEED;
}

int
timestamp_comp_GE(bit *retval, timestamp *val1, timestamp *val2)
{
	if (ts_isnil(*val1) || ts_isnil(*val2))
		*retval = bit_nil;
	else
		*retval = val1->days > val2->days || (val1->days == val2->days && val1->msecs >= val2->msecs);
	return GDK_SUCCEED;
}

int
CMDmsec(lng *r)
{
#ifdef HAVE_GETTIMEOFDAY
        struct timeval tp;

        gettimeofday(&tp, NULL);
        *r = ((lng) (tp.tv_sec)) * LL_CONSTANT(1000) + (lng) tp.tv_usec / LL_CONSTANT(1000);
#else
#ifdef HAVE_FTIME
        struct timeb tb;

        ftime(&tb);
        *r = ((lng) (tb.time)) * LL_CONSTANT(1000) + ((lng) tb.millitm);
#endif
#endif
	return GDK_SUCCEED;
}
