@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2007 CWI.
@' All Rights Reserved.

@f constant
@a Peter Boncz 
@v 0.1 
@t Constant BAT Algebra

Front-ends that represent tables as BAT[void,T] may try to optimize the
sitation that the tail value is equal for all tuples (a 'constant column').

This may happen in SQL, but is especially prevalent in Xquery. It is hard
to optimize away constants inside GDK. Also, even if the storage layer could
prevent the allocation of full column space for a constant, the BAT algebra
operators that work on top of it, should often perform a different
(simpler) operation than the normal algorithm (think of texist, join, etc).
Therefore, it seems that the algebra language level would be a good place to 
handle constant optimizations.

This module is a first attempt to do so.

The below MIL constant algebra provides BAT algebra-like functionality on 
MIL columns represented as single constants. It should be loaded *before*
any of the (bat,algebra,xtables) modules, because it uses the *any* type 
to indicate constant parameters in the command signatures. The variants 
where 'any' resolves to 'BAT', are covered by the respective modules 
(bat,algebra,xtables,aggrX3,malalgebra), that may be loaded subsequently.

Representing a column by a single value is not a full representation of the column.
The missing information is the size of the column and its seqbase. Due to
this, the full MIL algebra cannot be supported on top of constants, and it becomes
sometimes necessary to still materialize constants. To make this possible,
the milprint_summer code introduces a variable ipik (in addition to iter-pos-kind-item),
that holds a 'true' BAT with a real void-head. 

The general principle is that the front-end should have an 'extent' BAT (in
case of XQuery, this is the ipik).  This BAT can be used as a second
parameter to 'materialize(col,extent)' whose result is a 'true' BAT. If a column 
variable is already a 'true' BAT, it is unaffected by the 'materialize()' command.

It would have been better to have the full MIL algebra supported transparently
on constants. Now the developer has to worry about all operations being supported, and
if not, use a materialize().

Hopefully, in Monet5 we will get better support for representing constant columns
in BATs that can do aways with explicit use of fake_project in the generated MIL.
@m
.MODULE constant;

.COMMAND materialize ( any::1 value, BAT[oid,any] extent ) : BAT[oid,any::1] = CMDmaterializeConst;
"makes sure the first parameter is materialized as a bat (if it was a constant, it is blown up with the extent)"

.COMMAND materialize ( BAT[oid,any::1] value, BAT[oid,any] extent ) : BAT[oid,any::1] = CMDmaterializeFake;
"makes sure the first parameter is materialized as a bat (if it was a constant, it is blown up with the extent)"

.COMMAND texist (any::1 b, any::1 h) : bit = CMDconstEqual;
"exist(b,v); where the first parameter is interpreted as a constant column"

.COMMAND find(any::1 b, oid h) : any::1 = CMDconstFirstOid;
"find(b,v); where the first parameter is interpreted as a constant column"

.COMMAND fetch (any::1 b, int h) : any::1 = CMDconstFirstInt;
"fetch(b,v); where the first parameter is interpreted as a constant column"

.COMMAND fetch (any::1 b, lng h) : any::1 = CMDconstFirstLng;
"fetch(b,v); where the first parameter is interpreted as a constant column"

.COMMAND slice (any::1 b, int lo, int hi) : any::1 = CMDconstSliceInt;
"slice(b,lo,hi); where the first parameter is interpreted as a constant column"

.COMMAND slice (any::1 b, lng lo, lng hi) : any::1 = CMDconstSliceLng;
"slice(b,lo,hi); where the first parameter is interpreted as a constant column"

.COMMAND tmark (any::1 b, oid val) : any::1 = CMDconstFirstOid;
"mark_rev(b,c); where the first parameter is interpreted as a constant column"

.COMMAND copy ( any::1 b) : any::1 = CMDconstCopy;
"copy(b); where the first parameter is interpreted as a constant column"

.COMMAND tsort ( any::1 b) : any::1 = CMDconstCopy;
"tsort(b); where the first parameter is interpreted as a constant column"

.COMMAND tsort_rev ( any::1 b) : any::1 = CMDconstCopy;
"tsort_rev(b); where the first parameter is interpreted as a constant column"

.COMMAND chk_order ( any::1 b) : any::1 = CMDconstCopy;
"chk_order(b); where the first parameter is interpreted as a constant column"

.COMMAND project(any b, any::1 val) : any::1 = CMDconstSecond;
"project(b,c); where the first parameter is interpreted as a constant column"

.COMMAND CTrefine ( BAT[oid,oid] ct, any::1 b) : BAT[oid,oid] = CMDconstFirstBat;
"CTrefine(ct,b); where the second parameter is interpreted as a constant column"

.COMMAND CTrefine_rev ( BAT[oid,oid] ct, any::1 b) : BAT[oid,oid] = CMDconstFirstBat;
"CTrefine_rev(ct,b); where the second parameter is interpreted as a constant column"

.COMMAND CTgroup ( any::1 b) : any::1 = CMDconstCopy;
"CTgroup(b); where the first parameter is interpreted as a constant column"

.COMMAND CTgroup ( BAT[oid,oid] ct, any::1 b) : BAT[oid,oid] = CMDconstFirstBat;
"CTgroup(ct,b); where the second parameter is interpreted as a constant column"

.COMMAND min ( any::1 b ) : any::1 = CMDconstCopy;
"min(b); where the first parameter is interpreted as a constant column"

.COMMAND max ( any::1 b ) : any::1 = CMDconstCopy;
"max(b); where the first parameter is interpreted as a constant column"

.COMMAND avg ( any::1 b ) : any::1 = CMDconstCopy;
"avg(b); where the first parameter is interpreted as a constant column"

.COMMAND tunique (any::1 b) : BAT[any::1,void] = CMDconstUnique;
"tunique(c); delivers a result BAT [c,nil]"

.COMMAND access (any::1 b, int mode) : any::1 = CMDconstFirstInt;
"access(b,mode); where the first parameter is interpreted as a constant column"

.COMMAND tdiff(BAT[any::1,any::2], any::2 b) : BAT[any::1,any::2] = CMDconstDiff;
"tdiff(l,r); where the second parameter is interpreted as a constant column"

.COMMAND tintersect(BAT[any::1,any::2], any::2 b) : BAT[any::1,any::2] = CMDconstIntersect;
"tintersect(l,r); where the second parameter is interpreted as a constant column"

@= join
.COMMAND @1join ( BAT[oid,oid] left, any::1 right ) : BAT[oid,any::1] = CMDconstjoinRightMat;
"@1join(l,r); where the second parameter is a constant; materialize BAT[oid,r] (assumes join hits)"

.COMMAND @1join ( BAT[void,oid] left, any::1 right ) : any::1 = CMDconstjoinRightCopy;
"@1join(l,r); where the second parameter is a constant; return r (assumes join hits)"

.COMMAND @1join ( oid left, any::1 right ) : any::1 = CMDconstjoinCopy;
"@1join(l,r); where the first parameter is a MIL constant. Return a MIL constant (assumes join hits!)."

.COMMAND @1join ( any::1 left, BAT[any::1,any::2] right ) : any::2 = CMDconst@2joinLeftCopy;
"@1join(l,r); where the first parameter is a MIL constant. Return a MIL constant."
@m
@:join()@
@:join(left)@
@:join(merge)@
@:join(leftmerge)@
@:join(fetch)@
@:join(leftfetch)@
@:join(outer,outer)@

.END constant;
@mil
proc CTgroup ( oid a, BAT[oid,any] b) : BAT[oid,oid]
{
    return CTgroup(b);
}

proc CTrefine ( oid a, any b) : oid
{
    return a;
}

proc CTrefine_rev ( oid a, any b) : oid
{
    return a;
}

proc CTrefine ( oid a, BAT[oid,any] b) : BAT[oid,oid]
{
    return tsort(b);
}

proc CTrefine_rev ( oid a, BAT[oid,any] b) : BAT[oid,oid]
{
    return tsort_rev(b);
}

proc {min} ( any::1 b, BAT[oid,oid] g, BAT[oid,any] e) : BAT[oid,any::1] 
{
    return project(e,b);
}

proc {max} ( any::1 b, BAT[oid,oid] g, BAT[oid,any] e) : BAT[oid,any::1] 
{
    return project(e,b);
}

proc {sum} ( any::1 b, BAT[oid,oid] g, BAT[oid,any] e) : BAT[oid,any::1] 
{
    var fcn := monet_atomtbl.reverse().find(b.type());
    return [*fcn]({count}(g.reverse(), e, false)).[*](b);
}

proc {avg} ( any::1 b, BAT[oid,oid] g, BAT[oid,any] e) : BAT[oid,dbl]
{
    return project(e,[dbl](b));
}
@{
@c
#include "monetdb4_config.h"
#include "constant.proto.h"

int
CMDmaterializeConst(BAT **ret, ptr val, int tpe, BAT *extent)
{
        /* due to function resolution, we know that val must be a simple constant or an illegal bat */
        if (tpe == TYPE_bat) {
                GDKerror("materialize(%s,extent): first param should have an oid head.\n",
                         BBP_logical(((BAT*) val)->batCacheid));
                return GDK_FAIL;
        }
        *ret = BATconst(extent, tpe, val);
        return *ret?GDK_SUCCEED:GDK_FAIL;
}

int
CMDmaterializeFake(BAT **ret, BAT* value, BAT *extent)
{
	(void) extent;
        *ret = value;
        BBPfix(value->batCacheid);
        return GDK_SUCCEED;
}

int
CMDconstEqual(bit *ret, ptr v1, int tpe, ptr v2)
{
        int (*cmp)(ptr, ptr) = BATatoms[tpe].atomCmp;
	if (tpe == TYPE_bat) {
		GDKerror("const operation on a BAT\n");
        	return GDK_FAIL;
        } else {
                *ret = ((*cmp)( v1, v2) == 0);
        }
        return GDK_SUCCEED;
}

int
CMDconstCopy(ptr ret, ptr val, int tpe)
{
	if (tpe == TYPE_bat) {
		GDKerror("const operation on a BAT\n");
        	return GDK_FAIL;
	} else if (ATOMextern(tpe)) {
		size_t len = ATOMlen(tpe, val);
		*(ptr*) ret = (ptr) GDKmalloc(len);
		memcpy(*(ptr*) ret, val, len); 
	} else {
		memcpy(ret, val, ATOMsize(tpe)); 
	}
        return GDK_SUCCEED;
}

int
CMDconstFirstInt(ptr ret, ptr v1, int t1, int* v2)
{
	(void) v2; 
	return CMDconstCopy(ret, v1, t1);
}

int
CMDconstFirstOid(ptr ret, ptr v1, int t1, oid* v2)
{
	(void) v2; 
	return CMDconstCopy(ret, v1, t1);
}

int
CMDconstFirstLng(ptr ret, ptr v1, int t1, lng* v2)
{
	(void) v2; 
	return CMDconstCopy(ret, v1, t1);
}

int
CMDconstFirstBat(BAT **ret, BAT* b, ptr val, int tpe)
{
	BBPfix(b->batCacheid);
	*ret = b; (void) val; (void) tpe;
	return GDK_SUCCEED;
}

int
CMDconstSliceInt(ptr ret, ptr val, int tpe, int* lo, int* hi)
{
	(void) lo; (void) hi; 
	return CMDconstCopy(ret, val, tpe);
}

int
CMDconstSliceLng(ptr ret, ptr val, int tpe, lng* lo, lng* hi)
{
	(void) lo; (void) hi; 
	return CMDconstCopy(ret, val, tpe);
}

int
CMDconstSecond(ptr ret, ptr v1, int t1, ptr v2, int t2)
{
	(void) v1;
	(void) t1;
	return CMDconstCopy(ret, v2, t2);
}

int 
CMDconstUnique(BAT** ret, ptr v, int t)
{
    
	BAT *bn = *ret = BATnew(t, TYPE_void, 1);
        if (bn) {
		oid nil = oid_nil;
		if (BUNins(bn, v, &nil, FALSE)) return GDK_SUCCEED;
		BBPreclaim(bn);
	}
	return GDK_FAIL;
}

int
CMDconstjoinRightMat(BAT **ret, BAT *b, ptr val, int tpe)
{
        /* due to function resolution, we know that val must be a simple constant or an illegal bat */
        if (tpe == TYPE_bat) {
                GDKerror("positional join(bat,%s): second param is not a dense bat.\n",
                         BBP_logical(((BAT*) val)->batCacheid));
                return GDK_FAIL;
        }
        *ret = BATconst(b, tpe, val);
        return (*ret == NULL)?GDK_FAIL:GDK_SUCCEED;
}

int
CMDconstjoinRightCopy(ptr ret, BAT *b, ptr val, int tpe)
{
        /* due to function resolution, we know that val must be a simple constant or an illegal bat */
	(void) b;
        if (tpe == TYPE_bat) {
                GDKerror("positional join(bat,%s): second param is not a dense bat.\n",
                         BBP_logical(((BAT*) val)->batCacheid));
                return GDK_FAIL;
        }
        return CMDconstCopy(ret, val, tpe);
}

int
CMDconstjoinCopy(ptr ret, oid *id, ptr val, int tpe)
{
        /* due to function resolution, we know that val must be a simple constant or an illegal bat */
	(void) id;
        if (tpe == TYPE_bat) {
                GDKerror("positional join(const,%s): second param does not have an oid-head.\n",
                         BBP_logical(((BAT*) val)->batCacheid));
                return GDK_FAIL;
        }
        return CMDconstCopy(ret, val, tpe);
}

int
CMDconstjoinLeftCopy(ptr ret, ptr val, int res, BAT *b)
{
	BAT* bn = BATuselect(BATmirror(b), val, val);
        res = GDK_FAIL;
        if (bn) {
		if (BATcount(bn) != 1) {
        		GDKerror("join(const,%s): const should match exactly once.\n",
                                BBP_logical(b->batCacheid));
		} else {
			BATiter bni = bat_iterator(bn);
        		res = CMDconstCopy(ret, BUNhead(bni,BUNfirst(bn)), ATOMtype(b->ttype));
		}
		BBPreclaim(bn);
	}
	return res;
}

int
CMDconstouterjoinLeftCopy(ptr ret, ptr val, int res, BAT *b)
{
	BAT* bn = BATuselect(BATmirror(b), val, val);
        res = GDK_FAIL;
        if (bn) {
		val = ATOMnilptr(b->ttype);
		if (BATcount(bn) == 1) {
			BATiter bni = bat_iterator(bn);
			val = BUNhead(bni,BUNfirst(bn));
		} else if (BATcount(bn) > 1) {
			val = NULL;
        		GDKerror("outerjoin(const,%s): const should match exactly once.\n",
                                BBP_logical(b->batCacheid));
		}
        	res = CMDconstCopy(ret, val, ATOMtype(b->ttype));
		BBPreclaim(bn);
	}
	return res;
}


int 
CMDconstDiff(BAT **res, BAT *l, ptr val) 
{
	int (*cmp)(ptr, ptr) = BATatoms[l->ttype].atomCmp;
	BAT *bn = BATnew(ATOMtype(l->htype), ATOMtype(l->ttype), BATcount(l));
	BUN p, q;
	if (bn) {
		BATiter li = bat_iterator(l);
		BATloop(l, p, q) {
			ptr v = BUNtail(li,p);
			if ((*cmp)(v, val)) bunfastins(bn, BUNhead(li,p), v);    
		}
		bn->hsorted = l->hsorted;
		bn->tsorted = l->tsorted;
		if (l->hkey) BATkey(bn,1);
		if (l->tkey) BATkey(BATmirror(bn),1);
		*res = bn;
		return GDK_SUCCEED;
bunins_failed:  BBPreclaim(bn);
	}
	return GDK_FAIL;
}

int 
CMDconstIntersect(BAT **res, BAT *l, ptr val) 
{
	*res = BAT_select_(l, val, val, TRUE, TRUE, TRUE, TRUE);
	return (*res)?GDK_SUCCEED:GDK_FAIL;
}
@}
