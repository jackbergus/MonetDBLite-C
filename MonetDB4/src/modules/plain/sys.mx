@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2008 CWI.
@' All Rights Reserved.

@f sys
@t System Information BATs
@a M.L. Kersten
@v 1.0
@* Introduction
This document introduces a series of pseudo bats that provide access
to information stored within the Monet internal data structures.
In all cases, the pseudo BAT operation returns a transient BAT that
should be garbage collected after being used.

The main performance drain would be to use a pseudo BAT directly to
successively access it components. This can be avoided by first assigning
the pseudo BAT to a variable.

@- useful procedures

The commands here return BATs that can be easily reused in scripts.
For @%interactive use@ there is a collection of
@[<a href=#mod_2_1_0><bf>predefined procedures</bf></a>@
that you might well find very useful.

@* Module Definition
@m
.MODULE sys;

@- Performance Stats
@m
.COMMAND view_gdk_cpu() : BAT[str,int] = view_gdk_cpu;
	"Global cpu usage info"
.COMMAND view_gdk_memory(): BAT[str,int] = view_gdk_mem;
	"Global memory usage info"
.COMMAND view_gdk_io(): BAT[str,int] = view_gdk_io;
	"Global IO activityinfo"
.COMMAND view_gdk_bbp(): BAT[str,int] = view_gdk_bbp;
	"Global BBP usage info"
.COMMAND view_gdk_mem_histo() : BAT[lng,lng] = view_gdk_mem_histo;
	"Global memory histogram"
.COMMAND view_gdk_vm_histo() : BAT[lng,lng] = view_gdk_vm_histo;
	"Global virtual memory histogram"

.COMMAND mem_printmap() : void = print_mem_map;
        "print a map of all memory that is in use"
.COMMAND mem_colormap() : void = print_color_map;
        "print a color map of all memory that is in use"
@T
For each 64KB block in the first 3GB of the virtual memory {\tt mem\_printmap()} prints a character:
\begin{verbatim}
0-9 - thread stack space of thread <num>
B - in use for a large BAT heap (i.e. anonymous virtual memory).
b - free (last usage was B)
S - in use for a malloc block
s - free (last usage was S)
P - in use for the BBP array (i.e. anonymous virtual memory)
p - free (last usage was P)
M - in use as memory mapped region
m - free (last usage was M)
C - in use as MIL context buffer (i.e. anonymous virtual memory)
c - free (last usage was c)
\end{verbatim}
On Linux, the malloc library appears to be using anonymous virtual memory, which goes undetected.
If you want to see all your memory in the map, lower the gdk\_mem\_bigsize threshold in MonetDB.conf to a
low value (say 64KB).
@m
.COMMAND mem_cursize() : lng = get_mem_cursize;
 	"the amount of physical swapspace in KB that is currently in use"
.COMMAND mem_maxsize() : lng = get_mem_maxsize;
 	"the maximum usable amount of physical swapspace in KB (target only)"
.COMMAND mem_maxsize(lng) : void = set_mem_maxsize;
 	"set the maximum usable amount of physical swapspace in KB"
.COMMAND vm_cursize() : lng = get_vm_cursize;
 	"the amount of logical VM space in KB that is currently in use"
.COMMAND vm_minsize() : lng = get_vm_minsize;
 	"Get the threshold. Block larger then this threshold will be mmapped."
.COMMAND vm_minsize(lng) : void = set_vm_minsize;
 	"Set the threshold. Block larger then this threshold will be mmapped."
.COMMAND vm_maxsize() : lng = get_vm_maxsize;
 	"the maximum usable amount of logical VM space in KB (target only)"
.COMMAND vm_maxsize(lng) : void = set_vm_maxsize;
 	"set the maximum usable amount of physical swapspace in KB"
.COMMAND mem_bigsize() : lng = get_mem_bigsize;
	"returns threshold after which memory allocations come from anonymous VM"
.COMMAND mem_bigsize(lng) : void = set_mem_bigsize;
	"sets threshold after which memory allocations come from anonymous VM"
.COMMAND mem_usage(lng minsize) : BAT[str,lng] = get_mem_usage;
 	"get a split-up of how much memory blocks are in use."
.COMMAND vm_usage(lng minsize) : BAT[str,lng] = get_vm_usage;
	"get a split-up of how much virtual memory blocks are in use."
.COMMAND vm_trim(lng maxsize) : void = vm_trim;
	"flush memory maps"
@T
Some explanation of what mem\_usage() and vm\_usage() display:
\begin{verbatim}
> mem_usage().print();
#------------------------------#
# BAT:                 tmp_42  #
# (str)                (lng)   #
#------------------------------#
[ "buns/car_category",  400012 ] 100.000 string offsets
[ "buns/car_town",      400012 ] idem
[ "buns/car_class",     400012 ] idem
[ "tail/car_category",  266244 ] string tail heap
[ "tail/car_town",      266244 ] idem
[ "tail/car_class",     266244 ] idem
[ "_tot/buns",         1322996 ] the three bun heaps
[ "_tot/tail",          967762 ] the three tail heaps
[ "_tot/head",           70984 ] negligable
[ "_tot/bbp",            98866 ] BBP metadata structure
[ "_tot/mil",           102400 ] MIL interpreter stack space
[ "_tot/found",        2590144 ] buns+head+tail+bbp+mil
[ "_tot/malloc_heap",  2956048 ] in malloc heap
[ "_tot/malloc",       2956048 ] total consumed via malloc
[ "_tot/valloc",        201266 ] total consumed via virtualalloc
[ "_tot/mem",          3157314 ] total RAM+swap-file consumption
>
> vm_usage().print();
#------------------------------#
# BAT:               tmp_42    #
# (str)              (lng)     #
#------------------------------#
[ "_tot/bbp",        50331648  ] 50MB reserved (100KB claimed)
[ "_tot/mil",        16777216  ] 16MB reserved (100KB claimed)
[ "_tot/found",      67108864  ] bbp+mil
[ "_tot/vm",         71244560  ] total address space consumption
>
\end{verbatim}

@- BAT Buffer Pool
@m
.COMMAND view_bbp_name(): BAT[int,str] = view_bbp_name;
	"Pseudo bat to map a BAT id into its name"
.COMMAND view_bbp_htype(): BAT[int,str] = view_bbp_htype;
	"Pseudo bat to map a BAT id into its head type"
.COMMAND view_bbp_ttype(): BAT[int,str] = view_bbp_ttype;
	"Pseudo bat to map a BAT id into its tail type"
.COMMAND view_bbp_count(): BAT[int,lng] = view_bbp_count;
	"Pseudo bat to map a BAT id into its count"
.COMMAND view_bbp_refcnt(): BAT[int,int] = view_bbp_refcnt;
	"Pseudo bat to map a BAT id into its reference count"
.COMMAND view_bbp_lrefcnt(): BAT[int,int] = view_bbp_lrefcnt;
	"Pseudo bat to map a BAT id into its logical reference count"
.COMMAND view_bbp_location(): BAT[int,str] = view_bbp_location;
	"Pseudo bat to map a BAT id into its disk location"
.COMMAND view_bbp_heat(): BAT[int,int] = view_bbp_heat;
	"Pseudo bat to map a BAT id into its name"
.COMMAND view_bbp_dirty(): BAT[int,str] = view_bbp_dirty;
	"Pseudo bat to map a BAT id into its dirty/diffs/clean status"
.COMMAND view_bbp_status(): BAT[int,str] = view_bbp_status;
	"Pseudo bat to map a BAT id into its disk/load status"
.COMMAND view_bbp_kind(): BAT[int,str] = view_bbp_kind;
	"Pseudo bat to map a BAT id into its type"

.COMMAND check_bbp_size() : lng = check_bbp_size;
	"Walk the BBP directories, delete leftovers and return total size"

.COMMAND bbp_batcache_minsize(wrd minsize) : wrd = bbp_batcache_minsize;
	"set the minimum size (BUN count) for bats to be cached"

@- GDK status
@m
.COMMAND view_gdk_env( ): BAT[str,str] = view_gdk_env;
	"List the values of all environment variables"
.COMMAND view_gdk_thread( ): BAT[int,str] = view_gdk_thread;
	"Pseudo bat to map thread to name"
@- ATOM table status
@m
.COMMAND view_atom_name() : BAT[int,str] = view_atom_name;
	"Global type table names"
.COMMAND view_atom_align() : BAT[int,int] = view_atom_align;
	"Global type table alignment property"
.COMMAND view_atom_size() : BAT[int,int] = view_atom_size;
	"Global type table sizement property"

@- Monet Client Data
@m
.COMMAND view_client_name( ): BAT[int,str] = view_client_name;
	"Pseudo bat to map client identifier to its name"
.COMMAND view_client_login( ): BAT[int,str] = view_client_login;
	"Pseudo bat to map client identifier to its login time"
.COMMAND view_client_tree( ): BAT[int,str] = view_client_tree;
	"Pseudo bat to map client identifier to its current active tree"
.COMMAND view_client_size(int client) : BAT[str,lng] = view_client_size;
 	"get an overview of client buffer use (contexts, variables, trees)."

@- Monet Variables
@m
.BUILTIN view_var_name() : BAT[int,str] = view_var_name;
	"Pseudo bat to map variable id to its name."
.BUILTIN view_var_type() : BAT[int,str] = view_var_type;
	"Pseudo bat to map variable id to its type (as a string)."
.BUILTIN view_var_kind() : BAT[int,str] = view_var_kind;
	"Pseudo bat to map variable id to frozen/liquid"
.BUILTIN view_var_constant() : BAT[int,str] = view_var_constant;
	"Pseudo bat to map variable id to constant/changeable"
.BUILTIN view_var_value() : BAT[int,str] = view_var_value;
	"Pseudo bat to map variable id to its value (as a string)."

@- Monet Modules
@m
.COMMAND view_modules() : BAT[int,str] = view_modules;
	"Pseudo bat with all currently available modules"
.COMMAND module_name(str) : str = get_mod_name;
	"extract module name from module string"
.COMMAND module_db(str) : str = get_mod_db;
	"extract database name from module string"
.COMMAND format_fcn_sig(oid) : str = format_fcn_sig;
	"print a function signature"
.END sys;

@+ MIL Procedure definitions
@mil
    CONST monet_environment := bat("monet_environment");

    PROC help_tpe(int tpe) : str {
	IF (tpe = TOK_PROC) RETURN "PROC:      ";
	ELSE IF (tpe = TOK_COMMAND) RETURN "COMMAND:   ";
	ELSE IF (tpe = TOK_BUILTIN) RETURN "BUILTIN:   ";
	ELSE IF (tpe = TOK_ITERATOR) RETURN "ITERATOR:  ";
	RETURN "OPERATOR:  ";
    }

    PROC help_sig(oid fid) : void {
	printf("%s%s\n",
            help_tpe(monet_fcn_tpe.find(fid)), format_fcn_sig(fid));
	if (monet_fcn_mid.exist(fid)) {
            VAR mn := monet_mod_nme.find(monet_fcn_mid.find(fid));
            if (mn.startsWith("_")) {
                mn := string(mn,1);
            }
	    printf("MODULE:    %s\n", mn);
        }
	if (and(monet_fcn_aut.exist(fid), monet_fcn_dat.exist(fid))) {
	    printf("COMPILED:  by %s on %s\n",
                monet_fcn_aut.find(fid), monet_fcn_dat.find(fid));
        }
	if (monet_fcn_dsc.exist(fid)) {
	    printf("%s\n", monet_fcn_dsc.find(fid));
        } else {
	    printf("no text available\n");
        }
    }

    PROC help():void{}; # forward decl
    PROC help(str fcn) : void {
	IF (monet_fcn_nme.reverse().exist(fcn)) monet_fcn_nme.reverse()@hashloop(fcn) {
	    help_sig($t); printf("\n");
	} ELSE {
	    printf("no help available\n");
	}
    }

    # self help
    ADDHELP("help", "boncz", "Feb  6 1996",
         "provide help for a MIL construct.", "sys");

    PROC rename(BAT[any::1,any::2] b, str name) : bat[any::1,any::2] {
	if (not(b.bbpname(name))) ERROR("rename(%s,%s): operation failed\n", str(b), name);
	return b;
    }
    ADDHELP("rename", "boncz", "Feb  6 1996",
         "try to name a BAT and fail if it is not possible.", "sys");

    PROC modules() : void {
	var b := view_modules().reverse().kunique().reverse();
	table(1,[module_name](b).reverse().sort().reverse().col_name("name"),
		[module_db](b).col_name("database"));

    }
    ADDHELP("modules", "boncz", "Aug 14 1997",
	"list all installed modules, plus owner and db restrictions", "sys");

    PROC loaded() : void {
        var hidden := monet_mod_nme.semijoin(monet_mod_nme.[startsWith]("_").uselect(true));
	var mods := monet_mod_use.select(clientid()).reverse().histogram();
        var nmes := mods.mirror().join(monet_mod_nme).kdiff(hidden).access(BAT_WRITE);
        var disappeared := hidden.reverse().kdiff([+]("_",nmes).reverse()).reverse();
	table(1, nmes.insert(disappeared).reverse().sort().reverse().col_name("module"),
                 mods.col_name("usage_count"));
    }
    ADDHELP("loaded", "boncz", "Feb  6 1996",
	"list all loaded modules, and the number of active users.", "sys");

    PROC atoms():void {
	table(1,view_atom_name().col_name("atom type"),
		view_atom_size().col_name("size"),
		view_atom_align().col_name("alignment"));
    }
    PROC sigs(str modname) : void {
	var modname2;
	if (modname.startsWith("_")) {
	    modname2 := string(modname,1);
	} else {
	    modname2 := "_" + modname;
	}
	if (monet_mod_nme.reverse().exist(modname)) {
	    var o := monet_mod_nme.reverse().find(modname);
	    var m := monet_fcn_mid.uselect(o);
	    if (monet_mod_nme.reverse().exist(modname2)) {
	    	o := monet_mod_nme.reverse().find(modname2);
	    	m := union(m,monet_fcn_mid.uselect(o));
	    }
	    var b := [format_fcn_sig](m.reverse());
	    table(1,b.reverse().sort().reverse().col_name("signature"));
	} else if ([module_name](view_modules()).reverse().exist(modname)) {
  	    ERROR("sigs: must load module first.\n");
	} else {
  	    ERROR("sigs: module does not exist.\n");
	}
    }
    ADDHELP("sigs", "boncz", "Aug  2 1996",
	"Show all signatures of the functions in a module.", "sys");

    proc dir(bat[int,str] b) : void {
        var nme := view_bbp_name();
	var ht  := view_bbp_htype();
	var tt  := view_bbp_ttype();
	var cnt  := view_bbp_count();

        var heat :=  view_bbp_heat(); heat.col_name("heat");
        var dirty :=  view_bbp_dirty(); dirty.col_name("dirty");
        var status :=  view_bbp_status(); status.col_name("status");
        var kind :=  view_bbp_kind(); kind.col_name("kind");
        var refcnt :=  view_bbp_refcnt(); refcnt.col_name("refcnt");
        var lrefcnt :=  view_bbp_lrefcnt(); lrefcnt.col_name("lrefcnt");

	var rev := reverse(semijoin(reverse(b),select(reverse(nme),int(nil),-1))).mirror();
	var rst := b.kdiff(rev).mirror();

        table(1, b.reverse().sort().reverse().col_name("name"),
		rst.join(ht).kunion(rev.join(tt)).col_name("htype"),
		rst.join(tt).kunion(rev.join(ht)).col_name("ttype"),
                cnt.semijoin(b.mirror()).col_name("count"),
                heat, dirty,status,kind,refcnt,lrefcnt);
    }

    PROC dir() : void {
        var nme := view_bbp_name().copy().access(BAT_WRITE);
	    nme.col_name("name");
	var rev := [*](nme.reverse().select(int(nil),-1),-1).reverse();
	dir(nme.replace(rev));
    }
    PROC dir(str substr) : void {
        var nme := view_bbp_name();
        var rev := [*](nme.reverse().select(int(nil),-1),-1).reverse();
	nme.access(BAT_WRITE);
	nme.col_name("name");
	# now we have the correct bbp including reverses, lets replace these 
	nme.replace(rev);
	dir(nme.like(substr));
    }
    ADDHELP("dir", "boncz", "Feb  6 1996",
	"list all bats, including system bats. Optionally filter on name with a certain substring", "sys");

    proc dir_leaks() : void {
	var b0 := view_bbp_name().access(BAT_WRITE);
	b0.replace([*](b0.reverse().select(int(nil),-1),-1).reverse());
        var b1 := [startsWith](b0,"tmp_").[ifthen](b0).access(BAT_WRITE);
        var b2 := like(view_var_value(), "tmp_");
        var b3 := bat(int,str,b1.count());
        b1.delete(int(b0));
        b1@batloop() {
            var pat := "tmp_" + $h;
            if (like(b2,pat).count() = 0) b3.insert($h,$t);
        }
        dir(b3);
    }

    PROC ls() : void {
	var nme := view_bbp_name();
	var prs := nme.semijoin(view_bbp_kind().select("pers"));
	var rev := [*](nme.reverse().select(int(nil),-1),-1).reverse();
	prs.access(BAT_WRITE); prs.col_name("name"); prs.replace(rev);
	dir(prs);
    }
    ADDHELP("ls", "boncz", "Feb  6 1996",
	"list all data bats. Optionally filter on name with a certain substring", "sys");

    PROC ls(str substr) : void {
        var nme := view_bbp_name();
	var prs := nme.semijoin(view_bbp_kind().select("pers"));
	var rev := [*](nme.reverse().select(int(nil),-1),-1).reverse();
	prs.access(BAT_WRITE);
	prs.col_name("name");
	# now we have the correct bbp including reverses, lets replace these 
	prs.replace(rev);
	dir(prs.like(substr));
    }
    ADDHELP("ls", "arjen", "Jun 12 2001",
	"list all data bats filtered on name with some substring", "sys");

    PROC exit() : void {
	quit();
    }
    ADDHELP("exit", "boncz", "Jan 9 1998", "quit for consultants", "sys");

    PROC procs() : void {
	   var a := [format_fcn_sig](monet_fcntbl.reverse().
			semijoin(monet_fcn_tpe.select(TOK_PROC)).reverse());
	   table(1,a.reverse().sort().reverse().col_name("MIL Procedure"));
    }
    ADDHELP("procs", "boncz", "Feb  6 1996", "list all defined procs.", "sys");

    PROC clients() : void {
	var tree := view_client_tree().access(BAT_WRITE);
	tree.replace(clientid(), "clients()");
	print(view_client_name(),view_client_login(),tree.col_name("mil"));
    }
    ADDHELP("clients", "boncz", "Feb  6 1996",
	"list all active clients by their number.", "sys");

    PROC vars() : void  {
	table(view_var_name().kdiff([startsWith](view_var_name(), ".").uselect(true)),
              view_var_type(), view_var_kind(), view_var_constant(), view_var_value());
    }
    PROC vars(str substr) : void {
	table(view_var_name().like(substr),
              view_var_type(), view_var_kind(), view_var_constant(), view_var_value());
    }
    ADDHELP("vars", "boncz", "Feb  6 1996",
        	"list all Monet variables and their values. Optionally filter on name with a certain substring", "sys");

    PROC threads() : void { print(view_gdk_thread()); }
    ADDHELP("threads", "boncz", "Feb  6 1996",
		"list all system threads and their function.", "sys");

    PROC env() : void { print(view_gdk_env());}
    ADDHELP("env", "boncz", "Feb  6 1996",
		"list the values of all environment variables", "sys");

    PROC environment() : bat[str,str] { return view_gdk_env();}
    ADDHELP("environment", "boncz", "Mar 22 1998", "deprecated", "sys");

    PROC cpu() : bat[str,int] { RETURN view_gdk_cpu();}
    ADDHELP("cpu", "boncz", "Mar 22 1998", "Global cpu usage info", "sys");

    PROC memory() : bat[str,int] { RETURN view_gdk_memory();}
    ADDHELP("memory", "boncz", "Mar 22 1998", "Global memory usage info","sys");

    PROC io() : bat[str,int]  { RETURN view_gdk_io();}
    ADDHELP("io", "boncz", "Mar 22 1998", "Global IO activity info", "sys");

    PROC bbp() : bat[str,int] { RETURN view_gdk_bbp();}
    ADDHELP("bbp", "boncz", "Mar 22 1998", "Global BBP usage info", "sys");

    PROC readonly( BAT[any::1,any::2] b, int mode) : BAT[any::1,any::2]{
        return access(b,mode);
    }
    ADDHELP("readonly", "boncz", "Aug  6 1998",
        "deprecated. Use 'b.access()' instead.", "sys");

    PROC readonly( BAT[any::1,any::2] b) : int {
        var s := b.info().find("batRestricted");
        if (s = "updatable") {
                return BAT_WRITE;
        } else if (s = "read-only") {
                return BAT_READ;
        } else if (s = "append-only") {
                return BAT_APPEND;
        }
        ERROR("readonly: unknown mode.\n");
    }
    ADDHELP("readonly", "boncz", "Aug  6 1998",
        "deprecated. Use 'info.find(batRestricted)' instead.", "sys");

    PROC mem_usage() : BAT[str,lng] { return mem_usage(lng(100000));}
    PROC vm_usage() : BAT[str,lng] { return vm_usage(lng(100000));}
    PROC mem_usage(int minsize) : BAT[str,lng] { return mem_usage(lng(minsize));}
    PROC vm_usage(int minsize) : BAT[str,lng] { return vm_usage(lng(minsize));}

    CONST REMAP_PAGE_BITS := monet_environment.find("gdk_mem_pagebits").int();
    CONST REMAP_PAGE_SIZE := 1LL << REMAP_PAGE_BITS;
    CONST REMAP_PAGE_MASK := REMAP_PAGE_SIZE - 1LL;

    const BBPTRIM_ALL := <<(1LL, (monet_environment.find("gdk_arch").int() - 2));

@{
@* Implementation Code
@h
#ifndef _SYS_H_
#define _SYS_H_

#include "sys.proto.h"

#endif
@c
#include "monetdb4_config.h"
#include "monet.h"
#include "monet_context.h"
#include "monet_client.h"
#include "monet_parse.h"
#include "monet_deparse.h"
#include "monet_queue.h"
#include "sys.h"
#include "gdk_bbp.h"
#include <stdarg.h>
#include <time.h>

#ifdef HAVE_SYS_TIMES_H
# include <sys/times.h>
#endif

#ifndef NATIVE_WIN32
# ifndef HZ
#  if !defined(HAVE_SYSCONF) || !defined(_SC_CLK_TCK)
#   define HZ CLK_TCK
#  endif
# endif
#endif

#define PARAM(x)        (argv+x)
#define RETVAL          (argv)

@+ BBP status
The BAT buffer pool data structures describe the memory resident information
on the whereabouts of the BATs. The three predominant tables are made accessible
for inspection.

The most interesting sysbat for end-users is the BID-> NAME mapping,
because it provides access to the system guaranteed persistent BAT identifier.
@= Pseudo
	if (BBPindex("view_@1_@2") <= 0)
        	BATname(b, "@2");
        BATroles(b,"@1","@2");
	BATmode(b,TRANSIENT);
	BATfakeCommit(b);
	*retval= b;

@c
int
view_bbp_name(BAT **retval	/* put pointer to BAT[int,str] record here. */
    )
{
	BAT *b;
	int i;

	b = BATnew(TYPE_int, TYPE_str, BBPsize);
	if (b == 0)
		return GDK_FAIL;

	BBPlock("view_bbp_name");
	for (i = 1; i < BBPsize; i++)
		if (i != b->batCacheid && BBPvalid(i) && !(BBP_status(i) & BBPUNSTABLE)) {
			BUNins(b, &i, BBPname(i), FALSE);
			if (BBPvalid(-i)) {
				int j = -i;

				BUNins(b, &j, BBPname(j), FALSE);
			}
		}
	BBPunlock("view_bbp_name");
	@:Pseudo(bbp,name)@
	return GDK_SUCCEED;
}

@-
Finding all head/tail types is similar
@= bbp_types
int
view_bbp_@1(BAT** retval)	/* put pointer to BAT[int,str] record here. */
{
	BAT*    b;
        int     i;

        b= BATnew(TYPE_int,TYPE_str,BBPsize);
        if (b == 0)
		return GDK_FAIL;

	BBPlock("view_bbp_@1");
        for (i = 1; i < BBPsize; i++) {
		if (i != b->batCacheid && BBPvalid(i) && !(BBP_status(i) & BBPUNSTABLE)) {
			BAT *bn = (BAT*) BBPgetdesc(i);
			if (bn ) {
				str tpe = ATOMname(bn->@1);
				BUNins(b, &i, tpe, FALSE);
			}
		}
	}
	BBPunlock("view_bbp_@1");
	@:Pseudo(bbp,@1)@
        return GDK_SUCCEED;
}
@c
@:bbp_types(htype)@
@:bbp_types(ttype)@

int
view_bbp_count(BAT **retval	/* put pointer to BAT[int,str] record here. */
    )
{
	BAT *b;
	int i;

	b = BATnew(TYPE_int, TYPE_lng, BBPsize);
	if (b == 0)
		return GDK_FAIL;

	BBPlock("view_bbp_count");
	for (i = 1; i < BBPsize; i++)
		if (i != b->batCacheid && BBPvalid(i) && !(BBP_status(i) & BBPUNSTABLE)) {
			BAT *bn = (BAT *) BBPgetdesc(ABS(i));
			if (bn) {
				lng cnt = BATcount(bn);

				BUNins(b, &i, &cnt, FALSE);
			}
		}
	BBPunlock("view_bbp_count");
	@:Pseudo(bbp,cnt)@
	return GDK_SUCCEED;
}

@-
The BAT status is redundantly stored in view_bat_info.
@c
int
view_bbp_location(BAT **retval	/* put pointer to BAT[int,str] record here. */
    )
{
	BAT *b;
	int i;

	b = BATnew(TYPE_int, TYPE_str, BBPsize);
	if (b == 0)
		return GDK_FAIL;

	BBPlock("view_bbp_location");
	for (i = 1; i < BBPsize; i++)
		if (i != b->batCacheid && BBPvalid(i) && !(BBP_status(i) & BBPUNSTABLE)) {
			BUNins(b, &i, BBP_physical(i), FALSE);
		}
	BBPunlock("view_bbp_location");
	@:Pseudo(bbp,location)@
	return GDK_SUCCEED;
}


#define monet_modulesilent (!(GDKdebug&16384))

int
view_bbp_heat(BAT **retval	/* put pointer to BAT[int,int] record here. */
    )
{
	BAT *b;
	int i;

	b = BATnew(TYPE_int, TYPE_int, BBPsize);
	if (b == 0)
		return GDK_FAIL;

	BBPlock("view_bbp_heat");
	for (i = 1; i < BBPsize; i++)
		if (i != b->batCacheid && BBPvalid(i) && !(BBP_status(i) & BBPUNSTABLE)) {
			if (BBP_cache(i) && !monet_modulesilent) {
				int heat = BBP_lastused(i);

				BUNins(b, &i, &heat, FALSE);
			} else {
				int zero = 0;

				BUNins(b, &i, &zero, FALSE);
			}
		}
	BBPunlock("view_bbp_heat");
	@:Pseudo(bbp,heat)@
	return GDK_SUCCEED;
}

@-
The BAT dirty status: dirty => (mem != disk); diffs = not-committed
@c
int
view_bbp_dirty(BAT **retval	/* put pointer to BAT[int,str] record here. */
    )
{
	BAT *b;
	int i;

	b = BATnew(TYPE_int, TYPE_str, BBPsize);
	if (b == 0)
		return GDK_FAIL;

	BBPlock("view_bbp_dirty");
	for (i = 1; i < BBPsize; i++)
		if (i != b->batCacheid && BBPvalid(i) && !(BBP_status(i) & BBPUNSTABLE)) {
			BAT *bn = BBP_cache(i);

			BUNins(b, &i, bn ? BATdirty(bn) ? "dirty" : DELTAdirty(bn) ? "diffs" : "clean" : (BBP_status(i) & BBPSWAPPED) ? "swapped" : "clean", FALSE);
		}
	BBPunlock("view_bbp_dirty");
	@:Pseudo(bbp,dirty)@
	return GDK_SUCCEED;
}

@-
The BAT status is redundantly stored in view_bat_info.
@c
int
view_bbp_status(BAT **retval	/* put pointer to BAT[int,str] record here. */
    )
{
	BAT *b;
	int i;

	b = BATnew(TYPE_int, TYPE_str, BBPsize);
	if (b == 0)
		return GDK_FAIL;

	BBPlock("view_bbp_status");
	for (i = 1; i < BBPsize; i++)
		if (i != b->batCacheid && BBPvalid(i) && !(BBP_status(i) & BBPUNSTABLE)) {
			char *loc = BBP_cache(i) ? "load" : "disk";

			BUNins(b, &i, loc, FALSE);
		}
	BBPunlock("view_bbp_status");
	@:Pseudo(bbp,status)@
	return GDK_SUCCEED;
}

int
view_bbp_kind(BAT **retval	/* put pointer to BAT[int,str] record here. */
    )
{
	BAT *b;
	int i;

	b = BATnew(TYPE_int, TYPE_str, BBPsize);
	if (b == 0)
		return GDK_FAIL;

	BBPlock("view_bbp_kind");
	for (i = 1; i < BBPsize; i++)
		if (i != b->batCacheid && BBPvalid(i) && !(BBP_status(i) & BBPUNSTABLE)) {
			char *mode = NULL;

			if ((BBP_status(i) & BBPDELETED) || !(BBP_status(i) & BBPPERSISTENT)) {
				BAT *bt = (BAT*)BBPgetdesc(i);

				mode = (bt && bt->batPersistence == SESSION) ? "sess" : "tran";
			} else {
				mode = "pers";
			}
			if (mode)
				BUNins(b, &i, mode, FALSE);
		}
	BBPunlock("view_bbp_kind");
	@:Pseudo(bbp,kind)@
	return GDK_SUCCEED;
}

int
view_bbp_refcnt(BAT **retval	/* put pointer to BAT[int,str] record here. */
    )
{
	BAT *b;
	int i;

	b = BATnew(TYPE_int, TYPE_int, BBPsize);
	if (b == 0)
		return GDK_FAIL;

	BBPlock("view_bbp_refcnt");
	for (i = 1; i < BBPsize; i++)
		if (i != b->batCacheid && BBPvalid(i) && !(BBP_status(i) & BBPUNSTABLE)) {
			int refs = BBP_refs(i);
			BUNins(b, &i, &refs, FALSE);
		}
	BBPunlock("view_bbp_refcnt");
	@:Pseudo(bbp,refcnt)@
	return GDK_SUCCEED;
}


int
view_bbp_lrefcnt(BAT **retval	/* put pointer to BAT[int,str] record here. */
    )
{
	BAT *b;
	int i;

	b = BATnew(TYPE_int, TYPE_int, BBPsize);
	if (b == 0)
		return GDK_FAIL;

	BBPlock("view_bbp_lrefcnt");
	for (i = 1; i < BBPsize; i++)
		if (i != b->batCacheid && BBPvalid(i) && !(BBP_status(i) & BBPUNSTABLE)) {
			int lrefcnt = BBP_lrefs(i);

			BUNins(b, &i, &lrefcnt, FALSE);
		}
	BBPunlock("view_bbp_lrefcnt");
	@:Pseudo(bbp,lrefcnt)@
	return GDK_SUCCEED;
}

@+ GDK
The old-fashioned BATdump command is replaced by the sys.
@c
int
view_gdk_thread(BAT **retval	/* put pointer to BAT[int,str] record here. */
    )
{
	BAT *b;
	int i;

	b = BATnew(TYPE_int, TYPE_str, THREADS);
	if (b == 0)
		return GDK_FAIL;

	for (i = 0; i < THREADS; i++)
		if (GDKthreads[i].pid) {
			BUNins(b, &GDKthreads[i].tid, GDKthreads[i].name, FALSE);
		}
	@:Pseudo(gdk,thread)@
	return GDK_SUCCEED;
}

int
view_atom_name(BAT **retval	/* put pointer to BAT[int,str] record here. */
    )
{
	BAT *b;
	int i;

	b = BATnew(TYPE_int, TYPE_str, GDKatomcnt * 2);
	if (b == 0)
		return GDK_FAIL;

	for (i = 0; i < GDKatomcnt; i++)
		BUNins(b, &i, BATatoms[i].name, FALSE);
	@:Pseudo(atom,name)@

	return GDK_SUCCEED;
}

int
view_atom_align(BAT **retval	/* put pointer to BAT[int,str] record here. */
    )
{
	BAT *b;
	int i;

	b = BATnew(TYPE_int, TYPE_int, GDKatomcnt * 2);
	if (b == 0)
		return GDK_FAIL;

	for (i = 0; i < GDKatomcnt; i++)
		BUNins(b, &i, &BATatoms[i].align, FALSE);
	@:Pseudo(atom,align)@

	return GDK_SUCCEED;
}

int
view_atom_size(BAT **retval	/* put pointer to BAT[int,str] record here. */
    )
{
	BAT *b;
	int i;

	b = BATnew(TYPE_int, TYPE_int, GDKatomcnt * 2);
	if (b == 0)
		return GDK_FAIL;

	for (i = 0; i < GDKatomcnt; i++) {
		int z = BATatoms[i].size;

		BUNins(b, &i, &z, FALSE);
	}
	@:Pseudo(atom,size)@

	return GDK_SUCCEED;
}

int
view_gdk_env(BAT **retval)
{
	BAT *b = *retval = GDKenv;

	if (b == 0)
		return GDK_FAIL;
	BBPfix(b->batCacheid);
	return GDK_SUCCEED;
}

int
check_bbp_size(lng *ret)
{
	*ret = BBPdiskscan();
	return GDK_SUCCEED;
}

@+ Monet sys variables
@c
int
view_client_name(BAT **retval	/* put pointer to BAT[int,str] record here. */
    )
{
	BAT *b;
	int i;

	b = BATnew(TYPE_int, TYPE_str, MAXCLIENTS);
	if (b == 0)
		return GDK_FAIL;

	for (i = 0; i < MAXCLIENTS; i++)
		if (monet_clients[i].user) {
			BUNins(b, &i, monet_clients[i].user, FALSE);
		}

	@:Pseudo(client,name)@
	return GDK_SUCCEED;
}

int
view_client_login(BAT **retval	/* put pointer to BAT[int,str] record here. */
    )
{
	BAT *b;
	int i;
	char s[26];

	b = BATnew(TYPE_int, TYPE_str, MAXCLIENTS);
	if (b == 0)
		return GDK_FAIL;

	for (i = 0; i < MAXCLIENTS; i++)
		if (monet_clients[i].user) {
			time_t logintime = monet_clients[i].login;
			struct tm localt;

#ifdef HAVE_LOCALTIME_R
			(void) localtime_r(&logintime, &localt);
#else
			/* race condition: return value could be
			 * overwritten in parallel thread before
			 * assignment complete */
			localt = *localtime(&logintime);
#endif

#ifdef HAVE_ASCTIME_R3
			asctime_r(&localt, s, sizeof(s));
#else
#ifdef HAVE_ASCTIME_R
			asctime_r(&localt, s);
#else
			/* race condition: return value could be
			 * overwritten in parallel thread before copy
			 * complete, however on Windows, asctime is
			 * thread-safe */
			strncpy(s, asctime(&localt), 26);
#endif
#endif
			s[24] = 0; /* remove trailing newline */
			BUNins(b, &i, s, FALSE);
		}

	@:Pseudo(client,login)@
	return GDK_SUCCEED;
}

int
view_client_tree(BAT **retval)
{
	BAT *b = *retval = BATnew(TYPE_int, TYPE_str, 50);
	char buf[4096];
	int i;

	if (b == 0)
		return GDK_FAIL;
	for (i = 0; i < MAXCLIENTS; i++)
		if (monet_clients[i].mode != FINISHED) {
			Client c = monet_clients + i;

			buf[0] = 0;
			lockparser(c);
			yydeparse(c, c->tree, buf, buf + 80);
			unlockparser(c);
			BUNins(b, &i, buf, FALSE);
		}
	@:Pseudo(client,tree)@
	return GDK_SUCCEED;
}

int
view_client_size(BAT **retval, int *clientid)
{
	BATiter fcntbli, fti = bat_iterator(TBL_fcn_tpe), fii = bat_iterator(TBL_fcn_imp);
	BAT *b, *fcntbl;
	lng tot, vars = 0, nvars = 0;
	lng cntxts = 0, ncntxts = 0;
	lng procs = 0, procnodes = 0;
	int xx, stk = *clientid;
	BUN p, q, r;

	if (stk < 0 || stk >= MAXCLIENTS || monet_clients[stk].mode == FINISHED)
		return GDK_FAIL;
        b = *retval = BATnew(TYPE_str, TYPE_lng, 100);
	if (b == 0)
		return GDK_FAIL;

	/* look at the size of all procs */
	fcntbl = monet_clients[stk].fcntbl;
	fcntbli = bat_iterator(fcntbl);
        BATloop(fcntbl, p, q) {
		oid pid = *(oid*) BUNtloc(fcntbli, p);
		str nme = (str) BUNhead(fcntbli, p);
		size_t cnt = 0;
		r = BUNfnd(TBL_fcn_tpe, &pid);
		if (r == BUN_NONE || *(int*) BUNtloc(fti,r) != TOK_PROC) continue;
		r = BUNfnd(TBL_fcn_imp, &pid);
		if (r == BUN_NONE) continue;
		tot = Myysize(*(YYSTREE*) BUNtloc(fii,r), &cnt);
		procs += tot;
		procnodes += cnt;
		if (tot > 65536) BUNins(b, nme, &tot, FALSE);  
	}

	/* look at all live contexts and their variables */
	xx = monet_clients[stk].maxstk;
	if (xx == 0) xx = stk;
	do {
		Variable v = monet_cntxt[xx].var;
		while(v) {
			nvars++;
			vars += sizeof(VarRecord);
			if (v->binding.val.pval && ATOMextern(v->binding.vtype))
				vars += v->binding.len;
			v = v->next;
		}
		cntxts += sizeof(CntxtRec);
		ncntxts++;
		xx = monet_cntxt[xx].outer;
 	} while(xx && xx != stk);

	/* report */
 	tot = vars + procs + cntxts;
	BUNins(b, "var", &vars, FALSE);  
	BUNins(b, "var_num", &nvars, FALSE);  
	BUNins(b, "cntxt", &cntxts, FALSE);  
	BUNins(b, "cntxt_num", &ncntxts, FALSE);  
	BUNins(b, "proc", &procs, FALSE);  
	BUNins(b, "proc_nodes", &procnodes, FALSE);  
	BUNins(b, "total", &tot, FALSE);  

	@:Pseudo(client,size)@
	return GDK_SUCCEED;
}

@+ Variables
The variable information can be turned into a BAT for inspection as well.
@c
int
view_var_name(int stk,		/* variable context number ("stack"). */
	      YYSTREE lt,	/* syntax tree of parsed MIL. */
	      ValPtr res	/* value record for result. */
    )
{
	Client c;
	Variable v;
	BAT *b, **retval = &b;

	(void) lt;

	CNTXTclient(stk, &c);

	b = BATnew(TYPE_ptr, TYPE_str, 100);
	if (b == 0)
		return -1;

	for (;;) {
		for (v = monet_cntxt[stk].var; v != NULL; v = v->next) {
			BUNins(b, &v, v->name, FALSE);
		}
		if (stk < 0)
			break;
		stk = monet_cntxt[stk].outer;
	}
	@:Pseudo(var,type)@

	res->vtype = TYPE_bat;
	res->val.bval = BBPcacheid(b);
	BBPincref(res->val.bval, TRUE);
	BBPunfix(res->val.bval);
	return 0;
}

int
view_var_type(int stk,		/* variable context number ("stack"). */
	      YYSTREE lt,	/* syntax tree of parsed MIL. */
	      ValPtr res	/* value record for result. */
    )
{
	Client c;
	Variable v;
	BAT *b, **retval = &b;

	(void) lt;

	CNTXTclient(stk, &c);

	b = BATnew(TYPE_ptr, TYPE_str, 100);
	if (b == 0)
		return -1;

	for (;;) {
		for (v = monet_cntxt[stk].var; v != NULL; v = v->next) {
			BUNins(b, &v, BATatoms[v->binding.vtype].name, FALSE);
		}
		if (stk < 0)
			break;
		stk = monet_cntxt[stk].outer;
	}
	@:Pseudo(var,type)@

	res->vtype = TYPE_bat;
	res->val.bval = BBPcacheid(b);
	BBPincref(res->val.bval, TRUE);
	BBPunfix(res->val.bval);
	return 0;
}

int
view_var_kind(int stk,		/* variable context number ("stack"). */
	      YYSTREE lt,	/* syntax tree of parsed MIL. */
	      ValPtr res	/* value record for result. */
    )
{
	Client c;
	Variable v;
	BAT *b, **retval = &b;

	(void) lt;

	CNTXTclient(stk, &c);

	b = BATnew(TYPE_ptr, TYPE_str, 100);
	if (b == 0)
		return -1;

	for (;;) {
		for (v = monet_cntxt[stk].var; v != NULL; v = v->next) {
			BUNins(b, &v, (v->frozen ? "frozen" : "liquid"), FALSE);
		}
		if (stk < 0)
			break;
		stk = monet_cntxt[stk].outer;
	}
	@:Pseudo(var,type_status)@

	res->vtype = TYPE_bat;
	res->val.bval = BBPcacheid(b);
	BBPincref(res->val.bval, TRUE);
	BBPunfix(res->val.bval);
	return 0;
}

int
view_var_constant(int stk,	/* variable context number ("stack"). */
		  YYSTREE lt,	/* syntax tree of parsed MIL. */
		  ValPtr res	/* value record for result. */
    )
{
	Client c;
	Variable v;
	BAT *b, **retval = &b;

	(void) lt;

	CNTXTclient(stk, &c);

	b = BATnew(TYPE_ptr, TYPE_str, 100);
	if (b == 0)
		return -1;

	for (;;) {
		for (v = monet_cntxt[stk].var; v != NULL; v = v->next) {
			BUNins(b, &v, (v->constant ? "constant" : "changeable"), FALSE);
		}
		if (stk < 0)
			break;
		stk = monet_cntxt[stk].outer;
	}
	@:Pseudo(var,value_status)@

	res->vtype = TYPE_bat;
	res->val.bval = BBPcacheid(b);
	BBPincref(res->val.bval, TRUE);
	BBPunfix(res->val.bval);
	return 0;
}

int
view_var_value(int stk,		/* variable context number ("stack"). */
	       YYSTREE lt,	/* syntax tree of parsed MIL. */
	       ValPtr res	/* value record for result. */
    )
{
	Client c;
	Variable v;
	BAT *b, **retval = &b;
	char *buf = NULL;
	int l = 0;

	(void) lt;

	CNTXTclient(stk, &c);

	b = BATnew(TYPE_ptr, TYPE_str, 100);
	if (b == 0)
		return -1;

	for (;;) {
		for (v = monet_cntxt[stk].var; v != NULL; v = v->next) {
			int t = ATOMstorage(v->binding.vtype);
			ptr p = ATOMextern(t) ? v->binding.val.pval : (ptr) &v->binding.val.ival;

			if ((*BATatoms[v->binding.vtype].atomToStr) (&buf, &l, p)) {
				BUNins(b, &v, buf, FALSE);
			} else {
				BUNins(b, &v, (ptr)str_nil, FALSE);
			}
		}
		if (stk < 0)
			break;
		stk = monet_cntxt[stk].outer;
	}
	@:Pseudo(var,value_value)@

	res->vtype = TYPE_bat;
	res->val.bval = BBPcacheid(b);
	BBPincref(res->val.bval, TRUE);
	BBPunfix(res->val.bval);
	return 0;
}

@+ Modules
@c
static char any_str[] = "any";

int
view_modules(BAT **res)
{
	*res = (BAT *) TBL_getdir();
	return GDK_SUCCEED;
}

int
get_mod_name(str *res, str src)
{
	str entry = GDKstrdup(src);
	str s = strchr(entry, '-');

	if (s)
		*s = 0;
	*res = entry;
	return GDK_SUCCEED;
}

int
get_mod_db(str *res, str src)
{
	str entry = GDKstrdup(src);
	str s = strchr(entry, '-');

	if (s == NULL) {
		s = any_str;
	}
	*res = GDKstrdup(s);
	GDKfree(entry);
	return GDK_SUCCEED;
}


@- Performance
To obtain a good impression of the Monet performance we need timing information.
The most detailed information is best obtained with the system profiler.

However, the direct approach is to enable the user to read the timers maintained
internally. This is done with the CPU, IO, MEMORY, and BBP command which
displays the elapsed time in seconds, user- and system-cpu time in milliseconds
since its last invocation and the amount of space in use.  The process
identifier is used to differentiate among the possible processes.

Note that in multi threaded mode the routine prints the elapsed
time since the beginning of each process.
@{
@c
#ifndef NATIVE_WIN32
static time_t clk = 0;
static struct tms state;
#endif

int
view_gdk_cpu(BAT **retval)
{
#ifndef NATIVE_WIN32
	struct tms newst;
#endif
	int i;
	BAT *b;
#if !defined(NATIVE_WIN32) && !defined(HZ) && defined(HAVE_SYSCONF) && defined(_SC_CLK_TCK)
	static int HZ;

	if (HZ == 0)
			HZ = sysconf(_SC_CLK_TCK);
#endif

	*retval = b = BATnew(TYPE_str, TYPE_int, 32);
	if (b == 0)
		return GDK_FAIL;
#ifndef NATIVE_WIN32
	if (clk == 0) {
		clk = time(0);
		times(&state);
	}
	times(&newst);
	/* store counters, ignore errors */
	i = (int) (time(0) - clk);
	b = BUNins(b, "elapsed", &i, FALSE);
	i = newst.tms_utime * 1000 / HZ;
	b = BUNins(b, "user", &i, FALSE);
	i = (newst.tms_utime - state.tms_utime) * 1000 / HZ;
	b = BUNins(b, "elapuser", &i, FALSE);
	i = newst.tms_stime * 1000 / HZ;
	b = BUNins(b, "system", &i, FALSE);
	i = (newst.tms_stime - state.tms_stime) * 1000 / HZ;
	b = BUNins(b, "elapsystem", &i, FALSE);

	state = newst;
#else
	i = int_nil;
	b = BUNins(b, "elapsed", &i, FALSE);
	b = BUNins(b, "user", &i, FALSE);
	b = BUNins(b, "elapuser", &i, FALSE);
	b = BUNins(b, "system", &i, FALSE);
	b = BUNins(b, "elapsystem", &i, FALSE);
#endif
	@:Pseudo(gdk,cpu)@
	return GDK_SUCCEED;
}

@-
Same observations as to view_gdk_cpu()
@c
static char *memincr = NULL;
int
view_gdk_mem(BAT **retval)
{
/* 64bit: should return a [str,wrd] bat, but then again, mallinfo returns ints */
	struct mallinfo m;
	BAT *b;
	int i;

	m = MT_mallinfo();

	*retval = b = BATnew(TYPE_str, TYPE_int, 32);
	if (b == 0)
		return GDK_FAIL;

	/* store counters, ignore errors */
	if (memincr == NULL) {
		memincr = MT_heapbase;
	}
	i = (MT_heapcur() - memincr);

	memincr = MT_heapcur();
	b = BUNins(b, "memincr", &i, FALSE);
	i = m.arena;
	b = BUNins(b, "arena", &i, FALSE);
	i = m.ordblks;
	b = BUNins(b, "ordblks", &i, FALSE);
	i = m.smblks;
	b = BUNins(b, "smblks", &i, FALSE);
	i = m.hblkhd;
	b = BUNins(b, "hblkhd", &i, FALSE);
	i = m.hblks;
	b = BUNins(b, "hblks", &i, FALSE);
	i = m.usmblks;
	b = BUNins(b, "usmblks", &i, FALSE);
	i = m.fsmblks;
	b = BUNins(b, "fsmblks", &i, FALSE);
	i = m.uordblks;
	b = BUNins(b, "uordblks", &i, FALSE);
	i = m.fordblks;
	b = BUNins(b, "fordblks", &i, FALSE);
	@:Pseudo(gdk,mem)@
	return GDK_SUCCEED;
}

@-
To avoid complains about signed/unsigned comparisons between lng & size_t,
we cast  lng *num  to  size_t sze,
after checking that there is no under-/overflow.
@c
@= num2sze
	size_t sze;
	if (*num < 0) {
		GDKerror("set_@1: new size must not be < 0!\n");
		return GDK_FAIL;
	}
#if SIZEOF_SIZE_T == SIZEOF_INT
{
	lng size_t_max = 2 * (lng)INT_MAX;
	if (*num > size_t_max) {
		GDKerror("set_@1: new size must not be > " LLFMT "!\n", size_t_max);
		return GDK_FAIL;
	}
}
#endif
	sze = (size_t)*num;
@c
int
get_mem_bigsize(lng *num)
{
	*num = GDK_mem_bigsize;
	return GDK_SUCCEED;
}

int
set_mem_bigsize(lng *num)
{
	@:num2sze(mem_bigsize)@
	GDK_mem_bigsize = MAX(32768, sze);
	return GDK_SUCCEED;
}

int
get_mem_cursize(lng *num)
{
	*num = GDKmem_cursize();
	return GDK_SUCCEED;
}

int
get_mem_maxsize(lng *num)
{
	*num = GDK_mem_maxsize;
	return GDK_SUCCEED;
}

int
set_mem_maxsize(lng *num)
{
	@:num2sze(mem_maxsize)@
	if (sze < GDK_mem_bigsize)
		set_mem_bigsize(num);
	GDK_mem_maxsize = MAX(GDK_mem_bigsize, sze);
	return GDK_SUCCEED;
}

int
get_vm_cursize(lng *num)
{
	*num = GDKvm_cursize();
	return GDK_SUCCEED;
}

int
get_vm_minsize(lng *num)
{
	*num = GDK_vm_minsize;
	return GDK_SUCCEED;
}

int
set_vm_minsize(lng *num)
{
	@:num2sze(vm_minsize)@
	if (sze < GDK_mem_bigsize)
		set_mem_bigsize(num);
	GDK_vm_minsize = MAX(GDK_mem_bigsize, sze);
	return GDK_SUCCEED;
}

int
get_vm_maxsize(lng *num)
{
	*num = GDK_vm_maxsize;
	return GDK_SUCCEED;
}

int
set_vm_maxsize(lng *num)
{
	@:num2sze(vm_maxsize)@
	if (sze < GDK_vm_minsize)
		set_vm_minsize(num);
	GDK_vm_maxsize = MAX(GDK_vm_minsize, sze);
	return GDK_SUCCEED;
}


@= heap
	if (@2) {
		sz = HEAP@1size(@3);
		if (sz > *minsize) {
			sprintf(buf, "@4/%s", s);
			BUNins(bn, buf, &sz, FALSE);
		}
		@4 += sz; tot += sz;
	}
@c

int
get_mem_usage(BAT **ret, lng *minsize)
{
	lng buns = 0, hhsh = 0, thsh = 0, hind = 0, tind = 0, head = 0, tail = 0, tot = 0, n = 0, sz;
	BAT *bn = BATnew(TYPE_str, TYPE_lng, 2 * BBPsize);
	struct mallinfo m;
	char buf[1024];
	bat i;

	if (bn == NULL)
		return GDK_FAIL;
	BBPlock("get_mem_usage");
	for (i = 1; i < BBPsize; i++) 
	    if (i != bn->batCacheid && BBPvalid(i) && !(BBP_status(i) & BBPUNSTABLE)) {
		BAT *b = BBP_cache(i);
		str s;

		if (!BBPvalid(i))
			continue;

		s = BBPname(i);
		sz = 0;
		if (BBP[i].cache)
			sz += sizeof(BATstore);
		if (BBP[i].nme[0])
			n += strLen(BBP[i].nme[0]);
		if (BBP[i].nme[1])
			n += strLen(BBP[i].nme[1]);
		if (BBP[i].path)
			n += strLen(BBP[i].path);
		if (b)
			sz += sizeof(BAT);	/* mirror */

		if (sz > *minsize) {
			sprintf(buf, "desc/%s", s);
			BUNins(bn, buf, &sz, FALSE);
		}
		tot += (lng) sz;

		if (b == NULL || isVIEW(b)) {
			continue;
		}
		@:heap(mem,1,(&b->H->heap),head)@
		@:heap(mem,1,(&b->T->heap),tail)@
		@:heap(mem,b->H->hash,b->H->hash->heap,hhsh)@
		@:heap(mem,b->T->hash,b->T->hash->heap,thsh)@
		@:heap(mem,b->hheap,b->hheap,head)@
		@:heap(mem,b->theap,b->theap,tail)@
	}
	/* totals per category */
	BUNins(bn, "_tot/buns", &buns, FALSE);
	BUNins(bn, "_tot/head", &head, FALSE);
	BUNins(bn, "_tot/tail", &tail, FALSE);
	BUNins(bn, "_tot/hhsh", &hhsh, FALSE);
	BUNins(bn, "_tot/thsh", &thsh, FALSE);
	BUNins(bn, "_tot/hind", &hind, FALSE);
	BUNins(bn, "_tot/tind", &tind, FALSE);

	/* special area 1: BBP rec */
	sz = BBPlimit * sizeof(BBPrec) + n;
	BUNins(bn, "_tot/bbp", &sz, FALSE);
	tot += sz;

	/* special area 2: monet context records */
	sz = monet_cntxtmax * sizeof(CntxtRec);
	BUNins(bn, "_tot/mil", &sz, FALSE);

	/* this concludes all major traceable Monet memory usages */
	tot += sz;
	BUNins(bn, "_tot/found", &tot, FALSE);

	/* now look at what the global statistics report (to see if it coincides)
	 */

	/* how much *used* bytes in heap? */
	m = MT_mallinfo();
	sz = (size_t) (m.usmblks + m.uordblks + m.hblkhd);
	BUNins(bn, "_tot/malloc", &tot, FALSE);

	/* measure actual heap size, includes wasted fragmented space and anon mmap space used by malloc() */
	sz = GDKvm_heapsize();
	BUNins(bn, "_tot/heap", &sz, FALSE);

	tot = GDKmem_cursize();

	/* allocated swap area memory that is not plain malloc() */
	sz = MAX(0, sz - tot);
	BUNins(bn, "_tot/valloc", &sz, FALSE);

	/* swap-area memory is in either GDKvmalloc or heap */
	BUNins(bn, "_tot/swapmem", &tot, FALSE);

	BBPunlock("get_mem_usage");
	*ret = bn;
	return GDK_SUCCEED;
}

int
get_vm_usage(BAT **ret, lng *minsize)
{
	lng buns = 0, hhsh = 0, thsh = 0, hind = 0, tind = 0, head = 0, tail = 0, tot = 0, sz;
	BAT *bn = BATnew(TYPE_str, TYPE_lng, 2 * BBPsize);
	char buf[1024];
	bat i;

	if (bn == NULL)
		return GDK_FAIL;
	BBPlock("get_vm_usage");
	for (i = 1; i < BBPsize; i++) 
	    if (i != bn->batCacheid && BBPvalid(i) && !(BBP_status(i) & BBPUNSTABLE)) {
		BAT *b;
		str s;

		if (!BBPvalid(i))
			continue;

		s = BBPname(i);
 		b = BBP_cache(i);
		if (b == NULL || isVIEW(b)) {
			continue;
		}
		@:heap(vm,1,(&b->H->heap),head)@
		@:heap(vm,1,(&b->T->heap),tail)@
		@:heap(vm,b->H->hash,b->H->hash->heap,hhsh)@
		@:heap(vm,b->T->hash,b->T->hash->heap,thsh)@
		@:heap(vm,b->hheap,b->hheap,head)@
		@:heap(vm,b->theap,b->theap,tail)@
	}
	/* totals per category */
	BUNins(bn, "_tot/buns", &buns, FALSE);
	BUNins(bn, "_tot/head", &head, FALSE);
	BUNins(bn, "_tot/tail", &tail, FALSE);
	BUNins(bn, "_tot/hhsh", &hhsh, FALSE);
	BUNins(bn, "_tot/thsh", &thsh, FALSE);
	BUNins(bn, "_tot/hind", &hind, FALSE);
	BUNins(bn, "_tot/tind", &tind, FALSE);

	/* special area 1: BBP rec */
	sz = BBPmaxsize * sizeof(BBPrec);
	BUNins(bn, "_tot/bbp", &sz, FALSE);
	tot += sz;

	/* special area 2: monet context records */
	sz = monet_cntxtlim * sizeof(CntxtRec);
	BUNins(bn, "_tot/mil", &sz, FALSE);

	/* this concludes all major traceable Monet virtual memory usages */
	tot += sz;
	BUNins(bn, "_tot/found", &tot, FALSE);

	/* all VM is either GDKmmap or GDKvmalloc (possibly redirected GDKmalloc), *plus* the heap */
	sz = GDKvm_cursize();
	BUNins(bn, "_tot/vm", &sz, FALSE);

	BBPunlock("get_vm_usage");
	*ret = bn;
	return GDK_SUCCEED;
}

@-
Additional information on the process utilization is given by
the io command. The following information is obtained.

@T
\begin{tabular}{| l| l|}\hline
maxrss     &the maximum resident set size utilized (in kilobytes).\\
minflt     &the number of page faults serviced without any I/O\\
	 &activity; here I/O activity is avoided by "reclaiming" a\\

	 &activity; here I/O activity is avoided by "reclaiming" a\\
	 &page frame from the list of pages awaiting reallocation.\\
majflt     &the number of page faults serviced that required I/O\\
	 &activity.\\
nswap      &the number of times a process was "swapped" out of main\\
	 &memory\\
inblock    &the number of times the file system had to perform input.\\
oublock    &the number of times the file system had to perform output.\\
nvcsw      &the number of times a context switch resulted due to a\\
	 &process voluntarily giving up the processor before its\\
	 &time slice was completed (usually to await availability of\\
	 &a resource).\\
nivcsw     &the number of times a context switch resulted due to a\\
	 &higher priority process becoming runnable or because the\\
	 &current process exceeded its time slice.\\
\end{tabular}
@
The resource statistics are collected in a BAT. It can then
be queried. A default listing is produced by the command @%usagecmd@.
(which should be moved to Monet)

The BAT grows. It should be compacted.
@c
#ifdef HAVE_SYS_RESOURCE_H
# include <sys/resource.h>
#endif

int
view_gdk_io(BAT **retval)
{
#ifndef NATIVE_WIN32
	struct rusage ru;
#endif
	int i;
	BAT *b;

#ifndef NATIVE_WIN32
	getrusage(RUSAGE_SELF, &ru);
#endif
	*retval = b = BATnew(TYPE_str, TYPE_int, 32);
	if (b == 0)
		return GDK_FAIL;

#ifndef NATIVE_WIN32
	/* store counters, ignore errors */
	i = ru.ru_maxrss;
	BUNins(b, "maxrss", &i, FALSE);
	i = ru.ru_minflt;
	BUNins(b, "minflt", &i, FALSE);
	i = ru.ru_majflt;
	BUNins(b, "majflt", &i, FALSE);
	i = ru.ru_nswap;
	BUNins(b, "nswap", &i, FALSE);
	i = ru.ru_inblock;
	BUNins(b, "inblock", &i, FALSE);
	i = ru.ru_oublock;
	BUNins(b, "oublock", &i, FALSE);
	i = ru.ru_nvcsw;
	BUNins(b, "nvcsw", &i, FALSE);
	i = ru.ru_nivcsw;
	BUNins(b, "ninvcsw", &i, FALSE);
#else
	i = int_nil;
	BUNins(b, "maxrss", &i, FALSE);
	BUNins(b, "minflt", &i, FALSE);
	BUNins(b, "majflt", &i, FALSE);
	BUNins(b, "nswap", &i, FALSE);
	BUNins(b, "inblock", &i, FALSE);
	BUNins(b, "oublock", &i, FALSE);
	BUNins(b, "nvcsw", &i, FALSE);
	BUNins(b, "ninvcsw", &i, FALSE);
#endif

	@:Pseudo(gdk,io)@
	return GDK_SUCCEED;
}

int
view_gdk_bbp(BAT **retval)
{
	int pbat = 0;
	int pdisk = 0;
	int pheat = 0;
	bat i;
	int tmp = 0, per = 0;
	BAT *b;

	*retval = b = BATnew(TYPE_str, TYPE_int, 32);
	if (b == 0)
		return GDK_FAIL;

	for (i = 1; i < BBPsize; i++) {
	        if (i != b->batCacheid && BBPvalid(i) && !(BBP_status(i) & BBPUNSTABLE)) {
			pbat++;
			if (BBP_cache(i)) {
				pheat += BBP_lastused(i);
				if (BBP_cache(i)->batPersistence == PERSISTENT)
					per++;
				else
					tmp++;
			} else {
				pdisk++;
			}
		}
	}
	b = BUNins(b, "bats", &pbat, FALSE);
	b = BUNins(b, "tmpbats", &tmp, FALSE);
	b = BUNins(b, "perbats", &per, FALSE);
	b = BUNins(b, "ondisk", &pdisk, FALSE);
	b = BUNins(b, "todisk", &BBPout, FALSE);
	b = BUNins(b, "fromdisk", &BBPin, FALSE);

	@:Pseudo(gdk,bbp)@
	return GDK_SUCCEED;
}

int
view_gdk_mem_histo(BAT **retval)
{
	BAT *b = BATnew(TYPE_lng, TYPE_lng, GDK_HISTO_MAX_BIT);

#ifdef GDK_MEM_KEEPHISTO
	int i;

	if (b == NULL)
		return GDK_FAIL;
	for (i = 3; i < GDK_HISTO_MAX_BIT - 1; i++) {
		lng j = 1 << i;
		lng v = (lng) GDK_nmallocs[i]
		    BUNins(b, &j, &v, FALSE);
	}
#endif
	@:Pseudo(gdk,mem_histo)@
	return GDK_SUCCEED;
}

int
view_gdk_vm_histo(BAT **retval)
{
	BAT *b = BATnew(TYPE_lng, TYPE_lng, GDK_HISTO_MAX_BIT);

#ifdef GDK_VM_KEEPHISTO
	int i;

	if (b == NULL)
		return GDK_FAIL;
	for (i = 12; i < GDK_HISTO_MAX_BIT - 1; i++) {
		lng j = 1 << i;
		lng v = (lng) GDK_vm_nallocs[i]
		    BUNins(b, &j, &v, FALSE);
	}
#endif
	@:Pseudo(gdk,vm_histo)@
	return GDK_SUCCEED;
}


int
format_fcn_sig(str *sig, oid *fid)
{
	if (TBL_formatsig(*sig = (str) GDKmalloc(1024), *fid)) {
		return GDK_SUCCEED;
	}
	GDKfree(*sig);
	return GDK_FAIL;
}

int
print_mem_map(void)
{
	MT_alloc_print();
	return GDK_SUCCEED;
}

int
print_color_map(void)
{
	MT_alloc_table();
	return GDK_SUCCEED;
}

int
vm_trim(lng *lim)
{
	MT_mmap_trim((size_t) *lim, GDKerr);
	return GDK_SUCCEED;
}

int bbp_batcache_minsize(wrd *ret, wrd* val) {
	*ret = BBPrecycle_minsize(*val);
	return GDK_SUCCEED;
}
@}
