@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
@' Copyright August 2008- MonetDB B.V.
@' All Rights Reserved.

@f bat
@v 1.0
@a Peter Boncz, M.L. Kersten
@* Binary Association Tables
This module contains all commands that are of use when managing Binary
Association Tables (BATs). The relational operations you can execute
on BATs have the form of a @[<a href="../algebra/index.html">neat algebra</a>@.

But a database system needs more that just this algebra, since often it
is crucial to do table-updates (this would not be permitted in a strict
algebra).

All commands needed for BAT updates, property management, basic I/O, 
persistence, and storage options can be found in this module.

@* Module Definition
@m
.MODULE bat;

@- BAT basics
@m
.COMMAND bat(int ht, int tt) : BAT[any,any] = CMDnew_default;
"Creates a new empty transient BAT, with head- and tail-types as indicated."

.COMMAND new(int ht, int tt) : BAT[any,any] = CMDnew_default;
"Creates a new empty transient BAT, with head- and tail-types as indicated."

.COMMAND bat(int ht, int tt, wrd size) : BAT[any,any] = CMDnew;
"Creates a new empty BAT, directly allocating for 'size' elements."

.COMMAND new(int ht, int tt, wrd size) : BAT[any,any] = CMDnew;
"Creates a new empty BAT, directly allocating for 'size' elements."

.COMMAND bat(int ht, int tt, lng size) : BAT[any,any] = CMDnew_lng;
"Creates a new empty BAT, directly allocating for 'size' elements."

.COMMAND new(int ht, int tt, lng size) : BAT[any,any] = CMDnew_lng;
"Creates a new empty BAT, directly allocating for 'size' elements."

.COMMAND bat(int ht, int tt, int size) : BAT[any,any] = CMDnew_int;
"Creates a new empty BAT, directly allocating for 'size' elements."

.COMMAND new(int ht, int tt, int size) : BAT[any,any] = CMDnew_int;
"Creates a new empty BAT, directly allocating for 'size' elements."

.COMMAND densebat(wrd size) : BAT[void,void] = CMDdensebat;
"Creates a new [void,void] BAT of size 'size'."

.COMMAND reverse(BAT[any::1,any::2]) : BAT[any::2,any::1] = CMDreverse;
"Returns the reverse view of a BAT (head is tail and tail is head).
 BEWARE:  no copying is involved; input and output refer to the same object!"

.COMMAND mirror(BAT[any::1,any]) : BAT[any::1,any::1] = CMDmirror;
"Returns the head-mirror image of a BAT (two head columns)."

.COMMAND order(BAT[any::1,any::2] b) : BAT[any::1,any::2] = CMDorder;
"Sorts the BAT itself, in place, on ascending head values. Returns b."

.COMMAND order_rev(BAT[any::1,any::2] b) : BAT[any::1,any::2] = CMDorder_rev;
"Sorts the BAT itself, in place, on descending head values. Returns b."

.COMMAND sorder(BAT[any::1,any::2] b) : BAT[any::1,any::2] = CMDsorder;
"Stable sorts the BAT itself, in place, on ascending head values. Returns b."

.COMMAND sorder_rev(BAT[any::1,any::2] b) : BAT[any::1,any::2] = CMDsorder_rev;
"Stable sorts the BAT itself, in place, on descending head values. Returns b."

.COMMAND revert(BAT[any::1,any::2] b) : BAT[any::1,any::2] = CMDrevert;
"Puts all BUNs in a BAT in reverse order. Returns b."

@- BAT updates
@m
.COMMAND insert(BAT[any::1, any::2], any::1 h, any::2 t)
				: BAT[any::1,any::2] = CMDinsert_bun;
"Insert one BUN[h,t] in a BAT.
 Returns the modified BAT."

.COMMAND insert(BAT[any::1, any::2], BAT[any::1,any::2])
				: BAT[any::1,any::2] = CMDinsert_bat;
"Insert all BUNs of the second BAT into the first.
 Returns the modified BAT."

.COMMAND replace(BAT[any::1, any::2], any::1 h, any::2 t)
				: BAT[any::1,any::2] = CMDreplace_bun;
"Replace the tail value of one BUN that has some head value.
 Returns the modified BAT."

.COMMAND replace(BAT[any::1, any::2], BAT[any::1,any::2])
				: BAT[any::1,any::2] = CMDreplace_bat;
"Perform replace for all BUNs of the second BAT into the first.
 Returns the modified BAT."

.COMMAND replace(BAT[any::1, any::2], any::1 h, any::2 t, bit force)
				: BAT[any::1,any::2] = CMDreplace_bun_force;
"Replace the tail value of one BUN that has some head value.
 Returns the modified BAT."

.COMMAND replace(BAT[any::1, any::2], BAT[any::1,any::2], bit force)
				: BAT[any::1,any::2] = CMDreplace_bat_force;
"Perform replace for all BUNs of the second BAT into the first.
 Returns the modified BAT."

.COMMAND delete(BAT[any::1, any::2], any::1 h, any::2 t)
				: BAT[any::1,any::2] = CMDdelete_bun;
"Delete one specific BUN.
 Returns the modified BAT."

.COMMAND delete(BAT[any::1, any::2], any::1 h)
				: BAT[any::1,any::2] = CMDdelete_head;
"Delete all BUNs with a certain head value.
 Returns the modified BAT."

.COMMAND delete(BAT[any::1, any::2])
				: BAT[any::1,any::2] = CMDdelete_all;
"Delete all BUNs in a BAT.
 Returns the modified BAT."

.COMMAND delete(BAT[any::1, any::2] b, BAT[any::1,any] bn)
				: BAT[any::1,any::2] = CMDdelete_bat_head;
"Delete from the first BAT all BUNs with a head value that is in the second.
 Returns the modified BAT."

.COMMAND deleteBuns(BAT[any::1, any::2], BAT[any::1,any::2])
				: BAT[any::1,any::2] = CMDdelete_bat_bun;
"Delete from the first BAT all BUNs with a corresponding BUN in the second.
 Returns the modified BAT."

@+ void bats
The append set of commands lets you append values (or bats) with unique 
head values which start at the maximum head value before inserting plus one.
The appended bats tail can not be set key-ed. 
@m
.COMMAND append( BAT[oid,any::1] i, BAT[oid,any::1] u ) : BAT[oid,any::1] = BATappend_wrap; "append the content of u to i (renumbers u-oids' to unique numbers, starting at i.max()+1)"
.COMMAND append( BAT[oid,any::1] i, BAT[oid,any::1] u, bit force ) : BAT[oid,any::1] = BATappend_force; "append the content of u to i (renumbers u-oids' to unique numbers, starting at i.max()+1)"


.COMMAND append( BAT[void,any::1] i, BAT[void,any::1] u ) : BAT[void,any::1] = BATappend_wrap; "append the content of u to i"
.COMMAND append( BAT[void,any::1] i, BAT[void,any::1] u, bit force ) : BAT[void,any::1] = BATappend_force; "append the content of u to i"

.COMMAND append( BAT[void,any::1] i, BAT[oid,any::1] u ) : BAT[void,any::1] = BATappend_wrap; "append the content of u to i"
.COMMAND append( BAT[void,any::1] i, BAT[oid,any::1] u, bit force ) : BAT[void,any::1] = BATappend_force; "append the content of u to i"

.COMMAND append( BAT[oid,any::1] i, any::1 u ) : BAT[oid,any::1] = BUNappend_wrap; "append the value u to i"
.COMMAND append( BAT[oid,any::1] i, any::1 u, bit force ) : BAT[oid,any::1] = BUNappend_force; "append the value u to i"

.COMMAND append( BAT[void,any::1] i, any::1 u ) : BAT[void,any::1] = BUNappend_wrap; "append the value u to i"
.COMMAND append( BAT[void,any::1] i, any::1 u, bit force ) : BAT[void,any::1] = BUNappend_force; "append the value u to i"

.COMMAND inplace( BAT[void,any::1] o, oid id, any::1 val ) : BAT[void,any::1] = bun_inplace; "inplace replace values on the given locations"

.COMMAND inplace( BAT[void,any::1] o, BAT[oid,any::1] d ) : BAT[void,any::1] = bat_inplace; "inplace replace values on the given locations"

.COMMAND inplace( BAT[void,any::1] o, oid id, any::1 val, bit force ) : BAT[void,any::1] = bun_inplace_force; "inplace replace values on the given locations"

.COMMAND inplace( BAT[void,any::1] o, BAT[oid,any::1] d, bit force ) : BAT[void,any::1] = bat_inplace_force; "inplace replace values on the given locations"

@- BAT properties
Monet maintains a number of {\em properties} on each BAT that is used to steer tactical
query optimization (i.e. choosing a good algorithms for a particular algebra command).

These properties can be inspected with the {\tt info(BAT[any,any]) : BAT[str,str] } command:
\begin{verbatim}
> var car_age := bat(void,int);
> car_age.info().print();
#---------------------------------#
# BAT:		     tmp_31	  #
# (str)		     (str)	  #
#---------------------------------#
[ "batId",	     "car_age"	  ] # logical bat name
[ "batCacheid",	     "26"	  ] # BBP index
[ "head",	     "void"	  ] # physical head-type
[ "tail",	     "int"	  ] # physical tail-type
[ "batPersistence",  "persistent" ] # transient/session/persistent
[ "batRestricted",   "updatable"  ] # read-only/append-only/updatable
[ "batDirty",	     "clean"	  ] # clean/dirty
[ "batRefcnt",	     "1"	  ] # physical refcount
[ "batLRefcnt",	     "1"	  ] # logical refcount (total)
[ "batPlevel",	     "1"	  ] # logical refcount (persistent part)
[ "batSet",	     "0"	  ] # [head,tail] combinations are unique
[ "batCopiedtodisk", "1"	  ] # has been saved or not
\end{verbatim}

The above are global BAT properties. The properties {\tt batPersistence},
{\tt batRestricted} and {\tt batDirty} will be explained in the next section,
and the various reference counts in the section that follows it.

Per column, a number of properties are kept. We only show the head-properties; the tail properties
have the first character of their named replaced by 't' ({\tt sorted}, {\tt tdense}, etc.):

\begin{verbatim}
[ "hsorted",	     "1"	  ] # column is known to be sorted
[ "hdense",	     "1"	  ] # column is known to be densely ascended
[ "hseqbase",	     "0@0"	  ] # if densely ascending (i.e. 0@0, 1@0, @,0, ...): first value
\end{verbatim}

As described in the @[<a href="../../gdk/index.html#mod_1_3_0">GDK Technical Reference</a>@,
BATs store their data in one to six heaps. For each column type that is {\em variable-sized} - 
like {\tt str} - another
heap might be present ({\tt hheap} and {\tt theap}). 

\begin{verbatim}
[ "head.free",    "400004"	  ] # occupied size in bytes
[ "head.size",    "400012"	  ] # allocated size in bytes
[ "head.maxsize", "400012"	  ] # reserver virtual memory in bytes
[ "head.storage", "malloced"	  ] # malloced/mmap/priv
\end{verbatim}

Properties steer the algorithms that Monet uses to execute algebra command. For instance,
the {\tt find(BAT[any::1,any::2] b, any:;1) : any::2) that looks up a tail value by head,
uses binary search if and only if the head column is sorted (in other cases, hash-lookup
and scan are execution options).

Sometimes new (extension) code contains bugs in the property management, leaving false
properties on produced BATs. You can imagine that later on, this leads to additional
bugs, as e,g, the binary search algorithms will yield erroneous results on a non-sorted
sequence.

To make problem detection easier, the MIL interpreter contains property checking code,
that is set with via the  {\tt debugmask(int)} command:
\begin{description}
\item[2] {\tt debugmask(debugmask() or 2)} makes that all properties on
newly created BATs are checked. You must realize that finding out that a column is sorted
({\tt hsorted/tsorted}) costs a full scan, and finding out that it contains unique values
({\tt hkeyed/tkeyed}) costs a full scan plus the creation of a full hash index.
\item[8] {\tt debugmask(debugmask() or 8)} makes that all properties on
{\bf all} BATs handled by the MIL interpreter are checked. This will catch all property errors.
\end{description}

By default, both bits in the {\tt debugmask} are off, which gives fastest performance.
@m
.COMMAND count ( int bid ) : lng = CMDcount_bat;
"Returns the current size (in number of elements) of a BAT."

.COMMAND count ( BAT[void,void] b, lng cnt ) : lng = CMDsetcount_bat;
"Sets the size (in number of elements) of a BAT."

.COMMAND capacity ( int bid ) : lng = CMDcapacity;
"Returns the current allocation size (in max number of elements) of a BAT."

.COMMAND info ( BAT[any,any] ) : BAT[str,str] = CMDinfo;
"Produce a BAT containing info about a BAT in \"attribute\",\"value\" format.
 It contains all properties of the BAT record. See the BAT documentation in
 GDK for more information."

.COMMAND head ( int bid ) : str = CMDhead;
"Returns the type of the head column of a BAT, as a string."

.COMMAND head ( BAT[any,any] b ) : str = CMDhead_bat;
"Returns the type of the head column of a BAT, as a string."

.COMMAND htype ( int bid ) : int = CMDhtype;
"Returns the type of the head column of a BAT."

.COMMAND htype ( BAT[any,any] b ) : int = CMDhtype_bat;
"Returns the type of the head column of a BAT."

.COMMAND tail ( int bid ) : str = CMDtail;
"Returns the type of the tail column of a BAT, as a string."

.COMMAND tail ( BAT[any,any] b ) : str = CMDtail_bat;
"Returns the type of the tail column of a BAT, as a string."

.COMMAND ttype ( int bid ) : int = CMDttype;
"Returns the type of the tail column of a BAT."

.COMMAND ttype ( BAT[any,any] b ) : int = CMDttype_bat;
"Returns the type of the tail column of a BAT."

.COMMAND key( BAT[any::1,any::2] b, bit mode)
				: BAT[any::1,any::2] = CMDsetkey;
"Sets the 'key' property of the head column to 'mode'. In 'key' mode,
 the kernel will silently block insertions that cause a duplicate entries
 in the head column.
 KNOWN BUG: when 'key' is set to TRUE, this function does not automatically
 eliminate duplicates. Use b := b.kunique();"

.COMMAND key( BAT[any::1,any::2] b) : bit = CMDgetkey;
"return whether the head column of a BAT is unique (key)."

.COMMAND set( BAT[any::1,any::2] b, bit mode)
				: BAT[any::1,any::2] = CMDsetset;
"Sets the 'set' property on this BAT to 'mode'. In 'set' mode, the kernel
 will silently block insertions that cause a duplicate BUN [head,tail] entries
 in the BAT.
 KNOWN BUG: when 'set' is set to TRUE, this function does not automatically
 eliminate duplicates. Use b := b.sunique();
 Returns the BAT itself."

.COMMAND access( BAT[any::1,any::2] b, int mode)
				: BAT[any::1,any::2] = CMDsetaccess;
"Try to change the update access priviliges to this BAT. Mode:
 BAT_READ   - allow only read access.
 BAT_APPEND - allow reads and insertions of new elements.
 BAT_WRITE  - allow reads, insertions, and updates.
 BATs are updateable by default. On making a BAT readonly, all
 subsequent updates fail with an error message.
 Returns the BAT itself."

.COMMAND access( BAT[any::1,any::2] b) : int = CMDgetaccess;
"Return the update access privilige of a BAT."

.COMMAND seqbase( BAT[oid,any::1] b ) : oid = CMDget_seqbase;
"Get the sequence base for the void vcolumn of a BAT."

.COMMAND seqbase( BAT[void,any::1] b ) : oid = CMDget_seqbase;
"Get the sequence base for the void vcolumn of a BAT."

.COMMAND seqbase( BAT[void,any::1] b, oid seqbase)
				: BAT[void,any::1] = CMDset_seqbase;
"Set the sequence base for the void vcolumn of a BAT.
 Returns the BAT itself."

.COMMAND ordered(BAT[any,any]) : bit = CMDordered;
"Returns whether a BAT is ordered on head or not."

.COMMAND ordered_rev(BAT[any,any]) : bit = CMDordered_rev;
"Returns whether a BAT is ordered on head or not."

.COMMAND chk_order(BAT[any::1,any::2]) : BAT[any::1,any::2] = CMDchk_order;
"Infer the sortedness property (or not) of both head and tail."

.COMMAND assert_order(BAT[any::1,any::2]) : BAT[any::1,any::2] = CMDassert_order;
"Assert the sortedness property of tail."

.COMMAND batsize(str batname) : lng = CMDbatsize_str;
"A version of BATsize that does not require loading the BAT."

.COMMAND batsize(BAT[any,any] b) : lng = CMDbatsize;
"A version of BATsize that does not require loading the BAT."

.COMMAND batdsksize(BAT[any,any] b) : lng = CMDbatdsksize;
"batdsksize returns the size on disk rather than in memory"

@- BUN Access
@m
.ITERATOR  batloop(BAT[any,any], ptr handle) = CMDbatloop_std;
"Iterators are special MIL constructs:
  <bat-expression> @ <iterator>(<parameters>) <MIL-statement>
 'b@batloop()..' iterates over all BUNs [$h,$t] of BAT b."

.ITERATOR  batloop(BAT[any,any], ptr handle, int low, int high) = CMDbatloop;
"Iterators are special MIL constructs:
  <bat-expression> @ <iterator>(<parameters>) <MIL-statement>
 'b@batloop(low,high)..' iterates over all BUNs of b.slice(low,high)"

.ITERATOR  hashloop(BAT[any::1,any] b, ptr handle, any::1 val) = CMDhashloop;
"Iterators are special MIL constructs:
  <bat-expression> @ <iterator>(<parameters>) <MIL-statement>
 'b@hashloop(v)..' iterates over all BUNs [$h,$t] of BAT b where ($h = val)."

@- BAT I/O, Persistency
The BAT Buffer Pool (BBP) manages all known BATs. It administers
their logical and physical names and a reference count. BATs can
be {\em persistent}, {\em transient} or {\em session}. The BBP also manages
swapping on a BAT level: a BAT is either loaded entirely or not.
MIL variables of type {\tt bat} can either be loaded or not. When
the Monet server is started, all BATs are swapped out. If an unloaded
bat-variable is used as an operand in a command, it is automatically
loaded.	 The BBP applies a simple but effective LRU based swapping
algorithm. BATs have a {\em heat}, which drops over time, and is
increased when a BAT is used by some command.  If the size of the
allocated arena gets to be large, BATs may be swapped out.
@m
.COMMAND bbpname ( BAT[any,any] , str s) : BIT = CMDrename;
"Give a logical name to a BAT. This can fail if a BAT with name 's' already
 exists. The command then returns FALSE, else TRUE."

.COMMAND bbpname ( BAT[any,any]) : STR = CMDname;
"Gives back the logical name of a BAT."

.COMMAND roles ( BAT[any::1,any::2] , str h, str t)
				: BAT[any::1,any::2] = CMDroles;
"Give a logical name to the columns of a BAT.
 Returns the BAT itself."

.COMMAND col_name ( BAT[any,any] , str s) : BAT[any,any] = CMDcol_name;
"Give a logical name to tail column of a BAT.
 Returns the BAT itself."

.COMMAND persists( BAT[any::1,any::2], bit mode) : BAT[any::1,any::2] = CMDpersists;
"Make the BAT persistent (mode = TRUE), transient (mode = FALSE).
 or session (mode = bit(nil)). Returns the BAT itself."

.COMMAND destroy(str nme ) : bit = CMDdestroy;
"Destroys the BAT."

.COMMAND save(str nme) : bit = CMDsave;
"Save a BAT to storage, if it was loaded and dirty. Returns whether IO was necessary.
 Please realize that calling this function violates the atomic repository commit protocol!!"

.COMMAND unload(str name) : bit = CMDunload;
"Swapout a BAT to disk. Transient BATs can also be swapped out.
 Returns whether the unload indeed happened. "

.COMMAND hot(str name) : void = CMDhot;
"Makes a BAT very hot for the BBP. The chance of being chosen for swapout is
 small, afterwards."

.COMMAND cold(str nme) : void = CMDcold;
"Makes a BAT very cold for the BBP. The chance of being choses for swapout is
 big, afterwards."

.COMMAND heat(str nme) : int = CMDheat;
"returns the current BBP heat (LRU stamp)"


@- Heap Specific Commands
BATs are stored in memory in a number of Heap objects. A heap is nothing
more than a contiguous range of memory. Bats are saved to disk by just writing
away their image. This approach without pointer swizzling makes it possible
to either load an image into an alloced range of memory (STORE\_MEM), or
memory-map (STORE\_MMAP) an image into virtual memory.

The heap images of a BAT are stored in the {\tt $MONETHOME/dbfarm/$DB/bat/}
directory.  For each bat X, the following heaps are stored:
\begin{description}
\item[X.buns] an array with all the fixed-size parts of all BUNs.
\item[X.hheap] if the head column contains a variable sized atoms (e.g. str),
then the fixed-size part of a BUN contains an integer byte-offset into
the heap. String values themselves are stored in this the X.hheap.
\item[X.theap] similar to X.hheap, but for the tail column.
\item[X.hacc]. On each column, you might create {\em persistent hash accelerator
structure}. 
\end{description}

Each of these heaps can be {\bf compressed} using the Unix {\tt compress}
utility forming a X.ext.Z file. Monet will automatically decompress it
upon load. Compressed heaps cannot be memory mapped.

A final file present for each t in the BAT directory is:
\begin{description}
\item[X.desc] the BAT descriptor. Stores most of the properties of a BAT.
\end{description}
@
For more technical information on BATs, we refer to the
@[<a href="../../gdk/index.html">GDK</a>@
documentation.
@m
.COMMAND mmap(BAT[any::1,any::2], int head_mode, int tail_mode, int hheap_mode, int theap_mode) : BAT[any::1,any::2] = CMDmmap;
"For each individual heap, you can change the allocation mode to
 either STORE_MEM or STORE_MMAP. Passing an int(nil) means: no change.
 Changing a dirty STORE_MEM heap into STORE_MMAP, will cause a BAT save
 (this has to happen before the heap can be mapped into virtual memory).
 These modes are persistent. "

.COMMAND madvise(BAT[any::1,any::2], int head_mode, int tail_mode, int hheap_mode, int theap_mode) : BAT[any::1,any::2] = CMDmadvise;
"Modern Operating Systems allow users to influence the buffer management
 policy of virtual memory. This is a crucial feature for database systems,
 and eliminates the need to reimplement the OS in a database buffer manager.
 The supported flags are BUF_NORMAL (the normal adaptive kernel algorithm),
 BUF_RANDOM (no page prefetching), BUF_SEQUENTIAL (prefetch and swapout),
 BUF_WILLNEED (load everything with prefetch), BUF_DONTNEED (swapout).
 These buffer management modes are not persistent.
 Returns the BAT operated upon."

.COMMAND msync(BAT[void,any::1] b, oid lo, oid hi, bit async) : BAT[void,any::1] = CMDmsync;
"flush any mmapped heap data that corresponds to the [lo,hi] oids (void column) to disk". 

.COMMAND remap(BAT[void,any::1] b, BAT[void,oid] map, bit force) : BAT[void,any::1] = CMDremap;
"create a page-wise access(BAT_WRITE) copy of the first parameter input BAT[void,X]. 

 The second parameter map BAT[void,oid] (seqbase 0@00) indicates the order
 in which the 65536-tuple logical pages must appear in the result. It may not 
 contain illegal nor duplicate page-ids in the tail (page-ids start at 0).

 If the last page of the input BAT is requested in the map, and the input bat is 
 not an exact multiple of 65536 (hence the last page is incomplete), the missing 
 tuples appear as NILs in the result. 

 Finally, note that this operation is optimized for the case where the input
 BAT is memory-mapped directly (not: privately mapped). In that case, you get
 a fast copy-on-write copy of the BUN heap. Otherwise, an im-memory copy is made."

.COMMAND [swizzle](BAT[oid,oid] b, BAT[void,oid] map) : BAT[oid,oid] = CMDswizzle;
"swizzle re-mapped oids (translate from logical to physical using a page-id map)"

.COMMAND [swizzle](BAT[void,oid] b, BAT[void,oid] map) : BAT[oid,oid] = CMDswizzle;
"swizzle re-mapped oids (translate from logical to physical using a page-id map)"

.COMMAND isolate(BAT[void,any] b, BAT[void,oid] dirty, bit pageids) : void = CMDisolate;
"isolate a copy-on-write bat from changes in its master, by touching 
 (and thus copying) to-be-affected pages. If 'pageids' is true, the oids
 are page-ids pointing into b instead of direct keys, and the idea is to 
 isolate the full 64K tuple logical page (instead of the physical page)."

@- BAT Accelerators
@m
.COMMAND accbuild(BAT[any,any] b, str acctype) = CMDaccbuild;
"Build an accelerator on the head column of b. The builtin accelerator
 types index and hash will be created as transient accelerators. They
 will not be saved on disk. User-defined accelerators must always be
 persistent."
.COMMAND accdel(BAT[any,any] b, str acctype) = CMDaccdel;
"Delete an accelerator on the head column of b."

@- Synced BATs
The binary model of Monet has important advantages when working in
main-memory. Tables are thin and very efficiently processed. The binary
model gives rise, however, to a larger-than-normal number of join
and semijoin operations. Relations are split up in vertical parts that
are very much related to each other. Then, for instance, multiple
similar semijoins occur on different vertical parts. By equipping the
kernel with knowledge about the correspondence of these parts, we
can greatly limit the amount of work to be done.

When two BATs effectively contain the same sequence of head elements,
we call them 'synced'. This is implemented by storing a very large
OID for each column. An update to the column destroys this OID.
By comparing two OIDs the Monet kernel can very quickly decide that
two columns are exactly equal. All BAT algebra operations propagate
these 'sync' OIDs with their own propagation rules.
@m
.COMMAND synced (BAT[any,any] b1, BAT[any,any] b2) : bit = CMDsynced;
"Tests whether two BATs are synced or not. "

.END bat;

@- system bats
@mil
    CONST monet_fcn_aut := bat("monet_fcn_aut");
    CONST monet_fcn_cnt := bat("monet_fcn_cnt");
    CONST monet_fcn_dat := bat("monet_fcn_dat");
    CONST monet_fcn_dsc := bat("monet_fcn_dsc");
    CONST monet_fcn_fcn := bat("monet_fcn_fcn");
    CONST monet_fcn_imp := bat("monet_fcn_imp");
    CONST monet_fcn_mid := bat("monet_fcn_mid");
    CONST monet_fcn_nme := bat("monet_fcn_nme");
    CONST monet_fcn_pro := bat("monet_fcn_pro");
    CONST monet_fcn_sig := bat("monet_fcn_sig");
    CONST monet_fcn_tpe := bat("monet_fcn_tpe");
    CONST monet_mod_acc := bat("monet_mod_acc");
    CONST monet_mod_atm := bat("monet_mod_atm");
    CONST monet_mod_cnt := bat("monet_mod_cnt");
    CONST monet_mod_dep := bat("monet_mod_dep");
    CONST monet_mod_drop := bat("monet_mod_drop");
    CONST monet_mod_hdl := bat("monet_mod_hdl");
    CONST monet_mod_load := bat("monet_mod_load");
    CONST monet_mod_nme := bat("monet_mod_nme");
    CONST monet_mod_proc := bat("monet_mod_proc");
    CONST monet_mod_use := bat("monet_mod_use");
    CONST monet_mod_var := bat("monet_mod_var");

@- constants for mmap()
@mil
    CONST STORE_MEM   := 0;	# load into GDKmalloced memory
    CONST STORE_MMAP  := 1;	# mmap() into virtual memory

    PROC msync(bat[void,any::1] b, oid lo, bit async) : bat[void,any::1] {
	return msync(b, lo, oid(count(b)), async);
    }

    PROC mmap(bat[any::1,any::2] b, int memmode) : bat[any::1,any::2] {
	return mmap(b, memmode, memmode, memmode, memmode );
    }

    # overload madvise to pass the same memory mode for all heaps
    PROC madvise(bat[any::1,any::2] b, int memmode) : bat[any::1,any::2] {
	return madvise(b, memmode, memmode, memmode, memmode );
    }

@- constants for madvise()
@mil
    CONST BUF_NORMAL	:= 0;	# No further special treatment
    CONST BUF_RANDOM	:= 1;	# Expect random page references
    CONST BUF_SEQUENTIAL:= 2;	# Expect sequential page references
    CONST BUF_WILLNEED	:= 3;	# Will need these pages
    CONST BUF_DONTNEED	:= 4;	# Don't need these pages

    PROC swizzle(oid o, BAT[void,oid] map) : oid {
	var pid := oid(lng(o) >> REMAP_PAGE_BITS);
	if (map.exist(pid))
	    return oid(<<(lng(map.find(pid)),REMAP_PAGE_BITS) + and(lng(o),REMAP_PAGE_MASK));
	return o;
    }

    PROC pagesample(BAT[oid,any] b) : BAT[oid,void] {
	var lb := [lng](b.project(nil)).access(BAT_WRITE);
	lb := reverse(kunique(reverse([:>>=](lb,REMAP_PAGE_BITS)))).access(BAT_WRITE);
	return reverse([oid]([:<<=](lb,REMAP_PAGE_BITS)));
    }

@- constants for readonly()
@mil
    CONST BAT_READ   := 1;	# allow only read access.
    CONST BAT_APPEND := 2;	# allow reads and insertions of new elements.
    CONST BAT_WRITE  := 0;	# allow reads, insertions, and updates.

    PROC destroy(bat[any,any] b) : bit{
	return destroy(str(b));
	}

    PROC capacity(bat[any,any] b) : lng {
	return capacity(int(b));
	}

    PROC save(bat[any::1,any::2] b) : bat[any::1,any::2] {
	save(bbpname(b));
	return b;
    }

    PROC load(str batname) : bat[any,any] {
	return bat(batname);
    }

    PROC cold(bat[any::1,any::2] b) : void {
	cold(b.bbpname());
    }

    PROC hot(bat[any::1,any::2] b) : void {
	hot(b.bbpname());
    }
@
@{
@{
@* Implementation Code

@= batconvert
	(BAT@2type(@1) == TYPE_bat)?(ptr)&((BAT*)@2)->batCacheid:(ptr)@2

@+ Information Functions

@c
#include "monetdb4_config.h"
#include "gdk.h"
#include "monet.h"
#include "bat.proto.h"

int
CMDnew_lng(BAT **ret, int *ht, int *tt, lng *cap)
{
	if (*cap < 0)
		*cap = 0;
	if (*cap > (lng) BUN_MAX)
		*cap = (lng) BUN_MAX;
	*ret = BATnew(*ht, *tt, (BUN) * cap);
	if (*ret)
		(*ret)->batDirty |= 2;
	return (*ret) ? GDK_SUCCEED : GDK_FAIL;
}

int
CMDnew_int(BAT **ret, int *ht, int *tt, int *cap)
{
	if (*cap < 0)
		*cap = 0;
#if SIZEOF_INT == SIZEOF_BUN
  if (*cap > (int) BUN_MAX)
	  *cap = (int) BUN_MAX;
#endif
	*ret = BATnew(*ht, *tt, (BUN) * cap);
	if (*ret)
		(*ret)->batDirty |= 2;
	return (*ret) ? GDK_SUCCEED : GDK_FAIL;
}

int
CMDnew(BAT **ret, int *ht, int *tt, wrd *cap)
{
	if (*cap < 0)
		*cap = 0;
	if (*cap > (wrd) BUN_MAX)
		*cap = (wrd) BUN_MAX;
	*ret = BATnew(*ht, *tt, (BUN) * cap);
	if (*ret)
		(*ret)->batDirty |= 2;
	return (*ret) ? GDK_SUCCEED : GDK_FAIL;
}

int
CMDnew_default(BAT **ret, int *ht, int *tt)
{
	wrd default_size = 0;

	return CMDnew(ret, ht, tt, &default_size);
}

int
CMDdensebat(BAT **ret, wrd *size)
{
	BAT *b, *bm;

	if (*size < 0)
		*size = 0;
	if (*size > (wrd) BUN_MAX)
		*size = (wrd) BUN_MAX;
	*ret = b = BATnew(TYPE_void, TYPE_void, (BUN) *size);
	if (b == NULL)
		return GDK_FAIL;
	bm = BBP_cache(-b->batCacheid);
	b->batDirty = 1;
	b->tseqbase = bm->hseqbase = 0;
	b->hseqbase = bm->tseqbase = 0;
	BATkey(b, TRUE);
	BATkey(bm, TRUE);
	BATsetcount(b, (BUN) *size);
	return GDK_SUCCEED;
}

int
CMDreverse(BAT **ret, BAT *b)
{
	*ret = BATmirror(b);
	BBPfix(b->batCacheid);
	return GDK_SUCCEED;
}

int
CMDmirror(BAT **ret, BAT *b)
{
	BAT *v = *ret = VIEWcombine(b);

	if (b->batRestricted == BAT_WRITE) {
		*ret = BATcopy(v, v->htype, v->ttype, FALSE);
		BBPreclaim(v);
	}
	return (*ret) ? GDK_SUCCEED : GDK_FAIL;
}

int
CMDrevert(BAT **ret, BAT *b)
{
	if (BATrevert(*ret = b) == NULL)
		return GDK_FAIL;
	BBPfix(b->batCacheid);
	return GDK_SUCCEED;
}

int
CMDorder(BAT **ret, BAT *b)
{
	if (BATorder(*ret = b) == NULL)
		return GDK_FAIL;
	BBPfix(b->batCacheid);
	return GDK_SUCCEED;
}

int
CMDorder_rev(BAT **ret, BAT *b)
{
	if (BATorder_rev(*ret = b) == NULL)
		return GDK_FAIL;
	BBPfix(b->batCacheid);
	return GDK_SUCCEED;
}

int
CMDsorder(BAT **ret, BAT *b)
{
	if (BATsorder(*ret = b) == NULL)
		return GDK_FAIL;
	BBPfix(b->batCacheid);
	return GDK_SUCCEED;
}

int
CMDsorder_rev(BAT **ret, BAT *b)
{
	if (BATsorder_rev(*ret = b) == NULL)
		return GDK_FAIL;
	BBPfix(b->batCacheid);
	return GDK_SUCCEED;
}

int
CMDinsert_bun(BAT **r, BAT *b, ptr h, ptr t)
{
	if (BUNins(*r = b, @:batconvert(b,h)@, @:batconvert(b,t)@,FALSE) == NULL)
		return GDK_FAIL;
	BBPfix(b->batCacheid);
	return GDK_SUCCEED;
}

int
CMDinsert_bat(BAT **r, BAT *b, BAT *s)
{
	if (BATins(*r = b, s, FALSE) == NULL)
		return GDK_FAIL;
	BBPfix(b->batCacheid);
	return GDK_SUCCEED;
}

int
CMDreplace_bun(BAT **r, BAT *b, ptr h, ptr t)
{
	if (BUNreplace(*r = b, @:batconvert(b,h)@, @:batconvert(b,t)@, 0) == NULL)
		return GDK_FAIL;
	BBPfix(b->batCacheid);
	return GDK_SUCCEED;
}

int
CMDreplace_bat(BAT **r, BAT *b, BAT *s)
{
	if (BATreplace(*r = b, s, 0) == NULL)
		return GDK_FAIL;
	BBPfix(b->batCacheid);
	return GDK_SUCCEED;
}

int
CMDreplace_bun_force(BAT **r, BAT *b, ptr h, ptr t, bit *force)
{
	if (BUNreplace(*r = b, @:batconvert(b,h)@, @:batconvert(b,t)@, *force) == NULL)
		return GDK_FAIL;
	BBPfix(b->batCacheid);
	return GDK_SUCCEED;
}

int
CMDreplace_bat_force(BAT **r, BAT *b, BAT *s, bit *force)
{
	if (BATreplace(*r = b, s, *force) == NULL)
		return GDK_FAIL;
	BBPfix(b->batCacheid);
	return GDK_SUCCEED;
}

int
CMDdelete_bun(BAT **r, BAT *b, ptr h, ptr t)
{
	if (BUNdel(*r = b, @:batconvert(b,h)@, @:batconvert(b,t)@, FALSE) == NULL)
		return GDK_FAIL;
	BBPfix(b->batCacheid);
	return GDK_SUCCEED;
}

int
CMDdelete_head(BAT **r, BAT *b, ptr h)
{
	if (BUNdelHead(*r = b, @:batconvert(b,h)@, FALSE) == NULL)
		return GDK_FAIL;
	BBPfix(b->batCacheid);
	return GDK_SUCCEED;
}

int
CMDdelete_all(BAT **r, BAT *b)
{
	if (BATclear(*r = b) == NULL)
		return GDK_FAIL;
	BBPfix(b->batCacheid);
	return GDK_SUCCEED;
}

int
CMDdelete_bat_bun(BAT **r, BAT *b, BAT *s)
{
	if (BATdel(*r = b, s, FALSE) == NULL)
		return GDK_FAIL;
	BBPfix(b->batCacheid);
	return GDK_SUCCEED;
}

int
CMDdelete_bat_head(BAT **r, BAT *b, BAT *s)
{
	if (BATdelHead(*r = b, s, FALSE) == NULL)
		return GDK_FAIL;
	BBPfix(b->batCacheid);
	return GDK_SUCCEED;
}


int
bun_inplace(BAT **res, BAT *b, oid *id, ptr t )
{
	int ret = void_inplace(b,*id,@:batconvert(b,t)@,FALSE);
	*res = b;
	BBPfix(b->batCacheid);
	return ret;
}

int
bun_inplace_force(BAT **res, BAT *b, oid *id, ptr t, bit *force )
{
	int ret = void_inplace(b,*id,@:batconvert(b,t)@,*force);
	*res = b;
	BBPfix(b->batCacheid);
	return ret;
}

int
bat_inplace(BAT **res, BAT *o, BAT *d)
{
	*res = o;
	if (void_replace_bat(o, d, FALSE) == BUN_NONE)
		return GDK_FAIL;
	BBPfix(o->batCacheid);
	return GDK_SUCCEED;
}

int
bat_inplace_force(BAT **res, BAT *o, BAT *d, bit *force)
{
	*res = o;
	if (void_replace_bat(o, d, *force) == BUN_NONE)
		return GDK_FAIL;
	BBPfix(o->batCacheid);
	return GDK_SUCCEED;
}

int
BATappend_force(BAT **res, BAT *i, BAT *u, bit *force)
{
	if (!BATappend(i, u, *force))
		return GDK_FAIL;
	*res = i;
	BBPfix(i->batCacheid);
	return GDK_SUCCEED;
}

int
BATappend_wrap(BAT **res, BAT *i, BAT *u)
{
	bit force = FALSE;
	return BATappend_force(res, i, u, &force);
}

int
BUNappend_force(BAT **res, BAT *i, ptr t, bit *force)
{
	*res = BUNappend(i, @:batconvert(i,t)@, *force);
	if (*res) {
		BBPfix((*res)->batCacheid);
		return GDK_SUCCEED;
	}
	return GDK_FAIL;
}

int
BUNappend_wrap(BAT **res, BAT *i, ptr t)
{
	bit force = FALSE;
	return BUNappend_force(res, i, t, &force);
}

static BAT *
lock_desc(bat bid)
{
	BBPfix(bid);
	return (BAT *) BBPgetdesc(bid);
}

static void
unlock_desc(bat bid)
{
	BBPunfix(bid);
}

int
CMDcount_bat(lng *res, int *bid)
{
	if (BBPcheck((bat) *bid, "CMDcount_bat")) {
		BAT *b = lock_desc((bat) *bid);

		if (b == NULL) {
			*res = lng_nil;
		} else if (BBP_cache((bat) *bid)) {
			*res = (lng) BATcount(b);
		} else {
			/* BAT not loaded */
			*res = (lng) ((b->H->heap.free) / Hsize(b) - b->batFirst );
		}
		unlock_desc(*bid);
	}
	return GDK_SUCCEED;
}

int
CMDsetcount_bat(lng *res, BAT *b, lng *c)
{
	if (*c > (lng) BUN_MAX || *c < 0) {
		GDKerror("CMDsetcount_bat: argument out of range\n");
		return GDK_FAIL;
	}
	BATsetcount(b, (BUN) *c);
	*res = *c;
	return GDK_SUCCEED;
}

int
CMDcapacity(lng *res, int *bid)
{
	if (BBPcheck((bat) *bid, "CMDcapacity")) {
		BAT *b = lock_desc((bat) *bid);

		if (b == NULL) {
			*res = lng_nil;
		} else {
			*res = (lng) BATcapacity(b);
		}
		unlock_desc(*bid);
	}
	return GDK_SUCCEED;
}

int
CMDhead(str *res, int *bid)
{
	if (BBPcheck((bat) *bid, "CMDhead")) {
		str ret = (str)str_nil;
		BAT *b = lock_desc((bat) *bid);

		if (b) {
			ret = *bid > 0 ? ATOMname(b->htype) : ATOMname(b->ttype);
		}
		*res = GDKstrdup(ret);
		unlock_desc(*bid);
	} else {
		*res = GDKstrdup(str_nil);
	}
	return GDK_SUCCEED;
}

int
CMDhead_bat(str *res, BAT *b)
{
	return CMDhead(res, &b->batCacheid);
}

int
CMDhtype(int *res, int *bid)
{
	int ret = int_nil;
	if (BBPcheck((bat) *bid, "CMDhtype")) {
		BAT *b = lock_desc((bat) *bid);
		if (b) {
			ret = *bid > 0 ? b->htype : b->ttype;
		}
		unlock_desc(*bid);
	} *res = ret;
	return GDK_SUCCEED;
	
}

int
CMDhtype_bat(int *res, BAT *b)
{
	*res = b->htype; 
	return GDK_SUCCEED;
}

int
CMDtail(str *res, int *bid)
{
	if (BBPcheck((bat) *bid, "CMDtail")) {
		str ret = (str)str_nil;
		BAT *b = lock_desc((bat) *bid);

		if (b) {
			ret = *bid > 0 ? ATOMname(b->ttype) : ATOMname(b->htype);
		}
		*res = GDKstrdup(ret);
		unlock_desc(*bid);
	} else {
		*res = GDKstrdup(str_nil);
	}
	return GDK_SUCCEED;
}

int
CMDtail_bat(str *res, BAT *b)
{
	return CMDtail(res, &b->batCacheid);
}

int
CMDttype(int *res, int *bid)
{
	int ret = int_nil;
	if (BBPcheck((bat) *bid, "CMDttype")) {
		BAT *b = lock_desc((bat) *bid);
		if (b) {
			ret = *bid > 0 ? b->ttype : b->htype;
		}
		unlock_desc(*bid);
	} *res = ret;
	return GDK_SUCCEED;
}

int
CMDttype_bat(int *res, BAT *b)
{
	*res = b->ttype; 
	return GDK_SUCCEED;
}



int
CMDsetkey(BAT **result, BAT *input, bit *param)
{
	BATkey(*result = input, *param ? BOUND2BTRUE : FALSE);
	BBPfix(input->batCacheid);
	return GDK_SUCCEED;
}

int
CMDsetset(BAT **result, BAT *input, bit *param)
{
	BATset(*result = input, *param ? BOUND2BTRUE : FALSE);
	BBPfix(input->batCacheid);
	return GDK_SUCCEED;
}

int
CMDordered(bit *result, BAT *input)
{
	*result = BATordered(input) ? 1 : 0;
	return GDK_SUCCEED;
}

int
CMDchk_order(BAT **result, BAT *input)
{
	BATordered(input);
	BATordered(BATmirror(input));
	BBPfix(input->batCacheid);
	*result = input;
	return GDK_SUCCEED;
}

int
CMDassert_order(BAT **result, BAT *input)
{
	PROPDEBUG {
	    /* only with -d8 actually check */
	    BATordered(BATmirror(input));
	    if (!(BATtordered(input)&1)) {
		GDKerror("assert_order(%s): tail was not ordered.\n", BBP_logical(input->batCacheid));
		return GDK_FAIL;
	    }
	}

	/* mark tail sorted */
	if (!(BATtordered(input)&1)) {
	    input->tsorted = GDK_SORTED;
	    input->batDirtydesc = TRUE;
	}
	BBPfix(input->batCacheid);
	*result = input;
	return GDK_SUCCEED;
}

int
CMDordered_rev(bit *result, BAT *input)
{
	*result = BATordered_rev(input) ? 1 : 0;
	return GDK_SUCCEED;
}

int
CMDgetkey(bit *ret, BAT *b)
{
	/* we must take care of the special case of a nil column (TYPE_void,seqbase=nil)
	 * such nil columns never set hkey (and BUNins will never invalidate it if set) yet
	 * a nil column of a BAT with <= 1 entries does not contain doubles => return TRUE.
	 */
	if (BATcount(b) <= 1) {
		*ret = TRUE;
	} else {
		if (!b->hkey) {
			BATpropcheck(b, BATPROPS_ALL);
		}
		*ret = b->hkey ? TRUE : FALSE;
	}
	return GDK_SUCCEED;
}

int
CMDpersists(BAT **r, BAT *input, bit *param)
{
	BATmode(*r = input, (*param == TRUE) ? PERSISTENT : (*param == FALSE) ? TRANSIENT : SESSION);
	BBPfix(input->batCacheid);
	return GDK_SUCCEED;
}

int
CMDdestroy(bit *res, str input )
{
	int bid = BBPindex(input);

	*res = FALSE;
	if (bid) {
		BBPfix(bid);
		if (BBPindex(input) == bid) {
			BAT *b = (BAT*)BBPgetdesc(ABS(bid));

			BATmode(b, TRANSIENT);
			*res = TRUE;
		}
		BBPunfix(bid);
	}
	return GDK_SUCCEED;
}

int
CMDsetaccess(BAT **r, BAT *input, int *param)
{
	bat oldCacheid = input->batCacheid;

	*r = BATsetaccess(input, *param);
	if ((*r)->batCacheid == oldCacheid) {
		BBPfix(oldCacheid);
	}
	return GDK_SUCCEED;
}

int
CMDgetaccess(int *r, BAT *input)
{
	*r = BATgetaccess(input);
	return GDK_SUCCEED;
}

static char *
pre(str s1, str s2)
{
	static char buf[64];

	snprintf(buf, 64, "%s%s", s1, s2);
	return buf;
}
static char *
local_itoa(ssize_t i)
{
	static char buf[32];

	snprintf(buf, 32, SSZFMT, i);
	return buf;
}
static char *
local_utoa(size_t i)
{
	static char buf[32];

	snprintf(buf, 32, SZFMT, i);
	return buf;
}

#define COLLISION 64 

static void
HASHinfo(BAT *bn, Hash *h, str s)
{
	BUN i;
	BUN j;
	BUN k;
	BUN cnt[COLLISION + 2];

	BUNins(bn, pre(s, "type"), ATOMname(h->type),FALSE);
	BUNins(bn, pre(s, "mask"), local_utoa(h->mask),FALSE);
	BUNins(bn, pre(s, "lim"), local_utoa(h->lim),FALSE);

	for (i = 0; i <= COLLISION + 1; i++) {
		cnt[i] = 0;
	}
	for (i = 0; i <= h->mask; i++) {
		if (h->hash[i] == BUN_NONE) {
			cnt[0]++;
		} else if (h->hash[i] > h->lim) {
			GDKerror("HASHinfo: hash consistency problem " BUNFMT "\n", i);
		} else {
			j = HASHlist(h, h->hash[i]);
			for (k = 0; j; k++)
				j >>= 1;
			cnt[k]++;
		}
	}

	for (i = 0; i <= COLLISION + 1; i++)
		if (cnt[i]) {
			BUNins(bn, pre(s, local_itoa((ssize_t) (i?(1<<(i-1)):0))), local_utoa((size_t) cnt[i]), FALSE);
		}
}

static void
infoHeap(BAT *bn, Heap *hp, str nme)
{
	char buf[1024], *p = buf;

	if (!hp)
		return;
	while (*nme)
		*p++ = *nme++;
	strcpy(p, "free");
	BUNins(bn, buf, local_utoa(hp->free),FALSE);
	strcpy(p, "size");
	BUNins(bn, buf, local_utoa(hp->size),FALSE);
	strcpy(p, "maxsize");
	BUNins(bn, buf, local_utoa(hp->maxsize),FALSE);
	strcpy(p, "storage");
	BUNins(bn, buf, (hp->base == NULL || hp->base == (char*)1) ? "absent" : (hp->storage == STORE_MMAP) ? (hp->filename ? "memory mapped" : "anonymous vm") : (hp->storage & STORE_PRIV) ? "private map" : "malloced",FALSE);
	strcpy(p, "newstorage");
	BUNins(bn, buf, (hp->newstorage == STORE_MEM) ? "malloced" : (hp->newstorage & STORE_PRIV) ? "private map" : "memory mapped",FALSE);
	strcpy(p, "filename");
	BUNins(bn, buf, hp->filename ? hp->filename : "no file",FALSE);
}

static char *
oidtostr(oid i)
{
	int len = 48;
	static char bf[48];
	char *p = bf;

	(void) OIDtoStr(&p, &len, &i);
	return bf;
}

int
CMDinfo(BAT **retval, BAT *b)
{
	BAT *bn;
	char mode[1024], *accessmode;

	if (!(bn = BATnew(TYPE_str, TYPE_str, 128)))
		return GDK_FAIL;
	*retval = bn;

	if (b->batPersistence == PERSISTENT) {
		strcpy(mode, "persistent");
	} else if (b->batPersistence == SESSION) {
		strcpy(mode, "session");
	} else if (b->batPersistence == TRANSIENT) {
		strcpy(mode, "transient");
	} else {
		strcpy(mode, "unknown");
	}

	switch (b->batRestricted) {
	case BAT_READ:
		accessmode = "read-only";
		break;
	case BAT_WRITE:
		accessmode = "updatable";
		break;
	case BAT_APPEND:
		accessmode = "append-only";
		break;
	default:
		accessmode = "unknown";
	}

	BUNins(bn, "batId", BATgetId(b),FALSE);
	BUNins(bn, "batCacheid", local_itoa((ssize_t)(b->batCacheid)),FALSE);
	BUNins(bn, "hparentid", local_itoa((ssize_t)(b->H->parentid)),FALSE);
	BUNins(bn, "tparentid", local_itoa((ssize_t)(b->T->parentid)),FALSE);
	BUNins(bn, "batSharecnt", local_itoa((ssize_t)(b->batSharecnt)),FALSE);
	BUNins(bn, "batCount", local_utoa((size_t)b->batCount),FALSE);
	BUNins(bn, "batCapacity", local_utoa((size_t)b->batCapacity),FALSE);
	BUNins(bn, "head", ATOMname(b->htype),FALSE);
	BUNins(bn, "tail", ATOMname(b->ttype),FALSE);
	BUNins(bn, "batPersistence", mode,FALSE);
	BUNins(bn, "batRestricted", accessmode,FALSE);
	BUNins(bn, "batRefcnt", local_itoa((ssize_t)(BBP_refs(b->batCacheid))),FALSE);
	BUNins(bn, "batLRefcnt", local_itoa((ssize_t)(BBP_lrefs(b->batCacheid))),FALSE);
	BUNins(bn, "batDirty", BATdirty(b) ? "dirty" : "clean",FALSE);
	BUNins(bn, "batSet", local_itoa((ssize_t)(b->batSet)),FALSE);

	BUNins(bn, "hsorted", local_itoa((ssize_t)(BAThordered(b))),FALSE);
	BUNins(bn, "hident", b->hident,FALSE);
	BUNins(bn, "hdense", local_itoa((ssize_t)(BAThdense(b))),FALSE);
	BUNins(bn, "hseqbase", oidtostr(b->hseqbase),FALSE);
	BUNins(bn, "hkey", local_itoa((ssize_t)(b->hkey)),FALSE);
	BUNins(bn, "hvarsized", local_itoa((ssize_t)(b->hvarsized)),FALSE);
	BUNins(bn, "halign", local_utoa(b->halign),FALSE);
	BUNins(bn, "hnosorted", local_utoa(b->H->nosorted),FALSE);
	BUNins(bn, "hnosorted_rev", local_utoa(b->H->nosorted_rev),FALSE);
	BUNins(bn, "hnodense", local_utoa(b->H->nodense),FALSE);
	BUNins(bn, "hnokey[0]", local_utoa(b->H->nokey[0]),FALSE);
	BUNins(bn, "hnokey[1]", local_utoa(b->H->nokey[1]),FALSE);
	BUNins(bn, "hnonil", local_utoa(b->H->nonil),FALSE);
	BUNins(bn, "hnil", local_utoa(b->H->nil),FALSE);

	BUNins(bn, "tident", b->tident,FALSE);
	BUNins(bn, "tdense", local_itoa((ssize_t)(BATtdense(b))),FALSE);
	BUNins(bn, "tseqbase", oidtostr(b->tseqbase),FALSE);
	BUNins(bn, "tsorted", local_itoa((ssize_t)(BATtordered(b))),FALSE);
	BUNins(bn, "tkey", local_itoa((ssize_t)(b->tkey)),FALSE);
	BUNins(bn, "tvarsized", local_itoa((ssize_t)(b->tvarsized)),FALSE);
	BUNins(bn, "talign", local_utoa(b->talign),FALSE);
	BUNins(bn, "tnosorted", local_utoa(b->T->nosorted),FALSE);
	BUNins(bn, "tnosorted_rev", local_utoa(b->T->nosorted_rev),FALSE);
	BUNins(bn, "tnodense", local_utoa(b->T->nodense),FALSE);
	BUNins(bn, "tnokey[0]", local_utoa(b->T->nokey[0]),FALSE);
	BUNins(bn, "tnokey[1]", local_utoa(b->T->nokey[1]),FALSE);
	BUNins(bn, "tnonil", local_utoa(b->T->nonil),FALSE);
	BUNins(bn, "tnil", local_utoa(b->T->nil),FALSE);

	BUNins(bn, "batInserted", local_utoa(b->batInserted),FALSE);
	BUNins(bn, "batDeleted", local_utoa(b->batDeleted),FALSE);
	BUNins(bn, "batFirst", local_utoa(b->batFirst),FALSE);
	BUNins(bn, "htop", local_utoa(b->H->heap.free),FALSE);
	BUNins(bn, "ttop", local_utoa(b->T->heap.free),FALSE);
	BUNins(bn, "batStamp", local_itoa((ssize_t)(b->batStamp)),FALSE);
	BUNins(bn, "lastUsed", local_itoa((ssize_t)(BBP_lastused(b->batCacheid))),FALSE);
	BUNins(bn, "curStamp", local_itoa((ssize_t)(BBPcurstamp())),FALSE);
	BUNins(bn, "batCopiedtodisk", local_itoa((ssize_t)(b->batCopiedtodisk)),FALSE);
	BUNins(bn, "batDirtydesc", b->batDirtydesc ? "dirty" : "clean",FALSE);

	BUNins(bn, "H->heap.dirty", b->H->heap.dirty ? "dirty" : "clean",FALSE);
	BUNins(bn, "T->heap.dirty", b->T->heap.dirty ? "dirty" : "clean",FALSE);
	infoHeap(bn, &b->H->heap, "head.");
	infoHeap(bn, &b->T->heap, "tail.");

	BUNins(bn, "H->vheap->dirty", (b->H->vheap && b->H->vheap->dirty) ? "dirty" : "clean",FALSE);
	infoHeap(bn, b->hheap, "hheap.");

	BUNins(bn, "T->vheap->dirty", (b->T->vheap && b->T->vheap->dirty) ? "dirty" : "clean",FALSE);
	infoHeap(bn, b->theap, "theap.");

	/* dump index information */
	if (b->H->hash) {
		HASHinfo(bn, b->H->hash, "hhash->");
	}
	if (b->T->hash) {
		HASHinfo(bn, b->T->hash, "thash->");
	}
	return GDK_SUCCEED;
}

#define ROUND_UP(x,y) ((y)*(((x)+(y)-1)/(y)))

int
CMDbatdsksize(lng *tot, BAT *b)
{
	size_t blksize = 512;
	size_t size = 0;

	if (!isVIEW(b)) {
		size += ROUND_UP(b->H->heap.free, blksize);
		size += ROUND_UP(b->T->heap.free, blksize);
		if (b->hheap)
			size += ROUND_UP(b->hheap->free, blksize);
		if (b->theap)
			size += ROUND_UP(b->theap->free, blksize);
	}
	*tot = size;
	return GDK_SUCCEED;
}

int
CMDbatsize(lng *tot, BAT *b)
{
	size_t blksize = MT_pagesize();
	size_t size = 0;

	if (!isVIEW(b)) {
		BUN cnt = BATcapacity(b);

		size += ROUND_UP(b->H->heap.size, blksize);
		size += ROUND_UP(b->T->heap.size, blksize);
		if (b->hheap)
			size += ROUND_UP(b->hheap->size, blksize);
		if (b->theap)
			size += ROUND_UP(b->theap->size, blksize);
		if (b->H->hash)
			size += ROUND_UP(sizeof(BUN) * cnt, blksize);
		if (b->T->hash)
			size += ROUND_UP(sizeof(BUN) * cnt, blksize);
	}
	*tot = size;
	return GDK_SUCCEED;
}

int
CMDbatsize_str(lng *tot, str batname)
{
	bat bid = BBPindex(batname);
	BAT *b = bid ? (BAT *) BBPgetdesc(bid) : NULL;

	if (b == NULL) {
		GDKerror("CMDbatsize_str: %s no such bat.\n", batname);
		return GDK_FAIL;
	}
	return CMDbatsize(tot, b);
}

@+ Synced BATs
@c
int
CMDsynced(bit *ret, BAT *b1, BAT *b2)
{
	*ret = ALIGNsynced(b1, b2) ? 1 : 0;
	return GDK_SUCCEED;
}

@+ BBP Management, IO
@c
int
CMDroles(BAT **r, BAT *b, str hname, str tname)
{
	BATroles(*r = b, hname, tname);
	BBPfix(b->batCacheid);
	return GDK_SUCCEED;
}

int
CMDcol_name(BAT **r, BAT *b, str tname)
{
	BATcol_name(*r = b, tname);
	BBPfix(b->batCacheid);
	return GDK_SUCCEED;
}

int
CMDrename(bit *retval, BAT *b, str s)
{
	int ret;
	int c;
	char *t = s;

	for ( ; (c = *t) != 0; t++) {
		if (c != '_' && !GDKisalnum(c)) {
			GDKerror("CMDrename: identifier expected: %s\n", s);
			return GDK_FAIL;
		}
	}

	ret = BATname(b, s);
	*retval = FALSE;
	if (ret == 1) {
		GDKerror("CMDrename: identifier expected: %s\n", s);
		return GDK_FAIL;
	} else if (ret == BBPRENAME_ILLEGAL) {
		GDKerror("CMDrename: illegal temporary name: '%s'\n", s);
		return GDK_FAIL;
	} else if (ret == BBPRENAME_LONG) {
		GDKerror("CMDrename: name too long: '%s'\n", s);
		return GDK_FAIL;
	} else if (ret != BBPRENAME_ALREADY) {
		*retval = TRUE;
	}
	return GDK_SUCCEED;
}

int
CMDname(str *retval, BAT *b)
{
	*retval = GDKstrdup(BBPname(b->batCacheid));
	return GDK_SUCCEED;
}

int
CMDunload(bit *res, str input)
{
	bat bid = ABS(BBPindex(input));

	*res = FALSE;
	if (bid > 0) {
		BAT *b;

		BBPfix(bid);
		b = BBP_cache(bid);
		if (b) {
			if (b->batPersistence == SESSION)
				BATmode(b, TRANSIENT);
			BBPcold(bid);	/* will trigger unload of also persistent bats */
		}
		*res = BBPunfix(bid) == 0;
	}
	return GDK_SUCCEED;
}

int
CMDhot(str input)
{
	BBPhot(BBPindex(input));
	return GDK_SUCCEED;
}

int
CMDcold(str input)
{
	BBPcold(BBPindex(input));
	return GDK_SUCCEED;
}

int
CMDheat(int *res, str input)
{
	int bid = BBPindex(input);

	if (bid) {
		*res = BBP_lastused(bid) & 0x7fffffff;
	}
	return GDK_SUCCEED;
}

int
CMDsave(bit *res, str input)
{
	bat bid = BBPindex(input);
	BAT *b;

	*res = FALSE;
	if (bid) {
		BBPfix(bid);
		b = BBP_cache(bid);
		if (b && BATdirty(b)) {
			if (BBPsave(b) == 0)
				*res = TRUE;
		}
		BBPunfix(bid);
	}
	return GDK_SUCCEED;
}


@= change_heap
{
	if (@2) {
		int mode = (@2)->storage;

		if (*@1 == int_nil || *@1 == mode) {
			*@1 = -1;
		}
	}
}
@c
int
CMDmmap(BAT **r, BAT *b, int *hbns, int *tbns, int *hhp, int *thp)
{
	/* == int_nil means no change */
	if (*hbns == int_nil) 
		*hbns = b->batMaphead;
	if (*tbns == int_nil) 
		*tbns = b->batMaptail;
	if (b->hheap && *hhp == int_nil) 
		*hhp = b->batMaphheap;
	if (b->theap && *thp == int_nil) 
		*thp = b->batMaptheap;
	if (BATmmap(*r = b, *hbns, *tbns, *hhp, *thp) == 0) {
		BBPfix(b->batCacheid);
		return GDK_SUCCEED;
	}
	return GDK_FAIL;
}

int
CMDmadvise(BAT **r, BAT *b, int *hbns, int *tbns, int *hhp, int *thp)
{
	BBPfix(b->batCacheid);
	return BATmadvise(*r = b, (*hbns == int_nil) ? -1 : *hbns, (*tbns == int_nil) ? -1 : *tbns, (*hhp == int_nil) ? -1 : *hhp, (*thp == int_nil) ? -1 : *thp) ? GDK_FAIL : GDK_SUCCEED;
}

@+ Accelerator Control
@c
int
CMDaccbuild(BAT *b, str acc )
{
	if (strcmp(acc, "hash") == 0 && BAThash(b,0)) {
		return GDK_SUCCEED;
	}
	return GDK_FAIL;
}

int
CMDaccdel(BAT *b, str acc)
{
	if (strcmp(acc, "hash") == 0)
		HASHremove(b);
	return GDK_SUCCEED;
}

@+ Iterators
@= hashiter
	if (b->tvarsized) {
		HASHloop@1(bi, b->H->hash, idx, v)
			if ((i = ITERATE(v, BUNtvar(bi,idx), h)) < 0)
				return i;
	} else {
		HASHloop@1(bi, b->H->hash, idx, v)
			if ((i = ITERATE(v, BUNtloc(bi,idx), h)) < 0)
				return i;
	}
	break;
@c
int
CMDhashloop(BAT *b, ptr *handle, ptr v)
{
	BATiter bi = bat_iterator(b);
	Iteration h = *(Iteration *) handle;
	BUN idx;
	int i;

	if (BATprepareHash(b))
		return GDK_FAIL;

	switch (ATOMstorage(BAThtype(b))) {
	case TYPE_chr:
		@:hashiter(_chr)@
	case TYPE_bte:
		@:hashiter(_bte)@
	case TYPE_sht:
		@:hashiter(_sht)@
	case TYPE_int:
	case TYPE_flt:
		@:hashiter(_int)@
	case TYPE_dbl:
	case TYPE_lng:
		@:hashiter(_lng)@
	default:
		if (b->hvarsized) {
			@:hashiter(var)@
		} else {
			@:hashiter(loc)@
		}
	}
	return GDK_SUCCEED;
}

@= batlooparg
	if (@1 > BATcount(b)) {
		GDKerror("CMDbatloop: @1 parameter out of range (%lu %lu).\n", @1, BATcount(b));
		return GDK_FAIL;
	}
	@2 = BUNfirst(b) + @1;
@= batloopitr
	while (p <= q) {
		if ((i = ITERATE(BUNh@1(bi,p), BUNt@2(bi,p), h)) < 0)
			return i;
		p++;
	}
@c
static int
doCMDbatloop(BAT *b, ptr *handle, BUN low, BUN high)
{
	BATiter bi = bat_iterator(b);
	Iteration h = *(Iteration *) handle;
	BUN p, q;
	int i;

	if (high < low)
		return GDK_SUCCEED;
	@:batlooparg(low,p)@
	@:batlooparg(high,q)@
	if (b->hvarsized) {
		if (b->tvarsized) {
			@:batloopitr(var,var)@
		} else {
			@:batloopitr(var,loc)@
		}
	} else {
		if (b->tvarsized) {
			@:batloopitr(loc,var)@
		} else {
			@:batloopitr(loc,loc)@
		}
	}
	return GDK_SUCCEED;
}

/* XXX should be BUN *low, BUN *high for 64 bit architecture */
int
CMDbatloop(BAT *b, ptr *handle, int *low, int *high)
{
	return doCMDbatloop(b, handle, (BUN) * low, (BUN) * high);
}

int
CMDbatloop_std(BAT *b, ptr *handle)
{
	BUN n = BATcount(b);

	if (n == 0)
		return GDK_SUCCEED;
	return doCMDbatloop(b, handle, (BUN) 0, n - 1);
}

int
CMDget_seqbase(oid *o, BAT *b)
{
	*o = b->hseqbase;
	return GDK_SUCCEED;
}

int
CMDset_seqbase(BAT **r, BAT *b, oid *o)
{
	BATseqbase(*r = b, *o);
	BBPfix(b->batCacheid);
	return GDK_SUCCEED;
}

@+ Page-wise BAT remappings
The XML node storage scheme of MonetDB/XQuery needs some extra kernel support. 

\begin{itemize}
\item
  we introduce a fast way to create BATs with the VM pages in a different order
  (to cheaply support inserting new pages halfway). 
\item
  for other bats, there is a new rcopy(), that copies large heaps using
  copy-on-write memory maps. This is also done for string heaps, if they are
  no longer double eliminated. 
\item
  we introduce a primitive to swizzle OIDs for such remappings between RIDs (the real
  voids on disk) and PREs (the voids of the remapped copy).
\item
  we introduce 'isolate()' a primitive that executes a number of idempotent updates
  on a bat, such that all modified logical pages have received physical page
  copies (transparently by the MMU page faults it generates).
\end{itemize}

Also, we use copy-on-write maps for transaction isolation. Contrary to intuition, we 
write into STORE_MMAP read-only master bats (overriding the read-only protection 
with a new 'force' flag), and read only from the copy-on-write copies produced by 
the 'remap' and 'rcopy'. These copies provide efficient shadow paging. That is, before a master bat 
is replaced into (appends are no problem) then all live read copies (copy-on-write remaps) 
get a 'idempotent' replace on the affected pages (a BUN replace with a value that was 
already there), such that a shadow copy of the page is made by the OS. In this way, 
the subsequent update in the master bat is invisible in the copy-on-write copies 
(transaction isolation). 

The shadow copying could be done with BUN-replaces but can be optimized to touch just
one word per physical page. This is done by CMDisolate.

Similarly, the swizzle computations (from physical to logical id in remapped bats)
could be done with shifts, mask, addition and fetchjoins; it is done much faster
using the special-purpose CMDswizzle.  

other changes were:

\begin{itemize}
\item
  gdk_bat.mx/gdk_batop.mx: a 'force' flag in update operations that allow to update
  read-only/append-only BATs anyway. Note that if used, another (WAL-based) recovery
  mechanism must be used to repair BATs after a system crash!! This is a user
  respsonability (in this case, of the MonetDB/XQuery frontend).
\item
  gdk_bat.mx: make a true copy of remapped/rcopied BUN heaps if the bat becomes persistent 
  or updatable. 
\item
  gdk_batop.mx: optimized fetchjoin for idempotent positional joins (into a bat[void,void]
  with equal seqbase and all tuples hitting). To keep semantics consistent, it is now
  an error if a fetchjoin is performed with a key that is out-of-range. Everything *must* match!
\item
  gdk_storage.mx: batload.  To preserve the integritry of string heaps with such forced updates, 
  the kernel zaps the internal hash table of string heaps. Note that this is only allowed if 
  double-elimination inside the string heap is disabled (in that case the hash table is not 
  required to be complete).  To prevent problems, the rcopy() does not do mmap-tricks for 
  double-eliminating heaps.
\end{itemize}

In swizzling as well as in positional join, specific optimizations are made for
the common case where all pages appear in order (this occurs in XML tables that have
not yet received updates or are read-only). In this case swizzling is a no-op.

For read-only tables, logical node IDs (nids) are equal to both PREs and RIDs. A 
translation from NID to PRE (or RID) then becomes positional join onto a bat[void,void] 
with seqbases 0@0, which is an idempotent join. This case now returns a view at
zero cost.

@- Remapped Copy
CMDremap makes a copy of a bat, putting the logical 'pages' (REMAP_PAGE_SIZE tuples) in an 
alternative order, specified by a map. It is optimized to use copy-on-write memory 
mappings to make cheap copies, when possible.

The result is a read-only copy of the original. As it is a true copy, in principle 
we can replace (but nor insert/delete) BUNs in it, overriding the access restriction.

Making such bats persistent or appendable/writable, will force a true copy of the 
copy-on-write mmap heap to be made.
@c
static int
copy_segment(MT_mmap_hdl *hdl, BAT *bn, BAT *b, oid src, BUN dst, BUN cnt)
{
	int ret = 0;

	if (cnt) {
		size_t xx = REMAP_PAGE_SIZE * Tsize(b);
		off_t src_off = (off_t) (src * xx); /* 64bit: could overflow */
		size_t dst_off = dst * xx;
		size_t nbytes  = cnt * xx;
		size_t partial = (Tloc(b,BUNlast(b)) - Tloc(b,BUNfirst(b))) - src_off;

		if (!hdl) {
			/* copy segment from master bat */
			memcpy(Tloc(bn,BUNfirst(bn)) + dst_off, Tloc(b,BUNfirst(b)) + src_off, (partial < nbytes)?partial:nbytes);
		} else {
			if (MT_mmap_remap(hdl, src_off, nbytes) == (void *) -1) return 0;
		}
		if (partial < nbytes) {
			/* fill a partial page with nils */
			ptr nil = ATOMnilptr(bn->ttype);
			BUN cur = BUNfirst(bn) + (BUN) ((dst_off + partial) >> bn->T->shift);
			BUN end = BUNlast(bn);

			for (; cur < end; cur++) {
				ATOMreplace(bn->ttype, bn->theap, Tloc(bn,cur), nil); 
			}
		}
	}
	ret = 1;
bunins_failed:
	return ret;
}

int
CMDremap(BAT **res, BAT *b, BAT *map, bit *force)
{
	BATiter mapi = bat_iterator(map), bni;
	BUN cnt = BATcount(map), n = BATcount(b);
	BUN max = (BUN) (1 + (((ssize_t) n) - 1) / (size_t) REMAP_PAGE_SIZE);
	int (*fix) (ptr) = BATatoms[b->ttype].atomFix;
	int mode = (MMAP_READ|MMAP_SEQUENTIAL) | ((*force)?MMAP_WRITE:MMAP_COPY);
	oid* pid = (oid*) alloca(cnt*sizeof(oid));
	BUN xx, yy = 0, zz = 0;
	char path[PATHLENGTH];
	char *chk;
	BUN p, q;
	BAT *bn;
	BATstore *bs;
	MT_mmap_hdl hdl;

	/* try to use fast page-wise memory mapping technique on read-only mmapped [void,X] bats */ 
	char* mmappath = (b->batRestricted != BAT_WRITE &&
		    (b->T->heap.storage == STORE_MMAP))?path:NULL;

	/* sanity check on page map */
	if (BAThdense(map) == 0 || map->hseqbase ) {
		GDKerror("remap: map head column must be dense and starting from 0@0.\n");
		return GDK_FAIL;
	}
	if (b->ttype == TYPE_void) {
		/* remappings on bat[void,void] are only supported in the trivial case (all pages in order) */
		if (!BATtdense(map)) {
			GDKerror("remap: a bat[void,void] cannot me remapped.\n");
			return GDK_FAIL;
		}
		/* create another bat[void,void]. BEWARE: last page is not NIL padded!! */
		*res = bn = BATnew(TYPE_void, TYPE_void, 10);
		if (bn == NULL) return GDK_FAIL;
		BATseqbase(bn, 0);
		if (cnt) {
			oid mpid = *(oid*) BUNtail(mapi,BUNfirst(map));
			BATseqbase(BATmirror(bn), mpid << REMAP_PAGE_BITS);
		}
		BATsetcount(bn,cnt <<= REMAP_PAGE_BITS);
		return GDK_SUCCEED;
	}

	/* chk is a bit mask to ensure that no page is requested twice */
	chk = (char*) GDKmalloc(n = 1 + max/8);
	if (chk == NULL) return GDK_FAIL;
	memset(chk, 0, n);

	/* check that the set of requested page-ids is a subset of all existing page-ids */
	BATloop(map, p, q) {
		oid id = *(oid*) BUNtail(mapi, p);
		size_t idx = id >> 3;  
		char mask = (char) (1 << (id & 7));  
		if (id > max) {
			GDKerror("remap: map index " OIDFMT "@0 out of range [0@0," BUNFMT "@0]\n", id, max);
			GDKfree(chk);
			return GDK_FAIL;
		} else if (chk[idx] & mask) {
			GDKerror("remap: map index " OIDFMT "@0 occurs twice.\n", id);
			GDKfree(chk);
			return GDK_FAIL;
		}
		pid[yy++] = id;
		chk[idx] |= mask;
	}
	GDKfree(chk);

	/* create result bat descriptor */
	bs = BATcreatedesc(TYPE_void, b->ttype, TRUE);
	bn = bs ? &bs->B : NULL;
	*res = bn; 
	bni = bat_iterator(bn);
	if (bn == NULL) return GDK_FAIL;
	BATinit_idents(bn);

	bn->H->type = TYPE_void;
	bn->H->varsized = 1;
	bn->H->shift = 0;
	bn->H->width = 0;
	bn->H->seq = 0;
	bn->H->nonil = 0;

	bn->T->type = b->T->type;
	bn->T->varsized = b->T->varsized;
	bn->T->shift = b->T->shift; 
	bn->T->width = b->T->width;
	bn->T->seq = b->T->seq;

	bn->tsorted = 0;
	bn->tkey = 0;
	bn->T->nonil = 0;
	bn->batRestricted = BAT_READ;
	n = cnt << REMAP_PAGE_BITS;

	/* copy the entire tail heap (if present) */
	if (ATOMvarsized(bn->ttype)) {
		if (HEAPalloc(bn->theap, (size_t) (b->theap->free*BATMARGIN), 1) >= 0) {
			memcpy(bn->theap->base, b->theap->base, bn->theap->free = b->theap->free);
		} else {
			goto error;
		}
	}
	/* try to get a reserved mmap region */
	if (mmappath) {
		void *base;
		size_t heapsize = tailsize(bn, n);

		if (bn->T->heap.filename)
			GDKfree(bn->T->heap.filename); 
		bn->T->heap.filename = GDKstrdup(b->T->heap.filename); 
		if (bn->T->heap.filename == NULL)
			goto error;
		GDKfilepath(mmappath, BATDIR, bn->T->heap.filename, NULL);
		base = MT_mmap_open(&hdl, mmappath, mode, 0, heapsize, cnt);
		if (base == (void*) -1) goto error;

		bn->T->heap.base = base;
		bn->T->heap.size = bn->T->heap.maxsize = heapsize; 
		bn->T->heap.storage = STORE_MMAP;
		if (!*force)
			bn->T->heap.storage |= STORE_PRIV; 
	} else if (HEAPalloc(&bn->T->heap, n, Tsize(bn)) < 0) {
		goto error;
	}

	/* set the right bat size */
	bn->batCapacity = n;
	BATsetcount(bn, n);
	bn->batFirst = bn->batDeleted = 0;
	bn->batInserted = (cnt << REMAP_PAGE_BITS);

	/* go over all pages and copy them in segments that unite consecutively mapped pages */
	for(xx=1; xx<cnt; xx++) {
		if (pid[xx]-1 != pid[xx-1]) {
			if (!copy_segment(mmappath ? &hdl : NULL, bn, b, pid[zz], zz, xx-zz))
				break;
			zz = xx;
		}
	}
	if (xx < cnt || !copy_segment(mmappath ? &hdl : NULL, bn, b, pid[zz], zz, cnt-zz)) {
		HEAPfree(&bn->T->heap);
		goto error;
	}
	if (mmappath) {
		MT_mmap_close(&hdl);
		GDKvminc(tailsize(bn, n));
	}

	/* if the tail atom has refcounting, we must fix the copies */
	if (fix) {
		BATloop(bn, p, q) {
			fix(BUNtail(bni, p));
		}
	}
	BBPcacheit(bs);
	if (mmappath) {
		/* if copy-on-write was used, make bn a logical view on b */
		bn->P->lview = TRUE;
		bn->T->heap.copied = TRUE;
		if (bn->H->type != TYPE_void)
			BBPshare(bn->H->parentid = b->batCacheid);
		if (bn->T->type != TYPE_void)
			BBPshare(bn->T->parentid = -b->batCacheid);
	}
	return GDK_SUCCEED;
  error:
	if (mmappath)
		MT_mmap_close(&hdl);
	if (bn->theap) {
		HEAPfree(bn->theap);
		GDKfree(bn->theap);
	}
	HEAPfree(&bn->T->heap);
	BBPclear(bn->batCacheid);
	return GDK_FAIL;
}

@- page-wise OID swizzling
@c
#ifdef HAVE_RESTRICT
#define __r     restrict
#else
#ifdef HAVE___RESTRICT__
#define __r     __restrict__
#else
#define __r
#endif
#endif

#define SWIZZLE(idx) ((map[idx >> REMAP_PAGE_BITS] << REMAP_PAGE_BITS) | (idx & REMAP_PAGE_MASK))  
#define SWIZZLE_CHECK(idx) ((map[(idx >> REMAP_PAGE_BITS) & (ok &= ((idx >= max) - 1))] << REMAP_PAGE_BITS) | (idx & REMAP_PAGE_MASK))  

static int 
swizzle(oid max, int htpe, oid tbase, BUN cnt, 
	oid *__r hdst, oid *__r tdst, oid *__r map, oid *__r head, oid *__r tail) 
{
	BUN i, n = cnt;
	int ok = -1;

	if (tbase != oid_nil) {
		if (tbase + cnt > max) {
			ok = 0;
		} else if (htpe) {
			for(i=0; i<n; i++, tbase++) {
				*hdst++ = head[i];
				*tdst++ = SWIZZLE(tbase);
			}
		} else {
			for(i=0; i<n; i++, tbase++) {
				*tdst++ = SWIZZLE(tbase);
			}
		}
	} else {
		if (htpe) {
			for(i=0; i<n; i++) {
				*hdst++ = head[i];
				*tdst++ = SWIZZLE_CHECK(tail[i]);
			}
		} else {
			for(i=0; i<n; i++) {
				*tdst++ = SWIZZLE_CHECK(tail[i]);
			}
		}
	}
	return ok;
}

int
CMDswizzle(BAT **res, BAT *b, BAT *map)
{
	BATiter mapi = bat_iterator(map), bi = bat_iterator(b), bni;
	BUN xx, yy=0, n = BATcount(b), max = BATcount(map);
	oid *pid = (oid*) BUNtail(mapi, BUNfirst(map));
	BUN p, q;
	BAT *bn;
	oid sqbs;

	if (map->hseqbase) {
		GDKerror("[swizzle]: map %s should be a void column starting at 0@0.\n", 
			BBP_logical(map->batCacheid));
		return GDK_FAIL;
	}

	/* sometimes we can just return the input bat (idempotent swizzle) */
	if (max == 0 || (BATtdense(map) && map->tseqbase == 0)) { 
		/* special semantics: empty bat (max == 0) => no remapping */
		/* or if map-tdense with base 0 => do not check for out-of-range oids (HACK) */
		if (max && map->tseqbase) {
			GDKerror("[swizzle]: map %s is a void view.\n", BBP_logical(map->batCacheid)); 
			return GDK_FAIL;
		}
		*res = VIEWcreate(b, b); /* used in the fast, read-only XML case */
		return GDK_SUCCEED;
	} 

	/* for efficiency, we ensure the map to be a simple array (copy if necessary) */
	if (map->ttype == TYPE_void) {
		pid = (oid*) GDKmalloc(max*sizeof(oid));
		if (pid == NULL) return GDK_FAIL;
		BATloop(map, p, q)
			pid[yy++] = *(oid*) BUNtail(mapi,p);
	}

	/* create the result bat and set its final size */
	*res = bn = BATnew(BAThdense(b)?TYPE_void:b->htype, TYPE_oid, n);
	bni = bat_iterator(bn);
	if (bn == NULL) return GDK_FAIL;
	BATsetcount(bn, n);
	BATseqbase(bn, b->hseqbase);

	/* do the work in a fast function */
	xx = swizzle(max << REMAP_PAGE_BITS,		/* maximum offset (for range check) */
		     bn->htype,				/* generate a head column? */
		     BATtdense(b)?b->tseqbase:oid_nil,	/* input tail is dense? */
		     n,					/* number of input tuples */
		     (oid*) Hloc( bn, BUNfirst(bn)),	/* result array */
		     (oid*) Tloc( bn, BUNfirst(bn)),	/* result array */
		     pid,				/* page-id lookup array */
		     (oid*) BUNhloc(bi,BUNfirst(b)),	/* head input array */
		     (oid*) BUNtloc(bi,BUNfirst(b))	/* tail input array */
		     ) == 0;

	if (yy) GDKfree(pid);
	if (xx) {
		GDKerror("[swizzle]: %s contains illegal offsets.\n", BBP_logical(b->batCacheid)); 
		BBPreclaim(bn);
		return GDK_FAIL;
	}

	sqbs = n == 0 ? 0 : *(oid*)BUNhead(bni,BUNfirst(bn));
	bn->hdense = BAThdense(b) || (n < 2 && sqbs != oid_nil);
	if (bn->hdense) {
		BATseqbase(bn, sqbs);
	}
	bn->hsorted = (bn->hdense || BAThordered(b)&1) ? GDK_SORTED : FALSE;
	BATkey(bn, bn->hdense || b->hkey != 0);

	sqbs = n == 0 ? 0 : *(oid*)BUNtail(bni,BUNfirst(bn));
	bn->tdense = n < 2 && sqbs != oid_nil;
	if (bn->tdense) {
		BATseqbase(BATmirror(bn), sqbs);
	}
	bn->tsorted = bn->tdense ? GDK_SORTED : FALSE;
	BATkey(BATmirror(bn), bn->tdense || b->tkey != 0);

	return GDK_SUCCEED;
}

@- fast isolation support

If *pageids == TRUE, the oids are logical page-ids (REMAP_PAGE_SIZE) and the entire page
needs to be isolated. Note the distinction between physical and logical pages. VM needs
isolation on the physical level. The difference can be significant. A locical page is defined 
as a number of tuples (e.g. 64K) thus spans up to 512KB in case of a 8-byte type such as lng 
or oid. Such a a 512KB range may span up to 128 physical OS pages (MT_pagesize can be as low 
as 4KB on current systems).

All this is taken csre of by CMDisolate.
@c
int
CMDisolate(BAT *b, BAT *dirty, bit *pageids) {
	BATiter dirtyi = bat_iterator(dirty);
	int bogus = ~((((*pageids)&64)>>5) != (((*pageids)&32)>>4)); /* yields all ones */
	BUN cnt = BATcount(b);

	if (!BAThdense(b) || b->hseqbase || Tsize(b) != ATOMsize(b->ttype)) {
		GDKerror("isolate(%s): should be a unary column.\n", BBP_logical(b->batCacheid));
		return GDK_FAIL;
	}
	if (b->theap && b->theap->base && b->theap->storage != STORE_MEM) {
		GDKerror("isolate(%s): cannot isolate tail heaps.\n", BBP_logical(b->batCacheid));
		return GDK_FAIL;
	}
	if (b->T->heap.storage == STORE_MMAP) {
		GDKerror("isolate(%s): cannot isolate direct maps.\n", BBP_logical(b->batCacheid));
		return GDK_FAIL;
	}
	if (cnt && (b->T->heap.storage & STORE_PRIV)) {
		size_t pagebits, pagesize = MT_pagesize(), pagecnt = pagesize/ATOMsize(b->ttype);
		size_t pos, lim = 0, idx, xx, yy = pagecnt;
		unsigned int *bitmask;
		BUN p, q;
		for(pagebits=0; yy>1; pagebits++) yy >>= 1;

		/* determine the number of bitmask slots, and zalloc it */
		yy = 1+ ((cnt-1) >> (pagebits+5)); /* 5 is for 32, #bits in a unsigned int */
		bitmask = (unsigned int*) GDKmalloc(yy*sizeof(unsigned int));
		if (bitmask == NULL) {
			GDKerror("isolate(%s): memory failure.\n", BBP_logical(b->batCacheid));
			return GDK_FAIL;
		}
		for(xx=0; xx<yy; xx++) bitmask[xx] = 0;

		if (*pageids) {
			BATloop(dirty, p, q) {
				/* oid is a page number, calculate absolute oid */
				pos = (*(oid*) BUNtail(dirtyi,p)) << REMAP_PAGE_BITS;
				lim = pos + (size_t) REMAP_PAGE_SIZE;
	
				if (lim > cnt) lim = cnt; /* out of bounds!! */

				/* must touch all physical pages in this logical page */
				for(; pos<lim; pos+=pagecnt) { 
					idx = pos >> pagebits;
					bitmask[idx >> 5] |= 1 << (idx&31); 
				}
			}
		} else {
			/* oids are the BUNs that must be isolated */
			BATloop(dirty, p, q) {
				pos = *(oid*) BUNtail(dirtyi,p);

				if (pos > cnt) continue; /* out of bounds!! */

				idx = pos >> pagebits;
				bitmask[idx >> 5] |= 1 << (idx&31); 
			}
		}	

		/* write an idempotent byte into all pages that need isolation */
		for(xx=0; xx<yy; xx++) {
			unsigned int msk = bitmask[xx];
			if (msk) {
				chr *touch = ((chr*) b->T->heap.base) + xx * (pagesize << 5);
				do {
					if ((msk&127) == 0) { /* skip 7 clean pages */
						msk >>=7; touch += (pagesize<<3)-pagesize;
					} 
					if (msk&1) {
						/* do LOAD/STORE; bit-AND with all-ones to fool compiler */
						*(int*)touch = (*(int*)touch)&bogus; /* causes OS trap (copy-on-write) */
					} 
					msk >>= 1; touch += pagesize;
				} while(msk);
			} /* else: skip 32 clean pages */
		}
		GDKfree(bitmask);
	}
	return GDK_SUCCEED;
}

int
CMDmsync(BAT **r, BAT *b, oid* lo, oid *hi, bit *async)
{
	if (b->hseqbase == oid_nil || Tsize(b) > ATOMsize(ATOMtype(b->ttype))) {
		GDKerror("msync(%s, " OIDFMT ", " OIDFMT "): illegal head column.\n", BBP_logical(b->batCacheid), *lo, *hi);
		return GDK_FAIL;
	}
	if (*lo < b->hseqbase || *lo > *hi || (*hi - *lo) > BATcount(b)) {
		GDKerror("msync(%s, " OIDFMT ", " OIDFMT "): illegal lo-hi head range.\n", BBP_logical(b->batCacheid), *lo, *hi);
		return GDK_FAIL;
	}
	if (*lo < *hi && (b->T->heap.storage == STORE_MMAP)) {
		size_t lo_off = (*lo - b->hseqbase) * Tsize(b);
		size_t hi_off = (*hi - b->hseqbase) * Tsize(b);
		lo_off = (lo_off / MT_pagesize()) * MT_pagesize();
		hi_off = (((hi_off - 1) / MT_pagesize()) + 1) * MT_pagesize();
		if (MT_msync(b->T->heap.base, lo_off, hi_off - lo_off, (*async==TRUE)?MMAP_ASYNC:MMAP_SYNC)) {
			GDKerror("msync(%s, " OIDFMT ", " OIDFMT "): buns sync failed.\n", BBP_logical(b->batCacheid), *lo, *hi);
			return GDK_FAIL;
		}
	}
	if (b->theap && b->theap->storage == STORE_MMAP) { /* flush tail heaps fully */
		if (MT_msync(b->theap->base, 0, b->theap->free, (*async==TRUE)?MMAP_ASYNC:MMAP_SYNC)) { 
			GDKerror("msync(%s, " OIDFMT ", " OIDFMT "): tail sync failed.\n", BBP_logical(b->batCacheid), *lo, *hi);
			return GDK_FAIL;
		}
	}
	*r = b;
	BBPfix(b->batCacheid);
	return GDK_SUCCEED;
}
@}
@}
