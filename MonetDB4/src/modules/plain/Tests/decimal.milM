# Test
#The below MIL script stress-tests all operations on decimals, as well 
#as the performance of grouping, sort and join on decimal columns. 

module(decimal);module(xtables);module(alarm);module(mmath);

decimal_minrepeat(20);

var   dec_nil := decimal("nil");
var  dec_zero := decimal("-0000000000000000000000000000000000E-8989");
var  dec_tiny := decimal("+0.000000000000000000000000001122");
var  nec_tiny := decimal("-11220000000000E-40");
var dec_small := decimal(2244);
var nec_small := decimal("-22440000000000E-10");
var   dec_num := decimal("+4488E15");
var   nec_num := decimal("-44880000000000E5"); 
var   dec_big := decimal("+1122E40");
var   nec_big := decimal("-11220000000000E30"); 
var  dec_huge := decimal("+22440000000000E9000");
var  nec_huge := decimal("-2244E9010");

var dec_bat := new(str,decimal,10);
dec_bat.insert("dec_nil", dec_nil);
dec_bat.insert("dec_zero", dec_zero);
dec_bat.insert("dec_tiny", dec_tiny);
dec_bat.insert("nec_tiny", nec_tiny);
dec_bat.insert("dec_small", dec_small);
dec_bat.insert("nec_small", nec_small);
dec_bat.insert("dec_num", dec_num);
dec_bat.insert("nec_num", nec_num);
dec_bat.insert("dec_big", dec_big);
dec_bat.insert("nec_big", nec_big);
dec_bat.insert("dec_huge", dec_huge);
dec_bat.insert("nec_huge", nec_huge);

# test conversion to simple scalars
var dec_prc := [getprecision](dec_bat);
var dec_scl := [getscale](dec_bat);
var dec_flt := [flt](dec_bat);
var dec_int := [int](dec_bat);
var dec_lng := [lng](dec_bat);
var dec_dbl := [dbl](dec_bat);
# this one fails because there is no conversion defined to sht
var dec_sht := [sht](dec_bat);

print(dec_bat.col_name("value"), 
  dec_prc.col_name("precision"), 
  dec_scl.col_name("scale"));

print(dec_bat.col_name("value"), 
  dec_int.col_name("int"), 
  dec_lng.col_name("lng"));

print(dec_bat.col_name("value"), 
  dec_flt.col_name("flt"), 
  dec_dbl.col_name("dbl"));

# test reverse() conversion
print(dec_bat.col_name("decimal"), 
  [decimal](dec_int).col_name("from_int"), 
  [decimal](dec_lng).col_name("from_lng"));

print(dec_bat.col_name("decimal"), 
  [decimal](dec_flt).col_name("from_flt"));

print(dec_bat.col_name("decimal"), 
  [decimal](dec_dbl).col_name("from_dbl"));

# test set_scale and set_precision
print(dec_bat.col_name("decimal"), 
  [setscale](dec_bat,0).col_name("setscale(0)"),
  [setscale](dec_bat,10).col_name("setscale(10)"),
  [setscale](dec_bat,[-](dec_scl,5)).col_name("setscale(-5)"));

print(dec_bat.col_name("decimal"), 
  [setprecision](dec_bat,0).col_name("setprecision(0)"),
  [setprecision](dec_bat,10).col_name("setprecision(10)"),
  [setprecision](dec_bat,[-](dec_prc,5)).col_name("setprecision(-5)"));

print(dec_bat.col_name("decimal"), 
  [addscale](dec_bat,-5).col_name("addscale(-5)"),
  [addscale](dec_bat,5).col_name("addscale(5)"));

# test binary operators
var dec_zero := project(dec_bat.reverse(),0@0).reverse();
var dec_cart := join(dec_zero.reverse(),dec_zero);
var dec_bat1 := dec_cart.reverse().mark(0@0).reverse();
var dec_bat2 := dec_cart.mark(0@0).reverse();
var dec_raise := [-]([getprecision](dec_bat1),10);
var dec_prec := [-]([getprecision](dec_bat1),1);

print(dec_bat1.col_name("decimal1"),
  dec_raise.col_name("raise"),
  [pow](dec_bat1,dec_raise).col_name("pow"));

print(dec_bat1.col_name("decimal1"),
  dec_raise.col_name("raise"),
  dec_prec.col_name("precision"),
  [pow](dec_bat1,dec_raise,dec_prec).col_name("pow"));

print(dec_bat1.col_name("decimal1"),
  dec_bat2.col_name("decimal2"),
  [*](dec_bat1,dec_bat2).col_name("*"));

print(dec_bat1.col_name("decimal1"),
  dec_bat2.col_name("decimal2"),
  [/](dec_bat1,dec_bat2).col_name("/"));

print(dec_bat1.col_name("decimal1"),
  dec_bat2.col_name("decimal2"),
  [divide](dec_bat1,dec_bat2,10).col_name("divide"));

print(dec_bat1.col_name("decimal1"),
  dec_bat2.col_name("decimal2"),
  dec_prec.col_name("precision"),
  [divide](dec_bat1,dec_bat2,dec_prec).col_name("divide"));

print(dec_bat1.col_name("decimal1"),
  dec_bat2.col_name("decimal2"),
  [+](dec_bat1,dec_bat2).col_name("+"));

print(dec_bat1.col_name("decimal1"),
  dec_bat2.col_name("decimal2"),
  [-](dec_bat1,dec_bat2).col_name("-"));

print(dec_bat1.col_name("decimal1"),
  dec_bat2.col_name("decimal2"),
  [=](dec_bat1,dec_bat2).col_name("="));

print(dec_bat1.col_name("decimal1"),
  dec_bat2.col_name("decimal2"),
  [!=](dec_bat1,dec_bat2).col_name("!="));

print(dec_bat1.col_name("decimal1"),
  dec_bat2.col_name("decimal2"),
  [<](dec_bat1,dec_bat2).col_name("<"));

print(dec_bat1.col_name("decimal1"),
  dec_bat2.col_name("decimal2"),
  [<=](dec_bat1,dec_bat2).col_name("<="));

print(dec_bat1.col_name("decimal1"),
  dec_bat2.col_name("decimal2"),
  [>](dec_bat1,dec_bat2).col_name(">"));

print(dec_bat1.col_name("decimal1"),
  dec_bat2.col_name("decimal2"),
  [>=](dec_bat1,dec_bat2).col_name(">="));

# test unary operators
var dec_abs := [abs](dec_bat);
var dec_neg := [-](dec_bat);

print(dec_bat.col_name("decimal"),
  [isnil](dec_bat).col_name("isnil"),
  dec_abs.col_name("[abs]"),
  dec_neg.col_name("[-]"));

# test sorting
dec_bat.reverse().sort().reverse().col_name("sorted dec").print();
dec_abs.reverse().sort().reverse().col_name("sorted abs(dec)").print();

# test hash-join
dec_abs.join(dec_abs.reverse()).sort_ht().print();

# logical test

# performance test
# compare group, join and sort int vs decimal for 10.000, 100.000 and 1M tuples 

proc int(int i) : int { return i;}

proc pow(int base, int raise) : int {
    return int(pow(dbl(base),dbl(raise)));
}

proc arith_perftest(bat[any::1,any::2] b, any::2 div, str s) : void {
  var t := time(), reduce := [/](b,div); printf("[/](%s) = %dms\n", s, time()-t);
  t := time(); printf("join(%s=%d) = %d ms\n", s, join(b,b.reverse()).count(), time() - t);
  t := time(); printf("group(%s=%d) = %d ms\n", s, CTgroup(reduce).extend().count(), time() - t);
  t := time(); printf("[*](%s=%d) = %d ms\n", s, [*](b,div).count(), time() - t);
  t := time(); printf("[-](%s=%d) = %d ms\n", s, [-](b,b).count(), time() - t);
  t := time(); printf("[+](%s=%d) = %d ms\n", s, [+](b,b).count(), time() - t);
  if (b.count() < 1000000) {
     t := time(); printf("[pow](%s=%d) = %d ms\n", s, [pow](b,[int](reduce)).count(), time() - t);
     t := time(); b.reverse().sort(); printf("sort(%s) = %d ms\n", s, time() - t);
  }
}

var i := 10000;
var int_10K  := new(void,int,10000);
while((i :-= 1) >= 0) {
    int_10K.insert(nil,i);
}
int_10K.seqbase(0@0);

printf("#~BeginVariableOutput~#\n"); arith_perftest(int_10K, 101, "int_10K"); printf("#~EndVariableOutput~#\n");

var dec_10K := [decimal](int_10K);
printf("#~BeginVariableOutput~#\n"); arith_perftest(dec_10K, decimal("101"), "dec_10K"); printf("#~EndVariableOutput~#\n");

int_10K.seqbase(oid(nil));
var int_100K := new(void,int,100000);
while((i :+= 1) < 10) {
    var base := (9 - i) * 10000;
    int_100K.insert([+](int_10K,base));
}
int_100K.seqbase(0@0);

printf("#~BeginVariableOutput~#\n"); arith_perftest(int_100K, 1001, "int_100K"); printf("#~EndVariableOutput~#\n");

var dec_100K := [decimal](int_100K);
printf("#~BeginVariableOutput~#\n"); arith_perftest(dec_100K, decimal("1001"), "dec_100K"); printf("#~EndVariableOutput~#\n");

int_100K.seqbase(oid(nil));
var int_1M := new(void,int,1000000);
while((i :-= 1) >= 0) {
    var base := i * 100000;
    int_1M.insert([+](int_100K,base));
}
int_1M.seqbase(0@0);

printf("#~BeginVariableOutput~#\n"); arith_perftest(int_1M, 10001, "int_1M"); printf("#~EndVariableOutput~#\n");

var dec_1M := [decimal](int_1M);
printf("#~BeginVariableOutput~#\n"); arith_perftest(dec_1M, decimal("10001"), "dec_1M"); printf("#~EndVariableOutput~#\n");

quit();
