var testje := new(int,str);

testje.insert(1,"one");
testje.insert(2,"two");
testje.insert(3,"three");
testje.insert(1,"een");
testje.insert(2,"twee");
testje.insert(3,"drie");

printf("* Example BAT\n");
testje.print();

var deltest := new(int,str);
deltest.insert(1,"one");

printf("\n* deleteBuns: Delete the exact BUN\n");
deltest.print();
testje.deleteBuns(deltest);
testje.print();

deltest := new(int,int);
deltest.insert(2,2);
deltest.insert(3,3);

printf("\n* delete: Delete the BUNs with corresponding head values\n");
deltest.print();
testje.delete(deltest);
testje.print();

#
# test for VM bat remapping 
#
proc mk(bat[void,any] b, str tpe, bit map) : bat[void,any] {
        var nme := map.ifthenelse("mmap","file") + "_" + tpe; 
	CATCH({ bat(nme).persists(false); commit(); }); 
	[*tpe](b).rename(nme).access(BAT_READ).mmap(map.ifthenelse(STORE_MMAP,STORE_MEM)).persists(true).save();
        unload(nme);
        return bat(nme);
}

proc [equal](bat[void,any::1] l, bat[void,any::1] r) : bat[void,bit] {
  var n1 := [isnil](l);
  var n2 := [isnil](r);
  var res := [and](n1,n2).access(BAT_WRITE);
  var chk := [xor](n1,n2).uselect(false).mirror();
  return res.replace([=](chk.join(l),chk.join(r)).select(true)).access(BAT_READ);
}

var map := bat(void,oid).append(1@0).append(0@0).append(2@0).seqbase(0@0);
var sample := bat(void,oid, 200);
var b := bat(void,int,150000);
var o := bat(oid,int,150000);
var l := bat(lng,int,150000);
var i := 0;

var bak := debugmask();
debugmask(0); # do this quick: 150K times BATpropcheck is not nice
while(i < 150000) { 
  b.append(i); i :+= 1; 
  o.insert(oid(i),i+100); 
  l.insert(lng(i),i+100); 
  if ((i and 4095) = 0) 
    sample.append(oid(i));
}
debugmask(bak); # set debug to whatever we want it to be

sample := sample.seqbase(0@0).reverse().mirror();
b.seqbase(0@0);
o.access(BAT_READ);
l.access(BAT_READ);

########################################### 
# test for remap
#
# test both malloced (file) and mmap mem
########################################### 

var file_int := b.mk("int",false);
var file_oid := b.mk("oid",false);
var file_lng := b.mk("lng",false);
var file_str := b.mk("str",false);
var mmap_int := b.mk("int",true);
var mmap_oid := b.mk("oid",true);
var mmap_lng := b.mk("lng",true);
var mmap_str := b.mk("str",true);

var b0 := file_int.remap(map,true);
b0.count().print();
b0.slice(149995,150005).print();


var b1 := file_oid.remap(map,true); 
    [equal](b0,[int](b1)).uselect(false).count().print(); 
    sample.print(b0,b1);

var b2 := file_lng.remap(map,true); 
    [equal](b0,[int](b2)).uselect(false).count().print(); 
    sample.print(b0,b2);

var b3 := file_str.remap(map,true); 
    [equal](b0,[int](b3)).uselect(false).count().print(); 
    sample.print(b0,b3);

var b4 := mmap_int.remap(map,true); 
    [equal](b0,[int](b4)).uselect(false).count().print(); 
    sample.print(b0,b4);

var b5 := mmap_oid.remap(map,true); 
    [equal](b0,[int](b5)).uselect(false).count().print(); 
    sample.print(b0,b5);

var b6 := mmap_lng.remap(map,true); 
    [equal](b0,[int](b6)).uselect(false).count().print(); 
    sample.print(b0,b6);

var b7 := mmap_str.remap(map,true); 
    [equal](b0,[int](b7)).uselect(false).count().print(); 
    sample.print(b0,b7);

# showcase some features of these re-mapped bats
mmap_int.replace(65536@0,42,true); # change the master..
b4.slice(0,10).print(); # now 42 is also visible in the remap

# create a shadow page in the remap
b4.replace(0@0,1,true); 
b4.slice(0,10).print(); 
mmap_int.slice(65536,65538).print(); # master is still 42

# replace in the master
mmap_int.replace(65536@0,0,true); 
b4.slice(0,10).print(); # it is still 1 => shadow paging works 

########################################### 
# test for swizzle
#
# go for all optimized cases
########################################### 

var m_oid_oid := [oid](o.tmark(0@0));
var m_oid_void := o.hmark(100@0).hmark(0@0);
var m_void_oid := m_oid_oid.copy();
var m_void_void := m_oid_void.copy();
var m_lng_oid := [oid](l.tmark(0@0));
var m_lng_void := l.hmark(100@0).hmark(0@0);

var b2, b1 := [swizzle](m_void_oid, map);

b2 := [swizzle](m_void_void, map);
m_void_oid.slice(65430,65450).print(b1,m_void_void,b2);
print(count([!=](b1,b2).uselect(true)));

b2 := [swizzle](m_oid_oid, map);
m_void_oid.slice(65430,65450).print(b1,m_oid_oid,b2);
print(count([!=](b1,b2).uselect(true)));

b2 := [swizzle](m_oid_void, map);
m_void_oid.slice(65430,65450).print(b1,m_oid_void,b2);
print(count([!=](b1,b2).uselect(true)));

b2 := [swizzle](m_lng_oid, map);
m_void_oid.slice(65430,65450).print(b1,m_lng_oid,b2);
print(count([!=](b1,b2).uselect(true)));

b2 := [swizzle](m_lng_void, map);
m_void_oid.slice(65430,65450).print(b1,m_lng_void,b2);
print(count([!=](b1,b2).uselect(true)));

map := map.reverse().[int]().hmark(0@0);

b2 := [swizzle](m_void_oid, map);
m_void_oid.slice(65430,65450).print(b1,m_void_oid,b2);
print(count([!=](b1,b2).uselect(true)));

b2 := [swizzle](m_void_void, map);
m_void_oid.slice(65430,65450).print(b1,m_void_void,b2);
print(count([!=](b1,b2).uselect(true)));

b2 := [swizzle](m_oid_oid, map);
m_void_oid.slice(65430,65450).print(b1,m_oid_oid,b2);
print(count([!=](b1,b2).uselect(true)));

b2 := [swizzle](m_oid_void, map);
m_void_oid.slice(65430,65450).print(b1,m_oid_void,b2);
print(count([!=](b1,b2).uselect(true)));

b2 := [swizzle](m_lng_oid, map);
m_void_oid.slice(65430,65450).print(b1,m_lng_oid,b2);
print(count([!=](b1,b2).uselect(true)));

b2 := [swizzle](m_lng_void, map);
m_void_oid.slice(65430,65450).print(b1,m_lng_void,b2);
print(count([!=](b1,b2).uselect(true)));

map := map.reverse().[lng]().hmark(0@0);

b2 := [swizzle](m_void_void, map);
m_void_oid.slice(65430,65450).print(b1,m_void_void,b2);
print(count([!=](b1,b2).uselect(true)));

b2 := [swizzle](m_oid_oid, map);
m_void_oid.slice(65430,65450).print(b1,m_oid_oid,b2);
print(count([!=](b1,b2).uselect(true)));

b2 := [swizzle](m_oid_void, map);
m_void_oid.slice(65430,65450).print(b1,m_oid_void,b2);
print(count([!=](b1,b2).uselect(true)));

b2 := [swizzle](m_lng_oid, map);
m_void_oid.slice(65430,65450).print(b1,m_lng_oid,b2);
print(count([!=](b1,b2).uselect(true)));

b2 := [swizzle](m_lng_void, map);
m_void_oid.slice(65430,65450).print(b1,m_lng_void,b2);
print(count([!=](b1,b2).uselect(true)));

quit();
