@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2007 CWI.
@' All Rights Reserved.

@f upgrade
@t The upgrade module
@a N.J. Nes
@v 1.1
@* The upgrade module
The upgrade module takes all bats in a given dbfarm directory and converts them 
to the new bat descriptor format. 

@m
.MODULE upgrade;

.COMMAND convert(str dir) : void = bbp_convert; "convert the bats in the given bat directory (ie please supply the full directory, for example $dbfarm/dbname/bat)"

.END upgrade;

@c
#include "monetdb4_config.h"
#include <gdk.h>
#include "upgrade.proto.h"
#include <gdk_bbp.h>

#define DS DIR_SEP
#define TMPname(n) 	(n[0]=='t' && n[1]=='m' && n[2]=='p' && n[3]=='_')
#define OLD_GDKLIBRARY	980714	/* new 64-bits BAT */

typedef struct {
	sht headtype;		/* type id. */
	sht tailtype;		/* type id. */
	int headloc;		/* offset into bun. */
	int tailloc;		/* offset into bun. */
	bit headkey;		/* duplicates allowed? */
	bit tailkey;		/* duplicates allowed? */
	bit headvarsized;	/* varsized(>0) or fixedsized(0). */
	bit tailvarsized;	/* varsized(>0) or fixedsized(0). */
	sht bunshift;		/* log2 of bunwidth */
	unsigned short bunwidth; /* byte-width of BUN array */
	oid hseq;		/* start of dense head sequence */
	oid tseq;		/* start of dense tail sequence */
} DIMold;

typedef struct {
	short_str id;		/* BAT id storage. */
	chr dirtyflushed;	/* saved dirty marker */
	chr copiedtodisk;	/* once written */
	sht persistence;	/* should the BAT persist on disk? */
	int stamp;		/* BAT recent creation stamp */
	sht set;		/* real set semantics */
	sht restricted;		/* access priviliges */
	MT_Id tid;		/* which thread created it */
	bit keeparound;		/* keeparound even if refcnt == 0 */
	chr dummy[3];		/* not used yet */
	chr convert;		/* endian-conversion needed? */
	chr dirty;		/* general dirty marker */
	chr descdirty;		/* bat descriptor dirty marker */
	chr bunsdirty;		/* bun heap dirty marker */
	bat parentid;		/* cache id of VIEW parent bat */
} RECold;

typedef struct {
	int type;		/* type of index entity */
	size_t lim;		/* collision list size */
	hash_t mask;		/* number of hash buckets-1 (power of 2) */
	hash_t *hash;		/* hash table */
	hash_t *link;		/* collision list */
} HashOld;

typedef struct {
	void *root;		/* root of index structure. */
	void *stack;		/* stack with space for nodes */
	void *free;		/* index of first free node. */
	BUN *base;		/* lowest BUN in heap. */
	BUN *first;		/* first BUN in index order. */
	BUN *last;		/* last BUN in index order. */
} IDX, *Index;

typedef struct {
	size_t offset;		/* offset from start of file (bytes). */
	size_t maxsize;		/* maximum realloc size (bytes) */
	size_t free;		/* index where free area starts. */
	size_t size;		/* size of the heap (bytes) */
	BUN base;		/* base pointer in memory. */
	sht storage;		/* storage status. */
	bit copied;		/* a copy of an existing map. */
	chr padding;		/* not used. */
	str filename;		/* file containing image of the heap */
} Hold;

typedef struct {
	/* bunheap data */
	Hold buns;		/* space for the buns. */
	/* delta status administration */
	BUN deleted;		/* start of deleted elements */
	BUN hole;		/* to store next deletion */
	BUN inserted;		/* start of inserted elements */
	int sharecnt;		/* VIEW share count */
	char map_dirty;		/* new mmap mode present */
	char map_buns;		/* mmap mode for bun heap */
	char map_hheap;		/* mmap mode for head atom heap */
	char map_theap;		/* mmap mode for tail atom heap */
	char map_hacc;		/* mmap mode for head accelerator heap */
	char map_tacc;		/* mmap mode for tail accelerator heap */
} BUNold;

typedef struct {
	short_str id;		/* label for head/tail column */
	short_str atom;		/* head atom name */
	Hold heap;		/* space for the head/tail column. */
	HashOld hash;		/* hash index on head/tail column. */
	IDX idx;		/* tree index on head/tail column. */
	Hold accelerator;	/* contains heap accelerator. */
	chr heapdirty;		/* specific heap dirty marker */
	chr accdirty;		/* specific accelerator dirty marker */
	sht acctype;		/* accelerator-type */
	short_str accname;	/* accelerator-name */
	bit sorted;		/* 0=false, 1=true; */
	bit dense;		/* 0=false, 1=true; */
	oid align;		/* OID for sync alignment */
	size_t nosorted_rev;	/* position that proves sorted_rev==FALSE */
	size_t nokey[2];	/* positions that prove key ==FALSE */
	size_t nosorted;	/* position that proves sorted==FALSE */
	size_t nodense;		/* position that proves dense==FALSE */
	int aggr[3];		/* space for keeping size, card and hasnil aggregates */
	int accCopiedtodisk;
} COLold;

typedef struct {
	/* static bat properties */
	int GDKversion;		/* FIRST! */
	str batId;		/* BAT id: points to P->id */
	bat batCacheid;		/* index into BBP */
	DIMold dims;	/* BAT dimensions */
	Hold *batBuns;		/* pointer to U->buns */
	/* static column properties */
	Hold *hhash_heap;	/* hash table: points into H->hash */
	Hold *thash_heap;	/* hash table: points into T->hash */
	Hold *hidx_heap;	/* index tree: points into H->idx */
	Hold *tidx_heap;	/* index tree: points into T->idx */
	/* dynamic column properties */
	COLold *H;		/* column info */
	COLold *T;		/* column info */
	/* dynamic bat properties */
	RECold *P;		/* cache and sort info */
	BUNold *U;		/* cache and sort info */
	/* void hack fields */
	int void_tid;		/* thread that reads this bat */
	int void_cnt;		/* nr of reads */
	oid void_seq1;
	oid void_seq2;
} Bold;

typedef struct {
	Bold B;			/* storage for BAT descriptor */
	COLold H;		/* storage for head column */
	COLold T;		/* storage for tail column */
	RECold P;		/* storage for BATrec */
	BUNold U;		/* storage for BUNrec */
	long_str fullid;	/* new full bat name */
} BATold;

static INLINE str
BBPsubdir_recursive(str s, bat i)
{
	bat j;

	i >>= 6;
	j = i;
	i &= 63;
	*--s = DIR_SEP;
	*--s = '0' + (i & 7);
	*--s = '0' + (i >> 3);
	if (j >= 64) 
		s = BBPsubdir_recursive(s, j);
	return s;
}

static INLINE str
BBPnew_physical(str s, int len, bat i)
{
	bat j = i;
	s[--len] = 0;
	while(i>0) {
		s[--len] = '0' + (i & 7);
		i >>= 3;
	}
	s = s + len;
	if (j >= 64) 
		s = BBPsubdir_recursive(s, j);
	return s;
}

static INLINE str
BBPtmpname(str s, int len, bat i)
{
	s[--len] = 0;
	while(i>0) {
		s[--len] = '0' + (i & 7);
		i >>= 3;
	}
	s = s + len;
	return s;
}


static int
fix_heap( BAT *b )
{
	if (b) {
		Heap buns, hh, th;
		BAT *n = ((b) = BBP_cache(ABS((b)->batCacheid)));
		BAT *m = BATmirror(n);
		BAT *v;
		BATstore *bs = (BATstore *) n;
		var_t cnt = BATcount(b);
		int ht = (n->htype == TYPE_void && n->ttype == TYPE_void) ? TYPE_oid : n->htype;
		str nme = BBP_physical(n->batCacheid);

		/* alloc heaps */
		memset(&buns, 0, sizeof(Heap));
		buns.filename = (str) GDKmalloc(strlen(nme) + 12);
		sprintf(buns.filename, "%s.buns", nme);
		if (HEAPalloc(&buns, cnt + 1, BUNsize(n)) < 0) {
			GDKfree(buns.filename);
			buns.filename = NULL;
			return GDK_FAIL;
		}
		memset(&hh, 0, sizeof(Heap));
		if (n->hheap) {
			hh.filename = (str) GDKmalloc(strlen(nme) + 12);
			sprintf(hh.filename, "%s.hheap", nme);
			if (ATOMheap(ht, &hh, cnt) < 0) {
				HEAPfree(&buns);
				GDKfree(hh.filename);
				return GDK_FAIL;
			}
		}
		memset(&th, 0, sizeof(Heap));
		if (n->theap) {
			th.filename = (str) GDKmalloc(strlen(nme) + 12);
			sprintf(th.filename, "%s.theap", nme);
			if (ATOMheap(n->ttype, &th, cnt) < 0) {
				HEAPfree(&buns);
				HEAPfree(&hh);
				GDKfree(th.filename);
				return GDK_FAIL;
			}
		}
	
		v = VIEWcreate(b);

		/* cut the link to the heaps */
		n->hheap = m->theap = NULL;
		n->theap = m->hheap = NULL;

		n->batParentid = 0;
		n->batRestricted = BAT_WRITE;

		/* copy the heap data into their normal position */
		bs->U = *n->U;
		bs->P = *n->P;
		bs->H = *n->H;
		bs->T = *n->T;

		/* make sure everything points there */
		m->U = n->U = &(bs->U);
		m->P = n->P = &(bs->P);
		m->T = n->H = &(bs->H);
		m->H = n->T = &(bs->T);
		n->batBuns = m->batBuns = &n->U->buns;

		n->GDKversion = m->GDKversion = GDKLIBRARY;

		/* copy the heaps */
		*n->batBuns = buns;

		/* unshare from parents heap */
		if (hh.base) { 
			n->hheap = (Heap*)GDKmalloc(sizeof(Heap));
			*n->hheap = hh;
		}
		if (th.base) { 
			n->theap = (Heap*)GDKmalloc(sizeof(Heap));
			*n->theap = th;
		}

		/* modify dimensions to let disappear projected out columns */
		m->ttype = n->htype = ht;

		BATsetdims(n);
		m->dims.tailtype = n->dims.headtype;
		m->dims.headtype = n->dims.tailtype;
		m->dims.tailloc = n->dims.headloc;
		m->dims.headloc = n->dims.tailloc;
		m->dims.tailvarsized = n->dims.headvarsized;
		m->dims.headvarsized = n->dims.tailvarsized;
		m->dims.bunshift = n->dims.bunshift;
		m->dims.bunwidth = n->dims.bunwidth;
		m->dims.hseq = n->dims.tseq;
		m->dims.tseq = n->dims.hseq;
		n->batSharecnt = 0;
		n->batCopiedtodisk = 0;
		n->batDirty = 1;

		/* make the BAT empty and insert all again */
		DELTAinit(n);

		/* insert all of v in b, and quit */
		BATins(b, v, TRUE);
		BBPreclaim(v);

		/* TODO free old heaps */
	}
	return GDK_SUCCEED;
}

static int 
copy_heap(int storage, char *dst, char *dir, char *src, char *ext) 
{
	size_t res;
	FILE *srcfp, *dstfp;
	char srcpath[PATHLENGTH], dstpath[PATHLENGTH];
	char *buf;
	char *priv = "";

	if (storage == STORE_PRIV || storage == STORE_MMAP)	
		priv = ".priv";

	snprintf(srcpath, PATHLENGTH, "%s%c%s.%s", dir, DS, src, ext );
	if ((srcfp = fopen(srcpath, "rb")) == NULL) {
		snprintf(srcpath, PATHLENGTH, "%s%c%s.%s.priv", dir, DS, src, ext );
		if ((srcfp = fopen(srcpath, "rb")) == NULL) {
			GDKerror("couldn't open %s\n", srcpath);
			return -1;
		}
	}
	snprintf(dstpath, PATHLENGTH, "bat%c%s.%s%s", DS, dst, ext, priv);
	if ((dstfp = fopen(dstpath, "wb")) == NULL) {
		GDKerror("couldn't open %s\n", dstpath);
		return -1;
	}
	buf = GDKmalloc(64*BUFSIZ);
	while( (res = fread(buf, 1, 64*BUFSIZ, srcfp)) > 0) {
		if (fwrite(buf, 1, res, dstfp) < res) {
			GDKerror("error writing %s\n", dstpath);
			return -1;
		}
		if (res < (64*BUFSIZ))
			break;
	}
	fclose(dstfp);
	fclose(srcfp);
	return 0;
}
 
static int
bat_convert(bat i, char *dir, char *physical, char **name ) 
{
	char path[PATHLENGTH], np[BUFSIZ], *new_physical = np;
	BATold src;
	BATstore *dst = (BATstore*)GDKzalloc(sizeof(BATstore));
	BAT *b = NULL;
	FILE *fp;

	printf("converting bat %d(%s,%s)\n", i, name[0]?name[0]:"", name[1]?name[1]:"");

	snprintf(path, PATHLENGTH, "%s%c%s.desc", dir, DS, physical);
	fp = fopen(path, "rb");
	if (!fp) {
		snprintf(path, PATHLENGTH, "%s%cBACKUP%c%s.desc", 
			dir, DS, DS, physical);
		fp = fopen(path, "rb");
	}
	if (!fp){
		GDKerror("couldn't open descriptor %s\n", physical);
		return GDK_FAIL;
	}
	if (fread(&src, 1, sizeof(BATold), fp) < sizeof(BATold)) {
		GDKerror("couldn't read bat descriptor for %s\n", physical);
		return GDK_FAIL;
	}
	fclose(fp);
	if (src.B.GDKversion != OLD_GDKLIBRARY) {
		GDKerror("cannot convert from version %d\n", OLD_GDKLIBRARY);
		return GDK_FAIL;
	}
	/* here we start converting the descriptor */
	dst->B.GDKversion = GDKLIBRARY;
	b = (BAT *) dst;
	b->batCacheid = src.B.batCacheid;
	b->H = &dst->H;
	b->T = &dst->T;
	b->P = &dst->P;
	b->U = &dst->U;
	b->hident = b->tident = NULL;
	BATroles(b, NULL, NULL);
	b->batBuns = &b->U->buns;
	b->batBuns->base = NULL;
	b->batBuns->filename = NULL;
	b->hhash = b->thash = NULL;
	b->hheap = b->theap = NULL;
	b->void_tid = b->void_cnt = 0;
	b->void_seq1 = b->void_seq2 = 0;
	
	dst->B.dims.headtype = (chr) src.B.dims.headtype;
	dst->B.dims.tailtype = (chr) src.B.dims.tailtype;
	/* lookup atoms to get the proper atom_id */ 
	if (!ATOMname(b->htype) || strcmp(ATOMname(b->htype), src.H.atom) != 0){
		int ht = ATOMindex(src.H.atom);

		if (ht < 0 || BATatoms[ht].deleting) {
			ht = ATOMunknown_find(src.H.atom);
		}
		b->htype = ht;
	}
	if (!ATOMname(b->ttype) || strcmp(ATOMname(b->ttype), src.T.atom) != 0){
		int tt = ATOMindex(src.T.atom);

		if (tt < 0 || BATatoms[tt].deleting) {
			tt = ATOMunknown_find(src.T.atom);
		}
		b->ttype = tt;
	}
	dst->B.dims.headloc = src.B.dims.headloc;
	dst->B.dims.tailloc = src.B.dims.tailloc;
	dst->B.dims.headkey = src.B.dims.headkey;
	dst->B.dims.tailkey = src.B.dims.tailkey;
	dst->B.dims.headvarsized = src.B.dims.headvarsized;
	dst->B.dims.tailvarsized = src.B.dims.tailvarsized;
	dst->B.dims.bunshift = (chr) src.B.dims.bunshift;
	dst->B.dims.bunwidth = src.B.dims.bunwidth;
	dst->B.dims.hseq = src.B.dims.hseq;
	dst->B.dims.tseq = src.B.dims.tseq;

	dst->P.tid = 0;
	dst->P.stamp = 0;
	dst->P.persistence = BBPEXISTING;
	dst->P.dirtyflushed = 0;
	dst->P.copiedtodisk = 1;
	dst->P.set = (chr) src.P.set;
	dst->P.restricted = (chr) src.P.restricted;
	dst->P.dirty = 0;
	dst->P.descdirty = 1;
	dst->P.bunsdirty = 0;
	dst->P.sharecnt = src.U.sharecnt;
	dst->P.parentid = src.P.parentid;
	dst->P.map_dirty = dst->P.map_buns = dst->P.map_hheap = dst->P.map_theap =0;

	dst->U.buns.maxsize = src.U.buns.maxsize;
	dst->U.buns.free = src.U.buns.free;
	dst->U.buns.size = src.U.buns.size;
	dst->U.buns.base = NULL;
	dst->U.buns.storage = (char) src.U.buns.storage;
	dst->U.buns.copied = FALSE;
	dst->U.buns.newstorage = 0;
	dst->U.buns.filename = NULL;

	dst->U.deleted = src.U.deleted;
	/* compensate for the removed hole */
	dst->U.first = 	src.U.hole + 1;
	dst->U.inserted = src.U.inserted;
	/* src.U.hole just comes from disk, ie is offset from 0 */
	dst->U.count = (BUN)(((size_t)src.U.buns.free)/src.B.dims.bunwidth) - src.U.hole-1;
	DELTAload(b);

	dst->H.vheap = NULL;
	if (b->htype != TYPE_void && dst->B.dims.headvarsized) {
		dst->H.vheap = GDKzalloc(sizeof(Heap));

		dst->H.vheap->maxsize = src.H.heap.maxsize;
		dst->H.vheap->free = src.H.heap.free;
		dst->H.vheap->size = src.H.heap.size;
		dst->H.vheap->base = NULL;
		dst->H.vheap->storage = (char) src.H.heap.storage;
		dst->H.vheap->copied = FALSE;
		dst->H.vheap->newstorage = 0;
		dst->H.vheap->filename = NULL;
	}
	dst->H.heapdirty = 0;
	dst->H.sorted = src.H.sorted;
	dst->H.dense = src.H.dense;
	dst->H.align = src.H.align;
	dst->H.nosorted_rev = src.H.nosorted_rev;
	dst->H.nosorted = src.H.nosorted;
	dst->H.nokey[0] = src.H.nokey[0];
	dst->H.nokey[1] = src.H.nokey[1];
	dst->H.nodense = src.H.nodense;

	dst->T.vheap = NULL;
	if (b->ttype != TYPE_void && dst->B.dims.tailvarsized) {
		dst->T.vheap = GDKzalloc(sizeof(Heap));

		dst->T.vheap->maxsize = src.T.heap.maxsize;
		dst->T.vheap->free = src.T.heap.free;
		dst->T.vheap->size = src.T.heap.size;
		dst->T.vheap->base = NULL;
		dst->T.vheap->storage = (char) src.T.heap.storage;
		dst->T.vheap->copied = FALSE;
		dst->T.vheap->newstorage = 0;
		dst->T.vheap->filename = NULL;
	}
	dst->T.heapdirty = 0;
	dst->T.sorted = src.T.sorted;
	dst->T.dense = src.T.dense;
	dst->T.align = src.T.align;
	dst->T.nosorted_rev = src.T.nosorted_rev;
	dst->T.nosorted = src.T.nosorted;
	dst->T.nokey[0] = src.T.nokey[0];
	dst->T.nokey[1] = src.T.nokey[1];
	dst->T.nodense = src.T.nodense;

	new_physical[BUFSIZ - 1] = 0;
	new_physical -= (BUFSIZ-1);
	if (i>=64)
		new_physical = BBPsubdir_recursive(new_physical, i);
	*--new_physical = DIR_SEP;
	*--new_physical = 't';
	*--new_physical = 'a';
	*--new_physical = 'b';
	
	(void)GDKcreatedir(new_physical); 

	new_physical = np;
	new_physical = BBPnew_physical(new_physical, BUFSIZ, i); 
	if (copy_heap(b->batBuns->storage, new_physical, dir, physical, "buns") < 0) {
		return GDK_FAIL;
	}
	if (b->htype != TYPE_void && dst->B.dims.headvarsized && 
		copy_heap(b->H->vheap->storage, new_physical, dir, physical, "hheap") < 0) {
		return GDK_FAIL;
	}
	if (b->ttype != TYPE_void && dst->B.dims.tailvarsized && 
		copy_heap(b->T->vheap->storage, new_physical, dir, physical, "theap") < 0) {
		return GDK_FAIL;
	}
	/* should have enough space allready */ 
	if (i >= BBPsize) 
		return GDK_FAIL;
	BBP_desc(i) = dst;
	BBP_physical(i) = GDKstrdup(new_physical);
	if (!name[0]) {
		char nme[64];
		BBP_logical(i) = GDKstrdup(BBPtmpname(nme, 64, i));
	} else {
		BBP_logical(i) = GDKstrdup(name[0]);
	}
	if (name[1]) 
		BBP_logical(-i) = GDKstrdup(name[1]);
	BBPincref(i, TRUE);
	BBP_status_on(i, BBPNEW|BBPSWAPPED, "bat_convert");
	if (BBP_free(i & BBP_THREADMASK) <= i)
		BBP_free(i & BBP_THREADMASK) = i+1;
	if (b->htype == TYPE_str || b->ttype == TYPE_str) {
		DELTAsave(b);
		return fix_heap(BATdescriptor(b->batCacheid));
	}
	return GDK_SUCCEED;
}

static INLINE char *
BBPparse(str *cur)
{
	char *base, *c = *cur;

	for (c++; GDKisspace(*c); c++)
		;
	for (base = c; !(GDKisspace(*c) || *c == ','); c++)
		;
	*c = 0;
	*cur = c;
	return base;
}

int
bbp_convert( str batdir ) 
{
	char path[PATHLENGTH];
	char bak[PATHLENGTH];
	FILE *fp = NULL;
	bat i;
	char *c, buffer[3000];

	snprintf(bak, PATHLENGTH, "%s%cBACKUP%c", batdir, DS, DS); 
	BBPlock("bbp_convert");
	if (BBPsize > 28) { /* 28 bats allready exist by default */
		GDKerror("Can only convert to an empty dbfarm\n");
		return GDK_FAIL;
	}
	GDKfilepath(path, bak, "BBP", "dir");

	fp = fopen(path, "r");
	if (!fp) {
		GDKerror("Could not open the BBP.dir in the BACKUP directory(%s)\n", bak);
		return GDK_FAIL;
	}
	BBPdirty(1);
	if ((c = fgets(buffer, sizeof(buffer), fp)) != NULL) {
		int ptrsize, oidsize;
		if (sscanf(c, "%d %d", &ptrsize, &oidsize) != 2) {
			GDKerror("old BBP without size indications: please first save your BBP with a 4.6 or later Mserver");
			return GDK_FAIL;
			
		} else {
			c = fgets(buffer, sizeof(buffer), fp);
		}
		if (ptrsize != SIZEOF_SIZE_T || oidsize != SIZEOF_OID) {
			GDKerror("BBP incompatible with current Mserver");
			return GDK_FAIL;
		}
		if (c != NULL) {
			if ((c = strstr(c, "BBPsize")) != NULL) {
				sscanf(c, "BBPsize=%d", &i);
				if (i >= BBPsize) {
					BBPsize = i + 1;
					if (BBPsize >= BBPlimit)
						BBPextend(BATMARGIN, FALSE);
				}
			}
		}
	}
	/* scan the BBP.dir, and insert the BATs into the BBP */
	while ((c = fgets(buffer, sizeof(buffer), fp)) != NULL) {
		char *batname, *physical, *name[2];
		int res = GDK_SUCCEED;

		while (*c != '[')
			c++;
		for (c++; GDKisspace(*c); c++)
			;
		i = atoi(c);
		if (GDKisdigit(*c) && i > 0) {
			for (c++; *c != ','; c++)
				;
			for (c++; GDKisspace(*c); c++)
				;
			if (!GDKisdigit(*c))
				c--;
			else
				for (c++; *c != ','; c++)
					;
		} else {
			GDKerror("BBPinit: ignore line %s\n", buffer);

			continue;
		}

		batname = GDKstrdup(BBPparse(&c));
		physical = GDKstrdup(BBPparse(&c));

		c = strchr(batname, '~');
		name[0] = NULL;
		if (!c || c != batname) {
			if (c)
				*c = 0;
			if (!TMPname(batname))
				name[0] = GDKstrdup(batname);
		}
		if (c && c[1]) {
			name[1] = GDKstrdup(c + 1);
		} else {
			name[1] = NULL;
		}
		GDKfree(batname);
		res = bat_convert(i, batdir, physical, name);
		GDKfree(physical);
		if (name[0]) GDKfree(name[0]);
		if (name[1]) GDKfree(name[1]);
		if (res == GDK_FAIL) {
			fclose(fp);
			BBPunlock("bbp_convert");
			return GDK_FAIL;
		}
	}
	fclose(fp);
	BBPunlock("bbp_convert");
	return GDK_SUCCEED;
}
