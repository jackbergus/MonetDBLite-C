@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2007 CWI.
@' All Rights Reserved.

@f malalgebra
@a Arjen P. de Vries, S. Manegold
@v 1.0
@t Work around internal select and join algorithm selection
@* Introduction
@T
Too many bugs.

@m
.MODULE malalgebra;

@= join
  .COMMAND @1join ( BAT[any::1,any::2] left, BAT[any::2,any::3] right) :
                    BAT[any::1,any::3] = CMD@1join;
  "Hook directly into the '@1join' implementation of the join."
@= leftjoin
  .COMMAND left@1join ( BAT[any::1,any::2] left, BAT[any::2,any::3] right) :
                    BAT[any::1,any::3] = CMDleft@1join;
  "Hook directly into the 'left@1join' implementation of the join.
   prefix 'left' means that left and right input are not swapped during processing,
   and hence, the order of the left input's head is maintained in the result. @2"
@m
@:join(fetch,\nCAUTION: positional matches are assumed not to be out-of-bounds!!)@
@:join(merge)@
@:join(hash)@
@:leftjoin()@
@:leftjoin(fetch,\nCAUTION: positional matches are assumed not to be out-of-bounds!!)@
@:leftjoin(merge)@
@:leftjoin(hash)@

  .COMMAND leftthetajoin ( BAT[any::1,any::2] left, BAT[any::2,any::3] right, int mode) :
                    BAT[any::1,any::3] = CMDleftthetajoin;
  "Hook directly into the 'leftthetajoin' implementation of the join.
   prefix 'left' means that left and right input are not swapped during processing,
   and hence, the order of the left input's head is maintained in the result."

  .COMMAND nlthetajoin ( BAT[any::1,any::2] left, BAT[any::2,any::3] right, int mode, lng estimate) :
                    BAT[any::1,any::3] = CMDnlthetajoin;
  "Hook directly into the 'nested-loop-thetajoin' implementation of the join.
   prefix 'left' means that left and right input are not swapped during processing,
   and hence, the order of the left input's head is maintained in the result.
   Also, for each left tuple, all matching right tuples will appear in their order
   of appearrance in the right BAT. This property is handy for XQuery processing."


@= select
.COMMAND ord_@1select ( BAT[any::1,any::2] b, any::2 low, any::2 high) : 
				BAT[any::1, @2] = CMDord_@1select; 
"Like standard '@1select(b, low, high);', but preserves the order of the input BAT;
 (for the time being) this means, only the scan-based select algorithm is used."

.COMMAND ord_@1select ( BAT[any::1,any::2] b, any::2 low, any::2 high, bit l_in, bit h_in) : 
				BAT[any::1, @2] = CMDord_@1select_; 
"Like standard '@1select(b, low, high, l_in, h_in);', but preserves the order of the input BAT;
 (for the time being) this means, only the scan-based select algorithm is used."

.COMMAND ord_@1select ( BAT[any::1,any::2] b, any::2 value) :
                                BAT[any::1, @2] = CMDord_@1select1; 
"Like standard '@1select(b, value);', but preserves the order of the input BAT;
 (for the time being) this means, only the scan-based select algorithm is used."
@m
@:select(,any::2)@
@:select(u,void)@


@= sum
.COMMAND {_csum}(BAT[oid,@1] b) : BAT[oid,@1] = CMDclustered_sum_@1; 
	"grouped tail sum"
@m
@:sum(bte)@
@:sum(sht)@
@:sum(int)@
@:sum(wrd)@
@:sum(lng)@
@:sum(flt)@
@:sum(dbl)@

@= milsum
  PROC {csum}( BAT[oid,@1] b): BAT[oid,@1] {
    IF ( b.ordered() )
      RETURN {_csum}( b );
    ELSE
      RETURN {sum}( b );
  }
  ADDHELP("{csum}", "arjen", "Jul 18 2000",
          "Choose a different implementation if b is sorted on head.", 
          mod());
@mil
@:milsum(bte)@
@:milsum(sht)@
@:milsum(int)@
@:milsum(wrd)@
@:milsum(lng)@
@:milsum(flt)@
@:milsum(dbl)@

@m
.END malalgebra;

@{
@* Implementation Code
@h
#ifndef __MALALGEBRA_H__
#define __MALALGEBRA_H__
#include "gdk.h"

/* nothing much */

#endif /* __MALALGEBRA_H__ */

@c
#include "monetdb4_config.h"
#include "malalgebra.h"
#include "malalgebra.proto.h"

/* don't reorder! */
static BAT *
BATmalleftjoin(BAT *l, BAT *r)
{
	return BATleftjoin(l, r, oid_nil);
}

static BAT *
BATmalfetchjoin(BAT *l, BAT *r)
{
	int rfetch = (BAThdense(r) && ATOMstorage(l->ttype) <= ATOMstorage(TYPE_oid));
	int lfetch = (BATtdense(l) && ATOMstorage(r->htype) <= ATOMstorage(TYPE_oid));

	if (lfetch && !(rfetch && BATcount(l) < BATcount(r))) {
		return BATmirror(BATfetchjoin(BATmirror(r), BATmirror(l), oid_nil));
	} else if (rfetch) {
		return BATfetchjoin(l, r, oid_nil);
	}
	GDKerror("BATmalfetchjoin: Cannot perform fetchjoin: neither left tail nor right head are dense OID columns.\n");
	return NULL;
}

/* don't reorder! */
static BAT *
BATmalleftfetchjoin(BAT *l, BAT *r)
{
	int rfetch = (BAThdense(r) && ATOMstorage(l->ttype) <= ATOMstorage(TYPE_oid));

	if (rfetch) {
		return BATleftfetchjoin(l, r, oid_nil);
	}
	GDKerror("BATmalleftfetchjoin: Cannot perform leftfetchjoin: right head is no dense OID column.\n");
	return NULL;
}

static BAT *
BATmalhashjoin(BAT *l, BAT *r)
{
	size_t lsize = l->batBuns->size + (l->hheap ? l->hheap->size : 0) + (l->theap ? l->theap->size : 0);
	size_t rsize = r->batBuns->size + (r->hheap ? r->hheap->size : 0) + (r->theap ? r->theap->size : 0);

	if (rsize < lsize) {
		return BATmirror(BAThashjoin(BATmirror(r), BATmirror(l), oid_nil));
	}
	return BAThashjoin(l, r, oid_nil);
}

/* don't reorder! */
static BAT *
BATmallefthashjoin(BAT *l, BAT *r)
{
	return BAThashjoin(l, r, oid_nil);
}

static BAT *
BATmalmergejoin(BAT *l, BAT *r)
{
	if (!((BATtordered(l) & 1) || (BAThordered(r) & 1))) {
		GDKerror("BATmalmergejoin: Cannot perform mergejoin: neither left tail nor right head is ordered.\n");
		return NULL;
	}
/*
 * Stefan: There is no reason not to perform a mergejoin on voids, is there?
 *
  if ( (l->ttype==TYPE_void) || (r->htype==TYPE_void) ) {
    GDKerror( "BATmalmergejoin: Cannot perform mergejoin on void fields.\n" );
    return NULL;    
  }
*/
	return BATmergejoin(l, r, oid_nil);
}

/* don't reorder! */
static BAT *
BATmalleftmergejoin(BAT *l, BAT *r)
{
	if (!(BAThordered(r) & 1)) {
		GDKerror("BATmalleftmergejoin: Cannot perform leftmergejoin: right head is ordered.\n");
		return NULL;
	}
	return BATleftmergejoin(l, r, oid_nil);
}

@= joincmd
int CMD@1join(BAT **result, BAT *left, BAT* right) {
  ERRORcheck(left == NULL, "@1-join: invalid left operand"); 
  ERRORcheck(right == NULL, "@1-join: invalid right operand"); 
  ERRORcheck(TYPEerror(left->ttype, right->htype), "@1-join: type conflict\n"); 
  return (*result = (BAT*) BATmal@1join(left, right))?GDK_SUCCEED:GDK_FAIL;
}
@c
@:joincmd(left)@
@:joincmd(fetch)@
@:joincmd(leftfetch)@
@:joincmd(merge)@
@:joincmd(leftmerge)@
@:joincmd(hash)@
@:joincmd(lefthash)@

int
CMDleftthetajoin(BAT **result, BAT *l, BAT *r, int *mode)
{
	return (*result = BATleftthetajoin(l, r, *mode, MIN(BATcount(l), BATcount(r)))) ? GDK_SUCCEED : GDK_FAIL;
}

int
CMDnlthetajoin(BAT **result, BAT *l, BAT *r, int *mode, lng *estimate)
{
	return (*result = BATnlthetajoin(l, r, *mode, (size_t) * estimate)) ? GDK_SUCCEED : GDK_FAIL;
}

@= selectcmd
int CMDord_@1select1(BAT **result, BAT* b, ptr value) {
	return (*result = BAT_select_(b, value, 0, TRUE, TRUE, @2, TRUE))?GDK_SUCCEED:GDK_FAIL;
}
int CMDord_@1select(BAT **result, BAT *b, ptr low, ptr high) {
	return (*result = BAT_select_(b, low, high, TRUE, TRUE, @2, TRUE))?GDK_SUCCEED:GDK_FAIL;
}
int CMDord_@1select_(BAT **result, BAT *b, ptr low, ptr high, bit* l_in, bit* h_in) {
	int tt = b->ttype;
	ptr nil = ATOMnilptr(tt);
	if (*l_in == bit_nil && ATOMcmp(tt, low, nil)) {
		GDKerror("CMDord_@1select: flag 'l_in' must not be NIL, unless boundary 'low' is NIL\n");
		return GDK_FAIL;
	}
	if (*h_in == bit_nil && ATOMcmp(tt, high, nil)) {
		GDKerror("CMDord_@1select: flag 'h_in' must not be NIL, unless boundary 'high' is NIL\n");
		return GDK_FAIL;
	}
	return (*result = BAT_select_(b, low, high, *l_in, *h_in, @2, TRUE))?GDK_SUCCEED:GDK_FAIL;
}
@c
@:selectcmd(,TRUE)@
@:selectcmd(u,FALSE)@


@= sumcmd
int CMDclustered_sum_@1(BAT **ret, BAT *b ) {
	BAT *bn = BATnew(b->htype, BATttype(b), BATcount(b));	
	BUN p, q;
	int xx;
	oid cur;
	@1 sum = 0;

	bn->hsorted = b->hsorted;
	bn->tsorted = 0;
	if (BATcount(b))
 		cur = *(oid*)BUNhead(b,BUNfirst(b));
	BATloopFast(b, p, q, xx) {
		oid *h = (oid*) BUNhead(b,p);
		@1 *t = (@1*) BUNtail(b,p);

		if (cur != *h){
			BUNfastins(bn, &cur, &sum );
			cur = *h;
			sum = 0;
		}
		sum += *t;
	}
	if (BATcount(b))
		BUNfastins(bn, &cur, &sum );

	*ret = bn;
	return GDK_SUCCEED;
}
@c
@:sumcmd(bte)@
@:sumcmd(sht)@
@:sumcmd(int)@
@:sumcmd(wrd)@
@:sumcmd(lng)@
@:sumcmd(flt)@
@:sumcmd(dbl)@

@}

@= jointest_void
VAR @1result_void := @1join( l, r );
@
@= jointest_oid
VAR @1result_oid := @1join( [oid](l), [oid](r.reverse()).reverse() );
@
@= compresults
@:jointest_@2(@1)
IF( not( isnil(@1result_@2) ) ) {
  Ndiff := diff( result_@2, @1result_@2 ).count();
  printf( "Algorithm @1 leads to %d different answers.\n", Ndiff );
  IF (Ndiff>0) {
	Ntestfailed :+= 1;
	print(result_@2);
	print(@1result_@2);
	print(diff(result_@2,@1result_@2));
	print(diff(@1result_@2,result_@2));
  }
}
@
@mil

PROC test_malalgebra() : void {   
	#
	# Simple test of some algorithms against the baseline
	#
	VAR Ndiff, l, r;

	var dj := new( void, oid ); var tf := new( void, int );
	dj.insert( nil, 0@0 );  tf.insert( nil, 10 );
	dj.insert( nil, 0@0 );  tf.insert( nil, 20 );
	dj.insert( nil, 0@0 );  tf.insert( nil, 30 );
	dj.insert( nil, 1@0 );  tf.insert( nil, 30 );
	dj.insert( nil, 1@0 );  tf.insert( nil, 20 );
	dj.insert( nil, 1@0 );  tf.insert( nil, 10 );
	dj.insert( nil, 2@0 );  tf.insert( nil, 20 );
	dj.insert( nil, 2@0 );  tf.insert( nil, 30 );
	dj.insert( nil, 2@0 );  tf.insert( nil, 10 );
	dj.seqbase(0@0);        tf.seqbase(0@0);

	l := dj.reverse();
	r := tf;

	var Ntestfailed := 0;

	@:jointest_oid()@
	@:compresults(hash,oid)@
	@:compresults(fetch,oid)@
	@:compresults(merge,oid)@
	@:compresults(left,oid)@
	@:compresults(lefthash,oid)@
	@:compresults(leftfetch,oid)@
	@:compresults(leftmerge,oid)@

	@:jointest_void()@
	@:compresults(hash,void)@
	@:compresults(fetch,void)@
	@:compresults(merge,void)@
	@:compresults(left,void)@
	@:compresults(lefthash,void)@
	@:compresults(leftfetch,void)@
	@:compresults(leftmerge,void)@

	printf( "RESULT: %d tests failed.\n", Ntestfailed );
}
