@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2006 CWI.
@' All Rights Reserved.

@f iterator
@a Peter Boncz
@t Iterator-Based BAT Engine
@* Introduction
@T
In the Monet system it was decided that operators use full materialization.
This is a simple approach that allows for efficient implementation of the 
individual operators. In MIL, one operator is executed without interruption 
on an entire BAT, producing one result. The inner loop of a C implementation of
such MIL operators therefore typically does not perform any function calls at all.
This was deemed an important implementation feature for a main-memory
database system, as function calls are expensive; especially non-inlineable
function calls (like (*fcn)(); or C++ methods with late binding).

This module sets out to investigate how expensive these function calls really
are. We try to offset this advantage of full materialization with its drawbacks,
primarily too much memory consumption.  This experimental implementation provides
a core of relational operators on the BAT model like MIL, but now implemented using 
the concept of iterators (a la Goetz Graefe). In such an engine, a query processing 
operator tree is represented by a tree of iterator objects. These objects have a next()
method for getting the next tuple. During query processing,tuples flow through the 
tree by operator nodes making recursive calls to each others next() functions. 

The code is optimized for data handling; like in MIL; using type-specific functions 
where appropriate. This makes it fair to compare performance with the already 
existing (and optimized) MIL operators that employ full materialization.

There is one parameter to the iterators: the chunksize in which tuples flow
through the tree. If the chunksize is the BAT-size these operators are like 
MIL with a little more overhead. If the chunksize is 1 (default); it degenerates 
to pure 1-tuple-at-a-time processing.

@* MIL interface
@m
.MODULE iterator;

.ATOM iter = ptr;
	.FIX   = iter_fix;
	.UNFIX = iter_unfix;
.END;

.COMMAND scan(bat[any,any]) : iter
        = iter_scan; "sequential-scan on bat"
.COMMAND reverse(iter input) : iter
        = iter_reverse; "reverse the buns in the input iterator"
.COMMAND mirror(iter input) : iter
        = iter_mirror; "mirror buns (both head) in the input iterator"
.COMMAND mark(iter input, oid o) : iter
        = iter_mark; "mark tail buns of the input iterator"
.COMMAND select(iter input, bit tail, str fcn, any val) : iter
        = iter_select1; "select on tail (fcn in {eq,=,!=,<,>,<=,>=,..})"
.COMMAND select(iter input, bit tail, str fcn, any v1, any v2) : iter
        = iter_select2; "select on tail (fcn in {rng,..})"
.COMMAND join(iter outer, bat[any,any] inner) : iter
        = iter_join; "hash-join iterator"
.COMMAND histo(iter input) : bat[any,int] 
        = iter_histo; "groupby-count on tail"
.COMMAND aggr(iter input, str fcn, bat[oid,any::1] attr) : bat[any,any::1]
        = iter_aggr; "groupby-aggregate(attr), aggr in {max,min,sum,avg}"

.COMMAND next(iter) : bit
	= iter_next; "false: no more chunks / true: iter contains next chunk"
.COMMAND chunk(iter) : bat[any,any]
	= iter_chunk; "get the next chunk"
.COMMAND count(iter) : int
        = iter_count; "recursively execute an iterator; just count the elements"
.COMMAND collect(iter) : bat[any,any]
        = iter_collect; "recursively execute an iterator; collect results in a bat"

.COMMAND chunksize() : int = iter_setchunksize; "return the iterator chunksize (default=1)"
.COMMAND chunksize(int) = iter_getchunksize; "set the iterator chunksize"

.END iterator;

@* MIL Test Script
@mil

PROC test_iterator() : void {

	# module(ddbench)
	#
	# var age_t := enum_load(age);
	# var town_t := enum_load(town);
	# var reliable_t := enum_load(reliable);
	# var a18 := age_t.encode(18)
	# var town_reliable_CT := group(reliable_enum).group(town_enum);
	# 
	# # ddbench-like subhisto: count * where age=18 groupby town,reliable 
	# var ct := age_enum.scan().select(false,"=",a18).mirror().join(town_reliable_CT).histo();

	var x := new(int,int,1000);
	var i := 0;
	while(i < 1000) { x.insert(i,i); i :+= 1; }

	# dense test 
	a := [oid](x).reverse();
	b := [-](a);
	c := [%](a,10);

	var it := a.scan();
	while(it.next()) it.chunk().print();
	 
	a.scan().collect().print();
	a.scan().select(true, "=",10).collect().print();
	c.scan().histo().print();
	c.scan().aggr("min",b).print();
	c.scan().aggr("avg",b).print();

	# non-dense test
	x.delete(500);
	a := [oid](x).reverse();
	b := [-](a);
	c := [%](a,10);
	 
	a.scan().collect().print();
	a.scan().select(true,"=",10).collect().print();
	c.scan().histo().print();
	c.scan().aggr("min",b).print();
}


@* Iterator Implementation
@h
#include "monet.h"
typedef ptr iter;

@c
#include "monetdb4_config.h"
#include "iterator.h"
#include "iterator.proto.h"

size_t chunksize = 1;

@- BUN insert
@T
Moving tuples is optimized to moving only the fixed-size part. The operators presented
here do not introduce new values; they only pass already existing values. For
the result tuple buffers we use BATs, but let their heaps for variable-size atoms
point to the original BATs at the bottom of the tree. 
@c
#define valuecopy(dst, src, sz)\
    if (sz == 4) {\
        *(int*) (dst) = *(int*) (src);\
    } else if (sz == 1) {\
        *(bte*) (dst) = *(bte*) (src);\
    } else if (sz == 8) {\
        *(lng*) (dst) = *(lng*) (src);\
    } else if (sz == 2) {\
        *(sht*) (dst) = *(sht*) (src);\
    } else if (sz > 0) {\
        memcpy(dst, src, sz);\
    }
#define buncopy(it, p, h, t) {\
    valuecopy(p+it->result_hloc, h, it->result_hsize)\
    valuecopy(p+it->result_tloc, t, it->result_tsize)\
    p += BUNsize(it->result);\
}


@- Data Structure
@T
A stream is an object that has a next() method that returns more tuples. We also gave 
it a guess() for estimating how many tuples more will come, and a free() for deallocation.
This would have been nicely implemented as a hierarchy of streams in C++, but I hate
that language.

The data part of a stream consists of a BAT that contains the current result tuples,
and an operator-specific handle.
@c
typedef struct _ITER ITER;
typedef BAT *(*BATfcn) (ITER *, BAT *);
typedef size_t(*NEXTfcn) (ITER *);
typedef void (*FREEfcn) (ITER *);
typedef size_t(*GUESSfcn) (ITER *);

typedef union {
	ScanHandle scan;
	JoinHandle join;
	SelectHandle sel;
} OperatorHandle;

struct _ITER {
	str name;
	size_t tuples_seen;
	/* result tuple buffer (BAT slice of max chunksize) */
	BAT *result, *mirror;
	BUN result_cur;
	sht result_hloc, result_tloc;
	sht result_hsize, result_tsize;
	/* iterator methods */
	NEXTfcn next;		/* stream->next() : number of items read */
	FREEfcn free;		/* stream->free() : deallocate handle */
	GUESSfcn guess;		/* stream->guess() : guess of total stream size */
	ptr input;		/* ITER* child */
	/* stream-specific handle */
	OperatorHandle hdl;
};

@- Iterator Loop Macro
Compareable with BATloopFast
@c
#define ITERloop(it, p, q, xx)\
    for(p=it->result_cur,q=BUNlast(it->result), xx=BUNsize(it->result); (p<q) ||\
	    (ITERnext(it) && (p=it->result_cur) && (q=BUNlast(it->result))); p+=xx)
#define ITERbreak(it, p, cnt)\
    if (cnt == chunksize) { (it)->result_cur = p; return chunksize; }

@- Iterator Interface
@c
static
ITER *
ITERinit(ITER *input, str name, NEXTfcn next, FREEfcn free, GUESSfcn guess, BAT *b, BAT *h, BAT *t)
{
	ITER *it = (ITER *) GDKmalloc(sizeof(ITER));
	BAT *v = VIEWcreate_(b, TRUE);
	oid hseq = BAThdense(v) ? v->hseqbase - chunksize : oid_nil;
	oid tseq = BATtdense(v) ? v->tseqbase - chunksize : oid_nil;

	it->name = name;
	it->next = next;
	it->free = free;
	it->guess = guess;
	if (h) {
		BAT *m = BATmirror(v);

		if (t == NULL) {
			t = BATmirror(h);
		}
		v->H = m->T = b->H;
		v->T = m->H = b->T;
	}
	it->result = v;
	it->result_hloc = v->hloc;
	it->result_tloc = v->tloc;
	it->result_hsize = ATOMsize(v->htype);
	it->result_tsize = ATOMsize(v->ttype);
	it->result_cur = BUNfirst(b);
	it->tuples_seen = 0;
	it->input = (ptr) input;
	it->mirror = BATmirror(it->result);
	it->result->hseqbase = it->mirror->tseqbase = hseq;
	it->result->tseqbase = it->mirror->hseqbase = tseq;
	return it;
}

static INLINE size_t
ITERnext(ITER *it)
{
	size_t cnt = (*it->next) (it);
	BAT *b = it->result;
	BUN cur = BUNfirst(b);
	size_t idx = cnt + BUNindex(b, cur);

	b->batBuns->free = BUNptr(b, idx) - b->batBuns->base;
	it->tuples_seen += cnt;
	it->result_cur = cur;
	if (b->hseqbase != oid_nil)
		it->mirror->tseqbase = (b->hseqbase += cnt);
	if (b->tseqbase != oid_nil)
		it->mirror->hseqbase = (b->tseqbase += cnt);
	return cnt;
}

static
    size_t
ITERguess(ITER *it)
{
	return (*it->guess) (it);
}

static
    int
ITERfree(ITER *it)
{
	int cnt = BBPunfix(it->result->batCacheid);

	if (cnt <= 0) {
		if (it->free)
			(*it->free) (it);
		GDKfree(it);
	}
	return cnt;
}

static
BAT *
ITERcollect(ITER *it)
{
	BAT *bn = BATnew(it->result->htype, it->result->ttype, ITERguess(it));
	BUN p, q, r = BUNfirst(bn);
	int xx, yy = BUNsize(bn);

	if (it->result->hkey)
		BATkey(bn, TRUE);
	if (it->result->tkey)
		BATkey(BATmirror(bn), TRUE);
	bn->tsorted = it->result->tsorted;
	bn->hsorted = it->result->tsorted;
	if (BAThdense(it->result))
		BATseqbase(bn, it->result->hseqbase);
	if (BATtdense(it->result))
		BATseqbase(BATmirror(bn), it->result->tseqbase);

	ITERloop(it, p, q, xx) {
		if (bn->batBuns->free + yy > bn->batBuns->size) {
			size_t delta = ITERguess(it);

			if (BATextend(bn, BATcount(bn) + MAX(100, delta)) == NULL)
				goto bunins_failed;
			r = BUNlast(bn);
		}
		bunfastins_nocheck(bn, r, BUNhead(it->result, p), BUNtail(it->result, p), xx);
		r += xx;
	}
	return bn;
      bunins_failed:
	BBPreclaim(bn);
	return NULL;
}


@+ Scan Iterator
@T
Input is simpy an already loaded bat. We provide slices of it.
@h
typedef struct {
	size_t tuples_left;
} ScanHandle;

@c
size_t
ScanNext(ITER *it)
{
	size_t cnt = MIN(chunksize, it->hdl.scan.tuples_left);
	BAT *b = it->result;

	b->batFirst = BUNlast(b) - BUNsize(b);
	it->hdl.scan.tuples_left -= cnt;
	return cnt;
}

size_t
ScanGuess(ITER *it)
{
	return it->hdl.scan.tuples_left;	/* no guess: it's for sure */
}

int
iter_scan(iter *res, BAT *b)
{
	ITER *it;

	if (b->batRestricted != BAT_READ) {
		GDKerror("iter_scan: %s must be a read-only BAT.\n", BATgetId(b));
		return GDK_FAIL;
	}
	it = ITERinit(NULL, "scan", ScanNext, NULL, ScanGuess, b, NULL, NULL);
	it->result->batBuns->free = BUNfirst(b) - it->result->batBuns->base;
	it->hdl.scan.tuples_left = BATcount(b);

	*res = (iter) it;
	return GDK_SUCCEED;
}

@+ Mirror, Reverse and Mark Iterators
@T
This passes through the mirrored results of its input. No buns need to be copied as
their BAT buffers are views of each other; hence share the same data structures. 
@c
size_t
ViewNext(ITER *it)
{
	return ITERnext((ITER *) it->input);
}

size_t
ViewGuess(ITER *it)
{
	return ITERguess((ITER *) it->input);
}

void
ViewFree(ITER *it)
{
	(void) ITERfree((ITER *) it->input);
}

int
iter_mirror(iter *res, iter *in)
{
	ITER *input = (ITER *) *in;

	*res = (iter) ITERinit(input, "mirror", ViewNext, ViewFree, ViewGuess, VIEWcombine(input->result), input->result, BATmirror(input->result));
	return GDK_SUCCEED;
}

@- reverse
@T
This passes through the reversed results of its input. We reuse the mirror methods.
@c
int
iter_reverse(iter *res, iter *in)
{
	ITER *input = (ITER *) *in;
	BAT *b = BATmirror(input->result);

	*res = (iter) ITERinit(input, "reverse", ViewNext, ViewFree, ViewGuess, b, b, NULL);
	return GDK_SUCCEED;
}

@- mark
@c
int
iter_mark(iter *res, iter *in, oid *base)
{
	ITER *input = (ITER *) *in;
	BAT *b = BATmark(input->result, *base);

	*res = (iter) ITERinit(input, "mark", ViewNext, ViewFree, ViewGuess, b, NULL, NULL);
	return GDK_SUCCEED;
}

@+ Scan-Select Iterator
@T
This scans the input stream (whatever it may be) and only lets pass the qualifying 
elements. Qualification is determined using some bit-function that is executed with
three parameters: current tail-value and two constant parameter values.
Special cases without function call are coded out for equi-select and range-select
of various atomic types; 
@h
typedef struct {
	GDKfcn fcn;
	ptr v1, v2;
} SelectHandle;

@c
/* the code expansions */
@:select(any,any,tail,any,any)@
@:select(chr,eq,tloc,simple,chr)@
@:select(bte,eq,tloc,simple,bte)@
@:select(sht,eq,tloc,simple,sht)@
@:select(int,eq,tloc,simple,int)@
@:select(lng,eq,tloc,simple,lng)@
@:select(any,eq,tail,atom,b->ttype)@
@:select(chr,rng,tloc,simple,chr)@
@:select(bte,rng,tloc,simple,bte)@
@:select(sht,rng,tloc,simple,sht)@
@:select(int,rng,tloc,simple,int)@
@:select(flt,rng,tloc,simple,flt)@
@:select(lng,rng,tloc,simple,lng)@
@:select(dbl,rng,tloc,simple,dbl)@
@:select(any,rng,tail,atom,b->ttype)@

@= select_eq
   if (@2_EQ(BUN@1(b,p), it->hdl.sel.v1, @3))
@= select_rng
   if (@2_GE(BUN@1(b,p), it->hdl.sel.v1, @3) && @2_LE(BUN@1(b,p), it->hdl.sel.v2, @3))
@= select_any
   bit _zz; 
   (*it->hdl.sel.fcn)(&_zz, BUNtail(b,p), it->hdl.sel.v1, it->hdl.sel.v2);
   if (_zz) 
@= select
size_t SelectNext_@1_@2(ITER *it) {
    ITER *input = (ITER*) it->input;
    BAT *b = input->result;
    BUN p, q, r = BUNfirst(it->result);
    int xx;
    size_t yy = 0;

    ITERloop(input, p, q, xx) {
        @:select_@2(@3,@4,@5)@ {
            buncopy(it, r, BUNhead(b,p), BUN@3(b,p)); 
            ITERbreak(input, p+xx, ++yy);
        } 
    }
    return yy;
}
@c
size_t
SelectGuess(ITER *it)
{
	ITER *input = (ITER *) it->input;
	size_t totsize = (*input->guess) (input);

	return totsize / MAX(10, input->tuples_seen / MAX(1, it->tuples_seen));
}

int
iter_select2(iter *res, iter *in, bit *t, str fcn, ptr p1, int t1, ptr p2, int t2)
{
	NEXTfcn nxt = SelectNext_any_any;
	ITER *it, *input = (ITER *) *in;
	ValRecord argv[4];
	monet_sig_t sig;
	int argc = 3;
	BAT *bn;

	argv[1].vtype = BATttype(input->result);
	argv[2].vtype = t1;
	if (p2) {
		argv[argc++].vtype = t2;
	}
	sig.ret_tpe = 0;
	if (argc == 3 && strcmp(fcn, "rng") == 0 && t1 == t2 && t2 == input->result->ttype) {
		switch (ATOMstorage(input->result->ttype)) {
		case TYPE_chr:
			nxt = SelectNext_chr_rng;
			break;
		case TYPE_bte:
			nxt = SelectNext_bte_rng;
			break;
		case TYPE_sht:
			nxt = SelectNext_sht_rng;
			break;
		case TYPE_int:
			nxt = SelectNext_int_rng;
			break;
		case TYPE_flt:
			nxt = SelectNext_flt_rng;
			break;
		case TYPE_lng:
			nxt = SelectNext_lng_rng;
			break;
		case TYPE_dbl:
			nxt = SelectNext_dbl_rng;
			break;
		default:
			nxt = SelectNext_any_rng;
		}
	} else if (argc == 2 && strcmp(fcn, "eq") == 0 && t1 == input->result->ttype) {
		switch (ATOMstorage(input->result->ttype)) {
		case TYPE_chr:
			nxt = SelectNext_chr_eq;
			break;
		case TYPE_bte:
			nxt = SelectNext_bte_eq;
			break;
		case TYPE_sht:
			nxt = SelectNext_sht_eq;
			break;
		case TYPE_int:
		case TYPE_flt:
			nxt = SelectNext_int_eq;
			break;
		case TYPE_lng:
		case TYPE_dbl:
			nxt = SelectNext_lng_eq;
			break;
		default:
			nxt = SelectNext_any_eq;
		}
	} else if (TBL_normal_resolve(fcn, argc, argv, &sig, 0) != TOK_COMMAND || sig.ret_tpe != TYPE_bit || sig.fast_fcn == NULL) {
		GDKerror("iter_select: %s(%s,%s%s%s):%s is not a useable bit-command.\n", fcn, ATOMname(BATttype(input->result)), ATOMname(t1), p2 ? "," : "", p2 ? ATOMname(t2) : "", ATOMname(sig.ret_tpe));
		return GDK_FAIL;
	}
	bn = BATnew(BAThtype(input->result), *t ? BATttype(input->result) : TYPE_void, chunksize);
	if (input->result->hkey)
		BATkey(bn, TRUE);
	if (input->result->tkey)
		BATkey(BATmirror(bn), TRUE);
	bn->hsorted = input->result->hsorted;
	bn->tsorted = input->result->tsorted;

	it = ITERinit(input, "select", nxt, ViewFree, SelectGuess, bn, input->result, NULL);
	it->hdl.sel.fcn = sig.fast_fcn;
	it->hdl.sel.v1 = p1;
	it->hdl.sel.v2 = p2;

	*res = (iter) it;
	return GDK_SUCCEED;
}

int
iter_select1(iter *res, iter *input, bit *t, str fcn, ptr v1, int t1)
{
	return iter_select2(res, input, t, fcn, v1, t1, NULL, TYPE_void);
}

@+ Join Iterator
@T
Falls down into two cases: hash-join and positional join.

@- hash-join
@T
This is equi-join using a hash table on the inner operand. The inner
operand is materialied (it is a BAT).  The iterator then iteratively 
returns matches on tuples from the outer stream with the hash-table.
@h
typedef struct {
	BAT *inner;
	var_t *hash, *link;
	var_t mask, hashnum;
} JoinHandle;

@c
#define iterator_hashbte(tpe,val,msk) ((var_t) ((unsigned char*) val)[0])
#define iterator_hashchr(tpe,val,msk) iterator_hashbte(tpe,val,msk)
#define iterator_hashsht(tpe,val,msk) (((var_t) ((unsigned short*) val)[0]) % msk)
#define iterator_hashint(tpe,val,msk) (((var_t) ((unsigned int *) val)[0]) % msk)
#define iterator_hashlng(tpe,val,msk) ((var_t)(((unsigned int *) val)[0]^((unsigned int *) val)[1]) % msk)
#define iterator_hashloc(tpe,val,msk) (((var_t) (*BATatoms[tpe].atomHash)(val)) % msk)
#define iterator_hashvar(tpe,val,msk) iterator_hashloc(tpe,val,msk)

@:join(simple,chr,chr,loc)@
@:join(simple,bte,bte,loc)@
@:join(simple,sht,sht,loc)@
@:join(simple,int,int,loc)@
@:join(simple,lng,lng,loc)@
@:join(atom,loc,it->hdl.join.inner->htype,loc)@
@:join(atom,var,it->hdl.join.inner->htype,var)@

@= join
size_t JoinNext_@2(ITER *it) {
    ITER *outer = (ITER*) it->input;
    BUN p, q, r = BUNfirst(it->result);
    int xx;
    size_t yy = 0;

    ITERloop(outer, p, q, xx) {
	if (it->hdl.join.hashnum == 0) {
            it->hdl.join.hashnum =  
	        it->hdl.join.hash[iterator_hash@2(@3, BUNh@4(outer->result,p), it->hdl.join.mask)];
	}
        while(it->hdl.join.hashnum != 0) { 
            BUN t = BUNptr(it->hdl.join.inner, it->hdl.join.hashnum);
            it->hdl.join.hashnum = it->hdl.join.link[it->hdl.join.hashnum];
            if (@1_EQ(BUNt@4(outer->result, p), BUNh@4(it->hdl.join.inner,t), @3)) {
                buncopy(it, r, BUNhead(outer->result,p), BUNtail(it->hdl.join.inner,t)); 
                ITERbreak(outer, p, ++yy);
            }
        }
    }
    return yy;
}

@- postional-join
Here we can look up an OID by its position, because it resides in a VOID column.
@c
size_t
JoinNextVoid(ITER *it)
{
	ITER *outer = (ITER *) it->input;
	BUN p, q, t, r = BUNfirst(it->result);
	int xx;
	size_t yy = 0;

	ITERloop(outer, p, q, xx) {
		ptr val;

		BUNfndVOID(t, it->hdl.join.inner, BUNtloc(outer->result, p));
		if (t) {
			val = BUNtail(it->hdl.join.inner, t);
		} else {
			/* match error: 'recover' like outerjoin */
			val = ATOMnilptr(it->hdl.join.inner->ttype);
		}
		buncopy(it, r, BUNhead(outer->result, p), val);
		ITERbreak(outer, p + xx, ++yy);
	}
	return yy;
}

size_t
JoinGuess(ITER *it)
{
	ITER *outer = (ITER *) it->input;
	flt lsize = (flt) (*outer->guess) (outer);
	flt rsize = (flt) BATcount(it->hdl.join.inner);
	flt div = (flt) MAX(1.0, lsize / MAX(1.0, rsize));

	if (it->next == JoinNextVoid) {
		return (size_t) lsize;
	}
	return (size_t) (lsize / MAX(div, ((flt) outer->tuples_seen) / (flt) MAX(1, it->tuples_seen)));
}

int
iter_join(iter *res, iter *input, BAT *inner)
{
	NEXTfcn nxt = JoinNextVoid;
	ITER *it, *outer = (ITER *) *input;
	int ht = outer->result->htype;
	int n_one = outer->result->tkey;
	BAT *bn;

	if (outer->result->ttype != TYPE_oid || !BAThdense(inner)) {
		if (ATOMstorage(outer->result->ttype) == ATOMstorage(inner->htype)) {
			switch (ATOMstorage(inner->ttype)) {
			case TYPE_chr:
				nxt = JoinNext_chr;
				break;
			case TYPE_bte:
				nxt = JoinNext_bte;
				break;
			case TYPE_sht:
				nxt = JoinNext_sht;
				break;
			case TYPE_int:
			case TYPE_flt:
				nxt = JoinNext_int;
				break;
			case TYPE_lng:
			case TYPE_dbl:
				nxt = JoinNext_lng;
				break;
			default:
				nxt = (inner->tvarsized) ? JoinNext_var : JoinNext_loc;
			}
		} else {
			GDKerror("iter_join(iter[%s,%s], bat[%s,%s]) : not implemented.\n", ATOMname(outer->result->htype), ATOMname(outer->result->ttype), ATOMname(inner->htype), ATOMname(inner->ttype));
			return GDK_FAIL;
		}
	}
	if (ht == TYPE_void && !n_one) {
		ht = TYPE_oid;
	}
	bn = BATnew(ht, BATttype(inner), chunksize);
	bn->hsorted = outer->result->hsorted;
	bn->tsorted = 0;
	bn->hkey = outer->result->hkey && inner->hkey;
	it = ITERinit(outer, "join", nxt, ViewFree, JoinGuess, bn, outer->result, inner);
	it->hdl.join.inner = inner;
	if (nxt == JoinNextVoid) {
		BATseqbase(bn, outer->result->hseqbase);
		bn->tkey = outer->result->tkey && inner->tkey;
	} else {
		(void) BATprepareHash(inner);
		it->hdl.join.hash = inner->hhash->hash;
		it->hdl.join.link = inner->hhash->link;
		it->hdl.join.mask = inner->hhash->mask;
		it->hdl.join.hashnum = 0;
		n_one = FALSE;
	}

	*res = (iter) it;
	return GDK_SUCCEED;
}


@+ GroupBy-Aggregation 
@T
Aggregation breaks the tuple stream, as it needs to see all tuples before the
aggregate totals are known. Therefore, these operators return a BAT rather than 
an ITER. We provide two implementations: a generic hash-based grouping and
direct grouping on small integers (1-byte, 2-byte).

\begin{verbatim}
AGGREGATE-FCN     x     GROUPBY-TYPE      x     VALUE-TYPE  
          {count} x {chr,bte,sht,int,any}                           
{max,min,sum,avg} x {chr,bte,sht,int,any} x {chr,bte,sht,int,flt,lng,dbl} 
\end{verbatim}

We extract all 100 different implementation functions (1*4 + 4*4*6 = 100) from two 
code templates (one with direct grouping and one with hash-grouping) by decomposing 
the aggregate function into an init-value, an add-macro and a finish-macro.

@= aggr_count_init
@= aggr_sum_init
    *(@1*) aggr(@2) = (@1) 0;
@= aggr_avg_init
    *(@1*) aggr(@2) = (@1) 0;
@= aggr_min_init
    *(@1*) aggr(@2) = GDK_@1_max;
@= aggr_max_init
    *(@1*) aggr(@2) = GDK_@1_min;
@c
#define aggr(idx)	BUNtloc(bn, BUNptr(bn,idx))
#define bunfnd(r,v){ oid _id = *(oid*) v; oid *_o = &_id; BUNfndOID(r,attr,_o);\
    } if (r == NULL) {\
        GDKerror("iter_groupby: matching problem oid=%lu.\n", *(oid*) v);\
    } else
#define aggr_count_add(tpe,idx,v)
#define aggr_max_add(tpe,idx,v) bunfnd(r,v)\
    { tpe *_t=(tpe*)aggr(idx), *_a=(tpe*)BUNtloc(attr,r); if (*_a > *_t) *_t = *_a; }
#define aggr_min_add(tpe,idx,v) bunfnd(r,v)\
    { tpe *_t=(tpe*)aggr(idx), *_a=(tpe*)BUNtloc(attr,r); if (*_a < *_t) *_t = *_a; }
#define aggr_sum_add(tpe,idx,v) bunfnd(r,v)\
    { *(tpe*) aggr(idx) += *(tpe*) BUNtloc(attr,r); }
#define aggr_avg_add(tpe,idx,v) aggr_sum_add(tpe,idx,v)

#define aggr_count_finish(tpe,idx,r) *(int*) BUNtloc(bn,r) = cnt[idx]
#define aggr_sum_finish(tpe,idx,r) *(tpe*) BUNtloc(bn,r) = *(tpe*) aggr(idx)
#define aggr_avg_finish(tpe,idx,r) *(tpe*) BUNtloc(bn,r) = *(tpe*) aggr(idx) / cnt[idx]
#define aggr_min_finish(tpe,idx,r) *(tpe*) BUNtloc(bn,r) = *(tpe*) aggr(idx)
#define aggr_max_finish(tpe,idx,r) *(tpe*) BUNtloc(bn,r) = *(tpe*) aggr(idx)

@:groupby_grptpe(count,void)@
@:groupby_valtpe(max)@
@:groupby_valtpe(min)@
@:groupby_valtpe(avg)@
@:groupby_valtpe(sum)@

BATfcn
groupby_fcn(str aggr, int valtpe, int grptpe)
{
	if (strcmp(aggr, "count") == 0) {
		return groupby_fcn_count_void(grptpe);
	} else if (strcmp(aggr, "max") == 0) {
		return groupby_fcn_max(valtpe, grptpe);
	} else if (strcmp(aggr, "min") == 0) {
		return groupby_fcn_min(valtpe, grptpe);
	} else if (strcmp(aggr, "avg") == 0) {
		return groupby_fcn_avg(valtpe, grptpe);
	} else if (strcmp(aggr, "sum") == 0) {
		return groupby_fcn_sum(valtpe, grptpe);
	}
	return NULL;
}

@= groupby_valtpe
@:groupby_grptpe(@1,chr)@
@:groupby_grptpe(@1,bte)@
@:groupby_grptpe(@1,sht)@
@:groupby_grptpe(@1,int)@
@:groupby_grptpe(@1,wrd)@
@:groupby_grptpe(@1,flt)@
@:groupby_grptpe(@1,lng)@
@:groupby_grptpe(@1,dbl)@

BATfcn groupby_fcn_@1(int valtpe, int grptpe) {
    BATfcn f = NULL;
    switch(valtpe) {
    case TYPE_chr: f = groupby_fcn_@1_chr(grptpe); break;
    case TYPE_bte: f = groupby_fcn_@1_bte(grptpe); break;
    case TYPE_sht: f = groupby_fcn_@1_sht(grptpe); break;
    case TYPE_int: f = groupby_fcn_@1_int(grptpe); break;
    case TYPE_wrd: f = groupby_fcn_@1_wrd(grptpe); break;
    case TYPE_flt: f = groupby_fcn_@1_flt(grptpe); break;
    case TYPE_lng: f = groupby_fcn_@1_lng(grptpe); break;
    case TYPE_dbl: f = groupby_fcn_@1_dbl(grptpe); break;
    }
    return f;
}

@= groupby_grptpe
@:groupby_direct(@1,@2,char,tloc)@
@:groupby_direct(@1,@2,short,tloc)@
@:groupby_hash(@1,@2,int,tloc)@
@:groupby_hash(@1,@2,any,tail)@

BATfcn groupby_fcn_@1_@2(int grptpe) {
    BATfcn f = groupby_@1_@2_any;
    switch(grptpe) {
    case TYPE_bte: f = groupby_@1_@2_char; break;
    case TYPE_sht: f = groupby_@1_@2_short; break;
    case TYPE_int: f = groupby_@1_@2_int; break;
    }
    return f;
}

@- hash-lookup
The group-by value is placed in a hash-table that leads to the aggregate totals.
There is one optimized version for integers, and an unoptimized version
that works with ADT calls.

@= groupby_hash
BAT *groupby_@1_@2_@3(ITER *input, BAT *attr) {
    size_t idx, yy = 0, maxgrps = 100;
    int xx; 
    BAT *bn = BATnew(BATttype(input->result), attr->ttype, maxgrps);
    size_t off = BUNindex(bn, BUNfirst(bn));
    int *cntbuf = (int*) GDKmalloc(maxgrps*sizeof(int)), *cnt = cntbuf - off;
    lng initval = 0;
    BUN p, q;

    ITERloop(input, p, q, xx) {
        ptr t = BUN@4(input->result, p);
	BUN r = NULL;
        (void) BATprepareHash(bn);
        HASHloop_@3(bn,bn->hhash,idx,t,r) break;
        if (r == NULL) {
	    idx = BUNindex(bn, BUNlast(bn));
            BUNins(bn, t, &initval, FALSE);
            if (++yy >= maxgrps) {
                cntbuf = (int*) GDKrealloc(cntbuf, (maxgrps*=2)*sizeof(int));
                cnt = cntbuf - off;
            }
            @:aggr_@1_init(@2,idx)@
            cnt[idx] = 0;
        } 
        cnt[idx]++;
        aggr_@1_add(@2,idx,BUNhead(input->result, p));
    }
    idx = off;
    BATloopFast(bn, p, q, xx) {
        aggr_@1_finish(@2,idx,p); idx++;
    }
    GDKfree(cntbuf);
    return bn;
}

@- direct-lookup (small integers)
If the groupby-attribute is a small integer (char or short) we simply work with an
array for the aggregate totals, that is indexed with this small integer number
(no hashing needed).

@= groupby_direct
BAT* groupby_@1_@2_@3(ITER *input, BAT *attr) {
    int ngrps = 0, maxgrps = 1 << (ATOMsize(input->result->ttype)*8);
    BAT *bn = BATnew(TYPE_oid, attr->ttype, maxgrps); 
    int *cnt = (int*) alloca(maxgrps*(int)sizeof(int));
    size_t off = BUNfirst(bn) - bn->batBuns->base;
    BUN p, q, r = BUNfirst(bn);
    int idx, xx, yy = BUNsize(bn);

    bn->batFirst += off;
    for(idx=0; idx < maxgrps; idx++) {
        cnt[idx] = 0;
        @:aggr_@1_init(@2,idx)@
    }

    ITERloop(input, p, q, xx) {
        ptr t = BUNtloc(input->result, p);
        cnt[idx = *(unsigned @3*) t]++;
        aggr_@1_add(@2,idx,BUNhead(input->result, p));
    }

    for(idx=0; idx<ngrps; idx++) if (cnt[idx]) {
        *(oid*) BUNhloc(bn,r) = (oid) idx;
        aggr_@1_finish(@2,idx,r);
        r += yy;
    }
    bn->batFirst -= off;
    bn->batBuns->free = r - BUNfirst(bn);
    bn->hsorted = bn->tsorted = 0;
    return bn;
}
@c
int
iter_aggr(BAT **bn, iter *input, str aggr, BAT *b)
{
	BAT *result = ((ITER *) *input)->result;
	BATfcn fcn = groupby_fcn(aggr, b ? b->ttype : 0, result->ttype);

	if (fcn == NULL || ATOMstorage(BAThtype(result)) != ATOMstorage(TYPE_oid)) {
		GDKerror("iter_aggr(grp[%s,%s], %s, attr[%s,%s]): illegal parameters.\n", ATOMname(result->htype), ATOMname(result->ttype), aggr, b ? ATOMname(b->htype) : "*", b ? ATOMname(b->ttype) : "*");
		return GDK_FAIL;
	}
	*bn = (*fcn) (*input, b);
	return GDK_SUCCEED;
}

int
iter_histo(BAT **bn, iter *input)
{
	BAT dummy_attr;

	dummy_attr.ttype = TYPE_int;
	return iter_aggr(bn, input, "count", &dummy_attr);
}


@+ next
@T
Replace the contents of the result bat with the next chunk (if any) and return TRUE.
Otherwise, deallocate the iterator and return FALSE.
@c
int
iter_next(bit *ret, iter *input)
{
	*ret = (ITERnext((ITER *) *input) > 0);
	return GDK_SUCCEED;
}

@+ chunk
give back the current chunk
@c
int
iter_chunk(BAT **ret, iter *input)
{
	*ret = ((ITER *) *input)->result;
	return GDK_SUCCEED;
}

@+ collect
@T
Materialize a tuple stream into a BAT. This function intelligently uses
the guess() method for estimating the memory resources needed.
@c
int
iter_collect(BAT **res, iter *input)
{
	*res = ITERcollect((ITER *) *input);
	return *res ? GDK_SUCCEED : GDK_FAIL;
}

@+ count
@c
int
iter_count(int *res, iter *input)
{
	ITER *it = (ITER *) *input;
	BUN p, q;
	int xx = 0;

	ITERloop(it, p, q, xx) xx++;

	*res = xx;
	return GDK_SUCCEED;
}

@+ chunksize
@T
Get and set the chunksize parameter. This determines the granularity in
which tuples flow through an iterator tree.
@c
int
iter_setchunksize(int *size)
{
	chunksize = (size_t) * size;
	return GDK_SUCCEED;
}

int
iter_getchunksize(int *size)
{
	*size = (int) chunksize;
	return GDK_SUCCEED;
}

@+ fix/unfix
@c
int
iter_fix(iter *input)
{
	return BBPfix(((ITER *) *input)->result->batCacheid);
}

int
iter_unfix(iter *input)
{
	return ITERfree((ITER *) *input);
}
