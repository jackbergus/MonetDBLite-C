@/
The contents of this file are subject to the MonetDB Public License
Version 1.1 (the "License"); you may not use this file except in
compliance with the License. You may obtain a copy of the License at
http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html

Software distributed under the License is distributed on an "AS IS"
basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations
under the License.

The Original Code is the MonetDB Database System.

The Initial Developer of the Original Code is CWI.
Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
Copyright August 2008-2010 MonetDB B.V.
All Rights Reserved.
@

@f wisc
@t Monet Wisconsin Database Generator
@a M.L. Kersten
@v 1.1
@* Introduction
The Wisconsin Benchmark has become the simpliest benchmark  to asses
the implementation of a relational database.
The generator presented here has bee used to directly construct the
benchmark database in a series of BATs. The core code has been used
to derive the information presented in the thesis of C vd Berg.

The routines not mentioned in the MODULE interface are obsolete
and should be checked before being used.

The generator can be loaded as a module into any running server.

@m
.MODULE wisc;

.COMMAND wisc(str,int) = WISCgenerator; 
	"Wisconsin Benchmark Database Generator"
.COMMAND wiscdestroy(str) = WISCdestroy; 
	"WBD destroy table"
.END wisc;

@{
@* Implementation
@c
#include "monetdb4_config.h"
#include "gdk.h"
#include "wisc.proto.h"

static char string1[54] = "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx";
static char *rndstr;
/* static oid count; */

static void
WISCinitRndStr(int u1)
{
	int i;
	int k;
	char *p;
	char *q;

	rndstr = (char *) malloc(sizeof(char) * 7 * u1);
	p = rndstr;
	q = rndstr + 7 * u1;
	while (p < q) {
		*p++ = 'A';
	}

	for (i = 1, p = rndstr, q = rndstr + 7; i != u1; i++) {
		for (k = 0; k != 7; k++, p++, q++) {
			*q = *p + 1;
/*		if (q > rndstr+7*count) printf("bug"); */
			if (*q > 'Z') {
				*q = 'A';
			} else {
				p += 7 - k;
				q += 7 - k;
				break;
			}
		}
	}
}


static char *
rndStr(int i)
{
	int j;
	char *p, *q;

/* boundary test: i = count-1= >q = &rndstr[(count-1)+1 * 7] */
	for (j = 0, p = string1, q = &rndstr[(i + 1) * 7 - 1]; j != 7; j++) {
		*p++ = *q--;
	}
	return string1;
}


char string4[4][54] = {
	"AAAAxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
	"HHHHxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
	"OOOOxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
	"VVVVxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"
};

#define rnd4Str(u) (string4[(u)%4])

int *rnd;

static void
WISCinitUniq(int cnt)
{
	int *src = (int *) malloc(sizeof(int) * cnt);
	int top = cnt;
	int i;

	srand((int) time(0));
	rnd = (int *) malloc(sizeof(int) * cnt);
	WISCinitRndStr(cnt);
	for (i = 0; i != cnt; i++) {
		src[i] = i;
	}
	for (i = 0; i != cnt; i++, top--) {
		ssize_t idx = rand() % top;

		rnd[i] = src[idx];
		src[idx] = src[top - 1];
	}
	free(src);
}

/*
ssize_t gen, prime, seed;

WISCinitUniq(int cnt)
{
	if (cnt <= 1000) { 
		gen = 279;
		prime = 1009
	} else if (cnt <= 10000) {
		gen = 2969;
		prime = 10007
	} else if (cnt <= 100000) {
		gen = 21395;
		prime = 100003;
	} else if (cnt <= 1000000) {
		gen = 2107;
		prime = 1000003;
	} else if (cnt <= 10000000) {
		gen = 211;
		prime = 10000019;
	} else if (cnt <= 100000000) {
		gen = 21;
		prime = 100000007;
	} else { 
		printf("exceeded capacity\n");
		exit(1);
	}
	seed = gen;
}

ssize_t wiscrand(ssize_t seed, ssize_t limit)
{
	do {
		seed = (gen * seed)%prime;
	} while (seed > limit);

	return seed;
}
*/
struct {
	char *attr;
	int type;
} wisctype[16] = {
	{
	"unique1", TYPE_int,}, {
	"unique2", TYPE_int,}, {
	"two", TYPE_int,}, {
	"four", TYPE_int,}, {
	"ten", TYPE_int,}, {
	"twenty", TYPE_int,}, {
	"onePercent", TYPE_int,}, {
	"tenPercent", TYPE_int,}, {
	"twentyPercent", TYPE_int,}, {
	"fiftyPercent", TYPE_int,}, {
	"unique3", TYPE_int,}, {
	"evenOnePercent", TYPE_int,}, {
	"oddOnePercent", TYPE_int,}, {
	"stringu1", TYPE_str,}, {
	"stringu2", TYPE_str,}, {
"string4", TYPE_str},};

int
WISCgenerator(str nme,		/* string: pointer to char. */
	      int *cnt		/* pointer to integer. */
    )
{
	int u1, tmp;
	oid count, u2;
	int i;
	BAT *b[16];

	count = (oid) *cnt;
	stream_printf(GDKout, "WISC generator active on \"%s\" with %d tuples\n", nme, *cnt);
	stream_flush(GDKout);

	for (i = 0; i != 16; i++) {
		char buf[150];

		sprintf(buf, "%s_%s", nme, wisctype[i].attr);
		b[i] = BATnew(TYPE_void, wisctype[i].type, count);
		BATseqbase(b[i], 0);
		BATrename(b[i], buf);
		BATmode(b[i], PERSISTENT);
	}
	WISCinitUniq(*cnt);

	for (u2 = 0; u2 != count; u2++) {
		u1 = rnd[u2];
		b[0] = BUNins(b[0], &u2, &u1, FALSE);
	}
	for (u2 = 0; u2 != count; u2++) {
		u1 = rnd[u2];
		tmp = (int) u2;
		b[1] = BUNins(b[1], &u2, &tmp, FALSE);
	}
	for (u2 = 0; u2 != count; u2++) {
		u1 = rnd[u2];
		tmp = u1 % 2;
		b[2] = BUNins(b[2], &u2, &tmp, FALSE);
	}
	for (u2 = 0; u2 != count; u2++) {
		u1 = rnd[u2];
		tmp = u1 % 4;
		b[3] = BUNins(b[3], &u2, &tmp, FALSE);
	}
	for (u2 = 0; u2 != count; u2++) {
		u1 = rnd[u2];
		tmp = u1 % 10;
		b[4] = BUNins(b[4], &u2, &tmp, FALSE);
	}
	for (u2 = 0; u2 != count; u2++) {
		u1 = rnd[u2];
		tmp = u1 % 20;
		b[5] = BUNins(b[5], &u2, &tmp, FALSE);
	}
	for (u2 = 0; u2 != count; u2++) {
		u1 = rnd[u2];
		tmp = u1 % 100;
		b[6] = BUNins(b[6], &u2, &tmp, FALSE);
	}
	for (u2 = 0; u2 != count; u2++) {
		u1 = rnd[u2];
		tmp = u1 % 10;
		b[7] = BUNins(b[7], &u2, &tmp, FALSE);
	}
	for (u2 = 0; u2 != count; u2++) {
		u1 = rnd[u2];
		tmp = u1 % 5;
		b[8] = BUNins(b[8], &u2, &tmp, FALSE);
	}
	for (u2 = 0; u2 != count; u2++) {
		u1 = rnd[u2];
		tmp = u1 % 2;
		b[9] = BUNins(b[9], &u2, &tmp, FALSE);
	}
	for (u2 = 0; u2 != count; u2++) {
		u1 = rnd[u2];
		tmp = u1;
		b[10] = BUNins(b[10], &u2, &tmp, FALSE);
	}
	for (u2 = 0; u2 != count; u2++) {
		u1 = rnd[u2];
		tmp = u1 % 50 * 2;
		b[11] = BUNins(b[11], &u2, &tmp, FALSE);
	}
	for (u2 = 0; u2 != count; u2++) {
		u1 = rnd[u2];
		tmp = u1 % 50 * 2 + 1;
		b[12] = BUNins(b[12], &u2, &tmp, FALSE);
	}
	for (u2 = 0; u2 != count; u2++) {
		u1 = rnd[u2];
		/* (void) malloc(20); */
		b[13] = BUNins(b[13], &u2, rndStr(u1), FALSE);
	}
	for (u2 = 0; u2 != count; u2++) {
		u1 = rnd[u2];
		b[14] = BUNins(b[14], &u2, rndStr((int) u2), FALSE);
	}
	for (u2 = 0; u2 != count; u2++) {
		b[15] = BUNins(b[15], &u2, rnd4Str(u2), FALSE);
	}
	free(rnd);
	free(rndstr);
	return GDK_SUCCEED;
}

@-
The tables created for the Wisconsin database can be easily removed
by giving their base name only.
@c
int
WISCdestroy(str nme)
{
	int i;
	BAT *b;

	stream_printf(GDKout, "WISC destroy active \"%s\" \n", nme);
	stream_flush(GDKout);
	for (i = 0; i != 16; i++) {
		char buf[150];

		sprintf(buf, "%s_%s", nme, wisctype[i].attr);
		b = BATload(buf);
		if (b == 0) {
			GDKerror("WISCdestroy: %s not found\n", buf);
		} else {
			BBPreclaim(b);
		}
	}
	return GDK_SUCCEED;
}

@}
