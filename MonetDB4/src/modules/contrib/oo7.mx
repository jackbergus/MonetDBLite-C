@/
The contents of this file are subject to the MonetDB Public License
Version 1.1 (the "License"); you may not use this file except in
compliance with the License. You may obtain a copy of the License at
http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html

Software distributed under the License is distributed on an "AS IS"
basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations
under the License.

The Original Code is the MonetDB Database System.

The Initial Developer of the Original Code is CWI.
Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
Copyright August 2008-2011 MonetDB B.V.
All Rights Reserved.
@

@f oo7
@t OO7 database generator utility
@a F. Kwakkel, P. Boncz
@v 1.1
@* Introduction
@m
.MODULE oo7;

@+ Database Creation/Destruction
@m
.COMMAND oo7create(STR params) = oo7_create; 
"Create the OO7 database schema and fill it. Run with -help for info."

.COMMAND oo7delete() = oo7_delete; 
"Delete all OO7 tables."

@+ Traversal Predicates
Code spawned for the OO7 traversals (and used by the ODMG traversal library).
@m
.COMMAND subgraph(BAT[ANY::2,ANY::1] in,
                  BAT[ANY::1,ANY::1] edges) : BAT[ANY::1,ANY::1] = CMDsubgraph;
"Uses the tail values from 'in' as starting points, and
determines by recursive traversal which subgraph of 'edges'
can be reached from there. This subgraph is returned.\n
Traversal order is currently breadth-first.\n
Works only on ANY::1 e {int,oid,flt,bat,ptr}. "
 
.COMMAND closure( BAT[ANY::1,ANY::1] edges) : BAT[ANY::1,ANY::1] = CMDclosure;
"Computes the transitive closure of all points in the 'edges'
graph. Breadth-first traversal is used (repeated forward joins)."
 
.COMMAND traverse( BAT[ANY::2,ANY::1] in, BAT[ANY::1,ANY::1] edges):
                                BAT[ANY::1,ANY::1] = CMDtraverse; 
"From the starting points in 'in' (tail), compute all
reachable points by (dag!) 'edges'."

.END oo7;
@{
@* Implementation
@c
#include "monetdb_config.h"
#include "oo7.proto.h"
#include <monet.h>

#define NEWOID 		(OID++)
#define MAXPARLEN 	20
#define LINE_LEN	60

int NumAtomicPerComp;
int NumConnPerAtomic;
int DocumentSize;
int ManualSize;
int NumCompPerModule;
int NumAssmPerAssm;
int NumAssmLevels;
int NumCompPerAssm;
int NumModules;
int MinAtomicDate;
int MaxAtomicDate;
int MinAssmDate;
int MaxAssmDate;
int MinYoungCompDate;
int MaxYoungCompDate;
int MinOldCompDate;
int MaxOldCompDate;
int YoungCompFrac;

struct Params {
	char name[MAXPARLEN];
	int *val;
	int def;
} params[] = {
	{
	"NumAtomicPerComp", &NumAtomicPerComp, 20}, {
	"NumConnPerAtomic", &NumConnPerAtomic, 3}, {
	"DocumentSize", &DocumentSize, 2000}, {
	"ManualSize", &ManualSize, 1000000}, {
	"NumCompPerModule", &NumCompPerModule, 500}, {
	"NumAssmPerAssm", &NumAssmPerAssm, 3}, {
	"NumAssmLevels", &NumAssmLevels, 7}, {
	"NumCompPerAssm", &NumCompPerAssm, 3}, {
	"NumModules", &NumModules, 1}, {
	"MinAtomicDate", &MinAtomicDate, 1900}, {
	"MaxAtomicDate", &MaxAtomicDate, 1999}, {
	"MinAssmDate", &MinAssmDate, 1900}, {
	"MaxAssmDate", &MaxAssmDate, 1999}, {
	"MinYoungCompDate", &MinYoungCompDate, 2000}, {
	"MaxYoungCompDate", &MaxYoungCompDate, 2999}, {
	"MinOldCompDate", &MinOldCompDate, 0}, {
	"MaxOldCompDate", &MaxOldCompDate, 999}, {
	"YoungCompFrac", &YoungCompFrac, 10},
	    /* 1 out of 10 is young, others are old */
	{
	"", (int *) NULL, -1}
};

int TypeSize = 10;
int AtomTypeSize = 10;
int ConnTypeSize = 10;
int ModTypeSize = 10;
int CpaTypeSize = 10;
int BaseTypeSize = 10;
int TitleSize = 40;

char *rtype;
char *rtitle;
char *rdoctext;
char *ratomtype;
char *rconntype;
char *rmodtype;
char *rcpatype;
char *rbatype;
char *rmantext;

int *atom_oids;
int *cp_oids;

int rdocid = 0;
int rcpid = 0;
int ratomid = 0;
int rmodid = 0;
int ratomdocid = 0;
int rcpaid;
int rbaid = 0;
int rmanid = 0;

int OID = 0;

#define connTypeSize 4

char connType[connTypeSize][10] = { "very low", "low", "medium", "high" };

/* CLASS BATs */

BAT *DesignObj, *Connection, *Document, *BaseAssembly, *ComplexAssembly, *AtomicPart, *CompositePart, *Assembly, *Module, *Manual;

/* ATTRIBUTE BATs */

BAT *DesignObj_id, *DesignObj_type, *DesignObj_buildDate, *Connection_type, *Connection_length, *Document_title, *Document_id, *Document_text, *AtomicPart_buildDate, *AtomicPart_docId, *AtomicPart_type, *AtomicPart_id, *AtomicPart_x, *AtomicPart_y,
    *CompositePart_id, *CompositePart_buildDate, *CompositePart_type, *Module_id, *Module_buildDate, *Module_type, *Manual_title, *Manual_id, *Manual_text, *Manual_textLen, *ComplexAssembly_id, *ComplexAssembly_buildDate, *ComplexAssembly_type,
    *BaseAssembly_id, *BaseAssembly_buildDate, *BaseAssembly_type;

/* RELATION BATs */

BAT *rootPart, *parts, *to, *from, *doc, *priv, *shar, *assemblies, *subass, *designRoot, *man;

/* function prototypes */

int oo7genAssembly(int mod_oid, int level);

/*****************************/
/**** Randomize functions ****/
/*****************************/

static int
RandomCpBuildDate(void)
{
	static int c = 0;

	c++;
	if (c % YoungCompFrac == 0)
		return MinYoungCompDate + rand() % (MaxYoungCompDate - MinYoungCompDate + 1);	/* young */
	else
		return MinOldCompDate + rand() % (MaxOldCompDate - MinOldCompDate + 1);	/* old */
}

static int
RandomAtomBuildDate(void)
{
	return MinAtomicDate + rand() % (MaxAtomicDate - MinAtomicDate + 1);
}

static int
RandomBaBuildDate(void)
{

	return MinAssmDate + rand() % (MaxAssmDate - MinAssmDate + 1);
}

static int
RandomBaId(void)
{
	return (rbaid++);
}

static char *
RandomBaType(void)
{
	strcpy(rbatype, "anytype");
	return (rbatype);
}

static char *
RandomType(void)
{
	strcpy(rtype, "anytype");
	return rtype;
}

static char *
RandomTitle(void)
{
	sprintf(rtitle, "any title you like here (%d)", rdocid);
	return (rtitle);
}

static char *
RandomDocText(void)
{
	int i;

	for (i = 0; i < DocumentSize; i++)
		rdoctext[i] = (char) rand() % 26 + 'a';
	rdoctext[DocumentSize] = '\0';
	return (rdoctext);

}

static int
RandomDocId(void)
{
	return (rdocid++);
}

static int
RandomCpId(void)
{
	return (rcpid++);
}

static int
RandomAtomId(void)
{
	return (ratomid++);
}

static int
RandomAtomDocId(void)
{
	return (ratomdocid++);
}

static char *
RandomAtomType(void)
{
	strcpy(ratomtype, "anytype");
	return (ratomtype);
}

static int
RandomAtomX(void)
{
	return (rand());
}

static int
RandomAtomY(void)
{
	return (rand());
}

static char *
RandomConnType(void)
{
	return (connType[rand() % connTypeSize]);
}

static int
RandomConnLen(void)
{
	return (rand());
}

static int
RandomCpaId(void)
{
	return (rcpaid++);
}

static int
RandomCpaBuildDate(void)
{
	return (MinAssmDate + rand() % (MaxAssmDate - MinAssmDate + 1));
}

static char *
RandomCpaType(void)
{
	strcpy(rcpatype, "anytype");
	return (rcpatype);
}

static int
RandomModId(void)
{
	return (rmodid++);
}

static char *
RandomModType(void)
{
	strcpy(rmodtype, "anytype");
	return (rmodtype);
}

static int
RandomModBuildDate(void)
{
	return (rand());
}

static int
RandomManId(void)
{
	return (rmanid++);
}

static char *
RandomManText(void)
{
	int i;

	for (i = 0; i < ManualSize; i++)
		rmantext[i] = (char) ('a' + (rand() % 26));
	rdoctext[ManualSize] = '\0';
	return (rmantext);

}

@

@* oo7 create

@c
static BAT *
createBat(char *name, int ht, int tt)
{
	int i;
	BAT *b;

	if ((i = BBPindex(name)) != 0) {
		b = BATdescriptor(i);
		b = BBP_cache(ABS((b)->batCacheid));
		BATclear(b);
	} else
		b = BATnew(ht, tt, 100000);

	if (b == 0) {
		GDKerror("createBat: fatal error in oo7:createBat\n");
		return (0);
	}

	BATrename(b, name);
	BATmode(b, PERSISTENT);
	BATcommit(b);
	return (b);
}

int
oo7genAssembly(int mod_oid, int level)
{
	int i, d;
	char *s;
	int cpa_oid, child_ass_oid, ba_oid;

	if (level <= 1) {

		/* Base Assembly */

		ba_oid = NEWOID;

		BaseAssembly = BUNins(BaseAssembly, &ba_oid, &ba_oid, FALSE);
		d = RandomBaId();
		BaseAssembly_id = BUNins(BaseAssembly_id, &ba_oid, &d, FALSE);
		s = RandomBaType();
		BaseAssembly_type = BUNins(BaseAssembly_type, &ba_oid, s, FALSE);
		d = RandomBaBuildDate();
		BaseAssembly_buildDate = BUNins(BaseAssembly_buildDate, &ba_oid, &d, FALSE);

		/* private components: work to be done (see page 9 from spec) */

		/* BaseAssembly -- priv -- CompositePart */

		for (i = 0; i < NumCompPerAssm; i++)
			priv = BUNins(priv, &ba_oid, &cp_oids[rand() % NumCompPerModule], FALSE);

		/* shared components */

		/* BaseAssembly -- shar -- CompositePart */

		for (i = 0; i < NumCompPerAssm; i++)
			shar = BUNins(shar, &ba_oid, &cp_oids[rand() % NumCompPerModule], FALSE);

		/* Module -- assemblies -- Assembly */

		assemblies = BUNins(assemblies, &mod_oid, &ba_oid, FALSE);

		return (ba_oid);

	} else {

		/* Complex Assembly */

		cpa_oid = NEWOID;

		ComplexAssembly = BUNins(ComplexAssembly, &cpa_oid, &cpa_oid, FALSE);
		d = RandomCpaId();
		ComplexAssembly_id = BUNins(ComplexAssembly_id, &cpa_oid, &d, FALSE);
		s = RandomCpaType();
		ComplexAssembly_type = BUNins(ComplexAssembly_type, &cpa_oid, s, FALSE);
		d = RandomCpaBuildDate();
		ComplexAssembly_buildDate = BUNins(ComplexAssembly_buildDate, &cpa_oid, &d, FALSE);

		for (i = 0; i < NumAssmPerAssm; i++) {
			child_ass_oid = oo7genAssembly(mod_oid, level - 1);
			subass = BUNins(subass, &cpa_oid, &child_ass_oid, FALSE);
		}

		/* Module -- assemblies -- Assembly */

		assemblies = BUNins(assemblies, &mod_oid, &cpa_oid, FALSE);

		return (cpa_oid);
	}
}

@

@c
int
oo7_create(str par)
{
	int i, j, k, d;
	stream *out = GDKout;

	/*
	 * The Object Identifier(s);
	 */

	int cp_oid, doc_oid, atom_oid, conn_oid, top_ass_oid, man_oid, mod_oid;

	char *s, *par1, *val;

	/*
	 * Initialize randomizer
	 */

	srand(0);

	/* Set parameters to defaults */

	for (i = 0; params[i].val != (int *) NULL; i++)
		*params[i].val = params[i].def;

	/*
	 * Process Arguments ({Parameter=Value}*)
	 *
	 */

	par1 = par;
	while (*par1 != '\0') {
		par = par1;
		if ((par1 = strchr(par, ' ')) != (char *) NULL) {
			*par1 = '\0';
			par1++;
		} else
			par1 = par + strlen(par);

		if ((val = strchr(par, '=')) == (char *) NULL) {
			mnstr_printf(out, "oo7_create({Parameter=Value}*)\n");
			mnstr_printf(out, "Default parameter values:\n\n");
			for (j = 0; params[j].val != (int *) NULL; j++)
				mnstr_printf(out, "%-20s: %d\n", params[j].name, params[j].def);
			return 0;
		}
		val[0] = '\0';
		val++;
		for (j = 0; params[j].val != (int *) NULL; j++)
			if (strcmp(params[j].name, par) == 0) {
				*(params[j].val) = atoi(val);
				break;
			}
		if (params[j].val == (int *) NULL) {
			mnstr_printf(out, "oo7_create: unknown parameter: %s, default parameter values:\n\n", par);
			for (j = 0; params[j].val != (int *) NULL; j++)
				mnstr_printf(out, "oo7_create: %-20s: %d\n", params[j].name, params[j].def);
			return 0;
		}
	};

	/*
	 * Classes
	 *
	 */

	DesignObj = createBat("DesignObj", TYPE_oid, TYPE_oid);
	Connection = createBat("Connection", TYPE_oid, TYPE_oid);
	Document = createBat("Document", TYPE_oid, TYPE_oid);
	Assembly = createBat("Assembly", TYPE_oid, TYPE_oid);
	BaseAssembly = createBat("BaseAssembly", TYPE_oid, TYPE_oid);
	ComplexAssembly = createBat("ComplexAssembly", TYPE_oid, TYPE_oid);
	AtomicPart = createBat("AtomicPart", TYPE_oid, TYPE_oid);
	CompositePart = createBat("CompositePart", TYPE_oid, TYPE_oid);
	Module = createBat("Module", TYPE_oid, TYPE_oid);
	Manual = createBat("Manual", TYPE_oid, TYPE_oid);

	/*
	 * Attributes
	 *
	 */

	/* Design Object */

	DesignObj_id = createBat("DesignObj_id", TYPE_oid, TYPE_int);
	DesignObj_type = createBat("DesignObj_type", TYPE_oid, TYPE_str);
	DesignObj_buildDate = createBat("DesignObj_buildDate", TYPE_oid, TYPE_int);

	/* Connection */

	Connection_type = createBat("Connection_type", TYPE_oid, TYPE_str);
	Connection_length = createBat("Connection_length", TYPE_oid, TYPE_int);

	/* Document */

	Document_id = createBat("Document_id", TYPE_oid, TYPE_int);
	Document_title = createBat("Document_title", TYPE_oid, TYPE_str);
	Document_text = createBat("Document_text", TYPE_oid, TYPE_str);

	/* AtomicPart */

	AtomicPart_id = createBat("AtomicPart_id", TYPE_oid, TYPE_int);
	AtomicPart_buildDate = createBat("AtomicPart_buildDate", TYPE_oid, TYPE_int);
	AtomicPart_x = createBat("AtomicPart_x", TYPE_oid, TYPE_int);
	AtomicPart_y = createBat("AtomicPart_y", TYPE_oid, TYPE_int);
	AtomicPart_type = createBat("AtomicPart_type", TYPE_oid, TYPE_int);
	AtomicPart_docId = createBat("AtomicPart_docId", TYPE_oid, TYPE_int);

	/* CompositePart */

	CompositePart_id = createBat("CompositePart_id", TYPE_oid, TYPE_int);
	CompositePart_type = createBat("CompositePart_type", TYPE_oid, TYPE_str);
	CompositePart_buildDate = createBat("CompositePart_buildDate", TYPE_oid, TYPE_int);

	/* Module */

	Module_id = createBat("Module_id", TYPE_oid, TYPE_int);
	Module_buildDate = createBat("Module_buildDate", TYPE_oid, TYPE_int);
	Module_type = createBat("Module_type", TYPE_oid, TYPE_str);

	/* Manual */

	Manual_title = createBat("Manual_title", TYPE_oid, TYPE_str);
	Manual_id = createBat("Manual_id", TYPE_oid, TYPE_int);
	Manual_text = createBat("Manual_text", TYPE_oid, TYPE_str);
	Manual_textLen = createBat("Manual_textLen", TYPE_oid, TYPE_int);

	/* Assembly */

	/* Complex Assembly */

	ComplexAssembly_id = createBat("ComplexAssembly_id", TYPE_oid, TYPE_int);
	ComplexAssembly_buildDate = createBat("ComplexAssembly_buildDate", TYPE_oid, TYPE_int);
	ComplexAssembly_type = createBat("ComplexAssembly_type", TYPE_oid, TYPE_str);

	/* BaseAssembly */

	BaseAssembly_id = createBat("BaseAssembly_id", TYPE_oid, TYPE_int);
	BaseAssembly_buildDate = createBat("BaseAssembly_buildDate", TYPE_oid, TYPE_int);
	BaseAssembly_type = createBat("BaseAssembly_type", TYPE_oid, TYPE_str);


	/*
	 * Relations
	 *
	 */

	rootPart = createBat("rootPart", TYPE_oid, TYPE_oid);
	parts = createBat("parts", TYPE_oid, TYPE_oid);
	to = createBat("to", TYPE_oid, TYPE_oid);
	from = createBat("from", TYPE_oid, TYPE_oid);
	doc = createBat("doc", TYPE_oid, TYPE_oid);
	priv = createBat("priv", TYPE_oid, TYPE_oid);
	shar = createBat("shar", TYPE_oid, TYPE_oid);
	subass = createBat("subass", TYPE_oid, TYPE_oid);
	assemblies = createBat("assemblies", TYPE_oid, TYPE_oid);
	designRoot = createBat("designRoot", TYPE_oid, TYPE_oid);
	man = createBat("man", TYPE_oid, TYPE_oid);

	rtype = (char *) GDKmalloc((TypeSize + 1) * sizeof(char));
	rtitle = (char *) GDKmalloc((TitleSize + 1) * sizeof(char));
	rdoctext = (char *) GDKmalloc((DocumentSize + 1) * sizeof(char));
	ratomtype = (char *) GDKmalloc((AtomTypeSize + 1) * sizeof(char));
	rconntype = (char *) GDKmalloc((ConnTypeSize + 1) * sizeof(char));
	rmodtype = (char *) GDKmalloc((ModTypeSize + 1) * sizeof(char));
	rcpatype = (char *) GDKmalloc((CpaTypeSize + 1) * sizeof(char));
	rbatype = (char *) GDKmalloc((BaseTypeSize + 1) * sizeof(char));
	rmantext = (char *) GDKmalloc((ManualSize + 1) * sizeof(char));

	atom_oids = (int *) GDKmalloc((NumAtomicPerComp + 1) * sizeof(int));
	cp_oids = (int *) GDKmalloc((NumCompPerModule + 1) * sizeof(int));

	/* Generate All Composite Parts */

	for (i = 0; i < NumCompPerModule; i++) {

		/* Generate a Composite Part */

		cp_oid = NEWOID;
		cp_oids[i] = cp_oid;

		CompositePart = BUNins(CompositePart, &cp_oid, &cp_oid, FALSE);
		d = RandomCpId();
		CompositePart_id = BUNins(CompositePart_id, &cp_oid, &d, FALSE);
		d = RandomCpBuildDate();
		CompositePart_buildDate = BUNins(CompositePart_buildDate, &cp_oid, &d, FALSE);
		s = RandomType();
		CompositePart_type = BUNins(CompositePart_type, &cp_oid, s, FALSE);

		/* Generate a Document */

		doc_oid = NEWOID;

		Document = BUNins(Document, &doc_oid, &doc_oid, FALSE);
		d = RandomDocId();
		Document_id = BUNins(Document_id, &doc_oid, &d, FALSE);
		s = RandomTitle();
		Document_title = BUNins(Document_title, &doc_oid, s, FALSE);
		s = RandomDocText();
		Document_text = BUNins(Document_text, &doc_oid, s, FALSE);

		/* CompositePart --- doc --- Document */

		doc = BUNins(doc, &cp_oid, &doc_oid, FALSE);

		/* Generating the Atomic parts */

		for (j = 0; j < NumAtomicPerComp; j++) {

			atom_oid = NEWOID;
			atom_oids[j] = atom_oid;

			AtomicPart = BUNins(AtomicPart, &atom_oid, &atom_oid, FALSE);
			d = RandomAtomId();
			AtomicPart_id = BUNins(AtomicPart_id, &atom_oid, &d, FALSE);
			d = RandomAtomX();
			AtomicPart_x = BUNins(AtomicPart_x, &atom_oid, &d, FALSE);
			d = RandomAtomY();
			AtomicPart_y = BUNins(AtomicPart_y, &atom_oid, &d, FALSE);
			s = RandomAtomType();
			AtomicPart_type = BUNins(AtomicPart_type, &atom_oid, s, FALSE);
			d = RandomAtomDocId();
			AtomicPart_docId = BUNins(AtomicPart_docId, &atom_oid, &d, FALSE);
			d = RandomAtomBuildDate();
			AtomicPart_buildDate = BUNins(AtomicPart_buildDate, &atom_oid, &d, FALSE);

			/* CompositePart -- parts -- AtomicPart */

			parts = BUNins(parts, &cp_oid, &atom_oid, FALSE);
		}

		/* One Atomic Part is rootPart for a Composite Part */
		/* CompositePart -- rootPart -- AtomicPart */

		rootPart = BUNins(rootPart, &cp_oid, &atom_oids[rand() % NumAtomicPerComp], FALSE);

		/* Generate the Connections */

		/* FIRST: Put everything in a loop */

		for (j = 0; j < NumAtomicPerComp; j++) {

			/* Make a new connection */

			conn_oid = NEWOID;

			Connection = BUNins(Connection, &conn_oid, &conn_oid, FALSE);
			s = RandomConnType();
			Connection_type = BUNins(Connection_type, &conn_oid, s, FALSE);
			d = RandomConnLen();
			Connection_length = BUNins(Connection_length, &conn_oid, &d, FALSE);

			/* Connection -- from -- AtomicPart */

			from = BUNins(from, &conn_oid, &atom_oids[j], FALSE);

			/* Connection -- to -- AtomicPart */

			to = BUNins(to, &conn_oid, &atom_oids[(j + 1) % NumAtomicPerComp], FALSE);
		}

		/* SECOND: Add random connection  (2,5 or 8 to go) */

		for (j = 0; j < NumAtomicPerComp; j++)
			for (k = 1; k < NumConnPerAtomic; k++) {

				/* Make a new connection */

				conn_oid = NEWOID;

				Connection = BUNins(Connection, &conn_oid, &conn_oid, FALSE);
				s = RandomConnType();
				Connection_type = BUNins(Connection_type, &conn_oid, s, FALSE);
				d = RandomConnLen();
				Connection_length = BUNins(Connection_length, &conn_oid, &d, FALSE);

				/* Connection -- from -- AtomicPart */

				from = BUNins(from, &conn_oid, &atom_oids[j], FALSE);

				/* Connection -- to -- AtomicPart */

				to = BUNins(to, &conn_oid, &atom_oids[rand() % NumAtomicPerComp], FALSE);

			}
	}

	for (i = 0; i < NumModules; i++) {

		mod_oid = NEWOID;

		top_ass_oid = oo7genAssembly(mod_oid, NumAssmLevels);

		/* Module class, attributes */

		Module = BUNins(Module, &mod_oid, &mod_oid, FALSE);
		d = RandomModId();
		Module_id = BUNins(Module_id, &mod_oid, &d, FALSE);
		d = RandomModBuildDate();
		Module_buildDate = BUNins(Module_buildDate, &mod_oid, &d, FALSE);
		s = RandomModType();
		Module_type = BUNins(Module_type, &mod_oid, s, FALSE);

		/* Module -- designRoot -- ComplexAssembly) */

		designRoot = BUNins(designRoot, &mod_oid, &top_ass_oid, FALSE);

		/* Manual class, attributes */

		man_oid = NEWOID;

		Manual = BUNins(Manual, &man_oid, &man_oid, FALSE);
		s = RandomTitle();
		Manual_title = BUNins(Manual_title, &man_oid, s, FALSE);
		d = RandomManId();
		Manual_id = BUNins(Manual_id, &man_oid, &d, FALSE);

		s = RandomManText();
		Manual_text = BUNins(Manual_text, &man_oid, s, FALSE);

		Manual_textLen = BUNins(Manual_textLen, &man_oid, &ManualSize, FALSE);

		/* Module -- man -- Manual */

		man = BUNins(man, &mod_oid, &man_oid, FALSE);
	}

	GDKfree(rtype);
	GDKfree(rtitle);
	GDKfree(rdoctext);
	GDKfree(ratomtype);
	GDKfree(rconntype);
	GDKfree(rmodtype);
	GDKfree(rcpatype);
	GDKfree(rbatype);
	GDKfree(rmantext);

	GDKfree(atom_oids);
	GDKfree(cp_oids);

	/* Construction of the super class BATS */

	BATins(Assembly, BaseAssembly, FALSE);
	BATins(Assembly, ComplexAssembly, FALSE);

	BATins(DesignObj, AtomicPart, FALSE);
	BATins(DesignObj, CompositePart, FALSE);
	BATins(DesignObj, Assembly, FALSE);
	BATins(DesignObj, Module, FALSE);

	return (1);
}

@

@* oo7 delete
@c
int
oo7_delete(void)
{
	BAT *b;
	bat bid;

	if ((bid = BBPindex("rootPart")) && (b = BATdescriptor(bid)))
		BBPreclaim(b);
	if ((bid = BBPindex("parts")) && (b = BATdescriptor(bid)))
		BBPreclaim(b);
	if ((bid = BBPindex("to")) && (b = BATdescriptor(bid)))
		BBPreclaim(b);
	if ((bid = BBPindex("from")) && (b = BATdescriptor(bid)))
		BBPreclaim(b);
	if ((bid = BBPindex("doc")) && (b = BATdescriptor(bid)))
		BBPreclaim(b);
	if ((bid = BBPindex("priv")) && (b = BATdescriptor(bid)))
		BBPreclaim(b);
	if ((bid = BBPindex("shar")) && (b = BATdescriptor(bid)))
		BBPreclaim(b);
	if ((bid = BBPindex("assemblies")) && (b = BATdescriptor(bid)))
		BBPreclaim(b);
	if ((bid = BBPindex("subass")) && (b = BATdescriptor(bid)))
		BBPreclaim(b);
	if ((bid = BBPindex("designRoot")) && (b = BATdescriptor(bid)))
		BBPreclaim(b);
	if ((bid = BBPindex("man")) && (b = BATdescriptor(bid)))
		BBPreclaim(b);
	return GDK_SUCCEED;
}

@+  Closure and traversal operations
The closure operation takes a BAT and calculates the transitive closure.
The implementation below can be further optimized when BUN deletion
does not affect the BATloop [it doesn't!]

@= closure

static int
ANTICHECK_@1_@2_@3_@4(BAT *src, BUN p, BAT *chk, int tpe) 
{
    BUN w,u=BUNh@1(src, p);
    hash_t i; 

    (void) tpe;
    (void) BATprepareHash(chk);
    HASHloop@4(chk, chk->hhash, i, u, w) {
        if (@2_EQ(BUNt@1(chk, w), BUNt@1(src, p), @3)) { 
		return 1;
	}
    } 
    return 0;
}

static void
INSERT_ANTICHECK_@1_@2_@3_@4(BAT *dst, BAT *src, BAT *chk) 
{
        BUN p, q;
	int xx;
	int tpe = chk->htype;

        BATloopFast(src, p, q, xx) {
            if (ANTICHECK_@1_@2_@3_@4(src, p, dst, tpe))
		continue;
            if (ANTICHECK_@1_@2_@3_@4(src, p, chk, tpe))
		continue;
            BUNins(dst, BUNh@1(src, p), BUNt@1(src, p), FALSE);
        } 
	BBPreclaim(src); 
}

static void
closure_@1_@2_@3_@4( BAT *bn, BAT *delta ) 
{
	int tpe = bn->htype;
	while (BATcount(delta) > 0) {
        	BAT *new = BATjoin(delta,bn,BUN_NONE);
        	BAT *dst = BATnew(tpe, tpe, BATcount(new));
        	BATins(bn, delta, FALSE);
        	INSERT_ANTICHECK_@1_@2_@3_@4(dst, new, bn);
        	new = BATmirror(BATjoin(BATmirror(delta), BATmirror(bn), BUN_NONE));
        	BBPreclaim(delta);
        	delta = BATnew(tpe, tpe, BATcount(dst)+BATcount(new));
        	delta->hsorted = delta->tsorted = 0;
        	BATins(delta, dst, FALSE); BBPreclaim(dst);
        	INSERT_ANTICHECK_@1_@2_@3_@4(delta, new, bn);
	} 
}
@

@c
@:closure(loc,simple,bte,_bte)@
@:closure(loc,simple,sht,_sht)@
@:closure(loc,simple,int,_int)@
@:closure(loc,simple,lng,_lng)@
@:closure(loc,simple,ptr,_ptr)@
@:closure(loc,simple,oid,_oid)@
@:closure(var,atom,tpe,var)@
@:closure(loc,atom,tpe,loc)@

static BAT *
BATclosure(BAT *b)
{
	BAT *bn, *delta;
	int tpe;

	BATcheck(b, "BATclosure");
	ERRORcheck(TYPEerror(b->ttype, b->htype), "BATclosure:type conflict\n");

	tpe = b->htype;
	delta = BATsunique(b);
	bn = BATnew(tpe, tpe, BATcount(delta));
	bn->hsorted = bn->tsorted = 0;
	switch (tpe) {
	case TYPE_bit:
	case TYPE_chr:
	case TYPE_bte:
		closure_loc_simple_bte__bte(bn, delta);
		delta = NULL;
		break;
	case TYPE_sht:
		closure_loc_simple_sht__sht(bn, delta);
		delta = NULL;
		break;
	case TYPE_bat:
	case TYPE_int:
	case TYPE_flt:
#if SIZEOF_WRD == SIZEOF_INT
	case TYPE_wrd:
#endif
		closure_loc_simple_int__int(bn, delta);
		delta = NULL;
		break;
	case TYPE_oid:
		closure_loc_simple_oid__oid(bn, delta);
		delta = NULL;
		break;
	case TYPE_ptr:
		closure_loc_simple_ptr__ptr(bn, delta);
		delta = NULL;
		break;
	case TYPE_dbl:
	case TYPE_lng:
#if SIZEOF_WRD != SIZEOF_INT
	case TYPE_wrd:
#endif
		closure_loc_simple_lng__lng(bn, delta);
		delta = NULL;
		break;

	default:
		if (bn->hvarsized) {
			closure_var_atom_tpe_var(bn, delta);
		} else {
			closure_loc_atom_tpe_loc(bn, delta);
		}
		delta = NULL;
	}
	if (delta) {
		BATins(bn, delta, FALSE);
		(void) BBPreclaim(delta);
	}
	return bn;
}

@-
The traverse operation takes a BAT with starting points (or edges)
and calculates the reachable points using the reference DAG.
This implementation does not work well for non-tree graphs, because
it iterates over the temporary result. 
Moreover, the algorithm assumes a Directed Acyclic Graph.
Some performance is lost when we have to check for it.
Code expansion on type later.

@c
static BAT *
BATtraverse(BAT *b, BAT *dag)
{
	BAT *bn, *delta;
	BUN p;
	BUN q;
	ptr v, w;
	hash_t i;
	int xx;
	int grows, fnd;

	BATcheck(b, "BATtraverse");
	BATcheck(dag, "BATtraverse");
	ERRORcheck(TYPEerror(b->ttype, b->htype), "BATtraverse:type conflict\n");

	delta = BATsunique(b);
	BATcheck(delta, "BATtraverse: failed to create delta");

	if (b->ttype <= TYPE_sht || b->ttype >= TYPE_flt) {
		GDKerror("BATtraverse: type not yet supported\n");
		return delta;
	}
	if (BATprepareHash(dag)) {
		GDKerror("BATtraverse: couldn't hash\n");
		return delta;
	}
	do {
		grows = 0;
		bn = BATnew(BAThtype(delta), BATttype(delta), BATcount(delta) * 2);
		(void) BATset(bn, TRUE);
		BATloopFast(delta, p, q, xx) {
			fnd = 0;
			v = BUNtloc(delta, p);
			HASHloop_int(dag, dag->hhash, i, v, w) {
				bn = BUNins(bn, BUNhloc(delta, p), BUNtloc(dag, w), FALSE);
				fnd++;
			}
			if (fnd == 0) {
				bn = BUNins(bn, BUNhloc(delta, p), v, FALSE);
			} else
				grows++;
		}
		if (grows) {
			(void) BBPreclaim(delta);
			delta = bn;
		}
	} while (grows);
	return bn;
}

@-
This version has been produced for speed. tricky, because it
is not orthogonal. works for INTs, OIDs, only
Notice that the bat has to be reconstructed when the BAT grows.
Perhaps this should become part of BATexpand.
@c
static int
BATgraphtraverse(ptr v, BAT *bn, BAT *dag)
{
	ptr w, t;
	hash_t i;
	int j;

	if (BUNfnd(bn, v) != NULL) {
		return 0;
	}
	j = 0;
	HASHloop_int(dag, dag->hhash, i, v, w) {
		t = BUNtloc(dag, w);
		BUNfastins(bn, v, t);
		HASHins(bn, (BUNindex(bn, BUNlast(bn)) - 1), v);
		j++;
	}
	return j;
}

@

@-
The routine @%subgraph@ takes a BAT met fictive starting points and extracts the
corresponding subgraph from a BAT with a representation of the edges.
The points are extracted from the tail of the source bat and are not copied
to the destination unless it occurs as the head of an edge.
The routine works its waau through the graph in a semi-breadth search.
An older version was based on a recursive call to BATgraphtraverse.
The routine works its way through the graph recursively.
@c
static BAT *
BATsubgraph(BAT *b, BAT *dag)
{
	BAT *bn;
	BUN p;
	BUN q;
	size_t i, j;
	size_t bnsize = 0;


	BATcheck(b, "BATsubgraph");
	BATcheck(dag, "BATsubgraph");
	ERRORcheck(TYPEerror(b->ttype, b->htype), "BATsubgraph:type conflict\n");
	if (ATOMstorage(b->ttype) != TYPE_int || b->ttype >= TYPE_flt) {
		GDKerror("BATsubgraph: subgraphs works on INT-like types only.\n");
		return 0;
	}

	i = BATcount(dag);
	bn = BATnew(BAThtype(b), BATttype(b), (i < BATTINY ? BATTINY : i));
	if (bn == 0) {
		return bn;
	}
	/* set sorted flags by hand, because we used BUNfastins() */
	bn->hsorted = bn->tsorted = 0;

	if (BATprepareHash(dag)) {
		GDKerror("BATsubgraph: couldn't hash in subgraph\n");
		return bn;
	}

	BATloop(b, p, q)
	    bnsize += BATgraphtraverse(BUNtloc(b, p), bn, dag);
@-
Be careful here. The BAT bn may grow in size in the function
BATgraph traverse. This means that this loop should be independent of
its memory location.
@c
	for (j = BUNindex(bn, BUNfirst(bn)), bnsize += j; j < bnsize; j++)
		bnsize += BATgraphtraverse(BUNtloc(bn, BUNptr(bn, j)), bn, dag);

	return bn;
}

@- Interface Functions
@c
int
CMDsubgraph(BAT **ret, BAT *in, BAT *edges)
{
	return (*ret = BATsubgraph(in, edges)) ? GDK_SUCCEED : GDK_FAIL;
}

int
CMDtraverse(BAT **ret, BAT *in, BAT *edges)
{
	return (*ret = BATtraverse(in, edges)) ? GDK_SUCCEED : GDK_FAIL;
}

int
CMDclosure(BAT **ret, BAT *edges)
{
	return (*ret = BATclosure(edges)) ? GDK_SUCCEED : GDK_FAIL;
}

@
@}
