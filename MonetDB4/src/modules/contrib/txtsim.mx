@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2007 CWI.
@' All Rights Reserved.

@f txtsim
@t Module providing similarity metrics for strings
@a Arjan Scherpenisse, Peter Boncz (qgramselect, str2qgrams)
@d 15/04/2005
@v 0.3

@T 
@* String metrics

Provides basic similarity metrics for strings.

@* Module Definition
@m
.MODULE txtsim;

  .COMMAND levenshtein(str, str, int, int, int) : int = levenshtein_impl;
    "Calculates Levenshtein distance (edit distance) between two strings, variable operation costs (ins/del, replacement, transposition)"

  .COMMAND levenshtein(str, str) : int = levenshteinbasic_impl;
    "Calculates Levenshtein distance (edit distance) between two strings"
	
  .COMMAND editdistance(str, str) : int = levenshteinbasic_impl;
    "Alias for Levenshtein(str,str)"

  .COMMAND editdistance2(str, str) : int = levenshteinbasic2_impl;
    "Calculates Levenshtein distance (edit distance) between two strings. Cost of transposition is 1 instead of 2"

  .COMMAND similarity(str, str, dbl) : dbl = fstrcmp_impl;
    "Normalized edit distance between two strings"

  .COMMAND similarity(str, str) : dbl = fstrcmp0_impl;
    "Normalized edit distance between two strings"

  .COMMAND soundex(str) : str = soundex_impl;
    "Soundex function for phonetic matching"

  .COMMAND qgramnormalize(str): str = CMDqgramnormalize;
    "'Normalizes' strings (eg. toUpper and replaces non-alphanumerics with one space"
  
  .COMMAND qgramselfjoin(bat[void, oid] qgramid, bat[void, int] id, bat[void, int] pos, bat[void, int] len, flt c, int k) : bat[int, int] = CMDqgramselfjoin;
    "QGram self-join on ordered(!) qgram tables and sub-ordered q-gram positions"

.END txtsim;

@c
#include "monetdb4_config.h"

#include "txtsim.proto.h"

#include <string.h>
#ifdef HAVE_MALLOC_H
#include <malloc.h>
#endif
#include <stdio.h>
#include <stdlib.h>
#include <limits.h>

#define RETURN_NIL_IF(b,t) \
	if (b) {\
	   if (ATOMextern(t)) {\
	      *(ptr*) res = (ptr) ATOMnil(t);\
	   } else {\
	      memcpy(res, ATOMnilptr(t), ATOMsize(t));\
 	   }\
	   return GDK_SUCCEED; \
	}

/* =========================================================================
 * LEVENSH?TEIN FUNCTION
 * Source:
 * http://www.merriampark.com/ld.htm
 * =========================================================================
 */

#define MYMIN(x,y) ( (x<y) ? x : y )
#define SMALLEST_OF(x,y,z) ( MYMIN(MYMIN(x,y),z) )
#define SMALLEST_OF4(x,y,z,z2) ( MYMIN(MYMIN(MYMIN(x,y),z),z2) )

/***************************************************
 * Get a pointer to the specified cell of the matrix
 **************************************************/

inline int *
levenshtein_GetCellPointer(int *pOrigin, int col, int row, int nCols)
{
	return pOrigin + col + (row * (nCols + 1));
}

/******************************************************
 * Get the contents of the specified cell in the matrix 
 *****************************************************/

inline int
levenshtein_GetAt(int *pOrigin, int col, int row, int nCols)
{
	int *pCell;

	pCell = levenshtein_GetCellPointer(pOrigin, col, row, nCols);
	return *pCell;

}

/********************************************************
 * Fill the specified cell in the matrix with the value x
 *******************************************************/

inline void
levenshtein_PutAt(int *pOrigin, int col, int row, int nCols, int x)
{
	int *pCell;

	pCell = levenshtein_GetCellPointer(pOrigin, col, row, nCols);
	*pCell = x;
}


/******************************
 * Compute Levenshtein distance
 *****************************/
int
levenshtein_impl(int *result, str s, str t, int *insdel_cost, int *replace_cost, int *transpose_cost)
{
	int *d;			/* pointer to matrix */
	int n;			/* length of s */
	int m;			/* length of t */
	int i;			/* iterates through s */
	int j;			/* iterates through t */
	char s_i;		/* ith character of s */
	char t_j;		/* jth character of t */
	int cost;		/* cost */
	int cell;		/* contents of target cell */
	int above;		/* contents of cell immediately above */
	int left;		/* contents of cell immediately to left */
	int diag;		/* contents of cell immediately above and to left */
	int sz;			/* number of cells in matrix */
	int diag2 = 0, cost2 = 0;

	/* Step 1 */
	n = (int) strlen(s);	/* 64bit: assume strings are less than 2 GB */
	m = (int) strlen(t);
	if (n == 0) {
		return m;
	}
	if (m == 0) {
		return n;
	}
	sz = (n + 1) * (m + 1) * sizeof(int);
	d = (int *) GDKmalloc(sz);

	/* Step 2 */
	for (i = 0; i <= n; i++) {
		levenshtein_PutAt(d, i, 0, n, i);
	}

	for (j = 0; j <= m; j++) {
		levenshtein_PutAt(d, 0, j, n, j);
	}

	/* Step 3 */
	for (i = 1; i <= n; i++) {

		s_i = s[i - 1];

		/* Step 4 */
		for (j = 1; j <= m; j++) {

			t_j = t[j - 1];

			/* Step 5 */
			if (s_i == t_j) {
				cost = 0;
			} else {
				cost = *replace_cost;
			}

			/* Step 6 */
			above = levenshtein_GetAt(d, i - 1, j, n);
			left = levenshtein_GetAt(d, i, j - 1, n);
			diag = levenshtein_GetAt(d, i - 1, j - 1, n);

			if (j >= 2 && i >= 2) {
				/* NEW: detect transpositions */

				diag2 = levenshtein_GetAt(d, i - 2, j - 2, n);
				if (s[i - 2] == t[j - 1] && s[i - 1] == t[j - 2]) {
					cost2 = *transpose_cost;
				} else {
					cost2 = 2;
				}
				cell = SMALLEST_OF4(above + *insdel_cost, left + *insdel_cost, diag + cost, diag2 + cost2);
			} else {
				cell = SMALLEST_OF(above + *insdel_cost, left + *insdel_cost, diag + cost);
			}
			levenshtein_PutAt(d, i, j, n, cell);
		}
	}

	/* Step 7 */
	*result = levenshtein_GetAt(d, n, m, n);
	GDKfree(d);
	return GDK_SUCCEED;
}

int
levenshteinbasic_impl(int *result, str s, str t)
{
	int insdel = 1, replace = 1, transpose = 2;

	return levenshtein_impl(result, s, t, &insdel, &replace, &transpose);
}

int
levenshteinbasic2_impl(int *result, str s, str t)
{
	int insdel = 1, replace = 1, transpose = 1;

	return levenshtein_impl(result, s, t, &insdel, &replace, &transpose);
}


/* =========================================================================
 * SOUNDEX FUNCTION
 * Source:
 * http://www.mit.edu/afs/sipb/service/rtfm/src/freeWAIS-sf-1.0/ir/soundex.c
 * =========================================================================
 */

#define SoundexLen 4		/* length of a soundex code */
#define SoundexKey "Z000"	/* default key for soundex code */

/* set letter values */
static int Code[] = { 0, 1, 2, 3, 0, 1, 2, 0, 0, 2, 2, 4, 5, 5, 0,
	1, 2, 6, 2, 3, 0, 1, 0, 2, 0, 2
};

static inline char
SCode(unsigned char c)
{
	if (c == 95)
		return (2);	/* german sz */
	return (Code[toupper(c) - 'A']);
}

void
soundex_code(char *Name, char *Key)
{
	char LastLetter;
	int Index;

	/* set default key */
	strcpy(Key, SoundexKey);

	/* keep first letter */
	Key[0] = *Name;
	if (!isupper((int) (Key[0])))
		Key[0] = toupper(Key[0]);

	LastLetter = *Name;
	if (!*Name)
		return;
	Name++;

	/* scan rest of string */
	for (Index = 1; (Index <SoundexLen) &&*Name; Name++) {
		/* use only letters */
		if (isalpha((int) (*Name))) {
			/* ignore duplicate successive chars */
			if (LastLetter != *Name) {
				/* new LastLetter */
				LastLetter = *Name;

				/* ignore letters with code 0 */
				if (SCode(*Name) != 0) {
					Key[Index] = '0' + SCode(*Name);
					Index ++;
				}
			}
		}
	}
}


int
soundex_impl(str *res, str Name)
{
	RETURN_NIL_IF(strNil(Name), TYPE_str);

	*res = (str) GDKmalloc(sizeof(char) * (SoundexLen + 1));

	/* calculate Key for Name */
	soundex_code(Name, *res);

	return GDK_SUCCEED;
}


/******************************
 * QGRAMNORMALIZE
 *
 * This function 'normalizes' a string so valid q-grams can  be made of it:
 * All characters are transformed to uppercase, and all characters 
 * which are not letters or digits are stripped to a single space.
 *
 * qgramnormalize("Hallo, allemaal!").print(); --> "HALLO ALLEMAAL"
 * qgramnormalize(" '' t ' est").print(); --> [ "T EST" ]
 *
 *****************************/
int
CMDqgramnormalize(str *res, str input)
{
	int i, j = 0;
	char c, last = ' ';

	RETURN_NIL_IF(strNil(input), TYPE_str);

	*res = (str) GDKmalloc(sizeof(char) * (strlen(input) + 1));	/* normalized strings are never longer than original */

	for (i = 0; input[i]; i++) {
		c = toupper(input[i]);
		if (!(('A' <= c && c <= 'Z') || ('0' <= c && c <= '9')))
			c = ' ';
		if (c != ' ' || last != ' ') {
			(*res)[j++] = c;
		}
		last = c;
	}
	(*res)[j] = 0;
	/* strip final whitespace */
	while (j > 0 && (*res)[--j] == ' ')
		(*res)[j] = 0;

	return GDK_SUCCEED;

}

/* =========================================================================
 * FSTRCMP FUNCTION
 * Source:
 * http://search.cpan.org/src/MLEHMANN/String-Similarity-1/fstrcmp.c
 * =========================================================================
 */

#define PARAMS(proto) proto

/*
 * Data on one input string being compared.
 */
struct string_data {
	/* The string to be compared. */
	const char *data;

	/* The length of the string to be compared. */
	int data_length;

	/* The number of characters inserted or deleted. */
	int edit_count;
};

static struct string_data string[2];

static int max_edits;		/* compareseq stops when edits > max_edits */

#ifdef MINUS_H_FLAG

/* This corresponds to the diff -H flag.  With this heuristic, for
   strings with a constant small density of changes, the algorithm is
   linear in the strings size.  This is unlikely in typical uses of
   fstrcmp, and so is usually compiled out.  Besides, there is no
   interface to set it true.  */
static int heuristic;

#endif


/* Vector, indexed by diagonal, containing 1 + the X coordinate of the
   point furthest along the given diagonal in the forward search of the
   edit matrix.  */
static int *fdiag;

/* Vector, indexed by diagonal, containing the X coordinate of the point
   furthest along the given diagonal in the backward search of the edit
   matrix.  */
static int *bdiag;

/* Edit scripts longer than this are too expensive to compute.  */
static int too_expensive;

/* Snakes bigger than this are considered `big'.  */
#define SNAKE_LIMIT	20

struct partition {
	/* Midpoints of this partition.  */
	int xmid, ymid;

	/* Nonzero if low half will be analyzed minimally.  */
	int lo_minimal;

	/* Likewise for high half.  */
	int hi_minimal;
};


/* NAME
	diag - find diagonal path

   SYNOPSIS
	int diag(int xoff, int xlim, int yoff, int ylim, int minimal,
		struct partition *part);

   DESCRIPTION
	Find the midpoint of the shortest edit script for a specified
	portion of the two strings.

	Scan from the beginnings of the strings, and simultaneously from
	the ends, doing a breadth-first search through the space of
	edit-sequence.  When the two searches meet, we have found the
	midpoint of the shortest edit sequence.

	If MINIMAL is nonzero, find the minimal edit script regardless
	of expense.  Otherwise, if the search is too expensive, use
	heuristics to stop the search and report a suboptimal answer.

   RETURNS
	Set PART->(XMID,YMID) to the midpoint (XMID,YMID).  The diagonal
	number XMID - YMID equals the number of inserted characters
	minus the number of deleted characters (counting only characters
	before the midpoint).  Return the approximate edit cost; this is
	the total number of characters inserted or deleted (counting
	only characters before the midpoint), unless a heuristic is used
	to terminate the search prematurely.

	Set PART->LEFT_MINIMAL to nonzero iff the minimal edit script
	for the left half of the partition is known; similarly for
	PART->RIGHT_MINIMAL.

   CAVEAT
	This function assumes that the first characters of the specified
	portions of the two strings do not match, and likewise that the
	last characters do not match.  The caller must trim matching
	characters from the beginning and end of the portions it is
	going to specify.

	If we return the "wrong" partitions, the worst this can do is
	cause suboptimal diff output.  It cannot cause incorrect diff
	output.  */

static int diag PARAMS((int, int, int, int, int, struct partition *));

static int
diag(int xoff, int xlim, int yoff, int ylim, int minimal, struct partition *part)
{
	int *const fd = fdiag;	/* Give the compiler a chance. */
	int *const bd = bdiag;	/* Additional help for the compiler. */
	const char *const xv = string[0].data;	/* Still more help for the compiler. */
	const char *const yv = string[1].data;	/* And more and more . . . */
	const int dmin = xoff - ylim;	/* Minimum valid diagonal. */
	const int dmax = xlim - yoff;	/* Maximum valid diagonal. */
	const int fmid = xoff - yoff;	/* Center diagonal of top-down search. */
	const int bmid = xlim - ylim;	/* Center diagonal of bottom-up search. */
	int fmin = fmid;
	int fmax = fmid;	/* Limits of top-down search. */
	int bmin = bmid;
	int bmax = bmid;	/* Limits of bottom-up search. */
	int c;			/* Cost. */
	int odd = (fmid - bmid) & 1;

	/*
	 * True if southeast corner is on an odd diagonal with respect
	 * to the northwest.
	 */
	fd[fmid] = xoff;
	bd[bmid] = xlim;
	for (c = 1;; ++c) {
		int d;		/* Active diagonal. */
		int big_snake;

		big_snake = 0;
		/* Extend the top-down search by an edit step in each diagonal. */
		if (fmin > dmin)
			fd[--fmin - 1] = -1;
		else
			++fmin;
		if (fmax < dmax)
			fd[++fmax + 1] = -1;
		else
			--fmax;
		for (d = fmax; d >= fmin; d -= 2) {
			int x;
			int y;
			int oldx;
			int tlo;
			int thi;

			tlo = fd[d - 1], thi = fd[d + 1];

			if (tlo >= thi)
				x = tlo + 1;
			else
				x = thi;
			oldx = x;
			y = x - d;
			while (x < xlim && y < ylim && xv[x] == yv[y]) {
				++x;
				++y;
			}
			if (x - oldx > SNAKE_LIMIT)
				big_snake = 1;
			fd[d] = x;
			if (odd && bmin <= d && d <= bmax && bd[d] <= x) {
				part->xmid = x;
				part->ymid = y;
				part->lo_minimal = part->hi_minimal = 1;
				return 2 * c - 1;
			}
		}
		/* Similarly extend the bottom-up search.  */
		if (bmin > dmin)
			bd[--bmin - 1] = INT_MAX;
		else
			++bmin;
		if (bmax < dmax)
			bd[++bmax + 1] = INT_MAX;
		else
			--bmax;
		for (d = bmax; d >= bmin; d -= 2) {
			int x;
			int y;
			int oldx;
			int tlo;
			int thi;

			tlo = bd[d - 1], thi = bd[d + 1];
			if (tlo < thi)
				x = tlo;
			else
				x = thi - 1;
			oldx = x;
			y = x - d;
			while (x > xoff && y > yoff && xv[x - 1] == yv[y - 1]) {
				--x;
				--y;
			}
			if (oldx - x > SNAKE_LIMIT)
				big_snake = 1;
			bd[d] = x;
			if (!odd && fmin <= d && d <= fmax && x <= fd[d]) {
				part->xmid = x;
				part->ymid = y;
				part->lo_minimal = part->hi_minimal = 1;
				return 2 * c;
			}
		}

		if (minimal)
			continue;

#ifdef MINUS_H_FLAG
		/* Heuristic: check occasionally for a diagonal that has made lots
		   of progress compared with the edit distance.  If we have any
		   such, find the one that has made the most progress and return
		   it as if it had succeeded.

		   With this heuristic, for strings with a constant small density
		   of changes, the algorithm is linear in the strings size.  */
		if (c > 200 && big_snake && heuristic) {
			int best;

			best = 0;
			for (d = fmax; d >= fmin; d -= 2) {
				int dd;
				int x;
				int y;
				int v;

				dd = d - fmid;
				x = fd[d];
				y = x - d;
				v = (x - xoff) * 2 - dd;

				if (v > 12 * (c + (dd < 0 ? -dd : dd))) {
					if (v > best && xoff + SNAKE_LIMIT <= x && x < xlim && yoff + SNAKE_LIMIT <= y && y < ylim) {
						/* We have a good enough best diagonal; now insist
						   that it end with a significant snake.  */
						int k;

						for (k = 1; xv[x - k] == yv[y - k]; k++) {
							if (k == SNAKE_LIMIT) {
								best = v;
								part->xmid = x;
								part->ymid = y;
								break;
							}
						}
					}
				}
			}
			if (best > 0) {
				part->lo_minimal = 1;
				part->hi_minimal = 0;
				return 2 * c - 1;
			}
			best = 0;
			for (d = bmax; d >= bmin; d -= 2) {
				int dd;
				int x;
				int y;
				int v;

				dd = d - bmid;
				x = bd[d];
				y = x - d;
				v = (xlim - x) * 2 + dd;

				if (v > 12 * (c + (dd < 0 ? -dd : dd))) {
					if (v > best && xoff < x && x <= xlim - SNAKE_LIMIT && yoff < y && y <= ylim - SNAKE_LIMIT) {
						/* We have a good enough best diagonal; now insist
						   that it end with a significant snake.  */
						int k;

						for (k = 0; xv[x + k] == yv[y + k]; k++) {
							if (k == SNAKE_LIMIT - 1) {
								best = v;
								part->xmid = x;
								part->ymid = y;
								break;
							}
						}
					}
				}
			}
			if (best > 0) {
				part->lo_minimal = 0;
				part->hi_minimal = 1;
				return 2 * c - 1;
			}
		}
#else
		(void) big_snake;
#endif /* MINUS_H_FLAG */

		/* Heuristic: if we've gone well beyond the call of duty, give up
		   and report halfway between our best results so far.  */
		if (c >= too_expensive) {
			int fxybest;
			int fxbest;
			int bxybest;
			int bxbest;

			/* Pacify `gcc -Wall'. */
			fxbest = 0;
			bxbest = 0;

			/* Find forward diagonal that maximizes X + Y.  */
			fxybest = -1;
			for (d = fmax; d >= fmin; d -= 2) {
				int x;
				int y;

				x = fd[d] < xlim ? fd[d] : xlim;
				y = x - d;

				if (ylim < y) {
					x = ylim + d;
					y = ylim;
				}
				if (fxybest < x + y) {
					fxybest = x + y;
					fxbest = x;
				}
			}
			/* Find backward diagonal that minimizes X + Y.  */
			bxybest = INT_MAX;
			for (d = bmax; d >= bmin; d -= 2) {
				int x;
				int y;

				x = xoff > bd[d] ? xoff : bd[d];
				y = x - d;

				if (y < yoff) {
					x = yoff + d;
					y = yoff;
				}
				if (x + y < bxybest) {
					bxybest = x + y;
					bxbest = x;
				}
			}
			/* Use the better of the two diagonals.  */
			if ((xlim + ylim) - bxybest < fxybest - (xoff + yoff)) {
				part->xmid = fxbest;
				part->ymid = fxybest - fxbest;
				part->lo_minimal = 1;
				part->hi_minimal = 0;
			} else {
				part->xmid = bxbest;
				part->ymid = bxybest - bxbest;
				part->lo_minimal = 0;
				part->hi_minimal = 1;
			}
			return 2 * c - 1;
		}
	}
}


/* NAME
	compareseq - find edit sequence

   SYNOPSIS
	void compareseq(int xoff, int xlim, int yoff, int ylim, int minimal);

   DESCRIPTION
	Compare in detail contiguous subsequences of the two strings
	which are known, as a whole, to match each other.

	The subsequence of string 0 is [XOFF, XLIM) and likewise for
	string 1.

	Note that XLIM, YLIM are exclusive bounds.  All character
	numbers are origin-0.

	If MINIMAL is nonzero, find a minimal difference no matter how
	expensive it is.  */

static void compareseq PARAMS((int, int, int, int, int));

static void
compareseq(int xoff, int xlim, int yoff, int ylim, int minimal)
{
	const char *const xv = string[0].data;	/* Help the compiler.  */
	const char *const yv = string[1].data;

	if (string[1].edit_count + string[0].edit_count > max_edits)
		return;

	/* Slide down the bottom initial diagonal. */
	while (xoff < xlim && yoff < ylim && xv[xoff] == yv[yoff]) {
		++xoff;
		++yoff;
	}

	/* Slide up the top initial diagonal. */
	while (xlim > xoff && ylim > yoff && xv[xlim - 1] == yv[ylim - 1]) {
		--xlim;
		--ylim;
	}

	/* Handle simple cases. */
	if (xoff == xlim) {
		while (yoff < ylim) {
			++string[1].edit_count;
			++yoff;
		}
	} else if (yoff == ylim) {
		while (xoff < xlim) {
			++string[0].edit_count;
			++xoff;
		}
	} else {
		int c;
		struct partition part;

		/* Find a point of correspondence in the middle of the strings.  */
		c = diag(xoff, xlim, yoff, ylim, minimal, &part);
		if (c == 1) {
#if 0
			/* This should be impossible, because it implies that one of
			   the two subsequences is empty, and that case was handled
			   above without calling `diag'.  Let's verify that this is
			   true.  */
			abort();
#else
			/* The two subsequences differ by a single insert or delete;
			   record it and we are done.  */
			if (part.xmid - part.ymid < xoff - yoff)
				++string[1].edit_count;
			else
				++string[0].edit_count;
#endif
		} else {
			/* Use the partitions to split this problem into subproblems.  */
			compareseq(xoff, part.xmid, yoff, part.ymid, part.lo_minimal);
			compareseq(part.xmid, xlim, part.ymid, ylim, part.hi_minimal);
		}
	}
}

/* NAME
	fstrcmp - fuzzy string compare

   SYNOPSIS
	double fstrcmp(const char *s1, int l1, const char *s2, int l2, double);

   DESCRIPTION
	The fstrcmp function may be used to compare two string for
	similarity.  It is very useful in reducing "cascade" or
	"secondary" errors in compilers or other situations where
	symbol tables occur.

   RETURNS
	double; 0 if the strings are entirly dissimilar, 1 if the
	strings are identical, and a number in between if they are
	similar.  */

int
fstrcmp_impl(dbl *ret, str string1, str string2, dbl *minimum)
{
	int i;

	size_t fdiag_len;
	static int *fdiag_buf;
	static size_t fdiag_max;

	/* set the info for each string.  */
	string[0].data = string1;
	string[0].data_length = (int) strlen(string1); /* 64bit: assume string not too long */
	string[1].data = string2;
	string[1].data_length = (int) strlen(string2); /* 64bit: assume string not too long */

	/* short-circuit obvious comparisons */
	if (string[0].data_length == 0 && string[1].data_length == 0) {
		*ret = 1.0;
		return GDK_SUCCEED;
	}
	if (string[0].data_length == 0 || string[1].data_length == 0) {
		*ret = 0.0;
		return GDK_SUCCEED;
	}

	/* Set TOO_EXPENSIVE to be approximate square root of input size,
	   bounded below by 256.  */
	too_expensive = 1;
	for (i = string[0].data_length + string[1].data_length; i != 0; i >>= 2)
		too_expensive <<= 1;
	if (too_expensive < 256)
		too_expensive = 256;

	/* Because fstrcmp is typically called multiple times, while scanning
	   symbol tables, etc, attempt to minimize the number of memory
	   allocations performed.  Thus, we use a static buffer for the
	   diagonal vectors, and never free them.  */
	fdiag_len = string[0].data_length + string[1].data_length + 3;
	if (fdiag_len > fdiag_max) {
		fdiag_max = fdiag_len;
		fdiag_buf = realloc(fdiag_buf, fdiag_max * (2 * sizeof(int)));
	}
	fdiag = fdiag_buf + string[1].data_length + 1;
	bdiag = fdiag + fdiag_len;

	max_edits = 1 + (int) ((string[0].data_length + string[1].data_length) * (1. - *minimum));

	/* Now do the main comparison algorithm */
	string[0].edit_count = 0;
	string[1].edit_count = 0;
	compareseq(0, string[0].data_length, 0, string[1].data_length, 0);

	/* The result is
	   ((number of chars in common) / (average length of the strings)).
	   This is admittedly biased towards finding that the strings are
	   similar, however it does produce meaningful results.  */
	*ret = ((double)
		(string[0].data_length + string[1].data_length - string[1].edit_count - string[0].edit_count)
		/ (string[0].data_length + string[1].data_length));
	return GDK_SUCCEED;
}

int
fstrcmp0_impl(dbl *ret, str string1, str string2)
{
	double min = 0.0;

	return fstrcmp_impl(ret, string1, string2, &min);
}


/* ============ Q-GRAM SELF JOIN ============== */

int
CMDqgramselfjoin(BAT **res, BAT *qgram, BAT *id, BAT *pos, BAT *len, flt *c, int *k)
{
	size_t n = BATcount(qgram);
	unsigned int i, j;
	BAT *bn;

	oid *qbuf = (oid *) BUNtloc(qgram, BUNfirst(qgram));
	int *ibuf = (int *) BUNtloc(id, BUNfirst(id));
	int *pbuf = (int *) BUNtloc(pos, BUNfirst(pos));
	int *lbuf = (int *) BUNtloc(len, BUNfirst(len));

	ERRORcheck((qgram->ttype != TYPE_oid), "CMDqgramselfjoin: tail of BAT qgram must be oid.\n");
	ERRORcheck((id->ttype != TYPE_int), "CMDqgramselfjoin: tail of BAT id must be int.\n");
	ERRORcheck((pos->ttype != TYPE_int), "CMDqgramselfjoin: tail of BAT pos must be int.\n");
	ERRORcheck((len->ttype != TYPE_int), "CMDqgramselfjoin: tail of BAT len must be int.\n");

	/* ERRORcheck( (BATcount(qgram)>1 && !(BATtordered(qgram)&1)), "CMDqgramselfjoin: tail of qgram must be sorted.\n"); */

	ERRORcheck((ALIGNsynced(qgram, id) == 0), "CMDqgramselfjoin: qgram and id are not synced");

	ERRORcheck((ALIGNsynced(qgram, pos) == 0), "CMDqgramselfjoin: qgram and pos are not synced");
	ERRORcheck((ALIGNsynced(qgram, len) == 0), "CMDqgramselfjoin: qgram and len are not synced");

	ERRORcheck((BUNsize(qgram) != ATOMsize(qgram->ttype)), "CMDqgramselfjoin: qgram is not a true void bat");
	ERRORcheck((BUNsize(id) != ATOMsize(id->ttype)), "CMDqgramselfjoin: id is not a true void bat");

	ERRORcheck((BUNsize(pos) != ATOMsize(pos->ttype)), "CMDqgramselfjoin: pos is not a true void bat");
	ERRORcheck((BUNsize(len) != ATOMsize(len->ttype)), "CMDqgramselfjoin: len is not a true void bat");

	*res = bn = BATnew(TYPE_int, TYPE_int, n);

	for (i = 0; i < n - 1; i++) {
		for (j = i + 1; (j < n && qbuf[j] == qbuf[i] && pbuf[j] <= (pbuf[i] + (*k + *c * MYMIN(lbuf[i], lbuf[j])))); j++) {
			if (ibuf[i] != ibuf[j] && abs(lbuf[i] - lbuf[j]) <= (*k + *c * MYMIN(lbuf[i], lbuf[j]))) {
				bunfastins(bn, ibuf + i, ibuf + j);
			}
		}
	}

	bn->hsorted = bn->tsorted = 0;

	return GDK_SUCCEED;
      bunins_failed:
	GDKerror("CMDqgramselfjoin: could not realloc\n");
	BBPreclaim(bn);
	return GDK_FAIL;
}

@mil

proc stringdiff( str s1, str s1 ) : int {
	var sd1 := soundex(s1);
	var sd2 := soundex(s2);
	return editdistance(sd1,sd2);
}

proc str2qgrams(str s) : bat[oid,str]
{
    s := qgramnormalize(s);

    var len := s.length();
    var b := bat(str,void,len+4);
    var i := 0;
    var last := " ";

    b.insert("#",nil);
    b.insert("#",nil);
    while(i < len) {
        b.insert(s.string(i,1), nil);
        if (b.count() > 32764) break; # ignore suffix of >32KB strings
        i :+= 1;
    }
    b.insert("$",nil);
    b.insert("$",nil);
    b.reverse().seqbase(0@0);

    var c0 := b.select(0@0, oid(b.count() - 3)).mark(0@0).reverse();
    var c1 := b.select(1@0, oid(b.count() - 2)).mark(0@0).reverse();
    var c2 := b.select(2@0, oid(b.count() - 1)).mark(0@0).reverse();
    return [+](c0, [+](c1, c2));
}

# we assume the qgrams to ordered wrt frequency in the string collection
# ======================== QGRAM TABLE (37*37*37 entries)
# qgram_first[void,oid]   reference to qgrams table (first entry)
# qgram_val[void,str]     qgram 3-char string
#
# do not forget a sentinel entry [ oid(37*37*37 - 1), oid(count(qgrams_qgram)), "$$$" ] so that we can
# always find a next entry (for the higher bound).
#
# we assume qgrams to be ordered on qgram id
# ======================== QGRAMS TABLE (|avgstrlen+4| * |STRINGS| entries)
# qgrams_qgram[void,oid]   reference to qgram table
# qgrams_strings[void,oid] reference to strings table
# qgrams_len[void,sht]     string length, i.e. qgram_strings.join(strings_val).[length]().[sht]();
# qgrams_pos[void,sht]     string position (in normalized string, that is)
#
# ======================= STRINGS TABLE
# strings_val[void,str]
#
# we support strings up to 32768 characters

proc qgramselect(bat[void,oid] qgrams_strings, 
		 bat[void,sht] qgrams_pos,
		 bat[void,sht] qgrams_len,
                 bat[void,oid] qgram_first, 
		 bat[void,str] qgram_val,
                 str s, flt c, int k) : bat[flt,oid]
{
  var query := str2qgrams(s);
  var len := sht(query.count());
  var lim := 1 + 3*(k + int(c * flt(len)) - 1);
  var res := bat(oid,int,100000);
  var n := 0;

  # analyze qgrams (rare qgrams first to generate less candidates)
  qgram_val.join(query.reverse()).sort()@batloop() {
      var qgram := int($h);
      var pos := sht($t);
      var lo := qgram_first.find(oid(qgram));
      var hi := oid(int(qgram_first.find(oid(qgram+1)))-1);

      # filter_sel filters on candidates that have approximate the right position
      var filter_len := qgrams_len.reverse().select(lo,hi).reverse();
      var filter_lim := [flt]([min](filter_len,len)).access(BAT_WRITE).[:*=](c);
      filter_lim := [sht](filter_lim).access(BAT_WRITE).[:+=](sht(k));
      var filter_sel := qgrams_pos.reverse().select(lo,hi).reverse().[-](pos).[<](filter_lim);

      # refine filter_sel with a test on approximately the right length
      filter_sel.access(BAT_WRITE).[:and=](filter_len.access(BAT_WRITE).[:-=](len).[<](filter_lim));

      # test whether we already have info on the candidates that are left after filtering
      var filter_id := filter_sel.[ifthen](qgrams_strings.reverse().select(lo,hi).reverse());
      filter_sel := filter_id.outerjoin(res);

      # add new id counts to existing candidates (65536=1 because count is shifted 16 bits)
      res.replace(filter_id.reverse().join(filter_sel.select(0,int(nil)).access(BAT_WRITE).[:+=](65536)));

      if ((n :+= 1) <= lim) {
          # only insert new candidates in first iterations (otherwise they cannot make it anyway)
          filter_sel := filter_sel.uselect(int(nil)).mirror();
          filter_lim := [int](filter_sel.join(filter_lim)).access(BAT_WRITE).[:+=](65536);
          res.insert(filter_id.reverse().join(filter_lim));
      }
  }

  # perform selection to eliminate candidates that did not cut it; and compute ranking
  var res_strings := res.access(BAT_READ).mark(0@0).reverse();
  var res_lim := res.reverse().mark(0@0).reverse().[and](65535);
  var res_hit := res.reverse().mark(0@0).reverse().[>>](16);
  res_strings := [>](res_hit, res_lim).[ifthen](res_strings);
  res_hit := [flt](res_hit).access(BAT_WRITE).[:/=](flt(len));
  # we do not need to order on hit just yet because we will process all candidates with edit distance anyway.
  # return res_hit.reverse().join(res_strings).access(BAT_WRITE).order_rev().access(BAT_READ);
  return res_hit.reverse().join(res_strings).access(BAT_READ);
}


# comparing strings: 1@0: 'aap' and 2@0: 'aa'
# qgrams:
# 1@0: '##a'
# 2@0: '#aa'
# 3@0: 'aap'
# 4@0: 'aa$'

# qgram	id	pos	len
# 1@0	1@0	0	3
# 1@0	2@0	0	2
# 2@0	1@0	1	3
# 2@0	2@0	1	2
# 3@0	1@0	2	3
# 4@0	2@0	2	2
# etc

proc qgramselfjoin_test() : bat[oid, oid] {

	var qgram := (new (void, oid)).seqbase(0@0).append(1@0).append(1@0).append(2@0).append(2@0).append(3@0).append(4@0);
	var id := (new (void, oid)).seqbase(0@0).append(1@0).append(2@0).append(1@0).append(2@0).append(1@0).append(2@0);
	var pos := (new (void, int)).seqbase(0@0).append(0).append(0).append(1).append(1).append(2).append(2);
	var len := (new (void, int)).seqbase(0@0).append(3).append(2).append(3).append(2).append(3).append(3);

	var k := 3;
	var c := 0.8;

	return qgramselfjoin(qgram, id, pos, len, c, k);
}
