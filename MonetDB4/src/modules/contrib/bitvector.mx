@/
The contents of this file are subject to the MonetDB Public License
Version 1.1 (the "License"); you may not use this file except in
compliance with the License. You may obtain a copy of the License at
http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html

Software distributed under the License is distributed on an "AS IS"
basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations
under the License.

The Original Code is the MonetDB Database System.

The Initial Developer of the Original Code is CWI.
Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
Copyright August 2008-2010 MonetDB B.V.
All Rights Reserved.
@

@f bitvector
@t Bitvector datatypes
@a Peter Bosch
@v 1.0
@* Introduction

This module implements bit vectors.  One can encode a table with OIDs as
a bit vector where a bit is set when the corresponding table's OID is set.
A bit vector can also be decoded back into a real OID BAT.  Bit vectors
support the operations AND and OR.

@* Module Definition 
@m
.MODULE bitvector;

.COMMAND [allocate](wrd nbits, bit initial): 
   BAT[void,lng] = bitvector_allocate;
 "Allocate a new and empty bitvector"

.COMMAND [set](BAT[any::1,lng], wrd bnum) = bitvector_set;
 "Set a bit in a bitvector"

.COMMAND [isset](BAT[any::1,lng], wrd bnum): bit = bitvector_isset;
 "Is bit bnum set?"

.COMMAND [clr](BAT[any::1,lng], wrd bnum) = bitvector_clr;
 "Clear a bit in a bitvector"

.COMMAND [isclr](BAT[any::1,lng], wrd bnum): bit = bitvector_isclr;
 "Is bit bnum not set?"

.COMMAND [encode](BAT[any::1,oid]): BAT[void,lng] = bitvector_encode;
 "Encode a BAT with tail values into a bitvector"

.COMMAND [decode](BAT[void,lng]): BAT[oid,oid] = bitvector_decode;
 "Decodes a bitvector into a real BAT"

.COMMAND [and](BAT[void,lng], BAT[void,lng]): BAT[void,lng] = bitvector_and;
 "Logically ANDs two bitvectors"

.COMMAND [or](BAT[void,lng], BAT[void,lng]): BAT[void,lng] = bitvector_or;
 "Logically ORs two bitvectors"

.COMMAND [prt](BAT[void,lng]) = bitvector_print;
 "Print a bitvector"

.COMMAND [count](BAT[void,lng]): wrd = bitvector_count;
 "Count the number of bits set"

.END bitvector;

@mil
proc [allocate](int nbits, bit initial): bat[void,lng] {
    return [allocate](wrd(nbits), initial);
}
proc [set](bat[any::1,lng] b, int bnum): void {
    [set](b, wrd(bnum));
}
proc [isset](bat[any::1,lng] b, int bnum): bit {
    return [isset](b, wrd(bnum));
}
proc [clr](bat[any::1,lng] b, int bnum): void {
    [clr](b, wrd(bnum));
}
proc [isclr](bat[any::1,lng] b, int bnum): bit {
    return [isclr](b, wrd(bnum));
}

PROC test_bitvector() : void {

	a := new(int,oid); 
	a.insert(10, oid(0)); 
	a.insert(11, oid(62)); 
	a.insert(12, oid(64)); 
	a.insert(13, oid(256)); 

	b := new(int,oid); 
	b.insert(10, oid(0)); 
	b.insert(11, oid(31)); 
	b.insert(11, oid(32)); 
	b.insert(12, oid(62)); 

	bv_a := [encode](a);
	bv_a.print();

	bv_b := [encode](b);
	bv_b.print();

	bv_c := [and](bv_a, bv_b);
	bv_c.print();

	bv_d := [or](bv_a, bv_b);
	bv_d.print();

	c := [decode](bv_d);
	c.print();
}

@{
@* Implementation
@c
#include "monetdb4_config.h"
#include "bitvector.proto.h"

#define numentries(a, b)	(((a) + (b) - 1) / (b))

bitvector_export int
bitvector_allocate(BAT **b_dst, wrd *nbits, bit *initial)
{
	lng v;
	size_t nentries, n;

	nentries = numentries(*nbits, sizeof(lng) * 8);
	*b_dst = BATnew(TYPE_void, TYPE_lng, nentries);

	v = (*initial) ? -1 : 0;
	for (n = 0; n != nentries; n++)
		BUNappend(*b_dst, (ptr) &v, FALSE);
	return GDK_SUCCEED;
}

bitvector_export int
bitvector_set(BAT *b_src, wrd *bnum)
{
	size_t entry;
	lng *v;

	entry = *bnum / (sizeof(lng) * 8);
	if (BATcount(b_src) < entry + 1) {
		GDKerror("bitvector_set: BAT too small " BUNFMT " < " SZFMT "\n", BATcount(b_src), entry + 1);
		return GDK_FAIL;
	}

	v = (lng *) BUNtail(b_src, BUNfirst(b_src) + entry * BUNsize(b_src));
	*v |= (lng) 1 << (*bnum % (sizeof(lng) * 8));
	b_src->batDirty = TRUE;
	return GDK_SUCCEED;
}

bitvector_export int
bitvector_isset(bit *rv, BAT *b_src, wrd *bnum)
{
	size_t entry;
	lng v;

	entry = *bnum / (sizeof(lng) * 8);
	if (BATcount(b_src) < entry + 1) {
		GDKerror("bitvector_isset: BAT too small " BUNFMT " < " SZFMT "\n", BATcount(b_src), entry + 1);
		return GDK_FAIL;
	}

	v = *(lng *) BUNtail(b_src, BUNfirst(b_src) + entry * BUNsize(b_src));
	*rv = (bit) (v & ((lng) 1 << (*bnum % (sizeof(lng) * 8))));
	return GDK_SUCCEED;
}

bitvector_export int
bitvector_clr(BAT *b_src, wrd *bnum)
{
	size_t entry;
	lng *v;

	entry = *bnum / (sizeof(lng) * 8);
	if (BATcount(b_src) < entry + 1) {
		GDKerror("bitvector_clr: BAT too small " BUNFMT " < " SZFMT "\n", BATcount(b_src), entry + 1);
		return GDK_FAIL;
	}

	v = (lng *) BUNtail(b_src, BUNfirst(b_src) + entry * BUNsize(b_src));
	*v &= ~((lng) 1 << (*bnum % (sizeof(lng) * 8)));
	b_src->batDirty = TRUE;
	return GDK_SUCCEED;
}

bitvector_export int
bitvector_isclr(bit *rv, BAT *b_src, wrd *bnum)
{
	size_t entry;
	lng v;

	entry = *bnum / (sizeof(lng) * 8);
	if (BATcount(b_src) < entry + 1) {
		GDKerror("bitvector_isclr: BAT too small " BUNFMT " < " SZFMT "\n", BATcount(b_src), entry + 1);
		return GDK_FAIL;
	}

	v = *(lng *) BUNtail(b_src, BUNfirst(b_src) + entry * BUNsize(b_src));
	*rv = (v & ((lng) 1 << (*bnum % (sizeof(lng) * 8)))) ? 0 : 1;
	return GDK_SUCCEED;
}

bitvector_export int
bitvector_encode(BAT **b_dst, BAT *b_src)
{
	lng bf;
	oid nbits, lastentry;
	int xx;
	BUN p, q;

	if (b_src == NULL || b_src->ttype != TYPE_oid || BATorder(b_src) == NULL) {
		GDKerror("bitvector_encode: No OID table.\n");
		return GDK_FAIL;
	}
	nbits = * (oid *) BUNtail(b_src, BUNlast(b_src)) + 1;
	*b_dst = BATnew(TYPE_void, TYPE_lng, numentries(nbits, sizeof(lng) * 8));
	lastentry = 0;
	bf = 0;

	BATloopFast(b_src, p, q, xx) {
		oid *bnum, entry;

		bnum = (oid *) BUNtail(b_src, p);
		entry = *bnum / ((int) sizeof(lng) * 8);
		while (lastentry < entry) {
			lastentry++;
			BUNappend(*b_dst, (ptr) &bf, FALSE);
			bf = 0;
		}
		bf |= ((lng) 1 << (*bnum % (sizeof(lng) * 8)));
	}
	BUNappend(*b_dst, (ptr) &bf, FALSE);

	return GDK_SUCCEED;
}

bitvector_export int
bitvector_decode(BAT **b_dst, BAT *b_src)
{
	oid soid;
	BUN p, q;
	int xx, n;

	if (b_src->htype != TYPE_void || b_src->ttype != TYPE_lng) {
		GDKerror("bitvector_decode: None void/lng table.\n");
		return GDK_FAIL;
	}

	*b_dst = BATnew(TYPE_void, TYPE_oid, BATcount(b_src) * sizeof(lng) * 8);
	BATseqbase(*b_dst, (oid) 0);
	BATkey(BATmirror(*b_dst), TRUE);
	soid = 0;
	BATloopFast(b_src, p, q, xx) {
		lng bf;

		bf = *(lng *) BUNtail(b_src, p);
		if (bf)
			for (n = 0; n < (int) sizeof(lng) * 8; n++)
				if (bf & ((lng) 1 << n)) {
					oid _soid = soid + n;

					BUNappend(*b_dst, (ptr) &_soid, FALSE);
				}
		soid += sizeof(lng) * 8;
	}
	return GDK_SUCCEED;
}

bitvector_export int
bitvector_print(BAT *b_src)
{
	BUN p, q;
	int xx;

	if (b_src->htype != TYPE_void || b_src->ttype != TYPE_lng) {
		GDKerror("bitvector_decode: None void/lng table.\n");
		return GDK_FAIL;
	}

	BATloopFast(b_src, p, q, xx) {
		lng v = *(lng *) BUNtail(b_src, p);

		printf("x%08x%08x\n", (unsigned int) (v >> 32), (unsigned int) v);
	}
	return GDK_SUCCEED;
}

bitvector_export int
bitvector_and(BAT **b_dst, BAT *b_src1, BAT *b_src2)
{
	BUN p1, q1, p2, q2;

	if (b_src1->htype != TYPE_void || b_src1->ttype != TYPE_lng || b_src2->htype != TYPE_void || b_src2->ttype != TYPE_lng) {
		GDKerror("bitvector_and: No void/lng table(s).\n");
		return GDK_FAIL;
	}

	assert(BUNsize(b_src1) == sizeof(lng));

	*b_dst = BATnew(TYPE_void, TYPE_lng, BATcount(b_src1));

	p1 = BUNfirst(b_src1);
	q1 = BUNlast(b_src1);
	p2 = BUNfirst(b_src2);
	q2 = BUNlast(b_src2);
	for (; p1 < q1 && p2 < q2; p1 += sizeof(lng), p2 += sizeof(lng)) {
		lng v1, v2;

		v1 = * (lng *) BUNtail(b_src1, p1);
		v2 = * (lng *) BUNtail(b_src2, p2);
		v1 &= v2;
		BUNappend(*b_dst, (ptr) &v1, FALSE);
	}

	/* No need to copy the tail */
	return GDK_SUCCEED;
}

bitvector_export int
bitvector_or(BAT **b_dst, BAT *b_src1, BAT *b_src2)
{
	BUN p1, q1, p2, q2;

	if (b_src1->htype != TYPE_void || b_src1->ttype != TYPE_lng || b_src2->htype != TYPE_void || b_src2->ttype != TYPE_lng) {
		GDKerror("bitvector_and: No void/lng table(s).\n");
		return GDK_FAIL;
	}

	assert(BUNsize(b_src1) == sizeof(lng));

	*b_dst = BATnew(TYPE_void, TYPE_lng, BATcount(b_src1));

	p1 = BUNfirst(b_src1);
	q1 = BUNlast(b_src1);
	p2 = BUNfirst(b_src2);
	q2 = BUNlast(b_src2);
	for (; p1 < q1 && p2 < q2; p1 += sizeof(lng), p2 += sizeof(lng)) {
		lng v1, v2;

		v1 = * (lng *) BUNtail(b_src1, p1);
		v2 = * (lng *) BUNtail(b_src2, p2);
		v1 |= v2;
		BUNappend(*b_dst, (ptr) &v1, FALSE);
	}

	/* Copy the tail, when required */
	if (p1 < q1 || p2 < q2) {
		BUN p = NULL, q = NULL;
		BAT *b_src = NULL;

		if (p1 < q1) {
			assert(p2 == q2);
			p = p1;
			q = q1;
			b_src = b_src1;
		} else if (p2 < q2) {
			assert(p1 == q1);
			p = p2;
			q = q2;
			b_src = b_src2;
		}

		for (; p < q; p += sizeof(lng))
			BUNappend(*b_dst, BUNtail(b_src, p), FALSE);
	}

	return GDK_SUCCEED;
}

bitvector_export int
bitvector_count(wrd *count, BAT *b_src)
{
	BUN p, q;
	int xx;

	*count = 0;
	if (b_src->htype != TYPE_void || b_src->ttype != TYPE_lng) {
		GDKerror("bitvector_count: None void/lng table.\n");
		return GDK_FAIL;
	}

	BATloopFast(b_src, p, q, xx) {
		int n;
		lng v = *(lng *) BUNtail(b_src, p);

		if (v)
			for (n = 0; n != sizeof(lng) * 8; n++)
				if (v && (1 << n))
					(*count)++;
	}
	return GDK_SUCCEED;
}

@}
