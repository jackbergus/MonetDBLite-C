@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2008 CWI.
@' All Rights Reserved.

@' 		Alex van Ballegooij  <Alex.van.Ballegooij@cwi.nl>

@f bat_mmath
@t Optimized Multiplexed Mathematical Functions on BATs
@a A.R. van Ballegooij
@v 1.0
@* Introduction

This module provides optimized code-expanded implementations of multiplxed
math functions ([exp],[log],[pow]) on void-headed, head-aligned BATs.
Only the dbl type is supported.

@* Module Definition 
@m
.MODULE bat_mmath;

@
\begin{verbatim}
	signatures
	@1:	dbl			arithmetic type
	@2:	unary:  exp, log, sqrt 	mathematical function
	   	binary: pow            	mathematical function
\end{verbatim}

@= unarysignatures
.COMMAND "[@2]" (BAT[void,@1]) : BAT[void,@1] = bat_@1_@2;
	"optimized multiplexed @2 on [void,@1] BATs"

@= binarysignatures
.COMMAND "[@2]" (BAT[void,@1],BAT[void,@1]) : BAT[void,@1] = batbat_@1_@2;
	"optimized multiplexed @2 on head-aligned [void,@1] BATs"
.COMMAND "[@2]" (@1,BAT[void,@1]) : BAT[void,@1] = valbat_@1_@2;
	"optimized multiplexed left-scalar @2 on [void,@1] BAT"
.COMMAND "[@2]" (BAT[void,@1],@1) : BAT[void,@1] = batval_@1_@2;
	"optimized multiplexed right-scalar @2 on [void,@1] BAT"

@m
@:unarysignatures(dbl,exp)@
@:unarysignatures(dbl,log)@
@:unarysignatures(dbl,sqrt)@

@:binarysignatures(dbl,pow)@

.END bat_arith;

@* Implementation
@c
#include "monetdb4_config.h"
#include <gdk.h>
#include <gdk_scanselect.h>	/* for type-specific HT_bunfastins_nocheck_noinc(), until they're moved to gdk.mx */
#include "bat_arith.proto.h"
#include "bat_mmath.proto.h"

#include <math.h>

@c
/*
	implementation
	@1:	dbl			arithmetic type
	@2:	unary:  exp, log, sqrt 	mathematical function
	   	binary: pow            	mathematical function
*/
@= unaryimplementations
int
bat_@1_@2(BAT **ret, BAT *b)
{
	@1 *bp, *bq;
	@1 *bnp;
	BAT *bn;

        ALGODEBUG THRprintf(GDKout, "bat_@1_@2(b=%s);\n",BATgetId(b));
 	ERRORcheck((b->htype!=TYPE_void),
 	           "bat_@1_@2: BAT b must be void-headed.\n");
	/* todo for commutative operators call batval (ie. for * and /) */

	bn = BATnew(TYPE_void, b->ttype, BATcount(b));
	BATseqbase(bn,b->hseqbase);
	bn->tsorted = 0;
	bq = (@1*)Tloc(b,BUNlast(b));
	bp = (@1*)Tloc(b,BUNfirst(b));
	bnp = (@1*)Tloc(bn,BUNlast(bn));
	for (; bp < bq; bp++) {
		@1 bv = *(@1*)bp;
		int nonil = (bv != @1_nil); 

		bn->T->nonil &= nonil;
		if (nonil) 
			bv = @2(bv);
		*bnp++ = bv;
	}
        BATsetcount(bn, ((char*)bnp - bn->T->heap.base)/Tsize(bn));
        if (!bn->batDirty) bn->batDirty = TRUE;

        *ret = bn;
        return GDK_SUCCEED;
}

@= binaryimplementations
int
batbat_@1_@2(BAT **ret, BAT *l, BAT *r)
{
	@1 *bnp, *lp, *lq, *rp;
	BAT *bn;

        ALGODEBUG THRprintf(GDKout, "batbat_@1_@2(l=%s,r=%s);\n",BATgetId(l),BATgetId(r));
 	ERRORcheck((l->htype!=TYPE_void)||(r->htype!=TYPE_void)||(l->hseqbase!=r->hseqbase)||(BATcount(l)!=BATcount(r)),
 	           "batbat_@1_@2: BATs l & r must be void-headed and head-aligned.\n");

	bn = BATnew(TYPE_void, l->ttype, BATcount(l));
	BATseqbase(bn,l->hseqbase);
	bn->tsorted = 0;

	lq = (@1*)Tloc(l,BUNlast(l));
	lp = (@1*)Tloc(l,BUNfirst(l));
	rp = (@1*)Tloc(r,BUNfirst(r));
	bnp = (@1*)Tloc(bn,BUNlast(bn));
	for (; lp < lq; lp++, rp++) {
		if ((*lp != @1_nil) && (*rp != @1_nil)) {
			*bnp = @2(*lp, *rp);
		} else {
			*bnp = @1_nil;
			bn->T->nonil = 0;
		}
		bnp++;
	}

        BATsetcount(bn, ((char*)bnp - bn->T->heap.base)/Tsize(bn));
        if (!bn->batDirty) bn->batDirty = TRUE;

        *ret = bn;
        return GDK_SUCCEED;
}
int
valbat_@1_@2(BAT **ret, @1 *v, BAT *b)
{
	@1 *bp, *bq, *bnp;
	@1 vv = (((*v)!=@1_nil)?(*v):@1_nil);
	BAT *bn;

        ALGODEBUG THRprintf(GDKout, "valbat_@1_@2(v,b=%s);\n",BATgetId(b));
 	ERRORcheck((b->htype!=TYPE_void),
 	           "valbat_@1_@2: BAT b must be void-headed.\n");
	/* todo for commutative operators call batval (ie. for * and /) */

	bn = BATnew(TYPE_void, b->ttype, BATcount(b));
	BATseqbase(bn,b->hseqbase);
	bn->tsorted = 0;
	bq = (@1*)Tloc(b,BUNlast(b));
	bp = (@1*)Tloc(b,BUNfirst(b));
	bnp = (@1*)Tloc(bn,BUNlast(bn));
	if (vv != @1_nil) {
		for (; bp < bq; bp++) {
			@1 bv = *(@1*)bp;
			if (bv != @1_nil) {
				bv = @2(vv,bv);
			}
			*bnp = bv;
			bnp++;
		}
	} else {
		for (; bp < bq; bp++) {
			*bnp = vv;
			bnp++;
		}
	}
        BATsetcount(bn, ((char*)bnp - bn->T->heap.base)/Tsize(bn));
        if (!bn->batDirty) bn->batDirty = TRUE;

        *ret = bn;
        return GDK_SUCCEED;
}
int
batval_@1_@2(BAT **ret, BAT *b, @1 *v)
{
	@1 *bp, *bq, *bnp;
	@1 vv = (((*v)!=@1_nil)?(*v):@1_nil);
	BAT *bn;

        ALGODEBUG THRprintf(GDKout, "batval_@1_@2(v,b=%s);\n",BATgetId(b));
 	ERRORcheck((b->htype!=TYPE_void),
 	           "batval_@1_@2: BAT b must be void-headed.\n");

	bn = BATnew(TYPE_void, b->ttype, BATcount(b));
	BATseqbase(bn,b->hseqbase);
	bn->tsorted = 0;
	bq = (@1*)Tloc(b,BUNlast(b));
	bp = (@1*)Tloc(b,BUNfirst(b));
	bnp = (@1*)Tloc(bn,BUNlast(bn));
	if (vv != @1_nil) {
		for (; bp < bq; bp++) {
			@1 bv = *(@1*)bp;
			if (bv != @1_nil) {
				bv = @2(bv,vv);
			}
			*bnp = bv;
			bnp++;
		}
	} else {
		for (; bp < bq; bp++) {
			*bnp = vv;
			bnp++;
		}
	}
        BATsetcount(bn, ((char*)bnp - bn->T->heap.base)/Tsize(bn));
        if (!bn->batDirty) bn->batDirty = TRUE;

        *ret = bn;
        return GDK_SUCCEED;
}
@c

@:unaryimplementations(dbl,exp)@
@:unaryimplementations(dbl,log)@
@:unaryimplementations(dbl,sqrt)@

@:binaryimplementations(dbl,pow)@
