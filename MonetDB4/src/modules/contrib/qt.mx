@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
@' Copyright August 2008-2010 MonetDB B.V.
@' All Rights Reserved.

@f qt
@t Quad-tree ops.
@a Peter Bosch
@v 1.0
@* Introduction

The module qt is used for searching spots in the quad trees.  The interface
is such that one first downloads the spot into the module.  A spot is 
defined by three tables: (ID, H), (ID, S), and (ID, V).  It is assumed that
if an ID is present in the H table, it is also present in the S and V table.
Once the spot is downloaded, this module determines the geometrical center
of the spot and it stores it in a local data structure.  A reference to
this data structure is returned to the user.  Next, the user can query
image quad trees with the spot by presenting (ID, H), (ID, S) and (ID, V) 
tables od the image to this module and the spot reference.  The module 
matches the spot cross to the quad tree and it returns a BAT with the 
IDs of the matches.  The matches are grouped by a matchid, which is stored 
in the head of the resulting table; the tail contains the matching IDs.

@* Module Definition 
@m
.MODULE qt;

.USE uchr;
.USE bitvector;
.USE stats;

.COMMAND [qt_makecross](BAT[int,uchr] qt_hue, BAT[int,uchr] qt_sat,
			BAT[int,uchr] qt_val, int c_space):
  int = qt_makecross;
 "Construct a cross from a spot quad tree.  When IR space is set, the 
  cross is stored in IR color space."

.COMMAND [qt_delcross](int crossid) = qt_delcross;
 "Delete a cross."

.COMMAND [qt_match](int crossid, oid image_oid, 
		    BAT[void,oid] qt_ioffs, BAT[void,int] qt_inum,
		    BAT[void,int] qt_id, BAT[void,uchr] qt_hue, 
		    BAT[void,uchr] qt_sat, BAT[void,uchr] qt_val,
		    BAT[oid,oid] r_images, BAT[oid,int] r_nc,
		    BAT[oid,int] r_ids, int cspace,
		    flt fraction) = qt_match;
 "Look for a matching color cross, which is described by the cross 
  referenced by crossid, in the ID, H, S, and V table.  The requested quad
  tree is presented in the tables qt_ioffs and qt_inum (offset and number
  of features, respectively) at entry image_oid.  Fill in the r_* BATS
  with matching images, number of colors and the IDs of the matched
  features, respectively if more than or equal to the number of different
  colors from the spot time the fraction match in the image."

.COMMAND [qt_ir_cluster](BAT[void,oid] qt_ioffs, BAT[void,int] qt_inum,
			 BAT[void,int] qt_id, BAT[void,uchr] qt_hue, 
			 BAT[void,uchr] qt_sat, BAT[void,uchr] qt_val,
			 int persist) = qt_ir_cluster;
 "Cluster all images in a set of bit vectors with 3 color transitions in
  the Itten-Runge color space.  The clusters themselves are named 
  IR_[N|W]_C0_C1_C2"

.COMMAND [qt_pre_select](int crossid, int cspace, wrd nimages): 
                         BAT[oid,oid] = qt_pre_select;
 "Select images that _may_ satisfy the cross's color transitions"

.COMMAND [qt_cross_pre_select](int crossid, int cspace, wrd nimages): 
                               BAT[oid,oid] = qt_cross_pre_select;
 "Select images that _may_ satisfy the cross's color transitions"

.COMMAND [qt_debug](int debug) = qt_debug;
 "Set debuging on/off"

.COMMAND [qt_stats](int mode, str outfile) = qt_stats;
 "Control statistics output"

.PRELUDE = qt_prelude;
.EPILOGUE = qt_epilogue;

.END qt;

@{
@* Implementation
@c
#include "monetdb4_config.h"
#include <gdk.h>
#include <math.h>
#ifdef HAVE_UNISTD_H
# include <unistd.h>
#endif
#ifdef HAVE_IO_H
# include <io.h>
#endif
#include <uchr.h>
#include <bitvector.proto.h>
#include <stats.proto.h>
#include <qt.proto.h>
#ifdef HAVE_FTIME
#include <sys/timeb.h>
#endif

#define HUEBINS		256
#define GREYSAT		((256 * 20) / 100)
#define GREYBINS	16
#define NUMBINS		(HUEBINS + GREYBINS)

#define ITTEN_RUNGE_HUE_BINS	  12
#define ITTEN_RUNGE_GREY_BINS	  4
#define HUES_PER_ITTEN_RUNGE_BIN  ((double)HUEBINS/ITTEN_RUNGE_HUE_BINS)
#define GREYS_PER_ITTEN_RUNGE_BIN ((double)GREYBINS/ITTEN_RUNGE_GREY_BINS)
#define NIRBINS	(ITTEN_RUNGE_HUE_BINS + ITTEN_RUNGE_GREY_BINS)

#define QTE_VALID	0x80000000
#define QTE_MASK	0x0000FFFF

#ifndef min
#define min(a, b)	(((a) < (b))? (a): (b))
#endif
#ifndef max
#define max(a, b)	(((a) > (b))? (a): (b))
#endif

#define isgrey(sat)	((sat) <= GREYSAT)
#define NS(x)		((Time)(x))
#define US(x)		(NS(x) * LL_CONSTANT(1000))
#define MS(x)		(US(x) * LL_CONSTANT(1000))
#define S(x)		(MS(x) * LL_CONSTANT(1000))

typedef enum {
	N = 0, NE = 1, E = 2, SE = 3, S = 4, SW = 5, W = 6, NW = 7, Parent = 8
} direction_t;

#define COLORSPACE_H_256	0
#define COLORSPACE_IR_12	1

typedef enum {
	ColorSpace_H_256 = COLORSPACE_H_256,
	ColorSpace_IR_12 = COLORSPACE_IR_12
} colorspace_t;

typedef gdk_int64 Time;

static direction_t opposite[] = { S, SW, W, NW, N, NE, E, SE, Parent };

/* Spot management */
typedef struct {
	int *c_hstring;		/* The horizontal color string */
	int c_hlength;		/* Length of horizontal color string */
	int c_hcenter;		/* Horizontal center */
	int *c_vstring;		/* The horizontal color string */
	int c_vlength;		/* Length of horizontal color string */
	int c_vcenter;		/* Vertical center */
	int c_refs;		/* Number of refs */
	colorspace_t c_cspace;	/* Used color space */
	int c_crossid;		/* Assigned cross ID */
	gdk_uint32 *c_spot;	/* The real spot */
	int c_spot_w;		/* Spot width */
	int c_spot_h;		/* Spot height */
} cross_t;

#define NCROSSES	100
static cross_t crosses[NCROSSES];	/* The crosses themselves */
static int crossuniq;		/* Unique cross ID */

/* ID managament */

#define NLEVELS		10
typedef int zid_t;

typedef struct {
	int id_x;		/* x-position */
	int id_y;		/* y-position */
} idtoxy_t;

typedef struct {
	zid_t lvl_sid;		/* Starting ID */
	int lvl_nid;		/* Number of IDs at this level */
	int lvl_nid_dir;	/* SQRT of lvl_nid */
	idtoxy_t *lvl_idtoxy;	/* ID to X, Y conversion */
	zid_t *lvl_xytoid;	/* X, Y to ID conversion */
} qtlevel_t;

static int nlevels = NLEVELS;
static qtlevel_t *levels;
static BAT *ir_nclusters[NIRBINS * NIRBINS * NIRBINS];
static BAT *ir_wclusters[NIRBINS * NIRBINS * NIRBINS];

static MT_Lock qt_lock;
static int gband = 1;
static int hband = 1;
static int debug = 1;

static zid_t neighbor(direction_t direction, zid_t id);
static zid_t up(zid_t id);
static void match(direction_t direction, gdk_int16 *features, zid_t id, int *cstring, int cindex, int clength, BAT *r_ids, oid soid, int *ncolors);
static int get_color(gdk_uint32 hsv, colorspace_t cspace);
static int get_nfeatures(zid_t lastid);
static int same_color(int c1, int c2);
static int idlevel(zid_t id);
static int cluster(direction_t dir, BAT **clusters, wrd image, gdk_int16 *quadtree, int id);
static int convert_to_itten_runge_bin(int color);
static void publish(BAT **clusters, int c0, int c1, int c2, wrd image);

static ptr st_search;		/* Time to search quad trees */
static ptr st_bunins[3];	/* Time to perform a BUNins */

static Time
now(void)
{
#ifdef HAVE_GETTIMEOFDAY
	struct timeval tv;

	if (gettimeofday(&tv, NULL) < 0) {
		fprintf(stderr, "now: cannot get time of day: %s\n", strerror(errno));
		exit(1);
	}
	return S(tv.tv_sec) + US(tv.tv_usec);
#else
#ifdef HAVE_FTIME
	struct timeb tb;

	ftime(&tb);
	return S(tb.time) + MS(tb.millitm);
#endif
#endif
}

bat *
qt_prelude(void)
{
	zid_t lid;
	int n;

	MT_init_lock(qt_lock, "qt_lock");

	levels = (qtlevel_t *) GDKmalloc(nlevels * sizeof(qtlevel_t));
	assert(levels);

	for (lid = n = 0; n != nlevels; n++) {
		levels[n].lvl_sid = lid;
		levels[n].lvl_nid_dir = (zid_t) pow(2., (double) n);
		levels[n].lvl_nid = (zid_t) pow(4., (double) n);
		lid += levels[n].lvl_nid;
		levels[n].lvl_idtoxy = (idtoxy_t *) GDKmalloc(levels[n].lvl_nid * sizeof(idtoxy_t));
		assert(levels[n].lvl_idtoxy);
		levels[n].lvl_xytoid = (zid_t *) GDKmalloc(levels[n].lvl_nid * sizeof(zid_t));
		assert(levels[n].lvl_xytoid);

		if (n == 0) {
			levels[n].lvl_idtoxy[0].id_x = 0;
			levels[n].lvl_idtoxy[0].id_y = 0;
			levels[n].lvl_xytoid[0] = 0;
		} else {
			int nbits, j;

			nbits = 2 * n;
			for (j = 0; j != levels[n].lvl_nid; j++) {
				idtoxy_t *idtoxy;
				int b;

				idtoxy = &levels[n].lvl_idtoxy[j];
				idtoxy->id_x = idtoxy->id_y = 0;

				for (b = nbits - 1; b >= 0; b--) {
					int flag;

					flag = (j >> b) & 1;

					if (b % 2)
						idtoxy->id_y = (idtoxy->id_y << 1) | flag;

					else
						idtoxy->id_x = (idtoxy->id_x << 1) | flag;
				}

				levels[n].lvl_xytoid[idtoxy->id_y * levels[n].lvl_nid_dir + idtoxy->id_x] = j;
			}
		}
	}
/*
  for (n = 0; n != nlevels; n++) {
	int m;
	for (m = 0; m != levels[n].lvl_nid; m++)
	  printf("%d %d (%d,%d) %d\n", 
		n,
		levels[n].lvl_nid_dir,
		levels[n].lvl_idtoxy[m].id_x,
		levels[n].lvl_idtoxy[m].id_y,
		levels[n].lvl_sid + levels[n].lvl_xytoid[m]);
  }
*/

	/* Load the clusters from stable storage */
	if ((ir_wclusters[0] = BATload("IR_W_0_0_0")) != NULL) {
		int failed;

		printf("[qt_prelude]: Loading clusters from disk\n");
		for (failed = n = 0; n != NIRBINS * NIRBINS * NIRBINS; n++) {
			char cname[128];

			sprintf(cname, "IR_W_%d_%d_%d", n / (NIRBINS * NIRBINS), (n / NIRBINS) % NIRBINS, n % NIRBINS);
			ir_wclusters[n] = BATload(cname);

			sprintf(cname, "IR_N_%d_%d_%d", n / (NIRBINS * NIRBINS), (n / NIRBINS) % NIRBINS, n % NIRBINS);
			ir_nclusters[n] = BATload(cname);

			if (ir_wclusters[n] == NULL || ir_nclusters[n] == NULL) {
				GDKerror("[qt_prelude]: Missing color %d %d %d (W x%X, N x%X), discarding clusters\n", n / (NIRBINS * NIRBINS), (n / NIRBINS) % NIRBINS, n % NIRBINS, ir_wclusters[n], ir_nclusters[n]);
				failed = 1;
			}
		}

		if (failed) {
			printf("[qt_prelude]: Discarding all clusters\n");
			for (n = 0; n != NIRBINS * NIRBINS * NIRBINS; n++) {
				if (ir_wclusters[n])
					BATdelete(ir_wclusters[n]);
				if (ir_nclusters[n])
					BATdelete(ir_nclusters[n]);
			}
			memset(ir_wclusters, 0, NIRBINS * NIRBINS * NIRBINS * sizeof(BAT *));
			memset(ir_nclusters, 0, NIRBINS * NIRBINS * NIRBINS * sizeof(BAT *));
		}
	}

	crossuniq = (int) (now() / S(1));
	return NULL;
}

void
qt_epilogue(void)
{
	int n;

	MT_set_lock(qt_lock, "qt_epilogue");
	for (n = 0; n != NCROSSES; n++)
		if (crosses[n].c_crossid > 0) {
			MT_unset_lock(qt_lock, "qt_epilogue");
			return;
		}
	MT_destroy_lock(qt_lock);

	for (n = 0; n != nlevels; n++) {
		GDKfree(levels[n].lvl_idtoxy);
		GDKfree(levels[n].lvl_xytoid);
	}
	GDKfree(levels);
}

int
qt_makecross(int *crossid, BAT *qt_hue, BAT *qt_sat, BAT *qt_val, int *cspace)
{
	cross_t *c;
	BUN hp, hq, sp, sq, vp, vq, p, q, last;
	int spot_lo_x, spot_lo_y, spot_hi_x, spot_hi_y, spot_w, spot_h;
	int xx, level, lo_level, x, y, wh, lcolor, color, n;
	int hlength, vlength, hcenter = 0, vcenter = 0, *spotids, centerid;
	zid_t id;
	gdk_uint32 *spot;
	int *hstring, *vstring;

	switch (*cspace) {
	case COLORSPACE_H_256:
	case COLORSPACE_IR_12:
		break;
	default:
		GDKerror("[qt_makecross]: Unsupported color space (%d)\n", *cspace);
		return GDK_FAIL;
	}

	(void) BATorder(qt_hue);
	(void) BATorder(qt_sat);
	(void) BATorder(qt_val);

	if (BATcount(qt_hue) == 0) {
		GDKerror("[qt_makecross]: Empty spot?\n");
		return GDK_FAIL;
	}

	if (BATcount(qt_hue) != BATcount(qt_sat) || BATcount(qt_hue) != BATcount(qt_val)) {
		GDKerror("[qt_makecross]: (h) Table sizes " BUNFMT ", " BUNFMT ", " BUNFMT "\n", BATcount(qt_hue), BATcount(qt_sat), BATcount(qt_val));
		return GDK_FAIL;
	}

	/* Check how many levels are available in the spot quad tree and
	   find the bounding box */
	last = BUNlast(qt_hue) - BUNsize(qt_hue);
	if (debug)
		printf("makecross: last ID %d, hue %d\n", (int) *(zid_t *) BUNhead(qt_hue, last), *(int *) BUNtail(qt_hue, last));

	lo_level = idlevel(*(zid_t *) BUNhead(qt_hue, last));
	if (lo_level < 0) {
		GDKerror("[qt_makecross]: Image too deep (last id %d)\n", *(zid_t *) BUNhead(qt_hue, last));
		return GDK_FAIL;
	}

	spot_lo_x = spot_lo_y = spot_hi_x = spot_hi_y = -1;

	BATloopFast(qt_hue, p, q, xx) {
		id = *(zid_t *) BUNhead(qt_hue, p);
		level = idlevel(id);

		assert(level >= 0);

		if (debug)
			printf("makecross: real ID %d\n", (int) id);

		id -=levels[level].lvl_sid;

		wh = (int) pow(2., (double) (lo_level - level));
		if (debug)
			printf("makecross: id %d, wh %d, level %d, lo %d, x %d y %d\n", (int) id, wh, level, lo_level, levels[level].lvl_idtoxy[id].id_x, levels[level].lvl_idtoxy[id].id_y);
		x = levels[level].lvl_idtoxy[id].id_x * wh;
		y = levels[level].lvl_idtoxy[id].id_y * wh;

		if (debug)
			printf("makecross: x %d, y %d, wh %d\n", x, y, wh);

		if (spot_lo_x < 0 || x < spot_lo_x)
			spot_lo_x = x;
		if (spot_lo_y < 0 || y < spot_lo_y)
			spot_lo_y = y;
		if (x + wh > spot_hi_x)
			spot_hi_x = x + wh;
		if (y + wh > spot_hi_y)
			spot_hi_y = y + wh;
		if (debug)
			printf("makecross: spot %d %d %d %d\n", spot_lo_x, spot_lo_y, spot_hi_x, spot_hi_y);
	}

	if (spot_lo_x < 0 || spot_lo_y < 0 || spot_hi_x < 0 || spot_hi_y < 0) {
		GDKerror("[qt_makecross]: Cannot find bounding box\n");
		return GDK_FAIL;
	}

	/* Instantiate the spot in a two-dimensional table */
	spot_w = (spot_hi_x - spot_lo_x) + 1;
	spot_h = (spot_hi_y - spot_lo_y) + 1;
	spot = (gdk_uint32 *) GDKmalloc(spot_w * spot_h * sizeof(gdk_uint32));
	spotids = (int *) GDKmalloc(spot_w * spot_h * sizeof(int));
	assert(spot && spotids);
	memset(spot, 0, spot_w * spot_h * sizeof(gdk_uint32));
	memset(spotids, 0, spot_w * spot_h * sizeof(int));

	if (debug)
		printf("makecross: spot [%d, %d]->[%d, %d]\n", spot_lo_x, spot_lo_y, spot_hi_x, spot_hi_y);

	for (hp = BUNfirst(qt_hue), hq = BUNlast(qt_hue), sp = BUNfirst(qt_sat), sq = BUNlast(qt_sat), vp = BUNfirst(qt_val), vq = BUNlast(qt_val); hp < hq && sp < sq && vp < vq; hp += BUNsize(qt_hue), sp += BUNsize(qt_sat), vp += BUNsize(qt_val)) {
		int _x, _y;
		gdk_uint32 hsv;

		assert(*(int *) BUNhead(qt_hue, hp) == *(int *) BUNhead(qt_sat, sp) && *(int *) BUNhead(qt_hue, hp) == *(int *) BUNhead(qt_val, vp));

		id = *(zid_t *) BUNhead(qt_hue, hp);
		level = idlevel(id);

		assert(level >= 0);

		id -=levels[level].lvl_sid;

		wh = (int) pow(2., (double) (lo_level - level));
		x = levels[level].lvl_idtoxy[id].id_x * wh;
		y = levels[level].lvl_idtoxy[id].id_y * wh;

		hsv = QTE_VALID | (*(gdk_uint8 *) BUNtail(qt_hue, hp) << 16) | (*(gdk_uint8 *) BUNtail(qt_sat, sp) << 8) | *(gdk_uint8 *) BUNtail(qt_val, vp);

		for (_y = y - spot_lo_y; _y != y + wh - spot_lo_y; _y++)
			for (_x = x - spot_lo_x; _x != x + wh - spot_lo_x; _x++) {
				spot[_y * spot_w + _x] = hsv;
				spotids[_y * spot_w + _x] = id +levels[level].lvl_sid;
			}
	}

	/* Search for another center point when the center is not valid */
	assert(spot[(spot_w / 2) * spot_w + spot_w / 2] & QTE_VALID);
	centerid = spotids[(spot_h / 2) * spot_w + spot_w / 2];

	if (debug)
		printf("makecross: centerid %d\n", centerid);

	if (1 || debug) {
		printf("spot_h %d, spot_w %d\n", spot_h, spot_w);
		for (y = 0; y != spot_h; y++) {
			lcolor = -1;
			printf("[y %d]: ", y);
			for (x = 0; x != spot_w; x++)
				if (spot[y * spot_w + x] & QTE_VALID) {
					color = get_color(spot[y * spot_w + x], ColorSpace_IR_12);
					if (color !=lcolor)
						printf("%d ", color);
					lcolor = color;
				}
			printf("\n");
		}
	}

	hstring = (int *) GDKmalloc(spot_w * sizeof(int));
	vstring = (int *) GDKmalloc(spot_h * sizeof(int));
	assert(hstring && vstring);
	memset(hstring, 0, spot_w * sizeof(int));
	memset(vstring, 0, spot_h * sizeof(int));

	if (1 || debug)
		printf("makecross: horizontal transitions: ");

	for (lcolor = -1, hlength = x = 0; x != spot_w; x++) {
		if (x == spot_w / 2)
			hcenter = hlength;
		if (spot[(spot_h / 2) * spot_w + x] & QTE_VALID) {

			color = get_color(spot[(spot_h / 2) * spot_w + x],
					  (colorspace_t) *cspace);

			if (lcolor < 0 || color !=lcolor) {
				lcolor = hstring[hlength++] = color;

				if (1 || debug)
					printf("(%d)", color);
			}

			if (spotids[(spot_h / 2) * spot_w + x] == centerid)
				hcenter = hlength - 1;
		}
	}

	if (1 || debug)
		printf("\nmakecross: vertical transitions: ");
	for (lcolor = -1, vlength = y = 0; y != spot_h; y++) {
		if (y == spot_h / 2)
			vcenter = vlength;
		if (spot[y * spot_w + (spot_w / 2)] & QTE_VALID) {

			color = get_color(spot[y * spot_w + (spot_w / 2)],
					  (colorspace_t) *cspace);

			if (lcolor < 0 || color !=lcolor) {
				lcolor = vstring[vlength++] = color;

				if (1 || debug)
					printf("(%d)", color);
			}

			if (spotids[y * spot_w + (spot_w / 2)] == centerid)
				vcenter = vlength - 1;
		}
	}
	if (1 || debug)
		printf("\n");

	/* Now we have all the variables we need for the spot.  Fill them
	   in a cross data structure. */
	MT_set_lock(qt_lock, "qt_makecross");

	/* Find a free cross */
	for (n = 0; n != NCROSSES; n++)
		if (crosses[n].c_crossid == 0)
			break;

	if (n == NCROSSES) {
		GDKerror("[qt_makecross]: Cannot allocate cross\n");
		GDKfree(spot);
		GDKfree(spotids);
	}
	c = &crosses[n];
	c->c_crossid = crossuniq++;

	MT_unset_lock(qt_lock, "qt_makecross");

	if (debug)
		printf("makecross: hcenter %d, vcenter %d\n", hcenter, vcenter);

	c->c_cspace = (colorspace_t) *cspace;
	c->c_hlength = hlength;
	c->c_hstring = hstring;
	c->c_hcenter = hcenter;
	c->c_vlength = vlength;
	c->c_vstring = vstring;
	c->c_vcenter = vcenter;
	*crossid = c->c_crossid;

	c->c_spot = spot;
	c->c_spot_w = spot_w;
	c->c_spot_h = spot_h;

	GDKfree(spotids);
	return GDK_SUCCEED;
}

int
qt_delcross(int *crossid)
{
	cross_t *c;
	int n;

	MT_set_lock(qt_lock, "qt_delcross");
	for (n = 0; n != NCROSSES; n++)
		if (*crossid == crosses[n].c_crossid)
			break;

	if (n == NCROSSES) {
		MT_unset_lock(qt_lock, "qt_delcross");
		GDKerror("[qt_delcross]: Cross ID %d does not exist\n", *crossid);
		return GDK_FAIL;
	}

	c = &crosses[n];
	if (c->c_refs > 0) {
		MT_unset_lock(qt_lock, "qt_delcross");

		GDKerror("[qt_delcross]: Cross %d busy\n", *crossid);
		return GDK_FAIL;
	}

	GDKfree(c->c_hstring);
	GDKfree(c->c_vstring);
	GDKfree(c->c_spot);
	memset(c, 0, sizeof(cross_t));

	MT_unset_lock(qt_lock, "qt_delcross");
	return GDK_SUCCEED;
}

int
qt_match(int *crossid, oid *ioid, BAT *qt_ioffs, BAT *qt_inum, BAT *qt_id, BAT *qt_hue, BAT *qt_sat, BAT *qt_val, BAT *r_images, BAT *r_ncolors, BAT *r_ids, int *cspace, flt *fraction)
{
	int nfeatures, c_color, i, id_size, hsv_size, noid, rv;
	cross_t *c;
	gdk_int16 *quadtree;
	BUN ip, iq, hp, /*hq, */ sp, /*sq, */ vp /*,vq */ ;
	Time delta;
	zid_t lastid;
	oid soid, _ioid;

	if (st_search)
		delta = now();

	if (debug)
		printf("qt_match: " OIDFMT ", image_oid " OIDFMT "\n", * (oid *) BUNhead(qt_id, BUNfirst(qt_id)), * ioid);

	/* Check the consistency of the tables */
	soid = *(oid *) BUNhead(qt_id, BUNfirst(qt_id));
	if (soid != *(oid *) BUNhead(qt_hue, BUNfirst(qt_hue)) || soid != *(oid *) BUNhead(qt_sat, BUNfirst(qt_sat)) || soid != *(oid *) BUNhead(qt_val, BUNfirst(qt_val))) {
		GDKerror("[qt_match]: Heads differ " OIDFMT " " OIDFMT " " OIDFMT " " OIDFMT "\n", soid, * (oid *) BUNhead(qt_hue, BUNfirst(qt_hue)), * (oid *) BUNhead(qt_sat, BUNfirst(qt_sat)),
			 * (oid *) BUNhead(qt_val, BUNfirst(qt_val)));
		return GDK_FAIL;
	}

	if (BATcount(qt_id) != BATcount(qt_hue) || BATcount(qt_id) != BATcount(qt_sat) || BATcount(qt_id) != BATcount(qt_val)) {
		GDKerror("[qt_match]: Table sizes differ " BUNFMT " " BUNFMT " " BUNFMT " " BUNFMT "\n", BATcount(qt_id), BATcount(qt_hue), BATcount(qt_sat), BATcount(qt_val));
		return GDK_FAIL;
	}

	/* Find the starting oid and the number of features in the quad tree */
	_ioid = *(int *) BUNhead(qt_ioffs, BUNfirst(qt_ioffs));
	if (_ioid != (oid) *(int *) BUNhead(qt_inum, BUNfirst(qt_inum)) || BATcount(qt_ioffs) != BATcount(qt_inum)) {
		GDKerror("[qt_match]: Inconsistent IOFFS/INUM tables " OIDFMT " %d (head), count " BUNFMT " " BUNFMT "\n", _ioid, *(int *) BUNhead(qt_inum, BUNfirst(qt_inum)), BATcount(qt_ioffs), BATcount(qt_inum));
		return GDK_FAIL;
	}

	if (*ioid - _ioid > BATcount(qt_ioffs)) {
		GDKerror("[qt_match]: Image oid " OIDFMT " too large, BATcount " BUNFMT "\n", *ioid - _ioid, BATcount(qt_ioffs));
		return GDK_FAIL;
	}

	soid = *(int *) (BUNfirst(qt_ioffs) + (*ioid - _ioid) * BUNsize(qt_ioffs));
	noid = *(int *) (BUNfirst(qt_inum) + (*ioid - _ioid) * BUNsize(qt_inum));
	id_size = BUNsize(qt_id);
	hsv_size = BUNsize(qt_hue);

	if (debug)
		printf("qt_match: soid " OIDFMT ", noid %d\n", soid, noid);

	/* Make sure the soid and eoid are part of the tables */
	if (noid < 0 || soid >= BATcount(qt_id) || soid + noid > BATcount(qt_id)) {
		GDKerror("[qt_match]: soid " OIDFMT ", eoid " OIDFMT ", table size " BUNFMT "\n", soid, soid + noid, BATcount(qt_id));
		return GDK_FAIL;
	}

	lastid = -1;
	for (ip = BUNfirst(qt_id) + soid * id_size, iq = ip + noid * id_size; ip < iq; ip += id_size) {
		zid_t id = *(zid_t *) BUNtail(qt_id, ip);

		if (lastid < 0 || id >lastid)
			lastid = id;
	}
	assert(lastid >= 0);

	nfeatures = get_nfeatures(lastid);
	if (nfeatures < 0) {
		GDKerror("[qt_match]: Illegal quad tree (id %d too big)\n", *(int *) BUNhead(qt_hue, BUNlast(qt_hue)));
		return GDK_FAIL;
	}

	if (debug)
		printf("qt_match: number of features %d (lastid %d)\n", nfeatures, lastid);

	MT_set_lock(qt_lock, "qt_match");
	for (i = 0; i != NCROSSES; i++)
		if (*crossid == crosses[i].c_crossid)
			break;

	if (i == NCROSSES) {
		GDKerror("[qt_match]: Cross id %d does not exist\n", *crossid);
		MT_unset_lock(qt_lock, "qt_match");
		return GDK_FAIL;
	}

	c = &crosses[i];
	if (c->c_cspace != (colorspace_t) *cspace) {
		GDKerror("[qt_match]: Non matching color space (%d, %d)\n", c->c_cspace, *cspace);
		MT_unset_lock(qt_lock, "qt_match");
		return GDK_FAIL;
	}
	c->c_refs++;
	MT_unset_lock(qt_lock, "qt_match");

	/* construct an in-core version of the quad tree */
	quadtree = (gdk_int16 *) GDKmalloc(nfeatures * sizeof(gdk_int16));
	assert(quadtree);
	memset(quadtree, -1, nfeatures * sizeof(gdk_int16));

	for (ip = BUNfirst(qt_id) + soid * id_size, iq = ip + noid * id_size, hp = BUNfirst(qt_hue) + soid * hsv_size,	/*hq = hp + noid * hsv_size, */
	     sp = BUNfirst(qt_sat) + soid * hsv_size,	/*sq = sp + noid * hsv_size, */
	     vp = BUNfirst(qt_val) + soid * hsv_size /*,vq = vp + noid * hsv_size */ ;
	     ip < iq /* && hp < hq && sp < sq && vp < vq */ ;
	     ip += id_size, hp += hsv_size, sp += hsv_size, vp += hsv_size) {

		quadtree[*(int *) BUNtail(qt_id, ip)] = get_color((*(gdk_uint8 *) BUNtail(qt_hue, hp) << 16) | (*(gdk_uint8 *) BUNtail(qt_sat, sp) << 8) | *(gdk_uint8 *) BUNtail(qt_val, vp), (colorspace_t) *cspace);
	}

	/* process the quad tree and find matches.  start with the cross center */
	c_color = c->c_hstring[c->c_hcenter];

	/* Get the last used oid from the r_images table */
	assert(r_images->hsorted == TRUE);

	if (BATcount(r_images) == 0)
		soid = 0;
	else {
		soid = *(int *) BUNhead(r_images, BUNlast(r_images) - BUNsize(r_images));
		soid++;
	}
	if (debug)
		printf("match: Starting oid " OIDFMT "\n", soid);

	for (i = nfeatures - 1; i >= 0; i--) {
		int ncolors;
		Time t;
		size_t ofree, ocnt;

		if (quadtree[i] < 0)
			continue;
		if (!same_color(c_color, quadtree[i]))
			continue;

		ofree = r_ids->batBuns->free;
		ocnt = r_ids->batCount;
		if (st_bunins[0])
			t = now();
		BUNfastins(r_ids, (ptr) &soid, (ptr) &i);
		if (st_bunins[0]) {
			t = (now() - t) / MS(1);
			stats_add(&st_bunins[0], &t);
		}

		if (debug)
			printf("qt_match: Match in center, ID %d, color %d\n", i, c_color);

		ncolors = 1;
		match(E, quadtree, i, c->c_hstring, c->c_hcenter, c->c_hlength, r_ids, soid, &ncolors);
		match(W, quadtree, i, c->c_hstring, c->c_hcenter, c->c_hlength, r_ids, soid, &ncolors);
		match(N, quadtree, i, c->c_vstring, c->c_vcenter, c->c_vlength, r_ids, soid, &ncolors);
		match(S, quadtree, i, c->c_vstring, c->c_vcenter, c->c_vlength, r_ids, soid, &ncolors);

		if ((float) ncolors >= *fraction * (c->c_hlength + c->c_vlength - 1)) {

			if (st_bunins[1])
				t = now();
			BUNins(r_images, (ptr) &soid, (ptr) ioid, FALSE);
			if (st_bunins[1]) {
				t = (now() - t) / MS(1);
				stats_add(&st_bunins[1], &t);
			}

			if (st_bunins[2])
				t = now();
			BUNins(r_ncolors, (ptr) &soid, (ptr) &ncolors, FALSE);
			if (st_bunins[2]) {
				t = (now() - t) / MS(1);
				stats_add(&st_bunins[2], &t);
			}
			soid++;
		} else {
			/* Delete all matches */
			r_ids->batBuns->free = ofree;
			r_ids->batCount = ocnt;
		}
	}

	GDKfree(quadtree);
	c->c_refs--;
	assert(c->c_refs >= 0);

	if (st_search) {
		delta = (now() - delta) / MS(1);
		rv = stats_add(&st_search, &delta);
		if (rv != GDK_SUCCEED)
			return rv;
	}
	return GDK_SUCCEED;
}

static void
match(direction_t direction, gdk_int16 *features, zid_t id, int *cstring, int cindex, int clength, BAT *r_ids, oid soid, int *ncolors)
{
	int nid, pid, nnid, npid, color, cdelta;
	Time t;

	if (debug)
		printf("match: ID %d, color %d (cindex %d)\n", id, cstring[cindex], cindex);

	switch (direction) {
	case E:
	case S:
		cdelta = 1;
		break;
	case W:
	case N:
		cdelta = -1;
		break;
	default:
		assert("Not implemented direction" == NULL);
		abort();
	}

	/* Find the first neighbor that is colored differently. */
	for (;;) {
		pid = nid = neighbor(direction, id);

		if (pid < 0)
			return;

		if (features[pid] < 0)
			do {
				pid = up(pid);
			} while (pid >= 0 && features[pid] < 0);

		/* There is no next neighbor */
		if (pid < 0 || features[pid] < 0)
			return;

		if (!same_color(features[pid], cstring[cindex]))
			break;

		assert(features[pid] >= 0);
		if (debug)
			printf("match: Adding pid %d to matches\n", pid);

		if (st_bunins[0])
			t = now();
		BUNfastins(r_ids, (ptr) &soid, (ptr) &pid);
		if (st_bunins[0]) {
			t = (now() - t) / MS(1);
			(void) stats_add(&st_bunins[0], &t);
		}
		id = nid;
	}

	/* Find the next color */
	color = cstring[cindex];

	do {
		cindex = cindex + cdelta;
	} while (cindex < clength && cindex >= 0 && same_color(color, cstring[cindex]));

	if (debug)
		printf("match: First ID considered: %d, cindex %d\n", id, cindex);

	/* Feature `id' matched on color entry `cindex'.  Try to match
	   as much as possible in the direction `direction' */
	assert(direction == E || direction == W || direction == N || direction == S);

	while (((direction == E || direction == S) && cindex < clength) || ((direction == W || direction == N) && cindex >= 0)) {

		/* `nid' contains the feature id of the nearest neighbor to id.  It
		   is possible that this feature is not available, so, in case there
		   is no direct neighbor, we find the parent. */
		pid = nid = neighbor(direction, id);

		if (nid < 0)
			return;
		if (features[pid] < 0)
			do {
				pid = up(pid);
			} while (pid >= 0 && features[pid] < 0);

		if (debug)
			printf("match: Neighbor(%d) = %d, parent %d\n", id, nid, pid);

		/* When there is still no neighbor (either direct or through the parent),
		   we bail out. */
		if (pid < 0 || features[pid] < 0)
			return;

		/* There is a neighbor now, bail out if the color does not match
		   (but first check higher levels!!!) */

		if (debug)
			printf("match: Color %d %d (matching on %d)\n", pid, features[pid], cstring[cindex]);

		if (!same_color(features[pid], cstring[cindex])) {
			/* Do not match at higher layers -- such a QT intersection would
			   never be visible */
			return;
#ifdef notdef
			do {
				pid = up(pid);
				if (debug)
					printf("match: Going up, new pid %d (color %d, looking for %d)\n", pid, (pid >= 0 && features[pid] >= 0) ? features[pid] : -1, cstring[cindex]);
			} while (pid >= 0 && (features[pid] < 0 || !same_color(features[pid], cstring[cindex])));

			if (debug)
				printf("match: Went up, pid %d, color %d\n", pid, (pid >= 0 && features[pid] >= 0) ? features[pid] : -1);

			if (pid < 0 || features[pid] < 0 || !same_color(features[pid], cstring[cindex])) {
				if (debug)
					printf("match: No match found (with skip)\n");
				return;
			}

			/* We have found a color match at a higher level.  Proceed at that
			   higher level (i.e. don't go back down!) */
			nid = pid;
			BUNfastins(r_ids, (ptr) &soid, (ptr) &pid);
			(*ncolors)++;
			return;
#endif
		}

		assert(features[pid] >= 0);
		if (debug)
			printf("match: (2) Adding pid %d to matches\n", pid);

		if (st_bunins[0])
			t = now();
		BUNfastins(r_ids, (ptr) &soid, (ptr) &pid);
		if (st_bunins[0]) {
			t = (now() - t) / MS(1);
			(void) stats_add(&st_bunins[0], &t);
		}

		(*ncolors)++;

		/* Find the first neighbor that is colored differently. */
		for (;;) {
			npid = nnid = neighbor(direction, nid);
			if (npid < 0)
				return;
			if (features[npid] < 0)
				do {
					npid = up(npid);
				} while (npid >= 0 && features[npid] < 0);

			if (debug)
				printf("match: Trying to find matching neighbors: nid %d, nnid %d, npid %d, color %d\n", nid, nnid, npid, (npid >= 0 && features[npid] >= 0) ? features[npid] : -1);

			/* There is no next neighbor */
			if (npid < 0 || features[npid] < 0)
				return;

			if (!same_color(features[npid], cstring[cindex]))
				break;

			nid = nnid;
			assert(features[npid] >= 0);
			if (debug)
				printf("match: (3) Adding pid %d to matches\n", npid);

			if (st_bunins[0])
				t = now();
			BUNfastins(r_ids, (ptr) &soid, (ptr) &npid);
			if (st_bunins[0]) {
				t = (now() - t) / MS(1);
				(void) stats_add(&st_bunins[0], &t);
			}
		}

		/* We have matched a color, proceed to the next one. */
		color = cstring[cindex];

		do {
			cindex = cindex + cdelta;
		} while (cindex < clength && cindex >= 0 && same_color(color, cstring[cindex]));

		if (debug)
			printf("match: Proceeding with id %d (cindex %d, num %d)\n", nid, cindex, clength);
		id = nid;
	}
	if (debug)
		printf("match: done\n");
}

int
qt_ir_cluster(BAT *qt_ioffs, BAT *qt_inum, BAT *qt_id, BAT *qt_hue, BAT *qt_sat, BAT *qt_val, int *persist)
{
	int n, nfeatures, id_size, hsv_size;
	wrd nimages;
	gdk_int16 *quadtree;
	BUN inum_p, inum_q, ioffs_p, ioffs_q, ip, iq, hp, /*hq, */ sp, /*sq, */ vp /*,vq */ ;

	/* Validity checks */
	if (BATcount(qt_ioffs) != BATcount(qt_inum) || BATcount(qt_id) != BATcount(qt_hue) || BATcount(qt_id) != BATcount(qt_sat) || BATcount(qt_id) != BATcount(qt_val)) {
		GDKerror("[qt_ir_cluster]: Table sizes differ " BUNFMT " " BUNFMT " " BUNFMT " " BUNFMT " " BUNFMT " " BUNFMT "\n", BATcount(qt_inum), BATcount(qt_ioffs), BATcount(qt_id), BATcount(qt_hue), BATcount(qt_sat), BATcount(qt_val));
		return GDK_FAIL;
	}

	nimages = (wrd) BATcount(qt_inum);
	for (n = 0; n != NIRBINS * NIRBINS * NIRBINS; n++) {
		char cname[128];
		bit initial;

		/* Remove old clusters, if any */
		if (ir_nclusters[n])
			BBPreclaim(ir_nclusters[n]);
		if (ir_wclusters[n])
			BBPreclaim(ir_wclusters[n]);

		initial = 0;
		if (bitvector_allocate(&ir_wclusters[n], &nimages, &initial) != GDK_SUCCEED) {
			GDKerror("[qt_ir_cluster]: Cannot create bit vector\n");
			return GDK_FAIL;
		}
		sprintf(cname, "IR_W_%d_%d_%d", n / (NIRBINS * NIRBINS), (n / NIRBINS) % NIRBINS, n % NIRBINS);
		(void) BATrename(ir_wclusters[n], cname);

		if (bitvector_allocate(&ir_nclusters[n], &nimages, &initial) != GDK_SUCCEED) {
			GDKerror("[qt_ir_cluster]: Cannot create bit vector\n");
			return GDK_FAIL;
		}
		sprintf(cname, "IR_N_%d_%d_%d", n / (NIRBINS * NIRBINS), (n / NIRBINS) % NIRBINS, n % NIRBINS);
		(void) BATrename(ir_nclusters[n], cname);
	}

	nfeatures = levels[NLEVELS - 1].lvl_sid + levels[NLEVELS - 1].lvl_nid;
	quadtree = (gdk_int16 *) GDKmalloc(nfeatures * sizeof(gdk_int16));
	assert(quadtree);

	/* Go over all images in the set, materialize them in an in-core 
	   quad tree and find all three-color transitions */
	id_size = BUNsize(qt_id);
	hsv_size = BUNsize(qt_hue);
	printf("id_size %d, hsv_size %d\n", id_size, hsv_size);
	for (inum_p = BUNfirst(qt_inum), inum_q = BUNlast(qt_inum), ioffs_p = BUNfirst(qt_ioffs), ioffs_q = BUNlast(qt_ioffs); inum_p < inum_q && ioffs_p < ioffs_q; inum_p += BUNsize(qt_inum), ioffs_p += BUNsize(qt_ioffs)) {
		int inum, ioffs, id, maxid;
		wrd image;

		if (*BUNhead(qt_inum, inum_p) != *BUNhead(qt_ioffs, ioffs_p)) {
			GDKerror("[qt_ir_cluster]: INUM/IOFFS heads differ %d %d\n", *BUNhead(qt_inum, inum_p), *BUNhead(qt_ioffs, ioffs_p));
			GDKfree(quadtree);
			return GDK_FAIL;
		}

		image = (wrd) ((inum_p - BUNfirst(qt_inum)) / BUNsize(qt_inum));
		ioffs = *(int *) BUNtail(qt_ioffs, ioffs_p);
		inum = *(int *) BUNtail(qt_inum, inum_p);

		printf("Clustering image " SSZFMT ", ioffs %d, inum %d\n", (ssize_t) image, ioffs, inum);

		/* Materialize the quad tree */
		memset(quadtree, -1, nfeatures * sizeof(gdk_int16));

		maxid = -1;
		for (ip = BUNfirst(qt_id) + ioffs * id_size, iq = BUNfirst(qt_id) + (ioffs + inum) * id_size, hp = BUNfirst(qt_hue) + ioffs * hsv_size,
		     /* hq = BUNfirst(qt_hue) + (ioffs + inum) * hsv_size, */
		     sp = BUNfirst(qt_sat) + ioffs * hsv_size,
		     /* sq = BUNfirst(qt_sat) + (ioffs + inum) * hsv_size, */
		     vp = BUNfirst(qt_val) + ioffs * hsv_size
		     /* ,vq = BUNfirst(qt_val) + (ioffs + inum) * hsv_size */ ;
		     ip < iq /* && hp < hq && sp < sq && vp < vq */ ;
		     ip += id_size, hp += hsv_size, sp += hsv_size, vp += hsv_size) {

			id = *(int *) BUNtail(qt_id, ip);
			quadtree[id] = get_color((*(gdk_uint8 *) BUNtail(qt_hue, hp) << 16) | (*(gdk_uint8 *) BUNtail(qt_sat, sp) << 8) | *(gdk_uint8 *) BUNtail(qt_val, vp), ColorSpace_IR_12);

			if (maxid < 0 || id >maxid)
				maxid = id;
		}

		if (cluster(E, ir_wclusters, image, quadtree, maxid) != GDK_SUCCEED ||
		    cluster(N, ir_nclusters, image, quadtree, maxid) != GDK_SUCCEED) {
			GDKfree(quadtree);
			return GDK_FAIL;
		}
	}
	GDKfree(quadtree);

	/* Make the clusters permanent and commit them */
	if (*persist)
		for (n = 0; n != NIRBINS * NIRBINS * NIRBINS; n++) {
			(void) BATmode(ir_wclusters[n], PERSISTENT);
			(void) BATsave(ir_wclusters[n]);
			(void) BATmode(ir_nclusters[n], PERSISTENT);
			(void) BATsave(ir_nclusters[n]);
		}
	return GDK_SUCCEED;
}

static int
cluster(direction_t direction, BAT **clusters, wrd image, gdk_int16 *quadtree, int id)
{
	/* Find all three color transitions in the quad tree */
	for (; id >=0; id --) {
		gdk_int16 c[3];
		zid_t nid, pid;

		if (quadtree[id] == -1)
			continue;
		c[1] = quadtree[id];

		/* Proceed in one direction until we find a different color */
		nid = id;

		do {
			pid = nid = neighbor(direction, nid);
			if (pid >= 0 && quadtree[pid] < 0)
				do {
					pid = up(pid);
				} while (pid >= 0 && quadtree[pid] < 0);
		} while (pid >= 0 && quadtree[pid] == c[1]);

		c[0] = (pid < 0) ? -1 : quadtree[pid];

		/* Proceed in the other direction */
		nid = id;

		do {
			pid = nid = neighbor(opposite[direction], nid);
			if (pid >= 0 && quadtree[pid] < 0)
				do {
					pid = up(pid);
				} while (pid >= 0 && quadtree[pid] < 0);
		} while (pid >= 0 && quadtree[pid] == c[1]);

		c[2] = (pid < 0) ? -1 : quadtree[pid];

		if (c[0] < 0 && c[2] < 0)
			publish(clusters, c[1], c[1], c[1], image);
		else if (c[0] < 0) {
			publish(clusters, c[1], c[1], c[2], image);
			publish(clusters, c[1], c[2], c[2], image);
		} else if (c[2] < 0) {
			publish(clusters, c[0], c[1], c[1], image);
			publish(clusters, c[0], c[0], c[1], image);
		} else
			publish(clusters, c[0], c[1], c[2], image);
	}
	return GDK_SUCCEED;
}

static void
publish(BAT **clusters, int c0, int c1, int c2, wrd image)
{
	int rv;

	rv = bitvector_set(clusters[c0 * NIRBINS * NIRBINS + c1 * NIRBINS + c2], &image);
	assert(rv == GDK_SUCCEED);
	(void) rv;	/* fake usage to fool compilers in case assertions are disabled */
}

int
qt_cross_pre_select(BAT **candidates, int *crossid, int *cspace, wrd *nimages)
{
	int n, rv;
	wrd nbits;
	cross_t *c;
	BAT *bv, *_bv, *bv_cluster;
	bit initial;

	printf("qt_cross_pre_select: Preselecting images\n");
	MT_set_lock(qt_lock, "qt_cross_pre_select");
	for (n = 0; n != NCROSSES; n++)
		if (crosses[n].c_crossid == *crossid)
			break;
	if (n == NCROSSES) {
		GDKerror("[qt_cross_pre_select]: Cannot find cross %d\n", *crossid);
		MT_unset_lock(qt_lock, "qt_cross_pre_select");
		return GDK_FAIL;
	}
	c = &crosses[n];
	c->c_refs++;
	MT_unset_lock(qt_lock, "qt_cross_pre_select");

	printf("qt_cross_pre_select: allocating bitvector " SSZFMT "\n", (ssize_t) *nimages);
	/* Analyze the spot and select the right bit-fields.  Allocate an 
	   empty result bit field with all images selected */
	initial = 1;
	if (bitvector_allocate(&bv, nimages, &initial) != GDK_SUCCEED) {
		GDKerror("[qt_cross_pre_select]: Cannot allocate empty bit vector of size " SSZFMT "\n", (ssize_t) *nimages);
		c->c_refs--;
		return GDK_FAIL;
	}

	bitvector_count(&nbits, bv);
	printf("qt_cross_pre_select: nimages " SSZFMT "\n", (ssize_t) nbits);

	if (*cspace != (int) ColorSpace_IR_12 || (int) c->c_cspace != *cspace || ir_wclusters[0] == NULL) {

		printf("qt_cross_pre_select: No cache?\n");

		/* No candidates, all images are candidates */
		GDKwarning("qt_cross_pre_select: Warning: no cache\n");

		rv = bitvector_decode(candidates, bv);
		BATdelete(bv);
		c->c_refs--;
		return rv;
	}

	if (debug)
		bitvector_print(bv);
	/* For the horizontal colors ... */
	for (n = c->c_hlength - 1; n >= 2; n--) {
		bv_cluster = ir_wclusters[c->c_hstring[n] * NIRBINS * NIRBINS + c->c_hstring[n - 1] * NIRBINS + c->c_hstring[n - 2]];
		if (bitvector_and(&_bv, bv, bv_cluster) != GDK_SUCCEED) {
			c->c_refs--;
			return GDK_FAIL;
		}
		BATdelete(bv);
		bv = _bv;

		if (1) {
			bitvector_count(&nbits, bv);
			printf("qt_cross_pre_select: (horizontal n %d) nimages " SSZFMT "\n", n, (ssize_t) nbits);
		}
	}

	/* ... and for the vertical colors.  Note that I don't do anything
	   special for short color strings.  The reason is that since all 
	   images have been preselected (see allocate), only false positives
	   may be selected extra. */
	for (n = c->c_vlength - 1; n >= 2; n--) {
		bv_cluster = ir_nclusters[c->c_vstring[n] * NIRBINS * NIRBINS + c->c_vstring[n - 1] * NIRBINS + c->c_vstring[n - 2]];
		if (bitvector_and(&_bv, bv, bv_cluster) != GDK_SUCCEED) {
			c->c_refs--;
			return GDK_FAIL;
		}
		BATdelete(bv);
		bv = _bv;

		if (1) {
			bitvector_count(&nbits, bv);
			printf("qt_cross_pre_select: (vertical n %d) nimages " SSZFMT "\n", n, (ssize_t) nbits);
		}
	}

	/* The bitvector now describes all images that may be relevant. 
	   Decode the bit vector and return the oids of the relevant images.
	 */
	rv = bitvector_decode(candidates, bv);
	BATdelete(bv);
	c->c_refs--;
	return rv;
}

int
qt_pre_select(BAT **candidates, int *crossid, int *cspace, wrd *nimages)
{
	int n, rv, x, y;
	wrd nbits;
	cross_t *c;
	BAT *bv, *_bv, *bv_cluster;
	bit initial;

	printf("qt_pre_select: Preselecting images\n");
	MT_set_lock(qt_lock, "qt_pre_select");
	for (n = 0; n != NCROSSES; n++)
		if (crosses[n].c_crossid == *crossid)
			break;
	if (n == NCROSSES) {
		GDKerror("[qt_pre_select]: Cannot find cross %d\n", *crossid);
		MT_unset_lock(qt_lock, "qt_pre_select");
		return GDK_FAIL;
	}
	c = &crosses[n];
	c->c_refs++;
	MT_unset_lock(qt_lock, "qt_pre_select");

	printf("qt_pre_select: allocating bitvector " SSZFMT "\n", (ssize_t) *nimages);
	/* Analyze the spot and select the right bit-fields.  Allocate an 
	   empty result bit field with all images selected */
	initial = 1;
	if (bitvector_allocate(&bv, nimages, &initial) != GDK_SUCCEED) {
		GDKerror("[qt_pre_select]: Cannot allocate empty bit vector of size " SSZFMT "\n", (ssize_t) *nimages);
		c->c_refs--;
		return GDK_FAIL;
	}

	bitvector_count(&nbits, bv);
	printf("qt_pre_select: nimages " SSZFMT "\n", (ssize_t) nbits);

	if (*cspace != (int) ColorSpace_IR_12 || (int) c->c_cspace != *cspace || ir_wclusters[0] == NULL) {

		printf("qt_pre_select: No cache?\n");

		/* No candidates, all images are candidates */
		GDKwarning("qt_pre_select: Warning: no cache\n");

		rv = bitvector_decode(candidates, bv);
		BATdelete(bv);
		c->c_refs--;
		return rv;
	}

	if (debug)
		bitvector_print(bv);

	/* The horizontal color transitions */
	for (y = 0; y != c->c_spot_h; y++) {
		int colors[3], cindex, color;

		colors[0] = colors[1] = colors[2] = -1;
		cindex = 0;
		for (x = 0; x != c->c_spot_w; x++) {
			if (c->c_spot[y * c->c_spot_w + x] & QTE_VALID) {
				color = get_color(c->c_spot[y * c->c_spot_w + x], ColorSpace_IR_12);
				printf("cindex %d, color %d, prev %d\n", cindex, color, (cindex > 0) ? colors[cindex - 1] : -1);

				if (cindex == 0 || color !=colors[cindex - 1]) {
					colors[cindex++] = color;

					if (cindex == 3) {
						/* There is a 3 color transition! */
						printf("Using (h) %d %d %d\n", colors[2], colors[1], colors[0]);
						bv_cluster = ir_wclusters[colors[2] * NIRBINS * NIRBINS + colors[1] * NIRBINS + colors[0]];

						if (bitvector_and(&_bv, bv, bv_cluster) != GDK_SUCCEED) {
							c->c_refs--;
							return GDK_FAIL;
						}

						BATdelete(bv);
						bv = _bv;

						colors[0] = colors[1];
						colors[1] = colors[2];
						cindex = 2;

						if (1) {
							bitvector_count(&nbits, bv);
							printf("qt_pre_select: (horizontal y %d, x %d) nimages " SSZFMT "\n", y, x, (ssize_t) nbits);
						}
					}
				}
			}
		}

		if (cindex > 0 && cindex < 3) {
			if (cindex == 1)
				colors[1] = colors[2] = colors[0];
			else if (cindex == 2)
				colors[2] = colors[1];

			printf("Using (hlast) %d %d %d\n", colors[2], colors[1], colors[0]);
			bv_cluster = ir_wclusters[colors[2] * NIRBINS * NIRBINS + colors[1] * NIRBINS + colors[0]];

			if (bitvector_and(&_bv, bv, bv_cluster) != GDK_SUCCEED) {
				c->c_refs--;
				return GDK_FAIL;
			}

			BATdelete(bv);
			bv = _bv;
		}
	}

#ifdef notdef
	/* The vertical color transitions */
	for (x = 0; x != c->c_spot_w; x++) {
		int colors[3], cindex, color;

		colors[0] = colors[1] = colors[2] = -1;
		cindex = 0;
		for (y = 0; y != c->c_spot_h; y++) {
			if (c->c_spot[y * c->c_spot_w + x] & QTE_VALID) {
				color = get_color(c->c_spot[y * c->c_spot_w + x], ColorSpace_IR_12);
				printf("Vertical, got color %d (%d, %d)\n", color, x, y);

				if (cindex == 0 || color !=colors[cindex - 1]) {
					colors[cindex++] = color;

					if (cindex == 3) {
						/* There is a 3 color transition! */
						printf("Using (v) %d %d %d\n", colors[2], colors[1], colors[0]);
						bv_cluster = ir_nclusters[colors[2] * NIRBINS * NIRBINS + colors[1] * NIRBINS + colors[0]];

						if (bitvector_and(&_bv, bv, bv_cluster) != GDK_SUCCEED) {
							c->c_refs--;
							return GDK_FAIL;
						}

						BATdelete(bv);
						bv = _bv;

						colors[0] = colors[1];
						colors[1] = colors[2];
						cindex = 2;

						if (1) {
							bitvector_count(&nbits, bv);
							printf("qt_pre_select: (vertical x %d, y %d) nimages " SSZFMT "\n", x, y, (ssize_t) nbits);
						}
					}
				}
			}
		}

		if (cindex > 0 && cindex < 3) {
			if (cindex == 1)
				colors[1] = colors[2] = colors[0];
			else if (cindex == 2)
				colors[2] = colors[1];

			printf("Using (vlast) %d %d %d\n", colors[2], colors[1], colors[0]);
			bv_cluster = ir_nclusters[colors[2] * NIRBINS * NIRBINS + colors[1] * NIRBINS + colors[0]];

			if (bitvector_and(&_bv, bv, bv_cluster) != GDK_SUCCEED) {
				c->c_refs--;
				return GDK_FAIL;
			}

			BATdelete(bv);
			bv = _bv;
		}
	}
#endif

	/* The bitvector now describes all images that may be relevant. 
	   Decode the bit vector and return the oids of the relevant images.
	 */
	rv = bitvector_decode(candidates, bv);
	BATdelete(bv);
	c->c_refs--;
	return rv;
}

int
convert_to_itten_runge_bin(int color)
{
	if (color <HUEBINS)
		return (int) ((double) color /HUES_PER_ITTEN_RUNGE_BIN);

	return (int) ((double) (color -HUEBINS) /GREYS_PER_ITTEN_RUNGE_BIN) + ITTEN_RUNGE_HUE_BINS;
}

static int
get_color(gdk_uint32 hsv, colorspace_t cspace)
{
	gdk_uint8 h, s, v;
	int bin;

	h = (hsv >> 16) & 0xFF;
	s = (hsv >> 8) & 0xFF;
	v = hsv & 0xFF;
	bin = isgrey(s) ? (v * GREYBINS) / HUEBINS + HUEBINS : h;

	switch (cspace) {
	case ColorSpace_H_256:
		break;
	case ColorSpace_IR_12:
		bin = convert_to_itten_runge_bin(bin);
		break;
	default:
		assert("Unsupported color space" == 0);
		abort();
	}
	return bin;
}

static int
same_color(int c1, int c2)
{
	int delta;

	if ((c1 < HUEBINS && c2 >= HUEBINS) || (c2 < HUEBINS && c1 >= HUEBINS))
		/* Grey scales and colors are never the same */
		return 0;

	if (c1 >= HUEBINS) {
		assert(c2 >= HUEBINS);
		return abs(c1 - c2) < gband;
	}

	delta = abs(c1 - c2);
	return min(delta, HUEBINS - delta) < hband;
}


static zid_t
up(zid_t id)
{
	if (id == 0)
		return -1;
	assert(id >0);
	return (id -1) /4;
}

static int
get_nfeatures(zid_t lastid)
{
	int level;

	/* First determine ID's level */
	assert(levels);
	for (level = 0; level != nlevels; level++)
		if (lastid >= levels[level].lvl_sid && lastid < levels[level].lvl_sid + levels[level].lvl_nid)
			break;

	return (level == nlevels) ? -1 : levels[level].lvl_sid + levels[level].lvl_nid;
}

static int
idlevel(zid_t id)
{
	int level;

	/* First determine ID's level */
	assert(levels);
	for (level = 0; level != nlevels; level++)
		if (id >=levels[level].lvl_sid && id <levels[level].lvl_sid + levels[level].lvl_nid)
			break;
	return (level >= nlevels) ? -1 : level;
}

static zid_t
neighbor(direction_t direction, zid_t id)
{
	int x, y, level;
	qtlevel_t *l;

	/* First determine ID's level */
	assert(levels);
	for (level = 0; level != nlevels; level++)
		if (id >=levels[level].lvl_sid && id <levels[level].lvl_sid + levels[level].lvl_nid)
			break;
	if (level >= nlevels)
		return -1;

	l = &levels[level];
	id -=l->lvl_sid;
	assert(id >=0 && id <l->lvl_nid);
	x = l->lvl_idtoxy[id].id_x;
	y = l->lvl_idtoxy[id].id_y;

	switch (direction) {
	case N:
		y--;
		break;
	case NE:
		x++;
		y--;
		break;
	case E:
		x++;
		break;
	case SE:
		x++;
		y++;
		break;
	case S:
		y++;
		break;
	case SW:
		x--;
		y++;
		break;
	case W:
		x--;
		break;
	case NW:
		x--;
		y--;
		break;
	default:
		assert(0);
		abort();
	}

	if (x < 0 || y < 0 || x >= l->lvl_nid_dir || y >= l->lvl_nid_dir)
		return -1;

	return l->lvl_xytoid[y * l->lvl_nid_dir + x] + l->lvl_sid;
}

int
qt_debug(int *dbg)
{
	debug = *dbg;
	return GDK_SUCCEED;
}

int
qt_stats(int *mode, str outfile)
{
	int rv;

	rv = GDK_SUCCEED;
	switch (*mode) {
		int bins, binwidth;
		lng lo;

	case 0:
		bins = 100;
		binwidth = 10;
		lo = 0;

		if (st_search == NULL)
			rv = stats_histogram_new(&st_search, "qt_search", &bins, &binwidth, &lo);
		if (rv != GDK_SUCCEED)
			return rv;
		if (st_bunins[0] == NULL)
			rv = stats_histogram_new(&st_bunins[0], "bunins_ids", &bins, &binwidth, &lo);
		if (rv != GDK_SUCCEED)
			return rv;
		if (st_bunins[1] == NULL)
			rv = stats_histogram_new(&st_bunins[1], "bunins_images", &bins, &binwidth, &lo);
		if (rv != GDK_SUCCEED)
			return rv;
		if (st_bunins[2] == NULL)
			rv = stats_histogram_new(&st_bunins[2], "bunins_ncolors", &bins, &binwidth, &lo);
		if (rv != GDK_SUCCEED)
			return rv;
		break;
	case 1:
		if (st_search)
			rv = stats_report(&st_search, outfile);
		if (rv != GDK_SUCCEED)
			return rv;
		if (st_bunins[0])
			rv = stats_report(&st_bunins[0], outfile);
		if (rv != GDK_SUCCEED)
			return rv;
		if (st_bunins[1])
			rv = stats_report(&st_bunins[1], outfile);
		if (rv != GDK_SUCCEED)
			return rv;
		if (st_bunins[2])
			rv = stats_report(&st_bunins[2], outfile);
		if (rv != GDK_SUCCEED)
			return rv;
		break;
	case 2:
		if (st_search) {
			rv = stats_del(&st_search);
			st_search = NULL;
		}
		if (rv != GDK_SUCCEED)
			return rv;
		if (st_bunins[0]) {
			rv = stats_del(&st_bunins[0]);
			st_bunins[0] = NULL;
		}
		if (rv != GDK_SUCCEED)
			return rv;
		if (st_bunins[1]) {
			rv = stats_del(&st_bunins[1]);
			st_bunins[1] = NULL;
		}
		if (rv != GDK_SUCCEED)
			return rv;
		if (st_bunins[2]) {
			rv = stats_del(&st_bunins[2]);
			st_bunins[2] = NULL;
		}
		if (rv != GDK_SUCCEED)
			return rv;
		break;
	default:
		GDKerror("Unsupported statistics mode %d\n", *mode);
		return GDK_FAIL;
	}
	return GDK_SUCCEED;
}
@}
