@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2006 CWI.
@' All Rights Reserved.

@f bitset
@t The BitSet module
@a Menzo Windhouwer
@v 1.0
@* Introduction
@T

@* Implementation
@T

@+ MEL definition
@m

.MODULE bitset;

	.ATOM bitset = int;
		.TOSTR   = bitset_tostr;
		.FROMSTR = bitset_fromstr;
	.END;

	.COMMAND newBitset(int theBits) : bitset = newBitset1;
		"Create a new BitSet from an existing integer."
	.COMMAND newBitset() : bitset = newBitset2;
		"Create a new empty BitSet."

	.COMMAND bitset_clearBit(bitset theBitSet,int theBit) : bitset = bitset_clearBit;
		"Clear the specified bit in this BitSet."
	.COMMAND bitset_flipBit(bitset theBitSet,int theBit) : bitset = bitset_flipBit;
		"Flip the specified bit in this BitSet."
	.COMMAND bitset_getBit(bitset theBitSet,int theBit) : bit = bitset_getBit;
		"Get the specified bit from this BitSet."
	.COMMAND bitset_setBit(bitset theBitSet,int theBit) : bitset = bitset_setBit;
		"Set the specified bit from this BitSet."

	.COMMAND bitset_and(bitset theBitSet,bitset otherBitSet) : bitset = bitset_and;
		"AND this BitSet with an other BitSet."
	.COMMAND bitset_or(bitset theBitSet,bitset otherBitSet) : bitset = bitset_or;
		"OR this BitSet with an other BitSet."
	.COMMAND bitset_xor(bitset theBitSet,bitset otherBitSet) : bitset = bitset_xor;
		"XOR this BitSet with an other BitSet."
	.COMMAND bitset_not(bitset theBitSet) : bitset = bitset_not;
		"NOT this BitSet."
	.COMMAND bitset_toInt(bitset theBitSet) : int = bitset_toInt;
		"Convert this BitSet to an integer."

@mil
		PROC bitset_toStr(bitset theBitset) : str {
			return str(theBitset);
		}
@m

.END bitset;

@ifdef ODL

@+ ODL definition
#@odl

module bitset {

	atom bitset;

	atom bitset[4] {
		bitset clearBit(in int theBit);
		bitset flipBit(in int theBit);
		boolean getBit(in int theBit);
		bitset setBit(in int theBit);

		bitset and(in bitset otherBitSet);
		bitset or(in bitset otherBitSet);
		bitset xor(in bitset otherBitSet);
		bitset not();

		string toStr();
		int toInt();
	};

	bitset newBitset(in int theBits);
	bitset newBitset();
	
};

@endif

@+ C definition
@h

#ifndef _BITSET_H_
#define _BITSET_H_

/*#define DEBUG */

typedef int bitset;

#include "bitset.proto.h"

#endif /*_BITSET_H_*/

@+ C implementation
@c
#include "monetdb4_config.h"

#include "bitset.h"

@- Atom commands
@c

@T
{\bf{\tt fromstr(str):bitset}}

Create a BitSet from a string

allowed strings are:
\begin{itemize}
	\item an integer in decimal form;
	\item an integer in octal form (prefixed by 0);
	\item an integer in hexadecimal form (prefixed by 0x).
\end{itemize}
@-
@c

int
bitset_fromstr(char *src, int *len, bitset **atom)
{

	if (*len < (int) sizeof(int)) {
		GDKfree(*atom);
		*atom = GDKmalloc(sizeof(bitset));
		*len = sizeof(bitset);
	}

	sscanf(src, "%i", *atom);

	return (int) strlen(src);

}

@T
{\bf{\tt tostr(bitset):str}}

Create a string from a BitSet
@-
@c

int
bitset_tostr(char **dst, int *len, bitset *atom)
{

	int i;

#ifdef DEBUG
	printf("printing bitset[%d]\n", (int) *atom);
#endif

#ifdef DEBUG
	printf("len[%d]\n", *len);
#endif
	if (*len < (int) ((sizeof(bitset) * 8) + 1)) {
#ifdef DEBUG
		printf("freeing allocated memory\n");
#endif
		GDKfree(*dst);
		*dst = GDKmalloc((sizeof(bitset) * 8) + 1);
		*len = (sizeof(bitset) * 8) + 1;
	}
#ifdef DEBUG
	printf("allocating memory\n");
#endif
#ifdef DEBUG
	printf("allocated %d bytes\n", *len);
#endif

#ifdef DEBUG
	printf("constructing string\n");
#endif
	strcpy(*dst, "");
	for (i = (sizeof(bitset) * 8) - 1; i >= 0; i--) {
#ifdef DEBUG
		printf("%d ", i);
#endif
		if ((*atom >>i) &1)
			strcat(*dst, "t");
		else
			strcat(*dst, "f");
	}

#ifdef DEBUG
	printf("\nconstructed string[%s]\n", *dst);
#endif

	return (int) strlen(*dst);

}

@- Constructors
@c

@T
{\bf{\tt newBitset(int):bitset}}

Create a new BitSet from an existing integer.
@-
@c

int
newBitset1(bitset *res, int *theBits)
{

	*res = *theBits;

#ifdef DEBUG
	printf("created new bitset[%d] from int[%d]\n", *res, *theBits);
#endif

	return GDK_SUCCEED;

}

@T
{\bf{\tt newBitset():bitset}}

Create a new empty BitSet.
@-
@c

int
newBitset2(bitset *res)
{

	*res = 0;

#ifdef DEBUG
	printf("created new empty bitset[%d]\n", (int) *res);
#endif

	return GDK_SUCCEED;

}

@- Accessors
@c

@T
{\bf{\tt bitset\_clearBit(bitset,int):bitset}}

Clear the specified bit in this BitSet.
@-
@c

extern int
bitset_clearBit(bitset *res, bitset *theBitSet, int *theBit)
{

	if (*theBit >= (int) (sizeof(bitset) * 8)) {
		GDKerror("bitset_clearBit: This bit doesn't exist in the set\n");
		return GDK_FAIL;
	}

	*res = *theBitSet & (~(1 << *theBit));

	return GDK_SUCCEED;

}


@T
{\bf{\tt bitset\_flipBit(bitset,int)}}

Flip the specified bit in this BitSet.
@-
@c

extern int
bitset_flipBit(bitset *res, bitset *theBitSet, int *theBit)
{

	if (*theBit >= (int) (sizeof(bitset) * 8)) {
		GDKerror("bitset_flipBit: This bit doesn't exist in the set\n");
		return GDK_FAIL;
	}

	*res = *theBitSet ^ (1 << *theBit);

	return GDK_SUCCEED;

}

@T
{\bf{\tt bitset\_getBit(bitset,int):bit}}

Get the specified bit from this BitSet.
@-
@c

extern int
bitset_getBit(bit *res, bitset *theBitSet, int *theBit)
{

	if (*theBit >= (int) (sizeof(bitset) * 8)) {
		GDKerror("bitset_getBit: This bit doesn't exist in the set\n");
		return GDK_FAIL;
	}

	*res = (*theBitSet >> *theBit) & 1;
/*
fprintf(GDKout,"bitset_getBit(%d,%d) result: %d %s\n",*theBitSet,*theBit,*res,*res?"true":"false");
*/
	return GDK_SUCCEED;

}

@T
{\bf{\tt bitset\_setBit(bitset,int)}}

Set the specified bit from this BitSet.
@-
@c

extern int
bitset_setBit(bitset *res, bitset *theBitSet, int *theBit)
{

	if (*theBit >= (int) (sizeof(bitset) * 8)) {
		GDKerror("bitset_setBit: This bit doesn't exist in the set\n");
		return GDK_FAIL;
	}

	*res = *theBitSet | (1 << *theBit);

	return GDK_SUCCEED;

}

@T
{\bf{\tt bitset\_and(bitset,bitset):bitset}}

AND this BitSet with an other BitSet.
@-
@c

extern int
bitset_and(bitset *res, bitset *theBitSet, bitset *otherBitSet)
{

	*res = (*theBitSet) & (*otherBitSet);

	return GDK_SUCCEED;

}

@T
{\bf{\tt bitset\_or(bitset,bitset):bitset}}

OR this BitSet with an other BitSet.
@-
@c

extern int
bitset_or(bitset *res, bitset *theBitSet, bitset *otherBitSet)
{

	*res = (*theBitSet) | (*otherBitSet);

	return GDK_SUCCEED;

}

@T
{\bf{\tt bitset\_xor(bitset,bitset):bitset}}

XOR this BitSet with an other BitSet.
@-
@c

extern int
bitset_xor(bitset *res, bitset *theBitSet, bitset *otherBitSet)
{

	*res = (*theBitSet) ^ (*otherBitSet);

	return GDK_SUCCEED;

}

@T
{\bf{\tt bitset\_not(bitset):bitset}}

NOT this BitSet.
@-
@c

extern int
bitset_not(bitset *res, bitset *theBitSet)
{

	*res = ~(*theBitSet);

	return GDK_SUCCEED;

}

@T
{\bf{\tt bitset\_toInt(bitset):int}}

Convert this BitSet to an integer.
@-
@c

extern int
bitset_toInt(int *res, bitset *theBitSet)
{

	*res = *theBitSet;

	return GDK_SUCCEED;

}

@+ Test
@mil

PROC test_bitset() : void {
	sigs("bitset");

	printf("constructor\n");
	var b := newBitset();
	b.print();

	printf("get(15)\n");
	b.bitset_getBit(15).print();
	printf("set(15)\n");
	b := b.bitset_setBit(15);
	b.print();
	printf("get(15)\n");
	b.bitset_getBit(15).print();
	printf("clear(15)\n");
	b := b.bitset_clearBit(15);
	b.print();
	printf("get(15)\n");
	b.bitset_getBit(15).print();

	printf("flip(7)\n");
	b := b.bitset_flipBit(7);
	b.print();
	printf("flip(7)\n");
	b := b.bitset_flipBit(7);
	b.print();

	printf("constructor(35)\n");
	var a := newBitset(35);
	a.print();

	printf("constructor(0x22)\n");
	b := bitset("0x22");
	b.print();

	printf("and\n");
	bitset_and(a,b).print();
	printf("or\n");
	bitset_or(a,b).print();
	printf("xor\n");
	bitset_xor(a,b).print();
	printf("not\n");
	bitset_not(a).print();

	printf("convert to integer\n");
	bitset_toInt(a).print();
}
