@/
The contents of this file are subject to the MonetDB Public License
Version 1.1 (the "License"); you may not use this file except in
compliance with the License. You may obtain a copy of the License at
http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html

Software distributed under the License is distributed on an "AS IS"
basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations
under the License.

The Original Code is the MonetDB Database System.

The Initial Developer of the Original Code is CWI.
Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
Copyright August 2008-2011 MonetDB B.V.
All Rights Reserved.
@

@f array
@a A.R. van Ballegooij
@* Basic array support


@m
.MODULE array;
@= grid_mdefs
  .COMMAND grid(@1,@1,@1,@1) : bat[void,@1] = grid_@1;
    "Generates an index BAT, (grpcount,grpsize,clustersize,offset)"
@m
@:grid_mdefs(int)@
@:grid_mdefs(lng)@

  .COMMAND print_array(bat[any::1,any],...bat[any::1,int]...) : void = print_array;
    "Prints an array, using 1 value bat and N aligned index bats"

.END array;

@h
/*============================================================================*/
#ifndef __array_h__
#define __array_h__

#include <gdk.h>
#include <algebra.h>		/* to include BATmin and BATmax */

#include "array.proto.h"
@= grid_hdefs
#define new_@1_bat(b,s,f) do {						\
		if (((b) = BATnew(TYPE_void,TYPE_@1,(BUN) (s))) == NULL) { \
			GDKerror("%s: cannot create the bat ("BUNFMT" BUNs)\n", f, (BUN) (s)); \
			return GDK_FAIL;				\
		}							\
		BATseqbase((b),0);					\
	} while (0)
#define add_@1s(b,n)    {(b)->T->heap.free+=(size_t)(n)*sizeof(@1);\
			                   (b)->batCount+=(BUN)n;\
                         BATkey(BATmirror((b)),0);          \
                         (b)->tsorted = 0;                  }
#define get_@1_ptr(b)   ((@1*)(Tloc(b,BUNfirst((b)))))
@h
@:grid_hdefs(int)@
@:grid_hdefs(lng)@

/* The maximum number of dimensions that the print-function can handle... */
#define MAX_ARRAY_DIM 16

#endif
/*============================================================================*/
@c
/*============================================================================*/
#include "monetdb4_config.h"
#include "array.h"
#include <math.h>
#include <time.h>

@= grid_impl
array_export str ARRAYgrid_@1(@1 *ret, @1 *groups, @1 *groupsize, @1 *clustersize, @1 *offset);
array_export str ARRAYgridShift_@1(@1 *ret, @1 *groups, @1 *groupsize, @1 *clustersize, @1 *offset, @1 *shift);
array_export str ARRAYgridBAT_@1(@1 *ret, @1 *bid, @1 *groups, @1 *groupsize, @1 *clustersize, @1 *offset);
array_export str ARRAYgridBATshift_@1(@1 *ret, @1 *bid, @1 *groups, @1 *groupsize, @1 *clustersize, @1 *offset, @1 *shift);

int
fillgrid_@1(BAT **out, @1 *groups, @1 *groupsize, @1 *clustersize, @1 *offset, @1 *shift)
{
	register @1 *ptr;
	@1 i = *groups;
	@1 n = *groupsize + *offset;
	@1 r = *clustersize;
	@1 o = *offset;
	@1 s = *shift;

#ifdef EXCESSIVE_DEBUGGING
	fprintf(stderr, "[grid] (%d,%d,%d,%d)", i, n, r, o);
#endif

	ptr = get_@1_ptr(*out);

	while (i--) {
		register @1 ni = o;

		while (ni < n) {
			register @1 ri = r;

			while (ri--)
				(*(ptr ++)) = ni * s;
			ni++;
		}
	}

#ifdef EXCESSIVE_DEBUGGING
	fprintf(stderr, "- done\n");
#endif

	return GDK_SUCCEED;
}

int
grid_@1(BAT **out, @1 *groups, @1 *groupsize, @1 *clustersize, @1 *offset)
{
	@1 i = *groups;
	@1 n = *groupsize + *offset;
	@1 r = *clustersize;
	@1 o = *offset;
	@1 s = 1;

#ifdef EXCESSIVE_DEBUGGING
	fprintf(stderr, "[grid] (%d,%d,%d,%d)", i, n, r, o);
#endif

	new_@1_bat(*out, (i * (n - o) * r), "grid_@1");
	add_@1s(*out, (i * (n - o) * r));
	return fillgrid_@1(out, groups, groupsize, clustersize, offset, &s);
}

int
gridShift_@1(BAT **out, @1 *groups, @1 *groupsize, @1 *clustersize, @1 *offset, @1 *shift)
{
	@1 i = *groups;
	@1 n = *groupsize + *offset;
	@1 r = *clustersize;
	@1 o = *offset;

#ifdef EXCESSIVE_DEBUGGING
	fprintf(stderr, "[grid] (%d,%d,%d,%d)", i, n, r, o);
#endif

	new_@1_bat(*out, (i * (n - o) * r), "gridShift_@1");
	add_@1s(*out, (i * (n - o) * r));
	return fillgrid_@1(out, groups, groupsize, clustersize, offset, shift);
}

@c
@:grid_impl(int)@
@:grid_impl(lng)@


/*---------------------------------------------------------------------------*/
/*
   memory-hungry function;
   it internally builds the index to be able to print the array in-order.
*/

int
print_array(BAT *val, ...)
{
	BATiter vali = bat_iterator(val);
	va_list ap;
	BAT *tmp, *batptr[MAX_ARRAY_DIM];
	int *minvector;
	int *idxvector;
	int *maxvector;
	int *lenvector;
	oid *arrayindex;
	int i, dims;
	BUN j, c;
	stream *st = GDKout;
	int type_id = BATttype(val);

	va_start(ap, val);
	dims = 0;
	while ((tmp = va_arg(ap, BAT *)) != NULL) {
		if (dims == MAX_ARRAY_DIM) {
			GDKerror("print_array: Error, too high dimensionality.\n");
			goto exit_err_none;
		}
		batptr[dims++] = tmp;
	}
	va_end(ap);
	if (dims == 0) {
		GDKerror("print_array: Error, no index bats provided.\n");
		goto exit_err_none;
	}

#ifdef EXCESSIVE_DEBUGGING
	fprintf(stderr, "[PRINT_ARRAY] Dims = %d\n", dims);
#endif

	minvector = GDKmalloc(sizeof(ptr) * dims);
	idxvector = GDKzalloc(sizeof(int) * dims);
	maxvector = GDKmalloc(sizeof(ptr) * dims);
	lenvector = GDKmalloc(sizeof(ptr) * dims);

	c = 1;
	j = BATcount(val);
	for (i = 0; i < dims; i++) {
		if (BATttype(batptr[i]) != TYPE_int) {
			GDKerror("print_array: Index %d error, not int type\n", i);
			goto exit_err_part;
		}
		if (BATcount(batptr[i]) != j) {
			GDKerror("print_array: Index %d error, count doesn't match\n", i);
			goto exit_err_part;
		}

		BATmin(batptr[i], &(minvector[i]));
		BATmax(batptr[i], &(maxvector[i]));
		lenvector[i] = maxvector[i] - minvector[i] + 1;
		c *= lenvector[i];
#ifdef EXCESSIVE_DEBUGGING
		fprintf(stderr, "[PRINT_ARRAY] Axis %d = %d..%d\n", i, minvector[i], maxvector[i]);
#endif
	}

	if (c != j) {
		GDKerror("print_array: array size does not match array count\n");
		goto exit_err_part;
	}
	arrayindex = GDKmalloc(sizeof(oid) * c);

	/* Iterate over the first index BAT.              */
	/* And fetch additional indices (for a given oid) */
	/* building the full M-D structure (of oid's).    */
	{
		BATiter b0i = bat_iterator(batptr[0]);
		register BUN p, q;

		p = BUNfirst(batptr[0]);
		q = BUNlast(batptr[0]);
		while (p < q) {
			register oid *o = (oid *) BUNhead(b0i, p);
			register int offset;

			offset = *((int *) BUNtail(b0i, p)) - minvector[0];
			for (i = 1; i < dims; i++) {
				register BUN p = BUNfnd(batptr[i], o);

				if (p == BUN_NONE) {
					GDKerror("print_array: Index %d missing for oid " OIDFMT ".\n", i, *o);
					goto exit_err_full;
				}
				offset = (offset * lenvector[i]) + ((*((int *) Tloc(batptr[i],p))) - minvector[i]);
			}
			arrayindex[offset] = *o;
			p++;
		}
	}

	/* Iterate over all valid indices             */
	/* (note: normalized to [0..l-1] ranges !)    */
	/* And print the values within the 'correct'  */
	/* bracket structure...                       */
#ifdef EXCESSIVE_DEBUGGING
	fprintf(stderr, "[PRINT_ARRAY] ");
#endif
	while (idxvector[dims - 1] < lenvector[dims - 1]) {
		int offset;

		for (i = 0; i < dims; i++) {
			if (idxvector[i] != 0) {
#ifdef EXCESSIVE_DEBUGGING
				fprintf(stderr, ",");
#endif
				mnstr_printf(st, ",");
				break;
			}
		}
		i = 0;
		while (i < dims && idxvector[i] == 0) {
#ifdef EXCESSIVE_DEBUGGING
			fprintf(stderr, "[");
#endif
			mnstr_printf(st, "[");
			i++;
		}
		for (offset = idxvector[0], i = 1; i < dims; i++) {
			offset = (offset * lenvector[i]) + idxvector[i];
		}
		{
			register BUN p = BUNfnd(val, &arrayindex[offset]);

			if (p == BUN_NONE) {
				GDKerror("print_array: Value missing for oid " OIDFMT ".\n", arrayindex[offset]);
				goto exit_err_full;
			}
#ifdef EXCESSIVE_DEBUGGING
			fprintf(stderr, OIDFMT "\@0", arrayindex[offset]);
#endif
			ATOMprint(type_id, BUNtail(vali, p), st);
			if (mnstr_errnr(st))
				goto exit_err_full;
		}
		i = 0;
		while (i < dims && (++idxvector[i]) == lenvector[i]) {
#ifdef EXCESSIVE_DEBUGGING
			fprintf(stderr, "]");
#endif
			mnstr_printf(st, "]");
			if (i < dims - 1) {
				idxvector[i] = 0;
				i++;
			}
		}
	}
#ifdef EXCESSIVE_DEBUGGING
	fprintf(stderr, "\n");
#endif
	mnstr_printf(st, "\n");

	/* Exit strategies... */
	GDKfree(arrayindex);
	GDKfree(maxvector);
	GDKfree(idxvector);
	GDKfree(minvector);
	GDKfree(lenvector);
	return GDK_SUCCEED;

exit_err_full:
	GDKfree(arrayindex);
exit_err_part:
	GDKfree(maxvector);
	GDKfree(idxvector);
	GDKfree(minvector);
	GDKfree(lenvector);
exit_err_none:
	return GDK_FAIL;
}


/*============================================================================*/
@mil

PROC cons(int n,any::1 v) : bat[void,any::1] {
	return project(grid(1,n,1,0),v);
}
ADDHELP("cons", "A.R. van Ballegooij", "Sep 20 2003",
"generates a bat with a constant column", "array");

PROC concat(bat[oid,any::1] a,bat[oid,any::1] b,int o) : bat[oid,any::1] {
	return access(insert(access(copy(a),BAT_WRITE),
			reverse([oid]([+]([int](reverse(b)),o)))) ,
			BAT_READ);
}
ADDHELP("concat", "A.R. van Ballegooij", "Sep 20 2003",
"Adds 'offset' two second arrays indexes and merges tables", "array");

if (mod() = "main"){
	print("Array module loaded...");
}
