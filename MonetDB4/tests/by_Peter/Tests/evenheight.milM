# The main procedure is evenheight(bat_param,nranges) 
# it produces a new bat with an even-height remapping of tail-values.

# this computes the weighed midpoint of a range 'low'..'high'
# the weights are taken from the sorted histogram 'hst' 
#
proc compute_mid(bat hst, any  low, any  high) : void {
    var members := hst.reverse().select(low,high);
    var weighed := new(int, members.ttype(), members.count());
    var mid := nil.cast(hst.htype());
    var cum := 0;

    members@batloop() {
        cum := cum + $h;
        weighed.insert(cum, $t);
    }
    weighed@batloop() {
        mid := $t;
        if ($h >= (cum / 2)) break;
    }
    return mid;
}

# we construct an equal-height partitioning range for the tail columns
# of a bat. This partitioning range is represented by a new 'range-bat'.
# Each BUN in the range-bat represents 1 range. Its tail contains the maximum 
# range value (tails are sorted); its head contains the representative value.
#
# The below proc constructs such a range-bat iteratively using
# a histogram. This algorithms dynamically adapts the ideal 
# group-size 'ideal' to obtain a nicely balanced result.
#
proc range_bat(bat b, int n) : bat {
    var      histo := b.histogram().sort(); # sort it!
    var     ranges := new(b.ttype(), b.ttype(), (n*4)/3);
    var    cursize := 0;
    var items_left := b.count();
    var mid_h, last_h, first_h;

    histo@batloop() {
        var idealsize := items_left/n;
        if (cursize = 0) {
            first_h := $h; # the lowest element of the range
        }
        cursize := cursize + $t;
        if (cursize >= idealsize) {
            # ok, we must create a new group
            if ((cursize - idealsize) <= (idealsize - (cursize- $t))) {
                items_left := items_left - cursize;
	             mid_h := histo.compute_mid(first_h, $h);
                    last_h := $h;
                   cursize := 0;
            } else {
                # group would be too large with the current
                # element in it. Keep the current for the next grp.
                #
                items_left := items_left - (cursize - $t);
	             mid_h := histo.compute_mid(first_h, last_h);
                   first_h := $h;
                   cursize := $t;
            }
            # insert the new group description
            ranges.insert(mid_h, last_h);
            n := n - 1;
        }
        last_h := $h;
    }
    return ranges;
}

# use the range-bat to convert one value to its representative value.
proc convert_val(any v, any rng) : any {
        rng@batloop() {
		if ($t >= v) return $h;
	}
        return nil.cast(v.type());
}

# OVERALL USEABLE PROC
proc evenheight(bat b, int n) : bat {
        var rng := range_bat(b, n);
        print(rng); # print the range (for debugging purposes)
        return [convert_val](b, const rng);
}

# TESTING

var TheSize := 1000;

var def_tpe := new(int,int);
var i := 0;
while (i<TheSize) { def_tpe.insert(i,rand()); i:+=1; }

var a := [str](def_tpe.mark(100000@0)).reverse().mirror();
var b := a.range_bat(10);
var c := [int](b.reverse().mirror());
var d := [int](b.reverse());
print([-](c,d),b.reverse());

var aa := a.evenheight(9);

var z1 := new(int,int);
var z2 := new(int,int);
i := 0;
while (i<TheSize) { z1.insert(i,rand()); z2.insert(i,i); i:+=1; }

printf("#~BeginVariableOutput~#\n"); var z1z:=z1.evenheight(8); printf("#~EndVariableOutput~#\n");

var z2z:=z2.evenheight(8);

quit();

