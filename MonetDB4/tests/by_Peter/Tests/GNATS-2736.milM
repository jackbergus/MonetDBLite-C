# the following implementation paths in the standard pump implementation exist:
#
# proc_sort()ed
# proc_hash
# packed_sort()ed
# packed_hash
# direct_sort()ed_chr
# direct_sort()ed_bte
# direct_sort()ed_sht
# direct_sort()ed_int
# direct_sort()ed_wrd
# direct_sort()ed_void
# direct_hash_chr
# direct_hash_bte
# direct_hash_sht
# direct_hash_int
# direct_hash_wrd
#
# this script intends to test them all.
module(aggr);

var b_int := bat(int,str).insert(1,"1").insert(2,"2").insert(1,"1");
b_int.insert(3,"3").insert(4,"4").insert(5,"5").insert(6,"6");
b_int.insert(3,"3").insert(4,"4").insert(5,"5").insert(6,"6");
var b_wrd := [wrd](b_int.reverse()).reverse();
var b_sht := [sht](b_int.reverse()).reverse();
var b_bte := [bte](b_int.reverse()).reverse();
var b_chr := [chr](b_int.reverse()).reverse();
var b_str := [str](b_int.reverse()).reverse();
var v_oid := bat(void,str).insert(nil,"1").insert(nil,"2").insert(nil,"3");
v_oid.insert(nil,"4").insert(nil,"5").insert(nil,"6").seqbase(1@0);

var e_int := bat(int,void).insert(1,nil).insert(3,nil).insert(4,nil).insert(5,nil);
e_int.insert(6,nil).insert(7,nil).insert(8,nil).col_name("e_int");
var e_wrd := [wrd](e_int.reverse()).reverse().col_name("e_wrd");
var e_sht := [sht](e_int.reverse()).reverse().col_name("e_sht");
var e_bte := [bte](e_int.reverse()).reverse().col_name("e_bte");
var e_chr := [chr](e_int.reverse()).reverse().col_name("e_chr");
var e_str := [str](e_int.reverse()).reverse().col_name("e_str");
var e_oid := [oid](e_int.reverse()).reverse().col_name("e_oid");


var tests := bat(bat,bat);
tests.insert(b_wrd.col_name("b_wrd"), e_wrd);
tests.insert(b_int.col_name("b_int"), e_int);
tests.insert(b_sht.col_name("b_sht"), e_sht);
tests.insert(b_bte.col_name("b_bte"), e_bte);
tests.insert(b_chr.col_name("b_chr"), e_chr);
tests.insert(b_str.col_name("b_str"), e_str);
tests.insert(v_oid.col_name("v_oid"), e_oid);

tests.insert(b_wrd.sort().col_name("s_wrd"), e_wrd);
tests.insert(b_int.sort().col_name("s_int"), e_int);
tests.insert(b_sht.sort().col_name("s_sht"), e_sht);
tests.insert(b_bte.sort().col_name("s_bte"), e_bte);
tests.insert(b_chr.sort().col_name("s_chr"), e_chr);
tests.insert(b_str.sort().col_name("s_str"), e_str);

proc ku(bat[any,any] b) : bat[any,any] {
	return kunique(b);
}

proc mstr(int i) : str {
	if (isnil(i)) {
		return "nil";
	}
	return str(i);
}

proc mset_print(bat[any,bat] m) :void {
    m@batloop() {
        var h := $h;
        var t := $t;
        t@batloop() {
            printf("\t%s\t%s\n", mstr(int(h)), mstr(int($t)));
        }
    }
}

proc set_print(bat[any,any] b) :void {
    b@batloop() {
        printf("\t%s\t%s\n", mstr(int($h)), mstr(int($t)));
    }
}

# start testing, switch mask that tells us which implementation is actually used
debugmask(131072);

tests@batloop() {
	printf("\n# test proc {kunique}(%s)\n", $h.bbpname());
	{ku}($h).mset_print();
}

tests@batloop() {
	printf("\n# test proc {kunique}(%s,%s)\n", $h.bbpname(), $t.bbpname());
	{ku}($h,$t).mset_print();
}

tests@batloop() {
	printf("\n# test packed {kunique}(%s)\n", $h.bbpname());
	{kunique}($h).mset_print();
}

tests@batloop() {
	printf("\n# test packed {max}(%s,%s)\n", $h.bbpname(), $t.bbpname());
	{max}($h,$t).set_print();
}

tests@batloop() {
	printf("\n# test direct {max}(%s)\n", $h.bbpname());
	{max}([int]($h)).set_print();
}

tests@batloop() {
	printf("\n# test direct {max}(%s,%s)\n", $h.bbpname(), $t.bbpname());
	{max}([int]($h),$t).set_print();
}

quit();
