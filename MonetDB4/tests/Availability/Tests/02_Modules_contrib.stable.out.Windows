stdout of test '02_Modules_contrib` in directory 'tests/Availability` itself:


# 06:00:18 >  
# 06:00:18 >   Mserver "--config=C:\cygwin\var\tmp\monet.Int.32.32.d.8719\MonetDB4\NT\conf\MonetDB.conf" --debug=10 --set "monet_mod_path=C:\cygwin\var\tmp\monet.Int.32.32.d.8719\MonetDB4\NT\src\modules\plain\.libs;C:\cygwin\var\tmp\monet.Int.32.32.d.8719\MonetDB4\NT\src\modules\plain;C:\cygwin\var\tmp\monet.Int.32.32.d.8719\MonetDB4\NT\src\modules\contrib\.libs;C:\cygwin\var\tmp\monet.Int.32.32.d.8719\MonetDB4\NT\src\modules\contrib;C:\cygwin\var\tmp\monet.Int.32.32.d.8719\MonetDB4\NT\src\modules\calibrator\.libs;C:\cygwin\var\tmp\monet.Int.32.32.d.8719\MonetDB4\NT\src\modules\calibrator;C:\cygwin\var\tmp\monet.Int.32.32.d.8719\MonetDB4\NT\src\mapi\.libs;C:\cygwin\var\tmp\monet.Int.32.32.d.8719\MonetDB4\NT\src\mapi;C:\cygwin\var\tmp\monet.Int.32.32.d.8719\MonetDB4\NT\src\modules\mnetcdf\.libs;C:\cygwin\var\tmp\monet.Int.32.32.d.8719\MonetDB4\NT\src\modules\mnetcdf;C:\cygwin\var\tmp\monet.Int.32.32.d.8719\MonetDB4\scripts\tools" --set "gdk_dbfarm=C:\cygwin\var\tmp\monet.Int.32.32.d.8719\MonetDB4\NT\dbfarm" --set "sql_logdir=C:\cygwin\var\tmp\monet.Int.32.32.d.8719\MonetDB4\NT\sql_logs" --set "xquery_logdir=C:\cygwin\var\tmp\monet.Int.32.32.d.8719\MonetDB4\NT\xquery_logs" --set mapi_open=true --set xrpc_open=true --set mapi_port=30048 --set xrpc_port=41800 --set monet_prompt= --trace --dbname=mTests_tests_Availability  
# 06:00:18 >  

# MonetDB Server v4.21.0
# based on GDK   v1.21.0
# Copyright (c) 1993-2007, CWI. All rights reserved.
# Compiled for i686-pc-win32/32bit with 32bit OIDs; dynamically linked.

# Visit http://monetdb.cwi.nl/ for further information.
setoid(oid(20000000));

var MODULES:=bat("MODULES");
var Static_fcn:=monet_fcntbl.reverse().copy();

var Fname:=new(oid,str);	Fname.col_name("function");
var FnameS:=new(oid,str);	FnameS.col_name("function");
var Ftype:=new(oid,str);	Ftype.col_name("type");
var Fsig:=new(oid,str);		Fsig.col_name("signature");
var Fhelp:=new(oid,str);	Fhelp.col_name("help");
var Fnts:=new(oid,str);

var Plain_mods:=MODULES.select("contrib").sort().copy();
table(Plain_mods.reverse().col_name(sprintf("%i modules",Plain_mods.count())));
#-----------------#
# 13 modules	  #
#-----------------#
[ "array"	  ]
[ "bat_cast"	  ]
[ "bat_mmath"	  ]
[ "bitset"	  ]
[ "color"	  ]
[ "image"	  ]
[ "malalgebra"	  ]
[ "mel"		  ]
[ "salgebra"	  ]
[ "txtsim"	  ]
[ "uchr"	  ]
[ "vector"	  ]
[ "wisc"	  ]
Plain_mods@batloop() {
	var The_mod:=$h;
	printf("\nModule: \"%s\"\n\n",The_mod);
	module($h);

	var Mod_fcn:=sdiff(monet_fcntbl.reverse(),Static_fcn).reverse();
	Mod_fcn.sort()@batloop() {
	    var addThis:=false;
	    if (not(monet_fcn_mid.exist($t))) {
		addThis:=true;
	    } else {
		var m:=monet_mod_nme.find(monet_fcn_mid.find($t));
		if (m.startsWith("_")) {
		    m:=string(m,1);
		}
		if (m = The_mod) {
		    addThis:=true;
		}
	    }
	    if (addThis) {
		var Tname:=$h;
		var Ttype:=help_tpe(monet_fcn_tpe.find($t));
		var Tsig:=format_fcn_sig($t);
		var Thelp:="";
		if (monet_fcn_dsc.exist($t)) {
			Thelp:=monet_fcn_dsc.find($t);
		} else {
			Thelp:="not available";
		}
		Fname.insert($t,Tname);
		Ftype.insert($t,Ttype);
		Fsig.insert($t,Tsig);
		Fhelp.insert($t,Thelp);
		Fnts.insert($t,sprintf("%s %s %s",Tname,Ttype,Tsig));
	    }
	}

	drop($h);
	Static_fcn:=sunion(Static_fcn,monet_fcntbl.reverse());

	Fnts.count().print();
	Fnts.reverse().sort().reverse()@batloop() {
		FnameS.insert($h,Fname.find($h));
	}
	FnameS.count().print(); table(1,FnameS,Ftype,Fsig,Fhelp);

	Fname.delete();
	FnameS.delete();
	Ftype.delete();
	Fsig.delete();
	Fhelp.delete();
	Fnts.delete();
}

Module: "array"

[ 5 ]
[ 5 ]
#---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------#
# function		type		signature								help									  # name
#---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------#
[ "concat",	  "PROC:      ",  "concat(BAT[oid,any::1], BAT[oid,any::1], int) : BAT[oid,any::1]",	  "Adds 'offset' two second arrays indexes and merges tables"		  ]
[ "cons",	  "PROC:      ",  "cons(int, any::1) : BAT[void,any::1]",				  "generates a bat with a constant column"				  ]
[ "grid",	  "COMMAND:   ",  "grid(int, int, int, int) : BAT[void,int]",				  "Generates an index BAT, (grpcount,grpsize,clustersize,offset)"	  ]
[ "grid",	  "COMMAND:   ",  "grid(lng, lng, lng, lng) : BAT[void,lng]",				  "Generates an index BAT, (grpcount,grpsize,clustersize,offset)"	  ]
[ "print_array",  "COMMAND:   ",  "print_array(BAT[any::1,any], ..BAT[any::1,int]..) : void",		  "Prints an array, using 1 value bat and N aligned index bats"		  ]

Module: "bat_cast"

[ 2 ]
[ 2 ]
#---------------------------------------------------------------------------------------------------------------------------------#
# function		type		signature				help							  # name
#---------------------------------------------------------------------------------------------------------------------------------#
[ "[dbl]",	  "COMMAND:   ",  "[dbl](BAT[void,int]) : BAT[void,dbl]", "optimized multiplexed dbl-cast on [void,int] BATs"	  ]
[ "[oid]",	  "COMMAND:   ",  "[oid](BAT[void,int]) : BAT[void,oid]", "optimized multiplexed oid-cast on [void,int] BATs"	  ]

Module: "bat_mmath"

[ 6 ]
[ 6 ]
#---------------------------------------------------------------------------------------------------------------------------------------------------------#
# function		type		signature						help								  # name
#---------------------------------------------------------------------------------------------------------------------------------------------------------#
[ "[exp]",	  "COMMAND:   ",  "[exp](BAT[void,dbl]) : BAT[void,dbl]",		  "optimized multiplexed exp on [void,dbl] BATs"		  ]
[ "[log]",	  "COMMAND:   ",  "[log](BAT[void,dbl]) : BAT[void,dbl]",		  "optimized multiplexed log on [void,dbl] BATs"		  ]
[ "[pow]",	  "COMMAND:   ",  "[pow](BAT[void,dbl], BAT[void,dbl]) : BAT[void,dbl]",  "optimized multiplexed pow on head-aligned [void,dbl] BATs"	  ]
[ "[pow]",	  "COMMAND:   ",  "[pow](BAT[void,dbl], dbl) : BAT[void,dbl]",		  "optimized multiplexed right-scalar pow on [void,dbl] BAT"	  ]
[ "[pow]",	  "COMMAND:   ",  "[pow](dbl, BAT[void,dbl]) : BAT[void,dbl]",		  "optimized multiplexed left-scalar pow on [void,dbl] BAT"	  ]
[ "[sqrt]",	  "COMMAND:   ",  "[sqrt](BAT[void,dbl]) : BAT[void,dbl]",		  "optimized multiplexed sqrt on [void,dbl] BATs"		  ]

Module: "bitset"

[ 13 ]
[ 13 ]
#-------------------------------------------------------------------------------------------------------------------------------------------------#
# function		| type		| signature					| help							  #
#-------------------------------------------------------------------------------------------------------------------------------------------------#
[ "bitset_and",		  "COMMAND:   ",  "bitset_and(bitset, bitset) : bitset",	  "AND this BitSet with an other BitSet."		  ]
[ "bitset_clearBit",	  "COMMAND:   ",  "bitset_clearBit(bitset, int) : bitset",	  "Clear the specified bit in this BitSet."		  ]
[ "bitset_flipBit",	  "COMMAND:   ",  "bitset_flipBit(bitset, int) : bitset",	  "Flip the specified bit in this BitSet."		  ]
[ "bitset_getBit",	  "COMMAND:   ",  "bitset_getBit(bitset, int) : bit",		  "Get the specified bit from this BitSet."		  ]
[ "bitset_not",		  "COMMAND:   ",  "bitset_not(bitset) : bitset",		  "NOT this BitSet."					  ]
[ "bitset_or",		  "COMMAND:   ",  "bitset_or(bitset, bitset) : bitset",		  "OR this BitSet with an other BitSet."		  ]
[ "bitset_setBit",	  "COMMAND:   ",  "bitset_setBit(bitset, int) : bitset",	  "Set the specified bit from this BitSet."		  ]
[ "bitset_toInt",	  "COMMAND:   ",  "bitset_toInt(bitset) : int",			  "Convert this BitSet to an integer."			  ]
[ "bitset_toStr",	  "PROC:      ",  "bitset_toStr(bitset) : str",			  "not available"					  ]
[ "bitset_xor",		  "COMMAND:   ",  "bitset_xor(bitset, bitset) : bitset",	  "XOR this BitSet with an other BitSet."		  ]
[ "newBitset",		  "COMMAND:   ",  "newBitset() : bitset",			  "Create a new empty BitSet."				  ]
[ "newBitset",		  "COMMAND:   ",  "newBitset(int) : bitset",			  "Create a new BitSet from an existing integer."	  ]
[ "test_bitset",	  "PROC:      ",  "test_bitset() : void",			  "not available"					  ]

Module: "color"

[ 12 ]
[ 12 ]
#-------------------------------------------------------------------------------------------------------------------------#
# function		type		signature			help							  # name
#-------------------------------------------------------------------------------------------------------------------------#
[ "blue",	  "COMMAND:   ",  "blue(color) : int",		  "Extracts blue component from a color atom"		  ]
[ "cb",		  "COMMAND:   ",  "cb(color) : int",		  "Extracts Cb(blue color) component from a color atom"	  ]
[ "cr",		  "COMMAND:   ",  "cr(color) : int",		  "Extracts Cr(red color) component from a color atom"	  ]
[ "green",	  "COMMAND:   ",  "green(color) : int",		  "Extracts green component from a color atom"		  ]
[ "hsv",	  "COMMAND:   ",  "hsv(flt, flt, flt) : color",	  "Converts an HSV triplets to a color atom"		  ]
[ "hue",	  "COMMAND:   ",  "hue(color) : flt",		  "Extracts hue component from a color atom"		  ]
[ "luminance",	  "COMMAND:   ",  "luminance(color) : int",	  "Extracts Y(luminance) component from a color atom"	  ]
[ "red",	  "COMMAND:   ",  "red(color) : int",		  "Extracts red component from a color atom"		  ]
[ "rgb",	  "COMMAND:   ",  "rgb(int, int, int) : color",	  "Converts an RGB triplets to a color atom"		  ]
[ "saturation",	  "COMMAND:   ",  "saturation(color) : flt",	  "Extracts saturation component from a color atom"	  ]
[ "value",	  "COMMAND:   ",  "value(color) : flt",		  "Extracts value component from a color atom"		  ]
[ "ycc",	  "COMMAND:   ",  "ycc(int, int, int) : color",	  "Converts an YCC triplets to a color atom"		  ]

Module: "image"

[ 0 ]
[ 0 ]
#-------------------------------------------------#
# function		type		signature		help			  # name
# str		str	str		str	  # type
#-------------------------------------------------#

Module: "malalgebra"

[ 30 ]
[ 30 ]
#-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------#
# function			type		signature									help																													  # name
# str			str		str										str																													  # type
#-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------#
[ "fetchjoin",		  "COMMAND:   ",  "fetchjoin(BAT[any::1,any::2], BAT[any::2,any::3]) : BAT[any::1,any::3]",	  "Hook directly into the 'fetchjoin' implementation of the join."																						  ]
[ "hashjoin",		  "COMMAND:   ",  "hashjoin(BAT[any::1,any::2], BAT[any::2,any::3]) : BAT[any::1,any::3]",	  "Hook directly into the 'hashjoin' implementation of the join."																						  ]
[ "leftfetchjoin",	  "COMMAND:   ",  "leftfetchjoin(BAT[any::1,any::2], BAT[any::2,any::3]) : BAT[any::1,any::3]",		  "Hook directly into the 'leftfetchjoin' implementation of the join.\n   prefix 'left' means that left and right input are not swapped during processing,\n   and hence, the order of the left input's head is maintained in the result. \nCAUTION: positional matches are assumed not to be out-of-bounds!!"															  ]
[ "lefthashjoin",	  "COMMAND:   ",  "lefthashjoin(BAT[any::1,any::2], BAT[any::2,any::3]) : BAT[any::1,any::3]",		  "Hook directly into the 'lefthashjoin' implementation of the join.\n   prefix 'left' means that left and right input are not swapped during processing,\n   and hence, the order of the left input's head is maintained in the result. "																							  ]
[ "leftjoin",		  "COMMAND:   ",  "leftjoin(BAT[any::1,any::2], BAT[any::2,any::3]) : BAT[any::1,any::3]",		  "Hook directly into the 'leftjoin' implementation of the join.\n   prefix 'left' means that left and right input are not swapped during processing,\n   and hence, the order of the left input's head is maintained in the result. "																								  ]
[ "leftmergejoin",	  "COMMAND:   ",  "leftmergejoin(BAT[any::1,any::2], BAT[any::2,any::3]) : BAT[any::1,any::3]",		  "Hook directly into the 'leftmergejoin' implementation of the join.\n   prefix 'left' means that left and right input are not swapped during processing,\n   and hence, the order of the left input's head is maintained in the result. "																							  ]
[ "leftthetajoin",	  "COMMAND:   ",  "leftthetajoin(BAT[any::1,any::2], BAT[any::2,any::3], int) : BAT[any::1,any::3]",	  "Hook directly into the 'leftthetajoin' implementation of the join.\n   prefix 'left' means that left and right input are not swapped during processing,\n   and hence, the order of the left input's head is maintained in the result."																							  ]
[ "mergejoin",		  "COMMAND:   ",  "mergejoin(BAT[any::1,any::2], BAT[any::2,any::3]) : BAT[any::1,any::3]",	  "Hook directly into the 'mergejoin' implementation of the join."																						  ]
[ "nlthetajoin",	  "COMMAND:   ",  "nlthetajoin(BAT[any::1,any::2], BAT[any::2,any::3], int, lng) : BAT[any::1,any::3]",	  "Hook directly into the 'nested-loop-thetajoin' implementation of the join.\n   prefix 'left' means that left and right input are not swapped during processing,\n   and hence, the order of the left input's head is maintained in the result.\n   Also, for each left tuple, all matching right tuples will appear in their order\n   of appearrance in the right BAT. This property is handy for XQuery processing."	  ]
[ "ord_select",		  "COMMAND:   ",  "ord_select(BAT[any::1,any::2], any::2) : BAT[any::1,any::2]",			  "Like standard 'select(b, value);', but preserves the order of the input BAT;\n (for the time being) this means, only the scan-based select algorithm is used."										  ]
[ "ord_select",		  "COMMAND:   ",  "ord_select(BAT[any::1,any::2], any::2, any::2) : BAT[any::1,any::2]",		  "Like standard 'select(b, low, high);', but preserves the order of the input BAT;\n (for the time being) this means, only the scan-based select algorithm is used."										  ]
[ "ord_select",		  "COMMAND:   ",  "ord_select(BAT[any::1,any::2], any::2, any::2, bit, bit) : BAT[any::1,any::2]",	  "Like standard 'select(b, low, high, l_in, h_in);', but preserves the order of the input BAT;\n (for the time being) this means, only the scan-based select algorithm is used."								  ]
[ "ord_uselect",	  "COMMAND:   ",  "ord_uselect(BAT[any::1,any::2], any::2) : BAT[any::1,void]",				  "Like standard 'uselect(b, value);', but preserves the order of the input BAT;\n (for the time being) this means, only the scan-based select algorithm is used."										  ]
[ "ord_uselect",	  "COMMAND:   ",  "ord_uselect(BAT[any::1,any::2], any::2, any::2) : BAT[any::1,void]",			  "Like standard 'uselect(b, low, high);', but preserves the order of the input BAT;\n (for the time being) this means, only the scan-based select algorithm is used."										  ]
[ "ord_uselect",	  "COMMAND:   ",  "ord_uselect(BAT[any::1,any::2], any::2, any::2, bit, bit) : BAT[any::1,void]",	  "Like standard 'uselect(b, low, high, l_in, h_in);', but preserves the order of the input BAT;\n (for the time being) this means, only the scan-based select algorithm is used."								  ]
[ "test_malalgebra",	  "PROC:      ",  "test_malalgebra() : void",							  "not available"						  ]
[ "{_csum}",		  "COMMAND:   ",  "{_csum}(BAT[oid,bte]) : BAT[oid,bte]",						  "grouped tail sum"																																																		  ]
[ "{_csum}",		  "COMMAND:   ",  "{_csum}(BAT[oid,dbl]) : BAT[oid,dbl]",					  "grouped tail sum"						  ]
[ "{_csum}",		  "COMMAND:   ",  "{_csum}(BAT[oid,flt]) : BAT[oid,flt]",					  "grouped tail sum"						  ]
[ "{_csum}",		  "COMMAND:   ",  "{_csum}(BAT[oid,int]) : BAT[oid,int]",					  "grouped tail sum"						  ]
[ "{_csum}",		  "COMMAND:   ",  "{_csum}(BAT[oid,lng]) : BAT[oid,lng]",					  "grouped tail sum"						  ]
[ "{_csum}",		  "COMMAND:   ",  "{_csum}(BAT[oid,sht]) : BAT[oid,sht]",					  "grouped tail sum"						  ]
[ "{_csum}",		  "COMMAND:   ",  "{_csum}(BAT[oid,wrd]) : BAT[oid,wrd]",						  "grouped tail sum"																																																		  ]
[ "{csum}",		  "PROC:      ",  "{csum}(BAT[oid,bte]) : BAT[oid,bte]",						  "Choose a different implementation if b is sorted on head."																																													  ]
[ "{csum}",		  "PROC:      ",  "{csum}(BAT[oid,dbl]) : BAT[oid,dbl]",					  "Choose a different implementation if b is sorted on head."	  ]
[ "{csum}",		  "PROC:      ",  "{csum}(BAT[oid,flt]) : BAT[oid,flt]",					  "Choose a different implementation if b is sorted on head."	  ]
[ "{csum}",		  "PROC:      ",  "{csum}(BAT[oid,int]) : BAT[oid,int]",					  "Choose a different implementation if b is sorted on head."	  ]
[ "{csum}",		  "PROC:      ",  "{csum}(BAT[oid,lng]) : BAT[oid,lng]",					  "Choose a different implementation if b is sorted on head."	  ]
[ "{csum}",		  "PROC:      ",  "{csum}(BAT[oid,sht]) : BAT[oid,sht]",					  "Choose a different implementation if b is sorted on head."	  ]
[ "{csum}",		  "PROC:      ",  "{csum}(BAT[oid,wrd]) : BAT[oid,wrd]",						  "Choose a different implementation if b is sorted on head."																																													  ]

Module: "mel"

[ 2 ]
[ 2 ]
#---------------------------------------------------------------------------------#
# function	| type		| signature		| help			  #
#---------------------------------------------------------------------------------#
[ "mel_test",	  "PROC:      ",  "mel_test() : void",	  "not available"	  ]
[ "test_mel",	  "PROC:      ",  "test_mel() : void",	  "not available"	  ]

Module: "salgebra"

[ 11 ]
[ 11 ]
#---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------#
# function		| type		| signature							| help									  #
#---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------#
[ "CHbat",		  "COMMAND:   ",  "CHbat(clusterhash) : BAT[void,any]",				  "Provides access to the original bat."				  ]
[ "CHdir",		  "PROC:      ",  "CHdir() : void",						  "List the clusterhash dictionary."					  ]
[ "clusterhash",	  "COMMAND:   ",  "clusterhash(BAT[any,any]) : clusterhash",			  "Build a new or get a previously built clusterhash for the input bat."  ]
[ "destroy",		  "COMMAND:   ",  "destroy(str) : void",					  "Destroy the clusterhash with name chname (if possible)."		  ]
[ "info",		  "COMMAND:   ",  "info(clusterhash) : BAT[str,str]",				  "Return some info about the chash."					  ]
[ "rename",		  "COMMAND:   ",  "rename(clusterhash, str) : void",				  "Try to name ch; fail upon error."					  ]
[ "select",		  "PROC:      ",  "select(clusterhash, any::1) : BAT[oid,any::1]",		  "Select using a clusterhash uselect plus a cast."			  ]
[ "test_salgebra",	  "PROC:      ",  "test_salgebra() : void",					  "not available"							  ]
[ "ujoin",		  "COMMAND:   ",  "ujoin(clusterhash, BAT[any,any]) : BAT[oid,void]",		  "Return join(ch, b).project(nil) with propagated clustering."		  ]
[ "uselect",		  "COMMAND:   ",  "uselect(clusterhash, any) : BAT[oid,void]",			  "Return select(ch, v).project(nil) with propagated clustering."		  ]
[ "usortedjoin",	  "COMMAND:   ",  "usortedjoin(clusterhash, BAT[any,any]) : BAT[oid,void]",	  "Return join(ch, b).project(nil).sort with propagated clustering."	  ]

Module: "txtsim"

[ 13 ]
[ 13 ]
#---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------#
# function			type		signature					help																	  # name
# str			str		str						str																	  # type
#---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------#
[ "editdistance",	  "COMMAND:   ",  "editdistance(str, str) : int",		  "Alias for Levenshtein(str,str)"													  ]
[ "editdistance2",	  "COMMAND:   ",  "editdistance2(str, str) : int",		  "Calculates Levenshtein distance (edit distance) between two strings. Cost of transposition is 1 instead of 2"			  ]
[ "levenshtein",	  "COMMAND:   ",  "levenshtein(str, str) : int",		  "Calculates Levenshtein distance (edit distance) between two strings"									  ]
[ "levenshtein",	  "COMMAND:   ",  "levenshtein(str, str, int, int, int) : int",	  "Calculates Levenshtein distance (edit distance) between two strings, variable operation costs (ins/del, replacement, transposition)"	  ]
[ "qgramnormalize",	  "COMMAND:   ",  "qgramnormalize(str) : str",												  "'Normalizes' strings (eg. toUpper and replaces non-alphanumerics with one space"							  ]
[ "qgramselect",	  "PROC:      ",  "qgramselect(BAT[void,oid], BAT[void,sht], BAT[void,sht], BAT[void,oid], BAT[void,str], str, flt, int) : BAT[flt,oid]", "not available"															  ]
[ "qgramselfjoin",	  "COMMAND:   ",  "qgramselfjoin(BAT[void,oid], BAT[void,int], BAT[void,int], BAT[void,int], flt, int) : BAT[int,int]",			  "QGram self-join on ordered(!) qgram tables and sub-ordered q-gram positions"								  ]
[ "qgramselfjoin_test",	  "PROC:      ",  "qgramselfjoin_test() : BAT[oid,oid]",										  "not available"															  ]
[ "similarity",		  "COMMAND:   ",  "similarity(str, str) : dbl",												  "Normalized edit distance between two strings"											  ]
[ "similarity",		  "COMMAND:   ",  "similarity(str, str, dbl) : dbl",											  "Normalized edit distance between two strings"											  ]
[ "soundex",		  "COMMAND:   ",  "soundex(str) : str",				  "Soundex function for phonetic matching"												  ]
[ "str2qgrams",		  "PROC:      ",  "str2qgrams(str) : BAT[oid,str]",											  "not available"															  ]
[ "stringdiff",		  "PROC:      ",  "stringdiff(str, str) : int",			  "not available"															  ]

Module: "uchr"

[ 1 ]
[ 1 ]
#---------------------------------------------------------------------------------#
# function		type		signature		help			  # name
# str		str		str			str			  # type
#---------------------------------------------------------------------------------#
[ "test_uchr",	  "PROC:      ",  "test_uchr() : void",	  "not available"	  ]

Module: "vector"

[ 140 ]
[ 140 ]
#-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------#
# function			| type		| signature							| help												  #
#-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------#
[ "*",				  "OPERATOR:  ",  "*(dbl_vector32, dbl) : dbl_vector32",			  "Multiplication of vector of dbls with scalar"						  ]
[ "*",				  "OPERATOR:  ",  "*(dbls, dbl) : dbls",					  "Multiplication of vector of dbls with scalar"						  ]
[ "*",				  "OPERATOR:  ",  "*(flts, flt) : flts",					  "Multiplication of vector of flts with scalar"						  ]
[ "*",				  "OPERATOR:  ",  "*(int_vector64, int) : int_vector64",			  "Multiplication of vector of ints with scalar"						  ]
[ "*",				  "OPERATOR:  ",  "*(ints, int) : ints",					  "Multiplication of vector of ints with scalar"						  ]
[ "+",				  "OPERATOR:  ",  "+(dbl_vector32, dbl_vector32) : dbl_vector32",		  "Addition of vectors of dbl_vector32"								  ]
[ "+",				  "OPERATOR:  ",  "+(dbls, dbls) : dbls",					  "Addition of vectors of dbls"									  ]
[ "+",				  "OPERATOR:  ",  "+(flts, flts) : flts",					  "Addition of vectors of flts"									  ]
[ "+",				  "OPERATOR:  ",  "+(int_vector64, int_vector64) : int_vector64",		  "Addition of vectors of int_vector64"								  ]
[ "+",				  "OPERATOR:  ",  "+(ints, ints) : ints",					  "Addition of vectors of ints"									  ]
[ "-",				  "OPERATOR:  ",  "-(dbl_vector32, dbl_vector32) : dbl_vector32",		  "Subtraction of vectors of dbls (param 1 - param 2)"						  ]
[ "-",				  "OPERATOR:  ",  "-(dbls, dbls) : dbls",					  "Subtraction of vectors of dbls (param 1 - param 2)"						  ]
[ "-",				  "OPERATOR:  ",  "-(flts, flts) : flts",					  "Subtraction of vectors of flts (param 1 - param 2)"						  ]
[ "-",				  "OPERATOR:  ",  "-(int_vector64, int_vector64) : int_vector64",		  "Subtraction of vectors of ints (param 1 - param 2)"						  ]
[ "-",				  "OPERATOR:  ",  "-(ints, ints) : ints",					  "Subtraction of vectors of ints (param 1 - param 2)"						  ]
[ "/",				  "OPERATOR:  ",  "/(dbl_vector32, dbl) : dbl_vector32",			  "Divide vector of dbls by dbl"								  ]
[ "/",				  "OPERATOR:  ",  "/(dbls, dbl) : dbls",					  "Divide vector of dbls by dbl"								  ]
[ "/",				  "OPERATOR:  ",  "/(flts, flt) : flts",					  "Divide vector of flts by flt"								  ]
[ "/",				  "OPERATOR:  ",  "/(int_vector64, int) : int_vector64",			  "Divide vector of ints by int"								  ]
[ "/",				  "OPERATOR:  ",  "/(ints, int) : ints",					  "Divide vector of ints by int"								  ]
[ "D1distance",			  "COMMAND:   ",  "D1distance(dbl_vector32, dbl_vector32) : dbl",		  "Calculates 'Relative' L1 distance between 2 vectors"						  ]
[ "D1distance",			  "COMMAND:   ",  "D1distance(dbls, dbls) : dbl",				  "Calculates 'Relative' L1 distance between 2 vectors"						  ]
[ "D1distance",			  "COMMAND:   ",  "D1distance(flts, flts) : dbl",				  "Calculates 'Relative' L1 distance between 2 vectors"						  ]
[ "D1distance",			  "COMMAND:   ",  "D1distance(int_vector64, int_vector64) : dbl",		  "Calculates 'Relative' L1 distance between 2 vectors"						  ]
[ "D1distance",			  "COMMAND:   ",  "D1distance(ints, ints) : dbl",				  "Calculates 'Relative' L1 distance between 2 vectors"						  ]
[ "IDdistance",			  "COMMAND:   ",  "IDdistance(dbl_vector32, dbl_vector32) : dbl",		  "Calculates Intersection distance between 2 vectors"						  ]
[ "IDdistance",			  "COMMAND:   ",  "IDdistance(dbls, dbls) : dbl",				  "Calculates Intersection (I) distance (D) between 2 vectors"					  ]
[ "IDdistance",			  "COMMAND:   ",  "IDdistance(flts, flts) : dbl",				  "Calculates Intersection (I) distance (D) between 2 vectors"					  ]
[ "IDdistance",			  "COMMAND:   ",  "IDdistance(int_vector64, int_vector64) : dbl",		  "Calculates Intersection distance between 2 vectors"						  ]
[ "IDdistance",			  "COMMAND:   ",  "IDdistance(ints, ints) : dbl",				  "Calculates Intersection (I) distance (D) between 2 vectors"					  ]
[ "KSdistance",			  "COMMAND:   ",  "KSdistance(dbl_vector32, dbl_vector32) : dbl",		  "Calculates Kolmogorov-Smirnov Coefficient between 2 vectors"					  ]
[ "KSdistance",			  "COMMAND:   ",  "KSdistance(dbls, dbls) : dbl",				  "Calculates Kolmogorov-Smirnov Coefficient between 2 vectors"					  ]
[ "KSdistance",			  "COMMAND:   ",  "KSdistance(flts, flts) : dbl",				  "Calculates Kolmogorov-Smirnov Coefficient between 2 vectors"					  ]
[ "KSdistance",			  "COMMAND:   ",  "KSdistance(int_vector64, int_vector64) : dbl",		  "Calculates Kolmogorov-Smirnov Coefficient between 2 vectors"					  ]
[ "KSdistance",			  "COMMAND:   ",  "KSdistance(ints, ints) : dbl",				  "Calculates Kolmogorov-Smirnov Coefficient between 2 vectors"					  ]
[ "L1distance",			  "COMMAND:   ",  "L1distance(dbl_vector32, dbl_vector32) : dbl",		  "Calculates 'absulte difference' distance between 2 vectors"					  ]
[ "L1distance",			  "COMMAND:   ",  "L1distance(dbls, dbls) : dbl",				  "Calculates 'absulte difference' distance between 2 vectors"					  ]
[ "L1distance",			  "COMMAND:   ",  "L1distance(flts, flts) : dbl",				  "Calculates 'absulte difference' distance between 2 vectors"					  ]
[ "L1distance",			  "COMMAND:   ",  "L1distance(int_vector64, int_vector64) : dbl",		  "Calculates 'absulte difference' distance between 2 vectors"					  ]
[ "L1distance",			  "COMMAND:   ",  "L1distance(ints, ints) : dbl",				  "Calculates 'absulte difference' distance between 2 vectors"					  ]
[ "L2distance",			  "COMMAND:   ",  "L2distance(dbl_vector32, dbl_vector32) : dbl",		  "Calculates Euclidean (L2) distance between 2 vectors"					  ]
[ "L2distance",			  "COMMAND:   ",  "L2distance(dbls, dbls) : dbl",				  "Calculates Euclidean (L2) distance between 2 vectors"					  ]
[ "L2distance",			  "COMMAND:   ",  "L2distance(flts, flts) : dbl",				  "Calculates Euclidean (L2) distance between 2 vectors"					  ]
[ "L2distance",			  "COMMAND:   ",  "L2distance(int_vector64, int_vector64) : dbl",		  "Calculates Euclidean (L2) distance between 2 vectors"					  ]
[ "L2distance",			  "COMMAND:   ",  "L2distance(ints, ints) : dbl",				  "Calculates Euclidean (L2) distance between 2 vectors"					  ]
[ "YLdistance",			  "COMMAND:   ",  "YLdistance(dbl_vector32, dbl_vector32) : dbl",		  "Calculates Yakimovsky Likelihood ratio between 2 vectors"					  ]
[ "YLdistance",			  "COMMAND:   ",  "YLdistance(dbls, dbls) : dbl",				  "Calculates Yakimovsky Likelihood ratio between 2 vectors"					  ]
[ "YLdistance",			  "COMMAND:   ",  "YLdistance(flts, flts) : dbl",				  "Calculates Yakimovsky Likelihood ratio between 2 vectors"					  ]
[ "YLdistance",			  "COMMAND:   ",  "YLdistance(int_vector64, int_vector64) : dbl",		  "Calculates Yakimovsky Likelihood ratio between 2 vectors"					  ]
[ "YLdistance",			  "COMMAND:   ",  "YLdistance(ints, ints) : dbl",				  "Calculates Yakimovsky Likelihood ratio between 2 vectors"					  ]
[ "acos",			  "PROC:      ",  "acos(flt) : flt",						  "not available"										  ]
[ "asin",			  "PROC:      ",  "asin(flt) : flt",						  "not available"										  ]
[ "atan",			  "PROC:      ",  "atan(flt) : flt",						  "not available"										  ]
[ "average",			  "COMMAND:   ",  "average(dbl_vector32) : dbl",				  "Calculates the average value of the vector elements."					  ]
[ "average",			  "COMMAND:   ",  "average(dbls) : dbl",					  "Calculates the average value of the vector elements."					  ]
[ "average",			  "COMMAND:   ",  "average(flts) : dbl",					  "Calculates the average value of the vector elements."					  ]
[ "average",			  "COMMAND:   ",  "average(int_vector64) : dbl",				  "Calculates the average value of the vector elements."					  ]
[ "average",			  "COMMAND:   ",  "average(ints) : dbl",					  "Calculates the average value of the vector elements."					  ]
[ "ceil",			  "PROC:      ",  "ceil(flt) : flt",						  "not available"										  ]
[ "centroid",			  "COMMAND:   ",  "centroid(dbl_vector32) : dbl",				  "Computes the centroid of the given vector"							  ]
[ "centroid",			  "COMMAND:   ",  "centroid(dbls) : dbl",					  "Computes the centroid of the given vector"							  ]
[ "centroid",			  "COMMAND:   ",  "centroid(flts) : dbl",					  "Computes the centroid of the given vector"							  ]
[ "centroid",			  "COMMAND:   ",  "centroid(int_vector64) : dbl",				  "Computes the centroid of the given vector"							  ]
[ "centroid",			  "COMMAND:   ",  "centroid(ints) : dbl",					  "Computes the centroid of the given vector"							  ]
[ "cos",			  "PROC:      ",  "cos(flt) : flt",						  "not available"										  ]
[ "cosh",			  "PROC:      ",  "cosh(flt) : flt",						  "not available"										  ]
[ "dbl_vector32_rancreate",	  "COMMAND:   ",  "dbl_vector32_rancreate() : dbl_vector32",			  "Creates random vector"									  ]
[ "dbls_rancreate",		  "COMMAND:   ",  "dbls_rancreate(int) : dbls",					  "Creates random vector"									  ]
[ "dimension",			  "COMMAND:   ",  "dimension(dbl_vector32) : int",				  "Retrieves the dimension of the vector"							  ]
[ "dimension",			  "COMMAND:   ",  "dimension(dbls) : int",					  "Retrieves the dimension of the vector"							  ]
[ "dimension",			  "COMMAND:   ",  "dimension(flts) : int",					  "Retrieves the dimension of the vector"							  ]
[ "dimension",			  "COMMAND:   ",  "dimension(int_vector64) : int",				  "Retrieves the dimension of the vector"							  ]
[ "dimension",			  "COMMAND:   ",  "dimension(ints) : int",					  "Retrieves the dimension of the vector"							  ]
[ "exp",			  "PROC:      ",  "exp(flt) : flt",						  "not available"										  ]
[ "floor",			  "PROC:      ",  "floor(flt) : flt",						  "not available"										  ]
[ "flts_rancreate",		  "COMMAND:   ",  "flts_rancreate(int) : flts",					  "Creates random vector"									  ]
[ "getval",			  "COMMAND:   ",  "getval(dbl_vector32, int) : dbl",				  "Project the Ith element value out of the vector."						  ]
[ "getval",			  "COMMAND:   ",  "getval(dbls, int) : dbl",					  "Project the Ith element value out of the vector."						  ]
[ "getval",			  "COMMAND:   ",  "getval(flts, int) : flt",					  "Project the Ith element value out of the vector."						  ]
[ "getval",			  "COMMAND:   ",  "getval(int_vector64, int) : int",				  "Project the Ith element value out of the vector."						  ]
[ "getval",			  "COMMAND:   ",  "getval(ints, int) : int",					  "Project the Ith element value out of the vector."						  ]
[ "int_vector64_rancreate",	  "COMMAND:   ",  "int_vector64_rancreate() : int_vector64",			  "Creates random vector"									  ]
[ "ints_rancreate",		  "COMMAND:   ",  "ints_rancreate(int) : ints",					  "Creates random vector"									  ]
[ "length",			  "COMMAND:   ",  "length(dbl_vector32) : dbl",					  "Computes the length of the vector"								  ]
[ "length",			  "COMMAND:   ",  "length(dbls) : dbl",						  "Computes the length of the vector"								  ]
[ "length",			  "COMMAND:   ",  "length(flts) : dbl",						  "Computes the length of the vector"								  ]
[ "length",			  "COMMAND:   ",  "length(int_vector64) : dbl",					  "Computes the length of the vector"								  ]
[ "length",			  "COMMAND:   ",  "length(ints) : dbl",						  "Computes the length of the vector"								  ]
[ "log",			  "PROC:      ",  "log(flt) : flt",						  "not available"										  ]
[ "log10",			  "PROC:      ",  "log10(flt) : flt",						  "not available"										  ]
[ "maxrange",			  "COMMAND:   ",  "maxrange(BAT[any,dbl_vector32]) : dbl_vector32",		  "Determines the 32 values of each dimension in the vectors."					  ]
[ "maxrange",			  "COMMAND:   ",  "maxrange(BAT[any,dbls]) : dbls",				  "Determine the max values of each dimension in the vectors."					  ]
[ "maxrange",			  "COMMAND:   ",  "maxrange(BAT[any,flts]) : flts",				  "Determine the max values of each dimension in the vectors."					  ]
[ "maxrange",			  "COMMAND:   ",  "maxrange(BAT[any,int_vector64]) : int_vector64",		  "Determines the 64 values of each dimension in the vectors."					  ]
[ "maxrange",			  "COMMAND:   ",  "maxrange(BAT[any,ints]) : ints",				  "Determine the max values of each dimension in the vectors."					  ]
[ "meanvector",			  "COMMAND:   ",  "meanvector(BAT[any,dbl_vector32]) : dbl_vector32",		  "Calculates mean vector of given set of vectors"						  ]
[ "meanvector",			  "COMMAND:   ",  "meanvector(BAT[any,dbls], int) : dbls",			  "Calculates mean vector of given set of vectors (Params: bat[vectors], dimension of vectors)"	  ]
[ "meanvector",			  "COMMAND:   ",  "meanvector(BAT[any,flts], int) : flts",			  "Calculates mean vector of given set of vectors (Params: bat[vectors], dimension of vectors)"	  ]
[ "meanvector",			  "COMMAND:   ",  "meanvector(BAT[any,ints], int) : flts",			  "Calculates mean vector of given set of vectors (Params: bat[vectors], dimension of vectors)"	  ]
[ "minrange",			  "COMMAND:   ",  "minrange(BAT[any,dbl_vector32]) : dbl_vector32",		  "Determines the 32 values of each dimension in the vectors."					  ]
[ "minrange",			  "COMMAND:   ",  "minrange(BAT[any,dbls]) : dbls",				  "Determine the min values of each dimension in the vectors."					  ]
[ "minrange",			  "COMMAND:   ",  "minrange(BAT[any,flts]) : flts",				  "Determine the min values of each dimension in the vectors."					  ]
[ "minrange",			  "COMMAND:   ",  "minrange(BAT[any,int_vector64]) : int_vector64",		  "Determines the 64 values of each dimension in the vectors."					  ]
[ "minrange",			  "COMMAND:   ",  "minrange(BAT[any,ints]) : ints",				  "Determine the min values of each dimension in the vectors."					  ]
[ "normalize",			  "COMMAND:   ",  "normalize(dbl_vector32) : dbl_vector32",			  "Normalizes vector"										  ]
[ "normalize",			  "COMMAND:   ",  "normalize(dbls) : dbls",					  "Normalizes vector"										  ]
[ "normalize",			  "COMMAND:   ",  "normalize(flts) : flts",					  "Normalizes vector"										  ]
[ "normalize",			  "COMMAND:   ",  "normalize(ints) : flts",					  "Normalizes vector"										  ]
[ "pi",				  "PROC:      ",  "pi() : dbl",							  "not available"										  ]
[ "sin",			  "PROC:      ",  "sin(flt) : flt",						  "not available"										  ]
[ "sinh",			  "PROC:      ",  "sinh(flt) : flt",						  "not available"										  ]
[ "sqrt",			  "PROC:      ",  "sqrt(flt) : flt",						  "not available"										  ]
[ "sum",			  "COMMAND:   ",  "sum(dbl_vector32) : dbl",					  "Calculates the sum of the vector elements."							  ]
[ "sum",			  "COMMAND:   ",  "sum(dbls) : dbl",						  "Calculates the sum of the vector elements."							  ]
[ "sum",			  "COMMAND:   ",  "sum(flts) : flt",						  "Calculates the sum of the vector elements."							  ]
[ "sum",			  "COMMAND:   ",  "sum(int_vector64) : int",					  "Calculates the sum of the vector elements."							  ]
[ "sum",			  "COMMAND:   ",  "sum(ints) : int",						  "Calculates the sum of the vector elements."							  ]
[ "tan",			  "PROC:      ",  "tan(flt) : flt",						  "not available"										  ]
[ "tanh",			  "PROC:      ",  "tanh(flt) : flt",						  "not available"										  ]
[ "test_vector",		  "PROC:      ",  "test_vector() : void",					  "not available"										  ]
[ "todbls",			  "COMMAND:   ",  "todbls(flts) : dbls",					  "Converts vectors of flts to vector of dbls"							  ]
[ "todbls",			  "COMMAND:   ",  "todbls(ints) : dbls",					  "Converts vectors of ints to vector of dbls"							  ]
[ "toflts",			  "COMMAND:   ",  "toflts(dbls) : flts",					  "Converts vectors of dbls to vector of flts"							  ]
[ "toflts",			  "COMMAND:   ",  "toflts(ints) : flts",					  "Converts vectors of ints to vector of flts"							  ]
[ "toints",			  "COMMAND:   ",  "toints(dbls) : ints",					  "Converts vectors of dbls to vector of ints"							  ]
[ "toints",			  "COMMAND:   ",  "toints(flts) : ints",					  "Converts vectors of flts to vector of ints"							  ]
[ "twonormdiff",		  "COMMAND:   ",  "twonormdiff(dbl_vector32, dbl_vector32) : dbl_vector32",	  "Calculates 2norm difference between 2 vectors"						  ]
[ "twonormdiff",		  "COMMAND:   ",  "twonormdiff(dbls, dbls) : dbls",				  "Calculates 2norm difference between 2 vectors"						  ]
[ "twonormdiff",		  "COMMAND:   ",  "twonormdiff(flts, flts) : flts",				  "Calculates 2norm difference between 2 vectors"						  ]
[ "twonormdiff",		  "COMMAND:   ",  "twonormdiff(ints, ints) : flts",				  "Calculates 2norm difference between 2 vectors"						  ]
[ "variance",			  "COMMAND:   ",  "variance(dbl_vector32) : dbl",				  "Calculates the variance of the vector elements."						  ]
[ "variance",			  "COMMAND:   ",  "variance(dbls) : dbl",					  "Calculates the variance of the vector elements."						  ]
[ "variance",			  "COMMAND:   ",  "variance(flts) : dbl",					  "Calculates the variance of the vector elements."						  ]
[ "variance",			  "COMMAND:   ",  "variance(int_vector64) : dbl",				  "Calculates the variance of the vector elements."						  ]
[ "variance",			  "COMMAND:   ",  "variance(ints) : dbl",					  "Calculates the variance of the vector elements."						  ]
[ "variance2",			  "COMMAND:   ",  "variance2(dbl_vector32) : dbl",				  "Calculates the squared variance of the vector elements."					  ]
[ "variance2",			  "COMMAND:   ",  "variance2(dbls) : dbl",					  "Calculates the squared variance of the vector elements."					  ]
[ "variance2",			  "COMMAND:   ",  "variance2(flts) : dbl",					  "Calculates the squared variance of the vector elements."					  ]
[ "variance2",			  "COMMAND:   ",  "variance2(int_vector64) : dbl",				  "Calculates the squared variance of the vector elements."					  ]
[ "variance2",			  "COMMAND:   ",  "variance2(ints) : dbl",					  "Calculates the squared variance of the vector elements."					  ]

Module: "wisc"

[ 2 ]
[ 2 ]
#-----------------------------------------------------------------------------------------------------------------#
# function	| type		| signature			| help						  #
#-----------------------------------------------------------------------------------------------------------------#
[ "wisc",	  "COMMAND:   ",  "wisc(str, int) : void",	  "Wisconsin Benchmark Database Generator"	  ]
[ "wiscdestroy",  "COMMAND:   ",  "wiscdestroy(str) : void",	  "WBD destroy table"				  ]

quit();

# 15:30:10 >  
# 15:30:10 >  Done.
# 15:30:10 >  

