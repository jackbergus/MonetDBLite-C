@/
The contents of this file are subject to the MonetDB Public License
Version 1.1 (the "License"); you may not use this file except in
compliance with the License. You may obtain a copy of the License at
http://www.monetdb.org/Legal/MonetDBLicense

Software distributed under the License is distributed on an "AS IS"
basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations
under the License.

The Original Code is the MonetDB Database System.

The Initial Developer of the Original Code is CWI.
Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
Copyright August 2008-2013 MonetDB B.V.
All Rights Reserved.
@

@f gdk_relop

@c
/*
 * @a M. L. Kersten, P. Boncz, S. Manegold
 * @* BAT relational operators
 * The basic relational operators are implemented for BATs.
 * Particular attention has been paid to speed-up processing
 * joins, such that navigational access and object re-assembly
 * are not being harmed too much.
 */
#include "monetdb_config.h"
#include "gdk.h"
#include "gdk_private.h"

#define SAMPLE_TRESHOLD_LOG 17
#define SAMPLE_SLICE_SIZE 1000

/*
 * @+ Join Algorithms
 * All join related operations have the same prelude to check
 * domain compatibility and to creates the BAT to hold the result.
 *
 * We do some dynamic effort to estimate the result size. Good
 * estimates enhance performance and reduce the memory hunger of the join.
 * Method: we sample on l, and join on the whole r. This macro is called by
 * the physical join algorithms, hence we already decided on the algorithm
 * and join method, so the initial costs on r (e.g. hash creation) would have
 * to be paid anyway, and are reused later in the real join phase.
 *
 * Sampling was made more robust by using a logarithmic number of slices
 * taken at equal-spaced intervals across l. The results are then analyzed
 * and checked for outliers. If outliers are present, a real sample is taken
 * and executed with the generic join algorithm to obtain an better estimate.
 *
 * On small joins we just assume 1-N joins with a limited (=3) hit rate.
 */

#define HLATOMput(bn, dst) ATOMput(bn->htype, bn->H->vheap, dst, BUNhloc(li,l_cur))
#define HVATOMput(bn, dst) Hputvalue(bn, dst, BUNhvar(li,l_cur), 1)
#define TLATOMput(bn, dst) ATOMput(bn->ttype, bn->T->vheap, dst, BUNtloc(ri,r_cur))
#define TVATOMput(bn, dst) Tputvalue(bn, dst, BUNtvar(ri,r_cur), 1)
#define LATOM_cmp(bn, p,n) atom_CMP(p, n, bn->ttype)
#define VATOM_cmp(bn, p,n) atom_CMP(p, n, bn->ttype)

@= SIMPLEput
#define H@1put(bn,dst)	*(@1*) (dst) = *(@1*) (BUNhloc(li,l_cur))
#define T@1put(bn,dst)	*(@1*) (dst) = *(@1*) (BUNtloc(ri,r_cur))
#define @1_cmp(bn,p,n)  simple_CMP(p, n, @1)
@
@c
@:SIMPLEput(bte)@
@:SIMPLEput(sht)@
@:SIMPLEput(int)@
@:SIMPLEput(flt)@
@:SIMPLEput(lng)@
@:SIMPLEput(dbl)@

@c
/*
 * @+ Cross Product
 * This operation computes the cross product of two BATs, returning only the
 * head-value from the 'left' operand and then tail-value from the 'right'
 * operand.
 */
@= cross2
static BAT *
cross_@1_@2(BAT *bn, BAT *l, BAT *r)
{
	BATiter li = bat_iterator(l);
	BATiter ri = bat_iterator(r);
	BATiter bni;
	BUN l_cur, l_end, r_cur, r_end, dst;

	/* Just to silence compilers (Intel's icc) that otherwise might
	 * complain about "declared but never referenced" labels
	 * (condition should never be true).
	 * (A "dead" goto between the return and the label makes (other)
	 * compilers (Sun) complain about never reached code...)
	 */
	if (!bn)
		goto bunins_failed;

	bni = bat_iterator(bn);
	dst = BUNfirst(bn);
	ALGODEBUG fprintf(stderr, "#BATcross: cross_@1_@2();\n");
	BATloop(l, l_cur, l_end) {
		BATloop(r, r_cur, r_end) {
			H@1put(bn, BUNhloc(bni, dst));
			T@2put(bn, BUNtloc(bni, dst));
			dst++;
		}
	}
	BATsetcount(bn, dst);

	return bn;

bunins_failed:
	BBPreclaim(bn);
	return NULL;
}
@= cross1
	@:cross2(@1,bte)@
	@:cross2(@1,sht)@
	@:cross2(@1,int)@
	@:cross2(@1,lng)@
	@:cross2(@1,VATOM)@
	@:cross2(@1,LATOM)@
@
@c
@:cross1(bte)@
@:cross1(sht)@
@:cross1(int)@
@:cross1(lng)@

@:cross1(VATOM)@
@:cross1(LATOM)@

@= cross_switch_rtt
{
	int rtt = r->ttype;
	int rts = ATOMstorage(rtt);

	if (rts == TYPE_bte) {
		bn = cross_@1_bte(bn, l, r);
	} else if (rts == TYPE_sht) {
		bn = cross_@1_sht(bn, l, r);
	} else if (rts == TYPE_int || rts == TYPE_flt
#if SIZEOF_OID == SIZEOF_INT
		   || rts == TYPE_oid
#endif
		) {
		bn = cross_@1_int(bn, l, r);
	} else if (rts == TYPE_lng || rts == TYPE_dbl
#if SIZEOF_OID == SIZEOF_LNG
		   || ATOMstorage(lht) == TYPE_oid
#endif
) {
		bn = cross_@1_lng(bn, l, r);
	} else if (r->tvarsized) {
		bn = cross_@1_VATOM(bn, l, r);
	} else {
		bn = cross_@1_LATOM(bn, l, r);
	}
}
@
@c
@= cross_switch_lht
{
	int lht = l->htype;
	int lhs = ATOMstorage(lht);

	if (lhs == TYPE_bte) {
		@:cross_switch_rtt(bte)@
	} else if (lhs == TYPE_sht) {
		@:cross_switch_rtt(sht)@
	} else if (lhs == TYPE_int || lhs == TYPE_flt
#if SIZEOF_OID == SIZEOF_INT
		   || lhs == TYPE_oid
#endif
		) {
		@:cross_switch_rtt(int)@
	} else if (lhs == TYPE_lng || lhs == TYPE_dbl
#if SIZEOF_OID == SIZEOF_LNG
		   || lhs == TYPE_oid
#endif
		   ) {
		@:cross_switch_rtt(lng)@
	} else if (l->hvarsized) {
		@:cross_switch_rtt(VATOM)@
	} else {
		@:cross_switch_rtt(LATOM)@
	}
}
@
@c
BAT *
BATcross(BAT *l, BAT *r)
{
	BAT *bn;
	BUN lc, rc, sz;

	ERRORcheck(l == NULL, "BATcross: invalid left operand");
	ERRORcheck(r == NULL, "BATcross: invalid right operand");
	lc = BATcount(l);
	rc = BATcount(r);
	sz = (BUN) MIN((lng) lc * rc, BUN_MAX);
	assert(sz <= BUN_MAX);

	if (sz > 0) {
		BATiter li = bat_iterator(l);
		BATiter ri = bat_iterator(r);

		/* try to keep void columns where possible */
		if (rc == 1)
			return BATconst(l, BATttype(r), BUNtail(ri, BUNfirst(r)));
		if (lc == 1)
			return BATmirror(BATconst(BATmirror(r), BAThtype(l), BUNhead(li, BUNfirst(l))));
	}

	bn = BATnew(BAThtype(l), BATttype(r), sz);
	if (bn == NULL)
		return bn;
	if (sz == 0)
		return bn;

	@:cross_switch_lht@

	if (bn) {
		bn->hsorted = l->hsorted;
		bn->hrevsorted = l->hrevsorted;
		bn->tsorted = lc == 1 && r->tsorted;
		bn->trevsorted = lc == 1 && r->trevsorted;
		bn->hdense = rc == 1 && l->hdense;
		bn->tdense = lc == 1 && r->tdense;
		BATkey(bn, rc == 1 && BAThkey(l));
		BATkey(BATmirror(bn), lc == 1 && BATtkey(r));
		if (!bn->batDirty)
			bn->batDirty = TRUE;
		bn->H->nonil = l->H->nonil;
		bn->T->nonil = r->T->nonil;
	}

	return bn;
}

/*
 * @+ Cartesian product
 * The matching algorithms tries to construct non-empty matches on all head
 * columns. Each time this succeeds, it calls the Cartesian routine to
 * construct a join result that consists of the Cartesian product of these
 * matches.
 *
 * The matching tuples can be encoded in two ways:
 * @table @samp
 * @item clustered
 *  here we have two BUN pointers 'hi' and 'lo' that point
 * to a consecutive range of BUNs in a BAT that match.
 * @item nonclustered here we have a hit pointer that points to an array
 * of BUN  pointers that match.
 * @end table
 * The below structures are used for keeping track of the matching process.
 */
typedef struct _column_t {
	BAT *b;			/* BAT of this column */
	BATiter bi;
	BUN cur;		/* current BUN in b */
	BUN nhits;		/* number of matched BUNs */

	/* clustered */
	BUN lo;			/* first BUN that matches */
	BUN hi;			/* past last BUN that matches */
	/* nonclustered */
	BUN *hit;		/* BUN array pointer */
	size_t hitsize;		/* size of hit array */

	/* properties */
/* I'm not sure whether offset can become negative, so to be on the
 * save side, use a signed type.  However the magnitude should be
 * within the range allowed by BUN, so the casts associated with this
 * value should be OK. */
	ssize_t offset;		/* BUNindex of BUNfirst  */
	struct _column_t *sync;	/* iff > 0: column with synchronous BAT */
	BUN size;		/* size of the BAT */
	char binsearch;		/* sparse matching expected? */
	char ordered;		/* merge matching */
} column_t;

typedef struct {
	RowFcn tuple_fcn;	/* function to invoke per match */
	ptr tuple_data;		/* application-specific data */
	ColFcn *value_fcn;	/* for each col: function to invoke per value */
	ptr *value_data;	/* for each col: application-specific data */
	column_t *c;		/* array of columns */
	int argc;		/* size of c */
} table_t;

static void
column_result(table_t *t, int i)
{
	if (++i > t->argc) {
		/* end of recursion: invoke tuple-match routine */
		t->tuple_fcn(t->tuple_data, t->value_data);
	} else {
		/* recurse over all matches on this column */
		column_t *c = t->c + (i - 1);
		BUN q, *p = c->hit;
		BUN j;

		if (p == NULL) {	/* clustered */
			for (q = c->lo; q < c->hi; q++) {
				t->value_fcn[i] (t->value_data[i], BUNtail(c->bi, q));
				column_result(t, i);
			}
		} else {
			for (j = 0; j < c->nhits; j++, p++) {
				t->value_fcn[i] (t->value_data[i], BUNtail(c->bi, *p));
				column_result(t, i);
			}
		}
	}
}

/*
 * @* MultiColumn Joins
 * Computes the n-ary equijoin over the head columns of multiple BATs.
 * This function is complex, and uses nested functions calls,
 * for the specific stuff, it uses the stack for generating the
 * Cartesian product on each hit tuple. Most of all, it emits tuples one
 * at a time, in a pipeline rather than bulk fashion. For all these reasons,
 * it is not main-memory efficient. It does things that MonetDB actually
 * specifically was designed to avoid.
 *
 * USE THIS FUNCTION ONLY WHEN YOU REALLY REALLY HAVE TO:
 * @table @code
 * @item  -
 * printing a multicolumn table to a watching end-user is one such example
 * @end table
 * @+ multijoin entry routine
 * The multijoin will cause a cascade of value_fcn() calls putting
 * values in to place, rounded off each time by a tuple_fcn() that is
 * executed on each produced tuple. If this corresponds 1-1 with
 * the elements of one of the parameter BAT, the 'result' of the
 * operation would be aligned with it.
 *
 * The return value of this operation contains this status information.
 * It is an integer, of which all 4 bytes are used:
 * @table @code
 * @item ret[0] == 1,
 * if a mergejoin was used, 0 otherwise
 * @item ret[1] == 1,
 * if all bats had the key property set, 0 otherwise
 * @item ret[2] == 1
 * if there was a 1-1 join, 0 otherwise
 * @item ret[3] ==
 * the parameter number of the BAT which was used as leader
 * @end table
 */
#define COLSIZE(c)\
	(((c)->b->htype!=TYPE_void || (c)->b->hseqbase!=oid_nil)?(c)->size:0)
#define REALLOCBUNS(c,n) if (c->hitsize <= n)\
	c->hit = (BUN*) GDKrealloc(c->hit, (c->hitsize+=n)*sizeof(BUN))

#define LEAD_INTERRUPT_END  1
#define LEAD_TRAVERSE_SSK   3	/* seq, sorted, key */
#define LEAD_TRAVERSE_SNK   4	/* seq, nonsorted, key */
#define LEAD_TRAVERSE_SEQ   6	/* enforced seq (for order purposes) */
#define LEAD_TRAVERSE_SRT   9	/* traverse by sorted chunk */

int
BATmultijoin(int argc, BAT *argv[], RowFcn tuple_fcn, ptr tuple_data, ColFcn value_fcn[], ptr value_data[], int orderby)
{
	column_t *lead_col, *c = (column_t *) GDKzalloc(argc * (int) sizeof(column_t));
	column_t **reorder = (column_t **) GDKmalloc(argc * (int) sizeof(column_t *));
	int status = 0, algo = LEAD_TRAVERSE_SEQ;
	int i, k;
	BUN p, q;
	table_t t;

	/*
	 * Init the table descriptor.
	 */
	if (c == NULL || reorder == NULL) {
		GDKfree(c);
		GDKfree(reorder);
		return 0;
	}
	t.tuple_data = tuple_data;
	t.value_data = value_data;
	t.tuple_fcn = tuple_fcn;
	t.value_fcn = value_fcn;
	t.argc = argc;
	t.c = c;
	/*
	 * order columns by their size (smallest first)
	 */
	for (i = 0; i < argc; i++) {
		int j;

		c[i].b = argv[i];
		c[i].bi = bat_iterator(c[i].b);
		c[i].nhits = 1;	/* default value */
		c[i].offset = (ssize_t) BUNfirst(c[i].b);
		c[i].size = BATcount(c[i].b);

		/* positional lookup possible => ignore other alternatives */
		if (!BAThdense(c[i].b))
			c[i].ordered = BAThordered(c[i].b);

		/* insertion sort on size */
		for (j = 0; j < i; j++) {
			if (COLSIZE(reorder[j]) > COLSIZE(c + i) ||
			    /* in case of equal size, we prefer dense over non-dense */
			    (COLSIZE(reorder[j]) == COLSIZE(c + i) && !BAThdense(reorder[j]->b) && BAThdense((c + i)->b))) {
				for (k = i; k > j; k--) {
					reorder[k] = reorder[k - 1];
				}
				break;
			}
		}
		reorder[j] = c + i;
	}
	/*
	 * @- handle explicit ordering requests
	 * An 'orderby' specification tells that the multijoin should
	 * match in the order of one specific BAT parameter.
	 *
	 * Notice that we *respect* the ordering of the orderby column
	 * rather than we sort it explicitly (ie; you should order the
	 * most significant column beforehand).  This allows for both
	 * for join results ordered on some tail column as results
	 * ordered on head column, or even 'reverse' or other specific
	 * orderings.  One such specific ordering is the SQL ORDER BY
	 * multi-column ordering that can be obtained with the
	 * CTorderby command from the xtables module.
	 */
	if (orderby) {		/* order on tail of some column */
		int lead = orderby - 1;

		for (i = 0; i < argc; i++)
			if (reorder[i] == c + lead)
				break;
		while (--i >= 0) {
			reorder[i + 1] = reorder[i];
		}
		reorder[0] = c + lead;
	}
	lead_col = reorder[0];
	/*
	 * @- lead column traversal mode
	 * The default action is to do LEAD_TRAVERSE_SEQ: 1-by-1
	 * traversal of the lead_col, and for each head value use the
	 * best possible matching algorithm.  A local optimization is
	 * to signal a sorted head column in the lead column, so we
	 * can switch to LEAD_TRAVERSE_SRT; if double lead values
	 * occur we do them in one match iteration.
	 *
	 * We record in MULTIJOIN_SORTED(status) whether the chosen
	 * traversal method visits the head values in the lead column
	 * in order. This is important for the matching algorithms of
	 * the other columns (only if the head values are visited in
	 * order, merge algorithms may be employed).
	 */
	if (BAThordered(lead_col->b)) {
		if (!BAThkey(lead_col->b)) {
			algo = LEAD_TRAVERSE_SRT;
		}
		MULTIJOIN_SORTED(status) = TRUE;
	}
	lead_col->hi = lead_col->cur = BUNfirst(lead_col->b);
	q = BUNlast(lead_col->b);
	MULTIJOIN_KEY(status) = (char) BAThkey(lead_col->b);
	MULTIJOIN_LEAD(status) = (char) (lead_col - c);
	MULTIJOIN_SYNCED(status) = 1;
	if (algo == LEAD_TRAVERSE_SEQ && BAThkey(lead_col->b)) {
		algo = BAThordered(lead_col->b) ? LEAD_TRAVERSE_SSK : LEAD_TRAVERSE_SNK;
	}

	/*
	 * @- matching algorithms for the other columns
	 * Finally, the issue of choosing matching-algorithms for the
	 * other columns is treated. There are a number of
	 * possibilities. If a column is synced with a previous
	 * column, this is registered, so it can copy the matching
	 * results of that previous column. If not, we use the fact
	 * that a column is ordered and if not, has an binary index on
	 * it. Both cases fall into two sub cases: merge-lookup or
	 * binary-search; depending on whether we visit the head
	 * elements in order (MULTIJOIN_SORTED(status)).  If none of
	 * this is the case, we do hash-lookup using an on-the-fly
	 * hash-table.
	 */
	for (k = 1; k < argc; k++) {
		column_t *n = reorder[k];
		int j;

		for (j = (algo == LEAD_TRAVERSE_SEQ); j < k; j++) {
			if (ALIGNsynced(reorder[j]->b, n->b)) {
				n->sync = (struct _column_t *) reorder[j];
				n->offset -= reorder[j]->offset;
			}
		}
		if (!BAThkey(n->b)) {
			MULTIJOIN_KEY(status) = 0;
			MULTIJOIN_SYNCED(status) = 0;
		}
		if (!MULTIJOIN_SORTED(status)) {
			if (n->size < 4 * lead_col->size) {
				n->ordered = FALSE;
			} else {
				n->binsearch = TRUE;
			}
		} else if (n->size > 40 * lead_col->size) {
			n->binsearch = TRUE;
		}
		if (n->ordered) {
			n->cur = BUNfirst(n->b);
		} else if (!BAThkey(n->b) && n->sync == NULL) {
			if (BATprepareHash(n->b)) {
				GDKerror("BATmultijoin: could not hash '%s'\n", BATgetId(n->b));
				GDKfree(c);
				GDKfree(reorder);
				return 0;
			}
			n->hitsize = 20;
			n->hit = (BUN *) GDKmalloc(n->hitsize * sizeof(BUN));
			if (n->hit == NULL) {
				GDKfree(c);
				GDKfree(reorder);
				return 0;
			}
		}
	}

/*
 * @- the matching phase
 * We optimize in the case that the head-columns are OID. Below
 * macro's help to separate the two cases cleanly.
 */
#if (SIZEOF_OID == SIZEOF_INT)
#define OIDcmp(v1,v2)	simple_CMP(v1,v2,int)
#else
#define OIDcmp(v1,v2)	simple_CMP(v1,v2,lng)
#endif
#define STDcmp(v1,v2)	(*cmp)(v1,v2)

	if (ATOMstorage(lead_col->b->htype) == ATOMstorage(TYPE_oid)) {
		@:multijoin(hloc,OID,_oid)@
	} else {
		int (*cmp) (const void *, const void *) = BATatoms[lead_col->b->htype].atomCmp;

		@:multijoin(head,STD,_any)@
	}
	/*
	 * Cleanup & exit.
	 */
	for (i = 0; i < argc; i++) {
		if (c[i].hitsize)
			GDKfree(c[i].hit);
	}
	GDKfree(c);
	GDKfree(reorder);
	return status;
}

/*
 * @+ The Matching Algorithm
 * In multi-column join, all MonetDB accelerators are put to use when
 * equi-lookup is done on a number of head columns.  In order of
 * preference, it:
 *
 * @itemize
 * @item
 *     does positional lookup on @emph{ virtual oid} columns (void).
 * @item
 *     reuses lookup info on @emph{ synced columns}.
 * @item
 *     uses merge scan on @emph{ ordered columns}.
 * @item
 *     uses binary tree leaf scan on @emph{ indexed columns}.
 * @item
 *     uses hash lookup in other cases. If a hash-table does not
 * exist; it is created on the fly.
 * @end itemize
 *
 * The algorithm goes one by one, for unique head values in the
 * smallest-sized BAT. The strategy is for each column to find a range
 * of BUNs that match it.
 *
 * The algorithm is intelligent in that it processes the columns in
 * order of cardinality. If a column has no matches, you can cut off
 * the matching process for the current ID (head value) and go to the
 * next. Smallest BATs first means highest miss probability first.
 *
 * Another optimization is that when a column has a cardinality much
 * larger than the smallest column, you can expect sparse matching
 * (e.g. you selected 1% tuples out of a 1M tuple BAT, and re-joins
 * both with this routine). In those cases the merge algorithms use
 * binary search instead of mergescan.
 *
 * In non-empty matching ranges are found in all head columns, a
 * recursive routine is used to go over all combinations of matching
 * BUNs. This recursive routine calls for every match (the Cartesian
 * product) a special-purpose routine that is passed all matching BUN
 * pointers. This sequence of calls represents the result of the
 * multijoin.
 *
 * Normally you want to perform an action on each value (like
 * formatting or copying), but many values reoccur in the same place
 * when the Cartesian product over all columns is formed.  For
 * instance, when we have 5 attributes in which each has 2 matches on
 * the current id, we have 2*2*2*2*2=32 result tuples for this one
 * id. A simple-minded strategy would then do 32*5 value actions, when
 * processing these result tuples. This multijoin reduces that to just
 * 32, by calling whenever a value is 'changed' in the
 * result-tuple-under-construction, a value specific function,
 * provided by the user. Since each column can have a different value
 * function, this also allows for factoring out type-checking
 * overhead.
 */
@= multijoin
	while (algo) {
		ptr h;		/* points to current ID */

		/*
		 * find the next leader bun
		 */
		p = lead_col->hi;
		if (p >= q)
			break;
		h = BUNhead(lead_col->bi, p);

		/* FIND MATCHING COLUMN RANGES
		 * For each column, find all matches for this head value
		 */
		for (i = 0; i < argc; i++) {
			column_t *m, *n = reorder[i];	/* use BATcount() order */
			BAT *b = n->b;
			BATiter bi = n->bi;

			/* one-by-one traversal of the lead column? => no matching done.
			 */
			if (n == lead_col) {
				if (argc > 1 && ATOMcmp(b->htype, h, ATOMnilptr(b->htype)) == 0) {
					n->lo = n->hi = p+1;
					break;
				} else if (algo <= LEAD_TRAVERSE_SEQ) {
					n->lo = p;
					n->hi = p+1;
					continue;
				}
			}
			/* Synced lookup
			 * If some BAT is synced with a BAT we already
			 * handled ('parent'), we can simply copy and
			 * convert the BUNlists of the parent.
			 */
			if ((m = n->sync) != NULL) {
				if (m->hit) {
					BUN j;

					REALLOCBUNS(n, m->nhits);
					for (j = 0; j < m->nhits; j++) {
						n->hit[j] = (BUN) (n->offset + m->hit[j]);
					}
					n->nhits = m->nhits;
				} else {
					n->lo = (BUN) (n->offset + m->lo);
					n->hi = (BUN) (n->offset + m->hi);
				}
				/* Sorted lookup
				 * We perform a merge scan over the tail column.
				 */
			} else if (n->ordered) {
				BUN last = BUNlast(b);

				if (n->binsearch) {
					n->cur = SORTfndfirst(BATmirror(b), h);
					if (n->cur >= last)
						break;	/* NOT FOUND */
				} else {
					int yy = 1;

					for (; n->cur < last; n->cur++)
						if ((yy = @2cmp(BUN@1(bi, n->cur), h)) >= 0)
							 break;

					if (yy != 0)
						break;	/* NOT FOUND */
				}
				n->lo = n->cur;
				for (n->nhits = 1; (++n->cur) < last; n->nhits++) {
					if (@2cmp(BUN@1(bi, n->cur), h))
						 break;
				}
				if (n->cur >= last && (algo & LEAD_INTERRUPT_END))
					algo = 0;
				n->hi = n->cur;
				/* Single Hash lookup
				 */
			} else if (BAThkey(n->b)) {
				BUNfnd@2(n->cur, bi, h);
				if (n->cur == BUN_NONE)
					break;	/* NOT FOUND */
				n->lo = n->cur;
				n->hi = n->cur+1;
				/* Multiple Hash lookup
				 */
			} else {
				BUN j;

				n->nhits = 0;
				HASHloop@3(bi, b->H->hash, j, h) {
					REALLOCBUNS(n, n->nhits + 1);
					n->hit[n->nhits++] = j;
				}
				if (n->nhits == 0)
					break;	/* NOT FOUND */
			}
		}
		/* Recursively print the Cartesian product of all
		 * match collections of h.
		 */
		if (i >= argc) {
			t.value_fcn[0] (t.value_data[0], h);
			column_result(&t, 0);
		} else {
			MULTIJOIN_SYNCED(status) = 0;	/* a miss occurred somewhere! */
		}
	}
	if (lead_col->hi < q) {
		MULTIJOIN_SYNCED(status) = 0;	/* an interrupt occurred! */
	}
@
