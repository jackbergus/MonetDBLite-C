@/
The contents of this file are subject to the MonetDB Public License
Version 1.1 (the "License"); you may not use this file except in
compliance with the License. You may obtain a copy of the License at
http://www.monetdb.org/Legal/MonetDBLicense

Software distributed under the License is distributed on an "AS IS"
basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations
under the License.

The Original Code is the MonetDB Database System.

The Initial Developer of the Original Code is CWI.
Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
Copyright August 2008-2013 MonetDB B.V.
All Rights Reserved.
@

@f gdk_relop

@c
/*
 * @a M. L. Kersten, P. Boncz, S. Manegold
 * @* BAT relational operators
 * The basic relational operators are implemented for BATs.
 * Particular attention has been paid to speed-up processing
 * joins, such that navigational access and object re-assembly
 * are not being harmed too much.
 */
#include "monetdb_config.h"
#include "gdk.h"
#include "gdk_private.h"

#define SAMPLE_TRESHOLD_LOG 17
#define SAMPLE_SLICE_SIZE 1000

/*
 * @+ Join Algorithms
 * All join related operations have the same prelude to check
 * domain compatibility and to creates the BAT to hold the result.
 *
 * We do some dynamic effort to estimate the result size. Good
 * estimates enhance performance and reduce the memory hunger of the join.
 * Method: we sample on l, and join on the whole r. This macro is called by
 * the physical join algorithms, hence we already decided on the algorithm
 * and join method, so the initial costs on r (e.g. hash creation) would have
 * to be paid anyway, and are reused later in the real join phase.
 *
 * Sampling was made more robust by using a logarithmic number of slices
 * taken at equal-spaced intervals across l. The results are then analyzed
 * and checked for outliers. If outliers are present, a real sample is taken
 * and executed with the generic join algorithm to obtain an better estimate.
 *
 * On small joins we just assume 1-N joins with a limited (=3) hit rate.
 */

#define HLATOMput(bn, dst) ATOMput(bn->htype, bn->H->vheap, dst, BUNhloc(li,l_cur))
#define HVATOMput(bn, dst) Hputvalue(bn, dst, BUNhvar(li,l_cur), 1)
#define TLATOMput(bn, dst) ATOMput(bn->ttype, bn->T->vheap, dst, BUNtloc(ri,r_cur))
#define TVATOMput(bn, dst) Tputvalue(bn, dst, BUNtvar(ri,r_cur), 1)
#define LATOM_cmp(bn, p,n) atom_CMP(p, n, bn->ttype)
#define VATOM_cmp(bn, p,n) atom_CMP(p, n, bn->ttype)

@= SIMPLEput
#define H@1put(bn,dst)	*(@1*) (dst) = *(@1*) (BUNhloc(li,l_cur))
#define T@1put(bn,dst)	*(@1*) (dst) = *(@1*) (BUNtloc(ri,r_cur))
#define @1_cmp(bn,p,n)  simple_CMP(p, n, @1)
@
@c
@:SIMPLEput(bte)@
@:SIMPLEput(sht)@
@:SIMPLEput(int)@
@:SIMPLEput(flt)@
@:SIMPLEput(lng)@
@:SIMPLEput(dbl)@

@c
/*
 * @+ Cross Product
 * This operation computes the cross product of two BATs, returning only the
 * head-value from the 'left' operand and then tail-value from the 'right'
 * operand.
 */
@= cross2
static BAT *
cross_@1_@2(BAT *bn, BAT *l, BAT *r)
{
	BATiter li = bat_iterator(l);
	BATiter ri = bat_iterator(r);
	BATiter bni;
	BUN l_cur, l_end, r_cur, r_end, dst;

	/* Just to silence compilers (Intel's icc) that otherwise might
	 * complain about "declared but never referenced" labels
	 * (condition should never be true).
	 * (A "dead" goto between the return and the label makes (other)
	 * compilers (Sun) complain about never reached code...)
	 */
	if (!bn)
		goto bunins_failed;

	bni = bat_iterator(bn);
	dst = BUNfirst(bn);
	ALGODEBUG fprintf(stderr, "#BATcross: cross_@1_@2();\n");
	BATloop(l, l_cur, l_end) {
		BATloop(r, r_cur, r_end) {
			H@1put(bn, BUNhloc(bni, dst));
			T@2put(bn, BUNtloc(bni, dst));
			dst++;
		}
	}
	BATsetcount(bn, dst);

	return bn;

bunins_failed:
	BBPreclaim(bn);
	return NULL;
}
@= cross1
	@:cross2(@1,bte)@
	@:cross2(@1,sht)@
	@:cross2(@1,int)@
	@:cross2(@1,lng)@
	@:cross2(@1,VATOM)@
	@:cross2(@1,LATOM)@
@
@c
@:cross1(bte)@
@:cross1(sht)@
@:cross1(int)@
@:cross1(lng)@

@:cross1(VATOM)@
@:cross1(LATOM)@

@= cross_switch_rtt
{
	int rtt = r->ttype;
	int rts = ATOMstorage(rtt);

	if (rts == TYPE_bte) {
		bn = cross_@1_bte(bn, l, r);
	} else if (rts == TYPE_sht) {
		bn = cross_@1_sht(bn, l, r);
	} else if (rts == TYPE_int || rts == TYPE_flt
#if SIZEOF_OID == SIZEOF_INT
		   || rts == TYPE_oid
#endif
		) {
		bn = cross_@1_int(bn, l, r);
	} else if (rts == TYPE_lng || rts == TYPE_dbl
#if SIZEOF_OID == SIZEOF_LNG
		   || ATOMstorage(lht) == TYPE_oid
#endif
) {
		bn = cross_@1_lng(bn, l, r);
	} else if (r->tvarsized) {
		bn = cross_@1_VATOM(bn, l, r);
	} else {
		bn = cross_@1_LATOM(bn, l, r);
	}
}
@
@c
@= cross_switch_lht
{
	int lht = l->htype;
	int lhs = ATOMstorage(lht);

	if (lhs == TYPE_bte) {
		@:cross_switch_rtt(bte)@
	} else if (lhs == TYPE_sht) {
		@:cross_switch_rtt(sht)@
	} else if (lhs == TYPE_int || lhs == TYPE_flt
#if SIZEOF_OID == SIZEOF_INT
		   || lhs == TYPE_oid
#endif
		) {
		@:cross_switch_rtt(int)@
	} else if (lhs == TYPE_lng || lhs == TYPE_dbl
#if SIZEOF_OID == SIZEOF_LNG
		   || lhs == TYPE_oid
#endif
		   ) {
		@:cross_switch_rtt(lng)@
	} else if (l->hvarsized) {
		@:cross_switch_rtt(VATOM)@
	} else {
		@:cross_switch_rtt(LATOM)@
	}
}
@
@c
/*
 * @+ Cartesian product
 * The matching algorithms tries to construct non-empty matches on all head
 * columns. Each time this succeeds, it calls the Cartesian routine to
 * construct a join result that consists of the Cartesian product of these
 * matches.
 *
 * The matching tuples can be encoded in two ways:
 * @table @samp
 * @item clustered
 *  here we have two BUN pointers 'hi' and 'lo' that point
 * to a consecutive range of BUNs in a BAT that match.
 * @item nonclustered here we have a hit pointer that points to an array
 * of BUN  pointers that match.
 * @end table
 * The below structures are used for keeping track of the matching process.
 */
BAT *
BATcross(BAT *l, BAT *r)
{
	BAT *bn;
	BUN lc, rc, sz;

	ERRORcheck(l == NULL, "BATcross: invalid left operand");
	ERRORcheck(r == NULL, "BATcross: invalid right operand");
	lc = BATcount(l);
	rc = BATcount(r);
	sz = (BUN) MIN((lng) lc * rc, BUN_MAX);
	assert(sz <= BUN_MAX);

	if (sz > 0) {
		BATiter li = bat_iterator(l);
		BATiter ri = bat_iterator(r);

		/* try to keep void columns where possible */
		if (rc == 1)
			return BATconst(l, BATttype(r), BUNtail(ri, BUNfirst(r)));
		if (lc == 1)
			return BATmirror(BATconst(BATmirror(r), BAThtype(l), BUNhead(li, BUNfirst(l))));
	}

	bn = BATnew(BAThtype(l), BATttype(r), sz);
	if (bn == NULL)
		return bn;
	if (sz == 0)
		return bn;

	@:cross_switch_lht@

	if (bn) {
		bn->hsorted = l->hsorted;
		bn->hrevsorted = l->hrevsorted;
		bn->tsorted = lc == 1 && r->tsorted;
		bn->trevsorted = lc == 1 && r->trevsorted;
		bn->hdense = rc == 1 && l->hdense;
		bn->tdense = lc == 1 && r->tdense;
		BATkey(bn, rc == 1 && BAThkey(l));
		BATkey(BATmirror(bn), lc == 1 && BATtkey(r));
		if (!bn->batDirty)
			bn->batDirty = TRUE;
		bn->H->nonil = l->H->nonil;
		bn->T->nonil = r->T->nonil;
	}

	return bn;
}
