<!--
The contents of this file are subject to the MonetDB Public License
Version 1.1 (the "License"); you may not use this file except in
compliance with the License. You may obtain a copy of the License at
http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html

Software distributed under the License is distributed on an "AS IS"
basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations
under the License.

The Original Code is the MonetDB Database System.

The Initial Developer of the Original Code is CWI.
Portions created by CWI are Copyright (C) 1997-2006 CWI.
All Rights Reserved.
-->

<html>
<body>
<p>
<i>Purpose of this document</i><br>
This document will help you execute the first SQL query on a MonetDB
database backend.
It assumes that you have compiled and installed both the
MonetDB back-end and SQL front-end according to the 'HowToStart' descriptions.
Furthermore, the sanity test checks included in the distribution
did do not produce fatal errors.
</p>
<p>
<i> Prerequisites:</i><br>
You should have a basic understanding of SQL syntax.
In particular, the SQL front-end is based on SQL-3
standard.
Furthermore, you should be able 
to start/stop de MonetDB database server on
a given database. 
</p>
<p>
<i>Getting started</i><br>
Before you start, make sure that both back-end and front-end can be found.
The command `which Mserver` and `which MapiClient` should return the proper path
to the binaries. Likewise, make sure the database directory exists and you 
have proper file access permissions.
</p>
<p>
The MonetDB server does not contain hardwired knowledge on its SQL frontend.
It must be initialized and told to accept SQL sessions. In a separate window
start the server for a new SQL database (named VOC);
</p>
<pre>
$ mkdir -p $PREFIX/var/MonetDB/dbfarm/VOC
$ Mserver --dbname=VOC 
# Monet Database Server V4.3.14
# Copyright (c) 1993-2005, CWI. All rights reserved.
# compiled for i686-pc-linux-gnu/32bit; dynamically linked.
monet>module(sql_server);
monet>
</pre>
<p>
Here $PREFIX denotes the path where MonetDB has been installed.
All databases are kept in $PREFIX/var/MonetDB/dbfarm unless this location
has been changed in the MonetDB.conf file.
<br>
The server is initialized by loading the SQL module. It will listen
to a default port for requests.
<br>
In case loading the SQL module ("sql_server") fails, this might be caused by
the fact, that Mserver fails to find the module. There are two possible
reasons for this:
<ol>
<li>The SQL frontend it not installed. Since the SQL frontend comes from a separate source repository,
it needs to be installed separately (unless you did install the binary package on Windows).
<li>The SQL frontend is installed, but in a difference place, i.e., with a different PREFIX, than MonetDB.
In this case, you need to tell the Mserver, where to find the sql_server module. You can do this by 
adding the following commandline switch when starting the Mserver:
<pre>
$ Mserver --dbname=VOC --set monet_mod_path=$MONETDB_PREFIX/lib/MonetDB:$SQL_PREFIX/lib/MonetDB
</pre>
$MONETDB_PREFIX & $SQL_PREFIX denote the pathes where MonetDB respectively SQL have been installed.
Alternatively, you can add $SQL_PREFIX/lib/MonetDB to the monet_mod_path in your MonetDB.conf file.
<br>
If you get an error message, e.g. 'port already in use', you might have 
obsolete Mserver processes hanging around which should be killed first.
</p>

<p><i>SQL Frontends</i><br>
The distribution comes with a simple textual interface with
command-line history features, called MapiClient.
The alternative, graphical interface is called Mknife and
described elsewhere.<br>
To connect to the running MonetDB SQL server using the
default authorization information, type:
</p>
<pre>
$ MapiClient [-p <sql_port>] -lsql -u monetdb -P monetdb
</pre>
<p>
To be assured of a proper SQL environment, you could inspect the catalog
tables as follows:
</p>
<pre>
sql> select name from tables;
# name # name
# varchar # type
# 12 # tuplecount
# 1 # id
# count 12
[ "schemas"     ]
[ "tables"      ]
[ "columns"     ]
[ "keys"        ]
[ "idxs"        ]
[ "keycolumns"  ]
[ "types"       ]
[ "users"       ]
[ "auths"       ]
[ "user_role"   ]
[ "table_privileges"    ]
[ "column_privileges"   ]
</pre>
<p>
The distribution comes with a small sample database for the historical
multinational VOC (United East-Indian Trading Company 1602-1799)
The schema is kept around in .../src/test/VOC where ... denotes the 
toplevel directory where you installed the sql frontend.<br>
The single table used in this example is created as follows:
</p>
<pre>
create table voyage(
sql>         number integer,
sql>         trip   integer,
sql>	      boatname varchar(25),
sql>         master varchar(25),
sql>         tonnage integer,
sql>         birth   varchar(10),
sql>         acquired integer,
sql>         yard    varchar(1),
sql>         chamber varchar(1),
sql>         departure       date,
sql>         harbour varchar(12),
sql>         cape_arrival date,
sql>         cape_departure date,
sql>         destination_arrival date,
sql>         destination_harbour varchar(12)
sql> );
</pre>
<p>
To load the database with a small sample and inspect its
content, use the commands:
</p>
<pre>
sql> copy 5 records into voyage from '.../src/test/VOC/VOCsample.csv'
sql> using delimiters ',','\n';
sql> select distinct boatname,master from voyage;
# boatname master # name
# varchar varchar # type
# 5 # tuplecount
[ "BRESLAU",       "Jan Kornelis Roos" ]
[ "LES DEUX SOEURS",       "Blankman" ]
[ "POTSDAM",       "Bernard Christiaan Muller" ]
[ "GERECHTIGHEID", "Isaak Segon" ]
[ "MAGDEBURG",     "Asuerus Brinkman" ]
sql>
</pre>

<p>
The VOC database in its full incarnation contains over 8000
records. To retrieve part of it, you have to use selection and order
by predicates. A few illustrative SQL statements are shown.
</p>
<pre>
sql> select boatname,destination_arrival from voyage order by destination_arrival;
# boatname destination_arrival # name
# varchar date # type
# 5 # tuplecount
[ "LES DEUX SOEURS",           nil ]
[ "BRESLAU",       	1783-08-06 ]
[ "POTSDAM",       	1783-08-09 ]
[ "MAGDEBURG",     	1783-09-05 ]
[ "GERECHTIGHEID", 	1783-11-08 ]
sql> create view R as select boatname as boot, tonnage as weight from voyage;
sql> select * from R;
# boot weight # name
# varchar int # type
# 5 # tuplecount
[ "BRESLAU",       	1150]
[ "LES DEUX SOEURS",	 582]
[ "POTSDAM",       	1150]
[ "GERECHTIGHEID", 	1150]
[ "MAGDEBURG",     	nil]
sql> select boatname from voyage where tonnage between 0 and 1000;
# boatname # name
# varchar # type
# 1 # tuplecount
[ "LES DEUX SOEURS" ]
sql> select boatname from voyage where tonnage is null;
# boatname # name
# varchar # type
# 1 # tuplecount
[ "MAGDEBURG" ]
sql>
sql> select sum(tonnage) from voyage;
# sum(tonnage) # name
# int # type
# 1 # tuplecount
sql> select sum(tonnage) from voyage where tonnage is not null;
# sum(tonnage) # name
# int # type
# 1 # tuplecount
[ 4032 ]
sql>
</pre>
<p><i> Views</i><br>
The result of a query can be saved in a new table as follows:
To avoid cluttering the database, we remove all the tuples in R
(or simply drop the table).
It expects each tuple to be represented on a separate line and
conforms to the MonetDB tuple format lexical structure.
You can specify the column value separator. The defaults is
</p>

<p><i>SQL-3 Limitations</i><br>
The current SQL implementation can be characterised as SQL-92++.
It is based on the syntax and semantics of SQL-3, but does not
implement the complete language. In particular, it does not yet
support ADTs, modules, and triggers. Likewise, some of the functionality
of extended datatypes (e.g. blobs) are not included in the MonetDB
server libraries.
</p>
<p><i>Documentation</i><br> <br>
The documentation starts in <monet_dir>/doc/monet.html
NOTE: the current 'make install' does not yet generate this
      documentation to do this manually, execute *after* successful
      'make install'. In the top-level directory of the MonetDB build
      tree, call

 make html

</p>

<p><i>Troubleshooting</i><br>
The current implementation is a beta version, which means that occasionally 
you encounter bugs reported at the back-end. This may lead to a hanging
front-end as well. To illustrate, the next statement
</p>
</body>
</html>

