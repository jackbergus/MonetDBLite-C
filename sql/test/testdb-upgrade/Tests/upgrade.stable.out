stdout of test 'upgrade` in directory 'sql/test/testdb-upgrade` itself:


# 21:49:40 >  
# 21:49:40 >  "mserver5" "--debug=10" "--set" "gdk_nr_threads=0" "--set" "mapi_open=true" "--set" "mapi_port=30515" "--set" "mapi_usock=/var/tmp/mtest-14642/.s.monetdb.30515" "--set" "monet_prompt=" "--forcemito" "--set" "mal_listing=2" "--dbpath=/ufs/sjoerd/Monet-devel/var/MonetDB/mTests_sql_test_testdb-upgrade" "--set" "mal_listing=0"
# 21:49:40 >  

# MonetDB 5 server v11.16.0 (hg id: fd9db07674cf+)
# This is an unreleased version
# Serving database 'mTests_sql_test_testdb-upgrade', using 8 threads
# Compiled for x86_64-unknown-linux-gnu/64bit with 64bit OIDs dynamically linked
# Found 15.591 GiB available main-memory.
# Copyright (c) 1993-July 2008 CWI.
# Copyright (c) August 2008-2014 MonetDB B.V., all rights reserved
# Visit http://www.monetdb.org/ for further information


Ready.
Running database upgrade commands:
set schema "sys";
drop procedure sys.resetHistory;
drop procedure sys.keepCall;
drop procedure sys.keepQuery;
update sys._tables set system = false where name in ('callhistory','queryhistory','querylog') and schema_id = (select id from sys.schemas where name = 'sys');
drop view sys.queryLog;
drop table sys.callHistory;
drop table sys.queryHistory;
create function sys.querylog_catalog()
returns table(
	id oid,
	owner string,
	defined timestamp,
	query string,
	pipe string,
	mal int,			-- size of MAL plan
	optimize bigint 	-- time in usec
)
external name sql.querylog_catalog;

create function sys.querylog_calls()
returns table(
	id oid,				 -- references query plan
	"start" timestamp,	-- time the statement was started
	"stop" timestamp,	-- time the statement was completely finished
	arguments string,	-- actual call structure
	tuples wrd,			-- number of tuples in the result set
	run bigint,		-- time spent (in usec)  until the result export
	ship bigint,		-- time spent (in usec)  to ship the result set
	cpu int,  		-- average cpu load percentage during execution
	io int,			-- percentage time waiting for IO to finish 
	space bigint		-- total storage size of intermediates created (in MB)
)
external name sql.querylog_calls;

create view sys.querylog_catalog as select * from sys.querylog_catalog();
create view sys.querylog_calls as select * from sys.querylog_calls();
create view sys.querylog_history as
select qd.*, ql."start",ql."stop", ql.arguments, ql.tuples, ql.run, ql.ship, ql.cpu, ql.space, ql.io 
from sys.querylog_catalog() qd, sys.querylog_calls() ql
where qd.id = ql.id and qd.owner = user;

update sys._tables
    set system = true
    where name in ('querylog_history', 'querylog_calls', 'querylog_catalog')
        and schema_id = (select id from sys.schemas where name = 'sys');

create procedure sys.querylog_empty()
external name sql.querylog_empty;

create procedure sys.querylog_enable()
external name sql.querylog_enable;
create procedure sys.querylog_enable(threshold smallint)
external name sql.querylog_enable_threshold;
create procedure sys.querylog_disable()
external name sql.querylog_disable;
create view sys.tracelog as select * from sys.tracelog();
drop function sys.clients;
create function sys.sessions() returns table("user" string, "login" timestamp, "sessiontimeout" bigint, "lastcommand" timestamp, "querytimeout" bigint, "active" bool) external name sql.sessions;
create view sys.sessions as select * from sys.sessions();
create procedure sys.shutdown(delay tinyint) external name sql.shutdown;
create procedure sys.shutdown(delay tinyint, force bool) external name sql.shutdown;
create procedure sys.settimeout("query" bigint) external name sql.settimeout;
create procedure sys.settimeout("query" bigint, "session" bigint) external name sql.settimeout;
create procedure sys.setsession("timeout" bigint) external name sql.setsession;
create view sys.optimizers as select * from sys.optimizers();
create view sys.environment as select * from sys.environment();
create function sys.queue()
returns table(
	qtag bigint,
	"user" string,
	started timestamp,
	estimate timestamp,
	progress int,
	status string,
	tag oid,
	query string
)
external name sql.sysmon_queue;

create view sys.queue as select * from sys.queue();
update sys._tables
    set system = true
    where name = 'queue'
        and schema_id = (select id from sys.schemas where name = 'sys');

create procedure sys.pause(tag int)
external name sql.sysmon_pause;
create procedure sys.resume(tag int)
external name sql.sysmon_resume;
create procedure sys.stop(tag int)
external name sql.sysmon_stop;

create procedure sys.pause(tag bigint)
external name sql.sysmon_pause;
create procedure sys.resume(tag bigint)
external name sql.sysmon_resume;
create procedure sys.stop(tag bigint)
external name sql.sysmon_stop;
create aggregate quantile(val TINYINT, q DOUBLE) returns TINYINT external name "aggr"."quantile";
create aggregate quantile(val SMALLINT, q DOUBLE) returns SMALLINT external name "aggr"."quantile";
create aggregate quantile(val INTEGER, q DOUBLE) returns INTEGER external name "aggr"."quantile";
create aggregate quantile(val WRD, q DOUBLE) returns WRD external name "aggr"."quantile";
create aggregate quantile(val BIGINT, q DOUBLE) returns BIGINT external name "aggr"."quantile";
create aggregate quantile(val DECIMAL, q DOUBLE) returns DECIMAL external name "aggr"."quantile";
create aggregate quantile(val REAL, q DOUBLE) returns REAL external name "aggr"."quantile";
create aggregate quantile(val DOUBLE, q DOUBLE) returns DOUBLE external name "aggr"."quantile";
create aggregate quantile(val DATE, q DOUBLE) returns DATE external name "aggr"."quantile";
create aggregate quantile(val TIME, q DOUBLE) returns TIME external name "aggr"."quantile";
create aggregate quantile(val TIMESTAMP, q DOUBLE) returns TIMESTAMP external name "aggr"."quantile";
create aggregate median(val DECIMAL) returns DECIMAL external name "aggr"."median";
create view sys.storage as select * from sys.storage();
create view sys.storagemodel as select * from sys.storagemodel();
CREATE TABLE sys.statistics(
	"schema" string, 
	"table" string, 
	"column" string, 
	"type" string, 
	width integer,
	stamp timestamp, 
	"sample" bigint, 
	"count" bigint, 
	"unique" bigint, 
	"nils" bigint, 
	minval string, 
	maxval string,
	sorted boolean);

update sys._tables
	set system = true
	where name = 'statistics'
		and schema_id = (select id from sys.schemas where name = 'sys');

create procedure analyze()
external name sql.analyze;

create procedure analyze(tbl string)
external name sql.analyze;

create procedure analyze(sch string, tbl string)
external name sql.analyze;

create procedure analyze(sch string, tbl string, col string)
external name sql.analyze;

create procedure analyze("sample" bigint)
external name sql.analyze;

create procedure analyze(tbl string, "sample" bigint)
external name sql.analyze;

create procedure analyze(sch string, tbl string, "sample" bigint)
external name sql.analyze;

create procedure analyze(sch string, tbl string, col string, "sample" bigint)
external name sql.analyze;
insert into sys.systemfunctions (select f.id from sys.functions f, sys.schemas s where f.name in ('json_filter', 'json_filter_all', 'json_isvalid', 'json_isvalidarray', 'json_isvalidobject', 'json_length', 'json_path', 'json_text', 'querylog_calls', 'querylog_catalog', 'queue', 'sessions') and f.type = 1 and f.schema_id = s.id and s.name = 'sys');
insert into sys.systemfunctions (select f.id from sys.functions f, sys.schemas s where f.name in ('analyze', 'pause', 'querylog_disable', 'querylog_empty', 'querylog_enable', 'resume', 'setsession', 'settimeout', 'shutdown', 'stop', 'sysmon_resume') and f.type = 2 and f.schema_id = s.id and s.name = 'sys');
insert into sys.systemfunctions (select f.id from sys.functions f, sys.schemas s where f.name in ('quantile', 'median') and f.type = 3 and f.schema_id = s.id and s.name = 'sys');
update sys._tables set system = true where name in ('environment', 'optimizers', 'queue', 'sessions', 'statistics', 'storage', 'storagemodel', 'tracelog') and schema_id = (select id from sys.schemas where name = 'sys');
set schema "testschema";

Running database upgrade commands:
set schema "sys";
-- The contents of this file are subject to the MonetDB Public License
-- Version 1.1 (the "License"); you may not use this file except in
-- compliance with the License. You may obtain a copy of the License at
-- http://www.monetdb.org/Legal/MonetDBLicense
--
-- Software distributed under the License is distributed on an "AS IS"
-- basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
-- License for the specific language governing rights and limitations
-- under the License.
--
-- The Original Code is the MonetDB Database System.
--
-- The Initial Developer of the Original Code is CWI.
-- Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
-- Copyright August 2008-2014 MonetDB B.V.
-- All Rights Reserved.

-- (co) Martin Kersten
-- The JSON type comes with a few operators.

create schema json;

create type json external name json;

-- access the top level key by name, return its value
create function json.filter(js json, pathexpr string)
returns json external name json.filter;

create function json.filter(js json, name tinyint)
returns json external name json.filter;

create function json.filter(js json, name integer)
returns json external name json.filter;

create function json.filter(js json, name bigint)
returns json external name json.filter;

create function json.text(js json, e string)
returns string external name json.text;

-- test string for JSON compliancy
create function json.isvalid(js string)
returns bool external name json.isvalid;

create function json.isobject(js string)
returns bool external name json.isobject;

create function json.isarray(js string)
returns bool external name json.isarray;

create function json.isvalid(js json)
returns bool external name json.isvalid;

create function json.isobject(js json)
returns bool external name json.isobject;

create function json.isarray(js json)
returns bool external name json.isarray;

-- return the number of primary components
create function json.length(js json)
returns integer external name json.length;

create function json.keyarray(js json)
returns json external name json.keyarray;

create function json.valuearray(js json)
returns  json external name json.valuearray;

create function json.text(js json)
returns string external name json.text;

-- The remainder awaits the implementation 

-- create function json.object(*) returns json external name json.objectrender;

-- create function json.array(*) returns json external name json.arrayrender;

-- unnesting the JSON structure

-- create function json.unnest(js json)
-- returns table( id integer, k string, v string) external name json.unnest;

-- create function json.unnest(js json)
-- returns table( k string, v string) external name json.unnest;

-- create function json.unnest(js json)
-- returns table( v string) external name json.unnest;

-- create function json.nest table( id integer, k string, v string)
-- returns json external name json.nest;


create function sys.md5(v string) returns string external name clients.md5sum;
create type uuid external name uuid;
create function sys.uuid() returns uuid external name uuid."new";
create function sys.isaUUID(u uuid) returns uuid external name uuid."isaUUID";
insert into sys.systemfunctions (select f.id from sys.functions f, sys.schemas s where f.name in ('isauuid', 'md5', 'uuid') and f.type = 1 and f.schema_id = s.id and s.name = 'sys');
set schema "testschema";


# 21:49:41 >  
# 21:49:41 >  "/usr/bin/python2" "upgrade.SQL.py" "upgrade"
# 21:49:41 >  

#select count(*) from testschema.smallstring;
% testschema.L1 # table_name
% L1 # name
% wrd # type
% 2 # length
[ 66	]

# 21:49:42 >  
# 21:49:42 >  "Done."
# 21:49:42 >  

