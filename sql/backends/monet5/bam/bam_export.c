/*
 * The contents of this file are subject to the MonetDB Public License
 * Version 1.1 (the "License"); you may not use this file except in
 * compliance with the License. You may obtain a copy of the License at
 * http://www.monetdb.org/Legal/MonetDBLicense
 *
 * Software distributed under the License is distributed on an "AS IS"
 * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
 * License for the specific language governing rights and limitations
 * under the License.
 *
 * The Original Code is the MonetDB Database System.
 *
 * The Initial Developer of the Original Code is CWI.
 * Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
 * Copyright August 2008-2014 MonetDB B.V.
 * All Rights Reserved.
 */

/*
 * (author) R Cijvat
 * The code in this file defines export functionality, that enables
 * users to write data from the bam.export table to a SAM or BAM file.
 * After exporting data, the exporting functions will automatically
 * empty the bam.export table.
 */
 
#include "monetdb_config.h"

#include "bam_globals.h"
#include "bam_export.h"


typedef struct bam_field {
    str name;
    sql_column *c;
    BAT *b;
    BATiter iter;
    BUN cur;
} bam_field;


#define CUR_STR(field, i) ((str) BUNtail(field.iter, (field.cur+i)))
#define CUR_SHT(field, i) (*(sht *) BUNtail(field.iter, (field.cur+i)))
#define CUR_INT(field, i) (*(int *) BUNtail(field.iter, (field.cur+i)))

str 
sam_export(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
    /* arg 1: path to desired output file */
	str output_path = *(str *) getArgReference(stk, pci, pci->retc);
    
    mvc *m;
    sql_schema *s_bam;
    sql_table *t_export;
    bam_field fields[11];
    
    stream *output = NULL;
    
    int cnt, i;
    str msg = MAL_SUCCEED;
    
    memset(fields, 0, 11 * sizeof(bam_field));
    
    if ((output = bsopen(output_path)) == NULL) {
        msg = createException(MAL, "sam_export", "Could not open output file '%s' for writing", output_path);
        goto cleanup;
    }
    
    if ((msg = getSQLContext(cntxt, mb, &m, NULL)) != MAL_SUCCEED) {
        REUSE_EXCEPTION(msg, MAL, "sam_export", "Could not retrieve SQL context: %s", msg);
        goto cleanup;
	}
    
    if ((s_bam = mvc_bind_schema(m, "bam")) == NULL) {
        msg = createException(MAL, "sam_export", "Could not find bam schema");
        goto cleanup;
    }
    
    if ((t_export = mvc_bind_table(m, s_bam, "export")) == NULL) {
        msg = createException(MAL, "sam_export", "Could not find bam.export table");
        goto cleanup;
    }
    
    fields[0].name = "qname";
    fields[1].name = "flag";
    fields[2].name = "rname";
    fields[3].name = "pos";
    fields[4].name = "mapq";
    fields[5].name = "cigar";
    fields[6].name = "rnext";
    fields[7].name = "pnext";
    fields[8].name = "tlen";
    fields[9].name = "seq";
    fields[10].name = "qual";
    
    for (i=0; i<11; ++i) {
        int cnt_tmp;
        if ((fields[i].c = mvc_bind_column(m, t_export, fields[i].name)) == NULL) {
            msg = createException(MAL, "sam_export", "Could not find bam.export.%s column", fields[i].name);
            goto cleanup;
        }
        if ((fields[i].b = store_funcs.bind_col(m->session->tr, fields[i].c, RDONLY)) == NULL) {
            msg = createException(MAL, "sam_export", RUNTIME_OBJECT_MISSING);
            goto cleanup;
        }
        cnt_tmp = BATcount(fields[i].b);
        if (cnt_tmp <= 0) {
            msg = createException(MAL, "sam_export", "The bam.export table is empty");
            goto cleanup;
        }
        if (i > 0 && cnt != cnt_tmp) {
            msg = createException(MAL, "sam_export", "Misalignment in bam.export table: "
                    "column '%s' has %d values; expected %d",
                    fields[i].name, cnt_tmp, cnt);
            goto cleanup;
        }
        cnt = cnt_tmp;
        fields[i].iter = bat_iterator(fields[i].b);
        fields[i].cur = BUNfirst(fields[i].b);
    }
    
    /* Build header */
    mnstr_printf(output, "@HD VN:1.0 SO:%s\n",
            BATtordered(fields[0].b) ? "queryname" : 
                (BATordered(fields[2].b) && BATordered(fields[3].b) ? "coordinate" : 
                    "unsorted"));
                    
    /* TODO: Build SQ tags */
                    
    mnstr_printf(output, "@CO SAM file generated by MonetDB\n");
    
    
    for (i=0; i<cnt; ++i) {
        mnstr_printf(output, "%s\t%d\t%s\t%d\t%d\t%s\t%s\t%d\t%d\t%s\t%s\n", 
                CUR_STR(fields[0], i), CUR_SHT(fields[1], i), CUR_STR(fields[2], i), 
                CUR_INT(fields[3], i), CUR_SHT(fields[4], i), CUR_STR(fields[5], i), 
                CUR_STR(fields[6], i), CUR_INT(fields[7], i), CUR_INT(fields[8], i), 
                CUR_STR(fields[9], i), CUR_STR(fields[10], i));
    }
    
    (void)stk;
    (void)pci;
    
cleanup:
    for (i=0; i<11; ++i) {
        if (fields[i].b != NULL) {
            BBPreleaseref(fields[i].b->batCacheid);
        }
    }
    if (output) {
        close_stream(output);
    }
    
    return msg;
}



str 
bam_export(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
    /* arg 1: path to desired output file */
	str output_path = *(str *) getArgReference(stk, pci, pci->retc);

    (void)output_path;
    (void)cntxt;
    (void)mb;
    (void)stk;
    (void)pci;
    throw(MAL, "bam_export", "Not implemented yet...");
}

