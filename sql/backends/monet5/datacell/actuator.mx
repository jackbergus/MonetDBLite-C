@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2008 CWI.
@' All Rights Reserved.

@a M. Kersten, E. Liarou, R. Goncalves
@* The Actuator Simulation program
This program listens to an event stream on a particular port.
It collects statistics on the events.
@verbatim
actuator [options]
	--host=<host name> default localhost
	--port=<portnr> 
	--actuator=<actuator name> 
	--server=<0 1> 
	--latency=<0 or 1>
	--timestamp=<0 or 1>
@end verbatim
@f actuator
@c
#ifndef ACTUATOR
#define ACTUATOR
#include "monetdb_config.h"
#include "gdk.h"
#include "dcsocket.h" 
#include "basket.h"
#ifndef atoll
#define atoll atol
#endif
#ifndef strtoll
#define strtoll strtol
#endif

#ifndef HAVE_GETOPT_LONG
#  include "monet_getopt.h"
#else
# ifdef HAVE_GETOPT_H
#  include "getopt.h"
# endif
#endif


#endif



/*#define _DEBUG_ACTUATOR_ */
#define ACout GDKout

FILE *fd;
typedef struct ACTUATORCLI {
	str name;
	stream *fromServer;
	SOCKET newsockfd;
	struct ACTUATORCLI *nxt, *prev;
} ACrecord, *Actuator;

static Actuator acAnchor = NULL;

static Actuator
ACnew(str nme)
{
	Actuator ac;
	ac = (Actuator)GDKzalloc(sizeof(ACrecord));
	ac->name = GDKstrdup(nme);
	ac->nxt = acAnchor;
	acAnchor = ac;
	return ac;
}

#define TCP 1
#define UDP 2
static int protocol = TCP;

void
usage()
{
	mnstr_printf(ACout, "The actuator tool can be used to catch an event sequence \n");
	mnstr_printf(ACout, "from the emitter port of a DataCell.\n");
	mnstr_printf(ACout, "Several options are provided to control this process.\n");
	mnstr_printf(ACout, "\nactuator [options]\n");
	mnstr_printf(ACout, "--host=<host name>, default localhost\n");
	mnstr_printf(ACout, "--port=<portnr> \n");
	mnstr_printf(ACout, "--actuator=<actuator name> \n");
	mnstr_printf(ACout, "--timestamp=<0 or 1>  default=1\n");
	mnstr_printf(ACout, "--server=<0 or 1>  default=0\n");
	mnstr_printf(ACout, "--statistics=<0 or 1>  default=1\n");
	exit(-1);
}

static char *host = "localhost";
static int port = 50000;
static char *actuator = "X";
static int server = 0;
static int trace = 0;
static int stamp = 1; /* first column is a timestamp*/

static int statistics = 1;
/*if(statistics!=0)
    print statistics;
   else don't
   collect statistics based on assumption that first
   column denotes time of actuator emission */

static int received = 0;
static lng totallatency = 0;
static lng sendFirst = 0;
static lng receivedLast = 0;
static lng receivedFirst = 0;
static int characters = 0;

/* control the display and auto terminate the actuator */
static int batchsize = 1;
static int sequence = -1;
static int tuples = 0;

@-
The statistics are shown after a fixed number of tuples
have been received.Align this number with the batches
generated by the sensor and you get a good impression
of batch effect.
@c
void showStatistics()
{
	double elaps;
	int tuplesIntheBuffer = 2222;
	if (received == 0) return;



	mnstr_printf(ACout, "MYBUFSIZ :%d\n", MYBUFSIZ);
	mnstr_printf(ACout, "Tuples in the buffer :%d\n", tuplesIntheBuffer);

	mnstr_printf(ACout, "\nEvents %d\n", received);
	mnstr_printf(ACout, "Latency per tuple %6.2f microsec\n", (((double)totallatency) / received) / tuplesIntheBuffer);
	elaps = (double)((receivedLast - sendFirst) * tuplesIntheBuffer / (received));
	/*mnstr_printf(ACout, "receivedLast-sendFirst %d microsec\n", receivedLast-sendFirst);*/
	mnstr_printf(ACout, "Elapsed per batch %5.2f microsec\n", elaps);
	mnstr_printf(ACout, "Throughput %8.2f tpl/sec\n", 1000000.0 / elaps * tuplesIntheBuffer);
	mnstr_printf(ACout, "Bandwidth %zu bytes\n", characters * sizeof(char));


	/* sent a short tuple to stderr for gnuplot datafile*/
	if (trace)
		fprintf(stderr, "events %d throughput %6.2f\n",
			received, 1000000.0 / elaps * tuplesIntheBuffer);
}

void terminate(Actuator ac)
{
#ifdef _DEBUG_ACTUATOR_
	mnstr_printf(ACout, "about to shutdown the actuator\n");
#endif
	shutdown(ac->newsockfd, SHUT_RDWR);
	exit(0);
}

void stopListening(int i)
{
	(void)i;
	signal(i, SIG_IGN);
	if (statistics)
		showStatistics();
	exit(0);
}

extern int consumeStream(Actuator ac);

int
main(int argc, char **argv)
{
	int i, j = 0;
	char *err = NULL;
	char name[MYBUFSIZ + 1];
	static SOCKET sockfd;
	Actuator ac = NULL;
	int option_index = 0;

	static struct option long_options[11] = {
		{ "port", 1, 0, 'p' },
		{ "actuator", 1, 0, 'a' },
		{ "server", 1, 0, 's' },
		{ "statistics", 1, 0, 'S' },
		{ "sequence", 1, 0, 's' },
		{ "batch", 1, 0, 'b' },
		{ "host", 1, 0, 'h' },
		{ "help", 1, 0, '?' },
		{ "trace", 1, 0, 't' },
		{ "timestamp", 1, 0, 't' },
		{ 0, 0, 0, 0 }
	};
	THRdata[0] = (void *)file_wastream(stdout, "stdout");
	THRdata[1] = (void *)file_rastream(stdin, "stdin");
	for (i = 0; i < THREADS; i++) {
		GDKthreads[i].tid = i + 1;
	}

	for (;; ) {
		/*	int option_index=0;*/
		int c = getopt_long(argc, argv, "a:p:s:S:b:h:?:t:0", long_options, &option_index);

		if (c == -1)
			break;

		switch (c) {
		case 't':
			if (strcmp(long_options[option_index].name, "timestamp") == 0) {
				stamp = atol(optarg);
				break;
			}
			if (strcmp(long_options[option_index].name, "trace") == 0) {
				trace = atol(optarg);
				break;
			} else {
				usage();
				exit(0);
			}
			break;
		case 'b':
			batchsize = atol(optarg);
			break;
		case 'a':
			actuator = optarg;
			break;
		case 's':
			if (strcmp(long_options[option_index].name, "sequence") == 0) {
				sequence = atol(optarg);
				break;
			}
			if (strcmp(long_options[option_index].name, "server") == 0) {
				server = atol(optarg);
				break;
			} else {
				usage();
				exit(0);
			}
			break;
		case 'S':
			statistics = atol(optarg);
			break;
		case 'p':
			port = atol(optarg);
			break;
		case 'h':
			host = optarg;
			break;
		case '?':
		default:
			usage();
			exit(0);
		}
	}

	signal(SIGABRT, stopListening);
#ifdef SIGPIPE
	signal(SIGPIPE, stopListening);
#endif
#ifdef SIGHUP
	signal(SIGHUP, stopListening);
#endif
	signal(SIGTERM, stopListening);
	signal(SIGINT, stopListening);

	/* display properties */
	if (trace) {
		mnstr_printf(ACout, "--host=%s\n", host);
		mnstr_printf(ACout, "--port=%d\n", port);
		mnstr_printf(ACout, "--actuator=%s\n", actuator);
		mnstr_printf(ACout, "--trace=%d\n", trace);
		mnstr_printf(ACout, "--timestamp=%d\n", stamp);
		mnstr_printf(ACout, "--statistics=%d\n", statistics);
		mnstr_printf(ACout, "--server=%d\n", server);
		mnstr_printf(ACout, "--sequence=%d\n", sequence);
		mnstr_printf(ACout, "--batch=%d\n", batchsize);
	}

	if (protocol == UDP) {
		ac = ACnew(actuator);
		ac->fromServer = udp_rastream(host, port, actuator);
		if (ac->fromServer == NULL) {
			perror("Actuator: Could not open stream");
			mnstr_printf(ACout, "stream %s.%d.%s\n", host, port, actuator);
			return 0;
		}
		consumeStream(ac);
	}

	/* Handle TCP protocol */
	if (server && (err = socket_server_connect(&sockfd, port))) {
		mnstr_printf(ACout, "ACTUATOR:start server:%s\n", err);
		return 0;
	}
	snprintf(name, MYBUFSIZ - (strlen(actuator) + sizeof(j)), "%s%d", actuator, j++);
	ac = ACnew(name);
	name[0] = 0;
	err = NULL;
	do {
		if (server) {
#ifdef _DEBUG_ACTUATOR_
			mnstr_printf(ACout, "Actuator listens\n");
#endif
			err = socket_server_listen(sockfd, &(ac->newsockfd));
			if (err) {
				mnstr_printf(ACout, "ACTUATOR:server listen fails:%s\n", err);
				continue;
			}
		} else {
#ifdef _DEBUG_ACTUATOR_
			mnstr_printf(ACout, "Actuator connects\n");
#endif
			err = socket_client_connect(&(ac->newsockfd), host, port);
			if (err) {
				mnstr_printf(ACout, "ACTUATOR:start client:%s\n", err);
				continue;
			}
		}

#ifdef _DEBUG_ACTUATOR_
		mnstr_printf(ACout, "Initialize stream\n");
#endif
		ac->fromServer = socket_rastream(ac->newsockfd, actuator);

		if (ac->fromServer == NULL) {
			perror("Actuator: Could not open stream");
			mnstr_printf(ACout, "stream %s.%d.%s\n", host, port, actuator);
			continue;
		}
		consumeStream(ac);
	} while (server);
	socket_close(sockfd);
	terminate(ac);
	return 0;
}

#define L(X) (X + strlen(X))


/*
   lng
   estimateOverhead(){
    int i;
    lng l;
    lng t0= usec();
    for(i=0;i<10000; i++)
        l= usec();
    t0= usec()-t0;
    mnstr_printf(ACout, "Timing overhead " LLFMT " usec/10000\n",t0);
    return l;
   }
 */

int
consumeStream(Actuator ac)
{
	char buf[MYBUFSIZ + 1];   /* use equal to Linux internal buffer size */
	lng clk;
	char *endptr;
	lng l = 0;
	int m = 0;

#ifdef _DEBUG_ACTUATOR_
	mnstr_printf(ACout, "Consume stream\n");
#endif
	buf[0] = 0;
	while (tuples != batchsize * sequence &&
		   (m = (int)mnstr_readline(ac->fromServer, buf, MYBUFSIZ))) {
		buf[m] = 0;
		characters += m;
		received++;
		tuples++;
		if (trace)
			mnstr_printf(ACout, "%s\n", buf);
		/*mnstr_printf(ACout, "Received tuple[%d]:%s\n",received,buf);*/

		endptr = 0;
		clk = strtoll(buf + 1, &endptr, 0);
		if (sendFirst == 0)
			sendFirst = clk;
		receivedLast = usec();
		if (receivedFirst == 0)
			receivedFirst = receivedLast;
		if (stamp) {
			l = receivedLast - clk;
#ifdef _DEBUG_ACTUATOR_
			if (trace)
				mnstr_printf(ACout, "B#%d: " LLFMT " " LLFMT "\n",
					received, clk, l);
#endif
			totallatency += l;
		}

		m = 0;
		/*if( statistics && (received % batchsize )==0){
		    showStatistics();
		    received=0;
		    totallatency=0;
		    receivedFirst= receivedLast=0;
		    characters=0;
		   }*/
	}
	if (errno == EPIPE || errno == ECONNRESET) {
		mnstr_printf(ACout, "errno:%s\n", strerror(errno));
		close_stream(ac->fromServer);
	}
	if (statistics)
		showStatistics();
#ifdef _DEBUG_ACTUATOR_
	mnstr_printf(ACout, "tuples %d batchsize %d sequence %d\n",
		tuples, batchsize, sequence);
#endif

	if (tuples >= batchsize * sequence)
		terminate(ac);

	return 0;
}
