# The contents of this file are subject to the MonetDB Public License
# Version 1.1 (the "License"); you may not use this file except in
# compliance with the License. You may obtain a copy of the License at
# http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
#
# Software distributed under the License is distributed on an "AS IS"
# basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
# License for the specific language governing rights and limitations
# under the License.
#
# The Original Code is the MonetDB Database System.
#
# The Initial Developer of the Original Code is CWI.
# Portions created by CWI are Copyright (C) 1997-2008 CWI.
# All Rights Reserved.

@f basket
@- Event baskets
Continuous query processing relies on event baskets 
passed through a processing pipeline. Each stream is
represented with a BAT whose header contains a usec tag.
All event components received at the same receptor will
be tagged with the same key. 

Query processing follows the following steps:
1) gain access to a series of baskets,locking them for exclusive use
2) take a snapshot of its content and release the locks
3) process the query using the snapshots
4) lock the baskets again
5) drop elements from the basket you have seen/used.
6) unlock the baskets

The baskets form a simple synchronization point. They
are controlled by a group based locking scheme.
Steps 2) and 5) can be taken as a single action, i.e.
remove the previous snapshot and collect the new ones.

The baskets are organized into groups, i.e. they represent
a relational table.
@mal
module basket;

pattern new(nme:str,b:bat[:any_1,:any_2]):bat[:any_1,:any_2]
address BSKTnew
comment "Create a new event basket";

pattern group(nme:str,components:str...):void
address BSKTgroup
comment "Create a basket group";

command drop(grp:str,nme:str):void
address BSKTdrop
comment "Remove a basket from a group";
command drop(grp:str):void
address BSKTdropGroup
comment "Remove a basket group";

pattern bind(grp:str,nme:str) :bat[:any_1,:any_2]
address BSKTbind
comment "Locate the designated stream and provide access
to its base and private snapshot.";

command delete(nme:str,piv:bat[:any_1,:any_3]):void
address BSKTdelete
comment "Remove the events identified by their tag from their basket";

command update(nme:str,del:bat[:any_1,:any_3]):bat[:any_1,:any_3]
address BSKTupdate
comment "Remove the events identified from a basket and return a snapshot
of the newly arrived events";

command lock(grp:str,delay:int):void
address BSKTlock
comment "Lock a basket group and spinlock upon need";
command lock(grp:str):void
address BSKTlock2
comment "Lock a basket group ";

command unlock(grp:str):void
address BSKTunlock
comment "Unlock the basket";
@{
@h
#ifndef _BASKETS_
#define _BASKETS_

/* #define _DEBUG_BASKET     debug this module */
#define BSKTout GDKout

#include "monetdb_config.h"
#include "sql.h"
#include "mal.h"
#include "mal_interpreter.h"

@-
Each group has a single lock structure and possibly shared
properties.
@h
typedef struct GROUPLOCK{
	MT_Lock lock;
} *GroupLock;

typedef struct{
	GroupLock lock;
	str name;
	str grp;
	BAT *primary;
} *Basket, BasketRec;


#ifdef WIN32
#ifndef LIBCONTAINERS
#define containers_export extern __declspec(dllimport)
#else
#define containers_export extern __declspec(dllexport)
#endif
#else
#define containers_export extern
#endif

containers_export str BSKTlock(int *ret, str *nme, int *delay);
containers_export str BSKTlock2(int *ret, str *grp);
containers_export str BSKTunlock(int *ret, str *nme);
containers_export str BSKTnew(Client cntxt, MalBlkPtr mk, MalStkPtr stk, InstrPtr pc);
containers_export str BSKTbind(Client cntxt, MalBlkPtr mk, MalStkPtr stk, InstrPtr pc);
containers_export str BSKTgroup(Client cntxt, MalBlkPtr mk, MalStkPtr stk, InstrPtr pc);
containers_export str BSKTdrop(int *ret, str *grp, str *nme);
containers_export str BSKTdropGroup(int *ret, str *grp);
containers_export str BSKTdelete(int *ret, str *grp, str *nme, int *del);
containers_export str BSKTfind(int *ret, str *grp, str *nme);
containers_export int BSKTlocateGroup(str grp);
containers_export int BSKTmembers(str grp, str *member, int limit);
containers_export int BSKTmemberCount(str grp);
containers_export str BSKTmemberName(str grp,int idx);
containers_export str BSKTupdate(int *ret, int *bsk, int *upd);
containers_export BasketRec *baskets;
containers_export int bsktTop, bsktLimit;
containers_export lng usec(void);
#endif
@c
#include "basket.h"
#ifdef WIN32
#include "winsock2.h"
#endif

BasketRec *baskets;
int bsktTop, bsktLimit;
static MT_Lock bsktLock;

#define lockBasketCatalog() mal_set_lock(bsktLock,"basket");
#define unlockBasketCatalog() mal_unset_lock(bsktLock,"basket");

@-
We have to obtain the precise wall-clock time
This is not produced by GDKusec, which returns microseconds
since the start of the program.
Notice that this routine consumes noticable time.
@c
lng usec(void){
    struct timeval tp;

    gettimeofday(&tp, NULL);
    return ((lng) tp.tv_sec ) * LL_CONSTANT(1000000) + (lng) tp.tv_usec;
}


static int BSKTnewEntry(){
	if(bsktLimit == 0){
		bsktLimit = 128;
		baskets= (BasketRec *) GDKzalloc(bsktLimit * sizeof(BasketRec));
		MT_lock_init(&bsktLock,"basket");
		bsktTop=1; /* entry 0 is used as non-initialized */
	} else
		if( bsktTop == bsktLimit){
			bsktLimit +=128;
			baskets= (BasketRec *) GDKrealloc(baskets, bsktLimit * sizeof(BasketRec));
		}
	return bsktTop++;
}

static int
BSKTlocate(str grp, str nme){
	int i;
	for(i=1; i< bsktTop; i++)
	if(grp && nme &&
		baskets[i].name && strcmp(nme, baskets[i].name)==0 &&
		baskets[i].grp && strcmp(grp, baskets[i].grp)==0 )
		return i;
	return 0;
}

int
BSKTlocateGroup(str grp){
	int i;
	for(i=1; i< bsktTop; i++)
	if( grp && baskets[i].grp && strcmp(grp, baskets[i].grp)==0 )
		return i;
	return 0;
}

str BSKTfind(int *bid, str *grp, str *nme){
	int i;
	i= BSKTlocate(*grp,*nme);
	if( i==0) 
		throw(MAL,"basket.find","Could not find basket");
	assert(i>0 && i<bsktTop);
	if(baskets[i].primary == 0)
		throw(MAL,"basket.find","Basket not initialized");
	*bid= baskets[i].primary->batCacheid;
	BBPincref(*bid,TRUE);
	return MAL_SUCCEED;
}

str 
BSKTnew(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pc){
	int *ret= (int*) getArgReference(stk,pc,0);
	str *nme= (str*) getArgReference(stk,pc,1);
	int tpe= getArgType(mb,pc,2);
	int i;
        int void_head_type= TYPE_void;
        oid o= 0;

	(void) cntxt;
	mal_set_lock(mal_contextLock, "newBasket");
	i= BSKTnewEntry();
	baskets[i].lock= 0;
	baskets[i].name= GDKstrdup(*nme);
	baskets[i].grp= GDKstrdup(*nme);
        if( getHeadType(tpe) == TYPE_oid){
		baskets[i].primary = BATnew(void_head_type,getTailType(tpe),0);
                BATseqbase(baskets[i].primary, o);
                
        }
	else  
		baskets[i].primary = BATnew(getHeadType(tpe),getTailType(tpe),0);

        baskets[i].primary->tsorted = FALSE;

	*ret= baskets[i].primary->batCacheid;
	BBPincref(*ret,TRUE);
	mal_unset_lock(mal_contextLock, "newBasket");
	return MAL_SUCCEED;
}

str BSKTbind(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pc){
	int *ret= (int*) getArgReference(stk,pc,0);
	str grp= *(str*) getArgReference(stk,pc,1);
	str nme= *(str*) getArgReference(stk,pc,2);

	int bskt= BSKTlocate(grp,nme);
	if( bskt== 0)
		throw(MAL,"baskets.bind","Could not find basket %s",nme);
	BBPincref( *ret = baskets[bskt].primary->batCacheid,TRUE);
	(void) cntxt;
	(void)mb;
	return MAL_SUCCEED;
}
@-
For now, we use disjoint basket groups focussed to support
interaction between receptor and kernel.
@c
str BSKTgroup(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pc){
	int i,bskt;
	GroupLock bl;
	str grp;
	(void) cntxt;
	
	bl= (GroupLock) GDKzalloc(sizeof(struct GROUPLOCK));
	lockBasketCatalog();
	MT_lock_init(bl,"basket");
	for(i= pc->retc+1; i<pc->argc; i++){
		bskt= BSKTlocate(*(str*)getArgReference(stk,pc,i),
						*(str*)getArgReference(stk,pc,i));
		if( bskt==0){
			unlockBasketCatalog();
			throw(MAL,"basket.group","Unknown basket %s",
					*(str*) getArgReference(stk,pc,i));
		}
	}
	grp= *(str*) getArgReference(stk,pc,1);
	/* you may use basket.group("x") */
	i= (pc->retc+1 == pc->argc)? pc->retc: pc->retc+1;
	for(; i<pc->argc; i++){
		bskt= BSKTlocate(*(str*)getArgReference(stk,pc,i),
				*(str*)getArgReference(stk,pc,i));
		baskets[bskt].lock= bl;
		baskets[bskt].grp= GDKstrdup(grp);
	}
	unlockBasketCatalog();
	(void)mb;

	return MAL_SUCCEED;
}

@-
The locks are designated towards groups
If you can not grab the lock then we have to wait.
@c
str BSKTlock(int *ret, str *grp, int *delay){
	int bskt;

	bskt= BSKTlocateGroup(*grp);
	if( bskt==0) 
		throw(MAL,"basket.lock","Could not find the basket group");
#ifdef _DEBUG_BASKET
	stream_printf(BSKTout, "lock group %s\n",*grp);
#endif
    	mal_set_lock(baskets[bskt].lock->lock, "lock basket");
#ifdef _DEBUG_BASKET
	stream_printf(BSKTout, "got  group locked %s\n",*grp);
#endif
	(void) delay; /* control spinlock */
	(void) ret;
	return MAL_SUCCEED;
}
str BSKTlock2(int *ret, str *grp){
	int delay=0;
	return BSKTlock(ret,grp,&delay);
}
str BSKTunlock(int *ret, str *grp){
	int bskt;

	bskt= BSKTlocateGroup(*grp);
	if( bskt==0) 
		throw(MAL,"basket.lock","Could not find the basket group");
    	mal_unset_lock(baskets[bskt].lock->lock, "lock basket");
	(void) ret;
	return MAL_SUCCEED;
}

@-
Drop a specific basket from the group.
@c
static void
BSKTdropInternal(int bskt){
	GroupLock l;
	int i,cnt=0;

	lockBasketCatalog();
	l= baskets[bskt].lock;
	baskets[bskt].lock= 0;
	GDKfree(baskets[bskt].name);
	GDKfree(baskets[bskt].grp);
	baskets[bskt].name= 0;
	baskets[bskt].primary= 0;
	if( baskets[bskt].primary)
		BBPdecref(baskets[bskt].primary->batCacheid,TRUE);

	/* remove the lock structure if this was the last one */
	for( i=0; i<bsktTop; i++)
		if( baskets[i].lock== l) 
			cnt++;
	if( cnt==0)
		GDKfree(l);
	unlockBasketCatalog();
}

str BSKTdrop(int *ret, str *grp, str *nme){
	int bskt;

	bskt= BSKTlocate(*grp,*nme);
	if( bskt==0) 
		throw(MAL,"basket.drop","Could not find the basket group");
	BSKTdropInternal(bskt);
	(void) ret;
	return MAL_SUCCEED;
}

@-
And remove all the elements from a group
@c
str BSKTdropGroup(int *ret, str *grp){
	int i;
	if( baskets==0)
		return MAL_SUCCEED;
	
	for(i=1; i<bsktTop; i++)
	if(baskets[i].grp && strcmp(*grp, baskets[i].grp)==0)
		BSKTdropInternal(i);
	(void) ret;
	return MAL_SUCCEED;
}

str BSKTdelete(int *ret, str *grp,str *nme, int *del){
	int bskt;
	BAT *b;

	if( *nme==0) return MAL_SUCCEED;
	bskt= BSKTlocate(*grp,*nme);
	if( bskt==0) return MAL_SUCCEED;
	lockBasketCatalog();
	b= BATdescriptor(*del);
	if( b== NULL)
		throw(MAL,"basket.delete","Can not access descriptor");
	BATdel(baskets[bskt].primary,b,FALSE);
	BBPunfix(b->batCacheid);
	(void) ret;
	unlockBasketCatalog();
	return MAL_SUCCEED;
}

@-
Remove events from the basket and return a snapshot
of the remaining ones.
@c
str BSKTupdate(int *ret, int *bsk, int *upd){
	(void) ret;
	(void) bsk;
	(void) upd;
	return MAL_SUCCEED;
}
int BSKTmembers(str grp, str *member, int limit)
{
	int i, k=0;
	if( baskets==0)
		return 0;
	
	for(i=1; i<bsktTop; i++)
	if(k<limit && baskets[i].grp && strcmp(grp, baskets[i].grp)==0)
		member[k++]= baskets[i].name;
	return k;
}

int BSKTmemberCount(str grp){
	int i, cnt=0;
	for(i=1; i<bsktTop; i++)
	if( grp && baskets[i].grp && strcmp(grp, baskets[i].grp)==0)
		cnt++;
	return cnt;
}
str BSKTmemberName(str grp, int idx){
	int i;
	for(i=1;idx && i<bsktTop; i++)
	if( grp && baskets[i].grp && strcmp(grp, baskets[i].grp)==0)
		idx--;
	if( idx == 0)
		return baskets[i].name;
	return GDKstrdup("Unknown member");
}
@}
