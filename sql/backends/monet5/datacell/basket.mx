# The contents of this file are subject to the MonetDB Public License
# Version 1.1 (the "License"); you may not use this file except in
# compliance with the License. You may obtain a copy of the License at
# http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
#
# Software distributed under the License is distributed on an "AS IS"
# basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
# License for the specific language governing rights and limitations
# under the License.
#
# The Original Code is the MonetDB Database System.
#
# The Initial Developer of the Original Code is CWI.
# Portions created by CWI are Copyright (C) 1997-2008 CWI.
# All Rights Reserved.

@f basket
@- Event baskets
Continuous query processing relies on event baskets 
passed through a processing pipeline. The baskets
are derived from ordinary SQL tables where the delta
processing is ignored.

@mal
module basket;

pattern register(schema:str,tab:str):void
address BSKTregister
comment "Initialize a new basket based on a specific table definition in the datacell schema");

command lock{unsafe}(schema:str, tbl:str,delay:int):void
address BSKTlock
comment "Lock a basket group and spinlock upon need";

command lock{unsafe}(schema:str, tbl:str):void
address BSKTlock2
comment "Lock a basket group ";

command unlock{unsafe}(schema:str, tbl:str):void
address BSKTunlock
comment "Unlock the basket";

pattern grab(schema:str, tbl:str, flg:int):bat[:oid,:any]...
address BSKTgrab
comment "Take a snapshot of the basket, destroying the origin when flg is set";

command drop(schema:str, tbl:str):void
address BSKTdrop
comment "Remove the basket";

command dump()
address BSKTdump
comment "Dump the status of the basket table";
@{
@h
#ifndef _BASKETS_
#define _BASKETS_

#include "monetdb_config.h"
#include "mal.h"
#include "mal_interpreter.h"
#include "sql.h"

#ifdef WIN32
#ifndef LIBCONTAINERS
#define datacell_export extern __declspec(dllimport)
#else
#define datacell_export extern __declspec(dllexport)
#endif
#else
#define datacell_export extern
#endif

/* #define _DEBUG_DATACELL     debug this module */
#define BSKTout GDKout
#define MAXCOL 128
#define MAXBSK 64

typedef struct{
	MT_Lock lock;
	str schema;	/* lives in the datacell schema by default */
	str name;	/* table that represents the basket */
	int colcount;
	str *cols;
	BAT **primary;	
	/* statistics */
} *BSKTbasket, BSKTbasketRec;

datacell_export str schema_default;
datacell_export str BSKTregister(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
datacell_export str BSKTnewbasket(sql_schema *s, sql_table *t, sql_trans *tr);
datacell_export str BSKTdrop(int *ret, str *sch, str *tbl);
datacell_export str BSKTinventory(int *ret);
datacell_export int BSKTmemberCount(str schema, str tbl);
datacell_export int BSKTlocate(str schema, str tbl);
datacell_export str BSKTdump(int *ret);
datacell_export str BSKTgrab(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);

datacell_export str BSKTlock(int *ret, str *schema, str *tbl, int *delay);
datacell_export str BSKTunlock(int *ret, str *schema, str *tbl);
datacell_export str BSKTlock2(int *ret, str *schema, str *tbl);

datacell_export BSKTbasketRec *baskets;
datacell_export int bsktTop, bsktLimit;
datacell_export lng usec(void);
datacell_export InstrPtr BSKTgrabInstruction(MalBlkPtr mb, str shema, str tbl);
#endif
@c
#include "basket.h"
#ifdef WIN32
#include "winsock2.h"
#endif

str schema_default = "datacell";

BSKTbasketRec *baskets;   /* the datacell catalog */
int bsktTop, bsktLimit = 0;
static MT_Lock bsktLock;

#define lockBSKTbasketCatalog() mal_set_lock(bsktLock, "basket");
#define unlockBSKTbasketCatalog() mal_unset_lock(bsktLock, "basket");

@-
We have to obtain the precise wall-clock time
This is not produced by GDKusec, which returns microseconds
since the start of the program.
Notice that this routine consumes noticable time.
lng usec(void)
{
	struct timeval tp;

	gettimeofday(&tp, NULL);
	return ((lng)tp.tv_sec) * LL_CONSTANT(1000000) + (lng)tp.tv_usec;
}
@c

static int BSKTnewEntry()
{
	int i;
	for ( i=1; i< bsktLimit; i++)
	if (baskets[i].schema == NULL)
		break;
	if ( i < bsktLimit) {
		if ( i == bsktTop)
			bsktTop++;
		return i;
	}
	if (bsktLimit == 0) {
		bsktLimit = MAXBSK;
		baskets = (BSKTbasketRec *)GDKzalloc(bsktLimit * sizeof(BSKTbasketRec));
		MT_lock_init(&bsktLock, "basket");
		bsktTop = 1; /* entry 0 is used as non-initialized */
	} else if (bsktTop == bsktLimit) {
		bsktLimit += MAXBSK;
		baskets = (BSKTbasketRec *)GDKrealloc(baskets, bsktLimit * sizeof(BSKTbasketRec));
	}
	return bsktTop++;
}

static void
BSKTtolower(char *dst, const char *src)
{
	int i;
	for( i=0; i < BUFSIZ-1 && src[i]; i++)
		dst[i] = (char) tolower((int)src[i]);
	dst[i] = 0;
}
int
BSKTlocate(str schema, str tbl)
{
	int i;
	char lsch[BUFSIZ], ltbl[BUFSIZ];

	BSKTtolower(lsch,schema);
	BSKTtolower(ltbl,tbl);

	for (i = 1; i < bsktTop; i++)
		if (tbl && baskets[i].name && strcmp(ltbl, baskets[i].name) == 0 &&
			(schema == 0 || (baskets[i].schema && strcmp(lsch, baskets[i].schema) == 0)))
			return i;
	return 0;
}

str
BSKTnewbasket(sql_schema *s, sql_table *t, sql_trans *tr)
{
	int idx, i;
	node *o;
	str msg = MAL_SUCCEED;;
	BAT *b;
	sql_column  *c;

	mal_set_lock(mal_contextLock, "register");
	idx = BSKTnewEntry();
	MT_lock_init(&baskets[idx].lock, "register");

	baskets[idx].schema = GDKstrdup(s->base.name);
	baskets[idx].name = GDKstrdup(t->base.name);

	baskets[idx].colcount = 0;
	for (o = t->columns.set->h; o; o = o->next) baskets[idx].colcount++;
	baskets[idx].cols = GDKzalloc((baskets[idx].colcount + 1) * sizeof(str));
	baskets[idx].primary = GDKzalloc((baskets[idx].colcount + 1) * sizeof(BAT *));

	i = 0;
	for (o = t->columns.set->h; msg == MAL_SUCCEED && o; o = o->next) {
		c = o->data;
		b = store_funcs.bind_col(tr, c, 0);
		if (b == NULL) {
			mal_unset_lock(mal_contextLock, "register");
			throw(SQL, "sql.basket", "Can not access descriptor");
		}
		if (b->htype == TYPE_oid) {
			baskets[idx].primary[i] = BATnew(TYPE_void, b->ttype, 0);
			BATseqbase(baskets[idx].primary[i], 0);
		} else
			baskets[idx].primary[i] = BATnew(b->htype, b->ttype, 0);

		BBPreleaseref(b->batCacheid);
		baskets[idx].cols[i++] = GDKstrdup(c->base.name);
	}
	mal_unset_lock(mal_contextLock, "register");
	return MAL_SUCCEED;
}

str
BSKTregister(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	sql_schema  *s;
	sql_table   *t;
	mvc *m = NULL;
	str msg = getContext(cntxt, mb, &m, NULL);
	sql_trans *tr;
	char lsch[BUFSIZ];
	char ltbl[BUFSIZ];

	if (msg != MAL_SUCCEED)
		return msg;
	BSKTtolower(lsch,*(str*)getArgReference(stk, pci, 1));
	tr = m->session->tr;
	s = mvc_bind_schema(m, lsch);
	BSKTtolower(ltbl, *(str*)getArgReference(stk, pci, 2));
	if (s == NULL)
		throw(SQL, "datacell.register", "Schema missing");

	t = mvc_bind_table(m, s, ltbl);
	if (t == NULL)
		throw(SQL, "datacell.register", "Table missing");

	/* check double registration */
	if (BSKTlocate(lsch, ltbl))
		throw(SQL, "datacell.register", "Basket defined twice.");

	return BSKTnewbasket(s, t, tr);
}

int BSKTmemberCount(str schema, str tbl)
{
	int idx = BSKTlocate(schema, tbl);
	return baskets[idx].colcount;
}

@-
The locks are designated towards the baskets.
If you can not grab the lock then we have to wait.
@c
str BSKTlock(int *ret, str *schema, str *tbl, int *delay)
{
	int bskt;

	bskt = BSKTlocate(*schema, *tbl);
	if (bskt == 0)
		throw(MAL, "basket.lock", "Could not find the basket");
#ifdef _DEBUG_BASKET
	stream_printf(BSKTout, "lock group %s\n", *tbl);
#endif
	mal_set_lock(baskets[bskt].lock, "lock basket");
#ifdef _DEBUG_BASKET
	stream_printf(BSKTout, "got  group locked %s\n", *tbl);
#endif
	(void)delay;  /* control spinlock */
	(void)ret;
	return MAL_SUCCEED;
}


str BSKTlock2(int *ret, str *schema, str *tbl)
{
	int delay = 0;
	return BSKTlock(ret, schema, tbl, &delay);
}

str BSKTunlock(int *ret, str *schema, str *tbl)
{
	int bskt;

	bskt = BSKTlocate(*schema, *tbl);
	if (bskt == 0)
		throw(MAL, "basket.lock", "Could not find the basket");
	mal_unset_lock(baskets[bskt].lock, "lock basket");
	(void)ret;
	return MAL_SUCCEED;
}


str
BSKTdrop(int *ret, str *schema, str *tbl)
{
	int bskt;

	bskt = BSKTlocate(*schema, *tbl);
	if (bskt == 0)
		throw(MAL, "basket.drop", "Could not find the basket");
	baskets[bskt].colcount = 0;
	GDKfree(baskets[bskt].schema);
	GDKfree(baskets[bskt].name);
	GDKfree(baskets[bskt].cols);
	GDKfree(baskets[bskt].primary);
	baskets[bskt].schema = 0;
	baskets[bskt].name = 0;
	baskets[bskt].cols = 0;
	baskets[bskt].primary = 0;

	(void)ret;
	return MAL_SUCCEED;
}

str
BSKTdump(int *ret)
{
	int bskt;

	for ( bskt = 0; bskt < bsktLimit; bskt++) 
	if ( baskets[bskt].schema){
		mnstr_printf(GDKout, "#baskets[%2d] %s.%s columns %d events " BUNFMT "\n", bskt,
			baskets[bskt].schema,
			baskets[bskt].name,
			baskets[bskt].colcount,
			(baskets[bskt].primary[0]? BATcount(baskets[bskt].primary[0]): 0));
	}
	(void)ret;
	return MAL_SUCCEED;
}

str
BSKTgrab(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	str schema, tbl;
	int bskt, i, *ret;
	BAT *b;

	(void) cntxt;
	(void) mb;
	schema = *(str*) getArgReference(stk,pci, pci->argc-3);
	tbl = *(str*) getArgReference(stk,pci, pci->argc-2);

	bskt = BSKTlocate(schema, tbl);
	if (bskt == 0 )
		throw(MAL,"basket.grab","Basket not found");
	if ( baskets[bskt].colcount != pci->retc)
		throw(MAL,"basket.grab","Incompatible arguments");
	mal_set_lock(baskets[bskt].lock, "lock basket");
	for ( i=0; i < baskets[bskt].colcount; i++) {
		ret= (int*) getArgReference(stk,pci,i);
		b = baskets[bskt].primary[i];
		*ret = b->batCacheid;
		BBPkeepref(*ret);
		if (  b->htype == TYPE_oid) {
			baskets[bskt].primary[i] = BATnew(TYPE_void, b->ttype, 0);
			BATseqbase(baskets[bskt].primary[i], 0);
		} else
			baskets[bskt].primary[i] = BATnew(b->htype, b->ttype, 0);
	}
	mal_unset_lock(baskets[bskt].lock, "unlock basket");
	return MAL_SUCCEED;
}

InstrPtr
BSKTgrabInstruction(MalBlkPtr mb, str schema, str tbl)
{
	int i, j, bskt;
	InstrPtr p;
	BAT *b;

	bskt = BSKTlocate(schema, tbl);
	if (bskt == 0 )
		return 0;
	p = newFcnCall(mb,basketRef,grabRef);
	p->argc= 0;
	for ( i=0; i < baskets[bskt].colcount; i++) {
		b = baskets[bskt].primary[i];
		j= newTmpVariable(mb,newBatType(TYPE_oid,b->ttype));
		setVarUDFtype(mb,j);
		setVarFixed(mb,j);
		p= pushArgument(mb,p, j);
	}
	p->retc= p->argc;
	p= pushStr(mb,p,schema);
	p= pushStr(mb,p,tbl);
	return p;
}
@}
