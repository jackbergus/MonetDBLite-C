# The contents of this file are subject to the MonetDB Public License
# Version 1.1 (the "License"); you may not use this file except in
# compliance with the License. You may obtain a copy of the License at
# http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
#
# Software distributed under the License is distributed on an "AS IS"
# basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
# License for the specific language governing rights and limitations
# under the License.
#
# The Original Code is the MonetDB Database System.
#
# The Initial Developer of the Original Code is CWI.
# Portions created by CWI are Copyright (C) 1997-2008 CWI.
# All Rights Reserved.

@f basket
@- Event baskets
Continuous query processing relies on event baskets 
passed through a processing pipeline. The baskets
are derived from ordinary SQL tables where the delta
processing is ignored.

@mal
module datacell;

pattern register_basket(schema:str,tab:str):void
address DCregister_basket
comment "Initialize a new basket based on a specific table definition in the datacell schema");

pattern register_basket(tab:str):void
address DCregister_basket
comment "Initialize a new basket based on a specific table definition in the datacell schema");

pattern register_basket():void
address DCregister_all
comment "Create basket definitions for all tables in the datacell schema";

command inventory():bat[:str,:bat]
address DCinventory
comment "Produce a tabular view of the baskets identified";

command lock(schema:str, tbl:str,delay:int):void
address DClock
comment "Lock a basket group and spinlock upon need";
command lock(schema:str, tbl:str):void
address DClock2
comment "Lock a basket group ";

command unlock(schema:str, tbl:str):void
address DCunlock
comment "Unlock the basket";

@{
@h
#ifndef _DATACELLS_
#define _DATACELLS_

#include "monetdb_config.h"
#include "sql.h"
#include "mal_interpreter.h"


#ifdef WIN32
#ifndef LIBCONTAINERS
#define datacell_export extern __declspec(dllimport)
#else
#define datacell_export extern __declspec(dllexport)
#endif
#else
#define datacell_export extern
#endif

/* #define _DEBUG_DATACELL     debug this module */
#define DCout GDKout
#define MAXCOL 128
#define MAXBSK 64

typedef struct{
	MT_Lock lock;
	str schema;	/* lives in the datacell schema by default */
	str name;	/* table that represents the basket */
	int colcount;
	str *cols;
	BAT **primary;	
	/* statistics */
} *DCbasket, DCbasketRec;

datacell_export str schema_default;
datacell_export str DCregister_all(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
datacell_export str DCregister_basket(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
datacell_export str DCinventory(int *ret);
datacell_export int DCmemberCount(str schema, str tbl);
datacell_export int DClocate(str schema, str tbl);

datacell_export str DClock(int *ret, str *schema, str *tbl, int *delay);
datacell_export str DCunlock(int *ret, str *schema, str *tbl);
datacell_export str DClock2(int *ret, str *schema, str *tbl);

datacell_export DCbasketRec *baskets;
datacell_export int bsktTop, bsktLimit;
datacell_export lng usec(void);
#endif
@c
#include "basket.h"
#ifdef WIN32
#include "winsock2.h"
#endif

str schema_default = "datacell";

DCbasketRec *baskets;   /* the datacell catalog */
int bsktTop, bsktLimit;
static MT_Lock bsktLock;

#define lockDCbasketCatalog() mal_set_lock(bsktLock, "basket");
#define unlockDCbasketCatalog() mal_unset_lock(bsktLock, "basket");

@-
We have to obtain the precise wall-clock time
This is not produced by GDKusec, which returns microseconds
since the start of the program.
Notice that this routine consumes noticable time.
@c
lng usec(void)
{
	struct timeval tp;

	gettimeofday(&tp, NULL);
	return ((lng)tp.tv_sec) * LL_CONSTANT(1000000) + (lng)tp.tv_usec;
}

static int DCnewEntry()
{
	if (bsktLimit == 0) {
		bsktLimit = MAXBSK;
		baskets = (DCbasketRec *)GDKzalloc(bsktLimit * sizeof(DCbasketRec));
		MT_lock_init(&bsktLock, "basket");
		bsktTop = 1; /* entry 0 is used as non-initialized */
	} else if (bsktTop == bsktLimit) {
		bsktLimit += MAXBSK;
		baskets = (DCbasketRec *)GDKrealloc(baskets, bsktLimit * sizeof(DCbasketRec));
	}
	return bsktTop++;
}

int
DClocate(str schema, str tbl)
{
	int i;
	for (i = 1; i < bsktTop; i++)
		if (tbl && baskets[i].name && strcmp(tbl, baskets[i].name) == 0 &&
			(schema == 0 || (baskets[i].schema && strcmp(schema, baskets[i].schema) == 0)))
			return i;
	return 0;
}

static str
DCnewbasket(sql_schema *s, sql_table *t, sql_trans *tr)
{
	int idx, i;
	node *o;
	str msg = MAL_SUCCEED;;
	BAT *b;
	sql_column  *c;

	mal_set_lock(mal_contextLock, "register_basket");
	idx = DCnewEntry();
	MT_lock_init(&baskets[idx].lock, "register_basket");
	baskets[idx].schema = GDKstrdup(s->base.name);
	baskets[idx].name = GDKstrdup(t->base.name);

	baskets[idx].colcount = 0;
	for (o = t->columns.set->h; o; o = o->next) baskets[idx].colcount++;
	baskets[idx].cols = GDKzalloc((baskets[idx].colcount + 1) * sizeof(str));
	baskets[idx].primary = GDKzalloc((baskets[idx].colcount + 1) * sizeof(BAT *));

	i = 0;
	for (o = t->columns.set->h; msg == MAL_SUCCEED && o; o = o->next) {
		c = o->data;
		b = store_funcs.bind_col(tr, c, 0);
		if (b == NULL) {
			mal_unset_lock(mal_contextLock, "register_basket");
			throw(SQL, "sql.basket", "Can not access descriptor");
		}
		if (b->htype == TYPE_oid) {
			baskets[idx].primary[i] = BATnew(TYPE_void, b->ttype, 0);
			BATseqbase(baskets[idx].primary[i], 0);
		} else
			baskets[idx].primary[i] = BATnew(b->htype, b->ttype, 0);

		BBPreleaseref(b->batCacheid);
		baskets[idx].cols[i++] = GDKstrdup(c->base.name);
	}
	mal_unset_lock(mal_contextLock, "register_basket");
	return MAL_SUCCEED;
}

str
DCregister_basket(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	sql_schema  *s;
	sql_table   *t;
	mvc *m = NULL;
	str schema, tbl, msg = getContext(cntxt, mb, &m, NULL);
	sql_trans *tr = m->session->tr;

	if (msg != MAL_SUCCEED)
		return msg;
	if (pci->argc == 3) {
		s = mvc_bind_schema(m, schema = *(str*)getArgReference(stk, pci, 1));
		tbl = *(str*)getArgReference(stk, pci, 2);
	} else {
		s = mvc_bind_schema(m, schema = schema_default);
		tbl = *(str*)getArgReference(stk, pci, 1);
	}
	if (s == NULL)
		throw(SQL, "datacell.register_basket", "Schema missing");
	t = mvc_bind_table(m, s, tbl);
	if (t == NULL)
		throw(SQL, "datacell.register_basket", "Table missing");

	/* check double registration */
	if (DClocate(schema, tbl))
		throw(SQL, "datacell.register_basket", "Basket defined twice.");

	return DCnewbasket(s, t, tr);
}

str
DCregister_all(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	sql_schema  *s;
	sql_table   *t;
	mvc *m = NULL;
	str msg = getContext(cntxt, mb, &m, NULL);
	sql_trans *tr = m->session->tr;
	node *o;

	(void)stk;
	(void)pci;
	s = mvc_bind_schema(m, schema_default);
	if (s == NULL)
		throw(SQL, "datacell.register_basket", "Schema missing");
	for (o = s->tables.set->h; msg == MAL_SUCCEED && o; o = o->next) {
		t = o->data;

		/* check double registration */
		if (DClocate(schema_default, t->base.name))
			throw(SQL, "datacell.register_basket", "Basket defined twice.");
		msg = DCnewbasket(s, t, tr);
	}
	return msg;
}

str
DCinventory(int *ret)
{
	BAT *b, *bn;
	int i;
	str msg = MAL_SUCCEED;

	b = BATnew(TYPE_str, TYPE_bat, 0);
	if (b == NULL)
		throw(SQL, "datacell.inventory", MAL_MALLOC_FAIL);
	for (i = 0; msg == MAL_SUCCEED && i < bsktTop; i++) {
		bn = BATdescriptor(BBPindex(baskets[i].name));
		if (bn == NULL)
			msg = createException(SQL, "datacell.inventory", MAL_MALLOC_FAIL);
		else {
			BUNins(b, baskets[i].name, &bn->batCacheid, FALSE);
			BBPreleaseref(bn->batCacheid);
		}
	}
	*ret = b->batCacheid;
	BBPkeepref(b->batCacheid);
	return msg;
}

int DCmemberCount(str schema, str tbl)
{
	int idx = DClocate(schema, tbl);
	return baskets[idx].colcount;
}

@-
The locks are designated towards groups
If you can not grab the lock then we have to wait.
@c
str DClock(int *ret, str *schema, str *tbl, int *delay)
{
	int bskt;

	bskt = DClocate(*schema, *tbl);
	if (bskt == 0)
		throw(MAL, "basket.lock", "Could not find the basket group");
#ifdef _DEBUG_BASKET
	stream_printf(DCout, "lock group %s\n", *tbl);
#endif
	mal_set_lock(baskets[bskt].lock, "lock basket");
#ifdef _DEBUG_BASKET
	stream_printf(DCout, "got  group locked %s\n", *tbl);
#endif
	(void)delay;  /* control spinlock */
	(void)ret;
	return MAL_SUCCEED;
}


str DClock2(int *ret, str *schema, str *tbl)
{
	int delay = 0;
	return DClock(ret, schema, tbl, &delay);
}

str DCunlock(int *ret, str *schema, str *tbl)
{
	int bskt;

	bskt = DClocate(*schema, *tbl);
	if (bskt == 0)
		throw(MAL, "basket.lock", "Could not find the basket group");
	mal_unset_lock(baskets[bskt].lock, "lock basket");
	(void)ret;
	return MAL_SUCCEED;
}

@}
