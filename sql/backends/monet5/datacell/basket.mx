# The contents of this file are subject to the MonetDB Public License
# Version 1.1 (the "License"); you may not use this file except in
# compliance with the License. You may obtain a copy of the License at
# http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
#
# Software distributed under the License is distributed on an "AS IS"
# basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
# License for the specific language governing rights and limitations
# under the License.
#
# The Original Code is the MonetDB Database System.
#
# The Initial Developer of the Original Code is CWI.
# Portions created by CWI are Copyright (C) 1997-2008 CWI.
# All Rights Reserved.

@f basket
@- Event baskets
Continuous query processing relies on event baskets 
passed through a processing pipeline. The baskets
are derived from ordinary SQL tables where the delta
processing is ignored.

@mal
module basket;

pattern register(tab:str):void
address BSKTregister
comment "Initialize a new basket based on a specific table definition in the datacell schema");

command lock{unsafe}(tbl:str,delay:int):void
address BSKTlock
comment "Lock a basket group and spinlock upon need";

command lock{unsafe}(tbl:str):void
address BSKTlock2
comment "Lock a basket group ";

command unlock{unsafe}(tbl:str):void
address BSKTunlock
comment "Unlock the basket";

pattern grab(tbl:str):bat[:oid,:any]...
address BSKTgrab
comment "Take a snapshot of the basket, destroying the origin when flg is set";

pattern pass(tbl:str, cols:any...)
address BSKTpass
comment "Dump the new tuples into the basket";

pattern pass(tbl:str, cols:bat[:oid,:any]...)
address BSKTpass
comment "Dump the new tuples into the basket";

command drop(tbl:str):void
address BSKTdrop
comment "Remove the basket";

command threshold(tbl:str,N:int):bit
address BSKTthreshold
comment "Set an acceptance threshold of N events before inspecting";

command window(tbl:str,N:int, S:int):bit
address BSKTwindow
comment "Use a window of N event and slide S afterwards";

command reset():void
address BSKTreset
comment "Remove all baskets";

command dump()
address BSKTdump
comment "Dump the status of the basket table";
@{
@h
#ifndef _BASKETS_
#define _BASKETS_

#include "monetdb_config.h"
#include "mal.h"
#include "mal_interpreter.h"
#include "sql.h"

#ifdef WIN32
#ifndef LIBCONTAINERS
#define datacell_export extern __declspec(dllimport)
#else
#define datacell_export extern __declspec(dllexport)
#endif
#else
#define datacell_export extern
#endif

/* #define _DEBUG_DATACELL     debug this module */
#define BSKTout GDKout
#define MAXCOL 128
#define MAXBSK 64

typedef struct{
	MT_Lock lock;
	str name;	/* table that represents the basket */
	int threshold ; /* bound to determine scheduling eligibility */
	int delay;	/* heartbeat to schedule next inspection */
	int winsize, winslide; /* sliding window operations */
	lng lastseen;
	int colcount;
	str *cols;
	BAT **primary;	
	/* statistics */
} *BSKTbasket, BSKTbasketRec;

datacell_export str schema_default;
datacell_export str BSKTregister(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
datacell_export str BSKTdrop(int *ret, str *tbl);
datacell_export str BSKTreset(int *ret);
datacell_export str BSKTinventory(int *ret);
datacell_export int BSKTmemberCount(str tbl);
datacell_export int BSKTlocate(str tbl);
datacell_export str BSKTdump(int *ret);
datacell_export str BSKTgrab(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
datacell_export str BSKTpass(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
datacell_export str BSKTthreshold(int *ret, str *tbl, int *sz);
datacell_export str BSKTwindow(int *ret, str *tbl, int *sz, int *slide);

datacell_export str BSKTlock(int *ret, str *tbl, int *delay);
datacell_export str BSKTunlock(int *ret, str *tbl);
datacell_export str BSKTlock2(int *ret, str *tbl);

datacell_export str BSKTnewbasket(sql_schema *s, sql_table *t, sql_trans *tr);
datacell_export void BSKTelements(str nme, str buf, str *schema, str *tbl);
datacell_export InstrPtr BSKTgrabInstruction(MalBlkPtr mb, str tbl);
datacell_export InstrPtr BSKTpassInstruction(MalBlkPtr mb, str tbl);
datacell_export void BSKTtolower(char *src);

datacell_export BSKTbasketRec *baskets;
datacell_export int bsktTop, bsktLimit;
datacell_export lng usec(void);
#endif
@c
#include "basket.h"
#ifdef WIN32
#include "winsock2.h"
#endif

str schema_default = "datacell";

BSKTbasketRec *baskets;   /* the datacell catalog */
int bsktTop, bsktLimit = 0;
static MT_Lock bsktLock;

#define lockBSKTbasketCatalog() mal_set_lock(bsktLock, "basket");
#define unlockBSKTbasketCatalog() mal_unset_lock(bsktLock, "basket");

@-
We have to obtain the precise wall-clock time
This is not produced by GDKusec, which returns microseconds
since the start of the program.
Notice that this routine consumes noticable time.
lng usec(void)
{
	struct timeval tp;

	gettimeofday(&tp, NULL);
	return ((lng)tp.tv_sec) * LL_CONSTANT(1000000) + (lng)tp.tv_usec;
}
@c

/* assume BUFSIZ buffer space */
void
BSKTelements(str nme, str buf, str *schema, str *tbl)
{
	char *c;
	strncpy(buf,nme, BUFSIZ);
	buf[BUFSIZ-1]= 0;
	c = strchr(buf,(int) '.');
	if ( c == 0) 
		snprintf(buf,BUFSIZ,"datacell.%s",nme);
	c = strchr(buf,(int) '.');
	*schema = buf;
	*c++ = 0;
	*tbl = c;
}

static int BSKTnewEntry()
{
	int i;
	for ( i=1; i< bsktLimit; i++)
	if (baskets[i].name == NULL)
		break;
	if ( i < bsktLimit) {
		if ( i == bsktTop)
			bsktTop++;
		return i;
	}
	if (bsktLimit == 0) {
		bsktLimit = MAXBSK;
		baskets = (BSKTbasketRec *)GDKzalloc(bsktLimit * sizeof(BSKTbasketRec));
		MT_lock_init(&bsktLock, "basket");
		bsktTop = 1; /* entry 0 is used as non-initialized */
	} else if (bsktTop == bsktLimit) {
		bsktLimit += MAXBSK;
		baskets = (BSKTbasketRec *)GDKrealloc(baskets, bsktLimit * sizeof(BSKTbasketRec));
	}
	return bsktTop++;
}

void
BSKTtolower(char *src)
{
	int i;
	for( i=0; i < BUFSIZ-1 && src[i]; i++)
		src[i] = (char) tolower((int)src[i]);
}

int
BSKTlocate(str tbl)
{
	int i;
	char buf[BUFSIZ];

	strncpy(buf,tbl,BUFSIZ);
	BSKTtolower(buf);

	for (i = 1; i < bsktTop; i++)
		if (tbl && baskets[i].name && strcmp(tbl, baskets[i].name) == 0 )
			return i;
	return 0;
}

str
BSKTnewbasket(sql_schema *s, sql_table *t, sql_trans *tr)
{
	int idx, i;
	node *o;
	str msg = MAL_SUCCEED;;
	BAT *b;
	sql_column  *c;
	char buf[BUFSIZ];

	mal_set_lock(mal_contextLock, "register");
	idx = BSKTnewEntry();
	MT_lock_init(&baskets[idx].lock, "register");

	snprintf(buf,BUFSIZ,"%s.%s",s->base.name, t->base.name);
	baskets[idx].name = GDKstrdup(buf);

	baskets[idx].colcount = 0;
	for (o = t->columns.set->h; o; o = o->next) baskets[idx].colcount++;
	baskets[idx].cols = GDKzalloc((baskets[idx].colcount + 1) * sizeof(str));
	baskets[idx].primary = GDKzalloc((baskets[idx].colcount + 1) * sizeof(BAT *));

	i = 0;
	for (o = t->columns.set->h; msg == MAL_SUCCEED && o; o = o->next) {
		c = o->data;
		b = store_funcs.bind_col(tr, c, 0);
		if (b == NULL) {
			mal_unset_lock(mal_contextLock, "register");
			throw(SQL, "sql.basket", "Can not access descriptor");
		}
		baskets[idx].primary[i] = b;
		baskets[idx].cols[i++] = GDKstrdup(c->base.name);
	}
	mal_unset_lock(mal_contextLock, "register");
	return MAL_SUCCEED;
}

str
BSKTregister(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	sql_schema  *s;
	sql_table   *t;
	mvc *m = NULL;
	str msg = getContext(cntxt, mb, &m, NULL);
	sql_trans *tr;
	char buf[BUFSIZ], *lsch, *ltbl;
	str tbl;

	BSKTelements( tbl = *(str*) getArgReference(stk,pci,1), buf, &lsch, &ltbl);
	BSKTtolower(lsch);
	BSKTtolower(ltbl);
	

	if (msg != MAL_SUCCEED)
		return msg;

	tr = m->session->tr;
	s = mvc_bind_schema(m, lsch);
	if (s == NULL)
		throw(SQL, "datacell.register", "Schema missing");

	t = mvc_bind_table(m, s, ltbl);
	if (t == NULL)
		throw(SQL, "datacell.register", "Table missing");

	/* check double registration */
	if (BSKTlocate(tbl))
		throw(SQL, "datacell.register", "Basket defined twice.");

	return BSKTnewbasket(s, t, tr);
}

int BSKTmemberCount(str tbl)
{
	int idx = BSKTlocate(tbl);
	return baskets[idx].colcount;
}

@-
The locks are designated towards the baskets.
If you can not grab the lock then we have to wait.
@c
str BSKTlock(int *ret, str *tbl, int *delay)
{
	int bskt;

	bskt = BSKTlocate(*tbl);
	if (bskt == 0)
		throw(MAL, "basket.lock", "Could not find the basket");
#ifdef _DEBUG_BASKET
	stream_printf(BSKTout, "lock group %s\n", *tbl);
#endif
	mal_set_lock(baskets[bskt].lock, "lock basket");
#ifdef _DEBUG_BASKET
	stream_printf(BSKTout, "got  group locked %s\n", *tbl);
#endif
	(void)delay;  /* control spinlock */
	(void)ret;
	return MAL_SUCCEED;
}


str BSKTlock2(int *ret, str *tbl)
{
	int delay = 0;
	return BSKTlock(ret, tbl, &delay);
}

str BSKTunlock(int *ret, str *tbl)
{
	int bskt;

	bskt = BSKTlocate(*tbl);
	if (bskt == 0)
		throw(MAL, "basket.lock", "Could not find the basket");
	mal_unset_lock(baskets[bskt].lock, "lock basket");
	(void)ret;
	return MAL_SUCCEED;
}


str
BSKTdrop(int *ret, str *tbl)
{
	int bskt;

	bskt = BSKTlocate(*tbl);
	if (bskt == 0)
		throw(MAL, "basket.drop", "Could not find the basket");
	baskets[bskt].colcount = 0;
	GDKfree(baskets[bskt].name);
	GDKfree(baskets[bskt].cols);
	GDKfree(baskets[bskt].primary);
	baskets[bskt].name = 0;
	baskets[bskt].cols = 0;
	baskets[bskt].primary = 0;

	(void)ret;
	return MAL_SUCCEED;
}

str
BSKTreset(int *ret)
{
	int i;
	for ( i = 1; i < bsktLimit; i++)
	if ( baskets[i].name)
		BSKTdrop(ret, &baskets[i].name);
	return MAL_SUCCEED;
}
str
BSKTdump(int *ret)
{
	int bskt;

	for ( bskt = 0; bskt < bsktLimit; bskt++) 
	if ( baskets[bskt].name){
		mnstr_printf(GDKout, "#baskets[%2d] %s columns %d threshold %d window=[%d,%d] events " BUNFMT "\n", bskt,
			baskets[bskt].name,
			baskets[bskt].colcount,
			baskets[bskt].threshold,
			baskets[bskt].winsize,
			baskets[bskt].winslide,
			(baskets[bskt].primary[0]? BATcount(baskets[bskt].primary[0]): 0));
	}
	(void)ret;
	return MAL_SUCCEED;
}

str
BSKTgrab(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	str tbl;
	int bskt, i, *ret;
	BAT *b,*bn,*v;

	(void) cntxt;
	(void) mb;
	tbl = *(str*) getArgReference(stk,pci, pci->argc-1);

	bskt = BSKTlocate(tbl);
	if (bskt == 0 )
		throw(MAL,"basket.grab","Basket not found");
	if ( baskets[bskt].colcount != pci->retc)
		throw(MAL,"basket.grab","Incompatible arguments");

	mal_set_lock(baskets[bskt].lock, "lock basket");
	for ( i=0; i < baskets[bskt].colcount; i++) {
		ret= (int*) getArgReference(stk,pci,i);
		b = baskets[bskt].primary[i];

		/* take care of sliding windows */
		if ( baskets[bskt].winsize ){
			bn = BATcopy(b, b->htype, b->ttype,TRUE);
			v = BATslice(bn, baskets[bskt].winslide,BATcount(bn));
			BATclear(b);
			b = BATsetaccess(b, BAT_WRITE);
			BATins(b,v, FALSE);
			BATsetcount(bn, baskets[bskt].winsize);
			BBPunfix(v->batCacheid);
		} else {
			bn = BATcopy(b, b->htype, b->ttype,TRUE);
			BATclear(b);
		}

		*ret = bn->batCacheid;
		BBPkeepref(*ret);
	}
	mal_unset_lock(baskets[bskt].lock, "unlock basket");
	return MAL_SUCCEED;
}

str
BSKTpass(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	str tbl;
	int bskt, i, j, ret;
	BAT *b, *bn;

	(void) cntxt;
	(void) mb;
	tbl = *(str*) getArgReference(stk,pci, pci->retc);

	bskt = BSKTlocate(tbl);
	if (bskt == 0 )
		throw(MAL,"basket.pass","Basket not found");
	if ( baskets[bskt].colcount != pci->argc - 2)
		throw(MAL,"basket.pass","Non-matching arguments");

	/* copy the content of the temporary BATs into the basket */
	mal_set_lock(baskets[bskt].lock, "lock basket");
	for ( j = 2,  i=0; i < baskets[bskt].colcount; i++, j++) {
		ret= *(int*) getArgReference(stk,pci,j);
		b = baskets[bskt].primary[i];
		bn = BATdescriptor(ret);
		BATappend(b, bn, TRUE);
		BBPreleaseref(ret);
	}
	mal_unset_lock(baskets[bskt].lock, "unlock basket");
	return MAL_SUCCEED;
}

InstrPtr
BSKTgrabInstruction(MalBlkPtr mb, str tbl)
{
	int i, j, bskt;
	InstrPtr p;
	BAT *b;

	bskt = BSKTlocate(tbl);
	if (bskt == 0 )
		return 0;
	p = newFcnCall(mb,basketRef,grabRef);
	p->argc= 0;
	for ( i=0; i < baskets[bskt].colcount; i++) {
		b = baskets[bskt].primary[i];
		j= newTmpVariable(mb,newBatType(TYPE_oid,b->ttype));
		setVarUDFtype(mb,j);
		setVarFixed(mb,j);
		p= pushArgument(mb,p, j);
	}
	p->retc= p->argc;
	p= pushStr(mb,p,tbl);
	return p;
}

InstrPtr
BSKTpassInstruction(MalBlkPtr mb, str tbl)
{
	int i, j, bskt;
	InstrPtr p;
	BAT *b;

	bskt = BSKTlocate(tbl);
	if (bskt == 0 )
		return 0;
	p = newInstruction(mb, ASSIGNsymbol);
	getArg(p,0)= newTmpVariable(mb,TYPE_any);
	getModuleId(p) = basketRef;
	getFunctionId(p) = putName("pass",4);
	p = pushStr(mb,p, tbl);
	for ( i=0; i < baskets[bskt].colcount; i++) {
		b = baskets[bskt].primary[i];
		j= newTmpVariable(mb,newBatType(TYPE_oid,b->ttype));
		p= pushArgument(mb,p, j);
	}
	return p;
}

str
BSKTthreshold(int *ret, str *tbl, int *sz)
{
	int bskt;
	bskt = BSKTlocate(*tbl);
	if (bskt == 0 )
		throw(MAL,"basket.threshold","Basket not found");
	if ( *sz < 0)
		throw(MAL,"basket.threshold","Illegal value");
	if ( *sz < baskets[bskt].winsize)
		throw(MAL,"basket.threshold","Threshold smaller then window size");
	baskets[bskt].threshold = *sz;
	*ret = TRUE;
	return MAL_SUCCEED;
}

str
BSKTwindow(int *ret, str *tbl, int *sz, int *slide)
{
	int idx;

	idx = BSKTlocate(*tbl);
	if (idx == 0 )
		throw(MAL,"basket.window","Basket not found");
	if ( *slide < 0 || *slide > *sz)
		throw(MAL,"basket.window","Illegal window slide");
	if ( *sz < 0 )
		throw(MAL,"basket.window","Illegal window size");

	/* administer the required size */
	baskets[idx].winsize = *sz;
	if ( baskets[idx].threshold < *sz)
		baskets[idx].threshold = *sz;
	baskets[idx].winslide = *slide;
	*ret = TRUE;
	return MAL_SUCCEED;
}
@}
