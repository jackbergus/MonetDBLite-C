@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2008 CWI.
@' All Rights Reserved.

@f petrinet
@a Martin Kersten
@v 1
@+ Petri-net engine
This module is a prototype for the implementation of a
Petri-net interpreter for the DataCell.

The example below accepts events at channel X
and the continuous query move them to Y.
Both query and emitter attached are scheduled. 
@example
-see test directory
@end example
@mal
module petrinet;
pattern register(mod:str,fcn:str, delay:int):void
address PNregister
comment "Add a continous query to the Petri net. It will analyse
the MAL block to determine the input/output dependencies. 
The delay provides an indicative upperbound on how fast to react";

command source(mod:str,fcn:str, schema:str,tbl:str):void
address PNsource
comment "Manually define an input basket for a transformation";

command target(mod:str,fcn:str, schema:str,tbl:str):void
address PNtarget
comment "Manually define an output basket for a transformation";

pattern unregister(mod:str,fcn:str):void
address PNunregister
comment "Manually define an continous query from the scheduler. ";

command pause()
address PNpauseScheduler
comment "Pause the Petri net controller";

command resume()
address PNresumeScheduler
comment "Resume the interpretation";

command stop()
address PNstopScheduler
comment "Stop the Petri net controller";

pattern analyse(mod:str, fcn:str)
address PNanalyseWrapper
comment "Check the input/output relationship";
command dump()
address PNdump
comment "Show the status of the Petri net";
@-
@{
@+ Implementation
@h
#ifndef _PETRINET_
#define _PETRINET_
#include "monetdb_config.h"
#include "mal_interpreter.h"
#include "sql_scenario.h"
#include "basket.h"

/* #define _DEBUG_PETRINET_ */

#define PNout GDKout 
/*#define  _BASKET_SIZE_*/

#ifdef WIN32
#ifndef LIBDATACELL
#define datacell_export extern __declspec(dllimport)
#else
#define datacell_export extern __declspec(dllexport)
#endif
#else
#define datacell_export extern
#endif

datacell_export str PNregister(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
datacell_export str PNpauseScheduler(int *ret);
datacell_export str PNresumeScheduler(int *ret);
datacell_export str PNstopScheduler(int *ret);
datacell_export str PNunregister( Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
datacell_export str PNdump(int *ret);
datacell_export str PNsource(int *ret, str *mod, str *fcn, str *schema, str *tbl);
datacell_export str PNtarget(int *ret, str *mod, str *fcn, str *schema, str *tbl);
datacell_export str PNanalysis(Client cntxt, MalBlkPtr mb);
datacell_export str PNanalyseWrapper(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
#endif

@c
#include "petrinet.h"
#include "mal_builder.h"

#define MAXPN 200			/* it is the minimum, if we need more space GDKrealloc */
#define PNcontrolInfinit 1	/* infinit loop of PNController  */
#define PNcontrolEnd 2		/* when all factories are disable PNController exits */

static int controlRounds = PNcontrolInfinit;


typedef struct {
	str schema, table;
	int bskt;		/* basket used */
	BAT *b;				/* reference BAT for checking content */
	int available;      /* approximate number of events available */
	size_t lastcount;   /* statistics gathering */
	size_t consumed;
} PoolRec;

typedef struct {
	str mod, fcn;
	MalBlkPtr mb;       /* Factory MAL block */
	MalStkPtr stk;      /* Factory stack */
	InstrPtr pci;       /* Factory re-entry point */
	int pc;
	int status;		/* query status waiting/running/ready */
	int delay;		/* maximum delay between calls */
	int cycles;     /* number of invocations of the factory */
	int events;		/* number of events consumed */
	size_t cycletime;   /* total cycle time for all invocations */
	int enabled, available;
	int srctop, trgttop;
	PoolRec *source, *target;
} PNnode, *petrinode;

PNnode *pnet;

int pnettop = 0;

int *enabled;     /*array that contains the id's of all queries that are enable to fire*/

#define PNinitialize 3
#define PNrunning 2
#define PNpause 1
#define PNstopped 0

#define PNwaiting 4
#define PNscheduled 5
#define PNexecute 6
static char *statusnames[7]={"stopped","pause","running","initialize","waiting","scheduled","execute"};

static int status = PNinitialize;
static int cycleDelay = 10; /* be careful, it affects response/throughput timings */

str PNstartThread(int *ret);

str PNanalyseWrapper(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	Module scope;
	Symbol s = 0;
	str *modnme = (str *)getArgReference(stk, pci, 1);
	str *fcnnme = (str *)getArgReference(stk, pci, 2);

	(void) mb;
	scope = findModule(cntxt->nspace, putName(*modnme, (int)strlen(*modnme)));
	if (scope)
		s = findSymbolInModule(scope, putName(*fcnnme, (int)strlen(*fcnnme)));
	if (s == NULL)
		throw(MAL, "petrinet.analysis", "Could not find function");

	return PNanalysis(cntxt,s->def);
}

/* A transition is only allowed when all inputs are privately used */
str PNregister(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	Module scope;
	Symbol s = 0;
	int *ret = (int *)getArgReference(stk, pci, 0);
	str *modnme = (str *)getArgReference(stk, pci, 1);
	str *fcnnme = (str *)getArgReference(stk, pci, 2);
	int *delay = (int*) getArgReference(stk,pci,3);
	(void)mb;

	scope = findModule(cntxt->nspace, putName(*modnme, (int)strlen(*modnme)));
	if (scope)
		s = findSymbolInModule(scope, putName(*fcnnme, (int)strlen(*fcnnme)));

	if (s == NULL)
		throw(MAL, "petrinet.transformation", "Could not find function");

	if (pnettop >= MAXPN) {
		if ((pnet = (PNnode*)GDKrealloc(pnet, sizeof(PNnode) * (pnettop + 1))) == NULL)
			throw(MAL, "petrinet.transformation", MAL_MALLOC_FAIL);
	}else if (pnettop == 0 && (pnet = (PNnode *)GDKzalloc(MAXPN * sizeof(PNnode))) == NULL)
			throw(MAL, "petrinet.transformation", MAL_MALLOC_FAIL);

	pnet[pnettop].mod = GDKstrdup(*modnme);
	pnet[pnettop].fcn = GDKstrdup(*fcnnme);
	pnet[pnettop].mb = s->def;
	pnet[pnettop].status = PNwaiting;
	pnet[pnettop].cycles = 0;
	/* all the rest is zero */
	/*assert(pnettop<MAXPN);*/

	if( pci->argc >3 ){
		delay = (int*) getArgReference(stk,pci,3);
		if (*delay < 0)
			throw(MAL, "datacell.setDelay", "Negative value not allowed");
		pnet[pnettop].delay = *delay;
	}
	pnettop++;

	(void)ret;
	return PNanalysis(cntxt,s->def);
}

str
PNunregister(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	str mod = *(str*) getArgReference(stk,pci,1);
	str fcn = *(str*) getArgReference(stk,pci,2);
    Module scope;
    Symbol s;
	int ret;
	int i,j;

	if ( status != PNpause)
		throw(MAL,"datacell.unregister","Scheduler should be paused first");
	(void) mb;
	/* check for a continous query */
	scope = findModule(cntxt->nspace, putName(mod, (int)strlen(mod)));
	if (scope)
		s = findSymbolInModule(scope, putName(fcn, (int)strlen(fcn)));
	if (s == NULL)
		throw(SQL, "datacell.remove", "Continuous query found");
	PNpauseScheduler(&ret);
	for( i = j = 0; i< pnettop; i++)
		if (strcmp(mod, pnet[i].mod) == 0 && strcmp(fcn, pnet[i].fcn) == 0) {
		} else
			pnet[j++] = pnet[i];
	pnettop = j;
	PNresumeScheduler(&ret);
	return MAL_SUCCEED;
}

str PNstopScheduler(int *ret)
{
	status = PNstopped;
	(void)ret;
	return MAL_SUCCEED;
}

str PNresumeScheduler(int *ret)
{
	if ( status == PNrunning)
		return MAL_SUCCEED;
	if ( status == PNstopped || status == PNpause)
		status = PNrunning;
	if ( status == PNinitialize)
		return PNstartThread(ret);
	return MAL_SUCCEED;
}

str PNpauseScheduler(int *ret)
{
	if ( status == PNpause)
		return MAL_SUCCEED;
	status = PNpause;
	do
		MT_sleep_ms(cycleDelay);  /* delay to make it more tractable */
	while ( status == PNrunning);
	(void)ret;
	return MAL_SUCCEED;
}

str PNdump(int *ret)
{
	int i, k;
	mnstr_printf(PNout,"#scheduler status %s\n", statusnames[status]);
	for (i = 0; i < pnettop; i++) {
		mnstr_printf(PNout, "#[%d]\t%s.%s %s delay %d cycles %d events %d time %d ms\n",
			i, pnet[i].mod, pnet[i].fcn, statusnames[pnet[i].status], pnet[i].delay, pnet[i].cycles, pnet[i].events, pnet[i].cycletime/1000);
		for (k = 0; k < pnet[i].srctop; k++)
			mnstr_printf(PNout, "#<--\t%s.%s %d %d\n",
				pnet[i].source[k].schema,
				pnet[i].source[k].table,
				pnet[i].source[k].bskt,
				pnet[i].source[k].lastcount,
				pnet[i].source[k].consumed);
		for (k = 0; k < pnet[i].trgttop; k++)
			mnstr_printf(PNout, "#-->\t%s.%s basket[%d] %d %d\n",
				pnet[i].target[k].schema,
				pnet[i].target[k].table,
				pnet[i].source[k].bskt,
				pnet[i].target[k].lastcount,
				pnet[i].target[k].consumed);
	}
	(void)ret;
	return MAL_SUCCEED;
}
@-
Make the basket group accessible to the transition function
The code currently relies on a physical adjacent ordering of all member
in the group.
@c
str PNsource(int *ret, str *mod, str *fcn, str *schema, str *tbl)
{
	int i, k, z;

	z = BSKTlocate(*schema, *tbl);
	for (i = 0; i < pnettop; i++) {
		if (strcmp(*mod, pnet[i].mod) == 0 && strcmp(*fcn, pnet[i].fcn) == 0) {
			k = pnet[i].srctop;
			if (k >= MAXPN) {
				if ((pnet[i].source = (PoolRec*)GDKrealloc(pnet[i].source, sizeof(PoolRec) * (k + 1))) == NULL)
					throw(MAL, "petrinet.source", MAL_MALLOC_FAIL);
			}
			else if (k == 0 && (pnet[i].source = (PoolRec *)GDKzalloc(MAXPN * sizeof(PoolRec))) == NULL)
					throw(MAL, "petrinet.source", MAL_MALLOC_FAIL);
			
			pnet[i].source[k].schema = GDKstrdup(*schema);
			pnet[i].source[k].table = GDKstrdup(*tbl);
			pnet[i].source[k].bskt = z;
			pnet[i].srctop++;

			/*assert(pnet[i].srctop< MAXPN);*/
		}
	}
	(void)ret;
	return MAL_SUCCEED;
}

str PNtarget(int *ret, str *mod, str *fcn, str *schema, str *tbl)
{
	int i, k, z;

	z = BSKTlocate(*schema, *tbl);
	for (i = 0; i < pnettop; i++) {
		if (strcmp(*mod, pnet[i].mod) == 0 && strcmp(*fcn, pnet[i].fcn) == 0) {
			k = pnet[i].trgttop;
			if (k >= MAXPN) {
				if ((pnet[i].target = (PoolRec*)GDKrealloc(pnet[i].target, sizeof(PoolRec) * (k + 1))) == NULL)
					throw(MAL, "petrinet.target", MAL_MALLOC_FAIL);
			} else 
			if ( k == 0 && (pnet[i].target = (PoolRec *)GDKzalloc(MAXPN * sizeof(PoolRec))) == NULL)
				throw(MAL, "petrinet.target", MAL_MALLOC_FAIL);

			pnet[i].target[k].schema = GDKstrdup(*schema);
			pnet[i].target[k].table = GDKstrdup(*tbl);
			pnet[i].target[k].bskt = z;
			pnet[i].trgttop++;
			/*assert(pnet[i].trgttop< MAXPN);*/
		}
	}
	(void)ret;
	return MAL_SUCCEED;
}

/* check the routine for input/output relationships */
/* Make sure we do not re-use the same source more then once */
str
PNanalysis(Client cntxt, MalBlkPtr mb)
{
	int i, j, k, flg, ret;
	InstrPtr p, sig = getInstrPtr(mb,0);
	str schema, tbl;

	/* first check for errors */
	for( i = 0; i < mb->stop; i++){
		p= getInstrPtr(mb,i);
		if ( getModuleId(p) == basketRef && getFunctionId(p) == grabRef ){
			schema = getVarConstant(mb,getArg(p,p->argc-3)).val.sval;
			tbl = getVarConstant(mb,getArg(p,p->argc-2)).val.sval;
			flg = getVarConstant(mb,getArg(p,p->argc-1)).val.ival;
			
			for (j = 0; j < pnettop; j++) 
			for ( k = 0; k < pnet[j].srctop; k++)
			if ( strcmp(schema, pnet[j].source[k].schema) == 0 && strcmp(tbl, pnet[j].source[k].table) == 0 )
				throw(MAL, "datacell.register","Duplicate use of continuous query input");
		}
	}
	for( i = 0; i < mb->stop; i++){
		p= getInstrPtr(mb,i);
		if ( getModuleId(p) == basketRef &&  getFunctionId(p) == grabRef ){
			schema = getVarConstant(mb,getArg(p,p->argc-3)).val.sval;
			tbl = getVarConstant(mb,getArg(p,p->argc-2)).val.sval;
			flg = getVarConstant(mb,getArg(p,p->argc-1)).val.ival;
			if ( flg) {
				mnstr_printf(cntxt->fdout,"#input basket %s.%s \n", schema,tbl);
				PNsource(&ret, &getModuleId(sig), &getFunctionId(sig), &schema, &tbl);
			} else {
				mnstr_printf(cntxt->fdout,"#output basket %s.%s \n", schema,tbl);
				PNtarget(&ret, &getModuleId(sig), &getFunctionId(sig), &schema, &tbl);
			}
		}
	}
	return MAL_SUCCEED;
}
@-
The PetriNet controller lives in an separate thread.
It cycles through the nodes, hunting for non-empty baskets 
and transformations that can fire.
The current policy is a simple round-robin. Later we will
experiment with more advanced schemes, e.g., priority queues.

During each step cycle we first enable the transformations.
Then an optional scheduler may decide on the priority
of the factory activation.
All sources 
@c
static void
PNcontroller(void *dummy)
{
	int i, j, cnt = 0;
	Symbol s;
	InstrPtr p;
	MalStkPtr glb;
	MalBlkPtr mb;
	Client cntxt;
	int k = -1;
	int m = 0;
	str msg;
	lng t;

	cntxt = MCinitClient(0,0,GDKout);
	cntxt->nspace = newModule(NULL, putName("user", 4));
	SQLinitEnvironment(cntxt);
	/* At this point we know what is the total number of factories.
	 * The most extremely case is when ALL factories are enable to fire
	 * so the maximum space we could ever need is = #factories (=pnettop)*/

	if ((enabled = (int *)GDKzalloc(MAXPN * sizeof(int))) == NULL) {
		mnstr_printf(cntxt->fdout, "#Petrinet Controller is unable to allocate more memory!\n");
		return;
	}

	/* create a fake procedure to highlight the continuous queries */
	s = newFunction("user", "pnController", FACTORYsymbol);
	p = getSignature(s);
	getArg(p, 0) = newTmpVariable(mb = s->def, TYPE_void);
	/* create an execution environment for all transitions */
	for (i = 0; i < pnettop; i++) {
		p = newFcnCall(mb, pnet[i].mod, pnet[i].fcn);
		pnet[i].pc = getPC(mb, p);
	}
	pushEndInstruction(mb);
	/*printf("\n1 mb->vtop:%d\n",mb->vtop);*/
	chkProgram(cntxt->nspace, mb);
	if (mb->errors) {
		mnstr_printf(cntxt->fdout, "#Petrinet Controller found errors\n");
		return;
	}
	newStack(glb, mb->vtop);
	memset((char *)glb, 0, stackSize(mb->vtop));
	glb->stktop = mb->vtop;
	glb->blk = mb;
#ifdef _DEBUG_PETRINET_
	printFunction(cntxt->fdout, mb, 0, LIST_MAL_ALL);
#endif
	status = PNrunning;
	do {
		if ( cycleDelay)
			MT_sleep_ms(cycleDelay);  /* delay to make it more tractable */
		while (status == PNpause  ) 
			MT_sleep_ms(status== PNstopped? (cycleDelay?cycleDelay:5) :cycleDelay);  
		/* collect latest statistics, note that we don't need a lock here,
		   because the count need not be accurate to the usec. It will simply
		   come back. We also only have to check the sources that are marked
		   empty. */
		status = PNrunning;
		for (k = i = 0; i < pnettop; i++) {
			pnet[i].available = 0;
			pnet[i].enabled = 0;
			for (j = 0; j < pnet[i].srctop; j++) {
				pnet[i].source[j].b = baskets[pnet[i].source[j].bskt].primary[0];
				if (pnet[i].source[j].b == 0) { /* we lost the BAT */
					pnet[i].enabled = 0;
					break;
				}
				pnet[i].source[j].available = cnt = (int)BATcount(pnet[i].source[j].b);
				if (cnt) {
#ifdef _DEBUG_PETRINET_
					mnstr_printf(cntxt->fdout, "#PETRINET:%d tuples for %s.%s, source %d\n", cnt, pnet[i].mod, pnet[i].fcn, j);
#endif
					pnet[i].available += cnt;
					pnet[i].enabled++;
				} else {
#ifdef _DEBUG_PETRINET_
					mnstr_printf(cntxt->fdout, "#PETRINET:no tuples for %s.%s, source %d\n",  pnet[i].mod, pnet[i].fcn, j);
#endif
					/*stop checking if the rest input BATs does not contain elements */
					pnet[i].enabled = 0;
					break;
				}
			}
			if (pnet[i].enabled == pnet[i].srctop) 
				/*save the ids of all continuous queries that can be executed */
				enabled[k++] = i;
		}

		/* execute each enabled transformation */
		/* We don't need to access again all the factories and check again which are available to execute them
		 * we have already kept the enable ones in the enabled list (created in the previous loop)
		 * and now it is enough to access that list*/
		for (m = 0; m < k; m++) {
			i = enabled[m];
			if (pnet[i].srctop == pnet[i].enabled && pnet[i].available > 0) {
#ifdef _DEBUG_PETRINET_
				mnstr_printf(cntxt->fdout, "#Run transition %s pc %d\n", pnet[i].fcn, pnet[i].pc);
#endif
#ifdef _BASKET_SIZE_
				mnstr_printf(cntxt->fdout, "\npnet[%d].srctop:%d\n", i, pnet[i].srctop);
				mnstr_printf(cntxt->fdout, "Function: %s basket size %d\n", pnet[i].fcn, pnet[i].source[0].available);
#endif

				t= GDKusec();
				msg = reenterMAL(cntxt, mb, pnet[i].pc, pnet[i].pc + 1, glb, 0, 0);
				pnet[i].cycletime += GDKusec() - t;
				if ( msg != MAL_SUCCEED){
					mnstr_printf(cntxt->fdout, "Function: %s failed\n", pnet[i].fcn);
					pnet[i].enabled = -1;
				}
				pnet[i].cycles++;
				pnet[i].enabled = 0;
				pnet[i].available = 0;
				for (j = 0; j < pnet[i].srctop; j++) {
					pnet[i].events += pnet[i].source[j].available;
					pnet[i].source[j].available = 0;  /* force recount */
				}
			}
		}
	} while (status != PNstopped);
	(void)dummy;
}

str PNstartThread(int *ret)
{
	MT_Id pid;
	int s;
#ifdef _DEBUG_PETRINET_
	PNdump(&s);
#endif

	if (MT_create_thread(&pid, PNcontroller, &s, MT_THR_DETACHED) != 0)
		throw(MAL, "petrinet.startThread", "Process creation failed");

	(void)ret;
	return MAL_SUCCEED;
}

str PNstart(int *ret)
{
	int s;
#ifdef _DEBUG_PETRINET_
	PNdump(&s);
	printf("\npnettop=%d\n", pnettop);
#endif
	status = PNrunning;
	controlRounds = PNcontrolEnd;

	PNcontroller(&s);

	(void)ret;
	return MAL_SUCCEED;
}
@}
