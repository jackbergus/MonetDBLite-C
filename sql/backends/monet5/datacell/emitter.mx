@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2008 CWI.
@' All Rights Reserved.

@f emitter
@a Martin Kersten
@v 1
@+ DataCell Emitter
This module is a prototype for the implementation of a
DataCell emitter.  It can be used as follows.
@example
@end example
After this call it will sent tuples from basket X_p1
to the stream Y at the localhost default port.

[tag each tuple with the latency?, use as derived
baskets? [arrival,departure,latency]]

Each emitter is supported by an independent thread
that reads the data from a container composed of a series of baskets.
The emitter keeps the events until it can create the channel.

The emitter behaves as an ordinary continuous query.
It is is awakened when new tuples have arrived in the
baskets.

@mal
module emitter;

command start{unsafe}(schema:str, tbl:str, host:str, port:int, prot:str)
address DCemitterNew
comment "Define a emitter based on a basket table. 
The emitter protocol is either active or passive. Return its handle";

command pause(schema:str, tbl:str)
address DCemitterPause
comment "Pause listening";

command resume(schema:str, tbl:str)
address DCemitterResume
comment "Resume a emitter thread";

command drop(schema:str, tb:str)
address DCemitterDrop
comment "Drop a emitter";

@-
@{
@+ Implementation
The implementation is derived from the emitter module.
@h
#ifndef _EMITTER_
#define _EMITTER_
#include "monetdb_config.h"
#include "mal_interpreter.h"
#include "tablet.h"
#include "mtime.h"
#include "basket.h"

#define _DEBUG_EMITTER_ 
#define EMout GDKout

#ifdef WIN32
#ifndef LIBADAPTERS
#define adapters_export extern __declspec(dllimport)
#else
#define adapters_export extern __declspec(dllexport)
#endif
#else
#define adapters_export extern
#endif

adapters_export str DCemitterNew(int *ret, str *schema, str *tbl, str *host, int *port, str *proto);
adapters_export str DCemitterPause(int *ret, str *schema, str *nme);
adapters_export str DCemitterResume(int *ret, str *schema, str *nme);
adapters_export str DCemitterDrop(int *ret, str *schema, str *nme);

#endif

@c
#include "emitter.h"
#include "batcalc.h"
#include "dcsocket.h"
#include "stream_socket.h"
#define EMPAUSE 1		/* connected but not reading the channel */
#define EMLISTEN 2		/* connected and reading the channel */
#define EMSTOP 3		/* not connected */
#define EMRESHUFFLE 4	/* reorganization of the BATs */
#define EMDROP 5		
#define EMERROR 8               /* failed to establish the stream */

#define EMPASSIVE 1
#define EMACTIVE 2

#define TCP 1
#define UDP 2
static int protocol= TCP;

#define PAUSEDEFAULT 1000

typedef struct EMITTER{
	str schema;
	str name;	
	str host;
	int port;
	int status;
	int protocol;/* control the delay between attempts to connect */
	int delay;
	int lck;
	SOCKET sockfd;
	SOCKET newsockfd;
	stream *emitter;
	str error;
	MT_Id pid;
	lng sent;
	Tablet table;
	struct EMITTER *nxt, *prv;
} EMrecord, *Emitter;

static Emitter emAnchor = NULL;

static str EMstartThread(Emitter em);

static Emitter
EMnew(str schema, str nme)
{
	Emitter em;
	em = (Emitter)GDKzalloc(sizeof(EMrecord));
	if ( em == NULL)
		return em;
	em->schema = GDKstrdup(schema);
	em->name = GDKstrdup(nme);
	if (emAnchor)
		emAnchor->prv = em;
	em->nxt = emAnchor;
	emAnchor = em;
	return em;
}

static Emitter
EMfind(str schema, str nme)
{
	Emitter r;
	for (r = emAnchor; r; r = r->nxt)
		if (strcmp(schema, r->schema) == 0 && strcmp(nme, r->name) == 0)
			break;
	return r;
}
@-
The MAL interface for managing the emitter pool
The baskets should already be defined. There order
is used to interpret the messages sent.
@c
str DCemitterNew(int *ret, str *schema, str *tbl, str *host, int *port, str *proto)
{
	Emitter em;
	int protocol, idx, i, j, len;
	BAT *b;

	if (EMfind(*schema, *tbl))
		throw(MAL, "emitter.new", "Duplicate emitter");
	if ( strcmp(*proto, "active") == 0)
		protocol = EMACTIVE;
	else
	if ( strcmp(*proto, "passive") == 0)
		protocol = EMPASSIVE;
	else
		throw(MAL, "emitter.new", "Illegal protocol");

	em = EMnew(*schema, *tbl);
	if( em == NULL)
		throw(MAL, "emitter.new", MAL_MALLOC_FAIL);
	em->host = GDKstrdup(*host);
	em->port = *port;
	em->delay = PAUSEDEFAULT;
	em->lck = 0;
	em->error = NULL;
	em->protocol = protocol;

	idx = BSKTlocate(*schema, *tbl);
	if (idx == 0) /* should not happen */
		throw(MAL, "emitter.new", "basket not found");
@-
All tables are prepended with a default tick bat.
It becomes the synchronization handle.
@c
	len = BSKTmemberCount(*schema, *tbl);
	if (len == 0)
		throw(MAL, "emitter.new", "Group has no members");

	em->table.format = GDKzalloc(sizeof(Column) * (len + 1));
	em->table.format[0].c[0] = NULL;
	em->table.format[0].name = NULL;
	em->table.format[0].sep = GDKstrdup("[ ");
	em->table.format[0].seplen = (int)strlen(em->table.format[0].sep);
	em->status = EMSTOP;

	for (j = 0, i = 0; i < baskets[idx].colcount; i++) {
		b = baskets[idx].primary[j];
		if (b == NULL) {
			em->table.nr_attrs = j;   /* ensure a consistent structure*/
			throw(MAL, "receptor.new", "Could not access descriptor");
		}
		BBPincref(b->batCacheid, TRUE);

		em->table.format[j].c[0] = b;
		em->table.format[j].ci[0] = bat_iterator(b);
		em->table.format[j].name = GDKstrdup(baskets[idx].cols[i]);
		em->table.format[j].sep =
			j <= len - 1 ? GDKstrdup(",") : GDKstrdup("]\n");
		em->table.format[j].seplen = (int)strlen(em->table.format[j].sep);
		em->table.format[j].type = ATOMname(b->ttype);
		em->table.format[j].adt = (b)->ttype;
		em->table.format[j].tostr = &TABLETadt_toStr;
		em->table.format[j].frstr = &TABLETadt_frStr;
		em->table.format[j].extra = em->table.format + j;
		em->table.format[j].len = em->table.format[j].nillen =
									  ATOMlen(em->table.format[j].adt, ATOMnilptr(em->table.format[j].adt));
		em->table.format[j].data = GDKmalloc(em->table.format[j].len);
		j++;
	}
	em->table.nr_attrs = j;

	(void)ret;
#ifdef _DEBUG_EMITTER_
	mnstr_printf(EMout, "Instantiate a new emitter %d fields\n", i);
#endif
	em->status = EMLISTEN;
	(void)ret;
	if ( MT_create_thread(&em->pid, (void (*)(void *))EMstartThread, em, MT_THR_DETACHED) != 0) {
		throw(MAL, "emitter.start", "Emitter initiation failed");
	}
	return MAL_SUCCEED;
}

str DCemitterPause(int *ret, str *schema, str *nme)
{
	Emitter em;

	em = EMfind(*schema, *nme);
	if (em == NULL)
		throw(MAL, "emitter.pause", "Emitter not defined");
	if (em->status == EMLISTEN)
		throw(MAL, "emitter.pause", "Emitter not started");

	em->status = EMPAUSE;

#ifdef _DEBUG_EMITTER_
	mnstr_printf(EMout, "Pause a emitter\n");
#endif
	(void)ret;
	return MAL_SUCCEED;
}

str DCemitterResume(int *ret, str *schema, str *nme)
{
	Emitter em;

	(void) ret;
	em = EMfind(*schema, *nme);
	if (em == NULL)
		throw(MAL, "emitter.resume", "Emitter not defined");
	if (em->status == EMLISTEN)
		throw(MAL, "emitter.resume", "Emitter already started");
#ifdef _DEBUG_EMITTER_
	mnstr_printf(EMout, "resume an emitter\n");
#endif
	return MAL_SUCCEED;
}

str DCemitterDrop(int *ret, str *schema, str *nme)
{
	Emitter em, rb;

	em = EMfind(*schema, *nme);
	if (em == NULL)
		throw(MAL, "emitter.drop", "Emitter not defined");
#ifdef _DEBUG_EMITTER_
	mnstr_printf(EMout, "Drop a emitter\n");
#endif
	(void)ret;
	if (emAnchor == em)
		emAnchor = em->nxt;
	rb = em->prv;
	if (em->nxt)
		em->nxt->prv = em->prv;
	if (rb)
		rb->nxt = em->nxt;
	em->status = EMDROP;
	if (em->lck)
		BSKTunlock(&em->lck, &em->schema, &em->name);
	MT_join_thread(em->pid);
	return MAL_SUCCEED;
}



/*open a stream socket to a certain server:port*/


@-
The hard part starts here. Each emitter is turned into
a separate thread that prepares the results for outside
actuators. Since they may be configured as a server,
we have to attempt a reconnect upon failure.
@c
			
static void
EMreconnect(Emitter em)
{
	do {
		em->error = socket_client_connect(&em->newsockfd, em->host, em->port);
		if (em->error) {
			mnstr_printf(EMout, "Emitter connect fails: %s\n", em->error);
			MT_sleep_ms(em->delay);
		}
	} while (em->error);
}

static void
EMbody(Emitter em)
{
	BUN cnt;
	size_t i, j;
	int ret;

bodyRestart:
	/* create the actual channel */
	em->emitter = socket_wastream(em->newsockfd, em->name);
	if (em->emitter == NULL) {
		perror("Emitter: Could not open stream");
		mnstr_printf(EMout, "stream %s.%d.%s\n", em->host, em->port, em->name);
		socket_close(em->newsockfd);
#ifdef _DEBUG_EMITTER_
		mnstr_printf(EMout, "Exit emitter body loop\n");
#endif
		return;
	}
@-
Consume each event and store the result.
If the thread is suspended, we sleep for at least one second.
@c
	for (ret = 1; ret >= 0; )
	{
		while (em->status == EMPAUSE) {
#ifdef _DEBUG_EMITTER_
			mnstr_printf(EMout, "pause emitter\n");
#endif
			MT_sleep_ms(em->delay);
		}
		if (em->status == EMSTOP)
			break;
		if (em->status == EMDROP) {
			mnstr_close(em->emitter);
			for (j = 0; j < em->table.nr_attrs; j++) {
				GDKfree(em->table.format[j].sep);
				GDKfree(em->table.format[j].name);
				if (em->table.format[j].c)
					BBPdecref(em->table.format[j].c[0]->batCacheid, TRUE);
			}
			GDKfree(em->table.format);
			shutdown(em->newsockfd, SHUT_RDWR);
			GDKfree(em);
			em = NULL;
			return;
		}
		if ((cnt = BATcount(em->table.format[1].c[0]))) {
			BSKTlock(&em->lck, &em->schema, &em->name, &em->delay);
			if (em->status != EMLISTEN)
				break;

			cnt = BATcount(em->table.format[1].c[0]);
#ifdef _DEBUG_EMITTER_
			mnstr_printf(EMout, "Emit " BUNFMT " tuples \n", cnt);
#endif
			em->table.nr = cnt;

			ret = TABLEToutput_file(&em->table, em->table.format[1].c[0], em->emitter);
#ifdef _DEBUG_EMITTER_
			if (ret < 0)
				mnstr_printf(EMout, "Tuple emission failed\n");
#endif
			if (ret < 0) {
				/* keep the events and try to setup a new connection */
				BSKTunlock(&em->lck, &em->schema, &em->name);
				break;
			}
			/* clean the baskets */
			for (i = 1; i < em->table.nr_attrs; i++)
				BATclear(em->table.format[i].c[0]);

			BSKTunlock(&em->lck, &em->schema, &em->name);
			if (em->table.error) {
				mnstr_printf(GDKerr, em->table.error);
				em->table.error = 0;
			}
		}
	}
	/* writing failed, lets restart */
	if (em->protocol == EMPASSIVE) {
#ifdef _DEBUG_EMITTER_
		mnstr_printf(EMout, "Restart the connection\n");
#endif
		EMreconnect(em);
		goto bodyRestart;
	}
#ifdef _DEBUG_EMITTER_
	mnstr_printf(EMout, "Exit emitter body loop\n");
#endif
	mnstr_close(em->emitter);
}

str
EMstartThread(Emitter em)
{
	GDKprotect();

#ifdef _DEBUG_EMITTER_
	mnstr_printf(EMout, "Emitter body %s started at %s:%d, servermode=%d\n",
		em->name, em->host, em->port, em->protocol);
#endif
	if (protocol == UDP) {
		em->emitter = udp_wastream(em->host, em->port, em->name);
		if (em->emitter == NULL) {
			perror("Emitter: Could not open stream");
			mnstr_printf(EMout, "stream %s.%d.%s\n", em->host, em->port, em->name);
			return MAL_SUCCEED;
		}
		EMbody(em);
#ifdef _DEBUG_EMITTER_
		mnstr_printf(EMout, "End of emitter thread\n");
#endif
		return MAL_SUCCEED;
	}

	/* Handling the TCP connection */
	if (em->protocol == EMPASSIVE &&
		(em->error = socket_server_connect(&em->sockfd, em->port))) {
		em->status = EMERROR;
		mnstr_printf(EMout, "EMSTART THREAD: failed to start server:%s\n", em->error);
		return MAL_SUCCEED;
	}
	do {
		if (em->status == EMSTOP) return MAL_SUCCEED;
		if (em->protocol == EMPASSIVE) {
#ifdef _DEBUG_RECEPTOR_
			mnstr_printf(EMout, "Emitter listens\n");
#endif
			em->error = socket_server_listen(em->sockfd, &em->newsockfd);
			if (em->error) {
				em->status = EMERROR;
				mnstr_printf(EMout, "Emitter listen fails: %s\n", em->error);
			}
		}

		/* in server mode you should expect new connections */
		if (em->protocol == EMACTIVE) {
			if (MT_create_thread(&em->pid, (void (*)(void *))EMbody, em, MT_THR_DETACHED) != 0) {
				close_stream(em->emitter);
				throw(MAL, "emitter.start", "Process creation failed");
			}
		} else {
			EMreconnect(em);
			EMbody(em);
		}
	} while (em->protocol == EMPASSIVE);
	shutdown(em->newsockfd, SHUT_RDWR);
	return MAL_SUCCEED;
}
@}
