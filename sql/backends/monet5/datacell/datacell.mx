# The contents of this file are subject to the MonetDB Public License
# Version 1.1 (the "License"); you may not use this file except in
# compliance with the License. You may obtain a copy of the License at
# http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
#
# Software distributed under the License is distributed on an "AS IS"
# basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
# License for the specific language governing rights and limitations
# under the License.
#
# The Original Code is the MonetDB Database System.
#
# The Initial Developer of the Original Code is CWI.
# Portions created by CWI are Copyright (C) 1997-2008 CWI.
# All Rights Reserved.

@f datacell
The interface from SQL passes through here.

@mal
module datacell;

pattern prepare()
address DCinitialize
comment "Initialize the datacell infrastructure";

pattern basket(schema:str,tab:str):void
address DCregister
comment "Initialize a new basket based on a specific table definition in the datacell schema");

pattern emitter(sch:str, tbl:str, host:str, port:int)
address DCemitter
comment "define a emitter based on a basket table. The emitter protocol is either active or passive.";

pattern receptor(sch:str, tbl:str, host:str, port:int)
address DCreceptor
comment "Define a receptor based on a basket table. The receptor protocol is either active or passive.";

pattern mode(sch:str, tbl:str, arg:str)
address DCmode
comment "Change the mode of the adaptor";

pattern protocol(sch:str, tbl:str, arg:str)
address DCprotocol
comment "Change the protocol of the adaptor";

pattern remove(schema:str,obj:str):void
address DCdrop
comment "Remove a basket, receptor or emitter";

pattern pause(schema:str,obj:str):void
address DCpause
comment "Pause a receptor or emitter";

pattern resume(schema:str,obj:str):void
address DCresume
comment "Pause a receptor or emitter";

pattern query(name:str,def:str):void
address DCquery
comment "Add a new continuous query.";

pattern start()
address DCstartScheduler
comment "Convert the datacell schema to a stream processing infrastructure";

pattern pause()
address DCrunScheduler
comment "(Re)start the petrinet scheduler.";

pattern resume()
address DCresumeScheduler
comment "Resume the petrinet scheduler.";

pattern finish()
address DCfinishScheduler
comment "Stop the petrinet scheduler.";

command inventory():bat[:str,:bat]
address DCinventory
comment "Produce a tabular view of the datacell streaming components";

command dump()
address DCdump
comment "Dump receptor/emitter status";
@{
@h
#ifndef _DATACELLS_
#define _DATACELLS_

#include "monetdb_config.h"
#include "mal.h"
#include "mal_interpreter.h"
#include "sql.h"
#include "sql_scenario.h"
#include "basket.h"
#include "receptor.h"
#include "emitter.h"
#include "petrinet.h"

#ifdef WIN32
#ifndef LIBCONTAINERS
#define datacell_export extern __declspec(dllimport)
#else
#define datacell_export extern __declspec(dllexport)
#endif
#else
#define datacell_export extern
#endif

/* #define _DEBUG_DATACELL     debug this module */

datacell_export str DCinitialize(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
datacell_export str DCregister(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
datacell_export str DCdrop(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
datacell_export str DCpause(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
datacell_export str DCresume(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
datacell_export str DCmode(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
datacell_export str DCprotocol(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
datacell_export str DCquery(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
datacell_export str DCdump(int *ret);

datacell_export str DCstartScheduler(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
datacell_export str DCpauseScheduler(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
datacell_export str DCresumeScheduler(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
datacell_export str DCfinishScheduler(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);

datacell_export str DCinventory(int *ret);

#endif
@c
#include "datacell.h"
#ifdef WIN32
#include "winsock2.h"
#endif

str
DCinitialize(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	(void) cntxt;
	(void) mb;
	(void) stk;
	(void) pci;
	return MAL_SUCCEED;
}

str
DCregister(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	return BSKTregister(cntxt,mb,stk,pci);
}

str
DCpause(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	int idx, ret=0;
	str schema= *(str*) getArgReference(stk, pci,1);
	str tbl= *(str*) getArgReference(stk, pci,2);

	idx = BSKTlocate(schema,tbl);
	if ( idx == 0)
		throw(SQL, "datacell.pause", "Basket not found");

	DCreceptorPause(&ret, &schema, &tbl);
	DCemitterPause(&ret, &schema, &tbl);
	(void) cntxt;
	(void) mb;
	return MAL_SUCCEED;
}

str
DCresume(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	int idx, ret= 0;
	str schema= *(str*) getArgReference(stk, pci,1);
	str tbl= *(str*) getArgReference(stk, pci,2);

	idx = BSKTlocate(schema,tbl);
	if ( idx == 0)
		throw(SQL, "datacell.pause", "Basket not found");

	DCreceptorResume(&ret, &schema, &tbl);
	DCemitterResume(&ret, &schema, &tbl);
	(void) cntxt;
	(void) mb;
	return MAL_SUCCEED;
}

str
DCmode(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	int idx, ret=0;
	str *schema= (str*) getArgReference(stk, pci,1);
	str *tbl= (str*) getArgReference(stk, pci,2);
	str *arg= (str*) getArgReference(stk, pci,3);

	idx = BSKTlocate(*schema, *tbl);
	if ( idx == 0)
		throw(SQL, "datacell.mode", "Basket not found");

	RCmode(&ret, schema, tbl,arg);
	EMmode(&ret, schema, tbl,arg);
	(void) cntxt;
	(void) mb;
	return MAL_SUCCEED;
}

str
DCprotocol(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	int idx, ret=0;
	str *schema= (str*) getArgReference(stk, pci,1);
	str *tbl= (str*) getArgReference(stk, pci,2);
	str *arg= (str*) getArgReference(stk, pci,3);

	idx = BSKTlocate(*schema, *tbl);
	if ( idx == 0)
		throw(SQL, "datacell.protocol", "Basket not found");

	RCprotocol(&ret, schema, tbl,arg);
	EMprotocol(&ret, schema, tbl,arg);
	(void) cntxt;
	(void) mb;
	return MAL_SUCCEED;
}

str
DCinventory(int *ret)
{
	BAT *b, *bn;
	int i;
	str msg = MAL_SUCCEED;

	b = BATnew(TYPE_str, TYPE_bat, BATTINY);
	if (b == NULL)
		throw(SQL, "datacell.inventory", MAL_MALLOC_FAIL);
	for (i = 0; msg == MAL_SUCCEED && i < bsktTop; i++) {
		bn = BATdescriptor(BBPindex(baskets[i].name));
		if (bn == NULL)
			msg = createException(SQL, "datacell.inventory", MAL_MALLOC_FAIL);
		else {
			BUNins(b, baskets[i].name, &bn->batCacheid, FALSE);
			BBPreleaseref(bn->batCacheid);
		}
	}
	*ret = b->batCacheid;
	BBPkeepref(b->batCacheid);
	return msg;
}

/* locate the MAL representation of this operation and extract the flow */
/* If the operation is not available yet, it should be compiled from its
   definition retained in the SQL catalog */
str
DCquery(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	str nme = *(str*) getArgReference(stk,pci,1);
	str *def = (str*) getArgReference(stk,pci,2);
	Symbol s;
	str msg;
	InstrPtr p;
	Module scope;

	(void) mb;
	msg = SQLstatementIntern(cntxt, def, nme, 0, 0);
	/* if ( msg )
		return msg; */
	scope = findModule(cntxt->nspace,putName("datacell",8));
	s = newFunction(putName("datacell",8), putName(nme, strlen(nme)),FUNCTIONsymbol);
	if ( s == NULL) 
		throw(SQL,"datacell.query","Procedure code does not exist");
    freeMalBlk(s->def);
    s->def = copyMalBlk(cntxt->curprg->def);
	p= getInstrPtr(s->def,0);
	setModuleId(p, putName("datacell",8));
	setFunctionId(p, putName(nme,strlen(nme)));
    insertSymbol(scope,s);
	PNanalysis(cntxt,s->def);
	return msg;
}

/*
 * The scheduler works against a converted datacell schema.
 * It should be stopped before additions to the scheme will take effect
*/

#define DCNONINITIALIZED 1
#define DCINITIALIZED 2
#define DCPAUSED 3

static int DCinitialized;

str
DCstartScheduler(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	sql_schema  *s;
	sql_table   *t;
	mvc *m = NULL;
	str msg = getContext(cntxt, mb, &m, NULL);
	sql_trans *tr;
	node *o;

	if ( DCinitialized != DCNONINITIALIZED)
		throw(MAL,"datacell.start","Datacell already initialized");
	if( msg != MAL_SUCCEED)
		return msg;
	tr = m->session->tr;

	/* we first have to identify all continuous queries and build up
	   the dataflow dependencies. Then for all open sources and sinks
	   we should generate the default receptor/emittor
	*/
	(void)stk;
	(void)pci;
	s = mvc_bind_schema(m, schema_default);
	if (s == NULL)
		throw(SQL, "datacell.register", "Schema missing");
	for (o = s->tables.set->h; msg == MAL_SUCCEED && o; o = o->next) {
		t = o->data;

		/* check double registration */
		if (BSKTlocate(schema_default, t->base.name))
			throw(SQL, "datacell.register", "Basket defined twice.");
		msg = BSKTnewbasket(s, t, tr);
	}
	mnstr_printf(cntxt->fdout,"# use datacell.pause(), datacell.resume(), and datacell.stop() to control scheduler.\n");
	DCinitialized = DCINITIALIZED;
	return msg;
}

str
DCresumeScheduler(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	int ret=0;
	if ( DCinitialized != DCPAUSED)
		throw(MAL,"datacell.pause","Datacell already running");
	PNresumeScheduler(&ret);
	(void) cntxt;
	(void) mb;
	(void) stk;
	(void) pci;
	return MAL_SUCCEED;
}

str
DCpauseScheduler(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	int ret=0;
	if ( DCinitialized != DCPAUSED)
		throw(MAL,"datacell.pause","Datacell already paused");
	PNpauseScheduler(&ret);
	(void) cntxt;
	(void) mb;
	(void) stk;
	(void) pci;
	return MAL_SUCCEED;
}

str
DCdropcheduler(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	int ret=0;
	if ( DCinitialized != DCINITIALIZED && DCinitialized != DCPAUSED)
		throw(MAL,"datacell.pause","Datacell already stopped");
	PNstopScheduler(&ret);
	(void) cntxt;
	(void) mb;
	(void) stk;
	(void) pci;
	DCinitialized = DCNONINITIALIZED;
	return MAL_SUCCEED;
}

str
DCdump(int *ret)
{
	BSKTdump(ret);
	RCdump();
	EMdump();
	return MAL_SUCCEED;
}
@}
