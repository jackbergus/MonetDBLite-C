# The contents of this file are subject to the MonetDB Public License
# Version 1.1 (the "License"); you may not use this file except in
# compliance with the License. You may obtain a copy of the License at
# http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
#
# Software distributed under the License is distributed on an "AS IS"
# basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
# License for the specific language governing rights and limitations
# under the License.
#
# The Original Code is the MonetDB Database System.
#
# The Initial Developer of the Original Code is CWI.
# Portions created by CWI are Copyright (C) 1997-2008 CWI.
# All Rights Reserved.

@f datacell
The interface from SQL passes through here.

@mal
module datacell;

pattern prelude()
address DCprelude
comment "Convert the datacell schema to a stream processing infrastructure";

pattern basket(tab:str):void
address DCregister
comment "Initialize a new basket based on a specific table definition in the datacell schema");

pattern emitter(tbl:str, host:str, port:int)
address DCemitterNew
comment "Define a emitter based on a basket table.";

pattern receptor(tbl:str, host:str, port:int)
address DCreceptorNew
comment "Define a receptor based on a basket table..";

pattern mode(tbl:str, arg:str)
address DCmode
comment "Change the mode of the adaptor to active/passive";

pattern protocol(tbl:str, arg:str)
address DCprotocol
comment "Change the protocol of the adaptor UDP/TCP/CSV";

pattern remove(obj:str):void
address DCremove
comment "Remove a basket, receptor or emitter";

pattern pause(obj:str):void
address DCpause
comment "Pause a receptor or emitter";

pattern resume(obj:str):void
address DCresume
comment "Pause a receptor or emitter";

pattern query(name:str,def:str):void
address DCquery
comment "Add a new continuous query.";

pattern register(def:str, delay:int):void
address PNregister
comment "Add a new continuous query to the scheduler with an
indicative maximum delady of scheduling.";

pattern register(def:str):void
address PNregister
comment "Add a new continuous query to the scheduler.";

pattern unregister(def:str):void
address PNunregister
comment "Remove a new continuous query from the scheduler.";


pattern pause()
address DCpauseScheduler
comment "(Re)start the petrinet scheduler.";

pattern resume()
address DCresumeScheduler
comment "Resume the petrinet scheduler.";

pattern postlude()
address DCpostlude
comment "Stop the petrinet scheduler.";

command inventory():bat[:str,:bat]
address DCinventory
comment "Produce a tabular view of the datacell streaming components";

command dump()
address DCdump
comment "Dump receptor/emitter status";
@{
@h
#ifndef _DATACELLS_
#define _DATACELLS_

#include "monetdb_config.h"
#include "mal.h"
#include "mal_interpreter.h"
#include "sql.h"
#include "sql_scenario.h"
#include "basket.h"
#include "receptor.h"
#include "emitter.h"
#include "petrinet.h"

#ifdef WIN32
#ifndef LIBCONTAINERS
#define datacell_export extern __declspec(dllimport)
#else
#define datacell_export extern __declspec(dllexport)
#endif
#else
#define datacell_export extern
#endif

/* #define _DEBUG_DATACELL     debug this module */

datacell_export str DCprelude(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
datacell_export str DCregister(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
datacell_export str DCremove(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
datacell_export str DCpause(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
datacell_export str DCresume(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
datacell_export str DCmode(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
datacell_export str DCprotocol(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
datacell_export str DCquery(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
datacell_export str DCdump(int *ret);

datacell_export str DCpauseScheduler(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
datacell_export str DCresumeScheduler(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
datacell_export str DCpostlude(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);

datacell_export str DCinventory(int *ret);

#endif
@c
#include "datacell.h"
#include "opt_datacell.h"
#include "sql_optimizer.h"

#ifdef WIN32
#include "winsock2.h"
#endif

/*
 * The scheduler works against a converted datacell schema.
 * It should be stopped before additions to the scheme will take effect
*/

#define DCNONINITIALIZED 1
#define DCINITIALIZED 2
#define DCPAUSED 3

static int DCprepared;

/* 
 * grab all tables in the datacell schema and turn them into baskets.
 * The same for all procedures, turn them into continuous queries.
*/

str
DCprelude(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	mvc *m = NULL;
	str msg = getContext(cntxt, mb, &m, NULL);
	sql_schema  *s;
	node *o;
	sql_table *t;
	sql_func *f;
	sql_trans *tr;

	s = mvc_bind_schema(m, schema_default);
	if (s == NULL)
		throw(SQL, "datacell.prelude", "Schema missing");
	tr = m->session->tr;
	for (o = s->tables.set->h; msg == MAL_SUCCEED && o; o = o->next) {
		t = o->data;
		if (BSKTlocate(t->base.name))
			throw(SQL, "datacell.register", "Basket defined twice.");
		msg = BSKTnewbasket(s, t, tr);
	}
	for (o = s->funcs.set->h; msg == MAL_SUCCEED && o; o = o->next) {
		f = o->data;
		printf("function %s\n", f->base.name);
	}
	DCprepared = DCINITIALIZED;
	(void) stk;
	(void) pci;
	return msg;
}

str
DCregister(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	return BSKTregister(cntxt,mb,stk,pci);
}

str
DCpause(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	int idx, ret=0;
	str tbl= *(str*) getArgReference(stk, pci,1);

	idx = BSKTlocate(tbl);
	if ( idx == 0)
		throw(SQL, "datacell.pause", "Basket not found");

	DCreceptorPause(&ret, &tbl);
	DCemitterPause(&ret, &tbl);
	(void) cntxt;
	(void) mb;
	return MAL_SUCCEED;
}

str
DCresume(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	int idx, ret= 0;
	str tbl= *(str*) getArgReference(stk, pci,1);

	idx = BSKTlocate(tbl);
	if ( idx == 0)
		throw(SQL, "datacell.pause", "Basket not found");

	DCreceptorResume(&ret, &tbl);
	DCemitterResume(&ret, &tbl);
	(void) cntxt;
	(void) mb;
	return MAL_SUCCEED;
}

str
DCremove(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	int idx;
	str tbl= *(str*) getArgReference(stk, pci,1);

	(void) cntxt;
	(void) mb;
	idx = BSKTlocate(tbl);
	if ( idx == 0) 
		throw(MAL,"datacell.remove","Basket not found");
	/* remove basket  and corresponding receptor/emitters depending on it*/
	return MAL_SUCCEED;
}

str
DCmode(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	int idx, ret=0;
	str *tbl= (str*) getArgReference(stk, pci,1);
	str *arg= (str*) getArgReference(stk, pci,2);

	idx = BSKTlocate(*tbl);
	if ( idx == 0)
		throw(SQL, "datacell.mode", "Basket not found");

	RCmode(&ret, tbl,arg);
	EMmode(&ret, tbl,arg);
	(void) cntxt;
	(void) mb;
	return MAL_SUCCEED;
}

str
DCprotocol(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	int idx, ret=0;
	str *tbl= (str*) getArgReference(stk, pci,1);
	str *arg= (str*) getArgReference(stk, pci,2);

	idx = BSKTlocate(*tbl);
	if ( idx == 0)
		throw(SQL, "datacell.protocol", "Basket not found");

	RCprotocol(&ret, tbl,arg);
	EMprotocol(&ret, tbl,arg);
	(void) cntxt;
	(void) mb;
	return MAL_SUCCEED;
}

str
DCinventory(int *ret)
{
	BAT *b, *bn;
	int i;
	str msg = MAL_SUCCEED;

	b = BATnew(TYPE_str, TYPE_bat, BATTINY);
	if (b == NULL)
		throw(SQL, "datacell.inventory", MAL_MALLOC_FAIL);
	for (i = 0; msg == MAL_SUCCEED && i < bsktTop; i++) {
		bn = BATdescriptor(BBPindex(baskets[i].name));
		if (bn == NULL)
			msg = createException(SQL, "datacell.inventory", MAL_MALLOC_FAIL);
		else {
			BUNins(b, baskets[i].name, &bn->batCacheid, FALSE);
			BBPreleaseref(bn->batCacheid);
		}
	}
	*ret = b->batCacheid;
	BBPkeepref(b->batCacheid);
	return msg;
}

/* locate the MAL representation of this operation and extract the flow */
/* If the operation is not available yet, it should be compiled from its
   definition retained in the SQL catalog */
str
DCquery(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	str nme = *(str*) getArgReference(stk,pci,1);
	str *def = (str*) getArgReference(stk,pci,2);
	Symbol s;
	str msg;
	InstrPtr p;
	Module scope;
	lng clk = GDKusec();
	char buf[BUFSIZ], *lsch, *ltbl;

	BSKTelements( nme, buf, &lsch, &ltbl);
	BSKTtolower(lsch);
	BSKTtolower(ltbl);

	(void) mb;
	/* check if the argument denotes a procedure name */
	/* if so, get its definition to be compiled */

	msg = SQLstatementIntern(cntxt, def, ltbl, 0, 0);
	/* if ( msg )
		return msg; */
	scope = findModule(cntxt->nspace,putName(lsch,strlen(lsch)));
	s = newFunction(putName(lsch,strlen(lsch)), putName(ltbl, strlen(ltbl)),FUNCTIONsymbol);
	if ( s == NULL) 
		throw(SQL,"datacell.query","Procedure code does not exist");
    freeMalBlk(s->def);
    s->def = copyMalBlk(cntxt->curprg->def);
	p= getInstrPtr(s->def,0);
	setModuleId(p, putName(lsch,strlen(lsch)));
	setFunctionId(p, putName(ltbl,strlen(ltbl)));
    insertSymbol(scope,s);
	/* printFunction(cntxt->fdout, s->def, 0, LIST_MAL_STMT);*/
	/* optimize the code and register at scheduler */
	if ( msg == MAL_SUCCEED) {
		OPTdatacellImplementation(cntxt,s->def,0,0);
		addOptimizers(cntxt,s->def,0);
		if ( msg == MAL_SUCCEED)
			msg = optimizeMALBlock(cntxt,s->def);
		if ( msg == MAL_SUCCEED)
			msg = optimizerCheck(cntxt, s->def, "optimizer.datacell", 1, GDKusec() - clk, OPT_CHECK_ALL);
		addtoMalBlkHistory(mb, "datacell");
	}
	return msg;
}

str
DCresumeScheduler(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	int ret=0;
	PNresumeScheduler(&ret);
	(void) cntxt;
	(void) mb;
	(void) stk;
	(void) pci;
	return MAL_SUCCEED;
}

str
DCpauseScheduler(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	int ret=0;
	PNpauseScheduler(&ret);
	(void) cntxt;
	(void) mb;
	(void) stk;
	(void) pci;
	return MAL_SUCCEED;
}

str
DCpostlude(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	int ret=0;
	if ( DCprepared != DCINITIALIZED && DCprepared != DCPAUSED)
		throw(MAL,"datacell.pause","Datacell already stopped");
	PNstopScheduler(&ret);
	(void) cntxt;
	(void) mb;
	(void) stk;
	(void) pci;
	DCprepared = DCNONINITIALIZED;
	return MAL_SUCCEED;
}

str
DCdump(int *ret)
{
	BSKTdump(ret);
	RCdump();
	EMdump();
	PNdump(ret);
	return MAL_SUCCEED;
}
@}
