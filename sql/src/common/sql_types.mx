@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2005 CWI.
@' All Rights Reserved.

@f sql_types
@a N.J. Nes
@*
The typing scheme of SQL is quite elaborate. The standard introduces
several basic types with a plethora of functions.
As long as we haven;t implemented a scheme to accept the
function type signature and relate it to a C-function linked
with the system, we have to patch the code below.

Given the large number of examples, it should be relatively
easy to find something akin you intend to enter.
@h
#ifndef SQL_TYPES_H
#define SQL_TYPES_H

#include <sql_mem.h>
#include <sql_list.h>
#include <sql_string.h>
#include <sql_catalog.h>
#include <stream.h>

#define EC_MAX 		13
#define EC_ANY	 	0
#define EC_TABLE 	1
#define EC_BIT 		2
#define EC_CHAR 	3
#define EC_STRING 	4
#define EC_BLOB		5

#define EC_NUM 		6
#define EC_INTERVAL 	7
#define EC_DEC 		8
#define EC_FLT 		9
#define EC_NUMBER(e)	(e==EC_NUM||e==EC_INTERVAL||e==EC_DEC||e==EC_FLT)

#define EC_TIME		10
#define EC_DATE		11
#define EC_TIMESTAMP	12
#define EC_TEMP(e)	(e==EC_TIME||e==EC_DATE||e==EC_TIMESTAMP)

#define EC_FIXED(e)	(e==EC_BIT||e==EC_CHAR||\
			 e==EC_NUM||e==EC_INTERVAL||e==EC_DEC||EC_TEMP(e))

extern list *aliases;
extern list *types;
extern list *aggrs;
extern list *funcs;

extern int bits2digits(int b);
extern int digits2bits(int d);

extern int sql_type_convert(int form, int to); /* return 1, convert possible but its a down cast, 2 convert possible can be done savely */
extern int is_commutative(char *fnm); 	/* return 1, if commutative */

extern char *sql_bind_alias(char *alias);

extern int sql_find_subtype(sql_subtype *res, char *name, unsigned int digits, unsigned int scale);
extern sql_subtype *sql_find_numeric(sql_subtype *r, int localtype, unsigned int digits);

extern sql_subtype *sql_bind_subtype(char *name, unsigned int digits, unsigned int scale);
extern sql_subtype *sql_bind_localtype(char *name);
extern sql_subtype *sql_create_subtype(sql_type *t, unsigned int s, unsigned int d);
extern void sql_init_subtype(sql_subtype *res, sql_type *t, unsigned int digits, unsigned int scale);
extern void sql_subtype_destroy(sql_subtype *t);

extern int type_cmp(sql_type *t1, sql_type *t2);
extern int subtype_cmp(sql_subtype *t1, sql_subtype *t2);
extern int is_subtype(sql_subtype *t1, sql_subtype *t2);
extern char *subtype2string(sql_subtype *t);

extern sql_type *sql_create_type(char *sqlname, unsigned int digits, unsigned int scale, unsigned char radix, unsigned char eclass, char *name);
extern void type_destroy(sql_type *t);

extern sql_arg *sql_create_arg(char *name, sql_subtype *t);
extern sql_arg *arg_dup(sql_arg *a);
extern void arg_destroy(sql_arg *a);

extern sql_subaggr *sql_bind_aggr(sql_module *m, char *name, sql_subtype *type);
extern sql_aggr *sql_create_aggr(char *name, char *imp, sql_type *tpe, sql_type *res);
extern sql_subaggr *sql_dup_aggr(sql_subaggr *a);
extern void sql_subaggr_destroy(sql_subaggr *f);

extern sql_subfunc *sql_find_func(sql_module *m, char *name, int nrargs);
extern sql_subfunc *sql_bind_member(sql_module *m, char *name, sql_subtype *tp, int nrargs);
extern sql_subfunc *sql_bind_func(sql_module *m, char *name, sql_subtype *tp1, sql_subtype *tp2);
extern sql_subfunc *sql_bind_func_result(sql_module *m, char *name, sql_subtype *tp1, sql_subtype *tp2, sql_subtype *res);

extern sql_subfunc *sql_bind_func_(sql_module *m, char *name, list *ops);
extern sql_subfunc *sql_bind_func_result_(sql_module *m, char *name, list *ops, sql_subtype *res);
extern sql_subfunc *sql_dup_func(sql_subfunc *f);
extern void sql_subfunc_destroy(sql_subfunc *f);
extern sql_subfunc *sql_bind_proc(sql_module *m, char *name, list *ops);

extern void func_destroy(sql_func *t);
extern sql_func *sql_create_func(char *name, char *imp, sql_type *tpe1, sql_type *tpe2, sql_type *res, int scale_fixing);
extern sql_func *sql_create_func3(char *name, char *imp, sql_type *tpe1, sql_type *tpe2, sql_type *tpe3, sql_type *res, int scale_fixing);
extern sql_func *sql_create_func4(char *name, char *imp, sql_type *tpe1, sql_type *tpe2, sql_type *tpe3, sql_type *tpe4, sql_type *res, int scale_fixing);

extern sql_func *sql_create_func_(char *name, char *imp, list *ops, sql_subtype *res);

extern sql_func *sql_create_sqlfunc(char *name, char *imp, list *ops, sql_subtype *res);

extern void types_init(int debug);
extern void types_exit();

#endif /* SQL_TYPES_H */
@c
#include "sql_types.h"
#include "sql_keyword.h"	/* for keyword_exists(), keywords_insert(), init_keywords(), exit_keywords() */
#include <string.h>

#define END_SUBAGGR	1
#define END_AGGR	2
#define END_SUBTYPE	3
#define END_TYPE	4

list *aliases = NULL;
list *types = NULL;
list *aggrs = NULL;
list *funcs = NULL;

static list *localtypes = NULL;

static void sqltypeinit();

int digits2bits(int digits) 
{
	if (digits == 1)
		return 3;
	else if (digits <= 2)
		return 6;
	else if (digits <= 3)
		return 9;
	else if (digits <= 4)
		return 13;
	else if (digits < 5) 
		return 16;
	else if (digits < 10) 
		return 32;
	else if (digits < 17) 
		return 51;
	return 64;
}

int bits2digits(int bits) 
{
	if (bits < 4) 
		return 1;
	else if (bits < 7) 
		return 2;
	else if (bits < 10) 
		return 3;
	else if (bits < 14) 
		return 4;
	else if (bits < 16) 
		return 5;
	else if (bits < 20) 
		return 6;
	else if (bits < 24) 
		return 7;
	else if (bits < 27) 
		return 8;
	else if (bits < 30) 
		return 9;
	else if (bits <= 32) 
		return 10;
	return 19;
}

static int convert_matrix[EC_MAX][EC_MAX] = {

/* EC_ANY */	{ 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0 },
/* EC_TABLE */	{ 0, 2, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0 },
/* EC_BIT */	{ 0, 0, 2, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0 },
/* EC_CHAR */	{ 1, 1, 1, 2, 1, 0, 1, 1, 1, 1, 1, 1, 1 },
/* EC_STRING */	{ 1, 1, 1, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1 },
/* EC_BLOB */	{ 0, 0, 0, 0, 1, 2, 0, 0, 0, 0, 0, 0, 0 },
/* EC_NUM */	{ 0, 0, 0, 1, 1, 0, 2, 2, 1, 1, 0, 1, 0 },
/* EC_INTERVAL*/{ 0, 0, 0, 1, 1, 0, 2, 0, 0, 0, 1, 0, 0 },
/* EC_DEC */	{ 0, 0, 0, 1, 1, 0, 2, 2, 2, 1, 0, 0, 0 },
/* EC_FLT */	{ 0, 0, 0, 1, 1, 0, 2, 2, 2, 2, 0, 0, 0 },
/* EC_TIME */	{ 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 2, 0, 0 },
/* EC_DATE */	{ 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 2, 0 },
/* EC_TSTAMP */	{ 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 2, 2 }
};

int sql_type_convert (int from, int to) 
{
	int c = convert_matrix[from][to];
	return c;
}

int is_commutative(char *fnm)
{
	if (strcmp("sql_add", fnm) == 0 ||
	    strcmp("sql_mul", fnm) == 0)
	    	return 1;
	return 0;
}

void
base_init(sql_base * b, sqlid id, int flag, char *name)
{
	b->id = id;

	b->wtime = 0;
	b->rtime = 0;
	b->flag = flag;
	b->name = NULL;
	if (name)
		b->name = _strdup(name);
}

void
base_set_name(sql_base * b, char *name)
{
	assert(name);
	if (b->name)
		_DELETE(b->name);
	b->name = _strdup(name);
}

void
base_destroy(sql_base * b)
{
	if (b->name)
		_DELETE(b->name);
}

void
sql_init_subtype(sql_subtype *res, sql_type *t, unsigned int digits, unsigned int scale)
{
	res->type = t;
	res->digits = digits ? digits : t->digits;
	if (t->digits && res->digits > t->digits)
		res->digits = t->digits;
	res->scale = scale;
}

sql_subtype *
sql_create_subtype(sql_type *t, unsigned int digits, unsigned int scale)
{
	sql_subtype *res = NEW(sql_subtype);

	sql_init_subtype(res, t, digits, scale);
	return res;
}


int
localtypes_cmp(int nlt, int olt)
{
	if (nlt == TYPE_flt || nlt == TYPE_dbl) {
		nlt = TYPE_dbl;
	} else if (nlt == TYPE_sht || nlt == TYPE_int || nlt == TYPE_lng) {
		nlt = TYPE_lng;
	}
	if (nlt == olt)
		return 1;
	return 0;
}

sql_subtype *
sql_find_numeric(sql_subtype *r, int localtype, unsigned int digits)
{
	node *m, *n;

	if (localtype == TYPE_flt || localtype == TYPE_dbl) {
		localtype = TYPE_dbl;
	} else {
		localtype = TYPE_lng;
	}

	for (n = types->h; n; n = n->next) {
		sql_type *t = n->data;

		if (localtypes_cmp(t->localtype, localtype)) {
			if ((digits && t->digits >= digits) || (digits == t->digits)) {
				sql_init_subtype(r, t, digits, 0);
				return r;
			}
			for (m = n->next; m; m = m->next) {
				t = m->data;
				if (!localtypes_cmp(t->localtype, localtype)) {
					break;
				}
				n = m;
				if ((digits && t->digits >= digits) || (digits == t->digits)) {
					sql_init_subtype(r, t, digits, 0);
					return r;
				}
			}
			t = n->data;
			sql_init_subtype(r, t, digits, 0);
			return r;
		}
	}
	return NULL;
}

int 
sql_find_subtype(sql_subtype *res, char *name, unsigned int digits, unsigned int scale)
{
	/* todo add approximate info
	 * if digits/scale == 0 and no approximate with digits/scale == 0
	 * exists we could return the type with largest digits
	 *
	 * returning the largest when no exact match is found is now the
	 * (wrong?) default
	 */
	/* assumes the types are ordered on name,digits,scale where is always
	 * 0 > n
	 */
	node *m, *n;

	for (n = types->h; n; n = n->next) {
		sql_type *t = n->data;

		if (t->sqlname[0] == name[0] && strcmp(t->sqlname, name) == 0) {
			if ((digits && t->digits >= digits) || (digits == t->digits)) {
				sql_init_subtype(res, t, digits, scale);
				return 1;
			}
			for (m = n->next; m; m = m->next) {
				t = m->data;
				if (strcmp(t->sqlname, name) != 0) {
					break;
				}
				n = m;
				if ((digits && t->digits >= digits) || (digits == t->digits)) {
					sql_init_subtype(res, t, digits, scale);
					return 1;
				}
			}
			t = n->data;
			sql_init_subtype(res, t, digits, scale);
			return 1;
		}
	}
	return 0;
}

sql_subtype *
sql_bind_subtype(char *name, unsigned int digits, unsigned int scale)
{
	sql_subtype *res = NEW(sql_subtype);
	
	if (!sql_find_subtype(res, name, digits, scale)) {
		_DELETE(res);
		return NULL;
	}
	return res;
}

#ifndef NDEBUG
static int sql_end = 0;
#endif

void
type_destroy(sql_type *t)
{
	base_destroy(&t->base);
	_DELETE(t->sqlname);
	_DELETE(t);
}

void
sql_subtype_destroy(sql_subtype *t)
{
	_DELETE(t);
}

sql_subtype *
sql_bind_localtype(char *name)
{
	node *n = localtypes->h;

	while (n) {
		sql_subtype *t = n->data;

		if (strcmp(t->type->base.name, name) == 0) {
			return t;
		}
		n = n->next;
	}
	assert(0);
	return NULL;
}

sql_type *
sql_bind_type(char *name)
{
	node *n = types->h;

	while (n) {
		sql_type *t = n->data;

		if (strcmp(t->base.name, name) == 0) {
			return t;
		}
		n = n->next;
	}
	assert(0);
	return NULL;
}

int
type_cmp(sql_type *t1, sql_type *t2)
{
	int res = 0;

	if (!t1 || !t2)
		return -1;
	/* types are only equal
	   iff they map onto the same systemtype */
	res = (t1->localtype - t2->localtype);
	if (res)
		return res;
	/* and
	   iff they have the same sqlname */
	return (strcmp(t1->sqlname, t2->sqlname));
}

int
subtype_cmp(sql_subtype *t1, sql_subtype *t2)
{
	if (!t1->type || !t2->type)
		return -1;
	if ( !(t1->type->eclass == t2->type->eclass && 
	       t1->type->eclass == EC_INTERVAL) &&
	      (t1->digits != t2->digits || t1->scale != t2->scale) )
		return -1;
	/* subtypes are only equal iff
	   they map onto the same systemtype */
	return (type_cmp(t1->type, t2->type));
}

int
is_subtype(sql_subtype *t1, sql_subtype *t2)
/* returns true if t1 is a sub type of t2 */
{
	if (!t1 || !t2)
		return 0;
	if (t2->digits > 0 && t1->digits > t2->digits) 
		return 0;
	/* subtypes are only equal iff
	   they map onto the same systemtype */
	return (type_cmp(t1->type, t2->type) == 0);
}

char *
subtype2string(sql_subtype *t)
{
	char buf[BUFSIZ]; 

	if (t->digits > 0) {
		if (t->scale > 0)
			snprintf(buf, BUFSIZ, "%s(%d,%d)", 
				t->type->sqlname, t->digits, t->scale);
		else
			snprintf(buf, BUFSIZ, "%s(%d)", 
				t->type->sqlname, t->digits);
	} else {
			snprintf(buf, BUFSIZ, "%s", t->type->sqlname);
	}
	return _strdup(buf);
}

sql_subaggr *
sql_bind_aggr(sql_module *m, char *sqlaname, sql_subtype *type)
{
	char *name = toLower(sqlaname);
	node *n = aggrs->h;

	(void)m;
	while (n) {
		sql_aggr *a = n->data;

		if (strcmp(a->base.name, name) == 0 && (!a->tpe.type || (type && is_subtype(type, &a->tpe )))) {
			int scale = 0;
			sql_subaggr *ares = NEW(sql_subaggr);

			_DELETE(name);
			sql_ref_init(&(ares->ref));
			ares->aggr = a;
			scale = a->res.scale;
			/* same scale as the input */
			if (type)
				scale = type->scale;
			sql_init_subtype(&ares->res, a->res.type, a->res.digits, scale);
			return ares;
		}
		n = n->next;
	}
	_DELETE(name);
	return NULL;
}

void
aggr_destroy(sql_aggr *t)
{
	base_destroy(&t->base);
	_DELETE(t->imp);
	_DELETE(t);
}

sql_subaggr *
sql_dup_aggr(sql_subaggr *a)
{
	sql_ref_inc(&(a->ref));
	return a;
}

void
sql_subaggr_destroy(sql_subaggr *a)
{
	int ref = 0;

	if ((ref = sql_ref_dec(&(a->ref))) == 0) {
		_DELETE(a);
#ifndef NDEBUG
	} else if (sql_end == END_SUBAGGR) {
		printf("= REFCOUNT of subaggr %s %s is wrong %d\n", a->aggr->base.name, a->aggr->imp, ref);
#else
		(void) ref;	/* pacify picky compilers... */
#endif
	}
}


static sql_subfunc *
func_cmp(sql_func *f, char *name, int nrargs) 
{
	if (strcmp(f->base.name, name) == 0) {
		if (list_length(f->ops) == nrargs) {
			int scale = 0;
			sql_subfunc *fres = NEW(sql_subfunc);

			_DELETE(name);
			sql_ref_init(&(fres->ref));
			fres->func = f;
			sql_init_subtype(&fres->res, f->res.type, f->res.digits, scale);
			return fres;
		}
	}
	return NULL;
}

sql_subfunc *
sql_find_func(sql_module *m, char *sqlfname, int nrargs)
{
	char *name = toLower(sqlfname);
	node *n = funcs->h;
	sql_subfunc *fres;

	assert(nrargs);
	for (; n; n = n->next) {
		sql_func *f = n->data;

		if (!f->res.type)
			continue;
		if ((fres = func_cmp(f, name, nrargs )) != NULL) 
			return fres;
	}
	if (m) {
		node *n;

		if (m->funcs.set) for (n=m->funcs.set->h; n; n = n->next) {
			sql_func *f = n->data;

			if (f->aggr)
				continue;
			if ((fres = func_cmp(f, name, nrargs )) != NULL) 
				return fres;
		}
	}
	_DELETE(name);
	return NULL;
}


/* find function based on first argument */
sql_subfunc *
sql_bind_member(sql_module *m, char *sqlfname, sql_subtype *tp, int nrargs)
{
	char *name = toLower(sqlfname);
	node *n;

	(void)m;
	assert(nrargs);
	for (n = funcs->h; n; n = n->next) {
		sql_func *f = n->data;

		if (!f->res.type)
			continue;
		if (strcmp(f->base.name, name) == 0) {
			if (list_length(f->ops) == nrargs && is_subtype(tp, &((sql_arg *) f->ops->h->data)->type)) {

				int scale = 0;
				sql_subfunc *fres;

				/* member functions should not match binary operators */
				if (nrargs == 2 && subtype_cmp( &((sql_arg *) f->ops->h->data)->type, &((sql_arg *) f->ops->h->next->data)->type) == 0)
					continue;
				fres = NEW(sql_subfunc);

				_DELETE(name);
				sql_ref_init(&(fres->ref));
				fres->func = f;
				/* same scale as the input */
				if (tp && tp->scale > scale)
					scale = tp->scale;
				sql_init_subtype(&fres->res, f->res.type, f->res.digits, scale);
				return fres;
			}
		}
	}
	_DELETE(name);
	return NULL;
}

sql_subfunc *
sql_bind_func(sql_module *m, char *sqlfname, sql_subtype *tp1, sql_subtype *tp2)
{
	list *l = list_create((fdestroy)NULL);
	sql_subfunc *fres;

	if (tp1)
		list_append(l, tp1);
	if (tp2)
		list_append(l, tp2);

	fres = sql_bind_func_(m, sqlfname, l);
	list_destroy(l);
	return fres;
}

int
arg_subtype_cmp(sql_arg *a, sql_subtype *t)
{
	return (is_subtype(t, &a->type )?0:-1);
}

sql_subfunc *
sql_bind_func_(sql_module *m, char *sqlfname, list *ops)
{
	char *name = toLower(sqlfname);
	node *n = funcs->h;

	(void)m;
	while (n) {
		sql_func *f = n->data;

		if (!f->res.type)
			continue;
		if (strcmp(f->base.name, name) == 0) {
			if (list_cmp(f->ops, ops, (fcmp) &arg_subtype_cmp) == 0) {
				unsigned int scale = 0;
				sql_subfunc *fres = NEW(sql_subfunc);

				_DELETE(name);
				sql_ref_init(&(fres->ref));
				fres->func = f;
				for (n = ops->h; n; n = n->next) {
					sql_subtype *a = n->data;

					/* same scale as the input */
					if (a && a->scale > scale)
						scale = a->scale;
				}
				sql_init_subtype(&fres->res, f->res.type, f->res.digits, scale);
				return fres;
			}
		}
		n = n->next;
	}
	_DELETE(name);
	return NULL;
}

sql_subfunc *
sql_bind_func_result(sql_module *m, char *sqlfname, sql_subtype *tp1, sql_subtype *tp2, sql_subtype *res)
{
	list *l = list_create((fdestroy) NULL);
	sql_subfunc *fres;

	if (tp1)
		list_append(l, tp1);
	if (tp2)
		list_append(l, tp2);

	fres = sql_bind_func_result_(m, sqlfname, l, res);
	list_destroy(l);
	return fres;
}

sql_subfunc *
sql_bind_func_result_(sql_module *m, char *sqlfname, list *ops, sql_subtype *res)
{
	char *name = toLower(sqlfname);
	node *n = funcs->h;

	(void)m;
	while (n) {
		sql_func *f = n->data;

		if (!f->res.type)
			continue;
		if (strcmp(f->base.name, name) == 0 && is_subtype(&f->res, res) && list_cmp(f->ops, ops, (fcmp) &arg_subtype_cmp) == 0) {
			unsigned int scale = 0;
			sql_subfunc *fres = NEW(sql_subfunc);

			_DELETE(name);
			sql_ref_init(&(fres->ref));
			fres->func = f;
			for (n = ops->h; n; n = n->next) {
				sql_subtype *a = n->data;

				/* same scale as the input */
				if (a && a->scale > scale)
					scale = a->scale;
			}
			sql_init_subtype(&fres->res, f->res.type, f->res.digits, scale);
			return fres;
		}
		n = n->next;
	}
	_DELETE(name);
	return NULL;
}

sql_subfunc *
sql_bind_proc(sql_module *m, char *sqlfname, list *ops)
{
	char *name = toLower(sqlfname);
	node *n = funcs->h;

	(void)m;
	while (n) {
		sql_func *f = n->data;

		if (f->res.type)
			continue;
		if (strcmp(f->base.name, name) == 0 && list_cmp(f->ops, ops, (fcmp) &arg_subtype_cmp) == 0) {
			sql_subfunc *fres = NEW(sql_subfunc);

			_DELETE(name);
			sql_ref_init(&(fres->ref));
			fres->func = f;
			fres->res.type = NULL;
			return fres;
		}
		n = n->next;
	}
	_DELETE(name);
	return NULL;
}

void
func_destroy(sql_func *t)
{
	base_destroy(&t->base);
	if (t->imp)
		_DELETE(t->imp);
	if (t->ops)
		list_destroy(t->ops);
	_DELETE(t);
}

sql_subfunc *
sql_dup_func(sql_subfunc *f)
{
	sql_ref_inc(&(f->ref));
	return f;
}

void
sql_subfunc_destroy(sql_subfunc *f)
{
	int ref = 0;

	if ((ref = sql_ref_dec(&(f->ref))) == 0) {
		_DELETE(f);
#ifndef NDEBUG
	} else if (sql_end == END_SUBAGGR) {
		printf("= REFCOUNT of subfunc %s %s is wrong %d\n", f->func->base.name, f->func->imp, ref);
#else
		(void) ref;	/* pacify picky compilers... */
#endif
	}
}


void
sql_create_alias(char *name, char *alias)
{
	sql_alias *a = NEW(sql_alias);

	a->name = _strdup(name);
	a->alias = _strdup(alias);
	list_append(aliases, a);
	if (!keyword_exists(a->alias))
		keywords_insert(a->alias, KW_ALIAS);
}

void
alias_destroy(sql_alias * a)
{
	_DELETE(a->name);
	_DELETE(a->alias);
	_DELETE(a);
}

char *
sql_bind_alias(char *alias)
{
	node *n;

	for (n = aliases->h; n; n = n->next) {
		sql_alias *a = n->data;

		if (strcmp(a->alias, alias) == 0) {
			return a->name;
		}
	}
	return NULL;
}


sql_type *
sql_create_type(char *sqlname, unsigned int digits, unsigned int scale, unsigned char radix, unsigned char eclass, char *name)
{
	sql_type *t = NEW(sql_type);

	base_init(&t->base, OIDnew(1), TR_OLD, name);
	t->sqlname = toLower(sqlname);
	t->digits = digits;
	t->scale = scale;
	t->localtype = ATOMindex(t->base.name);
	t->radix = radix;
	t->eclass = eclass;
	if (!keyword_exists(t->sqlname))
		keywords_insert(t->sqlname, KW_TYPE);
	list_append(types, t);

	list_append(localtypes, sql_create_subtype(t, 0, 0));

	return t;
}

sql_aggr *
sql_create_aggr(char *name, char *imp, sql_type *tpe, sql_type *res)
{
	sql_aggr *t = NEW(sql_aggr);
	char *n = NULL;

	base_init(&t->base, OIDnew(1), TR_OLD, n=toLower(name));
	_DELETE(n);
	t->imp = _strdup(imp);
	if (tpe) {
		sql_init_subtype(&t->tpe, tpe, 0, 0);
	} else {
		t->tpe.type = NULL;
	}
	assert(res);
	sql_init_subtype(&t->res, res, 0, 0);
	t->nr = list_length(aggrs);
	list_append(aggrs, t);
	return t;
}

sql_arg *
sql_create_arg(char *name, sql_subtype *t)
{
	sql_arg *a = NEW(sql_arg);

	a->name = name;
	a->type = *t;
	return a;
}

static sql_arg *
create_arg(char *name, sql_subtype *t)
{
	sql_arg *a = sql_create_arg(name, t);

	sql_subtype_destroy(t);
	return a;
}


sql_arg *
arg_dup(sql_arg *oa)
{
	sql_arg *a = NEW(sql_arg);

	a->name = _strdup(oa->name);
	a->type = oa->type;
	return a;
}

void
arg_destroy(sql_arg *a)
{
	if (a->name)
		_DELETE(a->name);
	_DELETE(a);
}

sql_func *
sql_create_func(char *name, char *imp, sql_type *tpe1, sql_type *tpe2, sql_type *res, int scale_fixing)
{
	list *l = list_create((fdestroy) &arg_destroy);
	sql_subtype sres;

	if (tpe1)
		list_append(l,create_arg(NULL, sql_create_subtype(tpe1, 0, 0)));
	if (tpe2)
		list_append(l,create_arg(NULL, sql_create_subtype(tpe2, 0, 0)));

	sql_init_subtype(&sres, res, 0, scale_fixing);
	return sql_create_func_(name, imp, l, &sres);
}

sql_func *
sql_create_func3(char *name, char *imp, sql_type *tpe1, sql_type *tpe2, sql_type *tpe3, sql_type *res, int scale_fixing)
{
	list *l = list_create((fdestroy) &arg_destroy);
	sql_subtype sres;

	list_append(l, create_arg(NULL, sql_create_subtype(tpe1, 0, 0)));
	list_append(l, create_arg(NULL, sql_create_subtype(tpe2, 0, 0)));
	list_append(l, create_arg(NULL, sql_create_subtype(tpe3, 0, 0)));

	sql_init_subtype(&sres, res, 0, scale_fixing);
	return sql_create_func_(name, imp, l, &sres);
}

sql_func *
sql_create_func4(char *name, char *imp, sql_type *tpe1, sql_type *tpe2, sql_type *tpe3, sql_type *tpe4, sql_type *res, int scale_fixing)
{
	list *l = list_create((fdestroy) &arg_destroy);
	sql_subtype sres;

	list_append(l, create_arg(NULL, sql_create_subtype(tpe1, 0, 0)));
	list_append(l, create_arg(NULL, sql_create_subtype(tpe2, 0, 0)));
	list_append(l, create_arg(NULL, sql_create_subtype(tpe3, 0, 0)));
	list_append(l, create_arg(NULL, sql_create_subtype(tpe4, 0, 0)));

	sql_init_subtype(&sres, res, 0, scale_fixing);
	return sql_create_func_(name, imp, l, &sres);
}


sql_func *
sql_create_func_(char *name, char *imp, list *ops, sql_subtype *res)
{
	sql_func *t = NEW(sql_func);
	char *n = NULL;

	assert(res && ops);
	base_init(&t->base, OIDnew(1), TR_OLD, n=toLower(name));
	_DELETE(n);
	t->imp = _strdup(imp);
	t->ops = ops;
	if (res)	
		t->res = *res;
	else
		t->res.type = NULL;
	t->nr = list_length(funcs);
	t->sql = 0;
	list_append(funcs, t);
	return t;
}

sql_func *
sql_create_sqlfunc(char *name, char *imp, list *ops, sql_subtype *res)
{
	sql_func *t = NEW(sql_func);
	char *n = NULL;

	assert(res && ops);
	base_init(&t->base, OIDnew(1), TR_OLD, n=toLower(name));
	_DELETE(n);
	t->imp = _strdup(imp);
	t->ops = ops;
	if (res)	
		t->res = *res;
	else
		t->res.type = NULL;
	t->nr = list_length(funcs);
	t->sql = 1;
	list_append(funcs, t);
	return t;
}

void
types_init(int debug)
{
	(void)debug;
	aliases = list_create((fdestroy) &alias_destroy);
	types = list_create((fdestroy) &type_destroy);
	localtypes = list_create((fdestroy) &sql_subtype_destroy);
	aggrs = list_create((fdestroy) &aggr_destroy);
	funcs = list_create((fdestroy) &func_destroy);
	sqltypeinit();
}

/* SQL service initialization
This C-code version initializes the
parser catalogs with typing information. Although, in principle,
many of the function signatures can be obtained from the underlying
database kernel, we have chosen for this explicit scheme for one
simple reason. The SQL standard dictates the types and we have to
check their availability in the kernel only. The kernel itself could
include manyfunctions for which their is no standard.
lead to unexpected
*/


typedef struct {
	char *h, *t;
} pair;

static char *
local_result(char *s)
{
	int i;
	pair type_map[] = {
		{"uchr", "int"},
		{"sht", "int"},
		{"int", "lng"},
		{"lng", "lng"},
		{"flt", "dbl"},
		{"dbl", "dbl"},
		{0, 0}
	};

	for (i = 0; type_map[i].h; i++) {
		if (strcmp(s, type_map[i].h) == 0) {
			return type_map[i].t;
		}
	}
	return NULL;
}

@-
The current implementation uses a hardwired type and function table.
This routine is called once upon restart of the system.
@c
void
sqltypeinit()
{
	int i;

	sql_type *ts[100];
	sql_type **misc, **strings, **numerical;
	sql_type **decimals, **floats, **dates, **end, **t;
	sql_type *INT, *LNG, *OID, *BIT, *DBL;
	sql_type *SECINT, *MONINT, *DTE; 
	sql_type *TME, *TMETZ, *TMESTAMP, *TMESTAMPTZ;

	t = ts;
	*t++ = sql_create_type("TABLE", 0, 0, 0, EC_TABLE, "bat");

	misc = t;
	BIT = *t++ = sql_create_type("BOOLEAN", 1, 0, 2, EC_BIT, "bit");
	sql_create_alias(BIT->sqlname, "BOOL");

	strings = t;
	*t++ = sql_create_type("CHAR",    0, 0, 0, EC_CHAR, "str");
	*t++ = sql_create_type("VARCHAR", 0, 0, 0, EC_STRING, "str");
	*t++ = sql_create_type("CLOB",    0, 0, 0, EC_STRING, "str");

	numerical = t;

	OID = *t++ = sql_create_type("OID", 31, 0, 2, EC_NUM, "oid");
	(void)OID; /* pacify picky compilers */
	/*sql_create_type("TINYINT",   8, SCALE_FIX, 2,  EC_NUM, "uchr"); */
	      *t++ = sql_create_type("SMALLINT", 16, SCALE_FIX, 2, EC_NUM, "sht");
	INT = *t++ = sql_create_type("INT",      32, SCALE_FIX, 2, EC_NUM, "int");
	LNG = *t++ = sql_create_type("BIGINT",   64, SCALE_FIX, 2, EC_NUM, "lng");

	decimals = t;
	/* decimal(d,s) (d indicates nr digits,
	   s scale indicates nr of digits after the dot .) */
	/*#sql_type("DECIMAL", 2, SCALE_FIX, 10, EC_DEC, "uchr"); */
	*t++ = sql_create_type("DECIMAL",  4, SCALE_FIX, 10, EC_DEC, "sht");
	*t++ = sql_create_type("DECIMAL",  9, SCALE_FIX, 10, EC_DEC, "int");
	*t++ = sql_create_type("DECIMAL", 19, SCALE_FIX, 10, EC_DEC, "lng");

	/* float(n) (n indicates precision of atleast n digits) */
	/* ie n <= 23 -> flt */
	/*    n <= 51 -> dbl */
	/*    n <= 62 -> long long dbl (with -ieee) (not supported) */
	/* this requires a type definition */

	floats = t;
	*t++ = sql_create_type("REAL", 24, SCALE_NOFIX, 2, EC_FLT, "flt");
	DBL = *t++ = sql_create_type("DOUBLE", 53, SCALE_NOFIX, 2, EC_FLT, "dbl");


	dates = t;
	MONINT = *t++ = sql_create_type("MONTH_INTERVAL", 32, 0, 2, EC_INTERVAL, "int");
	SECINT = *t++ = sql_create_type("SEC_INTERVAL", 64, 0, 2, EC_INTERVAL, "lng");
	TME = *t++ = sql_create_type("TIME", 0, 0, 0, EC_TIME, "daytime");
	TMETZ = *t++ = sql_create_type("TIMETZ", 0, SCALE_FIX, 0, EC_TIME, "daytime");
	DTE = *t++ = sql_create_type("DATE", 0, 0, 0, EC_DATE, "date");
	TMESTAMP = *t++ = sql_create_type("TIMESTAMP", 0, 0, 0, EC_TIMESTAMP, "timestamp");
	TMESTAMPTZ = *t++ = sql_create_type("TIMESTAMPTZ", 0, SCALE_FIX, 0, EC_TIMESTAMP, "timestamp");

	*t++ = sql_create_type("BLOB", 0, 0, 0, EC_BLOB, "sqlblob");
	end = t;
	*t = NULL;

	for (i = 0; ts[i]; i++) {
		sql_create_func("hash", "hash", ts[i], INT, INT, SCALE_FIX);
		sql_create_func("=", "=", ts[i], ts[i], BIT, SCALE_FIX);
		sql_create_func("<>", "!=", ts[i], ts[i], BIT, SCALE_FIX);
		sql_create_func("isnull", "isnil", ts[i], NULL, BIT, SCALE_FIX);
		sql_create_func(">", ">", ts[i], ts[i], BIT, SCALE_FIX);
		sql_create_func(">=", ">=", ts[i], ts[i], BIT, SCALE_FIX);
		sql_create_func("<", "<", ts[i], ts[i], BIT, SCALE_FIX);
		sql_create_func("<=", "<=", ts[i], ts[i], BIT, SCALE_FIX);
		sql_create_aggr("exist", "exist", ts[i], BIT);
		sql_create_aggr("not_exist", "not_exist", ts[i], BIT);
	}

	for (i = 0; ts[i]; i++) {
		sql_create_aggr("min", "min", ts[i], ts[i]);
		sql_create_aggr("max", "max", ts[i], ts[i]);
		sql_create_func("sql_min", "min", ts[i], ts[i], ts[i], SCALE_FIX);
		sql_create_func("sql_max", "max", ts[i], ts[i], ts[i], SCALE_FIX);
		sql_create_func3("ifthenelse", "ifthenelse", BIT, ts[i], ts[i], ts[i], SCALE_NONE);
	}

	for (t = numerical+1; t < decimals; t++) {
		sql_subtype *r = NULL;
		char buf[50];
		char *lt = local_result((*t)->base.name);

		snprintf(buf, 50, "sum_%s", lt);
		r = sql_bind_localtype(lt);
		sql_create_aggr("sum", buf, *t, r->type);
		sql_create_aggr("avg", "avg", *t, DBL);
	}
	for (t = numerical+1; t < floats; t += 3) {
		char nm1[50];
		char nm2[50];

		snprintf(nm1, 50, "sum_%s", (*(t + 1))->base.name);
		snprintf(nm2, 50, "sum_%s", (*(t + 2))->base.name);
		sql_create_aggr("sum", nm1, *(t), *(t + 1));
		sql_create_aggr("sum", nm2, *(t + 1), *(t + 2));
		sql_create_aggr("sum", nm2, *(t + 2), *(t + 2));
	}
	for (t = numerical+1; t < floats; t++) 
		sql_create_aggr("avg", "avg", *(t), DBL);

	for (t = floats; t < dates; t++) {
		sql_subtype *r = NULL;
		char buf[50];
		char *lt = local_result((*t)->base.name);

		snprintf(buf, 50, "sum_%s", lt);
		r = sql_bind_localtype(lt);
		sql_create_aggr("sum", buf, *t, r->type);
		sql_create_aggr("avg", "avg", *t, DBL);
	}

	sql_create_aggr("count_no_nil", "count_no_nil", NULL, INT);
	sql_create_aggr("count", "count", NULL, INT);

	for (t = misc; t < strings; t++) {
		sql_create_func("and", "and", *t, *t, *t, SCALE_FIX);
		sql_create_func("or", "or", *t, *t, *t, SCALE_FIX);
		sql_create_func("xor", "xor", *t, *t, *t, SCALE_FIX);
		sql_create_func("not", "not", *t, NULL, *t, SCALE_FIX);
	}

	/* all numericals */
	for (t = numerical; *t != TME; t++) {
		sql_subtype *lt = sql_bind_localtype((*t)->base.name);

		sql_create_func("sql_sub", "-", *t, *t, *t, SCALE_FIX);
		sql_create_func("sql_add", "+", *t, *t, *t, SCALE_FIX);
		sql_create_func("sql_mul", "*", *t, *t, *t, SCALE_ADD);
		sql_create_func("sql_div", "/", *t, *t, *t, SCALE_SUB);
		sql_create_func("mod", "%", *t, *t, *t, SCALE_FIX);
		sql_create_func("and", "and", *t, *t, *t, SCALE_FIX);
		sql_create_func("or", "or", *t, *t, *t, SCALE_FIX);
		sql_create_func("xor", "xor", *t, *t, *t, SCALE_FIX);
		sql_create_func("sql_neg", "-", *t, NULL, *t, INOUT);
		sql_create_func("sql_pos", "+", *t, NULL, *t, INOUT);
		sql_create_func("abs", "abs", *t, NULL, *t, SCALE_FIX);
		sql_create_func("sign", "sign", *t, NULL, *t, SCALE_FIX);
		sql_create_func("power", "pow", *t, INT, *t, SCALE_FIX);
		sql_create_func("degrees", "deg", *t, NULL, *t, SCALE_NONE);
		sql_create_func("radians", "rad", *t, NULL, *t, SCALE_NONE);
		/* scale fixing for all numbers */
		sql_create_func("scale_up", "*", *t, lt->type, *t, SCALE_NONE);
		sql_create_func("scale_down", "round", *t, lt->type, *t, SCALE_NONE);
		/* numeric function on INTERVALS */
		if (*t != MONINT && *t != SECINT){
			sql_create_func("sql_sub", "-", MONINT, *t, MONINT, SCALE_FIX);
			sql_create_func("sql_add", "+", MONINT, *t, MONINT, SCALE_FIX);
			sql_create_func("sql_mul", "*", MONINT, *t, MONINT, SCALE_ADD);
			sql_create_func("sql_div", "/", MONINT, *t, MONINT, SCALE_SUB);
			sql_create_func("sql_sub", "-", SECINT, *t, SECINT, SCALE_FIX);
			sql_create_func("sql_add", "+", SECINT, *t, SECINT, SCALE_FIX);
			sql_create_func("sql_mul", "*", SECINT, *t, SECINT, SCALE_ADD);
			sql_create_func("sql_div", "/", SECINT, *t, SECINT, SCALE_SUB);
		}
	}
	for (t = decimals, t++; t != floats; t++) {
		sql_type **u;
		for (u = numerical+1; u != floats; u++) {
			if ((*t)->localtype >  (*u)->localtype) {
				sql_create_func("sql_mul", "*", *t, *u, *t, SCALE_ADD);
				sql_create_func("sql_mul", "*", *u, *t, *t, SCALE_ADD);
			}
		}
	}

	for (t = decimals; t < dates; t++) {
		sql_create_func("truncate", "trunc", *t, INT, *t, SCALE_NONE);
		sql_create_func("round", "round", *t, INT, *t, SCALE_NONE);
	}
	sql_create_func("pi", "pi", NULL, NULL, *t, SCALE_NONE);

	for (t = numerical; t < end; t++) {
		sql_type **u;

		for (u = numerical; u < end; u++) 
			sql_create_func("scale_up", "*", *u, *t, *t, SCALE_NONE);
	}

	for (t = floats; t < dates; t++) {
		sql_create_func("floor", "floor", *t, NULL, *t, SCALE_FIX);
		sql_create_func("ceil", "ceil", *t, NULL, *t, SCALE_FIX);
		sql_create_func("ceiling", "ceil", *t, NULL, *t, SCALE_FIX);	/* JDBC */
		sql_create_func("sin", "sin", *t, NULL, *t, SCALE_FIX);
		sql_create_func("cos", "cos", *t, NULL, *t, SCALE_FIX);
		sql_create_func("tan", "tan", *t, NULL, *t, SCALE_FIX);
		sql_create_func("asin", "asin", *t, NULL, *t, SCALE_FIX);
		sql_create_func("acos", "acos", *t, NULL, *t, SCALE_FIX);
		sql_create_func("atan", "atan", *t, NULL, *t, SCALE_FIX);
		sql_create_func("atan", "atan2", *t, *t, *t, SCALE_FIX);
		sql_create_func("sinh", "sinh", *t, NULL, *t, SCALE_FIX);
		sql_create_func("cot", "cotan", *t, NULL, *t, SCALE_FIX);
		sql_create_func("cosh", "cosh", *t, NULL, *t, SCALE_FIX);
		sql_create_func("tanh", "tanh", *t, NULL, *t, SCALE_FIX);
		sql_create_func("sqrt", "sqrt", *t, NULL, *t, SCALE_FIX);
		sql_create_func("exp", "exp", *t, NULL, *t, SCALE_FIX);
		sql_create_func("log", "log", *t, NULL, *t, SCALE_FIX);
		sql_create_func("log10", "log10", *t, NULL, *t, SCALE_FIX);
	}

	/* Date functions */
	sql_create_func("curdate", "current_date", NULL, NULL, DTE, SCALE_NONE);
	sql_create_func("current_date", "current_date", NULL, NULL, DTE, SCALE_NONE);
	sql_create_func("curtime", "current_time", NULL, NULL, TMETZ, SCALE_NONE);
	sql_create_func("current_time", "current_time", NULL, NULL, TMETZ, SCALE_NONE);
	sql_create_func("current_timestamp", "current_timestamp", NULL, NULL, TMESTAMPTZ, SCALE_NONE);
	sql_create_func("localtime", "current_time", NULL, NULL, TME, SCALE_NONE);
	sql_create_func("localtimestamp", "current_timestamp", NULL, NULL, TMESTAMP, SCALE_NONE);

	sql_create_func("sql_sub", "date_sub_sec_interval", DTE, SECINT, DTE, SCALE_FIX);
	sql_create_func("sql_sub", "date_sub_month_interval", DTE, MONINT, DTE, SCALE_FIX);
	sql_create_func("sql_sub", "timestamp_sub_sec_interval", TMESTAMP, SECINT, TMESTAMP, SCALE_FIX);
	sql_create_func("sql_sub", "timestamp_sub_month_interval", TMESTAMP, MONINT, TMESTAMP, SCALE_FIX);
	sql_create_func("sql_sub", "time_sub_sec_interval", TME, SECINT, TME, SCALE_FIX);

	sql_create_func("sql_sub", "diff", DTE, DTE, INT, SCALE_FIX);
	sql_create_func("sql_sub", "diff", TMESTAMP, TMESTAMP, LNG, SCALE_FIX);

	sql_create_func("sql_add", "date_add_sec_interval", DTE, SECINT, DTE, SCALE_FIX);
	sql_create_func("sql_add", "addmonths", DTE, MONINT, DTE, SCALE_FIX);
	sql_create_func("sql_add", "timestamp_add_sec_interval", TMESTAMP, SECINT, TMESTAMP, SCALE_FIX);
	sql_create_func("sql_add", "addmonths", TMESTAMP, MONINT, TMESTAMP, SCALE_FIX);
	sql_create_func("sql_add", "time_add_sec_interval", TME, SECINT, TME, SCALE_FIX);
	sql_create_func("local_timezone", "local_timezone", NULL, NULL, SECINT, SCALE_FIX);

	sql_create_func("year", "year", DTE, NULL, INT, SCALE_FIX);
	sql_create_func("month", "month", DTE, NULL, INT, SCALE_FIX);
	sql_create_func("day", "day", DTE, NULL, INT, SCALE_FIX);
	sql_create_func("hour", "hours", TME, NULL, INT, SCALE_FIX);
	sql_create_func("minute", "minutes", TME, NULL, INT, SCALE_FIX);
	sql_create_func("second", "seconds", TME, NULL, INT, SCALE_FIX);

	sql_create_func("year", "year", TMESTAMP, NULL, INT, SCALE_FIX);
	sql_create_func("month", "month", TMESTAMP, NULL, INT, SCALE_FIX);
	sql_create_func("day", "day", TMESTAMP, NULL, INT, SCALE_FIX);
	sql_create_func("hour", "hours", TMESTAMP, NULL, INT, SCALE_FIX);
	sql_create_func("minute", "minutes", TMESTAMP, NULL, INT, SCALE_FIX);
	sql_create_func("second", "seconds", TMESTAMP, NULL, INT, SCALE_FIX);

	sql_create_func("year", "year", MONINT, NULL, INT, SCALE_FIX);
	sql_create_func("month", "month", MONINT, NULL, INT, SCALE_FIX);
	sql_create_func("day", "day", SECINT, NULL, INT, SCALE_FIX);
	sql_create_func("hour", "hours", SECINT, NULL, INT, SCALE_FIX);
	sql_create_func("minute", "minutes", SECINT, NULL, INT, SCALE_FIX);
	sql_create_func("second", "seconds", SECINT, NULL, INT, SCALE_FIX);

	sql_create_func("dayofyear", "dayofyear", DTE, NULL, INT, SCALE_FIX);
	sql_create_func("weekofyear", "weekofyear", DTE, NULL, INT, SCALE_FIX);
	sql_create_func("dayofweek", "dayofweek", DTE, NULL, INT, SCALE_FIX);
	sql_create_func("dayofmonth", "day", DTE, NULL, INT, SCALE_FIX);
	sql_create_func("week", "weekofyear", DTE, NULL, INT, SCALE_FIX);

	for (t = strings; t < numerical; t++) {
		sql_create_func("locate", "locate", *t, *t, INT, SCALE_NONE);
		sql_create_func3("locate", "locate", *t, *t, INT, INT, SCALE_NONE);
		sql_create_func("substring", "substring", *t, INT, *t, SCALE_NONE);
		sql_create_func3("substring", "substring", *t, INT, INT, *t, SCALE_NONE);
		sql_create_func("like", "like", *t, *t, BIT, SCALE_NONE);
		sql_create_func("truncate", "stringleft", *t, INT, *t, SCALE_NONE);
		sql_create_func("concat", "+", *t, *t, *t, DIGITS_ADD);
		sql_create_func("ascii", "ascii", *t, NULL, INT, SCALE_NONE);
		sql_create_func("code", "unicode", INT, NULL, *t, SCALE_NONE);
		sql_create_func("length", "stringlength", *t, NULL, INT, SCALE_NONE);
		sql_create_func("right", "stringright", *t, INT, *t, SCALE_NONE);
		sql_create_func("left", "stringleft", *t, INT, *t, SCALE_NONE);
		sql_create_func("upper", "toUpper", *t, NULL, *t, SCALE_NONE);
		sql_create_func("ucase", "toUpper", *t, NULL, *t, SCALE_NONE);
		sql_create_func("lower", "toLower", *t, NULL, *t, SCALE_NONE);
		sql_create_func("lcase", "toLower", *t, NULL, *t, SCALE_NONE);
		sql_create_func("trim", "trim", *t, NULL, *t, SCALE_NONE);
		sql_create_func("ltrim", "ltrim", *t, NULL, *t, SCALE_NONE);
		sql_create_func("rtrim", "rtrim", *t, NULL, *t, SCALE_NONE);

		sql_create_func4("insert", "stringinsert", *t, INT, INT, *t, *t, SCALE_NONE);
		sql_create_func3("replace", "stringreplace", *t, *t, *t, *t, SCALE_NONE);
		sql_create_func("repeat", "repeat", *t, INT, *t, SCALE_NONE);
		sql_create_func("space", "space", INT, NULL, *t, SCALE_NONE);
		sql_create_func("char_length", "length", *t, NULL, INT, SCALE_NONE);
		sql_create_func("character_length", "length", *t, NULL, INT, SCALE_NONE);

		sql_create_func("soundex", "soundex", *t, NULL, *t, SCALE_NONE);
		sql_create_func("difference", "stringdiff", *t, *t, INT, SCALE_NONE);
		sql_create_func("editdistance", "editdistance", *t, *t, INT, SCALE_FIX);
		sql_create_func("editdistance2", "editdistance2", *t, *t, INT, SCALE_FIX);

		sql_create_func("similarity", "similarity", *t, *t, DBL, SCALE_FIX);
		sql_create_func("qgramnormalize", "qgramnormalize", *t, NULL, *t, SCALE_NONE);

		sql_create_func("levenshtein", "levenshtein", *t, *t, INT, SCALE_FIX);
		{ sql_subtype sres;
		sql_init_subtype(&sres, *t, 0, 0);
		sql_create_func_("levenshtein", "levenshtein",
				 list_append(list_append (list_append (list_append(list_append(list_create((fdestroy) &arg_destroy), create_arg(NULL, sql_create_subtype(*t, 0, 0))), create_arg(NULL, sql_create_subtype(*t, 0, 0))), create_arg(NULL, sql_create_subtype(INT, 0, 0))), create_arg(NULL, sql_create_subtype(INT, 0, 0))), create_arg(NULL, sql_create_subtype(INT, 0, 0))), &sres);
		}
	}
}

void
types_exit()
{
#ifndef NDEBUG
	sql_end = END_SUBAGGR;
#endif

#ifndef NDEBUG
	sql_end = END_AGGR;
#endif

	list_destroy(aggrs);
	list_destroy(funcs);

	list_destroy(localtypes);

#ifndef NDEBUG
	sql_end = END_SUBTYPE;
#endif

#ifndef NDEBUG
	sql_end = END_TYPE;
#endif
	list_destroy(aliases);
	list_destroy(types);
}
