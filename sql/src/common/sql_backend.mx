@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2006 CWI.
@' All Rights Reserved.

@f sql_backend
@a N.J. Nes
@* 
The back end structure collects the information needed to support
compilation and execution of the SQL code against a back-end engine.
Note that any back-end can be called upon by the front-end
to handle specific tasks, such as catalog management (sql_mvc)
and query execution (sql_qc). For this purpose, the front-end needs
access to operations defined in the back-end, in particular for
freeing the stack and code segment.

The front-end should not rely on knowledge how the back end handles 
the actual query processing. Using the sample back ends Monet4 and Monet5
are used to find the common ground here. The structure currently is a
simple functional wrapper. It assumes that a single back-end is used
for the duration of a session.
@{
@h
#ifndef _SQL_BACKEND_H_
#define _SQL_BACKEND_H_

#include "sql_mem.h"
#include "sql_catalog.h"

typedef void (*freestack_fptr) (backend_stack stk);
typedef void (*freecode_fptr) (backend_code code, backend_stack stk, int nr, char *name);
typedef void (*interpret_fptr) (backend_stack stk, char *code);
typedef char *(*create_user_fptr) (list *l, char *user, char *passwd, char *fullname, int schema_id, int grantor_id);
typedef char *(*drop_user_fptr) (char *user);
typedef int  (*find_user_fptr) (ptr m, char *user);
typedef void (*create_privileges_fptr) (ptr mvc, sql_schema *s);
typedef int  (*schema_has_user_fptr) (ptr mvc, sql_schema *s);
typedef int  (*alter_user_fptr) (ptr mvc, str user, str passwd, oid schema_id);

/* backing struct for this interface */
typedef struct _backend_functions {
	freestack_fptr fstack;
	freecode_fptr fcode;
	interpret_fptr finterpret;
	create_user_fptr fcuser;
	drop_user_fptr fduser;
	find_user_fptr ffuser;
	create_privileges_fptr fcrpriv;
	schema_has_user_fptr fshuser;
	alter_user_fptr fauser;
} backend_functions;

extern void backend_init(backend_functions *funcs);
extern void backend_freestack(backend_stack stk);
extern void backend_freecode(backend_code code, backend_stack stk, int nr, char *name);
extern void backend_interpret(backend_stack stk, char *code);
extern char *backend_create_user(list *l, char *user, char *passwd, char *fullname, int defschemid, int grantor);
extern char *backend_drop_user(char *user);
extern int  backend_find_user(ptr mp, char *user);
extern void backend_create_privileges(ptr mvc, sql_schema *s);
extern int  backend_schema_has_user(ptr mvc, sql_schema *s);
extern int	backend_alter_user(ptr mvc, str user, str passwd, oid schema_id);

#endif /* _SQL_BACKEND_H_ */
@c

#include "sql_backend.h"

static backend_functions *be_funcs = NULL;

void
backend_init(backend_functions *funcs)
{
	/* copy over, assume the caller doesn't modify the struct and that
	 * it is alloced appropriately */
	be_funcs = funcs;
}

void
backend_freestack(backend_stack stk)
{
	assert(be_funcs != NULL);
	if (be_funcs->fstack != NULL)
		be_funcs->fstack(stk);
}

void
backend_freecode(backend_code code, backend_stack stk, int nr, char *name)
{
	assert(be_funcs != NULL);
	if (be_funcs->fcode != NULL)
		be_funcs->fcode(code, stk, nr, name);
}

void
backend_interpret(backend_stack stk, char *code)
{
	assert(be_funcs != NULL);
	if (be_funcs->finterpret != NULL)
		be_funcs->finterpret(stk, code);
}

char *
backend_create_user(list *l, char *user, char *passwd, char *fullname, int defschemid, int grantor)
{
	assert(be_funcs != NULL);
	if (be_funcs->fcuser != NULL)
		return(be_funcs->fcuser(l, user, passwd, fullname, defschemid, grantor));
	return(NULL);
}

char *
backend_drop_user(char *user)
{
	assert(be_funcs != NULL);
	if (be_funcs->fduser != NULL)
		return(be_funcs->fduser(user));
	return(NULL);
}

int
backend_find_user(ptr m, char *user)
{
	assert(be_funcs != NULL);
	if (be_funcs->ffuser != NULL)
		return(be_funcs->ffuser(m, user));
	return(0);
}

void
backend_create_privileges(ptr mvc, sql_schema *s)
{
	assert(be_funcs != NULL);
	if (be_funcs->fcrpriv != NULL)
		be_funcs->fcrpriv(mvc, s);
}

int
backend_schema_has_user(ptr mvc, sql_schema *s)
{
	assert(be_funcs != NULL);
	if (be_funcs->fshuser != NULL)
		return(be_funcs->fshuser(mvc, s));
	return(FALSE);
}

int
backend_alter_user(ptr mvc, str user, str passwd, oid schema_id)
{
	assert(be_funcs != NULL);
	if (be_funcs->fauser != NULL)
		return(be_funcs->fauser(mvc, user, passwd, schema_id));
	return(FALSE);
}
@}
