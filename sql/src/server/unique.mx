@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2005 CWI.
@' All Rights Reserved.

@f unique
@a Niels Nes
@* Unique Keys

@+
The unique module adds commands to improve MonetDB's ability to check Unique keys.
Currently keys could be checked using the CTgroup/CTderive commands from the
xtables module. CTs suffer from bad performance as they assume the
result contains only a small number of groups, whereas unique keys should 
contain as many groups as values.

The unique module is optimized for clustered data, a common case for keys.
Special cases are, array index (cluster with repeats), 
	and clustered with exceptions. The array index can be stored
efficient by just remembering the array index function which is a combination
of a simple two dimensional array index, and some multiplication and addition
with constant values. A cluster with exceptions can be handled using a
cluster hash, which basically is a bat with the cluster values in the head
and offsets in the tail, where cluster values may repeat!.

/* also move hash_left and xor in here */
@m
.MODULE unique;

.COMMAND CTunique( BAT[void,any] attr) : BAT[void,oid] = CTunique;
	"Group the attr with the assumption that the values are part of a probably unique key" 

.COMMAND CTunique( BAT[void,oid] ct, BAT[void,any] attr) : BAT[void,oid] = CTunique2;
	"Regroup ct using attr with the assumption that the values are part of a probably unique key" 
@m
.END unique;
@c

#include "unique.proto.h"

#define UK_SAMPLE 1024

/* TODO 
	create ACC clusterhash (simply destroyed on inserts)
	add the clusterhash to input (only in CTunique(attr)) and to
	result
	
	Implement efficient histogram over clusterhash (sum the lengths).
	implement the other aggr operations efficiently !
	Forward rules on map implementations

	Fallback to xtables in case of small groups, ie. use the type info
	and if possible cardinality info.
*/


/* assumptions forall but the COMMANDs,
	ct.count == attr.count > 0, ct.ht == attr.ht == TYPE_void 

   todo improve test BATvoid, wrong code is now used for VIEWs where TYPE_void
   but real data used is still not an array 

one day we will have split head and tail, makeing the attr.ht == TYPE_void
not needed any more 
*/

BAT *
CTunique_(BAT *attr, int est)
{
	BUN p, q;
	size_t cnt = BATcount(attr);
	BAT *res = BATnew(TYPE_void, TYPE_oid, cnt);
	BAT *map = BATnew(attr->ttype, TYPE_oid, cnt);
	oid *ro = (oid *) BUNtail(res, BUNfirst(res));

	BAThash(map, &est);
	BATloop(attr, p, q) {
		BUN r;
		oid h;
		ptr v = BUNtail(attr, p);

		if ((r = BUNfnd(map, v)) == NULL) {
			h = *(oid *) BUNhead(attr, p);
			BUNins(map, v, &h);
		} else {
			h = *(oid *) BUNtail(map, r);
		}
		*ro++ = h;
	}
	res->batBuns->free = ((BUN) ro) - res->batBuns->base;
	res->tsorted = 0;
	ALIGNsetH(res, attr);
	BBPunfix(map->batCacheid);
	return res;
}

BAT *
CTunique_simple(BAT *attr)
{
	if (BATcount(attr) < UK_SAMPLE) {
		return CTunique_(attr, BATcount(attr));
	} else {
		BAT *s = CTunique_(BATsample(attr, UK_SAMPLE), UK_SAMPLE);
		int rs = BATcount(s) * (BATcount(attr) / UK_SAMPLE);

		rs = MAX(rs, BATcount(attr));
		return CTunique_(attr, rs);
	}
}

@= CTunique_ordered
oid
CTunique_ordered_@1(BAT *res, BAT *attr, oid start)
{
	size_t cnt = BATcount(attr);
	oid *ro = (oid*)BUNtail(res,BUNfirst(res));
	oid ao = attr->hseqbase, co;
	@1  *av = (@1*)BUNtail(attr,BUNfirst(attr)), *ae = av + cnt, cv;
	
	ro += start;
	ao += start;
	av += start;

	co = ao;
	cv = *av;
	while (av < ae) {
		if (*av != cv) {
			if (*av < cv)
				break;
			co = ao;
			cv = *av;
		}
		*ro++ = co;
		av++;
		ao++;
	}
	return ao - attr->hseqbase;
}
@c
@:CTunique_ordered(chr)@
@:CTunique_ordered(sht)@
@:CTunique_ordered(int)@
@:CTunique_ordered(lng)@
@:CTunique_ordered(flt)@
@:CTunique_ordered(dbl)@

@c
oid
CTunique_ordered_fast(BAT *res, BAT *attr, oid start)
{
	int tpe = ATOMstorage(attr->ttype);	/* standard type remappings */

	switch (tpe) {
	case TYPE_chr:
		return CTunique_ordered_chr(res, attr, start);
	case TYPE_sht:
		return CTunique_ordered_sht(res, attr, start);
	case TYPE_int:
		return CTunique_ordered_int(res, attr, start);
	case TYPE_lng:
		return CTunique_ordered_lng(res, attr, start);
	case TYPE_flt:
		return CTunique_ordered_flt(res, attr, start);
	case TYPE_dbl:
		return CTunique_ordered_dbl(res, attr, start);
	}
	return 0;
}

BAT *
CTunique_ordered(BAT *attr)
{
	int tpe = ATOMstorage(attr->ttype);	/* standard type remappings */

	if (tpe >= TYPE_str) {
		return CTunique_simple(attr);
	} else {
		size_t cnt = BATcount(attr);
		BAT *res = BATnew(TYPE_void, TYPE_oid, cnt);
		oid start = 0, end = CTunique_ordered_fast(res, attr, start);
		BUN r = BUNptr(res, BUNindex(res, BUNfirst(res)) + end);

		res->batBuns->free = r - res->batBuns->base;
		res->tsorted = attr->tsorted;
		ALIGNsetH(res, attr);
		BATprint(attr);
		BATprint(res);
		return res;
	}
}

BAT *
CTunique_partial_ordered(BAT *attr)
{
	size_t cnt = BATcount(attr), partial = 0;
	oid start = 0, end = cnt;
	BAT *res = BATnew(TYPE_void, TYPE_oid, cnt);
	BUN r;

	while (start < end) {
		oid n = CTunique_ordered_fast(res, attr, start);

		if (n < end) {
			if (n < (start + 1024)) {
				BBPunfix(res->batCacheid);
				/*return CTunique_simple(attr); */
				res = NULL;
				CTgroup(&res, attr);
				return res;
			} else {
				partial = 1;

				BBPunfix(res->batCacheid);
				res = NULL;
				CTgroup(&res, attr);
				return res;
			}
		}
		start = n;
	}
	/* todo write partial merge */
	r = BUNptr(res, BUNindex(res, BUNfirst(res)) + end);
	res->batBuns->free = r - res->batBuns->base;
	if (partial)
		res->tsorted = attr->tsorted;
	else
		res->tsorted = 1;
	ALIGNsetH(res, attr);
	return res;
}

/* always assume partial sorted!
   fallback to non sorted, ie hash solution only if parts are to small
   ie less than XXX per part.
 */

int
CTunique(BAT **res, BAT *attr)
{
	if (BATcount(attr) == 0) {
		*res = BATnew(TYPE_void, TYPE_oid, 0);
		BATseqbase(*res, attr->hseqbase);
	} else if (attr->tsorted & 1) {
		*res = CTunique_ordered(attr);
	} else {
		*res = CTunique_partial_ordered(attr);
		BATprint(attr);
		BATprint(res);
	}
	return GDK_SUCCEED;
}

@= CTunique2_ordered
BAT *
CTunique2_ordered_@1(BAT *res, BAT *ct, BAT *attr)
{
	size_t cnt = BATcount(ct);
	oid co = ct->hseqbase;
	oid *ci = (oid*)BUNtail(ct, BUNfirst(ct)), *eci = ci + cnt, cid;
	@1 *ca = (@1*)BUNtail(attr, BUNfirst(attr)), v = *ca;
	oid *o = (oid*)BUNtail(res, BUNfirst(res)), gid;
	
	for( cid = *ci, gid = co; ci < eci; ci++, ca++, co++, *o++) {
		if (*ci != cid || *ca != v ) {
			gid = co; 
			if (*ci != cid) {
				cid = *ci;
				if (*ca != v)
					v = *ca;
			} else {
				if (*ca < v){
					/* attr not 'partial' sorted, fallback
					   to cluster_hash based */
					BBPunfix(res->batCacheid);
					res = NULL;
					CTderive(&res, ct, attr );
					return res;
				}
				if (*ca != v)
					v = *ca;
			}
		}
		*o = gid;
	}
	res->batBuns->free = ((BUN)o) - res->batBuns->base; 
	res->tsorted = 1;
	ALIGNsetH(res,attr);
	return res;
}

@c
@:CTunique2_ordered(chr)@
@:CTunique2_ordered(sht)@
@:CTunique2_ordered(int)@
@:CTunique2_ordered(lng)@
@:CTunique2_ordered(flt)@
@:CTunique2_ordered(dbl)@

@c
BAT *
CTunique2_ordered(BAT *res, BAT *ct, BAT *attr)
{
	int tpe = ATOMstorage(attr->ttype);	/* standard type remappings */

	switch (tpe) {
	case TYPE_chr:
		return CTunique2_ordered_chr(res, ct, attr);
	case TYPE_sht:
		return CTunique2_ordered_sht(res, ct, attr);
	case TYPE_int:
		return CTunique2_ordered_int(res, ct, attr);
	case TYPE_lng:
		return CTunique2_ordered_lng(res, ct, attr);
	case TYPE_flt:
		return CTunique2_ordered_flt(res, ct, attr);
	case TYPE_dbl:
		return CTunique2_ordered_dbl(res, ct, attr);
	}
	return NULL;
}


int
CTunique2(BAT **res, BAT *ct, BAT *attr)
{
	size_t cnt = BATcount(ct);
	int tpe = ATOMstorage(attr->ttype);	/* standard type remappings */

	if (cnt == 0) {
		*res = BATnew(TYPE_void, TYPE_oid, 0);
		BATseqbase(*res, ct->hseqbase);
	} else if (tpe < TYPE_str && ct->tsorted & 1) {
		*res = BATnew(TYPE_void, TYPE_oid, cnt);
		/* clustered */
		*res = CTunique2_ordered(*res, ct, attr);
		BATseqbase(*res, ct->hseqbase);
	} else {
		return CTderive(res, ct, attr);
	}
	return GDK_SUCCEED;
}

@mil

