@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
@' Copyright August 2008-2009 MonetDB B.V.
@' All Rights Reserved.

@f rel_exp
@a N.J. Nes
@* 

@h
#ifndef _REL_EXP_H_
#define _REL_EXP_H_

#define new_exp_list() list_create((fdestroy)&exp_destroy)

extern sql_exp *exp_dup(sql_exp* e);
extern void exp_destroy(sql_exp* e);

extern sql_exp *exp_compare( sql_exp *l, sql_exp *r, int cmptype);
extern sql_exp *exp_compare2( sql_exp *l, sql_exp *r, sql_exp *h, int cmptype);
extern sql_exp *exp_or( list *l, list *r);

#define exp_fromtype(e)	((list*)e->r)->h->data
#define exp_totype(e)	((list*)e->r)->h->next->data
extern sql_exp *exp_convert( sql_exp *exp, sql_subtype *fromtype, sql_subtype *totype );
extern str number2name(str s, int len, int i);
extern sql_exp *exp_op( list *l, sql_subfunc *f );

#define append(l,v) list_append(l,v) 
#define exp_unop(l,f) \
	exp_op(append(new_exp_list(),l), f)
#define exp_binop(l,r,f) \
	exp_op(append(append(new_exp_list(),l),r), f)
#define exp_op3(l,r,r2,f) \
	exp_op(append(append(append(new_exp_list(),l),r),r2), f)
#define exp_op4(l,r,r2,r3,f) \
	exp_op(append(append(append(append(new_exp_list(),l),r),r2),r3), f)
extern sql_exp *exp_aggr( list *l, sql_subaggr *a, int distinct, int no_nils, int card, int has_nil );
#define exp_aggr1(e, a, d, n, c, hn) \
	exp_aggr(append(new_exp_list(), e), a, d, n, c, hn)
extern sql_exp * exp_atom( atom *a);
extern sql_exp * exp_atom_bool(int b); 
extern sql_exp * exp_atom_int(int i);
extern sql_exp * exp_atom_wrd(wrd w);
extern sql_exp * exp_atom_str(str s, sql_subtype *st);
extern sql_exp * exp_atom_clob(str s);
extern sql_exp * exp_atom_ref(int i, sql_subtype *tpe);
extern sql_exp * exp_param(char *name, sql_subtype *tpe, int frame);
extern sql_exp * exp_column( char *rname, char *name, sql_subtype *t, int card, int has_nils, int intern);
extern sql_exp * exp_alias( char *arname, char *acname, char *org_rname, char *org_cname, sql_subtype *t, int card, int has_nils, int intern);
extern void exp_setname( sql_exp *e, char *rname, char *name );
extern sql_exp* exp_label( sql_exp *e, int nr);

extern void exp_swap( sql_exp *e );

extern sql_subtype * exp_subtype( sql_exp *e );
extern char * exp_name( sql_exp *e );

extern char *exp_find_rel_name(sql_exp *e);

extern sql_exp *rel_find_exp( sql_rel *rel, sql_exp *e);

extern int exp_cmp( sql_exp *e1, sql_exp *e2);
extern int exp_match( sql_exp *e1, sql_exp *e2);
extern int exp_match_exp( sql_exp *e1, sql_exp *e2);
extern int exp_is_join(sql_exp *e);
extern int exp_is_eqjoin(sql_exp *e);
extern int exp_is_correlation(sql_exp *e, sql_rel *r );
extern int exp_is_atom(sql_exp *e);

extern sql_exp *exps_bind_column( list *exps, char *cname);
extern sql_exp *exps_bind_column2( list *exps, char *rname, char *cname);

extern int exps_card( list *l );
extern void exps_fix_card( list *exps, int card);
extern int exps_intern(list *exps);

extern char *compare_func( comp_type t );

#endif /* _REL_EXP_H_ */
@c
#include <sql_config.h>
#include "sql_semantic.h"
#include "rel_semantic.h"
#include "rel_exp.h"

static sql_exp * 
exp_create( int type ) 
{
	sql_exp *e = NEW(sql_exp);
	sql_ref_init(&e->ref);
	e->name = NULL;
	e->rname = NULL;
	e->card = 0;
	e->flag = 0;
	e->l = e->r = NULL;
	e->type = (expression_type)type;
	e->f = NULL;
	e->p = NULL;
	e->used = 0;
	return e;
}

sql_exp *
exp_dup(sql_exp *exp)
{
	sql_ref_inc(&exp->ref);
	return exp;
}

void 
exp_destroy(sql_exp *exp)
{
	if (!exp) 
		return;
	if (sql_ref_dec(&exp->ref) > 0)
		return;
	if (exp->name) 
		_DELETE(exp->name);
	if (exp->rname) 
		_DELETE(exp->rname);
	switch(exp->type){
	case e_atom:
		if (exp->l) 
			atom_destroy(exp->l);
		if (exp->r) 
			_DELETE(exp->r);
		break;
	case e_column:
		if (exp->l)
			_DELETE(exp->l);
		_DELETE(exp->r);
		break;
	case e_cmp:
		if (exp->flag == cmp_or) {
			list_destroy(exp->l);
			list_destroy(exp->r);
		} else {
			exp_destroy(exp->l);
			exp_destroy(exp->r);
			if (exp->f)
				exp_destroy(exp->f);
		}
		break;
	case e_convert:
		exp_destroy(exp->l);
		list_destroy(exp->r);
		break;
	case e_aggr:
		sql_subaggr_destroy(exp->f);
		if (exp->l) list_destroy(exp->l);
		break;
	case e_func:
		if (exp->f) sql_subfunc_destroy(exp->f);
		if (exp->l) list_destroy(exp->l);
		break;
	default:
		printf("TODO: exp_destroy %u\n", exp->type);
	}
	_DELETE(exp);
}

sql_exp * 
exp_compare( sql_exp *l, sql_exp *r, int cmptype) 
{
	sql_exp *e = exp_create(e_cmp);
	e->card = l->card;
	e->l = l;
	e->r = r;
	e->flag = cmptype;
	return e;
}

sql_exp * 
exp_compare2( sql_exp *l, sql_exp *r, sql_exp *h, int cmptype) 
{
	sql_exp *e = exp_create(e_cmp);
	e->card = l->card;
	e->l = l;
	e->r = r;
	if (h)
		e->f = h;
	e->flag = cmptype;
	return e;
}

sql_exp *
exp_or( list *l, list *r)
{
	sql_exp *e1 = l->h->data;
	sql_exp *e = exp_create(e_cmp);
	e->card = e1->card;
	e->l = l;
	e->r = r;
	e->f = e1->f;
	e->flag = cmp_or;
	return e;
}

static sql_subtype*
dup_subtype(sql_subtype *st)
{
	sql_subtype *res = NEW(sql_subtype);

	*res = *st;
	return res;
}

#define new_subtype_list() list_create((fdestroy)&sql_subtype_destroy)

sql_exp * 
exp_convert( sql_exp *exp, sql_subtype *fromtype, sql_subtype *totype )
{
	sql_exp *e = exp_create(e_convert);
	e->card = exp->card;
	e->l = exp;
	totype = dup_subtype(totype);
	e->r = append(append(new_subtype_list(),
			dup_subtype(fromtype)),totype);
	e->f = totype; /* keep a pointer to the copied type, the original may
			  disappear */
	return e;
}

sql_exp * 
exp_op( list *l, sql_subfunc *f )
{
	sql_exp *e = exp_create(e_func);
	e->card = exps_card(l);
	if (!l || list_length(l) == 0)
		e->card = CARD_ATOM; /* unop returns a single atom */
	e->l = l;
	e->f = f; 
	return e;
}

sql_exp * 
exp_aggr( list *l, sql_subaggr *a, int distinct, int no_nils, int card, int has_nils )
{
	sql_exp *e = exp_create(e_aggr);
	e->card = card;
	e->l = l;
	e->f = a; 
	if (distinct)
		set_distinct(e);
	if (no_nils)
		set_no_nil(e);
	if (!has_nils)
		set_has_no_nil(e);
	return e;
}

sql_exp * exp_atom( atom *a) 
{
	sql_exp *e = exp_create(e_atom);
	e->card = CARD_ATOM;
	e->l = a;
	return e;
}

sql_exp *
exp_atom_bool(int b) 
{
	sql_subtype bt; 

	sql_find_subtype(&bt, "boolean", 0, 0);
	if (b) 
		return exp_atom(atom_bool(&bt, TRUE ));
	else
		return exp_atom(atom_bool(&bt, FALSE ));
}

sql_exp *
exp_atom_int(int i) 
{
	sql_subtype it; 

	sql_find_subtype(&it, "int", 9, 0);
	return exp_atom(atom_int(&it, i ));
}

sql_exp *
exp_atom_wrd(wrd w) 
{
	sql_subtype it; 

	sql_find_subtype(&it, "wrd", 19, 0);
	return exp_atom(atom_int(&it, (int)w ));
}

sql_exp *
exp_atom_str(str s, sql_subtype *st) 
{
	return exp_atom(atom_string(st, _strdup(s), 1 ));
}

sql_exp *
exp_atom_clob(str s) 
{
	sql_subtype clob;

	sql_find_subtype(&clob, "clob", 0, 0);
	return exp_atom(atom_string(&clob, _strdup(s), 1 ));
}

sql_exp * 
exp_atom_ref(int i, sql_subtype *tpe) 
{
	sql_exp *e = exp_create(e_atom);
	e->card = CARD_ATOM;
	e->flag = i;
	e->f = tpe;
	return e;
}

sql_exp * 
exp_param(char *name, sql_subtype *tpe, int frame) 
{
	sql_exp *e = exp_create(e_atom);
	e->r = _strdup(name);
	e->card = CARD_ATOM;
	e->f = tpe;
	e->flag = frame;
	return e;
}

sql_exp * 
exp_alias( char *arname, char *acname, char *org_rname, char *org_cname, sql_subtype *t, int card, int has_nils, int intern) 
{
	sql_exp *e = exp_create(e_column);

	assert(acname && org_rname && org_cname);
	e->card = card;
	e->rname = (arname)?_strdup(arname):_strdup(org_rname);
	e->name = _strdup(acname);
	e->l = _strdup(org_rname);
	e->r = _strdup(org_cname);
	e->f = t;
	if (!has_nils)
		set_has_no_nil(e);
	if (intern)
		set_intern(e);
	return e;
}

sql_exp * 
exp_column( char *rname, char *cname, sql_subtype *t, int card, int has_nils, int intern) 
{
	sql_exp *e = exp_create(e_column);

	assert(cname);
	e->card = card;
	e->name = _strdup(cname);
	e->l = (rname)?_strdup(rname):NULL;
	e->r = _strdup(cname);
	e->f = t;
	if (!has_nils)
		set_has_no_nil(e);
	if (intern)
		set_intern(e);
	return e;
}

/* Set a name (alias) for the expression, such that we can refer 
   to this expression by this simple name.
 */
void 
exp_setname( sql_exp *e, char *rname, char *name )
{
	if (name) {
		if (e->name)
			_DELETE(e->name);
		e->name = _strdup(name);
	}
	if (e->rname)
		_DELETE(e->rname);
	e->rname = (rname)?_strdup(rname):NULL;
}

str
number2name(str s, int len, int i)
{
	s[--len] = 0;
	while(i>0) {
		s[--len] = '0' + (i & 7);
		i >>= 3;
	}
	s[--len] = 'L';
	return s + len;
}

sql_exp*
exp_label( sql_exp *e, int nr)
{
	char name[16], *nme;

	nme = number2name(name, 16, nr);
	assert(e->name == NULL);
	e->name = _strdup(nme);
	return e;
}

void
exp_swap( sql_exp *e ) 
{
	sql_exp *s = e->l;

	e->l = e->r;
	e->r = s;
	e->flag = swap_compare((comp_type)e->flag);
}

sql_subtype *
exp_subtype( sql_exp *e )
{
	switch(e->type) {
	case e_atom: {
		if (e->l) {
			atom *a = e->l;
			return atom_type(a);
		} else { /* atom reference */
			return e->f;
		}
	}
	case e_convert:
	case e_column:
		return e->f;
	case e_aggr: {
		sql_subaggr *a = e->f;
		return &a->res;
	}
	case e_func: {
		if (e->f) {
			sql_subfunc *f = e->f;
			return &f->res;
		}
		return NULL;
	}
	case e_cmp:
		/* return bit */
	default:
		return NULL;
	}
}

char *
exp_name( sql_exp *e )
{
	if (e->name)
		return e->name;
	if (e->type == e_convert && e->l)
		return exp_name(e->l);
	return NULL;
}

char *
exp_find_rel_name(sql_exp *e)
{
	switch(e->type) {
	case e_column:
		if (e->l)
			return e->l;
		break;
	case e_convert:
		return exp_find_rel_name(e->l);
	default:
		return NULL;
	}
	return NULL;
}

int 
exp_cmp( sql_exp *e1, sql_exp *e2)
{
	return (e1 == e2)?0:-1;
}

int 
exp_match( sql_exp *e1, sql_exp *e2)
{
	if (exp_cmp(e1, e2) == 0)
		return 1;
	if (e1->type == e2->type && e1->type == e_column) {
		if (!e1->name || !e2->name || strcmp(e1->name, e2->name) != 0)
			return 0;
		if (!e1->l || !e2->l || strcmp(e1->l, e2->l) != 0)
			return 0;
		/* e1->r */
		return 1;
	}
	return 0;
}

int 
exp_match_exp( sql_exp *e1, sql_exp *e2)
{
	if (exp_match(e1, e2))
		return 1;
	if (e1->type == e2->type && e1->type == e_cmp && 
	    e1->flag == e2->flag && e1->flag != cmp_or) {
		if (exp_match(e1->l, e2->l) && exp_match(e1->r, e2->r))
			return 1;
	}
	return 0;
}

int
exp_is_join(sql_exp *e)
{
	if (e->type == e_cmp && e->l && e->r)
		return 0;
	return -1;
}

int
exp_is_eqjoin(sql_exp *e)
{
	if (e->flag == cmp_equal)
		return 0;
	return -1; 
}

static sql_exp *
rel_find_exp_( sql_rel *rel, sql_exp *e) 
{
	sql_exp *ne = NULL;

	switch(e->type) {
	case e_column:
		if (e->l) { 
			ne = exps_bind_column2(rel->exps, e->l, e->r);
		} else {
			ne = exps_bind_column(rel->exps, e->r);
		}
		return ne;
	case e_convert:
		return rel_find_exp_(rel, e->l);
	case e_aggr:
	case e_func: 
		if (e->l) {
			list *l = e->l;
			node *n = l->h;
	
			while (ne == NULL && n != NULL) {
				ne = rel_find_exp_(rel, n->data);
				n = n->next;
			}
			return ne;
		}
	case e_cmp:	
		return NULL;
	case e_atom:
		return ne;
	}
	return ne;
}

sql_exp *
rel_find_exp( sql_rel *rel, sql_exp *e)
{
	sql_exp *ne = rel_find_exp_(rel, e);
	if (!ne) {
		switch(rel->op) {
		case op_left:
		case op_right:
		case op_full:
		case op_join:
			ne = rel_find_exp(rel->l, e);
			if (!ne) 
				ne = rel_find_exp(rel->r, e);
			break;
		case op_table:
			if (rel->exps && e->type == e_column && e->l && exps_bind_column2(rel->exps, e->l, e->r)) 
				ne = e;
			break;
		case op_union:
		case op_except:
		case op_inter:
		{
			if (rel->l)
				ne = rel_find_exp(rel->l, e);
			else if (rel->exps && e->l)
				ne = exps_bind_column2(rel->exps, e->l, e->r);
			else if (rel->exps)
				ne = exps_bind_column(rel->exps, e->r);
		}
		break;
		case op_basetable: 
			if (rel->exps && e->type == e_column && e->l) 
				ne = exps_bind_column2(rel->exps, e->l, e->r);
			break;
		default:
			if (!is_project(rel->op) && rel->l)
				ne = rel_find_exp(rel->l, e);
		}
	}
	return ne;
}

int 
exp_is_correlation(sql_exp *e, sql_rel *r )
{
	if (e->type == e_cmp) {
		sql_exp *le = rel_find_exp(r->l, e->l);
		sql_exp *re = rel_find_exp(r->r, e->r);

		if (le && re)
			return 0;
		le = rel_find_exp(r->r, e->l);
		re = rel_find_exp(r->l, e->r);
		if (le && re) {
			/* for future processing we depend on 
			   the correct order of the expression, ie swap here */
			exp_swap(e);
			return 0;
		}
	}
	return -1;
}

int
exp_is_atom( sql_exp *e )
{
	switch (e->type) {
	case e_atom:
		return 1;
	case e_convert:
		return exp_is_atom(e->l);
	case e_func:
	case e_aggr:
	{	
		int r = 1;
		node *n;
		list *l = e->l;

		if (l)
			for (n = l->h; n; n = n->next) 
				r &= exp_is_atom(n->data);
		return r;
	}
	case e_column:
	case e_cmp:
		return 0;
	}
	return 0;
}

sql_exp *
exps_bind_column( list *exps, char *cname ) 
{
	if (exps && cname) {
		node *en;

		for (en = exps->h; en; en = en->next ) {
			sql_exp *e = en->data;
			if (e->name && strcmp(e->name, cname) == 0)
				return e;
		}
	}
	return NULL;
}

sql_exp *
exps_bind_column2( list *exps, char *rname, char *cname ) 
{
	if (exps) {
		node *en;

		for (en = exps->h; en; en = en->next ) {
			sql_exp *e = en->data;
		
			if (e && is_column(e->type) && e->name && e->rname && strcmp(e->name, cname) == 0 && strcmp(e->rname, rname) == 0)
				return e;
			if (e && e->type == e_column && e->name && !e->rname && e->l && strcmp(e->name, cname) == 0 && strcmp(e->l, rname) == 0)
				return e;
			if (e && e->type == e_column && !e->name && !e->rname && e->l && e->r && strcmp(e->r, cname) == 0 && strcmp(e->l, rname) == 0)
				return e;
		}
	}
	return NULL;
}

int
exps_card( list *l ) 
{
	node *n;
	int card = 0;

	if (l) for(n = l->h; n; n = n->next) {
		sql_exp *e = n->data;

		if (card < e->card)
			card = e->card;
	}
	return card;
}
	
void
exps_fix_card( list *exps, int card)
{
	node *n;

	for (n = exps->h; n; n = n->next) {
		sql_exp *e = n->data;

		if (e->card > card)
			e->card = card;
	}
}

int
exps_intern(list *exps)
{
	node *n;
			
	for (n=exps->h; n; n = n->next) {
		sql_exp *e = n->data;		

		if (is_intern(e))
			return 1;
	}
	return 0;
}

char *
compare_func( comp_type t )
{
	switch(t) {
	case cmp_equal:
		return "=";
	case cmp_lt:
		return "<";
	case cmp_lte:
		return "<=";
	case cmp_gte:
		return ">=";
	case cmp_gt:
		return ">";
	case cmp_notequal:
		return "<>";
	default:
		return NULL;
	}
}

