@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
@' Copyright August 2008-2009 MonetDB B.V.
@' All Rights Reserved.

@f rel_semantic
@a N.J. Nes
@* 

@h
#ifndef _REL_SEMANTIC_H_
#define _REL_SEMANTIC_H_

#include <sql_list.h>
#include "sql_symbol.h"
#include "sql_parser.h"
#include "sql_relation.h"
#include <stdarg.h>

extern sql_rel *rel_semantic(mvc *sql, symbol *sym);
extern sql_rel *rel_parse(mvc *m, char *query, char emode);

extern comp_type swap_compare( comp_type t );
extern comp_type range2lcompare( int r );
extern comp_type range2rcompare( int r );
extern int compare2range( int l, int r );

#endif /*_REL_SEMANTIC_H_*/

@c

#include "sql_config.h"
#include "sql_parser.h"
#include "sql_symbol.h"
#include "rel_semantic.h"
#include "rel_select.h"
#include "rel_updates.h"
#include "rel_exp.h"

#include <unistd.h>
#include <stdio.h>
#include <string.h>
#include <ctype.h>

comp_type 
swap_compare( comp_type t )
{
	switch(t) {
	case cmp_equal:
		return cmp_equal;
	case cmp_lt:
		return cmp_gt;
	case cmp_lte:
		return cmp_gte;
	case cmp_gte:
		return cmp_lte;
	case cmp_gt:
		return cmp_lt;
	case cmp_notequal:
		return cmp_notequal;
	default:
		return cmp_equal;
	}
}

comp_type 
range2lcompare( int r )
{
	if (r&1) {
		return cmp_gte;
	} else {
		return cmp_gt;
	}
}

comp_type 
range2rcompare( int r )
{
	if (r&2) {
		return cmp_lte;
	} else {
		return cmp_lt;
	}
}

int 
compare2range( int l, int r )
{
	if (l == cmp_gt) {
		if (r == cmp_lt)
			return 0;
		else if (r == cmp_lte)
			return 2;
	} else if (l == cmp_gte) {
		if (r == cmp_lt)
			return 1;
		else if (r == cmp_lte)
			return 3;
	} 
	return -1;
}


sql_rel *
rel_parse(mvc *m, char *query, char emode)
{
	mvc o = *m;
	sql_rel *rel;
	buffer *b;
	char *n;
	int len = _strlen(query);

	m->qc = NULL;

	m->cache = 0;
	m->emode = emode;

	b = (buffer*)GDKmalloc(sizeof(buffer));
	n = GDKmalloc(len + 1 + 1);
	strncpy(n, query, len);
	query = n;
	query[len] = '\n';
	query[len+1] = 0;
	len++;
	buffer_init(b, query, len);
	scanner_init( &m->scanner, 
		bstream_create(buffer_rastream(b, "sqlstatement"), b->len),
		NULL);
	m->scanner.mode = LINE_1; 
	bstream_next(m->scanner.rs);

	m->params = NULL;
	/*m->args = NULL;*/
	m->argc = 0;
	m->sym = NULL;
	m->errstr[0] = '\0';
	/* via views we give access to protected objects */
	m->user_id = USER_MONETDB;

	(void) sqlparse(m);	/* blindly ignore errors */
	rel = rel_semantic(m, m->sym);

	GDKfree(query);
	GDKfree(b);
	bstream_destroy(m->scanner.rs);

	m->sym = NULL;
	if (m->session->status || m->errstr[0]) {
		int status = m->session->status;
		char errstr[ERRSIZE];

		strcpy(errstr, m->errstr);
		*m = o;
		m->session->status = status;
		strcpy(m->errstr, errstr);
	} else {
		*m = o;
	}
	return rel;
}

sql_rel * 
rel_semantic(mvc *sql, symbol *s)
{
	if (!s)
		return NULL;

	switch (s->token) {

	case TR_COMMIT:
	case TR_SAVEPOINT:
	case TR_RELEASE:
	case TR_ROLLBACK:
	case TR_START:
	case TR_MODE:

	case SQL_CREATE_SCHEMA:
	case SQL_DROP_SCHEMA:
	case SQL_CREATE_TABLE:
	case SQL_DROP_TABLE:
	case SQL_ALTER_TABLE:
	case SQL_DROP_VIEW:
	case SQL_CREATE_INDEX:
	case SQL_DROP_INDEX:
	case SQL_CREATE_USER:
	case SQL_DROP_USER:
	case SQL_ALTER_USER:
	case SQL_RENAME_USER:
	case SQL_CREATE_ROLE:
	case SQL_DROP_ROLE:
	case SQL_GRANT:
	case SQL_REVOKE:
	case SQL_GRANT_ROLES:
	case SQL_REVOKE_ROLES:
	case SQL_CREATE_TYPE:
	case SQL_CREATE_TRIGGER:
	case SQL_DROP_TRIGGER:
	case SQL_CONNECT:
	case SQL_DISCONNECT:

	case SQL_CREATE_SEQ:
	case SQL_ALTER_SEQ:
	case SQL_DROP_SEQ:

	case SQL_COPYTO:

	case SQL_CREATE_FUNC:
	case SQL_CREATE_PROC:
	case SQL_CREATE_AGGR:
	case SQL_DROP_FUNC:
	case SQL_DROP_PROC:
	case SQL_DECLARE:
	case SQL_CALL:
	case SQL_SET:
		return NULL;

	case SQL_INSERT:
	case SQL_UPDATE:
	case SQL_DELETE:
	case SQL_COPYFROM:
	case SQL_BINCOPYFROM:
		return rel_updates(sql, s);

	case SQL_WITH:
	{
		dnode *d = s->data.lval->h;
		symbol *select = d->next->data.sym;
		sql_rel *rel = NULL;

		stack_push_frame(sql, "WITH");
		/* first handle all with's (ie inlined views) */
		for (d = d->data.lval->h; d; d = d->next) {
			symbol *sym = d->data.sym;
			dnode *dn = sym->data.lval->h;
			dnode *cn = sym->data.lval->h->next;
			char *name = qname_table(dn->data.lval);
			sql_rel *rel, *nrel;
			list *exps = NULL;

			if (frame_find_var(sql, name)) {
				return sql_error(sql, 01, "Variable '%s' allready declared", name);
			}
			/* add all columns */
			if (cn->data.lval) {
				dnode *n = cn->data.lval->h;

				exps = new_exp_list();
				for (; n; n = n->next) {
					char *cname = n->data.sval;
					append(exps, exp_column(name, cname, NULL, CARD_MULTI, 0 /* null? */, 0));
				}
			}
			rel = rel_recursive_func(exps);
			stack_push_rel_view(sql, name, rel);

			nrel = rel_semantic(sql, sym);
			if (!nrel) {  
				stack_pop_frame(sql);
				return NULL;
			}
			assert(is_project(nrel->op));
			if (is_project(nrel->op) && nrel->exps) {
				node *ne = nrel->exps->h;

				for (; ne; ne = ne->next) 
					exp_setname( ne->data, name, NULL );
			}
			if (!rel_is_ref(rel))
				stack_set_rel_view(sql, name, nrel);
			rel_destroy(nrel);
		}
		rel = rel_semantic(sql, select);
		stack_pop_frame(sql);
		return rel;
	}

	case SQL_MULSTMT:
		assert(0); /* handled before rel_semantic */
		return NULL;
	case SQL_PREP:
	{
		dnode *d = s->data.lval->h;
		symbol *sym = d->data.sym;
		sql_rel *r = rel_semantic(sql, sym);

		if (!r) 
			return NULL;
		return r;
	}

	case SQL_CREATE_VIEW:
	{
		dlist *l = s->data.lval;
		sql_rel *ret = rel_view(sql, l->h->data.lval, l->h->next->data.lval, l->h->next->next->data.sym, l->h->next->next->next->data.i_val, l->h->next->next->next->next->data.i_val);

		assert(l->h->next->next->next->type == type_int);
		assert(l->h->next->next->next->next->type == type_int);
		sql->type = Q_SCHEMA;
		return ret;
	} break;
	case SQL_SELECT:
	case SQL_JOIN:
	case SQL_CROSS:
	case SQL_UNION:
	case SQL_EXCEPT:
	case SQL_INTERSECT:
		return rel_selects(sql, s);

	default:
		return sql_error(sql, 02, "symbol type not found");
	}
}
