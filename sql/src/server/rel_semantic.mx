@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2008 CWI.
@' All Rights Reserved.

@f rel_semantic
@a N.J. Nes
@* 

@h
#ifndef _REL_SEMANTIC_H_
#define _REL_SEMANTIC_H_

#include <sql_list.h>
#include "sql_symbol.h"
#include "sql_parser.h"
#include "sql_relation.h"
#include <stdarg.h>

extern sql_rel *rel_semantic(mvc *sql, symbol *sym);
extern sql_rel *rel_parse(mvc *m, char *query, char emode);

extern comp_type swap_compare( comp_type t );

#endif /*_REL_SEMANTIC_H_*/

@c

#include "sql_config.h"
#include "sql_parser.h"
#include "sql_symbol.h"
#include "rel_semantic.h"
#include "rel_select.h"

#include <unistd.h>
#include <stdio.h>
#include <string.h>
#include <ctype.h>

comp_type 
swap_compare( comp_type t )
{
	switch(t) {
	case cmp_equal:
		return cmp_equal;
	case cmp_lt:
		return cmp_gt;
	case cmp_lte:
		return cmp_gte;
	case cmp_gte:
		return cmp_lte;
	case cmp_gt:
		return cmp_lt;
	case cmp_notequal:
		return cmp_notequal;
	default:
		return cmp_equal;
	}
	return cmp_equal;
}

sql_rel *
rel_parse(mvc *m, char *query, char emode)
{
	mvc o = *m;
	sql_rel *rel;
	buffer *b;
	char *n;
	int len = _strlen(query);

	m->qc = NULL;

	m->cache = 0;
	m->emode = emode;

	b = (buffer*)GDKmalloc(sizeof(buffer));
	n = GDKmalloc(len + 1 + 1);
	strncpy(n, query, len);
	query = n;
	query[len] = '\n';
	query[len+1] = 0;
	len++;
	buffer_init(b, query, len);
	scanner_init( &m->scanner, 
		bstream_create(buffer_rastream(b, "sqlstatement"), b->len),
		NULL);
	m->scanner.mode = LINE_1; 
	bstream_next(m->scanner.rs);

	m->params = NULL;
	/*m->args = NULL;*/
	m->argc = 0;
	m->sym = NULL;
	m->errstr[0] = '\0';
	/* via views we give access to protected objects */
	m->user_id = USER_MONETDB;

	(void) sqlparse(m);	/* blindly ignore errors */
	rel = rel_semantic(m, m->sym);

	GDKfree(query);
	GDKfree(b);
	bstream_destroy(m->scanner.rs);

	m->sym = NULL;
	if (m->session->status || m->errstr[0]) {
		int status = m->session->status;
		char errstr[ERRSIZE];

		strcpy(errstr, m->errstr);
		*m = o;
		m->session->status = status;
		strcpy(m->errstr, errstr);
	} else {
		*m = o;
	}
	return rel;
}

sql_rel * 
rel_semantic(mvc *sql, symbol *s)
{
	if (!s)
		return NULL;

	switch (s->token) {

	case TR_COMMIT:
	case TR_SAVEPOINT:
	case TR_RELEASE:
	case TR_ROLLBACK:
	case TR_START:
	case TR_MODE:

	case SQL_CREATE_SCHEMA:
	case SQL_DROP_SCHEMA:
	case SQL_CREATE_TABLE:
	case SQL_DROP_TABLE:
	case SQL_ALTER_TABLE:
	case SQL_DROP_VIEW:
	case SQL_CREATE_INDEX:
	case SQL_DROP_INDEX:
	case SQL_CREATE_USER:
	case SQL_DROP_USER:
	case SQL_ALTER_USER:
	case SQL_CREATE_ROLE:
	case SQL_DROP_ROLE:
	case SQL_GRANT:
	case SQL_REVOKE:
	case SQL_GRANT_ROLES:
	case SQL_REVOKE_ROLES:
	case SQL_CREATE_TYPE:
	case SQL_CREATE_TRIGGER:
	case SQL_DROP_TRIGGER:
	case SQL_CONNECT:
	case SQL_DISCONNECT:

	case SQL_CREATE_SEQ:
	case SQL_ALTER_SEQ:
	case SQL_DROP_SEQ:

	case SQL_COPYFROM:
	case SQL_COPYTO:
	case SQL_INSERT:
	case SQL_UPDATE:
	case SQL_DELETE:

	case SQL_CREATE_FUNC:
	case SQL_CREATE_PROC:
	case SQL_CREATE_AGGR:
	case SQL_DROP_FUNC:
	case SQL_DROP_PROC:
	case SQL_DECLARE:
	case SQL_CALL:
	case SQL_SET:

	case SQL_WITH:
	case SQL_MULSTMT:
		/*return sql_error(sql, 02, "Not implemented");*/
		return NULL;
	case SQL_PREP:
	{
		dnode *d = s->data.lval->h;
		symbol *sym = d->data.sym;
		sql_rel *r = rel_semantic(sql, sym);

		if (!r) 
			return NULL;
		return r;
	}

	case SQL_CREATE_VIEW:
	{
		dlist *l = s->data.lval;
		sql_rel *ret = rel_view(sql, l->h->data.lval, l->h->next->data.lval, l->h->next->next->data.sym, l->h->next->next->next->data.ival, l->h->next->next->next->next->data.ival);

		sql->type = Q_SCHEMA;
		return ret;
	} break;
	case SQL_SELECT:
	case SQL_JOIN:
	case SQL_CROSS:
	case SQL_UNION:
	case SQL_EXCEPT:
	case SQL_INTERSECT:
		return rel_selects(sql, s);

	default:
		return sql_error(sql, 02, "symbol type not found");
	}
	return sql_error(sql, 02, "symbol type not found");
}
