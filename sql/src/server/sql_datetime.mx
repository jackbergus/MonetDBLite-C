@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
@' Copyright August 2008- MonetDB B.V.
@' All Rights Reserved.

@f sql_datetime
@a N.J. Nes
@* 

@h
#ifndef _SQL_DATETIME_H_
#define _SQL_DATETIME_H_

#include "sql_mvc.h"
#include "sql_symbol.h"

typedef enum inttype {
	iyear = 1,
	imonth,
	iday,
	ihour,
	imin,
	isec
} itype;

int parse_interval_qualifier(mvc *sql, struct dlist *pers, int *sk, int *ek);
/* returns 0 for month intervals, 
 *         1 for sec intervals, 
 * 	   in both cases sk/ek contain the start and end qualifiers 
 *         <0 for errors */

int parse_interval(mvc *sql, lng sign, char *str, int sk, int ek, lng *i);
/* returns 0 for month intervals and value in val, 
 *         1 for sec intervals and value in val, 
 *         <0 for errors */

int interval_from_str(char *str, int sk, int ek, lng *val);
/* returns 0 for month intervals and value in val, 
 *         1 for sec intervals and value in val, 
 *         <0 for errors */

char *datetime_field(itype field);
/* returns the datetime_field string representation */

#endif /*_SQL_DATETIME_H_*/

@c
#include "sql_config.h"
#include "sql_datetime.h"
#include "sql_string.h"
#include <stdlib.h>

int
parse_interval_qualifier(mvc *sql, struct dlist *pers, int *sk, int *ek)
{
	*sk = iyear;
	*ek = isec;

	if (pers) {
		dlist *s = pers->h->data.lval;

		assert(s->h->type == type_int);
		*ek = *sk = s->h->data.i_val;

		if (dlist_length(pers) == 2) {
			dlist *e = pers->h->next->data.lval;

			assert(e->h->type == type_int);
			*ek = e->h->data.i_val;
		}
	}
	if (*sk > *ek) {
		snprintf(sql->errstr, ERRSIZE, _("End interval field is larger than the start field\n"));
		return -1;
	}
	if ((*sk == iyear || *sk == imonth) && *ek > imonth) {
		snprintf(sql->errstr, ERRSIZE, _("Correct interval ranges are year-month or day-seconds\n"));
		return -1;
	}
	if (*sk == iyear || *sk == imonth)
		return 0;
	return 1;
}

int
parse_interval_(mvc *sql, lng sign, char *str, int sk, int ek, lng *i)
{
	char *n = NULL;
	lng val = 0;
	char sep = ':';
	int type;
	lng mul;

	if (*str == '-') {
		sign *= -1; 
		str++;
	}
	mul = sign;
		
	switch (sk) {
	case iyear:
		mul *= 12;
	case imonth:
		sep = '-';
		type = 0;
		break;

	case iday:
		mul *= 24;
		sep = ' ';
	case ihour:
		mul *= 60;
	case imin:
		mul *= 60;
	case isec:
		type = 1;
		break;

	default:
		if (sql)
			snprintf(sql->errstr, ERRSIZE, _("Internal error: parse_interval: bad value for sk (%d)\n"), sk);
		return -1;
	}

	val = strtol(str, &n, 10);
	switch (sk) {
	case imonth:
		if (val >= 12) {
			snprintf(sql->errstr, ERRSIZE, _("Overflow detected in months (" LLFMT ")\n"), val);
			return -1;
		}
		break;
	case ihour:
		if (val >= 24) {
			snprintf(sql->errstr, ERRSIZE, _("Overflow detected in hours (" LLFMT ")\n"), val);
			return -1;
		}
		break;
	case imin:
		if (val >= 60) {
			snprintf(sql->errstr, ERRSIZE, _("Overflow detected in minutes (" LLFMT ")\n"), val);
			return -1;
		}
		break;
	case isec:
		if (val >= 60) {
			snprintf(sql->errstr, ERRSIZE, _("Overflow detected in seconds (" LLFMT ")\n"), val);
			return -1;
		}
		break;
	}
	val *= mul;
	*i += val;
	if (ek != sk) {
		if (*n != sep) {
			if (sql)
				snprintf(sql->errstr, ERRSIZE, _("Interval field seperator \'%c\' missing\n"), sep);
			return -1;
		}
		return parse_interval_(sql, sign, n + 1, sk + 1, ek, i);
	} else {
		return type;
	}
}

int
parse_interval(mvc *sql, lng sign, char *str, int sk, int ek, lng *i)
{
	char *n = NULL;
	lng val = 0;
	char sep = ':';
	int type;
	lng mul;

	if (*str == '-') {
		sign *= -1; 
		str++;
	}
	mul = sign;
		
	switch (sk) {
	case iyear:
		mul *= 12;
	case imonth:
		sep = '-';
		type = 0;
		break;

	case iday:
		mul *= 24;
		sep = ' ';
	case ihour:
		mul *= 60;
	case imin:
		mul *= 60;
	case isec:
		type = 1;
		break;

	default:
		if (sql)
			snprintf(sql->errstr, ERRSIZE, _("Internal error: parse_interval: bad value for sk (%d)\n"), sk);
		return -1;
	}

	val = strtol(str, &n, 10);
	val *= mul;
	*i += val;
	if (ek != sk) {
		if (*n != sep) {
			if (sql)
				snprintf(sql->errstr, ERRSIZE, _("Interval field seperator \'%c\' missing\n"), sep);
			return -1;
		}
		return parse_interval_(sql, sign, n + 1, sk + 1, ek, i);
	} else {
		return type;
	}
}

int interval_from_str(char *str, int sk, int ek, lng *val)
{
	*val = 0;
	return parse_interval(NULL, 1, str, sk, ek, val);
}



char *
datetime_field(itype f)
{
	switch (f) {
	case iyear:
		return "year";
	case imonth:
		return "month";
	case iday:
		return "day";
	case ihour:
		return "hour";
	case imin:
		return "minute";
	case isec:
		return "second";
	}
	return "year";
}
