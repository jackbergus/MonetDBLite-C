@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2006 CWI.
@' All Rights Reserved.

@f sql_psm
@a N.J. Nes
@* 

@h
#ifndef _SQL_PSM_H_
#define _SQL_PSM_H_

#include <sql_list.h>
#include "sql_symbol.h"
#include "sql_statement.h"

extern stmt *psm(mvc *sql, symbol *sym);

#endif /* _SQL_PSM_H_ */
@c
#include "sql_psm.h"
#include "sql_select.h"
#include "sql_semantic.h"

static stmt * sequential_block (mvc *sql, scope *scp, sql_subtype *res, dlist *blk, char *opt_name);

/* SET variable = value */

static stmt *
psm_set(mvc *sql, scope *scp, dnode *n)
{
	char *name = n->data.sval;
	symbol *val = n->next->data.sym;
	stmt *var, *r = NULL;
	int level = 0;
	sql_subtype *tpe = NULL;

	/* name can be 
		'parameter of the function' (ie in the param list)
		or a local or global variable, declared earlier
	*/

	/* check if variable is known from the stack */
	if ((var=stack_find_var(sql, name)) == NULL) {
		sql_arg *a = sql_bind_param(sql, name);

		if (!a) /* not parameter, ie local var ? */
			return sql_error(sql, 01, "Variable %s unknown", name);
		tpe = &a->type;
	} else { 
		tpe = tail_type(var);
	}

	r = sql_value_exp(sql, scp, val, NULL, NULL, sql_sel);
	if (!r)
		return NULL;

	level = stack_find_frame(sql, name);
	r = check_types(sql, tpe, r, type_equal); 
	if (!r)
		return NULL;
	return stmt_assign(name, r, level);
}

static stmt *
psm_declare(mvc *sql, scope *scp, dnode *n)
{
	list *l;

	(void)scp;
	l = create_stmt_list();
	while(n) { /* list of  'identfiers with type' */
		dnode *ids = n->data.sym->data.lval->h->data.lval->h;
		sql_subtype *ctype = &n->data.sym->data.lval->h->next->data.typeval;
		while(ids) {
			char *name = ids->data.sval;
			stmt *r = NULL;

			/* check if we overwrite a scope local variable declare x; declare x; */
			if (frame_find_var(sql, name)) {
				list_destroy(l);
				return sql_error(sql, 01, 
					"Variable %s allready declared", name);
			}
			r = stmt_var(_strdup(name), ctype, 1, sql->frame );
			stack_push_var(sql, name, r);
			list_append(l, r);
			ids = ids->next;
		}
		n = n->next;
	}
	return stmt_list(l);
}

/* [ label: ]
   while (cond) do 
	statement_list
   end [ label ]
   currently we only parse the labels, they cannot be used as there is no

   support for LEAVE and ITERATE (sql multi-level break and continue)
 */
static stmt * 
psm_while_do( mvc *sql, scope *scp, sql_subtype *res, dnode *w )
{
	if (!w)
		return NULL;
	if (w->type == type_symbol) { 
		stmt *cond, *whilestmts;
		dnode *n = w;

		cond = sql_logical_exp(sql, scp, n->data.sym, NULL, NULL, sql_sel); 
		n = n->next;
		whilestmts = sequential_block(sql, scp, res, n->data.lval, n->next->data.sval);

		if (sql->session->status || !cond || !whilestmts) {
			cond_stmt_destroy(cond);
			cond_stmt_destroy(whilestmts);
			return NULL;
		}
		return stmt_while( cond, whilestmts );
	}
	return NULL;
}


/* if (cond) then statement_list
   [ elseif (cond) then statement_list ]*
   [ else statement_list ]
   end if
 */
static stmt * 
psm_if_then_else( mvc *sql, scope *scp, sql_subtype *res, dnode *elseif )
{
	if (!elseif)
		return NULL;
	if (elseif->next && elseif->type == type_symbol) { /* if or elseif */
		stmt *cond, *ifstmts, *elsestmts;
		dnode *n = elseif;

		cond = sql_logical_exp(sql, scp, n->data.sym, NULL, NULL, sql_sel); 
		n = n->next;
		ifstmts = sequential_block(sql, scp, res, n->data.lval, NULL);
		n = n->next;
		elsestmts = psm_if_then_else( sql, scp, res, n);

		if (sql->session->status || !cond || !ifstmts) {
			cond_stmt_destroy(cond);
			cond_stmt_destroy(ifstmts);
			cond_stmt_destroy(elsestmts);
			return NULL;
		}
		return stmt_if( cond, ifstmts, elsestmts);
	} else { /* else */
		symbol *e = elseif->data.sym;

		if (e->token != SQL_ELSE)
			return NULL;
		return sequential_block( sql, scp, res, e->data.lval, NULL);
	}
}

/* 	1
	CASE
	WHEN search_condition THEN statements
	[ WHEN search_condition THEN statements ]
	[ ELSE statements ]
	END CASE

	2
	CASE case_value
	WHEN when_value THEN statements
	[ WHEN when_value THEN statements ]
	[ ELSE statements ]
	END CASE
 */
static stmt * 
psm_case( mvc *sql, scope *scp, sql_subtype *res, dnode *case_when )
{
	if (!case_when)
		return NULL;

	/* case 1 */
	if (case_when->type == type_symbol) {
		dnode *n = case_when;
		symbol *case_value = n->data.sym;
		dlist *when_statements = n->next->data.lval;
		dlist *else_statements = n->next->next->data.lval;
		stmt *else_stmt = NULL, *v = sql_value_exp(sql, scp, case_value, NULL, NULL, sql_sel);
		stmt *cur_if = NULL, *top = NULL;

		if (!v)
			return NULL;
		if (else_statements) {
			else_stmt = sequential_block( sql, scp, res, else_statements, NULL);
			if (!else_stmt) {
				stmt_destroy(v);
				return NULL;
			}
		}
		n = when_statements->h;
		while(n) {
			dnode *m = n->data.sym->data.lval->h;
			stmt *cond=0, *when_value = sql_value_exp(sql, scp, m->data.sym, NULL, NULL, sql_sel);
			stmt *if_stmts = NULL;
			stmt *case_stmt = NULL;

			if (!when_value || 
			   (cond = sql_compare(sql, stmt_dup(v), when_value, "=", sql_sel)) == NULL || 
			   (if_stmts = sequential_block( sql, scp, res, m->next->data.lval, NULL)) == NULL ) {
				stmt_destroy(v);
				cond_stmt_destroy(else_stmt);
				cond_stmt_destroy(cond);
				return NULL;
			}
			case_stmt = stmt_if(cond, if_stmts, NULL);
			if (cur_if)
				cur_if->op3.stval = case_stmt;
			cur_if = case_stmt;
			if (!top)
				top = case_stmt;
			n = n->next;
		}
		if (cur_if)
			cur_if->op3.stval = else_stmt;
		return top;
	} else { 
		/* case 2 */
		dnode *n = case_when;
		dlist *whenlist = n->data.lval;
		dlist *else_statements = n->next->data.lval;
		stmt *else_stmt = NULL, *cur_if = NULL, *top = NULL;

		if (else_statements) {
			else_stmt = sequential_block( sql, scp, res, else_statements, NULL);
			if (!else_stmt) 
				return NULL;
		}
		n = whenlist->h;
		while(n) {
			dnode *m = n->data.sym->data.lval->h;
			stmt *cond = sql_logical_exp(sql, scp, m->data.sym, NULL, NULL, sql_sel);
			stmt *if_stmts = NULL;
			stmt *case_stmt = NULL;

			if (!cond || 
			   (if_stmts = sequential_block( sql, scp, res, m->next->data.lval, NULL)) == NULL ) {
				cond_stmt_destroy(else_stmt);
				cond_stmt_destroy(cond);
				return NULL;
			}
			case_stmt = stmt_if(cond, if_stmts, NULL);
			if (cur_if)
				cur_if->op3.stval = case_stmt;
			cur_if = case_stmt;
			if (!top)
				top = case_stmt;
			n = n->next;
		}
		if (cur_if)
			cur_if->op3.stval = else_stmt;
		return top;
	}
	return NULL;
}

/* return val;
 */
static stmt * 
psm_return( mvc *sql, scope *scp, sql_subtype *restype, symbol *return_sym )
{
	stmt *res = sql_value_exp(sql, scp, return_sym, NULL, NULL, sql_sel);
	if (!res || (res = check_types(sql, restype, res, type_equal)) == NULL)
		return NULL;
	return stmt_return(res);
}

static stmt *
sequential_block (mvc *sql, scope *scp, sql_subtype *restype, dlist *blk, char *opt_label) 
{
	list *l=0;
	stmt *res = NULL;
	dnode *n;

	if (blk->h)
 		l = create_stmt_list();
	stack_push_frame(sql, opt_label);
	for (n = blk->h; n; n = n->next ) {
		symbol *s = n->data.sym;
		switch (s->token) {
		case SQL_SET:
			res = psm_set(sql, scp, s->data.lval->h);
			break;
		case SQL_DECLARE:
			res = psm_declare(sql, scp, s->data.lval->h);
			break;
		case SQL_WHILE:
			res = psm_while_do(sql, scp, restype, s->data.lval->h);
			break;
		case SQL_IF:
			res = psm_if_then_else(sql, scp, restype, s->data.lval->h);
			break;
		case SQL_CASE:
			res = psm_case(sql, scp, restype, s->data.lval->h);
			break;
		case SQL_RETURN:
			res = psm_return(sql, scp, restype, s->data.sym);
			break;
		default:
			printf("default \n");
		}
		if (!res) {
			list_destroy(l);
			l = NULL;
			break;
		}
		list_append(l, res);
	}
	stack_pop_frame(sql);
	if (l)
		return stmt_list(l);
	return NULL;
}

static stmt *
create_func(mvc *sql, dlist *qname, dlist *params, sql_subtype *res, char *impl, dlist *body)
{
	char *fname = qname_table(qname);
	dnode *n;
	list *l = list_create((fdestroy) &arg_destroy);

	for (n = params->h; n; n = n->next) {
		dnode *an = n->data.lval->h;

		list_append(l, sql_create_arg(_strdup(an->data.sval), &an->next->data.typeval));
		sql_add_param(sql, an->data.sval, &an->next->data.typeval);
	}
	if (body) {		/* sql func */
		char *q = QUERY(sql->scanner);
		stmt *b = NULL;

		if (!(b = sequential_block(sql, NULL, res, body, NULL ))) {
			return NULL;
		}
		
		/* in prepare mode we instanciate the function */
		if (sql->mode == m_prepare) {
			return b;
		} else {
			stmt_destroy(b);
			sql_destroy_params(sql);
			mvc_create_func(sql, sql->session->schema, fname, l, res, TRUE, FALSE, q);
		}
	} else {
		mvc_create_func(sql, sql->session->schema, fname, l, res, FALSE, FALSE, impl);
	}
	return stmt_none();
}


stmt *
psm(mvc *sql, symbol *s)
{
	stmt *ret = NULL;

	switch (s->token) {

	case SQL_CREATE_FUNC:
	{
		dlist *l = s->data.lval;

		ret = create_func(sql, l->h->data.lval, l->h->next->data.lval, &l->h->next->next->data.typeval, l->h->next->next->next->data.sval, l->h->next->next->next->next->data.lval);
		sql->type = Q_SCHEMA;
	} 	break;
	case SQL_SET:
		ret = psm_set(sql, NULL, s->data.lval->h);
		sql->type = Q_UPDATE;
		break;
	case SQL_DECLARE:
		ret = psm_declare(sql, NULL, s->data.lval->h);
		sql->type = Q_UPDATE;
		break;
	default:
		return sql_error(sql, 01, "schema statement unknown symbol(%ld)->token = %s", (long) s, token2string(s->token));
	}
	return ret;
}
