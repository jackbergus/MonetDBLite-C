@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2007 CWI.
@' All Rights Reserved.

@f sql_psm
@a N.J. Nes
@* 

@h
#ifndef _SQL_PSM_H_
#define _SQL_PSM_H_

#include <sql_list.h>
#include "sql_symbol.h"
#include "sql_statement.h"
#include "sql_scope.h"

extern stmt *psm(mvc *sql, symbol *sym);

extern stmt * sequential_block (mvc *sql, scope *scp, sql_subtype *res, dlist *blk, char *opt_name);


#endif /* _SQL_PSM_H_ */
@c
#include "sql_config.h"
#include "sql_psm.h"
#include "sql_schema.h"
#include "sql_select.h"
#include "sql_updates.h"
#include "sql_semantic.h"
#include "sql_privileges.h"

/* SET variable = value */

static stmt *
psm_set(mvc *sql, scope *scp, dnode *n)
{
	exp_kind ek = {type_value, card_value, FALSE};
	char *name = n->data.sval;
	symbol *val = n->next->data.sym;
	stmt *var, *r = NULL;
	int level = 0;
	sql_subtype *tpe = NULL;

	/* name can be 
		'parameter of the function' (ie in the param list)
		or a local or global variable, declared earlier
	*/

	/* check if variable is known from the stack */
	if ((var=stack_find_var(sql, name)) == NULL) {
		sql_arg *a = sql_bind_param(sql, name);

		if (!a) /* not parameter, ie local var ? */
			return sql_error(sql, 01, "Variable %s unknown", name);
		tpe = &a->type;
	} else { 
		tpe = tail_type(var);
	}

	r = sql_value_exp(sql, scp, val, NULL, NULL, sql_sel, ek);
	if (!r)
		return NULL;

	level = stack_find_frame(sql, name);
	r = check_types(sql, tpe, r, type_equal); 
	if (!r)
		return NULL;
	return stmt_assign(name, r, level);
}

/* TODO add logic to check if variables get initialized */
static stmt *
psm_declare(mvc *sql, scope *scp, dnode *n)
{
	list *l;

	(void)scp;
	l = create_stmt_list();
	while(n) { /* list of 'identfiers with type' */
		dnode *ids = n->data.sym->data.lval->h->data.lval->h;
		sql_subtype *ctype = &n->data.sym->data.lval->h->next->data.typeval;
		while(ids) {
			char *name = ids->data.sval;
			stmt *r = NULL;

			/* check if we overwrite a scope local variable declare x; declare x; */
			if (frame_find_var(sql, name)) {
				list_destroy(l);
				return sql_error(sql, 01, 
					"Variable '%s' allready declared", name);
			}
			r = stmt_var(_strdup(name), ctype, 1, sql->frame );
			stack_push_var(sql, name, r, ctype);
			list_append(l, r);
			ids = ids->next;
		}
		n = n->next;
	}
	return stmt_list(l);
}


static sql_table *
find_basetable(stmt *s)
{
	switch(s->type) {
	case st_list:
		if (list_length(s->op1.lval)) 
			return find_basetable(s->op1.lval->h->data);
		break;
	case st_basetable:
		return s->op1.tval;
	default:
		if (s->op1.stval)
			return find_basetable(s->op1.stval);
	}
	return NULL;
}

static stmt *
psm_declare_table(mvc *sql, scope *scp, dnode *n)
{
	node *m;
	dlist *qname = n->next->data.lval;
	char *name = qname_table(qname);
	char *sname = qname_schema(qname);
	stmt *ret, *r;
	sql_subtype ctype = *sql_bind_localtype("bat");
	list *l;

	(void)scp;
	if (sname)  /* not allowed here */
		return sql_error(sql, 02, "DECLARE TABLE: qualified name allowed");
	if (frame_find_var(sql, name)) 
		return sql_error(sql, 01, "Variable '%s' allready declared", 
			name);
	
	ret = sql_create_table(sql, cur_schema(sql), SQL_DECLARED_TABLE, qname, n->next->next->data.sym, n->next->next->next->data.ival);

	if (!ret)
		return NULL;

	ctype.comp_type = find_basetable(ret); 

	l = create_stmt_list();
	for (m=ctype.comp_type->columns.set->h; m; m = m->next) {
		sql_column *c = m->data;
		stmt *cs = stmt_temp(&c->type);
		char *tname = _strdup(c->t->base.name);
		cs = stmt_alias(cs, tname, _strdup(c->base.name));
		list_append(l, cs);
	}
	r = stmt_list(l);
	stack_push_var(sql, name, r, &ctype);
	stmt_destroy(ret);
	return r;
}

/* [ label: ]
   while (cond) do 
	statement_list
   end [ label ]
   currently we only parse the labels, they cannot be used as there is no

   support for LEAVE and ITERATE (sql multi-level break and continue)
 */
static stmt * 
psm_while_do( mvc *sql, scope *scp, sql_subtype *res, dnode *w )
{
	if (!w)
		return NULL;
	if (w->type == type_symbol) { 
		stmt *cond, *whilestmts;
		dnode *n = w;

		cond = sql_logical_exp(sql, scp, n->data.sym, NULL, NULL, sql_sel); 
		n = n->next;
		whilestmts = sequential_block(sql, scp, res, n->data.lval, n->next->data.sval);

		if (sql->session->status || !cond || !whilestmts) {
			cond_stmt_destroy(cond);
			cond_stmt_destroy(whilestmts);
			return NULL;
		}
		return stmt_while( cond, whilestmts );
	}
	return NULL;
}


/* if (cond) then statement_list
   [ elseif (cond) then statement_list ]*
   [ else statement_list ]
   end if
 */
static stmt * 
psm_if_then_else( mvc *sql, scope *scp, sql_subtype *res, dnode *elseif )
{
	if (!elseif)
		return NULL;
	if (elseif->next && elseif->type == type_symbol) { /* if or elseif */
		stmt *cond, *ifstmts, *elsestmts;
		dnode *n = elseif;

		cond = sql_logical_exp(sql, scp, n->data.sym, NULL, NULL, sql_sel); 
		n = n->next;
		ifstmts = sequential_block(sql, scp, res, n->data.lval, NULL);
		n = n->next;
		elsestmts = psm_if_then_else( sql, scp, res, n);

		if (sql->session->status || !cond || !ifstmts) {
			cond_stmt_destroy(cond);
			cond_stmt_destroy(ifstmts);
			cond_stmt_destroy(elsestmts);
			return NULL;
		}
		return stmt_if( cond, ifstmts, elsestmts);
	} else { /* else */
		symbol *e = elseif->data.sym;

		if (e==NULL || (e->token != SQL_ELSE))
			return NULL;
		return sequential_block( sql, scp, res, e->data.lval, NULL);
	}
}

/* 	1
	CASE
	WHEN search_condition THEN statements
	[ WHEN search_condition THEN statements ]
	[ ELSE statements ]
	END CASE

	2
	CASE case_value
	WHEN when_value THEN statements
	[ WHEN when_value THEN statements ]
	[ ELSE statements ]
	END CASE
 */
static stmt * 
psm_case( mvc *sql, scope *scp, sql_subtype *res, dnode *case_when )
{
	exp_kind ek = {type_value, card_value, FALSE};

	if (!case_when)
		return NULL;

	/* case 1 */
	if (case_when->type == type_symbol) {
		dnode *n = case_when;
		symbol *case_value = n->data.sym;
		dlist *when_statements = n->next->data.lval;
		dlist *else_statements = n->next->next->data.lval;
		stmt *else_stmt = NULL, *v = sql_value_exp(sql, scp, case_value, NULL, NULL, sql_sel, ek);
		stmt *cur_if = NULL, *top = NULL;

		if (!v)
			return NULL;
		if (else_statements) {
			else_stmt = sequential_block( sql, scp, res, else_statements, NULL);
			if (!else_stmt) {
				stmt_destroy(v);
				return NULL;
			}
		}
		n = when_statements->h;
		while(n) {
			dnode *m = n->data.sym->data.lval->h;
			stmt *cond=0, *when_value = sql_value_exp(sql, scp, m->data.sym, NULL, NULL, sql_sel, ek);
			stmt *if_stmts = NULL;
			stmt *case_stmt = NULL;

			if (!when_value || 
			   (cond = sql_compare(sql, scp, stmt_dup(v), when_value, "=", sql_sel)) == NULL || 
			   (if_stmts = sequential_block( sql, scp, res, m->next->data.lval, NULL)) == NULL ) {
				stmt_destroy(v);
				cond_stmt_destroy(else_stmt);
				cond_stmt_destroy(cond);
				return NULL;
			}
			case_stmt = stmt_if(cond, if_stmts, NULL);
			if (cur_if)
				cur_if->op3.stval = case_stmt;
			cur_if = case_stmt;
			if (!top)
				top = case_stmt;
			n = n->next;
		}
		if (cur_if)
			cur_if->op3.stval = else_stmt;
		return top;
	} else { 
		/* case 2 */
		dnode *n = case_when;
		dlist *whenlist = n->data.lval;
		dlist *else_statements = n->next->data.lval;
		stmt *else_stmt = NULL, *cur_if = NULL, *top = NULL;

		if (else_statements) {
			else_stmt = sequential_block( sql, scp, res, else_statements, NULL);
			if (!else_stmt) 
				return NULL;
		}
		n = whenlist->h;
		while(n) {
			dnode *m = n->data.sym->data.lval->h;
			stmt *cond = sql_logical_exp(sql, scp, m->data.sym, NULL, NULL, sql_sel);
			stmt *if_stmts = NULL;
			stmt *case_stmt = NULL;

			if (!cond || 
			   (if_stmts = sequential_block( sql, scp, res, m->next->data.lval, NULL)) == NULL ) {
				cond_stmt_destroy(else_stmt);
				cond_stmt_destroy(cond);
				return NULL;
			}
			case_stmt = stmt_if(cond, if_stmts, NULL);
			if (cur_if)
				cur_if->op3.stval = case_stmt;
			cur_if = case_stmt;
			if (!top)
				top = case_stmt;
			n = n->next;
		}
		if (cur_if)
			cur_if->op3.stval = else_stmt;
		return top;
	}
	return NULL;
}

/* return val;
 */
static stmt * 
psm_return( mvc *sql, scope *scp, sql_subtype *restype, symbol *return_sym )
{
	exp_kind ek = {type_value, card_value, FALSE};
	stmt *res;

	if (restype->comp_type)
		ek.card = card_relation;
	res = sql_value_exp(sql, scp, return_sym, NULL, NULL, sql_sel, ek);
	if (!res || (res = check_types(sql, restype, res, type_equal)) == NULL)
		return NULL;
	return stmt_return(res);
}

stmt *
sequential_block (mvc *sql, scope *scp, sql_subtype *restype, dlist *blk, char *opt_label) 
{
	list *l=0;
	dnode *n;

	if (blk->h)
 		l = create_stmt_list();
	stack_push_frame(sql, opt_label);
	for (n = blk->h; n; n = n->next ) {
		stmt *res = NULL;
		symbol *s = n->data.sym;
		switch (s->token) {
		case SQL_SET:
			res = psm_set(sql, scp, s->data.lval->h);
			break;
		case SQL_DECLARE:
			res = psm_declare(sql, scp, s->data.lval->h);
			break;
		case SQL_CREATE_TABLE: 
			res = psm_declare_table(sql, scp, s->data.lval->h);
			break;
		case SQL_WHILE:
			res = psm_while_do(sql, scp, restype, s->data.lval->h);
			break;
		case SQL_IF:
			res = psm_if_then_else(sql, scp, restype, s->data.lval->h);
			break;
		case SQL_CASE:
			res = psm_case(sql, scp, restype, s->data.lval->h);
			break;
		case SQL_RETURN:
			/* should be last statement of a sequential_block */
			if (n->next) { 
				res = sql_error(sql, 01, 
					"Statement after return");
			} else {
				res =psm_return(sql, scp, restype, s->data.sym);
			}
			break;
		case SQL_SELECT: { /* row selections (into variables) */
			exp_kind ek = {type_value, card_row, TRUE};
			res = scope_subquery(sql, scp, s, ek);
		}	break;
		case SQL_COPYFROM:
		case SQL_INSERT:
		case SQL_UPDATE:
		case SQL_DELETE:
			res = updates(sql, scp, s);
			break;
		default:
			res = sql_error(sql, 01, 
			 "Statement '%s' is not a valid flow control statement",
			 token2string(s->token));
		}
		if (!res) {
			list_destroy(l);
			l = NULL;
			break;
		}
		list_append(l, res);
	}
	stack_pop_frame(sql);
	if (l)
		return stmt_list(l);
	return NULL;
}

static sql_subtype *
result_type(mvc *sql, char *fname, symbol *res ) 
{
	if (res->token == SQL_TYPE) {
		return &res->data.lval->h->data.typeval;
	} else if (res->token == SQL_TABLE) {

		/* here we create a new table-type */
		sql_subtype *t = NEW(sql_subtype);
		sql_table *tbl;
		dnode *n = res->data.lval->h;
		char *tnme = NEW_ARRAY(char, strlen(fname) + 2);

		tnme[0] = '#';
		strcpy(tnme+1, fname);
		tbl = mvc_create_generated(sql, sql->session->schema, tnme, NULL, 1 /* system ?*/);
		for(;n; n = n->next->next) {
			sql_subtype *ct = &n->next->data.typeval;
		    	mvc_create_column(sql, tbl, n->data.sval, ct);
		}
		_DELETE(tnme);

		sql_find_subtype(t, "table", 0, 0);
		t->comp_type = tbl;
		t->digits = tbl->base.id; /* pass the table through digits */
		return t;
	}
	return NULL;
}

static int
has_return(stmt *s )
{
	if (s->type == st_return) {
		return 1;
	} else if (s->type == st_if) {
		int res = has_return(s->op2.stval); /* ifstmts */
		if (res && s->op3.stval)
			res = has_return(s->op3.stval); /* elsestmts */
		return res;
	} else if (s->type == st_list) { /* sequential block */
		return has_return(s->op1.lval->t->data);
	}
	return 0;
}

list *
create_type_list(dlist *params, int param)
{
	sql_subtype *par_subtype;
	list * type_list = list_create((fdestroy) NULL);
	dnode * n = NULL;
	
	for (n = params->h; n; n = n->next) {
		dnode *an = n;
		/*char subtype_name[BUFSIZ];*/

		if (param) {
	               	an = n->data.lval->h;
			par_subtype = &an->next->data.typeval;
			list_append(type_list, par_subtype);
		} else { 
			par_subtype = &an->data.typeval;
			list_prepend(type_list, par_subtype);
		}
	
		

	}
	return type_list;
}

static stmt *
create_func(mvc *sql, dlist *qname, dlist *params, symbol *res, dlist *ext_name, dlist *body)
{
	char *fname = qname_table(qname);
	char *sname = qname_schema(qname);
	sql_schema *s = NULL;
	sql_subfunc * sub_f = NULL;
	sql_func *f;
	dnode *n;
	list *l = list_create((fdestroy) &arg_destroy), *type_list = NULL;
	list *id_func_l = NULL, *id_col_l = NULL, *view_id_l = NULL;
	sql_subtype *restype;
	int instantiate = (sql->mode == m_execute);

	if (sname && !(s = mvc_bind_schema(sql, sname)))
		return sql_error(sql, 02, "CREATE FUNCTION: no such schema '%s'", sname);
	if(s == NULL)
		s = cur_schema(sql);
	restype = result_type(sql, fname, res);

	if (params)
		type_list = create_type_list(params, 1);
	
	if (!instantiate && (sub_f = sql_bind_func_(s, fname, type_list))) {
		if (params) {
			char args[BUFSIZ], *arg_list = NULL;
			node *n;
			
			if (type_list->cnt > 0) {
	
				for (n = type_list->h; n; n = n->next) {
				char *tpe =  subtype2string((sql_subtype *) n->data);
				
				if (arg_list)	
					snprintf(args, BUFSIZ, "%s, %s", arg_list, tpe);
				else
					snprintf(args, BUFSIZ, "%s", tpe);
		                arg_list = GDKstrdup(args);
				_DELETE(tpe);	
				}
				
				list_destroy(type_list);
				
				return sql_error(sql, 02, "CREATE FUNCTION: name '%s' (%s) already in use", fname, arg_list);
			}
				
			return sql_error(sql, 02, "DROP FUNCTION: no such function '%s' ()", fname);

		} else
			return sql_error(sql, 02, "DROP FUNCTION: no such function '%s'", fname);
	
	} else {
		list_destroy(type_list);
	
		if (!instantiate && !schema_privs(sql->role_id, s)) {
			return sql_error(sql, 02, "CREATE FUNCTION: insufficient privileges for user '%s' in schema '%s'", stack_get_string(sql, "current_user"), s->base.name);
		} else {
		 	if (params) 
				for (n = params->h; n; n = n->next) {
					dnode *an = n->data.lval->h;
		
					list_append(l, sql_create_arg(_strdup(an->data.sval), &an->next->data.typeval));
					sql_add_param(sql, an->data.sval, &an->next->data.typeval);
				}
		 	if (body) {		/* sql func */
				char *q = QUERY(sql->scanner);
				stmt *b = NULL;
	
				if (!(b = sequential_block(sql, NULL, restype, body, NULL ))) {
					return NULL;
				}
			
				/* check if we have a return statement */
				if (restype && !has_return(b)) 
					return sql_error(sql, 01, "Missing return statement");
	
				/* in execute mode we instantiate the function */
				if (instantiate) {
					return b;
				} else {
					sql_destroy_params(sql);

					f = mvc_create_func(sql, sql->session->schema, fname, l, restype, TRUE, FALSE, "user", q);
					if (b) {
						id_col_l = stmt_list_dependencies(b, COLUMN_DEPENDENCY);
						id_func_l = stmt_list_dependencies(b, FUNC_DEPENDENCY);
						view_id_l = stmt_list_dependencies(b, VIEW_DEPENDENCY);
						
						mvc_create_dependencies(sql, id_col_l, f->base.id, FUNC_DEPENDENCY);
						mvc_create_dependencies(sql, id_func_l, f->base.id, FUNC_DEPENDENCY);
						mvc_create_dependencies(sql, view_id_l, f->base.id, FUNC_DEPENDENCY);
	
						list_destroy(id_col_l);
						list_destroy(id_func_l);
						list_destroy(view_id_l);
					}
					stmt_destroy(b);
				}
			} else {
				char *fmod = qname_module(ext_name);
				char *fnme = qname_fname(ext_name);
				mvc_create_func(sql, sql->session->schema, fname, l, restype, FALSE, FALSE, fmod, fnme );
			}
		}
	}
	return stmt_none();
}

stmt* 
drop_func(mvc *sql, dlist *qname, dlist *typelist, int drop_action)
{
	char *name = qname_table(qname);
	char *sname = qname_schema(qname);
	sql_schema *s = NULL;
	list * list_func = NULL, *type_list = NULL; 
	sql_subfunc *sub_func = NULL;
	sql_func *func = NULL;

	if (sname && !(s = mvc_bind_schema(sql, sname)))
		return sql_error(sql, 02, "DROP FUNCTION: no such schema '%s'", sname);

	if (s == NULL) 
		s =  cur_schema(sql);
	
	if (typelist) {	
		type_list = create_type_list(typelist, 0);
		sub_func = sql_bind_func_(s,name, type_list);
		if (!sub_func && !sname) {
			s = tmp_schema(sql);
			sub_func = sql_bind_func_(s, name, type_list);
		}
		if (sub_func)
			func = sub_func->func;
	}
	else {
		list_func = schema_bind_func(sql,s,name);
		if (list_func && list_func->cnt > 1)
			return sql_error(sql, 02, "DROP FUNCTION: there are more than one function called '%s', please use the full signature", name);
		if (list_func && list_func->cnt == 1)
			func = (sql_func*) list_func->h->data;
	}
	
	if (!func) { 
		if (typelist) {
			char args[BUFSIZ], *arg_list = NULL;
			node *n;
			
			if (type_list->cnt > 0) {
	
				for (n = type_list->h; n; n = n->next) {
				char *tpe =  subtype2string((sql_subtype *) n->data);
				
				if (arg_list)	
					snprintf(args, BUFSIZ, "%s, %s", arg_list, tpe);
				else
					snprintf(args, BUFSIZ, "%s", tpe);
		                arg_list = GDKstrdup(args);
				_DELETE(tpe);	
				}
				
				list_destroy(type_list);
				
				return sql_error(sql, 02, "DROP FUNCTION: no such function '%s' (%s)", name, arg_list);
			}
				
			return sql_error(sql, 02, "DROP FUNCTION: no such function '%s' ()", name);

		} else
			return sql_error(sql, 02, "DROP FUNCTION: no such function '%s'", name);
	} 
	
	list_destroy(type_list);

	
	if (!schema_privs(sql->role_id, s)) {
		return sql_error(sql, 02, "DROP FUNCTION: access denied for %s to schema ;'%s'", stack_get_string(sql, "current_user"), s->base.name);
	}
	
	
	if (!drop_action && mvc_check_dependency(sql, func->base.id, FUNC_DEPENDENCY))
		return sql_error(sql, 02, "DROP FUNCTION: there are functions dependent on function %s;", func->base.name);
	
	mvc_drop_func(sql, s, func, drop_action);

	return stmt_none();
}

stmt* 
drop_all_func(mvc *sql, dlist *qname, int drop_action)
{
	char *name = qname_table(qname);
	char *sname = qname_schema(qname);
	sql_schema *s = NULL;
	list * list_func = NULL; 
	sql_func *func = NULL;
	node *n = NULL;

	if (sname && !(s = mvc_bind_schema(sql, sname)))
		return sql_error(sql, 02, "DROP FUNCTION: no such schema '%s'", sname);

	if (s == NULL) 
		s =  cur_schema(sql);
	
	list_func = schema_bind_func(sql,s,name);
	
	if (!list_func) { 
			return sql_error(sql, 02, "DROP ALL FUNCTION: no such functions '%s'", name);
	} 
	
	if (!schema_privs(sql->role_id, s)) {
		return sql_error(sql, 02, "DROP FUNCTION: access denied for %s to schema ;'%s'", stack_get_string(sql, "current_user"), s->base.name);
	}
	
	
	for( n = list_func->h ; n; n = n->next) {
		func = (sql_func *) n->data;

		if (!drop_action && mvc_check_dependency(sql, func->base.id, FUNC_DEPENDENCY))
			return sql_error(sql, 02, "DROP FUNCTION: there are functions dependent on function %s;", func->base.name);
	}
		
	mvc_drop_all_func(sql, s, list_func, drop_action);

	list_destroy(list_func);

	return stmt_none();
}

stmt *
psm(mvc *sql, symbol *s)
{
	stmt *ret = NULL;

	switch (s->token) {

	case SQL_CREATE_FUNC:
	{
		dlist *l = s->data.lval;

		ret = create_func(sql, l->h->data.lval, l->h->next->data.lval, l->h->next->next->data.sym, l->h->next->next->next->data.lval, l->h->next->next->next->next->data.lval);
		sql->type = Q_SCHEMA;
	} 	break;
	case SQL_DROP_FUNC:
	{
		dlist *l = s->data.lval;
		
		if (l->h->next->data.ival)
	                ret = drop_all_func(sql, l->h->data.lval, l->h->next->next->next->data.ival);
		else
	                ret = drop_func(sql, l->h->data.lval, l->h->next->next->data.lval, l->h->next->next->next->data.ival);
		sql->type = Q_SCHEMA;
	}	break;
	case SQL_SET:
		ret = psm_set(sql, NULL, s->data.lval->h);
		sql->type = Q_UPDATE;
		break;
	case SQL_DECLARE:
		ret = psm_declare(sql, NULL, s->data.lval->h);
		sql->type = Q_UPDATE;
		break;
	default:
		return sql_error(sql, 01, "schema statement unknown symbol(%ld)->token = %s", (long) s, token2string(s->token));
	}
	return ret;
}
