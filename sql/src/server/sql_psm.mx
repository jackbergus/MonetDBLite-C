@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2006 CWI.
@' All Rights Reserved.

@f sql_psm
@a N.J. Nes
@* 

@h
#ifndef _SQL_PSM_H_
#define _SQL_PSM_H_

#include <sql_list.h>
#include "sql_symbol.h"
#include "sql_statement.h"

extern stmt *psm(mvc *sql, symbol *sym);

#endif /* _SQL_PSM_H_ */
@c
#include "sql_psm.h"
#include "sql_select.h"
#include "sql_semantic.h"
#include "sql_privileges.h"

static stmt * sequential_block (mvc *sql, scope *scp, sql_subtype *res, dlist *blk, char *opt_name);

/* SET variable = value */

static stmt *
psm_set(mvc *sql, scope *scp, dnode *n)
{
	exp_kind ek = {type_value, card_value, FALSE};
	char *name = n->data.sval;
	symbol *val = n->next->data.sym;
	stmt *var, *r = NULL;
	int level = 0;
	sql_subtype *tpe = NULL;

	/* name can be 
		'parameter of the function' (ie in the param list)
		or a local or global variable, declared earlier
	*/

	/* check if variable is known from the stack */
	if ((var=stack_find_var(sql, name)) == NULL) {
		sql_arg *a = sql_bind_param(sql, name);

		if (!a) /* not parameter, ie local var ? */
			return sql_error(sql, 01, "Variable %s unknown", name);
		tpe = &a->type;
	} else { 
		tpe = tail_type(var);
	}

	r = sql_value_exp(sql, scp, val, NULL, NULL, sql_sel, ek);
	if (!r)
		return NULL;

	level = stack_find_frame(sql, name);
	r = check_types(sql, tpe, r, type_equal); 
	if (!r)
		return NULL;
	return stmt_assign(name, r, level);
}

static stmt *
psm_declare(mvc *sql, scope *scp, dnode *n)
{
	list *l;

	(void)scp;
	l = create_stmt_list();
	while(n) { /* list of 'identfiers with type' */
		dnode *ids = n->data.sym->data.lval->h->data.lval->h;
		sql_subtype *ctype = &n->data.sym->data.lval->h->next->data.typeval;
		while(ids) {
			char *name = ids->data.sval;
			stmt *r = NULL;

			/* check if we overwrite a scope local variable declare x; declare x; */
			if (frame_find_var(sql, name)) {
				list_destroy(l);
				return sql_error(sql, 01, 
					"Variable %s allready declared", name);
			}
			r = stmt_var(_strdup(name), ctype, 1, sql->frame );
			stack_push_var(sql, name, r);
			list_append(l, r);
			ids = ids->next;
		}
		n = n->next;
	}
	return stmt_list(l);
}

/* [ label: ]
   while (cond) do 
	statement_list
   end [ label ]
   currently we only parse the labels, they cannot be used as there is no

   support for LEAVE and ITERATE (sql multi-level break and continue)
 */
static stmt * 
psm_while_do( mvc *sql, scope *scp, sql_subtype *res, dnode *w )
{
	if (!w)
		return NULL;
	if (w->type == type_symbol) { 
		stmt *cond, *whilestmts;
		dnode *n = w;

		cond = sql_logical_exp(sql, scp, n->data.sym, NULL, NULL, sql_sel); 
		n = n->next;
		whilestmts = sequential_block(sql, scp, res, n->data.lval, n->next->data.sval);

		if (sql->session->status || !cond || !whilestmts) {
			cond_stmt_destroy(cond);
			cond_stmt_destroy(whilestmts);
			return NULL;
		}
		return stmt_while( cond, whilestmts );
	}
	return NULL;
}


/* if (cond) then statement_list
   [ elseif (cond) then statement_list ]*
   [ else statement_list ]
   end if
 */
static stmt * 
psm_if_then_else( mvc *sql, scope *scp, sql_subtype *res, dnode *elseif )
{
	if (!elseif)
		return NULL;
	if (elseif->next && elseif->type == type_symbol) { /* if or elseif */
		stmt *cond, *ifstmts, *elsestmts;
		dnode *n = elseif;

		cond = sql_logical_exp(sql, scp, n->data.sym, NULL, NULL, sql_sel); 
		n = n->next;
		ifstmts = sequential_block(sql, scp, res, n->data.lval, NULL);
		n = n->next;
		elsestmts = psm_if_then_else( sql, scp, res, n);

		if (sql->session->status || !cond || !ifstmts) {
			cond_stmt_destroy(cond);
			cond_stmt_destroy(ifstmts);
			cond_stmt_destroy(elsestmts);
			return NULL;
		}
		return stmt_if( cond, ifstmts, elsestmts);
	} else { /* else */
		symbol *e = elseif->data.sym;

		if (e==NULL || (e->token != SQL_ELSE))
			return NULL;
		return sequential_block( sql, scp, res, e->data.lval, NULL);
	}
}

/* 	1
	CASE
	WHEN search_condition THEN statements
	[ WHEN search_condition THEN statements ]
	[ ELSE statements ]
	END CASE

	2
	CASE case_value
	WHEN when_value THEN statements
	[ WHEN when_value THEN statements ]
	[ ELSE statements ]
	END CASE
 */
static stmt * 
psm_case( mvc *sql, scope *scp, sql_subtype *res, dnode *case_when )
{
	exp_kind ek = {type_value, card_value, FALSE};

	if (!case_when)
		return NULL;

	/* case 1 */
	if (case_when->type == type_symbol) {
		dnode *n = case_when;
		symbol *case_value = n->data.sym;
		dlist *when_statements = n->next->data.lval;
		dlist *else_statements = n->next->next->data.lval;
		stmt *else_stmt = NULL, *v = sql_value_exp(sql, scp, case_value, NULL, NULL, sql_sel, ek);
		stmt *cur_if = NULL, *top = NULL;

		if (!v)
			return NULL;
		if (else_statements) {
			else_stmt = sequential_block( sql, scp, res, else_statements, NULL);
			if (!else_stmt) {
				stmt_destroy(v);
				return NULL;
			}
		}
		n = when_statements->h;
		while(n) {
			dnode *m = n->data.sym->data.lval->h;
			stmt *cond=0, *when_value = sql_value_exp(sql, scp, m->data.sym, NULL, NULL, sql_sel, ek);
			stmt *if_stmts = NULL;
			stmt *case_stmt = NULL;

			if (!when_value || 
			   (cond = sql_compare(sql, stmt_dup(v), when_value, "=", sql_sel)) == NULL || 
			   (if_stmts = sequential_block( sql, scp, res, m->next->data.lval, NULL)) == NULL ) {
				stmt_destroy(v);
				cond_stmt_destroy(else_stmt);
				cond_stmt_destroy(cond);
				return NULL;
			}
			case_stmt = stmt_if(cond, if_stmts, NULL);
			if (cur_if)
				cur_if->op3.stval = case_stmt;
			cur_if = case_stmt;
			if (!top)
				top = case_stmt;
			n = n->next;
		}
		if (cur_if)
			cur_if->op3.stval = else_stmt;
		return top;
	} else { 
		/* case 2 */
		dnode *n = case_when;
		dlist *whenlist = n->data.lval;
		dlist *else_statements = n->next->data.lval;
		stmt *else_stmt = NULL, *cur_if = NULL, *top = NULL;

		if (else_statements) {
			else_stmt = sequential_block( sql, scp, res, else_statements, NULL);
			if (!else_stmt) 
				return NULL;
		}
		n = whenlist->h;
		while(n) {
			dnode *m = n->data.sym->data.lval->h;
			stmt *cond = sql_logical_exp(sql, scp, m->data.sym, NULL, NULL, sql_sel);
			stmt *if_stmts = NULL;
			stmt *case_stmt = NULL;

			if (!cond || 
			   (if_stmts = sequential_block( sql, scp, res, m->next->data.lval, NULL)) == NULL ) {
				cond_stmt_destroy(else_stmt);
				cond_stmt_destroy(cond);
				return NULL;
			}
			case_stmt = stmt_if(cond, if_stmts, NULL);
			if (cur_if)
				cur_if->op3.stval = case_stmt;
			cur_if = case_stmt;
			if (!top)
				top = case_stmt;
			n = n->next;
		}
		if (cur_if)
			cur_if->op3.stval = else_stmt;
		return top;
	}
	return NULL;
}

/* return val;
 */
static stmt * 
psm_return( mvc *sql, scope *scp, sql_subtype *restype, symbol *return_sym )
{
	exp_kind ek = {type_value, card_value, FALSE};
	stmt *res;

	if (restype->comp_type)
		ek.card = card_relation;
	res = sql_value_exp(sql, scp, return_sym, NULL, NULL, sql_sel, ek);
	if (!res || (res = check_types(sql, restype, res, type_equal)) == NULL)
		return NULL;
	return stmt_return(res);
}

static stmt *
sequential_block (mvc *sql, scope *scp, sql_subtype *restype, dlist *blk, char *opt_label) 
{
	list *l=0;
	dnode *n;

	if (blk->h)
 		l = create_stmt_list();
	stack_push_frame(sql, opt_label);
	for (n = blk->h; n; n = n->next ) {
		stmt *res = NULL;
		symbol *s = n->data.sym;
		switch (s->token) {
		case SQL_SET:
			res = psm_set(sql, scp, s->data.lval->h);
			break;
		case SQL_DECLARE:
			res = psm_declare(sql, scp, s->data.lval->h);
			break;
		case SQL_WHILE:
			res = psm_while_do(sql, scp, restype, s->data.lval->h);
			break;
		case SQL_IF:
			res = psm_if_then_else(sql, scp, restype, s->data.lval->h);
			break;
		case SQL_CASE:
			res = psm_case(sql, scp, restype, s->data.lval->h);
			break;
		case SQL_RETURN:
			/* should be last statement of a sequential_block */
			if (n->next) { 
				res = sql_error(sql, 01, 
					"Statement after return");
			} else {
				res =psm_return(sql, scp, restype, s->data.sym);
			}
			break;
		case SQL_SELECT: /* row selections (into variables) */
			res = scope_subquery(sql, scp, s);
			break;
		default:
			res = sql_error(sql, 01, 
			 "Statement '%s' is not a valid flow control statement",
			 token2string(s->token));
		}
		if (!res) {
			list_destroy(l);
			l = NULL;
			break;
		}
		list_append(l, res);
	}
	stack_pop_frame(sql);
	if (l)
		return stmt_list(l);
	return NULL;
}

static sql_subtype *
result_type(mvc *sql, char *fname, symbol *res ) 
{
	if (res->token == SQL_TYPE) {
		return &res->data.lval->h->data.typeval;
	} else if (res->token == SQL_TABLE) {

		/* here we create a new table-type */
		sql_subtype *t = NEW(sql_subtype);
		sql_table *tbl;
		dnode *n = res->data.lval->h;
		char *tnme = NEW_ARRAY(char, strlen(fname) + 2);

		tnme[0] = '#';
		strcpy(tnme+1, fname);
		tbl = mvc_create_generated(sql, sql->session->schema, tnme, NULL, 1 /* system ?*/);
		for(;n; n = n->next->next) {
			sql_subtype *ct = &n->next->data.typeval;
		    	mvc_create_column(sql, tbl, n->data.sval, ct);
		}
		_DELETE(tnme);

		sql_find_subtype(t, "table", 0, 0);
		t->comp_type = tbl;
		t->digits = tbl->base.id; /* pass the table through digits */
		return t;
	}
	return NULL;
}

static int
has_return(stmt *s )
{
	if (s->type == st_return) {
		return 1;
	} else if (s->type == st_if) {
		int res = has_return(s->op2.stval); /* ifstmts */
		if (res && s->op3.stval)
			res = has_return(s->op3.stval); /* elsestmts */
		return res;
	} else if (s->type == st_list) { /* sequential block */
		return has_return(s->op1.lval->t->data);
	}
	return 0;
}

static stmt *
create_func(mvc *sql, dlist *qname, dlist *params, symbol *res, dlist *ext_name, dlist *body)
{
	char *fname = qname_table(qname);
	char *sname = qname_schema(qname);
	sql_schema *s = NULL;
	dnode *n;
	list *l = list_create((fdestroy) &arg_destroy);
	sql_subtype *restype;
	int instantiate = (sql->mode == m_execute);

	if (sname && !(s = mvc_bind_schema(sql, sname)))
		return sql_error(sql, 02, "CREATE FUNCTION: no such schema '%s'", sname);
	if(s == NULL)
		s = cur_schema(sql);
	restype = result_type(sql, fname, res);
	
	if (!instantiate && schema_bind_func(sql, s, fname)) {
		return sql_error(sql, 02, "CREATE FUNCTION: name '%s' already in use", fname);
	
	} else if (!instantiate && !schema_privs(sql->role_id, s)) {
		return sql_error(sql, 02, "CREATE FUNCTION: insufficient privileges for user '%s' in schema '%s'", stack_get_string(sql, "user"), s->base.name);
	} else {
	 	if (params) 
			for (n = params->h; n; n = n->next) {
				dnode *an = n->data.lval->h;
	
				list_append(l, sql_create_arg(_strdup(an->data.sval), &an->next->data.typeval));
				sql_add_param(sql, an->data.sval, &an->next->data.typeval);
			}
	 	if (body) {		/* sql func */
			char *q = QUERY(sql->scanner);
			stmt *b = NULL;

			if (!(b = sequential_block(sql, NULL, restype, body, NULL ))) {
				return NULL;
			}
		
			/* check if we have a return statement */
			if (restype && !has_return(b)) 
				return sql_error(sql, 01, "Missing return statement");

			/* in execute mode we instantiate the function */
			if (instantiate) {
				return b;
			} else {
				stmt_destroy(b);
				sql_destroy_params(sql);
				mvc_create_func(sql, sql->session->schema, fname, l, restype, TRUE, FALSE, "sql_cache", q);
				/* TODO: walk the stmt tree b and find all
				   functions it depends on, and store these
				   in a functions dependency table(f_id,d_id);
				*/
			}
		} else {
			char *fmod = qname_module(ext_name);
			char *fnme = qname_fname(ext_name);
			mvc_create_func(sql, sql->session->schema, fname, l, restype, FALSE, FALSE, fmod, fnme );
		}
	}
	return stmt_none();
}

stmt* 
drop_func(mvc *sql, dlist *qname)
{
	char *name = qname_table(qname);
	char *sname = qname_schema(qname);
	sql_schema *s = NULL;
	sql_func * func;

	if (sname && !(s = mvc_bind_schema(sql, sname)))
		return sql_error(sql, 02, "DROP FUNCTION: no such schema '%s'", sname);

	if (s == NULL) 
		s =  cur_schema(sql);
	func = schema_bind_func(sql,s,name);
	if (!func && !sname) {
		s = tmp_schema(sql);
		func = schema_bind_func(sql, s, name);
	}
	if (!func)  
		return sql_error(sql, 02, "DROP FUNCTION: no such function '%s'", name);
	if (!schema_privs(sql->role_id, s)) {
		return sql_error(sql, 02, "DROP FUNCTION: access denied for %s to schema ;'%s'", stack_get_string(sql, "user"), s->base.name);
	}
	mvc_drop_func(sql, s, name, 0);

	return stmt_none();
}

stmt *
psm(mvc *sql, symbol *s)
{
	stmt *ret = NULL;

	switch (s->token) {

	case SQL_CREATE_FUNC:
	{
		dlist *l = s->data.lval;

		ret = create_func(sql, l->h->data.lval, l->h->next->data.lval, l->h->next->next->data.sym, l->h->next->next->next->data.lval, l->h->next->next->next->next->data.lval);
		sql->type = Q_SCHEMA;
	} 	break;
	case SQL_DROP_FUNC:
	{
		dlist *l = s->data.lval;

                ret = drop_func(sql, l->h->data.lval);
		sql->type = Q_SCHEMA;
	}	break;
	case SQL_SET:
		ret = psm_set(sql, NULL, s->data.lval->h);
		sql->type = Q_UPDATE;
		break;
	case SQL_DECLARE:
		ret = psm_declare(sql, NULL, s->data.lval->h);
		sql->type = Q_UPDATE;
		break;
	default:
		return sql_error(sql, 01, "schema statement unknown symbol(%ld)->token = %s", (long) s, token2string(s->token));
	}
	return ret;
}
