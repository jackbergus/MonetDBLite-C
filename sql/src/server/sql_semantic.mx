@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2005 CWI.
@' All Rights Reserved.

@f sql_semantic
@a N.J. Nes
@* 

@h
#ifndef _SQL_SEMANTIC_H_
#define _SQL_SEMANTIC_H_

#include <stdio.h>
#include <stdarg.h>
#include <sql_list.h>
#include "sql_symbol.h"
#include "sql_parser.h"
#include "sql_scope.h"

#define create_string_list() list_create((fdestroy)&GDKfree)

extern stmt *semantic(mvc *sql, symbol *sym);

extern sql_schema *cur_schema(mvc *sql);
extern sql_schema *qname_schema(mvc *sql, dlist *qname);
extern char *qname_table(dlist *qname);
extern tvar *scope_add_table_columns(mvc *sql, scope *scp, sql_table *t, char *tname, int access);

extern sql_subtype *supertype(sql_subtype *r, sql_subtype *i);
extern int convert_types(mvc *sql, stmt **L, stmt **R, int scale_fixing);

typedef enum {
	type_equal,
	type_cast,		/* also truncate */
	type_dyncheck		/* if types are equal, check 
				   the digits/scale/overflow dynamicaly */
} check_type;

extern stmt *check_types(mvc *sql, sql_subtype *ct, stmt *s, check_type tpe);
extern stmt *fix_scale(mvc *sql, sql_subtype *ct, stmt *s, int both, int always);
extern stmt *sum_scales(mvc *sql, sql_subfunc *f, stmt *ls, stmt *rs);
extern stmt *scale_algebra(mvc *sql, sql_subfunc *f, stmt *ls, stmt *rs);
extern stmt *sqlparse_intern(mvc *m, char *query);
extern stmt *scope_sqlparse(mvc *m, scope *scp, char *query);

extern stmt *first_subset(stmt *subset);

extern void sql_add_arg(mvc *sql, atom *v);	/* used in src/server/sql_parser.y */
extern void sql_add_param(mvc *sql, char *name, stmt *s);	/* used in src/server/sql_parser.y */
extern stmt *sql_bind_param(mvc *sql, char *name);
extern atom *sql_bind_arg(mvc *sql, int nr);

extern void sql_destroy_params(mvc *sql);	/* used in backend */
extern void sql_destroy_args(mvc *sql);	/* used in backend */

extern int set_type_param(sql_subtype *type, stmt *param);
extern char *symbol2string(mvc *sql, symbol *s);


#endif /*_SQL_SEMANTIC_H_*/

@c

#include "sql_parser.h"
#include "sql_symbol.h"
#include "sql_statement.h"
#include "sql_semantic.h"
#include "sql_trans.h"
#include "sql_schema.h"
#include "sql_updates.h"
#include "sql_select.h"
#include "sql_env.h"
#include "sql_sequence.h"
#include "sql_privileges.h"

#include <unistd.h>
#include <stdio.h>
#include <string.h>
#include <ctype.h>

/* 
 * For debugging purposes we need to be able to convert sql-tokens to 
 * a string representation.
 *
 *
 * !SQL ERROR <sqlerrno> : <details>
 * !SQL DEBUG  <details>
 * !SQL WARNING <details>
 * !SQL  <informative message, reserved for ...rows affected>
 *
 * Todo add insert bats used for inserts (ie should change the 
 * 	query code to use the global bats (mvc_bat) in read only mode).
 */

void
sql_add_arg(mvc *sql, atom *v)
{
	sql->args[sql->argc++] = v;
}

void
sql_add_param(mvc *sql, char *name, stmt *s)
{
	var_ *v = NEW(var_);

	v->name = name;
	v->s = s;
	sql_ref_init(&(v->ref));

	if (!sql->params)
		sql->params = list_create((fdestroy) &var_destroy);
	list_append(sql->params, v);
}

stmt *
sql_bind_param(mvc *sql, char *name)
{
	node *n;

	if (sql->params) {
		for (n = sql->params->h; n; n = n->next) {
			var_ *v = n->data;

			if (strcmp(v->name, name) == 0) {
				return stmt_dup(v->s);
			}
		}
	}
	return NULL;
}

atom *
sql_bind_arg(mvc *sql, int nr)
{
	if (nr < sql->argc)
		return sql->args[nr];
	return NULL;
}

void
sql_convert_arg(mvc *sql, int nr, sql_subtype *rt)
{
	atom *a = sql_bind_arg(sql, nr);

	if (atom_null(a)) {
		if (a->data.vtype != rt->type->localtype) {
			a->data.vtype = rt->type->localtype;
			if (ATOMstorage(a->data.vtype) < TYPE_str) {
				ptr p = ATOMnilptr(a->data.vtype);

				VALset(&a->data, a->data.vtype, p);
			} else {
				a->data.val.pval = NULL;
			}
		}
	}
	sql_subtype_destroy(a->tpe);
	a->tpe = sql_dup_subtype(rt);
}

void
sql_destroy_params(mvc *sql)
{
	if (sql->params)
		list_destroy(sql->params);
	sql->params = NULL;
}

void
sql_destroy_args(mvc *sql)
{
	int i;

	for (i=0; i < sql->argc; i++){
		atom_destroy(sql->args[i]);
	}
	sql->argc = 0;
}


sql_schema *
cur_schema(mvc *sql)
{
	return sql->trans->schema;
}

sql_schema *
qname_schema(mvc *sql, dlist *qname)
{
	sql_schema *s = cur_schema(sql);

	assert(qname && qname->h);

	if (dlist_length(qname) == 2) {
		char *name = qname->h->data.sval;

		s = mvc_bind_schema(sql, name);
	}
	return s;
}

char *
qname_table(dlist *qname)
{
	assert(qname && qname->h);

	if (dlist_length(qname) == 1) {
		return qname->h->data.sval;
	} else if (dlist_length(qname) == 2) {
		return qname->h->next->data.sval;
	}
	return "unknown";
}

stmt *
scope_sqlparse(mvc *m, scope *scp, char *query)
{
	mvc o = *m;
	stmt *sq;
	buffer *b;
	char *n;
	int len = strlen(query);

	m->qc = NULL;

	m->cache = 0;

	b = (buffer*)GDKmalloc(sizeof(buffer));
	n = GDKmalloc(len + 1 + 1);
	strncpy(n, query, len);
	query = n;
	query[len] = '\n';
	query[len+1] = 0;
	len++;
	buffer_init(b, query, len);
	scanner_init( &m->scanner, 
		bstream_create(buffer_rastream(b, "sqlstatement"), b->len),
		NULL);
	m->scanner.mode = LINE_1; 
	bstream_next(m->scanner.rs);

	m->params = NULL;
	m->argc = 0;
	m->sym = NULL;
	m->errstr[0] = '\0';
	m->status = 0;

	(void) sqlparse(m);	/* blindly ignore errors */
	sq = sql_subquery(m, scp, m->sym, 1);

	GDKfree(query);
	GDKfree(b);
	bstream_destroy(m->scanner.rs);

	m->sym = NULL;
	if (m->status || m->errstr[0]) {
		int status = m->status;
		char errstr[ERRSIZE];

		strcpy(errstr, m->errstr);
		*m = o;
		m->status = status;
		strcpy(m->errstr, errstr);
	} else {
		*m = o;
	}
	return sq;
}

stmt *
sqlparse_intern(mvc *m, char *query)
{
	mvc o = *m;
	stmt *sq;
	buffer *b;
	char *n;
	int len = strlen(query);

	m->qc = NULL;

	m->cache = 0;

	b = (buffer*)GDKmalloc(sizeof(buffer));
	n = GDKmalloc(len + 1 + 1);
	strncpy(n, query, len);
	query = n;
	query[len] = '\n';
	query[len+1] = 0;
	len++;
	buffer_init(b, query, len);
	scanner_init( &m->scanner, 
		bstream_create(buffer_rastream(b, "sqlstatement"), b->len),
		NULL);
	m->scanner.mode = LINE_1; 
	bstream_next(m->scanner.rs);

	m->params = NULL;
	m->argc = 0;
	m->sym = NULL;
	m->errstr[0] = '\0';
	m->status = 0;
	/* via views we give access to protected objects */
	m->user_id = USER_MONETDB;

	(void) sqlparse(m);	/* blindly ignore errors */
	sq = scope_subquery(m, NULL, m->sym);

	GDKfree(query);
	GDKfree(b);
	bstream_destroy(m->scanner.rs);

	m->sym = NULL;
	if (m->status || m->errstr[0]) {
		int status = m->status;
		char errstr[ERRSIZE];

		strcpy(errstr, m->errstr);
		*m = o;
		m->status = status;
		strcpy(m->errstr, errstr);
	} else {
		*m = o;
	}
	return sq;
}

tvar *
scope_add_table_columns(mvc *sql, scope *scp, sql_table *t, char *tname, int access)
{
	node *n, *m;
	tvar *tv = NULL;

	if (!t->table && t->query) {

		stmt *sq = sqlparse_intern(sql, t->query);

		if (!sq)
			return NULL;
		tv = scope_add_table(scp, sq, tname, NULL);
		for (n = t->columns.set->h, m = sq->op1.lval->h; n && m; n = n->next, m = m->next) {
			sql_column *c = n->data;
			stmt *sc = stmt_dup(m->data);

			sc = stmt_alias(sc, _strdup(tname), _strdup(c->base.name));
			sc = stmt_column(sc, stmt_dup(sq));
			table_add_column(tv, sc, NULL, c->base.name);
		}
	} else {
		stmt *ts;

		tv = scope_add_table(scp, ts = stmt_basetable(t, tname), tname, t);
		for (n = t->columns.set->h; n; n = n->next) {
			sql_column *c = n->data;
			stmt *sc = stmt_cbat(c, stmt_dup(ts), access, st_bat);

			table_add_column(tv, sc, NULL, c->base.name);
		}
	}
	return tv;
}

static lng
scale2value(int scale)
{
	lng val = 1;

	if (scale < 0)
		scale = -scale;
	for (; scale; scale--) {
		val = val * 10;
	}
	return val;
}

stmt *
sum_scales(mvc *sql, sql_subfunc *f, stmt *ls, stmt *rs)
{
	if (strcmp(f->func->imp, "*") == 0 && 
	    f->func->res->type->scale == SCALE_FIX) {
		sql_subtype *t = NULL;
		sql_subtype *lt = tail_type(ls);
		sql_subtype *rt = tail_type(rs);

		f->res->scale = lt->scale + rt->scale;
		f->res->digits = lt->digits + rt->digits;
		/* HACK alert: digits should be less then max */
		if (f->res->type->radix == 10 && f->res->digits > 19)
			f->res->digits = 19;
		if (f->res->type->radix == 2 && f->res->digits > 53)
			f->res->digits = 53;
		/* sum of digits may mean we need a bigger result type 
		 * as the function don't support this we need to
		 * make bigger input types!
		 */

		/* numeric types are fixed length */
		if (f->res->type->eclass == EC_NUM) {
			t = sql_bind_numeric(f->res->type->localtype, f->res->digits);
		} else {
			t = sql_bind_subtype(f->res->type->sqlname, f->res->digits, f->res->scale);
		}
		if (type_cmp(t->type, f->res->type) != 0) { 
			/* do we need to convert to the a larger localtype 
			   int * int may not fit in an int, so we need to 
			   convert to lng * int.
			 */
			sql_subtype *nlt = sql_create_subtype(t->type, 
				f->res->digits, lt->scale);
			ls = check_types( sql, nlt, ls, type_equal);
			sql_subtype_destroy(nlt);
		}
		sql_subtype_destroy(f->res);
		f->res = t;
	}
	return ls;
}

stmt *
scale_algebra(mvc *sql, sql_subfunc *f, stmt *ls, stmt *rs)
{
	sql_subtype *lt = tail_type(ls);
	sql_subtype *rt = tail_type(rs);

	/*
	 * Decimals are mapped on plain integers. This has impact on the
	 * implemantion of division. First the 'dividend' should be large 
	 * enough to prevent rounding errors. This is solved by a 
	 * multiplication with the 'scale' of the divisor.
	 * Second the result type of the division should be equal to the 
	 * 'dividend', with the maximum scale of the dividend and divisor.
	 *
	 * Example      1.0/0.1 mapped (int 1 dec(1,0) and int 1 dec(2,1))
	 *                              1 * 10 = 10 (scale of divisor)
	 *                              10/1 = 1 dec(1)
	 */

	if (lt->type->scale == SCALE_FIX && rt->scale && 
		strcmp(f->func->imp, "/") == 0) {
		int digits = rt->scale + lt->digits;
		sql_subtype *nlt;

		/* HACK alert: digits should be less then max */
		if (f->res->type->radix == 10 && digits > 19)
			digits = 19;
		if (f->res->type->radix == 2 && digits > 53)
			digits = 53;

		/* scale fixing may require a larger type ! */
		nlt = sql_bind_subtype(lt->type->sqlname, digits, lt->scale+rt->scale);
		f->res->digits = digits;
		f->res->scale = lt->scale;
		
		ls = check_types( sql, nlt, ls, type_equal );
		sql_subtype_destroy(nlt);
	}
	return ls;
}

stmt *
fix_scale(mvc *sql, sql_subtype *ct, stmt *s, int both, int always)
{
	sql_subtype *st = tail_type(s);

	(void) sql;		/* Stefan: unused!? */

	if (ct->type->scale == SCALE_FIX && st->type->scale == SCALE_FIX) {
		int scale_diff = ((int) ct->scale - (int) st->scale);

		if (scale_diff) {
			sql_subtype *it = sql_bind_localtype(st->type->base.name);
			sql_subfunc *c = NULL;

			if (scale_diff < 0) {
				if (!both)
					return s;
				c = sql_bind_func(sql->trans->module, "scale_down", st, it);
			} else {
				c = sql_bind_func(sql->trans->module, "scale_up", st, it);
			}
			if (c) {
				lng val = scale2value(scale_diff);
				atom *a = atom_int(sql_dup_subtype(it), val);

				c->res->scale = (st->scale + scale_diff);
				return stmt_binop(s, stmt_atom(a), c);
			}
		}
	} else if (always && st->scale) {	/* scale down */
		int scale_diff = -(int) st->scale;
		sql_subtype *it = sql_bind_localtype(st->type->base.name);
		sql_subfunc *c = sql_bind_func(sql->trans->module, "scale_down", st, it);

		if (c) {
			lng val = scale2value(scale_diff);
			atom *a = atom_int(sql_dup_subtype(it), val);

			c->res->scale = 0;
			return stmt_binop(s, stmt_atom(a), c);
		} else {
			printf("scale_down mising (%s)\n", st->type->base.name);
		}
	}
	return s;
}

/* try to do an inplace convertion 
 * 
 * inplace conversion is only possible if the s is an variable.
 * This is only done to be able to map more cached queries onto the same 
 * interface.
 */
stmt *
inplace_convert(mvc *sql, sql_subtype *ct, stmt *s)
{
	sql_subtype *st = tail_type(s);

	if (s->type != st_var || s->ref.refcnt > 1 || ct->scale)
		return s;

	if (ct->digits == 0 || ct->type->radix == 2 || 
	   (ct->digits > 0 && st->digits < ct->digits)) {
		stmt *r = s;

		if (ct->type->localtype == st->type->localtype) {
			if (ct->type->localtype == TYPE_lng || ct->type->localtype == TYPE_int || ct->type->localtype == TYPE_sht) {
				r = stmt_varnr(s->flag, sql_dup_subtype(ct));
				sql_convert_arg(sql, s->flag, ct);
			} else if (ct->type->localtype == TYPE_str) {
				sql_subtype *nt = sql_create_subtype(st->type, ct->digits, ct->scale);

				r = stmt_varnr(s->flag, nt);
				sql_convert_arg(sql, s->flag, nt);
			}
		} else if (st->type->localtype == TYPE_str) {
			atom *a = sql_bind_arg(sql, s->flag);

			if (atom_null(a)) {
				r = stmt_varnr(s->flag, sql_dup_subtype(ct));
				sql_convert_arg(sql, s->flag, ct);
			}
		}
		if (r != s)
			stmt_destroy(s);
		return r;
	}
	return s;
}

/* check_types tries to match the ct type with the type of s if they don't
 * match s is converted. Returns NULL on failure.
 */
stmt *
check_types(mvc *sql, sql_subtype *ct, stmt *s, check_type tpe)
{
	int c = 0;
	sql_subtype *t = NULL, *st = tail_type(s);

	(void)tpe;
	if (!st && set_type_param(ct, s) == 0) {
		return s;
	} else if (!st) {
	        stmt_destroy(s);
                return sql_error(sql, 02, "statement has no type information");
	}

	/* first try cheap internal (inplace) convertions ! */
	s = inplace_convert(sql, ct, s);
	t = st = tail_type(s);

	/* check if the types are the same */
	if (t && subtype_cmp(t, ct) != 0) {
		t = NULL;
	}

	if (!t) {	/* try to convert if needed */
		sql_subtype *nt;
		c = sql_type_convert(st->type->eclass, ct->type->eclass);
		if (!c) { 
			stmt_destroy(s);
			s = NULL;
		} else {
			nt = sql_dup_subtype(ct);
			s = stmt_convert(s, sql_dup_subtype(st), nt);
		}
	} 
	if (!s) {
		stmt *res = sql_error(
			sql, 03,
			"types %s(%d,%d) (%s) and %s(%d,%d) (%s) are not equal",
			st->type->sqlname,
			st->digits,
			st->scale,
			st->type->base.name,
			ct->type->sqlname,
			ct->digits,
			ct->scale,
			ct->type->base.name
		);
		return res;
	}
	return s;
}

sql_subtype *
supertype(sql_subtype *r, sql_subtype *i)
{
	/* first find super type */
	char *tpe = r->type->sqlname;
	int radix = r->type->radix;
	int digits = 0;
	int idigits = i->digits;
	int rdigits = r->digits;
	unsigned int scale = sql_max(i->scale, r->scale);

	if (i->type->base.id >r->type->base.id) {
		tpe = i->type->sqlname;
		radix = i->type->radix;
	}
	/* 
	 * Incase of different radix we should change one. 
	 */
	if (i->type->radix != r->type->radix) {
		if (radix == 10 || radix == 0 /* strings */) {
			/* change to radix 10 */
			if (i->type->radix == 2)
				idigits = bits2digits(idigits);
			if (r->type->radix == 2)
				rdigits = bits2digits(rdigits);
		} else if (radix == 2) { /* change to radix 2 */
			if (i->type->radix == 10)
				idigits = digits2bits(idigits);
			if (r->type->radix == 10)
				rdigits = digits2bits(rdigits);
		}
	}
	if (idigits && rdigits) {
		if (idigits > rdigits) {
			digits = idigits;
			if (i->scale < scale)
				digits += scale - i->scale;
		} else if (idigits < rdigits) {
			digits = rdigits;
			if (r->scale < scale)
				digits += scale - r->scale;
		} else {
			/* same number of digits */
			digits = idigits;
			if (i->scale < r->scale)
				digits += r->scale - i->scale;
			else
				digits += i->scale - r->scale;
		}
	}

	return sql_bind_subtype(tpe, digits, scale);
}

int
set_type_param(sql_subtype *type, stmt *param)
{
	if (!type || !param || param->type != st_var)
		return -1;

	param->op2.typeval = sql_dup_subtype(type);
	return 0;
}

/* convert_types convert both the stmt's L and R such that they get
 * matching types. On failure <0 is returned;
 */
int
convert_types(mvc *sql, stmt **L, stmt **R, int scale_fixing)
{
	stmt *ls = *L;
	stmt *rs = *R;
	sql_subtype *lt = tail_type(ls);
	sql_subtype *rt = tail_type(rs);

	if (!rt && !lt) {
		sql_error(sql, 01, "Cannot have a parameter (?) on both sides of an expression");
		return -1;
	}

	if (rt && !lt)
		return set_type_param(rt, ls);

	if (!rt && lt)
		return set_type_param(lt, rs);

	if (rt && lt) {
		sql_subtype *i = lt;
		sql_subtype *r = rt;

		if (subtype_cmp(lt, rt) != 0) {
			sql_subtype *super = supertype(r, i);

			if (scale_fixing) {
				/* convert ls to super type */
				ls = check_types(sql, super, ls, type_equal);
				/* convert rs to super type */
				rs = check_types(sql, super, rs, type_equal);
			} else {
				/* convert ls to super type */
				super->scale = lt->scale;
				ls = check_types(sql, super, ls, type_equal);
				/* convert rs to super type */
				super->scale = rt->scale;
				rs = check_types(sql, super, rs, type_equal);
			}
			sql_subtype_destroy(super);
		/*
		} else if (scale_fixing) {
			ls = fix_scale(sql, r, ls, 0, 0);
			rs = fix_scale(sql, i, rs, 0, 0);
		*/
		}
		*L = ls;
		*R = rs;
		if (!ls || !rs) {
			return -1;
		}
		return 0;
	}
	return -1;
}

stmt *
first_subset(stmt *subset)
{
	node *n;

	assert(subset->type == st_ptable);

	n = ptable_pivots(subset)->h;
	if (n)
		return stmt_dup(n->data);
	return NULL;
}

char *symbol2string(mvc *sql, symbol *se)
{
	int len = 0;
	char buf[BUFSIZ];

	buf[0] = 0;
	switch (se->token) {
	case SQL_NOP: {
		dnode *lst = se->data.lval->h;
		dnode *ops = lst->next->data.lval->h;
		char *op = lst->data.sval;

		len = snprintf( buf+len, BUFSIZ-len, "%s(", op); 
		for (; ops; ops = ops->next) {
			char *tmp;
			len = snprintf( buf+len, BUFSIZ-len, "%s%s", 
				tmp = symbol2string(sql, ops->data.sym), 
				(ops->next)?",":"");
			_DELETE(tmp);
		}
		len = snprintf( buf+len, BUFSIZ-len, ")"); 
	} break;
	case SQL_BINOP: {
		dnode *lst = se->data.lval->h;
		char *op = lst->data.sval;
		char *l = symbol2string(sql, lst->next->data.sym);
		char *r = symbol2string(sql, lst->next->next->data.sym);
		len = snprintf( buf+len, BUFSIZ-len, "%s(%s,%s)", op, l, r); 
		_DELETE(l);
		_DELETE(r);
	} break;
	case SQL_OP: {
		dnode *lst = se->data.lval->h;
		char *op = lst->data.sval;
		len = snprintf( buf+len, BUFSIZ-len, "%s()", op ); 
	} break;
	case SQL_UNOP: {
		dnode *lst = se->data.lval->h;
		char *op = lst->data.sval;
		char *l = symbol2string(sql, lst->next->data.sym);
		len = snprintf( buf+len, BUFSIZ-len, "%s(%s)", op, l); 
		_DELETE(l);
	}
	case SQL_NULL:
		strcpy(buf,"NULL");
		break;
	case SQL_ATOM:{
		AtomNode *an = (AtomNode *) se;
		return atom2sql(an->a);
	}
	case SQL_NEXT:{
		char *seq = se->data.sval;
		len = snprintf( buf+len, BUFSIZ-len, "next value for %s", seq); 
	}	break;
	case SQL_COLUMN: {
		/* can only be variables */ 
		dlist *l = se->data.lval;
		if (dlist_length(l) == 1 && l->h->type == type_int) {
			atom *a = sql_bind_arg(sql, l->h->data.ival);
			return atom2sql(a);
		}
		return NULL;
	} 	
	case SQL_AGGR:
	case SQL_SELECT:
	case SQL_PARAMETER:
	case SQL_CASE:
	case SQL_COALESCE:
	case SQL_NULLIF:
	case SQL_CAST:
	default:
		return NULL;
	}
	return _strdup(buf);
}


stmt *
semantic(mvc *sql, symbol *s)
{
	stmt *res = NULL;

	if (!s)
		return NULL;

	switch (s->token) {

	case TR_COMMIT:
	case TR_SAVEPOINT:
	case TR_RELEASE:
	case TR_ROLLBACK:
	case TR_START:
	case TR_MODE:
		return transactions(sql, s);

	case SQL_CREATE_SCHEMA:
	case SQL_DROP_SCHEMA:
	case SQL_CREATE_TABLE:
	case SQL_DROP_TABLE:
	case SQL_ALTER_TABLE:
	case SQL_CREATE_VIEW:
	case SQL_DROP_VIEW:
	case SQL_CREATE_INDEX:
	case SQL_DROP_INDEX:
	case SQL_CREATE_USER:
	case SQL_DROP_USER:
	case SQL_ALTER_USER:
	case SQL_CREATE_ROLE:
	case SQL_DROP_ROLE:
	case SQL_GRANT_ROLES:
	case SQL_GRANT:
	case SQL_REVOKE:
	case SQL_CREATE_MODULE:
	case SQL_DROP_MODULE:
	case SQL_CREATE_TYPE:
	case SQL_CREATE_FUNC:
		return schemas(sql, s);

	case SQL_CREATE_SEQ:
	case SQL_DROP_SEQ:
		return sequences(sql, s);

	case SQL_COPYFROM:
	case SQL_INSERT:
	case SQL_UPDATE:
	case SQL_DELETE:
		return updates(sql, s);

	case SQL_DECLARE:
	case SQL_SET:
		return env(sql, s);

	case SQL_SELECT:
	case SQL_JOIN:
	case SQL_CROSS:
	case SQL_UNION:
	case SQL_EXCEPT:
	case SQL_INTERSECT:
		return selects(sql, s);

	case SQL_PREP:
	case SQL_MULSTMT:
	{
		dnode *d;
		list *l = create_stmt_list();

		for (d = s->data.lval->h; d; d = d->next) {
			symbol *sym = d->data.sym;
			stmt *st = semantic(sql, sym);

			if (!st) {
				list_destroy(l);
				return NULL;
			}
			list_append(l, st);
		}
		return stmt_list(l);
	}

	default:
		return sql_error(sql, 01, "sql_stmt symbol(%ld)->token = %s", (long) s, token2string(s->token));
	}
	return res;
}
