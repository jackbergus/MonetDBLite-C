@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2008 CWI.
@' All Rights Reserved.

@f rel_optimizer
@a N.J. Nes
@* 

@h
#ifndef _REL_OPTIMIZER_H_
#define _REL_OPTIMIZER_H_

#include "rel_semantic.h"

extern sql_rel * rel_optimizer(mvc *sql, sql_rel *rel);

#endif /*_REL_OPTIMIZER_H_*/
@c

//#define DEBUG

#include "sql_config.h"
#include "rel_optimizer.h"
#include "rel_select.h"
#include "rel_prop.h"
#include "rel_exp.h"
#include "rel_dump.h"

typedef struct global_props {
	int cnt[MAXOPS];
} global_props;

typedef sql_rel *(*rewrite_fptr)(mvc *sql, sql_rel *rel);
typedef int (*find_prop_fptr)(mvc *sql, sql_rel *rel);

/* The important task of the relational optimizer is to optimize the
   join order. 

   The current implementation chooses the join order based on 
   select counts, ie if one of the join sides has been reduced using
   a select this join is choosen over one without such selections. 
 */

/* currently we only find simple column expressions */
static sql_column *
name_find_column( sql_rel *rel, char *rname, char *name ) 
{
	sql_exp *alias = NULL;
	sql_column *c = NULL;

	switch (rel->op) {
	case op_basetable: {
		node *cn;
		sql_table *t = rel->l;
		if (rname) {
			if (rel->name && strcmp(rname, rel->name) != 0)
				return NULL;
			else if (!rel->name && strcmp(rname, t->base.name) != 0)
				return NULL;
		}
		if (rel->exps) {
			sql_exp *rename = exps_bind_column(rel->exps, name);
			if (!rename ||
			     rename->type != e_column ||
			    (rename->l && strcmp(t->base.name, rename->l) != 0))
				return NULL;
			name = rename->r;
		}
		for (cn = t->columns.set->h; cn; cn = cn->next) {
			sql_column *c = cn->data;
			if (strcmp(c->base.name, name) == 0) {
				return c;
			}
		}
	}
	case op_table:
		if (rname && rel->name && strcmp(rname, rel->name) != 0)
			return NULL;
		if (rel->exps)
			alias = exps_bind_column(rel->exps, name);
		/* table func */
		return NULL;
	case op_join: 
	case op_left: 
	case op_right: 
	case op_full: 
	case op_semi: 
	case op_anti: 
		/* first right (possible subquery) */
		c = name_find_column( rel->r, rname, name);
		if (!c) 
			c = name_find_column( rel->l, rname, name);
		return c;
	case op_select: 
	case op_union: 
	case op_inter: 
	case op_except: 
	case op_topn: 
		return name_find_column( rel->l, rname, name);
	case op_project:
	case op_groupby: 
		if (!rel->exps)
			break;
		if (rel->name && rname) { /* both have relation names */
			if (strcmp(rel->name, rname) != 0) 
				break;
			alias = exps_bind_column(rel->exps, name);
		/*
		} else if (rname) {
			alias = exps_bind_column2(rel->exps, rname, name);
		*/
		} else {
			alias = exps_bind_column(rel->exps, name);
		}
		break;
	}
	if (alias) { /* we found an expression with the correct name, but
			we need sql_columns */
		if (alias->type == e_column) /* real alias */
			return name_find_column( rel->l, alias->l, alias->r );
	}
	return NULL;
}

static sql_column *
exp_find_column( sql_rel *rel, sql_exp *exp )
{
	(void)rel;
	if (exp->type == e_column) { 
		return name_find_column(rel, exp->l, exp->r);
	}
	return NULL;
}

static int
join_properties(sql_rel *rel) 
{
	if (rel->exps) {
		list *join_cols = list_create(NULL);
		node *en;

		/* simply using the expressions should also work ! */
		for ( en = rel->exps->h; en; en = en->next ) {
			sql_exp *e = en->data;

			if (e->type == e_cmp && e->flag == cmp_equal) {
				sql_column *lc = exp_find_column(rel, e->l); 
				sql_column *rc = exp_find_column(rel, e->r); 

				if (lc && rc) {
					append(join_cols, lc);
					append(join_cols, rc);
				}
			}
		}
#ifdef DEBUG
		for (en = join_cols->h; en; en = en->next) {
			sql_column *c = en->data;
			printf("j col %s %s\n", c->t->base.name, c->base.name);
		}
#endif
		list_destroy(join_cols);
	}
	return 0;
}

static void
rel_properties(mvc *sql, global_props *gp, sql_rel *rel) 
{
	gp->cnt[(int)rel->op]++;
	switch (rel->op) {
	case op_basetable:
	case op_table:
		break;
	case op_join: 
	case op_left: 
	case op_right: 
	case op_full: 

	case op_semi: 
	case op_anti: 

	case op_union: 
	case op_inter: 
	case op_except: 
		rel_properties(sql, gp, rel->l);
		rel_properties(sql, gp, rel->r);
		break;
	case op_project:
	case op_select: 
	case op_groupby: 
	case op_topn: 
		if (rel->l)
			rel_properties(sql, gp, rel->l);
		break;
	}

	switch (rel->op) {
	case op_basetable:
	case op_table:
		rel->p = prop_create(PROP_COUNT, rel->p);
		break;
	case op_join: 
		join_properties(rel);
		break;
	case op_left: 
	case op_right: 
	case op_full: 

	case op_semi: 
	case op_anti: 

	case op_union: 
	case op_inter: 
	case op_except: 
		break;

	case op_project:
	case op_groupby: 
	case op_topn: 
	case op_select: 
		/* propagate relation names */
		if (!rel->name && rel->l) {
			sql_rel *l = rel->l;
			if (l->name)
				rel->name = _strdup(l->name);
		}
		break;
	}
}

static void
get_tables(mvc *sql, sql_rel *rel, list *tables) 
{
	switch (rel->op) {
	case op_basetable:
	case op_table:
		append(tables, rel);
		break;
	case op_join: 
	case op_left: 
	case op_right: 
	case op_full: 
	case op_semi: 
	case op_anti: 
	case op_union: 
	case op_inter: 
	case op_except: 
		get_tables(sql, rel->l, tables);
		get_tables(sql, rel->r, tables);
		break;
	case op_project:
	case op_select: 
	case op_groupby: 
	case op_topn: 
		get_tables(sql, rel->l, tables);
		break;
	}
}

static void
get_relations(sql_rel *rel, list *rels)
{
	if (rel->op == op_join) {
		assert(rel->exps == NULL);
		get_relations(rel->l, rels);
		get_relations(rel->r, rels);
		rel->l = NULL;
		rel->r = NULL;
		rel_destroy(rel);
	} else {
		append(rels, rel);
	}
}

static int
exp_count(int *cnt, int seqnr, sql_exp *e) 
{
	(void)seqnr;
	if (!e)
		return 0;
	if (find_prop(e->p, PROP_JOINIDX))
		*cnt += 100;
	switch(e->type) {
	case e_cmp:
		switch (e->flag) {
		case cmp_equal:
			*cnt += 20;
			return 20;
		case cmp_notequal:
			*cnt += 10;
			return 10;
		case cmp_gt:
		case cmp_gte:
		case cmp_lt:
		case cmp_lte:
			*cnt += 4;
			return 4;
		case cmp_like:
		case cmp_notlike:
			*cnt += 2;
			return 2;
		default:
			return 0;
		}
	default:
		return -5;
	}
	return -5;
}

static int
exp_keyvalue(sql_exp *e) 
{
	int cnt = 0;
	exp_count(&cnt, 0, e);
	return cnt;
}

static int
rel_has_exp(sql_rel *rel, sql_exp *e) 
{
	if (rel_find_exp(rel, e) != NULL) 
		return 0;
	return -1;
}

static sql_rel *
find_rel(list *rels, sql_exp *e)
{
	node *n = list_find(rels, e, (fcmp)&rel_has_exp);
	if (n) 
		return n->data;
	return NULL;
}

static int
joinexp_cmp(list *rels, sql_exp *h, sql_exp *key)
{
	sql_rel *h_l = find_rel(rels, h->l);
	sql_rel *h_r = find_rel(rels, h->r);
	sql_rel *key_l = find_rel(rels, key->l);
	sql_rel *key_r  = find_rel(rels, key->r);

	assert (h->type == e_cmp && key->type == e_cmp);
	assert (h_l && h_r && key_l && key_r);
	if (h_l == key_l && h_r == key_r)
		return 0;
	if (h_r == key_l && h_l == key_r)
		return 0;
        return -1;
}

static sql_exp *
joinexp_col(sql_exp *e, sql_rel *r)
{
	if (e->type == e_cmp) {
		if (rel_has_exp(r, e->l) >= 0) 
			return exp_dup(e->l);
		return exp_dup(e->r);
	}
	assert(0);
	return NULL;
}

static sql_column *
table_colexp(sql_exp *e, sql_rel *r)
{
	sql_table *t = r->l;

	if (e->type == e_column) {
		char *name = e->name;
		node *cn;

		if (r->exps) { /* use alias */
			for (cn = r->exps->h; cn; cn = cn->next) {
				sql_exp *ce = cn->data;
				if (strcmp(ce->name, name) == 0) {
					name = ce->r;
					break;
				}
			}
		}
		for (cn = t->columns.set->h; cn; cn = cn->next) {
			sql_column *c = cn->data;
			if (strcmp(c->base.name, name) == 0) 
				return c;
		}
	}
	return NULL;
}

static int
exp_joins_rels(sql_exp *e, list *rels)
{
	sql_rel *l, *r;

	assert (e->type == e_cmp);
		
	l = find_rel(rels, e->l);
	r = find_rel(rels, e->r);
	if (l && r)
		return 0;
	return -1;
}

static list *
matching_joins(list *rels, list *exps, sql_exp *je) 
{
	sql_rel *l, *r;

	assert (je->type == e_cmp);
		
	l = find_rel(rels, je->l);
	r = find_rel(rels, je->r);
	if (l && r) {
		list *res;
		list *n_rels = list_create(NULL);	

		append(n_rels, l);
		append(n_rels, r);
		res = list_select(exps, n_rels, (fcmp) &exp_joins_rels, (fdup)exp_dup);
		list_destroy(n_rels);
		return res; 
	}
	return list_create(NULL);
}

static int
sql_column_kc_cmp(sql_column *c, sql_kc *kc)
{
	/* return on equality */
	return (c->colnr - kc->c->colnr);
}

static sql_idx *
find_fk_index(sql_table *l, list *lcols, sql_table *r, list *rcols)
{
	if (l->idxs.set) {
		node *in;
	   	for(in = l->idxs.set->h; in; in = in->next){
	    		sql_idx *li = in->data;
			if (li->type == join_idx) {
		        	sql_idx *ri = ((sql_fkey*)li->key)->rkey->k.idx;
				fcmp cmp = (fcmp)&sql_column_kc_cmp;

              			if (ri->t == r && 
				    list_match(lcols, li->columns, cmp) == 0 &&
				    list_match(rcols, ri->columns, cmp) == 0) {
					return li;
				}
			}
		}
	}
	return NULL;
}

static sql_rel *
find_basetable( sql_rel *r)
{
	if (!r)
		return NULL;
	switch(r->op) {
	case op_basetable:	
		return r;
	case op_select:
		return find_basetable(r->l);
	default:
		return NULL;
	}
}

static sql_rel *
order_joins(list *rels, list *exps)
{
	sql_rel *top = NULL, *l, *r;
	sql_exp *cje;
	node *djn;
	list *sdje, *n_rels = list_create(NULL);
	int fnd;

	/* first find the distinct join expressions */
	list *aje = list_select(exps, (void*)1, (fcmp) &exp_is_join, (fdup)exp_dup);
	list *dje = list_distinct2(aje, rels, (fcmp2) &joinexp_cmp, (fdup)exp_dup);

	for(djn=dje->h; djn; djn = djn->next) {
		/* equal join expressions */
		sql_idx *idx = NULL;
		sql_exp *je = djn->data, *le = je->l, *re = je->r; 

		if (!find_prop(je->p, PROP_JOINIDX)) {
			int swapped = 0;
			list *aaje = matching_joins(rels, aje, je);
			list *eje = list_select(aaje, (void*)1, (fcmp) &exp_is_eqjoin, (fdup) &exp_dup);
			sql_rel *lr = find_rel(rels, le);
			sql_rel *rr = find_rel(rels, re);

			sql_table *l, *r;
			list *lexps = list_map(eje, lr, (fmap) &joinexp_col);
			list *rexps = list_map(eje, rr, (fmap) &joinexp_col);
			list *lcols, *rcols;

			lr = find_basetable(lr);
			rr = find_basetable(rr);
			if (!lr || !rr) {
				list_destroy(lexps);
				list_destroy(rexps);
				list_destroy(eje);
				list_destroy(aaje);
				continue;
			}
			l = lr->l;
			r = rr->l;
			lcols = list_map(lexps, lr, (fmap) &table_colexp);
			rcols = list_map(rexps, rr, (fmap) &table_colexp);
			list_destroy(lexps);
			list_destroy(rexps);
			if (list_length(lcols) != list_length(rcols)) {
				lcols->destroy = NULL;
				rcols->destroy = NULL;
				list_destroy(lcols);
				list_destroy(rcols);
				list_destroy(eje);
				list_destroy(aaje);
				continue;
			}

			idx = find_fk_index(l, lcols, r, rcols); 
			if (!idx) {
				idx = find_fk_index(r, rcols, l, lcols); 
				swapped = 1;
			} 

#ifdef DEBUG
			printf("%s %d %s %d (%d)\n", 
				l->base.name, list_length(lcols),
				r->base.name, list_length(rcols),
				idx?1:0);
#endif
			if (idx) { 	
				prop *p;
				node *n;
	
				/* Remove all other join expressions */
				for (n = eje->h; n; n = n->next) {
					if (je != n->data)
						list_remove_data(exps, n->data);
				}
				/* Add the join index using PROP_JOINIDX  */
				if (swapped) {
					sql_exp *s = je->l;
					je->l = je->r;
					je->r = s;
				}
				je->p = p = prop_create(PROP_JOINIDX, je->p);
				p->value = idx;
			}
			lcols->destroy = NULL;
			rcols->destroy = NULL;
			list_destroy(lcols);
			list_destroy(rcols);
			list_destroy(eje);
			list_destroy(aaje);
		}
	}
	list_destroy(aje);

	/* sort expressions on weighted number of reducing operators */
	sdje = list_sort(dje, (fkeyvalue)&exp_keyvalue, (fdup)&exp_dup);
	list_destroy(dje);

	/* get the first expression */
	cje = sdje->h->data;
	list_remove_data(sdje, cje);
	list_remove_data(exps, cje);

	/* find the involved relations */
	l = find_rel(rels, cje->l);
	r = find_rel(rels, cje->r);
	list_remove_data(rels, l);
	list_remove_data(rels, r);
	list_append(n_rels, l);
	list_append(n_rels, r);

	/* Create a relation between l and r. Since the calling 
	   functions rewrote the join tree, into a list of expressions 
	   and a list of (simple) relations, there are no outer joins 
	   involved, we can simply do a crossproduct here.
	 */
	top = rel_crossproduct(l, r, op_join);
	rel_join_add_exp(top, exp_dup(cje));

	/* all other join expressions on these 2 relations */
	while((djn = list_find(exps, n_rels, (fcmp)&exp_joins_rels)) != NULL) {
		sql_exp *e = djn->data;

		rel_join_add_exp(top, exp_dup(e));
		list_remove_data(exps, e);
	}
	/* Remove other joins on the current 'n_rels' 
	   set in the distinct list too */
	while((djn = list_find(sdje, n_rels, (fcmp)&exp_joins_rels)) != NULL) 
		list_remove_data(sdje, djn->data);

	/* build join tree using the ordered list */
	fnd = 1;
	while(list_length(exps) && fnd) {
		fnd = 0;
		/* find the first expression which could be added */
		for(djn = sdje->h; djn && !fnd; djn = djn->next) {
			node *ln, *rn, *en;
			
			cje = djn->data;
			ln = list_find(n_rels, cje->l, (fcmp)&rel_has_exp);
			rn = list_find(n_rels, cje->r, (fcmp)&rel_has_exp);

			if (ln || rn) {
				/* remove the expression from the lists */
				list_remove_data(sdje, cje);
				list_remove_data(exps, cje);
			}
			if (ln && rn) {
				assert(0);
				/* create a selection on the current */
				l = ln->data;
				r = rn->data;
				rel_join_add_exp(top, exp_dup(cje));
				fnd = 1;
			} else if (ln || rn) {
				if (ln) {
					l = ln->data;
					r = find_rel(rels, cje->r);
				} else {
					l = rn->data;
					r = find_rel(rels, cje->l);
				}
				list_remove_data(rels, r);
				append(n_rels, r);

				/* create a join using the current expression */
				top = rel_crossproduct(top, r, op_join);
				rel_join_add_exp(top, exp_dup(cje));

				/* all join expressions on these tables */
				while((en = list_find(exps, n_rels, (fcmp)&exp_joins_rels)) != NULL) {
					sql_exp *e = en->data;
					rel_join_add_exp(top, exp_dup(e));
					list_remove_data(exps, e);
				}
				/* Remove other joins on the current 'n_rels' 
				   set in the distinct list too */
				while((en = list_find(sdje, n_rels, (fcmp)&exp_joins_rels)) != NULL) 
					list_remove_data(sdje, en->data);
				fnd = 1;
			}
		}
	}
	if (list_length(rels)) { /* more relations */
		node *n;
		for(n=rels->h; n; n = n->next) 
			top = rel_crossproduct(top, n->data, op_join);
	}
	if (list_length(exps)) { /* more expressions */
		node *n;
		for(n=exps->h; n; n = n->next) 
			rel_join_add_exp(top, exp_dup(n->data));
	}
	return top;
}

static sql_rel *
reorder_join(mvc *sql, sql_rel *rel)
{
#ifdef DEBUG
	node *n;
#endif
	list *exps = rel->exps;
	list *rels;

	(void)sql;
	if (!exps) /* crosstable, ie order not important */
		return rel;
	rel->exps = NULL; /* should be all crosstables by now */
 	rels = list_create(NULL);
 	get_relations(rel, rels);

#ifdef DEBUG
printf("SPLIT RELATIONS\n");
	for(n = rels->h; n; n = n->next) 
		rel_print(sql, n->data, 0);
#endif

	rel = order_joins(rels, exps);
	list_destroy(rels);
	list_destroy(exps);
	return rel;
}

static list *
push_up_join_exps( sql_rel *rel) 
{
	switch(rel->op) {
	case op_join: {
		list *l = push_up_join_exps(rel->l);
		list *r = push_up_join_exps(rel->r);
		if (l && r) {
			l = list_merge(l, r, (fdup)&exp_dup);
			list_destroy(r);
		}
		if (rel->exps) {
			r = l;
			l = list_merge(rel->exps, r, (fdup)&exp_dup);
			list_destroy(r);
		}
		rel->exps = NULL;
		return l;
	}
	default:
		return NULL;
	}
	return NULL;
}

static sql_rel *
rel_join_order(mvc *sql, sql_rel *rel) 
{
	if (rel->op == op_join && rel->exps) {
#ifdef DEBUG
printf("BEFORE\n");
		rel_print(sql, rel, 0);
#endif
		rel->exps = push_up_join_exps(rel);
		rel = reorder_join(sql, rel);
#ifdef DEBUG
printf("AFTER\n");
		rel_print(sql, rel, 0);
#endif
	}
	return rel;
}

static sql_exp *
exp_remove_alias(sql_exp *e, list *exps) 
{
	sql_exp *r = NULL;

	switch(e->type) {
	case e_column:
		if (e->l) 
			r = exps_bind_column2(exps, e->l, e->r);
		else
			r = exps_bind_column(exps, e->r);
		if (r) {
			r = exp_dup(r);
			exp_destroy(e);
			return r;
		}
		break;
	case e_cmp: 
		e->l = exp_remove_alias(e->l, exps);
		e->r = exp_remove_alias(e->r, exps);
		if (e->f)
			e->f = exp_remove_alias(e->f, exps);
		return e;
	case e_convert:
		e->l = exp_remove_alias(e->l, exps);
		return e;
	case e_aggr:
	case e_func: {
		list *l = e->l;
		if (l) {
			node *n;
			list *nl = new_exp_list();
			for(n=l->h; n; n=n->next) {
				sql_exp *arg = n->data;

				arg = exp_dup(exp_remove_alias(arg, exps));
				append(nl, arg);
			}
			list_destroy(l);
			e->l = nl;
		}
	}	return e;
	case e_atom:
		return e;
	}
	return NULL;
}

/*
static sql_exp *
exps_remove_alias(sql_exp *e, list *exps) 
{
	return exp_dup(exp_remove_alias(e, exps));
}
*/

/* push the expression down, ie translate colum references from relation f into expression of relation t */ 
static sql_exp *
exp_push_down(mvc *sql, sql_exp *e, sql_rel *f, sql_rel *t) 
{
	sql_exp *ne = NULL;

	switch(e->type) {
	case e_column:
		if (e->l) { 
			ne = exps_bind_column2(f->exps, e->l, e->r);
			/* if relation name matches expressions relation name, find column based on column name alone */
			if (!ne && f->name && strcmp(e->l, f->name) == 0) 
				ne = exps_bind_column(f->exps, e->r);
		}
		if (!ne)
			ne = exps_bind_column(f->exps, e->r);
		assert(ne);
		e = NULL;
		if (ne->name && strcmp(ne->r, ne->name) == 0){ /* no alias */ 
			if (ne->l) {
				e = rel_bind_column2(sql, t, ne->l, ne->r);
				if (!e && t->name && strcmp(ne->l, t->name) == 0) 
					e = rel_bind_column(sql, t, ne->r);
			}
		}
		if (!e)
			e = rel_bind_column(sql, t, ne->r);
		assert(e);
		//return exp_dup(e);
		return e;
	case e_cmp: 
		if (e->f) 
			return exp_compare2( exp_push_down(sql, e->l, f, t), exp_push_down(sql, e->r, f, t), exp_push_down(sql, e->f, f, t), e->flag);
		else
			return exp_compare( exp_push_down(sql, e->l, f, t), exp_push_down(sql, e->r, f, t), e->flag);
	case e_convert:
		return exp_convert( exp_push_down(sql, e->l, f, t), exp_fromtype(e), exp_totype(e));
	case e_aggr:
	case e_func: {
		list *l = e->l, *nl = NULL;

		if (!l) {
			return exp_dup(e);
		} else {
			node *n;

			nl = new_exp_list();
			for(n=l->h; n; n=n->next) {
				sql_exp *arg = n->data;

				arg = exp_push_down(sql, arg, f, t);
				append(nl, arg);
			}
		}
		if (e->type == e_func)
			return exp_op(nl, sql_dup_func(e->f));
		return exp_aggr(nl, sql_dup_aggr(e->f), e->flag&1, (e->flag>>1), e->card);
	}	
	case e_atom:
		return exp_dup(e);
	}
	return NULL;
}

sql_rel *
rel_push_select_down(mvc *sql, sql_rel *rel) 
{
	//sql_rel *rr, *rl;

(void)sql;
	if (rel->op == op_select && rel->l) {
		sql_rel *r = rel->l; 
	//	node *n;

		assert(rel->exps);

		switch(r->op) {
		case op_basetable:
		case op_table:
			return rel;

		case op_join: 
		case op_left: 
		case op_right: 
		case op_full: 

		case op_semi: 
		case op_anti: 

#ifdef DEBUG
			rel_print(sql, rel, 0);
#endif

			/* for each exp check if we can push it left or right */
/*
			for (n=rel->exps->h; n; n = n->next) { 
				sql_exp *e = n->data;
			
				if (e->type == e_cmp) {
					sql_exp *le = e->l;
					sql_exp *re = e->r;
					sql_rel *nr;
		
					e = exp_dup(e);
					if (re->card >= CARD_AGGR) {
						nr = rel_push_join(r, le, re, e);
					} else {
						nr =rel_push_select(r, le, re);
					}
					assert(nr==r);
					(void)nr;
				}
			}
			rel_print(sql, rel, 0);
*/
			return rel;

		case op_union: 
		case op_inter: 

			/* we could push through both */
/*
#ifdef DEBUG
			rel_print(sql, rel, 0);
#endif

			r = rel_dup(rel->l); 
			rl = rel_select(rel_dup(r->l), NULL);
			rr = rel_select(rel_dup(r->r), NULL);
			for (n=rel->exps->h; n; n = n->next) { 
				sql_exp *le, *re, *e = n->data;
*/

				/* rewrite expression */
/*
				le = exp_push_down(sql, e, r, r->l);
				re = exp_push_down(sql, e, r, r->r);
				rel_select_add_exp(rl, exp_dup(le));
				rel_select_add_exp(rr, exp_dup(re));
			}
			rel_destroy(r->l);
			rel_destroy(r->r);
			r->l = rel_push_select_down(sql, rl);
			r->r = rel_push_select_down(sql, rr);
			if (rel->name)
				rel_set_name(r, rel->name); 
			rel_destroy(rel);
#ifdef DEBUG
			rel_print(sql, r, 0);
#endif
			return r;
*/
			break;

		case op_except: 
		case op_select: 
			(void)list_merge(r->exps, rel->exps, (fdup)&exp_dup);
			rel->l = NULL;
			rel_destroy(rel);
			return r;
			
		case op_project:

			/* here we need to fix aliases */

//			r = r->l;
			/* for each exp check if we can rename it */
/*
			for (n=rel->exps->h; n; n = n->next) { 
				sql_exp *e = n->data;
			
				if (e->type == e_cmp) {
					sql_exp *le, *re;
					sql_rel *nr, *p = rel->l;
		
					e = exps_remove_alias(e, p->exps);
 					le = e->l;
					re = e->r;
					if (re->card >= CARD_AGGR) {
						nr = rel_push_join(r, le, re, e);
					} else {
						nr = rel_push_select(r, le, re);
					}
					assert(nr==r);
					(void)nr;
				}
			}
			r = rel->l;
			rel->l = NULL;
			rel_destroy( rel );
			rel = r;
			rel_print(sql, rel, 0);
*/
			return rel;

		case op_groupby: 
		case op_topn: 
			return rel;
		}
	}
	return rel;
}

static sql_rel *
rewrite(mvc *sql, sql_rel *rel, rewrite_fptr rewriter) 
{
	switch (rel->op) {
	case op_basetable:
	case op_table:
		break;
	case op_join: 
	case op_left: 
	case op_right: 
	case op_full: 

	case op_semi: 
	case op_anti: 

	case op_union: 
	case op_inter: 
	case op_except: 
		rel->l = rewrite(sql, rel->l, rewriter);
		rel->r = rewrite(sql, rel->r, rewriter);
		break;
	case op_project:
	case op_select: 
	case op_groupby: 
	case op_topn: 
		if (rel->l)
			rel->l = rewrite(sql, rel->l, rewriter);
		break;
	}
	return rewriter(sql, rel);
}

sql_rel *
rel_optimizer(mvc *sql, sql_rel *rel) 
{
	global_props gp; 

	memset(&gp, 0, sizeof(global_props));
	rel_properties(sql, &gp, rel);

#ifdef DEBUG
{
	int i;
	for (i = 0; i < MAXOPS; i++) {
		if (gp.cnt[i]> 0)
			printf("%s %d\n", op2string((operator_type)i), gp.cnt[i]);
	}
}
#endif

#ifdef DEBUG
	rel_print(sql, rel, 0);
#endif

	/* TODO add rename optimizer, ie remove projects */

	/* TODO add optimizer which removes unions 
		(for example common rels, with only one different expression) */
	/* TODO common sub relation/expression optimizer */

/*
	if (gp.cnt[op_select])
		rel = rewrite(sql, rel, &rel_push_select_down); 
*/

	if (gp.cnt[op_join])
		rel = rewrite(sql, rel, &rel_join_order); 

#ifdef DEBUG
	rel_print(sql, rel, 0);
#endif

	/* optimize */
	return rel;
}
