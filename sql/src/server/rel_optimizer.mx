@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2006 CWI.
@' All Rights Reserved.

@f rel_optimizer
@a N.J. Nes
@* 

@h
#ifndef _REL_OPTIMIZER_H_
#define _REL_OPTIMIZER_H_

#include "rel_semantic.h"

extern sql_rel * rel_optimizer(mvc *sql, sql_rel *rel);

#endif /*_REL_OPTIMIZER_H_*/
@c

#include "rel_optimizer.h"
#include "rel_select.h"
#include "rel_dump.h"

typedef sql_rel *(*rewrite_fptr)(mvc *sql, sql_rel *rel);
typedef int (*find_prop_fptr)(mvc *sql, sql_rel *rel);

/* The important task of the relational optimizer is to optimize the
   join order. 

   The current implementation chooses the join order based on 
   select counts, ie if one of the join sides has been reduced using
   a select this join is choosen over one without such selections. 
 */

typedef struct prop {
	sql_rel *r;	/* the relation sub tree with the property */
	int kind;	/* kind of property */
	int value;	/* most properties are integer valued properties */
	struct prop *p;	/* some relations may have many properties, 
			   which are kept in a chain list */
} prop;
#define PROP_COUNT	0

#define prop_list() 	list_create((fdestroy)&prop_destroy)

static void
prop_destroy( prop *p )
{
	if (p->p)
		prop_destroy(p->p);
	_DELETE(p);
}

static prop *
prop_create( int kind, sql_rel *r, prop *pre )
{
	prop *p = NEW(prop);
	
	p->r = r;
	p->kind = kind;
	p->value = 0;
	p->p = pre;
	return p;
}

/* currently we only find simple column expressions */

static sql_column *
name_find_column( sql_rel *rel, char *rname, char *name ) 
{
	sql_exp *alias = NULL;
	sql_column *c = NULL;

	switch (rel->op) {
	case op_basetable: {
		node *cn;
		sql_table *t = rel->l;
		if (rname) {
			if (rel->name && strcmp(rname, rel->name) != 0)
				return NULL;
			else if (!rel->name && strcmp(rname, t->base.name) != 0)
				return NULL;
		}
		if (rel->exps) {
			sql_exp *rename = exps_bind_column(rel->exps, name);
			if (!rename ||
			     rename->type != e_column ||
			    (rename->l && strcmp(t->base.name, rename->l) != 0))
				return NULL;
			name = rename->r;
		}
		for (cn = t->columns.set->h; cn; cn = cn->next) {
			sql_column *c = cn->data;
			if (strcmp(c->base.name, name) == 0) {
				return c;
			}
		}
	}
	case op_table:
		if (rname && rel->name && strcmp(rname, rel->name) != 0)
			return NULL;
		if (rel->exps)
			alias = exps_bind_column(rel->exps, name);
		break;
	case op_join: 
	case op_left: 
	case op_right: 
	case op_full: 
		/* first right (possible subquery) */
		c = name_find_column( rel->r, rname, name);
		if (!c) 
			c = name_find_column( rel->l, rname, name);
		return c;
	case op_select: 
	case op_union: 
	case op_inter: 
	case op_except: 
	case op_orderby: 
	case op_topn: 
		return name_find_column( rel->l, rname, name);
	case op_project:
	case op_groupby: 
		if (!rel->exps)
			break;
		if (rel->name && rname) { /* both have relation names */
			if (strcmp(rel->name, rname) != 0) 
				break;
			alias = exps_bind_column(rel->exps, name);
		/*
		} else if (rname) {
			alias = exps_bind_column2(rel->exps, rname, name);
		*/
		} else {
			alias = exps_bind_column(rel->exps, name);
		}
		break;
	}
	if (alias) { /* we found an expression with the correct name, but
			we need sql_columns */
		if (alias->type == e_column) /* real alias */
			return name_find_column( rel->l, alias->l, alias->r );
	}
	return NULL;
}

static sql_column *
exp_find_column( sql_rel *rel, sql_exp *exp )
{
	(void)rel;
	if (exp->type == e_column) { 
		return name_find_column(rel, exp->l, exp->r);
	}
	return NULL;
}

static int
join_properties(sql_rel *rel) 
{
	if (rel->exps) {
		list *join_cols = list_create(NULL);
		node *en;

		/* simply using the expressions should also work ! */
		for ( en = rel->exps->h; en; en = en->next ) {
			sql_exp *e = en->data;

			if (e->type == e_cmp && e->flag == cmp_equal) {
				sql_column *lc = exp_find_column(rel, e->l); 
				sql_column *rc = exp_find_column(rel, e->r); 

				if (lc && rc) {
					append(join_cols, lc);
					append(join_cols, rc);
				}
			}
		}
#ifdef DEBUG
		for (en = join_cols->h; en; en = en->next) {
			sql_column *c = en->data;
			printf("j col %s %s\n", c->t->base.name, c->base.name);
		}
#endif
		list_destroy(join_cols);
	}
	return 0;
}

static void
rel_properties(mvc *sql, sql_rel *rel) 
{
	switch (rel->op) {
	case op_basetable:
	case op_table:
		break;
	case op_join: 
	case op_left: 
	case op_right: 
	case op_full: 

	case op_union: 
	case op_inter: 
	case op_except: 
		rel_properties(sql, rel->l);
		rel_properties(sql, rel->r);
		break;
	case op_project:
	case op_select: 
	case op_groupby: 
	case op_orderby: 
	case op_topn: 
		if (rel->l)
			rel_properties(sql, rel->l);
		break;
	}

	switch (rel->op) {
	case op_basetable:
	case op_table:
		rel->p = prop_create(PROP_COUNT, rel, rel->p);
		break;
	case op_join: 
		join_properties(rel);
		break;
	case op_left: 
	case op_right: 
	case op_full: 

	case op_union: 
	case op_inter: 
	case op_except: 
		break;

	case op_project:
	case op_groupby: 
	case op_orderby: 
	case op_topn: 
	case op_select: 
		/* propagate relation names */
		if (!rel->name && rel->l) {
			sql_rel *l = rel->l;
			if (l->name)
				rel->name = _strdup(l->name);
		}
		break;
	}
}

static void
get_tables(mvc *sql, sql_rel *rel, list *tables) 
{
	switch (rel->op) {
	case op_basetable:
	case op_table:
		append(tables, rel);
		break;
	case op_join: 
	case op_left: 
	case op_right: 
	case op_full: 
	case op_union: 
	case op_inter: 
	case op_except: 
		get_tables(sql, rel->l, tables);
		get_tables(sql, rel->r, tables);
		break;
	case op_project:
	case op_select: 
	case op_groupby: 
	case op_orderby: 
	case op_topn: 
		get_tables(sql, rel->l, tables);
		break;
	}
}

static char *
find_rel_name(sql_exp *e)
{
	switch(e->type) {
	case e_column:
		if (e->l)
			return e->l;
		break;
	case e_convert:
		return find_rel_name(e->l);
	default:
		return NULL;
	}
	return NULL;
}

static void
cond_append( list *l, char *n)
{
	if (n) {
		if (!list_find(l,n,(fcmp)strcmp))
			append(l,n);
	}
}

static list *
relation_names(list *exps) 
{
	node *n;
	list *l = list_create(NULL);

	for(n = exps->h; n; n = n->next) {
		sql_exp *e = n->data;
		if (e->type == e_cmp) {
			cond_append(l, find_rel_name(e->l));
			cond_append(l, find_rel_name(e->r));
		}
	}
	return l;
}

static void
get_relations(sql_rel *rel, list *rels)
{
	if (rel->op == op_join) {
		assert(rel->exps == NULL);
		get_relations(rel->l, rels);
		get_relations(rel->r, rels);
		rel->l = NULL;
		rel->r = NULL;
		rel_destroy(rel);
	} else {
		append(rels, rel);
	}
}

static sql_rel * 
rel_smallest(sql_rel *r, sql_rel *key) 
{
	if (r->exps && key->exps) {
		if (list_length(r->exps) - list_length(key->exps)) {
			return r;
		} else {
			return key;
		}
	} else if (r->exps) {
		return r;
	} else {
		return key;
	}
}

/* return matching relation */
static int 
matching_rel(sql_rel *r, sql_exp *je) 
{
	if (je->type == e_cmp) {
		char *name = find_rel_name(je->l);
		if (name && r->name && strcmp(name,r->name) == 0)
			return 0; 
		name = find_rel_name(je->r);
		if (name && r->name && strcmp(name,r->name) == 0)
			return 0; 
	} 
	return -1;
}

/* return join expression for relation r */
static int 
join_exp(sql_exp *je, sql_rel *r) 
{
	if (je->type == e_cmp) {
		char *name = find_rel_name(je->l);
		if (name && r->name && strcmp(name,r->name) == 0) {
			return 0; 
		} else {
			char *name = find_rel_name(je->r);
			if (name && r->name && strcmp(name,r->name) ==0)
				return 0; 
		}
	} 
	return -1;
}

static sql_rel *
rel_dup(sql_rel *r) {
	return r;
}

typedef struct pair {
	void *l, *r;
} pair;

static int 
rel_exp(sql_exp *je, pair *p) {
	if (je->type == e_cmp) {
		char *lname = find_rel_name(je->l);
		char *rname = find_rel_name(je->r);

		if (!lname || !rname)
			return -1;
		if (strcmp(lname,p->l) == 0 && strcmp(rname,p->r) == 0) 
			return 0; 
		if (strcmp(lname,p->r) == 0 && strcmp(rname,p->l) == 0) 
			return 0; 
	} 
	return -1;
} 

static int
joinexp_cmp(sql_exp *h, sql_exp *key)
{
	char *h_lname = find_rel_name(h->l);
	char *h_rname = find_rel_name(h->r);
	char *key_lname = find_rel_name(key->l);
	char *key_rname = find_rel_name(key->r);

	assert (h->type == e_cmp && key->type == e_cmp);
	if (strcmp(h_lname, key_lname) == 0 &&
	    strcmp(h_rname, key_rname) == 0)
		return 0;
	if (strcmp(h_rname, key_lname) == 0 &&
	    strcmp(h_lname, key_rname) == 0)
		return 0;
        return -1;
}

static sql_exp *
joinexp_col(sql_exp *e, char *rel_name)
{
	if (e->type == e_cmp) {
		char *rname = find_rel_name(e->l);
		if (rname && strcmp(rname, rel_name) == 0)
			return exp_dup(e->l);
		return e->r;
	}
	assert(0);
	return NULL;
}

static int
relation_name( sql_rel *r, char *name) 
{
	if (r->name && strcmp(r->name, name) == 0)
		return 0;
	return -1;
}

static sql_table *
rel_find_table(sql_rel *rel)
{
	switch(rel->op) {
	case op_basetable: 
		return rel->l;
	case op_table:

	case op_join: 
	case op_left: 
	case op_right: 
	case op_full: 
		return NULL;
	case op_select: 
	case op_union: 
	case op_inter: 
	case op_except: 
	case op_orderby: 
	case op_topn: 

	case op_project:
	case op_groupby: 
		return rel_find_table(rel->l);
	}
	return NULL;
}

static sql_table *
find_table(list *rels, char *rel_name)
{
	node *n = list_find(rels, rel_name, (fcmp)&relation_name);
	if (n) 
		return rel_find_table(n->data);
	return NULL;
}

static sql_rel *
order_joins(list *rels, list *exps)
{
	sql_rel *top = NULL, *cur = NULL;
	list *n_rels = list_create(NULL);
	node *un, *djn;

	/* first find the distinct join expressions */
	list *dje = list_distinct(exps, (fcmp) &joinexp_cmp, (fdup)exp_dup);

	for(djn=dje->h; djn; djn = djn->next) {
		/* equal join expressions */
		sql_exp *je = djn->data, *le = je->l, *re = je->r; 
		list *eje = list_select(dje, je, (fcmp) &joinexp_cmp, (fdup) &exp_dup);
		/* TODO check for equi joins etc */

		char *lname = find_rel_name(le);
		char *rname = find_rel_name(re);
		list *lcols = list_map(eje, lname, (fmap) &joinexp_col);
		list *rcols = list_map(eje, rname, (fmap) &joinexp_col);
		sql_table *l, *r;

		l = find_table(rels, lname);
		r = find_table(rels, rname);
		assert(l && r);
		printf("%s %d %s %d\n", l->base.name, list_length(lcols),
					r->base.name, list_length(rcols));
	}

	/* pick first relation on smallest size */
	top = cur = list_reduce(rels, (freduce)&rel_smallest, (fdup)&rel_dup);
	list_remove_data(rels, cur);
	append(n_rels, cur);
	while (list_length(exps)) {
		node *jen = NULL;
		for (un=n_rels->h;!jen && un; un = un->next) {
			jen = list_find(exps, un->data, (fcmp)&join_exp); 
		}
		if (jen) {
			node *rn;
			sql_exp *je = jen->data;

			je = exp_dup(je);
			list_remove_data(exps, je);
			/* find right relation */
			rn = list_find(rels, je, (fcmp)&matching_rel);
			if (!rn) { /* create a selection on the current */
				rel_join_add_exp(top, je);
			} else {
				sql_rel *r = rn->data;
				pair p;

				p.l = cur->name;
				p.r = r->name;
				assert(p.l && p.r);

				list_remove_data(rels, r);
				append(n_rels, r);
				top = rel_crossproduct(top, r, op_join);

				rel_join_add_exp(top, je);
				/* all join expressions on these tables */
				while((jen = list_find(exps, &p, (fcmp)&rel_exp)) != NULL) {
					sql_exp *e = jen->data;
					rel_join_add_exp(top, e);
					list_remove_data(exps, e);
				}
				cur = r;
			}
		} else {
			if (list_length(rels)) {
				sql_rel *r = order_joins(rels, exps);
				top = rel_crossproduct(top, r, op_join);
			}
			if (list_length(exps))
				top->exps = exps;
			return top;
		}
	}
	return top;
}

static sql_rel *
reorder_join(mvc *sql, sql_rel *rel)
{
#ifdef DEBUG
	node *n;
#endif
	list *exps = rel->exps;
	list *rels;

	(void)sql;
	if (!exps) /* crosstable, ie order not important */
		return rel;
	rel->exps = NULL; /* should be all crosstables by now */
 	rels = list_create(NULL);
 	get_relations(rel, rels);

#ifdef DEBUG
	for(n = rels->h; n; n = n->next) 
		rel_print(sql, n->data, 0);
#endif

	rel = order_joins(rels, exps);
	list_destroy(rels);
	list_destroy(exps);
	return rel;
}

static list *
push_up_join_exps( sql_rel *rel) 
{
	switch(rel->op) {
	case op_join: {
		list *l = push_up_join_exps(rel->l);
		list *r = push_up_join_exps(rel->r);
		if (l && r) {
			l = list_merge(l, r, (fdup)&exp_dup);
			list_destroy(r);
		}
		if (rel->exps) {
			r = l;
			l = list_merge(rel->exps, r, (fdup)&exp_dup);
			list_destroy(r);
		}
		rel->exps = NULL;
		return l;
	}
	default:
		return NULL;
	}
	return NULL;
}

static sql_rel *
rel_join_order(mvc *sql, sql_rel *rel) 
{
	if (rel->op == op_join) {
		if (rel->exps) {
			node *n;

			list *rels = relation_names(rel->exps);
			int len = list_length(rels);
			switch(len) {
			case 0: 
			case 1: /* crosstables */
				/* also column refs fall into this because 
				   they have no relation names */
				rel_print(sql, rel, 0);
				break;
#ifdef DEBUG
			case 2:
				printf("%d\n", len);
				for(n = rels->h; n; n = n->next) 
					printf(" %s", (char*)n->data);
				printf("\n");
				list_destroy(rels);
				return rel;
#endif
			default: 
				/* lets try too rewrite */
				rel_print(sql, rel, 0);

				printf("%d", len);
				for(n = rels->h; n; n = n->next) 
					printf(" %s", (char*)n->data);
				printf("\n");

				rel->exps = push_up_join_exps(rel);
				rel = reorder_join(sql, rel);

				rel_print(sql, rel, 0);
				break;
			}
			list_destroy(rels);
			return rel;
		}
		return rel;
	}
	return rel;
}

static sql_exp *
exp_remove_alias(sql_exp *e, list *exps) 
{
	sql_exp *r = NULL;

	switch(e->type) {
	case e_column:
		if (e->l) 
			r = exps_bind_column2(exps, e->l, e->r);
		else
			r = exps_bind_column(exps, e->r);
		if (r) {
			r = exp_dup(r);
			exp_destroy(e);
			return r;
		}
		break;
	case e_exp:	/* like only */
	case e_cmp: 
		e->l = exp_remove_alias(e->l, exps);
		e->r = exp_remove_alias(e->r, exps);
		return e;
	case e_convert:
		e->l = exp_remove_alias(e->l, exps);
		return e;
	case e_aggr:
	case e_func: {
		list *l = e->l;
		if (l) {
			node *n;
			list *nl = new_exp_list();
			for(n=l->h; n; n=n->next) {
				sql_exp *arg = n->data;

				arg = exp_dup(exp_remove_alias(arg, exps));
				append(nl, arg);
			}
			list_destroy(l);
			e->l = nl;
		}
	}	return e;
	case e_relation: 
		/* TODO */
		assert(0);
	case e_atom:
		return e;
	}
	return NULL;
}

static sql_exp *
selectexp_remove_alias(sql_exp *e, list *exps) 
{
	return exp_dup(exp_remove_alias(e, exps));
}

static sql_rel *
rel_push_select_down(mvc *sql, sql_rel *rel) 
{
	if (rel->op == op_select) {
		sql_rel *r = rel->l; 
		node *n;
		assert(rel->exps);

		switch(r->op) {
		case op_basetable:
		case op_table:
			return rel;
		case op_join: 
			rel_print(sql, rel, 0);
			/* for each exp check if we can push it left or right */
			for (n=rel->exps->h; n; n = n->next) { 
				sql_exp *e = n->data;
			
				if (e->type == e_cmp) {
					sql_exp *le = e->l;
					sql_exp *re = e->r;
					sql_rel *nr;
		
					e = exp_dup(e);
					if (re->card >= CARD_AGGR) {
						nr = rel_push_join(sql, r, le, re, e);
					} else {
						nr =rel_push_select(sql, r, le, re);
					}
					assert(nr==r);
					(void)nr;
				}
			}
			rel_print(sql, rel, 0);
			return rel;
		case op_left: 
		case op_right: 
		case op_full: 

		case op_union: 
			/* we could push through both */
		case op_inter: 
		case op_except: 
			return rel;

		case op_select: 
			/* simple (merge exp lists) (but shouldn't happen) */
			assert(0);
			
		case op_project:
			/* here we need to fix aliases */
			rel_print(sql, rel, 1);

			r = r->l;
			/* for each exp check if we can rename it */
			for (n=rel->exps->h; n; n = n->next) { 
				sql_exp *e = n->data;
			
				if (e->type == e_cmp) {
					sql_exp *le, *re;
					sql_rel *nr, *p = rel->l;
		
					e = selectexp_remove_alias(e, p->exps);
 					le = e->l;
					re = e->r;
					if (re->card >= CARD_AGGR) {
						nr = rel_push_join(sql, r, le, re, e);
					} else {
						nr = rel_push_select(sql, r, le, re);
					}
					assert(nr==r);
					(void)nr;
				}
			}
			r = rel->l;
			rel->l = NULL;
			rel_destroy( rel );
			rel = r;
			rel_print(sql, rel, 0);
			return rel;

		case op_groupby: 
		case op_orderby: 
		case op_topn: 
			return rel;
		}
	}
	return rel;
}

static sql_rel *
rewrite(mvc *sql, sql_rel *rel, rewrite_fptr rewriter) 
{
	switch (rel->op) {
	case op_basetable:
	case op_table:
		break;
	case op_join: 
	case op_left: 
	case op_right: 
	case op_full: 

	case op_union: 
	case op_inter: 
	case op_except: 
		rel->l = rewrite(sql, rel->l, rewriter);
		rel->r = rewrite(sql, rel->r, rewriter);
		break;
	case op_project:
	case op_select: 
	case op_groupby: 
	case op_orderby: 
	case op_topn: 
		if (rel->l)
			rel->l = rewrite(sql, rel->l, rewriter);
		break;
	}
	return rewriter(sql, rel);
}

sql_rel *
rel_optimizer(mvc *sql, sql_rel *rel) 
{
	/* collect properties/statistics 
	   (some should be obtained from the backend lower levels) */
	rel_properties(sql, rel);

	rel = rewrite(sql, rel, &rel_push_select_down); 

	rel = rewrite(sql, rel, &rel_join_order); 

	rel_print(sql, rel, 0);

	/* optimize */
	return rel;
}
