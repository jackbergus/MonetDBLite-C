@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2008 CWI.
@' All Rights Reserved.

@f rel_optimizer
@a N.J. Nes
@* 

@h
#ifndef _REL_OPTIMIZER_H_
#define _REL_OPTIMIZER_H_

#include "rel_semantic.h"

extern sql_rel * rel_optimizer(mvc *sql, sql_rel *rel);

#endif /*_REL_OPTIMIZER_H_*/
@c

//#define DEBUG

#include "sql_config.h"
#include "rel_optimizer.h"
#include "rel_select.h"
#include "rel_prop.h"
#include "rel_exp.h"
#include "rel_dump.h"

typedef struct global_props {
	int cnt[MAXOPS];
} global_props;

typedef sql_rel *(*rewrite_fptr)(mvc *sql, sql_rel *rel);
typedef int (*find_prop_fptr)(mvc *sql, sql_rel *rel);

/* The important task of the relational optimizer is to optimize the
   join order. 

   The current implementation chooses the join order based on 
   select counts, ie if one of the join sides has been reduced using
   a select this join is choosen over one without such selections. 
 */

/* currently we only find simple column expressions */
static sql_column *
name_find_column( sql_rel *rel, char *rname, char *name ) 
{
	sql_exp *alias = NULL;
	sql_column *c = NULL;

	switch (rel->op) {
	case op_basetable: {
		node *cn;
		sql_table *t = rel->l;
		if (rname) {
			if (rel->name && strcmp(rname, rel->name) != 0)
				return NULL;
			else if (!rel->name && strcmp(rname, t->base.name) != 0)
				return NULL;
		}
		if (rel->exps) {
			sql_exp *rename = exps_bind_column(rel->exps, name);
			if (!rename ||
			     rename->type != e_column ||
			    (rename->l && strcmp(t->base.name, rename->l) != 0))
				return NULL;
			name = rename->r;
		}
		for (cn = t->columns.set->h; cn; cn = cn->next) {
			sql_column *c = cn->data;
			if (strcmp(c->base.name, name) == 0) {
				return c;
			}
		}
	}
	case op_table:
		if (rname && rel->name && strcmp(rname, rel->name) != 0)
			return NULL;
		if (rel->exps)
			alias = exps_bind_column(rel->exps, name);
		/* table func */
		return NULL;
	case op_join: 
	case op_left: 
	case op_right: 
	case op_full: 
	case op_semi: 
	case op_anti: 
		/* first right (possible subquery) */
		c = name_find_column( rel->r, rname, name);
		if (!c) 
			c = name_find_column( rel->l, rname, name);
		return c;
	case op_select: 
	case op_union: 
	case op_inter: 
	case op_except: 
	case op_topn: 
		return name_find_column( rel->l, rname, name);
	case op_project:
	case op_groupby: 
		if (!rel->exps)
			break;
		if (rel->name && rname) { /* both have relation names */
			if (strcmp(rel->name, rname) != 0) 
				break;
			alias = exps_bind_column(rel->exps, name);
		/*
		} else if (rname) {
			alias = exps_bind_column2(rel->exps, rname, name);
		*/
		} else {
			alias = exps_bind_column(rel->exps, name);
		}
		break;
	}
	if (alias) { /* we found an expression with the correct name, but
			we need sql_columns */
		if (alias->type == e_column) /* real alias */
			return name_find_column( rel->l, alias->l, alias->r );
	}
	return NULL;
}

static sql_column *
exp_find_column( sql_rel *rel, sql_exp *exp )
{
	(void)rel;
	if (exp->type == e_column) { 
		return name_find_column(rel, exp->l, exp->r);
	}
	return NULL;
}

static int
join_properties(sql_rel *rel) 
{
	if (rel->exps) {
		list *join_cols = list_create(NULL);
		node *en;

		/* simply using the expressions should also work ! */
		for ( en = rel->exps->h; en; en = en->next ) {
			sql_exp *e = en->data;

			if (e->type == e_cmp && e->flag == cmp_equal) {
				sql_column *lc = exp_find_column(rel, e->l); 
				sql_column *rc = exp_find_column(rel, e->r); 

				if (lc && rc) {
					append(join_cols, lc);
					append(join_cols, rc);
				}
			}
		}
#ifdef DEBUG
		for (en = join_cols->h; en; en = en->next) {
			sql_column *c = en->data;
			printf("j col %s %s\n", c->t->base.name, c->base.name);
		}
#endif
		list_destroy(join_cols);
	}
	return 0;
}

static void
rel_properties(mvc *sql, global_props *gp, sql_rel *rel) 
{
	gp->cnt[(int)rel->op]++;
	switch (rel->op) {
	case op_basetable:
	case op_table:
		break;
	case op_join: 
	case op_left: 
	case op_right: 
	case op_full: 

	case op_semi: 
	case op_anti: 

	case op_union: 
	case op_inter: 
	case op_except: 
		rel_properties(sql, gp, rel->l);
		rel_properties(sql, gp, rel->r);
		break;
	case op_project:
	case op_select: 
	case op_groupby: 
	case op_topn: 
		if (rel->l)
			rel_properties(sql, gp, rel->l);
		break;
	}

	switch (rel->op) {
	case op_basetable:
	case op_table:
		rel->p = prop_create(PROP_COUNT, rel->p);
		break;
	case op_join: 
		join_properties(rel);
		break;
	case op_left: 
	case op_right: 
	case op_full: 

	case op_semi: 
	case op_anti: 

	case op_union: 
	case op_inter: 
	case op_except: 
		break;

	case op_project:
	case op_groupby: 
	case op_topn: 
	case op_select: 
		/* propagate relation names */
		if (!rel->name && rel->l) {
			sql_rel *l = rel->l;
			if (l->name)
				rel->name = _strdup(l->name);
		}
		break;
	}
}

#if 0
static void
get_tables(mvc *sql, sql_rel *rel, list *tables) 
{
	switch (rel->op) {
	case op_basetable:
	case op_table:
		append(tables, rel);
		break;
	case op_join: 
	case op_left: 
	case op_right: 
	case op_full: 
	case op_semi: 
	case op_anti: 
	case op_union: 
	case op_inter: 
	case op_except: 
		get_tables(sql, rel->l, tables);
		get_tables(sql, rel->r, tables);
		break;
	case op_project:
	case op_select: 
	case op_groupby: 
	case op_topn: 
		get_tables(sql, rel->l, tables);
		break;
	}
}
#endif

static void
get_relations(sql_rel *rel, list *rels)
{
	if (rel->op == op_join && rel->exps == NULL) {
		get_relations(rel->l, rels);
		get_relations(rel->r, rels);
		rel->l = NULL;
		rel->r = NULL;
		rel_destroy(rel);
	} else {
		append(rels, rel);
	}
}

static int
exp_count(int *cnt, int seqnr, sql_exp *e) 
{
	(void)seqnr;
	if (!e)
		return 0;
	if (find_prop(e->p, PROP_JOINIDX))
		*cnt += 100;
	if (find_prop(e->p, PROP_HASHIDX)) 
		*cnt += 100;
	switch(e->type) {
	case e_cmp:
		switch (e->flag) {
		case cmp_equal:
			*cnt += 10;
			return 10;
		case cmp_notequal:
			*cnt += 7;
			return 7;
		case cmp_gt:
		case cmp_gte:
		case cmp_lt:
		case cmp_lte:
			*cnt += 6;
			if (e->f){ /* range */
				*cnt += 6;
				return 12;
			}
			return 6;
		case cmp_like:
		case cmp_notlike:
			*cnt += 2;
			return 2;
		default:
			return 0;
		}
	default:
		return -5;
	}
	return -5;
}

static int
exp_keyvalue(sql_exp *e) 
{
	int cnt = 0;
	exp_count(&cnt, 0, e);
	return cnt;
}

static int
rel_has_exp(sql_rel *rel, sql_exp *e) 
{
	if (rel_find_exp(rel, e) != NULL) 
		return 0;
	return -1;
}

static sql_rel *
find_rel(list *rels, sql_exp *e)
{
	node *n = list_find(rels, e, (fcmp)&rel_has_exp);
	if (n) 
		return n->data;
	return NULL;
}

static int
joinexp_cmp(list *rels, sql_exp *h, sql_exp *key)
{
	sql_rel *h_l = find_rel(rels, h->l);
	sql_rel *h_r = find_rel(rels, h->r);
	sql_rel *key_l = find_rel(rels, key->l);
	sql_rel *key_r  = find_rel(rels, key->r);

	assert (h->type == e_cmp && key->type == e_cmp);
	assert (h_l && h_r && key_l && key_r);
	if (h_l == key_l && h_r == key_r)
		return 0;
	if (h_r == key_l && h_l == key_r)
		return 0;
        return -1;
}

static sql_exp *
joinexp_col(sql_exp *e, sql_rel *r)
{
	if (e->type == e_cmp) {
		if (rel_has_exp(r, e->l) >= 0) 
			return exp_dup(e->l);
		return exp_dup(e->r);
	}
	assert(0);
	return NULL;
}

static sql_column *
table_colexp(sql_exp *e, sql_rel *r)
{
	sql_table *t = r->l;

	if (e->type == e_column) {
		char *name = e->name;
		node *cn;

		if (r->exps) { /* use alias */
			for (cn = r->exps->h; cn; cn = cn->next) {
				sql_exp *ce = cn->data;
				if (strcmp(ce->name, name) == 0) {
					name = ce->r;
					break;
				}
			}
		}
		for (cn = t->columns.set->h; cn; cn = cn->next) {
			sql_column *c = cn->data;
			if (strcmp(c->base.name, name) == 0) 
				return c;
		}
	}
	return NULL;
}

static int
exp_joins_rels(sql_exp *e, list *rels)
{
	sql_rel *l, *r;

	assert (e->type == e_cmp);
		
	l = find_rel(rels, e->l);
	r = find_rel(rels, e->r);
	if (l && r)
		return 0;
	return -1;
}

static list *
matching_joins(list *rels, list *exps, sql_exp *je) 
{
	sql_rel *l, *r;

	assert (je->type == e_cmp);
		
	l = find_rel(rels, je->l);
	r = find_rel(rels, je->r);
	if (l && r) {
		list *res;
		list *n_rels = list_create(NULL);	

		append(n_rels, l);
		append(n_rels, r);
		res = list_select(exps, n_rels, (fcmp) &exp_joins_rels, (fdup)exp_dup);
		list_destroy(n_rels);
		return res; 
	}
	return list_create(NULL);
}

static int
sql_column_kc_cmp(sql_column *c, sql_kc *kc)
{
	/* return on equality */
	return (c->colnr - kc->c->colnr);
}

static sql_idx *
find_fk_index(sql_table *l, list *lcols, sql_table *r, list *rcols)
{
	if (l->idxs.set) {
		node *in;
	   	for(in = l->idxs.set->h; in; in = in->next){
	    		sql_idx *li = in->data;
			if (li->type == join_idx) {
		        	sql_idx *ri = ((sql_fkey*)li->key)->rkey->k.idx;
				fcmp cmp = (fcmp)&sql_column_kc_cmp;

              			if (ri->t == r && 
				    list_match(lcols, li->columns, cmp) == 0 &&
				    list_match(rcols, ri->columns, cmp) == 0) {
					return li;
				}
			}
		}
	}
	return NULL;
}

static sql_rel *
find_basetable( sql_rel *r)
{
	if (!r)
		return NULL;
	switch(r->op) {
	case op_basetable:	
		return r;
	case op_select:
		return find_basetable(r->l);
	default:
		return NULL;
	}
}

static list *
find_fk(list *rels, list *exps) 
{
	node *djn;
	list *sdje, *aje, *dje;

	/* first find the distinct join expressions */
	aje = list_select(exps, (void*)1, (fcmp) &exp_is_join, (fdup)exp_dup);
	dje = list_distinct2(aje, rels, (fcmp2) &joinexp_cmp, (fdup)exp_dup);
	for(djn=dje->h; djn; djn = djn->next) {
		/* equal join expressions */
		sql_idx *idx = NULL;
		sql_exp *je = djn->data, *le = je->l, *re = je->r; 

		if (!find_prop(je->p, PROP_JOINIDX)) {
			int swapped = 0;
			list *aaje = matching_joins(rels, aje, je);
			list *eje = list_select(aaje, (void*)1, (fcmp) &exp_is_eqjoin, (fdup) &exp_dup);
			sql_rel *lr = find_rel(rels, le);
			sql_rel *rr = find_rel(rels, re);

			sql_table *l, *r;
			list *lexps = list_map(eje, lr, (fmap) &joinexp_col);
			list *rexps = list_map(eje, rr, (fmap) &joinexp_col);
			list *lcols, *rcols;

			lr = find_basetable(lr);
			rr = find_basetable(rr);
			if (!lr || !rr) {
				list_destroy(lexps);
				list_destroy(rexps);
				list_destroy(eje);
				list_destroy(aaje);
				continue;
			}
			l = lr->l;
			r = rr->l;
			lcols = list_map(lexps, lr, (fmap) &table_colexp);
			rcols = list_map(rexps, rr, (fmap) &table_colexp);
			list_destroy(lexps);
			list_destroy(rexps);
			if (list_length(lcols) != list_length(rcols)) {
				lcols->destroy = NULL;
				rcols->destroy = NULL;
				list_destroy(lcols);
				list_destroy(rcols);
				list_destroy(eje);
				list_destroy(aaje);
				continue;
			}

			idx = find_fk_index(l, lcols, r, rcols); 
			if (!idx) {
				idx = find_fk_index(r, rcols, l, lcols); 
				swapped = 1;
			} 

#ifdef DEBUG
			printf("%s %d %s %d (%d)\n", 
				l->base.name, list_length(lcols),
				r->base.name, list_length(rcols),
				idx?1:0);
#endif
			if (idx) { 	
				prop *p;
				node *n;
	
				/* Remove all other join expressions */
				for (n = eje->h; n; n = n->next) {
					if (je != n->data)
						list_remove_data(exps, n->data);
				}
				/* Add the join index using PROP_JOINIDX  */
				if (swapped) {
					sql_exp *s = je->l;
					je->l = je->r;
					je->r = s;
				}
				je->p = p = prop_create(PROP_JOINIDX, je->p);
				p->value = idx;
			}
			lcols->destroy = NULL;
			rcols->destroy = NULL;
			list_destroy(lcols);
			list_destroy(rcols);
			list_destroy(eje);
			list_destroy(aaje);
		}
	}
	list_destroy(aje);

	/* sort expressions on weighted number of reducing operators */
	sdje = list_sort(dje, (fkeyvalue)&exp_keyvalue, (fdup)&exp_dup);
	list_destroy(dje);

	return sdje;
}

static sql_rel *
order_joins(list *rels, list *exps)
{
	sql_rel *top = NULL, *l = NULL, *r = NULL;
	sql_exp *cje;
	node *djn;
	list *sdje, *n_rels = list_create(NULL);
	int fnd = 0;

	sdje = find_fk(rels, exps);

	if (sdje->h) {
		/* get the first expression */
		cje = sdje->h->data;
		list_remove_data(sdje, cje);
		list_remove_data(exps, cje);

		/* find the involved relations */
		l = find_rel(rels, cje->l);
		r = find_rel(rels, cje->r);
	}
	if (l && r) {
		list_remove_data(rels, l);
		list_remove_data(rels, r);
		list_append(n_rels, l);
		list_append(n_rels, r);

		/* Create a relation between l and r. Since the calling 
	   	   functions rewrote the join tree, into a list of expressions 
	   	   and a list of (simple) relations, there are no outer joins 
	   	   involved, we can simply do a crossproduct here.
	 	 */
		top = rel_crossproduct(l, r, op_join);
		rel_join_add_exp(top, exp_dup(cje));

		/* all other join expressions on these 2 relations */
		while((djn = list_find(exps, n_rels, (fcmp)&exp_joins_rels)) != NULL) {
			sql_exp *e = djn->data;

			rel_join_add_exp(top, exp_dup(e));
			list_remove_data(exps, e);
		}
		/* Remove other joins on the current 'n_rels' set in the distinct list too */
		while((djn = list_find(sdje, n_rels, (fcmp)&exp_joins_rels)) != NULL) 
			list_remove_data(sdje, djn->data);
		fnd = 1;
	}
	/* build join tree using the ordered list */
	while(list_length(exps) && fnd) {
		fnd = 0;
		/* find the first expression which could be added */
		for(djn = sdje->h; djn && !fnd; djn = (!fnd)?djn->next:NULL) {
			node *ln, *rn, *en;
			
			cje = djn->data;
			ln = list_find(n_rels, cje->l, (fcmp)&rel_has_exp);
			rn = list_find(n_rels, cje->r, (fcmp)&rel_has_exp);

			if (ln || rn) {
				/* remove the expression from the lists */
				list_remove_data(sdje, cje);
				list_remove_data(exps, cje);
			}
			if (ln && rn) {
				assert(0);
				/* create a selection on the current */
				l = ln->data;
				r = rn->data;
				rel_join_add_exp(top, exp_dup(cje));
				fnd = 1;
			} else if (ln || rn) {
				if (ln) {
					l = ln->data;
					r = find_rel(rels, cje->r);
				} else {
					l = rn->data;
					r = find_rel(rels, cje->l);
				}
				list_remove_data(rels, r);
				append(n_rels, r);

				/* create a join using the current expression */
				top = rel_crossproduct(top, r, op_join);
				rel_join_add_exp(top, exp_dup(cje));

				/* all join expressions on these tables */
				while((en = list_find(exps, n_rels, (fcmp)&exp_joins_rels)) != NULL) {
					sql_exp *e = en->data;
					rel_join_add_exp(top, exp_dup(e));
					list_remove_data(exps, e);
				}
				/* Remove other joins on the current 'n_rels' 
				   set in the distinct list too */
				while((en = list_find(sdje, n_rels, (fcmp)&exp_joins_rels)) != NULL) 
					list_remove_data(sdje, en->data);
				fnd = 1;
			}
		}
	}
	if (list_length(rels)) { /* more relations */
		node *n;
		for(n=rels->h; n; n = n->next) {
			if (top)
				top = rel_crossproduct(top, n->data, op_join);
			else 
				top = n->data;
		}
	}
	if (list_length(exps)) { /* more expressions */
		node *n;
		for(n=exps->h; n; n = n->next) 
			rel_join_add_exp(top, exp_dup(n->data));
	}
	return top;
}

static void
push_in_join_down(list *rels, list *exps)
{
	node *n;
	int restart = 1;

	/* one of the rels should be a op_union with nrcols == 0 */
	while(restart) {
	    for(n = rels->h; n; n = n->next) {
		sql_rel *r = n->data;
	
		restart = 0;
		if (is_union(r->op) && r->nrcols == 0) {
			/* next step find expression on this relation */
			node *m;
			sql_rel *l = NULL;
			sql_exp *je = NULL;

			for(m = exps->h; !je && m; m = m->next) {
				sql_exp *e = m->data;

				if (e->type == e_cmp && e->flag == cmp_equal) {
					/* in values are on 
						the right of the join */
					if (rel_has_exp(r, e->r) >= 0) 
						je = e;
				}
			}
			/* with this expression find other relation */
			if (je && (l = find_rel(rels, je->l)) != NULL) {
				sql_rel *nr = rel_crossproduct(l, r, op_join);

				rel_join_add_exp(nr, exp_dup(je));
				list_append(rels, nr); 
				list_remove_data(rels, l);
				list_remove_data(rels, r);
				list_remove_data(exps, je);
				restart = 1;
				break;
			}

		}
	    }
	}
}

static sql_rel *
reorder_join(mvc *sql, sql_rel *rel)
{
#ifdef DEBUG
	node *n;
#endif
	list *exps = rel->exps;
	list *rels;

	(void)sql;
	if (!exps) /* crosstable, ie order not important */
		return rel;
	rel->exps = NULL; /* should be all crosstables by now */
 	rels = list_create(NULL);
	if (is_outerjoin(rel->op)) {
		/* try to use an join index also for outer joins */
		list_append(rels, rel->l);
		list_append(rels, rel->r);
		rel->exps = find_fk(rels, exps);
	} else { 
 		get_relations(rel, rels);
#ifdef DEBUG
		for(n = rels->h; n; n = n->next) 
			rel_print(sql, n->data, 0);
#endif
		push_in_join_down(rels, exps);

		rel = order_joins(rels, exps);
	}
	list_destroy(rels);
	list_destroy(exps);
	return rel;
}

static list *
push_up_join_exps( sql_rel *rel) 
{
	switch(rel->op) {
	case op_join: {
		sql_rel *rl = rel->l;
		sql_rel *rr = rel->r;
		list *l = !rel_is_ref(rl) ? push_up_join_exps(rl): NULL;
		list *r = !rel_is_ref(rr) ? push_up_join_exps(rr): NULL;
		if (l && r) {
			l = list_merge(l, r, (fdup)&exp_dup);
			list_destroy(r);
		}
		if (rel->exps) {
			if (l && !r)
				r = l;
			l = list_merge(rel->exps, r, (fdup)&exp_dup);
			list_destroy(r);
		}
		rel->exps = NULL;
		return l;
	}
	default:
		return NULL;
	}
	return NULL;
}

static sql_rel *
rel_join_order(mvc *sql, sql_rel *rel) 
{
	if (is_join(rel->op) && rel->exps) {
#ifdef DEBUG
printf("BEFORE\n");
		rel_print(sql, rel, 0);
#endif
		if (rel->op == op_join)
			rel->exps = push_up_join_exps(rel);
		rel = reorder_join(sql, rel);
#ifdef DEBUG
printf("AFTER\n");
		rel_print(sql, rel, 0);
#endif
	}
	return rel;
}

/* push the expression down, ie translate colum references from relation f into expression of relation t */ 
static sql_exp *
exp_push_down(mvc *sql, sql_exp *e, sql_rel *f, sql_rel *t) 
{
	sql_exp *ne = NULL, *l, *r, *r2;

	switch(e->type) {
	case e_column:
		if (e->l) { 
			ne = exps_bind_column2(f->exps, e->l, e->r);
			/* if relation name matches expressions relation name, find column based on column name alone */
			if (!ne && f->name && strcmp(e->l, f->name) == 0) 
				ne = exps_bind_column(f->exps, e->r);
		}
		if (!ne)
			ne = exps_bind_column(f->exps, e->r);
		assert(ne);
		e = NULL;
		if (ne->name && ne->r){ 
			if (ne->l) {
				e = rel_bind_column2(sql, t, ne->l, ne->r);
				if (!e && t->name && strcmp(ne->l, t->name) == 0) 
					e = rel_bind_column(sql, t, ne->r);
			}
		}
		if (!e && ne->r)
			e = rel_bind_column(sql, t, ne->r);
		return e;
	case e_cmp: 
		l = exp_push_down(sql, e->l, f, t);
		r = exp_push_down(sql, e->r, f, t);
		if (e->f) {
			r2 = exp_push_down(sql, e->f, f, t);
			if (l && r && r2)
				return exp_compare2( l, r, r2, e->flag);
		} else if (l && r) {
			return exp_compare( l, r, e->flag);
		}
		exp_destroy(l);
		exp_destroy(r);
		return NULL;
	case e_convert:
		l = exp_push_down(sql, e->l, f, t);
		if (l)
			return exp_convert( l, exp_fromtype(e), exp_totype(e));
		exp_destroy(l);
		return NULL;
	case e_aggr:
	case e_func: {
		list *l = e->l, *nl = NULL;

		if (!l) {
			return exp_dup(e);
		} else {
			node *n;

			nl = new_exp_list();
			for(n=l->h; n; n=n->next) {
				sql_exp *arg = n->data;

				arg = exp_push_down(sql, arg, f, t);
				if (!arg) {
					list_destroy(nl);
					return NULL;
				}
				append(nl, arg);
			}
		}
		if (e->type == e_func)
			return exp_op(nl, sql_dup_func(e->f));
		else 
			return exp_aggr(nl, sql_dup_aggr(e->f), e->flag&1, (e->flag>>1), e->card, has_nil(e));
	}	
	case e_atom:
		return exp_dup(e);
	}
	return NULL;
}

/*
 * Push select down, pushes the selects through (simple) projections. Also
 * it cleans up the projections which become useless.
 */
sql_rel *
rel_push_select_down(mvc *sql, sql_rel *rel) 
{
	list *exps = NULL;
	sql_rel *r = NULL;
	node *n;

	(void)sql;
	if ((is_join(rel->op) || is_project(rel->op) || rel->op == op_topn) && rel->l) {
		sql_rel *l = rel->l;
		if (l->op == op_select && !(rel_is_ref(l)) &&
		   (!l->exps || list_length(l->exps) == 0)) {
			rel->l = l->l;
			l->l = NULL;
			rel_destroy(l);
			return rel_push_select_down(sql, rel);
		} 
	}
	if ((is_join(rel->op) || is_set(rel->op)) && rel->r) {
		sql_rel *r = rel->r;
		if (r->op == op_select && !(rel_is_ref(r)) &&
	   	   (!r->exps || list_length(r->exps) == 0)) {
			rel->r = r->l;
			r->l = NULL;
			rel_destroy(r);
			return rel_push_select_down(sql, rel);
		}
	} 
	if (rel->op == op_select && r && !(rel_is_ref(r)) && (r->op == op_select || r->op == op_except)) {
		(void)list_merge(r->exps, rel->exps, (fdup)&exp_dup);
		rel->l = NULL;
		rel_destroy(rel);
		return rel_push_select_down(sql, r);
	}
	exps = rel->exps;
	r = rel->l;
	if (rel->op == op_select && r && is_set(r->op) && !(rel_is_ref(r))) {
		rel->exps = new_exp_list(); 
		for (n = exps->h; n; n = n->next) { 
			sql_exp *e = n->data, *ne = NULL;
			if (e->type == e_cmp) {
				int err = 0;
				ne = exp_push_down(sql, e, r, r->l);
				if (ne && ne != e) {
					sql_exp *re = ne->r;
					if (re->card >= CARD_AGGR) {
						r->l = rel_push_join(r->l, ne->l, re, ne);
					} else {
						r->l = rel_push_select(r->l, ne->l, ne);
					}
				} else 
					err = 1;
				ne = exp_push_down(sql, e, r, r->r);
				if (ne && ne != e) {
					sql_exp *re = ne->r;
					if (re->card >= CARD_AGGR) {
						r->r = rel_push_join(r->r, ne->l, re, ne);
					} else {
						r->r = rel_push_select(r->r, ne->l, ne);
					}
				} else 
					err = 1;

				if (err)
					list_append(rel->exps, exp_dup(e));
			} else {
				list_append(rel->exps, exp_dup(e));
			} 
		}
		list_destroy(exps);
		return rel_push_select_down(sql, r);
	}
	if (rel->op == op_project && r && r->op == op_project && !(rel_is_ref(r))) {
		int all = 1;

		/* here we need to fix aliases */
		rel->exps = new_exp_list(); 
		/* for each exp check if we can rename it */
		for (n = exps->h; n && all; n = n->next) { 
			sql_exp *e = n->data, *ne = NULL;
			sql_rel *prj = r;

			if (e->type != e_column) {
				all = 0;
			} else {	
				ne = exp_push_down(sql, e, prj, prj->l);
				/* can we move it down */
				if (ne && ne != e) {
					/* we need to keep the alias */
					exp_setname(ne, e->rname, e->name);
					list_append(rel->exps, ne);
				} else {
					all = 0;
					exp_destroy(ne);
				}
			}
		}
		if (all) {
			/* we can now remove the intermediate project */
			rel->l = r->l;
			r->l = NULL;
			rel_destroy(r);
			list_destroy(exps);
			return rel_push_select_down(sql, rel);
		} else {
			/* leave as is */
			list_destroy(rel->exps);
			rel->exps = exps;
		}
		return rel;
	} else if (rel->op == op_select && r && r->op == op_project && !(rel_is_ref(r))) {
		/* here we need to fix aliases */
		rel->exps = new_exp_list(); 
		/* for each exp check if we can rename it */
		for (n = exps->h; n; n = n->next) { 
			sql_exp *e = n->data, *ne = NULL, *le, *re;
			sql_rel *prj = r, *nr, *nl;

			/* sometimes we also have functions in the expression list (TODO change them to e_cmp (predicates like (1=0))) */
			if (e->type == e_cmp) {
				ne = exp_push_down(sql, e, prj, prj->l);
				/* can we move it down */
				if (ne && ne != e) {
					nr = prj->l;
				} else {
					nr = rel;
					exp_destroy(ne);
					ne = exp_dup(e);
				}
 				le = ne->l;
				re = ne->r;
				if (re->card >= CARD_AGGR) {
					nl = rel_push_join(nr, le, re, ne);
				} else {
					nl = rel_push_select(nr, le, ne);
				}
				if (nl != nr)
					prj->l = nl;
			} else {
				list_append(rel->exps, exp_dup(e));
			}
		}
		list_destroy(exps);
		return rel;
	}
	return rel;
}

/*
 * Push joins down, pushes the joins through group by expressions. 
 * When the join is on the group by columns, we can push the joins left
 * under the group by.
 */
sql_rel *
rel_push_join_down(mvc *sql, sql_rel *rel) 
{
	list *exps = NULL;
	sql_rel *gb = NULL, *l = NULL;

	(void)sql;
	if ((is_join(rel->op) || is_semi(rel->op)) && rel->l) {
		gb = rel->r;
		exps = rel->exps;
		if (gb->op == op_groupby && gb->r) { 
			list *jes = new_exp_list();
			node *n, *m;
			list *gbes = gb->r;
			/* find out if all group by expressions are 
			   used in the join */
			for(n = gbes->h; n; n = n->next) {
				sql_exp *gbe = n->data;
				int fnd = 0;
				char *rname = (gbe->rname)?gbe->rname:gb->name;
				for (m = exps->h; m && !fnd; m = m->next) {
					sql_exp *je = m->data;

					if (je->card >= CARD_ATOM && je->type == e_cmp) {
						/* expect right expression to match */
						sql_exp *r = je->r;
						if (r->type != e_column)
							continue;
						if (r && r->l && rname && strcmp(r->l, rname) == 0 && strcmp(r->r,gbe->name)==0) {
							fnd = 1;
						} else if (r && !r->l && !rname  && strcmp(r->r,gbe->name)==0) {
							fnd = 1;
						}
						if (fnd) {
							sql_exp *re = exp_push_down(sql, r, gb, gb->l);
							assert(re);
							je = exp_compare(exp_dup(je->l), re, je->flag);
							list_append(jes, je);
						}
					}
				}
				if (!fnd) {
					list_destroy(jes);
					return rel;
				}
			}
			if (is_join(rel->op)) {
				/* push join's left side (as semijoin) down group by */
				l = rel_copy(rel->l);
				/* now we need to translate the names using the join
			   	expressions */
				gb->l = rel_crossproduct(gb->l, l, op_semi);
				l = gb->l;
				l->exps = jes;
			} else { /* semi join */
				/* rewrite group by into project */
				gb->op = op_project;
				list_destroy(gb->r);
				gb->r = NULL;
			}
			return rel;
		} 
	}
	return rel;
}

static int
index_exp(sql_exp *e, sql_idx *i) 
{
	if (e->type == e_cmp) {
		switch(i->type) {
		case hash_idx:
			if (e->flag == cmp_equal)
				return 0;
		case join_idx:
		default:
			return -1;
		}
	}
	return -1;
}

static sql_column *
selectexp_col(sql_exp *e, sql_rel *r) 
{
	sql_table *t = r->l;

	if (e->type == e_cmp) {
		sql_exp *ec = e->l;

		if (ec->type == e_column) {
			char *name = ec->name;
			node *cn;

			if (r->exps) { /* use alias */
				for (cn = r->exps->h; cn; cn = cn->next) {
					sql_exp *ce = cn->data;
					if (strcmp(ce->name, name) == 0) {
						name = ce->r;
						break;
					}
				}
			}
			for (cn = t->columns.set->h; cn; cn = cn->next) {
				sql_column *c = cn->data;
				if (strcmp(c->base.name, name) == 0) 
					return c;
			}
		}
	}
	return NULL;
}

static sql_idx *
find_index(sql_rel *r, list **EXPS)
{
	sql_rel *b;
	sql_table *t;

	if ((b = find_basetable(r)) == NULL) 
		return NULL;

	/* any (partial) match of the expressions with the index columns */
	/* Depending on the index type we may need full matches and only
	   limited number of cmp types (hash only equality etc) */
	/* Depending on the index type we should (in the rel_bin) generate
	   more code, ie for spatial index add post filter etc, for hash
	   compute hash value and use index */
 	t = b->l;
	if (t->idxs.set) {
		node *in;

		/* find the columns involved in the selection over this base table*/
	   	for(in = t->idxs.set->h; in; in = in->next) {
			list *exps, *cols;
	    		sql_idx *i = in->data;
			fcmp cmp = (fcmp)&sql_column_kc_cmp;

			/* join indices are only interesting for joins */
			if (i->type == join_idx || list_length(i->columns) <= 1)
				continue;
			/* based on the index type, find qualifying exps */
			exps = list_select(r->exps, i, (fcmp) &index_exp, (fdup)exp_dup);
			/* now we obtain the columns, move into sql_column_kc_cmp! */
			cols = list_map(exps, b, (fmap) &selectexp_col);

			/* Match the index columns with the expression columns. 
			   TODO, Allow partial matches ! */
			if (list_match(cols, i->columns, cmp) == 0) {
				/* re-order exps in index order */
				node *n, *m;
				list *es = list_create((fdestroy)&exp_destroy);

				for(n = i->columns->h; n; n = n->next) {
					int i = 0;
					for(m = cols->h; m; m = m->next, i++) {
						if (cmp(m->data, n->data) == 0){
							sql_exp *e = list_fetch(exps, i);
							list_append(es, exp_dup(e) );
							break;
						}
					}
				}
				assert(list_length(exps) == list_length(es));
				/* fix the destroy function */
				cols->destroy = NULL;
				list_destroy(cols);
				list_destroy(exps);
				*EXPS = es;
				return i;
			}
			cols->destroy = NULL;
			list_destroy(cols);
			list_destroy(exps);
		}
	}
	return NULL;
}

static sql_rel *
rel_select_use_index(mvc *sql, sql_rel *rel) 
{
	(void)sql;
	if (rel->op == op_select) {
		list *exps = NULL;
		sql_idx *i = find_index(rel, &exps);
			
#ifdef DEBUG
		rel_print(sql, rel, 0);
#endif
		if (i) {
			prop *p;
			node *n;
	
			/* add PROP_HASHIDX to all column exps */
			for( n = exps->h; n; n = n->next) { 
				sql_exp *e = n->data;

				e->p = p = prop_create(PROP_HASHIDX, e->p);
				p->value = i;
			}
			/* add the remaining exps to the new exp list */
			if (list_length(rel->exps) < list_length(exps)) {
				for( n = rel->exps->h; n; n = n->next) {
					sql_exp *e = n->data;
					if (!list_find(exps, e, (fcmp)&exp_cmp))
						list_append(exps, exp_dup(e));
				}
			}
			list_destroy(rel->exps);
			rel->exps = exps;
		}
	}
	return rel;
}

/* TODO CSE */
static list *
exp_merge(list *exps)
{
	node *n, *m;
	for (n=exps->h; n && n->next; n = n->next) {
		sql_exp *e = n->data;
		//sql_exp *le = e->l;
		sql_exp *re = e->r;

		assert(e->type == e_cmp);
		/* only look for gt, gte, lte, lt */
		if (re->card == CARD_ATOM && e->flag < cmp_equal) {
			for (m=n->next; m; m = m->next) {
				sql_exp *f = m->data;
				//sql_exp *lf = f->l;
				sql_exp *rf = f->r;

				assert(f->type == e_cmp);
				if (rf->card == CARD_ATOM && e->flag < cmp_equal) {
					//printf("possible candidate\n");
				}
			}
		}
	}
	return exps;
}

static sql_rel *
rel_select_order(mvc *sql, sql_rel *rel) 
{
	(void)sql;
	if (rel->op == op_select && rel->exps && list_length(rel->exps)>1) {
		list *exps = NULL;
			
#ifdef DEBUG
		rel_print(sql, rel, 0);
#endif
		exps = list_sort(rel->exps, (fkeyvalue)&exp_keyvalue, (fdup)&exp_dup);
		list_destroy(rel->exps);
		rel->exps = exp_merge(exps);
	}
	return rel;
}

static sql_rel *
rewrite(mvc *sql, sql_rel *rel, rewrite_fptr rewriter) 
{
	switch (rel->op) {
	case op_basetable:
	case op_table:
		break;
	case op_join: 
	case op_left: 
	case op_right: 
	case op_full: 

	case op_semi: 
	case op_anti: 

	case op_union: 
	case op_inter: 
	case op_except: 
		rel->l = rewrite(sql, rel->l, rewriter);
		rel->r = rewrite(sql, rel->r, rewriter);
		break;
	case op_project:
	case op_select: 
	case op_groupby: 
	case op_topn: 
		if (rel->l)
			rel->l = rewrite(sql, rel->l, rewriter);
		break;
	}
	if (rel_is_ref(rel))
		return rel;
	return rewriter(sql, rel);
}

sql_rel *
rel_optimizer(mvc *sql, sql_rel *rel) 
{
	global_props gp; 

	memset(&gp, 0, sizeof(global_props));
	rel_properties(sql, &gp, rel);

#ifdef DEBUG
{
	int i;
	for (i = 0; i < MAXOPS; i++) {
		if (gp.cnt[i]> 0)
			printf("%s %d\n", op2string((operator_type)i), gp.cnt[i]);
	}
}
#endif

#ifdef DEBUG
	rel_print(sql, rel, 0);
#endif

	/* TODO add optimizer which removes unions 
		(for example common rels, with only one different expression) */

	/* TODO common sub relation/expression optimizer */

	if (gp.cnt[op_select])
		rel = rewrite(sql, rel, &rel_push_select_down); 

	/* TODO push select up. Sounds bad, but isn't. In case of an join-idx we want the selection on
	   the 'unique/primary (right hand side)' done before the (fake)-join and the selections on the foreign 
	   part done after. */

	if (gp.cnt[op_join] && gp.cnt[op_groupby])
		rel = rewrite(sql, rel, &rel_push_join_down); 

	if (gp.cnt[op_join] || gp.cnt[op_left])
		rel = rewrite(sql, rel, &rel_join_order); 

	if (gp.cnt[op_select])
		rel = rewrite(sql, rel, &rel_select_order); 

	if (gp.cnt[op_select])
		rel = rewrite(sql, rel, &rel_select_use_index); 

#ifdef DEBUG
	rel_print(sql, rel, 0);
#endif

	/* optimize */
	return rel;
}
