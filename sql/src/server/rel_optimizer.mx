@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
@' Copyright August 2008-2009 MonetDB B.V.
@' All Rights Reserved.

@f rel_optimizer
@a N.J. Nes
@* 

@h
#ifndef _REL_OPTIMIZER_H_
#define _REL_OPTIMIZER_H_

#include "rel_semantic.h"

extern sql_rel * rel_optimizer(mvc *sql, sql_rel *rel);

#endif /*_REL_OPTIMIZER_H_*/
@c

/*#define DEBUG*/

#include "sql_config.h"
#include "rel_optimizer.h"
#include "rel_select.h"
#include "rel_prop.h"
#include "rel_exp.h"
#include "rel_dump.h"

typedef struct global_props {
	int cnt[MAXOPS];
} global_props;

typedef sql_rel *(*rewrite_fptr)(int *changes, mvc *sql, sql_rel *rel);
typedef int (*find_prop_fptr)(mvc *sql, sql_rel *rel);

/* The important task of the relational optimizer is to optimize the
   join order. 

   The current implementation chooses the join order based on 
   select counts, ie if one of the join sides has been reduced using
   a select this join is choosen over one without such selections. 
 */

/* currently we only find simple column expressions */
static sql_column *
name_find_column( sql_rel *rel, char *rname, char *name ) 
{
	sql_exp *alias = NULL;
	sql_column *c = NULL;

	switch (rel->op) {
	case op_basetable: {
		node *cn;
		sql_table *t = rel->l;

		if (rel->exps) {
			sql_exp *rename = exps_bind_column(rel->exps, name);
			if (!rename ||
			     rename->type != e_column ||
			    (rename->l && strcmp(t->base.name, rename->l) != 0))
				return NULL;
			name = rename->r;
		}
		for (cn = t->columns.set->h; cn; cn = cn->next) {
			sql_column *c = cn->data;
			if (strcmp(c->base.name, name) == 0) {
				return c;
			}
		}
	}
	case op_table:
		if (rel->exps)
			alias = exps_bind_column(rel->exps, name);
		/* table func */
		return NULL;
	case op_join: 
	case op_left: 
	case op_right: 
	case op_full: 
	case op_semi: 
	case op_anti: 
		/* first right (possible subquery) */
		c = name_find_column( rel->r, rname, name);
		if (!c) 
			c = name_find_column( rel->l, rname, name);
		return c;
	case op_select: 
	case op_union: 
	case op_inter: 
	case op_except: 
	case op_topn: 
		return name_find_column( rel->l, rname, name);
	case op_project:
	case op_groupby: 
		if (!rel->exps)
			break;
		alias = exps_bind_column(rel->exps, name);
		break;
	case op_insert:
	case op_update:
	case op_delete:
		break;
	}
	if (alias) { /* we found an expression with the correct name, but
			we need sql_columns */
		if (alias->type == e_column) /* real alias */
			return name_find_column( rel->l, alias->l, alias->r );
	}
	return NULL;
}

static sql_column *
exp_find_column( sql_rel *rel, sql_exp *exp )
{
	(void)rel;
	if (exp->type == e_column) { 
		return name_find_column(rel, exp->l, exp->r);
	}
	return NULL;
}

static int
join_properties(sql_rel *rel) 
{
	if (rel->exps) {
		list *join_cols = list_create(NULL);
		node *en;

		/* simply using the expressions should also work ! */
		for ( en = rel->exps->h; en; en = en->next ) {
			sql_exp *e = en->data;

			if (e->type == e_cmp && e->flag == cmp_equal) {
				sql_column *lc = exp_find_column(rel, e->l); 
				sql_column *rc = exp_find_column(rel, e->r); 

				if (lc && rc) {
					append(join_cols, lc);
					append(join_cols, rc);
				}
			}
		}
#ifdef DEBUG
		for (en = join_cols->h; en; en = en->next) {
			sql_column *c = en->data;
			printf("j col %s %s\n", c->t->base.name, c->base.name);
		}
#endif
		list_destroy(join_cols);
	}
	return 0;
}

static void
rel_properties(mvc *sql, global_props *gp, sql_rel *rel) 
{
	gp->cnt[(int)rel->op]++;
	switch (rel->op) {
	case op_basetable:
	case op_table:
		break;
	case op_join: 
	case op_left: 
	case op_right: 
	case op_full: 

	case op_semi: 
	case op_anti: 

	case op_union: 
	case op_inter: 
	case op_except: 
		rel_properties(sql, gp, rel->l);
		rel_properties(sql, gp, rel->r);
		break;
	case op_project:
	case op_select: 
	case op_groupby: 
	case op_topn: 
		if (rel->l) 
			rel_properties(sql, gp, rel->l);
		break;
	case op_insert:
	case op_update:
	case op_delete:
		if (rel->r) {
			sql_rel *r = rel->r;

			rel_properties(sql, gp, r);
		}
		break;
	}

	switch (rel->op) {
	case op_basetable:
	case op_table:
		rel->p = prop_create(PROP_COUNT, rel->p);
		break;
	case op_join: 
		join_properties(rel);
		break;
	case op_left: 
	case op_right: 
	case op_full: 

	case op_semi: 
	case op_anti: 

	case op_union: 
	case op_inter: 
	case op_except: 
		break;

	case op_project:
	case op_groupby: 
	case op_topn: 
	case op_select: 
		break;

	case op_insert:
	case op_update:
	case op_delete:
		break;
	}
}

static void
get_relations(sql_rel *rel, list *rels)
{
	if (rel->op == op_join && rel->exps == NULL) {
		get_relations(rel->l, rels);
		get_relations(rel->r, rels);
		rel->l = NULL;
		rel->r = NULL;
		rel_destroy(rel);
	} else {
		append(rels, rel);
	}
}

static int
exp_count(int *cnt, int seqnr, sql_exp *e) 
{
	(void)seqnr;
	if (!e)
		return 0;
	if (find_prop(e->p, PROP_JOINIDX))
		*cnt += 100;
	if (find_prop(e->p, PROP_HASHIDX)) 
		*cnt += 100;
	switch(e->type) {
	case e_cmp:
		switch (e->flag) {
		case cmp_equal:
			*cnt += 10;
			return 10;
		case cmp_notequal:
			*cnt += 7;
			return 7;
		case cmp_gt:
		case cmp_gte:
		case cmp_lt:
		case cmp_lte:
			*cnt += 6;
			if (e->f){ /* range */
				*cnt += 6;
				return 12;
			}
			return 6;
		case cmp_like:
		case cmp_notlike:
			*cnt += 2;
			return 2;
		default:
			return 0;
		}
	default:
		return -5;
	}
}

static int
exp_keyvalue(sql_exp *e) 
{
	int cnt = 0;
	exp_count(&cnt, 0, e);
	return cnt;
}

static int
rel_has_exp(sql_rel *rel, sql_exp *e) 
{
	if (rel_find_exp(rel, e) != NULL) 
		return 0;
	return -1;
}

static sql_rel *
find_rel(list *rels, sql_exp *e)
{
	node *n = list_find(rels, e, (fcmp)&rel_has_exp);
	if (n) 
		return n->data;
	return NULL;
}

static sql_rel *
find_one_rel(list *rels, sql_exp *e)
{
	node *n;
	sql_rel *fnd = NULL;

	for(n = rels->h; n; n = n->next) {
		if (rel_has_exp(n->data, e) == 0) {
			if (fnd)
				return NULL;
			fnd = n->data;
		}
	}
	return fnd;
}

static int
joinexp_cmp(list *rels, sql_exp *h, sql_exp *key)
{
	sql_rel *h_l = find_rel(rels, h->l);
	sql_rel *h_r = find_rel(rels, h->r);
	sql_rel *key_l = find_rel(rels, key->l);
	sql_rel *key_r  = find_rel(rels, key->r);

	assert (h->type == e_cmp && key->type == e_cmp);
	assert (h_l && h_r && key_l && key_r);
	if (h_l == key_l && h_r == key_r)
		return 0;
	if (h_r == key_l && h_l == key_r)
		return 0;
        return -1;
}

static sql_exp *
joinexp_col(sql_exp *e, sql_rel *r)
{
	if (e->type == e_cmp) {
		if (rel_has_exp(r, e->l) >= 0) 
			return exp_dup(e->l);
		return exp_dup(e->r);
	}
	assert(0);
	return NULL;
}

static sql_column *
table_colexp(sql_exp *e, sql_rel *r)
{
	sql_table *t = r->l;

	if (e->type == e_column) {
		char *name = e->name;
		node *cn;

		if (r->exps) { /* use alias */
			for (cn = r->exps->h; cn; cn = cn->next) {
				sql_exp *ce = cn->data;
				if (strcmp(ce->name, name) == 0) {
					name = ce->r;
					break;
				}
			}
		}
		for (cn = t->columns.set->h; cn; cn = cn->next) {
			sql_column *c = cn->data;
			if (strcmp(c->base.name, name) == 0) 
				return c;
		}
	}
	return NULL;
}

static int
exp_joins_rels(sql_exp *e, list *rels)
{
	sql_rel *l, *r;

	assert (e->type == e_cmp);
		
	l = find_rel(rels, e->l);
	r = find_rel(rels, e->r);
	if (l && r)
		return 0;
	return -1;
}

static list *
matching_joins(list *rels, list *exps, sql_exp *je) 
{
	sql_rel *l, *r;

	assert (je->type == e_cmp);
		
	l = find_rel(rels, je->l);
	r = find_rel(rels, je->r);
	if (l && r) {
		list *res;
		list *n_rels = list_create(NULL);	

		append(n_rels, l);
		append(n_rels, r);
		res = list_select(exps, n_rels, (fcmp) &exp_joins_rels, (fdup)exp_dup);
		list_destroy(n_rels);
		return res; 
	}
	return list_create(NULL);
}

static int
sql_column_kc_cmp(sql_column *c, sql_kc *kc)
{
	/* return on equality */
	return (c->colnr - kc->c->colnr);
}

static sql_idx *
find_fk_index(sql_table *l, list *lcols, sql_table *r, list *rcols)
{
	if (l->idxs.set) {
		node *in;
	   	for(in = l->idxs.set->h; in; in = in->next){
	    		sql_idx *li = in->data;
			if (li->type == join_idx) {
		        	sql_idx *ri = ((sql_fkey*)li->key)->rkey->k.idx;
				fcmp cmp = (fcmp)&sql_column_kc_cmp;

              			if (ri->t == r && 
				    list_match(lcols, li->columns, cmp) == 0 &&
				    list_match(rcols, ri->columns, cmp) == 0) {
					return li;
				}
			}
		}
	}
	return NULL;
}

static sql_rel *
find_basetable( sql_rel *r)
{
	if (!r)
		return NULL;
	switch(r->op) {
	case op_basetable:	
		return r;
	case op_select:
		return find_basetable(r->l);
	default:
		return NULL;
	}
}

static list *
find_fk(list *rels, list *exps) 
{
	node *djn;
	list *sdje, *aje, *dje;

	/* first find the distinct join expressions */
	aje = list_select(exps, (void*)1, (fcmp) &exp_is_join, (fdup)exp_dup);
	dje = list_distinct2(aje, rels, (fcmp2) &joinexp_cmp, (fdup)exp_dup);
	for(djn=dje->h; djn; djn = djn->next) {
		/* equal join expressions */
		sql_idx *idx = NULL;
		sql_exp *je = djn->data, *le = je->l, *re = je->r; 

		if (!find_prop(je->p, PROP_JOINIDX)) {
			int swapped = 0;
			list *aaje = matching_joins(rels, aje, je);
			list *eje = list_select(aaje, (void*)1, (fcmp) &exp_is_eqjoin, (fdup) &exp_dup);
			sql_rel *lr = find_rel(rels, le);
			sql_rel *rr = find_rel(rels, re);

			sql_table *l, *r;
			list *lexps = list_map(eje, lr, (fmap) &joinexp_col);
			list *rexps = list_map(eje, rr, (fmap) &joinexp_col);
			list *lcols, *rcols;

			lr = find_basetable(lr);
			rr = find_basetable(rr);
			if (!lr || !rr) {
				list_destroy(lexps);
				list_destroy(rexps);
				list_destroy(eje);
				list_destroy(aaje);
				continue;
			}
			l = lr->l;
			r = rr->l;
			lcols = list_map(lexps, lr, (fmap) &table_colexp);
			rcols = list_map(rexps, rr, (fmap) &table_colexp);
			list_destroy(lexps);
			list_destroy(rexps);
			if (list_length(lcols) != list_length(rcols)) {
				lcols->destroy = NULL;
				rcols->destroy = NULL;
				list_destroy(lcols);
				list_destroy(rcols);
				list_destroy(eje);
				list_destroy(aaje);
				continue;
			}

			idx = find_fk_index(l, lcols, r, rcols); 
			if (!idx) {
				idx = find_fk_index(r, rcols, l, lcols); 
				swapped = 1;
			} 

#ifdef DEBUG
			printf("%s %d %s %d (%d)\n", 
				l->base.name, list_length(lcols),
				r->base.name, list_length(rcols),
				idx?1:0);
#endif
			if (idx) { 	
				prop *p;
				node *n;
	
				/* Remove all other join expressions */
				for (n = eje->h; n; n = n->next) {
					if (je != n->data)
						list_remove_data(exps, n->data);
				}
				/* Add the join index using PROP_JOINIDX  */
				if (swapped) {
					sql_exp *s = je->l;
					je->l = je->r;
					je->r = s;
				}
				je->p = p = prop_create(PROP_JOINIDX, je->p);
				p->value = idx;
			}
			lcols->destroy = NULL;
			rcols->destroy = NULL;
			list_destroy(lcols);
			list_destroy(rcols);
			list_destroy(eje);
			list_destroy(aaje);
		}
	}
	list_destroy(aje);

	/* sort expressions on weighted number of reducing operators */
	sdje = list_sort(dje, (fkeyvalue)&exp_keyvalue, (fdup)&exp_dup);
	list_destroy(dje);

	return sdje;
}

static sql_rel *
order_joins(list *rels, list *exps)
{
	sql_rel *top = NULL, *l = NULL, *r = NULL;
	sql_exp *cje;
	node *djn;
	list *sdje, *n_rels = list_create(NULL);
	int fnd = 0;

	/* find foreign keys and reorder the expressions on reducing quality */
	sdje = find_fk(rels, exps);

	/* open problem, some expressions use more then 2 relations */
	/* For example a.x = b.y * c.z; */
	if (sdje->h) {
		/* get the first expression */
		cje = sdje->h->data;

		/* find the involved relations */

		/* TODO all current code assumes expressions only touch 2 (atmost) 2 base tables, but complex expressions my touch multiple base tables */
		l = find_one_rel(rels, cje->l);
		r = find_one_rel(rels, cje->r);

		if (l && r) {
			list_remove_data(sdje, cje);
			list_remove_data(exps, cje);
		}
	}
	if (l && r) {
		list_remove_data(rels, l);
		list_remove_data(rels, r);
		list_append(n_rels, l);
		list_append(n_rels, r);

		/* Create a relation between l and r. Since the calling 
	   	   functions rewrote the join tree, into a list of expressions 
	   	   and a list of (simple) relations, there are no outer joins 
	   	   involved, we can simply do a crossproduct here.
	 	 */
		top = rel_crossproduct(l, r, op_join);
		rel_join_add_exp(top, exp_dup(cje));

		/* all other join expressions on these 2 relations */
		while((djn = list_find(exps, n_rels, (fcmp)&exp_joins_rels)) != NULL) {
			sql_exp *e = djn->data;

			rel_join_add_exp(top, exp_dup(e));
			list_remove_data(exps, e);
		}
		/* Remove other joins on the current 'n_rels' set in the distinct list too */
		while((djn = list_find(sdje, n_rels, (fcmp)&exp_joins_rels)) != NULL) 
			list_remove_data(sdje, djn->data);
		fnd = 1;
	}
	/* build join tree using the ordered list */
	while(list_length(exps) && fnd) {
		fnd = 0;
		/* find the first expression which could be added */
		for(djn = sdje->h; djn && !fnd; djn = (!fnd)?djn->next:NULL) {
			node *ln, *rn, *en;
			
			cje = djn->data;
			ln = list_find(n_rels, cje->l, (fcmp)&rel_has_exp);
			rn = list_find(n_rels, cje->r, (fcmp)&rel_has_exp);

			if (ln || rn) {
				/* remove the expression from the lists */
				list_remove_data(sdje, cje);
				list_remove_data(exps, cje);
			}
			if (ln && rn) {
				assert(0);
				/* create a selection on the current */
				l = ln->data;
				r = rn->data;
				rel_join_add_exp(top, exp_dup(cje));
				fnd = 1;
			} else if (ln || rn) {
				if (ln) {
					l = ln->data;
					r = find_rel(rels, cje->r);
				} else {
					l = rn->data;
					r = find_rel(rels, cje->l);
				}
				list_remove_data(rels, r);
				append(n_rels, r);

				/* create a join using the current expression */
				top = rel_crossproduct(top, r, op_join);
				rel_join_add_exp(top, exp_dup(cje));

				/* all join expressions on these tables */
				while((en = list_find(exps, n_rels, (fcmp)&exp_joins_rels)) != NULL) {
					sql_exp *e = en->data;
					rel_join_add_exp(top, exp_dup(e));
					list_remove_data(exps, e);
				}
				/* Remove other joins on the current 'n_rels' 
				   set in the distinct list too */
				while((en = list_find(sdje, n_rels, (fcmp)&exp_joins_rels)) != NULL) 
					list_remove_data(sdje, en->data);
				fnd = 1;
			}
		}
	}
	if (list_length(rels)) { /* more relations */
		node *n;
		for(n=rels->h; n; n = n->next) {
			if (top)
				top = rel_crossproduct(top, n->data, op_join);
			else 
				top = n->data;
		}
	}
	if (list_length(exps)) { /* more expressions */
		node *n;
		for(n=exps->h; n; n = n->next) 
			rel_join_add_exp(top, exp_dup(n->data));
	}
	return top;
}

static int
rel_neg_in_size(sql_rel *r)
{
	if (is_union(r->op) && r->nrcols == 0) 
		return -1 + rel_neg_in_size(r->l);
	if (is_project(r->op) && r->nrcols == 0) 
		return -1;
	return 0;
}

static list *
push_in_join_down(list *rels, list *exps)
{
	node *n;
	int restart = 1;
	list *nrels;

	/* we should sort these first, ie small in's before large one's */
	nrels = list_sort(rels, (fkeyvalue)&rel_neg_in_size, (fdup)&rel_dup);

	/* we need to cleanup, the new refs ! */
	rels->destroy = (fdestroy)rel_destroy;
	list_destroy(rels);
	rels = nrels;

	/* one of the rels should be a op_union with nrcols == 0 */
	while(restart) {
	    for(n = rels->h; n; n = n->next) {
		sql_rel *r = n->data;
	
		restart = 0;
		if ((is_union(r->op) || is_project(r->op)) && r->nrcols == 0) {
			/* next step find expression on this relation */
			node *m;
			sql_rel *l = NULL;
			sql_exp *je = NULL;

			for(m = exps->h; !je && m; m = m->next) {
				sql_exp *e = m->data;

				if (e->type == e_cmp && e->flag == cmp_equal) {
					/* in values are on 
						the right of the join */
					if (rel_has_exp(r, e->r) >= 0) 
						je = e;
				}
			}
			/* with this expression find other relation */
			if (je && (l = find_rel(rels, je->l)) != NULL) {
				sql_rel *nr = rel_crossproduct(l, r, op_join);

				rel_join_add_exp(nr, exp_dup(je));
				list_append(rels, nr); 
				list_remove_data(rels, l);
				list_remove_data(rels, r);
				list_remove_data(exps, je);
				restart = 1;
				break;
			}

		}
	    }
	}
	return rels;
}

static sql_rel *
reorder_join(mvc *sql, sql_rel *rel)
{
#ifdef DEBUG
	node *n;
#endif
	list *exps = rel->exps;
	list *rels;

	(void)sql;
	if (!exps) /* crosstable, ie order not important */
		return rel;
	rel->exps = NULL; /* should be all crosstables by now */
 	rels = list_create(NULL);
	if (is_outerjoin(rel->op)) {
		int cnt = 0;
		/* try to use an join index also for outer joins */
		list_append(rels, rel->l);
		list_append(rels, rel->r);
		cnt = list_length(exps);
		rel->exps = find_fk(rels, exps);
		if (list_length(rel->exps) != cnt) {
			list_destroy(rel->exps);
			rel->exps = list_dup(exps, (fdup)&exp_dup);
		}
	} else { 
 		get_relations(rel, rels);
#ifdef DEBUG
		for(n = rels->h; n; n = n->next) 
			rel_print(sql, n->data, 0);
#endif
		rels = push_in_join_down(rels, exps);
		rel = order_joins(rels, exps);
	}
	list_destroy(rels);
	list_destroy(exps);
	return rel;
}

static list *
push_up_join_exps( sql_rel *rel) 
{
	switch(rel->op) {
	case op_join: {
		sql_rel *rl = rel->l;
		sql_rel *rr = rel->r;
		list *l = !rel_is_ref(rl) ? push_up_join_exps(rl): NULL;
		list *r = !rel_is_ref(rr) ? push_up_join_exps(rr): NULL;
		if (l && r) {
			l = list_merge(l, r, (fdup)&exp_dup);
			list_destroy(r);
			r = NULL;
		}
		if (rel->exps) {
			if (l && !r)
				r = l;
			l = list_merge(rel->exps, r, (fdup)&exp_dup);
			list_destroy(r);
		}
		rel->exps = NULL;
		return l;
	}
	default:
		return NULL;
	}
}

static sql_rel *
rel_join_order(int *changes, mvc *sql, sql_rel *rel) 
{
	*changes = 0; 
	if (is_join(rel->op) && rel->exps) {
#ifdef DEBUG
printf("BEFORE\n");
		rel_print(sql, rel, 0);
#endif
		if (rel->op == op_join)
			rel->exps = push_up_join_exps(rel);
		rel = reorder_join(sql, rel);
#ifdef DEBUG
printf("AFTER\n");
		rel_print(sql, rel, 0);
#endif
	}
	return rel;
}

/* exp_rename */
static sql_exp *
exp_rename(mvc *sql, sql_exp *e, sql_rel *f, sql_rel *t) 
{
	sql_exp *ne = NULL, *l, *r, *r2;

	switch(e->type) {
	case e_column:
		if (e->l) { 
			ne = exps_bind_column2(f->exps, e->l, e->r);
			/* if relation name matches expressions relation name, find column based on column name alone */
		} else {
			ne = exps_bind_column(f->exps, e->r);
		}
		if (!ne)
			return exp_dup(e);
		e = NULL;
		if (ne->name && ne->r && ne->l) 
			e = rel_bind_column2(sql, t, ne->l, ne->r);
		if (!e && ne->r)
			e = rel_bind_column(sql, t, ne->r);
		if (!e && exp_is_atom(ne))
			return exp_dup(ne);
		return e;
	case e_cmp: 
		l = exp_rename(sql, e->l, f, t);
		r = exp_rename(sql, e->r, f, t);
		if (e->f) {
			r2 = exp_rename(sql, e->f, f, t);
			if (l && r && r2)
				return exp_compare2( l, r, r2, e->flag);
		} else if (l && r) {
			return exp_compare( l, r, e->flag);
		}
		assert(0);
		exp_destroy(l);
		exp_destroy(r);
		return NULL;
	case e_convert:
		l = exp_rename(sql, e->l, f, t);
		if (l)
			return exp_convert( l, exp_fromtype(e), exp_totype(e));
		exp_destroy(l);
		assert(0);
		return NULL;
	case e_aggr:
	case e_func: {
		list *l = e->l, *nl = NULL;

		if (!l) {
			return exp_dup(e);
		} else {
			node *n;

			nl = new_exp_list();
			for(n=l->h; n; n=n->next) {
				sql_exp *arg = n->data;

				arg = exp_rename(sql, arg, f, t);
				if (!arg) {
					list_destroy(nl);
					return NULL;
				}
				append(nl, arg);
			}
		}
		if (e->type == e_func)
			return exp_op(nl, sql_dup_func(e->f));
		else 
			return exp_aggr(nl, sql_dup_aggr(e->f), e->flag&1, (e->flag>>1), e->card, has_nil(e));
	}	
	case e_atom:
		return exp_dup(e);
	}
	assert(0);
	return NULL;
}

/* push the expression down, ie translate colum references from relation f into expression of relation t */ 
static sql_exp *
exp_push_down(mvc *sql, sql_exp *e, sql_rel *f, sql_rel *t) 
{
	int flag = e->flag;
	sql_exp *ne = NULL, *l, *r, *r2;

	switch(e->type) {
	case e_column:
		if (e->l) { 
			ne = exps_bind_column2(f->exps, e->l, e->r);
			/* if relation name matches expressions relation name, find column based on column name alone */
		}
		if (!ne)
			ne = exps_bind_column(f->exps, e->r);
		if (!ne)
			return NULL;
		e = NULL;
		if (ne->name && ne->r && ne->l) 
			e = rel_bind_column2(sql, t, ne->l, ne->r);
		if (!e && ne->r)
			e = rel_bind_column(sql, t, ne->r);
		if (e && flag)
			e->flag = flag;
		/* if the upper exp was an alias, keep this */ 
		if (e && ne->rname) 
			exp_setname(e, ne->rname, ne->name);
		return e;
	case e_cmp: 
		l = exp_push_down(sql, e->l, f, t);
		r = exp_push_down(sql, e->r, f, t);
		if (e->f) {
			r2 = exp_push_down(sql, e->f, f, t);
			if (l && r && r2)
				return exp_compare2( l, r, r2, e->flag);
		} else if (l && r) {
			return exp_compare( l, r, e->flag);
		}
		exp_destroy(l);
		exp_destroy(r);
		return NULL;
	case e_convert:
		l = exp_push_down(sql, e->l, f, t);
		if (l)
			return exp_convert( l, exp_fromtype(e), exp_totype(e));
		return NULL;
	case e_aggr:
	case e_func: {
		list *l = e->l, *nl = NULL;

		if (!l) {
			return exp_dup(e);
		} else {
			node *n;

			nl = new_exp_list();
			for(n=l->h; n; n=n->next) {
				sql_exp *arg = n->data;

				arg = exp_push_down(sql, arg, f, t);
				if (!arg) {
					list_destroy(nl);
					return NULL;
				}
				append(nl, arg);
			}
		}
		if (e->type == e_func)
			return exp_op(nl, sql_dup_func(e->f));
		else 
			return exp_aggr(nl, sql_dup_aggr(e->f), e->flag&1, (e->flag>>1), e->card, has_nil(e));
	}	
	case e_atom:
		return exp_dup(e);
	}
	return NULL;
}

/* some projections results are order dependend (row_number etc) */
static int 
project_unsafe(sql_rel *rel)
{
	node *n;

	if (need_distinct(rel))
		return 1;
	if (!rel->exps)
		return 0;
	for(n = rel->exps->h; n; n = n->next) {
		sql_exp *e = n->data;

		/* aggr func in project ! */
		if (e->type == e_func && e->card == 1)
			return 1;
	}
	return 0;
}

static int
exps_save(list *exps)
{
	node *n;

	for (n = exps->h; n; n = n->next) {
		sql_exp *e = n->data, *l = e->l, *r = e->r;

		if (e->type != e_cmp) 
			return 0;
		if (l->type != e_column && l->type != e_atom && l->type != e_convert)
			return 0;
		if (r->type != e_column && r->type != e_atom && r->type != e_convert)
			return 0;
		if (l->type == e_convert && ((sql_exp*)l->l)->type != e_atom)
			return 0;
		if (r->type == e_convert && ((sql_exp*)r->l)->type != e_atom)
			return 0;
	}
	return 1;
}

/*
 * Push TopN (only LIMIT, no ORDER BY) down through projections underneath crossproduct, i.e.,
 *
 *     topn(                          topn(
 *         project(                       project(
 *             crossproduct(                  crossproduct(
 *                 L,           =>                topn( L )[ n ],
 *                 R                              topn( R )[ n ]
 *             )                              )
 *         )[ Cs ]*                       )[ Cs ]*
 *     )[ n ]                         )[ n ]
 *
 *  (TODO: in case of n==1 we can omit the original top-level TopN)
 */
static sql_rel *
rel_push_topn_down(int *changes, mvc *sql, sql_rel *rel) 
{
	sql_rel *r = rel->l;

	(void)sql;
	if (rel->op == op_topn) {
		/* pass through projections */
		while (r && is_project(r->op) && !(rel_is_ref(r))) {
			/* ensure there is no order by */
			if (!r->r) {
				r = r->l;
			} else {
				r = NULL;
			}
		}
		/* push topn under crossproduct */
		if (r && !r->exps && r->op == op_join && !(rel_is_ref(r)) &&
		    ((sql_rel *)r->l)->op != op_topn && ((sql_rel *)r->r)->op != op_topn) {
			r->l = rel_topn( r->l, list_dup(rel->exps, (fdup)&exp_dup) );
			r->r = rel_topn( r->r, list_dup(rel->exps, (fdup)&exp_dup) );
			(*changes)++;
			return rel;
		}
	}
	return rel;
}

/*
 * Push select down, pushes the selects through (simple) projections. Also
 * it cleans up the projections which become useless.
 */
static sql_rel *
rel_push_select_down(int *changes, mvc *sql, sql_rel *rel) 
{
	list *exps = NULL;
	sql_rel *r = NULL;
	node *n;

	(void)sql;
	/* remove empty select's */
	if ((is_join(rel->op) || is_semi(rel->op) || is_project(rel->op) || rel->op == op_topn) && rel->l) {
		sql_rel *l = rel->l;
		if (l->op == op_select && !(rel_is_ref(l)) &&
		   (!l->exps || list_length(l->exps) == 0)) {
			rel->l = l->l;
			l->l = NULL;
			rel_destroy(l);
			(*changes)++;
			return rel;
		} 
	}
	if ((is_join(rel->op) || is_semi(rel->op) || is_set(rel->op)) && rel->r) {
		sql_rel *r = rel->r;
		if (r->op == op_select && !(rel_is_ref(r)) &&
	   	   (!r->exps || list_length(r->exps) == 0)) {
			rel->r = r->l;
			r->l = NULL;
			rel_destroy(r);
			(*changes)++;
			return rel;
		}
	} 
	/* merge 2 selects */
	r = rel->l;
	if (rel->op == op_select && r && !(rel_is_ref(r)) && (r->op == op_select || r->op == op_except) && exps_save(rel->exps)) {
		(void)list_merge(r->exps, rel->exps, (fdup)&exp_dup);
		rel->l = NULL;
		rel_destroy(rel);
		(*changes)++;
		return r;
	}
	/* push select through semi/anti join 
	 * select (semi(A,B)) == semi(select(A), B) */
	if (rel->op == op_select && r && is_semi(r->op) && !(rel_is_ref(r))) {
		rel->l = r->l;
		r->l = rel;
		(*changes)++;
		return r;
	}
	exps = rel->exps;

	/* push select through join */
	if (rel->op == op_select && r && r->op == op_join && !(rel_is_ref(r))) {
		rel->exps = new_exp_list(); 
		for (n = exps->h; n; n = n->next) { 
			sql_exp *e = exp_dup(n->data);
			if (e->type == e_cmp) {
				sql_exp *re = e->r;

				if (re->card >= CARD_AGGR) {
					list_append(rel->exps, e);
				} else {
					rel->l = rel_push_select(r, e->l, e);
					/* only pushed down selects are counted */
					if (r == rel->l) {
						(*changes)++;
					} else { /* Not useful to introduce an extra select */
						sql_rel *r = rel->l;

						rel->l = r->l;
						r->l = NULL;
						list_append(rel->exps, exp_dup(e));
						rel_destroy(r);
						
					}
					assert(r == rel->l);
				}
			} else {
				list_append(rel->exps, e);
			} 
		}
		list_destroy(exps);
		if (!list_length(rel->exps)) {
			r = rel->l;
			rel->l = NULL;
			rel_destroy(rel);
			return r;
		}
		return rel;
	}

	/* push select through set */
	if (rel->op == op_select && r && is_set(r->op) && !(rel_is_ref(r))) {
		rel->exps = new_exp_list(); 
		for (n = exps->h; n; n = n->next) { 
			sql_exp *e = n->data, *ne = NULL;
			if (e->type == e_cmp) {
				int err = 0;
				ne = exp_push_down(sql, e, r, r->l);
				if (ne && ne != e) {
					sql_exp *re = ne->r;
					if (re->card >= CARD_AGGR) {
						r->l = rel_push_join(r->l, ne->l, re, ne);
					} else {
						r->l = rel_push_select(r->l, ne->l, ne);
					}
				} else 
					err = 1;
				ne = exp_push_down(sql, e, r, r->r);
				if (ne && ne != e) {
					sql_exp *re = ne->r;
					if (re->card >= CARD_AGGR) {
						r->r = rel_push_join(r->r, ne->l, re, ne);
					} else {
						r->r = rel_push_select(r->r, ne->l, ne);
					}
				} else 
					err = 1;

				if (err)
					list_append(rel->exps, exp_dup(e));
			} else {
				list_append(rel->exps, exp_dup(e));
			} 
		}
		list_destroy(exps);
		(*changes)++;
		return r;
	}

	/* merge projects */
	if (rel->op == op_project && r && r->op == op_project && !(rel_is_ref(r))) {
		int all = 1;

		/* here we need to fix aliases */
		rel->exps = new_exp_list(); 
		/* for each exp check if we can rename it */
		for (n = exps->h; n && all; n = n->next) { 
			sql_exp *e = n->data, *ne = NULL;
			sql_rel *prj = r;

			if (e->type != e_column) {
				all = 0;
			} else {	
				ne = exp_push_down(sql, e, prj, prj->l);
				/* can we move it down */
				if (ne && ne != e) {
					char *tname = e->rname;
					/* we need to keep the alias */
					if (!tname && ne->rname) {
						tname = ne->rname;
						ne->rname = NULL;  /* prevent from being freed prematurely in exp_setname */
					}
					exp_setname(ne, tname, e->name);
					if (tname && tname != e->rname) {
						/* tname == old ne->rname, so need to free */
						_DELETE(tname);
					}
					list_append(rel->exps, ne);
				} else {
					all = 0;
					exp_destroy(ne);
				}
			}
		}
		if (all) {
			/* we can now remove the intermediate project */
			/* push order by expressions */
			if (rel->r) {
				list *nr = new_exp_list(), *res = rel->r; 
				for (n = res->h; n; n = n->next) { 
					sql_exp *e = n->data, *ne = NULL;
					sql_rel *prj = r;
	
					ne = exp_push_down(sql, e, prj, prj->l);
					/* can we move it down */
					if (ne && ne != e) {
						char *tname = e->rname;
						/* we need to keep the alias */
						if (!tname && ne->rname) {
							tname = ne->rname;
							ne->rname = NULL;  /* prevent from being freed prematurely in exp_setname */
						}
						exp_setname(ne, tname, e->name);
						if (tname && tname != e->rname) {
							/* tname == old ne->rname, so need to free */
							_DELETE(tname);
						}
						list_append(nr, ne);
					} else {
						all = 0;
						exp_destroy(ne);
					}
				}
				if (all) {
					list_destroy(res);
					rel->r = nr;
				} else {
					/* leave as is */
					list_destroy(nr);
					list_destroy(rel->exps);
					rel->exps = exps;
					return rel;
				}
			}
			rel->l = r->l;
			r->l = NULL;
			rel_destroy(r);
			list_destroy(exps);
			(*changes)++;
		} else {
			/* leave as is */
			list_destroy(rel->exps);
			rel->exps = exps;
		}
		return rel;
	/* push select through project */
	} else if (rel->op == op_select && r && r->op == op_project && !(rel_is_ref(r)) && exps_save(exps)) {
		/* we cannot push through rank (row_number etc) functions or
		   projects with distinct */
		if (project_unsafe(r))
			return rel;

		/* here we need to fix aliases */
		rel->exps = new_exp_list(); 
		/* for each exp check if we can rename it */
		for (n = exps->h; n; n = n->next) { 
			sql_exp *e = n->data, *ne = NULL, *le, *re;
			sql_rel *prj = r, *nr, *nl;

			/* sometimes we also have functions in the expression list (TODO change them to e_cmp (predicates like (1=0))) */
			if (e->type == e_cmp) {
				ne = exp_push_down(sql, e, prj, prj->l);

				/* can we move it down */
				if (ne && ne != e) {
					(*changes)++;
					nr = prj->l;
				} else {
					nr = rel;
					exp_destroy(ne);
					ne = exp_dup(e);
				}
 				le = ne->l;
				re = ne->r;
				if (re->card >= CARD_AGGR) {
					nl = rel_push_join(nr, le, re, ne);
				} else {
					nl = rel_push_select(nr, le, ne);
				}
				if (nl != nr)
					prj->l = nl;
			} else {
				list_append(rel->exps, exp_dup(e));
			}
		}
		list_destroy(exps);
		return rel;
	}
	return rel;
}

/*
 * Push joins down, pushes the joins through group by expressions. 
 * When the join is on the group by columns, we can push the joins left
 * under the group by.
 */
sql_rel *
rel_push_join_down(int *changes, mvc *sql, sql_rel *rel) 
{
	list *exps = NULL;
	sql_rel *gb = NULL, *l = NULL;

	(void)sql;
	*changes = 0;

	if (((is_join(rel->op) && rel->exps) || is_semi(rel->op)) && rel->l) {
		gb = rel->r;
		exps = rel->exps;
		if (gb->op == op_groupby && gb->r && list_length(gb->r)) { 
			list *jes = new_exp_list();
			node *n, *m;
			list *gbes = gb->r;
			/* find out if all group by expressions are 
			   used in the join */
			for(n = gbes->h; n; n = n->next) {
				sql_exp *gbe = n->data;
				int fnd = 0;
				char *rname = gbe->rname;
				for (m = exps->h; m && !fnd; m = m->next) {
					sql_exp *je = m->data;

					if (je->card >= CARD_ATOM && je->type == e_cmp) {
						/* expect right expression to match */
						sql_exp *r = je->r;
						if (r->type != e_column)
							continue;
						if (r && r->l && rname && strcmp(r->l, rname) == 0 && strcmp(r->r,gbe->name)==0) {
							fnd = 1;
						} else if (r && !r->l && !rname  && strcmp(r->r,gbe->name)==0) {
							fnd = 1;
						}
						if (fnd) {
							sql_exp *re = exp_push_down(sql, r, gb, gb->l);
							assert(re);
							je = exp_compare(exp_dup(je->l), re, je->flag);
							list_append(jes, je);
						}
					}
				}
				if (!fnd) {
					list_destroy(jes);
					return rel;
				}
			}
			if (is_join(rel->op)) {
				/* push join's left side (as semijoin) down group by */
				/*l = rel_copy(rel->l);*/
				l = rel_dup(rel_dup(rel->l));
				/* now we need to translate the names using the join expressions */
				gb->l = rel_crossproduct(gb->l, l, op_semi);
				l = gb->l;
				l->exps = jes;
			} else { /* semi join */
				/* rewrite group by into project */
				gb->op = op_project;
				list_destroy(gb->r);
				gb->r = NULL;
			}
			return rel;
		} 
	}
	return rel;
}

static sql_exp *
rel_find_aggr_exp( sql_rel *rel, list *exps, sql_exp *e, char *name)
{
 	list *ea = e->l;
	sql_exp *a = NULL, *eae;
	node *n;

	(void)rel;
	if (list_length(ea) != 1)
		return NULL;
	eae = ea->h->data;
	if (eae->type != e_column)
		return NULL;
	for( n = exps->h; n; n = n->next) {
		a = n->data;
		
		if (a->type == e_aggr) {
			sql_subaggr *af = a->f;
			list *aa = a->l;
			
			/* TODO handle distinct and no-nil etc ! */
			if (strcmp(af->aggr->base.name, name) == 0 &&
				/* TODO handle count (has no args!!) */
			    aa && list_length(aa) == 1) {
				sql_exp *aae = aa->h->data;

				if (eae->type == e_column &&
				    ((!aae->l && !eae->l) ||
				    (aae->l && eae->l &&
				    strcmp(aae->l, eae->l) == 0)) &&
				    (aae->r && eae->r &&
				    strcmp(aae->r, eae->r) == 0)) 
					return exp_column(a->rname, exp_name(a), exp_subtype(a), a->card, has_nil(a), is_intern(a));
			}
		}
	}
	return NULL;
}

static sql_subfunc *
find_func( mvc *sql, char *name, list *exps )
{
	list * l = list_create(NULL); 
	node *n;

	for(n = exps->h; n; n = n->next)
		append(l, exp_subtype(n->data)); 
	return sql_bind_func_(sql->session->schema, name, l);
}

/* rewrite avg into sum/count */
static sql_rel *
rel_avg2sum_count(int *changes, mvc *sql, sql_rel *rel) 
{
	*changes = 0;
	if (is_groupby(rel->op)) {
		list *pexps, *nexps = new_exp_list(), *avgs = new_exp_list();
		node *m, *n;

		/* Find all avg's */
		for (m = rel->exps->h; m; m = m->next) {
			sql_exp *e = exp_dup(m->data);

			if (e->type == e_aggr) {
				sql_subaggr *a = e->f;
				
				if (strcmp(a->aggr->base.name, "avg") == 0) {
					list *exps = e->l;
					sql_exp *ae = exps->h->data;

					/* 
					   FOR NOW ESCAPE ON AVG ON DECIMALS,
					   we need a rewrite or DEC's in 
					   the optimizer to solve this problem
					*/
					if (exp_subtype(ae)->type->eclass == EC_DEC)
						return rel;
					append(avgs, e);
					continue; 
				}
			}
			append(nexps, e);
		}
		if (!list_length(avgs))  
			return rel;

		/* For each avg, find count and sum */
		for (m = avgs->h; m; m = m->next) {
			list *args;
			sql_exp *avg = m->data, *navg, *cond, *cnt_d;
			sql_exp *cnt = rel_find_aggr_exp(rel, nexps, avg, "count");
			sql_exp *sum = rel_find_aggr_exp(rel, nexps, avg, "sum");
			sql_subfunc *div, *ifthen, *cmp;
			sql_subtype *dbl_t;
			char *rname = NULL, *name = NULL;

			rname = avg->rname;
			name = avg->name;
			if (!cnt) {
				list *l = avg->l;
				sql_subaggr *cf = sql_bind_aggr(sql->session->schema, "count", exp_subtype(l->h->data));
				sql_exp *e = exp_aggr(list_dup(avg->l, (fdup)&exp_dup), cf, need_distinct(avg), has_no_nil(avg), avg->card, has_nil(avg));

				exp_label(e, ++sql->label);
				append(nexps, e);
				cnt = exp_column(NULL, exp_name(e), exp_subtype(e), e->card, has_nil(e), is_intern(e));
			}
			if (!sum) {
				list *l = avg->l;
				sql_subaggr *sf = sql_bind_aggr(sql->session->schema, "sum", exp_subtype(l->h->data));
				sql_exp *e = exp_aggr(list_dup(avg->l, (fdup)&exp_dup), sf, need_distinct(avg), has_no_nil(avg), avg->card, has_nil(avg));

				exp_label(e, ++sql->label);
				append(nexps, e);
				sum = exp_column(NULL, exp_name(e), exp_subtype(e), e->card, has_nil(e), is_intern(e));
			}
			/* create new sum/cnt exp */

			/* For now we always convert to dbl */
			dbl_t = sql_bind_localtype("dbl");
			cnt_d = exp_convert(cnt, exp_subtype(cnt), dbl_t);
			sum = exp_convert(sum, exp_subtype(sum), dbl_t);

			args = new_exp_list();
			append(args, exp_dup(cnt));
			append(args, exp_atom_wrd(0));
			cmp = find_func(sql, "=", args);
			assert(cmp);
			cond = exp_op(args, cmp);

			args = new_exp_list();
			append(args, cond);
			append(args, exp_atom(atom_general(dbl_t, NULL, 0)));
			append(args, cnt_d);
			ifthen = find_func(sql, "ifthenelse", args);
			assert(ifthen);
			cnt_d = exp_op(args, ifthen);

			args = new_exp_list();
			append(args, sum);
			append(args, cnt_d);
			div = find_func(sql, "sql_div", args);
			assert(div);
			navg = exp_op(args, div);

			exp_setname(navg, rname, name );
			m->data = navg; 
		}
		pexps = new_exp_list();
		for (m = rel->exps->h, n = avgs->h; m; m = m->next) {
			sql_exp *e = exp_dup(m->data);

			if (e->type == e_aggr) {
				sql_subaggr *a = e->f;
				
				if (strcmp(a->aggr->base.name, "avg") == 0) {
					sql_exp *avg = exp_dup(n->data);

					append(pexps, avg);
					n = n->next;
					continue; 
				}
			}
			append(pexps, exp_column(e->rname, exp_name(e), exp_subtype(e), e->card, has_nil(e), is_intern(e)));
		}
		rel->exps = nexps;
		rel = rel_project(rel, pexps);
		*changes = 1;
	}
	return rel;
}

/* Pushing projects up the tree. Done very early in the optimizer.
 * Makes later steps easier. 
 */
sql_rel *
rel_push_project_up(int *changes, mvc *sql, sql_rel *rel) 
{
	/* project/project cleanup is done later */
	if (is_join(rel->op) || is_select(rel->op)) {
		node *n;
		list *exps = NULL, *l_exps, *r_exps;
		sql_rel *l = rel->l;
		sql_rel *r = rel->r;
		sql_rel *t;

		/* Don't rewrite refs, non projections or constant or 
		   order by projections  */
		if (!l || rel_is_ref(l) || 
		   (is_join(rel->op) && (!r || rel_is_ref(r))) ||
		   (is_select(rel->op) && l->op != op_project) ||
		   (is_join(rel->op) && l->op != op_project && r->op != op_project) ||
		  ((l->op == op_project && (!l->l || l->r || project_unsafe(l))) ||
		   (is_join(rel->op) && 
		    r->op == op_project && (!r->l || r->r || project_unsafe(r))))) 
			return rel;

		if (l->op == op_project && l->l) {
			/* Go through the list of project expressions.
			   Check if they can be pushed up, ie are they not
			   changing or introducing any columns used
			   by the upper operator. */

			exps = new_exp_list();
			for (n = l->exps->h; n; n = n->next) { 
				sql_exp *e = exp_dup(n->data);

				if (is_column(e->type) && exp_is_atom(e)) {
					list_append(exps, e);
				} else if (e->type == e_column) {
					if (e->name && e->name[0] == 'L')
						return rel;
					list_append(exps, e);
				} else {
					return rel;
				}
			}
		} else {
			exps = rel_projections(sql, l, NULL, 1, 1);
		}
		/* also handle right hand of join */
		if (is_join(rel->op) && r->op == op_project && r->l) {
			/* Here we also check all expressions of r like above
			   but also we need to check for ambigious names. */ 

			for (n = r->exps->h; n; n = n->next) { 
				sql_exp *e = exp_dup(n->data);

				if (is_column(e->type) && exp_is_atom(e)) {
					list_append(exps, e);
				} else if (e->type == e_column) {
					if (e->name && e->name[0] == 'L')
						return rel;
					list_append(exps, e);
				} else {
					return rel;
				}
			}
		} else if (is_join(rel->op)) {
			list *r_exps = rel_projections(sql, r, NULL, 1, 1);

			list_merge(exps, r_exps, (fdup)&exp_dup);
			list_destroy(r_exps);
		}
		/* Here we should check for ambigious names ? */
		if (is_join(rel->op) && r) {
			t = (l->op == op_project && l->l)?l->l:l;
			l_exps = rel_projections(sql, t, NULL, 1, 1);
			t = (r->op == op_project && r->l)?r->l:r;
			r_exps = rel_projections(sql, t, NULL, 1, 1);
			for(n = l_exps->h; n; n = n->next) {
				sql_exp *e = n->data;
	
				if (exp_is_atom(e))
					continue;
				if ((e->l && exps_bind_column2(r_exps, e->l, e->r) != NULL) || 
				   (exps_bind_column(r_exps, e->r) != NULL && (!e->l || !e->r)))
					return rel;
			}
			list_destroy(l_exps);
			list_destroy(r_exps);
		}

		/* rename operator expressions */
		if (l->op == op_project) {
			/* rewrite rel from rel->l into rel->l->l */
			if (rel->exps) {
				list *nexps = new_exp_list();

				for (n = rel->exps->h; n; n = n->next) {
					sql_exp *e = exp_dup(n->data);
	
					e = exp_rename(sql, e, l, l->l);
					assert(e);
					list_append(nexps, e);
				}
				list_destroy(rel->exps);
				rel->exps = nexps;
			}
			rel->l = l->l;
			l->l = NULL;
			rel_destroy(l);
		}
		if (is_join(rel->op) && r->op == op_project) {
			/* rewrite rel from rel->r into rel->r->l */
			if (rel->exps) {
				list *nexps = new_exp_list();

				for (n = rel->exps->h; n; n = n->next) {
					sql_exp *e = exp_dup(n->data);

					e = exp_rename(sql, e, r, r->l);
					assert(e);
					list_append(nexps, e);
				}
				list_destroy(rel->exps);
				rel->exps = nexps;
			}
			rel->r = r->l;
			r->l = NULL;
			rel_destroy(r);
		} 
		/* Done, ie introduce new project */
		exps_fix_card(exps, rel->card);
		rel = rel_project(rel, exps);
		*changes = 1;
		return rel;
	}
	return rel;
}

static void
exp_mark_used(sql_rel *subrel, sql_exp *e)
{
	sql_exp *ne = NULL;

	switch(e->type) {
	case e_column:
		ne = rel_find_exp(subrel, e);
		break;
	case e_convert:
		exp_mark_used(subrel, e->l);
		break;
	case e_aggr:
	case e_func: {
		if (e->l) {
			list *l = e->l;
			node *n = l->h;
	
			for (;n != NULL; n = n->next) 
				exp_mark_used(subrel, n->data);
		}
		/* rank operators have a second list of arguments */
		if (e->r) {
			list *l = e->r;
			node *n = l->h;
	
			for (;n != NULL; n = n->next) 
				exp_mark_used(subrel, n->data);
		}
		break;
	}
	case e_cmp:
		exp_mark_used(subrel, e->l);
		exp_mark_used(subrel, e->r);
		if (e->f)
			exp_mark_used(subrel, e->f);
		break;
	case e_atom:
		/* atoms are used in e_cmp */
		e->used = 1;
		break;
	}
	if (ne)
		ne->used = 1;
}

static void
exps_mark_used(sql_rel *rel, sql_rel *subrel)
{
	if (rel->exps) {
		node *n;
		for (n=rel->exps->h; n; n = n->next) {
			sql_exp *e = n->data;

			exp_mark_used(subrel, e);
		}
	}
	if (rel->r && (rel->op == op_project || rel->op  == op_groupby)) {
		list *l = rel->r;
		node *n;

		for (n=l->h; n; n = n->next) {
			sql_exp *e = n->data;

			exp_mark_used(rel, e);
			/* possibly project/groupby uses columns from the inner */ 
			exp_mark_used(subrel, e);
		}
	}
}

static void
exps_used(list *l)
{
	node *n;

	if (l) {
		for (n = l->h; n; n = n->next) {
			sql_exp *e = n->data;
	
			e->used = 1;
		}
	}
}

static void
rel_used(sql_rel *rel)
{
	if (is_topn(rel->op))
		rel = rel->l;
	if (rel->exps) {
		exps_used(rel->exps);
		if (rel->r && (rel->op == op_project || rel->op  == op_groupby))
			exps_used(rel->r);
	}
}

static void
rel_mark_used(mvc *sql, sql_rel *rel, int proj)
{
	(void)sql;
	switch(rel->op) {
	case op_basetable:
	case op_table:
		break;

	case op_topn: 
		if (proj)
			rel = rel ->l;
	case op_project:
	case op_groupby: 
		if (proj && rel->l) {
			exps_mark_used(rel, rel->l);
			rel_mark_used(sql, rel->l, 0);
		}
		break;
	case op_insert:
	case op_update:
	case op_delete:
		break;

	case op_select: 
		if (rel->l) {
			exps_mark_used(rel, rel->l);
			rel_mark_used(sql, rel->l, 0);
		}
		break;

	case op_union: 
	case op_inter: 
	case op_except: 
		/* For now we mark all union expression as used */

		/* Later we should (in case of union all) remove unused
		 * columns from the projection.
		 * 
 		 * Project part of union is based on column position.
		 */
		if (proj) {
			/* properly mark left/right based on exps list */
			rel_used(rel->l);
			rel_used(rel->r);
			rel_mark_used(sql, rel->l, 0);
			rel_mark_used(sql, rel->r, 0);
		}
		break;

	case op_join: 
	case op_left: 
	case op_right: 
	case op_full: 
	case op_semi: 
	case op_anti: 
		exps_mark_used(rel, rel->l);
		exps_mark_used(rel, rel->r);
		rel_mark_used(sql, rel->l, 0);
		rel_mark_used(sql, rel->r, 0);
		break;
	}
}

static sql_rel * rel_dce_sub(mvc *sql, sql_rel *rel);

static sql_rel *
rel_remove_unused(mvc *sql, sql_rel *rel) 
{
	if (!rel || rel_is_ref(rel))
		return rel;

	switch(rel->op) {
	case op_basetable:
	case op_table:
		if (rel->exps) {
			node *n;
			list *exps = new_exp_list();

			for(n=rel->exps->h; n; n = n->next) {
				sql_exp *e = n->data;

				if (e->used || is_intern(e))
					append(exps, exp_dup(e));
			}
			/* atleast one (needed for crossproducts, count(*), rank() and single value projections) ! */
			if (list_length(exps) == 0) {
				sql_exp *e = rel->exps->h->data;
				append(exps, exp_dup(e));
			}
			list_destroy(rel->exps);
			rel->exps = exps;
		}
		return rel;

	case op_topn: 

		if (rel->l)
			rel->l = rel_remove_unused(sql, rel->l);
		return rel;

	case op_project:
	case op_groupby: 

		if (rel->l && rel->exps) {
			node *n;
			list *exps = new_exp_list();

			for(n=rel->exps->h; n; n = n->next) {
				sql_exp *e = n->data;

				if (e->used || is_intern(e))
					append(exps, exp_dup(e));
			}
			/* atleast one (needed for crossproducts, count(*), rank() and single value projections) ! */
			if (list_length(exps) == 0) {
				sql_exp *e = rel->exps->h->data;
				append(exps, exp_dup(e));
			}
			list_destroy(rel->exps);
			rel->exps = exps;
		}
		return rel;

	case op_insert:
	case op_update:
	case op_delete:

	case op_select: 

	case op_union: 
	case op_inter: 
	case op_except: 
		/* We cannot remove here as set projection are based on column
		   position */

	case op_join: 
	case op_left: 
	case op_right: 
	case op_full: 
	case op_semi: 
	case op_anti: 
		return rel;
	}
	return rel;
}

static sql_rel * rel_dce_sub(mvc *sql, sql_rel *rel);

static sql_rel *
rel_dce_down(mvc *sql, sql_rel *rel, int skip_proj) 
{
	if (!rel)
		return rel;

	switch(rel->op) {
	case op_basetable:
	case op_table:

		if (!skip_proj)
			rel_dce_sub(sql, rel);

	case op_insert:
	case op_update:
	case op_delete:

		return rel;

	case op_topn: 
	case op_project:
	case op_groupby: 

		if (skip_proj && rel->l)
			rel->l = rel_dce_down(sql, rel->l, is_topn(rel->op));
		if (!skip_proj)
			rel_dce_sub(sql, rel);
		return rel;

	case op_union: 
	case op_inter: 
	case op_except: 
		if (skip_proj) {
			if (rel->l)
				rel->l = rel_dce_down(sql, rel->l, 0);
			if (rel->r)
				rel->r = rel_dce_down(sql, rel->r, 0);
		}
		if (!skip_proj)
			rel_dce_sub(sql, rel);
		return rel;

	case op_select: 
		if (rel->l)
			rel->l = rel_dce_down(sql, rel->l, 0);
		return rel;

	case op_join: 
	case op_left: 
	case op_right: 
	case op_full: 
	case op_semi: 
	case op_anti: 
		if (rel->l)
			rel->l = rel_dce_down(sql, rel->l, 0);
		if (rel->r)
			rel->r = rel_dce_down(sql, rel->r, 0);
		return rel;
	}
	return rel;
}

/* DCE
 *
 * Based on top relation expressions mark sub expressions as used.
 * Then recurse down until the projections. Clean them up and repeat.
 */
static sql_rel *
rel_dce_sub(mvc *sql, sql_rel *rel)
{
	if (!rel)
		return rel;

	rel = rel_remove_unused(sql, rel);
	/* mark used up until the next project */
	rel_mark_used(sql, rel, 1);
	rel_dce_down(sql, rel, 1);
	return rel;
}

static sql_rel *
rel_dce(mvc *sql, sql_rel *rel)
{
	rel_used(rel);
	rel_dce_sub(sql, rel);
	return rel;
}

static int
index_exp(sql_exp *e, sql_idx *i) 
{
	if (e->type == e_cmp) {
		switch(i->type) {
		case hash_idx:
			if (e->flag == cmp_equal)
				return 0;
		case join_idx:
		default:
			return -1;
		}
	}
	return -1;
}

static sql_column *
selectexp_col(sql_exp *e, sql_rel *r) 
{
	sql_table *t = r->l;

	if (e->type == e_cmp) {
		sql_exp *ec = e->l;

		if (ec->type == e_column) {
			char *name = ec->name;
			node *cn;

			if (r->exps) { /* use alias */
				for (cn = r->exps->h; cn; cn = cn->next) {
					sql_exp *ce = cn->data;
					if (strcmp(ce->name, name) == 0) {
						name = ce->r;
						break;
					}
				}
			}
			for (cn = t->columns.set->h; cn; cn = cn->next) {
				sql_column *c = cn->data;
				if (strcmp(c->base.name, name) == 0) 
					return c;
			}
		}
	}
	return NULL;
}

static sql_idx *
find_index(sql_rel *r, list **EXPS)
{
	sql_rel *b;
	sql_table *t;

	if ((b = find_basetable(r)) == NULL) 
		return NULL;

	/* any (partial) match of the expressions with the index columns */
	/* Depending on the index type we may need full matches and only
	   limited number of cmp types (hash only equality etc) */
	/* Depending on the index type we should (in the rel_bin) generate
	   more code, ie for spatial index add post filter etc, for hash
	   compute hash value and use index */
 	t = b->l;
	if (t->idxs.set) {
		node *in;

		/* find the columns involved in the selection over this base table*/
	   	for(in = t->idxs.set->h; in; in = in->next) {
			list *exps, *cols;
	    		sql_idx *i = in->data;
			fcmp cmp = (fcmp)&sql_column_kc_cmp;

			/* join indices are only interesting for joins */
			if (i->type == join_idx || list_length(i->columns) <= 1)
				continue;
			/* based on the index type, find qualifying exps */
			exps = list_select(r->exps, i, (fcmp) &index_exp, (fdup)exp_dup);
			/* now we obtain the columns, move into sql_column_kc_cmp! */
			cols = list_map(exps, b, (fmap) &selectexp_col);

			/* Match the index columns with the expression columns. 
			   TODO, Allow partial matches ! */
			if (list_match(cols, i->columns, cmp) == 0) {
				/* re-order exps in index order */
				node *n, *m;
				list *es = list_create((fdestroy)&exp_destroy);

				for(n = i->columns->h; n; n = n->next) {
					int i = 0;
					for(m = cols->h; m; m = m->next, i++) {
						if (cmp(m->data, n->data) == 0){
							sql_exp *e = list_fetch(exps, i);
							list_append(es, exp_dup(e) );
							break;
						}
					}
				}
				assert(list_length(exps) == list_length(es));
				/* fix the destroy function */
				cols->destroy = NULL;
				list_destroy(cols);
				list_destroy(exps);
				*EXPS = es;
				return i;
			}
			cols->destroy = NULL;
			list_destroy(cols);
			list_destroy(exps);
		}
	}
	return NULL;
}

static sql_rel *
rel_select_use_index(int *changes, mvc *sql, sql_rel *rel) 
{
	(void)sql;
	*changes = 0; 
	if (rel->op == op_select) {
		list *exps = NULL;
		sql_idx *i = find_index(rel, &exps);
			
#ifdef DEBUG
		rel_print(sql, rel, 0);
#endif
		if (i) {
			prop *p;
			node *n;
	
			/* add PROP_HASHIDX to all column exps */
			for( n = exps->h; n; n = n->next) { 
				sql_exp *e = n->data;

				e->p = p = prop_create(PROP_HASHIDX, e->p);
				p->value = i;
			}
			/* add the remaining exps to the new exp list */
			if (list_length(rel->exps) < list_length(exps)) {
				for( n = rel->exps->h; n; n = n->next) {
					sql_exp *e = n->data;
					if (!list_find(exps, e, (fcmp)&exp_cmp))
						list_append(exps, exp_dup(e));
				}
			}
			list_destroy(rel->exps);
			rel->exps = exps;
		}
	}
	return rel;
}

/* TODO CSE */
static list *
exp_merge(list *exps)
{
	node *n, *m;
	for (n=exps->h; n && n->next; n = n->next) {
		sql_exp *e = n->data;
		/*sql_exp *le = e->l;*/
		sql_exp *re = e->r;

		assert(e->type == e_cmp);
		/* only look for gt, gte, lte, lt */
		if (re->card == CARD_ATOM && e->flag < cmp_equal) {
			for (m=n->next; m; m = m->next) {
				sql_exp *f = m->data;
				/*sql_exp *lf = f->l;*/
				sql_exp *rf = f->r;

				assert(f->type == e_cmp);
				if (rf->card == CARD_ATOM && e->flag < cmp_equal) {
					/*printf("possible candidate\n");*/
				}
			}
		}
	}
	return exps;
}

static sql_rel *
rel_select_order(int *changes, mvc *sql, sql_rel *rel) 
{
	(void)sql;
	*changes = 0; 
	if (rel->op == op_select && rel->exps && list_length(rel->exps)>1) {
		list *exps = NULL;
			
#ifdef DEBUG
		rel_print(sql, rel, 0);
#endif
		exps = list_sort(rel->exps, (fkeyvalue)&exp_keyvalue, (fdup)&exp_dup);
		list_destroy(rel->exps);
		rel->exps = exp_merge(exps);
	}
	return rel;
}

static int
is_identity( sql_exp *e, sql_rel *r)
{
	switch(e->type) {
	case e_column:
		if (r && is_project(r->op)) {
			sql_exp *re = NULL;
			if (e->l)
				re = exps_bind_column2(r->exps, e->l, e->r);
			if (!re && ((char*)e->r)[0] == 'L')
				re = exps_bind_column(r->exps, e->r);
			if (re)
				return is_identity(re, r->l);
		}
		return 0;
	case e_func: {
		sql_subfunc *f = e->f;
		return (strcmp(f->func->base.name, "identity") == 0);
	}
	default:
		return 0;
	}
}

static int
is_identity_of(sql_exp *e, sql_rel *l) 
{
	if (e->type != e_cmp)
		return 0;
	if (!is_identity(e->l, l) || !is_identity(e->r, l))
		return 0;
	return 1;
}

/* rewrite {semi,anti}join (A, join(A,B)) into {semi,anti}join (A,B) */
static sql_rel *
rel_rewrite_semijoin(int *changes, mvc *sql, sql_rel *rel)
{
	(void)sql;
	if (is_semi(rel->op)) {
		sql_rel *l = rel->l;
		sql_rel *r = rel->r;
		sql_rel *rl = (r->l)?r->l:NULL;

		if (l->ref.refcnt == 3 && 
		   ((is_join(r->op) && l == r->l) || 
		    (is_project(r->op) && rl && is_join(rl->op) && l == rl->l))){
			sql_rel *or = r;

			if (!rel->exps || list_length(rel->exps) != 1 ||
			    !is_identity_of(rel->exps->h->data, l)) 
				return rel;
			
			if (is_project(r->op)) 
				r = rl;

#ifdef DEBUG
			rel_print(sql, rel, 0);
#endif
			rel->r = rel_dup(r->r);
			/* maybe rename exps ? */
			list_destroy(rel->exps);
			rel->exps = r->exps;
			r->exps = NULL;
			rel_destroy(l);
			rel_destroy(or);
#ifdef DEBUG
			rel_print(sql, rel, 0);
#endif
			(*changes)++;
		}

	}
	return rel;
}

/*
	Rewrite if the expressions c and z are equal
		REF
			R()
		union(
			select(REF, [x, y, z]),
			select(REF, [a, b, c])
		)
	into
		REF
			select(R(), c)
		union(
			select(REF, [x, y]),
			select(REF, [a, b])
		)
 */


static int
exps_distinct( sql_rel *l, list *l_exps, sql_rel *r, list *r_exps)
{
	(void)l;
	(void)l_exps;
	(void)r;
	(void)r_exps;
	return 0;
}

static int
rels_are_distinct(sql_rel *l, sql_rel *r)
{
	if (l->op != r->op) /* different operators, not sure */
		return 0;
	switch(l->op) {
	case op_basetable:
		return 0;
	case op_table:
		return exps_distinct(l, l->exps, r, r->exps);
	case op_join: 
	case op_left: 
	case op_right: 
	case op_full: 
	case op_semi: 
	case op_anti: 
		return (rels_are_distinct(l->l, r->l) ||
		    rels_are_distinct(l->r, r->r));
	case op_union: 
	case op_inter: 
	case op_except: 
		return need_distinct(((sql_rel*)l->l)) &&
		       need_distinct(((sql_rel*)r->l));
	case op_topn: 
	case op_project:
	case op_groupby: 
		return (rels_are_distinct(l->l, r->l)); 
	case op_select: 
		return (rels_are_distinct(l->l, r->l) ||
			exps_distinct(l, l->exps, r, r->exps));
	case op_insert:
	case op_update:
	case op_delete:
		return 0;
	}
	return 0;
}

static sql_rel *
rel_remove_distinct(int *changes, mvc *sql, sql_rel *rel)
{
	(void)sql;
	(void)changes;
	if (is_union(rel->op)) {
		sql_rel *l = rel->l;
		sql_rel *r = rel->r;

		if (l == r) 
			set_nodistinct(rel);

		if (rel->exps && exps_intern(rel->exps)) {
			/* the union is a result of an or expression */

			/* lets walk the trees and find the non matching
			   select/join expressions
			 */
			if (rels_are_distinct(rel->l, rel->r)) 
				set_nodistinct(rel);
			return rel;
		}
		return rel;
	}
	return rel;
}

static sql_rel *
rewrite(mvc *sql, sql_rel *rel, rewrite_fptr rewriter) 
{
	int changes = 0;

	if (!rel)
		return rel;

	switch (rel->op) {
	case op_basetable:
	case op_table:
		break;
	case op_join: 
	case op_left: 
	case op_right: 
	case op_full: 

	case op_semi: 
	case op_anti: 

	case op_union: 
	case op_inter: 
	case op_except: 
		rel->l = rewrite(sql, rel->l, rewriter);
		rel->r = rewrite(sql, rel->r, rewriter);
		break;
	case op_project:
	case op_select: 
	case op_groupby: 
	case op_topn: 
		rel->l = rewrite(sql, rel->l, rewriter);
		break;
	case op_insert:
	case op_update:
	case op_delete:
		rel->r = rewrite(sql, rel->r, rewriter);
		break;
	}
	if (rel_is_ref(rel))
		return rel;
	rel = rewriter(&changes, sql, rel);
	if (changes)
		return rewrite(sql, rel, rewriter);
	return rel;
}


/* TODO
	Rewrite if the expressions c and z are equal
		REF
			R()
		union(
			select(REF, [x, y, z]),
			select(REF, [a, b, c])
		)
	into
		REF
			select(R(), c)
		union(
			select(REF, [x, y]),
			select(REF, [a, b])
		)
 */

sql_rel *
rel_optimizer(mvc *sql, sql_rel *rel) 
{
	global_props gp; 

	memset(&gp, 0, sizeof(global_props));
	rel_properties(sql, &gp, rel);

#ifdef DEBUG
{
	int i;
	for (i = 0; i < MAXOPS; i++) {
		if (gp.cnt[i]> 0)
			printf("%s %d\n", op2string((operator_type)i), gp.cnt[i]);
	}
}
#endif

#ifdef DEBUG
	rel_print(sql, rel, 0);
#endif
	/* TODO cleanup rel_optimzer.mx (reorder code, remove unused etc) */
	/* make parts conditional (via debug flag) */

	/* Remove unused expressions */
	if (gp.cnt[op_project])
		rel = rel_dce(sql, rel);

	/* TODO add optimizer which removes unions 
		(for example common rels, with only one different expression) */

	/* TODO common sub relation/expression optimizer */

	/* push (simple renaming) projections up */
	if (gp.cnt[op_project])
		rel = rewrite(sql, rel, &rel_push_project_up); 

	/* rewrite op_anti/semi (A,C=join(A,B)) [ A.tid  = C.A.tid ] */
	if (gp.cnt[op_anti] || gp.cnt[op_semi])
		rel = rewrite(sql, rel, &rel_rewrite_semijoin);

	if (gp.cnt[op_select])
		rel = rewrite(sql, rel, &rel_push_select_down); 

	if (gp.cnt[op_topn])
		rel = rewrite(sql, rel, &rel_push_topn_down); 

	/* TODO push select up. Sounds bad, but isn't. In case of an join-idx we want the selection on
	   the 'unique/primary (right hand side)' done before the (fake)-join and the selections on the foreign 
	   part done after. */

	/* TODO remove distinct if its not needed */

	if (gp.cnt[op_union])
		rel = rewrite(sql, rel, &rel_remove_distinct); 

	if (gp.cnt[op_join] && gp.cnt[op_groupby])
		rel = rewrite(sql, rel, &rel_push_join_down); 

	if (gp.cnt[op_groupby])
		rel = rewrite(sql, rel, &rel_avg2sum_count); 

	if (gp.cnt[op_join] || gp.cnt[op_left])
		rel = rewrite(sql, rel, &rel_join_order); 

	if (gp.cnt[op_select])
		rel = rewrite(sql, rel, &rel_select_order); 

	if (gp.cnt[op_select])
		rel = rewrite(sql, rel, &rel_select_use_index); 

#ifdef DEBUG
	rel_print(sql, rel, 0);
#endif

	/* optimize */
	return rel;
}
