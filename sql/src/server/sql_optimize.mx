@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2006 CWI.
@' All Rights Reserved.

@f sql_optimize
@a N.J. Nes, S. Manegold
@* 

@h

#ifndef _SQL_OPTIMIZE_H
#define _SQL_OPTIMIZE_H

#include "sql_mvc.h"
#include "sql_statement.h"

extern stmt *optimize(mvc *c, stmt *s);

#endif /* _SQL_OPTIMIZE_H */

@c
#include "sql_optimize.h"
#include "sql_env.h"
#include <stdio.h>

#define create_stmt_list() list_create((fdestroy)&stmt_destroy)

static int
join_cmp_eq(stmt *jn)
{
	if (jn->flag == cmp_equal) {
		return 0;
	}
	return -1;
}

static int
join_cmp_neq(stmt *jn)
{
	if (jn->flag != cmp_equal) {
		return 0;
	}
	return -1;
}

/* ! join is join(st_bat,reverse(st_[i]bat)) ! */
static int 
join_cmp_htcolnr( stmt *join , int *htcolnr )
{
	int hcolnr = join->op1.stval->op1.cval->colnr & 65535;
	int tcolnr = join->op2.stval->op1.stval->op1.cval->colnr & 65535;
	int htcn = (hcolnr<<16) | tcolnr;

	if (htcn == *htcolnr){
		return 0;
	}
	return -1;
}

static int
stmt_cmp_nrcols(stmt *s, int *nr)
{
	if (s->type != st_filter && s->nrcols == *nr) {
		return 0;
	}
	return -1;
}

/* key is a join output */
static int
cmp_sel_head(stmt *sel, stmt *key)
{
	if (key->h && key->h == sel->h) {
		return 0;
	}
	return -1;
}

static int
cmp_sel_tail(stmt *sel, stmt *key)
{
	if (key->t && key->t == sel->h) {
		return 0;
	}
	return -1;
}

static int
stmt_cmp_head_tail(stmt *h, stmt *key)
{
	if (h->nrcols != key->nrcols) {
		return -1;
	}
	if (h->nrcols == 1 && h->h == key->h) {
		return 0;
	}
	if (h->nrcols == 2 && ((h->h == key->h && h->t == key->t) || (h->t == key->h && h->h == key->t))) {
		return 0;
	}
	return -1;
}

static int
select_count(stmt *s)
{
	switch (s->type) {
	case st_column:
	case st_alias:
		return 0;
/*
		return select_count(s->op1.stval);
*/
	case st_intersect:
		return select_count(s->op1.stval ) + select_count(s->op2.stval);
	case st_reljoin:{
		int sc = 0;
		node *n = NULL;

		for (n = s->op1.lval->h; n; n = n->next) {
			sc += select_count(n->data);
		}
		for (n = s->op2.lval->h; n; n = n->next) {
			sc += select_count(n->data);
		}
		return sc;
	}
	case st_join:
		return select_count(s->op1.stval) + select_count(s->op2.stval);
	case st_reverse:
		return select_count(s->op1.stval);
	case st_semijoin:
		return select_count(s->op1.stval) + select_count(s->op2.stval);
	case st_relselect:{
		int sc = 0;
		node *n = NULL;

		for (n = s->op1.lval->h; n; n = n->next) {
			sc += select_count(n->data);
		}
		return sc;
	}
	case st_select: case st_uselect:
		if (s->op2.stval->nrcols >= 1)
			return select_count(s->op1.stval) +
				select_count(s->op2.stval);
		else
			return select_count(s->op1.stval) + 3;	/* point */
	case st_select2: case st_uselect2:
		return select_count(s->op1.stval) + 2;		/* range */
	case st_bat: case st_idxbat:
	case st_pivot:
	case st_aggr:
	case st_group:
	case st_group_ext:
	case st_append:
	case st_diff:
	case st_union:
	case st_unop:
	case st_binop:
	case st_Nop:
		return 0;
	default:
#ifndef NDEBUG
		printf("= TODO: select_count(%s)\n", st_type2string(s->type));
#endif
		return 0;
	}
}

static stmt *
stmt_smallest(stmt *h, stmt *key)
{
	int h1 = select_count(h);
	int h2 = select_count(key);

	if (h1 > h2) {
		stmt_destroy(key);
		return h;
	} else {
		stmt_destroy(h);
		return key;
	}
}

static int
pivot_cmp_tail(stmt *piv, stmt *key)
{
	if (key->t && key->t == piv->t) {
		return 0;
	}
	return -1;
}


static int
data_cmp(void *d, void *k)
{
	if (d == k)
		return 0;
	return -1;
}

#define TYPE_JOIN(type) 	(type == st_join || type == st_reljoin)

static stmt *
stmt_intersect(stmt *op1, stmt *op2)
{
	stmt *res = NULL;
	int reverse = 0;

	while (op1->type == st_reverse) {
		stmt *r = op1;

		op1 = stmt_dup(op1->op1.stval);
		stmt_destroy(r);
	}
	while (op2->type == st_reverse) {
		stmt *r = op2;

		op2 = stmt_dup(op2->op1.stval);
		stmt_destroy(r);
	}
	if (op1->h != op2->h) {
		reverse = 1;
	}
	assert((TYPE_JOIN(op1->type)) && (TYPE_JOIN(op2->type)));

	/* only keep the join, ie forget about the cross product */
	if (TYPE_JOIN(op1->type) && op1->flag == cmp_all) {
		stmt_destroy(op1);
		return op2;
	} else if (TYPE_JOIN(op2->type) && op2->flag == cmp_all) {
		stmt_destroy(op2);
		return op1;
	}

	/* this case should have been transformed into a proper
	   multi-att join ("st_reljoin") by push_selects_down()
	 */
	assert(!(op1->flag == cmp_equal && op2->flag == cmp_equal));
	assert(!(op1->type == st_reljoin && op2->type == st_reljoin));

	/*
	 * need to add the mark trick as [].select(true) on tables
	 * without unique head identifiers + semijoin is wrong
	 */
	if (!reverse) {
		stmt *ml = stmt_mark(stmt_reverse(stmt_dup(op1)), 50);
		stmt *mr = stmt_mark(stmt_dup(op1), 50);
		stmt *l = stmt_join(stmt_dup(ml),
				    stmt_dup(op2->op1.stval), cmp_equal);
		stmt *r = stmt_join(stmt_dup(mr),
				    stmt_reverse(stmt_dup(op2->op2.stval)), cmp_equal);
		stmt *v = stmt_uselect(l, r, (comp_type) op2->flag);

		res = stmt_join(stmt_reverse(stmt_semijoin(ml, v)), mr, cmp_equal);
	} else {		/* reverse */
		stmt *ml = stmt_mark(stmt_reverse(stmt_dup(op1)), 50);
		stmt *mr = stmt_mark(stmt_dup(op1), 50);
		stmt *l = stmt_join(stmt_dup(mr),
				    stmt_dup(op2->op1.stval), cmp_equal);
		stmt *r = stmt_join(stmt_dup(ml),
				    stmt_reverse(stmt_dup(op2->op2.stval)), cmp_equal);
		stmt *v = stmt_uselect(l, r, (comp_type) op2->flag);

		res = stmt_join(stmt_reverse(stmt_semijoin(ml, v)), mr, cmp_equal);
	}

	stmt_destroy(op1);
	stmt_destroy(op2);
	return res;
}


static stmt *stmt_push_down_tail(stmt *join, stmt *select);
static stmt *
stmt_push_down_head(stmt *join, stmt *select)
{
	stmt *res = NULL;

	if (join->type == st_reljoin) {
		list *l1 = create_stmt_list();
		list *l2 = list_dup(join->op2.lval, (fdup) &stmt_dup);
		node *n;

		for (n = join->op1.lval->h; n; n = n->next) {
			l1 = list_append(l1, stmt_push_down_head(stmt_dup(n->data), stmt_dup(select)));
		}
		stmt_destroy(select);
		stmt_destroy(join);
		return stmt_reljoin2(l1, l2);
	} else if (join->type == st_join) {
		res = stmt_join(stmt_push_down_head(stmt_dup(join->op1.stval), select), stmt_dup(join->op2.stval), (comp_type) join->flag);
		stmt_destroy(join);
		return res;
	} else if (join->type == st_intersect) {
		res = stmt_intersect(stmt_push_down_head(stmt_dup(join->op1.stval), select), stmt_push_down_head(stmt_dup(join->op2.stval), stmt_dup(select))
		    );
		stmt_destroy(join);
		return res;
	} else if (join->type == st_reverse) {
		res = stmt_reverse(stmt_push_down_tail(stmt_dup(join->op1.stval), select));
		stmt_destroy(join);
		return res;
	} else if (join->type == st_diff) {
		stmt *op1 = stmt_semijoin(stmt_dup(join->op1.stval), select);

		res = stmt_diff(op1, stmt_dup(join->op2.stval));
		stmt_destroy(join);
		return res;
	} else if (join->type == st_semijoin) {
		select = stmt_dup(select);
		res = stmt_semijoin(stmt_push_down_head(stmt_dup(join->op1.stval), select), stmt_push_down_head(stmt_dup(join->op2.stval), select)
		    );
		stmt_destroy(join);
		return res;
	} else if (join->type == st_select) {
		/* nr cols == 2 ie push through op1 and op2 */
		if (join->op2.stval->nrcols >= 1) {
			select = stmt_dup(select);
			res = stmt_select(stmt_push_down_head(stmt_dup(join->op1.stval), select), stmt_push_down_head(stmt_dup(join->op2.stval), select), (comp_type) join->flag);
			stmt_destroy(join);
			return res;
		}
	} else if (join->type == st_uselect) {
		/* nr cols == 2 ie push through op1 and op2 */
		if (join->op2.stval->nrcols >= 1) {
			select = stmt_dup(select);
			res = stmt_uselect(stmt_push_down_head(stmt_dup(join->op1.stval), select), stmt_push_down_head(stmt_dup(join->op2.stval), select), (comp_type) join->flag);
			stmt_destroy(join);
			return res;
		}
	} else if (join->type == st_relselect) {
		list *l = create_stmt_list();
		node *n;

		for (n = join->op1.lval->h; n; n = n->next) {
			l = list_append(l, stmt_push_down_head(stmt_dup(n->data), stmt_dup(select)));
		}
		stmt_destroy(select);
		stmt_destroy(join);
		return stmt_relselect(l);
	} else if (join->type == st_bat || join->type == st_column) {
		return stmt_semijoin(join, select);
#ifndef NDEBUG
	} else {
		printf("= TODO: common/optimize.c: push down head %s\n", st_type2string(join->type));
#endif
	}
	return stmt_semijoin(join, select);
}

/* push select (idx, val) through join(idy,idx) */
static stmt *
stmt_push_down_tail(stmt *join, stmt *select)
{
	stmt *res;

	if (join->type == st_reljoin) {
		list *l1 = list_dup(join->op2.lval, (fdup) &stmt_dup);
		list *l2 = create_stmt_list();
		node *n;

		for (n = join->op2.lval->h; n; n = n->next) {
			l2 = list_append(l2, stmt_push_down_head(stmt_dup(n->data), stmt_dup(select)));
		}
		stmt_destroy(select);
		stmt_destroy(join);
		return stmt_reljoin2(l1, l2);
	} else if (join->type == st_join) {
		res = stmt_join(stmt_dup(join->op1.stval), stmt_push_down_tail(stmt_dup(join->op2.stval), select), (comp_type) join->flag);
		stmt_destroy(join);
		return res;
	} else if (join->type == st_intersect) {
		select = stmt_dup(select);
		res = stmt_intersect(stmt_push_down_tail(stmt_dup(join->op1.stval), select), stmt_push_down_tail(stmt_dup(join->op2.stval), select)
		    );
		stmt_destroy(join);
		return res;
	} else if (join->type == st_reverse) {
		res = stmt_reverse(stmt_push_down_head(stmt_dup(join->op1.stval), select));
		stmt_destroy(join);
		return res;
	} else if (join->type == st_diff) {
		stmt *tail = stmt_reverse(stmt_dup(join->op2.stval));
		stmt *op2 = stmt_reverse(stmt_semijoin(tail, select));

		res = stmt_diff(stmt_dup(join->op1.stval), op2);
		stmt_destroy(join);
		return res;
	} else if (join->type == st_semijoin) {
		res = stmt_semijoin(stmt_push_down_tail(stmt_dup(join->op1.stval), select), stmt_dup(join->op2.stval)
		    );
		stmt_destroy(join);
		return res;
	} else if (join->type == st_bat) {
		return stmt_reverse(stmt_semijoin(stmt_reverse(join), select));
		/* TODO find pivot in ptable, and push select through the ptable  */
	} else if (join->type == st_pivot) {
		/* make sure the ptable is optimized */
		stmt *nj = optimize( /* BUG no context avail */ NULL, join);

		return stmt_push_down_tail(nj, select);
	} else if (join->type == st_mark) {
		/* for now pushin through a mark is wrong, it should
		 * push through both sides, to keep ordered oids.
		 res = stmt_mark(stmt_push_down_tail(
		 stmt_dup(join->op1.stval), select), 
		 (comp_type)join->flag);
		 stmt_destroy(join);
		 return res;
		 */
		printf("st_mark\n");
		return stmt_reverse(stmt_semijoin(stmt_reverse(join), select));
#ifndef NDEBUG
	} else {
		printf("= TODO: common/optimize.c: push down tail %s\n", st_type2string(join->type));
#endif
	}
	stmt_destroy(select);
	return join;
}

static stmt *stmt_push_join_tail(stmt *s, stmt *join);
static stmt *
stmt_push_join_head(stmt *s, stmt *join)
{
	/* found target of push-down: a [rel]join */
	if (s->type == st_reljoin) {
		list *l1 = create_stmt_list();
		list *l2 = list_dup(s->op2.lval, (fdup) &stmt_dup);
		node *n;

		for (n = s->op1.lval->h; n; n = n->next) {
			l1 = list_append(l1, stmt_join(stmt_dup(join), stmt_dup(n->data), cmp_equal));
		}
		stmt_destroy(join);
		stmt_destroy(s);
		return stmt_reljoin2(l1, l2);
	} else if (s->type == st_join) {
		stmt *op1 = stmt_join(join, stmt_dup(s->op1.stval), cmp_equal);
		stmt *res = stmt_join(op1, stmt_dup(s->op2.stval), (comp_type) s->flag);

		stmt_destroy(s);
		return res;
	/* recursively proceed push-down/search for join through some operations */
	} else if (s->type == st_reverse) {
		stmt *res = stmt_reverse(stmt_push_join_tail(stmt_dup(s->op1.stval), stmt_reverse(join)));

		stmt_destroy(s);
		return res;
	} else if (s->type == st_intersect) {
		stmt *res = stmt_intersect(stmt_push_join_head(stmt_dup(s->op1.stval), join),
					   stmt_push_join_head(stmt_dup(s->op2.stval), stmt_dup(join)));

		stmt_destroy(s);
		return res;
	} else if (s->type == st_diff) {
		stmt *op1 = stmt_join(join, stmt_dup(s->op1.stval), cmp_equal);
		stmt *res = stmt_diff(op1, stmt_dup(s->op2.stval));

		stmt_destroy(s);
		return res;
	} else if (s->type == st_semijoin) {
		stmt *jn = stmt_dup(join);
		stmt *op1 = stmt_push_join_head(stmt_dup(s->op1.stval), jn);
		stmt *op2 = stmt_push_join_head(stmt_dup(s->op2.stval), jn);
		stmt *res = stmt_semijoin(op1, op2);

		stmt_destroy(s);
		return res;
	/* push joins only through "head-tail" selects (i.e., "theta-intersection": h == h && t [cmp] t) */
	/* no need to push joins through simple selects or relselects */
	} else if (s->type == st_select) {
		if (s->op2.stval->nrcols >= 1) {
			stmt *jn = stmt_dup(join);
			stmt *op1 = stmt_push_join_head(stmt_dup(s->op1.stval), jn);
			stmt *op2 = stmt_push_join_head(stmt_dup(s->op2.stval), jn);
			stmt *res = stmt_select(op1, op2, (comp_type) s->flag);

			stmt_destroy(s);
			return res;
		}
	} else if (s->type == st_uselect) {
		if (s->op2.stval->nrcols >= 1) {
			stmt *jn = stmt_dup(join);
			stmt *op1 = stmt_push_join_head(stmt_dup(s->op1.stval), jn);
			stmt *op2 = stmt_push_join_head(stmt_dup(s->op2.stval), jn);
			stmt *res = stmt_uselect(op1, op2, (comp_type) s->flag);

			stmt_destroy(s);
			return res;
		}
	} else if (s->type == st_select2 || s->type == st_uselect2){
	} else if (s->type == st_relselect) {
/*
		list *l = create_stmt_list();
		node *n;

		for (n = s->op1.lval->h; n; n = n->next) {
			l = list_append(l, stmt_push_join_head(stmt_dup(n->data), stmt_dup(join)));
		}
		stmt_destroy(s);
		stmt_destroy(join);
		return stmt_relselect(l);
*/
	/* known ends of recursion */
	} else if (s->type == st_idxbat){
	} else if (s->type == st_bat){
	/* unknown end of recursion */
#ifndef NDEBUG
	} else {
		printf("= TODO: common/optimize.c: push join head %s\n", st_type2string(s->type));
#endif
	}
	return stmt_join(join, s, cmp_equal);
}

static stmt *
stmt_push_join_tail(stmt *s, stmt *join)
{
	/* found target of push-down: a [rel]join */
	if (s->type == st_reljoin) {
		list *l1 = list_dup(s->op1.lval, (fdup) &stmt_dup);
		list *l2 = create_stmt_list();
		node *n;

		for (n = s->op2.lval->h; n; n = n->next) {
			l2 = list_append(l2, stmt_join(stmt_reverse(stmt_dup(join)), stmt_dup(n->data), cmp_equal));
		}
		stmt_destroy(s);
		stmt_destroy(join);
		return stmt_reljoin2(l1, l2);
	} else if (s->type == st_join) {
		stmt *op2 = stmt_join(stmt_dup(s->op2.stval), join, cmp_equal);
		stmt *res = stmt_join(stmt_dup(s->op1.stval), op2,
				      (comp_type) s->flag);

		stmt_destroy(s);
		return res;
	/* recursively proceed push-down/search for join through some operations */
	} else if (s->type == st_semijoin){
		stmt *op1 = stmt_push_join_tail( stmt_dup(s->op1.stval), join);
		stmt *res = stmt_semijoin( op1, stmt_dup(s->op2.stval) );
		stmt_destroy(s);
		return res;
	} else if (s->type == st_reverse) {
		stmt *res = stmt_reverse(stmt_push_join_head(stmt_dup(s->op1.stval), stmt_reverse(join)));

		stmt_destroy(s);
		return res;
	} else if (s->type == st_intersect) {
		stmt *res = stmt_intersect(stmt_push_join_tail(stmt_dup(s->op1.stval), join),
					   stmt_push_join_tail(stmt_dup(s->op2.stval), stmt_dup(join))
		    );

		stmt_destroy(s);
		return res;
	} else if (s->type == st_diff) {
		stmt *op2 = stmt_join(stmt_dup(s->op2.stval), join, cmp_equal);
		stmt *res = stmt_diff(stmt_dup(s->op1.stval), op2);

		stmt_destroy(s);
		return res;
	/* known ends of recursion */
	} else if (s->type == st_idxbat){
	/* unknown end of recursion */
#ifndef NDEBUG
	} else {
		printf("= TODO: common/optimize.c: push join tail %s\n", st_type2string(s->type));
#endif
	}
	return stmt_join(s, join, cmp_equal);
}

static stmt *
stmt_join2select(stmt *j)
{

	if (j->type == st_join) {
		stmt *res = stmt_uselect(stmt_dup(j->op1.stval),
					 stmt_reverse(stmt_dup(j->op2.stval)),
					 (comp_type) j->flag);

		stmt_destroy(j);
		return res;
	} else if (j->type == st_reverse) {
		stmt *res = stmt_join2select(stmt_dup(j->op1.stval));

		stmt_destroy(j);
		return res;
	} else if (j->type == st_intersect) {
		stmt *res = stmt_semijoin(stmt_join2select(stmt_dup(j->op1.stval)),
					  stmt_join2select(stmt_dup(j->op2.stval)));

		stmt_destroy(j);
		return res;
	} else if (j->type == st_semijoin) {
		return j;
#ifndef NDEBUG
	} else {
		printf("= TODO: common/optimize.c: join2select %s\n", st_type2string(j->type));
#endif
	}
	return j;
}



static stmt *
stmt_push_down_head_wrap(stmt *j, stmt *sel)
{
	return stmt_push_down_head(stmt_dup(j), stmt_dup(sel));
}
static stmt *
stmt_push_down_tail_wrap(stmt *j, stmt *sel)
{
	return stmt_push_down_tail(stmt_dup(j), stmt_dup(sel));
}

#define sSTMT_BAT(type) (type == st_bat || type == st_idxbat)
int STMT_BAT(int type ) {
	return sSTMT_BAT(type);
}

static sql_idx *
find_fk_index(list * eqjoins, int tail, list **fkjoins)
{
	sql_idx *hi = NULL, *ti = NULL;
	sql_table *htab, *ttab;
	node *in;
	stmt *join = eqjoins->h->data;

	assert(fkjoins && *fkjoins == NULL);

	if (!STMT_BAT(join->op1.stval->type) ||
		/* assumes reverse */
	    !STMT_BAT(join->op2.stval->op1.stval->type) )
		return NULL;

	if(tail) {
		htab = join->t->op1.tval;
		ttab = join->h->op1.tval;
	} else {
		htab = join->h->op1.tval;
		ttab = join->t->op1.tval;
	}
	if(htab->idxs.set)
	   for(in = htab->idxs.set->h; in; in = in->next){
	    	hi = in->data;
		if (hi->type == join_idx){
		        ti = ((sql_fkey*)hi->key)->rkey->k.idx;
              			if (ti->t == ttab) {
              				node *hn, *tn;
              				int ic = 0;
              				*fkjoins = create_stmt_list();
              				for(hn = hi->columns->h, tn = ti->columns->h; hn && tn; hn = hn->next, tn = tn->next, ic++){
              					node * jn;
              					int hcolnr = ((sql_kc*)hn->data)->c->colnr & 65535;
              					int tcolnr = ((sql_kc*)tn->data)->c->colnr & 65535;
              					int htcolnr;
              					if(tail) 
              						htcolnr = (tcolnr<<16) | hcolnr;
              					else
              						htcolnr = (hcolnr<<16) | tcolnr;
              					if ((jn = list_find(eqjoins, (void*)&htcolnr, (fcmp)&join_cmp_htcolnr))) {
              						stmt * js = jn->data;
              						/*if (js->op1.stval->type==st_bat && js->op2.stval->op1.stval->type==st_bat)*/ {
              							list_append(*fkjoins,stmt_dup(js));
              						}
              					}
              				}
              				if (list_length(*fkjoins) == ic) {
              					break;
              				} else {
              					list_destroy(*fkjoins);
              					*fkjoins = NULL;
              				}
			}
		}
	}
	if(*fkjoins)
		return hi;
	else
		return NULL;
}

/*
 * The push_selects_down function converts a conjunction set into a
 * reduced conjuntion tree where the selects are grouped together and
 * pushed under the join. Also joins are grouped together.
 * */
static list *
push_selects_down(mvc *c, list *con)
{
	int one = 1;
	int two = 2;

	list *rsel;
	list *res = create_stmt_list();
	list *sels, *dsels, *joins, *djoins;
	node *n = NULL;

	sels = list_select(con, (void *) &one, (fcmp) &stmt_cmp_nrcols, (fdup) &stmt_dup);
	dsels = list_distinct(sels, (fcmp) &stmt_cmp_head_tail, (fdup) &stmt_dup);

	joins = list_select(con, (void *) &two, (fcmp) &stmt_cmp_nrcols, (fdup) &stmt_dup);
	djoins = list_distinct(joins, (fcmp) &stmt_cmp_head_tail, (fdup) &stmt_dup);
	if (list_length(sels) > list_length(dsels)) {
		rsel = create_stmt_list();
		for (n = dsels->h; n; n = n->next) {
			list *esels = list_select(sels, n->data, (fcmp) &stmt_cmp_head_tail, (fdup) &stmt_dup);
			stmt *sel = stmt_relselect(esels);

			/* TODO check for primary/foreign key selects */
			list_append(rsel, sel);
		}
		list_destroy(dsels);
	} else {
		rsel = dsels;
	}
	list_destroy(sels);

	/* todo join order rewrites */
	for (n = djoins->h; n; n = n->next) {
		list *ejoins = list_select(joins, n->data, (fcmp) &stmt_cmp_head_tail, (fdup) &stmt_dup);
		stmt *join = ejoins->h->data;
		list *eqjoins = NULL, *nqjoins = NULL;
		stmt *reljoin = NULL, *jdx = NULL;
		node *hsel = NULL, *tsel = NULL;
		node * jn;

		/* align joined tables */
		for(jn = ejoins->h; jn; jn = jn->next) {
			stmt *j = jn->data;

			if (!STMT_BAT(j->op1.stval->type))
				continue;
			assert(j->op2.stval->type==st_reverse);
			if (!STMT_BAT(j->op2.stval->op1.stval->type))
				continue;
			if (j->t == join->h && j->type == st_join && j->flag == cmp_equal ) {
				stmt *jh = stmt_dup(j->op2.stval->op1.stval);
				stmt *jt = stmt_reverse(stmt_dup(j->op1.stval));
				jn->data = stmt_join(jh, jt, (comp_type)j->flag);
				stmt_destroy(j);
			} else if (j->t == join->h && j->type == st_reljoin) {
				list *l1 = list_dup(j->op1.lval, (fdup)&stmt_dup);
				list *l2 = list_dup(j->op2.lval, (fdup)&stmt_dup);
				jn->data = stmt_reljoin2(l2,l1);
				stmt_destroy(j);
			}
		}

		if (!mvc_debug_on(c,32768)) {
			/* check for foreign key joins */
			eqjoins = list_select(ejoins, (void*)1L, (fcmp)&join_cmp_eq, (fdup)&stmt_dup );
			if (list_length(eqjoins) > 0) {
				list *fkjoins = NULL;
				sql_idx *idx = NULL;
				int tail = 0;

				/* look for foreign key index */
				if (!(idx = find_fk_index(eqjoins, tail, &fkjoins))) {
					tail = 1;
					idx = find_fk_index(eqjoins, tail, &fkjoins);
				}

				/* replace foreign key joins by index */
				if (idx && fkjoins) {
					jdx = stmt_idxbat(idx, 0);
					jdx->nrcols = 2;
					if(tail) {
						jdx->h = stmt_dup(((stmt*)fkjoins->h->data)->t);
						jdx->t = stmt_dup(((stmt*)fkjoins->h->data)->h);
						jdx = stmt_reverse(jdx);
					} else {
						jdx->h = stmt_dup(((stmt*)fkjoins->h->data)->h);
						jdx->t = stmt_dup(((stmt*)fkjoins->h->data)->t);
					}
	
					/* remove joins replaced by the join idx */
					for(jn = fkjoins->h; jn; jn = jn->next) {
						node * nj = list_find(ejoins, jn->data, (fcmp)&data_cmp);
						assert(nj);
						list_remove_node(ejoins, nj);
					}
				}
				if (fkjoins)
					list_destroy(fkjoins);
			}
			list_destroy(eqjoins);
		}

		if (list_length(ejoins) > 0) {
			/* push select through all remaining joins */
			join = ejoins->h->data;
			hsel = list_find(rsel, (void*)join, (fcmp)&cmp_sel_head);
			tsel = list_find(rsel, (void*)join, (fcmp)&cmp_sel_tail);

			if (hsel) {
				stmt *sel = hsel->data;
				list *nejoins = list_map(ejoins, sel,
					 (fmap) &stmt_push_down_head_wrap);

				sel->nr++;
				list_destroy(ejoins);
				ejoins = nejoins;
			}
			if (tsel) {
				stmt *sel = tsel->data;
				list *nejoins = list_map(ejoins, sel,
					 (fmap) &stmt_push_down_tail_wrap);
	
				sel->nr++;
				list_destroy(ejoins);
				ejoins = nejoins;
			}
		} else if (jdx) {
			hsel = list_find(rsel, (void*)jdx, (fcmp)&cmp_sel_head);
			tsel = list_find(rsel, (void*)jdx, (fcmp)&cmp_sel_tail);
			if (hsel){
				stmt *sel = hsel->data;
				jdx = stmt_semijoin(jdx, stmt_dup(sel));
				sel->nr++;
			}
			if (tsel){
				stmt *sel = tsel->data;
				jdx = stmt_reverse(stmt_semijoin(stmt_reverse(jdx), stmt_dup(sel)));
				sel->nr++;
			}
		}

		/* look for multi-att equi-join candidates */
		eqjoins = list_select(ejoins, (void *) 1L, (fcmp) &join_cmp_eq, (fdup) &stmt_dup);
		if (list_length(eqjoins) > 1) {
			/* rewrite conjuction of equi-join into multi-att equi-join */
			reljoin = stmt_reljoin1(eqjoins);
			/* collect the remaining non-equi joins */
			nqjoins = list_select(ejoins, (void *) 1L, (fcmp) &join_cmp_neq, (fdup) &stmt_dup);
			list_destroy(ejoins);
		} else {
			/* no multi-att equi-join found; theat all joins equally */
			reljoin = NULL;
			nqjoins = ejoins;
		}
		list_destroy(eqjoins);

		/* re-add fk join index and multi-att equi-join to the collection */
		if (jdx) 
			list_append(nqjoins, jdx);

		/* changes to [].().select(TRUE) */
		join = (stmt *) list_reduce(nqjoins, (freduce) &stmt_intersect, (fdup) &stmt_dup);
		list_destroy(nqjoins);

		if (reljoin && join) {
			join = stmt_intersect(reljoin, join);
		} else if (reljoin) {
			join = reljoin;
		}

		if (!join)
			assert(0);
		list_append(res, join);
	}
	/* find least expensive join (with head/tail selects) */
	/* continue finding usages of this until done */

	list_destroy(joins);
	list_destroy(djoins);

	if (!list_length(res)) {
		if (list_length(rsel) == 1) {
			stmt *L = rsel->h->data;

			L->nr = 0;
			list_destroy(res);
			return rsel;
		} else {
			/* add implicit cross products */
			node *n;

			for (n = rsel->h; n && n->next; n = n->next) {
				stmt *L = n->data;
				stmt *R = n->next->data;

				L->nr = 0;
				R->nr = 0;
				list_append(res, stmt_join(stmt_dup(L), stmt_reverse(stmt_dup(R)), cmp_all));
			}
		}
	} else {		/* check if all selects are used by the joins */
		for (n = rsel->h; n; n = n->next) {
			stmt *L = n->data;

			if (!L->nr) {	/* not used!! */
				stmt *R = res->h->data;

				list_append(res, stmt_join(stmt_dup(L), stmt_reverse(stmt_dup(R)), cmp_all));
			}
			L->nr = 0;
		}
	}
	list_destroy(rsel);
	return res;
}

/* TODO: we do not need a mark on 1-1 joins, then the old head is unique */
list *
mk_pivot(list *pivots, stmt *st, stmt *p, int markid)
{
	list *npivots;
	stmt *j, *pnl, *pnr;
	node *pn;

	node *tp = list_find(pivots, (void *) st, (fcmp) &pivot_cmp_tail);

	j = stmt_push_join_head(st, p);
	if (tp) {
		/* convert to a select [op](l,r).select(TRUE); */
		j = stmt_push_join_tail(j, stmt_reverse(stmt_dup(tp->data)));
		j = stmt_join2select(j);
	}

	pnr = stmt_mark(stmt_reverse(j), markid);

	npivots = create_stmt_list();
	if (!tp) {
		pnl = stmt_mark(stmt_dup(j), markid);
		list_append(npivots, pnl);
	}
	for (pn = pivots->h; pn; pn = pn->next) {
		list_append(npivots, stmt_join(stmt_dup(pnr), stmt_dup(pn->data), cmp_equal));
	}
	stmt_destroy(pnr);
	return npivots;
}

/* merge_pivot_sets tries to merge pivot sets using the joins in the join set
 * returns a set of pivot sets.
 * */
/*
static list *merge_pivot_sets(list *pivotsets, list *joins)
{
	stmt *st;
	if (list_length(joins) == 0)
		return NULL;
	if (!pivotsets){
		list *pivots = create_stmt_list();
		node *n = joins->h;
		pivotsets = list_create((fdestroy)&list_destroy);
		st = n->data;

		if (st->nrcols == 1) {
			list_append(pivots, 
					stmt_mark(stmt_reverse(stmt_dup(st)), markid++));
		}
		if (st->nrcols == 2) {
			list_append(pivots, 
					stmt_mark(stmt_reverse(stmt_dup(st)), markid));
			list_append(pivots, 
					stmt_mark(stmt_dup(st), markid++));
		}
		list_append(pivotsets,pivots);
	}
}

static list *pivot_sets(list *joins, int *Markid)
{
	int markid = *Markid;
	list *psets = list_create((fdestroy)&list_destroy);
	node *n;

	for( n = joins->h; n; n = n->next ){
		list *pivots = create_stmt_list();
		stmt *st = n->data;

		if (st->nrcols == 1) {
			list_append(pivots, stmt_mark(stmt_reverse(stmt_dup(st)), markid++));
		}
		if (st->nrcols == 2) {
			list_append(pivots, stmt_mark (stmt_reverse(stmt_dup(st)), markid));
			list_append(pivots, stmt_mark(stmt_dup(st), markid++));
		}
		list_append(psets,pivots);
	}
	*Markid = markid;
	return psets;
}
*/

static stmt *
set2pivot(mvc *c, list *l)
{
	list *lo = create_stmt_list();
	list *pivots = create_stmt_list();
	stmt *join, *st = NULL;
	node *n;
	int len = 0;
	int markid = 0;

	l = push_selects_down(c, l);

	/* order l according to ascending "size" */
	while (list_length(l)) {
		join = (stmt*)list_reduce(l, (freduce)&stmt_smallest, (fdup)&stmt_dup);
		assert(join);
		n = list_find(l, (void*)join, data_cmp);
		assert(n);
		list_append(lo,join);
		list_remove_node(l,n);
	}
	list_destroy(l);
	l = lo;
	/* end of order */

	n = l->h;
/*
	join = (stmt *) list_reduce(l, (freduce) &stmt_smallest, (fdup) &stmt_dup);
	n = list_find(l, (void *) join, data_cmp);
	if (join)
		stmt_destroy(join);
*/
	if (!n) {
assert(0);
		list_destroy(l);
		list_destroy(pivots);
		return NULL;
	}
	st = n->data;
	if (st->nrcols == 1) {
		if (st->type == st_idxbat) {
			list_append(pivots, stmt_mirror(stmt_dup(st)));
		} else {
			list_append(pivots, stmt_mark(stmt_reverse(stmt_dup(st)), markid++));
		}
	}
	if (st->nrcols == 2) {
		if (st->type == st_idxbat) {
			list_append(pivots, stmt_mirror(stmt_dup(st)));
			list_append(pivots, stmt_dup(st));
		} else {
			list_append(pivots, stmt_mark(stmt_reverse(stmt_dup(st)), markid));
			list_append(pivots, stmt_mark(stmt_dup(st), markid++));
		}
	}
	n = list_remove_node(l, n);
	len = list_length(l) + 1;
	while (list_length(l) > 0 && len > 0) {
		len--;
		n = l->h;
		while (n) {
			stmt *st = n->data;
			node *p = NULL;

			for (p = pivots->h; p; p = p->next) {
				list *nps = NULL;
				stmt *pv = p->data;

				if (st->type == st_idxbat) {
					/* joining two join indices, no join
					   needed 
					 */
					if (pv->t == st->h && pv->h == st->h) {
						list_append(pivots, stmt_dup(st));
						n = list_remove_node(l, n);
						break;
					} else if (pv->t == st->t && pv->h == st->t) {
						list_append(pivots, stmt_reverse(stmt_dup(st)));
						n = list_remove_node(l, n);
						break;
					}
				} else if (pv->t == st->h) {
					nps = mk_pivot(pivots, stmt_dup(st), stmt_dup(pv), markid++);
					list_destroy(pivots);
					pivots = nps;
					n = list_remove_node(l, n);
					break;
				} else if (pv->t == st->t) {
					nps = mk_pivot(pivots, stmt_reverse(stmt_dup(st)), stmt_dup(pv), markid++);
					list_destroy(pivots);
					pivots = nps;
					n = list_remove_node(l, n);
					break;
				}
			}
			if (n)
				n = n->next;
		}
	}
	if (!len) {
		assert(0);
		return NULL;
	}
	list_destroy(l);
	return stmt_list(pivots);
}

/* list of stmt's containing filter steps are transformed into a pivot table */
static stmt *
filter_pivots(list *pivots, list *filters)
{
	stmt *filter = list_reduce(filters, (freduce) &stmt_semijoin, (fdup) &stmt_dup);
	list *nl = create_stmt_list();
	node *n;

	for (n = pivots->h; n; n = n->next) {
		stmt *p = stmt_dup(n->data);
		stmt *np = stmt_semijoin(p, stmt_dup(filter));

		list_append(nl, np);
	}
	stmt_destroy(filter);
	return stmt_list(nl);
}

/* The group code is needed for double elimination.
 * if a value is selected twice once on the left hand of the
 * 'OR' and once on the right hand of the 'OR' it will be in the
 * result twice.
 *
 * current version is broken, unique also remove normal doubles.
 */
static stmt *
sets2pivot(mvc *c, list *ll)
{
	node *n = ll->h;

	if (n) {
		stmt *pivots = set2pivot(c, n->data);

		n = n->next;
		while (n) {
			stmt *npivots = set2pivot(c, n->data);
			list *l = npivots->op1.lval;
			list *inserts = create_stmt_list();
			node *m, *c;

			/* we use a special bat insert to garantee unique head 
			 * oids 
			 */
			for (m = l->h; m; m = m->next) {
				for (c = pivots->op1.lval->h; c; c = c->next) {
					stmt *cd = c->data;
					stmt *md = m->data;

					if (cd->t == md->t) {
						list_append(inserts, stmt_append(stmt_dup(cd), stmt_dup(md)));
						break;
					}
				}
			}
			stmt_destroy(pivots);
			stmt_destroy(npivots);
			pivots = stmt_list(inserts);
			n = n->next;
		}
		{
			group *g = NULL;
			stmt *u;
			node *m;
			list *inserts = create_stmt_list();

			for (m = pivots->op1.lval->h; m; m = m->next) {
				g = grp_create(stmt_dup(m->data), g, NULL);
			}
			u = stmt_reverse(stmt_unique(stmt_reverse(stmt_dup(g->ext)), NULL));
			grp_destroy(g);

			for (m = pivots->op1.lval->h; m; m = m->next) {
				list_append(inserts, stmt_semijoin(stmt_dup(m->data), stmt_dup(u)));
			}
			stmt_destroy(u);
			stmt_destroy(pivots);
			return stmt_list(inserts);
		}
		/* no double elimination jet 
		   return pivots;
		 */
	}
	return NULL;
}

static stmt *
op_stmt2pivot(mvc * c, stmt *s)
{
	if (s->type != st_set && s->type != st_sets) {
		s = stmt_set(s);
	}
	if (s->type == st_sets) {
		stmt *ns = sets2pivot(c, s->op1.lval);

		stmt_destroy(s);
		s = ns;
	} else {
		stmt *ns = set2pivot(c, s->op1.lval);

		stmt_destroy(s);
		s = ns;
	}
	return s;
}

static stmt *
find_pivot(stmt *subset, stmt *t)
{
	assert(t);
	if (t) {
		node *n;

		for (n = subset->op1.lval->h; n; n = n->next) {
			stmt *s = n->data;

			if (s->t == t)
				return stmt_dup(s);
		}
	}
	assert(0);
	return NULL;
}


stmt *
optimize(mvc *c, stmt *s)
{
	stmt *res = s;

	assert(!(s->optimized < 1 && s->rewritten));
	if (s->optimized >= 1) {
		if (s->rewritten)
			return stmt_dup(s->rewritten);
		else
			return stmt_dup(s);
	}

	switch (s->type) {
		/* first just return those statements which we cannot optimize,
		 * such as schema manipulation, transaction managment, 
		 * and user authentication.
		 */
	case st_none:
	case st_sql:
	case st_rs_column:
	case st_dbat:
	case st_basetable:
	case st_idxbat:

	case st_atom:
	case st_bulkinsert:
	case st_var:
	case st_table_clear:

		s->optimized = 1;
		return stmt_dup(s);

	case st_reljoin:{

		list *l1 = create_stmt_list();
		list *l2 = create_stmt_list();
		node *n1, *n2;
		stmt *res;

		for (n1 = s->op1.lval->h, n2 = s->op2.lval->h; n1 && n2; n1 = n1->next, n2 = n2->next) {
			list_append(l1, optimize(c, n1->data));
			list_append(l2, optimize(c, n2->data));
		}
		res = stmt_reljoin2(l1, l2);
		s->optimized = res->optimized = 1;
		if (res != s) {
			s->rewritten = stmt_dup(res);
		}
		return res;
	}

	case st_relselect:{

		list *l = create_stmt_list();
		node *n;
		stmt *res;

		for (n = s->op1.lval->h; n; n = n->next) {
			list_append(l, optimize(c, n->data));
		}
		res = stmt_relselect(l);
		s->optimized = res->optimized = 1;
		if (res != s) {
			s->rewritten = stmt_dup(res);
		}
		return res;
	}

	case st_temp:
	case st_filter:
	case st_select:
	case st_select2:
	case st_uselect:
	case st_uselect2:
	case st_semijoin:
	case st_diff:
	case st_intersect:
	case st_union:
	case st_outerjoin:
	case st_join:
	case st_mirror:
	case st_reverse:
	case st_const:
	case st_mark:
	case st_gen_group:
	case st_group:
	case st_group_ext:
	case st_derive:
	case st_unique:
	case st_limit:
	case st_order:
	case st_reorder:
	case st_ordered:

	case st_column:
	case st_alias:
	case st_output:
	case st_affected_rows:
	case st_append:
	case st_insert:
	case st_replace:
	case st_exception:

	case st_aggr:
	case st_op:
	case st_unop:
	case st_binop:
	case st_Nop:
	case st_convert:

	case st_while:
	case st_if:
	case st_return:
	case st_table:

		if (s->op1.stval) {
			stmt *os = s->op1.stval;
			stmt *ns = optimize(c, os);

			assert(ns != s);
			s->op1.stval = ns;
			stmt_destroy(os);
		}
		if (s->type != st_convert) {
			if (s->op2.stval) {
				stmt *os = s->op2.stval;
				stmt *ns = optimize(c, os);
	
				assert(ns != s);
				s->op2.stval = ns;
				stmt_destroy(os);
			}
			if (s->op3.stval) {
				stmt *os = s->op3.stval;
				stmt *ns = optimize(c, os);
	
				assert(ns != s);
				s->op3.stval = ns;
				stmt_destroy(os);
			}
		}
		s->optimized = 1;
		return stmt_dup(s);

	case st_assign:
		if (s->op2.stval) {
			stmt *os = s->op2.stval;
			stmt *ns = optimize(c, os);

			assert(ns != s);
			s->op2.stval = ns;
			stmt_destroy(os);
		}
		s->optimized = 1;
		return stmt_dup(s);

	case st_list:{

		stmt *res = NULL;
		node *n;
		list *l = s->op1.lval;
		list *nl = NULL;

		nl = create_stmt_list();
		for (n = l->h; n; n = n->next) {
			stmt *ns = optimize(c, n->data);

			list_append(nl, ns);
		}
		res = stmt_list(nl);
		s->optimized = res->optimized = 1;
		if (res != s) {
			s->rewritten = stmt_dup(res);
		}
		return res;
	}

	case st_bat:

		s->optimized = 1;
		return stmt_dup(s);

	case st_pivot:{

		stmt *ns = optimize(c, s->op2.stval);	/* optimize ptable */
		stmt *np = find_pivot(ns, s->t);

		stmt_destroy(ns);

		s->optimized = np->optimized = 1;
		if (np != s) {
			s->rewritten = stmt_dup(np);
		}
		return np;
	}

	case st_ptable:{
		if (ptable_parent(s)) {
			stmt *parent = optimize(c, ptable_parent(s));
			stmt *f, *np;

			if (!ptable_statements(s))
				return parent;
			/* filter statements */
			f = filter_pivots(parent->op1.lval, ptable_statements(s)->op1.lval);
			stmt_destroy(parent);
			np = optimize(c, f);
			stmt_destroy(f);
			s->optimized = np->optimized = 1;
			if (np != s) {
				s->rewritten = stmt_dup(np);
			}
			return np;
		}
		if (ptable_statements(s)) {
			stmt *pivots = op_stmt2pivot(c, stmt_dup(ptable_statements(s)));

			/* also optimize the pivots */
			stmt *np = optimize(c, pivots);

			assert(np);
			stmt_destroy(pivots);
			s->optimized = np->optimized = 1;
			if (np != s) {
				s->rewritten = stmt_dup(np);
			}
			return np;
		}
		return s;
	}

	case st_set:
	case st_sets:
	default:
		assert(0);	/* these should have been rewriten by now */
	}
	return res;
}
