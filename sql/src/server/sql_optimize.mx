@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2008 CWI.
@' All Rights Reserved.

@f sql_optimize
@a N.J. Nes, S. Manegold
@* 

@h

#ifndef _SQL_OPTIMIZE_H
#define _SQL_OPTIMIZE_H

#include "sql_mvc.h"
#include "sql_statement.h"

extern stmt *optimize(mvc *c, stmt *s);
extern stmt *push_semijoin( stmt *select, stmt *s );

#endif /* _SQL_OPTIMIZE_H */

@c
#include "sql_config.h"
#include "sql_optimize.h"
#include "sql_env.h"
#include <stdio.h>
#include "rel_semantic.h"
#include "sql_rel2bin.h"

#define create_stmt_list() list_create((fdestroy)&stmt_destroy)

static int
join_cmp_eq(stmt *jn)
{
	if (jn->flag == cmp_equal) {
		return 0;
	}
	return -1;
}

static int
join_cmp_neq(stmt *jn)
{
	if (jn->flag != cmp_equal) {
		return 0;
	}
	return -1;
}

/* ! join is join(st_bat,reverse(st_[i]bat)) ! */
static int 
join_cmp_htcolnr( stmt *join , int *htcolnr )
{
	int hcolnr = join->op1.stval->op1.cval->colnr & 65535;
	int tcolnr = join->op2.stval->op1.stval->op1.cval->colnr & 65535;
	int htcn = (hcolnr<<16) | tcolnr;

	if (htcn == *htcolnr){
		return 0;
	}
	return -1;
}

static int
stmt_cmp_nrcols(stmt *s, int *nr)
{
	if (s->type != st_filter && s->nrcols == *nr) {
		return 0;
	}
	return -1;
}

/* key is a join output */
static int
cmp_sel_head(stmt *sel, stmt *key)
{
	if (key->h && key->h == sel->h) {
		return 0;
	}
	return -1;
}

static int
cmp_sel_tail(stmt *sel, stmt *key)
{
	if (key->t && key->t == sel->h) {
		return 0;
	}
	return -1;
}

static int
stmt_cmp_head_tail(stmt *h, stmt *key)
{
	if (h->nrcols != key->nrcols) {
		return -1;
	}
	if (h->nrcols == 1 && h->h == key->h) {
		return 0;
	}
	if (h->nrcols == 2 && ((h->h == key->h && h->t == key->t) || (h->t == key->h && h->h == key->t))) {
		return 0;
	}
	return -1;
}

static stmt * headcolumn(stmt *st);

static stmt *
tailcolumn(stmt *st)
{
	switch (st->type) {
	case st_join:
	case st_outerjoin:
	case st_intersect:
	case st_reorder:
		return tailcolumn(st->op2.stval);

	case st_join2:
		return tailcolumn(st->op2.stval);
	case st_reljoin:
		return tailcolumn(st->op2.lval->h->data);

	case st_semijoin:
		return tailcolumn(st->op1.stval);

	case st_column:
	case st_bat:
		return st;
	case st_reverse:
		return headcolumn(st->op1.stval);
	default:
		return NULL;
	}
}

static stmt *
headcolumn(stmt *st)
{
	switch (st->type) {
	case st_column:
	case st_bat:
		return st;
	case st_reverse:
		return tailcolumn(st->op1.stval);
	case st_semijoin:
		return headcolumn(st->op1.stval);
	default:
		return NULL;
	}
	return NULL;
}

/* getcolumn is used by rangejoin detection */
static stmt *
getcolumn(stmt *st)
{
	if (!st)
		return NULL;	
	switch (st->type) {
	case st_reverse:
		return getcolumn(headcolumn(st->op1.stval));
	case st_pivot:
		return getcolumn(st->op1.stval);
	case st_bat:
	case st_column:
		return st;
	default:
		return getcolumn(tailcolumn(st));
	}
}

static int
cmp_matching_column( stmt *l, stmt *r)
{
	stmt *lc = getcolumn(l->op1.stval);
	stmt *rc = getcolumn(r->op1.stval);

	if (lc && rc && lc == rc)
		return 0;
	lc = getcolumn(tailcolumn(l->op2.stval));
	rc = getcolumn(tailcolumn(r->op2.stval));
	if (lc && rc && lc == rc)
		return 0;
	return -1;
}

static int
select_count(stmt *s)
{
	switch (s->type) {
	case st_column:
	case st_alias:
		return 0;
/*
		return select_count(s->op1.stval);
*/
	case st_intersect:
		return select_count(s->op1.stval ) + select_count(s->op2.stval);
	case st_reljoin:{
		int sc = 0;
		node *n = NULL;

		for (n = s->op1.lval->h; n; n = n->next) {
			sc += select_count(n->data);
		}
		for (n = s->op2.lval->h; n; n = n->next) {
			sc += select_count(n->data);
		}
		return sc;
	}
	case st_join:
		/* we don't like thetajoins */
		if (s->flag != cmp_equal)
			return -1;
		return select_count(s->op1.stval) + select_count(s->op2.stval);
	case st_join2:
		return select_count(s->op1.stval) + 
			select_count(s->op2.stval) + select_count(s->op3.stval);
	case st_reverse:
	case st_mirror:
		return select_count(s->op1.stval);
	case st_semijoin:
		return select_count(s->op1.stval) + select_count(s->op2.stval);
	case st_relselect:{
		int sc = 0;
		node *n = NULL;

		for (n = s->op1.lval->h; n; n = n->next) {
			sc += select_count(n->data);
		}
		return sc;
	}
	case st_select: case st_uselect:
		if (s->op2.stval->nrcols >= 1) 
		   /* before the reduce we need to scan */
			return -20;
		else if (s->flag == cmp_equal)
			return select_count(s->op1.stval) + 20;	/* point */
		else if (s->flag == cmp_notequal)
			return select_count(s->op1.stval) + 10;	/* point */
		else if (s->flag == cmp_like || s->flag == cmp_notlike)
			return select_count(s->op1.stval) + 2;	/* like==scan */
		/* ranges */
		return select_count(s->op1.stval) + 4;	
	case st_select2: case st_uselect2:
		return select_count(s->op1.stval) + 2;		/* range */
	case st_idxbat:
		return 100;	/* we want join indices first */
	case st_unop:
	case st_convert:
		if (s->nrcols > 0)
			return select_count(s->op1.stval) - 1;
		return 0;
	case st_binop:
		if (s->nrcols > 0)
			return select_count(s->op1.stval) +
			       select_count(s->op2.stval) - 1;
		return 0;
	case st_Nop:
		/* also scans cost time */
		if (s->nrcols > 0)
			return -5;
	case st_bat: 
	case st_pivot:
	case st_aggr:
	case st_group:
	case st_group_ext:
	case st_append:
	case st_diff:
	case st_union:
	case st_mark:   
	case st_var:    
		return 0;
	default:
#ifndef NDEBUG
		printf("= TODO: select_count(%s)\n", st_type2string(s->type));
#endif
		return 0;
	}
}

static stmt *
stmt_smallest(stmt *h, stmt *key)
{
	int h1 = select_count(h);
	int h2 = select_count(key);

	if (h1 > h2) {
		stmt_destroy(key);
		return h;
	} else {
		stmt_destroy(h);
		return key;
	}
}

static int 
stmt_cmp(stmt *s1, stmt *s2)
{
	int h1 = select_count(s1);
	int h2 = select_count(s2);
	return h1-h2;
}

static int
pivot_cmp_tail(stmt *piv, stmt *key)
{
	if (key->t && key->t == piv->t) {
		return 0;
	}
	return -1;
}

static int
data_cmp(void *d, void *k)
{
	if (d == k)
		return 0;
	return -1;
}

#define TYPE_JOIN(type)  (type == st_join || type == st_join2 || type == st_reljoin)

static stmt *
stmt_intersect(stmt *op1, stmt *op2)
{
	stmt *res = NULL;
	int reverse = 0;

	while (op1->type == st_reverse) {
		stmt *r = op1;

		op1 = stmt_dup(op1->op1.stval);
		stmt_destroy(r);
	}
	while (op2->type == st_reverse) {
		stmt *r = op2;

		op2 = stmt_dup(op2->op1.stval);
		stmt_destroy(r);
	}
	if (op1->h != op2->h) {
		reverse = 1;
	}
	assert((TYPE_JOIN(op1->type)) && (TYPE_JOIN(op2->type)));

	/* only keep the join, ie forget about the cross product */
	if (TYPE_JOIN(op1->type) && op1->flag == cmp_all) {
		stmt_destroy(op1);
		return op2;
	} else if (TYPE_JOIN(op2->type) && op2->flag == cmp_all) {
		stmt_destroy(op2);
		return op1;
	}

	/* this case should have been transformed into a proper
	   multi-att join ("st_reljoin") by push_selects_down()
	 */
	assert(!(op1->type == st_reljoin && op2->type == st_reljoin));
	assert(op1->type != st_idxbat && op2->type != st_idxbat);

	/*
	 * need to add the mark trick as [].select(true) on tables
	 * without unique head identifiers + semijoin is wrong
	 */
	if (!reverse) {
		stmt *ml = stmt_mark(stmt_reverse(stmt_dup(op1)), 50);
		stmt *mr = stmt_mark(stmt_dup(op1), 50);
		stmt *l = stmt_join(stmt_dup(ml),
			    	stmt_dup(op2->op1.stval), cmp_equal);
		if (op2->type == st_join2) {
			stmt *r1 = stmt_join(stmt_dup(mr),
				    	stmt_dup(op2->op2.stval), cmp_equal);
			stmt *r2 = stmt_join(stmt_dup(mr),
				    	stmt_dup(op2->op3.stval), cmp_equal);
			comp_type c1 = op2->flag&2 ? cmp_gte : cmp_gt;
			comp_type c2 = op2->flag&1 ? cmp_lte : cmp_lt;
			stmt *v1 = stmt_uselect(l, r1, c1);
			stmt *v2 = stmt_uselect(stmt_dup(l), r2, c2);
			
			ml = stmt_semijoin(ml, v1);
			ml = stmt_semijoin(ml, v2);
			res = stmt_join(stmt_reverse(ml), mr, cmp_equal);
		} else {
			stmt *r = stmt_join(stmt_dup(mr),
				    	stmt_reverse(stmt_dup(op2->op2.stval)), cmp_equal);
			stmt *v = stmt_uselect(l, r, (comp_type) op2->flag);
	
			res = stmt_join(stmt_reverse(stmt_semijoin(ml, v)), mr, cmp_equal);
		}
	} else {		/* reverse */
		if (op2->type == st_join2) {
			stmt *ml = stmt_mark(stmt_reverse(stmt_dup(op1)), 50);
			stmt *mr = stmt_mark(stmt_dup(op1), 50);
			stmt *l = stmt_join(stmt_dup(mr),
				    	stmt_dup(op2->op1.stval), cmp_equal);
			stmt *r1 = stmt_join(stmt_dup(ml),
				    	stmt_dup(op2->op2.stval), cmp_equal);
			stmt *r2 = stmt_join(stmt_dup(ml),
				    	stmt_dup(op2->op3.stval), cmp_equal);
			comp_type c1 = op2->flag&2 ? cmp_gte : cmp_gt;
			comp_type c2 = op2->flag&1 ? cmp_lte : cmp_lt;
			stmt *v1 = stmt_uselect(l, r1, c1);
			stmt *v2 = stmt_uselect(stmt_dup(l), r2, c2);
	
			ml = stmt_semijoin(ml, v1);
			ml = stmt_semijoin(ml, v2);
			res = stmt_join(stmt_reverse(ml), mr, cmp_equal);
		} else {
			stmt *ml = stmt_mark(stmt_reverse(stmt_dup(op1)), 50);
			stmt *mr = stmt_mark(stmt_dup(op1), 50);
			stmt *l = stmt_join(stmt_dup(mr),
				    	stmt_dup(op2->op1.stval), cmp_equal);
			stmt *r = stmt_join(stmt_dup(ml),
				    	stmt_reverse(stmt_dup(op2->op2.stval)), cmp_equal);
			stmt *v = stmt_uselect(l, r, (comp_type) op2->flag);
	
			res = stmt_join(stmt_reverse(stmt_semijoin(ml, v)), mr, cmp_equal);
		}
	}

	stmt_destroy(op1);
	stmt_destroy(op2);
	return res;
}


static stmt *stmt_push_down_tail(stmt *join, stmt *select);
static stmt *
stmt_push_down_head(stmt *join, stmt *select)
{
	stmt *res = NULL;

	if (join->type == st_reljoin) {
		list *l1 = create_stmt_list();
		list *l2 = list_dup(join->op2.lval, (fdup) &stmt_dup);
		node *n;

		for (n = join->op1.lval->h; n; n = n->next) {
			l1 = list_append(l1, stmt_push_down_head(stmt_dup(n->data), stmt_dup(select)));
		}
		stmt_destroy(select);
		stmt_destroy(join);
		return stmt_reljoin2(l1, l2);
	} else if (join->type == st_join) {
		res = stmt_join(stmt_push_down_head(stmt_dup(join->op1.stval), select), stmt_dup(join->op2.stval), (comp_type) join->flag);
		stmt_destroy(join);
		return res;
	} else if (join->type == st_join2) {
		res = stmt_join2(stmt_push_down_head(stmt_dup(join->op1.stval), select), stmt_dup(join->op2.stval), stmt_dup(join->op3.stval), join->flag);
		stmt_destroy(join);
		return res;
	} else if (join->type == st_intersect) {
		res = stmt_intersect(stmt_push_down_head(stmt_dup(join->op1.stval), select), stmt_push_down_head(stmt_dup(join->op2.stval), stmt_dup(select))
		    );
		stmt_destroy(join);
		return res;
	} else if (join->type == st_reverse) {
		res = stmt_reverse(stmt_push_down_tail(stmt_dup(join->op1.stval), select));
		stmt_destroy(join);
		return res;
	} else if (join->type == st_diff) {
		stmt *op1 = stmt_semijoin(stmt_dup(join->op1.stval), select);

		res = stmt_diff(op1, stmt_dup(join->op2.stval));
		stmt_destroy(join);
		return res;
	} else if (join->type == st_semijoin) {
		select = stmt_dup(select);
		res = stmt_semijoin(stmt_push_down_head(stmt_dup(join->op1.stval), select), stmt_push_down_head(stmt_dup(join->op2.stval), select)
		    );
		stmt_destroy(join);
		return res;
	} else if (join->type == st_select) {
		/* nr cols == 2 ie push through op1 and op2 */
		if (join->op2.stval->nrcols >= 1) {
			select = stmt_dup(select);
			res = stmt_select(stmt_push_down_head(stmt_dup(join->op1.stval), select), stmt_push_down_head(stmt_dup(join->op2.stval), select), (comp_type) join->flag);
			stmt_destroy(join);
			return res;
		}
	} else if (join->type == st_uselect) {
		/* nr cols == 2 ie push through op1 and op2 */
		if (join->op2.stval->nrcols >= 1) {
			select = stmt_dup(select);
			res = stmt_uselect(stmt_push_down_head(stmt_dup(join->op1.stval), select), stmt_push_down_head(stmt_dup(join->op2.stval), select), (comp_type) join->flag);
			stmt_destroy(join);
			return res;
		}
	} else if (join->type == st_relselect) {
		list *l = create_stmt_list();
		node *n;

		for (n = join->op1.lval->h; n; n = n->next) {
			l = list_append(l, stmt_push_down_head(stmt_dup(n->data), stmt_dup(select)));
		}
		stmt_destroy(select);
		stmt_destroy(join);
		return stmt_relselect(l);
	} else if (join->type == st_bat || join->type == st_column || 
		   join->type == st_append) {
		return stmt_semijoin(join, select);
#ifndef NDEBUG
	} else {
		printf("= TODO: common/optimize.c: push down head %s\n", st_type2string(join->type));
#endif
	}
	if (join == select) {
		stmt_destroy(select);
		return join;
	}
	return stmt_semijoin(join, select);
}

/* push select (idx, val) through join(idy,idx) */
static stmt *
stmt_push_down_tail(stmt *join, stmt *select)
{
	stmt *res;

	if (join->type == st_reljoin) {
		list *l1 = list_dup(join->op2.lval, (fdup) &stmt_dup);
		list *l2 = create_stmt_list();
		node *n;

		for (n = join->op2.lval->h; n; n = n->next) {
			l2 = list_append(l2, stmt_push_down_head(stmt_dup(n->data), stmt_dup(select)));
		}
		stmt_destroy(select);
		stmt_destroy(join);
		return stmt_reljoin2(l1, l2);
	} else if (join->type == st_join) {
		res = stmt_join(stmt_dup(join->op1.stval), stmt_push_down_tail(stmt_dup(join->op2.stval), select), (comp_type) join->flag);
		stmt_destroy(join);
		return res;
	} else if (join->type == st_join2) {
		res = stmt_join2(stmt_dup(join->op1.stval), stmt_reverse(stmt_push_down_tail(stmt_reverse(stmt_dup(join->op2.stval)), select)), stmt_reverse(stmt_push_down_tail(stmt_reverse(stmt_dup(join->op3.stval)), select)), join->flag);
		stmt_destroy(join);
		return res;
	} else if (join->type == st_intersect) {
		select = stmt_dup(select);
		res = stmt_intersect(stmt_push_down_tail(stmt_dup(join->op1.stval), select), stmt_push_down_tail(stmt_dup(join->op2.stval), select)
		    );
		stmt_destroy(join);
		return res;
	} else if (join->type == st_reverse) {
		res = stmt_reverse(stmt_push_down_head(stmt_dup(join->op1.stval), select));
		stmt_destroy(join);
		return res;
	} else if (join->type == st_diff) {
		stmt *tail = stmt_reverse(stmt_dup(join->op2.stval));
		stmt *op2 = stmt_reverse(stmt_semijoin(tail, select));

		res = stmt_diff(stmt_dup(join->op1.stval), op2);
		stmt_destroy(join);
		return res;
	} else if (join->type == st_semijoin) {
		res = stmt_semijoin(stmt_push_down_tail(stmt_dup(join->op1.stval), select), stmt_dup(join->op2.stval)
		    );
		stmt_destroy(join);
		return res;
	} else if (join->type == st_bat) {
		return stmt_reverse(stmt_semijoin(stmt_reverse(join), select));
		/* TODO find pivot in ptable, and push select through the ptable  */
	} else if (join->type == st_pivot) {
		/* make sure the ptable is optimized */
		stmt *nj = optimize( /* BUG no context avail */ NULL, join);

		return stmt_push_down_tail(nj, select);
	} else if (join->type == st_mark) {
		/* for now pushin through a mark is wrong, it should
		 * push through both sides, to keep ordered oids.
		 res = stmt_mark(stmt_push_down_tail(
		 stmt_dup(join->op1.stval), select), 
		 (comp_type)join->flag);
		 stmt_destroy(join);
		 return res;
		 */
		return stmt_reverse(stmt_semijoin(stmt_reverse(join), select));
#ifndef NDEBUG
	} else {
		printf("= TODO: common/optimize.c: push down tail %s\n", st_type2string(join->type));
#endif
	}
	stmt_destroy(select);
	return join;
}

static stmt *stmt_push_join_tail(stmt *s, stmt *join);
static stmt *
stmt_push_join_head(stmt *s, stmt *join)
{
	/* found target of push-down: a [rel]join */
	if (s->type == st_reljoin) {
		list *l1 = create_stmt_list();
		list *l2 = list_dup(s->op2.lval, (fdup) &stmt_dup);
		node *n;

		for (n = s->op1.lval->h; n; n = n->next) {
			l1 = list_append(l1, stmt_join(stmt_dup(join), stmt_dup(n->data), cmp_equal));
		}
		stmt_destroy(join);
		stmt_destroy(s);
		return stmt_reljoin2(l1, l2);
	} else if (s->type == st_join) {
		stmt *op1 = stmt_join(join, stmt_dup(s->op1.stval), cmp_equal);
		stmt *res = stmt_join(op1, stmt_dup(s->op2.stval), (comp_type) s->flag);

		stmt_destroy(s);
		return res;
	} else if (s->type == st_join2) {
		stmt *op1 = stmt_push_join_head(stmt_dup(s->op1.stval), join);
		stmt *res = stmt_join2(op1, 
					stmt_dup(s->op2.stval), 
					stmt_dup(s->op3.stval), 
					(comp_type) s->flag);

		stmt_destroy(s);
		return res;
	/* recursively proceed push-down/search for join through some operations */
	} else if (s->type == st_reverse) {
		stmt *res = stmt_reverse(stmt_push_join_tail(stmt_dup(s->op1.stval), stmt_reverse(join)));

		stmt_destroy(s);
		return res;
	} else if (s->type == st_intersect) {
		stmt *res = stmt_intersect(stmt_push_join_head(stmt_dup(s->op1.stval), join),
					   stmt_push_join_head(stmt_dup(s->op2.stval), stmt_dup(join)));

		stmt_destroy(s);
		return res;
	} else if (s->type == st_diff) {
		stmt *op1 = stmt_join(join, stmt_dup(s->op1.stval), cmp_equal);
		stmt *res = stmt_diff(op1, stmt_dup(s->op2.stval));

		stmt_destroy(s);
		return res;
	} else if (s->type == st_semijoin) {
		stmt *jn = stmt_dup(join);
		stmt *op1 = stmt_push_join_head(stmt_dup(s->op1.stval), jn);
		stmt *op2 = stmt_push_join_head(stmt_dup(s->op2.stval), jn);
		stmt *res = stmt_semijoin(op1, op2);

		stmt_destroy(s);
		return res;
	/* push joins only through "head-tail" selects (i.e., "theta-intersection": h == h && t [cmp] t) */
	/* no need to push joins through simple selects or relselects */
	} else if (s->type == st_select) {
		if (s->op2.stval->nrcols >= 1) {
			stmt *jn = stmt_dup(join);
			stmt *op1 = stmt_push_join_head(stmt_dup(s->op1.stval), jn);
			stmt *op2 = stmt_push_join_head(stmt_dup(s->op2.stval), jn);
			stmt *res = stmt_select(op1, op2, (comp_type) s->flag);

			stmt_destroy(s);
			return res;
		}
	} else if (s->type == st_uselect) {
		if (s->op2.stval->nrcols >= 1) {
			stmt *jn = stmt_dup(join);
			stmt *op1 = stmt_push_join_head(stmt_dup(s->op1.stval), jn);
			stmt *op2 = stmt_push_join_head(stmt_dup(s->op2.stval), jn);
			stmt *res = stmt_uselect(op1, op2, (comp_type) s->flag);

			stmt_destroy(s);
			return res;
		}
	} else if (s->type == st_select2 || s->type == st_uselect2){
	} else if (s->type == st_relselect) {
/*
		list *l = create_stmt_list();
		node *n;

		for (n = s->op1.lval->h; n; n = n->next) {
			l = list_append(l, stmt_push_join_head(stmt_dup(n->data), stmt_dup(join)));
		}
		stmt_destroy(s);
		stmt_destroy(join);
		return stmt_relselect(l);
*/
	/* known ends of recursion */
	} else if (s->type == st_idxbat){
	} else if (s->type == st_bat){
	/* unknown end of recursion */
#ifndef NDEBUG
	} else {
		printf("= TODO: common/optimize.c: push join head %s\n", st_type2string(s->type));
#endif
	}
	return stmt_join(join, s, cmp_equal);
}

static stmt *
stmt_push_join_tail(stmt *s, stmt *join)
{
	/* found target of push-down: a [rel]join */
	if (s->type == st_reljoin) {
		list *l1 = list_dup(s->op1.lval, (fdup) &stmt_dup);
		list *l2 = create_stmt_list();
		node *n;

		for (n = s->op2.lval->h; n; n = n->next) {
			l2 = list_append(l2, stmt_join(stmt_reverse(stmt_dup(join)), stmt_dup(n->data), cmp_equal));
		}
		stmt_destroy(s);
		stmt_destroy(join);
		return stmt_reljoin2(l1, l2);
	} else if (s->type == st_join) {
		stmt *op2 = stmt_join(stmt_dup(s->op2.stval), join, cmp_equal);
		stmt *res = stmt_join(stmt_dup(s->op1.stval), op2,
				      (comp_type) s->flag);

		stmt_destroy(s);
		return res;
	} else if (s->type == st_join2) {
		stmt *op2 = stmt_push_join_tail( stmt_reverse(stmt_dup(s->op2.stval)), join);
		stmt *op3 = stmt_push_join_tail( stmt_reverse(stmt_dup(s->op3.stval)), stmt_dup(join));
		stmt *res = stmt_join2(stmt_dup(s->op1.stval), 
				       stmt_reverse(op2), stmt_reverse(op3),
				      (comp_type) s->flag);

		stmt_destroy(s);
		return res;
	/* recursively proceed push-down/search for join through some operations */
	} else if (s->type == st_semijoin) {
		stmt *op1 = stmt_push_join_tail( stmt_dup(s->op1.stval), join);
		stmt *res = stmt_semijoin( op1, stmt_dup(s->op2.stval) );
		stmt_destroy(s);
		return res;
	} else if (s->type == st_reverse) {
		stmt *res = stmt_reverse(stmt_push_join_head(stmt_dup(s->op1.stval), stmt_reverse(join)));

		stmt_destroy(s);
		return res;
	} else if (s->type == st_intersect) {
		stmt *res = stmt_intersect(stmt_push_join_tail(stmt_dup(s->op1.stval), join),
					   stmt_push_join_tail(stmt_dup(s->op2.stval), stmt_dup(join))
		    );

		stmt_destroy(s);
		return res;
	} else if (s->type == st_diff) {
		stmt *op2 = stmt_join(stmt_dup(s->op2.stval), join, cmp_equal);
		stmt *res = stmt_diff(stmt_dup(s->op1.stval), op2);

		stmt_destroy(s);
		return res;
	/* known ends of recursion */
	} else if (s->type == st_idxbat) {
	/* unknown end of recursion */
#ifndef NDEBUG
	} else {
		printf("= TODO: common/optimize.c: push join tail %s\n", st_type2string(s->type));
#endif
	}
	return stmt_join(s, join, cmp_equal);
}

static stmt *
stmt_jdx2select(stmt *j, stmt *hp, stmt *tp)
{
	stmt *res = NULL;
	if (j->type == st_reverse) {
		res = stmt_jdx2select(stmt_dup(j->op1.stval), tp, hp);
		stmt_destroy(j);
		return stmt_reverse(res);
	} else if (j->type == st_semijoin) {
		hp = stmt_semijoin(stmt_reverse(hp), stmt_dup(j->op2.stval));
		res = stmt_jdx2select(stmt_dup(j->op1.stval), stmt_reverse(hp), tp);
		stmt_destroy(j);
		return res;
	} else if (j->type == st_idxbat) {
		hp = stmt_join(hp, j, cmp_equal);
		return stmt_uselect(hp, tp, cmp_equal);
	}
	assert(0);
	return res;
}

static stmt *
stmt_join2select(stmt *j)
{

	if (j->type == st_join) {
		stmt *res = stmt_uselect(stmt_dup(j->op1.stval),
					 stmt_reverse(stmt_dup(j->op2.stval)),
					 (comp_type) j->flag);

		stmt_destroy(j);
		return res;
	} else if (j->type == st_idxbat) {
		assert(0); /* handled earlier */
	} else if (j->type == st_join2) {
		stmt *res = stmt_select2(stmt_dup(j->op1.stval),
					 stmt_dup(j->op2.stval),
					 stmt_dup(j->op3.stval),
					 j->flag);
		stmt_destroy(j);
		return res;
	} else if (j->type == st_reverse) {
		stmt *res = stmt_join2select(stmt_dup(j->op1.stval));

		stmt_destroy(j);
		return res;
	} else if (j->type == st_intersect) {
		stmt *res = stmt_semijoin(stmt_join2select(stmt_dup(j->op1.stval)),
					  stmt_join2select(stmt_dup(j->op2.stval)));

		stmt_destroy(j);
		return res;
	} else if (j->type == st_semijoin) {
		stmt *res = stmt_semijoin(stmt_join2select(stmt_dup(j->op1.stval)),
					  stmt_dup(j->op2.stval));

		stmt_destroy(j);
		return res;
#ifndef NDEBUG
	} else {
		printf("= TODO: common/optimize.c: join2select %s\n", st_type2string(j->type));
#endif
	}
	return j;
}

/* push the semijoin of (select,s) through the select statement (select) */
stmt *
push_semijoin( stmt *select, stmt *s )
{
	if (select->type == st_convert){ 
		sql_subtype f = select->op3.typeval;
		sql_subtype t = select->op4.typeval;
		stmt *op1 = stmt_dup(select->op1.stval);

		op1 = push_semijoin(op1, s);
		stmt_destroy(select);
		return stmt_convert(op1, &f, &t);
	}
	if (select->type == st_unop){ 
		stmt *op1 = stmt_dup(select->op1.stval);

		op1 = push_semijoin(op1, s);
		stmt_destroy(select);
		return stmt_unop(op1, sql_dup_func(select->op4.funcval));
	}
	if (select->type == st_binop) {
		stmt *op1 = stmt_dup(select->op1.stval);
		stmt *op2 = stmt_dup(select->op2.stval);
		if (op1->nrcols) 
			op1 = push_semijoin(op1, stmt_dup(s));
		if (op2->nrcols) 
			op2 = push_semijoin(op2, stmt_dup(s));
		stmt_destroy(select);
		stmt_destroy(s);
		return stmt_binop(op1, op2, sql_dup_func(select->op4.funcval));
	}
	if (select->type == st_diff) {
		stmt *op1 = stmt_dup(select->op1.stval);
		stmt *op2 = stmt_dup(select->op2.stval);

		op1 = push_semijoin(op1, s);
		stmt_destroy(select);
		return stmt_diff(op1, op2);
	}
	if (select->type == st_union) {
		stmt *op1 = stmt_dup(select->op1.stval);
		stmt *op2 = stmt_dup(select->op2.stval);

		op1 = push_semijoin(op1, stmt_dup(s));
		op2 = push_semijoin(op2, s);
		stmt_destroy(select);
		return stmt_union(op1, op2);
	}

	/* semijoin(reverse(semijoin(reverse(x)),s) */
	if (select->type == st_reverse &&
	    select->op1.stval->type == st_semijoin &&
	    select->op1.stval->op1.stval->type == st_reverse) {
		stmt *op1 = stmt_dup( select->op1.stval->op1.stval->op1.stval);
		stmt *op2 = stmt_dup( select->op1.stval->op2.stval);

		op1 = push_semijoin( op1, s );
		stmt_destroy(select);
		return stmt_reverse(stmt_semijoin( stmt_reverse(op1), op2));
	}
	if (select->type != st_select2 && select->type != st_uselect2 &&
	    select->type != st_select && select->type != st_uselect)
		return stmt_semijoin(select, s);

	s = push_semijoin(stmt_dup(select->op1.stval), s);
	if (select->type == st_select2) {
		comp_type cmp = (comp_type)select->flag;
		stmt *op2 = stmt_dup( select->op2.stval);
		stmt *op3 = stmt_dup( select->op3.stval);

		stmt_destroy(select);
		return stmt_select2( s, op2, op3, cmp);
	}

	if (select->type == st_uselect2) {
		comp_type cmp = (comp_type)select->flag;
		stmt *op2 = stmt_dup( select->op2.stval);
		stmt *op3 = stmt_dup( select->op3.stval);

		stmt_destroy(select);
		return stmt_uselect2( s, op2, op3, cmp);
	}

	if (select->type == st_select) {
		comp_type cmp = (comp_type)select->flag;
		stmt *op2 = stmt_dup( select->op2.stval);

		if (cmp == cmp_like || cmp == cmp_notlike) {
			stmt *op3 = stmt_dup( select->op3.stval);

			stmt_destroy(select);
			return stmt_likeselect( s, op2, op3, cmp);
		} else {
			stmt_destroy(select);
			return stmt_select( s, op2, cmp);
		}
	}

	if (select->type == st_uselect) {
		comp_type cmp = (comp_type)select->flag;
		stmt *op2 = stmt_dup( select->op2.stval);

		stmt_destroy(select);
		return stmt_uselect( s, op2, cmp);
	}
	assert(0);
	return NULL;
}




static stmt *
stmt_push_down_head_wrap(stmt *j, stmt *sel)
{
	return stmt_push_down_head(stmt_dup(j), stmt_dup(sel));
}
static stmt *
stmt_push_down_tail_wrap(stmt *j, stmt *sel)
{
	return stmt_push_down_tail(stmt_dup(j), stmt_dup(sel));
}

#define sSTMT_BAT(type) (type == st_bat || type == st_idxbat)
int STMT_BAT(int type ) {
	return sSTMT_BAT(type);
}

static sql_idx *
find_fk_index(list * eqjoins, int tail, list **fkjoins)
{
	sql_idx *hi = NULL, *ti = NULL;
	sql_table *htab, *ttab;
	node *in;
	stmt *join = eqjoins->h->data;

	assert(fkjoins && *fkjoins == NULL);

	if (!STMT_BAT(join->op1.stval->type) ||
		/* assumes reverse */
	    !STMT_BAT(join->op2.stval->op1.stval->type) )
		return NULL;

	if(tail) {
		htab = join->t->op1.tval;
		ttab = join->h->op1.tval;
	} else {
		htab = join->h->op1.tval;
		ttab = join->t->op1.tval;
	}
	if(htab->idxs.set)
	   for(in = htab->idxs.set->h; in; in = in->next){
	    	hi = in->data;
		if (hi->type == join_idx){
		        ti = ((sql_fkey*)hi->key)->rkey->k.idx;
              			if (ti->t == ttab) {
              				node *hn, *tn;
              				int ic = 0;
              				*fkjoins = create_stmt_list();
              				for(hn = hi->columns->h, tn = ti->columns->h; hn && tn; hn = hn->next, tn = tn->next, ic++){
              					node * jn;
              					int hcolnr = ((sql_kc*)hn->data)->c->colnr & 65535;
              					int tcolnr = ((sql_kc*)tn->data)->c->colnr & 65535;
              					int htcolnr;
              					if(tail) 
              						htcolnr = (tcolnr<<16) | hcolnr;
              					else
              						htcolnr = (hcolnr<<16) | tcolnr;
              					if ((jn = list_find(eqjoins, (void*)&htcolnr, (fcmp)&join_cmp_htcolnr))) {
              						stmt * js = jn->data;
              						/*if (js->op1.stval->type==st_bat && js->op2.stval->op1.stval->type==st_bat)*/ {
              							list_append(*fkjoins,stmt_dup(js));
              						}
              					}
              				}
              				if (list_length(*fkjoins) == ic) {
              					break;
              				} else {
              					list_destroy(*fkjoins);
              					*fkjoins = NULL;
              				}
			}
		}
	}
	if(*fkjoins)
		return hi;
	else
		return NULL;
}

/*
 * The push_selects_down function converts a conjunction set into a
 * reduced conjuntion tree where the selects are grouped together and
 * pushed under the join. Also joins are grouped together.
 * */
static list *
push_selects_down(mvc *c, list *con)
{
	int one = 1;
	int two = 2;

	list *rsel;
	list *res = create_stmt_list();
	list *sels, *dsels, *joins, *djoins;
	node *n = NULL;

	sels = list_select(con, (void *) &one, (fcmp) &stmt_cmp_nrcols, (fdup) &stmt_dup);
	dsels = list_distinct(sels, (fcmp) &stmt_cmp_head_tail, (fdup) &stmt_dup);

	joins = list_select(con, (void *) &two, (fcmp) &stmt_cmp_nrcols, (fdup) &stmt_dup);
	djoins = list_distinct(joins, (fcmp) &stmt_cmp_head_tail, (fdup) &stmt_dup);
	if (list_length(sels) > list_length(dsels)) {
		rsel = create_stmt_list();
		for (n = dsels->h; n; n = n->next) {
			list *esels = list_select(sels, n->data, (fcmp) &stmt_cmp_head_tail, (fdup) &stmt_dup);
			list *osels = list_order(esels, (fcmp) &stmt_cmp, (fdup) &stmt_dup);
			stmt *sel = stmt_relselect(osels);

			list_destroy(esels);

			/* TODO check for primary/foreign key selects */
			list_append(rsel, sel);
		}
		list_destroy(dsels);
	} else {
		rsel = dsels;
	}
	list_destroy(sels);

	/* TODO join order rewrites */
	for (n = djoins->h; n; n = n->next) {
		list *ejoins = list_select(joins, n->data, (fcmp) &stmt_cmp_head_tail, (fdup) &stmt_dup);
		stmt *join = ejoins->h->data;
		list *eqjoins = NULL, *nqjoins = NULL, *rjoins = NULL;
		stmt *reljoin = NULL, *jdx = NULL;
		node *hsel = NULL, *tsel = NULL;
		node * jn;

		/* align joined tables */
		for(jn = ejoins->h; jn; jn = jn->next) {
			stmt *j = jn->data;

			if (j->t == join->h && j->type == st_join) {
				stmt *jh = stmt_dup(j->op2.stval->op1.stval);
				stmt *jt = stmt_reverse(stmt_dup(j->op1.stval));
				jn->data = stmt_join(jh, jt, swap_compare((comp_type)j->flag));
				stmt_destroy(j);
			} else if (j->type == st_reljoin &&
				   STMT_BAT(j->op1.stval->type) && 
				   STMT_BAT(j->op2.stval->op1.stval->type) &&
				   j->t == join->h) {
				list *l1 = list_dup(j->op1.lval, (fdup)&stmt_dup);
				list *l2 = list_dup(j->op2.lval, (fdup)&stmt_dup);
				/* change order reljoin ? */
				assert(0);
				jn->data = stmt_reljoin2(l2,l1);
				stmt_destroy(j);
			}
		}

		if (!mvc_debug_on(c,32768)) {
			/* check for foreign key joins */
			eqjoins = list_select(ejoins, (void*)1L, (fcmp)&join_cmp_eq, (fdup)&stmt_dup );
			if (list_length(eqjoins) > 0) {
				list *fkjoins = NULL;
				sql_idx *idx = NULL;
				int tail = 0;

				/* look for foreign key index */
				if (!(idx = find_fk_index(eqjoins, tail, &fkjoins))) {
					tail = 1;
					idx = find_fk_index(eqjoins, tail, &fkjoins);
				}

				/* replace foreign key joins by index */
				if (idx && fkjoins) {
					int nr = 0;
					jdx = stmt_idxbat(idx, RDONLY);
					jdx->nrcols = 2;
					if(tail) {
						jdx->h = stmt_dup(((stmt*)fkjoins->h->data)->t);
						jdx->t = stmt_dup(((stmt*)fkjoins->h->data)->h);
					} else {
						jdx->h = stmt_dup(((stmt*)fkjoins->h->data)->h);
						jdx->t = stmt_dup(((stmt*)fkjoins->h->data)->t);
					}
	
					/* remove joins replaced by the join idx */
					for(jn = fkjoins->h; jn; jn = jn->next) {
						node * nj = list_find(ejoins, jn->data, (fcmp)&data_cmp);
						assert(nj);
						list_remove_node(ejoins, nj);
						nr ++;
					}
					assert(nr == list_length(fkjoins));
					c->opt_stats[0]++; 
				}
				if (fkjoins)
					list_destroy(fkjoins);
			}
			list_destroy(eqjoins);
		}

		if (list_length(ejoins) > 0) {
			/* push select through all remaining joins */
			join = ejoins->h->data;
			hsel = list_find(rsel, (void*)join, (fcmp)&cmp_sel_head);
			tsel = list_find(rsel, (void*)join, (fcmp)&cmp_sel_tail);

			if (hsel) {
				stmt *sel = hsel->data;
				list *nejoins = list_map(ejoins, sel,
					 (fmap) &stmt_push_down_head_wrap);

				sel->nr++;
				list_destroy(ejoins);
				ejoins = nejoins;
			}
			if (tsel) {
				stmt *sel = tsel->data;
				list *nejoins = list_map(ejoins, sel,
					 (fmap) &stmt_push_down_tail_wrap);
	
				sel->nr++;
				list_destroy(ejoins);
				ejoins = nejoins;
			}
		} else if (jdx) {
			hsel = list_find(rsel, (void*)jdx, (fcmp)&cmp_sel_head);
			tsel = list_find(rsel, (void*)jdx, (fcmp)&cmp_sel_tail);
			/* first select on the unique values */
			if (tsel){
				stmt *sel = tsel->data;
				jdx = stmt_reverse(stmt_semijoin(stmt_reverse(jdx), stmt_dup(sel)));
				sel->nr++;
			}
			if (hsel) {
				stmt *sel = hsel->data;
				/* reduced using the primary key -> stmt_join */

				/* select get replace, ie mark old
					   as used in the query */
				sel->nr++;
				if (tsel) {
					sel = push_semijoin(stmt_dup(sel), stmt_dup(jdx));
					jdx = stmt_semijoin(jdx, sel);
				} else {
					jdx = stmt_semijoin(jdx, stmt_dup(sel));
				}
			}
		}

		/* look for multi-att equi-join candidates */
		eqjoins = list_select(ejoins, (void *) 1L, (fcmp) &join_cmp_eq, (fdup) &stmt_dup);
		if (list_length(eqjoins) > 1) {
			/* rewrite conjuction of equi-join into multi-att equi-join */
			reljoin = stmt_reljoin1(eqjoins);
			/* collect the remaining non-equi joins */
			nqjoins = list_select(ejoins, (void *) 1L, (fcmp) &join_cmp_neq, (fdup) &stmt_dup);
			list_destroy(ejoins);
		} else {
			/* no multi-att equi-join found; treat all joins equally */
			reljoin = NULL;
			nqjoins = ejoins;
		}
		list_destroy(eqjoins);

		/* look for range join candidates (ie collect theta joins) */
		rjoins = create_stmt_list();
		while (list_length(nqjoins) > 1) {
			node *n = nqjoins->h;
			stmt *o1 = stmt_dup(n->data);

			list_remove_node(nqjoins, n);
			n = list_find(nqjoins, o1, (fcmp)&cmp_matching_column);
			if (n) {
				stmt *s, *o2 = stmt_dup(n->data);
				stmt *o1c = getcolumn(o1->op1.stval);
				stmt *o2c = getcolumn(o2->op1.stval);
				int cmp = 0;

				list_remove_node(nqjoins, n);
				if (o1->flag > o2->flag){
					s = o1; 
					o1 = o2; 
					o2 = s;
				}
				if (o1->flag == cmp_gt && o2->flag == cmp_lt)
					cmp = 0;
				else if (o1->flag == cmp_gt && o2->flag == cmp_lte)
					cmp = 1;
				else if (o1->flag == cmp_gte && o2->flag == cmp_lt)
					cmp = 2;
				else if (o1->flag == cmp_gte && o2->flag == cmp_lte)
					cmp = 3;
				else
					assert(0);
	
				if (o1c && o2c && o1c == o2c) {
					s = stmt_join2(
						stmt_dup(o1->op1.stval),
						stmt_reverse(stmt_dup(o1->op2.stval)),
						stmt_reverse(stmt_dup(o2->op2.stval)),
						cmp);
				} else {
					s = stmt_join2(
						stmt_reverse(stmt_dup(o1->op2.stval)),
						/* we need to swap order too */
						stmt_dup(o2->op1.stval),
						stmt_dup(o1->op1.stval),
						3-cmp);
				}
				stmt_destroy(o1);
				stmt_destroy(o2);

				/* prepend as 2 joins in one are hopefully 
			   	more restrictive then a single join */
				list_prepend(rjoins, s);
			}  else {
				list_append(rjoins, o1);
			}
		}
		if (list_length(rjoins)) {
			if (list_length(nqjoins) == 1)
				list_append(rjoins, stmt_dup(nqjoins->h->data));
			list_destroy(nqjoins);
			nqjoins = rjoins;
		} else {
			list_destroy(rjoins);
		}

		/* re-add fk join index and multi-att equi-join to the collection */
		if (jdx) 
			list_append(nqjoins, jdx);

		/* changes to [].().select(TRUE) */
		join = (stmt *) list_reduce(nqjoins, (freduce) &stmt_intersect, (fdup) &stmt_dup);
		list_destroy(nqjoins);

		if (reljoin && join) {
			join = stmt_intersect(reljoin, join);
		} else if (reljoin) {
			join = reljoin;
		}

		if (!join)
			assert(0);
		list_append(res, join);
	}
	/* find least expensive join (with head/tail selects) */
	/* continue finding usages of this until done */

	list_destroy(joins);
	list_destroy(djoins);

	if (!list_length(res)) {
		if (list_length(rsel) == 1) {
			stmt *L = rsel->h->data;

			L->nr = 0;
			list_destroy(res);
			return rsel;
		} else {
			/* add implicit cross products */
			node *n;

			for (n = rsel->h; n && n->next; n = n->next) {
				stmt *L = n->data;
				stmt *R = n->next->data;

				L->nr = 0;
				R->nr = 0;
				list_append(res, stmt_join(stmt_dup(L), stmt_reverse(stmt_dup(R)), cmp_all));
			}
		}
	} else {		/* check if all selects are used by the joins */
		for (n = rsel->h; n; n = n->next) {
			stmt *L = n->data;

			if (!L->nr) {	/* not used!! */
				stmt *R = res->h->data;

				list_append(res, stmt_join(stmt_dup(L), stmt_reverse(stmt_dup(R)), cmp_all));
			}
			L->nr = 0;
		}
	}
	list_destroy(rsel);
	return res;
}

static int
is_jdx( stmt *j )
{
	switch(j->type) {
	case st_semijoin:
	case st_join:
	case st_join2:
	case st_reverse:
		return is_jdx(j->op1.stval);
	case st_idxbat:
		return 1;
	default:
		return 0;
	}
	return 0;
}

/* TODO: we do not need a mark on 1-1 joins, then the old head is unique */
list *
mk_pivot(list *pivots, stmt *st, stmt *p, int markid)
{
	list *npivots;
	stmt *j, *pnl, *pnr;
	node *pn;

	node *tp = list_find(pivots, (void *) st, (fcmp) &pivot_cmp_tail);

	if (tp && is_jdx(st)) {
		j = stmt_jdx2select(st, p, stmt_dup(tp->data));
	} else {
		j = stmt_push_join_head(st, p);
		if (tp) {
			/* convert to a select [op](l,r).select(TRUE); */
			j = stmt_push_join_tail(j, stmt_reverse(stmt_dup(tp->data)));
			j = stmt_join2select(j);
		}
	}

	pnr = stmt_mark(stmt_reverse(j), markid);

	npivots = create_stmt_list();
	if (!tp) {
		pnl = stmt_mark(stmt_dup(j), markid);
		list_append(npivots, pnl);
	}
	for (pn = pivots->h; pn; pn = pn->next) {
		list_append(npivots, stmt_join(stmt_dup(pnr), stmt_dup(pn->data), cmp_equal));
	}
	stmt_destroy(pnr);
	return npivots;
}

static stmt *
set2pivot(mvc *c, list *l)
{
	list *lo = create_stmt_list();
	list *pivots = create_stmt_list();
	stmt *join, *st = NULL;
	node *n;
	int len = 0;
	int markid = 0;

	l = push_selects_down(c, l);

	/* order l according to ascending "size" */
	while (list_length(l)) {
		join = (stmt*)list_reduce(l, (freduce)&stmt_smallest, (fdup)&stmt_dup);
		assert(join);
		n = list_find(l, (void*)join, data_cmp);
		assert(n);
		list_append(lo,join);
		list_remove_node(l,n);
	}
	list_destroy(l);
	l = lo;
	/* end of order */

	n = l->h;
	assert(n);
	st = n->data;
	if (st->nrcols == 1) {
		if (st->type == st_idxbat) {
			list_append(pivots, stmt_mirror(stmt_dup(st)));
		} else {
			list_append(pivots, stmt_mark(stmt_reverse(stmt_dup(st)), markid++));
		}
	}
	if (st->nrcols == 2) {
		if (st->type == st_idxbat) {
			list_append(pivots, stmt_mirror(stmt_dup(st)));
			list_append(pivots, stmt_dup(st));
		} else {
			list_append(pivots, stmt_mark(stmt_reverse(stmt_dup(st)), markid));
			list_append(pivots, stmt_mark(stmt_dup(st), markid++));
		}
	}
	len = list_length(l);
	n = list_remove_node(l, n);
	assert(list_length(l)+1 == len);

	/* The join index joins are kept as (fk,pk). So first join on the
	   heads, ie foreign side */
	if (list_length(l) > 0 && len > 0) {
		n = l->h;
		while (n) {
			stmt *st = n->data;
			node *p = NULL;

			for (p = pivots->h; p; p = p->next) {
				list *nps = NULL;
				stmt *pv = p->data;

				if (pv->t == st->h) {
					nps = mk_pivot(pivots, stmt_dup(st), stmt_dup(pv), markid++);
					list_destroy(pivots);
					pivots = nps;
					n = list_remove_node(l, n);
					n = NULL; /* restart from smallest */
					break;
				}
			}
			if (n)
				n = n->next;
		}
	}
	while (list_length(l) > 0 && len > 0) {
		len--;
		n = l->h;
		while (n) {
			stmt *st = n->data;
			node *p = NULL;

			for (p = pivots->h; p; p = p->next) {
				list *nps = NULL;
				stmt *pv = p->data;

				if (pv->t == st->h) {
					nps = mk_pivot(pivots, stmt_dup(st), stmt_dup(pv), markid++);
					list_destroy(pivots);
					pivots = nps;
					n = list_remove_node(l, n);
					n = NULL; /* restart from smallest */
					break;
				} else if (pv->t == st->t) {
					nps = mk_pivot(pivots, stmt_reverse(stmt_dup(st)), stmt_dup(pv), markid++);
					list_destroy(pivots);
					pivots = nps;
					n = list_remove_node(l, n);
					n = NULL; /* restart from smallest */
					break;
				}
			}
			if (n)
				n = n->next;
		}
	}
	if (!len) {
		assert(0);
		return NULL;
	}
	list_destroy(l);
	return stmt_list(pivots);
}

/* two kinds of filters (list of stmts (st_set) or list of lists (st_sets)) */
static stmt *
filter_pivots(list *pivots, stmt *filters)
{
	if (filters->type == st_set) {
		stmt *filter = list_reduce(filters->op1.lval, (freduce) &stmt_semijoin, (fdup) &stmt_dup);
		list *nl = create_stmt_list();
		node *n;

		for (n = pivots->h; n; n = n->next) {
			stmt *p = stmt_dup(n->data);
			stmt *np = stmt_semijoin(p, stmt_dup(filter));

			list_append(nl, np);
		}
		stmt_destroy(filter);
		return stmt_list(nl);
	} else { /* this only handle one common case (filter on same 
			relation result) */
		/* union(filter(pivots,f1), filter(pivots,f2)) */
		node *m;
		list *nl = create_stmt_list();

		m = filters->op1.lval->h; 
		if (m) {
			list *f = m->data;
			stmt *filter = list_reduce(f, (freduce) &stmt_semijoin, (fdup) &stmt_dup);
			node *n;

			for (n = pivots->h; n; n = n->next) {
				stmt *p = stmt_dup(n->data);
				stmt *np = stmt_semijoin(p, stmt_dup(filter));

				list_append(nl, np);
			}
			stmt_destroy(filter);
		}
	
		for (m = m->next; m; m = m->next) {
			list *f = m->data, *nnl = create_stmt_list();
			stmt *filter = list_reduce(f, (freduce) &stmt_semijoin, (fdup) &stmt_dup);
			node *n, *o;

			for (n = pivots->h, o = nl->h; n && o; n = n->next, o = o->next) {
				stmt *q = stmt_dup(o->data);
				stmt *p = stmt_dup(n->data);
				stmt *np = stmt_semijoin(p, stmt_dup(filter));

				list_append(nnl, stmt_union(q, np));
			}
			list_destroy(nl);
			nl = nnl;
			stmt_destroy(filter);
		}
		return stmt_list(nl);
	}
}

/* The group code is needed for double elimination.
 * if a value is selected twice once on the left hand of the
 * 'OR' and once on the right hand of the 'OR' it will be in the
 * result twice.
 *
 * current version is broken, unique also remove normal doubles.
 */
static stmt *
sets2pivot(mvc *c, list *ll)
{
	node *n = ll->h;

	if (n) {
		stmt *pivots = set2pivot(c, n->data);

		n = n->next;
		while (n) {
			stmt *npivots = set2pivot(c, n->data);
			list *l = npivots->op1.lval;
			list *inserts = create_stmt_list();
			node *m, *c;

			/* we use a special bat insert to garantee unique head 
			 * oids 
			 */
			for (m = l->h; m; m = m->next) {
				for (c = pivots->op1.lval->h; c; c = c->next) {
					stmt *cd = c->data;
					stmt *md = m->data;

					if (cd->t == md->t) {
						list_append(inserts, stmt_append(stmt_dup(cd), stmt_dup(md)));
						break;
					}
				}
			}
			stmt_destroy(pivots);
			stmt_destroy(npivots);
			pivots = stmt_list(inserts);
			n = n->next;
		}
		{
			group *g = NULL;
			stmt *u;
			node *m;
			list *inserts = create_stmt_list();

			for (m = pivots->op1.lval->h; m; m = m->next) {
				g = grp_create(stmt_dup(m->data), g, NULL);
			}
			u = stmt_reverse(stmt_unique(stmt_reverse(stmt_dup(g->ext)), NULL));
			grp_destroy(g);

			for (m = pivots->op1.lval->h; m; m = m->next) {
				list_append(inserts, stmt_semijoin(stmt_dup(m->data), stmt_dup(u)));
			}
			stmt_destroy(u);
			stmt_destroy(pivots);
			return stmt_list(inserts);
		}
		/* no double elimination jet 
		   return pivots;
		 */
	}
	return NULL;
}

static stmt *
op_stmt2pivot(mvc * c, stmt *s)
{
	if (s->type != st_set && s->type != st_sets) {
		s = stmt_set(s);
	}
	if (s->type == st_sets) {
		stmt *ns = sets2pivot(c, s->op1.lval);

		stmt_destroy(s);
		s = ns;
	} else {
		stmt *ns = set2pivot(c, s->op1.lval);

		stmt_destroy(s);
		s = ns;
	}
	return s;
}

static stmt *
find_pivot(stmt *subset, stmt *t)
{
	assert(t);
	if (t) {
		node *n;

		for (n = subset->op1.lval->h; n; n = n->next) {
			stmt *s = n->data;

			if (s->t == t)
				return stmt_dup(s);
		}
	}
	assert(0);
	return NULL;
}


stmt *
optimize(mvc *c, stmt *s)
{
	stmt *res = s;

	assert(!(s->optimized < 1 && s->rewritten));
	if (s->optimized >= 1) {
		if (s->rewritten)
			return stmt_dup(s->rewritten);
		else
			return stmt_dup(s);
	}

	switch (s->type) {
		/* first just return those statements which we cannot optimize,
		 * such as schema manipulation, transaction managment, 
		 * and user authentication.
		 */
	case st_none:
	case st_connection:
	case st_sql:
	case st_rs_column:
	case st_dbat:
	case st_basetable:
	case st_idxbat:
	case st_bat:

	case st_atom:
	case st_import:
	case st_var:

		s->optimized = 1;
		return stmt_dup(s);

	case st_reljoin:{

		list *l1 = create_stmt_list();
		list *l2 = create_stmt_list();
		node *n1, *n2;
		stmt *res;

		for (n1 = s->op1.lval->h, n2 = s->op2.lval->h; n1 && n2; n1 = n1->next, n2 = n2->next) {
			list_append(l1, optimize(c, n1->data));
			list_append(l2, optimize(c, n2->data));
		}
		res = stmt_reljoin2(l1, l2);
		s->optimized = res->optimized = 1;
		if (res != s) {
			assert(s->rewritten==NULL);
			s->rewritten = stmt_dup(res);
		}
		return res;
	}

	case st_relselect:{

		list *l = create_stmt_list();
		node *n;
		stmt *res;

		for (n = s->op1.lval->h; n; n = n->next) {
			list_append(l, optimize(c, n->data));
		}
		res = stmt_relselect(l);
		s->optimized = res->optimized = 1;
		if (res != s) {
			assert(s->rewritten==NULL);
			s->rewritten = stmt_dup(res);
		}
		return res;
	}

	case st_temp:
	case st_filter:
	case st_select:
	case st_select2:
	case st_uselect:
	case st_uselect2:
	case st_semijoin:
	case st_diff:
	case st_intersect:
	case st_union:
	case st_outerjoin:
	case st_join:
	case st_join2:
	case st_mirror:
	case st_reverse:
	case st_const:
	case st_mark:
	case st_gen_group:
	case st_group:
	case st_group_ext:
	case st_derive:
	case st_unique:
	case st_limit:
	case st_order:
	case st_reorder:
	case st_ordered:

	case st_column:
	case st_alias:
	case st_output:
	case st_affected_rows:
	case st_append:
	case st_exception:

	case st_aggr:
	case st_op:
	case st_unop:
	case st_binop:
	case st_Nop:
	case st_convert:

	case st_while:
	case st_if:
	case st_return:
	case st_table:
	case st_assign:
	case st_export:

		if (s->op1.stval) {
			stmt *os = s->op1.stval;
			stmt *ns = optimize(c, os);

			assert(ns != s);
			s->op1.stval = ns;
			stmt_destroy(os);
		}

		if (s->type == st_export || s->type == st_convert) {
			s->optimized = 1;
			return stmt_dup(s);
		}

	case st_append_col:
	case st_append_idx:
	case st_update_col:
	case st_update_idx:
	case st_delete:
	case st_table_clear:

		if (s->op2.stval) {
			stmt *os = s->op2.stval;
			stmt *ns = optimize(c, os);
	
			assert(ns != s);
			s->op2.stval = ns;
			stmt_destroy(os);
		}
		if (s->op3.stval) {
			stmt *os = s->op3.stval;
			stmt *ns = optimize(c, os);
	
			assert(ns != s);
			s->op3.stval = ns;
			stmt_destroy(os);
		}
		s->optimized = 1;
		return stmt_dup(s);

	case st_list:{

		stmt *res = NULL;
		node *n;
		list *l = s->op1.lval;
		list *nl = NULL;

		nl = create_stmt_list();
		for (n = l->h; n; n = n->next) {
			stmt *ns = optimize(c, n->data);

			list_append(nl, ns);
		}
		res = stmt_list(nl);
		s->optimized = res->optimized = 1;
		if (res != s) {
			assert(s->rewritten==NULL);
			s->rewritten = stmt_dup(res);
		}
		return res;
	}

	case st_pivot:{

		stmt *ns = optimize(c, s->op2.stval);	/* optimize ptable */
		stmt *np = find_pivot(ns, s->t);

		stmt_destroy(ns);

		s->optimized = np->optimized = 1;
		if (np != s) {
			assert(s->rewritten==NULL);
			s->rewritten = stmt_dup(np);
		}
		return np;
	}

	case st_ptable:{
		if (ptable_parent(s)) {
			stmt *parent = optimize(c, ptable_parent(s));
			stmt *f, *np;

			if (!ptable_statements(s))
				return parent;
			/* filter statements */
			f = filter_pivots(parent->op1.lval, ptable_statements(s));
			stmt_destroy(parent);
			np = optimize(c, f);
			stmt_destroy(f);
			s->optimized = np->optimized = 1;
			if (np != s) {
				assert(s->rewritten==NULL);
				s->rewritten = stmt_dup(np);
			}
			return np;
		}
		if (ptable_statements(s)) {
			stmt *pivots = op_stmt2pivot(c, stmt_dup(ptable_statements(s)));

			/* also optimize the pivots */
			stmt *np = optimize(c, pivots);

			assert(np);
			stmt_destroy(pivots);
			s->optimized = np->optimized = 1;
			if (np != s) {
				assert(s->rewritten==NULL);
				s->rewritten = stmt_dup(np);
			}
			return np;
		}
		return s;
	}

	case st_set:
	case st_sets:
	default:
		assert(0);	/* these should have been rewriten by now */
	}
	return res;
}
