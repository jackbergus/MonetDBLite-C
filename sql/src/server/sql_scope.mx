@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2008 CWI.
@' All Rights Reserved.

@f sql_scope
@a N.J. Nes
@* 

@h
#ifndef _SQL_SCOPE_H_
#define _SQL_SCOPE_H_

#include "sql_mem.h"
#include "sql_statement.h"
#include "sql_list.h"

typedef struct tvar {
	sql_ref ref;

	list *columns;
	struct stmt *s;
	char *tname;
} tvar;

typedef struct cvar {
	sql_ref ref;

	struct stmt *s;
	tvar *table;
	char *tname;
	char *cname;
} cvar;

typedef struct var_ {
	sql_ref ref;

	char *name;
	struct stmt *s;
} var_;

typedef struct scope {
	stmt *ptable;		/* result pivot table */
	list *bases;		/* all used base tables ! */
	list *outers;		/* outer references */

	list *pivots;		/* pivots */
	list *ppivots;		/* partial pivots */

	list *tables;
	list *aliases;		/* list of aliased statements */
	struct scope *p;
} scope;

extern scope *scope_open(scope *p);
extern scope *scope_close(scope *s);

/*
 * scope_find_pivot finds the virtual pivot for the statement t
 * */
extern stmt *scope_find_pivot(scope *s, stmt *t);

/*
 * scope_first_pivot, return the first virtual pivot
 * */
extern stmt *scope_first_pivot(scope *s);

/* 
 * table_add_column adds a column (cvar) to the table t (tname could be NULL).
 * */
extern cvar *table_add_column(tvar *t, stmt *s, char *tname, char *cname);

/* 
 * scope_add_table adds a table (tvar) to the scope scp (name should be set). 
 * */
extern tvar *scope_add_table(scope *scp, stmt *table, char *name, sql_table *t);

/* 
 * scope_add_alias adds a alias for a stmt.
 * */
extern var_ *scope_add_alias(scope *scp, stmt *s, char *alias);

/* 
 * scope_add_var adds a local declared variable.
 * */
#define scope_add_var(scp,s,name) scope_add_alias(scp, s, name)


/* 
 * scope_bind_table finds a table in the scp with the given name, only needed
 * for name.* queries 
 * */
extern tvar *scope_bind_table(scope *scp, char *name);

/* 
 * scope_bind_column finds a column in the scp with the given tname.cname 
 * (where tname could be NULL) 
 * */
extern cvar *scope_bind_column(scope *scp, char *tname, char *cname);

/* 
 * scope_bind finds a column or alias in the scp the given name 
 * */
extern stmt *scope_bind(scope *scp, char *tname, char *cname);

extern cvar *scope_first_column(scope *scp);
extern tvar *scope_first_table(scope *scp);

extern void scope_dump(scope *s);

extern void var_destroy(var_ *t);
extern void tvar_destroy(tvar *t);

#endif /*_SQL_SCOPE_H_*/

@c

#include "sql_config.h"
#include "sql_scope.h"
#include <string.h>


static void
cvar_destroy(cvar *cv)
{
	if (sql_ref_dec(&(cv->ref)) == 0) {
		if (cv->s)
			stmt_destroy(cv->s);
		if (cv->tname)
			_DELETE(cv->tname);
		if (cv->cname)
			_DELETE(cv->cname);
		_DELETE(cv);
	} else {
		printf("couldn't destroy cvar %s.%s\n", cv->tname, cv->cname);
	}
}

void
tvar_destroy(tvar *v)
{
	if (sql_ref_dec(&(v->ref)) == 0) {
		list_destroy(v->columns);
		if (v->s)
			stmt_destroy(v->s);
		if (v->tname)
			_DELETE(v->tname);
		_DELETE(v);
	} else {
		printf("couldn't destroy tvar %s\n", v->tname);
	}
}

void
var_destroy(var_ *v)
{
	if (sql_ref_dec(&(v->ref)) == 0) {
		if (v->s)
			stmt_destroy(v->s);
		if (v->name)
			_DELETE(v->name);
		_DELETE(v);
	} else {
		printf("couldn't destroy var %s\n", v->name);
	}
}

scope *
scope_open(scope *p)
{
	scope *s = NEW(scope);

	s->ptable = stmt_ptable(stmt_ptable(NULL));
	s->pivots = list_create((fdestroy) &stmt_destroy);
	s->ppivots = list_create((fdestroy) &stmt_destroy);
	s->outers = list_create((fdestroy) &stmt_destroy);

	s->tables = list_create((fdestroy) &tvar_destroy);
	s->aliases = list_create((fdestroy) &var_destroy);
	s->p = p;
	s->bases = NULL;
	if (!p)
		s->bases = list_create((fdestroy) NULL);
	return s;
}

scope *
scope_close(scope *s)
{
	scope *p = s->p;

	stmt_destroy(s->ptable);

	list_destroy(s->pivots);
	list_destroy(s->ppivots);

	list_destroy(s->outers);

	list_destroy(s->tables);
	list_destroy(s->aliases);
	if (s->bases)
		list_destroy(s->bases);
	_DELETE(s);
	return p;
}

static stmt *
find_pivot(scope *scp, stmt *t)
{
	node *n;

	for (n = scp->ppivots->h; n; n = n->next) {
		stmt *p = n->data;

		if (p->t == t)
			return stmt_dup(p);
	}
	assert(0);
	return NULL;
}


stmt *
scope_find_pivot(scope *scp, stmt *t)
{
	return find_pivot(scp, t);
}

stmt *
scope_first_pivot(scope *scp)
{
	node *n = scp->ppivots->h;

	if (n)
		return stmt_dup(n->data);
	assert(0);
	return NULL;
}

static int
stmt_cmp(stmt *s1, stmt *s2)
{
	return (int) (s1 - s2);
}

static void
scope_add_table_(scope *scp, stmt *s, int outer)
{
	if (outer) {
		if (list_find(scp->outers, s, (fcmp) &stmt_cmp) == NULL)
			list_append(scp->outers, stmt_dup(s));
	}
	list_append(scp->pivots, stmt_pivot(stmt_dup(s), stmt_dup(scp->ptable)));
	list_append(scp->ppivots, stmt_pivot(stmt_dup(s), stmt_dup(ptable_parent(scp->ptable))));
}

cvar *
table_add_column(tvar *t, stmt *s, char *tname, char *cname)
{
	cvar *v = NEW(cvar);

	v->s = s;
	v->table = t;
	assert((!tname || strlen(tname)));

	v->tname = (tname) ? _strdup(tname) : NULL;
	v->cname = _strdup(cname);
	sql_ref_init(&(v->ref));
	list_append(t->columns, v);
	return v;
}

static void
scope_append_table(scope *scp, sql_table *t)
{
	if (scp->p) {
		scope_append_table(scp->p, t);
	} else {
		node *n;

		for (n = scp->bases->h; n; n = n->next) {
			sql_table *ot = n->data;

			if (t == ot)
				return;
		}
		list_append(scp->bases, t);
	}
}

tvar *
scope_add_table(scope *scp, stmt *s, char *tname, sql_table *t)
{
	tvar *v = NEW(tvar);

	if (t)
		scope_append_table(scp, t);
	v->s = s;
	v->columns = list_create((fdestroy) &cvar_destroy);
	v->tname = (tname) ? _strdup(tname) : NULL;
	sql_ref_init(&(v->ref));
	list_append(scp->tables, v);

	scope_add_table_(scp, s, 0);
	return v;
}

var_ *
scope_add_alias(scope *scp, stmt *s, char *name)
{
	var_ *v = NEW(var_);

	v->s = s;
	v->name = _strdup(name);
	sql_ref_init(&(v->ref));
	list_append(scp->aliases, v);
	return v;
}

tvar *
scope_bind_table(scope *scp, char *name)
{
	for (; scp; scp = scp->p) {
		node *n = scp->tables->h;

		for (; n; n = n->next) {
			tvar *v = n->data;

			if (v->tname && strcmp(v->tname, name) == 0) {
				return v;
			}
		}
	}
	return NULL;
}

static cvar *
scope_find_column(list *columns, char *cname)
{
	node *n = columns->h;

	for (; n; n = n->next) {
		cvar *c = n->data;

		if (strcmp(c->cname, cname) == 0) {
			return c;
		}
	}
	return NULL;
}

static cvar *
find_table_column(list *columns, char *tname, char *cname)
{
	node *n = columns->h;

	for (; n; n = n->next) {
		cvar *c = n->data;

		if (c->tname && strcmp(c->tname, tname) == 0 && strcmp(c->cname, cname) == 0) {
			return c;
		}
	}
	return NULL;
}

static int
ambiguous_column(list *cols, cvar *cv)
{
	node *n;

	if (!cv->tname)		/* no tname ie columns are unique */
		return 0;

	for (n = cols->h; n; n = n->next) {
		cvar *a = n->data;

		if (a != cv && strcmp(a->cname, cv->cname) == 0)
			return 1;
	}
	return 0;
}

cvar *
scope_bind_column(scope *scp, char *tname, char *cname)
{
	cvar *cv = NULL;

	if (!tname) {
		node *n = scp->tables->h;

		for (; n; n = n->next) {
			tvar *tv = n->data;

			if ((cv = scope_find_column(tv->columns, cname)) != NULL) {
				if (ambiguous_column(tv->columns, cv))
					return NULL;
				return cv;
			}
		}
	} else {
		node *n = scp->tables->h;

		for (; n; n = n->next) {
			tvar *tv = n->data;

			if (tv->tname && strcmp(tv->tname, tname) == 0 && (cv = scope_find_column(tv->columns, cname)) != NULL) {
				return cv;
			} else if (!tv->tname && (cv = find_table_column(tv->columns, tname, cname)) != NULL) {
				return cv;
			}
		}
	}
	return NULL;
}

static stmt *
scope_bind_column_(scope *scp, char *tname, char *cname)
{
	scope *start = scp;
	cvar *cv = NULL;

	if (!tname) {
		for (; scp; scp = scp->p) {
			node *n = scp->tables->h;

			for (; n; n = n->next) {
				tvar *tv = n->data;

				if ((cv = scope_find_column(tv->columns, cname)) != NULL) {
					if (ambiguous_column(tv->columns, cv))
						return NULL;
					if (start != scp) {
						stmt *s = find_pivot(scp, tv->s);

						/* add outer ref */
						scope_add_table_(start, s, 1);
						return stmt_column(stmt_join(s, stmt_dup(cv->s), cmp_equal), stmt_dup(s), NULL);
					}
					return stmt_dup(cv->s);
				}
			}
		}
		return NULL;
	}

	/* tname != NULL */
	for (; scp; scp = scp->p) {
		node *n = scp->tables->h;

		for (; n; n = n->next) {
			tvar *tv = n->data;

			if (tv->tname && strcmp(tv->tname, tname) == 0 && (cv = scope_find_column(tv->columns, cname)) != NULL) {
				if (start != scp) {
					stmt *s = find_pivot(scp, tv->s);

					/* add outer ref */
					scope_add_table_(start, s, 1);
					return stmt_column(stmt_join(s, stmt_dup(cv->s), cmp_equal), stmt_dup(s), NULL);
				}
				return stmt_dup(cv->s);
			} else if (!tv->tname && (cv = find_table_column(tv->columns, tname, cname)) != NULL) {
				if (start != scp) {
					stmt *s = find_pivot(scp, tv->s);

					/* add outer ref */
					scope_add_table_(start, s, 1);
					return stmt_column(stmt_join(s, stmt_dup(cv->s), cmp_equal), stmt_dup(s), NULL);
				}
				return stmt_dup(cv->s);
			}
		}
	}
	return NULL;
}

static var_ *
scope_bind_alias(scope *scp, char *name)
{
	for (; scp; scp = scp->p) {
		node *n = scp->aliases->h;

		for (; n; n = n->next) {
			var_ *v = n->data;

			if (strcmp(v->name, name) == 0)
				return v;
		}
	}
	return NULL;
}

stmt *
scope_bind(scope *scp, char *tname, char *cname)
{
	stmt *s = scope_bind_column_(scp, tname, cname);

	if (!s && !tname) {
		var_ *a = scope_bind_alias(scp, cname);

		if (a)
			return stmt_dup(a->s);
		return NULL;
	}
	return s;
}

cvar *
scope_first_column(scope *scp)
{
	if (scp->tables && list_length(scp->tables)) {
		node *n = scp->tables->h;
		tvar *tv = n->data;

		if (list_length(tv->columns)) {
			node *m = tv->columns->h;

			return m->data;
		}
	}
	return NULL;
}

/* first and only table */
tvar *
scope_first_table(scope *scp)
{
	for (; scp; scp = scp->p) {
		node *n = scp->tables->h;

		for (; n; n = n->next) {
			tvar *tv = n->data;

			return tv;
		}
	}
	return NULL;
}


void
scope_dump(scope *scp)
{
	for (; scp; scp = scp->p) {
		node *n = scp->tables->h;

		printf("\t-> tables: \n");
		for (; n; n = n->next) {
			tvar *tv = n->data;
			node *m = tv->columns->h;

			printf("\t\t(%s)", tv->tname ? tv->tname : "");
			for (; m; m = m->next) {
				cvar *cv = m->data;

				printf("(%s.%s)", cv->tname ? cv->tname : "", cv->cname);
			}
			printf("\n");
		}
	}
}
