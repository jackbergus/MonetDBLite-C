@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2005 CWI.
@' All Rights Reserved.

@f sql_statement
@a N.J. Nes
@*

@h
#ifndef _SQL_STATEMENT_H_
#define _SQL_STATEMENT_H_

#include "sql_sym.h"
#include "sql_atom.h"
#include "sql_string.h"
#include "sql_mvc.h"

#define create_stmt_list() list_create((fdestroy)&stmt_destroy)

typedef enum stmt_type {
	st_none,
	st_sql,			/* sometimes a query rewrite is easier */
	st_var,			/* still needs work */
	st_update_var,
	st_seq_next,		

	st_basetable,
	st_temp,		/* temporal bat */
	st_bat,
	st_column,		/* relational column result */
	st_dbat,
	st_idxbat,
	st_const,
	st_mark,
	st_gen_group,
	st_reverse,
	st_mirror,

	st_limit,
	st_order,
	st_reorder,

	st_ordered,
	st_output,
	st_affected_rows,

	st_atom,
	st_filter,
	st_select,
	st_select2,
	st_uselect,
	st_uselect2,
	st_semijoin,
	st_relselect,

	st_reljoin,
	st_join,
	st_outerjoin,
	st_diff,
	st_intersect,
	st_union,

	st_find,
	st_bulkinsert,
	st_append,
	st_insert,
	st_replace,
	st_table_clear,
	st_exception,

	st_group_ext,
	st_group,
	st_derive,
	st_unique,
	st_convert,
	st_op,
	st_unop,
	st_binop,
	st_Nop,
	st_aggr,

	st_alias,

	st_set,
	st_sets,

	st_ptable,		/* (R(tables) */
	st_pivot,		/* binary relation between R and input table */
	st_groupby,		/* (R, groupby columns) */

	/* used internally only */
	st_list
} st_type;

typedef enum comp_type {
	cmp_gt = 0,
	cmp_gte = 1,
	cmp_lte = 2,
	cmp_lt = 3,
	cmp_equal = 4,
	cmp_notequal = 5,
	cmp_notlike = 6,
	cmp_like = 7,
	cmp_all = 8
} comp_type;

typedef struct stmt {
	sql_ref ref;

	st_type type;
	symdata op1;
	symdata op2;
	symdata op3;
	symdata op4;		/* only op4 will hold other types */

	char nrcols;
	char key;		/* key (aka all values are unique) */
	char aggr;		/* aggregated */

	int flag;

	int nr;			/* variable assignment */
	int nr2;		/* usage count */

	struct stmt *h;
	struct stmt *t;
	int optimized;
	struct stmt *rewritten;
} stmt;

typedef struct group {
	sql_ref ref;

	stmt *grp;
	stmt *ext;
	list *cols;		/* list of group by columns */
} group;

extern const char *st_type2string(st_type type);

extern int stmt_stmt2dot(stmt *s, int l, int *i, FILE *fp);

extern stmt *stmt_none();
extern stmt *stmt_sql(char *query);
extern stmt *stmt_var(char *varname, sql_subtype *t);
extern stmt *stmt_varnr(int nr, sql_subtype *t);
extern stmt *stmt_update_var(char *varname);
extern stmt *stmt_seq_next(char *seqname);

extern stmt *stmt_basetable(sql_table *t, char *tname);

#define isbasetable(s) (s->type == st_basetable && s->op1.tval->table)
#define basetable_table(s) s->op1.tval

#define ptable_pivots(s)		((s)->op1.lval)
#define ptable_parent(s)		((s)->op2.stval)
#define ptable_statements(s)	((s)->op3.stval)

extern stmt *stmt_bat(sql_column *c, stmt *basetable, int access );
extern stmt *stmt_column(stmt *i, stmt *basetable);	/* relational column */
extern stmt *stmt_tbat(sql_table *t, int access);
extern stmt *stmt_idxbat(sql_idx * i, int access);

extern stmt *stmt_temp(sql_subtype *t);
extern stmt *stmt_atom(atom *op1);
extern stmt *stmt_atom_string(char *s);
extern stmt *stmt_atom_int(int i);
extern stmt *stmt_bool(int b);
extern stmt *stmt_filter(stmt *sel);
extern stmt *stmt_select(stmt *op1, stmt *op2, comp_type cmptype);
extern stmt *stmt_likeselect(stmt *op1, stmt *op2, stmt *op3, comp_type cmptype);
extern stmt *stmt_uselect(stmt *op1, stmt *op2, comp_type cmptype);

/* cmp
       0 ==   l <  x <  h
       1 ==   l <  x <= h
       2 ==   l <= x <  h
       3 ==   l <= x <= h
       */
extern stmt *stmt_select2(stmt *op1, stmt *op2, stmt *op3, int cmp);
extern stmt *stmt_uselect2(stmt *op1, stmt *op2, stmt *op3, int cmp);
extern stmt *stmt_semijoin(stmt *op1, stmt *op2);

extern stmt *stmt_relselect_init();
extern void stmt_relselect_fill(stmt *relselect, stmt *select);
extern stmt *stmt_relselect(list *sels);

extern stmt *stmt_reljoin_init();
extern void stmt_reljoin_fill(stmt *reljoin, stmt *lc, stmt *rc);
extern stmt *stmt_reljoin1(list *joins);
extern stmt *stmt_reljoin2(list *l1, list *l2);
extern stmt *stmt_join(stmt *op1, stmt *op2, comp_type cmptype);
extern stmt *stmt_outerjoin(stmt *op1, stmt *op2, comp_type cmptype);

extern stmt *stmt_diff(stmt *op1, stmt *op2);
extern stmt *stmt_union(stmt *op1, stmt *op2);
extern stmt *stmt_list(list *l);
extern stmt *stmt_set(stmt *s1);
extern stmt *stmt_sets(list *s1);
extern stmt *stmt_ptable(stmt *p);
extern stmt *stmt_pivot(stmt *s, stmt *ptable);
extern stmt *stmt_groupby(stmt *p, list *cols);

extern stmt *stmt_find(stmt *b, stmt *v, sql_column *c);
extern stmt *stmt_bulkinsert(stmt *t, char *sep, char *rsep, stmt *file, int nr);

extern stmt *stmt_append(stmt *c, stmt *values);
extern stmt *stmt_insert(stmt *c, stmt *values);
extern stmt *stmt_replace(stmt *c, stmt *values);
extern stmt *stmt_table_clear(sql_table *t);

/* raise exception incase the condition (cond) holds, continue with stmt res */
extern stmt *stmt_exception(stmt *res, stmt *cond, char *errstr, int errcode);

extern stmt *stmt_const(stmt *s, stmt *val);
extern stmt *stmt_mark(stmt *s, int id);
extern stmt *stmt_mark_tail(stmt *s, int id);
extern stmt *stmt_gen_group(stmt *s); /* given a gid,cnt blowup to full groups */
extern stmt *stmt_reverse(stmt *s);
extern stmt *stmt_mirror(stmt *s);

extern stmt *stmt_limit(stmt *s, int offset, int limit, int direction);
extern stmt *stmt_order(stmt *s, int direction);
extern stmt *stmt_reorder(stmt *s, stmt *t, int direction);

extern stmt *stmt_convert(stmt *v, sql_subtype *from, sql_subtype *to);
extern stmt *stmt_op(sql_subfunc *op);
extern stmt *stmt_unop(stmt *op1, sql_subfunc *op);
extern stmt *stmt_binop(stmt *op1, stmt *op2, sql_subfunc *op);
extern stmt *stmt_Nop(stmt *ops, sql_subfunc *op);
extern stmt *stmt_aggr(stmt *op1, group *grp, sql_subaggr *op);
extern stmt *stmt_aggr2(stmt *op1, stmt *op2, sql_subaggr *op);
extern stmt *stmt_unique(stmt *s, group *grp);

extern stmt *stmt_alias(stmt *op1, char *tname, char *name);

extern stmt *stmt_ordered(stmt *order, stmt *res);
extern stmt *stmt_output(stmt *l);
extern stmt *stmt_affected_rows(stmt *l);

extern sql_subtype *head_type(stmt *st);
extern sql_subtype *tail_type(stmt *st);
extern int stmt_has_null( stmt *s );

/* return max(s1.nrcols, .. , sn.nrcols where si in l ) */
extern int stmt_list_nrcols(list *l);

extern char *column_name(stmt *st);
extern char *table_name(stmt *st);

extern void stmt_destroy(stmt *s);
extern stmt *stmt_dup(stmt *s);

extern group *grp_create(stmt *s, group *og, stmt *col);
extern group *grp_semijoin(group *og, stmt *s);
extern void grp_destroy(group *g);
extern group *grp_dup(group *g);
extern stmt *grp_find_groupby_col(group *g, stmt *s);

#endif /* _SQL_STATEMENT_H_ */

@c
#include "sql_mem.h"
#include "sql_statement.h"
#include <string.h>

const char *
st_type2string(st_type type)
{
	switch (type) {
#define ST(TYPE) case st_##TYPE : return #TYPE
		ST(none);
		ST(sql);
		ST(var);
		ST(update_var);
		ST(seq_next);

		ST(basetable);
		ST(temp);
		ST(bat);

		ST(column);
		ST(dbat);
		ST(idxbat);

		ST(const);

		ST(mark);
		ST(gen_group);
		ST(reverse);
		ST(mirror);

		ST(limit);
		ST(order);
		ST(reorder);

		ST(ordered);
		ST(output);

		ST(atom);

		ST(filter);
		ST(select);
		ST(select2);
		ST(uselect);
		ST(uselect2);
		ST(semijoin);
		ST(relselect);

		ST(reljoin);
		ST(join);
		ST(outerjoin);
		ST(diff);
		ST(intersect);
		ST(union);

		ST(find);
		ST(bulkinsert);
		ST(append);
		ST(insert);
		ST(replace);
		ST(table_clear);
		ST(exception);

		ST(group_ext);
		ST(group);

		ST(derive);
		ST(unique);
		ST(convert);
		ST(op);
		ST(unop);
		ST(binop);
		ST(Nop);
		ST(aggr);

		ST(alias);

		ST(set);
		ST(sets);
		ST(ptable);
		ST(pivot);
		ST(groupby);
		ST(list);

	default:
		assert(0);
		return "st_?";
	}
	return "unknown";	/* just needed for broken compilers ! */
}

/* #TODO make proper traversal operations */
stmt *
stmt_atom_string(char *S)
{
	char *s = sql2str(S);
	sql_subtype t; 

	sql_find_subtype(&t, "varchar", strlen(s), 0);
	return stmt_atom(atom_string(&t, s, 1));
}

stmt *
stmt_atom_int(int i)
{
	sql_subtype t;

	sql_find_subtype(&t, "int", 9, 0);
	return stmt_atom(atom_int(&t, i));
}

stmt *
stmt_bool(int b)
{
	sql_subtype t;

	sql_find_subtype(&t, "boolean", 0, 0);
	if (b) {
		return stmt_atom(atom_bool(&t, TRUE));
	} else {
		return stmt_atom(atom_bool(&t, FALSE));
	}
}

static stmt *
stmt_atom_oid(int i)
{
	sql_subtype t;

	sql_find_subtype(&t, "oid", 0, 0);
	return stmt_atom(atom_int(&t, i));
}

static stmt *
stmt_create(st_type type)
{
	stmt *s = NEW(stmt);

	sql_ref_init(&s->ref);
	s->type = type;
	s->op1.sval = NULL;
	s->op2.sval = NULL;
	s->op3.sval = NULL;
	s->op4.sval = NULL;
	s->flag = 0;
	s->nrcols = 0;
	s->key = 0;
	s->aggr = 0;
	s->nr = 0;
	s->nr2 = int_nil;
	s->h = NULL;
	s->t = NULL;
	s->optimized = 0;
	s->rewritten = NULL;
	return s;
}

static stmt *
stmt_ext(stmt *grp)
{
	stmt *ns = stmt_create(st_group_ext);

	ns->op1.stval = grp;
	ns->nrcols = grp->nrcols;
	ns->key = 1;
	ns->h = stmt_dup(grp->h);
	ns->t = stmt_dup(grp->t);
	return ns;
}

static stmt *
stmt_group(stmt *s)
{
	stmt *ns = stmt_create(st_group);

	ns->op1.stval = s;
	ns->nrcols = s->nrcols;
	ns->key = 0;
	ns->h = stmt_dup(s->h);
	ns->t = stmt_dup(s->t);
	return ns;
}

static stmt *
stmt_derive(stmt *s, stmt *t)
{
	stmt *ns = stmt_create(st_derive);

	ns->op1.stval = s;
	ns->op2.stval = t;
	ns->nrcols = s->nrcols;
	ns->key = 0;
	ns->h = stmt_dup(s->h);
	ns->t = stmt_dup(s->t);
	return ns;
}

void
grp_destroy(group *g)
{
	if (sql_ref_dec(&g->ref) == 0) {
		stmt_destroy(g->grp);
		stmt_destroy(g->ext);
		if (g->cols)
			list_destroy(g->cols);
		_DELETE(g);
	}
}

group *
grp_dup(group *g)
{
	if (g)
		sql_ref_inc(&g->ref);
	return g;
}

group *
grp_create(stmt *s, group *og, stmt *col)
{
	group *g = NEW(group);

	sql_ref_init(&g->ref);
	g->cols = NULL;
	if (og) {
		g->grp = stmt_derive(stmt_dup(og->grp), s);
		g->cols = og->cols;
		og->cols = NULL;
		grp_destroy(og);
	} else {
		g->grp = stmt_group(s);
		if (col)
			g->cols = list_create(NULL);
	}
	if (col) {
		assert(g->cols);
		list_append(g->cols, col);
	}
	g->ext = stmt_ext(stmt_dup(g->grp));
	return g;
}

static stmt *
stmt_semijoin_tail(stmt *op1, stmt *op2)
{
	return stmt_reverse(stmt_semijoin(stmt_reverse(op1), op2));
}

group *
grp_semijoin(group *og, stmt *s)
{
	group *g = NEW(group);

	sql_ref_init(&g->ref);
	g->grp = stmt_semijoin_tail(stmt_dup(og->grp), s);
	g->ext = stmt_semijoin(stmt_dup(og->ext), stmt_dup(s));
	g->cols = og->cols;
	og->cols = NULL;
	grp_destroy(og);
	return g;
}

void
stmt_destroy(stmt *s)
{
	if (sql_ref_dec(&s->ref) == 0) {
		switch (s->type) {
			/* stmt_destroy  op1 */
		case st_relselect:
			list_destroy(s->op1.lval);
			break;
		case st_reljoin:
			list_destroy(s->op1.lval);
			list_destroy(s->op2.lval);
			break;

		case st_diff:
		case st_intersect:
		case st_union:
		case st_join:
		case st_outerjoin:
		case st_derive:
		case st_unique:
		case st_alias:
		case st_append:
		case st_insert:
		case st_replace:
		case st_pivot:
		case st_find:
		case st_sql:
		case st_update_var:
		case st_seq_next:

			if (s->op1.stval)
				stmt_destroy(s->op1.stval);
			if (s->op2.stval)
				stmt_destroy(s->op2.stval);
			if (s->op3.stval)
				stmt_destroy(s->op3.stval);
			break;

		case st_exception:

			if (s->op1.stval)
				stmt_destroy(s->op1.stval);
			if (s->op2.stval)
				stmt_destroy(s->op2.stval);
			if (s->op3.stval)
				stmt_destroy(s->op3.stval);
			if (s->op4.stval)
				stmt_destroy(s->op4.stval);
			break;

		case st_set:
		case st_sets:
		case st_list:

		case st_ptable:
			list_destroy(s->op1.lval);
			if (s->op2.stval)
				stmt_destroy(s->op2.stval);
			if (s->op3.stval)
				stmt_destroy(s->op3.stval);
			break;

		case st_groupby:
			stmt_destroy(s->op1.stval);
			list_destroy(s->op2.lval);
			if (s->op3.stval)
				stmt_destroy(s->op3.stval);
			break;

		case st_var:
			if (s->op1.sval)
				_DELETE(s->op1.sval);
			break;

			/* reference only independently managed resources */
		case st_basetable:
		case st_table_clear:
			if (s->op2.sval)
				_DELETE(s->op2.sval);
		case st_bat:
		case st_dbat:
		case st_idxbat:
		case st_none:
			break;

			/* special cases */
		case st_temp:
			if (s->op1.stval)
				stmt_destroy(s->op1.stval);
			if (s->op2.stval)
				stmt_destroy(s->op2.stval);
			if (s->op3.stval)
				stmt_destroy(s->op3.stval);
			break;
		case st_aggr:
			if (s->op1.stval)
				stmt_destroy(s->op1.stval);
			if (s->op2.stval)
				stmt_destroy(s->op2.stval);
			if (s->op3.stval)
				stmt_destroy(s->op3.stval);
			sql_subaggr_destroy(s->op4.aggrval);
			break;
		case st_convert:
			if (s->op1.stval)
				stmt_destroy(s->op1.stval);
			break;
		case st_op:
		case st_unop:
		case st_binop:
		case st_Nop:
			if (s->op1.stval)
				stmt_destroy(s->op1.stval);
			if (s->op2.stval)
				stmt_destroy(s->op2.stval);
			if (s->op3.stval)
				stmt_destroy(s->op3.stval);
			sql_subfunc_destroy(s->op4.funcval);
			break;
		case st_atom:
			atom_destroy(s->op1.aval);
			break;

			/* simple case of statements of only statements */
		case st_const:
		case st_mark:
		case st_gen_group:
		case st_reverse:
		case st_mirror:
		case st_limit:
		case st_order:
		case st_reorder:
		case st_ordered:
		case st_output:
		case st_affected_rows:

		case st_column:
		case st_group:
		case st_group_ext:

		case st_filter:
		case st_select:
		case st_select2:
		case st_uselect:
		case st_uselect2:
		case st_semijoin:

		case st_bulkinsert:
			if (s->op1.stval)
				stmt_destroy(s->op1.stval);
			if (s->op2.stval)
				stmt_destroy(s->op2.stval);
			if (s->op3.stval)
				stmt_destroy(s->op3.stval);
			if (s->op4.stval)
				stmt_destroy(s->op4.stval);
			break;

		default:
			printf("! TODO: stmt_destroy(%d=%s) !\n", s->type, st_type2string(s->type));
		}
		if (s->h)
			stmt_destroy(s->h);
		if (s->t)
			stmt_destroy(s->t);
		if (s->rewritten)
			stmt_destroy(s->rewritten);

#ifndef NDEBUG
		if (s->nr2 > 0) {
/*
 * happens far too often for now, hence, we keep it for debugging, only ...
			printf("= sql_statement.mx: stmt_destroy: (result of) statement %s (%d) was used %d times less often than its refcnt indicated!\n",
				st_type2string(s->type), (int)s->type, s->nr2);
 */
		} else if (s->nr2 == int_nil) {
/*
 * happens far too often for now, hence, we keep it for debugging, only ...

NIELS: Because the optimizer rewrites partly inplace some parts of the
  statement tree are really not executed!
			printf("= sql_statement.mx: stmt_destroy: statement %s (%d) was never executed!\n",
				st_type2string(s->type), (int)s->type);

 */
		} else if (s->nr2 < 0) {
			printf("= sql_statement.mx: stmt_destroy: (rssult of) statement %s (%d) was used %d times more often than its refcnt indicated!\n", st_type2string(s->type), (int) s->type, -s->nr2);
		}
#endif

		_DELETE(s);
	}
}

stmt *
stmt_none()
{
	return stmt_create(st_none);
}

stmt *
stmt_sql(char *query)
{
	stmt *s = stmt_create(st_sql);

	s->op1.stval = stmt_atom_string(query);
	return s;
}

stmt *
stmt_var(char *varname, sql_subtype *t)
{
	stmt *s = stmt_create(st_var);

	s->op1.sval = varname;
	if (t)
		s->op2.typeval = *t;
	else
		s->op2.typeval.type = NULL;
	s->key = 1;
	return s;
}

stmt *
stmt_varnr(int nr, sql_subtype *t)
{
	stmt *s = stmt_create(st_var);

	s->op1.sval = NULL;
	if (t)
		s->op2.typeval = *t;
	else
		s->op2.typeval.type = NULL;
	s->key = 1;
	s->flag = nr;
	return s;
}


stmt *
stmt_update_var(char *varname)
{
	stmt *s = stmt_create(st_update_var);

	s->op1.stval = stmt_atom_string(varname);
	s->key = 1;
	return s;
}

stmt *
stmt_seq_next(char *seqname)
{
	stmt *s = stmt_create(st_seq_next);

	s->op1.stval = stmt_atom_string(seqname);
	s->key = 1;
	return s;
}

stmt *
stmt_basetable(sql_table *t, char *name)
{
	stmt *s = stmt_create(st_basetable);

	s->op1.tval = t;
	s->op2.sval = _strdup(name);
	return s;
}

stmt *
stmt_temp(sql_subtype *t)
{
	stmt *s = stmt_create(st_temp);

	s->op4.typeval = *t;
	s->nrcols = 1;
	return s;
}

stmt *
stmt_column(stmt *op1, stmt *basetable)
{
	stmt *s = stmt_create(st_column);

	s->op1.stval = op1;
	/* if not single value, its a single column ! */
	if (op1->nrcols > 0)
		s->nrcols = 1;
	s->key = op1->key;
	s->aggr = op1->aggr;
	s->h = basetable;	/* oid's used from this basetable */
	return s;
}

static stmt *
stmt_bat_(sql_column *c, stmt *basetable, int access )
{
	stmt *s = stmt_create(st_bat);

	s->op1.cval = c;
	s->nrcols = 1;
	s->flag = access;
	s->h = basetable;	/* oid's used from this basetable */
	return s;
}

stmt *
stmt_bat(sql_column *c, stmt *basetable, int access )
{
	stmt *s = stmt_bat_(c, basetable, access );
	
	if (c->base.flag != TR_NEW && 
	    access == RDONLY && c->t->persists && !c->t->clear) {
		stmt *i = stmt_bat_(c, stmt_dup(basetable), INS );
		stmt *u = stmt_bat_(c, stmt_dup(basetable), UPD );

		s = stmt_union(s, i);
		s = stmt_diff(s, u);
		s = stmt_union(s, stmt_dup(u));
	} 
	/* even temp tables have deletes because we like to keep void heads */
	if (access == RDONLY) {
		stmt *d = stmt_tbat(c->t, RDONLY);
		s = stmt_diff(s, stmt_reverse(d));
	}
	return s;
}

stmt *
stmt_tbat(sql_table *t, int access)
{
	stmt *s = stmt_create(st_dbat);

	s->nrcols = 0;
	s->flag = access;
	s->op1.tval = t;
	return s;
}

stmt *
stmt_idxbat_(sql_idx * i, int access)
{
	stmt *s = stmt_create(st_idxbat);

	s->op1.idxval = i;
	s->nrcols = 1;
	s->flag = access;
	return s;
}

stmt *
stmt_idxbat(sql_idx * idx, int access)
{
	stmt *s = stmt_idxbat_(idx, access);

	if (idx->base.flag != TR_NEW && 
	    access == RDONLY && idx->t->persists && !idx->t->clear) {
		stmt *i = stmt_idxbat_(idx, INS);
		stmt *u = stmt_idxbat_(idx, UPD);

		s = stmt_union(s, i);
		s = stmt_diff(s, u);
		s = stmt_union(s, stmt_dup(u));
	} 
	/* even temp tables have deletes because we like to keep void heads */
	if (access == RDONLY) {
		stmt *d = stmt_tbat(idx->t, RDONLY);
		s = stmt_diff(s, stmt_reverse(d));
	}
	return s;
}

stmt *
stmt_const(stmt *s, stmt *val)
{
	stmt *ns = stmt_create(st_const);

	ns->op1.stval = s;
	ns->op2.stval = val;
	ns->nrcols = s->nrcols;
	ns->key = s->key;
	ns->aggr = s->aggr;
	ns->h = stmt_dup(s->h);
	return ns;
}

/* BEWARE stmt_mark marks the head, this while the mil mark is a mark tail
 * Current implementation adds the reverses in stmt_mark nolonger in
 * the generated code.
*/
stmt *
stmt_mark(stmt *s, int id)
{
	stmt *ns = stmt_create(st_mark);

	ns->op1.stval = stmt_reverse(s);
	ns->op2.stval = stmt_atom_oid(id);

	ns->nrcols = s->nrcols;
	ns->key = s->key;
	ns->aggr = s->aggr;
	ns->h = stmt_dup(s->t);
	return stmt_reverse(ns);
}

stmt *
stmt_mark_tail(stmt *s, int id)
{
	stmt *ns = stmt_create(st_mark);

	ns->op1.stval = s;
	ns->op2.stval = stmt_atom_oid(id);

	ns->nrcols = s->nrcols;
	ns->key = s->key;
	ns->aggr = s->aggr;
	ns->h = stmt_dup(s->h);
	return ns;
}

stmt *
stmt_gen_group(stmt *s)
{
	stmt *ns = stmt_create(st_gen_group);

	ns->op1.stval = s;

	ns->nrcols = s->nrcols;
	ns->key = 0;
	ns->aggr = 0;
	ns->h = stmt_dup(s->h);
	return ns;
}

stmt *
stmt_reverse(stmt *s)
{
	stmt *ns = stmt_create(st_reverse);

	ns->op1.stval = s;
	ns->nrcols = s->nrcols;
	ns->key = s->key;
	ns->aggr = s->aggr;
	ns->h = stmt_dup(s->t);
	ns->t = stmt_dup(s->h);
	return ns;
}

stmt *
stmt_mirror(stmt *s)
{
	stmt *ns = stmt_create(st_mirror);

	ns->op1.stval = s;
	ns->nrcols = 2;
	ns->key = s->key;
	ns->aggr = s->aggr;
	ns->h = stmt_dup(s->h);
	ns->t = stmt_dup(s->h);
	return ns;
}

stmt *
stmt_limit(stmt *s, int offset, int limit, int direction)
{
	stmt *ns = stmt_create(st_limit);

	ns->op1.stval = s;
	ns->op2.stval = stmt_atom_int(offset);
	ns->op3.stval = stmt_atom_int(limit);
	ns->nrcols = s->nrcols;
	ns->key = s->key;
	ns->aggr = s->aggr;
	ns->t = stmt_dup(s->t);
	ns->flag = direction;
	return ns;
}

stmt *
stmt_order(stmt *s, int direction)
{
	stmt *ns = stmt_create(st_order);

	ns->op1.stval = s;
	ns->flag = direction;
	ns->nrcols = s->nrcols;
	ns->key = s->key;
	ns->aggr = s->aggr;
	ns->t = stmt_dup(s->t);
	return ns;
}

stmt *
stmt_reorder(stmt *s, stmt *t, int direction)
{
	stmt *ns = stmt_create(st_reorder);

	ns->op1.stval = s;
	ns->op2.stval = t;
	ns->flag = direction;
	ns->nrcols = s->nrcols;
	ns->key = s->key;
	ns->aggr = s->aggr;
	ns->t = stmt_dup(s->t);
	return ns;
}

stmt *
stmt_unique(stmt *s, group *g)
{
	stmt *ns = stmt_create(st_unique);

	ns->op1.stval = s;
	if (g) {
		ns->op2.stval = stmt_dup(g->grp);
		grp_destroy(g);
	}
	ns->nrcols = s->nrcols;
	ns->key = 1;		/* ?? maybe change key to unique ? */
	ns->aggr = s->aggr;
	ns->t = stmt_dup(s->t);
	return ns;
}

stmt *
stmt_atom(atom *op1)
{
	stmt *s = stmt_create(st_atom);

	s->op1.aval = op1;
	s->key = 1;		/* values are also unique */
	return s;
}

stmt *
stmt_filter(stmt *sel)
{
	stmt *s = stmt_create(st_filter);

	s->op1.stval = sel;
	s->nrcols = 1;
	s->h = stmt_dup(s->op1.stval->h);
	return s;
}

stmt *
stmt_relselect_init()
{
	stmt *s = stmt_create(st_relselect);

	s->op1.lval = list_create((fdestroy) &stmt_destroy);
	s->nrcols = 1;
	return s;
}

void
stmt_relselect_fill(stmt *rs, stmt *sel)
{
	list_append(rs->op1.lval, sel);
	if (!rs->h)
		rs->h = stmt_dup(((stmt *) (rs->op1.lval->h->data))->h);
}

stmt *
stmt_relselect(list *sels)
{
	stmt *s = stmt_create(st_relselect);

	s->op1.lval = sels;
	s->nrcols = 1;
	s->h = stmt_dup(((stmt *) (s->op1.lval->h->data))->h);
	return s;
}

stmt *
stmt_select(stmt *op1, stmt *op2, comp_type cmptype)
{
	stmt *s = stmt_create(st_select);

	s->op1.stval = op1;
	s->op2.stval = op2;
	s->flag = cmptype;
	s->nrcols = 1;
	s->h = stmt_dup(s->op1.stval->h);
	s->t = stmt_dup(s->op1.stval->t);
	return s;
}

stmt *
stmt_likeselect(stmt *op1, stmt *op2, stmt *op3, comp_type cmptype)
{
	stmt *s = stmt_create(st_select);

	s->op1.stval = op1;
	s->op2.stval = op2;
	s->op3.stval = op3;
	s->flag = cmptype;
	s->nrcols = 1;
	s->h = stmt_dup(s->op1.stval->h);
	s->t = stmt_dup(s->op1.stval->t);
	return s;
}

stmt *
stmt_select2(stmt *op1, stmt *op2, stmt *op3, int cmp)
{
	stmt *s = stmt_create(st_select2);

	s->op1.stval = op1;
	s->op2.stval = op2;
	s->op3.stval = op3;
	s->flag = cmp;
	s->nrcols = 1;
	s->h = stmt_dup(s->op1.stval->h);
	s->t = stmt_dup(s->op1.stval->t);
	return s;
}

stmt *
stmt_uselect(stmt *op1, stmt *op2, comp_type cmptype)
{
	stmt *s = stmt_create(st_uselect);

	assert(cmptype != cmp_like && cmptype != cmp_notlike);
	s->op1.stval = op1;
	s->op2.stval = op2;
	s->flag = cmptype;
	s->nrcols = 1;
	s->h = stmt_dup(s->op1.stval->h);
	return s;
}

stmt *
stmt_uselect2(stmt *op1, stmt *op2, stmt *op3, int cmp)
{
	stmt *s = stmt_create(st_uselect2);

	s->op1.stval = op1;
	s->op2.stval = op2;
	s->op3.stval = op3;
	s->flag = cmp;
	s->nrcols = 1;
	s->h = stmt_dup(s->op1.stval->h);
	return s;
}

stmt *
stmt_semijoin(stmt *op1, stmt *op2)
{
	stmt *s = stmt_create(st_semijoin);

	s->op1.stval = op1;
	s->op2.stval = op2;
	/* assert( op1->h == op2->h ); */
	s->nrcols = op1->nrcols;
	s->key = op1->key;
	s->aggr = op1->aggr;
	s->h = stmt_dup(op1->h);
	s->t = stmt_dup(op1->t);
	return s;
}


stmt *
stmt_reljoin_init()
{
	stmt *s = stmt_create(st_reljoin);

	s->op1.lval = list_create((fdestroy) &stmt_destroy);
	s->op2.lval = list_create((fdestroy) &stmt_destroy);
	s->nrcols = 2;
	return s;
}

void
stmt_reljoin_fill(stmt *rj, stmt *lc, stmt *rc)
{
	list_append(rj->op1.lval, lc);
	list_append(rj->op2.lval, rc);
	if (!rj->h)
		rj->h = stmt_dup(((stmt *) (rj->op1.lval->h->data))->h);
	if (!rj->t)
		rj->t = stmt_dup(((stmt *) (rj->op2.lval->h->data))->h);
}

stmt *
stmt_reljoin2(list *l1, list *l2)
{
	stmt *s = stmt_create(st_reljoin);

	s->op1.lval = l1;
	s->op2.lval = l2;
	s->nrcols = 2;
	s->h = stmt_dup(((stmt *) (s->op1.lval->h->data))->h);
	s->t = stmt_dup(((stmt *) (s->op2.lval->h->data))->h);
	return s;
}

stmt *
stmt_reljoin1(list *joins)
{
	list *l1 = list_create((fdestroy) &stmt_destroy);
	list *l2 = list_create((fdestroy) &stmt_destroy);
	stmt *L = NULL;
	node *n = NULL;

	for (n = joins->h; n; n = n->next) {
		stmt *l = stmt_dup(((stmt *) (n->data))->op1.stval);
		stmt *r = stmt_dup(((stmt *) (n->data))->op2.stval);

		while (l->type == st_reverse) {
			stmt *t = l;

			l = stmt_dup(l->op1.stval);
			stmt_destroy(t);
		}
		while (r->type == st_reverse) {
			stmt *t = r;

			r = stmt_dup(r->op1.stval);
			stmt_destroy(t);
		}
		if (l->t != r->t) {
			r = stmt_reverse(r);
		}
		if (L == NULL) {
			L = stmt_dup(l);
		} else if (L->h != l->h) {
			stmt *t = l;

			l = r;
			r = t;
		}
		l1 = list_append(l1, l);
		l2 = list_append(l2, r);
	}
	if (L != NULL)
		stmt_destroy(L);
	return stmt_reljoin2(l1, l2);
}

stmt *
stmt_join(stmt *op1, stmt *op2, comp_type cmptype)
{
	stmt *s = stmt_create(st_join);

	s->op1.stval = op1;
	s->op2.stval = op2;
	s->flag = cmptype;
	s->key = op1->key;
	s->nrcols = 2;
	s->h = stmt_dup(op1->h);
	s->t = stmt_dup(op2->t);
	return s;
}

stmt *
stmt_outerjoin(stmt *op1, stmt *op2, comp_type cmptype)
{
	stmt *s = stmt_create(st_outerjoin);

	s->op1.stval = op1;
	s->op2.stval = op2;
	s->flag = cmptype;
	s->nrcols = 2;
	s->h = stmt_dup(op1->h);
	s->t = stmt_dup(op2->t);
	return s;
}

stmt *
stmt_diff(stmt *op1, stmt *op2)
{
	stmt *s = stmt_create(st_diff);

	s->op1.stval = op1;
	s->op2.stval = op2;
	s->nrcols = op1->nrcols;
	s->key = op1->key;
	s->aggr = op1->aggr;
	s->h = stmt_dup(op1->h);
	s->t = stmt_dup(op1->t);
	return s;
}

stmt *
stmt_union(stmt *op1, stmt *op2)
{
	stmt *s = stmt_create(st_union);

	s->op1.stval = op1;
	s->op2.stval = op2;
	s->nrcols = op1->nrcols;
	s->h = stmt_dup(op1->h);
	s->t = stmt_dup(op1->t);
	return s;
}

stmt *
stmt_find(stmt *b, stmt *v, sql_column *c)
{
	stmt *s = stmt_create(st_find);

	assert(c);
	s->op1.stval = b;
	s->op2.stval = v;
	s->op4.cval = c;
	s->nrcols = 1;
	s->key = 0;
	s->h = stmt_dup(b->h);
	s->t = stmt_dup(b->t);
	return s;
}

stmt *
stmt_bulkinsert(stmt *t, char *sep, char *rsep, stmt *file, int nr)
{
	stmt *s = stmt_create(st_bulkinsert);

	s->op1.stval = t;
	s->op2.stval = stmt_atom_string(sep);
	s->op3.stval = stmt_atom_string(rsep);
	s->op4.stval = file;
	s->flag = nr;
	return s;
}

stmt *
stmt_list(list *l)
{
	int nrcols = 0;
	int key = 1;
	node *n;
	stmt *s = stmt_create(st_list);

	s->op1.lval = l;

	for (n = l->h; n; n = n->next) {
		stmt *f = n->data;

		if (f->nrcols > nrcols)
			nrcols = f->nrcols;
		key &= f->key;
	}
	s->nrcols = nrcols;
	s->key = key;
	return s;
}

stmt *
stmt_ordered(stmt *order, stmt *res)
{
	stmt *ns = stmt_create(st_ordered);

	ns->type = st_ordered;
	ns->op1.stval = order;
	ns->op2.stval = res;
	ns->nrcols = res->nrcols;
	ns->key = res->key;
	ns->aggr = res->aggr;
	ns->t = stmt_dup(res->t);
	return ns;
}

stmt *
stmt_output(stmt *l)
{
	stmt *s = stmt_create(st_output);

	s->op1.stval = l;
	return s;
}

stmt *
stmt_affected_rows(stmt *l)
{
	stmt *s = stmt_create(st_affected_rows);

	s->op1.stval = l;
	return s;
}


stmt *
stmt_set(stmt *s1)
{
	stmt *s = stmt_create(st_set);

	s->op1.lval = list_append(list_create((fdestroy) &stmt_destroy), s1);
	s->nrcols = s1->nrcols;
	return s;
}

stmt *
stmt_sets(list *l1)
{
	node *n;
	int nrcols = 0;
	stmt *s = stmt_create(st_sets);

	s->op1.lval = l1;
	for (n = l1->h; n; n = n->next) {
		list *l = n->data;
		node *m;

		for (m = l->h; m; m = m->next) {
			stmt *t = m->data;

			if (t->nrcols > nrcols)
				nrcols = t->nrcols;
		}
	}
	assert(nrcols <= 2);
	s->nrcols = nrcols;
	return s;
}

/* ptable
		list of pivots
		parent
		statements
 */

stmt *
stmt_ptable(stmt *ptable)
{
	stmt *s = stmt_create(st_ptable);

	s->op1.lval = list_create((fdestroy) NULL);
	s->op2.stval = ptable;
	s->nrcols = 2;
	return s;
}

stmt *
stmt_pivot(stmt *base, stmt *ptable)
{
	stmt *s = stmt_create(st_pivot);

	assert(ptable->type == st_ptable);

	s->op1.stval = base;
	s->op2.stval = ptable;
	s->h = stmt_dup(ptable);	/* the ptable is the new base table */
	s->t = stmt_dup(base);	/* pivots have oid's in the tail */
	s->nrcols = 2;
	list_append(ptable_pivots(ptable), s);
	return s;
}

stmt *
stmt_groupby(stmt *ptable, list *cols)
{
	stmt *s = stmt_create(st_groupby);

	assert(ptable->type == st_ptable);

	s->op1.stval = ptable;
	s->op2.lval = cols;
	s->nrcols = 2;
	return s;
}

stmt *
stmt_append(stmt *c, stmt *a)
{
	stmt *s = stmt_create(st_append);

	s->op1.stval = c;
	s->op2.stval = a;
	s->h = stmt_dup(c->h);
	s->t = stmt_dup(c->t);
	s->nrcols = c->nrcols;
	s->key = c->key;
	return s;
}

stmt *
stmt_insert(stmt *c, stmt *a)
{
	stmt *s = stmt_create(st_insert);

	s->op1.stval = c;
	s->op2.stval = a;
	s->h = stmt_dup(c->h);
	s->t = stmt_dup(c->t);
	return s;
}

stmt *
stmt_replace(stmt *c, stmt *b)
{
	stmt *s = stmt_create(st_replace);

	s->op1.stval = c;
	s->op2.stval = b;
	s->nrcols = 1;
	return s;
}

stmt *
stmt_table_clear(sql_table *t)
{
	stmt *s = stmt_create(st_table_clear);

	s->op1.tval = t;
	s->nrcols = 0;
	return s;
}

stmt *
stmt_exception(stmt *res, stmt *cond, char *errstr, int errcode)
{
	stmt *s = stmt_create(st_exception);

	s->op1.stval = cond;
	s->op2.stval = stmt_atom_string(errstr);
	s->op3.stval = stmt_atom_int(errcode);
	s->nrcols = 0;
	if (res) {
		s->op4.stval = res;
		s->key = res->key;
		s->nrcols = res->nrcols;
		s->aggr = res->aggr;
		s->h = stmt_dup(res->h);
		s->t = stmt_dup(res->t);
	}
	return s;
}


stmt *
stmt_convert(stmt *v, sql_subtype *from, sql_subtype *to)
{
	stmt *s = stmt_create(st_convert);

	s->op1.stval = v;
	s->op3.typeval = *from;
	s->op4.typeval = *to;
	s->nrcols = 0;		/* function without arguments returns single value */
	s->h = stmt_dup(v->h);
	s->key = v->key;
	s->nrcols = v->nrcols;
	s->aggr = v->aggr;
	return s;
}

stmt *
stmt_op(sql_subfunc *op)
{
	stmt *s = stmt_create(st_op);

	assert(op);

	s->op4.funcval = op;
	s->nrcols = 0;		/* function without arguments returns single value */
	s->key = 1;
	return s;
}

stmt *
stmt_unop(stmt *op1, sql_subfunc *op)
{
	stmt *s = stmt_create(st_unop);

	s->op1.stval = op1;
	assert(op);
	s->op4.funcval = op;
	s->h = stmt_dup(op1->h);
	s->nrcols = op1->nrcols;
	s->key = op1->key;
	s->aggr = op1->aggr;
	return s;
}

stmt *
stmt_binop(stmt *op1, stmt *op2, sql_subfunc *op)
{
	stmt *s = stmt_create(st_binop);
	int aggr = 0;

	s->op1.stval = op1;
	s->op2.stval = op2;
	assert(op);
	s->op4.funcval = op;
	aggr = op1->aggr;
	if (!aggr)
		aggr = op2->aggr;
	if (op1->nrcols > op2->nrcols) {
		s->h = stmt_dup(op1->h);
		s->nrcols = op1->nrcols;
		s->key = op1->key;
	} else {
		s->h = stmt_dup(op2->h);
		s->nrcols = op2->nrcols;
		s->key = op2->key;
	}
	s->aggr = aggr;
	return s;
}

stmt *
stmt_Nop(stmt *ops, sql_subfunc *op)
{
	node *n;
	stmt *o = NULL, *s = stmt_create(st_Nop);

	s->op1.stval = ops;
	assert(op);
	s->op4.funcval = op;
	if (list_length(ops->op1.lval)) {
		for (n = ops->op1.lval->h, o = n->data; n; n = n->next) {
			stmt *c = n->data;
	
			if (o->nrcols < c->nrcols)
				o = c;
		}
	}

	if (o) {
		s->h = stmt_dup(o->h);
		s->nrcols = o->nrcols;
		s->key = o->key;
		s->aggr = o->aggr;
	}
	return s;
}

stmt *
stmt_aggr(stmt *op1, group *grp, sql_subaggr *op)
{
	stmt *s = stmt_create(st_aggr);

	s->op1.stval = op1;
	if (grp) {
		s->op2.stval = stmt_dup(grp->grp);
		s->op3.stval = stmt_dup(grp->ext);
		s->nrcols = 1;
		s->h = stmt_dup(grp->grp->h);
		grp_destroy(grp);
	} else {
		s->nrcols = 0;
		s->h = stmt_dup(op1->h);
	}
	s->key = 1;
	s->aggr = 1;
	s->op4.aggrval = op;
	s->flag = 0;
	return s;
}

stmt *
stmt_aggr2(stmt *op1, stmt *op2, sql_subaggr *op)
{
	stmt *s = stmt_create(st_aggr);

	s->op1.stval = op1;
	s->op2.stval = op2;
	s->nrcols = 1;
	s->nrcols = 0;
	s->h = stmt_dup(op1->h);
	s->key = 1;
	s->aggr = 1;
	s->op4.aggrval = op;
	s->flag = 1;
	return s;
}

stmt *
stmt_alias(stmt *op1, char *tname, char *alias)
{
	stmt *s = stmt_create(st_alias);

	s->op1.stval = op1;
	if (tname)
		s->op2.stval = stmt_atom_string(tname);
	s->op3.stval = stmt_atom_string(alias);
	s->h = stmt_dup(op1->h);
	s->t = stmt_dup(op1->t);
	s->nrcols = op1->nrcols;
	s->key = op1->key;
	s->aggr = op1->aggr;
	return s;
}

stmt *
stmt_dup(stmt *s)
{
	if (s)
		sql_ref_inc(&s->ref);
	return s;
}


sql_subtype *
tail_type(stmt *st)
{
	switch (st->type) {
	case st_const:
	case st_join:
	case st_outerjoin:
		return tail_type(st->op2.stval);
	case st_reljoin:
		/* The tail type of a reljoin is the head of the second list!,
		   ie should be 'oid' */
		return head_type(st->op2.lval->h->data);

	case st_exception:
		if (st->op4.stval)
			return tail_type(st->op4.stval);
		return NULL;

	case st_diff:
	case st_filter:
	case st_select:
	case st_select2:
	case st_uselect:
	case st_uselect2:
	case st_limit:
	case st_semijoin:
	case st_unique:
	case st_union:
	case st_append:
	case st_replace:
	case st_alias:
	case st_column:
	case st_pivot:
	case st_group:
	case st_derive:
	case st_group_ext:
	case st_mark:
	case st_gen_group:
		return tail_type(st->op1.stval);

	case st_list:
		return tail_type(st->op1.lval->h->data);

	case st_bat:
		return &st->op1.cval->type;
	case st_idxbat:
		if (st->op1.idxval->type == unique) {
			return sql_bind_localtype("int");
		} else if (st->op1.idxval->type == join_idx) {
			return sql_bind_localtype("oid");
		}
	case st_seq_next:
	case st_table_clear:
		return sql_bind_localtype("lng");
	case st_mirror:
	case st_reverse:
		return head_type(st->op1.stval);

	case st_aggr:
		return &st->op4.aggrval->res;
	case st_op:
	case st_unop:
	case st_binop:
	case st_Nop:
		return &st->op4.funcval->res;
	case st_atom:
		return atom_type(st->op1.aval);
	case st_convert:
	case st_temp:
		return &st->op4.typeval;
	case st_find:
		return &st->op4.cval->type;
	case st_var:
		return &st->op2.typeval;
	case st_relselect:
	default:
		fprintf(stderr, "missing tail type %d: %s\n", st->type, st_type2string(st->type));
		assert(0);
		return NULL;
	}
}

sql_subtype *
head_type(stmt *st)
{
	switch (st->type) {
	case st_aggr:
	case st_unop:
	case st_binop:
	case st_Nop:
	case st_unique:
	case st_union:
	case st_alias:
	case st_diff:
	case st_join:
	case st_outerjoin:
	case st_semijoin:
	case st_mirror:
	case st_filter:
	case st_select:
	case st_select2:
	case st_uselect:
	case st_uselect2:
	case st_column:
	case st_append:
	case st_insert:
	case st_replace:
	case st_pivot:
	case st_mark:
	case st_gen_group:
	case st_group:
	case st_group_ext:
	case st_order:
		return head_type(st->op1.stval);
	case st_relselect:
	case st_reljoin:
		return head_type(st->op1.lval->h->data);

	case st_list:
		return head_type(st->op1.lval->h->data);

	case st_temp:
	case st_bat:
	case st_const:
		return sql_bind_localtype("oid");
		/* return NULL; oid */

	case st_reverse:
		return tail_type(st->op1.stval);
	case st_atom:
		return atom_type(st->op1.aval);
	case st_find:
		return head_type(st->op2.stval);

	default:
		fprintf(stderr, "missing head type %d: %s\n", st->type, st_type2string(st->type));
		return NULL;
	}
}

int
stmt_has_null( stmt *s )
{
	switch (s->type) {
	case st_aggr:
	case st_Nop:
	case st_select:
	case st_select2:
	case st_uselect:
	case st_uselect2:
	case st_atom:
		return 0;
	case st_unop:
	case st_reverse:
		return stmt_has_null(s->op1.stval);
	case st_binop:
		return stmt_has_null(s->op1.stval) + stmt_has_null(s->op2.stval);
	case st_bat:
		return !s->op1.cval->null;

	default:
		return 1;
	}
}

int
stmt_list_nrcols(list *l)
{
	int nrcols = 0;
	node *n;

	for (n = l->h; n; n = n->next) {
		stmt *s = n->data;

		if (s->nrcols > nrcols)
			nrcols = s->nrcols;
	}
	return nrcols;
}

static char *
func_name(char *n1, char *n2)
{
	int l1 = strlen(n1), l2; 

	if (!n2)
		return _strdup(n1);
	l2 = strlen(n2);

	if (l2 > 16) {		/* only support short names */
		char *ns = NEW_ARRAY(char, l2 + 1);

		strncpy(ns, n2, l2);
		ns[l2] = 0;
		return ns;
	} else {
		char *ns = NEW_ARRAY(char, l1 + l2 + 2), *s = ns;

		strncpy(ns, n1, l1);
		ns += l1;
		*ns++ = '_';
		strncpy(ns, n2, l2);
		ns += l2;
		*ns = '\0';
		return s;
	}
}

char *
column_name(stmt *st)
{
	switch (st->type) {
	case st_reverse:
		return column_name(st->op1.stval);
	case st_const:
	case st_join:
	case st_outerjoin:
	case st_derive:
		return column_name(st->op2.stval);

	case st_mirror:
	case st_group:
	case st_group_ext:
	case st_column:
	case st_union:
	case st_append:
	case st_mark:
	case st_gen_group:
	case st_filter:
	case st_select:
	case st_select2:
	case st_uselect:
	case st_uselect2:
	case st_limit:
	case st_semijoin:
	case st_diff:
	case st_unique:
	case st_pivot:
	case st_replace:
	case st_convert:
	case st_seq_next:
		return column_name(st->op1.stval);

	case st_op:
		return _strdup(st->op4.funcval->func->base.name);
	case st_unop:
	case st_binop:
	case st_Nop:
	{
		char *cn = column_name(st->op1.stval);
		char *r = func_name(st->op4.funcval->func->base.name, cn);

		if (cn) _DELETE(cn);
		return r;
	}
	case st_aggr:
	{
		char *cn = column_name(st->op1.stval);
		char *r = func_name(st->op4.aggrval->aggr->base.name, cn);

		if (cn) _DELETE(cn);
		return r;
	}
	case st_alias:
		return column_name(st->op3.stval);
	case st_bat:
		return _strdup(st->op1.cval->base.name);
	case st_atom:
		if (st->op1.aval->data.vtype == TYPE_str)
			return atom2string(st->op1.aval);
	case st_var:
	case st_temp:
		return _strdup("single_value");

	case st_relselect:
	case st_reljoin:
	case st_list:
		if (list_length(st->op1.lval))
			return column_name(st->op1.lval->h->data);
		return NULL;
	default:
		fprintf(stderr, "missing column name %d: %s\n", st->type, st_type2string(st->type));
		return NULL;
	}
}

char *
table_name(stmt *st)
{
	switch (st->type) {
	case st_reverse:
		return table_name(st->op1.stval);
	case st_const:
	case st_join:
	case st_outerjoin:
	case st_derive:
		return table_name(st->op2.stval);
	case st_mirror:
	case st_group:
	case st_group_ext:
	case st_column:
	case st_union:
	case st_append:
	case st_mark:
	case st_gen_group:
	case st_filter:
	case st_select:
	case st_select2:
	case st_uselect:
	case st_uselect2:
	case st_semijoin:
	case st_diff:
	case st_aggr:
	case st_unique:
	case st_pivot:
		return table_name(st->op1.stval);

	case st_basetable:
	case st_table_clear:
		if (st->op2.sval)
			return _strdup(st->op2.sval);
		return _strdup(st->op1.tval->base.name);
	case st_bat:
		return table_name(st->h);
	case st_alias:
		if (st->op2.stval)
			return table_name(st->op2.stval);
		return NULL;

	case st_atom:
		if (st->op1.aval->data.vtype == TYPE_str && st->op1.aval->data.val.sval && strlen(st->op1.aval->data.val.sval))
			return atom2string(st->op1.aval);

	case st_var:
	case st_temp:
	case st_relselect:
	case st_reljoin:
	default:
		return NULL;
	}
}

stmt *
grp_find_groupby_col(group *g, stmt *s)
{
	node *n;

	/* groups built for outer references or implicit groups
	   can always find columns */
	if (!g->cols)
		return s;

	for (n = g->cols->h; n; n = n->next) {
		stmt *gs = n->data;

		if (gs == s)
			return s;
	}
	return NULL;
}

int stmt_stmt2dot(stmt *s, int l, int *i, FILE *fp)
{
	node *n,*m;
	int j,k;

	assert(s);
	if (s->optimized >= l) {
		s->optimized = --(*i);
		fprintf(fp,"id%d[label=\"%s\\n",
			-(s->optimized), st_type2string(s->type));
		if (s->ref.refcnt)
			fprintf(fp," refcnt=%d", s->ref.refcnt);
		if (s->nrcols)
			fprintf(fp," nrcols=%d", (int)s->nrcols);
		if (s->key)
			fprintf(fp," key=%d", (int)s->key);
		if (s->aggr)
			fprintf(fp," aggr=%d", (int)s->aggr);
		if (s->flag)
			fprintf(fp," flag=%d", (int)s->flag);
		if (s->nr)
			fprintf(fp," nr=%d", (int)s->nr);
		fprintf(fp," \\n");
		if (s->op1.ival)
			fprintf(fp," op1=%d", (int)s->op1.ival);
		if (s->op2.ival)
			fprintf(fp," op2=%d", (int)s->op2.ival);
		if (s->op3.ival)
			fprintf(fp," op3=%d", (int)s->op3.ival);
		if (s->op4.ival)
			fprintf(fp," op4=%d", (int)s->op4.ival);
		fprintf(fp,"\" ];\n");		

		switch (s->type) {
		case st_relselect:
		case st_reljoin:
			if (s->op1.lval)
			    for (j=1, n=s->op1.lval->h; n; n=n->next, j++)
				fprintf(fp, "id%d -> id%d [headlabel=\"1.%d\"];\n",
					stmt_stmt2dot(n->data, l, i, fp), -(s->optimized), j);
			if (s->op2.lval)
			    for (j=1, n=s->op2.lval->h; n; n=n->next, j++)
				fprintf(fp, "id%d -> id%d [headlabel=\"2.%d\"];\n",
					stmt_stmt2dot(n->data, l, i, fp), -(s->optimized), j);
			break;

		case st_sets: 
			if (s->op1.lval)
			   for (j=1, n=s->op1.lval->h; n; n=n->next, j++)
			     for (k=1, m=((list*)n->data)->h; m; m=m->next, k++)
				fprintf(fp, "id%d -> id%d [headlabel=\"1.%d.%d\"];\n",
					stmt_stmt2dot(m->data, l, i, fp), -(s->optimized), j, k);
			break;

		case st_set: case st_list:
		case st_ptable:
			if (s->op1.lval)
			    for (j=1, n=s->op1.lval->h; n; n=n->next, j++)
				fprintf(fp, "id%d -> id%d [headlabel=\"1.%d\"];\n",
					stmt_stmt2dot(n->data, l, i, fp), -(s->optimized), j);
			if (s->op2.lval) 
			    for (j=1, n=s->op2.lval->h; n; n=n->next, j++)
				fprintf(fp, "id%d -> id%d [headlabel=\"2.%d\"];\n",
					stmt_stmt2dot(n->data, l, i, fp), -(s->optimized), j);
			if (s->op3.stval) 
				fprintf(fp, "id%d -> id%d [headlabel=\"3\"];\n",
					stmt_stmt2dot(s->op3.stval, l, i, fp), -(s->optimized));
			if (s->op4.stval) 
				fprintf(fp, "id%d -> id%d [headlabel=\"4\"];\n",
					stmt_stmt2dot(s->op4.stval, l, i, fp), -(s->optimized));
			break;

		case st_var:
			if (s->op1.sval) {
				fprintf(fp,"var_%s[label=\"var '%s'\",shape=ellipse];\n", s->op1.sval, s->op1.sval);
				fprintf(fp, "var_%s -> id%d [headlabel=\"1\"];\n",
					s->op1.sval, -(s->optimized));
			}
			break;

		/* reference only independently managed resources */
		case st_basetable:
		case st_dbat:
			fprintf(fp,"table_%s[label=\"table '%s'\",shape=ellipse];\n", s->op1.tval->base.name, s->op1.tval->base.name);
			fprintf(fp, "table_%s -> id%d [headlabel=\"1\"];\n",
				s->op1.tval->base.name, -(s->optimized));
			break;
			
		case st_bat:
			fprintf(fp,"column_%s[label=\"column '%s'\",shape=ellipse];\n", s->op1.cval->base.name, s->op1.cval->base.name);
			fprintf(fp, "column_%s -> id%d [headlabel=\"1\"];\n",
				s->op1.cval->base.name, -(s->optimized));
			fprintf(fp, "table_%s -> column_%s;\n",
				s->op1.cval->t->base.name, s->op1.cval->base.name);
			break;

		case st_idxbat:
			fprintf(fp,"index_%s[label=\"index '%s'\",shape=ellipse];\n", s->op1.idxval->base.name, s->op1.idxval->base.name);
			fprintf(fp, "index_%s -> id%d [headlabel=\"1\"];\n",
				s->op1.idxval->base.name, -(s->optimized));
			break;

		case st_none:
			break;

		/* special cases */
		case st_temp:
			if (s->op1.stval) 
				fprintf(fp, "id%d -> id%d [headlabel=\"1\"];\n",
					stmt_stmt2dot(s->op1.stval, l, i, fp), -(s->optimized));
			if (s->op2.stval) 
				fprintf(fp, "id%d -> id%d [headlabel=\"2\"];\n",
					stmt_stmt2dot(s->op2.stval, l, i, fp), -(s->optimized));
			if (s->op3.stval) 
				fprintf(fp, "id%d -> id%d [headlabel=\"3\"];\n",
					stmt_stmt2dot(s->op3.stval, l, i, fp), -(s->optimized));
			break;

		case st_aggr:
			if (s->op1.stval) 
				fprintf(fp, "id%d -> id%d [headlabel=\"1\"];\n",
					stmt_stmt2dot(s->op1.stval, l, i, fp), -(s->optimized));
			if (s->op2.stval) 
				fprintf(fp, "id%d -> id%d [headlabel=\"2\"];\n",
					stmt_stmt2dot(s->op2.stval, l, i, fp), -(s->optimized));
			if (s->op3.stval) 
				fprintf(fp, "id%d -> id%d [headlabel=\"3\"];\n",
					stmt_stmt2dot(s->op3.stval, l, i, fp), -(s->optimized));
	/*
			sql_subaggr_destroy(s->op4.aggrval);
	*/
			break;

		case st_convert:
			if (s->op1.stval) 
				fprintf(fp, "id%d -> id%d [headlabel=\"1\"];\n",
					stmt_stmt2dot(s->op1.stval, l, i, fp), -(s->optimized));
			fprintf(fp,"func_convert[label=\"func 'convert'\",shape=ellipse];\n" );
			fprintf(fp, "func_convert -> id%d [headlabel=\"4\"];\n",
				-(s->optimized));
			break;

		case st_op: case st_unop: case st_binop: case st_Nop:
			if (s->op1.stval) 
				fprintf(fp, "id%d -> id%d [headlabel=\"1\"];\n",
					stmt_stmt2dot(s->op1.stval, l, i, fp), -(s->optimized));
			if (s->op2.stval) 
				fprintf(fp, "id%d -> id%d [headlabel=\"2\"];\n",
					stmt_stmt2dot(s->op2.stval, l, i, fp), -(s->optimized));
			if (s->op3.stval) 
				fprintf(fp, "id%d -> id%d [headlabel=\"3\"];\n",
					stmt_stmt2dot(s->op3.stval, l, i, fp), -(s->optimized));
			fprintf(fp,"func_%s[label=\"func '%s'\",shape=ellipse];\n", s->op4.funcval->func->base.name, s->op4.funcval->func->base.name);
			fprintf(fp, "func_%s -> id%d [headlabel=\"4\"];\n",
				s->op4.funcval->func->base.name, -(s->optimized));
			break;

		case st_atom:
			if (s->op1.aval) {
				fprintf(fp,"id%d[label=\"'%s'\",share=octagon];\n", -(--(*i)), atom2string(s->op1.aval));
				fprintf(fp, "id%d -> id%d [headlabel=\"1\"];\n",
					-(*i), -(s->optimized));
			}
			break;


		case st_diff: case st_intersect: case st_union:
		case st_join: case st_outerjoin:
		case st_derive:
		case st_unique:
		case st_alias:
		case st_append: case st_insert: case st_replace:
		case st_exception:
		case st_pivot:
	  	case st_find:
		case st_sql:

		/* simple case of statements of only statements */

		case st_const: case st_mark: case st_gen_group:
		case st_reverse: case st_mirror:
		case st_limit: case st_order: case st_reorder:
		case st_ordered: case st_output: case st_affected_rows:

		case st_group: case st_group_ext:

		case st_filter:
		case st_select: case st_select2:
		case st_uselect: case st_uselect2:
		case st_semijoin:

		case st_bulkinsert:
			if (s->op1.stval) 
				fprintf(fp, "id%d -> id%d [headlabel=\"1\"];\n",
					stmt_stmt2dot(s->op1.stval, l, i, fp), -(s->optimized));
			if (s->op2.stval) 
				fprintf(fp, "id%d -> id%d [headlabel=\"2\"];\n",
					stmt_stmt2dot(s->op2.stval, l, i, fp), -(s->optimized));
			if (s->op3.stval) 
				fprintf(fp, "id%d -> id%d [headlabel=\"3\"];\n",
					stmt_stmt2dot(s->op3.stval, l, i, fp), -(s->optimized));
			if (s->op4.stval) 
				fprintf(fp, "id%d -> id%d [headlabel=\"4\"];\n",
					stmt_stmt2dot(s->op4.stval, l, i, fp), -(s->optimized));
			break;

		default:
			printf("! TODO: stmt_stmt2dot(%d=%s) !\n",s->type,st_type2string(s->type));
			assert(0);
		}
		if (s->h) 
			fprintf(fp, "id%d -> id%d [headlabel=\"h\",color=green];\n",
				stmt_stmt2dot(s->h, l, i, fp), -(s->optimized));
		if (s->t) 
			fprintf(fp, "id%d -> id%d [headlabel=\"t\",color=green];\n",
				stmt_stmt2dot(s->t, l, i, fp), -(s->optimized));
	}

	return -(s->optimized);
}
