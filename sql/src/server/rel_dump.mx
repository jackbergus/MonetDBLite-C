@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2008 CWI.
@' All Rights Reserved.

@f rel_dump
@a N.J. Nes
@* 

@h
#ifndef _REL_DUMP_H_
#define _REL_DUMP_H_

#include "rel_semantic.h"

extern void rel_print(mvc *sql, sql_rel *rel, int depth);
extern const char *op2string(operator_type op);

#endif /*_REL_DUMP_H_*/
@c
#include "sql_config.h"
#define LINESIZE 80

#include "rel_dump.h"

static void
print_indent( mvc *sql, int depth)
{
	char buf[LINESIZE+1];
	int i;

	(void)sql;
	depth *= 4; /* tab stop 4 */
	if (depth > LINESIZE)
		depth = LINESIZE;
	for(i=0; i<depth; i++){
		buf[i] = ' ';
	}
	buf[i] = 0;
	printf("\n%s", buf);
}

static void
cmp_print(mvc *sql, int cmp) 
{
	char *r;

	(void)sql;
	switch(cmp) {
	case cmp_gt: 		r = ">"; break;
	case cmp_gte: 		r = ">="; break;
	case cmp_lte: 		r = "<="; break;
	case cmp_lt: 		r = "<"; break;
	case cmp_equal: 	r = "="; break;
	case cmp_notequal: 	r = "!="; break;
	case cmp_notlike: 	r = "notlike"; break;
	case cmp_like: 		r = "like"; break;
	case cmp_all: 		r = "all"; break;
	default:
		r = "";
	}
	printf(" %s ", r);
}

static void exps_print(mvc *sql, list *exps, int depth, int alias, int brackets);

static void
exp_print(mvc *sql, sql_exp *e, int depth, int comma, int alias) 
{
	(void)sql;
	if (!e)
		return;
	switch(e->type) {
	case e_convert: {
		printf("convert(");
		exp_print(sql, e->l, depth, 0, 0);
		printf(")");
	 	break;
	}
	case e_atom: {
		if (e->l) {
			atom *a = e->l;
			char *s = atom2string(a);
			if (atom_type(a)->type->localtype == TYPE_str)
				printf("'%s'", s);
			else
				printf("%s", s);
			_DELETE(s);
		} else { /* variables */
			if (e->r) { /* named parameters */
				char *name = e->r;
				printf("%s", name);
			} else { /* numbered arguments */
				printf("A%d", e->flag);
			}
		}
	} 	break;
	case e_func: {
		sql_subfunc *f = e->f;
		printf("%s", f->func->base.name );
		exps_print( sql, e->l, depth, alias, 1);
	} 	break;
	case e_aggr: {
		sql_subaggr *a = e->f;
		printf("%s", a->aggr->base.name );
		if (e->flag&DISTINCT)
			printf(" unique ");
		if (e->flag&NO_NIL)
			printf(" no nil ");
		exps_print( sql, e->l, depth, alias, 1);
	} 	break;
	case e_column: 
		if (e->l)
			printf("%s.", (char*)e->l);
		printf("%s", (char*)e->r);
		if (e->name && strcmp(e->name, e->r)==0)
			alias = 0;
	 	break;
	case e_cmp: 
		exp_print(sql, e->l, depth+1, 0, 0);
		cmp_print(sql, e->flag );
		exp_print(sql, e->r, depth+1, 0, 0);
		if (e->f) {
			printf(", ");
			exp_print(sql, e->f, depth+1, 0, 0);
		}
	 	break;
	default:
		;
	}
	if (e->flag&ASCENDING)
		printf(" ASC");
	if (e->name && alias)
		printf(" as %s", e->name);
	if (comma)
		printf(", ");
}

static void
exps_print(mvc *sql, list *exps, int depth, int alias, int brackets) 
{
	node *en;

	if (!exps)
		return;

	if (brackets)
		printf("(");
	else
		printf(" [ ");
	for( en = exps->h; en; en = en->next ) 
		exp_print(sql, en->data, depth+1, (en->next!=NULL), alias);
	if (brackets)
		printf(")");
	else
		printf(" ]");
}

const char *
op2string(operator_type op) 
{
	switch (op) {
	case op_basetable:
		return "basetable";
	case op_table:
		return "table";
	case op_project:
		return "project";
	case op_select: 
		return "select";
	case op_join: 
	case op_left: 
	case op_right: 
	case op_full: 
		return "join";
	case op_union: 
	case op_inter: 
	case op_except: 
		return "set op";
	case op_groupby: 
		return "group by";
	case op_topn: 
		return "topn";
	}
	return "unknown";
}

void
rel_print(mvc *sql, sql_rel *rel, int depth) 
{
	char *r = NULL;

	if (!rel)
		return;
	switch (rel->op) {
	case op_basetable:
		if (rel->name) {
			sql_table *t = rel->l;
			print_indent(sql, depth);
			printf("table(%s.%s) as %s", 
				t->s->base.name,
				t->base.name,
				rel->name);
		}
		if (rel->exps) {
			printf(" aliases");
			exps_print(sql, rel->exps, depth, 1, 0);
		}
		break;
	case op_table:
		if (rel->name) {
			print_indent(sql, depth);
			printf("table(%s)", rel->name);
		}
		if (rel->exps) {
			exps_print(sql, rel->exps, depth, 1, 0);
		}
		break;
	case op_join: 
	case op_left: 
	case op_right: 
	case op_full: 
	case op_union: 
	case op_inter: 
	case op_except: 
		r = "join";
		if (rel->op == op_left)
			r = "left outer join";
		if (rel->op == op_right)
			r = "right outer join";
		if (rel->op == op_full)
			r = "full outer join";
		else if (rel->op == op_union)
			r = "union";
		else if (rel->op == op_inter)
			r = "intersect";
		else if (rel->op == op_except)
			r = "except";
		else if (!rel->exps && rel->op == op_join)
			r = "crossproduct";
		print_indent(sql, depth);
		if (is_distinct(rel))
			printf("distinct ");
		printf("%s (", r);
		rel_print(sql, rel->l, depth+1);
		printf(",");
		rel_print(sql, rel->r, depth+1);
		print_indent(sql, depth);
		printf(")");
		exps_print(sql, rel->exps, depth, 0, 0);
		if (rel->name)
			printf(" as %s", rel->name);
		break;
	case op_project:
	case op_select: 
	case op_groupby: 
	case op_topn: 
		r = "project";
		if (rel->op == op_select)
			r = "select";
		if (rel->op == op_groupby)
			r = "group by";
		if (rel->op == op_topn)
			r = "top N";
		if (rel->l) {
			print_indent(sql, depth);
			if (is_distinct(rel))
				printf("distinct ");
			printf("%s (", r);
			rel_print(sql, rel->l, depth+1);
			print_indent(sql, depth);
			printf(")");
		}
		if (rel->r && 
	           (rel->op == op_groupby || rel->op == op_project)) { 
		   /* group by and order by columns */
			if (rel->op == op_project)
				r = " order by ";
			exps_print(sql, rel->r, depth, 1, 0);
		}
		exps_print(sql, rel->exps, depth, 1, 0);
		if (rel->name)
			printf(" as %s", rel->name);
		break;
	default:
		printf("todo: print %u\n", rel->op);
	}
	if (!depth)
		printf("\n");
}
