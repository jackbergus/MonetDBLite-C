@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
@' Copyright August 2008-2010 MonetDB B.V.
@' All Rights Reserved.

@f rel_dump
@a N.J. Nes
@* 

@h
#ifndef _REL_DUMP_H_
#define _REL_DUMP_H_

#include "rel_semantic.h"

extern void rel_print(mvc *sql, sql_rel *rel, int depth);
extern void _rel_print(mvc *sql, sql_rel *rel);
extern const char *op2string(operator_type op);

#endif /*_REL_DUMP_H_*/
@c
#include "sql_config.h"
#define LINESIZE 160
#define TABSTOP 2

#include "rel_dump.h"

static void
print_indent(mvc *sql, stream *fout, int depth)
{
	char buf[LINESIZE+1];
	int i;

	(void)sql;
	depth *= TABSTOP;
	if (depth > LINESIZE)
		depth = LINESIZE;
	for (i = 0; i < depth; i++){
		if ((i % TABSTOP) == 0)	
			buf[i] = '|';
		else
			buf[i] = ' ';
	}
	buf[i] = 0;
	stream_printf(fout, "\n=%s", buf);
}

static void
cmp_print(mvc *sql, stream *fout, int cmp) 
{
	char *r;

	(void)sql;
	switch(cmp) {
	case cmp_gt: 		r = ">"; break;
	case cmp_gte: 		r = ">="; break;
	case cmp_lte: 		r = "<="; break;
	case cmp_lt: 		r = "<"; break;
	case cmp_equal: 	r = "="; break;
	case cmp_notequal: 	r = "!="; break;
	case cmp_notlike: 	r = "notlike"; break;
	case cmp_like: 		r = "like"; break;
	case cmp_notilike: 	r = "notilike"; break;
	case cmp_ilike: 	r = "ilike"; break;
	case cmp_all: 		r = "all"; break;
	case cmp_or: 		r = "or"; break;
	default:
		r = "";
	}
	stream_printf(fout, " %s ", r);
}

static void exps_print(mvc *sql, stream *fout, list *exps, int depth, int alias, int brackets);

static void
exp_print(mvc *sql, stream *fout, sql_exp *e, int depth, int comma, int alias) 
{
	(void)sql;
	if (!e)
		return;
	switch(e->type) {
	case e_convert: {
		stream_printf(fout, "convert(");
		exp_print(sql, fout, e->l, depth, 0, 0);
		stream_printf(fout, ")");
	 	break;
	}
	case e_atom: {
		if (e->l) {
			atom *a = e->l;
			if (atom_type(a)->type->localtype == TYPE_ptr) {
				sql_table *t = a->data.val.pval;
				stream_printf(fout, "table(%s)", t->base.name);
			} else {
				char *s = atom2string(a);
				if (atom_type(a)->type->localtype == TYPE_str)
					stream_printf(fout, "'%s'", s);
				else
					stream_printf(fout, "%s", s);
				_DELETE(s);
			}
		} else { /* variables */
			if (e->r) { /* named parameters */
				char *name = e->r;
				stream_printf(fout, "%s", name);
			} else { /* numbered arguments */
				stream_printf(fout, "A%d", e->flag);
			}
		}
	} 	break;
	case e_func: {
		sql_subfunc *f = e->f;
		stream_printf(fout, "%s", f->func->base.name );
		exps_print(sql, fout, e->l, depth, alias, 1);
		if (e->r)
			exps_print(sql, fout, e->r, depth, alias, 1);
	} 	break;
	case e_aggr: {
		sql_subaggr *a = e->f;
		stream_printf(fout, "%s", a->aggr->base.name );
		if (need_distinct(e))
			stream_printf(fout, " unique ");
		if (need_no_nil(e))
			stream_printf(fout, " no nil ");
		exps_print(sql, fout, e->l, depth, alias, 1);
	} 	break;
	case e_column: 
		if (e->l)
			stream_printf(fout, "%s.", (char*)e->l);
		stream_printf(fout, "%s", (char*)e->r);
		if (e->rname && e->name && e->l && e->r &&
			strcmp(e->rname, e->l) == 0 &&
			strcmp(e->name, e->r) == 0) 
			alias = 0;
		if (!e->rname && e->name && strcmp(e->name, e->r)==0)
			alias = 0;
	 	break;
	case e_cmp: 
		if (e->flag == cmp_or) {
			exps_print(sql, fout, e->l, depth, alias, 1);
			cmp_print(sql, fout, e->flag );
			exps_print(sql, fout, e->r, depth, alias, 1);
		} else if (e->f) {
			exp_print(sql, fout, e->r, depth+1, 0, 0);
			if (is_anti(e))
				stream_printf(fout, " ! ");
			cmp_print(sql, fout, swap_compare(range2lcompare(e->flag)) );
			exp_print(sql, fout, e->l, depth+1, 0, 0);
			if (is_anti(e))
				stream_printf(fout, " ! ");
			cmp_print(sql, fout, range2rcompare(e->flag) );
			exp_print(sql, fout, e->f, depth+1, 0, 0);
		} else {
			exp_print(sql, fout, e->l, depth+1, 0, 0);
			if (is_anti(e))
				stream_printf(fout, " ! ");
			cmp_print(sql, fout, e->flag );

			exp_print(sql, fout, e->r, depth+1, 0, 0);
		}
	 	break;
	default:
		;
	}
	if (e->type != e_atom && is_ascending(e))
		stream_printf(fout, " ASC");
	if (e->type != e_atom && e->type != e_cmp && !has_nil(e))
		stream_printf(fout, " NOT NULL");
	if (e->name && alias) {
		stream_printf(fout, " as ");
		if (e->rname)
			stream_printf(fout, "%s.", e->rname);
		stream_printf(fout, "%s", e->name);
	}
	if (comma)
		stream_printf(fout, ", ");
}

static void
exps_print(mvc *sql, stream *fout, list *exps, int depth, int alias, int brackets) 
{
	node *en;

	if (!exps)
		return;

	if (brackets)
		stream_printf(fout, "(");
	else
		stream_printf(fout, " [ ");
	for (en = exps->h; en; en = en->next) 
		exp_print(sql, fout, en->data, depth+1, (en->next!=NULL), alias);
	if (brackets)
		stream_printf(fout, ")");
	else
		stream_printf(fout, " ]");
}

const char *
op2string(operator_type op) 
{
	switch (op) {
	case op_basetable:
		return "basetable";
	case op_table:
		return "table";
	case op_ddl:
		return "ddl";
	case op_project:
		return "project";
	case op_select: 
		return "select";
	case op_join: 
	case op_left: 
	case op_right: 
	case op_full: 
		return "join";
	case op_semi: 
		return "semi";
	case op_anti: 
		return "anti";
	case op_union: 
	case op_inter: 
	case op_except: 
		return "set op";
	case op_groupby: 
		return "group by";
	case op_topn: 
		return "topn";
	case op_insert: 
	case op_update: 
	case op_delete: 
		return "modify op";
	}
	return "unknown";
}

static int 
find_ref( list *refs, sql_rel *rel )
{
	node *n;
	int nr = 1;

	for(n=refs->h; n; n = n->next, nr++){
		if (n->data == rel)
			return nr;
	}
	return 0;
}

static void
rel_print_(mvc *sql, stream  *fout, sql_rel *rel, int depth, list *refs) 
{ 
	char *r = NULL;

	if (!rel)
		return;

	if (rel_is_ref(rel)) {
		int nr = list_length(refs) + 1;
		int cnt = rel->ref.refcnt;
		stream_printf(fout, "\n= REF %d (%d)", nr, cnt);
	}

	switch (rel->op) {
	case op_basetable: {
		sql_table *t = rel->l;
		print_indent(sql, fout, depth);
		if (t->s)
			stream_printf(fout, "table(%s.%s)", 
				t->s->base.name, t->base.name);
		else
			stream_printf(fout, "table(%s)", t->base.name);
		if (rel->exps) 
			exps_print(sql, fout, rel->exps, depth, 1, 0);
	} 	break;
	case op_table:
		print_indent(sql, fout, depth);
		stream_printf(fout, "table");
		if (rel->exps) 
			exps_print(sql, fout, rel->exps, depth, 1, 0);
		break;
	case op_ddl:
		print_indent(sql, fout, depth);
		stream_printf(fout, "ddl");
		if (rel->l)
			rel_print_(sql, fout, rel->l, depth+1, refs);
		if (rel->r)
			rel_print_(sql, fout, rel->r, depth+1, refs);
		if (rel->exps) 
			exps_print(sql, fout, rel->exps, depth, 1, 0);
		break;
	case op_join: 
	case op_left: 
	case op_right: 
	case op_full: 
	case op_semi: 
	case op_anti: 
	case op_union: 
	case op_inter: 
	case op_except: 
		r = "join";
		if (rel->op == op_left)
			r = "left outer join";
		else if (rel->op == op_right)
			r = "right outer join";
		else if (rel->op == op_full)
			r = "full outer join";
		else if (rel->op == op_semi)
			r = "semijoin";
		else if (rel->op == op_anti)
			r = "antijoin";
		else if (rel->op == op_union)
			r = "union";
		else if (rel->op == op_inter)
			r = "intersect";
		else if (rel->op == op_except)
			r = "except";
		else if (!rel->exps && rel->op == op_join)
			r = "crossproduct";
		print_indent(sql, fout, depth);
		if (need_distinct(rel))
			stream_printf(fout, "distinct ");
		stream_printf(fout, "%s (", r);
		if (rel_is_ref(rel->l)) {
			int nr = find_ref(refs, rel->l);
			stream_printf(fout, " & REF %d ", nr);
		} else
			rel_print_(sql, fout, rel->l, depth+1, refs);
		stream_printf(fout, ",");
		if (rel_is_ref(rel->r)) {
			int nr = find_ref(refs, rel->r);
			stream_printf(fout, " & REF %d  ", nr);
		} else
			rel_print_(sql, fout, rel->r, depth+1, refs);
		print_indent(sql, fout, depth);
		stream_printf(fout, ")");
		exps_print(sql, fout, rel->exps, depth, 1, 0);
		break;
	case op_project:
	case op_select: 
	case op_groupby: 
	case op_topn: 
		r = "project";
		if (rel->op == op_select)
			r = "select";
		if (rel->op == op_groupby)
			r = "group by";
		if (rel->op == op_topn)
			r = "top N";
		print_indent(sql, fout, depth);
		if (rel->l) {
			if (need_distinct(rel))
				stream_printf(fout, "distinct ");
			stream_printf(fout, "%s (", r);
			if (rel_is_ref(rel->l)) {
				int nr = find_ref(refs, rel->l);
				stream_printf(fout, " & REF %d ", nr);
			} else
				rel_print_(sql, fout, rel->l, depth+1, refs);
			print_indent(sql, fout, depth);
			stream_printf(fout, ")");
		}
		if (rel->r && 
	           (rel->op == op_groupby || rel->op == op_project)) { 
		   /* group by and order by columns */
			if (rel->op == op_project)
				r = " order by ";
			exps_print(sql, fout, rel->r, depth, 1, 0);
		}
		exps_print(sql, fout, rel->exps, depth, 1, 0);
		break;
	case op_insert:
	case op_update:
	case op_delete: {

		print_indent(sql, fout, depth);
		if (rel->op == op_insert)
			stream_printf(fout, "insert(");
		else if (rel->op == op_update)
			stream_printf(fout, "update(");
		else if (rel->op == op_delete)
			stream_printf(fout, "delete(");

		if (rel_is_ref(rel->l)) {
			int nr = find_ref(refs, rel->l);
			stream_printf(fout, " & REF %d ", nr);
		} else
			rel_print_(sql, fout, rel->l, depth+1, refs);

		if (rel_is_ref(rel->r)) {
			int nr = find_ref(refs, rel->r);
			stream_printf(fout, " & REF %d ", nr);
		} else
			rel_print_(sql, fout, rel->r, depth+1, refs);
		print_indent(sql, fout, depth);
		stream_printf(fout, ")");
		if (rel->exps)
			exps_print(sql, fout, rel->exps, depth, 1, 0);
	} 	break;
	default:
		assert(0);
	}
}

static void
rel_print_refs(mvc *sql, stream* fout, sql_rel *rel, int depth, list *refs) 
{
	if (!rel)
		return;
	switch (rel->op) {
	case op_basetable:
	case op_table:
	case op_ddl:
		break;
	case op_join: 
	case op_left: 
	case op_right: 
	case op_full: 
	case op_semi: 
	case op_anti: 
	case op_union: 
	case op_inter: 
	case op_except: 
		rel_print_refs(sql, fout, rel->l, depth, refs);
		rel_print_refs(sql, fout, rel->r, depth, refs);
		if (rel_is_ref(rel->l) && !find_ref(refs, rel->l)) {
			rel_print_(sql, fout, rel->l, depth, refs);
			list_append(refs, rel->l);
		}
		if (rel_is_ref(rel->r) && !find_ref(refs, rel->r)) {
			rel_print_(sql, fout, rel->r, depth, refs);
			list_append(refs, rel->r);
		}
		break;
	case op_project:
	case op_select: 
	case op_groupby: 
	case op_topn: 
		rel_print_refs(sql, fout, rel->l, depth, refs);
		if (rel->l && rel_is_ref(rel->l) && !find_ref(refs, rel->l)) {
			rel_print_(sql, fout, rel->l, depth, refs);
			list_append(refs, rel->l);
		}
		break;
	case op_insert: 
	case op_update: 
	case op_delete: 
		rel_print_refs(sql, fout, rel->l, depth, refs);
		if (rel->l && rel_is_ref(rel->l) && !find_ref(refs, rel->l)) {
			rel_print_(sql, fout, rel->l, depth, refs);
			list_append(refs, rel->l);
		}
		rel_print_refs(sql, fout, rel->r, depth, refs);
		if (rel->r && rel_is_ref(rel->r) && !find_ref(refs, rel->r)) {
			rel_print_(sql, fout, rel->r, depth, refs);
			list_append(refs, rel->r);
		}
		break;
	}
}

void
_rel_print(mvc *sql, sql_rel *rel) 
{
	list *refs = list_create(NULL);
	rel_print_refs(sql, THRdata[0], rel, 0, refs);
	rel_print_(sql, THRdata[0], rel, 0, refs);
	stream_printf(THRdata[0], "\n");
	list_destroy(refs);
}

void
rel_print(mvc *sql, sql_rel *rel, int depth) 
{
	list *refs = list_create(NULL);
	size_t pos;
	size_t nl = 0;
	size_t len = 0, lastpos = 0;
	stream *fd = sql->scanner.ws;
	stream *s;
	buffer *b = buffer_create(16364); /* hopefully enough */
	if (!b)
		return; /* signal somehow? */
	s = buffer_wastream(b, "SQL Plan");
	if (!s) {
		buffer_destroy(b);
		return; /* signal somehow? */
	}

	rel_print_refs(sql, s, rel, depth, refs);
	rel_print_(sql, s, rel, depth, refs);
	stream_printf(s, "\n");

	/* count the number of lines in the output, skip the leading \n */
	for (pos = 1; pos < b->pos; pos++) {
		if (b->buf[pos] == '\n') {
			nl++;
			if (len < pos - lastpos)
				len = pos - lastpos;
			lastpos = pos + 1;
		}
	}
	b->buf[b->pos - 1] = '\0';  /* should always end with a \n, can overwrite */

	/* craft a semi-professional header */
	stream_printf(fd, "&1 0 %d 1 %d\n", /* type id rows columns tuples */
			nl, nl);
	stream_printf(fd, "%% .plan # table_name\n");
	stream_printf(fd, "%% rel # name\n");
	stream_printf(fd, "%% clob # type\n");
	stream_printf(fd, "%% " SZFMT " # length\n", len - 2 /* remove = and \n */);

	/* output the data */
	stream_printf(fd, "%s\n", b->buf + 1 /* omit starting \n */);

	stream_close(s);
	stream_destroy(s);
	buffer_destroy(b);

	list_destroy(refs);
}
