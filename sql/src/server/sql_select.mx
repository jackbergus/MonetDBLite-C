@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2005 CWI.
@' All Rights Reserved.

@f sql_select
@a N.J. Nes
@* 

@h
#ifndef _SQL_SELECT_H_
#define _SQL_SELECT_H_

#include <stdio.h>
#include <stdarg.h>
#include <sql_list.h>
#include "sql_symbol.h"
#include "sql_scope.h"
#include "sql_statement.h"

#define sql_from 0
#define sql_where 1
/* special search fase which is used within the selection fase */
#define sql_search 2
#define sql_sel   3

extern stmt *selects(mvc *sql, symbol *sym);

extern stmt *sql_subquery(mvc *sql, scope *scp, symbol *sq, int toplevel);
extern stmt *scope_subquery(mvc *sql, scope *scp, symbol *sq);
extern stmt *flat_subquery(mvc *sql, symbol *sq);

extern stmt *sql_value_exp(mvc *sql, scope *scp, symbol *se, group *grp, stmt *subset, int f);
extern stmt *sql_logical_exp(mvc *sql, scope *scp, symbol *sc, group *grp, stmt *subset, int f);
extern stmt *stmt2pivot(scope *scp, stmt *s);

extern stmt *sql_compare(mvc *sql, stmt *ls, stmt *rs, char *compare_op, int f);
extern stmt *complex_find_subset(stmt *subset, stmt *t);
extern stmt *sql_and(mvc *sql, scope *scp, stmt *ls, stmt *rs, int f);

#endif /*_SQL_SELECT_H_*/
@c

#include "sql_config.h"
#include "sql_select.h"
#include "sql_parser.h"
#include "sql_scope.h"
#include "sql_semantic.h"
#include "sql_sequence.h"
#include "sql_privileges.h"
#include "sql_env.h"

static stmt *sql_select(mvc *sql, scope *scp, SelectNode *sn, int toplevel);
static stmt *sql_simple_select(mvc *sql, scope *scp, symbol *where, dlist *selection);
static stmt *sql_compare_exp(mvc *sql, scope *scp, group *grp, stmt *subset, symbol *lo, symbol *ro, char *compare_op, int f);

static tvar *query_exp_optname(mvc *sql, scope *scp, symbol *q);
static tvar *sql_subquery_optname(mvc *sql, scope *scp, symbol *query);
static stmt *sql_Nop_(mvc *sql, char *fname, stmt *a1, stmt *a2, stmt *a3);

static void
sql_select_cleanup(mvc *sql, stmt *s, stmt *subset, group *grp)
{
	(void) sql;		/* Stefan: unused!? */

	if (grp)
		grp_destroy(grp);
	if (subset)
		stmt_destroy(subset);
	if (s)
		stmt_destroy(s);
}

static tvar *
table_ref(mvc *sql, scope *scp, symbol *tableref)
{
	char *tname = NULL;
	sql_table *t = NULL;

	/* todo handle opt_table_ref 
	   (ie tableref->data.lval->h->next->data.sym */

	if (tableref->token == SQL_NAME) {
		sql_schema *s = qname_schema(sql, tableref->data.lval->h->data.lval);

		tname = qname_table(tableref->data.lval->h->data.lval);

		if (!s) {
			(void) sql_error(sql, 02, "unknown schema");
			return NULL;
		}
		t = mvc_bind_table(sql, s, tname);
		if (!t) {
			(void) sql_error(sql, 02, "unknown table %s", tname);
			return NULL;
		} else if (!table_privs(sql, t, PRIV_SELECT)) {
			(void) sql_error(sql, 02, "user is not allowed to perform SELECT operation on table %s", tname);
			return NULL;
		}
		if (tableref->data.lval->h->next->data.sym) {	/* AS */
			tname = tableref->data.lval->h->next->data.sym->data.lval->h->data.sval;
		}
		return scope_add_table_columns(sql, scp, t, tname, RDONLY);
	} else if (tableref->token == SQL_TABLE) {
		stmt *s = sql_value_exp(sql, scp, tableref->data.lval->h->data.sym, NULL, NULL, sql_from);
		char *tname = tableref->data.lval->h->next->data.sym->data.lval->h->data.sval;

		if (!s)
			return NULL;
		return scope_add_table(scp, s, tname, NULL);
	} else if (tableref->token == SQL_SELECT) {
		return sql_subquery_optname(sql, scp, tableref);
	} else {
		return query_exp_optname(sql, scp, tableref);
	}
}

stmt *
sql_subquery(mvc *sql, scope *scp, symbol *sq, int toplevel)
{
	SelectNode *sn = (SelectNode *) sq;

	assert(sn->s.token == SQL_SELECT);

	if (!toplevel && sn->limit >= 0)
		return sql_error(sql, 01, "LIMIT only allowed on outer select");

	if (!toplevel && sn->orderby)
		return sql_error(sql, 01, "ORDER BY only allowed on outer select ");

	if (sn->from) {		/* keep variable list with tables and names */
		dlist *fl = sn->from->data.lval;
		dnode *n = NULL;
		tvar *fnd = (tvar *) 1L;	/* 1L to keep 64-bit compilers from complaining *
						 * about different sizes of int and pointer     */

		for (n = fl->h; (n && fnd); n = n->next)
			fnd = table_ref(sql, scp, n->data.sym);

		if (!fnd)
			return NULL;

	} else if (toplevel) {	/* only on top level query */
		return sql_simple_select(sql, scp, sn->where, sn->selection);
	}
	return sql_select(sql, scp, sn, toplevel);
}

stmt *
scope_subquery(mvc *sql, scope *scp, symbol *sq)
{
	stmt *s;
	int toplevel = (scp) ? 0 : 1;

	scp = scope_open(scp);
	s = sql_subquery(sql, scp, sq, toplevel);
	scp = scope_close(scp);
	return s;
}

/* handle limit and orderby properly ! */
stmt *
flat_subquery(mvc *sql, symbol *sq)
{
	scope *scp = scope_open(NULL);
	stmt *s = sql_subquery(sql, scp, sq, 1);

	scp = scope_close(scp);

	if (s && s->type == st_ordered) {
		list *l = create_stmt_list();
		node *n;

		for (n = s->op2.stval->op1.lval->h; n; n = n->next) {
			stmt *sc = stmt_dup(n->data);

			list_append(l, stmt_reverse(stmt_order(stmt_reverse(stmt_join(stmt_mark(stmt_reverse(stmt_dup(s->op1.stval)), 0), sc, cmp_equal)
							       ), 1))
			    );
		}
		stmt_destroy(s);
		s = stmt_list(l);
	}
	return s;
}

/* 
 * Column references, can be done using simple names or aliases and
 * using a combination of table name and column name (or alias).
 * The sql_column_ref finds the column based on the specification from
 * symbol column_r.
 * A special column reference is 'rowid'.
 */

static stmt *
sql_column_ref(mvc *sql, scope *scp, symbol *column_r)
{
	stmt *cs = NULL;
	dlist *l = column_r->data.lval;

	assert(column_r->token == SQL_COLUMN && column_r->type == type_list);

	if (dlist_length(l) == 1 && l->h->type == type_int) {
		return stmt_varnr(l->h->data.ival, sql_dup_subtype(atom_type(sql_bind_arg(sql, l->h->data.ival))));
	} else if (dlist_length(l) == 1) {
		char *name = l->h->data.sval;

		if (strcmp(name, "rowid") == 0) {
			cvar *cv = scope_first_column(scp);

			if (!cv)
				return sql_error(sql, 02, "ROWID used without table ref");
			return stmt_mirror(stmt_dup(cv->s));
		} else if (!(cs = scope_bind(scp, NULL, name))) {
			/* maybe simple param */
			cs = sql_bind_param(sql, name);
			if (!cs) {
				char *v, *t;
				sql_subtype *tpe;

				if (!(v = sql_get_var(sql, name)))
					return sql_error(sql, 02, "identifier %s unknown or ambigious", name);
				t = sql_get_type(sql, name);
				tpe = sql_bind_subtype(t, 0, 0);
				cs = stmt_atom(atom_general(tpe, _strdup(v), 1));
			}
		}
	} else if (dlist_length(l) == 2) {
		char *tname = l->h->data.sval;
		char *cname = l->h->next->data.sval;

		if (strcmp(cname, "rowid") == 0) {
			tvar *tv = scope_bind_table(scp, tname);
			cvar *cv;

			if (!tv) {
				return sql_error(sql, 02, "identifier %s unknown", tname);
			}
			cv = tv->columns->h->data;
			return stmt_mirror(stmt_dup(cv->s));
		} else if (!(cs = scope_bind(scp, tname, cname))) {
			return sql_error(sql, 02, "column %s.%s unknown", tname, cname);
		}
	} else if (dlist_length(l) >= 3) {
		return sql_error(sql, 02, "TODO: column names of level >= 3");
	}
	return cs;
}

static char *
tmp_table_name()
{
	oid id = OIDnew(1);
	static char buf[BUFSIZ];
	snprintf(buf, BUFSIZ, "c" SZFMT "", (size_t)id);

	return buf;
}

static tvar *
table_optname(mvc *sql, scope *scp, stmt *sq, symbol *optname)
{
	node *m;
	char *tname = NULL;
	dlist *columnrefs = NULL;
	tvar *tv;

	if (optname && optname->token == SQL_NAME) {
		tname = optname->data.lval->h->data.sval;
		columnrefs = optname->data.lval->h->next->data.lval;
	}
	tv = scope_add_table(scp, sq, tname, NULL);
	if (columnrefs) {
		dnode *d;

		if (list_length(sq->op1.lval) != dlist_length(columnrefs)) {
			return sql_error(sql, 02, "column definition list does not match real list of columns");
		}
		for (m = sq->op1.lval->h, d = columnrefs->h; d && m; d = d->next, m = m->next) {
			stmt *st = m->data;
			stmt *sc = stmt_column(stmt_alias(stmt_dup(st),
							  _strdup(tname), _strdup(d->data.sval)), stmt_dup(sq));

			table_add_column(tv, sc, tname, d->data.sval);
		}
	} else if (tname) {
		/* foreach column add column name */
		for (m = sq->op1.lval->h; m; m = m->next) {
			stmt *st = m->data;
			char *cname = column_name(st);
			stmt *sc = stmt_column(stmt_dup(st), stmt_dup(sq));

			sc = stmt_alias(sc, _strdup(tname), cname);
			table_add_column(tv, sc, tname, cname);
		}
	} else {
		/* foreach column add full basetable,column name */
		for (m = sq->op1.lval->h; m; m = m->next) {
			stmt *st = m->data;
			char *cname = column_name(st);
			char *tname = table_name(st);
			stmt *sc = stmt_column(stmt_dup(st), stmt_dup(sq));

			table_add_column(tv, sc, tname, cname);
			_DELETE(tname);
			_DELETE(cname);
		}
	}
	return tv;
}

static tvar *
sql_subquery_optname(mvc *sql, scope *scp, symbol *query)
{
	SelectNode *sn = (SelectNode *) query;
	stmt *sq = flat_subquery(sql, query);
	char *tname = NULL;

	if (!sq)
		return NULL;

	if (sn->name && sn->name->token == SQL_NAME)
		tname = sn->name->data.lval->h->data.sval;

	/* create a table from a single value subquery result */
	if (sq->key && sq->nrcols == 0) {
		list *l = create_stmt_list();
		node *n;

		for (n = sq->op1.lval->h; n; n = n->next) {
			stmt *nsq = stmt_dup(n->data);
			char *cname = column_name(nsq);
			stmt *temp = stmt_temp(sql_dup_subtype(tail_type(nsq)));

			nsq = stmt_append(temp, nsq);
			if (tname)
				nsq = stmt_alias(nsq, _strdup(tname), cname);
			else
				nsq = stmt_alias(nsq, table_name(nsq), cname);
			list_append(l, nsq);
		}
		stmt_destroy(sq);
		sq = stmt_list(l);
	}
	return table_optname(sql, scp, sq, sn->name);
}

static stmt *
find_pivot(stmt *subset, stmt *t)
{
	assert(subset->type == st_ptable);

	if (t) {
		node *n;

		for (n = ptable_pivots(subset)->h; n; n = n->next) {
			stmt *s = n->data;

			if (s->t == t)
				return stmt_dup(s);
		}
	}
	assert(0);
	return NULL;
}

/* before the pivot table is created we need to check on both head and
 * tail for the subset.
 * */
stmt *
complex_find_subset(stmt *subset, stmt *t)
{

	if (t) {
		node *n;

		for (n = subset->op1.lval->h; n; n = n->next) {
			stmt *s = n->data;

			if (s->t == t)
				return stmt_dup(s);
		}
		for (n = subset->op1.lval->h; n; n = n->next) {
			stmt *s = n->data;

			if (s->h == t)
				return stmt_dup(s);
		}
	}
	return NULL;
}

/* The case/when construction in the selection works on the resulting
   table (ie. on the marked columns). We just need to know which oid list
   is involved (ie. find one subset).
   We need to check if for all results the types are the same. 

 TODO case in where part!!
 */
static stmt *
sql_case(mvc *sql, scope *scp, int token, symbol *opt_cond, dlist *when_search_list, symbol *opt_else, group *grp, stmt *subset, int f)
{
	sql_subtype *tpe = NULL;
	list *conds = create_stmt_list();
	list *results = create_stmt_list();
	dnode *dn = when_search_list->h;
	sql_subtype *restype = NULL;
	stmt *res = NULL, *else_stmt = NULL;
	node *n, *m;

	if (dn) {
		stmt *cond = NULL, *result = NULL;

		/* NULLIF(e1,e2) == CASE WHEN e1=e2 THEN NULL ELSE e1 END */
		if (token == SQL_NULLIF) {
			stmt *e1, *e2;

			e1 = sql_value_exp(sql, scp, dn->data.sym, grp, subset, f);
			e2 = sql_value_exp(sql, scp, dn->next->data.sym, grp, subset, f);
			if (e1 && subset && subset->nrcols && e1->nrcols == 0)
				e1 = stmt_const(first_subset(subset), e1);
			if (e1 && e2) {
				cond = sql_compare(sql, stmt_dup(e1), e2, "=", sql_search);
				result = stmt_atom(atom_general(sql_dup_subtype(tail_type(e1)), NULL, 0));
				else_stmt = e1;	/* ELSE case */
			} else {
				if (e1)
					stmt_destroy(e1);
				if (e2)
					stmt_destroy(e2);
			}
			/* COALESCE(e1,e2) == CASE WHEN e1 
			   IS NOT NULL THEN e1 ELSE e2 END */
		} else if (token == SQL_COALESCE) {
			cond = sql_value_exp(sql, scp, dn->data.sym, grp, subset, f);

			if (cond && subset->nrcols && cond->nrcols == 0)
				cond = stmt_const(first_subset(subset), cond);
			if (cond) {
				result = stmt_dup(cond);
				cond = sql_compare(sql, cond, stmt_atom(atom_general(sql_dup_subtype(tail_type(cond)), NULL, 0)), "<>", sql_search);
			}
		} else {
			dlist *when = dn->data.sym->data.lval;

			if (opt_cond) {
				cond = sql_compare_exp(sql, scp, grp, subset, opt_cond, when->h->data.sym, "=", sql_search);
			} else {
				cond = sql_logical_exp(sql, scp, when->h->data.sym, grp, subset, sql_search);
			}
			result = sql_value_exp(sql, scp, when->h->next->data.sym, grp, subset, f);
		}
		if (!cond || !result) {
			list_destroy(conds);
			list_destroy(results);
			return NULL;
		}
		list_prepend(conds, cond);
		list_prepend(results, result);

		restype = sql_dup_subtype(tail_type(result));

		if (token == SQL_NULLIF)
			dn = NULL;
		else
			dn = dn->next;
	}
	if (!restype) {
		list_destroy(conds);
		list_destroy(results);
		return sql_error(sql, 02, "result type missing");
	}
	for (; dn; dn = dn->next) {
		stmt *cond = NULL, *result = NULL;

		if (token == SQL_COALESCE) {
			cond = sql_value_exp(sql, scp, dn->data.sym, grp, subset, f);

			if (cond && subset->nrcols && cond->nrcols == 0)
				cond = stmt_const(first_subset(subset), cond);
			if (cond) {
				result = stmt_dup(cond);
				cond = sql_compare(sql, cond, stmt_atom(atom_general(sql_dup_subtype(tail_type(cond)), NULL, 0)), "<>", sql_search);
			}
		} else {
			dlist *when = dn->data.sym->data.lval;

			if (opt_cond) {
				cond = sql_compare_exp(sql, scp, grp, subset, opt_cond, when->h->data.sym, "=", sql_search);
			} else {
				cond = sql_logical_exp(sql, scp, when->h->data.sym, grp, subset, sql_search);
			}
			result = sql_value_exp(sql, scp, when->h->next->data.sym, grp, subset, sql_search);
		}
		if (!cond || !result) {
			list_destroy(conds);
			list_destroy(results);
			return NULL;
		}
		list_prepend(conds, cond);
		list_prepend(results, result);

		tpe = tail_type(result);
		if (!tpe) {
			list_destroy(conds);
			list_destroy(results);
			return sql_error(sql, 02, "result type missing");
		}
		tpe = supertype(restype, tpe);
		sql_subtype_destroy(restype);
		if (!tpe) {
			list_destroy(conds);
			list_destroy(results);
			return sql_error(sql, 02, "result types %s,%s of case are not compatible", restype->type->sqlname, tpe->type->sqlname);
		}
		restype = tpe;
	}
	if (subset) {
		res = first_subset(subset);
		if (!res) {
			list_destroy(conds);
			list_destroy(results);
			return sql_error(sql, 02, "subset not found for CASE statement");
		}
	} else if (f != sql_sel) {
		return sql_error(sql, 02, "CASE in query currently not supported");
	}
	if (opt_else || else_stmt) {
		stmt *result = else_stmt;

		if (!result)
			result = sql_value_exp(sql, scp, opt_else, grp, subset, f);

		tpe = tail_type(result);
		if (tpe && restype) {
			tpe = supertype(restype, tpe);
			sql_subtype_destroy(restype);
		}
		restype = tpe;

		if (!result || !(result = check_types(sql, restype, result, type_equal))) {
			list_destroy(conds);
			list_destroy(results);
			return NULL;
		}

		if (result->nrcols <= 0 && (f != sql_sel || subset)) {
			res = stmt_const(res, result);
		} else {
			if (res)
				stmt_destroy(res);
			res = result;
		}

		if (!res) {
			list_destroy(conds);
			list_destroy(results);
			return NULL;
		}
	} else {
		stmt *a = stmt_atom(atom_general(sql_dup_subtype(restype), NULL, 0));

		if (res) {
			res = stmt_const(res, a);
		} else if (!subset) {
			res = a;
		} else {
			stmt_destroy(a);
			return sql_error(sql, 02, "CASE in query currently not supported");
		}
	}

	for (n = conds->h, m = results->h; n && m; n = n->next, m = m->next) {
		stmt *cond = stmt_dup(n->data);
		stmt *result = stmt_dup(m->data);

		/* handle single values differently ! */
		if (f == sql_sel && !subset) {
			res = sql_Nop_(sql, "ifthenelse", cond, result, res);
		} else {
			if (result->nrcols <= 0)
				result = stmt_const(cond, result);
			else
				result = stmt_semijoin(result, cond);

			if (!(result = check_types(sql, restype, result, type_equal))) {
				list_destroy(conds);
				list_destroy(results);
				stmt_destroy(res);
				return NULL;
			}
			res = stmt_replace(res, result);
		}
	}
	list_destroy(conds);
	list_destroy(results);
	return res;
}

static stmt *
sql_case_exp(mvc *sql, scope *scp, symbol *se, group *grp, stmt *subset, int f)
{
	dlist *l = se->data.lval;

	if (se->token == SQL_COALESCE) {
		symbol *opt_else = l->t->data.sym;

		return sql_case(sql, scp, se->token, NULL, l, opt_else, grp, subset, f);
	} else if (se->token == SQL_NULLIF) {
		return sql_case(sql, scp, se->token, NULL, l, NULL, grp, subset, f);
	} else if (l->h->type == type_list) {
		dlist *when_search_list = l->h->data.lval;
		symbol *opt_else = l->h->next->data.sym;

		return sql_case(sql, scp, SQL_CASE, NULL, when_search_list, opt_else, grp, subset, f);
	} else {
		symbol *scalar_exp = l->h->data.sym;
		dlist *when_value_list = l->h->next->data.lval;
		symbol *opt_else = l->h->next->next->data.sym;

		return sql_case(sql, scp, SQL_CASE, scalar_exp, when_value_list, opt_else, grp, subset, f);
	}
}

static stmt *
sql_cast(mvc *sql, scope *scp, symbol *se, group *grp, stmt *subset, int f)
{

	dlist *dl = se->data.lval;
	symbol *s = dl->h->data.sym;
	sql_subtype *tpe = dl->h->next->data.typeval;

	stmt *l = sql_value_exp(sql, scp, s, grp, subset, f);

	/* strings may need too be truncated */
	if (tpe ->type ->localtype == TYPE_str) { 
		if (tpe->digits > 0) {
			sql_subtype *st = tail_type(l);
			sql_subtype *it = sql_bind_localtype("int");
			sql_subfunc *c = sql_bind_func(sql->trans->module, "truncate", st, it);
			l = stmt_binop(l, stmt_atom_int(tpe->digits), c);
		}
	}
	if (l)
		return check_types(sql, tpe, l, type_cast);
	return NULL;
}

static stmt *
sql_Nop_(mvc *sql, char *fname, stmt *a1, stmt *a2, stmt *a3)
{
	list *sl = create_stmt_list();
	list *tl = list_create(NULL);
	sql_subfunc *f = NULL;

	list_append(sl, a1);
	list_append(tl, tail_type(a1));
	list_append(sl, a2);
	list_append(tl, tail_type(a2));
	list_append(sl, a3);
	list_append(tl, tail_type(a3));

	f = sql_bind_func_(sql->trans->module, fname, tl);
	list_destroy(tl);
	if (f)
		return stmt_Nop(stmt_list(sl), f);
	return sql_error(sql, 02, "operator: %s unknown", fname);
}

static stmt *
sql_Nop(mvc *sql, scope *scp, symbol *se, group *grp, stmt *subset, int fs)
{
	dnode *l = se->data.lval->h;
	dnode *ops = l->next->data.lval->h;
	list *sl = create_stmt_list();
	list *tl = list_create(NULL);
	sql_subfunc *f = NULL;

	for (; ops; ops = ops->next) {
		stmt *op = sql_value_exp(sql, scp, ops->data.sym, grp, subset, fs);

		if (!op) {
			list_destroy(sl);
			return NULL;
		}
		list_append(sl, op);
		list_append(tl, tail_type(op));
	}
	f = sql_bind_func_(sql->trans->module, l->data.sval, tl);
	list_destroy(tl);
	if (f) {
		return stmt_Nop(stmt_list(sl), f);
	} else {
		if ((f = sql_bind_member(sql->trans->module, l->data.sval, tail_type(sl->h->data), list_length(sl))) != NULL) {
			node *n, *m;
			list *nsl = create_stmt_list();

			n = sl->h;
			list_append(nsl, stmt_dup(n->data));
			m = f->func->ops->h;
			for (n = n->next, m = m->next; n && m; n = n->next, m = m->next) {
				sql_arg *a = m->data;
				stmt *op = stmt_dup(n->data);

				op = check_types(sql, a->type, op, type_equal);
				if (!op) {
					list_destroy(nsl);
					nsl = NULL;
					break;
				}
				list_append(nsl, op);
			}
			if (nsl) {
				list_destroy(sl);
				return stmt_Nop(stmt_list(nsl), f);
			}
		}
		list_destroy(sl);
		return sql_error(sql, 02, "operator: %s unknown", l->data.sval);
	}
	return NULL;
}

static stmt *
sql_binop_(mvc *sql, scope *scp, char *fname, stmt *ls, stmt *rs)
{
	stmt *res = NULL;
	sql_subtype *t1, *t2;
	sql_subfunc *f = NULL;

	t1 = tail_type(ls);
	t2 = tail_type(rs);

	/* input from different tables requires an extra cross-product! */
	if (ls->nrcols > 0 && rs->nrcols > 0 && ls->h != rs->h) {
		ls = stmt_join(scope_find_pivot(scp, ls->h), ls, cmp_equal);
		rs = stmt_join(scope_find_pivot(scp, rs->h), rs, cmp_equal);
	}
	f = sql_bind_func(sql->trans->module, fname, t1, t2);
	if (!f && is_commutative(fname)) {
		f = sql_bind_func(sql->trans->module, fname, t2, t1);
		if (f) {
			sql_subtype *tmp = t1;
			t1 = t2;	
			t2 = tmp;
			res = ls;		
			ls = rs;
			rs = res;
		}
	}
	if (f) {
		if (f->func->res->scale == SCALE_FIX) {
			ls = fix_scale(sql, t2, ls, 0, 0);
			rs = fix_scale(sql, t1, rs, 0, 0);
		} else if (f->func->res->scale == SCALE_SUB) {
			ls = scale_algebra(sql, f, ls, rs);
		} else if (f->func->res->scale == SCALE_ADD) {
			ls = sum_scales(sql, f, ls, rs);
		} else if (f->func->res->scale == DIGITS_ADD) {
			f->res->digits = t1->digits + t2->digits;
		}
		return stmt_binop(ls, rs, f);
	} else {
		int digits = t1->digits + t2->digits;

		if ((f = sql_bind_member(sql->trans->module, fname, t1, 2)) != NULL) {
			/* try finding function based on first argument */
			node *m = f->func->ops->h;
			sql_arg *a = m->next->data;

			rs = check_types(sql, a->type, rs, type_equal);
			if (rs)
				return stmt_binop(ls, rs, f);
		} else if (convert_types(sql, &ls, &rs, 0) >= 0) {
			/* try operators */
			t1 = tail_type(ls);
			t2 = tail_type(rs);
			f = sql_bind_func(sql->trans->module, fname, t1, t2);
			if (f) {
				if (f->func->res->scale == SCALE_FIX) {
					ls = fix_scale(sql, t2, ls, 0, 0);
					rs = fix_scale(sql, t1, rs, 0, 0);
				} else if (f->func->res->scale == SCALE_SUB) {
					ls = scale_algebra(sql, f, ls, rs);
				} else if (f->func->res->scale == SCALE_ADD) {
					ls = sum_scales(sql, f, ls, rs);
				} else if (f->func->res->scale == DIGITS_ADD) {
					f->res->digits = digits;
				}
				return stmt_binop(ls, rs, f);
			}
		}
	}
	if (rs && ls)
		res = sql_error(sql, 02, "binary operator %s(%s,%s) unknown", fname, tail_type(ls)->type->sqlname, tail_type(rs)->type->sqlname);
	if (ls)
		stmt_destroy(ls);
	if (rs)
		stmt_destroy(rs);
	return res;
}

#define MAXDEPTH 512

static stmt *
sql_binop(mvc *sql, scope *scp, symbol *se, group *grp, stmt *subset, int f)
{
	dnode *l = se->data.lval->h;
	stmt *ls, *rs;

	sql->depth++;
	if (sql->depth > MAXDEPTH)
		return sql_error(sql, 02, "Too many nested operators");

 	ls = sql_value_exp(sql, scp, l->next->data.sym, grp, subset, f);
	rs = sql_value_exp(sql, scp, l->next->next->data.sym, grp, subset, f);
	sql->depth --;

	if (!ls || !rs) {
		if (ls)
			stmt_destroy(ls);
		if (rs)
			stmt_destroy(rs);
		return NULL;
	}

	/* also need to add semantic checks here */
	if (ls->type == st_list) {
		stmt *o = ls;

		assert(list_length(ls->op1.lval) == 1);
		ls = stmt_dup(ls->op1.lval->h->data);
		stmt_destroy(o);
	}
	if (rs->type == st_list) {
		stmt *o = rs;

		assert(list_length(rs->op1.lval) == 1);
		rs = stmt_dup(rs->op1.lval->h->data);
		stmt_destroy(o);
	}

	return sql_binop_(sql, scp, l->data.sval, ls, rs);
}

static stmt *
sql_op(mvc *sql, scope *scp, symbol *se, group *grp, stmt *subset)
{
	dnode *l = se->data.lval->h;
	sql_subfunc *f = NULL;

	(void) scp;
	(void) grp;
	(void) subset;		/* Stefan: unused!? */

	f = sql_bind_func(sql->trans->module, l->data.sval, NULL, NULL);
	if (f) {
		return stmt_op(f);
	} else {
		return sql_error(sql, 02, "operator: %s() unknown", l->data.sval);
	}
	return NULL;
}

static stmt *
sql_unop(mvc *sql, scope *scp, symbol *se, group *grp, stmt *subset, int fs)
{
	dnode *l = se->data.lval->h;
	char *fname = l->data.sval;
	sql_subfunc *f = NULL;
	sql_subtype *rt = NULL;
	stmt *rs = sql_value_exp(sql, scp, l->next->data.sym, grp, subset, fs);

	if (!rs)
		return NULL;
	rt = tail_type(rs);
	f = sql_bind_func(sql->trans->module, fname, rt, NULL);
	/* try to find the function with out a type, and convert
	 * the value to the type needed by this function!
	 */
	if (!f && (f = sql_find_func(sql->trans->module, fname, 1)) != NULL) {
		sql_arg *a = f->func->ops->h->data;

		rs = check_types(sql, a->type, rs, type_equal);
		if (!rs) {
			sql_subfunc_destroy(f);
			f = NULL;
		}
	}
	if (f) {
		if (f->func->imp) {
			if (f->func->res->scale == INOUT) {
				f->res->digits = rt->digits;
				f->res->scale = rt->scale;
			}
			return stmt_unop(rs, f);
		} else {
			stmt *res;
			sql_arg *a = f->func->ops->h->data;

			sql_add_param(sql, _strdup(a->name), rs);

			res = sqlparse_intern(sql, f->func->imp);
			sql_subfunc_destroy(f);
			return res;
		}
	} else if (rs) {
		char *type = tail_type(rs)->type->sqlname;

		stmt_destroy(rs);
		return sql_error(sql, 02, "unary operator %s(%s) unknown", l->data.sval, type);
	}
	return NULL;
}


static stmt *
sql_aggrop(mvc *sql, scope *scp, symbol *se, group *grp, stmt *subset, int f)
{
	dlist *l = se->data.lval;
	sql_subaggr *a = NULL;
	int distinct = l->h->next->data.ival;
	stmt *s = NULL;
	char *aggrstr = l->h->data.sval;
	int remove_nils = 0; 

	if (f == sql_where) 
		return sql_error(sql, 02, "aggregates not allowed in WHERE clause");
	
	if (!l->h->next->next->data.sym) {	/* count(*) case */
		cvar *cv;

		if (strcmp(aggrstr, "count") != 0) {
			return sql_error(sql, 02, "unable to perform %s(*) aggregate", l->h->data.sval);
		}
		if (grp) {
			a = sql_bind_aggr(sql->trans->module, aggrstr, NULL);
			return stmt_aggr(stmt_dup(grp->grp), grp_dup(grp), a);
		}
		cv = scope_first_column(scp);
		if (cv && subset) {
			stmt *foundsubset = find_pivot(subset, cv->s->h);

			assert(foundsubset);
			if (!foundsubset) {
				return sql_error(sql, 02, "aggregate: cannot find subset for column %s\n", cv->cname);
			}
			s = stmt_join(foundsubset, stmt_dup(cv->s), cmp_equal);
		} else if (!cv) { /* count(*) without from */
			/* if we have a where (boolean only) */
			if (!(s = scope_bind(scp, NULL, "row"))) 
				return stmt_atom_int(1);
		}
	} else {
		/* use cnt as nils shouldn't be counted */
		if (strcmp(aggrstr, "count") == 0) {
			aggrstr = "count_no_nil";
		} else {
			remove_nils = 1;
		}
		/* the values which are aggregated together, no grp should
		 * be given there to optain the values */
		s = sql_value_exp(sql, scp, l->h->next->next->data.sym, /*grp */ NULL, subset, f);
	}

	if (s && distinct) {
		s = stmt_unique(s, grp_dup(grp));
	}
	if (!s)
		return NULL;
	a = sql_bind_aggr(sql->trans->module, aggrstr, tail_type(s));
	if (a) {
		/* type may have changed, ie. need to 
			fix_scale (avg(dec(sht)) -> double */
		sql_subtype *t = tail_type(s);

		/* inconsistent sql requires NULL != NULL and NULL <> NULL, ie unknown
		 * but also NULL means no values, which means 'ignore'
		 *
		 * so here we need to ignore NULLs
		 */
		if (remove_nils && stmt_has_null(s)) {
			sql_subtype *t = tail_type(s);
			stmt *n = stmt_atom(atom_general(sql_dup_subtype(t), NULL, 0));
			s = stmt_select2(s, n, stmt_dup(n), 0);
		}
		return fix_scale(sql, t, stmt_aggr(s, grp_dup(grp), a), 1, (t->type->scale == SCALE_FIX));
	} else {
		char *type = tail_type(s)->type->sqlname;

		stmt_destroy(s);
		return sql_error(sql, 02, "aggregate: %s(%s) unknown", l->h->data.sval, type);
	}
	return NULL;
}

static stmt *
sql_column_value(mvc *sql, scope *scp, symbol *se, group *grp, stmt *subset, int f)
{
	stmt *s = sql_column_ref(sql, scp, se);

	if (s && s->h && subset && f) {
		stmt *col = s;
		stmt *foundsubset = find_pivot(subset, s->h);

		if (!foundsubset)
			return sql_error(sql, 02, "subset not found for value expression");

		s = stmt_join(foundsubset, s, cmp_equal);
		if (s && grp && f && s->type != st_aggr && grp->cols) {
			if (grp_find_groupby_col(grp, col)) {
				s = stmt_join(stmt_dup(grp->ext), s, cmp_equal);
			} else {
				char *name = column_name(col);

				stmt_destroy(s);
				if (name)
					return sql_error(sql, 02, "cannot use non GROUP BY column '%s' in query results without an aggregate function", name);
				else
					return sql_error(sql, 02, "cannot use non GROUP BY column in query results without an aggregate function");
			}
		} else if (s && grp && f && s->type != st_aggr) {
			s = stmt_join(stmt_dup(grp->ext), s, cmp_equal);
		}
	}
	return s;
}

stmt *
sql_value_exp(mvc *sql, scope *scp, symbol *se, group *grp, stmt *subset, int f)
{

	switch (se->token) {
	case SQL_NOP:
		return sql_Nop(sql, scp, se, grp, subset, f);
	case SQL_BINOP:
		return sql_binop(sql, scp, se, grp, subset, f);
	case SQL_OP:
		return sql_op(sql, scp, se, grp, subset);
	case SQL_UNOP:
		return sql_unop(sql, scp, se, grp, subset, f);
	case SQL_AGGR:
		return sql_aggrop(sql, scp, se, grp, subset, f);
	case SQL_COLUMN:
		return sql_column_value(sql, scp, se, grp, subset, f);
	case SQL_SELECT:{
		stmt *s = scope_subquery(sql, scp, se);

		if (s && s->type == st_list && list_length(s->op1.lval) == 1) {
			stmt *t = stmt_dup(s->op1.lval->h->data);

			stmt_destroy(s);
			s = t;
			s->aggr = 1;	/* single value */
		}
		return s;
	}
	case SQL_PARAMETER:{
		char n[BUFSIZ];
		stmt *s;

		if (sql->mode != m_prepare) {
			return sql_error(sql, 02, "cannot have parameters (?) in normal queries, use PREPARE;");
		}
		snprintf(n, BUFSIZ, "A%d", (sql->params)?list_length(sql->params):0);
		sql_add_param(sql, _strdup(n), s = stmt_var(_strdup(n), NULL));
		return stmt_dup(s);
	}
	case SQL_NULL:
		return stmt_atom(atom_general(sql_dup_subtype(sql_bind_localtype("str")), NULL, 0));
	case SQL_ATOM:{
		AtomNode *an = (AtomNode *) se;

		if (!an || !an->a) {
			return stmt_atom(atom_general(sql_dup_subtype(
					sql_bind_localtype("str")), NULL, 0));
		} else {
			return stmt_atom(atom_dup(an->a));
		}
	}
		break;
	case SQL_NEXT:{
		char *seq = se->data.sval;
		int len = strlen(seq);
		/* NOTE: this is a dirty hack to disable the existence check on
		 *       inline generated sequences, as they don't exist yet,
		 *       but eventually will be.  We recognise this situation if
		 *       the sequence name ends with triple double quotes (").
		 */
		if (
			seq[len - 3] != '"' &&
			seq[len - 2] != '"' &&
			seq[len - 1] != '"' &&
			!sql_find_seq(sql, seq))
		{
			return sql_error(sql, 02, "NEXT VALUE FOR: "
			                 "no such sequence '%s'", seq);
		}
		return stmt_seq_next( _strdup(seq) );
	}
		break;
	case SQL_CAST:
		return sql_cast(sql, scp, se, grp, subset, f);
	case SQL_CASE:
		return sql_case_exp(sql, scp, se, grp, subset, f);
	case SQL_COALESCE:
	case SQL_NULLIF:
		return sql_case_exp(sql, scp, se, grp, subset, f);
	default:
		return sql_logical_exp(sql, scp, se, grp, subset, f);
	}
	return NULL;
}

/* turns a stmt set (or a set of stmt_sets) into a pivot table 
 * ie a table with a oid column for each base table.
 * A row of this pivot table expresses how the rows of the base tables
 * relate.
 */

stmt *
stmt2pivot(scope *scp, stmt *s)
{
	stmt *ptable = stmt_dup(scp->ptable);
	stmt *res = ptable;

	while (ptable_parent(ptable))
		ptable = ptable_parent(ptable);
	assert(!ptable_statements(ptable));
	ptable_statements(ptable) = s;
	res->nrcols = s->nrcols;
	return res;
}

static stmt *
find_on_column_name(mvc *sql, scope *scp, tvar *t, char *name)
{
	node *m;

	(void) sql;
	(void) scp;		/* Stefan: unused!? */

	for (m = t->columns->h; m; m = m->next) {
		cvar *rc = m->data;

		if (strcmp(name, rc->cname) == 0) {
			return stmt_dup(rc->s);
		}
	}
	return NULL;
}

static list *
join_on_column_name(mvc *sql, scope *scp, tvar *tv, tvar *r, int all)
{
	list *res = create_stmt_list();
	node *n;

	for (n = tv->columns->h; n; n = n->next) {
		cvar *lc = n->data;
		stmt *rs = find_on_column_name(sql, scp, r, lc->cname);

		if (rs) {
			list_append(res, stmt_dup(lc->s));
			list_append(res, rs);
		} else if (all) {
			list_destroy(res);
			return NULL;
		}
	}
	return res;
}


static stmt *
sql_join_(mvc *sql, scope *scp, symbol *tab1, int natural, jt jointype, symbol *tab2, symbol *js)
{
	stmt *s = NULL, *subset = NULL;
	tvar *tv1, *tv2;

	tv1 = table_ref(sql, scp, tab1);
	tv2 = table_ref(sql, scp, tab2);

	if (!tv1 || !tv2)
		return NULL;

	if (js && natural) {
		return sql_error(sql, 02, "cannot have a NATURAL JOIN with a join specification (ON or USING);");
	}
	if (!js && !natural) {
		return sql_error(sql, 02, "must have NATURAL JOIN or a JOIN with a specification (ON or USING);");
	}

	if (js && js->token != SQL_USING) {	/* On sql_logical_exp */
		s = sql_logical_exp(sql, scp, js, NULL, NULL, sql_where);
	} else if (js) {	/* using */
		dnode *n = js->data.lval->h;

		s = stmt_reljoin_init();
		for (; n; n = n->next) {
			char *nm = n->data.sval;

			stmt *ls = find_on_column_name(sql, scp, tv1, nm);
			stmt *rs = find_on_column_name(sql, scp, tv2, nm);

			if (!ls || !rs) {
				if (ls)
					stmt_destroy(ls);
				if (rs)
					stmt_destroy(rs);
				if (s)
					stmt_destroy(s);
				return sql_error(sql, 02, "tables %s and/or %s do not have a matching column %s\n", tv1->tname, tv2->tname, nm);
			}
			if ((convert_types(sql, &ls, &rs, 1) < 0)) {
				if (ls)
					stmt_destroy(ls);
				if (rs)
					stmt_destroy(rs);
				if (s)
					stmt_destroy(s);
				return NULL;
			}
			stmt_reljoin_fill(s, ls, rs);
		}
	} else {		/* ! js -> natural join */
		list *matching_columns;
		node *m;

		matching_columns = join_on_column_name(sql, scp, tv1, tv2, 0);

		if (!matching_columns || list_length(matching_columns) == 0) {
			if (matching_columns)
				list_destroy(matching_columns);
			return sql_error(sql, 02, "no attributes of tables %s and %s match\n", tv1->tname, tv2->tname);
		}

		s = stmt_reljoin_init();
		for (m = matching_columns->h; m; m = m->next->next) {
			stmt *ls = stmt_dup(m->data);
			stmt *rs = stmt_dup(m->next->data);

			if ((!rs) || (!ls) || (convert_types(sql, &ls, &rs, 1) < 0)) {
				if (ls)
					stmt_destroy(ls);
				if (rs)
					stmt_destroy(rs);
				if (s)
					stmt_destroy(s);
				return NULL;
			}
			stmt_reljoin_fill(s, ls, rs);
		}
		list_destroy(matching_columns);
	}

	if (s) {
		s = stmt2pivot(scp, s);
	}
	subset = s;
	if (subset) {
		list *l1;
		tvar *t = NULL;
		node *n;
		stmt *fs1 = find_pivot(subset, tv1->s);
		stmt *fs2 = find_pivot(subset, tv2->s);
		stmt *ld = NULL, *rd = NULL;

		if (!fs1 || !fs2) {
			if (fs1)
				stmt_destroy(fs1);
			if (fs2)
				stmt_destroy(fs2);
			if (!fs1) {
				return sql_error(sql, 02, "subset %s not found in JOIN expression", tv1->tname);
			} else if (!fs2) {
				return sql_error(sql, 02, "subset %s not found in JOIN expression", tv2->tname);
			} else {
				return sql_error(sql, 02, "subsets %s,%s not found in JOIN expression", tv1->tname, tv2->tname);
			}

		}

		t = tv1;
		if (jointype == jt_left || jointype == jt_full) {
			cvar *cs = t->columns->h->data;

			/* we need to add the missing oid's */
			ld = stmt_diff(stmt_dup(cs->s), stmt_reverse(stmt_dup(fs1)));
			ld = stmt_mark(stmt_reverse(ld), 0);
		}
		t = tv2;
		if (jointype == jt_right || jointype == jt_full) {
			cvar *cs = t->columns->h->data;

			/* we need to add the missing oid's */
			rd = stmt_diff(stmt_dup(cs->s), stmt_reverse(stmt_dup(fs2)));
			rd = stmt_mark(stmt_reverse(rd), 0);
		}
		l1 = create_stmt_list();
		t = tv1;
		for (n = t->columns->h; n; n = n->next) {
			cvar *cs = n->data;

			list_append(l1, stmt_join(stmt_dup(fs1), stmt_dup(cs->s), cmp_equal));
		}
		t = tv2;
		for (n = t->columns->h; n; n = n->next) {
			cvar *cs = n->data;

			list_append(l1, stmt_join(stmt_dup(fs2), stmt_dup(cs->s), cmp_equal));
		}
		if (fs1)
			stmt_destroy(fs1);
		if (fs2)
			stmt_destroy(fs2);
		if (jointype == jt_left || jointype == jt_full) {
			list *l2 = create_stmt_list();
			node *m = l1->h;

			t = tv1;
			for (n = t->columns->h; n; n = n->next, m = m->next) {
				cvar *cs = n->data;

				list_append(l2, stmt_append(stmt_dup(m->data), stmt_join(stmt_dup(ld), stmt_dup(cs->s), cmp_equal)));
			}
			t = tv2;
			for (n = t->columns->h; n; n = n->next, m = m->next) {
				cvar *cs = n->data;

				list_append(l2, stmt_append(stmt_dup(m->data), stmt_const(stmt_dup(ld), stmt_atom(atom_general(sql_dup_subtype(tail_type(cs->s)), NULL, 0)))));
			}
			list_destroy(l1);
			l1 = l2;
		}
		if (jointype == jt_right || jointype == jt_full) {
			list *l2 = create_stmt_list();
			node *m = l1->h;

			t = tv1;
			for (n = t->columns->h; n; n = n->next, m = m->next) {
				cvar *cs = n->data;

				list_append(l2, stmt_append(stmt_dup(m->data), stmt_const(stmt_dup(rd), stmt_atom(atom_general(sql_dup_subtype(tail_type(cs->s)), NULL, 0)))));
			}
			t = tv2;
			for (n = t->columns->h; n; n = n->next, m = m->next) {
				cvar *cs = n->data;

				list_append(l2, stmt_append(stmt_dup(m->data), stmt_join(stmt_dup(rd), stmt_dup(cs->s), cmp_equal)));
			}
			list_destroy(l1);
			l1 = l2;
		}
		if (ld)
			stmt_destroy(ld);
		if (rd)
			stmt_destroy(rd);
		s = stmt_list(l1);
	}
	if (subset)
		stmt_destroy(subset);
	return s;
}

static stmt *
sql_join(mvc *sql, scope *scp, symbol *q)
{

	dnode *n = q->data.lval->h;
	symbol *tab_ref1 = n->data.sym;
	int natural = n->next->data.ival;
	jt jointype = (jt) n->next->next->data.ival;
	symbol *tab_ref2 = n->next->next->next->data.sym;
	symbol *joinspec = n->next->next->next->next->data.sym;

	return sql_join_(sql, scp, tab_ref1, natural, jointype, tab_ref2, joinspec);
}

stmt *
distinct(stmt *s)
{
	node *n;
	group *grp = NULL;
	list *rl = create_stmt_list();

	for (n = s->op1.lval->h; n; n = n->next) {
		stmt *t = n->data;

		grp = grp_create(stmt_dup(t), grp, NULL);
	}

	for (n = s->op1.lval->h; n; n = n->next) {
		stmt *t = n->data;

		list_append(rl, stmt_join(stmt_dup(grp->ext), stmt_dup(t), cmp_equal));
	}

	if (grp)
		grp_destroy(grp);
	stmt_destroy(s);
	s = stmt_list(rl);
	return s;
}

static stmt *
sql_union(mvc *sql, tvar *tv1, tvar *tv2, dlist *cols )
{
	node *n, *m;
	list *stmts = create_stmt_list();

	if (!cols) {
		for (n = tv1->columns->h, m = tv2->columns->h; n && m; n = n->next, m = m->next) {
			cvar *lc = n->data;
			cvar *rc = m->data;
			stmt *rs = stmt_dup(rc->s);
			stmt *ls = stmt_dup(lc->s);

			if ((convert_types(sql, &ls, &rs, 1) < 0)) {
				if (ls)
					stmt_destroy(ls);
				if (rs)
					stmt_destroy(rs);
				list_destroy(stmts);
				return NULL;
			}

			/* insert single value into table */
			if (lc->s->key) {
				stmt *temp = stmt_temp(sql_dup_subtype(tail_type(ls)));

				ls = stmt_append(temp, ls);
			}
			ls = stmt_append(ls, rs);
			/* the alias keeps the column name around */
			ls = stmt_alias(ls, NULL, _strdup(lc->cname));
			list_append(stmts, ls);
		}
		/* TODO cols length 0 see natural join
		   cols length > 0 see union join, join on name */
	}
	return stmt_list(stmts);
}

static stmt *
sql_except(mvc *sql, tvar *tv1, tvar *tv2, dlist *cols, int distinct )
{
	node *n, *m;

	list *stmts = create_stmt_list();
	if (!cols) {
		/*
		 * The multi column except is handled using group by's and
		 * group size counts on both sides of the except. We then
		 * return for each group of A with (A.count - B.count) > 0, 
	         * number of rows.
		 * 
		 * The problem with this approach is that the groups should
		 * have equal group identifiers. So we take the union of all
		 * columns before the group by.
		 */
		group *lgrp = NULL, *rgrp = NULL;
		stmt *s, *lm, *ld, *ls = NULL, *rs = NULL;
		sql_subaggr *a;

		for (n = tv1->columns->h; n; n = n->next) {
			cvar *lc = n->data;
			stmt *l = stmt_dup(lc->s);

			lgrp = grp_create(l, lgrp, NULL);
		}
		for (n = tv2->columns->h; n; n = n->next) {
			cvar *rc = n->data;
			stmt *r = stmt_dup(rc->s);

			rgrp = grp_create(r, rgrp, NULL);
		}
 		a = sql_bind_aggr(sql->trans->module, "count", NULL);
		ls = stmt_aggr(stmt_dup(lgrp->grp), grp_dup(lgrp), a); 
		a = sql_dup_aggr(a);
		rs = stmt_aggr(stmt_dup(rgrp->grp), grp_dup(rgrp), a); 

		/* now find the matching groups */
		s = stmt_reljoin_init();
		for (n = tv1->columns->h, m = tv2->columns->h; n && m; n = n->next, m = m->next) {
			cvar *lc = n->data;
			cvar *rc = m->data;
			stmt *l = stmt_dup(lc->s);
			stmt *r = stmt_dup(rc->s);

			if ((convert_types(sql, &l, &r, 1) < 0)) {
				if (l)
					stmt_destroy(l);
				if (r)
					stmt_destroy(r);
				if (lgrp)
					grp_destroy(lgrp);
				if (rgrp)
					grp_destroy(rgrp);
				list_destroy(stmts);
				return NULL;
			}
			l = stmt_join(stmt_dup(lgrp->ext), l, cmp_equal);
			r = stmt_join(stmt_dup(rgrp->ext), r, cmp_equal);
			stmt_reljoin_fill(s, l, r);
		}
		
		/* the join of the groups removed those in A but not in B,
		 * we need these later so keep these in 'ld' */
		ld = stmt_diff(stmt_dup(ls), stmt_dup(s));

		if (!distinct) {
			lm = stmt_reverse(stmt_mark_tail(stmt_dup(s),0));
			ls = stmt_join(stmt_dup(lm),ls,cmp_equal);
			rs = stmt_join(stmt_mark(s,0),rs,cmp_equal);

			s = sql_binop_(sql, NULL, "sql_sub", ls, rs);
			s = stmt_select(s, stmt_atom_int(0), cmp_gt);

			/* A ids */
			s = stmt_join(stmt_reverse(lm), s, cmp_equal);
			/* now we need to add the groups which weren't in B */
			s = stmt_union(ld,s);
			/* now we have gid,cnt, blowup to full groupsizes */
			s = stmt_gen_group(s);
		} else {
			stmt_destroy(s);
			s = ld;
		}
		s = stmt_mark_tail(s, 500); 
		/* from gid back to A id's */
		s = stmt_reverse(stmt_join(stmt_dup(lgrp->ext), s, cmp_equal));

		grp_destroy(lgrp);
		grp_destroy(rgrp);

		/* project columns of left hand expression */
		for (n = tv1->columns->h; n; n = n->next) {
			cvar *lc = n->data;
			stmt *ls = stmt_dup(lc->s);

			/* retain name via the stmt_alias */
			ls = stmt_join(stmt_dup(s), ls, cmp_equal);
			ls = stmt_alias(ls, NULL, _strdup(lc->cname));
			list_append(stmts, ls);
		}
		stmt_destroy(s);

		/* TODO cols length 0 see natural join
		   cols length > 0 see union join, join on name */
	}
	return stmt_list(stmts);
}

static stmt *
sql_intersect(mvc *sql, tvar *tv1, tvar *tv2, dlist *cols, int distinct )
{
	node *n, *m;
	list *stmts = create_stmt_list();

	if (!cols) {
		/*
		 * The multi column intersect is handled using group by's and
		 * group size counts on both sides of the intersect. We then
		 * return for each group of A with min(A.count,B.count), 
	         * number of rows.
		 * 
		 * The problem with this approach is that the groups should
		 * have equal group identifiers. So we take the union of all
		 * columns before the group by.
		 */
		group *lgrp = NULL, *rgrp = NULL;
		stmt *s, *lm, *ls = NULL, *rs = NULL;
		sql_subaggr *a;

		for (n = tv1->columns->h; n; n = n->next) {
			cvar *lc = n->data;
			stmt *l = stmt_dup(lc->s);

			lgrp = grp_create(l, lgrp, NULL);
		}
		for (n = tv2->columns->h; n; n = n->next) {
			cvar *rc = n->data;
			stmt *r = stmt_dup(rc->s);

			rgrp = grp_create(r, rgrp, NULL);
		}
 		a = sql_bind_aggr(sql->trans->module, "count", NULL);
		ls = stmt_aggr(stmt_dup(lgrp->grp), grp_dup(lgrp), a); 
		a = sql_dup_aggr(a);
		rs = stmt_aggr(stmt_dup(rgrp->grp), grp_dup(rgrp), a); 

		/* now find the matching groups */
		s = stmt_reljoin_init();
		for (n = tv1->columns->h, m = tv2->columns->h; n && m; n = n->next, m = m->next) {
			cvar *lc = n->data;
			cvar *rc = m->data;
			stmt *l = stmt_dup(lc->s);
			stmt *r = stmt_dup(rc->s);

			if ((convert_types(sql, &l, &r, 1) < 0)) {
				if (l)
					stmt_destroy(l);
				if (r)
					stmt_destroy(r);
				if (lgrp)
					grp_destroy(lgrp);
				if (rgrp)
					grp_destroy(rgrp);
				list_destroy(stmts);
				return NULL;
			}
			l = stmt_join(stmt_dup(lgrp->ext), l, cmp_equal);
			r = stmt_join(stmt_dup(rgrp->ext), r, cmp_equal);
			stmt_reljoin_fill(s, l, r);
		}
		
		if (!distinct) {
			lm = stmt_reverse(stmt_mark_tail(stmt_dup(s),0));
			ls = stmt_join(stmt_dup(lm),ls,cmp_equal);
			rs = stmt_join(stmt_mark(s,0),rs,cmp_equal);

			s = sql_binop_(sql, NULL, "sql_min", ls, rs);
			/* A ids */
			s = stmt_join(stmt_reverse(lm), s, cmp_equal);
			/* now we have gid,cnt, blowup to full groupsizes */
			s = stmt_gen_group(s);
		}
		s = stmt_mark_tail(s, 500); 
		/* from gid back to A id's */
		s = stmt_reverse(stmt_join(stmt_dup(lgrp->ext), s, cmp_equal));

		grp_destroy(lgrp);
		grp_destroy(rgrp);

		/* project columns of left hand expression */
		for (n = tv1->columns->h; n; n = n->next) {
			cvar *lc = n->data;
			stmt *ls = stmt_dup(lc->s);

			/* retain name via the stmt_alias */
			ls = stmt_join(stmt_dup(s), ls, cmp_equal);
			ls = stmt_alias(ls, NULL, _strdup(lc->cname));
			list_append(stmts, ls);
		}
		stmt_destroy(s);

		/* TODO cols length 0 see natural join
		   cols length > 0 see union join, join on name */
	}
	return stmt_list(stmts);
}

static stmt *
sql_setop(mvc *sql, scope *scp, symbol *q)
{
	stmt *res = NULL;
	dnode *n = q->data.lval->h;
	symbol *tab_ref1 = n->data.sym;
	int dist = n->next->data.ival;
	dlist *corresponding = n->next->next->data.lval;
	symbol *tab_ref2 = n->next->next->next->data.sym;

	tvar *tv1 = table_ref(sql, scp, tab_ref1);
	tvar *tv2 = table_ref(sql, scp, tab_ref2);

	if (!tv1 || !tv2) {
		return NULL;
	}

	if (list_length(tv1->columns) != list_length(tv2->columns)) {
		char *op = "UNION";
		if (q->token == SQL_EXCEPT)
			op = "EXCEPT";
		else if (q->token == SQL_INTERSECT)
			op = "INTERSECT";
		return sql_error(sql, 02, "cannot %s different ordinality queries", op);
	}
	if ( q->token == SQL_UNION)
		res = sql_union(sql, tv1, tv2, corresponding );
	if ( q->token == SQL_EXCEPT)
		res = sql_except(sql, tv1, tv2, corresponding, dist );
	if ( q->token == SQL_INTERSECT)
		res = sql_intersect(sql, tv1, tv2, corresponding, dist );
	if (res && dist) {
		res = distinct(res);
	}
	return res;
}

static stmt *
scope_setop(mvc *sql, symbol *q)
{
	scope *nscp = scope_open(NULL);
	stmt *tq = sql_setop(sql, nscp, q);

	if (!tq)
		return NULL;
	(void) scope_close(nscp);
	return tq;
}

static stmt *
sql_cross(mvc *sql, scope *scp, symbol *q)
{

	dnode *n = q->data.lval->h;
	symbol *tab_ref1 = n->data.sym;
	symbol *tab_ref2 = n->next->data.sym;

	tvar *tv1 = table_ref(sql, scp, tab_ref1);
	tvar *tv2 = table_ref(sql, scp, tab_ref2);
	cvar *cv1;
	cvar *cv2;
	stmt *ct;

	if (!tv1 || !tv2)
		return NULL;

	cv1 = tv1->columns->h->data;
	cv2 = tv2->columns->h->data;

	/* cross product */
	ct = stmt_join(stmt_dup(cv1->s), stmt_reverse(stmt_dup(cv2->s)), cmp_all);

	if (ct) {
		/* add the columns */
		list *rl = create_stmt_list();
		node *nv;

		ct = stmt2pivot(scp, ct);

		for (nv = scp->tables->h; nv; nv = nv->next) {
			node *n;
			tvar *tv = nv->data;
			stmt *foundsubset = find_pivot(ct, tv->s);

			for (n = tv->columns->h; n; n = n->next) {
				cvar *cs = n->data;

				list_append(rl, stmt_join(stmt_dup(foundsubset), stmt_dup(cs->s), cmp_equal));
			}
			stmt_destroy(foundsubset);
		}
		stmt_destroy(ct);
		return stmt_list(rl);
	}
	return NULL;
}

static stmt *
scope_cross(mvc *sql, symbol *q)
{
	scope *nscp = scope_open(NULL);
	stmt *tq = sql_cross(sql, nscp, q);

	if (!tq)
		return NULL;
	(void) scope_close(nscp);
	return tq;
}

static tvar *
query_exp_optname(mvc *sql, scope *scp, symbol *q)
{
	tvar *res = NULL;

	switch (q->token) {
	case SQL_UNION:
	case SQL_EXCEPT:
	case SQL_INTERSECT:
	{
		scope *nscp = scope_open(scp);
		stmt *tq = sql_setop(sql, nscp, q);

		if (!tq)
			return NULL;
		res = table_optname(sql, scp, tq, q->data.lval->t->data.sym);
		scp = scope_close(nscp);
		return res;
	}
	case SQL_JOIN:
	{
		scope *nscp = scope_open(scp);
		stmt *tq = sql_join(sql, nscp, q);

		if (!tq)
			return NULL;
		res = table_optname(sql, scp, tq, q->data.lval->t->data.sym);
		scp = scope_close(nscp);
		return res;
	}
	case SQL_CROSS:
	{
		scope *nscp = scope_open(scp);
		stmt *tq = sql_cross(sql, nscp, q);

		if (!tq)
			return NULL;
		res = table_optname(sql, scp, tq, q->data.lval->t->data.sym);
		scp = scope_close(nscp);
		return res;
	}
	case SQL_UNIONJOIN:
	{
		scope *nscp = scope_open(scp);
		node *m;
		dnode *n = q->data.lval->h;

		/*int all = n->next->data.ival; */
		tvar *lv = table_ref(sql, nscp, n->data.sym);
		tvar *rv = table_ref(sql, nscp, n->next->next->data.sym);
		list *unions, *matching_columns;

		if (!lv || !rv)
			return NULL;

		/* find the matching columns (all should match?)
		 * union these 
		 * if !all do a distinct operation at the end 
		 */
		/* join all result columns ie join(lh,rh) on column_name */

		matching_columns = join_on_column_name(sql, nscp, lv, rv, 1);

		if (!matching_columns)
			return NULL;

		unions = create_stmt_list();
		for (m = matching_columns->h; m; m = m->next->next) {
			stmt *l = stmt_dup(m->data);
			stmt *r = stmt_dup(m->next->data);

			list_append(unions, stmt_union(l, r));
		}
		res = table_optname(sql, scp, stmt_list(unions), q->data.lval->t->data.sym);
		list_destroy(matching_columns);
		scp = scope_close(nscp);
		return res;
	}
	default:
		(void) sql_error(sql, 02, "case %d %s\n", q->token, token2string(q->token));
	}
	return NULL;
}

/* column expression of the form: table.* */
static stmt *
columns_exp(mvc *sql, scope *scp, symbol *column_e, group *grp, stmt *subset, int f)
{
	char *tname = column_e->data.lval->h->data.sval;
	tvar *tv = scope_bind_table(scp, tname);

	(void) sql;		/* Stefan: unused!? */
	(void) f;

	if (tv) {
		stmt *foundsubset = find_pivot(subset, tv->s);
		list *columns = create_stmt_list();
		node *n = tv->columns->h;

		if (grp)
			foundsubset = stmt_join(stmt_dup(grp->ext), foundsubset, cmp_equal);
		while (n) {
			cvar *cv = n->data;

			list_append(columns, stmt_join(stmt_dup(foundsubset), stmt_dup(cv->s), cmp_equal));
			n = n->next;
		}
		stmt_destroy(foundsubset);
		return stmt_list(columns);
	} else if (list_length(scp->tables) == 1) {
		tvar *tv = scp->tables->h->data;
		node *n;
		list *columns = create_stmt_list();
		stmt *foundsubset = scope_first_pivot(scp);

		if (grp)
			foundsubset = stmt_join(stmt_dup(grp->ext), foundsubset, cmp_equal);
		for (n = tv->columns->h; n; n = n->next) {
			cvar *cv = n->data;

			if (cv->tname && strcmp(cv->tname, tname) == 0) {
				list_append(columns, stmt_join(stmt_dup(foundsubset), stmt_dup(cv->s), cmp_equal));
			}
		}
		stmt_destroy(foundsubset);
		if (list_length(columns) > 0)
			return stmt_list(columns);
		else
			list_destroy(columns);
	}
	if (!tv)
		return sql_error(sql, 02, "column expression table %s unknown", tname);
	return NULL;
}


static stmt *
_column_exp(mvc *sql, scope *scp, symbol *column_e, group *grp, stmt *subset, int f)
{
	dlist *l = column_e->data.lval;
	stmt *s = sql_value_exp(sql, scp, l->h->data.sym, grp, subset, f);

	if (!s)
		return NULL;
	/* AS name */
	if (s && l->h->next->data.sval) {

		s = stmt_alias(s, table_name(s), _strdup(l->h->next->data.sval));
		scope_add_alias(scp, stmt_dup(s), l->h->next->data.sval);
	}
	return s;
}

static stmt *
sql_column_exp(mvc *sql, scope *scp, symbol *column_e, group *grp, stmt *subset, int f)
{
	stmt *res = NULL;

	if (column_e->token == SQL_TABLE) {
		res = columns_exp(sql, scp, column_e, grp, subset, f);
	} else if (column_e->token == SQL_COLUMN) {
		res = _column_exp(sql, scp, column_e, grp, subset, f);
	}
	if (!res) {
		return sql_error(sql, 02, "column expression symbol(%d)->token = %s no output", (int) column_e->token, token2string(column_e->token));
	}
	return res;
}

static list *
list_map_merge(list *l2, list *l1)
{
	list *res = list_dup(l1, (fdup) &stmt_dup);

	res = list_merge(res, l2, (fdup) &stmt_dup);
	return res;
}

static list *
list_map_append_list(list *l2, list *l1)
{
	return list_append(l1, list_dup(l2, (fdup) &stmt_dup));
}

stmt *
sql_compare(mvc *sql, stmt *ls, stmt *rs, char *compare_op, int f)
{
	int join = 0;
	comp_type type = cmp_equal;

	if (!ls || !rs)
		return NULL;

	if (convert_types(sql, &ls, &rs, 1) < 0) {
		if (ls)
			stmt_destroy(ls);
		if (rs)
			stmt_destroy(rs);
		return NULL;
	}
	/* predicate case ? */
	if (f == sql_sel || (ls->nrcols <= 0 && rs->nrcols <= 0)) {
		return sql_binop_(sql, NULL, compare_op, ls, rs);
	}
	if (ls->nrcols > 0 && rs->nrcols > 0) {
		join = 1;
	}
	if (compare_op[0] == '=') {
		type = cmp_equal;
	} else if (compare_op[0] == '<') {
		type = cmp_lt;
		if (compare_op[1] != '\0') {
			if (compare_op[1] == '>') {
				type = cmp_notequal;
			} else if (compare_op[1] == '=') {
				type = cmp_lte;
			}
		}
	} else if (compare_op[0] == '>') {
		type = cmp_gt;
		if (compare_op[1] != '\0') {
			if (compare_op[1] == '=') {
				type = cmp_gte;
			}
		}
	}
	if (join) {
		if (ls->h && rs->h && ls->h == rs->h) {
			return stmt_uselect(ls, rs, type);
		}
		rs = stmt_reverse(rs);
		return stmt_join(ls, rs, type);
	} else {
		stmt *res;

		if (ls->nrcols == 0) {
			stmt *t = ls;

			ls = rs;
			rs = t;

			if (type == cmp_lt) 
				type = cmp_gt;
			else if (type == cmp_gt) 
				type = cmp_lt;
			else if (type == cmp_lte) 
				type = cmp_gte;
			else if (type == cmp_gte) 
				type = cmp_lte;
		}
		res = stmt_uselect(ls, rs, type);
		if (f == sql_where && (ls->nrcols == 2 || rs->nrcols == 2))
			res = stmt_filter(res);
		return res;
	}
}

static stmt *
sql_compare_exp(mvc *sql, scope *scp, group *grp, stmt *subset, symbol *lo, symbol *ro, char *compare_op, int f)
{
	stmt *rs, *ls;

	if (lo->token == SQL_SELECT) { /* swap subquery to the right handside */
		symbol *tmp = lo;

		lo = ro;
		ro = tmp;

		if (compare_op[0] == '>')
			compare_op[0] = '<';
		else if (compare_op[0] == '<')
			compare_op[0] = '>';
	}

	ls = sql_value_exp(sql, scp, lo, grp, subset, f);
	if (!ls)
		return NULL;
	
	if (ro->token != SQL_SELECT) {
		rs = sql_value_exp(sql, scp, ro, grp, subset, f);
		if (!rs) {
			stmt_destroy(ls);
			return NULL;
		}
		
		if (grp && (!rs->key || !ls->key)) {
			stmt_destroy(rs);
			stmt_destroy(ls);
			return sql_error(sql, 02, "cannot compare sets with values, probably an aggregate function missing");
		}
		return sql_compare(sql, ls, rs, compare_op, f);
	} else {
		node *o;

		rs = scope_subquery(sql, scp, ro);

		if (!rs) {
			stmt_destroy(ls);
			return NULL;
		}
		if (rs->type != st_list || list_length(rs->op1.lval) == 0) {
			stmt_destroy(ls);
			stmt_destroy(rs);
			return sql_error(sql, 02, "subquery result wrong");
		}
		o = rs->op1.lval->h;
		/* no outer references */
		if (list_length(rs->op1.lval) == 1) {
			stmt *sqa = stmt_dup(o->data);

			stmt_destroy(rs);
			return sql_compare(sql, ls, sqa, compare_op, f);
		} else {
			/* for now assume single outer ref ! */
			stmt *oref = stmt_dup(o->next->data);
			stmt *sqa = stmt_dup(o->data);
			stmt *cmp = NULL;
			stmt *h;

			if (list_length(rs->op1.lval) > 2 || !oref->t) {
				stmt_destroy(oref);
				stmt_destroy(sqa);
				stmt_destroy(rs);
				return sql_error(sql, 02, "comparision between incompatible types");
			}

			cmp = stmt_join(stmt_reverse(oref), sqa, cmp_equal);
			if (f == sql_search) {
				/* need to fix the cmp head */
				h = stmt_dup(cmp->h->t);
				stmt_destroy(cmp->h);
				cmp->h = h;

				cmp = stmt_join(find_pivot(subset, cmp->h), cmp, cmp_equal);
			} else {
				/* need to fix the oref head */
				h = stmt_dup(cmp->h->h);
				stmt_destroy(cmp->h);
				cmp->h = h;

				if (subset) {	/* filter subset */
					stmt *p = find_pivot(subset, ls->h);

					ls = stmt_join(p, ls, cmp_equal);
				} else if (ls->nrcols) {
					stmt *p = scope_find_pivot(scp, ls->h);

					ls = stmt_join(p, ls, cmp_equal);
				}
			}
			/* it can happen that the subquery reduces the outer
			   refs, so we need to semijoin here 
			 */
			ls = stmt_semijoin(ls, stmt_dup(cmp));
			cmp = sql_compare(sql, ls, cmp, compare_op, f);
			/* incase of sub queries no need too filter */
			if (f == sql_search)
				return cmp;
			stmt_destroy(rs);
			if (!cmp)
				return NULL;
			return stmt_filter(cmp);
		}
	}
	return NULL;
}

static void
filter(stmt *ptable, stmt *s)
{
	stmt *ps;

	if (!ptable_statements(ptable))
		ptable_statements(ptable) = stmt_list(create_stmt_list());
	ps = ptable_statements(ptable);
	list_append(ps->op1.lval, s);
	if (ps->nrcols < s->nrcols)
		ps->nrcols = s->nrcols;
	ps->key &= s->key;
}

stmt *
sql_and(mvc *sql, scope *scp, stmt *ls, stmt *rs, int f)
{
	stmt *res = NULL;

	if (!ls || !rs)
		return NULL;

	/* keep filters on a higher level, ie. they need a full pivot table */
	if (ls->type == st_filter) {
		filter(scp->ptable, ls);
		return rs;
	}
	if (rs->type == st_filter) {
		filter(scp->ptable, rs);
		return ls;
	}

	if (f == sql_sel || (ls->nrcols <= 0 && rs->nrcols <= 0))
		return sql_binop_(sql, NULL, "and", ls, rs);

	if (f >= sql_search)
		return stmt_semijoin(ls, rs);

	if (ls->type != st_set && ls->type != st_sets) {
		ls = stmt_set(ls);
	}

	if (rs->type != st_set && rs->type != st_sets) {
		rs = stmt_set(rs);
	}

	if (ls->type == st_set && rs->type == st_set) {
		list_merge(ls->op1.lval, rs->op1.lval, (fdup) &stmt_dup);
		ls->nrcols = stmt_list_nrcols(ls->op1.lval);
		stmt_destroy(rs);
		res = ls;
	} else if (ls->type == st_sets && rs->type == st_set) {
		res = stmt_sets(list_map(ls->op1.lval, rs->op1.sval, (fmap) &list_map_merge));
		stmt_destroy(rs);
		stmt_destroy(ls);
	} else if (ls->type == st_set && rs->type == st_sets) {
		res = stmt_sets(list_map(rs->op1.lval, ls->op1.sval, (fmap) &list_map_merge));
		stmt_destroy(rs);
		stmt_destroy(ls);
	} else if (ls->type == st_sets && rs->type == st_sets) {
		res = stmt_sets(list_map(ls->op1.lval, rs->op1.sval, (fmap) &list_map_merge));
		stmt_destroy(rs);
		stmt_destroy(ls);
	}
	return res;
}

static stmt *
sql_or(mvc *sql, scope *scp, stmt *ls, stmt *rs, int f)
{
	stmt *res = NULL;

	(void) sql;		/* Stefan: unused!? */
	(void) scp;		/* Stefan: unused!? */

	if (!ls || !rs)
		return NULL;

	if (f >= sql_search)
		return stmt_union(stmt_const(ls, stmt_atom_int(0)), stmt_const(rs, stmt_atom_int(0)));

	/* optimization 
	   (x = 'a' or x = 'b') ==> union(select(x,'a'),select(x,'b'))
	   should also handle the recursive case!
	 */
	if (ls->type != st_set && ls->type != st_sets && rs->type != st_set && rs->type != st_sets) {
		if (ls->h == rs->h && ls->nrcols == 1 && rs->nrcols == 1)
			return stmt_union(stmt_const(ls, stmt_atom_int(0)), stmt_const(rs, stmt_atom_int(0)));
	}

	if (ls->type != st_set && ls->type != st_sets) {
		ls = stmt_set(ls);
	}
	if (rs->type != st_set && rs->type != st_sets) {
		rs = stmt_set(rs);
	}
	if (ls->type == st_set && rs->type == st_set) {
		res = stmt_sets(list_append(list_append(list_create((fdestroy) &list_destroy), list_dup(ls->op1.lval, (fdup) &stmt_dup)), list_dup(rs->op1.lval, (fdup) &stmt_dup)));
		stmt_destroy(ls);
		stmt_destroy(rs);
	} else if (ls->type == st_sets && rs->type == st_set) {
		list_append(ls->op1.lval, list_dup(rs->op1.lval, (fdup) &stmt_dup));
		res = ls;
		stmt_destroy(rs);
	} else if (ls->type == st_set && rs->type == st_sets) {
		list_append(rs->op1.lval, list_dup(ls->op1.lval, (fdup) &stmt_dup));
		res = rs;
		stmt_destroy(ls);
	} else if (ls->type == st_sets && rs->type == st_sets) {
		(void) list_map(ls->op1.lval, rs->op1.sval, (fmap) &list_map_append_list);
		res = ls;
		stmt_destroy(rs);
	}
	return res;
}

stmt *
sql_logical_exp_(mvc *sql, scope *scp, symbol *sc, group *grp, stmt *subset, int f)
{
	if (!sc)
		return NULL;
	switch (sc->token) {
	case SQL_OR:
	{
		symbol *lo = sc->data.lval->h->data.sym;
		symbol *ro = sc->data.lval->h->next->data.sym;
		stmt *ls = sql_logical_exp(sql, scp, lo, grp, subset, f);
		stmt *rs = sql_logical_exp(sql, scp, ro, grp, subset, f);

		return sql_or(sql, scp, ls, rs, f);
	}
		break;
	case SQL_AND:
	{
		symbol *lo = sc->data.lval->h->data.sym;
		symbol *ro = sc->data.lval->h->next->data.sym;
		stmt *ls = sql_logical_exp(sql, scp, lo, grp, subset, f);
		stmt *rs = sql_logical_exp(sql, scp, ro, grp, subset, f);

		return sql_and(sql, scp, ls, rs, f);
	}
		break;
	case SQL_COMPARE:
	{
		symbol *lo = sc->data.lval->h->data.sym;
		symbol *ro = sc->data.lval->h->next->next->data.sym;
		char *compare_op = sc->data.lval->h->next->data.sval;

		return sql_compare_exp(sql, scp, grp, subset, lo, ro, compare_op, f);
	}
		break;
	case SQL_BETWEEN:
	case SQL_NOT_BETWEEN:
	{
		stmt *res = NULL;
		symbol *lo = sc->data.lval->h->data.sym;
		int symmetric = sc->data.lval->h->next->data.ival;
		symbol *ro1 = sc->data.lval->h->next->next->data.sym;
		symbol *ro2 = sc->data.lval->h->next->next->next->data.sym;
		stmt *ls = sql_value_exp(sql, scp, lo, grp, subset, f);
		stmt *rs1 = sql_value_exp(sql, scp, ro1, grp, subset, f);
		stmt *rs2 = sql_value_exp(sql, scp, ro2, grp, subset, f);
		sql_subtype *ct = NULL;

		if (!ls || !rs1 || !rs2)
			return NULL;
		ct = tail_type(ls);
		rs1 = check_types(sql, ct, rs1, type_equal);
		rs2 = check_types(sql, ct, rs2, type_equal);
		if (symmetric) {
			stmt *tmp = NULL;
			sql_subfunc *min = sql_bind_func(sql->trans->module, "min", tail_type(rs1), tail_type(rs2));
			sql_subfunc *max = sql_bind_func(sql->trans->module, "max", tail_type(rs1), tail_type(rs2));

			if (!min || !max) {
				return sql_error(sql, 02, "min or max operator on types %s %s missing", tail_type(rs1)->type->sqlname, tail_type(rs2)->type->sqlname);
			}
			tmp = stmt_binop(rs1, rs2, min);
			rs2 = stmt_binop(stmt_dup(rs1), stmt_dup(rs2), max);
			rs1 = tmp;
		}
		if (rs1->nrcols > 0 || rs2->nrcols > 0 || f == sql_sel) {
			stmt *j1, *j2;

			if (sc->token == SQL_NOT_BETWEEN) {
				j1 = sql_compare(sql, stmt_dup(ls), rs1, "<", f);
				j2 = sql_compare(sql, stmt_dup(ls), rs2, ">", f);
			} else {
				j1 = sql_compare(sql, stmt_dup(ls), rs1, ">=", f);
				j2 = sql_compare(sql, stmt_dup(ls), rs2, "<=", f);
			}
			stmt_destroy(ls);
			return sql_and(sql, scp, j1, j2, f);
		}
		res = stmt_uselect2(ls, rs1, rs2, 3
				    /* aka rs1 <= ls <= rs2 */ );
		if (sc->token == SQL_NOT_BETWEEN)
			res = stmt_diff(stmt_dup(ls), res);
		return res;
	}
	case SQL_LIKE:
	case SQL_NOT_LIKE:
	{
		stmt *res = NULL;
		symbol *lo = sc->data.lval->h->data.sym;
		symbol *ro = sc->data.lval->h->next->data.sym;
		stmt *ls = sql_value_exp(sql, scp, lo, grp, subset, f);
		stmt *a = NULL, *e = NULL;
		sql_subtype *st = sql_bind_localtype("str");
		char *es = NULL;

		if (!ls)
			return NULL;

		if (!tail_type(ls)) {
			stmt_destroy(ls);
			return sql_error(sql, 02, "No parameter allowed on left hand of LIKE statement");
		}

		lo = ro->data.lval->h->data.sym;
		a = sql_value_exp(sql, scp, lo, grp, subset, f);

		if (!a) {
			stmt_destroy(ls);
			return NULL;
		}
		if (dlist_length(ro->data.lval) == 2) {
			es = ro->data.lval->h->next->data.sval;
			e = stmt_atom_string(_strdup(es));
		}
		if (!tail_type(a)) {
			if (set_type_param(st, a) == -1) {
				stmt_destroy(ls);
				stmt_destroy(a);
				return sql_error(sql, 02, "wrong type used with LIKE statement, should be string");
			}
		} else if ((a = check_types(sql, st, a, type_equal)) == NULL) {
			stmt_destroy(ls);
			return sql_error(sql, 02, "wrong type used with LIKE statement, should be string");
		}
		/* predicate case ? */
		if (ls->nrcols == 0 || f == sql_sel) {
			sql_subtype *bt = sql_bind_localtype("bit");
			sql_subtype *s = sql_bind_localtype("str");
			sql_subfunc *like = sql_bind_func_result(sql->trans->module, "like", s, s, bt);

			res = stmt_binop(ls, a, like);
			if (sc->token != SQL_LIKE) {
				sql_subfunc *not = sql_bind_func_result(sql->trans->module, "not", bt, NULL, bt);

				res = stmt_unop(stmt_dup(res), not);
			}
		} else {
			comp_type cmp = (sc->token == SQL_LIKE ? cmp_like : cmp_notlike);

			/* default to the '\' char for escape */
			if (es == NULL)
				e = stmt_atom_string(_strdup(""));
			res = stmt_likeselect(ls, a, e, cmp);
		}
		return res;
	}
	case SQL_IN:
	case SQL_NOT_IN:
		/*
		   <in predicate> ::=
		   <row value constructor>
		   [ NOT ] IN <in predicate value>

		   <in predicate value> ::=
		   <table subquery>
		   | <left paren> <in value list> <right paren>

		   <in value list> ::=
		   <value expression> { <comma> <value expression> }...
		 */
	{
		dlist *l = sc->data.lval;
		symbol *lo = l->h->data.sym;
		stmt *ls = sql_value_exp(sql, scp, lo, grp, subset, f);

		if (!ls)
			return NULL;
		if (l->h->next->type == type_list) {
			dnode *n = l->h->next->data.lval->h;
			sql_subtype *ct = tail_type(ls);
			stmt *temp = stmt_temp(sql_dup_subtype(ct));

			for (; n; n = n->next) {
				symbol *sval = n->data.sym;
				stmt *v = sql_value_exp(sql, scp, sval, NULL, NULL, f);

				temp = stmt_append(temp, check_types(sql, ct, v, type_equal));
			}
			if (sc->token == SQL_IN) {
				/* predicate case ? */
				if (ls->nrcols == 0) {
					sql_subtype *tp = tail_type(ls);
					sql_subaggr *exist;

					/* exist(temp,ls) */
					exist = sql_bind_aggr(sql->trans->module, "exist", tp);
					temp = stmt_reverse(temp);
					return stmt_aggr2(temp, ls, exist);
				} else if (f == sql_sel) {
					sql_subtype *bt = sql_bind_localtype("bit");
					sql_subtype *tp = tail_type(ls);
					sql_subfunc *isnul, *not;

					isnul = sql_bind_func_result(sql->trans->module, "isnull", tp, NULL, bt);
					not = sql_bind_func_result(sql->trans->module, "not", bt, NULL, bt);
					return stmt_unop(stmt_unop(stmt_outerjoin(ls, stmt_reverse(temp), cmp_equal), isnul), not);
				} else {	/* normal subquery */
					return stmt_reverse(stmt_semijoin(stmt_reverse(ls), stmt_reverse(temp)));
				}
			} else {	/* SQL_NOT_IN */
				/* predicate case ? */
				if (ls->nrcols == 0) {
					sql_subtype *tp = tail_type(ls);
					sql_subaggr *nexist;

					/* [not_exist](temp,ls) */
					/* not_exit needed to handle
					   null correctly */
					nexist = sql_bind_aggr(sql->trans->module, "not_exist", tp);
					temp = stmt_reverse(temp);
					return stmt_aggr2(temp, ls, nexist);
				} else if (f == sql_sel) {
					sql_subtype *bt = sql_bind_localtype("bit");
					sql_subtype *tp = tail_type(ls);
					sql_subfunc *isnul;

					isnul = sql_bind_func_result(sql->trans->module, "isnull", tp, NULL, bt);
					return stmt_unop(stmt_outerjoin(ls, stmt_reverse(temp), cmp_equal), isnul);
				} else {	/* normal subquery */
					return stmt_diff(stmt_dup(ls), stmt_join(ls, stmt_reverse(temp), cmp_equal));
				}
			}
		} else if (l->h->next->type == type_symbol) {
			symbol *ro = l->h->next->data.sym;
			stmt *sq = scope_subquery(sql, scp, ro);

			if (!sq)
				return NULL;

			if (sq->type != st_list || list_length(sq->op1.lval) == 0) {
				stmt_destroy(sq);
				return sql_error(sql, 02, "subquery result wrong");
			}

			if (list_length(sq->op1.lval) == 1) {
				stmt *rs = stmt_dup(sq->op1.lval->h->data);

				stmt_destroy(sq);
				/* predicate case ? */
				if (ls->nrcols == 0) {
					sql_subtype *tp = tail_type(ls);
					sql_subaggr *exist;

					if (sc->token == SQL_IN) {
						/* exist(rs,ls) */
						exist = sql_bind_aggr(sql->trans->module, "exist", tp);
					} else {
						/* exist(rs,ls) */
						exist = sql_bind_aggr(sql->trans->module, "not_exist", tp);
					}
					rs = stmt_reverse(rs);
					return stmt_aggr2(rs, ls, exist);
				} else if (f != sql_sel) {
					if (sc->token == SQL_IN) {
						if (rs->nrcols) {	/* set in (select set) */
							return stmt_reverse(stmt_semijoin(stmt_reverse(ls), stmt_reverse(rs)));
						} else {
							/* v1 in (select v2)
							 * and
							 * set in (select value) 
							 */
							return sql_compare(sql, ls, rs, "=", f);
						}
					} else {	/* SQL_NOT_IN */
						if (rs->nrcols) {	/* set not in (select set) */
							return stmt_reverse(stmt_diff(stmt_reverse(ls), stmt_reverse(rs)));
						} else {
							/* v1 not in (select v2) 
							 * and
							 * set not in (select v1) 
							 */
							return sql_compare(sql, ls, rs, "<>", f);
						}
					}
				} else 	if (ls->nrcols == 0) {
					sql_subtype *tp = tail_type(ls);
					sql_subaggr *exist;

					if (sc->token == SQL_IN) {
						/* exist(rs,ls) */
						exist = sql_bind_aggr(sql->trans->module, "exist", tp);
					} else {
						/* [not_exist](temp,ls) */
						/* not_exit needed to handle null correctly */
						exist = sql_bind_aggr(sql->trans->module, "not_exist", tp);
					}
					rs = stmt_reverse(rs);
					return stmt_aggr2(rs, ls, exist);
						
				} else if (rs->nrcols == 0) { 
				/* SELECT name [not] in (select 'a') FROM tables */
				/* single value */
					if (sc->token == SQL_IN) {
						return sql_compare(sql, ls, rs, "=", f);
					} else {
						return sql_compare(sql, ls, rs, "<>", f);
					}
					/* set of values */
				} else {
					sql_subtype *bt = sql_bind_localtype("bit");
					sql_subtype *tp = tail_type(ls);
					sql_subfunc *isnul;

					isnul = sql_bind_func_result(sql->trans->module, "isnull", tp, NULL, bt);
					if (sc->token == SQL_IN) {
						sql_subfunc *not = sql_bind_func_result(sql->trans->module, "not", bt, NULL, bt);
						return stmt_unop(stmt_unop(stmt_outerjoin(ls, stmt_reverse(rs), cmp_equal), isnul), not);
					} else {
						return stmt_unop(stmt_outerjoin(ls, stmt_reverse(rs), cmp_equal), isnul);
					}
				}
			} else {
				/* TODO fix this broken impl ! */
				return sql_error(sql, 03, "time to implement (NOT) IN with outer refs\n");
			}
			return NULL;
		} else {
			return sql_error(sql, 02, "IN: missing inner query");
		}
	}
		break;
	case SQL_EXISTS:
	case SQL_NOT_EXISTS:
	{
		symbol *lo = sc->data.sym;
		stmt *ls = scope_subquery(sql, scp, lo);

		if (!ls)
			return NULL;

		if (ls->type != st_list) {
			stmt_destroy(ls);
			return sql_error(sql, 02, "subquery result wrong");
		}
		if (list_length(ls->op1.lval) == 1 || f == sql_sel) {
			/* predicate case */
			/* EXIST non empty result means AND TRUE */
			/* NOT EXIST non empty result means AND FALSE */
			stmt *res, *s = ls->op1.lval->h->data;
			sql_subaggr *cnt;
			sql_subtype *bt = sql_bind_localtype("bit");
			sql_subtype *it = sql_bind_localtype("int");

			if (s->nrcols == 0) {
				s = stmt_append(stmt_temp(tail_type(s)), stmt_dup(s));
			}
			cnt = sql_bind_aggr(sql->trans->module, "count", NULL);
			res = stmt_dup(s);
			res = stmt_aggr(res, NULL, cnt);
			if (sc->token == SQL_EXISTS) {
				sql_subfunc *ne = sql_bind_func_result(sql->trans->module, "<>", it, it, bt);

				res = stmt_binop(res, stmt_atom_int(0), ne);
			} else {	/* NOT EXISTS */
				sql_subfunc *e = sql_bind_func_result(sql->trans->module, "=", it, it, bt);

				res = stmt_binop(res, stmt_atom_int(0), e);
			}
			stmt_destroy(ls);
			return res;
		} else {
			/* for now assume single outer ref ! */
			node *o = ls->op1.lval->h;
			stmt *t, *oref = stmt_dup(o->next->data);

			/* need to fix the oref tail */
			t = stmt_dup(oref->t->t);
			stmt_destroy(oref->t);
			oref->t = t;

			t = stmt_reverse(oref);
			if (sc->token == SQL_NOT_EXISTS)
				t = stmt_diff(scope_first_pivot(scp), t);
			stmt_destroy(ls);
			return stmt_filter(t);
		}
	}
		break;
	case SQL_NULL:
	case SQL_NOT_NULL:
	/* is (NOT) NULL */
	{
		symbol *cr = sc->data.sym;
		stmt *res = sql_value_exp(sql, scp, cr, grp, subset, f);

		/* TODO predicate!! */
		if (res) {
			sql_subtype *tpe = sql_dup_subtype(tail_type(res));
			stmt *a = stmt_atom(atom_general(tpe, NULL, 0));

			if (sc->token == SQL_NULL) {
				res = stmt_uselect(res, a, cmp_equal);
			} else {
				res = stmt_uselect(res, a, cmp_notequal);
			}
		}
		return res;
	}
		break;
	case SQL_NOT: {
		symbol *lo = sc->data.sym;
		stmt *ls = sql_logical_exp(sql, scp, lo, grp, subset, f);
		sql_subtype *bt = sql_bind_localtype("bit");
		sql_subfunc *not = sql_bind_func_result(sql->trans->module, "not", bt, NULL, bt);
		
		if (!ls)
			return NULL;

		return stmt_unop(ls, not);
	}
		break;
	case SQL_ATOM: {
		AtomNode *an = (AtomNode *) sc;

		/* TRUE or FALSE */
		return stmt_atom(atom_dup(an->a));
	}
		break;
	default:
		return sql_error(sql, 02, "predicate %s %d: time to implement some more", token2string(sc->token), sc->token);
	}
	return sql_error(sql, 02, "predicate: time to implement some more");
}

stmt *
sql_logical_exp(mvc *sql, scope *scp, symbol *sc, group *grp, stmt *subset, int f)
{
	stmt *s = sql_logical_exp_(sql, scp, sc, grp, subset, f);

	if (s && s->nrcols == 0 && f == sql_where) {
		/* predicate */
		sql_subtype *bt = sql_bind_localtype("bit");
		stmt *t = NULL;
		int found = 1;

		if (!(t = scope_bind(scp, NULL, "row"))) {
			t = stmt_temp(sql_dup_subtype(bt));
			t = stmt_append(t, stmt_bool(1));
			found = 0;
		}
		if (!(s = check_types(sql, bt, s, type_equal)))
			return NULL;
		s = stmt_select(t, s, cmp_equal);
		if (!found)
			scope_add_alias(scp, stmt_dup(s), "row");

	} else if (s && s->nrcols == 0 && f == sql_search && subset) {
		stmt *t = first_subset(subset);

		t = stmt_const(t, stmt_bool(1));
		return stmt_select(t, s, cmp_equal);
	}
	if (s && s->type == st_filter) {
		filter(scp->ptable, s);
		if (subset)
			return first_subset(subset);
		else
			return stmt_dup(scope_first_column(scp)->s);
	}
	return s;
}

static group *
query_groupby_inner(mvc *sql, scope *scp, stmt *c, stmt *subset, group *cur)
{
	stmt *s = find_pivot(subset, c->h);

	(void) scp;		/* Stefan: unused!? */

	if (s) {
		stmt *j = stmt_join(s, c, cmp_equal);

		cur = grp_create(j, cur, c);
	}

	if (!cur) {
		char *cn = column_name(c);

		(void) sql_error(sql, 02, "subset not found for groupby column %s\n", cn);
		_DELETE(cn);
		return NULL;
	}
	return cur;
}

static group *
query_groupby(mvc *sql, scope *scp, symbol *groupby, stmt *subset)
{
	group *cur = NULL;
	dnode *o = groupby->data.lval->h;

	while (o) {
		symbol *grp = o->data.sym;
		stmt *c = sql_column_ref(sql, scp, grp);

		if (!c) {
			if (cur)
				grp_destroy(cur);
			return NULL;
		}
		cur = query_groupby_inner(sql, scp, c, subset, cur);
		o = o->next;
	}
	return cur;
}

static list *
rel_groupby(mvc *sql, scope *scp, symbol *groupby)
{
	list *l = create_stmt_list();
	dnode *o = groupby->data.lval->h;

	while (o) {
		symbol *grp = o->data.sym;
		stmt *c = sql_column_ref(sql, scp, grp);

		if (!c) {
			if (l)
				list_destroy(l);
			return NULL;
		}
		list_append(l, c);
		o = o->next;
	}
	return l;
}

static group *
query_groupby_outers(mvc *sql, scope *scp, stmt *subset)
{
	group *cur = NULL;
	node *o = scp->outers->h;

	(void) sql;		/* Stefan: unused!? */

	for (; o; o = o->next) {
		stmt *outer = o->data;
		stmt *s = find_pivot(subset, outer);

		if (s)
			cur = grp_create(s, cur, NULL);
	}
	return cur;
}

/*
   select column_1, column_2 from x order by column_1, column_2;

   As SQL-3 dropped support for order by number (column position in result 
   table) so we also do not support it. Unfortunately SQL-3 added new crap,
   order by 'expression', where expression should match a result column 
   expression. We also do not support this (just use as bla and order by bla!).
   SQL-3 supports ordering on columns not in the result table, but again we
   don't.
 */
static stmt *
orderby_column_ref(mvc *sql, symbol *column_r, stmt *s)
{
	dlist *l = column_r->data.lval;

	assert(column_r->token == SQL_COLUMN && column_r->type == type_list);

	if (dlist_length(l) == 1) {
		char *name = l->h->data.sval;
		node *n;

		for (n = s->op1.lval->h; n; n = n->next) {
			stmt *t = n->data;
			char *cn = column_name(t);

			if (strcmp(cn, name) == 0) {
				_DELETE(cn);
				return stmt_dup(t);
			}
			_DELETE(cn);
		}
		return sql_error(sql, 02, "unknown column name (%s) in ORDER BY", name);
	}
	if (dlist_length(l) == 2) {
		char *tname = l->h->data.sval;
		char *name = l->h->next->data.sval;
		node *n;

		for (n = s->op1.lval->h; n; n = n->next) {
			stmt *t = n->data;
			char *tn = table_name(t);
			char *cn = column_name(t);

			if (tn && strcmp(tn, tname) == 0 && strcmp(cn, name) == 0) {
				if (tn)
					_DELETE(tn);
				_DELETE(cn);
				return stmt_dup(t);
			}
			if (tn)
				_DELETE(tn);
			_DELETE(cn);
		}
		return sql_error(sql, 02, "unknown column name (%s) in ORDER BY", name);
	}
	return sql_error(sql, 02, "only single column names supported in ORDER BY");
}

static stmt *
query_orderby(mvc *sql, symbol *orderby, stmt *s)
{
	stmt *cur = NULL;
	dnode *o = orderby->data.lval->h;

	while (o) {
		symbol *order = o->data.sym;

		if (order->token == SQL_COLUMN) {
			symbol *col = order->data.lval->h->data.sym;
			int direction = order->data.lval->h->next->data.ival;
			stmt *sc = orderby_column_ref(sql, col, s);

			if (sc) {
				if (cur)
					cur = stmt_reorder(cur, sc, direction);
				else
					cur = stmt_order(sc, direction);
			} else {
				return NULL;
			}
		} else {
			return sql_error(sql, 02, "order not of type SQL_COLUMN\n");
		}
		o = o->next;
	}
	return cur;
}

/* find the special 'row' column */
static stmt *
find_base_row( stmt *subset, int aggr )
{
	stmt *s = subset->op1.lval->h->data;
	/* if its an aggregation we need the real base */
	if (aggr)
		while(s->type != st_append && s->op1.stval) 
			s = s->op1.stval;
	return stmt_dup(s);
}

static stmt *
sql_simple_select(mvc *sql, scope *scp, symbol *where, dlist *selection)
{
	stmt *subset = NULL;
	stmt *s = NULL;
	list *rl, *sl;
	dnode *n = NULL;
	node *m;
	int aggr = 0;

	if (!selection) 
		return sql_error(sql, 02, "A query without a 'from' part cannot have a '*' selection");
		
	if (where) {
		s = sql_logical_exp(sql, scp, where, NULL, NULL, sql_where);
		if (!s)
			return NULL;
		if (s->type != st_set && s->type != st_sets) {
			s = stmt_set(s);
		}
		subset = s;
	}
	sl = create_stmt_list();
	for ( n = selection->h; n; n = n->next) {
		stmt *cs = sql_column_exp(sql, scp, n->data.sym, NULL, NULL, sql_sel);

		if (!cs || !tail_type(cs)) {
			if (cs) stmt_destroy(cs);
			list_destroy(sl);
			sql_select_cleanup(sql, s, subset, NULL);
			return sql_error(sql, 02, "subquery result missing");
		}
		list_append(sl, cs);
		aggr |= cs->aggr;
	}
	rl = create_stmt_list();
	for (m = sl->h, n = selection->h; m && n; m = m->next, n = n->next) {
		stmt *cs = m->data;

		/* t1.* */
		if (cs->type == st_list && n->data.sym->token == SQL_TABLE) {
			list_merge(rl, cs->op1.lval, (fdup) &stmt_dup);
		} else if (cs->type == st_list) {	/* subquery */
			if (list_length(cs->op1.lval) == 1) {
				list_append(rl, stmt_dup(cs->op1.lval->h->data));
			} else {
				if (subset) stmt_destroy(subset);
				list_destroy(rl);
				list_destroy(sl);
				return sql_error(sql, 02, "subquery should return a single value");
			}
		} else if (subset) {
			stmt *ss = find_base_row(subset, aggr);

			cs = stmt_const(ss, stmt_dup(cs));
			list_append(rl, cs);
		} else {
			list_append(rl, stmt_dup(cs));
		}
	}
	if (subset)
		stmt_destroy(subset);
	list_destroy(sl);

	s = stmt_list(rl);

	if (!s)
		return sql_error(sql, 02, "subquery result missing");
	return s;
}

static stmt *
sql_select(mvc *sql, scope *scp, SelectNode *sn, int toplevel)
{
	list *rl = NULL;
	stmt *s = NULL;

	stmt *order = NULL, *subset = NULL;
	group *grp = NULL;

	if (!sn->from)
		return sql_simple_select(sql, scp, sn->where, sn->selection);

	if (sn->where) {
		node *n;
		stmt *cur = NULL;

		s = sql_logical_exp(sql, scp, sn->where, NULL, NULL, sql_where);
		if (!s) {
			sql_select_cleanup(sql, s, subset, grp);
			return sql_error(sql, 02, "subquery result missing");
		}
		if (s->type != st_set && s->type != st_sets) {
			s = stmt_set(s);
		}
		/* check for tables not used in the where part */
		if (s->type == st_set) {	/* TODO: handle st_sets!! */
			for (n = scp->tables->h; n; n = n->next) {
				tvar *v = n->data;
				stmt *tmp = complex_find_subset(s, v->s);

				if (!tmp) {
					cvar *cv = v->columns->h->data;

					tmp = stmt_dup(cv->s);
					/* just add a select whole column */
					if (!cur) {
						cur = stmt_dup(tmp);
						/* add join to an already used column */
					} else {
						tmp = stmt_join(stmt_dup(cur), stmt_reverse(tmp), cmp_all);
					}
					s = sql_and(sql, scp, s, tmp, sql_where);
				} else if (!cur) {
					cur = tmp;
				} else {
					stmt_destroy(tmp);
				}
			}
		}
		if (cur)
			stmt_destroy(cur);

	} else if (sn->from) {
		node *n;
		stmt *cur = NULL;

		for (n = scp->tables->h; n; n = n->next) {
			tvar *tv = n->data;
			cvar *cv = tv->columns->h->data;
			stmt *tmp = stmt_dup(cv->s);

			if (!cur) {
				cur = tmp;
			} else {
				tmp = stmt_join(stmt_dup(cur), stmt_reverse(tmp), cmp_all);
				if (s) {
					list_append(s->op1.lval, tmp);
				} else {
					s = stmt_set(tmp);
				}
			}
		}
		if (!cur) {
			sql_select_cleanup(sql, s, subset, grp);
			return sql_error(sql, 02, "subquery has no columns");
		}
		if (!s)
			s = cur;
		else
			stmt_destroy(cur);
	}

	if (s) {
		s = stmt2pivot(scp, s);
		if (s && sn->groupby) {
			/*
			   list *cols = rel_groupby(sql, scp, sn->groupby);
			 */

			grp = query_groupby(sql, scp, sn->groupby, s);
			if (!grp) {
				sql_select_cleanup(sql, s, subset, grp);
				return sql_error(sql, 02, "subquery result missing");
			}
			/*
			   s = stmt_groupby(s, cols);
			 */
		}

		if (s && list_length(scp->outers) > 0) {
			assert(!grp);
			grp = query_groupby_outers(sql, scp, s);
			if (!grp) {
				assert(0);
				sql_select_cleanup(sql, s, subset, grp);
				return sql_error(sql, 02, "subquery outer ref GROUP BY result missing");
			}
		}
	}

	subset = stmt_dup(s);

	if (sn->having) {
		stmt *t, *ss = subset;


		/* handle havings without group by as a subquery, ie
		   they work on the partial pivot tables 
		 */
		if (!grp)
			ss = ptable_parent(subset);

		t = sql_logical_exp(sql, scp, sn->having, grp, ss, sql_search);
		if (!t) {
			sql_select_cleanup(sql, s, subset, grp);
			return sql_error(sql, 02, "subquery result missing");
		}

		if (!grp) {
			filter(subset, stmt_filter(t));
		} else {
			grp = grp_semijoin(grp, t);
		}
	}

	if (!subset) {
		sql_select_cleanup(sql, s, subset, grp);
		return sql_error(sql, 02, "subquery result missing");
	}

	rl = create_stmt_list();
	if (sn->selection) {
		list *sl = create_stmt_list();
		dnode *n;
		node *m;
		int nrcols = 0, aggr = 0;

		for (n = sn->selection->h; n; n = n->next) {
			stmt *cs = sql_column_exp(sql, scp, n->data.sym, grp, subset, sql_sel);

			if (!cs || !tail_type(cs)) {
				list_destroy(sl);
				list_destroy(rl);
				sql_select_cleanup(sql, s, subset, grp);
				return sql_error(sql, 02, "subquery result missing");
			}

			list_append(sl, cs);
			if (nrcols < cs->nrcols)
				nrcols = cs->nrcols;
			aggr |= cs->aggr;
		}

		for (m = sl->h, n = sn->selection->h; m && n; m = m->next, n = n->next) {
			stmt *cs = m->data;

			/* t1.* */
			if (cs->type == st_list && n->data.sym->token == SQL_TABLE) {
				list_merge(rl, cs->op1.lval, (fdup) &stmt_dup);
			} else if (cs->type == st_list) {	/* subquery */
				if (list_length(cs->op1.lval) == 1) {	/* single value */
					stmt *ss = ptable_pivots(subset)->h->data;
					stmt *cs1 = cs->op1.lval->h->data;

					ss = stmt_dup(ss);
					cs1 = stmt_dup(cs1);
					list_append(rl, stmt_join(ss, cs1, cmp_all));
				} else {	/* referenced variable(s) (can only be 2) */
					stmt *sqa = cs->op1.lval->h->data;
					stmt *ids = cs->op1.lval->h->next->data;
					stmt *s = stmt_join(stmt_reverse(stmt_dup(ids)), stmt_dup(sqa), cmp_equal);

					s = stmt_outerjoin(stmt_mirror(first_subset(subset)), s, cmp_equal);
					list_append(rl, s);
				}
			} else if (cs->nrcols == 0) {
				/* select name,count(*) should give an error */
				if (cs->aggr && nrcols > 0) {
					list_destroy(sl);
					list_destroy(rl);
					sql_select_cleanup(sql, s, subset, grp);
					return sql_error(sql, 02, "single value in column expression");
					/* properly handle select '' from x */
				} else if (!cs->aggr && !aggr) {
					stmt *ss = first_subset(subset);

					cs = stmt_const(ss, stmt_dup(cs));
					list_append(rl, cs);
				} else {
					cs = stmt_dup(cs);
					list_append(rl, cs);
				}
			} else if (cs->aggr == 1 && cs->nrcols >= 2) {
				/* sub query single value */
				stmt *ss = ptable_pivots(subset)->h->data;

				ss = stmt_dup(ss);
				cs = stmt_dup(cs);
				list_append(rl, stmt_join(ss, cs, cmp_all));
			} else {
				cs = stmt_dup(cs);
				list_append(rl, cs);
			}
		}
		list_destroy(sl);
	} else {
		/* select * from tables */
		if (grp && list_length(scp->outers) <= 0) {
			list_destroy(rl);
			sql_select_cleanup(sql, s, subset, grp);
			return sql_error(sql, 02, "cannot combine SELECT * with GROUP BY");
		}
		if (toplevel) {
			node *nv;

			for (nv = scp->tables->h; nv; nv = nv->next) {
				node *n;
				tvar *tv = nv->data;
				stmt *foundsubset = find_pivot(subset, tv->s);

				for (n = tv->columns->h; n; n = n->next) {
					stmt *s;
					cvar *cs = n->data;
					stmt *cbat = stmt_dup(cs->s);

					/* selected only a single row ?? */
					if (subset->nrcols == 0) {
						s = cbat;
					} else {
						s = stmt_join(stmt_dup(foundsubset), cbat, cmp_equal);
					}
					list_append(rl, s);
				}
				stmt_destroy(foundsubset);
			}
		} else {
			/* 
			 * subquery can only return one column
			 */
			tvar *tv = scope_first_table(scp);
			stmt *foundsubset = find_pivot(subset, tv->s);

			if (!foundsubset) {
				list_destroy(rl);
				sql_select_cleanup(sql, s, subset, grp);
				return sql_error(sql, 02, "subquery result missing");
			}
			if (tv->columns->h) {
				node *n = tv->columns->h;
				stmt *s;
				cvar *cs = n->data;
				stmt *cbat = stmt_dup(cs->s);

				/* selected only a single row ?? */
				if (subset->nrcols == 0) {
					s = cbat;
				} else {
					s = stmt_join(stmt_dup(foundsubset), cbat, cmp_equal);
				}
				list_append(rl, s);
			}
			stmt_destroy(foundsubset);
		}
	}
	/* the inner query should output a table where the first column
	 * contains the queried column values. 
	 * If variables from the outer query are correlated 
	 * the oids from the base tables of these variables are returned
	 * in the next columns.
	 */
	if (list_length(scp->outers) > 0) {
		node *n = scp->outers->h;

		for (; n; n = n->next) {
			stmt *oref = n->data;
			stmt *foundsubset = find_pivot(subset, oref);

			if (!foundsubset) {
				list_destroy(rl);
				sql_select_cleanup(sql, s, subset, grp);
				return sql_error(sql, 02, "subquery result missing");
			}
			list_append(rl, stmt_join(stmt_dup(grp->ext), foundsubset, cmp_equal));
		}
	}
	stmt_destroy(s);
	s = stmt_list(rl);

	if (s && subset && sn->distinct) {
		s = distinct(s);
	}

	if (s && subset && sn->orderby) {
		order = query_orderby(sql, sn->orderby, s);
		if (!order) {
			sql_select_cleanup(sql, s, subset, grp);
			return sql_error(sql, 02, "subquery result missing");
		}
	}

	if (!s) {
		sql_select_cleanup(sql, s, subset, grp);
		return sql_error(sql, 02, "subquery result missing");
	}

	sql_select_cleanup(sql, NULL, subset, grp);

	if (sn->limit >= 0) {
		int offset = (sn->offset >=0)?sn->offset:0;
		if (order) {
			node *n;
			list *l = create_stmt_list();

			order = stmt_limit(order, offset, sn->limit, 0);
			for (n = s->op1.lval->h; n; n = n->next)
				list_append(l, stmt_semijoin(stmt_dup(n->data), stmt_dup(order)));
			stmt_destroy(s);
			s = stmt_list(l);
		} else {
			/* simply reduce ptable */
			node *n = s->op1.lval->h;
			list *l = create_stmt_list();

			if (n) {
				stmt *limit = stmt_limit(stmt_dup(n->data), offset, sn->limit, 0);
				list_append(l, limit);
				for ( n = n->next; n; n = n->next)
					list_append(l, stmt_semijoin(stmt_dup(n->data), stmt_dup(limit)));
			}
			stmt_destroy(s);
			s = stmt_list(l);
		}
	}

	if (s && order)
		return stmt_ordered(order, s);
	return s;
}


stmt *
selects(mvc *sql, symbol *s)
{
	stmt *ret = NULL;

	switch (s->token) {
	case SQL_SELECT:
		ret = scope_subquery(sql, NULL, s);
		/* add output stmt */
		if (ret)
			ret = stmt_output(ret);
		sql->type = Q_TABLE;
		break;
	case SQL_JOIN:
		ret = sql_join(sql, NULL, s);
		/* add output stmt */
		if (ret)
			ret = stmt_output(ret);
		sql->type = Q_TABLE;
		break;
	case SQL_CROSS:
		ret = scope_cross(sql, s);
		/* add output stmt */
		if (ret)
			ret = stmt_output(ret);
		sql->type = Q_TABLE;
		break;
	case SQL_UNION:
	case SQL_EXCEPT:
	case SQL_INTERSECT:
		ret = scope_setop(sql, s);
		/* add output stmt */
		if (ret)
			ret = stmt_output(ret);
		sql->type = Q_TABLE;
		break;

	default:
		return sql_error(sql, 01, "SELECT statement unknown symbol(%ld)->token = %s", (long) s, token2string(s->token));
	}
	return ret;
}
