@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2008 CWI.
@' All Rights Reserved.

@f sql_select
@a N.J. Nes
@* 

@h
#ifndef _SQL_SELECT_H_
#define _SQL_SELECT_H_

#include <stdio.h>
#include <stdarg.h>
#include <sql_list.h>
#include "sql_symbol.h"
#include "sql_scope.h"
#include "sql_statement.h"
#include "sql_semantic.h"

extern stmt *selects(mvc *sql, scope *scp, symbol *sym);

extern stmt *sql_subquery(mvc *sql, scope *scp, symbol *sq, exp_kind ek);
extern stmt *scope_subquery(mvc *sql, scope *scp, symbol *sq, exp_kind ek );
extern stmt *scope_subtable(mvc *sql, scope *scp, symbol *sq, exp_kind ek );
extern stmt *flat_subquery(mvc *sql, symbol *sq);
extern stmt *sql_reorder(stmt *order, stmt *s);

extern stmt *sql_value_exp(mvc *sql, scope *scp, symbol *se, group *grp, stmt *subset, int f, exp_kind knd);
extern stmt *sql_logical_exp(mvc *sql, scope *scp, symbol *sc, group *grp, stmt *subset, int f, exp_kind knd);
extern stmt *stmt2pivot(scope *scp, stmt *s);

extern stmt *sql_compare(mvc *sql, scope *scp, stmt *ls, stmt *rs, char *compare_op, int f, exp_kind ek);
extern stmt *complex_find_subset(stmt *subset, stmt *t);
extern stmt *sql_and(mvc *sql, scope *scp, stmt *ls, stmt *rs, int f);
extern stmt *sql_unop_(mvc *sql, sql_schema *s, char *fname, stmt *rs);
extern stmt *sql_binop_(mvc *sql, scope *scp, sql_schema *s, char *fname, stmt *ls, stmt *rs);
extern stmt *sql_Nop_(mvc *sql, char *fname, stmt *a1, stmt *a2, stmt *a3, stmt *a4);
extern stmt *find_pivot(stmt *subset, stmt *t);

#endif /*_SQL_SELECT_H_*/
@c

#include "sql_config.h"
#include "sql_select.h"
#include "sql_parser.h"
#include "sql_scope.h"
#include "sql_semantic.h"
#include "sql_sequence.h"
#include "sql_privileges.h"
#include "sql_env.h"
#include "sql_xml.h"

static stmt *sql_select(mvc *sql, scope *scp, SelectNode *sn, exp_kind ek);
static stmt *sql_compare_exp(mvc *sql, scope *scp, group *grp, stmt *subset, symbol *lo, symbol *ro, char *compare_op, int f, exp_kind ek);

static stmt *sql_simple_select(mvc *sql, scope *scp, SelectNode *sn);
static tvar *query_exp_optname(mvc *sql, scope *scp, symbol *q);
static tvar *sql_subquery_optname(mvc *sql, scope *scp, symbol *query);

static void
sql_select_cleanup(mvc *sql, stmt *s, stmt *subset, group *grp)
{
	(void) sql;		/* Stefan: unused!? */

	if (grp)
		grp_destroy(grp);
	if (subset)
		stmt_destroy(subset);
	if (s)
		stmt_destroy(s);
}

static tvar *
sql_table_func(mvc *sql, scope *scp, symbol *query)
{
	tvar *tv = NULL;
	sql_subtype *st = NULL;
	node *m;
	exp_kind ek = {type_value, card_relation, TRUE};
	stmt *sq = sql_value_exp(sql, scp, query->data.lval->h->data.sym, NULL, NULL, sql_from, ek);
	char *tname = NULL;


	if (!sq)
		return NULL;

	if (query->data.lval->h->next->data.sym)
		tname = query->data.lval->h->next->data.sym->data.lval->h->data.sval;

	/* colum or table function */
	st = tail_type(sq);
	if (!st->comp_type) {
		(void) sql_error(sql, 02, "SELECT: '%s' does not return a table", tname);
		return NULL;
	}
	tv = scope_add_table(scp, sq, tname, NULL);

	/* foreach column add column name */
	for (m = st->comp_type->columns.set->h; m; m = m->next) {
		sql_column *c = m->data;
		char *cname = _strdup(c->base.name);
		char *_tname = (tname)?_strdup(tname):NULL;
		stmt *sc = stmt_rs_column(stmt_dup(sq), stmt_atom_string(cname), &c->type);

		sc = stmt_alias(sc, _tname, _strdup(c->base.name));
		sc = stmt_column(sc, stmt_dup(sq), NULL);
		table_add_column(tv, sc, NULL, cname);
	}
	return tv;
}


static tvar *
table_ref(mvc *sql, scope *scp, symbol *tableref)
{
	char *tname = NULL;
	sql_table *t = NULL;

	/* todo handle opt_table_ref 
	   (ie tableref->data.lval->h->next->data.sym */

	switch(tableref->token) {
	case SQL_NAME: { 
		stmt *temp_table = NULL;
		char *sname = qname_schema(tableref->data.lval->h->data.lval);
		sql_schema *s = NULL;
		tname = qname_table(tableref->data.lval->h->data.lval);

		if (sname && !(s=mvc_bind_schema(sql,sname))) {
			(void) sql_error(sql, 02, "SELECT: no such schema '%s'", sname);
			return NULL;
		}
		if (!s)
			s = cur_schema(sql);
		t = mvc_bind_table(sql, s, tname);
		/* TODO: search path */
		if (!t && !sname) {
			s = tmp_schema(sql);
			t = mvc_bind_table(sql, s, tname);
		}
		if (!t && !sname) {
			sql_subtype *tpe;
			if ((tpe = stack_find_type(sql, tname)) != NULL) {
				temp_table = stack_find_var(sql, tname);
				t = tpe->comp_type;
			} else {
				temp_table = stack_find_view(sql, tname);
			}
		}
		if (!t && (!temp_table || temp_table->type != st_list)) {
			(void) sql_error(sql, 02, "SELECT: no such table '%s'", tname);
			return NULL;
		} else if (!temp_table && !table_privs(sql, t, PRIV_SELECT)) {
			(void) sql_error(sql, 02, "SELECT: access denied for %s to table '%s.%s'", stack_get_string(sql, "current_user"), s->base.name, tname);
			return NULL;
		}
		if (tableref->data.lval->h->next->data.sym) {	/* AS */
			tname = tableref->data.lval->h->next->data.sym->data.lval->h->data.sval;
		}
		if (temp_table && !t) {
			return scope_add_temp_view(scp, temp_table, tname); 
		} else if (temp_table) {
			return scope_add_temp_table(scp, t, temp_table, tname); 
		} else {
			return scope_add_table_columns(sql, scp, t, tname, RDONLY);
		}
	}
	case SQL_TABLE:
		return sql_table_func(sql, scp, tableref);
	case SQL_SELECT:
		return sql_subquery_optname(sql, scp, tableref);
	default:
		return query_exp_optname(sql, scp, tableref);
	}
	return NULL;
}

stmt *
sql_subquery(mvc *sql, scope *scp, symbol *sq, exp_kind ek)
{
	SelectNode *sn = (SelectNode *) sq;

	if (sq->token != SQL_SELECT) {
		tvar *tv = table_ref(sql, scp, sq);
		list *l;
		node *n;

		if (!tv)
			return NULL;

		l = create_stmt_list();
		for (n = tv->columns->h; n; n = n->next) {
			cvar *lc = n->data;
			stmt *ls = stmt_dup(lc->s);

			list_append(l, ls);
		}
		return stmt_list(l);
	}
	assert(sn->s.token == SQL_SELECT);

	if ((ek.card != card_relation && sn->limit >= 0) && 
	    (ek.card == card_value && sn->limit != 1))
		return sql_error(sql, 01, "SELECT: LIMIT only allowed on outermost SELECT");

	if (ek.card != card_relation && sn->orderby)
		return sql_error(sql, 01, "SELECT: ORDER BY only allowed on outermost SELECT");

	if (sn->from) {		/* keep variable list with tables and names */
		dlist *fl = sn->from->data.lval;
		dnode *n = NULL;
		tvar *fnd = (tvar *) 1L;	/* 1L to keep 64-bit compilers from complaining *
						 * about different sizes of int and pointer     */

		for (n = fl->h; (n && fnd); n = n->next) 
			fnd = table_ref(sql, scp, n->data.sym);
		if (!fnd)
			return NULL;

	} else if (!scp->p) {	/* only on top level query */
		return sql_simple_select(sql, scp, sn);
	}
	return sql_select(sql, scp, sn, ek);
}

stmt *
scope_subtable(mvc *sql, scope *scp, symbol *sq, exp_kind ek)
{
	stmt *s;

	scp = scope_open(scp);
	s = sql_subquery(sql, scp, sq, ek);
	
	if (!s) {
		scp = scope_close(scp);
		return NULL;
	}

	/* create a table from a single value subquery result */
	if (s->key && s->nrcols == 0) {
		list *l = create_stmt_list();
		node *n;

		for (n = s->op1.lval->h; n; n = n->next) {
			stmt *ns = stmt_dup(n->data);
			char *cname = column_name(ns);
			stmt *temp = stmt_temp(tail_type(ns));

			ns = stmt_append(temp, ns);
			ns = stmt_alias(ns, table_name(ns), cname);
			list_append(l, ns);
		}
		stmt_destroy(s);
		s = stmt_list(l);
	}
	scp = scope_close(scp);
	return s;
}

stmt *
scope_subquery(mvc *sql, scope *scp, symbol *sq, exp_kind ek)
{
	stmt *s;

	scp = scope_open(scp);
	s = sql_subquery(sql, scp, sq, ek);
	scp = scope_close(scp);
	return s;
}

/* handle limit and orderby properly ! */
stmt *
flat_subquery(mvc *sql, symbol *sq)
{
	scope *scp = scope_open(NULL);
	exp_kind ek = {type_value, card_relation, TRUE};
	stmt *n = NULL, *s = sql_subquery(sql, scp, sq, ek);

	scp = scope_close(scp);
	if (s && s->type == st_ordered) {
		n = sql_reorder(stmt_dup(s->op1.stval), stmt_dup(s->op2.stval));
		stmt_destroy(s);
		s = n;
	}
	return s;
}

/* 
 * Column references, can be done using simple names or aliases and
 * using a combination of table name and column name (or alias).
 * The sql_column_ref finds the column based on the specification from
 * symbol column_r.
 */
static stmt *
sql_var_ref(mvc *sql, char *name, int at)
{
	stmt *s = NULL;

	/* TODO in case of global (not builtin session) vars, obtain the 
	   value instead as the variable disappears after the session */

	if ((s = stack_find_var(sql, name)) != NULL) {
		sql_subtype *tpe = stack_find_type(sql, name);
		int frame = stack_find_frame(sql, name);
		if (tpe->comp_type)
			return stmt_table(stmt_dup(s), 1);
		else
			return stmt_var(_strdup(name), tpe, 0, frame);
	} else  if (at) {
		return sql_error(sql, 02, "SELECT: '@""%s' unknown", name);
	} else {
		return sql_error(sql, 02, "SELECT: identifier '%s' unknown or ambiguous", name);
	}
}


static stmt *
sql_column_ref(mvc *sql, scope *scp, symbol *column_r)
{
	stmt *cs = NULL;
	dlist *l = column_r->data.lval;

	assert(column_r->token == SQL_COLUMN && column_r->type == type_list);

	if (dlist_length(l) == 1 && l->h->type == type_int) {
		return stmt_varnr(l->h->data.ival, atom_type(sql_bind_arg(sql, l->h->data.ival)));
	} else if (dlist_length(l) == 1) {
		char *name = l->h->data.sval;

		sql_arg *a = sql_bind_param(sql, name);
		stmt *s = stack_find_var(sql, name);
		cs = scope_bind(scp, NULL, name);

		if (cs) {
			if (a || s) {
				stmt_destroy(cs);
				return sql_error(sql, 02, "SELECT: identifier '%s' ambiguous", name);
			}
		} else if (a) {
			if (s) 
				return sql_error(sql, 02, "SELECT: identifier '%s' ambiguous", name);
			cs = stmt_var(_strdup(a->name), &a->type, 0, 0);
		} else if (s) {
			cs = sql_var_ref(sql, name, 0);
		} else {
			return sql_error(sql, 02, "SELECT: identifier '%s' unknown", name);
		}
	} else if (dlist_length(l) == 2) {
		char *tname = l->h->data.sval;
		char *cname = l->h->next->data.sval;

		if (!(cs = scope_bind(scp, tname, cname))) {
			return sql_error(sql, 02, "SELECT: no such column '%s.%s'", tname, cname);
		}
	} else if (dlist_length(l) >= 3) {
		return sql_error(sql, 02, "TODO: column names of level >= 3");
	}
	return cs;
}

static tvar *
table_optname(mvc *sql, scope *scp, stmt *sq, symbol *optname)
{
	node *m;
	char *tname = NULL;
	dlist *columnrefs = NULL;
	tvar *tv;

	if (optname && optname->token == SQL_NAME) {
		tname = optname->data.lval->h->data.sval;
		columnrefs = optname->data.lval->h->next->data.lval;
	}
	tv = scope_add_table(scp, sq, tname, NULL);
	if (columnrefs) {
		dnode *d;

		if (list_length(sq->op1.lval) != dlist_length(columnrefs)) {
			return sql_error(sql, 02, "SELECT: column definition list does not match real list of columns");
		}
		for (m = sq->op1.lval->h, d = columnrefs->h; d && m; d = d->next, m = m->next) {
			stmt *st = m->data;
			stmt *sc = stmt_column(stmt_alias(stmt_dup(st),
							  _strdup(tname), _strdup(d->data.sval)), stmt_dup(sq), NULL);

			table_add_column(tv, sc, tname, d->data.sval);
		}
	} else if (tname) {
		/* foreach column add column name */
		for (m = sq->op1.lval->h; m; m = m->next) {
			stmt *st = m->data;
			char *cname = column_name(st);
			stmt *sc = stmt_column(stmt_dup(st), stmt_dup(sq), NULL);

			sc = stmt_alias(sc, _strdup(tname), cname);
			table_add_column(tv, sc, tname, cname);
		}
	} else {
		/* foreach column add full basetable,column name */
		for (m = sq->op1.lval->h; m; m = m->next) {
			stmt *sc = NULL, *st = m->data;
			char *cname = column_name(st);
			char *tname = table_name(st);
			sql_table *t = NULL;
			if(tname)
				t = mvc_bind_table(sql, sql->session->schema, tname); 
			sc = stmt_column(stmt_dup(st), stmt_dup(sq), t);

			table_add_column(tv, sc, tname, cname);
			_DELETE(tname);
			_DELETE(cname);
		}
	}
	return tv;
}

static tvar *
sql_subquery_optname(mvc *sql, scope *scp, symbol *query)
{
	SelectNode *sn = (SelectNode *) query;
	stmt *sq = flat_subquery(sql, query);
	char *tname = NULL;

	if (!sq)
		return NULL;

	if (sn->name && sn->name->token == SQL_NAME)
		tname = sn->name->data.lval->h->data.sval;

	/* create a table from a single value subquery result */
	if (sq->key && sq->nrcols == 0) {
		list *l = create_stmt_list();
		node *n;

		for (n = sq->op1.lval->h; n; n = n->next) {
			stmt *nsq = stmt_dup(n->data);
			char *cname = column_name(nsq);
			stmt *temp = stmt_temp(tail_type(nsq));

			nsq = stmt_append(temp, nsq);
			if (tname)
				nsq = stmt_alias(nsq, _strdup(tname), cname);
			else
				nsq = stmt_alias(nsq, table_name(nsq), cname);
			list_append(l, nsq);
		}
		stmt_destroy(sq);
		sq = stmt_list(l);
	}
	return table_optname(sql, scp, sq, sn->name);
}

stmt *
find_pivot(stmt *subset, stmt *t)
{
	assert(subset->type == st_ptable);

	if (t) {
		node *n;

		for (n = ptable_pivots(subset)->h; n; n = n->next) {
			stmt *s = n->data;

			if (s->t == t)
				return stmt_dup(s);
		}
	}
	return NULL;
}

/* before the pivot table is created we need to check on both head and
 * tail for the subset.
 */
stmt *
complex_find_subset(stmt *subset, stmt *t)
{

	if (t) {
		node *n;

		for (n = subset->op1.lval->h; n; n = n->next) {
			stmt *s = n->data;

			if (s->t == t)
				return stmt_dup(s);
		}
		for (n = subset->op1.lval->h; n; n = n->next) {
			stmt *s = n->data;

			if (s->h == t)
				return stmt_dup(s);
		}
	}
	return NULL;
}

/* The case/when construction in the selection works on the resulting
   table (ie. on the marked columns). We just need to know which oid list
   is involved (ie. find one subset).
   We need to check if for all results the types are the same. 
 */
static stmt *
sql_case(mvc *sql, scope *scp, int token, symbol *opt_cond, dlist *when_search_list, symbol *opt_else, group *grp, stmt *subset, int f)
{
	sql_subtype *tpe = NULL;
	list *conds = create_stmt_list();
	list *results = create_stmt_list();
	dnode *dn = when_search_list->h;
	sql_subtype *restype = NULL, rtype;
	stmt *res = NULL, *else_stmt = NULL;
	node *n, *m;
	exp_kind ek = {type_value, card_column, FALSE};
	int aggr = 0;
	
	if (dn) {
		stmt *cond = NULL, *result = NULL;

		/* NULLIF(e1,e2) == CASE WHEN e1=e2 THEN NULL ELSE e1 END */
		if (token == SQL_NULLIF) {
			stmt *e1, *e2;

			e1 = sql_value_exp(sql, scp, dn->data.sym, grp, subset, f, ek);
			e2 = sql_value_exp(sql, scp, dn->next->data.sym, grp, subset, f, ek);
			if (e1 && e2) {
				aggr |= e1->aggr;
				aggr |= e2->aggr;
				if (e1 && subset && subset->nrcols && e1->nrcols == 0)
					e1 = stmt_const(first_subset(subset), e1);
				cond = sql_compare(sql, scp, stmt_dup(e1), e2, "=", sql_sel, ek);
				result = stmt_atom(atom_general(tail_type(e1), NULL, 0));
				else_stmt = e1;	/* ELSE case */
			} else {
				if (e1)
					stmt_destroy(e1);
				if (e2)
					stmt_destroy(e2);
			}
			/* COALESCE(e1,e2) == CASE WHEN e1 
			   IS NOT NULL THEN e1 ELSE e2 END */
		} else if (token == SQL_COALESCE) {
			cond = sql_value_exp(sql, scp, dn->data.sym, grp, subset, f, ek);
			if (cond) {
				sql_subtype *bt = sql_bind_localtype("bit");
				sql_subtype *tp = tail_type(cond);
				sql_subfunc *isnul, *not;

				aggr |= cond->aggr;

				if (cond && subset && subset->nrcols && cond->nrcols == 0 && !cond->aggr)
					cond = stmt_const(first_subset(subset), cond);
				isnul = sql_bind_func_result(sql->session->schema, "isnull", tp, NULL, bt);
				not = sql_bind_func_result(sql->session->schema, "not", bt, NULL, bt);
				result = stmt_dup(cond);
				cond = stmt_unop(stmt_unop(cond, isnul), not);
			}
		} else {
			dlist *when = dn->data.sym->data.lval;

			if (opt_cond) {
				cond = sql_compare_exp(sql, scp, grp, subset, opt_cond, when->h->data.sym, "=", sql_sel, ek);
			} else {
				cond = sql_logical_exp(sql, scp, when->h->data.sym, grp, subset, sql_sel, ek);
			}
			result = sql_value_exp(sql, scp, when->h->next->data.sym, grp, subset, f, ek);
		}
		if (!cond || !result) {
			list_destroy(conds);
			list_destroy(results);
			return NULL;
		}
		list_prepend(conds, cond);
		list_prepend(results, result);

		restype = tail_type(result);

		if (token == SQL_NULLIF)
			dn = NULL;
		else
			dn = dn->next;
	}
	if (!restype) {
		list_destroy(conds);
		list_destroy(results);
		return sql_error(sql, 02, "CASE: result type missing");
	}
	/* for COALESCE we skip the last (else part) */
	for (; dn && (token != SQL_COALESCE || dn->next); dn = dn->next) {
		stmt *cond = NULL, *result = NULL;

		if (token == SQL_COALESCE) {
			cond = sql_value_exp(sql, scp, dn->data.sym, grp, subset, f, ek);
			if (cond) {
				sql_subtype *bt = sql_bind_localtype("bit");
				sql_subtype *tp = tail_type(cond);
				sql_subfunc *isnul, *not;

				aggr |= cond->aggr;

				if (cond && subset && subset->nrcols && cond->nrcols == 0 && !cond->aggr)
					cond = stmt_const(first_subset(subset), cond);
				isnul = sql_bind_func_result(sql->session->schema, "isnull", tp, NULL, bt);
				not = sql_bind_func_result(sql->session->schema, "not", bt, NULL, bt);
				result = stmt_dup(cond);
				cond = stmt_unop(stmt_unop(cond, isnul), not);
			}
		} else {
			dlist *when = dn->data.sym->data.lval;

			if (opt_cond) {
				cond = sql_compare_exp(sql, scp, grp, subset, opt_cond, when->h->data.sym, "=", sql_sel, ek);
			} else {
				cond = sql_logical_exp(sql, scp, when->h->data.sym, grp, subset, sql_sel, ek);
			}
			result = sql_value_exp(sql, scp, when->h->next->data.sym, grp, subset, sql_sel, ek);
		}
		if (!cond || !result) {
			list_destroy(conds);
			list_destroy(results);
			return NULL;
		}
		list_prepend(conds, cond);
		list_prepend(results, result);

		tpe = tail_type(result);
		if (!tpe) {
			list_destroy(conds);
			list_destroy(results);
			return sql_error(sql, 02, "CASE: result type missing");
		}
		supertype(&rtype, restype, tpe);
		if (!tpe) {
			list_destroy(conds);
			list_destroy(results);
			return sql_error(sql, 02, "CASE: incompatible result types '%s' and '%s'", restype->type->sqlname, tpe->type->sqlname);
		}
		restype = &rtype;
	}
	if (subset && (grp || !aggr)) {
		res = first_subset(subset);
		if (!res) {
			list_destroy(conds);
			list_destroy(results);
			return sql_error(sql, 02, "CASE: subset not found");
		}
	} 
	if (opt_else || else_stmt) {
		stmt *result = else_stmt;

		if (!result)
			result = sql_value_exp(sql, scp, opt_else, grp, subset, f, ek);

		tpe = tail_type(result);
		if (tpe && restype) {
			supertype(&rtype, restype, tpe);
			tpe = &rtype;
		}
		restype = tpe;

		if (!result || !(result = check_types(sql, restype, result, type_equal))) {
			list_destroy(conds);
			list_destroy(results);
			return NULL;
		}

		if (res && result->nrcols <= 0 && (f != sql_sel || subset)) {
			res = stmt_const(res, result);
		} else {
			if (res)
				stmt_destroy(res);
			res = result;
		}

		if (!res) {
			list_destroy(conds);
			list_destroy(results);
			return NULL;
		}
	} else {
		stmt *a = stmt_atom(atom_general(restype, NULL, 0));

		if (res) {
			res = stmt_const(res, a);
		} else if (!subset) {
			res = a;
		} 
	}

	for (n = conds->h, m = results->h; n && m; n = n->next, m = m->next) {
		stmt *cond = stmt_dup(n->data);
		stmt *result = stmt_dup(m->data);

		if (!(result = check_types(sql, restype, result, type_equal))) {
			list_destroy(conds);
			list_destroy(results);
			stmt_destroy(res);
			return NULL;
		}
		res = sql_Nop_(sql, "ifthenelse", cond, result, res, NULL);
	}
	list_destroy(conds);
	list_destroy(results);
	return res;
}

static stmt *
sql_case_exp(mvc *sql, scope *scp, symbol *se, group *grp, stmt *subset, int f)
{
	dlist *l = se->data.lval;

	if (se->token == SQL_COALESCE) {
		symbol *opt_else = l->t->data.sym;

		return sql_case(sql, scp, se->token, NULL, l, opt_else, grp, subset, f);
	} else if (se->token == SQL_NULLIF) {
		return sql_case(sql, scp, se->token, NULL, l, NULL, grp, subset, f);
	} else if (l->h->type == type_list) {
		dlist *when_search_list = l->h->data.lval;
		symbol *opt_else = l->h->next->data.sym;

		return sql_case(sql, scp, SQL_CASE, NULL, when_search_list, opt_else, grp, subset, f);
	} else {
		symbol *scalar_exp = l->h->data.sym;
		dlist *when_value_list = l->h->next->data.lval;
		symbol *opt_else = l->h->next->next->data.sym;

		return sql_case(sql, scp, SQL_CASE, scalar_exp, when_value_list, opt_else, grp, subset, f);
	}
}

static stmt *
sql_cast(mvc *sql, scope *scp, symbol *se, group *grp, stmt *subset, int f)
{

	dlist *dl = se->data.lval;
	symbol *s = dl->h->data.sym;
	sql_subtype *tpe = &dl->h->next->data.typeval;
	exp_kind ek = {type_value, card_column, FALSE};
	stmt *l = sql_value_exp(sql, scp, s, grp, subset, f, ek);

	if (!l)
		return NULL;
	/* strings may need too be truncated */
	if (tpe ->type ->localtype == TYPE_str) { 
		if (tpe->digits > 0) {
			sql_subtype *st = tail_type(l);
			sql_subtype *it = sql_bind_localtype("int");
			sql_subfunc *c = sql_bind_func(sql->session->schema, "truncate", st, it);
			if (c)
				l = stmt_binop(l, stmt_atom_int(tpe->digits), c);
		}
	}
	if (l) {
		char *ltpe = tail_type(l)?tail_type(l)->type->sqlname:"unknown";

		l = check_types(sql, tpe, l, type_cast);
		if (!l) {
			/* we overwrite the error here */
			sql->session->status = 0;
			sql->errstr[0] = 0;
			return sql_error(sql, 02, "CAST: cannot cast type '%s' to type '%s'", ltpe, tpe->type->sqlname );
		}
	}
	return l;
}

stmt *
sql_Nop_(mvc *sql, char *fname, stmt *a1, stmt *a2, stmt *a3, stmt *a4)
{
	list *sl = create_stmt_list();
	list *tl = list_create(NULL);
	sql_subfunc *f = NULL;

	list_append(sl, a1);
	list_append(tl, tail_type(a1));
	list_append(sl, a2);
	list_append(tl, tail_type(a2));
	list_append(sl, a3);
	list_append(tl, tail_type(a3));
	if (a4) {
		list_append(sl, a4);
		list_append(tl, tail_type(a4));
	}

	f = sql_bind_func_(sql->session->schema, fname, tl);
	list_destroy(tl);
	if (f)
		return stmt_Nop(stmt_list(sl), f);
	return sql_error(sql, 02, "SELECT: no such operator '%s'", fname);
}

static stmt *
sql_Nop(mvc *sql, scope *scp, symbol *se, group *grp, stmt *subset, int fs)
{
	int nr_args = 0;
	dnode *l = se->data.lval->h;
	dnode *ops = l->next->data.lval->h;
	list *sl = create_stmt_list();
	list *tl = list_create(NULL);
	sql_subfunc *f = NULL;
	sql_subtype *obj_type = NULL;
	char *fname = qname_fname(l->data.lval); 
	char *sname = qname_schema(l->data.lval);
	sql_schema *s = sql->session->schema;
	exp_kind ek = {type_value, card_column, FALSE};

	for (; ops; ops = ops->next, nr_args++) {
		stmt *op = sql_value_exp(sql, scp, ops->data.sym, grp, subset, fs, ek);
		sql_subtype *tpe;

		if (!op) {
			list_destroy(sl);
			return NULL;
		}
		list_append(sl, op);
		tpe = tail_type(op);
		if (!nr_args)
			obj_type = tpe;
		list_append(tl, tpe);
	}
	if (sname) 
		s = mvc_bind_schema(sql, sname);
	f = sql_bind_func_(s, fname, tl);
	list_destroy(tl);
	if (f) {
		return stmt_Nop(stmt_list(sl), f);
	} else if ((f = sql_bind_member(s, fname, obj_type, nr_args)) != NULL ||
		   (f = sql_find_func(s, fname, nr_args)) != NULL) {
		node *n, *m;
		list *nsl = create_stmt_list();

		for (n = sl->h, m = f->func->ops->h; n && m; 
				n = n->next, m = m->next) {
			sql_arg *a = m->data;
			stmt *op = stmt_dup(n->data);

			op = check_types(sql, &a->type, op, type_equal);
			if (!op) {
				list_destroy(nsl);
				nsl = NULL;
				break;
			}
			list_append(nsl, op);
		}
		if (nsl) {
			list_destroy(sl);
			return stmt_Nop(stmt_list(nsl), f);
		}
	}
	list_destroy(sl);
	return sql_error(sql, 02, "SELECT: no such operator '%s'", fname);
}

stmt *
sql_binop_(mvc *sql, scope *scp, sql_schema *s, char *fname, stmt *ls, stmt *rs)
{
	stmt *res = NULL;
	sql_subtype *t1, *t2;
	sql_subfunc *f = NULL;

	t1 = tail_type(ls);
	t2 = tail_type(rs);

	if (!s)
		s = sql->session->schema;
	/* input from different tables requires an extra cross-product! */
	if (scp && ls->nrcols > 0 && rs->nrcols > 0 && ls->h != rs->h) {
		ls = stmt_join(scope_find_pivot(scp, ls->h), ls, cmp_equal);
		rs = stmt_join(scope_find_pivot(scp, rs->h), rs, cmp_equal);
	}
	f = sql_bind_func(s, fname, t1, t2);
	if (!f && is_commutative(fname)) {
		f = sql_bind_func(s, fname, t2, t1);
		if (f) {
			sql_subtype *tmp = t1;
			t1 = t2;	
			t2 = tmp;
			res = ls;		
			ls = rs;
			rs = res;
		}
	}
	if (f) {
		if (f->func->res.scale == SCALE_FIX) {
			ls = fix_scale(sql, t2, ls, 0, 0);
			rs = fix_scale(sql, t1, rs, 0, 0);
		} else if (f->func->res.scale == SCALE_SUB) {
			ls = scale_algebra(sql, f, ls, rs);
		} else if (f->func->res.scale == SCALE_ADD) {
			ls = sum_scales(sql, f, ls, rs);
		} else if (f->func->res.scale == DIGITS_ADD) {
			f->res.digits = t1->digits + t2->digits;
		}
		return stmt_binop(ls, rs, f);
	} else {
		int digits = t1->digits + t2->digits;
		stmt *ols = stmt_dup(ls);
		stmt *ors = stmt_dup(rs);

		/* try finding function based on first argument */
		if ((f = sql_bind_member(s, fname, t1, 2)) != NULL) {
			node *m = f->func->ops->h;
			sql_arg *a = m->data;

			ls = check_types(sql, &a->type, ls, type_equal);
			a = m->next->data;
			rs = check_types(sql, &a->type, rs, type_equal);
			if (ls && rs) {
				stmt_destroy(ols);
				stmt_destroy(ors);
				return stmt_binop(ls, rs, f);
			}
		}
		/* reset error */
		sql->session->status = 0;
		sql->errstr[0] = '\0';

		if (ls)
			stmt_destroy(ls);
		if (rs)
			stmt_destroy(rs);
		ls = ols;
		rs = ors;
		ols = stmt_dup(ls);
		ors = stmt_dup(rs);
		/* try finding function based on both arguments */
		if (convert_types(sql, &ls, &rs, 1, type_equal) >= 0) {
			/* try operators */
			t1 = tail_type(ls);
			t2 = tail_type(rs);
			f = sql_bind_func(s, fname, t1, t2);
			if (f) {
				if (f->func->res.scale == SCALE_FIX) {
					ls = fix_scale(sql, t2, ls, 0, 0);
					rs = fix_scale(sql, t1, rs, 0, 0);
				} else if (f->func->res.scale == SCALE_SUB) {
					ls = scale_algebra(sql, f, ls, rs);
				} else if (f->func->res.scale == SCALE_ADD) {
					ls = sum_scales(sql, f, ls, rs);
				} else if (f->func->res.scale == DIGITS_ADD) {
					f->res.digits = digits;
				}
				stmt_destroy(ols);
				stmt_destroy(ors);
				return stmt_binop(ls, rs, f);
			}
		}
		/* reset error */
		sql->session->status = 0;
		sql->errstr[0] = '\0';

		if (ls)
			stmt_destroy(ls);
		if (rs)
			stmt_destroy(rs);
		ls = ols;
		rs = ors;
		/* everything failed, fall back to bind on function name only */
		if ((f = sql_find_func(s, fname, 2)) != NULL) {
			node *m = f->func->ops->h;
			sql_arg *a = m->data;

			ls = check_types(sql, &a->type, ls, type_equal);
			a = m->next->data;
			rs = check_types(sql, &a->type, rs, type_equal);
			if (ls && rs) 
				return stmt_binop(ls, rs, f);
		}
	}
	if (rs && ls)
		res = sql_error(sql, 02, "SELECT: no such binary operator '%s(%s,%s)'", fname, tail_type(ls)->type->sqlname, tail_type(rs)->type->sqlname);
	cond_stmt_destroy(ls);
	cond_stmt_destroy(rs);
	return res;
}

stmt *
flatten_outerrefs( mvc *sql, scope *scp, stmt *ls, stmt **R, stmt *subset, int f ) 
{
	stmt *rs = *R;
	node *o = ls->op1.lval->h;
	stmt *oref = stmt_dup(o->next->data);
	stmt *sqa = stmt_dup(o->data);
	stmt *cmp = NULL;
	stmt *h;
			
	(void)scp;
	(void)f;
	/* for now assume single outer ref ! */
	if (list_length(ls->op1.lval) > 2 || !oref->t) {
		stmt_destroy(oref);
		stmt_destroy(sqa);
		stmt_destroy(ls);
		stmt_destroy(rs);
		return sql_error(sql, 02, "SELECT: too many outer references");
	}
	cmp = stmt_join(stmt_reverse(oref), sqa, cmp_equal);

	/* need to fix the cmp head */
	h = stmt_dup(cmp->h->t);
	stmt_destroy(cmp->h);
	cmp->h = h;

	cmp = stmt_join(find_pivot(subset, cmp->h), cmp, cmp_equal);
	/* it can happen that the subquery reduces the outer
	 * refs, so we need to semijoin here 
	 */
	*R = rs = stmt_semijoin(rs, stmt_dup(cmp));
	stmt_destroy(ls);
	ls = cmp;
	return ls;
}

static stmt *
sql_binop(mvc *sql, scope *scp, symbol *se, group *grp, stmt *subset, int f)
{
	dnode *l = se->data.lval->h;
	stmt *ls, *rs;
	char *fname = qname_fname(l->data.lval); 
	char *sname = qname_schema(l->data.lval);
	sql_schema *s = sql->session->schema;
	exp_kind ek = {type_value, card_column, FALSE};

 	ls = sql_value_exp(sql, scp, l->next->data.sym, grp, subset, f, ek);
	rs = sql_value_exp(sql, scp, l->next->next->data.sym, grp, subset, f, ek);
	if (!ls || !rs) {
		if (ls)
			stmt_destroy(ls);
		if (rs)
			stmt_destroy(rs);
		return NULL;
	}

	/* do we have subquery results ? */
	if (ls->type == st_list) {
		/* with outer references ? */
		if (list_length(ls->op1.lval) > 1) {
			ls = flatten_outerrefs(sql, scp, ls, &rs, subset, f);
		} else {
			stmt *old = ls;
			ls = stmt_dup(ls->op1.lval->h->data);
			stmt_destroy(old);
		}
	}
	if (rs->type == st_list) {
		/* with outer references ? */
		if (list_length(rs->op1.lval) > 1) {
			rs = flatten_outerrefs(sql, scp, rs, &ls, subset, f);
		} else {
			stmt *old = rs;
			rs = stmt_dup(rs->op1.lval->h->data);
			stmt_destroy(old);
		}
	}

	if (sname) 
		s = mvc_bind_schema(sql, sname);
	return sql_binop_(sql, scp, s, fname, ls, rs);
}

static stmt *
sql_op(mvc *sql, symbol *se)
{
	dnode *l = se->data.lval->h;
	sql_subfunc *f = NULL;
	char *fname = qname_fname(l->data.lval); 
	char *sname = qname_schema(l->data.lval);
	sql_schema *s = sql->session->schema;

	if (sname) 
		s = mvc_bind_schema(sql, sname);
	f = sql_bind_func(s, fname, NULL, NULL);
	if (f) {
		return stmt_op(f);
	} else {
		return sql_error(sql, 02, 
			"SELECT: no such operator '%s()'", fname);
	}
	return NULL;
}

stmt *
sql_unop_(mvc *sql, sql_schema *s, char *fname, stmt *rs)
{
	sql_subtype *rt = NULL;
	sql_subfunc *f = NULL;

	if (!s)
		s = sql->session->schema;
	rt = tail_type(rs);
	f = sql_bind_func(s, fname, rt, NULL);
	/* try to find the function without a type, and convert
	 * the value to the type needed by this function!
	 */
	if (!f && (f = sql_find_func(s, fname, 1)) != NULL) {
		sql_arg *a = f->func->ops->h->data;

		rs = check_types(sql, &a->type, rs, type_equal);
		if (!rs) {
			sql_subfunc_destroy(f);
			f = NULL;
		}
	}
	if (f) {
		if (f->func->res.scale == INOUT) {
			f->res.digits = rt->digits;
			f->res.scale = rt->scale;
		}
		return stmt_unop(rs, f);
	} else if (rs) {
		char *type = tail_type(rs)->type->sqlname;

		stmt_destroy(rs);
		return sql_error(sql, 02, "SELECT: no such unary operator '%s(%s)'", fname, type);
	}
	return NULL;
}

static stmt *
sql_unop(mvc *sql, scope *scp, symbol *se, group *grp, stmt *subset, int fs)
{
	dnode *l = se->data.lval->h;
	char *fname = qname_fname(l->data.lval); 
	char *sname = qname_schema(l->data.lval);
	exp_kind ek = {type_value, card_column, FALSE};
	stmt *rs = sql_value_exp(sql, scp, l->next->data.sym, grp, subset, fs, ek);
	sql_schema *s = sql->session->schema;

	if (!rs)
		return NULL;
	if (sname) 
		s = mvc_bind_schema(sql, sname);
	return sql_unop_(sql, s, fname, rs);
}

static stmt *
sql_aggrop(mvc *sql, scope *scp, symbol *se, group *grp, stmt *subset, int f)
{
	dlist *l = se->data.lval;
	sql_subaggr *a = NULL;
	int distinct = l->h->next->data.ival;
	stmt *s = NULL;
	char *aggrstr = l->h->data.sval; 
	int remove_nils = 0; 
	sql_schema *schema = sql->session->schema;

	if (f == sql_where) 
		return sql_error(sql, 02, "%s: not allowed in WHERE clause", toUpper(alloca(strlen(aggrstr) + 1), aggrstr));
	
	if (!l->h->next->next->data.sym) {	/* count(*) case */
		cvar *cv;

		if (strcmp(aggrstr, "count") != 0) {
			return sql_error(sql, 02, "%s: unable to perform '%s(*)'", toUpper(alloca(strlen(aggrstr) + 1), aggrstr), aggrstr);
		}
		if (grp) {
			a = sql_bind_aggr(schema, aggrstr, NULL);
			return stmt_aggr(stmt_dup(grp->grp), grp_dup(grp), a, 1);
		}
		cv = scope_first_column(scp);
		if (cv && subset) {
			stmt *foundsubset = find_pivot(subset, cv->s->h);

			assert(foundsubset);
			if (!foundsubset) {
				return sql_error(sql, 02, "%s: no subset for column '%s'", toUpper(alloca(strlen(aggrstr) + 1), aggrstr), cv->cname);
			}
			s = foundsubset;
			if (s && distinct) {
				s = stmt_join(foundsubset, stmt_dup(cv->s), cmp_equal);
				s = stmt_unique(s, NULL);
			}
			a = sql_bind_aggr(schema, aggrstr, NULL);
			return stmt_aggr(stmt_alias(s,NULL,_strdup("")),NULL,a,1);
		} else if (!cv) { /* count(*) without from */
			/* if we have a where (boolean only) */
			if (!(s = scope_bind(scp, NULL, "row"))) 
				return stmt_atom_int(1);
			stmt_destroy(s);
			s = stmt_dup(subset);
		}
	} else {
		exp_kind ek = {type_value, card_column, FALSE};

		/* use cnt as nils shouldn't be counted */
		if (strcmp(aggrstr, "count") == 0) {
			aggrstr = "count_no_nil";
		} else {
			remove_nils = 1;
		}
		/* the values which are aggregated together, no grp should
		 * be given there to optain the values */
		s = sql_value_exp(sql, scp, l->h->next->next->data.sym, /*grp */ NULL, subset, f, ek);
		if (s->nrcols <= 0 && subset) /* single value */
			s = stmt_const(first_subset(subset), s);
	}

	if (s && distinct) {
		s = stmt_unique(s, grp_dup(grp));
	}
	if (!s)
		return NULL;
	a = sql_bind_aggr(schema, aggrstr, tail_type(s));
	if (a) {
		/* type may have changed, ie. need to 
			fix_scale (avg(dec(sht)) -> double */
		sql_subtype *t = tail_type(s);

		/* inconsistent sql requires NULL != NULL, ie unknown
		 * but also NULL means no values, which means 'ignore'
		 *
		 * so here we need to ignore NULLs
		 */
		if (remove_nils && stmt_has_null(s)) {
			sql_subtype *t = tail_type(s);
			stmt *n = stmt_atom(atom_general(t, NULL, 0));
			s = stmt_select2(s, n, stmt_dup(n), 0);
		}
		return fix_scale(sql, t, stmt_aggr(s, grp_dup(grp), a, 1), 1, (t->type->scale == SCALE_FIX));
	} else {
		char *type = tail_type(s)->type->sqlname;

		stmt_destroy(s);
		return sql_error(sql, 02, "%s: no such operator '%s(%s)'", toUpper(alloca(strlen(aggrstr) + 1), aggrstr), aggrstr, type);
	}
	return NULL;
}

static group *
query_groupby_inner(mvc *sql, scope *scp, stmt *c, stmt *subset, group *cur)
{
	stmt *s = find_pivot(subset, c->h);

	(void) scp;		/* Stefan: unused!? */

	if (s) {
		stmt *j = stmt_join(s, c, cmp_equal);

		cur = grp_create(j, cur, c);
	}

	if (!cur) {
		char *cn = column_name(c);

		(void) sql_error(sql, 02, "GROUP BY: no subset for column '%s'", cn);
		_DELETE(cn);
		return NULL;
	}
	return cur;
}

/* some users like to use aliases allready in the groupby */
stmt *
sql_selection_ref(mvc *sql, scope *scp, symbol *grp, dlist *selection, stmt *subset)
{
	dnode *n;
	dlist *gl = grp->data.lval;
	char *name = NULL;
	exp_kind ek = {type_value, card_column, FALSE};

	if (dlist_length(gl) > 1)
		return NULL;
	if (!selection)
		return NULL;

	name = gl->h->data.sval;
	for (n = selection->h; n; n = n->next) {
		/* we only look for columns */
		if (n->data.sym->token == SQL_COLUMN) {
			dlist *l = n->data.sym->data.lval;
			/* AS name */ 
			if (l->h->next->data.sval &&
			    strcmp(l->h->next->data.sval, name) == 0){
				return sql_value_exp(sql, scp, l->h->data.sym, NULL, subset, sql_sel, ek);
			}
		}
	}
	return NULL;
}

static group *
query_groupby(mvc *sql, scope *scp, symbol *groupby, stmt *subset, dlist *selection)
{
	group *cur = NULL;
	dnode *o = groupby->data.lval->h;

	for (; o; o = o->next) {
		symbol *grp = o->data.sym;
		stmt *c = sql_column_ref(sql, scp, grp);

		if (!c) {
			/* reset error */
			sql->session->status = 0;
			sql->errstr[0] = '\0';

			c = sql_selection_ref(sql, scp, grp, selection, subset);
			if (c) {
				cur = grp_create(c, cur, NULL);
				continue;
			}
		} 
		if (!c) {
			if (cur)
				grp_destroy(cur);
			return NULL;
		}
		cur = query_groupby_inner(sql, scp, c, subset, cur);
	}
	return cur;
}

/*
   select column_1, column_2 from x order by column_1, column_2;

   As SQL-3 dropped support for order by number (column position in result 
   table) so we also do not support it. Unfortunately SQL-3 added new crap,
   order by 'expression', where expression should match a result column 
   expression. We only support single column name expressions 
	(else just use as bla and order by bla!).
   SQL-3 supports ordering on columns not in the result table, 
   we do support that if the column is a direct base column.
 */
static stmt *
orderby_column_ref(mvc *sql, symbol *column_r, stmt *s)
{
	dlist *l = column_r->data.lval;

	assert(column_r->token == SQL_COLUMN && column_r->type == type_list);

	if (dlist_length(l) == 1) {
		char *name = l->h->data.sval;
		node *n;

		for (n = s->op1.lval->h; n; n = n->next) {
			stmt *t = n->data;
			char *cn = column_name(t);

			if (strcmp(cn, name) == 0) {
				_DELETE(cn);
				return stmt_dup(t);
			}
			_DELETE(cn);
		}
		return sql_error(sql, 02, "ORDER BY: no such column '%s'", name);
	}
	if (dlist_length(l) == 2) {
		char *tname = l->h->data.sval;
		char *name = l->h->next->data.sval;
		node *n;

		for (n = s->op1.lval->h; n; n = n->next) {
			stmt *t = n->data;
			char *tn = table_name(t);
			char *cn = column_name(t);

			if (tn && strcmp(tn, tname) == 0 && strcmp(cn, name) == 0) {
				if (tn)
					_DELETE(tn);
				_DELETE(cn);
				return stmt_dup(t);
			}
			if (tn)
				_DELETE(tn);
			_DELETE(cn);
		}
		return sql_error(sql, 02, "ORDER BY: no such column '%s'", name);
	}
	return sql_error(sql, 02, "ORDER BY: absolute column names not supported");
}


/* find selection expressions matching the order by column expression */

/* first limit to simple columns only */
static stmt *
orderby_column_exp(mvc *sql, symbol *column_r, stmt *s)
{
	dlist *l = column_r->data.lval;

	assert(column_r->token == SQL_COLUMN && column_r->type == type_list);

	if (dlist_length(l) == 1) {
		char *name = l->h->data.sval;
		node *n;

		for (n = s->op1.lval->h; n; n = n->next) {
			stmt *t = n->data;

			if (t->type == st_alias) {
				char *cn = column_name(t->op1.stval);

				if (strcmp(cn, name) == 0) {
					_DELETE(cn);
					return stmt_dup(t);
				}
				_DELETE(cn);
			}
		}
		return sql_error(sql, 02, "ORDER BY: no such column '%s'", name);
	}
	if (dlist_length(l) == 2) {
		char *tname = l->h->data.sval;
		char *name = l->h->next->data.sval;
		node *n;

		for (n = s->op1.lval->h; n; n = n->next) {
			stmt *t = n->data;

			if (t->type == st_alias) {
				char *tn = table_name(t->op1.stval);
				char *cn = column_name(t->op1.stval);

				if (tn && strcmp(tn, tname) == 0 && strcmp(cn, name) == 0) {
					if (tn)
						_DELETE(tn);
					_DELETE(cn);
					return stmt_dup(t);
				}
				if (tn)
					_DELETE(tn);
				_DELETE(cn);
			}
		}
		return sql_error(sql, 02, "ORDER BY: no such column '%s'", name);
	}
	return sql_error(sql, 02, "ORDER BY: absolute column names not supported");
}

static stmt *
query_orderby(mvc *sql, scope *scp, symbol *orderby, stmt *sel, stmt *subset, group *grp)
{
	stmt *cur = NULL;
	dnode *o = orderby->data.lval->h;

	/* first sort the groups */
	if (!sel && grp) 
		cur = stmt_order(stmt_dup(grp->grp), 1);
	while (o) {
		symbol *order = o->data.sym;

		if (order->token == SQL_COLUMN) {
			symbol *col = order->data.lval->h->data.sym;
			int direction = order->data.lval->h->next->data.ival;
			stmt *sc = NULL;

			if (sel)
				sc = orderby_column_ref(sql, col, sel);
			if (sel && !sc) {
				/* reset error */
				sql->session->status = 0;
				sql->errstr[0] = '\0';

				sc = orderby_column_exp(sql, col, sel);
			}

			/* fall back to column references, ie those not in
			   the selection result */
			if (!sc && (!sel || !grp)) {
				/* reset error */
				sql->session->status = 0;
				sql->errstr[0] = '\0';

				sc = sql_column_ref(sql, scp, col);
				if (sc) {
					stmt *t = find_pivot(subset, sc->h);
					if (t) {
						sc = stmt_join(t, sc, cmp_equal);
					} else {
						stmt_destroy(sc); 
						sc = NULL;
					}
				}
			}

			if (sc) {
				if (cur)
					cur = stmt_reorder(cur, sc, direction);
				else
					cur = stmt_order(sc, direction);
			} else {
				return NULL;
			}
		} else {
			return sql_error(sql, 02, "ORDER BY: not a column");
		}
		o = o->next;
	}
	return cur;
}

/* window functions */
static stmt *
sql_rankop(mvc *sql, scope *scp, symbol *se, group *grp, stmt *subset, int f)
{
	dlist *l = se->data.lval;
	symbol *window_function = l->h->data.sym;
	dlist *window_specification = l->h->next->data.lval;
	char *aggrstr = NULL;
	stmt *s = NULL;
	
	if (window_function->token == SQL_RANK) {
		aggrstr = window_function->data.sval;
	} else { /* window aggr function */
		aggrstr  = window_function->data.lval->h->data.sval;
	}

	if (grp && window_specification->h->data.sym) 
		return sql_error(sql, 02, "OVER: not supported in combination with GROUP BY");

	if (f == sql_where) 
		return sql_error(sql, 02, "%s: not allowed in WHERE clause", toUpper(alloca(strlen(aggrstr) + 1), aggrstr));

	/* Partition By */
	if (window_specification->h->data.sym) {
		grp = query_groupby(sql, scp, window_specification->h->data.sym, subset, NULL /* cannot use (selection) column references, as this result is a selection column */ );
	}
	/* Order By */
	if (window_specification->h->next->data.sym) {
		s = query_orderby(sql, scp, window_specification->h->next->data.sym, NULL, subset, grp);
	} else if (grp) { /* order on group by result */
		s = stmt_order(stmt_dup(grp->grp), 1);
	}
	if (!s && subset) 
		s = first_subset(subset);
	else if (!s)
		return s;
	if (grp) {
		stmt *map = stmt_dup(grp->grp);
		stmt *ext = stmt_dup(grp->ext);
		return sql_Nop_(sql, aggrstr, s, map, ext, NULL);
	} else if (aggrstr) {
		return sql_unop_(sql, NULL, aggrstr, s);
	} else {
		assert(0);
		s = stmt_mark(stmt_reverse(s), 0);
	}
	return s;
}

static stmt *
sql_column_value(mvc *sql, scope *scp, symbol *se, group *grp, stmt *subset, int f)
{
	stmt *s = sql_column_ref(sql, scp, se);

	if (s && s->h && subset && f) {
		stmt *col = s;
		stmt *foundsubset = find_pivot(subset, s->h);

		if (!foundsubset)
			return sql_error(sql, 02, "SELECT: no subset found for value expression");

		s = stmt_join(foundsubset, s, cmp_equal);
		if (s && grp && f && s->type != st_aggr && grp->cols) {
			if (grp_find_groupby_col(grp, col)) {
				s = stmt_join(stmt_dup(grp->ext), s, cmp_equal);
			} else {
				char *name = column_name(col);

				stmt_destroy(s);
				if (name)
					return sql_error(sql, 02, "SELECT: cannot use non GROUP BY column '%s' in query results without an aggregate function", name);
				else
					return sql_error(sql, 02, "SELECT: cannot use non GROUP BY column in query results without an aggregate function");
			}
		} else if (s && grp && f && s->type != st_aggr) {
			s = stmt_join(stmt_dup(grp->ext), s, cmp_equal);
		}
	}
	return s;
}

stmt *
sql_table_exp(mvc *sql, scope *scp, symbol *sym ) 
{
	stmt *ls = flat_subquery(sql, sym);

	(void)scp;
	assert(scp == NULL);
	if (!ls)
		return ls;

	if (ls->type == st_list) { 
		if (ls->nrcols <= 0) { /* single row */
			list *l = create_stmt_list();
			node *n;
			for (n = ls->op1.lval->h; n; n = n->next) {
				stmt *nsq = stmt_dup(n->data);
				char *cname = column_name(nsq);
				char *tname = table_name(nsq);
				stmt *temp = stmt_temp(tail_type(nsq));

				nsq = stmt_append(temp, nsq);
				nsq = stmt_alias(nsq, tname, cname);
				list_append(l, nsq);
			}
			stmt_destroy(ls);
			ls = stmt_list(l);
		}
	} else if (ls->nrcols <= 0) { /* single row */
		char *cname = column_name(ls);
		char *tname = table_name(ls);
		stmt *temp = stmt_temp(tail_type(ls));
		ls = stmt_append(temp, ls);
		ls = stmt_alias(ls, tname, cname);
	}
	return stmt_table(ls, 1);
}

stmt *
stmt_seq_next(mvc *sql, char *sname, char *seqname)
{
	stmt *schema = stmt_atom_string(sname);
	stmt *seq = stmt_atom_string(seqname);
	return sql_binop_(sql, NULL, NULL, "next_value_for", schema, seq);
}


stmt *
sql_value_exp(mvc *sql, scope *scp, symbol *se, group *grp, stmt *subset, int f, exp_kind ek)
{
	if (!se)
		return NULL;

 	if (THRhighwater())
		return sql_error(sql, 10, "SELECT: too many nested operators");

	switch (se->token) {
	case SQL_OP:
		return sql_op(sql, se);
	case SQL_UNOP:
		return sql_unop(sql, scp, se, grp, subset, f);
	case SQL_BINOP:
		return sql_binop(sql, scp, se, grp, subset, f);
	case SQL_NOP:
		return sql_Nop(sql, scp, se, grp, subset, f);
	case SQL_AGGR:
		return sql_aggrop(sql, scp, se, grp, subset, f);
	case SQL_RANK:
		return sql_rankop(sql, scp, se, grp, subset, f);
	case SQL_COLUMN:
		return sql_column_value(sql, scp, se, grp, subset, f);
	case SQL_NAME:
		return sql_var_ref(sql, se->data.sval, 1);
	case SQL_SELECT:{
		stmt *s = scope_subquery(sql, scp, se, ek);

		/* make a single (column) out of a subquery,
		   we do it here instead of all places where the
		   subquery result is used
		 */
		if (s && s->type == st_list) {
			/* single value (no outer references) */
		 	if (list_length(s->op1.lval) == 1) {
				stmt *t = stmt_dup(s->op1.lval->h->data);
				stmt_destroy(s);
				s = t;

				/* if we got a unrelated column, we need 
				   a dynamic check for a single valued result.
				*/
				if (s->nrcols != 0 && s->aggr != 1 &&
				   (ek.card == card_value || 
				    ek.card == card_column)) {
					/* Here we obtain a single value
					   which is NULL incase of an empty
					   result or the single result of
					   the sub query. We raise an exception
					   incase the sub query returned more
					   results.
					 */
					
					sql_subaggr *zero_or_one = sql_bind_aggr(sql->session->schema, "zero_or_one", tail_type(s));
					assert(zero_or_one);
					s = stmt_aggr(s, NULL, zero_or_one, 1);
					/* we aggregated in the subquery not 
					   in the outer */
					s->aggr = 0;
				}
			} else if (f >= sql_sel) { /* normalize subquery */
				/* flatten subqueries */
				stmt *h, *v = stmt_dup(s->op1.lval->h->data);
				stmt *o = stmt_dup(s->op1.lval->h->next->data);
				stmt_destroy(s);
				s = stmt_join(stmt_reverse(o), v, cmp_equal);
				h = stmt_dup(s->h->t);
				stmt_destroy(s->h);
				s->h = h;
				if (f >= sql_sel)   /* make sure we don't lose rows */
					s = stmt_outerjoin(stmt_mirror(first_subset(subset)), s, cmp_equal);
			}
		}

		return s;
	}
	case SQL_TABLE:  /* turn a subquery into a tabular result */
	{
		return sql_table_exp(sql, scp, se->data.sym);
	}
		break;
	case SQL_PARAMETER:{
		if (sql->mode != m_prepare) 
			return sql_error(sql, 02, "SELECT: parameters ('?') not allowed in normal queries, use PREPARE");
		return stmt_varnr(se->data.ival, NULL);
	}
	case SQL_NULL:
		return stmt_atom(atom_general(sql_bind_localtype("str"), NULL, 0));
	case SQL_ATOM:{
		AtomNode *an = (AtomNode *) se;

		if (!an || !an->a) {
			return stmt_atom(atom_general(sql_bind_localtype("str"), NULL, 0));
		} else {
			return stmt_atom(atom_dup(an->a));
		}
	}
		break;
	case SQL_NEXT:{
		char *seq = qname_table(se->data.lval);
		char *sname = qname_schema(se->data.lval);
		sql_schema *s = NULL;

		if (sname && !(s = mvc_bind_schema(sql, sname)))
			return sql_error(sql, 02, "NEXT VALUE FOR: no such schema '%s'", sname);
		if (!s)
			s = sql->session->schema;
		if (!find_sql_sequence(s, seq)) 
			return sql_error(sql, 02, "NEXT VALUE FOR: "
			                 "no such sequence '%s'.'%s'", s->base.name, seq);
		return stmt_seq_next(sql, _strdup(s->base.name), _strdup(seq) );
	}
		break;
	case SQL_CAST:
		return sql_cast(sql, scp, se, grp, subset, f);
	case SQL_CASE:
	case SQL_COALESCE:
	case SQL_NULLIF:
		return sql_case_exp(sql, scp, se, grp, subset, f);
	case SQL_XMLELEMENT:
	case SQL_XMLFOREST:
	case SQL_XMLCOMMENT:
	case SQL_XMLATTRIBUTE:
	case SQL_XMLCONCAT:
	case SQL_XMLDOCUMENT:
	case SQL_XMLPI:
	case SQL_XMLTEXT:
		return sql_xml(sql, scp, se, grp, subset, f, ek);
	default:
		return sql_logical_exp(sql, scp, se, grp, subset, f, ek);
	}
	return NULL;
}

/* turns a stmt set (or a set of stmt_sets) into a pivot table 
 * ie a table with a oid column for each base table.
 * A row of this pivot table expresses how the rows of the base tables
 * relate.
 */

stmt *
stmt2pivot(scope *scp, stmt *s)
{
	stmt *ptable = stmt_dup(scp->ptable);
	stmt *res = ptable;

	while (ptable_parent(ptable))
		ptable = ptable_parent(ptable);
	assert(!ptable_statements(ptable));
	ptable_statements(ptable) = s;
	res->nrcols = s->nrcols;
	return res;
}

static cvar *
find_on_column_name(tvar *t, char *name)
{
	node *m;

	for (m = t->columns->h; m; m = m->next) {
		cvar *rc = m->data;

		if (strcmp(name, rc->cname) == 0) 
			return rc;
	}
	return NULL;
}

static list *
join_on_column_name(tvar *tv, tvar *r, int all)
{
	list *res = list_create(NULL);
	node *n;

	for (n = tv->columns->h; n; n = n->next) {
		cvar *lc = n->data;
		cvar *rc = find_on_column_name(r, lc->cname);

		if (rc) {
			list_append(res, lc);
			list_append(res, rc);
		} else if (all) {
			list_destroy(res);
			return NULL;
		}
	}
	return res;
}

static stmt *
set2table( mvc *sql, scope *scp, stmt *s) 
{
	stmt *cur = NULL, *t = NULL;
	int pending = 0;
	node *n;

	for (n = scp->tables->h; n; n = n->next) {
		tvar *v = n->data;
		stmt *tmp = complex_find_subset(s, v->s);

		if (!tmp) {
			cvar *cv = v->columns->h->data;

			tmp = stmt_dup(cv->s);
			pending = 1;
			/* just add a select whole column */
			if (!cur) {
				cur = tmp;
				continue;
			}
		} else if (!cur) {
			cur = tmp;
			continue;
		}
		if (pending) {
			pending = 0;
			tmp = stmt_join(stmt_dup(cur), 
					stmt_reverse(tmp), cmp_all);
			s = sql_and(sql, scp, s, tmp, sql_where);
		} else if (tmp) {
			stmt_destroy(tmp);
		}
	}
			/* just add a select whole column */
	for (n = scp->outers->h; n; n = n->next) {
		stmt *o = n->data;
		stmt *tmp = complex_find_subset(s, o);

		if (!tmp) {
			tmp = stmt_column(stmt_const(stmt_dup(o), stmt_atom_int(0)), stmt_dup(o), NULL);
			pending = 1;
			if (!cur) {
				cur = tmp;
				continue;
			}
		} else if (!cur) {
			cur = tmp;
			continue;
		}
		if (pending) {
			pending = 0;
			tmp = stmt_join(stmt_dup(cur), 
					stmt_reverse(tmp), cmp_all);
			if (s)
				s = sql_and(sql, scp, s, tmp, sql_where);
			else
				s = stmt_set(tmp);
		} else if (tmp) {
			stmt_destroy(tmp);
		}
	}
	if (!cur)
		return s;
	if ((t = scope_bind(scp, NULL, "row")) != NULL && t->nrcols == 0) {
		t = stmt_join(stmt_dup(cur), stmt_reverse(t), cmp_all);
		s = sql_and(sql, scp, s, t, sql_where);
	}
	stmt_destroy(cur);
	return s;
}

static int 
cvar_cmp(cvar *c1, cvar *c2)
{
	return c1-c2;
}

static stmt *
sql_join_(mvc *sql, scope *scp, symbol *tab1, int natural, jt jointype, symbol *tab2, symbol *js)
{
	list *matching_columns = NULL;
	stmt *s = NULL, *subset = NULL;
	tvar *tv1, *tv2;

	tv1 = table_ref(sql, scp, tab1);
	tv2 = table_ref(sql, scp, tab2);

	if (!tv1 || !tv2)
		return NULL;

	if (tv1->tname && tv2->tname && strcmp(tv1->tname, tv2->tname) == 0) 
		return sql_error(sql, 02, "SELECT: '%s' on both sides of the JOIN expression;", tv1->tname);

	if (js && natural) 
		return sql_error(sql, 02, "SELECT: cannot have a NATURAL JOIN with a join specification (ON or USING);");
	if (!js && !natural) 
		return sql_error(sql, 02, "SELECT: must have NATURAL JOIN or a JOIN with a join specification (ON or USING);");

	if (js && js->token != SQL_USING) {	/* On sql_logical_exp */
		exp_kind ek = {type_value, card_relation, TRUE };
		s = sql_logical_exp(sql, scp, js, NULL, NULL, sql_where, ek);
	} else if (js) {	/* using */
		dnode *n = js->data.lval->h;

		matching_columns = list_create(NULL);
		s = stmt_reljoin_init();
		for (; n; n = n->next) {
			char *nm = n->data.sval;

			cvar *lc = find_on_column_name(tv1, nm);
			cvar *rc = find_on_column_name(tv2, nm);
			stmt *ls, *rs;

			if (!lc || !rc) {
				if (s)
					stmt_destroy(s);
				list_destroy(matching_columns);
				return sql_error(sql, 02, "JOIN: tables '%s' and '%s' do not have a matching column '%s'\n", tv1->tname, tv2->tname, nm);
			}
			ls = stmt_dup(lc->s);
			rs = stmt_dup(rc->s);
			if ((convert_types(sql, &ls, &rs, 1, type_equal) < 0)) {
				if (ls)
					stmt_destroy(ls);
				if (rs)
					stmt_destroy(rs);
				if (s)
					stmt_destroy(s);
				return NULL;
			}
			list_append(matching_columns, lc);
			list_append(matching_columns, rc);
			stmt_reljoin_fill(s, ls, rs);
		}
	} else {		/* ! js -> natural join */
		node *m;

		matching_columns = join_on_column_name(tv1, tv2, 0);

		if (!matching_columns || list_length(matching_columns) == 0) {
			if (matching_columns)
				list_destroy(matching_columns);
			return sql_error(sql, 02, "JOIN: no columns of tables '%s' and '%s' match", tv1->tname, tv2->tname);
		}

		s = stmt_reljoin_init();
		for (m = matching_columns->h; m; m = m->next->next) {
			cvar *lc = m->data;
			cvar *rc = m->next->data;
			stmt *ls, *rs;

			if (!lc || !rc) {
				cond_stmt_destroy(s);
				list_destroy(matching_columns);
				return NULL;
			}
			ls = stmt_dup(lc->s);
			rs = stmt_dup(rc->s);
			if (convert_types(sql, &ls, &rs, 1, type_equal) < 0) {
				cond_stmt_destroy(ls);
				cond_stmt_destroy(rs);
				cond_stmt_destroy(s);
				list_destroy(matching_columns);
				return NULL;
			}
			stmt_reljoin_fill(s, ls, rs);
		}
	}

	if (s && s->type != st_set && s->type != st_sets) 
		s = stmt_set(s);
	if (s && (s = set2table(sql, scp, s)) != NULL)
		s = stmt2pivot(scp, s);
	subset = s;
	if (subset) {
		list *l1;
		tvar *t = NULL;
		node *n;
		stmt *fs1 = find_pivot(subset, tv1->s);
		stmt *fs2 = find_pivot(subset, tv2->s);
		stmt *ld = NULL, *rd = NULL;

		if (!fs1 || !fs2) {
			cond_stmt_destroy(fs1);
			cond_stmt_destroy(fs2);
			list_destroy(matching_columns);
			if (!fs1) {
				return sql_error(sql, 02, "JOIN: subset '%s' not found", tv1->tname);
			} else if (!fs2) {
				return sql_error(sql, 02, "JOIN: subset '%s' not found", tv2->tname);
			} else {
				return sql_error(sql, 02, "JOIN: subsets '%s' and '%s' not found", tv1->tname, tv2->tname);
			}
		}

		t = tv1;
		if (jointype == jt_left || jointype == jt_full) {
			cvar *cs = t->columns->h->data;

			/* we need to add the missing oid's */
			ld = stmt_diff(stmt_dup(cs->s), stmt_reverse(stmt_dup(fs1)));
			ld = stmt_mark(stmt_reverse(ld), 0);
		}
		t = tv2;
		if (jointype == jt_right || jointype == jt_full) {
			cvar *cs = t->columns->h->data;

			/* we need to add the missing oid's */
			rd = stmt_diff(stmt_dup(cs->s), stmt_reverse(stmt_dup(fs2)));
			rd = stmt_mark(stmt_reverse(rd), 0);
		}
		l1 = create_stmt_list();
		t = tv1;
		for (n = t->columns->h; n; n = n->next) {
			cvar *cs = n->data;

			list_append(l1, stmt_join(stmt_dup(fs1), stmt_dup(cs->s), cmp_equal));
		}
		t = tv2;
		for (n = t->columns->h; n; n = n->next) {
			cvar *cs = n->data;

			list_append(l1, stmt_join(stmt_dup(fs2), stmt_dup(cs->s), cmp_equal));
		}
		cond_stmt_destroy(fs1);
		cond_stmt_destroy(fs2);
		if (jointype == jt_left || jointype == jt_full) {
			list *l2 = create_stmt_list();
			node *m = l1->h;

			t = tv1;
			for (n = t->columns->h; n; n = n->next, m = m->next) {
				cvar *cs = n->data;

				list_append(l2, stmt_append(stmt_dup(m->data), stmt_join(stmt_dup(ld), stmt_dup(cs->s), cmp_equal)));
			}
			t = tv2;
			for (n = t->columns->h; n; n = n->next, m = m->next) {
				cvar *cs = n->data;

				list_append(l2, stmt_append(stmt_dup(m->data), stmt_const(stmt_dup(ld), stmt_atom(atom_general(tail_type(cs->s), NULL, 0)))));
			}
			list_destroy(l1);
			l1 = l2;
		}
		if (jointype == jt_right || jointype == jt_full) {
			list *l2 = create_stmt_list();
			node *m = l1->h;

			t = tv1;
			for (n = t->columns->h; n; n = n->next, m = m->next) {
				cvar *cs = n->data;

				list_append(l2, stmt_append(stmt_dup(m->data), stmt_const(stmt_dup(rd), stmt_atom(atom_general(tail_type(cs->s), NULL, 0)))));
			}
			t = tv2;
			for (n = t->columns->h; n; n = n->next, m = m->next) {
				cvar *cs = n->data;

				list_append(l2, stmt_append(stmt_dup(m->data), stmt_join(stmt_dup(rd), stmt_dup(cs->s), cmp_equal)));
			}
			list_destroy(l1);
			l1 = l2;
		}
		if (matching_columns) {
			/* Natural join and join on columns list output the
			   join columns once.  
			   Natural join only outputs join columns.
			 */
			list *l2 = create_stmt_list();
			node *o = NULL, *m = l1->h, *rm;

			t = tv1;
			for (n = t->columns->h; n; n = n->next, m = m->next) 
				;
			rm = m;
			m = l1->h;
			for (n = t->columns->h; n; n = n->next, m = m->next) {
				cvar *lc = n->data;
				if ((o = list_find(matching_columns, lc, (fcmp)&cvar_cmp))) {
					stmt *ls, *rs;
					cvar *rc = o->next->data;
					node *p = rm;

					for (o = tv2->columns->h; o && o->data != rc; o = o->next, p = p->next) 
						;
					ls = stmt_dup(m->data);
					rs = stmt_dup(p->data);
					ls = sql_Nop_(sql, "ifthenelse", sql_unop_(sql, NULL, "isnull", ls), rs, stmt_dup(ls), NULL);
					ls = stmt_alias(ls, NULL, _strdup(lc->cname));
					list_append(l2, ls);
				}
			}
			if (js) {
				t = tv1;
				m = l1->h;
				for (n = t->columns->h; n; n = n->next, m = m->next) {
					cvar *cs = n->data;
					if (!(o = list_find(matching_columns, cs, (fcmp)&cvar_cmp))) 
						list_append(l2, stmt_dup(m->data));
				}
				t = tv2;
				for (n = t->columns->h; n; n = n->next, m = m->next) {
					cvar *cs = n->data;
					if (!(o = list_find(matching_columns, cs, (fcmp)&cvar_cmp))) 
						list_append(l2, stmt_dup(m->data));
				}
			}
			/* add no join columns */
			list_destroy(l1);
			l1 = l2;
			list_destroy(matching_columns);
		}
		cond_stmt_destroy(ld);
		cond_stmt_destroy(rd);
		s = stmt_list(l1);
	}
	if (subset)
		stmt_destroy(subset);
	return s;
}

static stmt *
sql_join(mvc *sql, scope *scp, symbol *q)
{
	dnode *n = q->data.lval->h;
	symbol *tab_ref1 = n->data.sym;
	int natural = n->next->data.ival;
	jt jointype = (jt) n->next->next->data.ival;
	symbol *tab_ref2 = n->next->next->next->data.sym;
	symbol *joinspec = n->next->next->next->next->data.sym;

	return sql_join_(sql, scp, tab_ref1, natural, jointype, tab_ref2, joinspec);
}

stmt *
distinct(stmt *s)
{
	node *n;
	group *grp = NULL;
	list *rl = create_stmt_list();
	stmt *ext = NULL;

	if (list_length(s->op1.lval) > 1) {
		for (n = s->op1.lval->h; n; n = n->next) {
			stmt *t = n->data;
	
			grp = grp_create(stmt_dup(t), grp, NULL);
		}
		ext = stmt_dup(grp->ext);
		if (grp)
			grp_destroy(grp);
	} else {
		stmt *t = s->op1.lval->h->data; 
		ext = stmt_mirror(stmt_unique(stmt_dup(t), NULL));
	}

	for (n = s->op1.lval->h; n; n = n->next) {
		stmt *t = n->data;

		list_append(rl, stmt_join(stmt_dup(ext), stmt_dup(t), cmp_equal));
	}

	stmt_destroy(ext);
	stmt_destroy(s);
	s = stmt_list(rl);
	return s;
}

static stmt *
sql_union(mvc *sql, tvar *tv1, tvar *tv2, dlist *cols )
{
	node *n, *m;
	list *stmts = create_stmt_list();

	if (!cols) {
		for (n = tv1->columns->h, m = tv2->columns->h; n && m; n = n->next, m = m->next) {
			cvar *lc = n->data;
			cvar *rc = m->data;
			stmt *rs = stmt_dup(rc->s);
			stmt *ls = stmt_dup(lc->s);

			if ((convert_types(sql, &ls, &rs, 1, type_set) < 0)) {
				if (ls)
					stmt_destroy(ls);
				if (rs)
					stmt_destroy(rs);
				list_destroy(stmts);
				return NULL;
			}

			/* insert single value into table */
			if (lc->s->key) {
				stmt *temp = stmt_temp(tail_type(ls));

				ls = stmt_append(temp, ls);
			}
			ls = stmt_append(ls, rs);
			/* the alias keeps the column name around */
			ls = stmt_alias(ls, NULL, _strdup(lc->cname));
			list_append(stmts, ls);
		}
		/* TODO cols length 0 see natural join
		   cols length > 0 see union join, join on name */
	}
	return stmt_list(stmts);
}

static stmt *
sql_except(mvc *sql, tvar *tv1, tvar *tv2, dlist *cols, int distinct )
{
	node *n, *m;

	list *stmts = create_stmt_list();
	if (!cols) {
		/*
		 * The multi column except is handled using group by's and
		 * group size counts on both sides of the except. We then
		 * return for each group of A with (A.count - B.count) > 0, 
		 * number of rows.
		 * 
		 * The problem with this approach is that the groups should
		 * have equal group identifiers. So we take the union of all
		 * columns before the group by.
		 */
		group *lgrp = NULL, *rgrp = NULL;
		stmt *s, *lm, *ld, *ls = NULL, *rs = NULL;
		sql_subaggr *a;

		for (n = tv1->columns->h; n; n = n->next) {
			cvar *lc = n->data;
			stmt *l = stmt_dup(lc->s);

			lgrp = grp_create(l, lgrp, NULL);
		}
		for (n = tv2->columns->h; n; n = n->next) {
			cvar *rc = n->data;
			stmt *r = stmt_dup(rc->s);

			rgrp = grp_create(r, rgrp, NULL);
		}
 		a = sql_bind_aggr(sql->session->schema, "count", NULL);
		ls = stmt_aggr(stmt_dup(lgrp->grp), grp_dup(lgrp), a, 1); 
		a = sql_dup_aggr(a);
		rs = stmt_aggr(stmt_dup(rgrp->grp), grp_dup(rgrp), a, 1); 

		/* now find the matching groups */
		s = stmt_reljoin_init();
		for (n = tv1->columns->h, m = tv2->columns->h; n && m; n = n->next, m = m->next) {
			cvar *lc = n->data;
			cvar *rc = m->data;
			stmt *l = stmt_dup(lc->s);
			stmt *r = stmt_dup(rc->s);

			if ((convert_types(sql, &l, &r, 1, type_set) < 0)) {
				if (l)
					stmt_destroy(l);
				if (r)
					stmt_destroy(r);
				if (lgrp)
					grp_destroy(lgrp);
				if (rgrp)
					grp_destroy(rgrp);
				list_destroy(stmts);
				return NULL;
			}
			l = stmt_join(stmt_dup(lgrp->ext), l, cmp_equal);
			r = stmt_join(stmt_dup(rgrp->ext), r, cmp_equal);
			stmt_reljoin_fill(s, l, r);
		}
		
		/* the join of the groups removed those in A but not in B,
		 * we need these later so keep these in 'ld' */
		ld = stmt_diff(stmt_dup(ls), stmt_dup(s));

		if (!distinct) {
			lm = stmt_reverse(stmt_mark_tail(stmt_dup(s),0));
			ls = stmt_join(stmt_dup(lm),ls,cmp_equal);
			rs = stmt_join(stmt_mark(s,0),rs,cmp_equal);

			s = sql_binop_(sql, NULL, NULL, "sql_sub", ls, rs);
			s = stmt_select(s, stmt_atom_int(0), cmp_gt);

			/* A ids */
			s = stmt_join(stmt_reverse(lm), s, cmp_equal);
			/* now we need to add the groups which weren't in B */
			s = stmt_union(ld,s);
			/* now we have gid,cnt, blowup to full groupsizes */
			s = stmt_gen_group(s);
		} else {
			stmt_destroy(s);
			s = ld;
		}
		s = stmt_mark_tail(s, 500); 
		/* from gid back to A id's */
		s = stmt_reverse(stmt_join(stmt_dup(lgrp->ext), s, cmp_equal));

		grp_destroy(lgrp);
		grp_destroy(rgrp);

		/* project columns of left hand expression */
		for (n = tv1->columns->h; n; n = n->next) {
			cvar *lc = n->data;
			stmt *ls = stmt_dup(lc->s);

			/* retain name via the stmt_alias */
			ls = stmt_join(stmt_dup(s), ls, cmp_equal);
			ls = stmt_alias(ls, NULL, _strdup(lc->cname));
			list_append(stmts, ls);
		}
		stmt_destroy(s);

		/* TODO cols length 0 see natural join
		   cols length > 0 see union join, join on name */
	}
	return stmt_list(stmts);
}

static stmt *
sql_intersect(mvc *sql, tvar *tv1, tvar *tv2, dlist *cols, int distinct )
{
	node *n, *m;
	list *stmts = create_stmt_list();

	if (!cols) {
		/*
		 * The multi column intersect is handled using group by's and
		 * group size counts on both sides of the intersect. We then
		 * return for each group of A with min(A.count,B.count), 
		 * number of rows.
		 * 
		 * The problem with this approach is that the groups should
		 * have equal group identifiers. So we take the union of all
		 * columns before the group by.
		 */
		group *lgrp = NULL, *rgrp = NULL;
		stmt *s, *lm, *ls = NULL, *rs = NULL;
		sql_subaggr *a;

		for (n = tv1->columns->h; n; n = n->next) {
			cvar *lc = n->data;
			stmt *l = stmt_dup(lc->s);

			lgrp = grp_create(l, lgrp, NULL);
		}
		for (n = tv2->columns->h; n; n = n->next) {
			cvar *rc = n->data;
			stmt *r = stmt_dup(rc->s);

			rgrp = grp_create(r, rgrp, NULL);
		}
 		a = sql_bind_aggr(sql->session->schema, "count", NULL);
		ls = stmt_aggr(stmt_dup(lgrp->grp), grp_dup(lgrp), a, 1); 
		a = sql_dup_aggr(a);
		rs = stmt_aggr(stmt_dup(rgrp->grp), grp_dup(rgrp), a, 1); 

		/* now find the matching groups */
		s = stmt_reljoin_init();
		for (n = tv1->columns->h, m = tv2->columns->h; n && m; n = n->next, m = m->next) {
			cvar *lc = n->data;
			cvar *rc = m->data;
			stmt *l = stmt_dup(lc->s);
			stmt *r = stmt_dup(rc->s);

			if ((convert_types(sql, &l, &r, 1, type_set) < 0)) {
				if (l)
					stmt_destroy(l);
				if (r)
					stmt_destroy(r);
				if (lgrp)
					grp_destroy(lgrp);
				if (rgrp)
					grp_destroy(rgrp);
				list_destroy(stmts);
				return NULL;
			}
			l = stmt_join(stmt_dup(lgrp->ext), l, cmp_equal);
			r = stmt_join(stmt_dup(rgrp->ext), r, cmp_equal);
			stmt_reljoin_fill(s, l, r);
		}
		
		if (!distinct) {
			lm = stmt_reverse(stmt_mark_tail(stmt_dup(s),0));
			ls = stmt_join(stmt_dup(lm),ls,cmp_equal);
			rs = stmt_join(stmt_mark(s,0),rs,cmp_equal);

			s = sql_binop_(sql, NULL, NULL, "sql_min", ls, rs);
			/* A ids */
			s = stmt_join(stmt_reverse(lm), s, cmp_equal);
			/* now we have gid,cnt, blowup to full groupsizes */
			s = stmt_gen_group(s);
		}
		s = stmt_mark_tail(s, 500); 
		/* from gid back to A id's */
		s = stmt_reverse(stmt_join(stmt_dup(lgrp->ext), s, cmp_equal));

		grp_destroy(lgrp);
		grp_destroy(rgrp);

		/* project columns of left hand expression */
		for (n = tv1->columns->h; n; n = n->next) {
			cvar *lc = n->data;
			stmt *ls = stmt_dup(lc->s);

			/* retain name via the stmt_alias */
			ls = stmt_join(stmt_dup(s), ls, cmp_equal);
			ls = stmt_alias(ls, NULL, _strdup(lc->cname));
			list_append(stmts, ls);
		}
		stmt_destroy(s);

		/* TODO cols length 0 see natural join
		   cols length > 0 see union join, join on name */
	}
	return stmt_list(stmts);
}

static stmt *
sql_setop_(mvc *sql, scope *scp, symbol *q)
{
	stmt *res = NULL;
	dnode *n = q->data.lval->h;
	symbol *tab_ref1 = n->data.sym;
	int dist = n->next->data.ival;
	dlist *corresponding = n->next->next->data.lval;
	symbol *tab_ref2 = n->next->next->next->data.sym;

	tvar *tv1 = table_ref(sql, scp, tab_ref1);
	tvar *tv2 = table_ref(sql, scp, tab_ref2);

	if (!tv1 || !tv2) {
		return NULL;
	}

	if (list_length(tv1->columns) != list_length(tv2->columns)) {
		char *op = "UNION";
		if (q->token == SQL_EXCEPT)
			op = "EXCEPT";
		else if (q->token == SQL_INTERSECT)
			op = "INTERSECT";
		return sql_error(sql, 02, "%s: column counts (%d and %d) do not match", op, list_length(tv1->columns), list_length(tv2->columns));
	}
	if ( q->token == SQL_UNION)
		res = sql_union(sql, tv1, tv2, corresponding );
	if ( q->token == SQL_EXCEPT)
		res = sql_except(sql, tv1, tv2, corresponding, dist );
	if ( q->token == SQL_INTERSECT)
		res = sql_intersect(sql, tv1, tv2, corresponding, dist );
	if (res && dist) {
		res = distinct(res);
	}
	return res;
}

static stmt *
sql_setop(mvc *sql, scope *scp, symbol *q)
{
	scope *nscp = scope_open(scp);
	stmt *tq = sql_setop_(sql, nscp, q);

	if (!tq)
		return NULL;
	(void) scope_close(nscp);
	return tq;
}

static stmt *
sql_cross_(mvc *sql, scope *scp, symbol *q)
{

	dnode *n = q->data.lval->h;
	symbol *tab_ref1 = n->data.sym;
	symbol *tab_ref2 = n->next->data.sym;

	tvar *tv1 = table_ref(sql, scp, tab_ref1);
	tvar *tv2 = table_ref(sql, scp, tab_ref2);
	cvar *cv1;
	cvar *cv2;
	stmt *ct;

	if (!tv1 || !tv2)
		return NULL;

	cv1 = tv1->columns->h->data;
	cv2 = tv2->columns->h->data;

	/* cross product */
	ct = stmt_join(stmt_dup(cv1->s), stmt_reverse(stmt_dup(cv2->s)), cmp_all);

	if (ct) {
		/* add the columns */
		list *rl = create_stmt_list();
		node *nv;

		ct = stmt2pivot(scp, ct);

		for (nv = scp->tables->h; nv; nv = nv->next) {
			node *n;
			tvar *tv = nv->data;
			stmt *foundsubset = find_pivot(ct, tv->s);

			for (n = tv->columns->h; n; n = n->next) {
				cvar *cs = n->data;

				list_append(rl, stmt_join(stmt_dup(foundsubset), stmt_dup(cs->s), cmp_equal));
			}
			stmt_destroy(foundsubset);
		}
		stmt_destroy(ct);
		return stmt_list(rl);
	}
	return NULL;
}

static stmt *
sql_cross(mvc *sql, scope *scp, symbol *q)
{
	scope *nscp = scope_open(scp);
	stmt *tq = sql_cross_(sql, nscp, q);

	if (!tq)
		return NULL;
	(void) scope_close(nscp);
	return tq;
}

static tvar *
query_exp_optname(mvc *sql, scope *scp, symbol *q)
{
	tvar *res = NULL;

	switch (q->token) {
	case SQL_UNION:
	case SQL_EXCEPT:
	case SQL_INTERSECT:
	{
		scope *nscp = scope_open(scp);
		stmt *tq = sql_setop_(sql, nscp, q);

		if (!tq)
			return NULL;
		res = table_optname(sql, scp, tq, q->data.lval->t->data.sym);
		scp = scope_close(nscp);
		return res;
	}
	case SQL_JOIN:
	{
		scope *nscp = scope_open(NULL);
		stmt *tq = sql_join(sql, nscp, q);

		if (!tq)
			return NULL;
		res = table_optname(sql, scp, tq, q->data.lval->t->data.sym);
		scope_close(nscp);
		return res;
	}
	case SQL_CROSS:
	{
		scope *nscp = scope_open(NULL);
		stmt *tq = sql_cross_(sql, nscp, q);

		if (!tq)
			return NULL;
		res = table_optname(sql, scp, tq, q->data.lval->t->data.sym);
		scope_close(nscp);
		return res;
	}
	case SQL_UNIONJOIN:
	{
		scope *nscp = scope_open(NULL);
		node *m;
		dnode *n = q->data.lval->h;

		/*int all = n->next->data.ival; */
		tvar *lv = table_ref(sql, nscp, n->data.sym);
		tvar *rv = table_ref(sql, nscp, n->next->next->data.sym);
		list *unions, *matching_columns;

		if (!lv || !rv)
			return NULL;

		/* find the matching columns (all should match?)
		 * union these 
		 * if !all do a distinct operation at the end 
		 */
		/* join all result columns ie join(lh,rh) on column_name */

		matching_columns = join_on_column_name(lv, rv, 1);

		if (!matching_columns)
			return NULL;

		unions = create_stmt_list();
		for (m = matching_columns->h; m; m = m->next->next) {
			stmt *l = stmt_dup(m->data);
			stmt *r = stmt_dup(m->next->data);

			list_append(unions, stmt_union(l, r));
		}
		res = table_optname(sql, scp, stmt_list(unions), q->data.lval->t->data.sym);
		list_destroy(matching_columns);
		scope_close(nscp);
		return res;
	}
	default:
		(void) sql_error(sql, 02, "case %d %s\n", q->token, token2string(q->token));
	}
	return NULL;
}

/* column expression of the form: table.* */
static stmt *
columns_exp(mvc *sql, scope *scp, symbol *column_e, group *grp, stmt *subset, int f)
{
	char *tname = column_e->data.lval->h->data.sval;
	tvar *tv = scope_bind_table(scp, tname);

	(void) sql;		/* Stefan: unused!? */
	(void) f;

	if (tv) {
		stmt *foundsubset = find_pivot(subset, tv->s);
		list *columns = create_stmt_list();
		node *n = tv->columns->h;

		if (grp)
			foundsubset = stmt_join(stmt_dup(grp->ext), foundsubset, cmp_equal);
		while (n) {
			cvar *cv = n->data;

			list_append(columns, stmt_join(stmt_dup(foundsubset), stmt_dup(cv->s), cmp_equal));
			n = n->next;
		}
		stmt_destroy(foundsubset);
		return stmt_list(columns);
	} else if (list_length(scp->tables) == 1) {
		tvar *tv = scp->tables->h->data;
		node *n;
		list *columns = create_stmt_list();
		stmt *foundsubset = scope_first_pivot(scp);

		if (grp)
			foundsubset = stmt_join(stmt_dup(grp->ext), foundsubset, cmp_equal);
		for (n = tv->columns->h; n; n = n->next) {
			cvar *cv = n->data;

			if (cv->tname && strcmp(cv->tname, tname) == 0) {
				list_append(columns, stmt_join(stmt_dup(foundsubset), stmt_dup(cv->s), cmp_equal));
			}
		}
		stmt_destroy(foundsubset);
		if (list_length(columns) > 0)
			return stmt_list(columns);
		else
			list_destroy(columns);
	}
	if (!tv)
		return sql_error(sql, 02, "SELECT: no such table '%s'", tname);
	return NULL;
}


static stmt *
_column_exp(mvc *sql, scope *scp, symbol *column_e, group *grp, stmt *subset, int f)
{
	dlist *l = column_e->data.lval;
	exp_kind ek = {type_value, card_column, FALSE};
	stmt *s = sql_value_exp(sql, scp, l->h->data.sym, grp, subset, f, ek);

	if (!s)
		return NULL;

	/* flatten subqueries */
	if (s->type == st_list && 
	    list_length(s->op1.lval) == 2 && f == sql_sel) {
		stmt *h, *v = stmt_dup(s->op1.lval->h->data);
		stmt *o = stmt_dup(s->op1.lval->h->next->data);
		stmt_destroy(s);
		s = stmt_join(stmt_reverse(o), v, cmp_equal);
		h = stmt_dup(s->h->t);
		stmt_destroy(s->h);
		s->h = h;
		if (f >= sql_sel)   /* make sure we don't lose rows */
			s = stmt_outerjoin(stmt_mirror(first_subset(subset)), s, cmp_equal);
	}
	/* AS name */
	if (s && l->h->next->data.sval) {
		s = stmt_alias(s, table_name(s), _strdup(l->h->next->data.sval));
		scope_add_alias(scp, stmt_dup(s), l->h->next->data.sval);
	}
	return s;
}

static stmt *
sql_column_exp(mvc *sql, scope *scp, symbol *column_e, group *grp, stmt *subset, int f)
{
	stmt *res = NULL;

	if (column_e->token == SQL_TABLE) {
		res = columns_exp(sql, scp, column_e, grp, subset, f);
	} else if (column_e->token == SQL_COLUMN) {
		res = _column_exp(sql, scp, column_e, grp, subset, f);
	}
	if (!res) {
		return sql_error(sql, 02, "column expression symbol(%d)->token = %s no output", (int) column_e->token, token2string(column_e->token));
	}
	return res;
}

static list *
list_map_merge(list *l2, list *l1)
{
	list *res = list_dup(l1, (fdup) &stmt_dup);

	res = list_merge(res, l2, (fdup) &stmt_dup);
	return res;
}

static list *
list_map_append_list(list *l2, list *l1)
{
	return list_append(l1, list_dup(l2, (fdup) &stmt_dup));
}

stmt *
sql_compare(mvc *sql, scope *scp, stmt *ls, stmt *rs, char *compare_op, int f, exp_kind ek)
{
	int join = 0;
	comp_type type = cmp_equal;

	if (!ls || !rs)
		return NULL;

	if (convert_types(sql, &ls, &rs, 1, type_equal) < 0) {
		if (ls)
			stmt_destroy(ls);
		if (rs)
			stmt_destroy(rs);
		return NULL;
	}
	/* predicate case ? */
	if (f == sql_sel || (ls->nrcols <= 0 && rs->nrcols <= 0) || !ek.reduce) {
		return sql_binop_(sql, NULL, NULL, compare_op, ls, rs);
	}
	if (ls->nrcols > 0 && rs->nrcols > 0) {
		join = 1;
	}
	if (compare_op[0] == '=') {
		type = cmp_equal;
	} else if (compare_op[0] == '<') {
		type = cmp_lt;
		if (compare_op[1] != '\0') {
			if (compare_op[1] == '>') {
				type = cmp_notequal;
			} else if (compare_op[1] == '=') {
				type = cmp_lte;
			}
		}
	} else if (compare_op[0] == '>') {
		type = cmp_gt;
		if (compare_op[1] != '\0') {
			if (compare_op[1] == '=') {
				type = cmp_gte;
			}
		}
	}
	if (join) {
		if (ls->h && rs->h && ls->h == rs->h && ls->nrcols != 2) {
			return stmt_uselect(ls, rs, type);
		}
		if (scp && (ls->nrcols == 2 || rs->nrcols == 2)) {
			/* we have some implicit joins, ie lets filter */ 
			if (ls->nrcols < rs->nrcols) {
				ls = stmt_join(scope_find_pivot(scp, ls->h), ls, cmp_equal);
			} else if (ls->nrcols > rs->nrcols) {
				rs = stmt_join(scope_find_pivot(scp, rs->h), rs, cmp_equal);
			}
			rs = stmt_uselect(ls, rs, type);
			return stmt_filter(rs);
		}
		rs = stmt_reverse(rs);
		return stmt_join(ls, rs, type);
	} else {
		stmt *res;

		if (ls->nrcols == 0) {
			stmt *t = ls;

			ls = rs;
			rs = t;

			if (type == cmp_lt) 
				type = cmp_gt;
			else if (type == cmp_gt) 
				type = cmp_lt;
			else if (type == cmp_lte) 
				type = cmp_gte;
			else if (type == cmp_gte) 
				type = cmp_lte;
		}
		res = stmt_uselect(ls, rs, type);
		if (f == sql_where && (ls->nrcols == 2 || rs->nrcols == 2))
			res = stmt_filter(res);
		return res;
	}
}

static stmt *
sql_compare_exp(mvc *sql, scope *scp, group *grp, stmt *subset, symbol *lo, symbol *ro, char *compare_op, int f, exp_kind ek)
{
	stmt *rs, *ls;
	exp_kind iek = {type_value, card_column, FALSE};

	if (lo->token == SQL_SELECT) { /* swap subquery to the right handside */
		symbol *tmp = lo;

		lo = ro;
		ro = tmp;

		if (compare_op[0] == '>')
			compare_op[0] = '<';
		else if (compare_op[0] == '<')
			compare_op[0] = '>';
	}

	ls = sql_value_exp(sql, scp, lo, grp, subset, f, iek);
	if (!ls)
		return NULL;
	
	if (ro->token != SQL_SELECT) {
		rs = sql_value_exp(sql, scp, ro, grp, subset, f, iek);
		if (!rs) {
			stmt_destroy(ls);
			return NULL;
		}
		
		if (grp && (!rs->key || !ls->key)) {
			stmt_destroy(rs);
			stmt_destroy(ls);
			return sql_error(sql, 02, "SELECT: cannot compare sets with values (did you forget an aggregate function?)");
		}
		return sql_compare(sql, scp, ls, rs, compare_op, f, ek);
	} else {
		node *o;

		rs = scope_subquery(sql, scp, ro, iek);

		if (!rs) {
			stmt_destroy(ls);
			return NULL;
		}
		if (rs->type != st_list || list_length(rs->op1.lval) == 0) {
			stmt_destroy(ls);
			stmt_destroy(rs);
			return sql_error(sql, 02, "SELECT: subquery result wrong");
		}
		o = rs->op1.lval->h;
		/* no outer references */
		if (list_length(rs->op1.lval) == 1) {
			stmt *sqa = stmt_dup(o->data);

			stmt_destroy(rs);
			if (!sqa->key) {
				sql_subaggr *zero_or_one = sql_bind_aggr(sql->session->schema, "zero_or_one", tail_type(sqa));
				assert(zero_or_one);
				sqa = stmt_aggr(sqa, NULL, zero_or_one, 1);
				/* we aggregated in the subquery not in the outer */
				sqa->aggr = 0;
			}
			return sql_compare(sql, scp, ls, sqa, compare_op, f, ek);
		} else {
			/* for now assume single outer ref ! */
			stmt *oref = stmt_dup(o->next->data);
			stmt *sqa = stmt_dup(o->data);
			stmt *cmp = NULL;
			stmt *h;

			if (list_length(rs->op1.lval) > 2 || !oref->t) {
				stmt_destroy(oref);
				stmt_destroy(sqa);
				stmt_destroy(rs);
				return sql_error(sql, 02, "SELECT: comparision between incompatible types");
			}

			cmp = stmt_join(stmt_reverse(oref), sqa, cmp_equal);
			if (f == sql_sel) {
				/* need to fix the cmp head */
				h = stmt_dup(cmp->h->t);
				stmt_destroy(cmp->h);
				cmp->h = h;

				cmp = stmt_join(find_pivot(subset, cmp->h), cmp, cmp_equal);
			} else {
				/* need to fix the oref head */
				h = stmt_dup(cmp->h->h);
				stmt_destroy(cmp->h);
				cmp->h = h;

				/* filter subset */
				if (subset) {	
					stmt *p = find_pivot(subset, ls->h);

					ls = stmt_join(p, ls, cmp_equal);
				} else if (scp && ls->nrcols) {
					stmt *p = scope_find_pivot(scp, ls->h);

					ls = stmt_join(p, ls, cmp_equal);

					if (!cmp->key) {
						sql_subaggr *zero_or_one = sql_bind_aggr(sql->session->schema, "zero_or_one", tail_type(cmp));
						assert(zero_or_one);
						cmp = stmt_aggr(cmp, NULL, zero_or_one, 1);
						/* we aggregated in the subquery not in the outer */
						cmp->aggr = 0;
					}
				}
			}
			/* it can happen that the subquery reduces the outer
			   refs, so we need to semijoin here 
			 */
			/* THIS IS A BUG, the inner query cannot reduce by 
			   itself (a subquery is simply a function which always
			   gives a result (famous count bug!). 

			   We should do a outer join like solution here. 
			 */
			ls = stmt_semijoin(ls, stmt_dup(cmp));

			cmp = sql_compare(sql, scp, ls, cmp, compare_op, f, ek);
			/* incase of sub queries no need too filter */
			if (f == sql_having)
				return cmp;
			stmt_destroy(rs);
			if (!cmp)
				return NULL;
			return stmt_filter(cmp);
		}
	}
	return NULL;
}

/*
void
subset_add_outer(stmt *ptable, stmt *s)
{
	while (ptable_parent(ptable))
		ptable = ptable_parent(ptable);

	if (!ptable_statements(ptable)) {
		ptable_statements(ptable) = stmt_set(s);
	} else {
		stmt *ps = ptable_statements(ptable);

		if (ps->type != st_set) {
			ps = stmt_set(ps);
			ptable_statements(ptable) = ps;
		}

		list_append(ps->op1.lval, s);
		if (ps->nrcols < s->nrcols)
			ps->nrcols = s->nrcols;
		ps->key &= s->key;
	}
}
*/

static void
filter(stmt *ptable, stmt *s)
{

	if (!ptable_statements(ptable)) {
		ptable_statements(ptable) = stmt_set(s);
	} else {
		stmt *ps = ptable_statements(ptable);

		list_append(ps->op1.lval, s);
		if (ps->nrcols < s->nrcols)
			ps->nrcols = s->nrcols;
		ps->key &= s->key;
	}
}

stmt *
sql_and(mvc *sql, scope *scp, stmt *ls, stmt *rs, int f)
{
	stmt *res = NULL;

	if (!ls || !rs)
		return NULL;

	/* keep filters on a higher level, ie. they need a full pivot table */
	if (ls->type == st_filter) {
		filter(scp->ptable, ls);
		return rs;
	}
	if (rs->type == st_filter) {
		filter(scp->ptable, rs);
		return ls;
	}

	if (f == sql_sel || (ls->nrcols <= 0 && rs->nrcols <= 0))
		return sql_binop_(sql, NULL, NULL, "and", ls, rs);

	if (f >= sql_having)
		return stmt_semijoin(ls, rs);

	if (ls->type != st_set && ls->type != st_sets) {
		ls = stmt_set(ls);
	}

	if (rs->type != st_set && rs->type != st_sets) {
		rs = stmt_set(rs);
	}

	if (ls->type == st_set && rs->type == st_set) {
		list_merge(ls->op1.lval, rs->op1.lval, (fdup) &stmt_dup);
		ls->nrcols = stmt_list_nrcols(ls->op1.lval);
		stmt_destroy(rs);
		res = ls;
	} else if (ls->type == st_sets && rs->type == st_set) {
		res = stmt_sets(list_map(ls->op1.lval, rs->op1.sval, (fmap) &list_map_merge));
		stmt_destroy(rs);
		stmt_destroy(ls);
	} else if (ls->type == st_set && rs->type == st_sets) {
		res = stmt_sets(list_map(rs->op1.lval, ls->op1.sval, (fmap) &list_map_merge));
		stmt_destroy(rs);
		stmt_destroy(ls);
	} else if (ls->type == st_sets && rs->type == st_sets) {
		res = stmt_sets(list_map(ls->op1.lval, rs->op1.sval, (fmap) &list_map_merge));
		stmt_destroy(rs);
		stmt_destroy(ls);
	}
	return res;
}

static void
or_filter(stmt *ptable, stmt *s)
{

	if (!ptable_statements(ptable)) {
		ptable_statements(ptable) = stmt_set(s);
	} else {
		stmt *ps = ptable_statements(ptable);

		if (ps->type == st_set) {
			stmt *nps = stmt_sets(list_append(list_create((fdestroy) &list_destroy), list_dup(ps->op1.lval, (fdup) &stmt_dup)));
			stmt_destroy(ps);
			ps = ptable_statements(ptable) = nps;
		}
		assert (ps->type == st_sets);
		/* s->type == st_set is missing */
		list_append(ps->op1.lval, list_append(create_stmt_list(), s));
	}
}

static stmt *
sql_or(mvc *sql, scope *scp, stmt *ls, stmt *rs, int f)
{
	stmt *res = NULL;

	(void) scp;		/* Stefan: unused!? */

	if (!ls || !rs)
		return NULL;

	/* keep filters on a higher level, ie. they need a full pivot table */
	if (ls->type == st_bat && rs->type == st_filter) {
		or_filter(scp->ptable, rs);
		return ls;
	}
	if (ls->type == st_filter && rs->type == st_filter) {
		or_filter(scp->ptable, ls);
		or_filter(scp->ptable, rs);
		return stmt_dup(scope_first_column(scp)->s);
	}
	if (ls->type == st_filter || rs->type == st_filter) {
		if (rs->type == st_filter) {
			stmt *t = ls;
			ls = rs;
			rs = t;
		}
		or_filter(scp->ptable, ls);

		return rs;
	}
	/* todo keep both sets aligned */

	if (f == sql_sel || (ls->nrcols <= 0 && rs->nrcols <= 0))
		return sql_binop_(sql, NULL, NULL, "or", ls, rs);

	if (f >= sql_having)
		return stmt_union(stmt_const(ls, stmt_atom_int(0)), stmt_const(rs, stmt_atom_int(0)));

	/* optimization 
	   (x = 'a' or x = 'b') ==> union(select(x,'a'),select(x,'b'))
	   should also handle the recursive case!
	 */
	if (ls->type != st_set && ls->type != st_sets && rs->type != st_set && rs->type != st_sets) {
		if (ls->h == rs->h && ls->nrcols == 1 && rs->nrcols == 1)
			return stmt_union(stmt_const(ls, stmt_atom_int(0)), stmt_const(rs, stmt_atom_int(0)));
	}

	if (ls->type != st_set && ls->type != st_sets) {
		ls = stmt_set(ls);
	}
	if (rs->type != st_set && rs->type != st_sets) {
		rs = stmt_set(rs);
	}

	if (ls->type == st_set && rs->type == st_set) {
		res = stmt_sets(list_append(list_append(list_create((fdestroy) &list_destroy), list_dup(ls->op1.lval, (fdup) &stmt_dup)), list_dup(rs->op1.lval, (fdup) &stmt_dup)));
		stmt_destroy(ls);
		stmt_destroy(rs);
	} else if (ls->type == st_sets && rs->type == st_set) {
		list_append(ls->op1.lval, list_dup(rs->op1.lval, (fdup) &stmt_dup));
		res = ls;
		stmt_destroy(rs);
	} else if (ls->type == st_set && rs->type == st_sets) {
		list_append(rs->op1.lval, list_dup(ls->op1.lval, (fdup) &stmt_dup));
		res = rs;
		stmt_destroy(ls);
	} else if (ls->type == st_sets && rs->type == st_sets) {
		(void) list_map(ls->op1.lval, rs->op1.sval, (fmap) &list_map_append_list);
		res = ls;
		stmt_destroy(rs);
	}
	return res;
}

stmt *
sql_logical_exp_(mvc *sql, scope *scp, symbol *sc, group *grp, stmt *subset, int f, exp_kind ek)
{
	exp_kind iek = {type_value, card_column, FALSE};

	if (!sc)
		return NULL;

 	if (THRhighwater())
		return sql_error(sql, 10, "SELECT: too many nested operators");

	switch (sc->token) {
	case SQL_OR:
	{
		symbol *lo = sc->data.lval->h->data.sym;
		symbol *ro = sc->data.lval->h->next->data.sym;
		stmt *ls = sql_logical_exp(sql, scp, lo, grp, subset, f, ek);
		stmt *rs = sql_logical_exp(sql, scp, ro, grp, subset, f, ek);

		return sql_or(sql, scp, ls, rs, f);
	}
		break;
	case SQL_AND:
	{
		symbol *lo = sc->data.lval->h->data.sym;
		symbol *ro = sc->data.lval->h->next->data.sym;
		stmt *ls = sql_logical_exp(sql, scp, lo, grp, subset, f, ek);
		stmt *rs = sql_logical_exp(sql, scp, ro, grp, subset, f, ek);

		return sql_and(sql, scp, ls, rs, f);
	}
		break;
	case SQL_COMPARE:
	{
		symbol *lo = sc->data.lval->h->data.sym;
		symbol *ro = sc->data.lval->h->next->next->data.sym;
		char *compare_op = sc->data.lval->h->next->data.sval;

		/* currently we don't handle the (universial and existential) 
		   quantifiers (all and any/some) */
		return sql_compare_exp(sql, scp, grp, subset, lo, ro, compare_op, f, ek);
	}
		break;
	case SQL_BETWEEN:
	case SQL_NOT_BETWEEN:
	{
		stmt *res = NULL;
		symbol *lo = sc->data.lval->h->data.sym;
		int symmetric = sc->data.lval->h->next->data.ival;
		symbol *ro1 = sc->data.lval->h->next->next->data.sym;
		symbol *ro2 = sc->data.lval->h->next->next->next->data.sym;
		stmt *ls = sql_value_exp(sql, scp, lo, grp, subset, f, iek);
		stmt *rs1 = sql_value_exp(sql, scp, ro1, grp, subset, f, iek);
		stmt *rs2 = sql_value_exp(sql, scp, ro2, grp, subset, f, iek);
		sql_subtype *ct = NULL;

		if (!ls || !rs1 || !rs2)
			return NULL;
		ct = tail_type(ls);
		rs1 = check_types(sql, ct, rs1, type_equal);
		rs2 = check_types(sql, ct, rs2, type_equal);
		if (symmetric) {
			stmt *tmp = NULL;
			sql_subfunc *min = sql_bind_func(sql->session->schema, "min", tail_type(rs1), tail_type(rs2));
			sql_subfunc *max = sql_bind_func(sql->session->schema, "max", tail_type(rs1), tail_type(rs2));

			if (!min || !max) {
				return sql_error(sql, 02, "min or max operator on types %s %s missing", tail_type(rs1)->type->sqlname, tail_type(rs2)->type->sqlname);
			}
			tmp = stmt_binop(rs1, rs2, min);
			rs2 = stmt_binop(stmt_dup(rs1), stmt_dup(rs2), max);
			rs1 = tmp;
		}
		if (rs1->nrcols > 0 || rs2->nrcols > 0 || f == sql_sel) {
			stmt *j1, *j2;

			if (sc->token == SQL_NOT_BETWEEN) {
				j1 = sql_compare(sql, scp, stmt_dup(ls), rs1, "<", f, ek);
				j2 = sql_compare(sql, scp, stmt_dup(ls), rs2, ">", f, ek);
			} else {
				j1 = sql_compare(sql, scp, stmt_dup(ls), rs1, ">=", f, ek);
				j2 = sql_compare(sql, scp, stmt_dup(ls), rs2, "<=", f, ek);
			}
			stmt_destroy(ls);
			return sql_and(sql, scp, j1, j2, f);
		}
		res = stmt_uselect2(ls, rs1, rs2, 3
			    /* aka ls >= rs1 && ls <= rs2 */ );
		if (sc->token == SQL_NOT_BETWEEN)
			res->flag |= ANTI; /* aka ls < rs1 || ls > rs2 */ 
		return res;
	}
	case SQL_LIKE:
	case SQL_NOT_LIKE:
	{
		stmt *res = NULL;
		symbol *lo = sc->data.lval->h->data.sym;
		symbol *ro = sc->data.lval->h->next->data.sym;
		stmt *ls = sql_value_exp(sql, scp, lo, grp, subset, f, iek);
		stmt *a = NULL, *e = NULL;
		sql_subtype *st = sql_bind_localtype("str");
		char *es = NULL;

		if (!ls)
			return NULL;

		if (!tail_type(ls)) {
			stmt_destroy(ls);
			return sql_error(sql, 02, "SELECT: parameter not allowed on left hand of LIKE operator");
		}

		lo = ro->data.lval->h->data.sym;
		/* like uses a single string pattern */
		iek.card = card_value;
		a = sql_value_exp(sql, scp, lo, grp, subset, f, iek);

		if (!a) {
			stmt_destroy(ls);
			return NULL;
		}
		if (dlist_length(ro->data.lval) == 2) {
			es = ro->data.lval->h->next->data.sval;
			e = stmt_atom_string(_strdup(es));
		}
		if (!tail_type(a)) {
			if (stmt_set_type_param(sql, st, a) == -1) {
				stmt_destroy(ls);
				stmt_destroy(a);
				cond_stmt_destroy(e);
				return sql_error(sql, 02, "LIKE: wrong type, should be string");
			}
		} else if ((a = check_types(sql, st, a, type_equal)) == NULL) {
			stmt_destroy(ls);
			cond_stmt_destroy(e);
			return sql_error(sql, 02, "LIKE: wrong type, should be string");
		}
		if ((ls = check_types(sql, st, ls, type_equal)) == NULL) {
			stmt_destroy(a);
			cond_stmt_destroy(e);
			return sql_error(sql, 02, "LIKE: wrong type, should be string");
		}

		/* predicate case ? */
		if (ls->nrcols == 0 || f == sql_sel) {
			sql_subtype *bt = sql_bind_localtype("bit");
			sql_subtype *s = sql_bind_localtype("str");
			sql_subfunc *like = sql_bind_func_result(sql->session->schema, "like", s, s, bt);

			res = stmt_binop(ls, a, like);
			if (sc->token != SQL_LIKE) {
				sql_subfunc *not = sql_bind_func_result(sql->session->schema, "not", bt, NULL, bt);

				res = stmt_unop(stmt_dup(res), not);
			}
		} else {
			comp_type cmp = (sc->token == SQL_LIKE ? cmp_like : cmp_notlike);

			/* default to the '\' char for escape */
			if (es == NULL)
				e = stmt_atom_string(_strdup(""));
			res = stmt_likeselect(ls, a, e, cmp);
		}
		return res;
	}
	case SQL_IN:
	case SQL_NOT_IN:
		/*
		   <in predicate> ::=
		   <row value constructor>
		   [ NOT ] IN <in predicate value>

		   <in predicate value> ::=
		   <table subquery>
		   | <left paren> <in value list> <right paren>

		   <in value list> ::=
		   <value expression> { <comma> <value expression> }...
		 */
	{
		dlist *l = sc->data.lval;
		symbol *lo = l->h->data.sym;
		stmt *ls = sql_value_exp(sql, scp, lo, grp, subset, f, iek);

		if (!ls)
			return NULL;
		iek.card = card_set;
		if (l->h->next->type == type_list) {
			dnode *n = l->h->next->data.lval->h;
			sql_subtype *ct = tail_type(ls);
			stmt *temp = stmt_temp(ct);

			for (; n; n = n->next) {
				symbol *sval = n->data.sym;
				stmt *v = sql_value_exp(sql, scp, sval, NULL, NULL, f, iek);

				if (!v) {
					stmt_destroy(ls);
					stmt_destroy(temp);
					return NULL;
				}
				if (v->type == st_list) {
					stmt_destroy(temp);
					if (n->next) {
						stmt_destroy(ls);
						return sql_error(sql, 02, "SELECT: multiple subqueries with outer references in IN is not supported");
					}
					if (list_length(v->op1.lval) > 2) {
						stmt_destroy(v);
						return sql_error(sql, 02, "SELECT: comparision between incompatible types");
					}
					temp = v;
				} else {
					temp = stmt_append(temp, check_types(sql, ct, v, type_equal));
				}
			}
			/* outer references */
			if (temp->type == st_list) {
				node *o = temp->op1.lval->h;
				stmt *oref = stmt_dup(o->next->data);
				stmt *sqa = stmt_dup(o->data);
				stmt *cmp = NULL, *h;
				char *comp = NULL;

				cmp = stmt_join(stmt_reverse(oref), sqa, cmp_equal);
				/* need to fix the cmp head */
				h = stmt_dup(cmp->h->t);
				stmt_destroy(cmp->h);
				cmp->h = h;

				if (sc->token == SQL_IN) 
					comp = "=";
				else
					comp = "<>";

				if (subset)
					cmp = stmt_join(find_pivot(subset, cmp->h), cmp, cmp_equal);
				else if (scp)
					cmp = stmt_join(scope_find_pivot(scp, cmp->h), cmp, cmp_equal);
				cmp = sql_compare(sql, scp, ls, cmp, comp, f, ek);
				return cmp;
			}
			if (sc->token == SQL_IN) {
				/* predicate case ? */
				if (ls->nrcols == 0) {
					sql_subtype *tp = tail_type(ls);
					sql_subaggr *exist;

					/* exist(temp,ls) */
					exist = sql_bind_aggr(sql->session->schema, "exist", tp);
					temp = stmt_reverse(temp);
					return stmt_aggr2(temp, ls, exist);
				} else if (f == sql_sel) {
					sql_subtype *bt = sql_bind_localtype("bit");
					sql_subtype *tp = tail_type(ls);
					sql_subfunc *isnul, *not;

					isnul = sql_bind_func_result(sql->session->schema, "isnull", tp, NULL, bt);
					not = sql_bind_func_result(sql->session->schema, "not", bt, NULL, bt);
					return stmt_unop(stmt_unop(stmt_outerjoin(ls, stmt_reverse(temp), cmp_equal), isnul), not);
				} else {	/* normal subquery */
					return stmt_reverse(stmt_semijoin(stmt_reverse(ls), stmt_reverse(temp)));
				}
			} else {	/* SQL_NOT_IN */
				/* predicate case ? */
				if (ls->nrcols == 0) {
					sql_subtype *tp = tail_type(ls);
					sql_subaggr *nexist;

					/* [not_exist](temp,ls) */
					/* not_exit needed to handle
					   null correctly */
					nexist = sql_bind_aggr(sql->session->schema, "not_exist", tp);
					temp = stmt_reverse(temp);
					return stmt_aggr2(temp, ls, nexist);
				} else if (f == sql_sel) {
					sql_subtype *bt = sql_bind_localtype("bit");
					sql_subtype *tp = tail_type(ls);
					sql_subfunc *isnul;

					isnul = sql_bind_func_result(sql->session->schema, "isnull", tp, NULL, bt);
					return stmt_unop(stmt_outerjoin(ls, stmt_reverse(temp), cmp_equal), isnul);
				} else {	/* normal subquery */
					/* NULL not IN null isn't possible */
					if (stmt_has_null(ls)) {
						sql_subtype *t = tail_type(ls);
						stmt *n = stmt_atom(atom_general(t, NULL, 0));
						ls = stmt_select2(ls, n, stmt_dup(n), 0);
					}
					return stmt_diff(stmt_dup(ls), stmt_join(ls, stmt_reverse(temp), cmp_equal));
				}
			}
		} else {
			return sql_error(sql, 02, "IN: missing inner query");
		}
	}
		break;
	case SQL_EXISTS:
	case SQL_NOT_EXISTS:
	{
		symbol *lo = sc->data.sym;
		stmt *ls = scope_subquery(sql, scp, lo, iek);

		if (!ls)
			return NULL;

		if (ls->type != st_list) {
			stmt_destroy(ls);
			return sql_error(sql, 02, "SELECT: subquery result wrong");
		}
		if (list_length(ls->op1.lval) == 1 || f == sql_sel) {
			/* predicate case */
			/* EXIST non empty result means AND TRUE */
			/* NOT EXIST non empty result means AND FALSE */
			stmt *res, *s = ls->op1.lval->h->data;
			sql_subaggr *cnt;
			sql_subtype *bt = sql_bind_localtype("bit");
			sql_subtype *it = sql_bind_localtype("int");

			if (s->nrcols == 0) {
				s = stmt_append(stmt_temp(tail_type(s)), stmt_dup(s));
			}
			cnt = sql_bind_aggr(sql->session->schema, "count", NULL);
			res = stmt_dup(s);
			res = stmt_aggr(res, NULL, cnt, 1);
			if (sc->token == SQL_EXISTS) {
				sql_subfunc *ne = sql_bind_func_result(sql->session->schema, "<>", it, it, bt);

				res = stmt_binop(res, stmt_atom_int(0), ne);
			} else {	/* NOT EXISTS */
				sql_subfunc *e = sql_bind_func_result(sql->session->schema, "=", it, it, bt);

				res = stmt_binop(res, stmt_atom_int(0), e);
			}
			stmt_destroy(ls);
			return res;
		} else {
			/* for now assume single outer ref ! */
			node *o = ls->op1.lval->h;
			stmt *t, *oref = stmt_dup(o->next->data);

			/* need to fix the oref tail */
			/*
			t = stmt_dup(oref->t->t);
			stmt_destroy(oref->t);
			oref->t = t;
			*/

			t = stmt_reverse(oref);
			if (sc->token == SQL_NOT_EXISTS)
				t = stmt_diff(scope_first_pivot(scp), t);
			stmt_destroy(ls);
			return stmt_filter(t);
		}
	}
		break;
	case SQL_NULL:
	case SQL_NOT_NULL:
	/* is (NOT) NULL */
	{
		symbol *cr = sc->data.sym;
		stmt *res = sql_value_exp(sql, scp, cr, grp, subset, f, iek);

		/* TODO predicate! */
		if (res && f == sql_sel) {
			sql_subtype *bt = sql_bind_localtype("bit");
			sql_subtype *tp = tail_type(res);
			sql_subfunc *isnul = sql_bind_func_result(sql->session->schema, "isnull", tp, NULL, bt);

			if (!isnul) {
				stmt_destroy(res);
				return NULL;
			}
			res = stmt_unop(res, isnul);
			if (sc->token != SQL_NULL) {
				sql_subfunc *not = sql_bind_func_result(sql->session->schema, "not", bt, NULL, bt);
				res = stmt_unop(res, not);
			} 
		} else if (res) {
			sql_subtype *tpe = tail_type(res);
			stmt *a = stmt_atom(atom_general(tpe, NULL, 0));

			if (sc->token == SQL_NULL) {
				res = stmt_uselect(res, a, cmp_equal);
			} else {
				res = stmt_uselect(res, a, cmp_notequal);
			}
		}
		return res;
	}
		break;
	case SQL_NOT: {
		symbol *lo = sc->data.sym;
		stmt *ls = sql_logical_exp(sql, scp, lo, grp, subset, f, ek);

		if (!ls)
			return NULL;
		if (ls->nrcols == 0 || f == sql_sel) { /* predicates */
			sql_subtype *bt = sql_bind_localtype("bit");
			sql_subfunc *not = sql_bind_func_result(sql->session->schema, "not", bt, NULL, bt);
		
			return stmt_unop(ls, not);
		} else { /* R.diff(ls) */
			if (subset)
				return stmt_diff(first_subset(subset), ls);
			else
				return stmt_diff(stmt_dup(scope_first_column(scp)->s), ls);
		}
	}
		break;
	case SQL_ATOM: {
		AtomNode *an = (AtomNode *) sc;

		/* TRUE or FALSE */
		return stmt_atom(atom_dup(an->a));
	}
		break;
	case SQL_COLUMN:
		return sql_column_value(sql, scp, sc, grp, subset, f);
	case SQL_UNION:
	case SQL_EXCEPT:
	case SQL_INTERSECT: {
		/* todo handle outer refs, ie requires full implementations of
		   sql_setop */
		stmt *r, *s = sql_setop(sql, NULL, sc);
		if (s->type != st_list || list_length(s->op1.lval) != 1) {
			char *op = "UNION";
			if (sc->token == SQL_EXCEPT)
				op = "EXCEPT";
			else if (sc->token == SQL_INTERSECT)
				op = "INTERSECT";
			stmt_destroy(s);
			return sql_error(sql, 02, "%s: single column instead of a table expected", op);
		}
		r = stmt_dup( s->op1.lval->h->data );
		stmt_destroy(s);
		return r;
	} break;
	default:
		return sql_error(sql, 02, "predicate %s %d: time to implement some more", token2string(sc->token), sc->token);
	}
	return sql_error(sql, 02, "predicate: time to implement some more");
}

stmt *
sql_logical_exp(mvc *sql, scope *scp, symbol *sc, group *grp, stmt *subset, int f, exp_kind ek)
{
	stmt *s = sql_logical_exp_(sql, scp, sc, grp, subset, f, ek);

	if (s && s->nrcols == 0 && f == sql_where) {
		/* predicate */
		sql_subtype *bt = sql_bind_localtype("bit");
		stmt *t = NULL;
		int found = 1;

		if (scp->tables->h) {
			cvar *c = scope_first_column(scp);
			stmt *b = stmt_bool(1);
			t = stmt_const(stmt_dup(c->s), b);
			found = 0;
		} else if (!(t = scope_bind(scp, NULL, "row"))) {
			stmt *b = stmt_bool(1);
			t = stmt_temp(bt);
			/* fake column needs fake base table too */
			t->h = b;
			t = stmt_append(t, stmt_dup(b));
			found = 0;
		}
		if (!(s = check_types(sql, bt, s, type_equal)))
			return NULL;
		s = stmt_uselect(t, s, cmp_equal);
		if (!found)
			scope_add_alias(scp, stmt_dup(t), "row");

	} else if (s && s->nrcols == 0 && f == sql_having && subset) {
		stmt *t = first_subset(subset);

		t = stmt_const(t, stmt_bool(1));
		return stmt_uselect(t, s, cmp_equal);
	}
	return s;
}

static group *
query_groupby_outers(mvc *sql, scope *scp, stmt *subset)
{
	group *cur = NULL;
	node *o = scp->outers->h;

	(void) sql;		/* Stefan: unused!? */

	for (; o; o = o->next) {
		stmt *outer = o->data;
		stmt *s = find_pivot(subset, outer);

		if (s)
			cur = grp_create(s, cur, NULL);
	}
	return cur;
}

static stmt *
find_order(stmt *s)
{
	assert(s->type == st_order || s->type == st_reorder);
	while(s->type == st_reorder)
		s = s->op1.stval;
	return s;
}

stmt *
sql_reorder(stmt *order, stmt *s) 
{
	list *l = create_stmt_list();
	node *n;
	/* we need to keep the order by column, to propagate the sort property*/
	stmt *o = find_order(order);
	stmt *x = o->op1.stval;

	order = stmt_mark(stmt_reverse(order), 0);
	for (n = s->op1.lval->h; n; n = n->next) {
		stmt *sc = n->data;
		char *cname = column_name(sc);
		char *tname = table_name(sc);

		if (sc != x)
			sc = stmt_reverse(stmt_order(stmt_reverse(stmt_join(stmt_dup(order), stmt_dup(sc), cmp_equal)), 1));
		else	/* first order by column */
			sc = stmt_mark(stmt_dup(o), 0);
		sc = stmt_alias(sc, tname, cname );
		list_append(l, sc);
		
	}
	stmt_destroy(s);
	stmt_destroy(order);
	return stmt_list(l);
}

static stmt *
sql_simple_select(mvc *sql, scope *scp, SelectNode *sn )
{
	stmt *subset = NULL;
	stmt *s = NULL;
	list *rl, *sl;
	dnode *n = NULL;
	node *m;
	int aggr = 0;
	exp_kind ek = {type_value, card_relation, TRUE};

	if (!sn->selection) 
		return sql_error(sql, 02, "SELECT: '*' not allowed without FROM");
		
	if (sn->where) {
		s = sql_logical_exp(sql, scp, sn->where, NULL, NULL, sql_where, ek);
		if (!s)
			return NULL;
		subset = s;
	}
	sl = create_stmt_list();
	for ( n = sn->selection->h; n; n = n->next) {
		stmt *cs = sql_column_exp(sql, scp, n->data.sym, NULL, subset, sql_sel);

		if (!cs || !tail_type(cs)) {
			list_destroy(sl);
			sql_select_cleanup(sql, cs, subset, NULL);
			return sql_error(sql, 02, "SELECT: subquery result missing");
		}
		if (tail_type(cs)->comp_type) {
			list_destroy(sl);
			sql_select_cleanup(sql, cs, subset, NULL);
			return sql_error(sql, 02, "SELECT: subquery returns a table");
		}
		list_append(sl, cs);
		aggr |= cs->aggr;
	}
	rl = create_stmt_list();
	for (m = sl->h, n = sn->selection->h; m && n; m = m->next, n = n->next){
		stmt *cs = m->data;

		/* t1.* */
		if (cs->type == st_list && n->data.sym->token == SQL_TABLE) {
			list_merge(rl, cs->op1.lval, (fdup) &stmt_dup);
		} else if (cs->type == st_list) {	/* subquery */
			if (list_length(cs->op1.lval) == 1) {
				list_append(rl, stmt_dup(cs->op1.lval->h->data));
			} else {
				if (subset) stmt_destroy(subset);
				list_destroy(rl);
				list_destroy(sl);
				return sql_error(sql, 02, "SELECT: subquery should return a single value");
			}
		} else if (subset) {
			stmt *ss = NULL;
			if (aggr) { 
				ss = scope_bind(scp, NULL, "row"); 
			} else {
				ss = stmt_dup(subset);
			}
			cs = stmt_const(ss, stmt_dup(cs));
			list_append(rl, cs);
		} else {
			list_append(rl, stmt_dup(cs));
		}
	}
	if (subset)
		stmt_destroy(subset);
	list_destroy(sl);

	/* SELECT ... INTO var_list */
	if (sn->into) {
		list *nl = create_stmt_list();

		for (m = rl->h, n = sn->into->h; m && n; m = m->next, n = n->next) {
			sql_subtype *tpe = NULL;
			char *nme = n->data.sval;
			stmt *a = NULL, *v = m->data, *var;
			int level;

			if ((var=stack_find_var(sql, nme)) == NULL || !v->key) {
				list_destroy(rl);
				list_destroy(nl);
				if (var)
					return sql_error(sql, 02, "SELECT INTO: needs a single row");
				else
					return sql_error(sql, 02, "SELECT INTO: variable '%s' unknown", nme);
			}
			tpe = tail_type(var);
			level = stack_find_frame(sql, nme);
			v = check_types(sql, tpe, stmt_dup(v), type_equal); 
			if (!v) {
				list_destroy(rl);
				list_destroy(nl);
				return NULL;
			}
			a = stmt_assign(nme, v, level);
			list_append(nl, a);
		}
		list_destroy(rl);
		rl = nl;
	}

	s = stmt_list(rl);

	if (!s)
		return sql_error(sql, 02, "SELECT: subquery result missing");
	return s;
}

static stmt *
sets2table( mvc *sql, scope *scp , stmt *s ) 
{
	list *l = s->op1.lval, *nl = list_create((fdestroy) &list_destroy);
	node *n;

	for (n = l->h; n; n = n->next) {
		list *t = n->data; 
		node *m = t->h;

		if (m) {
			list *nll;
			stmt *s1 = m->data;
			stmt *set = stmt_set(stmt_dup(s1));

			for (m = m->next; m; m = m->next) {
				stmt *s1 = m->data;

				if (s1->nrcols > set->nrcols)
					set -> nrcols = s1->nrcols;
				list_append(set->op1.lval, stmt_dup(s1)); 
			}
			set = set2table(sql, scp, set);
			nll = create_stmt_list();
			for (m = set->op1.lval->h; m; m = m->next) {
				stmt *s1 = m->data;

				list_append(nll, stmt_dup(s1));
			}
			stmt_destroy(set);
			list_append(nl, nll);
		}
	}
	stmt_destroy(s);
	return stmt_sets(nl);
}


static stmt *
sql_select(mvc *sql, scope *scp, SelectNode *sn, exp_kind ek)
{
	list *rl = NULL;
	stmt *s = NULL;
	exp_kind iek = {type_value, card_relation, TRUE};

	stmt *order = NULL, *subset = NULL;
	group *grp = NULL;

	if (!sn->from)
		return sql_simple_select(sql, scp, sn);

	if (sn->where) {
		s = sql_logical_exp(sql, scp, sn->where, NULL, NULL, sql_where, iek);
		if (!s) {
			sql_select_cleanup(sql, s, subset, grp);
			return sql_error(sql, 02, "SELECT: subquery result missing");
		}
		if (s->type == st_filter) {
			filter(scp->ptable, s);
			s = stmt_dup(scope_first_column(scp)->s);
		}
		if (s->type != st_set && s->type != st_sets) {
			s = stmt_set(s);
		}
		/* check for tables not used in the where part */
		if (s->type == st_set) {
			s = set2table(sql, scp, s);
		} else {
			s = sets2table(sql, scp, s);
		}
	} else if (sn->from) {
		node *n;
		stmt *cur = NULL;

		for (n = scp->tables->h; n; n = n->next) {
			tvar *tv = n->data;
			cvar *cv = tv->columns->h->data;
			stmt *tmp = stmt_dup(cv->s);

			if (!cur) {
				cur = tmp;
			} else {
				tmp = stmt_join(stmt_dup(cur), stmt_reverse(tmp), cmp_all);
				if (s) {
					list_append(s->op1.lval, tmp);
				} else {
					s = stmt_set(tmp);
				}
			}
		}
		if (!cur) {
			sql_select_cleanup(sql, s, subset, grp);
			return sql_error(sql, 02, "SELECT: subquery has no columns");
		}
		if (!s)
			s = cur;
		else
			stmt_destroy(cur);
	}

	if (s) {
		s = stmt2pivot(scp, s);
		if (s && sn->groupby) {
			/* pass selection */
			grp = query_groupby(sql, scp, sn->groupby, s, sn->selection);
			if (!grp) {
				sql_select_cleanup(sql, s, subset, grp);
				return sql_error(sql, 02, "SELECT: subquery result missing");
			}
		}

		if (s && ek.card != card_set && list_length(scp->outers) > 0) {
			assert(!grp);
			grp = query_groupby_outers(sql, scp, s);
			if (!grp) {
				assert(0);
				sql_select_cleanup(sql, s, subset, grp);
				return sql_error(sql, 02, "SELECT: subquery outer ref GROUP BY result missing");
			}
		}
	}

	subset = stmt_dup(s);

	if (sn->having) {
		stmt *t, *ss = subset;


		/* handle havings without group by as a subquery, ie
		   they work on the partial pivot tables 
		 */
		if (!grp)
			ss = ptable_parent(subset);

		t = sql_logical_exp(sql, scp, sn->having, grp, ss, sql_having, iek);
		if (!t) {
			sql_select_cleanup(sql, s, subset, grp);
			return sql_error(sql, 02, "SELECT: subquery result missing");
		}

		if (!grp) {
			filter(subset, stmt_filter(t));
		} else {
			grp = grp_semijoin(grp, t);
		}
	}

	if (!subset) {
		sql_select_cleanup(sql, s, subset, grp);
		return sql_error(sql, 02, "SELECT: subquery result missing");
	}

	rl = create_stmt_list();
	if (sn->selection) {
		list *sl = create_stmt_list();
		dnode *n;
		node *m;
		int nrcols = 0, aggr = 0;
		void *outer = NULL;


		if (scp->outers->t)
		 	outer = scp->outers->t->data; 

		for (n = sn->selection->h; n; n = n->next) {
			stmt *cs = sql_column_exp(sql, scp, n->data.sym, grp, subset, sql_sel);

			if (!cs || !tail_type(cs)) {
				list_destroy(sl);
				list_destroy(rl);
				sql_select_cleanup(sql, s, subset, grp);
				return sql_error(sql, 02, "SELECT: subquery result missing");
			}

			list_append(sl, cs);
			if (nrcols < cs->nrcols)
				nrcols = cs->nrcols;
			aggr |= cs->aggr;

			if (scp->outers->t && outer != scp->outers->t->data) {
				/* new outer reference */
				outer = scp->outers->t->data;
				
				list_destroy(sl);
				list_destroy(rl);
				sql_select_cleanup(sql, s, subset, grp);
				return sql_error(sql, 02, "SELECT: outer reference in the selection part is not supported");
				/*subset_add_outer(subset, outer);*/
			}
		}

		for (m = sl->h, n = sn->selection->h; m && n; m = m->next, n = n->next) {
			stmt *cs = m->data;

			/* t1.* */
			if (cs->type == st_list && n->data.sym->token == SQL_TABLE) {
				list_merge(rl, cs->op1.lval, (fdup) &stmt_dup);
			} else if (cs->type == st_list) {	/* subquery */
				if (list_length(cs->op1.lval) == 1) {	/* single value */
					stmt *ss = ptable_pivots(subset)->h->data;
					stmt *cs1 = cs->op1.lval->h->data;

					ss = stmt_dup(ss);
					cs1 = stmt_dup(cs1);
					list_append(rl, stmt_join(ss, cs1, cmp_all));
				} else {	/* referenced variable(s) (can only be 2) */
					stmt *sqa = cs->op1.lval->h->data;
					stmt *ids = cs->op1.lval->h->next->data;
					stmt *s = stmt_join(stmt_reverse(stmt_dup(ids)), stmt_dup(sqa), cmp_equal);

					s = stmt_outerjoin(stmt_mirror(first_subset(subset)), s, cmp_equal);
					list_append(rl, s);
				}
			} else if (cs->nrcols == 0) {
				/* select name,count(*) should give an error */
				if (cs->aggr && nrcols > 0) {
					list_destroy(sl);
					list_destroy(rl);
					sql_select_cleanup(sql, s, subset, grp);
					return sql_error(sql, 02, "SELECT: single value in column expression");
					/* properly handle select '' from x */
				} else if (!cs->aggr && !aggr) {
					stmt *ss = first_subset(subset);

					cs = stmt_const(ss, stmt_dup(cs));
					list_append(rl, cs);
				} else {
					cs = stmt_dup(cs);
					list_append(rl, cs);
				}
			} else if (cs->aggr == 1 && cs->nrcols >= 2) {
				/* sub query single value */
				stmt *ss = ptable_pivots(subset)->h->data;

				ss = stmt_dup(ss);
				cs = stmt_dup(cs);
				list_append(rl, stmt_join(ss, cs, cmp_all));
			} else {
				cs = stmt_dup(cs);
				if (!cs->aggr && outer && ek.card <= card_column) {
					sql_subaggr *zero_or_one = sql_bind_aggr(sql->session->schema, "zero_or_one", tail_type(cs));
					cs = stmt_aggr(cs, grp_dup(grp), zero_or_one, 1);
					/* we aggregated in the subquery not 
					   in the outer */
					cs->aggr = 0;
				}
				list_append(rl, cs);
			}
		}
		list_destroy(sl);
	} else {
		/* select * from tables */
		if (grp && list_length(scp->outers) <= 0) {
			list_destroy(rl);
			sql_select_cleanup(sql, s, subset, grp);
			return sql_error(sql, 02, "SELECT: cannot combine '*' with GROUP BY");
		}
		if (!scp->p) {
			node *nv;

			for (nv = scp->tables->h; nv; nv = nv->next) {
				node *n;
				tvar *tv = nv->data;
				stmt *foundsubset = find_pivot(subset, tv->s);

				for (n = tv->columns->h; n; n = n->next) {
					stmt *s;
					cvar *cs = n->data;
					stmt *cbat = stmt_dup(cs->s);

					/* selected only a single row ?? */
					if (subset->nrcols == 0) {
						s = cbat;
					} else {
						s = stmt_join(stmt_dup(foundsubset), cbat, cmp_equal);
					}
					list_append(rl, s);
				}
				stmt_destroy(foundsubset);
			}
		} else {
			/* 
			 * subquery can only return one column
			 */
			tvar *tv = scope_first_table(scp);
			stmt *foundsubset = find_pivot(subset, tv->s);

			if (!foundsubset) {
				list_destroy(rl);
				sql_select_cleanup(sql, s, subset, grp);
				return sql_error(sql, 02, "SELECT: subquery result missing");
			}
			if (tv->columns->h) {
				node *n = tv->columns->h;
				stmt *s;
				cvar *cs = n->data;
				stmt *cbat = stmt_dup(cs->s);

				/* selected only a single row ?? */
				if (subset->nrcols == 0) {
					s = cbat;
				} else {
					s = stmt_join(stmt_dup(foundsubset), cbat, cmp_equal);
				}
				list_append(rl, s);
			}
			stmt_destroy(foundsubset);
		}
	}
	/* the inner query should output a table where the first column
	 * contains the queried column values. 
	 * If variables from the outer query are correlated 
	 * the oids from the base tables of these variables are returned
	 * in the next columns.
	 */
	if (list_length(scp->outers) > 0) {
		node *n = scp->outers->h;

		for (; n; n = n->next) {
			stmt *oref = n->data;
			stmt *foundsubset = find_pivot(subset, oref);

			if (!foundsubset) {
				list_destroy(rl);
				sql_select_cleanup(sql, s, subset, grp);
				return sql_error(sql, 02, "SELECT: subquery result missing");
			}
			if (ek.card != card_set)
				list_append(rl, stmt_join(stmt_dup(grp->ext), foundsubset, cmp_equal));
			else
				list_append(rl, foundsubset);
		}
	}
	stmt_destroy(s);
	s = stmt_list(rl);

	if (s && subset && sn->distinct) {
		s = distinct(s);
	}

	if (s && subset && sn->orderby) {
		order = query_orderby(sql, scp, sn->orderby, s, subset, grp);
		if (!order) {
			sql_select_cleanup(sql, s, subset, grp);
			return sql_error(sql, 02, "SELECT: subquery result missing");
		}
	}

	if (!s) {
		sql_select_cleanup(sql, s, subset, grp);
		return sql_error(sql, 02, "SELECT: subquery result missing");
	}

	sql_select_cleanup(sql, NULL, subset, grp);

	if (sn->limit >= 0 || sn->offset > 0) {
		int offset = (sn->offset >=0)?sn->offset:0;
		int limit = sn->limit;

		if (limit < 0) {
			limit = sn->offset;
			offset = 0;
		}
	
		if (order) {
			node *n;
			list *l = create_stmt_list();
			stmt *lmt = stmt_limit(stmt_dup(order), offset, limit, 0);

			for (n = s->op1.lval->h; n; n = n->next)
				if (sn->limit < 0)
					list_append(l, stmt_diff(stmt_dup(n->data), stmt_dup(lmt)));
				else
					list_append(l, stmt_semijoin(stmt_dup(n->data), stmt_dup(lmt)));
			stmt_destroy(s);
			s = stmt_list(l);
			if (sn->limit < 0) {
				order = stmt_diff(order, lmt);
			} else {
				stmt_destroy(order);
				order = lmt;
			}
		} else {
			/* simply reduce ptable */
			node *n = s->op1.lval->h;
			list *l = create_stmt_list();

			if (n) {
				stmt *lmt = stmt_limit(stmt_dup(n->data), offset, limit, 0);
				if (sn->limit >= 0) {
					list_append(l, lmt);
					n = n->next;
				}
				for ( ; n; n = n->next)
					if (sn->limit < 0)
						list_append(l, stmt_diff(stmt_dup(n->data), stmt_dup(lmt)));
					else
						list_append(l, stmt_semijoin(stmt_dup(n->data), stmt_dup(lmt)));
			}
			stmt_destroy(s);
			s = stmt_list(l);
		}
	}

	if (s && order && !scp->p) { /* toplevel */
		return stmt_ordered(order, s);
	} else if (s && order && scp->p && ek.card == card_relation) {
		s = sql_reorder(order, s);
	}
	return s;
}


stmt *
selects(mvc *sql, scope *scp, symbol *s)
{
	stmt *ret = NULL;

	switch (s->token) {
	case SQL_SELECT: {
		exp_kind ek = {type_value, card_relation, TRUE};
		ret = scope_subquery(sql, scp, s, ek);
		sql->type = Q_TABLE;
	} 	break;
	case SQL_JOIN:
		ret = sql_join(sql, scp, s);
		sql->type = Q_TABLE;
		break;
	case SQL_CROSS:
		ret = sql_cross(sql, scp, s);
		sql->type = Q_TABLE;
		break;
	case SQL_UNION:
	case SQL_EXCEPT:
	case SQL_INTERSECT:
		ret = sql_setop(sql, scp, s);
		sql->type = Q_TABLE;
		break;

	default:
		return sql_error(sql, 01, "SELECT statement unknown symbol(%ld)->token = %s", (long) s, token2string(s->token));
	}
	return ret;
}
