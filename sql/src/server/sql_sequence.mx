@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2005 CWI.
@' All Rights Reserved.

@f sql_sequence
@a N.J. Nes
@* 

@h
#ifndef _SQL_SEQUENCE_H_
#define _SQL_SEQUENCE_H_

#include "sql_symbol.h"
#include <sql_statement.h>

extern int sql_create_sequences(mvc *sql, sql_schema *s);
extern int sql_find_seq(mvc *m, str seq);

extern stmt *sequences(mvc *sql, symbol *s);
extern stmt *sql_create_seq(mvc *sql, sql_schema *ss, dlist *qname, sql_subtype *tpe, lng start, lng inc, lng min, lng max, int cycle);
extern char* sql_next_seq_name(mvc *sql);

#endif /*_SQL_SEQUENCE_H_*/
@c

#include "sql_sequence.h"
#include "sql_semantic.h"
#include "sql_privileges.h"

int
sql_create_sequences(mvc *m, sql_schema *s)
{
	sql_table *t;

	t = mvc_create_table(m, s, "sequences", 1, 1, 0, -1);
	mvc_create_column_(m, t, "name", "varchar", 1024);
	mvc_create_column_(m, t, "schema", "varchar", 1024);
	mvc_create_column_(m, t, "start", "bigint", 19);
	mvc_create_column_(m, t, "cached", "bigint", 19);
	mvc_create_column_(m, t, "increment", "bigint", 19);
	mvc_create_column_(m, t, "minvalue", "bigint", 19);
	mvc_create_column_(m, t, "maxvalue", "bigint", 19);
	mvc_create_column_(m, t, "cycle", "boolean", 0);

	return 0;
}

int
sql_find_seq(mvc *m, str seq)
{
	int res = 0;
	sql_schema *sys = find_sql_schema(m->trans, "sys");
	sql_table *seqs = find_sql_table(sys, "sequences");
	sql_column *seqname = find_sql_column(seqs, "name");
	ssize_t rid = column_find_row(m->trans, seqname, seq, NULL);

	if (rid >= 0)
		res = 1;
	return res;
}

stmt *
sql_create_seq(
		mvc *sql,
		sql_schema *ss,
		dlist *qname,
		sql_subtype *tpe,
		lng start,
		lng inc,
		lng min,
		lng max,
		int cycle)
{
	char buf[BUFSIZ];
	char* name = qname_table(qname);
	(void) tpe;

	if (sql_find_seq(sql, name)) {
		return sql_error(sql, 02,
				 "CREATE SEQUENCE: "
				 "name '%s' already in use", name);
	} else if (!schema_privs(sql->role_id, ss)) {
		return sql_error(sql, 02,
				"CREATE SEQUENCE: insufficient privileges "
				"for '%s' in schema '%s'", sql->user, ss->base.name);
	}

	/* generate defaults */
	if (start < 0) start = 1;
	if (inc < 0) inc = 1;
	if (min < 0) min = 1;
	if (cycle && max < 0) cycle = 0;
	if (max < 0) max = 0;

	snprintf(buf, BUFSIZ,
		 "insert into sys.sequences values "
		 "('%s',        '%s',  %lld,      %lld,%lld,%lld,%lld,    %s);",
		 /*name,      schema, start,    cached, inc, min, max, cycle */
		 name, ss->base.name, start, start - 1, inc, min, max, cycle ? "true" : "false");
	return stmt_sql(_strdup(buf));
}

stmt *
sql_alter_seq(
		mvc *sql,
		sql_schema *ss,
		dlist *qname,
		sql_subtype *tpe,
		lng start,
		lng inc,
		lng min,
		lng max,
		int cycle)
{
	char buf[BUFSIZ];
	char* name = qname_table(qname);
	sql_schema *sys = find_sql_schema(sql->trans, "sys");
	sql_table *seqs = find_sql_table(sys, "sequences");
	sql_column *col = find_sql_column(seqs, "name");
	ssize_t rid = column_find_row(sql->trans, col, name, NULL);
	(void) tpe;

	if (rid < 0) {
		return sql_error(sql, 02,
				 "ALTER SEQUENCE: "
				 "no such sequence '%s'", name);
	}
	 if (!schema_privs(sql->role_id, ss)) {
		return sql_error(sql, 02,
				"ALTER SEQUENCE: insufficient privileges "
				"for '%s' in schema '%s'", sql->user, ss->base.name);
	}

	/* use values already in there if not supplied */
	col = find_sql_column(seqs, "start");
	assert(col);
	if (start < 0) start = *(lng*)column_find_value(sql->trans, col, rid);
	col = find_sql_column(seqs, "increment");
	assert(col);
	if (inc < 0) inc = *(lng*)column_find_value(sql->trans, col, rid);
	col = find_sql_column(seqs, "minvalue");
	assert(col);
	if (min < 0) min = *(lng*)column_find_value(sql->trans, col, rid);
	col = find_sql_column(seqs, "cycle");
	assert(col);
	if (cycle && max < 0) cycle = *(bit*)column_find_value(sql->trans, col, rid);
	col = find_sql_column(seqs, "maxvalue");
	assert(col);
	if (max < 0) max = *(lng*)column_find_value(sql->trans, col, rid);

	snprintf(buf, BUFSIZ,
		"update sys.sequences set "
		"start = %lld "
		"cached = %lld "
		"inc = %lld "
		"min = %lld "
		"max = %lld "
		"cycle = %s "
		"where name = '%s' and schema = '%s';",
		start, start - 1, inc, min, max, cycle ? "true" : "false",
		name, ss->base.name);
	return stmt_sql(_strdup(buf));
}

static stmt *
sql_drop_seq(mvc *sql, sql_schema *ss, dlist *qname)
{
	char buf[BUFSIZ];
	char *name = qname_table(qname);

	if (!sql_find_seq(sql, name)) {
		return sql_error(sql, 02, "DROP SEQUENCE: no such sequence '%s'", name);
	} else if (!schema_privs(sql->role_id, ss)) {
		return sql_error(sql, 02, "DROP SEQUENCE: insufficient privileges for '%s' in schema '%s'", sql->user,  ss->base.name);
	}
	snprintf(buf, BUFSIZ, "delete from sys.sequences where name = '%s';", name);
	return stmt_sql(_strdup(buf));
}

char*
sql_next_seq_name(mvc *m)
{
	char buf[BUFSIZ + 1];

	sql_schema *sys = find_sql_schema(m->trans, "sys");
	sql_table *seqs = find_sql_table(sys, "sequences");
	
	snprintf(buf, BUFSIZ, "seq_%lld\"\"\"", seqs->cnt++);
	buf[BUFSIZ] = '\0';

	/* waring: using sa_strdup here */
	return(sa_strdup(m->sa, buf));
}

stmt *
sequences(mvc *sql, symbol *s)
{
	stmt *res = NULL;

	switch (s->token) {
		case SQL_CREATE_SEQ:
		{
			dlist *l = s->data.lval;

			/*
			   mvc *sql,
			   sql_schema *ss,
			   dlist *qname,
			   sql_subtype *tpe,
			   int start,
			   int inc,
			   int min,
			   int max,
			   int cycle
			 */
			res = sql_create_seq(
					sql,
					cur_schema(sql), 
					l->h->data.lval, 
					l->h->next->data.typeval, 
					l->h->next->next->data.lval->h->data.ival, 
					l->h->next->next->data.lval->h->next->data.ival, 
					l->h->next->next->data.lval->h->next->data.ival, 
					l->h->next->next->data.lval->h->next->next->data.ival,
					l->h->next->next->data.lval->h->next->next->next->data.ival);
		}
		break;
		case SQL_ALTER_SEQ:
		{
			dlist* l = s->data.lval;
			
			res = sql_alter_seq(
					sql,
					cur_schema(sql), 
					l->h->data.lval, 
					l->h->next->data.typeval, 
					l->h->next->next->data.lval->h->data.ival, 
					l->h->next->next->data.lval->h->next->data.ival, 
					l->h->next->next->data.lval->h->next->data.ival, 
					l->h->next->next->data.lval->h->next->next->data.ival,
					l->h->next->next->data.lval->h->next->next->next->data.ival);
		}
		case SQL_DROP_SEQ:
		{
			dlist *l = s->data.lval;

			res = sql_drop_seq(sql, cur_schema(sql), l->h->data.lval);
		}
		break;
		default:
			return sql_error(sql, 01, "sql_stmt Symbol(%ld)->token = %s", (long) s, token2string(s->token));
	}
	return res;
}
