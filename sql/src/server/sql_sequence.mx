@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2006 CWI.
@' All Rights Reserved.

@f sql_sequence
@a N.J. Nes
@* 

@h
#ifndef _SQL_SEQUENCE_H_
#define _SQL_SEQUENCE_H_

#include "sql_symbol.h"
#include <sql_statement.h>
#include <bat/bat_sequence.h>

extern stmt *sequences(mvc *sql, symbol *s);
extern char* sql_next_seq_name(mvc *sql);

#endif /*_SQL_SEQUENCE_H_*/
@c

#include "sql_config.h"
#include "sql_sequence.h"
#include "sql_semantic.h"
#include "sql_privileges.h"
#include "sql_select.h"

stmt *
sql_create_seq(
	mvc *sql,
	sql_schema *ss,
	dlist *qname,
	sql_subtype *tpe,
	lng start,
	lng inc,
	lng min,
	lng max,
	lng cache,
	int cycle)
{
	char* name = qname_table(qname);

	(void) tpe;
	if (find_sql_sequence(sql->session->schema, name)) {
		return sql_error(sql, 02,
				"CREATE SEQUENCE: "
				"name '%s' already in use", name);
	} else if (!schema_privs(sql->role_id, ss)) {
		return sql_error(sql, 02,
				"CREATE SEQUENCE: insufficient privileges "
				"for '%s' in schema '%s'", stack_get_string(sql, "current_user"), ss->base.name);
	}

	/* generate defaults */
	if (inc <= 0) inc = 1;
	if (min < 0) min = 0;
	if (cycle && max < 0) cycle = 0;
	if (max < 0) max = 0;
	if (cache <= 0) cache = 1;

	sql_trans_create_sequence(sql->session->tr, ss, name, start, min, max, inc, cache, cycle);  
	return stmt_none();
}

static stmt *
sql_alter_seq(
		mvc *sql,
		sql_schema *ss,
		dlist *qname,
		sql_subtype *tpe,
		dlist* start_list,
		lng inc,
		lng min,
		lng max,
		lng cache,
		int cycle)
{
	char* name = qname_table(qname);
	int start_type = start_list->h->data.ival;
	sql_sequence *seq;
	stmt *val = NULL, *seqname = NULL;
	sql_subfunc *f = NULL;
	sql_subtype *str_t = sql_bind_localtype("str");
	sql_subtype *lng_t = sql_bind_localtype("lng");

	(void) tpe;
	if (!(seq = find_sql_sequence(sql->session->schema, name))) {
		return sql_error(sql, 02,
				"ALTER SEQUENCE: "
				"no such sequence '%s'", name);
	}
	if (!schema_privs(sql->role_id, ss)) {
		return sql_error(sql, 02,
				"ALTER SEQUENCE: insufficient privileges "
				"for '%s' in schema '%s'", stack_get_string(sql, "current_user"), ss->base.name);
	}

	/* first alter the known values */
	sql_trans_alter_sequence(sql->session->tr, seq, min, max, inc, cache, cycle);

	/* restart maybe a query, ie we create a binary statement 
	   restart(seqname,value) */ 

	if (start_type == 0) {
		val = stmt_atom_lng(seq->start);
	} else if (start_type == 1) { /* value (exp) */
		exp_kind ek = {type_value, card_value, FALSE};
		val = sql_value_exp(sql, NULL, start_list->h->next->data.sym, NULL, NULL, sql_sel, ek);

		if (!val || !(val = check_types(sql, lng_t, val, type_equal)))
			return NULL;
	} else if (start_type == 2) {
		val = stmt_atom_lng(start_list->h->next->data.ival);
	}
	seqname = stmt_atom_string(_strdup(name));
	f = sql_bind_func(ss, "restart", str_t, lng_t);
	assert(f);
	return stmt_binop(seqname, val, f);
}

static stmt *
sql_drop_seq(mvc *sql, sql_schema *ss, dlist *qname)
{
	char *name = qname_table(qname);

	if (!find_sql_sequence(sql->session->schema, name)) {
		return sql_error(sql, 02, "DROP SEQUENCE: no such sequence '%s'", name);
	} else if (!schema_privs(sql->role_id, ss)) {
		return sql_error(sql, 02, "DROP SEQUENCE: insufficient privileges for '%s' in schema '%s'", stack_get_string(sql, "current_user"),  ss->base.name);
	}
	sql_trans_drop_sequence(sql->session->tr, ss, name);  
	return stmt_none();
}

char*
sql_next_seq_name(mvc *m)
{
	char buf[BUFSIZ + 1];

	snprintf(buf, BUFSIZ, "seq_%d", store_next_oid());
	buf[BUFSIZ] = '\0';

	/* waring: using sa_strdup here */
	return(sa_strdup(m->sa, buf));
}

stmt *
sequences(mvc *sql, symbol *s)
{
	stmt *res = NULL;

	sql->type = Q_SCHEMA; 
	switch (s->token) {
		case SQL_CREATE_SEQ:
		{
			dlist *l = s->data.lval;
			dlist *h = l->h->next->next->data.lval;

			res = sql_create_seq(
/* mvc* sql */		sql,
/* sql_schema* s */	cur_schema(sql), 
/* dlist* qname */	l->h->data.lval, 
/* sql_subtype* t*/	&l->h->next->data.typeval, 
/* lng start */		h->h->data.ival, 
/* lng inc */		h->h->next->data.ival, 
/* lng min */		h->h->next->next->data.ival, 
/* lng max */		h->h->next->next->next->data.ival,
/* lng cache */		h->h->next->next->next->next->data.ival,
/* int cycle */		h->h->next->next->next->next->next->data.ival);
		}
		break;
		case SQL_ALTER_SEQ:
		{
			dlist* l = s->data.lval;
			dlist *h = l->h->next->next->data.lval;
			
			res = sql_alter_seq(
/* mvc* sql */		sql,
/* sql_schema* s */	cur_schema(sql), 
/* dlist* qname */	l->h->data.lval, 
/* sql_subtype* t*/	&l->h->next->data.typeval, 
/* dlist start */	h->h->data.lval, 
/* lng inc */		h->h->next->data.ival, 
/* lng min */		h->h->next->next->data.ival, 
/* lng max */		h->h->next->next->next->data.ival,
/* lng cache */		h->h->next->next->next->next->data.ival,
/* int cycle */		h->h->next->next->next->next->next->data.ival);
		}
		break;
		case SQL_DROP_SEQ:
		{
			dlist *l = s->data.lval;
			res = sql_drop_seq(sql, cur_schema(sql), l->h->data.lval);
		}
		break;
		default:
			return sql_error(sql, 01, "sql_stmt Symbol(%ld)->token = %s", (long) s, token2string(s->token));
	}
	return res;
}
