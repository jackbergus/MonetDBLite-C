@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2006 CWI.
@' All Rights Reserved.

@f sql_sequence
@a N.J. Nes
@* 

@h
#ifndef _SQL_SEQUENCE_H_
#define _SQL_SEQUENCE_H_

#include "sql_symbol.h"
#include <sql_statement.h>
#include <bat/bat_sequence.h>

extern int sql_create_sequences(mvc *sql, sql_schema *s);
extern int sql_find_seq(mvc *m, str seq);

extern stmt *sequences(mvc *sql, symbol *s);
extern char* sql_next_seq_name(mvc *sql);

#endif /*_SQL_SEQUENCE_H_*/
@c

#include "sql_sequence.h"
#include "sql_semantic.h"
#include "sql_privileges.h"
#include "sql_select.h"

int
sql_create_sequences(mvc *m, sql_schema *s)
{
	sql_table *t;

	t = mvc_create_table(m, s, "sequences", 1, SQL_PERSIST, 0, -1);
	mvc_create_column_(m, t, "name", "varchar", 1024);
	mvc_create_column_(m, t, "schema", "varchar", 1024);
	mvc_create_column_(m, t, "start", "bigint", 64);
	mvc_create_column_(m, t, "increment", "bigint", 64);
	mvc_create_column_(m, t, "cache", "bigint", 64);
	mvc_create_column_(m, t, "minvalue", "bigint", 64);
	mvc_create_column_(m, t, "maxvalue", "bigint", 64);
	mvc_create_column_(m, t, "cycle", "boolean", 1);
	/* columns for internal use */
	mvc_create_column_(m, t, "cached", "bigint", 64);
	mvc_create_column_(m, t, "called", "boolean", 1);

	return 0;
}

int
sql_find_seq(mvc *m, str seq)
{
	int res = 0;
	sql_schema *sys = find_sql_schema(m->session->tr, "sys");
	sql_table *seqs = find_sql_table(sys, "sequences");
	sql_column *seqname = find_sql_column(seqs, "name");
	ssize_t rid = column_find_row(m->session->tr, seqname, seq, NULL);

	if (rid >= 0)
		res = 1;
	/* dirty hack don't mark sequences as read (else next value for fails)*/
	seqs->base.rtime = seqname->base.rtime = 0;
	return res;
}

stmt *
sql_create_seq(
		mvc *sql,
		sql_schema *ss,
		dlist *qname,
		sql_subtype *tpe,
		dlist* start_list,
		lng inc,
		lng min,
		lng max,
		lng cache,
		int cycle)
{
	char buf[BUFSIZ];
	char* name = qname_table(qname);
	char* start = NULL, *tmp;
	int start_type = start_list->h->data.ival;

	(void) tpe;
	if (sql_find_seq(sql, name)) {
		return sql_error(sql, 02,
				"CREATE SEQUENCE: "
				"name '%s' already in use", name);
	} else if (!schema_privs(sql->role_id, ss)) {
		return sql_error(sql, 02,
				"CREATE SEQUENCE: insufficient privileges "
				"for '%s' in schema '%s'", stack_get_string(sql, "user"), ss->base.name);
	}

	/* generate defaults */
	if (inc <= 0) inc = 1;
	if (min < 0) min = 0;
	if (cycle && max < 0) cycle = 0;
	if (max < 0) max = 0;
	if (cache <= 0) cache = 1;

	/* create the start subquery */
	if (start_type == -1) {
		start = _strdup("select 1");
	} else if (start_type == 0) {
		/* this is wrong here... (we can't have no argument) */
		assert(start_type != 0);
	} else if (start_type == 1) {
		/* argument is a subquery */
		stmt *sq = NULL;
		symbol* query = start_list->h->next->data.sym;

		if (query->token != SQL_SELECT) {
			return sql_error(sql, 02,
					"CREATE SEQUENCE: subquery must be of type SELECT");
		}

		sq = scope_subquery(sql, NULL, query);
		assert(sq);
		tmp = start = _strdup(QUERY(sql->scanner) + sql->scanner.as - 1);
		tmp += _strlen(start);
		while (*tmp != ';' && tmp >= start) tmp--;
		*tmp = '\0';

		stmt_destroy(sq);
	} else if (start_type == 2) {
		/* argument is simple int */
		snprintf(buf, BUFSIZ, "select %lld",
				start_list->h->next->data.ival);
		start = _strdup(buf);
	}

	assert(start);
	snprintf(buf, BUFSIZ,
		 "insert into \"sys\".\"sequences\" "
		 "(\"name\", \"schema\", \"increment\", \"minvalue\", "
		 		"\"maxvalue\", \"cycle\", \"start\", \"cache\", "
				"\"cached\", \"called\") values "
		 "(    '%s',       '%s',          %lld,         %lld, "
		 		"        %lld,        %s,      (%s),    %lld, "
				"         0,      false); ",
		 name, ss->base.name, inc, min,
		 max, cycle ? "true" : "false", start, cache);
	_DELETE(start);
	return stmt_sql(_strdup(buf));
}

static stmt *
sql_alter_seq(
		mvc *sql,
		sql_schema *ss,
		dlist *qname,
		sql_subtype *tpe,
		dlist* start_list,
		lng inc,
		lng min,
		lng max,
		lng cache,
		int cycle)
{
	int ok = 0;
	void *p;
	char buf[BUFSIZ];
	char* name = qname_table(qname);
	sql_schema *sys = find_sql_schema(sql->session->tr, "sys");
	sql_table *seqs = find_sql_table(sys, "sequences");
	sql_column *col = find_sql_column(seqs, "name");
	ssize_t rid = column_find_row(sql->session->tr, col, name, NULL);
	lng start = -1;
	int start_type = start_list->h->data.ival, called = 0;
	char* cur = NULL, *tmp = NULL;

	(void) tpe;
	if (rid < 0) {
		return sql_error(sql, 02,
				"ALTER SEQUENCE: "
				"no such sequence '%s'", name);
	}
	if (!schema_privs(sql->role_id, ss)) {
		return sql_error(sql, 02,
				"ALTER SEQUENCE: insufficient privileges "
				"for '%s' in schema '%s'", stack_get_string(sql, "user"), ss->base.name);
	}

	/* make sure the in memory sequence structure is flushed */
	ok = sequence_exit(name);
	assert(ok);
	if (!ok)
		return sql_error(sql, 02, "ALTER SEQUENCE: internal error");

	col = find_sql_column(seqs, "start");
	assert(col);
	/* we never change the start value on ALTER thus read the current
	 * value */
	start = *(lng*)(p = column_find_value(sql->session->tr, col, rid)); _DELETE(p);
	/* create the restart subquery */
	if (start_type == -1) {
		/* retain old cur value */
		col = find_sql_column(seqs, "cached");
		assert(col);
		snprintf(buf, BUFSIZ, "select %lld",
				*(lng*)(p=column_find_value(sql->session->tr, col, rid)));
		_DELETE(p);
		cur = _strdup(buf);

		/* also retain called flag */
		col = find_sql_column(seqs, "called");
		assert(col);
		called = *(bit*)(p=column_find_value(sql->session->tr, col, rid));
		_DELETE(p);
	} else if (start_type == 0) {
		/* there is no argument, set cur to start (on next lookup) */
		snprintf(buf, BUFSIZ, "select %lld", start );
		cur = _strdup(buf);
		called = 1;
	} else if (start_type == 1) {
		/* argument is a subquery */
		stmt *sq = NULL;
		symbol* query = start_list->h->next->data.sym;

		if (query->token != SQL_SELECT) {
			return sql_error(sql, 02,
					"CREATE SEQUENCE: subquery must be of type SELECT");
		}

		sq = scope_subquery(sql, NULL, query);
		assert(sq);
		tmp = cur = _strdup(QUERY(sql->scanner) + sql->scanner.as - 1);
		tmp += _strlen(cur);
		while (*tmp != ';' && tmp >= cur) tmp--;
		*tmp = '\0';

		stmt_destroy(sq);

		called = 1;
	} else if (start_type == 2) {
		/* argument is simple int */
		snprintf(buf, BUFSIZ, "select %lld",
				start_list->h->next->data.ival);
		cur = _strdup(buf);

		called = 1;
	}

	/* use values already in there if not supplied */
	col = find_sql_column(seqs, "increment");
	assert(col);
	if (inc <= 0) {
		p = column_find_value(sql->session->tr, col, rid);
		inc = *(lng*)p;
		_DELETE(p);
	}
	col = find_sql_column(seqs, "minvalue");
	assert(col);
	if (min < 0) {
		p = column_find_value(sql->session->tr, col, rid);
		min = *(lng*)p;
		_DELETE(p);
	}
	col = find_sql_column(seqs, "cycle");
	assert(col);
	if (cycle && max < 0) {
		p = column_find_value(sql->session->tr, col, rid);
		cycle = *(bit*)p;
		_DELETE(p);
	}
	col = find_sql_column(seqs, "maxvalue");
	assert(col);
	if (max < 0) { 
		p = column_find_value(sql->session->tr, col, rid);
		max = *(lng*)p;
		_DELETE(p);
	}
	col = find_sql_column(seqs, "cache");
	assert(col);
	if (cache <= 0) { 
		p = column_find_value(sql->session->tr, col, rid);
		cache = *(lng*)p;
		_DELETE(p);
	}

	snprintf(buf, BUFSIZ,
		"update \"sys\".\"sequences\" set "
		"\"start\" = %lld, "
		"\"increment\" = %lld, "
		"\"minvalue\" = %lld, "
		"\"maxvalue\" = %lld, "
		"\"cache\" = %lld, "
		"\"cycle\" = %s, "
		"\"cached\" = (%s), "
		"\"called\" = %s "
		"where \"name\" = '%s' and \"schema\" = '%s';",
		start, inc, min, max, cache, cycle ? "true" : "false",
		cur, called ? "true" : "false",
		name, ss->base.name);
	return stmt_sql(_strdup(buf));
}

static stmt *
sql_drop_seq(mvc *sql, sql_schema *ss, dlist *qname)
{
	int ok = 0;
	char buf[BUFSIZ];
	char *name = qname_table(qname);

	if (!sql_find_seq(sql, name)) {
		return sql_error(sql, 02, "DROP SEQUENCE: no such sequence '%s'", name);
	} else if (!schema_privs(sql->role_id, ss)) {
		return sql_error(sql, 02, "DROP SEQUENCE: insufficient privileges for '%s' in schema '%s'", stack_get_string(sql, "user"),  ss->base.name);
	}
	/* make sure the in memory sequence structure is flushed */
	ok = sequence_exit(name);
	assert(ok);
	if (!ok)
		return sql_error(sql, 02, "DROP SEQUENCE: internal error");
	snprintf(buf, BUFSIZ, "delete from \"sys\".\"sequences\" where \"name\" = '%s';", name);
	return stmt_sql(_strdup(buf));
}

char*
sql_next_seq_name(mvc *m)
{
	char buf[BUFSIZ + 1];

	snprintf(buf, BUFSIZ, "seq_%d\"\"\"", store_next_oid());
	buf[BUFSIZ] = '\0';

	/* waring: using sa_strdup here */
	return(sa_strdup(m->sa, buf));
}

stmt *
sequences(mvc *sql, symbol *s)
{
	stmt *res = NULL;

	sql->type = Q_SCHEMA; 
	switch (s->token) {
		case SQL_CREATE_SEQ:
		{
			dlist *l = s->data.lval;
			dlist *h = l->h->next->next->data.lval;

			res = sql_create_seq(
/* mvc* sql */		sql,
/* sql_schema* s */	cur_schema(sql), 
/* dlist* qname */	l->h->data.lval, 
/* sql_subtype* t*/	&l->h->next->data.typeval, 
/* dlist start */	h->h->data.lval, 
/* lng inc */		h->h->next->data.ival, 
/* lng min */		h->h->next->next->data.ival, 
/* lng max */		h->h->next->next->next->data.ival,
/* lng cache */		h->h->next->next->next->next->data.ival,
/* int cycle */		h->h->next->next->next->next->next->data.ival);
		}
		break;
		case SQL_ALTER_SEQ:
		{
			dlist* l = s->data.lval;
			dlist *h = l->h->next->next->data.lval;
			
			res = sql_alter_seq(
/* mvc* sql */		sql,
/* sql_schema* s */	cur_schema(sql), 
/* dlist* qname */	l->h->data.lval, 
/* sql_subtype* t*/	&l->h->next->data.typeval, 
/* dlist start */	h->h->data.lval, 
/* lng inc */		h->h->next->data.ival, 
/* lng min */		h->h->next->next->data.ival, 
/* lng max */		h->h->next->next->next->data.ival,
/* lng cache */		h->h->next->next->next->next->data.ival,
/* int cycle */		h->h->next->next->next->next->next->data.ival);
		}
		break;
		case SQL_DROP_SEQ:
		{
			dlist *l = s->data.lval;
			res = sql_drop_seq(sql, cur_schema(sql), l->h->data.lval);
		}
		break;
		default:
			return sql_error(sql, 01, "sql_stmt Symbol(%ld)->token = %s", (long) s, token2string(s->token));
	}
	return res;
}
