@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
@' Copyright August 2008-2009 MonetDB B.V.
@' All Rights Reserved.

@f sql_env
@a N.J. Nes
@* Environment variables
The processing setting of the SQL front-end can collect information
for postprocessing and debugging by setting a flag
using the SQL construct: 
SET <variable>=<string> 
SET <variable>=<boolean>
SET <variable>=<int>

The SQL engine comes with a limited set of environment variables
to control its behavior. 
The 'debug' variable takes an integer and sets the Mserver global
debug flag. (See MonetDB documentation.)

By default all remaining variables are stored as strings and 
any type analysis is up to the user. The can be freely used by the
SQL programmer for inclusion in his queries. 

The limited number of built-in variables defined above are 
strongly typed the hard way.
Moreover, they have a counterpart representation in the 
MVC structure to ease inspection during query processing.

The variables can be retrieved using the table producing function var();
@{
@h
#ifndef _SQL_ENV_H_
#define _SQL_ENV_H_

#include "sql_parser.h"
#include "sql_symbol.h"
#include "sql_statement.h"
#include "sql_mvc.h"

extern int mvc_debug_on(mvc *m, int flag);

extern str sql_update_var(mvc *sql, char *name);

extern int sql_create_env(mvc *sql, sql_schema *s);

#define NR_KEEPQUERY_ARGS 4
#define NR_KEEPCALL_ARGS 10

#endif /* _SQL_ENV_H_ */
@c
#include "sql_config.h"
#include "sql_env.h"
#include "sql_updates.h"
#include "sql_semantic.h"
#include "sql_privileges.h"

#define SESSION_RW 0
#define SESSION_RO 1

int
mvc_debug_on(mvc *m, int flg)
{

	if (m->debug & flg)
		return 1;

	return 0;
}

str
sql_update_var(mvc *m, char *name)
{
	lng sgn;
	if (strcmp(name, "debug") == 0) {
		sgn = stack_get_number(m, "debug");
		assert((lng) GDK_int_min <= sgn && sgn <= (lng) GDK_int_max);
		m->debug = (int) sgn;
	} else if (strcmp(name, "current_schema") == 0) {
		char *schema = stack_get_string(m, "current_schema");

		if (!mvc_set_schema(m, schema)) {
			return sql_message( "Schema (%s) missing\n", schema);
		}
	} else if (strcmp(name, "current_role") == 0) {
		char *role = stack_get_string(m, "current_role");

		if (!mvc_set_role(m, role)) {
			return sql_message( "Role (%s) missing\n", role);
		}
	} else if (strcmp(name, "current_timezone") == 0) {
		sgn = stack_get_number(m, "current_timezone") / 60;
		assert((lng) GDK_int_min <= sgn && sgn <= (lng) GDK_int_max);
		m->timezone = (int) sgn;
	} else if (strcmp(name, "cache") == 0) {
		sgn = stack_get_number(m, "cache");
		assert((lng) GDK_int_min <= sgn && sgn <= (lng) GDK_int_max);
		m->cache = (int) sgn;
	} else if (strcmp(name, "history") == 0) {
		sql_schema *sys = mvc_bind_schema(m, "sys");

		sgn = stack_get_number(m, "history");
		assert((lng) GDK_int_min <= sgn && sgn <= (lng) GDK_int_max);
		if (!sql_find_func(sys, "keepquery", NR_KEEPQUERY_ARGS) ||
		    !sql_find_func(sys, "keepcall", NR_KEEPCALL_ARGS))
			return sql_message( "Cannot activate history because the keepQuery and keepCall procedures are not available\n" ); 
		m->history = (int) (sgn)?1:0;
	} else if (strcmp(name, "optimizer") == 0) {
		str optimizer =stack_get_string(m,"optimizer");
		str pipe=GDKgetenv(optimizer);
		if ( optimizer == NULL || *optimizer == 0)
			return NULL;
		if ( pipe == NULL && strcmp(optimizer,"off"))
			return sql_message( "Optimizer pipeline not known\n");
	}
	return NULL;
}


int
sql_create_env(mvc *m, sql_schema *s)
{
	list *l;
	/* here we create a new table-type */
	sql_subtype tpe;
	sql_table *

	t = mvc_create_generated(m, s, "#env", NULL, 1);
	mvc_create_column_(m, t, "name", "varchar", 1024);
	mvc_create_column_(m, t, "value", "varchar", 2048);

	sql_find_subtype(&tpe, "table", 0, 0);
	tpe.comp_type = t;
	tpe.digits = t->base.id; /* pass the table through digits */

	/* add function */
	l = list_create((fdestroy) &arg_destroy);
	mvc_create_func(m, s, "env", l, &tpe, FALSE, FALSE, "sql", "sql_environment", 1);
	list_destroy(l);

	t = mvc_create_generated(m, s, "#var", NULL, 1);
	mvc_create_column_(m, t, "name", "varchar", 1024);

	sql_find_subtype(&tpe, "table", 0, 0);
	tpe.comp_type = t;
	tpe.digits = t->base.id; /* pass the table through digits */

	/* add function */
	l = list_create((fdestroy) &arg_destroy);
	mvc_create_func(m, s, "var", l, &tpe, FALSE, FALSE, "sql", "sql_variables", 1);
	list_destroy(l);
	return 0;
}
@}
