@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2005 CWI.
@' All Rights Reserved.

@f sql_updates
@a N.J. Nes
@* 

@h
#ifndef _SQL_UPDATES_H_
#define _SQL_UPDATES_H_

#include <stdio.h>
#include <stdarg.h>
#include <sql_list.h>
#include "sql_symbol.h"
#include "sql_scope.h"
#include "sql_statement.h"

extern stmt *updates(mvc *sql, symbol *sym);

extern void cleanup_stmts(stmt **stmts, int cnt);
extern stmt *sql_insert(mvc *sql, sql_table *t, stmt **inserts, int len, int output);
extern stmt *sql_insert_add_idx(mvc *sql, sql_table *t, sql_idx * idx, list *l);
extern stmt *sql_delete(mvc *sql, tvar *tv, sql_table *t, stmt *s, int output);
extern stmt *sql_update(mvc *sql, sql_table *t, stmt **updates, list *l);
extern stmt *output_value(stmt *s);

#endif /*_SQL_UPDATES_H_*/
@c

#include "sql_config.h"
#include "sql_updates.h"
#include "sql_parser.h"
#include "sql_scope.h"
#include "sql_semantic.h"
#include "sql_select.h"
#include "sql_privileges.h"

stmt *
output_value(stmt *s)
{
	return stmt_output(stmt_list(list_append(create_stmt_list(), stmt_alias(s, _strdup("affected"), _strdup("rows")))));
}

static stmt *
insert_value(mvc *sql, scope *scp, sql_column *c, symbol *s)
{
	if (s->token == SQL_NULL) {
		atom *a = atom_general(sql_dup_subtype(c->type), NULL, 0);

		return stmt_atom(a);
	} else {
		stmt *n = NULL;
		stmt *a = sql_value_exp(sql, scp, s, NULL, NULL, sql_sel);

		if (!a)
			return(NULL);
			
		if (!(n = check_types(sql, c->type, a, type_dyncheck))) {
			return NULL;
		}
		return n;
	}
	return NULL;
}

void
cleanup_stmts(stmt **stmts, int cnt)
{
	int i;

	for (i = 0; i < cnt; i++) {
		if (stmts[i])
			stmt_destroy(stmts[i]);
	}
	_DELETE(stmts);
}


static stmt *
insert_check_ukey(mvc *sql, stmt **inserts, sql_key *k, stmt *idx_inserts)
{
/* pkey's cannot have NULLs, ukeys however can
   current implementation switches on 'NOT NULL' on primary key columns */

	char buf[BUFSIZ];
	stmt *res;

	sql_subtype *it = sql_bind_localtype("int");
	sql_subtype *lt = sql_bind_localtype("lng");
	sql_subaggr *cnt = sql_bind_aggr(sql->trans->module, "count", NULL);
	sql_subtype *bt = sql_bind_localtype("bit");

	if (list_length(k->columns) > 1) {
		node *m;
		stmt *s = inserts[0]->op2.stval;
		sql_subaggr *sum;
		stmt *count_sum = NULL;
		sql_subfunc *ne = sql_bind_func_result(sql->trans->module, "<>", it, it, bt);

		/* 1st stage: find out if original contains same values */
		if (s->key && s->nrcols == 0) {
			s = stmt_relselect_init();
			stmt_relselect_fill(s, stmt_uselect(stmt_idxbat(k->idx, 0), stmt_dup(idx_inserts), cmp_equal));
			for (m = k->columns->h; m; m = m->next) {
				sql_kc *c = m->data;

				stmt_relselect_fill(s, stmt_uselect(stmt_dup(inserts[c->c->colnr]->op1.stval), stmt_dup(inserts[c->c->colnr]->op2.stval), cmp_equal));
			}
		} else {
			s = stmt_reljoin_init();
			stmt_reljoin_fill(s, stmt_idxbat(k->idx, 0), stmt_dup(idx_inserts));
			for (m = k->columns->h; m; m = m->next) {
				sql_kc *c = m->data;

				stmt_reljoin_fill(s, stmt_dup(inserts[c->c->colnr]->op1.stval), stmt_dup(inserts[c->c->colnr]->op2.stval));
			}
		}
		s = stmt_binop(stmt_aggr(s, NULL, cnt), stmt_atom_int(0), ne);

		/* 2e stage: find out if inserted are unique */
		if (idx_inserts->nrcols) {	/* insert columns not atoms */
			group *g = NULL;
			stmt *ss;
			sql_subfunc *or = sql_bind_func_result(sql->trans->module, "or", bt, bt, bt);

			for (m = k->columns->h; m; m = m->next) {
				sql_kc *c = m->data;

				g = grp_create(stmt_dup(inserts[c->c->colnr]->op2.stval), g, NULL);
			}
			ss = stmt_aggr(stmt_dup(g->grp), grp_dup(g), sql_dup_aggr(cnt));
			grp_destroy(g);
			/* (count(ss) <> sum(ss)) */
			sum = sql_bind_aggr(sql->trans->module, "sum", tail_type(ss));
			count_sum = stmt_binop(check_types(sql, lt, stmt_aggr(stmt_dup(ss), NULL, sql_dup_aggr(cnt)), type_equal), check_types(sql, lt, stmt_aggr(ss, NULL, sum), type_equal), sql_dup_func(ne));

			/* combine results */
			s = stmt_binop(s, count_sum, or);
		}

		if (k->type == pkey) {
			snprintf(buf, BUFSIZ, "INSERT INTO: PRIMARY KEY constraint %s.%s violated", k->t->base.name, k->base.name);
		} else {
			snprintf(buf, BUFSIZ, "INSERT INTO: UNIQUE constraint %s.%s violated", k->t->base.name, k->base.name);
		}
		res = stmt_exception(s, _strdup(buf), 00001);
	} else {		/* single column key */
		sql_kc *c = k->columns->h->data;
		stmt *h = stmt_dup(inserts[c->c->colnr]->op2.stval);
		stmt *s = stmt_dup(inserts[c->c->colnr]->op1.stval);

		if (h->nrcols) {
			s = stmt_join(s, stmt_reverse(h), cmp_equal);
		} else {
			s = stmt_uselect(s, h, cmp_equal);
		}
		/* s should be empty */
		if (k->type == pkey) {
			snprintf(buf, BUFSIZ, "INSERT INTO: PRIMARY KEY constraint %s.%s violated", k->t->base.name, k->base.name);
		} else {
			snprintf(buf, BUFSIZ, "INSERT INTO: UNIQUE constraint %s.%s violated", k->t->base.name, k->base.name);
		}
		res = stmt_exception(stmt_aggr(s, NULL, cnt), _strdup(buf), 00001);
	}
	return res;
}

static stmt *
insert_check_fkey(mvc *sql, stmt **inserts, sql_key *k, stmt *idx_inserts)
{
	char buf[BUFSIZ];
	stmt *s = inserts[0]->op2.stval;
	sql_subtype *it = sql_bind_localtype("int");
	sql_subaggr *cnt = sql_bind_aggr(sql->trans->module, "count", NULL);
	sql_subtype *bt = sql_bind_localtype("bit");
	sql_subfunc *ne = sql_bind_func_result(sql->trans->module, "<>", it, it, bt);

	(void) sql;		/* unused! */

	if (s->key && s->nrcols == 0) {
		s = stmt_binop(stmt_aggr(stmt_dup(idx_inserts), NULL, cnt), stmt_atom_int(1), ne);
	} else {
		/* reljoin.count <> inserts[col1].count */
		stmt *ins = stmt_dup(inserts[0]->op2.stval);

		s = stmt_binop(stmt_aggr(stmt_dup(idx_inserts), NULL, cnt), stmt_aggr(ins, NULL, sql_dup_aggr(cnt)), ne);
	}

	/* s should be empty */
	snprintf(buf, BUFSIZ, "INSERT INTO: FOREIGN KEY constraint %s.%s violated", k->t->base.name, k->base.name);
	return stmt_exception(s, _strdup(buf), 00001);
}

static stmt *
sql_insert_key(mvc *sql, stmt **inserts, sql_key *k, stmt *idx_inserts)
{
	/* int insert = 1;
	 * while insert and has u/pkey and not defered then
	 *      if u/pkey values exist then
	 *              insert = 0
	 * while insert and has fkey and not defered then
	 *      find id of corresponding u/pkey  
	 *      if (!found)
	 *              insert = 0
	 * if insert
	 *      insert values
	 *      insert fkey/pkey index
	 */
	if (k->type == pkey || k->type == ukey) {
		return insert_check_ukey(sql, inserts, k, idx_inserts);
	} else {		/* foreign keys */
		return insert_check_fkey(sql, inserts, k, idx_inserts);
	}
}

static stmt *
hash_insert(mvc *sql, sql_idx * i, stmt **inserts)
{
	node *m;
	sql_subtype *it;
	int bits = 0;
	stmt *h = NULL;

	if (list_length(i->columns) <= 1)
		return NULL;

	it = sql_bind_localtype("int");
	for (m = i->columns->h; m; m = m->next, bits += 8) {
		sql_kc *c = m->data;
		sql_subfunc *hf = sql_bind_func_result(sql->trans->module, "hash", c->c->type, it, it);

		if (h) {
			sql_subfunc *xor = sql_bind_func_result(sql->trans->module, "xor", it, it, it);

			h = stmt_binop(h, stmt_binop(stmt_dup(inserts[c->c->colnr]->op2.stval), stmt_atom_int(bits), hf), xor);
		} else {
			h = stmt_binop(stmt_dup(inserts[c->c->colnr]->op2.stval), stmt_atom_int(bits), hf);
		}
	}
	return h;
}

static stmt *
join_idx_insert(mvc *sql, sql_idx * i, stmt **inserts)
{
	node *m, *o;
	sql_idx *ri = ((sql_fkey *) i->key)->rkey->k.idx;
	stmt *rts = stmt_basetable(ri->t, ri->t->base.name);
	stmt *s = inserts[0]->op2.stval;

	if (s->key && s->nrcols == 0) {
		sql_subtype *bt = sql_bind_localtype("bit");
		sql_subfunc *or = sql_bind_func_result(sql->trans->module, "or", bt, bt, bt);
		int nulls = 0;
		stmt *cond = NULL;

		s = stmt_relselect_init();
		for (m = i->columns->h, o = ri->columns->h; m && o; m = m->next, o = o->next) {
			sql_kc *c = m->data;
			sql_kc *rc = o->data;

			stmt_relselect_fill(s, stmt_uselect(stmt_dup(stmt_cbat(rc->c, stmt_dup(rts), 0, st_bat)), stmt_dup(inserts[c->c->colnr]->op2.stval), cmp_equal));

			if (c->c->null) {
				sql_subfunc *isnil = sql_bind_func(sql->trans->module, "isnull", c->c->type, NULL);
				stmt *ins = stmt_dup(inserts[c->c->colnr]->op2.stval);

				ins = stmt_unop(ins, isnil);
				if (!cond) {
					cond = ins;
				} else {
					cond = stmt_binop(cond, ins, sql_dup_func(or));
				}

				nulls = 1;
			}
		}
		sql_subfunc_destroy(or);

		s = stmt_mark(stmt_reverse(s), 0);
		/* add missing nulls (and NULLs only (SIMPLE MATCH)) */
		if (nulls) {
			stmt *t = stmt_temp(sql_dup_subtype(bt));
			stmt *isnull = stmt_temp(sql_dup_subtype(tail_type(s)));
			stmt *notnull = s;

			isnull = stmt_append(isnull, stmt_atom(atom_general(sql_dup_subtype(tail_type(s)), NULL, 0)));
			t = stmt_append(t, cond);
			isnull = stmt_join(t, stmt_reverse(stmt_const(stmt_reverse(isnull), stmt_bool(1))), cmp_equal);
			notnull = stmt_join(stmt_dup(t), stmt_reverse(stmt_const(stmt_reverse(notnull), stmt_bool(0))), cmp_equal);
			s = stmt_union(isnull, notnull);
		}
	} else {
		int nulls = 0;

		s = stmt_reljoin_init();
		for (m = i->columns->h, o = ri->columns->h; m && o; m = m->next, o = o->next) {
			sql_kc *c = m->data;
			sql_kc *rc = o->data;

			stmt_reljoin_fill(s, stmt_dup(inserts[c->c->colnr]->op2.stval), stmt_dup(stmt_cbat(rc->c, stmt_dup(rts), 0, st_bat)));
			if (c->c->null)
				nulls = 1;
		}
		/* add missing nulls (and NULLs only (SIMPLE MATCH)) */
		if (nulls) {
			stmt *cur = NULL, *missing = stmt_diff(stmt_dup(inserts[0]->op2.stval),
							       stmt_dup(s));

			for (m = i->columns->h; m; m = m->next) {

				sql_kc *c = m->data;
				sql_subfunc *isnil = sql_bind_func(sql->trans->module, "isnull",
								   c->c->type, NULL);

				stmt *n;

				n = stmt_dup(inserts[c->c->colnr]->op2.stval);
				n = stmt_semijoin(n, stmt_dup(missing));
				n = stmt_unop(n, isnil);
				n = stmt_uselect(n, stmt_bool(1), cmp_equal);
				if (cur)
					cur = stmt_semijoin(cur, n);
				else
					cur = n;
			}
			stmt_destroy(missing);
			s = stmt_union(s, stmt_const(cur, stmt_atom(atom_general(sql_dup_subtype(sql_bind_localtype("oid")), NULL, 0))));
		}
		s = stmt_reverse(stmt_order(stmt_reverse(s), 1));

	}
	stmt_destroy(rts);
	return s;
}

static void
sql_insert_idx(mvc *sql, stmt **inserts, sql_idx * i, list *l)
{
	stmt *is = NULL;

	if (i->type == unique) {
		is = hash_insert(sql, i, inserts);
	} else if (i->type == join_idx) {
		is = join_idx_insert(sql, i, inserts);
	}
	if (i->key) {
		stmt *ckeys = sql_insert_key(sql, inserts, i->key, is);

		list_prepend(l, ckeys);
	}
	/* append to the pre-computed join-index */
	if (is)
		list_append(l, stmt_append(stmt_idxbat(i, 1), is));
}

static int
sql_insert_idxs(mvc *sql, sql_table *t, stmt **inserts, list *l)
{
	node *n;
	int res = 1;

	if (!t->idxs.set)
		return res;

	for (n = t->idxs.set->h; n; n = n->next) {
		sql_idx *i = n->data;

		sql_insert_idx(sql, inserts, i, l);
	}
	return res;
}

stmt *
sql_insert_add_idx(mvc *sql, sql_table *t, sql_idx * idx, list *l)
{
	stmt **inserts;
	node *m;
	int i, len = list_length(t->columns.set);
	stmt *ts = stmt_basetable(t, t->base.name);

	inserts = NEW_ARRAY(stmt *, len);

	for (m = t->columns.set->h, i = 0; m; m = m->next, i++) {
		sql_column *c = m->data;
		stmt *b = stmt_cbat(c, stmt_dup(ts), UPD, st_bat);
		sql_subtype *tp = sql_dup_subtype(tail_type(b));

		inserts[i] = stmt_append(stmt_temp(tp), b);
	}
	stmt_destroy(ts);
	sql_insert_idx(sql, inserts, idx, l);
	cleanup_stmts(inserts, len);
	return stmt_list(l);
}

static int
is_idx_updated(sql_idx * i, stmt **updates)
{
	int update = 0;
	node *m;

	for (m = i->columns->h; m; m = m->next) {
		sql_kc *ic = m->data;

		if (updates[ic->c->colnr]) {
			update = 1;
			break;
		}
	}
	return update;
}

static int
first_updated_col(stmt **updates, int cnt)
{
	int i;

	for (i = 0; i < cnt; i++) {
		if (updates[i])
			return i;
	}
	return -1;
}

static stmt *
update_check_ukey(mvc *sql, stmt **updates, sql_key *k, stmt *idx_updates, int updcol)
{
	char buf[BUFSIZ];
	stmt *res = NULL;

	sql_subtype *it = sql_bind_localtype("int");
	sql_subaggr *cnt = sql_bind_aggr(sql->trans->module, "count", NULL);
	sql_subtype *bt = sql_bind_localtype("bit");
	sql_subfunc *ne;

	if (list_length(k->columns) > 1 && !idx_updates)
		return NULL;

	ne = sql_bind_func_result(sql->trans->module, "<>", it, it, bt);
	if (list_length(k->columns) > 1) {
		stmt *ts = stmt_basetable(k->t, k->t->base.name);
		node *m;
		stmt *s;

		/* 1st stage: find out if original contains same values */
		s = stmt_reljoin_init();
		stmt_reljoin_fill(s, stmt_diff(stmt_idxbat(k->idx, 0), stmt_dup(idx_updates)), stmt_dup(idx_updates));
		for (m = k->columns->h; m; m = m->next) {
			sql_kc *c = m->data;
			stmt *upd, *l;

			if (updates[c->c->colnr]) {
				upd = stmt_dup(updates[c->c->colnr]->op2.stval);
				l = stmt_dup(updates[c->c->colnr]->op1.stval);
			} else {
				upd = stmt_dup(updates[updcol]->op2.stval);
				upd = stmt_semijoin(stmt_cbat(c->c, stmt_dup(ts), RDONLY, st_bat), upd);
				l = stmt_dup(upd);
			}
			stmt_reljoin_fill(s, l, upd);

		}
		s = stmt_binop(stmt_aggr(s, NULL, cnt), stmt_atom_int(0), ne);

		/* 2e stage: find out if updated are unique */
		if (idx_updates->nrcols) {	/* update columns not atoms */
			sql_subaggr *sum;
			stmt *count_sum = NULL;
			group *g = NULL;
			stmt *ss;
			sql_subfunc *or = sql_bind_func_result(sql->trans->module, "or", bt, bt, bt);

			for (m = k->columns->h; m; m = m->next) {
				sql_kc *c = m->data;
				stmt *upd;

				if (updates[c->c->colnr]) {
					upd = stmt_dup(updates[c->c->colnr]->op2.stval);
				} else {
					upd = stmt_dup(updates[updcol]->op2.stval);
					upd = stmt_semijoin(stmt_cbat(c->c, stmt_dup(ts), RDONLY, st_bat), upd);
				}
				g = grp_create(upd, g, NULL);
			}
			ss = stmt_aggr(stmt_dup(g->grp), grp_dup(g), sql_dup_aggr(cnt));
			grp_destroy(g);
			/* (count(ss) <> sum(ss)) */
			sum = sql_bind_aggr(sql->trans->module, "sum", tail_type(ss));
			count_sum = stmt_binop(stmt_aggr(stmt_dup(ss), NULL, sql_dup_aggr(cnt)), check_types(sql, it, stmt_aggr(ss, NULL, sum), type_equal), sql_dup_func(ne));

			/* combine results */
			s = stmt_binop(s, count_sum, or);
		}

		if (k->type == pkey) {
			snprintf(buf, BUFSIZ, "UPDATE: PRIMARY KEY constraint %s.%s violated", k->t->base.name, k->base.name);
		} else {
			snprintf(buf, BUFSIZ, "UPDATE: UNIQUE constraint %s.%s violated", k->t->base.name, k->base.name);
		}
		res = stmt_exception(s, _strdup(buf), 00001);
	} else {		/* single column key */
		sql_kc *c = k->columns->h->data;
		stmt *h = stmt_dup(updates[c->c->colnr]->op2.stval);
		stmt *o = stmt_diff(stmt_dup(updates[c->c->colnr]->op1.stval), stmt_dup(h));
		stmt *s = stmt_join(o, stmt_reverse(h), cmp_equal);

		/* s should be empty */
		s = stmt_binop(stmt_aggr(s, NULL, cnt), stmt_atom_int(0), ne);

		/* 2e stage: find out if updated are unique */
		if (h->nrcols) {	/* update columns not atoms */
			sql_subaggr *sum;
			stmt *count_sum = NULL;
			sql_subfunc *or = sql_bind_func_result(sql->trans->module, "or", bt, bt, bt);
			stmt *ssum;

			stmt *upd = stmt_dup(updates[c->c->colnr]->op2.stval);
			group *g = grp_create(upd, NULL, NULL);
			stmt *ss = stmt_aggr(stmt_dup(g->grp), g, sql_dup_aggr(cnt));

			/* (count(ss) <> sum(ss)) */
			sum = sql_bind_aggr(sql->trans->module, "sum", tail_type(ss));
			ssum = stmt_aggr(ss, NULL, sum);
			count_sum = stmt_binop(check_types(sql, tail_type(ssum), stmt_aggr(stmt_dup(ss), NULL, sql_dup_aggr(cnt)), type_equal), ssum, sql_dup_func(ne));

			/* combine results */
			s = stmt_binop(s, count_sum, or);
		}

		if (k->type == pkey) {
			snprintf(buf, BUFSIZ, "UPDATE: PRIMARY KEY constraint %s.%s violated", k->t->base.name, k->base.name);
		} else {
			snprintf(buf, BUFSIZ, "UPDATE: UNIQUE constraint %s.%s violated", k->t->base.name, k->base.name);
		}
		res = stmt_exception(s, _strdup(buf), 00001);
	}
	return res;
}

static stmt *
update_check_fkey(mvc *sql, stmt **updates, sql_key *k, stmt *idx_updates, int updcol)
{
	char buf[BUFSIZ];
	stmt *s;
	sql_subtype *it = sql_bind_localtype("int");
	sql_subaggr *cnt = sql_bind_aggr(sql->trans->module, "count", NULL);
	sql_subtype *bt = sql_bind_localtype("bit");
	sql_subfunc *ne = sql_bind_func_result(sql->trans->module, "<>", it, it, bt);
	stmt *cur;

	if (!idx_updates)
		return NULL;
	(void) sql;		/* unused! */
	/* reljoin.count <> updates[updcol].count */
	cur = stmt_dup(updates[updcol]->op2.stval);
	s = stmt_binop(stmt_aggr(stmt_dup(idx_updates), NULL, cnt), stmt_aggr(cur, NULL, sql_dup_aggr(cnt)), ne);

	/* s should be empty */
	snprintf(buf, BUFSIZ, "UPDATE: FOREIGN KEY constraint %s.%s violated", k->t->base.name, k->base.name);
	return stmt_exception(s, _strdup(buf), 00001);
}

static stmt *
sql_update_key(mvc *sql, stmt **updates, sql_key *k, stmt *idx_updates, int updcol)
{
	if (k->type == pkey || k->type == ukey) {
		return update_check_ukey(sql, updates, k, idx_updates, updcol);
	} else {		/* foreign keys */
		return update_check_fkey(sql, updates, k, idx_updates, updcol);
	}
}

static stmt *
hash_update(mvc *sql, sql_idx * i, stmt **updates, int updcol)
{
	/* calculate new value */
	node *m;
	sql_subtype *it;
	int bits = 0;
	stmt *h = NULL, *ts;

	if (list_length(i->columns) <= 1)
		return NULL;

	ts = stmt_basetable(i->t, i->t->base.name);
	it = sql_bind_localtype("int");
	for (m = i->columns->h; m; m = m->next, bits += 8) {
		sql_kc *c = m->data;
		sql_subfunc *hf = sql_bind_func_result(sql->trans->module, "hash", c->c->type, it, it);
		stmt *upd;

		if (updates[c->c->colnr]) {
			upd = stmt_dup(updates[c->c->colnr]->op2.stval);
		} else {
			upd = stmt_dup(updates[updcol]->op2.stval);
			upd = stmt_semijoin(stmt_cbat(c->c, stmt_dup(ts), RDONLY, st_bat), upd);
		}

		if (h) {
			sql_subfunc *xor = sql_bind_func_result(sql->trans->module, "xor", it, it, it);

			h = stmt_binop(h, stmt_binop(upd, stmt_atom_int(bits), hf), xor);
		} else {
			h = stmt_binop(upd, stmt_atom_int(bits), hf);
		}
	}
	stmt_destroy(ts);
	return h;
}

static stmt *
join_idx_update(sql_idx * i, stmt **updates, int updcol)
{
	int nulls = 0;
	node *m, *o;
	sql_idx *ri = ((sql_fkey *) i->key)->rkey->k.idx;
	stmt *s = NULL, *rts = stmt_basetable(ri->t, ri->t->base.name), *ts;
	stmt *null = NULL;

	ts = stmt_basetable(i->t, i->t->base.name);
	s = stmt_reljoin_init();
	for (m = i->columns->h, o = ri->columns->h; m && o; m = m->next, o = o->next) {
		sql_kc *c = m->data;
		sql_kc *rc = o->data;
		stmt *upd;

		if (updates[c->c->colnr]) {
			upd = stmt_dup(updates[c->c->colnr]->op2.stval);
		} else {
			upd = stmt_dup(updates[updcol]->op2.stval);
			upd = stmt_semijoin(stmt_cbat(c->c, stmt_dup(ts), RDONLY, st_bat), upd);
		}
		if (c->c->null) {	/* new nulls (MATCH SIMPLE) */
			stmt *nn = stmt_dup(upd);

			nn = stmt_uselect(nn, stmt_atom(atom_general(sql_dup_subtype(c->c->type), NULL, 0)), cmp_equal);
			if (null)
				null = stmt_semijoin(null, nn);
			else
				null = nn;
			nulls = 1;
		}
		stmt_reljoin_fill(s, upd, stmt_dup(stmt_cbat(rc->c, stmt_dup(rts), 0, st_bat)));

	}
	/* add missing nulls */
	if (nulls)
		s = stmt_union(s, stmt_const(null, stmt_atom(atom_general(sql_dup_subtype(sql_bind_localtype("oid")), NULL, 0))));

	stmt_destroy(ts);
	stmt_destroy(rts);
	return s;
}

static int
sql_update_idxs(mvc *sql, sql_table *t, stmt **updates, list *l)
{
	int res = 1;
	node *n;
	int updcol;

	if (!t->idxs.set)
		return res;

	updcol = first_updated_col(updates, list_length(t->columns.set));
	for (n = t->idxs.set->h; n; n = n->next) {
		sql_idx *i = n->data;
		stmt *is = NULL;

		/* check if update is needed, 
		 * ie atleast on of the idx columns is updated 
		 */
		if (is_idx_updated(i, updates) == 0)
			continue;

		if (i->type == unique) {
			is = hash_update(sql, i, updates, updcol);
		} else if (i->type == join_idx) {
			is = join_idx_update(i, updates, updcol);
		}
		if (i->key) {
			stmt *ckeys = sql_update_key(sql, updates, i->key, is, updcol);

			if (ckeys)
				list_prepend(l, ckeys);
		}
		if (is)
			list_append(l, stmt_replace(stmt_idxbat(i, 1), is));
	}
	return res;
}

stmt *
sql_insert(mvc *sql, sql_table *t, stmt **inserts, int len, int output)
{
	char buf[BUFSIZ];
	int i;
	list *l = create_stmt_list();
	node *n;
	sql_subaggr *cnt = sql_bind_aggr(sql->trans->module, "count", NULL);
	stmt *s = NULL;

	if (!sql_insert_idxs(sql, t, inserts, l)) {
		return sql_error(sql, 02, "Inserting into indexes failed for table %s", t->base.name);
	}

	for (n = t->columns.set->h; n; n = n->next) {
		sql_column *c = n->data;

		if (!inserts[c->colnr]) {
			list_destroy(l);
			sql_subaggr_destroy(cnt);
			return NULL;
		}
		if (!c->null) {
			stmt *s = inserts[c->colnr]->op2.stval;

			if (!(s->key && s->nrcols == 0)) {
				s = stmt_atom(atom_general(sql_dup_subtype(c->type), NULL, 0));
				s = stmt_uselect(stmt_dup(inserts[c->colnr]->op2.stval), s, cmp_equal);
				s = stmt_aggr(s, NULL, sql_dup_aggr(cnt));
			} else {
				sql_subfunc *isnil = sql_bind_func(sql->trans->module, "isnull", c->type, NULL);

				s = stmt_unop(stmt_dup(inserts[c->colnr]->op2.stval), isnil);
			}
			snprintf(buf, BUFSIZ, "INSERT INTO: NOT NULL constraint violated for column %s.%s", c->t->base.name, c->base.name);
			s = stmt_exception(s, _strdup(buf), 00001);

			list_prepend(l, s);
		}
	}

	sql_subaggr_destroy(cnt);
	for (i = 0; i < len; i++)
		list_append(l, stmt_dup(inserts[i]));

	if (output) {
		if (inserts[0]->op2.stval->nrcols == 0) {
			s = stmt_atom_int(1);
		} else {
			s = stmt_aggr(stmt_dup(inserts[0]->op2.stval), NULL, sql_bind_aggr(sql->trans->module, "count", NULL));
		}
		list_append(l, output_value(s));
	}
	return stmt_list(l);
}

static stmt *
insert_into(mvc *sql, dlist *qname, dlist *columns, symbol *val_or_q)
{
	int inscol = 0;
	scope *scp;
	tvar *tv = NULL;

	sql_schema *s = qname_schema(sql, qname);
	char *tname = qname_table(qname);
	sql_table *t;
	list *collist = NULL;
	int i, len = 0;
	stmt **inserts, *res = NULL;

	if (!s || (t = mvc_bind_table(sql, s, tname)) == NULL) {
		return sql_error(sql, 02, "Inserting into non existing table %s", tname);
	} else if (!t->table) {
		return sql_error(sql, 02, "Cannot insert into the view %s", tname);
	}
	if (!table_privs(sql, t, PRIV_INSERT)) {
		return sql_error(sql, 02, "User is not allowed to insert into table %s", tname);
	}
	if (columns) {
		dnode *n;

		collist = list_create((fdestroy) NULL);
		for (n = columns->h; n; n = n->next) {
			sql_column *c = mvc_bind_column(sql, t, n->data.sval);

			if (c) {
				list_append(collist, c);
			} else {
				return sql_error(sql, 02, "Inserting into non existing column %s.%s", tname, n->data.sval);
			}
		}
	} else {
		collist = t->columns.set;
	}

	len = list_length(t->columns.set);
	inserts = NEW_ARRAY(stmt *, len);

	for (i = 0; i < len; i++)
		inserts[i] = NULL;

	scp = scope_open(NULL);
	tv = scope_add_table_columns(sql, scp, t, t->base.name);

	if (val_or_q->token == SQL_VALUES) {
		dlist *rowlist = val_or_q->data.lval;
		dlist *values;
		dnode *o;

		for (o = rowlist->h; o; o = o->next) {
			values = o->data.lval;

			if (dlist_length(values) != list_length(collist)) {
				scp = scope_close(scp);
				return sql_error(sql, 02, "Inserting into table %s, number of values doesn't match number of columns", tname);
			} else {
				dnode *n;
				node *m;

				for (n = values->h, m = collist->h; n && m; n = n->next, m = m->next) {
					sql_column *c = m->data;
					stmt *ins = insert_value(sql, NULL, c, n->data.sym);

					if (!ins) {
						cleanup_stmts(inserts, len);
						return NULL;
					}
					if (!inserts[c->colnr]) {
						inserts[c->colnr] = stmt_append(stmt_cbat(c, stmt_dup(tv->s), cs_size(&c->t->keys) ? UPD : INS, st_bat), ins);
					} else {
						stmt *t = NULL;
						if (inserts[c->colnr]->op2.stval->type != st_temp) {
							t = stmt_temp(sql_dup_subtype(tail_type(ins)));
							t = stmt_append(t,stmt_dup(inserts[c->colnr]->op2.stval));
							t = stmt_append( stmt_dup(inserts[c->colnr]->op1.stval), t);
							stmt_destroy(inserts[c->colnr]);
							inserts[c->colnr] = t;
							
						}
						/* append to temp */
					
						t = stmt_append(inserts[c->colnr]->op2.stval, ins);
						inserts[c->colnr]->op2.stval = t;
					}
					inscol = c->colnr;
				}

			}
		}
	} else {
		stmt *s = flat_subquery(sql, val_or_q);

		if (!s) {
			scp = scope_close(scp);
			cleanup_stmts(inserts, len);
			return NULL;
		}
		if (list_length(s->op1.lval) != list_length(collist)) {
			stmt_destroy(s);
			scp = scope_close(scp);
			cleanup_stmts(inserts, len);
			return sql_error(sql, 02, "Inserting into table %s, query result doesn't match number of columns", tname);
		} else {
			node *m, *n;

			for (n = s->op1.lval->h, m = collist->h; n && m; n = n->next, m = m->next) {
				sql_column *c = m->data;
				stmt *ins = check_types(sql, c->type, stmt_dup(n->data), type_dyncheck);

				if (!ins) {
					stmt_destroy(s);
					scp = scope_close(scp);
					cleanup_stmts(inserts, len);
					return NULL;
				}
				inserts[c->colnr] = stmt_append(stmt_cbat(c, stmt_dup(tv->s), cs_size(&c->t->keys) ? UPD : INS, st_bat), ins);
				inscol = c->colnr;
			}
		}
		if (s)
			stmt_destroy(s);
	}
	for (i = 0; i < len; i++) {
		stmt *ic = inserts[inscol]?inserts[inscol]->op2.stval:NULL;

		if (!inserts[i]) {
			node *m;

			for (m = t->columns.set->h; m; m = m->next) {
				sql_column *c = m->data;

				if (c->colnr == i) {
					stmt *s = NULL;

					if (c->def) {
						stmt *sq;
						char buf[BUFSIZ];

						snprintf(buf, BUFSIZ, "select %s;", c->def);
						sq = sqlparse_intern(sql, buf);
						if (sq->type != st_list || list_length(sq->op1.lval) != 1)
							return NULL;
						s = stmt_dup(sq->op1.lval->h->data);
						s = check_types(sql, c->type, s, type_equal);
						if (!s)
							return NULL;
						stmt_destroy(sq);
					} else {
						atom *a = atom_general(sql_dup_subtype(c->type), NULL, 0);
						s = stmt_atom(a);
					}
					/* no valid default ! */
					if (!s) {
						scp = scope_close(scp);

						cleanup_stmts(inserts, len);
						return sql_error(sql, 02, "column %s has no valid default value", c->base.name);
					}
					if (ic && !(ic->key && ic->nrcols == 0))
						s = stmt_const(stmt_dup(ic), s);
					inserts[i] = stmt_append(stmt_cbat(c, stmt_dup(tv->s), cs_size(&c->t->keys) ? UPD : INS, st_bat), s);
				}
			}
			assert(inserts[i]);
		}
	}
	if (collist != t->columns.set)
		list_destroy(collist);
	res = sql_insert(sql, t, inserts, len, 1);
	scp = scope_close(scp);
	cleanup_stmts(inserts, len);
	return res;
}

static stmt *
sql_bulkinsert(mvc *sql, sql_table *t, char *tsep, char *rsep, char *filename, int nr)
{
	stmt *bats = NULL;
	stmt *fname = (filename) ? stmt_atom_string(_strdup(filename)) : NULL;
	node *n;
	int i, len = 0;
	stmt **inserts, *res = NULL;

	scope *scp = scope_open(NULL);
	tvar *tv = scope_add_table_columns(sql, scp, t, t->base.name);

	bats = stmt_bulkinsert(stmt_basetable(t, t->base.name), _strdup(tsep), _strdup(rsep), fname, nr);
	len = list_length(t->columns.set);
	inserts = NEW_ARRAY(stmt *, len);

	for (n = t->columns.set->h, i = 0; n; n = n->next, i++) {
		sql_column *c = n->data;

		inserts[i] = stmt_append(stmt_cbat(c, stmt_dup(tv->s), cs_size(&c->t->keys) ? UPD : INS, st_bat), stmt_find(stmt_dup(bats), stmt_atom_string(_strdup(c->base.name)), c));
	}
	stmt_destroy(bats);
	res = sql_insert(sql, t, inserts, len, 1);
	scp = scope_close(scp);
	cleanup_stmts(inserts, len);
	return res;
}

static stmt *
copyfrom(mvc *sql, dlist *qname, dlist *files, dlist *seps, int nr)
{
	char *tname = qname_table(qname);
	sql_table *t = mvc_bind_table(sql, cur_schema(sql), tname);
	char *tsep = seps->h->data.sval;
	char *rsep = seps->h->next->data.sval;
	list *slist;

	if (!t) {
		return sql_error(sql, 02, "Copy into non existing table %s", tname);
	} else if (files) {
		dnode *n = files->h;

		for (slist = create_stmt_list(); n; n = n->next) {
			char *fname = n->data.sval;

			list_append(slist, sql_bulkinsert(sql, t, tsep, rsep, fname, nr));
		}
		return stmt_list(slist);
	}
	slist = create_stmt_list();
	list_append(slist, sql_bulkinsert(sql, t, tsep, rsep, NULL, nr));
	return stmt_list(slist);
}


stmt *
sql_update(mvc *sql, sql_table *t, stmt **updates, list *l)
{
	char buf[BUFSIZ];
	node *n;
	sql_subaggr *cnt = sql_bind_aggr(sql->trans->module, "count", NULL);

	if (!sql_update_idxs(sql, t, updates, l)) {
		sql_subaggr_destroy(cnt);
		return sql_error(sql, 02, "Updating indexes failed for table %s", t->base.name);
	}

	for (n = t->columns.set->h; n; n = n->next) {
		sql_column *c = n->data;

		if (updates[c->colnr] && !c->null) {
			stmt *s = updates[c->colnr]->op2.stval;

			if (!(s->key && s->nrcols == 0)) {
				s = stmt_atom(atom_general(sql_dup_subtype(c->type), NULL, 0));
				s = stmt_uselect(stmt_dup(updates[c->colnr]->op2.stval), s, cmp_equal);
				s = stmt_aggr(s, NULL, sql_dup_aggr(cnt));
			} else {
				sql_subfunc *isnil = sql_bind_func(sql->trans->module, "isnull", c->type, NULL);

				s = stmt_unop(stmt_dup(updates[c->colnr]->op2.stval), isnil);
			}
			snprintf(buf, BUFSIZ, "UPDATE: NOT NULL constraint violated for column %s.%s", c->t->base.name, c->base.name);
			s = stmt_exception(s, _strdup(buf), 00001);

			list_prepend(l, s);
		}
	}
	sql_subaggr_destroy(cnt);
	return stmt_list(l);
}

static stmt *
sql_update_table(mvc *sql, sql_schema *schema, char *tname, dlist *assignmentlist, symbol *opt_where)
{
	stmt *s = NULL;
	sql_table *t = mvc_bind_table(sql, schema, tname);

	if (!t) {
		return sql_error(sql, 02, "Updating non existing table %s", tname);
	} else if (!t->table) {
		return sql_error(sql, 02, "Cannot update the view %s", tname);
	} else {
		int len = 0, i = 0;
		tvar *tv = NULL;
		dnode *n;
		list *l;
		scope *scp;
		stmt **updates;

		scp = scope_open(NULL);
		tv = scope_add_table_columns(sql, scp, t, t->base.name);

		if (opt_where) {
			s = sql_logical_exp(sql, scp, opt_where, NULL, NULL, sql_where);
			if (s && s->type != st_set && s->type != st_sets) {
				s = stmt_set(s);
			}
			if (s) {
				/* check if the table is used in the query */
				stmt *tmp = complex_find_subset(s, tv->s);

				if (!tmp) { /* not used do a select all */
					cvar *cv = tv->columns->h->data;

					tmp = stmt_dup(cv->s);
					s = sql_and(sql, scp, s, tmp, sql_where);
				}

				s = stmt2pivot(scp, s);
			} else {
				scope_close(scp);
				return NULL;
			}
		} else {	/* update all */
			cvar *c = tv->columns->h->data;

			s = stmt2pivot(scp, stmt_dup(c->s));
		}
		l = create_stmt_list();

		len = list_length(t->columns.set);
		updates = NEW_ARRAY(stmt *, len);

		for (i = 0; i < len; i++)
			updates[i] = NULL;

		for (n = assignmentlist->h, i = 0; n; n = n->next, i++) {
			symbol *a = NULL;
			stmt *v = NULL;
			dlist *assignment = n->data.sym->data.lval;
			char *cname = assignment->h->data.sval;
			sql_column *c = mvc_bind_column(sql, t, cname);

			if (!c) {
				stmt_destroy(s);
				list_destroy(l);
				cleanup_stmts(updates, len);
				return sql_error(sql, 02, "Updating non existing column %s.%s", tname, assignment->h->data.sval);
			}
			a = assignment->h->next->data.sym;
			if (a)
				v = sql_value_exp(sql, scp, a, NULL, s, sql_sel);
			else
				v = stmt_atom(atom_general(sql_dup_subtype(c->type), NULL, 0));

			if (!v || (v = check_types(sql, c->type, v, type_dyncheck)) == NULL) {
				stmt_destroy(s);
				list_destroy(l);
				cleanup_stmts(updates, len);
				return NULL;
			}

			if (v->nrcols <= 0) {
				v = stmt_const(stmt_reverse(s ? first_subset(s) : stmt_cbat(c, stmt_dup(tv->s), RDONLY, st_bat)), v);
			} else {
				/* s is a table result ie new oid, original oid 
				 * v is a result based on subset s, new oid, val
				 * So a join is needed to get original oid, val
				 */
				v = stmt_join(stmt_reverse(first_subset(s)), v, cmp_equal);
			}
			updates[c->colnr] = stmt_replace(stmt_cbat(c, stmt_dup(tv->s), UPD, st_bat), v);
			list_append(l, stmt_dup(updates[c->colnr]));
			if (t->base.flag != TR_NEW) {
				list_append(l, stmt_insert(stmt_cbat(c, stmt_dup(tv->s), UPD, st_ubat), stmt_dup(v)));
			}
		}
		list_append(l, output_value(stmt_aggr(first_subset(s), NULL, sql_bind_aggr(sql->trans->module, "count", NULL))));
		stmt_destroy(s);

		if ((s = sql_update(sql, t, updates, l)) == NULL) {
			list_destroy(l);
			cleanup_stmts(updates, len);
			return NULL;
		}
		scp = scope_close(scp);
		cleanup_stmts(updates, len);
		return s;
	}
	return NULL;
}

static stmt *
update_table(mvc *sql, dlist *qname, dlist *assignmentlist, symbol *opt_where)
{
	sql_schema *s = qname_schema(sql, qname);
	char *tname = qname_table(qname);

	return sql_update_table(sql, s, tname, assignmentlist, opt_where);
}


static int
sql_delete_idxs(mvc *sql, sql_table *t, stmt *vals, list *l)
{
	node *n;
	int res = 1;

	(void) sql;		/* unused!? */

	for (n = t->idxs.set->h; n; n = n->next) {
		sql_idx *i = n->data;
		sql_subtype *it = NULL;
		stmt *v = NULL;

		if (i->type == unique && list_length(i->columns) <= 1)
			continue;

		if (i->type == unique) {
			it = sql_bind_localtype("int");
		} else if (i->type == join_idx) {
			it = sql_bind_localtype("oid");
		}

		assert(it);
		v = stmt_const(stmt_reverse(first_subset(vals)), stmt_atom(atom_general(sql_dup_subtype(it), NULL, 0)));
		list_append(l, stmt_replace(stmt_idxbat(i, 1), v));
	}
	return res;
}


stmt *
sql_delete(mvc *sql, tvar *tv, sql_table *t, stmt *s, int output)
{
	node *n;
	list *l = create_stmt_list();
	sql_subtype *to;
	stmt *v;

	to = sql_bind_subtype("oid", 0, 0);
	v = stmt_const(stmt_reverse(first_subset(s)), stmt_atom(atom_general(to, NULL, 0)));
	list_append(l, stmt_append(stmt_tbat(basetable_table(tv->s), INS), stmt_reverse(v)));

	for (n = t->columns.set->h; n; n = n->next) {
		sql_column *c = n->data;
		stmt *v = stmt_const(stmt_reverse(first_subset(s)),
				     stmt_atom(atom_general(sql_dup_subtype(c->type), NULL, 0)));

		list_append(l, stmt_replace(stmt_cbat(c, stmt_dup(tv->s), DEL, st_bat), v));
	}
	if (output) {
		stmt *t = stmt_aggr(first_subset(s), NULL,
				    sql_bind_aggr(sql->trans->module, "count", NULL));

		list_append(l, output_value(t));
	}

	if (t->idxs.set && !sql_delete_idxs(sql, t, s, l)) {
		list_destroy(l);
		return sql_error(sql, 02, "Deleting from indexes failed for table %s", t->base.name);
	}
	return stmt_list(l);
}

static stmt *
delete_table(mvc *sql, dlist *qname, symbol *opt_where)
{
	char *tname = qname_table(qname);
	sql_table *t = mvc_bind_table(sql, cur_schema(sql), tname);

	if (!t) {
		return sql_error(sql, 02, "Deleting from non existing table %s", tname);
	} else if (!t->table) {
		return sql_error(sql, 02, "Cannot delete from the view %s", tname);
	}
	if (!table_privs(sql, t, PRIV_DELETE)) {
		return sql_error(sql, 02, "User is not allowed to delete from table %s", tname);
	} else {
		tvar *tv = NULL;
		stmt *s = NULL;
		scope *scp = scope_open(NULL);

		tv = scope_add_table_columns(sql, scp, t, t->base.name);

		if (opt_where) {
			stmt *subset = NULL;
			s = sql_logical_exp(sql, scp, opt_where, NULL, NULL, sql_where);
			if (s && s->type != st_set && s->type != st_sets) {
				s = stmt_set(s);
			}
			if (s) {
				/* check if the table is used in the query */
				stmt *tmp = complex_find_subset(s, tv->s);

				if (!tmp) { /* not used do a select all */
					cvar *cv = tv->columns->h->data;

					tmp = stmt_dup(cv->s);
					s = sql_and(sql, scp, s, tmp, sql_where);
				}

				subset = stmt2pivot(scp,s);
			} else {
				scope_close(scp);
				return NULL;
			}
			s = sql_delete(sql, tv, t, subset, 1);
			stmt_destroy(subset);
		} else {	/* delete all */
			s = stmt_table_clear(t);
			s = output_value(s);
		}

		assert(isbasetable(tv->s));

		scp = scope_close(scp);
		return s;
	}
	return NULL;
}

stmt *
updates(mvc *sql, symbol *s)
{
	stmt *ret = NULL;

	switch (s->token) {
	case SQL_COPYFROM:
	{
		dlist *l = s->data.lval;

		ret = copyfrom(sql, l->h->data.lval, l->h->next->data.lval, l->h->next->next->data.lval, l->h->next->next->next->data.ival);
		sql->type = Q_UPDATE;
	}
		break;
	case SQL_INSERT:
	{
		dlist *l = s->data.lval;

		ret = insert_into(sql, l->h->data.lval, l->h->next->data.lval, l->h->next->next->data.sym);
		sql->type = Q_UPDATE;
	}
		break;
	case SQL_UPDATE:
	{
		dlist *l = s->data.lval;

		ret = update_table(sql, l->h->data.lval, l->h->next->data.lval, l->h->next->next->data.sym);
		sql->type = Q_UPDATE;
	}
		break;
	case SQL_DELETE:
	{
		dlist *l = s->data.lval;

		ret = delete_table(sql, l->h->data.lval, l->h->next->data.sym);
		sql->type = Q_UPDATE;
	}
		break;
	default:
		return sql_error(sql, 01, "Updates statement unknown Symbol(%ld)->token = %s", (long) s, token2string(s->token));
	}
	return ret;
}
