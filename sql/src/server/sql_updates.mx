@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2007 CWI.
@' All Rights Reserved.

@f sql_updates
@a N.J. Nes
@* 

@h
#ifndef _SQL_UPDATES_H_
#define _SQL_UPDATES_H_

#include <stdio.h>
#include <stdarg.h>
#include <sql_list.h>
#include "sql_symbol.h"
#include "sql_scope.h"
#include "sql_statement.h"

extern stmt *updates(mvc *sql, scope *scp, symbol *sym);

extern void cleanup_stmts(stmt **stmts, int cnt);
extern stmt *sql_insert(mvc *sql, sql_table *t, stmt **inserts, int len, int output);
extern stmt *sql_insert_add_idx(mvc *sql, sql_table *t, sql_idx * idx, list *l);
extern stmt *sql_delete(mvc *sql, tvar *tv, sql_table *t, stmt *s, int output, int all);
extern stmt *sql_update(mvc *sql, sql_table *t, stmt **updates, list *l);

/* the single result value needs to be multiplexed count(rows) times */
extern stmt *push_project(stmt *rows, stmt *val);

#endif /*_SQL_UPDATES_H_*/
@c

#include "sql_config.h"
#include "sql_updates.h"
#include "sql_parser.h"
#include "sql_scope.h"
#include "sql_semantic.h"
#include "sql_select.h"
#include "sql_privileges.h"

static stmt *
insert_value(mvc *sql, scope *scp, sql_column *c, symbol *s)
{
	if (s->token == SQL_NULL) {
		atom *a = atom_general(&c->type, NULL, 0);

		return stmt_atom(a);
	} else {
		stmt *n = NULL;
		exp_kind ek = {type_value, card_value, FALSE};
		stmt *a = sql_value_exp(sql, scp, s, NULL, NULL, sql_sel, ek);

		if (!a)
			return(NULL);
			
		if (!(n = check_types(sql, &c->type, a, type_equal))) {
			return NULL;
		}
		return n;
	}
	return NULL;
}

void
cleanup_stmts(stmt **stmts, int cnt)
{
	int i;

	for (i = 0; i < cnt; i++) {
		if (stmts[i])
			stmt_destroy(stmts[i]);
	}
	_DELETE(stmts);
}


static stmt *
insert_check_ukey(mvc *sql, stmt **inserts, sql_key *k, stmt *idx_inserts, int alter)
{
/* pkey's cannot have NULLs, ukeys however can
   current implementation switches on 'NOT NULL' on primary key columns */

	char buf[BUFSIZ];
	stmt *res;

	sql_subtype *it = sql_bind_localtype("int");
	sql_subaggr *cnt = sql_bind_aggr(sql->session->schema, "count", NULL);
	sql_subtype *bt = sql_bind_localtype("bit");
	stmt *ts = stmt_basetable(k->t, k->t->base.name);
	sql_subfunc *ne = sql_bind_func_result(sql->session->schema, "<>", it, it, bt);

	if (list_length(k->columns) > 1) {
		node *m;
		stmt *s = inserts[0]->op2.stval;
		sql_subaggr *sum;
		stmt *count_sum = NULL;

		/* 1st stage: find out if original contains same values */
		if (s->key && s->nrcols == 0) {
			s = stmt_relselect_init();
			stmt_relselect_fill(s, stmt_uselect(stmt_idxbat(k->idx, RDONLY), stmt_dup(idx_inserts), cmp_equal));
			for (m = k->columns->h; m; m = m->next) {
				sql_kc *c = m->data;

				stmt_relselect_fill(s, stmt_uselect( stmt_bat(c->c, stmt_dup(ts), RDONLY), stmt_dup(inserts[c->c->colnr]->op2.stval), cmp_equal));
			}
		} else {
			s = stmt_reljoin_init();
			stmt_reljoin_fill(s, stmt_idxbat(k->idx, RDONLY), stmt_dup(idx_inserts));
			for (m = k->columns->h; m; m = m->next) {
				sql_kc *c = m->data;

				stmt_reljoin_fill(s, stmt_bat(c->c, stmt_dup(ts), RDONLY), stmt_dup(inserts[c->c->colnr]->op2.stval));
			}
		}
		s = stmt_binop(stmt_aggr(s, NULL, cnt), stmt_atom_int(0), ne);

		/* 2e stage: find out if inserted are unique */
		if (idx_inserts->nrcols) {	/* insert columns not atoms */
			stmt *ss;
			sql_subfunc *or = sql_bind_func_result(sql->session->schema, "or", bt, bt, bt);
			/* implementation uses sort,refine, keyed check */
			ss = NULL;
			for (m = k->columns->h; m; m = m->next) {
				sql_kc *c = m->data;

				if (ss)  
					ss = stmt_reorder(ss, stmt_dup(inserts[c->c->colnr]->op2.stval), 1);
				else
					ss = stmt_order(stmt_dup(inserts[c->c->colnr]->op2.stval), 1);
			}

			sum = sql_bind_aggr(sql->session->schema, "not_unique", tail_type(ss));
			count_sum = stmt_aggr(ss, NULL, sum);
			/* combine results */
			s = stmt_binop(s, count_sum, or);
		}

		if (k->type == pkey) {
			snprintf(buf, BUFSIZ, "INSERT INTO: PRIMARY KEY constraint '%s.%s' violated", k->t->base.name, k->base.name);
		} else {
			snprintf(buf, BUFSIZ, "INSERT INTO: UNIQUE constraint '%s.%s' violated", k->t->base.name, k->base.name);
		}
		res = stmt_exception(s, _strdup(buf), 00001);
	} else {		/* single column key */
		sql_kc *c = k->columns->h->data;
		stmt *s, *h = inserts[c->c->colnr]->op2.stval;

		if (!alter) {
			s = stmt_bat(c->c, stmt_dup(ts), RDONLY);
			if (h->nrcols) {
				s = stmt_join(s, stmt_reverse(stmt_dup(h)), cmp_equal);
				/* s should be empty */
				s = stmt_aggr(s, NULL, cnt);
			} else {
				s = stmt_uselect(s, stmt_dup(h), cmp_equal);
				/* s should be empty */
				s = stmt_aggr(s, NULL, cnt);
			}
			/* s should be empty */
			s = stmt_binop(s, stmt_atom_int(0), ne);
		} else {
			s = stmt_bool(0);
		}

		/* 2e stage: find out if inserts are unique */
		if (h->nrcols) {	/* insert multiple atoms */
			sql_subaggr *sum;
			stmt *count_sum = NULL;
			sql_subfunc *or = sql_bind_func_result(sql->session->schema, "or", bt, bt, bt);
			stmt *ssum;

			stmt *ins = stmt_dup(inserts[c->c->colnr]->op2.stval);
			group *g = grp_create(ins, NULL, NULL);
			stmt *ss = stmt_aggr(stmt_dup(g->grp), g, sql_dup_aggr(cnt));

			/* (count(ss) <> sum(ss)) */
			sum = sql_bind_aggr(sql->session->schema, "sum", tail_type(ss));
			ssum = stmt_aggr(ss, NULL, sum);
			count_sum = stmt_binop(check_types(sql, tail_type(ssum), stmt_aggr(stmt_dup(ss), NULL, sql_dup_aggr(cnt)), type_equal), ssum, sql_dup_func(ne));

			/* combine results */
			s = stmt_binop(s, count_sum, or);
		}
		if (k->type == pkey) {
			snprintf(buf, BUFSIZ, "INSERT INTO: PRIMARY KEY constraint '%s.%s' violated", k->t->base.name, k->base.name);
		} else {
			snprintf(buf, BUFSIZ, "INSERT INTO: UNIQUE constraint '%s.%s' violated", k->t->base.name, k->base.name);
		}
		res = stmt_exception(s, _strdup(buf), 00001);
	}
	stmt_destroy(ts);
	return res;
}

static stmt *
insert_check_fkey(mvc *sql, stmt **inserts, sql_key *k, stmt *idx_inserts)
{
	char buf[BUFSIZ];
	stmt *s = inserts[0]->op2.stval;
	sql_subtype *it = sql_bind_localtype("int");
	sql_subaggr *cnt = sql_bind_aggr(sql->session->schema, "count", NULL);
	sql_subtype *bt = sql_bind_localtype("bit");
	sql_subfunc *ne = sql_bind_func_result(sql->session->schema, "<>", it, it, bt);

	(void) sql;		/* unused! */

	if (s->key && s->nrcols == 0) {
		s = stmt_binop(stmt_aggr(stmt_dup(idx_inserts), NULL, cnt), stmt_atom_int(1), ne);
	} else {
		/* reljoin.count <> inserts[col1].count */
		stmt *ins = stmt_dup(inserts[0]->op2.stval);

		s = stmt_binop(stmt_aggr(stmt_dup(idx_inserts), NULL, cnt), stmt_aggr(ins, NULL, sql_dup_aggr(cnt)), ne);
	}

	/* s should be empty */
	snprintf(buf, BUFSIZ, "INSERT INTO: FOREIGN KEY constraint '%s.%s' violated", k->t->base.name, k->base.name);
	return stmt_exception(s, _strdup(buf), 00001);
}

static stmt *
sql_insert_key(mvc *sql, stmt **inserts, sql_key *k, stmt *idx_inserts, int alter)
{
	/* int insert = 1;
	 * while insert and has u/pkey and not defered then
	 *      if u/pkey values exist then
	 *              insert = 0
	 * while insert and has fkey and not defered then
	 *      find id of corresponding u/pkey  
	 *      if (!found)
	 *              insert = 0
	 * if insert
	 *      insert values
	 *      insert fkey/pkey index
	 */
	if (k->type == pkey || k->type == ukey) {
		return insert_check_ukey(sql, inserts, k, idx_inserts, alter);
	} else {		/* foreign keys */
		return insert_check_fkey(sql, inserts, k, idx_inserts );
	}
}

static stmt *
hash_insert(mvc *sql, sql_idx * i, stmt **inserts)
{
	node *m;
	sql_subtype *it;
	int bits = 1 + 31/(list_length(i->columns)+2);
	stmt *h = NULL;

	if (list_length(i->columns) <= 1)
		return NULL;

	it = sql_bind_localtype("int");
	for (m = i->columns->h; m; m = m->next) {
		sql_kc *c = m->data;

		if (h) {
			sql_subfunc *xor = sql_bind_func_result3(sql->session->schema, "rotate_xor_hash", it, it, &c->c->type, it);

			h = stmt_Nop(stmt_list( list_append( list_append(
				list_append(create_stmt_list(), h), 
				stmt_atom_int(bits)), 
				stmt_dup(inserts[c->c->colnr]->op2.stval))), 
				xor);
		} else {
			sql_subfunc *hf = sql_bind_func_result(sql->session->schema, "hash", &c->c->type, NULL, it);
			h = stmt_unop(stmt_dup(inserts[c->c->colnr]->op2.stval), hf);
		}
	}
	return h;
}

static stmt *
join_idx_insert(mvc *sql, sql_idx * i, stmt **inserts)
{
	node *m, *o;
	sql_idx *ri = ((sql_fkey *) i->key)->rkey->k.idx;
	stmt *rts = stmt_basetable(ri->t, ri->t->base.name);
	stmt *s = inserts[0]->op2.stval;

	if (s->key && s->nrcols == 0) {
		sql_subtype *bt = sql_bind_localtype("bit");
		sql_subfunc *or = sql_bind_func_result(sql->session->schema, "or", bt, bt, bt);
		stmt *cond = NULL;

		s = stmt_relselect_init();
		for (m = i->columns->h, o = ri->columns->h; m && o; m = m->next, o = o->next) {
			sql_kc *c = m->data;
			sql_kc *rc = o->data;

			stmt_relselect_fill(s, stmt_uselect(stmt_bat(rc->c, stmt_dup(rts), RDONLY), stmt_dup(inserts[c->c->colnr]->op2.stval), cmp_equal));

			if (c->c->null) {
				sql_subfunc *isnil = sql_bind_func(sql->session->schema, "isnull", &c->c->type, NULL);
				stmt *ins = stmt_dup(inserts[c->c->colnr]->op2.stval);

				ins = stmt_unop(ins, isnil);
				if (!cond) {
					cond = ins;
				} else {
					cond = stmt_binop(cond, ins, sql_dup_func(or));
				}
			}
		}
		sql_subfunc_destroy(or);

		/* add missing nulls (and NULLs only (SIMPLE MATCH)) */
		s = stmt_mark(stmt_reverse(s), 0);
		if (cond) {
			stmt *t = stmt_temp(bt);
			stmt *isnull = stmt_temp(tail_type(s));
			stmt *notnull = s;

			isnull = stmt_append(isnull, stmt_atom(atom_general(tail_type(s), NULL, 0)));
			t = stmt_append(t, cond);
			isnull = stmt_join(t, stmt_reverse(stmt_const(stmt_reverse(isnull), stmt_bool(1))), cmp_equal);
			notnull = stmt_join(stmt_dup(t), stmt_reverse(stmt_const(stmt_reverse(notnull), stmt_bool(0))), cmp_equal);
			s = stmt_union(isnull, notnull);
		}
	} else {
		int nulls = 0;

		s = stmt_reljoin_init();
		for (m = i->columns->h, o = ri->columns->h; m && o; m = m->next, o = o->next) {
			sql_kc *c = m->data;
			sql_kc *rc = o->data;

			stmt_reljoin_fill(s, stmt_dup(inserts[c->c->colnr]->op2.stval), stmt_bat(rc->c, stmt_dup(rts), RDONLY));
			if (c->c->null)
				nulls = 1;
		}
		/* add missing nulls (and NULLs only (SIMPLE MATCH)) */
		if (nulls) {
			stmt *cur = NULL, *missing = stmt_diff(stmt_dup(inserts[0]->op2.stval),
							       stmt_dup(s));

			for (m = i->columns->h; m; m = m->next) {

				sql_kc *c = m->data;
				sql_subfunc *isnil = sql_bind_func(sql->session->schema, "isnull",
								   &c->c->type, NULL);

				stmt *n;

				n = stmt_dup(inserts[c->c->colnr]->op2.stval);
				n = stmt_semijoin(n, stmt_dup(missing));
				n = stmt_unop(n, isnil);
				n = stmt_uselect(n, stmt_bool(1), cmp_equal);
				if (cur)
					cur = stmt_semijoin(cur, n);
				else
					cur = n;
			}
			stmt_destroy(missing);
			s = stmt_union(s, stmt_const(cur, stmt_atom(atom_general(sql_bind_localtype("oid"), NULL, 0))));
		}
		s = stmt_reverse(stmt_order(stmt_reverse(s), 1));
	}
	stmt_destroy(rts);
	return s;
}

static void
sql_insert_idx(mvc *sql, stmt **inserts, sql_idx * i, list *l, int alter)
{
	stmt *is = NULL;

	if (i->type == unique) {
		is = hash_insert(sql, i, inserts);
	} else if (i->type == join_idx) {
		is = join_idx_insert(sql, i, inserts);
	}
	if (i->key) {
		stmt *ckeys = sql_insert_key(sql, inserts, i->key, is, alter);

		list_prepend(l, ckeys);
	}
	/* append to the pre-computed join-index */
	if (is)
		list_append(l, stmt_append(stmt_idxbat(i, INS), is));
}

static int
sql_insert_idxs(mvc *sql, sql_table *t, stmt **inserts, list *l)
{
	node *n;
	int res = 1;

	if (!t->idxs.set)
		return res;

	for (n = t->idxs.set->h; n; n = n->next) {
		sql_idx *i = n->data;

		sql_insert_idx(sql, inserts, i, l, 0);
	}
	return res;
}

void
scope_add_inserted( scope *scp, stmt **inserts, sql_table *t, char *name) 
{
	node *n;
	tvar *tv = scope_add_table(scp, NULL, name, NULL); 

	for (n = t->columns.set->h; n; n = n->next) {
		sql_column *c = n->data;
		char *cn = _strdup(c->base.name);
		stmt *inserted = stmt_dup(inserts[c->colnr]->op2.stval);

		inserted = stmt_alias(inserted, _strdup(name), cn);
		table_add_column(tv, inserted, NULL, c->base.name);
	}
}

static int
sql_insert_triggers(mvc *sql, sql_table *t, stmt **inserts, list *l)
{
	node *n;
	int res = 1;
	list *tri_list = NULL;

	if (!t->triggers.set)
		return res;

	for (n = t->triggers.set->h; n; n = n->next) {
		sql_trigger *trigger = n->data;
		int trigger_id = trigger->base.id;

		if (trigger->event == 0 && 
		   (!sql->called_triggers || 
		    !list_find_id(sql->called_triggers, trigger_id))) {
			scope *scp = scope_open(NULL);
			stmt *s = NULL;
			char *n = trigger->new_name;

			/* add name for the 'inserted' to the scope */
			if (!n) n = "new"; 
	
			if (sql->called_triggers) {
				list_append(sql->called_triggers, &trigger_id);
			} else {
				tri_list = list_create((fdestroy) NULL);
				tri_list = list_append(tri_list, &trigger_id);
				sql->called_triggers = tri_list;
			}
	
			scope_add_inserted(scp, inserts, t, n);
			s = scope_sqlparse(sql, scp, trigger->statement, m_execute);

			if (tri_list) {
				sql->called_triggers = NULL;
				list_destroy(tri_list);	
			}
			tri_list = NULL;
			scope_close(scp);
			
			if (!s) 
				return 0;
			if (trigger -> time )
				list_append(l, s);
			else
				list_prepend(l, s);
		}
	}
	return res;
}

stmt *
sql_insert_add_idx(mvc *sql, sql_table *t, sql_idx * idx, list *l)
{
	stmt **inserts;
	node *m;
	int i, len = list_length(t->columns.set);
	stmt *ts = stmt_basetable(t, t->base.name);

	inserts = NEW_ARRAY(stmt *, len);

	for (m = t->columns.set->h, i = 0; m; m = m->next, i++) {
		sql_column *c = m->data;
		stmt *b = stmt_bat(c, stmt_dup(ts), RDONLY);
		sql_subtype *tp = tail_type(b);

		inserts[i] = stmt_append(stmt_temp(tp), b);
	}
	stmt_destroy(ts);
	sql_insert_idx(sql, inserts, idx, l, 1);
	cleanup_stmts(inserts, len);
	return stmt_list(l);
}

static int
is_idx_updated(sql_idx * i, stmt **updates)
{
	int update = 0;
	node *m;

	for (m = i->columns->h; m; m = m->next) {
		sql_kc *ic = m->data;

		if (updates[ic->c->colnr]) {
			update = 1;
			break;
		}
	}
	return update;
}

static int
first_updated_col(stmt **updates, int cnt)
{
	int i;

	for (i = 0; i < cnt; i++) {
		if (updates[i])
			return i;
	}
	return -1;
}

static stmt *
update_check_ukey(mvc *sql, stmt **updates, sql_key *k, stmt *idx_updates, int updcol)
{
	char buf[BUFSIZ];
	stmt *res = NULL;

	sql_subtype *it = sql_bind_localtype("int");
	sql_subaggr *cnt = sql_bind_aggr(sql->session->schema, "count", NULL);
	sql_subtype *bt = sql_bind_localtype("bit");
	sql_subfunc *ne;

	if (list_length(k->columns) > 1 && !idx_updates)
		return NULL;

	ne = sql_bind_func_result(sql->session->schema, "<>", it, it, bt);
	if (list_length(k->columns) > 1) {
		stmt *ts = stmt_basetable(k->t, k->t->base.name);
		node *m;
		stmt *s;

		/* 1st stage: find out if original (without the updated) 
			do not contain the same values as the updated values. 
			This is done using a relation join and a count (which 
			should be zero)
	 	*/
		s = stmt_reljoin_init();
		stmt_reljoin_fill(s, stmt_diff(stmt_idxbat(k->idx, RDONLY), stmt_dup(idx_updates)), stmt_dup(idx_updates));
		for (m = k->columns->h; m; m = m->next) {
			sql_kc *c = m->data;
			stmt *upd, *l;

			if (updates[c->c->colnr]) {
				upd = stmt_dup(updates[c->c->colnr]->op2.stval);
			} else {
				upd = stmt_semijoin(stmt_bat(c->c, stmt_dup(ts), RDONLY), stmt_dup(updates[updcol]->op2.stval));
			}
			l = stmt_diff(stmt_bat(c->c, stmt_dup(ts), RDONLY), stmt_dup(upd));
			stmt_reljoin_fill(s, l, upd);

		}
		s = stmt_binop(stmt_aggr(s, NULL, cnt), stmt_atom_int(0), ne);

		/* 2e stage: find out if the updated are unique */
		if (idx_updates->nrcols) {	/* update columns not atoms */
			sql_subaggr *sum;
			stmt *count_sum = NULL;
			group *g = NULL;
			stmt *ss;
			sql_subfunc *or = sql_bind_func_result(sql->session->schema, "or", bt, bt, bt);

			/* also take the hopefully unique hash keys, to reduce
			   (re)group costs */
			g = grp_create(stmt_dup(idx_updates), g, NULL);
			for (m = k->columns->h; m; m = m->next) {
				sql_kc *c = m->data;
				stmt *upd;

				if (updates[c->c->colnr]) {
					upd = stmt_dup(updates[c->c->colnr]->op2.stval);
				} else {
					upd = stmt_dup(updates[updcol]->op2.stval);
					upd = stmt_semijoin(stmt_bat(c->c, stmt_dup(ts), RDONLY), upd);
				}
				g = grp_create(upd, g, NULL);
			}
			ss = stmt_aggr(stmt_dup(g->grp), grp_dup(g), sql_dup_aggr(cnt));
			grp_destroy(g);
			/* (count(ss) <> sum(ss)) */
			sum = sql_bind_aggr(sql->session->schema, "sum", tail_type(ss));
			count_sum = stmt_binop(stmt_aggr(stmt_dup(ss), NULL, sql_dup_aggr(cnt)), check_types(sql, it, stmt_aggr(ss, NULL, sum), type_equal), sql_dup_func(ne));

			/* combine results */
			s = stmt_binop(s, count_sum, or);
		}

		if (k->type == pkey) {
			snprintf(buf, BUFSIZ, "UPDATE: PRIMARY KEY constraint '%s.%s' violated", k->t->base.name, k->base.name);
		} else {
			snprintf(buf, BUFSIZ, "UPDATE: UNIQUE constraint '%s.%s' violated", k->t->base.name, k->base.name);
		}
		res = stmt_exception(s, _strdup(buf), 00001);
	} else {		/* single column key */
		sql_kc *c = k->columns->h->data;
		stmt *h = stmt_dup(updates[c->c->colnr]->op2.stval);
		stmt *o = stmt_diff(stmt_dup(updates[c->c->colnr]->op1.stval), stmt_dup(h));
		stmt *s = stmt_join(o, stmt_reverse(h), cmp_equal);

		/* s should be empty */
		s = stmt_binop(stmt_aggr(s, NULL, cnt), stmt_atom_int(0), ne);

		/* 2e stage: find out if updated are unique */
		if (h->nrcols) {	/* update columns not atoms */
			sql_subaggr *sum;
			stmt *count_sum = NULL;
			sql_subfunc *or = sql_bind_func_result(sql->session->schema, "or", bt, bt, bt);
			stmt *ssum;

			stmt *upd = stmt_dup(updates[c->c->colnr]->op2.stval);
			group *g = grp_create(upd, NULL, NULL);
			stmt *ss = stmt_aggr(stmt_dup(g->grp), g, sql_dup_aggr(cnt));

			/* (count(ss) <> sum(ss)) */
			sum = sql_bind_aggr(sql->session->schema, "sum", tail_type(ss));
			ssum = stmt_aggr(ss, NULL, sum);
			count_sum = stmt_binop(check_types(sql, tail_type(ssum), stmt_aggr(stmt_dup(ss), NULL, sql_dup_aggr(cnt)), type_equal), ssum, sql_dup_func(ne));

			/* combine results */
			s = stmt_binop(s, count_sum, or);
		}

		if (k->type == pkey) {
			snprintf(buf, BUFSIZ, "UPDATE: PRIMARY KEY constraint '%s.%s' violated", k->t->base.name, k->base.name);
		} else {
			snprintf(buf, BUFSIZ, "UPDATE: UNIQUE constraint '%s.%s' violated", k->t->base.name, k->base.name);
		}
		res = stmt_exception(s, _strdup(buf), 00001);
	}
	return res;
}

static stmt *
update_check_fkey(mvc *sql, stmt **updates, sql_key *k, stmt *idx_updates, int updcol)
{
	char buf[BUFSIZ];
	stmt *s;
	sql_subtype *it = sql_bind_localtype("int");
	sql_subaggr *cnt = sql_bind_aggr(sql->session->schema, "count", NULL);
	sql_subtype *bt = sql_bind_localtype("bit");
	sql_subfunc *ne = sql_bind_func_result(sql->session->schema, "<>", it, it, bt);
	stmt *cur;

	if (!idx_updates)
		return NULL;
	(void) sql;		/* unused! */
	/* reljoin.count <> updates[updcol].count */
	cur = stmt_dup(updates[updcol]->op2.stval);
	s = stmt_binop(stmt_aggr(stmt_dup(idx_updates), NULL, cnt), stmt_aggr(cur, NULL, sql_dup_aggr(cnt)), ne);

	/* s should be empty */
	snprintf(buf, BUFSIZ, "UPDATE: FOREIGN KEY constraint '%s.%s' violated", k->t->base.name, k->base.name);
	return stmt_exception(s, _strdup(buf), 00001);
}

static stmt *
join_updated_pkey(mvc *sql, sql_key * k, stmt **updates, int updcol)
{
	char buf[BUFSIZ];
	int nulls = 0;
	node *m, *o;
	sql_idx *ri = ((sql_fkey*)k)->rkey->k.idx;
	stmt *s = NULL, *ts = stmt_basetable(ri->t, ri->t->base.name), *fts;
	stmt *null = NULL, *rows;
	sql_subtype *it = sql_bind_localtype("int");
	sql_subtype *bt = sql_bind_localtype("bit");
	sql_subaggr *cnt = sql_bind_aggr(sql->session->schema, "count", NULL);
	sql_subfunc *ne = sql_bind_func_result(sql->session->schema, "<>", it, it, bt);

	fts = stmt_basetable(k->idx->t, k->idx->t->base.name);
	s = stmt_reljoin_init();

	rows = stmt_idxbat(k->idx, RDONLY);
	rows = stmt_semijoin(stmt_reverse(rows), stmt_dup(updates[updcol]));

	for (m = k->idx->columns->h, o = ri->columns->h; m && o; m = m->next, o = o->next) {
		sql_kc *fc = m->data;
		sql_kc *c = o->data;
		stmt *upd;

		if (updates[c->c->colnr]) {
			upd = stmt_dup(updates[c->c->colnr]->op2.stval);
		} else {
			upd = stmt_dup(updates[updcol]->op2.stval);
			upd = stmt_semijoin(stmt_bat(c->c, stmt_dup(ts), RDONLY), upd);
		}
		if (c->c->null) {	/* new nulls (MATCH SIMPLE) */
			stmt *nn = stmt_dup(upd);

			nn = stmt_uselect(nn, stmt_atom(atom_general(&c->c->type, NULL, 0)), cmp_equal);
			if (null)
				null = stmt_semijoin(null, nn);
			else
				null = nn;
			nulls = 1;
		}
		stmt_reljoin_fill(s, upd, stmt_semijoin(stmt_dup(
		  stmt_bat(fc->c, stmt_dup(fts), RDONLY)), stmt_dup(rows) ));

	}
	/* add missing nulls */
	if (nulls)
		s = stmt_union(s, stmt_const(null, stmt_atom(atom_general(sql_bind_localtype("oid"), NULL, 0))));

	stmt_destroy(ts);
	stmt_destroy(fts);

	/* reljoin.count <> updates[updcol].count */
	s = stmt_binop(stmt_aggr(stmt_dup(s), NULL, cnt), stmt_aggr(rows, NULL, sql_dup_aggr(cnt)), ne);

	/* s should be empty */
	snprintf(buf, BUFSIZ, "UPDATE: FOREIGN KEY constraint '%s.%s' violated", k->t->base.name, k->base.name);
	return stmt_exception(s, _strdup(buf), 00001);
}


static void 
sql_update_ukey(mvc *sql, stmt **updates, sql_key *k, int updcol, list *l) 
{
	sql_ukey *uk = (sql_ukey*)k;

	if (uk->keys && list_length(uk->keys) > 0) {
		node *n;
		for(n = uk->keys->h; n; n = n->next) {
			sql_key *fk = n->data;
			stmt *s = NULL;

			/* here we should handle UPDATE ACTIONs:
					no action,
					restrict
					cascade
					set null
					set default
			 */
			/* Current implementation is just 'restrict' */
			/* All rows of the foreign key table which are
			   affected by the primary key update should all
			   match one of the updated primary keys again.
			 */
			s = join_updated_pkey(sql, fk, updates, updcol);
			list_prepend(l, s);
		}
	}
}

static void
sql_update_key(mvc *sql, stmt **updates, sql_key *k, stmt *idx_updates, int updcol, list *l)
{
	stmt *ckeys;

	if (k->type == pkey || k->type == ukey) {
		ckeys = update_check_ukey(sql, updates, k, idx_updates, updcol);
		sql_update_ukey(sql, updates, k, updcol, l);
		list_prepend(l, ckeys);
	} else {		/* foreign keys */
		ckeys = update_check_fkey(sql, updates, k, idx_updates, updcol);
		list_prepend(l, ckeys);
	}
}

static stmt *
hash_update(mvc *sql, sql_idx * i, stmt **updates, int updcol)
{
	/* calculate new value */
	node *m;
	sql_subtype *it;
	int bits = 1 + 31/(list_length(i->columns)+2);
	stmt *h = NULL, *ts;

	if (list_length(i->columns) <= 1)
		return NULL;

	ts = stmt_basetable(i->t, i->t->base.name);
	it = sql_bind_localtype("int");
	for (m = i->columns->h; m; m = m->next ) {
		sql_kc *c = m->data;
		stmt *upd;

		if (updates[c->c->colnr]) {
			upd = stmt_dup(updates[c->c->colnr]->op2.stval);
		} else {
			upd = stmt_dup(updates[updcol]->op2.stval);
			upd = stmt_semijoin(stmt_bat(c->c, stmt_dup(ts), RDONLY), upd);
		}

		if (h) {
			sql_subfunc *xor = sql_bind_func_result3(sql->session->schema, "rotate_xor_hash", it, it, &c->c->type, it);

			h = stmt_Nop(stmt_list( list_append( list_append(
				list_append(create_stmt_list(), h), 
				stmt_atom_int(bits)), 
				upd)), 
				xor);
		} else {
			sql_subfunc *hf = sql_bind_func_result(sql->session->schema, "hash", &c->c->type, NULL, it);
			h = stmt_unop(upd, hf);
		}
	}
	stmt_destroy(ts);
	return h;
}

static stmt *
join_idx_update(sql_idx * i, stmt **updates, int updcol)
{
	int nulls = 0;
	node *m, *o;
	sql_idx *ri = ((sql_fkey *) i->key)->rkey->k.idx;
	stmt *s = NULL, *rts = stmt_basetable(ri->t, ri->t->base.name), *ts;
	stmt *null = NULL;

	ts = stmt_basetable(i->t, i->t->base.name);
	s = stmt_reljoin_init();
	for (m = i->columns->h, o = ri->columns->h; m && o; m = m->next, o = o->next) {
		sql_kc *c = m->data;
		sql_kc *rc = o->data;
		stmt *upd;

		if (updates[c->c->colnr]) {
			upd = stmt_dup(updates[c->c->colnr]->op2.stval);
		} else {
			upd = stmt_dup(updates[updcol]->op2.stval);
			upd = stmt_semijoin(stmt_bat(c->c, stmt_dup(ts), RDONLY), upd);
		}
		if (c->c->null) {	/* new nulls (MATCH SIMPLE) */
			stmt *nn = stmt_dup(upd);

			nn = stmt_uselect(nn, stmt_atom(atom_general(&c->c->type, NULL, 0)), cmp_equal);
			if (null)
				null = stmt_semijoin(null, nn);
			else
				null = nn;
			nulls = 1;
		}
		stmt_reljoin_fill(s, upd, stmt_dup(stmt_bat(rc->c, stmt_dup(rts), RDONLY)));

	}
	/* add missing nulls */
	if (nulls)
		s = stmt_union(s, stmt_const(null, stmt_atom(atom_general(sql_bind_localtype("oid"), NULL, 0))));

	stmt_destroy(ts);
	stmt_destroy(rts);
	return s;
}

static int
sql_update_idxs(mvc *sql, sql_table *t, stmt **updates, list *l)
{
	int res = 1;
	node *n;
	int updcol;

	if (!t->idxs.set)
		return res;

	updcol = first_updated_col(updates, list_length(t->columns.set));
	for (n = t->idxs.set->h; n; n = n->next) {
		sql_idx *i = n->data;
		stmt *is = NULL;

		/* check if update is needed, 
		 * ie atleast on of the idx columns is updated 
		 */
		if (is_idx_updated(i, updates) == 0)
			continue;

		if (i->type == unique) {
			is = hash_update(sql, i, updates, updcol);
		} else if (i->type == join_idx) {
			is = join_idx_update(i, updates, updcol);
		}
		if (i->key)
			sql_update_key(sql, updates, i->key, is, updcol, l);
		if (is) 
			list_append(l, stmt_insert(stmt_idxbat(i, UPD), is));
	}
	return res;
}

static void
scope_add_updated( scope *scp, stmt **updates, sql_table *t, char *on, char *nn)
{
	node *n;
	tvar *tv = scope_add_table(scp, NULL, on, NULL); 

	for (n = t->columns.set->h; n; n = n->next) {
		sql_column *c = n->data;
		if (updates[c->colnr]) {
			char *cn = _strdup(c->base.name);
			stmt *h = stmt_dup(updates[c->colnr]->op2.stval);
			stmt *updated = stmt_dup(updates[c->colnr]->op1.stval);

			updated = stmt_semijoin(updated, h);
			updated = stmt_alias(updated, _strdup(on), cn);
			table_add_column(tv, updated, NULL, c->base.name);
		}
	}
	tv = scope_add_table(scp, NULL, nn, NULL); 

	for (n = t->columns.set->h; n; n = n->next) {
		sql_column *c = n->data;
		if (updates[c->colnr]) {
			char *cn = _strdup(c->base.name);
			stmt *updated = stmt_dup(updates[c->colnr]->op2.stval);

			updated = stmt_alias(updated, _strdup(nn), cn);
			table_add_column(tv, updated, NULL, c->base.name);
		}
	}
}


static int
sql_update_triggers(mvc *sql, sql_table *t, stmt **inserts, list *l)
{
	node *n;
	int res = 1;
	list *tri_list = NULL;

	if (!t->triggers.set)
		return res;

	for (n = t->triggers.set->h; n; n = n->next) {
		sql_trigger *trigger = n->data;
		int trigger_id = trigger->base.id;

		if (trigger->event == 2 && 
		   (!sql->called_triggers || 
		    !list_find_id(sql->called_triggers, trigger_id))) {
			scope *scp = scope_open(NULL);
			stmt *s = NULL;
	
			/* add name for the 'inserted' to the scope */
			char *n = trigger->new_name;
			char *o = trigger->old_name;
	
			if (!n) n = "new"; 
			if (!o) o = "old"; 
	
			if (sql->called_triggers) {
				list_append(sql->called_triggers, &trigger_id);
			} else {
				tri_list = list_create((fdestroy) NULL);
				tri_list = list_append(tri_list, &trigger_id);
				sql->called_triggers = tri_list;
			}
	
			scope_add_updated(scp, inserts, t, o, n);
			s = scope_sqlparse(sql, scp, trigger->statement, m_execute);

			if (tri_list) {
				sql->called_triggers = NULL;
				list_destroy(tri_list);	
			}
			tri_list = NULL;
			scope_close(scp);

			if (!s) 
				return 0;
			if (trigger -> time )
				list_append(l, s);
			else
				list_prepend(l, s);
		}
	}
	return res;
}

stmt *
sql_insert(mvc *sql, sql_table *t, stmt **inserts, int len, int output)
{
	char buf[BUFSIZ];
	int i;
	list *l = create_stmt_list();
	node *n;
	sql_subaggr *cnt;
	stmt *s = NULL;

	if (!sql_insert_idxs(sql, t, inserts, l)) {
		list_destroy(l);
		return sql_error(sql, 02, "INSERT INTO: failed to update indexes for table '%s'", t->base.name);
	}

 	cnt = sql_bind_aggr(sql->session->schema, "count", NULL);
	for (n = t->columns.set->h; n; n = n->next) {
		sql_column *c = n->data;

		if (!inserts[c->colnr]) {
			list_destroy(l);
			sql_subaggr_destroy(cnt);
			return NULL;
		}
		if (!c->null) {
			stmt *s = inserts[c->colnr]->op2.stval;

			if (!(s->key && s->nrcols == 0)) {
				s = stmt_atom(atom_general(&c->type, NULL, 0));
				s = stmt_uselect(stmt_dup(inserts[c->colnr]->op2.stval), s, cmp_equal);
				s = stmt_aggr(s, NULL, sql_dup_aggr(cnt));
			} else {
				sql_subfunc *isnil = sql_bind_func(sql->session->schema, "isnull", &c->type, NULL);

				s = stmt_unop(stmt_dup(inserts[c->colnr]->op2.stval), isnil);
			}
			snprintf(buf, BUFSIZ, "INSERT INTO: NOT NULL constraint violated for column %s.%s", c->t->base.name, c->base.name);
			s = stmt_exception(s, _strdup(buf), 00001);

			list_prepend(l, s);
		}
	}

	sql_subaggr_destroy(cnt);
	for (i = 0; i < len; i++)
		list_append(l, stmt_dup(inserts[i]));

	if (!sql_insert_triggers(sql, t, inserts, l)) {
		list_destroy(l);
		return sql_error(sql, 02, "INSERT INTO: triggers failed for table '%s'", t->base.name);
	}

	if (output) {
		if (inserts[0]->op2.stval->nrcols == 0) {
			s = stmt_atom_int(1);
		} else {
			s = stmt_aggr(stmt_dup(inserts[0]->op2.stval), NULL, sql_bind_aggr(sql->session->schema, "count", NULL));
		}
		list_append(l, stmt_affected_rows(s));
	}
	return stmt_list(l);
}

stmt *
push_project(stmt *rows, stmt *val) 
{
	switch (val->type) {
	case st_convert:
	case st_unop:
		val->op1.stval = push_project(rows, val->op1.stval);
		val->nrcols = rows->nrcols;
		return val;
	default:
		return stmt_const(rows, val);
	}
}

static stmt *
insert_into(mvc *sql, scope *scp, dlist *qname, dlist *columns, symbol *val_or_q)
{
	stmt *temp_table = NULL;
	int inscol = 0;
	tvar *tv = NULL;

	char *sname = qname_schema(qname);
	char *tname = qname_table(qname);
	sql_schema *s = NULL;
	sql_table *t = NULL;
	list *collist = NULL;
	int i, len = 0;
	stmt **inserts, *res = NULL;

	if (sname && !(s=mvc_bind_schema(sql, sname))) {
		(void) sql_error(sql, 02, "INSERT INTO: no such schema '%s'", sname);
		return NULL;
	}
	if (!s)
		s = cur_schema(sql);
	t = mvc_bind_table(sql, s, tname);
	if (!t && !sname) {
		s = tmp_schema(sql);
		t = mvc_bind_table(sql, s, tname);
		if (!t) {
			sql_subtype *tpe = stack_find_type(sql, tname);
			temp_table = stack_find_var(sql, tname);
			if (tpe)
				t = tpe->comp_type;
		}
	}
	if (!t) {
		return sql_error(sql, 02, "INSERT INTO: no such table '%s'", tname);
	} else if (isView(t)) {
		return sql_error(sql, 02, "INSERT INTO: cannot insert into view '%s'", tname);
	}
	if (!table_privs(sql, t, PRIV_INSERT)) {
		return sql_error(sql, 02, "INSERT INTO: insufficient privileges for user '%s' to insert into table '%s'", stack_get_string(sql, "current_user"), tname);
	}
	if (columns) {
		dnode *n;

		collist = list_create((fdestroy) NULL);
		for (n = columns->h; n; n = n->next) {
			sql_column *c = mvc_bind_column(sql, t, n->data.sval);

			if (c) {
				list_append(collist, c);
			} else {
				return sql_error(sql, 02, "INSERT INTO: no such column '%s.%s'", tname, n->data.sval);
			}
		}
	} else {
		collist = t->columns.set;
	}

	len = list_length(t->columns.set);
	inserts = NEW_ARRAY(stmt *, len);

	for (i = 0; i < len; i++)
		inserts[i] = NULL;

	scp = scope_open(scp);
	if (temp_table) 
		tv = scope_add_temp_table(scp, t, temp_table, t->base.name); 
	else
		tv = scope_add_table_columns(sql, scp, t, t->base.name, INS);

	if (val_or_q->token == SQL_VALUES) {
		dlist *rowlist = val_or_q->data.lval;
		dlist *values;
		dnode *o;

		for (o = rowlist->h; o; o = o->next) {
			values = o->data.lval;

			if (dlist_length(values) != list_length(collist)) {
				scp = scope_close(scp);
				cleanup_stmts(inserts, len);
				return sql_error(sql, 02, "INSERT INTO: number of values doesn't match number of columns of table '%s'", tname);
			} else {
				dnode *n;
				node *m;

				for (n = values->h, m = collist->h; n && m; n = n->next, m = m->next) {
					sql_column *c = m->data;
					stmt *ins = insert_value(sql, NULL, c, n->data.sym);

					if (!ins) {
						cleanup_stmts(inserts, len);
						return NULL;
					}
					if (!inserts[c->colnr]) {
						inserts[c->colnr] = stmt_append(stmt_bat(c, stmt_dup(tv->s), INS), ins);
					} else {
						stmt *t = NULL;
						if (inserts[c->colnr]->op2.stval->type != st_temp) {
							t = stmt_temp(tail_type(ins));
							t = stmt_append(t,stmt_dup(inserts[c->colnr]->op2.stval));
							t = stmt_append( stmt_dup(inserts[c->colnr]->op1.stval), t);
							stmt_destroy(inserts[c->colnr]);
							inserts[c->colnr] = t;
							
						}
						/* append to temp */
					
						t = stmt_append(inserts[c->colnr]->op2.stval, ins);
						inserts[c->colnr]->op2.stval = t;
					}
					inscol = c->colnr;
				}

			}
		}
	} else {
		stmt *s = flat_subquery(sql, val_or_q);

		if (!s) {
			scp = scope_close(scp);
			cleanup_stmts(inserts, len);
			return NULL;
		}
		if (list_length(s->op1.lval) != list_length(collist)) {
			stmt_destroy(s);
			scp = scope_close(scp);
			cleanup_stmts(inserts, len);
			return sql_error(sql, 02, "INSERT INTO: query result doesn't match number of columns in table '%s'", tname);
		} else {
			node *m, *n;

			/* first copy (else inplace converts fail!) */
			for (n = s->op1.lval->h, m = collist->h; n && m; n = n->next, m = m->next) {
				sql_column *c = m->data;
				inserts[c->colnr] = stmt_dup(n->data);
				inscol = c->colnr;
			}
			stmt_destroy(s);
			s = NULL;
			for (m = collist->h; m; m = m->next) {
				sql_column *c = m->data;
				stmt *ins = inserts[c->colnr];

				if (ins) {
					ins = check_types(sql, &c->type, ins, type_equal);
					inserts[c->colnr] = ins;
					if (!ins) {
						scp = scope_close(scp);
						cleanup_stmts(inserts, len);
						return NULL;
					}
					inserts[c->colnr] = stmt_append(stmt_bat(c, stmt_dup(tv->s), INS), ins);
				}
			}
		}
		if (s)
			stmt_destroy(s);
	}
	for (i = 0; i < len; i++) {
		stmt *ic = inserts[inscol]?inserts[inscol]->op2.stval:NULL;

		if (!inserts[i]) {
			node *m;

			for (m = t->columns.set->h; m; m = m->next) {
				sql_column *c = m->data;

				if (c->colnr == i) {
					stmt *s = NULL;

					if (c->def) {
						stmt *sq;
						char buf[BUFSIZ];

						snprintf(buf, BUFSIZ, "select %s;", c->def);
						sq = scope_sqlparse(sql, NULL, buf, sql->mode);
						if (!sq || sq->type != st_list || list_length(sq->op1.lval) != 1) {
							cond_stmt_destroy(sq);
							cleanup_stmts(inserts, len);
							return NULL;
						}
						s = stmt_dup(sq->op1.lval->h->data);
						s = check_types(sql, &c->type, s, type_equal);
						if (!s) {
							stmt_destroy(sq);
							cleanup_stmts(inserts, len);
							return NULL;
						}
						stmt_destroy(sq);
					} else {
						atom *a = atom_general(&c->type, NULL, 0);
						s = stmt_atom(a);
					}
					/* no valid default ! */
					if (!s) {
						scp = scope_close(scp);

						cleanup_stmts(inserts, len);
						return sql_error(sql, 02, "INSERT INTO: column '%s' has no valid default value", c->base.name);
					}
					if (ic && !(ic->key && ic->nrcols == 0))
						s = push_project(stmt_dup(ic), s);
					inserts[i] = stmt_append(stmt_bat(c, stmt_dup(tv->s), INS), s);
				}
			}
			assert(inserts[i]);
		}
	}
	if (collist != t->columns.set)
		list_destroy(collist);
	res = sql_insert(sql, t, inserts, len, 1);
	scp = scope_close(scp);
	cleanup_stmts(inserts, len);
	return res;
}

/* TODO rewrite on parser level into, INSERT INTO x select * from import()
   where import is a function returning a table of to be inserted values.
 */
static stmt *
sql_bulkinsert(mvc *sql, scope *scp, sql_table *t, stmt *temp_table, char *tsep, char *rsep, char *filename, int nr)
{
	stmt *rs = NULL;
	stmt *fname = (filename) ? stmt_atom_string(_strdup(filename)) : NULL;
	node *n;
	int i, len = 0;
	stmt **inserts, *res = NULL;
	tvar *tv;

	scp = scope_open(scp);
	if (temp_table)
		tv = scope_add_temp_table(scp, t, temp_table, t->base.name); 
	else
		tv = scope_add_table_columns(sql, scp, t, t->base.name, INS);
	rs = stmt_bulkinsert(stmt_basetable(t, t->base.name), _strdup(tsep), _strdup(rsep), fname, nr);
	len = list_length(t->columns.set);
	inserts = NEW_ARRAY(stmt *, len);

	for (n = t->columns.set->h, i = 0; n; n = n->next, i++) {
		sql_column *c = n->data;

		inserts[i] = stmt_append(stmt_bat(c, stmt_dup(tv->s), INS), 
				stmt_rs_column(stmt_dup(rs), stmt_atom_string(_strdup(c->base.name)), &c->type));
	}
	stmt_destroy(rs);
	res = sql_insert(sql, t, inserts, len, 1);
	scp = scope_close(scp);
	cleanup_stmts(inserts, len);
	return res;
}

static stmt *
copyfrom(mvc *sql, scope *scp, dlist *qname, dlist *files, dlist *seps, int nr)
{
	stmt *temp_table = NULL;
	char *sname = qname_schema(qname);
	char *tname = qname_table(qname);
	sql_schema *s = NULL;
	sql_table *t = NULL;
	char *tsep = seps->h->data.sval;
	char *rsep = seps->h->next->data.sval;
	list *slist;

	if (sname && !(s=mvc_bind_schema(sql, sname))) {
		(void) sql_error(sql, 02, "COPY INTO: no such schema '%s'", sname);
		return NULL;
	}
	if (!s)
		s = cur_schema(sql);
	t = mvc_bind_table(sql, s, tname);
	if (!t && !sname) {
		s = tmp_schema(sql);
		t = mvc_bind_table(sql, s, tname);
		if (!t) {
			sql_subtype *tpe = stack_find_type(sql, tname);
			temp_table = stack_find_var(sql, tname);
			if (tpe)
				t = tpe->comp_type;
		}
	}
	if (!t) {
		return sql_error(sql, 02, "COPY INTO: no such table '%s'", tname);
	} else if (files) {
		dnode *n = files->h;

		for (slist = create_stmt_list(); n; n = n->next) {
			char *fname = n->data.sval;

			list_append(slist, sql_bulkinsert(sql, scp, t, temp_table, tsep, rsep, fname, nr));
		}
		return stmt_list(slist);
	}
	slist = create_stmt_list();
	list_append(slist, sql_bulkinsert(sql, scp, t, temp_table, tsep, rsep, NULL, nr));
	return stmt_list(slist);
}


stmt *
sql_update(mvc *sql, sql_table *t, stmt **updates, list *l)
{
	char buf[BUFSIZ];
	node *n;
	sql_subaggr *cnt;

 	cnt = sql_bind_aggr(sql->session->schema, "count", NULL);
	for (n = t->columns.set->h; n; n = n->next) {
		sql_column *c = n->data;

		if (updates[c->colnr] && !c->null) {
			stmt *s = updates[c->colnr]->op2.stval;

			if (!(s->key && s->nrcols == 0)) {
				s = stmt_atom(atom_general(&c->type, NULL, 0));
				s = stmt_uselect(stmt_dup(updates[c->colnr]->op2.stval), s, cmp_equal);
				s = stmt_aggr(s, NULL, sql_dup_aggr(cnt));
			} else {
				sql_subfunc *isnil = sql_bind_func(sql->session->schema, "isnull", &c->type, NULL);

				s = stmt_unop(stmt_dup(updates[c->colnr]->op2.stval), isnil);
			}
			snprintf(buf, BUFSIZ, "UPDATE: NOT NULL constraint violated for column '%s.%s'", c->t->base.name, c->base.name);
			s = stmt_exception(s, _strdup(buf), 00001);

			list_prepend(l, s);
		}
	}
	sql_subaggr_destroy(cnt);

	if (!sql_update_triggers(sql, t, updates, l)) {
		list_destroy(l);
		return sql_error(sql, 02, "UPDATE: triggers failed for table '%s'", t->base.name);
	}
	if (!sql_update_idxs(sql, t, updates, l)) {
		list_destroy(l);
		return sql_error(sql, 02, "UPDATE: failed to update indexes for table '%s'", t->base.name);
	}

	return stmt_list(l);
}

static stmt *
sql_update_table(mvc *sql, scope *scp, sql_schema *schema, char *tname, dlist *assignmentlist, symbol *opt_where)
{
	stmt *temp_table = NULL;
	stmt *s = NULL;
	sql_table *t = mvc_bind_table(sql, schema, tname);

	if (!t && !schema) {
		sql_subtype *tpe;
		if ((tpe = stack_find_type(sql, tname)) != NULL) {
			temp_table = stack_find_var(sql, tname);
			t = tpe->comp_type;
		}
	}
	if (!t) {
		return sql_error(sql, 02, "UPDATE: no such table '%s'", tname);
	} else if (isView(t)) {
		return sql_error(sql, 02, "UPDATE: cannot update view '%s'", tname);
	} else {
		int len = 0, i = 0;
		tvar *tv = NULL;
		dnode *n;
		list *l;
		stmt **updates;

		scp = scope_open(scp);
		if (temp_table) 
			tv = scope_add_temp_table(scp, t, temp_table, t->base.name); 
		else
			tv = scope_add_table_columns(sql, scp, t, t->base.name, RDONLY);

		if (opt_where) {
			s = sql_logical_exp(sql, scp, opt_where, NULL, NULL, sql_where);
			if (s && s->type != st_set && s->type != st_sets) {
				s = stmt_set(s);
			}
			if (s) {
				/* check if the table is used in the query */
				stmt *tmp = complex_find_subset(s, tv->s);

				if (!tmp) { /* not used do a select all */
					cvar *cv = tv->columns->h->data;

					tmp = stmt_dup(cv->s);
					s = sql_and(sql, scp, s, tmp, sql_where);
				}

				s = stmt2pivot(scp, s);
			} else {
				scope_close(scp);
				return NULL;
			}
		} else {	/* update all */
			cvar *c = tv->columns->h->data;

			s = stmt2pivot(scp, stmt_dup(c->s));
		}
		l = create_stmt_list();

		len = list_length(t->columns.set);
		updates = NEW_ARRAY(stmt *, len);

		for (i = 0; i < len; i++)
			updates[i] = NULL;

		for (n = assignmentlist->h, i = 0; n; n = n->next, i++) {
			symbol *a = NULL;
			stmt *v = NULL;
			dlist *assignment = n->data.sym->data.lval;
			char *cname = assignment->h->data.sval;
			sql_column *c = mvc_bind_column(sql, t, cname);

			if (!c) {
				stmt_destroy(s);
				list_destroy(l);
				cleanup_stmts(updates, len);
				return sql_error(sql, 02, "UPDATE: no such column '%s.%s'", tname, assignment->h->data.sval);
			}
			a = assignment->h->next->data.sym;
			if (a) {
				exp_kind ek = {type_value, card_column, FALSE};
				v = sql_value_exp(sql, scp, a, NULL, s, sql_sel, ek);
			} else
				v = stmt_atom(atom_general(&c->type, NULL, 0));

			if (!v || (v = check_types(sql, &c->type, v, type_equal)) == NULL) {
				stmt_destroy(s);
				list_destroy(l);
				cleanup_stmts(updates, len);
				return NULL;
			}

			if (v->nrcols <= 0) {
				v = stmt_const(stmt_reverse(s ? first_subset(s) : stmt_bat(c, stmt_dup(tv->s), RDONLY)), v);
			} else {
				if (v->type == st_list && list_length(v->op1.lval) == 2) { /* sub query with outer refs */
					node *o = v->op1.lval->h;
					stmt *oref = stmt_dup(o->next->data);
					stmt *sqa = stmt_dup(o->data);
					stmt *cmp, *h;

					cmp = stmt_join(stmt_reverse(oref), sqa, cmp_equal);
					/* need to fix the cmp head */
					h = stmt_dup(cmp->h->t);
					stmt_destroy(cmp->h);
					cmp->h = h;
					stmt_destroy(v);
					v = cmp;
				}
				/* s is a table result ie new oid, original oid 
				 * v is a result based on subset s, new oid, val
				 * So a join is needed to get original oid, val
				 */
				v = stmt_join(stmt_reverse(first_subset(s)), v, cmp_equal);
			}
			/* new bats need values replaced */
			if (c->base.flag == TR_NEW)
				updates[c->colnr] = stmt_replace(stmt_bat(c, stmt_dup(tv->s), INS), stmt_dup(v));
			else
				updates[c->colnr] = stmt_insert(stmt_bat(c, stmt_dup(tv->s), UPD), stmt_dup(v));
			list_append(l, stmt_dup(updates[c->colnr]));
		}
		list_append(l, stmt_affected_rows(stmt_aggr(first_subset(s), NULL, sql_bind_aggr(sql->session->schema, "count", NULL))));
		stmt_destroy(s);

		if ((s = sql_update(sql, t, updates, l)) == NULL) {
			list_destroy(l);
			cleanup_stmts(updates, len);
			return NULL;
		}
		scp = scope_close(scp);
		cleanup_stmts(updates, len);
		return s;
	}
	return NULL;
}

static stmt *
update_table(mvc *sql, scope *scp, dlist *qname, dlist *assignmentlist, symbol *opt_where)
{
	char *sname = qname_schema(qname);
	char *tname = qname_table(qname);
	sql_schema *s = NULL;
	sql_table *t = NULL;

	if (sname && !(s=mvc_bind_schema(sql,sname))) {
		(void) sql_error(sql, 02, "UPDATE: no such schema '%s'", sname);
		return NULL;
	}
	if (!s)
		s = cur_schema(sql);
	t = mvc_bind_table(sql, s, tname);
	if (!t && !sname) 
		s = tmp_schema(sql);
	return sql_update_table(sql, scp, s, tname, assignmentlist, opt_where);
}


void
scope_add_deleted( scope *scp, stmt *deletes, sql_table *t, char *name)
{
	node *n;
	tvar *tv = scope_add_table(scp, NULL, name, NULL); 
	stmt *ts = stmt_basetable(t, t->base.name);

	for (n = t->columns.set->h; n; n = n->next) {
		sql_column *c = n->data;
		char *cn = _strdup(c->base.name);
		stmt *deleted = stmt_bat(c, stmt_dup(ts), RDONLY);

		deleted = stmt_semijoin(deleted, stmt_dup(deletes));
		deleted = stmt_alias(deleted, _strdup(name), cn);
		table_add_column(tv, deleted, NULL, c->base.name);
	}
}


static int
sql_delete_triggers(mvc *sql, sql_table *t, stmt *deletes, list *l)
{
	node *n;
	int res = 1;
	list *tri_list = NULL;

	if (!t->triggers.set)
		return res;

	for (n = t->triggers.set->h; n; n = n->next) {
		sql_trigger *trigger = n->data;
		int trigger_id = trigger->base.id;

		if (trigger->event == 1 && 
		   (!sql->called_triggers || 
		    !list_find_id(sql->called_triggers, trigger_id))) {
			scope *scp = scope_open(NULL);
			stmt *s = NULL;
	
			/* add name for the 'deleted' to the scope */
			char *o = trigger->old_name;
		
			if (!o) o = "old"; 
		
			if (sql->called_triggers) {
				list_append(sql->called_triggers, &trigger_id);
			} else {
				tri_list = list_create((fdestroy) NULL);
				tri_list = list_append(tri_list, &trigger_id);
				sql->called_triggers = tri_list;
			}

			scope_add_deleted(scp, deletes, t, o);
			s = scope_sqlparse(sql, scp, trigger->statement, m_execute);

			if (tri_list) {
				sql->called_triggers = NULL;
				list_destroy(tri_list);	
			}
			tri_list = NULL;
			scope_close(scp);

			if (!s) 
				return 0;
			if (trigger -> time )
				list_append(l, s);
			else
				list_prepend(l, s);
		}
	}
	return res;
}


static void 
sql_delete_key(mvc *sql, stmt *deletes, sql_key *k, list *l) 
{
	sql_ukey *uk = (sql_ukey*)k;

	if (uk->keys && list_length(uk->keys) > 0) {
		char buf[BUFSIZ];
		sql_subtype *it = sql_bind_localtype("int");
		sql_subtype *bt = sql_bind_localtype("bit");
		node *n;
		for(n = uk->keys->h; n; n = n->next) {
			sql_subaggr *cnt = sql_bind_aggr(sql->session->schema, "count", NULL);
			sql_subfunc *ne = sql_bind_func_result(sql->session->schema, "<>", it, it, bt);
			sql_key *fk = n->data;
			stmt *s;
			/* here we should handle DELETE ACTIONs:
					no action,
					restrict
					cascade
					set null
					set default
			 */
			/* Current implementation is just 'restrict' */
			s = stmt_idxbat(fk->idx, RDONLY);
			s = stmt_semijoin(stmt_reverse(s), stmt_dup(deletes));
			/* The overlap between deleted primaries and foreign
			   should be empty */
			s = stmt_binop(stmt_aggr(s, NULL, cnt), stmt_atom_int(0), ne);
			snprintf(buf, BUFSIZ, "DELETE: FOREIGN KEY constraint '%s.%s' violated", k->t->base.name, k->base.name);
			s = stmt_exception(s, _strdup(buf), 00001);
			list_prepend(l, s);
		}
	}
}

static int
sql_delete_keys(mvc *sql, sql_table *t, stmt *deletes, list *l)
{
	int res = 1;
	node *n;

	if (!t->keys.set)
		return res;

	for (n = t->keys.set->h; n; n = n->next) {
		sql_key *k = n->data;

		if (k->type == pkey || k->type == ukey) 
			sql_delete_key(sql, deletes, k, l);
	}
	return res;
}

stmt *
sql_delete(mvc *sql, tvar *tv, sql_table *t, stmt *s, int output, int all)
{
	list *l = create_stmt_list();
	stmt *v = NULL;
	stmt *subset = NULL;

	if (!all) {
		sql_subtype to;

		sql_find_subtype(&to, "oid", 0, 0);
		if (s->type == st_ptable)
			subset = first_subset(s);
		else /* simple select */
			subset = s;
		v = stmt_const(stmt_reverse(subset), stmt_atom(atom_general(&to, NULL, 0)));
		list_append(l, stmt_append(stmt_tbat(basetable_table(tv->s), INS), stmt_reverse(v)));
	} else {
		/* first column */
		v = stmt_mirror(stmt_bat(t->columns.set->h->data, stmt_dup(tv->s), RDONLY));
		s = stmt_table_clear(t);
		list_append(l, stmt_dup(s));
	}

	if (!sql_delete_triggers(sql, t, v, l)) {
		list_destroy(l);
		return sql_error(sql, 02, "DELETE: triggers failed for table '%s'", t->base.name);
	}
	if (!sql_delete_keys(sql, t, v, l)) {
		list_destroy(l);
		return sql_error(sql, 02, "DELETE: failed to delete indexes for table '%s'", t->base.name);
	}

	if (output) {
		if (!all) 
			s = stmt_aggr(stmt_dup(subset), NULL,
			    sql_bind_aggr(sql->session->schema, "count", NULL));
		list_append(l, stmt_affected_rows(s));
	}
	return stmt_list(l);
}

static stmt *
delete_table(mvc *sql, scope *scp, dlist *qname, symbol *opt_where)
{
	stmt *temp_table = NULL;
	char *sname = qname_schema(qname);
	char *tname = qname_table(qname);
	sql_schema *s = NULL;
	sql_table *t = NULL;

	if (sname && !(s=mvc_bind_schema(sql, sname))) {
		(void) sql_error(sql, 02, "DELETE FROM: no such schema '%s'", sname);
		return NULL;
	}
	if (!s)
		s = cur_schema(sql);
	t = mvc_bind_table(sql, s, tname);
	if (!t && !sname) {
		s = tmp_schema(sql);
		t = mvc_bind_table(sql, s, tname);
		if (!t) {
			sql_subtype *tpe = stack_find_type(sql, tname);
			temp_table = stack_find_var(sql, tname);
			if (tpe)
				t = tpe->comp_type;
		}
	}
	if (!t) {
		return sql_error(sql, 02, "DELETE FROM: no such table '%s'", tname);
	} else if (isView(t)) {
		return sql_error(sql, 02, "DELETE FROM: cannot delete from view '%s'", tname);
	}
	if (!table_privs(sql, t, PRIV_DELETE)) {
		return sql_error(sql, 02, "DELETE FROM: insufficient privileges for user '%s' to delete from table '%s'", stack_get_string(sql, "current_user"), tname);
	} else {
		tvar *tv = NULL;
		stmt *s = NULL;

		scp = scope_open(scp);
		if (temp_table) 
			tv = scope_add_temp_table(scp, t, temp_table, t->base.name); 
		else
			tv = scope_add_table_columns(sql, scp, t, t->base.name, RDONLY);
		if (opt_where) {
			stmt *subset = NULL;
			s = sql_logical_exp(sql, scp, opt_where, NULL, NULL, sql_where);
			if (s && s->type == st_filter) { /* filter on table ? */
				ptable_statements(scp->ptable) = stmt_set(s);
				s = stmt_dup(scope_first_column(scp)->s);
			}
			if (s && s->type != st_set && s->type != st_sets) {
				s = stmt_set(s);
			}
			if (s) {
				/* check if the table is used in the query */
				stmt *tmp = complex_find_subset(s, tv->s);

				if (!tmp) { /* not used do a select all */
					cvar *cv = tv->columns->h->data;

					tmp = stmt_dup(cv->s);
					s = sql_and(sql, scp, s, tmp, sql_where);
				}

				subset = stmt2pivot(scp,s);
			} else {
				scope_close(scp);
				return NULL;
			}
			s = sql_delete(sql, tv, t, subset, 1, 0);
			stmt_destroy(subset);
		} else {	/* delete all */
			s = sql_delete(sql, tv, t, NULL, 1, 1);
		}

		assert(isbasetable(tv->s));

		scp = scope_close(scp);
		return s;
	}
	return NULL;
}

stmt *
updates(mvc *sql, scope *scp, symbol *s)
{
	stmt *ret = NULL;

	switch (s->token) {
	case SQL_COPYFROM:
	{
		dlist *l = s->data.lval;

		ret = copyfrom(sql, scp, l->h->data.lval, l->h->next->data.lval, l->h->next->next->data.lval, l->h->next->next->next->data.ival);
		sql->type = Q_UPDATE;
	}
		break;
	case SQL_INSERT:
	{
		dlist *l = s->data.lval;

		ret = insert_into(sql, scp, l->h->data.lval, l->h->next->data.lval, l->h->next->next->data.sym);
		sql->type = Q_UPDATE;
	}
		break;
	case SQL_UPDATE:
	{
		dlist *l = s->data.lval;

		ret = update_table(sql, scp, l->h->data.lval, l->h->next->data.lval, l->h->next->next->data.sym);
		sql->type = Q_UPDATE;
	}
		break;
	case SQL_DELETE:
	{
		dlist *l = s->data.lval;

		ret = delete_table(sql, scp, l->h->data.lval, l->h->next->data.sym);
		sql->type = Q_UPDATE;
	}
		break;
	default:
		return sql_error(sql, 01, "Updates statement unknown Symbol(%ld)->token = %s", (long) s, token2string(s->token));
	}
	return ret;
}
