@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
@' Copyright August 2008-2009 MonetDB B.V.
@' All Rights Reserved.

@f sql_updates
@a N.J. Nes
@* 

@h
#ifndef _SQL_UPDATES_H_
#define _SQL_UPDATES_H_

#include <stdio.h>
#include <stdarg.h>
#include <sql_list.h>
#include "sql_symbol.h"
#include "sql_statement.h"

extern stmt *updates(mvc *sql, symbol *sym);

#endif /*_SQL_UPDATES_H_*/
@c

#include "sql_config.h"
#include "sql_updates.h"
#include "sql_parser.h"
#include "sql_semantic.h"
#include "sql_privileges.h"

#include "rel_subquery.h"
#include "rel_select.h"

static stmt *
insert_check_ukey(mvc *sql, stmt **inserts, sql_key *k, stmt *idx_inserts, int alter)
{
/* pkey's cannot have NULLs, ukeys however can
   current implementation switches on 'NOT NULL' on primary key columns */

	char *msg = NULL;
	stmt *res;

	sql_subtype *wrd = sql_bind_localtype("wrd");
	sql_subaggr *cnt = sql_bind_aggr(sql->session->schema, "count", NULL);
	sql_subtype *bt = sql_bind_localtype("bit");
	stmt *ts = stmt_basetable(k->t, k->t->base.name);
	sql_subfunc *ne = sql_bind_func_result(sql->session->schema, "<>", wrd, wrd, bt);

	if (list_length(k->columns) > 1) {
		node *m;
		stmt *s = inserts[0]->op2.stval;
		sql_subaggr *sum;
		stmt *ssum = NULL;
		stmt *col = NULL;

		/* 1st stage: find out if original contains same values */
		if (s->key && s->nrcols == 0) {
			s = stmt_relselect_init();
			stmt_relselect_fill(s, stmt_uselect(stmt_idxbat(k->idx, RDONLY), stmt_dup(idx_inserts), cmp_equal));
			for (m = k->columns->h; m; m = m->next) {
				sql_kc *c = m->data;
				col = stmt_bat(c->c, stmt_dup(ts), RDONLY);
				if ((k->type == ukey) && stmt_has_null(stmt_dup(col))) {
					sql_subtype *t = tail_type(col);
					stmt *n = stmt_atom(atom_general(t, NULL, 0));
					col = stmt_select2(col, n, stmt_dup(n), 0);
				}

				stmt_relselect_fill(s, stmt_uselect( col, stmt_dup(inserts[c->c->colnr]->op2.stval), cmp_equal));
			}
		} else {
			s = stmt_releqjoin_init();
			stmt_releqjoin_fill(s, stmt_idxbat(k->idx, RDONLY), stmt_dup(idx_inserts));
			for (m = k->columns->h; m; m = m->next) {
				sql_kc *c = m->data;
				col = stmt_bat(c->c, stmt_dup(ts), RDONLY);
				if ((k->type == ukey) && stmt_has_null(stmt_dup(col))) {
					sql_subtype *t = tail_type(col);
					stmt *n = stmt_atom(atom_general(t, NULL, 0));
					col = stmt_select2(col, n, stmt_dup(n), 0);
				}

				stmt_releqjoin_fill(s, col, stmt_dup(inserts[c->c->colnr]->op2.stval));
			}
		}
		s = stmt_binop(stmt_aggr(s, NULL, cnt, 1), stmt_atom_wrd(0), ne);

		/* 2e stage: find out if inserted are unique */
		if (!alter && idx_inserts->nrcols) {	/* insert columns not atoms */
#if 0
			sql_subtype *Oid = sql_bind_localtype("oid");
			sql_subfunc *nu, *or = sql_bind_func_result(sql->session->schema, "or", bt, bt, bt);
			stmt *ss = NULL;

			/* implementation uses group, not_uniques,
				join, derive, not_uniques keyed check */
			for (m = k->columns->h; m; m = m->next) {
				sql_kc *c = m->data;

				if (ss) {
					ss = stmt_derive(ss, stmt_join(stmt_mirror(stmt_dup(ss)), stmt_dup(inserts[c->c->colnr]->op2.stval), cmp_equal));
				} else {
					ss = stmt_group(stmt_dup(inserts[c->c->colnr]->op2.stval));
				}
			}
 			nu = sql_bind_func_result(sql->session->schema, "not_uniques", tail_type(ss), NULL, Oid);
			ss = stmt_unop(ss, nu);

			sum = sql_bind_aggr(sql->session->schema, "not_unique", tail_type(ss));
			ssum = stmt_aggr(ss, NULL, sum, 1);
			/* combine results */
			s = stmt_binop(s, ssum, or);
#else
			stmt *ss;
			sql_subfunc *or = sql_bind_func_result(sql->session->schema, "or", bt, bt, bt);
			/* implementation uses sort,refine, keyed check */
			ss = NULL;
			for (m = k->columns->h; m; m = m->next) {
				sql_kc *c = m->data;

				if (ss)  
					ss = stmt_reorder(ss, stmt_dup(inserts[c->c->colnr]->op2.stval), 1);
				else
					ss = stmt_order(stmt_dup(inserts[c->c->colnr]->op2.stval), 1);
			}

			sum = sql_bind_aggr(sql->session->schema, "not_unique", tail_type(ss));
			ssum = stmt_aggr(ss, NULL, sum, 1);
			/* combine results */
			s = stmt_binop(s, ssum, or);
#endif
		}

		if (k->type == pkey) {
			msg = sql_message( "INSERT INTO: PRIMARY KEY constraint '%s.%s' violated", k->t->base.name, k->base.name);
		} else {
			msg = sql_message( "INSERT INTO: UNIQUE constraint '%s.%s' violated", k->t->base.name, k->base.name);
		}
		res = stmt_exception(s, msg, 00001);
	} else {		/* single column key */
		sql_kc *c = k->columns->h->data;
		stmt *s, *h = inserts[c->c->colnr]->op2.stval;

		s = stmt_bat(c->c, stmt_dup(ts), RDONLY);
		if ((k->type == ukey) && stmt_has_null(stmt_dup(s))) {
			sql_subtype *t = tail_type(h);
			stmt *n = stmt_atom(atom_general(t, NULL, 0));
			s = stmt_select2(s, n, stmt_dup(n), 0);
		}
		if (!alter) {
			if (h->nrcols) {
				s = stmt_join(s, stmt_reverse(stmt_dup(h)), cmp_equal);
				/* s should be empty */
				s = stmt_aggr(s, NULL, cnt, 1);
			} else {
				s = stmt_uselect(s, stmt_dup(h), cmp_equal);
				/* s should be empty */
				s = stmt_aggr(s, NULL, cnt, 1);
			}
			/* s should be empty */
			s = stmt_binop(s, stmt_atom_wrd(0), ne);
		} else {
			s = stmt_bool(0);
		}

		/* 2e stage: find out if inserts are unique */
		if (h->nrcols && (k->type == pkey || !alter) ) {	/* insert multiple atoms */
			sql_subaggr *sum;
			stmt *count_sum = NULL;
			sql_subfunc *or = sql_bind_func_result(sql->session->schema, "or", bt, bt, bt);
			stmt *ssum;

			stmt *ins = stmt_dup(inserts[c->c->colnr]->op2.stval);
			group *g = grp_create(ins, NULL, NULL);
			stmt *ss = stmt_aggr(stmt_dup(g->grp), g, sql_dup_aggr(cnt), 1);

			/* (count(ss) <> sum(ss)) */
			sum = sql_bind_aggr(sql->session->schema, "sum", tail_type(ss));
			ssum = stmt_aggr(ss, NULL, sum, 1);
			ssum = sql_Nop_(sql, "ifthenelse", sql_unop_(sql, NULL, "isnull", ssum), stmt_atom_wrd(0), stmt_dup(ssum), NULL);
			count_sum = stmt_binop(check_types(sql, tail_type(ssum), stmt_aggr(stmt_dup(ss), NULL, sql_dup_aggr(cnt), 1), type_equal), ssum, sql_dup_func(ne));

			/* combine results */
			s = stmt_binop(s, count_sum, or);
		}
		if (k->type == pkey) {
			msg = sql_message( "INSERT INTO: PRIMARY KEY constraint '%s.%s' violated", k->t->base.name, k->base.name);
		} else {
			msg = sql_message( "INSERT INTO: UNIQUE constraint '%s.%s' violated", k->t->base.name, k->base.name);
		}
		res = stmt_exception(s, msg, 00001);
	}
	stmt_destroy(ts);
	return res;
}

static stmt *
insert_check_fkey(mvc *sql, stmt **inserts, sql_key *k, stmt *idx_inserts)
{
	char *msg = NULL;
	stmt *s = inserts[0]->op2.stval;
	sql_subtype *wrd = sql_bind_localtype("wrd");
	sql_subaggr *cnt = sql_bind_aggr(sql->session->schema, "count", NULL);
	sql_subtype *bt = sql_bind_localtype("bit");
	sql_subfunc *ne = sql_bind_func_result(sql->session->schema, "<>", wrd, wrd, bt);

	(void) sql;		/* unused! */

	if (s->key && s->nrcols == 0) {
		s = stmt_binop(stmt_aggr(stmt_dup(idx_inserts), NULL, cnt, 1), stmt_atom_wrd(1), ne);
	} else {
		/* releqjoin.count <> inserts[col1].count */
		stmt *ins = stmt_dup(inserts[0]->op2.stval);

		s = stmt_binop(stmt_aggr(stmt_dup(idx_inserts), NULL, cnt, 1), stmt_aggr(ins, NULL, sql_dup_aggr(cnt), 1), ne);
	}

	/* s should be empty */
	msg = sql_message( "INSERT INTO: FOREIGN KEY constraint '%s.%s' violated", k->t->base.name, k->base.name);
	return stmt_exception(s, msg, 00001);
}

static stmt *
sql_insert_key(mvc *sql, stmt **inserts, sql_key *k, stmt *idx_inserts, int alter)
{
	/* int insert = 1;
	 * while insert and has u/pkey and not defered then
	 *      if u/pkey values exist then
	 *              insert = 0
	 * while insert and has fkey and not defered then
	 *      find id of corresponding u/pkey  
	 *      if (!found)
	 *              insert = 0
	 * if insert
	 *      insert values
	 *      insert fkey/pkey index
	 */
	if (k->type == pkey || k->type == ukey) {
		return insert_check_ukey(sql, inserts, k, idx_inserts, alter);
	} else {		/* foreign keys */
		return insert_check_fkey(sql, inserts, k, idx_inserts );
	}
}

static stmt *
hash_insert(mvc *sql, sql_idx * i, stmt **inserts)
{
	node *m;
	sql_subtype *it, *wrd;
	int bits = 1 + ((sizeof(wrd)*8)-1)/(list_length(i->columns));
	stmt *h = NULL;

	if (list_length(i->columns) <= 1)
		return NULL;

	it = sql_bind_localtype("int");
	wrd = sql_bind_localtype("wrd");
	for (m = i->columns->h; m; m = m->next) {
		sql_kc *c = m->data;

		if (h) {
			sql_subfunc *xor = sql_bind_func_result3(sql->session->schema, "rotate_xor_hash", wrd, it, &c->c->type, wrd);

			h = stmt_Nop(stmt_list( list_append( list_append(
				list_append(create_stmt_list(), h), 
				stmt_atom_int(bits)), 
				stmt_dup(inserts[c->c->colnr]->op2.stval))), 
				xor);
		} else {
			sql_subfunc *hf = sql_bind_func_result(sql->session->schema, "hash", &c->c->type, NULL, wrd);
			h = stmt_unop(stmt_dup(inserts[c->c->colnr]->op2.stval), hf);
		}
	}
	return h;
}

static stmt *
join_idx_insert(mvc *sql, sql_idx * i, stmt **inserts)
{
	node *m, *o;
	sql_idx *ri = ((sql_fkey *) i->key)->rkey->k.idx;
	stmt *rts = stmt_basetable(ri->t, ri->t->base.name);
	stmt *s = inserts[0]->op2.stval;

	if (s->key && s->nrcols == 0) {
		sql_subtype *bt = sql_bind_localtype("bit");
		sql_subfunc *or = sql_bind_func_result(sql->session->schema, "or", bt, bt, bt);
		stmt *cond = NULL;

		s = stmt_relselect_init();
		for (m = i->columns->h, o = ri->columns->h; m && o; m = m->next, o = o->next) {
			sql_kc *c = m->data;
			sql_kc *rc = o->data;

			stmt_relselect_fill(s, stmt_uselect(stmt_bat(rc->c, stmt_dup(rts), RDONLY), stmt_dup(inserts[c->c->colnr]->op2.stval), cmp_equal));

			if (c->c->null) {
				sql_subfunc *isnil = sql_bind_func(sql->session->schema, "isnull", &c->c->type, NULL);
				stmt *ins = stmt_dup(inserts[c->c->colnr]->op2.stval);

				ins = stmt_unop(ins, isnil);
				if (!cond) {
					cond = ins;
				} else {
					cond = stmt_binop(cond, ins, sql_dup_func(or));
				}
			}
		}
		sql_subfunc_destroy(or);

		/* add missing nulls (and NULLs only (SIMPLE MATCH)) */
		s = stmt_mark(stmt_reverse(s), 0);
		if (cond) {
			stmt *t = stmt_temp(bt);
			stmt *isnull = stmt_temp(tail_type(s));
			stmt *notnull = s;

			isnull = stmt_append(isnull, stmt_atom(atom_general(tail_type(s), NULL, 0)));
			t = stmt_append(t, cond);
			isnull = stmt_join(t, stmt_reverse(stmt_const(stmt_reverse(isnull), stmt_bool(1))), cmp_equal);
			notnull = stmt_join(stmt_dup(t), stmt_reverse(stmt_const(stmt_reverse(notnull), stmt_bool(0))), cmp_equal);
			s = stmt_union(isnull, notnull);
		}
	} else {
		int nulls = 0;

		s = stmt_releqjoin_init();
		for (m = i->columns->h, o = ri->columns->h; m && o; m = m->next, o = o->next) {
			sql_kc *c = m->data;
			sql_kc *rc = o->data;

			stmt_releqjoin_fill(s, stmt_dup(inserts[c->c->colnr]->op2.stval), stmt_bat(rc->c, stmt_dup(rts), RDONLY));
			if (c->c->null)
				nulls = 1;
		}
		/* add missing nulls (and NULLs only (SIMPLE MATCH)) */
		if (nulls) {
			stmt *cur = NULL, *missing = stmt_diff(stmt_dup(inserts[0]->op2.stval),
							       stmt_dup(s));

			for (m = i->columns->h; m; m = m->next) {

				sql_kc *c = m->data;
				sql_subfunc *isnil = sql_bind_func(sql->session->schema, "isnull",
								   &c->c->type, NULL);

				stmt *n;

				n = stmt_dup(inserts[c->c->colnr]->op2.stval);
				n = stmt_semijoin(n, stmt_dup(missing));
				n = stmt_unop(n, isnil);
				n = stmt_uselect(n, stmt_bool(1), cmp_equal);
				if (cur)
					cur = stmt_semijoin(cur, n);
				else
					cur = n;
			}
			stmt_destroy(missing);
			/* There is no merge union, so we need the expensive sort ! */
			s = stmt_union(s, stmt_const(cur, stmt_atom(atom_general(sql_bind_localtype("oid"), NULL, 0))));
		}
		s = stmt_reverse(stmt_order(stmt_reverse(s), 1));
	}
	stmt_destroy(rts);
	return s;
}

static void
sql_insert_idx(mvc *sql, stmt **inserts, sql_idx * i, list *l, int alter)
{
	stmt *is = NULL;

	if (i->type == hash_idx) {
		is = hash_insert(sql, i, inserts);
	} else if (i->type == join_idx) {
		is = join_idx_insert(sql, i, inserts);
	}
	if (i->key) {
		stmt *ckeys = sql_insert_key(sql, inserts, i->key, is, alter);

		list_prepend(l, ckeys);
	}
	/* append to the pre-computed join-index */
	if (is)
		list_append(l, stmt_append_idx(i, is));
}

static int
sql_insert_idxs(mvc *sql, sql_table *t, stmt **inserts, list *l)
{
	node *n;
	int res = 1;

	if (!t->idxs.set)
		return res;

	for (n = t->idxs.set->h; n; n = n->next) {
		sql_idx *i = n->data;

		sql_insert_idx(sql, inserts, i, l, 0);
	}
	return res;
}

static void
stack_add_inserted( mvc *sql, char *name, sql_table *t) 
{
	sql_rel *r = rel_basetable(t, name );
		
	stack_push_rel_view(sql, name, r);
}

static int
sql_insert_triggers(mvc *sql, sql_table *t, stmt **inserts, list *l)
{
	node *n;
	int res = 1;

	(void)inserts;
	if (!t->triggers.set)
		return res;

	for (n = t->triggers.set->h; n; n = n->next) {
		sql_trigger *trigger = n->data;
		int *trigger_id = NEW(int);
		*trigger_id = trigger->base.id;

		stack_push_frame(sql, "OLD-NEW");
		if (trigger->event == 0) { 
			stmt *s = NULL;
			char *n = trigger->new_name;

			/* add name for the 'inserted' to the stack */
			if (!n) n = "new"; 
	
			stack_add_inserted(sql, n, t);
			s = sql_parse(sql, trigger->statement, m_instantiate);
			
			if (!s) 
				return 0;
			if (trigger -> time )
				list_append(l, s);
			else
				list_prepend(l, s);
		}
		stack_pop_frame(sql);
	}
	return res;
}

static stmt ** 
table_update_array(sql_table *t, int *Len)
{
	stmt **updates;
	int i, len = list_length(t->columns.set);
	node *m;

	*Len = len;
	updates = NEW_ARRAY(stmt *, len);
	for (m = t->columns.set->h, i = 0; m; m = m->next, i++) {
		sql_column *c = m->data;

		/* update the column number, for correct array access */
		c->colnr = i;
		updates[i] = NULL;
	}
	return updates;
}

static stmt *
sql_insert(mvc *sql, sql_table *t, stmt **inserts, int len, int output)
{
	int i;
	list *l = create_stmt_list();
	node *n;
	sql_subaggr *cnt;
	stmt *s = NULL;

	if (!sql_insert_idxs(sql, t, inserts, l)) {
		list_destroy(l);
		return sql_error(sql, 02, "INSERT INTO: failed to update indexes for table '%s'", t->base.name);
	}

 	cnt = sql_bind_aggr(sql->session->schema, "count", NULL);
	for (n = t->columns.set->h; n; n = n->next) {
		sql_column *c = n->data;

		if (!inserts[c->colnr]) {
			list_destroy(l);
			sql_subaggr_destroy(cnt);
			return NULL;
		}
		if (!c->null) {
			stmt *s = inserts[c->colnr]->op2.stval;
			char *msg = NULL;

			if (!(s->key && s->nrcols == 0)) {
				s = stmt_atom(atom_general(&c->type, NULL, 0));
				s = stmt_uselect(stmt_dup(inserts[c->colnr]->op2.stval), s, cmp_equal);
				s = stmt_aggr(s, NULL, sql_dup_aggr(cnt), 1);
			} else {
				sql_subfunc *isnil = sql_bind_func(sql->session->schema, "isnull", &c->type, NULL);

				s = stmt_unop(stmt_dup(inserts[c->colnr]->op2.stval), isnil);
			}
			msg = sql_message( "INSERT INTO: NOT NULL constraint violated for column %s.%s", c->t->base.name, c->base.name);
			s = stmt_exception(s, msg, 00001);

			list_prepend(l, s);
		}
	}

	sql_subaggr_destroy(cnt);
	for (i = 0; i < len; i++)
		list_append(l, stmt_dup(inserts[i]));

	if (!sql_insert_triggers(sql, t, inserts, l)) {
		list_destroy(l);
		return sql_error(sql, 02, "INSERT INTO: triggers failed for table '%s'", t->base.name);
	}

	if (output) {
		if (inserts[0]->op2.stval->nrcols == 0) {
			s = stmt_atom_wrd(1);
		} else {
			s = stmt_aggr(stmt_dup(inserts[0]->op2.stval), NULL, sql_bind_aggr(sql->session->schema, "count", NULL), 1);
		}
		list_append(l, stmt_affected_rows(s));
	}
	return stmt_list(l);
}

static stmt *
sql_import(mvc *sql, sql_table *t, char *tsep, char *rsep, char *ssep, char *ns, char *filename, lng nr, lng offset)
{
	stmt *rs = NULL;
	stmt *fname = (filename) ? stmt_atom_string(_strdup(filename)) : NULL;
	node *n;
	int i, len = 0;
	stmt **inserts, *res = NULL;

	rs = stmt_import(stmt_basetable(t, t->base.name), _strdup(tsep), _strdup(rsep), _strdup(ssep), _strdup(ns), fname, nr, offset);
	inserts = table_update_array(t, &len);
	for (n = t->columns.set->h, i = 0; n; n = n->next, i++) {
		sql_column *c = n->data;

		inserts[i] = stmt_append_col(c, stmt_rs_column(stmt_dup(rs), stmt_atom_string(_strdup(c->base.name)), &c->type));
	}
	stmt_destroy(rs);
	res = sql_insert(sql, t, inserts, len, 1);
	return res;
}

static stmt *
copyfrom(mvc *sql, dlist *qname, dlist *files, dlist *seps, dlist *nr_offset, str null_string)
{
	char *sname = qname_schema(qname);
	char *tname = qname_table(qname);
	sql_schema *s = NULL;
	sql_table *t = NULL;
	char *tsep = seps->h->data.sval;
	char *rsep = seps->h->next->data.sval;
	char *ssep = (seps->h->next->next)?seps->h->next->next->data.sval:"\"";
	char *ns = (null_string)?null_string:"null";
	list *slist;
	lng nr = (nr_offset)?nr_offset->h->data.l_val:-1;
	lng offset = (nr_offset)?nr_offset->h->next->data.l_val:0;

	assert(!nr_offset || nr_offset->h->type == type_lng);
	assert(!nr_offset || nr_offset->h->next->type == type_lng);
	if (sname && !(s=mvc_bind_schema(sql, sname))) {
		(void) sql_error(sql, 02, "COPY INTO: no such schema '%s'", sname);
		return NULL;
	}
	if (!s)
		s = cur_schema(sql);
	t = mvc_bind_table(sql, s, tname);
	if (!t && !sname) {
		s = tmp_schema(sql);
		t = mvc_bind_table(sql, s, tname);
		if (!t) {
			sql_subtype *tpe = stack_find_type(sql, tname);
			if (tpe)
				t = tpe->comp_type;
		}
	}
	if (!t) {
		return sql_error(sql, 02, "COPY INTO: no such table '%s'", tname);
	} else if (files) {
		dnode *n = files->h;

		for (slist = create_stmt_list(); n; n = n->next) {
			char *fname = n->data.sval;

			list_append(slist, sql_import(sql, t, tsep, rsep, ssep, ns, fname, nr, offset));
		}
		return stmt_list(slist);
	}
	slist = create_stmt_list();
	list_append(slist, sql_import(sql, t, tsep, rsep, ssep, ns, NULL, nr, offset));
	return stmt_list(slist);
}

static stmt *
copyto(mvc *sql, symbol *sq, str filename, dlist *seps, str null_string)
{
	char *tsep = seps->h->data.sval;
	char *rsep = seps->h->next->data.sval;
	char *ssep = (seps->h->next->next)?seps->h->next->next->data.sval:"\"";
	char *ns = (null_string)?null_string:"null";
	stmt *s = flat_subquery(sql, sq);
	stmt *fname = (filename) ? stmt_atom_string(_strdup(filename)) : NULL;
	list *slist;

	if (!s) 
		return NULL;

	slist = create_stmt_list();
	list_append(slist, stmt_export(s, _strdup(tsep), _strdup(rsep), _strdup(ssep), _strdup(ns), fname));
	if (s->type == st_list && ((stmt*)s->op1.lval->h->data)->nrcols != 0) {
		stmt *cnt = stmt_aggr(stmt_dup(s->op1.lval->h->data), NULL, sql_bind_aggr(sql->session->schema, "count", NULL), 1);
		list_append(slist, stmt_affected_rows(cnt));
	} else {
		list_append(slist, stmt_affected_rows(stmt_atom_wrd(1)));
	}
	return stmt_list(slist);
}

stmt *
updates(mvc *sql, symbol *s)
{
	stmt *ret = NULL;

	switch (s->token) {
	case SQL_COPYFROM:
	{
		dlist *l = s->data.lval;

		ret = copyfrom(sql, l->h->data.lval, l->h->next->data.lval, l->h->next->next->data.lval, l->h->next->next->next->data.lval, l->h->next->next->next->next->data.sval);
		sql->type = Q_UPDATE;
	}
		break;
	case SQL_COPYTO:
	{
		dlist *l = s->data.lval;

		ret = copyto(sql, l->h->data.sym, l->h->next->data.sval, l->h->next->next->data.lval, l->h->next->next->next->data.sval);
		sql->type = Q_UPDATE;
	}
		break;
	default:
		return sql_error(sql, 01, "Updates statement unknown Symbol(" PTRFMT ")->token = %s", PTRFMTCAST s, token2string(s->token));
	}

	return ret;
}
