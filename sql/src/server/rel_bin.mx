@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2008 CWI.
@' All Rights Reserved.

@f rel_bin
@a N.J. Nes
@* 

@h
#ifndef _REL_BIN_H_
#define _REL_BIN_H_

#include "rel_semantic.h"
#include "sql_statement.h"

extern stmt * rel_bin(mvc *sql, sql_rel *rel);

#endif /*_REL_BIN_H_*/
@c
#include "sql_config.h"

#include "rel_bin.h"
#include "rel_exp.h"
#include "rel_prop.h"

static stmt * subrel_bin(mvc *sql, sql_rel *rel, list *refs);

static void 
print_stmtlist( stmt *l )
{
	node *n;
	if (l)
	for (n = l->op1.lval->h; n; n = n->next) {
		char *rnme = table_name(n->data);
		char *nme = column_name(n->data);

		printf("%s.%s\n", rnme, nme);
	}
}

static stmt *
bin_find_column( stmt *sub, char *rname, char *name ) 
{
	stmt *res = NULL;
	node *n;

	if (rname) {
		for (n = sub->op1.lval->h; n; n = n->next) {
			char *rnme = table_name(n->data);
			char *nme = column_name(n->data);

			if (rnme && strcmp(rnme, rname) == 0 && 
				    strcmp(nme, name) == 0) {
				res = n->data;
				break;
			}
		}
	} else {
		for (n = sub->op1.lval->h; n; n = n->next) {
			char *nme = column_name(n->data);

			if (strcmp(nme, name) == 0) {
				res = n->data;
				break;
			}
		}
	}
	if (!res)
		return NULL;
	return stmt_dup(res);
}

static stmt *const_column(stmt *val ) 
{
	sql_subtype *ct = tail_type(val);
	stmt *temp = stmt_temp(ct);
	return stmt_append(temp, val);
}

static stmt *column( stmt *val )
{
	val = stmt_dup(val);
	if (val->nrcols == 0)
		return const_column(val);
	return val;
}

static stmt *
bin_first_column( stmt *sub ) 
{
	node *n = sub->op1.lval->h;
	stmt *c = stmt_dup(n->data);

	if (c->nrcols == 0)
		return const_column(c);
	return c;
}

char *compare_func( comp_type t )
{
	switch(t) {
	case cmp_equal:
		return "=";
	case cmp_lt:
		return "<";
	case cmp_lte:
		return "<=";
	case cmp_gte:
		return ">=";
	case cmp_gt:
		return ">";
	case cmp_notequal:
		return "<>";
	default:
		return NULL;
	}
	return NULL;
}

static stmt *
exp_bin(mvc *sql, sql_exp *e, stmt *left, stmt *right, group *grp, stmt *sel) 
{
	stmt *s = NULL;

	if (!e) {
		assert(0);
		return NULL;
	}

	switch(e->type) {
	case e_atom: {
		if (e->l) { 			/* literals */
			atom *a = e->l;
			s = stmt_atom(atom_dup(a));
		} else if (e->r) { 		/* parameters */
			s = stmt_var(e->r, e->f, 0, e->flag);
		} else { 			/* arguments */
			s = stmt_varnr(e->flag, e->f);
		}
	}	break;
	case e_convert: {
		stmt *l = exp_bin(sql, e->l, left, right, grp, sel);
		list *tps = e->r;
		sql_subtype *from = tps->h->data;
		sql_subtype *to = tps->h->next->data;
		if (!l) 
			return NULL;
		s = stmt_convert(l, from, to);
	} 	break;
	case e_func: {
		node *en;
		list *l = create_stmt_list(), *exps = e->l, *obe = e->r;
		sql_subfunc *f = e->f;

		if (!obe && exps) {
			for (en = exps->h; en; en = en->next) {
				stmt *es;

				es = exp_bin(sql, en->data, left, right, grp, sel);
				if (!es) {
					list_destroy(l);
					return NULL;
				}
				list_append(l,es);
			}
		}
		/* Window expressions are handled differently.
		   ->l == group by expression list
		   ->r == order by expression list
		   If both lists are empty, we pass a single 
		 	column for the inner relation
		 */
		if (obe) {
			group *g = NULL;
			stmt *orderby = NULL;
		
			if (exps) {
				for (en = exps->h; en; en = en->next) {
					stmt *es;

					es = exp_bin(sql, en->data, left, right, NULL, sel);
					if (!es) {
						list_destroy(l);
						return NULL;
					}
					g = grp_create(es, g, NULL);
				}
			}
			/* order on the group first */
			if (g) 
				orderby = stmt_order(stmt_dup(g->grp), 1);
			for (en = obe->h; en; en = en->next) {
				sql_exp *orderbycole = en->data; 
				stmt *orderbycols = exp_bin(sql, orderbycole, left, right, NULL, sel); 

				if (!orderbycols) {
					list_destroy(l);
					return NULL;
				}
				if (orderby)
					orderby = stmt_reorder(orderby, orderbycols, is_ascending(orderbycole));
				else
					orderby = stmt_order(orderbycols, is_ascending(orderbycole));
			}
			if (!orderby)
				orderby = stmt_mirror(bin_first_column(left));
			list_append(l, orderby);
			if (g) {
				list_append(l, stmt_dup(g->grp));
				list_append(l, stmt_dup(g->ext));
				grp_destroy(g);
			}
		}
		if (strcmp(f->func->base.name, "identity") == 0) {
			s = stmt_mirror(stmt_dup(l->h->data));
			list_destroy(l);
		} else
			s = stmt_Nop(stmt_list(l), sql_dup_func(e->f)); 
	} 	break;
	case e_aggr: {
		list *attr = e->l; 
		stmt *as = NULL;
		stmt *as2 = NULL;
		sql_subaggr *a = e->f;
		group *g = grp;

		assert(sel == NULL);
		if (attr) { 
			as = exp_bin(sql, attr->h->data, left, right, NULL, sel);
			if (list_length(attr) == 2)
				as2 = exp_bin(sql, attr->h->next->data, left, right, NULL, sel);
			/* insert single value into a column */
			if (as && as->nrcols <= 0 && !left)
				as = stmt_append(stmt_temp(tail_type(as)), as);
		} else {
			/* count(*) may need the default group (relation) and
			   and/or an attribute to count */
			if (g) {
				as = stmt_dup(grp->grp);
			} else if (left) {
				as = bin_first_column(left);
			} else {
				/* create dummy single value in a column */
				as = stmt_atom_int(0);
				as = stmt_append(stmt_temp(tail_type(as)), as);
			}
		}
		if (!as) 
			return NULL;	

		if (as->nrcols <= 0 && left) 
			as = stmt_const(bin_first_column(left), as);
		/* inconsistent sql requires NULL != NULL and NULL <> NULL, ie unknown
		 * but also NULL means no values, which means 'ignore'
		 *
		 * so here we need to ignore NULLs
		 */
		if (has_no_nil(e) && attr) {
			sql_subtype *t = exp_subtype(attr->h->data);
			stmt *n = stmt_atom(atom_general(t, NULL, 0));
			as = stmt_select2(as, n, stmt_dup(n), 0);
		}
		if (need_distinct(e)){ 
			if (g)
				as = stmt_unique(as, grp_dup(grp));
			else
				as = stmt_unique(as, NULL);
		}
		if (g) 
			g = grp_dup(g);
		if (as2) 
			s = stmt_aggr2(stmt_reverse(as), as2, sql_dup_aggr(a) );
		else
			s = stmt_aggr(as, g, sql_dup_aggr(a), 1 );
		/* HACK: correct cardinality for window functions */
		if (e->card > CARD_AGGR)
			s->nrcols = 2;
	} 	break;
	case e_column: {
		if (right) /* check relation names */
			s = bin_find_column(right, e->l, e->r);
		if (!s && left) {
			if (left->type == st_Nop && tail_type(left)->comp_type ) { /* table function */
				s = stmt_rs_column(stmt_dup(left), stmt_atom_string(_strdup(e->r)), e->f/*subtype*/);
			} else {
				s = bin_find_column(left, e->l, e->r);
			}
		}
		if (s && grp)
			s = stmt_join(stmt_dup(grp->ext), s, cmp_equal);
		if (!s && right) {
			printf("could not find %s.%s\n", (char*)e->l, (char*)e->r);
			print_stmtlist(left);
			print_stmtlist(right);
		}
		if (sel)
			s = stmt_semijoin(s, stmt_dup(sel));
	 }	break;
	case e_cmp: {
		stmt *l = NULL, *r = NULL, *r2 = NULL;
		int swapped = 0, is_select = 0;
		sql_exp *re = e->r, *re2 = e->f;
		prop *p;

		/* here we handle join indices */
		if ((p=find_prop(e->p, PROP_JOINIDX)) != NULL) {
			sql_idx *i = p->value;
			sql_exp *el = e->l;
			sql_exp *er = e->r;

			/* find out left and right */
			l = bin_find_column(left, el->l, i->base.name);
			if (!l) {
				swapped = 1;
				l = bin_find_column(right, el->l, i->base.name);
				r = bin_find_column(left, er->l, "%OID%");
			} else {
				r = bin_find_column(right, er->l, "%OID%");
			}
			/* small performance improvement, ie use idx directly */
			if (l->type == st_alias && 
			    l->op1.stval->type == st_idxbat &&
			    r->type == st_alias && 
			    r->op1.stval->type == st_mirror) {
				stmt_destroy(r);
				s = l;
			} else if (swapped)
				s = stmt_join(r, stmt_reverse(l), cmp_equal);
			else
				s = stmt_join(l, stmt_reverse(r), cmp_equal);
			sql->opt_stats[0]++; 
			assert(sel==NULL);
			break;
		}
		if (!l) {
			l = exp_bin(sql, e->l, left, NULL, grp, sel);
			swapped = 0;
		}
		if (!l && right) {
 			l = exp_bin(sql, e->l, right, NULL, grp, sel);
			swapped = 1;
		}
		if (swapped || !right)
 			r = exp_bin(sql, e->r, left, NULL, grp, sel);
		else
 			r = exp_bin(sql, e->r, right, NULL, grp, sel);
		if (!r && !swapped) {
 			r = exp_bin(sql, e->r, left, NULL, grp, sel);
			is_select = 1;
		}
		if (re2)
 			r2 = exp_bin(sql, e->f, left, right, grp, sel);
		if (!l || !r || (re2 && !r2)) {
			assert(0);
			if (l) stmt_destroy(l);
			if (r) stmt_destroy(r);
			if (r2) stmt_destroy(r2);
			return NULL;
		}

		/* the escape charachter of like is in the right expression */
		if (e->flag == cmp_notlike || e->flag == cmp_like) {
			if (!e->f)
				r2 = stmt_atom_string(_strdup(""));
			if (!l || !r || !r2) {
				assert(0);
				if (l) stmt_destroy(l);
				if (r) stmt_destroy(r);
				if (r2) stmt_destroy(r2);
				return NULL;
			}
			return stmt_likeselect(l, r, r2, (comp_type)e->flag);
		}
		if (left && right && re->card > CARD_ATOM && !is_select) {
			if (l->nrcols == 0)
				l = stmt_const(bin_first_column(swapped?right:left), l); 
			if (r->nrcols == 0)
				r = stmt_const(bin_first_column(swapped?left:right), r); 
			if (swapped) {
				s = stmt_join(r, stmt_reverse(l), swap_compare((comp_type)e->flag));
			} else if (r2) {
				s = stmt_join2(l, r, r2, (comp_type)e->flag);
			} else {
				s = stmt_join(l, stmt_reverse(r), (comp_type)e->flag);
			}
		} else {
			if (r2) {
				s = stmt_uselect2(l, r, r2, (comp_type)e->flag);
			} else {
				/* value compare or select */
				if (l->nrcols == 0 && r->nrcols == 0) {
					sql_subfunc *f = sql_bind_func(sql->session->schema, compare_func((comp_type)e->flag), tail_type(l), tail_type(r));
					assert(f);
					s = stmt_binop(l, r, f);
				} else
					s = stmt_uselect(l, r, (comp_type)e->flag);
			}
		}
		if (is_anti(e))
			s->flag |= ANTI;
	 }	break;
	default:
		;
	}
	return s;
}


static stmt *
stmt_rename( sql_rel *rel, sql_exp *exp, stmt *s )
{
	char *name = exp->name;
	char *rname = exp->rname;

	if (!name)
		name = column_name(s);
	if (!rname) 	
		rname = rel->name;
	if (!rname)
		rname = table_name(s);
	name = _strdup(name);
	rname = (rname)?_strdup(rname):NULL;
	s = stmt_alias(s, rname, name);
	return s;
}

static stmt *
rel2bin_basetable( mvc *sql, sql_rel *rel, list *refs )
{
	list *l; 
	stmt *ts, *sub = NULL;
	sql_table *t = rel->l;
	node *n;
			
	(void)sql;
	(void)refs;
	l = create_stmt_list();
	ts = stmt_basetable(t, (rel->name)?rel->name:t->base.name);
	for (n = t->columns.set->h; n; n = n->next) {
		sql_column *c = n->data;

		stmt *sc = stmt_bat(c, stmt_dup(ts), RDONLY);
		list_append(l, sc);
	}
	if (t->idxs.set) {
		/* oid column */
		if (t->columns.set->h) { 
			sql_column *c = t->columns.set->h->data;
			stmt *sc = stmt_bat(c, stmt_dup(ts), RDONLY);
			char *rnme = (rel->name)?rel->name:t->base.name;
	
			rnme = (rnme)?_strdup(rnme):NULL;
			sc = stmt_mirror(sc);
			sc = stmt_alias(sc, rnme, _strdup("%OID%"));
			list_append(l, sc);
		}
		for (n = t->idxs.set->h; n; n = n->next) {
			sql_idx *i = n->data;
			stmt *sc = stmt_idxbat(i, RDONLY);
			char *rnme = (rel->name)?rel->name:t->base.name;

			rnme = (rnme)?_strdup(rnme):NULL;
			sc = stmt_alias(sc, rnme, _strdup(i->base.name));
			list_append(l, sc);
		}
	}
	stmt_destroy(ts);
	sub = stmt_list(l);
	/* add aliases */
	if (rel->exps) {
		node *en;
		for( en = rel->exps->h; en; en = en->next ) {
			sql_exp *exp = en->data;
			stmt *s = bin_find_column(sub, exp->l, exp->r);
			char *rname = exp->rname;
	
			if (!s) {
				assert(0);
				stmt_destroy(sub);
				return NULL;
			}
			rname = rname?_strdup(rname):NULL;
			s = stmt_alias(s, NULL, _strdup(exp->name));
			list_append(l, s);
		}
	}
	return sub;
}

static stmt *
rel2bin_table( mvc *sql, sql_rel *rel, list *refs )
{
	list *l; 
	stmt *sub = NULL;
	node *en;
			
	(void)refs;
	sub = exp_bin(sql, rel->l, NULL, NULL, NULL, NULL); /* table function */
	if (!sub) { 
		assert(0);
		return NULL;	
	}
	l = create_stmt_list();
	for( en = rel->exps->h; en; en = en->next ) {
		sql_exp *exp = en->data;
		stmt *s = exp_bin(sql, exp, sub, NULL, NULL, NULL);
		char *rnme = rel->name;

		if (!s) {
			assert(0);
			list_destroy(l);
			if (sub) 
				stmt_destroy(sub);
			return NULL;
		}
		if (sub && sub->nrcols >= 1 && s->nrcols == 0)
			s = stmt_const(bin_first_column(sub), s);
		else if (!sub)
			s = column(s);
		rnme = (rnme)?_strdup(rnme):NULL;
		s = stmt_alias(s, rnme, _strdup(exp->name));
		list_append(l, s);
	}
	if (sub) 
		stmt_destroy(sub);
	sub = stmt_list(l);
	return sub;
}

static int
equi_join(stmt *j)
{
	if (j->flag == cmp_equal)
		return 0;
	return -1;
}

static int
not_equi_join(stmt *j)
{
	if (j->flag != cmp_equal)
		return 0;
	return -1;
}

static stmt *
rel2bin_join( mvc *sql, sql_rel *rel, list *refs )
{
	list *l; 
	node *en, *n;
	stmt *left = NULL, *right = NULL, *join = NULL, *jl, *jr;
	stmt *ld = NULL, *rd = NULL;

	if (rel->l) /* first construct the left sub relation */
		left = subrel_bin(sql, rel->l, refs);
	if (rel->r) /* first construct the right sub relation */
		right = subrel_bin(sql, rel->r, refs);
	if (!left || !right) { 
		assert(0);
		if (left) stmt_destroy(left);
		if (right) stmt_destroy(right);
		return NULL;	
	}
	if (rel->exps) {
		int idx = 0;
		list *jns = create_stmt_list();

		/* generate a stmt_reljoin */
		for( en = rel->exps->h; en; en = en->next ) {
			int join_idx = sql->opt_stats[0];
			stmt *s = exp_bin(sql, en->data, left, right, NULL, NULL);

			if (!s) {
				assert(0);
				stmt_destroy(left);
				stmt_destroy(right);
				list_destroy(jns);
				return NULL;
			}
			if (join_idx != sql->opt_stats[0])
				idx = 1;
			if (!join) {
				join = s;
			} else if (s->type != st_join && s->type != st_join2) {
				/* handle select expressions */
				assert(0);
				if (s->h == join->h) {
					join = stmt_semijoin(join,s);
				} else {
					join = stmt_reverse(join);
					join = stmt_semijoin(join,s);
					join = stmt_reverse(join);
				}
				continue;
			}
			list_append(jns, s);
		}
		if (list_length(jns) > 1) {
			int o = 1, *O = &o;
			/* move all equi joins into a releqjoin */
			list *eqjns = list_select(jns, O, (fcmp)&equi_join, (fdup)stmt_dup);
			if (!idx && list_length(eqjns) > 1) {
				list *neqjns = list_select(jns, O, (fcmp)&not_equi_join, (fdup)stmt_dup);
				list_destroy(jns);
				join = stmt_reljoin(stmt_releqjoin1(eqjns), neqjns);
			} else {
				join = stmt_reljoin(NULL, jns);
				list_destroy(eqjns);
			}
		} else {
			join = stmt_dup(jns->h->data); 
			list_destroy(jns);
		}
	} else {
		stmt *l = bin_first_column(left);
		stmt *r = bin_first_column(right);
		join = stmt_join(l, stmt_reverse(r), cmp_all); 
	}

	/* construct relation */
	l = create_stmt_list();

	jl = stmt_reverse(stmt_mark_tail(stmt_dup(join),0));
	if (rel->op == op_left || rel->op == op_full) {
		/* we need to add the missing oid's */
		ld = stmt_diff(bin_first_column(left), stmt_reverse(stmt_dup(jl)));
		ld = stmt_mark(stmt_reverse(ld), 0);
	}
	jr = stmt_reverse(stmt_mark_tail(stmt_reverse(join),0));
	if (rel->op == op_right || rel->op == op_full) {
		/* we need to add the missing oid's */
		rd = stmt_diff(bin_first_column(right), stmt_reverse(stmt_dup(jr)));
		rd = stmt_mark(stmt_reverse(rd), 0);
	}

	for( n = left->op1.lval->h; n; n = n->next ) {
		stmt *c = n->data;
		char *rnme = table_name(c);
		char *nme = column_name(c);
		stmt *s = stmt_join(stmt_dup(jl), column(c), cmp_equal);

		if (rel->op == op_left || rel->op == op_full)
			s = stmt_append(s, stmt_join(stmt_dup(ld), stmt_dup(c), cmp_equal));
		if (rel->op == op_right || rel->op == op_full) 
			s = stmt_append(s, stmt_const(stmt_dup(rd), stmt_atom(atom_general(tail_type(c), NULL, 0))));

		rnme = (rnme)?_strdup(rnme):NULL;
		s = stmt_alias(s, rnme, _strdup(nme));
		list_append(l, s);
	}
	stmt_destroy(jl);
	stmt_destroy(left);
	for( n = right->op1.lval->h; n; n = n->next ) {
		stmt *c = n->data;
		char *rnme = table_name(c);
		char *nme = column_name(c);
		stmt *s = stmt_join(stmt_dup(jr), column(c), cmp_equal);

		if (rel->op == op_left || rel->op == op_full) 
			s = stmt_append(s, stmt_const(stmt_dup(ld), stmt_atom(atom_general(tail_type(c), NULL, 0))));
		if (rel->op == op_right || rel->op == op_full) 
			s = stmt_append(s, stmt_join(stmt_dup(rd), stmt_dup(c), cmp_equal));

		rnme = (rnme)?_strdup(rnme):NULL;
		s = stmt_alias(s, rnme, _strdup(nme));
		list_append(l, s);
	}
	stmt_destroy(jr);
	stmt_destroy(right);
	if (ld)
		stmt_destroy(ld);
	if (rd)
		stmt_destroy(rd);
	return stmt_list(l);
}

static stmt *
rel2bin_semijoin( mvc *sql, sql_rel *rel, list *refs )
{
	list *l; 
	node *en, *n;
	stmt *left = NULL, *right = NULL, *join = NULL;

	if (rel->l) /* first construct the left sub relation */
		left = subrel_bin(sql, rel->l, refs);
	if (rel->r) /* first construct the right sub relation */
		right = subrel_bin(sql, rel->r, refs);
	if (!left || !right) { 
		assert(0);
		if (left) stmt_destroy(left);
		if (right) stmt_destroy(right);
		return NULL;	
	}
	if (rel->exps) {
		for( en = rel->exps->h; en; en = en->next ) {
			stmt *s = exp_bin(sql, en->data, left, right, NULL, NULL);

			if (!s) {
				assert(0);
				stmt_destroy(left);
				stmt_destroy(right);
				if (join)
					stmt_destroy(join);
				return NULL;
			}
			if (!join) {
				join = s;
			} else {
				/* break column join */
				stmt *l = stmt_mark(stmt_reverse(join), 100);
				stmt *r = stmt_mark(stmt_dup(join), 100);
				stmt *ld = stmt_dup(s->op1.stval);
				stmt *rd = stmt_reverse(stmt_dup(s->op2.stval));
				stmt *le = stmt_join(l, ld, cmp_equal);
				stmt *re = stmt_join(r, rd, cmp_equal);

				sql_subfunc *f = sql_bind_func(sql->session->schema, compare_func((comp_type)s->flag), tail_type(le), tail_type(le));
				stmt * cmp;

				assert(f);

				cmp = stmt_binop(le, re, f);

				cmp = stmt_uselect(cmp, stmt_bool(1), cmp_equal);

				l = stmt_semijoin(stmt_dup(l), stmt_dup(cmp));
				r = stmt_semijoin(stmt_dup(r), cmp);
				join = stmt_join(stmt_reverse(l), r, cmp_equal);
				stmt_destroy(s);
			}
		}
	} else {
		/* TODO: this case could use some optimization */
		stmt *l = bin_first_column(left);
		stmt *r = bin_first_column(right);
		join = stmt_join(l, stmt_reverse(r), cmp_all); 
	}

	/* construct relation */
	l = create_stmt_list();

	/* We did a full join, thats too much. 
	   Reduce this using difference and semijoin */
	if (rel->op == op_anti) {
		stmt *c = left->op1.lval->h->data;
		join = stmt_diff(stmt_dup(c), join);
	} else {
		stmt *c = left->op1.lval->h->data;
		join = stmt_semijoin(stmt_dup(c), join);
	}

	join = stmt_reverse(stmt_mark_tail(join,0));

	/* semijoin all the left columns */
	for( n = left->op1.lval->h; n; n = n->next ) {
		stmt *c = n->data;
		char *rnme = table_name(c);
		char *nme = column_name(c);
		stmt *s = stmt_join(stmt_dup(join), column(c), cmp_equal);

		rnme = (rnme)?_strdup(rnme):NULL;
		s = stmt_alias(s, rnme, _strdup(nme));
		list_append(l, s);
	}
	stmt_destroy(join);
	stmt_destroy(left);
	stmt_destroy(right);
	return stmt_list(l);
}

static stmt *
rel2bin_distinct(stmt *s)
{
	node *n;
	group *grp = NULL;
	list *rl = create_stmt_list();

	for (n = s->op1.lval->h; n; n = n->next) {
		stmt *t = n->data;

		grp = grp_create(column(t), grp, NULL);
	}

	for (n = s->op1.lval->h; n; n = n->next) {
		stmt *t = n->data;

		list_append(rl, stmt_join(stmt_dup(grp->ext), stmt_dup(t), cmp_equal));
	}

	if (grp)
		grp_destroy(grp);
	stmt_destroy(s);
	s = stmt_list(rl);
	return s;
}

static stmt *
rel2bin_union( mvc *sql, sql_rel *rel, list *refs )
{
	list *l; 
	node *n, *m;
	stmt *left = NULL, *right = NULL, *sub;

	if (rel->l) /* first construct the left sub relation */
		left = subrel_bin(sql, rel->l, refs);
	if (rel->r) /* first construct the right sub relation */
		right = subrel_bin(sql, rel->r, refs);
	if (!left || !right) { 
		assert(0);
		if (left) stmt_destroy(left);
		if (right) stmt_destroy(right);
		return NULL;	
	}

	/* construct relation */
	l = create_stmt_list();
	for( n = left->op1.lval->h, m = right->op1.lval->h; n && m; 
		n = n->next, m = m->next ) {
		stmt *c1 = n->data;
		stmt *c2 = stmt_dup(m->data);
		char *rnme = rel->name;
		char *nme = column_name(c1);
		stmt *s;

		/* append isn't save, ie use union 
			(also not save loses unique head oids) 

		   so we create append on copies.
		*/
		s = stmt_append(column(c1), c2);
		if (!rnme)
			rnme = table_name(c1);
		nme = _strdup(nme);
		rnme = (rnme)?_strdup(rnme):NULL;
		s = stmt_alias(s, rnme, nme);
		list_append(l, s);
	}
	stmt_destroy(left);
	stmt_destroy(right);
	sub = stmt_list(l);
	if (need_distinct(rel)) 
		sub = rel2bin_distinct(sub);
	return sub;
}

static stmt *
rel2bin_except( mvc *sql, sql_rel *rel, list *refs )
{
	list *stmts; 
	node *n, *m;
	stmt *left = NULL, *right = NULL, *sub;

	group *lgrp = NULL, *rgrp = NULL;
	stmt *s, *lm, *ls = NULL, *rs = NULL, *ld = NULL;
	sql_subaggr *a;

	if (rel->l) /* first construct the left sub relation */
		left = subrel_bin(sql, rel->l, refs);
	if (rel->r) /* first construct the right sub relation */
		right = subrel_bin(sql, rel->r, refs);
	if (!left || !right) { 
		assert(0);
		if (left) stmt_destroy(left);
		if (right) stmt_destroy(right);
		return NULL;	
	}

	/* construct relation */
	stmts = create_stmt_list();
	/*
	 * The multi column intersect is handled using group by's and
	 * group size counts on both sides of the intersect. We then
	 * return for each group of A with min(A.count,B.count), 
	 * number of rows.
	 * 
	 * The problem with this approach is that the groups should
	 * have equal group identifiers. So we take the union of all
	 * columns before the group by.
	 */
	for (n = left->op1.lval->h; n; n = n->next) 
		lgrp = grp_create(column(n->data), lgrp, NULL);
	for (n = right->op1.lval->h; n; n = n->next) 
		rgrp = grp_create(column(n->data), rgrp, NULL);

 	a = sql_bind_aggr(sql->session->schema, "count", NULL);
	ls = stmt_aggr(stmt_dup(lgrp->grp), grp_dup(lgrp), a, 1); 
	a = sql_dup_aggr(a);
	rs = stmt_aggr(stmt_dup(rgrp->grp), grp_dup(rgrp), a, 1); 

	/* now find the matching groups */
	s = stmt_releqjoin_init();
	for (n = left->op1.lval->h, m = right->op1.lval->h; n && m; n = n->next, m = m->next) {
		stmt *l = column(n->data);
		stmt *r = column(m->data);

		l = stmt_join(stmt_dup(lgrp->ext), l, cmp_equal);
		r = stmt_join(stmt_dup(rgrp->ext), r, cmp_equal);
		stmt_releqjoin_fill(s, l, r);
	}

	/* the join of the groups removed those in A but not in B,
	 * we need these later so keep these in 'ld' */
	ld = stmt_diff(stmt_dup(ls), stmt_dup(s));
		
	/*if (!distinct) */
	{
		sql_subfunc *sub;

		lm = stmt_reverse(stmt_mark_tail(stmt_dup(s),0));
		ls = stmt_join(stmt_dup(lm),ls,cmp_equal);
		rs = stmt_join(stmt_mark(s,0),rs,cmp_equal);

 		sub = sql_bind_func(sql->session->schema, "sql_sub", tail_type(ls), tail_type(rs));
		/*s = sql_binop_(sql, NULL, "sql_sub", ls, rs);*/
		s = stmt_binop(ls, rs, sub);
		s = stmt_select(s, stmt_atom_int(0), cmp_gt);

		/* A ids */
		s = stmt_join(stmt_reverse(lm), s, cmp_equal);
		/* now we need to add the groups which weren't in B */
		s = stmt_union(ld,s);
		/* now we have gid,cnt, blowup to full groupsizes */
		s = stmt_gen_group(s);
	/*
	} else {
		stmt_destroy(s);
		s = ld;
	*/
	}
	s = stmt_mark_tail(s, 500); 
	/* from gid back to A id's */
	s = stmt_reverse(stmt_join(stmt_dup(lgrp->ext), s, cmp_equal));

	grp_destroy(lgrp);
	grp_destroy(rgrp);

	/* project columns of left hand expression */
	for (n = left->op1.lval->h; n; n = n->next) {
		stmt *c1 = column(n->data);
		char *rnme = rel->name;
		char *nme = column_name(c1);

		/* retain name via the stmt_alias */
		c1 = stmt_join(stmt_dup(s), c1, cmp_equal);

		if (!rnme)
			rnme = table_name(c1);
		
		nme = _strdup(nme);
		rnme = (rnme)?_strdup(rnme):NULL;
		c1 = stmt_alias(c1, rnme, nme);
		list_append(stmts, c1);
	}
	stmt_destroy(s);

	stmt_destroy(left);
	stmt_destroy(right);
	sub = stmt_list(stmts);
	if (need_distinct(rel))
		sub = rel2bin_distinct(sub);
	return sub;
}

static stmt *
rel2bin_inter( mvc *sql, sql_rel *rel, list *refs )
{
	list *stmts; 
	node *n, *m;
	stmt *left = NULL, *right = NULL, *sub;

	group *lgrp = NULL, *rgrp = NULL;
	stmt *s, *lm, *ls = NULL, *rs = NULL;
	sql_subaggr *a;

	if (rel->l) /* first construct the left sub relation */
		left = subrel_bin(sql, rel->l, refs);
	if (rel->r) /* first construct the right sub relation */
		right = subrel_bin(sql, rel->r, refs);
	if (!left || !right) { 
		assert(0);
		if (left) stmt_destroy(left);
		if (right) stmt_destroy(right);
		return NULL;	
	}

	/* construct relation */
	stmts = create_stmt_list();
	/*
	 * The multi column intersect is handled using group by's and
	 * group size counts on both sides of the intersect. We then
	 * return for each group of A with min(A.count,B.count), 
	 * number of rows.
	 * 
	 * The problem with this approach is that the groups should
	 * have equal group identifiers. So we take the union of all
	 * columns before the group by.
	 */
	for (n = left->op1.lval->h; n; n = n->next) 
		lgrp = grp_create(column(n->data), lgrp, NULL);
	for (n = right->op1.lval->h; n; n = n->next) 
		rgrp = grp_create(column(n->data), rgrp, NULL);

 	a = sql_bind_aggr(sql->session->schema, "count", NULL);
	ls = stmt_aggr(stmt_dup(lgrp->grp), grp_dup(lgrp), a, 1); 
	a = sql_dup_aggr(a);
	rs = stmt_aggr(stmt_dup(rgrp->grp), grp_dup(rgrp), a, 1); 

	/* now find the matching groups */
	s = stmt_releqjoin_init();
	for (n = left->op1.lval->h, m = right->op1.lval->h; n && m; n = n->next, m = m->next) {
		stmt *l = column(n->data);
		stmt *r = column(m->data);

		l = stmt_join(stmt_dup(lgrp->ext), l, cmp_equal);
		r = stmt_join(stmt_dup(rgrp->ext), r, cmp_equal);
		stmt_releqjoin_fill(s, l, r);
	}
		
	/*if (!distinct) */
	{
		sql_subfunc *min;

		lm = stmt_reverse(stmt_mark_tail(stmt_dup(s),0));
		ls = stmt_join(stmt_dup(lm),ls,cmp_equal);
		rs = stmt_join(stmt_mark(s,0),rs,cmp_equal);

 		min = sql_bind_func(sql->session->schema, "sql_min", tail_type(ls), tail_type(rs));
		/*s = sql_binop_(sql, NULL, "sql_min", ls, rs);*/
		s = stmt_binop(ls, rs, min);
		/* A ids */
		s = stmt_join(stmt_reverse(lm), s, cmp_equal);
		/* now we have gid,cnt, blowup to full groupsizes */
		s = stmt_gen_group(s);
	}
	s = stmt_mark_tail(s, 500); 
	/* from gid back to A id's */
	s = stmt_reverse(stmt_join(stmt_dup(lgrp->ext), s, cmp_equal));

	grp_destroy(lgrp);
	grp_destroy(rgrp);

	/* project columns of left hand expression */
	for (n = left->op1.lval->h; n; n = n->next) {
		stmt *c1 = column(n->data);
		char *rnme = rel->name;
		char *nme = column_name(c1);

		/* retain name via the stmt_alias */
		c1 = stmt_join(stmt_dup(s), c1, cmp_equal);

		if (!rnme)
			rnme = table_name(c1);
		
		nme = _strdup(nme);
		rnme = (rnme)?_strdup(rnme):NULL;
		c1 = stmt_alias(c1, rnme, nme);
		list_append(stmts, c1);
	}
	stmt_destroy(s);

	stmt_destroy(left);
	stmt_destroy(right);
	sub = stmt_list(stmts);
	if (need_distinct(rel))
		sub = rel2bin_distinct(sub);
	return sub;
}

static stmt *
rel2bin_project( mvc *sql, sql_rel *rel, list *refs )
{
	list *l; 
	node *en;
	stmt *sub = NULL, *psub = NULL;

	if (!rel->exps) 
		return stmt_none();

	if (rel->l) { /* first construct the sub relation */
		sub = subrel_bin(sql, rel->l, refs);
		if (!sub) { 
			assert(0);
			return NULL;	
		}
	}
	l = create_stmt_list();
	for( en = rel->exps->h; en; en = en->next ) {
		sql_exp *exp = en->data;
		stmt *s = exp_bin(sql, exp, sub, NULL, NULL, NULL);

		if (!s) {
			assert(0);
			cond_stmt_destroy(sub);
			list_destroy(l);
			return NULL;
		}
		if (sub && sub->nrcols >= 1 && s->nrcols == 0)
			s = stmt_const(bin_first_column(sub), s);
		else if (!sub)
			s = column(s);
			
		s = stmt_rename(rel, exp, s);
		list_append(l, s);
	}
	psub = stmt_list(l);
	if (need_distinct(rel))
		psub = rel2bin_distinct(psub);
	if (rel->r) {
		list *oexps = rel->r;
		stmt *orderby = NULL;

		for (en = oexps->h; en; en = en->next) {
			sql_exp *orderbycole = en->data; 
			stmt *orderbycols = exp_bin(sql, orderbycole, sub, psub, NULL, NULL); 

			if (!orderbycols) {
				assert(0);
				stmt_destroy(sub);
				cond_stmt_destroy(orderby);
				return NULL;
			}
			if (orderby)
				orderby = stmt_reorder(orderby, orderbycols, is_ascending(orderbycole));
			else
				orderby = stmt_order(orderbycols, is_ascending(orderbycole));
		}
		psub = stmt_ordered(orderby, psub);
	}
	if (sub) 
		stmt_destroy(sub);
	return psub;
}

static stmt *
rel2bin_predicate(void) 
{
	sql_subtype *bt = sql_bind_localtype("bit");
	stmt *temp = stmt_temp(bt);
	return stmt_append(temp, stmt_bool(1));
}

static stmt *
rel2bin_hash_lookup( mvc *sql, sql_rel *rel, stmt *sub, sql_idx *i, node *en ) 
{
	sql_subtype *it = sql_bind_localtype("int");
	stmt *h = NULL;
	stmt *bits = stmt_atom_int(1 + 31/(list_length(i->columns)+2));
	sql_exp *e = en->data;
	sql_exp *l = e->l;
	stmt *idx = bin_find_column(sub, l->l, i->base.name);

	/* TODO should be in key order! */
	for( en = rel->exps->h; en; en = en->next ) {
		sql_exp *e = en->data;
		stmt *s;

		assert(e->type == e_cmp && e->flag == cmp_equal);
		s = exp_bin(sql, e->r, NULL, NULL, NULL, NULL);

		if (h) {
			sql_subfunc *xor = sql_bind_func_result3(sql->session->schema, "rotate_xor_hash", it, it, tail_type(s), it);

			h = stmt_Nop(stmt_list( list_append( list_append(
				list_append(create_stmt_list(), h), 
				stmt_dup(bits)), s)), xor);
		} else {
			sql_subfunc *hf = sql_bind_func_result(sql->session->schema, "hash", tail_type(s), NULL, it);

			h = stmt_unop(s, hf);
		}
	}
	stmt_destroy(bits);
	return stmt_uselect(idx, h, cmp_equal);
}


static stmt *
rel2bin_select( mvc *sql, sql_rel *rel, list *refs )
{
	list *l; 
	node *en, *n;
	stmt *sub = NULL, *sel = NULL;
	stmt *predicate = NULL;

	if (!rel->exps) {
		assert(0);
		return NULL;
	}

	if (rel->l) { /* first construct the sub relation */
		sub = subrel_bin(sql, rel->l, refs);
		if (!sub) { 
			assert(0);
			return NULL;	
		}
	} else {
		predicate = rel2bin_predicate();
	}
	/* handle possible index lookups */
	/* expressions are in index order ! */
	if ( (en = rel->exps->h) != NULL) { 
		sql_exp *e = en->data;
		prop *p;

		if ((p=find_prop(e->p, PROP_HASHIDX)) != NULL) {
			sql_idx *i = p->value;
			
			sel = rel2bin_hash_lookup(sql, rel, sub, i, en);
		}
	}
	sel = stmt_relselect_init();
	for( en = rel->exps->h; en; en = en->next ) {
		//stmt *s = exp_bin(sql, en->data, sub, NULL, NULL, sel);
		stmt *s = exp_bin(sql, en->data, sub, NULL, NULL, NULL);

		if (!s) {
			assert(0);
			if (sub) stmt_destroy(sub);
			if (predicate) stmt_destroy(predicate);
			if (sel) stmt_destroy(sel);
			return NULL;
		}
		if (s->nrcols == 0){ 
			if (!predicate) 
				predicate = rel2bin_predicate();
			predicate = stmt_uselect(predicate, s, cmp_equal);
		} else {
			/*
			if (sel) 
				stmt_destroy(sel);
			sel = s;
			*/
			stmt_relselect_fill(sel, s);
		}
	}

	if (predicate && sel) {
		if (list_length(sel->op1.lval) == 0) {
			stmt_destroy(sel);
			sel = NULL;
		} else {
			sel = stmt_join(sel, stmt_dup(predicate), cmp_all);
		}
	}
	/* construct relation */
	l = create_stmt_list();
	if (sub && sel) {
		sel = stmt_mark(stmt_reverse(sel),0);
		for( n = sub->op1.lval->h; n; n = n->next ) {
			stmt *col = stmt_dup(n->data);
	
			sel = stmt_dup(sel);
			if (col->nrcols == 0) /* constant */
				col = stmt_const(sel, col);
			else
				col = stmt_join(sel, col, cmp_equal);
			list_append(l, col);
		}
	} else if (sub && predicate) {
		stmt *h = NULL;
		n = sub->op1.lval->h;
		h = stmt_join( stmt_dup(n->data), stmt_dup(predicate), cmp_all);
		h = stmt_reverse(stmt_mark_tail(h, 0)); 
		for( n = sub->op1.lval->h; n; n = n->next ) {
			stmt *col = stmt_dup(n->data);
	
			h = stmt_dup(h);
			if (col->nrcols == 0) /* constant */
				col = stmt_const(h, col);
			else
				col = stmt_join(h, col, cmp_equal);
			list_append(l, col);
		}
		stmt_destroy(h);
	} else if (predicate) {
		list_append(l, stmt_dup(predicate));
	}
	if (predicate) stmt_destroy(predicate);
	if (sub) stmt_destroy(sub);
	if (sel) stmt_destroy(sel);
	return stmt_list(l);
}

static stmt *
rel2bin_groupby( mvc *sql, sql_rel *rel, list *refs )
{
	list *l, *aggrs;
	node *n, *en;
	stmt *sub = NULL, *cursub;
	group *groupby = NULL;

	if (rel->l) { /* first construct the sub relation */
		sub = subrel_bin(sql, rel->l, refs);
		if (!sub) { 
			assert(0);
			return NULL;	
		}
	}

	/* groupby columns */
	if (rel->r) {
		list *exps = rel->r; 

		for( en = exps->h; en; en = en->next ) {
			sql_exp *e = en->data; 
			stmt *gbcol = exp_bin(sql, e, sub, NULL, NULL, NULL); 
	
			if (!gbcol) {
				assert(0);
				stmt_destroy(sub);
				if (groupby) 
					grp_destroy(groupby);
				return NULL;
			}
			groupby = grp_create(gbcol, groupby, NULL);
		}
	}
	/* now aggregate */
	l = create_stmt_list();
	aggrs = rel->exps;
	cursub = stmt_list(l);
	for( n = aggrs->h; n; n = n->next ) {
		sql_exp *aggrexp = n->data;

		stmt *aggrstmt = exp_bin(sql, aggrexp, sub, NULL, groupby, NULL); 

		/* maybe the aggr uses intermediate results of this group by,
		   therefor we pass the group by columns too 
		 */
		if (!aggrstmt) 
			aggrstmt = exp_bin(sql, aggrexp, sub, cursub, groupby, NULL); 
		if (!aggrstmt) {
			assert(0);
			stmt_destroy(cursub);
			stmt_destroy(sub);
			if (groupby) grp_destroy(groupby);
			return NULL;
		}

		aggrstmt = stmt_rename(rel, aggrexp, aggrstmt);
		list_append(l, aggrstmt);
	}
	if (sub) stmt_destroy(sub);
	if (groupby) grp_destroy(groupby);
	return cursub;
}

static stmt *
rel2bin_topn( mvc *sql, sql_rel *rel, list *refs )
{
	list *newl;
	int l = -1, o = 0;
	stmt *sub = NULL, *order = NULL;
	node *n;

	if (rel->l) /* first construct the sub relation */
		sub = subrel_bin(sql, rel->l, refs);
	if (!sub) { 
		assert(0);
		return NULL;	
	}

	if (rel->exps) {
		sql_exp *limit = rel->exps->h->data;
		atom *a = limit->l;

		l = a->data.val.ival;
		if (list_length(rel->exps) > 1) {
			sql_exp *offset = rel->exps->h->next->data;

			a = offset->l;
			o = a->data.val.ival;
			if (o <= 0)
				o = 0;
		}
	}

	if (sub->type == st_ordered) {
		stmt *s = stmt_dup(sub->op2.stval);
		order = stmt_dup(sub->op1.stval);
		stmt_destroy(sub);
		sub = s;
	}
	n = sub->op1.lval->h;
	newl = create_stmt_list();

	if (n) {
		stmt *limit = NULL;
		int lmt = l;

		if (l < 0) {
			l = o;
			o = 0;
		}

		if (order) {
		 	limit = stmt_limit(stmt_dup(order), o, l, 0);
		} else {
			limit = stmt_limit(stmt_dup(n->data), o, l, 0);
			if (lmt >= 0) {
				n = n->next;
				list_append(newl, limit);
			}
		}

		for ( ; n; n = n->next) {
			stmt *s;
	
			if (lmt < 0)
				s = stmt_diff(stmt_dup(n->data), stmt_dup(limit));
			else
				s = stmt_semijoin(stmt_dup(n->data), stmt_dup(limit));
			list_append(newl, s);
		}
		if (order) {
			if (lmt < 0) {
		 		order = stmt_diff(order, limit);
			} else {
				stmt_destroy(order);
		 		order = limit;
			}
		}
	}
	stmt_destroy(sub);
	sub = stmt_list(newl);
	if (order) 
		return stmt_ordered(order, sub);
	return sub;
}

static stmt *
refs_find_rel(list *refs, sql_rel *rel)
{
	node *n;

	for(n=refs->h; n; n = n->next) {
		stmt *s = n->data;
		char *name = table_name(s->op1.lval->h->data);
		
		if (strcmp(name, rel->name) == 0) {
			_DELETE(name);
			return stmt_dup(s);
		}
		_DELETE(name);
	}
	return NULL;
}

static stmt *
subrel_bin(mvc *sql, sql_rel *rel, list *refs ) 
{
	stmt *s = NULL;

	if (!rel)
		return s;
	if (rel_is_ref(rel)) {
		s = refs_find_rel(refs, rel);
		if (s)
			return s;
	}
	switch (rel->op) {
	case op_basetable:
		s = rel2bin_basetable(sql, rel, refs);
		break;
	case op_table:
		s = rel2bin_table(sql, rel, refs);
		break;
	case op_join: 
	case op_left: 
	case op_right: 
	case op_full: 
		s = rel2bin_join(sql, rel, refs);
		break;
	case op_semi:
	case op_anti:
		s = rel2bin_semijoin(sql, rel, refs);
		break;
	case op_union: 
		s = rel2bin_union(sql, rel, refs);
		break;
	case op_except: 
		s = rel2bin_except(sql, rel, refs);
		break;
	case op_inter: 
		s = rel2bin_inter(sql, rel, refs);
		break;
	case op_project:
		s = rel2bin_project(sql, rel, refs);
		break;
	case op_select: 
		s = rel2bin_select(sql, rel, refs);
		break;
	case op_groupby: 
		s = rel2bin_groupby(sql, rel, refs);
		break;
	case op_topn: 
		s = rel2bin_topn(sql, rel, refs);
		break;
	default:
		printf("todo: print %u\n", rel->op);
	}
	if (s && rel_is_ref(rel)) 
		list_append(refs, stmt_dup(s));
	return s;
}

stmt *
rel_bin(mvc *sql, sql_rel *rel ) 
{
	list *refs = create_stmt_list();
	stmt *s = subrel_bin( sql, rel, refs);
	if (s && s->type != st_none) {
		s = stmt_output(s);
		sql->type = Q_TABLE;
	}
	list_destroy(refs);
	return s;
}
