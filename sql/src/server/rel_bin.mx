@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2008 CWI.
@' All Rights Reserved.

@f rel_bin
@a N.J. Nes
@* 

@h
#ifndef _REL_BIN_H_
#define _REL_BIN_H_

#include "rel_semantic.h"
#include "sql_statement.h"

extern stmt * rel_bin(mvc *sql, sql_rel *rel);

#endif /*_REL_BIN_H_*/
@c
#include "sql_config.h"
#define LINESIZE 80

#include "rel_bin.h"
#include "rel_prop.h"

static stmt * subrel_bin(mvc *sql, sql_rel *rel);

static void 
print_stmtlist( stmt *l )
{
	node *n;
	if (l)
	for (n = l->op1.lval->h; n; n = n->next) {
		char *rnme = table_name(n->data);
		char *nme = column_name(n->data);

		printf("%s.%s\n", rnme, nme);
	}
}

static stmt *
bin_find_column( stmt *sub, char *rname, char *name ) 
{
	stmt *res = NULL;
	node *n;

	if (rname) {
		for (n = sub->op1.lval->h; n; n = n->next) {
			char *rnme = table_name(n->data);
			char *nme = column_name(n->data);

			if (rnme && strcmp(rnme, rname) == 0 && 
				    strcmp(nme, name) == 0) {
				res = n->data;
				break;
			}
		}
	} else {
		for (n = sub->op1.lval->h; n; n = n->next) {
			char *nme = column_name(n->data);

			if (strcmp(nme, name) == 0) {
				res = n->data;
				break;
			}
		}
	}
	if (!res)
		return NULL;
	return stmt_dup(res);
}

static stmt *const_column(stmt *val ) 
{
	sql_subtype *ct = tail_type(val);
	stmt *temp = stmt_temp(ct);
	return stmt_append(temp, val);
}

static stmt *column( stmt *val )
{
	val = stmt_dup(val);
	if (val->nrcols == 0)
		return const_column(val);
	return val;
}

static stmt *
bin_first_column( stmt *sub ) 
{
	node *n = sub->op1.lval->h;
	stmt *c = stmt_dup(n->data);

	if (c->nrcols == 0)
		return const_column(c);
	return c;
}

static stmt *
exp_bin(mvc *sql, sql_exp *e, stmt *left, stmt *right, group *grp) 
{
	stmt *s = NULL;

	if (!e) {
		assert(0);
		return NULL;
	}

	switch(e->type) {
	case e_atom: {
		if (e->l) { 			/* literals */
			atom *a = e->l;
			s = stmt_atom(atom_dup(a));
		} else if (e->r) { 		/* parameters */
			s = stmt_var(e->r, e->f, 0, e->flag);
		} else { 			/* arguments */
			s = stmt_varnr(e->flag, e->f);
		}
	}	break;
	case e_convert: {
		stmt *l = exp_bin(sql, e->l, left, right, grp);
		list *tps = e->r;
		sql_subtype *from = tps->h->data;
		sql_subtype *to = tps->h->next->data;
		if (!l) 
			return NULL;
		s = stmt_convert(l, from, to);
	} 	break;
	case e_func: {
		node *en;
		list *l = create_stmt_list(), *exps = e->l;

		if (exps) {
			for (en = exps->h; en; en = en->next) {
				stmt *es;

				es = exp_bin(sql, en->data, left, right, grp);
				if (!es) {
					list_destroy(l);
					return NULL;
				}
				list_append(l,es);
			}
		}
		s = stmt_Nop(stmt_list(l), sql_dup_func(e->f)); 
	} 	break;
	case e_aggr: {
		list *attr = e->l; 
		stmt *as = NULL;
		stmt *as2 = NULL;
		sql_subaggr *a = e->f;
		group *g = grp;

		if (attr) { 
			as = exp_bin(sql, attr->h->data, left, right, NULL);
			if (list_length(attr) == 2)
				as2 = exp_bin(sql, attr->h->next->data, left, right, NULL);
		} else {
			/* count(*) may need the default group (relation) and
			   and/or an attribute to count */
			if (g)
				as = stmt_dup(grp->grp);
			else
				as = bin_first_column(left);
		}
		if (!as) 
			return NULL;	
		/* inconsistent sql requires NULL != NULL and NULL <> NULL, ie unknown
		 * but also NULL means no values, which means 'ignore'
		 *
		 * so here we need to ignore NULLs
		 */
		if (e->flag&NO_NIL) {
			sql_subtype *t = tail_type(as);
			stmt *n = stmt_atom(atom_general(t, NULL, 0));
			as = stmt_select2(as, n, stmt_dup(n), 0);
		}
		if (e->flag&DISTINCT){ /* distinct */
			if (g)
				as = stmt_unique(as, grp_dup(grp));
			else
				as = stmt_unique(as, NULL);
		}
		if (g) 
			g = grp_dup(g);
		if (as2) 
			s = stmt_aggr2(stmt_reverse(as), as2, sql_dup_aggr(a) );
		else
			s = stmt_aggr(as, g, sql_dup_aggr(a), 1 );
		/* HACK: correct cardinality for window functions */
		if (e->card > CARD_AGGR)
			s->nrcols = 2;
	} 	break;
	case e_column: {
		if (right) /* check relation names */
			s = bin_find_column(right, e->l, e->r);
		if (!s && left) {
			if (left->type == st_Nop && tail_type(left)->comp_type ) { /* table function */
				s = stmt_rs_column(stmt_dup(left), stmt_atom_string(_strdup(e->r)), e->f/*subtype*/);
			} else {
				s = bin_find_column(left, e->l, e->r);
			}
		}
		if (s && grp)
			s = stmt_join(stmt_dup(grp->ext), s, cmp_equal);
		if (!s && right) {
			printf("could not find %s.%s\n", (char*)e->l, (char*)e->r);
			print_stmtlist(left);
			print_stmtlist(right);
		}
	 }	break;
	case e_cmp: {
		stmt *l = NULL, *r = NULL;
		int swapped = 0;
		sql_exp *re = e->r;
		prop *p;

		/* here we handle join indices */
		if ((p=find_prop(e->p, PROP_JOINIDX)) != NULL) {
			/* it maybe much easier to rewrite the join expression
			   in the optimizer, to allready use the 'columns'
			   fk_idx, pk_idx
			 */
			sql_idx *i = p->value, *ri;
			sql_fkey *fk = (sql_fkey*)i->key;

			ri = fk->rkey->k.idx;

			/* find out left and right */
			l = bin_find_column(left, NULL, i->base.name);
			if (!l) {
				swapped = 1;
				l = bin_find_column(right, NULL, i->base.name);
				r = bin_find_column(left, NULL, ri->base.name);
			} else {
				r = bin_find_column(right, NULL, ri->base.name);
			}
			if (swapped)
				s = stmt_join(r, stmt_reverse(l), cmp_equal);
			else
				s = stmt_join(l, stmt_reverse(r), cmp_equal);
			sql->opt_stats[0]++; 
			break;
		}
		if (!l) {
			l = exp_bin(sql, e->l, left, NULL, grp);
			swapped = 0;
		}
		if (!l && right) {
 			l = exp_bin(sql, e->l, right, NULL, grp);
			swapped = 1;
		}
		/* the escape charachter of like is in the right expression */
		if (e->flag == cmp_notlike || e->flag == cmp_like) {
			stmt *escape = NULL;

 			r = exp_bin(sql, e->r, left, right, grp);
			if (e->f) {
 				escape = exp_bin(sql, e->f, left, right, grp);
			} else {
				escape = stmt_atom_string(_strdup(""));
			}
			if (!l || !r || !escape) {
				assert(0);
				if (l) stmt_destroy(l);
				if (r) stmt_destroy(r);
				if (escape) stmt_destroy(escape);
				return NULL;
			}
			return stmt_likeselect(l, r, escape, (comp_type)e->flag);
		}
		if (swapped || !right)
 			r = exp_bin(sql, e->r, left, NULL, grp);
		else
 			r = exp_bin(sql, e->r, right, NULL, grp);
		if (!l || !r) {
			assert(0);
			if (l) stmt_destroy(l);
			if (r) stmt_destroy(r);
			return NULL;
		}
		if (left && right && re->card > CARD_ATOM) {
			if (swapped)
				s = stmt_join(r, stmt_reverse(l), swap_compare((comp_type)e->flag));
			else
				s = stmt_join(l, stmt_reverse(r), (comp_type)e->flag);
		} else {
			s = stmt_select(l, r, (comp_type)e->flag);
		}
	 }	break;
	default:
		;
	}
	return s;
}


static stmt *
stmt_rename( sql_rel *rel, sql_exp *exp, stmt *s )
{
	char *name = exp->name;
	char *rname = rel->name;

	if (!name)
		name = column_name(s);
	if (!rname)
		rname = table_name(s);
	name = _strdup(name);
	rname = (rname)?_strdup(rname):NULL;
	s = stmt_alias(s, rname, name);
	return s;
}

static stmt *
rel2bin_basetable( mvc *sql, sql_rel *rel )
{
	list *l; 
	stmt *ts, *sub = NULL;
	sql_table *t = rel->l;
	node *n;
			
	(void)sql;
	l = create_stmt_list();
	ts = stmt_basetable(t, (rel->name)?rel->name:t->base.name);
	for (n = t->columns.set->h; n; n = n->next) {
		sql_column *c = n->data;

		stmt *sc = stmt_bat(c, stmt_dup(ts), RDONLY);
		list_append(l, sc);
	}
	if (t->idxs.set) {
		for (n = t->idxs.set->h; n; n = n->next) {
			sql_idx *i = n->data;
			stmt *sc = NULL;

			if (i->type == join_idx) {
				sc = stmt_idxbat(i, RDONLY);
			} else {
				sql_column *c = t->columns.set->h->data;
				sc = stmt_bat(c, stmt_dup(ts), RDONLY);
				sc = stmt_mirror(sc);
			}
			sc = stmt_alias(sc, NULL, _strdup(i->base.name));
			list_append(l, sc);
		}
	}
	stmt_destroy(ts);
	sub = stmt_list(l);
	/* add aliases */
	if (rel->exps) {
		node *en;
		for( en = rel->exps->h; en; en = en->next ) {
			sql_exp *exp = en->data;
			stmt *s = bin_find_column(sub, exp->l, exp->r);
	
			if (!s) {
				assert(0);
				stmt_destroy(sub);
				return NULL;
			}
			s = stmt_alias(s, NULL, _strdup(exp->name));
			list_append(l, s);
		}
	}
	return sub;
}

static stmt *
rel2bin_table( mvc *sql, sql_rel *rel )
{
	list *l; 
	stmt *sub = NULL;
	node *en;
			
	sub = exp_bin(sql, rel->l, NULL, NULL, NULL); /* table function */
	if (!sub) { 
		assert(0);
		return NULL;	
	}
	l = create_stmt_list();
	for( en = rel->exps->h; en; en = en->next ) {
		sql_exp *exp = en->data;
		stmt *s = exp_bin(sql, exp, sub, NULL, NULL);
		char *rnme = rel->name;

		if (!s) {
			assert(0);
			list_destroy(l);
			if (sub) 
				stmt_destroy(sub);
			return NULL;
		}
		if (sub && sub->nrcols >= 1 && s->nrcols == 0)
			s = stmt_const(bin_first_column(sub), s);
		else if (!sub)
			s = column(s);
		rnme = (rnme)?_strdup(rnme):NULL;
		s = stmt_alias(s, rnme, _strdup(exp->name));
		list_append(l, s);
	}
	if (sub) 
		stmt_destroy(sub);
	sub = stmt_list(l);
	return sub;
}

char *compare_func( comp_type t )
{
	switch(t) {
	case cmp_equal:
		return "=";
	case cmp_lt:
		return "<";
	case cmp_lte:
		return "<=";
	case cmp_gte:
		return ">=";
	case cmp_gt:
		return ">";
	case cmp_notequal:
		return "<>";
	default:
		return NULL;
	}
	return NULL;
}

static stmt *
rel2bin_join( mvc *sql, sql_rel *rel )
{
	list *l; 
	node *en, *n;
	stmt *left = NULL, *right = NULL, *join = NULL, *jl, *jr;
	stmt *ld = NULL, *rd = NULL;

	if (rel->l) /* first construct the left sub relation */
		left = subrel_bin(sql, rel->l);
	if (rel->r) /* first construct the right sub relation */
		right = subrel_bin(sql, rel->r);
	if (!left || !right) { 
		assert(0);
		if (left) stmt_destroy(left);
		if (right) stmt_destroy(right);
		return NULL;	
	}
	if (rel->exps) {
		for( en = rel->exps->h; en; en = en->next ) {
			stmt *s = exp_bin(sql, en->data, left, right, NULL);

			if (!s) {
				assert(0);
				stmt_destroy(left);
				stmt_destroy(right);
				if (join)
					stmt_destroy(join);
				return NULL;
			}
			if (!join) {
				join = s;
			} else {
				/* break column join */
				stmt *l = stmt_mark(stmt_reverse(join), 100);
				stmt *r = stmt_mark(stmt_dup(join), 100);
				stmt *ld = stmt_dup(s->op1.stval);
				stmt *rd = stmt_reverse(stmt_dup(s->op2.stval));
				stmt *le = stmt_join(l, ld, cmp_equal);
				stmt *re = stmt_join(r, rd, cmp_equal);

				sql_subfunc *f = sql_bind_func(sql->session->schema, compare_func((comp_type)s->flag), tail_type(le), tail_type(le));
				stmt * cmp;

				assert(f);


				cmp = stmt_binop(le, re, f);

				cmp = stmt_uselect(cmp, stmt_bool(1), cmp_equal);

				l = stmt_semijoin(stmt_dup(l), stmt_dup(cmp));
				r = stmt_semijoin(stmt_dup(r), cmp);
				join = stmt_join(stmt_reverse(l), r, cmp_equal);
				stmt_destroy(s);
			}
		}
	} else {
		stmt *l = bin_first_column(left);
		stmt *r = bin_first_column(right);
		join = stmt_join(l, stmt_reverse(r), cmp_all); 
		
	}

	/* construct relation */
	l = create_stmt_list();

	jl = stmt_reverse(stmt_mark_tail(stmt_dup(join),0));
	if (rel->op == op_left || rel->op == op_full) {
		/* we need to add the missing oid's */
		ld = stmt_diff(bin_first_column(left), stmt_reverse(stmt_dup(jl)));
		ld = stmt_mark(stmt_reverse(ld), 0);
	}
	jr = stmt_reverse(stmt_mark_tail(stmt_reverse(join),0));
	if (rel->op == op_right || rel->op == op_full) {
		/* we need to add the missing oid's */
		rd = stmt_diff(bin_first_column(right), stmt_reverse(stmt_dup(jr)));
		rd = stmt_mark(stmt_reverse(rd), 0);
	}

	for( n = left->op1.lval->h; n; n = n->next ) {
		stmt *c = n->data;
		char *rnme = table_name(c);
		char *nme = column_name(c);
		stmt *s = stmt_join(stmt_dup(jl), column(c), cmp_equal);

		if (rel->op == op_left || rel->op == op_full)
			s = stmt_append(s, stmt_join(stmt_dup(ld), stmt_dup(c), cmp_equal));
		if (rel->op == op_right || rel->op == op_full) 
			s = stmt_append(s, stmt_const(stmt_dup(rd), stmt_atom(atom_general(tail_type(c), NULL, 0))));

		rnme = (rnme)?_strdup(rnme):NULL;
		s = stmt_alias(s, rnme, _strdup(nme));
		list_append(l, s);
	}
	stmt_destroy(jl);
	stmt_destroy(left);
	for( n = right->op1.lval->h; n; n = n->next ) {
		stmt *c = n->data;
		char *rnme = table_name(c);
		char *nme = column_name(c);
		stmt *s = stmt_join(stmt_dup(jr), column(c), cmp_equal);

		if (rel->op == op_left || rel->op == op_full) 
			s = stmt_append(s, stmt_const(stmt_dup(ld), stmt_atom(atom_general(tail_type(c), NULL, 0))));
		if (rel->op == op_right || rel->op == op_full) 
			s = stmt_append(s, stmt_join(stmt_dup(rd), stmt_dup(c), cmp_equal));

		rnme = (rnme)?_strdup(rnme):NULL;
		s = stmt_alias(s, rnme, _strdup(nme));
		list_append(l, s);
	}
	stmt_destroy(jr);
	stmt_destroy(right);
	if (ld)
		stmt_destroy(ld);
	if (rd)
		stmt_destroy(rd);
	return stmt_list(l);
}

static stmt *
rel2bin_distinct(stmt *s)
{
	node *n;
	group *grp = NULL;
	list *rl = create_stmt_list();

	for (n = s->op1.lval->h; n; n = n->next) {
		stmt *t = n->data;

		grp = grp_create(column(t), grp, NULL);
	}

	for (n = s->op1.lval->h; n; n = n->next) {
		stmt *t = n->data;

		list_append(rl, stmt_join(stmt_dup(grp->ext), stmt_dup(t), cmp_equal));
	}

	if (grp)
		grp_destroy(grp);
	stmt_destroy(s);
	s = stmt_list(rl);
	return s;
}

static stmt *
rel2bin_union( mvc *sql, sql_rel *rel )
{
	list *l; 
	node *n, *m;
	stmt *left = NULL, *right = NULL, *sub;

	if (rel->l) /* first construct the left sub relation */
		left = subrel_bin(sql, rel->l);
	if (rel->r) /* first construct the right sub relation */
		right = subrel_bin(sql, rel->r);
	if (!left || !right) { 
		assert(0);
		if (left) stmt_destroy(left);
		if (right) stmt_destroy(right);
		return NULL;	
	}

	/* construct relation */
	l = create_stmt_list();
	for( n = left->op1.lval->h, m = right->op1.lval->h; n && m; 
		n = n->next, m = m->next ) {
		stmt *c1 = n->data;
		stmt *c2 = stmt_dup(m->data);
		char *rnme = rel->name;
		char *nme = column_name(c1);
		stmt *s;

		/* append isn't save, ie use union 
			(also not save loses unique head oids) 

		   so we create append on copies.
		*/
		s = stmt_append(column(c1), c2);
		if (!rnme)
			rnme = table_name(c1);
		nme = _strdup(nme);
		rnme = (rnme)?_strdup(rnme):NULL;
		s = stmt_alias(s, rnme, nme);
		list_append(l, s);
	}
	stmt_destroy(left);
	stmt_destroy(right);
	sub = stmt_list(l);
	if (rel->flag&DISTINCT) /* distinct */
		sub = rel2bin_distinct(sub);
	return sub;
}

static stmt *
rel2bin_except( mvc *sql, sql_rel *rel )
{
	list *stmts; 
	node *n, *m;
	stmt *left = NULL, *right = NULL, *sub;

	group *lgrp = NULL, *rgrp = NULL;
	stmt *s, *lm, *ls = NULL, *rs = NULL, *ld = NULL;
	sql_subaggr *a;

	if (rel->l) /* first construct the left sub relation */
		left = subrel_bin(sql, rel->l);
	if (rel->r) /* first construct the right sub relation */
		right = subrel_bin(sql, rel->r);
	if (!left || !right) { 
		assert(0);
		if (left) stmt_destroy(left);
		if (right) stmt_destroy(right);
		return NULL;	
	}

	/* construct relation */
	stmts = create_stmt_list();
	/*
	 * The multi column intersect is handled using group by's and
	 * group size counts on both sides of the intersect. We then
	 * return for each group of A with min(A.count,B.count), 
	 * number of rows.
	 * 
	 * The problem with this approach is that the groups should
	 * have equal group identifiers. So we take the union of all
	 * columns before the group by.
	 */
	for (n = left->op1.lval->h; n; n = n->next) 
		lgrp = grp_create(column(n->data), lgrp, NULL);
	for (n = right->op1.lval->h; n; n = n->next) 
		rgrp = grp_create(column(n->data), rgrp, NULL);

 	a = sql_bind_aggr(sql->session->schema, "count", NULL);
	ls = stmt_aggr(stmt_dup(lgrp->grp), grp_dup(lgrp), a, 1); 
	a = sql_dup_aggr(a);
	rs = stmt_aggr(stmt_dup(rgrp->grp), grp_dup(rgrp), a, 1); 

	/* now find the matching groups */
	s = stmt_reljoin_init();
	for (n = left->op1.lval->h, m = right->op1.lval->h; n && m; n = n->next, m = m->next) {
		stmt *l = stmt_dup(n->data);
		stmt *r = stmt_dup(m->data);

		l = stmt_join(stmt_dup(lgrp->ext), l, cmp_equal);
		r = stmt_join(stmt_dup(rgrp->ext), r, cmp_equal);
		stmt_reljoin_fill(s, l, r);
	}

	/* the join of the groups removed those in A but not in B,
	 * we need these later so keep these in 'ld' */
	ld = stmt_diff(stmt_dup(ls), stmt_dup(s));
		
	/*if (!distinct) */
	{
		sql_subfunc *sub;

		lm = stmt_reverse(stmt_mark_tail(stmt_dup(s),0));
		ls = stmt_join(stmt_dup(lm),ls,cmp_equal);
		rs = stmt_join(stmt_mark(s,0),rs,cmp_equal);

 		sub = sql_bind_func(sql->session->schema, "sql_sub", tail_type(ls), tail_type(rs));
		/*s = sql_binop_(sql, NULL, "sql_sub", ls, rs);*/
		s = stmt_binop(ls, rs, sub);
		s = stmt_select(s, stmt_atom_int(0), cmp_gt);

		/* A ids */
		s = stmt_join(stmt_reverse(lm), s, cmp_equal);
		/* now we need to add the groups which weren't in B */
		s = stmt_union(ld,s);
		/* now we have gid,cnt, blowup to full groupsizes */
		s = stmt_gen_group(s);
	/*
	} else {
		stmt_destroy(s);
		s = ld;
	*/
	}
	s = stmt_mark_tail(s, 500); 
	/* from gid back to A id's */
	s = stmt_reverse(stmt_join(stmt_dup(lgrp->ext), s, cmp_equal));

	grp_destroy(lgrp);
	grp_destroy(rgrp);

	/* project columns of left hand expression */
	for (n = left->op1.lval->h; n; n = n->next) {
		stmt *c1 = stmt_dup(n->data);
		char *rnme = rel->name;
		char *nme = column_name(c1);

		/* retain name via the stmt_alias */
		c1 = stmt_join(stmt_dup(s), c1, cmp_equal);

		if (!rnme)
			rnme = table_name(c1);
		
		nme = _strdup(nme);
		rnme = (rnme)?_strdup(rnme):NULL;
		c1 = stmt_alias(c1, rnme, nme);
		list_append(stmts, c1);
	}
	stmt_destroy(s);

	stmt_destroy(left);
	stmt_destroy(right);
	sub = stmt_list(stmts);
	if (rel->flag&DISTINCT) /* distinct */
		sub = rel2bin_distinct(sub);
	return sub;
}

static stmt *
rel2bin_inter( mvc *sql, sql_rel *rel )
{
	list *stmts; 
	node *n, *m;
	stmt *left = NULL, *right = NULL, *sub;

	group *lgrp = NULL, *rgrp = NULL;
	stmt *s, *lm, *ls = NULL, *rs = NULL;
	sql_subaggr *a;

	if (rel->l) /* first construct the left sub relation */
		left = subrel_bin(sql, rel->l);
	if (rel->r) /* first construct the right sub relation */
		right = subrel_bin(sql, rel->r);
	if (!left || !right) { 
		assert(0);
		if (left) stmt_destroy(left);
		if (right) stmt_destroy(right);
		return NULL;	
	}

	/* construct relation */
	stmts = create_stmt_list();
	/*
	 * The multi column intersect is handled using group by's and
	 * group size counts on both sides of the intersect. We then
	 * return for each group of A with min(A.count,B.count), 
	 * number of rows.
	 * 
	 * The problem with this approach is that the groups should
	 * have equal group identifiers. So we take the union of all
	 * columns before the group by.
	 */
	for (n = left->op1.lval->h; n; n = n->next) 
		lgrp = grp_create(column(n->data), lgrp, NULL);
	for (n = right->op1.lval->h; n; n = n->next) 
		rgrp = grp_create(column(n->data), rgrp, NULL);

 	a = sql_bind_aggr(sql->session->schema, "count", NULL);
	ls = stmt_aggr(stmt_dup(lgrp->grp), grp_dup(lgrp), a, 1); 
	a = sql_dup_aggr(a);
	rs = stmt_aggr(stmt_dup(rgrp->grp), grp_dup(rgrp), a, 1); 

	/* now find the matching groups */
	s = stmt_reljoin_init();
	for (n = left->op1.lval->h, m = right->op1.lval->h; n && m; n = n->next, m = m->next) {
		stmt *l = stmt_dup(n->data);
		stmt *r = stmt_dup(m->data);

		l = stmt_join(stmt_dup(lgrp->ext), l, cmp_equal);
		r = stmt_join(stmt_dup(rgrp->ext), r, cmp_equal);
		stmt_reljoin_fill(s, l, r);
	}
		
	/*if (!distinct) */
	{
		sql_subfunc *min;

		lm = stmt_reverse(stmt_mark_tail(stmt_dup(s),0));
		ls = stmt_join(stmt_dup(lm),ls,cmp_equal);
		rs = stmt_join(stmt_mark(s,0),rs,cmp_equal);

 		min = sql_bind_func(sql->session->schema, "sql_min", tail_type(ls), tail_type(rs));
		/*s = sql_binop_(sql, NULL, "sql_min", ls, rs);*/
		s = stmt_binop(ls, rs, min);
		/* A ids */
		s = stmt_join(stmt_reverse(lm), s, cmp_equal);
		/* now we have gid,cnt, blowup to full groupsizes */
		s = stmt_gen_group(s);
	}
	s = stmt_mark_tail(s, 500); 
	/* from gid back to A id's */
	s = stmt_reverse(stmt_join(stmt_dup(lgrp->ext), s, cmp_equal));

	grp_destroy(lgrp);
	grp_destroy(rgrp);

	/* project columns of left hand expression */
	for (n = left->op1.lval->h; n; n = n->next) {
		stmt *c1 = stmt_dup(n->data);
		char *rnme = rel->name;
		char *nme = column_name(c1);

		/* retain name via the stmt_alias */
		c1 = stmt_join(stmt_dup(s), c1, cmp_equal);

		if (!rnme)
			rnme = table_name(c1);
		
		nme = _strdup(nme);
		rnme = (rnme)?_strdup(rnme):NULL;
		c1 = stmt_alias(c1, rnme, nme);
		list_append(stmts, c1);
	}
	stmt_destroy(s);

	stmt_destroy(left);
	stmt_destroy(right);
	sub = stmt_list(stmts);
	if (rel->flag&DISTINCT) /* distinct */
		sub = rel2bin_distinct(sub);
	return sub;
}

static stmt *
rel2bin_project( mvc *sql, sql_rel *rel )
{
	list *l; 
	node *en;
	stmt *sub = NULL, *psub = NULL;

	if (!rel->exps) 
		return stmt_none();

	if (rel->l) { /* first construct the sub relation */
		sub = subrel_bin(sql, rel->l);
		if (!sub) { 
			assert(0);
			return NULL;	
		}
	}
	l = create_stmt_list();
	for( en = rel->exps->h; en; en = en->next ) {
		sql_exp *exp = en->data;
		stmt *s = exp_bin(sql, exp, sub, NULL, NULL);

		if (!s) {
			assert(0);
			list_destroy(l);
			if (sub) 
				stmt_destroy(sub);
			return NULL;
		}
		if (sub && sub->nrcols >= 1 && s->nrcols == 0)
			s = stmt_const(bin_first_column(sub), s);
		else if (!sub)
			s = column(s);
			
		s = stmt_rename(rel, exp, s);
		list_append(l, s);
	}
	psub = stmt_list(l);
	if (rel->flag&DISTINCT) /* distinct */
		psub = rel2bin_distinct(psub);
	if (rel->r) {
		list *oexps = rel->r;
		stmt *orderby = NULL;

		for (en = oexps->h; en; en = en->next) {
			sql_exp *orderbycole = en->data; 
			stmt *orderbycols = exp_bin(sql, orderbycole, sub, psub, NULL); 

			if (!orderbycols) {
				assert(0);
				stmt_destroy(sub);
				cond_stmt_destroy(orderby);
				return NULL;
			}
			if (orderby)
				orderby = stmt_reorder(orderby, orderbycols, orderbycole->flag&ASCENDING);
			else
				orderby = stmt_order(orderbycols, orderbycole->flag&ASCENDING);
		}
		psub = stmt_ordered(orderby, psub);
	}
	if (sub) 
		stmt_destroy(sub);
	return psub;
}

static stmt *
rel2bin_predicate(void) 
{
	sql_subtype *bt = sql_bind_localtype("bit");
	stmt *temp = stmt_temp(bt);
	return stmt_append(temp, stmt_bool(1));
}

static stmt *
rel2bin_select( mvc *sql, sql_rel *rel )
{
	list *l; 
	node *en, *n;
	stmt *sub = NULL, *sel = NULL;
	stmt *predicate = NULL;

	if (!rel->exps) {
		assert(0);
		return NULL;
	}

	if (rel->l) { /* first construct the sub relation */
		sub = subrel_bin(sql, rel->l);
		if (!sub) { 
			assert(0);
			return NULL;	
		}
	} else {
		predicate = rel2bin_predicate();
	}
	for( en = rel->exps->h; en; en = en->next ) {
		stmt *s = exp_bin(sql, en->data, sub, NULL, NULL);

		if (!s) {
			assert(0);
			if (sub) stmt_destroy(sub);
			if (predicate) stmt_destroy(predicate);
			if (sel) stmt_destroy(sel);
			return NULL;
		}
		if (s->nrcols == 0){ 
			if (!predicate) 
				predicate = rel2bin_predicate();
			predicate = stmt_select(predicate, s, cmp_equal);
		} else if (sel) {
			sel = stmt_semijoin(sel, s);
		} else {
			sel = s;
		}
	}

	if (predicate && sel) 
		sel = stmt_join(sel, stmt_dup(predicate), cmp_all);
	/* construct relation */
	l = create_stmt_list();
	if (sub && sel) {
		sel = stmt_mark(stmt_reverse(sel),0);
		for( n = sub->op1.lval->h; n; n = n->next ) {
			list_append(l, stmt_join(stmt_dup(sel), stmt_dup(n->data), cmp_equal));
		}
	} else if (sub && predicate) {
		stmt *h = NULL;
		n = sub->op1.lval->h;
		h = stmt_join( stmt_dup(n->data), stmt_dup(predicate), cmp_all);
		h = stmt_reverse(stmt_mark_tail(h, 0)); 
		for( n = sub->op1.lval->h; n; n = n->next ) {
			list_append(l, stmt_join(stmt_dup(h), stmt_dup(n->data), cmp_equal));
		}
		stmt_destroy(h);
	} else if (predicate) {
		list_append(l, stmt_dup(predicate));
	}
	if (predicate) stmt_destroy(predicate);
	if (sub) stmt_destroy(sub);
	if (sel) stmt_destroy(sel);
	return stmt_list(l);
}

static stmt *
rel2bin_groupby( mvc *sql, sql_rel *rel )
{
	list *l, *aggrs;
	node *n, *en;
	stmt *sub = NULL, *cursub;
	group *groupby = NULL;


	if (rel->l) /* first construct the sub relation */
		sub = subrel_bin(sql, rel->l);
	if (!sub) { 
		assert(0);
		return NULL;	
	}

	/* groupby columns */
	if (rel->r) {
		list *exps = rel->r; 
		for( en = exps->h; en; en = en->next ) {
			sql_exp *e = en->data; 
			stmt *groupbycol = exp_bin(sql, e, sub, NULL, NULL); 

			if (!groupbycol) {
				assert(0);
				stmt_destroy(sub);
				if (groupby) 
					grp_destroy(groupby);
				return NULL;
			}
			groupby = grp_create(groupbycol, groupby, NULL);
		}
	}
	/* now aggregate */
	l = create_stmt_list();
	aggrs = rel->exps;
	cursub = stmt_list(l);
	for( n = aggrs->h; n; n = n->next ) {
		sql_exp *aggrexp = n->data;

		stmt *aggrstmt = exp_bin(sql, aggrexp, sub, NULL, groupby); 

		/* maybe the aggr uses intermediate results of this group by,
		   therefor we pass the group by columns too 
		 */
		if (!aggrstmt) 
			aggrstmt = exp_bin(sql, aggrexp, sub, cursub, groupby); 
		if (!aggrstmt) {
			assert(0);
			stmt_destroy(cursub);
			stmt_destroy(sub);
			if (groupby) grp_destroy(groupby);
			return NULL;
		}

		aggrstmt = stmt_rename(rel, aggrexp, aggrstmt);
		list_append(l, aggrstmt);
	}
	stmt_destroy(sub);
	if (groupby) grp_destroy(groupby);
	return cursub;
}

static stmt *
rel2bin_topn( mvc *sql, sql_rel *rel )
{
	list *newl;
	int l = -1, o = 0;
	stmt *sub = NULL, *order = NULL;
	node *n;

	if (rel->l) /* first construct the sub relation */
		sub = subrel_bin(sql, rel->l);
	if (!sub) { 
		assert(0);
		return NULL;	
	}

	if (rel->exps) {
		sql_exp *limit = rel->exps->h->data;
		atom *a = limit->l;

		l = a->data.val.ival;
		if (list_length(rel->exps) > 1) {
			sql_exp *offset = rel->exps->h->next->data;

			a = offset->l;
			o = a->data.val.ival;
			if (o <= 0)
				o = 0;
		}
	}

	if (sub->type == st_ordered) {
		stmt *s = stmt_dup(sub->op2.stval);
		order = stmt_dup(sub->op1.stval);
		stmt_destroy(sub);
		sub = s;
	}
	n = sub->op1.lval->h;
	newl = create_stmt_list();

	if (n) {
		stmt *limit = NULL;
		int lmt = l;

		if (l < 0) {
			l = o;
			o = 0;
		}

		if (order) {
		 	limit = stmt_limit(stmt_dup(order), o, l, 0);
		} else {
			limit = stmt_limit(stmt_dup(n->data), o, l, 0);
			if (lmt >= 0) {
				n = n->next;
				list_append(newl, limit);
			}
		}

		for ( ; n; n = n->next) {
			stmt *s;
	
			if (lmt < 0)
				s = stmt_diff(stmt_dup(n->data), stmt_dup(limit));
			else
				s = stmt_semijoin(stmt_dup(n->data), stmt_dup(limit));
			list_append(newl, s);
		}
		if (order) {
			if (lmt < 0) {
		 		order = stmt_diff(order, limit);
			} else {
				stmt_destroy(order);
		 		order = limit;
			}
		}
	}
	stmt_destroy(sub);
	sub = stmt_list(newl);
	if (order) 
		return stmt_ordered(order, sub);
	return sub;
}


static stmt *
subrel_bin(mvc *sql, sql_rel *rel ) 
{
	stmt *s = NULL;

	if (!rel)
		return s;
	switch (rel->op) {
	case op_basetable:
		s = rel2bin_basetable(sql, rel);
		break;
	case op_table:
		s = rel2bin_table(sql, rel);
		break;
	case op_join: 
	case op_left: 
	case op_right: 
	case op_full: 
		s = rel2bin_join(sql, rel);
		break;
	case op_union: 
		s = rel2bin_union(sql, rel);
		break;
	case op_except: 
		s = rel2bin_except(sql, rel);
		break;
	case op_inter: 
		s = rel2bin_inter(sql, rel);
		break;
	case op_project:
		s = rel2bin_project(sql, rel);
		break;
	case op_select: 
		s = rel2bin_select(sql, rel);
		break;
	case op_groupby: 
		s = rel2bin_groupby(sql, rel);
		break;
	case op_topn: 
		s = rel2bin_topn(sql, rel);
		break;
	default:
		printf("todo: print %u\n", rel->op);
	}
	return s;
}

stmt *
rel_bin(mvc *sql, sql_rel *rel ) 
{
	stmt *s = subrel_bin( sql, rel);
	if (s && s->type != st_none) {
		s = stmt_output(s);
		sql->type = Q_TABLE;
	}
	return s;
}
