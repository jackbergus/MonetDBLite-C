@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
@' Copyright August 2008-2009 MonetDB B.V.
@' All Rights Reserved.

@f rel_subquery
@a N.J. Nes
@* 

@h
#ifndef _REL_SUBQUERY_H_
#define _REL_SUBQUERY_H_

#include "rel_semantic.h"
#include "sql_semantic.h"

extern stmt *select_into(mvc *sql, symbol *sq, exp_kind ek );
extern stmt *flat_subquery(mvc *sql, symbol *sq);

extern stmt *value_exp(mvc *sql, symbol *se, int f, exp_kind knd);
extern stmt *logical_value_exp(mvc *sql, symbol *sc, int f, exp_kind knd);

extern stmt *sql_unop_(mvc *sql, sql_schema *s, char *fname, stmt *rs);
extern stmt *sql_binop_(mvc *sql, sql_schema *s, char *fname, stmt *ls, stmt *rs);
extern stmt *sql_Nop_(mvc *sql, char *fname, stmt *a1, stmt *a2, stmt *a3, stmt *a4);

extern stmt *rel_parse_value(mvc *m, char *query, char emode);
extern sql_exp * rel_parse_val(mvc *m, char *query, char emode);

#endif /*_REL_SUBQUERY_H_*/

@c

#include "sql_config.h"
#include "rel_subquery.h"
#include "rel_select.h"
#include "rel_exp.h"
#include "rel_optimizer.h"
#include "rel_bin.h"
#include "sql_env.h"

stmt *
sql_unop_(mvc *sql, sql_schema *s, char *fname, stmt *rs)
{
	sql_subtype *rt = NULL;
	sql_subfunc *f = NULL;

	if (!s)
		s = sql->session->schema;
	rt = tail_type(rs);
	f = sql_bind_func(s, fname, rt, NULL);
	/* try to find the function without a type, and convert
	 * the value to the type needed by this function!
	 */
	if (!f && (f = sql_find_func(s, fname, 1)) != NULL) {
		sql_arg *a = f->func->ops->h->data;

		rs = check_types(sql, &a->type, rs, type_equal);
		if (!rs) {
			sql_subfunc_destroy(f);
			f = NULL;
		}
	}
	if (f) {
		if (f->func->res.scale == INOUT) {
			f->res.digits = rt->digits;
			f->res.scale = rt->scale;
		}
		return stmt_unop(rs, f);
	} else if (rs) {
		char *type = tail_type(rs)->type->sqlname;

		stmt_destroy(rs);
		return sql_error(sql, 02, "SELECT: no such unary operator '%s(%s)'", fname, type);
	}
	return NULL;
}

stmt *
sql_binop_(mvc *sql, sql_schema *s, char *fname, stmt *ls, stmt *rs)
{
	stmt *res = NULL;
	sql_subtype *t1, *t2;
	sql_subfunc *f = NULL;

	t1 = tail_type(ls);
	t2 = tail_type(rs);

	if (!s)
		s = sql->session->schema;
	f = sql_bind_func(s, fname, t1, t2);
	if (!f && is_commutative(fname)) {
		f = sql_bind_func(s, fname, t2, t1);
		if (f) {
			sql_subtype *tmp = t1;
			t1 = t2;	
			t2 = tmp;
			res = ls;		
			ls = rs;
			rs = res;
		}
	}
	if (f) {
		if (f->func->fix_scale == SCALE_FIX) {
			ls = fix_scale(sql, t2, ls, 0, 0);
			rs = fix_scale(sql, t1, rs, 0, 0);
		} else if (f->func->fix_scale == SCALE_DIV) {
			ls = scale_algebra(sql, f, ls, rs);
		} else if (f->func->fix_scale == SCALE_MUL) {
			ls = sum_scales(sql, f, ls, rs);
		} else if (f->func->fix_scale == DIGITS_ADD) {
			f->res.digits = t1->digits + t2->digits;
		}
		return stmt_binop(ls, rs, f);
	} else {
		int digits = t1->digits + t2->digits;
		stmt *ols = stmt_dup(ls);
		stmt *ors = stmt_dup(rs);

		/* try finding function based on first argument */
		if (!EC_NUMBER(t1->type->eclass) &&
		   (f = sql_bind_member(s, fname, t1, 2)) != NULL) {
			node *m = f->func->ops->h;
			sql_arg *a = m->data;

			ls = check_types(sql, &a->type, ls, type_equal);
			a = m->next->data;
			rs = check_types(sql, &a->type, rs, type_equal);
			if (ls && rs) {
				stmt_destroy(ols);
				stmt_destroy(ors);
				return stmt_binop(ls, rs, f);
			}
		}
		/* reset error */
		sql->session->status = 0;
		sql->errstr[0] = '\0';

		if (ls)
			stmt_destroy(ls);
		if (rs)
			stmt_destroy(rs);
		ls = ols;
		rs = ors;
		ols = stmt_dup(ls);
		ors = stmt_dup(rs);
		/* try finding function based on both arguments */
		if (convert_types(sql, &ls, &rs, 1, type_equal) >= 0) {
			/* try operators */
			t1 = tail_type(ls);
			t2 = tail_type(rs);
			f = sql_bind_func(s, fname, t1, t2);
			if (f) {
				if (f->func->fix_scale == SCALE_FIX) {
					ls = fix_scale(sql, t2, ls, 0, 0);
					rs = fix_scale(sql, t1, rs, 0, 0);
				} else if (f->func->fix_scale == SCALE_DIV) {
					ls = scale_algebra(sql, f, ls, rs);
				} else if (f->func->fix_scale == SCALE_MUL) {
					ls = sum_scales(sql, f, ls, rs);
				} else if (f->func->fix_scale == DIGITS_ADD) {
					f->res.digits = digits;
				}
				stmt_destroy(ols);
				stmt_destroy(ors);
				return stmt_binop(ls, rs, f);
			}
		}
		/* reset error */
		sql->session->status = 0;
		sql->errstr[0] = '\0';

		if (ls)
			stmt_destroy(ls);
		if (rs)
			stmt_destroy(rs);
		ls = ols;
		rs = ors;
		/* everything failed, fall back to bind on function name only */
		if ((f = sql_find_func(s, fname, 2)) != NULL) {
			node *m = f->func->ops->h;
			sql_arg *a = m->data;

			ls = check_types(sql, &a->type, ls, type_equal);
			a = m->next->data;
			rs = check_types(sql, &a->type, rs, type_equal);
			if (ls && rs) 
				return stmt_binop(ls, rs, f);
		}
	}
	if (rs && ls)
		res = sql_error(sql, 02, "SELECT: no such binary operator '%s(%s,%s)'", fname, tail_type(ls)->type->sqlname, tail_type(rs)->type->sqlname);
	cond_stmt_destroy(ls);
	cond_stmt_destroy(rs);
	return res;
}

stmt *
sql_Nop_(mvc *sql, char *fname, stmt *a1, stmt *a2, stmt *a3, stmt *a4)
{
	list *sl = create_stmt_list();
	list *tl = list_create(NULL);
	sql_subfunc *f = NULL;

	list_append(sl, a1);
	list_append(tl, tail_type(a1));
	list_append(sl, a2);
	list_append(tl, tail_type(a2));
	list_append(sl, a3);
	list_append(tl, tail_type(a3));
	if (a4) {
		list_append(sl, a4);
		list_append(tl, tail_type(a4));
	}

	f = sql_bind_func_(sql->session->schema, fname, tl);
	list_destroy(tl);
	if (f)
		return stmt_Nop(stmt_list(sl), f);
	return sql_error(sql, 02, "SELECT: no such operator '%s'", fname);
}

static stmt *
_subquery(mvc *sql, symbol *sq, exp_kind ek)
{
	stmt *s = NULL;

	int status = sql->session->status;
	sql_rel *r = rel_subquery(sql, NULL, sq, ek);

	if (!r) {
		if (!sql->errstr[0]) 
			sql->session->status = status;
		return NULL;
	} else {
		r = rel_optimizer(sql, r);
		s = rel_bin(sql, r);
	}
	return s;
}

/* single value only */
stmt *
select_into( mvc *sql, symbol *sq, exp_kind ek) 
{
	SelectNode *sn = (SelectNode*)sq;
	dlist *into = sn->into;
	/* SELECT ... INTO var_list */
	stmt *s;

	sn->into = NULL;
	s = _subquery(sql, sq, ek);
	if (into && s) {
		list *rl = s->op1.lval;
		node *m;
		dnode *n;
		list *nl = create_stmt_list();

		assert(s->type == st_list);
		for (m = rl->h, n = into->h; m && n; m = m->next, n = n->next) {
			sql_subtype *tpe = NULL;
			char *nme = n->data.sval;
			stmt *a = NULL, *v = m->data, *var;
			int level;

			if ((var=stack_find_var(sql, nme)) == NULL) {
				list_destroy(rl);
				list_destroy(nl);
				return sql_error(sql, 02, "SELECT INTO: variable '%s' unknown", nme);
			}
			/* dynamic check for single values */
			v = stmt_dup(v);
			if (!v->key) {
				sql_subaggr *zero_or_one = sql_bind_aggr(sql->session->schema, "zero_or_one", tail_type(v));
				assert(zero_or_one);
				v = stmt_aggr(v, NULL, zero_or_one, 1);
			}
			tpe = tail_type(var);
			level = stack_find_frame(sql, nme);
			v = check_types(sql, tpe, v, type_equal); 
			if (!v) {
				list_destroy(rl);
				list_destroy(nl);
				return NULL;
			}
			a = stmt_assign(nme, v, level);
			list_append(nl, a);
		}
		stmt_destroy(s);
		s = stmt_list(nl);
	}
	return s;
}

static stmt *
find_order(stmt *s)
{
	if (s->type == st_limit) 
		assert(s->op1.stval->type == st_order || s->op1.stval->type == st_reorder);
	else
		assert(s->type == st_order || s->type == st_reorder);
		
	while(s->type == st_reorder)
		s = s->op1.stval;
	return s;
}

static stmt *
sql_reorder(stmt *order, stmt *s) 
{
	list *l = create_stmt_list();
	node *n;
	/* we need to keep the order by column, to propagate the sort property*/
	stmt *o = find_order(order);
	stmt *x = o->op1.stval;

	order = stmt_mark(stmt_reverse(order), 0);
	for (n = s->op1.lval->h; n; n = n->next) {
		stmt *sc = n->data;
		char *cname = column_name(sc);
		char *tname = table_name(sc);

		if (sc != x)
			sc = stmt_reverse(stmt_order(stmt_reverse(stmt_join(stmt_dup(order), stmt_dup(sc), cmp_equal)), 1));
		else	/* first order by column */
			sc = stmt_mark(stmt_dup(o), 0);
		sc = stmt_alias(sc, tname, cname );
		list_append(l, sc);
		
	}
	stmt_destroy(s);
	stmt_destroy(order);
	return stmt_list(l);
}

stmt *
flat_subquery(mvc *sql, symbol *sq)
{
	stmt *s = NULL;
	exp_kind ek = {type_value, card_relation, TRUE};

	s = _subquery(sql, sq, ek);
	if (s && s->type == st_ordered) {
		stmt *n = sql_reorder(stmt_dup(s->op1.stval), stmt_dup(s->op2.stval));
		stmt_destroy(s);
		s = n;
	}
	return s;
}

stmt *
value_exp(mvc *sql, symbol *sq, int f, exp_kind ek)
{
	int is_last = 0;
	stmt *s = NULL;
	int status = sql->session->status;
	sql_rel *r = NULL;
	sql_exp *e = rel_value_exp2(sql, &r, sq, f, ek, &is_last);

	if (!r && !e) {
		if (!sql->errstr[0]) 
			sql->session->status = status;
		return NULL;
	} else {
		if (r) {
			r = rel_optimizer(sql, r);
			s = rel_bin(sql, r);
		} else {
			s = exp_bin(sql, e, NULL, NULL, NULL, NULL);
		}

		if (s && s->type == st_list && !s->op1.lval->h) {
			assert(0);
			stmt_destroy(s);
			s = NULL;
		}

		if (r)
			rel_destroy(r);
		if (!r && e)
			exp_destroy(e);
	}
	/* we need a relation */
	if (ek.card == card_relation && s && s->type == st_ordered) {
		stmt *order = stmt_dup(s->op1.stval);
		stmt *ns = stmt_dup(s->op2.stval);
			
		stmt_destroy(s);
		s = sql_reorder(order, ns);
	}
	if (ek.card == card_relation && s) {
		if (s->type == st_list && s->nrcols == 0 && s->key) {
			/* row to columns */
			node *n;
			list *l = create_stmt_list();

			for(n=s->op1.lval->h; n; n = n->next)
				list_append(l, const_column(stmt_dup(n->data)));
			stmt_destroy(s);
			s = stmt_list(l);
		}
		s = stmt_table(s, 1);
	}
	/* single column */
	if (ek.card != card_relation && s && s->type == st_list) {
		stmt *ns = stmt_dup(s->op1.lval->h->data); 

		stmt_destroy(s);
		s = ns;
	}
	/* single value */
	if (ek.card == card_value && s && !s->key) {
		sql_subaggr *zero_or_one = sql_bind_aggr(sql->session->schema, "zero_or_one", tail_type(s));
		assert(zero_or_one);
		s = stmt_aggr(s, NULL, zero_or_one, 1);
	}
	return s;
}

/* Used for default values,
	select default
	       next value 
	       now 
 */

sql_exp *
rel_parse_val(mvc *m, char *query, char emode)
{
	mvc o = *m;
	sql_exp *e = NULL;
	buffer *b;
	char *n;
	int len = _strlen(query);
	exp_kind ek = {type_value, card_value, FALSE};

	m->qc = NULL;

	m->cache = 0;
	m->emode = emode;

	b = (buffer*)GDKmalloc(sizeof(buffer));
	n = GDKmalloc(len + 1 + 1);
	strncpy(n, query, len);
	query = n;
	query[len] = '\n';
	query[len+1] = 0;
	len++;
	buffer_init(b, query, len);
	scanner_init( &m->scanner, 
		bstream_create(buffer_rastream(b, "sqlstatement"), b->len),
		NULL);
	m->scanner.mode = LINE_1; 
	bstream_next(m->scanner.rs);

	m->params = NULL;
	/*m->args = NULL;*/
	m->argc = 0;
	m->sym = NULL;
	m->errstr[0] = '\0';
	/* via views we give access to protected objects */
	m->user_id = USER_MONETDB;

	(void) sqlparse(m);	/* blindly ignore errors */
	
	/* get out the single value as we don't want an enclosing projection! */
	if (m->sym->token == SQL_SELECT) {
		SelectNode *sn = (SelectNode *)m->sym;
		if (sn->selection->h->data.sym->token == SQL_COLUMN) {
			int is_last = 0;
			sql_rel *r = NULL;
			symbol* sq = sn->selection->h->data.sym->data.lval->h->data.sym;
			e = rel_value_exp2(m, &r, sq, sql_sel, ek, &is_last);
		}
	}
	GDKfree(query);
	GDKfree(b);
	bstream_destroy(m->scanner.rs);

	m->sym = NULL;
	if (m->session->status || m->errstr[0]) {
		int status = m->session->status;
		char errstr[ERRSIZE];

		strcpy(errstr, m->errstr);
		*m = o;
		m->session->status = status;
		strcpy(m->errstr, errstr);
	} else {
		*m = o;
	}
	return e;
}

stmt *
rel_parse_value(mvc *m, char *query, char emode)
{
	mvc o = *m;
	stmt *s = NULL;
	buffer *b;
	char *n;
	int len = _strlen(query);
	exp_kind ek = {type_value, card_value, FALSE};

	m->qc = NULL;

	m->cache = 0;
	m->emode = emode;

	b = (buffer*)GDKmalloc(sizeof(buffer));
	n = GDKmalloc(len + 1 + 1);
	strncpy(n, query, len);
	query = n;
	query[len] = '\n';
	query[len+1] = 0;
	len++;
	buffer_init(b, query, len);
	scanner_init( &m->scanner, 
		bstream_create(buffer_rastream(b, "sqlstatement"), b->len),
		NULL);
	m->scanner.mode = LINE_1; 
	bstream_next(m->scanner.rs);

	m->params = NULL;
	/*m->args = NULL;*/
	m->argc = 0;
	m->sym = NULL;
	m->errstr[0] = '\0';
	/* via views we give access to protected objects */
	m->user_id = USER_MONETDB;

	(void) sqlparse(m);	/* blindly ignore errors */
	
	/* get out the single value as we don't want an enclosing projection! */
	if (m->sym->token == SQL_SELECT) {
		SelectNode *sn = (SelectNode *)m->sym;
		if (sn->selection->h->data.sym->token == SQL_COLUMN) {
			s = value_exp(m, sn->selection->h->data.sym->data.lval->h->data.sym, sql_sel, ek);
		}
	}
	GDKfree(query);
	GDKfree(b);
	bstream_destroy(m->scanner.rs);

	m->sym = NULL;
	if (m->session->status || m->errstr[0]) {
		int status = m->session->status;
		char errstr[ERRSIZE];

		strcpy(errstr, m->errstr);
		*m = o;
		m->session->status = status;
		strcpy(m->errstr, errstr);
	} else {
		*m = o;
	}
	return s;
}

stmt *
logical_value_exp(mvc *sql, symbol *sc, int f, exp_kind ek)
{
	stmt *s = NULL;
	int status = sql->session->status;
	sql_rel *r = NULL;
	sql_exp *e = rel_logical_value_exp(sql, &r, sc, f);

	if (!r && !e) {
		if (!sql->errstr[0]) 
			sql->session->status = status;
		return NULL;
	} else {
		if (r) {
			r = rel_optimizer(sql, r);
			s = rel_bin(sql, r);
		} else {
			s = exp_bin(sql, e, NULL, NULL, NULL, NULL);
		}

		if (s && s->type == st_list && !s->op1.lval->h) {
			assert(0);
			stmt_destroy(s);
			s = NULL;
		}

		if (r)
			rel_destroy(r);
		if (!r && e)
			exp_destroy(e);
	}
	/* we need a relation */
	if (ek.card == card_relation && s && s->type == st_ordered) {
		stmt *order = stmt_dup(s->op1.stval);
		stmt *ns = stmt_dup(s->op2.stval);
			
		stmt_destroy(s);
		s = sql_reorder(order, ns);
	}
	if (ek.card == card_relation && s)
		s = stmt_table(s, 1);
	/* single column */
	if (ek.card != card_relation && s && s->type == st_list) {
		stmt *ns = stmt_dup(s->op1.lval->h->data); 

		stmt_destroy(s);
		s = ns;
	}
	/* single value */
	if (ek.card == card_value && s && !s->key) {
		sql_subaggr *zero_or_one = sql_bind_aggr(sql->session->schema, "zero_or_one", tail_type(s));
		assert(zero_or_one);
		s = stmt_aggr(s, NULL, zero_or_one, 1);
	}
	return s;
}
