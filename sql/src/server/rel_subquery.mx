@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
@' Copyright August 2008- MonetDB B.V.
@' All Rights Reserved.

@f rel_subquery
@a N.J. Nes
@* 

@h
#ifndef _REL_SUBQUERY_H_
#define _REL_SUBQUERY_H_

#include "rel_semantic.h"
#include "sql_semantic.h"

extern void stack_push_table(mvc *sql, char *tname, sql_table *t);
extern void stack_add_inserted(mvc *sql, stmt **inserts, char *tname, sql_table *t);
extern void stack_add_deleted(mvc *sql, stmt *deletes, char *tname, sql_table *t);
extern void stack_add_updated(mvc *sql, stmt **updates, char *on, char *nn, sql_table *t);

extern stmt *select_into(mvc *sql, symbol *sq, exp_kind ek );
extern stmt *flat_subquery(mvc *sql, symbol *sq);

extern stmt *value_exp(mvc *sql, symbol *se, int f, exp_kind knd);
extern stmt *logical_value_exp(mvc *sql, symbol *sc, int f, exp_kind knd);

extern stmt * update_logical_exp(mvc *sql, symbol *sc, sql_table *t);
extern stmt ** update_exp(mvc *sql, symbol *sc, dlist *assignmentlist, sql_table *t, stmt **rows_affected);

extern stmt *sql_unop_(mvc *sql, sql_schema *s, char *fname, stmt *rs);
extern stmt *sql_binop_(mvc *sql, sql_schema *s, char *fname, stmt *ls, stmt *rs);
extern stmt *sql_Nop_(mvc *sql, char *fname, stmt *a1, stmt *a2, stmt *a3, stmt *a4);

extern stmt *rel_parse_value(mvc *m, char *query, char emode);

#endif /*_REL_SUBQUERY_H_*/

@c

#include "sql_config.h"
#include "rel_subquery.h"
#include "rel_select.h"
#include "rel_exp.h"
#include "rel_optimizer.h"
#include "rel_bin.h"
#include "sql_env.h"
#include "sql_updates.h"

stmt *
sql_unop_(mvc *sql, sql_schema *s, char *fname, stmt *rs)
{
	sql_subtype *rt = NULL;
	sql_subfunc *f = NULL;

	if (!s)
		s = sql->session->schema;
	rt = tail_type(rs);
	f = sql_bind_func(s, fname, rt, NULL);
	/* try to find the function without a type, and convert
	 * the value to the type needed by this function!
	 */
	if (!f && (f = sql_find_func(s, fname, 1)) != NULL) {
		sql_arg *a = f->func->ops->h->data;

		rs = check_types(sql, &a->type, rs, type_equal);
		if (!rs) {
			sql_subfunc_destroy(f);
			f = NULL;
		}
	}
	if (f) {
		if (f->func->res.scale == INOUT) {
			f->res.digits = rt->digits;
			f->res.scale = rt->scale;
		}
		return stmt_unop(rs, f);
	} else if (rs) {
		char *type = tail_type(rs)->type->sqlname;

		stmt_destroy(rs);
		return sql_error(sql, 02, "SELECT: no such unary operator '%s(%s)'", fname, type);
	}
	return NULL;
}

stmt *
sql_binop_(mvc *sql, sql_schema *s, char *fname, stmt *ls, stmt *rs)
{
	stmt *res = NULL;
	sql_subtype *t1, *t2;
	sql_subfunc *f = NULL;

	t1 = tail_type(ls);
	t2 = tail_type(rs);

	if (!s)
		s = sql->session->schema;
	f = sql_bind_func(s, fname, t1, t2);
	if (!f && is_commutative(fname)) {
		f = sql_bind_func(s, fname, t2, t1);
		if (f) {
			sql_subtype *tmp = t1;
			t1 = t2;	
			t2 = tmp;
			res = ls;		
			ls = rs;
			rs = res;
		}
	}
	if (f) {
		if (f->func->fix_scale == SCALE_FIX) {
			ls = fix_scale(sql, t2, ls, 0, 0);
			rs = fix_scale(sql, t1, rs, 0, 0);
		} else if (f->func->fix_scale == SCALE_SUB) {
			ls = scale_algebra(sql, f, ls, rs);
		} else if (f->func->fix_scale == SCALE_ADD) {
			ls = sum_scales(sql, f, ls, rs);
		} else if (f->func->fix_scale == DIGITS_ADD) {
			f->res.digits = t1->digits + t2->digits;
		}
		return stmt_binop(ls, rs, f);
	} else {
		int digits = t1->digits + t2->digits;
		stmt *ols = stmt_dup(ls);
		stmt *ors = stmt_dup(rs);

		/* try finding function based on first argument */
		if (!EC_NUMBER(t1->type->eclass) &&
		   (f = sql_bind_member(s, fname, t1, 2)) != NULL) {
			node *m = f->func->ops->h;
			sql_arg *a = m->data;

			ls = check_types(sql, &a->type, ls, type_equal);
			a = m->next->data;
			rs = check_types(sql, &a->type, rs, type_equal);
			if (ls && rs) {
				stmt_destroy(ols);
				stmt_destroy(ors);
				return stmt_binop(ls, rs, f);
			}
		}
		/* reset error */
		sql->session->status = 0;
		sql->errstr[0] = '\0';

		if (ls)
			stmt_destroy(ls);
		if (rs)
			stmt_destroy(rs);
		ls = ols;
		rs = ors;
		ols = stmt_dup(ls);
		ors = stmt_dup(rs);
		/* try finding function based on both arguments */
		if (convert_types(sql, &ls, &rs, 1, type_equal) >= 0) {
			/* try operators */
			t1 = tail_type(ls);
			t2 = tail_type(rs);
			f = sql_bind_func(s, fname, t1, t2);
			if (f) {
				if (f->func->fix_scale == SCALE_FIX) {
					ls = fix_scale(sql, t2, ls, 0, 0);
					rs = fix_scale(sql, t1, rs, 0, 0);
				} else if (f->func->fix_scale == SCALE_SUB) {
					ls = scale_algebra(sql, f, ls, rs);
				} else if (f->func->fix_scale == SCALE_ADD) {
					ls = sum_scales(sql, f, ls, rs);
				} else if (f->func->fix_scale == DIGITS_ADD) {
					f->res.digits = digits;
				}
				stmt_destroy(ols);
				stmt_destroy(ors);
				return stmt_binop(ls, rs, f);
			}
		}
		/* reset error */
		sql->session->status = 0;
		sql->errstr[0] = '\0';

		if (ls)
			stmt_destroy(ls);
		if (rs)
			stmt_destroy(rs);
		ls = ols;
		rs = ors;
		/* everything failed, fall back to bind on function name only */
		if ((f = sql_find_func(s, fname, 2)) != NULL) {
			node *m = f->func->ops->h;
			sql_arg *a = m->data;

			ls = check_types(sql, &a->type, ls, type_equal);
			a = m->next->data;
			rs = check_types(sql, &a->type, rs, type_equal);
			if (ls && rs) 
				return stmt_binop(ls, rs, f);
		}
	}
	if (rs && ls)
		res = sql_error(sql, 02, "SELECT: no such binary operator '%s(%s,%s)'", fname, tail_type(ls)->type->sqlname, tail_type(rs)->type->sqlname);
	cond_stmt_destroy(ls);
	cond_stmt_destroy(rs);
	return res;
}

stmt *
sql_Nop_(mvc *sql, char *fname, stmt *a1, stmt *a2, stmt *a3, stmt *a4)
{
	list *sl = create_stmt_list();
	list *tl = list_create(NULL);
	sql_subfunc *f = NULL;

	list_append(sl, a1);
	list_append(tl, tail_type(a1));
	list_append(sl, a2);
	list_append(tl, tail_type(a2));
	list_append(sl, a3);
	list_append(tl, tail_type(a3));
	if (a4) {
		list_append(sl, a4);
		list_append(tl, tail_type(a4));
	}

	f = sql_bind_func_(sql->session->schema, fname, tl);
	list_destroy(tl);
	if (f)
		return stmt_Nop(stmt_list(sl), f);
	return sql_error(sql, 02, "SELECT: no such operator '%s'", fname);
}


void
stack_push_table(mvc *sql, char *tname, sql_table *t)
{
	sql_rel *r = rel_basetable(t, tname );
		
	stack_push_rel_view(sql, tname, r);
}

void
stack_add_inserted( mvc *sql, stmt **inserts, char *name, sql_table *t) 
{
	sql_rel *r = rel_basetable(t, name );
		
	stack_push_rel_view(sql, name, r);
	(void)inserts;
/*
		list *l = create_stmt_list();
		stmt *s;
		node *n;

		for (n = t->columns.set->h; n; n = n->next) {
			sql_column *c = n->data;
			char *cn = _strdup(c->base.name);
			stmt *inserted = stmt_dup(inserts[c->colnr]->op2.stval);

			inserted = stmt_alias(inserted, _strdup(name), cn);
			list_append(l, inserted);
		}
		s = stmt_list(l);
		s = stmt_table(s, 1);
		stack_push_view(sql, name, s);
*/
}

void
stack_add_deleted(mvc *sql, stmt *deletes, char *name, sql_table *t)
{
	sql_rel *r = rel_basetable(t, name );
		
	stack_push_rel_view(sql, name, r);
	(void)deletes;
/*
	node *n;
	tvar *tv = scope_add_table(scp, NULL, name, NULL); 
	stmt *ts = stmt_basetable(t, t->base.name);

	for (n = t->columns.set->h; n; n = n->next) {
		sql_column *c = n->data;
		char *cn = _strdup(c->base.name);
		stmt *deleted = stmt_bat(c, stmt_dup(ts), RDONLY);

		deleted = stmt_semijoin(deleted, stmt_dup(deletes));
		deleted = stmt_alias(deleted, _strdup(name), cn);
		table_add_column(tv, deleted, NULL, c->base.name);
	}
*/
}

void
stack_add_updated(mvc *sql, stmt **updates, char *on, char *nn, sql_table *t)
{
	sql_rel *or = rel_basetable(t, on );
	sql_rel *nr = rel_basetable(t, nn );
		
	stack_push_rel_view(sql, on, or);
	stack_push_rel_view(sql, nn, nr);
	(void)updates;
/*
	node *n;
	tvar *tv = scope_add_table(scp, NULL, on, NULL); 

	for (n = t->columns.set->h; n; n = n->next) {
		sql_column *c = n->data;
		if (updates[c->colnr]) {
			char *cn = _strdup(c->base.name);
			stmt *h = stmt_dup(updates[c->colnr]->op2.stval);
			//stmt *updated = stmt_dup(updates[c->colnr]->op1.stval);
			stmt *updated = stmt_bat(c, stmt_dup(tv->s), RDONLY);

			updated = stmt_semijoin(updated, h);
			updated = stmt_alias(updated, _strdup(on), cn);
			table_add_column(tv, updated, NULL, c->base.name);
		}
	}
	tv = scope_add_table(scp, NULL, nn, NULL); 

	for (n = t->columns.set->h; n; n = n->next) {
		sql_column *c = n->data;
		if (updates[c->colnr]) {
			char *cn = _strdup(c->base.name);
			stmt *updated = stmt_dup(updates[c->colnr]->op2.stval);

			updated = stmt_alias(updated, _strdup(nn), cn);
			table_add_column(tv, updated, NULL, c->base.name);
		}
	}
*/
}




static stmt *
_subquery(mvc *sql, symbol *sq, exp_kind ek)
{
	stmt *s = NULL;

	int status = sql->session->status;
	sql_rel *r = rel_subquery(sql, NULL, sq, ek);

	if (!r) {
		if (!sql->errstr[0]) 
			sql->session->status = status;
		return NULL;
	} else {
		r = rel_optimizer(sql, r);
		s = rel_bin(sql, r);
	}
	return s;
}

/* single value only */
stmt *
select_into( mvc *sql, symbol *sq, exp_kind ek) 
{
	SelectNode *sn = (SelectNode*)sq;
	dlist *into = sn->into;
	/* SELECT ... INTO var_list */
	stmt *s;

	sn->into = NULL;
	s = _subquery(sql, sq, ek);
	if (into && s) {
		list *rl = s->op1.lval;
		node *m;
		dnode *n;
		list *nl = create_stmt_list();

		assert(s->type == st_list);
		for (m = rl->h, n = into->h; m && n; m = m->next, n = n->next) {
			sql_subtype *tpe = NULL;
			char *nme = n->data.sval;
			stmt *a = NULL, *v = m->data, *var;
			int level;

			if ((var=stack_find_var(sql, nme)) == NULL) {
				list_destroy(rl);
				list_destroy(nl);
				return sql_error(sql, 02, "SELECT INTO: variable '%s' unknown", nme);
			}
			/* dynamic check for single values */
			v = stmt_dup(v);
			if (!v->key) {
				sql_subaggr *zero_or_one = sql_bind_aggr(sql->session->schema, "zero_or_one", tail_type(v));
				assert(zero_or_one);
				v = stmt_aggr(v, NULL, zero_or_one, 1);
			}
			tpe = tail_type(var);
			level = stack_find_frame(sql, nme);
			v = check_types(sql, tpe, v, type_equal); 
			if (!v) {
				list_destroy(rl);
				list_destroy(nl);
				return NULL;
			}
			a = stmt_assign(nme, v, level);
			list_append(nl, a);
		}
		stmt_destroy(s);
		s = stmt_list(nl);
	}
	return s;
}

static stmt *
find_order(stmt *s)
{
	if (s->type == st_limit) 
		assert(s->op1.stval->type == st_order || s->op1.stval->type == st_reorder);
	else
		assert(s->type == st_order || s->type == st_reorder);
		
	while(s->type == st_reorder)
		s = s->op1.stval;
	return s;
}

static stmt *
sql_reorder(stmt *order, stmt *s) 
{
	list *l = create_stmt_list();
	node *n;
	/* we need to keep the order by column, to propagate the sort property*/
	stmt *o = find_order(order);
	stmt *x = o->op1.stval;

	order = stmt_mark(stmt_reverse(order), 0);
	for (n = s->op1.lval->h; n; n = n->next) {
		stmt *sc = n->data;
		char *cname = column_name(sc);
		char *tname = table_name(sc);

		if (sc != x)
			sc = stmt_reverse(stmt_order(stmt_reverse(stmt_join(stmt_dup(order), stmt_dup(sc), cmp_equal)), 1));
		else	/* first order by column */
			sc = stmt_mark(stmt_dup(o), 0);
		sc = stmt_alias(sc, tname, cname );
		list_append(l, sc);
		
	}
	stmt_destroy(s);
	stmt_destroy(order);
	return stmt_list(l);
}

stmt *
flat_subquery(mvc *sql, symbol *sq)
{
	stmt *s = NULL;
	exp_kind ek = {type_value, card_relation, TRUE};

	s = _subquery(sql, sq, ek);
	if (s && s->type == st_ordered) {
		stmt *n = sql_reorder(stmt_dup(s->op1.stval), stmt_dup(s->op2.stval));
		stmt_destroy(s);
		s = n;
	}
	return s;
}

stmt *
value_exp(mvc *sql, symbol *sq, int f, exp_kind ek)
{
	int is_last = 0;
	stmt *s = NULL;
	int status = sql->session->status;
	sql_rel *r = NULL;
	sql_exp *e = rel_value_exp2(sql, &r, sq, f, ek, &is_last);

	if (!r && !e) {
		if (!sql->errstr[0]) 
			sql->session->status = status;
		return NULL;
	} else {
		if (r) {
			r = rel_optimizer(sql, r);
			s = rel_bin(sql, r);
		} else {
			s = exp_bin(sql, e, NULL, NULL, NULL, NULL);
		}

		if (s && s->type == st_list && !s->op1.lval->h) {
			assert(0);
			stmt_destroy(s);
			s = NULL;
		}

		if (r)
			rel_destroy(r);
		if (!r && e)
			exp_destroy(e);
	}
	/* we need a relation */
	if (ek.card == card_relation && s && s->type == st_ordered) {
		stmt *order = stmt_dup(s->op1.stval);
		stmt *ns = stmt_dup(s->op2.stval);
			
		stmt_destroy(s);
		s = sql_reorder(order, ns);
	}
	if (ek.card == card_relation && s)
		s = stmt_table(s, 1);
	/* single column */
	if (ek.card != card_relation && s && s->type == st_list) {
		stmt *ns = stmt_dup(s->op1.lval->h->data); 

		stmt_destroy(s);
		s = ns;
	}
	/* single value */
	if (ek.card == card_value && s && !s->key) {
		sql_subaggr *zero_or_one = sql_bind_aggr(sql->session->schema, "zero_or_one", tail_type(s));
		assert(zero_or_one);
		s = stmt_aggr(s, NULL, zero_or_one, 1);
	}
	return s;
}

/* Used for default values,
	select default
	       next value 
	       now 
 */
stmt *
rel_parse_value(mvc *m, char *query, char emode)
{
	mvc o = *m;
	stmt *s = NULL;
	buffer *b;
	char *n;
	int len = _strlen(query);
	exp_kind ek = {type_value, card_value, FALSE};

	m->qc = NULL;

	m->cache = 0;
	m->emode = emode;

	b = (buffer*)GDKmalloc(sizeof(buffer));
	n = GDKmalloc(len + 1 + 1);
	strncpy(n, query, len);
	query = n;
	query[len] = '\n';
	query[len+1] = 0;
	len++;
	buffer_init(b, query, len);
	scanner_init( &m->scanner, 
		bstream_create(buffer_rastream(b, "sqlstatement"), b->len),
		NULL);
	m->scanner.mode = LINE_1; 
	bstream_next(m->scanner.rs);

	m->params = NULL;
	/*m->args = NULL;*/
	m->argc = 0;
	m->sym = NULL;
	m->errstr[0] = '\0';
	/* via views we give access to protected objects */
	m->user_id = USER_MONETDB;

	(void) sqlparse(m);	/* blindly ignore errors */
	
	/* get out the single value as we don't want an enclosing projection! */
	if (m->sym->token == SQL_SELECT) {
		SelectNode *sn = (SelectNode *)m->sym;
		if (sn->selection->h->data.sym->token == SQL_COLUMN) {
			s = value_exp(m, sn->selection->h->data.sym->data.lval->h->data.sym, sql_sel, ek);
		}
	}
	GDKfree(query);
	GDKfree(b);
	bstream_destroy(m->scanner.rs);

	m->sym = NULL;
	if (m->session->status || m->errstr[0]) {
		int status = m->session->status;
		char errstr[ERRSIZE];

		strcpy(errstr, m->errstr);
		*m = o;
		m->session->status = status;
		strcpy(m->errstr, errstr);
	} else {
		*m = o;
	}
	return s;
}

stmt *
logical_value_exp(mvc *sql, symbol *sc, int f, exp_kind ek)
{
	stmt *s = NULL;
	int status = sql->session->status;
	sql_rel *r = NULL;
	sql_exp *e = rel_logical_value_exp(sql, &r, sc, f);

	if (!r && !e) {
		if (!sql->errstr[0]) 
			sql->session->status = status;
		return NULL;
	} else {
		if (r) {
			r = rel_optimizer(sql, r);
			s = rel_bin(sql, r);
		} else {
			s = exp_bin(sql, e, NULL, NULL, NULL, NULL);
		}

		if (s && s->type == st_list && !s->op1.lval->h) {
			assert(0);
			stmt_destroy(s);
			s = NULL;
		}

		if (r)
			rel_destroy(r);
		if (!r && e)
			exp_destroy(e);
	}
	/* we need a relation */
	if (ek.card == card_relation && s && s->type == st_ordered) {
		stmt *order = stmt_dup(s->op1.stval);
		stmt *ns = stmt_dup(s->op2.stval);
			
		stmt_destroy(s);
		s = sql_reorder(order, ns);
	}
	if (ek.card == card_relation && s)
		s = stmt_table(s, 1);
	/* single column */
	if (ek.card != card_relation && s && s->type == st_list) {
		stmt *ns = stmt_dup(s->op1.lval->h->data); 

		stmt_destroy(s);
		s = ns;
	}
	/* single value */
	if (ek.card == card_value && s && !s->key) {
		sql_subaggr *zero_or_one = sql_bind_aggr(sql->session->schema, "zero_or_one", tail_type(s));
		assert(zero_or_one);
		s = stmt_aggr(s, NULL, zero_or_one, 1);
	}
	return s;
}

stmt *
update_logical_exp(mvc *sql, symbol *sc, sql_table *t)
{
	stmt *s = NULL;
	int status = sql->session->status;
	sql_rel *r = rel_logical_exp(sql, NULL, sc, sql_where), *l;

	if (r && t) { /* simple predicate which is not using the to 
		    be updated table. We add a select all */
		l = rel_basetable(t, t->base.name );
		r = rel_crossproduct(l, r, op_join);
	}
	if (!r && t) {
		sql->errstr[0] = 0;
		sql->session->status = status;
		r = rel_basetable(t, t->base.name );
		r = rel_logical_exp(sql, r, sc, sql_where);
	}
	if (!r) {
		return NULL;
	} else {
		sql_exp *e = exp_column(rel_name(r), "%TID%", sql_bind_localtype("oid"), CARD_MULTI, 0, 1);

		r = rel_project(r, append(new_exp_list(), e));
		r = rel_optimizer(sql, r);
		s = rel_bin(sql, r);
		rel_destroy(r);

		if (s && s->type == st_list && list_length(s->op1.lval) == 1) {
			stmt *r = stmt_dup(s->op1.lval->h->data);

			stmt_destroy(s);
			s = r;
		}
	}
	return s;
}

stmt **
update_exp(mvc *sql, symbol *sc, dlist *assignmentlist, sql_table *t, stmt **rows_affected)
{
	int len;
	stmt *s = NULL, **updates, *tid;
	dnode *n;
	node *m;
	sql_exp *e;
	sql_rel *r = NULL;

	if (sc) {
		int status = sql->session->status;
		sql_rel *l;

		r = rel_logical_exp(sql, NULL, sc, sql_where);

		if (r && t) { /* simple predicate which is not using the to 
			    be updated table. We add a select all */

			l = rel_basetable(t, t->base.name );
			r = rel_crossproduct(l, r, op_semi);
		}
		if (!r && t) {
			sql->errstr[0] = 0;
			sql->session->status = status;
			r = rel_basetable(t, t->base.name );
			r = rel_logical_exp(sql, r, sc, sql_where);
			if (r && is_join(r->op))
				r->op = op_semi;
		}
		if (!r) 
			return NULL;
	} else {	/* update all */
		r = rel_basetable(t, t->base.name );
	}

	/* We simply create a relation %TID%, updates */

	/* first create the project */
	e = exp_column(rel_name(r), "%TID%", sql_bind_localtype("oid"), CARD_MULTI, 0, 1);
	r = rel_project(r, append(new_exp_list(),e));
	for (n = assignmentlist->h; n; n = n->next) {
		symbol *a = NULL;
		sql_exp *v = NULL;
		dlist *assignment = n->data.sym->data.lval;
		char *cname = assignment->h->data.sval;
		sql_column *c = mvc_bind_column(sql, t, cname);

		if (!c) {
			rel_destroy(r);
			return sql_error(sql, 02, "UPDATE: no such column '%s.%s'", t->base.name, assignment->h->data.sval);
		}
		a = assignment->h->next->data.sym;
		if (a) {
			int status = sql->session->status;
			sql_rel *rel_val = NULL;
			exp_kind ek = {type_value, card_column, FALSE};

			v = rel_value_exp(sql, &rel_val, a, sql_sel, ek);
			if (v) {
				if (rel_val) {
					list *exps = rel_projections(sql, r, NULL, 0, 1);
					sql_rel *nr = rel_project(rel_crossproduct(rel_dup(r->l), rel_val, op_join), exps);
					rel_destroy(r);
					r = nr;
				}
			} else {
				sql->errstr[0] = 0;
				sql->session->status = status;
				v = rel_value_exp(sql, &r, a, sql_sel, ek);
			}		
		} else {
			v = exp_atom(atom_general(&c->type, NULL, 0));
		}

		if (!v || (v = rel_check_type(sql, &c->type, v, type_equal)) == NULL) {
			if (v)
				exp_destroy(v);
			rel_destroy(r);
			return NULL;
		}
		rel_project_add_exp(sql, r, v);
	}
	r = rel_optimizer(sql, r);
	s = rel_bin(sql, r);

	updates = table_update_array(t, &len);
	/* %TID% column */
	tid = stmt_dup(s->op1.lval->h->data); 
	for (n = assignmentlist->h, m = s->op1.lval->h->next; n && m; n = n->next, m = m->next) {
		dlist *assignment = n->data.sym->data.lval;
		char *cname = assignment->h->data.sval;
		sql_column *c = mvc_bind_column(sql, t, cname);

		assert(c);
		updates[c->colnr] = stmt_update_col(c, 
			stmt_join(stmt_reverse(stmt_dup(tid)), stmt_dup(m->data), cmp_equal));
	}
	/* use %TID% column to count the number of rows affected */
	*rows_affected = stmt_affected_rows(stmt_aggr(tid, NULL, sql_bind_aggr(sql->session->schema, "count", NULL), 1));
	stmt_destroy(s);
	return updates;
}
