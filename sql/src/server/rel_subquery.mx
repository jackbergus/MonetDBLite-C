@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
@' Copyright August 2008- MonetDB B.V.
@' All Rights Reserved.

@f rel_subquery
@a N.J. Nes
@* 

@h
#ifndef _REL_SUBQUERY_H_
#define _REL_SUBQUERY_H_

#include "rel_semantic.h"
#include "sql_semantic.h"

extern void stack_push_table(mvc *sql, char *tname, sql_table *t);
extern void stack_add_inserted(mvc *sql, stmt **inserts, char *tname, sql_table *t);

extern stmt *select_into(mvc *sql, symbol *sq, exp_kind ek );
extern stmt *flat_subquery(mvc *sql, symbol *sq);

extern stmt *value_exp(mvc *sql, scope *scp, symbol *se, group *grp, stmt *subset, int f, exp_kind knd);
extern stmt *logical_value_exp(mvc *sql, symbol *sc, group *grp, stmt *subset, int f, exp_kind knd);

extern stmt * update_logical_exp(mvc *sql, scope *scp, symbol *sc, tvar *tv, sql_table *t);
extern stmt ** update_exp(mvc *sql, scope *scp, symbol *sc, dlist *assignmentlist, sql_table *t, tvar *tv, stmt **rows_affected);

#endif /*_REL_SUBQUERY_H_*/

@c

#include "sql_config.h"
#include "rel_subquery.h"
#include "rel_select.h"
#include "rel_exp.h"
#include "rel_optimizer.h"
#include "rel_bin.h"
#include "sql_select.h"
#include "sql_env.h"
#include "sql_updates.h"

void
stack_push_table(mvc *sql, char *tname, sql_table *t)
{
	if (mvc_debug_on(sql,16384)) {
		sql_rel *r = rel_basetable(t, tname );
		
		stack_push_rel_view(sql, tname, r);
	} else {
		stmt *s, *ts = stmt_basetable(t, tname);
		list *l = create_stmt_list();
		node *n;

		for (n = t->columns.set->h; n; n = n->next) {
			sql_column *c = n->data;
			stmt *sc = stmt_bat(c, stmt_dup(ts), 0);
	
			list_append(l, sc);
		}
		stmt_destroy(ts);
		s = stmt_list(l);
		s = stmt_table(s, 1);
		stack_push_view(sql, tname, s);
	}
}

void
stack_add_inserted( mvc *sql, stmt **inserts, char *name, sql_table *t) 
{
	node *n;
	if (mvc_debug_on(sql,16384)) {
		sql_rel *r = rel_basetable(t, name );
		
		stack_push_rel_view(sql, name, r);
	} else {
		list *l = create_stmt_list();
		stmt *s;

		for (n = t->columns.set->h; n; n = n->next) {
			sql_column *c = n->data;
			char *cn = _strdup(c->base.name);
			stmt *inserted = stmt_dup(inserts[c->colnr]->op2.stval);

			inserted = stmt_alias(inserted, _strdup(name), cn);
			list_append(l, inserted);
		}
		s = stmt_list(l);
		s = stmt_table(s, 1);
		stack_push_view(sql, name, s);
	}
}


static stmt *
_subquery(mvc *sql, symbol *sq, exp_kind ek)
{
	stmt *s = NULL;

	int status = sql->session->status;
	sql_rel *r = rel_subquery(sql, NULL, sq, ek);

	if (!r) {
		if (!sql->errstr[0]) 
			sql->session->status = status;
		return NULL;
	} else {
		r = rel_optimizer(sql, r);
		s = rel_bin(sql, r);
	}
	return s;
}

static stmt *
rel_select_into( mvc *sql, symbol *sq, exp_kind ek) 
{
	SelectNode *sn = (SelectNode*)sq;
	dlist *into = sn->into;
	/* SELECT ... INTO var_list */
	stmt *s;

	sn->into = NULL;
	s = _subquery(sql, sq, ek);
	if (into && s) {
		list *rl = s->op1.lval;
		node *m;
		dnode *n;
		list *nl = create_stmt_list();

		assert(s->type == st_list);
		for (m = rl->h, n = into->h; m && n; m = m->next, n = n->next) {
			sql_subtype *tpe = NULL;
			char *nme = n->data.sval;
			stmt *a = NULL, *v = m->data, *var;
			int level;

			if ((var=stack_find_var(sql, nme)) == NULL) {
				list_destroy(rl);
				list_destroy(nl);
				return sql_error(sql, 02, "SELECT INTO: variable '%s' unknown", nme);
			}
			/* dynamic check for single values */
			v = stmt_dup(v);
			if (!v->key) {
				sql_subaggr *zero_or_one = sql_bind_aggr(sql->session->schema, "zero_or_one", tail_type(v));
				assert(zero_or_one);
				v = stmt_aggr(v, NULL, zero_or_one, 1);
			}
			tpe = tail_type(var);
			level = stack_find_frame(sql, nme);
			v = check_types(sql, tpe, v, type_equal); 
			if (!v) {
				list_destroy(rl);
				list_destroy(nl);
				return NULL;
			}
			a = stmt_assign(nme, v, level);
			list_append(nl, a);
		}
		stmt_destroy(s);
		s = stmt_list(nl);
	}
	return s;
}

/* single value only */
stmt *select_into(mvc *sql, symbol *sq, exp_kind ek )
{
	if (mvc_debug_on(sql,16384)) 
		return rel_select_into(sql, sq, ek);
	return sql_scope_subquery(sql, NULL, sq, ek);
}

stmt *flat_subquery(mvc *sql, symbol *sq)
{
	stmt *s = NULL;
	exp_kind ek = {type_value, card_relation, TRUE};

	if ((s = _subquery(sql, sq, ek)) == NULL)
		return sql_flat_subquery(sql, sq);
	if (s && s->type == st_ordered) {
		stmt *n = sql_reorder(stmt_dup(s->op1.stval), stmt_dup(s->op2.stval));
		stmt_destroy(s);
		s = n;
	}
	return s;
}

static stmt *
_value_exp(mvc *sql, symbol *sq, int f, exp_kind ek)
{
	int is_last = 0;
	stmt *s = NULL;
	int status = sql->session->status;
	sql_rel *r = NULL;
	sql_exp *e = rel_value_exp2(sql, &r, sq, f, ek, &is_last);

	if (!r && !e) {
		if (!sql->errstr[0]) 
			sql->session->status = status;
		return NULL;
	} else {
		if (r) {
			r = rel_optimizer(sql, r);
			s = rel_bin(sql, r);
		} else {
			s = exp_bin(sql, e, NULL, NULL, NULL, NULL);
		}

		if (s && s->type == st_list && !s->op1.lval->h) {
			assert(0);
			stmt_destroy(s);
			s = NULL;
		}

		if (r)
			rel_destroy(r);
		if (!r && e)
			exp_destroy(e);
	}
	/* we need a relation */
	if (ek.card == card_relation && s && s->type == st_ordered) {
		stmt *order = stmt_dup(s->op1.stval);
		stmt *ns = stmt_dup(s->op2.stval);
			
		stmt_destroy(s);
		s = sql_reorder(order, ns);
	}
	if (ek.card == card_relation && s)
		s = stmt_table(s, 1);
	/* single column */
	if (ek.card != card_relation && s && s->type == st_list) {
		stmt *ns = stmt_dup(s->op1.lval->h->data); 

		stmt_destroy(s);
		s = ns;
	}
	/* single value */
	if (ek.card == card_value && s && !s->key) {
		sql_subaggr *zero_or_one = sql_bind_aggr(sql->session->schema, "zero_or_one", tail_type(s));
		assert(zero_or_one);
		s = stmt_aggr(s, NULL, zero_or_one, 1);
	}
	return s;
}

stmt *value_exp(mvc *sql, scope *scp, symbol *se, group *grp, stmt *subset, int f, exp_kind knd)
{
	assert(sql && se);
	if (mvc_debug_on(sql,16384)) {
		assert((!scp || list_length(scp->tables) == 0) && !grp && !subset);
		return _value_exp( sql, se, f, knd);
	}
	return sql_value_exp(sql, scp, se, grp, subset, f, knd);
}

static stmt *
logical_value_exp_(mvc *sql, symbol *sc, int f, exp_kind ek)
{
	stmt *s = NULL;
	int status = sql->session->status;
	sql_rel *r = NULL;
	sql_exp *e = rel_logical_value_exp(sql, &r, sc, f);

	if (!r && !e) {
		if (!sql->errstr[0]) 
			sql->session->status = status;
		return NULL;
	} else {
		if (r) {
			r = rel_optimizer(sql, r);
			s = rel_bin(sql, r);
		} else {
			s = exp_bin(sql, e, NULL, NULL, NULL, NULL);
		}

		if (s && s->type == st_list && !s->op1.lval->h) {
			assert(0);
			stmt_destroy(s);
			s = NULL;
		}

		if (r)
			rel_destroy(r);
		if (!r && e)
			exp_destroy(e);
	}
	/* we need a relation */
	if (ek.card == card_relation && s && s->type == st_ordered) {
		stmt *order = stmt_dup(s->op1.stval);
		stmt *ns = stmt_dup(s->op2.stval);
			
		stmt_destroy(s);
		s = sql_reorder(order, ns);
	}
	if (ek.card == card_relation && s)
		s = stmt_table(s, 1);
	/* single column */
	if (ek.card != card_relation && s && s->type == st_list) {
		stmt *ns = stmt_dup(s->op1.lval->h->data); 

		stmt_destroy(s);
		s = ns;
	}
	/* single value */
	if (ek.card == card_value && s && !s->key) {
		sql_subaggr *zero_or_one = sql_bind_aggr(sql->session->schema, "zero_or_one", tail_type(s));
		assert(zero_or_one);
		s = stmt_aggr(s, NULL, zero_or_one, 1);
	}
	return s;
}

stmt *logical_value_exp(mvc *sql, symbol *sc, group *grp, stmt *subset, int f, exp_kind knd)
{
	assert(!grp && !subset);
	if (mvc_debug_on(sql,16384)) {
		return logical_value_exp_(sql, sc, f, knd);
	} else {
		return sql_logical_exp(sql, NULL, sc, grp, subset, f, knd);
	}
}

stmt *
sql_update_logical_exp(mvc *sql, scope *scp, symbol *sc, tvar *tv)
{
	exp_kind ek = {type_value, card_column, TRUE};
	stmt *s = sql_logical_exp(sql, scp, sc, NULL, NULL, sql_where, ek);

	if (s && s->type == st_filter) { /* filter on table ? */
		ptable_statements(scp->ptable) = stmt_set(s);
		s = stmt_dup(scope_first_column(scp)->s);
	}
	if (s && s->type != st_set && s->type != st_sets) {
		s = stmt_set(s);
	}
	if (s) {
		/* check if the table is used in the query */
		stmt *tmp = complex_find_subset(s, tv->s);

		if (!tmp) { /* not used do a select all */
			cvar *cv = tv->columns->h->data;

			tmp = stmt_dup(cv->s);
			s = sql_and(sql, scp, s, tmp, sql_where);
		}
		s = stmt2pivot(scp,s);
	}
	return s;
}

static stmt *
rel_update_logical_exp(mvc *sql, symbol *sc, sql_table *t)
{
	stmt *s = NULL;
	int status = sql->session->status;
	sql_rel *r = rel_logical_exp(sql, NULL, sc, sql_where), *l;

	if (r && t) { /* simple predicate which is not using the to 
		    be updated table. We add a select all */
		l = rel_basetable(t, t->base.name );
		r = rel_crossproduct(l, r, op_join);
	}
	if (!r && t) {
		sql->errstr[0] = 0;
		sql->session->status = status;
		r = rel_basetable(t, t->base.name );
		r = rel_logical_exp(sql, r, sc, sql_where);
	}
	if (!r) {
		return NULL;
	} else {
		sql_exp *e = exp_column(r->name, "%TID%", sql_bind_localtype("oid"), CARD_MULTI, 0, 1);

		r = rel_project(r, append(new_exp_list(), e));
		r = rel_optimizer(sql, r);
		s = rel_bin(sql, r);
		rel_destroy(r);

		if (s && s->type == st_list && list_length(s->op1.lval) == 1) {
			stmt *r = stmt_dup(s->op1.lval->h->data);

			stmt_destroy(s);
			s = r;
		}
	}
	return s;
}

stmt *
update_logical_exp(mvc *sql, scope *scp, symbol *sc, tvar *tv, sql_table *t)
{
	if (mvc_debug_on(sql,16384)) {
		return rel_update_logical_exp(sql, sc, t);
	} else {
		return sql_update_logical_exp(sql, scp, sc, tv);
	}
}


stmt **
rel_update_exp(mvc *sql, symbol *sc, dlist *assignmentlist, sql_table *t, stmt **rows_affected)
{
	int len;
	stmt *s = NULL, **updates, *tid;
	dnode *n;
	node *m;
	sql_exp *e;
	sql_rel *r = NULL;

	if (sc) {
		int status = sql->session->status;
		sql_rel *l;

		r = rel_logical_exp(sql, NULL, sc, sql_where);

		if (r && t) { /* simple predicate which is not using the to 
			    be updated table. We add a select all */

			l = rel_basetable(t, t->base.name );
			r = rel_crossproduct(l, r, op_semi);
		}
		if (!r && t) {
			sql->errstr[0] = 0;
			sql->session->status = status;
			r = rel_basetable(t, t->base.name );
			r = rel_logical_exp(sql, r, sc, sql_where);
			if (r && is_join(r->op))
				r->op = op_semi;
		}
		if (!r) 
			return NULL;
	} else {	/* update all */
		r = rel_basetable(t, t->base.name );
	}

	/* We simply create a relation %TID%, updates */

	/* first create the project */
	e = exp_column(r->name, "%TID%", sql_bind_localtype("oid"), CARD_MULTI, 0, 1);
	r = rel_project(r, append(new_exp_list(),e));
	for (n = assignmentlist->h; n; n = n->next) {
		symbol *a = NULL;
		sql_exp *v = NULL;
		dlist *assignment = n->data.sym->data.lval;
		char *cname = assignment->h->data.sval;
		sql_column *c = mvc_bind_column(sql, t, cname);

		if (!c) {
			rel_destroy(r);
			return sql_error(sql, 02, "UPDATE: no such column '%s.%s'", t->base.name, assignment->h->data.sval);
		}
		a = assignment->h->next->data.sym;
		if (a) {
			int status = sql->session->status;
			sql_rel *rel_val = NULL;
			exp_kind ek = {type_value, card_column, FALSE};

			v = rel_value_exp(sql, &rel_val, a, sql_sel, ek);
			if (v) {
				if (rel_val) {
					list *exps = rel_projections(sql, r, NULL, 0, 1);
					sql_rel *nr = rel_project(rel_crossproduct(rel_dup(r->l), rel_val, op_join), exps);
					rel_destroy(r);
					r = nr;
				}
			} else {
				sql->errstr[0] = 0;
				sql->session->status = status;
				v = rel_value_exp(sql, &r, a, sql_sel, ek);
			}		
		} else {
			v = exp_atom(atom_general(&c->type, NULL, 0));
		}

		if (!v || (v = rel_check_type(sql, &c->type, v, type_equal)) == NULL) {
			if (v)
				exp_destroy(v);
			rel_destroy(r);
			return NULL;
		}
		rel_project_add_exp(sql, r, v);
	}
	r = rel_optimizer(sql, r);
	s = rel_bin(sql, r);

	updates = table_update_array(t, &len);
	/* %TID% column */
	tid = stmt_dup(s->op1.lval->h->data); 
	for (n = assignmentlist->h, m = s->op1.lval->h->next; n && m; n = n->next, m = m->next) {
		dlist *assignment = n->data.sym->data.lval;
		char *cname = assignment->h->data.sval;
		sql_column *c = mvc_bind_column(sql, t, cname);

		assert(c);
		updates[c->colnr] = stmt_update_col(c, 
			stmt_join(stmt_reverse(stmt_dup(tid)), stmt_dup(m->data), cmp_equal));
	}
	/* use %TID% column to count the number of rows affected */
	*rows_affected = stmt_affected_rows(stmt_aggr(tid, NULL, sql_bind_aggr(sql->session->schema, "count", NULL), 1));
	stmt_destroy(s);
	return updates;
}

stmt **
sql_update_exp(mvc *sql, scope *scp, symbol *sc, dlist *assignmentlist, sql_table *t, tvar *tv, stmt **rows_affected)
{
	int i, len;
	stmt *s = NULL;
	stmt **updates;
	dnode *n;
	list *l;

	if (sc) {
		s = sql_update_logical_exp(sql, scp, sc, tv );
		if (!s) 
			return NULL;
	} else {	/* update all */
		cvar *c = tv->columns->h->data;

		s = stmt2pivot(scp, stmt_dup(c->s));
	}
	l = create_stmt_list();

	updates = table_update_array(t, &len);

	for (n = assignmentlist->h, i = 0; n; n = n->next, i++) {
		symbol *a = NULL;
		stmt *v = NULL;
		dlist *assignment = n->data.sym->data.lval;
		char *cname = assignment->h->data.sval;
		sql_column *c = mvc_bind_column(sql, t, cname);

		if (!c) {
			stmt_destroy(s);
			list_destroy(l);
			cleanup_stmts(updates, len);
			return sql_error(sql, 02, "UPDATE: no such column '%s.%s'", tv->tname, assignment->h->data.sval);
		}
		a = assignment->h->next->data.sym;
		if (a) {
			exp_kind ek = {type_value, card_column, FALSE};
			v = value_exp(sql, scp, a, NULL, s, sql_sel, ek);
		} else
			v = stmt_atom(atom_general(&c->type, NULL, 0));

		if (!v || (v = check_types(sql, &c->type, v, type_equal)) == NULL) {
			stmt_destroy(s);
			list_destroy(l);
			cleanup_stmts(updates, len);
			return NULL;
		}

		if (v->nrcols <= 0) {
			v = stmt_const(stmt_reverse(s ? first_subset(s) : stmt_bat(c, stmt_dup(tv->s), RDONLY)), v);
		} else {
			if (v->type == st_list && list_length(v->op1.lval) == 2) { /* sub query with outer refs */
				node *o = v->op1.lval->h;
				stmt *oref = stmt_dup(o->next->data);
				stmt *sqa = stmt_dup(o->data);
				stmt *cmp, *h;

				cmp = stmt_join(stmt_reverse(oref), sqa, cmp_equal);
				/* need to fix the cmp head */
				h = stmt_dup(cmp->h->t);
				stmt_destroy(cmp->h);
				cmp->h = h;
				stmt_destroy(v);
				v = cmp;
			}
			/* s is a table result ie new oid, original oid 
			 * v is a result based on subset s, new oid, val
			 * So a join is needed to get original oid, val
			 */
			v = stmt_join(stmt_reverse(first_subset(s)), v, cmp_equal);
		}
		updates[c->colnr] = stmt_update_col(c, v);
	}
	*rows_affected = stmt_affected_rows(stmt_aggr(first_subset(s), NULL, sql_bind_aggr(sql->session->schema, "count", NULL), 1));
	stmt_destroy(s);
	return updates;
}

stmt **
update_exp(mvc *sql, scope *scp, symbol *sc, dlist *assignmentlist, sql_table *t, tvar *tv, stmt **rows_affected)
{
	if (mvc_debug_on(sql,16384)) {
		return rel_update_exp(sql, sc, assignmentlist, t, rows_affected);
	} else {
		return sql_update_exp(sql, scp, sc, assignmentlist, t, tv, rows_affected);
	}
}


