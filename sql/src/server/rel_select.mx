@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2007 CWI.
@' All Rights Reserved.

@f rel_select
@a N.J. Nes
@* 

@h
#ifndef _REL_SELECT_H_
#define _REL_SELECT_H_

#include "rel_semantic.h"

#define sql_from 0
#define sql_where 1
#define sql_having 2
#define sql_sel   3

extern sql_rel *rel_selects(mvc *sql, symbol *sym);
extern void rel_select_add_exp(sql_rel *l, sql_exp *e);
extern sql_rel *rel_select(sql_rel *l, sql_exp *e);

extern sql_exp *exps_bind_column( list *exps, char *cname);
extern sql_exp *exps_bind_column2( list *exps, char *tname, char *cname);

extern sql_exp *rel_bind_column( mvc *sql, sql_rel *rel, char *cname );
extern sql_exp *rel_bind_column2( mvc *sql, sql_rel *rel, char *tname, char *cname );

extern sql_rel *rel_crossproduct(sql_rel *l, sql_rel *r, operator_type join);
extern void rel_join_add_exp( sql_rel *rel, sql_exp *e);

extern sql_rel *
rel_push_select(mvc *sql, sql_rel *rel, sql_exp *ls, sql_exp *e);
extern sql_rel *
rel_push_join(mvc *sql, sql_rel *rel, sql_exp *ls, sql_exp *rs, sql_exp *e);

extern sql_exp *exp_dup(sql_exp* e);
extern void exp_destroy(sql_exp* e);

extern sql_rel *rel_dup(sql_rel *r);
extern void rel_destroy(sql_rel *rel);

#define append(l,v) list_append(l,v) 
#define new_exp_list() list_create((fdestroy)&exp_destroy)
#define new_rel_list() list_create((fdestroy)NULL)

extern sql_exp *exp_compare( sql_exp *l, sql_exp *r, int cmptype);
#define exp_fromtype(e)	((list*)e->r)->h->data
#define exp_totype(e)	((list*)e->r)->h->next->data
extern sql_exp *exp_convert( sql_exp *exp, sql_subtype *fromtype, sql_subtype *totype );
extern sql_exp *exp_op( list *l, sql_subfunc *f );
extern sql_exp *exp_aggr( list *l, sql_subaggr *a, int distinct, int no_nils, int card );

extern void rel_set_name( sql_rel *rel, char *name );

#endif /*_REL_SELECT_H_*/
@c

#include "sql_config.h"
#include "rel_select.h"
#include "sql_semantic.h" 	/* TODO this dependency should be removed, move
				   the dependend code into sql_mvc */
#include "sql_privileges.h"
#include "sql_sequence.h"
#include "sql_env.h"
#include "rel_dump.h"

#define new_subtype_list() list_create((fdestroy)&sql_subtype_destroy)
#define rel_project_exp(e) rel_project(sql, NULL, append(new_exp_list(), e))

static sql_exp *rel_unop_(mvc *sql, sql_exp *l, sql_schema *s, char *fname);
static sql_exp *rel_binop_(mvc *sql, sql_exp *l, sql_exp *r, sql_schema *s, char *fname);
static sql_exp *rel_nop_(mvc *sql, sql_exp *l, sql_exp *r, sql_exp *r2, sql_schema *s, char *fname);

sql_rel *
rel_dup(sql_rel *r) 
{
	sql_ref_inc(&r->ref);
	return r;
}

static void 
rel_destroy_(sql_rel *rel)
{
	if (!rel) 
		return;
	if (rel->name) 
		_DELETE(rel->name);
	if (rel->exps)
		list_destroy(rel->exps);
	if (rel->op != op_basetable && rel->op != op_groupby) {
		if (rel->l)
			rel_destroy(rel->l);
		if (rel->r && !is_distinct(rel))
			rel_destroy(rel->r);
	} else if (rel->op == op_groupby) {
		if (rel->l)
			rel_destroy(rel->l);
		if (rel->r)
			list_destroy(rel->r);
	}
}

void 
rel_destroy(sql_rel *rel)
{
	if (!rel) 
		return;
	if (sql_ref_dec(&rel->ref) > 0)
		return;
	rel_destroy_(rel);
	_DELETE(rel);
}

static sql_rel*
rel_create()
{
	sql_rel *r = NEW(sql_rel);

	sql_ref_init(&r->ref);
	r->name = NULL;
	r->l = r->r = NULL;
	r->exps = NULL;
	r->card = CARD_ATOM;
	r->nrcols = 0;
	r->processed = 0;
	r->subquery = 0;
	r->p = NULL;
	return r;
}

static void
rel_setsubquery(sql_rel*r) 
{
	if (r->l && r->op != op_basetable)
		rel_setsubquery(r->l);
	if (r->r && is_join(r->op)) 
		rel_setsubquery(r->r);
	r->subquery = 1;
}

sql_exp *
exp_dup(sql_exp *exp)
{
	sql_ref_inc(&exp->ref);
	return exp;
}

void 
exp_destroy(sql_exp *exp)
{
	if (!exp) 
		return;
	if (sql_ref_dec(&exp->ref) > 0)
		return;
	if (exp->name) 
		_DELETE(exp->name);
	switch(exp->type){
	case e_atom:
		if (exp->l) 
			atom_destroy(exp->l);
		if (exp->r) 
			_DELETE(exp->r);
		break;
	case e_exp:
		exp_destroy(exp->l);
		exp_destroy(exp->r);
		break;
	case e_relation:
		break;
	case e_column:
		if (exp->l)
			_DELETE(exp->l);
		_DELETE(exp->r);
		break;
	case e_cmp:
		exp_destroy(exp->l);
		exp_destroy(exp->r);
		break;
	case e_convert:
		exp_destroy(exp->l);
		list_destroy(exp->r);
		break;
	case e_aggr:
		sql_subaggr_destroy(exp->f);
		if (exp->l) list_destroy(exp->l);
		break;
	case e_func:
		if (exp->f) sql_subfunc_destroy(exp->f);
		if (exp->l) list_destroy(exp->l);
		break;
	default:
		printf("TODO: exp_destroy %u\n", exp->type);
	}
	_DELETE(exp);
}

static sql_subtype*
dup_subtype(sql_subtype *st)
{
	sql_subtype *res = NEW(sql_subtype);

	*res = *st;
	return res;
}

static sql_subtype * exp_subtype( sql_exp *e );


static sql_subtype *
rel_subtype( sql_rel *r )
{
	if (is_project(r->op)) {
		list *exps = r->exps;
		if (exps && list_length(exps) >= 1) 
			return exp_subtype(exps->t->data);
	} else if (r->op == op_union) {
		return rel_subtype(r->l);
	}
	return NULL;
}

static sql_subtype *
exp_subtype( sql_exp *e )
{
	switch(e->type) {
	case e_atom: {
		if (e->l) {
			atom *a = e->l;
			return atom_type(a);
		} else { /* atom reference */
			return e->f;
		}
	}
	case e_exp:
	case e_convert:
	case e_column:
		return e->f;
	case e_aggr: {
		sql_subaggr *a = e->f;
		return &a->res;
	}
	case e_func: {
		if (e->f) {
			sql_subfunc *f = e->f;
			return &f->res;
		}
		return NULL;
	}
	case e_relation:
		return rel_subtype(e->l);
	case e_cmp:
		/* return bit */
	default:
		return NULL;
	}
}


static sql_exp * exp_create( int type ) 
{
	sql_exp *e = NEW(sql_exp);
	sql_ref_init(&e->ref);
	e->name = NULL;
	e->card = 0;
	e->flag = 0;
	e->l = e->r = NULL;
	e->type = (expression_type)type;
	e->f = NULL;
	return e;
}

static sql_exp * exp_atom( atom *a) 
{
	sql_exp *e = exp_create(e_atom);
	e->card = CARD_ATOM;
	e->l = a;
	return e;
}

static sql_exp * exp_atom_ref(int i, sql_subtype *tpe) 
{
	sql_exp *e = exp_create(e_atom);
	e->card = CARD_ATOM;
	e->flag = i;
	e->f = tpe;
	return e;
}

static sql_exp * exp_param(char *name, sql_subtype *tpe) 
{
	sql_exp *e = exp_create(e_atom);
	e->r = _strdup(name);
	e->card = CARD_ATOM;
	e->f = tpe;
	return e;
}



static sql_exp *
exp_atom_bool(int b) {
	sql_subtype bt; 

	sql_find_subtype(&bt, "boolean", 0, 0);
	if (b) 
		return exp_atom(atom_bool(&bt, TRUE ));
	else
		return exp_atom(atom_bool(&bt, FALSE ));
}

static sql_exp *
exp_atom_int(int i) {
	sql_subtype it; 

	sql_find_subtype(&it, "int", 9, 0);
	return exp_atom(atom_int(&it, i ));
}

static sql_exp *
exp_atom_str(str s) {
	sql_subtype st; 

	sql_find_subtype(&st, "str", 0, 0);
	return exp_atom(atom_string(&st, _strdup(s), 1 ));
}


static sql_exp * exp_relation( sql_rel *r) 
{
	sql_exp *e = exp_create(e_relation);
	e->card = r->card;
	e->l = r;
	return e;
}

static sql_exp * 
exp_column( char *tname, char *cname, sql_subtype *t) 
{
	sql_exp *e = exp_create(e_column);
	e->name = _strdup(cname);
	e->card = CARD_MULTI;
	e->l = (tname)?_strdup(tname):NULL;
	e->r = _strdup(cname);
	e->f = t;
	return e;
}

static sql_exp * 
exp_alias( char *tname, char *cname, sql_exp *old) 
{
	sql_exp *e = exp_create(e_column);

	assert(cname);
	e->card = old->card;
	e->name = _strdup(cname);
	e->l = (tname)?_strdup(tname):NULL;
	e->r = _strdup(cname);
	e->f = exp_subtype(old);
	return e;
}

static str
number2name(str s, int len, int i)
{
	s[--len] = 0;
	while(i>0) {
		s[--len] = '0' + (i & 7);
		i >>= 3;
	}
	s[--len] = 'L';
	return s + len;
}

static void exp_set_name( sql_exp *e, char *name )
{
	if (e->name)
		_DELETE(e->name);
	e->name = _strdup(name);
}

static char *
exp_name( sql_exp *e )
{
	if (e->name)
		return e->name;
	if (e->type == e_convert && e->l)
		return exp_name(e->l);
	return NULL;
}

static sql_exp * 
exp_alias_or_copy( mvc *sql, char *tname, char *cname, sql_exp *old, int settname) 
{
	if (settname && !tname && old->type == e_column)
		tname = old->l;

	if (!cname) {
		char name[16], *nme;
		nme = number2name(name, 16, ++sql->label);

		exp_set_name(old, nme);
		return exp_alias(tname, nme, old);
	} else if (cname && !old->name) {
		exp_set_name(old, cname);
	}
	return exp_alias(tname, cname, old);
}



static sql_exp * 
exp_exp( sql_exp *l, sql_exp *r ) 
{
	sql_exp *e = exp_create(e_exp);
	e->card = l->card;
	e->l = l;
	e->r = r;
	return e;
}

static sql_exp * 
exp_like( sql_exp *l, sql_exp *r, sql_exp *esc, int like) 
{
	sql_exp *e = exp_create(e_cmp);
	e->card = l->card;
	e->l = l;
	e->r = r;
	if (esc)
		e->r = exp_exp(r,esc);
	e->flag = like;
	return e;
}

sql_exp * 
exp_compare( sql_exp *l, sql_exp *r, int cmptype) 
{
	sql_exp *e = exp_create(e_cmp);
	e->card = l->card;
	e->l = l;
	e->r = r;
	e->flag = cmptype;
	return e;
}

#define exp_unop(l,f) \
	exp_op(append(new_exp_list(),l), f)
#define exp_binop(l,r,f) \
	exp_op(append(append(new_exp_list(),l),r), f)
#define exp_op3(l,r,r2,f) \
	exp_op(append(append(append(new_exp_list(),l),r),r2), f)

static int
exps_card( list *l ) 
{
	node *n;
	int card = 0;

	if (l) for(n = l->h; n; n = n->next) {
		sql_exp *e = n->data;

		if (card < e->card)
			card = e->card;
	}
	return card;
}
	
sql_exp * 
exp_op( list *l, sql_subfunc *f )
{
	sql_exp *e = exp_create(e_func);
	e->card = exps_card(l);
	if (!l || list_length(l) == 0)
		e->card = CARD_ATOM; /* unop returns a single atom */
	e->l = l;
	e->f = f; 
	return e;
}

sql_exp * 
exp_convert( sql_exp *exp, sql_subtype *fromtype, sql_subtype *totype )
{
	sql_exp *e = exp_create(e_convert);
	e->card = exp->card;
	e->l = exp;
	totype = dup_subtype(totype);
	e->r = append(append(new_subtype_list(),
			dup_subtype(fromtype)),totype);
	e->f = totype; /* keep a pointer to the copied type, the original may
			  disappear */
	return e;
}

sql_exp * 
exp_aggr( list *l, sql_subaggr *a, int distinct, int no_nils, int card )
{
	sql_exp *e = exp_create(e_aggr);
	e->card = card;
	e->l = l;
	e->f = a; 
	e->flag = (no_nils<<1) + distinct;
	return e;
}

static sql_exp *
basetable_bind_column( sql_rel *rel, char *cname ) 
{
	node *cn;
	sql_table *t = rel->l;
	sql_exp *e = NULL;

	if (rel->exps) /* list of aliases */
		e = exps_bind_column(rel->exps, cname);
	if (e) 
		return exp_alias(NULL, cname, e);
	for (cn = t->columns.set->h; cn; cn = cn->next) {
		sql_column *c = cn->data;
		if (strcmp(c->base.name, cname) == 0)
			return exp_column(rel->name, cname, &c->type );
	}
	return NULL;
}

static sql_exp *
exp_find_column( sql_exp *e )
{
	while(e && e->type != e_column) {
		if (e->type == e_atom || e->type == e_exp || e->type == e_cmp ||
		   !e->l)
			return NULL;
		if (e->type == e_aggr || e->type == e_func) {
			list *l = e->l;
			e = l->h->data;
		}
		if (e->type == e_convert) 
			e = e->l;
	}
	return e;
}

sql_exp *
exps_bind_column( list *exps, char *cname ) 
{
	node *en;

	for (en = exps->h; en; en = en->next ) {
		sql_exp *e = en->data;
		if (e->name && strcmp(e->name, cname) == 0)
			return e;
	}
	return NULL;
}

sql_exp *
exps_bind_column2( list *exps, char *tname, char *cname ) 
{
	node *en;

	for (en = exps->h; en; en = en->next ) {
		sql_exp *e = exp_find_column(en->data);
		
		if (e && e->type == e_column && e->name && e->l && strcmp(e->name, cname) == 0 && strcmp(e->l, tname) == 0)
			return e;
		if (e && e->type == e_column && e->l && e->r && strcmp(e->r, cname) == 0 && strcmp(e->l, tname) == 0)
			return e;
	}
	return NULL;
}


static sql_rel *
rel_bind_table( sql_rel **p, sql_rel *rel, char *tname ) 
{
	sql_rel *r;

	if (rel->name && strcmp(rel->name, tname) == 0) 
		return rel; 
	switch(rel->op) {
	case op_join:
	case op_left:
	case op_right:
	case op_full:
		*p = rel;
		r = rel_bind_table( p,  rel->l, tname);
		if (r) 
			return r;
		*p = rel;
		return rel_bind_table( p, rel->r, tname);
	case op_project:
	case op_groupby:
	case op_select:
	case op_union:
	case op_except:
	case op_inter:
	case op_orderby:
	case op_topn:
		*p = rel;
		return rel_bind_table( p, rel->l, tname);
	default:
		return NULL;
	}
	return NULL;
}

/* find the path to the relation containing the base of the expression 
	(e_column), in most cases this means go down the join tree and 
	find the base column. 
 */
static int
rel_bind_path_( mvc *sql, sql_rel *rel, sql_exp *e, list *path )
{
	int found = 0;

	switch (rel->op) {
	case op_join:
	case op_left:
	case op_right:
	case op_full: 
		/* first right (possible subquery) */
		found = rel_bind_path_( sql, rel->r, e, path);
		if (!found) 
			found = rel_bind_path_( sql, rel->l, e, path);
		break;
	case op_select:
	case op_union:
	case op_inter:
	case op_except:
	case op_orderby:
	case op_topn:
		found = rel_bind_path_( sql, rel->l, e, path);
		break;
	case op_groupby: 
	case op_project:
		if (!rel->exps)
			break;
		if (rel->name && e->l) { /* both have relation names */
			if (strcmp(rel->name, e->l) != 0) 
				break;

			if (exps_bind_column(rel->exps, e->r))
				found = 1;
		} else if (e->l && exps_bind_column2(rel->exps, e->l, e->r)) {
			found = 1;
		} else if (!e->l && exps_bind_column(rel->exps, e->r)) {
			found = 1;
		}
		break;
	case op_table:
		if (e->l && rel->name && strcmp(e->l, rel->name) != 0)
			return 0;
		if (rel->exps && exps_bind_column(rel->exps, e->r)) 
			found = 1;
		break;
	case op_basetable: 
	    {
		node *cn;
		sql_table *t = rel->l;

		if (e->l) {
			if (rel->name && strcmp(e->l, rel->name) != 0)
				return 0;
			else if (!rel->name && strcmp(e->l, t->base.name) != 0)
				return 0;
		}
		if (rel->exps && exps_bind_column(rel->exps, e->r)) {
			found = 1;
			break;
		}
		for (cn = t->columns.set->h; cn; cn = cn->next) {
			sql_column *c = cn->data;
			if (strcmp(c->base.name, e->r) == 0) {
				found = 1;
				break;
			}
		}
	    }
	}
	if (found)
		list_prepend(path, rel);
	return found;
}

static list *
rel_bind_path( mvc *sql, sql_rel *rel, sql_exp *e )
{
	list *path = new_rel_list(); 
	if (e->type == e_column) {
	
		if (rel) {
			if (!rel_bind_path_(sql, rel, e, path)) {
				/* something is wrong */
				list_destroy(path); 
				return NULL;
			}
		}
		return path;
	}
	/* default the top relation */
	append(path, rel); 
	return path;
}


static list *
rel_projections(mvc *sql, sql_rel *rel, char *tname, int settname )
{
	list *rexps, *exps ;

	if (settname && !tname)
		tname = rel->name;

	switch(rel->op) {
	case op_join:
	case op_left:
	case op_right:
	case op_full:
		exps = rel_projections(sql, rel->l, tname, settname );
		rexps = rel_projections(sql, rel->r, tname, settname );
		exps = list_merge( exps, rexps, (fdup)&exp_dup);
		list_destroy(rexps);
		return exps;
	case op_groupby:
	case op_project:
	case op_table:
		if (rel->exps) {
			node *en;

			exps = new_exp_list();
			for (en = rel->exps->h; en; en = en->next) {
				sql_exp *e = en->data;
				append(exps, e=exp_alias_or_copy(sql, tname, exp_name(e), e, settname));
				e->card = rel->card;
			}
			return exps;
		}
	case op_union:
	case op_except:
	case op_inter:
		/* fix card */
		exps = rel_projections(sql, rel->l, tname, settname );
		if (exps) {
			node *en;
			for (en = exps->h; en; en = en->next) {
				sql_exp *e = en->data;
				e->card = rel->card;
			}
		}
		return exps;
	case op_select:
	case op_orderby:
	case op_topn:
		return rel_projections(sql, rel->l, tname, settname );
	case op_basetable: 
	{
		node *cn;
		sql_table *t = rel->l;

		exps = new_exp_list();
		if (rel->exps) {
			node *en;
			for (en = rel->exps->h; en; en = en->next) {
				sql_exp *e = en->data;
				append(exps, exp_alias(NULL, e->name, e ));
			}
		} else {
			for (cn = t->columns.set->h; cn; cn = cn->next) {
				sql_column *c = cn->data;
				append(exps, exp_column(tname, c->base.name, &c->type ));
			}
		}
		return exps;
	} 
	default:
		return NULL;
	}
	return NULL;
}

/*
static sql_exp *
exp_copy( sql_exp *e )
{
	if (e->type == e_relation) {
		sql_rel *r = e->l;
		if (r->op == op_project)
			return r->exps->h->data;
	}
	return e;
}
*/

static sql_rel *
rel_copy( sql_rel *i ) 
{
	sql_rel *rel = rel_create();

	rel->name = (i->name)?_strdup(i->name):NULL;
	rel->l = NULL;
	rel->r = NULL;
	rel->card = i->card;

	switch(i->op) {
	case op_basetable:
		rel->l = i->l;
		break;
	case op_table:
		rel->l = exp_dup(i->l); 
		break;
	case op_groupby:
		rel->l = rel_copy(i->l);
		if (i->r)
			rel->r = (i->r)?list_dup(i->r, (fdup)&exp_dup):NULL;
		break;
	case op_orderby:
	case op_join:
	case op_left:
	case op_right:
	case op_full:
	case op_project:
	case op_select:
	default:
		if (i->l)
			rel->l = rel_copy(i->l);
		if (i->r)
			rel->r = rel_copy(i->r);
		break;
	}
	rel->op = i->op;
	rel->exps = (i->exps)?list_dup(i->exps, (fdup)&exp_dup):NULL;
	return rel;
}

static sql_rel *
rel_basetable(sql_table *t, char *tname) 
{
	sql_rel *rel = rel_create();

	assert(tname);
	rel->name = _strdup(tname);
	rel->l = t;
	rel->r = NULL;
	rel->op = op_basetable;
	rel->exps = NULL;
	rel->card = CARD_MULTI;
	rel->nrcols = list_length(t->columns.set);
	return rel;
}

static sql_rel *
rel_table_func(char *tname, sql_exp *f, list *exps) 
{
	sql_rel *rel = rel_create();

	rel->name = (tname)?_strdup(tname):NULL;
	rel->l = f;
	rel->r = NULL;
	rel->op = op_table;
	rel->exps = exps;
	rel->card = CARD_MULTI;
	rel->nrcols = list_length(exps);
	return rel;
}

static sql_rel *
rel_setop(sql_rel *l, sql_rel *r, operator_type setop)
{
	sql_rel *rel = rel_create();

	rel->name = NULL;
	rel->l = l;
	rel->r = r;
	rel->op = setop;
	rel->exps = NULL;
	rel->card = CARD_MULTI;
	if (l && r) 
		rel->nrcols = l->nrcols + r->nrcols;
	return rel;
}

sql_rel *
rel_crossproduct(sql_rel *l, sql_rel *r, operator_type join)
{
	sql_rel *rel = rel_create();

	rel->name = NULL;
	rel->l = l;
	rel->r = r;
	rel->op = join;
	rel->exps = NULL;
	rel->card = CARD_MULTI;
	rel->nrcols = l->nrcols + r->nrcols;
	return rel;
}

void 
rel_join_add_exp( sql_rel *rel, sql_exp *e)
{
	assert(is_join(rel->op));

	if (!rel->exps)
		rel->exps = new_exp_list();
	append(rel->exps, e);
	if (e->card > rel->card)
		rel->card = e->card;
}

static sql_rel *
rel_project(mvc *sql, sql_rel *l, list *e)
{
	sql_rel *rel = rel_create();

	(void)sql;
	rel->name = NULL;
	rel->l = l;
	rel->r = NULL;
	rel->op = op_project;
	rel->exps = e;
	rel->card = CARD_ATOM; /* no relation */
	if (l) {
		rel->card = l->card;
		rel->nrcols = l->nrcols;
	}
	return rel;
}

static sql_rel *
rel_distinct(mvc *sql, sql_rel *l) 
{
	if (l->op != op_project)
		l = rel_project(sql, l, rel_projections(sql, l, l->name, 1));
	assert (l->op == op_project && (!l->r || l->r == l));
	l->r = l; /* distinct */

	return l;
}


static sql_exp * exps_match(sql_exp *m, sql_exp *e);

static int
explists_match(list *m, list *e)
{
	node *nm,*ne;

	if (!m || !e)
		return (m==e);
	if (list_length(m) != list_length(e)) 
		return 0;
	for (nm = m->h, ne = e->h; nm && ne; nm = nm->next, ne = ne->next) {
		if (!exps_match(nm->data, ne->data))
			return 0;
	}
	return 1;
}

static sql_exp *
exps_match(sql_exp *m, sql_exp *e)
{
	if (m->type != e->type)
		return NULL;
	switch (m->type) {
	case e_column:
		if (strcmp(m->r, e->r) == 0) {
			if (m->l && e->l && (strcmp(m->l, e->l) == 0)) 
				return m;
			else if (!m->l && !e->l)
				return m;
		}
		break;
	case e_aggr:
		if (m->f == e->f && explists_match(m->l, e->l))
			return m;
		break;
	default:
		return NULL;
	}
	return NULL;
}

static sql_exp *
exps_find_match_exp(list *l, sql_exp *e)
{
	node *n;
	if (!l || !list_length(l))
		return NULL;

	for (n = l->h; n; n = n->next){
		sql_exp *m = n->data;
		if (exps_match(m,e))
			return m;
	}
	return NULL;
}

static sql_exp *rel_groupby_add_aggr(mvc *sql, sql_rel *rel, sql_exp *e)
{
	sql_exp *m = NULL;
	char name[16], *nme = NULL;
	char *tname = rel->name;

	if ((m=exps_find_match_exp(rel->exps, e)) == NULL) {
		if (!e->name) {
			nme = number2name(name, 16, ++sql->label);
			exp_set_name(e, nme);
		}
		append(rel->exps, e);
		m = e;
	}
	if (!tname && e->type == e_column)
		tname = e->l;
	return exp_alias(tname, m->name, m);
}

static void 
rel_project_add_exp( mvc *sql, sql_rel *rel, sql_exp *e)
{
	assert(is_project(rel->op));

	if (rel->op == op_project) {
		if (!rel->exps)
			rel->exps = new_exp_list();
		append(rel->exps, e);
	} else if (rel->op == op_groupby) {
		/* todo fix leak */
		(void) rel_groupby_add_aggr(sql, rel, e);
	}
}

static sql_exp *
rel_project_label_exp(mvc *sql, sql_rel *rel, sql_exp *e)
{
	char name[16], *nme;
	nme = number2name(name, 16, ++sql->label);

	exp_set_name(e, nme);
	if (e->card == CARD_AGGR)
		e->card = CARD_MULTI;
	return exp_alias(rel->name, nme, e);
}

static sql_exp *
rel_project_firstcolumn(mvc *sql, sql_rel *rel)
{
	sql_exp *e;
	assert(rel->op == op_project && list_length(rel->exps));

	e = rel->exps->h->data;
	return rel_project_label_exp(sql, rel, e);
}

static sql_exp *
rel_lastexp(mvc *sql, sql_rel *rel ) 
{
	sql_exp *e;
	assert(rel->op == op_project && list_length(rel->exps));

	e = rel->exps->t->data;
	return rel_project_label_exp(sql, rel, e);
}

void
rel_select_add_exp(sql_rel *l, sql_exp *e)
{
	assert(l->op == op_select);
	append(l->exps, e);
}

sql_rel *
rel_select(sql_rel *l, sql_exp *e)
{
	sql_rel *rel = rel_create();
	
	assert(rel->op != op_select);
	rel->name = l->name?_strdup(l->name):NULL;
	rel->l = l;
	rel->r = NULL;
	rel->op = op_select;
	rel->exps = new_exp_list();
	if (e)
		append(rel->exps, e);
	rel->card = CARD_ATOM; /* no relation */
	if (l) {
		rel->card = l->card;
		rel->nrcols = l->nrcols;
	}
	return rel;
}

static sql_rel*
rel_project2groupby(mvc *sql, sql_rel **g)
{
	if ((*g)->op == op_project) { 
		node *en;
		sql_rel *r = *g;

		r->card = CARD_ATOM; /* no groupby expressions */
		r->op = op_groupby;
		r->r = new_exp_list(); /* add empty groupby column list */
		*g = r;
		
		for (en = r->exps->h; en; en = en->next) {
			sql_exp *e = en->data;

			if (e->card > r->card) {
				if (e->type == e_column && e->r) {
					return sql_error(sql, 02, "cannot use non GROUP BY column '%s' in query results without an aggregate function", e->r);
				} else {
					return sql_error(sql, 02, "cannot use non GROUP BY column in query results without an aggregate function");
				}
				return NULL;
			}
		}
		return rel_project(sql, r, rel_projections(sql, r, NULL, 1));
	}
	return NULL;
}

static sql_rel *
rel_groupby_(sql_rel *l, list *groupbyexps )
{
	sql_rel *rel = rel_create();

	if (groupbyexps)
		rel->card = CARD_AGGR;
	else
		rel->card = CARD_ATOM;

	rel->name = NULL;
	rel->l = l;
	rel->r = groupbyexps;
	rel->exps = NULL;
	rel->nrcols = l->nrcols;
	rel->op = op_groupby;
	return rel;
}

static sql_rel *
rel_groupby(sql_rel *l, list *groupbyexps )
{
	sql_rel *rel = rel_groupby_(l,groupbyexps);
	list *aggrs = new_exp_list();
	node *en;

	if (groupbyexps) {
		for (en = groupbyexps->h; en; en = en->next) {
			/* todo make a proper exp_copy (or alias) */
			sql_exp *e = exp_dup(en->data);

			e->card = rel->card;
			append(aggrs, e);
		}
	}

	rel->exps = aggrs;
	return rel;
}

static sql_rel *
rel_groupby_aggrs(mvc *sql, sql_rel *l, list *groupbyexps, list *aggr_exps )
{
	sql_rel *rel = rel_groupby_(l,groupbyexps);
	list *aggrs = new_exp_list();
	node *n;

	rel->exps = aggrs;
	for (n = aggr_exps->h; n; n=n->next) {
		sql_exp *e = n->data;
		e->card = rel->card;
		rel_groupby_add_aggr( sql, rel, e);
	}

	return rel;
}

static sql_rel *
rel_orderby(sql_rel *l, list *orderbyexps )
{
	sql_rel *rel = rel_create();

	rel->name = NULL;
	rel->l = l;
	rel->r = NULL;
	rel->op = op_orderby;	
	rel->exps = orderbyexps;
	rel->card = l->card;
	rel->nrcols = l->nrcols;
	return rel;
}

static sql_rel *
rel_topn(sql_rel *l, list *e )
{
	sql_rel *r = rel_orderby( l, e);
	r->op = op_topn;	
	r->card = l->card;
	r->nrcols = l->nrcols;
	return r;
}

void rel_set_name( sql_rel *rel, char *name )
{
	if (rel->name)
		_DELETE(rel->name);
	rel->name = _strdup(name);
}

static char * rel_get_name( sql_rel *rel )
{
	if (rel->name)
		return (rel->name);
	switch(rel->op) {
	case op_basetable:
	{
		sql_table *t = rel->l;
		return t->base.name;
	}
	default:
		return rel_get_name(rel->l);
	}
	assert(0);
	return NULL;
}

/* ls is the left expression of the select, rs is a simple atom, e is the
   select expression. 
 */
sql_rel *
rel_push_select( mvc *sql, sql_rel *rel, sql_exp *ls, sql_exp *e)
{
	list *l = rel_bind_path(sql, rel, ls);
	node *n;
	sql_rel *lrel = NULL, *p = NULL;

	if (!l) {
		/* expression has no clear parent relation, so filter current 
		   with it */
		if (rel && rel->op == op_select) { /* refine old select */
			rel_select_add_exp(rel, e);
			return rel;
		}
		return rel_select(rel, e);
	}

	for (n = l->h; n; n = n->next ) {
		lrel = n->data;
		
		/* push down as long as the operators allow this
		 */
		if (lrel->op != op_select && lrel->op != op_join)
			break;
		p = lrel;
	}
	if (!lrel)
		return NULL;
	if (p && p->op == op_select) { /* refine old select */
		rel_select_add_exp(p, e);
	} else {
		sql_rel *n = rel_select(lrel, e);

		if (p && p != lrel) {
			assert(p->op == op_join);
			if (p->l == lrel)
				p->l = n;
			else {
				assert(p->r == lrel);
				p->r = n;
			}
		} else {
			if (rel != lrel)
				assert(0);
			rel = n;
		}
	}
	return rel;
}


/* ls and rs are the left and right expression of the join, e is the
   join expression. 
 */
sql_rel *
rel_push_join( mvc *sql, sql_rel *rel, sql_exp *ls, sql_exp *rs, sql_exp *e)
{
	list *l = rel_bind_path(sql, rel, ls);
	list *r = rel_bind_path(sql, rel, rs);
	node *ln, *rn;
	sql_rel *lrel = NULL, *rrel = NULL, *p = NULL;

	if (!l || !r)
		return NULL;

	p = rel;
	for (ln = l->h, rn = r->h; ln && rn; ln = ln->next, rn = rn->next ) {
		lrel = ln->data;
		rrel = rn->data;
		
		/* push down as long as the operators allow this
			and the relation is equal.
		 */
		if (lrel != rrel || 
		   (lrel->op != op_select && lrel->op != op_join))
			break;
		p = lrel;
	}
	if (!lrel || !rrel)
		return NULL;

	/* filter on columns of this relation */
	if (lrel == rrel && lrel->op != op_join) {
		if (lrel->op == op_select) {
			rel_select_add_exp(lrel, e);
		} else if (p && p->op == op_select) {
			rel_select_add_exp(p, e);
		} else {
			sql_rel *n = rel_select(lrel, e);

			if (p && p != lrel) {
				if (p->l == lrel)
					p->l = n;
				else
					p->r = n;
			} else {
				rel = n;
			}
		}
		return rel;
	}

	rel_join_add_exp( p, e);
	return rel;
}

/* forward refs */
static sql_rel * rel_subquery(mvc *sql, sql_rel *rel, symbol *sq, int f);
static sql_rel * rel_setquery(mvc *sql, sql_rel *rel, symbol *sq);
static sql_rel * rel_joinquery(mvc *sql, sql_rel *rel, symbol *sq);
static sql_rel * rel_crossquery(mvc *sql, sql_rel *rel, symbol *q);
static sql_rel * rel_unionjoinquery(mvc *sql, sql_rel *rel, symbol *sq);
static sql_exp * rel_value_exp(mvc *sql, sql_rel **rel, symbol *se, int f);

static sql_rel *
rel_table_optname(mvc *sql, sql_rel *sq, symbol *optname)
{
	(void)sql;
	if (optname && optname->token == SQL_NAME) {
		dlist *columnrefs = NULL;
		char *tname = optname->data.lval->h->data.sval;

		if (tname)
			rel_set_name( sq, tname );
		columnrefs = optname->data.lval->h->next->data.lval;
		if (columnrefs && sq->exps) {
			dnode *d = columnrefs->h;
			node *ne = sq->exps->h;

			for (; d && ne; d = d->next, ne = ne->next) 
				exp_set_name( ne->data, d->data.sval );
		}
	}
	return sq;
}

static sql_rel *
rel_subquery_optname(mvc *sql, sql_rel *rel, symbol *query, int f)
{
	SelectNode *sn = (SelectNode *) query;
	sql_rel *sq = rel_subquery(sql, rel, query, f);

	if (!sq)
		return NULL;

	return rel_table_optname(sql, sq, sn->name);
}

static sql_rel *
query_exp_optname(mvc *sql, sql_rel *r, symbol *q)
{
	switch (q->token) {
	case SQL_UNION:
	case SQL_EXCEPT:
	case SQL_INTERSECT:
	{
		sql_rel *tq = rel_setquery(sql, r, q);

		if (!tq)
			return NULL;
		return rel_table_optname(sql, tq, q->data.lval->t->data.sym);
	}
	case SQL_JOIN:
	{
		sql_rel *tq = rel_joinquery(sql, r, q);

		if (!tq)
			return NULL;
		return rel_table_optname(sql, tq, q->data.lval->t->data.sym);
	}
	case SQL_CROSS:
	{
		sql_rel *tq = rel_crossquery(sql, r, q);

		if (!tq)
			return NULL;
		return rel_table_optname(sql, tq, q->data.lval->t->data.sym);
	}
	case SQL_UNIONJOIN:
	{
		sql_rel *tq = rel_unionjoinquery(sql, r, q);

		if (!tq)
			return NULL;
		return rel_table_optname(sql, tq, q->data.lval->t->data.sym);
	}
	default:
		(void) sql_error(sql, 02, "case %d %s\n", q->token, token2string(q->token));
	}
	return NULL;
}

static sql_rel *
rel_bind_column_(mvc *sql, sql_rel **p, sql_rel *rel, char *cname )
{
	sql_rel *l = NULL, *r = NULL;
	switch(rel->op) {
	case op_join:
	case op_left:
	case op_right:
	case op_full: {
		sql_rel *right = rel->r;

		*p = rel;
		r = rel_bind_column_(sql, p, rel->r, cname);

		if (!r || !right->subquery) {
			*p = rel;
			l = rel_bind_column_(sql, p, rel->l, cname);
			if (l && r && !r->subquery) {
				(void) sql_error(sql, 02, "SELECT: identifier '%s' unknown or ambiguous", cname);
				return NULL;
			}
		}
		if (l && !r)
			return l;
		return r;
	}
	case op_groupby:
	case op_project:
	case op_table:
		if (rel->exps && exps_bind_column(rel->exps, cname))
			return rel;
		*p = rel;
		if (rel->processed)
			return NULL;
		if (rel->l && rel->op != op_table)
			return rel_bind_column_(sql, p, rel->l, cname );
		break;
	case op_basetable:
	{
		node *cn;
		sql_table *t = rel->l;

		for (cn = t->columns.set->h; cn; cn = cn->next) {
			sql_column *c = cn->data;
			if (strcmp(c->base.name, cname) == 0)
				return rel;
		}
		break;
	} 
	case op_select:
	case op_union:
	case op_except:
	case op_inter:
	case op_orderby:
	case op_topn:
		*p = rel;
		return rel_bind_column_(sql, p, rel->l, cname);
	default:
		return NULL;
	}
	return NULL;
}

static sql_exp *
rel_rename_column( mvc *sql, sql_rel *rel, char *cname )
{
	sql_exp *e = NULL;
	char name[16], *nme;
	nme = number2name(name, 16, ++sql->label);

	assert(rel->op == op_basetable);
	/* ambiguous names need fixing */
	e = basetable_bind_column(rel, cname); 
	if (!rel->exps)
		rel->exps = new_exp_list();
	append(rel->exps, e);
	exp_set_name(e, nme);
	return exp_alias(NULL, nme, e);
}

sql_exp *
rel_bind_column( mvc *sql, sql_rel *rel, char *cname )
{
	sql_rel *p = NULL;

	if (!rel || (rel = rel_bind_column_(sql, &p, rel, cname)) == NULL)
		return NULL;

	if (rel && rel->subquery && p && is_join(p->op) && 
	    rel->op == op_basetable && (p->l == rel || p->r == rel)) {
		return rel_rename_column(sql, rel, cname);
	}

	if (is_project(rel->op) || rel->op == op_table) {
		if (rel->exps) {
			sql_exp *e = exps_bind_column(rel->exps, cname);
			if (e)
				return exp_alias_or_copy(sql, rel->name, cname, e, 1);
		}
	} else if (rel->op == op_basetable) {
		return basetable_bind_column(rel, cname);
	}
	return NULL;
}

sql_exp *
rel_bind_column2( mvc *sql, sql_rel *rel, char *tname, char *cname )
{
	if (rel->exps) {
		sql_exp *e = NULL;

		if (rel->name && tname && strcmp(rel->name, tname) == 0)
			e = exps_bind_column(rel->exps, cname);
		else
			e = exps_bind_column2(rel->exps, tname, cname);
		if (e)
			return exp_alias_or_copy(sql, tname, cname, e, 1);
	}
	if (is_project(rel->op)) {
		if (!rel->processed)
			return rel_bind_column2(sql, rel->l, tname, cname);
	} else if (is_join(rel->op)) {
		sql_exp *e = rel_bind_column2(sql, rel->l, tname, cname);
		if (!e)
			e = rel_bind_column2(sql, rel->r, tname, cname);
		return e;
	} else if (is_set(rel->op) || is_sort(rel->op) || is_select(rel->op)) {
		if (rel->l)
			return rel_bind_column2(sql, rel->l, tname, cname);
	} else if (rel->op == op_basetable && strcmp(rel->name, tname) == 0) {
		node *cn;
		sql_table *t = rel->l;

		for (cn = t->columns.set->h; cn; cn = cn->next) {
			sql_column *c = cn->data;
			if (strcmp(c->base.name, cname) == 0)
				return exp_column(rel->name, cname, &c->type );
		}
	}
	return NULL;
}


static sql_rel *
rel_table_func_named(mvc *sql, sql_rel *rel, symbol *query)
{
	list *exps = NULL;
	sql_subtype *st = NULL;
	node *m;

	sql_exp *e = rel_value_exp(sql, &rel, query->data.lval->h->data.sym, sql_from);
	char *tname = NULL;
	if (!e)
		return NULL;

	if (query->data.lval->h->next->data.sym)
		tname = query->data.lval->h->next->data.sym->data.lval->h->data.sval;

	/* colum or table function */
	st = exp_subtype(e);
	if (!st->comp_type) {
		(void) sql_error(sql, 02, "SELECT: '%s' does not return a table", tname);
		return NULL;
	}

	/* foreach column add column name */
	exps = new_exp_list();
	for (m = st->comp_type->columns.set->h; m; m = m->next) {
		sql_column *c = m->data;
		append(exps, exp_column(NULL, c->base.name, &c->type ));
	}
	return rel_table_func(tname, e, exps);
}

static sql_rel *
table_ref(mvc *sql, sql_rel *rel, symbol *tableref)
{
	char *tname = NULL;
	sql_table *t = NULL;

	(void)rel;
	if (tableref->token == SQL_NAME) {
		char *sname = qname_schema(tableref->data.lval->h->data.lval);
		sql_schema *s = NULL;
		tname = qname_table(tableref->data.lval->h->data.lval);

		if (sname && !(s=mvc_bind_schema(sql,sname))) 
			return sql_error(sql, 02, "SELECT: no such schema '%s'", sname);
		if (!s)
			s = cur_schema(sql);
		t = mvc_bind_table(sql, s, tname);
		/* TODO: search path */
		if (!t && !sname) {
			s = tmp_schema(sql);
			t = mvc_bind_table(sql, s, tname);
		}
		if (!t) {
			return sql_error(sql, 02, "SELECT: no such table '%s'", tname);
		} else if (!table_privs(sql, t, PRIV_SELECT)) {
			return sql_error(sql, 02, "User is not allowed to select from table %s", tname);
		}
		if (tableref->data.lval->h->next->data.sym) {	/* AS */
			tname = tableref->data.lval->h->next->data.sym->data.lval->h->data.sval;
		}
		if (isView(t)) { /* base view */
			node *n,*m;
			sql_rel *rel = rel_parse(sql, t->query);
			if (!rel)
				return rel;

			for (n = t->columns.set->h, m = rel->exps->h; n && m; n = n->next, m = m->next) {
				sql_column *c = n->data;
				sql_exp *e = m->data;

				exp_set_name(e, c->base.name);
				if (e->card == CARD_AGGR)
					e->card = CARD_MULTI;
			}
			rel_set_name(rel, tname);
			return rel;
		}
		return rel_basetable(t, tname);
	} else if (tableref->token == SQL_TABLE) {
		return rel_table_func_named(sql, rel, tableref);
	} else if (tableref->token == SQL_SELECT) {
		return rel_subquery_optname(sql, rel, tableref, sql_from);
	} else {
		return query_exp_optname(sql, rel, tableref);
	}
}

static sql_exp *
rel_var_ref(mvc *sql, char *name, int at)
{
	if (stack_find_var(sql, name) != NULL) {
		sql_subtype *tpe = stack_find_type(sql, name);
		/*int frame = stack_find_frame(sql, name);*/
		return exp_param(name, tpe);
	} else if (at) {
		return sql_error(sql, 02, "SELECT: '@""%s' unknown", name);
	} else {
		return sql_error(sql, 02, "SELECT: identifier '%s' unknown or ambiguous", name);
	}
}

static sql_exp *
rel_column_ref(mvc *sql, sql_rel *rel, symbol *column_r)
{
	sql_exp *exp = NULL;
	dlist *l = column_r->data.lval;

	assert(column_r->token == SQL_COLUMN && column_r->type == type_list);
	if (dlist_length(l) == 1 && l->h->type == type_int) {
		int nr = l->h->data.ival;
		atom *a;
		if ((a = sql_bind_arg(sql, nr)) != NULL)
			return exp_atom_ref(nr, atom_type(a));
		return NULL;
	} else if (dlist_length(l) == 1) {
		char *name = l->h->data.sval;
		int var = (stack_find_var(sql, name) != NULL);
		
		exp = rel_bind_column(sql, rel, name);
		if (exp && var) 
			return sql_error(sql, 02, "SELECT: identifier '%s' ambiguous", name);
		if (!exp && var)
			return rel_var_ref(sql, name, 0);
		if (!exp && !var)
			return sql_error(sql, 02, "SELECT: identifier '%s' unknown", name);
		
	} else if (dlist_length(l) == 2) {
		char *tname = l->h->data.sval;
		char *cname = l->h->next->data.sval;

		exp = rel_bind_column2(sql, rel, tname, cname);
		if (!exp) {
			sql_rel *p, *r = rel_bind_table(&p, rel, tname);

			(void)p;
			if (r)
				exp = rel_bind_column(sql, r, cname);
		}
		if (!exp)
			return sql_error(sql, 02, "SELECT: no such column '%s.%s'", tname, cname);
	} else if (dlist_length(l) >= 3) {
		return sql_error(sql, 02, "TODO: column names of level >= 3");
	}
	return exp;
}

static lng
scale2value(int scale)
{
	lng val = 1;

	if (scale < 0)
		scale = -scale;
	for (; scale; scale--) {
		val = val * 10;
	}
	return val;
}

static sql_exp *
exp_fix_scale(mvc *sql, sql_subtype *ct, sql_exp *e, int both, int always)
{
	sql_subtype *et = exp_subtype(e);
	(void) sql;		/* Stefan: unused!? */

	if (ct->type->scale == SCALE_FIX && et->type->scale == SCALE_FIX) {
		int scale_diff = ((int) ct->scale - (int) et->scale);

		if (scale_diff) {
			sql_subtype *it = sql_bind_localtype(et->type->base.name);
			sql_subfunc *c = NULL;

			if (scale_diff < 0) {
				if (!both)
					return e;
				c = sql_bind_func(sql->session->schema, "scale_down", et, it);
			} else {
				c = sql_bind_func(sql->session->schema, "scale_up", et, it);
			}
			if (c) {
				lng val = scale2value(scale_diff);
				atom *a = atom_int(it, val);

				c->res.scale = (et->scale + scale_diff);
				return exp_binop(e, exp_atom(a), c);
			}
		}
	} else if (always && et->scale) {	/* scale down */
		int scale_diff = -(int) et->scale;
		sql_subtype *it = sql_bind_localtype(et->type->base.name);
		sql_subfunc *c = sql_bind_func(sql->session->schema, "scale_down", et, it);

		if (c) {
			lng val = scale2value(scale_diff);
			atom *a = atom_int(it, val);

			c->res.scale = 0;
			return exp_binop(e, exp_atom(a), c);
		} else {
			printf("scale_down mising (%s)\n", et->type->base.name);
		}
	}
	return e;
}

static int
rel_set_type_param(mvc *sql, sql_subtype *type, sql_exp *param)
{
	if (!type || !param || param->type != e_atom || !param->r)
		return -1;

	if (set_type_param(sql, type, param->flag) == 0) {
		param->f = type;
		return 0;
	}
	return -1;
}

static sql_exp * 
rel_check_type(mvc *sql, sql_subtype *t, sql_exp *exp, int tpe)
{
	sql_subtype *fromtype = exp_subtype(exp);
	
	if ((!fromtype || !fromtype->type) && rel_set_type_param(sql, t, exp) == 0)
		return exp;

	if (fromtype && subtype_cmp(t, fromtype) != 0) {
		int c = sql_type_convert(fromtype->type->eclass, t->type->eclass);
		if (!c || 
		   (c == 2 && tpe == type_set) || (c == 3 && tpe != type_cast)){
			exp_destroy(exp);
			exp = NULL;
		} else {
			exp = exp_convert(exp, fromtype, t);
		}
	}
	if (!exp) {
		sql_exp *res = sql_error(
			sql, 03,
			"types %s(%d,%d) (%s) and %s(%d,%d) (%s) are not equal",
			fromtype->type->sqlname,
			fromtype->digits,
			fromtype->scale,
			t->type->base.name,
			t->type->sqlname,
			t->digits,
			t->scale,
			t->type->base.name
		);
		return res;
	}
	return exp;
}

static sql_exp *
exp_sum_scales(mvc *sql, sql_subfunc *f, sql_exp *l, sql_exp *r)
{
	if (strcmp(f->func->imp, "*") == 0 && 
	    f->func->res.type->scale == SCALE_FIX) {
		sql_subtype t;
		sql_subtype *lt = exp_subtype(l);
		sql_subtype *rt = exp_subtype(r);

		f->res.scale = lt->scale + rt->scale;
		f->res.digits = lt->digits + rt->digits;
		/* HACK alert: digits should be less then max */
		if (f->res.type->radix == 10 && f->res.digits > 19)
			f->res.digits = 19;
		if (f->res.type->radix == 2 && f->res.digits > 53)
			f->res.digits = 53;
		/* sum of digits may mean we need a bigger result type 
		 * as the function don't support this we need to
		 * make bigger input types!
		 */

		/* numeric types are fixed length */
		if (f->res.type->eclass == EC_NUM) {
			sql_find_numeric(&t, f->res.type->localtype, f->res.digits);
		} else {
			sql_find_subtype(&t, f->res.type->sqlname, f->res.digits, f->res.scale);
		}
		if (type_cmp(t.type, f->res.type) != 0) { 
			/* do we need to convert to the a larger localtype 
			   int * int may not fit in an int, so we need to 
			   convert to lng * int.
			 */
			sql_subtype nlt;

			sql_init_subtype(&nlt, t.type, f->res.digits, lt->scale);
			l = rel_check_type( sql, &nlt, l, type_equal );
		}
		f->res = t;
	}
	return l;
}

static sql_exp *
exp_scale_algebra(mvc *sql, sql_subfunc *f, sql_exp *l, sql_exp *r)
{
	sql_subtype *lt = exp_subtype(l);
	sql_subtype *rt = exp_subtype(r);

	/*
	 * Decimals are mapped on plain integers. This has impact on the
	 * implemantion of division. First the 'dividend' should be large 
	 * enough to prevent rounding errors. This is solved by a 
	 * multiplication with the 'scale' of the divisor.
	 * Second the result type of the division should be equal to the 
	 * 'dividend', with the maximum scale of the dividend and divisor.
	 *
	 * Example      1.0/0.1 mapped (int 1 dec(1,0) and int 1 dec(2,1))
	 *                              1 * 10 = 10 (scale of divisor)
	 *                              10/1 = 1 dec(1)
	 */

	if (lt->type->scale == SCALE_FIX && rt->scale && 
		strcmp(f->func->imp, "/") == 0) {
		int digits = rt->scale + lt->digits;
		sql_subtype nlt;

		/* HACK alert: digits should be less then max */
		if (f->res.type->radix == 10 && digits > 19)
			digits = 19;
		if (f->res.type->radix == 2 && digits > 53)
			digits = 53;

		/* scale fixing may require a larger type ! */
		sql_find_subtype(&nlt, lt->type->sqlname, digits, lt->scale+rt->scale);
		f->res.digits = digits;
		f->res.scale = lt->scale;
		
		l = rel_check_type( sql, &nlt, l, type_equal );

		sql_find_subtype(&f->res, lt->type->sqlname, f->res.digits, f->res.scale);
	}
	return l;
}

static int 
rel_convert_types(mvc *sql, sql_exp **L, sql_exp **R, int scale_fixing, int tpe)
{
	sql_exp *ls = *L;
	sql_exp *rs = *R;
	sql_subtype *lt = exp_subtype(ls);
	sql_subtype *rt = exp_subtype(rs);

	if (!rt && !lt) {
		sql_error(sql, 01, "Cannot have a parameter (?) on both sides of an expression");
		return -1;
	}
	if (rt && (!lt || !lt->type))
		 return rel_set_type_param(sql, rt, ls);
	if (lt && (!rt || !rt->type))
		 return rel_set_type_param(sql, lt, rs);

	if (rt && lt) {
		sql_subtype *i = lt;
		sql_subtype *r = rt;

		if (subtype_cmp(lt, rt) != 0) {
			sql_subtype super;

			supertype(&super, r, i);
			if (scale_fixing) {
				/* convert ls to super type */
				ls = rel_check_type(sql, &super, ls, tpe);
				/* convert rs to super type */
				rs = rel_check_type(sql, &super, rs, tpe);
			} else {
				/* convert ls to super type */
				super.scale = lt->scale;
				ls = rel_check_type(sql, &super, ls, tpe);
				/* convert rs to super type */
				super.scale = rt->scale;
				rs = rel_check_type(sql, &super, rs, tpe);
			}
		}
		*L = ls;
		*R = rs;
		if (!ls || !rs) {
			return -1;
		}
		return 0;
	}
	return -1;
}

static sql_rel *
rel_compare_exp(mvc *sql, sql_rel *rel, sql_exp *ls, sql_exp *rs, char *compare_op, sql_exp *esc, int f )
{
	sql_exp *L = ls, *R = rs, *e = NULL;
	comp_type type = cmp_equal;

	if (!ls || !rs)
		return NULL;

	if (rel_convert_types(sql, &ls, &rs, 1, type_equal) < 0) {
		if (ls)
			exp_destroy(ls);
		if (rs)
			exp_destroy(rs);
		return NULL;
	}
	if (!rel || f == sql_sel || (ls->card <= CARD_ATOM && rs->card <= CARD_ATOM)) {
		sql_exp *e;

		if (compare_op[0] == 'l') 
			compare_op = "like";
		if (compare_op[0] == 'n') 
			compare_op = "not_like";
		e = rel_binop_(sql, ls, rs, NULL, compare_op);

		if (!e)
			return NULL;
		/* HACK pass expression with in simple value projection */
		if (f == sql_sel) {
			if (rel->op == op_project) { 
				append(rel->exps, e);
			} else {
				list *exps = new_exp_list();

				append(exps, e);
				return rel_project(sql, rel, exps);
			}
		} else {
			return rel_select(rel, e);
		}
	}
	if (compare_op[0] == '=') {
		type = cmp_equal;
	} else if (compare_op[0] == '<') {
		type = cmp_lt;
		if (compare_op[1] != '\0') {
			if (compare_op[1] == '>') {
				type = cmp_notequal;
			} else if (compare_op[1] == '=') {
				type = cmp_lte;
			}
		}
	} else if (compare_op[0] == '>') {
		type = cmp_gt;
		if (compare_op[1] != '\0') {
			if (compare_op[1] == '=') {
				type = cmp_gte;
			}
		}
	} else if (compare_op[0] == 'l') {
		type = cmp_like;
	} else if (compare_op[0] == 'n') {
		type = cmp_notlike;
	}
	if (type != cmp_like && type != cmp_notlike) {
		if (ls->card < rs->card) {
			sql_exp *swap = ls;
	
			ls = rs;
			rs = swap;

			swap = L; 
			L = R; 
			R = swap;

			type = swap_compare(type);
		}
		e = exp_compare( ls, rs, type );
	} else {
		e = exp_like( ls, rs, esc, type );
	}

	/* atom or row => select */
	if (rs->card <= CARD_ATOM) {

		if (ls->card == rs->card)  /* bin compare op */
			return rel_select(rel, e);

		/* push select into the given relation */
		return rel_push_select(sql, rel, L, e);
	} else { /* join */
		return rel_push_join(sql, rel, L, R, e);
	}
	return rel;
}

static sql_rel *
rel_compare(mvc *sql, sql_rel *rel, symbol *lo, symbol *ro, char *compare_op, int f )
{
	sql_exp *rs = 0, *ls;

	if (lo->token == SQL_SELECT) { /* swap subquery to the right handside */
		symbol *tmp = lo;

		lo = ro;
		ro = tmp;

		if (compare_op[0] == '>')
			compare_op[0] = '<';
		else if (compare_op[0] == '<')
			compare_op[0] = '>';
	}

	ls = rel_value_exp(sql, &rel, lo, f);
	if (!ls)
		return NULL;
	if (ro->token != SQL_SELECT) {
		rs = rel_value_exp(sql, &rel, ro, f);
	} else {
		/* first try without current relation, too see if there
		   are correlations with the outer relation */
		sql_rel *r = rel_subquery(sql, NULL, ro, f);

		if (!r) {
			sql->errstr[0] = 0;
			r = rel_subquery(sql, rel, ro, f);

			/* get last expression */
			if (r) {
				rs = rel_lastexp(sql, r);
				rel = r;
			}
		} else if (r->card > CARD_ATOM) {
			/* should be changed to a dynamic check ! */
			return sql_error(sql, 02, 
				"SELECT: subquery returned more than one row");
		} else if (r) {
			rs = exp_relation(r);
		}

		if (!r) {
			exp_destroy(ls);
			return NULL;
		}
	}
	if (!rs) {
		exp_destroy(ls);
		return NULL;
	}
	return rel_compare_exp(sql, rel, ls, rs, compare_op, NULL, f);
}

static sql_rel *
rel_or(mvc *sql, sql_rel *l, sql_rel *r, int f)
{
	sql_rel *rel;

	(void)f;
	rel = rel_setop(l, r, op_union);
	rel->exps = rel_projections(sql, rel, NULL, 1);
	return rel;
}

static sql_rel * rel_logical_exp(mvc *sql, sql_rel *rel, symbol *sc, int f);

static sql_exp *
rel_logical_value_exp(mvc *sql, sql_rel **rel, symbol *sc, int f)
{
	if (!sc)
		return NULL;
	switch (sc->token) {
	case SQL_OR:
	case SQL_AND:
	{
		symbol *lo = sc->data.lval->h->data.sym;
		symbol *ro = sc->data.lval->h->next->data.sym;

		sql_exp *ls = rel_logical_value_exp(sql, rel, lo, f);
		sql_exp *rs = rel_logical_value_exp(sql, rel, ro, f);

		if (!ls || !rs)
			return NULL;
		if (sc->token == SQL_OR)
			return rel_binop_(sql, ls, rs, NULL, "or");
		else
			return rel_binop_(sql, ls, rs, NULL, "and");
	}
	case SQL_COMPARE:
	{
		symbol *lo = sc->data.lval->h->data.sym;
		symbol *ro = sc->data.lval->h->next->next->data.sym;
		char *compare_op = sc->data.lval->h->next->data.sval;

		sql_exp *rs, *ls = rel_value_exp(sql, rel, lo, f);

		if (!ls)
			return NULL;

		if (ro->token != SQL_SELECT) {
			rs = rel_value_exp(sql, rel, ro, f);
			if (!rs) 
				return NULL;
			return rel_binop_(sql, ls, rs, NULL, compare_op);
		} else {
			/* first try without current relation, too see if there
		   	are correlations with the outer relation */
			sql_rel *r = rel_subquery(sql, NULL, ro, f);
	
			if (!r) { /* correlation, ie return new relation */
				sql->errstr[0] = 0;
				r = rel_subquery(sql, *rel, ro, f);

				/* get last expression */
				if (r) {
					rs = rel_lastexp(sql, r);
					*rel = r;
				}
			} else if (r->card > CARD_ATOM) {
				/* should be changed to a dynamic check ! */
				return sql_error(sql, 02, 
				 "SELECT: subquery returned more than one row");
			} else if (r) { 
				rs = exp_relation(r);
			}
	
			if (!r) {
				exp_destroy(ls);
				return NULL;
			}
			return rel_binop_(sql, ls, rs, NULL, compare_op);
		}
	}
	/* Set Member ship */
	case SQL_IN:
	case SQL_NOT_IN:
	{
		dlist *dl = sc->data.lval;
		symbol *lo = dl->h->data.sym;
		dnode *n = dl->h->next;
		sql_exp *l = rel_value_exp(sql, rel, lo, f);
		sql_rel *left = *rel, *right = NULL;
		list *left_exps = NULL;

		if (!l)
			return NULL;

		/* list of values or subqueries */
			/* single element could be a 'select' */
		/*
		if (n->type == type_list) {
			dnode *m = n->data.lval->h;
			if (!m->next && m->type == type_symbol) 
				n = m;
		}
		*/
		left_exps = rel_projections(sql,left, NULL, 1);
		if (l->type != e_column && is_project((*rel)->op)) {
			rel_project_add_exp(sql, *rel, l);
			l = rel_project_firstcolumn(sql, *rel);
		}
			
		if (n->type == type_list) {
			sql_subtype *st = exp_subtype(l);

			n = n->data.lval->h;
			for (; n; n = n->next) {
				symbol *sval = n->data.sym;
				/* without correlation first */
				sql_rel *z = NULL;
				sql_exp *r = rel_value_exp(sql, &z, sval, f);
				sql_rel *rl;

				if (!r || !(r=rel_check_type(sql, st, r, type_equal))) {
					if (r)
						exp_destroy(r);
					exp_destroy(l);
					if (right)
						rel_destroy(right);
					return NULL;
				}
				if (z) {
					rl = z; /* TODO leak cleanup r */
				} else {
 					rl = rel_project_exp(r);
				}
				if (right) {
					rl = rel_setop(right, rl, op_union);
					rl->exps = rel_projections(sql, rl, NULL, 0);
				}
				right = rl;
			}
			/*
			if (right && !is_project(right->op))
				right = rel_project(sql, right, rel_projections(sql,right, NULL));
			*/
			right = rel_distinct(sql, right);
		} else if (n->type == type_symbol) {
			symbol *ro = n->data.sym;

			/* first try without current relation, too see if there
		   	   are correlations with the outer relation */
			right = rel_logical_exp(sql, NULL, ro, f);

			if (!right) {
				sql->errstr[0] = 0;
				return sql_error(sql, 02, "corelation in [NOT] IN is not supported");
			} else {
				right = rel_distinct(sql, right);
			}
		}
		/* right is a relation without correlations */
		if (right) {
			sql_exp *r = NULL, *e;

			r = rel_project_firstcolumn(sql, right);
			rel_setsubquery(right);
			*rel = rel_crossproduct(left, right, op_join);
			if (rel_convert_types(sql, &l, &r, 1, type_equal) < 0) {
				if (l)
					exp_destroy(l);
				if (r)
					exp_destroy(r);
				return NULL;
			}
			e = exp_compare( l, r, cmp_equal );
			rel_join_add_exp(*rel, e);
			if (f >= sql_sel)
				(*rel)->op = op_left;
			*rel = rel_project(sql, *rel, left_exps);
			e = rel_unop_(sql, r, NULL, "isnull");
			if (sc->token == SQL_IN) 
				return rel_unop_(sql, e, NULL, "not");
			return e;
		}
		return NULL;
	}
	case SQL_LIKE:
	case SQL_NOT_LIKE:
	{
		symbol *lo = sc->data.lval->h->data.sym;
		symbol *ro = sc->data.lval->h->next->data.sym;
		sql_subtype *st = sql_bind_localtype("str");
		sql_exp *le = rel_value_exp(sql, rel, lo, f);
		sql_exp *re, *ee = NULL;

		if (!le)
			return NULL;

		if (!exp_subtype(le)) {
			exp_destroy(le);
			return sql_error(sql, 02, "No parameter allowed on left hand of LIKE statement");
		}

		/* Do we need to escape ? */
		if (dlist_length(ro->data.lval) == 2) {
			char *escape = ro->data.lval->h->next->data.sval;
			ee = exp_atom(atom_string(st, _strdup(escape), 1));
		}
		ro = ro->data.lval->h->data.sym;
		re = rel_value_exp(sql, rel, ro, f);
		if (!re)
			return NULL;
		if (!exp_subtype(re)) {
			if (rel_set_type_param(sql, st, re) == -1) {
				exp_destroy(le);
				exp_destroy(re);
				return sql_error(sql, 02, "wrong type used with LIKE statement, should be string");
			}
		} else if ((re = rel_check_type(sql, st, re, type_equal)) == NULL) {
			return sql_error(sql, 02, "Wrong type used with LIKE statement, should be string");
		}
		if (sc->token == SQL_LIKE) {
			if (ee)
				return rel_nop_(sql, le, re, ee, NULL, "like");
			return rel_binop_(sql, le, re, NULL, "like");
		} else {
			if (ee)
				return rel_nop_(sql, le, re, ee, NULL, "not_like");
			return rel_binop_(sql, le, re, NULL, "not_like");
		}
	}
	case SQL_BETWEEN:
	case SQL_NOT_BETWEEN:
	{
		symbol *lo = sc->data.lval->h->data.sym;
		int symmetric = sc->data.lval->h->next->data.ival;
		symbol *ro1 = sc->data.lval->h->next->next->data.sym;
		symbol *ro2 = sc->data.lval->h->next->next->next->data.sym;
		sql_exp *le = rel_value_exp(sql, rel, lo, f);
		sql_exp *re1 = rel_value_exp(sql, rel, ro1, f);
		sql_exp *re2 = rel_value_exp(sql, rel, ro2, f);
		sql_exp *e1 = NULL, *e2 = NULL;
		sql_subtype *ct = NULL;

		if (!le || !re1 || !re2) {
			exp_destroy(le);
			exp_destroy(re1);
			exp_destroy(re2);
			return NULL;
		}
		ct = exp_subtype(le);
		re1 = rel_check_type(sql, ct, re1, type_equal);
		re2 = rel_check_type(sql, ct, re2, type_equal);

		if (!re1 || !re2) {
			exp_destroy(le);
			exp_destroy(re1);
			exp_destroy(re2);
			return NULL;
		}

		if (symmetric) {
			sql_exp *tmp = NULL;
			sql_subfunc *min = sql_bind_func(sql->session->schema, "min", exp_subtype(re1), exp_subtype(re2));
			sql_subfunc *max = sql_bind_func(sql->session->schema, "max", exp_subtype(re1), exp_subtype(re2));

			if (!min || !max) {
				return sql_error(sql, 02, "min or max operator on types %s %s missing", exp_subtype(re1)->type->sqlname, exp_subtype(re2)->type->sqlname);
			}
			tmp = exp_binop(re1, re2, min);
			re2 = exp_binop(exp_dup(re1), exp_dup(re2), max);
			re1 = tmp;
		}

		if (sc->token == SQL_NOT_BETWEEN) {
			e1 = rel_binop_(sql, le, re1, NULL, "<");
			e2 = rel_binop_(sql, exp_dup(le), re2, NULL, ">");
		} else {
			e1 = rel_binop_(sql, le, re1, NULL, ">=");
			e2 = rel_binop_(sql, exp_dup(le), re2, NULL, "<=");
		}
		if (!e1 || !e2)
			return NULL;
		return rel_binop_(sql, e1, e2, NULL, "and");
	}
	case SQL_NULL:
	case SQL_NOT_NULL:
	/* is (NOT) NULL */
	{
		sql_exp *le = rel_value_exp(sql, rel, sc->data.sym, f);

		if (!le)
			return NULL;
		le = rel_unop_(sql, le, NULL, "isnull");
		if (sc->token != SQL_NULL) 
			le = rel_unop_(sql, le, NULL, "not");
		return le;
	}
	case SQL_NOT: { 
		sql_exp *le = rel_logical_value_exp(sql, rel, sc->data.sym, f);
		return rel_unop_(sql, le, NULL, "not");
	}
	case SQL_ATOM: {
		/* TRUE or FALSE */
		AtomNode *an = (AtomNode *) sc;
		return exp_atom(atom_dup(an->a));
	} 
	case SQL_UNION:
	case SQL_EXCEPT:
	case SQL_INTERSECT: {
		sql_rel *r = rel_setquery(sql, *rel, sc);
		if (r)
			return exp_relation(r);
		return NULL;
	} 
	default:
		return sql_error(sql, 02, "Predicate %s %d: time to implement some more", token2string(sc->token), sc->token);
	}
	return sql_error(sql, 02, "Predicate: time to implement some more");
}

static sql_rel *
rel_logical_exp(mvc *sql, sql_rel *rel, symbol *sc, int f)
{
	if (!sc)
		return NULL;
	switch (sc->token) {
	case SQL_OR:
	{
		symbol *lo = sc->data.lval->h->data.sym;
		symbol *ro = sc->data.lval->h->next->data.sym;
		sql_rel *ls = rel;
		sql_rel *rs = rel_copy(rel);

		ls = rel_logical_exp(sql, ls, lo, f);
		rs = rel_logical_exp(sql, rs, ro, f);

		if (!ls || !rs)
			return NULL;
		return rel_or(sql, ls, rs, f);
	}
	case SQL_AND:
	{
		symbol *lo = sc->data.lval->h->data.sym;
		symbol *ro = sc->data.lval->h->next->data.sym;

		rel = rel_logical_exp(sql, rel, lo, f);
		if (!rel)
			return NULL;
		return rel_logical_exp(sql, rel, ro, f);
	}
	case SQL_COMPARE:
	{
		symbol *lo = sc->data.lval->h->data.sym;
		symbol *ro = sc->data.lval->h->next->next->data.sym;
		char *compare_op = sc->data.lval->h->next->data.sval;
		return rel_compare(sql, rel, lo, ro, compare_op, f);
	}
		break;
	/* Set Member ship */
	case SQL_IN:
	case SQL_NOT_IN:
	{
		dlist *dl = sc->data.lval;
		symbol *lo = dl->h->data.sym;
		dnode *n = dl->h->next;
		sql_exp *l = rel_value_exp(sql, &rel, lo, f);
		sql_rel *left = rel, *right = NULL;

		if (!l)
			return NULL;

		/* list of values or subqueries */
			/* single element could be a 'select' */
		/*
		if (n->type == type_list) {
			dnode *m = n->data.lval->h;
			if (!m->next && m->type == type_symbol) 
				n = m;
		}
		*/
		if (n->type == type_list) {
			sql_subtype *st = exp_subtype(l);

			n = n->data.lval->h;
			for (; n; n = n->next) {
				symbol *sval = n->data.sym;
				/* without correlation first */
				sql_rel *z = NULL;
				sql_exp *r = rel_value_exp(sql, &z, sval, f);
				sql_rel *rl;

				if (!r || !(r=rel_check_type(sql, st, r, type_equal))) {
					if (r)
						exp_destroy(r);
					exp_destroy(l);
					if (right)
						rel_destroy(right);
					return NULL;
				}
				if (z) {
					rl = z; /* TODO leak cleanup r */
				} else {
 					rl = rel_project_exp(r);
				}
				if (right) {
					rl = rel_setop(right, rl, op_union);
					rl->exps = rel_projections(sql, rl, NULL, 0);
				}
				right = rl;
			}
			/*
			if (right && !is_project(right->op))
				right = rel_project(sql, right, rel_projections(sql,right, NULL));
			*/
			right = rel_distinct(sql, right);
		} else if (n->type == type_symbol) {
			symbol *ro = n->data.sym;

			/* first try without current relation, too see if there
		   	   are correlations with the outer relation */
			right = rel_logical_exp(sql, NULL, ro, f);

			if (!right) {
				sql->errstr[0] = 0;
				right = rel_subquery(sql, rel, ro, f);
				/* we need a group by here ugh */
				
				if (right) {
					rel_destroy(right);
					return sql_error(sql, 02, "corelation in [NOT] IN is not supported");
				}
			} else {
 				/* we translate the in into a 
				   join(left,distinct(right)).project(left), 
				   maybe we should introduce a semijoin */
				right = rel_distinct(sql, right);
			}
		}
		/* right is a relation without correlations */
		if (right) {
			sql_exp *r = NULL, *e;
			int is_predicate = (l->card == CARD_ATOM); 

			r = rel_project_firstcolumn(sql, right);
			rel_setsubquery(right);
			rel = rel_crossproduct(left, right, op_join);
			if (rel_convert_types(sql, &l, &r, 1, type_equal) < 0) {
				if (l)
					exp_destroy(l);
				if (r)
					exp_destroy(r);
				return NULL;
			}
			if (is_predicate) { 
				sql_exp *tmp = l;
				l = r;
				r = tmp;
			}
			e = exp_compare( l, r, cmp_equal );
			if (is_predicate)
				rel = rel_select(rel, e);
			else
				rel_join_add_exp(rel, e);
			if (sc->token == SQL_NOT_IN) {
				rel->op = op_left;
				e = rel_unop_(sql, r, NULL, "isnull");
				r = exp_atom_bool(1);
				e = exp_compare( e, r, cmp_equal);
				rel = rel_select(rel, e);
			}
			rel = rel_project(sql, rel, rel_projections(sql,left,NULL, 1));
			return rel;
		}
		return right;
	}
	case SQL_EXISTS:
	case SQL_NOT_EXISTS:
	{
		symbol *lo = sc->data.sym;
		char *cmp;
		sql_subaggr *a;
		sql_exp *cnt, *re;
		list *exps = NULL;
		int no_nil = 0;

		rel = rel_subquery(sql, rel, lo, f);
		if (!rel)
			return NULL;

		/* change to aggr(count(*)) > 0 */
		if (sc->token == SQL_EXISTS) {
 			cmp = ">";
		/* change to left join (aggr(count(right_exp)) == 0) */
		} else {	/* NOT EXISTS, needs left join */
			list *rexps = NULL;
			sql_rel *r = rel;
 			cmp = "=";
			no_nil = 1;
			while(r && r->l && !is_join(r->op))
				r = r->l;
			if (!r)
				return NULL;
			assert(r->op == op_join);
			r->op = op_left;
			exps = new_exp_list();
			/* find first right expression */
			if (r->r)
				r = r->r;
			rexps = rel_projections(sql, r, NULL, 1);
			assert(rexps && rexps->h);
			append(exps, exp_dup(rexps->h->data) );
			list_destroy(rexps);
		}
		a = sql_bind_aggr(sql->session->schema, "count", NULL);
		cnt = exp_aggr(exps, a, 0, no_nil, rel->card);
		cnt = rel_groupby_add_aggr(sql, rel, cnt);
		re = exp_atom_int(0);
		return rel_compare_exp(sql, rel, cnt, re, cmp, NULL, f); 
	}
	case SQL_LIKE:
	case SQL_NOT_LIKE:
	{
		symbol *lo = sc->data.lval->h->data.sym;
		symbol *ro = sc->data.lval->h->next->data.sym;
		sql_subtype *st = sql_bind_localtype("str");
		sql_exp *le = rel_value_exp(sql, &rel, lo, f);
		sql_exp *re, *ee = NULL;

		if (!le)
			return NULL;

		if (!exp_subtype(le)) {
			exp_destroy(le);
			return sql_error(sql, 02, "No parameter allowed on left hand of LIKE statement");
		}

		/* Do we need to escape ? */
		if (dlist_length(ro->data.lval) == 2) {
			char *escape = ro->data.lval->h->next->data.sval;
			ee = exp_atom(atom_string(st, _strdup(escape), 1));
		}
		ro = ro->data.lval->h->data.sym;
		re = rel_value_exp(sql, &rel, ro, f);
		if (!re)
			return NULL;
		if (!exp_subtype(re)) {
			if (rel_set_type_param(sql, st, re) == -1) {
				exp_destroy(le);
				exp_destroy(re);
				return sql_error(sql, 02, "wrong type used with LIKE statement, should be string");
			}
		} else if ((re = rel_check_type(sql, st, re, type_equal)) == NULL) {
			return sql_error(sql, 02, "Wrong type used with LIKE statement, should be string");
		}
		if (sc->token == SQL_LIKE) 
			return rel_compare_exp(sql, rel, le, re, "l", ee, f);
		return rel_compare_exp(sql, rel, le, re, "n", ee, f);
	}
	case SQL_BETWEEN:
	case SQL_NOT_BETWEEN:
	{
		symbol *lo = sc->data.lval->h->data.sym;
		int symmetric = sc->data.lval->h->next->data.ival;
		symbol *ro1 = sc->data.lval->h->next->next->data.sym;
		symbol *ro2 = sc->data.lval->h->next->next->next->data.sym;
		sql_exp *le = rel_value_exp(sql, &rel, lo, f);
		sql_exp *re1 = rel_value_exp(sql, &rel, ro1, f);
		sql_exp *re2 = rel_value_exp(sql, &rel, ro2, f);
		sql_subtype *ct = NULL;

		if (!le || !re1 || !re2) {
			exp_destroy(le);
			exp_destroy(re1);
			exp_destroy(re2);
			return NULL;
		}
		ct = exp_subtype(le);
		re1 = rel_check_type(sql, ct, re1, type_equal);
		re2 = rel_check_type(sql, ct, re2, type_equal);

		if (!re1 || !re2) {
			exp_destroy(le);
			exp_destroy(re1);
			exp_destroy(re2);
			return NULL;
		}

		if (symmetric) {
			sql_exp *tmp = NULL;
			sql_subfunc *min = sql_bind_func(sql->session->schema, "min", exp_subtype(re1), exp_subtype(re2));
			sql_subfunc *max = sql_bind_func(sql->session->schema, "max", exp_subtype(re1), exp_subtype(re2));

			if (!min || !max) {
				return sql_error(sql, 02, "min or max operator on types %s %s missing", exp_subtype(re1)->type->sqlname, exp_subtype(re2)->type->sqlname);
			}
			tmp = exp_binop(re1, re2, min);
			re2 = exp_binop(exp_dup(re1), exp_dup(re2), max);
			re1 = tmp;
		}

		if (sc->token == SQL_NOT_BETWEEN) {
			rel = rel_compare_exp(sql, rel, le, re1, "<", NULL, f);
			rel = rel_compare_exp(sql, rel, exp_dup(le), re2, ">", NULL, f);
		} else {
			rel = rel_compare_exp(sql, rel, le, re1, ">=", NULL, f);
			rel = rel_compare_exp(sql, rel, exp_dup(le), re2, "<=", NULL, f);
		}
		return rel;
	}
	case SQL_NULL:
	case SQL_NOT_NULL:
	/* is (NOT) NULL */
	{
		sql_exp *re, *le = rel_value_exp(sql, &rel, sc->data.sym, f);

		if (!le)
			return NULL;
		le = rel_unop_(sql, le, NULL, "isnull");
		re = exp_atom_bool(1);
		if (sc->token == SQL_NULL) 
			le = exp_compare( le, re, cmp_equal);
		else
			le = exp_compare( le, re, cmp_notequal);
		return rel_select(rel, le);
	}
	case SQL_ATOM: {
		/* TRUE or FALSE */
		AtomNode *an = (AtomNode *) sc;
		sql_exp *e = exp_atom(atom_dup(an->a));
		return rel_select(rel, e);
	} 
	case SQL_UNION:
	case SQL_EXCEPT:
	case SQL_INTERSECT: 
		return rel_setquery(sql, rel, sc);
	default:
		return sql_error(sql, 02, "Predicate %s %d: time to implement some more", token2string(sc->token), sc->token);
	}
	return sql_error(sql, 02, "Predicate: time to implement some more");
}

static sql_exp *
rel_op(mvc *sql, symbol *se )
{
	dnode *l = se->data.lval->h;
	sql_subfunc *f = NULL;
	char *fname = qname_fname(l->data.lval); 
	char *sname = qname_schema(l->data.lval);
	sql_schema *s = sql->session->schema;

	if (sname) 
		s = mvc_bind_schema(sql, sname);
	f = sql_bind_func(s, fname, NULL, NULL);
	if (f) {
		return exp_op(NULL, f);
	} else {
		return sql_error(sql, 02, 
			"SELECT: no such operator '%s'", fname);
	}
	return NULL;
}

static sql_exp *
rel_unop_(mvc *sql, sql_exp *e, sql_schema *s, char *fname)
{
	sql_subfunc *f = NULL;
	sql_subtype *t = NULL;

	if (!s)
		s = sql->session->schema;
	t = exp_subtype(e);
	f = sql_bind_func(s, fname, t, NULL);
	/* try to find the function without a type, and convert
	 * the value to the type needed by this function!
	 */
	if (!f && (f = sql_find_func(s, fname, 1)) != NULL) {
		sql_arg *a = f->func->ops->h->data;

		e = rel_check_type(sql, &a->type, e, type_equal);
		if (!e) {
			sql_subfunc_destroy(f);
			f = NULL;
		}
	}
	if (f) {
		if (f->func->imp) {
			if (f->func->res.scale == INOUT) {
				f->res.digits = t->digits;
				f->res.scale = t->scale;
			}
			return exp_unop(e, f);
		/* 
		} else {
			stmt *res;
			sql_arg *a = f->func->ops->h->data;

			sql_add_param(sql, _strdup(a->name), e);

			res = sqlparse_intern(sql, f->func->imp);
			sql_subfunc_destroy(f);
			return res;
		*/
		}
	} else if (e) {
		char *type = exp_subtype(e)->type->sqlname;

		exp_destroy(e);
		return sql_error(sql, 02, "SELECT: no such unary operator '%s(%s)'", fname, type);
	}
	return NULL;
}

static sql_exp *
rel_unop(mvc *sql, sql_rel **rel, symbol *se, int fs)
{
	dnode *l = se->data.lval->h;
	char *fname = qname_fname(l->data.lval); 
	char *sname = qname_schema(l->data.lval);
	sql_schema *s = sql->session->schema;
	sql_exp *e = rel_value_exp(sql, rel, l->next->data.sym, fs);

	if (!e)
		return NULL;
	if (sname) 
		s = mvc_bind_schema(sql, sname);
	return rel_unop_(sql, e, s, fname);
}


static sql_exp *
rel_binop_(mvc *sql, sql_exp *l, sql_exp *r, sql_schema *s, char *fname)
{
	sql_exp *res = NULL;
	sql_subtype *t1, *t2;
	sql_subfunc *f = NULL;

	t1 = exp_subtype(l);
	t2 = exp_subtype(r);

	if (!s)
		s = sql->session->schema;
	f = sql_bind_func(s, fname, t1, t2);
	if (!f && is_commutative(fname)) {
		f = sql_bind_func(s, fname, t2, t1);
		if (f) {
			sql_subtype *tmp = t1;
			t1 = t2;	
			t2 = tmp;
			res = l;		
			l = r;
			r = res;
		}
	}
	if (f) {
		if (f->func->res.scale == SCALE_FIX) {
			l = exp_fix_scale(sql, t2, l, 0, 0);
			r = exp_fix_scale(sql, t1, r, 0, 0);
		} else if (f->func->res.scale == SCALE_SUB) {
			l = exp_scale_algebra(sql, f, l, r);
		} else if (f->func->res.scale == SCALE_ADD) {
			l = exp_sum_scales(sql, f, l, r);
		} else if (f->func->res.scale == DIGITS_ADD) {
			f->res.digits = t1->digits + t2->digits;
		}
		return exp_binop(l, r, f);
	} else {
		int digits = t1->digits + t2->digits;

		if ((f = sql_bind_member(s, fname, t1, 2)) != NULL) {
			/* try finding function based on first argument */
			node *m = f->func->ops->h;
			sql_arg *a = m->next->data;

			r = rel_check_type(sql, &a->type, r, type_equal);
			if (r)
				return exp_binop(l, r, f);
		} else if (rel_convert_types(sql, &l, &r, 1/*fix scale*/, type_equal) >= 0){
			/* try operators */
			t1 = exp_subtype(l);
			t2 = exp_subtype(r);
			f = sql_bind_func(s, fname, t1, t2);
			if (f) {
				if (f->func->res.scale == SCALE_FIX) {
					l = exp_fix_scale(sql, t2, l, 0, 0);
					r = exp_fix_scale(sql, t1, r, 0, 0);
				} else if (f->func->res.scale == SCALE_SUB) {
					l = exp_scale_algebra(sql, f, l, r);
				} else if (f->func->res.scale == SCALE_ADD) {
					l = exp_sum_scales(sql, f, l, r);
				} else if (f->func->res.scale == DIGITS_ADD) {
					f->res.digits = digits;
				}
				return exp_binop(l, r, f);
			}
		}
	}
	if (r && l)
		res = sql_error(sql, 02, "SELECT: no such binary operator '%s(%s,%s)'", fname, exp_subtype(l)->type->sqlname, exp_subtype(r)->type->sqlname);
	if (l)
		exp_destroy(l);
	if (r)
		exp_destroy(r);
	return res;
}

#define SQLMAXDEPTH ((THREAD_STACK_SIZE/4096))

static sql_exp *
rel_binop(mvc *sql, sql_rel **rel, symbol *se, int f)
{
	dnode *dl = se->data.lval->h;
	sql_exp *l, *r;
	char *fname = qname_fname(dl->data.lval); 
	char *sname = qname_schema(dl->data.lval);
	sql_schema *s = sql->session->schema;

 	l = rel_value_exp(sql, rel, dl->next->data.sym, f);
	r = rel_value_exp(sql, rel, dl->next->next->data.sym, f);

	if (!l || !r) {
		if (l)
			exp_destroy(l);
		if (r)
			exp_destroy(r);
		return NULL;
	}

	if (sname) 
		s = mvc_bind_schema(sql, sname);
	return rel_binop_(sql, l, r, s, fname);
}

static sql_exp *
rel_nop_(mvc *sql, sql_exp *a1, sql_exp *a2, sql_exp *a3, sql_schema *s, char *fname)
{
	list *tl = list_create(NULL);
	sql_subfunc *f = NULL;

	append(tl, exp_subtype(a1));
	append(tl, exp_subtype(a2));
	append(tl, exp_subtype(a3));

	if (!s)
		s = sql->session->schema;
	f = sql_bind_func_(s, fname, tl);
	list_destroy(tl);
	if (f)
		return exp_op3(a1,a2,a3,f);
	return sql_error(sql, 02, "SELECT: no such operator '%s'", fname);
}

static sql_exp *
rel_nop(mvc *sql, sql_rel **rel, symbol *se, int fs)
{
	dnode *l = se->data.lval->h;
	dnode *ops = l->next->data.lval->h;
	list *exps = new_exp_list();
	list *tl = list_create(NULL);
	sql_subfunc *f = NULL;
	char *fname = qname_fname(l->data.lval); 
	char *sname = qname_schema(l->data.lval);
	sql_schema *s = sql->session->schema;

	for (; ops; ops = ops->next) {
		sql_exp *e = rel_value_exp(sql, rel, ops->data.sym, fs);

		if (!e) {
			list_destroy(exps);
			return NULL;
		}
		append(exps, e);
		append(tl, exp_subtype(e));
	}
	if (sname) 
		s = mvc_bind_schema(sql, sname);
	f = sql_bind_func_(s, fname, tl);
	list_destroy(tl);
	if (f) {
		return exp_op(exps, f);
	} else if ((f = sql_bind_member(s, fname, exp_subtype(exps->h->data), list_length(exps))) != NULL) {
		node *n, *m;
		list *nexps = new_exp_list();

		n = exps->h;
		append(nexps, exp_dup(n->data));
		m = f->func->ops->h;
		for (n = n->next, m = m->next; n && m; n = n->next, m = m->next) {
			sql_arg *a = m->data;
			sql_exp *e = exp_dup(n->data);

			e = rel_check_type(sql, &a->type, e, type_equal);
			if (!e) {
				list_destroy(nexps);
				nexps = NULL;
				break;
			}
			append(nexps, e);
		}
		if (nexps) {
			list_destroy(exps);
			return exp_op(nexps, f);
		}
	}
	list_destroy(exps);
	return sql_error(sql, 02, "SELECT: no such operator '%s'", fname);
}

static sql_exp *
rel_aggr(mvc *sql, sql_rel **rel, symbol *se, int f)
{
	dlist *l = se->data.lval;
	sql_subaggr *a = NULL;
	int distinct = l->h->next->data.ival;
	char *aggrstr = l->h->data.sval;
	sql_exp *e = NULL, *exp = NULL;
	sql_rel *groupby, *old;
	int no_nil = 0;

	groupby = *rel;

	if (groupby->l && groupby->op == op_project) {
		sql_rel *r = groupby->l;	
		if (r->op == op_groupby) {
			groupby = r;
		} else if (r->op == op_select && r->l) {  
			/* a having after a groupby */
			r = r->l;
			if (r->op == op_groupby)
				groupby = r;
		}
	}

	if (groupby->op != op_groupby)   	/* implicite groupby */
		*rel = rel_project2groupby(sql, &groupby);
 	old = *rel; 
	if (!old)
		return NULL;

	if (f == sql_where && !groupby) 
		return sql_error(sql, 02, "%s: not allowed in WHERE clause", toUpper(alloca(strlen(aggrstr) + 1), aggrstr));
	
	if (!l->h->next->next->data.sym) {	/* count(*) case */

		if (strcmp(aggrstr, "count") != 0) {
			return sql_error(sql, 02, "%s: unable to perform '%s(*)'", toUpper(alloca(strlen(aggrstr) + 1), aggrstr), aggrstr);
		}
		a = sql_bind_aggr(sql->session->schema, aggrstr, NULL);
		/* add aggr expression to the groupby, and return a 
			column expression */
		e = exp_aggr(NULL, a, distinct, 0, groupby->card);
		if (*rel == groupby && f == sql_sel) /* selection */ 
			return e;
		return rel_groupby_add_aggr(sql, groupby, e);
	} else {
		/* use cnt as nils shouldn't to be counted */
		sql_rel *gr = groupby->l;

		no_nil = 1;
		e = rel_value_exp(sql, &gr, l->h->next->next->data.sym, f);
		groupby->l = gr;
	}

	if (!e)
		return NULL;
	a = sql_bind_aggr(sql->session->schema, aggrstr, exp_subtype(e));
	if (a) {
		/* type may have changed, ie. need to fix_scale */
		sql_subtype *t = exp_subtype(e);
		list *exps = new_exp_list();

		append(exps, e);
		e = exp_aggr(exps, a, distinct, no_nil, groupby->card);
		exp = e;
		if (*rel != old)
			exp = rel_groupby_add_aggr(sql, *rel, exp);
		else if (*rel != groupby || f != sql_sel) /* selection */ 
			exp = rel_groupby_add_aggr(sql, groupby, exp);
		return exp_fix_scale(sql, t, exp, 1, 
					(t->type->scale == SCALE_FIX));
	} else {
		char *type = exp_subtype(e)->type->sqlname;

		exp_destroy(e);
		return sql_error(sql, 02, "%s: no such operator '%s(%s)'", toUpper(alloca(strlen(aggrstr) + 1), aggrstr), aggrstr, type);
	}
	return NULL;
}

static sql_exp *
rel_case(mvc *sql, sql_rel **rel, int token, symbol *opt_cond, dlist *when_search_list, symbol *opt_else, int f)
{
	sql_subtype *tpe = NULL;
	list *conds = new_exp_list();
	list *results = new_exp_list();
	dnode *dn = when_search_list->h;
	sql_subtype *restype = NULL, rtype;
	sql_exp *res = NULL, *else_exp = NULL;
	node *n, *m;

	if (dn) {
		sql_exp *cond = NULL, *result = NULL;

		/* NULLIF(e1,e2) == CASE WHEN e1=e2 THEN NULL ELSE e1 END */
		if (token == SQL_NULLIF) {
			sql_exp *e1, *e2;

			e1 = rel_value_exp(sql, rel, dn->data.sym, f);
			e2 = rel_value_exp(sql, rel, dn->next->data.sym, f);
			if (e1 && e2) {
				cond = rel_binop_(sql, exp_dup(e1), e2, NULL, "=");
				result = exp_atom(atom_general(exp_subtype(e1), NULL, 0));
				else_exp = e1;	/* ELSE case */
			} else {
				if (e1)
					exp_destroy(e1);
				if (e2)
					exp_destroy(e2);
			}
			/* COALESCE(e1,e2) == CASE WHEN e1 
			   IS NOT NULL THEN e1 ELSE e2 END */
		} else if (token == SQL_COALESCE) {
			cond = rel_value_exp(sql, rel, dn->data.sym, f);

			if (cond) {
				result = exp_dup(cond);
				cond = rel_unop_(sql, rel_unop_(sql, cond, NULL, "isnull"), NULL, "not");
			}
		} else {
			dlist *when = dn->data.sym->data.lval;

			if (opt_cond) {
				sql_exp *l = rel_value_exp(sql, rel, opt_cond, f);
				sql_exp *r = rel_value_exp(sql, rel, when->h->data.sym, f);
				if (!l || !r)
					return NULL;
				cond = rel_binop_(sql, l, r, NULL, "=");
			} else {
				/* binary value exp (TODO check result type?) */
				cond = rel_value_exp(sql, rel, when->h->data.sym, sql_sel);
			}
			result = rel_value_exp(sql, rel, when->h->next->data.sym, f);
		}
		if (!cond || !result) {
			list_destroy(conds);
			list_destroy(results);
			return NULL;
		}
		list_prepend(conds, cond);
		list_prepend(results, result);

		restype = exp_subtype(result);

		if (token == SQL_NULLIF)
			dn = NULL;
		else
			dn = dn->next;
	}
	if (!restype) {
		list_destroy(conds);
		list_destroy(results);
		return sql_error(sql, 02, "result type missing");
	}
	/* for COALESCE we skip the last (else part) */
	for (; dn && (token != SQL_COALESCE || dn->next); dn = dn->next) {
		sql_exp *cond = NULL, *result = NULL;

		if (token == SQL_COALESCE) {
			cond = rel_value_exp(sql, rel, dn->data.sym, f);

			if (cond) {
				result = exp_dup(cond);
				cond = rel_unop_(sql, rel_unop_(sql, cond, NULL, "isnull"), NULL, "not");
			}
		} else {
			dlist *when = dn->data.sym->data.lval;

			if (opt_cond) {
				sql_exp *l = rel_value_exp(sql, rel, opt_cond, f);
				sql_exp *r = rel_value_exp(sql, rel, when->h->data.sym, f);
				cond = rel_binop_(sql, l, r, NULL, "=");
				if (!l || !r)
					return NULL;
			} else {
				/* binary value exp (TODO check result type?) */
				cond = rel_value_exp(sql, rel, when->h->data.sym, sql_sel);
			}
			result = rel_value_exp(sql, rel, when->h->next->data.sym, sql_sel);
		}
		if (!cond || !result) {
			list_destroy(conds);
			list_destroy(results);
			return NULL;
		}
		list_prepend(conds, cond);
		list_prepend(results, result);

		tpe = exp_subtype(result);
		if (!tpe) {
			list_destroy(conds);
			list_destroy(results);
			return sql_error(sql, 02, "result type missing");
		}
		supertype(&rtype, restype, tpe);
		if (!tpe) {
			list_destroy(conds);
			list_destroy(results);
			return sql_error(sql, 02, "result types %s,%s of case are not compatible", restype->type->sqlname, tpe->type->sqlname);
		}
		restype = &rtype;
	}
	if (opt_else || else_exp) {
		sql_exp *result = else_exp;

		if (!result)
			result = rel_value_exp(sql, rel, opt_else, f);

		tpe = exp_subtype(result);
		if (tpe && restype) {
			supertype(&rtype, restype, tpe);
			tpe = &rtype;
		}
		restype = tpe;

		if (!result || !(result = rel_check_type(sql, restype, result, type_equal))) {
			list_destroy(conds);
			list_destroy(results);
			return NULL;
		}

		if (res)
			exp_destroy(res);
		res = result;

		if (!res) {
			list_destroy(conds);
			list_destroy(results);
			return NULL;
		}
	} else {
		sql_exp *a = exp_atom(atom_general(restype, NULL, 0));

		res = a;
	}

	for (n = conds->h, m = results->h; n && m; n = n->next, m = m->next) {
		sql_exp *cond = exp_dup(n->data);
		sql_exp *result = exp_dup(m->data);

		if (!(result = rel_check_type(sql, restype, result, type_equal))) {
			list_destroy(conds);
			list_destroy(results);
			exp_destroy(res);
			return NULL;
		}

		res = rel_nop_(sql, cond, result, res, NULL, "ifthenelse" );
		if (!res) { 
			list_destroy(conds);
			list_destroy(results);
			exp_destroy(res);
			return NULL;
		}
	}
	list_destroy(conds);
	list_destroy(results);
	return res;
}

static sql_exp *
rel_case_exp(mvc *sql, sql_rel **rel, symbol *se, int f)
{
	dlist *l = se->data.lval;

	if (se->token == SQL_COALESCE) {
		symbol *opt_else = l->t->data.sym;

		return rel_case(sql, rel, se->token, NULL, l, opt_else, f);
	} else if (se->token == SQL_NULLIF) {
		return rel_case(sql, rel, se->token, NULL, l, NULL, f);
	} else if (l->h->type == type_list) {
		dlist *when_search_list = l->h->data.lval;
		symbol *opt_else = l->h->next->data.sym;

		return rel_case(sql, rel, SQL_CASE, NULL, when_search_list, opt_else, f);
	} else {
		symbol *scalar_exp = l->h->data.sym;
		dlist *when_value_list = l->h->next->data.lval;
		symbol *opt_else = l->h->next->next->data.sym;

		return rel_case(sql, rel, SQL_CASE, scalar_exp, when_value_list, opt_else, f);
	}
}

static sql_exp *
rel_cast(mvc *sql, sql_rel *rel, symbol *se, int f)
{

	dlist *dl = se->data.lval;
	symbol *s = dl->h->data.sym;
	sql_subtype *tpe = &dl->h->next->data.typeval;

	sql_exp *e = rel_value_exp(sql, &rel, s, f);

	if (!e)
		return NULL;
	/* strings may need too be truncated */
	if (tpe ->type ->localtype == TYPE_str) { 
		if (tpe->digits > 0) {
			sql_subtype *et = exp_subtype(e);
			sql_subtype *it = sql_bind_localtype("int");
			sql_subfunc *c = sql_bind_func(sql->session->schema, "truncate", et, it);
			if (c)
				e = exp_binop(e, exp_atom_int(tpe->digits), c);
		}
	}
	if (e)
		return rel_check_type(sql, tpe, e, type_cast);
	return NULL;
}

sql_exp *
rel_table_func_exp(mvc *sql, sql_rel *rel, symbol *sym, int f ) 
{
	sql_rel *r = rel_subquery(sql, rel, sym, f);

	if (!r)
		return NULL;
	/* todo administer that its a table call */
	return exp_relation(r);
}


static sql_exp *
rel_value_exp(mvc *sql, sql_rel **rel, symbol *se, int f)
{
	switch (se->token) {
	case SQL_OP:
		return rel_op(sql, se );
	case SQL_UNOP:
		return rel_unop(sql, rel, se, f);
	case SQL_BINOP:
		return rel_binop(sql, rel, se, f);
	case SQL_NOP:
		return rel_nop(sql, rel, se, f);
	case SQL_AGGR:
		return rel_aggr(sql, rel, se, f);
	case SQL_COLUMN:
		return rel_column_ref(sql, *rel, se );
	case SQL_NAME:
		return rel_var_ref(sql, se->data.sval, 1);
	case SQL_SELECT: {
		sql_rel *old = NULL;
		sql_rel *r = NULL;

		if (!r) {
			r = *rel;
			/* for now only rewrite relational tree in 
				the selection fase */
			if (r && f==sql_sel) { 
				if (is_project(r->op)) {
					old = r;
					r = r->l;
				}
				if (is_groupby(r->op)) {
					old = r;
					r = r->l;
				}
			} 
			r = rel_subquery(sql, r, se, f);
			if (old) {
				old->l = r;
				*rel = old;
			} else {
				*rel = r;
			}
		}
		if (r)  
			return rel_lastexp(sql, r);
		return NULL;
	}
	case SQL_TABLE:  /* turn a subquery into a tabular result */
	{
		return rel_table_func_exp(sql, *rel, se->data.sym, f);
	}
		break;
	case SQL_PARAMETER:{
		if (sql->mode != m_prepare) 
			return sql_error(sql, 02, "SELECT: parameters ('?') not allowed in normal queries, use PREPARE");
		return exp_atom_ref(se->data.ival, NULL);
	}
	case SQL_ATOM:{
		AtomNode *an = (AtomNode *) se;

		if (!an || !an->a) {
			return exp_atom(atom_general(sql_bind_localtype("str"), NULL, 0));
		} else {
			return exp_atom(atom_dup(an->a));
		}
	}
	case SQL_NEXT:{
		sql_subtype *str_t = sql_bind_localtype("str");
		sql_subfunc *f;
		char *seq = se->data.sval;

		if ( !find_sql_sequence(sql->session->schema, seq)) 
			return sql_error(sql, 02, "NEXT VALUE FOR: "
			                 "no such sequence '%s'", seq);
		f = sql_bind_func(NULL, "next_value_for", str_t, NULL);
		assert(f);
		return exp_unop( exp_atom_str(seq), f);
	} 
	case SQL_CAST:
		return rel_cast(sql, *rel, se, f);
	case SQL_CASE:
	case SQL_COALESCE:
	case SQL_NULLIF:
		return rel_case_exp(sql, rel, se, f);
	default: 
		return rel_logical_value_exp(sql, rel, se, f);
	}
	return NULL;
}

static sql_exp *
column_exp(mvc *sql, sql_rel **rel, symbol *column_e, int f)
{
	dlist *l = column_e->data.lval;
	sql_exp *ve = rel_value_exp(sql, rel, l->h->data.sym, f);

	if (!ve)
		return NULL;
	/* AS name */
	if (ve && l->h->next->data.sval) 
		exp_set_name(ve, l->h->next->data.sval);
	return ve;
}

static list *
rel_table_exp(mvc *sql, sql_rel *rel, symbol *column_e )
{
	if (column_e->token == SQL_TABLE) {
		char *tname = column_e->data.lval->h->data.sval;
		sql_rel *p, *r = rel_bind_table(&p, rel, tname);

		(void)p;
		if (r) 
			return rel_projections(sql, r, tname, 1 );
		return sql_error(sql, 02, 
			"Column expression Table '%s' unknown", tname);
	}
	return NULL;
}

static sql_exp *
rel_column_exp(mvc *sql, sql_rel **rel, symbol *column_e, int f)
{
	if (column_e->token == SQL_COLUMN) {
		return column_exp(sql, rel, column_e, f);
	}
	return NULL;
}

static sql_rel *
rel_simple_select(mvc *sql, sql_rel *rel, symbol *where, dlist *selection)
{
	dnode *n = selection->h;

	(void) where;
	if (where) {
		sql_rel *r = rel_logical_exp(sql, rel, where, sql_where);
		if (!r)
			return NULL;
		rel = r;
	}
	if (!rel || rel->op != op_project)
		rel = rel_project(sql, rel, new_exp_list());
	for (; n; n = n->next ) {
		/* Here we could get real column expressions (including single
		 * atoms) but also table results. Therefor we try both
		 * rel_column_exp and rel_table_exp.
		 */
		list *te = NULL; 
		sql_exp *ce = rel_column_exp(sql, &rel, n->data.sym, sql_sel);

		if (ce && exp_subtype(ce)) {
			/* new relational, we need to rewrite */
			rel_project_add_exp(sql, rel, ce);
			continue;
		} else if (!ce) {
			te = rel_table_exp(sql, rel, n->data.sym );
		} else {
			exp_destroy(ce);
			ce = NULL;
		}
		if (!ce && !te) 
			return sql_error(sql, 02, "SELECT: subquery result missing");
		/* here we should merge the column expressions we obtained
		 * sofar with the table expression, ie t1.* or a subquery 
		 */
		if (te) {
			list_merge( rel->exps, te, (fdup)&exp_dup);
			list_destroy(te);
		}
	}
	if (rel)
		rel->processed = 1;
	return rel;
}

/* some users like to use aliases allready in the groupby */
sql_exp *
rel_selection_ref(mvc *sql, sql_rel *rel, symbol *grp, dlist *selection )
{
	dnode *n;
	dlist *gl = grp->data.lval;
	char *name = NULL;

	if (dlist_length(gl) > 1)
		return NULL;
	if (!selection)
		return NULL;

	name = gl->h->data.sval;
	for (n = selection->h; n; n = n->next) {
		/* we only look for columns */
		if (n->data.sym->token == SQL_COLUMN) {
			dlist *l = n->data.sym->data.lval;
			/* AS name */ 
			if (l->h->next->data.sval &&
			    strcmp(l->h->next->data.sval, name) == 0){
				sql_exp *ve = rel_value_exp(sql, &rel, l->h->data.sym, sql_sel);
				if (ve) {
					dlist *l = dlist_create(sql->sa);
					symbol *sym;
					exp_set_name(ve, name);
					/* now we should rewrite the selection
					   such that it uses the new group
					   by column 
					*/
					dlist_append_string(sql->sa, l,  
						sa_strdup(sql->sa, name));
					sym = symbol_create_list(sql->sa, SQL_COLUMN, l);
					l = dlist_create(sql->sa);
					dlist_append_symbol(sql->sa, l, sym);
					/* no alias */
					dlist_append_symbol(sql->sa, l, NULL);
					n->data.sym = symbol_create_list(sql->sa, SQL_COLUMN, l);
				
				}
				return ve;
			}
		}
	}
	return NULL;
}

static sql_rel *
rel_group_by(mvc *sql, sql_rel *rel, symbol *groupby, dlist *selection )
{
	dnode *o = groupby->data.lval->h;
	list *exps = new_exp_list();

	for (; o; o = o->next) {
		symbol *grp = o->data.sym;
		sql_exp *e = rel_column_ref(sql, rel, grp);

		if (!e) {
			/* reset error */
			sql->errstr[0] = '\0';
			sql->session->status = 0;

			e = rel_selection_ref(sql, rel, grp, selection);
			if (!e) {
				list_destroy(exps);
				return NULL;
			}
		}
		append(exps, e);
	}
	return rel_groupby( rel, exps );
}

static sql_rel *
rel_order_by(mvc *sql, sql_rel *rel, symbol *orderby )
{
	list *exps = new_exp_list();
	dnode *o = orderby->data.lval->h;

	for (; o; o = o->next) {
		symbol *order = o->data.sym;

		if (order->token == SQL_COLUMN) {
			symbol *col = order->data.lval->h->data.sym;
			int direction = order->data.lval->h->next->data.ival;
			sql_exp *e = rel_column_ref(sql, rel, col);

			if (!e) {
				list_destroy(exps);
				return NULL;
			}
			append(exps, e);
			append(exps, exp_atom_int(direction) );
		} else {
			return sql_error(sql, 02, "order not of type SQL_COLUMN\n");
		}
	}
	return rel_orderby( rel, exps);
}

static sql_rel *
join_on_column_name(mvc *sql, sql_rel *rel, sql_rel *t1, sql_rel *t2, int all)
{
	int found = 0;
	list *exps = rel_projections(sql, t1, NULL, 1);
	node *n;

	if (!exps)
		return NULL;
	for (n = exps->h; n; n = n->next) {
		sql_exp *lc = n->data;
		sql_exp *rc = rel_bind_column(sql, t2, lc->name);

		if (rc) {
			found = 1;
			rel = rel_compare_exp(sql, rel, lc, rc, "=", NULL, sql_where);
		} else if (all) {
			found = 0;
			break;
		}
	}
	list_destroy(exps);
	if (!found) {
		rel_destroy(rel);
		return sql_error(sql, 02, "JOIN: no columns of tables '%s' and '%s' match", rel_get_name(t1), rel_get_name(t2));
	}
	return rel;
}


sql_rel *exp_top_relation(sql_exp *e )
{
	switch(e->type) {	
	case e_atom:
		return NULL;
	case e_relation:
		if (e->l)
			return e->l;
		return NULL;
	case e_exp:
	case e_convert: 
	case e_cmp:
		if (e->l)
			return exp_top_relation(e->l);
		break;
	case e_column:
	default:
		return NULL;
	}
	return NULL;
}

static sql_rel *
rel_select_exp(mvc *sql, sql_rel *rel, sql_rel *outer, SelectNode *sn, int toplevel)
{
	int aggr = 0;

	if (!sn->from)
		return rel_simple_select(sql, rel, sn->where, sn->selection);

	if (sn->where) {
		sql_rel *r = rel_logical_exp(sql, rel, sn->where, sql_where);
		if (!r) 
			return sql_error(sql, 02, "Subquery result missing");
		rel = r;
	}

	if (rel) {
		if (rel && sn->groupby) {
			rel = rel_group_by(sql, rel, sn->groupby,sn->selection);

			if (!rel) 
				return NULL;
			aggr = 1;
		}

		if (outer && rel->op == op_join && rel->l == outer) {
			list *groupby_cols;
			list *aggr_exps = rel_projections(sql, outer, NULL, 1);
			sql_exp *e = NULL;

			if (!is_project(outer->op)) {
				list *exps = rel_projections(sql, outer, NULL, 1);
				outer = rel_project(sql, outer, exps);
				rel->l = outer;
			}
			e = exp_dup(outer->exps->h->data);
			e = rel_unop_(sql, e, NULL, "identity");
			rel_project_add_exp(sql, outer, e);
			e = rel_project_label_exp(sql, outer, e);
			groupby_cols = new_exp_list();
			append(groupby_cols, e);
			rel = rel_groupby_aggrs( sql, rel, groupby_cols, aggr_exps );
		}
	}

	if (sn->having) {
		/* having implies group by, ie if not supplied do a group by */
		if (rel->op != op_groupby) 
			rel = rel_groupby( rel, NULL);

		aggr = 1;
		rel = rel_logical_exp(sql, rel, sn->having, sql_having);

		if (!rel) 
			return NULL;
		if (rel -> exps && exps_card(rel->exps) > CARD_AGGR) {
			/* clean up missing */
			return sql_error(sql, 02, "SELECT: cannot compare sets with values, probably an aggregate function missing");
		}
	}

	if (sn->selection) {
		dnode *n = sn->selection->h;
		int card = 0;

		if (outer)
			rel = rel_project(sql, rel, rel_projections(sql, rel, NULL, 1));
		else
			rel = rel_project(sql, rel, new_exp_list());
		for (; n; n = n->next) {
			/* Here we could get real column expressions 
			 * (including single atoms) but also table results. 
			 * Therefor we try both rel_column_exp 
			 * and rel_table_exp.

			 * TODO 
				the rel_table_exp should simply return a new 
				relation
		 	 */
			list *te = NULL; 
			sql_exp *ce = rel_column_exp(sql, &rel, n->data.sym, sql_sel);
			if (ce && exp_subtype(ce)) {
				/* seems some sub-queries return 
				   valid expressions with invalid cardinality 
				   (which need a dynamic check!!!)
				 */
				if (outer && rel->card < ce->card) {
					ce = rel_groupby_add_aggr(sql, rel->l, ce);
					ce->card = rel->card;	
				}
				rel_project_add_exp(sql, rel, ce);
				continue;
			} else if (!ce) {
				te = rel_table_exp(sql, rel, n->data.sym);
			} else {
				exp_destroy(ce);
				ce = NULL;
			}
			if (!ce && !te) 
				return sql_error(sql, 02, "SELECT: subquery result missing");
			/* here we should merge the column expressions we 
			 * obtained sofar with the table expression, ie 
			 * t1.* or a subquery.
		 	 */
			list_merge( rel->exps, te, (fdup)&exp_dup);
			list_destroy(te);
		}
		/* Next bit shouldn't be needed anymore TODO remove */
		if (rel && is_project(rel->op) && !outer) {
			node *n;
			list *exps = rel->exps;

			for (n = exps->h; n; n = n->next) {
				sql_exp *ce = n->data;

				if (ce->card > rel->card) {
					rel_destroy(rel);
					if (ce->type == e_column && ce->r) {
						return sql_error(sql, 02, "SELECT: cannot use non GROUP BY column '%s' in query results without an aggregate function", ce->r);
					} else {
						return sql_error(sql, 02, "SELECT: cannot use non GROUP BY column in query results without an aggregate function");
					}
				}
				if (rel->card != ce->card && ce->card != CARD_ATOM && card != CARD_ATOM) {
					rel_destroy(rel);
					return sql_error(sql, 02, "SELECT: single value in column expression");
				}
				/* fix card (needed for constants) */
				ce->card = rel->card;
			}
		}
	} else {
		/* select * from tables */

		if (aggr) {
			rel_destroy(rel);
			return sql_error(sql, 02, "SELECT: cannot combine '*' with GROUP BY");
		}

		if (toplevel && !is_project(rel->op)) {
			rel = rel_project(sql, rel, rel_projections(sql,rel, NULL, 1));
		} else {
			/* 
			 * subquery can only return one column
			 */
		}
	}

	if (rel)
		rel->processed = 1;
	if (rel && sn->distinct) 
		rel = rel_distinct(sql, rel);

	if (rel && sn->orderby) 
		rel = rel_order_by(sql, rel, sn->orderby);

	if (!rel) 
		return NULL;

	if (sn->limit > 0 || sn->offset > 0) {
		list *exps = new_exp_list();

		append(exps, exp_atom_int(sn->limit));
		if (sn->offset > 0)
			append(exps, exp_atom_int(sn->offset));
		rel = rel_topn(rel, exps);
	}
	return rel;
}


sql_rel *
rel_query(mvc *sql, sql_rel *rel, symbol *sq, int toplevel, int f)
{
	sql_rel *res = NULL, *left = NULL;
	SelectNode *sn = (SelectNode *) sq;

	assert(sn->s.token == SQL_SELECT);

	if (!toplevel && sn->limit >= 0)
		return sql_error(sql, 01, "SELECT: LIMIT only allowed on outermost SELECT");

	if (!toplevel && sn->orderby)
		return sql_error(sql, 01, "SELECT: ORDER BY only allowed on outermost SELECT");

	if (sn->from) {		/* keep variable list with tables and names */
		dlist *fl = sn->from->data.lval;
		dnode *n = NULL;
		sql_rel *fnd = NULL;

		for (n = fl->h; n ; n = n->next) {
			fnd = table_ref(sql, rel, n->data.sym);

			if (!fnd)
				break;
			if (res) 
				res = rel_crossproduct(res, fnd, op_join);
			else 
				res = fnd;
		}
		if (rel && !toplevel) {
			/* We need to make sure this sub query returns
			    one value per left relation (outer reference) */
			rel_setsubquery(res);
			left = res = rel_crossproduct(rel, res, op_join);
		}

		if (!fnd) {
			if (res)
				rel_destroy(res);
			return NULL;
		}

	} else if (toplevel) {	/* only on top level query */
		return rel_simple_select(sql, rel, sn->where, sn->selection);
	}
	if (res)
		rel = rel_select_exp(sql, res, rel, sn, toplevel);
	/* make sure no more expressions are pushed into the left joins */
	if (left && f >= sql_sel)  
		left->op = op_left;
	if (rel)
		rel_setsubquery(rel);
	return rel;
}

static sql_rel *
rel_setquery_(mvc *sql, sql_rel *l, sql_rel *r, dlist *cols, int op )
{
	sql_rel *rel;

	if (!cols) {
		node *n, *m;
		int changes = 0;

		list *ls = rel_projections(sql, l, NULL, 1);
		list *rs = rel_projections(sql, r, NULL, 1);
		list *nls = new_exp_list();
		list *nrs = new_exp_list();

		for (n = ls->h, m = rs->h; n && m; n = n->next, m = m->next) {
			sql_exp *le = exp_dup(n->data), *lb = le;
			sql_exp *re = exp_dup(m->data), *rb = re;

			if ((rel_convert_types(sql, &le, &re, 1, type_set) < 0)) {
				if (le)
					exp_destroy(le);
				if (re)
					exp_destroy(re);
				return NULL;
			}
			if (le != lb || re != rb)
				changes = 1;
			append(nls, le); 
			append(nrs, re); 
		}
		if (changes) {
			l = rel_project(sql, l, nls);
			r = rel_project(sql, r, nrs);
			l->processed = 1;
			r->processed = 1;
		} else {
			list_destroy(nls);
			list_destroy(nrs);
		}
	}
	rel = rel_setop(l, r, (operator_type)op);
	rel->exps = rel_projections(sql, rel, NULL, 0);
	rel->processed = 1;
	return rel;
}


static sql_rel *
rel_setquery(mvc *sql, sql_rel *rel, symbol *q)
{
	sql_rel *res = NULL;
	dnode *n = q->data.lval->h;
	symbol *tab_ref1 = n->data.sym;
	int dist = n->next->data.ival;
	dlist *corresponding = n->next->next->data.lval;
	symbol *tab_ref2 = n->next->next->next->data.sym;

	sql_rel *t1 = table_ref(sql, NULL, tab_ref1);
	sql_rel *t2 = table_ref(sql, NULL, tab_ref2);

	(void)rel; /* TODO coorelated unions */
	if (!t1 || !t2) 
		return NULL;

	if (list_length(t1->exps) != list_length(t2->exps)) {
		char *op = "UNION";
		if (q->token == SQL_EXCEPT)
			op = "EXCEPT";
		else if (q->token == SQL_INTERSECT)
			op = "INTERSECT";
		return sql_error(sql, 02, "%s: column counts (%d and %d) do not match", op, t1->nrcols, t2->nrcols);
	}
	if (t1 && dist) 
		t1 = rel_distinct(sql, t1);
	if ( q->token == SQL_UNION)
		if (t2 && dist) 
			t2 = rel_distinct(sql, t2);
		res = rel_setquery_(sql, t1, t2, corresponding, op_union );
		if (res && dist) 
			res = rel_distinct(sql, res);
	if ( q->token == SQL_EXCEPT)
		res = rel_setquery_(sql, t1, t2, corresponding, op_except );
	if ( q->token == SQL_INTERSECT)
		res = rel_setquery_(sql, t1, t2, corresponding, op_inter );
	return res;
}



static sql_rel *
rel_joinquery_(mvc *sql, sql_rel *rel, symbol *tab1, int natural, jt jointype, symbol *tab2, symbol *js)
{
	operator_type op = op_join;
	sql_rel *t1, *t2;

	t1 = table_ref(sql, rel, tab1);
	t2 = table_ref(sql, rel, tab2);

	if (!t1 || !t2)
		return NULL;

	if (strcmp(t1->name, t2->name) == 0) { 
		rel_destroy(t1);
		rel_destroy(t2);
		return sql_error(sql, 02, "SELECT: '%s' on both sides of the JOIN expression;", t1->name);
	}

	switch(jointype) {
	case jt_inner: op = op_join;
		break;
	case jt_left: op = op_left;
		break;
	case jt_right: op = op_right;
		break;
	case jt_full: op = op_full;
		break;
	case jt_union:
		/* fool compiler */
		return NULL;
	}
	rel = rel_crossproduct(t1, t2, op_join);

	if (js && natural) {
		return sql_error(sql, 02, "SELECT: cannot have a NATURAL JOIN with a join specification (ON or USING);");
	}
	if (!js && !natural) {
		return sql_error(sql, 02, "SELECT: must have NATURAL JOIN or a JOIN with a join specification (ON or USING);");
	}

	if (js && js->token != SQL_USING) {	/* On sql_logical_exp */
		rel = rel_logical_exp(sql, rel, js, sql_where);
	} else if (js) {	/* using */
		dnode *n = js->data.lval->h;

		for (; n; n = n->next) {
			char *nm = n->data.sval;

			sql_exp *ls = rel_bind_column(sql, t1, nm);
			sql_exp *rs = rel_bind_column(sql, t2, nm);

			if (!ls || !rs) {
				if (ls)
					exp_destroy(ls);
				if (rs)
					exp_destroy(rs);
				sql_error(sql, 02, "JOIN: tables '%s' and '%s' do not have a matching column '%s'\n", rel_get_name(t1), rel_get_name(t2), nm);
				rel_destroy(rel);
				return NULL;
			}
			rel = rel_compare_exp(sql, rel, ls, rs, "=", NULL, sql_where);
			if (!rel)
				return NULL;
		}
	} else {		/* ! js -> natural join */
		rel = join_on_column_name(sql, rel, t1, t2, 0);
	}
	if (!rel)
		return NULL;
	rel->op = op; 
	return rel;
}

static sql_rel *
rel_joinquery(mvc *sql, sql_rel *rel, symbol *q)
{

	dnode *n = q->data.lval->h;
	symbol *tab_ref1 = n->data.sym;
	int natural = n->next->data.ival;
	jt jointype = (jt) n->next->next->data.ival;
	symbol *tab_ref2 = n->next->next->next->data.sym;
	symbol *joinspec = n->next->next->next->next->data.sym;

	return rel_joinquery_(sql, rel, tab_ref1, natural, jointype, tab_ref2, joinspec);
}

static sql_rel *
rel_crossquery(mvc *sql, sql_rel *rel, symbol *q)
{
	dnode *n = q->data.lval->h;
	symbol *tab1 = n->data.sym;
	symbol *tab2 = n->next->data.sym;
	sql_rel *t1 = table_ref(sql, rel, tab1);
	sql_rel *t2 = table_ref(sql, rel, tab2);

	if (!t1 || !t2)
		return NULL;

	rel = rel_crossproduct(t1, t2, op_join);
	return rel;
}
	
static sql_rel *
rel_unionjoinquery(mvc *sql, sql_rel *rel, symbol *q)
{
	dnode *n = q->data.lval->h;
	sql_rel *lv = table_ref(sql, rel, n->data.sym);
	sql_rel *rv = table_ref(sql, rel, n->next->next->data.sym);
	int all = n->next->data.ival; 
	list *lexps, *rexps;
	node *m;
	int found = 0;

	if (!lv || !rv)
		return NULL;

 	lexps = rel_projections(sql, lv, NULL, 1);
	/* find the matching columns (all should match?)
	 * union these 
	 * if !all do a distinct operation at the end 
	 */
	/* join all result columns ie join(lh,rh) on column_name */
	rexps = new_exp_list();
	for (m = lexps->h; m; m = m->next) {
		sql_exp *lc = m->data;
		sql_exp *rc = rel_bind_column(sql, rv, lc->name);
			
		if (!rc && all) 
			break;
		if (rc) {
			found = 1;
			append(rexps, rc);
		}
	}
	if (!found) {
		list_destroy(lexps);
		list_destroy(rexps);
		rel_destroy(rel);
		return NULL;
	}
	lv = rel_project(sql, lv, lexps);
	rv = rel_project(sql, rv, rexps);
	rel = rel_setop(lv, rv, op_union);
	rel->exps = rel_projections(sql, rel, NULL, 0);
	if (!all)
		rel = rel_distinct(sql, rel);
	return rel;
}

static sql_rel *
rel_subquery(mvc *sql, sql_rel *rel, symbol *sq, int f)
{
	int toplevel = 0;

	if (!rel || (rel->op == op_project && 
		(!rel->exps || list_length(rel->exps) == 0)))
		toplevel = 1;

	return rel_query(sql, rel, sq, toplevel, f);
}

sql_rel *
rel_selects(mvc *sql, symbol *s)
{
	sql_rel *ret = NULL;

	switch (s->token) {
	case SQL_SELECT:
		ret = rel_subquery(sql, NULL, s, sql_from);
		sql->type = Q_TABLE;
		break;
	case SQL_JOIN:
		ret = rel_joinquery(sql, NULL, s);
		sql->type = Q_TABLE;
		break;
	case SQL_CROSS:
		ret = rel_crossquery(sql, NULL, s);
		sql->type = Q_TABLE;
		break;
	case SQL_UNION:
	case SQL_EXCEPT:
	case SQL_INTERSECT:
		ret = rel_setquery(sql, NULL, s);
		sql->type = Q_TABLE;
		break;
	default:
		return NULL;
	}
	if (mvc_debug_on(sql,32768)) {
		rel_print(sql, ret, 0);
		printf("\n");
	}
	if (!ret && sql->errstr[0] == 0)
		(void) sql_error(sql, 02, "relational query without result");
	return ret;
}
