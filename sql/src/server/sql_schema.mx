@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2007 CWI.
@' All Rights Reserved.

@f sql_schema
@a N.J. Nes
@* 

@h
#ifndef _SQL_SCHEMA_H_
#define _SQL_SCHEMA_H_

#include <stdio.h>
#include <stdarg.h>
#include <sql_list.h>
#include "sql_symbol.h"
#include "sql_statement.h"

extern stmt *schemas(mvc *sql, symbol *sym);
extern stmt *sql_create_table(mvc *sql, sql_schema *ss, int temp, dlist *qname, symbol *table_elements_or_subquery, int commit_action);

#endif /*_SQL_SCHEMA_H_*/

@c

#include "sql_config.h"
#include "sql_schema.h"
#include "sql_parser.h"
#include "sql_scope.h"
#include "sql_updates.h"
#include "sql_select.h"
#include "sql_semantic.h"
#include "sql_privileges.h"
#include "sql_psm.h"

static void
list_append_stmt(list *l, stmt *s)
{
	if (s->type == st_none) {
		stmt_destroy(s);
	} else {
		list_append(l, s);
	}
}

static stmt *
list2stmt(list *l)
{
	if (list_length(l) == 0) {
		list_destroy(l);
		return stmt_none();
	} else {
		return stmt_list(l);
	}

}

static stmt *
grant_roles(mvc *sql, sql_schema *schema, dlist *roles, dlist *grantees, int grant, int grantor)
{
	/* grant roles to the grantees */
	dnode *r, *g;

	(void) sql;
	(void) schema;
	(void) grant;
	(void) grantor;		/* Stefan: unused!? */

	for (r = roles->h; r; r = r->next) {
		char *role = r->data.sval;

		/*
		   role_id = relproject(relselect(auths, role),id);
		   exception(count(role_id) == 0), "Role %s not found !", role;
		 */
		for (g = grantees->h; g; g = g->next) {
			char *grantee = g->data.sval;

			/* 
			   grantee_id = relproject(relselect(auths,grantee),id);
			   exception (count(grantee_id) == 0), "User/role %s not found !", grantee;
			   r = relselect(role_user,role_id,grantee_id)
			   exception(count(r) > 0), "Role (%s,%s) already granted", role, grantee;
			   relinsert(role_user,role_id,grantee_id,grantor,grant);
			 */
			if (!sql_grant_role(sql, grantee, role)) 
				return sql_error(sql, 02, "GRANT: cannot grant ROLE '%s' to ROLE '%s'", grantee, role );
		}
	}
	return stmt_none();
}

static stmt *
revoke_roles(mvc *sql, sql_schema *schema, dlist *roles, dlist *grantees, int admin, int grantor)
{
	/* revoke roles from the grantees */
	dnode *r, *g;

	(void) schema;
	(void) admin;
	(void) grantor;		/* Stefan: unused!? */

	for (r = roles->h; r; r = r->next) {
		char *role = r->data.sval;

		for (g = grantees->h; g; g = g->next) {
			char *grantee = g->data.sval;

			if (sql_revoke_role(sql, grantee, role) == FALSE) 
				return sql_error(sql, 02, "REVOKE no such role '%s' or grantee '%s'", role, grantee);
		}
	}
	return stmt_none();
}

static stmt *
sql_insert_priv(mvc *sql, int auth_id, int obj_id, int privilege, int grantor, int grantable)
{
	sql_schema *ss = mvc_bind_schema(sql, "sys");
	sql_table *pt = mvc_bind_table(sql, ss, "privileges");
	node *n = pt->columns.set->h;
	stmt *res, **inserts = NEW_ARRAY(stmt *, 5);
	stmt *pts = stmt_basetable(pt, pt->base.name);

	inserts[0] = stmt_append(stmt_bat(n->data, stmt_dup(pts), INS), stmt_atom_int(obj_id));
	n = n->next;
	inserts[1] = stmt_append(stmt_bat(n->data, stmt_dup(pts), INS), stmt_atom_int(auth_id));
	n = n->next;
	inserts[2] = stmt_append(stmt_bat(n->data, stmt_dup(pts), INS), stmt_atom_int(privilege));
	n = n->next;
	inserts[3] = stmt_append(stmt_bat(n->data, stmt_dup(pts), INS), stmt_atom_int(grantor));
	n = n->next;
	inserts[4] = stmt_append(stmt_bat(n->data, stmt_dup(pts), INS), stmt_atom_int(grantable));
	stmt_destroy(pts);
	res = sql_insert(sql, pt, inserts, 5, 0);
	cleanup_stmts(inserts, 5);
	return res;
}

void
sql_insert_all_privs(mvc *sql, int auth_id, int obj_id, int grantor, int grantable, list *l)
{
	list_append(l, sql_insert_priv(sql, auth_id, obj_id, PRIV_SELECT, grantor, grantable));
	list_append(l, sql_insert_priv(sql, auth_id, obj_id, PRIV_UPDATE, grantor, grantable));
	list_append(l, sql_insert_priv(sql, auth_id, obj_id, PRIV_INSERT, grantor, grantable));
	list_append(l, sql_insert_priv(sql, auth_id, obj_id, PRIV_DELETE, grantor, grantable));
}

const char *
priv2string(int priv)
{
	switch (priv) {
	case PRIV_SELECT:
		return "SELECT";
	case PRIV_UPDATE:
		return "UPDATE";
	case PRIV_INSERT:
		return "INSERT";
	case PRIV_DELETE:
		return "DELETE";
	case PRIV_EXECUTE:
		return "EXECUTE";
	}
	return "UNKNOWN PRIV";
}

static stmt *
grant_table(mvc *sql, sql_schema *cur, dlist *privs, char *tname, dlist *grantees, int grant, int grantor)
{
	dnode *gn;
	sql_table *t = mvc_bind_table(sql, cur, tname);
	list *l;

	if (!t) {
		return sql_error(sql, 02, "GRANT no such table '%s'", tname);
	}

	l = create_stmt_list();
	if (privs == NULL) {	/* ALL [ PRIVILEGES ] */
		int all = PRIV_SELECT | PRIV_UPDATE | PRIV_INSERT | PRIV_DELETE;
		int allowed = schema_privs(grantor, t->s);

		if (!allowed)
			allowed = sql_grantable(sql, grantor, t->base.id, all, 0);

		if (!allowed) {
			list_destroy(l);
			return sql_error(sql, 02, "GRANTOR '%s' is not allowed to grant ALL privileges for table '%s'", stack_get_string(sql,"current_user"), tname);
		}

		for (gn = grantees->h; gn; gn = gn->next) {
			char *grantee = gn->data.sval;
			int grantee_id;

			if (grantee)
				grantee_id = sql_find_auth(sql, grantee);
			else
				grantee_id = sql_find_auth(sql, "public");

			if (grantee_id <= 0) {
				list_destroy(l);
				return sql_error(sql, 02, "user/role '%s' unknown", grantee);
			}
			sql_insert_all_privs(sql, grantee_id, t->base.id, grantor, grant, l);
		}
		return stmt_list(l);
	}
	for (gn = grantees->h; gn; gn = gn->next) {
		dnode *opn;
		char *grantee = gn->data.sval;
		int grantee_id;

		if (grantee)
			grantee_id = sql_find_auth(sql, grantee);
		else
			grantee_id = sql_find_auth(sql, "public");

		if (grantee_id < 0) {
			list_destroy(l);
			return sql_error(sql, 02, "user/role '%s' unknown", grantee);
		}

		for (opn = privs->h; opn; opn = opn->next) {
			symbol *op = opn->data.sym;
			int priv = PRIV_SELECT;

			switch (op->token) {
			case SQL_SELECT:
				priv = PRIV_SELECT;
				break;
			case SQL_UPDATE:
				priv = PRIV_UPDATE;
				break;

			case SQL_INSERT:
				priv = PRIV_INSERT;
				break;
			case SQL_DELETE:
				priv = PRIV_DELETE;
				break;

			case SQL_EXECUTE:
			default:
				list_destroy(l);
				return sql_error(sql, 02, "Cannot GRANT EXECUTE on table name %s", tname);
			}

			if ((op->token == SQL_SELECT || op->token == SQL_UPDATE) && op->data.lval) {
				dnode *cn;

				for (cn = op->data.lval->h; cn; cn = cn->next) {
					char *cname = cn->data.sval;
					sql_column *c = 0;

					int allowed = sql_grantable(sql,
								    grantor, t->s->base.id,
								    priv, 1);

					if (!allowed)
						allowed = sql_grantable(sql, grantor, t->base.id, priv, 1);

					if (!allowed)
						allowed = sql_grantable(sql, grantor, c->base.id, priv, 0);

					if (!allowed) {
						list_destroy(l);
						return sql_error(sql, 02, "GRANTOR %s is not allowed to grant privilege %s for table %s", stack_get_string(sql, "current_user"), priv2string(priv), tname);
					}

					c = mvc_bind_column(sql, t, cname);
					if (!c) {
						list_destroy(l);
						return sql_error(sql, 02, "Grant: table %s has no column %s", tname, cname);
					}
					list_append(l, sql_insert_priv(sql, grantee_id, c->base.id, priv, grantor, grant));
				}
			} else {
				int allowed = sql_grantable(sql, grantor,
							    t->s->base.id, priv, 1);

				if (!allowed)
					allowed = sql_grantable(sql, grantor, t->base.id, priv, 0);

				if (!allowed) {
					list_destroy(l);
					return sql_error(sql, 02, "GRANTOR %s is not allowed to grant privilege %s for table %s", stack_get_string(sql, "current_user"), priv2string(priv), tname);
				}

				list_append(l, sql_insert_priv(sql, grantee_id, t->base.id, priv, grantor, grant));
			}
		}
	}
	return stmt_list(l);
}

static stmt *
grant_func(mvc *sql, sql_schema *cur, dlist *privs, char *fname, dlist *grantees, int grant, int grantor)
{
/* todo */
	(void) sql;
	(void) cur;
	(void) privs;
	(void) fname;
	(void) grantees;
	(void) grant;
	(void) grantor;
	return sql_error(sql, 02, "GRANT Table/Function name %s doesn't exist", fname);
}


static stmt *
grant_privs(mvc *sql, sql_schema *cur, dlist *privs, dlist *grantees, int grant, int grantor)
{
	dlist *obj_privs = privs->h->data.lval;
	symbol *obj = privs->h->next->data.sym;
	int token = obj->token;

	if (token == SQL_NAME)
		if (mvc_bind_table(sql, cur, obj->data.sval) != NULL)
			token = SQL_TABLE;

	switch (token) {
	case SQL_TABLE:
		return grant_table(sql, cur, obj_privs, obj->data.sval, grantees, grant, grantor);
	case SQL_NAME:
		return grant_func(sql, cur, obj_privs, obj->data.sval, grantees, grant, grantor);
	default:
		return sql_error(sql, 02, "Grant: unknown token %d", token);
	}
	return sql_error(sql, 02, "Grant: unknown token %d", token);
}

static stmt *
sql_delete_priv(mvc *sql, int auth_id, int obj_id, int privilege, int grantor, int grantable)
{
	sql_schema *ss = mvc_bind_schema(sql, "sys");
	sql_table *pt = mvc_bind_table(sql, ss, "privileges");
	node *n = pt->columns.set->h;

	stmt *pts = stmt_basetable(pt, pt->base.name);
	stmt *s = stmt_relselect_init();
	scope *scp = scope_open(NULL);
	tvar *ptv = scope_add_table_columns(sql, scp, pt, pt->base.name, UPD);

	(void) grantor;
	(void) grantable;

	stmt_relselect_fill(s, stmt_uselect(stmt_bat(n->data, stmt_dup(pts), RDONLY), stmt_atom_int(auth_id), cmp_equal));
	n = n->next;
	stmt_relselect_fill(s, stmt_uselect(stmt_bat(n->data, stmt_dup(pts), RDONLY), stmt_atom_int(privilege), cmp_equal));
	n = n->next;
	stmt_relselect_fill(s, stmt_uselect(stmt_bat(n->data, stmt_dup(pts), RDONLY), stmt_atom_int(obj_id), cmp_equal));

	s = stmt_mark(stmt_reverse(s), 0);
	s = sql_delete(sql, ptv, ss, pt, s, 0, 0);
	scope_close(scp);
	return s;
}

static stmt *
revoke_table(mvc *sql, sql_schema *cur, dlist *privs, char *tname, dlist *grantees, int grant, int grantor)
{
	dnode *gn;
	sql_table *t = mvc_bind_table(sql, cur, tname);
	list *l;

	if (!t) {
		return sql_error(sql, 02, "REVOKE Table name %s doesn't exist", tname);
	}

	/* TODO 
	   if (grant)
	   do update !
	   if (grant)
	   return
	 */
	l = create_stmt_list();
	if (privs == NULL) {	/* ALL [ PRIVILEGES ] */
		for (gn = grantees->h; gn; gn = gn->next) {
			char *grantee = gn->data.sval;
			int grantee_id;
	
			if (grantee)
				grantee_id = sql_find_auth(sql, grantee);
			else
				grantee_id = sql_find_auth(sql, "public");

			if (grantee_id < 0) {
				list_destroy(l);
				return sql_error(sql, 02, "User/Role %s unknown", grantee);
			}

			list_append(l, sql_delete_priv(sql, grantee_id, t->base.id, PRIV_SELECT, grantor, grant));
			list_append(l, sql_delete_priv(sql, grantee_id, t->base.id, PRIV_UPDATE, grantor, grant));
			list_append(l, sql_delete_priv(sql, grantee_id, t->base.id, PRIV_INSERT, grantor, grant));
			list_append(l, sql_delete_priv(sql, grantee_id, t->base.id, PRIV_DELETE, grantor, grant));
		}
		return stmt_list(l);
	}
	for (gn = grantees->h; gn; gn = gn->next) {
		dnode *opn;
		char *grantee = gn->data.sval;
		int grantee_id;

		if (grantee)
			grantee_id = sql_find_auth(sql, grantee);
		else
			grantee_id = sql_find_auth(sql, "public");

		if (grantee_id < 0) {
			list_destroy(l);
			return sql_error(sql, 02, "User/Role %s unknown", grantee);
		}

		for (opn = privs->h; opn; opn = opn->next) {
			symbol *op = opn->data.sym;
			int priv = PRIV_SELECT;

			switch (op->token) {
			case SQL_SELECT:
				priv = PRIV_SELECT;
				break;
			case SQL_UPDATE:
				priv = PRIV_UPDATE;
				break;

			case SQL_INSERT:
				priv = PRIV_INSERT;
				break;
			case SQL_DELETE:
				priv = PRIV_DELETE;
				break;

			case SQL_EXECUTE:
			default:
				list_destroy(l);
				return sql_error(sql, 02, "Cannot GRANT EXECUTE on table name %s", tname);
			}

			if ((op->token == SQL_SELECT || op->token == SQL_UPDATE) && op->data.lval) {
				dnode *cn;

				for (cn = op->data.lval->h; cn; cn = cn->next) {
					char *cname = cn->data.sval;
					sql_column *c;

					c = mvc_bind_column(sql, t, cname);
					if (!c) {
						list_destroy(l);
						return sql_error(sql, 02, "Grant: table %s has no column %s", tname, cname);
					}
					list_append(l, sql_delete_priv(sql, grantee_id, c->base.id, priv, grantor, grant));
				}
			} else {
				list_append(l, sql_delete_priv(sql, grantee_id, t->base.id, priv, grantor, grant));
			}
		}
	}
	return stmt_list(l);
}

static stmt *
revoke_func(mvc *sql, sql_schema *cur, dlist *privs, char *fname, dlist *grantees, int grant, int grantor)
{
/* todo */
	(void) sql;
	(void) cur;
	(void) privs;
	(void) fname;
	(void) grantees;
	(void) grant;
	(void) grantor;
	return NULL;
}

static stmt *
revoke_privs(mvc *sql, sql_schema *cur, dlist *privs, dlist *grantees, int grant, int grantor)
{
	dlist *obj_privs = privs->h->data.lval;
	symbol *obj = privs->h->next->data.sym;
	int token = obj->token;

	if (token == SQL_NAME)
		if (mvc_bind_table(sql, cur, obj->data.sval) != NULL)
			token = SQL_TABLE;

	switch (token) {
	case SQL_TABLE:
		return revoke_table(sql, cur, obj_privs, obj->data.sval, grantees, grant, grantor);
	case SQL_NAME:
		return revoke_func(sql, cur, obj_privs, obj->data.sval, grantees, grant, grantor);
	default:
		return sql_error(sql, 02, "Grant: unknown token %d", token);
	}
	return NULL;
}


static stmt *
create_type(mvc *sql, dlist *qname, char *impl)
{
	char *tname = qname_table(qname);

	if (!mvc_create_type(sql, sql->session->schema, tname, 0, 0, 0, impl)) {
		if (impl)
			return sql_error(sql, 02, "CREATE TYPE: unknown external type '%s'", impl);
		return NULL;
	}
	return stmt_none();
}

static stmt *
create_trigger(mvc *sql, dlist *qname, int time, symbol *trigger_event, 
	char *table_name, dlist *opt_ref, dlist *triggered_action)
{
	stmt *sq = NULL;
	list *col_l = NULL, *func_l= NULL, *view_id_l = NULL;
	scope *scp = scope_open(NULL);
	sql_trigger *trigger;
	char *tname = qname_table(qname);
	sql_schema *ss = cur_schema(sql);
	sql_table *t = NULL;
	int instantiate = (sql->mode == m_execute);

	int event = (trigger_event->token == SQL_INSERT)?0:
			  (trigger_event->token == SQL_DELETE)?1:2;
	dlist *columns = trigger_event->data.lval;
	char *old_name = NULL, *new_name = NULL; 
	int orientation = triggered_action->h->data.ival;
	char *condition = triggered_action->h->next->data.sval;
	dlist *stmts = triggered_action->h->next->next->data.lval;
	
	if (opt_ref) {
		dnode *dl = opt_ref->h;
		for ( ; dl; dl = dl->next) {
			/* list (new(1)/old(0)), char */
			char *n = dl->data.lval->h->next->data.sval;

			if (!dl->data.lval->h->data.ival) 
				old_name = n;
			else
				new_name = n;
		}
	}
	if (!instantiate && !schema_privs(sql->role_id, ss)) 
		return sql_error(sql, 02, "CREATE TRIGGER: access denied for %s to schema ;'%s'", stack_get_string(sql, "current_user"), ss->base.name);
	if ((trigger = mvc_bind_trigger(sql, ss, tname )) != NULL && !instantiate) 
		return sql_error(sql, 02, "CREATE TRIGGER: name '%s' already in use", tname);
	
	if (!instantiate && !(t = mvc_bind_table(sql, ss, table_name)))
		return sql_error(sql, 02, "CREATE TRIGGER: unknown table '%s'", table_name);
	if (!instantiate && isView(t)) 
		return sql_error(sql, 02, "CREATE TRIGGER: cannot create trigger on view '%s'", tname);
	
	
	if (!instantiate) {
		char *q = QUERY(sql->scanner);
		trigger = mvc_create_trigger(sql, t, tname, time, orientation, 
			event, old_name, new_name, condition, q);
	}
	sq = sequential_block(sql, scp, NULL, stmts, NULL);
	
	if (sq && !instantiate) {
		col_l = stmt_list_dependencies(sq, COLUMN_DEPENDENCY);
		func_l = stmt_list_dependencies(sq, FUNC_DEPENDENCY);
		view_id_l = stmt_list_dependencies(sq, VIEW_DEPENDENCY);

		mvc_create_dependencies(sql, col_l, trigger->base.id, TRIGGER_DEPENDENCY);
		mvc_create_dependencies(sql, func_l, trigger->base.id, TRIGGER_DEPENDENCY);
		mvc_create_dependencies(sql, view_id_l, trigger->base.id, TRIGGER_DEPENDENCY);

		list_destroy(col_l);
		list_destroy(func_l);
		list_destroy(view_id_l);
		stmt_destroy(sq);
		sq = NULL;
	}
	scope_close(scp);
	
	/* todo trigger_columns */
	(void)columns;

	if (instantiate)
		return sq;
	return stmt_none();
}

static stmt *
drop_trigger(mvc *sql, dlist *qname)
{
	char *tname = qname_table(qname);
	sql_schema *ss = cur_schema(sql);
	sql_trigger * t= NULL;

	if (!schema_privs(sql->role_id, ss)) 
		return sql_error(sql, 02, "DROP TRIGGER: access denied for %s to schema ;'%s'", stack_get_string(sql, "current_user"), ss->base.name);
	if ((t = mvc_bind_trigger(sql, ss, tname )) == NULL)
		return sql_error(sql, 02, "DROP TRIGGER: unknown trigger %s\n", tname);
	mvc_drop_trigger(sql, ss, tname);
	return stmt_none();
}

static stmt *
connect_catalog(mvc *sql, dlist *qname)
{
	char *server = qname->h->data.sval;
	int id = -1, port = qname->h->next->data.ival;
	char *db = qname->h->next->next->data.sval;
	char *db_alias = qname->h->next->next->next->data.sval;
	symbol *user_symb = qname->h->next->next->next->next->data.sym;
	char *user = NULL, *passwd = NULL;
	char *lang = qname->h->next->next->next->next->next->data.sval;
	char default_dbalias[BUFSIZ], default_lang[BUFSIZ];

	user = user_symb->data.lval->h->data.sval;
	passwd = user_symb->data.lval->h->next->data.sval;
	
	if (db_alias == NULL){
		snprintf(default_dbalias, BUFSIZ, "%s_%s_%s", server, db, user);
		db_alias = GDKstrdup(default_dbalias);
	}

	if (lang == NULL){
		snprintf(default_lang, BUFSIZ, "sql");
		lang = default_lang;
	}
	
	id = mvc_connect_catalog(sql, server, port, db, db_alias, user, passwd, lang);
	
	if (id == 0)	
		return sql_error(sql, 02, "CONNECT TO: this connection already exists or the db_alias '%s' was already used!", db_alias);
	
	return stmt_connection(&id, server, &port, db, db_alias, user, passwd, lang);	
}

static stmt *
disconnect_catalog(mvc *sql, dlist *qname)
{
	int id = 0, port = -1;
	char *db_alias = NULL;
	
	if (qname->cnt != 0) {
		db_alias = qname->h->data.sval;
	
		id = mvc_disconnect_catalog(sql, db_alias);

		if (id == 0)	
			return sql_error(sql, 02, "DISCONNECT CATALOG: no such db_alias '%s'", db_alias);
		else
			return stmt_connection(&id, NULL, &port, NULL, db_alias, NULL, NULL, NULL);	
	} else {
		mvc_disconnect_catalog_ALL(sql);	
		return stmt_connection(&id, NULL, &port, NULL, NULL, NULL, NULL, NULL);	
	}
}

static void
as_subquery( mvc *sql, sql_table *t, stmt *sq, dlist *column_spec )
{
	if (column_spec) {
		dnode *n = column_spec->h;
		node *m = sq->op1.lval->h;

		for (; n; n = n->next, m = m->next) {
			char *cname = n->data.sval;
			stmt *st = m->data;
			sql_subtype *tp = tail_type(st);

			mvc_create_column(sql, t, cname, tp);
		}
	} else {
		node *m;

		for (m = sq->op1.lval->h; m; m = m->next) {
			stmt *st = m->data;
			char *cname = column_name(st);
			sql_subtype *tp = tail_type(st);

			mvc_create_column(sql, t, cname, tp);
			_DELETE(cname);
		}
	}
}

static stmt *
view_rename_columns( char *name, stmt *sq, dlist *column_spec)
{
	dnode *n = column_spec->h;
	node *m = sq->op1.lval->h;
	list *l = create_stmt_list();

	for (; n && m; n = n->next, m = m->next) {
		char *cname = n->data.sval;
		stmt *st = stmt_dup(m->data);

		st = stmt_alias(st, _strdup(name), _strdup(cname));
		list_append(l, st);
	}
	stmt_destroy(sq);
	if (n || m) {
		list_destroy(l);
		return NULL;
	}
	return stmt_list(l);
}

static stmt *
create_view(mvc *sql, sql_schema *ss, dlist *qname, dlist *column_spec, symbol *query, int check, int persistent)
{
	char *name = qname_table(qname);
	char *sname = qname_schema(qname);
	sql_schema *s = NULL;
	sql_table *t = NULL;
	list * id_l = NULL, *view_id_l = NULL;
	int instantiate = (sql->mode == m_execute || !persistent);

	if (sname && !(s = mvc_bind_schema(sql, sname)))
		return sql_error(sql, 02, "CREATE VIEW: no such schema '%s'", sname);

	if (s == NULL)
		s = ss;

	(void) check;		/* Stefan: unused!? */

	if ((t = mvc_bind_table(sql, s, name)) != NULL && !instantiate) {
		return sql_error(sql, 02, "CREATE VIEW: name '%s' already in use", name);
	} else if (!instantiate && !schema_privs(sql->role_id, s)) {
		return sql_error(sql, 02, "CREATE VIEW: access denied for %s to schema ;'%s'", stack_get_string(sql, "current_user"), s->base.name);
	} else if (query) {
		exp_kind ek = {type_value, card_relation, TRUE};
		stmt *sq = NULL;
		char *q = QUERY(sql->scanner);

		if (query->token == SQL_SELECT) {
			SelectNode *sn = (SelectNode *) query;

			if (sn->limit >= 0)
				return sql_error(sql, 01, "CREATE VIEW: LIMIT not supported");
			if (sn->orderby)
				return sql_error(sql, 01, "CREATE VIEW: ORDER BY not supported");
		}

		sql->depth++;
		if (sql->depth > SQL_MAXDEPTH)
			return sql_error(sql, 02, "CREATE VIEW: too many nested VIEWS");
		sq = scope_subquery(sql, NULL, query, ek );
		sql->depth--;
		if (!sq)
			return NULL;

		if (!instantiate) {
			t = mvc_create_view(sql, s, name, q, 0);
			as_subquery( sql, t, sq, column_spec );
		}
		if (!persistent && column_spec) 
			sq = view_rename_columns( name, sq, column_spec);
		if (!instantiate && sq) {
			view_id_l = stmt_list_dependencies(sq, VIEW_DEPENDENCY);
			id_l = stmt_list_dependencies(sq, COLUMN_DEPENDENCY);
			mvc_create_dependencies(sql, id_l, t->base.id, VIEW_DEPENDENCY);
			mvc_create_dependencies(sql, view_id_l, t->base.id, VIEW_DEPENDENCY);
			list_destroy(id_l);
			list_destroy(view_id_l);
			stmt_destroy(sq);
			return stmt_none();
		}
		return sq;
	}
	return NULL;
}

static stmt *
drop_view(mvc *sql, dlist *qname, int drop_action)
{
	char *tname = qname_table(qname);
	char *sname = qname_schema(qname);
	sql_table *t = NULL;
	sql_schema *ss = NULL;

	if (sname != NULL && (ss = mvc_bind_schema(sql, sname)) == NULL)
		return sql_error(sql, 02, "DROP VIEW: no such schema '%s'", sname);

	if (ss == NULL)
		ss = cur_schema(sql);

	t = mvc_bind_table(sql, ss, tname);

	if (!schema_privs(sql->role_id, ss)) {  
		return sql_error(sql, 02, "DROP VIEW: access denied for %s to schema '%s'", stack_get_string(sql, "current_user"), ss->base.name);
	} else if (!t) {
		return sql_error(sql, 02, "DROP VIEW: unknown view '%s'", tname);
	} else if (!isView(t)) {
		return sql_error(sql, 02, "DROP VIEW: unable to drop view '%s'", tname);
	} else if (t->system) {
		return sql_error(sql, 02, "DROP VIEW: cannot drop system view '%s'", tname);
	} else if (! drop_action && mvc_check_dependency(sql, t->base.id, VIEW_DEPENDENCY)) {
			return sql_error(sql, 02, "unable to drop view %s (there are database objects which depend on it)\n", t->base.name);
	} else {
		mvc_drop_table(sql, ss, t->base.name, drop_action);
		return stmt_none();
	}
}

static stmt *
create_index(mvc *sql, sql_schema *ss, char *iname, int itype, dlist *qname, dlist *column_list)
{

	char *name = qname_table(qname);
	sql_idx *i = mvc_bind_idx(sql, ss, iname);

	sql_table *t = mvc_bind_table(sql, ss, name);

	if (i) {
		return sql_error(sql, 02, "CREATE INDEX: name '%s' already in use", iname);
	} else if (!t) {
		return sql_error(sql, 02, "CREATE INDEX: no such table '%s'", name);
	} else if (isView(t)) {
		return sql_error(sql, 02, "CREATE INDEX: cannot create index on view '%s'", name);
	} else {
		dnode *n = column_list->h;
		sql_idx *i = mvc_create_idx(sql, t, iname, (idx_type) itype);

		if (!i) {
			/* Fabian: I doubt whether this error can be triggered since
			 * the more generic case is already checked above. */
			return sql_error(sql, 02, "CREATE INDEX: index '%s' already exists", iname);
		}
		for (; n; n = n->next) {
			char *cname = n->data.sval;
			sql_column *c = mvc_bind_column(sql, t, cname);

			if (!c) {
				return sql_error(sql, 02, "CREATE INDEX: no such column '%s'", cname);
			} else {
				mvc_create_ic(sql, i, c);
				mvc_create_dependency(sql, c->base.id, i->base.id, INDEX_DEPENDENCY);
			}
		}
		return stmt_none();
	}
	return NULL;
}

static stmt *
drop_index(mvc *sql, dlist *qname)
{
	stmt *res = NULL;
	char *iname = qname_table(qname);
	sql_schema *ss = cur_schema(sql);

	sql_idx *i = mvc_bind_idx(sql, ss, iname);

	if (!schema_privs(sql->role_id, ss)) 
		return sql_error(sql, 02, "DROP INDEX: access denied for %s to schema ;'%s'", stack_get_string(sql, "current_user"), ss->base.name);
	if (!i) {
		return sql_error(sql, 02, "DROP INDEX: no such index '%s'", iname);
	} else {
		mvc_drop_idx(sql, ss, i->base.name);
		res = stmt_none();
	}
	return res;
}

static stmt *
create_user(mvc *sql, char *user, char *passwd, char *fullname, char *schema)
{
	char *err; 
	int schema_id = 0;
	list *l;

	if (backend_find_user(sql, user) >= 0) {
		return sql_error(sql, 02, "CREATE USER: user '%s' already exists", user);
	}
	if ((schema_id = sql_find_schema(sql, schema)) < 0) {
		return sql_error(sql, 02, "CREATE USER: no such schema '%s'", schema);
	}
	l = create_stmt_list();
	if ((err = backend_create_user(l, user, passwd, fullname,
					schema_id, sql->user_id)) != NULL)
	{
		(void) sql_error(sql, 02, "CREATE USER: %s", err);
		GDKfree(err);
		return FALSE;
	}

	return stmt_list(l);
}

static stmt *
drop_user(mvc *sql, char *user)
{
	int user_id = sql_find_auth(sql, user);
	if (mvc_check_dependency(sql, user_id, OWNER_DEPENDENCY))
		return sql_error(sql, 02, "DROP USER: '%s' owns a schema", user);

	if(sql_drop_user(sql, user) == FALSE)
		return sql_error(sql, 02, "DROP USER: no such user '%s'", user);

	return stmt_none();
}

static stmt *
alter_user(mvc *sql, char *user, char *passwd, char *schema)
{
	sqlid schema_id = 0;
	if (backend_find_user(sql, user) < 0)
		return sql_error(sql, 02, "ALTER USER: no such user '%s'", user);

	if (sql->user_id != USER_MONETDB && sql->role_id != ROLE_SYSADMIN && strcmp(user, stack_get_string(sql, "current_user")) != 0)
		return sql_error(sql, 02, "ALTER USER: insufficient privileges to change password for user '%s'", user);
	if (schema && (schema_id = sql_find_schema(sql, schema)) < 0) {
		return sql_error(sql, 02, "ALTER USER: no such schema '%s'", schema);
	}
	sql_alter_user(sql, user, passwd, schema_id);

	return stmt_none();
}


static stmt *
create_role(mvc *sql, dlist *qname, int grantor)
{
	char *role_name = qname->t->data.sval;

	if (dlist_length(qname) > 2) {
		return sql_error(sql, 02, "CREATE ROLE: qualified role can only have a schema and a role\n");
	}
	sql_create_role(sql, role_name, grantor);
	return stmt_none();
}

static stmt *
drop_role(mvc *sql, dlist *qname)
{
	char *role_name = qname->t->data.sval;

	if (dlist_length(qname) > 2) {
		return sql_error(sql, 02, "DROP ROLE: qualified role can only have a schema and a role\n");
	}
	sql_drop_role(sql, role_name);
	return stmt_none();
}

static int
column_constraint_type(mvc *sql, char *name, symbol *s, sql_schema *ss, sql_table *t, sql_column *cs, int alter, list **sl)
{
	int res = SQL_ERR;

	switch (s->token) {
		case SQL_UNIQUE:
		case SQL_PRIMARY_KEY:
			{
				key_type kt = (s->token == SQL_UNIQUE) ? ukey : pkey;
				sql_key *k;

				if (kt == pkey && t->pkey) {
					(void) sql_error(sql, 02, "CONSTRAINT PRIMARY KEY: a table can have only one PRIMARY KEY\n");
					return res;
				}
				if (name && mvc_bind_key(sql, ss, name)) {
					(void) sql_error(sql, 02, "CONSTRAINT PRIMARY KEY: key %s already exists", name);
					return res;
				}
				k = mvc_create_ukey(sql, t, name, kt);

				mvc_create_kc(sql, k, cs);
				res = SQL_OK;
				if (alter) {
					stmt *s;
					list *l = create_stmt_list();

					s = sql_insert_add_idx(sql, t, k->idx, l);
					if (!(*sl))
						*sl = create_stmt_list();
					list_append(*sl, s);
				}
			}
			break;
		case SQL_FOREIGN_KEY:
			{
				dnode *n = s->data.lval->h;
				char *rtname = qname_table(n->data.lval);
				char *rcname = n->next->data.lval->h->data.sval;
				int ref_actions = n->next->next->next->data.ival; 
				sql_fkey *fk;
				list *cols;
				sql_table *rt = mvc_bind_table(sql, cur_schema(sql), rtname);
				sql_key *rk;

				if (!rt) {
					(void) sql_error(sql, 02, "CONSTRAINT FOREIGN KEY: no such table table '%s'\n", rtname);
					return res;
				}
				if (name && mvc_bind_key(sql, ss, name)) {
					(void) sql_error(sql, 02, "CONSTRAINT PRIMARY KEY: key %s already exists", name);
					return res;
				}

				cols = list_append(list_create(NULL), rcname);
				rk = mvc_bind_ukey(rt, cols);
				list_destroy(cols);
				if (!rk) {
					(void) sql_error(sql, 02, "CONSTRAINT FOREIGN KEY: could not find referenced PRIMARY KEY in table %s.%s\n", rtname, rcname);
					return res;
				}
				fk = mvc_create_fkey(sql, t, name, fkey, rk, ref_actions & 255, (ref_actions>>8) & 255);
				mvc_create_fkc(sql, fk, cs);
				res = SQL_OK;
				if (alter) {
					stmt *s;
					list *l = create_stmt_list();

					s = sql_insert_add_idx(sql, t, ((sql_key *) fk)->idx, l);
					if (!(*sl))
						*sl = create_stmt_list();
					list_append(*sl, s);
				}
			}
			break;
		case SQL_NOT_NULL:
		case SQL_NULL:
			{
				int null = (s->token == SQL_NOT_NULL) ? 0 : 1;

				mvc_null(sql, cs, null);
				res = SQL_OK;
			}
			break;
	}

	if (res == SQL_ERR) {
		(void) sql_error(sql, 02, "unknown constraint (%ld)->token = %s\n", (long) s, token2string(s->token));
	}
	return res;
}

/* 
column_option: default | column_constraint ;
*/

static char *
table_constraint_name(symbol *s, sql_table *t)
{
	/* create a descriptive name like table_col_pkey */
	char *suffix;		/* stores the type of this constraint */
	dnode *nms = NULL;
	static char buf[BUFSIZ];

	switch (s->token) {
		case SQL_UNIQUE:
			suffix = "_unique";
			nms = s->data.lval->h;	/* list of columns */
			break;
		case SQL_PRIMARY_KEY:
			suffix = "_pkey";
			nms = s->data.lval->h;	/* list of columns */
			break;
		case SQL_FOREIGN_KEY:
			suffix = "_fkey";
			nms = s->data.lval->h->next->data.lval->h;	/* list of colums */
			break;
		default:
			suffix = "_?";
			nms = NULL;
	}

	/* copy table name */
	strncpy(buf, t->base.name, BUFSIZ);

	/* add column name(s) */
	for (; nms; nms = nms->next) {
		strncat(buf, "_", BUFSIZ - strlen(buf));
		strncat(buf, nms->data.sval, BUFSIZ - strlen(buf));
	}

	/* add suffix */
	strncat(buf, suffix, BUFSIZ - strlen(buf));

	return buf;
}

static char *
column_constraint_name(symbol *s, sql_column *sc, sql_table *t)
{
	/* create a descriptive name like table_col_pkey */
	char *suffix;		/* stores the type of this constraint */
	static char buf[BUFSIZ];

	switch (s->token) {
		case SQL_UNIQUE:
			suffix = "unique";
			break;
		case SQL_PRIMARY_KEY:
			suffix = "pkey";
			break;
		case SQL_FOREIGN_KEY:
			suffix = "fkey";
			break;
		default:
			suffix = "?";
	}

	snprintf(buf, BUFSIZ, "%s_%s_%s", t->base.name, sc->base.name, suffix);

	return buf;
}


static int
column_option(
		mvc *sql,
		symbol *s,
		sql_schema *ss,
		sql_table *t,
		sql_column *cs,
		int alter,
		list **sl)
{
	int res = SQL_ERR;

	assert(cs);
	switch (s->token) {
		case SQL_CONSTRAINT:
		{
			dlist *l = s->data.lval;
			char *opt_name = l->h->data.sval;
			symbol *sym = l->h->next->data.sym;

			if (!opt_name)
				opt_name = column_constraint_name(sym, cs, t);
			res = column_constraint_type(sql, opt_name, sym, ss, t, cs, alter, sl);
		}
		break;
		case SQL_DEFAULT:
		{
			char *r;
			exp_kind ek = {type_value, card_value, FALSE};
			stmt *tmp = sql_value_exp(sql, NULL, s->data.sym, NULL, NULL, sql_sel, ek);

			if (!tmp || (tmp = check_types(sql, &cs->type, tmp, type_equal)) == NULL) 
				return SQL_ERR;
			stmt_destroy(tmp);

			r = symbol2string(sql, s->data.sym);
			mvc_default(sql, cs, r);
			_DELETE(r);
			res = SQL_OK;
		}
		break;
		case SQL_ATOM:
		{
			AtomNode *an = (AtomNode *) s;

			if (!an || !an->a) {
				mvc_default(sql, cs, NULL);
			} else {
				atom *a = an->a;

				if (a->data.vtype == TYPE_str) {
					mvc_default(sql, cs, a->data.val.sval);
				} else {
					char *r = atom2string(a);

					mvc_default(sql, cs, r);
					_DELETE(r);
				}
			}
			res = SQL_OK;
		}
		break;
		case SQL_NOT_NULL:
		case SQL_NULL:
		{
			int null = (s->token == SQL_NOT_NULL) ? 0 : 1;

			mvc_null(sql, cs, null);
			res = SQL_OK;
		}
		break;
	}
	if (res == SQL_ERR) {
		(void) sql_error(sql, 02, "unknown column option (%ld)->token = %s\n", (long) s, token2string(s->token));
	}
	return res;
}

static int
column_options(mvc *sql, dlist *opt_list, sql_schema *ss, sql_table *t, sql_column *cs, int alter, list **sl)
{
	assert(cs);

	if (opt_list) {
		dnode *n = NULL;

		for (n = opt_list->h; n; n = n->next) {
			int res = column_option(sql, n->data.sym, ss, t, cs, alter, sl);

			if (res == SQL_ERR)
				return SQL_ERR;
		}
	}
	return SQL_OK;
}

static stmt *
create_column(mvc *sql, symbol *s, sql_schema *ss, sql_table *t, int alter)
{
	dlist *l = s->data.lval;
	char *cname = l->h->data.sval;
	sql_subtype *ctype = &l->h->next->data.typeval;
	dlist *opt_list = NULL;
	stmt *res = NULL;

	if (l->h->next->next)
		opt_list = l->h->next->next->data.lval;

	if (cname && ctype) {
		list *sl = NULL;
		sql_column *cs = NULL;

		cs = find_sql_column(t, cname);
		if (cs) 
			return sql_error(sql, 02, "%s TABLE: A with name '%s' already exists\n", (alter)?"ALTER":"CREATE", cname);

		cs = mvc_create_column(sql, t, cname, ctype);
		if (column_options(sql, opt_list, ss, t, cs, alter, &sl) == SQL_ERR) {
			if (sl) 
				list_destroy(sl);
			return NULL;
		}
		if (alter) {
			atom *a = NULL;

			if (!cs->null && !cs->def) {
				return sql_error(sql, 02, "CREATE TABLE: column default value is NULL, but column has NOT NULL constraint\n");
			}
			if (cs->null && !cs->def) {
				a = atom_general(&cs->type, NULL, 0);
				if (a)
					res = stmt_append(stmt_bat(cs, stmt_basetable(t, t->base.name), INS), stmt_const(stmt_bat(mvc_first_column(sql, t), stmt_basetable(t, t->base.name), RDONLY), stmt_atom(a)));
			} else {
				stmt *sq, *val;
				char buf[BUFSIZ];

				snprintf(buf, BUFSIZ, "select %s;", cs->def);
				sq = scope_sqlparse(sql, NULL, buf, sql->mode);
				if (!sq || sq->type != st_list || list_length(sq->op1.lval) != 1) {
					cond_stmt_destroy(sq);
					return NULL;
				}
				val = stmt_dup(sq->op1.lval->h->data);
				val = check_types(sql, &cs->type, val, type_equal);
				if (!val) {
					stmt_destroy(sq);
					return NULL;
				}
				stmt_destroy(sq);
				/* default could be a function such as 
				   next value for, this should be called once
				   foreach new value.
				*/
				res = stmt_append(stmt_bat(cs, stmt_basetable(t, t->base.name), INS), push_project(stmt_bat(mvc_first_column(sql, t), stmt_basetable(t, t->base.name), RDONLY), val));
			}
			if (!res) {
				return sql_error(sql, 02, "ALTER TABLE: failed to create default value '%s'\n", cs->def ? cs->def : "NULL");
			}
		}
		if (sl && res) {
			list_append(sl, res);
			res = stmt_list(sl);
		}
		if (!res)
			res = stmt_none();
	}

	if (!res)
		return sql_error(sql, 02, "CREATE: column type or name");
	return res;
}

static stmt *
table_foreign_key(mvc *sql, char *name, symbol *s, sql_schema *ss, sql_table *t, int alter)
{
	stmt *res = NULL;
	dnode *n = s->data.lval->h;
	char *rtname = qname_table(n->data.lval);
	sql_table *ft = mvc_bind_table(sql, ss, rtname);

	if (!ft) {
		return sql_error(sql, 02, "CONSTRAINT FOREIGN KEY: no such table '%s'\n", rtname);
	} else {
		sql_key *rk = NULL;
		sql_fkey *fk;
		dnode *nms = n->next->data.lval->h;
		node *fnms;
		int ref_actions = n->next->next->next->next->data.ival;

		if (name && mvc_bind_key(sql, ss, name)) {
			return sql_error(sql, 02, "Create Key failed, key %s allready exists", name);
		}
		if (n->next->next->data.lval) {	/* find unique referenced key */
			dnode *rnms = n->next->next->data.lval->h;
			list *cols = list_create(NULL);

			for (; rnms; rnms = rnms->next)
				list_append(cols, rnms->data.sval);

			/* find key in ft->keys */
			rk = mvc_bind_ukey(ft, cols);
			list_destroy(cols);
		} else {	/* no list of columns to find referenced unique key ie
				   use ft.pkey */
			rk = &ft->pkey->k;
		}
		if (!rk) {
			return sql_error(sql, 02, "CONSTRAINT FOREIGN KEY: could not find referenced PRIMARY KEY in table '%s'\n", ft->base.name);
		}
		fk = mvc_create_fkey(sql, t, name, fkey, rk, ref_actions & 255, (ref_actions>>8) & 255);

		for (fnms = rk->columns->h; nms && fnms; nms = nms->next, fnms = fnms->next) {
			char *nm = nms->data.sval;
			sql_column *c = mvc_bind_column(sql, t, nm);

			if (!c) {
				return sql_error(sql, 02, "CONSTRAINT FOREIGN KEY: no such column '%s' in table '%s'\n", nm, t->base.name);
			}
			mvc_create_fkc(sql, fk, c);
		}
		if (nms || fnms) {
			return sql_error(sql, 02, "CONSTRAINT FOREIGN KEY: not all columns are handled\n");
		}
		if (alter) {
			list *l = create_stmt_list();

			res = sql_insert_add_idx(sql, t, ((sql_key *) fk)->idx, l);
		} else {
			res = stmt_none();
		}
	}
	return res;
}

static stmt *
table_constraint_type(mvc *sql, char *name, symbol *s, sql_schema *ss, sql_table *t, int alter)
{
	stmt *res = NULL;

	if (!isTable(t)) {
		return sql_error(sql, 02, "ALTER TABLE: cannot add constraint to VIEW '%s'\n", t->base.name);
	}
	switch (s->token) {
		case SQL_UNIQUE:
		case SQL_PRIMARY_KEY:
		{
			key_type kt = (s->token == SQL_PRIMARY_KEY ? pkey : ukey);
			dnode *nms = s->data.lval->h;
			sql_key *k;

			if (kt == pkey && t->pkey) 
				return sql_error(sql, 02, "CONSTRAINT PRIMARY KEY: a table can have only one PRIMARY KEY\n");
			if (name && mvc_bind_key(sql, ss, name)) 
				return sql_error(sql, 02, "CONSTRAINT PRIMARY KEY: key %s already exists", name);
			
 			k = mvc_create_ukey(sql, t, name, kt);
			for (; nms; nms = nms->next) {
				char *nm = nms->data.sval;
				sql_column *c = mvc_bind_column(sql, t, nm);

				if (!c) {
					return sql_error(sql, 02, "no such column '%s' for table '%s'\n", nm, t->base.name);
				}
				(void) mvc_create_kc(sql, k, c);
			}
			if (alter) {
				list *l = create_stmt_list();

				res = sql_insert_add_idx(sql, t, k->idx, l);
			} else {
				res = stmt_none();
			}
		}
		break;
		case SQL_FOREIGN_KEY:
			res = table_foreign_key(sql, name, s, ss, t, alter);
			break;
	}
	if (!res) {
		return sql_error(sql, 02, "table constraint type: wrong token (%ld) = %s\n", (long) s, token2string(s->token));
	}
	return res;
}

static stmt *
table_constraint(mvc *sql, symbol *s, sql_schema *ss, sql_table *t, int alter)
{
	stmt *res = NULL;

	if (s->token == SQL_CONSTRAINT) {
		dlist *l = s->data.lval;
		char *opt_name = l->h->data.sval;
		symbol *sym = l->h->next->data.sym;

		if (!opt_name)
			opt_name = table_constraint_name(sym, t);
		res = table_constraint_type(sql, opt_name, sym, ss, t, alter);
	}

	if (!res) {
		return sql_error(sql, 02, "table constraint: wrong token (%ld) = %s\n", (long) s, token2string(s->token));
	}
	return res;
}

static stmt *
table_element(mvc *sql, symbol *s, sql_schema *ss, sql_table *t, int alter)
{
	stmt *res = NULL;

	switch (s->token) {
	case SQL_COLUMN:
		res = create_column(sql, s, ss, t, alter);
		break;
	case SQL_CONSTRAINT:
		res = table_constraint(sql, s, ss, t, alter);
		break;
	case SQL_COLUMN_OPTIONS:
	{
		dnode *n = s->data.lval->h;
		char *cname = n->data.sval;
		sql_column *c = mvc_bind_column(sql, t, cname);
		dlist *olist = n->next->data.lval;
		list *sl = NULL;

		if (!c) {
			return sql_error(sql, 02, "column '%s' not found\n", cname);
		} else {
			if (column_options(sql, olist, ss, t, c, alter, &sl) == SQL_ERR) {
				if (sl) list_destroy(sl);
				return NULL;
			}
		}
		if (sl)
			res = stmt_list(sl);
		else
			res = stmt_none();
	}
		break;
	case SQL_LIKE:
	{
		char *name = qname_table(s->data.lval);
		sql_table *ot = mvc_bind_table(sql, ss, name);
		node *n;

		for (n = ot->columns.set->h; n; n = n->next) {
			sql_column *oc = n->data;

			(void)mvc_create_column(sql, t, oc->base.name, &oc->type);
		}
		res = stmt_none();
	} break;
	case SQL_DROP_COLUMN:
	{
		dlist *l = s->data.lval;
		char *cname = l->h->data.sval;
		int drop_action = l->h->next->data.ival;
		sql_column *col = mvc_bind_column(sql, t, cname);

		if (col == NULL)
			return sql_error(sql, 02, "cannot drop unknown column %s\n", cname);
		if (cs_size(&t->columns) <= 1)
			return sql_error(sql, 02, "cannot drop column %s (table needs atleast one column)\n", cname);
		if (t->system)
			return sql_error(sql, 02, "cannot drop column %s (table is a system table)\n", cname);
		if (isView(t))
			return sql_error(sql, 02, "cannot drop column %s (%s is a view)\n", cname, t->base.name);
		if (!drop_action && mvc_check_dependency(sql, col->base.id, COLUMN_DEPENDENCY))
			return sql_error(sql, 02, "unable to drop column %s (there are database objects which depend on it)\n", cname);
		if (!drop_action  && t->keys.set) {
			node *n, *m;

			for (n = t->keys.set->h; n; n = n->next) {
				sql_key *k = n->data;
				for (m = k->columns->h; m; m = m->next) {
					sql_kc *kc = m->data;
					if (strcmp(kc->c->base.name, cname)==0) 
						return sql_error(sql, 02, "unable to drop column %s (there are constraints which depend on it)\n", cname);
				}
			}
		}
		mvc_drop_column(sql, t, cname, drop_action);
		res = stmt_none();
	} break;
	case SQL_DROP_CONSTRAINT:
	{
		dlist *l = s->data.lval;
		char *kname = l->h->data.sval;
		int drop_action = l->h->next->data.ival;

		if (mvc_bind_key(sql, ss, kname ) == NULL)
			return sql_error(sql, 02, "cannot drop unknown constraint %s\n", kname);
		mvc_drop_key(sql, ss, kname, drop_action);
		res = stmt_none();
	} break;
	}
	if (!res) {
		return sql_error(sql, 02, "unknown table element (%ld)->token = %s\n", (long) s, token2string(s->token));
	}
	return res;
}

stmt *
sql_create_table(mvc *sql, sql_schema *ss, int temp, dlist *qname, symbol *table_elements_or_subquery, int commit_action)
{
	char *name = qname_table(qname);
	char *sname = qname_schema(qname);
	sql_schema *s = NULL;

	if (sname && !(s = mvc_bind_schema(sql, sname)))
		return sql_error(sql, 02, "CREATE TABLE: no such schema '%s'", sname);

	if (temp != SQL_PERSIST && commit_action == CA_COMMIT)
		commit_action = CA_DELETE;
	
	if (temp != SQL_PERSIST) {
		/* if (s != NULL) warn("discarding schema %s", s->base.name; */
		s = mvc_bind_schema(sql, "tmp");
	} else if (s == NULL) {
		s = ss;
	}

	if (mvc_bind_table(sql, s, name)) {
		char *cd = (temp == SQL_DECLARED_TABLE)?"DECLARE":"CREATE";
		return sql_error(sql, 02, "%s TABLE: name '%s' already in use", cd, name);
	} else if (temp != SQL_DECLARED_TABLE &&!schema_privs(sql->role_id, s)){
		return sql_error(sql, 02, "CREATE TABLE: insufficient privileges for user '%s' in schema '%s'", stack_get_string(sql, "current_user"), s->base.name);
	} else if (table_elements_or_subquery->token == SQL_CREATE_TABLE) { 
		/* table element list */
		sql_table *t = mvc_create_table(sql, s, name, 0, temp, commit_action, -1);
		list *new_columns = create_stmt_list();
		dnode *n;
		dlist *columns = table_elements_or_subquery->data.lval;

		if (temp == SQL_DECLARED_TABLE)
			list_append_stmt(new_columns, stmt_basetable(t,name));
			
		for (n = columns->h; n; n = n->next) {
			symbol *sym = n->data.sym;
			stmt *te = table_element(sql, sym, s, t, 0);

			if (!te) {
				list_destroy(new_columns);
				return NULL;
			}
			list_append_stmt(new_columns, te);
		}
		return list2stmt(new_columns);
	} else { /* [col name list] as subquery with or without data */
		exp_kind ek = {type_value, card_relation, TRUE};
		stmt *sq = NULL, *res = NULL;
		dlist *as_sq = table_elements_or_subquery->data.lval;
		dlist *column_spec = as_sq->h->data.lval;
		symbol *subquery = as_sq->h->next->data.sym;
		int with_data = as_sq->h->next->next->data.ival;
		sql_table *t = NULL; 

		sq = scope_subquery(sql, NULL, subquery, ek);
		/* make sure we get a list of ordered columns */
		if (sq && sq->type == st_ordered) {
			stmt *order = stmt_dup(sq->op1.stval);
			stmt *s = stmt_dup(sq->op2.stval);
			stmt_destroy(sq);
			sq = sql_reorder(order, s);
		}
		if (!sq)
			return NULL;

		/* create table */
		t = mvc_create_table(sql, s, name, 0, temp, commit_action, -1);
		as_subquery(sql, t, sq, column_spec);

		/* insert query result into this table */
		if (with_data) {
			node *n, *m;
			scope *scp = scope_open(NULL);
			tvar *tv = scope_add_table_columns(sql, scp, t, t->base.name, INS);
			list *l = create_stmt_list();
			list *cl = t->columns.set;

			for (n = sq->op1.lval->h, m = cl->h; n && m; n = n->next, m = m->next) {
				sql_column *c = m->data;
				stmt *ins = stmt_dup(n->data);
				list_append(l, stmt_append(stmt_bat(c, stmt_dup(tv->s), INS), ins));
			}
			scope_close(scp);
			res = stmt_list(l);
		} else {
			res = stmt_none();
		}
		stmt_destroy(sq);
		return res;
	}
}

static stmt *
drop_table(mvc *sql, dlist *qname, int drop_action)
{
	char *sname = qname_schema(qname);
	char *tname = qname_table(qname);
	sql_schema *s = NULL;
	sql_table *t = NULL;
	node *n; 

	if (sname && !(s=mvc_bind_schema(sql, sname))) {
		(void) sql_error(sql, 02, "DROP TABLE: no such schema '%s'", sname);
		return NULL;
	}
	if (!s)
		s = cur_schema(sql);
	t = mvc_bind_table(sql, s, tname);
	if (!t && !sname) {
		s = tmp_schema(sql);
		t = mvc_bind_table(sql, s, tname);
	}
	if (!t) { 
		return sql_error(sql, 02, "DROP TABLE: no such table '%s'", tname);
	} else if (!isTable(t)) {
		return sql_error(sql, 02, "DROP TABLE: cannot drop VIEW '%s'", tname);
	} else if (t->system) {
		return sql_error(sql, 02, "DROP TABLE: cannot drop system table '%s'", tname);
	} else if (!schema_privs(sql->role_id, s)) {
		return sql_error(sql, 02, "DROP TABLE: access denied for %s to schema ;'%s'", stack_get_string(sql, "current_user"), s->base.name);
	}
	if ( !drop_action && t->keys.set) {
		for (n = t->keys.set->h; n; n = n->next) {
			sql_key *k = n->data;

			if (k->type == ukey || k->type == pkey) {
				sql_ukey *uk = (sql_ukey *) k;

				if (uk->keys && list_length(uk->keys)) {
					node *l = uk->keys->h;

					for (; l; l = l->next) {
						k = l->data;
						/* make sure it is not a self referencing key */
						if (k->t != t) {
							return sql_error(sql, 02,
									 "DROP TABLE: FOREIGN KEY %s.%s "
									 "depends on %s",
									 k->t->base.name, k->base.name, tname);
						}
					}
				}
			}
		}
	}

	if (!drop_action && mvc_check_dependency(sql, t->base.id, TABLE_DEPENDENCY))
			return sql_error(sql, 02, "DROP TABLE: unable to drop table %s (there are database objects which depend on it)\n", t->base.name);
	
	mvc_drop_table(sql, s, t->base.name, drop_action);
	return stmt_none();
}

static stmt *
alter_table(mvc *sql, sql_schema *ss, dlist *qname, symbol *te)
{
	char *name = qname_table(qname);
	sql_table *t = NULL;

	if ((t = mvc_bind_table(sql, ss, name)) == NULL) {
		return sql_error(sql, 02, "ALTER TABLE: no such table '%s'", name);
	} else {
		return table_element(sql, te, ss, t, 1);
	}
}

static char *
get_schema_name(dlist *name_auth)
{
	assert(name_auth && name_auth->h);

	return name_auth->h->data.sval;
}

static char *
schema_auth(dlist *name_auth)
{
	assert(name_auth && name_auth->h && dlist_length(name_auth) == 2);

	return name_auth->h->next->data.sval;
}

static stmt *
create_schema(mvc *sql, dlist *auth_name, dlist *schema_elements)
{
	char *name = get_schema_name(auth_name);
	char *auth = schema_auth(auth_name);
	int auth_id = sql->role_id;

	if (auth && (auth_id = sql_find_auth(sql, auth)) < 0) {
		return sql_error(sql, 02, "CREATE SCHEMA: no such authorization '%s'", auth);
	}
	if (sql->user_id != USER_MONETDB && sql->role_id != ROLE_SYSADMIN) {
		return sql_error(sql, 02, "CREATE SCHEMA: insufficient privileges for user '%s'", stack_get_string(sql, "current_user"));
	}
	if (mvc_bind_schema(sql, name)) {
		return sql_error(sql, 02, "CREATE SCHEMA: name '%s' already in use", name);
	} else {
		dnode *n;
		list *table_elements = create_stmt_list();
		sql_schema *ss = mvc_create_schema(sql, name, auth_id, sql->user_id);

		n = schema_elements->h;

		while (n) {
			stmt *res = NULL;

			if (n->data.sym->token == SQL_CREATE_TABLE) {
				dlist *l = n->data.sym->data.lval;

				res = sql_create_table(sql, ss, l->h->data.ival, l->h->next->data.lval, l->h->next->next->data.sym, l->h->next->next->next->data.ival);
			} else if (n->data.sym->token == SQL_CREATE_VIEW) {
				dlist *l = n->data.sym->data.lval;

				res = create_view(sql, ss, l->h->data.lval, l->h->next->data.lval, l->h->next->next->data.sym, l->h->next->next->next->data.ival, l->h->next->next->next->next->data.ival);
			}
			if (!res) {
				list_destroy(table_elements);
				return NULL;
			}
			list_append_stmt(table_elements, res);
			n = n->next;
		}

		return list2stmt(table_elements);
	}
}

static stmt *
drop_schema(mvc *sql, dlist *qname, int dropaction)
{
	char *name = get_schema_name(qname);
	sql_schema *s = mvc_bind_schema(sql, name);

	(void) dropaction;
	if (!s) {
		return sql_error(sql, 02, "DROP SCHEMA: name %s does not exist", name);
	} else if (!schema_privs(sql->role_id, s)) {
		return sql_error(sql, 02, "DROP SCHEMA: access denied for %s to schema ;'%s'", stack_get_string(sql, "current_user"), s->base.name);
	} else if (s == cur_schema(sql)) {
		return sql_error(sql, 02, "DROP SCHEMA: cannot drop current schema");
	} else if (strcmp(name, "sys") == 0 || strcmp(name, "tmp") == 0) {
		return sql_error(sql, 02, "DROP SCHEMA: access denied for '%s'", name);
	} else if (sql_schema_has_user(sql, s)) {
		return sql_error(sql, 02, "DROP SCHEMA: unable to drop schema '%s' (there are database objects which depend on it", name);
	} else {
		mvc_drop_schema(sql, name, dropaction);
		return stmt_none();
	}
}

stmt *
schemas(mvc *sql, symbol *s)
{
	stmt *ret = NULL;

	if (!QUERY_MODE(sql->mode))
		return sql_error(sql, 05, "Schema statements are directly executed and therefor cannot be debugged, explained, profiled, traced or used in a prepare statement");

	switch (s->token) {
	case SQL_CREATE_SCHEMA:
	{
		dlist *l = s->data.lval;

		ret = create_schema(sql, l->h->data.lval,	/* qname (name.authid) */
				    l->h->next->next->next->data.lval /* schema_elements */ );
		sql->type = Q_SCHEMA;
	}
		break;
	case SQL_DROP_SCHEMA:
	{
		dlist *l = s->data.lval;

		ret = drop_schema(sql, l->h->data.lval,	/* qname */
				  l->h->next->data.ival);	/* drop_action */
		sql->type = Q_SCHEMA;
	}
		break;
	case SQL_DROP_TABLE:
	{
		dlist *l = s->data.lval;

		ret = drop_table(sql, l->h->data.lval, l->h->next->data.ival);
		sql->type = Q_SCHEMA;
	}
		break;
	case SQL_DROP_VIEW:
	{
		dlist *l = s->data.lval;

		ret = drop_view(sql, l->h->data.lval, l->h->next->data.ival);
		sql->type = Q_SCHEMA;
	}
		break;
	case SQL_CREATE_TABLE:
	{

		dlist *l = s->data.lval;

		ret = sql_create_table(sql, cur_schema(sql), l->h->data.ival, l->h->next->data.lval, l->h->next->next->data.sym, l->h->next->next->next->data.ival);
		sql->type = Q_SCHEMA;
	}
		break;
	case SQL_CREATE_VIEW:
	{
		dlist *l = s->data.lval;

		ret = create_view(sql, cur_schema(sql), l->h->data.lval, l->h->next->data.lval, l->h->next->next->data.sym, l->h->next->next->next->data.ival, l->h->next->next->next->next->data.ival);
		sql->type = Q_SCHEMA;
	}
		break;
	case SQL_CREATE_INDEX:
	{
		dlist *l = s->data.lval;

		ret = create_index(sql, cur_schema(sql), l->h->data.sval, l->h->next->data.ival, l->h->next->next->data.lval, l->h->next->next->next->data.lval);
		sql->type = Q_SCHEMA;
	}
		break;
	case SQL_DROP_INDEX:
	{
		dlist *l = s->data.lval;

		ret = drop_index(sql, l);	/* index name */
		sql->type = Q_SCHEMA;
	}
		break;
	case SQL_CREATE_USER:
	{
		dlist *l = s->data.lval;

		ret = create_user(sql, l->h->data.sval,	/* user name */
				  l->h->next->data.sval,	/* password */
				  l->h->next->next->data.sval,	/* fullname */
				  l->h->next->next->next->data.sval);	/* dschema */
		sql->type = Q_SCHEMA;
	}
		break;
	case SQL_DROP_USER:
		ret = drop_user(sql, s->data.sval);	/* user name */
		sql->type = Q_SCHEMA;
		break;
	case SQL_ALTER_USER:
	{
		dlist *l = s->data.lval;

		ret = alter_user(sql, l->h->data.sval,	/* user */
				 l->h->next->data.lval->h->data.sval,	/* passwd */
				 l->h->next->data.lval->h->next->data.sval	/* schema */
		    );
		sql->type = Q_SCHEMA;
	}
		break;
	case SQL_CREATE_ROLE:
	{
		dlist *l = s->data.lval;

		ret = create_role(sql, l->h->data.lval,	/* role name */
				  l->h->next->data.ival);	/* role grantor */
		sql->type = Q_SCHEMA;
	}
		break;
	case SQL_DROP_ROLE:
	{
		dlist *l = s->data.lval;

		ret = drop_role(sql, l);	/* role name */
		sql->type = Q_SCHEMA;
	}
		break;
	case SQL_ALTER_TABLE:
	{
		dlist *l = s->data.lval;

		ret = alter_table(sql, cur_schema(sql), l->h->data.lval,	/* table name */
				  l->h->next->data.sym);	/* table element */
		sql->type = Q_SCHEMA;
	}
		break;
	case SQL_GRANT_ROLES:
	{
		dlist *l = s->data.lval;

		ret = grant_roles(sql, cur_schema(sql), l->h->data.lval,	/* authids */
				  l->h->next->data.lval,	/* grantees */
				  l->h->next->next->data.ival,	/* admin? */
				  l->h->next->next->next->data.ival ? sql->user_id : sql->role_id);
		/* grantor ? */
		sql->type = Q_SCHEMA;
	} break;
	case SQL_REVOKE_ROLES:
	{
		dlist *l = s->data.lval;

		ret = revoke_roles(sql, cur_schema(sql), l->h->data.lval,	/* authids */
				  l->h->next->data.lval,	/* grantees */
				  l->h->next->next->data.ival,	/* admin? */
				  l->h->next->next->next->data.ival ? sql->user_id : sql->role_id);
		/* grantor ? */
		sql->type = Q_SCHEMA;
	} break;
	case SQL_GRANT:
	{
		dlist *l = s->data.lval;

		ret = grant_privs(sql, cur_schema(sql), l->h->data.lval,	/* privileges */
				  l->h->next->data.lval,	/* grantees */
				  l->h->next->next->data.ival,	/* grant ? */
				  l->h->next->next->next->data.ival ? sql->user_id : sql->role_id);
		/* grantor ? */
		sql->type = Q_SCHEMA;
	} break;
	case SQL_REVOKE:
	{
		dlist *l = s->data.lval;

		ret = revoke_privs(sql, cur_schema(sql), l->h->data.lval,	/* privileges */
				   l->h->next->data.lval,	/* grantees */
				   l->h->next->next->data.ival,	/* grant ? */
				   l->h->next->next->next->data.ival ? sql->user_id : sql->role_id);
		/* grantor ? */
		sql->type = Q_SCHEMA;
	} break;

	case SQL_CREATE_TYPE:
	{
		dlist *l = s->data.lval;

		ret = create_type(sql, l->h->data.lval, l->h->next->data.sval);
		sql->type = Q_SCHEMA;
	}
		break;

	case SQL_CREATE_TRIGGER:
	{
		dlist *l = s->data.lval;

		ret = create_trigger(sql, l->h->data.lval, l->h->next->data.ival, l->h->next->next->data.sym, l->h->next->next->next->data.sval, l->h->next->next->next->next->data.lval, l->h->next->next->next->next->next->data.lval);
		sql->type = Q_SCHEMA;
	}
		break;

	case SQL_DROP_TRIGGER:
	{
		dlist *l = s->data.lval;

		ret = drop_trigger(sql, l);
		sql->type = Q_SCHEMA;
	}
		break;

	case SQL_CONNECT:
	{
		dlist *l = s->data.lval;

		ret = connect_catalog(sql, l);
		sql->type = Q_SCHEMA;
	}
		break;

	case SQL_DISCONNECT:
	{
		dlist *l = s->data.lval;

		ret = disconnect_catalog(sql, l);
		sql->type = Q_SCHEMA;
	}
		break;

	default:
		return sql_error(sql, 01, "schema statement unknown symbol(%ld)->token = %s", (long) s, token2string(s->token));
	}
	sql->last = NULL;
	return ret;
}
