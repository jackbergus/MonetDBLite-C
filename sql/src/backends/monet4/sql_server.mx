@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2007 CWI.
@' All Rights Reserved.

@f sql_server
@a N.J. Nes, M.L. Kersten
@* 
The sql_server module contains the complete wrapper interface for the
SQL client and the corresponding MIL runtime startup.

The implementation described here is focused on using the Mapi library
for interaction. This provides a simple textual interface to the server
based on ASCII text.

It is intended to work directly with any of the mclient implementations.
To avoid clashes with the default port settings, we have hardwired a number
for the time being.
@m
.MODULE sql_server;
	.USE ascii_io, monettime; 

	.ATOM mvc = ptr;
	.END;

	.BUILTIN sql_frontend() : ptr = sql_frontend_wrap;
		"create/return the sql_frontend"

	.COMMAND sql_trace() : void = sql_trace;
		"enable/disable saving the sql statement traces (per client)" 

@+ extra low level interface 
@m
	.BUILTIN mvc_new() : mvc = mvc_new;
	"create a sql contect"

	.command mvc_destroy(mvc m, int commit) = mvc_destroy_wrap;
	"commit/abort and destroy sql contect"
@+ 
@m

	.BUILTIN sqlconsole( ) = sqlconsole;
	"Read sql statements from stdin and output results on stdout"

	.COMMAND sqllogmanager() = sqllogmanager;
		"The log manager takes care of keeping the logs small, ie. it merges the changes into bats and abandons the logs"

@-
The session is interpreted in the context of a globally
known catalog. It is commonly represented by a variable
in the user context and should be provided to all commands.
No sanity check is performed on its validity and authorized
access after being logged in.
@m
	.COMMAND mvc_sql( mvc m, str cmd ) = mvc_sql_wrap;
		"execute a sql query"


	.COMMAND declareVariable( mvc m, str varname, any::1 nl ) = declareVariable;
		"Declare a new session variable in the mvc structure"
	.COMMAND getVariable( mvc m, str varname ) : any::1 = getVariable;
		"Get a session variable from the mvc structure"
	.COMMAND setVariable( mvc m, str varname, any::1 val ) = setVariable;
		"Set the value of a session variable in the mvc structure"

	.COMMAND mvc_next_value( mvc m, str sname, str seqname ) : lng = mvc_next_value;
		"return the next value of the sequence"

	.COMMAND [mvc_next_value]( mvc m, BAT[oid,str] snames, str seqname ) : bat[oid,lng] = mvc_bat_next_value;
		"return the next value of the sequence for the bat of schema names"

	.COMMAND mvc_get_value( mvc m, str sname, str sequence ) : lng = mvc_get_value;
		"return the current value of the sequence"

	.COMMAND mvc_restart_seq( mvc m, str sname, str sequence, lng start ) : lng = mvc_restart_seq;
		"restart the sequence with value start"
@-
The updates against the relational tables are collected in separate
BATs until transaction commit. 
The code produced by the SQL->MIL compiler uses it to propagate
the updates to the persistent versions.
@m
	.COMMAND mvc_bind( mvc c, str sname, str tname, str cname, int access ) : 
		BAT[any::1,any::2] = 
		mvc_bind_wrap; "Bind the bat, tname.cname"

	.COMMAND mvc_append( mvc c, str sname, str tname, str cname, any b ) :void = mvc_append; 
		"Append b to the column, tname.cname (possibly optimized to replace the insert bat of tname.cname"

	.COMMAND mvc_update( mvc c, str sname, str tname, str cname, any b ) :void = mvc_update; 
		"Append b to the column, tname.cname (possibly optimized to replace the insert bat of tname.cname"

	.COMMAND mvc_bind_dbat( mvc c, str sname, str tname, int access ) : 
		BAT[any::1,any::2] = mvc_bind_dbat_wrap; 
		"Bind the table deletes bat, tname.deletes"

	.COMMAND mvc_bind_idxbat( mvc c, str sname, str tname, str iname, int access ) : 
		BAT[any::1,any::2] = mvc_bind_idxbat_wrap; 
		"Bind the idx table"

	.COMMAND mvc_append_idx( mvc c, str sname, str tname, str iname, any b) :void = mvc_append_idx; 
		"Bind the idx table"

	.COMMAND mvc_update_idx( mvc c, str sname, str tname, str iname, any b) :void = mvc_update_idx; 
		"Bind the idx table"
@-
A special clear table function is required for an efficient DELETE ALL implementation. A table clear requires global table knowledge. 
@m
	.COMMAND mvc_clear_table( mvc c, str sname, str tname ) :lng = mvc_clear_table_wrap;
		"Clear table" 

	.COMMAND mvc_delete( mvc c, str sname, str tname, any b ) :void = mvc_delete_wrap;
		"delete from table" 
@-
The results of the SQL queries are assembled in result sets, which
can be shipped to the front-end for display or exported over a
stream.
@m
	.COMMAND mvc_result_table( mvc m, int nr_cols, int type, any order ) : int = mvc_result_row_wrap; "Create structure to cache a row query result" 

	.COMMAND mvc_result_table( mvc m, int nr_cols, int type, BAT[oid,any] order ) : int = mvc_result_table_wrap; "Create structure to cache a table query result" 

	.COMMAND mvc_result_column( mvc m, str tname, str name, str typename, int digits, int scale, any val) = mvc_result_value_wrap; "Add the value to the row query result"
	.COMMAND mvc_result_column( mvc m, str tname, str name, str typename, int digits, int scale, BAT[oid,any] col) = mvc_result_column_wrap; "Add the colunm to the table query result"

	.COMMAND mvc_schema_operation(mvc m, Stream s, str w) =
		mvc_export_schema_wrap; "export a schema operation to stream s"

	.COMMAND mvc_export_result(mvc m, Stream s, int result_id, str w) =
		mvc_export_result_wrap; "export a result to stream s"

	.COMMAND mvc_affected_rows(mvc m, Stream s, int cnt, str w) =
		mvc_affected_rows_int; "export the number of affected rows by the current query to stream s"

	.COMMAND mvc_affected_rows(mvc m, Stream s, lng cnt, str w) =
		mvc_affected_rows_wrap; "export the number of affected rows by the current query to stream s"

	.COMMAND mvc_export_value(mvc m, Stream s, int qtype, str tname, str name, str typename, int digits, int scale, int eclass, any val, str w) =
		mvc_export_value_wrap; "export a single value onto the stream s"

	.COMMAND mvc_import_table( mvc c, Bstream s, str tname, 
					str sep, str rsep, int nr) : 
		BAT[str,BAT] = mvc_import_table_wrap; 
		"import a table from stream s with the given tuple and record seperators (sep/rsep)"

@= mel_round
	.COMMAND dec_round( @1 v, @1 r ) : @1 = @1_dec_round_wrap; "round off the value v to nearests multiple of r"

	.COMMAND round( @1 v, int d, int s, bte r ) : @1 = @1_round_wrap; "round off the decimal v(d,s) to r digits behind the dot (if r < 0, before the dot)"
@m

@:mel_round(bte)@
@:mel_round(sht)@
@:mel_round(int)@
@:mel_round(lng)@

@m
	.COMMAND dec_round( flt v, flt r ) : flt = flt_dec_round_wrap; "round off the value v to nearests multiple of r"

	.COMMAND dec_round( dbl v, dbl r ) : dbl = dbl_dec_round_wrap; "round off the value v to nearests multiple of r"

@= mel_cast
 .COMMAND @1( str v ) : @1 = str_2_@1; "cast to @1 and check for overflow"
 .COMMAND @1( str v, int digits ) : @1 = str_2num_@1; "cast to @1 and check for overflow"
 .COMMAND @1( str v, int digits, int scale ) : @1 = str_2dec_@1; "cast to dec(@1) and check for overflow"
@m
@:mel_cast(bte)@
@:mel_cast(sht)@
@:mel_cast(int)@
@:mel_cast(lng)@

@= mel_castfromstr
 .COMMAND @1( str v ) : @1 = str_2_@1; "cast to @1"
@m
@:mel_castfromstr(flt)@
@:mel_castfromstr(dbl)@
@:mel_castfromstr(timestamp)@
@:mel_castfromstr(daytime)@
@:mel_castfromstr(date)@

 .COMMAND "str"( mvc m, int eclass, int d1, int s1, int has_tz, any v, int d2 ) : str = str_cast; "cast to string and check for overflow"

@= mel_cast_2dec
 .COMMAND @1( @2 v ) : @1 = @2_2_@1; "cast @2 to @1 and check for overflow"
 .COMMAND @1( @2 v, int d2, int s2 ) : @1 = @2_num2dec_@1; "cast number to decimale(@1) and check for overflow"
@m

@:mel_cast_2dec(bte,flt)@
@:mel_cast_2dec(sht,flt)@
@:mel_cast_2dec(int,flt)@
@:mel_cast_2dec(lng,flt)@
@:mel_cast_2dec(bte,dbl)@
@:mel_cast_2dec(sht,dbl)@
@:mel_cast_2dec(int,dbl)@
@:mel_cast_2dec(lng,dbl)@

@= mel_cast_dec2
 .COMMAND @1( int s1, @2 v ) : @1 = @2_dec2_@1; "cast decimal(@2) to @1 and check for overflow"
 .COMMAND @1( int s1, @2 v, int d2, int s2 ) : @1 = @2_dec2dec_@1; "cast decimal(@2) to decimale(@1) and check for overflow"
@m

@= mel_cast2
@:mel_cast_2dec(@1,@2)@
@:mel_cast_dec2(@1,@2)@
@m

@:mel_cast2(bte,bte)@
@:mel_cast2(bte,sht)@
@:mel_cast2(bte,int)@
@:mel_cast2(bte,lng)@
@:mel_cast2(sht,bte)@
@:mel_cast2(sht,sht)@
@:mel_cast2(sht,int)@
@:mel_cast2(sht,lng)@
@:mel_cast2(int,bte)@
@:mel_cast2(int,sht)@
@:mel_cast2(int,int)@
@:mel_cast2(int,lng)@
@:mel_cast2(lng,bte)@
@:mel_cast2(lng,sht)@
@:mel_cast2(lng,int)@
@:mel_cast2(lng,lng)@
@:mel_cast2(flt,bte)@
@:mel_cast2(flt,sht)@
@:mel_cast2(flt,int)@
@:mel_cast2(flt,lng)@
@:mel_cast2(dbl,bte)@
@:mel_cast2(dbl,sht)@
@:mel_cast2(dbl,int)@
@:mel_cast2(dbl,lng)@

@= mel_interval
 .COMMAND month_interval( @1 v, int ek, int sk ) : int = month_interval_@1; "cast @1 to a month_interval and check for overflow"

 .COMMAND second_interval( @1 v, int ek, int sk ) : lng = second_interval_@1; "cast @1 to a month_interval and check for overflow"
@m

@:mel_interval(str)@
@:mel_interval(bte)@
@:mel_interval(sht)@
@:mel_interval(int)@
@:mel_interval(lng)@

	.BUILTIN sql_variables() : ptr = sql_variables;
		"return the table with session variables"

	.BUILTIN dump_cache() : void = dump_cache;
		"dump the query cache"

	.BUILTIN dump_opt_stats() : void = dump_opt_stats;
		"dump the optimizer rewrite statistics"

	.COMMAND zero_or_one( BAT[any,any::1] b) : any::1 = zero_or_one; "if b contains exactly one value return this. Incase of more raise an exception else return nil"

	.COMMAND not_unique( BAT[oid,oid] b) : bit = not_unique; "check if the tail sorted bat b doesn't have unique tail values" 

.END sql_server;

@-
The implementation below mostly wraps around the primitives
provided in the SQL server code base. The wrapper handles
conversion from the MIL interpretation context to direct
handles and returns proper error messages upon failure.
@h
#ifndef _SQL_SERVER_H_
#define _SQL_SERVER_H_

#include <sql_mem.h>
#include <streams.h>
#include <ascii_io.h>
#include <monettime.h>
#include <monet_context.h>
#include "sql_mvc.h"
#include "sql_server.proto.h"

#endif /*_SQL_SERVER_H_*/

@c
#include "sql_config.h"
#include "sql_server.h"
#include "sql_result.h"
#include "sql_session.h"
#include "sql_gencode.h"
#include "sql_user.h"
#include <sql_privileges.h>
#include <sql_decimal.h>
#include <sql_string.h>
#include <sql_datetime.h>
#include <sql_env.h>
#include <algebra.h>
#include "sql_storage.h"
#include <store_sequence.h>

@-
The code heavily depends on the (complex) data structures for
both program representation (YYSTREE), runtime stack (Cntxt),
and the MIL interpreter. Details can be found in the src/monet
directory.
@c

void
monet4_freestack(backend_stack stk)
{
	Cntxt procstk = (Cntxt) (ptrdiff_t) stk;

	monet_cntxt[procstk].reuse = FALSE;
	CNTXTclear(procstk);
	CNTXTfree1(procstk);
	CNTXTdelete(procstk);
}

void
monet4_freecode(backend_code code, backend_stack stk, int nr, char *name)
{
	YYSTREE callnode = (YYSTREE) code;

	(void)nr;
	if (code) {
		Client client;

		/* free proc */
		Myyfree(callnode);

		/* deregister proc */
		CNTXTclient((Cntxt) (ptrdiff_t) stk, &client);
		TBL_delproc(client, name);
	}
}

int
sql_frontend_wrap(Cntxt stk, YYSTREE lt, ValPtr res)
{
	Client father = NULL;

	if (lt->cnt != 0) 
		return handle_argerror(res, lt->cnt, 0);

	memset((char *)&be_funcs, '\0', sizeof(backend_functions));
	be_funcs.fstack = &monet4_freestack;
	be_funcs.fcode = &monet4_freecode;
	monet4_user_init(&be_funcs);
	CNTXTclient(stk, &father);
	if (father && father->father >= 0) {
		/* if the father itself is a temporary client, let
		 * the new child depend on the grandfather.
		 * so: father always points to a real client session!
		 */
		father = monet_clients + father->father;
	}
	if (father)
		stk = father->stk;
	if (mvc_init(0/*debug*/, store_bat, (backend_stack) stk) < 0) {
		return GDK_FAIL;
	}
	res->vtype = TYPE_ptr;
	res->val.pval = (ptr) sql_frontend();
	return GDK_SUCCEED;
}

int
sqllogmanager()
{
	mvc_logmanager();
	return GDK_SUCCEED;	
}

int
mvc_sql_wrap(mvc *c, str cmd)
{
	return mvc_sql(*(mvc **) c, cmd);
}

int
declareVariable(mvc* M, str varname, ptr value, int type)
{
	mvc *m = *(mvc**)M;
	ValRecord src;

	/* var should be there allready */
	VALset(&src, type, value);
	stack_set_var(m, varname, &src);
	return GDK_SUCCEED;
}

int
setVariable(mvc* M, str varname, ptr value, int type)
{
	mvc *m = *(mvc**)M;
	ValRecord src;
	str err;

	VALset(&src, type, value);
	if (stack_find_var(m, varname)) 
		stack_set_var(m, varname, &src);
	else
		return GDKerror("setVariable: variable '%s' unknown", varname);
	if ((err = sql_update_var(m, varname)) != NULL) {
		GDKerror("%s", err);
		_DELETE(err);
		return GDK_FAIL;
	}
	return GDK_SUCCEED;
}

int
getVariable(ptr value, int *type, mvc* M, str varname)
{
	mvc *m = *(mvc**)M;
	ValRecord *v = stack_get_var(m, varname);

	if (!v) 
		return GDKerror("getVariable: variable '%s' unknown", varname);

	*type = v->vtype;
	if (ATOMextern(v->vtype) == 0) {
		ptr p = VALptr(v);
		memcpy(value, p, ATOMlen(v->vtype, p));
	} else if (v->vtype >= TYPE_str && ATOMstorage(v->vtype) == TYPE_str) {
		*(str*)value = GDKstrdup(v->val.sval);
	} else {
		*(ptr*)value = GDKmalloc(v->len);
		memcpy(*(ptr*)value, v->val.pval, v->len);
	}
	return GDK_SUCCEED;
}


/* TODO pass also the schema name */
int
mvc_next_value(lng *res, mvc *C, str sname, str seqname)
{
	mvc *c = *(mvc**)C;
	sql_schema *s = mvc_bind_schema(c, sname);

	if (s) {
		sql_sequence *seq = find_sql_sequence(s, seqname);

		if (seq && seq_next_value(seq, res))
			return GDK_SUCCEED;
	}
	return GDK_FAIL;
}

int
mvc_bat_next_value(BAT **res, mvc *C, BAT *snames, str seqname)
{
	mvc *c = *(mvc**)C;
	BAT *r;
	BUN p,q;
	sql_schema *s = NULL;
	sql_sequence *seq = NULL;
	seqbulk *sb = NULL;
	BATiter snamesi = bat_iterator(snames);

	r = BATnew(snames->htype, TYPE_lng, BATcount(snames));
	if (!r) {
		GDKerror("Cannot create bat");
		return GDK_FAIL;
	}

	BATseqbase(r, snames->hseqbase);
	if (!BATcount(snames)) {
		*res = r;
		return GDK_SUCCEED;
	}

	BATloop(snames,p,q){
		str sname = BUNtail(snamesi,BUNfirst(snames));
		lng l;

		if (!s || strcmp(s->base.name, sname) != 0) {
			if (sb)
				seqbulk_destroy(sb);
			s = mvc_bind_schema(c, sname);
			seq = NULL;
			if (!s || 
			    (seq = find_sql_sequence(s, seqname)) == NULL ||
			    !(sb = seqbulk_create(seq, BATcount(snames))) ) {
				BBPunfix(r->batCacheid);
				GDKerror("sql.next_value error");
				return GDK_FAIL;
			}
		}
		if (!seqbulk_next_value(sb, &l)) {
			BBPunfix(r->batCacheid);
			seqbulk_destroy(sb);
			GDKerror("sql.next_value error");
			return GDK_FAIL;
		}
		BUNins(r, BUNhead(snamesi,p), &l, FALSE);
	}
	if (sb) 
		seqbulk_destroy(sb);
	*res = r;
	return GDK_SUCCEED;
}

int
mvc_get_value(lng *res, mvc *C, str sname, str seqname)
{
	mvc *c = *(mvc**)C;
	sql_schema *s = mvc_bind_schema(c, sname);

	if (s) {
		sql_sequence *seq = find_sql_sequence(s, seqname);

		if (seq && seq_get_value(seq, res))
			return GDK_SUCCEED;
	}
	return GDK_FAIL;
}

int
mvc_restart_seq(lng *res, mvc *C, str sname, str seqname, lng *start)
{
	mvc *c = *(mvc**)C;
	sql_schema *s = mvc_bind_schema(c, sname);

	if (s) {
		sql_sequence *seq = find_sql_sequence(s, seqname);

		if (seq) {
			*res = sql_trans_sequence_restart(c->session->tr, seq, *start);
			return GDK_SUCCEED;
		}
	}
	return GDK_FAIL;
}

static BAT *
mvc_bind(mvc *m, char *sname, char *tname, char *cname, int access)
{
	sql_trans *tr = m->session->tr;
	BAT *b = NULL;
	sql_schema *s = mvc_bind_schema(m, sname);
	sql_table *t = mvc_bind_table(m, s, tname);
	sql_column *c = mvc_bind_column(m, t, cname);

	b = store_funcs.bind_col(tr, c, access);
	return b;
}

int 
mvc_append(mvc *M, str sname, str tname, str cname, ptr ins, int tpe)
{
	mvc *m = *(mvc**)M;
	sql_trans *tr = m->session->tr;
	sql_schema *s = mvc_bind_schema(m, sname);
	sql_table *t = mvc_bind_table(m, s, tname);
	sql_column *c = mvc_bind_column(m, t, cname);
	BAT *b = (BAT*)ins;

	if ((tpe == TYPE_bat && b->ttype != c->type.type->localtype) ||
	    (tpe != TYPE_bat && tpe != c->type.type->localtype)) 
		return GDK_FAIL;
	store_funcs.append_col(tr, c, ins, tpe);
	return GDK_SUCCEED;
}

int
mvc_append_idx(mvc *M, char *sname, char *tname, char *iname, ptr ins, int tpe)
{
	mvc *m = *(mvc**)M;
	sql_trans *tr = m->session->tr;
	sql_schema *s = mvc_bind_schema(m, sname);
	sql_idx *i = mvc_bind_idx(m, s, iname);
	BAT *b = (BAT*)ins;

	(void) tname;
	if ((tpe != TYPE_bat && tpe != TYPE_int && tpe != TYPE_oid) &&
	    (tpe == TYPE_bat && b->ttype != TYPE_int && b->ttype != TYPE_oid)){
		GDKerror("incorrect type (%d) for index\n", tpe);
		return GDK_FAIL;
	}
	store_funcs.append_idx(tr, i, ins, tpe);
	return GDK_SUCCEED;
}

int 
mvc_update(mvc *M, str sname, str tname, str cname, ptr ins, int tpe)
{
	mvc *m = *(mvc**)M;
	sql_trans *tr = m->session->tr;
	sql_schema *s = mvc_bind_schema(m, sname);
	sql_table *t = mvc_bind_table(m, s, tname);
	sql_column *c = mvc_bind_column(m, t, cname);
	BAT *b = (BAT*)ins;

	if (tpe != TYPE_bat || b->ttype != c->type.type->localtype) 
		return GDK_FAIL;
	store_funcs.update_col(tr, c, ins, tpe, 0);
	return GDK_SUCCEED;
}

int
mvc_update_idx(mvc *M, char *sname, char *tname, char *iname, ptr ins, int tpe)
{
	mvc *m = *(mvc**)M;
	sql_trans *tr = m->session->tr;
	sql_schema *s = mvc_bind_schema(m, sname);
	sql_idx *i = mvc_bind_idx(m, s, iname);
	BAT *b = (BAT*)ins;

	(void) tname;
	if (tpe != TYPE_bat || (b->ttype != TYPE_int && b->ttype != TYPE_oid)){
		GDKerror("incorrect type (%d) for index\n", tpe);
		return GDK_FAIL;
	}
	store_funcs.update_idx(tr, i, ins, tpe);
	return GDK_SUCCEED;
}

static BAT *
mvc_bind_dbat(mvc *m, char *sname, char *tname, int access)
{
	sql_trans *tr = m->session->tr;
	BAT *b = NULL;
	sql_schema *s = mvc_bind_schema(m, sname);
	sql_table *t = mvc_bind_table(m, s, tname);

	b = store_funcs.bind_del(tr, t, access);
	return b;
}

static BAT *
mvc_bind_idxbat(mvc *m, char *sname, char *tname, char *iname, int access)
{
	sql_trans *tr = m->session->tr;
	BAT *b = NULL;
	sql_schema *s = mvc_bind_schema(m, sname);
	sql_idx *i = mvc_bind_idx(m, s, iname);

	(void)tname;
	b = store_funcs.bind_idx(tr, i, access);
	return b;
}

int
mvc_bind_wrap(BAT **res, mvc *c, str sname, str tname, str cname, int *access)
{
	*res = mvc_bind(*(mvc **) c, sname, tname, cname, *access);
	if (*res) {
		return GDK_SUCCEED;
	}
	return GDK_FAIL;
}

int
mvc_bind_dbat_wrap(BAT **res, mvc *c, str sname, str tname, int *access)
{
	*res = mvc_bind_dbat(*(mvc **) c, sname, tname, *access);
	if (*res) {
		return GDK_SUCCEED;
	}
	return GDK_FAIL;
}

int
mvc_bind_idxbat_wrap(BAT **res, mvc *c, str sname, str tname, str iname, int *access)
{
	*res = mvc_bind_idxbat(*(mvc **) c, sname, tname, iname, *access);
	if (*res) {
		return GDK_SUCCEED;
	}
	return GDK_FAIL;
}

int
mvc_clear_table_wrap(lng *res, mvc *c, str sname, str tname)
{
	mvc *m = *(mvc **) c;
	sql_schema *s = mvc_bind_schema(m, sname);
	sql_table *t = mvc_bind_table(m, s, tname);

	*res = mvc_clear_table(m, t);
	return GDK_SUCCEED;
}

int
mvc_delete_wrap(mvc *M, char *sname, char *tname, ptr ins, int tpe)
{
	mvc *m = *(mvc**)M;
	sql_schema *s = mvc_bind_schema(m, sname);
	sql_table *t = mvc_bind_table(m, s, tname);
	BAT *b = (BAT*)ins;

	if (tpe != TYPE_bat || (b->ttype != TYPE_oid && b->ttype != TYPE_void)){
		GDKerror("incorrect type (%d) for index\n", tpe);
		return GDK_FAIL;
	}
	store_funcs.delete_tab(m->session->tr, t, ins, tpe);
	return GDK_SUCCEED;
}

static int
mvc_result_row(mvc *m, int nr_cols, int qtype)
{
	m->results = res_table_create(m->session->tr, m->result_id++, nr_cols, qtype, m->results, NULL);
	return m->results->id;
}


int
mvc_result_table_wrap(int *res_id, mvc *M, int *nr_cols, int *qtype, BAT *order)
{
	*res_id = mvc_result_table(*(mvc **) M, *nr_cols, *qtype, order);
	if (*res_id < 0)
		return GDK_FAIL;
	return GDK_SUCCEED;
}

int
mvc_result_row_wrap(int *res_id, mvc *M, int *nr_cols, int *qtype, ptr p, int p_type)
{
	(void) p;
	(void) p_type;		/* Stefan: unused!? */

	*res_id = mvc_result_row(*(mvc **) M, *nr_cols, *qtype);
	if (*res_id < 0)
		return GDK_FAIL;
	return GDK_SUCCEED;
}

int
mvc_result_column_wrap(mvc *M, str tn, str name, str type, int *digits, int *scale, BAT *b)
{
	if (mvc_result_column(*(mvc **) M, tn, name, type, *digits, *scale, b))
		return GDK_FAIL;
	return GDK_SUCCEED;
}

int
mvc_result_value_wrap(mvc *M, str tn, str name, str type, int *digits, int *scale, ptr p, int mtype)
{
	if (mvc_result_value(*(mvc **) M, tn, name, type, *digits, *scale, p, mtype))
		return GDK_FAIL;
	return GDK_SUCCEED;
}

int
mvc_import_table_wrap(BAT **res, mvc *c, Bstream *s, str tname, str sep, str rsep, int *sz)
{
	*res = mvc_import_table(*(mvc **) c, *(bstream **) s, tname, sep, rsep, *sz);
	if (*res == NULL) {
		GDKerror("importTable: failed to import table");
		return GDK_FAIL;
	}
	return GDK_SUCCEED;
}

int
mvc_export_result_wrap(mvc *M, Stream *S, int *res_id, str w)
{
	if (mvc_export_result(*(mvc **) M, *(stream **) S, *res_id, w))
		return GDK_FAIL;

	return GDK_SUCCEED;
}

int
mvc_export_schema_wrap(mvc *M, Stream *S, str w)
{
	if (mvc_export_operation(*(mvc **) M, *(stream **) S, w))
		return GDK_FAIL;

	return GDK_SUCCEED;
}

int
mvc_affected_rows_wrap(mvc *M, Stream *S, lng *nr, str w)
{
	stream *s = *(stream**)S;
	mvc *m = *(mvc**)M;

	m->type = Q_UPDATE;
	if (mvc_export_affrows(m, s, *nr, w))
		return GDK_FAIL;

	return GDK_SUCCEED;
}

int
mvc_affected_rows_int(mvc *M, Stream *S, int *nr, str w)
{
	lng N = *nr;
	return mvc_affected_rows_wrap(M, S, &N, w);
}

int
mvc_export_value_wrap(mvc *M, Stream *S, int *qtype, str tn, str name, str type, int *digits, int *scale, int *eclass, ptr p, int mtype, str w)
{
	if (mvc_export_value(*(mvc **) M, *(stream **)S, *qtype, tn, name, type, *digits, *scale, *eclass, p, mtype, w) != SQL_OK)
		return GDK_FAIL;
	return GDK_SUCCEED;
}

lng scales[20] = {
	LL_CONSTANT(0),
	LL_CONSTANT(10),
	LL_CONSTANT(100),
	LL_CONSTANT(1000),
	LL_CONSTANT(10000),
	LL_CONSTANT(100000),
	LL_CONSTANT(1000000),
	LL_CONSTANT(10000000),
	LL_CONSTANT(100000000),
	LL_CONSTANT(1000000000),
	LL_CONSTANT(10000000000),
	LL_CONSTANT(100000000000),
	LL_CONSTANT(1000000000000),
	LL_CONSTANT(10000000000000),
	LL_CONSTANT(100000000000000),
	LL_CONSTANT(1000000000000000),
	LL_CONSTANT(10000000000000000),
	LL_CONSTANT(100000000000000000),
	LL_CONSTANT(1000000000000000000)
};

@-
The core modules of Monet provide just a limited set of
mathematical operators. The extensions required to support
SQL-99 are shown below. At some point they also should be
moved to module code base.
@= round
int 
@1_dec_round_wrap( @1 *res, @1 *v, @1 *r )
{
	@1 val = *v;
	@1 add = *r;

	/* shortcut nil */
	if (*v == @1_nil) {
		*res = @1_nil;
		return(GDK_SUCCEED);
	}

	add >>=1;
	if (val < 0) 
		add = -add;
	val += add; 
	val /= *r;
	*res = val;
	return GDK_SUCCEED;
}

int 
@1_round_wrap( @1 *res, @1 *v, int *d, int *s, bte *r )
{
	/* shortcut nil */
	if (*v == @1_nil) {
		*res = @1_nil;
	} else if (-*r > *d) {
		*res = 0;
	} else if (*r > 0 && *r < *s) {
		int dff = *s - *r;
		lng rnd = scales[dff]>>1;
		if (*v > 0)
			*res = (((*v + rnd)/scales[dff])*scales[dff]);
		else
			*res = (((*v - rnd)/scales[dff])*scales[dff]);
	} else if (*r <= 0) {
		int dff = -*r + *s;
		lng rnd = scales[dff]>>1;
		if (*v > 0)
			*res = (((*v + rnd)/scales[dff])*scales[dff]);
		else
			*res = (((*v - rnd)/scales[dff])*scales[dff]);
	}
	return GDK_SUCCEED;
}

int 
str_2dec_@1( @1 *res, str val, int *d, int *sc )
{
	char *s = strip_extra_zeros(val);
	char *dot = strchr(s, '.');
	int digits = _strlen(s) - 1;
	int scale = digits - (dot-s);
	lng value = 0;

	if (!dot) {
		if (GDK_STRNIL(val)) {
			*res = @1_nil;
			return GDK_SUCCEED;
		} else {
			GDKerror("\"%s\" is no decimal value (doesn't contain a '.')", val);
			return GDK_FAIL;
		}
	}
		
	value = decimal_from_str(s);
	if (*s == '+' || *s == '-')
		digits --;
	if (scale < *sc){
		/* the current scale is too small, increase it by adding 0's */
		int d = *sc - scale;	/* CANNOT be 0! */

		value *= scales[d];
		scale += d;
		digits += d;
	} else if (scale > *sc){
		/* the current scale is too big, decrease it by correctly rounding */
		int d = scale - *sc;	/* CANNOT be 0 */
		lng rnd = scales[d]>>1;

		value += rnd;
		value /= scales[d];
		scale -= d;
		digits -= d;
	}
	if (digits > *d) {
		GDKerror("decimal (%s) doesn't have format (%d,%d)", val, *d, *sc);
		return GDK_FAIL;
	}
	*res = (@1) value;
	return GDK_SUCCEED;
}

int
str_2num_@1( @1 *res, str v, int *len )
{
	int zero = 0;
	return str_2dec_@1( res, v, len, &zero );
}
@c
@:round(bte)@
@:round(sht)@
@:round(int)@
@:round(lng)@

@= fround
int 
@1_dec_round_wrap( @1 *res, @1 *v, @1 *r )
{
	@1 val = *v;

	/* not nil */
	if (ATOMcmp(TYPE_@1, v, ATOMnilptr(TYPE_@1)) != 0) {
		val /= *r;
	}
	*res = val;
	return GDK_SUCCEED;
}
@c
@:fround(flt)@
@:fround(dbl)@

@= cast
int
str_2_@1( @1 *res, str val )
{
	ptr p = NULL;
	int len = 0;
	int e; 
	
	e = ATOMfromstr(TYPE_@1, &p, &len, val);
	if (e < 0 || !p || 
	   (ATOMcmp(TYPE_@1, p, ATOMnilptr(TYPE_@1)) == 0 &&
	    ATOMcmp(TYPE_str, val, ATOMnilptr(TYPE_str)) != 0) ) {
		if (p)
			GDKfree(p);
		GDKerror("@1: conversion of string '%s' failed\n", val );
		return GDK_FAIL;
	}
	*res = *(@1*)p;
	if (p)
		GDKfree(p);
	return GDK_SUCCEED;
}
@c
@:cast(bte)@
@:cast(sht)@
@:cast(int)@
@:cast(lng)@
@:cast(flt)@
@:cast(dbl)@
@:cast(timestamp)@
@:cast(daytime)@
@:cast(date)@

int
str_cast(str *res, mvc *M, int *eclass, int *d, int *s, int *has_tz, ptr v, int tpe, int *len)
{
	mvc *m = *(mvc**)M;
	int sz = *len + 1;
	char *r = NULL;

	if (tpe != TYPE_str) {
		r = GDKmalloc(sz);
		sz = convert2str(m, *eclass, *d, *s, *has_tz, v, tpe, &r, *len);
	} else {
		sz = _strlen(v);
		if (*len == 0 || sz <= *len) 
			r = GDKstrdup(v);
	}
	if (*len > 0 && sz > *len) {
		if (r) 
			GDKfree(r);
		if (ATOMcmp(TYPE_str, ATOMnilptr(TYPE_str), v) != 0) {
			GDKerror("str_cast: value too long for type (var)char(%d)\n", *len);
			return GDK_FAIL;
		} else {
			*res = GDKstrdup(str_nil);
			return GDK_SUCCEED;
		}
	}
	*res = r;
	return GDK_SUCCEED;
}

@= simpleupcast
int 
@2_2_@1( @1 *res, @2 *v )
{
	/* shortcut nil */
	if (*v == @2_nil) {
		*res = @1_nil;
		return(GDK_SUCCEED);
	}
	
	/* since the @1 type is bigger than or equal to the @2 type, it will
	   always fit */
	*res = (@1)*v;
	return GDK_SUCCEED;
}
@c

@= simpledowncast
int @2_2_@1( @1 *res, @2 *v )
{
	lng val = *v;

	/* shortcut nil */
	if (*v == @2_nil) {
		*res = @1_nil;
		return(GDK_SUCCEED);
	}
	
	/* see if the number fits in the data type */
	if (val >= GDK_@1_min && val <= GDK_@1_max)	{
		*res = (@1)val;
		return GDK_SUCCEED;
	} else {
		GDKerror("convert: value (" LLFMT ") exceeds limits of type @1\n",val);
		return GDK_FAIL;
	}
}
@c

@= numcastup
@:simpleupcast(@1,@2)@

int 
@2_dec2_@1( @1 *res, int *s1, @2 *v )
{
	int scale = *s1;
	@1 r, h = (*v<0)?-5:5; 

	/* shortcut nil */
	if (*v == @2_nil) {
		*res = @1_nil;
		return(GDK_SUCCEED);
	}

	/* since the @1 type is bigger than or equal to the @2 type, it will
	   always fit */
	r = (@1)*v;
	if (scale) 
		r = (@1) ((r + h) / scales[scale]);
	*res = r;
	return GDK_SUCCEED;
}

int 
@2_dec2dec_@1( @1 *res, int *S1, @2 *v, int *d2, int *S2 )
{
	int p = *d2, inlen = 1;
	@2 cpyval = *v;
	int s1 = *S1, s2 = *S2;
	@1 r, h = (*v<0)?-5:5; 

	/* shortcut nil */
	if (*v == @2_nil) {
		*res = @1_nil;
		return(GDK_SUCCEED);
	}
	
	/* count the number of digits in the input */
	while (cpyval /= 10)
		inlen++;

	/* rounding is allowed */
	inlen += (s2-s1);
	if (p && inlen > p) {
		GDKerror("convert: too many digits (%d > %d)\n", inlen, p);
		return(GDK_FAIL);
	}

	/* since the @1 type is bigger than or equal to the @2 type, it will
	   always fit */
	r = (@1)*v;
	if (s2 > s1) 
		r *= (@1) scales[s2 - s1];
	else if (s2 != s1) 
		r = (@1) ((r + h) / scales[s1 - s2]);
	*res = r;
	return GDK_SUCCEED;
}

int 
@2_num2dec_@1( @1 *res, @2 *v, int *d2, int *s2 )
{
	int zero = 0;
	return @2_dec2dec_@1( res, &zero, v, d2, s2 );
}

@c
@:numcastup(bte,bte)@
@:numcastup(sht,bte)@
@:numcastup(sht,sht)@
@:numcastup(int,bte)@
@:numcastup(int,sht)@
@:numcastup(int,int)@
@:numcastup(lng,bte)@
@:numcastup(lng,sht)@
@:numcastup(lng,int)@
@:numcastup(lng,lng)@

@= fnumcastdown
@:simpledowncast(@1,@2)@

/* when casting a floating point to an decimal we like to preserve the 
 * precision.  This means we first scale the float before converting.
*/
int 
@2_num2dec_@1( @1 *res, @2 *v, int *d2, int *s2 )
{
	int p = *d2, inlen = 1, scale = *s2;
	@2 r;
	lng cpyval;

	/* shortcut nil */
	if (*v == @2_nil) {
		*res = @1_nil;
		return(GDK_SUCCEED);
	}
	
	/* since the @1 type is bigger than or equal to the @2 type, it will
	   always fit */
	r = (@2) *v;
	if (scale) 
		r *= scales[scale];
	cpyval = (lng) r;

	/* count the number of digits in the input */
	while (cpyval /= 10)
		inlen++;
	/* rounding is allowed */
	if (p && inlen > p) {
		GDKerror("convert: too many digits (%d > %d)\n", inlen, p);
		return(GDK_FAIL);
	}
	*res = (@1) r;
	return GDK_SUCCEED;
}
@c
@:fnumcastdown(bte,flt)@
@:fnumcastdown(sht,flt)@
@:fnumcastdown(int,flt)@
@:fnumcastdown(lng,flt)@
@:fnumcastdown(bte,dbl)@
@:fnumcastdown(sht,dbl)@
@:fnumcastdown(int,dbl)@
@:fnumcastdown(lng,dbl)@

@= fnumcastup
@:simpleupcast(@1,@2)@

int 
@2_dec2_@1( @1 *res, int *s1, @2 *v )
{
	int scale = *s1;
	@1 r;

	/* shortcut nil */
	if (*v == @2_nil) {
		*res = @1_nil;
		return(GDK_SUCCEED);
	}
	
	/* since the @1 type is bigger than or equal to the @2 type, it will
	   always fit */
	r = (@1)*v;
	if (scale) 
		r /= scales[scale];
	*res = r;
	return GDK_SUCCEED;
}

int 
@2_dec2dec_@1( @1 *res, int *S1, @2 *v, int *d2, int *S2 )
{
	int p = *d2, inlen = 1;
	@2 cpyval = *v;
	int s1 = *S1, s2 = *S2;
	@1 r;

	/* shortcut nil */
	if (*v == @2_nil) {
		*res = @1_nil;
		return(GDK_SUCCEED);
	}
	
	/* count the number of digits in the input */
	while (cpyval /= 10)
		inlen++;
	/* rounding is allowed */
	inlen += (s2-s1);
	if (p && inlen > p) {
		GDKerror("convert: too many digits (%d > %d)\n", inlen, p);
		return(GDK_FAIL);
	}

	/* since the @1 type is bigger than or equal to the @2 type, it will
	   always fit */
	r = (@1)*v;
	if(s2 > s1) 
		r *= scales[s2-s1];
	else if (s2 != s1) 
		r /= scales[s1-s2];
	*res = r;
	return GDK_SUCCEED;
}
int 
@2_num2dec_@1( @1 *res, @2 *v, int *d2, int *s2 )
{
	int zero = 0;
	return @2_dec2dec_@1( res, &zero, v, d2, s2 );
}

@c
@:fnumcastup(flt,bte)@
@:fnumcastup(flt,sht)@
@:fnumcastup(flt,int)@
@:fnumcastup(flt,lng)@
@:fnumcastup(dbl,bte)@
@:fnumcastup(dbl,sht)@
@:fnumcastup(dbl,int)@
@:fnumcastup(dbl,lng)@

@c
@= numcastdown
@:simpledowncast(@1,@2)@

int 
@2_dec2_@1( @1 *res, int *s1, @2 *v )
{
	int scale = *s1;
	lng val = *v, h = (val<0)?-5:5;

	/* shortcut nil */
	if (*v == @2_nil) {
		*res = @1_nil;
		return(GDK_SUCCEED);
	}
	
	if (scale) 
		val = (val+h)/scales[scale];
	/* see if the number fits in the data type */
	if (val >= GDK_@1_min && val <= GDK_@1_max)	{
		*res = (@1)val;
		return GDK_SUCCEED;
	} else {
		GDKerror("convert: value (" LLFMT ") exceeds limits of type @1\n",val);
		return GDK_FAIL;
	}
}

int 
@2_dec2dec_@1( @1 *res, int *S1, @2 *v, int *d2, int *S2 )
{
	int p = *d2, inlen = 1;
	lng val = *v, cpyval = val, h = (val<0)?-5:5;
	int s1 = *S1, s2 = *S2;

	/* shortcut nil */
	if (*v == @2_nil) {
		*res = @1_nil;
		return(GDK_SUCCEED);
	}
	
	/* count the number of digits in the input */
	while (cpyval /= 10)
		inlen++;
	/* rounding is allowed */
	inlen += (s2-s1);
	if (p && inlen > p) {
		GDKerror("convert: too many digits (%d > %d)\n", inlen, p);
		return(GDK_FAIL);
	}

	if(s2 > s1) 
		val *= scales[s2-s1];
	else if (s2 != s1) 
		val = (val+h)/scales[s1-s2];

	/* see if the number fits in the data type */
	if (val >= GDK_@1_min && val <= GDK_@1_max)	{
		*res = (@1)val;
		return GDK_SUCCEED;
	} else {
		GDKerror("convert: value (" LLFMT ") exceeds limits of type @1\n",val);
		return GDK_FAIL;
	}
}

int 
@2_num2dec_@1( @1 *res, @2 *v, int *d2, int *s2 )
{
	int zero = 0;
	return @2_dec2dec_@1( res, &zero, v, d2, s2 );
}
@c
@:numcastdown(bte,sht)@
@:numcastdown(bte,int)@
@:numcastdown(bte,lng)@
@:numcastdown(sht,int)@
@:numcastdown(sht,lng)@
@:numcastdown(int,lng)@

int 
month_interval_str( int *ret, str s, int *ek, int *sk )
{
	lng res;

	if (interval_from_str( s, *sk, *ek, &res ) < 0)
		return GDK_FAIL;
	*ret = (int) res;
	return GDK_SUCCEED;
}

int 
second_interval_str( lng *res, str s, int *ek, int *sk )
{

	if (interval_from_str( s, *sk, *ek, res ) < 0)
		return GDK_FAIL;
	return GDK_SUCCEED;
}

@= c_interval
int 
month_interval_@1( int *ret, @1 *s, int *ek, int *sk ){
	int r = (int)*s;

	(void)ek;
	switch(*sk) {
	case iyear: 	
		r *= 12;
	case imonth:
		break;
	default:
		return GDK_FAIL;
	}
	*ret = r;
	return GDK_SUCCEED;
}
int 
second_interval_@1( lng *res, @1 *s, int *ek, int *sk ){
	lng r = *s;

	(void)ek;
	switch(*sk) {
	case iday: 	
		r *= 24;
	case ihour:
		r *= 60;
	case imin:
		r *= 60;
	case isec:
		break;
	default:
		return GDK_FAIL;
	}
	*res = r;
	return GDK_SUCCEED;
}
@c

@:c_interval(bte)@
@:c_interval(sht)@
@:c_interval(int)@
@:c_interval(lng)@

int 
zero_or_one(ptr ret, BAT* b) 
{
	ptr p;
	int c = BATcount(b);
	int _s = ATOMsize(ATOMtype(b->ttype));

	if (c == 0) {
		p = ATOMnilptr(b->ttype);
	} else if (c == 1) {
		BATiter bi = bat_iterator(b);
		p = BUNtail(bi,BUNfirst(b));
	} else {
		p = NULL;
		GDKerror("zero_or_one: cardinality violation (%d>1)", c);
		return GDK_FAIL;
	}
	if (ATOMextern(b->ttype)) {
		_s = ATOMlen(ATOMtype(b->ttype), p);
		memcpy(*(ptr*) ret=GDKmalloc(_s), p, _s);
	} else if (b->ttype == TYPE_bat) {
		bat bid = *(bat*)p;
		*(BAT**) ret = BATdescriptor(bid);
	} else if (_s == 4) {
		*(int*) ret = *(int*)p;
	} else if (_s == 1) {
		*(bte*) ret = *(bte*)p;
	} else if (_s == 2) {
		*(sht*) ret = *(sht*)p;
	} else if (_s == 8) {
		*(lng*) ret = *(lng*)p;
	} else {
		memcpy(ret, p, _s);
	}
	return GDK_SUCCEED;
}

int not_unique(bit *ret, BAT* b) 
{
	*ret = FALSE;
	if (b->tkey || b->tdense || BATcount(b) <= 1) {
		return GDK_SUCCEED;
	} else if (b->tsorted&1) {
		BUN p,q;

		oid c = *(oid*)Tloc(b, BUNfirst(b)); 
		for(p=BUNfirst(b)+1, q=BUNlast(b); p<q; p++) {
			oid v = *(oid*)Tloc(b,p);
			if (v<=c) {
				*ret = TRUE;
				break;
			}
			c = v;
		}
	} else {
		return GDK_FAIL;
	}
	return GDK_SUCCEED;
}

@-
An SQL session needs a minimal set of modules, shown below.
The MIL procs should also be moved to the kernel, despite the
fact that they are rather SQL specific.
@mil
module(alarm);
module(xtables);
module(aggrX3);
module(monettime);
module(blob);
module(txtsim);
module(mmath);
module(mkey);
module(bat_arith);
module(pcre); # likeselect_pcre
module(pqueue); # pqueue_topn
module(mapi); # mapi_listen 

# low memory usage for testing unloading
#mem_maxsize(0LL);
#vm_maxsize(0LL);

proc sql_environment() : BAT[str,BAT] {
	var b := new(str,bat,2);
	var e := environment();
	b.insert("name", e.mark(0@0).reverse());
	b.insert("value", e.reverse().mark(0@0).reverse());
	return b;
}

proc bbp() : BAT[str,BAT] {
	var b := new(str,bat,12);
	b.insert("id", view_bbp_name().hmark(0@0)); 
	b.insert("name", view_bbp_name().tmark(0@0));
	b.insert("htype", view_bbp_htype().tmark(0@0));
	b.insert("ttype", view_bbp_ttype().tmark(0@0));
	b.insert("count", view_bbp_count().tmark(0@0));
	b.insert("refcnt", view_bbp_refcnt().tmark(0@0));
	b.insert("lrefcnt", view_bbp_lrefcnt().tmark(0@0));
	b.insert("location", view_bbp_location().tmark(0@0));
	b.insert("heat", view_bbp_heat().tmark(0@0));
	b.insert("dirty", view_bbp_dirty().tmark(0@0));
	b.insert("status", view_bbp_status().tmark(0@0));
	b.insert("kind", view_bbp_kind().tmark(0@0));
	return b;
}


proc daytime ( lng s ) : daytime {
	return add(daytime(0), s*lng(1000));
}

proc sql_diff (bat[any::1,any::2] b1, bat[any::1,any::3] b2) : bat[any::1,any::2] {
	if (count(b2) > 0) 
		return kdiff(b1,b2);
	return b1;
}

proc sql_union (bat[any::1,any::2] b1, bat[any::1,any::2] b2) : bat[any::1,any::2] {
#	if (count(b1) = 0)
#		return b2;
#	if (count(b2) > 0)
		return kunion(b1,b2);
#	return b1;
}

proc sql_semijoin (bat[oid,any::1] b1, bat[oid,any::2] b2) : bat[oid,any::1] {
	var x := b2.mirror();
	return x.join(b1);
}

proc log2(int i) : int {
  var n := 0;
  while(i > 1)  {
     i >>= 1;
     n :+= 1;
  }
  return n;
}

# forward reference, will be filled in the sql session 
var myc := mvc(ptr(nil));
proc next_value( str sname, str v ) : lng {
	return mvc_next_value(myc, sname, v);
}
proc [next_value]( bat[oid,str] snames, str v ) : lng {
	return [mvc_next_value](myc, snames, v);
}
proc get_value( str sname, str v ) : lng {
	return mvc_get_value(myc, sname, v);
}
proc restart( str sname, str seq, lng v ) : lng {
	return mvc_restart_seq(myc, sname, seq, v);
}

proc SQLgroup(BAT[oid,any] a) : grp {
	# handle the grouping for unique checks with the special _CTgroup 
	if (and(or((a.ttype()=int),(a.ttype()=lng)),(a.count()>(256*1024)))) {
		var N := (max(a) - min(a));
		if (or((N.type()=lng),isnil(N)))
			N := a.count();
		if (or((N > a.count()),(N<0)))
			N := a.count();
		if (or((N = 0),(log2(N)=0))) {
			return 1;
		}
		return _CTgroup(a, log2(N), 1); 
	}
	return CTgroup(a);
}

proc [rotate_xor_hash](BAT[any::1,int] h, int nbits, BAT[any::1, any] b) : BAT[any::1,int] {
	h.access(BAT_WRITE);
	return [:rotate_xor_hash=](h,nbits,b);
}

proc in (bat[any::1,any::2] b, any::2 v) : bit { return b.reverse().exist(v); }
proc in (any::2 b, any::2 v) : bit { return (b = v); }
proc [identity](bat[oid,any::1] b) : bat[oid,oid] { return mirror(b); }

proc {mark_grp}(BAT[oid,any::1] b, any::2 a, BAT[oid,oid] g) : BAT[oid,int] {
	return [int](mark_grp(b,g,0@0));
}
proc mark_grp(BAT[oid,any::1] b) : BAT[oid,int] {
	return [int](mark(b,0@0));
}
proc {rank_grp}(BAT[oid,any::1] b, BAT[oid,oid] gp, BAT[oid,oid] gpe) : BAT[oid,int] {
	var g := CTderive(gp,b);
	var m := g.map();
	var e := [int](g.extend().mirror());
	return join(m, e);
}
proc rank_grp(BAT[oid,any::1] b) : BAT[oid,int] {
	var g := CTgroup(b);
	var m := g.map();
	var e := [int](g.extend().mirror());
	return join(m, e);
}
proc rand(int v) : int {
	return rand();
}

tzone_local(TIMEZONE("GMT"));

proc sql_server_start() : void {
	var fc := nil;
	var err := CATCH({ fc := sql_frontend(); });

	if (isnil(err)) {
		mapi_register(fc);
		if (monet_environment.find("gdk_embedded") = "no") {
			fork(sqllogmanager());
		}
		return str(nil);
	} else {
		printf(err);
	}
}

sql_server_start();
if (monet_environment.find("monet_welcome") = "yes") 
    printf("%c MonetDB/SQL module v2.21.0 loaded\n", int(35));
    #                              ^^^^^^
    # Maintained via vertoo. Please don't modify by hand!
    # Contact MonetDB-developers@lists.sourceforge.net for details and/or assistance.
