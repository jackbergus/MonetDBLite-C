@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2006 CWI.
@' All Rights Reserved.

@f sql_server
@a N.J. Nes, M.L. Kersten
@* 
The sql_server module contains the complete wrapper interface for the
SQL client and the corresponding MIL runtime startup.

The implementation described here is focused on using the Mapi library
for interaction. This provides a simple textual interface to the server
based on ASCII text.

It is intended to work directly with any of the MapiClient implementations.
To avoid clashes with the default port settings, we have hardwired a number
for the time being.
@m
.MODULE sql_server;
	.USE ascii_io, monettime; 

	.ATOM mvc = ptr;
	.END;

	.BUILTIN sql_frontend() : ptr = sql_frontend_wrap;
		"create/return the sql_frontend"

	.COMMAND sql_trace() : void = sql_trace;
		"enable/disable saving the sql statement traces (per client)" 

@+ extra low level interface 
@m
	.BUILTIN mvc_new() : mvc = mvc_new;
	"create a sql contect"

	.command mvc_destroy(mvc m, int commit) = mvc_destroy_wrap;
	"commit/abort and destroy sql contect"
@+ 
@m

	.BUILTIN sqlconsole( ) = sqlconsole;
	"Read sql statements from stdin and output results on stdout"

	.COMMAND sqllogmanager() = sqllogmanager;
		"The log manager takes care of keeping the logs small, ie. it merges the changes into bats and abandons the logs"

@-
The session is interpreted in the context of a globally
known catalog. It is commonly represented by a variable
in the user context and should be provided to all commands.
No sanity check is performed on its validity and authorized
access after being logged in.
@m
	.COMMAND mvc_sql( mvc m, str cmd ) = mvc_sql_wrap;
		"execute a sql query"

	.COMMAND mvc_update_var( mvc m, str varname ) = mvc_update_var_wrap;
		"update a session variable in the mvc structure"

	.COMMAND mvc_next_value( mvc m, str sequence ) : lng = mvc_next_value;
		"return the next value of the sequence"
@-
The updates against the relational tables are collected in separate
BATs until transaction commit. 
The code produced by the SQL->MIL compiler uses it to propagate
the updates to the persistent versions.
@m
	.COMMAND mvc_bind( mvc c, str sname, str tname, str cname, int access ) : 
		BAT[any::1,any::2] = 
		mvc_bind_wrap; "Bind the bat, tname.cname"

	.COMMAND mvc_append( mvc c, str sname, str tname, str cname, int access, BAT[oid,any::1] b ) : 
		BAT[void,any::1] = 
		mvc_append; "Append b to the column, tname.cname (possibly optimized to a replace the insert bat of tname.cname"

	.COMMAND mvc_bind_dbat( mvc c, str sname, str tname, int access ) : 
		BAT[any::1,any::2] = mvc_bind_dbat_wrap; 
		"Bind the table deletes bat, tname.deletes"

	.COMMAND mvc_bind_idxbat( mvc c, str sname, str tname, str iname, int access ) : 
		BAT[any::1,any::2] = mvc_bind_idxbat_wrap; 
		"Bind the idx table"

	.COMMAND mvc_append_idxbat( mvc c, str sname, str tname, str iname, int access, BAT[oid,any::1] b ) : 
		BAT[void,any::1] = mvc_append_idxbat; 
		"Bind the idx table"
@-
A special clear table function is required for an efficient DELETE ALL implementation. A table clear requires global table knowledge. 
@m
	.COMMAND mvc_clear_table( mvc c, str sname, str tname ) :
		lng = mvc_clear_table_wrap;
		"Clear table" 
@-
The results of the SQL queries are assembled in result sets, which
can be shipped to the front-end for display or exported over a
stream.
@m
	.COMMAND mvc_result_table( mvc m, int nr_cols, int type, any order ) : int = mvc_result_row_wrap; "Create structure to cache a row query result" 

	.COMMAND mvc_result_table( mvc m, int nr_cols, int type, BAT[oid,any] order ) : int = mvc_result_table_wrap; "Create structure to cache a table query result" 

	.COMMAND mvc_result_column( mvc m, str tname, str name, str typename, int digits, int scale, any val) = mvc_result_value_wrap; "Add the value to the row query result"
	.COMMAND mvc_result_column( mvc m, str tname, str name, str typename, int digits, int scale, BAT[oid,any] col) = mvc_result_column_wrap; "Add the colunm to the table query result"

	.COMMAND mvc_schema_operation(mvc m, Stream s) =
		mvc_export_schema_wrap; "export a schema operation to stream s"

	.COMMAND mvc_export_result(mvc m, Stream s, int result_id) =
		mvc_export_result_wrap; "export a result to stream s"

	.COMMAND mvc_affected_rows(mvc m, Stream s, int cnt) =
		mvc_affected_rows_int; "export the number of affected rows by the current query to stream s"

	.COMMAND mvc_affected_rows(mvc m, Stream s, lng cnt) =
		mvc_affected_rows_wrap; "export the number of affected rows by the current query to stream s"

	.COMMAND mvc_export_value(mvc m, Stream s, int qtype, str tname, str name, str typename, int digits, int scale, int eclass, any val ) =
		mvc_export_value_wrap; "export a single value onto the stream s"

	.COMMAND mvc_import_table( mvc c, Bstream s, str tname, 
					str sep, str rsep, int nr) : 
		BAT[str,BAT] = mvc_import_table_wrap; 
		"import a table from stream s with the given tuple and record seperators (sep/rsep)"

@= mel_round
	.COMMAND round( @1 v, @1 r ) : @1 = @1_round_wrap; "round off the value v to nearests multiple of r"
@m

@:mel_round(sht)@
@:mel_round(int)@
@:mel_round(lng)@

@m
	.COMMAND round( flt v, flt r ) : flt = flt_round_wrap; "round off the value v to nearests multiple of r"

	.COMMAND round( dbl v, dbl r ) : dbl = dbl_round_wrap; "round off the value v to nearests multiple of r"

@= mel_cast
 .COMMAND @1( str v ) : @1 = str_2_@1; "cast to @1 and check for overflow"
 .COMMAND @1( str v, int digits ) : @1 = str_2num_@1; "cast to @1 and check for overflow"
 .COMMAND @1( str v, int digits, int scale ) : @1 = str_2dec_@1; "cast to dec(@1) and check for overflow"
@m
@:mel_cast(sht)@
@:mel_cast(int)@
@:mel_cast(lng)@

@= mel_castfromstr
 .COMMAND @1( str v ) : @1 = str_2_@1; "cast to @1"
@m
@:mel_castfromstr(flt)@
@:mel_castfromstr(dbl)@
@:mel_castfromstr(timestamp)@
@:mel_castfromstr(daytime)@
@:mel_castfromstr(date)@

 .COMMAND "str"( mvc m, int eclass, int d1, int s1, int has_tz, any v, int d2 ) : str = str_cast; "cast to string and check for overflow"

@= mel_cast_2dec
 .COMMAND @1( @2 v ) : @1 = @2_2_@1; "cast @2 to @1 and check for overflow"
 .COMMAND @1( @2 v, int d2, int s2 ) : @1 = @2_num2dec_@1; "cast number to decimale(@1) and check for overflow"
@m

@:mel_cast_2dec(sht,flt)@
@:mel_cast_2dec(int,flt)@
@:mel_cast_2dec(lng,flt)@
@:mel_cast_2dec(sht,dbl)@
@:mel_cast_2dec(int,dbl)@
@:mel_cast_2dec(lng,dbl)@

@= mel_cast_dec2
 .COMMAND @1( int s1, @2 v ) : @1 = @2_dec2_@1; "cast decimal(@2) to @1 and check for overflow"
 .COMMAND @1( int s1, @2 v, int d2, int s2 ) : @1 = @2_dec2dec_@1; "cast decimal(@2) to decimale(@1) and check for overflow"
@m

@= mel_cast2
@:mel_cast_2dec(@1,@2)@
@:mel_cast_dec2(@1,@2)@
@m

@:mel_cast2(sht,sht)@
@:mel_cast2(sht,int)@
@:mel_cast2(sht,lng)@
@:mel_cast2(int,sht)@
@:mel_cast2(int,int)@
@:mel_cast2(int,lng)@
@:mel_cast2(lng,sht)@
@:mel_cast2(lng,int)@
@:mel_cast2(lng,lng)@
@:mel_cast2(flt,sht)@
@:mel_cast2(flt,int)@
@:mel_cast2(flt,lng)@
@:mel_cast2(dbl,sht)@
@:mel_cast2(dbl,int)@
@:mel_cast2(dbl,lng)@

@= mel_interval
 .COMMAND month_interval( @1 v, int ek, int sk ) : int = month_interval_@1; "cast @1 to a month_interval and check for overflow"

 .COMMAND second_interval( @1 v, int ek, int sk ) : lng = second_interval_@1; "cast @1 to a month_interval and check for overflow"
@m

@:mel_interval(str)@
@:mel_interval(sht)@
@:mel_interval(int)@
@:mel_interval(lng)@

.END sql_server;

@-
The implementation below mostly wraps around the primitives
provided in the SQL server code base. The wrapper handles
conversion from the MIL interpretation context to direct
handles and returns proper error messages upon failure.
@h
#ifndef _SQL_SERVER_H_
#define _SQL_SERVER_H_

#include <sql_mem.h>
#include <streams.h>
#include <ascii_io.h>
#include <monettime.h>
#include <monet_context.h>
#include "sql_mvc.h"
#include "sql_server.proto.h"

#endif /*_SQL_SERVER_H_*/

@c
#include "sql_server.h"
#include "sql_result.h"
#include "sql_privileges.h"
#include "sql_session.h"
#include <sql_decimal.h>
#include <sql_string.h>
#include <sql_datetime.h>
#include <sql_env.h>
#include <algebra.h>
#include <bat/bat_store.h>
#include <bat/res_table.h>
#include <bat/bat_bm.h>
#include <bat/bat_sequence.h>

@-
The code heavily depends on the (complex) data structures for
both program representation (YYSTREE), runtime stack (Cntxt),
and the MIL interpreter. Details can be found in the src/monet
directory.
@c
static int
builtin_operand(Cntxt stk, YYSTREE lt, int arg_nr, ptr *Res, int type, ValPtr res)
{
	int k = interpret(stk, arg(lt, arg_nr), res);

	if (k < 0)
		return k;
	*Res = VALconvert(type, res);
	if ((res == ILLEGALVALUE) || (type == TYPE_bat && res)) {
		return handle_paramerror(res, arg_nr, res->vtype, type);
	}
	return 0;
}

void
monet4_freestack(backend_stack stk)
{
	Cntxt procstk = (Cntxt) (ptrdiff_t) stk;

	monet_cntxt[procstk].reuse = FALSE;
	CNTXTclear(procstk);
	CNTXTfree1(procstk);
	CNTXTdelete(procstk);
}

void
monet4_freecode(backend_code code, backend_stack stk, int nr, char *name)
{
	YYSTREE callnode = (YYSTREE) code;

	(void)nr;
	if (code) {
		Client client;

		/* free proc */
		Myyfree(callnode);

		/* deregister proc */
		CNTXTclient((Cntxt) (ptrdiff_t) stk, &client);
		TBL_delproc(client, name);
	}
}

int
sql_frontend_wrap(Cntxt stk, YYSTREE lt, ValPtr res)
{
	Client father = NULL;

	if (lt->cnt != 0) 
		return handle_argerror(res, lt->cnt, 0);

	backend_init(&monet4_freestack, &monet4_freecode, &monet4_parse);
	CNTXTclient(stk, &father);
	if (father && father->father >= 0) {
		/* if the father itself is a temporary client, let
		 * the new child depend on the grandfather.
		 * so: father always points to a real client session!
		 */
		father = monet_clients + father->father;
	}
	if (father)
		stk = father->stk;
	if (mvc_init(0, (backend_stack) stk) < 0) {
		return GDK_FAIL;
	}
	res->vtype = TYPE_ptr;
	res->val.pval = (ptr) sql_frontend();
	return GDK_SUCCEED;
}

int
sqllogmanager()
{
	mvc_logmanager();
	return GDK_SUCCEED;	
}

int
mvc_sql_wrap(mvc *c, str cmd)
{
	return mvc_sql(*(mvc **) c, cmd);
}

int
mvc_update_var_wrap(mvc *c, str varname)
{
	return sql_update_var(*(mvc **) c, varname);
}

int
mvc_next_value(lng *res, mvc *c, str seq)
{
	if (sql_next_value((*(mvc **) c)->session->tr, seq, res))
		return GDK_SUCCEED;
	return GDK_FAIL;
}

static BAT *
mvc_bind(mvc *m, char *sname, char *tname, char *cname, int access)
{
	sql_trans *tr = m->session->tr;
	BAT *b = NULL;
	sql_schema *s = mvc_bind_schema(m, sname);
	sql_table *t = mvc_bind_table(m, s, tname);
	sql_column *c = mvc_bind_column(m, t, cname);

	if (access == UPD || access == RD_UPD)
		b = bind_ubat(tr, c, access);
	else
		b = bind_bat(tr, c, access);
	return b;
}

int 
mvc_append(BAT **b, mvc *M, str sname, str tname, str cname, int *access, BAT *i)
{
	mvc *m = *(mvc**)M;
	sql_trans *tr = m->session->tr;
	sql_schema *s = mvc_bind_schema(m, sname);
	sql_table *t = mvc_bind_table(m, s, tname);
	sql_column *c = mvc_bind_column(m, t, cname);

	if (*access == UPD || *access == RD_UPD)
		*b = append_ubat(tr, c, *access, i);
	else
		*b = append_bat(tr, c, *access, i);
	return GDK_SUCCEED;
}


static BAT *
mvc_bind_dbat(mvc *m, char *sname, char *tname, int access)
{
	sql_trans *tr = m->session->tr;
	BAT *b = NULL;
	sql_schema *s = mvc_bind_schema(m, sname);
	sql_table *t = mvc_bind_table(m, s, tname);

	b = bind_dbat(tr, t, access);
	return b;
}

static BAT *
mvc_bind_idxbat(mvc *m, char *sname, char *tname, char *iname, int access)
{
	sql_trans *tr = m->session->tr;
	BAT *b = NULL;
	sql_schema *s = mvc_bind_schema(m, sname);
	sql_idx *i = mvc_bind_idx(m, s, iname);

	(void) tname;
	if (access == UPD || access == RD_UPD)
		b = bind_uidx(tr, i, access);
	else
		b = bind_idx(tr, i, access);
	return b;
}

int
mvc_append_idxbat(BAT **b, mvc *M, char *sname, char *tname, char *iname, int *access, BAT *ib)
{
	mvc *m = *(mvc**)M;
	sql_trans *tr = m->session->tr;
	sql_schema *s = mvc_bind_schema(m, sname);
	sql_idx *i = mvc_bind_idx(m, s, iname);

	(void) tname;
	if (*access == UPD || *access == RD_UPD)
		*b = append_uidx(tr, i, *access, ib);
	else
		*b = append_idx(tr, i, *access, ib);
	return GDK_SUCCEED;
}



int
mvc_bind_wrap(BAT **res, mvc *c, str sname, str tname, str cname, int *access)
{
	*res = mvc_bind(*(mvc **) c, sname, tname, cname, *access);
	if (*res) {
		return GDK_SUCCEED;
	}
	return GDK_FAIL;
}

int
mvc_bind_dbat_wrap(BAT **res, mvc *c, str sname, str tname, int *access)
{
	*res = mvc_bind_dbat(*(mvc **) c, sname, tname, *access);
	if (*res) {
		return GDK_SUCCEED;
	}
	return GDK_FAIL;
}

int
mvc_bind_idxbat_wrap(BAT **res, mvc *c, str sname, str tname, str iname, int *access)
{
	*res = mvc_bind_idxbat(*(mvc **) c, sname, tname, iname, *access);
	if (*res) {
		return GDK_SUCCEED;
	}
	return GDK_FAIL;
}

int
mvc_clear_table_wrap(lng *res, mvc *c, str sname, str tname)
{
	mvc *m = *(mvc **) c;
	sql_schema *s = mvc_bind_schema(m, sname);
	sql_table *t = mvc_bind_table(m, s, tname);

	*res = mvc_clear_table(m, t);
	return GDK_SUCCEED;
}

static int
mvc_result_row(mvc *m, int nr_cols, int qtype)
{
	m->results = res_table_create(m->session->tr, m->result_id++, nr_cols, qtype, m->results);
	return m->results->id;
}


int
mvc_result_table_wrap(int *res_id, mvc *M, int *nr_cols, int *qtype, BAT *order)
{
	*res_id = mvc_result_table(*(mvc **) M, *nr_cols, *qtype, order);
	if (*res_id < 0)
		return GDK_FAIL;
	return GDK_SUCCEED;
}

int
mvc_result_row_wrap(int *res_id, mvc *M, int *nr_cols, int *qtype, ptr p, int p_type)
{
	(void) p;
	(void) p_type;		/* Stefan: unused!? */

	*res_id = mvc_result_row(*(mvc **) M, *nr_cols, *qtype);
	if (*res_id < 0)
		return GDK_FAIL;
	return GDK_SUCCEED;
}

int
mvc_result_column_wrap(mvc *M, str tn, str name, str type, int *digits, int *scale, BAT *b)
{
	if (mvc_result_column(*(mvc **) M, tn, name, type, *digits, *scale, b))
		return GDK_FAIL;
	return GDK_SUCCEED;
}

int
mvc_result_value_wrap(mvc *M, str tn, str name, str type, int *digits, int *scale, ptr p, int mtype)
{
	if (mvc_result_value(*(mvc **) M, tn, name, type, *digits, *scale, p, mtype))
		return GDK_FAIL;
	return GDK_SUCCEED;
}

int
mvc_import_table_wrap(BAT **res, mvc *c, Bstream *s, str tname, str sep, str rsep, int *sz)
{
	*res = mvc_import_table(*(mvc **) c, *(bstream **) s, tname, sep, rsep, *sz);
	if (*res == NULL)
		return GDK_FAIL;
	return GDK_SUCCEED;
}

int
mvc_export_result_wrap(mvc *M, Stream *S, int *res_id)
{
	if (mvc_export_result(*(mvc **) M, *(stream **) S, *res_id))
		return GDK_FAIL;

	return GDK_SUCCEED;
}

int
mvc_export_schema_wrap(mvc *M, Stream *S)
{
	if (mvc_export_operation(*(mvc **) M, *(stream **) S))
		return GDK_FAIL;

	return GDK_SUCCEED;
}

int
mvc_affected_rows_wrap(mvc *M, Stream *S, lng *nr)
{
	stream *s = *(stream**)S;
	mvc *m = *(mvc**)M;

	m->type = Q_UPDATE;
	if (mvc_export_affrows(m, s, *nr))
		return GDK_FAIL;

	return GDK_SUCCEED;
}

int
mvc_affected_rows_int(mvc *M, Stream *S, int *nr)
{
	lng N = *nr;
	return mvc_affected_rows_wrap(M, S, &N);
}

int
mvc_export_value_wrap(mvc *M, Stream *S, int *qtype, str tn, str name, str type, int *digits, int *scale, int *eclass, ptr p, int mtype)
{
	if (mvc_export_value(*(mvc **) M, *(stream **)S, *qtype, tn, name, type, *digits, *scale, *eclass, p, mtype) != SQL_OK)
		return GDK_FAIL;
	return GDK_SUCCEED;
}

@-
The core modules of Monet provide just a limited set of
mathematical operators. The extensions required to support
SQL-99 are shown below. At some point they also should be
moved to module code base.
@= round
int @1_round_wrap( @1 *res, @1 *v, @1 *r )
{
	@1 val = *v;
	@1 add = *r;

	/* shortcut nil */
	if (*v == @1_nil) {
		*res = @1_nil;
		return(GDK_SUCCEED);
	}

	add >>=1;
	if (val < 0) 
		add = -add;
	val += add; 
	val /= *r;
	*res = val;
	return GDK_SUCCEED;
}

int str_2dec_@1( @1 *res, str val, int *d, int *sc )
{
	char *s = strip_extra_zeros(val);
	char *dot = strchr(s, '.');
	int digits = strlen(s) - 1;
	int scale = digits - (dot-s);
	lng value = 0;

	if (!dot) {
		GDKerror("\"%s\" is no decimal value (doesn't contain a '.')", val);
		return GDK_FAIL;
	}
		
	value = decimal_from_str(s);
	if (*s == '+' || *s == '-')
		digits --;
	if (scale < *sc) {
		/* the current scale is too small, increase it by adding 0's */
		int d = *sc - scale;	/* CANNOT be 0! */
		value *= d * 10;
		scale += d;
		digits += d;
	} else if (scale > *sc) {
		/* the current scale is too big, decrease it by correctly rounding */
		int d = scale - *sc;	/* CANNOT be 0 */
		value /= (d - 1) * 10;
		if (value % 10 >= 5) 
			value += 10;
		value /= 10;
		scale -= d;
		digits -= d;
	}
	if (digits > *d) {
		GDKerror("decimal (%s) doesn't have format (%d,%d)", val, *d, *sc);
		return GDK_FAIL;
	}
	*res = (@1) value;
	return GDK_SUCCEED;
}

int
str_2num_@1( @1 *res, str v, int *len )
{
	int zero = 0;
	return str_2dec_@1( res, v, len, &zero );
}
@c
@:round(sht)@
@:round(int)@
@:round(lng)@

@= fround
int @1_round_wrap( @1 *res, @1 *v, @1 *r )
{
	@1 val = *v;

	/* not nil */
	if (ATOMcmp(TYPE_@1, v, ATOMnilptr(TYPE_@1)) != 0) {
		val /= *r;
	}
	*res = val;
	return GDK_SUCCEED;
}
@c
@:fround(flt)@
@:fround(dbl)@

@= cast
int
str_2_@1( @1 *res, str val )
{
	ptr p = NULL;
	int len = 0;
	int e; 
	
	e = ATOMfromstr(TYPE_@1, &p, &len, val);
	if (e < 0 || !p || 
	   (ATOMcmp(TYPE_@1, p, ATOMnilptr(TYPE_@1)) == 0 &&
	    ATOMcmp(TYPE_str, val, ATOMnilptr(TYPE_str)) != 0) ) {
		if (p)
			GDKfree(p);
		GDKerror("@1: conversion of string '%s' failed\n", val );
		return GDK_FAIL;
	}
	*res = *(@1*)p;
	if (p)
		GDKfree(p);
	return GDK_SUCCEED;
}
@c
@:cast(sht)@
@:cast(int)@
@:cast(lng)@
@:cast(flt)@
@:cast(dbl)@
@:cast(timestamp)@
@:cast(daytime)@
@:cast(date)@

int
str_cast(str *res, mvc *M, int *eclass, int *d, int *s, int *has_tz, ptr v, int tpe, int *len)
{
	mvc *m = *(mvc**)M;
	int sz = *len + 1;
	char *r = NULL;

	if (tpe != TYPE_str) {
		r = GDKmalloc(sz);
		sz = convert2str(m, *eclass, *d, *s, *has_tz, v, tpe, &r, *len);
	} else {
		sz = strlen(v);
		if (*len == 0 || sz <= *len) 
			r = GDKstrdup(v);
	}
	if (*len > 0 && sz > *len) {
		GDKfree(r);
		if (ATOMcmp(TYPE_str, ATOMnilptr(TYPE_str), v) != 0) {
			GDKerror("str_cast: value too long for type (var)char(%d)\n", *len);
			return GDK_FAIL;
		} else {
			*res = GDKstrdup(str_nil);
			return GDK_SUCCEED;
		}
	}
	*res = r;
	return GDK_SUCCEED;
}

lng scales[20] = {
	LL_CONSTANT(0),
	LL_CONSTANT(10),
	LL_CONSTANT(100),
	LL_CONSTANT(1000),
	LL_CONSTANT(10000),
	LL_CONSTANT(100000),
	LL_CONSTANT(1000000),
	LL_CONSTANT(10000000),
	LL_CONSTANT(100000000),
	LL_CONSTANT(1000000000),
	LL_CONSTANT(10000000000),
	LL_CONSTANT(100000000000),
	LL_CONSTANT(1000000000000),
	LL_CONSTANT(10000000000000),
	LL_CONSTANT(100000000000000),
	LL_CONSTANT(1000000000000000),
	LL_CONSTANT(10000000000000000),
	LL_CONSTANT(100000000000000000),
	LL_CONSTANT(1000000000000000000)
};

@= simpleupcast
int @2_2_@1( @1 *res, @2 *v )
{
	/* shortcut nil */
	if (*v == @2_nil) {
		*res = @1_nil;
		return(GDK_SUCCEED);
	}
	
	/* since the @1 type is bigger than or equal to the @2 type, it will
	   always fit */
	*res = (@1)*v;
	return GDK_SUCCEED;
}
@c

@= simpledowncast
int @2_2_@1( @1 *res, @2 *v )
{
	lng val = (lng) *v;

	/* shortcut nil */
	if (*v == @2_nil) {
		*res = @1_nil;
		return(GDK_SUCCEED);
	}
	
	/* see if the number fits in the data type */
	if (val >= GDK_@1_min && val <= GDK_@1_max)	{
		*res = (@1)val;
		return GDK_SUCCEED;
	} else {
		GDKerror("convert: value (" LLFMT ") exceeds limits of type @1\n",val);
		return GDK_FAIL;
	}
}
@c

@= numcastup
@:simpleupcast(@1,@2)@

int @2_dec2_@1( @1 *res, int *s1, @2 *v )
{
	int scale = *s1;
	@1 r, h = (*v<0)?-5:5; 

	/* shortcut nil */
	if (*v == @2_nil) {
		*res = @1_nil;
		return(GDK_SUCCEED);
	}
	
	/* since the @1 type is bigger than or equal to the @2 type, it will
	   always fit */
	r = (@1)*v;
	if (scale) 
		r = (@1) ((r + h) / scales[scale]);
	*res = r;
	return GDK_SUCCEED;
}

int @2_num2dec_@1( @1 *res, @2 *v, int *d2, int *s2 )
{
	int zero = 0;
	return @2_dec2dec_@1( res, &zero, v, d2, s2 );
}

int @2_dec2dec_@1( @1 *res, int *S1, @2 *v, int *d2, int *S2 )
{
	int p = *d2, inlen = 1;
	@2 cpyval = *v;
	int s1 = *S1, s2 = *S2;
	@1 r, h = (*v<0)?-5:5; 

	/* shortcut nil */
	if (*v == @2_nil) {
		*res = @1_nil;
		return(GDK_SUCCEED);
	}
	
	/* count the number of digits in the input */
	while (cpyval /= 10)
		inlen++;

	/* rounding is allowed */
	inlen += (s2-s1);
	if (p && inlen > p) {
		GDKerror("convert: too many digits (%d > %d)\n", inlen, p);
		return(GDK_FAIL);
	}

	/* since the @1 type is bigger than or equal to the @2 type, it will
	   always fit */
	r = (@1)*v;
	if (s2 > s1) 
		r *= (@1) scales[s2 - s1];
	else if (s2 != s1) 
		r = (@1) ((r + h) / scales[s1 - s2]);
	*res = r;
	return GDK_SUCCEED;
}
@c
@:numcastup(sht,sht)@
@:numcastup(int,sht)@
@:numcastup(int,int)@
@:numcastup(lng,sht)@
@:numcastup(lng,int)@
@:numcastup(lng,lng)@

@= fnumcastdown
@:simpledowncast(@1,@2)@

/* when casting a floating point to an decimal we like to preserve the 
 * precision.  This means we first scale the float before converting.
*/
int @2_num2dec_@1( @1 *res, @2 *v, int *s2, int *d2 )
{
	int p = *d2, inlen = 1, scale = *s2;
	@2 r;
	lng cpyval;

	/* shortcut nil */
	if (*v == @2_nil) {
		*res = @1_nil;
		return(GDK_SUCCEED);
	}
	
	/* since the @1 type is bigger than or equal to the @2 type, it will
	   always fit */
	r = (@2) *v;
	if (scale) 
		r *= scales[scale];
	cpyval = (lng) r;

	/* count the number of digits in the input */
	while (cpyval /= 10)
		inlen++;
	/* rounding is allowed */
	if (p && inlen > p) {
		GDKerror("convert: too many digits (%d > %d)\n", inlen, p);
		return(GDK_FAIL);
	}
	*res = (@1) r;
	return GDK_SUCCEED;
}
@c
@:fnumcastdown(sht,flt)@
@:fnumcastdown(int,flt)@
@:fnumcastdown(lng,flt)@
@:fnumcastdown(sht,dbl)@
@:fnumcastdown(int,dbl)@
@:fnumcastdown(lng,dbl)@

@= fnumcastup
@:simpleupcast(@1,@2)@

int @2_dec2_@1( @1 *res, int *s1, @2 *v )
{
	int scale = *s1;
	@1 r;

	/* shortcut nil */
	if (*v == @2_nil) {
		*res = @1_nil;
		return(GDK_SUCCEED);
	}
	
	/* since the @1 type is bigger than or equal to the @2 type, it will
	   always fit */
	r = (@1)*v;
	if (scale) 
		r /= scales[scale];
	*res = r;
	return GDK_SUCCEED;
}

int @2_num2dec_@1( @1 *res, @2 *v, int *d2, int *s2 )
{
	int zero = 0;
	return @2_dec2dec_@1( res, &zero, v, d2, s2 );
}

int @2_dec2dec_@1( @1 *res, int *S1, @2 *v, int *d2, int *S2 )
{
	int p = *d2, inlen = 1;
	@2 cpyval = *v;
	int s1 = *S1, s2 = *S2;
	@1 r;

	/* shortcut nil */
	if (*v == @2_nil) {
		*res = @1_nil;
		return(GDK_SUCCEED);
	}
	
	/* count the number of digits in the input */
	while (cpyval /= 10)
		inlen++;
	/* rounding is allowed */
	inlen += (s2-s1);
	if (p && inlen > p) {
		GDKerror("convert: too many digits (%d > %d)\n", inlen, p);
		return(GDK_FAIL);
	}

	/* since the @1 type is bigger than or equal to the @2 type, it will
	   always fit */
	r = (@1)*v;
	if(s2 > s1) 
		r *= scales[s2-s1];
	else if (s2 != s1) 
		r /= scales[s1-s2];
	*res = r;
	return GDK_SUCCEED;
}
@c
@:fnumcastup(flt,sht)@
@:fnumcastup(flt,int)@
@:fnumcastup(flt,lng)@
@:fnumcastup(dbl,sht)@
@:fnumcastup(dbl,int)@
@:fnumcastup(dbl,lng)@

@c
@= numcastdown
@:simpledowncast(@1,@2)@

int @2_dec2_@1( @1 *res, int *s1, @2 *v )
{
	int scale = *s1;
	lng val = *v, h = (val<0)?-5:5;

	/* shortcut nil */
	if (*v == @2_nil) {
		*res = @1_nil;
		return(GDK_SUCCEED);
	}
	
	if (scale) 
		val = (val+h)/scales[scale];
	/* see if the number fits in the data type */
	if (val >= GDK_@1_min && val <= GDK_@1_max)	{
		*res = (@1)val;
		return GDK_SUCCEED;
	} else {
		GDKerror("convert: value (" LLFMT ") exceeds limits of type @1\n",val);
		return GDK_FAIL;
	}
}

int @2_num2dec_@1( @1 *res, @2 *v, int *d2, int *s2 )
{
	int zero = 0;
	return @2_dec2dec_@1( res, &zero, v, d2, s2 );
}

int @2_dec2dec_@1( @1 *res, int *S1, @2 *v, int *d2, int *S2 )
{
	int p = *d2, inlen = 1;
	lng val = *v, cpyval = val, h = (val<0)?-5:5;
	int s1 = *S1, s2 = *S2;

	/* shortcut nil */
	if (*v == @2_nil) {
		*res = @1_nil;
		return(GDK_SUCCEED);
	}
	
	/* count the number of digits in the input */
	while (cpyval /= 10)
		inlen++;
	/* rounding is allowed */
	inlen += (s2-s1);
	if (p && inlen > p) {
		GDKerror("convert: too many digits (%d > %d)\n", inlen, p);
		return(GDK_FAIL);
	}

	if(s2 > s1) 
		val *= scales[s2-s1];
	else if (s2 != s1) 
		val = (val+h)/scales[s1-s2];

	/* see if the number fits in the data type */
	if (val >= GDK_@1_min && val <= GDK_@1_max)	{
		*res = (@1)val;
		return GDK_SUCCEED;
	} else {
		GDKerror("convert: value (" LLFMT ") exceeds limits of type @1\n",val);
		return GDK_FAIL;
	}
}
@c
@:numcastdown(sht,int)@
@:numcastdown(sht,lng)@
@:numcastdown(int,lng)@

int month_interval_str( int *ret, str s, int *ek, int *sk ){
	lng res;

	if (interval_from_str( s, *sk, *ek, &res ) < 0)
		return GDK_FAIL;
	*ret = (int) res;
	return GDK_SUCCEED;
}
int second_interval_str( lng *res, str s, int *ek, int *sk ){

	if (interval_from_str( s, *sk, *ek, res ) < 0)
		return GDK_FAIL;
	return GDK_SUCCEED;
}

@= c_interval
int month_interval_@1( int *ret, @1 *s, int *ek, int *sk ){
	int r = (int)*s;

	(void)ek;
	switch(*sk) {
	case iyear: 	
		r *= 12;
	case imonth:
		break;
	default:
		return GDK_FAIL;
	}
	*ret = r;
	return GDK_SUCCEED;
}
int second_interval_@1( lng *res, @1 *s, int *ek, int *sk ){
	lng r = *s;

	(void)ek;
	switch(*sk) {
	case iday: 	
		r *= 24;
	case ihour:
		r *= 60;
	case imin:
		r *= 60;
	case isec:
		break;
	default:
		return GDK_FAIL;
	}
	*res = r;
	return GDK_SUCCEED;
}
@c

@:c_interval(sht)@
@:c_interval(int)@
@:c_interval(lng)@

@-
An SQL session needs a minimal set of modules, shown below.
The MIL procs should also be moved to the kernel, despite the
fact that they are rather SQL specific.
@mil
module(alarm);
module(xtables);
module(aggrX3);
module(monettime);
module(blob);
module(txtsim);
module(mmath);
module(mkey);
module(bat_arith);
module(pcre); # likeselect_pcre
module(pqueue); # pqueue_topn
module(mapi); # mapi_listen 

# low memory usage for testing unloading
#mem_maxsize(0LL);
#vm_maxsize(0LL);

proc sql_diff (bat[any::1,any::2] b1, bat[any::1,any::3] b2) : bat[any::1,any::2] {
	if (count(b2) > 0) 
		return kdiff(b1,b2);
	return b1;
}

proc sql_union (bat[any::1,any::2] b1, bat[any::1,any::2] b2) : bat[any::1,any::2] {
#	if (count(b1) = 0)
#		return b2;
#	if (count(b2) > 0)
		return kunion(b1,b2);
#	return b1;
}

proc in (bat[any::1,any::2] b, any::2 v) : bit { return b.reverse().exist(v); }
proc in (any::2 b, any::2 v) : bit { return (b = v); }
proc [identity](bat[oid,any::1] b) : bat[oid,oid] { return mirror(b); }

proc sql_server_start(bit global) : void {
	var fc := nil;

	var err := CATCH({ fc := sql_frontend(); });
	if (isnil(err)) {
		mapi_register(fc);

		fork(sqllogmanager());

		if (not(mapi_running())) {
			fork(mapi_listen(
				int(monet_environment.find("mapi_port")),
				str(nil),
				5,
				global
				)
			);
		}
	} else {
		printf(err);
	}
}

proc sql_server_start() : void {
	sql_server_start(false);
}

tzone_local(TIMEZONE("GMT"));

if (mod() = "main") {
	sql_server_start();
}
