@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2006 CWI.
@' All Rights Reserved.

@f sql_session
@a N.J. Nes
@*

@* Session code

This small module contains the code to instantiate an SQL client.
This code strongly depends on the front-end/back-end setup.

@h
#ifndef _SQL_SESSION_H_
#define _SQL_SESSION_H_

#include "sql_server.h"
#include <sql_backend.h>
#include <monet_context.h>
#include <builtin.proto.h>
#include <str.h>

typedef struct backend {
	int console;
	mvc *mvc;

	buffer *outbuf;
	stream *out;
} backend;

extern void monet4_parse(backend_stack stk, char *code);

extern int sqlstatement(char *cmd, Cntxt stk);
extern int mvc_sql(mvc *c, str query);
extern ptr sql_frontend(void);

#endif /*_SQL_SESSION_H_*/
@c
#include "sql_session.h"
#include "sql_server.h"
#include "sql_result.h"
#include "sql_gencode.h"	/* for backend_dump() */
#include <sql_semantic.h>
#include <rel_semantic.h>
#include <rel_bin.h>
#include <sql_optimize.h>
#include <sql_privileges.h>
#include <sql_rel2bin.h>
#include <sql_qc.h>
#include <sql_parser.h>		/* for sqlparse() */
#include <sql_env.h>		/* explain,debug,reply_size,auto_commit etc */
#include <bat/bat_store.h>
#include <bat/res_table.h>
#include <mapi.h>

static int keep_trace = 0;

int
sql_trace()
{
	keep_trace = !keep_trace;
	return GDK_SUCCEED;
}

@= builtin_operand
{
	int _k = interpret(stk, arg(lt, @1), res);
	if (_k < 0) {
		return _k;
	}
	@3 = VALconvert(@2, res);
	if ((@3 == ILLEGALVALUE)  || (@2 == TYPE_bat && !@3)) {
		return handle_paramerror(res,@1,res->vtype,@2);
	}
}
@c

static backend *
backend_create(mvc *c, int console)
{
	backend *b = NEW(backend);

	b->mvc = c;

	b->outbuf = buffer_create(BUFSIZ);
	b->out = buffer_wastream(b->outbuf, "SQLserver");
	b->console = console;
	return b;
}

static void
backend_destroy(backend *b)
{
	if (b->out) {
		buffer_destroy(b->outbuf);
		stream_close(b->out);
		stream_destroy(b->out);
	}
	_DELETE(b);
}

static int
error(stream *out, char *str)
{
	char *p;

	if (!out)
		out = GDKerr;

	if (stream_errnr(out))
		return -1;
	while ((p = strchr(str, '\n')) != NULL) {
		p++;		/* include newline */
		if (*str !='!' && stream_write(out, "!", 1, 1) != 1)
			return -1;
		if (stream_write(out, str, p - str, 1) != 1)
			 return -1;
		str = p;
	}
	if (str &&*str) {
		if (*str !='!' && stream_write(out, "!", 1, 1) != 1)
			return -1;
		if (stream_write(out, str, strlen(str), 1) != 1 || stream_write(out, "\n", 1, 1) != 1)
			 return -1;
	}
	/*if (stream_flush(out))
		return -1;
	*/
	return 0;
}

stmt *
sql_symbol2stmt(mvc *c)
{
	stmt *s = NULL;

	if (mvc_debug_on(c,16384)) {
		sql_rel *r;
		printf("# semantic relational algebra\n");
		r = rel_semantic(c, c->sym);
		if (!r) {
			if (c->errstr[0]) {
				printf("# %s\n", c->errstr);
				return NULL;
			} else {
				c->status = 0;
				printf("# falling back to direct mode \n");
				s = semantic(c, NULL, c->sym);
			}
		} else {
			s = rel_bin(c, r);
			if (s){
				stmt *opt;

				opt = optimize(c, s);
				stmt_destroy(s);
				s = rel2bin(c, opt);
				stmt_destroy(opt);
				return opt;
			}
		}
	}  else {
		/*printf("# semantic binary algebra\n");*/
		s = semantic(c, NULL, c->sym);
	}

	if (s){
		stmt *opt;
/*
		if(i<=0){
			i *= 10;
			printf("\ndigraph %d {\nnode[shape=box,fontname=Helvetica];\nedge[labelfontname=Helvetica,labelfontcolor=red];\n", -i);
			(void)stmt_stmt2dot(s, i, &i, stdout);
			printf("}\n");
		}
		printf("# optimize\n");
*/
		opt = optimize(c, s);
		stmt_destroy(s);
		s = opt;
/*
		if(i<=0){
			i *= 10;
			printf("\ndigraph %d {\nnode[shape=box,fontname=Helvetica];\nedge[labelfontname=Helvetica,labelfontcolor=red];\n", -i);
			(void)stmt_stmt2dot(s, i, &i, stdout);
			printf("}\n");
		}
		printf("# rel2bin\n");
*/
		opt = rel2bin(c, s);
		stmt_destroy(s);
		s = opt;
/*
		if(i<=0){
			i *= 10;
			printf("\ndigraph %d {\nnode[shape=box,fontname=Helvetica];\nedge[labelfontname=Helvetica,labelfontcolor=red];\n", -i);
			(void)stmt_stmt2dot(s, i, &i, stdout);
			printf("}\n");
		}
*/
	}
	return s;
}

int
sqlcleanup(mvc *c, int err)
{
	sql_destroy_params(c);
	sql_destroy_args(c);

	/* some statements dynamically disable caching */
	c->sym = NULL;
	if (c->sa) 
		c->sa = sa_reset(c->sa);
	if (err)
		c->status = err;
	scanner_query_processed(&(c->scanner));
	return err;
}

void backend_profile( backend *be, char *query, lng parse, lng optimize, lng exec, lng total )
{
	mvc *c = be->mvc;
	int mode = c->mode;
	int explain = c->explain;
	char *q = query;

	char buf[BUFSIZ];

	/* ltrim query */
	while(isspace((int)(*q))) 
		q++;

	/* TODO use sql_prepare/execute */
	snprintf(buf, BUFSIZ, "INSERT INTO \"sys\".\"profile\" "
		 "VALUES(now(),'%s',%lld,%lld,%lld,%lld,USER);\n",
		 q, parse, optimize, exec, total);
	_DELETE(query);

	/* switch of explain to prevent recursion */
	c->mode = m_normal;
	c->explain = m_normal;
	(void) mvc_sql(c, buf);
	c->mode = mode;
	c->explain = explain;
}

int
sqlexecute(backend *be, stream *out)
{
	mvc *c = be->mvc;
	char *query = NULL;
	lng T0 = 0, Tparse = 0, Tmil = 0;
	int err = 0;
	cq *q = NULL;

	c->type = Q_PARSE;
	if (!c->trans) {
		int schema_nr = mvc_trans(c);
		if (c->cache && (c->schema_number < schema_nr || c->qc->id > 1000)) {
			c->schema_number = schema_nr;
			if (c->qc)
				qc_destroy(c->qc);
			c->qc = qc_create(c->clientid);
		}
	}

	if (!c->sa)
		c->sa = sa_create();

	if (c->mode == m_profile)
		T0 = GDKusec();

	if ((err = sqlparse(c)) ||
	    /* Only forget old errors on transaction boundaries */
	    (mvc_status(c) && c->type != Q_TRANS) || !c->sym) {
		if (!err && c->scanner.started) /* repeat old errors, with a parsed query */
			err = mvc_status(c);
		return sqlcleanup(c, err);
	}

	if (c->mode == m_profile)
		Tparse = GDKusec();
	if ((c->mode == m_explain || c->mode == m_profile) && 
	    c->sym->token == SQL_SET)
		c->mode = m_normal;

	if (c->mode == m_execute) {
		q = qc_find(c->qc, c->sym->data.lval->h->data.ival);
		if (!q) {
			err = -1;
			sql_error(c, 2, "no prepared statement with the given id\n");
		} else {
			err = backend_exec_prepared_stmt( be, q );
		}
		if (err)
			return sqlcleanup(c, err);
	} else if (c->mode == m_explain || !c->cache || 
	           !(q = qc_match(c->qc, c->sym, c->args, c->argc, c->scanner.key))) {
		stmt *s = sql_symbol2stmt(c);

		if (!s && (err = mvc_status(c))) /* semantic errors */
			return sqlcleanup(c, err);
		assert(s);
		if (c->mode == m_explain) {
			err = backend_explain(be, s, out);
		} else {
			if (c->cache) {
				q = qc_insert(c->qc, c->sa, c->sym, c->args, c->argc, c->scanner.key, c->type, NULL);
				c->sa = NULL;
				c->sym = NULL;
			}
			if ((err = backend_dump(be, q, s)) != 0  && q)
				qc_delete(c->qc, q);
		}
		stmt_destroy(s);
		if (err)
			return sqlcleanup(c, err);
	}

	if (c->mode == m_profile) {
		query = sql_escape_str(QUERY(c->scanner) + c->scanner.as);
		Tmil = GDKusec();
	}

	scanner_query_processed(&(c->scanner));

	if (q && c->mode == m_prepare) {
		int len;
		if (c->params && (len = list_length(c->params)) > MAXPARAMS) {
			sql_error(c, 2, "To many parameters in prepared statement (%d>%d)\n", len, MAXPARAMS);
			err = -1;
			return sqlcleanup(c, err);
		}
		err = mvc_export_prepare(c, out, q);
	} else if (q && !q->code) {
		err = backend_call(be, c, q); 
	} else if (q) {
		err = backend_fastpath(be, c, q);
	}
	if (!err && c->mode == m_profile) {
		lng T = GDKusec();
		backend_profile(be, query, Tparse-T0, Tmil-Tparse, T-Tmil,T0-T);
	}
	return sqlcleanup(c, err);
}

@-
Sidestepping SQL to directly executed a single MIL statement
in the same context.
@c
void
sidestepMil(Cntxt stk, char *cmd)
{
	ValRecord res;

	res.vtype = TYPE_void;
	interpret_str(stk, cmd, &res);
}

#define TRANS_ABORTED "!current transaction is aborted (please ROLLBACK)\n"

int
handle_error(mvc *m, stream *out, int pstatus)
{
	int go = 1;
	char *buf = GDKerrbuf;

	/* transaction already broken */
	if (m->type != Q_TRANS && pstatus < 0) {
		if (stream_write(out, TRANS_ABORTED, sizeof(TRANS_ABORTED) - 1, 1) != 1) {
			go = !go;
		}
	} else {
		if (error(out, m->errstr) < 0 || (buf && buf[0] && error(out, buf) < 0)) {
			go = !go;
		}
	}
	/* reset error buffers */
	m->errstr[0] = 0;
	if (buf)
		buf[0] = 0;
	return go;
}

@c
int
sqlclient(backend *sql, bstream *in, stream *out)
{
	mvc *m = sql->mvc;
	int err, go = TRUE;
	int language = 'S';
	prot oldmode;

	in->eof = 1;		/* force prompt on first iteration */
	while (go) {
		int pstatus = 0;

		if (in->pos >= in->len) {
			ssize_t rd;

			assert(in->pos == in->len);

			if (in->eof || !isa_block_stream(in->s)) {
				language = (sql->console) ? 'S' : 0;

				/* auto_commit on end of statement */
				if (m->auto_commit && m->trans) {
					if (mvc_status(m) < 0) {
						mvc_rollback(m, 0, NULL);
					} else if (mvc_commit(m, 0, NULL) < 0) {
						go = handle_error(m, out, pstatus);
						if (!go)
							break;
					}
				}

				if ( (!isa_block_stream(in->s) && stream_write(out, PROMPT1, sizeof(PROMPT1) - 1, 1) != 1) || stream_flush(out)) {
					go = FALSE;
					break;
				}
				in->eof = 0;
			}
			if ((rd = bstream_next(in)) <= 0) {
				if (rd == 0 && language != 0 && in->eof) {
					/* we hadn't seen the EOF before, so just try again
					   (this time with prompt) */
					continue;
				}
				go = FALSE;
				break;
			}
			if (go && !sql->console && language == 0)
				language = in->buf[in->pos++];
		}
		if (sql->console && strncmp(in->buf + in->pos, "quit", 4) == 0) {
			in->pos = in->len;	/* HACK: should use parsed lenght */
			go = FALSE;
			break;
		}
@-
To enable tracing of SQL execution using its MIL code
requires the same client context. This means that we should
have an escape from the sql parser and directly address the
MIL interpreter. This is accomplished with a prepend of the
query string with "M".
		if (mil && language == 'M') {
			sidestepMil(stk, in->buf+in->pos);
			in->pos = in->len; /* HACK: should use parsed lenght */
			continue;
		}
@c
		oldmode = m->scanner.mode;
		if (language == 's') {
			language = 'S';
			m->scanner.mode = LINE_1;
		}
		if (language != 'S' && language != 'X') {
			error(out, "!unrecognized language prefix");
			break;
		}
		if (language == 'X') {
			int n, id, off, len;

			n = sscanf(in->buf + in->pos, "export %d %d %d", &id, &off, &len);

			if (n == 2 || n == 3) {
				mvc_export_chunk(m, out, id, off, n == 3 ? len : m->reply_size);

				in->pos = in->len;	/* HACK: should use parsed lenght */
				continue;
			}
			if (sscanf(in->buf + in->pos, "close %d", &id) == 1) {
				res_table *t = res_tables_find(m->results, id);

				if (t)
					m->results = res_tables_remove(m->results, t);
				in->pos = in->len;	/* HACK: should use parsed lenght */
				continue;
			}
			if (sscanf(in->buf + in->pos, "auto_commit %d", &id) == 1) {
				m->auto_commit = (id)?1:0;
				m->ac_on_commit = m->auto_commit;
				if (mvc_rollback(m, 0, NULL) < 0)
					break;
				in->pos = in->len;	/* HACK: should use parsed lenght */
				continue;
			}
			if (sscanf(in->buf + in->pos, "reply_size %d", &id) == 1) {
				m->reply_size = id;
				in->pos = in->len;	/* HACK: should use parsed lenght */
				continue;
			}
			error(out, "!unrecognized X command");
			break;
		}

		if (m->trans)
			pstatus = m->status;

		m->mode = m->explain;
		err = sqlexecute(sql, out);
		m->scanner.mode = oldmode;
		if (err) /* output error */
			go = handle_error(m, out, pstatus);
	}
	return GDK_SUCCEED;
}

int
sqlstatement(char *cmd, Cntxt stk)
{
	int err = 0;
	mvc *m;
	backend *sql;
	Variable v;
	bstream *rs;
	buffer *b;
	char *n;
	int len = strlen(cmd);

	b = (buffer*)GDKmalloc(sizeof(buffer));
	n = GDKmalloc(len + 1 + 1);
	strncpy(n, cmd, len);
	cmd = n;
	cmd[len] = '\n';
	cmd[len+1] = 0;
	len++;

	buffer_init(b, cmd, len);
	rs = bstream_create(buffer_rastream(b, "sqlstatement"), b->len);
	m = mvc_create(0, (backend_stack) stk, rs, GDKout);
	mvc_trans(m);		/* start transaction */
	m->user_id = m->role_id = USER_MONETDB;
	m->user = _strdup("monetdb");
	m->trans->schema = mvc_bind_schema(m, "sys");
	m->scanner.mode = LINE_1; 
	bstream_next(m->scanner.rs);
	sql = backend_create(m, 1);

	/* add myc and Output, Input to the stack */
	v = VARnew(stk, "myc");
	v->binding.vtype = TYPE_mvc;
	v->binding.val.pval = m;

	err = sqlexecute(sql, GDKout);
	if (err)
		GDKerror(m->errstr);
	backend_destroy(sql);
	GDKfree(cmd);
	GDKfree(b);

	mvc_commit(m, 0, NULL);
	res_tables_destroy(m->results);
	mvc_destroy(m);
	VARdel(stk, v);
	if (err)
		return GDK_FAIL;
	else
		return GDK_SUCCEED;
}

int
mvc_sql(mvc *m, char *cmd)
{
	Cntxt stk = (Cntxt) m->stk;
	mvc o = *m;

	int err = 0;
	backend *sql;
	Variable mvc, output;
	buffer *b;
	char *n;
	int len = strlen(cmd);

	sql = backend_create(m, 1);

	/* shouldn't be needed to reset the myc variable ! */ 
        mvc = VARfind(&stk, "myc");
        if (mvc == NULL) {
            GDKerror("sql_client_init: failed to lookup myc variable.\n"); 
	    return GDK_FAIL;
	}
        if (mvc->binding.vtype != TYPE_mvc) {
            GDKerror("sql_client_init: myc variable has wrong type != mvc.\n"); 
	    return GDK_FAIL;
	}
        mvc->binding.val.pval = m; 

        output = VARfind(&stk, "Output");
        if (output == NULL) {
            GDKerror("sql_client_init: failed to lookup Output variable.\n"); 
	    return GDK_FAIL;
	}
        if (output->binding.vtype != TYPE_Stream) {
            GDKerror("sql_client_init: Output variable has wrong type != stream.\n"); 
	    return GDK_FAIL;
	}
        output->binding.val.pval = NULL;

	m->qc = NULL;
	m->cache = 0;
	m->user_id = m->role_id = USER_MONETDB;
	m->user = _strdup("monetdb");

	b = (buffer*)GDKmalloc(sizeof(buffer));
	n = GDKmalloc(len + 1 + 1);
	strncpy(n, cmd, len);
	cmd = n;
	cmd[len] = '\n';
	cmd[len+1] = 0;
	len++;
	buffer_init(b, cmd, len);
	scanner_init( &m->scanner, 
		bstream_create(buffer_rastream(b, "sqlstatement"), b->len),
		NULL);
	m->scanner.mode = LINE_1; 
	bstream_next(m->scanner.rs);

	m->params = NULL;
	m->argc = 0;
	m->sym = NULL;
	m->auto_commit = 0;

	err = sqlexecute(sql, NULL);
	backend_destroy(sql);
	GDKfree(cmd);
	GDKfree(b);
	bstream_destroy(m->scanner.rs);
	assert(m->qc == NULL);

	GDKfree(m->user);
	*m = o;
        output->binding.val.pval = m->scanner.ws;
	if (err)
		return GDK_FAIL;
	else
		return GDK_SUCCEED;
}

int
sqlconsole(Cntxt stk, YYSTREE lt, ValPtr res)
{
	int ret = GDK_SUCCEED;
	stream *in = GDKin, *out = GDKout;
	bstream *rs;
	Variable v;
	backend *sql;
	char *schema;
	mvc *m;

	if (lt->cnt != 0)
		return handle_argerror(res, lt->cnt, 0);

	rs = bstream_create(in, 0);
	m = mvc_create(0, (backend_stack) stk, rs, out);
	m->cache = 1;
	if (!m) {
		GDKerror("Couldn't start sqlconsole");
		return GDK_FAIL;
	}
	schema = mvc_login(m, "monetdb", "monetdb");

	if (!schema) {
		stream_printf(out, "!schema authorization error");
		stream_flush(out);
		res_tables_destroy(m->results);
		mvc_destroy(m);
		return GDK_FAIL;
	}
	GDKfree(schema);
	stream_flush(out);

	/* add myc and Output, Input to the stack */
	v = VARnew(stk, "myc");
	v->binding.vtype = TYPE_mvc;
	v->binding.val.pval = m;

	v = VARnew(stk, "Output");
	v->binding.vtype = TYPE_Stream;
	v->binding.val.pval = out;

	v = VARnew(stk, "Input");
	v->binding.vtype = TYPE_Bstream;
	v->binding.val.pval = rs;

	sql = backend_create(m, 1);
	ret = sqlclient(sql, rs, out);
	bstream_destroy(rs);
	res_tables_destroy(m->results);
	m->results = NULL;	
	backend_destroy(sql);
	mvc_destroy(m);
	return ret;
}

static char *
sql_client_alloc(mapi_client *fc)
{
	mvc *m = mvc_create(0, (backend_stack)fc->stk, NULL, NULL);
	backend *be = backend_create(m, 0);
	Variable v;

	if (!m) 
		return "!couldn't allocate sql catalog";
	fc->fc = be;
	m->cache = 1;

	/* add myc and Output, Input to the stack */
	v = VARnew(fc->stk, "myc");
	v->binding.vtype = TYPE_mvc;
	v->binding.val.pval = m;

	v = VARnew(fc->stk, "Output");
	v->binding.vtype = TYPE_Stream;
	v->binding.val.pval = NULL;

	v = VARnew(fc->stk, "Input");
	v->binding.vtype = TYPE_Bstream;
	v->binding.val.pval = NULL;

	return NULL;
}

static char * 
sql_client_init(mapi_client *fc)
{
	bstream *rs;
	backend *be = fc->fc;
	mvc *m = be->mvc;
	char *schema;
	Variable v;

	rs = bstream_create(fc->c->fdin, fc->c->blocked ? (128 * BLOCK) : 0);
	mvc_reset(m, rs, fc->c->fdout);
	schema = mvc_login(m, fc->c->user, fc->c->passwd);
	if (!schema) {
		char *res = "!Schema authorization error";
		res_tables_destroy(m->results);
		m->results = NULL;
		return res;
	}
	GDKfree(schema);

	if (keep_trace && !m->scanner.log) {
		char fn[BUFSIZ];

		snprintf(fn, BUFSIZ, "sql.%d", (int)(fc->c - monet_clients)); 
		m->scanner.log = open_wastream(fn);
	}

	/* shouldn't be needed to reset the myc variable ! */ 
        v = VARfind(&fc->stk, "myc");
        if (v == NULL) 
            return "sql_client_init: failed to lookup myc variable.\n"; 
        if (v->binding.vtype != TYPE_mvc) {
	    printf("missing mvc\n");
            return "sql_client_init: myc variable has wrong type != mvc.\n"; 
	}
        v->binding.val.pval = m; 

        v = VARfind(&fc->stk, "Output");
        if (v == NULL) 
            return "sql_client_init: failed to lookup Output variable.\n"; 
        if (v->binding.vtype != TYPE_Stream) 
            return "sql_client_init: Output variable has wrong type != stream.\n"; 
        v->binding.val.pval = fc->c->fdout; 

        v = VARfind(&fc->stk, "Input");
        if (v == NULL) 
            return "sql_client_init: failed to lookup Input variable.\n"; 
        if (v->binding.vtype != TYPE_Bstream) 
            return "sql_client_init: Input variable has wrong type != bstream.\n"; 
        v->binding.val.pval = m->scanner.rs; 
	return NULL; /* no error */
}

static void
sql_client_engine(mapi_client *fc )
{
	backend *be = fc->fc;
	char *buf = THRget_errbuf(fc->thread);

	if (!buf) {
		buf = GDKmalloc(GDKMAXERRLEN);
		buf[0] = '\0';
		THRset_errbuf(fc->thread, buf);
	}
	sqlclient(be, be->mvc->scanner.rs, be->mvc->scanner.ws);
	bstream_destroy(be->mvc->scanner.rs);
	res_tables_destroy(be->mvc->results);
	be->mvc->results = NULL;

	if (keep_trace && be->mvc->scanner.log) 
		stream_flush(be->mvc->scanner.log);
}

static void  
sql_client_free(mapi_client *fc)
{
	backend *be = fc->fc;
	mvc *m = be->mvc;
	char *buf = THRget_errbuf(fc->thread);

	if (buf) {
		GDKfree(buf);
		THRset_errbuf(fc->thread, NULL);
	}
	fc->fc = NULL;
	backend_destroy(be);
	mvc_destroy(m);
}

ptr
sql_frontend(void)
{
	char *m_clients = GDKgetenv("mapi_clients"); 
	int nr = (m_clients)?strtol(m_clients, NULL, 10):1;
	mapi_frontend *f = (mapi_frontend*)GDKmalloc(sizeof(mapi_frontend));
	f->name = GDKstrdup("sql");
	f->cache_limit = nr;
	f->f_alloc = sql_client_alloc;
	f->f_init  = sql_client_init;
	f->f_free  = sql_client_free;
	f->f_engine  = sql_client_engine; /* read/parse/execute loop */
	return (ptr)f;
}


int
mvc_new(Cntxt stk, YYSTREE lt, ValPtr res)
{
	stream *in = GDKin, *out = GDKout;
	bstream *rs;
	mvc *m;

	if (lt->cnt != 0)
		return handle_argerror(res, lt->cnt, 0);

	rs = bstream_create(in, 0);
	m = mvc_create(0, (backend_stack) stk, rs, out);
	m->cache = 1;

	mvc_trans(m);		/* start transaction */
	m->user_id = m->role_id = USER_MONETDB;
	m->user = _strdup("monetdb");
	m->trans->schema = mvc_bind_schema(m, "sys");

	res->vtype = TYPE_mvc;
	res->val.pval = (ptr) m;
	return GDK_SUCCEED;
}

int
mvc_destroy_wrap(mvc *M, int *commit)
{
	mvc *m = *(mvc**)M;
	if (*commit)
		mvc_commit(m, 0, NULL);
	else
		mvc_rollback(m, 0, NULL);
	res_tables_destroy(m->results);
	mvc_destroy(m);
	return GDK_SUCCEED;
}
