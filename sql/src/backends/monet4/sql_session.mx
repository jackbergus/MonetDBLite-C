@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2007 CWI.
@' All Rights Reserved.

@f sql_session
@a N.J. Nes
@*

@* Session code

This small module contains the code to instantiate an SQL client.
This code strongly depends on the front-end/back-end setup.

@h
#ifndef _SQL_SESSION_H_
#define _SQL_SESSION_H_

#include "sql_server.h"
#include <sql_backend.h>
#include <monet_context.h>
#include <builtin.proto.h>
#include <str.h>

typedef struct backend {
	int console;
	mvc *mvc;

	buffer *outbuf;
	stream *out;
} backend;

extern int mvc_sql(mvc *c, str query);
extern char *mvc_login(mvc *c, char *user, char *passwd);
extern ptr sql_frontend(void);

#endif /*_SQL_SESSION_H_*/
@c
#include "sql_config.h"
#include "sql_session.h"
#include "sql_server.h"
#include "sql_result.h"
#include "sql_gencode.h"	/* for backend_dump() */
#include <sql_semantic.h>
#include <rel_semantic.h>
#include <rel_optimizer.h>
#include <rel_bin.h>
#include <sql_optimize.h>
#include <sql_privileges.h>
#include <sql_rel2bin.h>
#include <bin_optimizer.h>
#include <sql_qc.h>
#include <sql_parser.h>		/* for sqlparse() */
#include <sql_env.h>		/* explain,debug,reply_size,auto_commit etc */
#include <bat/bat_store.h>
#include <bat/res_table.h>
#include <mapi.h>

static int SQLdebug = 0;
static int keep_trace = 0;
static char *sqlinit = NULL;

int
sql_trace()
{
	keep_trace = !keep_trace;
	return GDK_SUCCEED;
}

@= builtin_operand
{
	int _k = interpret(stk, arg(lt, @1), res);
	if (_k < 0) {
		return _k;
	}
	@3 = VALconvert(@2, res);
	if ((@3 == ILLEGALVALUE)  || (@2 == TYPE_bat && !@3)) {
		return handle_paramerror(res,@1,res->vtype,@2);
	}
}
@c

static int
error(stream *out, char *str)
{
	char *p;

	if (!out)
		out = GDKerr;

	if (stream_errnr(out))
		return -1;
	while ((p = strchr(str, '\n')) != NULL) {
		p++;		/* include newline */
		if (*str !='!' && stream_write(out, "!", 1, 1) != 1)
			return -1;
		if (stream_write(out, str, p - str, 1) != 1)
			 return -1;
		str = p;
	}
	if (str &&*str) {
		if (*str !='!' && stream_write(out, "!", 1, 1) != 1)
			return -1;
		if (stream_write(out, str, strlen(str), 1) != 1 || stream_write(out, "\n", 1, 1) != 1)
			 return -1;
	}
	return 0;
}

stmt *
sql_symbol2stmt(mvc *c)
{
	stmt *s = NULL;

	if (mvc_debug_on(c,16384)) {
		sql_rel *r;
		printf("# semantic relational algebra\n");
		r = rel_semantic(c, c->sym);
		if (!r) {
			if (c->errstr[0]) {
				printf("# %s\n", c->errstr);
				return NULL;
			} else {
				c->session->status = 0;
				printf("# falling back to direct mode \n");
				s = output_semantic(c, NULL, c->sym);
			}
		} else {
			r = rel_optimizer(c, r);
			s = rel_bin(c, r);
			if (s){
				stmt *opt;

				/* only needed for delta tables */
				opt = rel2bin(c, s); 	
				stmt_destroy(s);
				s = bin_optimizer(c, opt);
				stmt_destroy(opt);
				return s;
			}
		}
	}  else {
		/*printf("# semantic binary algebra\n");*/
		s = output_semantic(c, NULL, c->sym);
	}

	if (s){
		stmt *opt;

		if (mvc_debug_on(c,32768)) 
			stmt2dot(s, 1, "/tmp/g1.dot");
		opt = optimize(c, s);
		stmt_destroy(s);
		s = opt;
		if (mvc_debug_on(c,32768)) 
			stmt2dot(s, 2, "/tmp/g2.dot");
		opt = rel2bin(c, s);
		stmt_destroy(s);
		s = opt;
		if (mvc_debug_on(c,32768)) 
			stmt2dot(s, 3, "/tmp/g3.dot");
		opt = bin_optimizer(c, s);
		stmt_destroy(s);
		s = opt;
		if (mvc_debug_on(c,32768)) 
			stmt2dot(s, 4, "/tmp/g4.dot");
	}
	return s;
}

int
sqlcleanup(mvc *c, int err)
{
	sql_destroy_params(c);
	sql_destroy_args(c);

	/* some statements dynamically disable caching */
	c->sym = NULL;
	if (c->sa) 
		c->sa = sa_reset(c->sa);
	if (err)
		c->session->status = err;
	scanner_query_processed(&(c->scanner));
	return err;
}

void backend_profile( backend *be, char *query, lng parse, lng optimize, lng exec, lng total )
{
	mvc *c = be->mvc;
	modes_t mode = c->mode;
	modes_t explain = c->explain;
	char *q = query;

	char buf[BUFSIZ];

	/* ltrim query */
	while(isspace((int)(*q))) 
		q++;

	/* TODO use sql_prepare/execute */
	snprintf(buf, BUFSIZ, "INSERT INTO \"profile\" "
		 "VALUES(now,'%s',"LLFMT","LLFMT","LLFMT","LLFMT",USER);\n",
		 q, parse, optimize, exec, total);
	_DELETE(query);

	/* switch of explain to prevent recursion */
	c->mode = m_normal;
	c->explain = m_normal;
	(void) mvc_sql(c, buf);
	c->mode = mode;
	c->explain = explain;
}

int
sqlexecute(backend *be, stream *out)
{
	mvc *c = be->mvc;
	char *query = NULL;
	lng T0 = 0, Tparse = 0, Tmil = 0;
	int err = 0;
	cq *q = NULL;

	if (c && !c->session->active) {
		int schema_changed = mvc_trans(c);
		if (c->cache && (schema_changed || c->qc->id > 1000)) {
			if (c->qc)
				qc_destroy(c->qc);
			c->qc = qc_create(c->clientid);
		}
	}
	c->type = Q_PARSE;

	if (!c->sa)
		c->sa = sa_create();

	if (c->mode == m_profile)
		T0 = GDKusec();

	if ((err = sqlparse(c)) ||
	    /* Only forget old errors on transaction boundaries */
	    (mvc_status(c) && c->type != Q_TRANS) || !c->sym) {
		if (!err && c->scanner.started) /* repeat old errors, with a parsed query */
			err = mvc_status(c);
		return sqlcleanup(c, err);
	}

	if (c->mode == m_profile)
		Tparse = GDKusec();

	if (c->mode == m_execute) {
		q = qc_find(c->qc, c->sym->data.lval->h->data.ival);
		if (!q) {
			err = -1;
			sql_error(c, 2, "no prepared statement with the given id\n");
		} else {
			err = backend_exec_prepared_stmt( be, q );
		}
		if (err)
			return sqlcleanup(c, err);
	} else if (c->mode == m_inplace || c->mode == m_explain || !c->cache || 
	           !(q = qc_match(c->qc, c->sym, c->args, c->argc, c->scanner.key))) {
		stmt *s = sql_symbol2stmt(c);

		if (!s && (err = mvc_status(c))) /* semantic errors */
			return sqlcleanup(c, err);
		assert(s);
		if (c->mode == m_explain) {
			err = backend_explain(be, s, out);
		} else {
			if (c->cache && s->type != st_none) {
				q = qc_insert(c->qc, c->sa, c->sym, c->args, c->argc, c->scanner.key, c->type, sql_escape_str(QUERY(c->scanner)));
				c->sa = NULL;
				c->sym = NULL;
			}
			if ((err = backend_dump(be, q, s)) != 0  && q)
				qc_delete(c->qc, q);
		}
		stmt_destroy(s);
		if (err)
			return sqlcleanup(c, err);
	}

	if (c->mode == m_profile) {
		query = sql_escape_str(QUERY(c->scanner) + c->scanner.as);
		Tmil = GDKusec();
	}

	scanner_query_processed(&(c->scanner));

	if (q && c->mode == m_prepare) {
		int len;
		if (c->params && (len = list_length(c->params)) > MAXPARAMS) {
			sql_error(c, 2, "Too many parameters in prepared statement (%d>%d)\n", len, MAXPARAMS);
			err = -1;
			return sqlcleanup(c, err);
		}
		err = mvc_export_prepare(c, out, q, NULL);
	} else if (q && !q->code) {
		err = backend_call(be, c, q);
	} else if (q) {
		err = backend_fastpath(be, c, q);
	}
	if (!err && c->mode == m_profile) {
		lng T = GDKusec();
		backend_profile(be, query, Tparse-T0, Tmil-Tparse, T-Tmil,T0-T);
	}
	return sqlcleanup(c, err);
}

@-
Sidestepping SQL to directly executed a single MIL statement
in the same context.
@c
void
sidestepMil(Cntxt stk, char *cmd)
{
	ValRecord res;

	res.vtype = TYPE_void;
	interpret_str(stk, cmd, &res);
}

#define TRANS_ABORTED "!current transaction is aborted (please ROLLBACK)\n"

int
handle_error(mvc *m, stream *out, int pstatus)
{
	int go = 1;
	char *buf = GDKerrbuf;

	/* transaction already broken */
	if (m->type != Q_TRANS && pstatus < 0) {
		if (stream_write(out, TRANS_ABORTED, sizeof(TRANS_ABORTED) - 1, 1) != 1) {
			go = !go;
		}
	} else {
		if (error(out, m->errstr) < 0 || (buf && buf[0] && error(out, buf) < 0)) {
			go = !go;
		}
	}
	/* reset error buffers */
	m->errstr[0] = 0;
	if (buf)
		buf[0] = 0;
	return go;
}

@c
int
sqlclient(backend *sql, bstream *in, stream *out)
{
	mvc *m = sql->mvc;
	int err, go = TRUE;
	int language = 'S';
	prot oldmode;

	in->eof = 1;		/* force prompt on first iteration */
	while (go) {
		int pstatus = 0;

		/* Different kinds of supported statements sequences
			A;	-- single line			s
			A \n B;	-- multi line			S
			A; B;   -- compound single block	s
			A;	-- many multi line 
			B \n C; -- statements in one block	S
		*/
		/* auto_commit on end of statement */
		if (m->scanner.mode == LINE_N && m->session->auto_commit && m->session->active) {
			if (mvc_status(m) < 0) {
				mvc_rollback(m, 0, NULL);
			} else if (mvc_commit(m, 0, NULL) < 0) {
				go = handle_error(m, out, pstatus);
				if (!go)
					break;
			}
		}

		if (in->pos >= in->len) {
			ssize_t rd;

			assert(in->pos == in->len);

			if (in->eof) {
				language = (sql->console) ? 'S' : 0;

				/* auto_commit on end of statement (s A;B; case)*/
				if (m->session->auto_commit && m->session->active) {
					if (mvc_status(m) < 0) {
						mvc_rollback(m, 0, NULL);
					} else if (mvc_commit(m, 0, NULL) < 0) {
						go = handle_error(m, out, pstatus);
						if (!go)
							break;
					}
				}

				if (stream_flush(out)) {
					go = FALSE;
					break;
				}
				in->eof = 0;
			}
			if ((rd = bstream_next(in)) <= 0) {
				if (rd == 0 && language != 0 && in->eof) {
					/* we hadn't seen the EOF before, so just try again
					   (this time with prompt) */
					continue;
				}
				go = FALSE;
				break;
			}
			if (go && !sql->console && language == 0)
				language = in->buf[in->pos++];
		}
		if (sql->console && strncmp(in->buf + in->pos, "quit", 4) == 0) {
			in->pos = in->len;	/* HACK: should use parsed lenght */
			go = FALSE;
			break;
		}
@-
To enable tracing of SQL execution using its MIL code
requires the same client context. This means that we should
have an escape from the sql parser and directly address the
MIL interpreter. This is accomplished with a prepend of the
query string with "M".
		if (mil && language == 'M') {
			sidestepMil(stk, in->buf+in->pos);
			in->pos = in->len; /* HACK: should use parsed lenght */
			continue;
		}
@c
		oldmode = m->scanner.mode;
		if (language == 's') {
			language = 'S';
			m->scanner.mode = LINE_1;
		}
		if (language != 'S' && language != 'X') {
			error(out, "!unrecognized language prefix");
			break;
		}
		if (language == 'X') {
			int n, v, off, len;

			if (m->scanner.log) 
				stream_write(m->scanner.log, in->buf+in->pos, in->len - in->pos, 1);

			n = sscanf(in->buf + in->pos, "export %d %d %d", &v, &off, &len);

			if (n == 2 || n == 3) {
				mvc_export_chunk(m, out, v, off, n == 3 ? len : m->reply_size);

				in->pos = in->len;	/* HACK: should use parsed lenght */
				continue;
			}
			if (sscanf(in->buf + in->pos, "close %d", &v) == 1) {
				res_table *t = res_tables_find(m->results, v);

				if (t)
					m->results = res_tables_remove(m->results, t);
				in->pos = in->len;	/* HACK: should use parsed lenght */
				continue;
			}
			if (sscanf(in->buf + in->pos, "auto_commit %d", &v) == 1) {
				int commit = (!m->session->auto_commit && v);
				m->session->auto_commit = (v)?1:0;
				m->session->ac_on_commit = m->session->auto_commit;
				if (m->session->active) {
					if (commit && mvc_commit(m, 0, NULL)< 0)
						break;
					else if (!commit && mvc_rollback(m, 0, NULL) < 0)
						break;
				}
				in->pos = in->len;	/* HACK: should use parsed lenght */
				continue;
			}
			if (sscanf(in->buf + in->pos, "reply_size %d", &v) == 1) {
				m->reply_size = v;
				in->pos = in->len;	/* HACK: should use parsed lenght */
				continue;
			}
			error(out, "!unrecognized X command");
			break;
		}

		if (m->session->active)
			pstatus = m->session->status;

		m->mode = m->explain;
		err = sqlexecute(sql, out);
		m->scanner.mode = oldmode;
		if (err) /* output error */
			go = handle_error(m, out, pstatus);
	}
	if (m->session->auto_commit && m->session->active) {
		if (mvc_status(m) >= 0 && mvc_commit(m, 0, NULL) < 0) 
			(void) handle_error(m, out, 0);
	}
	if (m->session->active)
		mvc_rollback(m, 0, NULL);
	return GDK_SUCCEED;
}

int
mvc_sql(mvc *m, char *cmd)
{
	Cntxt stk = (Cntxt) m->session->stk;
	mvc *o;
	int ac = m->session->auto_commit, sizevars, topvars;
	sql_var *vars;

	int err = 0;
	backend *sql;
	Variable myc, output;
	buffer *b;
	char *n;
	int len = _strlen(cmd);

	o = NEW(mvc);
	if (!o)
		return GDK_FAIL;
	*o = *m;

	sql = backend_create(m, 1);

	/* shouldn't be needed to reset the myc variable ! */ 
        myc = VARfind(&stk, "myc");
        if (myc == NULL) {
            GDKerror("sql_client_init: failed to lookup myc variable.\n"); 
	    return GDK_FAIL;
	}
        if (myc->binding.vtype != TYPE_mvc) {
            GDKerror("sql_client_init: myc variable has wrong type != mvc.\n"); 
	    return GDK_FAIL;
	}
        myc->binding.val.pval = m; 

        output = VARfind(&stk, "Output");
        if (output == NULL) {
            GDKerror("sql_client_init: failed to lookup Output variable.\n"); 
	    return GDK_FAIL;
	}
        if (output->binding.vtype != TYPE_Stream) {
            GDKerror("sql_client_init: Output variable has wrong type != stream.\n"); 
	    return GDK_FAIL;
	}
        output->binding.val.pval = NULL;

	m->qc = NULL;
	/* disable caching */
	m->cache = 0;
	m->user_id = m->role_id = USER_MONETDB;

	b = (buffer*)GDKmalloc(sizeof(buffer));
	n = GDKmalloc(len + 1 + 1);
	strncpy(n, cmd, len);
	cmd = n;
	cmd[len] = '\n';
	cmd[len+1] = 0;
	len++;
	buffer_init(b, cmd, len);
	scanner_init( &m->scanner, 
		bstream_create(buffer_rastream(b, "mvc_sql"), b->len),
		NULL);
	m->scanner.mode = LINE_1; 
	bstream_next(m->scanner.rs);

	m->params = NULL;
	m->argc = 0;
	m->sym = NULL;
	m->session->auto_commit = 0;

	err = sqlexecute(sql, NULL);
	backend_destroy(sql);
	GDKfree(cmd);
	GDKfree(b);
	bstream_destroy(m->scanner.rs);
	assert(m->qc == NULL);

	/* variable stack maybe resized, ie we need to keep the new stack */
	sizevars = m->sizevars;
	topvars = m->topvars;
	vars = m->vars;
	*m = *o;
	_DELETE(o);
	m->sizevars = sizevars;
	m->topvars = topvars;
	m->vars = vars;
	m->session->auto_commit = ac;
        output->binding.val.pval = m->scanner.ws;
	if (err)
		return GDK_FAIL;
	else
		return GDK_SUCCEED;
}

int 
sql_variables(Cntxt stk, YYSTREE lt, ValPtr res)
{
	int i;
	mvc *m;
	Variable v;
	BAT *vars, *r; 

	if (lt->cnt != 0) 
		return handle_argerror(res, lt->cnt, 0);

        v = VARfind(&stk, "myc");
        if (v == NULL) 
            return GDKerror("sql_variables: failed to lookup myc variable.\n"); 

	m = v->binding.val.pval;

	vars = BATnew(TYPE_void,TYPE_str, m->topvars);
	BATseqbase(vars, 0);
	for (i=0; i<m->topvars && m->vars[i].s; i++) 
		BUNappend(vars, m->vars[i].name, FALSE);
	r = BATnew(TYPE_str,TYPE_bat,1);
	BUNins(r, "name", &vars->batCacheid, FALSE);
	BBPunfix(vars->batCacheid);
	res->vtype = TYPE_bat;
	res->val.bval = r->batCacheid;
	BBPkeepref(r->batCacheid);
	return GDK_SUCCEED;
}

int
dump_cache(Cntxt stk, YYSTREE lt, ValPtr res)
{
	mvc *m;
	int cnt; 
	BAT *t, *query, *count;
	cq *q = NULL;
	Variable v;

	if (lt->cnt != 0) 
		return handle_argerror(res, lt->cnt, 0);

        v = VARfind(&stk, "myc");
        if (v == NULL) 
            return GDKerror("dump_cache: failed to lookup myc variable.\n"); 

	m = v->binding.val.pval;

	cnt = m->qc->id; 
 	t = BATnew(TYPE_str, TYPE_bat, 1);
	query = BATnew(TYPE_void, TYPE_str, cnt);
	BATseqbase(query, 0);
	count = BATnew(TYPE_void, TYPE_int, cnt);
	BATseqbase(count, 0);
	BUNins(t, "query", &query->batCacheid, FALSE);
	BUNins(t, "count", &count->batCacheid, FALSE);

	for(q = m->qc->q; q; q = q->next) {
		BUNappend(query, q->codestring, FALSE);
		BUNappend(count, &q->count, FALSE);
	}

	BBPunfix(query->batCacheid);
	BBPunfix(count->batCacheid);
	res->vtype = TYPE_bat;
	res->val.bval = t->batCacheid;
	BBPkeepref(t->batCacheid);
	return GDK_SUCCEED;
}

int
dump_opt_stats(Cntxt stk, YYSTREE lt, ValPtr res)
{
	mvc *m;
	int cnt; 
	BAT *t, *rewrite, *count;
	Variable v;

	if (lt->cnt != 0) 
		return handle_argerror(res, lt->cnt, 0);

        v = VARfind(&stk, "myc");
        if (v == NULL) 
            return GDKerror("dump_opt_stats: failed to lookup myc variable.\n");

	m = v->binding.val.pval;

	cnt = m->qc->id; 
 	t = BATnew(TYPE_str, TYPE_bat, 1);
	rewrite = BATnew(TYPE_void, TYPE_str, cnt);
	BATseqbase(rewrite, 0);
	count = BATnew(TYPE_void, TYPE_int, cnt);
	BATseqbase(count, 0);
	BUNins(t, "rewrite", &rewrite->batCacheid, FALSE);
	BUNins(t, "count", &count->batCacheid, FALSE);

	BUNappend(rewrite, "joinidx", FALSE);
	BUNappend(count, &m->opt_stats[0], FALSE);
	/* TODO add other rewrites */

	BBPunfix(rewrite->batCacheid);
	BBPunfix(count->batCacheid);
	res->vtype = TYPE_bat;
	res->val.bval = t->batCacheid;
	BBPkeepref(t->batCacheid);
	return GDK_SUCCEED;
}

/* initialize the global variable, ie make mvc point to these */
static int
global_variables(mvc *sql, char *user, char *schema)
{
	sql_subtype ctype;
	char *typename;
	char *name;
	stmt *r = NULL;
	lng sec = 0;
	bit T = TRUE, F = FALSE;
	ValRecord src;

 	typename = "int";
	sql_find_subtype(&ctype, typename, 0, 0);
 	name = "debug";

	r = stmt_var(_strdup(name), &ctype, 0, 1);
	stack_push_var(sql, name, r, &ctype);
	stack_set_var(sql, name, VALset(&src, ctype.type->localtype, &sql->debug));

	typename = "varchar";
	sql_find_subtype(&ctype, typename, 8, 0);
	name = "explain";
	r = stmt_var(_strdup(name), &ctype, 0, 1);
	stack_push_var(sql, name, r, &ctype);
	stack_set_var(sql, name, VALset(&src, ctype.type->localtype, ""));

	sql_find_subtype(&ctype, typename, 1024, 0);
	name = "current_schema";
	r = stmt_var(_strdup(name), &ctype, 0, 1);
	stack_push_var(sql, name, r, &ctype);
	stack_set_var(sql, name, VALset(&src, ctype.type->localtype, schema));

	name = "current_user";
	r = stmt_var(_strdup(name), &ctype, 0, 1);
	stack_push_var(sql, name, r, &ctype);
	stack_set_var(sql, name, VALset(&src, ctype.type->localtype, user));

	name = "current_role";
	r = stmt_var(_strdup(name), &ctype, 0, 1);
	stack_push_var(sql, name, r, &ctype);
	stack_set_var(sql, name, VALset(&src, ctype.type->localtype, user));

	name = "optimizer";
	r = stmt_var(_strdup(name), &ctype, 0, 1);
	stack_push_var(sql, name, r, &ctype);
	stack_set_var(sql, name, VALset(&src, ctype.type->localtype, "yes"));

	typename = "sec_interval";
	sql_find_subtype(&ctype, typename, 0, 0);
	name = "current_timezone";
	r = stmt_var(_strdup(name), &ctype, 0, 1);
	stack_push_var(sql, name, r, &ctype);
	stack_set_var(sql, name, VALset(&src, ctype.type->localtype, &sec));

	typename = "boolean";
	sql_find_subtype(&ctype, typename, 0, 0);
	name = "cache";
	r = stmt_var(_strdup(name), &ctype, 0, 1);
	stack_push_var(sql, name, r, &ctype);
	stack_set_var(sql, name, VALset(&src, ctype.type->localtype, &T));

	name = "profile";
	r = stmt_var(_strdup(name), &ctype, 0, 1);
	stack_push_var(sql, name, r, &ctype);
	stack_set_var(sql, name, VALset(&src, ctype.type->localtype, &F));

	name = "trace";
	r = stmt_var(_strdup(name), &ctype, 0, 1);
	stack_push_var(sql, name, r, &ctype);
	stack_set_var(sql, name, VALset(&src, ctype.type->localtype, &F));
	return 0;
}


char *
mvc_login(mvc *m, char *user, char *passwd)
{
	ssize_t rid;
	sql_schema *sys = NULL;
	sql_table *users = NULL;
	sql_column *users_name = NULL;

	char *schema = NULL;

	if (m->debug & 1)
		fprintf(stderr, "mvc_login %s\n", user);

	mvc_trans(m);

	sys = find_sql_schema(m->session->tr, "sys");
	users = find_sql_table(sys, "db_users");
	users_name = find_sql_column(users, "name");

	if ((rid = column_find_row(m->session->tr, users_name, user, NULL)) >= 0) {
		sql_column *users_passwd = find_sql_column(users, "passwd");
		char *pwd = column_find_value(m->session->tr, users_passwd, rid);

		if (pwd && strcmp(passwd, pwd) == 0) {
			sql_column *users_schema = find_sql_column(users, "default_schema");
			void *p = column_find_value(m->session->tr, users_schema, rid);
			unsigned int schema_id = *(unsigned int *)p;
			sql_table *schemas = find_sql_table(sys, "schemas");
			sql_column *schemas_name = find_sql_column(schemas, "name");
			sql_column *schemas_id = find_sql_column(schemas, "id");
			sql_table *auths = find_sql_table(sys, "auths");
			sql_column *auths_name = find_sql_column(auths, "name");

			_DELETE(p);
			if ((rid = column_find_row(m->session->tr, schemas_id, &schema_id, NULL)) >= 0)
				schema = column_find_value(m->session->tr, schemas_name, rid);

			/* only set schema if user is found */
			rid = column_find_row(m->session->tr, auths_name, user, NULL);
			if (rid >= 0) {
				sql_column *auths_id = find_sql_column(auths, "id");
				void *p = column_find_value(m->session->tr, auths_id, rid);
				int id = *(int *) p;

				_DELETE(p);
				m->user_id = m->role_id = id;
			} else {
				schema = NULL;
			}
		}
		if (pwd)
			_DELETE(pwd);
	}

	if (!schema || !mvc_set_schema(m, schema)) {
		if (m->session->active)
			mvc_rollback(m, 0, NULL);
		return NULL;
	}
	/* reset the user and schema names */
	stack_set_string(m, "current_schema", schema);
	stack_set_string(m, "current_user", user);
	stack_set_string(m, "current_role", user);
	mvc_rollback(m, 0, NULL);
	return schema;
}

int
sqlconsole(Cntxt stk, YYSTREE lt, ValPtr res)
{
	int ret = GDK_SUCCEED;
	stream *in = GDKin, *out = GDKout;
	bstream *rs;
	Variable v;
	backend *sql;
	char *schema;
	mvc *m;

	if (lt->cnt != 0)
		return handle_argerror(res, lt->cnt, 0);

	rs = bstream_create(in, 0);
	m = mvc_create(0, (backend_stack) stk, SQLdebug, rs, out);
	if (!m) {
		GDKerror("Couldn't start sqlconsole");
		return GDK_FAIL;
	}
	m->argfixed = 1;
	schema = mvc_login(m, "monetdb", "monetdb");

	if (!schema) {
		stream_printf(out, "!schema authorization error");
		stream_flush(out);
		res_tables_destroy(m->results);
		mvc_destroy(m);
		return GDK_FAIL;
	}
	GDKfree(schema);
	stream_flush(out);

	/* add myc and Output, Input to the stack */
	v = VARnew(stk, "myc"); /* allready exists but thats a global var */
	v->binding.vtype = TYPE_mvc;
	v->binding.val.pval = m;

	v = VARnew(stk, "Output");
	v->binding.vtype = TYPE_Stream;
	v->binding.val.pval = out;

	v = VARnew(stk, "Input");
	v->binding.vtype = TYPE_Bstream;
	v->binding.val.pval = rs;

	sql = backend_create(m, 1);
	if (sqlinit)
		mvc_sql(m, sqlinit);
	ret = sqlclient(sql, rs, out);
	bstream_destroy(rs);
	res_tables_destroy(m->results);
	m->results = NULL;	
	backend_destroy(sql);
	mvc_destroy(m);
	return ret;
}

static char *
sql_client_alloc(mapi_client *fc)
{
	mvc *m = mvc_create(0, (backend_stack)fc->stk, SQLdebug, NULL, NULL);
	backend *be = backend_create(m, 0);
	Variable v;

	if (!m) 
		return "!couldn't allocate sql catalog";
	m->argfixed = 1;
	fc->fc = be;

	/* add myc and Output, Input to the stack */
	v = VARnew(fc->stk, "myc"); /* allready exists but thats a global var */
	v->binding.vtype = TYPE_mvc;
	v->binding.val.pval = m;

	v = VARnew(fc->stk, "Output");
	v->binding.vtype = TYPE_Stream;
	v->binding.val.pval = NULL;

	v = VARnew(fc->stk, "Input");
	v->binding.vtype = TYPE_Bstream;
	v->binding.val.pval = NULL;

	/* only now we can initialize the global variables */
	global_variables(m, "monetdb", "sys");
	return NULL;
}

static char * 
sql_client_init(mapi_client *fc)
{
	bstream *rs;
	backend *be = fc->fc;
	mvc *m = be->mvc;
	char *schema;
	Variable v;

	rs = bstream_create(fc->c->fdin, 128 * BLOCK);
	mvc_reset(m, rs, fc->c->fdout, SQLdebug, 10);
	schema = mvc_login(m, fc->c->user, fc->c->passwd);
	if (!schema) {
		char *res = "schema authorization error";
		res_tables_destroy(m->results);
		m->results = NULL;
		return res;
	}
	GDKfree(schema);

	if (keep_trace && !m->scanner.log) {
		char fn[BUFSIZ];

		snprintf(fn, BUFSIZ, "sql.%d", (int)(fc->c - monet_clients)); 
		m->scanner.log = open_wastream(fn);
	}

	/* shouldn't be needed to reset the myc variable ! */ 
        v = VARfind(&fc->stk, "myc");
        if (v == NULL) 
            return "sql_client_init: failed to lookup myc variable.\n"; 
        if (v->binding.vtype != TYPE_mvc) {
	    printf("missing mvc\n");
            return "sql_client_init: myc variable has wrong type != mvc.\n"; 
	}
        v->binding.val.pval = m; 

        v = VARfind(&fc->stk, "Output");
        if (v == NULL) 
            return "sql_client_init: failed to lookup Output variable.\n"; 
        if (v->binding.vtype != TYPE_Stream) 
            return "sql_client_init: Output variable has wrong type != stream.\n"; 
        v->binding.val.pval = fc->c->fdout; 

        v = VARfind(&fc->stk, "Input");
        if (v == NULL) 
            return "sql_client_init: failed to lookup Input variable.\n"; 
        if (v->binding.vtype != TYPE_Bstream) 
            return "sql_client_init: Input variable has wrong type != bstream.\n"; 
        v->binding.val.pval = m->scanner.rs; 
	return NULL; /* no error */
}

static void
sql_client_engine(mapi_client *fc )
{
	backend *be = fc->fc;
	char *buf = THRget_errbuf(fc->thread);

	if (!buf) {
		buf = GDKmalloc(GDKMAXERRLEN);
		buf[0] = '\0';
		THRset_errbuf(fc->thread, buf);
	}
	if (sqlinit)
		mvc_sql(be->mvc, sqlinit);
	sqlclient(be, be->mvc->scanner.rs, be->mvc->scanner.ws);
	bstream_destroy(be->mvc->scanner.rs);
	res_tables_destroy(be->mvc->results);
	be->mvc->results = NULL;

	if (keep_trace && be->mvc->scanner.log) 
		stream_flush(be->mvc->scanner.log);
}

static void  
sql_client_free(mapi_client *fc)
{
	backend *be = fc->fc;
	mvc *m = be->mvc;
	char *buf = THRget_errbuf(fc->thread);

	if (buf) {
		GDKfree(buf);
		THRset_errbuf(fc->thread, NULL);
	}
	fc->fc = NULL;
	backend_destroy(be);
	mvc_destroy(m);
}

ptr
sql_frontend(void)
{
	char *debug_str = GDKgetenv("sql_debug");
	char *m_clients = GDKgetenv("mapi_clients"); 
	int nr = (m_clients)?strtol(m_clients, NULL, 10):1;
	mapi_frontend *f = (mapi_frontend*)GDKmalloc(sizeof(mapi_frontend));
	f->name = GDKstrdup("sql");
	f->cache_limit = nr;
	f->f_alloc = sql_client_alloc;
	f->f_init  = sql_client_init;
	f->f_free  = sql_client_free;
	f->f_engine  = sql_client_engine; /* read/parse/execute loop */

	sqlinit = GDKgetenv("sqlinit");
	if (debug_str) 
		SQLdebug = strtol(debug_str,NULL,10);
	return (ptr)f;
}


int
mvc_new(Cntxt stk, YYSTREE lt, ValPtr res)
{
	stream *in = GDKin, *out = GDKout;
	bstream *rs;
	mvc *m;

	if (lt->cnt != 0)
		return handle_argerror(res, lt->cnt, 0);

	rs = bstream_create(in, 0);
	m = mvc_create(0, (backend_stack) stk, SQLdebug, rs, out);
	m->argfixed = 1;
	mvc_trans(m);		/* start transaction */
	m->user_id = m->role_id = USER_MONETDB;
	m->session->schema = mvc_bind_schema(m, "sys");

	res->vtype = TYPE_mvc;
	res->val.pval = (ptr) m;
	return GDK_SUCCEED;
}

int
mvc_destroy_wrap(mvc *M, int *commit)
{
	mvc *m = *(mvc**)M;
	if (*commit)
		mvc_commit(m, 0, NULL);
	else
		mvc_rollback(m, 0, NULL);
	res_tables_destroy(m->results);
	mvc_destroy(m);
	return GDK_SUCCEED;
}
