@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2006 CWI.
@' All Rights Reserved.

@f sql_cache
@v 0.0
@a M.L.Kersten, N.Nes
@+ SQL cache
The SQL cache module provides the primitives to
keep pre-compiled SQL queries around. 
The cache can be filled using a MAL structure
of the following form:
@T
\begin{verbatim}
function qry001(A1:int):int
comment "select * from t where a> ?";
   ... mal ...
end qry001;
\end{verbatim}

Unlike the other modules, it is permissible to
remove elements from this cache at runtime.
@mal
module sql_cache;

command remove(nme:str):void
address SQLCacheRemove
comment "Remove the cached function";

command exists(nme:str):bit
address SQLCacheExists
comment "Locate a cached SQL function";

command getDefinition(nme:str):bat[:int,:str]
address SQLCacheGetDefinition
comment"Retrieve the SQL statement for a 
	cache operation";
@-
@{

@+ BAT Iterator Implementation

@h
#ifndef _SQL_CACHE_H_
#define _SQL_CACHE_H_
#include "sql.h"

/* #define _SQL_CACHE_DEBUG */
sql5_export str SQLCacheRemove(int *ret, str *nme);
sql5_export str SQLCacheExists(bit *res, str *nme);
sql5_export str SQLCacheGetDefinition(int *ret, str *nme);

#endif /* _SQL_CACHE_H_ */
@c
#include "mal.h"
#include "mal_interpreter.h"
#include "inspect.h"
#include "mal_namespace.h"
#include "sql_cache.h"

str
SQLCacheExists(bit *res, str *nme)
{
	Module scope;
	Symbol s;
	Client c = MCgetClient();

	scope = findModule(c->nspace, putName("sql_cache",9));

	if (scope == NULL)
		throw(MAL, "sql_cache.exists", "internal error, sql_cache missing\n");
	s = findSymbolInModule(scope, *nme);
	*res = s != NULL;
	return MAL_SUCCEED;
}

str
SQLCacheGetDefinition(int *ret, str *nme)
{
	Module scope;
	Symbol s;
	Client c = MCgetClient();
	BAT *b = BATnew(TYPE_int, TYPE_str, 256);

	if (b == 0)
		throw(MAL, "sql_cache.getDefinition", "failed to create BAT");

	scope = findModule(c->nspace, putName("sql_cache",9));

	if (scope == NULL)
		throw(MAL, "sql_cache.getDefinition", "internal error, sql_cache missing\n");
	s = findSymbolInModule(scope, *nme);

	if (s) {
		int i;
		str ps;

		for (i = 0; i < s->def->stop; i++) {
			ps = instruction2str(s->def, getInstrPtr(s->def, i), 0);
			BUNins(b, &i, ps + 1, FALSE);
			GDKfree(ps);
		}
	}
	BATmode(b, TRANSIENT);
	BATfakeCommit(b);
	*ret = b->batCacheid;
	return MAL_SUCCEED;
}

str
SQLCacheRemove(int *ret, str *nme)
{
	Module scope;
	Symbol s;
	Client c = MCgetClient();

	(void) ret;
#ifdef _SQL_CACHE_DEBUG
	stream_printf(GDKout, "SQLCacheRemove %s\n", *nme);
#endif
	scope = findModule(c->nspace, putName("sql_cache",9));

	if (scope == NULL)
		throw(MAL, "sql_cache.remove", "internal error, sql_cache missing\n");
	s= findSymbolInModule(scope, *nme);
	if (s == NULL)
		throw(MAL, "sql_cache.remove", "internal error, symbol missing\n");
	if( getInstrPtr(s->def,0)->token == FACTORYsymbol)
		shutdownFactoryByName(scope, *nme);
	else
		deleteSymbol(scope,s);

	return MAL_SUCCEED;
}

@}
