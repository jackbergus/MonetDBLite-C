@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2006 CWI.
@' All Rights Reserved.

@f sql_user
@t SQL catalog management
@a N. Nes, F. Groffen
@+ SQL user
The SQL user and authorisation implementation differs per backend.  This
file implements the authorisation and user management based on the M5
system authorisation.
@h
#ifndef _SQL_USER_H_
#define _SQL_USER_H_
#include "sql.h"	/* includes sql_backend.h */

sql_export void monet5_user_init(backend_functions *be_funcs);
sql_export str  monet5_user_get_def_schema(mvc *m, oid user);

sql_export str db_users_wrap(int *r);

#endif /* _SQL_USER_H_ */

@c
#include "sql_user.h"
#include "sql_mvc.h"
#include "bat5.h"
#include "mal_authorize.h"

static str
monet5_drop_user(ptr _mvc, str user)
{
	mvc *m = (mvc *)_mvc;
	ssize_t rid;
	sql_schema *sys = find_sql_schema(m->session->tr, "sys");
	sql_table *users = find_sql_table(sys, "db_user_info");
	sql_column *users_name = find_sql_column(users, "name");

	rid = column_find_row(m->session->tr, users_name, user, NULL);
	if (rid < 0)
		return NULL;
	table_delete(m->session->tr, users, rid);
	AUTHremoveUser(&user);
	return user;
}

static str
monet5_create_user(list *l, str user, str passwd, str fullname, sqlid schema_id, sqlid grantorid)
{
	oid uid = 0;
	bat bid = 0;
	BAT *scens;
	str ret;
	char buf[BUFSIZ];
	(void)l;

	/* prepare the scens BAT: it should contain the sql scenario */
	scens = BATnew(TYPE_str, TYPE_void, 1);
	BUNins(scens, "sql", 0, FALSE);
	bid = BBPcacheid(scens);
	/* add the user to the M5 authorisation administration */
	if ((ret = AUTHaddUser(&uid, &user, &passwd, &bid)) != MAL_SUCCEED) {
		BBPunfix(bid); 
		return ret;
	}
	BBPunfix(bid);

	/* create two SQL statements that insert the user in the SQL
	 * adminsitration */
	snprintf(buf, BUFSIZ, "INSERT INTO \"sys\".\"db_user_info\" VALUES('%s','%s',%d);", user, fullname, schema_id);
	list_append(l, stmt_sql(_strdup(buf)));
	snprintf(buf, BUFSIZ, "INSERT INTO \"sys\".\"auths\" VALUES(" SZFMT ", '%s', %d);", (size_t)store_next_oid(), user, grantorid);
	list_append(l, stmt_sql(_strdup(buf)));

	return(NULL);
}

static BAT *
db_users() 
{
	bat b, bid;
	str tmp;

	/* prepare the scens BAT: it should contain the sql scenario */
	BAT *scens = BATnew(TYPE_str, TYPE_void, 1);

	BUNins(scens, "sql", 0, FALSE);
	bid = BBPcacheid(scens);
	if ((tmp = AUTHgetUsers(&b, &bid)) != MAL_SUCCEED) {
		BBPunfix(bid); 
		GDKfree(tmp);
		return(NULL);
	}
	BBPunfix(bid);
	return BBPdescriptor(b);
}

static int
monet5_find_user(ptr mp, str user) 
{
	BAT *users;
	BUN p;
	(void)mp;	/* we don't need mvc, as we do a M5 backend call */
	

	users = db_users();
	if (!users)
		return -1; 
	p = BUNfnd(BATmirror(users), user);
	BBPunfix(users->batCacheid);

	/* yeah, I would prefer to return something different too */
	return(p == NULL ? -1 : 1);
}

str
db_users_wrap(int *r)
{
	BAT *b = db_users();
	BAT *t = BATnew(TYPE_str, TYPE_bat, 1);

	BUNins(t, "name", &b->batCacheid, FALSE);
	BBPunfix(b->batCacheid);
	*r = t->batCacheid;
	BBPkeepref(*r);
	return MAL_SUCCEED;
}

static void
monet5_create_privileges(ptr _mvc, sql_schema *s)
{
	sql_table *t, *uinfo;
	mvc *m = (mvc *)_mvc;
	char *err = NULL;
	int schema_id = 0;
	str monetdbuser = "monetdb";
	sql_subtype tpe;
	list *l;

	/* create the authorisation related tables */
	t = mvc_create_table(m, s, "db_user_info", 1, SQL_PERSIST, 0, -1);
	mvc_create_column_(m, t, "name", "varchar", 1024);
	mvc_create_column_(m, t, "fullname", "varchar", 2048);
	mvc_create_column_(m, t, "default_schema", "int", 9);
	uinfo = t;

	(void)err;
	t = mvc_create_generated(m, s, "#db_users", NULL, 1);
	mvc_create_column_(m, t, "name", "varchar", 2048);

	sql_find_subtype(&tpe, "table", 0, 0);
	tpe.comp_type = t;
	tpe.digits = t->base.id; /* pass the table through digits */

	/* add function */
	l = list_create((fdestroy) &arg_destroy);
	/* following funcion returns a table (single column) of user names
	   with the approriate scenario (sql) */
	mvc_create_func(m, s, "db_users", l, &tpe, FALSE, FALSE, "db_users");

	t = mvc_create_view(m, s, "users",
			"SELECT u.\"name\" AS \"name\", "
				"ui.\"fullname\", ui.\"default_schema\" "
			"FROM db_users() AS u LEFT JOIN "
				"\"sys\".\"db_user_info\" AS ui "
				"ON u.\"name\" = ui.\"name\" "
			";", 1);
	mvc_create_column_(m, t, "name", "varchar", 1024);
	mvc_create_column_(m, t, "fullname", "varchar", 2024);
	mvc_create_column_(m, t, "default_schema", "int", 9);

	schema_id = sql_find_schema(m, "sys");
	assert(schema_id >= 0);

	table_insert(m->session->tr, uinfo, monetdbuser, "MonetDB Administrator", &schema_id);
}

static int
monet5_schema_has_user(ptr _mvc, sql_schema *s)
{
	mvc *m = (mvc *)_mvc;
	ssize_t rid;
	sql_schema *sys = find_sql_schema(m->session->tr, "sys");
	sql_table *users = find_sql_table(sys, "db_user_info");
	sql_column *users_schema = find_sql_column(users, "default_schema");
	sqlid schema_id = s->base.id;

	rid = column_find_row(m->session->tr, users_schema, &schema_id, NULL);
	if (rid < 0)
		return FALSE;
	return TRUE;
}

static int
monet5_alter_user(ptr _mvc, str user, str passwd, sqlid schema_id)
{
	mvc *m = (mvc *)_mvc;

	if (passwd != NULL) {
		str err = AUTHsetPassword(&user, &passwd);
		if (err != MAL_SUCCEED) {
			(void)sql_error(m, 02, "%s", err);
			return(FALSE);
		}
	}
	if (schema_id) {
		ssize_t rid;
		sql_schema *sys = find_sql_schema(m->session->tr, "sys");
		sql_table *info = find_sql_table(sys, "db_user_info");
		sql_column *users_name = find_sql_column(info, "name");
		sql_column *users_schema = find_sql_column(info, "default_schema");

		/* FIXME: we don't really check against the backend here */
		rid = column_find_row(m->session->tr, users_name, user, NULL);
		if (rid < 0)
			return FALSE;

		column_update_value(m->session->tr, users_schema, rid, &schema_id);
	}
	return TRUE;
}

void
monet5_user_init(backend_functions *be_funcs)
{
	be_funcs->fcuser		= &monet5_create_user;
	be_funcs->fduser		= &monet5_drop_user;
	be_funcs->ffuser		= &monet5_find_user;
	be_funcs->fcrpriv		= &monet5_create_privileges;
	be_funcs->fshuser		= &monet5_schema_has_user;
	be_funcs->fauser		= &monet5_alter_user;
}

str
monet5_user_get_def_schema(mvc *m, oid user)
{
	ssize_t rid;
	sqlid schema_id;
	sql_schema *sys = NULL;
	sql_table *user_info = NULL;
	sql_column *users_schema = NULL;
	sql_table *schemas = NULL;
	sql_column *schemas_name = NULL;
	sql_column *schemas_id = NULL;
	sql_table *auths = NULL;
	sql_column *auths_name = NULL;

	void *p;

	str schema = NULL;
	str username = NULL;
	str err = NULL;

	if (m->debug)
		fprintf(stderr, "monet5_user_get_def_schema " OIDFMT "\n", user);

	if ((err = AUTHresolveUser(&username, &user)) != MAL_SUCCEED) {
		GDKfree(err);
		return(NULL);	/* don't reveal that the user doesn't exist */
	}

	mvc_trans(m);

	sys = find_sql_schema(m->session->tr, "sys");
	user_info = find_sql_table(sys, "db_user_info");
	users_schema = find_sql_column(user_info, "default_schema");
	p = column_find_value(m->session->tr, users_schema, user);
	schema_id = *(sqlid*)p;
	_DELETE(p);

	schemas = find_sql_table(sys, "schemas");
	schemas_name = find_sql_column(schemas, "name");
	schemas_id = find_sql_column(schemas, "id");
	auths = find_sql_table(sys, "auths");
	auths_name = find_sql_column(auths, "name");

	if ((rid = column_find_row(m->session->tr, schemas_id, &schema_id, NULL)) >= 0)
		schema = column_find_value(m->session->tr, schemas_name, rid);

	/* only set schema if user is found */
	rid = column_find_row(m->session->tr, auths_name, username, NULL);
	if (rid >= 0) {
		sql_column *auths_id = find_sql_column(auths, "id");
		p = column_find_value(m->session->tr, auths_id, rid);
		int id = *(int *) p;
		_DELETE(p);

		m->user_id = m->role_id = id;
	} else {
		schema = NULL;
	}

	if (!schema || !mvc_set_schema(m, schema)) {
		if (m->session->active)
			mvc_rollback(m, 0, NULL);
		return NULL;
	}
	/* reset the user and schema names */
	backend_set_string(m, "current_schema", schema);
	backend_set_string(m, "current_user", username);
	backend_set_string(m, "current_role", username);
	mvc_rollback(m, 0, NULL);
	return schema;
}
