@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2005 CWI.
@' All Rights Reserved.

@f sql
@t SQL Scenario implementation
@a M Kersten 
@v 0
@* SQL support implementation
This module contains the wrappers around the SQL 
multi-version-catalog and support routines copied
from the Version 4 code base.

@mal
module sql;

command sql():void 
address SQLsession;
command start():void 
address SQLsession
comment "Switch to processing SQL statements";

command init():void
address SQLinitEnvironment
comment "Initialize the environment for MAL";

command compile(cmd:str):str 
address SQLcompile0;

command compile(cmd:str,flag:int):str 
address SQLcompile
comment "Compile a single sql statement and return a MAL proc.
If flag >0 then the result is kept in the catalogue. Otherwise
the catalog is reset before returning.";

command eval(cmd:str):str 
address SQLstatement
comment "Execute a single sql statement";

command header(i:int) :void
address SQLheader
comment "Generate a table header for an SQL frontend";
command column(i:any_1, v:str,t:str,digits:int,scale:int) :void
address SQLcolumnsingle;
command column(b:bat[:any_1,:any_2], v:str,t:str,digits:int,scale:int) :void
address SQLcolumn
comment "Rename a table column";

command assert(b:bit,msg:str):void
address SQLassert
comment "Generate an exception when b==true";

command assert(b:int,msg:str):void
address SQLassertInt
comment "Generate an exception when b!=0";
command assert(b:lng,msg:str):void
address SQLassertLng
comment "Generate an exception when b!=0";

pattern output(order:int, a:any...):void
address SQLoutput;
pattern output(order:int,r:bat[:any_1,:any]...):void
address SQLoutputBats
comment "Overloading of the core print routines to obtain proper layout";

@- The SQL multi-version catalog
This module also contains the definitions for managing an SQL database schema in
version 5.  It is an adaptation of the original V4.3 code base. 
A main difference is that the global catalog is obtained from
the client record, rather then lookup the variable in a context stack.

The MAL operations below are used in the SQL->MAL compiler and
can be (sparingly) used to inspect it from a MIL console.
The 'mvc_' header is removed, because all commands are already
prepended by the 'sql.' module name.
The original code is retained, because it makes it
easier to later re-use part of the catalog code in a separately.
@mal

command createCatalog( debug:int ) :void 
address mvc_create_wrap
comment "Create multi version catalog";

command destroyCatalog() 
address mvc_destroy_wrap
comment "Destroy multi version catalog";

command update_var( varname:str ):void
address mvc_update_var_wrap
comment "Update a session variable";

command bind_ubat(sname:str, tname:str, cname:str, access:int ) :bat[:any_1,:any_2]
address mvc_bind_ubat_wrap
comment "Bind bat with the updates to tname.cname 
	with specific access mode";

command bind_dbat(sname:str, tname:str, access:int):bat[:any_1,:any_2]
address mvc_bind_dbat_wrap
comment "Bind the table deletes bat, tname.delete 
	with specific access modes";

command bind_idxbat(sname:str, tname:str, iname:str, access:int):bat[:any_1,:any_2]
address mvc_bind_idxbat_wrap
comment "Bind the idx bat, tname.idx
	with specific accsess modes";

command clear_table(sname:str, tname:str) :lng
address mvc_clear_table_wrap
comment "Clear table";

command bind(sname:str, tname:str, cname:str, access:int ):bat[:any_1,:any_2]
address mvc_bind_wrap
comment "Bind the bat tname.cname into the focus with specific access mode";

command columnBind(b:bat[:str,:bat], nme:str) :bat[:any_1,:any_2]
address mvc_bind_single_wrap
comment "Bind the column bat into the focus ";

@-
The Monet 5 code generator uses several SQL specific wrapper functions.
They are not present in V4
@mal
command exportTable(s:stream, res_id:int, 
		offset:int, nr:int ) 
address mvc_export_table_wrap
comment "Export a table (in order) to stream s 
	with the given tuple and record 
	seperators (sep/rsep)";

command exportResult(s:stream, res_id:int ) 
address mvc_export_result_wrap
comment "Export a table (in order) to stream s 
	with the given tuple and record 
	seperators (sep/rsep)";

command importTable( s:stream, tname:str, 
	sep:str, rsep:str, nr:int) :bat[:str,:bat] 
address mvc_import_table_wrap
comment "Import a table from stream s with the 
	given tuple and seperators (sep/rsep)";

pattern hash( v:any_1, sh:int ) :int 
address hash_wrap 
comment "calculate a hash value and shift left";

command hash( b:bat[:void,:any_1], sh:int ) :bat[:void,:int]
address bathash_wrap 
comment "calculate a hash value and shift left";

@- SQL functions
The SQL functions are all recognized by their module name.
For some we need to provide a new implementation, others
merely require a different address binding.

The aggregate operations work on doubles by default.
This calls for casting values around in the process.
@= mal_round
command round( v:@1, r:@1 ) :@1 
address @1_round_wrap
comment "round off the value v to nearests multiple of r";
command round( v:@1, r:dbl ) :@1 
address @1_dbl_round_wrap
comment "round off the value v to nearests multiple of r";
@mal

@:mal_round(sht)@
@:mal_round(int)@
@:mal_round(lng)@

command round( v:flt, r:flt ) :flt 
address dbl_round_wrap
comment "round off the value v to nearests multiple of r";
command round( v:dbl, r:dbl ) :dbl 
address dbl_round_wrap
comment "round off the value v to nearests multiple of r";

@= mal_cast
command @1( v:str ) :@1 
address CALCstr2@1
comment "Cast to @1";
command @1( v:str, digits:int ) :@1 
address str_2num_@1
comment "cast to @1 and check for overflow";
command @1( v:str, digits:int, scale:int ) :@1 
address str_2dec_@1
comment "cast to dec(@1) and check for overflow";
@mal
@:mal_cast(sht)@
@:mal_cast(int)@
@:mal_cast(lng)@

@= mal_fcast
command @1( v:str ) :@1 
address CALCstr2@1
comment "cast to @1";
@mal
@:mal_fcast(flt)@
@:mal_fcast(dbl)@

@mal
command str( v:bit) :str 
address CALCbit2str
comment "Idempotent cast of strings";
command str( v:str) :str 
address CALCstr2str
comment "Idempotent cast of strings";
@+ todo
command str( v:any_1, digits:int ) :str 
address SQLstr_cast
comment "cast to string and check for overflow";

@= mal_cast_2dec
command @1( v:@2) :@1 
address @2_2_@1
comment "cast @1 to @1 and check for overflow";
command @1( v:@2, digits:int, scale:int ) :@1 
address @2_num2dec_@1
comment "cast number to decimal(@1) and check for overflow";
@mal
@:mal_cast_2dec(sht,flt)@
@:mal_cast_2dec(int,flt)@
@:mal_cast_2dec(lng,flt)@
@:mal_cast_2dec(sht,dbl)@
@:mal_cast_2dec(int,dbl)@
@:mal_cast_2dec(lng,dbl)@

@= mal_cast_dec2
command @1( s1:int, v:@2) :@1 
address @2_dec2_@1
comment "cast decimal(@2) to @1 and check for overflow";
command @1( s1:int, v:@2, d2:int, s2:int ) :@1 
address @2_dec2dec_@1
comment "cast decimal(@2) to decimal(@1) and check for overflow";
@mal

@= mal_cast2
@:mal_cast_2dec(@1,@2)@
@:mal_cast_dec2(@1,@2)@
@mal
@:mal_cast2(sht,sht)@
@:mal_cast2(sht,int)@
@:mal_cast2(sht,lng)@
@:mal_cast2(int,sht)@
@:mal_cast2(int,int)@
@:mal_cast2(int,lng)@
@:mal_cast2(lng,sht)@
@:mal_cast2(lng,int)@
@:mal_cast2(lng,lng)@
@:mal_cast2(flt,sht)@
@:mal_cast2(flt,int)@
@:mal_cast2(flt,lng)@
@:mal_cast2(dbl,sht)@
@:mal_cast2(dbl,int)@
@:mal_cast2(dbl,lng)@
@-
Include the sql_cache functionality
@mal
include sql_cache;
include mil_algebra_procs;

@h
#ifndef _SQL_H
#define _SQL_H

#include <sql_mem.h>

#ifdef _MSC_VER
#ifndef LIBSQL
#define sql_export extern __declspec(dllimport)
#else
#define sql_export extern __declspec(dllexport)
#endif
#else
#define sql_export extern
#endif

#include "sql_mvc.h"
#include <sql_backend.h>
#include <mal_session.h>

#include <mal_function.h>
#include <mal_stack.h>
#include <mal_interpreter.h>
#include <mal_session.h>
#include <tablet.h>
#include <streams.h>
#include "sql_privileges.h"
#include "sql_semantic.h"
#include "sql_optimize.h"
#include "sql_rel2bin.h"
#include "sql_decimal.h"
#include "sql_string.h"
#include "sql_scope.h"
#include "sql_qc.h"
#include "sql_env.h"

#define debugPlan() (be->mvc->debug || (be->mvc->mode == m_debug ))
#define explainPlan() (be->mvc->explain && \
		strcmp(be->mvc->explain, "plan") == 0)
#define explainPerformance() (be->mvc->explain && \
		strcmp(be->mvc->explain, "performance") == 0)

@-
The back end structure collects the information needed to support
compilation and execution of the SQL code against the Monet Version 5
back end. Note that the back-end can be called upon by the front-end
to handle specific tasks, such as catalog management (sql_mvc)
and query execution (sql_qc). For this purpose, the front-end needs
access to operations defined in the back-end, in particular for
freeing the stack and code segment.
@-
@h
typedef struct backend {
	int console;
	int debug;
	int trace;
	char language;		/* 'S' or 's' or 'X' */
	mvc *mvc;
	buffer *outbuf;
	stream *out;
	sql_schema *currSchema;
	sql_table *currTable;
	sql_column *currColumn;
	sql_key *currKey;
	sql_idx *currIndex;
	MalBlkPtr code;
	cq *q;			/* pointer to the cached query */
@-
Some statistics are gathered during the execution of a query
and added to the SQL history table for post analysis when the
query has been successfully executed.
@h
	lng Tread, Tparse, Toptimize, Tschedule, Texec;
	str qry;
} backend;

extern backend *backend_create(int trace, mvc *m, Client c);
extern void backend_destroy(backend *b);

extern int sqlcleanup(mvc *c, int err);
extern stmt *sql_symbol2stmt(mvc *c);

extern BAT *mvc_bind(mvc *m, char *sname, char *tname, char *cname, int access);
extern BAT *mvc_bind_ubat(mvc *m, char *sname, char *tname, char *cname, int access);
extern BAT *mvc_bind_dbat(mvc *m, char *sname, char *tname, int access);
extern BAT *mvc_bind_idxbat(mvc *m, char *sname, char *tname, char *iname, int access);

extern int mvc_export_result(mvc *c, stream *s, int res_id);

#endif /* _SQL_H */

@-
First introduce the routines to be called by the front-end.
@c
#include "sql.h"
#include "sql_result.h"
#include "sql_gencode.h"
#include "bat/bat_store.h"
#include "bat/res_table.h"

backend *
backend_create(int trace, mvc *m, Client c)
{
	backend *b = NEW(backend);

	b->console = isAdministrator(c);
	b->debug = 0;
	b->outbuf = NULL;
	b->out = NULL;
	b->trace = trace;
	b->language = 0;
	b->mvc = m;

	b->currSchema = NULL;
	b->currTable = NULL;
	b->currColumn = NULL;
	b->currKey = NULL;
	b->currIndex = NULL;
	b->code = NULL;
	b->Tread = b->Tparse = b->Toptimize = b->Tschedule = b->Texec = 0;
	b->qry = NULL;
	b->q = NULL;
	return b;
}

void
backend_destroy(backend *b)
{
	_DELETE(b);
}

@-
Stuff copied from the Monet 4 back end
Lookup the statement associated with a specific identifier
from the statement cache. Compile and optimize it for later
consumption, e.g. display
@c
stmt *
sql_symbol2stmt(mvc *c)
{
	stmt *s = semantic(c, c->sym);

	if (s) {
		stmt *opt = optimize(c, s);

		stmt_destroy(s);
		s = rel2bin(c, opt);
		stmt_destroy(opt);
	}
	return s;
}

@-
After the SQL statement has been executed, its data structures
should be garbage collected. For successful actions we have to finish
the transaction as well, e.g. commit or rollback.
@c
int
sqlcleanup(mvc *c, int err)
{
	sql_destroy_params(c);
	sql_destroy_args(c);

	/* some statements dynamically disable caching */
	c->sym = NULL;
	if (c->sa) 
		sa_destroy(c->sa);
	c->sa = sa_create();
	scanner_query_processed(&(c->scanner));
	return err;
}

@-
The internal administration of the SQL compilation and execution state
is administered by a state descriptor accessible in each phase.
Failure to find the state descriptor aborts the session.

@= getContext
{	
	Client _client = getClient();

	if (_client == NULL ) {
		return throwMessage("mvc","Can not access client record");
	} 
	if ( _client->state[PARSER] == NULL) {
		return throwMessage("mvc","PARSER not initialized\n");
	}
	if ( _client->state[OPTIMIZE] == NULL) {
		str schema;
		backend *be = _client->state[PARSER];

		(void)be;
		printf("#Re-establish context for client not expected\n");
		_client->state[OPTIMIZE] == mvc_create(0,0,NULL,GDKout);
		schema = mvc_login( _client->state[OPTIMIZE], 
				GDKstrdup("monetdb"), GDKstrdup("monetdb") );
		if( !schema)
			return throwMessage("getContext","unknown schema for monetdb\n");
		else
			_DELETE(schema);
	}
	@1= ((mvc *) _client ->state[OPTIMIZE]);
}
@= setContext
{
	Client _client = getClient();
	if (_client == NULL || _client ->state[OPTIMIZE]== 0 ) {
		return throwMessage("mvc","Can not get access to @2 state");
	} 
	_client ->state[OPTIMIZE]= @1;
}
@= getBackend
{
	Client _client= getClient();
	if (_client == NULL ) {
		return throwMessage("be","Can not access client record");
	} 
	if ( _client->state[PARSER] == NULL) {
		return throwMessage("be","PARSER not initialized\n");
	}
	@1= ((backend*) _client->state[PARSER]);
}
@c

str
mvc_create_wrap(int *ret, int *debug)
{
	mvc *res = mvc_create(*debug, 0, NULL, GDKout);

	(void) ret;
	@:setContext(res,mvc)@

	return MAL_SUCCEED;
}

str
mvc_destroy_wrap(int *ret)
{
	mvc *m;

	(void) ret;
	@:getContext(m)@
	mvc_destroy(m);
	@:setContext(NULL,mvc)@

	return MAL_SUCCEED;
}

str
mvc_update_var_wrap(int *ret, str *varname)
{
	mvc *m;

	(void) ret;
	@:getContext(m)@
	if (sql_update_var(m, *varname) != GDK_SUCCEED)
		return throwException(MALEXCEPTION, "mvc_update_var", "error");
	return MAL_SUCCEED;
}


BAT *
mvc_bind(mvc *m, char *sname, char *tname, char *cname, int access)
{
	sql_trans *tr = m->trans;
	BAT *b = NULL;
	sql_schema *s = mvc_bind_schema(m, sname);
	sql_table *t = mvc_bind_table(m, s, tname);
	sql_column *c = mvc_bind_column(m, t, cname);

	b = bind_bat(tr, c, access);
	return b;
}


BAT *
mvc_bind_ubat(mvc *m, char *sname, char *tname, char *cname, int access)
{
	sql_trans *tr = m->trans;
	BAT *b = NULL;
	sql_schema *s = mvc_bind_schema(m, sname);
	sql_table *t = mvc_bind_table(m, s, tname);
	sql_column *c = mvc_bind_column(m, t, cname);

	b = bind_ubat(tr, c, access);
	return b;
}

BAT *
mvc_bind_dbat(mvc *m, char *sname, char *tname, int access)
{
	sql_trans *tr = m->trans;
	BAT *b = NULL;
	sql_schema *s = mvc_bind_schema(m, sname);
	sql_table *t = mvc_bind_table(m, s, tname);

	b = bind_dbat(tr, t, access);
	return b;
}

BAT *
mvc_bind_idxbat(mvc *m, char *sname, char *tname, char *iname, int access)
{
	sql_trans *tr = m->trans;
	BAT *b = NULL;
	sql_schema *s = mvc_bind_schema(m, sname);
	sql_idx *i = mvc_bind_idx(m, s, iname);

	(void) tname;
	b = bind_idx(tr, i, access);
	return b;
}

str
mvc_bind_wrap(int *bid, str *sname, str *tname, str *cname, int *access)
{
	mvc *m;
	BAT *b;

	@:getContext(m)@

	b = mvc_bind(m, *sname, *tname, *cname, *access);
	if (b) {
		BBPincref( *bid = b->batCacheid, TRUE);
		BBPunfix( *bid);
		return MAL_SUCCEED;
	}
	return throwException(MALEXCEPTION, "mvc_bind_wrap", "error");
}

@-
Monet 5 extension 
@-
The Mx macro below is used in many places throughout the code base to
access the BAT descriptor.

@= chkIdentifier
	/* generate exception if string is not an identifier */
	if( isIdentifier(@1))
		return throwMessage( "@4","identifier expected");
@= Pseudo
	if (BBPindex("@1_@2_@3") <= 0)
		BATname(b, "@1_@2_@3");
	BATroles(b,"@1","@2");
	BATmode(b,TRANSIENT);
	BATfakeCommit(b);
	*ret = b->batCacheid;

@c

str
mvc_bind_single_wrap(int *ret, int *bid, str *name)
{
	BAT *b, *bn;
	int r;
	ptr p;

	if( (bn= BATdescriptor(*bid)) == NULL)
		return throwMessage("sql.bind","Cannot access descriptor");

	p = BUNfnd(bn, *name);
	r = *(int *) BUNtail(bn, p);
	if( (b= BATdescriptor(r)) == NULL)
		return throwMessage("sql.bind","Cannot access descriptor");
	BBPincref(*ret= b->batCacheid, TRUE);
	BBPunfix( *ret = b->batCacheid);
	BBPunfix( bn->batCacheid);
	return MAL_SUCCEED;
}

str
mvc_bind_ubat_wrap(int *ret, str *sname, str *tname, str *cname, int *access)
{
	mvc *m;
	BAT *b;

	@:getContext(m)@
	b = mvc_bind_ubat(m, *sname, *tname, *cname, *access);
	if (b) {
		BBPincref( *ret = b->batCacheid, TRUE);
		BBPunfix(*ret);
		return MAL_SUCCEED;
	}
	return throwException(MALEXCEPTION, "mvc_bind_ubat_wrap", "error");
}

str
mvc_bind_dbat_wrap(int *ret, str *sname, str *tname, int *access)
{
	mvc *m;
	BAT *b;

	@:getContext(m)@
	b = mvc_bind_dbat(m, *sname, *tname, *access);
	if (b) {
		BBPincref( *ret = b->batCacheid, TRUE);
		BBPunfix(*ret);
		return MAL_SUCCEED;
	}
	return throwException(MALEXCEPTION, "mvc_bind_dbat_wrap", "error");
}

str
mvc_bind_idxbat_wrap(int *ret, str *sname, str *tname, str *iname, int *access)
{
	mvc *m;
	BAT *b;

	@:getContext(m)@
	b = mvc_bind_idxbat(m, *sname, *tname, *iname, *access);
	if (b) {
		BBPincref( *ret = b->batCacheid, TRUE);
		BBPunfix(*ret);
		return MAL_SUCCEED;
	}
	return throwException(MALEXCEPTION, "mvc_bind_idxbat_wrap", "error");
}

str
mvc_clear_table_wrap(lng *res, str sname, str tname)
{
	mvc *m;
	sql_schema *s;
	sql_table *t;

	@:getContext(m)@
	s = mvc_bind_schema(m, sname);
	t = mvc_bind_table(m, s, tname);
	*res = mvc_clear_table(m, t);
	return MAL_SUCCEED;
}

str
mvc_import_table_wrap(int *res, stream **s, str *tname, str *sep, str *rsep, int *sz)
{
	mvc *m;
	BAT *b;

	@:getContext(m)@

	b = mvc_import_table(m, bstream_create(*s, 1024 * 1024), *tname, *sep, *rsep, *sz);
	if (b == 0)
		return throwMessage("sql.importTable", "failed");
	*res = b->batCacheid;
	return MAL_SUCCEED;
}

str
mvc_export_result_wrap(stream *s, int *res_id)
{
	mvc *c;

	@:getContext(c)@
	if (mvc_export_result(c, *(stream **) s, *res_id)) {
		return throwMessage("sql.exportResult", "failed");
	}
	return NULL;
}

str
mvc_export_table_wrap(stream *s, int *res_id, int *offset, int *nr)
{
	mvc *c;

	@:getContext(c)@
	if (mvc_export_table(c, *(stream **) s, *res_id, *offset, *nr)) {
		return throwMessage("sql.exportTable", "failed");
	}
	return NULL;
}

str
bathash_wrap(int *res, int *bid, int *shift)
{
	BAT *b, *dst;
	int sh = *shift;
	hash_t (*hash)(ptr v); 
	int *r, *f;

	if( (b = BATdescriptor(*bid)) == NULL ){
		return throwMessage("bathash", "Cannot access descriptor");
	}

	dst= BATnew(TYPE_void,TYPE_int, BATcount(b));
	if (!dst) {
		BBPunfix(b->batCacheid);
		return throwMessage("bathash", "can not create bat");
	}
	BATseqbase(dst, b->hseqbase);

 	r = (int*)BUNtail(dst, BUNfirst(dst));
	f = r;
	hash = BATatoms[b->ttype].atomHash;
	if (ATOMvarsized(b->ttype)) { /* ugh */
		BUN p,q;
		int xx;

		BATloopFast(b,p,q,xx){
			ptr v = BUNtail(b,p);
			*r++ = (hash(v) << (sh)) & 0xEFFFFFFF;
		}
	} else {
		char *v = BUNtail(b,BUNfirst(b)), *e = BUNtail(b,BUNlast(b));
		int sz = BUNsize(b);

		for(; v < e; v+=sz) {
			*r++ = (hash(v) << (sh)) & 0xEFFFFFFF;
		}
	}
	dst->batBuns->free = ((r-f)*BUNsize(dst));
	BATsetcount(dst, r-f);
	BATkey(dst, 0);
	dst->tsorted = 0;

	BBPincref( *res = dst->batCacheid, TRUE);
	BBPunfix(*res);
	BBPunfix(b->batCacheid);
	return MAL_SUCCEED;
}

str
hash_wrap(MalBlkPtr m, MalStkPtr s, InstrPtr p)
{
	ptr v;
	int *res, tpe = getArgType(m,p,1);
	int sh, shtype = getArgType(m,p,2);

	if (shtype != TYPE_int) {
		assert(0);
		return throwMessage("sql.hash", "failed");
	}

	res= (int *) getArgReference(s,p,0);
	v = getArgReference(s,p,1);
	sh = *(int*)getArgReference(s,p,2);

	if (tpe == TYPE_bat)
		return bathash_wrap(res, (int*)v, &sh); 

	if (ATOMvarsized(tpe)) /* ugh */
		*res = (ATOMhash(tpe, *(char**)v) << (sh)) & 0xEFFFFFFF;
	else
		*res = (ATOMhash(tpe, v) << (sh)) & 0xEFFFFFFF;
	return NULL;
}

@-
The core modules of Monet provide just a limited set of
mathematical operators. The extensions required to support
SQL-99 are shown below. At some point they also should be
moved to module code base.
@= round
str @1_round_wrap( @1 *res, @1 *v, @1 *r )
{
	@1 val = *v;
	@1 add = *r;

	/* shortcut nil */
	if (*v == @1_nil) {
		*res = @1_nil;
		return NULL;
	}

	add >>=1;
	if (val < 0) 
		add = -add;
	val += add; 
	val /= *r;
	*res = val;
	return NULL;
}
str @1_dbl_round_wrap( @1 *res, @1 *v, dbl *r )
{
	@1 add = *r;	/* lossy conversion */
	return @1_round_wrap(res,v, &add);
}

str
str_2dec_@1( @1 *res, str *val, int *d, int *sc )
{
	char *s = strip_extra_zeros(*val);
	char *dot = strchr(s, '.');
	int digits = strlen(s) - 1;
	int scale = digits - (dot-s);
	lng value = 0;

	if (!dot) {
		return throwException(MALEXCEPTION, "@1", 
			"\"%s\" is no decimal value (doesn't contain a '.')", *val);
	}
		
	value = decimal_from_str(s);
	if (*s == '+' || *s == '-')
		digits --;
	if (scale < *sc){
		/* the current scale is too small, increase it by adding 0's */
		int d = *sc - scale;	/* CANNOT be 0! */
		value *= d * 10;
		scale += d;
		digits += d;
	} else if (scale > *sc){
		/* the current scale is too big, decrease it by correctly rounding */
		int d = scale - *sc;	/* CANNOT be 0 */
		value /= (d - 1) * 10;
		if (value % 10 >= 5)
			value += 10;
		value /= 10;
		scale -= d;
		digits -= d;
	}
	if (digits > *d) {
		return throwException(MALEXCEPTION,"@1", 
		     "decimal (%s) doesn't have format (%d,%d)", *val, *d, *sc);
	}
	*res = (@1) value;
	return MAL_SUCCEED;
}
str
str_2num_@1( @1 *res, str *v, int *len )
{
	int zero = 0;
	return str_2dec_@1( res, v, len, &zero );
}
@c

@:round(sht)@
@:round(int)@
@:round(lng)@

@= fround
str @1_round_wrap( @1 *res, @1 *v, @1 *r )
{
	@1 val = *v;

	/* not nil */
	if (ATOMcmp(TYPE_@1, v, ATOMnilptr(TYPE_@1)) != 0) {
		val /= *r;
	}
	*res = val;
	return MAL_SUCCEED;
}
@c
@:fround(flt)@
@:fround(dbl)@

@= cast
str
str_2_@1( @1 *res, str *val )
{
	ptr p = NULL;
	int len = 0;
	int e; 
	
	e = ATOMfromstr(TYPE_@1, &p, &len, *val);
	if (e < 0 || !p || 
	   (ATOMcmp(TYPE_@1, p, ATOMnilptr(TYPE_@1)) == 0 &&
	    ATOMcmp(TYPE_str, *val, ATOMnilptr(TYPE_str)) != 0))
	{
		if (p)
			GDKfree(p);
		return throwMessage("@1", "atom nil");
	}
	*res = *(@1*)p;
	if (p)
		GDKfree(p);
	return MAL_SUCCEED;
}
str
SQL@1_2_str( str *res, @1 *val )
{
	char *p = NULL;
	int len = 0;
	@2( &p, &len, val);
	*res = p;
	return MAL_SUCCEED;
}
@c
@:cast(bit,bitToStr)@
@:cast(oid,OIDtoStr)@
@:cast(sht,shtToStr)@
@:cast(int,intToStr)@
@:cast(lng,lngToStr)@
@:cast(flt,fltToStr)@
@:cast(dbl,dblToStr)@

str
SQLstr_2_str( str *res, str *val )
{
	if( *val == str_nil) 
		*res= str_nil;
	else
		*res =  GDKstrdup(*val);
	return MAL_SUCCEED;
}
str
SQLstr_cast(str *res, ptr v, int tpe, int *len)
{
	int sz = *len + 1;
	char *r = GDKmalloc(sz);

	if (tpe != TYPE_str) {
		sz = BATatoms[tpe].atomToStr(&r, &sz, v);
	} else {
		sz = strlen(v);
		if (sz <= *len) {
			strncpy(r, v, sz);
			r[sz] = 0;
		}
	}
	if (sz > *len) {
		GDKfree(r);
		if (ATOMcmp(TYPE_str, ATOMnilptr(TYPE_str), v) != 0) {
			return throwException(MALEXCEPTION, "str_cast", "value too long for type (var)char(%d)\n", *len);
		} else {
			*res = GDKstrdup(str_nil);
			return MAL_SUCCEED;
		}
	}
	*res = r;
	return MAL_SUCCEED;
}

lng scales[20] = {
	LL_CONSTANT(0),
	LL_CONSTANT(10),
	LL_CONSTANT(100),
	LL_CONSTANT(1000),
	LL_CONSTANT(10000),
	LL_CONSTANT(100000),
	LL_CONSTANT(1000000),
	LL_CONSTANT(10000000),
	LL_CONSTANT(100000000),
	LL_CONSTANT(1000000000),
	LL_CONSTANT(10000000000),
	LL_CONSTANT(100000000000),
	LL_CONSTANT(1000000000000),
	LL_CONSTANT(10000000000000),
	LL_CONSTANT(100000000000000),
	LL_CONSTANT(1000000000000000),
	LL_CONSTANT(10000000000000000),
	LL_CONSTANT(100000000000000000),
	LL_CONSTANT(1000000000000000000)
};

@= simpleupcast
str @2_2_@1( @1 *res, @2 *v )
{
	/* shortcut nil */
	if (*v == @2_nil) {
		*res = @1_nil;
		return(MAL_SUCCEED);
	}
	
	/* since the @1 type is bigger than or equal to the @2 type, it will
	   always fit */
	*res = (@1)*v;
	return(MAL_SUCCEED);
}
@c

@= simpledowncast
str @2_2_@1( @1 *res, @2 *v )
{
	lng val = *v;

	/* shortcut nil */
	if (*v == @2_nil) {
		*res = @1_nil;
		return(MAL_SUCCEED);
	}
	
	/* see if the number fits in the data type */
	if (val >= GDK_@1_min && val <= GDK_@1_max)	{
		*res = (@1)val;
		return(MAL_SUCCEED);
	} else {
		return throwException(MALEXCEPTION,"convert",
			"value (%d) exceeds limits of type @1\n", val);
	}
}
@c

@= numcastup
@:simpleupcast(@1,@2)@

str @2_dec2_@1( @1 *res, int *s1, @2 *v )
{
	int scale = *s1;
	@1 r, h = (*v<0)?-5:5; 

	/* shortcut nil */
	if (*v == @2_nil) {
		*res = @1_nil;
		return(MAL_SUCCEED);
	}

	/* since the @1 type is bigger than or equal to the @2 type, it will
	   always fit */
	r = (@1)*v;
	if (scale) 
		r = (r+h)/scales[scale];
	*res = r;
	return(MAL_SUCCEED);
}

str @2_dec2dec_@1( @1 *res, int *S1, @2 *v, int *d2, int *S2 )
{
	int p = *d2, inlen = 1;
	@2 cpyval = *v;
	int s1 = *S1, s2 = *S2;
	@1 r, h = (*v<0)?-5:5; 

	/* shortcut nil */
	if (*v == @2_nil) {
		*res = @1_nil;
		return(MAL_SUCCEED);
	}
	
	/* count the number of digits in the input */
	while (cpyval /= 10)
		inlen++;

	/* rounding is allowed */
	inlen += (s2-s1);
	if (p && inlen > p) {
		return(throwException(MALEXCEPTION,"convert",
			"too many digits (%d > %d)\n", inlen, p));
	}

	/* since the @1 type is bigger than or equal to the @2 type, it will
	   always fit */
	r = (@1)*v;
	if (s2 > s1) 
		r *= scales[s2-s1];
	else if (s2 != s1) 
		r = (r+h)/scales[s1-s2];
	*res = r;
	return(MAL_SUCCEED);
}

str @2_num2dec_@1( @1 *res, @2 *v, int *d2, int *s2 )
{
	int zero = 0;
	return @2_dec2dec_@1( res, &zero, v, d2, s2 );
}

@c
@:numcastup(sht,sht)@
@:numcastup(int,sht)@
@:numcastup(int,int)@
@:numcastup(lng,sht)@
@:numcastup(lng,int)@
@:numcastup(lng,lng)@

@= fnumcastdown
@:simpledowncast(@1,@2)@

/* when casting a floating point to an decimal we like to preserve the 
 * precision.  This means we first scale the float before converting.
*/
str @2_num2dec_@1( @1 *res, @2 *v, int *s2, int *d2 )
{
	int p = *d2, inlen = 1, scale = *s2;
	@2 r;
	lng cpyval;

	/* shortcut nil */
	if (*v == @2_nil) {
		*res = @1_nil;
		return(MAL_SUCCEED);
	}
	
	/* since the @1 type is bigger than or equal to the @2 type, it will
	   always fit */
	r = (@1)*v;
	if (scale) 
		r *= scales[scale];
	cpyval = r;

	/* count the number of digits in the input */
	while (cpyval /= 10)
		inlen++;
	/* rounding is allowed */
	if (p && inlen > p) {
		return(throwException(MALEXCEPTION,"convert",
			"too many digits (%d > %d)\n", inlen, p));
	}
	*res = r;
	return MAL_SUCCEED;
}
@c
@:fnumcastdown(sht,flt)@
@:fnumcastdown(int,flt)@
@:fnumcastdown(lng,flt)@
@:fnumcastdown(sht,dbl)@
@:fnumcastdown(int,dbl)@
@:fnumcastdown(lng,dbl)@

@= fnumcastup
@:simpleupcast(@1,@2)@

str @2_dec2_@1( @1 *res, int *s1, @2 *v )
{
	int scale = *s1;
	@1 r;

	/* shortcut nil */
	if (*v == @2_nil) {
		*res = @1_nil;
		return(MAL_SUCCEED);
	}
	
	/* since the @1 type is bigger than or equal to the @2 type, it will
	   always fit */
	r = (@1)*v;
	if (scale) 
		r /= scales[scale];
	*res = r;
	return MAL_SUCCEED;
}

str @2_dec2dec_@1( @1 *res, int *S1, @2 *v, int *d2, int *S2 )
{
	int p = *d2, inlen = 1;
	@2 cpyval = *v;
	int s1 = *S1, s2 = *S2;
	@1 r;

	/* shortcut nil */
	if (*v == @2_nil) {
		*res = @1_nil;
		return(MAL_SUCCEED);
	}
	
	/* count the number of digits in the input */
	while (cpyval /= 10)
		inlen++;
	/* rounding is allowed */
	inlen += (s2-s1);
	if (p && inlen > p) {
		return(throwException(MALEXCEPTION,"convert",
			"too many digits (%d > %d)\n", inlen, p));
	}

	/* since the @1 type is bigger than or equal to the @2 type, it will
	   always fit */
	r = (@1)*v;
	if(s2 > s1) 
		r *= scales[s2-s1];
	else if (s2 != s1) 
		r /= scales[s1-s2];
	*res = r;
	return MAL_SUCCEED;
}

str @2_num2dec_@1( @1 *res, @2 *v, int *d2, int *s2 )
{
	int zero = 0;
	return @2_dec2dec_@1( res, &zero, v, d2, s2 );
}
@c
@:fnumcastup(flt,sht)@
@:fnumcastup(flt,int)@
@:fnumcastup(flt,lng)@
@:fnumcastup(dbl,sht)@
@:fnumcastup(dbl,int)@
@:fnumcastup(dbl,lng)@

@c
@= numcastdown
@:simpledowncast(@1,@2)@

str @2_dec2_@1( @1 *res, int *s1, @2 *v )
{
	int scale = *s1;
	lng val = *v, h = (val<0)?-5:5;

	/* shortcut nil */
	if (*v == @2_nil) {
		*res = @1_nil;
		return(MAL_SUCCEED);
	}
	
	if (scale) 
		val = (val+h)/scales[scale];
	/* see if the number fits in the data type */
	if (val >= GDK_@1_min && val <= GDK_@1_max)	{
		*res = (@1)val;
		return MAL_SUCCEED;
	} else {
		return throwException(MALEXCEPTION,"convert",
			"value (%d) exceeds limits of type @1\n", val);
	}
}

str @2_dec2dec_@1( @1 *res, int *S1, @2 *v, int *d2, int *S2 )
{
	int p = *d2, inlen = 1;
	lng val = *v, cpyval = val, h = (val<0)?-5:5;
	int s1 = *S1, s2 = *S2;

	/* shortcut nil */
	if (*v == @2_nil) {
		*res = @1_nil;
		return(MAL_SUCCEED);
	}
	
	/* count the number of digits in the input */
	while (cpyval /= 10)
		inlen++;
	/* rounding is allowed */
	inlen += (s2-s1);
	if (p && inlen > p) {
		return(throwException(MALEXCEPTION,"@2_2_@1",
			"too many digits (%d > %d)\n", inlen, p));
	}

	if(s2 > s1) 
		val *= scales[s2-s1];
	else if (s2 != s1) 
		val = (val+h)/scales[s1-s2];

	/* see if the number fits in the data type */
	if (val >= GDK_@1_min && val <= GDK_@1_max)	{
		*res = (@1)val;
		return MAL_SUCCEED;
	} else {
		return throwException(MALEXCEPTION,"convert",
			"value (%d) exceeds limits of type @1\n", val);
	}
}

str @2_num2dec_@1( @1 *res, @2 *v, int *d2, int *s2 )
{
	int zero = 0;
	return @2_dec2dec_@1( res, &zero, v, d2, s2 );
}
@c
@:numcastdown(sht,int)@
@:numcastdown(sht,lng)@
@:numcastdown(int,lng)@
