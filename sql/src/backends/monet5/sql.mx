@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2008 CWI.
@' All Rights Reserved.

@f sql
@t SQL Scenario implementation
@a M Kersten 
@v 0
@* SQL support implementation
This module contains the wrappers around the SQL 
multi-version-catalog and support routines copied
from the Version 4 code base.

@mal
module batsql;
module sql;

command start():void 
address SQLsession
comment "Switch to processing SQL statements";

command start2():void
address SQLsession2
comment "Switch to processing precompiled sql statements";

command init():void
address SQLinitEnvironment
comment "Initialize the environment for MAL";

command commit():void
address SQLcommit_wrap;
command rollback():void
address SQLrollback_wrap;

command eval(cmd:str):void 
address SQLstatement
comment "Compile and execute a single sql statement";

pattern assert(b:bit,msg:str):void
address SQLassert
comment "Generate an exception when b==true";

pattern assert(b:int,msg:str):void
address SQLassertInt
comment "Generate an exception when b!=0";

pattern assert(b:lng,msg:str):void
address SQLassertLng
comment "Generate an exception when b!=0";
@-
@{
command startQuery(s:str):void
address SQLstartQuery
comment "Initialize tracing query performance";

command exitQuery(s:str):void
address SQLexitQuery
comment "Finalize tracing query performance";
@}
@- The SQL multi-version catalog
This module also contains the definitions for managing an SQL database schema in
version 5.  It is an adaptation of the original V4.3 code base. 
A main difference is that the global catalog is obtained from
the client record, rather then lookup the variable in a context stack.

The MAL operations below are used in the SQL->MAL compiler and
can be (sparingly) used to inspect it from a MIL console.
The 'mvc_' header is removed, because all commands are already
prepended by the 'sql.' module name.
The original code is retained, because it makes it
easier to later re-use part of the catalog code in a separately.
@mal

pattern setVariable( varname:str, value:any_1 ):void
address setVariable
comment "Set the value of a session variable";

pattern getVariable( varname:str ):any_1
address getVariable
comment "Get the value of a session variable";

command logfile(filename:str):void 
address mvc_logfile
comment "Enable/disable saving the sql statement traces";

command next_value( sname:str, sequence:str ):lng
address mvc_next_value
comment "return the next value of the sequence";

command batsql.next_value( sname:bat[:oid,:str], sequence:str ) :bat[:oid,:lng]
address mvc_bat_next_value
comment "return the next value of the sequence";

command get_value( sname:str, sequence:str ):lng
address mvc_get_value
comment "return the current value of the sequence";

command restart( sname:str, sequence:str, start:lng ):lng
address mvc_restart_seq
comment "restart the sequence with value start";

command bind_dbat(sname:str, tname:str, access:int):bat[:oid,:oid]
address mvc_bind_dbat_wrap
comment "Bind the table deletes bat, tname.delete 
	with specific access modes";

command bind_idxbat(sname:str, tname:str, iname:str, access:int):bat[:oid,:any_1]
address mvc_bind_idxbat_wrap
comment "Bind the idx bat, tname.idx
	with specific accsess modes";

command bind(sname:str, tname:str, cname:str, access:int ):bat[:oid,:any_1]
address mvc_bind_wrap
comment "Bind the bat tname.cname into the focus with specific access mode";

pattern append(sname:str, tname:str, cname:str, ins:any ):void
address mvc_append_wrap
comment "Append b to the column tname.cname (possibly optimized to replace the insert bat of tname.cname";

pattern update(sname:str, tname:str, cname:str, ins:any ):void
address mvc_update_wrap
comment "Append b to the column tname.cname (possibly optimized to replace the insert bat of tname.cname";

command clear_table(sname:str, tname:str) :lng
address mvc_clear_table_wrap
comment "Clear table";

pattern delete(sname:str, tname:str, b:any) :void 
address mvc_delete_wrap
comment "delete from table";

command columnBind(b:bat[:str,:bat], nme:str) :bat[:oid,:any_1]
address mvc_bind_single_wrap
comment "Bind the column bat into the focus ";

@-
The Monet 5 code generator uses several SQL specific wrapper functions.
They are not present in V4
@mal
command resultSet( nr_cols:int, sep:str, rsep:str, ssep:str, ns:str, order:bat[:oid,:any_1] ) :int 
address mvc_result_file_wrap
comment "Prepare a file result set"; 

command resultSet( nr_cols:int, qtype:int, order:bat[:oid,:any_1] ) :int 
address mvc_result_table_wrap
comment "Prepare a table result set"; 

command resultSet( nr_cols:int, qtype:int, order:any_1 ) :int 
address mvc_result_row_wrap
comment "Prepare a row result set"; 

command resultSet( nr_cols:int, qtype:int, order:bat[:oid,:any_1] ) :int 
address mvc_result_table_wrap
comment "Prepare a table result set"; 

pattern rsColumn(rs:int, tname:str, name:str, typename:str, digits:int, scale:int, val:any_1 ) :void
address mvc_result_value_wrap
comment "Add the value to the row query result";

command rsColumn(rs:int, tname:str, name:str, typename:str, digits:int, scale:int, col:bat[:oid,:any_1] ) :void
address mvc_result_column_wrap
comment "Add the colunm to the table query result";

command rsColumn(rs:int, tname:str, name:str, typename:str, digits:int, scale:int, val:bte ) :void
address mvc_result_value_bte;
command rsColumn(rs:int, tname:str, name:str, typename:str, digits:int, scale:int, val:sht ) :void
address mvc_result_value_sht;
command rsColumn(rs:int, tname:str, name:str, typename:str, digits:int, scale:int, val:lng ) :void
address mvc_result_value_lng;
command rsColumn(rs:int, tname:str, name:str, typename:str, digits:int, scale:int, val:int ) :void
address mvc_result_value_int;

command exportResult(s:streams, res_id:int, w:str) :void
address mvc_export_result_wrap
comment "Export a result (in order) to stream s"; 

command exportOperation(w:str) :void
address mvc_export_operation_wrap
comment "Export result of schema/transaction queries"; 

command affectedRows(nr:int, w:str) :void
address mvc_affected_rows_int
comment "export the number of affected rows by the current query";

command affectedRows(nr:lng, w:str) :void
address mvc_affected_rows_wrap
comment "export the number of affected rows by the current query";

pattern exportValue(qtype:int, tname:str, name:str, typename:str, digits:int, scale:int, eclass:int, val:any_1, w:str):void
address mvc_export_value_wrap 
comment "export a single value onto the stream s";

command importTable( s:bstream, tname:str, 
	sep:str, rsep:str, ssep:str, ns:str, nr:int, offset:int) :bat[:str,:bat] 
address mvc_import_table_wrap
comment "Import a table from bstream s with the 
	given tuple and seperators (sep/rsep)";

command zero_or_one( col:bat[:any_2,:any_1]) :any_1
address zero_or_one
comment "if col contains exactly one value return this. Incase of more raise an exception else return nil";

command not_unique( b:bat[:oid,:oid]) :bit 
address not_unique 
comment "check if the tail sorted bat b doesn't have unique tail values" ;
command not_unique( b:bat[:oid,:oid]) :bit 
address not_unique ;

function sql_environment():bat[:str,:bat];
	b := bat.new(:str,:bat,2);
	e := inspect.getEnvironment();
	n := algebra.markT(e, 0:oid);
	r := bat.reverse(n);
	v := algebra.markH(e, 0:oid);
	bat.insert(b, "name", r);
	bat.insert(b, "value", v);
	return b;
end sql_environment;

function clients():bat[:str,:bat];
	b := bat.new(:str,:bat,5);
	u:= clients.getUsers();
	bat.insert(b,"user",u);
	l:= clients.getLogins();
	bat.insert(b,"login",l);
	c:= clients.getLastCommand();
	bat.insert(b,"lastcommand",c);
	a:= clients.getActions();
	bat.insert(b,"actions",a);
	t:= clients.getTime();
	bat.insert(b,"seconds",t);
	return b;
end clients;

function bbp():bat[:str,:bat];
	b := bat.new(:str,:bat,12);
	ns := bbp.getNames();
	ri := algebra.markT(ns, 0:oid);
	i := bat.reverse(ri);
	n := algebra.markH(ns, 0:oid);
	bat.insert(b, "id", i);
	bat.insert(b, "name", n);
	iht := bbp.getHeadType();
	ht := algebra.markH(iht, 0:oid);
	bat.insert(b, "htype", ht);
	itt := bbp.getTailType();
	tt := algebra.markH(itt, 0:oid);
	bat.insert(b, "ttype", tt);
	icnt := bbp.getCount();
	cnt := algebra.markH(icnt, 0:oid);
	bat.insert(b, "count", cnt);
	irefcnt := bbp.getRefCount();
	refcnt := algebra.markH(irefcnt, 0:oid);
	bat.insert(b, "refcnt", refcnt);
	ilrefcnt := bbp.getLRefCount();
	lrefcnt := algebra.markH(ilrefcnt, 0:oid);
	bat.insert(b, "lrefcnt", lrefcnt);
	ilocation := bbp.getLocation();
	location := algebra.markH(ilocation, 0:oid);
	bat.insert(b, "location", location);
	iheat := bbp.getHeat();
	heat := algebra.markH(iheat, 0:oid);
	bat.insert(b, "heat", heat);
	idirty := bbp.getDirty();
	dirty := algebra.markH(idirty, 0:oid);
	bat.insert(b, "dirty", dirty);
	istatus := bbp.getStatus();
	status := algebra.markH(istatus, 0:oid);
	bat.insert(b, "status", status);
	ikind := bbp.getKind();
	kind := algebra.markH(ikind, 0:oid);
	bat.insert(b, "kind", kind);
	return b;
end bbp;

command sql_variables():bat[:str,:bat]
address sql_variables
comment "return the table with session variables";

command db_users() :bat[:str,:bat]
address db_users_wrap
comment "return table of users with sql scenario";

command dump_cache() :bat[:str,:bat]
address dump_cache
comment "dump the content of the query cache";

command dump_opt_stats() :bat[:str,:bat]
address dump_opt_stats
comment "dump the optimizer rewrite statistics";

@- SQL function aliases
The code generate should identify the precise module
target for all functions. This creates quite some
administration overhead and analysis at many places.
The alternative is to extend modules with an alias.

The routine below are added to the calc module to
ease code generation.
@mal
pattern calc.rotate_xor_hash(h:int, nbits:int, v:any_1) :int address MKEYrotate_xor_hash;
command batcalc.rotate_xor_hash(h:bat[:oid,:int], nbits:int, b:bat[:oid,:any_1]) :bat[:oid,:int] address MKEYbulk_rotate_xor_hash;

pattern calc.hash( v:any ) :int address MKEYhash; 
command calc.hash( v:chr ) :int address MKEYhash_chr; 
command calc.hash( v:bte ) :int address MKEYhash_bte; 
command calc.hash( v:sht ) :int address MKEYhash_sht; 
command calc.hash( v:int ) :int address MKEYhash_int; 
command calc.hash( v:flt ) :int address MKEYhash_flt; 
command calc.hash( v:dbl ) :int address MKEYhash_dbl; 
command calc.hash( v:lng ) :int address MKEYhash_lng; 
command calc.hash( v:str ) :int address MKEYhash_str; 

command batcalc.hash( b:bat[:oid,:any_1] ) :bat[:oid,:int]
address bathash_wrap 
comment "calculate a hash value";

@- SQL functions
The SQL functions are all recognized by their module name.
For some we need to provide a new implementation, others
merely require a different address binding.

The aggregate operations work on doubles by default.
This calls for casting values around in the process.
@= mal_round
command dec_round( v:@1, r:@1 ) :@1 
address @1_dec_round_wrap
comment "round off the value v to nearests multiple of r";


command round( v:@1, d:int, s:int, r:bte) :@1
address @1_round_wrap
comment "round off the decimal v(d,s) to r digits behind the dot (if r < 0, before the dot)";
@-
@{
command dec_round( v:@1, r:dbl ) :@1 
address @1_dbl_dec_round_wrap
comment "round off the value v to nearests multiple of r";
command dec_round( v:@1, r:int ) :@1 
address @1_int_dec_round_wrap
comment "round off the value v to nearests multiple of r";
@}
@mal

command aggr.exist(b:bat[:any_1,:any_2], h:any_1):bit 
address ALGexist;

@:mal_round(bte)@
@:mal_round(sht)@
@:mal_round(int)@
@:mal_round(lng)@

command dec_round( v:flt, r:flt ) :flt 
address flt_flt_dec_round_wrap
comment "round off the value v to nearests multiple of r";

command dec_round( v:dbl, r:dbl ) :dbl 
address dbl_dbl_dec_round_wrap
comment "round off the value v to nearests multiple of r";
@-
@{
command dec_round( v:flt, r:int ) :flt 
address flt_int_dec_round_wrap
comment "round off the value v to nearests multiple of r";
command dec_round( v:dbl, r:int ) :dbl
address dbl_int_dec_round_wrap
comment "round off the value v to nearests multiple of r";
@}

@= mal_cast
command calc.@1( v:str ) :@1 
address str_2_@1
comment "Cast to @1";
command calc.@1( v:str, digits:int ) :@1 
address str_2num_@1
comment "cast to @1 and check for overflow";
command calc.@1( v:str, digits:int, scale:int ) :@1 
address str_2dec_@1
comment "cast to dec(@1) and check for overflow";

command batcalc.@1( v:bat[:oid,:str] ) :bat[:oid,:@1] 
address batstr_2_@1
comment "Cast to @1";
command batcalc.@1( v:bat[:oid,:str], digits:int ) :bat[:oid,:@1] 
address batstr_2num_@1
comment "cast to @1 and check for overflow";
command batcalc.@1( v:bat[:oid,:str], digits:int, scale:int ) :bat[:oid,:@1] 
address batstr_2dec_@1
comment "cast to dec(@1) and check for overflow";
@-
@{
address CALCstr2@1
command calc.str( v:@1 ) :str
address CALC@12str
comment "Cast @1 to str";
@}
@mal
@:mal_cast(bte)@
@:mal_cast(sht)@
@:mal_cast(int)@
@:mal_cast(lng)@

@= mal_castfromstr
command calc.@1( v:str ) :@1 
address str_2_@1
comment "cast to @1";
command batcalc.@1( v:bat[:oid,:str] ) :bat[:oid,:@1] 
address batstr_2_@1
comment "cast to @1";
command calc.str( v:@1 ) :str 
address SQL@1_2_str
comment "cast @1 to str";
@mal
@:mal_castfromstr(flt)@
@:mal_castfromstr(dbl)@
@:mal_castfromstr(timestamp)@
@:mal_castfromstr(daytime)@
@:mal_castfromstr(date)@
@:mal_castfromstr(sqlblob)@

@mal
command calc.str( v:str) :str 
address CALCstr2str
comment "Idempotent cast of strings";

@+ bit conversion (why?) 
command calc.str( v:bit) :str 
address CALCbit2str
comment "Idempotent cast of strings";

command calc.bte( v:bit) :bte 
address CALCbit2bte
comment "Cast bit to bte ";
command calc.sht( v:bit) :sht 
address CALCbit2sht
comment "Cast bit to sht ";
command calc.int( v:bit) :int 
address CALCbit2int
comment "Cast bit to int ";
command calc.lng( v:bit) :lng 
address CALCbit2lng
comment "Cast bit to lng ";
@mal

pattern calc.str( eclass:int, d1:int, s1:int, has_tz:int, v:any_1, digits:int ) :str 
address SQLstr_cast
comment "cast to string and check for overflow";

command batcalc.str( eclass:int, d1:int, s1:int, has_tz:int, v:bat[:oid,:any_1], digits:int ) :bat[:oid,:str] 
address SQLbatstr_cast
comment "cast to string and check for overflow";

command calc.substring(s:str,offset:int):str
address STRsubstringTail;
command calc.substring(s:str,offset:int,count:int):str
address STRsubstring;

@= mal_cast_2dec
command calc.@1( v:@2) :@1 
address @2_2_@1
comment "cast @2 to @1";
command calc.@1( v:@2, digits:int, scale:int ) :@1 
address @2_num2dec_@1
comment "cast number to decimal(@1) and check for overflow";

command batcalc.@1( v:bat[:oid,:@2]) :bat[:oid,:@1]
address bat@2_2_@1
comment "cast @2 to @1";
command batcalc.@1( v:bat[:oid,:@2], digits:int, scale:int ) :bat[:oid,:@1] 
address bat@2_num2dec_@1
comment "cast number to decimal(@1) and check for overflow";
@mal
@:mal_cast_2dec(bte,flt)@
@:mal_cast_2dec(sht,flt)@
@:mal_cast_2dec(int,flt)@
@:mal_cast_2dec(lng,flt)@
@:mal_cast_2dec(bte,dbl)@
@:mal_cast_2dec(sht,dbl)@
@:mal_cast_2dec(int,dbl)@
@:mal_cast_2dec(lng,dbl)@

@= mal_cast_dec2
command calc.@1( s1:int, v:@2) :@1 
address @2_dec2_@1
comment "cast decimal(@2) to @1 and check for overflow";
command calc.@1( s1:int, v:@2, d2:int, s2:int ) :@1 
address @2_dec2dec_@1
comment "cast decimal(@2) to decimal(@1) and check for overflow";

command batcalc.@1( s1:int, v:bat[:oid,:@2]) :bat[:oid,:@1]
address bat@2_dec2_@1
comment "cast decimal(@2) to @1 and check for overflow";
command batcalc.@1( s1:int, v:bat[:oid,:@2], d2:int, s2:int ) :bat[:oid,:@1] 
address bat@2_dec2dec_@1
comment "cast decimal(@2) to decimal(@1) and check for overflow";
@mal

@= mal_cast2
@:mal_cast_2dec(@1,@2)@
@:mal_cast_dec2(@1,@2)@
@mal
@:mal_cast2(bte,bte)@
@:mal_cast2(bte,sht)@
@:mal_cast2(bte,int)@
@:mal_cast2(bte,lng)@
@:mal_cast2(sht,bte)@
@:mal_cast2(sht,sht)@
@:mal_cast2(sht,int)@
@:mal_cast2(sht,lng)@
@:mal_cast2(int,bte)@
@:mal_cast2(int,sht)@
@:mal_cast2(int,int)@
@:mal_cast2(int,lng)@
@:mal_cast2(lng,bte)@
@:mal_cast2(lng,sht)@
@:mal_cast2(lng,int)@
@:mal_cast2(lng,lng)@
@:mal_cast2(flt,bte)@
@:mal_cast2(flt,sht)@
@:mal_cast2(flt,int)@
@:mal_cast2(flt,lng)@
@:mal_cast2(dbl,bte)@
@:mal_cast2(dbl,sht)@
@:mal_cast2(dbl,int)@
@:mal_cast2(dbl,lng)@

@= mal_interval
command calc.month_interval( v:@1, ek:int, sk:int ) :int
address month_interval_@1
comment "cast @1 to a month_interval and check for overflow";

command calc.second_interval( v:@1, ek:int, sk:int ) :lng
address second_interval_@1
comment "cast @1 to a month_interval and check for overflow";
@mal

@:mal_interval(str)@
@:mal_interval(bte)@
@:mal_interval(sht)@
@:mal_interval(int)@
@:mal_interval(lng)@

command sql.rank_grp(b:bat[:oid,:any_1], gp:bat[:oid,:oid], gpe:bat[:oid,:oid]) :bat[:oid,:int] 
address sql_rank_grp
comment "return the ranked groups";

command sql.rank(b:bat[:oid,:any_1]) :bat[:oid,:int] 
address sql_rank
comment "return the rank bat";

command sql.dense_rank_grp(b:bat[:oid,:any_1], gp:bat[:oid,:oid], gpe:bat[:oid,:oid]) :bat[:oid,:int] 
address sql_dense_rank_grp
comment "return the densely ranked groups";

command sql.dense_rank(b:bat[:oid,:any_1]) :bat[:oid,:int] 
address sql_dense_rank
comment "return the densely ranked bat";

function batcalc.mark_grp( b:bat[:oid,:any_1], a:bat[:any_2,:any_3], g:bat[:oid,:oid]) :bat[:oid,:int]; 
	x := algebra.mark_grp(a,g,1:oid);
	return batcalc.int(x);
end batcalc.mark_grp;

function batcalc.mark_grp( b:bat[:oid,:any_1] ) :bat[:oid,:int]; 
	x := algebra.markT(b,1:oid);
	return batcalc.int(x);
end batcalc.mark_grp;

function batcalc.rank_grp( b:bat[:oid,:any_1], gp:bat[:oid,:oid], gpe:bat[:oid,:oid]) :bat[:oid,:int]; 
	o := bat.mirror(b);
	g := algebra.join(o, gp);
	return sql.rank_grp(b, g, gpe);
end batcalc.rank_grp;

function batcalc.rank_grp( b:bat[:oid,:any_1]) :bat[:oid,:int]; 
	return sql.rank(b);
end batcalc.rank_grp;

function batcalc.dense_rank_grp( b:bat[:oid,:any_1], gp:bat[:oid,:oid], gpe:bat[:oid,:oid]) :bat[:oid,:int]; 
	o := bat.mirror(b);
	g := algebra.join(o, gp);
	return sql.dense_rank_grp(b, g, gpe);
end batcalc.dense_rank_grp;

function batcalc.dense_rank_grp( b:bat[:oid,:any_1]) :bat[:oid,:int]; 
	return sql.dense_rank(b);
end batcalc.dense_rank_grp;

function sql.zero_or_one( b:bat[:oid,:any_1], gp:bat[:oid,:oid], gpe:bat[:oid,:oid]) :bat[:oid,:any_1];
	(e,g) := group.new(gp);
	m := aggr.max(e);
	c0 := calc.isnil(m);
	c0 := calc.not(c0);
	c1 := calc.>(m,1);
	c1 := calc.and(c0,c1);
	ms := calc.str(m); 
	msg := str.+("zero_or_one: cardinality violation (", ms);
	msg := str.+(msg, ">1)");
	assert(c1, msg);
	return b;
end sql.zero_or_one;


function mmath.rand( v:int ) :int;
	x := mmath.rand();
	return x;
end mmath.rand;

@mal

command prelude()
address SQLprelude;

command epilogue()
address SQLepilogue;

sql.prelude();

include sql_bpm;

@h
#ifndef _SQL_H
#define _SQL_H

#include <sql_mem.h>

#ifdef WIN32
#ifndef LIBSQL
#define sql5_export extern __declspec(dllimport)
#else
#define sql5_export extern __declspec(dllexport)
#endif
#else
#define sql5_export extern
#endif

#include "sql_mvc.h"
#include <sql_backend.h>
#include <mal_session.h>

#include <mal_function.h>
#include <mal_stack.h>
#include <mal_interpreter.h>
#include <mal_session.h>
#include <tablet.h>
#include <streams.h>
#include <mtime.h>
#include <blob.h>
#include "sql_privileges.h"
#include "sql_semantic.h"
#include "sql_optimize.h"
#include "sql_rel2bin.h"
#include <bin_optimizer.h>
#include "sql_decimal.h"
#include "sql_string.h"
#include "sql_scope.h"
#include "sql_qc.h"
#include "sql_env.h"
#include <opt_replicator.h>

@-
The back-end structure collects the information needed to support
compilation and execution of the SQL code against the Monet Version 5
back end. Note that the back-end can be called upon by the front-end
to handle specific tasks, such as catalog management (sql_mvc)
and query execution (sql_qc). For this purpose, the front-end needs
access to operations defined in the back-end, in particular for
freeing the stack and code segment.
@-
@h
typedef struct backend {
	int console;
	char language;		/* 'S' or 's' or 'X' */
	mvc *mvc;
	stream *out;
	Client client;
	sql_schema *currSchema;
	sql_table *currTable;
	sql_column *currColumn;
	sql_key *currKey;
	sql_idx *currIndex;
	int	vtop;		/* top of the variable stack before the current function */
	cq *q;			/* pointer to the cached query */
@-
Some statistics are gathered during the execution of a query
and added to the SQL history table for post analysis when the
query has been successfully executed.
@h
	lng Tparse, Toptimize, Tschedule, Texec;
	str qry;
} backend;

extern backend *backend_reset(backend *b);
extern backend *backend_create(mvc *m, Client c);
extern void backend_destroy(backend *b);

extern int sqlcleanup(mvc *c, int err);
extern stmt *sql_symbol2stmt(mvc *c, symbol *sym);

extern BAT *mvc_bind(mvc *m, char *sname, char *tname, char *cname, int access);
extern BAT *mvc_bind_dbat(mvc *m, char *sname, char *tname, int access);
extern BAT *mvc_bind_idxbat(mvc *m, char *sname, char *tname, char *iname, int access);

sql5_export str SQLcommit_wrap(int *ret);
sql5_export str SQLrollback_wrap(int *ret);
sql5_export str mvc_bind_wrap(int *bid, str *sname, str *tname, str *cname, int *access);
sql5_export void replicator_sql(struct _sql_functions *sqlfp);

sql5_export str mvc_append_wrap(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str mvc_update_wrap(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str mvc_bind_single_wrap(int *ret, int *bid, str *name);
sql5_export str mvc_bind_dbat_wrap(int *ret, str *sname, str *tname, int *access);
sql5_export str mvc_bind_idxbat_wrap(int *ret, str *sname, str *tname, str *iname, int *access);
sql5_export str mvc_clear_table_wrap(lng *res, str *sname, str *tname);
sql5_export str mvc_delete_wrap(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str mvc_result_row_wrap(int *res_id, int *nr_cols, int *qtype, int *o);
sql5_export str mvc_result_file_wrap(int *res_id, int *nr_cols, unsigned char* *sep, unsigned char* *rsep, unsigned char* *ssep, unsigned char* *ns, bat *order_bid);
sql5_export str mvc_result_table_wrap(int *res_id, int *nr_cols, int *qtype, bat *order_bid);
sql5_export str mvc_result_column_wrap(int *ret, int *rs, str *tn, str *name, str *type, int *digits, int *scale, bat *bid);
@= result_value_export
sql5_export str mvc_result_value_@1(int *ret, int *rs, str *tn, str *name, str *type, int *digits, int *scale, @1 *val);
@h
@:result_value_export(flt)@
@:result_value_export(dbl)@
@:result_value_export(lng)@
@:result_value_export(int)@
@:result_value_export(sht)@
@:result_value_export(bte)@

sql5_export str mvc_result_value_wrap(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str mvc_affected_rows_wrap(int *r, lng *nr, str *w);
sql5_export str mvc_export_result_wrap(int *ret, stream **s, int *res_id, str *w);
sql5_export str mvc_export_operation_wrap(int *ret, str *w);
sql5_export str mvc_export_value_wrap(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str mvc_import_table_wrap(int *res, bstream **s, str *tname, unsigned char* *sep, unsigned char* *rsep, unsigned char* *ssep, unsigned char* *ns, int *sz, int *offset);
sql5_export str bathash_wrap(int *res, int *bid );
sql5_export str hash_wrap(MalBlkPtr m, MalStkPtr s, InstrPtr p);
sql5_export str setVariable(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str getVariable(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str sql_variables(int *res);
sql5_export str mvc_logfile(int *d, str *filename);
sql5_export str mvc_next_value(lng *res, str *sname, str *seqname);
sql5_export str mvc_bat_next_value(int *res, int *sname, str *seqname);
sql5_export str mvc_get_value(lng *res, str *sname, str *seqname);
sql5_export str mvc_restart_seq(lng *res, str *sname, str *seqname, lng *start);
sql5_export str mvc_affected_rows_int(int *r, int *nr, str *w);
sql5_export str zero_or_one(ptr ret, int *bid);
sql5_export str not_unique(bit *ret, int *bid);
sql5_export str month_interval_str( int *ret, str *s, int *ek, int *sk );
sql5_export str second_interval_str( lng *res, str *s, int *ek, int *sk );
sql5_export str dump_cache(int *r);
sql5_export str dump_opt_stats(int *r);
@= round_export
sql5_export str @1_dec_round_wrap( @1 *res, @1 *v, @1 *r );
sql5_export str @1_dbl_dec_round_wrap( @1 *res, @1 *v, dbl *r );
sql5_export str @1_int_dec_round_wrap( @1 *res, @1 *v, int *r );
sql5_export str @1_round_wrap( @1 *res, @1 *v, int *d, int *s, bte *r );
sql5_export str str_2dec_@1( @1 *res, str *val, int *d, int *sc );
sql5_export str str_2num_@1( @1 *res, str *v, int *len );
sql5_export str batstr_2dec_@1( int *res, int *val, int *d, int *sc );
sql5_export str batstr_2num_@1( int *res, int *v, int *len );
@h
@:round_export(bte)@
@:round_export(sht)@
@:round_export(int)@
@:round_export(lng)@
@= cast_export
sql5_export str str_2_@1( @1 *res, str *val );
sql5_export str batstr_2_@1( int *res, int *val );
sql5_export str SQL@1_2_str( str *res, @1 *val );
@h
@:cast_export(bit,bitToStr)@
@:cast_export(oid,OIDtoStr)@
@:cast_export(bte,bteToStr)@
@:cast_export(sht,shtToStr)@
@:cast_export(int,intToStr)@
@:cast_export(lng,lngToStr)@
@:cast_export(flt,fltToStr)@
@:cast_export(dbl,dblToStr)@
@:cast_export(timestamp,timestamp_tostr)@
@:cast_export(daytime,daytime_tostr)@
@:cast_export(date,date_tostr)@
@:cast_export(sqlblob,sqlblob_tostr)@
sql5_export str SQLstr_cast(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str SQLbatstr_cast(int *r, int *eclass, int *d1, int *s1, int *has_tz, int *v, int *digits );
@= fround_export
sql5_export str @1_@2_dec_round_wrap( @1 *res, @1 *v, @2 *r );
@h
@:fround_export(flt,flt)@
@:fround_export(flt,int)@
@:fround_export(dbl,dbl)@
@:fround_export(dbl,int)@
@= c_interval_export
sql5_export str month_interval_@1( int *ret, @1 *s, int *ek, int *sk );
sql5_export str second_interval_@1( lng *res, @1 *s, int *ek, int *sk );
@h
@:c_interval_export(bte)@
@:c_interval_export(sht)@
@:c_interval_export(int)@
@:c_interval_export(lng)@
@= simpleupcast_export
sql5_export str @2_2_@1( @1 *res, @2 *v );
sql5_export str bat@2_2_@1( int *res, int *v );
@= simpledowncast_export
sql5_export str @2_2_@1( @1 *res, @2 *v );
sql5_export str bat@2_2_@1( int *res, int *v );
@= numcastup_export
@:simpledowncast_export(@1,@2)@
sql5_export str @2_dec2_@1( @1 *res, int *s1, @2 *v );
sql5_export str @2_dec2dec_@1( @1 *res, int *S1, @2 *v, int *d2, int *S2 );
sql5_export str @2_num2dec_@1( @1 *res, @2 *v, int *d2, int *s2 );
sql5_export str bat@2_dec2_@1( int *res, int *s1, int *v );
sql5_export str bat@2_dec2dec_@1( int *res, int *S1, int *v, int *d2, int *S2 );
sql5_export str bat@2_num2dec_@1( int *res, int *v, int *d2, int *s2 );
@h
@:numcastup_export(bte,bte)@
@:numcastup_export(sht,bte)@
@:numcastup_export(sht,sht)@
@:numcastup_export(int,bte)@
@:numcastup_export(int,sht)@
@:numcastup_export(int,int)@
@:numcastup_export(lng,bte)@
@:numcastup_export(lng,sht)@
@:numcastup_export(lng,int)@
@:numcastup_export(lng,lng)@
@= fnumcastdown_export
@:simpledowncast_export(@1,@2)@
sql5_export str @2_num2dec_@1( @1 *res, @2 *v, int *d2, int *s2 );
sql5_export str bat@2_num2dec_@1( int *res, int *v, int *d2, int *s2 );
@h
@:fnumcastdown_export(bte,flt)@
@:fnumcastdown_export(sht,flt)@
@:fnumcastdown_export(int,flt)@
@:fnumcastdown_export(lng,flt)@
@:fnumcastdown_export(bte,dbl)@
@:fnumcastdown_export(sht,dbl)@
@:fnumcastdown_export(int,dbl)@
@:fnumcastdown_export(lng,dbl)@
@= fnumcastup_export
@:simpleupcast_export(@1,@2)@
sql5_export str @2_dec2_@1( @1 *res, int *s1, @2 *v );
sql5_export str @2_dec2dec_@1( @1 *res, int *S1, @2 *v, int *d2, int *S2 );
sql5_export str @2_num2dec_@1( @1 *res, @2 *v, int *d2, int *s2 );
sql5_export str bat@2_dec2_@1( int *res, int *s1, int *v );
sql5_export str bat@2_dec2dec_@1( int *res, int *S1, int *v, int *d2, int *S2 );
sql5_export str bat@2_num2dec_@1( int *res, int *v, int *d2, int *s2 );
@h
@:fnumcastup_export(flt,bte)@
@:fnumcastup_export(flt,sht)@
@:fnumcastup_export(flt,int)@
@:fnumcastup_export(flt,lng)@
@:fnumcastup_export(dbl,bte)@
@:fnumcastup_export(dbl,sht)@
@:fnumcastup_export(dbl,int)@
@:fnumcastup_export(dbl,lng)@
@= numcastdown_export
@:simpledowncast_export(@1,@2)@
sql5_export str @2_dec2_@1( @1 *res, int *s1, @2 *v );
sql5_export str @2_dec2dec_@1( @1 *res, int *S1, @2 *v, int *d2, int *S2 );
sql5_export str @2_num2dec_@1( @1 *res, @2 *v, int *d2, int *s2 );
sql5_export str bat@2_dec2_@1( int *res, int *s1, int *v );
sql5_export str bat@2_dec2dec_@1( int *res, int *S1, int *v, int *d2, int *S2 );
sql5_export str bat@2_num2dec_@1( int *res, int *v, int *d2, int *s2 );
@h
@:numcastdown_export(bte,sht)@
@:numcastdown_export(bte,int)@
@:numcastdown_export(bte,lng)@
@:numcastdown_export(sht,int)@
@:numcastdown_export(sht,lng)@
@:numcastdown_export(int,lng)@

sql5_export str getContext(mvc **c, backend **b );

#endif /* _SQL_H */

@-
First introduce the routines to be called by the front-end.
@c
#include "sql_config.h"
#include "sql.h"
#include "sql_result.h"
#include "sql_gencode.h"
#include <sql_storage.h>
#include <store_sequence.h>
#include <sql_datetime.h>
#include <rel_optimizer.h>
#include <rel_bin.h>

backend *
backend_reset(backend *b)
{
	b->out = b->client->fdout;
	b->language = 0;

	b->currSchema = NULL;
	b->currTable = NULL;
	b->currColumn = NULL;
	b->currKey = NULL;
	b->currIndex = NULL;
	b->vtop = 0;
	b->Tparse = b->Toptimize = b->Tschedule = b->Texec = 0;
	b->qry = NULL;
	b->q = NULL;
	return b;
}

backend *
backend_create(mvc *m, Client c)
{
	backend *b = NEW(backend);

	b->console = isAdministrator(c);
	b->mvc = m;
	b->client = c;
	return backend_reset(b);
}

void
backend_destroy(backend *b)
{
	_DELETE(b);
}

@-
Stuff copied from the Monet 4 back end
Lookup the statement associated with a specific identifier
from the statement cache. Compile and optimize it for later
consumption, e.g. display
@c
stmt *
sql_symbol2stmt(mvc *c, symbol *sym)
{
	stmt *s = NULL;

	if (mvc_debug_on(c,16384)) {
		int status = c->session->status;
		sql_rel *r = rel_semantic(c, sym);
		if (!r) {
			if (c->errstr[0]) {
				return NULL;
			} else {
				c->session->status = status;
				printf("# falling back to direct mode \n");
				s = output_semantic(c, NULL, sym);
			}
		} else {
			r = rel_optimizer(c, r);
			s = rel_bin(c, r);
			if (s){
				stmt *opt;

				/* only needed for delta tables */
				opt = rel2bin(c, s); 	
				stmt_destroy(s);
				s = bin_optimizer(c, opt);
				stmt_destroy(opt);
				return s;
			}
		}
	}  else {
		s = output_semantic(c, NULL, sym);
	}

	if (s){
		stmt *opt;

		if (mvc_debug_on(c,128)) 
			stmt2dot(s, 1, "/tmp/g1.dot");
		opt = optimize(c, s);
		stmt_destroy(s);
		s = opt;
		if (mvc_debug_on(c,128)) 
			stmt2dot(s, 2, "/tmp/g2.dot");
		opt = rel2bin(c, s);
		stmt_destroy(s);
		s = opt;
		if (mvc_debug_on(c,128)) 
			stmt2dot(s, 3, "/tmp/g3.dot");
		opt = bin_optimizer(c, s);
		stmt_destroy(s);
		s = opt;
		if (mvc_debug_on(c,128)) 
			stmt2dot(s, 4, "/tmp/g4.dot");
	}
	return s;
}

@-
After the SQL statement has been executed, its data structures
should be garbage collected. For successful actions we have to finish
the transaction as well, e.g. commit or rollback.
@c
int
sqlcleanup(mvc *c, int err)
{
	sql_destroy_params(c);
	sql_destroy_args(c);

	/* some statements dynamically disable caching */
	c->sym = NULL;
	if (c->sa) 
		c->sa = sa_reset(c->sa);
	if (err)
		c->session->status = err;
	scanner_query_processed(&(c->scanner));
	return err;
}

@-
The internal administration of the SQL compilation and execution state
is administered by a state descriptor accessible in each phase.
Failure to find the state descriptor aborts the session.

@c
str 
getContext(mvc **c, backend **b )
{
	Client _client = MCgetClient();

	if (_client == NULL ) 
		throw(SQL, "mvc","Can not access client record");
	if (_client->state[MAL_SCENARIO_PARSER] == NULL || _client->state[MAL_SCENARIO_OPTIMIZE] == NULL)
		throw(SQL, "mvc","MAL_SCENARIO_PARSER not initialized");
	*c = ((mvc *) _client ->state[MAL_SCENARIO_OPTIMIZE]); 
	if (b)
		*b = ((backend*) _client->state[MAL_SCENARIO_PARSER]);
	return MAL_SUCCEED;
}

str
SQLcommit_wrap(int *ret){
	mvc *m = NULL;
	str msg = getContext(&m, NULL);

	if (msg)
		return msg;
	(void) ret;
	mvc_commit(m, 0, NULL); /* keep the changes */
	return MAL_SUCCEED;
}
str
SQLrollback_wrap(int *ret){
	mvc *m=NULL;
	str msg = getContext(&m, NULL);

	if (msg)
		return msg;
	(void) ret;
	mvc_rollback(m, 0, NULL); /* keep the changes */
	return MAL_SUCCEED;
}

/* setVariable(int *ret, str *name, any value) */
str
setVariable(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	char buf[BUFSIZ];
	mvc *m = NULL;
	int mtype = getArgType(mb, pci, 2);
	str varname   = *(str *) getArgReference(stk, pci, 1);
	str msg = getContext(&m, NULL);
	ValRecord *src;

	if (msg)
		return msg;

	if (mtype < 0 || mtype >= 255)
		throw(SQL, "sql.setVariable", "failed");
	src = &stk->stk[getArg(pci, 2)];
	if (stack_find_var(m, varname)) {
		stack_set_var(m, varname, src);
	} else {
		snprintf(buf, BUFSIZ, "variable '%s' unknown", varname);
		throw(SQL, "sql.setVariable", buf);
	}
	if ((msg = sql_update_var(m, varname)) != NULL) {
		snprintf(buf, BUFSIZ, "%s", msg);
		_DELETE(msg);
		throw(SQL, "sql.setVariable", buf);
	}
	return MAL_SUCCEED;
}

/* getVariable(int *ret, str *name) */
str
getVariable(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	mvc *m = NULL;
	int mtype = getArgType(mb, pci, 0);
	str varname   = *(str *) getArgReference(stk, pci, 1);
	str msg = getContext(&m, NULL);
	ValRecord *dst, *src;

	if (msg)
		return msg;

	if (mtype < 0 || mtype >= 255)
		throw(SQL, "sql.getVariable", "failed");
	src = stack_get_var(m, varname);
	if (!src) {
		char buf[BUFSIZ];
		snprintf(buf, BUFSIZ, "variable '%s' unknown", varname);
		throw(SQL, "sql.getVariable", buf);
	}
	dst = &stk->stk[getArg(pci, 0)];
	VALcopy(dst,src);
	return MAL_SUCCEED;
}

str
sql_variables(int *res)
{
	int i;
	mvc *m = NULL;
	BAT *vars, *r; 
	str msg = getContext(&m, NULL);

	if (msg)
		return msg;

	vars = BATnew(TYPE_void,TYPE_str, m->topvars);
	BATseqbase(vars, 0);
	for (i=0; i<m->topvars && m->vars[i].s; i++) 
		BUNappend(vars, m->vars[i].name, FALSE);
	r = BATnew(TYPE_str,TYPE_bat,1);
	BUNins(r, "name", &vars->batCacheid, FALSE);
	BBPunfix(vars->batCacheid);
	*res = r->batCacheid;
	BBPkeepref(r->batCacheid);
	return MAL_SUCCEED;
}

str
mvc_logfile(int *d, str *filename)
{
	mvc *m = NULL;
	str msg = getContext(&m, NULL);

	(void)d;
	if (msg)
		return msg;
	if (m->scanner.log) {
		close_stream(m->scanner.log);
		m->scanner.log = NULL;
	}

	if (*filename != str_nil) 
		m->scanner.log = open_wastream(*filename);
	return MAL_SUCCEED;
}

str
mvc_next_value(lng *res, str *sname, str *seqname)
{
	mvc *m = NULL;
	str msg = getContext(&m, NULL);
	sql_schema *s;

	if (msg)
		return msg;
 	s = mvc_bind_schema(m, *sname);
	if (s) {
		sql_sequence *seq = find_sql_sequence(s, *seqname);

		if (seq && seq_next_value(seq, res)) {
			m->last_id = *res;
			return MAL_SUCCEED;
		}
	}
	throw(SQL, "sql.next_value", "error");
}

str
mvc_bat_next_value(int *res, int *sid, str *seqname)
{
	mvc *m = NULL;
	str msg = getContext(&m, NULL);
	BAT *b, *r;
	BUN p,q;
	sql_schema *s = NULL;
	sql_sequence *seq = NULL;
	seqbulk *sb = NULL;
	BATiter bi;

	if (msg)
		return msg;

	if( (b = BATdescriptor(*sid)) == NULL )
		throw(SQL, "sql.next_value", "Cannot access descriptor");

	r = BATnew(b->htype, TYPE_lng, BATcount(b));
	if (!r) {
		BBPunfix(b->batCacheid);
		throw(SQL, "sql.next_value", "Cannot create bat");
	}
	BATseqbase(r, b->hseqbase);

	if (!BATcount(b)) {
		BBPunfix(b->batCacheid);
		BBPkeepref( *res = r->batCacheid);
		return MAL_SUCCEED;
	}

	bi = bat_iterator(b);
	BATloop(b,p,q){
		str sname = BUNtail(bi,BUNfirst(b));
		lng l;

		if (!s || strcmp(s->base.name, sname) != 0) {
			if (sb)
				seqbulk_destroy(sb);
			s = mvc_bind_schema(m, sname);
			seq = NULL;
			if (!s || 
			    (seq = find_sql_sequence(s, *seqname)) == NULL ||
			    !(sb = seqbulk_create(seq, BATcount(b))) ) {
				BBPunfix(b->batCacheid);
				BBPunfix(r->batCacheid);
				throw(SQL, "sql.next_value", "error");
			}
		}
		if (!seqbulk_next_value(sb, &l)) {
			BBPunfix(b->batCacheid);
			BBPunfix(r->batCacheid);
			seqbulk_destroy(sb);
			throw(SQL, "sql.next_value", "error");
		}
		BUNins(r, BUNhead(bi,p), &l, FALSE);
	}
	if (sb) 
		seqbulk_destroy(sb);
	BBPunfix(b->batCacheid);
	BBPkeepref( *res = r->batCacheid);
	return MAL_SUCCEED;
}

str
mvc_get_value(lng *res, str *sname, str *seqname)
{
	mvc *m = NULL;
	str msg = getContext(&m, NULL);
	sql_schema *s;

	if (msg)
		return msg;
 	s = mvc_bind_schema(m, *sname);
	if (s) {
		sql_sequence *seq = find_sql_sequence(s, *seqname);

		if (seq && seq_get_value(seq, res))
			return MAL_SUCCEED;
	}
	throw(SQL, "sql.get_value", "error");
}

str
mvc_restart_seq(lng *res, str *sname, str *seqname, lng *start)
{
	mvc *m = NULL;
	str msg = getContext(&m, NULL);
	sql_schema *s;

	if (msg)
		return msg;
 	s = mvc_bind_schema(m, *sname);
	if (s) {
		sql_sequence *seq = find_sql_sequence(s, *seqname);

		if (seq) {
			*res = sql_trans_sequence_restart(m->session->tr, seq, *start);
			return MAL_SUCCEED;
		}
	}
	throw(SQL, "sql.restart", "error");
}



BAT *
mvc_bind(mvc *m, char *sname, char *tname, char *cname, int access)
{
	sql_trans *tr = m->session->tr;
	BAT *b = NULL;
	sql_schema *s = mvc_bind_schema(m, sname);
	sql_table *t = mvc_bind_table(m, s, tname);
	sql_column *c = mvc_bind_column(m, t, cname);

	b = store_funcs.bind_col(tr, c, access);
	return b;
}

BAT *
mvc_bind_dbat(mvc *m, char *sname, char *tname, int access)
{
	sql_trans *tr = m->session->tr;
	BAT *b = NULL;
	sql_schema *s = mvc_bind_schema(m, sname);
	sql_table *t = mvc_bind_table(m, s, tname);

	b = store_funcs.bind_del(tr, t, access);
	return b;
}

BAT *
mvc_bind_idxbat(mvc *m, char *sname, char *tname, char *iname, int access)
{
	sql_trans *tr = m->session->tr;
	BAT *b = NULL;
	sql_schema *s = mvc_bind_schema(m, sname);
	sql_idx *i = mvc_bind_idx(m, s, iname);

	(void) tname;
	b = store_funcs.bind_idx(tr, i, access);
	return b;
}

str
mvc_bind_wrap(int *bid, str *sname, str *tname, str *cname, int *access)
{
	BAT *b = NULL;
	mvc *m = NULL;
	str msg = getContext(&m, NULL);

	if (msg)
		return msg;
	b = mvc_bind(m, *sname, *tname, *cname, *access);
	if (b) {
		BBPkeepref( *bid = b->batCacheid);
		return MAL_SUCCEED;
	}
	throw(SQL, "mvc_bind", "limitation in transaction scope");
}


void
replicator_sql(struct _sql_functions *sqlfp)
{
        sqlfp->sqlbind = &mvc_bind_wrap;
	sqlfp->sqlbind_idx = &mvc_bind_idxbat_wrap;
}

str
mvc_bind_idxbat_wrap(int *bid, str *sname, str *tname, str *iname, int *access)
{
	BAT *b = NULL;
	mvc *m = NULL;
	str msg = getContext(&m, NULL);

	if (msg)
		return msg;
	b = mvc_bind_idxbat(m, *sname, *tname, *iname, *access);
	if (b) {
		BBPkeepref( *bid = b->batCacheid);
		return MAL_SUCCEED;
	}
	throw(SQL, "mvc_bind_idxbat", "limitation in transaction scope");
}


/*mvc_append_wrap(int *bid, str *sname, str *tname, str *cname, ptr d) */
str
mvc_append_wrap(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	mvc *m = NULL;
	str msg = getContext(&m, NULL);
	str sname = *(str *)getArgReference(stk, pci, 1);
	str tname = *(str *)getArgReference(stk, pci, 2);
	str cname = *(str *)getArgReference(stk, pci, 3);
	ptr ins = (ptr)getArgReference(stk, pci, 4);
	int tpe = getArgType(mb, pci, 4);

	sql_schema *s;
	sql_table *t;
	sql_column *c;

	if (msg)
		return msg;

	if (tpe > TYPE_any)
		tpe = TYPE_bat;
	if (tpe == TYPE_bat && (ins = BATdescriptor(*(int*)ins)) == NULL) 
		throw(SQL, "sql.append","Cannot access descriptor");
	if (ATOMextern(tpe)) 
		ins = *(ptr*)ins;
	s = mvc_bind_schema(m, sname);
	t = mvc_bind_table(m, s, tname);
	c = mvc_bind_column(m, t, cname);
	if (c) {
		store_funcs.append_col(m->session->tr, c, ins, tpe);
	} else {
		sql_idx *i = mvc_bind_idx(m, s, cname);
		if (i)
			store_funcs.append_idx(m->session->tr, i, ins, tpe);
	}
	if (tpe == TYPE_bat)
		BBPunfix(((BAT*)ins)->batCacheid);
	return MAL_SUCCEED;
}

/*mvc_update_wrap(int *bid, str *sname, str *tname, str *cname, ptr d) */
str
mvc_update_wrap(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	mvc *m = NULL;
	str msg = getContext(&m, NULL);
	str sname = *(str *)getArgReference(stk, pci, 1);
	str tname = *(str *)getArgReference(stk, pci, 2);
	str cname = *(str *)getArgReference(stk, pci, 3);
	ptr ins = (ptr)getArgReference(stk, pci, 4);
	int tpe = getArgType(mb, pci, 4);

	sql_schema *s;
	sql_table *t;
	sql_column *c;

	if (msg)
		return msg;

	if (tpe > TYPE_any)
		tpe = TYPE_bat;
	if( tpe == TYPE_bat && (ins = BATdescriptor(*(int*)ins)) == NULL) 
		throw(SQL, "sql.update","Cannot access descriptor");
	if (ATOMextern(tpe)) 
		ins = *(ptr*)ins;
	s = mvc_bind_schema(m, sname);
	t = mvc_bind_table(m, s, tname);
	c = mvc_bind_column(m, t, cname);
	if (c) {
		store_funcs.update_col(m->session->tr, c, ins, tpe, 0);
	} else {
 		sql_idx *i = mvc_bind_idx(m, s, cname);
		if (i)
			store_funcs.update_idx(m->session->tr, i, ins, tpe);
	}
	if (tpe == TYPE_bat)
		BBPunfix(((BAT*)ins)->batCacheid);
	return MAL_SUCCEED;
}

@-
Monet 5 extension 
@-
The Mx macro below is used in many places throughout the code base to
access the BAT descriptor.

@= chkIdentifier
	/* generate exception if string is not an identifier */
	if( isIdentifier(@1))
		throw(SQL,  "@4","identifier expected");
@= Pseudo
	if (BBPindex("@1_@2_@3") <= 0)
		BATname(b, "@1_@2_@3");
	BATroles(b,"@1","@2");
	BATmode(b,TRANSIENT);
	BATfakeCommit(b);
	*ret = b->batCacheid;

@c

str
mvc_bind_single_wrap(int *ret, int *bid, str *name)
{
	BAT *b, *bn;
	int r;
	BUN p;
	BATiter bni;

	if( (bn= BATdescriptor(*bid)) == NULL)
		throw(SQL, "sql.bind","Cannot access descriptor");

	p = BUNfnd(bn, *name);
	bni = bat_iterator(bn);
	r = *(int *) BUNtail(bni, p);
	if( (b= BATdescriptor(r)) == NULL)
		throw(SQL, "sql.bind","Cannot access descriptor");
	BBPkeepref(*ret= b->batCacheid);
	BBPunfix( bn->batCacheid);
	return MAL_SUCCEED;
}

str
mvc_bind_dbat_wrap(int *ret, str *sname, str *tname, int *access)
{
	BAT *b;
	mvc *m = NULL;
	str msg = getContext(&m, NULL);

	if (msg)
		return msg;
	b = mvc_bind_dbat(m, *sname, *tname, *access);
	if (b) {
		BBPkeepref( *ret = b->batCacheid);
		return MAL_SUCCEED;
	}
	throw(SQL, "mvc_bind_dbat_wrap", "error");
}

str
mvc_clear_table_wrap(lng *res, str *sname, str *tname)
{
	sql_schema *s;
	sql_table *t;
	mvc *m = NULL;
	str msg = getContext(&m, NULL);

	if (msg)
		return msg;
	s = mvc_bind_schema(m, *sname);
	t = mvc_bind_table(m, s, *tname);
	*res = mvc_clear_table(m, t);
	return MAL_SUCCEED;
}

/*mvc_delete_wrap(int *d, str *sname, str *tname, ptr d) */
str
mvc_delete_wrap(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	mvc *m = NULL;
	str msg = getContext(&m, NULL);
	str sname = *(str *)getArgReference(stk, pci, 1);
	str tname = *(str *)getArgReference(stk, pci, 2);
	ptr ins = (ptr)getArgReference(stk, pci, 3);
	int tpe = getArgType(mb, pci, 3);
	BAT *b = NULL;

	sql_schema *s;
	sql_table *t;

	if (msg)
		return msg;

	if (tpe > TYPE_any)
		tpe = TYPE_bat;
	if (tpe == TYPE_bat && (b = BATdescriptor(*(int*)ins)) == NULL) 
		throw(SQL, "sql.delete","Cannot access descriptor");
	if (tpe != TYPE_bat || (b->ttype != TYPE_oid && b->ttype != TYPE_void))
		throw(SQL, "sql.delete","Cannot access descriptor");
	s = mvc_bind_schema(m, sname);
	t = mvc_bind_table(m, s, tname);
	store_funcs.delete_tab(m->session->tr, t, b, tpe);
	if (tpe == TYPE_bat)
		BBPunfix(((BAT*)ins)->batCacheid);
	return MAL_SUCCEED;
}

static int
mvc_result_row(mvc *m, int nr_cols, int qtype)
{
	m->results = res_table_create(m->session->tr, m->result_id++, nr_cols, qtype, m->results, NULL);
	return m->results->id;
}

str
mvc_result_row_wrap(int *res_id, int *nr_cols, int *qtype, int *o)
{
	mvc *m = NULL;
	str msg = getContext(&m, NULL);

	if (msg)
		return msg;
	(void)o; /* dummy order */
	*res_id = mvc_result_row(m, *nr_cols, *qtype); 
	if (*res_id < 0)
		throw(SQL, "sql.resultSet", "failed");
	return MAL_SUCCEED;
}

str 
mvc_result_file_wrap(int *res_id, int *nr_cols, unsigned char* *T, unsigned char* *R, unsigned char* *S, unsigned char* *N, bat *order_bid)
{
	str res = MAL_SUCCEED;
	BAT *order;
	mvc *m = NULL;
	str msg = getContext(&m, NULL);
	res_table *t = NULL;
	unsigned char *tsep = NULL, *rsep = NULL, *ssep = NULL, *ns = NULL;
	ssize_t len;

	if (msg)
		return msg;
        if ((order = BATdescriptor(*order_bid)) == NULL ) {
                throw(SQL, "sql.resultSet", "Cannot access descriptor");
        }
	t = res_table_create(m->session->tr, m->result_id++, *nr_cols, Q_TABLE, m->results, order);
	m->results = t;
	len = strlen((char*)(*T));
	GDKstrFromStr(tsep=GDKmalloc(len+1), *T, len); len = 0;
	len = strlen((char*)(*R));
	GDKstrFromStr(rsep=GDKmalloc(len+1), *R, len); len = 0;
	len = strlen((char*)(*S));
	GDKstrFromStr(ssep=GDKmalloc(len+1), *S, len); len = 0;
	len = strlen((char*)(*N));
	GDKstrFromStr(ns=GDKmalloc(len+1), *N, len); len = 0;
	t->tsep = (char*)tsep;
	t->rsep = (char*)rsep;
	t->ssep = (char*)ssep;
	t->ns = (char*)ns;
	*res_id = t->id;
	if (*res_id < 0)
		res = createException(SQL, "sql.resultSet", "failed");
	BBPunfix(order->batCacheid);
	return res;
}

str
mvc_result_table_wrap(int *res_id, int *nr_cols, int *qtype, bat *order_bid)
{
	str res = MAL_SUCCEED;
	BAT *order;
	mvc *m = NULL;
	str msg = getContext(&m, NULL);

	if (msg)
		return msg;
        if ((order = BATdescriptor(*order_bid)) == NULL ) {
                throw(SQL, "sql.resultSet", "Cannot access descriptor");
        }
	*res_id = mvc_result_table(m, *nr_cols, *qtype, order);
	if (*res_id < 0)
		res= createException(SQL, "sql.resultSet", "failed");
	BBPunfix(order->batCacheid);
	return res;
}

str
mvc_result_column_wrap(int *ret, int *rs, str *tn, str *name, str *type, int *digits, int *scale, bat *bid)
{
	str res = MAL_SUCCEED;
	BAT *b;
	mvc *m = NULL;
	str msg = getContext(&m, NULL);

	(void)ret;
	(void)rs;
	if (msg)
		return msg;
        if( (b = BATdescriptor(*bid)) == NULL ){
                throw(SQL, "sql.rsColumn", "Cannot access descriptor");
        }
	if (mvc_result_column(m, *tn, *name, *type, *digits, *scale, b)) 
		res = createException(SQL, "sql.rsColumn", "failed");
	BBPunfix(b->batCacheid);
	return res;
}
@= result_value
str
mvc_result_value_@1(int *ret, int *rs, str *tn, str *name, str *type, int *digits, int *scale, @1 *val)
{
	mvc *m = NULL;
	str msg = getContext(&m, NULL);

	(void)ret;
	(void)rs;
	if (msg)
		return msg;
	if (mvc_result_value(m, *tn, *name, *type, *digits, *scale, (ptr) val, TYPE_@1))
		throw(SQL, "sql.rsColumn", "failed");
	return MAL_SUCCEED;
}
@-
@c
@:result_value(flt)@
@:result_value(dbl)@
@:result_value(lng)@
@:result_value(int)@
@:result_value(sht)@
@:result_value(bte)@
str
/*mvc_result_value_wrap(int *ret, int *rs, str *tn, str *name, str *type, int *digits, int *scale, ptr p, int mtype)*/
mvc_result_value_wrap(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	int *ret  = (int *) getArgReference(stk, pci, 0);
	int *rs   = (int *) getArgReference(stk, pci, 1);
	str *tn   = (str *) getArgReference(stk, pci, 2);
	str *cn   = (str *) getArgReference(stk, pci, 3);
	str *type = (str *) getArgReference(stk, pci, 4);
	int *digits = (int *) getArgReference(stk, pci, 5);
	int *scale = (int *) getArgReference(stk, pci, 6);
	ptr p =  (ptr) getArgReference(stk, pci, 7);
	int mtype = getArgType(mb, pci, 7);
	mvc *m = NULL;
	str msg = getContext(&m, NULL);

	(void)ret;
	(void)rs;
	if (msg)
		return msg;
	if (ATOMextern(mtype)) 
		p = *(ptr*)p;
	if (mvc_result_value(m, *tn, *cn, *type, *digits, *scale, p, mtype))
		throw(SQL, "sql.rsColumn", "failed");
	return MAL_SUCCEED;
}

str
mvc_affected_rows_wrap(int *r, lng *nr, str *w)
{
	backend *b = NULL;
	mvc *c = NULL;
	str msg = getContext(&c, &b);

	if (msg)
		return msg;
	c->type = Q_UPDATE;
	if (mvc_export_affrows(c, b->out, *nr, *w)) {
		throw(SQL, "sql.affectedRows", "failed");
	}
	(void)r;
	return NULL;
}

str
mvc_affected_rows_int(int *r, int *nr, str *w)
{
	lng N = *nr;
	return mvc_affected_rows_wrap(r, &N, w);
}

str
mvc_export_result_wrap(int *ret, stream **s, int *res_id, str *w)
{
	backend *b = NULL;
	mvc *c = NULL;
	str msg = getContext(&c, &b);

	if (msg)
		return msg;
	if (mvc_export_result(c, *s, *res_id, *w)) {
		throw(SQL, "sql.exportResult", "failed");
	}
	(void)ret;
	return NULL;
}

str
mvc_export_operation_wrap(int *ret, str *w)
{
	backend *b = NULL;
	mvc *c = NULL;
	str msg = getContext(&c, &b);

	if (msg)
		return msg;
	if (mvc_export_operation(c, b->out, *w)) {
		throw(SQL, "sql.exportOperation", "failed");
	}
	(void)ret;
	return NULL;
}


str
/*mvc_export_value_wrap(int *ret, int *qtype, str tn, str name, str type, int *digits, int *scale, int *eclass, ptr p, int mtype)*/
mvc_export_value_wrap(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	int *qtype= (int *) getArgReference(stk, pci, 1);
	str *tn   = (str *) getArgReference(stk, pci, 2);
	str *cn   = (str *) getArgReference(stk, pci, 3);
	str *type = (str *) getArgReference(stk, pci, 4);
	int *digits = (int *) getArgReference(stk, pci, 5);
	int *scale = (int *) getArgReference(stk, pci, 6);
	int *eclass = (int *) getArgReference(stk, pci, 7);
	ptr p =  (ptr) getArgReference(stk, pci, 8);
	int mtype = getArgType(mb, pci, 8);
	str *w = (str *) getArgReference(stk, pci, 9);
	backend *b = NULL;
	mvc *c = NULL;
	str msg = getContext(&c, &b);

	if (msg)
		return msg;
	if (ATOMextern(mtype)) 
		p = *(ptr*)p;
	if (mvc_export_value(c, b->out, *qtype, *tn, *cn, *type, *digits, *scale, *eclass, p, mtype, *w, "NULL") != SQL_OK)
		throw(SQL, "sql.exportValue", "failed");
	return MAL_SUCCEED;
}

str
mvc_import_table_wrap(int *res, bstream **s, str *tname, unsigned char* *T, unsigned char* *R, unsigned char* *S, unsigned char * *N, int *sz, int *offset)
{
	BAT *b;
	mvc *m = NULL;
	str msg = getContext(&m, NULL);
	unsigned char *tsep = NULL, *rsep = NULL, *ssep = NULL, *ns = NULL;
	ssize_t len = 0;

	if (msg)
		return msg;
	len = strlen((char*)(*T));
	GDKstrFromStr(tsep=GDKmalloc(len+1), *T, len); len = 0;
	len = strlen((char*)(*R));
	GDKstrFromStr(rsep=GDKmalloc(len+1), *R, len); len = 0;
	len = strlen((char*)(*S));
	GDKstrFromStr(ssep=GDKmalloc(len+1), *S, len); len = 0;
	len = strlen((char*)(*N));
	GDKstrFromStr(ns=GDKmalloc(len+1), *N, len); len = 0;
	b = mvc_import_table(m, *s, *tname, (char*)tsep, (char*)rsep, (char*)ssep, (char*)ns, *sz, *offset);
	GDKfree(tsep);
	GDKfree(rsep);
	GDKfree(ssep);
	GDKfree(ns);
	if (!b)
		throw(SQL, "importTable", "failed to import table");
	*res = b->batCacheid;
	BBPincref( *res, TRUE);
	BBPunfix(*res);
	return MAL_SUCCEED;
}

str
zero_or_one(ptr ret, int *bid) 
{
	BAT *b;
	int c, _s;
	ptr p;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(SQL, "zero_or_one", "Cannot access descriptor");
	}
	c = BATcount(b);
	if (c == 0) {
		p = ATOMnilptr(b->ttype);
	} else if (c == 1) {
		BATiter bi = bat_iterator(b);
		p = BUNtail(bi,BUNfirst(b));
	} else {
		char buf[BUFSIZ];

		p = NULL;
                snprintf(buf, BUFSIZ, "cardinality violation (%d>1)", c);
		throw(SQL, "zero_or_one", buf);
	}
	_s = ATOMsize(ATOMtype(b->ttype));
	if (ATOMextern(b->ttype)) {
		_s = ATOMlen(ATOMtype(b->ttype), p);
		memcpy(*(ptr*) ret=GDKmalloc(_s), p, _s);
	} else if (b->ttype == TYPE_bat) {
		bat bid = *(bat*)p;
		*(BAT**) ret = BATdescriptor(bid);
	} else if (_s == 4) {
		*(int*) ret = *(int*)p;
	} else if (_s == 1) {
		*(bte*) ret = *(bte*)p;
	} else if (_s == 2) {
		*(sht*) ret = *(sht*)p;
	} else if (_s == 8) {
		*(lng*) ret = *(lng*)p;
	} else {
		memcpy(ret, p, _s);
	}
	BBPreleaseref(b->batCacheid);
	
	return MAL_SUCCEED;
}

str not_unique(bit *ret, int* bid) 
{
	BAT *b;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(SQL, "not_unique", "Cannot access descriptor");
	}

	*ret = FALSE;
	if (BATtkey(b) || BATtdense(b) || BATcount(b) <= 1) {
		BBPunfix(b->batCacheid);
		return MAL_SUCCEED;
	} else if (b->tsorted&1) {
		BUN p,q;
		oid c = *(oid*)Tloc(b, BUNfirst(b)); 

		for(p=BUNfirst(b)+1, q=BUNlast(b);p<q;p++) {
			oid v = *(oid*)Tloc(b,p);
			if (v<=c) {
				*ret = TRUE;
				break;
			}
			c = v;
		}
	} else {
		BBPunfix(b->batCacheid);
		throw(SQL, "not_unique", "input should be sorted");
	}
	BBPunfix(b->batCacheid);
	return MAL_SUCCEED;
}

static str
voidbathash(int *res, BAT *b )
{
	BAT *dst;
	hash_t (*hash)(ptr v); 
	int *r, *f;
	BATiter bi, dsti;

	dst = BATnew(TYPE_void,TYPE_int, BATcount(b));
	if (!dst) {
		BBPunfix(b->batCacheid);
		throw(SQL, "bathash", "can not create bat");
	}
	BATseqbase(dst, b->hseqbase);

	dsti = bat_iterator(dst);
	bi = bat_iterator(b);
 	r = (int*)BUNtail(dsti, BUNfirst(dst));
	f = r;
	hash = BATatoms[b->ttype].atomHash;
	if (ATOMvarsized(b->ttype)) { /* ugh */
		BUN p,q;

		BATloop(b,p,q){
			ptr v = BUNtail(bi,p);
			*r++ = (hash(v)) & 0xEFFFFFFF;
		}
	} else {
		char *v = BUNtail(bi,BUNfirst(b)), *e = BUNtail(bi,BUNlast(b));
		int sz = Tsize(b);

		for(; v < e; v+=sz) {
			*r++ = (hash(v)) & 0xEFFFFFFF;
		}
	}
	BATsetcount(dst, r-f);
	BATkey(BATmirror(dst), 0);
	dst->tsorted = 0;

	BBPkeepref( *res = dst->batCacheid);
	BBPunfix(b->batCacheid);
	return MAL_SUCCEED;
}

str
bathash_wrap(int *res, int *bid )
{
	BAT *b, *dst;
	hash_t (*hash)(ptr v); 
	BATiter bi;

	if( (b = BATdescriptor(*bid)) == NULL ){
		throw(SQL, "bathash", "Cannot access descriptor");
	}

	if (b->htype == TYPE_void) 
		return voidbathash(res, b);

	dst= BATnew(TYPE_oid,TYPE_int, BATcount(b));
	if (!dst) {
		BBPunfix(b->batCacheid);
		throw(SQL, "bathash", "can not create bat");
	}

	hash = BATatoms[b->ttype].atomHash;
	bi = bat_iterator(b);
	if (ATOMvarsized(b->ttype)) { /* ugh */
		BUN p,q;

		BATloop(b,p,q){
			ptr v = BUNtail(bi,p);
			int h = (hash(v)) & 0xEFFFFFFF;
			BUNins(dst, BUNhead(bi,p), &h, FALSE);
		}
	} else {
		BUN p,q;

		BATloop(b,p,q){
			ptr v = BUNtail(bi,p);
			int h = (hash(v)) & 0xEFFFFFFF;
			BUNins(dst, BUNhead(bi,p), &h, FALSE);
		}
	}

	BBPkeepref( *res = dst->batCacheid);
	BBPunfix(b->batCacheid);
	return MAL_SUCCEED;
}


str
hash_wrap(MalBlkPtr m, MalStkPtr s, InstrPtr p)
{
	ptr v;
	int *res, tpe = getArgType(m,p,1);

	res= (int *) getArgReference(s,p,0);
	v = getArgReference(s,p,1);

	if (tpe == TYPE_bat)
		return bathash_wrap(res, (int*)v); 

	if (ATOMextern(tpe)) /* ugh */
		*res = (ATOMhash(tpe, *(char**)v)) & 0xEFFFFFFF;
	else
		*res = (ATOMhash(tpe, v)) & 0xEFFFFFFF;
	return NULL;
}

lng scales[20] = {
	LL_CONSTANT(0),
	LL_CONSTANT(10),
	LL_CONSTANT(100),
	LL_CONSTANT(1000),
	LL_CONSTANT(10000),
	LL_CONSTANT(100000),
	LL_CONSTANT(1000000),
	LL_CONSTANT(10000000),
	LL_CONSTANT(100000000),
	LL_CONSTANT(1000000000),
	LL_CONSTANT(10000000000),
	LL_CONSTANT(100000000000),
	LL_CONSTANT(1000000000000),
	LL_CONSTANT(10000000000000),
	LL_CONSTANT(100000000000000),
	LL_CONSTANT(1000000000000000),
	LL_CONSTANT(10000000000000000),
	LL_CONSTANT(100000000000000000),
	LL_CONSTANT(1000000000000000000)
};

@-
The core modules of Monet provide just a limited set of
mathematical operators. The extensions required to support
SQL-99 are shown below. At some point they also should be
moved to module code base.
@= round
str 
@1_dec_round_wrap( @1 *res, @1 *v, @1 *r )
{
	@1 val = *v;
	@1 add = *r;

	/* shortcut nil */
	if (*v == @1_nil) {
		*res = @1_nil;
		return NULL;
	}

	add >>=1;
	if (val < 0) 
		add = -add;
	val += add; 
	val /= *r;
	*res = val;
	return NULL;
}

str 
@1_round_wrap( @1 *res, @1 *v, int *d, int *s, bte *r )
{
	/* shortcut nil */
	if (*v == @1_nil) {
		*res = @1_nil;
	} else if (-*r > *d) {
		*res = 0;
	} else if (*r > 0 && *r < *s) {
		int dff = *s - *r;
		lng rnd = scales[dff]>>1;
		if (*v > 0)
			*res = (((*v + rnd)/scales[dff])*scales[dff]);
		else
			*res = (((*v - rnd)/scales[dff])*scales[dff]);
	} else if (*r <= 0) {
		int dff = -*r + *s;
		lng rnd = scales[dff]>>1;
		if (*v > 0)
			*res = (((*v + rnd)/scales[dff])*scales[dff]);
		else
			*res = (((*v - rnd)/scales[dff])*scales[dff]);
	}
	return MAL_SUCCEED;
}

str 
@1_dbl_dec_round_wrap( @1 *res, @1 *v, dbl *r )
{
	@1 add = *r;	/* lossy conversion */
	return @1_dec_round_wrap(res,v, &add);
}

str 
@1_int_dec_round_wrap( @1 *res, @1 *v, int *r )
{
	@1 add = *r;	/* lossy conversion */
	return @1_dec_round_wrap(res,v, &add);
}

str
str_2dec_@1( @1 *res, str *val, int *d, int *sc )
{
	char *s = strip_extra_zeros(*val);
	char *dot = strchr(s, '.');
	int digits = _strlen(s) - 1;
	int scale = digits - (dot-s);
	lng value = 0;

	if (!dot) {
		if (GDK_STRNIL(*val)) {
			*res = @1_nil;
			return MAL_SUCCEED;
		} else {
			throw(SQL, "@1", 
				"\"%s\" is no decimal value (doesn't contain a '.')", *val);
		}
	}
		
	value = decimal_from_str(s);
	if (*s == '+' || *s == '-')
		digits --;
	if (scale < *sc){
		/* the current scale is too small, increase it by adding 0's */
		int d = *sc - scale;	/* CANNOT be 0! */

		value *= scales[d];
		scale += d;
		digits += d;
	} else if (scale > *sc){
		/* the current scale is too big, decrease it by correctly rounding */
		int d = scale - *sc;	/* CANNOT be 0 */
		lng rnd = scales[d]>>1;

		value += rnd;
		value /= scales[d];
		scale -= d;
		digits -= d;
	}
	if (digits > *d) {
		throw(SQL,"@1", 
		     "decimal (%s) doesn't have format (%d.%d)", *val, *d, *sc);
	}
	*res = (@1) value;
	return MAL_SUCCEED;
}

str
str_2num_@1( @1 *res, str *v, int *len )
{
	int zero = 0;
	return str_2dec_@1( res, v, len, &zero );
}

str
batstr_2dec_@1( int *res, int *bid, int *d, int *sc )
{
	BAT *b, *dst;
	BATiter bi;
	BUN p,q;
	char *msg = NULL;

	if( (b = BATdescriptor(*bid)) == NULL ){
		throw(SQL, "batcalc.str_2dec_@1", "Cannot access descriptor");
	}
	bi = bat_iterator(b);
	dst = BATnew(b->htype, TYPE_@1, BATcount(b));
	BATseqbase(dst, b->hseqbase);
	BATloop(b,p,q) {
		str v = (str)BUNtail(bi,p);
		@1 r;
		msg = str_2dec_@1( &r, &v, d, sc );
		if (msg)
			break;
		BUNins(dst, BUNhead(bi,p), &r, FALSE);
	}
	BBPkeepref( *res = dst->batCacheid);
	BBPunfix(b->batCacheid);
	return msg;
}

str
batstr_2num_@1( int *res, int *bid, int *len )
{
	BAT *b, *dst;
	BATiter bi;
	BUN p,q;
	char *msg = NULL;

	if( (b = BATdescriptor(*bid)) == NULL ){
		throw(SQL, "batcalc.str_2num_@1", "Cannot access descriptor");
	}
	bi = bat_iterator(b);
	dst = BATnew(b->htype, TYPE_@1, BATcount(b));
	BATseqbase(dst, b->hseqbase);
	BATloop(b,p,q) {
		str v = (str)BUNtail(bi,p);
		@1 r;
		msg = str_2num_@1( &r, &v, len );
		if (msg)
			break;
		BUNins(dst, BUNhead(bi,p), &r, FALSE);
	}
	BBPkeepref( *res = dst->batCacheid);
	BBPunfix(b->batCacheid);
	return msg;
}
@c

@:round(bte)@
@:round(sht)@
@:round(int)@
@:round(lng)@

@= fround
str 
@1_@2_dec_round_wrap( @1 *res, @1 *v, @2 *r )
{
	@1 val = *v;

	/* not nil */
	if (ATOMcmp(TYPE_@1, v, ATOMnilptr(TYPE_@1)) != 0) {
		val /= *r;
	}
	*res = val;
	return MAL_SUCCEED;
}
@c
@:fround(flt,flt)@
@:fround(flt,int)@
@:fround(dbl,dbl)@
@:fround(dbl,int)@

@= cast
str
str_2_@1( @1 *res, str *val )
{
	ptr p = NULL;
	int len = 0;
	int e; 
	
	e = ATOMfromstr(TYPE_@1, &p, &len, *val);
	if (e < 0 || !p || 
	   (ATOMcmp(TYPE_@1, p, ATOMnilptr(TYPE_@1)) == 0 &&
	    ATOMcmp(TYPE_str, *val, ATOMnilptr(TYPE_str)) != 0))
	{
		char buf[BUFSIZ];
		if (p)
			GDKfree(p);
                snprintf(buf, BUFSIZ,"conversion of string '%s' failed",*val);
		throw(SQL, "@1", buf);
	}
	*res = *(@1*)p;
	if (p)
		GDKfree(p);
	return MAL_SUCCEED;
}

str
SQL@1_2_str( str *res, @1 *val )
{
	char *p = NULL;
	int len = 0;
	@2( &p, &len, val);
	*res = p;
	return MAL_SUCCEED;
}

str
batstr_2_@1( int *res, int *bid )
{
	BAT *b, *dst;
	BATiter bi;
	BUN p,q;
	char *msg = NULL;

	if( (b = BATdescriptor(*bid)) == NULL ){
		throw(SQL, "batcalc.str_2_@1", "Cannot access descriptor");
	}
	bi = bat_iterator(b);
	dst = BATnew(b->htype, TYPE_@1, BATcount(b));
	BATseqbase(dst, b->hseqbase);
	BATloop(b,p,q) {
		str v = (str)BUNtail(bi,p);
		@1 r;
		msg = str_2_@1( &r, &v );
		if (msg)
			break;
		BUNins(dst, BUNhead(bi,p), &r, FALSE);
	}
	BBPkeepref( *res = dst->batCacheid);
	BBPunfix(b->batCacheid);
	return msg;
}
@c
@:cast(bit,bitToStr)@
@:cast(oid,OIDtoStr)@
@:cast(bte,bteToStr)@
@:cast(sht,shtToStr)@
@:cast(int,intToStr)@
@:cast(lng,lngToStr)@
@:cast(flt,fltToStr)@
@:cast(dbl,dblToStr)@
@:cast(timestamp,timestamp_tostr)@
@:cast(daytime,daytime_tostr)@
@:cast(date,date_tostr)@
@:cast(sqlblob,sqlblob_tostr)@

str
SQLstr_2_str( str *res, str *val )
{
	if( *val == str_nil) 
		*res = (str)str_nil;
	else
		*res =  GDKstrdup(*val);
	return MAL_SUCCEED;
}

str
SQLstr_cast_(str *res, mvc *m, int eclass, int d, int s, int has_tz, ptr p, int tpe, int len)
{
	char *r = NULL;
	int sz = MAX(2,len + 1);	/* nil should fit */

	if (tpe != TYPE_str) {
		r = GDKmalloc(sz);
		sz = convert2str(m, eclass, d, s, has_tz, p, tpe, &r, sz);
	} else {
		str v = (str)p; 
		sz = _strlen(v);
		if (len == 0 || sz <= len) 
			r = GDKstrdup(v);
	}
	if (len > 0 && sz > len) {
		if (r) 
			GDKfree(r);
		if (ATOMcmp(TYPE_str, ATOMnilptr(TYPE_str), p) != 0) {
			throw(SQL, "str_cast", "value too long for type (var)char(%d)", len);
		} else {
			r = GDKstrdup(str_nil);
		}
	}
	*res = r;
	return MAL_SUCCEED;
}

str
SQLstr_cast(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	str *res  = (str *) getArgReference(stk, pci, 0);
	int eclass = *(int*) getArgReference(stk, pci, 1);
	int d = *(int*) getArgReference(stk, pci, 2);
	int s = *(int*) getArgReference(stk, pci, 3);
	int has_tz = *(int*) getArgReference(stk, pci, 4);
	ptr p   = (ptr) getArgReference(stk, pci, 5);
	int tpe = getArgType(mb, pci, 5);
	int len   = *(int *) getArgReference(stk, pci, 6);
	mvc *m = NULL;
	str msg = getContext(&m, NULL);

	if (msg)
		return msg;
	if (ATOMextern(tpe)) 
		p = *(ptr*)p;
	return SQLstr_cast_(res, m, eclass, d, s, has_tz, p, tpe, len );
}

str 
SQLbatstr_cast(int *res, int *eclass, int *d1, int *s1, int *has_tz, int *bid, int *digits )
{
	BAT *b, *dst;
	BATiter bi;
	BUN p,q;
	mvc *m = NULL;
	str msg = getContext(&m, NULL);
	char *r = NULL;

	if (msg)
		return msg;
	if( (b = BATdescriptor(*bid)) == NULL ){
		throw(SQL, "batcalc.str_2dec_@1", "Cannot access descriptor");
	}
	bi = bat_iterator(b);
	dst = BATnew(b->htype, TYPE_str, BATcount(b));
	BATseqbase(dst, b->hseqbase);
	BATloop(b,p,q) {
		ptr v = (ptr)BUNtail(bi,p);
		msg = SQLstr_cast_( &r, m, *eclass, *d1, *s1, *has_tz, v, b->ttype, *digits);
		if (msg)
			break;
		BUNins(dst, BUNhead(bi,p), r, FALSE);
		GDKfree(r);
	}
	BBPkeepref( *res = dst->batCacheid);
	BBPunfix(b->batCacheid);
	return msg;
}

@= simpleupcast
str 
@2_2_@1( @1 *res, @2 *v )
{
	/* shortcut nil */
	if (*v == @2_nil) {
		*res = @1_nil;
		return(MAL_SUCCEED);
	}
	
	/* since the @1 type is bigger than or equal to the @2 type, it will
	   always fit */
	*res = (@1)*v;
	return(MAL_SUCCEED);
}

str bat@2_2_@1( int *res, int *bid )
{
	BAT *b, *dst;
	BATiter bi;
	BUN p,q;
	char *msg = NULL;

	if( (b = BATdescriptor(*bid)) == NULL ){
		throw(SQL, "batcalc.@2_2_@1", "Cannot access descriptor");
	}
	bi = bat_iterator(b);
	dst = BATnew(b->htype, TYPE_@1, BATcount(b));
	BATseqbase(dst, b->hseqbase);
	BATloop(b,p,q) {
		@2 *v = (@2*)BUNtail(bi,p);
		@1 r;
		msg = @2_2_@1( &r, v );
		if (msg)
			break;
		BUNins(dst, BUNhead(bi,p), &r, FALSE);
	}
	BBPkeepref( *res = dst->batCacheid);
	BBPunfix(b->batCacheid);
	return msg;
}
@c

@= simpledowncast
str @2_2_@1( @1 *res, @2 *v )
{
	lng val = *v;

	/* shortcut nil */
	if (*v == @2_nil) {
		*res = @1_nil;
		return(MAL_SUCCEED);
	}
	
	/* see if the number fits in the data type */
	if (val >= GDK_@1_min && val <= GDK_@1_max)	{
		*res = (@1)val;
		return(MAL_SUCCEED);
	} else {
		throw(SQL, "convert",
			"value (" LLFMT ") exceeds limits of type @1", val);
	}
}

str bat@2_2_@1( int *res, int *bid )
{
	BAT *b, *dst;
	BATiter bi;
	BUN p,q;
	char *msg = NULL;

	if( (b = BATdescriptor(*bid)) == NULL ){
		throw(SQL, "batcalc.@2_2_@1", "Cannot access descriptor");
	}
	bi = bat_iterator(b);
	dst = BATnew(b->htype, TYPE_@1, BATcount(b));
	BATseqbase(dst, b->hseqbase);
	BATloop(b,p,q) {
		@2 *v = (@2*)BUNtail(bi,p);
		@1 r;
		msg = @2_2_@1( &r, v );
		if (msg)
			break;
		BUNins(dst, BUNhead(bi,p), &r, FALSE);
	}
	BBPkeepref( *res = dst->batCacheid);
	BBPunfix(b->batCacheid);
	return msg;
}
@c

@= numcastup
@:simpleupcast(@1,@2)@

str @2_dec2_@1( @1 *res, int *s1, @2 *v )
{
	int scale = *s1;
	@1 r, h = (*v<0)?-5:5; 

	/* shortcut nil */
	if (*v == @2_nil) {
		*res = @1_nil;
		return(MAL_SUCCEED);
	}

	/* since the @1 type is bigger than or equal to the @2 type, it will
	   always fit */
	r = (@1)*v;
	if (scale) 
		r = (@1) ((r + h) / scales[scale]);
	*res = r;
	return(MAL_SUCCEED);
}

str 
@2_dec2dec_@1( @1 *res, int *S1, @2 *v, int *d2, int *S2 )
{
	int p = *d2, inlen = 1;
	@2 cpyval = *v;
	int s1 = *S1, s2 = *S2;
	@1 r, h = (*v<0)?-5:5; 

	/* shortcut nil */
	if (*v == @2_nil) {
		*res = @1_nil;
		return(MAL_SUCCEED);
	}
	
	/* count the number of digits in the input */
	while (cpyval /= 10)
		inlen++;

	/* rounding is allowed */
	inlen += (s2-s1);
	if (p && inlen > p) {
		throw(SQL, "convert",
			"too many digits (%d > %d)", inlen, p);
	}

	/* since the @1 type is bigger than or equal to the @2 type, it will
	   always fit */
	r = (@1)*v;
	if (s2 > s1) 
		r *= (@1) scales[s2 - s1];
	else if (s2 != s1) 
		r = (@1) ((r + h) / scales[s1 - s2]);
	*res = r;
	return(MAL_SUCCEED);
}

str 
@2_num2dec_@1( @1 *res, @2 *v, int *d2, int *s2 )
{
	int zero = 0;
	return @2_dec2dec_@1( res, &zero, v, d2, s2 );
}

str bat@2_dec2_@1( int *res, int *s1, int *bid )
{
	BAT *b, *dst;
	BATiter bi;
	BUN p,q;
	char *msg = NULL;

	if( (b = BATdescriptor(*bid)) == NULL ){
		throw(SQL, "batcalc.@2_dec2_@1", "Cannot access descriptor");
	}
	bi = bat_iterator(b);
	dst = BATnew(b->htype, TYPE_@1, BATcount(b));
	BATseqbase(dst, b->hseqbase);
	BATloop(b,p,q) {
		@2 *v = (@2*)BUNtail(bi,p);
		@1 r;
		msg = @2_dec2_@1( &r, s1, v );
		if (msg)
			break;
		BUNins(dst, BUNhead(bi,p), &r, FALSE);
	}
	BBPkeepref( *res = dst->batCacheid);
	BBPunfix(b->batCacheid);
	return msg;
}

str bat@2_dec2dec_@1( int *res, int *S1, int *bid, int *d2, int *S2 )
{
	BAT *b, *dst;
	BATiter bi;
	BUN p,q;
	char *msg = NULL;

	if( (b = BATdescriptor(*bid)) == NULL ){
		throw(SQL, "batcalc.@2_dec2dec_@1", "Cannot access descriptor");
	}
	bi = bat_iterator(b);
	dst = BATnew(b->htype, TYPE_@1, BATcount(b));
	BATseqbase(dst, b->hseqbase);
	BATloop(b,p,q) {
		@2 *v = (@2*)BUNtail(bi,p);
		@1 r;
		msg = @2_dec2dec_@1( &r, S1, v, d2, S2 );
		if (msg)
			break;
		BUNins(dst, BUNhead(bi,p), &r, FALSE);
	}
	BBPkeepref( *res = dst->batCacheid);
	BBPunfix(b->batCacheid);
	return msg;
}
str bat@2_num2dec_@1( int *res, int *bid, int *d2, int *s2 )
{
	BAT *b, *dst;
	BATiter bi;
	BUN p,q;
	char *msg = NULL;

	if( (b = BATdescriptor(*bid)) == NULL ){
		throw(SQL, "batcalc.@2_num2dec_@1", "Cannot access descriptor");
	}
	bi = bat_iterator(b);
	dst = BATnew(b->htype, TYPE_@1, BATcount(b));
	BATseqbase(dst, b->hseqbase);
	BATloop(b,p,q) {
		@2 *v = (@2*)BUNtail(bi,p);
		@1 r;
		msg = @2_num2dec_@1( &r, v, d2, s2 );
		if (msg)
			break;
		BUNins(dst, BUNhead(bi,p), &r, FALSE);
	}
	BBPkeepref( *res = dst->batCacheid);
	BBPunfix(b->batCacheid);
	return msg;
}

@c
@:numcastup(bte,bte)@
@:numcastup(sht,bte)@
@:numcastup(sht,sht)@
@:numcastup(int,bte)@
@:numcastup(int,sht)@
@:numcastup(int,int)@
@:numcastup(lng,bte)@
@:numcastup(lng,sht)@
@:numcastup(lng,int)@
@:numcastup(lng,lng)@

@= fnumcastdown
@:simpledowncast(@1,@2)@

/* when casting a floating point to an decimal we like to preserve the 
 * precision.  This means we first scale the float before converting.
*/
str 
@2_num2dec_@1( @1 *res, @2 *v, int *d2, int *s2 )
{
	int p = *d2, inlen = 1, scale = *s2;
	@2 r;
	lng cpyval;

	/* shortcut nil */
	if (*v == @2_nil) {
		*res = @1_nil;
		return(MAL_SUCCEED);
	}
	
	/* since the @1 type is bigger than or equal to the @2 type, it will
	   always fit */
	r = (@2) *v;
	if (scale) 
		r *= scales[scale];
	cpyval = (lng) r;

	/* count the number of digits in the input */
	while (cpyval /= 10)
		inlen++;
	/* rounding is allowed */
	if (p && inlen > p) {
		throw(SQL, "convert",
			"too many digits (%d > %d)", inlen, p);
	}
	*res = (@1) r;
	return MAL_SUCCEED;
}
str 
bat@2_num2dec_@1( int *res, int *bid, int *d2, int *s2 )
{
	BAT *b, *dst;
	BATiter bi;
	BUN p,q;
	char *msg = NULL;

	if( (b = BATdescriptor(*bid)) == NULL ){
		throw(SQL, "batcalc.@2_num2dec_@1", "Cannot access descriptor");
	}
	bi = bat_iterator(b);
	dst = BATnew(b->htype, TYPE_@1, BATcount(b));
	BATseqbase(dst, b->hseqbase);
	BATloop(b,p,q) {
		@2 *v = (@2*)BUNtail(bi,p);
		@1 r;
		msg = @2_num2dec_@1( &r, v, d2, s2 );
		if (msg)
			break;
		BUNins(dst, BUNhead(bi,p), &r, FALSE);
	}
	BBPkeepref( *res = dst->batCacheid);
	BBPunfix(b->batCacheid);
	return msg;
}

@c
@:fnumcastdown(bte,flt)@
@:fnumcastdown(sht,flt)@
@:fnumcastdown(int,flt)@
@:fnumcastdown(lng,flt)@
@:fnumcastdown(bte,dbl)@
@:fnumcastdown(sht,dbl)@
@:fnumcastdown(int,dbl)@
@:fnumcastdown(lng,dbl)@

@= fnumcastup
@:simpleupcast(@1,@2)@

str 
@2_dec2_@1( @1 *res, int *s1, @2 *v )
{
	int scale = *s1;
	@1 r;

	/* shortcut nil */
	if (*v == @2_nil) {
		*res = @1_nil;
		return(MAL_SUCCEED);
	}
	
	/* since the @1 type is bigger than or equal to the @2 type, it will
	   always fit */
	r = (@1)*v;
	if (scale) 
		r /= scales[scale];
	*res = r;
	return MAL_SUCCEED;
}

str 
@2_dec2dec_@1( @1 *res, int *S1, @2 *v, int *d2, int *S2 )
{
	int p = *d2, inlen = 1;
	@2 cpyval = *v;
	int s1 = *S1, s2 = *S2;
	@1 r;

	/* shortcut nil */
	if (*v == @2_nil) {
		*res = @1_nil;
		return(MAL_SUCCEED);
	}
	
	/* count the number of digits in the input */
	while (cpyval /= 10)
		inlen++;
	/* rounding is allowed */
	inlen += (s2-s1);
	if (p && inlen > p) {
		throw(SQL, "convert",
			"too many digits (%d > %d)", inlen, p);
	}

	/* since the @1 type is bigger than or equal to the @2 type, it will
	   always fit */
	r = (@1)*v;
	if(s2 > s1) 
		r *= scales[s2-s1];
	else if (s2 != s1) 
		r /= scales[s1-s2];
	*res = r;
	return MAL_SUCCEED;
}

str 
@2_num2dec_@1( @1 *res, @2 *v, int *d2, int *s2 )
{
	int zero = 0;
	return @2_dec2dec_@1( res, &zero, v, d2, s2 );
}

str bat@2_dec2_@1( int *res, int *s1, int *bid )
{
	BAT *b, *dst;
	BATiter bi;
	BUN p,q;
	char *msg = NULL;

	if( (b = BATdescriptor(*bid)) == NULL ){
		throw(SQL, "batcalc.@2_dec2_@1", "Cannot access descriptor");
	}
	bi = bat_iterator(b);
	dst = BATnew(b->htype, TYPE_@1, BATcount(b));
	BATseqbase(dst, b->hseqbase);
	BATloop(b,p,q) {
		@2 *v = (@2*)BUNtail(bi,p);
		@1 r;
		msg = @2_dec2_@1( &r, s1, v );
		if (msg)
			break;
		BUNins(dst, BUNhead(bi,p), &r, FALSE);
	}
	BBPkeepref( *res = dst->batCacheid);
	BBPunfix(b->batCacheid);
	return msg;
}

str bat@2_dec2dec_@1( int *res, int *S1, int *bid, int *d2, int *S2 )
{
	BAT *b, *dst;
	BATiter bi;
	BUN p,q;
	char *msg = NULL;

	if( (b = BATdescriptor(*bid)) == NULL ){
		throw(SQL, "batcalc.@2_dec2dec_@1", "Cannot access descriptor");
	}
	bi = bat_iterator(b);
	dst = BATnew(b->htype, TYPE_@1, BATcount(b));
	BATseqbase(dst, b->hseqbase);
	BATloop(b,p,q) {
		@2 *v = (@2*)BUNtail(bi,p);
		@1 r;
		msg = @2_dec2dec_@1( &r, S1, v, d2, S2 );
		if (msg)
			break;
		BUNins(dst, BUNhead(bi,p), &r, FALSE);
	}
	BBPkeepref( *res = dst->batCacheid);
	BBPunfix(b->batCacheid);
	return msg;
}

str bat@2_num2dec_@1( int *res, int *bid, int *d2, int *s2 )
{
	BAT *b, *dst;
	BATiter bi;
	BUN p,q;
	char *msg = NULL;

	if( (b = BATdescriptor(*bid)) == NULL ){
		throw(SQL, "batcalc.@2_num2dec_@1", "Cannot access descriptor");
	}
	bi = bat_iterator(b);
	dst = BATnew(b->htype, TYPE_@1, BATcount(b));
	BATseqbase(dst, b->hseqbase);
	BATloop(b,p,q) {
		@2 *v = (@2*)BUNtail(bi,p);
		@1 r;
		msg = @2_num2dec_@1( &r, v, d2, s2 );
		if (msg)
			break;
		BUNins(dst, BUNhead(bi,p), &r, FALSE);
	}
	BBPkeepref( *res = dst->batCacheid);
	BBPunfix(b->batCacheid);
	return msg;
}


@c
@:fnumcastup(flt,bte)@
@:fnumcastup(flt,sht)@
@:fnumcastup(flt,int)@
@:fnumcastup(flt,lng)@
@:fnumcastup(dbl,bte)@
@:fnumcastup(dbl,sht)@
@:fnumcastup(dbl,int)@
@:fnumcastup(dbl,lng)@

@c
@= numcastdown
@:simpledowncast(@1,@2)@

str 
@2_dec2_@1( @1 *res, int *s1, @2 *v )
{
	int scale = *s1;
	lng val = *v, h = (val<0)?-5:5;

	/* shortcut nil */
	if (*v == @2_nil) {
		*res = @1_nil;
		return(MAL_SUCCEED);
	}
	
	if (scale) 
		val = (val+h)/scales[scale];
	/* see if the number fits in the data type */
	if (val >= GDK_@1_min && val <= GDK_@1_max)	{
		*res = (@1)val;
		return MAL_SUCCEED;
	} else {
		throw(SQL, "convert",
			"value (" LLFMT ") exceeds limits of type @1", val);
	}
}

str 
@2_dec2dec_@1( @1 *res, int *S1, @2 *v, int *d2, int *S2 )
{
	int p = *d2, inlen = 1;
	lng val = *v, cpyval = val, h = (val<0)?-5:5;
	int s1 = *S1, s2 = *S2;

	/* shortcut nil */
	if (*v == @2_nil) {
		*res = @1_nil;
		return(MAL_SUCCEED);
	}
	
	/* count the number of digits in the input */
	while (cpyval /= 10)
		inlen++;
	/* rounding is allowed */
	inlen += (s2-s1);
	if (p && inlen > p) {
		throw(SQL, "@2_2_@1",
			"too many digits (%d > %d)", inlen, p);
	}

	if(s2 > s1) 
		val *= scales[s2-s1];
	else if (s2 != s1) 
		val = (val+h)/scales[s1-s2];

	/* see if the number fits in the data type */
	if (val >= GDK_@1_min && val <= GDK_@1_max)	{
		*res = (@1)val;
		return MAL_SUCCEED;
	} else {
		throw(SQL, "convert",
			"value (" LLFMT ") exceeds limits of type @1", val);
	}
}

str 
@2_num2dec_@1( @1 *res, @2 *v, int *d2, int *s2 )
{
	int zero = 0;
	return @2_dec2dec_@1( res, &zero, v, d2, s2 );
}

str bat@2_dec2_@1( int *res, int *s1, int *bid )
{
	BAT *b, *dst;
	BATiter bi;
	BUN p,q;
	char *msg = NULL;

	if( (b = BATdescriptor(*bid)) == NULL ){
		throw(SQL, "batcalc.@2_dec2_@1", "Cannot access descriptor");
	}
	bi = bat_iterator(b);
	dst = BATnew(b->htype, TYPE_@1, BATcount(b));
	BATseqbase(dst, b->hseqbase);
	BATloop(b,p,q) {
		@2 *v = (@2*)BUNtail(bi,p);
		@1 r;
		msg = @2_dec2_@1( &r, s1, v );
		if (msg)
			break;
		BUNins(dst, BUNhead(bi,p), &r, FALSE);
	}
	BBPkeepref( *res = dst->batCacheid);
	BBPunfix(b->batCacheid);
	return msg;
}

str bat@2_dec2dec_@1( int *res, int *S1, int *bid, int *d2, int *S2 )
{
	BAT *b, *dst;
	BATiter bi;
	BUN p,q;
	char *msg = NULL;

	if( (b = BATdescriptor(*bid)) == NULL ){
		throw(SQL, "batcalc.@2_dec2dec_@1", "Cannot access descriptor");
	}
	bi = bat_iterator(b);
	dst = BATnew(b->htype, TYPE_@1, BATcount(b));
	BATseqbase(dst, b->hseqbase);
	BATloop(b,p,q) {
		@2 *v = (@2*)BUNtail(bi,p);
		@1 r;
		msg = @2_dec2dec_@1( &r, S1, v, d2, S2 );
		if (msg)
			break;
		BUNins(dst, BUNhead(bi,p), &r, FALSE);
	}
	BBPkeepref( *res = dst->batCacheid);
	BBPunfix(b->batCacheid);
	return msg;
}

str bat@2_num2dec_@1( int *res, int *bid, int *d2, int *s2 )
{
	BAT *b, *dst;
	BATiter bi;
	BUN p,q;
	char *msg = NULL;

	if( (b = BATdescriptor(*bid)) == NULL ){
		throw(SQL, "batcalc.@2_num2dec_@1", "Cannot access descriptor");
	}
	bi = bat_iterator(b);
	dst = BATnew(b->htype, TYPE_@1, BATcount(b));
	BATseqbase(dst, b->hseqbase);
	BATloop(b,p,q) {
		@2 *v = (@2*)BUNtail(bi,p);
		@1 r;
		msg = @2_num2dec_@1( &r, v, d2, s2 );
		if (msg)
			break;
		BUNins(dst, BUNhead(bi,p), &r, FALSE);
	}
	BBPkeepref( *res = dst->batCacheid);
	BBPunfix(b->batCacheid);
	return msg;
}


@c
@:numcastdown(bte,sht)@
@:numcastdown(bte,int)@
@:numcastdown(bte,lng)@
@:numcastdown(sht,int)@
@:numcastdown(sht,lng)@
@:numcastdown(int,lng)@

str 
month_interval_str( int *ret, str *s, int *ek, int *sk )
{
	lng res;

	if (interval_from_str( *s, *sk, *ek, &res ) < 0)
		throw(SQL, "calc.month_interval",
			"wrong format (%s)", *s);
	*ret = res;
	return MAL_SUCCEED;
}

str 
second_interval_str( lng *res, str *s, int *ek, int *sk )
{

	if (interval_from_str( *s, *sk, *ek, res ) < 0)
		throw(SQL, "calc.second_interval",
			"wrong format (%s)", *s);
	return MAL_SUCCEED;
}

@= c_interval
str
month_interval_@1( int *ret, @1 *s, int *ek, int *sk ){
	int r = (int)*s;

	(void)ek;
	switch(*sk) {
	case iyear: 	
		r *= 12;
	case imonth:
		break;
	default:
		throw(ILLARG, "calc.month_interval","illegal argument");
	}
	*ret = r;
	return MAL_SUCCEED;
}
str
second_interval_@1( lng *res, @1 *s, int *ek, int *sk ){
	lng r = *s;

	(void)ek;
	switch(*sk) {
	case iday: 	
		r *= 24;
	case ihour:
		r *= 60;
	case imin:
		r *= 60;
	case isec:
		break;
	default:
		throw(ILLARG, "calc.second_interval","illegal argument");
	}
	*res = r;
	return MAL_SUCCEED;
}
@c
@:c_interval(bte)@
@:c_interval(sht)@
@:c_interval(int)@
@:c_interval(lng)@

str
dump_cache(int *r)
{
	mvc *m = NULL;
	str msg = getContext(&m, NULL);
	int cnt; 
	BAT *t, *query, *count;
	cq *q = NULL;

	if (msg)
		return msg;
	cnt = m->qc->id; 
 	t = BATnew(TYPE_str, TYPE_bat, 1);
	query = BATnew(TYPE_void, TYPE_str, cnt);
	BATseqbase(query, 0);
	count = BATnew(TYPE_void, TYPE_int, cnt);
	BATseqbase(count, 0);
	BUNins(t, "query", &query->batCacheid, FALSE);
	BUNins(t, "count", &count->batCacheid, FALSE);

	for(q = m->qc->q; q; q = q->next) {
		BUNappend(query, q->codestring, FALSE);
		BUNappend(count, &q->count, FALSE);
	}

	BBPunfix(query->batCacheid);
	BBPunfix(count->batCacheid);
	*r = t->batCacheid;
	BBPkeepref(*r);
	return MAL_SUCCEED;
}

str
dump_opt_stats(int *r)
{
	mvc *m = NULL;
	str msg = getContext(&m, NULL);
	int cnt; 
	BAT *t, *rewrite, *count;

	if (msg)
		return msg;
	cnt = m->qc->id; 
 	t = BATnew(TYPE_str, TYPE_bat, 1);
	rewrite = BATnew(TYPE_void, TYPE_str, cnt);
	BATseqbase(rewrite, 0);
	count = BATnew(TYPE_void, TYPE_int, cnt);
	BATseqbase(count, 0);
	BUNins(t, "rewrite", &rewrite->batCacheid, FALSE);
	BUNins(t, "count", &count->batCacheid, FALSE);

	BUNappend(rewrite, "joinidx", FALSE);
	BUNappend(count, &m->opt_stats[0], FALSE);
	/* TODO add other rewrites */

	BBPunfix(rewrite->batCacheid);
	BBPunfix(count->batCacheid);
	*r = t->batCacheid;
	BBPkeepref(*r);
	return MAL_SUCCEED;
}

@= rnk
str 
sql_@1rank_grp(bat *rid, bat *bid, bat *gid, bat *gpe)
{
	BAT *r, *b, *g;
	BUN p, q;
	BATiter bi, gi;
	int (*ocmp)(ptr, ptr), (*gcmp)(ptr, ptr);
	ptr oc, gc;
	int rank = 1, nrank = @3;

	if( (b = BATdescriptor(*bid)) == NULL )
		throw(SQL, "sql.@1rank_grp", "Cannot access descriptor");
	if( (g = BATdescriptor(*gid)) == NULL )
		throw(SQL, "sql.@1rank_grp", "Cannot access descriptor");
	(void)gpe;
	bi = bat_iterator(b);
	gi = bat_iterator(g);
	ocmp = BATatoms[b->ttype].atomCmp;
	gcmp = BATatoms[g->ttype].atomCmp;
	oc = BUNtail(bi, BUNfirst(b));
	gc = BUNtail(gi, BUNfirst(g));
	if (!ALIGNsynced(b, g))
		throw(SQL, "sql.@1rank_grp", "bats not aligned");
	if (BATtordered(b) != GDK_SORTED)
		throw(SQL, "sql.@1rank_grp", "bat not sorted");
	r = BATnew(TYPE_oid, TYPE_int, BATcount(b));
	if (r == NULL)
		throw(SQL, "sql.@1rank_grp", "cannot allocate result bat");
	BATloop(b, p, q) {
		ptr on = BUNtail(bi, p);
		ptr gn = BUNtail(gi, p);
		int c = 0;

		if ((c = ocmp(on, oc)) != 0) 
			rank = nrank;
		if (gcmp(gn, gc) != 0) 
			c = rank = nrank = 1;  
		oc = on;
		gc = gn;
		BUNins(r, BUNhead(bi,p), &rank, FALSE);
		@2;
	}
	BBPunfix(b->batCacheid);
	BBPunfix(g->batCacheid);
	BBPkeepref(*rid = r->batCacheid);
	return MAL_SUCCEED;
}

str
sql_@1rank(bat *rid, bat *bid)
{ 
	BAT *r, *b;
	BATiter bi;
	int (*cmp)(ptr, ptr);
	ptr cur;
	BUN p, q;
	int rank = 1, nrank = @3;

	if( (b = BATdescriptor(*bid)) == NULL )
		throw(SQL, "sql.@1rank", "Cannot access descriptor");
	if (BATtordered(b) != GDK_SORTED)
		throw(SQL, "sql.@1rank", "bat not sorted");
	bi = bat_iterator(b);
	cmp = BATatoms[b->ttype].atomCmp;
	cur = BUNtail(bi, BUNfirst(b));
	r = BATnew(TYPE_oid, TYPE_int, BATcount(b));
	if (r == NULL)
		throw(SQL, "sql.@1rank", "cannot allocate result bat");
	if (BATtdense(b)) {
		BATloop(b, p, q) {
			BUNins(r, BUNhead(bi,p), &rank, FALSE);
			rank++;
		}
	} else {
		BATloop(b, p, q) {
			ptr n = BUNtail(bi, p);
			int c = 0;
	
			if ((c = cmp(n, cur)) != 0) 
				rank = nrank; 
			cur = n;
			BUNins(r, BUNhead(bi,p), &rank, FALSE);
			@2;
		}
	}
	BBPunfix(b->batCacheid);
	BBPkeepref(*rid = r->batCacheid);
	return MAL_SUCCEED;
}
@c
@:rnk(,(void)c;nrank++,1)@
@:rnk(dense_,nrank+=(c?1:0),2)@
