@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
@' Copyright August 2008-2009 MonetDB B.V.
@' All Rights Reserved.

@f sql
@t SQL Scenario implementation
@a M Kersten 
@v 0
@* SQL support implementation
This module contains the wrappers around the SQL 
multi-version-catalog and support routines copied
from the Version 4 code base.

@mal
module batsql;
module sql;

pattern start():void 
address SQLsession
comment "Switch to processing SQL statements";

pattern start2():void
address SQLsession2
comment "Switch to processing precompiled sql statements";

pattern init():void
address SQLinitEnvironment
comment "Initialize the environment for MAL";

pattern transaction():void
address SQLtransaction
comment "Start a transaction";
pattern commit():void
address SQLcommit
comment "Commit the transaction";
pattern rollback():void
address SQLrollback
comment "Abort the transaction";

pattern eval(cmd:str):void 
address SQLstatement
comment "Compile and execute a single sql statement";

pattern eval(cmd:str, output:bit):void 
address SQLstatement
comment "Compile and execute a single sql statement (and optionaly send output on the output stream)";

pattern assert{unsafe}(b:bit,msg:str):void
address SQLassert
comment "Generate an exception when b==true";

pattern assert{unsafe}(b:int,msg:str):void
address SQLassertInt
comment "Generate an exception when b!=0";

pattern assert{unsafe}(b:wrd,msg:str):void
address SQLassertWrd
comment "Generate an exception when b!=0";

pattern assert{unsafe}(b:lng,msg:str):void
address SQLassertLng
comment "Generate an exception when b!=0";
@- The SQL multi-version catalog
This module also contains the definitions for managing an SQL database schema in
version 5.  It is an adaptation of the original V4.3 code base. 
A main difference is that the global catalog is obtained from
the client record, rather then lookup the variable in a context stack.

The MAL operations below are used in the SQL->MAL compiler and
can be (sparingly) used to inspect it from a MIL console.
The 'mvc_' header is removed, because all commands are already
prepended by the 'sql.' module name.
The original code is retained, because it makes it
easier to later re-use part of the catalog code in a separately.
@mal

pattern setVariable( varname:str, value:any_1 ):void
address setVariable
comment "Set the value of a session variable";

pattern getVariable( varname:str ):any_1
address getVariable
comment "Get the value of a session variable";

pattern logfile{unsafe}(filename:str):void 
address mvc_logfile
comment "Enable/disable saving the sql statement traces";

pattern next_value( sname:str, sequence:str ):lng
address mvc_next_value
comment "return the next value of the sequence";

pattern batsql.next_value( sname:bat[:oid,:str], sequence:str ) :bat[:oid,:lng]
address mvc_bat_next_value
comment "return the next value of the sequence";

pattern get_value( sname:str, sequence:str ):lng
address mvc_get_value
comment "return the current value of the sequence";

pattern restart{unsafe}( sname:str, sequence:str, start:lng ):lng
address mvc_restart_seq
comment "restart the sequence with value start";

pattern bind_dbat(schema:str, table:str, access:int):bat[:oid,:oid]
address mvc_bind_dbat_wrap
comment "Bind to 'schema.table' BAT with deleted objecs
and with specific access kind:
	0 - base table
	1 - inserts
	2 - updates";

pattern bind_idxbat(schema:str, table:str, index:str, access:int):bat[:oid,:any_1]
address mvc_bind_idxbat_wrap
comment "Bind the 'schema.table.index' BAT with access kind:
	0 - base table
	1 - inserts
	2 - updates";

pattern bind_idxbat(schema:str, table:str, index:str, access:int, low:oid, hgh:oid):bat[:oid,:any_1]
address mvc_bind_idxbat_wrap
comment "Bind the 'schema.table.index' BAT with access kind:
	0 - base table
	1 - inserts
	2 - updates";

pattern bind(schema:str, table:str, column:str, access:int ):bat[:oid,:any_1]
address mvc_bind_wrap
comment "Bind the 'schema.table.column' BAT with access kind:
	0 - base table
	1 - inserts
	2 - updates";

pattern bind(schema:str, table:str, column:str, access:int, low:oid, hgh:oid ):bat[:oid,:any_1]
address mvc_bind_wrap
comment "Bind the 'schema.table.column' BAT partition with access kind:
	0 - base table
	1 - inserts
	2 - updates";

command bind_dbat(clientid:int, schema:str, table:str, access:int, oldversion:lng, version:lng):bat[:oid,:oid]
address mvc_diff_dbat_wrap
comment "Bind to 'schema.table' BAT with deleted objecs
and with specific access kind:
	0 - base table
	1 - inserts
	2 - updates";

command getVersion(clientid:int):lng
address mvc_getVersion
comment "Return the database version identifier for a client";

pattern append{unsafe}(sname:str, tname:str, cname:str, ins:any ):void
address mvc_append_wrap
comment "Append b to the column tname.cname (possibly optimized to replace the insert bat of tname.cname";

pattern update{unsafe}(sname:str, tname:str, cname:str, ins:any ):void
address mvc_update_wrap
comment "Append b to the column tname.cname (possibly optimized to replace the insert bat of tname.cname";

pattern clear_table{unsafe}(sname:str, tname:str) :wrd
address mvc_clear_table_wrap
comment "Clear table";

pattern delete{unsafe}(sname:str, tname:str, b:any) :void 
address mvc_delete_wrap
comment "delete from table";

command columnBind(b:bat[:str,:bat], nme:str) :bat[:oid,:any_1]
address mvc_bind_single_wrap
comment "Bind the column bat into the focus ";

@-
The Monet 5 code generator uses several SQL specific wrapper functions.
@mal
pattern resultSet{unsafe}( nr_cols:int, sep:str, rsep:str, ssep:str, ns:str, order:any_1 ) :int 
address mvc_result_file_wrap
comment "Prepare a file result set"; 

pattern resultSet{unsafe}( nr_cols:int, sep:str, rsep:str, ssep:str, ns:str, order:bat[:oid,:any_1] ) :int 
address mvc_result_file_wrap
comment "Prepare a file result set"; 

pattern resultSet{unsafe}( nr_cols:int, qtype:int, order:any_1 ) :int 
address mvc_result_row_wrap
comment "Prepare a row result set"; 

pattern resultSet{unsafe}( nr_cols:int, qtype:int, order:bat[:oid,:any_1] ) :int 
address mvc_result_table_wrap
comment "Prepare a table result set"; 

pattern rsColumn{unsafe}(rs:int, tname:str, name:str, typename:str, digits:int, scale:int, val:any_1 ) :void
address mvc_result_value_wrap
comment "Add the value to the row query result";

pattern rsColumn{unsafe}(rs:int, tname:str, name:str, typename:str, digits:int, scale:int, col:bat[:oid,:any_1] ) :void
address mvc_result_column_wrap
comment "Add the column to the table query result";

pattern declaredTable{unsafe}( name:str ) :int 
address mvc_declared_table_wrap
comment "Prepare a declared table"; 

pattern dtColumn{unsafe}(rs:int, tname:str, name:str, typename:str, digits:int, scale:int) :void
address mvc_declared_table_column_wrap;

pattern dropDeclaredTable{unsafe}( name:str ) :void 
address mvc_drop_declared_table_wrap
comment "drop a declared table"; 

pattern dropDeclaredTables{unsafe}( nr:int ) :void 
address mvc_drop_declared_tables_wrap
comment "drop top n declared tables"; 

pattern exportHead{unsafe}(s:streams, res_id:int) :void
address mvc_export_head_wrap
comment "Export a result (in order) to stream s"; 

pattern exportResult{unsafe}(s:streams, res_id:int) :void
address mvc_export_result_wrap
comment "Export a result (in order) to stream s"; 

pattern exportChunk{unsafe}(s:streams, res_id:int) :void
address mvc_export_chunk_wrap
comment "Export a chunk of the result set (in order) to stream s"; 

pattern exportChunk{unsafe}(s:streams, res_id:int, offset:int, nr:int) :void
address mvc_export_chunk_wrap
comment "Export a chunk of the result set (in order) to stream s"; 

pattern exportOperation{unsafe}(w:str) :void
address mvc_export_operation_wrap
comment "Export result of schema/transaction queries"; 

pattern affectedRows{unsafe}(nr:wrd, w:str) :void
address mvc_affected_rows_wrap
comment "export the number of affected rows by the current query";

pattern exportValue{unsafe}(qtype:int, tname:str, name:str, typename:str, digits:int, scale:int, eclass:int, val:any_1, w:str):void
address mvc_export_value_wrap 
comment "export a single value onto the stream s";

pattern importTable{unsafe}( s:bstream, sname:str, tname:str, 
	sep:str, rsep:str, ssep:str, ns:str, nr:lng, offset:lng) :bat[:str,:bat]
address mvc_import_table_wrap
comment "Import a table from bstream s with the 
	given tuple and seperators (sep/rsep)";

function copy_from(
	sname:str,
	tname:str,
	tsep:str,
	rsep:str,
	ssep:str,
	ns:str,
	fname:str,
	nr:lng,
	offset:lng
):bat[:str,:bat];
	cs := str.codeset();
	f  := str.iconv(fname, "UTF-8", cs);
	s  := streams.openRead(f);
	#bs := bstream.create(s, 1048576);
	#bs := bstream.create(s, 8388608);
	bs := bstream.create(s, 33554432);
	#bs := bstream.create(s, 67108864);

	res := sql.importTable(bs, sname, tname, tsep, rsep, ssep, ns, nr, offset);
	bstream.destroy(bs);
	streams.close(s);
	return res;
end copy_from;

function copyfrom(
	sname:str,
	tname:str,
	tsep:str,
	rsep:str,
	ssep:str,
	ns:str,
	nr:lng,
	offset:lng
):bat[:str,:bat];
	in := io.stdin();
	res := sql.importTable(in, sname, tname, tsep, rsep, ssep, ns, nr, offset);
	return res;
end copyfrom;

pattern importTable{unsafe}( sname:str, tname:str, fname:str... ) :bat[:str,:bat]
address mvc_bin_import_table_wrap
comment "Import a table from the files (fname)";


command zero_or_one( col:bat[:any_2,:any_1]) :any_1
address zero_or_one
comment "if col contains exactly one value return this. Incase of more raise an exception else return nil";

command not_unique( b:bat[:oid,:oid]) :bit 
address not_unique 
comment "check if the tail sorted bat b doesn't have unique tail values" ;

command not_uniques( b:bat[:oid,:oid]) :bat[:oid,:oid] 
address not_unique_oids 
comment "return not unique oids" ;
command not_uniques( b:bat[:oid,:wrd]) :bat[:oid,:oid] 
address not_unique_oids ;

function times(elaps:int,inblock:lng, oublock:lng):void;
	io.printf("#times %d ms",elaps);
	io.printf(" %d reads",inblock);
	io.printf(" %d writes\n",oublock);
end times;

factory times();
	elaps:= alarm.time();
	user := profiler.getUserTime();
	system := profiler.getSystemTime();
	inblocks := profiler.getDiskReads();
	oublocks := profiler.getDiskWrites();
barrier goon:=true;
	e1:= alarm.time();
	u1:= profiler.getUserTime();
	s1:= profiler.getSystemTime();
	i1 := profiler.getDiskReads();
	o1 := profiler.getDiskWrites();
	elaps:= e1-elaps;
	inblocks := i1-inblocks;
	oublocks := o1-oublocks;
	user := u1-user;
	system:= s1-system;
	io.printf("times %d ms",elaps);
	io.printf(" user %d ms",user);
	io.printf(" system %d ms",system);
	io.printf(" %d reads",inblocks);
	io.printf(" %d writes\n",oublocks);
	elaps := e1;
	user := u1;
	system:=s1;
	inblocks  := i1;
	oublocks  := o1;
	yield times;
	redo goon:=true;
exit goon;
end times;

pattern argRecord():str
address SQLargRecord
comment "Glue together the calling sequence";
pattern argRecord(a:any...):str
address SQLargRecord
comment "Glue together the calling sequence";

function sql_environment():bat[:str,:bat];
	b := bat.new(:str,:bat,2);
	e := inspect.getEnvironment();
	n := algebra.markT(e, 0:oid);
	r := bat.reverse(n);
	v := algebra.markH(e, 0:oid);
	bat.insert(b, "name", r);
	bat.insert(b, "value", v);
	return sql_environment := b;
end sql_environment;

function clients():bat[:str,:bat];
	b := bat.new(:str,:bat,5);
	u:= clients.getUsers();
	bat.insert(b,"user",u);
	l:= clients.getLogins();
	bat.insert(b,"login",l);
	c:= clients.getLastCommand();
	bat.insert(b,"lastcommand",c);
	a:= clients.getActions();
	bat.insert(b,"actions",a);
	t:= clients.getTime();
	bat.insert(b,"seconds",t);
	return clients := b;
end clients;

function bbp():bat[:str,:bat];
	b := bat.new(:str,:bat,12);
	ns := bbp.getNames();
	ri := algebra.markT(ns, 0:oid);
	i := bat.reverse(ri);
	n := algebra.markH(ns, 0:oid);
	bat.insert(b, "id", i);
	bat.insert(b, "name", n);
	iht := bbp.getHeadType();
	ht := algebra.markH(iht, 0:oid);
	bat.insert(b, "htype", ht);
	itt := bbp.getTailType();
	tt := algebra.markH(itt, 0:oid);
	bat.insert(b, "ttype", tt);
	icnt := bbp.getCount();
	cnt := algebra.markH(icnt, 0:oid);
	bat.insert(b, "count", cnt);
	irefcnt := bbp.getRefCount();
	refcnt := algebra.markH(irefcnt, 0:oid);
	bat.insert(b, "refcnt", refcnt);
	ilrefcnt := bbp.getLRefCount();
	lrefcnt := algebra.markH(ilrefcnt, 0:oid);
	bat.insert(b, "lrefcnt", lrefcnt);
	ilocation := bbp.getLocation();
	location := algebra.markH(ilocation, 0:oid);
	bat.insert(b, "location", location);
	iheat := bbp.getHeat();
	heat := algebra.markH(iheat, 0:oid);
	bat.insert(b, "heat", heat);
	idirty := bbp.getDirty();
	dirty := algebra.markH(idirty, 0:oid);
	bat.insert(b, "dirty", dirty);
	istatus := bbp.getStatus();
	status := algebra.markH(istatus, 0:oid);
	bat.insert(b, "status", status);
	ikind := bbp.getKind();
	kind := algebra.markH(ikind, 0:oid);
	bat.insert(b, "kind", kind);
	return bbp := b;
end bbp;

pattern sql_variables():bat[:str,:bat]
address sql_variables
comment "return the table with session variables";

pattern db_users() :bat[:str,:bat]
address db_users_wrap
comment "return table of users with sql scenario";

pattern password(user:str) :str
address db_password_wrap
comment "return password hash of user";

pattern dump_cache() :bat[:str,:bat]
address dump_cache
comment "dump the content of the query cache";

pattern dump_opt_stats() :bat[:str,:bat]
address dump_opt_stats
comment "dump the optimizer rewrite statistics";

pattern dump_trace() :bat[:str,:bat]
address dump_trace
comment "dump the trace statistics";

@- SQL function aliases
The code generate should identify the precise module
target for all functions. This creates quite some
administration overhead and analysis at many places.
The alternative is to extend modules with an alias.

The routine below are added to the calc module to
ease code generation.
@mal
pattern calc.hash( v:any ) :wrd address MKEYhash; 
command batcalc.hash( b:bat[:oid,:any_1] ) :bat[:oid,:wrd] address MKEYbathash;
pattern calc.rotate_xor_hash(h:wrd, nbits:int, v:any_1) :wrd address MKEYrotate_xor_hash;
command batcalc.rotate_xor_hash(h:bat[:oid,:wrd], nbits:int, b:bat[:oid,:any_1]) :bat[:oid,:int] address MKEYbulk_rotate_xor_hash;

@- SQL functions
The SQL functions are all recognized by their module name.
For some we need to provide a new implementation, others
merely require a different address binding.

The aggregate operations work on doubles by default.
This calls for casting values around in the process.

@= mal_round
command sql.dec_round( v:@1, r:@1 ) :@1 
address @1_dec_round_wrap
comment "round off the value v to nearests multiple of r";

command sql.round( v:@1, d:int, s:int, r:bte) :@1
address @1_round_wrap
comment "round off the decimal v(d,s) to r digits behind the dot (if r < 0, before the dot)";

@mal
@:mal_round(bte)@
@:mal_round(sht)@
@:mal_round(int)@
@:mal_round(lng)@

@= mal_fround
command sql.dec_round( v:@1, r:@1 ) :@1 
address @1_dec_round_wrap
comment "round off the value v to nearests multiple of r";

command sql.round( v:@1, r:bte) :@1
address @1_round_wrap
comment "round off the floating point v to r digits behind the dot (if r < 0, before the dot)";

@mal
@:mal_fround(flt)@
@:mal_fround(dbl)@

@= mal_cast
command calc.@1( v:str ) :@1 
address str_2_@1
comment "Cast to @1";
command calc.@1( v:str, digits:int ) :@1 
address str_2num_@1
comment "cast to @1 and check for overflow";
command calc.@1( v:str, digits:int, scale:int ) :@1 
address str_2dec_@1
comment "cast to dec(@1) and check for overflow";

command batcalc.@1( v:bat[:oid,:str] ) :bat[:oid,:@1] 
address batstr_2_@1
comment "Cast to @1";
command batcalc.@1( v:bat[:oid,:str], digits:int ) :bat[:oid,:@1] 
address batstr_2num_@1
comment "cast to @1 and check for overflow";
command batcalc.@1( v:bat[:oid,:str], digits:int, scale:int ) :bat[:oid,:@1] 
address batstr_2dec_@1
comment "cast to dec(@1) and check for overflow";
@-
@{
address CALCstr2@1
command calc.str( v:@1 ) :str
address CALC@12str
comment "Cast @1 to str";
@}
@mal
@:mal_cast(bte)@
@:mal_cast(sht)@
@:mal_cast(int)@
@:mal_cast(lng)@

@= mal_castfromstr
command calc.@1( v:str ) :@1 
address str_2_@1
comment "cast to @1";
command batcalc.@1( v:bat[:oid,:str] ) :bat[:oid,:@1] 
address batstr_2_@1
comment "cast to @1";
command calc.str( v:@1 ) :str 
address SQL@1_2_str
comment "cast @1 to str";
@mal
@:mal_castfromstr(wrd)@
@:mal_castfromstr(flt)@
@:mal_castfromstr(dbl)@
@:mal_castfromstr(timestamp)@
@:mal_castfromstr(daytime)@
@:mal_castfromstr(date)@
@:mal_castfromstr(sqlblob)@

@mal
command calc.str( v:str) :str 
address CALCstr2str
comment "Idempotent cast of strings";

@+ bit conversion (why?) 
command calc.str( v:bit) :str 
address CALCbit2str
comment "Idempotent cast of strings";

command calc.bte( v:bit) :bte 
address CALCbit2bte
comment "Cast bit to bte ";
command calc.sht( v:bit) :sht 
address CALCbit2sht
comment "Cast bit to sht ";
command calc.int( v:bit) :int 
address CALCbit2int
comment "Cast bit to int ";
command calc.lng( v:bit) :lng 
address CALCbit2lng
comment "Cast bit to lng ";
@mal

pattern calc.str( eclass:int, d1:int, s1:int, has_tz:int, v:any_1, digits:int ) :str 
address SQLstr_cast
comment "cast to string and check for overflow";

pattern batcalc.str( eclass:int, d1:int, s1:int, has_tz:int, v:bat[:oid,:any_1], digits:int ) :bat[:oid,:str] 
address SQLbatstr_cast
comment "cast to string and check for overflow";

command calc.substring(s:str,offset:int):str
address STRsubstringTail;
command calc.substring(s:str,offset:int,count:int):str
address STRsubstring;

@= mal_cast_2dec
command calc.@1( v:@2) :@1 
address @2_2_@1
comment "cast @2 to @1";
command calc.@1( v:@2, digits:int, scale:int ) :@1 
address @2_num2dec_@1
comment "cast number to decimal(@1) and check for overflow";

command batcalc.@1( v:bat[:oid,:@2]) :bat[:oid,:@1]
address bat@2_2_@1
comment "cast @2 to @1";
command batcalc.@1( v:bat[:oid,:@2], digits:int, scale:int ) :bat[:oid,:@1] 
address bat@2_num2dec_@1
comment "cast number to decimal(@1) and check for overflow";
@mal
@:mal_cast_2dec(bte,flt)@
@:mal_cast_2dec(sht,flt)@
@:mal_cast_2dec(int,flt)@
@:mal_cast_2dec(wrd,flt)@
@:mal_cast_2dec(lng,flt)@
@:mal_cast_2dec(bte,dbl)@
@:mal_cast_2dec(sht,dbl)@
@:mal_cast_2dec(int,dbl)@
@:mal_cast_2dec(wrd,dbl)@
@:mal_cast_2dec(lng,dbl)@

@= mal_cast_dec2
command calc.@1( s1:int, v:@2) :@1 
address @2_dec2_@1
comment "cast decimal(@2) to @1 and check for overflow";
command calc.@1( s1:int, v:@2, d2:int, s2:int ) :@1 
address @2_dec2dec_@1
comment "cast decimal(@2) to decimal(@1) and check for overflow";

command batcalc.@1( s1:int, v:bat[:oid,:@2]) :bat[:oid,:@1]
address bat@2_dec2_@1
comment "cast decimal(@2) to @1 and check for overflow";
command batcalc.@1( s1:int, v:bat[:oid,:@2], d2:int, s2:int ) :bat[:oid,:@1] 
address bat@2_dec2dec_@1
comment "cast decimal(@2) to decimal(@1) and check for overflow";
@mal

@= mal_cast2
@:mal_cast_2dec(@1,@2)@
@:mal_cast_dec2(@1,@2)@
@mal
@:mal_cast2(bte,bte)@
@:mal_cast2(bte,sht)@
@:mal_cast2(bte,int)@
@:mal_cast2(bte,wrd)@
@:mal_cast2(bte,lng)@
@:mal_cast2(sht,bte)@
@:mal_cast2(sht,sht)@
@:mal_cast2(sht,int)@
@:mal_cast2(sht,wrd)@
@:mal_cast2(sht,lng)@
@:mal_cast2(int,bte)@
@:mal_cast2(int,sht)@
@:mal_cast2(int,int)@
@:mal_cast2(int,wrd)@
@:mal_cast2(int,lng)@
@:mal_cast2(wrd,bte)@
@:mal_cast2(wrd,sht)@
@:mal_cast2(wrd,int)@
@:mal_cast2(wrd,wrd)@
@:mal_cast2(lng,bte)@
@:mal_cast2(lng,sht)@
@:mal_cast2(lng,int)@
@:mal_cast2(lng,wrd)@
@:mal_cast2(lng,lng)@
@:mal_cast2(flt,bte)@
@:mal_cast2(flt,sht)@
@:mal_cast2(flt,int)@
@:mal_cast2(flt,wrd)@
@:mal_cast2(flt,lng)@
@:mal_cast2(dbl,bte)@
@:mal_cast2(dbl,sht)@
@:mal_cast2(dbl,int)@
@:mal_cast2(dbl,wrd)@
@:mal_cast2(dbl,lng)@

@= mal_interval
command calc.month_interval( v:@1, ek:int, sk:int ) :int
address month_interval_@1
comment "cast @1 to a month_interval and check for overflow";

command calc.second_interval( v:@1, ek:int, sk:int ) :lng
address second_interval_@1
comment "cast @1 to a second_interval and check for overflow";
@mal

@:mal_interval(str)@
@:mal_interval(bte)@
@:mal_interval(sht)@
@:mal_interval(int)@
@:mal_interval(wrd)@
@:mal_interval(lng)@
@:mal_interval(daytime)@

command calc.rowid(v:any_1, schema:str, table:str) :oid
address sql_rowid
comment "return the next rowid";

command sql.rank_grp(b:bat[:oid,:any_1], gp:bat[:oid,:oid], gpe:bat[:oid,:oid]) :bat[:oid,:int] 
address sql_rank_grp
comment "return the ranked groups";

command sql.rank(b:bat[:oid,:any_1]) :bat[:oid,:int] 
address sql_rank
comment "return the rank bat";

command sql.dense_rank_grp(b:bat[:oid,:any_1], gp:bat[:oid,:oid], gpe:bat[:oid,:oid]) :bat[:oid,:int] 
address sql_dense_rank_grp
comment "return the densely ranked groups";

command sql.dense_rank(b:bat[:oid,:any_1]) :bat[:oid,:int] 
address sql_dense_rank
comment "return the densely ranked bat";

command aggr.exist(b:bat[:any_1,:any_2], h:any_1):bit 
address ALGexist;

function slave.open(tag:int, t:timestamp):bit;
    X4:bat[:oid,:int]  := sql.bind("sys","replicas","tag",0);
	X5 := bat.reverse(X4);
	c1 := algebra.exist(X5,tag);
	sql.assert(c1, "Ignoring replay of transaction");
    X13:bat[:oid,:int]  := sql.bind("sys","replicas","tag",1);
	X14 := bat.reverse(X13);
	c1 := algebra.exist(X14,tag);
	sql.assert(c1, "Ignoring replay of transaction");
	return open:= true;
end slave.open;

function slave.close(uri:str, tag:int, t:timestamp):bit;
    sql.append("sys","replicas","uri",uri);
    sql.append("sys","replicas","tag",tag);
    sql.append("sys","replicas","stamp",t);
    sql.append("sys","replicas","remark",nil);
	return close:= true;
end slave.close;

function batcalc.mark_grp{inline}( b:bat[:oid,:any_1], a:bat[:any_2,:any_3], g:bat[:oid,:oid]) :bat[:oid,:int]; 
	# order based on b
	bm := algebra.markT(b,0:oid);
	mb := bat.reverse(bm);
	ma := algebra.leftfetchjoin(mb, a);
	aa := bat.mirror(a);
	maa := algebra.leftfetchjoin(mb, aa);
	x := algebra.mark_grp(ma,g,1:oid);
	mg := batcalc.int(x);
	# restore the order based on a 
	aam := bat.reverse(maa);
	return mark_grp := algebra.leftfetchjoin(aam, mg);
end batcalc.mark_grp;

function batcalc.mark_grp{inline}( b:bat[:oid,:any_1] ) :bat[:oid,:int]; 
	x := algebra.markT(b,1:oid);
	return mark_grp:= batcalc.int(x);
end batcalc.mark_grp;

function batcalc.rank_grp{inline}( b:bat[:oid,:any_1], gp:bat[:oid,:oid], gpe:bat[:oid,:oid]) :bat[:oid,:int]; 
	o := bat.mirror(b);
	g := algebra.join(o, gp);
	return rank_grp:= sql.rank_grp(b, g, gpe);
end batcalc.rank_grp;

function batcalc.rank_grp{inline}( b:bat[:oid,:any_1]) :bat[:oid,:int]; 
	return rank_grp:= sql.rank(b);
end batcalc.rank_grp;

function batcalc.dense_rank_grp{inline}( b:bat[:oid,:any_1], gp:bat[:oid,:oid], gpe:bat[:oid,:oid]) :bat[:oid,:int]; 
	o := bat.mirror(b);
	g := algebra.join(o, gp);
	return dense_rank_grp:= sql.dense_rank_grp(b, g, gpe);
end batcalc.dense_rank_grp;

function batcalc.dense_rank_grp{inline}( b:bat[:oid,:any_1]) :bat[:oid,:int]; 
	return dense_rank_grp:= sql.dense_rank(b);
end batcalc.dense_rank_grp;

function sql.zero_or_one{inline}( b:bat[:oid,:any_1], gp:bat[:oid,:oid], gpe:bat[:oid,:oid]) :bat[:oid,:any_1];
	(e,g) := group.new(gp);
	m := aggr.max(e);
	c0 := calc.isnil(m);
	c0 := calc.not(c0);
	c1 := calc.>(m,1:wrd);
	c1 := calc.and(c0,c1);
	ms := calc.str(m); 
	msg := str.+("zero_or_one: cardinality violation (", ms);
	msg := str.+(msg, ">1)");
	sql.assert(c1, msg);
	return zero_or_one := b;
end sql.zero_or_one;


function mmath.rand{inline}( v:int ) :int;
	x := mmath.rand();
	return rand := x;
end mmath.rand;

pattern cluster(sch:str, tbl:str)
address SQLcluster
comment "Cluster the columns of a table on the (first) primary key";

pattern cluster2(sch:str, tbl:str)
address SQLcluster2
comment "Cluster the columns of a table on the (first) primary key";
@-
The distributed processing of queries requires the SQL runtime
system to be able to deliver portions of the BATs in an efficient
way. 
It should be cast into a more efficient C procedure, which also
takes care of NAS opportunities.
@mal
function octopus.bind(sch:str, tab:str,col:str,kind:int, 
low:oid, hgh:oid, version:int):bat[:oid,:any_1];
	b:bat[:oid,:any_1]:= sql.bind(sch,tab,col,kind,low,hgh);
	return bind:= b;
end bind;

function octopus.bind(sch:str, tab:str,col:str,kind:int, version:int):bat[:oid,:any_1];
	b:bat[:oid,:any_1]:= sql.bind(sch,tab,col,kind);
	return bind:= b;
end bind;

function octopus.bind(conn:str, sch:str, tab:str,col:str,kind:int, 
low:oid, hgh:oid, version:int):bat[:oid,:any_1];
	s := remote.put(conn,sch);
	t := remote.put(conn,tab);
	c := remote.put(conn,col);
	k := remote.put(conn,kind);
	v := remote.put(conn,version);
	l := remote.put(conn,low);
	h := remote.put(conn,hgh);
	bh:= remote.put(conn,bind);
	bh:= remote.exec(conn,"sql","bind",s,t,c,k,l,h);
	b:bat[:oid,:any_1]:= remote.get(conn,bh);
	return bind:= b;
end octopus.bind;

function octopus.bind(conn:str, sch:str, tab:str,col:str,kind:int, 
version:int):bat[:oid,:any_1];
	s := remote.put(conn,sch);
	t := remote.put(conn,tab);
	c := remote.put(conn,col);
	k := remote.put(conn,kind);
	bh:= remote.put(conn,bind);
	bh:= remote.exec(conn,"sql","bind",s,t,c,k);
	b:bat[:oid,:any_1]:= remote.get(conn,bh);
	return bind:= b;
end octopus.bind;

function octopus.bind_dbat(sch:str, tab:str,access:int, version:int):bat[:oid,:any_1];
	b := sql.bind_dbat(sch,tab,access);
	return bind_dbat:= b;
end octopus.bind_dbat;

function octopus.bind_dbat(conn:str,sch:str, tab:str, access:int, version:int):bat[:oid,:oid];
	s := remote.put(conn,sch);
	t := remote.put(conn,tab);
	a := remote.put(conn,access);
	bh:= remote.put(conn,bind_dbat);
	bh:= remote.exec(conn,"sql","bind_dbat",s,t,a);
	b:bat[:oid,:oid]:= remote.get(conn,bh);
	
	return bind_dbat:= b;
end octopus.bind_dbat;

function octopus.bind_idxbat(sch:str, tab:str, index:str, access:int, version:int):bat[:oid,:any_1];
	b := sql.bind_idxbat(sch,tab,index,access);
	return bind_idxbat:= b;
end octopus.bind_idxbat;

function octopus.bind_idxbat(conn:str,sch:str, tab:str, index:str, access:int, version:int):bat[:oid,:oid];
	s := remote.put(conn,sch);
	t := remote.put(conn,tab);
	i := remote.put(conn,index);
	a := remote.put(conn,access);
	bh:= remote.put(conn,bind_idxbat);
	bh:= remote.exec(conn,"sql","bind_idxbat",s,t,i,a);
	b:bat[:oid,:oid]:= remote.get(conn,bh);
	
	return bind_idxbat:= b;
end octopus.bind_idxbat;

function octopus.getVariable(conn:str,name:str):any_1;
	s := remote.put(conn,name);
	bh:= remote.exec(conn,"sql","getVariable",s);
	b:any_1 := remote.get(conn,bh);
	return getVariable:= b;
end octopus.getVariable;

pattern rdfshred (location:str, gname:str)
address SQLrdfShred
comment "Procedure that wraps around the shredder of the rdf module in MAL. 
Shredding an RDF data file from location results in 7 new tables (6 
permutations of SPO and a mapping) in the RDF schema and an entry to table 
rdf.graph We can then query with SQL queries the RDF triple storeby quering 
tables gid_spo, gid_pso etc., where gid is looked up in rdf.graph"

command prelude()
address SQLprelude;

command epilogue()
address SQLepilogue;

sql.prelude();

include sql_bpm;


@h
#ifndef _SQL_H
#define _SQL_H

#include <sql_mem.h>

#ifdef WIN32
#ifndef LIBSQL
#define sql5_export extern __declspec(dllimport)
#else
#define sql5_export extern __declspec(dllexport)
#endif
#else
#define sql5_export extern
#endif

#include "sql_mvc.h"
#include <sql_backend.h>
#include <mal_session.h>

#include <mal_function.h>
#include <mal_stack.h>
#include <mal_interpreter.h>
#include <mal_session.h>
#include <tablet.h>
#include <streams.h>
#include <mtime.h>
#include <blob.h>
#include <mkey.h>
#include <str.h>
#include "sql_privileges.h"
#include "sql_semantic.h"
#include "sql_rel2bin.h"
#include <bin_optimizer.h>
#include "sql_decimal.h"
#include "sql_string.h"
#include "sql_qc.h"
#include "sql_env.h"
#include "sql_emptyset.h"

#include <bat/bat_storage.h>

@-
The back-end structure collects the information needed to support
compilation and execution of the SQL code against the Monet Version 5
back end. Note that the back-end can be called upon by the front-end
to handle specific tasks, such as catalog management (sql_mvc)
and query execution (sql_qc). For this purpose, the front-end needs
access to operations defined in the back-end, in particular for
freeing the stack and code segment.
@-
@h
typedef struct backend {
	int console;
	char language;		/* 'S' or 's' or 'X' */
	mvc *mvc;
	stream *out;
	Client client;
	sql_schema *currSchema;
	sql_table *currTable;
	sql_column *currColumn;
	sql_key *currKey;
	sql_idx *currIndex;
	int	vtop;		/* top of the variable stack before the current function */
	cq *q;			/* pointer to the cached query */
} backend;

extern backend *backend_reset(backend *b);
extern backend *backend_create(mvc *m, Client c);
extern void backend_destroy(backend *b);

extern int sqlcleanup(mvc *c, int err);
extern stmt *sql_symbol2stmt(mvc *c, symbol *sym);

extern BAT *mvc_bind(mvc *m, char *sname, char *tname, char *cname, int access);
extern BAT *mvc_bind_dbat(mvc *m, char *sname, char *tname, int access);
extern BAT *mvc_bind_idxbat(mvc *m, char *sname, char *tname, char *iname, int access);

sql5_export str SQLtransaction(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str SQLcommit(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str SQLrollback(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);

sql5_export str mvc_append_wrap(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str mvc_update_wrap(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str mvc_bind_single_wrap(int *ret, int *bid, str *name);
sql5_export str mvc_bind_wrap(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str mvc_bind_dbat_wrap(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str mvc_bind_idxbat_wrap(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str mvc_clear_table_wrap(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str mvc_delete_wrap(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str mvc_result_row_wrap(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str mvc_result_file_wrap(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str mvc_result_table_wrap(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str mvc_result_column_wrap(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str mvc_result_value_wrap(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);

sql5_export str mvc_declared_table_wrap(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str mvc_declared_table_column_wrap(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str mvc_drop_declared_table_wrap(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci );
sql5_export str mvc_drop_declared_tables_wrap(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci );

sql5_export str mvc_affected_rows_wrap(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str mvc_export_result_wrap(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str mvc_export_head_wrap(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str mvc_export_chunk_wrap(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str mvc_export_operation_wrap(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str mvc_export_value_wrap(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str mvc_import_table_wrap(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str mvc_bin_import_table_wrap(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str setVariable(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str getVariable(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str sql_variables(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str mvc_logfile(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str mvc_next_value(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str mvc_bat_next_value(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str mvc_get_value(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str mvc_diff_idxbat_wrap(bat *b, int *clientid, str *s, str *t, str *i, int *access, lng *oldversion, lng *version );
sql5_export str mvc_diff_dbat_wrap(bat *b, int *clientid, str *s, str *t, int *access, lng *oldversion, lng *version);
sql5_export str mvc_getVersion(lng *r, int *clientid);
sql5_export str mvc_restart_seq(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str zero_or_one(ptr ret, int *bid);
sql5_export str not_unique(bit *ret, int *bid);
sql5_export str not_unique_oids(bat *ret, bat *bid);
sql5_export str SQLcluster(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str SQLoctopusBind(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str SQLoctopusBinddbat(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str SQLargRecord(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str SQLrdfShred(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str month_interval_str( int *ret, str *s, int *ek, int *sk );
sql5_export str second_interval_str( lng *res, str *s, int *ek, int *sk );
sql5_export str dump_cache(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str dump_opt_stats(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str sql_rowid(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str sql_rank_grp(bat *rid, bat *bid, bat *gid, bat *gpe);
sql5_export str sql_rank(bat *rid, bat *bid);
sql5_export str sql_dense_rank_grp(bat *rid, bat *bid, bat *gid, bat *gpe);
sql5_export str sql_dense_rank(bat *rid, bat *bid);
@= round_export
sql5_export str @1_dec_round_wrap( @1 *res, @1 *v, @1 *r );
sql5_export str @1_round_wrap( @1 *res, @1 *v, int *d, int *s, bte *r );
sql5_export str str_2dec_@1( @1 *res, str *val, int *d, int *sc );
sql5_export str str_2num_@1( @1 *res, str *v, int *len );
sql5_export str batstr_2dec_@1( int *res, int *val, int *d, int *sc );
sql5_export str batstr_2num_@1( int *res, int *v, int *len );
@h
@:round_export(bte)@
@:round_export(sht)@
@:round_export(int)@
@:round_export(wrd)@
@:round_export(lng)@
@= cast_export
sql5_export str str_2_@1( @3 *res, str *val );
sql5_export str batstr_2_@1( int *res, int *val );
sql5_export str SQL@1_2_str( str *res, @1 *val );
@h
@:cast_export(bit,bitToStr,bit)@
@:cast_export(oid,OIDtoStr,oid)@
@:cast_export(bte,bteToStr,bte)@
@:cast_export(sht,shtToStr,sht)@
@:cast_export(int,intToStr,int)@
@:cast_export(lng,lngToStr,lng)@
@:cast_export(wrd,wrdToStr,wrd)@
@:cast_export(flt,fltToStr,flt)@
@:cast_export(dbl,dblToStr,dbl)@
@:cast_export(timestamp,timestamp_tostr,timestamp)@
@:cast_export(daytime,daytime_tostr,daytime)@
@:cast_export(date,date_tostr,date)@
@:cast_export(sqlblob,sqlblob_tostr,sqlblob*)@
sql5_export str SQLstr_cast(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
sql5_export str SQLbatstr_cast(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
@= fround_export
sql5_export str @1_dec_round_wrap( @1 *res, @1 *v, @1 *r );
sql5_export str @1_round_wrap( @1 *res, @1 *v, bte *r );
@h
@:fround_export(flt)@
@:fround_export(dbl)@
@= c_interval_export
sql5_export str month_interval_@1( int *ret, @1 *s, int *ek, int *sk );
sql5_export str second_interval_@1( lng *res, @1 *s, int *ek, int *sk );
@h
@:c_interval_export(bte)@
@:c_interval_export(sht)@
@:c_interval_export(int)@
@:c_interval_export(wrd)@
@:c_interval_export(lng)@
@:c_interval_export(daytime)@
@= simpleupcast_export
sql5_export str @2_2_@1( @1 *res, @2 *v );
sql5_export str bat@2_2_@1( int *res, int *v );
@= simpledowncast_export
sql5_export str @2_2_@1( @1 *res, @2 *v );
sql5_export str bat@2_2_@1( int *res, int *v );
@= numcastup_export
@:simpledowncast_export(@1,@2)@
sql5_export str @2_dec2_@1( @1 *res, int *s1, @2 *v );
sql5_export str @2_dec2dec_@1( @1 *res, int *S1, @2 *v, int *d2, int *S2 );
sql5_export str @2_num2dec_@1( @1 *res, @2 *v, int *d2, int *s2 );
sql5_export str bat@2_dec2_@1( int *res, int *s1, int *v );
sql5_export str bat@2_dec2dec_@1( int *res, int *S1, int *v, int *d2, int *S2 );
sql5_export str bat@2_num2dec_@1( int *res, int *v, int *d2, int *s2 );
@h
@:numcastup_export(bte,bte)@
@:numcastup_export(sht,bte)@
@:numcastup_export(sht,sht)@
@:numcastup_export(int,bte)@
@:numcastup_export(int,sht)@
@:numcastup_export(int,int)@
@:numcastup_export(wrd,bte)@
@:numcastup_export(wrd,sht)@
@:numcastup_export(wrd,int)@
@:numcastup_export(wrd,wrd)@
@:numcastup_export(lng,bte)@
@:numcastup_export(lng,sht)@
@:numcastup_export(lng,int)@
@:numcastup_export(lng,wrd)@
@:numcastup_export(lng,lng)@
@= fnumcastdown_export
@:simpledowncast_export(@1,@2)@
sql5_export str @2_num2dec_@1( @1 *res, @2 *v, int *d2, int *s2 );
sql5_export str bat@2_num2dec_@1( int *res, int *v, int *d2, int *s2 );
@h
@:fnumcastdown_export(bte,flt)@
@:fnumcastdown_export(sht,flt)@
@:fnumcastdown_export(int,flt)@
@:fnumcastdown_export(wrd,flt)@
@:fnumcastdown_export(lng,flt)@
@:fnumcastdown_export(bte,dbl)@
@:fnumcastdown_export(sht,dbl)@
@:fnumcastdown_export(int,dbl)@
@:fnumcastdown_export(wrd,dbl)@
@:fnumcastdown_export(lng,dbl)@
@= fnumcastup_export
@:simpleupcast_export(@1,@2)@
sql5_export str @2_dec2_@1( @1 *res, int *s1, @2 *v );
sql5_export str @2_dec2dec_@1( @1 *res, int *S1, @2 *v, int *d2, int *S2 );
sql5_export str @2_num2dec_@1( @1 *res, @2 *v, int *d2, int *s2 );
sql5_export str bat@2_dec2_@1( int *res, int *s1, int *v );
sql5_export str bat@2_dec2dec_@1( int *res, int *S1, int *v, int *d2, int *S2 );
sql5_export str bat@2_num2dec_@1( int *res, int *v, int *d2, int *s2 );
@h
@:fnumcastup_export(flt,bte)@
@:fnumcastup_export(flt,sht)@
@:fnumcastup_export(flt,int)@
@:fnumcastup_export(flt,wrd)@
@:fnumcastup_export(flt,lng)@
@:fnumcastup_export(dbl,bte)@
@:fnumcastup_export(dbl,sht)@
@:fnumcastup_export(dbl,int)@
@:fnumcastup_export(dbl,wrd)@
@:fnumcastup_export(dbl,lng)@
@= numcastdown_export
@:simpledowncast_export(@1,@2)@
sql5_export str @2_dec2_@1( @1 *res, int *s1, @2 *v );
sql5_export str @2_dec2dec_@1( @1 *res, int *S1, @2 *v, int *d2, int *S2 );
sql5_export str @2_num2dec_@1( @1 *res, @2 *v, int *d2, int *s2 );
sql5_export str bat@2_dec2_@1( int *res, int *s1, int *v );
sql5_export str bat@2_dec2dec_@1( int *res, int *S1, int *v, int *d2, int *S2 );
sql5_export str bat@2_num2dec_@1( int *res, int *v, int *d2, int *s2 );
@h
@:numcastdown_export(bte,sht)@
@:numcastdown_export(bte,int)@
@:numcastdown_export(bte,wrd)@
@:numcastdown_export(bte,lng)@
@:numcastdown_export(sht,int)@
@:numcastdown_export(sht,wrd)@
@:numcastdown_export(sht,lng)@
@:numcastdown_export(int,wrd)@
@:numcastdown_export(int,lng)@
@:numcastdown_export(wrd,lng)@

sql5_export str getContext(Client cntxt, MalBlkPtr mb, mvc **c, backend **b );

#endif /* _SQL_H */

@-
First introduce the routines to be called by the front-end.
@c
#include "sql_config.h"
#include "sql.h"
#include "sql_result.h"
#include "sql_gencode.h"
#include <sql_storage.h>
#include <sql_scenario.h>
#include <store_sequence.h>
#include <sql_optimizer.h>
#include <sql_datetime.h>
#include <rel_optimizer.h>
#include <rel_select.h>
#include <rel_dump.h>
#include <rel_bin.h>
#include <math.h>
#include <cluster.h>
#ifdef HAVE_MONETDB5_RDF
	#include <rdf/rdf.h>
#endif

backend *
backend_reset(backend *b)
{
	b->out = b->client->fdout;
	b->language = 0;

	b->currSchema = NULL;
	b->currTable = NULL;
	b->currColumn = NULL;
	b->currKey = NULL;
	b->currIndex = NULL;
	b->vtop = 0;
	b->q = NULL;
	return b;
}

backend *
backend_create(mvc *m, Client c)
{
	backend *b = NEW(backend);

	b->console = isAdministrator(c);
	b->mvc = m;
	b->client = c;
	return backend_reset(b);
}

void
backend_destroy(backend *b)
{
	_DELETE(b);
}

@-
Stuff copied from the Monet 4 back end
Lookup the statement associated with a specific identifier
from the statement cache. Compile and optimize it for later
consumption, e.g. display
@c
stmt *
sql_symbols2stmt(mvc *c, symbol *s) 
{
	dnode *d;
	list *l = create_stmt_list();

	for (d = s->data.lval->h; d; d = d->next) {
		symbol *sym = d->data.sym;
		stmt *st = sql_symbol2stmt(c, sym);

		if (!st) {
			list_destroy(l);
			return NULL;
		}
		list_append(l, st);
	}
	return stmt_list(l);
}

stmt *
sql_symbol2stmt(mvc *c, symbol *sym)
{
	stmt *s = NULL;
	int status;
	sql_rel *r;

	if (sym->token == SQL_MULSTMT) 
		return sql_symbols2stmt(c, sym);

	status = c->session->status;
	r = rel_semantic(c, sym);
	if (!r) {
		if (c->errstr[0]) {
			return NULL;
		} else {
			c->session->status = status;
			/*printf("# falling back to direct mode \n");*/
			s = output_semantic(c, sym);
		}
	} else {
		r = rel_optimizer(c, r);
		if (c->emode == m_plan) {
			rel_print(c, r, 0);
		} else {
			s = output_rel_bin(c, r);
		}
		rel_destroy(r);
		if (s) {
			stmt *opt;

			/* only needed for delta tables */
			opt = rel2bin(c, s); 	
			stmt_destroy(s);
			s = bin_optimizer(c, opt);
			stmt_destroy(opt);
			return s;
		}
	}

	if (s){
		stmt *opt;

		if (mvc_debug_on(c,128)) 
			stmt2dot(s, 1, "/tmp/g1.dot");
		opt = rel2bin(c, s);
		stmt_destroy(s);
		s = opt;
		if (mvc_debug_on(c,128)) 
			stmt2dot(s, 2, "/tmp/g2.dot");
		opt = bin_optimizer(c, s);
		stmt_destroy(s);
		s = opt;
		if (mvc_debug_on(c,128)) 
			stmt2dot(s, 3, "/tmp/g3.dot");
	}
	return s;
}

@-
After the SQL statement has been executed, its data structures
should be garbage collected. For successful actions we have to finish
the transaction as well, e.g. commit or rollback.
@c
int
sqlcleanup(mvc *c, int err)
{
	sql_destroy_params(c);
	sql_destroy_args(c);

	/* some statements dynamically disable caching */
	c->sym = NULL;
	if (c->sa) 
		c->sa = sa_reset(c->sa);
	if (err > 0)
		c->session->status = -err;
	if (err < 0)
		c->session->status = err;
	scanner_query_processed(&(c->scanner));
	return err;
}

@-
The internal administration of the SQL compilation and execution state
is administered by a state descriptor accessible in each phase.
Failure to find the state descriptor aborts the session.

@c
str 
getContext(Client cntxt, MalBlkPtr mb, mvc **c, backend **b )
{
	(void)mb;
	if (cntxt == NULL ) 
		throw(SQL, "mvc","No client record");
	if (cntxt->state[MAL_SCENARIO_PARSER] == NULL || cntxt->state[MAL_SCENARIO_OPTIMIZE] == NULL)
		throw(SQL, "mvc","SQL module not initialized");
	*c = ((mvc *) cntxt ->state[MAL_SCENARIO_OPTIMIZE]); 
	if (*c == 0)
		throw(SQL, "mvc","SQL module not initialized, mvc struct missing");
	if (b)
		*b = ((backend*) cntxt->state[MAL_SCENARIO_PARSER]);
	if (b && *b == 0)
		throw(SQL, "mvc","SQL module not initialized, backend struct missing");
	return MAL_SUCCEED;
}

str
SQLtransaction(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	mvc *m = NULL;
	str msg = getContext(cntxt,mb, &m, NULL);

	(void) cntxt;
	(void) stk;
	(void) pci;
	if (msg)
		return msg;
	mvc_trans(m);
	return MAL_SUCCEED;
}

str
SQLcommit(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	mvc *m = NULL;
	str msg = getContext(cntxt,mb, &m, NULL);

	(void) cntxt;
	(void) stk;
	(void) pci;
	if (msg)
		return msg;
	mvc_commit(m, 0, NULL); /* keep the changes */
	return MAL_SUCCEED;
}
str
SQLrollback(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	mvc *m=NULL;
	str msg = getContext(cntxt,mb, &m, NULL);

	(void) cntxt;
	(void) stk;
	(void) pci;
	if (msg)
		return msg;
	mvc_rollback(m, 0, NULL); /* keep the changes */
	return MAL_SUCCEED;
}

/* setVariable(int *ret, str *name, any value) */
str
setVariable(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	char buf[BUFSIZ];
	mvc *m = NULL;
	int mtype = getArgType(mb, pci, 2);
	str varname   = *(str *) getArgReference(stk, pci, 1);
	str msg = getContext(cntxt,mb, &m, NULL);
	ValRecord *src;

	(void) cntxt;
	if (msg)
		return msg;

	if (mtype < 0 || mtype >= 255)
		throw(SQL, "sql.setVariable", "failed");
	if ( strcmp("optimizer",  varname)== 0) {
		msg = setOptimizers(*(str *) getArgReference(stk,pci,2));
		if ( msg != NULL &&  strcmp(msg,"default_pipe") == 0 && strcmp(msg,varname))
			return MAL_SUCCEED;
		msg = SQLvalidatePipeline();
		if ( msg ){
			setOptimizers("default_pipe");
			return msg;
		}
	}
	src = &stk->stk[getArg(pci, 2)];
	if (stack_find_var(m, varname)) {
		stack_set_var(m, varname, src);
	} else {
		snprintf(buf, BUFSIZ, "variable '%s' unknown", varname);
		throw(SQL, "sql.setVariable", buf);
	}
	if ((msg = sql_update_var(m, varname)) != NULL) {
		snprintf(buf, BUFSIZ, "%s", msg);
		_DELETE(msg);
		throw(SQL, "sql.setVariable", buf);
	}
	return MAL_SUCCEED;
}

/* getVariable(int *ret, str *name) */
str
getVariable(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	mvc *m = NULL;
	int mtype = getArgType(mb, pci, 0);
	str varname   = *(str *) getArgReference(stk, pci, 1);
	str msg = getContext(cntxt,mb, &m, NULL);
	ValRecord *dst, *src;

	(void) cntxt;
	if (msg)
		return msg;

	if (mtype < 0 || mtype >= 255)
		throw(SQL, "sql.getVariable", "failed");
	src = stack_get_var(m, varname);
	if (!src) {
		char buf[BUFSIZ];
		snprintf(buf, BUFSIZ, "variable '%s' unknown", varname);
		throw(SQL, "sql.getVariable", buf);
	}
	dst = &stk->stk[getArg(pci, 0)];
	VALcopy(dst,src);
	return MAL_SUCCEED;
}

str
sql_variables(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	int i;
	mvc *m = NULL;
	BAT *vars, *r; 
	str msg = getContext(cntxt,mb, &m, NULL);
	int *res = (int *) getArgReference(stk, pci, 0);

	(void) cntxt;
	if (msg)
		return msg;

	vars = BATnew(TYPE_void,TYPE_str, m->topvars);
	BATseqbase(vars, 0);
	for (i=0; i<m->topvars && m->vars[i].s; i++) 
		BUNappend(vars, m->vars[i].name, FALSE);
	r = BATnew(TYPE_str,TYPE_bat,1);
	BUNins(r, "name", &vars->batCacheid, FALSE);
	BBPunfix(vars->batCacheid);
	*res = r->batCacheid;
	BBPkeepref(r->batCacheid);
	return MAL_SUCCEED;
}

/* str mvc_logfile(int *d, str *filename); */
str
mvc_logfile(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	mvc *m = NULL;
	str msg = getContext(cntxt,mb, &m, NULL);
	int *res = (int *) getArgReference(stk, pci, 0);
	str filename = *(str *)getArgReference(stk, pci, 1);

	(void) cntxt;
	if (msg)
		return msg;
	if (m->scanner.log) {
		close_stream(m->scanner.log);
		m->scanner.log = NULL;
	}

	if (filename != str_nil) 
		m->scanner.log = open_wastream(filename);
	*res = 0;
	return MAL_SUCCEED;
}

/* str mvc_next_value(lng *res, str *sname, str *seqname); */
str
mvc_next_value(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	mvc *m = NULL;
	str msg = getContext(cntxt,mb, &m, NULL);
	sql_schema *s;
	lng *res  = (lng *) getArgReference(stk, pci, 0);
	str *sname  = (str *) getArgReference(stk, pci, 1);
	str *seqname  = (str *) getArgReference(stk, pci, 2);

	(void) cntxt;
	if (msg)
		return msg;
 	s = mvc_bind_schema(m, *sname);
	if (s) {
		sql_sequence *seq = find_sql_sequence(s, *seqname);

		if (seq && seq_next_value(seq, res)) {
			m->last_id = *res;
			stack_set_number(m, "last_id", m->last_id);
			return MAL_SUCCEED;
		}
	}
	throw(SQL, "sql.next_value", "error");
}

/* str mvc_bat_next_value(bat *res, int *sid, str *seqname); */
str
mvc_bat_next_value(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	mvc *m = NULL;
	str msg = getContext(cntxt,mb, &m, NULL);
	BAT *b, *r;
	BUN p,q;
	sql_schema *s = NULL;
	sql_sequence *seq = NULL;
	seqbulk *sb = NULL;
	BATiter bi;
	bat *res  = (bat *) getArgReference(stk, pci, 0);
	int *sid  = (int *) getArgReference(stk, pci, 1);
	str *seqname  = (str *) getArgReference(stk, pci, 2);

	(void) cntxt;
	if (msg)
		return msg;

	if( (b = BATdescriptor(*sid)) == NULL )
		throw(SQL, "sql.next_value", "Cannot access descriptor");

	r = BATnew(b->htype, TYPE_lng, BATcount(b));
	if (!r) {
		BBPunfix(b->batCacheid);
		throw(SQL, "sql.next_value", "Cannot create bat");
	}
	BATseqbase(r, b->hseqbase);

	if (!BATcount(b)) {
		BBPunfix(b->batCacheid);
		BBPkeepref(r->batCacheid);
		*res = r->batCacheid;
		return MAL_SUCCEED;
	}

	bi = bat_iterator(b);
	BATloop(b,p,q){
		str sname = BUNtail(bi,BUNfirst(b));
		lng l;

		if (!s || strcmp(s->base.name, sname) != 0) {
			if (sb)
				seqbulk_destroy(sb);
			s = mvc_bind_schema(m, sname);
			seq = NULL;
			if (!s || 
			    (seq = find_sql_sequence(s, *seqname)) == NULL ||
			    !(sb = seqbulk_create(seq, BATcount(b))) ) {
				BBPunfix(b->batCacheid);
				BBPunfix(r->batCacheid);
				throw(SQL, "sql.next_value", "error");
			}
		}
		if (!seqbulk_next_value(sb, &l)) {
			BBPunfix(b->batCacheid);
			BBPunfix(r->batCacheid);
			seqbulk_destroy(sb);
			throw(SQL, "sql.next_value", "error");
		}
		BUNins(r, BUNhead(bi,p), &l, FALSE);
	}
	if (sb) 
		seqbulk_destroy(sb);
	BBPunfix(b->batCacheid);
	BBPkeepref(r->batCacheid);
	*res = r->batCacheid;
	return MAL_SUCCEED;
}

/* str mvc_get_value(lng *res, str *sname, str *seqname); */
str
mvc_get_value(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	mvc *m = NULL;
	str msg = getContext(cntxt,mb, &m, NULL);
	sql_schema *s;
	lng *res  = (lng *) getArgReference(stk, pci, 0);
	str *sname  = (str *) getArgReference(stk, pci, 1);
	str *seqname  = (str *) getArgReference(stk, pci, 2);

	(void) cntxt;
	if (msg)
		return msg;
 	s = mvc_bind_schema(m, *sname);
	if (s) {
		sql_sequence *seq = find_sql_sequence(s, *seqname);

		if (seq && seq_get_value(seq, res))
			return MAL_SUCCEED;
	}
	throw(SQL, "sql.get_value", "error");
}

str
mvc_getVersion(lng *version, int *clientid)
{
	mvc *m = NULL;
	Client cntxt = mal_clients+*clientid;
	str msg = getContext(cntxt, NULL, &m, NULL);

	if (msg)
		return msg;
	*version = -1;
	if (m->session->tr)
		*version = m->session->tr->stime;
	return MAL_SUCCEED;
}

/* str mvc_restart_seq(lng *res, str *sname, str *seqname, lng *start); */
str
mvc_restart_seq(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	mvc *m = NULL;
	str msg = getContext(cntxt,mb, &m, NULL);
	sql_schema *s;
	lng *res  = (lng *) getArgReference(stk, pci, 0);
	str *sname  = (str *) getArgReference(stk, pci, 1);
	str *seqname  = (str *) getArgReference(stk, pci, 2);
	lng *start  = (lng *) getArgReference(stk, pci, 3);

	(void) cntxt;
	if (msg)
		return msg;
 	s = mvc_bind_schema(m, *sname);
	if (s) {
		sql_sequence *seq = find_sql_sequence(s, *seqname);

		if (seq) {
			*res = sql_trans_sequence_restart(m->session->tr, seq, *start);
			return MAL_SUCCEED;
		}
	}
	throw(SQL, "sql.restart", "error");
}



BAT *
mvc_bind(mvc *m, char *sname, char *tname, char *cname, int access)
{
	sql_trans *tr = m->session->tr;
	BAT *b = NULL;
	sql_schema *s = NULL;
	sql_table *t = NULL;
	sql_column *c = NULL;

	s = mvc_bind_schema(m, sname);
	if ( s == NULL) 
		return NULL;
	t = mvc_bind_table(m, s, tname);
	if ( t == NULL) 
		return NULL;
	c = mvc_bind_column(m, t, cname);
	if ( c == NULL) 
		return NULL;

	b = store_funcs.bind_col(tr, c, access);
	return b;
}

BAT *
mvc_bind_dbat(mvc *m, char *sname, char *tname, int access)
{
	sql_trans *tr = m->session->tr;
	BAT *b = NULL;
	sql_schema *s = NULL;
	sql_table *t = NULL;
	s = mvc_bind_schema(m, sname);
	if ( s == NULL)
		return NULL;
	t = mvc_bind_table(m, s, tname);
	if ( t == NULL)
		return NULL;

	b = store_funcs.bind_del(tr, t, access);
	return b;
}

BAT *
mvc_bind_idxbat(mvc *m, char *sname, char *tname, char *iname, int access)
{
	sql_trans *tr = m->session->tr;
	BAT *b = NULL;
	sql_schema *s = mvc_bind_schema(m, sname);
	sql_idx *i = mvc_bind_idx(m, s, iname);

	(void) tname;
	b = store_funcs.bind_idx(tr, i, access);
	return b;
}

/* str mvc_bind_wrap(int *bid, str *sname, str *tname, str *cname, int *access); */
str
mvc_bind_wrap(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	BAT *b = NULL, *bn;
	mvc *m = NULL;
	str msg = getContext(cntxt,mb, &m, NULL);
	int *bid = (int *)getArgReference(stk, pci, 0);
	str *sname = (str *)getArgReference(stk, pci, 1);
	str *tname = (str *)getArgReference(stk, pci, 2);
	str *cname = (str *)getArgReference(stk, pci, 3);
	int *access = (int *)getArgReference(stk, pci, 4);
	oid lval,hval=0;

	(void) cntxt;
	if (msg)
		return msg;
	b = mvc_bind(m, *sname, *tname, *cname, *access);
	if (b) {
		if ( pci->argc == 7){
			/* partitioned access */
			lval = *(oid *)getArgReference(stk, pci, 5);
			hval = *(oid *)getArgReference(stk, pci, 6);
			bn =  BATslice(b, lval,hval);
			BATseqbase(bn, lval);
			BBPreleaseref(b->batCacheid);
			b= bn;
		}
		BBPkeepref( *bid = b->batCacheid);
		return MAL_SUCCEED;
	}
	throw(SQL, "sql.bind", "unable to find %s.%s(%s)", *sname, *tname, *cname);
}


/* str mvc_bind_idxbat_wrap(int *bid, str *sname, str *tname, str *iname, int *access); */
str
mvc_bind_idxbat_wrap(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	BAT *b = NULL,*bn;
	mvc *m = NULL;
	str msg = getContext(cntxt,mb, &m, NULL);
	int *bid = (int *)getArgReference(stk, pci, 0);
	str *sname = (str *)getArgReference(stk, pci, 1);
	str *tname = (str *)getArgReference(stk, pci, 2);
	str *iname = (str *)getArgReference(stk, pci, 3);
	int *access = (int *)getArgReference(stk, pci, 4);
	oid lval,hval=0;

	(void) cntxt;
	if (msg)
		return msg;
	b = mvc_bind_idxbat(m, *sname, *tname, *iname, *access);
	if (b) {
		if ( pci->argc == 7){
			/* partitioned access */
			lval = *(oid *)getArgReference(stk, pci, 5);
			hval = *(oid *)getArgReference(stk, pci, 6);
			bn =  BATslice(b, lval,hval);
			BATseqbase(bn, lval);
			BBPreleaseref(b->batCacheid);
			b= bn;
		}
		BBPkeepref( *bid = b->batCacheid);
		return MAL_SUCCEED;
	}
	throw(SQL, "sql.idxbind", "unable to find index %s for %s.%s",
			*iname, *sname, *tname);
}

str 
mvc_diff_idxbat_wrap(bat *bid, int *clientid, str *s, str *t, str *i, int *access, lng *oldversion, lng *version)
{
	mvc *m = NULL;
	Client cntxt = mal_clients+*clientid;
	str msg = getContext(cntxt, NULL, &m, NULL);
	BAT *b;

	if (msg)
		return msg;
	(void)oldversion;
	(void)version;
	b = mvc_bind(m, *s, *t, *i, *access);
	if (b) {
		BBPkeepref( *bid = b->batCacheid);
		return MAL_SUCCEED;
	}
	throw(SQL, "sql.idxbind", "unable to find index %s for %s.%s", *i, *s, *t);
}

/*mvc_append_wrap(int *bid, str *sname, str *tname, str *cname, ptr d) */
str
mvc_append_wrap(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	mvc *m = NULL;
	str msg = getContext(cntxt,mb, &m, NULL);
	str sname = *(str *)getArgReference(stk, pci, 1);
	str tname = *(str *)getArgReference(stk, pci, 2);
	str cname = *(str *)getArgReference(stk, pci, 3);
	ptr ins = (ptr)getArgReference(stk, pci, 4);
	int tpe = getArgType(mb, pci, 4);

	sql_schema *s;
	sql_table *t;
	sql_column *c;

	(void) cntxt;
	if (msg)
		return msg;

	if (tpe > TYPE_any)
		tpe = TYPE_bat;
	if (tpe == TYPE_bat && (ins = BATdescriptor(*(int*)ins)) == NULL) 
		throw(SQL, "sql.append","Cannot access descriptor");
	if (ATOMextern(tpe)) 
		ins = *(ptr*)ins;
	s = mvc_bind_schema(m, sname);
	if ( s == NULL)
		throw(MAL,"sql.append","Schema missing");
	t = mvc_bind_table(m, s, tname);
	if ( t == NULL)
		throw(MAL,"sql.append","Table missing");
	c = mvc_bind_column(m, t, cname);
	if (c) {
		store_funcs.append_col(m->session->tr, c, ins, tpe);
	} else {
		sql_idx *i = mvc_bind_idx(m, s, cname);
		if (i)
			store_funcs.append_idx(m->session->tr, i, ins, tpe);
	}
	if (tpe == TYPE_bat)
		BBPunfix(((BAT*)ins)->batCacheid);
	return MAL_SUCCEED;
}

/*mvc_update_wrap(int *bid, str *sname, str *tname, str *cname, ptr d) */
str
mvc_update_wrap(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	mvc *m = NULL;
	str msg = getContext(cntxt,mb, &m, NULL);
	str sname = *(str *)getArgReference(stk, pci, 1);
	str tname = *(str *)getArgReference(stk, pci, 2);
	str cname = *(str *)getArgReference(stk, pci, 3);
	ptr ins = (ptr)getArgReference(stk, pci, 4);
	int tpe = getArgType(mb, pci, 4);

	sql_schema *s;
	sql_table *t;
	sql_column *c;

	(void) cntxt;
	if (msg)
		return msg;

	if (tpe > TYPE_any)
		tpe = TYPE_bat;
	if( tpe == TYPE_bat && (ins = BATdescriptor(*(int*)ins)) == NULL) 
		throw(SQL, "sql.update","Cannot access descriptor");
	if (ATOMextern(tpe)) 
		ins = *(ptr*)ins;
	s = mvc_bind_schema(m, sname);
	if ( s == NULL)
		throw(MAL,"sql.update","Schema missing");
	t = mvc_bind_table(m, s, tname);
	if ( t == NULL)
		throw(MAL,"sql.update","Table missing");
	c = mvc_bind_column(m, t, cname);
	if (c) {
		store_funcs.update_col(m->session->tr, c, ins, tpe, 0);
	} else {
 		sql_idx *i = mvc_bind_idx(m, s, cname);
		if (i)
			store_funcs.update_idx(m->session->tr, i, ins, tpe);
	}
	if (tpe == TYPE_bat)
		BBPunfix(((BAT*)ins)->batCacheid);
	return MAL_SUCCEED;
}

@-
Monet 5 extension 
@-
The Mx macro below is used in many places throughout the code base to
access the BAT descriptor.

@= chkIdentifier
	/* generate exception if string is not an identifier */
	if( isIdentifier(@1))
		throw(SQL,  "@4","identifier expected");
@= Pseudo
	if (BBPindex("@1_@2_@3") <= 0)
		BATname(b, "@1_@2_@3");
	BATroles(b,"@1","@2");
	BATmode(b,TRANSIENT);
	BATfakeCommit(b);
	*ret = b->batCacheid;

@c

str
mvc_bind_single_wrap(int *ret, int *bid, str *name)
{
	BAT *b, *bn;
	int r;
	BUN p;
	BATiter bni;

	if( (bn= BATdescriptor(*bid)) == NULL)
		throw(SQL, "sql.bind","Cannot access descriptor");

	p = BUNfnd(bn, *name);
	bni = bat_iterator(bn);
	r = *(int *) BUNtail(bni, p);
	if( (b= BATdescriptor(r)) == NULL)
		throw(SQL, "sql.bind","Cannot access descriptor");
	BBPkeepref(*ret= b->batCacheid);
	BBPunfix( bn->batCacheid);
	return MAL_SUCCEED;
}

/* str mvc_bind_dbat_wrap(int *ret, str *sname, str *tname, int *access); */
str
mvc_bind_dbat_wrap(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	BAT *b;
	mvc *m = NULL;
	str msg = getContext(cntxt,mb, &m, NULL);
	int *ret = (int *)getArgReference(stk, pci, 0);
	str *sname = (str *)getArgReference(stk, pci, 1);
	str *tname = (str *)getArgReference(stk, pci, 2);
	int *access = (int*)getArgReference(stk, pci, 3);

	(void) cntxt;
	if (msg)
		return msg;
	b = mvc_bind_dbat(m, *sname, *tname, *access);
	if (b) {
		BBPkeepref( *ret = b->batCacheid);
		return MAL_SUCCEED;
	}
	throw(SQL, "mvc_bind_dbat_wrap", "error");
}

str 
mvc_diff_dbat_wrap(bat *bid, int *clientid, str *s, str *t, int *access, lng *oldversion, lng *version )
{
	mvc *m = NULL;
	Client cntxt = mal_clients+*clientid;
	str msg = getContext(cntxt, NULL, &m, NULL);
	BAT *b;

	if (msg)
		return msg;
	(void)oldversion;
	(void)version;
	b = mvc_bind_dbat(m, *s, *t, *access);
	if (b) {
		BBPkeepref( *bid = b->batCacheid);
		return MAL_SUCCEED;
	}
	throw(SQL, "mvc_bind_dbat_wrap", "error");
}

/* str mvc_clear_table_wrap(wrd *res, str *sname, str *tname); */
str
mvc_clear_table_wrap(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	sql_schema *s;
	sql_table *t;
	mvc *m = NULL;
	str msg = getContext(cntxt,mb, &m, NULL);
	wrd *res = (wrd *)getArgReference(stk, pci, 0);
	str *sname = (str *)getArgReference(stk, pci, 1);
	str *tname = (str *)getArgReference(stk, pci, 2);

	(void) cntxt;
	if (msg)
		return msg;
	s = mvc_bind_schema(m, *sname);
	if ( s == NULL)
		throw(MAL,"sql.clear_table","Schema missing");
	t = mvc_bind_table(m, s, *tname);
	if ( t == NULL)
		throw(MAL,"sql.clear_table","Table missing");
	*res = mvc_clear_table(m, t);
	return MAL_SUCCEED;
}

/*mvc_delete_wrap(int *d, str *sname, str *tname, ptr d) */
str
mvc_delete_wrap(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	mvc *m = NULL;
	str msg = getContext(cntxt,mb, &m, NULL);
	str sname = *(str *)getArgReference(stk, pci, 1);
	str tname = *(str *)getArgReference(stk, pci, 2);
	ptr ins = (ptr)getArgReference(stk, pci, 3);
	int tpe = getArgType(mb, pci, 3);
	BAT *b = NULL;

	sql_schema *s;
	sql_table *t;

	(void) cntxt;
	if (msg)
		return msg;

	if (tpe > TYPE_any)
		tpe = TYPE_bat;
	if (tpe == TYPE_bat && (b = BATdescriptor(*(int*)ins)) == NULL) 
		throw(SQL, "sql.delete","Cannot access descriptor");
	if (tpe != TYPE_bat || (b->ttype != TYPE_oid && b->ttype != TYPE_void))
		throw(SQL, "sql.delete","Cannot access descriptor");
	s = mvc_bind_schema(m, sname);
	if ( s == NULL)
		throw(MAL,"sql.delete","Schema missing");
	t = mvc_bind_table(m, s, tname);
	if ( t == NULL)
		throw(MAL,"sql.delete","Table missing");
	store_funcs.delete_tab(m->session->tr, t, b, tpe);
	if (tpe == TYPE_bat)
		BBPunfix(((BAT*)ins)->batCacheid);
	return MAL_SUCCEED;
}

static int
mvc_result_row(mvc *m, int nr_cols, int qtype)
{
	m->results = res_table_create(m->session->tr, m->result_id++, nr_cols, qtype, m->results, NULL);
	return m->results->id;
}

/* str mvc_result_row_wrap(int *res_id, int *nr_cols, int *qtype, int *o); */
str
mvc_result_row_wrap(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	mvc *m = NULL;
	str msg = getContext(cntxt,mb, &m, NULL);
	int *res_id = (int *)getArgReference(stk, pci, 0);
	int *nr_cols = (int *)getArgReference(stk, pci, 1);
	int *qtype = (int *)getArgReference(stk, pci, 2);
	int *o = (int *)getArgReference(stk, pci, 3);

	(void) cntxt;
	if (msg)
		return msg;
	(void)o; /* dummy order */
	*res_id = mvc_result_row(m, *nr_cols, *qtype); 
	if (*res_id < 0)
		throw(SQL, "sql.resultSet", "failed");
	return MAL_SUCCEED;
}

/* str mvc_result_file_wrap(int *res_id, int *nr_cols, unsigned char* *T, unsigned char* *R, unsigned char* *S, unsigned char* *N, bat *order_bid); */
str 
mvc_result_file_wrap(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	str res = MAL_SUCCEED;
	BAT *order = NULL;
	mvc *m = NULL;
	str msg = getContext(cntxt,mb, &m, NULL);
	res_table *t = NULL;
	unsigned char *tsep = NULL, *rsep = NULL, *ssep = NULL, *ns = NULL;
	ssize_t len;
	int *res_id = (int *)getArgReference(stk, pci, 0);
	int *nr_cols = (int *)getArgReference(stk, pci, 1);
	unsigned char **T = (unsigned char **)getArgReference(stk, pci, 2);
	unsigned char **R = (unsigned char **)getArgReference(stk, pci, 3);
	unsigned char **S = (unsigned char **)getArgReference(stk, pci, 4);
	unsigned char **N = (unsigned char **)getArgReference(stk, pci, 5);
	int mtype = getArgType(mb, pci, 6);

	(void) cntxt;
	if (msg)
		return msg;
	if (isaBatType(mtype)) {
		bat *order_bid = (bat *)getArgReference(stk, pci, 6);
        	if ((order = BATdescriptor(*order_bid)) == NULL ) {
               		throw(SQL, "sql.resultSet", "Cannot access descriptor");
        	}
	}
	m->results = t = res_table_create(m->session->tr, m->result_id++, *nr_cols, Q_TABLE, m->results, order);
	len = strlen((char*)(*T));
	GDKstrFromStr(tsep=GDKmalloc(len+1), *T, len); len = 0;
	len = strlen((char*)(*R));
	GDKstrFromStr(rsep=GDKmalloc(len+1), *R, len); len = 0;
	len = strlen((char*)(*S));
	GDKstrFromStr(ssep=GDKmalloc(len+1), *S, len); len = 0;
	len = strlen((char*)(*N));
	GDKstrFromStr(ns=GDKmalloc(len+1), *N, len); len = 0;
	t->tsep = (char*)tsep;
	t->rsep = (char*)rsep;
	t->ssep = (char*)ssep;
	t->ns = (char*)ns;
	*res_id = t->id;
	if (*res_id < 0)
		res = createException(SQL, "sql.resultSet", "failed");
	if (order)
		BBPunfix(order->batCacheid);
	return res;
}

/* str mvc_result_table_wrap(int *res_id, int *nr_cols, int *qtype, bat *order_bid); */
str
mvc_result_table_wrap(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	str res = MAL_SUCCEED;
	BAT *order;
	mvc *m = NULL;
	str msg = getContext(cntxt,mb, &m, NULL);
	int *res_id = (int *)getArgReference(stk, pci, 0);
	int *nr_cols = (int *)getArgReference(stk, pci, 1);
	int *qtype = (int *)getArgReference(stk, pci, 2);
	bat *order_bid = (bat *)getArgReference(stk, pci, 3);

	(void) cntxt;
	if (msg)
		return msg;
        if ((order = BATdescriptor(*order_bid)) == NULL ) {
                throw(SQL, "sql.resultSet", "Cannot access descriptor");
        }
	*res_id = mvc_result_table(m, *nr_cols, *qtype, order);
	if (*res_id < 0)
		res= createException(SQL, "sql.resultSet", "failed");
	BBPunfix(order->batCacheid);
	return res;
}

/* str mvc_result_column_wrap(int *ret, int *rs, str *tn, str *name, str *type, int *digits, int *scale, bat *bid); */
str
mvc_result_column_wrap(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	str res = MAL_SUCCEED;
	BAT *b;
	mvc *m = NULL;
	str msg = getContext(cntxt,mb, &m, NULL);
	int *ret = (int *)getArgReference(stk, pci, 0);
	str *tn = (str *)getArgReference(stk, pci, 2);
	str *name = (str *)getArgReference(stk, pci, 3);
	str *type = (str *)getArgReference(stk, pci, 4);
	int *digits = (int *)getArgReference(stk, pci, 5);
	int *scale = (int *)getArgReference(stk, pci, 6);
	bat *bid = (bat *)getArgReference(stk, pci, 7);

	(void) cntxt;
	if (msg)
		return msg;
	if ((b = BATdescriptor(*bid)) == NULL)
		throw(SQL, "sql.rsColumn", "cannot access BAT descriptor");
	if (mvc_result_column(m, *tn, *name, *type, *digits, *scale, b)) 
		res = createException(SQL, "sql.rsColumn", "mvc_result_column failed");
	*ret = 0;
	BBPunfix(b->batCacheid);
	return res;
}

str
/*mvc_result_value_wrap(int *ret, int *rs, str *tn, str *name, str *type, int *digits, int *scale, ptr p, int mtype)*/
mvc_result_value_wrap(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	int *ret  = (int *) getArgReference(stk, pci, 0);
	str *tn   = (str *) getArgReference(stk, pci, 2);
	str *cn   = (str *) getArgReference(stk, pci, 3);
	str *type = (str *) getArgReference(stk, pci, 4);
	int *digits = (int *) getArgReference(stk, pci, 5);
	int *scale = (int *) getArgReference(stk, pci, 6);
	ptr p =  (ptr) getArgReference(stk, pci, 7);
	int mtype = getArgType(mb, pci, 7);
	mvc *m = NULL;
	str msg = getContext(cntxt,mb, &m, NULL);

	(void) cntxt;
	if (msg)
		return msg;
	if (ATOMextern(mtype)) 
		p = *(ptr*)p;
	if (mvc_result_value(m, *tn, *cn, *type, *digits, *scale, p, mtype))
		throw(SQL, "sql.rsColumn", "failed");
	*ret = 0;
	return MAL_SUCCEED;
}

/* str mvc_declared_table_wrap(int *res_id, str *name); */
str
mvc_declared_table_wrap(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	mvc *m = NULL;
	str msg = getContext(cntxt,mb, &m, NULL);
	sql_schema *s = NULL;
	int *res_id = (int *) getArgReference(stk, pci, 0);
	str *name = (str *) getArgReference(stk, pci, 1);

	(void) cntxt;
	if (msg)
		return msg;
	s = mvc_bind_schema(m, dt_schema);
	if ( s == NULL)
		throw(MAL,"sql.declared_table","Schema missing");
	(void)mvc_create_table(m, s, *name, TRUE, SQL_DECLARED_TABLE, CA_DROP, 0);
	*res_id = 0;
	return MAL_SUCCEED;
}

/* str mvc_declared_table_column_wrap(int *ret, int *rs, str *tname, str *name, str *type, int *digits, int *scale); */
str 
mvc_declared_table_column_wrap(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	mvc *m = NULL;
	str msg = getContext(cntxt,mb, &m, NULL);
	sql_schema *s = NULL;
	sql_table *t = NULL;
	sql_subtype tpe;
	int *ret  = (int *) getArgReference(stk, pci, 0);
	int *rs = (int *) getArgReference(stk, pci, 1);
	str *tname = (str *) getArgReference(stk, pci, 2);
	str *name = (str *) getArgReference(stk, pci, 3);
	str *type = (str *) getArgReference(stk, pci, 4);
	int *digits = (int *) getArgReference(stk, pci, 5);
	int *scale = (int *) getArgReference(stk, pci, 6);

	(void) cntxt;
	if (msg)
		return msg;
	if (*rs != 0)
                throw(SQL, "sql.dtColumn", "Cannot access declared table");
	if (!sql_find_subtype(&tpe, *type, *digits, *scale))
                throw(SQL, "sql.dtColumn", "Cannot find column type");
	s = mvc_bind_schema(m, dt_schema);
	if ( s == NULL)
		throw(MAL,"sql.declared_table_column","Schema missing");
	t = mvc_bind_table(m, s, *tname);
	if ( t == NULL)
		throw(MAL,"sql.declared_table_column","Table missing");
	(void)mvc_create_column(m, t, *name, &tpe); 
	*ret = 0;
	return MAL_SUCCEED;
}

str
mvc_drop_declared_table_wrap(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci )
{
	mvc *m = NULL;
	str *name = (str *) getArgReference(stk, pci, 1);
	str msg = getContext(cntxt, mb, &m, NULL);
	sql_schema *s = NULL;
	sql_table *t = NULL;

	if (msg)
		return msg;
	s = mvc_bind_schema(m, dt_schema);
	if ( s == NULL)
		throw(MAL,"sql.drop","Schema missing");
	t = mvc_bind_table(m, s, *name);
	if ( t == NULL)
		throw(MAL,"sql.drop","Table missing");
	(void)mvc_drop_table(m, s, t, 0);
	return MAL_SUCCEED;
}

str
mvc_drop_declared_tables_wrap(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci )
{
	mvc *m = NULL;
	int i = *(int *) getArgReference(stk, pci, 1);
	str msg = getContext(cntxt, mb, &m, NULL);
	sql_schema *s = NULL;
	sql_table *t = NULL;

	if (msg)
		return msg;
	s = mvc_bind_schema(m, dt_schema);
	if ( s == NULL)
		throw(MAL,"sql.drop","Schema missing");
	while(i && s->tables.set->t) {
		t = s->tables.set->t->data;
		(void)mvc_drop_table(m, s, t, 0);
		i--;
	}
	return MAL_SUCCEED;
}

/* str mvc_affected_rows_wrap(int *r, wrd *nr, str *w); */
str
mvc_affected_rows_wrap(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	backend *b = NULL;
	mvc *c = NULL;
	str msg = getContext(cntxt,mb, &c, &b);
	int *r  = (int *) getArgReference(stk, pci, 0);
#ifndef NDEBUG
	int mtype = getArgType(mb, pci, 1);
#endif
	wrd nr;
	str *w = (str *) getArgReference(stk, pci, 2);

	(void) cntxt;
	if (msg)
		return msg;
	assert (mtype == TYPE_wrd);
	nr = *(wrd *) getArgReference(stk, pci, 1);
	if (mvc_export_affrows(c, b->out, nr, *w)) {
		throw(SQL, "sql.affectedRows", "failed");
	}
	(void)r;
	return NULL;
}

/* str mvc_export_head_wrap(int *ret, stream **s, int *res_id); */
str
mvc_export_head_wrap(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	backend *b = NULL;
	mvc *c = NULL;
	str msg = getContext(cntxt,mb, &c, &b);
	int *ret  = (int *) getArgReference(stk, pci, 0);
	stream **s  = (stream **) getArgReference(stk, pci, 1);
	int *res_id = (int *) getArgReference(stk, pci, 2);

	(void) cntxt;
	if (msg)
		return msg;
	if (mvc_export_head(c, *s, *res_id, FALSE)) {
		throw(SQL, "sql.exportHead", "failed");
	}
	(void)ret;
	return NULL;
}
/* str mvc_export_result_wrap(int *ret, stream **s, int *res_id); */
str
mvc_export_result_wrap(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	backend *b = NULL;
	mvc *c = NULL;
	str msg = getContext(cntxt,mb, &c, &b);
	int *ret  = (int *) getArgReference(stk, pci, 0);
	stream **s  = (stream **) getArgReference(stk, pci, 1);
	int *res_id = (int *) getArgReference(stk, pci, 2);

	(void) cntxt;
	if (msg)
		return msg;
	if (mvc_export_result(c, *s, *res_id)) {
		throw(SQL, "sql.exportResult", "failed");
	}
	(void)ret;
	return NULL;
}
/* str mvc_export_chunk_wrap(int *ret, stream **s, int *res_id, str *w); */
str
mvc_export_chunk_wrap(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	backend *b = NULL;
	mvc *c = NULL;
	str msg = getContext(cntxt,mb, &c, &b);
	int *ret  = (int *) getArgReference(stk, pci, 0);
	stream **s  = (stream **) getArgReference(stk, pci, 1);
	int *res_id = (int *) getArgReference(stk, pci, 2);
	BUN	offset = 0;
	BUN	nr = 0;

	if ( pci->argc == 5){
		offset = *(BUN *) getArgReference(stk,pci,3);
		nr = *(BUN *) getArgReference(stk,pci,4);
	} 

	(void) cntxt;
	if (msg)
		return msg;
	if (mvc_export_chunk(c, *s, *res_id, offset, nr)) {
		throw(SQL, "sql.exportChunk", "failed");
	}
	(void)ret;
	return NULL;
}

/* str mvc_export_operation_wrap(int *ret, str *w); */
str
mvc_export_operation_wrap(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	backend *b = NULL;
	mvc *c = NULL;
	str msg = getContext(cntxt,mb, &c, &b);
	int *ret  = (int *) getArgReference(stk, pci, 0);
	str *w = (str *) getArgReference(stk, pci, 1);

	(void) cntxt;
	if (msg)
		return msg;
	if (mvc_export_operation(c, b->out, *w)) {
		throw(SQL, "sql.exportOperation", "failed");
	}
	(void)ret;
	return NULL;
}


str
/*mvc_export_value_wrap(int *ret, int *qtype, str tn, str name, str type, int *digits, int *scale, int *eclass, ptr p, int mtype)*/
mvc_export_value_wrap(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	int *qtype= (int *) getArgReference(stk, pci, 1);
	str *tn   = (str *) getArgReference(stk, pci, 2);
	str *cn   = (str *) getArgReference(stk, pci, 3);
	str *type = (str *) getArgReference(stk, pci, 4);
	int *digits = (int *) getArgReference(stk, pci, 5);
	int *scale = (int *) getArgReference(stk, pci, 6);
	int *eclass = (int *) getArgReference(stk, pci, 7);
	ptr p =  (ptr) getArgReference(stk, pci, 8);
	int mtype = getArgType(mb, pci, 8);
	str *w = (str *) getArgReference(stk, pci, 9);
	backend *b = NULL;
	mvc *c = NULL;
	str msg = getContext(cntxt,mb, &c, &b);

	(void) cntxt;
	if (msg)
		return msg;
	if (ATOMextern(mtype)) 
		p = *(ptr*)p;
	if (b->out == NULL ||
		mvc_export_value(c, b->out, *qtype, *tn, *cn, *type, *digits, *scale, *eclass, p, mtype, *w, "NULL") != SQL_OK)
		throw(SQL, "sql.exportValue", "failed");
	return MAL_SUCCEED;
}

/* str mvc_import_table_wrap(int *res, bstream **s, str *sname, str *tname, unsigned char* *T, unsigned char* *R, unsigned char* *S, unsigned char* *N, lng *sz, lng *offset); */
str
mvc_import_table_wrap(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	BAT *b;
	mvc *m = NULL;
	str msg = getContext(cntxt,mb, &m, NULL);
	unsigned char *tsep = NULL, *rsep = NULL, *ssep = NULL, *ns = NULL;
	ssize_t len = 0;
	int *res = (int *) getArgReference(stk, pci, 0);
	bstream **s = (bstream **) getArgReference(stk, pci, 1);
	str *sname = (str *) getArgReference(stk, pci, 2);
	str *tname = (str *) getArgReference(stk, pci, 3);
	unsigned char **T = (unsigned char **) getArgReference(stk, pci, 4);
	unsigned char **R = (unsigned char **) getArgReference(stk, pci, 5);
	unsigned char **S = (unsigned char **) getArgReference(stk, pci, 6);
	unsigned char **N = (unsigned char **) getArgReference(stk, pci, 7);
	lng *sz = (lng *) getArgReference(stk, pci, 8);
	lng *offset = (lng *) getArgReference(stk, pci, 9);

	if (msg)
		return msg;
	len = strlen((char*)(*T));
	GDKstrFromStr(tsep=GDKmalloc(len+1), *T, len); len = 0;
	len = strlen((char*)(*R));
	GDKstrFromStr(rsep=GDKmalloc(len+1), *R, len); len = 0;
	len = strlen((char*)(*S));
	if (*S && strcmp(str_nil,*(char**)S)) {
		GDKstrFromStr(ssep=GDKmalloc(len+1), *S, len); 
		len = 0;
	}
	len = strlen((char*)(*N));
	GDKstrFromStr(ns=GDKmalloc(len+1), *N, len); len = 0;
	b = mvc_import_table(cntxt, m, *s, *sname, *tname, (char*)tsep, (char*)rsep, (char*)ssep, (char*)ns, *sz, *offset);
	GDKfree(tsep);
	GDKfree(rsep);
	if(ssep)
		GDKfree(ssep);
	GDKfree(ns);
	if (!b)
		throw(SQL, "importTable", "failed to import table");
	*res = b->batCacheid;
	BBPincref( *res, TRUE);
	BBPunfix(*res);
	return MAL_SUCCEED;
}

/* str mvc_bin_import_table_wrap(int *res, str *sname, str *tname, str *fname..); */
str
mvc_bin_import_table_wrap(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	BAT *b;
	mvc *m = NULL;
	str msg = getContext(cntxt, mb, &m, NULL);
	BUN cnt = 0;
	int i, *res = (int *) getArgReference(stk, pci, 0);
	str sname = *(str *) getArgReference(stk, pci, 1);
	str tname = *(str *) getArgReference(stk, pci, 2);
	sql_schema *s = mvc_bind_schema(m, sname);
	sql_table *t;
	node *n;

	if (msg)
		return msg;

	if ( s == NULL)
		throw(MAL,"sql.drop","Schema missing");
	t = mvc_bind_table(m, s, tname);
	if (!t) 
		throw(SQL,"sql", "table %s not found", tname);
	if (list_length(t->columns.set) != (pci->argc-3))
		throw(SQL,"sql", "Not enough columns in found");
	b = BATnew(TYPE_str, TYPE_bat, pci->argc-3);
	for (i = 3, n = t->columns.set->h; i<pci->argc && n; i++, n = n->next) {
		sql_column *col = n->data;
		BAT *c;

		c = BATattach(col->type.type->localtype, *(str*)getArgReference(stk, pci, i));
		if (c == NULL) {
			BBPunfix(b->batCacheid);
			throw(SQL, "sql", "failed to attach file %s",
			      *(str*)getArgReference(stk, pci, i));
		}

		BATsetaccess(c, BAT_READ);
		BATpropcheck(c, BATPROPS_ALL);
		BATpropcheck(BATmirror(c), BATPROPS_ALL);
		if (i!=3 && cnt != BATcount(c)) {
			BBPunfix(b->batCacheid);
			throw(SQL, "sql", "table %s not found", tname);
		}
		cnt = BATcount(c);
		BUNins(b, (ptr)col->base.name, (ptr)&c->batCacheid, FALSE);
		BBPunfix( c->batCacheid );
	}
	*res = b->batCacheid;
	BBPincref( *res, TRUE);
	BBPunfix(*res);
	return MAL_SUCCEED;
}


str
zero_or_one(ptr ret, int *bid) 
{
	BAT *b;
	BUN c, _s;
	ptr p;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(SQL, "zero_or_one", "Cannot access descriptor");
	}
	c = BATcount(b);
	if (c == 0) {
		p = ATOMnilptr(b->ttype);
	} else if (c == 1) {
		BATiter bi = bat_iterator(b);
		p = BUNtail(bi,BUNfirst(b));
	} else {
		char buf[BUFSIZ];

		p = NULL;
                snprintf(buf, BUFSIZ, "cardinality violation (" BUNFMT ">1)", c);
		throw(SQL, "zero_or_one", buf);
	}
	_s = ATOMsize(ATOMtype(b->ttype));
	if (ATOMextern(b->ttype)) {
		_s = ATOMlen(ATOMtype(b->ttype), p);
		memcpy(*(ptr*) ret=GDKmalloc(_s), p, _s);
	} else if (b->ttype == TYPE_bat) {
		bat bid = *(bat*)p;
		*(BAT**) ret = BATdescriptor(bid);
	} else if (_s == 4) {
		*(int*) ret = *(int*)p;
	} else if (_s == 1) {
		*(bte*) ret = *(bte*)p;
	} else if (_s == 2) {
		*(sht*) ret = *(sht*)p;
	} else if (_s == 8) {
		*(lng*) ret = *(lng*)p;
	} else {
		memcpy(ret, p, _s);
	}
	BBPreleaseref(b->batCacheid);
	
	return MAL_SUCCEED;
}

str not_unique(bit *ret, int* bid) 
{
	BAT *b;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(SQL, "not_unique", "Cannot access descriptor");
	}

	*ret = FALSE;
	if (BATtkey(b) || BATtdense(b) || BATcount(b) <= 1) {
		BBPunfix(b->batCacheid);
		return MAL_SUCCEED;
	} else if (b->tsorted&1) {
		BUN p,q;
		oid c = *(oid*)Tloc(b, BUNfirst(b)); 

		for(p=BUNfirst(b)+1, q=BUNlast(b);p<q;p++) {
			oid v = *(oid*)Tloc(b,p);
			if (v<=c) {
				*ret = TRUE;
				break;
			}
			c = v;
		}
	} else {
		BBPunfix(b->batCacheid);
		throw(SQL, "not_unique", "input should be sorted");
	}
	BBPunfix(b->batCacheid);
	return MAL_SUCCEED;
}

/* later we could optimize this to start from current BUN 
   And only search the from the first if second is not found.
 */
static inline int 
HASHfndTwice(BAT *b, ptr v)
{
	BATiter bi = bat_iterator(b);
	BUN i = BUN_NONE;
	int first = 1;
	
	HASHloop( bi, b->H->hash, i, v) {
		if (!first)
			return 1;
		first = 0;
	}
	return 0;
}

str 
not_unique_oids(bat *ret, bat* bid) 
{
	BAT *b, *bn = NULL;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(SQL, "not_uniques", "Cannot access descriptor");
	}
	if (b->ttype != TYPE_oid && b->ttype != TYPE_wrd) {
		throw(SQL, "not_uniques", "Wrong types");
	}

	assert(b->htype == TYPE_oid);
	if (BATtkey(b) || BATtdense(b) || BATcount(b) <= 1) {
		bn = BATnew(TYPE_oid, TYPE_oid, 0);
	} else if (b->tsorted&1) { /* ugh handle both wrd and oid types */
		oid c = *(oid*)Tloc(b, BUNfirst(b)), *rf, *rh, *rt;
		oid *h = (oid*)Hloc(b,0), *vp, *ve;
		int first = 1;

		bn = BATnew(TYPE_oid, TYPE_oid, BATcount(b));
		vp = (oid*)Tloc(b, BUNfirst(b));
		ve = vp + BATcount(b);
		rf = rh = (oid*)Hloc(bn, BUNfirst(bn));
		rt = (oid*)Tloc(bn, BUNfirst(bn));
		*rh++ = *h++; 
		*rt++ = *vp; 
		for(vp++; vp < ve; vp++, h++) {
			oid v = *vp;
			if (v == c) {
				first = 0;
				*rh++ = *h;
				*rt++ = v;
			} else if (!first) {
				first = 1;
				*rh++ = *h;
				*rt++ = v;
			} else {
				*rh = *h;
				*rt = v;
			}
			c = v;
		}
		if (first)
			rh--;
		BATsetcount(bn, (BUN)(rh - rf)); 
	} else {
		oid *rf, *rh, *rt;
		oid *h = (oid*)Hloc(b,0), *vp, *ve;
		BAT *bm = BATmirror(b);

		if (BATprepareHash(bm))
			throw(SQL, "not_uniques", "hash creation failed");
		bn = BATnew(TYPE_oid, TYPE_oid, BATcount(b));
		vp = (oid*)Tloc(b, BUNfirst(b));
		ve = vp + BATcount(b);
		rf = rh = (oid*)Hloc(bn, BUNfirst(bn));
		rt = (oid*)Tloc(bn, BUNfirst(bn));
		for(; vp < ve; vp++, h++) {
			/* try to find value twice */
			if (HASHfndTwice(bm, vp)) {
				*rh++ = *h;
				*rt++ = *vp;
			}
		}
		BATsetcount(bn, (BUN)(rh - rf)); 
	}
	BBPunfix(b->batCacheid);
	BBPkeepref(*ret = bn->batCacheid);
	return MAL_SUCCEED;
}

lng scales[20] = {
	LL_CONSTANT(1),
	LL_CONSTANT(10),
	LL_CONSTANT(100),
	LL_CONSTANT(1000),
	LL_CONSTANT(10000),
	LL_CONSTANT(100000),
	LL_CONSTANT(1000000),
	LL_CONSTANT(10000000),
	LL_CONSTANT(100000000),
	LL_CONSTANT(1000000000),
	LL_CONSTANT(10000000000),
	LL_CONSTANT(100000000000),
	LL_CONSTANT(1000000000000),
	LL_CONSTANT(10000000000000),
	LL_CONSTANT(100000000000000),
	LL_CONSTANT(1000000000000000),
	LL_CONSTANT(10000000000000000),
	LL_CONSTANT(100000000000000000),
	LL_CONSTANT(1000000000000000000)
};

@-
The core modules of Monet provide just a limited set of
mathematical operators. The extensions required to support
SQL-99 are shown below. At some point they also should be
moved to module code base.
@= round
str 
@1_dec_round_wrap( @1 *res, @1 *v, @1 *r )
{
	@1 val = *v;
	@1 add = *r;

	/* shortcut nil */
	if (*v == @1_nil) {
		*res = @1_nil;
		return NULL;
	}

	add >>=1;
	if (val < 0) 
		add = -add;
	val += add; 
	val /= *r;
	*res = val;
	return NULL;
}

str 
@1_round_wrap( @1 *res, @1 *v, int *d, int *s, bte *r )
{
	/* shortcut nil */
	if (*v == @1_nil) {
		*res = @1_nil;
	} else if (-*r > *d) {
		*res = 0;
	} else if (*r > 0 && *r < *s) {
		int dff = *s - *r;
		lng rnd = scales[dff]>>1;
		lng lres;
		if (*v > 0)
			lres = (((*v + rnd)/scales[dff])*scales[dff]);
		else
			lres = (((*v - rnd)/scales[dff])*scales[dff]);
		assert((lng) GDK_@1_min < lres && lres <= (lng) GDK_@1_max);
		*res = (@1) lres;
	} else if (*r <= 0 && -*r + *s > 0) {
		int dff = -*r + *s;
		lng rnd = scales[dff]>>1;
		lng lres;
		if (*v > 0)
			lres = (((*v + rnd)/scales[dff])*scales[dff]);
		else
			lres = (((*v - rnd)/scales[dff])*scales[dff]);
		assert((lng) GDK_@1_min < lres && lres <= (lng) GDK_@1_max);
		*res = (@1) lres;
	} else {
		*res = *v;
	}
	return MAL_SUCCEED;
}

str
str_2dec_@1( @1 *res, str *val, int *d, int *sc )
{
	char *s = strip_extra_zeros(*val);
	char *dot = strchr(s, '.');
	int digits = _strlen(s) - 1;
	int scale = digits - (int) (dot-s);
	lng value = 0;

	if (!dot) {
		if (GDK_STRNIL(*val)) {
			*res = @1_nil;
			return MAL_SUCCEED;
		} else {
			throw(SQL, "@1", 
				"\"%s\" is no decimal value (doesn't contain a '.')", *val);
		}
	}
		
	value = decimal_from_str(s);
	if (*s == '+' || *s == '-')
		digits --;
	if (scale < *sc){
		/* the current scale is too small, increase it by adding 0's */
		int d = *sc - scale;	/* CANNOT be 0! */

		value *= scales[d];
		scale += d;
		digits += d;
	} else if (scale > *sc){
		/* the current scale is too big, decrease it by correctly rounding */
		int d = scale - *sc;	/* CANNOT be 0 */
		lng rnd = scales[d]>>1;

		value += rnd;
		value /= scales[d];
		scale -= d;
		digits -= d;
	}
	if (digits > *d) {
		throw(SQL,"@1", 
		     "decimal (%s) doesn't have format (%d.%d)", *val, *d, *sc);
	}
	*res = (@1) value;
	return MAL_SUCCEED;
}

str
str_2num_@1( @1 *res, str *v, int *len )
{
	int zero = 0;
	return str_2dec_@1( res, v, len, &zero );
}

str
batstr_2dec_@1( int *res, int *bid, int *d, int *sc )
{
	BAT *b, *dst;
	BATiter bi;
	BUN p,q;
	char *msg = NULL;

	if( (b = BATdescriptor(*bid)) == NULL ){
		throw(SQL, "batcalc.str_2dec_@1", "Cannot access descriptor");
	}
	bi = bat_iterator(b);
	dst = BATnew(b->htype, TYPE_@1, BATcount(b));
	BATseqbase(dst, b->hseqbase);
	BATloop(b,p,q) {
		str v = (str)BUNtail(bi,p);
		@1 r;
		msg = str_2dec_@1( &r, &v, d, sc );
		if (msg)
			break;
		BUNins(dst, BUNhead(bi,p), &r, FALSE);
	}
	BBPkeepref( *res = dst->batCacheid);
	BBPunfix(b->batCacheid);
	return msg;
}

str
batstr_2num_@1( int *res, int *bid, int *len )
{
	BAT *b, *dst;
	BATiter bi;
	BUN p,q;
	char *msg = NULL;

	if( (b = BATdescriptor(*bid)) == NULL ){
		throw(SQL, "batcalc.str_2num_@1", "Cannot access descriptor");
	}
	bi = bat_iterator(b);
	dst = BATnew(b->htype, TYPE_@1, BATcount(b));
	BATseqbase(dst, b->hseqbase);
	BATloop(b,p,q) {
		str v = (str)BUNtail(bi,p);
		@1 r;
		msg = str_2num_@1( &r, &v, len );
		if (msg)
			break;
		BUNins(dst, BUNhead(bi,p), &r, FALSE);
	}
	BBPkeepref( *res = dst->batCacheid);
	BBPunfix(b->batCacheid);
	return msg;
}
@c

@:round(bte)@
@:round(sht)@
@:round(int)@
@:round(wrd)@
@:round(lng)@

@= fround
str 
@1_dec_round_wrap( @1 *res, @1 *v, @1 *r )
{
	@1 val = *v;

	/* not nil */
	if (ATOMcmp(TYPE_@1, v, ATOMnilptr(TYPE_@1)) != 0) {
		val /= *r;
	}
	*res = val;
	return MAL_SUCCEED;
}

str 
@1_round_wrap( @1 *res, @1 *v, bte *r )
{
	/* shortcut nil */
	if (*v == @1_nil) {
		*res = @1_nil;
	} else if (*r < 0) {
		int d = -*r;
		@1 rnd = (@1) (scales[d]>>1); 

		if (*v > 0)
			*res = (@1) (floor(((*v + rnd)/((@1)(scales[d]))))*scales[d]);
		else
			*res = (@1) (floor(((*v + rnd)/((@1)(scales[d]))))*scales[d]);
	} else if (*r > 0) {
		int d = *r;

		if (*v > 0)
			*res = (@1) (floor(*v*(@1)scales[d]+.5)/scales[d]);
		else
			*res = (@1) (floor(*v*(@1)scales[d]+.5)/scales[d]);
	} else {
		*res = *v;
	}
	return MAL_SUCCEED;
}

@c
@:fround(flt)@
@:fround(dbl)@

#if SIZEOF_WRD == SIZEOF_INT
#define wrdToStr(sptr, lptr, p) intToStr(sptr, lptr, (int*)p)
#else
#define wrdToStr(sptr, lptr, p) lngToStr(sptr, lptr, (lng*)p)
#endif

@= cast
str
str_2_@1( @3 *res, str *val )
{
	ptr p = NULL;
	int len = 0;
	int e; 
	
	e = ATOMfromstr(TYPE_@1, &p, &len, *val);
	if (e < 0 || !p || 
	   (ATOMcmp(TYPE_@1, p, ATOMnilptr(TYPE_@1)) == 0 &&
	    ATOMcmp(TYPE_str, *val, ATOMnilptr(TYPE_str)) != 0))
	{
		char buf[BUFSIZ];
		if (p)
			GDKfree(p);
                snprintf(buf, BUFSIZ,"conversion of string '%s' failed",*val);
		throw(SQL, "@1", buf);
	}
	@4;
	if (!ATOMextern(TYPE_@1)) {
		if (p)
			GDKfree(p);
	}
	return MAL_SUCCEED;
}

str
SQL@1_2_str( str *res, @1 *val )
{
	char *p = NULL;
	int len = 0;
	@2( &p, &len, val);
	*res = p;
	return MAL_SUCCEED;
}

str
batstr_2_@1( int *res, int *bid )
{
	BAT *b, *dst;
	BATiter bi;
	BUN p,q;
	char *msg = NULL;

	if( (b = BATdescriptor(*bid)) == NULL ){
		throw(SQL, "batcalc.str_2_@1", "Cannot access descriptor");
	}
	bi = bat_iterator(b);
	dst = BATnew(b->htype, TYPE_@1, BATcount(b));
	BATseqbase(dst, b->hseqbase);
	BATloop(b,p,q) {
		str v = (str)BUNtail(bi,p);
		@3 r;
		msg = str_2_@1( &r, &v );
		if (msg)
			break;
		BUNins(dst, BUNhead(bi,p), &r, FALSE);
	}
	BBPkeepref( *res = dst->batCacheid);
	BBPunfix(b->batCacheid);
	return msg;
}
@c
@:cast(bit,bitToStr,bit, *res = *(bit*)p)@
@:cast(oid,OIDtoStr,oid, *res = *(oid*)p)@
@:cast(bte,bteToStr,bte, *res = *(bte*)p)@
@:cast(sht,shtToStr,sht, *res = *(sht*)p)@
@:cast(int,intToStr,int, *res = *(int*)p)@
@:cast(lng,lngToStr,lng, *res = *(lng*)p)@
@:cast(wrd,wrdToStr,wrd, *res = *(wrd*)p)@
@:cast(flt,fltToStr,flt, *res = *(flt*)p)@
@:cast(dbl,dblToStr,dbl, *res = *(dbl*)p)@
@:cast(timestamp,timestamp_tostr,timestamp, *res = *(timestamp*)p)@
@:cast(daytime,daytime_tostr,daytime, *res = *(daytime*)p)@
@:cast(date,date_tostr,date, *res = *(date*)p)@
@:cast(sqlblob,sqlblob_tostr,sqlblob*, *res = (sqlblob*)p)@

str
SQLstr_2_str( str *res, str *val )
{
	if( *val == str_nil) 
		*res = (str)str_nil;
	else
		*res =  GDKstrdup(*val);
	return MAL_SUCCEED;
}

str
SQLstr_cast_(str *res, mvc *m, int eclass, int d, int s, int has_tz, ptr p, int tpe, int len)
{
	char *r = NULL;
	int sz = MAX(2,len + 1);	/* nil should fit */

	if (tpe != TYPE_str) {
		r = GDKmalloc(sz);
		sz = convert2str(m, eclass, d, s, has_tz, p, tpe, &r, sz);
	} else {
		str v = (str)p; 
		strLength(&sz, v);
		if (len == 0 || sz <= len) 
			r = GDKstrdup(v);
	}
	if (len > 0 && sz > len) {
		if (r) 
			GDKfree(r);
		if (ATOMcmp(TYPE_str, ATOMnilptr(TYPE_str), p) != 0) {
			throw(SQL, "str_cast", "value too long for type (var)char(%d)", len);
		} else {
			r = GDKstrdup(str_nil);
		}
	}
	*res = r;
	return MAL_SUCCEED;
}

str
SQLstr_cast(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	str *res  = (str *) getArgReference(stk, pci, 0);
	int eclass = *(int*) getArgReference(stk, pci, 1);
	int d = *(int*) getArgReference(stk, pci, 2);
	int s = *(int*) getArgReference(stk, pci, 3);
	int has_tz = *(int*) getArgReference(stk, pci, 4);
	ptr p   = (ptr) getArgReference(stk, pci, 5);
	int tpe = getArgType(mb, pci, 5);
	int len   = *(int *) getArgReference(stk, pci, 6);
	mvc *m = NULL;
	str msg = getContext(cntxt,mb, &m, NULL);

	(void) cntxt;
	if (msg)
		return msg;
	if (ATOMextern(tpe)) 
		p = *(ptr*)p;
	return SQLstr_cast_(res, m, eclass, d, s, has_tz, p, tpe, len );
}

/* str SQLbatstr_cast(int *res, int *eclass, int *d1, int *s1, int *has_tz, int *bid, int *digits ); */
str 
SQLbatstr_cast(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	BAT *b, *dst;
	BATiter bi;
	BUN p,q;
	mvc *m = NULL;
	str msg = getContext(cntxt,mb, &m, NULL);
	char *r = NULL;
	int *res  = (int *) getArgReference(stk, pci, 0);
	int *eclass = (int*) getArgReference(stk, pci, 1);
	int *d1 = (int*) getArgReference(stk, pci, 2);
	int *s1 = (int*) getArgReference(stk, pci, 3);
	int *has_tz = (int*) getArgReference(stk, pci, 4);
	int *bid   = (int*) getArgReference(stk, pci, 5);
	int *digits   = (int *) getArgReference(stk, pci, 6);

	(void) cntxt;
	if (msg)
		return msg;
	if( (b = BATdescriptor(*bid)) == NULL ){
		throw(SQL, "batcalc.str_2dec_@1", "Cannot access descriptor");
	}
	bi = bat_iterator(b);
	dst = BATnew(b->htype, TYPE_str, BATcount(b));
	BATseqbase(dst, b->hseqbase);
	BATloop(b,p,q) {
		ptr v = (ptr)BUNtail(bi,p);
		msg = SQLstr_cast_( &r, m, *eclass, *d1, *s1, *has_tz, v, b->ttype, *digits);
		if (msg)
			break;
		BUNins(dst, BUNhead(bi,p), r, FALSE);
		GDKfree(r);
	}
	BBPkeepref( *res = dst->batCacheid);
	BBPunfix(b->batCacheid);
	return msg;
}

@= simpleupcast
str 
@2_2_@1( @1 *res, @2 *v )
{
	/* shortcut nil */
	if (*v == @2_nil) {
		*res = @1_nil;
		return(MAL_SUCCEED);
	}
	
	/* since the @1 type is bigger than or equal to the @2 type, it will
	   always fit */
	*res = (@1)*v;
	return(MAL_SUCCEED);
}

str bat@2_2_@1( int *res, int *bid )
{
	BAT *b, *dst;
	BATiter bi;
	BUN p,q;
	char *msg = NULL;

	if( (b = BATdescriptor(*bid)) == NULL ){
		throw(SQL, "batcalc.@2_2_@1", "Cannot access descriptor");
	}
	bi = bat_iterator(b);
	dst = BATnew(b->htype, TYPE_@1, BATcount(b));
	BATseqbase(dst, b->hseqbase);
	BATloop(b,p,q) {
		@2 *v = (@2*)BUNtail(bi,p);
		@1 r;
		msg = @2_2_@1( &r, v );
		if (msg)
			break;
		BUNins(dst, BUNhead(bi,p), &r, FALSE);
	}
	BBPkeepref( *res = dst->batCacheid);
	BBPunfix(b->batCacheid);
	return msg;
}
@c

@= simpledowncast
str @2_2_@1( @1 *res, @2 *v )
{
	@3 val = *v;

	/* shortcut nil */
	if (*v == @2_nil) {
		*res = @1_nil;
		return(MAL_SUCCEED);
	}
	
	/* see if the number fits in the data type */
	if ((@3)(@1)val > (@3) GDK_@1_min && 
	    val > (@3) GDK_@1_min && val <= (@3) GDK_@1_max)	{
		*res = (@1)val;
		return(MAL_SUCCEED);
	} else {
		throw(SQL, "convert",
			"value (" @4 ") exceeds limits of type @1", val);
	}
}

str bat@2_2_@1( int *res, int *bid )
{
	BAT *b, *dst;
	BATiter bi;
	BUN p,q;
	char *msg = NULL;

	if( (b = BATdescriptor(*bid)) == NULL ){
		throw(SQL, "batcalc.@2_2_@1", "Cannot access descriptor");
	}
	bi = bat_iterator(b);
	dst = BATnew(b->htype, TYPE_@1, BATcount(b));
	BATseqbase(dst, b->hseqbase);
	BATloop(b,p,q) {
		@2 *v = (@2*)BUNtail(bi,p);
		@1 r;
		msg = @2_2_@1( &r, v );
		if (msg)
			break;
		BUNins(dst, BUNhead(bi,p), &r, FALSE);
	}
	BBPkeepref( *res = dst->batCacheid);
	BBPunfix(b->batCacheid);
	return msg;
}
@-
The simple cast up operations in some cases
could re-use the storage space as well.
@= numcastup
@:simpleupcast(@1,@2)@

str @2_dec2_@1( @1 *res, int *s1, @2 *v )
{
	int scale = *s1;
	@1 r, h = (*v<0)?-5:5; 

	/* shortcut nil */
	if (*v == @2_nil) {
		*res = @1_nil;
		return(MAL_SUCCEED);
	}

	/* since the @1 type is bigger than or equal to the @2 type, it will
	   always fit */
	r = (@1)*v;
	if (scale) 
		r = (@1) ((r + h) / scales[scale]);
	*res = r;
	return(MAL_SUCCEED);
}

str 
@2_dec2dec_@1( @1 *res, int *S1, @2 *v, int *d2, int *S2 )
{
	int p = *d2, inlen = 1;
	@2 cpyval = *v;
	int s1 = *S1, s2 = *S2;
	@1 r, h = (*v<0)?-5:5; 

	/* shortcut nil */
	if (*v == @2_nil) {
		*res = @1_nil;
		return(MAL_SUCCEED);
	}
	
	/* count the number of digits in the input */
	while (cpyval /= 10)
		inlen++;

	/* rounding is allowed */
	inlen += (s2-s1);
	if (p && inlen > p) {
		throw(SQL, "convert",
			"too many digits (%d > %d)", inlen, p);
	}

	/* since the @1 type is bigger than or equal to the @2 type, it will
	   always fit */
	r = (@1)*v;
	if (s2 > s1) 
		r *= (@1) scales[s2 - s1];
	else if (s2 != s1) 
		r = (@1) ((r + h) / scales[s1 - s2]);
	*res = r;
	return(MAL_SUCCEED);
}

str 
@2_num2dec_@1( @1 *res, @2 *v, int *d2, int *s2 )
{
	int zero = 0;
	return @2_dec2dec_@1( res, &zero, v, d2, s2 );
}

str bat@2_dec2_@1( int *res, int *s1, int *bid )
{
	BAT *b, *bn;
	@2 *p,*q;
	char *msg = NULL;
	int scale = *s1;
	@1 *o;

	if( (b = BATdescriptor(*bid)) == NULL ){
		throw(SQL, "batcalc.@2_dec2_@1", "Cannot access descriptor");
	}
	bn = BATnew(b->htype, TYPE_@1, BATcount(b));
	BATseqbase(bn, b->hseqbase);
	o = (@1*) Tloc(bn,BUNfirst(bn));
	p = (@2*) Tloc(b, BUNfirst(b));
	q = (@2*) Tloc(b, BUNlast(b));
	bn->T->nonil= b->T->nonil;
	if ( b->T->nonil){
		for (; p<q; p++)
			*o = (@1) ((*p +  (*p<0)?-5:5) / scales[scale]);
	} else{
		if (*p == @2_nil) {
			*o = @1_nil;
			bn->T->nonil= FALSE;
		} else
			*o = (@1) ((*p +  (*p<0)?-5:5) / scales[scale]);
	}
	BATsetcount(bn, BATcount(b));
    bn->tsorted = 0;
    BATkey(BATmirror(bn),FALSE);
    if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ);

	BBPkeepref( *res = bn->batCacheid);
	BBPunfix(b->batCacheid);
	return msg;
}

str bat@2_dec2dec_@1( int *res, int *S1, int *bid, int *d2, int *S2 )
{
	BAT *b, *dst;
	BATiter bi;
	BUN p,q;
	char *msg = NULL;

	if( (b = BATdescriptor(*bid)) == NULL ){
		throw(SQL, "batcalc.@2_dec2dec_@1", "Cannot access descriptor");
	}
	bi = bat_iterator(b);
	dst = BATnew(b->htype, TYPE_@1, BATcount(b));
	BATseqbase(dst, b->hseqbase);
	BATloop(b,p,q) {
		@2 *v = (@2*)BUNtail(bi,p);
		@1 r;
		msg = @2_dec2dec_@1( &r, S1, v, d2, S2 );
		if (msg)
			break;
		BUNins(dst, BUNhead(bi,p), &r, FALSE);
	}
	BBPkeepref( *res = dst->batCacheid);
	BBPunfix(b->batCacheid);
	return msg;
}
str bat@2_num2dec_@1( int *res, int *bid, int *d2, int *s2 )
{
	BAT *b, *dst;
	BATiter bi;
	BUN p,q;
	char *msg = NULL;

	if( (b = BATdescriptor(*bid)) == NULL ){
		throw(SQL, "batcalc.@2_num2dec_@1", "Cannot access descriptor");
	}
	bi = bat_iterator(b);
	dst = BATnew(b->htype, TYPE_@1, BATcount(b));
	BATseqbase(dst, b->hseqbase);
	BATloop(b,p,q) {
		@2 *v = (@2*)BUNtail(bi,p);
		@1 r;
		msg = @2_num2dec_@1( &r, v, d2, s2 );
		if (msg)
			break;
		BUNins(dst, BUNhead(bi,p), &r, FALSE);
	}
	BBPkeepref( *res = dst->batCacheid);
	BBPunfix(b->batCacheid);
	return msg;
}

@c
@:numcastup(bte,bte)@
@:numcastup(sht,bte)@
@:numcastup(sht,sht)@
@:numcastup(int,bte)@
@:numcastup(int,sht)@
@:numcastup(int,int)@
@:numcastup(wrd,bte)@
@:numcastup(wrd,sht)@
@:numcastup(wrd,int)@
@:numcastup(wrd,wrd)@
@:numcastup(lng,bte)@
@:numcastup(lng,sht)@
@:numcastup(lng,int)@
@:numcastup(lng,wrd)@
@:numcastup(lng,lng)@

@= fnumcastdown
@:simpledowncast(@1,@2,dbl,"%f")@

/* when casting a floating point to an decimal we like to preserve the 
 * precision.  This means we first scale the float before converting.
*/
str 
@2_num2dec_@1( @1 *res, @2 *v, int *d2, int *s2 )
{
	int p = *d2, inlen = 1, scale = *s2;
	@2 r;
	lng cpyval;

	/* shortcut nil */
	if (*v == @2_nil) {
		*res = @1_nil;
		return(MAL_SUCCEED);
	}
	
	/* since the @1 type is bigger than or equal to the @2 type, it will
	   always fit */
	r = (@2) *v;
	if (scale) 
		r *= scales[scale];
	cpyval = (lng) r;

	/* count the number of digits in the input */
	while (cpyval /= 10)
		inlen++;
	/* rounding is allowed */
	if (p && inlen > p) {
		throw(SQL, "convert",
			"too many digits (%d > %d)", inlen, p);
	}
	*res = (@1) r;
	return MAL_SUCCEED;
}
str 
bat@2_num2dec_@1( int *res, int *bid, int *d2, int *s2 )
{
	BAT *b, *dst;
	BATiter bi;
	BUN p,q;
	char *msg = NULL;

	if( (b = BATdescriptor(*bid)) == NULL ){
		throw(SQL, "batcalc.@2_num2dec_@1", "Cannot access descriptor");
	}
	bi = bat_iterator(b);
	dst = BATnew(b->htype, TYPE_@1, BATcount(b));
	BATseqbase(dst, b->hseqbase);
	BATloop(b,p,q) {
		@2 *v = (@2*)BUNtail(bi,p);
		@1 r;
		msg = @2_num2dec_@1( &r, v, d2, s2 );
		if (msg)
			break;
		BUNins(dst, BUNhead(bi,p), &r, FALSE);
	}
	BBPkeepref( *res = dst->batCacheid);
	BBPunfix(b->batCacheid);
	return msg;
}

@c
@:fnumcastdown(bte,flt)@
@:fnumcastdown(sht,flt)@
@:fnumcastdown(int,flt)@
@:fnumcastdown(wrd,flt)@
@:fnumcastdown(lng,flt)@
@:fnumcastdown(bte,dbl)@
@:fnumcastdown(sht,dbl)@
@:fnumcastdown(int,dbl)@
@:fnumcastdown(wrd,dbl)@
@:fnumcastdown(lng,dbl)@

@= fnumcastup
@:simpleupcast(@1,@2)@

str 
@2_dec2_@1( @1 *res, int *s1, @2 *v )
{
	int scale = *s1;
	@1 r;

	/* shortcut nil */
	if (*v == @2_nil) {
		*res = @1_nil;
		return(MAL_SUCCEED);
	}
	
	/* since the @1 type is bigger than or equal to the @2 type, it will
	   always fit */
	r = (@1)*v;
	if (scale) 
		r /= scales[scale];
	*res = r;
	return MAL_SUCCEED;
}

str 
@2_dec2dec_@1( @1 *res, int *S1, @2 *v, int *d2, int *S2 )
{
	int p = *d2, inlen = 1;
	@2 cpyval = *v;
	int s1 = *S1, s2 = *S2;
	@1 r;

	/* shortcut nil */
	if (*v == @2_nil) {
		*res = @1_nil;
		return(MAL_SUCCEED);
	}
	
	/* count the number of digits in the input */
	while (cpyval /= 10)
		inlen++;
	/* rounding is allowed */
	inlen += (s2-s1);
	if (p && inlen > p) {
		throw(SQL, "convert",
			"too many digits (%d > %d)", inlen, p);
	}

	/* since the @1 type is bigger than or equal to the @2 type, it will
	   always fit */
	r = (@1)*v;
	if(s2 > s1) 
		r *= scales[s2-s1];
	else if (s2 != s1) 
		r /= scales[s1-s2];
	*res = r;
	return MAL_SUCCEED;
}

str 
@2_num2dec_@1( @1 *res, @2 *v, int *d2, int *s2 )
{
	int zero = 0;
	return @2_dec2dec_@1( res, &zero, v, d2, s2 );
}

str bat@2_dec2_@1( int *res, int *s1, int *bid )
{
	BAT *b, *dst;
	BATiter bi;
	BUN p,q;
	char *msg = NULL;

	if( (b = BATdescriptor(*bid)) == NULL ){
		throw(SQL, "batcalc.@2_dec2_@1", "Cannot access descriptor");
	}
	bi = bat_iterator(b);
	dst = BATnew(b->htype, TYPE_@1, BATcount(b));
	BATseqbase(dst, b->hseqbase);
	BATloop(b,p,q) {
		@2 *v = (@2*)BUNtail(bi,p);
		@1 r;
		msg = @2_dec2_@1( &r, s1, v );
		if (msg)
			break;
		BUNins(dst, BUNhead(bi,p), &r, FALSE);
	}
	BBPkeepref( *res = dst->batCacheid);
	BBPunfix(b->batCacheid);
	return msg;
}

str bat@2_dec2dec_@1( int *res, int *S1, int *bid, int *d2, int *S2 )
{
	BAT *b, *dst;
	BATiter bi;
	BUN p,q;
	char *msg = NULL;

	if( (b = BATdescriptor(*bid)) == NULL ){
		throw(SQL, "batcalc.@2_dec2dec_@1", "Cannot access descriptor");
	}
	bi = bat_iterator(b);
	dst = BATnew(b->htype, TYPE_@1, BATcount(b));
	BATseqbase(dst, b->hseqbase);
	BATloop(b,p,q) {
		@2 *v = (@2*)BUNtail(bi,p);
		@1 r;
		msg = @2_dec2dec_@1( &r, S1, v, d2, S2 );
		if (msg)
			break;
		BUNins(dst, BUNhead(bi,p), &r, FALSE);
	}
	BBPkeepref( *res = dst->batCacheid);
	BBPunfix(b->batCacheid);
	return msg;
}

str bat@2_num2dec_@1( int *res, int *bid, int *d2, int *s2 )
{
	BAT *b, *dst;
	BATiter bi;
	BUN p,q;
	char *msg = NULL;

	if( (b = BATdescriptor(*bid)) == NULL ){
		throw(SQL, "batcalc.@2_num2dec_@1", "Cannot access descriptor");
	}
	bi = bat_iterator(b);
	dst = BATnew(b->htype, TYPE_@1, BATcount(b));
	BATseqbase(dst, b->hseqbase);
	BATloop(b,p,q) {
		@2 *v = (@2*)BUNtail(bi,p);
		@1 r;
		msg = @2_num2dec_@1( &r, v, d2, s2 );
		if (msg)
			break;
		BUNins(dst, BUNhead(bi,p), &r, FALSE);
	}
	BBPkeepref( *res = dst->batCacheid);
	BBPunfix(b->batCacheid);
	return msg;
}


@c
@:fnumcastup(flt,bte)@
@:fnumcastup(flt,sht)@
@:fnumcastup(flt,int)@
@:fnumcastup(flt,wrd)@
@:fnumcastup(flt,lng)@
@:fnumcastup(dbl,bte)@
@:fnumcastup(dbl,sht)@
@:fnumcastup(dbl,int)@
@:fnumcastup(dbl,wrd)@
@:fnumcastup(dbl,lng)@

@c
@= numcastdown
@:simpledowncast(@1,@2,lng,LLFMT)@

str 
@2_dec2_@1( @1 *res, int *s1, @2 *v )
{
	int scale = *s1;
	lng val = *v, h = (val<0)?-5:5;

	/* shortcut nil */
	if (*v == @2_nil) {
		*res = @1_nil;
		return(MAL_SUCCEED);
	}
	
	if (scale) 
		val = (val+h)/scales[scale];
	/* see if the number fits in the data type */
	if (val > GDK_@1_min && val <= GDK_@1_max)	{
		*res = (@1)val;
		return MAL_SUCCEED;
	} else {
		throw(SQL, "convert",
			"value (" LLFMT ") exceeds limits of type @1", val);
	}
}

str 
@2_dec2dec_@1( @1 *res, int *S1, @2 *v, int *d2, int *S2 )
{
	int p = *d2, inlen = 1;
	lng val = *v, cpyval = val, h = (val<0)?-5:5;
	int s1 = *S1, s2 = *S2;

	/* shortcut nil */
	if (*v == @2_nil) {
		*res = @1_nil;
		return(MAL_SUCCEED);
	}
	
	/* count the number of digits in the input */
	while (cpyval /= 10)
		inlen++;
	/* rounding is allowed */
	inlen += (s2-s1);
	if (p && inlen > p) {
		throw(SQL, "@2_2_@1",
			"too many digits (%d > %d)", inlen, p);
	}

	if(s2 > s1) 
		val *= scales[s2-s1];
	else if (s2 != s1) 
		val = (val+h)/scales[s1-s2];

	/* see if the number fits in the data type */
	if (val > GDK_@1_min && val <= GDK_@1_max)	{
		*res = (@1)val;
		return MAL_SUCCEED;
	} else {
		throw(SQL, "convert",
			"value (" LLFMT ") exceeds limits of type @1", val);
	}
}

str 
@2_num2dec_@1( @1 *res, @2 *v, int *d2, int *s2 )
{
	int zero = 0;
	return @2_dec2dec_@1( res, &zero, v, d2, s2 );
}

str bat@2_dec2_@1( int *res, int *s1, int *bid )
{
	BAT *b, *dst;
	BATiter bi;
	BUN p,q;
	char *msg = NULL;

	if( (b = BATdescriptor(*bid)) == NULL ){
		throw(SQL, "batcalc.@2_dec2_@1", "Cannot access descriptor");
	}
	bi = bat_iterator(b);
	dst = BATnew(b->htype, TYPE_@1, BATcount(b));
	BATseqbase(dst, b->hseqbase);
	BATloop(b,p,q) {
		@2 *v = (@2*)BUNtail(bi,p);
		@1 r;
		msg = @2_dec2_@1( &r, s1, v );
		if (msg)
			break;
		BUNins(dst, BUNhead(bi,p), &r, FALSE);
	}
	BBPkeepref( *res = dst->batCacheid);
	BBPunfix(b->batCacheid);
	return msg;
}

str bat@2_dec2dec_@1( int *res, int *S1, int *bid, int *d2, int *S2 )
{
	BAT *b, *dst;
	BATiter bi;
	BUN p,q;
	char *msg = NULL;

	if( (b = BATdescriptor(*bid)) == NULL ){
		throw(SQL, "batcalc.@2_dec2dec_@1", "Cannot access descriptor");
	}
	bi = bat_iterator(b);
	dst = BATnew(b->htype, TYPE_@1, BATcount(b));
	BATseqbase(dst, b->hseqbase);
	BATloop(b,p,q) {
		@2 *v = (@2*)BUNtail(bi,p);
		@1 r;
		msg = @2_dec2dec_@1( &r, S1, v, d2, S2 );
		if (msg)
			break;
		BUNins(dst, BUNhead(bi,p), &r, FALSE);
	}
	BBPkeepref( *res = dst->batCacheid);
	BBPunfix(b->batCacheid);
	return msg;
}

str bat@2_num2dec_@1( int *res, int *bid, int *d2, int *s2 )
{
	BAT *b, *dst;
	BATiter bi;
	BUN p,q;
	char *msg = NULL;

	if( (b = BATdescriptor(*bid)) == NULL ){
		throw(SQL, "batcalc.@2_num2dec_@1", "Cannot access descriptor");
	}
	bi = bat_iterator(b);
	dst = BATnew(b->htype, TYPE_@1, BATcount(b));
	BATseqbase(dst, b->hseqbase);
	BATloop(b,p,q) {
		@2 *v = (@2*)BUNtail(bi,p);
		@1 r;
		msg = @2_num2dec_@1( &r, v, d2, s2 );
		if (msg)
			break;
		BUNins(dst, BUNhead(bi,p), &r, FALSE);
	}
	BBPkeepref( *res = dst->batCacheid);
	BBPunfix(b->batCacheid);
	return msg;
}


@c
@:numcastdown(bte,sht)@
@:numcastdown(bte,int)@
@:numcastdown(bte,wrd)@
@:numcastdown(bte,lng)@
@:numcastdown(sht,int)@
@:numcastdown(sht,wrd)@
@:numcastdown(sht,lng)@
@:numcastdown(int,wrd)@
@:numcastdown(int,lng)@
@:numcastdown(wrd,lng)@

str 
month_interval_str( int *ret, str *s, int *d, int *sk )
{
	lng res;

	(void)sk;
	if (interval_from_str( *s, *d, &res ) < 0)
		throw(SQL, "calc.month_interval",
			"wrong format (%s)", *s);
	assert((lng) GDK_int_min <= res && res <= (lng) GDK_int_max);
	*ret = (int) res;
	return MAL_SUCCEED;
}

str 
second_interval_str( lng *res, str *s, int *d, int *sk )
{
	(void)sk;
	if (interval_from_str( *s, *d, res ) < 0)
		throw(SQL, "calc.second_interval",
			"wrong format (%s)", *s);
	return MAL_SUCCEED;
}

@= c_interval
str
month_interval_@1( int *ret, @1 *s, int *d, int *sk ){
	int k = digits2sk(*d);
	int r = (int)*s;

	(void)sk;
	switch(k) {
	case iyear: 	
		r *= 12;
	case imonth:
		break;
	default:
		throw(ILLARG, "calc.month_interval","illegal argument");
	}
	*ret = r;
	return MAL_SUCCEED;
}
str
second_interval_@1( lng *res, @1 *s, int *d, int *sk ){
	int k = digits2sk(*d);
	lng r = *s;

	(void)sk;
	switch(k) {
	case iday: 	
		r *= 24;
	case ihour:
		r *= 60;
	case imin:
		r *= 60;
	case isec:
		break;
	default:
		throw(ILLARG, "calc.second_interval","illegal argument");
	}
	*res = r;
	return MAL_SUCCEED;
}
@c
@:c_interval(bte)@
@:c_interval(sht)@
@:c_interval(int)@
@:c_interval(wrd)@
@:c_interval(lng)@

str
second_interval_daytime( lng *res, daytime *s, int *d, int *sk )
{
	int k = digits2sk(*d);
	lng r = *(int*)s;

	(void)sk;
	switch(k) {
	case isec:
		r /= 1000;
		break;
	case imin:
		r /= 60000;
		break;
	case ihour:
		r /= 3600000;
		break;
	case iday: 	
		r /= (24*3600000);
		break;
	default:
		throw(ILLARG, "calc.second_interval","illegal argument");
	}
	*res = r;
	return MAL_SUCCEED;
}

/* str dump_cache(int *r); */
str
dump_cache(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	mvc *m = NULL;
	str msg = getContext(cntxt,mb, &m, NULL);
	int cnt; 
	BAT *t, *query, *count;
	cq *q = NULL;
	int *r = (int *) getArgReference(stk, pci, 0);

	(void) cntxt;
	if (msg)
		return msg;
	cnt = m->qc->id; 
 	t = BATnew(TYPE_str, TYPE_bat, 1);
	query = BATnew(TYPE_void, TYPE_str, cnt);
	BATseqbase(query, 0);
	count = BATnew(TYPE_void, TYPE_int, cnt);
	BATseqbase(count, 0);
	BUNins(t, "query", &query->batCacheid, FALSE);
	BUNins(t, "count", &count->batCacheid, FALSE);

	for(q = m->qc->q; q; q = q->next) {
		BUNappend(query, q->codestring, FALSE);
		BUNappend(count, &q->count, FALSE);
	}

	BBPunfix(query->batCacheid);
	BBPunfix(count->batCacheid);
	*r = t->batCacheid;
	BBPkeepref(*r);
	return MAL_SUCCEED;
}

/* str dump_opt_stats(int *r); */
str
dump_opt_stats(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	mvc *m = NULL;
	str msg = getContext(cntxt,mb, &m, NULL);
	int cnt; 
	BAT *t, *rewrite, *count;
	int *r = (int *) getArgReference(stk, pci, 0);

	(void) cntxt;
	if (msg)
		return msg;
	cnt = m->qc->id; 
 	t = BATnew(TYPE_str, TYPE_bat, 1);
	rewrite = BATnew(TYPE_void, TYPE_str, cnt);
	BATseqbase(rewrite, 0);
	count = BATnew(TYPE_void, TYPE_int, cnt);
	BATseqbase(count, 0);
	BUNins(t, "rewrite", &rewrite->batCacheid, FALSE);
	BUNins(t, "count", &count->batCacheid, FALSE);

	BUNappend(rewrite, "joinidx", FALSE);
	BUNappend(count, &m->opt_stats[0], FALSE);
	/* TODO add other rewrites */

	BBPunfix(rewrite->batCacheid);
	BBPunfix(count->batCacheid);
	*r = t->batCacheid;
	BBPkeepref(*r);
	return MAL_SUCCEED;
}

/* str dump_opt_stats(int *r); */
str
dump_trace(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	mvc *m = NULL;
	str msg = getContext(cntxt,mb, &m, NULL);
	BAT *t;
	int *r = (int *) getArgReference(stk, pci, 0);

	if (msg)
		return msg;
	t= TRACEtable();
	*r = t->batCacheid;
	BBPkeepref(*r);
	return MAL_SUCCEED;
}

/* str sql_rowid(oid *rid, ptr v, str *sname, str *tname); */
str 
sql_rowid(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	BAT *b;
	mvc *m = NULL;
	str msg = getContext(cntxt,mb, &m, NULL);
	sql_schema *s = NULL;
	sql_table *t = NULL;
	sql_column *c = NULL;
	sql_delta *d;
	oid *rid = (oid *) getArgReference(stk, pci, 0);
	str *sname = (str *) getArgReference(stk, pci, 2);
	str *tname = (str *) getArgReference(stk, pci, 3);

	(void) cntxt;
	if (msg)
		return msg;
	s = mvc_bind_schema(m, *sname);
	if ( s == NULL)
		throw(MAL,"sql.rowid","Schema missing");
	t = mvc_bind_table(m, s, *tname);
	if ( s == NULL)
		throw(MAL,"sql.rowid","Table missing");
	if (!s || !t || !t->columns.set->h)
                throw(SQL, "calc.rowid", "Cannot find column");
	c = t->columns.set->h->data;
	/* HACK, get insert bat */
	b = store_funcs.bind_col(m->session->tr, c, RD_INS);
	/* UGH (move into storage backends!!) */
	d = c->data;
	*rid = d->ibase + BATcount(b);
	BBPunfix(b->batCacheid);
	return MAL_SUCCEED;
}

@= rnk
str 
sql_@1rank_grp(bat *rid, bat *bid, bat *gid, bat *gpe)
{
	BAT *r, *b, *g;
	BUN p, q;
	BATiter bi, gi;
	int (*ocmp)(ptr, ptr), (*gcmp)(ptr, ptr);
	ptr oc, gc;
	int rank = 1, nrank = @3;

	if( (b = BATdescriptor(*bid)) == NULL )
		throw(SQL, "sql.@1rank_grp", "Cannot access descriptor");
	if( (g = BATdescriptor(*gid)) == NULL )
		throw(SQL, "sql.@1rank_grp", "Cannot access descriptor");
	(void)gpe;
	bi = bat_iterator(b);
	gi = bat_iterator(g);
	ocmp = BATatoms[b->ttype].atomCmp;
	gcmp = BATatoms[g->ttype].atomCmp;
	oc = BUNtail(bi, BUNfirst(b));
	gc = BUNtail(gi, BUNfirst(g));
	if (!ALIGNsynced(b, g))
		throw(SQL, "sql.@1rank_grp", "bats not aligned");
	if (BATtordered(b) != GDK_SORTED)
		throw(SQL, "sql.@1rank_grp", "bat not sorted");
	r = BATnew(TYPE_oid, TYPE_int, BATcount(b));
	if (r == NULL)
		throw(SQL, "sql.@1rank_grp", "cannot allocate result bat");
	BATloop(b, p, q) {
		ptr on = BUNtail(bi, p);
		ptr gn = BUNtail(gi, p);
		int c = 0;

		if ((c = ocmp(on, oc)) != 0) 
			rank = nrank;
		if (gcmp(gn, gc) != 0) 
			c = rank = nrank = 1;  
		oc = on;
		gc = gn;
		BUNins(r, BUNhead(bi,p), &rank, FALSE);
		@2;
	}
	BBPunfix(b->batCacheid);
	BBPunfix(g->batCacheid);
	BBPkeepref(*rid = r->batCacheid);
	return MAL_SUCCEED;
}

str
sql_@1rank(bat *rid, bat *bid)
{ 
	BAT *r, *b;
	BATiter bi;
	int (*cmp)(ptr, ptr);
	ptr cur;
	BUN p, q;
	int rank = 1, nrank = @3;

	if( (b = BATdescriptor(*bid)) == NULL )
		throw(SQL, "sql.@1rank", "Cannot access descriptor");
	if (BATtordered(b) != GDK_SORTED)
		throw(SQL, "sql.@1rank", "bat not sorted");
	bi = bat_iterator(b);
	cmp = BATatoms[b->ttype].atomCmp;
	cur = BUNtail(bi, BUNfirst(b));
	r = BATnew(TYPE_oid, TYPE_int, BATcount(b));
	if (r == NULL)
		throw(SQL, "sql.@1rank", "cannot allocate result bat");
	if (BATtdense(b)) {
		BATloop(b, p, q) {
			BUNins(r, BUNhead(bi,p), &rank, FALSE);
			rank++;
		}
	} else {
		BATloop(b, p, q) {
			ptr n = BUNtail(bi, p);
			int c = 0;
	
			if ((c = cmp(n, cur)) != 0) 
				rank = nrank; 
			cur = n;
			BUNins(r, BUNhead(bi,p), &rank, FALSE);
			@2;
		}
	}
	BBPunfix(b->batCacheid);
	BBPkeepref(*rid = r->batCacheid);
	return MAL_SUCCEED;
}
@c
@:rnk(,(void)c;nrank++,1)@
@:rnk(dense_,nrank+=(c?1:0),2)@

str SQLargRecord(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	str *ret;

	(void) cntxt;
	ret= (str *) getArgReference(stk,pci,0);
	*ret = instruction2str(mb,stk,getInstrPtr(mb,0),LIST_MAL_VALUE);
	return MAL_SUCCEED;
}

@-
The table is searched for all columns and they are
re-clustered on the hash value over the  primary key. 
Initially the first column
@c

str SQLcluster(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	str *sch = (str *) getArgReference(stk,pci,1);
	str *tbl = (str *) getArgReference(stk,pci,2);
	sql_trans	*tr;
	sql_schema	*s;
	sql_table 	*t;
	sql_column	*c;
	mvc *m = NULL;
	str msg = getContext(cntxt,mb, &m, NULL);
	int first=1;
	bat mid, hid, bid;
	BAT *map= NULL, *b;
	node *o;

	if (msg)
		return msg;
   	s = mvc_bind_schema(m, *sch);
	if ( s == NULL)
		throw(MAL,"sql.cluster","Schema missing");
	t = mvc_bind_table(m, s, *tbl);
	if ( t == NULL)
		throw(MAL,"sql.cluster","Table missing");
	tr = m->session->tr;
	t->base.wtime = s->base.wtime = tr->wtime = tr->stime;
	t->base.rtime = s->base.rtime = tr->rtime = tr->stime;

	/* actually build the hash on the multi-column primary key */

	for (o = t->columns.set->h; o; o = o->next) {
		sql_delta *d;
		c = o->data;
		if (first) {
			first = 0;
			b = store_funcs.bind_col(tr, c, 0);
			msg = CLUSTER_key(&hid, &b->batCacheid);
			BBPreleaseref(b->batCacheid);
			if (msg)
				return msg;
			msg = CLUSTER_map(&mid,&hid);
			BBPdecref(hid, TRUE);
			if (msg)
				return msg;
			map = BATdescriptor(mid);
			if (map== NULL)
				throw(MAL,"sql.cluster","Can not access descriptor");
		}

		b = store_funcs.bind_col(tr, c, 0);
		if (b == NULL)
			throw(MAL,"sql.cluster","Can not access descriptor");
		msg = CLUSTER_apply(&bid, b, map);
		BBPreleaseref(b->batCacheid);
		if (msg){
			BBPreleaseref(map->batCacheid);
			return msg;
		}
		BBPdecref(b->batCacheid, TRUE);
		d = c->data;
		d->bid = 0;
		d->ibase = 0;
		d->ibid = bid; /* use the insert bat */
		c->base.wtime = c->base.rtime = tr->stime;
	}
	/* bat was cleared */
	t->cleared = 1;
	if (map) {
		BBPreleaseref(map->batCacheid);
		BBPdecref(mid, TRUE);
	}
	return MAL_SUCCEED;
}

str 
SQLcluster2(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	str *sch = (str *) getArgReference(stk,pci,1);
	str *tbl = (str *) getArgReference(stk,pci,2);
	sql_trans	*tr;
	sql_schema	*s;
	sql_table 	*t;
	sql_column	*c;
	mvc *m = NULL;
	str msg = getContext(cntxt,mb, &m, NULL);
	int first=1;
	bat mid, hid, bid;
	BAT *b;
	node *o;

	if (msg)
		return msg;
   	s = mvc_bind_schema(m, *sch);
	if ( s == NULL)
		throw(MAL,"sql.cluster","Schema missing");
	t = mvc_bind_table(m, s, *tbl);
	if ( t == NULL)
		throw(MAL,"sql.cluster","Table missing");
	tr = m->session->tr;

        t->base.wtime = s->base.wtime = tr->wtime = tr->stime;
        t->base.rtime = s->base.rtime = tr->rtime = tr->stime;
	for (o = t->columns.set->h; o; o = o->next) {
		sql_delta *d;
		c = o->data;
		if (first) {
			bat psum;
			unsigned int bits = 10, off = 0;
			first = 0;
			b = store_funcs.bind_col(tr, c, 0);
			msg = MKEYbathash(&hid, &b->batCacheid);
			BBPreleaseref(b->batCacheid);
			if (msg)
				return msg;
			msg = CLS_create_wrd(&psum, &mid, &hid, &bits, &off);
			BBPdecref(hid, TRUE);
			BBPdecref(psum, TRUE);
			if (msg)
				return msg;
		}

		b = store_funcs.bind_col(tr, c, 0);
		if (b == NULL)
			throw(MAL,"sql.cluster","Can not access descriptor");
		msg = CLS_map(&bid,&mid,&b->batCacheid);
		BBPreleaseref(b->batCacheid);
		if (msg){
			BBPreleaseref(bid);
			return msg;
		}
		BBPdecref(b->batCacheid, TRUE);

		d = c->data;
		/* its probably an empty bat which we shouldn't free 
		BBPdecref(d->ibid, TRUE);*/
		d->bid = 0;	
		d->ibase = 0;
		d->ibid = bid; /* use the insert bat */

		c->base.wtime = c->base.rtime = tr->stime;
	}
	/* bat was cleared */
	t->cleared = 1;
	return MAL_SUCCEED;
}

@- Shredding RDF documents through SQL
Wrapper around the RDF shredder of the rdf module of M5. The first time
the database is going to be used for rdf run sql/src/sql/rdf.sql.

An rdf file can be now shreded with SQL command:
CALL rdf_shred('/path/to/location','graph name');

The table rdf.graph will be updated with an entry of the form:
[graph name, graph id] -> [gname,gid].

In addition all permutation of SPO for the specific rdf document will be
created. The name of the triple tables are rdf.pso$gid$, rdf.spo$gid$ etc.
For example if gid = 3 then rdf.spo3 is the triple table ordered on subject,
property, object. Finally, there is one more table called rdf.map$gid$ that
maps oids to strings (i.e., the lexical representation).

@= crt_tbl
sprintf(buff, "@2%d", @1);
@2_tbl = mvc_create_table(m, sch, buff, 0, SQL_PERSIST, 0, 3);
mvc_create_column(m, @2_tbl, "@3", &tpe);
mvc_create_column(m, @2_tbl, "@4", &tpe);
mvc_create_column(m, @2_tbl, "@5", &tpe);

@= crt_col
s = BATdescriptor(g[@2]);
p = BATdescriptor(g[@3]);
o = BATdescriptor(g[@4]);
store_funcs.append_col(m->session->tr, mvc_bind_column(m, @1, "subject"),
		s, TYPE_bat);
store_funcs.append_col(m->session->tr, mvc_bind_column(m, @1, "property"),
		p, TYPE_bat);
store_funcs.append_col(m->session->tr, mvc_bind_column(m, @1, "object"),
		o, TYPE_bat);
BBPunfix(s->batCacheid);
BBPunfix(p->batCacheid);
BBPunfix(o->batCacheid);


@c
str
SQLrdfShred(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
#ifdef HAVE_MONETDB5_RDF
	bat docbats;
	BAT *graph = NULL;
	BAT *p, *s, *o;
	bat *g;
	sql_schema *sch;
	sql_table *g_tbl;
	sql_column *gname, *gid;
	sql_table *spo_tbl, *sop_tbl, *pso_tbl, *pos_tbl, *osp_tbl, *ops_tbl;
	sql_table *map_tbl;
	sql_subtype tpe;
	str *location = (str *) getArgReference(stk,pci,1);
	str *name = (str *) getArgReference(stk,pci,2);
	char buff[24];
	mvc *m = NULL;
	int id = 0;
	oid rid = oid_nil;

	str msg = getContext(cntxt, mb, &m, NULL);
	if (msg)
		return msg;

	sch = mvc_bind_schema(m, "rdf");
	if ( sch == NULL)
		throw(MAL,"sql.rdfSchred","Schema missing");
	g_tbl = mvc_bind_table(m, sch, "graph");
	gname = mvc_bind_column(m, g_tbl, "gname");
	gid = mvc_bind_column(m, g_tbl, "gid");

	rid = table_funcs.column_find_row(m->session->tr, gname, *name, NULL);
	if (rid != oid_nil) {
		throw(SQL,"sql.rdfShred","graph name allready exists in rdf.graph");
	}
	id = (int) store_funcs.count_col(gname);
	store_funcs.append_col(m->session->tr, gname, *name, TYPE_str);
	store_funcs.append_col(m->session->tr, gid, &id, TYPE_int);

	msg = RDFParser(&docbats, location, name);
	if (msg)
		return msg;

	if (sizeof(oid) == 8) {
		sql_find_subtype(&tpe, "oid", 31, 0);
		/* todo for niels: if use int/bigint the @0 is serialized */
		/* sql_find_subtype(&tpe, "bigint", 64, 0); */
	} else {
		sql_find_subtype(&tpe, "oid", 31, 0);
		/* sql_find_subtype(&tpe, "int", 32, 0); */
	}
	@:crt_tbl(id,spo,subject,property,object)@
	@:crt_tbl(id,sop,subject,object,property)@
	@:crt_tbl(id,pso,property,subject,object)@
	@:crt_tbl(id,pos,property,object,subject)@
	@:crt_tbl(id,osp,object,subject,property)@
	@:crt_tbl(id,ops,object,property,subject)@

	sprintf(buff, "map%d", id);
	map_tbl = mvc_create_table(m, sch, buff, 0, SQL_PERSIST, 0, 2);
	mvc_create_column(m, map_tbl, "sid", &tpe);
	sql_find_subtype(&tpe, "varchar", 1024, 0);
	mvc_create_column(m, map_tbl, "lexical", &tpe);

	if ((graph = BATdescriptor(docbats)) == NULL) {
		throw(SQL, "sql.rdfShred", "docbat is missing");
	}
	g = (bat *) Tloc(graph, BUNfirst(graph));

	s =  BATdescriptor(g[MAP_LEX]);
	if ( s == NULL){
		BBPreleaseref(graph->batCacheid);
		throw(SQL, "sql.rdfShred", "map_lex is missing");
	}

	store_funcs.append_col(m->session->tr,
			mvc_bind_column(m, map_tbl, "lexical"), s, TYPE_bat);
	store_funcs.append_col(m->session->tr,
			mvc_bind_column(m, map_tbl, "sid"),
			BATmark(s, 0),
			TYPE_bat);
	BBPunfix(s->batCacheid);

	@:crt_col(spo_tbl,S_sort,P_PO,O_PO)@
	@:crt_col(sop_tbl,S_sort,P_OP,O_OP)@
	@:crt_col(pso_tbl,S_SO,P_sort,O_SO)@
	@:crt_col(pos_tbl,S_OS,P_sort,O_OS)@
	@:crt_col(osp_tbl,S_SP,P_SP,O_sort)@
	@:crt_col(ops_tbl,S_PS,P_PS,O_sort)@

	/* unfix graph */
	BBPunfix(graph->batCacheid);

	return MAL_SUCCEED;
#else
	(void) cntxt; (void) mb; (void) stk; (void) pci;
	throw(SQL, "sql.rdfShred", "RDF support is missing from Monet5");
#endif
}
