@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2006 CWI.
@' All Rights Reserved.

@f sql
@t SQL Scenario implementation
@a M Kersten 
@v 0
@* SQL support implementation
This module contains the wrappers around the SQL 
multi-version-catalog and support routines copied
from the Version 4 code base.

@mal
module sql;

command start():void 
address SQLsession
comment "Switch to processing SQL statements";

command trace():void 
address SQLtrace
comment "enable/disable saving the sql statement traces (per client)";

command init():void
address SQLinitEnvironment
comment "Initialize the environment for MAL";

command commit():void
address SQLcommit_wrap;
command rollback():void
address SQLrollback_wrap;

command eval(cmd:str):str 
address SQLstatement
comment "Execute a single sql statement";

command assert(b:bit,msg:str):void
address SQLassert
comment "Generate an exception when b==true";

command assert(b:int,msg:str):void
address SQLassertInt
comment "Generate an exception when b!=0";

command assert(b:lng,msg:str):void
address SQLassertLng
comment "Generate an exception when b!=0";

@- The SQL multi-version catalog
This module also contains the definitions for managing an SQL database schema in
version 5.  It is an adaptation of the original V4.3 code base. 
A main difference is that the global catalog is obtained from
the client record, rather then lookup the variable in a context stack.

The MAL operations below are used in the SQL->MAL compiler and
can be (sparingly) used to inspect it from a MIL console.
The 'mvc_' header is removed, because all commands are already
prepended by the 'sql.' module name.
The original code is retained, because it makes it
easier to later re-use part of the catalog code in a separately.
@mal

command setVariable( varname:str ):void
address mvc_update_var_wrap
comment "Update a session variable";

command nextValue( sequence:str ):lng
address mvc_next_value
comment "return the next value of the sequence";

command bind_dbat(sname:str, tname:str, access:int):bat[:any_1,:any_2]
address mvc_bind_dbat_wrap
comment "Bind the table deletes bat, tname.delete 
	with specific access modes";

command bind_idxbat(sname:str, tname:str, iname:str, access:int):bat[:any_1,:any_2]
address mvc_bind_idxbat_wrap
comment "Bind the idx bat, tname.idx
	with specific accsess modes";

command append_idxbat(sname:str, tname:str, iname:str, access:int, b:bat[:oid,:any_1] ):bat[:any_1,:any_2]
address mvc_append_idxbat_wrap;
command append_idxbat(sname:str, tname:str, iname:str, access:int, b:bat[:void,:any_1] ):bat[:any_1,:any_2]
address mvc_append_idxbat_wrap
comment "Append b to the column tname.iname (possibly optimized to replace the insert bat of tname.iname";

command bind(sname:str, tname:str, cname:str, access:int ):bat[:any_1,:any_2]
address mvc_bind_wrap
comment "Bind the bat tname.cname into the focus with specific access mode";

command append(sname:str, tname:str, cname:str, access:int, b:bat[:oid,:any_1] ):bat[:any_1,:any_2]
address mvc_append_wrap;
command append(sname:str, tname:str, cname:str, access:int, b:bat[:void,:any_1] ):bat[:any_1,:any_2]
address mvc_append_wrap
comment "Append b to the column tname.cname (possibly optimized to replace the insert bat of tname.cname";

command clear_table(sname:str, tname:str) :lng
address mvc_clear_table_wrap
comment "Clear table";

command columnBind(b:bat[:str,:bat], nme:str) :bat[:any_1,:any_2]
address mvc_bind_single_wrap
comment "Bind the column bat into the focus ";

@-
The Monet 5 code generator uses several SQL specific wrapper functions.
They are not present in V4
@mal
command resultSet( nr_cols:int, qtype:int, order:bat[:void,:any_1] ) :int 
address mvc_result_table_wrap
comment "Prepare a table result set"; 

command resultSet( nr_cols:int, qtype:int, order:bat[:oid,:any_1] ) :int 
address mvc_result_table_wrap
comment "Prepare a table result set"; 

command resultSet( nr_cols:int, qtype:int, order:any_1 ) :int 
address mvc_result_row_wrap
comment "Prepare a row result set"; 

command rsColumn(rs:int, tname:str, name:str, typename:str, digits:int, scale:int, col:bat[:void,:any_1] ) :void
address mvc_result_column_wrap
comment "Add the colunm to the table query result";

command rsColumn(rs:int, tname:str, name:str, typename:str, digits:int, scale:int, col:bat[:oid,:any_1] ) :void
address mvc_result_column_wrap
comment "Add the colunm to the table query result";

pattern rsColumn(rs:int, tname:str, name:str, typename:str, digits:int, scale:int, val:any_1 ) :void
address mvc_result_value_wrap
comment "Add the value to the row query result";

command rsColumn(rs:int, tname:str, name:str, typename:str, digits:int, scale:int, val:sht ) :void
address mvc_result_value_sht;
command rsColumn(rs:int, tname:str, name:str, typename:str, digits:int, scale:int, val:lng ) :void
address mvc_result_value_lng;
command rsColumn(rs:int, tname:str, name:str, typename:str, digits:int, scale:int, val:int ) :void
address mvc_result_value_int;

command exportResult(res_id:int ) :void
address mvc_export_result_wrap
comment "Export a result (in order) to stream s"; 

command exportOperation() :void
address mvc_export_operation_wrap
comment "Export result of schema/transaction queries"; 

command affectedRows( nr:int ) :void
address mvc_affected_rows_int
comment "export the number of affected rows by the current query";

command affectedRows( nr:lng ) :void
address mvc_affected_rows_wrap
comment "export the number of affected rows by the current query";

pattern exportValue( qtype:int, tname:str, name:str, typename:str, digits:int, scale:int, eclass:int, val:any_1 )
address mvc_export_value_wrap 
comment "export a single value onto the stream s";

command importTable( s:bstream, tname:str, 
	sep:str, rsep:str, nr:int) :bat[:str,:bat] 
address mvc_import_table_wrap
comment "Import a table from bstream s with the 
	given tuple and seperators (sep/rsep)";

@- SQL function aliases
The code generate should identify the precise module
target for all functions. This creates quite some
administration overhead and analysis at many places.
The alternative is to extend modules with an alias.

The routine below are added to the calc module to
ease code generation.
@mal
pattern calc.rotate_xor_hash(h:int, nbits:int, v:any_1) :int address MKEYrotate_xor_hash;
command batcalc.rotate_xor_hash(h:bat[:oid,:int], nbits:int, b:bat[:oid,:any_1]) :bat[:oid,:int] address MKEYbulk_rotate_xor_hash;

pattern calc.hash( v:any ) :int address MKEYhash; 
command calc.hash( v:chr ) :int address MKEYhash_chr; 
command calc.hash( v:sht ) :int address MKEYhash_sht; 
command calc.hash( v:int ) :int address MKEYhash_int; 
command calc.hash( v:flt ) :int address MKEYhash_flt; 
command calc.hash( v:dbl ) :int address MKEYhash_dbl; 
command calc.hash( v:lng ) :int address MKEYhash_lng; 
command calc.hash( v:str ) :int address MKEYhash_str; 

command batcalc.hash( b:bat[:void,:any_1] ) :bat[:void,:int]
address voidbathash_wrap 
comment "calculate a hash value";

command batcalc.hash( b:bat[:oid,:any_1] ) :bat[:oid,:int]
address bathash_wrap 
comment "calculate a hash value";

#command batstr.hash( b:bat[:void,:str] ) :bat[:void,:int]
#address bathash_wrap 
#comment "calculate a hash value";


command calc.timestamp(s:str):timestamp
address MTIMEtimestamp_fromstr;
command calc.timestamp(d:timestamp):timestamp
address MTIMEtimestamp_timestamp;
command calc.==(a:timestamp,b:timestamp):bit
address MTIMEtimestamp_EQ;
command calc.!=(a:timestamp,b:timestamp):bit
address MTIMEtimestamp_NEQ;
command calc.<(a:timestamp,b:timestamp):bit
address MTIMEtimestamp_LT;
command calc.<=(a:timestamp,b:timestamp):bit
address MTIMEtimestamp_LE;
command calc.>(a:timestamp,b:timestamp):bit
address MTIMEtimestamp_GT;
command calc.>=(a:timestamp,b:timestamp):bit
address MTIMEtimestamp_GE;
command calc.isnil(v:timestamp):bit
address MTIMEtimestamp_isnil
        comment "Nil test for timestamp value";


command calc.date(s:str):date
address MTIMEdate_fromstr;
command calc.date(d:date):date
address MTIMEdate_date;
command calc.==(a:date,b:date):bit
address MTIMEdate_EQ;
command calc.!=(a:date,b:date):bit
address MTIMEdate_NEQ;
command calc.<(a:date,b:date):bit
address MTIMEdate_LT;
command calc.<=(a:date,b:date):bit
address MTIMEdate_LE;
command calc.>(a:date,b:date):bit
address MTIMEdate_GT;
command calc.>=(a:date,b:date):bit
address MTIMEdate_GE;
command calc.isnil(v:date):bit
address MTIMEdate_isnil
        comment "Nil test for date1 value";
command calc.current_date():date
address MTIMEcurrent_date;

command calc.timestamp_sub_sec_interval(t:timestamp,s:lng):timestamp address MTIMEtimestamp_sub_sec_interval_lng_wrap;
command calc.timestamp_add_sec_interval(t:timestamp,s:lng):timestamp address MTIMEtimestamp_add_sec_interval_lng_wrap;
command calc.timestamp_sub_month_interval(t:timestamp,s:int):timestamp address MTIMEtimestamp_sub_month_interval_wrap;
command calc.timestamp_add_month_interval(t:timestamp,s:int):timestamp address MTIMEtimestamp_add_month_interval_wrap;

command calc.time_add_sec_interval(t:daytime,s:lng):daytime address MTIMEtime_add_sec_interval_wrap;
command calc.time_sub_sec_interval(t:daytime,s:lng):daytime address MTIMEtime_sub_sec_interval_wrap;
command calc.date_sub_sec_interval(t:date,s:int):date address MTIMEdate_sub_sec_interval_wrap;
command calc.date_sub_sec_interval(t:date,s:lng):date address MTIMEdate_sub_sec_interval_lng_wrap;
command calc.date_add_sec_interval(t:date,s:int):date address MTIMEdate_add_sec_interval_wrap;
command calc.date_add_sec_interval(t:date,s:lng):date address MTIMEdate_add_sec_interval_lng_wrap;
command calc.date_add_month_interval(t:date,s:int):date address MTIMEdate_add_month_interval_wrap;


command calc.year(d:date) :int
address MTIMEdate_extract_year;
command calc.year(d:bat[:any_1,:date]):bat[:any_1,:int]
address MTIMEdate_extract_year_bulk;;

command calc.month(d:date) :int
address MTIMEdate_extract_month;
command calc.month(d:bat[:any_1,:date]):bat[:any_1,:int]
address MTIMEdate_extract_month_bulk;;

command calc.day(d:date) :int
address MTIMEdate_extract_day;
command calc.day(d:bat[:any_1,:date]):bat[:any_1,:int]
address MTIMEdate_extract_day_bulk;;

# daytime
command calc.daytime(d:daytime):daytime
address MTIMEdaytime2daytime;
command calc.daytime(s:lng):daytime
address MTIMEsecs2daytime;
command calc.hours(h:daytime) :int
address MTIMEdaytime_extract_hours;
command calc.hours(d:bat[:any_1,:date]):bat[:any_1,:int]
address MTIMEdaytime_extract_hours_bulk;;

command calc.minutes(d:daytime) :int
address MTIMEdaytime_extract_minutes;
command calc.minutes(d:bat[:any_1,:date]):bat[:any_1,:int]
address MTIMEdaytime_extract_minutes_bulk;;
command calc.seconds(d:daytime) :int
address MTIMEdaytime_extract_seconds;
command calc.seconds(d:bat[:any_1,:date]):bat[:any_1,:int]
address MTIMEdaytime_extract_seconds_bulk;;

command calc.milliseconds(d:daytime) :int
address MTIMEdaytime_extract_milliseconds;
command calc.milliseconds(d:bat[:any_1,:date]):bat[:any_1,:int]
address MTIMEdaytime_extract_milliseconds_bulk;;
command calc.isnil(v:daytime):bit
address MTIMEdaytime_isnil
        comment "Nil test for daytime value";

# timestamp
command calc.timestamp(t:timestamp):timestamp
address MTIMEtimestamp2timestamp;
command calc.daytime(t:timestamp) :daytime
address MTIMEtimestamp_extract_daytime_default;
command calc.daytime(t:timestamp, v:timezone) :daytime
address MTIMEtimestamp_extract_daytime;

command calc.date(t:timestamp) :date
address MTIMEtimestamp_extract_date_default;
command calc.date(t:timestamp,v:timezone) :date
address MTIMEtimestamp_extract_date;

# timezone
command calc.local_timezone() :lng address MTIMElocal_timezone;
command calc.timezone(name:str):timezone address MTIMEtimezone;

command calc.start_dst(t:timezone) :zrule address MTIMEtzone_extract_start;
command calc.end_dst(t:timezone) :zrule address MTIMEtzone_extract_end;
command calc.minutes(t:timezone) :int address MTIMEtzone_extract_minutes;

# zrule
command calc.month(t:zrule) :int address MTIMErule_extract_month;
command calc.day(t:zrule) :int	address MTIMErule_extract_day;
command calc.weekday(t:zrule) :int address MTIMErule_extract_weekday;
command calc.minutes(t:zrule) :int address MTIMErule_extract_minutes;

#SQL specific time support functions
command calc.current_timestamp() :timestamp address MTIMEcurrent_timestamp;
command calc.current_date() :date address MTIMEcurrent_date;
command calc.current_time() :daytime address MTIMEcurrent_time;

# utility functions (for SQL) for direct extraction of fields from timestamps
command calc.year(t:timestamp) :int address MTIMEtimestamp_year;
command calc.month(t:timestamp) :int address MTIMEtimestamp_month;
command calc.day(t:timestamp) :int address MTIMEtimestamp_day;
command calc.hours(t:timestamp) :int address MTIMEtimestamp_hours;
command calc.minutes(t:timestamp) :int address MTIMEtimestamp_minutes;
command calc.seconds(t:timestamp) :int address MTIMEtimestamp_seconds;
command calc.milliseconds(t:timestamp) :int address MTIMEtimestamp_milliseconds;

command calc.year(months:int) :int address MTIMEsql_year;
command calc.month(months:int) :int address MTIMEsql_month;
command calc.day(secs:lng) :int address MTIMEsql_day;
command calc.hours(secs:lng) :int address MTIMEsql_hours;
command calc.minutes(secs:lng) :int address MTIMEsql_minutes;
command calc.seconds(secs:lng) :int address MTIMEsql_seconds;

command calc.addyears(value:date, years:int) :date address MTIMEdate_addyears;
command calc.addmonths(value:date, months:int) :date address MTIMEdate_addmonths;
command calc.adddays(value:date, days:int) :date address MTIMEdate_adddays;
command calc.diff(val1:date, val2:date) :int address MTIMEdate_diff; 
command calc.dayofyear(d:date) :int address MTIMEdate_extract_dayofyear;
command calc.weekofyear(d:date) :int address MTIMEdate_extract_weekofyear;
command calc.dayofweek(d:date) :int address MTIMEdate_extract_dayofweek;
command calc.add(v:timestamp, msecs:lng) :timestamp address MTIMEtimestamp_add; 
command calc.diff(val1:timestamp, val2:timestamp) :lng address MTIMEtimestamp_diff;

# string 
command calc.toLower( s:str ) :str address STRLower;
command calc.toUpper( s:str ) :str address STRUpper;

command calc.trim( s:str ) :str address STRStrip;
command calc.ltrim( s:str ) :str address STRLtrim;
command calc.rtrim( s:str ) :str address STRRtrim;
command calc.substitute(s:str,src:str,dst:str,rep:bit):str
address STRSubstitute;
command calc.substring(s:str,offset:int):str
address STRsubstringTail;
command calc.substring(s:str,offset:int,count:int):str
address STRsubstring;

command calc.stringleft(s:str,l:int):str
address STRprefix;
command calc.stringright(s:str,l:int):str
address STRsuffix;

command calc.stringlength( s:str ) :int 
address STRstringLength;

# math 
command calc.acos(x:flt):flt address MATHunary_ACOSflt;
command calc.acos(x:dbl):dbl address MATHunary_ACOSdbl;
command calc.asin(x:flt):flt address MATHunary_ASINflt;
command calc.asin(x:dbl):dbl address MATHunary_ASINdbl;
command calc.atan(x:flt):flt address MATHunary_ATANflt;
command calc.atan(x:dbl):dbl address MATHunary_ATANdbl;
command calc.atan2(x:flt,y:flt):flt address MATHbinary_ATAN2flt;
command calc.atan2(x:dbl,y:dbl):dbl address MATHbinary_ATAN2dbl;
command calc.cos(x:flt):flt address MATHunary_COSflt;
command calc.cos(x:dbl):dbl address MATHunary_COSdbl;
command calc.sin(x:flt):flt address MATHunary_SINflt;
command calc.sin(x:dbl):dbl address MATHunary_SINdbl;
command calc.tan(x:flt):flt address MATHunary_TANflt;
command calc.tan(x:dbl):dbl address MATHunary_TANdbl;
command calc.cosh(x:flt):flt address MATHunary_COSHflt;
command calc.cosh(x:dbl):dbl address MATHunary_COSHdbl;
command calc.sinh(x:flt):flt address MATHunary_SINHflt;
command calc.sinh(x:dbl):dbl address MATHunary_SINHdbl;
command calc.tanh(x:flt):flt address MATHunary_TANHflt;
command calc.tanh(x:dbl):dbl address MATHunary_TANHdbl;
command calc.exp(x:flt):flt address MATHunary_EXPflt;
command calc.exp(x:dbl):dbl address MATHunary_EXPdbl;
command calc.log(x:dbl):dbl address MATHunary_LOGdbl;
command calc.log10(x:dbl):dbl address MATHunary_LOG10dbl;
#/* TODO */
command calc.floor(y:flt):flt address MATHunary_FLOORflt;
command calc.floor(y:dbl):dbl address MATHunary_FLOORdbl;

@- SQL functions
The SQL functions are all recognized by their module name.
For some we need to provide a new implementation, others
merely require a different address binding.

The aggregate operations work on doubles by default.
This calls for casting values around in the process.
@= mal_round
command calc.round( v:@1, r:@1 ) :@1 
address @1_round_wrap
comment "round off the value v to nearests multiple of r";
command calc.round( v:@1, r:dbl ) :@1 
address @1_dbl_round_wrap
comment "round off the value v to nearests multiple of r";
command calc.round( v:@1, r:int ) :@1 
address @1_int_round_wrap
comment "round off the value v to nearests multiple of r";

@mal

command aggr.exist(b:bat[:any_1,:any_2], h:any_1):bit 
address ALGexist;

@:mal_round(sht)@
@:mal_round(int)@
@:mal_round(lng)@

command calc.round( v:flt, r:flt ) :flt 
address flt_flt_round_wrap
comment "round off the value v to nearests multiple of r";
command calc.round( v:flt, r:int ) :flt 
address flt_int_round_wrap
comment "round off the value v to nearests multiple of r";
command calc.round( v:dbl, r:dbl ) :dbl 
address dbl_dbl_round_wrap
comment "round off the value v to nearests multiple of r";
command calc.round( v:dbl, r:int ) :dbl
address dbl_int_round_wrap
comment "round off the value v to nearests multiple of r";

@= mal_cast
command calc.@1( v:str ) :@1 
address str_2_@1
comment "Cast to @1";
#address CALCstr2@1
#command calc.str( v:@1 ) :str
#address CALC@12str
#comment "Cast @1 to str";
command calc.@1( v:str, digits:int ) :@1 
address str_2num_@1
comment "cast to @1 and check for overflow";
command calc.@1( v:str, digits:int, scale:int ) :@1 
address str_2dec_@1
comment "cast to dec(@1) and check for overflow";
@mal
@:mal_cast(sht)@
@:mal_cast(int)@
@:mal_cast(lng)@

@= mal_castfromstr
#address CALCstr2@1
command calc.@1( v:str ) :@1 
address str_2_@1
comment "cast to @1";
@mal
@:mal_castfromstr(flt)@
@:mal_castfromstr(dbl)@
@:mal_castfromstr(timestamp)@
@:mal_castfromstr(daytime)@
@:mal_castfromstr(date)@

@mal
command calc.str( v:bit) :str 
address CALCbit2str
comment "Idempotent cast of strings";
command calc.str( v:str) :str 
address CALCstr2str
comment "Idempotent cast of strings";

command calc.sht( v:bit) :sht 
address CALCbit2sht
comment "Cast bit to sht ";
command calc.int( v:bit) :int 
address CALCbit2int
comment "Cast bit to int ";
command calc.lng( v:bit) :lng 
address CALCbit2lng
comment "Cast bit to lng ";

#command calc.str( v:any_1, digits:int ) :str 
pattern calc.str( eclass:int, d1:int, s1:int, has_tz:int, v:any_1, digits:int ) :str 
address SQLstr_cast
comment "cast to string and check for overflow";

@= mal_cast_2dec
#address CALC@22@1
command calc.@1( v:@2) :@1 
address @2_2_@1
comment "cast @2 to @1";
command calc.@1( v:@2, digits:int, scale:int ) :@1 
address @2_num2dec_@1
comment "cast number to decimal(@1) and check for overflow";
@mal
@:mal_cast_2dec(sht,flt)@
@:mal_cast_2dec(int,flt)@
@:mal_cast_2dec(lng,flt)@
@:mal_cast_2dec(sht,dbl)@
@:mal_cast_2dec(int,dbl)@
@:mal_cast_2dec(lng,dbl)@

@= mal_cast_dec2
command calc.@1( s1:int, v:@2) :@1 
address @2_dec2_@1
comment "cast decimal(@2) to @1 and check for overflow";
command calc.@1( s1:int, v:@2, d2:int, s2:int ) :@1 
address @2_dec2dec_@1
comment "cast decimal(@2) to decimal(@1) and check for overflow";
@mal

@= mal_cast2
@:mal_cast_2dec(@1,@2)@
@:mal_cast_dec2(@1,@2)@
@mal
@:mal_cast2(sht,sht)@
@:mal_cast2(sht,int)@
@:mal_cast2(sht,lng)@
@:mal_cast2(int,sht)@
@:mal_cast2(int,int)@
@:mal_cast2(int,lng)@
@:mal_cast2(lng,sht)@
@:mal_cast2(lng,int)@
@:mal_cast2(lng,lng)@
@:mal_cast2(flt,sht)@
@:mal_cast2(flt,int)@
@:mal_cast2(flt,lng)@
@:mal_cast2(dbl,sht)@
@:mal_cast2(dbl,int)@
@:mal_cast2(dbl,lng)@

@= mal_interval
command calc.month_interval( v:@1, ek:int, sk:int ) :int
address month_interval_@1
comment "cast @1 to a month_interval and check for overflow";

command calc.second_interval( v:@1, ek:int, sk:int ) :lng
address second_interval_@1
comment "cast @1 to a month_interval and check for overflow";
@mal

@:mal_interval(str)@
@:mal_interval(sht)@
@:mal_interval(int)@
@:mal_interval(lng)@

@-
Include the sql_cache functionality
@mal

command calc.like(s:str, pat:str, esc:str):bit 
address PCRElike3;

command calc.like(s:str, pat:str):bit 
address PCRElike2;

command batstr.like(s:bat[:any_1,:str], pat:str, esc:str):bat[:any_1,:bit] 
address PCRElike_uselect_pcre;

command prelude()
address SQLprelude;

command epilogue()
address SQLepilogue;

include sql_cache;
sql.prelude();

@h
#ifndef _SQL_H
#define _SQL_H

#include <sql_mem.h>

#ifdef _MSC_VER
#ifndef LIBSQL
#define sql_export extern __declspec(dllimport)
#else
#define sql_export extern __declspec(dllexport)
#endif
#else
#define sql_export extern
#endif

#include "sql_mvc.h"
#include <sql_backend.h>
#include <mal_session.h>

#include <mal_function.h>
#include <mal_stack.h>
#include <mal_interpreter.h>
#include <mal_session.h>
#include <tablet.h>
#include <streams.h>
#include <mtime.h>
#include "sql_privileges.h"
#include "sql_semantic.h"
#include "sql_optimize.h"
#include "sql_rel2bin.h"
#include "sql_decimal.h"
#include "sql_string.h"
#include "sql_scope.h"
#include "sql_qc.h"
#include "sql_env.h"
@-
The back-end structure collects the information needed to support
compilation and execution of the SQL code against the Monet Version 5
back end. Note that the back-end can be called upon by the front-end
to handle specific tasks, such as catalog management (sql_mvc)
and query execution (sql_qc). For this purpose, the front-end needs
access to operations defined in the back-end, in particular for
freeing the stack and code segment.
@-
@h
typedef struct backend {
	int console;
	char language;		/* 'S' or 's' or 'X' */
	mvc *mvc;
	buffer *outbuf;
	stream *out;
	sql_schema *currSchema;
	sql_table *currTable;
	sql_column *currColumn;
	sql_key *currKey;
	sql_idx *currIndex;
	MalBlkPtr code;
	int	vtop;		/* top of the variable stack before the current function */
	cq *q;			/* pointer to the cached query */
@-
Some statistics are gathered during the execution of a query
and added to the SQL history table for post analysis when the
query has been successfully executed.
@h
	lng Tparse, Toptimize, Tschedule, Texec;
	str qry;
} backend;

extern backend *backend_create(mvc *m, Client c);
extern void backend_destroy(backend *b);

extern int sqlcleanup(mvc *c, int err);
extern stmt *sql_symbol2stmt(mvc *c);

extern BAT *mvc_bind(mvc *m, char *sname, char *tname, char *cname, int access);
extern BAT *mvc_bind_dbat(mvc *m, char *sname, char *tname, int access);
extern BAT *mvc_bind_idxbat(mvc *m, char *sname, char *tname, char *iname, int access);

#endif /* _SQL_H */

@-
First introduce the routines to be called by the front-end.
@c
#include "sql.h"
#include "sql_result.h"
#include "sql_gencode.h"
#include <bat/bat_store.h>
#include <bat/res_table.h>
#include <bat/bat_sequence.h>
#include <sql_datetime.h>
#include <rel_bin.h>

backend *
backend_create(mvc *m, Client c)
{
	backend *b = NEW(backend);

	b->console = isAdministrator(c);
	b->outbuf = NULL;
	b->out = c->fdout;
	b->language = 0;
	b->mvc = m;

	b->currSchema = NULL;
	b->currTable = NULL;
	b->currColumn = NULL;
	b->currKey = NULL;
	b->currIndex = NULL;
	b->code = NULL;
	b->vtop = 0;
	b->Tparse = b->Toptimize = b->Tschedule = b->Texec = 0;
	b->qry = NULL;
	b->q = NULL;
	return b;
}

void
backend_destroy(backend *b)
{
	_DELETE(b);
}

@-
Stuff copied from the Monet 4 back end
Lookup the statement associated with a specific identifier
from the statement cache. Compile and optimize it for later
consumption, e.g. display
@c
stmt *
sql_symbol2stmt(mvc *c)
{
	stmt *s = NULL;

	if (mvc_debug_on(c,16384)) {
		sql_rel *r;
		printf("# semantic relational algebra\n");
		r = rel_semantic(c, c->sym);
		if (!r) {
			if (c->errstr[0]) {
				printf("# %s\n", c->errstr);
				return NULL;
			} else {
				c->session->status = 0;
				printf("# falling back to direct mode \n");
				s = semantic(c, NULL, c->sym);
			}
		} else {
			s = rel_bin(c, r);
			if (s){
				stmt *opt;

				opt = optimize(c, s);
				stmt_destroy(s);
				s = rel2bin(c, opt);
				stmt_destroy(opt);
				return opt;
			}
		}
	}  else {
		/*printf("# semantic binary algebra\n");*/
		s = semantic(c, NULL, c->sym);
	}

	if (s){
		stmt *opt;

		opt = optimize(c, s);
		stmt_destroy(s);
		s = opt;
		opt = rel2bin(c, s);
		stmt_destroy(s);
		s = opt;
	}
	return s;
}

@-
After the SQL statement has been executed, its data structures
should be garbage collected. For successful actions we have to finish
the transaction as well, e.g. commit or rollback.
@c
int
sqlcleanup(mvc *c, int err)
{
	sql_destroy_params(c);
	sql_destroy_args(c);

	/* some statements dynamically disable caching */
	c->sym = NULL;
	if (c->sa) 
		c->sa = sa_reset(c->sa);
	if (err)
		c->session->status = err;
	scanner_query_processed(&(c->scanner));
	return err;
}

@-
The internal administration of the SQL compilation and execution state
is administered by a state descriptor accessible in each phase.
Failure to find the state descriptor aborts the session.

@c
str 
getContext(mvc **c, backend **b )
{
	Client _client = MCgetClient();

	if (_client == NULL ) {
		return throwMessage("mvc","Can not access client record");
	} 
	if ( _client->state[PARSER] == NULL) {
		return throwMessage("mvc","PARSER not initialized\n");
	}
	if ( _client->state[OPTIMIZE] == NULL) {
		assert(0);	/* Fabian: this looks like very dirty and wrong code to me */
		str schema = NULL;
		backend *be = _client->state[PARSER];

		(void)be; /* Fabian: what is the use of declaring a variable, never using it, but telling the compiler to shut up? */
		printf("#Re-establish context for client not expected\n");
		_client->state[OPTIMIZE] = mvc_create(0,0,NULL,GDKout);
		/* Fabian: should not GDKstrdup and should not use mvc_login
		schema = mvc_login( _client->state[OPTIMIZE], 
				GDKstrdup("monetdb"), GDKstrdup("monetdb") );
		*/
		if( !schema)
			return throwMessage("getContext","unknown schema for monetdb\n");
		else
			_DELETE(schema);
	}
	*c = ((mvc *) _client ->state[OPTIMIZE]); 
	if (b)
		*b = ((backend*) _client->state[PARSER]);
	return MAL_SUCCEED;
}

str
SQLcommit_wrap(int *ret){
	mvc *m;
	str msg = getContext(&m, NULL);

	if (msg)
		return msg;
	(void) ret;
	mvc_commit(m, 0, NULL); /* keep the changes */
	return MAL_SUCCEED;
}
str
SQLrollback_wrap(int *ret){
	mvc *m;
	str msg = getContext(&m, NULL);

	if (msg)
		return msg;
	(void) ret;
	mvc_rollback(m, 0, NULL); /* keep the changes */
	return MAL_SUCCEED;
}
str
mvc_update_var_wrap(int *ret, str *varname)
{
	mvc *m;
	str msg = getContext(&m, NULL);

	if (msg)
		return msg;
	(void) ret;
	if (sql_update_var(m, *varname) != GDK_SUCCEED)
		return throwException(MALEXCEPTION, "sql.setVariable", "error");
	return MAL_SUCCEED;
}

str
mvc_next_value(lng *res, str *seq)
{
	mvc *m;
	str msg = getContext(&m, NULL);

	if (msg)
		return msg;
	if (sql_next_value(m->session->tr, *seq, res))
		return MAL_SUCCEED;
	return throwException(MALEXCEPTION, "sql.nextValue", "error");
}


BAT *
mvc_bind(mvc *m, char *sname, char *tname, char *cname, int access)
{
	sql_trans *tr = m->session->tr;
	BAT *b = NULL;
	sql_schema *s = mvc_bind_schema(m, sname);
	sql_table *t = mvc_bind_table(m, s, tname);
	sql_column *c = mvc_bind_column(m, t, cname);

	if (access == UPD || access == RD_UPD)
		b = bind_ubat(tr, c, access);
	else
		b = bind_bat(tr, c, access);
	return b;
}

int 
mvc_append(BAT **b, mvc *m, str sname, str tname, str cname, int *access, BAT *i)
{
	sql_trans *tr = m->session->tr;
	sql_schema *s = mvc_bind_schema(m, sname);
	sql_table *t = mvc_bind_table(m, s, tname);
	sql_column *c = mvc_bind_column(m, t, cname);

	if (*access == UPD || *access == RD_UPD)
		*b = append_ubat(tr, c, *access, i);
	else
		*b = append_bat(tr, c, *access, i);
	return GDK_SUCCEED;
}


BAT *
mvc_bind_dbat(mvc *m, char *sname, char *tname, int access)
{
	sql_trans *tr = m->session->tr;
	BAT *b = NULL;
	sql_schema *s = mvc_bind_schema(m, sname);
	sql_table *t = mvc_bind_table(m, s, tname);

	b = bind_dbat(tr, t, access);
	return b;
}

BAT *
mvc_bind_idxbat(mvc *m, char *sname, char *tname, char *iname, int access)
{
	sql_trans *tr = m->session->tr;
	BAT *b = NULL;
	sql_schema *s = mvc_bind_schema(m, sname);
	sql_idx *i = mvc_bind_idx(m, s, iname);

	(void) tname;
	if (access == UPD || access == RD_UPD)
		b = bind_uidx(tr, i, access);
	else
		b = bind_idx(tr, i, access);
	return b;
}

int
mvc_append_idxbat(BAT **b, mvc *m, char *sname, char *tname, char *iname, int *access, BAT *ib)
{
	sql_trans *tr = m->session->tr;
	sql_schema *s = mvc_bind_schema(m, sname);
	sql_idx *i = mvc_bind_idx(m, s, iname);

	(void) tname;
	if (*access == UPD || *access == RD_UPD)
		*b = append_uidx(tr, i, *access, ib);
	else
		*b = append_idx(tr, i, *access, ib);
	return GDK_SUCCEED;
}


str
mvc_bind_wrap(int *bid, str *sname, str *tname, str *cname, int *access)
{
	BAT *b;
	mvc *m;
	str msg = getContext(&m, NULL);

	if (msg)
		return msg;
	b = mvc_bind(m, *sname, *tname, *cname, *access);
	if (b) {
		BBPkeepref( *bid = b->batCacheid);
		return MAL_SUCCEED;
	}
	return throwException(MALEXCEPTION, "mvc_bind", "error");
}

str
mvc_append_wrap(int *bid, str *sname, str *tname, str *cname, int *access, int *ins)
{
	BAT *I, *B = NULL;
	mvc *m;
	str msg = getContext(&m, NULL);

	if( (I= BATdescriptor(*ins)) == NULL)
		return throwMessage("sql.append","Cannot access descriptor");

	if (msg)
		return msg;
	mvc_append(&B, m, *sname, *tname, *cname, access, I);
	BBPunfix(I->batCacheid);
	if (B) {
		BBPkeepref( *bid = B->batCacheid);
		return MAL_SUCCEED;
	}
	return throwException(MALEXCEPTION, "mvc_append", "error");
}

@-
Monet 5 extension 
@-
The Mx macro below is used in many places throughout the code base to
access the BAT descriptor.

@= chkIdentifier
	/* generate exception if string is not an identifier */
	if( isIdentifier(@1))
		return throwMessage( "@4","identifier expected");
@= Pseudo
	if (BBPindex("@1_@2_@3") <= 0)
		BATname(b, "@1_@2_@3");
	BATroles(b,"@1","@2");
	BATmode(b,TRANSIENT);
	BATfakeCommit(b);
	*ret = b->batCacheid;

@c

str
mvc_bind_single_wrap(int *ret, int *bid, str *name)
{
	BAT *b, *bn;
	int r;
	ptr p;

	if( (bn= BATdescriptor(*bid)) == NULL)
		return throwMessage("sql.bind","Cannot access descriptor");

	p = BUNfnd(bn, *name);
	r = *(int *) BUNtail(bn, p);
	if( (b= BATdescriptor(r)) == NULL)
		return throwMessage("sql.bind","Cannot access descriptor");
	BBPkeepref(*ret= b->batCacheid);
	BBPunfix( bn->batCacheid);
	return MAL_SUCCEED;
}

str
mvc_bind_dbat_wrap(int *ret, str *sname, str *tname, int *access)
{
	BAT *b;
	mvc *m;
	str msg = getContext(&m, NULL);

	if (msg)
		return msg;
	b = mvc_bind_dbat(m, *sname, *tname, *access);
	if (b) {
		BBPkeepref( *ret = b->batCacheid);
		return MAL_SUCCEED;
	}
	return throwException(MALEXCEPTION, "mvc_bind_dbat_wrap", "error");
}

str
mvc_bind_idxbat_wrap(int *ret, str *sname, str *tname, str *iname, int *access)
{
	BAT *b;
	mvc *m;
	str msg = getContext(&m, NULL);

	if (msg)
		return msg;
	b = mvc_bind_idxbat(m, *sname, *tname, *iname, *access);
	if (b) {
		BBPkeepref( *ret = b->batCacheid);
		return MAL_SUCCEED;
	}
	return throwException(MALEXCEPTION, "mvc_bind_idxbat_wrap", "error");
}

str
mvc_append_idxbat_wrap(int *bid, str *sname, str *tname, str *iname, int *access, int *ins)
{
	BAT *I, *B = NULL;
	mvc *m;
	str msg = getContext(&m, NULL);

	if( (I= BATdescriptor(*ins)) == NULL)
		return throwMessage("sql.append_idxbat","Cannot access descriptor");

	if (msg)
		return msg;
	mvc_append_idxbat(&B, m, *sname, *tname, *iname, access, I);
	BBPunfix(I->batCacheid);
	if (B) {
		BBPkeepref( *bid = B->batCacheid);
		return MAL_SUCCEED;
	}
	return throwException(MALEXCEPTION, "mvc_append_idxbat", "error");
}


str
mvc_clear_table_wrap(lng *res, str *sname, str *tname)
{
	sql_schema *s;
	sql_table *t;
	mvc *m;
	str msg = getContext(&m, NULL);

	if (msg)
		return msg;
	s = mvc_bind_schema(m, *sname);
	t = mvc_bind_table(m, s, *tname);
	*res = mvc_clear_table(m, t);
	return MAL_SUCCEED;
}

static int
mvc_result_row(mvc *m, int nr_cols, int qtype)
{
	m->results = res_table_create(m->session->tr, m->result_id++, nr_cols, qtype, m->results);
	return m->results->id;
}

str
mvc_result_row_wrap(int *res_id, int *nr_cols, int *qtype, int *o)
{
	mvc *m;
	str msg = getContext(&m, NULL);

	if (msg)
		return msg;
	(void)o; /* dummy order */
	*res_id = mvc_result_row(m, *nr_cols, *qtype); 
	if (*res_id < 0)
		return throwMessage("sql.resultSet", "failed");
	return MAL_SUCCEED;
}

str
mvc_result_table_wrap(int *res_id, int *nr_cols, int *qtype, bat *order_bid)
{
	str res = MAL_SUCCEED;
	BAT *order;
	mvc *m;
	str msg = getContext(&m, NULL);

	if (msg)
		return msg;
        if ((order = BATdescriptor(*order_bid)) == NULL ) {
                return throwMessage("sql.resultSet", "Cannot access descriptor");
        }
	*res_id = mvc_result_table(m, *nr_cols, *qtype, order);
	if (*res_id < 0)
		res= throwMessage("sql.resultSet", "failed");
	BBPunfix(order->batCacheid);
	return res;
}

str
mvc_result_column_wrap(int *ret, int *rs, str *tn, str *name, str *type, int *digits, int *scale, bat *bid)
{
	str res = MAL_SUCCEED;
	BAT *b;
	mvc *m;
	str msg = getContext(&m, NULL);

	(void)ret;
	(void)rs;
	if (msg)
		return msg;
        if( (b = BATdescriptor(*bid)) == NULL ){
                return throwMessage("sql.rsColumn", "Cannot access descriptor");
        }
	if (mvc_result_column(m, *tn, *name, *type, *digits, *scale, b)) 
		res = throwMessage("sql.rsColumn", "failed");
	BBPunfix(b->batCacheid);
	return res;
}
@= result_value
str
mvc_result_value_@1(int *ret, int *rs, str *tn, str *name, str *type, int *digits, int *scale, @1 *val)
{
	mvc *m;
	str msg = getContext(&m, NULL);

	(void)ret;
	(void)rs;
	if (msg)
		return msg;
	if (mvc_result_value(m, *tn, *name, *type, *digits, *scale, (ptr) val, TYPE_@1))
		return throwMessage("sql.rsColumn", "failed");
	return MAL_SUCCEED;
}
@-
@c
@:result_value(flt)@
@:result_value(dbl)@
@:result_value(lng)@
@:result_value(int)@
@:result_value(sht)@
str
/*mvc_result_value_wrap(int *ret, int *rs, str *tn, str *name, str *type, int *digits, int *scale, ptr p, int mtype)*/
mvc_result_value_wrap(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	int *ret  = (int *) getArgReference(stk, pci, 0);
	int *rs   = (int *) getArgReference(stk, pci, 1);
	str *tn   = (str *) getArgReference(stk, pci, 2);
	str *cn   = (str *) getArgReference(stk, pci, 3);
	str *type = (str *) getArgReference(stk, pci, 4);
	int *digits = (int *) getArgReference(stk, pci, 5);
	int *scale = (int *) getArgReference(stk, pci, 6);
	ptr p =  (ptr) getArgReference(stk, pci, 7);
	int mtype = getArgType(mb, pci, 7);
	mvc *m;
	str msg = getContext(&m, NULL);

	(void)ret;
	(void)rs;
	if (msg)
		return msg;
	if (ATOMvarsized(mtype)) 
		p = *(ptr*)p;
	if (mvc_result_value(m, *tn, *cn, *type, *digits, *scale, p, mtype))
		return throwMessage("sql.rsColumn", "failed");
	return MAL_SUCCEED;
}

str
mvc_affected_rows_wrap( int *r, lng *nr)
{
	backend *b;
	mvc *c;
	str msg = getContext(&c, &b);

	if (msg)
		return msg;
	c->type = Q_UPDATE;
	if (mvc_export_affrows(c, b->out, *nr)) {
		return throwMessage("sql.affectedRows", "failed");
	}
	(void)r;
	return NULL;
}

str
mvc_affected_rows_int( int *r, int *nr)
{
	lng N = *nr;
	return mvc_affected_rows_wrap(r, &N);
}

str
mvc_export_result_wrap(int *ret, int *res_id)
{
	backend *b;
	mvc *c;
	str msg = getContext(&c, &b);

	if (msg)
		return msg;
	if (mvc_export_result(c, b->out, *res_id)) {
		return throwMessage("sql.exportResult", "failed");
	}
	(void)ret;
	return NULL;
}

str
mvc_export_operation_wrap(int *ret)
{
	backend *b;
	mvc *c;
	str msg = getContext(&c, &b);

	if (msg)
		return msg;
	if (mvc_export_operation(c, b->out)) {
		return throwMessage("sql.exportOperation", "failed");
	}
	(void)ret;
	return NULL;
}


str
/*mvc_export_value_wrap(int *ret, int *qtype, str tn, str name, str type, int *digits, int *scale, int *eclass, ptr p, int mtype)*/
mvc_export_value_wrap(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	int *qtype= (int *) getArgReference(stk, pci, 1);
	str *tn   = (str *) getArgReference(stk, pci, 2);
	str *cn   = (str *) getArgReference(stk, pci, 3);
	str *type = (str *) getArgReference(stk, pci, 4);
	int *digits = (int *) getArgReference(stk, pci, 5);
	int *scale = (int *) getArgReference(stk, pci, 6);
	int *eclass = (int *) getArgReference(stk, pci, 7);
	ptr p =  (ptr) getArgReference(stk, pci, 8);
	int mtype = getArgType(mb, pci, 8);
	backend *b;
	mvc *c;
	str msg = getContext(&c, &b);

	if (msg)
		return msg;
	if (ATOMvarsized(mtype)) 
		p = *(ptr*)p;
	if (mvc_export_value(c, b->out, *qtype, *tn, *cn, *type, *digits, *scale, *eclass, p, mtype) != SQL_OK)
		return throwMessage("sql.exportValue", "failed");
	return MAL_SUCCEED;
}

str
mvc_import_table_wrap(int *res, bstream **s, str *tname, str *sep, str *rsep, int *sz)
{
	BAT *b;
	mvc *m;
	str msg = getContext(&m, NULL);

	if (msg)
		return msg;
	b = mvc_import_table(m, *s, *tname, *sep, *rsep, *sz);
	if (b == 0)
		return throwMessage("sql.importTable", "failed");
	*res = b->batCacheid;
	BBPincref( *res, TRUE);
	BBPunfix(*res);
	return MAL_SUCCEED;
}

str
voidbathash_wrap(int *res, int *bid )
{
	BAT *b, *dst;
	hash_t (*hash)(ptr v); 
	int *r, *f;

	if( (b = BATdescriptor(*bid)) == NULL ){
		return throwMessage("bathash", "Cannot access descriptor");
	}

	dst= BATnew(TYPE_void,TYPE_int, BATcount(b));
	if (!dst) {
		BBPunfix(b->batCacheid);
		return throwMessage("bathash", "can not create bat");
	}
	BATseqbase(dst, b->hseqbase);

 	r = (int*)BUNtail(dst, BUNfirst(dst));
	f = r;
	hash = BATatoms[b->ttype].atomHash;
	if (ATOMvarsized(b->ttype)) { /* ugh */
		BUN p,q;
		int xx;

		BATloopFast(b,p,q,xx){
			ptr v = BUNtail(b,p);
			*r++ = (hash(v)) & 0xEFFFFFFF;
		}
	} else {
		char *v = BUNtail(b,BUNfirst(b)), *e = BUNtail(b,BUNlast(b));
		int sz = BUNsize(b);

		for(; v < e; v+=sz) {
			*r++ = (hash(v)) & 0xEFFFFFFF;
		}
	}
	dst->batBuns->free = ((r-f)*BUNsize(dst));
	BATsetcount(dst, r-f);
	BATkey(BATmirror(dst), 0);
	dst->tsorted = 0;

	BBPkeepref( *res = dst->batCacheid);
	BBPunfix(b->batCacheid);
	return MAL_SUCCEED;
}

str
bathash_wrap(int *res, int *bid )
{
	BAT *b, *dst;
	hash_t (*hash)(ptr v); 

	if( (b = BATdescriptor(*bid)) == NULL ){
		return throwMessage("bathash", "Cannot access descriptor");
	}

	dst= BATnew(TYPE_oid,TYPE_int, BATcount(b));
	if (!dst) {
		BBPunfix(b->batCacheid);
		return throwMessage("bathash", "can not create bat");
	}

	hash = BATatoms[b->ttype].atomHash;
	if (ATOMvarsized(b->ttype)) { /* ugh */
		BUN p,q;
		int xx;

		BATloopFast(b,p,q,xx){
			ptr v = BUNtail(b,p);
			int h = (hash(v)) & 0xEFFFFFFF;
			BUNins(dst, BUNhead(b,p), &h, FALSE);
		}
	} else {
		BUN p,q;
		int xx;

		BATloopFast(b,p,q,xx){
			ptr v = BUNtail(b,p);
			int h = (hash(v)) & 0xEFFFFFFF;
			BUNins(dst, BUNhead(b,p), &h, FALSE);
		}
	}

	BBPkeepref( *res = dst->batCacheid);
	BBPunfix(b->batCacheid);
	return MAL_SUCCEED;
}


str
hash_wrap(MalBlkPtr m, MalStkPtr s, InstrPtr p)
{
	ptr v;
	int *res, tpe = getArgType(m,p,1);

	res= (int *) getArgReference(s,p,0);
	v = getArgReference(s,p,1);

	if (tpe == TYPE_bat)
		return bathash_wrap(res, (int*)v); 

	if (ATOMvarsized(tpe)) /* ugh */
		*res = (ATOMhash(tpe, *(char**)v)) & 0xEFFFFFFF;
	else
		*res = (ATOMhash(tpe, v)) & 0xEFFFFFFF;
	return NULL;
}

@-
The core modules of Monet provide just a limited set of
mathematical operators. The extensions required to support
SQL-99 are shown below. At some point they also should be
moved to module code base.
@= round
str @1_round_wrap( @1 *res, @1 *v, @1 *r )
{
	@1 val = *v;
	@1 add = *r;

	/* shortcut nil */
	if (*v == @1_nil) {
		*res = @1_nil;
		return NULL;
	}

	add >>=1;
	if (val < 0) 
		add = -add;
	val += add; 
	val /= *r;
	*res = val;
	return NULL;
}
str @1_dbl_round_wrap( @1 *res, @1 *v, dbl *r )
{
	@1 add = *r;	/* lossy conversion */
	return @1_round_wrap(res,v, &add);
}
str @1_int_round_wrap( @1 *res, @1 *v, int *r )
{
	@1 add = *r;	/* lossy conversion */
	return @1_round_wrap(res,v, &add);
}

str
str_2dec_@1( @1 *res, str *val, int *d, int *sc )
{
	char *s = strip_extra_zeros(*val);
	char *dot = strchr(s, '.');
	int digits = strlen(s) - 1;
	int scale = digits - (dot-s);
	lng value = 0;

	if (!dot) {
		return throwException(MALEXCEPTION, "@1", 
			"\"%s\" is no decimal value (doesn't contain a '.')", *val);
	}
		
	value = decimal_from_str(s);
	if (*s == '+' || *s == '-')
		digits --;
	if (scale < *sc){
		/* the current scale is too small, increase it by adding 0's */
		int d = *sc - scale;	/* CANNOT be 0! */
		value *= d * 10;
		scale += d;
		digits += d;
	} else if (scale > *sc){
		/* the current scale is too big, decrease it by correctly rounding */
		int d = scale - *sc;	/* CANNOT be 0 */
		value /= (d - 1) * 10;
		if (value % 10 >= 5)
			value += 10;
		value /= 10;
		scale -= d;
		digits -= d;
	}
	if (digits > *d) {
		return throwException(MALEXCEPTION,"@1", 
		     "decimal (%s) doesn't have format (%d,%d)", *val, *d, *sc);
	}
	*res = (@1) value;
	return MAL_SUCCEED;
}
str
str_2num_@1( @1 *res, str *v, int *len )
{
	int zero = 0;
	return str_2dec_@1( res, v, len, &zero );
}
@c

@:round(sht)@
@:round(int)@
@:round(lng)@

@= fround
str @1_@2_round_wrap( @1 *res, @1 *v, @2 *r )
{
	@1 val = *v;

	/* not nil */
	if (ATOMcmp(TYPE_@1, v, ATOMnilptr(TYPE_@1)) != 0) {
		val /= *r;
	}
	*res = val;
	return MAL_SUCCEED;
}
@c
@:fround(flt,flt)@
@:fround(flt,int)@
@:fround(dbl,dbl)@
@:fround(dbl,int)@

@= cast
str
str_2_@1( @1 *res, str *val )
{
	ptr p = NULL;
	int len = 0;
	int e; 
	
	e = ATOMfromstr(TYPE_@1, &p, &len, *val);
	if (e < 0 || !p || 
	   (ATOMcmp(TYPE_@1, p, ATOMnilptr(TYPE_@1)) == 0 &&
	    ATOMcmp(TYPE_str, *val, ATOMnilptr(TYPE_str)) != 0))
	{
		char buf[BUFSIZ];
		if (p)
			GDKfree(p);
                snprintf(buf, BUFSIZ,"conversion of string '%s' failed\n",*val);
		return throwMessage("@1", buf);
	}
	*res = *(@1*)p;
	if (p)
		GDKfree(p);
	return MAL_SUCCEED;
}
str
SQL@1_2_str( str *res, @1 *val )
{
	char *p = NULL;
	int len = 0;
	@2( &p, &len, val);
	*res = p;
	return MAL_SUCCEED;
}
@c
@:cast(bit,bitToStr)@
@:cast(oid,OIDtoStr)@
@:cast(sht,shtToStr)@
@:cast(int,intToStr)@
@:cast(lng,lngToStr)@
@:cast(flt,fltToStr)@
@:cast(dbl,dblToStr)@
@:cast(timestamp,timestamp_tostr)@
@:cast(daytime,daytime_tostr)@
@:cast(date,date_tostr)@

str
SQLstr_2_str( str *res, str *val )
{
	if( *val == str_nil) 
		*res = (str)str_nil;
	else
		*res =  GDKstrdup(*val);
	return MAL_SUCCEED;
}

str
/*SQLstr_cast(str *res, ptr v, int tpe, int *len) */
SQLstr_cast(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	str *res  = (str *) getArgReference(stk, pci, 0);
	int eclass = *(int*) getArgReference(stk, pci, 1);
	int d = *(int*) getArgReference(stk, pci, 2);
	int s = *(int*) getArgReference(stk, pci, 3);
	int has_tz = *(int*) getArgReference(stk, pci, 4);
	ptr p   = (ptr) getArgReference(stk, pci, 5);
	int tpe = getArgType(mb, pci, 5);
	int len   = *(int *) getArgReference(stk, pci, 6);
	int sz = len + 1;
	char *r = GDKmalloc(sz);
	mvc *m;
	str msg = getContext(&m, NULL);

	if (msg)
		return msg;
	if (tpe != TYPE_str) {
		r = GDKmalloc(sz);
		sz = convert2str(m, eclass, d, s, has_tz, p, tpe, &r, len);
	} else {
		str v = *(str*)p; 
		sz = strlen(v);
		if (len == 0 || sz <= len) 
			r = GDKstrdup(v);
	}
	if (len > 0 && sz > len) {
		GDKfree(r);
		if (ATOMcmp(TYPE_str, ATOMnilptr(TYPE_str), p) != 0) {
			return throwException(MALEXCEPTION, "str_cast", "value too long for type (var)char(%d)\n", len);
		} else {
			*res = GDKstrdup(str_nil);
			return MAL_SUCCEED;
		}
	}
	*res = r;
	return MAL_SUCCEED;
}

lng scales[20] = {
	LL_CONSTANT(0),
	LL_CONSTANT(10),
	LL_CONSTANT(100),
	LL_CONSTANT(1000),
	LL_CONSTANT(10000),
	LL_CONSTANT(100000),
	LL_CONSTANT(1000000),
	LL_CONSTANT(10000000),
	LL_CONSTANT(100000000),
	LL_CONSTANT(1000000000),
	LL_CONSTANT(10000000000),
	LL_CONSTANT(100000000000),
	LL_CONSTANT(1000000000000),
	LL_CONSTANT(10000000000000),
	LL_CONSTANT(100000000000000),
	LL_CONSTANT(1000000000000000),
	LL_CONSTANT(10000000000000000),
	LL_CONSTANT(100000000000000000),
	LL_CONSTANT(1000000000000000000)
};

@= simpleupcast
str @2_2_@1( @1 *res, @2 *v )
{
	/* shortcut nil */
	if (*v == @2_nil) {
		*res = @1_nil;
		return(MAL_SUCCEED);
	}
	
	/* since the @1 type is bigger than or equal to the @2 type, it will
	   always fit */
	*res = (@1)*v;
	return(MAL_SUCCEED);
}
@c

@= simpledowncast
str @2_2_@1( @1 *res, @2 *v )
{
	lng val = *v;

	/* shortcut nil */
	if (*v == @2_nil) {
		*res = @1_nil;
		return(MAL_SUCCEED);
	}
	
	/* see if the number fits in the data type */
	if (val >= GDK_@1_min && val <= GDK_@1_max)	{
		*res = (@1)val;
		return(MAL_SUCCEED);
	} else {
		return throwException(MALEXCEPTION,"convert",
			"value (" LLFMT ") exceeds limits of type @1\n", val);
	}
}
@c

@= numcastup
@:simpleupcast(@1,@2)@

str @2_dec2_@1( @1 *res, int *s1, @2 *v )
{
	int scale = *s1;
	lng vdummy= *v;
	@1 r, h = (vdummy <0)?-5:5; 

	/* shortcut nil */
	if (*v == @2_nil) {
		*res = @1_nil;
		return(MAL_SUCCEED);
	}

	/* since the @1 type is bigger than or equal to the @2 type, it will
	   always fit */
	r = (@1)*v;
	if (scale) 
		r = (r+h)/scales[scale];
	*res = r;
	return(MAL_SUCCEED);
}

str @2_dec2dec_@1( @1 *res, int *S1, @2 *v, int *d2, int *S2 )
{
	int p = *d2, inlen = 1;
	@2 cpyval = *v;
	int s1 = *S1, s2 = *S2;
	lng vdummy= *v;
	@1 r, h = ( vdummy<0)?-5:5; 

	/* shortcut nil */
	if (*v == @2_nil) {
		*res = @1_nil;
		return(MAL_SUCCEED);
	}
	
	/* count the number of digits in the input */
	while (cpyval /= 10)
		inlen++;

	/* rounding is allowed */
	inlen += (s2-s1);
	if (p && inlen > p) {
		return(throwException(MALEXCEPTION,"convert",
			"too many digits (%d > %d)\n", inlen, p));
	}

	/* since the @1 type is bigger than or equal to the @2 type, it will
	   always fit */
	r = (@1)*v;
	if (s2 > s1) 
		r *= scales[s2-s1];
	else if (s2 != s1) 
		r = (r+h)/scales[s1-s2];
	*res = r;
	return(MAL_SUCCEED);
}

str @2_num2dec_@1( @1 *res, @2 *v, int *d2, int *s2 )
{
	int zero = 0;
	return @2_dec2dec_@1( res, &zero, v, d2, s2 );
}

@c
@:numcastup(sht,sht)@
@:numcastup(sht,oid)@
@:numcastup(int,sht)@
@:numcastup(int,int)@
@:numcastup(int,oid)@
@:numcastup(lng,sht)@
@:numcastup(lng,int)@
@:numcastup(lng,oid)@
@:numcastup(lng,lng)@

@= fnumcastdown
@:simpledowncast(@1,@2)@

/* when casting a floating point to an decimal we like to preserve the 
 * precision.  This means we first scale the float before converting.
*/
str @2_num2dec_@1( @1 *res, @2 *v, int *s2, int *d2 )
{
	int p = *d2, inlen = 1, scale = *s2;
	@2 r;
	lng cpyval;

	/* shortcut nil */
	if (*v == @2_nil) {
		*res = @1_nil;
		return(MAL_SUCCEED);
	}
	
	/* since the @1 type is bigger than or equal to the @2 type, it will
	   always fit */
	r = (@1)*v;
	if (scale) 
		r *= scales[scale];
	cpyval = r;

	/* count the number of digits in the input */
	while (cpyval /= 10)
		inlen++;
	/* rounding is allowed */
	if (p && inlen > p) {
		return(throwException(MALEXCEPTION,"convert",
			"too many digits (%d > %d)\n", inlen, p));
	}
	*res = r;
	return MAL_SUCCEED;
}
@c
@:fnumcastdown(sht,flt)@
@:fnumcastdown(int,flt)@
@:fnumcastdown(lng,flt)@
@:fnumcastdown(sht,dbl)@
@:fnumcastdown(int,dbl)@
@:fnumcastdown(lng,dbl)@

@= fnumcastup
@:simpleupcast(@1,@2)@

str @2_dec2_@1( @1 *res, int *s1, @2 *v )
{
	int scale = *s1;
	@1 r;

	/* shortcut nil */
	if (*v == @2_nil) {
		*res = @1_nil;
		return(MAL_SUCCEED);
	}
	
	/* since the @1 type is bigger than or equal to the @2 type, it will
	   always fit */
	r = (@1)*v;
	if (scale) 
		r /= scales[scale];
	*res = r;
	return MAL_SUCCEED;
}

str @2_dec2dec_@1( @1 *res, int *S1, @2 *v, int *d2, int *S2 )
{
	int p = *d2, inlen = 1;
	@2 cpyval = *v;
	int s1 = *S1, s2 = *S2;
	@1 r;

	/* shortcut nil */
	if (*v == @2_nil) {
		*res = @1_nil;
		return(MAL_SUCCEED);
	}
	
	/* count the number of digits in the input */
	while (cpyval /= 10)
		inlen++;
	/* rounding is allowed */
	inlen += (s2-s1);
	if (p && inlen > p) {
		return(throwException(MALEXCEPTION,"convert",
			"too many digits (%d > %d)\n", inlen, p));
	}

	/* since the @1 type is bigger than or equal to the @2 type, it will
	   always fit */
	r = (@1)*v;
	if(s2 > s1) 
		r *= scales[s2-s1];
	else if (s2 != s1) 
		r /= scales[s1-s2];
	*res = r;
	return MAL_SUCCEED;
}

str @2_num2dec_@1( @1 *res, @2 *v, int *d2, int *s2 )
{
	int zero = 0;
	return @2_dec2dec_@1( res, &zero, v, d2, s2 );
}
@c
@:fnumcastup(flt,sht)@
@:fnumcastup(flt,int)@
@:fnumcastup(flt,lng)@
@:fnumcastup(dbl,sht)@
@:fnumcastup(dbl,int)@
@:fnumcastup(dbl,lng)@

@c
@= numcastdown
@:simpledowncast(@1,@2)@

str @2_dec2_@1( @1 *res, int *s1, @2 *v )
{
	int scale = *s1;
	lng val = *v, h = (val<0)?-5:5;

	/* shortcut nil */
	if (*v == @2_nil) {
		*res = @1_nil;
		return(MAL_SUCCEED);
	}
	
	if (scale) 
		val = (val+h)/scales[scale];
	/* see if the number fits in the data type */
	if (val >= GDK_@1_min && val <= GDK_@1_max)	{
		*res = (@1)val;
		return MAL_SUCCEED;
	} else {
		return throwException(MALEXCEPTION,"convert",
			"value (" LLFMT ") exceeds limits of type @1\n", val);
	}
}

str @2_dec2dec_@1( @1 *res, int *S1, @2 *v, int *d2, int *S2 )
{
	int p = *d2, inlen = 1;
	lng val = *v, cpyval = val, h = (val<0)?-5:5;
	int s1 = *S1, s2 = *S2;

	/* shortcut nil */
	if (*v == @2_nil) {
		*res = @1_nil;
		return(MAL_SUCCEED);
	}
	
	/* count the number of digits in the input */
	while (cpyval /= 10)
		inlen++;
	/* rounding is allowed */
	inlen += (s2-s1);
	if (p && inlen > p) {
		return(throwException(MALEXCEPTION,"@2_2_@1",
			"too many digits (%d > %d)\n", inlen, p));
	}

	if(s2 > s1) 
		val *= scales[s2-s1];
	else if (s2 != s1) 
		val = (val+h)/scales[s1-s2];

	/* see if the number fits in the data type */
	if (val >= GDK_@1_min && val <= GDK_@1_max)	{
		*res = (@1)val;
		return MAL_SUCCEED;
	} else {
		return throwException(MALEXCEPTION,"convert",
			"value (" LLFMT ") exceeds limits of type @1\n", val);
	}
}

str @2_num2dec_@1( @1 *res, @2 *v, int *d2, int *s2 )
{
	int zero = 0;
	return @2_dec2dec_@1( res, &zero, v, d2, s2 );
}
@c
@:numcastdown(sht,int)@
@:numcastdown(sht,lng)@
@:numcastdown(int,lng)@

str 
month_interval_str( int *ret, str *s, int *ek, int *sk ){
	lng res;

	if (interval_from_str( *s, *sk, *ek, &res ) < 0)
		return throwException(MALEXCEPTION,"calc.month_interval",
			"wrong format (%s)\n", *s);
	*ret = res;
	return NULL;
}
str 
second_interval_str( lng *res, str *s, int *ek, int *sk ){

	if (interval_from_str( *s, *sk, *ek, res ) < 0)
		return throwException(MALEXCEPTION,"calc.second_interval",
			"wrong format (%s)\n", *s);
	return NULL;
}

@= c_interval
str
month_interval_@1( int *ret, @1 *s, int *ek, int *sk ){
	int r = (int)*s;

	(void)ek;
	switch(*sk) {
	case iyear: 	
		r *= 12;
	case imonth:
		break;
	default:
		return throwMessage("calc.month_interval","illegal argument");
	}
	*ret = r;
	return MAL_SUCCEED;
}
str
second_interval_@1( lng *res, @1 *s, int *ek, int *sk ){
	lng r = *s;

	(void)ek;
	switch(*sk) {
	case iday: 	
		r *= 24;
	case ihour:
		r *= 60;
	case imin:
		r *= 60;
	case isec:
		break;
	default:
		return throwMessage("calc.month_interval","illegal argument");
	}
	*res = r;
	return MAL_SUCCEED;
}
@c
@:c_interval(sht)@
@:c_interval(int)@
@:c_interval(lng)@
