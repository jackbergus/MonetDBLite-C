@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2008 CWI.
@' All Rights Reserved.

@f sql_result
@a N.J. Nes
@*

@h
#ifndef sql_result_H
#define sql_result_H

#include <stream.h>
#include <sql_mvc.h>
#include <sql_catalog.h>
#include <sql_qc.h>

extern int mvc_export_affrows(mvc *m, stream *s, lng val, str w);
extern int mvc_export_operation(mvc *m, stream *s, str w);
extern int mvc_export_value( mvc *m, stream *s, int qtype, str tn, str cn, str type, int d, int sc, int eclass, ptr p, int mtype, str w);
extern int mvc_export_result(mvc *c, stream *s, int res_id, str w);
extern int mvc_export_prepare(mvc *c, stream *s, cq *q, str w);
extern int mvc_export_chunk(mvc *m, stream *s, int res_id, size_t offset, size_t nr);

extern BAT *mvc_import_table(mvc *c, bstream *s, char *tname, char *sep, char *rsep, char *ssep, int nr, int offset);
extern int mvc_result_table(mvc *m, int nr_cols, int type, BAT *order);

extern int mvc_result_column(mvc *m, char *tn, char *name, char *typename, int digits, int scale, BAT *b);
extern int mvc_result_value(mvc *m, char *tn, char *name, char *typename, int digits, int scale, ptr *p, int mtype);

extern int convert2str( mvc *m, int eclass, int d, int sc, int has_tz, ptr p, int mtype, char **buf, int len);

#endif /* sql_result_H */
@c

#include "sql_config.h"
#include "sql_result.h"
#include <tablet.h>
#include <mtime.h>
#include <sql_scope.h>
#include <bat/res_table.h>

@= dec_tostr
	char buf[32];
	@1 v = *(@1*)a;
	int scale = (int)(ptrdiff_t)extra, cur = 31, neg = (v<0)?1:0, i, done = 0;
	int l;

	if (v == @1_nil) {
		if (*len < 5){
			if (*Buf)
				GDKfree(*Buf);
			*len = 5;
			*Buf = GDKmalloc(*len);
		}
		strcpy(*Buf, "NULL");
		return 4;
	}
		
	if (v<0)
		v = -v;

	buf[cur--] = 0;
	if (scale){
		for (i=0; i<scale; i++) {
			buf[cur--] = (char) (v%10 + '0');
			v /= 10;
		}
		buf[cur--] = '.';
	}
	while (v) {
		buf[cur--] = (char ) (v%10 + '0');
		v /= 10;
		done = 1;
	}
	if (!done)
		buf[cur--] = '0';
	if (neg)
		buf[cur--] = '-';
	l = (32-cur-1);
	if (*len < l){
		if (*Buf)
			GDKfree(*Buf);
		*len = l+1;
		*Buf = GDKmalloc(*len);
	}
	strcpy(*Buf, buf+cur+1);
	return l-1;
@c

int
dec_tostr(void *extra, char **Buf, int *len, int type, ptr a)
{
	/* support dec map to bte, sht, int and lng */
	if (type == TYPE_bte) {
		@:dec_tostr(bte)@
	} else if (type == TYPE_sht) {
		@:dec_tostr(sht)@
	} else if (type == TYPE_int) {
		@:dec_tostr(int)@
	} else if (type == TYPE_lng) {
		@:dec_tostr(lng)@
	} else {
		GDKwarning("Decimal cannot be mapped to %s\n", ATOMname(type));
	}
	return 0;
}

struct time_res {
	int fraction;
	int has_tz;
	lng timezone;
};

int
sql_time_tostr(void *TS_RES, char **buf, int *len, int type, ptr A)
{
	struct time_res *ts_res = TS_RES;
	int i, len1, big = 128;
	char buf1[128], *s1 = buf1, *s;
	lng val = 0, timezone = ts_res->timezone * 60 * 1000;
	daytime tmp, *a = A;
	daytime mtime = 24 * 60 * 60 * 1000;

	(void) type;
	if (*(int *) a == int_nil) {
		if (*len < 5) {
			if (*buf)
				GDKfree(*buf);
			*buf = (str) GDKmalloc(*len = 16);
		}
		s = *buf;
		strcpy(s, "NULL");
		return 4;
	}

	if (ts_res->has_tz) 
		val = *a + timezone;
	else
		val = *a;
	if (val < 0)
		val = mtime + val;
	if (val > mtime)
		val = val - mtime;
	tmp = (daytime) val;

	len1 = daytime_tostr(&s1, &big, &tmp);

	/* fixup the fraction, default is 3 */
	len1 += (ts_res->fraction-3);
	if (ts_res->fraction == 0) 
		len1 --;

	if (*len < len1 + 8) {
		if (*buf)
			GDKfree(*buf);
		*buf = (str) GDKmalloc(*len = len1 + 8);
	}
	s = *buf;
	strcpy(s, buf1);
	s += len1;
	s[0] = 0;
	/* extra zero's for usec's */
	for (i=3; i<ts_res->fraction; i++) 
		s[-i+2] = '0';

	if (ts_res->has_tz) {
		*s++ = (ts_res->timezone >= 0) ? '+' : '-';
		sprintf(s, "%02d:%02d", ABS(ts_res->timezone) / 60, ABS(ts_res->timezone) % 60);
		s += 5;
	}
	return (int) (s - *buf);
}

int
sql_timestamp_tostr(void *TS_RES, char **buf, int *len, int type, ptr A)
{
	struct time_res *ts_res = TS_RES;
	int i, len1, len2, big = 128;
	char buf1[128], buf2[128], *s, *s1 = buf1, *s2 = buf2;
	timestamp tmp, *a = A;
	lng timezone = ts_res->timezone * 60 * 1000;

	(void) type;
	if (*(lng *) a == lng_nil) {
		if (*len < 5) {
			if (*buf)
				GDKfree(*buf);
			*buf = (str) GDKmalloc(*len = 16);
		}
		s = *buf;
		strcpy(s, "NULL");
		return 4;
	}

	if (ts_res->has_tz) {
		MTIMEtimestamp_add(&tmp, a, &timezone);
		len1 = date_tostr(&s1, &big, &tmp.days);
		len2 = daytime_tostr(&s2, &big, &tmp.msecs);
	} else {
		len1 = date_tostr(&s1, &big, &a->days);
		len2 = daytime_tostr(&s2, &big, &a->msecs);
	}

	/* fixup the fraction, default is 3 */
	len2 += (ts_res->fraction-3);
	if (ts_res->fraction == 0) 
		len2 --;

	if (*len < len1 + len2 + 8) {
		if (*buf)
			GDKfree(*buf);
		*buf = (str) GDKmalloc(*len = len1 + len2 + 8);
	}
	s = *buf;
	strcpy(s, buf1);
	s += len1;
	*s++ = ' ';
	strcpy(s, buf2);
	s += len2;
	s[0] = 0;
	/* extra zero's for usec's */
	for (i=3; i<ts_res->fraction; i++) 
		s[-i+2] = '0';

	if (ts_res->has_tz) {
		*s++ = (ts_res->timezone >= 0) ? '+' : '-';
		sprintf(s, "%02d:%02d", ABS(ts_res->timezone) / 60, ABS(ts_res->timezone) % 60);
		s += 5;
	}
	return (int) (s - *buf);
}

static size_t
bat_max_strlength(BAT *b)
{
	BUN p, q;
	size_t max = 0;
	size_t l = 0;
	BATiter bi = bat_iterator(b);

	BATloop(b, p, q) {
		char *s = BUNtail(bi, p);
		l = strlen(s);

		if (l > max)
			max = l;
	}
	return max;
}

@= bat_max_xlength
static size_t
bat_max_@1length(BAT *b)
{
	BUN p, q;
	lng max = 0;
	lng min = 0;
	size_t ret = 0;
	BATiter bi = bat_iterator(b);

	BATloop(b, p, q) {
		@1 l = *((@1 *)BUNtail(bi, p));
		if (l == @1_nil) l = 4;
		if (l > max) max = l;
		if (l < min) min = l;
	}

	if ((-min * 10) > max) max = (-min * 10);
	while (max /= 10) ret++;
	ret++;
	
	return ret;
}
@c
@:bat_max_xlength(bte)@
@:bat_max_xlength(sht)@
@:bat_max_xlength(int)@
@:bat_max_xlength(lng)@

@= dec_frstr
	sql_subtype *t = &df->col->type;

	unsigned int i, neg = 0;
	char *p = s;
	@1 *r;
	@1 res = 0;
	if (*s == '-'){
		neg = 1;
		s++;
	} else if (*s == '+'){
		neg = 0;
		s++;
	}
	for (i = 0; i < (t->digits-t->scale) && *s != '.' && *s; i++, s++) {
		if (!*s || *s < '0' || *s > '9') {
			showException(SQL,"sql", "decimal wrong format (%s)", p);
			return NULL;
		}
		res *= 10;
		res += (*s-'0');
	}
	if (!*s && t->scale) {
		for( i = 0; i < t->scale; i++) {
			res *= 10;
		}
	}
	if (*s) {
		if (*s != '.') {
			showException(SQL,"sql", "decimal wrong format (%s)", p);
			return NULL;
		}
		s++;
		for( i = 0; *s && i < t->scale; i++, s++) {
			if (*s < '0' || *s > '9') {
				showException(SQL,"sql", "decimal wrong format (%s)", p);
				return NULL;
			}
			res *= 10;
			res += (*s-'0');
		}
		for( ; i < t->scale; i++) {
			res *= 10;
		}
	}
	if (*s) {
		showException(SQL,"sql", "decimal wrong format (%s)", p);
		return NULL;
	}
	r = df->ai->data;
	if (!r)
		r = (@1*)GDKmalloc(sizeof(@1));
	df->ai->data = r;
	if (neg)
		*r = -res;
	else
		*r = res;
	return (ptr*)r;
@c

typedef struct dec_format {
	sql_column *col;
	Column *ai;
} dec_format;

ptr *
dec_frstr(void *extra, int type, char *s, char *e, char quote)
{
	/* support dec map to bte, sht, int and lng */
	dec_format *df = extra;

	if (s == NULL || s == e || (!quote && 
			(s[0] == 'N' || s[0] == 'n') &&
			(s[1] == 'U' || s[1] == 'u') &&
			(s[2] == 'L' || s[2] == 'l') &&
			(s[3] == 'L' || s[3] == 'l') &&
			(s[4] == 0))) { 
        	memcpy(df->ai->data, ATOMnilptr(type), df->ai->nillen);
		return df->ai->data;
	} else if (type == TYPE_bte) {
		@:dec_frstr(bte)@
	} else if (type == TYPE_sht) {
		@:dec_frstr(sht)@
	} else if (type == TYPE_int) {
		@:dec_frstr(int)@
	} else if (type == TYPE_lng) {
		@:dec_frstr(lng)@
	} else {
		GDKwarning("Decimal cannot be parsed from %s\n", ATOMname(type));
	}
	return NULL;
}

static char *
coerce(char *s)
{
	char *n = GDKmalloc(strlen(s) + 1);
	char *t = n;

	for (; *s; s++)
		switch (*s) {
		case '\\':
			s++;
			if (*s == 'n')
				*t++ = '\n';
			else if (*s == 't')
				*t++ = '\t';
			else if (*s == '\\')
				*t++ = '\\';
			else
		default:
				*t++ = *s;
		}
	*t = 0;
	return n;
}

ptr *
_ASCIIadt_frStr(void *extra, int type, char *s, char *e, char quote)
{
	Column *c = extra;

	if (s == NULL || (!quote && s == e) || (!quote && 
			(s[0] == 'N' || s[0] == 'n') &&
			(s[1] == 'U' || s[1] == 'u') &&
			(s[2] == 'L' || s[2] == 'l') &&
			(s[3] == 'L' || s[3] == 'l') &&
			(s[4] == 0))) { 
        	memcpy(c->data, ATOMnilptr(type), c->nillen);
	} else if (type == TYPE_str) {
		return TABLETstrFrStr(c, s, e);
	} else {
		(void)(*BATatoms[type].atomFromStr)(s, &c->len, (ptr) &c->data);
		if (c->data && ATOMcmp(type, ATOMnilptr(type), c->data) == 0) 
			c->data = NULL;
	}
	return c->data;
}


static int
_ASCIIadt_toStr(void *extra, char **buf, int *len, int type, ptr a)
{
	if (!a || ATOMcmp(type, ATOMnilptr(type), a) == 0) {
		char *dst;
		const char src[] = "NULL";
		int l = sizeof(src) - 1;

		if (l + 1 > *len) {
			GDKfree(buf);
			*len = l + 1;
			*buf = GDKmalloc(*len);
		}
		dst = *buf;
		strncpy(dst, src, l);
		dst[l] = 0;
		return l;
	} else if (type == TYPE_str) {
		Column *fmt = (Column*)extra;
		char *dst, *src = a;
		int l = (fmt->quote)?escapedStrlen(src):(int)strlen(src), l2 = 0;

		if (l + 3 > *len) {
			GDKfree(*buf);
			*len = 2 * l + 3;
			*buf = GDKmalloc(*len);
		}
		dst = *buf;
		if (fmt->quote) {
			dst[0] = fmt->quote;
			l2 = 1;
			l = escapedStr(dst+l2, src);
		} else {
			strncpy(dst + l2, src, l);
		}
		if (l2) {
			dst[l + l2] = fmt->quote;
			l2++;
		}
		dst[l + l2] = 0;
		return l + l2;
	} else {
		return (*BATatoms[type].atomToStr) (buf, len, a);
	}
}


BAT *
mvc_import_table(mvc *m, bstream *bs, char *tname, char *sep, char *rsep, char *ssep, int sz, int offset)
{
	int i = 0;
	sql_table *t = mvc_bind_table(m, m->session->schema, tname);
	node *n;
	BAT *bats = NULL;
	Tablet as;
	Column *fmt;

	if (!t) {
		showException(SQL,"sql", "table %s not found", tname);
		m->type = -1;
		return NULL;
	}
	if (!bs ||stream_errnr(bs->s)) {
		showException(IO,"sql", "stream not open %d", stream_errnr(bs->s));

		m->type = -1;
		return NULL;
	}

	if (offset > 0)
		offset--;
	sep = coerce(sep);
	rsep = coerce(rsep);
	if (t->columns.set) {
		stream *out = m->scanner.ws;
		dec_format *dec;

		as.nr_attrs = list_length(t->columns.set);
		as.nr = sz;
		as.offset = offset;
		as.error = NULL;
		fmt = as.format = (Column *) GDKmalloc(sizeof(Column) * (as.nr_attrs + 1));
		dec = (dec_format*) GDKmalloc(sizeof(dec_format) * (as.nr_attrs + 1));

		if (!isa_block_stream(bs->s))
			 out = NULL;

		for (n = t->columns.set->h, i = 0; n; n = n->next, i++) {
			sql_column *col = n->data;

			fmt[i].name = col->base.name;
			fmt[i].sep = (n->next) ? _strdup(sep) : _strdup(rsep);
			fmt[i].seplen = _strlen(fmt[i].sep);
			fmt[i].type = col->type.type->base.name;
			fmt[i].adt = ATOMindex(fmt[i].type);
			fmt[i].tostr = &_ASCIIadt_toStr;
			fmt[i].frstr = &_ASCIIadt_frStr;
			fmt[i].extra = fmt+i;
			fmt[i].len = fmt[i].nillen = 
				ATOMlen(fmt[i].adt, ATOMnilptr(fmt[i].adt));
			fmt[i].data = GDKmalloc(fmt[i].len);
			fmt[i].c = NULL;
			fmt[i].ws = !(has_whitespace(fmt[i].sep));
			fmt[i].quote = ssep?ssep[0]:0;
			if (col->type.type->eclass == EC_DEC) {
				fmt[i].tostr = &dec_tostr;
				fmt[i].frstr = &dec_frstr;
				fmt[i].extra = dec+i;
				dec[i].col = col;
				dec[i].ai = fmt+i;
			}
		}
		if (TABLETcreate_bats(&as, (sz<0)?1000:sz) >= 0) {
			if (TABLETload_file(&as, bs, out) >= 0)
				bats = TABLETcollect_bats(&as);
		}
		if (as.error)
			showException(SQL, "sql", as.error);
		GDKfree(dec);
		TABLETdestroy_format(&as);
	}
	_DELETE(sep);
	_DELETE(rsep);

	m->type = Q_UPDATE;
	return bats;
}

@-
mvc_export_result dumps the sql header information and the 
first part (reply_size) of the result set. It should be produced in Monet format to 
enable mapi to work with it.
@c

static int
mvc_export_warning(stream *s, str w) {
	str tmp = NULL;
	while (w != NULL && *w != '\0') {
		if ((tmp = strchr(w, (int)'\n')) != NULL)
			*tmp++ = '\0';
		if (stream_printf(s, "#%s", w) < 0)
			return(-1);
		w = tmp;
	}
	return(1);
}

int
mvc_export_prepare(mvc *c, stream *out, cq *q, str w)
{
	node *n;
	int len = c->params ? list_length(c->params) : 0;

	if (!out)
		return 0;

	/* write header, query type: Q_PREPARE */
	if (stream_printf(out,
		"&5 %d %d 3 %d\n" /* TODO: add type here: r(esult) or u(pdate) */
		"%% .prepare,	.prepare,	.prepare # table_name\n"
		"%% type,	digits,	scale # name\n"
		"%% varchar,	int,	int # type\n"
		"%% 0,	0,	0 # length\n",
		q->id, len, len) < 0) {
		return -1;
	}

	if (c->params) {
		int i;

		q->paramlen = len;
		q->params = SA_NEW_ARRAY(q->sa, sql_subtype, len);
		for (n = c->params->h, i=0; n; n = n->next, i++) {
			sql_arg *a = n->data;
			sql_subtype *t = &a->type;

			if (t) {
				if (stream_printf(out,
					"[ \"%s\",	%d,	%d	]\n",
					t->type->sqlname,
					t->digits,
					t->scale
				) < 0) {
					return -1;
				}
				/* add to the query cache parameters */
				q->params[i] = *t;
			} else {
				return -1;
			}
		}
	}
	if (mvc_export_warning(out, w) != 1)
		return -1;
	return 0;
}


@-
improved formatting of positive integers
@= mvc_send
int
mvc_send_@1(stream *s, @1 cnt){
	char buf[50], *b;
	int neg = cnt <0;
	if(neg) cnt = -cnt;
	b= buf+49;
	do{
		*b--= (char) ('0'+ (cnt % 10));
		cnt /=10;
	} while(cnt>0);
	if( neg) 
		*b = '-'; 
	else b++;
	return stream_write(s, b, 50- (b-buf),1)==1;
}
@c
@:mvc_send(bte)@
@:mvc_send(sht)@
@:mvc_send(int)@
@:mvc_send(lng)@

int
convert2str( mvc *m, int eclass, int d, int sc, int has_tz, ptr p, int mtype, char **buf, int len)
{
	int l = 0;

	if (eclass == EC_DEC) {
		l = dec_tostr((void *) (ptrdiff_t) sc, buf, &len, mtype, p);
	} else if (eclass == EC_TIME) {
		struct time_res *ts_res = alloca(sizeof(struct time_res));
		ts_res->has_tz = has_tz;
		ts_res->fraction = d?d-1:0;
		ts_res->timezone = m->timezone;
		l = sql_time_tostr( (void *) ts_res, buf, &len, mtype, p);

	} else if (eclass == EC_TIMESTAMP) {
		struct time_res *ts_res = alloca(sizeof(struct time_res));
		ts_res->has_tz = has_tz;
		ts_res->fraction = d?d-1:0;
		ts_res->timezone = m->timezone;
		l = sql_timestamp_tostr((void *) ts_res, buf, &len, mtype, p);

	} else if (!p || ATOMcmp(mtype, ATOMnilptr(mtype), p) == 0) {
		if ((unsigned int)len < sizeof("NULL")) {
			GDKfree(*buf);
			*buf = GDKstrdup("NULL");
		} else {
			strncpy(*buf, "NULL", sizeof("NULL"));
		}
	} else {
		l = (*BATatoms[mtype].atomToStr) (buf, &len, p);
	}
	return l;
}

int
export_value( mvc *m, stream *s, int eclass, char *sqlname, int d, int sc, ptr p, int mtype, char **buf, int *len)
{
	int ok = 0;
	int l = 0;

	if (eclass == EC_DEC) {
		l = dec_tostr((void *) (ptrdiff_t) sc, buf, len,
				  mtype, p);
		ok = (stream_write(s, *buf, l, 1) == 1);
	} else if (eclass == EC_TIME) {
		struct time_res *ts_res = alloca(sizeof(struct time_res));
		ts_res->has_tz = (strcmp(sqlname, "timetz") == 0);
		ts_res->fraction = d?d-1:0;
		ts_res->timezone = m->timezone;
		l = sql_time_tostr( (void *) ts_res, buf, len, mtype, p);

		ok = (stream_write(s, *buf, l, 1) == 1);
	} else if (eclass == EC_TIMESTAMP) {
		struct time_res *ts_res = alloca(sizeof(struct time_res));
		ts_res->has_tz = (strcmp(sqlname, "timestamptz") == 0);
		ts_res->fraction = d?d-1:0;
		ts_res->timezone = m->timezone;
		l = sql_timestamp_tostr((void *) ts_res, buf, len, mtype, p);

		ok = (stream_write(s, *buf, l, 1) == 1);
	} else if (!p || ATOMcmp(mtype, ATOMnilptr(mtype), p) == 0) {
		ok = (stream_write(s, "NULL", sizeof("NULL") - 1, 1) == 1);
	} else {
		switch(mtype) {
		case TYPE_bte:
			ok = mvc_send_bte(s, *(bte*)p);
			break;
		case TYPE_sht:
			ok = mvc_send_sht(s, *(sht*)p);
			break;
		case TYPE_int:
			ok = mvc_send_int(s, *(int*)p);
			break;
		default: {
			l = (*BATatoms[mtype].atomToStr) (buf, len, p);
			ok = (stream_write(s, *buf, l, 1) == 1);
		}
		}
	}
	return ok;
}

static int
mvc_export_row(mvc *m, stream *s, res_table *t, str btag, str sep, str rsep, str ssep)
{
	int seplen = strlen(sep);
	int rseplen= strlen(rsep);
	char *buf = NULL;
	int len = 0;
	int i, ok = 1;

	if (!s)
		return 0;

	(void)ssep;
	if (btag[0])
		ok = (stream_write(s, btag, strlen(btag), 1) == 1);
	for (i = 0; i < t->nr_cols && ok; i++) {
		res_col *c = t->cols + i;

		if (i != 0) {
			ok = (stream_write(s, sep, seplen, 1) == 1);
			if (!ok)
				break;
		}
		ok = export_value(m, s, c->type.type->eclass, 
			c->type.type->sqlname, c->type.digits, c->type.scale, 
			c->p, c->mtype, &buf, &len);
	}
	if (len)
		_DELETE(buf);
	m->results = res_tables_remove(m->results, t);
	if (ok)
		ok = (stream_write(s, rsep, rseplen, 1) == 1);
	return (ok) ? 0 : -1;
}

static int
mvc_export_table(mvc *m, stream *s, res_table *t, BAT *order, size_t offset, size_t nr, char *btag, char *sep, char *rsep, char *ssep )
{
	Tablet as;
	Column *fmt;
	ssize_t i;

	if (!t)
		return -1;
	if (!s)
		return 0;

	as.nr_attrs = t->nr_cols + 1;	/* for the leader */
	as.nr = nr;
	as.offset = offset;
	fmt = as.format = (Column *) GDKmalloc(sizeof(Column) * (as.nr_attrs + 1));

	memset(fmt, 0, (as.nr_attrs + 1) * sizeof(Column));

	fmt[0].c = NULL;
	fmt[0].sep = _strdup(btag);
	fmt[0].seplen = _strlen(fmt[0].sep);
	fmt[0].ws = 0;

	for (i = 1; i <= t->nr_cols; i++) {
		res_col *c = t->cols + (i - 1);

		if (!c->b)
			break;

		fmt[i].c = BATdescriptor(c->b);
		fmt[i].ci = bat_iterator(fmt[i].c);
		fmt[i].name = NULL;
		fmt[i].sep = ((i - 1) < (t->nr_cols - 1)) ? _strdup(sep) : _strdup(rsep);
		fmt[i].seplen = _strlen(fmt[i].sep);
		fmt[i].type = ATOMname(fmt[i].c->ttype);
		fmt[i].adt = fmt[i].c->ttype;
		fmt[i].tostr = &_ASCIIadt_toStr;
		fmt[i].frstr = &_ASCIIadt_frStr;
		fmt[i].extra = fmt+i;
		fmt[i].data = NULL;
		fmt[i].len = 0;
		fmt[i].nillen = 0;
		fmt[i].ws = 0;
		fmt[i].quote = ssep?ssep[0]:0;
		if (c->type.type->eclass == EC_DEC) {
			fmt[i].tostr = &dec_tostr;
			fmt[i].frstr = &dec_frstr;
			fmt[i].extra = (void *) (ptrdiff_t) c->type.scale;
		} else if (c->type.type->eclass == EC_TIMESTAMP) {
			struct time_res *ts_res = alloca(sizeof(struct time_res));
			ts_res->has_tz = (strcmp(c->type.type->sqlname, "timestamptz") == 0); 
			ts_res->fraction = c->type.digits?c->type.digits-1:0;
			ts_res->timezone = m->timezone;

			fmt[i].tostr = &sql_timestamp_tostr;
			fmt[i].frstr = NULL;
			fmt[i].extra = ts_res;
		} else if (c->type.type->eclass == EC_TIME) {
			struct time_res *ts_res = alloca(sizeof(struct time_res));
			ts_res->has_tz = (strcmp(c->type.type->sqlname, "timetz") == 0); 
			ts_res->fraction = c->type.digits?c->type.digits-1:0;
			ts_res->timezone = m->timezone;

			fmt[i].tostr = &sql_time_tostr;
			fmt[i].frstr = NULL;
			fmt[i].extra = ts_res;
		} else {
			fmt[i].extra = fmt+i;
		}
	}
	if (i == t->nr_cols + 1) {
		TABLEToutput_file(&as, order, s);
	}
	TABLETdestroy_format(&as);
	if (stream_errnr(s))
		return -1;
	return 0;
}

int 
export_length( stream *s, int mtype, int eclass, int digits, int scale, bat bid, ptr p) 
{
	int ok = 1;
	size_t count = 0;

	mtype = ATOMstorage(mtype);
	if (mtype == TYPE_str) {
		if (eclass == EC_CHAR) {
			ok = mvc_send_int(s, digits);
		} else {
			count = 0;
			if (bid) {
				BAT *b = BATdescriptor(bid);

				count = bat_max_strlength(b);
				BBPunfix(b->batCacheid);
			} else {
				if (p) count = strlen((char *) p);
				else count = 4;
			}
			ok = mvc_send_lng(s, (lng) count);
		}
	} else if (eclass == EC_NUM) {
		count = 0;
		if (bid) {
			BAT *b = BATdescriptor(bid);

			if (mtype == TYPE_bte) {
				count = bat_max_btelength(b);
			} else if (mtype == TYPE_sht) {
				count = bat_max_shtlength(b);
			} else if (mtype == TYPE_int) {
				count = bat_max_intlength(b);
			} else { /* TYPE_lng */
				count = bat_max_lnglength(b);
			}
			BBPunfix(b->batCacheid);
		} else {
			if (p) {
				lng val = 0;
				if (mtype == TYPE_bte) {
					val = *((bte *)p);
				} else if (mtype == TYPE_sht) {
					val = *((sht *)p);
				} else if (mtype == TYPE_int) {
					val = *((int *)p);
				} else { /* TYPE_lng */
					val = *((lng *)p);
				}

				if (val < 0) count++;
				while (val /= 10) count++;
				count++;
			} else {
				count = 4;
			}
		}
		ok = mvc_send_lng(s, (lng) count);
	/* the following two could be done once by taking the
	   max value and calculating the number of digits from that
	   value, instead of the maximum values taken now, which
	   include the optional sign */
	} else if (eclass == EC_FLT) {
		/* [sign]+digit+period+[max 6 digits]+E+[sign]+[max 2 digits] */
		if (mtype == TYPE_flt) {
			ok = mvc_send_int(s, 13);
		/* [sign]+digit+period+[max 14 digits]+E+[sign]+[max 3 digits] */
		} else { /* TYPE_dbl */
			ok = mvc_send_int(s, 22);
		}
	} else if (eclass == EC_DEC) {
		count = 1 + digits;
		if (scale > 0)
			count += 1;
		ok = mvc_send_lng(s, (lng) count);
	} else if (eclass == EC_DATE) {
		ok = mvc_send_int(s, 10);
	} else if (eclass == EC_TIME) {
		count = 8;
		if (scale)	/* time zone */
			count += 6;	/* +03:30 */
		if (digits > 1)	/* fractional seconds precision (including dot) */
			count += digits;
		ok = mvc_send_lng(s, (lng) count);
	} else if (eclass == EC_TIMESTAMP) {
		count = 10 + 1 + 8;
		if (scale)	/* time zone */
			count += 6;		/* +03:30 */
		if (digits)	/* fractional seconds precision */
			count += digits;
		ok = mvc_send_lng(s, (lng) count);
	} else if (eclass == EC_BIT) {
		ok = mvc_send_int(s, 5);	/* max(strlen("true"), strlen("false")) */
	} else {
		ok = mvc_send_int(s, 0);
	}
	return ok;
}

 
int
mvc_export_value(mvc *m, stream *s, int qtype, str tn, str cn, str type, int d, int sc, int eclass, ptr p, int mtype, str w) 
{
	char *buf = NULL;
	int len = 0;
	int ok = 1;
	char *rsep = "\t]\n";

#ifdef NDEBUG
	(void) qtype; /* pacify compiler in case asserts are disabled */
#endif
	assert(qtype == Q_TABLE);
	if (stream_write(s, "&1 0 1 1 1\n", 11, 1) == 1 &&
	    /* fallback to default tuplecount (1) and id (0) */
	    /* TODO first header name then values */
	    stream_write(s, "% ", 2, 1) == 1 &&
	    stream_write(s, tn, strlen(tn), 1) == 1 &&
	    stream_write(s, " # table_name\n% ", 16, 1) == 1 &&
	    stream_write(s, cn, strlen(cn), 1) == 1 &&
	    stream_write(s, " # name\n% ", 10, 1) == 1 &&
	    stream_write(s, type, strlen(type), 1) == 1 &&
	    stream_write(s, " # type\n% ", 10, 1) == 1 &&
	    export_length(s, mtype, eclass, d, sc, 0, p) &&
	    stream_write(s, " # length\n[ ", 12, 1) == 1 &&
	    export_value( m, s, eclass, type, d, sc, p, mtype, &buf, &len)) 
		ok = (stream_write(s, rsep, strlen(rsep), 1) == 1);
	    
	if (buf)
		_DELETE(buf);

	if (ok)
		ok = mvc_export_warning(s, w);
	return ok;
}
int
mvc_export_operation(mvc *m, stream *s, str w)
{
	assert(m->type == Q_SCHEMA || m->type == Q_TRANS);
	if (m->type == Q_SCHEMA) {
		if (!s || stream_write(s, "&3\n", 3, 1) != 1)
			return -1;
	} else {
		if (m->session->auto_commit) {
			if (stream_write(s, "&4 t\n", 5, 1) != 1)
				return -1;
		} else {
			if (stream_write(s, "&4 f\n", 5, 1) != 1)
				return -1;
		}
	}

	if (mvc_export_warning(s, w) != 1)
		return -1;
	return 0;
}

int
mvc_export_affrows(mvc *m, stream *s, lng val, str w)
{
	/* if we don't have a stream, nothing can go wrong, so we return
	 * success.  This is especially vital for execution of internal SQL
	 * commands, since they don't get a stream to suppress their output.
	 * If we would fail on heaving no stream here, those internal commands
	 * fail too.
	 */
	if (!s) return 0;
	
	assert(m->type == Q_UPDATE);
	if (stream_write(s, "&2 ", 3, 1) != 1 || 
	   !mvc_send_lng(s, val) ||
	    stream_write(s, " ", 1, 1) != 1 ||
	   !mvc_send_lng(s, m->last_id) ||
   	    stream_write(s, "\n", 1, 1) != 1)
		return -1;
	if (mvc_export_warning(s, w) != 1)
		return -1;
	return 0;
}

static int
export_error(BAT *order)
{
	if (order)
		BBPunfix(order->batCacheid);
	return -1;
}

int
mvc_export_file(mvc *m, res_table *t) 
{
	int res = 0;
	size_t count;
	stream *s;
	BAT *order = NULL;
	char *sep = t->tsep;
	char *rsep = t->rsep;

	s = open_wastream(t->filename);
	if (!s || stream_errnr(s)) {
		GDKerror("failed to open %s\n", t->filename);
		return -1;
	}

	sep = coerce(sep);
	rsep = coerce(rsep);
	if (!t->order) {
		res = mvc_export_row(m, s, t, "", sep, rsep, t->ssep);
	} else {
		order = BATdescriptor(t->order);
		count = BATcount(order);
		res = mvc_export_table(m, s, t, order, 0, count, "", sep, rsep, t->ssep);
		BBPunfix(order->batCacheid);
		m->results = res_tables_remove(m->results, t);
	} 
	_DELETE(sep);
	_DELETE(rsep);
	stream_close(s);
	stream_destroy(s);
	return res;
}

int
mvc_export_result(mvc *m, stream *s, int res_id, str w)
{
	int i, clean = 0, res = 0;
	size_t count;
	res_table *t = res_tables_find(m->results, res_id);
	BAT *order = NULL;

	if (!s || !t)
		return 0;

	/* we shouldn't have anything else but Q_TABLE here */
	assert(t->query_type == Q_TABLE);
	if (t->filename)
		return mvc_export_file(m, t);

	/* query type: Q_TABLE */
	if (!(stream_write(s, "&1 ", 3, 1) == 1))
		return -1;

	/* id */
	if (!mvc_send_int(s, t->id) ||
			stream_write(s, " ", 1, 1) != 1)
		return -1;

	/* tuple count */
	if (t->order) {
		order = BATdescriptor(t->order);

		count = BATcount(order);
	} else
		count = 1;
	if (!mvc_send_lng(s, (lng) count) ||
			stream_write(s, " ", 1, 1) != 1)
		return export_error(order);

	/* column count */
	if (!mvc_send_int(s, t->nr_cols) ||
			stream_write(s, " ", 1, 1) != 1)
		return export_error(order);

	/* row count, min(count, reply_size) */
	if (!mvc_send_int(s, (size_t) m->reply_size < count ? m->reply_size : (int) count)) 
		return export_error(order);

	if (stream_write(s, "\n% ", 3, 1) != 1)
		return export_error(order);
	for (i = 0; i < t->nr_cols; i++) {
		res_col *c = t->cols + i;
		size_t len = strlen(c->tn);

		if (len && stream_write(s, c->tn, len, 1) != 1)
			return export_error(order);
		if (i + 1 < t->nr_cols && stream_write(s, ",\t", 2, 1) != 1)
			return export_error(order);
	}
	if (stream_write(s, " # table_name\n% ", 16, 1) != 1)
		return export_error(order);

	for (i = 0; i < t->nr_cols; i++) {
		res_col *c = t->cols + i;

		if (stream_write(s, c->name, strlen(c->name), 1) != 1)
			return export_error(order);
		if (i + 1 < t->nr_cols && stream_write(s, ",\t", 2, 1) != 1)
			return export_error(order);
	}
	if (stream_write(s, " # name\n% ", 10, 1) != 1)
		return export_error(order);

	for (i = 0; i < t->nr_cols; i++) {
		res_col *c = t->cols + i;

		if (stream_write(s, c->type.type->sqlname, strlen(c->type.type->sqlname), 1) != 1)
			return export_error(order);
		if (i + 1 < t->nr_cols && stream_write(s, ",\t", 2, 1) != 1)
			return export_error(order);
	}
	if (stream_write(s, " # type\n% ", 10, 1) != 1)
		return export_error(order);

	for (i = 0; i < t->nr_cols; i++) {
		res_col *c = t->cols + i;
		int mtype = c->type.type->localtype;
		int eclass = c->type.type->eclass;

		if (!export_length(s, mtype, eclass, c->type.digits, c->type.scale, c->b, c->p))
			return export_error(order);
		if (i + 1 < t->nr_cols && stream_write(s, ",\t", 2, 1) != 1)
			return export_error(order);
	}
	if (stream_write(s, " # length\n", 10, 1) != 1)
		return export_error(order);

	if (!t->order)
		return mvc_export_row(m, s, t, "[ ", ",\t", "\t]\n", "\"");

	count = m->reply_size;
	if (count == 0 || count >= BATcount(order)) {
		count = BATcount(order);
		clean = 1;
	}
	res = mvc_export_table(m, s, t, order, 0, count, "[ ", ",\t", "\t]\n", "\"");
	BBPunfix(order->batCacheid);
	if (clean)
		m->results = res_tables_remove(m->results, t);

	if (res > 0)
		res = mvc_export_warning(s, w);
	return res;
}

int
mvc_export_chunk(mvc *m, stream *s, int res_id, size_t offset, size_t nr)
{
	int res = 0;
	res_table *t = res_tables_find(m->results, res_id);
	BAT *order = NULL;
	size_t cnt;

	if (!s || !t)
		return 0;

	order = BATdescriptor(t->order);
	cnt = nr;
	if (cnt == 0) 
		cnt = BATcount(order);
	if (offset >= BATcount(order))
		cnt = 0;
	if (offset + cnt > BATcount(order)) 
		cnt = BATcount(order) - offset;

	/* query type: Q_BLOCK */
	if (!(stream_write(s, "&6 ", 3, 1) == 1))
		return export_error(order);

	/* result id */
	if (!mvc_send_int(s, res_id) ||
			stream_write(s, " ", 1, 1) != 1)
		return export_error(order);

	/* column count */
	if (!mvc_send_int(s, t->nr_cols) ||
			stream_write(s, " ", 1, 1) != 1)
		return export_error(order);

	/* row count */
	if (!mvc_send_lng(s, (lng) cnt) || 
			stream_write(s, " ", 1, 1) != 1)
		return export_error(order);

	/* block offset */
	if (!mvc_send_lng(s, (lng) offset)) 
		return export_error(order);

	if (stream_write(s, "\n", 1, 1) != 1)
		return export_error(order);

	res = mvc_export_table(m, s, t, order, offset, cnt, "[ ", ",\t", "\t]\n", "\"");
	BBPunfix(order->batCacheid);
	return res;
}


int
mvc_result_table(mvc *m, int nr_cols, int type, BAT *order)
{
	res_table *t = res_table_create(m->session->tr, m->result_id++, nr_cols, type, m->results, order);
	m->results = t;
	return t->id;
}

int
mvc_result_column(mvc *m, char *tn, char *name, char *typename, int digits, int scale, BAT *b)
{
	(void)res_col_create(m->session->tr, m->results, tn, name, typename, digits, scale, TYPE_bat, b);
	return 0;
}

int
mvc_result_value(mvc *m, char *tn, char *name, char *typename, int digits, int scale, ptr *p, int mtype)
{
	(void)res_col_create(m->session->tr, m->results, tn, name, typename, digits, scale, mtype, p);
	return 0;
}

