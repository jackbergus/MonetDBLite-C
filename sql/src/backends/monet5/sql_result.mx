@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2005 CWI.
@' All Rights Reserved.

@f sql_result
@a N.J. Nes
@*

@h
#ifndef sql_result_H
#define sql_result_H

#include <stream.h>
#include <sql_mvc.h>
#include <sql_catalog.h>

extern int mvc_export_default(mvc *m, stream *s);
extern int mvc_export_value( mvc *m, stream *s, int qtype, str tn, str cn, str type, int d, int sc, int eclass, ptr p, int mtype);
extern int mvc_export_result(mvc *c, stream *s, int res_id);
extern int mvc_export_chunk(mvc *m, stream *s, int res_id, unsigned int offset, unsigned int nr);
extern BAT *mvc_import_table(mvc *c, bstream *s, char *tname, char *sep, char *rsep, int nr);
extern int mvc_result_table(mvc *m, int nr_cols, int type, BAT *order);

extern int mvc_result_column(mvc *m, char *tn, char *name, char *typename, int digits, int scale, BAT *b);
extern int mvc_result_value(mvc *m, char *tn, char *name, char *typename, int digits, int scale, ptr *p, int mtype);

extern int mvc_send_int(stream *s, int cnt);
extern int mvc_send_sht(stream *s, sht cnt);

#endif /* sql_result_H */
@c

#include "sql_result.h"
#include <tablet.h>
#include <mtime.h>
#include <bat/res_table.h>
#include <bat/bat_bm.h>

@= dec_tostr
	char buf[32];
	@1 v = *(@1*)a;
	int scale = (int)(ptrdiff_t)extra, cur = 31, neg = (v<0)?1:0, i, done = 0;
	int l;

	if (v == @1_nil) {
		if (*len < 5){
			if (*Buf)
				GDKfree(*Buf);
			*len = 5;
			*Buf = GDKmalloc(*len);
		}
		strcpy(*Buf, "NULL");
		return 4;
	}
		
	if (v<0)
		v = -v;

	buf[cur--] = 0;
	if (scale){
		for (i=0; i<scale; i++) {
			buf[cur--] = (char) (v%10 + '0');
			v /= 10;
		}
		buf[cur--] = '.';
	}
	while (v) {
		buf[cur--] = (char ) (v%10 + '0');
		v /= 10;
		done = 1;
	}
	if (!done)
		buf[cur--] = '0';
	if (neg)
		buf[cur--] = '-';
	l = (32-cur-1);
	if (*len < l){
		if (*Buf)
			GDKfree(*Buf);
		*len = l+1;
		*Buf = GDKmalloc(*len);
	}
	strcpy(*Buf, buf+cur+1);
	return l-1;
@c

int
dec_tostr(void *extra, char **Buf, int *len, int type, ptr a)
{
	/* support dec map to sht, int and lng */
	if (type == TYPE_sht) {
		@:dec_tostr(sht)@
	} else if (type == TYPE_int) {
		@:dec_tostr(int)@
	} else if (type == TYPE_lng) {
		@:dec_tostr(lng)@
	} else {
		GDKwarning("Decimal cannot be mapped to %s\n", ATOMname(type));
	}
	return 0;
}

int
sql_time_tostr(void *M, char **buf, int *len, int type, ptr A)
{
	mvc *m = M;
	int len1, big = 128;
	char buf1[128], *s1 = buf1, *s;
	lng val, timezone = m->timezone * 60 * 1000;
	daytime tmp, *a = A;
	daytime mtime = 24 * 60 * 60 * 1000;

	(void) type;
	if (*(int *) a == int_nil) {
		if (*len < 5) {
			if (*buf)
				GDKfree(*buf);
			*buf = (str) GDKmalloc(*len = 16);
		}
		s = *buf;
		strcpy(s, "NULL");
		return 4;
	}

	val = *a + timezone;
	if (val < 0)
		val = mtime + val;
	if (val > mtime)
		val = val - mtime;
	tmp = (daytime) val;

	len1 = daytime_tostr(&s1, &big, &tmp);

	if (*len < len1 + 8) {
		if (*buf)
			GDKfree(*buf);
		*buf = (str) GDKmalloc(*len = len1 + 8);
	}
	s = *buf;
	strcpy(s, buf1);
	s += len1;

	*s++ = (m->timezone >= 0) ? '+' : '-';
	sprintf(s, "%02d:%02d", ABS(m->timezone) / 60, ABS(m->timezone) % 60);
	s += 5;
	return (int) (s - *buf);
}

int
sql_timestamp_tostr(void *M, char **buf, int *len, int type, ptr A)
{
	mvc *m = M;
	int len1, len2, big = 128;
	char buf1[128], buf2[128], *s, *s1 = buf1, *s2 = buf2;
	timestamp tmp, *a = A;
	lng timezone = m->timezone * 60 * 1000;

	(void) type;
	if (*(lng *) a == lng_nil) {
		if (*len < 5) {
			if (*buf)
				GDKfree(*buf);
			*buf = (str) GDKmalloc(*len = 16);
		}
		s = *buf;
		strcpy(s, "NULL");
		return 4;
	}

	MTIMEtimestamp_add(&tmp, a, &timezone);
	len1 = date_tostr(&s1, &big, &tmp.days);
	len2 = daytime_tostr(&s2, &big, &tmp.msecs);

	if (*len < len1 + len2 + 8) {
		if (*buf)
			GDKfree(*buf);
		*buf = (str) GDKmalloc(*len = len1 + len2 + 8);
	}
	s = *buf;
	strcpy(s, buf1);
	s += len1;
	*s++ = ' ';
	strcpy(s, buf2);
	s += len2;

	*s++ = (m->timezone >= 0) ? '+' : '-';
	sprintf(s, "%02d:%02d", ABS(m->timezone) / 60, ABS(m->timezone) % 60);
	s += 5;
	return (int) (s - *buf);
}

static int
bat_max_length(BAT *b)
{
	BUN p, q;
	int max = 0;

	BATloop(b, p, q) {
		char *s = BUNtail(b, p);
		int l = strlen(s);

		if (l > max)
			max = l;
	}
	return max;
}

@= dec_frstr
	sql_subtype *t = (sql_subtype*)extra;

	unsigned int i, neg = 0;
	char *p = s;
	@1 *r;
	@1 res = 0;
	if (*s == '-'){
		neg = 1;
		s++;
	} else if (*s == '+'){
		neg = 0;
		s++;
	}
	for (i = 0; i < (t->digits-t->scale) && *s != '.' && *s; i++, s++) {
		if (!*s || *s < '0' || *s > '9') {
			GDKerror("decimal wrong format (%s)", p);
			return NULL;
		}
		res *= 10;
		res += (*s-'0');
	}
	if (!*s && t->scale) {
		GDKerror("decimal wrong format (%s)", p);
		return NULL;
	}
	if (*s) {
		if (*s != '.') {
			GDKerror("decimal wrong format (%s)", p);
			return NULL;
		}
		s++;
		for( i = 0; *s && i < t->scale; i++, s++) {
			if (*s < '0' || *s > '9') {
				GDKerror("decimal wrong format (%s)", p);
				return NULL;
			}
			res *= 10;
			res += (*s-'0');
		}
	}
	if (*s) {
		GDKerror("decimal wrong format (%s)", p);
		return NULL;
	}
	r = (@1*)GDKmalloc(sizeof(@1));
	if (neg)
		*r = -res;
	else
		*r = res;
	return (ptr*)r;
@c

ptr *
dec_frstr(void *extra, int type, char *s, char *e, char quote)
{
	/* support dec map to sht, int and lng */
	(void) e;
	(void) quote;
	if (type == TYPE_sht) {
		@:dec_frstr(sht)@
	} else if (type == TYPE_int) {
		@:dec_frstr(int)@
	} else if (type == TYPE_lng) {
		@:dec_frstr(lng)@
	} else {
		GDKwarning("Decimal cannot be parsed from %s\n", ATOMname(type));
	}
	return NULL;
}

static char *
coerce(char *s)
{
	char *n = GDKmalloc(strlen(s) + 1);
	char *t = n;

	for (; *s; s++)
		switch (*s) {
		case '\\':
			s++;
			if (*s == 'n')
				*t++ = '\n';
			else if (*s == 't')
				*t++ = '\t';
			else if (*s == '\\')
				*t++ = '\\';
			else
		default:
				*t++ = *s;
		}
	*t = 0;
	return n;
}

ptr *
_ASCIIadt_frStr(void *extra, int type, char *s, char *e, char quote)
{
	int l = 0;
	ptr *res = NULL;

	(void) extra;
	if (!(type == TYPE_str && quote) && strcasecmp(s, "NULL") == 0) {
		res = (ptr *) ATOMnil(type);
	} else if (type == TYPE_str) {
		return TABLETstrFrStr(s, e);
	} else {
		(void) (*BATatoms[type].atomFromStr) (s, &l, (ptr) &res);
	}
	return res;
}


static int
_ASCIIadt_toStr(void *extra, char **buf, int *len, int type, ptr a)
{

	(void) extra;
	if (!a || ATOMcmp(type, ATOMnilptr(type), a) == 0) {
		char *dst;
		const char src[] = "NULL";
		int l = sizeof(src) - 1;

		if (l + 1 > *len) {
			GDKfree(buf);
			*len = l + 1;
			*buf = GDKmalloc(*len);
		}
		dst = *buf;
		strncpy(dst, src, l);
		dst[l] = 0;
		return l;
	} else {
		return (*BATatoms[type].atomToStr) (buf, len, a);
	}
}


BAT *
mvc_import_table(mvc *m, bstream *bs, char *tname, char *sep, char *rsep, int sz)
{
	int i = 0;
	sql_trans *tr = m->trans;
	sql_table *t = mvc_bind_table(m, tr->schema, tname);
	node *n;
	BAT *bats = NULL;
	Tablet as;
	Column *fmt;

	if (!t) {
		GDKerror("table %s not found\n", tname);
		m->type = -1;
		return NULL;
	}
	if (!bs ||stream_errnr(bs->s)) {
		GDKerror("stream not open %d\n", stream_errnr(bs->s));

		m->type = -1;
		return NULL;
	}

	sep = coerce(sep);
	rsep = coerce(rsep);
	if (t->columns.set) {
		stream *out = m->scanner.ws;

		as.nr_attrs = list_length(t->columns.set);
		as.nr = sz;
		fmt = as.format = (Column *) GDKmalloc(sizeof(Column) * (as.nr_attrs + 1));

		if (!isa_block_stream(bs->s))
			 out = NULL;

		for (n = t->columns.set->h, i = 0; n; n = n->next, i++) {
			sql_column *col = n->data;

			fmt[i].name = col->base.name;
			fmt[i].sep = (n->next) ? _strdup(sep) : _strdup(rsep);
			fmt[i].seplen = (int) strlen(fmt[i].sep);
			fmt[i].type = col->type->type->base.name;
			fmt[i].adt = ATOMindex(fmt[i].type);
			fmt[i].tostr = &_ASCIIadt_toStr;
			fmt[i].frstr = &_ASCIIadt_frStr;
			fmt[i].extra = NULL;
			if (col->type->type->eclass == EC_DEC) {
				fmt[i].tostr = &dec_tostr;
				fmt[i].frstr = &dec_frstr;
				fmt[i].extra = col->type;
			}
		}
		if (TABLETcreate_bats(&as) >= 0) {
			if (TABLETload_file(&as, bs, out) >= 0)
				 bats = TABLETcollect_bats(&as);
		}
		TABLETdestroy_format(&as);
	}
	_DELETE(sep);
	_DELETE(rsep);

	m->type = Q_UPDATE;
	return bats;
}

@-
mvc_export_result dumps the sql header information and the 
first part (reply_size) of the result set. It should be produced in Monet format to 
enable mapi to work with it.
@c
static str mvcDefaultMsg[] = {
	"#-\n# 2 # querytype\n",
	"#-\n# 3 # querytype\n",
	"#-\n# 4 # querytype\n",
	"#-\n# 5 # querytype\n",
	"#-\n# 6 # querytype\n",
	"#-\n# 7 # querytype\n",
	"#-\n# 8 # querytype\n",
	"#-\n# 9 # querytype\n"
};

static int mvcDefaultMsg_len = 19; /*strlen("#-\n# 9 # querytype\n");*/

int
mvc_export_default(mvc *m, stream *s)
{
	int ok = 1;

	assert(m->type > 1 && m->type < 10);
	if (s) 
		ok = (stream_write(s, mvcDefaultMsg[m->type-2], mvcDefaultMsg_len, 1) == 1);
	return (ok) ? 0 : -1;
}

@-
improved formatting of positive integers
@= mvc_send
int
mvc_send_@1(stream *s, @1 cnt){
	char buf[50], *b;
	int neg = cnt <0;
	if(neg) cnt = -cnt;
	b= buf+49;
	do{
		*b--= '0'+ (cnt %10);
		cnt /=10;
	} while(cnt>0);
	if( neg) 
		*b = '-'; 
	else b++;
	return stream_write(s, b, 50- (b-buf),1)==1;
}
@c
@:mvc_send(sht)@
@:mvc_send(int)@

int
export_value( mvc *m, stream *s, int eclass, char *sqlname, int sc, ptr p, int mtype, char **buf, int *len)
{
	int ok = 0;

	if (eclass == EC_DEC) {
		int l = dec_tostr((void *) (ptrdiff_t) sc, buf, len,
				  mtype, p);
		ok = (stream_write(s, *buf, l, 1) == 1);
	} else if (eclass == EC_TIME && strcmp(sqlname, "timetz") == 0) {
		int l = sql_time_tostr( (void *) m, buf, len, mtype, p);

		ok = (stream_write(s, *buf, l, 1) == 1);
	} else if (eclass == EC_TIMESTAMP && strcmp(sqlname, "timestamptz") == 0) {
		int l = sql_timestamp_tostr((void *) m, buf, len, mtype, p);

		ok = (stream_write(s, *buf, l, 1) == 1);
	} else if (!p || ATOMcmp(mtype, ATOMnilptr(mtype), p) == 0) {
		ok = (stream_write(s, "NULL", sizeof("NULL") - 1, 1) == 1);
	} else {
		switch(mtype) {
		case TYPE_sht:
			ok = mvc_send_sht(s, *(sht*)p);
			break;
		case TYPE_int:
			ok = mvc_send_int(s, *(int*)p);
			break;
		default: {
			int l = (*BATatoms[mtype].atomToStr) (buf, len, p);
			ok = (stream_write(s, *buf, l, 1) == 1);
		}
		}
	}
	return ok;
}


static int
mvc_export_row(mvc *m, stream *s, res_table *t)
{
	char *sep = ",\t";
	char *rsep = "\t]\n";
	int seplen= 2;
	int rseplen= 3;

	int i, ok = 1;
	char *buf = NULL;
	int len = 0;

	m->type = Q_RESULT;
	if (!s)
		return 0;

	ok = (stream_write(s, "[ ", 2, 1) == 1);
	for (i = 0; i < t->nr_cols && ok; i++) {
		res_col *c = t->cols + i;

		if (i != 0) {
			ok = (stream_write(s, sep, seplen, 1) == 1);
			if (!ok)
				break;
		}
		export_value(m, s, c->type->type->eclass, 
			c->type->type->sqlname, c->type->scale, 
			c->p, c->mtype, &buf, &len);
	}
	if( len)
		_DELETE(buf);
	m->results = res_tables_remove(m->results, t);
	if (ok)
		ok = (stream_write(s, rsep, rseplen, 1) == 1);
	return (ok) ? 0 : -1;
}

static int
mvc_export_table(mvc *m, stream *s, res_table *t, unsigned int offset, unsigned int nr)
{
	char *sep = ",\t";
	char *rsep = "\t]\n";

	Tablet as;
	Column *fmt;
	ssize_t i;
	size_t cnt;
	int clean = 0;
	BAT *order = NULL;

	if (!t)
		return -1;
	if (!s)
		return 0;

	if (!t->order)
		return mvc_export_row(m, s, t);

	m->type = Q_RESULT;
	order = BATdescriptor(t->order);
	cnt = nr;
	if (cnt == 0) {
		cnt = BATcount(order);
		clean = 1;
	}
	if (offset >= BATcount(order))
		cnt = 0;
	if (offset + cnt > BATcount(order)) {
		cnt = BATcount(order) - offset;
		clean = 1;
	}

	if (cnt == 0) {
		if (clean || !BATcount(order)) {
			BBPunfix(order->batCacheid);
			m->results = res_tables_remove(m->results, t);
		}
		if (stream_errnr(s))
			return -1;
		return 0;
	}
	as.nr_attrs = t->nr_cols + 1;	/* for the leader */
	as.nr = cnt;
	as.offset = offset;
	fmt = as.format = (Column *) GDKmalloc(sizeof(Column) * (as.nr_attrs + 1));

	memset(fmt, 0, (as.nr_attrs + 1) * sizeof(Column));

	fmt[0].bval = NULL;
	fmt[0].sep = _strdup("[ ");
	fmt[0].seplen = (int) strlen(fmt[0].sep);

	for (i = 1; i <= t->nr_cols; i++) {
		res_col *c = t->cols + (i - 1);

		if (!c->b)
			break;

		fmt[i].bval = BATdescriptor(c->b);
		fmt[i].name = NULL;
		fmt[i].sep = ((i - 1) < (t->nr_cols - 1)) ? _strdup(sep) : _strdup(rsep);
		fmt[i].seplen = (int) strlen(fmt[i].sep);
		fmt[i].type = ATOMname(fmt[i].bval->ttype);
		fmt[i].adt = fmt[i].bval->ttype;
		fmt[i].tostr = &_ASCIIadt_toStr;
		fmt[i].frstr = &_ASCIIadt_frStr;
		fmt[i].extra = NULL;
		if (c->type->type->eclass == EC_DEC) {
			fmt[i].tostr = &dec_tostr;
			fmt[i].frstr = &dec_frstr;
			fmt[i].extra = (void *) (ptrdiff_t) c->type->scale;
		} else if (c->type->type->eclass == EC_TIMESTAMP && strcmp(c->type->type->sqlname, "timestamptz") == 0) {
			fmt[i].tostr = &sql_timestamp_tostr;
			fmt[i].frstr = NULL;
			fmt[i].extra = m;
		} else if (c->type->type->eclass == EC_TIME && strcmp(c->type->type->sqlname, "timetz") == 0) {
			fmt[i].tostr = &sql_time_tostr;
			fmt[i].frstr = NULL;
			fmt[i].extra = m;
		}
	}
	if (i == t->nr_cols + 1) {
		TABLEToutput_file(&as, order, s);
	}
	BBPunfix(order->batCacheid);
	TABLETdestroy_format(&as);
	if (clean)
		m->results = res_tables_remove(m->results, t);
	if (stream_errnr(s))
		return -1;
	return 0;
}

int 
export_length( stream *s, int mtype, int eclass, int digits, int scale, bat bid, ptr p) 
{
	int ok = 1;
	size_t count = 0;

	if (mtype == TYPE_str) {
		if (eclass == EC_CHAR) {
			ok = mvc_send_int(s, digits);
		} else {
			count = 0;
			if (bid) {
				BAT *b = BATdescriptor(bid);

				count = bat_max_length(b);
				BBPunfix(b->batCacheid);
			} else {
				count = strlen((char *) p);
			}
			ok = mvc_send_int(s, count);
		}
		/* the following three could be done once by taking the
		   max value and calculating the number of digits from that
		   value, instead of the maximum values taken now, which
		   include the optional sign */
	} else if (eclass == EC_NUM) {
		if (mtype == TYPE_sht) {
			count = 6;
		} else if (mtype == TYPE_int) {
			count = 10;
		} else { /* TYPE_lng */
			count = 20;
		}
		ok = mvc_send_int(s, count);
	} else if (eclass == EC_FLT) {
	/* [sign]+digit+period+[max 6 digits]+E+[sign]+[max 2 digits] */
		if (mtype == TYPE_flt) {
			ok = mvc_send_int(s, 13);
	/* [sign]+digit+period+[max 14 digits]+E+[sign]+[max 3 digits] */
		} else { /* TYPE_dbl */
			ok = mvc_send_int(s, 22);
		}
	} else if (eclass == EC_DEC) {
		count = 1 + digits;
		if (scale > 0)
			count += 1;
		ok = mvc_send_int(s, count);
	} else if (eclass == EC_DATE) {
		ok = mvc_send_int(s, 10);
	} else if (eclass == EC_TIME) {
		count = 8;
		if (scale)	/* time zone */
			count += 6;	/* +03:30 */
		if (digits)	/* fractional seconds precision */
			count += 1 + digits;
		ok = mvc_send_int(s, count);
	} else if (eclass == EC_TIMESTAMP) {
		count = 10 + 1 + 8;
		if (scale)	/* time zone */
			count += 6;		/* +03:30 */
		if (digits)	/* fractional seconds precision */
			count += 1 + digits;
		ok = mvc_send_int(s, count);
	} else {
		ok = mvc_send_int(s, 0);
	}
	return ok;
}

int
mvc_export_value( mvc *m, stream *s, int qtype, str tn, str cn, str type, int d, int sc, int eclass, ptr p, int mtype) 
{
	char *buf = NULL;
	int len = 0;
	int ok = 1;
	char *rsep = "\t]\n";

	if (stream_write(s, mvcDefaultMsg[qtype-2], mvcDefaultMsg_len, 1) == 1&&
	    stream_write(s, "# ", 2, 1) == 1 &&
	    stream_write(s, tn, strlen(tn), 1) == 1 &&
	    stream_write(s, " # table_name\n# ", 16, 1) == 1 &&
	    stream_write(s, cn, strlen(cn), 1) == 1 &&
	    stream_write(s, " # name\n# ", 10, 1) == 1 &&
	    stream_write(s, type, strlen(type), 1) == 1 &&
	    stream_write(s, " # type\n# ", 10, 1) == 1 &&
	    export_length(s, mtype, eclass, d, sc, 0, p) &&
	    stream_write(s, " # length\n# 1 # tuplecount\n# 0 # id\n[ ", 38, 1) == 1 &&
	    export_value( m, s, eclass, type, sc, p, mtype, &buf, &len)) 
		ok = (stream_write(s, rsep, strlen(rsep), 1) == 1);
	    
	if (buf)
		_DELETE(buf);
	return ok;
}

int
mvc_export_result(mvc *m, stream *s, int res_id)
{
	int i, ok = 1;
	res_table *t = res_tables_find(m->results, res_id);
	char *buf,*b;

	if (!s)
		return 0;
	assert(t->query_type > 1 && t->query_type < 10);
	ok = (stream_write(s, mvcDefaultMsg[t->query_type-2], mvcDefaultMsg_len, 1) == 1);

	/* skip headers for affected row counts */
	if (ok && (t->query_type == Q_UPDATE || t->query_type == Q_TRANS))
		return mvc_export_table(m, s, t, 0, m->reply_size);

	if (!ok)
		return -1;
	m->type = Q_RESULT;

	ok = (stream_write(s, "# ", 2, 1) == 1);
	for (i = 0; i < t->nr_cols && ok; i++) {
		res_col *c = t->cols + i;
		int len = strlen(c->tn);

		if (len)
			ok = (stream_write(s, c->tn, len, 1) == 1);
		if (i + 1 < t->nr_cols && ok)
			ok = (stream_write(s, ",\t", 2, 1) == 1);
	}
	if (ok)
		ok = (stream_write(s, " # table_name\n# ", 16, 1) == 1);

	for (i = 0; i < t->nr_cols && ok; i++) {
		res_col *c = t->cols + i;

		ok = (stream_write(s, c->name, strlen(c->name), 1) == 1);
		if (i + 1 < t->nr_cols && ok)
			ok = (stream_write(s, ",\t", 2, 1) == 1);
	}
	if (ok)
		ok = (stream_write(s, " # name\n# ", 10, 1) == 1);

	for (i = 0; i < t->nr_cols && ok; i++) {
		res_col *c = t->cols + i;

		ok = (stream_write(s, c->type->type->sqlname, strlen(c->type->type->sqlname), 1) == 1);
		if (i + 1 < t->nr_cols && ok)
			ok = (stream_write(s, ",\t", 2, 1) == 1);
	}
	if (ok)
		ok = (stream_write(s, " # type\n# ", 10, 1) == 1);

	for (i = 0; i < t->nr_cols && ok; i++) {
		res_col *c = t->cols + i;
		int mtype = c->type->type->localtype;
		int eclass = c->type->type->eclass;

		ok = export_length(s, mtype, eclass, c->type->digits, c->type->scale, c->b, c->p);
		if (i + 1 < t->nr_cols && ok)
			ok = (stream_write(s, ",\t", 2, 1) == 1);
	}
	if (ok)
		ok = (stream_write(s, " # length\n", 10, 1) == 1);

	{
		size_t count;

		if (t->order) {
			BAT *order = BATdescriptor(t->order);

			count = BATcount(order);
			BBPunfix(order->batCacheid);
		} else
			count = 1;
		ok = (stream_write(s, "# " , 2,1) >= 0);
		ok= mvc_send_int(s,count);
		for (i = 1; i < t->nr_cols && ok; i++)
			ok = (stream_write(s, ",\t", 2, 1) == 1);
		if (ok)
			ok = (stream_write(s, " # tuplecount\n", 14, 1) == 1);
	}
	buf = alloca(t->nr_cols*2+100);
	ok = (stream_write(s, "# " , 2,1) >= 0);
	mvc_send_int(s,t->id);


	for (b=buf, i = 1; i < t->nr_cols && ok; i++)
	{
		*b++ =','; *b++ = '\t'; 
	}
	*b++ = ' '; *b++= '#'; *b++= ' ';
	*b++ = 'i'; *b++= 'd'; *b++= '\n'; *b=0;
	ok = (stream_write(s, buf, b-buf, 1) == 1); 

	if (ok)
		return mvc_export_table(m, s, t, 0, m->reply_size);
	return (ok) ? 0 : -1;
}

int
mvc_export_chunk(mvc *m, stream *s, int res_id, unsigned int offset, unsigned int nr)
{
	res_table *t = res_tables_find(m->results, res_id);
	return mvc_export_table(m, s, t, offset, nr);
}


int
mvc_result_table(mvc *m, int nr_cols, int type, BAT *order)
{
	res_table *t = res_table_create(m->trans, m->result_id++, nr_cols, type, m->results);

	t->order = order->batCacheid;
	bat_incref(t->order, TRUE, "mvc_result_table");
	m->results = t;
	return t->id;
}

int
mvc_result_column(mvc *m, char *tn, char *name, char *typename, int digits, int scale, BAT *b)
{
	res_col *c = res_col_create(m->trans, m->results, tn, name, typename, digits, scale);

	c->b = b->batCacheid;
	bat_incref(c->b, TRUE, "mvc_result_column");
	return 0;
}

int
mvc_result_value(mvc *m, char *tn, char *name, char *typename, int digits, int scale, ptr *p, int mtype)
{
	res_col *c = res_col_create(m->trans, m->results, tn, name, typename, digits, scale);

	c->mtype = mtype;
	c->p = ATOMdup(mtype, p);
	return 0;
}

