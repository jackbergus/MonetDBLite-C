@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2005 CWI.
@' All Rights Reserved.

@f sql_gencode
@t SQL to MAL code generation.
@a N. Nes, M. Kersten
@+ MAL Code generation
[TODO, check code generation, in particular the assignment of
the result to the proper variable]

This module contains the actions to construct a MAL program, ready for
optimization and execution by the Monet V5 kernel.

The code base is modeled directly after its MIL variant, replacing
each IO request by instructions to initialize the corresponding MAL data
structure.
To speed up the compilation, we may consider keeping a cache of pre-compiled
statements.

MAL extensions needed. A temporary variable used as an argument
should be printed (done). Consider replacing modname/fcnname by
an integer constant and a global lookup table. This should
reduce the cost to prepare MAL statements significantly.

A dummy module is needed to load properly.
@-
@h
#ifndef _SQL2MAL_H
#define _SQL2MAL_H

#include <sql.h>
#include <sql_atom.h>
#include <sql_statement.h>
#include <sql_mvc.h>
#include <mal_function.h>

sql_export int backend_dumpstmt(backend *be, MalBlkPtr mb, stmt *s);
sql_export void backend_dumpproc(backend *be, Client c, int id, stmt *s);
sql_export void backend_callinline(backend *be, Client c, stmt *s, list *args);
sql_export void backend_call(backend *be, Client c, int id, list *args);
sql_export int backend_exec_prepared_stmt( backend *be, cq *q );

#define _SQL_GENCODE_DEBUG
#endif /* _SQL2MAL_H */
@c
#include "sql_gencode.h"
#include "sql_optimizer.h"
#include "sql_scope.h"
#include "mal_namespace.h"

static int _dumpstmt(backend *sql, MalBlkPtr mb, stmt *s);

@+ MAL code support
To simplify construction of the MAL program use the following
macros

@c

static InstrPtr
newStmt(MalBlkPtr mb, char *module, char *name)
{
	InstrPtr q = newInstruction(ASSIGNsymbol);

	if( module==NULL) module="algebra";
	assert(name!= NULL);
	setModuleId(q, putName(module,strlen(module)));
	setFunctionId(q, putName(name,strlen(name)));
	getDestVar(q) = newTmpVariable(mb, TYPE_any);
	setVarInitialized(mb, getDestVar(q));
	pushInstruction(mb, q);
	return q;
}

static InstrPtr
newStmtId(MalBlkPtr mb, char *id, char *module, char *name)
{
	InstrPtr q = newInstruction(ASSIGNsymbol);

	if( module==NULL) module="algebra";
	assert(name!= NULL);
	setModuleId(q, putName(module,strlen(module)));
	setFunctionId(q, putName(name,strlen(name)));
	getDestVar(q) = newVariable(mb, _strdup(id), TYPE_any);

	setVarInitialized(mb, getDestVar(q));
	pushInstruction(mb, q);
	return q;
}

static InstrPtr
newAssignment(MalBlkPtr mb)
{
	InstrPtr q = newInstruction(ASSIGNsymbol);

	pushInstruction(mb, q);
	return q;
}

static InstrPtr
pushInt(MalBlkPtr mb, InstrPtr q, int val)
{
	int _t;
	char bufi[BUFSIZ];

	snprintf(bufi, BUFSIZ, "%d", val);
	_t = newConstant(mb, TYPE_int, _strdup(bufi), TRUE);
	return pushArgument(mb, q, _t);
}

static InstrPtr
pushLng(MalBlkPtr mb, InstrPtr q, long val)
{
	int _t;
	char bufi[BUFSIZ];

	snprintf(bufi, BUFSIZ, "%ld", val);
	_t = newConstant(mb, TYPE_lng, _strdup(bufi), TRUE);
	return pushArgument(mb, q, _t);
}

static InstrPtr
pushStr(MalBlkPtr mb, InstrPtr q, const char *val)
{
	int _t = newConstant(mb, TYPE_str, _strdup(val), TRUE);

	return pushArgument(mb, q, _t);
}

static InstrPtr
pushStrVal(MalBlkPtr mb, InstrPtr q, char *val)
{
	int _t = newConstant(mb, TYPE_str, val, TRUE);

	return pushArgument(mb, q, _t);
}


static InstrPtr
pushBit(MalBlkPtr mb, InstrPtr q, const char *val)
{
	int _t = newConstant(mb, TYPE_bit, _strdup(val), TRUE);

	return pushArgument(mb, q, _t);
}

static InstrPtr
pushNilType(MalBlkPtr mb, InstrPtr q, int tpe)
{
	int _t = newConstant(mb, tpe, _strdup("nil"), TRUE);
	return pushArgument(mb, q, _t);
}


@+ MAL initialization
Many instructions have a more or less fixed structure, therefore
they can be assembled in a pre-compiled block. Each time we need it,
a copy can be extracted and included in the MAL block

The catalog relations should be maintained in a MAL box, which
provides the handle for transaction management.
@-
The atoms produced by the parser should be converted back into
MAL constants. Ideally, this should not be necessary when the
SQL parser keeps the string representation around.
This involves regeneration of their string as well and
trimming the enclosing string quotes.
@c
static int
constantAtom(backend *sql, MalBlkPtr mb, atom *a)
{
	int idx;
	ValPtr vr = (ValPtr) &a->data;
	char *val;

	(void) sql;

	VALformat(&val, vr);
	if (vr->vtype == TYPE_str) {
		val[strlen(val) - 1] = 0;
		idx = newConstant(mb, vr->vtype, _strdup(val + 1), FALSE);
		GDKfree(val);
	} else {
		idx = newConstant(mb, vr->vtype, _strdup(val), FALSE);
		GDKfree(val);
	}
	return idx;
}

@-
Instructions are encapsulated with time code.
@= SQLprelude
	if (sql->debug&2) {
		/* t0:= time(); printf(" %d ",t0); */
		q = newStmtId(mb, "t0","alarm","usec");
		q = newStmt(mb,"io","printf");
		q = pushStr(mb,q," %d ");
		q = pushArgumentId(mb,q,_strdup("t0"));
	}

@= SQLpostlude
	if (sql->debug&2) {
		/* t1 := time();t1:= t1-t0; 
		   stream_printf(GDKout," %d ",t1);
		   stream_printf(GDKout,"%d\n",nr);*/
		q = newStmtId(mb,"t1","alarm","usec");
		q = newStmtId(mb,"t1","calc","-");
		q = pushArgumentId(mb,q,_strdup("t1"));
		q = pushArgumentId(mb,q,_strdup("t0"));
		q = newStmt(mb,"io","printf");
		q = pushStr(mb,q," %d ");
		q = pushArgumentId(mb,q,_strdup("t1"));
		q = newStmt(mb,"io","printf");
		q = pushStr(mb,q," %d \n");
		q = pushArgumentId(mb,q,_strdup("nr"));
	}
@-
The dump_header produces a sequence of instructions for
the front-end to prepare presentation of a result table.
@c
void
dump_header(MalBlkPtr mb, stmt *s, list *l)
{
	node *n;
	InstrPtr q;

	for (n = l->h; n; n = n->next) {
		stmt *c = n->data;
		char *tname = table_name(c);
		char *_tn = "";
		char *tn = (tname) ? tname : _tn;
		char *cn = column_name(c);

		q = newStmt(mb, "sql", "rsColumn");
		q = pushArgument(mb, q, s->nr);
		q = pushStr(mb, q, tn);
		q = pushStrVal(mb, q, cn);
		q = pushStr(mb, q, tail_type(c)->type->sqlname);
		q = pushInt(mb, q, tail_type(c)->digits);
		q = pushInt(mb, q, tail_type(c)->scale);
		if (tn != _tn)
			_DELETE(tn);
		q = pushArgument(mb, q, c->nr);
	}
}

@-
Some utility routines to generate code
The equality operator in MAL is '==' instead of '='.
@c
str
convertCalcOperator(str op)
{
	char buf[128];

	if (strcmp(op, "=") == 0)
		return _strdup("calc.==");
	buf[0] = 0;
	strcat(buf,"calc.");
	strcat(buf,op);
	return _strdup(buf);
}

str
convertOperator(str op)
{
	if (strcmp(op, "=") == 0)
		return "==";
	return op;
}

void
dump_1(backend *sql, MalBlkPtr mb, stmt *s, char *mod, char *name)
{
	InstrPtr q;
	int o1 = _dumpstmt(sql, mb, s->op1.stval);

	@:SQLprelude@
	q = newStmt(mb, mod, name);
	q = pushArgument(mb, q, o1);
	s->nr = getDestVar(q);
	@:SQLpostlude@
}

void
dump_2(backend *sql, MalBlkPtr mb, stmt *s, char *mod, char *name)
{
	InstrPtr q;
	int o1 = _dumpstmt(sql, mb, s->op1.stval);
	int o2 = _dumpstmt(sql, mb, s->op2.stval);

	@:SQLprelude@
	q = newStmt(mb, mod, name);
	q = pushArgument(mb, q, o1);
	q = pushArgument(mb, q, o2);
	s->nr = getDestVar(q);
	@:SQLpostlude@
}

InstrPtr
dump_multiplex(MalBlkPtr mb, char *name /* should be eaten */, int o1, int o2, int type, int rtype)
{
	InstrPtr q;
	int match=0;

	switch (*name){
	case '+': case '-': case '*': case '/': case '%':
		match=1;
		break;
	case '<': case '>': case '=': case '!':
		if( *(name+1) && *(name+1)=='=') match++; else
		if( *(name+1) == 0) match++;
		match= 1;
	}
	if (strcmp(name,"hash") == 0 || strcmp(name,"xor") == 0)
		match = 1;
	if( match && type <= TYPE_str){
		if (type == TYPE_str)
			q = newStmt(mb, "batstr", name);
		else
			q = newStmt(mb, "batcalc", name);
		/*setVarType(mb,getArg(q,0), newBatType(TYPE_void,rtype));*/
		q = pushArgument(mb, q, o1);
		q = pushArgument(mb, q, o2);
	} else {
		q = newStmt(mb, "optimizer","multiplex");
		setVarType(mb,getArg(q,0), newBatType(TYPE_void,rtype));
		q = pushStrVal(mb, q, convertCalcOperator(name));
		q = pushArgument(mb, q, o1);
		q = pushArgument(mb, q, o2);
	}
	return q;
}

@-
The intermediate results of this translation are mostly readonly.
Set this property to reduce copying.
@c
void
dump_3(backend *sql, MalBlkPtr mb, stmt *s, char *mod, char *name)
{
	InstrPtr q;
	int o1 = _dumpstmt(sql, mb, s->op1.stval);
	int o2 = _dumpstmt(sql, mb, s->op2.stval);

	@:SQLprelude@
	q = newStmt(mb, "bat", "setReadMode");
	q = pushArgument(mb, q, o1);

	q = newStmt(mb, mod, name);
	q = pushArgument(mb, q, o1);
	q = pushArgument(mb, q, o2);
	s->nr = getDestVar(q);
	@:SQLpostlude@
}

@-
The big code generation switch. The sections are aligned to the
Monet version4 code generation block for ease of comparison.
@c
static int 
_dumpstmt(backend *sql, MalBlkPtr mb, stmt *s)
{
	InstrPtr q = NULL;
	node *n;

	if (s) {
		if (s->nr > 0)
			return s->nr;	/* stmt already handled */

		switch (s->type) {
		case st_none: {
			q = newAssignment(mb);
			s->nr = getDestVar(q);
			q = pushInt(mb, q, 1);
			setVarInitialized(mb, s->nr);
		}	break;
		case st_sql:{
			int o1 = _dumpstmt(sql, mb, s->op1.stval);

			q = newStmt(mb, "sql", "eval");
			s->nr = getDestVar(q);
			q = pushArgument(mb, q, o1);
		} break;
		case st_var:{
			q = newAssignment(mb);
			s->nr = getDestVar(q);
			if (s->op1.sval) {
				q = pushArgumentId(mb, q, _strdup(s->op1.sval));
			} else {
				char buf[32];

				(void) snprintf(buf, 32, "A%d", s->flag);
				q = pushArgumentId(mb, q, _strdup(buf));
			}
			setVarInitialized(mb, s->nr);
		} break;
		case st_update_var:{
			dump_1(sql, mb, s, "sql", "setVariable");
		}
			break;
		case st_seq_next:{
			dump_1(sql, mb, s, "sql", "nextVariable");
		}
			break;
		case st_temp:{
			int l, r;
			int ht = TYPE_void;
			int tt = s->op4.typeval->type->localtype;

			q = newStmt(mb, "bat", "new");
			setVarType(mb, getArg(q, 0), newBatType(ht, tt));
			q = pushNilType(mb, q, ht);
			q = pushNilType(mb, q, tt);
			s->nr = getDestVar(q);

			l = getDestVar(q);
			r = newConstant(mb, TYPE_oid, _strdup("0@0"), TRUE);
			q = newStmt(mb, "bat", "setSequenceBase");
			q = pushArgument(mb, q, l);
			q = pushArgument(mb, q, r);
		} break;
		case st_column:
			s->nr = _dumpstmt(sql, mb, s->op1.stval);
			break;
		case st_bat:
		case st_ubat:{
			char *type = (s->type == st_bat) ? "" : "_ubat";
			char buf[256];
			int k;
			int ht = TYPE_void;
			int tt = s->op1.cval->type->type->localtype;

			@:SQLprelude@
			snprintf(buf, 256, "bind%s", type);
			q = newStmt(mb, "sql", buf);
			getVar(mb,getArg(q,0))->isudftype= 1;
			setVarType(mb, getArg(q, 0), newBatType(ht, tt));
			q = pushStr(mb, q, s->op1.cval->t->s->base.name);
			q = pushStr(mb, q, s->op1.cval->t->base.name);
			q = pushStr(mb, q, s->op1.cval->base.name);
			q = pushInt(mb, q, s->flag);
			k = getDestVar(q);
			s->nr = k;

			if (s->flag > RDONLY) {
				q = newStmt(mb, "bat", "setWriteMode");
				q = pushArgument(mb, q, k);
			}
			@:SQLpostlude@
		}
			break;
		case st_dbat:{
			int k;

			@:SQLprelude@
			q = newStmt(mb, "sql", "bind_dbat");
			getVar(mb,getArg(q,0))->isudftype= 1;
			setVarType(mb,getArg(q,0),newBatType(TYPE_void,TYPE_oid));

			q = pushStr(mb, q, s->op1.tval->s->base.name);
			q = pushStr(mb, q, s->op1.tval->base.name);
			q = pushInt(mb, q, s->flag);
			k = getDestVar(q);
			s->nr = k;

			if (s->flag > RDONLY) {
				q = newStmt(mb, "bat", "setWriteMode");
				q = pushArgument(mb, q, k);
			}
			@:SQLpostlude@
		}
			break;
		case st_idxbat:{
			int k, tt;

			@:SQLprelude@
			q = newStmt(mb, "sql", "bind_idxbat");
			tt = tail_type(s)->type->localtype;
			setVarType(mb, getArg(q, 0), newBatType(TYPE_void, tt));
			q = pushStr(mb, q, s->op1.idxval->t->s->base.name);
			q = pushStr(mb, q, s->op1.idxval->t->base.name);
			q = pushStr(mb, q, s->op1.idxval->base.name);
			q = pushInt(mb, q, s->flag);
			k = getDestVar(q);
			s->nr = k;

			if (s->flag > RDONLY) {
				q = newStmt(mb, "bat", "setWriteMode");
				q = pushArgument(mb, q, k);
			}
			@:SQLpostlude@
		}
			break;
		case st_const:{
			dump_2(sql, mb, s, "algebra", "project");
		}
			break;
		case st_mark:{
			dump_2(sql, mb, s, "algebra", "markT");
		}
			break;
		case st_gen_group:{
			dump_1(sql, mb, s, "algebra", "groupby");
		}
			break;
		case st_reverse:{
			dump_1(sql, mb, s, "bat", "reverse");
		}
			break;
		case st_mirror:{
			dump_1(sql, mb, s, "bat", "mirror");
		}
			break;
		case st_limit:{
			int l = _dumpstmt(sql, mb, s->op1.stval);
			int offset = _dumpstmt(sql, mb, s->op2.stval);
			int len = _dumpstmt(sql, mb, s->op3.stval);

			@:SQLprelude@

			if (s->flag) {
				int topn = 0;
				char *name = "topn_min";
				if ((s->flag-1) > 0)
					name = "topn_max"; 

				q = newStmt(mb, "calc", "+");
				q = pushArgument(mb,q, offset);
				q = pushArgument(mb,q, len);
				topn = getDestVar(q);
				 
				q = newStmt(mb, "pqueue", name);
				q = pushArgument(mb,q, l);
				q = pushArgument(mb, q, topn);
				l = getDestVar(q);

				/* the result of the topn is still sliced,
				 * to remove the offset part */
			}
			q = newStmt(mb, "calc", "+");
			q = pushArgument(mb, q, offset);
			q = pushArgument(mb, q, len);
			len = getDestVar(q);

			/* since both arguments of algebra.slice are inclusive
			   correct the LIMIT value by substracting 1 */
			q = newStmt(mb, "calc", "-");
			q = pushArgument(mb, q, len);
			q = pushInt(mb, q, 1);
			len = getDestVar(q);

			q = newStmt(mb, "algebra", "slice");
			q = pushArgument(mb, q, l);
			q = pushArgument(mb, q, offset);
			q = pushArgument(mb, q, len);
			s->nr = getDestVar(q);
			@:SQLpostlude@
		} break;
		case st_order:{
			int l = _dumpstmt(sql, mb, s->op1.stval);

			@:SQLprelude@
			q = newStmt(mb, "algebra", "sort" );
			q = pushArgument(mb, q, l);
			s->nr = getDestVar(q);
			if( s->flag == 0){
				q = newStmt(mb, "algebra","revert");
				q= pushArgument(mb,q,s->nr);
				s->nr = getDestVar(q);
			}
			@:SQLpostlude@
		} break;
		case st_reorder:{
			int l = _dumpstmt(sql, mb, s->op1.stval);
			int r = _dumpstmt(sql, mb, s->op2.stval);

			@:SQLprelude@
			if (s->flag) {
				q = newStmt(mb, "group", "refine");
			} else {
				q = newStmt(mb, "group", "refine_reverse");
			}
			q = pushArgument(mb, q, l);
			q = pushArgument(mb, q, r);
			s->nr = getDestVar(q);
			@:SQLpostlude@
		}
			break;

		case st_uselect:
		case st_select:{
			int l = _dumpstmt(sql, mb, s->op1.stval);
			int r = _dumpstmt(sql, mb, s->op2.stval);
			int k;

			char *cmd = s->type == st_select ? "select" : "uselect";

			@:SQLprelude@
			if (s->op2.stval->nrcols >= 1) {
				char *op = "=";
				int k;

				switch (s->flag) {
				case cmp_equal:
					op = "=";
					break;
				case cmp_notequal:
					op = "!=";
					break;
				case cmp_lt:
					op = "<";
					break;
				case cmp_lte:
					op = "<=";
					break;
				case cmp_gt:
					op = ">";
					break;
				case cmp_gte:
					op = ">=";
					break;
				default:
					GDKerror("Unknown operator");
				}
				q= dump_multiplex(mb,convertOperator(op),l,r,tail_type(s->op2.stval)->type->localtype, TYPE_bit);
				s->nr = getDestVar(q);
				k = getDestVar(q);
				q = newStmt(mb, "algebra", "uselect");
				q = pushArgument(mb, q, k);
				q = pushBit(mb, q, "true");
			} else {
				switch (s->flag) {
				case cmp_like:{
					int e = _dumpstmt(sql, mb, s->op3.stval);
					q = newStmt(mb, "batstr", "like");
					q = pushArgument(mb, q, l);
					q = pushArgument(mb, q, r);
					q = pushArgument(mb, q, e);
					break;
				}
				case cmp_notlike:{
					int e = _dumpstmt(sql, mb, s->op3.stval);
					int k;

					q = newStmt(mb, "batstr", "like");
					q = pushArgument(mb, q, l);
					q = pushArgument(mb, q, r);
					q = pushArgument(mb, q, e);
					k = getDestVar(q);
					q = newStmt(mb, "algebra", "kdifference");
					q = pushArgument(mb, q, l);
					q = pushArgument(mb, q, k);
					break;
				}
				case cmp_equal:{
					q = newStmt(mb, "algebra", cmd);
					q = pushArgument(mb, q, l);
					q = pushArgument(mb, q, r);
					break;
				}
				case cmp_notequal:{
					q = newStmt(mb, "algebra", "uselect");
					q = pushArgument(mb, q, l);
					q = pushArgument(mb, q, r);
					k = getDestVar(q);
					q = newStmt(mb, "algebra", "kdifference");
					q = pushArgument(mb, q, l);
					q = pushArgument(mb, q, k);
					break;
				}
				case cmp_lt:
					q = newStmt(mb, "algebra", cmd);
					q = pushArgument(mb, q, l);
					q = pushNilType(mb, q, tail_type(s)->type->localtype);
					q = pushArgument(mb, q, r);
					q = pushBit(mb, q, "false");
					q = pushBit(mb, q, "false");
					break;
				case cmp_lte:
					q = newStmt(mb, "algebra", cmd);
					q = pushArgument(mb, q, l);
					q = pushNilType(mb, q, tail_type(s)->type->localtype);
					q = pushArgument(mb, q, r);
					break;
				case cmp_gt:
					q = newStmt(mb, "algebra", cmd);
					q = pushArgument(mb, q, l);
					q = pushArgument(mb, q, r);
					q = pushNilType(mb, q, tail_type(s)->type->localtype);
					q = pushBit(mb, q, "false");
					q = pushBit(mb, q, "false");
					break;
				case cmp_gte:
					q = newStmt(mb, "algebra", cmd);
					q = pushArgument(mb, q, l);
					q = pushArgument(mb, q, r);
					q = pushNilType(mb, q, tail_type(s)->type->localtype);
					break;
				default:
					GDKerror("SQL2MAL: error impossible\n");
				}
			}
			s->nr = getDestVar(q);
			@:SQLpostlude@
		}
			break;
		case st_uselect2:
		case st_select2:{
			int l = _dumpstmt(sql, mb, s->op1.stval);
			int r1 = _dumpstmt(sql, mb, s->op2.stval);
			int r2 = _dumpstmt(sql, mb, s->op3.stval);
			char *cmd = st_uselect2 == s->type ? "uselect" : "select";

			@:SQLprelude@
			q = newStmt(mb, "algebra", cmd);
			q = pushArgument(mb, q, l);
			q = pushArgument(mb, q, r1);
			q = pushArgument(mb, q, r2);

			switch (s->flag) {
			case 0:
				q = pushBit(mb, q, "false");
				q = pushBit(mb, q, "false");
				break;
			case 1:
				q = pushBit(mb, q, "false");
				q = pushBit(mb, q, "true");
				break;
			case 2:
				q = pushBit(mb, q, "true");
				q = pushBit(mb, q, "false");
				break;
			case 3:
				q = pushBit(mb, q, "true");
				q = pushBit(mb, q, "true");
				break;
			}
			s->nr = getDestVar(q);
			@:SQLpostlude@
		}
			break;
		case st_semijoin:{
			dump_2(sql, mb, s, "algebra", "semijoin");
		}
			break;
		case st_diff:{
			dump_2(sql, mb, s, "algebra", "kdifference");
		}
			break;
		case st_union:{
			dump_2(sql, mb, s, "algebra", "kunion");
		}
			break;
		case st_reljoin:{
			node *ln = NULL, *rn = NULL;

			@:SQLprelude@
			if (list_length(s->op1.lval) == 1) {
				int l = _dumpstmt(sql, mb, s->op1.lval->h->data);
				int r = _dumpstmt(sql, mb, s->op2.lval->h->data);
				int k;

				q = newStmt(mb, "bat", "reverse");
				q = pushArgument(mb, q, r);
				k = getDestVar(q);
				q = newStmt(mb, "algebra", "join");
				q = pushArgument(mb, q, l);
				q = pushArgument(mb, q, k);
			} else {
				q = newStmt(mb, "algebra", "ds_link");
				for (ln = s->op1.lval->h, rn = s->op2.lval->h; ln && rn; ln = ln->next, rn = rn->next) {
					int l = _dumpstmt(sql, mb, ln->data);
					int r = _dumpstmt(sql, mb, rn->data);

					q = pushArgument(mb, q, l);
					q = pushArgument(mb, q, r);
				}
			}
			s->nr = getDestVar(q);
			@:SQLpostlude@
		} break;
		case st_outerjoin:
		case st_join:{
			int l = _dumpstmt(sql, mb, s->op1.stval);
			int r = _dumpstmt(sql, mb, s->op2.stval);
			char *jt = "join";

			@:SQLprelude@
			if (s->type == st_outerjoin)
				jt = "outerjoin";

			switch (s->flag) {
			case cmp_equal:
				q = newStmt(mb, "algebra", jt);

				q = pushArgument(mb, q, l);
				q = pushArgument(mb, q, r);
				@:SQLpostlude@
				break;
			case cmp_notequal:
				q = newStmt(mb, "algebra", "antijoin");

				q = pushArgument(mb, q, l);
				q = pushArgument(mb, q, r);
				@:SQLpostlude@
				break;
			case cmp_lt:
				q = newStmt(mb, "algebra", "thetajoin");

				q = pushArgument(mb, q, l);
				q = pushArgument(mb, q, r);
				q = pushInt(mb, q, -1);
				@:SQLpostlude@
				break;
			case cmp_lte:
				q = newStmt(mb, "algebra", "thetajoin");

				q = pushArgument(mb, q, l);
				q = pushArgument(mb, q, r);
				q = pushInt(mb, q, -2);
				@:SQLpostlude@
				break;
			case cmp_gt:
				q = newStmt(mb, "algebra", "thetajoin");

				q = pushArgument(mb, q, l);
				q = pushArgument(mb, q, r);
				q = pushInt(mb, q, 1);
				@:SQLpostlude@
				break;
			case cmp_gte:
				q = newStmt(mb, "algebra", "thetajoin");

				q = pushArgument(mb, q, l);
				q = pushArgument(mb, q, r);
				q = pushInt(mb, q, 2);
				@:SQLpostlude@
				break;
			case cmp_all:	/* aka cross table */
			{
				int z;

				q = newStmt(mb, "bat", "reverse");
				q = pushArgument(mb, q, r);
				r = getDestVar(q);

				q = newStmt(mb, "calc", "int");
				q = pushInt(mb, q, 0);
				z = getDestVar(q);

				q = newStmt(mb, "algebra", "project");
				q = pushArgument(mb, q, r);
				q = pushArgument(mb, q, z);
				r = getDestVar(q);

				q = newStmt(mb, "bat", "reverse");
				q = pushArgument(mb, q, r);
				r = getDestVar(q);

				q = newStmt(mb, "algebra", "project");
				q = pushArgument(mb, q, l);
				q = pushArgument(mb, q, z);
				l = getDestVar(q);

				q = newStmt(mb, "algebra", "join");
				q = pushArgument(mb, q, l);
				q = pushArgument(mb, q, r);
				@:SQLpostlude@
				break;
			}
			default:
				GDKerror("SQL2MAL: error impossible\n");
			}
			s->nr = getDestVar(q);
			break;
		}
		case st_group:{
			char nme[BUFSIZ];
			int ext, grp, o1 = _dumpstmt(sql, mb, s->op1.stval);

			@:SQLprelude@
			q = newStmt(mb, "group", "new");
			ext = getDestVar(q);
			snprintf( nme, BUFSIZ, "grp%d", getDestVar(q));
        		q = pushReturn(mb, q, newVariable(mb, _strdup(nme), TYPE_any));
			setVarInitialized(mb, getArg(q, 1));
			grp = getArg(q, 1);
			q = pushArgument(mb, q, o1);

			q = newAssignment(mb);
			q = pushArgument(mb, q, grp);
			s->nr = getDestVar(q);
			setVarInitialized(mb, s->nr);
			
			snprintf( nme, BUFSIZ, "ext%d", s->nr);
			renameVariable(mb, ext, _strdup(nme));

			@:SQLpostlude@
		} 	break;
		case st_group_ext:{
			char ext[BUFSIZ];
			int e = -1, g = _dumpstmt(sql, mb, s->op1.stval);

			snprintf( ext, BUFSIZ, "ext%d", g);
			e = findVariable(mb, ext);
			assert(e >= 0);

			@:SQLprelude@
			q = newStmt(mb, "bat", "mirror");
			q = pushArgument(mb, q, e);
			s->nr = getDestVar(q);
			@:SQLpostlude@
		} break;
		case st_derive:{
			char nme[BUFSIZ];
			int ext, grp;
			int g = _dumpstmt(sql, mb, s->op1.stval);
			int l = _dumpstmt(sql, mb, s->op2.stval);

			@:SQLprelude@
			q = newStmt(mb, "group", "derive");
			ext = getDestVar(q);
			snprintf( nme, BUFSIZ, "grp%d", getDestVar(q));
        		q = pushReturn(mb, q, newVariable(mb, _strdup(nme), TYPE_any));
			setVarInitialized(mb, getArg(q, 1));
			setVarInitialized(mb, getArg(q, 0));
			grp = getArg(q, 1);
			q = pushArgument(mb, q, g);
			q = pushArgument(mb, q, l);

			q = newAssignment(mb);
			q = pushArgument(mb, q, grp);
			s->nr = getDestVar(q);
			setVarInitialized(mb, s->nr);

			snprintf( nme, BUFSIZ, "ext%d", s->nr);
			renameVariable(mb, ext, _strdup(nme));

			@:SQLpostlude@
		} 	break;
		case st_unique:{
			int l = _dumpstmt(sql, mb, s->op1.stval);

			@:SQLprelude@
			if (s->op2.stval) {
				char nme[BUFSIZ];
				int e, g = _dumpstmt(sql, mb, s->op2.stval);

				q = newStmt(mb, "group", "derive");
				e = getDestVar(q);
				snprintf( nme, BUFSIZ, "grp%d", getDestVar(q));
        			q = pushReturn(mb, q, newVariable(mb, _strdup(nme), TYPE_any));
				setVarInitialized(mb, getArg(q, 1));
				setVarInitialized(mb, getArg(q, 0));
				q = pushArgument(mb, q, g);
				q = pushArgument(mb, q, l);

				q = newStmt(mb, "bat", "mirror");
				q = pushArgument(mb, q, e);
				e = getDestVar(q);

				q = newStmt(mb, "algebra", "semijoin");
				q = pushArgument(mb, q, l);
				q = pushArgument(mb, q, e);
			} else {
				int k;

				q = newStmt(mb, "bat", "reverse");
				q = pushArgument(mb, q, l);
				k = getDestVar(q);
				q = newStmt(mb, "algebra", "kunique");
				q = pushArgument(mb, q, k);
				k = getDestVar(q);
				q = newStmt(mb, "bat", "reverse");
				q = pushArgument(mb, q, k);
			}
			s->nr = getDestVar(q);
			@:SQLpostlude@
			break;
		}
		case st_convert: {
			char *convert = s->op4.typeval->type->base.name;
			/* convert types and make sure they are rounded up correctly */
			int l = _dumpstmt(sql, mb, s->op1.stval);

			@:SQLprelude@

			if (s->op4.typeval->type->eclass == EC_INTERVAL) {
				if (s->op4.typeval->type->localtype == TYPE_int)
					convert = "month_interval";
				else
					convert = "second_interval";
			}

			/* Lookup the sql convert function, there is no need
			 * to for single value vs bat, this is handled by the 
			 * mal function resolution */
			if (s->nrcols == 0) { /* simple calc */
				q = newStmt(mb, "calc", convert);
			} else if (s->nrcols > 0 && 
				(s->op3.typeval->type->eclass == EC_DEC ||
				 s->op4.typeval->type->eclass == EC_DEC ||
				 s->op4.typeval->type->eclass == EC_INTERVAL ||
				 EC_TEMP(s->op4.typeval->type->eclass)) ){
				int type = s->op4.typeval->type->localtype;

				q = newStmt(mb, "optimizer","multiplex");
				setVarType(mb,getArg(q,0), newBatType(TYPE_void,type));
				q = pushStrVal(mb, q, convertCalcOperator(convert));
			} else {
				q = newStmt(mb, "batcalc", convert);
			}

			if (s->op3.typeval->type->eclass == EC_DEC) 
				/* scale of the current decimal */
				q = pushInt(mb, q, s->op3.typeval->scale);
			q = pushArgument(mb, q, l);
	
			if (s->op4.typeval->type->eclass == EC_DEC ||
			    s->op4.typeval->type->eclass == EC_INTERVAL) {
				/* digits, scale of the result decimal */
				q = pushInt(mb, q, s->op4.typeval->digits);
				q = pushInt(mb, q, s->op4.typeval->scale);
			}
			s->nr = getDestVar(q);
			@:SQLpostlude@
			break;
		}
		case st_op:{
			@:SQLprelude@
			if (s->op1.stval && s->op1.stval->nrcols) 
				q = newStmt(mb, "algebra", s->op4.funcval->func->imp);
			else
				q = newStmt(mb, "calc", s->op4.funcval->func->imp);
			s->nr = getDestVar(q);
			@:SQLpostlude@
			break;
		}
		case st_unop:{
			int l = _dumpstmt(sql, mb, s->op1.stval);

			@:SQLprelude@
			if (s->op1.stval->nrcols) {
				sql_subtype *a = tail_type(s);
				q = newStmt(mb, "optimizer","multiplex");
				setVarType(mb,getArg(q,0), newBatType(TYPE_void,a->type->localtype));
				s->nr = getDestVar(q);
				q = pushStrVal(mb, q, convertCalcOperator(s->op4.funcval->func->imp));
				q = pushArgument(mb, q, l);
			} else {
				q = newStmt(mb, "calc", s->op4.funcval->func->imp);
				q = pushArgument(mb, q, l);
			}
			s->nr = getDestVar(q);
			@:SQLpostlude@
		}
			break;
		case st_binop:{
			int l = _dumpstmt(sql, mb, s->op1.stval);
			int r = _dumpstmt(sql, mb, s->op2.stval);

			@:SQLprelude@
			if (s->op1.stval->nrcols || s->op2.stval->nrcols) {
				q= dump_multiplex(mb,convertOperator(s->op4.funcval->func->imp),l,r,tail_type(s->op2.stval)->type->localtype, s->op4.funcval->func->res->type->localtype);
				s->nr = getDestVar(q);
			} else {
				q = newStmt(mb, "calc", convertOperator(s->op4.funcval->func->imp));
				q = pushArgument(mb, q, l);
				q = pushArgument(mb, q, r);
			}
			s->nr = getDestVar(q);
			@:SQLpostlude@
		}
			break;
		case st_Nop:{
			node *n;

			/* dump operands */
			_dumpstmt(sql, mb, s->op1.stval);	

			@:SQLprelude@
			if (s->nrcols) {
				q = newStmt(mb, "optimizer","multiplex");
				setVarType(mb,getArg(q,0), 
					newBatType(TYPE_void,tail_type(s->op1.stval)->type->localtype));
				q = pushStrVal(mb, q, convertCalcOperator(s->op4.funcval->func->imp));
			} else {
				q = newStmt(mb, "calc", s->op4.funcval->func->imp);
			}
			for (n = s->op1.stval->op1.lval->h; n; n = n->next) {
				stmt *op = n->data;

				q = pushArgument(mb, q, op->nr);
			}
			s->nr = getDestVar(q);
			@:SQLpostlude@
		} break;
		case st_aggr:{
			int l = _dumpstmt(sql, mb, s->op1.stval);
			char *aggrfunc = _strdup(s->op4.aggrval->aggr->imp);
			char *c;
			int restype = s->op4.aggrval->aggr->res->type->localtype;
			sql_subtype *tpe = tail_type(s->op1.stval);
			int output_type_needed = 0;
			
			/* some aggr functions require bigger outputs types */
			if (tpe &&
			    (s->op4.aggrval->aggr->res->type->localtype > 
			    tpe->type->localtype || 
			    (s->op4.aggrval->aggr->res->type->localtype == 
			     tpe->type->localtype && 
			     tpe->type->localtype == TYPE_lng)) ) {
				/* Cut off the type information.
			   	It should be handled by the type resolver
			 	*/
				c = strchr(aggrfunc, '_');
				if (c) {
					output_type_needed = 1;
					*c = 0;
				}
			}

			@:SQLprelude@
			if (s->op3.gval) {
				int g = _dumpstmt(sql, mb, s->op2.stval);
				int e = _dumpstmt(sql, mb, s->op3.stval);

				q = newStmt(mb, "aggr", aggrfunc);
				if (output_type_needed)
					setVarType(mb, getArg(q, 0), newBatType(TYPE_void,restype));
				q = pushArgument(mb, q, l);
				q = pushArgument(mb, q, g);
				q = pushArgument(mb, q, e);
			} else {
				q = newStmt(mb, "aggr", aggrfunc);
				if (output_type_needed)
					setVarType(mb, getArg(q, 0), restype);
				q = pushArgument(mb, q, l);
			}
			_DELETE(aggrfunc);
			s->nr = getDestVar(q);
			@:SQLpostlude@
		}
			break;
		case st_atom:{
			atom *a = s->op1.aval;
			if (atom_null(a)) {
				q = newStmt(mb, "calc", a->tpe->type->base.name);
				q = pushNilType(mb, q, a->tpe->type->localtype);
			} else {
				int k;
				q = newStmt(mb, "calc",a->tpe->type->base.name);
				k = constantAtom(sql, mb, a);
				q = pushArgument(mb, q, k);
			}
			s->nr = getDestVar(q);
		}
			break;
		case st_insert:{
			int l = _dumpstmt(sql, mb, s->op1.stval);
			int r = _dumpstmt(sql, mb, s->op2.stval);

			@:SQLprelude@
			if (s->op2.stval->nrcols) {
				q = newStmt(mb, "bat", "insert");
				q = pushArgument(mb, q, l);
				q = pushArgument(mb, q, r);
				s->nr = l;
			} else {
				q = newStmt(mb, "bat", "insert");
				q = pushArgument(mb, q, l);
				q = pushArgument(mb, q, r);
				s->nr = l;
			}
			@:SQLpostlude@
		}
			break;
		case st_append:{
			int l = _dumpstmt(sql, mb, s->op1.stval);
			int r = _dumpstmt(sql, mb, s->op2.stval);

			q = newStmt(mb, "bat", "append");
			q = pushArgument(mb, q, l);
			q = pushArgument(mb, q, r);
			s->nr = l;
			@:SQLpostlude@
		} break;
		case st_replace:{
			int l = _dumpstmt(sql, mb, s->op1.stval);
			int r = _dumpstmt(sql, mb, s->op2.stval);

			@:SQLprelude@
			q = newStmt(mb, "bat", "replace");
			q = pushArgument(mb, q, l);
			q = pushArgument(mb, q, r);
			s->nr = l;
			@:SQLpostlude@
		} break;
		case st_table_clear:{
			sql_table *t = s->op1.tval;

			@:SQLprelude@
			q = newStmt(mb, "sql", "clear_table");
			q = pushStr(mb, q, t->s->base.name);
			q = pushStr(mb, q, t->base.name);
			s->nr = getDestVar(q);
			@:SQLpostlude@
		} break;
		case st_exception:{
			int l = _dumpstmt(sql, mb, s->op1.stval);
			int r = _dumpstmt(sql, mb, s->op2.stval);

			@:SQLprelude@
			/* if(bit(l)) { error(r);}  ==raising an exception */
			q = newStmt(mb, "sql", "assert");
			q = pushArgument(mb, q, l);
			q = pushArgument(mb, q, r);
			s->nr = getDestVar(q);
			@:SQLpostlude@
			break;
		}
		case st_intersect:{
			int l = _dumpstmt(sql, mb, s->op1.stval);
			int r = _dumpstmt(sql, mb, s->op2.stval);

			@:SQLprelude@
			q = newStmt(mb, "algebra", "sintersect");
			q = pushArgument(mb, q, l);
			q = pushArgument(mb, q, r);
			s->nr = getDestVar(q);
			@:SQLpostlude@
		} break;
		case st_alias:
			s->nr = _dumpstmt(sql, mb, s->op1.stval);
			break;
		case st_set:
		case st_list:{
			for (n = s->op1.lval->h; n; n = n->next) {
				_dumpstmt(sql, mb, n->data);
			}
		}
			break;
		case st_sets:{
			for (n = s->op1.lval->h; n; n = n->next) {
				list *l = n->data;
				node *ml = l->h;

				while (ml) {
					_dumpstmt(sql, mb, ml->data);
					ml = ml->next;
				}
			}
		}
			break;
		case st_find:{
			/* this command is called to fetch a BAT from an import */
			/* dump_2(sql,mb,s,"algebra","find"); */
			int o1 = _dumpstmt(sql, mb, s->op1.stval);
			int o2 = _dumpstmt(sql, mb, s->op2.stval);

			@:SQLprelude@
			q = newStmt(mb, "sql", "columnBind");
			/* adjust destination type */
			setVarType(mb,getArg(q,0), newBatType(
				TYPE_void,s->op4.cval->type->type->localtype));
			q = pushArgument(mb, q, o1);
			q = pushArgument(mb, q, o2);
			s->nr = getDestVar(q);
			@:SQLpostlude@
		} break;
		case st_bulkinsert:{
			char *tname = s->op1.stval->op1.tval->base.name;
			int sep = _dumpstmt(sql, mb, s->op2.stval);
			int rsep = _dumpstmt(sql, mb, s->op3.stval);

			if (s->op4.stval) {
				int file = _dumpstmt(sql, mb, s->op4.stval);
				int codeset;

				q = newStmt(mb, "str", "codeset");
				codeset = getDestVar(q);

				q = newStmt(mb, "str", "iconv");
				q = pushArgument(mb, q, file);
				q = pushStr(mb, q, "UTF-8");
				q = pushArgument(mb, q, codeset);

				q = newStmt(mb, "stream", "openRead");
				q = pushArgument(mb, q, file);
				file = getDestVar(q);

				q = newStmt(mb, "sql", "importTable");
				q = pushArgument(mb, q, file);
				q = pushStr(mb, q, tname);
				q = pushArgument(mb, q, sep);
				q = pushArgument(mb, q, rsep);
				q = pushInt(mb, q, s->flag);
				s->nr = getDestVar(q);

				q = newStmt(mb, "stream", "close");
				q = pushArgument(mb, q, file);
			} else {
				q = newStmt(mb, "sql", "importTable");
				q = pushStr(mb, q, "Input");
				q = pushStr(mb, q, tname);
				q = pushArgument(mb, q, sep);
				q = pushArgument(mb, q, rsep);
				q = pushInt(mb, q, s->flag);
				s->nr = getDestVar(q);
			}
		}
			break;
		case st_filter:
			s->nr = _dumpstmt(sql, mb, s->op1.stval);
			break;
		case st_ordered:{
			int l = _dumpstmt(sql, mb, s->op1.stval);

			_dumpstmt(sql, mb, s->op2.stval);
			s->nr = l;
		} break;
		case st_output:{
			stmt *order = NULL;
			stmt *lst = s->op1.stval;

			_dumpstmt(sql, mb, lst);

			if (lst->type == st_ordered) {
				order = lst->op1.stval;
				lst = lst->op2.stval;
			}
			if (lst->type == st_list) {
				list *l = lst->op1.lval;
				int cnt = list_length(l);
				InstrPtr k;

				n = l->h;
				if (n) {
					if (!order) {
						order = n->data;
					}
				}
				k = newStmt(mb, "sql", "resultSet");
				s->nr = getDestVar(k);
				k = pushInt(mb, k, cnt);
				k = pushInt(mb, k, sql->mvc->type);
				k = pushArgument(mb, k, order->nr);
				dump_header(mb, s, l);
				
				q = newStmt(mb, "sql", "exportResult");
				q = pushArgument(mb, q, s->nr);
			} else {
				q = newStmt(mb, "sql", "print");
				q = pushStr(mb, q, "not a valid output list\n");
			}
		}
			break;

			/* todo */
		case st_basetable:
		case st_ptable:
		case st_pivot:
		case st_relselect:
		case st_groupby:
			stream_printf(GDKout, "not implemented stmt\n");
			assert(0);


		}
/*	if (s->nr == 0) s->nr = mb->stop;*/
#ifdef _SQL_GENCODE_DEBUG
	} else {
		stream_printf(GDKout, "called with zero statement nr\n");
#endif
	}
	return s->nr;
}

int backend_dumpstmt(backend *be, MalBlkPtr mb, stmt *s)
{
	int nr = _dumpstmt(be, mb, s);
	mvc *c = be->mvc;

	if (c->cache && c->type != Q_RESULT && c->type != Q_UPDATE) {
		InstrPtr q = newStmt(mb, "sql", "exportResult");
		return getDestVar(q);
	}
	return nr;
}

void
backend_callinline(backend *be, Client c, stmt *s, list *args)
{
	InstrPtr curInstr = 0;
	MalBlkPtr curBlk = c->curprg->def;

	curInstr = getInstrPtr(curBlk, 0);

	if (args) { /* we shouldn't come here as we aren't caching statements */
		int argc=0;
		char arg[32];
		node *n;

		for (n = args->h; n; n = n->next, argc++) {
			atom *a = n->data;
			int type = a->tpe->type->localtype;
			int varid = 0;

			curInstr = newAssignment(curBlk);
			snprintf(arg, 32, "A%d", argc);
			varid = getDestVar(curInstr);
			renameVariable(curBlk, varid, _strdup(arg));
			setVarType(curBlk, varid, type);

			if (atom_null(a)) {
				sql_subtype *t = a->tpe;
				curInstr = pushNilType(curBlk, curInstr, t->type->localtype);
			} else {
				int _t = constantAtom(be, curBlk, a);
				curInstr = pushArgument(curBlk, curInstr, _t);
			}
		}
	}
	backend_dumpstmt(be, curBlk, s);
	c->curprg->def = curBlk;
}

void
backend_dumpproc(backend *be, Client c, int id, stmt *s)
{
	MalBlkPtr curBlk = 0;
	Symbol curPrg = 0;
	InstrPtr curInstr = 0;
	char fnme[BUFSIZ];
	int argc = 0;
	char arg[32];
	node *n;

	/* later we could use the id directly (as its unique) and
	   just create a InstrPtr using newInstruction */
	snprintf(fnme, BUFSIZ, "sql%d", id);

	c->backup = c->curprg;

	/* later we change this to a factory ? */
	c->curprg = newFunction(putName(fnme,strlen(fnme)), FUNCTIONsymbol);
	curPrg = c->curprg;
	curBlk = curPrg->def;
	curInstr = getInstrPtr(curBlk, 0);
	setModuleId(curInstr, putName("sql_cache",9));

	if (be->mvc->args) {

		for (n = be->mvc->args->h; n; n = n->next, argc++) {
			atom *a = n->data;
			int type = a->tpe->type->localtype;
			int varid = 0;

			snprintf(arg, 32, "A%d", argc);
			varid = newVariable(curBlk, _strdup(arg), type);
			curInstr = pushArgument(curBlk, curInstr, varid);
			setVarType(curBlk, varid, type);
		}
	} else if (be->mvc->params) { /* needed for prepare statements */

		for (n = be->mvc->params->h; n; n = n->next, argc++) {
			var_ *v = n->data;
			int type = tail_type(v->s)->type->localtype;
			int varid = 0;

			snprintf(arg, 32, "A%d", argc);
			varid = newVariable(curBlk, _strdup(arg), type);
			curInstr = pushArgument(curBlk, curInstr, varid);
			setVarType(curBlk, varid, type);
		}
	}
	backend_dumpstmt(be, curBlk, s);

	pushEndInstruction(curBlk);
	addQueryToCache(c);
	if (c->backup) {
		c->curprg = c->backup;
		c->backup = 0;
	}
}

void
backend_call(backend *be, Client c, int id, list *args)
{

	InstrPtr q;
	MalBlkPtr mb = c->curprg->def;
	char name[BUFSIZ];

	(void) snprintf(name, BUFSIZ, "sql%d", id);

	q = newStmt(mb, "sql_cache", name);
	setVarType(mb, getArg(q, 0), TYPE_void);
	if (args) {
		node *n, *p;

		for (n = args->h, p = be->q->params->h; n && p; 
		     n = n->next, p = p->next) {
			atom *a = n->data;

			if (atom_null(a)) {
				sql_subtype *t = p->data;
				/* need type from the prepared argument */
				q = pushNilType(mb, q, t->type->localtype);
			} else {
				int _t = constantAtom(be, mb, a);
				q = pushArgument(mb, q, _t);
			}
		}
	}
}

int
backend_exec_prepared_stmt( backend *be, cq *q )
{
	mvc *c = be->mvc;
	node *a, *p;
	int argc, parc; 

	argc = c->args?list_length(c->args):0;
	parc = q->params?list_length(q->params):0;

	if (argc != parc) {
		sql_error(c, 0002, "wrong number of arguments for prepared statement\n");
		return -1;
	} else if (c->args) {
		for (a = c->args->h, p = q->params->h; a && p; a = a->next, p = p->next) {
			atom *arg = a->data;
			sql_subtype *pt = p->data;

			if (!atom_cast(arg, pt)) {
				char buf[BUFSIZ];

				snprintf(buf, BUFSIZ, "wrong argument for prepared statement (expected %s instead of %s)\n", pt->type->sqlname, arg->tpe->type->sqlname);
				sql_error(c, 003, buf);
				return -1;
			}
		}
	}
	return 0;
}
