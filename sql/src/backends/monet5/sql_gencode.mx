@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2007 CWI.
@' All Rights Reserved.

@f sql_gencode
@t SQL to MAL code generation.
@a N. Nes, M. Kersten
@+ MAL Code generation
This module contains the actions to construct a MAL program, ready for
optimization and execution by the Monet V5 kernel.

The code base is modeled directly after its MIL variant, replacing
each IO request by instructions to initialize the corresponding MAL data
structure.
To speed up the compilation, we may consider keeping a cache of pre-compiled
statements.

MAL extensions needed. A temporary variable used as an argument
should be printed (done). Consider replacing modname/fcnname by
an integer constant and a global lookup table. This should
reduce the cost to prepare MAL statements significantly.

A dummy module is needed to load properly.
@-
@h
#ifndef _SQL2MAL_H
#define _SQL2MAL_H

#include <sql.h>
#include <sql_atom.h>
#include <sql_statement.h>
#include <sql_mvc.h>
#include <mal_function.h>

sql5_export int backend_dumpstmt(backend *be, MalBlkPtr mb, stmt *s);
sql5_export Symbol backend_dumpproc(backend *be, Client c, cq *q, stmt *s);
sql5_export void backend_callinline(backend *be, Client c, stmt *s);
sql5_export void backend_call(backend *be, Client c, cq *q);
sql5_export void initSQLreferences(void);
sql5_export str backend_name(cq *cq);

#endif /* _SQL2MAL_H */
@c
#include "sql_config.h"
#include "sql_gencode.h"
#include "sql_optimizer.h"
#include "sql_scope.h"
#include "mal_namespace.h"
#include "opt_prelude.h"
#include "mal_builder.h"

#include <sql_optimize.h>
#include <sql_rel2bin.h>

static int _dumpstmt(backend *sql, MalBlkPtr mb, stmt *s);
static void backend_create_func(backend *be, sql_func *f);

@+ MAL code support
To simplify construction of the MAL program use the following
macros

@+ MAL initialization
Many instructions have a more or less fixed structure, therefore
they can be assembled in a pre-compiled block. Each time we need it,
a copy can be extracted and included in the MAL block

The catalog relations should be maintained in a MAL box, which
provides the handle for transaction management.
@-
The atoms produced by the parser should be converted back into
MAL constants. Ideally, this should not be necessary when the
SQL parser keeps the string representation around.
This involves regeneration of their string as well and
trimming the enclosing string quotes.
@c
static int
constantAtom(backend *sql, MalBlkPtr mb, atom *a)
{
	int idx;
	ValPtr vr = (ValPtr) &a->data;
	ValRecord cst;

	(void) sql;
	VALcopy(&cst,vr);
	idx= defConstant(mb, vr->vtype, &cst);
	return idx;
}
@-
To speedup code generation we freeze the references to the major modules.
This safes table lookups.
@c
static str exportValueRef;
static str exportResultRef;
static str exportOperationRef;

void initSQLreferences(void){
	optimizerInit();
	exportValueRef = putName("exportValue",11);
	exportResultRef= putName("exportResult",12);
	exportOperationRef= putName("exportOperation",15);
	if( algebraRef==NULL || exportValueRef==NULL ||
		exportResultRef==NULL || exportOperationRef==NULL )
			GDKfatal("error initSQLreferences");
}
@-
Instructions are encapsulated with time code.
@= SQLprelude
	if (mvc_debug_on(sql->mvc, 2)) {
		/* t0:= time(); printf(" %d ",t0); */
		q = newStmtId(mb, "t0","alarm","usec");
		q = newStmt(mb,"io","printf");
		q = pushStr(mb,q," %d ");
		q = pushArgumentId(mb,q,_strdup("t0"));
	}

@= SQLpostlude
	if (mvc_debug_on(sql->mvc, 2)) {
		/* t1 := time();t1:= t1-t0; 
		   stream_printf(GDKout," %d ",t1);
		   stream_printf(GDKout,"%d\n",nr);*/
		q = newStmtId(mb,"t1","alarm","usec");
		q = newStmtId(mb,"t1","calc","-");
		q = pushArgumentId(mb,q,_strdup("t1"));
		q = pushArgumentId(mb,q,_strdup("t0"));
		q = newStmt(mb,"io","printf");
		q = pushStr(mb,q," %d ");
		q = pushArgumentId(mb,q,_strdup("t1"));
		q = newStmt(mb,"io","printf");
		q = pushStr(mb,q," %d \n");
		q = pushArgumentId(mb,q,_strdup("nr"));
	}
@-
The dump_header produces a sequence of instructions for
the front-end to prepare presentation of a result table.
@c
void
dump_header(MalBlkPtr mb, stmt *s, list *l)
{
	node *n;
	InstrPtr q;

	for (n = l->h; n; n = n->next) {
		stmt *c = n->data;
		sql_subtype *t = tail_type(c);
		char *tname = table_name(c);
		char *sname = schema_name(c);
		char *_empty = "";
		char *tn = (tname) ? tname : _empty;
		char *sn = (sname) ? sname : _empty;
		char *cn = column_name(c);
		char *ntn = sql_escape_ident(tn);
		char *nsn = sql_escape_ident(sn);
		char *fqtn = alloca(sizeof(char) * (strlen(nsn) + 1 + strlen(ntn) + 1));

		fqtn[0]=0;
		strcat(fqtn, nsn);
		strcat(fqtn, ".");
		strcat(fqtn, ntn);

		q = newStmt1(mb, sqlRef, "rsColumn");
		q = pushArgument(mb, q, s->nr);
		q = pushStr(mb, q, fqtn);
		q = pushStr(mb, q, cn);
		q = pushStr(mb, q, t->type->sqlname);
		q = pushInt(mb, q, t->digits);
		q = pushInt(mb, q, t->scale);
		q = pushArgument(mb, q, c->nr);
		if (tn != _empty)
			_DELETE(tn);
		if (sn != _empty)
			_DELETE(sn);
		_DELETE(cn);
		_DELETE(ntn);
		_DELETE(nsn);
	}
}

@-
The dump_cols produces a sequence of instructions for
the front-end to prepare presentation of a result table (bat).
@c
void
dump_cols(MalBlkPtr mb, list *l, int result_set)
{
	node *n;
	InstrPtr q;

	for (n = l->h; n; n = n->next) {
		stmt *c = n->data;
		char *cn = column_name(c);
		char *ncn = sql_escape_ident(cn);

		q = newStmt2(mb, batRef, insertRef);
		q = pushArgument(mb, q, result_set);
		q = pushStr(mb, q, ncn);
		q = pushArgument(mb, q, c->nr);
		_DELETE(ncn);
		_DELETE(cn);
	}
}

@-
Some utility routines to generate code
The equality operator in MAL is '==' instead of '='.
@c
str
convertMultiplexMod(str mod, str op)
{
	if (strcmp(op, "=") == 0)
		return _strdup("calc");
	return _strdup(mod);
}
str
convertMultiplexFcn(str op)
{
	if (strcmp(op, "=") == 0)
		return _strdup("==");
	return _strdup(op);
}

str
convertOperator(str op)
{
	if (strcmp(op, "=") == 0)
		return "==";
	return op;
}

void
dump_1(backend *sql, MalBlkPtr mb, stmt *s, char *mod, char *name)
{
	InstrPtr q;
	int o1 = _dumpstmt(sql, mb, s->op1.stval);

	@:SQLprelude@
	q = newStmt1(mb, mod, name);
	q = pushArgument(mb, q, o1);
	s->nr = getDestVar(q);
	@:SQLpostlude@
}

void
dump_2(backend *sql, MalBlkPtr mb, stmt *s, char *mod, char *name)
{
	InstrPtr q;
	int o1 = _dumpstmt(sql, mb, s->op1.stval);
	int o2 = _dumpstmt(sql, mb, s->op2.stval);

	@:SQLprelude@
	q = newStmt1(mb, mod, name);
	q = pushArgument(mb, q, o1);
	q = pushArgument(mb, q, o2);
	s->nr = getDestVar(q);
	@:SQLpostlude@
}

InstrPtr
multiplex2(MalBlkPtr mb, char *mod, char *name /* should be eaten */, int o1, int o2, int rtype)
{
	InstrPtr q;

	q = newStmt(mb, "mal","multiplex");
	setVarType(mb,getArg(q,0), newBatType(TYPE_oid,rtype));
	freezeVarType(mb,getArg(q,0));
	q = pushStr(mb, q, convertMultiplexMod(mod,name));
	q = pushStr(mb, q, convertMultiplexFcn(name));
	q = pushArgument(mb, q, o1);
	q = pushArgument(mb, q, o2);
	return q;
}

InstrPtr
multiplexN(MalBlkPtr mb, char *mod, char *name)
{
	InstrPtr q = NULL;

	if (strcmp(name,"rotate_xor_hash") == 0 && strcmp(mod, "calc") == 0)
		q = newStmt(mb, "mkey", "bulk_rotate_xor_hash");
	return q;
}

@-
The intermediate results of this translation are mostly readonly.
Set this property to reduce copying.
@c
void
dump_3(backend *sql, MalBlkPtr mb, stmt *s, char *mod, char *name)
{
	InstrPtr q;
	int o1 = _dumpstmt(sql, mb, s->op1.stval);
	int o2 = _dumpstmt(sql, mb, s->op2.stval);

	@:SQLprelude@
	q = newStmt1(mb, batRef, "setReadMode");
	q = pushArgument(mb, q, o1);

	q = newStmt(mb, mod, name);
	q = pushArgument(mb, q, o1);
	q = pushArgument(mb, q, o2);
	s->nr = getDestVar(q);
	@:SQLpostlude@
}

static char*
reconnect(MalBlkPtr mb, list *l)
{
	InstrPtr q = NULL;
	char *db_alias = NULL;

	node* n = l->h;	
	int i = 0;

	n = n->next;
	
	/*create the mserver reconnect*/
	q = newStmt1(mb,mserverRef,reconnectRef);
	getVar(mb,getArg(q,0))->isudftype= 1;
	setVarType(mb, getArg(q, 0), TYPE_int);
	
	while (n) {
		if (i == 1)
			q = pushInt(mb, q, *(int *) n->data);
		else {
			if (i == 3) {
				db_alias = (char *) n->data;
				q = pushStr(mb, q, (char *) n->data);
			}
			else
				if(i != 2)
					q = pushStr(mb, q, (char *) n->data);
		}
		n = n->next;
		i++;
	}
	
	return db_alias;
}


void
disconnect(MalBlkPtr mb, list *l)
{
	InstrPtr q = NULL;

	node* n = l->h;	

	
	/*create the mserver disconnect*/
	q = newStmt1(mb,mserverRef,disconnectRef);
	getVar(mb,getArg(q,0))->isudftype= 1;
	setVarType(mb, getArg(q, 0), TYPE_int);
	
	if (list_length(l) == 2) {
		q = pushStr(mb, q, (char *) n->next->data);
	}

}

@-
The big code generation switch. The sections are aligned to the
Monet version4 code generation block for ease of comparison.
@c
#define SMALLBUFSIZ 64
static int 
_dumpstmt(backend *sql, MalBlkPtr mb, stmt *s)
{
	InstrPtr q = NULL;
	node *n;

	if (s) {
		if (s->nr > 0)
			return s->nr;	/* stmt already handled */

		switch (s->type) {
		case st_none: {
			q = newAssignment(mb);
			s->nr = getDestVar(q);
			q = pushInt(mb, q, 1);
		}	break;
		case st_connection: {
			if (list_length(s->op1.lval) < 3)
				disconnect(mb, s->op1.lval);
			else 
				reconnect(mb, s->op1.lval);
		}	break;
		case st_sql:{
			int o1 = _dumpstmt(sql, mb, s->op1.stval);

			q = newStmt1(mb, sqlRef, "eval");
			s->nr = getDestVar(q);
			q = pushArgument(mb, q, o1);
		} break;
		case st_var:{
			if (s->op1.sval) {
				if (VAR_GLOBAL(s->flag)) { /* globals */
					int tt = tail_type(s)->type->localtype;
					q = newStmt1(mb, sqlRef, "getVariable");
					q = pushStr(mb, q, s->op1.sval);
					setVarType(mb, getArg(q, 0), tt);
					freezeVarType(mb,getArg(q,0));
				} else if ((s->flag & VAR_DECLARE) == 0) {
					q = newAssignment(mb);
					q = pushArgumentId(mb, q, _strdup(s->op1.sval));
				} else {
					int tt = tail_type(s)->type->localtype;
					q = newInstruction(mb,ASSIGNsymbol);
					q->argc = q->retc = 0;
					q = pushArgumentId(mb, q, _strdup(s->op1.sval));
					q = pushNil(mb, q, tt);
					pushInstruction(mb, q);
					q->retc++;
				}
			} else {
				char *buf;

				buf = alloca(SMALLBUFSIZ);
				(void) snprintf(buf, SMALLBUFSIZ, "A%d", s->flag);
				q = newAssignment(mb);
				q = pushArgumentId(mb, q, _strdup(buf));
			}
			s->nr = getDestVar(q);
		} break;
		case st_temp:{
			int ht = TYPE_oid;
			int tt = s->op4.typeval.type->localtype;

			q = newStmt1(mb, batRef, "new");
			setVarType(mb, getArg(q, 0), newBatType(ht, tt));
			freezeVarType(mb,getArg(q,0));
			q = pushNil(mb, q, ht);
			q = pushNil(mb, q, tt);

			s->nr = getDestVar(q);
		} break;
		case st_column:
			s->nr = _dumpstmt(sql, mb, s->op1.stval);
			break;
		case st_bat: {
			int ht = TYPE_oid;
			int tt = s->op1.cval->type.type->localtype;

			@:SQLprelude@
			q = newStmt1(mb, sqlRef, bindRef);
			setVarType(mb, getArg(q, 0), newBatType(ht, tt));
			freezeVarType(mb,getArg(q,0));
			q = pushStr(mb, q, s->op1.cval->t->s->base.name);
			q = pushStr(mb, q, s->op1.cval->t->base.name);
			q = pushStr(mb, q, s->op1.cval->base.name);
			q = pushInt(mb, q, s->flag);
			s->nr = getDestVar(q);
			@:SQLpostlude@
		}
			break;
		case st_dbat:{
			int ht = TYPE_oid;
			@:SQLprelude@
			q = newStmt1(mb, sqlRef, binddbatRef);
			setVarType(mb, getArg(q,0), newBatType(ht,TYPE_oid));
			freezeVarType(mb,getArg(q,0));
			q = pushStr(mb, q, s->op1.tval->s->base.name);
			q = pushStr(mb, q, s->op1.tval->base.name);
			q = pushInt(mb, q, s->flag);
			s->nr = getDestVar(q);
			@:SQLpostlude@
		}
			break;
		case st_idxbat:{
			int tt;
			int ht = TYPE_oid;

			@:SQLprelude@
			q = newStmt1(mb, sqlRef, "bind_idxbat");
			tt = tail_type(s)->type->localtype;
			setVarType(mb, getArg(q, 0), newBatType(ht, tt));
			freezeVarType(mb,getArg(q,0));
			q = pushStr(mb, q, s->op1.idxval->t->s->base.name);
			q = pushStr(mb, q, s->op1.idxval->t->base.name);
			q = pushStr(mb, q, s->op1.idxval->base.name);
			q = pushInt(mb, q, s->flag);
			s->nr = getDestVar(q);
			@:SQLpostlude@
		}
			break;
		case st_const:{
			dump_2(sql, mb, s, algebraRef, "project");
		}
			break;
		case st_mark:{
			dump_2(sql, mb, s, algebraRef, "markT");
		}
			break;
		case st_gen_group:{
			dump_1(sql, mb, s, algebraRef, "groupby");
		}
			break;
		case st_reverse:{
			dump_1(sql, mb, s, batRef, reverseRef);
		}
			break;
		case st_mirror:{
			dump_1(sql, mb, s, batRef, "mirror");
		}
			break;
		case st_limit:{
			int l = _dumpstmt(sql, mb, s->op1.stval);
			int offset = _dumpstmt(sql, mb, s->op2.stval);
			int len = _dumpstmt(sql, mb, s->op3.stval);

			@:SQLprelude@

			/* first insert single value into a bat */
			if (s->nrcols == 0) { 
				int k;
				int ht = TYPE_oid;
				int tt = tail_type(s->op1.stval)->type->localtype;

				q = newStmt1(mb, batRef, "new");
				setVarType(mb, getArg(q, 0), newBatType(ht,tt));
				freezeVarType(mb,getArg(q,0));
				q = pushNil(mb, q, ht);
				q = pushNil(mb, q, tt);
				k = getDestVar(q);

				q = newStmt2(mb, batRef, appendRef);
				q = pushArgument(mb, q, k);
				q = pushArgument(mb, q, l);
				l = k;
			}
			if (s->flag) {
				int topn = 0;
				char *name = "topn_min";
				if ((s->flag-1) > 0)
					name = "topn_max"; 

				q = newStmt1(mb, calcRef, "+");
				q = pushArgument(mb,q, offset);
				q = pushArgument(mb,q, len);
				topn = getDestVar(q);
				 
				q = newStmt(mb, "pqueue", name);
				q = pushArgument(mb,q, l);
				q = pushArgument(mb, q, topn);
				l = getDestVar(q);

				/* the result of the topn is still sliced,
				 * to remove the offset part */
			}
			q = newStmt1(mb, calcRef, "+");
			q = pushArgument(mb, q, offset);
			q = pushArgument(mb, q, len);
			len = getDestVar(q);

			/* since both arguments of algebra.slice are inclusive
			   correct the LIMIT value by substracting 1 */
			q = newStmt1(mb, calcRef, "-");
			q = pushArgument(mb, q, len);
			q = pushInt(mb, q, 1);
			len = getDestVar(q);

			q = newStmt1(mb, algebraRef, "slice");
			q = pushArgument(mb, q, l);
			q = pushArgument(mb, q, offset);
			q = pushArgument(mb, q, len);
			l = getDestVar(q);
			/* retrieve the single values again */ 
			if (s->nrcols == 0) { 
				q = newStmt1(mb, algebraRef, "find");
				q = pushArgument(mb, q, l);
				pushOid(mb,q,0);
				l = getDestVar(q);
			}
			s->nr = l;
			@:SQLpostlude@
		} break;
		case st_order:{
			int l = _dumpstmt(sql, mb, s->op1.stval);

			@:SQLprelude@
			q = newStmt1(mb, algebraRef, "sortTail" );
			q = pushArgument(mb, q, l);
			s->nr = getDestVar(q);
			if( s->flag == 0){
				q = newStmt1(mb, algebraRef,"sortReverseTail");
				q= pushArgument(mb,q,s->nr);
				s->nr = getDestVar(q);
			}
			@:SQLpostlude@
		} break;
		case st_reorder:{
			int l = _dumpstmt(sql, mb, s->op1.stval);
			int r = _dumpstmt(sql, mb, s->op2.stval);

			@:SQLprelude@
			if (s->flag) {
				q = newStmt(mb, "group", "refine");
			} else {
				q = newStmt(mb, "group", "refine_reverse");
			}
			q = pushArgument(mb, q, l);
			q = pushArgument(mb, q, r);
			s->nr = getDestVar(q);
			@:SQLpostlude@
		}
			break;

		case st_uselect:
		case st_select:{
			int l = _dumpstmt(sql, mb, s->op1.stval);
			int r = _dumpstmt(sql, mb, s->op2.stval);
			int k;

			char *cmd = s->type == st_select ? "select" : "uselect";

			@:SQLprelude@
			if (s->op2.stval->nrcols >= 1) {
				char *mod = calcRef;
				char *op = "=";
				int k;
				int j,hml,tmr,mhj,mtj;

				switch (s->flag) {
				case cmp_equal:
					op = "=";
					break;
				case cmp_notequal:
					op = "!=";
					break;
				case cmp_lt:
					op = "<";
					break;
				case cmp_lte:
					op = "<=";
					break;
				case cmp_gt:
					op = ">";
					break;
				case cmp_gte:
					op = ">=";
					break;
				case cmp_like:
					op = "like";
					mod = strRef;
					break;
				case cmp_notlike:
					op = "notlike";
					mod = strRef;
					break;
				default:
					showException(SQL,"sql","Unknown operator");
				}

				/* multiplex needs equal heads */
				/* hml := head_mirror(l);
				   tmr := tail_mirror(r);
				   j := lhm.join(rtm);
				   mhj := markH(j)
				   mtj := markT(j)
				   tmj.join(l);
				   hmj := reverse(hmj);
				   hmj.join(r);
				*/
				q = newStmt1(mb, batRef, "mirror" );
				q = pushArgument(mb, q, l);
				hml = getDestVar(q);

				q = newStmt1(mb, batRef, "mirror" );
				q = pushArgument(mb, q, r);
				tmr = getDestVar(q);

				q = newStmt2(mb, algebraRef, joinRef);
				q = pushArgument(mb, q, hml);
				q = pushArgument(mb, q, tmr);
				j = getDestVar(q);

				q = newStmt1(mb, algebraRef, "markH");
				q = pushArgument(mb, q, j);
				q = pushOid(mb, q, 0);
				mhj = getDestVar(q);

				q = newStmt1(mb, algebraRef, "markT");
				q = pushArgument(mb, q, j);
				q = pushOid(mb, q, 0);
				mtj = getDestVar(q);

				q = newStmt2(mb, batRef, reverseRef );
				q = pushArgument(mb, q, mtj);
				mtj = getDestVar(q);

				q = newStmt2(mb, algebraRef, joinRef);
				q = pushArgument(mb, q, mtj);
				q = pushArgument(mb, q, l);
				l = getDestVar(q);

				q = newStmt2(mb, algebraRef, joinRef);
				q = pushArgument(mb, q, mhj);
				q = pushArgument(mb, q, r);
				r = getDestVar(q);

				q = multiplex2(mb,mod,convertOperator(op),l,r,TYPE_bit);
				k = getDestVar(q);

				q = newStmt1(mb, algebraRef, "uselect");
				q = pushArgument(mb, q, k);
				q = pushBit(mb, q, TRUE);
				k = getDestVar(q);

				q = newStmt2(mb, batRef, reverseRef );
				q = pushArgument(mb, q, k);
				k = getDestVar(q);

				q = newStmt2(mb, algebraRef, joinRef);
				q = pushArgument(mb, q, k);
				q = pushArgument(mb, q, mhj);
				k = getDestVar(q);

				q = newStmt2(mb, batRef, reverseRef );
				q = pushArgument(mb, q, k);
				s->nr = getDestVar(q);
			} else {
				switch (s->flag) {
				case cmp_like:{
					int e = _dumpstmt(sql, mb, s->op3.stval);
#ifdef HAVE_LIBPCRE
					q = newStmt(mb, "pcre", "like");
#else
					q = newStmt(mb, "batcalc", "like");
#endif
					q = pushArgument(mb, q, l);
					q = pushArgument(mb, q, r);
					q = pushArgument(mb, q, e);
					break;
				}
				case cmp_notlike:{
					int e = _dumpstmt(sql, mb, s->op3.stval);
					int k;

#ifdef HAVE_LIBPCRE
					q = newStmt(mb, "pcre", "like");
#else
					q = newStmt(mb, "batcalc", "like");
#endif
					q = pushArgument(mb, q, l);
					q = pushArgument(mb, q, r);
					q = pushArgument(mb, q, e);
					k = getDestVar(q);

					q = newStmt1(mb, algebraRef, "project");
					q = pushArgument(mb, q, l);
					q = pushNil(mb, q, TYPE_void);
					l = getDestVar(q);
					q = newStmt1(mb, algebraRef, "kdifference");
					q = pushArgument(mb, q, l);
					q = pushArgument(mb, q, k);
					break;
				}
				case cmp_equal:{
					q = newStmt1(mb, algebraRef, cmd);
					q = pushArgument(mb, q, l);
					q = pushArgument(mb, q, r);
					break;
				}
				case cmp_notequal:{
					q = newStmt1(mb, algebraRef, "uselect");
					q = pushArgument(mb, q, l);
					q = pushArgument(mb, q, r);
					k = getDestVar(q);
					q = newStmt1(mb, algebraRef, "project");
					q = pushArgument(mb, q, l);
					q = pushNil(mb, q, TYPE_void);
					l = getDestVar(q);
					q = newStmt1(mb, algebraRef, "kdifference");
					q = pushArgument(mb, q, l);
					q = pushArgument(mb, q, k);
					break;
				}
				case cmp_lt:
					q = newStmt1(mb, algebraRef, cmd);
					q = pushArgument(mb, q, l);
					q = pushNil(mb, q, tail_type(s)->type->localtype);
					q = pushArgument(mb, q, r);
					q = pushBit(mb, q, FALSE);
					q = pushBit(mb, q, FALSE);
					break;
				case cmp_lte:
					q = newStmt1(mb, algebraRef, cmd);
					q = pushArgument(mb, q, l);
					q = pushNil(mb, q, tail_type(s)->type->localtype);
					q = pushArgument(mb, q, r);
					break;
				case cmp_gt:
					q = newStmt1(mb, algebraRef, cmd);
					q = pushArgument(mb, q, l);
					q = pushArgument(mb, q, r);
					q = pushNil(mb, q, tail_type(s)->type->localtype);
					q = pushBit(mb, q, FALSE);
					q = pushBit(mb, q, FALSE);
					break;
				case cmp_gte:
					q = newStmt1(mb, algebraRef, cmd);
					q = pushArgument(mb, q, l);
					q = pushArgument(mb, q, r);
					q = pushNil(mb, q, tail_type(s)->type->localtype);
					break;
				default:
					showException(SQL,"sql","SQL2MAL: error impossible\n");
				}
			}
			s->nr = getDestVar(q);
			@:SQLpostlude@
		}
			break;
		case st_uselect2:
		case st_select2:{
			int l = _dumpstmt(sql, mb, s->op1.stval);
			int r1 = _dumpstmt(sql, mb, s->op2.stval);
			int r2 = _dumpstmt(sql, mb, s->op3.stval);
			char *cmd = st_uselect2 == s->type ? "uselect" : "select";

			@:SQLprelude@

			if (s->op2.stval->type == st_atom &&
			    s->op3.stval->type == st_atom &&
			    atom_null(s->op2.stval->op1.aval) &&
			    atom_null(s->op3.stval->op1.aval) 
			) {
				q = newStmt1(mb, algebraRef, "selectNotNil");
				q = pushArgument(mb, q, l);
				s->nr = getDestVar(q);
				@:SQLpostlude@
				break;
			}

			q = newStmt1(mb, algebraRef, cmd);
			q = pushArgument(mb, q, l);
			q = pushArgument(mb, q, r1);
			q = pushArgument(mb, q, r2);

			switch (s->flag) {
			case 0:
				q = pushBit(mb, q, FALSE);
				q = pushBit(mb, q, FALSE);
				break;
			case 1:
				q = pushBit(mb, q, FALSE);
				q = pushBit(mb, q, TRUE);
				break;
			case 2:
				q = pushBit(mb, q, TRUE);
				q = pushBit(mb, q, FALSE);
				break;
			case 3:
				q = pushBit(mb, q, TRUE);
				q = pushBit(mb, q, TRUE);
				break;
			}
			s->nr = getDestVar(q);
			@:SQLpostlude@
		}
			break;
		case st_semijoin:{
			if (s->op1.stval->h && s->op1.stval->h == s->op2.stval->h)
				dump_2(sql, mb, s, sqlRef, "sql_semijoin");
			else
				dump_2(sql, mb, s, algebraRef, "semijoin");
		}
			break;
		case st_diff:{
			dump_2(sql, mb, s, algebraRef, "kdifference");
		}
			break;
		case st_union:{
			dump_2(sql, mb, s, algebraRef, "kunion");
		}
			break;
		case st_outerjoin:
		case st_join:{
			int l = _dumpstmt(sql, mb, s->op1.stval);
			int r = _dumpstmt(sql, mb, s->op2.stval);
			char *jt = "join";

			@:SQLprelude@
			if (s->type == st_outerjoin) {
				jt = "outerjoin";
			/* handle fetchjoins differently 
			} else if (s->flag == cmp_equal && s->h && !s->t) { 
				q = newStmt(mb, "algebra2", "fetchjoin");

				q = pushArgument(mb, q, l);
				q = pushArgument(mb, q, r);

				s->nr = getDestVar(q);
				break;
			*/
			}

			switch (s->flag) {
			case cmp_equal:
				q = newStmt1(mb, algebraRef, jt);

				q = pushArgument(mb, q, l);
				q = pushArgument(mb, q, r);
				@:SQLpostlude@
				break;
			case cmp_notequal:
				q = newStmt1(mb, algebraRef, "antijoin");

				q = pushArgument(mb, q, l);
				q = pushArgument(mb, q, r);
				@:SQLpostlude@
				break;
			case cmp_lt:
				q = newStmt1(mb, algebraRef, "thetajoin");

				q = pushArgument(mb, q, l);
				q = pushArgument(mb, q, r);
				q = pushInt(mb, q, -1);
				@:SQLpostlude@
				break;
			case cmp_lte:
				q = newStmt1(mb, algebraRef, "thetajoin");

				q = pushArgument(mb, q, l);
				q = pushArgument(mb, q, r);
				q = pushInt(mb, q, -2);
				@:SQLpostlude@
				break;
			case cmp_gt:
				q = newStmt1(mb, algebraRef, "thetajoin");

				q = pushArgument(mb, q, l);
				q = pushArgument(mb, q, r);
				q = pushInt(mb, q, 1);
				@:SQLpostlude@
				break;
			case cmp_gte:
				q = newStmt1(mb, algebraRef, "thetajoin");

				q = pushArgument(mb, q, l);
				q = pushArgument(mb, q, r);
				q = pushInt(mb, q, 2);
				@:SQLpostlude@
				break;
			case cmp_all:	/* aka cross table */
			{
				int z;

				q = newStmt2(mb, batRef, reverseRef);
				q = pushArgument(mb, q, r);
				r = getDestVar(q);

				q = newStmt1(mb, calcRef, "int");
				q = pushInt(mb, q, 0);
				z = getDestVar(q);

				q = newStmt1(mb, algebraRef, "project");
				q = pushArgument(mb, q, r);
				q = pushArgument(mb, q, z);
				r = getDestVar(q);

				q = newStmt2(mb, batRef, reverseRef);
				q = pushArgument(mb, q, r);
				r = getDestVar(q);

				q = newStmt1(mb, algebraRef, "project");
				q = pushArgument(mb, q, l);
				q = pushArgument(mb, q, z);
				l = getDestVar(q);

				q = newStmt2(mb, algebraRef, joinRef);
				q = pushArgument(mb, q, l);
				q = pushArgument(mb, q, r);
				@:SQLpostlude@
				break;
			}
			default:
				showException(SQL,"sql","SQL2MAL: error impossible\n");
			}
			s->nr = getDestVar(q);
			break;
		}
		case st_group:{
			char *nme;
			int ext, grp, o1 = _dumpstmt(sql, mb, s->op1.stval);

			nme = alloca(SMALLBUFSIZ);
			@:SQLprelude@
			q = newStmt(mb, "group", "new");
			ext = getDestVar(q);
			snprintf( nme, SMALLBUFSIZ, "grp%d", getDestVar(q));
        		q = pushReturn(mb, q, newVariable(mb, _strdup(nme), TYPE_any));
			grp = getArg(q, 1);
			q = pushArgument(mb, q, o1);

			q = newAssignment(mb);
			q = pushArgument(mb, q, grp);
			s->nr = getDestVar(q);
			
			snprintf( nme, SMALLBUFSIZ, "ext%d", s->nr);
			renameVariable(mb, ext, _strdup(nme));

			@:SQLpostlude@
		} 	break;
		case st_group_ext:{
			char *ext;
			int e = -1, g = _dumpstmt(sql, mb, s->op1.stval);

			ext = alloca(SMALLBUFSIZ);
			snprintf( ext, SMALLBUFSIZ, "ext%d", g);
			e = findVariable(mb, ext);
			assert(e >= 0);

			@:SQLprelude@
			q = newStmt1(mb, batRef, "mirror");
			q = pushArgument(mb, q, e);
			s->nr = getDestVar(q);
			@:SQLpostlude@
		} break;
		case st_derive:{
			char *nme, *buf;
			int ext, grp;
			int g = _dumpstmt(sql, mb, s->op1.stval);
			int l = _dumpstmt(sql, mb, s->op2.stval);

			nme = alloca(SMALLBUFSIZ);
			buf = alloca(SMALLBUFSIZ);
			@:SQLprelude@
			q = newStmt(mb, "group", "derive");
			ext = getDestVar(q);
			snprintf( nme, SMALLBUFSIZ, "grp%d", getDestVar(q));
        		q = pushReturn(mb, q, newVariable(mb, _strdup(nme), TYPE_any));
			grp = getArg(q, 1);
			(void) snprintf(buf, SMALLBUFSIZ, "ext%d", g);
			q = pushArgumentId(mb, q, _strdup(buf));
			q = pushArgument(mb, q, g);
			q = pushArgument(mb, q, l);

			q = newAssignment(mb);
			q = pushArgument(mb, q, grp);
			s->nr = getDestVar(q);

			snprintf( nme, SMALLBUFSIZ, "ext%d", s->nr);
			renameVariable(mb, ext, _strdup(nme));

			@:SQLpostlude@
		} 	break;
		case st_unique:{
			int l = _dumpstmt(sql, mb, s->op1.stval);

			@:SQLprelude@
			if (s->op2.stval) {
				char *nme, *buf;
				int e, e1, g = _dumpstmt(sql, mb, s->op2.stval);

				nme = alloca(SMALLBUFSIZ);
				buf = alloca(SMALLBUFSIZ);
				q = newStmt(mb, "group", "new");
				e1 = getDestVar(q);
				snprintf( nme, SMALLBUFSIZ, "grp%d", e1);
        			q = pushReturn(mb, q, newVariable(mb, _strdup(nme), TYPE_any));
				q = pushArgument(mb, q, g);

				q = newStmt(mb, "group", "derive");
				e = getDestVar(q);
				snprintf( nme, SMALLBUFSIZ, "grp%d", getDestVar(q));
        			q = pushReturn(mb, q, newVariable(mb, _strdup(nme), TYPE_any));
				q = pushArgument(mb, q, e1);
				(void) snprintf(buf, SMALLBUFSIZ, "grp%d", e1);
				q = pushArgumentId(mb, q, _strdup(buf));
				q = pushArgument(mb, q, l);

				q = newStmt1(mb, batRef, "mirror");
				q = pushArgument(mb, q, e);
				e = getDestVar(q);

				q = newStmt1(mb, algebraRef, "semijoin");
				q = pushArgument(mb, q, l);
				q = pushArgument(mb, q, e);
			} else {
				int k;

				q = newStmt2(mb, batRef, reverseRef);
				q = pushArgument(mb, q, l);
				k = getDestVar(q);
				q = newStmt1(mb, algebraRef, "kunique");
				q = pushArgument(mb, q, k);
				k = getDestVar(q);
				q = newStmt2(mb, batRef, reverseRef);
				q = pushArgument(mb, q, k);
			}
			s->nr = getDestVar(q);
			@:SQLpostlude@
			break;
		}
		case st_convert: {
			char *convert = s->op4.typeval.type->base.name;
			/* convert types and make sure they are rounded up correctly */
			int l = _dumpstmt(sql, mb, s->op1.stval);

			if (s->op4.typeval.type->localtype ==
			    s->op3.typeval.type->localtype &&
			    s->op4.typeval.type->eclass ==
			    s->op3.typeval.type->eclass &&
			    s->op3.typeval.type->eclass != EC_INTERVAL &&
			    s->op3.typeval.type->eclass != EC_DEC 
			   ) {
				s->nr = l;	
				break;
			}

			@:SQLprelude@

			/* external types have sqlname convert functions,
			   these can generate errors (fromstr cannot) */
			if (s->op4.typeval.type->eclass == EC_EXTERNAL)
				convert = s->op4.typeval.type->sqlname;
		
			if (s->op4.typeval.type->eclass == EC_INTERVAL) {
				if (s->op4.typeval.type->localtype == TYPE_int)
					convert = "month_interval";
				else
					convert = "second_interval";
			}

			/* Lookup the sql convert function, there is no need
			 * for single value vs bat, this is handled by the 
			 * mal function resolution */
			if (s->nrcols == 0) { /* simple calc */
				q = newStmt1(mb, calcRef, convert);
			} else if (s->nrcols > 0 && 
				(s->op3.typeval.type->eclass == EC_DEC ||
				 s->op4.typeval.type->eclass == EC_DEC ||
				 s->op4.typeval.type->eclass == EC_INTERVAL ||
				 EC_TEMP(s->op4.typeval.type->eclass) ||
				(s->op4.typeval.type->eclass == EC_STRING && 
			    	!(s->op3.typeval.type->eclass == EC_STRING &&
			    	s->op4.typeval.digits == 0) ) ) ){
				int type = s->op4.typeval.type->localtype;

				q = newStmt(mb, "mal","multiplex");
				setVarType(mb,getArg(q,0), newBatType(TYPE_oid,type));
				freezeVarType(mb,getArg(q,0));
				q = pushStr(mb, q, convertMultiplexMod("calc",convert));
				q = pushStr(mb, q, convertMultiplexFcn(convert));
			} else
				q = newStmt1(mb, batcalcRef, convert);

			/* convert to string is complex, we need full type info
			   and mvc for the timezone */
			if (s->op4.typeval.type->eclass == EC_STRING && 
			    !(s->op3.typeval.type->eclass == EC_STRING &&
			    s->op4.typeval.digits == 0) ) {
				q = pushInt(mb, q, s->op3.typeval.type->eclass);
				q = pushInt(mb, q, s->op3.typeval.digits);
				q = pushInt(mb, q, s->op3.typeval.scale);
				q = pushInt(mb, q, type_has_tz(&s->op3.typeval));
			} else if (s->op3.typeval.type->eclass == EC_DEC) 
				/* scale of the current decimal */
				q = pushInt(mb, q, s->op3.typeval.scale);
			q = pushArgument(mb, q, l);
	
			if (s->op4.typeval.type->eclass == EC_DEC ||
			    s->op4.typeval.type->eclass == EC_INTERVAL) {
				/* digits, scale of the result decimal */
				q = pushInt(mb, q, s->op4.typeval.digits);
				q = pushInt(mb, q, s->op4.typeval.scale);
			}
			/* convert to string, give error on to large strings */
			if (s->op4.typeval.type->eclass == EC_STRING && 
			    !(s->op3.typeval.type->eclass == EC_STRING &&
			    s->op4.typeval.digits == 0) )
				q = pushInt(mb, q, s->op4.typeval.digits);
			s->nr = getDestVar(q);
			@:SQLpostlude@
			break;
		}
		case st_op:{
			char *mod = sql_func_mod(s->op4.funcval->func);
			char *fimp = sql_func_imp(s->op4.funcval->func);
			@:SQLprelude@
			backend_create_func(sql, s->op4.funcval->func); 
			q = newStmt(mb, mod, fimp);
			s->nr = getDestVar(q);
			@:SQLpostlude@
			break;
		}
		case st_unop:{
			char *mod = sql_func_mod(s->op4.funcval->func);
			char *fimp = sql_func_imp(s->op4.funcval->func);
			int l = _dumpstmt(sql, mb, s->op1.stval);

			@:SQLprelude@
			backend_create_func(sql, s->op4.funcval->func); 
			if (s->op1.stval->nrcols) {
				int rtype = s->op4.funcval->res.type->localtype;

				q = newStmt(mb, "mal","multiplex");
				setVarType(mb,getArg(q,0), newBatType(TYPE_oid,rtype));
				freezeVarType(mb,getArg(q,0));
				q = pushStr(mb, q, convertMultiplexMod(mod,fimp));
				q = pushStr(mb, q, convertMultiplexFcn(fimp));
				q = pushArgument(mb, q, l);
			} else {
				q = newStmt(mb, mod, fimp);
				q = pushArgument(mb, q, l);
			}
			s->nr = getDestVar(q);
			@:SQLpostlude@
		}
			break;
		case st_binop:{
			/* TODO use the rewriter to fix the 'round' function */
			sql_subtype *tpe = tail_type(s->op1.stval);
			int special = 0;
			char *mod = sql_func_mod(s->op4.funcval->func);
			char *fimp = sql_func_imp(s->op4.funcval->func);
			int l = _dumpstmt(sql, mb, s->op1.stval);
			int r = _dumpstmt(sql, mb, s->op2.stval);

			if (strcmp(fimp, "round")==0 &&
			    tpe->type->eclass == EC_DEC) 
				special = 1;

			@:SQLprelude@
			backend_create_func(sql, s->op4.funcval->func); 
			if (s->op1.stval->nrcols || s->op2.stval->nrcols) {
				if (!special) {
					q = multiplex2(mb,mod,convertOperator(fimp),l,r, s->op4.funcval->res.type->localtype);
				} else {
					mod= convertMultiplexMod(mod,fimp);
					fimp= convertMultiplexFcn(fimp);
					q = newStmt(mb, "mal","multiplex");
					setVarType(mb,getArg(q,0), 
						newBatType(TYPE_oid,tail_type(s->op1.stval)->type->localtype));
					freezeVarType(mb,getArg(q,0));
					q = pushStr(mb, q, mod);
					q = pushStr(mb, q, fimp);
					q = pushArgument(mb, q, l);
					q = pushInt(mb, q, tpe->digits);
					q = pushInt(mb, q, tpe->scale);
					q = pushArgument(mb, q, r);
				}
				s->nr = getDestVar(q);
			} else {
				q = newStmt(mb, mod, convertOperator(fimp));
				q = pushArgument(mb, q, l);
				if (special) {
					q = pushInt(mb, q, tpe->digits);
					q = pushInt(mb, q, tpe->scale);
				}
				q = pushArgument(mb, q, r);
			}
			s->nr = getDestVar(q);
			@:SQLpostlude@
		}
			break;
		case st_Nop:{
			char *mod = sql_func_mod(s->op4.funcval->func);
			char *fimp = sql_func_imp(s->op4.funcval->func);
			node *n;
			/* dump operands */
			_dumpstmt(sql, mb, s->op1.stval);	

			@:SQLprelude@
			backend_create_func(sql, s->op4.funcval->func); 
			if (s->nrcols) {
				fimp = convertMultiplexFcn(fimp);
				q = multiplexN(mb,mod,fimp);
				if (!q) {
					q = newStmt(mb, "mal","multiplex");
					setVarType(mb,getArg(q,0), 
						newBatType(TYPE_oid,tail_type(s->op1.stval)->type->localtype));
					freezeVarType(mb,getArg(q,0));
					q = pushStr(mb, q, mod);
					q = pushStr(mb, q, fimp);
				} else {
					setVarType(mb,getArg(q,0), 
						newBatType(TYPE_any,tail_type(s->op1.stval)->type->localtype));
					freezeVarType(mb,getArg(q,0));
					_DELETE(fimp);
				}
			} else {
				q = newStmt(mb, mod, fimp);
			}
			for (n = s->op1.stval->op1.lval->h; n; n = n->next) {
				stmt *op = n->data;

				q = pushArgument(mb, q, op->nr);
			}
			s->nr = getDestVar(q);
			@:SQLpostlude@
		} break;
		case st_aggr:{
			int l = _dumpstmt(sql, mb, s->op1.stval);
			char *mod = _strdup(s->op4.aggrval->aggr->mod);
			char *aggrfunc = s->op4.aggrval->aggr->imp;
			int restype = s->op4.aggrval->res.type->localtype;
			int output_type_needed = 0;
			
			if (strcmp(aggrfunc, "sum") == 0) 
				output_type_needed = 1;

			@:SQLprelude@
			if (s->flag) { 
				int l2 = _dumpstmt(sql, mb, s->op2.stval);

				q = newStmt(mb, mod, aggrfunc);
				q = pushArgument(mb, q, l);
				q = pushArgument(mb, q, l2);

			} else if (s->op3.gval) {
				int g = _dumpstmt(sql, mb, s->op2.stval);
				int e = _dumpstmt(sql, mb, s->op3.stval);

				q = newStmt(mb, mod, aggrfunc);
				setVarType(mb, getArg(q, 0), newBatType(TYPE_any,restype));
				freezeVarType(mb,getArg(q,0));
				q = pushArgument(mb, q, l);
				q = pushArgument(mb, q, g);
				q = pushArgument(mb, q, e);
			} else {
				q = newStmt(mb, mod, aggrfunc);
				if (output_type_needed){
					setVarType(mb, getArg(q, 0), restype);
					freezeVarType(mb,getArg(q,0));
				}
				q = pushArgument(mb, q, l);
			}
			s->nr = getDestVar(q);
			@:SQLpostlude@
		}
			break;
		case st_atom:{
			atom *a = s->op1.aval;
			if (atom_null(a)) {
				q = newStmt1(mb, calcRef, atom_type(a)->type->base.name);
				q = pushNil(mb, q, atom_type(a)->type->localtype);
			} else {
				int k;
				q = newStmt1(mb, calcRef, atom_type(a)->type->base.name);
				k = constantAtom(sql, mb, a);
				q = pushArgument(mb, q, k);
			}
			s->nr = getDestVar(q);
		}
			break;
		case st_insert:{
			int l = _dumpstmt(sql, mb, s->op1.stval);
			int r = _dumpstmt(sql, mb, s->op2.stval);

			@:SQLprelude@
			if (s->op2.stval->nrcols) {
				q = newStmt2(mb, batRef, insertRef);
				q = pushArgument(mb, q, l);
				q = pushArgument(mb, q, r);
				q = pushBit(mb, q, TRUE);
				s->nr = l;
			} else {
				q = newStmt2(mb, batRef, insertRef);
				q = pushArgument(mb, q, l);
				q = pushArgument(mb, q, r);
				q = pushBit(mb, q, TRUE);
				s->nr = l;
			}
			@:SQLpostlude@
		}
			break;
		case st_append:{
			int l = 0;
			int r = _dumpstmt(sql, mb, s->op2.stval);

			/* special cases try to simply replace the insert bat */
			if (s->op1.stval->type == st_bat && 
			    s->op2.stval->nrcols) {
				stmt *c = s->op1.stval; 

				q = newStmt1(mb, sqlRef, appendRef);
				q = pushStr(mb, q, c->op1.cval->t->s->base.name);
				q = pushStr(mb, q, c->op1.cval->t->base.name);
				q = pushStr(mb, q, c->op1.cval->base.name);
				q = pushInt(mb, q, c->flag);
				q = pushArgument(mb, q, r);
				l = getDestVar(q);
			} else if (s->op1.stval->type == st_idxbat && 
			    	   s->op2.stval->nrcols) {
				stmt *c = s->op1.stval; 

				q = newStmt1(mb, sqlRef, putName("append_idxbat",13));
				q = pushStr(mb, q, c->op1.idxval->t->s->base.name);
				q = pushStr(mb, q, c->op1.idxval->t->base.name);
				q = pushStr(mb, q, c->op1.idxval->base.name);
				q = pushInt(mb, q, c->flag);
				q = pushArgument(mb, q, r);
				l = getDestVar(q);
			} else {
				l = _dumpstmt(sql, mb, s->op1.stval);
				if (s->op1.stval->type != st_bat &&
			    	    s->op1.stval->type != st_idxbat) {
					q = newStmt1(mb, batRef, "setWriteMode");
					q = pushArgument(mb, q, l);
					l = getDestVar(q);
				}

				q = newStmt2(mb, batRef, appendRef);
				q = pushArgument(mb, q, l);
				q = pushArgument(mb, q, r);
				q = pushBit(mb, q, TRUE);
			}
			s->nr = l;
			@:SQLpostlude@
		} break;
		case st_replace:{
			int l = _dumpstmt(sql, mb, s->op1.stval);
			int r = _dumpstmt(sql, mb, s->op2.stval);
			char *f = (s->op1.stval->type == st_bat ||
				   s->op1.stval->type == st_idxbat)?
				putName("inplace",7):putName("replace",7);

			@:SQLprelude@
			q = newStmt1(mb, batRef, f);
			q = pushArgument(mb, q, l);
			q = pushArgument(mb, q, r);
			q = pushBit(mb, q, TRUE);
			s->nr = l;
			@:SQLpostlude@
		} break;
		case st_table_clear:{
			sql_table *t = s->op1.tval;

			@:SQLprelude@
			q = newStmt1(mb, sqlRef, "clear_table");
			q = pushStr(mb, q, t->s->base.name);
			q = pushStr(mb, q, t->base.name);
			s->nr = getDestVar(q);
			@:SQLpostlude@
		} break;
		case st_exception:{
			int l,r;

			l = _dumpstmt(sql, mb, s->op1.stval);
			r = _dumpstmt(sql, mb, s->op2.stval);

			@:SQLprelude@
			/* if(bit(l)) { error(r);}  ==raising an exception */
			q = newStmt1(mb, sqlRef, "assert");
			q = pushArgument(mb, q, l);
			q = pushArgument(mb, q, r);
			s->nr = getDestVar(q);
			@:SQLpostlude@
			break;
		}
		case st_intersect:{
			int l = _dumpstmt(sql, mb, s->op1.stval);
			int r = _dumpstmt(sql, mb, s->op2.stval);

			@:SQLprelude@
			q = newStmt1(mb, algebraRef, "sintersect");
			q = pushArgument(mb, q, l);
			q = pushArgument(mb, q, r);
			s->nr = getDestVar(q);
			@:SQLpostlude@
		} break;
		case st_alias:
			s->nr = _dumpstmt(sql, mb, s->op1.stval);
			break;
		case st_set:
		case st_list:{
			for (n = s->op1.lval->h; n; n = n->next) {
				_dumpstmt(sql, mb, n->data);
			}
		}
			break;
		case st_sets:{
			for (n = s->op1.lval->h; n; n = n->next) {
				list *l = n->data;
				node *ml = l->h;

				while (ml) {
					_dumpstmt(sql, mb, ml->data);
					ml = ml->next;
				}
			}
		}
			break;
		case st_rs_column:{
			/* this command is called to fetch a BAT from an import */
			int o1 = _dumpstmt(sql, mb, s->op1.stval);
			int o2 = _dumpstmt(sql, mb, s->op2.stval);

			@:SQLprelude@
			q = newStmt1(mb, sqlRef, "columnBind");
			/* adjust destination type */
			setVarType(mb,getArg(q,0), newBatType( TYPE_oid,s->op4.typeval.type->localtype));
			freezeVarType(mb,getArg(q,0));
			q = pushArgument(mb, q, o1);
			q = pushArgument(mb, q, o2);
			s->nr = getDestVar(q);
			@:SQLpostlude@
		} break;
		case st_bulkinsert:{
			char *tname = s->op1.stval->op1.tval->base.name;
			int sep = _dumpstmt(sql, mb, s->op2.stval);
			int rsep = _dumpstmt(sql, mb, s->op3.stval);

			if (s->op4.stval) {
				int file = _dumpstmt(sql, mb, s->op4.stval);
				int codeset;
				int bs;

				q = newStmt(mb, "str", "codeset");
				codeset = getDestVar(q);

				q = newStmt(mb, "str", "iconv");
				q = pushArgument(mb, q, file);
				q = pushStr(mb, q, "UTF-8");
				q = pushArgument(mb, q, codeset);
				file = getDestVar(q);

				q = newStmt(mb, "streams", "openRead");
				q = pushArgument(mb, q, file);
				file = getDestVar(q);

				q = newStmt(mb, "bstream", "create");
				q = pushArgument(mb, q, file);
				q = pushInt(mb, q, 1024*1024);
				bs = getDestVar(q);

				q = newStmt1(mb, sqlRef, "importTable");
				q = pushArgument(mb, q, bs);
				q = pushStr(mb, q, tname);
				q = pushArgument(mb, q, sep);
				q = pushArgument(mb, q, rsep);
				q = pushInt(mb, q, s->flag);
				s->nr = getDestVar(q);

				q = newStmt(mb, "bstream", "destroy");
				q = pushArgument(mb, q, bs);

				q = newStmt(mb, "streams", "close");
				q = pushArgument(mb, q, file);
			} else {
				int io_stdin;
				q = newStmt(mb, "io", "stdin");
				io_stdin = getDestVar(q);

				q = newStmt1(mb, sqlRef, "importTable");
				q = pushArgument(mb, q, io_stdin);
				q = pushStr(mb, q, tname);
				q = pushArgument(mb, q, sep);
				q = pushArgument(mb, q, rsep);
				q = pushInt(mb, q, s->flag);
				s->nr = getDestVar(q);
			}
		}
			break;
		case st_filter:
			s->nr = _dumpstmt(sql, mb, s->op1.stval);
			break;
		case st_ordered:{
			int l = _dumpstmt(sql, mb, s->op1.stval);

			_dumpstmt(sql, mb, s->op2.stval);
			s->nr = l;
		} break;
		case st_affected_rows:{
			InstrPtr q;
			int o1 = _dumpstmt(sql, mb, s->op1.stval);

			@:SQLprelude@
			q = newStmt1(mb, sqlRef, "affectedRows");
			q = pushArgument(mb, q, o1);
			q = pushStr(mb, q, ""); /* warning */
			s->nr = getDestVar(q);
			@:SQLpostlude@
		} break;
		case st_output:{
			stmt *order = NULL;
			stmt *lst = s->op1.stval;

			_dumpstmt(sql, mb, lst);

			if (lst->type == st_ordered) {
				order = lst->op1.stval;
				lst = lst->op2.stval;
			}
			if (lst->type == st_list) {
				list *l = lst->op1.lval;
				int cnt = list_length(l);
				stmt *f;
				InstrPtr k;

				n = l->h;
				f = n->data;

				/* single value result, has a fast exit */
				if (cnt == 1 && !order && f->nrcols <= 0){
					stmt *c = n->data;
					sql_subtype *t = tail_type(c);
					char *tname = table_name(c);
					char *sname = schema_name(c);
					char *_empty = "";
					char *tn = (tname) ? tname : _empty;
					char *sn = (sname) ? sname : _empty;
					char *cn = column_name(c);
					char *ntn = sql_escape_ident(tn);
					char *nsn = sql_escape_ident(sn);
					char *fqtn = alloca(sizeof(char) * (strlen(nsn) + 1 + strlen(ntn) + 1));

					fqtn[0]=0;
					strcat(fqtn, nsn);
					strcat(fqtn, ".");
					strcat(fqtn, ntn);
					q = newStmt2(mb, sqlRef, exportValueRef);
					s->nr = getDestVar(q);
					q = pushInt(mb, q, sql->mvc->type);
					q = pushStr(mb, q, fqtn);
					q = pushStr(mb, q, cn);
					q = pushStr(mb, q, t->type->sqlname);
					q = pushInt(mb, q, t->digits);
					q = pushInt(mb, q, t->scale);
					q = pushInt(mb, q, t->type->eclass);
					q = pushArgument(mb, q, c->nr);
					q = pushStr(mb, q, ""); /* warning */
					if (tn != _empty)
						_DELETE(tn);
					if (sn != _empty)
						_DELETE(sn);
					_DELETE(cn);
					_DELETE(ntn);
					_DELETE(nsn);
					break;
				}
				if (n) {
					if (!order) {
						order = n->data;
					}
				}
				k = newStmt2(mb, sqlRef, resultSetRef);
				s->nr = getDestVar(k);
				k = pushInt(mb, k, cnt);
				k = pushInt(mb, k, sql->mvc->type);
				k = pushArgument(mb, k, order->nr);
				dump_header(mb, s, l);
				
				q = newStmt2(mb, sqlRef, exportResultRef);
				q = pushArgument(mb, q, s->nr);
				q = pushStr(mb, q, ""); /* warning */
			} else {
				q = newStmt1(mb, sqlRef, "print");
				q = pushStr(mb, q, "not a valid output list\n");
			}
		}
			break;

		case st_table:{
			stmt *lst = s->op1.stval;

			_dumpstmt(sql, mb, lst);

			if (lst->type == st_list) {
				list *l = lst->op1.lval;

				q = newStmt1(mb, batRef, "new");
				s->nr = getDestVar(q);
				q = pushNil(mb, q, TYPE_str);
				q = pushNil(mb, q, TYPE_bat);
				dump_cols(mb, l, s->nr);
			} else {
				q = newStmt1(mb, sqlRef, "print");
				q = pushStr(mb, q, "not a valid output list\n");
			}
		}
			break;


		/* flow control statements */
		case st_while: {
			int c,bvar;

			/* loop barrier */
			q = newAssignment(mb);
			q->barrier= BARRIERsymbol;
			bvar = getArg(q,0);
			q = pushBit(mb, q, TRUE);

			/* leave barrier */
			c = _dumpstmt(sql,mb, s->op1.stval);
			q = newStmt1(mb, calcRef, "not");
			q = pushArgument(mb, q, c);
			c = getArg(q,0);

			q = newAssignment(mb);
			getArg(q,0) = bvar;
			q->barrier= LEAVEsymbol;
			pushArgument(mb,q,c);
			
			_dumpstmt(sql,mb,s->op2.stval);

			/* redo barrier, start again at the loop barrier */
			q = newAssignment(mb);
			q->barrier= REDOsymbol;
			getArg(q,0) = bvar;
			q->argc = q->retc = 1;
			q = pushBit(mb, q, TRUE);

			/* exit barrier */
			q = newAssignment(mb);
			getArg(q,0) = bvar;
			q->argc = q->retc = 1;
			q->barrier= EXITsymbol;
		} 	break;
		case st_if: {
			int c,t,e;
			c= _dumpstmt(sql,mb, s->op1.stval);
			q= newAssignment(mb);
			t= getArg(q,0);
			pushArgument(mb,q,c);
			q->barrier= BARRIERsymbol;
			_dumpstmt(sql,mb,s->op2.stval);
			q= newAssignment(mb);
			getArg(q,0)= t;
			q->argc= q->retc=1;
			q->barrier= EXITsymbol;

			q= newStmt1(mb, calcRef, "not");
			q->barrier= BARRIERsymbol;
			e= getArg(q,0);
			pushArgument(mb,q,c);
			if(s->op3.stval)
				_dumpstmt(sql,mb,s->op3.stval);
			q= newAssignment(mb);
			getArg(q,0)= e;
			q->argc= q->retc=1;
			q->barrier= EXITsymbol;
		}	break;
		case st_return: {
			int c = _dumpstmt(sql,mb, s->op1.stval);
			int tt = tail_type(s->op1.stval)->type->localtype;
			q = newInstruction(mb,RETURNsymbol);
			if (tt == TYPE_bat) {
				tt = newBatType(TYPE_str,TYPE_bat);
				getArg(q,0)= newTmpVariable(mb, tt);
			} else {
				getArg(q,0)= newTmpVariable(mb, tt);
			}
			pushArgument(mb,q,c);
			pushInstruction(mb, q);
		}	break;
		case st_assign: {
			int r = _dumpstmt(sql,mb, s->op2.stval);
			if (!VAR_GLOBAL(s->flag)) { /* globals */
				char *vn = atom2string(s->op1.stval->op1.aval);
				q = newInstruction(mb,ASSIGNsymbol);
				q->argc = q->retc = 0;
				q = pushArgumentId(mb, q, vn);
				pushInstruction(mb, q);
				q->retc++;
			} else {
				int vn = _dumpstmt(sql, mb, s->op1.stval);
				q = newStmt1(mb, sqlRef, "setVariable");
				q = pushArgument(mb, q, vn);
			}
			q = pushArgument(mb, q, r);
		} 	break;

			/* todo */
		case st_basetable:
		case st_ptable:
		case st_pivot:
		case st_relselect:
		case st_reljoin:
			stream_printf(GDKout, "not implemented stmt\n");
			assert(0);


		}
	}
	return s->nr;
}

int backend_dumpstmt(backend *be, MalBlkPtr mb, stmt *s)
{
	int nr = _dumpstmt(be, mb, s);
	mvc *c = be->mvc;

	if (c->cache && (c->type == Q_SCHEMA || c->type == Q_TRANS)) {
		InstrPtr q = newStmt2(mb, sqlRef, exportOperationRef);
		q = pushStr(mb, q, ""); /* warning */
		return getDestVar(q);
	}
	return nr;
}

void
backend_callinline(backend *be, Client c, stmt *s )
{
	mvc *m = be->mvc;
	InstrPtr curInstr = 0;
	MalBlkPtr curBlk = c->curprg->def;

	curInstr = getInstrPtr(curBlk, 0);

	if (m->argc) { /* we shouldn't come here as we aren't caching statements */
		int argc=0;
		char arg[SMALLBUFSIZ];

		for (; argc < m->argc; argc++) {
			atom *a = m->args[argc];
			int type = atom_type(a)->type->localtype;
			int varid = 0;

			curInstr = newAssignment(curBlk);
			snprintf(arg, SMALLBUFSIZ, "A%d", argc);
			varid = getDestVar(curInstr);
			renameVariable(curBlk, varid, _strdup(arg));
			setVarType(curBlk, varid, type);
			freezeVarType(curBlk,varid);

			if (atom_null(a)) {
				sql_subtype *t = atom_type(a);
				curInstr = pushNil(curBlk, curInstr, t->type->localtype);
			} else {
				int _t = constantAtom(be, curBlk, a);
				curInstr = pushArgument(curBlk, curInstr, _t);
			}
		}
	}
	backend_dumpstmt(be, curBlk, s);
	pushEndInstruction(curBlk);
	c->curprg->def = curBlk;
}

Symbol
backend_dumpproc(backend *be, Client c, cq *cq, stmt *s)
{
	mvc *m = be->mvc;
	MalBlkPtr curBlk = 0;
	Symbol curPrg = 0, backup = NULL;
	InstrPtr curInstr = 0;
	int argc = 0;
	char arg[SMALLBUFSIZ];
	node *n;
/*
	InstrPtr q;
	str msg, profile;
*/

	backup = c->curprg;

	/* later we change this to a factory ? */
	if (cq) 
		c->curprg = newFunction(putName(cq->name,strlen(cq->name)), FUNCTIONsymbol);
	else 
		c->curprg = newFunction("tmp", FUNCTIONsymbol);

	curPrg = c->curprg;
	curPrg->def->keephistory= backup->def->keephistory;
	curBlk = curPrg->def;
	curInstr = getInstrPtr(curBlk, 0);
	/* we do not return anything */
	setVarType(curBlk, 0, TYPE_void);
	freezeVarType(curBlk,0);
	setModuleId(curInstr, putName("user",4));

	if (be->mvc->argc) {
		for (argc = 0; argc < m->argc; argc++) {
			atom *a = m->args[argc];
			int type = atom_type(a)->type->localtype;
			int varid = 0;

			snprintf(arg, SMALLBUFSIZ, "A%d", argc);
			varid = newVariable(curBlk, _strdup(arg), type);
			curInstr = pushArgument(curBlk, curInstr, varid);
			setVarType(curBlk, varid, type);
			freezeVarType(curBlk,0);
		}
	} else if (be->mvc->params) { /* needed for prepare statements */

		for (n = be->mvc->params->h; n; n = n->next, argc++) {
			sql_arg *a = n->data;
			int type = a->type.type->localtype;
			int varid = 0;

			snprintf(arg, SMALLBUFSIZ, "A%d", argc);
			varid = newVariable(curBlk, _strdup(arg), type);
			curInstr = pushArgument(curBlk, curInstr, varid);
			setVarType(curBlk, varid, type);
			freezeVarType(curBlk,varid);
		}
	}
	/* keep the query for tracing and inspection */
/* not yet used
	profile = sql_get_var(be->mvc,"profile");
	if(profile  && strcmp(profile ,"true")==0){
		q= newStmt(curBlk,sqlRef,putName("startQuery",10));
		pushStr(curBlk,q, msg=sql_escape_str(QUERY(m->scanner)));
		GDKfree(msg);
	}
*/

	backend_dumpstmt(be, curBlk, s);
	pushEndInstruction(curBlk);
	setLifespan(curBlk);

	if (cq){
		be->Toptimize = GDKusec();
		addQueryToCache(c);
		be->Toptimize = GDKusec()- be->Toptimize;
	}
	
/* not yet used
	if(profile  && strcmp(profile ,"true")==0){
		newStmt(curBlk,sqlRef,putName("exitQuery",9));
	}
*/

	curPrg = c->curprg;
	if (backup) 
		c->curprg = backup;
	return curPrg;
}

void
backend_call(backend *be, Client c, cq *cq)
{
	mvc *m = be->mvc;
	InstrPtr q;
	MalBlkPtr mb = c->curprg->def;

	q = newStmt2(mb, putName("user",4), cq->name);
	/* cached (factorized queries return bit??) */
	if (getInstrPtr(((Symbol)cq->code)->def, 0)->token == FACTORYsymbol ) {
		setVarType(mb, getArg(q, 0), TYPE_bit);
		freezeVarType(mb,getArg(q,0));
	} else {
		setVarType(mb, getArg(q, 0), TYPE_void);
		freezeVarType(mb,getArg(q,0));
	}
	if (m->argc) {
		int i;

		for (i=0; i<m->argc; i++){
			atom *a = m->args[i];
			sql_subtype *pt = cq->params+i;

			if (!atom_cast(a, pt)) {
				char buf[BUFSIZ];

				snprintf(buf, BUFSIZ, "wrong argument for function call (expected %s instead of %s)\n", pt->type->sqlname, atom_type(a)->type->sqlname);
				sql_error(m, 003, buf);
				break;
			}
			if (atom_null(a)) {
				sql_subtype *t = cq->params+i;
				/* need type from the prepared argument */
				q = pushNil(mb, q, t->type->localtype);
			} else {
				int _t = constantAtom(be, mb, a);
				q = pushArgument(mb, q, _t);
			}
		}
	}
}

static void
backend_create_func(backend *be, sql_func *f)
{
	mvc *m = be->mvc;
	MalBlkPtr curBlk = 0;
	InstrPtr curInstr = 0;
	Client c = be->client;
	Symbol backup = NULL;
	stmt *s;
	bit t = TRUE;

	/* nothing to do for internal and ready functions */
	if (!f->sql || f->sql > 1)
		return;
	f->sql++;
	s = scope_sqlparse(m, NULL, f->imp, m_execute);
	if (s) {
		stmt *opt;
		opt = optimize(m, s);
		stmt_destroy(s);
		s = rel2bin(m, opt);
		stmt_destroy(opt);
	}
	assert(s);

	backup = c->curprg;
	c->curprg = newFunction(putName(f->base.name,strlen(f->base.name)), FUNCTIONsymbol);

	curBlk = c->curprg->def;
	curInstr = getInstrPtr(curBlk, 0);

	if (curBlk->var[0]->props == 0)
		curBlk->var[0]->props = newPropertySet();
	setProperty(getProps(curBlk,0),"inline", "=", TYPE_bit, &t);

	if (f->res.type) { 
		setVarType(curBlk, 0, f->res.type->localtype);
		freezeVarType(curBlk,0);
	} else {
		setVarType(curBlk, 0, TYPE_void);
		freezeVarType(curBlk,0);
	}
	setModuleId(curInstr, putName("user",4));

	if (f->ops) {
		int argc = 0;
		node *n;

		for (n = f->ops->h; n; n = n->next, argc++) {
			sql_arg *a = n->data;
			int type = a->type.type->localtype;
			int varid = 0;

			varid = newVariable(curBlk, _strdup(a->name), type);
			curInstr = pushArgument(curBlk, curInstr, varid);
			setVarType(curBlk, varid, type);
			freezeVarType(curBlk,varid);
		}
	}
	backend_dumpstmt(be, curBlk, s);
	pushEndInstruction(curBlk);
	setLifespan(curBlk);
	addQueryToCache(c);
	if (backup) 
		c->curprg = backup;
}
