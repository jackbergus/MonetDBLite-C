@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2008 CWI.
@' All Rights Reserved.

@f merovingian
@a Fabian Groffen
@v 1.0
@* The MonetDB keeper
The role of the Merovingian within the MonetDB suite is to act as a
smart proxy, with capabilities to start Mservers when necessary.

Since some people appear to have troubles pronouncing or remembering its
name, one can also refer to the Merovingian, as Mero, Merov or Nebula.
While the latter one has nothing to do with the former, it is provided
as convenience for those who keep on having technical problems with
pronouncing the former.  In any case, people having difficulties here
should watch the Matrix once more.

Most of the Merovingian's decisions are based on information provided by
Sabaoth.  Sabaoth is a file-system based administration shared between
all Mservers in the same farm on a local machine.  It keeps track of how
Mservers can be reached, with which scenarios, and what the crashcounter
of each server is.

The Merovingian will fork off an Mserver whenever a client requests a
database which is not running yet.  The forked Mserver is detached from
the Merovingian, such that the Mserver can live on, even if the
Merovingian is restarted (or dies).  Sabaoth will deal with the
Merovingian finding the Mservers already running, or forked.

Forking off an Mserver isn't done unconditionally.  The crashlog
information maintained by Sabaoth for a given database is consulted
before each fork.  While Sabaoth itself will make sure that the Mserver
logs a warning upon restart after a crash, Merovingian will refuse to
start an Mserver if it has crashed a number of times during a recent
period.  The Merovingian will log such refusals as well as return this
as error to the connecting client.
FIXME: actually implement that

@h
#define MEROV_VERSION   "0.7"
#define MEROV_PORT      50000

@c
#include "sql_config.h"
#include "merovingian.h"
#include "mal_sabaoth.h"
#include <stream_socket.h>
#include <stdlib.h> /* exit, getenv */
#include <stdarg.h>	/* variadic stuff */
#include <stdio.h> /* fprintf */
#include <sys/types.h>
#ifdef HAVE_SYS_SOCKET_H
#include <sys/socket.h>
#endif
#ifdef HAVE_SYS_UN_H
#include <sys/un.h>
#endif
#ifdef HAVE_NETDB_H
#include <netdb.h>
#include <netinet/in.h>
#endif
#ifdef HAVE_FCNTL_H
#include <fcntl.h>
#endif
#include <unistd.h>
#include <string.h> /* strerror */
#ifdef HAVE_ALLOCA_H
#include <alloca.h>
#endif
#include <errno.h>
#include <signal.h> /* handle Ctrl-C, etc. */
#include <pthread.h>

#define SOCKPTR struct sockaddr *
#ifdef HAVE_SOCKLEN_T
#define SOCKLEN socklen_t
#else
#define SOCKLEN int
#endif

/* FreeBSD 6.2 misses these definitions */
#ifndef CLD_EXITED
# define CLD_EXITED 1
#endif
#ifndef CLD_KILLED
# define CLD_KILLED 2
#endif
#ifndef CLD_DUMPED
# define CLD_DUMPED 3
#endif

typedef char* err;

#define freeErr(X) GDKfree(X)
#define getErrMsg(X) X
#define NO_ERR (err)0

static str _merovingian_mserver = NULL;

typedef struct _dpair {
	FILE* fout;       /* where to read stdout messages from */
	FILE* ferr;       /* where to read stderr messages from */
	pid_t pid;        /* this process' id */
	char* dbname;     /* the database that this server serves */
	pthread_t tid;    /* thread id used when terminating this server */
	struct _dpair* next;
}* dpair;
static dpair topdp = NULL;

static int _keepLogging = 1;
static int _timeInterval = 0;
static void
logListener(void *p)
{
	dpair d = topdp;
	dpair w;
	FILE *fout, *ferr;
	char buf[8096];
	int hadData;
	char mytime[20];
	time_t now, lastout, lasterr;
	struct tm *tmp;
	int equalouterr;

	(void)p;

	/* the first entry in the list of d is where our output should go to */
	fout = d->fout;
	ferr = d->ferr;

	if (d->dbname == NULL || fout == ferr) {
		equalouterr = 1;
	} else {
		equalouterr = 0;
	}

	/* skip the first entry, we don't care about it in the normal loop */
	d = d->next;

#define PRINT_TIME(STREAM, CHAN) \
	now = time(NULL); \
	if (now - CHAN >= _timeInterval) { \
		tmp = localtime(&now); \
		strftime(mytime, sizeof(mytime), "%Y-%m-%d %H:%M:%S", tmp); \
		fprintf(STREAM, "TME %s\n", mytime); \
		CHAN = now; \
	}

	lastout = 0;
	lasterr = 0;
	do {
		w = d;
		hadData = 0;
		while (w != NULL) {
			if (fgets(buf, 8096, w->fout) != NULL) {
				PRINT_TIME(fout, lastout);
				fprintf(fout, "MSG %s[" LLFMT "]: %s",
						w->dbname, (long long int)w->pid, buf);
				hadData = 1;
			}
			if (fgets(buf, 8096, w->ferr) != NULL) {
				if (equalouterr == 1) {
					PRINT_TIME(ferr, lastout);
				} else {
					PRINT_TIME(ferr, lasterr);
				}
				fprintf(ferr, "ERR %s[" LLFMT "]: %s",
						w->dbname, (long long int)w->pid, buf);
				hadData = 1;
			}
			w = w->next;
		}
		fflush(fout);
		if (equalouterr == 0)
			fflush(ferr);
		/* see if we need to break the loop */
		if (_keepLogging == 0) {
			if (hadData == 0) {
				break;
			} else {
				continue;	/* don't wait if someone's waiting for us */
			}
		}
		/* wait a tenth of a second */
		MT_sleep_ms(10);
	} while (1);
	/* make sure we emit the current timestamp before we quit */
	lastout = 0;
	PRINT_TIME(fout, lastout);
	if (equalouterr == 0) {
		lasterr =  0;
		PRINT_TIME(ferr, lasterr);
	}
}

int timeout = 0;
/**
 * The terminateProcess function tries to let the given mserver process
 * shut down gracefully within a given time-out.  If that fails, it
 * sends the deadly SIGKILL signal to the mserver process and returns.
 */
static void
terminateProcess(void *p)
{
	dpair d = (dpair)p;
	sabdb *stats;
	str er;
	int i;

	er = SABAOTHgetStatus(&stats, d->dbname);
	if (er != MAL_SUCCEED) {
		fprintf(stderr, "cannot terminate process " LLFMT ": %s\n",
				(long long int)d->pid, er);
		GDKfree(er);
		return;
	}

	if (stats == NULL) {
		fprintf(stderr, "strange, process " LLFMT " serves database '%s' "
				"which does not exist\n", (long long int)d->pid, d->dbname);
		return;
	}

	switch (stats->state) {
		case SABdbRunning:
			/* ok, what we expect */
		break;
		case SABdbCrashed:
			fprintf(stderr, "cannot shut down database '%s', mserver "
					"(pid " LLFMT ") has crashed\n",
					d->dbname, (long long int)d->pid);
			SABAOTHfreeStatus(&stats);
			return;
		case SABdbInactive:
			fprintf(stdout, "database '%s' appears to have shut down already\n",
					d->dbname);
			fflush(stdout);
			SABAOTHfreeStatus(&stats);
			return;
		default:
			fprintf(stderr, "unknown state: %d", (int)stats->state);
			SABAOTHfreeStatus(&stats);
			return;
	}

	/* ok, once we get here, we'll be shutting down the server */
	fprintf(stdout, "sending process " LLFMT " (database '%s') the "
			"TERM signal\n", (long long int)d->pid, d->dbname);
	fflush(stdout);
	kill(d->pid, SIGTERM);
	for (i = 0; i < timeout * 2; i++) {
		if (stats != NULL)
			SABAOTHfreeStatus(&stats);
		MT_sleep_ms(500);
		er = SABAOTHgetStatus(&stats, d->dbname);
		if (er != MAL_SUCCEED) {
			fprintf(stderr, "unexpected problem: %s\n", er);
			GDKfree(er);
			/* don't die, just continue, so we KILL in the end */
		} else if (stats == NULL) {
			fprintf(stderr, "hmmmm, database '%s' suddenly doesn't exist "
					"any more\n", d->dbname);
		} else {
			switch (stats->state) {
				case SABdbRunning:
					/* ok, try again */
				break;
				case SABdbCrashed:
					fprintf (stderr, "database '%s' crashed after SIGTERM\n",
							d->dbname);
					SABAOTHfreeStatus(&stats);
					return;
				case SABdbInactive:
					fprintf(stdout, "database '%s' has shut down\n", d->dbname);
					fflush(stdout);
					SABAOTHfreeStatus(&stats);
					return;
				default:
					fprintf(stderr, "unknown state: %d", (int)stats->state);
				break;
			}
		}
	}
	fprintf(stderr, "timeout of %d seconds expired, sending process " LLFMT
			" (database '%s') the KILL signal\n",
			timeout, (long long int)d->pid, d->dbname);
	kill(d->pid, SIGKILL);
	return;
}

/**
 * Logs the given string and formatting parameter stuff by writing it to
 * stdout.
 */
static void
merlog(str fmt, ...)
{
	va_list ap;
	char message[4096];
	int len;

	va_start(ap, fmt);

	len = vsnprintf(message, 4095, fmt, ap);
	message[len] = '\0';

	/* trim trailing newlines */
	while (len > 0 && message[--len] == '\n')
		message[len] = '\0';

	fprintf(stdout, "%s\n", message);
	/* flush the stream, it seems that for some reason this is necessary */
	fflush(stdout);

	va_end(ap);
}

/**
 * Creates a new error, allocated with malloc.  The error should be
 * freed using freeErr().
 */
static str
newErr(str fmt, ...)
{
	va_list ap;
	char message[4096];
	str ret;
	int len;

	va_start(ap, fmt);

	len = vsnprintf(message, 4095, fmt, ap);
	message[len] = '\0';

	va_end(ap);

	ret = GDKstrdup(message);
	return(ret);
}

/**
 * Fork an Mserver and detach.  The forked Mserver is not a child of
 * this process any more after this function.  Hence, no client pid is
 * maintained or returned.  Before forking off, Sabaoth is consulted to
 * see if forking makes sense, or whether it is necessary at all, or
 * forbidden by restart policy, e.g. when in maintenance.
 */
static err
forkMserver(str database, sabdb** stats, int force)
{
	pid_t pid;
	str er;
	sabuplog info;
	struct tm *t;
	char tstr[20];
	int pfdo[2];
	int pfde[2];
	dpair dp = topdp;

	er = SABAOTHgetStatus(stats, database);
	if (er != MAL_SUCCEED) {
		err e = newErr("%s", er);
		GDKfree(er);
		*stats = NULL;
		return(e);
	}

	if (*stats == NULL)
		return(newErr("no such database: %s", database));

	/* Since we ask for a specific database, it should be either there
	 * or not there.  Since we checked the latter case above, it should
	 * just be there, and be the right one.  There also shouldn't be
	 * more than one entries in the list, so we assume we have the right
	 * one here. */

	/* retrieve uplog information to print a short conclusion */
	er = SABAOTHgetUplogInfo(&info, *stats);
	if (er != MAL_SUCCEED) {
		err e = newErr("could not retrieve uplog information: %s", er);
		GDKfree(er);
		SABAOTHfreeStatus(stats);
		*stats = NULL;
		return(e);
	}

	if ((*stats)->locked == 1) {
		merlog("database '%s' is under maintenance", database);
		if (force == 0)
			return(NO_ERR);
	}

	switch ((*stats)->state) {
		case SABdbRunning:
			t = localtime(&info.laststart);
			strftime(tstr, sizeof(tstr), "%Y-%m-%d %H:%M:%S", t);
			merlog("database '%s' already running since %s, "
					"up min/avg/max: " LLFMT "/" LLFMT "/" LLFMT ", "
					"crash average: %d.00 %.2f %.2f (%d-%d=%d)",
					database, tstr,
					(lng)info.minuptime, (lng)info.avguptime, (lng)info.maxuptime,
					info.crashavg1, info.crashavg10, info.crashavg30,
					info.startcntr, info.stopcntr, info.crashcntr);
			return(NO_ERR);
		break;
		case SABdbCrashed:
			t = localtime(&info.lastcrash);
			strftime(tstr, sizeof(tstr), "%Y-%m-%d %H:%M:%S", t);
			merlog("database '%s' has crashed after start on %s, "
					"attempting restart, "
					"up min/avg/max: " LLFMT "/" LLFMT "/" LLFMT ", "
					"crash average: %d.00 %.2f %.2f (%d-%d=%d)",
					database, tstr,
					(lng)info.minuptime, (lng)info.avguptime, (lng)info.maxuptime,
					info.crashavg1, info.crashavg10, info.crashavg30,
					info.startcntr, info.stopcntr, info.crashcntr);
		break;
		case SABdbInactive:
			merlog("starting database '%s', "
					"up min/avg/max: " LLFMT "/" LLFMT "/" LLFMT ", "
					"crash average: %d.00 %.2f %.2f (%d-%d=%d)",
					database,
					(lng)info.minuptime, (lng)info.avguptime, (lng)info.maxuptime,
					info.crashavg1, info.crashavg10, info.crashavg30,
					info.startcntr, info.stopcntr, info.crashcntr);
		break;
		default:
			SABAOTHfreeStatus(stats);
			*stats = NULL;
			return(newErr("unknown state: %d", (int)(*stats)->state));
	}

	if ((*stats)->locked == 1 && force == 1)
		merlog("startup of database under maintenance '%s' forced", database);

	/* create the pipes (filedescriptors) now, such that we and the
	 * child have the same descriptor set */
	if (pipe(pfdo) == -1) {
		SABAOTHfreeStatus(stats);
		*stats = NULL;
		return(newErr("unable to create pipe: %s", strerror(errno)));
	}
	if (pipe(pfde) == -1) {
		SABAOTHfreeStatus(stats);
		*stats = NULL;
		return(newErr("unable to create pipe: %s", strerror(errno)));
	}

	pid = fork();
	if (pid == 0) {
		str dbname = alloca(sizeof(char) * 512);
		str vaultkey = alloca(sizeof(char) * 512);
		str argv[10];	/* for the exec arguments */
		int c = 0;

		/* redirect stdout and stderr to a new pair of fds for
		 * logging help */
		close(pfdo[0]);
		dup2(pfdo[1], 1);
		close(pfdo[1]);

		close(pfde[0]);
		dup2(pfde[1], 2);
		close(pfde[1]);

		/* we don't use stdin, neither should mserver ... */
		close(0);

		/* ok, now exec that mserver we want */
		snprintf(dbname, 511, "--dbname=%s", database);
		snprintf(vaultkey, 511, "monet_vault_key=%s/.vaultkey", (*stats)->path);
		argv[c++] = _merovingian_mserver;
		argv[c++] = dbname;
		argv[c++] = "--dbinit=include sql;"; /* yep, no quotes needed! */
		argv[c++] = "--set"; argv[c++] = "daemon=yes";
		argv[c++] = "--set"; argv[c++] = "mapi_open=true";
		argv[c++] = "--set"; argv[c++] = vaultkey;
		argv[c++] = NULL;

		merlog("executing '%s' for database '%s'",
				_merovingian_mserver, database);
		execv(_merovingian_mserver, argv);
		/* if the exec returns, it is because of a failure */
		fprintf(stderr, "executing failed: %s\n", strerror(errno));
		exit(1);
	} else if (pid > 0) {
		int i;

		/* parent: fine, let's add the pipes for this child */
		while (dp->next != NULL)
			dp = dp->next;
		dp = dp->next = GDKmalloc(sizeof(struct _dpair));
		dp->fout = fdopen(pfdo[0], "r");
		fcntl(pfdo[0], F_SETFL, O_NONBLOCK);
		close(pfdo[1]);
		dp->ferr = fdopen(pfde[0], "r");
		fcntl(pfde[0], F_SETFL, O_NONBLOCK);
		close(pfde[1]);
		dp->next = NULL;
		dp->pid = pid;
		dp->dbname = GDKstrdup(database);

		/* wait for the child to open up a communication channel */
		for (i = 0; i < 20; i++) {	/* wait up to 10 seconds */
			/* stats cannot be NULL, as we don't allow starting not
			 * existing databases */
			SABAOTHfreeStatus(stats);
			er = SABAOTHgetStatus(stats, database);
			if (er != MAL_SUCCEED) {
				/* since the client mserver lives its own life anyway,
				 * it's not really a problem we exit here */
				err e = newErr("%s", er);
				GDKfree(er);
				*stats = NULL;
				return(e);
			}
			if ((*stats)->state == SABdbRunning &&
					(*stats)->conns != NULL &&
					(*stats)->conns->val != NULL)
			{
				break;
			}
			MT_sleep_ms(500);
		}
		if (i > 20) {
			/* we've never found a connection */
			switch ((*stats)->state) {
				case SABdbRunning:
					return(newErr(
								"timeout when waiting for database '%s' to "
								"open up a communication channel", database));
				case SABdbCrashed:
					return(newErr(
								"database '%s' has crashed after starting, "
								"manual intervention needed", database));
				case SABdbInactive:
					return(newErr(
								"database '%s' appears to cleanly shut down "
								"itself after starting", database));
				default:
					return(newErr("unknown state: %d", (int)(*stats)->state));
			}
		}
		if ((*stats)->locked == 1) {
			merlog("database '%s' has been put into maintenance "
					"mode during startup", database);
		}

		return(NO_ERR);
	}
	/* forking failed somehow, cleanup the pipes */
	close(pfdo[0]);
	close(pfdo[1]);
	close(pfde[0]);
	close(pfde[1]);
	return(newErr(strerror(errno)));
}

static err
handleClient(int sock)
{
	stream *fdin, *fout;
	bstream *fin;
	str buf = alloca(sizeof(char) * 8096);
	char *user = NULL, *algo = NULL, *passwd = NULL, *lang = NULL;
	char *database = NULL, *s;
	sabdb *top = NULL;
	sabdb *stat = NULL;
	struct sockaddr_in saddr;
	socklen_t saddrlen = sizeof(struct sockaddr_in);

	fdin = block_stream(socket_rastream(sock, "read"));
	fout = block_stream(socket_wastream(sock, "write"));

	if (!fdin || !fout) {
		return(newErr("inputstream or outputstream problems"));
	}

	/* note that we claim to speak proto 8 here */
	stream_printf(fout, "%s:merovingian:8:%s:%s",
			"void",  /* some bs */
			"plain", /* FIXME: don't do difficult things for now */
#ifdef WORDS_BIGENDIAN
			"BIG"
#else
			"LIT"
#endif
			);
	stream_flush(fout);
	/* get response */
	stream_read_block(fdin, buf, 8095, 1);

	fin = bstream_create(fdin, 128 * 8096);
	fin->eof = 1;

	/* decode BIG/LIT:user:{cypher}passwordchal:lang:database: line */

	user = buf;
	/* byte order */
	s = strchr(user, ':');
	if (s) {
		*s = 0;
		stream_set_byteorder(fin->s, strcmp(user, "BIG") == 0);
		user = s + 1;
	} else {
		err e = newErr("client challenge error: %s", buf);
		stream_printf(fout, "!incomplete challenge '%s'\n", user);
		stream_flush(fout);
		stream_close(fout);
		stream_close(fdin);
		return(e);
	}

	/* passwd */
	s = strchr(user, ':');
	if (s) {
		*s = 0;
		passwd = s + 1;
		/* decode algorithm, i.e. {plain}mypasswordchallenge */
		if (*passwd != '{') {
			err e = newErr("client challenge error: %s", buf);
			stream_printf(fout, "!invalid password entry\n");
			stream_flush(fout);
			stream_close(fout);
			stream_close(fdin);
			return(e);
		}
		algo = passwd + 1;
		s = strchr(algo, '}');
		if (!s) {
			err e = newErr("client challenge error: %s", buf);
			stream_printf(fout, "!invalid password entry\n");
			stream_flush(fout);
			stream_close(fout);
			stream_close(fdin);
			return(e);
		}
		*s = 0;
		passwd = s + 1;
	} else {
		err e = newErr("client challenge error: %s", buf);
		stream_printf(fout, "!incomplete challenge '%s'\n", user);
		stream_flush(fout);
		stream_close(fout);
		stream_close(fdin);
		return(e);
	}

	/* lang */
	s = strchr(passwd, ':');
	if (s) {
		*s = 0;
		lang = s + 1;
	} else {
		err e = newErr("client challenge error: %s", buf);
		stream_printf(fout, "!incomplete challenge, missing language\n");
		stream_flush(fout);
		stream_close(fout);
		stream_close(fdin);
		return(e);
	}

	/* database */
	s = strchr(lang, ':');
	if (s) {
		*s = 0;
		database = s + 1;
		/* we can have stuff following, make it void */
		s = strchr(database, ':');
		if (s)
			*s = 0;
	}

	if (*database == '\0') {
		/* we need to have a database, if we haven't gotten one,
		 * complain */
		stream_printf(fout, "!please specify a database\n");
		stream_flush(fout);
		stream_close(fout);
		stream_close(fdin);
		return(newErr("no database specified"));
	} else {
		err e = forkMserver(database, &top, 0);
		if (e != NO_ERR) {
			if (top == NULL) {
				stream_printf(fout, "!no such database '%s', please create it first\n", database);
			} else {
				stream_printf(fout, "!internal error while starting a new mserver\n");
			}
			stream_flush(fout);
			stream_close(fout);
			stream_close(fdin);
			return(e);
		}
		stat = top;
	}

	/* if we can't redirect, our mission ends here */
	if (stat->conns == NULL || stat->conns->val == NULL) {
		err e = newErr("database '%s' does not allow connections", stat->dbname);
		stream_printf(fout, "!database '%s' does not allow connections\n", stat->dbname);
		stream_flush(fout);
		stream_close(fout);
		stream_close(fdin);
		SABAOTHfreeStatus(&top);
		return(e);
	}

	if (getpeername(sock, (struct sockaddr *)&saddr, &saddrlen) == -1) {
		merlog("couldn't get peername of client: %s", strerror(errno));
		merlog("redirecting client for database '%s' to %s",
				stat->dbname, stat->conns->val);
	} else {
		/* avoid doing this, it requires some includes that probably
		 * give trouble on windowz
		host = inet_ntoa(saddr.sin_addr);
		 */
		char *host = alloca(sizeof(char) * ((3 + 1 + 3 + 1 + 3 + 1 + 3) + 1));
		sprintf(host, "%u.%u.%u.%u",
				(unsigned) ((ntohl(saddr.sin_addr.s_addr) >> 24) & 0xff),
				(unsigned) ((ntohl(saddr.sin_addr.s_addr) >> 16) & 0xff),
				(unsigned) ((ntohl(saddr.sin_addr.s_addr) >> 8) & 0xff),
				(unsigned) (ntohl(saddr.sin_addr.s_addr) & 0xff));
		merlog("redirecting client %s:%d for database '%s' to %s",
				host, (int)ntohs(saddr.sin_port),
				stat->dbname, stat->conns->val);
	}

	/* need to send a redirect */
	stream_printf(fout, "^%s%s\n",
			stat->conns->val, stat->dbname);
	/* flush redirect and return */
	stream_flush(fout);
	stream_close(fout);
	stream_close(fdin);

	SABAOTHfreeStatus(&top);
	return(NO_ERR);
}

static err
openConnection(int *ret, unsigned short port)
{
	struct sockaddr_in server;
	int sock = -1;

	socklen_t length = 0;
	int on = 1;
	int i = 0;
	char host[512];

	sock = socket(AF_INET, SOCK_STREAM, 0);
	if (sock < 0)
		return(newErr("creation of stream socket failed: %s",
					strerror(errno)));

	setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, (char *) &on, sizeof on);

	server.sin_family = AF_INET;
	server.sin_addr.s_addr = htonl(INADDR_ANY);
	for (i = 0; i < 8; i++)
		server.sin_zero[i] = 0;
	length = (socklen_t) sizeof(server);

	server.sin_port = htons((unsigned short) ((port) & 0xFFFF));
	if (bind(sock, (SOCKPTR) &server, length) < 0) {
		return(newErr("binding to stream socket port %d failed: %s",
				port, strerror(errno)));
	}

	if (getsockname(sock, (SOCKPTR) &server, &length) < 0)
		return(newErr("failed getting socket name: %s",
				strerror(errno)));
	/* keep queue of 5 */
	listen(sock, 5);

	gethostname(host, (int) 512);
	merlog("listening for connections on %s:%d", host, port);

	*ret = sock;
	return(NO_ERR);
}

static int _keepListening = 1;
static str
acceptConnections(int sock)
{
	str msg;
	int retval;
	struct timeval tv;
	fd_set fds;
	int msgsock;
	err e;

	do {
		/* handle socket connections */
		FD_ZERO(&fds);
		if (sock >= 0)
			FD_SET(sock, &fds);

		/* Wait up to 0.5 seconds. */
		tv.tv_sec = 0;
		tv.tv_usec = 500;

		retval = select(sock + 1, &fds, NULL, NULL, &tv);
		if (retval == 0) {
			/* nothing interesting has happened */
			continue;
		}
		if (retval < 0) {
			if (_keepListening == 0)
				break;
			if (errno != EINTR) {
				msg = strerror(errno);
				goto error;
			}
			continue;
		}
		if (sock >= 0 && FD_ISSET(sock, &fds)) {
			if ((msgsock = accept(sock, (SOCKPTR) 0, (socklen_t *) 0)) < 0) {
				if (_keepListening == 0)
					break;
				if (errno != EINTR) {
					msg = strerror(errno);
					goto error;
				}
				continue;
			}
		} else
			continue;
		e = handleClient(msgsock);
		if (e != NO_ERR) {
			fprintf(stderr, "client error: %s\n", getErrMsg(e));
			freeErr(e);
		}
	} while (_keepListening);
	shutdown(sock, SHUT_RDWR);
	close(sock);
	return(NO_ERR);

error:
	_keepListening = 0;
	shutdown(sock, SHUT_RDWR);
	close(sock);
	return(newErr("accept connection: %s", msg));
}

static void
controlRunner(void *d)
{
	char buf[256];
	char *p, *q;
	sabdb *stats;
	int fd = *((int *)d);
	int pos = 0;

	/* Try to handle control signals.  We can get race conditions due to
	 * clients coming in at the same time.  We might need to fix this
	 * situation sometime. */
	while (_keepListening == 1) {
		if (pos == 0) {
			if ((pos = read(fd, buf, 255)) == 0) {
				/* ignore EOF, but don't spin-lock */
				MT_sleep_ms(500);
				continue;
			} else if (pos == -1) {
				/* hmmm error ... give up */
				fprintf(stderr, "error reading from control channel: %s\n",
						strerror(errno));
				break;
			} else {
				buf[pos] = '\0';
				pos = 0;
			}
		}
		q = buf + pos;
		p = strchr(q, '\n');
		if (p == NULL) {
			/* skip, must be garbage */
			fprintf(stderr, "skipping garbage on control channel: %s\n", buf);
			pos = 0;
			continue;
		}
		*p++ = '\0';
		if (*p == '\0') {
			pos = 0;
		} else {
			pos = p - buf;
		}

		/* format is simple: database<space>command */
		if ((p = strchr(q, ' ')) == NULL) {
			fprintf(stderr, "malformed control signal: %s\n", q);
		} else {
			*p++ = '\0';
			if (strcmp(p, "start") == 0) {
				merlog("starting database %s due to control signal", q);
				forkMserver(q, &stats, 1);
				if (stats != NULL)
					SABAOTHfreeStatus(&stats);
			} else if (strcmp(p, "stop") == 0 ||
					strcmp(p, "kill") == 0)
			{
				/* we need to find the right dpair, that is we
				 * sort of assume the control signal is right */
				dpair dp = topdp;
				while (dp != NULL) {
					if (strcmp(dp->dbname, q) == 0) {
						if (strcmp(p, "stop") == 0) {
							merlog("stopping database %s due to control "
									"signal", q);
							kill(dp->pid, SIGTERM);
						} else {
							merlog("killing database %s due to control "
									"signal", q);
							kill(dp->pid, SIGKILL);
						}
						break;
					}
					dp = dp->next;
				}
				if (dp == NULL) {
					fprintf(stderr, "received control stop signal for "
							"database not under merovingian control: %s\n",
							q);
				}
			} else {
				fprintf(stderr, "unknown control command: %s", p);
			}
		}
	}
	close(fd);
	merlog("control channel closed");
}

static str
replacePrefix(str s)
{
	str p;
	str buf;

	/* unfortunately we have to replace occurences of ${prefix} with
	 * MONETDB5_PREFIX, which is medieval in this language */
	p = strstr(s, "${prefix}");
	if (p != NULL) {
		buf = GDKmalloc(sizeof(char) * (strlen(s) + strlen(MONETDB5_PREFIX) + 1));
		memcpy(buf, s, p - s);
		memcpy(buf + (p - s), MONETDB5_PREFIX, strlen(MONETDB5_PREFIX));
		memcpy(buf + (p - s) + strlen(MONETDB5_PREFIX), s + (p - s) + 9, strlen(s) - 9 - (p - s) + 1);
		return(buf);
	} else {
		return(GDKstrdup(s));
	}
}

static void
handler(int sig)
{
	merlog("caught signal %d, Merovingian %s stopping ...", sig, MEROV_VERSION);
	_keepListening = 0;
}

static dpair servers;

static void
childhandler(int sig, siginfo_t *si, void *unused)
{
	dpair p, q;

	(void)sig;
	(void)unused;

	if (si->si_code != CLD_EXITED &&
			si->si_code != CLD_KILLED &&
			si->si_code != CLD_DUMPED)
	{
		/* ignore traps, stops and continues, we only want terminations
		 * of the client process */
		return;
	}

	/* get the pid from the former child, and locate it in our list */
	q = servers;
	p = q->next;
	while (p != NULL) {
		if (p->pid == si->si_pid) {
			/* wait a little (we're not in a hurry anyway, are we?) such
			 * that the logger catches the messages (if any). */
			MT_sleep_ms(40);
			/* remove it, disconnect first, then free (because the
			 * logger might access it otherwise after the free) */
			q->next = p->next;
			if (si->si_code == CLD_EXITED) {
				merlog("database '%s' (%d) has exited with exit status %d",
						p->dbname, p->pid, si->si_status);
			} else if (si->si_code == CLD_KILLED) {
				merlog("database '%s' (%d) was killed by signal %d",
						p->dbname, p->pid, si->si_status);
			} else if (si->si_code == CLD_DUMPED) {
				merlog("database '%s' (%d) has crashed (dumped core)",
						p->dbname, p->pid);
			}
			if (p->dbname)
				GDKfree(p->dbname);
			GDKfree(p);
			return;
		}
		q = p;
		p = q->next;
	}
	merlog("received SIGCHLD from unknown child with pid %d", si->si_pid);
}

int
main(int argc, char *argv[])
{
	err e;
	int argp;
	str dbfarm, msglog, errlog, pidfilename;
	str p;
	FILE *cnf = NULL, *pidfile = NULL;
	char buf[1024];
	sabdb* stats = NULL;
	dpair d;
	int pfd[2];
	pthread_t tid;
	struct sigaction sa;
	int ret;
	int sock = 0;
	struct stat sb;
	int oerr = -1;
	unsigned short port = MEROV_PORT;

	/* Paranoia umask, but good, because why would people have to sniff
	 * our private parts? */
	umask(S_IRWXG | S_IRWXO);

	/* hunt for the config file, and read it, allow the caller to
	 * specify where to look using the MNETDB5CONF environment variable */
	p = getenv("MONETDB5CONF");
	if (p == NULL)
		p = MONETDB5_CONFFILE;
	cnf = fopen(p, "r");
	if (cnf == NULL) {
		fprintf(stderr, "cannot open config file %s\n", p);
		fflush(stderr);
		exit(1);
	}

	dbfarm = NULL;
	msglog = NULL;
	errlog = NULL;
	timeout = 0;
	pidfilename = NULL;
	while (fgets(buf, 1024, cnf) != NULL) {
		/* eliminate fgets' newline */
		buf[strlen(buf) - 1] = '\0';
		if (*buf && strncmp(buf, "gdk_dbfarm=", 11) == 0) {
			p = strchr(buf, '=');
			dbfarm = replacePrefix(++p);
		} else if (*buf && strncmp(buf, "mero_msglog=", 12) == 0) {
			p = strchr(buf, '=');
			msglog = replacePrefix(++p);
		} else if (*buf && strncmp(buf, "mero_errlog=", 12) == 0) {
			p = strchr(buf, '=');
			errlog = replacePrefix(++p);
		} else if (*buf && strncmp(buf, "mero_exittimeout=", 17) == 0) {
			p = strchr(buf, '=');
			timeout = atoi(++p);
		} else if (*buf && strncmp(buf, "mero_timeinterval=", 18) == 0) {
			p = strchr(buf, '=');
			_timeInterval = atoi(++p);
		} else if (*buf && strncmp(buf, "mero_pidfile=", 13) == 0) {
			p = strchr(buf, '=');
			pidfilename = replacePrefix(++p);
		} else if (*buf && strncmp(buf, "mero_port=", 10) == 0) {
			p = strchr(buf, '=');
			/* temporarily misuse oerr */
			oerr = atoi(++p);
			if (oerr <= 0 || oerr > 65535) {
				fprintf(stderr, "invalid port number: %s\n", p);
				fflush(stderr);
			}
			port = (unsigned short)oerr;
			oerr = -1;
		}
	}

	fclose(cnf);

	/* where is the mserver5 binary we fork on demand? */
	snprintf(buf, 1023, "%s/bin/mserver5", MONETDB5_PREFIX);
	_merovingian_mserver = alloca(sizeof(char) * (strlen(buf) + 1));
	memcpy(_merovingian_mserver, buf, strlen(buf) + 1);
	/* exit early if this is not going to work well */
	if (stat(_merovingian_mserver, &sb) == -1) {
		fprintf(stderr, "cannot stat mserver5 executable: %s\n",
				strerror(errno));
		fflush(stderr);
		exit(1);
	}

	/* we need a dbfarm */
	if (dbfarm == NULL) {
		fprintf(stderr, "cannot find dbfarm via config file\n");
		fflush(stderr);
		exit(1);
	}

	/* we need a pidfile */
	if (pidfilename == NULL) {
		fprintf(stderr, "cannot find pidfilename via config file\n");
		fflush(stderr);
		exit(1);
	}

	snprintf(buf, 1024, "%s/.merovingian_lock", dbfarm);
	/* Unfortunately we need to do this twice.  After we fork, we lose
	 * the lock on this file, so in the forked child we need to lock
	 * again, making sure the parent unlocked.  There is a potential
	 * race condition here between the unlock and the relock by the
	 * child, but this is assumed to be neglictible.  Over all, it is
	 * important that the parent can return when the lockfile is already
	 * in use, because that means s-s-d (the caller) is able to
	 * identify it as a failed start attempt. */
	if ((ret = MT_lockf(buf, F_TLOCK, 4, 1)) == -1) {
		/* locking failed */
		fprintf(stderr, "another merovingian is already running\n");
		fflush(stderr);
		exit(1);
	} else if (ret == -2) {
		/* directory or something doesn't exist */
		fprintf(stderr, "unable to create .merovingian_lock file in %s: %s\n",
				dbfarm, strerror(errno));
		fflush(stderr);
		exit(1);
	}
	close(ret);

	snprintf(buf, 1024, "%s/.merovingian_control", dbfarm);
	unlink(buf);
	if ((ret = mkfifo(buf, S_IRUSR | S_IWUSR)) != 0) {
		fprintf(stderr, "failed to create a control channel %s: %s\n",
				buf, strerror(errno));
		fflush(stderr);
		exit(1);
	}

	topdp = alloca(sizeof(struct _dpair));
	topdp->pid = 0;
	topdp->dbname = NULL;

	/* where should our msg output go to? */
	if (msglog == NULL) {
		/* stdout, save it */
		argp = dup(1);
		topdp->fout = fdopen(argp, "w");
	} else {
		/* write to the given file */
		topdp->fout = fopen(msglog, "a");
		if (topdp->fout == NULL) {
			fprintf(stderr, "unable to open '%s': %s\n",
					msglog, strerror(errno));
			exit(1);
		}
		topdp->dbname = "file";
	}

	/* where should our err output go to? */
	if (errlog == NULL) {
		/* stderr, save it */
		argp = dup(2);
		topdp->ferr = fdopen(argp, "w");
	} else {
		/* write to the given file */
		if (strcmp(msglog, errlog) == 0) {
			topdp->ferr = topdp->fout;
		} else {
			topdp->ferr = fopen(errlog, "a");
			if (topdp->ferr == NULL) {
				fprintf(stderr, "unable to open '%s': %s\n",
						errlog, strerror(errno));
				exit(1);
			}
		}
		topdp->dbname = "file";
	}
	GDKfree(msglog);
	GDKfree(errlog);

	d = topdp->next = alloca(sizeof(struct _dpair));

	/* make sure we will be able to write the our pid */
	if ((pidfile = fopen(pidfilename, "w")) == NULL) {
		fprintf(stderr, "unable to open '%s' for writing: %s\n",
				pidfilename, strerror(errno));
		exit(1);
	}

	/* redirect stdout */
	if (pipe(pfd) == -1) {
		fprintf(stderr, "unable to create pipe: %s\n",
				strerror(errno));
		return(1);
	}
	d->fout = fdopen(pfd[0], "r");
	fcntl(pfd[0], F_SETFL, O_NONBLOCK);
	dup2(pfd[1], 1);
	close(pfd[1]);

	/* redirect stderr */
	if (pipe(pfd) == -1) {
		fprintf(stderr, "unable to create pipe: %s\n",
				strerror(errno));
		return(1);
	}
	/* before it is too late, save original stderr */
	oerr = dup(2);
	d->ferr = fdopen(pfd[0], "r");
	fcntl(pfd[0], F_SETFL, O_NONBLOCK);
	dup2(pfd[1], 2);
	close(pfd[1]);

	/* fork into the background, right after we know that everything
	 * that was necessary (config, pipes) is working */
	switch (fork()) {
		case -1:
			/* oops, forking went wrong, cheat a bit in order to write to
			 * the console */
			d->ferr = fdopen(oerr, "r");
			fprintf(d->ferr, "unable to fork into background: %s\n",
					strerror(errno));
			return(1);
		case 0:
			/* the child, we want to keep it, try to lock, we can only
			 * do that here, as we don't inherit the lock from our
			 * parent... */
			snprintf(buf, 1024, "%s/.merovingian_lock", dbfarm);
			/* we leak ret, but that doesn't matter as the file needs to
			 * remain available, otherwise we loose the lock */
			if ((ret = MT_lockf(buf, F_TLOCK, 4, 1)) == -1) {
				/* locking failed */
				d->ferr = fdopen(oerr, "r");
				fprintf(d->ferr, "another merovingian is already running\n");
				exit(1);
			} else if (ret == -2) {
				/* directory or something doesn't exist */
				d->ferr = fdopen(oerr, "r");
				fprintf(d->ferr, "unable to create .merovingian_lock file in "
						"%s: %s\n", dbfarm, strerror(errno));
				exit(1);
			}

			close(oerr);
			/* detach from controlling tty */
			close(0);
		break;
		default:
			/* the parent, we want it to die, with no error */
			return(0);
	}

	d->next = NULL;
	d->pid = getpid();
	d->dbname = "merovingian";

	/* write out the pid */
	fprintf(pidfile, "%d\n", (int)d->pid);
	fflush(pidfile);
	fclose(pidfile);

	servers = d;

	if (pthread_create(&tid, NULL, (void *(*)(void *))logListener, (void *)NULL) < 0) {
		fprintf(topdp->ferr, "%s: unable to create logthread, exiting\n", argv[0]);
		return(1);
	}

	sigemptyset(&sa.sa_mask);
	sa.sa_flags = 0;
	sa.sa_handler = handler;
	if (
			sigaction(SIGINT, &sa, NULL) == -1 ||
			sigaction(SIGQUIT, &sa, NULL) == -1 ||
			sigaction(SIGTERM, &sa, NULL) == -1)
	{
		fprintf(topdp->ferr, "%s: unable to create signal handlers\n", argv[0]);
		return(1);
	}

	sa.sa_flags = SA_SIGINFO | SA_NOCLDWAIT;
	sigemptyset(&sa.sa_mask);
	sa.sa_sigaction = childhandler;
	if (sigaction(SIGCHLD, &sa, NULL) == -1) {
		fprintf(topdp->ferr, "%s: unable to create signal handlers\n", argv[0]);
		return(1);
	}

	merlog("Merovingian %s starting ...", MEROV_VERSION);
	merlog("monitoring dbfarm %s", dbfarm);

	SABAOTHinit(dbfarm, NULL);

	/* open up a connection */
	e = openConnection(&sock, port);
	if (e == NO_ERR) {
		pthread_t ctid = 0;
		int comfd = -1;
		for (argp = 1; argp < argc; argp++) {
			e = forkMserver(argv[argp], &stats, 0);
			if (e != NO_ERR) {
				fprintf(stderr, "failed to fork mserver: %s\n", getErrMsg(e));
				freeErr(e);
			}
			if (stats != NULL)
				SABAOTHfreeStatus(&stats);
		}

		/* handle control commands */
		snprintf(buf, 1024, "%s/.merovingian_control", dbfarm);
		comfd = open(buf, O_RDONLY | O_NONBLOCK);
		if (pthread_create(&ctid, NULL, (void *(*)(void *))controlRunner, (void *)&comfd) < 0) {
			fprintf(stderr, "unable to create control command thread\n");
			ctid = 0;
		}
		GDKfree(dbfarm);

		/* handle external connections main loop */
		e = acceptConnections(sock);

		/* shut down the control runner too */
		if (comfd > -1)
			close(comfd);
		if (ctid != 0)
			pthread_join(ctid, NULL);
	}

	unlink(buf);
	ret = 0;

	if (e != NO_ERR) {
		fprintf(stderr, "%s\n", e);
		freeErr(e);
		ret = 1;
	}

	merlog("Merovingian %s stopping ...", MEROV_VERSION);

	/* we don't need merovingian itself */
	d = d->next;

	/* before we kill all our children, make sure we won't shoot
	 * ourself in the foot because of our SIGCHLD handler */
	sigemptyset(&sa.sa_mask);
	sa.sa_flags = 0;
	sa.sa_handler = SIG_DFL;
	/* ignore error, if it fails, the only thing we can do is fail and
	 * don't kill anything, so risk a race condition with hard crash
	 * here */
	sigaction(SIGCHLD, &sa, NULL);
	/* stop started mservers */
	if (timeout > 0) {
		dpair t = d;
		while (t != NULL) {
			if (pthread_create(&(t->tid), NULL,
						(void *(*)(void *))terminateProcess, (void *)t) < 0)
			{
				fprintf(topdp->ferr, "%s: unable to create thread to terminate "
						"database '%s'\n", argv[0], d->dbname);
				t->tid = 0;
				ret = 1;
			}
			t = t->next;
		}
		/* wait for all processes to be terminated */
		t = d;
		while (t != NULL) {
			if (t->tid != 0 && (argp = pthread_join(t->tid, NULL)) != 0) {
				fprintf(topdp->ferr, "failed to wait for termination thread: "
						"%s\n", strerror(argp));
				ret = 1;
			}
			t = t->next;
		}
	}

	_keepLogging = 0;
	if ((argp = pthread_join(tid, NULL)) != 0) {
		fprintf(topdp->ferr, "failed to wait for logging thread: %s\n", strerror(argp));
		ret = 1;
	}

	fclose(topdp->fout);
	if (topdp->fout != topdp->ferr)
		fclose(topdp->ferr);

	/* clean up dbpair structs */
	while (d != NULL) {
		topdp = d->next;
		if (d->dbname != NULL)
			GDKfree(d->dbname);
		GDKfree(d);
		d = topdp;
	}

	return(ret);
}

/* vim:set ts=4 sw=4 noexpandtab: */
