@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2005 CWI.
@' All Rights Reserved.

@f sql_optimizer
@t SQL catalog management
@a N. Nes, M.L. Kersten
@+ SQL scenario
The SQL scenario implementation is a derivative of the MAL session scenario.

It is also the first version that uses state records attached to
the client record. They are initialized as part of the initialization 
phase of the scenario.

The SQL compiler uses only a small subset of the MAL language.
This involves ca 70 different operators, divided into the
catalog management (?) and query processing (?)
@{
[Make complete list of MAL instructions used in the compilation]
alarm.usec
algebra.count
algebra.join
algebra.kunique
algebra.likeselect
algebra.markT
algebra.outerjoin
algebra.semijoin
algebra.sintersect
algebra.slice
algebra.tunique
algebra.uselect
bat.append
batcalc.project
bat.insert
bat.mirror
bat.new
bat.replace
bat.reverse
bat.seqbase
bat.{setReadMode, setWriteMode}
bat.sort
bat.tsort
bbp.project
calc.{<,<=,=,!=,>,>=}
calc.{-.+.*,/,%}
calc.{oid,int,flt,dbl,str,chr,bit}
group.group 
group.refine
group.refine_reverse
io.printf
optimizer.multiplex
sql.assert
sql.bind
sql.bind_dbat
sql.bind_idxbat
sql.bind_ubat
sql_cache.???
sql.clear_table
sql.column
sql.columnBind
sql.eval
sql.output
sql.print
sql.setVariable
str.codeset
stream.close
stream.openRead
str.iconv
??.{sum,min,max,count}
@}
@h
#ifndef _SQL_OPTIMIZER_H_
#define _SQL_OPTIMIZER_H_
#include "sql.h"

/* #define _SQL_OPTIMIZER_DEBUG  */

sql_export void addQueryToCache(Client c);
sql_export str SQLoptimizer(Client c);
sql_export void SQLsetAccessMode(Client c);

#endif /* _SQL_OPTIMIZER_H_ */

@-
The queries are stored in a cache after they have been
type checked and optimized.
The Factory optimizer encapsulates the query with a re-entrance
structure. However, this structure is only effective if
quite some (expensive) instructions can be safed.
The current heuristic is geared at avoiding trivial
factory structures.
@c
#include "mal_macro.h"
#include "mal_optimizer.h"
#include "mal_peephole.h"
#include "mal_debugger.h"
#include "mal_namespace.h"
#include "sql_mvc.h"
#include "sql_optimizer.h"
#include "sql_scenario.h"
#include "sql_gencode.h"
#include "optimizer.h"

#define TOSMALL 12

str 
FXoptimizer(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	InstrPtr *ns, p;
	int v;
	int i, j, k, klim,newssize;/*, argseen=0;*/
	MALfcn setWriteMode = 0;
	Symbol s;
	lng clk = GDKusec();
	str bindRef= putName("bind",4);
	str sqlRef= putName("sql",3);
	str modeRef= putName("setWriteMode",12);

#ifdef _SQL_OPTIMIZER_DEBUG
	stream_printf(GDKout, "First call to FXoptimizer\n");
	printFunction(GDKout, mb, LIST_MAL_ALL);
#endif
	(void)stk;
	if( mb->errors) {
		/* remove the FXoptimizer request */
		if (pci)
			removeInstruction(mb, pci);
		return MAL_SUCCEED;
	}
	if( !factoryHasFreeSpace())
		return MAL_SUCCEED;

@-
The factor code is generated as soon as you have encountered a bind
operation.
@c
	if (mb->stop <= TOSMALL){
		for(i=0; i< mb->stop; i++){
			p= getInstrPtr(mb,0);
			if (functionName(p)== bindRef && 
				moduleName(p)== sqlRef)  break;
		}
		if(i == mb->stop)
			return MAL_SUCCEED;
	}

	s = findMALSymbol(getName("bat",3), modeRef);
	if (s)
		setWriteMode = getSignature(s)->fcn;

@-
The first step is to collect all the sql bind operations and
to extract some compiler relevant properties from the catalogue.
@c
	newssize = mb->ssize * 2;
	ns = (InstrPtr *) GDKmalloc(sizeof(InstrPtr) * newssize);
	k = 1;
	ns[0] = getInstrPtr(mb, 0);	/* its signature */
	ns[0]->token = FACTORYsymbol;
 	setVarType(mb, getArg(ns[0],0), TYPE_bit);
	for (i = 0; i < mb->stop; i++) {
		p = getInstrPtr(mb, i);
		if (functionName(p)== bindRef && 
			moduleName(p)== sqlRef) {
			ns[k++] = p;
		}
@-
Check if the relation is already made write-enabled in the plan.
It uses the knowledge that at this stage the plan is still a linear
sequence of instructions.
@c
		if (setWriteMode && p->fcn == setWriteMode) {
			for (j = 0; j < k; j++)
				if (ns[j]->fcn == setWriteMode && ns[j]->argv[1] == p->argv[1])
					break;
				else if (ns[j]->argv[0] == p->argv[1]) {
					ns[k++] = p;
					break;
				}
		}
@-
Finally, move all instructions out of the loop until you find a
reference an argument. This pre-supposes that the instructions
are invariant to multiple calls. In general this is not the case,
for consider a block that depends on the size of a BAT.
		if( argseen == 0){
			for(j=p->retc; j<p->argc; j++){
				for( k=0; k<sig->retc; k++)
				if( getArg(p,k)== getArg(sig,k)
					argseen=1;
			}
			if( argseen==0)
				ns[k++]= p;
		}
@c
	}
	klim = k;		/* remember the head */
@-
The prelude code has been generated, now we can inject the remaining
instructions, producing a syntactic correct MAL program again.
@c
	v = newTmpVariable(mb, TYPE_bit);
	p = newInstruction(NULL,ASSIGNsymbol);
	p->barrier = BARRIERsymbol;
	p->argv[0] = v;
	pushBit(mb,p,TRUE);
	ns[k++] = p;

	for (i = 1; i < mb->stop - 1; i++) {
		int doit = 0;

		p = getInstrPtr(mb, i);
		if (!( functionName(p)== bindRef && 
			  moduleName(p)== sqlRef))
			doit = 1;
@-
Skip it if the writeMode relates to a base table
@c
		if (setWriteMode)
			for (j = 0; j < klim; j++)
				if (ns[j] == p)
					doit = 0;
		if (doit)
			ns[k++] = p;
	}
@-
Finalize the factory loop
@c
	p = newInstruction(NULL,ASSIGNsymbol);
	p->barrier = YIELDsymbol;
	p->argv[0] = v;
	ns[k++] = p;
	p = newInstruction(NULL,ASSIGNsymbol);
	p->barrier = REDOsymbol;
	p->argv[0] = v;
	ns[k++] = p;
	p = newInstruction(NULL,ASSIGNsymbol);
	p->barrier = EXITsymbol;
	p->argv[0] = v;
	ns[k++] = p;
	ns[k++] = getInstrPtr(mb, i);

	mb->stop = k;
	mb->ssize = newssize;
	GDKfree(mb->stmt);
	mb->stmt = ns;

	optimizerCheck(mb,"sql.factorize",1,GDKusec()-clk);
@-
At this stage we can once call upon the optimizers to do their work.
Static known information is known and stored in constant variables,
which can be used by the rewrite rules.
This all works under the assumption that the SQL layer properly invalidates
the cache when the underlying table is changed.
@c
#ifdef _SQL_OPTIMIZER_DEBUG
	printFunction(GDKout, mb, LIST_MAL_INSTR);
#endif
	return MAL_SUCCEED;
}

void
addQueryToCache(Client c)
{
	Module cache;
	backend *be = ((backend *) c->state[PARSER]);
	str optimizer;

	cache = findModule(c->nspace, putName("sql_cache",9));
	if (cache == 0) {
		return;
	}
	insertSymbol(cache, c->curprg);
	trimMalBlk(c->curprg->def);
	c->blkmode = 0;
	chkProgram(c->nspace, c->curprg->def);
#ifdef _SQL_OPTIMIZER_DEBUG
	printf("ADD QUERY TO CACHE\n");
	printFunction(GDKout,c->curprg->def,LIST_MAL_ALL);
#endif
@-
An error in the compilation should be reported to the user.
And if the debugging option is set, the debugger is called
to allow inspection.
@c
	if (c->curprg->def->errors) {
		mvc *m;
		m = ((mvc *) c->state[OPTIMIZE]);
		showErrors();

		if (c->listing)
			printFunction(c->fdout, c->curprg->def, c->listing);
		stream_flush(c->fdout);
		if ( m->debug )
			runMALDebugger(c->curprg);
		return;
	}
	(void)be;
	optimizer = sql_get_var(be->mvc,"optimizer");
#ifdef _SQL_OPTIMIZER_DEBUG
	if( optimizer)
		stream_printf(c->fdout,"optimizer=%s\n",optimizer);
#endif

	if( optimizer == 0 || strcmp(optimizer,"yes")==0){
		if( c->debug)
			optimizerCheck(c->curprg->def,"sql.baseline",-1,0);
		COoptimizer(c->curprg->def,0,0);
		ARoptimizer(c->curprg->def, 0, 0);
		FXoptimizer(c->curprg->def, 0, 0);
		OPTmultiplex(c->curprg->def, 0, 0);
		MRoptimizer(c->curprg->def,0,0);
	} else if( optimizer ){
		/* interpret the optimizer control statement */
	}
}

@-
The default SQL optimizer performs a limited set of operations
that are known to be (reasonably) stable and effective.
Finegrained control over the optimizer steps is available thru
setting the corresponding SQL variable.

This version simply runs through the MAL script and re-orders the instructions
into catalog operations, query graph, and result preparation.
This distinction is used to turn the function into a factory, which would
enable re-entry when used as a cache-optimized query.
The second optimization is move access mode changes on the base tables
to the front of the plan.

We also apply the Alias Removal optimizer to trim the instruction list
by removing simple assignments.

@c

str
SQLoptimizer(Client c)
{
	(void) c;
#ifdef _SQL_OPTIMIZER_DEBUG
	stream_printf(GDKout, "SQLoptimizer\n");
	printFunction(c->fdout, c->curprg->def, LIST_MAL_INSTR);
	stream_printf(GDKout, "done\n");
#endif
	return MAL_SUCCEED;
}
@-
The SQLkdiffSplitter searches this important operator and splits
the dataflow graph into two sections with a switch on the size of
the second operand. In many situations it is empty, there are no
deleted tuples to consider. The effect is that we do not have
to reduce the table to elements that are still valid.

Beware, the SQL code may contain several kdifference statements.
One for each base table touched. They should all be split,
which leads to an explosion in the plan sizes
@c
void SQLkdiffSplitter(Client c){
	MalBlkPtr mb;
	int limit,i,k,l,foundit=1,total=0, zero,cnt,lab;
	InstrPtr *old;
	InstrPtr q,p;
	int *map,mtop;
	long clk= GDKusec();

#ifdef _SQL_OPTIMIZER_DEBUG
	printf("START kdifference optimizer\n");
	printFunction(GDKout,c->curprg->def,LIST_MAL_ALL);
#endif
	while(foundit) {
		foundit=0;
		mb= c->curprg->def;
		setLifespan(mb);
		limit=mb->stop;
		old= mb->stmt;
		newMalBlkStmt(mb,mb->stop*2+5);

		for(i=0;i<limit; i++){
			p= old[i];
			if( moduleId(p) && strcmp(moduleName(p),"sql")==0 &&
			    strcmp(functionName(p),"kdifference")==0){
				total++;
				foundit++;
@-
The starting situation is to obtain the count and perform
an instruction copy until the endLifespan of the first operand.
	cnt:= algebra.count(t);
barrier doit:= c>0;
	....
exit	doit;
	..rest of code
@c
				q= newInstruction(NULL,ASSIGNsymbol);
				cnt= newTmpVariable(mb,TYPE_lng);
				setVarUsed(mb,cnt,TRUE);
				q->argv[0]=cnt;
				q->argv[1]= p->argv[2];
				q->argc=2;
				setModuleId(q,putName("algebra",7));
				setFunctionId(q,putName("count",5));
				pushInstruction(mb,q);

				q= newInstruction(NULL,ASSIGNsymbol);
				q->barrier= BARRIERsymbol;
				lab= newTmpVariable(mb,TYPE_bit);
				setVarUsed(mb,lab,TRUE);
				setVarUsed(mb,cnt,TRUE);
				setVarInitialized(mb,cnt);
				setModuleId(q,putName("calc",4));
				setFunctionId(q,putName(">",1));
				q->argv[0]=lab;
				q->argv[1]=cnt;
				q->retc=1;
				q->argc=2;
				pushLng(mb,q,0);
				zero= q->argv[2];
				setVarUsed(mb,q->argv[2],TRUE);
				pushInstruction(mb,q);
@-
We have to perform the expensive kdifference anyway
@c
				q= newInstruction(NULL,ASSIGNsymbol);
				setModuleId(q,putName("algebra",7));
				setFunctionId(q,putName("kdifference",5));
				q->argv[0]= p->argv[0];
				q->retc=1;
				pushArgument(mb,q,p->argv[1]);
				pushArgument(mb,q,p->argv[2]);
				pushInstruction(mb,q);
				typeChecker(c->nspace,mb,q,TRUE);
				/* endLifespan = mb->var[p->argv[0]]->endLifespan;*/
				k= i; /* for later */
				for(i++;i< limit-1; i++){
					q= old[i];
/* just handle the first */
					pushInstruction(mb,q);
					if( moduleId(q) && strcmp(moduleName(q),"sql")==0 &&
						strcmp(functionName(q),"kdifference")==0){
						setModuleId(q,putName("algebra",7));
					}
				}
				i--;

				q= newInstruction(NULL,EXITsymbol);
				q->barrier= EXITsymbol;
				q->argv[0]= lab;
				pushInstruction(mb,q);

@-
Durig the second phase we copy the same sequence, but
now we have to remap the variables. In this process the
variable types may change, which means we have to keep
track of them.
@c
				q= newInstruction(NULL,ASSIGNsymbol);
				q->barrier= BARRIERsymbol;
				setModuleId(q,putName("calc",4));
				setFunctionId(q,putName("==",2)); 
				q->argv[0]=lab;
				q->argv[1]=cnt;
				q->argv[2]=zero;
				q->retc=1;
				q->argc=3;
				pushInstruction(mb,q);
@-
Now we don;t have to perform the expensive kdifference 
@c
				map= (int*) GDKmalloc(2 * sizeof(int)*mb->vtop);
				map[0]= getArg(p,0);
				map[1]= getArg(p,1);
				mtop=2;

				i=k; 
				for(i++;i< limit-1; i++){
					q= copyInstruction(old[i]);
/* just handle the first */
					if( moduleId(q) && strcmp(moduleName(q),"sql")==0 &&
						strcmp(functionName(q),"kdifference")==0){
						setModuleId(q,putName("algebra",7));
					}
					for(k=0;k<q->argc; k++)
					for(l=0;l<mtop; l+=2)
					if( getArg(q,k)== map[2*l] ){
						/* deal with the type compatibility issue */
						q->argv[k]= map[2*l+1];
						break;
					}
					pushInstruction(mb,q);
				}
				i--;

				q= newInstruction(NULL,EXITsymbol);
				q->barrier= EXITsymbol;
				q->argv[0]= lab;
				pushInstruction(mb,q);

				/* remove the old instruction */
				GDKfree(map);
				freeInstruction(p);
				continue;
			}
			/* just move the instruction into place */
			pushInstruction(mb,p);
		}
@-
The code is wrong, we should not try it more than once
		foundit= foundit || (i<limit);
@c
		foundit=0;
		GDKfree(old);
	}
	if( total) {
		optimizerCheck(mb,"sql.kdiff_replacement",1,GDKusec()-clk);
#ifdef _SQL_OPTIMIZER_DEBUG
		printf("FINAL STAGE errors=%d\n",mb->errors);
		printFunction(GDKout,mb,LIST_MAL_ALL);
#endif
	}
}
@}
