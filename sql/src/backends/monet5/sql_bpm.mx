@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2007 CWI.
@' All Rights Reserved.

@f sql_bpm
@mal

module mat;

command bind(sname:str, tname:str, cname:str, access:int, part:int) :bat[:oid,:any_1]
address mat_bind_wrap
comment "Bind the bat tname.cname into the focus with specific access mode";

command bind_idxbat(sname:str, tname:str, iname:str, access:int, part:int):bat[:oid,:any_1]
address mat_bind_idxbat_wrap
comment "Bind the idx bat, tname.idx
	with specific accsess modes";

command inc_parts(sname:str, tname:str):void
address inc_parts_wrap
comment "Increment the number of partions";

module constraints;

command parts(sname:str, tname:str, cname:str, access:int, nrparts:int):void
address Cparts
comment "Check if the number of partions is still valid";

@h
#ifndef _SQL_BPM_H_
#define _SQL_BPM_H_
#include "sql.h"

sql5_export str mat_bind_wrap(int *bid, str *sname, str *tname, str *cname, int *access, int *part);
sql5_export str mat_bind_idxbat_wrap(int *bid, str *sname, str *tname, str *cname, int *access, int *part);
sql5_export str inc_parts_wrap(int *d, str *sname, str *tname);
sql5_export str Cparts(int *d, str *sname, str *tname, str *cname, int *access, int *parts);

#endif /* _SQL_BPM_H_ */

@c
#include <sql_config.h>
#include <sql_bpm.h>
#include <sql_mem.h>
#include <sql_mvc.h>
#include <sql.h>
#include <mal_exception.h>
#include <bpm/bpm_storage.h>
#include <bat/bat_utils.h>

static BAT *
mat_bind(mvc *m, char *sname, char *tname, char *cname, int access, int part)
{
	sql_schema *s = mvc_bind_schema(m, sname);
	sql_table *t = mvc_bind_table(m, s, tname);
	sql_column *c = mvc_bind_column(m, t, cname);
	sql_bpm *p = c->data;

	if (p->nr <= part) {
		return NULL;
	} else {
		if (access == RD_INS)
			part += p->ins;
		if (access == RD_UPD){
			assert(p->parts[part].ubid);
			return temp_descriptor(p->parts[part].ubid);
		}
		assert(p->parts[part].bid);
		return temp_descriptor(p->parts[part].bid);
	}
}

str
mat_bind_wrap(int *bid, str *sname, str *tname, str *cname, int *access, int *part)
{
	BAT *b = NULL;
	mvc *m = NULL;
	str msg = getContext(&m, NULL);

	if (msg)
		return msg;
	b = mat_bind(m, *sname, *tname, *cname, *access, *part);
	if (b) {
		BBPkeepref( *bid = b->batCacheid);
		return MAL_SUCCEED;
	}
	throw(SQL, "mat.bind", "limitation in transaction scope");
}

static BAT *
mat_bind_idxbat(mvc *m, char *sname, char *cname, int access, int part)
{
	sql_schema *s = mvc_bind_schema(m, sname);
	sql_idx *i = mvc_bind_idx(m, s, cname);
	sql_bpm *p = i->data;

	if (p->nr <= part) {
		return NULL;
	} else {
		if (access == RD_INS)
			part += p->ins;
		if (access == RD_UPD)
			return temp_descriptor(p->parts[part].ubid);
		return temp_descriptor(p->parts[part].bid);
	}
}

str
mat_bind_idxbat_wrap(int *bid, str *sname, str *tname, str *cname, int *access, int *part)
{
	BAT *b = NULL;
	mvc *m = NULL;
	str msg = getContext(&m, NULL);

	if (msg)
		return msg;
	(void)tname;
	b = mat_bind_idxbat(m, *sname, *cname, *access, *part);
	if (b) {
		BBPkeepref( *bid = b->batCacheid);
		return MAL_SUCCEED;
	}
	throw(SQL, "mat.bind", "limitation in transaction scope");
}

str
Cparts(int *d, str *sname, str *tname, str *cname, int *access, int *parts)
{
	mvc *m = NULL;
	str msg = getContext(&m, NULL);
	sql_schema *s;
	sql_table *t;
	sql_column *c;
	sql_bpm *p;
	int err = 0;

	(void)d;
	if (msg)
		return msg;

	s = mvc_bind_schema(m, *sname);
 	t = mvc_bind_table(m, s, *tname);
 	c = mvc_bind_column(m, t, *cname);
	if (c) {
		p = c->data;
	} else {
		sql_idx *i = mvc_bind_idx(m, s, *cname);
		p = i->data;
	}
	if (*access == RD_INS)
		err = *parts != (p->nr-p->ins);
	else
		err = *parts != (p->ins);
		    /* HACK ALERT */
	if (!err || *access == RD_UPD) 
		return MAL_SUCCEED;
	throw(OPTIMIZER, "mal.assert", "parts changed");
}

str
mat_dummy(void)
{
	throw(OPTIMIZER, "mat.dummy", "not optimized away");
}

static void
inc_parts(sql_table *t)
{
	node *n;

	if (isTempTable(t) || isView(t))
		return ;
	for (n=t->columns.set->h; n; n = n->next) {
		sql_column *c = n->data;
		if (c->data && !bpm_add_partition(c->data))
			return;
	}
	if (t->idxs.set) for (n=t->idxs.set->h; n; n = n->next) {
		sql_idx *i = n->data;
		if (i->data && !bpm_add_partition(i->data))
			return;
	}
}

str
inc_parts_wrap(int *d, str *sname, str *tname)
{
	mvc *m = NULL;
	str msg = getContext(&m, NULL);
	sql_schema *s;
	sql_table *t;

	(void)d;
	if (msg)
		return msg;

	s = mvc_bind_schema(m, *sname);
	if (active_store_type != store_bpm)
		throw(SQL, "mat.inc_parts", 
			"currently no bpm store support available");
	if (!s)
		throw(SQL, "mat.inc_parts", 
			sql_message("schema %s unknown", *sname));
 	t = mvc_bind_table(m, s, *tname);
	if (!t)
		throw(SQL, "mat.inc_parts", 
			sql_message("table %s unknown", *tname));
	inc_parts(t);
	return MAL_SUCCEED;
}

