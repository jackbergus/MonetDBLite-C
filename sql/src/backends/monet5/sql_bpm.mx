@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2008 CWI.
@' All Rights Reserved.

@f sql_bpm
@mal

module mat;

command bind(sname:str, tname:str, cname:str, access:int, part:int) :bat[:oid,:any_1]
address mat_bind_wrap
comment "Bind the bat tname.cname into the focus with specific access mode";

command bind_idxbat(sname:str, tname:str, iname:str, access:int, part:int):bat[:oid,:any_1]
address mat_bind_idxbat_wrap
comment "Bind the idx bat, tname.idx
	with specific accsess modes";

command inc_parts(sname:str, tname:str):void
address inc_parts_wrap
comment "Increment the number of partions";

module constraints;

command parts(sname:str, tname:str, cname:str, access:int, nrparts:int):void
address Cparts
comment "Check if the number of partions is still valid";

module distribution;

command bindHost(sname:str, tname:str, cname:str, part:int):int
address dist_bindHost_wrap
comment "Bind location id for a partition fragment";

command setHost(sname:str, tname:str, cname:str, part:int, host:int):int
address dist_setHost_wrap
comment "Set location id for a partition fragment";

command addHost(host:str, por:int, dbname:str, user:str, passwd:str):int
address dist_addHost_wrap
comment "Add a location for a partition fragment";

command reconnect(id:int):int
address dist_reconnect_wrap
comment "Reconnect to a remote host using the location information associated to id";

command send(mid:int, sname:str, tname:str, cname:str, part:int):int
address dist_send_wrap
comment "Send a fragment to a remote location";

@h
#ifndef _SQL_BPM_H_
#define _SQL_BPM_H_
#include "sql.h"

sql5_export str mat_bind_wrap(int *bid, str *sname, str *tname, str *cname, int *access, int *part);
sql5_export str mat_bind_idxbat_wrap(int *bid, str *sname, str *tname, str *cname, int *access, int *part);
sql5_export str inc_parts_wrap(int *d, str *sname, str *tname);
sql5_export str Cparts(int *d, str *sname, str *tname, str *cname, int *access, int *parts);
sql5_export str dist_bindHost_wrap(int *host, str *sname, str *tname, str *cname, int *part);
sql5_export str dist_setHost_wrap(int *bid, str *sname, str *tname, str *cname, int *part, int *host);
sql5_export str dist_addHost_wrap(int *id, str *host, int *port, str *dbname, str *user, str *passwd);
sql5_export str dist_reconnect_wrap(int *mid, int *id);
sql5_export str dist_send_wrap(int *mid, str *sname, str *tname, str *cname, int *part);



#endif /* _SQL_BPM_H_ */

@c
#include <sql_config.h>
#include <sql_bpm.h>
#include <sql_mem.h>
#include <sql_mvc.h>
#include <sql.h>
#include <mal_exception.h>
#include <bpm/bpm_storage.h>
#include <bat/bat_utils.h>
#include <mal_mapi.h>

static BAT *
mat_bind(mvc *m, char *sname, char *tname, char *cname, int access, int part)
{
	sql_schema *s = mvc_bind_schema(m, sname);
	sql_table *t = mvc_bind_table(m, s, tname);
	sql_column *c = mvc_bind_column(m, t, cname);
	sql_bpm *p = c->data;

	if (p->nr <= part) {
		return NULL;
	} else {
		if (access == RD_INS)
			part += p->ins;
		if (access == RD_UPD){
			assert(p->parts[part].ubid);
			return temp_descriptor(p->parts[part].ubid);
		}
		assert(p->parts[part].bid);
		return temp_descriptor(p->parts[part].bid);
	}
}

str
mat_bind_wrap(int *bid, str *sname, str *tname, str *cname, int *access, int *part)
{
	BAT *b = NULL;
	mvc *m = NULL;
	str msg = getContext(&m, NULL);

	if (msg)
		return msg;
	b = mat_bind(m, *sname, *tname, *cname, *access, *part);
	if (b) {
		BBPkeepref( *bid = b->batCacheid);
		return MAL_SUCCEED;
	}
	throw(SQL, "mat.bind", "limitation in transaction scope");
}

static BAT *
mat_bind_idxbat(mvc *m, char *sname, char *cname, int access, int part)
{
	sql_schema *s = mvc_bind_schema(m, sname);
	sql_idx *i = mvc_bind_idx(m, s, cname);
	sql_bpm *p = i->data;

	if (p->nr <= part) {
		return NULL;
	} else {
		if (access == RD_INS)
			part += p->ins;
		if (access == RD_UPD)
			return temp_descriptor(p->parts[part].ubid);
		return temp_descriptor(p->parts[part].bid);
	}
}

str
mat_bind_idxbat_wrap(int *bid, str *sname, str *tname, str *cname, int *access, int *part)
{
	BAT *b = NULL;
	mvc *m = NULL;
	str msg = getContext(&m, NULL);

	if (msg)
		return msg;
	(void)tname;
	b = mat_bind_idxbat(m, *sname, *cname, *access, *part);
	if (b) {
		BBPkeepref( *bid = b->batCacheid);
		return MAL_SUCCEED;
	}
	throw(SQL, "mat.bind", "limitation in transaction scope");
}

str
Cparts(int *d, str *sname, str *tname, str *cname, int *access, int *parts)
{
	mvc *m = NULL;
	str msg = getContext(&m, NULL);
	sql_schema *s;
	sql_table *t;
	sql_column *c;
	sql_bpm *p;
	int err = 0;

	(void)d;
	if (msg)
		return msg;

	s = mvc_bind_schema(m, *sname);
 	t = mvc_bind_table(m, s, *tname);
 	c = mvc_bind_column(m, t, *cname);
	if (c) {
		p = c->data;
	} else {
		sql_idx *i = mvc_bind_idx(m, s, *cname);
		p = i->data;
	}
	if (*access == RD_INS)
		err = *parts != (p->nr-p->ins);
	else
		err = *parts != (p->ins);
		    /* HACK ALERT */
	if (!err || *access == RD_UPD) 
		return MAL_SUCCEED;
	throw(OPTIMIZER, "mal.assert", "parts changed");
}

str
mat_dummy(void)
{
	throw(OPTIMIZER, "mat.dummy", "not optimized away");
}

static void
inc_parts(sql_table *t)
{
	node *n;

	if (isTempTable(t) || isView(t))
		return ;
	for (n=t->columns.set->h; n; n = n->next) {
		sql_column *c = n->data;
		if (c->data && !bpm_add_partition(c->data))
			return;
	}
	if (t->idxs.set) for (n=t->idxs.set->h; n; n = n->next) {
		sql_idx *i = n->data;
		if (i->data && !bpm_add_partition(i->data))
			return;
	}
}

str
inc_parts_wrap(int *d, str *sname, str *tname)
{
	mvc *m = NULL;
	str msg = getContext(&m, NULL);
	sql_schema *s;
	sql_table *t;

	(void)d;
	if (msg)
		return msg;

	s = mvc_bind_schema(m, *sname);
	if (active_store_type != store_bpm)
		throw(SQL, "mat.inc_parts", 
			"currently no bpm store support available");
	if (!s)
		throw(SQL, "mat.inc_parts", 
			sql_message("schema %s unknown", *sname));
 	t = mvc_bind_table(m, s, *tname);
	if (!t)
		throw(SQL, "mat.inc_parts", 
			sql_message("table %s unknown", *tname));
	inc_parts(t);
	return MAL_SUCCEED;
}

static int
dist_bind(mvc *m, char *sname, char *tname, char *cname, int part)
{
	sql_schema *s = mvc_bind_schema(m, sname);
	sql_table *t = mvc_bind_table(m, s, tname);
	sql_column *c = mvc_bind_column(m, t, cname);
	sql_bpm *p = c->data;

	if (p->nr <= part) {
		return 0;
	} else {
		return *(int *) p->parts[part].host;
	}
}


str
dist_bindHost_wrap(int *host, str *sname, str *tname, str *cname, int *part)
{
	mvc *m = NULL;
	str msg = getContext(&m, NULL);

	if (msg)
		return msg;
	if ((*host = dist_bind(m, *sname, *tname, *cname, *part)))
		return MAL_SUCCEED;
	throw(SQL, "dist.bindHost", "limitation in transaction scope");
}

static int
dist_set(mvc *m, char *sname, char *tname, char *cname, int part, int host)
{
	sql_schema *s = mvc_bind_schema(m, sname);
	sql_table *t = mvc_bind_table(m, s, tname);
	sql_column *c = mvc_bind_column(m, t, cname);
	sql_bpm *p = c->data;

	if (p->nr <= part) {
		return 0;
	} else {
		
		return bpm_set_part_location(p, part, host, NULL, 0, NULL, NULL, NULL);
	}
}

str 
dist_setHost_wrap(int *bid, str *sname, str *tname, str *cname, int *part, int *host)
{
	mvc *m = NULL;
	str msg = getContext(&m, NULL);
	
	if (msg)
		return msg;
	if ((*bid = dist_set(m, *sname, *tname, *cname, *part, *host)))
		return MAL_SUCCEED;
	throw(SQL, "dist.setHost", "limitation in transaction scope");
}

str 
dist_addHost_wrap(int *id, str *host, int *port, str *dbname, str *user, str *passwd)
{
	bpmHost bpmH = bpm_host_create(*host, *port, *dbname, *user, *passwd);
	if (bpmH && (*id = *(int *) bpmH->host))
		return MAL_SUCCEED;
	throw(SQL, "dist.addHost", "limitation in transaction scope");

}

str 
dist_reconnect_wrap(int *mid, int *id)
{
	bpmHost bpmH = bpm_host_get(*id);
	char *lng = "mal";
	str msg = SERVERreconnectAlias(mid, &bpmH->host, &bpmH->port, &bpmH->dbname, &bpmH->user, &bpmH->passwd, &lng); 
	if (msg)
		return msg;
	return MAL_SUCCEED;
}

static str 
dist_send(mvc *m, int *mid, str sname, str tname, str cname, int part)
{
	sql_schema *s = mvc_bind_schema(m, sname);
	sql_table *t = mvc_bind_table(m, s, tname);
	sql_column *c = mvc_bind_column(m, t, cname);
	sql_bpm *p = c->data;
	BAT *b = NULL;

	if (p->nr <= part) {
		return NULL;
	} else {
		int bid = logger_find_bat(bpm_logger, p->parts[part].name);
                b = temp_descriptor(bid);
		(void) b;
		(void) mid;
		/*return SERVERsend(*mid, &p->parts[part].name, b);	*/
	}
	
	return NULL;	
}

str 
dist_send_wrap(int *mid, str *sname, str *tname, str *cname, int *part)
{
	mvc *m = NULL;
	str msg = getContext(&m, NULL);
	
	if (msg)
		return msg;
	if ((msg = dist_send(m, mid, *sname, *tname, *cname, *part)))
		return MAL_SUCCEED;
	throw(SQL, "dist.put", msg);
}
