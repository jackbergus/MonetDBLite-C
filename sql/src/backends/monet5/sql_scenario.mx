@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2005 CWI.
@' All Rights Reserved.

@f sql_scenario
@t SQL catalog management
@a N. Nes, M.L. Kersten
@+ SQL scenario
The SQL scenario implementation is a derivative of the MAL session scenario.

It is also the first version that uses state records attached to
the client record. They are initialized as part of the initialization 
phase of the scenario.

@h
#ifndef _SQL_SCENARIO_H_
#define _SQL_SCENARIO_H_
#include "sql.h"

/* #define _SQL_SCENARIO_DEBUG */
/* #define _SQL_READER_DEBUG */
/* #define _SQL_PARSER_DEBUG */

sql_export str SQLexitClient(Client c);
sql_export str SQLinitClient(Client c);
sql_export str SQLexit(Client c);
sql_export str SQLinit(Client c);
sql_export str SQLinitEnvironment(int *ret);
sql_export str SQLcompile(str *ret, str *expr, int *flag);
sql_export str SQLepilogue();

sql_export str SQLparser(Client c);
sql_export str SQLengine(Client c);

#endif /* _SQL_SCENARIO_H_ */

@+ Scenario routines
Before we are can process SQL statements the global catalog
should be initialized. Thereafter, each time a client enters
we update its context descriptor to denote an SQL scenario.
@c
#include "sql_scenario.h"
#include "sql_result.h"
#include "sql_gencode.h"
#include "sql_optimizer.h"
#include "sql_cache.h"
#include "sql_env.h"
#include "sql_readline.h"
#include "print.h"
#include "mal_parser.h"
#include <bat/res_table.h>
#include "mal_namespace.h"
#include "mal_debugger.h"
#include "bat.h"
#include <mtime.h>

static void pushCatchDefault(MalBlkPtr mb, str nme, int autocommit);

static int SQLinitialized;

static void
monet5_freestack(backend_stack stk)
{
	(void) stk;
#ifdef _SQL_SCENARIO_DEBUG
	stream_printf(GDKout, "#monet5_freestack\n");
#endif
}

static void
monet5_parse(backend_stack stk, char *cmd)
{
	(void) stk;
	(void) cmd;
#ifdef _SQL_SCENARIO_DEBUG
	stream_printf(GDKout, "#monet5_parse:%s\n", cmd);
#endif
}

static void
monet5_freecode(backend_code code, backend_stack stk, int nr)
{
	(void) code;
	(void) stk;
	(void) nr;
#ifdef _SQL_SCENARIO_DEBUG
	stream_printf(GDKout, "#monet5_free:%d\n", nr);
#endif
}

str
SQLinit(Client c)
{
	char *gmt = "GMT";
	tzone tz;

#ifdef _SQL_SCENARIO_DEBUG
	stream_printf(GDKout, "#SQLinit Monet 5\n");
#endif
	if (SQLinitialized)
		return MAL_SUCCEED;
	SQLinitialized = FALSE;
	(void) c;		/* not used */
	MTIMEtimezone(&tz, &gmt);
	(void) tz;
	backend_init(&monet5_freestack, &monet5_freecode, &monet5_parse);
	if (mvc_init(FALSE, 0) < 0) {
		return throwMessage("SQLinit", "Catalogue initialization failed\n");
	}
	SQLinitialized = TRUE;
	return MAL_SUCCEED;
}

str
SQLexit(Client c)
{
#ifdef _SQL_SCENARIO_DEBUG
	stream_printf(GDKout, "#SQLexit\n");
#endif
	(void) c;		/* not used */
	if( SQLinitialized == FALSE){
		return throwMessage("SQLexit",
			"Catalogue not available\n");
	}
	/* the SQL scenario support may never be finished
	mvc_exit();
	SQLinitialized= FALSE;
	*/
	return MAL_SUCCEED;
}

str
SQLepilogue()
{
	if( SQLinitialized){
		mvc_exit();
		SQLinitialized= FALSE;
	}
	return MAL_SUCCEED;
}

static int
sendProperty(stream *out, char *name, char *value)
{
	if (stream_write(out, "[ \"", 1, 3) != 3)
		return 0;
	while (*name) {
		switch (*name) {
		case '"':
			if (stream_write(out, "\\\"", 1, 2) != 2)
				return 0;
			break;
		case '\\':
			if (stream_write(out, "\\\\", 1, 2) != 2)
				return 0;
			break;
		default:
			if (stream_write(out, name, 1, 1) != 1)
				return 0;
			break;
		}
		name++;
	}
	if (stream_write(out, "\", \"", 1, 4) != 4)
		return 0;
	while (*value) {
		switch (*value) {
		case '"':
			if (stream_write(out, "\\\"", 1, 2) != 2)
				return 0;
			break;
		case '\\':
			if (stream_write(out, "\\\\", 1, 2) != 2)
				return 0;
			break;
		default:
			if (stream_write(out, value, 1, 1) != 1)
				return 0;
			break;
		}
		value++;
	}
	if (stream_write(out, "\" ]\n", 1, 4) != 4)
		return 0;
	return 1;
}
@-
It should become possible to initialize the SQL
from a MAL program to setup an environment to
debug independently of the parser plans
produced. This should not touch the IO parameters.
@c
str 
SQLinitAdmin(Client c)
{
	str msg;
	mvc *m;
	str schema;

	if (!SQLinitialized && (msg = SQLinit(c)) != MAL_SUCCEED)
		return msg;
	
	if ((backend *) c->state[PARSER] == 0) {
		m = mvc_create(1, 0, c->fdin, c->fdout);
		/* replace user name with client record setting later on */
		schema = mvc_login(m, "monetdb", "monetdb");
		if (!schema) {
			return throwMessage("SQLparser", "No schema defined\n");
		} else {
			/*
			if (!sendProperty(c->fdout, "version", "5") ||
			    !sendProperty(c->fdout, "language", "sql") ||
			    !sendProperty(c->fdout, "schema", schema) || 
			    !sendProperty(c->fdout, "auto_commit", "false") || 
			    !sendProperty(c->fdout, "reply_size", "1000") || 
				stream_flush(c->fdout) < 0)
			{
				res_tables_destroy(m->results);
				mvc_destroy(m);
				return throwMessage("SQLparser", "Disconnected\n");
			}
			*/
		}
		c->state[PARSER] = (void *) backend_create(0 /*debug */ , m, c);
		((backend*)c->state[PARSER])->language = 'S';	/*expect SQL text first */
		c->state[OPTIMIZE] = m;
	} else {
		m = c->state[OPTIMIZE];
	}
	return MAL_SUCCEED;
}

str
SQLinitClient(Client c)
{
	str msg;

#ifdef _SQL_SCENARIO_DEBUG
	stream_printf(GDKout, "#SQLinitClient\n");
#endif

	msg = SQLinitAdmin(c);

	c->yycur = 0;		/* make sure we don't reuse the used input */
	c->fdin->eof = 1;	/* force prompt on first iteration */
	initSQLreferences();
	return msg;
}

str
SQLexitClient(Client c)
{
	mvc *m;
#ifdef _SQL_SCENARIO_DEBUG
	stream_printf(GDKout, "#SQLexitClient\n");
#endif
	if (SQLinitialized == FALSE) {
		return throwMessage("SQLinitClient", "Catalogue not available\n");
	}
	if ((backend *) c->state[PARSER] && (mvc *) c->state[OPTIMIZE]) {
		m= (mvc *) c->state[OPTIMIZE];
		if (m->qc) {
			oid id;
			int ret = 0;

			for (id = 0; id <m->qc->id; id ++) {
				char buf[BUFSIZ], *nme ;
				snprintf(buf, BUFSIZ, "sql%d", (int) id);
				nme= putName(buf,strlen(buf));
				SQLCacheRemove(&ret, &nme);
			}
		}
		mvc_destroy((mvc *) c->state[OPTIMIZE]);
		backend_destroy((backend *) c->state[PARSER]);
		/* files are already closed */
		c->state[OPTIMIZE] = NULL;
		c->state[PARSER] = NULL;
	}
	return MAL_SUCCEED;
}

str
SQLsession(str *ret)
{
	str msg = MAL_SUCCEED;

	stream_printf(GDKout, "#Continue as SQL session\n");
	msg = setScenario(getClient(), "sql");
	*ret = 0;
	return msg;
}

@-
A statement received internally is simply appended for
execution
@c
str
SQLinitEnvironment(int *ret)
{
	(void) ret;
	return SQLinitAdmin(getClient());
}
@-
The SQLcompile operation can be used by separate
front-ends to benefit from the SQL functionality.
It expects a string and returns the name of the
corresponding MAL block as it is known in the
SQL_cache, where it can be picked up.
@c

void
freeVariables(MalBlkPtr mb, MalStkPtr glb, int start)
{
	int i;

	for (i = start; i < mb->vtop;) {
		clearVariable(mb, i);

		if (glb) {
			garbageElement(&glb->stk[i]);
			/* clean stack entry */
			glb->stk[i].vtype = TYPE_int;
			glb->stk[i].val.ival = 0;
			glb->stk[i].len = 0;
		}
		i++;
	}
	mb->vtop = start;
}


/* #define _SQL_COMPILE */
str
SQLcompile(str *ret, str *expr, int *flag)
{
	int err = 0;
	mvc o, *m;
	buffer *b;
	char *n;
	str msg= MAL_SUCCEED;
	Client c= getClient();
	backend *sql = ((backend *) c->state[PARSER]);
	int len = strlen(*expr);

	(void) ret;
	(void) flag;
#ifdef _SQL_COMPILE
	stream_printf(c->fdout, "#SQLstatement:flag=%d:%s\n", *flag, *expr);
#endif
	if (!sql)
		return throwMessage("SQLcompile", "Catalogue not available\n");

	m = sql->mvc;
	if (!m->sa)
		m->sa = sa_create();
	o = *m;
	sql = backend_create(0, m, c);
	m->qc = NULL;
	m->cache = 0;

	b = (buffer*)GDKmalloc(sizeof(buffer));
	n = GDKmalloc(len + 1 + 1);
	strncpy(n, *expr, len);
	n[len] = '\n';
	n[len+1] = 0;
	len++;

	buffer_init(b, n, len);
	scanner_init( &m->scanner, 
		bstream_create(buffer_rastream(b, "sqlstatement"), b->len),
		NULL);
	m->scanner.mode = LINE_1; 
	bstream_next(m->scanner.rs);

	m->params = NULL;
	m->argc = 0;
	m->sym = NULL;
	m->auto_commit = 0;

@-
System has been prepared to parse it and generate code
@c
	if ( (err = sqlparse(m)) ||
	    /* Only forget old errors on transaction boundaries */
	    (mvc_status(m) && m->type != Q_TRANS) || !m->sym) {
		if (!err)
			err = mvc_status(m);
		sqlcleanup(m, err);
		*m->errstr = 0;
		msg = throwMessage("SQLparser", "Parser errors\n");
		goto endofcompile;
	}
@-
We have dealt with the first parsing step and advanced the input reader
to the next statement (if any).
Now is the time to also perform the semantic analysis, 
optimize and produce code.
We don;t search the cache for a previous incarnation.
@c
	{	
		Symbol curPrg = c->curprg;
		int vtop = c->curprg->def->vtop;
		stmt *s = sql_symbol2stmt(m);

		c->curprg = NULL;

		if (!s && (err = mvc_status(m))) {
			stream_printf(c->fdout, "#%s\n", m->errstr);
			*m->errstr = 0;
			sqlcleanup(m, err);
			msg = throwMessage("SQLparser", "Semantic errors\n");
			goto endofcompile;
		}
		assert(s);
		/* generate MAL code */
		backend_dumpproc(sql, c, 0, s);

		chkTypes(c->nspace, c->curprg->def); /* resolve types */

		extern str OPTmultiplex(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
		/* we know more in this case then
			chkProgram(c->nspace, c->curprg->def); */
		if (!c->curprg->def->errors && m->mode != m_prepare &&
/*
		    (msg = sql_get_var(m,"optimizer")) == NULL) 
*/
		    !m->cache) {
			OPTmultiplex(c->curprg->def,0,0);
		}
		if (!c->curprg->def->errors) {
			backend *be = c->state[PARSER];
			sql->out = NULL; /* no output */
			c->state[PARSER] = sql;
			msg = (str) runMAL(c, c->curprg->def, 1, 0, 0, 0);
			c->state[PARSER] = be;
		}
		resetInstructions(c->curprg->def, 1);
		freeVariables(c->curprg->def, c->glb, vtop);
		c->curprg = curPrg;
#ifdef _SQL_COMPILE
		printFunction(c->fdout, c->curprg->def, c->listing);
#endif
	}
#ifdef _SQL_COMPILE
	stream_printf(c->fdout, "#parse result %d\n", err);
#endif
@-
We are done; a MAL procedure recides in the cache.
@c
endofcompile:
	backend_destroy(sql);
	GDKfree(n);
	GDKfree(b);
	bstream_destroy(m->scanner.rs);
	*m = o;
	return msg;
}
str
SQLcompile0(str *ret, str *expr)
{
	int flag= -1;
	return SQLcompile(ret,expr,&flag);
}
@-
Implementation of the execution of a single SQL statement is postponed.
@c
str
SQLstatement(str *ret, str *cmd)
{
	int flag=0;

#ifdef _SQL_READER_DEBUG
	stream_printf(GDKout, "#SQLstatement:%s\n", *cmd);
#endif
	SQLcompile(ret,cmd,&flag);
	return MAL_SUCCEED;
}

static int
error(stream *out, char *str)
{
	char *p;

	if (!out)
		out = GDKerr;

	if (stream_errnr(out))
		return -1;
	while ((p = strchr(str, '\n')) != NULL) {
		p++;		/* include newline */
		if (*str !='!' && stream_write(out, "!", 1, 1) != 1)
			return -1;
		if (stream_write(out, str, p - str, 1) != 1)
			 return -1;
		str = p;
	}
	if (str &&*str) {
		if (*str !='!' && stream_write(out, "!", 1, 1) != 1)
			return -1;
		if (stream_write(out, str, strlen(str), 1) != 1 || stream_write(out, "\n", 1, 1) != 1)
			 return -1;
	}
	if (stream_flush(out))
		return -1;
	return 0;
}

#define TRANS_ABORTED "!current transaction is aborted (please ROLLBACK)\n"

int
handle_error(mvc *m, stream *out, int pstatus)
{
	int go = 1;
	char *buf = GDKerrbuf;

	/* transaction already broken */
	if (m->type != Q_TRANS && pstatus < 0) {
		if (stream_write(out, TRANS_ABORTED, sizeof(TRANS_ABORTED) - 1, 1) != 1) {
			go = !go;
		}
	} else {
		if (error(out, m->errstr) < 0 || (buf && buf[0] && error(out, buf) < 0)) {
			go = !go;
		}
	}
	/* reset error buffers */
	m->errstr[0] = 0;
	if (buf)
		buf[0] = 0;
	return go;
}


@-
The SQL reader collects a (sequence) of statements from the input
stream, but only when no unresolved 'nxt' character is visible.
In combination with SQLparser this ensures that all statements
are handled one by one.

The SQLreader is called from two places: the SQL parser and
the MAL debugger.
The former only occurs during the parsing phase and the
second only during exection.
This means we can safely change the language setting for
the duration of these calls.
@c
int SQLautocommit(Client c, mvc *m){
	if (m->auto_commit && m->trans) {
		if (m->cache && (m->type == Q_TRANS || 
			m->type == Q_SCHEMA || 
			m->qc->id >100)) {
			if (m->qc) 
				qc_destroy(m->qc);
			m->qc = qc_create();
		}
		if (mvc_status(m) < 0) {
			mvc_rollback(m, 0, NULL);
		} else if (mvc_commit(m, 0, NULL) < 0) {
		 	return handle_error(m, c->fdout, 0);
		}
	}
	return TRUE;
}

str
SQLreader(Client c)
{
	int go = TRUE;
	int more = TRUE;
	backend *be = ((backend *) c->state[PARSER]);
	bstream *in = c->fdin;
	int language = be->language;	/* 'S' for SQL, 'D' from debugger */
	mvc *m = be->mvc;

#ifdef _SQL_READER_DEBUG
	stream_printf(GDKout, "#SQLparser: start reading SQL block\n");
	stream_flush(GDKout);
#endif
	if (!be || c->mode <= FINISHING) {
		c->mode = FINISHING;
		return NULL;
	}

@- 
Continue processing any left-over input from the previous round.
@c

#ifdef _SQL_READER_DEBUG
	stream_printf(GDKout, "#pos %d len %d\n", in->pos, in->len);
	stream_flush(GDKout);
#endif
	/* skip whitespace */
	while (in->pos < in->len && (isspace((int) (in->buf[in->pos])) || in->buf[in->pos] == ';'))
		in->pos++;
@-
Distinguish between console reading and MapiClient connections.
The former comes with readline functionality.
@c
	while(more) {
	    more = FALSE;
	    if (go && in->pos >= in->len) {
		ssize_t rd;

		if (c->bak) {
			popClientInput(c);
			in = c->fdin;
			m->scanner.rs = c->fdin;
			c->fdin->pos += c->yycur;
			c->yycur = 0;
		}
		if (in->eof || !isa_block_stream(in->s)) {
			language = (be->console) ? 'S' : 0;

			/* The rules of auto_commit require us to finish 
			   and start a transaction on the start of a new statement */
			go = SQLautocommit(c,m);

			if (go && (stream_write(c->fdout, c->prompt, c->promptlength, 1) != 1 || stream_flush(c->fdout))) {
				go = FALSE;
				break;
			}
			in->eof = 0;
		}
		if (go && (rd = bstream_next(in)) <= 0) {
#ifdef _SQL_READER_DEBUG
			stream_printf(GDKout, "#rd %d  language %d eof %d\n", rd, language, in->eof);
			stream_flush(GDKout);
#endif
			if (be->language == 'D' && in->eof == 0) {
				return 0;
			}
			if (rd == 0 && language != 0 && in->eof && !be->console) {
				/* we hadn't seen the EOF before, so just try again
				   (this time with prompt) */
				more = TRUE;
				continue;
			}
			go = FALSE;
			break;
		} else if (go && !be->console && language == 0) {
			be->language = in->buf[in->pos++];
		}
#ifdef _SQL_READER_DEBUG
		stream_printf(GDKout, "#SQL blk:%s\n", in->buf + in->pos);
#endif
	    }
	}
	if (!go || (strncmp(CURRENT(c), "quit", 4) == 0)) {
		in->pos = in->len;	/* skip rest of the input */
		c->mode = FINISHING;
		return NULL;
	}
	return 0;
}

@-
The SQL block is stored in the client input buffer, from which it
can be parsed by the SQL parser. The client structure contains
a small table of bounded tables. This should be reset before we
parse a new statement sequence.
@-
Before we parse the sql statement, we look for any variable settings
for specific commands.
The most important one is to prepare code to be handled by the debugger.
The current analysis is simple and fulfills our short-term needs.
A future version may analyze the parameter settings in more detail.
@c

void
SQLsetDebugger(Client c, mvc *m, int onoff)
{
	InstrPtr q;

	if (m == 0 || m->mode != m_debug)
		return;
	c->itrace='n';
	q = newInstruction(NULL,ASSIGNsymbol);
	moduleId(q) = putName("mdb",3);
	if( onoff)
		functionId(q) = putName("start",5);
	else functionId(q) = putName("stop",4);
	pushInstruction(c->curprg->def, q);
}

void
SQLsetTrace(Client c, int on)
{
	if (on)
		c->listing = (c->listing & LIST_INPUT) | LIST_MAL_INSTR;
	else
		c->listing &= LIST_INPUT;
}

void
SQLsetExplain(Client c)
{
	c->listing = (c->listing & LIST_INPUT) | LIST_MAL_ALL;
}

static int
output_prepare(stream *out, mvc *c, cq *q)
{
	node *n;

	if (!out)
		return 0;
	/* indicate to client that a new SQL command starts here */
	if (stream_printf(out,
		"#-\n"
		"# " SZFMT " # querytype\n"
		"# prepare,	prepare,	prepare # table_name\n"
		"# type,	digits,	scale # name\n"
		"# varchar,	int,	int # type\n"
		"# 0,	0,	0 # length\n"
		"# %d # tuplecount\n"
		"# %d # id\n",
		Q_PREPARE,
		c->params ? list_length(c->params) : 0,
		q->id
	) < 0) {
		return -1;
	}

	if (c->params) {
		int i, len = list_length(c->params);

		q->paramlen = len;
		q->params = NEW_ARRAY(sql_subtype,len);
		for (n = c->params->h, i=0; n; n = n->next, i++) {
			var_ *v = n->data;
			sql_subtype *t = tail_type(v->s);

			if (t) {
				if (stream_printf(out,
					"[ \"%s\",	%d,	%d	]\n",
					t->type->sqlname,
					t->digits,
					t->scale
				) < 0) {
					return -1;
				}
				/* add to the query cache parameters */
				q->params[i] = *t;
			} else {
				return -1;
			}
		}
	}
	return 0;
}

@-
The core part of the SQL interface, parse the query and
prepare the intermediate code.
@c

str
SQLparser(Client c)
{
	bstream *in = c->fdin;
	stream *out = c->fdout;
	str msg = 0;
	int err = 0;
	backend *be;
	mvc *m;
	int oldvtop,oldstop;
	lng T0 = 0;
	int pstatus = 0;
	prot oldmode;

	be = ((backend *) c->state[PARSER]);
	if (be == 0) {
		GDKerror("SQL state descriptor missing\n");
		return throwMessage("SQLparser", "State decriptor missing\n");
	}
	oldvtop = c->curprg->def->vtop;
	oldstop = c->curprg->def->stop;
	be->vtop = oldvtop;
#ifdef _SQL_PARSER_DEBUG
	stream_printf(GDKout, "#SQL compilation \n");
	printf("debugger? %d %d\n", debugPlan(), be->mvc->mode);
#endif
	m = be->mvc;

	assert(m);

	m->type = Q_PARSE;
	if (!m->trans) 
		mvc_trans(m);
	pstatus = m->status;

	/* sqlparse needs sql allocator to be available.  It can be NULL at
	 * this point if this is a recursive call. */
	if (!m->sa)
		m->sa = sa_create();

	m->mode = m->explain;
	oldmode = m->scanner.mode;
	if (be->language == 's') {
		be->language = 'S';
		m->scanner.mode = LINE_1;
	}
	if (be->language != 'S' && be->language != 'X') {
		return throwMessage("SQLparser", "Unrecognized language prefix\n");
	}
	if (be->language == 'X') {
		int n = 0, id, off, len;

		if( strncmp(in->buf + in->pos,"export ",7)==0 )
			n = sscanf(in->buf + in->pos+7, "%d %d %d", &id, &off, &len);

		if (n == 2 || n == 3) {
			mvc_export_chunk(m, out, id, off, n == 3 ? len : m->reply_size);

			in->pos = in->len;	/* HACK: should use parsed lenght */
			return NULL;
		}
		if( strncmp(in->buf+in->pos,"close ",6)==0 ){
			res_table *t = res_tables_find(m->results, id);

			id= (int) strtol(in->buf+in->pos+6,NULL,0);
			if (t)
				m->results = res_tables_remove(m->results, t);
			in->pos = in->len;	/* HACK: should use parsed lenght */
			return NULL;
		}
		if( strncmp(in->buf + in->pos,"quit",4)==0 ) {
			c->mode = FINISHING;
			return NULL;
		}
		return throwMessage("SQLparser", "Unrecognized X command\n");
	}

	if( explainPerformance())
		T0 = GDKusec();

	if ((err = sqlparse(m)) && m->debug){
		/* switch to different language mode */
		char oldlang= be->language;
		be->language= 'D';
		runMALDebugger(c->curprg);
		be->language= oldlang;
	}
	if( err ||
	    /* Only forget old errors on transaction boundaries */
	    (mvc_status(m) && m->type != Q_TRANS) || !m->sym) {
		if (!err)
			err = mvc_status(m);
		msg = throwMessage("SQLparser", m->errstr);
		handle_error(m, c->fdout, pstatus);
		sqlcleanup(m, err);
		goto finalize;
	}
@-
We have dealt with the first parsing step and advanced the input reader
to the next statement (if any).
Now is the time to also perform the semantic analysis, optimize and 
produce code.
@c
	be->q = NULL;
	if (m->mode == m_execute) {
		be->q = qc_find(m->qc, m->sym->data.lval->h->data.ival);
		if (!be->q) {
			err = -1;
			sql_error(m, 2, "no prepared statement with the given id\n");
		} else {
			err = backend_exec_prepared_stmt( be, be->q );
		}
		if (err) {
			sqlcleanup(m, err);
			goto finalize;
		}
	} else 
	if( (be->q = qc_match(m->qc, m->sym, m->args, m->argc, m->scanner.key)) ){
		/* not sure if this is allowed, because subsequent cleanup may
			depend on it */
		//m->mode= m_execute;
	} else {
		stmt *s;

		s = sql_symbol2stmt(m);

		if (!s && (err = mvc_status(m))) {
			msg = throwMessage("SQLparser", m->errstr);
			handle_error(m, c->fdout, pstatus);
			sqlcleanup(m, err);
			goto finalize;
		}
		assert(s);
		/* generate and call the MAL code */
/*
		if (m->mode != m_prepare &&
		   (msg = sql_get_var(m,"optimizer")) == NULL) {
*/
		if( m->mode == m_debug)
			SQLsetDebugger(c, m, m->mode == m_debug);
		if (m->mode != m_prepare && !m->cache){
			backend_callinline(be, c, s );
		} else {
			/* generate a factory instantiation */
			size_t factorized = backend_dumpproc(be, c, m->qc->id, s);
			be->q = qc_insert(m->qc, 
					  m->sa,      /* the allocator */
					  m->sym,     /* the sql symbol tree */
					  m->args,    /* the argument list */
					  m->argc,
					  m->scanner.key,	/* the statement hash key */
					  m->type,	/* the type of the statement */
					  (char*)factorized/*_strdup("the mal block?")*/);

			be->q->code = (backend_code) c->curprg;
			be->q->stk = 0;
			m->sa = NULL;
			m->sym = NULL;
		} 
		stmt_destroy(s);
	}
#ifdef _SQL_PARSER_DEBUG
	else
		stream_printf(GDKout, "#parse result %d\n", err);
#endif
	if( be->q) be->q->stk= 0;
	if (be->q && m->mode == m_prepare) {
		err = output_prepare(c->fdout, m, be->q);
	} else if(m->mode == m_execute && be->q){
		/* everything ready for a fast call */
	} else if (be->q) {  /* call procedure generation (only in cache mode) */
		backend_call(be, c, be->q);
	}

@-
In the final phase we add any debugging control
@c
	/* turn off debugger */
	if( debugPlan() && m->mode != m_execute)
		SQLsetDebugger(c, m, FALSE);

	if (explainPerformance()) {
		be->qry = sql_escape_str(QUERY(m->scanner));
		be->Tparse = GDKusec() - T0;
	}

@-
During the execution of the query exceptions can be raised.
The default action is to print them out at the end of the
query block.
@c
	if (err == 0) {
		pushCatchDefault(c->curprg->def, "sqlerror", m->auto_commit);
		pushEndInstruction(c->curprg->def);

extern str OPTmultiplex(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);

		chkTypes(c->nspace, c->curprg->def); /* resolve types */
		/* we know more in this case then
			chkProgram(c->nspace, c->curprg->def); */
		if (!c->curprg->def->errors && m->mode != m_prepare &&
/*
		    (msg = sql_get_var(m,"optimizer")) == NULL) 
*/
		    !m->cache) {
			OPTmultiplex(c->curprg->def,0,0);
		}
		if (c->curprg->def->errors) {
			if( m->mode == m_debug){
				/* switch to differnt language mode */
				char oldlang= be->language;
				be->language= 'D';
				runMALDebugger(c->curprg);
				be->language= oldlang;
			}
			showErrors();
			/* restore the state */
			if (c->listing || explainPlan())
				printFunction(c->fdout, c->curprg->def, c->listing);
			resetMalBlk(c->curprg->def, oldstop);
			freeVariables(c->curprg->def, c->glb, oldvtop);
			c->curprg->def->errors = 0;
			msg = throwMessage("SQLparser", "Semantic errors\n");
		}
	}
finalize:
	m->scanner.mode = oldmode;
	if (explainPlan() && m->mode != m_execute) {
		printFunction(c->fdout, c->curprg->def, c->listing);
	}
#ifdef _SQL_PARSER_DEBUG
	else {
		stream_printf(GDKout, "#SQL finished:%s\n", msg);
		printFunction(c->fdout, c->curprg->def, c->listing);
	}
#endif
@-
Gather the statistics for post analysis. It should preferably
be stored in an SQL table
@c
	return msg;
}

@-
Execution of the SQL program is delegated to the MALengine.
Different cases should be distinguished. The default is to
hand over the MAL block derived by the parser for execution.
However, when we received an Execute call, we make a shortcut
and prepare the stack for immediate execution
@c
static str sql_cacheRef=0;
static Module sql_moduleRef=0;
str
SQLexecutePrepared(Client cntxt, backend *be, cq *q )
{
	mvc *c = be->mvc;
	int argc, parc; 
	ValPtr *argv, argvbuffer[MAXARG];
	ValRecord *argrec, argrecbuffer[MAXARG];
	MalBlkPtr mb;
	MalStkPtr glb;
	InstrPtr pci;
	int i;
	str ret;
	Symbol sym;

#ifdef DEBUG_CALLMAL
	stream_printf(GDKout,"SQLexecute\n");
	printFunction(GDKout,((Symbol)q->code)->def,LIST_MAL_ALL);
#endif
	if( sql_cacheRef== NULL)
		sql_cacheRef= putName("sql_cache",9);
	if( sql_moduleRef== NULL)
		sql_moduleRef= findModule(0,sql_cacheRef);
	sym= findSymbolInModule(sql_moduleRef, backend_name(q));
	assert(sym != NULL);
	mb= sym->def;
	pci= getInstrPtr(mb,0);
	if( pci->argc >= MAXARG)
		argv= (ValPtr *) GDKmalloc(sizeof(ValPtr) * pci->argc);
	else argv= argvbuffer;

	if( pci->retc >= MAXARG)
		argrec= (ValRecord *)GDKmalloc(sizeof(ValRecord) * pci->retc);
	else argrec= argrecbuffer;

	/* prepare the target variables */
	for(i=0;i<pci->retc; i++){
		argv[i]= argrec+i;
		argv[i]->vtype= getVarGDKType(mb,i);
	}

	argc = c->argc;
	parc = q->paramlen;

	if (argc != parc) {
		sql_error(c, 0002, "wrong number of arguments for prepared statement\n");
		if( pci->argc >= MAXARG)
			GDKfree(argv);
		if( pci->retc >= MAXARG)
			GDKfree(argrec);
		return MAL_SUCCEED;
	} else {
		for (i = 0; i<c->argc; i++){
			atom *arg = c->args[i];
			sql_subtype *pt = q->params+i;

			if (!atom_cast(arg, pt)) {
				char buf[BUFSIZ];

				snprintf(buf, BUFSIZ, "wrong argument for prepared statement (expected %s instead of %s)\n", pt->type->sqlname, atom_type(arg)->type->sqlname);
				sql_error(c, 003, buf);
				if( pci->argc >= MAXARG)
					GDKfree(argv);
				if( pci->retc >= MAXARG)
						GDKfree(argrec);
				return MAL_SUCCEED;
			}
			argv[pci->retc+i]= &arg->data;
		}
	}
	glb = (MalStkPtr)(q->stk);
	ret= callMAL(cntxt,mb, &glb, argv, (c->mode == m_debug?'n':0));
	q->stk = (backend_stack)glb;
	if( pci->argc >= MAXARG)
		GDKfree(argv);
	if( pci->retc >= MAXARG)
			GDKfree(argrec);
	return ret;
}
str
SQLengine(Client c)
{
	str msg = MAL_SUCCEED;
	MalStkPtr oldglb = c->glb;
	backend *be = ((backend *) c->state[PARSER]);
	char oldlang= be->language;
	mvc *m = be->mvc;
	lng T0=0;

	if (be->language == 'X'){ 	/* return directly from X-commands */
		sqlcleanup(be->mvc, 0);
		return MAL_SUCCEED;
	}

	if (c->curprg->def->errors){
		sqlcleanup(be->mvc, 0);
		return throwMessage("SQLengine", "Program contains errors\n");
	}
#ifdef SQL_SCENARIO_DEBUG
	stream_printf(GDKout, "#Ready to execute SQL statement\n");
#endif

	if( c->curprg->def->stop == 1 ){
		sqlcleanup(be->mvc, 0);
		return MAL_SUCCEED;
	}
	if( explainPerformance())
		T0 = GDKusec();
	if (m->mode == m_execute) {
		msg= SQLexecutePrepared(c,be, be->q );
		goto cleanup_engine;
	}
	if( m->mode == m_prepare){
		goto cleanup_engine;
	} else if(explainPlan()){
		printFunction(c->fdout, c->curprg->def, c->listing);
@-
If you want to see the detailed code, we have to pick it up from
the cache as well. This calls for finding the call to the
cached routine, which may be hidden . For now we take a shortcut.
@c
		if( be->q) {
			InstrPtr p;
			p = getInstrPtr(c->curprg->def,1);
			if( p->blk)
				printFunction(c->fdout, p->blk, c->listing);

		}
		c->curprg->def->errors = -1; /* don;t execute */
	} 
	c->glb = 0;
	be->language= 'D';
@-
The code below is copied from MALengine, which handles execution
in the context of a user global environment. We have a private
environment.
@c
	if( MALcommentsOnly(c->curprg->def)) {
		msg= MAL_SUCCEED;
	} else {
		msg = (str) runMAL(c, c->curprg->def, 1, 0, 0, 0);
	}

cleanup_engine:
    if (msg) {
        GDKerror(msg);
        if (!c->listing)
            printFunction(c->fdout, c->curprg->def, c->listing);
        showErrors();
		m->status = -10;
    }
	sqlcleanup(be->mvc, 0);
	resetMalBlk( c->curprg->def, 1);
	/* resetInstructions(c->curprg->def, 1);*/
	freeVariables(c->curprg->def, c->glb, be->vtop);
	be->language = oldlang;
@-
Any error encountered during execution should block further processing
unless auto_commit has been set.
@c
	c->glb = oldglb;
	if (explainPerformance()) {
		str ret;
		int mode = m->mode;
		int explain = m->explain;
		lng tot = be->Tparse;
		char buf[BUFSIZ], *qs, *stmt = buf;

		tot += be->Texec = GDKusec() - T0;
		qs = be->qry;
		while(isspace(*qs)) 
			qs++; 
		m->mode = m_normal;
		m->explain = m_normal;
		/* TODO use sql_prepare/execute */
		snprintf(buf, BUFSIZ, "insert into sys.profile "
		 "values(now,'%s'," LLFMT ",0," LLFMT "," LLFMT" ,USER);\n",
		 qs, be->Tparse, be->Texec, tot);
@-
This code causes a recursion, because the reset of the explain
triggers the profile action. A better approach is to directly
update the profile tables, without SQL intervention.
Then the SQL profile table is just a view over a few basic bats.
@c
		stream_printf(GDKout, "#%s [parse %d]", be->qry, be->Tparse);
		stream_printf(GDKout, "[engine %d]", be->Texec);
		stream_printf(GDKout, "[total %d]\n", tot);
		if (be->qry)
			GDKfree(be->qry);
		be->qry = NULL;

		SQLstatement(&ret, &stmt);
		m->mode = mode;
		m->explain = explain;
	}

	/*
	 * clear query cache after Transaction boundaries (commit/rollback)
	 * and on schema changes
	 */
	if (m->cache && (m->type == Q_TRANS || m->type == Q_SCHEMA || m->qc->id >100)) {
		if (m->qc) {
			oid id;
			int ret = 0;

			for (id = 0; id <m->qc->id; id ++) {
				char buf[BUFSIZ], *nme ;
				snprintf(buf, BUFSIZ, "sql%d", (int) id);
				nme= putName(buf,strlen(buf));
				SQLCacheRemove(&ret, &nme);
			}
			(void) ret;
			qc_destroy(m->qc);
		}
		m->qc = qc_create();
	}

	return msg;
}

@-
Assertion errors detected during the execution of a code block
raises an exception.
@c
str
SQLassert(int *ret, bit *flg, str *msg)
{
	(void) ret;
	if (*flg)
		return throwException("SQLerror", "assert", *msg);
	return MAL_SUCCEED;
}

str
SQLassertInt(int *ret, int *flg, str *msg)
{
	(void) ret;
	if (*flg)
		return throwException("SQLerror", "assert", *msg);
	return MAL_SUCCEED;
}

str
SQLassertLng(int *ret, lng *flg, str *msg)
{
	(void) ret;
	if (*flg)
		return throwException("SQLerror", "assert", *msg);
	return MAL_SUCCEED;
}

@- Utilities
Catching errors is a recurring situation. The block below 
generates the default code block, ie catch it and print
the error. It should also deal with the auto_commit
situation. [todo]
For the time being we do not catch errors. They are
passed to the environment.
@c
static void
pushCatchDefault(MalBlkPtr mb, str nme, int autocommit)
{
/*
	InstrPtr p;
*/

/*	int i;*/
	(void) mb;
	(void) nme;
	(void) autocommit;

/*
	if (autocommit) {
		p = newInstruction(NULL,ASSIGNsymbol);
		moduleId(p) = putName("sql",3);
		functionId(p) = putName("commit",6);
		pushInstruction(mb, p);
	}
*/
/* no catch
	p= newInstruction(NULL,CATCHsymbol);
	i= findVariable(mb,nme);
	if( i< 0) i= newVariable(mb,GDKstrdup(nme),TYPE_str);
	getDestVar(p) = i;
	p->argc =1;
	p->retc = 1;
	pushInstruction(mb,p);

	p= newInstruction(NULL,ASSIGNsymbol);
	moduleId(p)= putName("io",2);
	functionId(p)= putName("print",5);
	pushArgumentId(mb, p, GDKstrdup(nme));
	pushInstruction(mb,p);
*/

/*
	if (autocommit) {
		p = newInstruction(NULL,ASSIGNsymbol);
		moduleId(p) = putName("sql",3);
		functionId(p) = putName("rollback",8);
		pushInstruction(mb, p);
	}
*/
/*       else {
		p= newInstruction(NULL,RAISEsymbol);
		p->barrier= RAISEsymbol;
		p->argv[0] = findVariable(mb,GDKstrdup("sqlerror"));
		pushStr(mb,p,"Transaction abort");
		pushInstruction(mb,p);
	}

	p= newInstruction(NULL,EXITsymbol);
	p->argv[0] = findVariable(mb,GDKstrdup(nme));
	p->barrier= EXITsymbol;
	pushInstruction(mb,p);
*/
}

@mal
# nothing special to do
