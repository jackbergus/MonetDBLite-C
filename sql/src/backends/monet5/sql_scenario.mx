@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2007 CWI.
@' All Rights Reserved.

@f sql_scenario
@t SQL catalog management
@a N. Nes, M.L. Kersten
@+ SQL scenario
The SQL scenario implementation is a derivative of the MAL session scenario.

It is also the first version that uses state records attached to
the client record. They are initialized as part of the initialization 
phase of the scenario.

@h
#ifndef _SQL_SCENARIO_H_
#define _SQL_SCENARIO_H_
#include "sql.h"

/* #define _SQL_SCENARIO_DEBUG */
/* #define _SQL_READER_DEBUG */
/* #define _SQL_PARSER_DEBUG */

sql5_export str SQLsession(str *ret);
sql5_export str SQLsession2(str *ret);
sql5_export str SQLprelude(void);
sql5_export str SQLepilogue(void);
sql5_export str SQLstartQuery(int *ret, str *qry);
sql5_export str SQLexitQuery(int *ret, str *qry);

sql5_export str SQLexit(Client c);
sql5_export str SQLinit(Client c);
sql5_export str SQLexitClient(Client c);
sql5_export str SQLinitClient(Client c);
sql5_export str SQLreader(Client c);
sql5_export str SQLparser(Client c);
sql5_export str SQLengine(Client c);
sql5_export str SQLassert(int *ret, bit *flg, str *msg);
sql5_export str SQLassertInt(int *ret, int *flg, str *msg);
sql5_export str SQLassertLng(int *ret, lng *flg, str *msg);

sql5_export str SQLinitEnvironment(int *ret);
sql5_export str SQLstatement(int *ret, str *expr);
sql5_export str SQLcompile(str *ret, str *expr);
sql5_export str SQLtrace(int *ret);
sql5_export str SQLCacheRemove(Client c, str nme);

#endif /* _SQL_SCENARIO_H_ */

@+ Scenario routines
Before we are can process SQL statements the global catalog
should be initialized. Thereafter, each time a client enters
we update its context descriptor to denote an SQL scenario.
@c
#include "sql_config.h"
#include "sql_scenario.h"
#include "sql_result.h"
#include "sql_gencode.h"
#include "sql_optimizer.h"
#include "sql_env.h"
#include "sql_mvc.h"
#include "sql_readline.h"
#include "sql_user.h"
#include "mal_io.h"
#include "mal_parser.h"
#include "mal_builder.h"
#include <bat/res_table.h>
#include "mal_namespace.h"
#include "mal_sabaoth.h"
#include "mal_debugger.h"
#include "bat5.h"
#include <mtime.h>
#include "optimizer.h"

static int SQLinitialized = 0;
static int SQLdebug = 0;

static void
monet5_freestack(backend_stack stk)
{
	ptr p = (ptr)stk;
	if (p != NULL)
		GDKfree(p);
#ifdef _SQL_SCENARIO_DEBUG
	stream_printf(GDKout, "#monet5_freestack\n");
#endif
}

static void
monet5_freecode(backend_code code, backend_stack stk, int nr, char *name)
{
	(void) code;
	(void) stk;
	(void) nr;
	SQLCacheRemove(MCgetClient(), name);

#ifdef _SQL_SCENARIO_DEBUG
	stream_printf(GDKout, "#monet5_free:%d\n", nr);
#endif
}

str
SQLsession(str *ret)
{
	str msg = MAL_SUCCEED;

	msg = setScenario(MCgetClient(), "sql");
	*ret = 0;
	return msg;
}

str
SQLsession2(str *ret)
{
	str msg = MAL_SUCCEED;

	msg = setScenario(MCgetClient(), "msql");
	*ret = 0;
	return msg;
}

str
SQLprelude(void)
{
	int res = 0;
	str tmp;
	Scenario s = getFreeScenario();
	if (!s)
		throw(MAL, "sql.start", "out of scenario slots");
	s->name = "sql";
	s->language = "sql";
	s->initSystem = "SQLinit";
	s->exitSystem = "SQLexit";
	s->initClient = "SQLinitClient";
	s->exitClient = "SQLexitClient";
	s->reader = "SQLreader";
	s->parser = "SQLparser";
	/* s->optimizer = "SQLoptimizer";
	 * s->tactics = .. */
	s->engine = "SQLengine";
	tmp = SABAOTHmarchScenario(&res, &s->name);
	if (tmp != MAL_SUCCEED)
		return(tmp);

	s = getFreeScenario();
	if (!s)
		throw(MAL, "sql.start", "out of scenario slots");

	s->name = "msql";
	s->language = "msql";
	s->initSystem = "SQLinit";
	s->exitSystem = "SQLexit";
	s->initClient = "SQLinitClient";
	s->exitClient = "SQLexitClient";
	s->reader = "MALreader";
	s->parser = "MALparser";
	s->optimizer = "MALoptimizer";
	/* s->tactics = .. */
	s->engine = "MALengine";
	return SABAOTHmarchScenario(&res, &s->name);
}

str
SQLepilogue(void)
{
	int res = 0;
	char *s = "sql";

	if( SQLinitialized){
		/*
		mvc_exit(); 
		SQLinitialized= FALSE;
		*/
	}
	/* this function is never called, but for the style of it, we clean
	 * up our own mess */
	return SABAOTHretreatScenario(&res, &s);
}

str
SQLinit(Client c)
{
	char *debug_str = GDKgetenv("sql_debug");
	char *gmt = "GMT";
	tzone tz;
	backend_functions *be_funcs;

	(void) c;		/* not used */
#ifdef _SQL_SCENARIO_DEBUG
	stream_printf(GDKout, "#SQLinit Monet 5\n");
#endif
	if (SQLinitialized)
		return MAL_SUCCEED;
	/* SQLinitialized == FALSE; */

	be_funcs = GDKzalloc(sizeof(backend_functions));
	be_funcs->fstack		= &monet5_freestack;
	be_funcs->fcode			= &monet5_freecode;
	monet5_user_init(be_funcs);
	backend_init(be_funcs); /* be_funcs probably leaks */

	MTIMEtimezone(&tz, &gmt);
	(void) tz;
	if (mvc_init(FALSE, 0) < 0) 
		throw(SQL, "SQLinit", "Catalogue initialization failed");
	if (debug_str) 
		SQLdebug = strtol(debug_str,NULL,10);
	SQLinitialized = TRUE;
	return MAL_SUCCEED;
}

str
SQLexit(Client c)
{
#ifdef _SQL_SCENARIO_DEBUG
	stream_printf(GDKout, "#SQLexit\n");
#endif
	(void) c;		/* not used */
	if( SQLinitialized == FALSE)
		throw(SQL, "SQLexit", "Catalogue not available");
	return MAL_SUCCEED;
}

static int keep_trace = 0;

str
SQLtrace(int *ret)
{
	(void)ret;
	keep_trace = !keep_trace;
	return MAL_SUCCEED;
}

@-
@= SQLglobal
	name = @1;
	r = stmt_var(_strdup(name), &ctype, 0, 1);
	stack_push_var(sql, name, r, &ctype);
	stack_set_var(sql, name, VALset(&src, ctype.type->localtype, @2));
@c
/* initialize the global variable, ie make mvc point to these */
static int
global_variables(mvc *sql, char *user, char *schema)
{
	sql_subtype ctype;
	char *typename;
	char *name;
	stmt *r = NULL;
	int debug = 0, sec = 0;
	bit T = TRUE, F = FALSE;
	ValRecord src;

 	typename = "int";
	sql_find_subtype(&ctype, typename, 0, 0);
	@:SQLglobal("debug", &debug)@

	typename = "varchar";
	sql_find_subtype(&ctype, typename, 8, 0);
	@:SQLglobal("explain", "")@

	sql_find_subtype(&ctype, typename, 1024, 0);
	@:SQLglobal("current_schema", schema)@
	@:SQLglobal("current_user", user)@
	@:SQLglobal("current_role", user)@
	@:SQLglobal("optimizer", defaultPlan)@

	typename = "sec_interval";
	sql_find_subtype(&ctype, typename, 0, 0);
	@:SQLglobal("current_timezone", &sec)@

	typename = "boolean";
	sql_find_subtype(&ctype, typename, 0, 0);
	@:SQLglobal("cache", &T)@
	@:SQLglobal("profile", &F)@
	@:SQLglobal("trace", &F)@
	return 0;
}

str
SQLstartQuery(int *ret, str *qry){
	(void) ret; (void) qry;
	return MAL_SUCCEED;
}
str
SQLexitQuery(int *ret, str *qry){
	(void) ret; (void) qry;
	return MAL_SUCCEED;
}

str
SQLinitClient(Client c)
{
	str msg;
	mvc *m;
	str schema;

#ifdef _SQL_SCENARIO_DEBUG
	stream_printf(GDKout, "#SQLinitClient\n");
#endif

	if (!SQLinitialized && (msg = SQLinit(c)) != MAL_SUCCEED)
		return msg;
	
	if ((backend *) c->state[MAL_SCENARIO_PARSER] == 0) {
		m = mvc_create((c-mal_clients), 0, SQLdebug, c->fdin, c->fdout);

		global_variables(m, "monetdb", "sys");
		if (isAdministrator(c))  /* console should return everything */
			m->reply_size = -1;
		/* pass through credentials of the user if not console */
		schema = monet5_user_get_def_schema(m, c->user);
		if (!schema) {
			_DELETE(schema);
			throw(PERMD, "SQLinitClient", "schema authorization error");
		}
		_DELETE(schema);

		if (keep_trace && !m->scanner.log) {
			char fn[BUFSIZ];

			snprintf(fn, BUFSIZ, "sql.%d", (int)(c - mal_clients));
			m->scanner.log = open_wastream(fn);
		}
		c->state[MAL_SCENARIO_PARSER] = (void *) backend_create(m, c);
		((backend*)c->state[MAL_SCENARIO_PARSER])->language = 'S';	/*expect SQL text first */
		c->state[MAL_SCENARIO_OPTIMIZE] = m;
	} else {
		m = c->state[MAL_SCENARIO_OPTIMIZE];
		/* TODO reset global variables */
	}

	initSQLreferences();
	return MAL_SUCCEED;
}

str
SQLexitClient(Client c)
{
	mvc *m;
#ifdef _SQL_SCENARIO_DEBUG
	stream_printf(GDKout, "#SQLexitClient\n");
#endif
	if (SQLinitialized == FALSE) {
		throw(SQL, "SQLinitClient", "Catalogue not available");
	}
	if ((backend *) c->state[MAL_SCENARIO_PARSER] && (mvc *) c->state[MAL_SCENARIO_OPTIMIZE]) {
		m= (mvc *) c->state[MAL_SCENARIO_OPTIMIZE];
		res_tables_destroy(m->results);
		m->results= NULL;
		mvc_destroy(m);
		backend_destroy((backend *) c->state[MAL_SCENARIO_PARSER]);
		/* files are already closed */
		c->state[MAL_SCENARIO_OPTIMIZE] = NULL;
		c->state[MAL_SCENARIO_PARSER] = NULL;
	}
	return MAL_SUCCEED;
}

@-
A statement received internally is simply appended for
execution
@c
str
SQLinitEnvironment(int *ret)
{
	(void) ret;
	return SQLinitClient(MCgetClient());
}
@-
The cache with plans should be regularly be refreshed.
@c
void
SQLcacheRefresh(mvc *m){
	if (m && !m->session->active) {
		int schema_changed = mvc_trans(m);
		if (m->cache && (schema_changed || m->qc->id > 1000)){
			if (m->qc)
				qc_destroy(m->qc);
			m->qc = qc_create(m->clientid);
		}
	}
}
@-
The SQLcompile operation can be used by separate
front-ends to benefit from the SQL functionality.
It expects a string and returns the name of the
corresponding MAL block as it is known in the
SQL_cache, where it can be picked up.
The SQLstatement operation also executes the instruction.

In both cases the SQL string is handled like an ordinary
user query, following the same optimization paths and
caching.
@c

static void
freeVariables(MalBlkPtr mb, MalStkPtr glb, int start)
{
	int i;

	for (i = start; i < mb->vtop;) {
		clearVariable(mb, i);

		if (glb) {
			garbageElement(&glb->stk[i]);
			/* clean stack entry */
			glb->stk[i].vtype = TYPE_int;
			glb->stk[i].val.ival = 0;
			glb->stk[i].len = 0;
		}
		i++;
	}
	mb->vtop = start;
}

/* #define _SQL_COMPILE */
static str
SQLstatementIntern(str *expr, str nme, int execute)
{
	int err = 0;
	mvc o, *m;
	int ac;
	buffer *b;
	char *n;
	str msg = MAL_SUCCEED;
	Client c= MCgetClient();
	backend *sql = ((backend *) c->state[MAL_SCENARIO_PARSER]);
	int len = strlen(*expr);

#ifdef _SQL_COMPILE
	stream_printf(c->fdout, "#SQLstatement:%s\n", *expr);
#endif
	if (!sql) {
		msg = SQLinitEnvironment(&err);
		sql = ((backend *) c->state[MAL_SCENARIO_PARSER]);
	}
	if (msg)
		throw(SQL, "SQLstatement", "Catalogue not available");

	initSQLreferences();
	m = sql->mvc;
 	ac = m->session->auto_commit;
	SQLcacheRefresh(m);
	if (!m->sa)
		m->sa = sa_create();
	o = *m;
	m->type= Q_PARSE;
	sql = backend_create(m, c);
	m->qc = NULL;
	m->cache = 0;
	m->user_id = m->role_id = USER_MONETDB;

	b = (buffer*)GDKmalloc(sizeof(buffer));
	n = GDKmalloc(len + 1 + 1);
	strncpy(n, *expr, len);
	if(n[len] != '\n') n[len++] = '\n';
	n[len] = 0;

	buffer_init(b, n, len);
	scanner_init( &m->scanner, 
		bstream_create(buffer_rastream(b, "sqlstatement"), b->len),
		NULL);
	m->scanner.mode = LINE_1; 
	bstream_next(m->scanner.rs);

	m->params = NULL;
	m->argc = 0;
	m->sym = NULL;
	m->session->auto_commit = 0;

@-
System has been prepared to parse it and generate code
@c
	if ( (err = sqlparse(m)) ||
	    /* Only forget old errors on transaction boundaries */
	    (mvc_status(m) && m->type != Q_TRANS) || !m->sym) {
		if (!err)
			err = mvc_status(m);
		if( m->errstr)
			msg = createException(PARSE, "SQLparser", m->errstr);
		 else 
			msg = createException(PARSE, "SQLparser", "Parser errors");
		*m->errstr = 0;
		sqlcleanup(m, err);
		goto endofcompile;
	}
@-
We have dealt with the first parsing step and advanced the input reader
to the next statement (if any).
Now is the time to also perform the semantic analysis, 
optimize and produce code.
We don;t search the cache for a previous incarnation yet.
@c
	{	
		Symbol oldsym= c->curprg;
		stmt *s = sql_symbol2stmt(m, m->sym);

		MSinitClientPrg(c,"user",nme); 
		if (!s && (err = mvc_status(m))) {
			stream_printf(c->fdout, "%s\n", m->errstr);
			if( m->errstr)
				msg = createException(PARSE, "SQLparser", m->errstr);
			else msg = createException(PARSE, "SQLparser", "Semantic errors");
			*m->errstr = 0;
			sqlcleanup(m, err);
			/* restore the state */
			freeSymbol(c->curprg);
			c->curprg= oldsym;
			goto endofcompile;
		}
		/* generate MAL code */
		backend_callinline(sql, c, s );
		addQueryToCache(c); 

		if( c->curprg->def->errors){
			/* restore the state */
			freeSymbol(c->curprg);
			c->curprg= oldsym;
			goto endofcompile;
		}

#ifdef _SQL_COMPILE
		stream_printf(c->fdout,"result of sql.eval()\n");
		printFunction(c->fdout, c->curprg->def, c->listing);
#endif

		if ( execute) {
			backend *be = c->state[MAL_SCENARIO_PARSER];
			sql->out = NULL; /* no output */
			c->state[MAL_SCENARIO_PARSER] = sql;
			msg = (str) runMAL(c, c->curprg->def, 1, 0, 0, 0);
			c->state[MAL_SCENARIO_PARSER] = be;
			MSresetInstructions(c->curprg->def, 1);
			freeVariables(c->curprg->def, 0, 0);
			c->curprg= oldsym;
		}
	}
#ifdef _SQL_COMPILE
	stream_printf(c->fdout, "#parse/execute result %d\n", err);
#endif
@-
We are done; a MAL procedure recides in the cache.
@c
endofcompile:
	backend_destroy(sql);
	GDKfree(n);
	GDKfree(b);
	bstream_destroy(m->scanner.rs);
	*m = o;
	m->session->auto_commit = ac;
	return msg;
}

str
SQLstatement(int *ret, str *expr)
{
	(void)ret;
	return SQLstatementIntern(expr, "SQLstatement", TRUE);
}

str
SQLcompile(str *ret, str *expr){
	str msg;

	*ret = NULL;
	msg= SQLstatementIntern(expr, "SQLcompile", FALSE);
	if( msg == MAL_SUCCEED)
		*ret= GDKstrdup("SQLcompile");
	return msg;
}

static int
error(stream *out, char *str)
{
	char *p;

	if (!out)
		out = GDKerr;

	if (stream_errnr(out))
		return -1;
	while ((p = strchr(str, '\n')) != NULL) {
		p++;		/* include newline */
		if (*str !='!' && stream_write(out, "!", 1, 1) != 1)
			return -1;
		if (stream_write(out, str, p - str, 1) != 1)
			 return -1;
		str = p;
	}
	if (str &&*str) {
		if (*str !='!' && stream_write(out, "!", 1, 1) != 1)
			return -1;
		if (stream_write(out, str, strlen(str), 1) != 1 || stream_write(out, "\n", 1, 1) != 1)
			 return -1;
	}
	return 0;
}

#define TRANS_ABORTED "!current transaction is aborted (please ROLLBACK)\n"

int
handle_error(mvc *m, stream *out, int pstatus)
{
	int go = 1;
	char *buf = GDKerrbuf;

	/* transaction already broken */
	if (m->type != Q_TRANS && pstatus < 0) {
		if (stream_write(out, TRANS_ABORTED, sizeof(TRANS_ABORTED) - 1, 1) != 1) {
			go = !go;
		}
	} else {
		if (error(out, m->errstr) < 0 || (buf && buf[0] && error(out, buf) < 0)) {
			go = !go;
		}
	}
	/* reset error buffers */
	m->errstr[0] = 0;
	if (buf)
		buf[0] = 0;
	return go;
}


@-
The SQL reader collects a (sequence) of statements from the input
stream, but only when no unresolved 'nxt' character is visible.
In combination with SQLparser this ensures that all statements
are handled one by one.

The SQLreader is called from two places: the SQL parser and
the MAL debugger.
The former only occurs during the parsing phase and the
second only during exection.
This means we can safely change the language setting for
the duration of these calls.
@c

int SQLautocommit(Client c, mvc *m){
	if (m->session->auto_commit && m->session->active) {
		if (mvc_status(m) < 0) {
			mvc_rollback(m, 0, NULL);
		} else if (mvc_commit(m, 0, NULL) < 0) {
		 	return handle_error(m, c->fdout, 0);
		}
	}
	return TRUE;
}

/* #define _SQL_READER_DEBUG */
str
SQLreader(Client c)
{
	int go = TRUE;
	int more = TRUE;
	backend *be = ((backend *) c->state[MAL_SCENARIO_PARSER]);
	bstream *in = c->fdin;
	int language = -1;
	mvc *m = NULL;
	int blocked = isa_block_stream(in->s);

	if (!be || c->mode <= FINISHING) {
#ifdef _SQL_READER_DEBUG
	stream_printf(GDKout, "SQL client finished\n");
#endif
		c->mode = FINISHING;
		return NULL;
	}
#ifdef _SQL_READER_DEBUG
	stream_printf(GDKout, "#SQLparser: start reading SQL %s %s\n",
		(be->console?" from console":""), 
		(blocked? "Blocked read":""));
#endif
	language = be->language;	/* 'S' for SQL, 'D' from debugger */
	m = be->mvc;
@- 
Continue processing any left-over input from the previous round.
@c

#ifdef _SQL_READER_DEBUG
	stream_printf(GDKout, "#pos %d len %d eof %d \n",
		in->pos, in->len, in->eof);
#endif
@-
Distinguish between console reading and MapiClient connections.
The former comes with readline functionality.
@c
	while(more) {
		more = FALSE;
		if (go && in->pos >= in->len) {
		ssize_t rd;

		if (c->bak) {
#ifdef _SQL_READER_DEBUG
			stream_printf(GDKout, "Switch to backup stream\n");
#endif
			MCpopClientInput(c);
			in = c->fdin;
			m->scanner.rs = c->fdin;
			c->fdin->pos += c->yycur;
			c->yycur = 0;
		}
		if (in->eof || !blocked) {
			language = (be->console) ? 'S' : 0;

			/* The rules of auto_commit require us to finish 
			   and start a transaction on the start of a new statement */
			if( m->mode != m_debug )
				go = SQLautocommit(c,m);

			if (go && ((!blocked && stream_write(c->fdout, c->prompt, c->promptlength, 1) != 1) || stream_flush(c->fdout))) {
				go = FALSE;
				break;
			}
			in->eof = 0;
		}
		if (go && (rd = bstream_next(in)) <= 0) {
#ifdef _SQL_READER_DEBUG
			stream_printf(GDKout, "#rd %d  language %d eof %d\n", rd, language, in->eof);
#endif
			if (be->language == 'D' && in->eof == 0) 
				return 0;

			if (rd == 0 && language != 0 && in->eof && !be->console) {
				/* we hadn't seen the EOF before, so just try again
				   (this time with prompt) */
				more = TRUE;
				continue;
			}
			go = FALSE;
			break;
		} else if (go && !be->console && language == 0) {
			be->language = in->buf[in->pos++];
		}
#ifdef _SQL_READER_DEBUG
		stream_printf(GDKout, "#SQL blk:%s\n", in->buf + in->pos);
#endif
		}
	}
	if (!go || (strncmp(CURRENT(c), "\\q", 2) == 0)) {
		in->pos = in->len;	/* skip rest of the input */
		c->mode = FINISHING;
		return NULL;
	}
	return 0;
}

@-
The SQL block is stored in the client input buffer, from which it
can be parsed by the SQL parser. The client structure contains
a small table of bounded tables. This should be reset before we
parse a new statement sequence.
@-
Before we parse the sql statement, we look for any variable settings
for specific commands.
The most important one is to prepare code to be handled by the debugger.
The current analysis is simple and fulfills our short-term needs.
A future version may analyze the parameter settings in more detail.
@c
void
SQLsetDebugger(Client c, mvc *m, int onoff)
{
	if (m == 0 || m->mode != m_debug)
		return;
	c->itrace='n';
	if( onoff){
		newStmt(c->curprg->def,"mdb","start");
		c->debugOptimizer= TRUE;
	} else {
		newStmt(c->curprg->def,"mdb","stop");
		c->debugOptimizer= FALSE;
	}
}

void
SQLsetTimer(Client c, int onoff)
{
	InstrPtr q;

	c->itrace='c';
	q = newStmt(c->curprg->def,"mdb","setTimer");
	pushBit(c->curprg->def,q,onoff);
	q = newStmt(c->curprg->def,"mdb","setFlow");
	pushBit(c->curprg->def,q,onoff);
}

void
SQLshowPlan(Client c)
{
	newStmt(c->curprg->def,"mdb","list");
}

@-
The core part of the SQL interface, parse the query and
prepare the intermediate code.
@c

str
SQLparser(Client c)
{
	bstream *in = c->fdin;
	stream *out = c->fdout;
	str msg = 0;
	backend *be;
	mvc *m;
	int oldvtop,oldstop;
	lng T0 = 0;
	int pstatus = 0;
	int err = 0;
	prot oldmode;

	be = ((backend *) c->state[MAL_SCENARIO_PARSER]);
	if (be == 0) {
		showException(SQL,"sql","SQL state descriptor missing\n");
		throw(SQL, "SQLparser", "State descriptor missing");
	}
	oldvtop = c->curprg->def->vtop;
	oldstop = c->curprg->def->stop;
	be->vtop = oldvtop;
#ifdef _SQL_PARSER_DEBUG
	stream_printf(GDKout, "#SQL compilation \n");
	printf("debugger? %d\n", be->mvc->mode);
#endif
	m = be->mvc;
	m->type = Q_PARSE;
	SQLcacheRefresh(m);
	pstatus = m->session->status;

	/* sqlparse needs sql allocator to be available.  It can be NULL at
	 * this point if this is a recursive call. */
	if (!m->sa)
		m->sa = sa_create();

	m->mode = m->explain;
	oldmode = m->scanner.mode;
	if (be->language == 's') {
		be->language = 'S';
		m->scanner.mode = LINE_1;
	}
	if (be->language == 'X') {
		int n = 0, v, off, len;

		if( strncmp(in->buf + in->pos,"export ",7)==0 )
			n = sscanf(in->buf + in->pos+7, "%d %d %d", &v, &off, &len);

		if (n == 2 || n == 3) {
			mvc_export_chunk(m, out, v, off, n == 3 ? len : m->reply_size);

			in->pos = in->len;	/* HACK: should use parsed lenght */
			return NULL;
		}
		if( strncmp(in->buf+in->pos,"close ",6)==0 ){
			res_table *t;

			v = (int) strtol(in->buf+in->pos+6,NULL,0);
 			t = res_tables_find(m->results, v);
			if (t)
				m->results = res_tables_remove(m->results, t);
			in->pos = in->len;	/* HACK: should use parsed lenght */
			return NULL;
		}
		if( strncmp(in->buf+in->pos,"auto_commit ", 12)==0 ){
			int commit;
			v= (int) strtol(in->buf+in->pos+12,NULL,10);
			commit = (!m->session->auto_commit && v);
			m->session->auto_commit = (v)?1:0;
			m->session->ac_on_commit = m->session->auto_commit;
			if (m->session->active) {
				if (commit && mvc_commit(m, 0, NULL)< 0)
					throw(SQL, "SQLparser", "Xauto_commit (commit) failed");
				else if (!commit && mvc_rollback(m, 0, NULL) < 0)
					throw(SQL, "SQLparser", "Xauto_commit (rollback) failed");
			}
			in->pos = in->len;	/* HACK: should use parsed lenght */
			return NULL;
		}
		if( strncmp(in->buf+in->pos,"reply_size ", 11)==0 ){
			v= (int) strtol(in->buf+in->pos+11,NULL,10);
			m->reply_size = v;
			in->pos = in->len;	/* HACK: should use parsed lenght */
			return NULL;
		}
		if( strncmp(in->buf + in->pos,"quit",4)==0 ) {
			c->mode = FINISHING;
			return NULL;
		}
		throw(SQL, "SQLparser", "Unrecognized X command");
	} 
	if (be->language != 'S' ) {
		throw(SQL, "SQLparser", "Unrecognized language prefix");
	}

	if( be->mvc->mode== m_profile )
		T0 = GDKusec();

	if ((err = sqlparse(m)) && m->debug){
		/* switch to different language mode */
		char oldlang= be->language;
		be->language= 'D';
		runMALDebugger(c->curprg);
		be->language= oldlang;
	}
	if( err ||
	    /* Only forget old errors on transaction boundaries */
	    (mvc_status(m) && m->type != Q_TRANS) || !m->sym) {
		if (!err && m->scanner.started) /* repeat old errors, with a parsed query */
			err = mvc_status(m);
		if (err) {
			msg = createException(PARSE, "SQLparser", m->errstr);
			handle_error(m, c->fdout, pstatus);
		}
		sqlcleanup(m, err);
		goto finalize;
	}
@-
We have dealt with the first parsing step and advanced the input reader
to the next statement (if any).
Now is the time to also perform the semantic analysis, optimize and 
produce code.
@c
	be->q = NULL;
	if (m->mode == m_execute) {
		be->q = qc_find(m->qc, m->sym->data.lval->h->data.ival);
		if (!be->q) {
			err = -1;
			sql_error(m, 2, "no prepared statement with the given id\n");
			sqlcleanup(m, err);
			goto finalize;
		}
		m->mode = m_inplace;
	} else 
	if( (be->q = qc_match(m->qc, m->sym, m->args, m->argc, m->scanner.key))){
		if( m->mode == m_trace || m->explain == m_trace)
			SQLsetTimer(c, TRUE);
		if( m->mode == m_debug)
			SQLsetDebugger(c, m, m->mode == m_debug); 
		if( m->mode != m_debug  && m->mode!= m_explain && m->mode!= m_trace)
			m->mode = m_inplace;
	} else {
		stmt *s;

		s = sql_symbol2stmt(m, m->sym);

		if (s==0 || (err = mvc_status(m))) {
			msg = createException(PARSE, "SQLparser", m->errstr);
			handle_error(m, c->fdout, pstatus);
			sqlcleanup(m, err);
			goto finalize;
		}
		assert(s);
		/* generate and call the MAL code */
		if( m->explain == m_explain)
			SQLshowPlan(c);
		if( m->mode == m_trace || m->explain == m_trace)
			SQLsetTimer(c, TRUE);
		if( m->mode == m_debug)
			SQLsetDebugger(c, m, m->mode == m_debug); 
		if ((m->mode != m_inplace && m->mode != m_prepare && !m->cache && m->mode!= m_explain) || s->type == st_none){
			backend_callinline(be, c, s );
			if( m->mode == m_inplace)
				m->mode = m_normal; 
		} else {
			/* generate a factory instantiation */
			be->q = qc_insert(m->qc, 
					  m->sa,      /* the allocator */
					  m->sym,     /* the sql symbol tree */
					  m->args,    /* the argument list */
					  m->argc,
					  m->scanner.key,/* the statement hash key */
					  m->type,/* the type of the statement */
					  sql_escape_str(QUERY(m->scanner)));

			be->q->code = 
				(backend_code)backend_dumpproc(be, c, be->q, s);
			be->q->stk = 0;
			/* register name in the namespace */
			be->q->name = putName(be->q->name, strlen(be->q->name));
			if( m->mode == m_normal)
				m->mode = m_inplace; 
			m->sa = NULL;
			m->sym = NULL;
		} 
		stmt_destroy(s);
	}
#ifdef _SQL_PARSER_DEBUG
	else
		stream_printf(GDKout, "#parse result %d\n", err);
#endif
	if( be->q ){
		if (m->mode == m_prepare)
			err = mvc_export_prepare(m, c->fdout, be->q, "");
		else if (m->mode == m_inplace ){
			/* everything ready for a fast call */
		} else /* call procedure generation (only in cache mode) */
			backend_call(be, c, be->q);
	}

@-
In the final phase we add any debugging control
@c
	/* turn off debugger */
	if( m->mode == m_debug ) 
		SQLsetDebugger(c, m, FALSE);
	if( m->mode == m_trace )
		SQLsetTimer(c, FALSE);

	if (be->mvc->mode == m_profile ) {
		be->qry = sql_escape_str(QUERY(m->scanner));
		be->Tparse = GDKusec() - T0;
	}
	scanner_query_processed(&(m->scanner));

@-
During the execution of the query exceptions can be raised.
The default action is to print them out at the end of the
query block.
@c
	if (err == 0) {
		pushEndInstruction(c->curprg->def);

		chkTypes(c->nspace, c->curprg->def); /* resolve types */
		/* we know more in this case then
			chkProgram(c->nspace, c->curprg->def); */
		if (c->curprg->def->errors) {
			if( m->mode == m_debug){
				/* switch to differnt language mode */
				char oldlang= be->language;
				be->language= 'D';
				runMALDebugger(c->curprg);
				be->language= oldlang;
			}
			showErrors();
			/* restore the state */
			resetMalBlk(c->curprg->def, oldstop);
			freeVariables(c->curprg->def, c->glb, oldvtop);
			c->curprg->def->errors = 0;
			msg = createException(PARSE, "SQLparser", "Semantic errors");
		}
	}
@-
Inspect the variables for post code-generation actions.
@c
finalize:
	if(m->mode== m_explain  && be->q && be->q->code)
		printFunction(GDKout, ((Symbol)(be->q->code))->def, LIST_MAL_INSTR | LIST_MAL_PROPS);
	m->scanner.mode = oldmode;
@-
Gather the statistics for post analysis. It should preferably
be stored in an SQL table
@c
	if (msg)
		sqlcleanup(m, 0);
	return msg;
}

@-
Execution of the SQL program is delegated to the MALengine.
Different cases should be distinguished. The default is to
hand over the MAL block derived by the parser for execution.
However, when we received an Execute call, we make a shortcut
and prepare the stack for immediate execution
@c
str
SQLexecutePrepared(Client cntxt, backend *be, cq *q )
{
	mvc *c = be->mvc;
	int argc, parc; 
	ValPtr *argv, argvbuffer[MAXARG];
	ValRecord *argrec, argrecbuffer[MAXARG];
	MalBlkPtr mb;
	MalStkPtr glb;
	InstrPtr pci;
	int i;
	str ret;

#ifdef DEBUG_CALLMAL
	stream_printf(GDKout,"SQLexecute\n");
	printFunction(GDKout, ((Symbol)q->code)->def, LIST_MAL_ALL);
#endif
	mb = ((Symbol)q->code)->def;
	pci= getInstrPtr(mb,0);
	if( pci->argc >= MAXARG)
		argv= (ValPtr *) GDKmalloc(sizeof(ValPtr) * pci->argc);
	else argv= argvbuffer;

	if( pci->retc >= MAXARG)
		argrec= (ValRecord *)GDKmalloc(sizeof(ValRecord) * pci->retc);
	else argrec= argrecbuffer;

	/* prepare the target variables */
	for(i=0;i<pci->retc; i++){
		argv[i]= argrec+i;
		argv[i]->vtype= getVarGDKType(mb,i);
	}

	argc = c->argc;
	parc = q->paramlen;

	if (argc != parc) {
		if( pci->argc >= MAXARG)
			GDKfree(argv);
		if( pci->retc >= MAXARG)
			GDKfree(argrec);
		return GDKstrdup("wrong number of arguments for prepared statement\n");
	} else {
		for (i = 0; i<c->argc; i++){
			atom *arg = c->args[i];
			sql_subtype *pt = q->params+i;

			if (!atom_cast(arg, pt)) {
				char buf[BUFSIZ];

				snprintf(buf, BUFSIZ, "wrong argument for prepared statement (expected %s instead of %s)\n", pt->type->sqlname, atom_type(arg)->type->sqlname);
				/*sql_error(c, 003, buf); */
				if( pci->argc >= MAXARG)
					GDKfree(argv);
				if( pci->retc >= MAXARG)
						GDKfree(argrec);
				return _strdup(buf);
			}
			argv[pci->retc+i]= &arg->data;
		}
	}
	glb = (MalStkPtr)(q->stk);
	ret= callMAL(cntxt,mb, &glb, argv, (c->mode == m_debug?'n':0));
	q->stk = (backend_stack)glb;
	if( pci->argc >= MAXARG)
		GDKfree(argv);
	if( pci->retc >= MAXARG)
		GDKfree(argrec);
	return ret;
}

str 
backend_profile( backend *be, char *query, lng parse, lng optimize, lng exec, lng total )
{
	int ret;
	str msg = NULL;
	mvc *c = be->mvc;
	modes_t mode = c->mode;
	modes_t explain = c->explain;
	char *q = query;

	char buf[BUFSIZ], *stmt = buf;

	/* ltrim query */
	while(isspace((int)(*q))) 
		q++;

	/* TODO use sql_prepare/execute */
	snprintf(buf, BUFSIZ, "INSERT INTO \"profile\" "
		 "VALUES(now,'%s',"LLFMT","LLFMT","LLFMT","LLFMT",USER);\n",
		 q, parse, optimize, exec, total);
	_DELETE(query);

	/* switch of explain to prevent recursion */
	c->mode = m_normal;
	c->explain = m_normal;
	msg = SQLstatement(&ret, &stmt);
	(void)ret;
	c->mode = mode;
	c->explain = explain;
	be->Tparse= be->Toptimize = be->Tschedule = be->Texec = 0;
	return msg;
}

str SQLrecompile(Client c, backend *be);

str
SQLengineIntern(Client c, backend *be) 
{
	str msg = MAL_SUCCEED;
	MalStkPtr oldglb = c->glb;
	char oldlang= be->language;
	mvc *m = be->mvc;
	lng T0=0;
	InstrPtr p;
	MalBlkPtr mb;

	if ( oldlang == 'X'){ 	/* return directly from X-commands */
		sqlcleanup(be->mvc, 0);
		return MAL_SUCCEED;
	}

	if (m->mode == m_explain) {
		sqlcleanup(be->mvc, 0);
		goto cleanup_engine;
	}
	if (c->curprg->def->errors){
		sqlcleanup(be->mvc, 0);
		throw(SQL, "SQLengine", "Program contains errors");
	}
#ifdef SQL_SCENARIO_DEBUG
	stream_printf(GDKout, "#Ready to execute SQL statement\n");
#endif

	if( c->curprg->def->stop == 1 ){
		sqlcleanup(be->mvc, 0);
		return MAL_SUCCEED;
	}
	if( m->mode == m_profile)
		T0 = GDKusec();
	if (m->mode == m_inplace) {
		msg= SQLexecutePrepared(c, be, be->q );
		goto cleanup_engine;
	}
	if( m->mode == m_prepare){
		goto cleanup_engine;
	} else if( m->mode == m_explain ){
@-
If you want to see the detailed code, we have to pick it up from
the cache as well. This calls for finding the call to the
cached routine, which may be hidden . For now we take a shortcut.
@c
		if( be->q) {
			InstrPtr p;
			p = getInstrPtr(c->curprg->def,1);
			if( p->blk)
				printFunction(c->fdout, p->blk, c->listing);

		}
		c->curprg->def->errors = -1; /* don;t execute */
	} 
	c->glb = 0;
	be->language= 'D';
@-
The code below is copied from MALengine, which handles execution
in the context of a user global environment. We have a private
environment.
@c
	if( MALcommentsOnly(c->curprg->def)) {
		msg= MAL_SUCCEED;
	} else {
		msg = (str) runMAL(c, c->curprg->def, 1, 0, 0, 0);
	}

cleanup_engine:
	if (msg) {
		if (getExceptionType(msg) == OPTIMIZER) {
			resetMalBlk( c->curprg->def, 1);
			/* resetInstructions(c->curprg->def, 1);*/
			freeVariables(c->curprg->def, c->glb, be->vtop);
			be->language = oldlang;
			c->glb = oldglb;
			return SQLrecompile(c, be);
		} else {
			str p = getExceptionPlace(msg);
			showException(getExceptionType(msg), p, getExceptionMessage(msg));
			GDKfree(p);
		}
		showErrors();
		m->session->status = -10;
	}
@-
If we are dealing with a {runonce} plan, the query cache should
be adjusted too.
@c
/* postpone */

	mb= c->curprg->def;
	if( be->q && mb &&
		fndArgProperty(mb, (p= getInstrPtr(mb,0)),0,putName("runonce",7)) ){
		SQLCacheRemove(c, getFunctionId(p));
		/* this should invalidate any match */
		be->q->key= -1;
		be->q->paramlen = -1;
		/* qc_delete(be->q) */
	}
	be->q = NULL;
	sqlcleanup(be->mvc, 0);
	resetMalBlk( c->curprg->def, 1);
	/* resetInstructions(c->curprg->def, 1);*/
	freeVariables(c->curprg->def, c->glb, be->vtop);
	be->language = oldlang;
@-
Any error encountered during execution should block further processing
unless auto_commit has been set.
@c
	c->glb = oldglb;
	if (m->mode== m_profile) {
		lng tot = be->Tparse; 

		tot += be->Texec = GDKusec() - T0;
		msg = backend_profile(be, be->qry, be->Tparse-be->Toptimize, be->Toptimize, be->Texec, tot);
		be->qry = NULL;
	}

	return msg;
}

str
SQLrecompile(Client c, backend *be) 
{
	stmt *s;
	mvc *m = be->mvc;
	int oldvtop = c->curprg->def->vtop;
	int oldstop = c->curprg->def->stop;

	SQLCacheRemove(c, be->q->name);
	s = sql_symbol2stmt(m, be->q->s);
	be->q->code = (backend_code)backend_dumpproc(be, c, be->q, s);
	be->q->stk = 0;
	stmt_destroy(s);

	pushEndInstruction(c->curprg->def);

	chkTypes(c->nspace, c->curprg->def); /* resolve types */
	if (c->curprg->def->errors) {
		showErrors();
		/* restore the state */
		resetMalBlk(c->curprg->def, oldstop);
		freeVariables(c->curprg->def, c->glb, oldvtop);
		c->curprg->def->errors = 0;
		throw(SQL, "SQLrecompile", "Semantic errors");
	}
	return SQLengineIntern(c, be);
}

str
SQLengine(Client c)
{
	backend *be = ((backend *) c->state[MAL_SCENARIO_PARSER]);
	return SQLengineIntern(c, be);
}

@-
Assertion errors detected during the execution of a code block
raises an exception.
@c
str
SQLassert(int *ret, bit *flg, str *msg)
{
	(void) ret;
	if (*flg)
		throw(SQL, "assert", *msg);
	return MAL_SUCCEED;
}

str
SQLassertInt(int *ret, int *flg, str *msg)
{
	(void) ret;
	if (*flg)
		throw(SQL, "assert", *msg);
	return MAL_SUCCEED;
}

str
SQLassertLng(int *ret, lng *flg, str *msg)
{
	(void) ret;
	if (*flg)
		throw(SQL, "assert", *msg);
	return MAL_SUCCEED;
}

str
SQLCacheRemove(Client c, str nme)
{
	Symbol s;

#ifdef _SQL_CACHE_DEBUG
	stream_printf(GDKout, "SQLCacheRemove %s\n", nme);
#endif

	s= findSymbolInModule(c->nspace, nme);
	if (s == NULL)
		throw(MAL, "cache.remove", "internal error, symbol missing\n");
	if( getInstrPtr(s->def,0)->token == FACTORYsymbol)
		shutdownFactoryByName(c->nspace, nme);
	else
		deleteSymbol(c->nspace,s);
	return MAL_SUCCEED;
}
