@/
The contents of this file are subject to the MonetDB Public License
Version 1.1 (the "License"); you may not use this file except in
compliance with the License. You may obtain a copy of the License at
http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
 
Software distributed under the License is distributed on an "AS IS"
basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations
under the License.
 
The Original Code is the MonetDB Database System.

The Initial Developer of the Original Code is CWI.
Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
Copyright August 2008-2010 MonetDB B.V.
All Rights Reserved.
@

@f mseed
@a Martin Kersten
@v 0.1
@+ Mseed
These routines are meant to interpret mseed files stored in the vault.
The simplifying situation is that mseed has a single model.
The code base assumes that libmseed has been installed on your system.

The mseed catalog initialization script should have been run.
@begin verbatim
-- this schema is intended to experiment with accessing mseed files
drop FUNCTION mseedImport();
drop table mseedCatalog;
drop table mseedRepository;

-- all records in the mseed files correspond to a row in the catalog
CREATE TABLE mseedCatalog (
mseed			int, 			-- Vault file id
chunk			varchar(255),	-- SQL volumn storage container name
seqno			int,			-- SEED record sequence number, should be between 0 and 999999
		 PRIMARY KEY (mseed,seqno),
dataquality 	char,			-- Data record indicator, should be 'D=data unknown qual', 
								-- 'R=raw no quality', 'Q= quality controlled' or 'M'
network			varchar(11),	-- Network
station			varchar(11),	-- Station
location		varchar(11),	-- Location
channel			varchar(11),	-- Channel
starttime 		timestamp,		-- Record start time, the time of the first sample, as a high precision epoch time 
samplerate		double,			-- Nominal sample rate (Hz) 
samplecnt		int,			-- Number of samples in record 
sampletype		string,			-- storage type in mseed record
minval			float,			-- statistics for search later
maxval			float
); 

-- this function inserts the mseed record information into the catalog
-- errors are returned for off-line analysis.
CREATE FUNCTION mseedImport(vid int, source string, target string)
	RETURNS string
EXTERNAL NAME mseed.import;

-- mseed data volumns may appear in different formats
-- we try to postpone them, assuming the optimizer can guide JIT.
--CREATE TABLE chunkname (
--time	timestamp,
--mseed	int,
--adata	varchar(20),	dependent on type
--idata	int,
--fdata	float,
--ddata	double
--); 
@end verbatim

@- How to use the mseed catalog.
First, the vault directory is populated with the location of the mseed source files
in a remote site. The corresponding local name is set using the basename property,
and all files creation and access times are set to null.
Following, a limited number of files are loaded into the vault and analysed.
The information extracted ends up in the catalog, and remains there forever.
The underlying mseed file is not decrypted directly, it will be done as soon
as a query requests its.

A test sequence (after the vault director has been populated)
@begin verbatim
create table batch(vid int, source string, target string);


insert into batch
select vid, source, target from vault where created is null limit 2;
call batchload( select vid, source, target from vault where created is null limit 2);
drop table batch;
@end verbatim

@mal
module mseed;
pattern import(vid:int, source:str, target:str):str
address MseedImport
comment "Dump the record content of an mseed file from the vault into the mseed catalog";

@-
The intended use is to simply rely on SQL to select elements
in the vault table for import and to apply the mseed import operation.
It returns the id list of succesful imports.
@verbatim
select mseedImport(vid,source,target) from vault where ...
@end verbatim
@{
@h
#ifndef _MSEED_H
#define _MSEED_H

#include "sql_config.h"
#include "clients.h"
#include "mal.h" 
#include "mal_client.h"
#include "mal_interpreter.h"
#include "mal_function.h"
#include "libmseed.h"

#ifdef WIN32
#ifndef LIBMSEED
#define vault_export extern __declspec(dllimport)
#else
#define vault_export extern __declspec(dllexport)
#endif
#else
#define vault_export extern
#endif

vault_export str MseedImport(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);

#define _MSEED_DEBUG_

#endif /* _MSEED_H */
@c
#include "mseed.h"
#include "vault.h"
str SQLstatementIntern(Client c, str *expr, str nme, int execute, bit output);

#define QRYinsert "INSERT INTO mseedCatalog(mseed, seqno, dataquality, network, \
	 station, location, channel, starttime , samplerate, samplecnt, sampletype) \
	 VALUES(%d, %d,'%c','%s', '%s','%s','%s','%s',%f,%d,%s);"

str
MseedImport(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	str *ret = (str*) getArgReference(stk,pci,0); 
	str msg = MAL_SUCCEED;
	int *vid = (int*) getArgReference(stk,pci,1); 
	str *sourcefile = (str*) getArgReference(stk,pci,2); 
	str *targetfile = (str*) getArgReference(stk,pci,3); 
	MSRecord *msr = 0;

	int verbose   = 1;
	//int ppackets  = 2;
	int reclen    = -1;
	int dataflag  = 1;
	int totalrecs = 0;
	int totalsamps = 0;
	int retcode;
	int j;
	time_t t;
	struct tm *tm;
	char *s, *kind;
	timestamp answ;
	char file[BUFSIZ];
	char buf[BUFSIZ];
	char starttime[BUFSIZ];
	char stoptime[BUFSIZ];
	int stepsize;

	(void) mb;

	if ( strcmp(*sourcefile, *targetfile) ) {
		if ( vaultpath[0] == 0){
			msg= createException(MAL,"mseed.dump","Vault not initialized");
			*ret = GDKstrdup(msg);
			return msg;
		}
		snprintf(file,BUFSIZ,"%s%c%s",vaultpath, DIR_SEP,*targetfile);

		/* only fetch the file if it is not already in the local vault */
		if ( access(file, R_OK) ){
			mnstr_printf(cntxt->fdout, "FTP fetch %s -> %s\n",*sourcefile,file);
			msg= VLTimport(&answ, sourcefile, targetfile);
			if ( msg)
				return msg;
			/* remember the location of the copy */
			s= buf;
			snprintf(buf,BUFSIZ,"UPDATE vault SET created=now() WHERE vid = %d;", *vid);
			msg =SQLstatementIntern(cntxt,&s,"mseed.import file",TRUE,FALSE);
			if ( msg)
				return msg;
		}
	} else 
		/* no caching  needed or allowed */
		snprintf(file,BUFSIZ,"%s",*targetfile);

	/* Loop over the input file */
	s= buf;
	while ( (retcode = ms_readmsr (&msr, file, reclen, NULL, NULL, 1, dataflag, verbose)) == MS_NOERROR )
	{
		totalrecs++;
		totalsamps += msr->samplecnt;
		//msr_print(msr, ppackets);

		t= MS_HPTIME2EPOCH(msr->starttime);
		tm = gmtime(&t);
		snprintf(starttime,BUFSIZ,"%d-%02d-%02d %02d:%02d:%02d.%06ld", tm->tm_year +(tm->tm_year > 80?1900:2000), tm->tm_mon+1,tm->tm_mday, tm->tm_hour, tm->tm_min,tm->tm_sec, msr->starttime % HPTMODULUS);

		switch(msr->sampletype){
			case 'a': kind="'string'"; break;
			case 'i': kind="'int'"; break;
			case 'f': kind="'flt'"; break;
			case 'd': kind="'dbl'"; break;
			default : kind="null";
		}
		snprintf(buf,BUFSIZ,QRYinsert, *vid, msr->sequence_number,msr->dataquality,msr->network, msr->station, msr->location, msr->channel,
		starttime,msr->samprate, msr->samplecnt,kind);
		printf("%s\n",buf);
		msg =SQLstatementIntern(cntxt,&s,"mseed.import",TRUE,FALSE);
		if ( msg != MAL_SUCCEED){
			break;
		}

		stepsize = 1000000/ msr->samprate;
		if (msr->samplecnt) {
			/* calculate end of series */
			msr->starttime += msr->samplecnt * stepsize;
			t= MS_HPTIME2EPOCH(msr->starttime);
			tm = gmtime(&t);
			snprintf(stoptime,BUFSIZ,"%d-%02d-%02d %02d:%02d:%02d.%06ld", tm->tm_year +(tm->tm_year > 80?1900:2000), tm->tm_mon+1,tm->tm_mday, tm->tm_hour, tm->tm_min,tm->tm_sec, msr->starttime % HPTMODULUS);
			printf("%s\n",stoptime);
		}
		if (msr->datasamples)
		for ( j=0;j< msr->samplecnt; j++){
			t= MS_HPTIME2EPOCH(msr->starttime);
			tm = gmtime(&t);
			snprintf(stoptime,BUFSIZ,"%d-%02d-%02d %02d:%02d:%02d.%06ld", tm->tm_year +(tm->tm_year > 80?1900:2000), tm->tm_mon+1,tm->tm_mday, tm->tm_hour, tm->tm_min,tm->tm_sec, msr->starttime % HPTMODULUS);
			msr->starttime += stepsize;
			switch(msr->sampletype){
			case 'a':
				snprintf(buf,BUFSIZ, "INSERT INTO mseedVolumn(time,adata) VALUES (%s, %d,%s);", stoptime, *vid, ((char**) msr->datasamples)[j]);
				break;
			case 'i':
				snprintf(buf,BUFSIZ, "INSERT INTO mseedVolumn(time,idata) VALUES (%s, %d,%d);", stoptime, *vid, ((int*) msr->datasamples)[j]);
				break;
			case 'f':
				snprintf(buf,BUFSIZ, "INSERT INTO mseedVolumn(time,fdata) VALUES (%s, %d,%f);", stoptime, *vid, ((flt*) msr->datasamples)[j]);
				break;
			case 'd':
				snprintf(buf,BUFSIZ, "INSERT INTO mseedVolumn(time,ddata) VALUES (%s, %d,%f);", stoptime, *vid, ((dbl*) msr->datasamples)[j]);
				break;
			default:
				snprintf(buf,BUFSIZ,"undef %d",msr->encoding);
			}
			printf("%s\n",buf);
		}
	}

	if ( msg== MAL_SUCCEED && retcode != MS_ENDOFFILE )
		msg = createException(MAL, "mseed.dump", "Cannot read %s: %s\n", file, ms_errorstr(retcode));

	/* Make sure everything is cleaned up */
	ms_readmsr (&msr, NULL, 0, NULL, NULL, 0, 0, 0);
	if (msg )
		*ret= GDKstrdup(msg);
	else *ret= 0;
	return msg;
}  

@}
