@/
The contents of this file are subject to the MonetDB Public License
Version 1.1 (the "License"); you may not use this file except in
compliance with the License. You may obtain a copy of the License at
http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
 
Software distributed under the License is distributed on an "AS IS"
basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations
under the License.
 
The Original Code is the MonetDB Database System.

The Initial Developer of the Original Code is CWI.
Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
Copyright August 2008-2010 MonetDB B.V.
All Rights Reserved.
@

@f mseed
@a Martin Kersten
@v 0.1
@+ Mseed
These routines are meant to interpret mseed files stored in the vault.
The simplifying situation is that mseed has a single model.
The code base assumes that libmseed has been installed on your system.

The mseed catalog initialization script should have been run.
@begin verbatim
-- this schema is intended to experiment with accessing mseed files
drop FUNCTION mseedImport();
drop table mseedCatalog;
drop table mseedRepository;

-- all records in the mseed files correspond to a row in the catalog
CREATE TABLE mseedCatalog (
mseed			int, 			-- Vault file id
seqno			int,			-- SEED record sequence number, should be between 0 and 999999
		 PRIMARY KEY (mseed,seqno),
dataquality 	char,			-- Data record indicator, should be 'D=data unknown qual', 
								-- 'R=raw no quality', 'Q= quality controlled' or 'M'
network			varchar(11),	-- Network
station			varchar(11),	-- Station
location		varchar(11),	-- Location
channel			varchar(11),	-- Channel
starttime 		timestamp,		-- Record start time, the time of the first sample, as a high precision epoch time 
samplerate		double,			-- Nominal sample rate (Hz) 
samplecnt		int,			-- Number of samples in record 
sampletype		string,			-- storage type in mseed record
minval			float,			-- statistics for search later
maxval			float
); 

-- this function inserts the mseed record information into the catalog
-- errors are returned for off-line analysis.
CREATE PROCEDURE mseedImport(vid int, source string, target string)
EXTERNAL NAME mseed.import;

-- The records are collected in SQL tables of the following structure
-- The are ordered on timestamp
--CREATE TABLE chunk<mseed> (
--time	timestamp,
--data	int (or float,double,varchar(20),	dependent on type
--); 
@end verbatim

@- How to use the mseed catalog.
First, the vault directory is populated with the location of the mseed source files
in a remote site. The corresponding local name is set using the basename property,
and all files creation and access times are set to null.
Following, a limited number of files are loaded into the vault and analysed.
The information extracted ends up in the catalog, and remains there forever.
The underlying mseed file is not decrypted directly, it will be done as soon
as a query requests its.

A test sequence (after the vault director has been populated)
@begin verbatim
create table batch(vid int, source string, target string);

insert into batch
select vid, source, target from vault where created is null limit 2;
call mseedImport( (select vid, source, target from vault where created is null limit 2) );
drop table batch;
@end verbatim

@mal
module mseed;
pattern import{unsafe}(vid:int, source:str, target:str)
address MseedImport
comment "Dump the record content of an mseed file from the vault into the mseed catalog";

@{
@-
Performance experimentation on eir on 17 dec 2010.
The code base uses the SQLstatementIntern to populate both the catalog and the mseed files.
Experiment 0 concerns loading the mseedN file using a sequence of inserts. This involves
the complete code path from generating SQL statement, parsing, optimization and execution.
No query caching is enabled. The first record from
ftp://www.orfeus-eu.org/pub/data/POND/1990/002/MN_BNI__BHN.1990.002.20.21.32.mseed
with 3768 events was loaded in 10.770 msec

The second experiment produced a copy file, separately loaded into MonetDB using
copy 400000 records into mseed2 from '/tmp/input/' delimiters ',','\n';
this track leads to a load time of 326ms for the first record.
The first file with 26 records and 97592 tuples was loaded this way within 8710 msec.
This approach still uses the SQL logger. The expected speedup for direct update would
be something like a factor 3.

The third experiment produced the single binary BAT images followed by
copy into mseed2 from ('/tmp/time','/tmp/data');
Attach procedure for complete file ran in about 232 ms.


@h
#ifndef _MSEED_H
#define _MSEED_H

#include "sql_config.h"
#include "clients.h"
#include "mal.h" 
#include "mal_client.h"
#include "mal_interpreter.h"
#include "mal_function.h"
#include "libmseed.h"

#ifdef WIN32
#ifndef LIBMSEED
#define vault_export extern __declspec(dllimport)
#else
#define vault_export extern __declspec(dllexport)
#endif
#else
#define vault_export extern
#endif

vault_export str MseedImport(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);

#define _MSEED_DEBUG_

#endif /* _MSEED_H */
@c
#include "mseed.h"
#include "vault.h"

#define EXPERIMENT0 0
#define EXPERIMENT1 0
#define EXPERIMENT2 2

str SQLstatementIntern(Client c, str *expr, str nme, int execute, bit output);

#define QRYinsertI "INSERT INTO mseedCatalog(mseed, seqno, dataquality, network, \
	 station, location, channel, starttime , samplerate, samplecnt, sampletype, minval,maxval) \
	 VALUES(%d, %d,'%c','%s', '%s','%s','%s','%s',%f,%d,%s,%d,%d);"

str
MseedImport(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	str msg = MAL_SUCCEED;
	int *vid = (int*) getArgReference(stk,pci,1); 
	str *sourcefile = (str*) getArgReference(stk,pci,2); 
	str *targetfile = (str*) getArgReference(stk,pci,3); 
	MSRecord *msr = 0;

	int verbose   = 1;
	//int ppackets  = 2;
	int reclen    = -1;
	int dataflag  = 1;
	int totalrecs = 0;
	int totalsamps = 0;
	int retcode;
	int j;
	time_t t;
	struct tm *tm;
	char *s, *kind;
	timestamp answ;
	char file[BUFSIZ];
	char buf[BUFSIZ];
	char starttime[BUFSIZ];
	char stoptime[BUFSIZ];
	int stepsize;
	int imin,imax;
	int nobat=0;
	FILE *data=0, *time=0;

	(void) mb;

	if ( strcmp(*sourcefile, *targetfile) ) {
		if ( vaultpath[0] == 0){
			msg= createException(MAL,"mseed.dump","Vault not initialized");
			return msg;
		}
		snprintf(file,BUFSIZ,"%s%c%s",vaultpath, DIR_SEP,*targetfile);

		/* only fetch the file if it is not already in the local vault */
		if ( access(file, R_OK) ){
			mnstr_printf(cntxt->fdout, "#FTP fetch %s -> %s\n",*sourcefile,file);
			msg= VLTimport(&answ, sourcefile, targetfile);
			if ( msg)
				return msg;
			/* remember the location of the copy */
			s= buf;
			snprintf(buf,BUFSIZ,"UPDATE vault SET created=now() WHERE vid = %d;", *vid);
			msg =SQLstatementIntern(cntxt,&s,"mseed.import file",TRUE,FALSE);
			if ( msg)
				return msg;
		}
	} else 
		/* no caching  needed or allowed */
		snprintf(file,BUFSIZ,"%s",*targetfile);

	/* Loop over the input file */
	s= buf;
	while ( (retcode = ms_readmsr (&msr, file, reclen, NULL, NULL, 1, dataflag, verbose)) == MS_NOERROR  )
	{
		totalrecs++;
		totalsamps += msr->samplecnt;
		//msr_print(msr, ppackets);

		t= MS_HPTIME2EPOCH(msr->starttime);
		tm = gmtime(&t);
		snprintf(starttime,BUFSIZ,"%d-%02d-%02d %02d:%02d:%02d.%06ld", tm->tm_year +(tm->tm_year > 80?1900:2000), tm->tm_mon+1,tm->tm_mday, tm->tm_hour, tm->tm_min,tm->tm_sec, msr->starttime % HPTMODULUS);

		switch(msr->sampletype){
			case 'a': kind="'string'"; break;
			case 'i': kind="'int'"; imin= int_nil; imax= int_nil; break;
			case 'f': kind="'flt'"; break;
			case 'd': kind="'dbl'"; break;
			default : kind="null";
		}
		if ( nobat==0 ){
			snprintf(buf,BUFSIZ,"CREATE TABLE sys.mseed%d(time timestamp, data int);",*vid);
			msg =SQLstatementIntern(cntxt,&s,"mseed.import file",TRUE,FALSE);
			if ( msg)
				return msg;
		}
		if ( EXPERIMENT1 )
			data = fopen("/tmp/data","w");
		if ( EXPERIMENT2  && nobat == 0){
			snprintf(buf, BUFSIZ, "%s/time",vaultpath);
			time = fopen(buf,"w");
			if ( time == 0)
				throw(MAL,"mseed.import",RUNTIME_CREATE_ERROR);
			snprintf(buf, BUFSIZ, "%s/data",vaultpath);
			data = fopen(buf,"w");
			if ( data == 0)
				throw(MAL,"mseed.import",RUNTIME_CREATE_ERROR);
		}
		nobat++;

		if (msr->datasamples)
		for ( j=0;j< msr->samplecnt; j++){
			t= MS_HPTIME2EPOCH(msr->starttime);
			tm = gmtime(&t);
			snprintf(stoptime,BUFSIZ,"%d-%02d-%02d %02d:%02d:%02d.%06ld", tm->tm_year +(tm->tm_year > 80?1900:2000), tm->tm_mon+1,tm->tm_mday, tm->tm_hour, tm->tm_min,tm->tm_sec, msr->starttime % HPTMODULUS);
			msr->starttime += stepsize;
			switch(msr->sampletype){
			case 'a':
				if ( EXPERIMENT0 )
					snprintf(buf,BUFSIZ, "INSERT INTO mseed%d(time,adata) VALUES (timestamp '%s', %s);", *vid, stoptime, ((char**) msr->datasamples)[j]);
				if ( EXPERIMENT1 )
					snprintf(buf,BUFSIZ, "%s, %s", stoptime, ((char**) msr->datasamples)[j]);
				break;
			case 'i':
				if ( EXPERIMENT0 )
					snprintf(buf,BUFSIZ, "INSERT INTO mseed%d(time,data) VALUES (timestamp '%s', %d);", *vid, stoptime, ((int*) msr->datasamples)[j]);
				if ( EXPERIMENT1 )
					snprintf(buf,BUFSIZ, "%s, %d", stoptime, ((int*) msr->datasamples)[j]);

				if ( EXPERIMENT2 ){
					fwrite((char*) &tm, sizeof(timestamp), 1, time);
					fwrite( (char*) &((int*) msr->datasamples)[j], sizeof(int), 1, data);
				}
				if ( imin == int_nil || imin > ((int*) msr->datasamples)[j]) imin = ((int*) msr->datasamples)[j];
				if ( imax == int_nil || imax < ((int*) msr->datasamples)[j]) imax = ((int*) msr->datasamples)[j];
				break;
			case 'f':
				if ( EXPERIMENT0 )
					snprintf(buf,BUFSIZ, "INSERT INTO mseed%d(time,fdata) VALUES (timestamp '%s', %f);", *vid, stoptime, ((flt*) msr->datasamples)[j]);
				if ( EXPERIMENT1 )
					snprintf(buf,BUFSIZ, "%s, %f", stoptime, ((flt*) msr->datasamples)[j]);
				break;
			case 'd':
				if ( EXPERIMENT0 )
					snprintf(buf,BUFSIZ, "INSERT INTO mseed%d(time,ddata) VALUES ( timestamp '%s', %f);", *vid, stoptime, ((dbl*) msr->datasamples)[j]);
				if ( EXPERIMENT1 )
					snprintf(buf,BUFSIZ, "%s, %f", stoptime, ((dbl*) msr->datasamples)[j]);
				break;
			default:
				snprintf(buf,BUFSIZ,"undef %d",msr->encoding);
			}
			if ( EXPERIMENT1 )
				fprintf(data,"%s\n",buf);
			if ( EXPERIMENT0 ){
				msg =SQLstatementIntern(cntxt,&s,"mseed.import",TRUE,FALSE);
				if ( msg != MAL_SUCCEED)
					break;
			}
		}
		switch(msr->sampletype){
			case 'a': kind="'string'"; break;
			case 'i': 
				snprintf(buf,BUFSIZ,QRYinsertI, *vid, msr->sequence_number,msr->dataquality,msr->network, msr->station, msr->location, msr->channel,
				starttime,msr->samprate, msr->samplecnt,kind,imin,imax);
				break;
			case 'f': kind="'flt'"; break;
			case 'd': kind="'dbl'"; break;
			default : kind="null";
		}

		msg =SQLstatementIntern(cntxt,&s,"mseed.import",TRUE,FALSE);
		if ( msg != MAL_SUCCEED){
			break;
		}

		stepsize = 1000000/ msr->samprate;
		if (msr->samplecnt) {
			/* calculate end of series */
			msr->starttime += msr->samplecnt * stepsize;
			t= MS_HPTIME2EPOCH(msr->starttime);
			tm = gmtime(&t);
			snprintf(stoptime,BUFSIZ,"%d-%02d-%02d %02d:%02d:%02d.%06ld", tm->tm_year +(tm->tm_year > 80?1900:2000), tm->tm_mon+1,tm->tm_mday, tm->tm_hour, tm->tm_min,tm->tm_sec, msr->starttime % HPTMODULUS);
		}
		if(EXPERIMENT0 && nobat) {
			retcode = MS_ENDOFFILE;
			break;
		}

		if ( EXPERIMENT1){
			if( data) fclose(data);
			data = 0;
			strcpy(buf,"copy 400000 records into mseed2 from '/tmp/data' delimiters ',','\n';");
			msg =SQLstatementIntern(cntxt,&s,"mseed.import",TRUE,FALSE);
		}
	}
	if ( EXPERIMENT2){
		if( data) fclose(data);
		if( time) fclose(time);
		data = 0;
		time = 0;
		snprintf(buf,BUFSIZ,"copy into mseed2 from ('%s/time','%s/data');",vaultpath,vaultpath);
		msg =SQLstatementIntern(cntxt,&s,"mseed.import",TRUE,FALSE);
	}

	if ( msg== MAL_SUCCEED && retcode != MS_ENDOFFILE )
		msg = createException(MAL, "mseed.dump", "Cannot read %s: %s\n", file, ms_errorstr(retcode));
	else if ( msg == MAL_SUCCEED){
		strcpy(buf,"commit;");
		msg =SQLstatementIntern(cntxt,&s,"mseed.import",TRUE,FALSE);
	}

	/* Make sure everything is cleaned up */
	ms_readmsr (&msr, NULL, 0, NULL, NULL, 0, 0, 0);
	return msg;
}  

@}
