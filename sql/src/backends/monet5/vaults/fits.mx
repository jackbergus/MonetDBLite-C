@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
@' Copyright August 2008-2010 MonetDB B.V.
@' All Rights Reserved.

@a M. Ivanova, M. Kersten, N. Nes
@f fits
@- This module contains primitives for accessing data in FITS file format.

@{
@-
@mal
module fits;

command fitstest(filename:str):int
address FITStest
comment "Returns the type of first extension in the FITS file filename";

pattern attach(fname :str):void
address FITSattach
comment "Open a FITS file and return catalog of the table HDUs";


@h
#ifndef _FITS_
#define _FITS_
#undef htype
#undef ttype
#include "fitsio.h"
#include "fitsio2.h"
#include "longnam.h"
#include "sql_config.h"
#include <sql_mvc.h>
#include <sql.h>
#include "clients.h"
#include "mal.h" 
#include "mal_client.h"
#include "mal_exception.h" 

#ifdef WIN32
#ifndef LIBFITS
#define fits_export extern __declspec(dllimport)
#else
#define fits_export extern __declspec(dllexport)
#endif
#else
#define fits_export extern
#endif

fits_export str FITStest(int *res, str *fname);
fits_export str FITSattach(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
#endif

@-

@c
#include "fits.h"

str
FITStest(int *res, str *fname)
{
    fitsfile *fptr;       /* pointer to the FITS file, defined in fitsio.h */
	str msg = MAL_SUCCEED;
    int status = 0, hdutype;

    *res = 0;
    if ( fits_open_file(&fptr, *fname, READONLY, &status) )
       	msg = createException(MAL, "fits.test", "Missing FITS file %s", fname);
	else {
	    fits_movabs_hdu(fptr, 2, &hdutype, &status);
		*res = hdutype;
    	fits_close_file(fptr, &status);
	}

    return msg;
}

static void
FITSinitCatalog(mvc *m)
{
	sql_schema *sch;
	sql_table *fits_fl, *fits_tbl,  *fits_col;
	
	sch = mvc_bind_schema(m,"sys");

	fits_fl = mvc_bind_table(m, sch, "fits_files");
	if ( fits_fl == NULL ){
		fits_fl = mvc_create_table(m, sch, "fits_files", tt_table, 0, SQL_PERSIST, 0, 2);
		mvc_create_column_(m, fits_fl, "id","int",32);
		mvc_create_column_(m, fits_fl, "name","varchar",80);
	}

	fits_tbl = mvc_bind_table(m, sch, "fits_tables");
	if ( fits_tbl == NULL ){
		fits_tbl = mvc_create_table(m, sch, "fits_tables", tt_table, 0, SQL_PERSIST, 0, 4);
		mvc_create_column_(m, fits_tbl, "id","int",32);
		mvc_create_column_(m, fits_tbl, "name","varchar",80);
		mvc_create_column_(m, fits_tbl, "file_id","int",32);
		mvc_create_column_(m, fits_tbl, "hdu","int",32);
	}

	fits_col = mvc_bind_table(m, sch, "fits_columns");
	if ( fits_col == NULL ){
		fits_col = mvc_create_table(m, sch, "fits_columns", tt_table, 0, SQL_PERSIST, 0, 6);
		mvc_create_column_(m, fits_col, "id","int",32);
		mvc_create_column_(m, fits_col, "name","varchar",80);
		mvc_create_column_(m, fits_col, "type","varchar",80);
		mvc_create_column_(m, fits_col, "mtype","int",32);
		mvc_create_column_(m, fits_col, "table_id","int",32);
		mvc_create_column_(m, fits_col, "units","varchar",10);
	}
	
}   

static int
fits2mtype( int t )
{
    printf("%d\n", t );
    switch(t) {
    case TBIT:
    case TLOGICAL:
        return TYPE_bit;
    case TBYTE:
    case TSBYTE:
        return TYPE_chr;
    case TSTRING:
        return TYPE_str;
    case TUSHORT:
    case TSHORT:
        return TYPE_sht;
    case TUINT:
    case TINT:
    case TULONG:
    case TLONG:
        return TYPE_int;
    case TLONGLONG:
        return TYPE_lng;
    case TFLOAT:
        return TYPE_flt;
    case TDOUBLE:
        return TYPE_dbl;
    /* missing */
    case TCOMPLEX:
    case TDBLCOMPLEX:
        return -1;
    }
    return -1;
}

str FITSattach(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	mvc *m = NULL;
	sql_schema *sch;
	sql_table *fits_fl, *fits_tbl, *fits_col, *tbl = NULL;
	sql_column *col;
	str msg = MAL_SUCCEED; 
	str fname = *(str*) getArgReference(stk, pci, 1);
	fitsfile *fptr;  /* pointer to the FITS file */
	int status = 0, i, j, hdutype, hdunum = 1, cnum = 0;
	int tpcode = 0, mtype;
	oid  fid, tid, rid = oid_nil;
	char tname[BUFSIZ];
	long tbcol, rep, wid;
    char cname[BUFSIZ], tform[BUFSIZ], tunit[BUFSIZ], tnull[BUFSIZ], tdisp[BUFSIZ];
	double tscal, tzero;
	

	
	msg = getContext(cntxt, mb, &m, NULL);
	if (msg)
		return msg;

    if ( fits_open_file(&fptr, fname, READONLY, &status) ){
       	msg = createException(MAL, "fits.attach", "Missing FITS file %s.\n", fname);
		return msg;
	}

	sch = mvc_bind_schema(m,"sys");

	fits_fl = mvc_bind_table(m, sch, "fits_files");
	if ( fits_fl == NULL )
		FITSinitCatalog(m);

	fits_fl = mvc_bind_table(m, sch, "fits_files");
	fits_tbl = mvc_bind_table(m, sch, "fits_tables");
	fits_col = mvc_bind_table(m, sch, "fits_columns");

	/* check if the file is already attached */
	col = mvc_bind_column(m, fits_fl, "name");
	rid = table_funcs.column_find_row(m->session->tr, col, fname, NULL);
	if ( rid != oid_nil ) {
		fits_close_file(fptr, &status);
		msg = createException(SQL, "fits.attach", "File %s already attached\n", fname);
		return msg;
	}

	/* add row in the fits_files catalog table */
	col = mvc_bind_column(m, fits_fl, "id");
	fid = store_funcs.count_col(col) + 1;
	store_funcs.append_col(m->session->tr,
			mvc_bind_column(m, fits_fl, "id"), &fid, TYPE_int);
	store_funcs.append_col(m->session->tr,
			mvc_bind_column(m, fits_fl, "name"), fname, TYPE_str);

	col = mvc_bind_column(m, fits_tbl, "id");
	tid = store_funcs.count_col(col) + 1;

	fits_get_num_hdus(fptr, &hdunum, &status);
	for (i = 1; i <= hdunum; i++){
		fits_movabs_hdu(fptr, i, &hdutype, &status);
		if ( hdutype != ASCII_TBL && hdutype != BINARY_TBL )
			continue;

		/* SQL table name - the name of FITS extention */
		fits_read_key(fptr, TSTRING, "EXTNAME", tname, NULL, &status);
		if ( status ) {
			snprintf(tname,BUFSIZ,"%s_%d",fname,i);
			status = 0;
		}
		else {	/* check table name for existence */
			tbl = mvc_bind_table(m, sch, tname);
			if ( tbl )
				snprintf(tname,BUFSIZ,"%s_%d",fname,i);
		}

		store_funcs.append_col(m->session->tr,
				mvc_bind_column(m, fits_tbl, "id"), &tid, TYPE_int);
		store_funcs.append_col(m->session->tr,
			mvc_bind_column(m, fits_tbl, "name"), tname, TYPE_str);
		store_funcs.append_col(m->session->tr,
			mvc_bind_column(m, fits_tbl, "file_id"), &fid, TYPE_int);
		store_funcs.append_col(m->session->tr,
			mvc_bind_column(m, fits_tbl, "hdu"), &i, TYPE_int);

		/* read columns description */

		fits_get_num_cols(fptr, &cnum, &status);
		for ( j = 1; j <= cnum; j++){
		    fits_get_acolparms(fptr, j, cname, &tbcol, tunit, tform, &tscal, &tzero, tnull, tdisp, &status);
			fits_get_coltype(fptr, j, &tpcode, &rep, &wid, &status);
			mtype = fits2mtype(tpcode);

			store_funcs.append_col(m->session->tr,
				mvc_bind_column(m, fits_col, "id"), &j, TYPE_int);
			store_funcs.append_col(m->session->tr,
				mvc_bind_column(m, fits_col, "name"), cname, TYPE_str);
			store_funcs.append_col(m->session->tr,
				mvc_bind_column(m, fits_col, "type"), tform, TYPE_str);
			store_funcs.append_col(m->session->tr,
				mvc_bind_column(m, fits_col, "mtype"), &mtype, TYPE_int);
			store_funcs.append_col(m->session->tr,
				mvc_bind_column(m, fits_col, "table_id"), &tid, TYPE_int);
			store_funcs.append_col(m->session->tr,
				mvc_bind_column(m, fits_col, "units"), tunit, TYPE_str);
		}
		tid++;
	}
	fits_close_file(fptr, &status);

	return MAL_SUCCEED;
}   


@}
