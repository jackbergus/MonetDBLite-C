@/
The contents of this file are subject to the MonetDB Public License
Version 1.1 (the "License"); you may not use this file except in
compliance with the License. You may obtain a copy of the License at
http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html

Software distributed under the License is distributed on an "AS IS"
basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations
under the License.

The Original Code is the MonetDB Database System.

The Initial Developer of the Original Code is CWI.
Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
Copyright August 2008-2010 MonetDB B.V.
All Rights Reserved.
@

@f vault
@a Martin Kersten
@v 0.1
@+ Data Vaults
The Data Vault module provides the basic infrastructure to manage
a repository with datafiles whose integrity and use is shared between
MonetDB and a client repository.

Once a vault is created, the system administrator can manually add files to the 
vault catalog. A target directory, when set, denotes the location where
temporary copies are to be stored.

A import() operation will perform a batch copy of the files marked as to be copied
from the remote site using a path to an (ftp) directory.

If source and target files reside on the same file system then a symbolic link is sufficient.
Alternatively, the vault can be populated using normal updates to the vault catalog.

The SQL view on the vault merely describes the files being imported,
their freshness and properties required to fetch them from a remote source.
It is an ordinary SQL table, which can be the target for updates using SQL.
See the source file for the script.
@verbatim
CREATE TABLE sys.vault (
vid 			int PRIMARY KEY,-- Internal key
kind			string,			-- vault kind (CSV, MSEED, FITS,..)
source			string,			-- remote file name for cURL to access
refresh			boolean,		-- refresh each time of access
cached			timestamp,		-- copy stored locally
target			string			-- file name of source file in vault
);
@end verbatim

The module is developed solely for a Linux environment.
The vault root is a subdirectory of the dbfarm/<dbname>/vault/ and contains
a subdirectory for each vault kind. In turn, each vault kind comes
with a refinement of the catalog identified above using the vid
to relate the two.
@mal
module vault;

command getdirectory():str
address VLTgetDirectory
comment "Return the location of the root vault directory";

command import(vid:int)
address VLTimport
comment "Import the vault object identified";

command ftpget(src:str,trg:str)
address VLTftpget
comment "Use FTP to copy a remote file to a local";

pattern prelude():void 
address VLTprelude
comment "Initialize the vault.";

command epiloque():void 
address VLTepilogue
comment "Cleanup the vault.";

vault.prelude();
@{
@-
@+ Implementation
@h
#ifndef _VAULT_H
#define _VAULT_H
#include "sql_config.h"
#include "clients.h"
#include "mal.h"
#include "mal_client.h"
#include "mal_interpreter.h"

#ifdef HAVE_CURL
#include <curl/curl.h>
#include <curl/types.h>
#include <curl/easy.h>
#endif

#ifdef WIN32
#ifndef LIBVAULT
#define vault_export extern __declspec(dllimport)
#else
#define vault_export extern __declspec(dllexport)
#endif
#else
#define vault_export extern
#endif

#define _VAULT_DEBUG_

vault_export str VLTprelude(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
vault_export str VLTftpget(int *ret, str *source, str *target);
vault_export str VLTgetDirectory(str *ret);
vault_export str VLTimport(int *ret, str *nme);
vault_export  str VLTepilogue(int *ret);

vault_export char vaultpath[BUFSIZ];
#endif /* _VAULT_H */
@- Module initializaton
@c
#include "vault.h"

char vaultpath[BUFSIZ];
@-
@= initialize
	if ( vaultpath[0] == 0){
		snprintf(vaultpath, PATHLENGTH, "%s%c%s%cvault", GDKgetenv("gdk_dbfarm"), DIR_SEP, GDKgetenv("gdk_dbname"), DIR_SEP);
		if (mkdir(vaultpath, 0755) < 0 && errno != EEXIST) 
			return createException(MAL,"vault.getDirectory", "can not access vault directory");
	}
@-
The curl sample code has been copied from http://curl.haxx.se/libcurl/c/ftpget.html
@c
#ifdef HAVE_CURL
struct FtpFile {
  const char *filename;
  FILE *stream;
};
 
static size_t my_fwrite(void *buffer, size_t size, size_t nmemb, void *stream)
{
  struct FtpFile *out=(struct FtpFile *)stream;
  if(out && !out->stream) {
    /* open file for writing */ 
    out->stream=fopen(out->filename, "wb");
    if(!out->stream)
      return -1; /* failure, can't open file to write */ 
  }
  return fwrite(buffer, size, nmemb, out->stream);
}
#endif

str
VLTftpget(int *ret, str *source, str *target)
{
	str msg = MAL_SUCCEED;

#ifdef HAVE_CURL
	CURL *curl;
	CURLcode res;
	char path[BUFSIZ];
	struct FtpFile ftpfile={
		path, /* name to store the file as if succesful */ 
		NULL
	};

	//curl_global_init(CURL_GLOBAL_DEFAULT);

	snprintf(path,BUFSIZ,"%s%c%s", vaultpath, DIR_SEP, *target);
	mnstr_printf(GDKout,"#vault.ftpget: %s\n",path);
	curl = curl_easy_init();
	if(curl) {
		curl_easy_setopt(curl, CURLOPT_URL, *source);
		/* Define our callback to get called when there's data to be written */ 
		curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, my_fwrite);
		/* Set a pointer to our struct to pass to the callback */ 
		curl_easy_setopt(curl, CURLOPT_WRITEDATA, &ftpfile);

		/* Switch on full protocol/debug output */ 
		IODEBUG curl_easy_setopt(curl, CURLOPT_VERBOSE, 1L);

		res = curl_easy_perform(curl);

		/* always cleanup */ 
		curl_easy_cleanup(curl);

		if(CURLE_OK != res)
			msg= createException(MAL,"vault.ftpget", "curl told us %d\n", res);
	}

	if(ftpfile.stream)
		fclose(ftpfile.stream); /* close the local file */ 

	curl_global_cleanup();
#else
	(void) source;
	(void) target;
	msg = createException(MAL,"vault.ftpget", "No curl library");
#endif
	*ret= 0;
	return msg;
}



str
VLTprelude(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
#ifdef HAVE_CURL
	if (vaultpath[0] == 0){
		curl_global_init(CURL_GLOBAL_DEFAULT);
	}
#endif
	@:initialize@
	(void) cntxt;
	(void) mb;
	(void) stk;
	(void) pci;		/* fool compiler */
	return MAL_SUCCEED;
}

str
VLTepilogue(int *ret)
{
	(void)ret;
	return MAL_SUCCEED;
}
str 
VLTgetDirectory(str *ret){
	*ret= GDKstrdup(vaultpath);
	return MAL_SUCCEED;
}

@-
Import checks freshness of the vault entry and adds a copy to the local cache.
@c
str 
VLTimport(int *ret, str *id){
	(void) ret;
	(void) id;
	return MAL_SUCCEED;
}
@}
