@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2005 CWI.
@' All Rights Reserved.

@f bat_sequence
@h
#ifndef BAT_SEQ_H
#define BAT_SEQ_H

extern void sequences_init(void);
extern void sequences_exit(void);

extern int sql_next_value(sql_trans *tr, char *seq, lng *val);
extern int sequence_exit(char* s);

#endif /* BAT_SEQ_H */
@c
#include "sql_catalog.h"
#include "sql_storage.h"
#include "bat_store.h"
#include "bat_bm.h"
#include "bat_logger.h"

/*
 * There is a small window were the update of the cached value is done by a
 * different transaction. This could result in a wrong order of the updates 
 * which incase of a crash could lead to second use of sequence numbers.
 *
 * Creating/using 2 sequence numbers at the sametime will give problems as
 * the sql_seqs list is global but the numbers aren't committed.
 * The impact of this is low as one transaction will fail, but still the
 * wrong sql_seqs list is used.
 */

typedef struct sql_sequence {
	char *name;
	lng start;
	lng cur;
	lng minvalue;
	lng maxvalue;
	lng increment;
	lng cacheinc;
	bit cycle;
	lng cached;
	bit called;
} sql_sequence;

static list *sql_seqs = NULL;

static void 
sequence_destroy( sql_sequence *s )
{
	_DELETE(s->name);
	_DELETE(s);
}

void sequences_init(void)
{
	sql_seqs = list_create( (fdestroy)sequence_destroy );
}

/**
 * Stores the current cache value of the sequence and destroys it.  This
 * function is used when an ALTER or DROP SEQUENCE statement is
 * performed.  Because the given sequence is part of the sql_seqs list,
 * the list is updated accordingly by this function.
 *
 * @return 0 if an error occurred while removing the sequence, 1
 *         otherwise
 */
int sequence_exit(char* seq) {
	sql_trans *ntr = sql_trans_create(0, NULL, NULL);
	sql_schema *sys = find_sql_schema(ntr, "sys");
	sql_table *seqs = find_sql_table(sys, "sequences");
	sql_column *seq_name = find_sql_column(seqs, "name");
	sql_column *seq_cached = find_sql_column(seqs, "cached");
	ssize_t id;
	node* n;
	sql_sequence *s;

	/* find the right node in the list and remove it */
	if (list_length(sql_seqs)) {
		for (n = sql_seqs->h; n; n = n ->next) {
			s = n->data;
			if (strcmp(s->name, seq) == 0) {
				list_remove_node(sql_seqs, n);
				break;
			}
		}
		/* the sequence was not loaded */
		sql_trans_destroy(ntr);
		return(1);
	} else {
		/* nothing is loaded yet */
		sql_trans_destroy(ntr);
		return(1);
	}

	if (s && (id = column_find_row(ntr, seq_name, s->name, NULL)) >= 0) {
		column_update_value(ntr, seq_cached, id, &s->cur);
	} else {
		sql_trans_destroy(ntr);
		/* error message:
		 * "Internal consistency error: no such sequence %s", s->name
		 */
		return(0);
	}
	sql_trans_commit(ntr);
	sql_trans_destroy(ntr);
	sequence_destroy(s);

	return(1);
}

void sequences_exit(void)
{
	node *n;
	sql_trans *ntr = sql_trans_create(0, NULL, NULL);
	sql_schema *sys = find_sql_schema(ntr, "sys");
	sql_table *seqs = find_sql_table(sys, "sequences");
	sql_column *seq_name = find_sql_column(seqs, "name");
	sql_column *seq_cached = find_sql_column(seqs, "cached");

	/* reset sequence numbers */
	if (list_length(sql_seqs)){
		for ( n = sql_seqs->h; n; n = n ->next ) {
			sql_sequence *s = n->data;
			ssize_t id;
	
			if ((id = column_find_row(ntr, seq_name, s->name, NULL)) >= 0) 
				column_update_value(ntr, seq_cached, id, &s->cur);
		}
		sql_trans_commit(ntr);
	}
	list_destroy(sql_seqs);
	sql_trans_destroy(ntr);
}

static void 
sql_update_sequence_cache(sql_trans *tr, char *seq, lng cached, bit called) 
{
	ssize_t id;
	sql_trans *ntr = sql_trans_create(0, NULL, NULL);
	sql_schema *sys = find_sql_schema(ntr, "sys");
	sql_table *seqs = find_sql_table(sys, "sequences");
	sql_column *seq_name = find_sql_column(seqs, "name");
	sql_column *seq_cached = find_sql_column(seqs, "cached");
	sql_column *seq_called = find_sql_column(seqs, "called");

	if ((id = column_find_row(ntr, seq_name, seq, NULL)) < 0) {
		/* a new sequence needs to be updated in the current transaction */
		sys = find_sql_schema(tr, "sys");
		seqs = find_sql_table(sys, "sequences");
		seq_name = find_sql_column(seqs, "name");
		seq_cached = find_sql_column(seqs, "cached");
		seq_called = find_sql_column(seqs, "called");

		if ((id = column_find_row(tr, seq_name, seq, NULL)) < 0) 
			return;
		column_update_value(tr, seq_cached, id, &cached);
		column_update_value(tr, seq_called, id, &called);
	} else {
		column_update_value(ntr, seq_cached, id, &cached);
		column_update_value(ntr, seq_called, id, &called);
		sql_trans_commit(ntr);
	}
	sql_trans_destroy(ntr);
}

static sql_sequence *
sql_create_sequence(sql_trans *tr, char *seq ) 
{
	void *p;
	ssize_t id;
	sql_sequence *s = NULL;
	sql_schema *sys = find_sql_schema(tr, "sys");
	sql_table *seqs = find_sql_table(sys, "sequences");
	sql_column *seq_name = find_sql_column(seqs, "name");
	sql_column *seq_start = find_sql_column(seqs, "start");
	sql_column *seq_inc = find_sql_column(seqs, "increment");
	sql_column *seq_cache = find_sql_column(seqs, "cache");
	sql_column *seq_min = find_sql_column(seqs, "minvalue");
	sql_column *seq_max = find_sql_column(seqs, "maxvalue");
	sql_column *seq_cycle = find_sql_column(seqs, "cycle");
	sql_column *seq_cached = find_sql_column(seqs, "cached");
	sql_column *seq_called = find_sql_column(seqs, "called");
	lng nr;

	if ((id = column_find_row(tr, seq_name, seq, NULL)) < 0) 
		return NULL;
	
	s = NEW(sql_sequence);
	s -> name = _strdup(seq);
	s -> start = *(lng*)(p=column_find_value(tr, seq_start, id)); _DELETE(p);
	s -> increment = *(lng*)(p=column_find_value(tr, seq_inc, id)); _DELETE(p);
	s -> cacheinc = s->increment * *(lng*)(p=column_find_value(tr, seq_cache, id)); _DELETE(p);
	s -> minvalue = *(lng*)(p=column_find_value(tr, seq_min, id)); _DELETE(p);
	s -> maxvalue = *(lng*)(p=column_find_value(tr, seq_max, id)); _DELETE(p);
	s -> cycle = *(bit*)(p=column_find_value(tr, seq_cycle, id)); _DELETE(p);
	s -> called = *(bit*)(p=column_find_value(tr, seq_called, id)); _DELETE(p);
	/* note: we default to the start value for cur here if cached is zero */
	s -> cached = *(lng*)(p=column_find_value(tr, seq_cached, id)); _DELETE(p);
	s -> cur = s->cached ? s->cached : s->start;

	/* move to the global transaction, to get the current values */
	while(tr->parent) 
		tr = tr->parent;

	sys = find_sql_schema(tr, "sys");
	seqs = find_sql_table(sys, "sequences");
	seq_name = find_sql_column(seqs, "name");
	seq_cached = find_sql_column(seqs, "cached");

	if ((id = column_find_row(tr, seq_name, seq, NULL)) < 0) 
		return s;
	nr = *(lng*)(p=column_find_value(tr, seq_cached, id)); _DELETE(p);
	if (nr > s->cur) 
		s->cur = s->cached = nr;
	return s;
}

int
sql_next_value(sql_trans *tr, char *seq, lng *val)
{
	lng nr = 0;
	node *n;
	sql_sequence *s;

	store_lock();

	for ( n = sql_seqs->h; n; n = n ->next ) {

		s = n->data;
		if (strcmp(s->name, seq) == 0) {
			if (s->called) {
				/* handle min/max and cycle */
				s->cur += s->increment;
				if ((s->maxvalue && s->cur > s->maxvalue) ||
						(s->minvalue && s->cur < s->minvalue))
				{
					if (s->cycle) {
						/* cycle to the start value again */
						s->cur = s->start;
					} else {
						/* we're out of numbers */
						*val = 0;
						store_unlock();
						/* error message:
						 * printf("No more numbers: %lld < %lld < %lld\n", s->minvalue, s->cur, s->maxvalue);
						 */
						return(0);
					}
				}
			}
			s->called = 1;
			nr = s->cur;
			*val = nr;
			if (!s->cached || nr == s->cached) {
				/* update value in a single transaction */
				s->cached += s->cacheinc;
				store_unlock(); 
				sql_update_sequence_cache(tr, seq, s->cached, s->called);
				return 1;
			}
			store_unlock(); 
			return 1;
		}
	}
	s = sql_create_sequence(tr, seq);
	if (!s) {
		*val = 0;
		store_unlock();
		/* error message:
		 * printf("No such sequence %s\n", seq);
		 */
		return 0;
	}
	if (s->called) {
		/* handle min/max and cycle */
		s->cur += s->increment;
		if ((s->maxvalue && s->cur > s->maxvalue) ||
				(s->minvalue && s->cur < s->minvalue))
		{
			if (s->cycle) {
				/* cycle to the start value again */
				s->cur = s->start;
			} else {
				/* we're out of numbers */
				*val = 0;
				store_unlock();
				/* error message:
				 * printf("No more numbers: %lld < %lld < %lld\n", s->minvalue, s->cur, s->maxvalue);
				 */
				return(0);
			}
		}
	}
	s->called = 1;
	nr = s->cur;
	list_append(sql_seqs, s);
	store_unlock();
	sql_update_sequence_cache(tr, seq, s->cached, s->called);
	*val = nr;
	return 1;
}

