@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2005 CWI.
@' All Rights Reserved.

@f bat_sequence
@h
#ifndef BAT_SEQ_H
#define BAT_SEQ_H

extern void sequences_init(void);
extern void sequences_exit(void);

extern int sql_next_value(sql_trans *tr, char *seq, lng *val);

#endif /* BAT_SEQ_H */
@c
#include "sql_catalog.h"
#include "sql_storage.h"
#include "bat_store.h"
#include "bat_bm.h"
#include "bat_logger.h"

/*
 * TODO, sql_seqs list contains all used sequences. When sequences are dropped,
 * they should be removed from this list. If a sequence with the same name is
 * created there is a change the old values are reused.
 *
 * There is a small window were the update of the cached value is done by a
 * different transaction. This could result in a wrong order of the updates 
 * which incase of a crash could lead to second use of sequence numbers.
 *
 * Creating/using 2 sequence numbers at the sametime will give problems as
 * the sql_seqs list is global but the numbers aren't committed.
 * The impact of this is low as one transaction will fail, but still the
 * wrong sql_seqs list is used.
 *
 * Possible solution for all these problems is 'create/drop/alter sequences'
 * are single transaction statements.
 */

typedef struct sql_sequence {
	char *name;
	lng cur;
	lng cached;
	lng minvalue;
	lng maxvalue;
	lng increment;
	bit cycle;
} sql_sequence;

static list *sql_seqs = NULL;

static void 
sequence_destroy( sql_sequence *s )
{
	_DELETE(s->name);
	_DELETE(s);
}

void sequences_init(void)
{
	sql_seqs = list_create( (fdestroy)sequence_destroy );
}

void sequences_exit(void)
{
	node *n;
	sql_trans *ntr = sql_trans_create(0, NULL, NULL);
	sql_schema *sys = find_sql_schema(ntr, "sys");
	sql_table *seqs = find_sql_table(sys, "sequences");
	sql_column *seq_name = find_sql_column(seqs, "name");
	sql_column *seq_cached = find_sql_column(seqs, "cached");

	/* reset sequence numbers */
	if (list_length(sql_seqs)){
		for ( n = sql_seqs->h; n; n = n ->next ) {
			sql_sequence *s = n->data;
			ssize_t id;
	
			if ((id = column_find_row(ntr, seq_name, s->name, NULL)) >= 0) 
				column_update_value(ntr, seq_cached, id, &s->cur);
		}
		sql_trans_commit(ntr);
	}
	list_destroy(sql_seqs);
	sql_trans_destroy(ntr);
}

static void 
sql_update_sequence(sql_trans *tr, char *seq, lng cached ) 
{
	ssize_t id;
	sql_trans *ntr = sql_trans_create(0, NULL, NULL);
	sql_schema *sys = find_sql_schema(ntr, "sys");
	sql_table *seqs = find_sql_table(sys, "sequences");
	sql_column *seq_name = find_sql_column(seqs, "name");
	sql_column *seq_cached = find_sql_column(seqs, "cached");

	if ((id = column_find_row(ntr, seq_name, seq, NULL)) < 0) {
		/* a new sequence needs to be updated in the current transaction */
		sys = find_sql_schema(tr, "sys");
		seqs = find_sql_table(sys, "sequences");
		seq_name = find_sql_column(seqs, "name");
		seq_cached = find_sql_column(seqs, "cached");

		if ((id = column_find_row(tr, seq_name, seq, NULL)) < 0) 
			return;
		column_update_value(tr, seq_cached, id, &cached);
	} else {
		column_update_value(ntr, seq_cached, id, &cached);
		sql_trans_commit(ntr);
	}
}

static sql_sequence *
sql_create_sequence(sql_trans *tr, char *seq ) 
{
	ssize_t id;
	sql_sequence *s = NULL;
	sql_schema *sys = find_sql_schema(tr, "sys");
	sql_table *seqs = find_sql_table(sys, "sequences");
	sql_column *seq_name = find_sql_column(seqs, "name");
	sql_column *seq_cached = find_sql_column(seqs, "cached");
	sql_column *seq_inc = find_sql_column(seqs, "increment");
	sql_column *seq_min = find_sql_column(seqs, "minvalue");
	sql_column *seq_max = find_sql_column(seqs, "maxvalue");
	sql_column *seq_cycle = find_sql_column(seqs, "cycle");
	lng nr;

	if ((id = column_find_row(tr, seq_name, seq, NULL)) < 0) 
		return NULL;
	
	s = NEW(sql_sequence);
	s -> name = _strdup(seq);
	s -> cur = *(lng*)column_find_value(tr, seq_cached, id);
	s -> cached = s->cur;
	s -> increment = *(lng*)column_find_value(tr, seq_inc, id);
	s -> minvalue = *(lng*)column_find_value(tr, seq_min, id);
	s -> maxvalue = *(lng*)column_find_value(tr, seq_max, id);
	s -> cycle = *(bit*)column_find_value(tr, seq_cycle, id);

	/* move to the global transaction, to get the current values */
	while(tr->parent) 
		tr = tr->parent;

	sys = find_sql_schema(tr, "sys");
	seqs = find_sql_table(sys, "sequences");
	seq_name = find_sql_column(seqs, "name");
	seq_cached = find_sql_column(seqs, "cached");

	if ((id = column_find_row(tr, seq_name, seq, NULL)) < 0) 
		return s;
	nr = *(lng*)column_find_value(tr, seq_cached, id);
	if (nr > s->cur) 
		s->cur = s->cached = nr;
	return s;
}

int
sql_next_value(sql_trans *tr, char *seq, lng *val)
{
	lng nr = 0;
	node *n;
	sql_sequence *s;

	store_lock();

	for ( n = sql_seqs->h; n; n = n ->next ) {

		s = n->data;
		if (strcmp(s->name, seq) == 0) {
			/* TODO handle min/max and cycle */
			s->cur += s->increment;
			nr = s->cur;
			if (nr == s->cached) {
				/* update value in a single transaction */
				s->cached += 1024;
				store_unlock(); 
				sql_update_sequence(tr, seq, s->cached);
				return nr;
			}
			store_unlock(); 
			*val = nr;
			return 1;
		}
	}
	s = sql_create_sequence(tr, seq);
	if (!s) {
		*val = 0;
		store_unlock();
		return 0;
	}
	s->cached += 1024;
	/* TODO handle min/max and cycle */
	s->cur += s->increment;
	nr = s->cur;
	list_append(sql_seqs, s);
	store_unlock();
	sql_update_sequence(tr, seq, s->cached);
	*val = nr;
	return 1;
}


