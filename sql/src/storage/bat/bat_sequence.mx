@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2007 CWI.
@' All Rights Reserved.

@f bat_sequence
@h
#ifndef BAT_SEQ_H
#define BAT_SEQ_H

extern void sequences_init(void);
extern void sequences_exit(void);

extern int seq_next_value(sql_sequence *seq, lng *val);
extern int seq_restart(sql_sequence *seq, lng start);

#endif /* BAT_SEQ_H */
@c
#include "sql_config.h"
#include "sql_catalog.h"
#include "sql_storage.h"
#include "bat_store.h"
#include <logger.h>

typedef struct bat_sequence {
	sqlid seqid;
	bit called;
	lng cur;
	lng cached;
} bat_sequence;

static list *sql_seqs = NULL;

static void 
sequence_destroy( bat_sequence *s )
{
	_DELETE(s);
}

void sequences_init(void)
{
	sql_seqs = list_create( (fdestroy)sequence_destroy );
}

void sequences_exit(void)
{
	list_destroy(sql_seqs);
}

/* lock is held */
static void 
sql_update_sequence_cache(sql_sequence *seq, lng cached) 
{
	log_sequence(sql_logger, seq->base.id, cached);
}

/* lock is held */
static bat_sequence *
sql_create_sequence(sql_sequence *seq ) 
{
	lng id = 0;
	bat_sequence *s = NULL;

	s = NEW(bat_sequence);
	s -> seqid = seq->base.id;
	s -> called = 0;
	s -> cur = seq->start; 	  
	s -> cached = seq->start;

	if (seq->base.flag == TR_OLD && 
	    logger_sequence(sql_logger, seq->base.id, &id )) 
		s->cached = id;
	s -> cur = s->cached;
	return s;
}

int seq_restart(sql_sequence *seq, lng start)
{
	node *n = NULL;
	bat_sequence *s;

	store_lock();
	for ( n = sql_seqs->h; n; n = n ->next ) {
		s = n->data;
		if (s->seqid == seq->base.id)
			break;
	}
	if (!n) {
		s = sql_create_sequence(seq);
		if (!s) {
			store_unlock();
			return 0;
		}
		list_append(sql_seqs, s);
	} else {
		s = n->data;
	}
	s->called = 0;
	s->cur = start;
	s->cached = start + seq->cacheinc;
	/* handle min/max and cycle */
	if ((seq->maxvalue && s->cur > seq->maxvalue) ||
	    (seq->minvalue && s->cur < seq->minvalue))
	{
		/* we're out of numbers */
		store_unlock();
		return(0);
	}
	sql_update_sequence_cache(seq, s->cached);
	store_unlock(); 
	return 1;
}


int
seq_next_value(sql_sequence *seq, lng *val)
{
	lng nr = 0;
	node *n = NULL;
	bat_sequence *s;
	int save = 0;

	*val = 0;
	store_lock();
	for ( n = sql_seqs->h; n; n = n ->next ) {
		s = n->data;
		if (s->seqid == seq->base.id)
			break;
	}
	if (!n) {
		s = sql_create_sequence(seq);
		if (!s) {
			store_unlock();
			return 0;
		}
		list_append(sql_seqs, s);
	} else {
		s = n->data;
		if (s->called)
			s->cur += seq->increment;
	}
	/* handle min/max and cycle */
	if ((seq->maxvalue && s->cur > seq->maxvalue) ||
	    (seq->minvalue && s->cur < seq->minvalue))
	{
		if (seq->cycle) {
			/* cycle to the start value again */
			s->cur = seq->start;
			save = 1;
		} else { /* we're out of numbers */
			store_unlock();
			return(0);
		}
	}
	s->called = 1;
	nr = s->cur;
	*val = nr;
	if (save || nr == s->cached) {
		s->cached = nr + seq->cacheinc;
		sql_update_sequence_cache(seq, s->cached);
		store_unlock(); 
		return 1;
	}
	assert(nr<s->cached);
	store_unlock(); 
	return 1;
}
