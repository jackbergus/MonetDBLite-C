@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2006 CWI.
@' All Rights Reserved.

@f bat_logger
@t Transactions
@a N. J. Nes
@v 1.0
@T
@* Introduction
[Make it a re-usable piece of code if possible, i.e. a module]
In the philosophy of Monet, transaction management overhead should only
be paid when necessary. Transaction management is for this purpose 
implemented as a separate module and applications are required to
obey the transaction policy, e.g. obtaining/releasing locks. 

This module is designed to support efficient logging of SQL database.
Once loaded, the SQL compiler will insert the proper calls at
transaction commit to include the changes in the log file.

The key decision to be made by the user is the location of the log file.
Ideally, it should be stored in fail-safe environment, or at least
the log and databases should be on separate disk columns.

The current setup assumes that the log directory is a mounted file system. (?)
This file system may reside on the same hardware as the database server
and therefor the writes are done to the same disk, but could also 
reside on an other system and then the changes are flushed through the network.  
The logger works under the assumption that it is called to safeguard
updates on the database when it has an exclusive lock on
the latest version. 

Finding the updates applied to a BAT is relatively easy, because each
BAT contains a delta structure. On commit these changes are
written to the log file and the delta management is reset. Since each 
commit is written to the same log file, the beginning and end are 
marked by a log identifier.

A server restart should only (re)process blocks which are completely 
written to disk. A log replay therefor ends in a commit or abort on
the changed bats. Once all logs have been read, the changes to
the bats are maded persistent, ie a bbp sub-commit is done.

@* Implementation Code 
@h
#ifndef _SQL_LOGGER_H_
#define _SQL_LOGGER_H_

#include "bat_bm.h"

#define SQLBATSIZE 0

/* version 03.02.02 of catalog */
#define CATALOG_VERSION 30202

typedef int log_bid;

/* the sequence identifier for the sequence of log files */
#define LOG_OID	0
/* the sequence identifier for sql objects */
#define SQL_OID	1

extern int logger_start(int debug);
extern void logger_stop(void);
extern int logger_restart(void);
extern int logger_cleanup(void);
extern int logger_changes(void);
extern int logger_sequence(int seq, lng *id);

extern int log_bat(BAT *b, char *n);
extern int log_bat_clear(char *n);
extern int log_bat_persists(BAT *b, char *n);
extern int log_bat_transient(char *n);

extern int log_tstart(void);
extern int log_tend(void);
extern int log_sequence(int seq, lng id);

extern log_bid logger_add_bat(BAT *b, char *name);
extern void logger_del_bat(log_bid bid);
extern log_bid logger_find_bat(char *name);

#endif /*_SQL_LOGGER_H_*/
@c
#include "sql_mem.h"
#include "bat_logger.h"
#include "stream.h"

@-
The log record encoding is geared at reduced storage space, but
at the expense of readability. A user can not easily inspect the
log a posteriori to check what has happened.

@c
#define SQL_LOG_START		1
#define SQL_LOG_END		2
#define SQL_LOG_INSERT		3
#define SQL_LOG_DELETE		4
#define SQL_LOG_CREATE		5
#define SQL_LOG_DESTROY		6
#define SQL_LOG_USE		7
#define SQL_LOG_CLEAR		8
#define SQL_LOG_OID		9

typedef struct logformat_t {
	char flag;
	int nr;
} logformat;

#define LOGFILE "log"

typedef struct logger {
	int debug;
	int changes;
	lng id;
	int tid;
	char *dir;
	stream *log;
	BAT *seq_ids; 	/* int, lng */
	BAT *catalog;	/* int, str */
} logger;

static logger *l = NULL;

static int bm_commit(void);
static void bm_abort(void);

static int
log_read_format(logformat *data)
{
	int res = 1;

	if (stream_read(l->log, &data->flag, 1, 1) != 1)
		return 0;
	res = stream_readInt(l->log, &data->nr);
	return res;
}

static int
log_write_format(logformat *data)
{
	if (stream_write(l->log, &data->flag, 1, 1) != 1 || !stream_writeInt(l->log, data->nr))
		return SQL_ERR;
	return SQL_OK;
}

static char *
log_read_string(void)
{
	int len;
	ssize_t nr;
	char *buf;

	if (!stream_readInt(l->log, &len))
		return NULL;
	buf = NEW_ARRAY(char, len);

	if ((nr = stream_read(l->log, buf, 1, len)) != (ssize_t) len) {
		buf[len-1] = 0;
		printf("!ERROR: couldn't read name (%s) " SSZFMT "\n", buf, nr);
		GDKfree(buf);
		return NULL;
	}
	buf[len-1] = 0;
	return buf;
}

static int
log_write_string(char *n)
{
	int len = (int) strlen(n) + 1;	/* log including EOS */

	assert(len > 1);
	if (!stream_writeInt(l->log, len) ||
	    stream_write(l->log, n, 1, len) != (ssize_t) len)
		return SQL_ERR;
	return SQL_OK;
}

static void
log_read_clear(char *name)
{
	log_bid bid = logger_find_bat(name);
	BAT *b = bat_descriptor(bid, "log_read_clear");

	if (l->debug & 1)
		fprintf(stderr, "logger found log_read_clear %s\n", name);

	if (b) {
		BATclear(b);
		bat_destroy(b);
	}
}

static void
log_read_seq(logformat *lf)
{
	int seq = lf->nr;
	lng id;
	int res = SQL_OK;

	res = stream_readLng(l->log, &id);
	if (BUNfnd(l->seq_ids, &seq)) {
		BUNdelHead(l->seq_ids, &seq, FALSE);
	}
	BUNins(l->seq_ids, &seq, &id, FALSE);
	(void)res;
}

static void
log_read_updates(logformat *lf, char *name)
{
	log_bid bid = logger_find_bat(name);
	BAT *b = bat_descriptor(bid,  "log_read_updates");

	if (l->debug & 1)
		fprintf(stderr, "logger found log_read_updates %s %s %d\n", name, (lf->flag == SQL_LOG_INSERT) ? "insert" : "delete", lf->nr);

	if (b) {
		void *(*rh) (ptr, stream *, size_t) = BATatoms[b->htype].atomRead;
		void *(*rt) (ptr, stream *, size_t) = BATatoms[b->ttype].atomRead;
		void *tv = ATOMnil(b->ttype);

		if (b->htype == TYPE_void && lf->flag == SQL_LOG_INSERT) { 
			for (; lf->nr > 0; lf->nr--) {
				void *t = rt(tv, l->log, 1);

				if (!t)
					break;
				if (lf->flag == SQL_LOG_INSERT)
					BUNappend(b, t, TRUE);
				if (t != tv)
					_DELETE(t);
			}

		} else {
			void *hv = ATOMnil(b->htype);

			for (; lf->nr > 0; lf->nr--) {
				void *h = rh(hv, l->log, 1);
				void *t = rt(tv, l->log, 1);

				if (!h && !t)
					break;
				if (lf->flag == SQL_LOG_INSERT)
					BUNins(b, h, t, FALSE);
				else if (lf->flag == SQL_LOG_DELETE)
					BUNdel(b, h, t, FALSE);
				if (h != hv)
					_DELETE(h);
				if (t != tv)
					_DELETE(t);
			}
			_DELETE(hv);
		}
		_DELETE(tv);
		bat_destroy(b);
	}
}

static void
log_read_destroy(char *name)
{
	log_bid bid = logger_find_bat(name);

	if (bid)
		logger_del_bat(bid);
}

static void
log_read_create(char *name)
{
	char *buf = log_read_string();

	if (l->debug & 1)
		fprintf(stderr, "log_read_create %s\n", name);

	if (!buf) {
		GDKerror("logger could not read create (%s)\n", name);
	} else {
		int ht, tt, hseq = 0, tseq = 0;
		char *ha = buf, *ta = strchr(buf, ',');
		BAT *b;

		if (!ta) {
			GDKerror("logger types are not ',' seperated (%s)\n", buf);
			return;
		}
		*ta = 0;
		ta++;		/* skip over , */
		if (strcmp(ha, "vid") == 0) {
			ht = TYPE_void;
			hseq = 1;
		} else {
			ht = ATOMindex(ha);
		}
		if (strcmp(ta, "vid") == 0) {
			tt = TYPE_void;
			tseq = 1;
		} else {
			tt = ATOMindex(ta);
		}
		b = BATnew(ht, tt, SQLBATSIZE);

		if (hseq)
			BATseqbase(b, 0);
		if (tseq)
			BATseqbase(b=BATmirror(b), 0);

		if (!b) {
			GDKerror("logger could not create bat (%s,%s,%s,%d,%d)\n", name, ha, ta, ht, tt);
			return;
		}
		logger_add_bat(b, name);
		bat_destroy(b);
	}
	if (buf)
		_DELETE(buf);
}

static void
log_read_use(logformat *lf, char *name)
{
	log_bid bid = lf->nr;
	BAT *b = bat_descriptor(bid, "log_read_use");
	
	if (!b) {
		GDKerror("logger could not use bat (" OIDFMT ") for %s\n", bid, name);
		return ;
	}
	logger_add_bat(b, name);
}

static void
tr_commit(void)
{
	if (l->debug & 1)
		printf("tr_commit\n");

	bm_commit();
}

static void
tr_abort(void)
{
	if (l->debug & 1)
		printf("tr_abort\n");

	bm_abort();
}

static int
logger_open(logger *logger)
{
	char filename[BUFSIZ];

	snprintf(filename, BUFSIZ, "%s%s." LLFMT, logger->dir, LOGFILE, logger->id);
	logger->log = open_wstream(filename);
	if (stream_errnr(logger->log))
		 return SQL_ERR;

	return SQL_OK;
}

static void
logger_close(logger *logger)
{
	stream *log = logger->log;

	if (log) {
		stream_close(log);
		stream_destroy(log);
	}
	logger->log = NULL;
}

static int
logger_readlog(logger *logger, char *filename)
{
	logformat lf;

	logger->log = open_rstream(filename);


	/* if the file doesn't exist, there is nothing to be readback */
	if (!logger->log || stream_errnr(logger->log)) {
		if (logger->log)
			stream_destroy(logger->log);

		return 0;
	}
	while (log_read_format(&lf)) {
		char *name = NULL;

		if (lf.flag != SQL_LOG_START && lf.flag != SQL_LOG_END && 
		    lf.flag != SQL_LOG_OID) {
			name = log_read_string();

			if (!name) {
				GDKerror("logger could not read name (%d)\n", lf.flag);
				return -1;
			}
		}
		switch (lf.flag) {
		case SQL_LOG_START:
			if (logger->tid != 0)
				tr_abort();
			logger->tid = lf.nr;
			if (logger->debug & 1)
				fprintf(stderr, "logger tstart %d\n", 
					logger->tid);

			break;
		case SQL_LOG_END:
			if (logger->tid == lf.nr) {
				if (logger->debug & 1)
					fprintf(stderr, "logger tend %d\n", 
						logger->tid);
				tr_commit();
			} else {
				tr_abort();
			}
			logger->tid = 0;

			break;
		case SQL_LOG_OID:
			log_read_seq(&lf);

			break;
		case SQL_LOG_INSERT:
			log_read_updates(&lf, name);

			break;
		case SQL_LOG_DELETE:
			log_read_updates(&lf, name);

			break;
		case SQL_LOG_CREATE:
			log_read_create(name);

			break;
		case SQL_LOG_USE:
			log_read_use(&lf, name);

			break;
		case SQL_LOG_DESTROY:
			log_read_destroy(name);

			break;
		case SQL_LOG_CLEAR:
			log_read_clear(name);

			break;
		default:
			GDKerror("logger error %d %s\n", lf.flag, name);
			return -2;
		}
		if (name)
			_DELETE(name);
		logger->changes++;
	}
	logger_close(logger);

	if (logger->tid != 0) 
		tr_abort();

	return 0;
}

@-
The log files are incrementally numbered. They are processed in the
same sequence.
@c
static int
logger_readlogs(logger *logger, FILE *fp, char *filename)
{
	int res = 0;
	char id[BUFSIZ];

	if (logger->debug & 1)
		fprintf(stderr, "logger_readlogs %s\n", filename);

	while (fgets(id, BUFSIZ, fp) != NULL) {
		char buf[BUFSIZ];
		lng lid = strtoll(id, NULL, 10);
		
		if (lid >= logger->id) {
			logger->id = lid;
			snprintf(buf, BUFSIZ, "%s." LLFMT, filename, logger->id);

			if ((res = logger_readlog(logger, buf)) != 0) {
				break;
			}
		}
	}
	return res;
}

static int
logger_commit(void)
{
	int id = LOG_OID;
	if (l->debug & 1)
		fprintf(stderr, "logger_commit\n");

	BUNdelHead(l->seq_ids, &id, FALSE);
	BUNins(l->seq_ids, &id, &l->id, FALSE);
	return bm_commit();
}

static int
check_version(logger *logger, FILE *fp)
{
	int version = 0;

	if (fscanf(fp, "%6d", &version) != 1 || version != CATALOG_VERSION) {
		GDKerror("Incompatible database version %06d, "
			 "this server supports version %06d\n"
			 "Please move away %s and its corresponding dbfarm.",
			 version, CATALOG_VERSION, logger->dir);

		return -1;
	}
	fgetc(fp);		/* skip \n */
	fgetc(fp);		/* skip \n */
	return 0;
}

static
int bm_subcommit( BAT * catalog ) 
{
	BUN p,q;
	BAT *n = bat_new(TYPE_void, TYPE_str, BATcount(catalog)*2, "subcommit");
	BAT *b = catalog;
	int res;

	BATseqbase(n,0);
	/* first loop over deleted then over current and new */
	for (p = b->batDeleted; p < b->batFirst; p = BUNnext(b, p)) {
		bat col = *(log_bid*)BUNhead(b,p);
		str name = BBPname(col);
		BUNappend(n, name, FALSE);
	}
	BATloop(b, p, q) {
		bat col = *(log_bid*)BUNhead(b,p);
		str name = BBPname(col);
		BUNappend(n, name, FALSE);
	}
	/* now commit catalog, so its also up to date on disk */
	BATcommit(catalog); 
	res = TMsubcommit(n);
	BBPreclaim(n);
	return res;
}

static void
logger_destroy(void)
{
	if (!l)
		return ;
	if (l->catalog) {
		BUN p, q;
		BAT *b = l->catalog;

		logger_cleanup();

		/* destroy the deleted */
/* would be an error ....
		for (p = b->batDeleted; p < b->batFirst; p = BUNnext(b, p)) {
			bat bid = *(log_bid *) BUNhead(b, p);

			bat_decref(bid, TRUE);
		}
*/
		/* free resources */
		BATloop(b, p, q) {
			bat bid = *(log_bid *) BUNhead(b, p);

			bat_decref(bid, TRUE);
		}

		bat_decref(l->catalog->batCacheid, TRUE);
		bat_destroy(l->catalog);
	}
	_DELETE(l->dir);
	logger_close(l);
	_DELETE(l);
	l = NULL;
}

static void 
logger_new(int debug)
{
	int id = LOG_OID;
	FILE *fp;
	char filename[BUFSIZ];
	char bak[BUFSIZ];
	log_bid seq_ids = 0;
	char *catalog = "log_catalog";
	bat log_catalog = BBPindex("log_catalog");
	char *logdir = GDKgetenv("logdir");
	char *dbname = GDKgetenv("gdk_dbname");

	if (!logdir || !dbname)
		return ;

	l = NEW(struct logger);
	l->debug = debug;
	l->changes = 0;
	l->id = 1;
	l->tid = 0;

	snprintf(filename, BUFSIZ, "%s%c%s%c", logdir, DIR_SEP, dbname, DIR_SEP);
	l->dir = _strdup(filename);
	l->log = NULL;
	l->catalog = NULL;

	if (log_catalog == 0) {
		log_bid bid = 0;
		l->catalog = bat_new(TYPE_int, TYPE_str, SQLBATSIZE, "logger_new");
		if (debug)
			printf("create log_catalog\n");

		bid = l->catalog->batCacheid;

		/* Make persistent */
		bat_incref(bid, TRUE, "logger_new");
		BATmode(l->catalog, PERSISTENT);
		BBPrename(l->catalog->batCacheid, catalog);

		/* insert catalog bat, to make TMsubcommit calls possible */
		BUNins(l->catalog, &bid, catalog, FALSE);
		if (bm_subcommit(l->catalog) != 0) {  /* save log_catalog */
			logger_destroy();
			return ;
		}
	} else { /* find the persisten log_catalog. As non persistent bats
		    require a logical reference we also add a logical 
		    reference for the persistent bats */
		BUN p, q;
		BAT *b = bat_descriptor(log_catalog, "logger_new");

		l->catalog = b;
		BATloop(b, p, q) {
			bat bid = *(log_bid *) BUNhead(b, p);

			bat_incref(bid, TRUE, "logger_new");
		}
	}
	seq_ids = logger_find_bat("seq_ids");
	if (seq_ids == 0) {
		l->seq_ids = bat_new(TYPE_int, TYPE_lng, 1, "logger_new");
		BATmode(l->seq_ids, PERSISTENT);
		BBPrename(l->seq_ids->batCacheid, "seq_ids");
		
		logger_add_bat(l->seq_ids, "seq_ids");
		BUNins(l->seq_ids, &id, &l->id, FALSE);
	} else {
		l->seq_ids = bat_descriptor(seq_ids, "logger_new");
		if (BATcount(l->seq_ids)) {
			l->id = *(lng*)BUNtail(l->seq_ids, BUNfnd(l->seq_ids, &id));
		} else {
			BUNins(l->seq_ids, &id, &l->id, FALSE);
		}
	}

	snprintf(filename, BUFSIZ, "%s%s", l->dir, LOGFILE);

	snprintf(bak, BUFSIZ, "%s.bak", filename);

	if ((fp = fopen(filename, "r")) != NULL) {
		if (check_version(l, fp)) {
			logger_destroy();
			return ;
		}

		l->changes++;
		logger_readlogs(l, fp, filename);
	} else if ((fp = fopen(bak, "r")) != NULL) {
		fclose(fp);
		GDKmove(l->dir, LOGFILE, "bak", l->dir, LOGFILE, NULL);

		if ((fp = fopen(filename, "r")) != NULL) {
			if (check_version(l, fp)) {
				logger_destroy();
				return ;
			}

			l->changes++;
			logger_readlogs(l, fp, filename);
		}
	} else if ((fp = fopen(filename, "w")) == NULL) {
		if (!GDKcreatedir(filename)) {
			GDKerror("logger could not create log directory %s\n", l->dir);
			logger_destroy();
			return ;
		} else if ((fp = fopen(filename, "w")) == NULL) {
			GDKerror("logger could not create file %s\n", filename);
			logger_destroy();
			return ;
		}
		fprintf(fp, "%06d\n\n", CATALOG_VERSION);
		l->id ++;
		fprintf(fp, LLFMT "\n", l->id);
	} else {
		fprintf(fp, "%06d\n\n", CATALOG_VERSION);
		l->id ++;
		fprintf(fp, LLFMT "\n", l->id);
	}
	fclose(fp);
	l->tid = 1;
}

int 
logger_start(int debug)
{
	logger_new(debug);
	if (!l)
		return -1;
	if (logger_open(l) == SQL_ERR) {
		logger_destroy();
		return -1;
	}
	if (l->changes && 
	    (logger_restart() != SQL_OK ||
	    logger_cleanup() != SQL_OK)) {
		logger_destroy();
		return -1;
	}
	return 0;
}

static int
logger_exit(logger *logger)
{
	FILE *fp;
	char filename[BUFSIZ];

	logger_close(logger);
	if (GDKmove(logger->dir, LOGFILE, NULL, logger->dir, LOGFILE, "bak") < 0) {
		return SQL_ERR;
	}

	snprintf(filename, BUFSIZ, "%s%s", logger->dir, LOGFILE);
	if ((fp = fopen(filename, "w")) != NULL) {
		char ext[BUFSIZ];

		fprintf(fp, "%06d\n\n", CATALOG_VERSION);
		logger->id ++;

		if (logger_commit() < 0)
			return SQL_ERR;

		fprintf(fp, LLFMT "\n", logger->id);
		fclose(fp);

		/* atomic action, switch to new log, keep old for later 
		   cleanup actions 
		 */
		snprintf(ext, BUFSIZ, "bak-" LLFMT, logger->id);
		if (GDKmove(logger->dir, LOGFILE, "bak", logger->dir, LOGFILE, ext) < 0)
			 return SQL_ERR;
	} else {
		GDKerror("logger could not open %s\n", filename);
		return SQL_ERR;
	}
	return SQL_OK;
}

int
logger_restart(void)
{
	int res = 0;

	if ((res = logger_exit(l)) == SQL_OK)
		res = logger_open(l);

	return res;
}

void
logger_stop(void)
{
	logger_destroy();
}

int
logger_cleanup()
{
	char buf[BUFSIZ];
	char id[BUFSIZ];
	FILE *fp = NULL;

	snprintf(buf, BUFSIZ, "%s%s.bak-" LLFMT, l->dir, LOGFILE, l->id);
	if (l->debug & 1)
		fprintf(stderr, "logger_cleanup %s\n", buf);

	if ((fp = fopen(buf, "r")) == NULL)
		return SQL_ERR;

	/* skip catalog */
	while (fgets(id, BUFSIZ, fp) != NULL && id[0] != '\n')
		;

	while (fgets(id, BUFSIZ, fp) != NULL) {
		char *e = strchr(id, '\n');

		if (e)
			*e = 0;
		GDKunlink(l->dir, LOGFILE, id);
	}
	fclose(fp);
	snprintf(buf, BUFSIZ, "bak-" LLFMT, l->id);
	GDKunlink(l->dir, LOGFILE, buf);

	return SQL_OK;
}

int
logger_changes()
{
	return l->changes;
}

int
logger_sequence(int seq, lng *id)
{
	ptr p = BUNfnd(l->seq_ids, &seq);

	if (p) {
		*id = *(lng*)BUNtail(l->seq_ids, p);
		return 1;
	}
	return 0;
}

@-
Changes made to the BAT descriptor should be stored in the log files.
Actually, we need to save the descriptor file, perhaps we should simply
introduce a versioning scheme. 
@c
int
log_bat_persists(BAT *b, char *name)
{
	char *ha, *ta;
	int len;
	char buf[BUFSIZ];
	logformat lf;
	int havevoid = 0;
	int flag = (b->batPersistence == PERSISTENT)?SQL_LOG_USE:SQL_LOG_CREATE;

	lf.nr = 0;
	if (flag == SQL_LOG_USE)
		lf.nr = b->batCacheid;
	lf.flag = flag;
	l->changes++;
	if (log_write_format(&lf) == SQL_ERR || 
	    log_write_string(name) == SQL_ERR)
		return SQL_ERR;

	if (b->batPersistence == PERSISTENT) /* log SQL_LOG_USE only */
		return SQL_OK;

	ha = ATOMname(b->htype);
	if (b->htype == TYPE_void && BAThdense(b)) {
		ha = "vid";
		havevoid = 1;
	}
	ta = ATOMname(b->ttype);
	if (!havevoid && b->ttype == TYPE_void && BATtdense(b)) {
		ta = "vid";
	}
	len = snprintf(buf, BUFSIZ, "%s,%s", ha, ta);
	len++;			/* include EOS */
	if (!stream_writeInt(l->log, len) || 
	     stream_write(l->log, buf, 1, len) != (ssize_t) len)
		 return SQL_ERR;

	if (l->debug & 1)
		fprintf(stderr, "Logged new bat [%s,%s] %s " SZFMT "\n", ha, ta, name,
			BATcount(b));
	return log_bat(b, name);
}

int
log_bat_transient(char *name)
{
	logformat lf;

	lf.flag = SQL_LOG_DESTROY;
	lf.nr = 0;
	l->changes++;
	if (log_write_format(&lf) == SQL_ERR || 
	    log_write_string(name) == SQL_ERR)
		return SQL_ERR;

	if (l->debug & 1)
		fprintf(stderr, "Logged destroyed bat %s\n", name);
	return SQL_OK;
}

int
log_bat(BAT *b, char *name)
{
	int ok = GDK_SUCCEED;
	logformat lf;
	BUN p;

	if (l->debug & 128) {
		/* logging is switched off */
		return SQL_OK;
	}

	lf.nr = (int)(BUNindex(b, BUNlast(b)) - BUNindex(b, b->batInserted));
	l->changes += lf.nr;

	if (lf.nr) {
		int (*wh) (ptr, stream *, size_t) = BATatoms[b->htype].atomWrite;
		int (*wt) (ptr, stream *, size_t) = BATatoms[b->ttype].atomWrite;

		lf.flag = SQL_LOG_INSERT;
		if (log_write_format(&lf) == SQL_ERR || 
		    log_write_string(name) == SQL_ERR)
			return SQL_ERR;

		if (b->htype == TYPE_void && b->ttype < TYPE_str && !VIEWparent(b)) {
			ptr t = BUNtail(b, b->batInserted);
			ok = wt(t, l->log, lf.nr);
		} else {
			for (p = b->batInserted; p < BUNlast(b) && ok == GDK_SUCCEED; p = BUNnext(b, p)) {
				ptr h = BUNhead(b, p);
				ptr t = BUNtail(b, p);
				ok = wh(h, l->log, 1);
				ok = (ok == GDK_FAIL) ? ok : wt(t, l->log, 1);
			}
		}

		if (l->debug)
			fprintf(stderr, "Logged %s %d inserts\n", name, lf.nr);
	}
	lf.nr = (int)(BUNindex(b, b->batFirst) - BUNindex(b, b->batDeleted));
	l->changes += lf.nr;

	if (lf.nr && ok == GDK_SUCCEED) {
		int (*wh) (ptr, stream *, size_t) = BATatoms[b->htype].atomWrite;
		int (*wt) (ptr, stream *, size_t) = BATatoms[b->ttype].atomWrite;

		lf.flag = SQL_LOG_DELETE;
		if (log_write_format(&lf) == SQL_ERR || 
		    log_write_string(name) == SQL_ERR)
			return SQL_ERR;

		for (p = b->batDeleted; p < b->batFirst && ok == GDK_SUCCEED; p = BUNnext(b, p)) {
			ptr h = BUNhead(b, p);
			ptr t = BUNtail(b, p);
			ok = wh(h, l->log, 1);
			ok = (ok == GDK_FAIL) ? ok : wt(t, l->log, 1);
		}

		if (l->debug)
			fprintf(stderr, "Logged %s %d deletes\n", name, lf.nr);
	}
	BATcommit(b);

	return (ok == GDK_SUCCEED) ? SQL_OK : SQL_ERR;
}

int
log_bat_clear(char *name)
{
	int ok = GDK_SUCCEED;
	logformat lf;

	if (l->debug & 128) {
		/* logging is switched off */
		return SQL_OK;
	}

	lf.nr = 1;
	l->changes += lf.nr;

	lf.flag = SQL_LOG_CLEAR;
	if (log_write_format(&lf) == SQL_ERR || 
	    log_write_string(name) == SQL_ERR)
		return SQL_ERR;

	return (ok == GDK_SUCCEED) ? SQL_OK : SQL_ERR;
}

int
log_tstart(void)
{
	logformat lf;

	lf.flag = SQL_LOG_START;
	lf.nr = ++l->tid;

	if (l->debug)
		fprintf(stderr, "log_tstart %d\n", l->tid);

	return log_write_format(&lf);
}

int
log_tend(void)
{
	logformat lf;

	if (l->debug)
		fprintf(stderr, "log_tend %d\n", l->tid);

	lf.flag = SQL_LOG_END;
	lf.nr = l->tid;
	if (log_write_format(&lf) == SQL_ERR || 
	    stream_flush(l->log) ||
	    stream_fsync(l->log))
		 return SQL_ERR;

	return SQL_OK;
}

/* a transaction in it self */
int
log_sequence(int seq, lng id)
{
	logformat lf;

	lf.flag = SQL_LOG_OID;
	lf.nr = seq;

	if (l->debug)
		fprintf(stderr, "log_sequence %d" LLFMT "\n", seq, id);

	if (BUNfnd(l->seq_ids, &seq)) {
		BUNdelHead(l->seq_ids, &seq, FALSE);
	}
	BUNins(l->seq_ids, &seq, &id, FALSE);

	if (log_write_format(&lf) == SQL_ERR ||
	    !stream_writeLng(l->log, id) ||
	    stream_flush(l->log) ||
	    stream_fsync(l->log))
		 return SQL_ERR;
	return SQL_OK;
}

static int
bm_commit(void)
{
	BUN p;
	BAT *b = l->catalog;

	/* remove the destroyed bats */
	for (p = b->batDeleted; p < b->batFirst; p = BUNnext(b, p)) {
		bat bid = *(log_bid *) BUNhead(b, p);
		BAT *b = bat_descriptor(bid, "bm_commit");

		BATmode(b, TRANSIENT);
		bat_decref(bid, TRUE);
		bat_destroy(b);
	}

	for (p = b->batInserted; p < BUNlast(b); p = BUNnext(b, p)) {
		log_bid bid = *(log_bid *) BUNhead(b, p);
		BAT *b = bat_descriptor(bid, "bm_commit");

		BATmode(b, PERSISTENT);
		bat_destroy(b);
	}
	if (bm_subcommit(l->catalog) != 0)	/* save new bats */
		return SQL_ERR;
	return 0;
}

static void
bm_abort(void)
{
	BUN p;
	BAT *b = l->catalog;

	/* remove the created bats */
	for (p = b->batInserted; p < BUNlast(b); p = BUNnext(b, p)) {
		bat bid = *(log_bid *) BUNhead(b, p);

		bat_decref(bid, TRUE);
	}
	for (p = BUNfirst(b); p < b->batInserted; p = BUNnext(b, p)) {
		log_bid bid = *(log_bid *) BUNhead(b, p);
		BAT *b = bat_descriptor(bid, "bm_abort");

		BATundo(b);
		BATcommit(b);
		bat_destroy(b);
	}
	BATundo(l->catalog);
}

log_bid
logger_add_bat(BAT *b, char *name)
{
	log_bid bid = logger_find_bat(name);

	if (bid) {
		if (bid != b->batCacheid) 
			BUNdelHead(l->catalog, &bid, FALSE);
		else
			return bid;
	}
	bid = b->batCacheid;
	if (l->debug)
		printf("create %s\n", name);
	BUNins(l->catalog, &bid, name, FALSE);
	bat_incref(bid, TRUE, "logger_add_bat");
	return bid;
}

void
logger_del_bat(log_bid bid)
{
	BUNdelHead(l->catalog, &bid, FALSE);
}

log_bid
logger_find_bat(char *name)
{
	BAT *r_catalog = BATmirror(l->catalog);
	log_bid res = 0;
	BUN p = BUNfnd(r_catalog, name);

	if (p) 
		res = *(log_bid *) BUNtail(r_catalog, p);
	return res;
}
