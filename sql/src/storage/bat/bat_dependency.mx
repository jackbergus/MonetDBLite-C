@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2007 CWI.
@' All Rights Reserved.

@f bat_dependency
@a R.A. Goncalves

@h
#ifndef BAT_DEPEND_H
#define BAT_DEPEND_H

#include "sql_types.h"
#include "sql_backend.h"
#include "bat_sequence.h"
#include "bat_store.h"

extern int create_dependency_table(sql_trans *tr, sql_schema *s);
extern sql_column* create_column(sql_trans *tr, sql_table* t, char* table, char *type, int digits);

#endif /*BAT_DEPEND_H */
@c

#include "sql_config.h"
#include "bat_dependency.h"



sql_column*
create_column(sql_trans *tr, sql_table* t, char* table, char *type, int digits)
{
	sql_subtype tpe;
        
	if (!sql_find_subtype(&tpe, type, digits, 0))
                return NULL;
	
	return sql_trans_create_column(tr, t, table, &tpe);
}

/*Function to create the table to control the dependencies*/
int
create_dependency_table(sql_trans *tr, sql_schema *s){
        sql_table *t;
        t = sql_trans_create_table(tr, s, "dependencies", 1, 0, 0, 1);
        
	create_column(tr, t, "id", "int",32);
	create_column(tr, t, "depend_id", "int",32);
	create_column(tr, t, "depend_type", "smallint",16);
        return 0;
}

/*Function to create a dependency*/
void
sql_trans_create_dependency(sql_trans* tr, int id, int depend_id, short depend_type)
{
	sql_schema * s = find_sql_schema(tr, "sys");
	sql_table *t = find_sql_table(s, "dependencies");
	sql_column *c_id = find_sql_column(t, "id");
	sql_column *c_dep_id = find_sql_column(t, "depend_id");
	sql_column *c_dep_type = find_sql_column(t, "depend_type");

	if (column_find_row(tr, c_id, &id, c_dep_id, &depend_id, c_dep_type, &depend_type, NULL) == -1)
		table_insert(tr, t, &id, &depend_id, &depend_type);
}

/*Function to drop the dependencies on depend_id*/
void
sql_trans_drop_dependencies(sql_trans* tr, int depend_id)
{
	ssize_t rid;
	list *id_list = NULL;
	node *node_id = NULL;
	sql_schema * s = find_sql_schema(tr, "sys");
	sql_table* t = find_sql_table(s, "dependencies");

	sql_column * dep_id = find_sql_column(t, "id");
	sql_column * dep_dep_id = find_sql_column(t, "depend_id");
	
	id_list = table_select_column(tr, dep_id, dep_dep_id, &depend_id, NULL);
	node_id = id_list->h;
	
	while (node_id) {
		rid = column_find_row(tr, dep_id, node_id->data, dep_dep_id, &depend_id, NULL);
		if (rid != -1)
			table_delete(tr, t, rid);
		node_id = node_id->next;
	}

	list_destroy(id_list);
}
/*It returns a list with depend_id_1, depend_type_1, depend_id_2, depend_type_2, ....*/
list*
sql_trans_get_dependencies(sql_trans* tr, int id, short depend_type)
{
	node *id_node, *type_node, *trig_node;
	sql_schema *s;
	sql_table *dep, *triggers;
	sql_column *dep_id_col, *dep_dep_id, *dep_dep_type, *tri_id, *table_id;
	list *dep_id, *dep_type, *trig_list, *dep_list = list_create((fdestroy) NULL); 

	s = find_sql_schema(tr, "sys");	

	dep = find_sql_table(s, "dependencies");

	dep_id_col = find_sql_column(dep, "id");
	dep_dep_id = find_sql_column(dep, "depend_id");
	dep_dep_type = find_sql_column(dep, "depend_type");

	dep_id = table_select_column(tr, dep_dep_id, dep_id_col, &id, NULL);
	dep_type = table_select_column(tr, dep_dep_type, dep_id_col, &id, NULL);

	id_node = dep_id->h;	
	type_node = dep_type->h;	

	while (id_node && type_node)
	{
	
		list_append(dep_list, id_node->data);
		list_append(dep_list, type_node->data);
		id_node = id_node->next;
		type_node = type_node->next;
	}
	list_destroy(dep_id);
	list_destroy(dep_type);

	if (depend_type == TABLE_DEPENDENCY) {
		triggers = find_sql_table(s, "triggers");
		table_id = find_sql_column(triggers, "table_id");
		tri_id = find_sql_column(triggers, "id");

		depend_type = TRIGGER_DEPENDENCY;
		trig_list = table_select_column(tr, tri_id, table_id, &id, NULL);
		trig_node = trig_list->h;
		while (trig_node) {
			list_append(dep_list, trig_node->data);
			list_append(dep_list, &depend_type);
			trig_node = trig_node->next;
		}
		
		list_destroy(trig_list);
	}
	return dep_list;
}

/*It checks if there are dependency between two ID's */
int
sql_trans_get_dependency_type(sql_trans *tr, int id, short depend_type)
{
	ssize_t rid;
	sql_schema *s;
	sql_table *dep;
	sql_column *dep_id, *dep_dep_id, *dep_dep_type;

	s = find_sql_schema(tr, "sys");	

	dep = find_sql_table(s, "dependencies");

	dep_id = find_sql_column(dep, "id");
	dep_dep_id = find_sql_column(dep, "depend_id");
	dep_dep_type = find_sql_column(dep, "depend_type");

	rid = column_find_row(tr, dep_id, &id, dep_dep_type, &depend_type, NULL);
	if (rid != -1)	
		return *(int *) column_find_value(tr, dep_dep_id, rid);
	else return -1;
}

/*It checks if there are dependency between two ID's */
int
sql_trans_check_dependency(sql_trans *tr, int id, int depend_id, short depend_type)
{
	ssize_t rid;
	sql_schema *s;
	sql_table *dep;
	sql_column *dep_id, *dep_dep_id, *dep_dep_type;

	s = find_sql_schema(tr, "sys");	

	dep = find_sql_table(s, "dependencies");

	dep_id = find_sql_column(dep, "id");
	dep_dep_id = find_sql_column(dep, "depend_id");
	dep_dep_type = find_sql_column(dep, "depend_type");

	rid = column_find_row(tr, dep_id, &id, dep_dep_id, &depend_id, dep_dep_type, &depend_type, NULL);
	if (rid != -1)	
		return 1;
	else return 0;
}



/*Schema on users*/

list *
sql_trans_schema_user_dependencies(sql_trans *tr, int schema_id)
{
	short type = USER_DEPENDENCY;
	list *l = list_create((fdestroy) NULL);
	list *dep_list = backend_schema_user_dependencies(tr, schema_id);
	node *n = dep_list->h;
	
	while (n)
	{
		list_append(l,n->data);
		list_append(l,&type);
		n = n->next;
	}
	list_destroy(dep_list);
	return l;
}

/*owner on schemas*/
list *
sql_trans_owner_schema_dependencies(sql_trans *tr, int owner_id)
{
	sql_schema * s = find_sql_schema(tr, "sys");
	sql_table *t = find_sql_table(s, "schemas");
	sql_column *owner = find_sql_column(t, "owner");
	sql_column *schema_id = find_sql_column(t, "id");
	short type = SCHEMA_DEPENDENCY;
	list *l = list_create((fdestroy) NULL);
	list *dep_list = table_select_column(tr, schema_id, owner, &owner_id, NULL);
	node *n = dep_list->h;
	
	while (n)
	{
		list_append(l,n->data);
		list_append(l,&type);
		n = n->next;
	}
	list_destroy(dep_list);
	return l;
}

/*Function on Functions*/



