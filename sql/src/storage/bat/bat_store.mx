@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2006 CWI.
@' All Rights Reserved.

@f bat_store

@h
#ifndef BATSTORE_H
#define BATSTORE_H

#include "sql_storage.h"
#include "bat_dependency.h"
#include <logger.h>

extern logger *sql_logger;

#define isNew(x)  (x->base.flag == TR_NEW)
#define isTemp(x) (isNew(x)||x->t->persistence!=SQL_PERSIST)
#define isTempTable(x)   (x->persistence!=SQL_PERSIST)
#define isGlobalTable(x) (x->persistence!=SQL_LOCAL_TEMP)
#define isGlobalTemp(x) (x->persistence==SQL_GLOBAL_TEMP)
#define isTempSchema(x)  (strcmp(x->base.name,"tmp") == 0)

#define Ccc(c,s1,s2,t) (c)?s1 "_" t:s2 "_" t
#define Dcc(c,s1,s2,t) (c)?"D_" s1 "_" t:"D_" s2 "_" t
#define Ucc(c,s1,s2,t) (c)?"U_" s1 "_" t:"U_" s2 "_" t

#define bat_set_access(b,access) b->P->restricted = access
#define bat_clear(b) bat_set_access(b,BAT_WRITE);BATclear(b);bat_set_access(b,BAT_READ)

extern BAT *bind_bats(sql_trans *tr, sql_column *c);
extern BAT *bind_idxs(sql_trans *tr, sql_idx * i);

extern BAT *bind_bat(sql_trans *tr, sql_column *c, int access);
extern BAT *bind_ubat(sql_trans *tr, sql_column *c, int access);
extern BAT *bind_idx(sql_trans *tr, sql_idx * i, int access);
extern BAT *bind_uidx(sql_trans *tr, sql_idx * i, int access);
extern BAT *bind_dbat(sql_trans *tr, sql_table *t, int access);

extern BAT *append_bat(sql_trans *tr, sql_column *c, int access, BAT *b);
extern BAT *append_ubat(sql_trans *tr, sql_column *c, int access, BAT *b);
extern BAT *append_idx(sql_trans *tr, sql_idx * i, int access, BAT *b);
extern BAT *append_uidx(sql_trans *tr, sql_idx * i, int access, BAT *b);

extern BAT *temp_descriptor(log_bid b);

#endif /*BATSTORE_H */
@c
#include "bat_store.h"
#include "sql_types.h"
#include "sql_backend.h"
#include "bat_bm.h"
#include "bat_sequence.h"
#include <bat.h>

/* version 03.02.01 of catalog */
#define CATALOG_VERSION 30201

logger *sql_logger = NULL;
static MT_Lock bs_lock;
static lng store_oid = 0;
static int nr_sessions = 0;
static int nr_active = 0;
static int transactions = 0;
static sql_trans *gtrans = NULL;
static int schema_number = 0; /* each committed schema change triggers a new
				 schema number (session wise unique number) */
static int bs_debug = 0;

#define MAX_SPARES 32
static sql_trans *spare_trans[MAX_SPARES];
static int spares = 0;

int
key_cmp(sql_key *k, sqlid *id)
{
	if (k && id &&k->base.id == *id)
		return 0;
	return 1;
}

static int stamp = 1;

static int timestamp () {
	return stamp++;
}

static void
temp_destroy(log_bid b)
{
	BBPdecref(b, TRUE);
}

static void
temp_dup(log_bid b)
{
	BBPincref(b, TRUE);
}

static log_bid
temp_create(BAT *b)
{
	temp_dup(b->batCacheid);
	return b->batCacheid;
}

BAT *
temp_descriptor(log_bid b)
{
	return BATdescriptor((bat) b);
}

static log_bid
temp_copy(log_bid b, int temp)
{
/* make a copy of b, if temp is set only create a empty bat */
	BAT *o = temp_descriptor(b);
	BAT *c;
	log_bid r;

	if (bs_debug&4)
		fprintf(stderr, "temp_copy %d\n", b);

	if (!temp) {
		c = bat_copy(o, "temp_copy");
		BATcommit(c);
	} else {
		c = bat_new(o->htype, o->ttype, BATSIZE, "temp_copy");
	}
	r = temp_create(c);
	bat_destroy(c);
	bat_destroy(o);
	return r;
}

BAT *
bind_bats(sql_trans *tr, sql_column *c)
{
	BAT *b = bat_new(TYPE_int, TYPE_bat, 4, "bind_bats");
	int access;

	(void)tr;
	access = 0;
	BUNins(b, &access, &c->bat.bid, FALSE);
	if (c->bat.ibid) {
		access = 0; /* inserts */
		BUNins(b, &access, &c->bat.ibid, FALSE);
	}
	if (c->bat.ubid) {
		access = 1; /* deletes */
		BUNins(b, &access, &c->bat.ubid, FALSE);
		access = 0; /* inserts */
		BUNins(b, &access, &c->bat.ubid, FALSE);
	}
	if (c->t->dbid) {
		access = 1; /* deletes */
		BUNins(b, &access, &c->t->dbid, FALSE);
	}
	return b;
}

BAT *
bind_idxs(sql_trans *tr, sql_idx *i)
{
	BAT *b = bat_new(TYPE_int, TYPE_bat, 4, "bind_idxs");
	int access;

	(void)tr;
	access = 0;
	BUNins(b, &access, &i->bat.bid, FALSE);
	if (i->bat.ibid) {
		access = 0; /* inserts */
		BUNins(b, &access, &i->bat.ibid, FALSE);
	}
	if (i->bat.ubid) {
		access = 1; /* deletes */
		BUNins(b, &access, &i->bat.ubid, FALSE);
		access = 0; /* inserts */
		BUNins(b, &access, &i->bat.ubid, FALSE);
	}
	if (i->t->dbid) {
		access = 1; /* deletes */
		BUNins(b, &access, &i->t->dbid, FALSE);
	}
	return b;
}

BAT *
bind_bat(sql_trans *tr, sql_column *c, int access)
{
	BAT *b;

	if (isTemp(c) || access == INS || access == RD_INS || !c->bat.bid) {
		assert(c->bat.ibid);
		b = temp_descriptor(c->bat.ibid);
	} else {
		b = temp_descriptor(c->bat.bid);
		bat_set_access(b, BAT_READ);
		assert(access==RDONLY);
	}
	b->batDirty |= 2;
	if (access == INS || access == UPD) {
		bat_set_access(b, BAT_WRITE);
		c->base.wtime = c->t->base.wtime = c->t->s->base.wtime = tr->wtime = tr->stime;
	}
	c->base.rtime = c->t->base.rtime = c->t->s->base.rtime = tr->rtime = tr->stime;
	assert(b);
	return b;
}

BAT *
append_bat(sql_trans *tr, sql_column *c, int access, BAT *i)
{
	BAT *b = NULL;

	if (isTemp(c) || access == INS || !c->bat.bid) {
		assert(c->bat.ibid);
		b = temp_descriptor(c->bat.ibid);
		if (BATcount(b) == 0 && !VIEWparent(i) && i->htype == TYPE_void){
			bat_destroy(b);
			temp_destroy(c->bat.ibid);
			c->bat.ibid = temp_create(i);
			b = temp_descriptor(c->bat.ibid);
		} else {
			BATappend(b, i, TRUE);
		}
	} else {
		assert(0); /* RDONLY appends ???? */
	}
	assert(b != NULL);
	b->batDirty |= 2;
	if (access == INS) 
		c->base.wtime = c->t->base.wtime = c->t->s->base.wtime = tr->wtime = tr->stime;
	c->base.rtime = c->t->base.rtime = c->t->s->base.rtime = tr->rtime = tr->stime;
	return b;
}


BAT *
bind_ubat(sql_trans *tr, sql_column *c, int access)
{
	BAT *b;

	b = temp_descriptor(c->bat.ubid);
	b->batDirty |= 2;
	assert(b);
	c->t->s->base.rtime = c->t->base.rtime = c->base.rtime = tr->stime;
	if (access == INS || access == UPD) {
		bat_set_access(b, BAT_WRITE);
		c->base.wtime = c->t->base.wtime = c->t->s->base.wtime = tr->wtime = tr->stime;
	}
	return b;
}

BAT *
append_ubat(sql_trans *tr, sql_column *c, int access, BAT *i)
{
	BAT *b;

	b = temp_descriptor(c->bat.ubid);
	if (BATcount(b) == 0 && !VIEWparent(i)){ 
		bat_destroy(b);
		temp_destroy(c->bat.ubid);
		c->bat.ubid = temp_create(i);
		b = temp_descriptor(c->bat.ubid);
	} else {
		BATappend(b, i, TRUE);
	}
	assert(b);
	b->batDirty |= 2;
	c->t->s->base.rtime = c->t->base.rtime = c->base.rtime = tr->stime;
	if (access == INS || access == UPD) 
		c->base.wtime = c->t->base.wtime = c->t->s->base.wtime = tr->wtime = tr->stime;
	return b;
}

BAT *
bind_dbat(sql_trans *tr, sql_table *t, int access)
{
	BAT *b;

	b = temp_descriptor(t->dbid);
	b->batDirty |= 2;
	t->s->base.rtime = t->base.rtime = tr->stime;
	assert(access!=RD_UPD && access != UPD);
	if (access == INS) {
		bat_set_access(b, BAT_WRITE);
		t->base.wtime = t->s->base.wtime = tr->wtime = tr->stime;
	}
	assert(b);
	return b;
}

BAT *
bind_idx(sql_trans *tr, sql_idx * i, int access)
{
	BAT *b;

	if (isTemp(i) || access == INS || access == RD_INS || !i->bat.bid) {
		assert(i->bat.ibid);
		b = temp_descriptor(i->bat.ibid);
	} else {
		b = temp_descriptor(i->bat.bid);
		bat_set_access(b, BAT_READ);
		assert(access==RDONLY || access == RD_UPD);
	}
	b->batDirty |= 2;
	if (access == INS || access == UPD) {
		bat_set_access(b, BAT_WRITE);
		i->base.wtime = i->t->base.wtime = i->t->s->base.wtime = tr->wtime = tr->stime;
	}
	i->base.rtime = i->t->base.rtime = i->t->s->base.rtime = tr->rtime = tr->stime;
	assert(b);
	return b;
}

BAT *
append_idx(sql_trans *tr, sql_idx * i, int access, BAT *ib)
{
	BAT *b = NULL;

	if (isTemp(i) || access == INS || !i->bat.bid) {
		assert(i->bat.ibid);
		b = temp_descriptor(i->bat.ibid);
		if (BATcount(b) == 0 && !VIEWparent(ib) && ib->htype == TYPE_void){ 
			bat_destroy(b);
			temp_destroy(i->bat.ibid);
			i->bat.ibid = temp_create(ib);
			b = temp_descriptor(i->bat.ibid);
		} else {
			BATappend(b, ib, TRUE);
		}
	} else {
		assert(0); /* RDONLY appends ???? */
	}
	assert(b != NULL);
	b->batDirty |= 2;
	if (access == INS) 
		i->base.wtime = i->t->base.wtime = i->t->s->base.wtime = tr->wtime = tr->stime;
	i->base.rtime = i->t->base.rtime = i->t->s->base.rtime = tr->rtime = tr->stime;
	return b;
}

BAT *
bind_uidx(sql_trans *tr, sql_idx * i, int access)
{
	BAT *b;

	b = temp_descriptor(i->bat.ubid);
	b->batDirty |= 2;
	assert(b);
	i->base.rtime = i->t->base.rtime = i->t->s->base.rtime = tr->rtime = tr->stime;
	if (access == INS || access == UPD) {
		bat_set_access(b, BAT_WRITE);
		i->base.wtime = i->t->base.wtime = i->t->s->base.wtime = tr->wtime = tr->stime;
	}
	return b;
}

BAT *
append_uidx(sql_trans *tr, sql_idx * i, int access, BAT *ib)
{
	BAT *b;

	b = temp_descriptor(i->bat.ubid);
	if (BATcount(b) == 0 && !VIEWparent(ib)){ 
		bat_destroy(b);
		temp_destroy(i->bat.ubid);
		i->bat.ubid = temp_create(ib);
		b = temp_descriptor(i->bat.ibid);
	} else {
		BATappend(b, ib, TRUE);
	}
	assert(b);
	b->batDirty |= 2;
	if (access == INS || access == UPD) 
		i->base.wtime = i->t->base.wtime = i->t->s->base.wtime = tr->wtime = tr->stime;
	i->base.rtime = i->t->base.rtime = i->t->s->base.rtime = tr->rtime = tr->stime;
	return b;
}

static size_t
append_inserted(BAT *b, BAT *i )
{
	size_t nr = 0;
	BUN r;

	for (r = i->batInserted; r < BUNlast(i); r = BUNnext(i, r)) {
		BUNappend(b, BUNtail(i,r), TRUE);
		nr++;
	}
	return nr;
}

static size_t
copy_inserted(BAT *b, BAT *i )
{
	size_t nr = 0;
	BUN r;

	for (r = i->batInserted; r < BUNlast(i); r = BUNnext(i, r)) {
		BUNins(b, BUNhead(i,r), BUNtail(i,r), TRUE);
		nr++;
	}
	return nr;
}


/* probably not needed any more */
static void
update_table_bat(BAT *b, BAT *ub, BAT *db)
{
	if (ub && BATcount(ub)) {
		void_replace_bat(b, ub, TRUE);
		BATclear(ub);
		BATcommit(ub);
	}
	(void)db;
}

void
kc_destroy(sql_kc *kc)
{
	_DELETE(kc);
}

void
key_destroy(sql_key *k)
{
	/* remove key from schema */
	list_remove_data(k->t->s->keys,k);
	if (k->type == ukey || k->type == pkey) {
		sql_ukey *uk = (sql_ukey *) k;
		if (uk->keys)
			list_destroy(uk->keys);
	}
	list_destroy(k->columns);
	base_destroy(&k->base);
	_DELETE(k);
}

void
idx_destroy(sql_idx * i)
{
	/* remove idx from schema */
	list_remove_data(i->t->s->idxs, i);
	if (i->bat.name)
		_DELETE(i->bat.name);
	if (i->bat.uname)
		_DELETE(i->bat.uname);
	if (i->bat.ibid)
		temp_destroy(i->bat.ibid);
	if (i->bat.ubid)
		temp_destroy(i->bat.ubid);
	if (i->bat.bid) 
		temp_destroy(i->bat.bid);

	list_destroy(i->columns);
	base_destroy(&i->base);
	_DELETE(i);
}

void
trigger_destroy(sql_trigger *tr)
{
	/* remove trigger from schema */
	list_remove_data(tr->t->s->triggers, tr);
	if (tr->old_name)
		_DELETE(tr->old_name);
	if (tr->new_name)
		_DELETE(tr->new_name);
	if (tr->condition)
		_DELETE(tr->condition);
	_DELETE(tr->statement);
	if (tr->columns)
		list_destroy(tr->columns);
	base_destroy(&tr->base);
	_DELETE(tr);
}

void
column_destroy(sql_column *c)
{
	if (c->bat.name)
		_DELETE(c->bat.name);
	if (c->bat.uname)
		_DELETE(c->bat.uname);
	if (c->bat.ibid)
		temp_destroy(c->bat.ibid);
	if (c->bat.ubid)
		temp_destroy(c->bat.ubid);
	if (c->bat.bid) 
		temp_destroy(c->bat.bid);

	if (c->def)
		_DELETE(c->def);
	base_destroy(&c->base);
	_DELETE(c);
}

void
table_destroy(sql_table *t)
{
	cs_destroy(&t->keys);
	cs_destroy(&t->idxs);
	cs_destroy(&t->triggers);
	cs_destroy(&t->columns);
	if (t->dname)
		_DELETE(t->dname);
	if (t->dbid)
		temp_destroy(t->dbid);

	base_destroy(&t->base);
	if (t->query)
		_DELETE(t->query);
	_DELETE(t);
}

void
seq_destroy(sql_sequence *s)
{
	base_destroy(&s->base);
	_DELETE(s);
}

void
schema_destroy(sql_schema *s)
{
	cs_destroy(&s->tables);
	cs_destroy(&s->funcs);
	cs_destroy(&s->types);
	list_destroy(s->keys);
	list_destroy(s->idxs);
	list_destroy(s->triggers);
	base_destroy(&s->base);
	_DELETE(s);
}

/*#define STORE_DEBUG 1 */

sql_trans *
sql_trans_destroy(sql_trans *t)
{
	sql_trans *res = t->parent;

	transactions--;
#ifdef STORE_DEBUG
	fprintf(stderr, "destroy trans (%p)\n", t);
#endif

	if (res == gtrans && spares < MAX_SPARES && !t->name) {
#ifdef STORE_DEBUG
		fprintf(stderr, "spared (%d) trans (%p)\n", spares, t);
#endif
		spare_trans[spares++] = t;
		return res;
	}

	if (t->name) {
		_DELETE(t->name);
		t->name = NULL;
	}

	cs_destroy(&t->schemas);

	_DELETE(t);
	return res;
}

static void
destroy_spare_transactions() 
{
	int i, s = spares;

	spares = MAX_SPARES; /* ie now there not spared anymore */
	for (i = 0; i < s; i++) 
		sql_trans_destroy(spare_trans[i]);
}

static int
tr_flag(sql_base * b, int flag)
{
	if (flag == TR_OLD)
		return flag;
	return b->flag;
}

static BAT *
get_bat(char *name)
{
	log_bid bid = logger_find_bat(sql_logger, name);

	if (bid) {
		BAT *b = temp_descriptor(bid);
		assert(b);
		return b;
	}
	return NULL;
}


static void
load_keycolumn(sql_trans *tr, BAT *columns, BUN j, sql_key *k)
{
	sql_kc *kc = NEW(sql_kc);
	BAT *kc_col = get_bat("sys_keycolumns_column");
	BAT *kc_trunc = get_bat("sys_keycolumns_trunc");
	ptr lid = BUNhead(columns, j);
	char *name = bun_find(kc_col, lid);
	int trunc = *(int *) bun_find(kc_trunc, lid);
	sql_column *c = find_sql_column(k->t, name);

	assert(c);

	(void)tr;
	kc->c = c;
	kc->trunc = trunc;
	list_append(k->columns, kc);

	bat_destroy(kc_col);
	bat_destroy(kc_trunc);
}

static sql_key *
load_key(sql_trans *tr, BAT *keys, BUN j, sql_table *t)
{
	size_t ccnt;
	BAT *cols, *rcols;
	BAT *key_id = get_bat("sys_keys_id");
	BAT *key_tpe = get_bat("sys_keys_type");
	BAT *key_name = get_bat("sys_keys_name");
	BAT *key_rkey = get_bat("sys_keys_rkey");
	BAT *kc_id = get_bat("sys_keycolumns_id");
	BAT *kc_nr = get_bat("sys_keycolumns_nr");
	BAT *D_keycolumns = get_bat("D_sys_keycolumns");
	ptr lid = BUNhead(keys, j);
	key_type ktype = (key_type) *(int *) bun_find(key_tpe, lid);
	char *name = (char *) bun_find(key_name, lid);
	sql_key *nk = (ktype != fkey) ? (sql_key *) NEW(sql_ukey)
	    : (sql_key *) NEW(sql_fkey);
	BUN p, q;
	node *n;

	base_init(&nk->base, *(sqlid *) bun_find(key_id, lid), TR_OLD, name);
	nk->type = ktype;
	nk->columns = list_create((fdestroy) &kc_destroy);
	nk->t = t;

	if (ktype == ukey || ktype == pkey) {
		sql_ukey *uk = (sql_ukey *) nk;

		uk->keys = NULL;

		if (ktype == pkey)
			t->pkey = uk;
	} else {
		sql_fkey *fk = (sql_fkey *) nk;

		fk->rkey = NULL;
	}

	cols = BATselect(kc_id, (ptr) &nk->base.id, (ptr) &nk->base.id);
	rcols = BATkdiff(cols, BATmirror(D_keycolumns));
	bat_destroy(cols);
	cols = rcols;

	rcols = BATsemijoin(kc_nr, cols);
	bat_destroy(cols);
	cols = BATmirror(rcols);
	rcols = BATsort(cols);
	bat_destroy(cols);
	cols = BATmirror(rcols);

	ccnt = BATcount(cols);
	if (ccnt) {
		BATloop(cols, p, q)
		    load_keycolumn(tr, cols, p, nk);
	}
	bat_destroy(cols);

	/* find idx with same name */
	n = list_find_name(nk->t->s->idxs, nk->base.name);
	if (n) {
		nk->idx = (sql_idx *) n->data;
		nk->idx->key = nk;
	}

	if (ktype == fkey) {
		sql_fkey *fk = (sql_fkey *) nk;
		sqlid rkey = *(sqlid *) bun_find(key_rkey, lid);
		node *n = list_find(t->s->keys, &rkey, (fcmp) &key_cmp);

		if (n) {
			sql_ukey *uk = n->data;

			fk->rkey = uk;
			if (!uk->keys)
				uk->keys = list_create(NULL);
			list_append(uk->keys, fk);
		}
	} else {		/* could be a set of rkeys */
		sql_ukey *uk = (sql_ukey *) nk;
		BAT *keys = BATselect(key_rkey, (ptr) &nk->base.id, (ptr) &nk->base.id);

		BATloop(keys, p, q) {
			ptr fkey_lid = (sqlid *) BUNhead(keys, p);
			sqlid fkey = *(sqlid *) bun_find(key_id, fkey_lid);
			node *n = list_find(t->s->keys, &fkey, (fcmp) &key_cmp);

			if (n) {
				sql_fkey *fk = n->data;

				if (!uk->keys)
					uk->keys = list_create(NULL);
				list_append(uk->keys, fk);
				fk->rkey = uk;
			}
		}
		BBPreclaim(keys);
	}

	bat_destroy(key_id);
	bat_destroy(key_tpe);
	bat_destroy(key_name);
	bat_destroy(key_rkey);
	bat_destroy(kc_id);
	bat_destroy(kc_nr);
	bat_destroy(D_keycolumns);
	return nk;
}

static void
load_idxcolumn(sql_trans *tr, BAT *columns, BUN j, sql_idx * i)
{
	sql_kc *kc = NEW(sql_kc);
	BAT *kc_col = get_bat("sys_keycolumns_column");
	BAT *kc_trunc = get_bat("sys_keycolumns_trunc");
	ptr lid = BUNhead(columns, j);
	char *name = bun_find(kc_col, lid);
	int trunc = *(int *) bun_find(kc_trunc, lid);
	sql_column *c = find_sql_column(i->t, name);

	assert(c);

	(void)tr;
	kc->c = c;
	if (i->type == unique) 
		c->unique = (BATcount(columns)>0);
	kc->trunc = trunc;
	list_append(i->columns, kc);

	bat_destroy(kc_col);
	bat_destroy(kc_trunc);
}

static sql_idx *
load_idx(sql_trans *tr, BAT *idxs, BUN j, sql_table *t)
{
	char bname[BUFSIZ];
	size_t ccnt;
	BAT *b;
	BAT *cols, *rcols;
	BAT *idx_id = get_bat("sys_idxs_id");
	BAT *idx_tpe = get_bat("sys_idxs_type");
	BAT *idx_name = get_bat("sys_idxs_name");
	BAT *kc_id = get_bat("sys_keycolumns_id");
	BAT *kc_nr = get_bat("sys_keycolumns_nr");
	BAT *D_keycolumns = get_bat("D_sys_keycolumns");
	ptr lid = BUNhead(idxs, j);
	idx_type itype = (idx_type) * (int *) bun_find(idx_tpe, lid);
	char *name = (char *) bun_find(idx_name, lid);
	sql_idx *ni = NEW(sql_idx);
	BUN p, q;

	base_init(&ni->base, *(sqlid *) bun_find(idx_id, lid), TR_OLD, name);
	ni->type = itype;

	ni->columns = list_create((fdestroy) &kc_destroy);
	ni->t = t;
	ni->key = NULL;

	cols = BATselect(kc_id, (ptr) &ni->base.id, (ptr) &ni->base.id);
	rcols = BATkdiff(cols, BATmirror(D_keycolumns));
	bat_destroy(cols);
	cols = rcols;

	rcols = BATsemijoin(kc_nr, cols);
	bat_destroy(cols);
	cols = BATmirror(rcols);
	rcols = BATsort(cols);
	bat_destroy(cols);
	cols = BATmirror(rcols);

	ccnt = BATcount(cols);
	if (ccnt) {
		BATloop(cols, p, q)
		    load_idxcolumn(tr, cols, p, ni);
	}
	bat_destroy(cols);

	ni->bat.ibid = ni->bat.bid = ni->bat.ubid = 0;
	ni->bat.name = ni->bat.uname = NULL;

	if (itype == join_idx || list_length(ni->columns) > 1 ) {
		snprintf(bname, BUFSIZ, "%s_%s_%s", t->s->base.name, t->base.name, ni->base.name);
		ni->bat.name = _strdup(bname);
		b = temp_descriptor(logger_find_bat(sql_logger, ni->bat.name));
		ni->bat.bid = temp_create(b);
		bat_destroy(b);

		snprintf(bname, BUFSIZ, "U_%s", ni->bat.name);
		ni->bat.uname = _strdup(bname);
		b = temp_descriptor(logger_find_bat(sql_logger, ni->bat.uname));
		ni->bat.ubid = temp_create(b);
		bat_destroy(b);
	}

	if (itype == join_idx) {
		BAT *b = bat_new(TYPE_void, TYPE_oid, t->sz, "load_idx");

		ni->bat.ibid = temp_create(b);
		bat_destroy(b);
	} else {
		BAT *b = bat_new(TYPE_void, TYPE_int, t->sz, "load_idx");

		ni->bat.ibid = temp_create(b);
		bat_destroy(b);
	}

	if (ni->bat.bid && ni->bat.ubid) {
		BAT *b  = temp_descriptor(ni->bat.bid);
		BAT *ib = temp_descriptor(ni->bat.ibid);
		BAT *ub = temp_descriptor(ni->bat.ubid);
		BAT *db = temp_descriptor(t->dbid);

		if (BATcount(ub) || BATcount(db)) {
			update_table_bat(b, ub, db);
		}
		bat_destroy(ub);
		bat_destroy(db);

		BATseqbase(ib, BATcount(b));
		bat_destroy(ib);
		bat_destroy(b);
	}

	bat_destroy(idx_id);
	bat_destroy(idx_tpe);
	bat_destroy(idx_name);
	bat_destroy(kc_id);
	bat_destroy(kc_nr);
	bat_destroy(D_keycolumns);
	return ni;
}

static void
load_triggercolumn(sql_trans *tr, BAT *columns, BUN j, sql_trigger * i)
{
	sql_kc *kc = NEW(sql_kc);
	BAT *kc_col = get_bat("sys_keycolumns_column");
	BAT *kc_trunc = get_bat("sys_keycolumns_trunc");
	ptr lid = BUNhead(columns, j);
	char *name = bun_find(kc_col, lid);
	int trunc = *(int *) bun_find(kc_trunc, lid);
	sql_column *c = find_sql_column(i->t, name);

	assert(c);

	(void)tr;
	kc->c = c;
	kc->trunc = trunc;
	list_append(i->columns, kc);

	bat_destroy(kc_col);
	bat_destroy(kc_trunc);
}

static sql_trigger *
load_trigger(sql_trans *tr, BAT *triggers, BUN j, sql_table *t)
{
	size_t ccnt;
	BAT *cols, *rcols;
	BAT *trigger_id = get_bat("sys_triggers_id");
	BAT *trigger_name = get_bat("sys_triggers_name");
	BAT *trigger_time = get_bat("sys_triggers_time");
	BAT *trigger_orientation = get_bat("sys_triggers_orientation");
	BAT *trigger_event = get_bat("sys_triggers_event");
	BAT *trigger_old_name = get_bat("sys_triggers_old_name");
	BAT *trigger_new_name = get_bat("sys_triggers_new_name");
	BAT *trigger_condition = get_bat("sys_triggers_condition");
	BAT *trigger_statement = get_bat("sys_triggers_statement");
	BAT *kc_id = get_bat("sys_keycolumns_id");
	BAT *kc_nr = get_bat("sys_keycolumns_nr");
	BAT *D_keycolumns = get_bat("D_sys_keycolumns");
	ptr lid = BUNhead(triggers, j);
	char *name = (char *) bun_find(trigger_name, lid);
	char *old_name = (char *) bun_find(trigger_old_name, lid);
	char *new_name = (char *) bun_find(trigger_new_name, lid);
	char *condition = (char*)bun_find(trigger_condition, lid);
	char *statement = (char*)bun_find(trigger_statement, lid);
	sql_trigger *nt = NEW(sql_trigger);
	BUN p, q;

	base_init(&nt->base, *(sqlid *) bun_find(trigger_id, lid), TR_OLD, name);
	nt->columns = list_create((fdestroy) &kc_destroy);
	nt->t = t;
	nt->time = *(sht*)bun_find(trigger_time, lid);
	nt->orientation = *(sht*)bun_find(trigger_orientation, lid);
	nt->event = *(sht*)bun_find(trigger_event, lid);

	nt->old_name = (old_name)?_strdup(old_name):NULL;
	nt->new_name = (new_name)?_strdup(new_name):NULL;
	nt->condition = (condition)?_strdup(condition):NULL;
	nt->statement = _strdup(statement);

	cols = BATselect(kc_id, (ptr) &nt->base.id, (ptr) &nt->base.id);
	rcols = BATkdiff(cols, BATmirror(D_keycolumns));
	bat_destroy(cols);
	cols = rcols;

	rcols = BATsemijoin(kc_nr, cols);
	bat_destroy(cols);
	cols = BATmirror(rcols);
	rcols = BATsort(cols);
	bat_destroy(cols);
	cols = BATmirror(rcols);

	ccnt = BATcount(cols);
	if (ccnt) {
		BATloop(cols, p, q)
		    load_triggercolumn(tr, cols, p, nt);
	}
	bat_destroy(cols);

	bat_destroy(trigger_id);
	bat_destroy(trigger_name);
	bat_destroy(trigger_time);
	bat_destroy(trigger_orientation);
	bat_destroy(trigger_event);
	bat_destroy(trigger_old_name);
	bat_destroy(trigger_new_name);
	bat_destroy(trigger_condition);
	bat_destroy(trigger_statement);
	bat_destroy(kc_id);
	bat_destroy(kc_nr);
	bat_destroy(D_keycolumns);
	return nt;
}

static sql_column *
load_column(sql_trans *tr, sql_table *t, BAT *columns, BUN j)
{
	char *def;
	char name[BUFSIZ], *tpe;
	sql_column *c = NEW(sql_column);
	ptr lid = BUNhead(columns, j);
	int sz, d;
	BAT *b;
	BAT *column_id = get_bat("sys__columns_id");
	BAT *column_name = get_bat("sys__columns_name");
	BAT *column_type = get_bat("sys__columns_type");
	BAT *column_type_digits = get_bat("sys__columns_type_digits");
	BAT *column_type_scale = get_bat("sys__columns_type_scale");
	BAT *column_default = get_bat("sys__columns_default");
	BAT *column_null = get_bat("sys__columns_null");
	BAT *column_number = get_bat("sys__columns_number");

	base_init(&c->base, *(sqlid *) bun_find(column_id, lid), TR_OLD, (char *) bun_find(column_name, lid));

	tpe = (char *) bun_find(column_type, lid);
	sz = *(int *) bun_find(column_type_digits, lid);
	d = *(int *) bun_find(column_type_scale, lid);
	if (!sql_find_subtype(&c->type, tpe, sz, d))
		sql_init_subtype(&c->type, sql_trans_bind_type(tr, t->s, tpe), sz, d);
	def = (char *) bun_find(column_default, lid);
	c->def = NULL;
	if (ATOMcmp(TYPE_str, ATOMnilptr(TYPE_str), def) != 0)
		c->def = _strdup(def);
	c->null = *(bit *) bun_find(column_null, lid);
	c->colnr = *(int *) bun_find(column_number, lid);
	c->unique = 0;
	c->t = t;

	c->bat.ibid = c->bat.bid = c->bat.ubid = 0;
	c->bat.name = c->bat.uname = NULL;

	if (isTable(t) && !isTempTable(t)) {	/* system table */
		int type = ATOMindex(c->type.type->base.name);

		snprintf(name, BUFSIZ, "%s_%s_%s", t->s->base.name, t->base.name, c->base.name);
		c->bat.name = _strdup(name);
		b = temp_descriptor(logger_find_bat(sql_logger, c->bat.name));
		c->bat.bid = temp_create(b);
		bat_destroy(b);

		snprintf(name, BUFSIZ, "U_%s", c->bat.name);
		c->bat.uname = _strdup(name);
		b = temp_descriptor(logger_find_bat(sql_logger, c->bat.uname));
		c->bat.ubid = temp_create(b);
		bat_destroy(b);

 		b = bat_new(TYPE_void, type, t->sz, "load_column");
		c->bat.ibid = temp_create(b);
		bat_destroy(b);
	} else if (isTable(t) && isTempTable(t)) {	/* temp table */
		int type = c->type.type->localtype;

		b = bat_new(TYPE_void, type, t->sz, "load_column");
		c->bat.ibid = temp_create(b);
		bat_destroy(b);
	}

	if (bs_debug)
		fprintf(stderr, "\t\tload column %s\n", c->base.name);

	if (c->bat.bid && c->bat.ubid && !isTempTable(t)) {
		BAT *b  = temp_descriptor(c->bat.bid);
		BAT *ib  = temp_descriptor(c->bat.ibid);
		BAT *ub = temp_descriptor(c->bat.ubid);
		BAT *db = temp_descriptor(t->dbid);

		t->cnt = (BATcount(b)-BATcount(db));
		if (BATcount(ub) || BATcount(db)) {
			update_table_bat(b, ub, db);
		}
		bat_destroy(ub);
		bat_destroy(db);

		BATseqbase(ib, BATcount(b));
		bat_destroy(ib);
		bat_destroy(b);
	}

	bat_destroy(column_id);
	bat_destroy(column_name);
	bat_destroy(column_type);
	bat_destroy(column_type_digits);
	bat_destroy(column_type_scale);
	bat_destroy(column_default);
	bat_destroy(column_null);
	bat_destroy(column_number);
	return c;
}

static sql_table *
load_table(sql_trans *tr, sql_schema *s, BAT *tables, BUN j)
{
	char name[BUFSIZ], *query;
	sql_table *t = NEW(sql_table);
	ptr lid = BUNhead(tables, j);
	BAT *cols, *rcols, *keys, *rkeys, *idxs, *ridxs, *triggers, *rtriggers;
	BUN p, q;
	size_t ccnt;
	BAT *column_table = get_bat("sys__columns_table_id");
	BAT *column_number = get_bat("sys__columns_number");
	BAT *key_table = get_bat("sys_keys_table_id");
	BAT *idx_table = get_bat("sys_idxs_table_id");
	BAT *trigger_table = get_bat("sys_triggers_table_id");
	BAT *table_id = get_bat("sys__tables_id");
	BAT *table_names = get_bat("sys__tables_name");
	BAT *table_queries = get_bat("sys__tables_query");
	BAT *table_type = get_bat("sys__tables_type");
	BAT *table_system = get_bat("sys__tables_system");
	BAT *table_commit_action = get_bat("sys__tables_commit_action");
	BAT *D_columns = get_bat("D_sys__columns");
	BAT *D_keys = get_bat("D_sys_keys");
	BAT *D_idxs = get_bat("D_sys_idxs");
	BAT *D_triggers = get_bat("D_sys_triggers");

	base_init(&t->base, *(sqlid *) bun_find(table_id, lid), TR_OLD, bun_find(table_names, lid));
	query = (char *) bun_find(table_queries, lid);
	t->query = NULL;
	if (ATOMcmp(TYPE_str, ATOMnilptr(TYPE_str), query) != 0)
		t->query = _strdup(query);
	t->type = *(sht *) bun_find(table_type, lid);
	t->system = *(bit *) bun_find(table_system, lid);
	t->commit_action = (ca_t)*(sht *) bun_find(table_commit_action, lid); 
	t->persistence = SQL_PERSIST; 
	if (t->commit_action)
		t->persistence = SQL_GLOBAL_TEMP;
	t->cleared = 0;

	t->pkey = NULL;
	t->s = s;
	t->sz = BATSIZE;
	t->cnt = 0;

	cs_init(&t->columns, (fdestroy) &column_destroy);
	cs_init(&t->idxs, (fdestroy) &idx_destroy);
	cs_init(&t->keys, (fdestroy) &key_destroy);
	cs_init(&t->triggers, (fdestroy) &trigger_destroy);

	snprintf(name, BUFSIZ, "D_%s_%s", t->s->base.name, t->base.name);
	t->dname = _strdup(name);
	t->dbid = 0;
	if (isTable(t)) {
		BAT *b;
		bat bid;

		if (!isTempTable(t) && (bid = logger_find_bat(sql_logger, t->dname))) {
			b = temp_descriptor(bid);
		} else {
			b = bat_new(TYPE_void, TYPE_oid, t->sz, "load_table");
		}
		t->dbid = temp_create(b);
		bat_destroy(b);
	}

	cols = BATselect(column_table, (ptr) &t->base.id, (ptr) &t->base.id);
	rcols = BATkdiff(cols, BATmirror(D_columns));
	bat_destroy(cols);
	cols = rcols;

	rcols = BATsemijoin(column_number, cols);
	bat_destroy(cols);
	cols = BATmirror(rcols);
	rcols = BATsort(cols);
	bat_destroy(cols);
	cols = BATmirror(rcols);

	if (bs_debug)
		fprintf(stderr, "\tload table %s\n", t->base.name);

	BATloop(cols, p, q)
		cs_add(&t->columns, load_column(tr, t, cols, p), TR_OLD);

	bat_destroy(cols);

	/* load idx's first as the may be needed by the keys */
	idxs = BATselect(idx_table, (ptr) &t->base.id, (ptr) &t->base.id);
	ridxs = BATkdiff(idxs, BATmirror(D_idxs));
	bat_destroy(idxs);

	ccnt = BATcount(ridxs);
	if (isTable(t) && ccnt) {
		BATloop(ridxs, p, q) {
			sql_idx *i;

			cs_add(&t->idxs, i = load_idx(tr, ridxs, p, t), TR_OLD);
			list_append(s->idxs, i);
		}
	}
	bat_destroy(ridxs);

	keys = BATselect(key_table, (ptr) &t->base.id, (ptr) &t->base.id);
	rkeys = BATkdiff(keys, BATmirror(D_keys));
	bat_destroy(keys);

	ccnt = BATcount(rkeys);
	if (isTable(t) && ccnt) {
		BATloop(rkeys, p, q) {
			sql_key *k;

			cs_add(&t->keys, k = load_key(tr, rkeys, p, t), TR_OLD);
			list_append(s->keys, k);
		}
	}
	bat_destroy(rkeys);

	triggers = BATselect(trigger_table, (ptr) &t->base.id, (ptr) &t->base.id);
	rtriggers = BATkdiff(triggers, BATmirror(D_triggers));
	bat_destroy(triggers);

	ccnt = BATcount(rtriggers);
	if (isTable(t) && ccnt) {
		BATloop(rtriggers, p, q) {
			sql_trigger *k;

			cs_add(&t->triggers, k = load_trigger(tr, rtriggers, p, t), TR_OLD);
			list_append(s->triggers, k);
		}
	}
	bat_destroy(rtriggers);

	bat_destroy(idx_table);
	bat_destroy(key_table);
	bat_destroy(column_table);
	bat_destroy(column_number);
	bat_destroy(table_id);
	bat_destroy(table_names);
	bat_destroy(table_queries);
	bat_destroy(table_type);
	bat_destroy(D_columns);
	bat_destroy(D_idxs);
	bat_destroy(D_keys);
	return t;
}

static sql_type *
load_type(sql_trans *tr, sql_schema * s, BAT *types, BUN j)
{
	sql_type *t = NEW(sql_type);
	ptr lid = BUNhead(types, j);
	BAT *type_id = get_bat("sys_types_id");
	BAT *type_systemname = get_bat("sys_types_systemname");
	BAT *type_sqlname = get_bat("sys_types_sqlname");
	BAT *type_digits = get_bat("sys_types_digits");
	BAT *type_scale = get_bat("sys_types_scale");
	BAT *type_radix = get_bat("sys_types_radix");
	BAT *type_eclass = get_bat("sys_types_eclass");

	(void)tr;
	base_init(&t->base, *(sqlid *) bun_find(type_id, lid), TR_OLD, bun_find(type_systemname, lid));
	t->sqlname = _strdup((char *) bun_find(type_sqlname, lid));
	t->digits = *(int *) bun_find(type_digits, lid);
	t->scale = *(int *) bun_find(type_scale, lid);
	t->radix = *(int *) bun_find(type_radix, lid);
	t->eclass = *(int *) bun_find(type_eclass, lid);
	t->localtype = ATOMindex(t->base.name);
	t->s = s;

	bat_destroy(type_id);
	bat_destroy(type_systemname);
	bat_destroy(type_sqlname);
	bat_destroy(type_digits);
	bat_destroy(type_scale);
	bat_destroy(type_radix);
	bat_destroy(type_eclass);
	return t;
}

static sql_table *
schema_get_table(sql_schema *s, oid id)
{
	if (s) {
		node *n;

		for (n=s->tables.set->h; n; n = n->next) {
			sql_table *t = n->data;
			if (t->base.id == id)
				return t;
		}
	}
	return NULL;
}

static sql_arg *
load_arg(sql_trans *tr, sql_func * f, BAT *args, BUN j)
{
	char *tpe;
	sql_arg *a = NEW(sql_arg);
	ptr lid = BUNhead(args, j);
	int digits, scale;
	BAT *arg_name = get_bat("sys_args_name");
	BAT *arg_type = get_bat("sys_args_type");
	BAT *arg_type_digits = get_bat("sys_args_type_digits");
	BAT *arg_type_scale = get_bat("sys_args_type_scale");

	(void)f;
	a->name = _strdup((char *) bun_find(arg_name, lid));
	tpe = (char *) bun_find(arg_type, lid);
	digits = *(int *) bun_find(arg_type_digits, lid);
	scale = *(int *) bun_find(arg_type_scale, lid);
	if (!sql_find_subtype(&a->type, tpe, digits, scale))
		sql_init_subtype(&a->type, sql_trans_bind_type(tr, f->s, tpe), digits, scale);

	/* complex (table) types */
	if (a->type.type->localtype == TYPE_bat) 
		a->type.comp_type = schema_get_table(f->s, digits);

	bat_destroy(arg_name);
	bat_destroy(arg_type);
	bat_destroy(arg_type_digits);
	bat_destroy(arg_type_scale);
	return a;
}

static sql_func *
load_func(sql_trans *tr, sql_schema * s, BAT *funcs, BUN j)
{
	sql_func *t = NEW(sql_func);
	ptr lid = BUNhead(funcs, j);
	BAT *args, *rargs;
	BUN p, q;
	BAT *func_id = get_bat("sys_functions_id");
	BAT *func_name = get_bat("sys_functions_name");
	BAT *func_func = get_bat("sys_functions_func");
	BAT *func_mod = get_bat("sys_functions_mod");
	BAT *func_sql = get_bat("sys_functions_sql");
	BAT *func_aggr = get_bat("sys_functions_aggr");
	BAT *arg_func_id = get_bat("sys_args_func_id");
	BAT *arg_number = get_bat("sys_args_number");
	int first = 1;

	base_init(&t->base, *(sqlid *) bun_find(func_id, lid), TR_OLD, bun_find(func_name, lid));
	t->imp = _strdup((char *) bun_find(func_func, lid));
	t->mod = _strdup((char *) bun_find(func_mod, lid));
	t->sql = *(bit *) bun_find(func_sql, lid);
	t->aggr = *(bit *) bun_find(func_aggr, lid);
	t->res.type = NULL;
	t->s = s;

	args = BATselect(arg_func_id, (ptr) &t->base.id, (ptr) &t->base.id);

	rargs = BATsemijoin(arg_number, args);
	bat_destroy(args);
	args = BATmirror(rargs);
	rargs = BATsort(args);
	bat_destroy(args);
	args = BATmirror(rargs);

	if (bs_debug)
		fprintf(stderr, "\tload table %s\n", t->base.name);

	t->ops = list_create((fdestroy)&arg_destroy);
	BATloop(args, p, q) {
		sql_arg *a = load_arg(tr, t, args, p);
		if (first) {
			first = 0;
			if (strcmp(a->name, "result") == 0) {
				t -> res = a->type;
				arg_destroy(a);
			} else {
				list_append(t->ops, a);
			}
		} else {
			list_append(t->ops, a);
		}
	}
	bat_destroy(args);

	bat_destroy(func_id);
	bat_destroy(func_name);
	bat_destroy(func_func);
	bat_destroy(func_mod);
	bat_destroy(func_sql);
	bat_destroy(func_aggr);
	bat_destroy(arg_func_id);
	bat_destroy(arg_number);
	return t;
}

static sql_sequence *
load_seq(sql_trans *tr, sql_schema * s, BAT *seqs, BUN j)
{
	sql_sequence *seq = NEW(sql_sequence);
	ptr lid = BUNhead(seqs, j);
	BAT *seq_id = get_bat("sys_sequences_id");
	BAT *seq_name = get_bat("sys_sequences_name");
	BAT *seq_start = get_bat("sys_sequences_start");
	BAT *seq_minvalue = get_bat("sys_sequences_minvalue");
	BAT *seq_maxvalue = get_bat("sys_sequences_maxvalue");
	BAT *seq_increment = get_bat("sys_sequences_increment");
	BAT *seq_cacheinc = get_bat("sys_sequences_cacheinc");
	BAT *seq_cycle = get_bat("sys_sequences_cycle");

	(void)tr;
	base_init(&seq->base, *(sqlid *) bun_find(seq_id, lid), TR_OLD, bun_find(seq_name, lid));
	seq->start = *(lng *) bun_find(seq_start, lid);
	seq->minvalue = *(lng *) bun_find(seq_minvalue, lid);
	seq->maxvalue = *(lng *) bun_find(seq_maxvalue, lid);
	seq->increment = *(lng *) bun_find(seq_increment, lid);
	seq->cacheinc = *(lng *) bun_find(seq_cacheinc, lid);
	seq->cycle = *(bit *) bun_find(seq_cycle, lid);
	seq->s = s;

	bat_destroy(seq_id);
	bat_destroy(seq_name);
	bat_destroy(seq_start);
	bat_destroy(seq_minvalue);
	bat_destroy(seq_maxvalue);
	bat_destroy(seq_increment);
	bat_destroy(seq_cacheinc);
	bat_destroy(seq_cycle);
	return seq;
}

static sql_schema *
load_schema(sql_trans *tr, BAT *schemas, BUN j)
{
	sql_schema *s = NEW(sql_schema);
	ptr lid = BUNhead(schemas, j);
	BAT *tables, *ptables, *types, *funcs, *seqs;
	BUN p, q;
	BAT *schema_names = get_bat("sys_schemas_name");
	BAT *schema_auths = get_bat("sys_schemas_authorization");
	BAT *table_schema = get_bat("sys__tables_schema_id");
	BAT *D_tables = get_bat("D_sys__tables");
	BAT *type_schema = get_bat("sys_types_schema_id");
	BAT *D_types = get_bat("D_sys_types");
	BAT *func_schema = get_bat("sys_functions_schema_id");
	BAT *D_funcs = get_bat("D_sys_functions");
	BAT *seq_schema = get_bat("sys_sequences_schema_id");
	BAT *D_seqs = get_bat("D_sys_sequences");

	base_init(&s->base, *(sqlid *) bun_find(schemas, lid), TR_OLD, bun_find(schema_names, lid));
	s->auth_id = *(sqlid *) bun_find(schema_auths, lid);
	s->keys = list_create((fdestroy) NULL);
	s->idxs = list_create((fdestroy) NULL);
	s->triggers = list_create((fdestroy) NULL);

	bat_destroy(schema_auths);
	bat_destroy(schema_names);

	cs_init(&s->tables, (fdestroy) &table_destroy);
	cs_init(&s->types, (fdestroy) &type_destroy);
	cs_init(&s->funcs, (fdestroy) &func_destroy);
	cs_init(&s->seqs, (fdestroy) &seq_destroy);

	if (bs_debug)
		fprintf(stderr, "load schema %s %d\n", s->base.name, s->base.id);

	/* first load simple types */
	types = BATselect(type_schema, (ptr) &s->base.id, (ptr) &s->base.id);
	if (D_types) {
		BAT *ptypes = BATkdiff(types, BATmirror(D_types));
		bat_destroy(types);
		types = ptypes;
	}
	bat_destroy(type_schema);
	bat_destroy(D_types);

	BATloop(types, p, q)
	    cs_add(&s->types, load_type(tr, s, types, p), TR_OLD);
	bat_destroy(types);

	/* second tables (and complex types) */
	tables = BATselect(table_schema, (ptr) &s->base.id, (ptr) &s->base.id);
	ptables = BATkdiff(tables, BATmirror(D_tables));
	bat_destroy(tables);
	bat_destroy(table_schema);
	bat_destroy(D_tables);

	BATloop(ptables, p, q) 
	    	cs_add(&s->tables, load_table(tr, s, ptables, p), TR_OLD);
	bat_destroy(ptables);

	/* last functions which could use these types */
	funcs = BATselect(func_schema, (ptr) &s->base.id, (ptr) &s->base.id);
	if (D_funcs) {
		BAT *pfuncs = BATkdiff(funcs, BATmirror(D_funcs));
		bat_destroy(funcs);
		funcs = pfuncs;
	}
	bat_destroy(func_schema);
	bat_destroy(D_funcs);

	BATloop(funcs, p, q)
	    cs_add(&s->funcs, load_func(tr, s, funcs, p), TR_OLD);
	bat_destroy(funcs);

	seqs = BATselect(seq_schema, (ptr) &s->base.id, (ptr) &s->base.id);
	if (D_seqs) {
		BAT *pseqs = BATkdiff(seqs, BATmirror(D_seqs));
		bat_destroy(seqs);
		seqs = pseqs;
	}
	bat_destroy(seq_schema);
	bat_destroy(D_seqs);

	BATloop(seqs, p, q)
	    cs_add(&s->seqs, load_seq(tr, s, seqs, p), TR_OLD);
	bat_destroy(seqs);
	return s;
}

static sql_trans *
load_trans(backend_stack stk)
{
	sql_trans *t = NEW(sql_trans);
	BUN p, q;
	BAT *schema_ids = get_bat("sys_schemas_id");
	BAT *D_schemas = get_bat("D_sys_schemas");
	BAT *b;

	t->name = NULL;
	t->wtime = t->rtime = 0;
	t->stime = timestamp ();
	t->schema_updates = 0;
	t->status = 0;

	t->parent = NULL;
	t->stk = stk;

	cs_init(&t->schemas, (fdestroy) &schema_destroy);

	if (bs_debug)
		fprintf(stderr, "load trans\n");

	b = BATkdiff(schema_ids, BATmirror(D_schemas));
	BATloop(b, p, q)
	    cs_add(&t->schemas, load_schema(t, b, p), TR_OLD);
	bat_destroy(b);

	bat_destroy(schema_ids);
	bat_destroy(D_schemas);
	return t;
}

static BAT *
sys_bat(char *name, int type)
{
	BAT *b = NULL;
	bat bid = logger_find_bat(sql_logger, name);

	if (bs_debug)
		fprintf(stderr, "sys_bat %s bid %d\n", name, bid);

	if (bid == 0) {
		if (name[0] == 'U')
			b = bat_new(TYPE_oid, type, BATSIZE, "sys_bat");
		else
			b = bat_new(TYPE_void, type, BATSIZE, "sys_bat");
		bid = logger_add_bat(sql_logger, b, name );
		if (bs_debug)
			fprintf(stderr, "sys_bat created %s bid %d\n", name, bid);

	} else {
		if (bs_debug)
			fprintf(stderr, "sys_bat loaded %s bid %d\n", name, bid);
		b = temp_descriptor(bid);
	}
	assert(b);
	return b;
}

static int
next_oid(void)
{
	lng id = 0;
	MT_set_lock(bs_lock, "next_oid");
	id = store_oid++;
	MT_unset_lock(bs_lock, "next_oid");
	return id;
}

int
store_next_oid(void)
{
	return next_oid();
}

static void
bs_init_schema(void)
{
	int istmp = 0;
	BAT *sql_schema_id = sys_bat(Ccc(istmp,"tmp","sys","schemas_id"), TYPE_int);
	BAT *sql_schema_name = sys_bat(Ccc(istmp,"tmp","sys","schemas_name"), TYPE_str);
	BAT *sql_schema_auth = sys_bat(Ccc(istmp,"tmp","sys","schemas_authorization"), TYPE_int);
	BAT *U_schema_id = sys_bat(Ucc(istmp,"tmp","sys","schemas_id"), TYPE_int);
	BAT *U_schema_name = sys_bat(Ucc(istmp,"tmp","sys","schemas_name"), TYPE_str);
	BAT *U_schema_auth = sys_bat(Ucc(istmp,"tmp","sys","schemas_authorization"), TYPE_int);
	BAT *D_sql_schema = sys_bat(Dcc(istmp,"tmp","sys","schemas"), TYPE_oid);

	update_table_bat(sql_schema_id, U_schema_id, D_sql_schema);
	update_table_bat(sql_schema_name, U_schema_name, D_sql_schema);
	update_table_bat(sql_schema_auth, U_schema_auth, D_sql_schema);

	bat_destroy(sql_schema_id);
	bat_destroy(sql_schema_name);
	bat_destroy(sql_schema_auth);
	bat_destroy(U_schema_id);
	bat_destroy(U_schema_name);
	bat_destroy(U_schema_auth);
	bat_destroy(D_sql_schema);
}

static void
bs_init_table(int istmp)
{
	BAT *sql_table_id = sys_bat(Ccc(istmp,"tmp","sys","_tables_id"), TYPE_int);
	BAT *sql_table_name = sys_bat(Ccc(istmp,"tmp","sys","_tables_name"), TYPE_str);
	BAT *sql_table_schema = sys_bat(Ccc(istmp,"tmp","sys","_tables_schema_id"), TYPE_int);
	BAT *sql_table_query = sys_bat(Ccc(istmp,"tmp","sys","_tables_query"), TYPE_str);
	BAT *sql_table_type = sys_bat(Ccc(istmp,"tmp","sys","_tables_type"), TYPE_sht);
	BAT *sql_table_system = sys_bat(Ccc(istmp,"tmp","sys","_tables_system"), TYPE_bit);
	BAT *sql_table_commit_action = sys_bat(Ccc(istmp,"tmp","sys","_tables_commit_action"), TYPE_sht);
	BAT *U_table_id = sys_bat(Ucc(istmp,"tmp","sys","_tables_id"), TYPE_int);
	BAT *U_table_name = sys_bat(Ucc(istmp,"tmp","sys","_tables_name"), TYPE_str);
	BAT *U_table_schema = sys_bat(Ucc(istmp,"tmp","sys","_tables_schema_id"), TYPE_int);
	BAT *U_table_query = sys_bat(Ucc(istmp,"tmp","sys","_tables_query"), TYPE_str);
	BAT *U_table_type = sys_bat(Ucc(istmp,"tmp","sys","_tables_type"), TYPE_sht);
	BAT *U_table_system = sys_bat(Ucc(istmp,"tmp","sys","_tables_system"), TYPE_bit);
	BAT *U_table_commit_action = sys_bat(Ucc(istmp,"tmp","sys","_tables_commit_action"), TYPE_sht);
	BAT *D_sql_table = sys_bat(Dcc(istmp,"tmp","sys","_tables"), TYPE_oid);

	update_table_bat(sql_table_id, U_table_id, D_sql_table);
	update_table_bat(sql_table_name, U_table_name, D_sql_table);
	update_table_bat(sql_table_schema, U_table_schema, D_sql_table);
	update_table_bat(sql_table_query, U_table_query, D_sql_table);
	update_table_bat(sql_table_type, U_table_type, D_sql_table);

	bat_destroy(sql_table_id);
	bat_destroy(sql_table_name);
	bat_destroy(sql_table_schema);
	bat_destroy(sql_table_query);
	bat_destroy(sql_table_type);
	bat_destroy(sql_table_system);
	bat_destroy(sql_table_commit_action);
	bat_destroy(U_table_id);
	bat_destroy(U_table_name);
	bat_destroy(U_table_schema);
	bat_destroy(U_table_query);
	bat_destroy(U_table_type);
	bat_destroy(U_table_system);
	bat_destroy(U_table_commit_action);
	bat_destroy(D_sql_table);
}

static void
bs_init_column(int istmp)
{
	BAT *sql_column_id = sys_bat(Ccc(istmp,"tmp","sys","_columns_id"), TYPE_int);
	BAT *sql_column_name = sys_bat(Ccc(istmp,"tmp","sys","_columns_name"), TYPE_str);
	BAT *sql_column_type = sys_bat(Ccc(istmp,"tmp","sys","_columns_type"), TYPE_str);
	BAT *sql_column_type_digits = sys_bat(Ccc(istmp,"tmp","sys","_columns_type_digits"), TYPE_int);
	BAT *sql_column_type_scale = sys_bat(Ccc(istmp,"tmp","sys","_columns_type_scale"), TYPE_int);
	BAT *sql_column_table = sys_bat(Ccc(istmp,"tmp","sys","_columns_table_id"), TYPE_int);
	BAT *sql_column_default = sys_bat(Ccc(istmp,"tmp","sys","_columns_default"), TYPE_str);
	BAT *sql_column_null = sys_bat(Ccc(istmp,"tmp","sys","_columns_null"), TYPE_bit);
	BAT *sql_column_number = sys_bat(Ccc(istmp,"tmp","sys","_columns_number"), TYPE_int);
	BAT *U_column_id = sys_bat(Ucc(istmp,"tmp","sys","_columns_id"), TYPE_int);
	BAT *U_column_name = sys_bat(Ucc(istmp,"tmp","sys","_columns_name"), TYPE_str);
	BAT *U_column_type = sys_bat(Ucc(istmp,"tmp","sys","_columns_type"), TYPE_str);
	BAT *U_column_type_digits = sys_bat(Ucc(istmp,"tmp","sys","_columns_type_digits"), TYPE_int);
	BAT *U_column_type_scale = sys_bat(Ucc(istmp,"tmp","sys","_columns_type_scale"), TYPE_int);
	BAT *U_column_table = sys_bat(Ucc(istmp,"tmp","sys","_columns_table_id"), TYPE_int);
	BAT *U_column_default = sys_bat(Ucc(istmp,"tmp","sys","_columns_default"), TYPE_str);
	BAT *U_column_null = sys_bat(Ucc(istmp,"tmp","sys","_columns_null"), TYPE_bit);
	BAT *U_column_number = sys_bat(Ucc(istmp,"tmp","sys","_columns_number"), TYPE_int);
	BAT *D_sql_column = sys_bat(Dcc(istmp,"tmp","sys","_columns"), TYPE_oid);

	update_table_bat(sql_column_id, U_column_id, D_sql_column);
	update_table_bat(sql_column_name, U_column_name, D_sql_column);
	update_table_bat(sql_column_type, U_column_type, D_sql_column);
	update_table_bat(sql_column_type_digits, U_column_type_digits, D_sql_column);
	update_table_bat(sql_column_type_scale, U_column_type_scale, D_sql_column);
	update_table_bat(sql_column_table, U_column_table, D_sql_column);
	update_table_bat(sql_column_default, U_column_default, D_sql_column);
	update_table_bat(sql_column_null, U_column_null, D_sql_column);
	update_table_bat(sql_column_number, U_column_number, D_sql_column);

	bat_destroy(sql_column_id);
	bat_destroy(sql_column_name);
	bat_destroy(sql_column_type);
	bat_destroy(sql_column_type_digits);
	bat_destroy(sql_column_type_scale);
	bat_destroy(sql_column_table);
	bat_destroy(sql_column_default);
	bat_destroy(sql_column_null);
	bat_destroy(sql_column_number);
	bat_destroy(U_column_id);
	bat_destroy(U_column_name);
	bat_destroy(U_column_type);
	bat_destroy(U_column_type_digits);
	bat_destroy(U_column_type_scale);
	bat_destroy(U_column_table);
	bat_destroy(U_column_default);
	bat_destroy(U_column_null);
	bat_destroy(U_column_number);
	bat_destroy(D_sql_column);
}


static void
bs_init_key(int istmp)
{
	BAT *key_id = sys_bat(Ccc(istmp,"tmp","sys","keys_id"), TYPE_int);
	BAT *key_table = sys_bat(Ccc(istmp,"tmp","sys","keys_table_id"), TYPE_int);
	BAT *key_tpe = sys_bat(Ccc(istmp,"tmp","sys","keys_type"), TYPE_int);
	BAT *key_name = sys_bat(Ccc(istmp,"tmp","sys","keys_name"), TYPE_str);
	BAT *key_rkey = sys_bat(Ccc(istmp,"tmp","sys","keys_rkey"), TYPE_int);
	BAT *U_key_id = sys_bat(Ucc(istmp,"tmp","sys","keys_id"), TYPE_int);
	BAT *U_key_table = sys_bat(Ucc(istmp,"tmp","sys","keys_table_id"), TYPE_int);
	BAT *U_key_tpe = sys_bat(Ucc(istmp,"tmp","sys","keys_type"), TYPE_int);
	BAT *U_key_name = sys_bat(Ucc(istmp,"tmp","sys","keys_name"), TYPE_str);
	BAT *U_key_rkey = sys_bat(Ucc(istmp,"tmp","sys","keys_rkey"), TYPE_int);
	BAT *D_key = sys_bat(Dcc(istmp,"tmp","sys","keys"), TYPE_oid);

	BAT *kc_id = sys_bat(Ccc(istmp,"tmp","sys","keycolumns_id"), TYPE_int);
	BAT *kc_col = sys_bat(Ccc(istmp,"tmp","sys","keycolumns_column"), TYPE_str);
	BAT *kc_trunc = sys_bat(Ccc(istmp,"tmp","sys","keycolumns_trunc"), TYPE_int);
	BAT *kc_nr = sys_bat(Ccc(istmp,"tmp","sys","keycolumns_nr"), TYPE_int);
	BAT *U_kc_id = sys_bat(Ucc(istmp,"tmp","sys","keycolumns_id"), TYPE_int);
	BAT *U_kc_col = sys_bat(Ucc(istmp,"tmp","sys","keycolumns_column"), TYPE_str);
	BAT *U_kc_trunc = sys_bat(Ucc(istmp,"tmp","sys","keycolumns_trunc"), TYPE_int);
	BAT *U_kc_nr = sys_bat(Ucc(istmp,"tmp","sys","keycolumns_nr"), TYPE_int);
	BAT *D_kc = sys_bat(Dcc(istmp,"tmp","sys","keycolumns"), TYPE_oid);

	update_table_bat(key_id, U_key_id, D_key);
	update_table_bat(key_table, U_key_table, D_key);
	update_table_bat(key_tpe, U_key_tpe, D_key);
	update_table_bat(key_name, U_key_name, D_key);
	update_table_bat(key_rkey, U_key_rkey, D_key);
	/* key_updaterule = sys_bat(Ccc(istmp,"tmp","sys","keys_updaterule"), TYPE_int); */
	/* key_deleterule = sys_bat(Ccc(istmp,"tmp","sys","keys_deleterule"), TYPE_int); */
	/* key_deferrability = sys_bat(Ccc(istmp,"tmp","sys","keys_deferrability"), TYPE_int); */

	update_table_bat(kc_id, U_kc_id, D_kc);
	update_table_bat(kc_col, U_kc_col, D_kc);
	update_table_bat(kc_trunc, U_kc_trunc, D_kc);
	update_table_bat(kc_nr, U_kc_nr, D_kc);

	bat_destroy(key_id);
	bat_destroy(key_table);
	bat_destroy(key_tpe);
	bat_destroy(key_name);
	bat_destroy(key_rkey);
	bat_destroy(U_key_id);
	bat_destroy(U_key_table);
	bat_destroy(U_key_tpe);
	bat_destroy(U_key_name);
	bat_destroy(U_key_rkey);
	bat_destroy(D_key);

	bat_destroy(kc_id);
	bat_destroy(kc_col);
	bat_destroy(kc_trunc);
	bat_destroy(kc_nr);
	bat_destroy(U_kc_id);
	bat_destroy(U_kc_col);
	bat_destroy(U_kc_trunc);
	bat_destroy(U_kc_nr);
	bat_destroy(D_kc);
}

static void
bs_init_idx(int istmp)
{
	BAT *idx_id = sys_bat(Ccc(istmp,"tmp","sys","idxs_id"), TYPE_int);
	BAT *idx_table = sys_bat(Ccc(istmp,"tmp","sys","idxs_table_id"), TYPE_int);
	BAT *idx_tpe = sys_bat(Ccc(istmp,"tmp","sys","idxs_type"), TYPE_int);
	BAT *idx_name = sys_bat(Ccc(istmp,"tmp","sys","idxs_name"), TYPE_str);
	BAT *U_idx_id = sys_bat(Ucc(istmp,"tmp","sys","idxs_id"), TYPE_int);
	BAT *U_idx_table = sys_bat(Ucc(istmp,"tmp","sys","idxs_table_id"), TYPE_int);
	BAT *U_idx_tpe = sys_bat(Ucc(istmp,"tmp","sys","idxs_type"), TYPE_int);
	BAT *U_idx_name = sys_bat(Ucc(istmp,"tmp","sys","idxs_name"), TYPE_str);
	BAT *D_idx = sys_bat(Dcc(istmp,"tmp","sys","idxs"), TYPE_oid);

	BAT *kc_id = sys_bat(Ccc(istmp,"tmp","sys","keycolumns_id"), TYPE_int);
	BAT *kc_col = sys_bat(Ccc(istmp,"tmp","sys","keycolumns_column"), TYPE_str);
	BAT *kc_trunc = sys_bat(Ccc(istmp,"tmp","sys","keycolumns_trunc"), TYPE_int);
	BAT *kc_nr = sys_bat(Ccc(istmp,"tmp","sys","keycolumns_nr"), TYPE_int);
	BAT *U_kc_id = sys_bat(Ucc(istmp,"tmp","sys","keycolumns_id"), TYPE_int);
	BAT *U_kc_col = sys_bat(Ucc(istmp,"tmp","sys","keycolumns_column"), TYPE_str);
	BAT *U_kc_trunc = sys_bat(Ucc(istmp,"tmp","sys","keycolumns_trunc"), TYPE_int);
	BAT *U_kc_nr = sys_bat(Ucc(istmp,"tmp","sys","keycolumns_nr"), TYPE_int);
	BAT *D_kc = sys_bat(Dcc(istmp,"tmp","sys","keycolumns"), TYPE_oid);

	update_table_bat(idx_id, U_idx_id, D_idx);
	update_table_bat(idx_table, U_idx_table, D_idx);
	update_table_bat(idx_tpe, U_idx_tpe, D_idx);
	update_table_bat(idx_name, U_idx_name, D_idx);
	/* key_updaterule = sys_bat(Ccc(istmp,"tmp","sys","keys_updaterule"), TYPE_int); */
	/* key_deleterule = sys_bat(Ccc(istmp,"tmp","sys","keys_deleterule"), TYPE_int); */
	/* key_deferrability = sys_bat(Ccc(istmp,"tmp","sys","keys_deferrability"), TYPE_int); */

	update_table_bat(kc_id, U_kc_id, D_kc);
	update_table_bat(kc_col, U_kc_col, D_kc);
	update_table_bat(kc_trunc, U_kc_trunc, D_kc);
	update_table_bat(kc_nr, U_kc_nr, D_kc);

	bat_destroy(idx_id);
	bat_destroy(idx_table);
	bat_destroy(idx_tpe);
	bat_destroy(idx_name);
	bat_destroy(U_idx_id);
	bat_destroy(U_idx_table);
	bat_destroy(U_idx_tpe);
	bat_destroy(U_idx_name);
	bat_destroy(D_idx);

	bat_destroy(kc_id);
	bat_destroy(kc_col);
	bat_destroy(kc_trunc);
	bat_destroy(kc_nr);
	bat_destroy(U_kc_id);
	bat_destroy(U_kc_col);
	bat_destroy(U_kc_trunc);
	bat_destroy(U_kc_nr);
	bat_destroy(D_kc);
}

static void
bs_init_trigger(int istmp)
{
	BAT *trigger_id = sys_bat(Ccc(istmp,"tmp","sys","triggers_id"), TYPE_int);
	BAT *trigger_name = sys_bat(Ccc(istmp,"tmp","sys","triggers_name"), TYPE_str);
	BAT *trigger_table = sys_bat(Ccc(istmp,"tmp","sys","triggers_table_id"), TYPE_int);
	BAT *trigger_time = sys_bat(Ccc(istmp,"tmp","sys","triggers_time"), TYPE_sht);
	BAT *trigger_orientation = sys_bat(Ccc(istmp,"tmp","sys","triggers_orientation"), TYPE_sht);
	BAT *trigger_event = sys_bat(Ccc(istmp,"tmp","sys","triggers_event"), TYPE_sht);
	BAT *trigger_old_name = sys_bat(Ccc(istmp,"tmp","sys","triggers_old_name"), TYPE_str);
	BAT *trigger_new_name = sys_bat(Ccc(istmp,"tmp","sys","triggers_new_name"), TYPE_str);
	BAT *trigger_condition = sys_bat(Ccc(istmp,"tmp","sys","triggers_condition"), TYPE_str);
	BAT *trigger_statement = sys_bat(Ccc(istmp,"tmp","sys","triggers_statement"), TYPE_str);

	BAT *U_trigger_id = sys_bat(Ucc(istmp,"tmp","sys","triggers_id"), TYPE_int);
	BAT *U_trigger_name = sys_bat(Ucc(istmp,"tmp","sys","triggers_name"), TYPE_str);
	BAT *U_trigger_table = sys_bat(Ucc(istmp,"tmp","sys","triggers_table_id"), TYPE_int);
	BAT *U_trigger_time = sys_bat(Ucc(istmp,"tmp","sys","triggers_time"), TYPE_sht);
	BAT *U_trigger_orientation = sys_bat(Ucc(istmp,"tmp","sys","triggers_orientation"), TYPE_sht);
	BAT *U_trigger_event = sys_bat(Ucc(istmp,"tmp","sys","triggers_event"), TYPE_sht);
	BAT *U_trigger_old_name = sys_bat(Ucc(istmp,"tmp","sys","triggers_old_name"), TYPE_str);
	BAT *U_trigger_new_name = sys_bat(Ucc(istmp,"tmp","sys","triggers_new_name"), TYPE_str);
	BAT *U_trigger_condition = sys_bat(Ucc(istmp,"tmp","sys","triggers_condition"), TYPE_str);
	BAT *U_trigger_statement = sys_bat(Ucc(istmp,"tmp","sys","triggers_statement"), TYPE_str);
	BAT *D_trigger = sys_bat(Dcc(istmp,"tmp","sys","triggers"), TYPE_oid);

	BAT *kc_id = sys_bat(Ccc(istmp,"tmp","sys","keycolumns_id"), TYPE_int);
	BAT *kc_col = sys_bat(Ccc(istmp,"tmp","sys","keycolumns_column"), TYPE_str);
	BAT *kc_trunc = sys_bat(Ccc(istmp,"tmp","sys","keycolumns_trunc"), TYPE_int);
	BAT *kc_nr = sys_bat(Ccc(istmp,"tmp","sys","keycolumns_nr"), TYPE_int);
	BAT *U_kc_id = sys_bat(Ucc(istmp,"tmp","sys","keycolumns_id"), TYPE_int);
	BAT *U_kc_col = sys_bat(Ucc(istmp,"tmp","sys","keycolumns_column"), TYPE_str);
	BAT *U_kc_trunc = sys_bat(Ucc(istmp,"tmp","sys","keycolumns_trunc"), TYPE_int);
	BAT *U_kc_nr = sys_bat(Ucc(istmp,"tmp","sys","keycolumns_nr"), TYPE_int);
	BAT *D_kc = sys_bat(Dcc(istmp,"tmp","sys","keycolumns"), TYPE_oid);

	update_table_bat(trigger_id, U_trigger_id, D_trigger);
	update_table_bat(trigger_name, U_trigger_name, D_trigger);
	update_table_bat(trigger_table, U_trigger_table, D_trigger);
	update_table_bat(trigger_time, U_trigger_time, D_trigger);
	update_table_bat(trigger_orientation, U_trigger_orientation, D_trigger);
	update_table_bat(trigger_event, U_trigger_event, D_trigger);
	update_table_bat(trigger_old_name, U_trigger_old_name, D_trigger);
	update_table_bat(trigger_new_name, U_trigger_new_name, D_trigger);
	update_table_bat(trigger_condition, U_trigger_condition, D_trigger);
	update_table_bat(trigger_statement, U_trigger_statement, D_trigger);

	update_table_bat(kc_id, U_kc_id, D_kc);
	update_table_bat(kc_col, U_kc_col, D_kc);
	update_table_bat(kc_trunc, U_kc_trunc, D_kc);
	update_table_bat(kc_nr, U_kc_nr, D_kc);

	bat_destroy(trigger_id);
	bat_destroy(trigger_name);
	bat_destroy(trigger_table);
	bat_destroy(trigger_time);
	bat_destroy(trigger_orientation);
	bat_destroy(trigger_event);
	bat_destroy(trigger_old_name);
	bat_destroy(trigger_new_name);
	bat_destroy(trigger_condition);
	bat_destroy(trigger_statement);
	bat_destroy(U_trigger_id);
	bat_destroy(U_trigger_name);
	bat_destroy(U_trigger_table);
	bat_destroy(U_trigger_time);
	bat_destroy(U_trigger_orientation);
	bat_destroy(U_trigger_event);
	bat_destroy(U_trigger_old_name);
	bat_destroy(U_trigger_new_name);
	bat_destroy(U_trigger_condition);
	bat_destroy(U_trigger_statement);
	bat_destroy(D_trigger);

	bat_destroy(kc_id);
	bat_destroy(kc_col);
	bat_destroy(kc_trunc);
	bat_destroy(kc_nr);
	bat_destroy(U_kc_id);
	bat_destroy(U_kc_col);
	bat_destroy(U_kc_trunc);
	bat_destroy(U_kc_nr);
	bat_destroy(D_kc);
}

static void
bs_init_sequence(void)
{
	int istmp = 0;
	BAT *sequence_id = sys_bat(Ccc(istmp,"tmp","sys","sequences_id"), TYPE_int);
	BAT *sequence_schema = sys_bat(Ccc(istmp,"tmp","sys","sequences_schema_id"), TYPE_int);
	BAT *sequence_name = sys_bat(Ccc(istmp,"tmp","sys","sequences_name"), TYPE_str);
	BAT *sequence_start = sys_bat(Ccc(istmp,"tmp","sys","sequences_start"), TYPE_lng);
	BAT *sequence_minvalue = sys_bat(Ccc(istmp,"tmp","sys","sequences_minvalue"), TYPE_lng);
	BAT *sequence_maxvalue = sys_bat(Ccc(istmp,"tmp","sys","sequences_maxvalue"), TYPE_lng);
	BAT *sequence_increment = sys_bat(Ccc(istmp,"tmp","sys","sequences_increment"), TYPE_lng);
	BAT *sequence_cacheinc = sys_bat(Ccc(istmp,"tmp","sys","sequences_cacheinc"), TYPE_lng);
	BAT *sequence_cycle = sys_bat(Ccc(istmp,"tmp","sys","sequences_cycle"), TYPE_bit);

	BAT *U_sequence_id = sys_bat(Ucc(istmp,"tmp","sys","sequences_id"), TYPE_int);
	BAT *U_sequence_schema = sys_bat(Ucc(istmp,"tmp","sys","sequences_schema_id"), TYPE_int);
	BAT *U_sequence_name = sys_bat(Ucc(istmp,"tmp","sys","sequences_name"), TYPE_str);
	BAT *U_sequence_start = sys_bat(Ucc(istmp,"tmp","sys","sequences_start"), TYPE_lng);
	BAT *U_sequence_minvalue = sys_bat(Ucc(istmp,"tmp","sys","sequences_minvalue"), TYPE_lng);
	BAT *U_sequence_maxvalue = sys_bat(Ucc(istmp,"tmp","sys","sequences_maxvalue"), TYPE_lng);
	BAT *U_sequence_increment = sys_bat(Ucc(istmp,"tmp","sys","sequences_increment"), TYPE_lng);
	BAT *U_sequence_cacheinc = sys_bat(Ucc(istmp,"tmp","sys","sequences_cacheinc"), TYPE_lng);
	BAT *U_sequence_cycle = sys_bat(Ucc(istmp,"tmp","sys","sequences_cycle"), TYPE_bit);

	BAT *D_sequence = sys_bat(Dcc(istmp,"tmp","sys","sequences"), TYPE_oid);

	update_table_bat(sequence_id, U_sequence_id, D_sequence);
	update_table_bat(sequence_schema, U_sequence_schema, D_sequence);
	update_table_bat(sequence_name, U_sequence_name, D_sequence);
	update_table_bat(sequence_start, U_sequence_start, D_sequence);
	update_table_bat(sequence_minvalue, U_sequence_minvalue, D_sequence);
	update_table_bat(sequence_maxvalue, U_sequence_maxvalue, D_sequence);
	update_table_bat(sequence_increment, U_sequence_increment, D_sequence);
	update_table_bat(sequence_cacheinc, U_sequence_cacheinc, D_sequence);
	update_table_bat(sequence_cycle, U_sequence_cycle, D_sequence);

	bat_destroy(sequence_id);
	bat_destroy(sequence_schema);
	bat_destroy(sequence_name);
	bat_destroy(sequence_start);
	bat_destroy(sequence_minvalue);
	bat_destroy(sequence_maxvalue);
	bat_destroy(sequence_increment);
	bat_destroy(sequence_cacheinc);
	bat_destroy(sequence_cycle);
	bat_destroy(U_sequence_id);
	bat_destroy(U_sequence_schema);
	bat_destroy(U_sequence_name);
	bat_destroy(U_sequence_start);
	bat_destroy(U_sequence_minvalue);
	bat_destroy(U_sequence_maxvalue);
	bat_destroy(U_sequence_increment);
	bat_destroy(U_sequence_cacheinc);
	bat_destroy(U_sequence_cycle);
	bat_destroy(D_sequence);
}

static void
bs_init_type(void)
{
	int zero = 0;
	node *n = NULL;

	int istmp = 0;
	BAT *type_id = sys_bat(Ccc(istmp,"tmp","sys","types_id"), TYPE_int);
	BAT *type_sqlname = sys_bat(Ccc(istmp,"tmp","sys","types_sqlname"), TYPE_str);
	BAT *type_digits = sys_bat(Ccc(istmp,"tmp","sys","types_digits"), TYPE_int);
	BAT *type_scale = sys_bat(Ccc(istmp,"tmp","sys","types_scale"), TYPE_int);
	BAT *type_radix = sys_bat(Ccc(istmp,"tmp","sys","types_radix"), TYPE_int);
	BAT *type_eclass = sys_bat(Ccc(istmp,"tmp","sys","types_eclass"), TYPE_int);
	BAT *type_schema_id = sys_bat(Ccc(istmp,"tmp","sys","types_schema_id"), TYPE_int);
	BAT *type_systemname = sys_bat(Ccc(istmp,"tmp","sys","types_systemname"), TYPE_str);
	BAT *U_type_id = sys_bat(Ucc(istmp,"tmp","sys","types_id"), TYPE_int);
	BAT *U_type_sqlname = sys_bat(Ucc(istmp,"tmp","sys","types_sqlname"), TYPE_str);
	BAT *U_type_digits = sys_bat(Ucc(istmp,"tmp","sys","types_digits"), TYPE_int);
	BAT *U_type_scale = sys_bat(Ucc(istmp,"tmp","sys","types_scale"), TYPE_int);
	BAT *U_type_radix = sys_bat(Ucc(istmp,"tmp","sys","types_radix"), TYPE_int);
	BAT *U_type_eclass = sys_bat(Ucc(istmp,"tmp","sys","types_eclass"), TYPE_int);
	BAT *U_type_schema_id = sys_bat(Ucc(istmp,"tmp","sys","types_schema_id"), TYPE_int);
	BAT *U_type_systemname = sys_bat(Ucc(istmp,"tmp","sys","types_systemname"), TYPE_str);
	BAT *D_type = sys_bat(Dcc(istmp,"tmp","sys","types"), TYPE_oid);

	if (BATcount(type_sqlname) == 0) {
		oid rid = type_id->hseqbase + BATcount(type_id);
		for (n = types->h; n; n = n->next, rid++) {
			sql_type *t = n->data;
			int radix = t->radix;
			int eclass = t->eclass;

			BUNins(type_id, &rid, &t->base.id, FALSE);

			BUNins(type_sqlname, &rid, t->sqlname, FALSE);
			BUNins(type_digits, &rid, &t->digits, FALSE);
			BUNins(type_scale, &rid, &t->scale, FALSE);
			BUNins(type_radix, &rid, &radix, FALSE);
			BUNins(type_eclass, &rid, &eclass, FALSE);
			BUNins(type_schema_id, &rid, &zero, FALSE);
			BUNins(type_systemname, &rid, t->base.name, FALSE);
		}
	}

	bat_destroy(type_id);
	bat_destroy(type_sqlname);
	bat_destroy(type_digits);
	bat_destroy(type_scale);
	bat_destroy(type_radix);
	bat_destroy(type_eclass);
	bat_destroy(type_schema_id);
	bat_destroy(type_systemname);
	bat_destroy(U_type_id);
	bat_destroy(U_type_sqlname);
	bat_destroy(U_type_digits);
	bat_destroy(U_type_scale);
	bat_destroy(U_type_radix);
	bat_destroy(U_type_eclass);
	bat_destroy(U_type_schema_id);
	bat_destroy(U_type_systemname);
	bat_destroy(D_type);
}

static void
bs_init_func(void)
{
	bit T = TRUE, F = FALSE;
	int zero = 0;
	node *n = NULL, *m = NULL;

	int istmp = 0;
	BAT *func_id = sys_bat(Ccc(istmp,"tmp","sys","functions_id"), TYPE_int);
	BAT *func_name = sys_bat(Ccc(istmp,"tmp","sys","functions_name"), TYPE_str);
	BAT *func_func = sys_bat(Ccc(istmp,"tmp","sys","functions_func"), TYPE_str);
	BAT *func_mod = sys_bat(Ccc(istmp,"tmp","sys","functions_mod"), TYPE_str);
	BAT *func_sql = sys_bat(Ccc(istmp,"tmp","sys","functions_sql"), TYPE_bit);
	BAT *func_aggr = sys_bat(Ccc(istmp,"tmp","sys","functions_aggr"), TYPE_bit);
	BAT *func_schema_id = sys_bat(Ccc(istmp,"tmp","sys","functions_schema_id"), TYPE_int);
	BAT *U_func_id = sys_bat(Ucc(istmp,"tmp","sys","functions_id"), TYPE_int);
	BAT *U_func_name = sys_bat(Ucc(istmp,"tmp","sys","functions_name"), TYPE_str);
	BAT *U_func_func = sys_bat(Ucc(istmp,"tmp","sys","functions_func"), TYPE_str);
	BAT *U_func_mod = sys_bat(Ucc(istmp,"tmp","sys","functions_mod"), TYPE_str);
	BAT *U_func_sql = sys_bat(Ucc(istmp,"tmp","sys","functions_sql"), TYPE_bit);
	BAT *U_func_aggr = sys_bat(Ucc(istmp,"tmp","sys","functions_aggr"), TYPE_bit);
	BAT *U_func_schema_id = sys_bat(Ucc(istmp,"tmp","sys","functions_schema_id"), TYPE_int);
	BAT *D_func = sys_bat(Dcc(istmp,"tmp","sys","functions"), TYPE_oid);

	BAT *arg_id = sys_bat(Ccc(istmp,"tmp","sys","args_id"), TYPE_int);
	BAT *arg_func_id = sys_bat(Ccc(istmp,"tmp","sys","args_func_id"), TYPE_int);
	BAT *arg_name = sys_bat(Ccc(istmp,"tmp","sys","args_name"), TYPE_str);
	BAT *arg_type = sys_bat(Ccc(istmp,"tmp","sys","args_type"), TYPE_str);
	BAT *arg_type_digits = sys_bat(Ccc(istmp,"tmp","sys","args_type_digits"), TYPE_int);
	BAT *arg_type_scale = sys_bat(Ccc(istmp,"tmp","sys","args_type_scale"), TYPE_int);
	BAT *arg_number = sys_bat(Ccc(istmp,"tmp","sys","args_number"), TYPE_int);
	BAT *U_arg_id = sys_bat(Ucc(istmp,"tmp","sys","args_id"), TYPE_int);
	BAT *U_arg_func_id = sys_bat(Ucc(istmp,"tmp","sys","args_func_id"), TYPE_int);
	BAT *U_arg_name = sys_bat(Ucc(istmp,"tmp","sys","args_name"), TYPE_str);
	BAT *U_arg_type = sys_bat(Ucc(istmp,"tmp","sys","args_type"), TYPE_str);
	BAT *U_arg_type_digits = sys_bat(Ucc(istmp,"tmp","sys","args_type_digits"), TYPE_int);
	BAT *U_arg_type_scale = sys_bat(Ucc(istmp,"tmp","sys","args_type_scale"), TYPE_int);
	BAT *U_arg_number = sys_bat(Ucc(istmp,"tmp","sys","args_number"), TYPE_int);
	BAT *D_arg = sys_bat(Dcc(istmp,"tmp","sys","args"), TYPE_oid);

	if (BATcount(func_name) == 0) {
		oid rid = func_id->hseqbase + BATcount(func_id);
		for (n = funcs->h; n; n = n->next, rid++) {
			sql_func *f = n->data;
			bit sql = f->sql;
			int id, nr = 0;
			char arg_nme[] = "arg_0";
			oid aid = arg_id->hseqbase + BATcount(arg_id);

			BUNins(func_id, &rid, &f->base.id, FALSE);
			BUNins(func_name, &rid, f->base.name, FALSE);
			BUNins(func_func, &rid, f->imp, FALSE);
			BUNins(func_mod, &rid, f->mod, FALSE);
			BUNins(func_sql, &rid, &sql, FALSE);
			BUNins(func_aggr, &rid, &F, FALSE);
			BUNins(func_schema_id, &rid, &zero, FALSE);
		
			if (f->res.type) {
				char *name = "result";

				id = next_oid();
				BUNins(arg_id, &aid, &id, FALSE);
				BUNins(arg_func_id, &aid, &f->base.id, FALSE);
				BUNins(arg_name, &aid, name, FALSE);
				BUNins(arg_type, &aid, f->res.type->sqlname, FALSE);
				BUNins(arg_type_digits, &aid, &f->res.scale, FALSE);
				BUNins(arg_type_scale, &aid, &f->res.scale, FALSE);
				BUNins(arg_number, &aid, &nr, FALSE);
				nr++;
				aid++;
			}
			for (m = f->ops->h; m; m = m->next, nr++, aid++) {
				sql_arg *a = m->data;

				id = next_oid();
				BUNins(arg_id, &aid, &id, FALSE);
				BUNins(arg_func_id, &aid, &f->base.id, FALSE);
				if (a->name) {
					BUNins(arg_name, &aid, a->name, FALSE);
				} else {
					arg_nme[4] = '0' + nr;
					BUNins(arg_name, &aid, arg_nme, FALSE);
				}
				BUNins(arg_type, &aid, a->type.type->sqlname, FALSE);
				BUNins(arg_type_digits, &aid, &a->type.scale, FALSE);
				BUNins(arg_type_scale, &aid, &a->type.scale, FALSE);
				BUNins(arg_number, &aid, &nr, FALSE);
			}
		}
		for (n = aggrs->h; n; n = n->next, rid++) {
			char *name1 = "result";
			char *name2 = "arg";
			sql_aggr *aggr = n->data;
			int nr = 0, id;
			oid aid = arg_id->hseqbase + BATcount(arg_id);

			BUNins(func_id, &rid, &aggr->base.id, FALSE);
			BUNins(func_name, &rid, aggr->base.name, FALSE);
			BUNins(func_func, &rid, aggr->imp, FALSE);
			BUNins(func_mod, &rid, aggr->mod, FALSE);
			BUNins(func_sql, &rid, &F, FALSE);
			BUNins(func_aggr, &rid, &T, FALSE);
			BUNins(func_schema_id, &rid, &zero, FALSE);

			id = next_oid();
			BUNins(arg_id, &aid, &id, FALSE);
			BUNins(arg_func_id, &aid, &aggr->base.id, FALSE);
			BUNins(arg_name, &aid, name1, FALSE);
			BUNins(arg_type, &aid, aggr->res.type->sqlname, FALSE);
			BUNins(arg_type_digits, &aid, &aggr->res.scale, FALSE);
			BUNins(arg_type_scale, &aid, &aggr->res.scale, FALSE);
			BUNins(arg_number, &aid, &nr, FALSE);
			nr++;
			aid++;

			if (aggr->tpe.type) {
				id = next_oid();
				BUNins(arg_id, &aid, &id, FALSE);
				BUNins(arg_func_id, &aid, &aggr->base.id, FALSE);
				BUNins(arg_name, &aid, name2, FALSE);
				BUNins(arg_type, &aid, aggr->tpe.type->sqlname, FALSE);
				BUNins(arg_type_digits, &aid, &aggr->tpe.scale, FALSE);
				BUNins(arg_type_scale, &aid, &aggr->tpe.scale, FALSE);
				BUNins(arg_number, &aid, &nr, FALSE);
				aid++;
			}
		}
	}

	bat_destroy(func_id);
	bat_destroy(func_name);
	bat_destroy(func_func);
	bat_destroy(func_mod);
	bat_destroy(func_sql);
	bat_destroy(func_aggr);
	bat_destroy(func_schema_id);
	bat_destroy(U_func_id);
	bat_destroy(U_func_name);
	bat_destroy(U_func_func);
	bat_destroy(U_func_mod);
	bat_destroy(U_func_sql);
	bat_destroy(U_func_aggr);
	bat_destroy(U_func_schema_id);
	bat_destroy(D_func);

	bat_destroy(arg_id);
	bat_destroy(arg_func_id);
	bat_destroy(arg_name);
	bat_destroy(arg_type);
	bat_destroy(arg_type_digits);
	bat_destroy(arg_type_scale);
	bat_destroy(arg_number);
	bat_destroy(U_arg_id);
	bat_destroy(U_arg_func_id);
	bat_destroy(U_arg_name);
	bat_destroy(U_arg_type);
	bat_destroy(U_arg_type_digits);
	bat_destroy(U_arg_type_scale);
	bat_destroy(U_arg_number);
	bat_destroy(D_arg);
}


static sql_column *
bootstrap_create_column(sql_trans *tr, sql_table *t, char *name, char *sqltype, int digits)
{
	char bname[BUFSIZ];
	sql_column *col = NEW(sql_column);
	int istmp = 0; /* global temps are stored in the sys schema */

	BAT *b;
	oid rid;

	if (bs_debug)
		fprintf(stderr, "bootstrap_create_column %s\n", name );

	base_init(&col->base, next_oid(), TR_NEW, name);
	sql_find_subtype(&col->type, sqltype, digits, 0);
	col->def = NULL;
	col->null = 1;
	col->colnr = cs_size(&t->columns);
	col->t = t;
	col->unique = 0;
	cs_add(&t->columns, col, TR_NEW);

	col->bat.ibid = col->bat.bid = col->bat.ubid = 0;
	col->bat.name = col->bat.uname = NULL;

	/* need to use ibid here as we are making changes to it */

	snprintf(bname, BUFSIZ, "%s_%s_%s", col->t->s->base.name, col->t->base.name, col->base.name);
	col->bat.name = _strdup(bname);
	b = temp_descriptor(logger_find_bat(sql_logger, col->bat.name));
	col->bat.ibid = temp_create(b);
	bat_destroy(b);

	b = get_bat(Ccc(istmp,"tmp","sys","_columns_id"));
	rid = BATcount(b);
	BUNins(b, (ptr) &rid, (ptr) &col->base.id, FALSE);
	bat_destroy(b);

	b = get_bat(Ccc(istmp,"tmp","sys","_columns_table_id"));
	BUNins(b, (ptr) &rid, (ptr) &t->base.id, FALSE);
	bat_destroy(b);

	b = get_bat(Ccc(istmp,"tmp","sys","_columns_name"));
	BUNins(b, (ptr) &rid, (ptr) col->base.name, FALSE);
	bat_destroy(b);

	b = get_bat(Ccc(istmp,"tmp","sys","_columns_type"));
	BUNins(b, (ptr) &rid, (ptr) col->type.type->sqlname, FALSE);
	bat_destroy(b);

	b = get_bat(Ccc(istmp,"tmp","sys","_columns_type_digits"));
	BUNins(b, (ptr) &rid, (ptr) &col->type.digits, FALSE);
	bat_destroy(b);

	b = get_bat(Ccc(istmp,"tmp","sys","_columns_type_scale"));
	BUNins(b, (ptr) &rid, (ptr) &col->type.scale, FALSE);
	bat_destroy(b);

	b = get_bat(Ccc(istmp,"tmp","sys","_columns_default"));
	if (col->def)
		BUNins(b, (ptr) &rid, (ptr) col->def, FALSE);
	else
		BUNins(b, (ptr) &rid, (ptr) ATOMnilptr(TYPE_str), FALSE);
	bat_destroy(b);

	b = get_bat(Ccc(istmp,"tmp","sys","_columns_null"));
	BUNins(b, (ptr) &rid, (ptr) &col->null, FALSE);
	bat_destroy(b);

	b = get_bat(Ccc(istmp,"tmp","sys","_columns_number"));
	BUNins(b, (ptr) &rid, (ptr) &col->colnr, FALSE);
	bat_destroy(b);

	col->base.wtime = t->base.wtime = t->s->base.wtime = tr->wtime = tr->stime;
	tr->schema_updates ++;

	return col;
}

sql_table *
create_sql_table(char *name, sht type, bit system, int persistence, int commit_action)
{
	sql_table *t = NEW(sql_table);

	assert((persistence==SQL_PERSIST || commit_action) && commit_action>=0);
	base_init(&t->base, next_oid(), TR_NEW, name);
	t->type = type;
	t->system = system;
	t->persistence = (temp_t)persistence;
	t->commit_action = (ca_t)commit_action;
	t->query = NULL;
	cs_init(&t->columns, (fdestroy) &column_destroy);
	cs_init(&t->idxs, (fdestroy) &idx_destroy);
	cs_init(&t->keys, (fdestroy) &key_destroy);
	cs_init(&t->triggers, (fdestroy) &trigger_destroy);
	t->pkey = NULL;
	t->dname = NULL;
	t->dbid = 0;
	t->sz = BATSIZE;
	t->cnt = 0;
	t->cleared = 0;
	t->s = NULL;
	return t;
}

static sql_table *
bootstrap_create_table(sql_trans *tr, sql_schema *s, char *name)
{
	char bname[BUFSIZ];
	int istmp = isTempSchema(s);
	int persistence = istmp?SQL_GLOBAL_TEMP:SQL_PERSIST;
	sht commit_action = istmp?CA_PRESERVE:CA_COMMIT;
	sql_table *t = create_sql_table(name, tt_table, 1, persistence, commit_action);

	BAT *b;
	oid rid;

	if (bs_debug)
		fprintf(stderr, "bootstrap_create_table %s\n", name );

	t->query = NULL;
	t->s = s;
	cs_add(&s->tables, t, TR_NEW);

	snprintf(bname, BUFSIZ, "D_%s_%s", t->s->base.name, t->base.name);
	t->dname = _strdup(bname);
	b = temp_descriptor(logger_find_bat(sql_logger, t->dname));
	t->dbid = temp_create(b);
	bat_destroy(b);

	assert(t->dbid);

	istmp = 0; /* global temps are stored in the sys schema */
	b = get_bat(Ccc(istmp,"tmp","sys","_tables_id"));
	rid = BATcount(b);
	BUNins(b, (ptr) &rid, (ptr) &t->base.id, FALSE);
	bat_destroy(b);
	b = get_bat(Ccc(istmp,"tmp","sys","_tables_schema_id"));
	BUNins(b, (ptr) &rid, (ptr) &s->base.id, FALSE);
	bat_destroy(b);
	b = get_bat(Ccc(istmp,"tmp","sys","_tables_name"));
	BUNins(b, (ptr) &rid, (ptr) t->base.name, FALSE);
	bat_destroy(b);
	b = get_bat(Ccc(istmp,"tmp","sys","_tables_type"));
	BUNins(b, (ptr) &rid, (ptr) &t->type, FALSE);
	bat_destroy(b);
	b = get_bat(Ccc(istmp,"tmp","sys","_tables_system"));
	BUNins(b, (ptr) &rid, (ptr) &t->system, FALSE);
	bat_destroy(b);
	b = get_bat(Ccc(istmp,"tmp","sys","_tables_commit_action"));
	BUNins(b, (ptr) &rid, (ptr) &commit_action, FALSE);
	bat_destroy(b);
	b = get_bat(Ccc(istmp,"tmp","sys","_tables_query"));
	BUNins(b, (ptr) &rid, (ptr) ATOMnilptr(TYPE_str), FALSE);
	bat_destroy(b);

	t->base.wtime = s->base.wtime = tr->wtime = tr->stime;
	tr->schema_updates ++;
	return t;
}


static sql_schema *
bootstrap_create_schema(sql_trans *tr, char *name, int auth_id)
{
	sql_schema *s = NEW(sql_schema);
	int istmp = 0;

	BAT *b;
	oid rid;

	if (bs_debug)
		fprintf(stderr, "bootstrap_create_schema %s %d\n", name, auth_id);

	base_init(&s->base, next_oid(), TR_NEW, name);
	s->auth_id = auth_id;
	cs_init(&s->tables, (fdestroy) &table_destroy);
	cs_init(&s->types, (fdestroy) &type_destroy);
	cs_init(&s->funcs, (fdestroy) &func_destroy);
	cs_init(&s->seqs, (fdestroy) &seq_destroy);
	s->keys = list_create((fdestroy) NULL);
	s->idxs = list_create((fdestroy) NULL);
	s->triggers = list_create((fdestroy) NULL);

	cs_add(&tr->schemas, s, TR_NEW);

	b = get_bat(Ccc(istmp,"tmp","sys","schemas_id"));
	rid = BATcount(b);
	BUNins(b, (ptr) &rid, (ptr) &s->base.id, FALSE);
	bat_destroy(b);

	b = get_bat(Ccc(istmp,"tmp","sys","schemas_name"));
	BUNins(b, (ptr) &rid, (ptr) s->base.name, FALSE);
	bat_destroy(b);

	b = get_bat(Ccc(istmp,"tmp","sys","schemas_authorization"));
	BUNins(b, (ptr) &rid, (ptr) &s->auth_id, FALSE);
	bat_destroy(b);

	s->base.wtime = tr->wtime = tr->stime;
	tr->schema_updates ++;
	return s;
}

static int
store_schema_number()
{
	return schema_number;
}

int
store_init(int debug, char *logdir, char *dbname, backend_stack stk)
{
	int first = 0;
	int istmp = 0;

	bs_debug = debug;
	sql_logger = logger_create(debug, "sql", logdir, dbname, CATALOG_VERSION);

	if (!sql_logger)
		return -1;

	logger_sequence(sql_logger, OBJ_SID, &store_oid);
	MT_lock_init(&bs_lock);

	types_init(debug);

	bs_init_schema();
	bs_init_type();
	bs_init_func();
	bs_init_sequence();
	while(istmp<2) {
		bs_init_table(istmp);
		bs_init_column(istmp);
		bs_init_key(istmp);
		bs_init_idx(istmp);
		bs_init_trigger(istmp);
		istmp++;
	}
	sequences_init();

	gtrans = load_trans(stk);

	if (!find_sql_schema(gtrans, "sys")) {
		sql_schema *s, *p = NULL;
		sql_table *t;

		sql_trans *tr = sql_trans_create(stk, NULL, NULL);

		first = 1;

		/* todo introduce a dependencies table which keeps
		   dependencies between sql objects, such as
			call dependencies for func's
			sequence and table dependencies
			etc.
		*/
		s = bootstrap_create_schema(tr, "sys", ROLE_SYSADMIN);
		t = bootstrap_create_table(tr, s, "schemas");
		bootstrap_create_column(tr, t, "id", "int", 32);
		bootstrap_create_column(tr, t, "name", "varchar", 1024);
		bootstrap_create_column(tr, t, "authorization", "int", 32);

		t = bootstrap_create_table(tr, s, "types");
		bootstrap_create_column(tr, t, "id", "int", 32);
		bootstrap_create_column(tr, t, "systemname", "varchar", 256);
		bootstrap_create_column(tr, t, "sqlname", "varchar", 1024);
		bootstrap_create_column(tr, t, "digits", "int", 32);
		bootstrap_create_column(tr, t, "scale", "int", 32);
		bootstrap_create_column(tr, t, "radix", "int", 32);
		bootstrap_create_column(tr, t, "eclass", "int", 32);
		bootstrap_create_column(tr, t, "schema_id", "int", 32);

		t = bootstrap_create_table(tr, s, "functions");
		bootstrap_create_column(tr, t, "id", "int", 32);
		bootstrap_create_column(tr, t, "name", "varchar", 256);
		bootstrap_create_column(tr, t, "func", "varchar", 8196);
		bootstrap_create_column(tr, t, "mod", "varchar", 8196);
		/* sql or database internal */
		bootstrap_create_column(tr, t, "sql", "boolean", 1);
		/* aggr or func */
		bootstrap_create_column(tr, t, "aggr", "boolean", 1);
		bootstrap_create_column(tr, t, "schema_id", "int", 32);

		t = bootstrap_create_table(tr, s, "args");
		bootstrap_create_column(tr, t, "id", "int", 32);
		bootstrap_create_column(tr, t, "func_id", "int", 32);
		bootstrap_create_column(tr, t, "name", "varchar", 256);
		bootstrap_create_column(tr, t, "type", "varchar", 1024);
		bootstrap_create_column(tr, t, "type_digits", "int", 32);
		bootstrap_create_column(tr, t, "type_scale", "int", 32);
		bootstrap_create_column(tr, t, "number", "int", 32);

		t = bootstrap_create_table(tr, s, "sequences");
		bootstrap_create_column(tr, t, "id", "int", 32);
		bootstrap_create_column(tr, t, "schema_id", "int", 32);
		bootstrap_create_column(tr, t, "name", "varchar", 256);
		bootstrap_create_column(tr, t, "start", "bigint", 64);
		bootstrap_create_column(tr, t, "minvalue", "bigint", 64);
		bootstrap_create_column(tr, t, "maxvalue", "bigint", 64);
		bootstrap_create_column(tr, t, "increment", "bigint", 64);
		bootstrap_create_column(tr, t, "cacheinc", "bigint", 64);
		bootstrap_create_column(tr, t, "cycle", "boolean", 1);

		while(s) {
			t = bootstrap_create_table(tr, s, "_tables");
			bootstrap_create_column(tr, t, "id", "int", 32);
			bootstrap_create_column(tr, t, "name", "varchar", 1024);
			bootstrap_create_column(tr, t, "schema_id", "int", 32);
			bootstrap_create_column(tr, t, "query", "varchar", 2048);
			bootstrap_create_column(tr, t, "type", "smallint", 16);
			bootstrap_create_column(tr, t, "system", "boolean", 0);
			bootstrap_create_column(tr, t, "commit_action", "smallint", 16); 

			t = bootstrap_create_table(tr, s, "_columns");
			bootstrap_create_column(tr, t, "id", "int", 32);
			bootstrap_create_column(tr, t, "name", "varchar", 1024);
			bootstrap_create_column(tr, t, "type", "varchar", 1024);
			bootstrap_create_column(tr, t, "type_digits", "int", 32);
			bootstrap_create_column(tr, t, "type_scale", "int", 32);
			bootstrap_create_column(tr, t, "table_id", "int", 32);
			bootstrap_create_column(tr, t, "default", "varchar", 2048);
			bootstrap_create_column(tr, t, "null", "boolean", 0);
			bootstrap_create_column(tr, t, "number", "int", 32);

			t = bootstrap_create_table(tr, s, "keys");
			bootstrap_create_column(tr, t, "id", "int", 32);
			bootstrap_create_column(tr, t, "table_id", "int", 32);
			bootstrap_create_column(tr, t, "type", "int", 32);
			bootstrap_create_column(tr, t, "name", "varchar", 1024);
			bootstrap_create_column(tr, t, "rkey", "int", 32);

			t = bootstrap_create_table(tr, s, "idxs");
			bootstrap_create_column(tr, t, "id", "int", 32);
			bootstrap_create_column(tr, t, "table_id", "int", 32);
			bootstrap_create_column(tr, t, "type", "int", 32);
			bootstrap_create_column(tr, t, "name", "varchar", 1024);

			t = bootstrap_create_table(tr, s, "triggers");
			bootstrap_create_column(tr, t, "id", "int", 32);
			bootstrap_create_column(tr, t, "name", "varchar", 1024);
			bootstrap_create_column(tr, t, "table_id", "int", 32);
			bootstrap_create_column(tr, t, "time", "smallint", 16);
			bootstrap_create_column(tr, t, "orientation", "smallint", 16);
			bootstrap_create_column(tr, t, "event", "smallint", 16);
			bootstrap_create_column(tr, t, "old_name", "varchar", 1024);
			bootstrap_create_column(tr, t, "new_name", "varchar", 1024);
			bootstrap_create_column(tr, t, "condition", "varchar", 2048);
			bootstrap_create_column(tr, t, "statement", "varchar", 2048);

			t = bootstrap_create_table(tr, s, "keycolumns");
			bootstrap_create_column(tr, t, "id", "int", 32);
			bootstrap_create_column(tr, t, "column", "varchar", 1024);
			bootstrap_create_column(tr, t, "trunc", "int", 32);
			bootstrap_create_column(tr, t, "nr", "int", 32);
			


			if (!p) {
				/*To create the dependency table*/
				create_dependency_table(tr,s);

				p = s; 
				/* now the same tables for temporaries */
				s = bootstrap_create_schema(tr, "tmp", ROLE_SYSADMIN);
			} else {
				s = NULL;
			}
		}

		if (sql_trans_commit(tr) != SQL_OK)
			fprintf(stderr, "cannot commit initial transaction\n");
		sql_trans_destroy(tr);
	}
	return first;
}

static int active = 1;
static int logging = 0;

void
store_exit(void)
{
	struct logger *l = sql_logger;

	/* never started! */
	if (!sql_logger)
		return;

	MT_set_lock(bs_lock, "store_exit");
	sql_logger = NULL;
#ifdef STORE_DEBUG
	fprintf(stderr, "store exit locked\n");
#endif
	active = 0;

	/* busy wait till the logmanager is ready */
	while (logging) {
		MT_unset_lock(bs_lock, "store_exit");
		MT_sleep_ms(100);
		MT_set_lock(bs_lock, "store_exit");
	}

	if (gtrans) {
		MT_unset_lock(bs_lock, "store_exit");
		sequences_exit();
		MT_set_lock(bs_lock, "store_exit");
	}
	if (spares > 0) 
		destroy_spare_transactions();

	logger_exit(l);
	logger_destroy(l);

	/* Open transactions have a link to the global transaction therefor
	   we need busy waiting until all transactions have ended or
	   (current implementation) simply keep the gtrans alive and simply
	   exit (but leak memory).
	 */ 
	if (!transactions) { 
		sql_trans_destroy(gtrans);
		gtrans = NULL;
	}
#ifdef STORE_DEBUG
	fprintf(stderr, "store exit unlocked\n");
#endif
	MT_unset_lock(bs_lock, "store_exit");
	types_exit();
}

void
store_manager(void)
{
	while (active) {
		int res = LOG_OK;

		MT_sleep_ms(30000);
		MT_set_lock(bs_lock, "store_manager");
		if (transactions || !active || !sql_logger || 
			logger_changes(sql_logger) < 1000) {
			MT_unset_lock(bs_lock, "store_manager");
			continue;
		}
		logging = 1;
		res = logger_restart(sql_logger);
		MT_unset_lock(bs_lock, "store_manager");
		if (logging && res == LOG_OK)
			logger_cleanup(sql_logger);
		logging = 0;
	}
}


void
store_lock(void)
{
	MT_set_lock(bs_lock, "trans_lock");
#ifdef STORE_DEBUG
	fprintf(stderr, "locked\n");
#endif
}

void
store_unlock(void)
{
#ifdef STORE_DEBUG
	fprintf(stderr, "unlocked\n");
#endif
	MT_unset_lock(bs_lock, "trans_unlock");
}

static sql_kc *
kc_dup(sql_trans *tr, int flag, sql_kc *kc, sql_table *t)
{
	sql_kc *nkc = NEW(sql_kc);
	sql_column *c = find_sql_column(t, kc->c->base.name);

	(void) tr;		/* unused! */
	(void) flag;
	assert(c);
	nkc->c = c;
	c->unique = kc->c->unique;
	nkc->trunc = kc->trunc;
	return nkc;
}

static sql_key *
key_dup(sql_trans *tr, int flag, sql_key *k, sql_table *t)
{
	sql_key *nk = (k->type != fkey) ? (sql_key *) NEW(sql_ukey)
	    : (sql_key *) NEW(sql_fkey);
	node *n;

	base_init(&nk->base, k->base.id, tr_flag(&k->base, flag), k->base.name);

	nk->type = k->type;
	nk->columns = list_create((fdestroy) &kc_destroy);
	nk->t = t;
	nk->idx = NULL;

	if (k->idx) {
		node *n = list_find_name(nk->t->s->idxs, nk->base.name);

		if (n) {
			nk->idx = (sql_idx *) n->data;
			nk->idx->key = nk;
		}
	}

	if (nk->type != fkey) {
		sql_ukey *tk = (sql_ukey *) nk;

		tk->keys = NULL;

		if (nk->type == pkey)
			t->pkey = tk;
	} else {
		sql_fkey *tk = (sql_fkey *) nk;

		tk->rkey = NULL;
	}

	for (n = k->columns->h; n; n = n->next) {
		sql_kc *okc = n->data;

		list_append(nk->columns, kc_dup(tr, flag, okc, t));
	}

	if (nk->type == fkey) {
		sql_fkey *fk = (sql_fkey *) nk;
		sql_fkey *ok = (sql_fkey *) k;
		node *n;

		if (ok->rkey) {
			n = list_find(t->s->keys, &ok->rkey->k.base.id, (fcmp) &key_cmp);

			if (n) {
				sql_ukey *uk = n->data;
	
				fk->rkey = uk;
				if (!uk->keys)
					uk->keys = list_create(NULL);
				list_append(uk->keys, fk);
			}
		}
	} else {		/* could be a set of rkeys */
		sql_ukey *uk = (sql_ukey *) nk;
		sql_ukey *ok = (sql_ukey *) k;
		node *m;

		if (ok->keys)
			for (m = ok->keys->h; m; m = m->next) {
				sql_fkey *ofk = m->data;
				node *n = list_find(t->s->keys, &ofk->k.base.id, (fcmp) &key_cmp);

				if (n) {
					sql_fkey *fk = n->data;

					if (!uk->keys)
						uk->keys = list_create(NULL);
					list_append(uk->keys, fk);
					fk->rkey = uk;
				}
			}
	}
	list_append(t->s->keys, nk);
	return nk;
}

static sql_idx *
idx_dup(sql_trans *tr, int flag, sql_idx * i, sql_table *t)
{
	sql_idx *ni = NEW(sql_idx);
	node *n;
	int type = TYPE_int;

	base_init(&ni->base, i->base.id, tr_flag(&i->base, flag), i->base.name);

	ni->columns = list_create((fdestroy) &kc_destroy);
	ni->t = t;
	ni->type = i->type;
	ni->bat.ibid = i->bat.ibid;
	ni->bat.bid = i->bat.bid;
	ni->bat.ubid = i->bat.ubid;
	ni->bat.name = ni->bat.uname = NULL; 

	ni->key = NULL;

	if (ni->type == join_idx)
		type = TYPE_oid;

	if (ni->bat.ibid) {
		BAT *b;
		if (isTempTable(ni->t)) {
			ni->bat.ibid = temp_copy(ni->bat.ibid, 1);
		} else if (isNew(i)) {
			/* move the bat to the new idx, fixup the old idx */
			b = bat_new(TYPE_void, type, ni->t->sz, "idx_dup");
			i->bat.ibid = temp_create(b); 
			if (flag == TR_NEW && tr->parent == gtrans) { 
				/* new idxs are moved to gtrans and bat.bid */
				temp_dup(ni->bat.ibid);
				i->bat.bid = ni->bat.ibid;
				i->base.flag = TR_OLD;
			}
			if (i->bat.bid) {
				BAT *cb = temp_descriptor(i->bat.bid);
				BATseqbase(b, BATcount(cb));
				bat_destroy(cb);
			} 
			bat_destroy(b);
		} else { /* old idx */
			ni->bat.ibid = temp_copy(ni->bat.ibid, 0);
		}
	}
	ni->bat.ubid = i->bat.ubid;
	if (isTable(ni->t) && !isTempTable(ni->t)) { /* new ubid */
		if (ni->bat.ubid) { /* new ubid */
			ni->bat.ubid = temp_copy(ni->bat.ubid, 0);
		} else {
			BAT *b = bat_new(TYPE_oid, type, ni->t->sz, "idx_dup");
			ni->bat.ubid = temp_create(b);
			bat_destroy(b);

			/* old needs an update bat too */
			b = bat_new(TYPE_oid, type, ni->t->sz, "idx_dup");
			i->bat.ubid = temp_create(b);
			bat_destroy(b);
		}
	}
	if (ni->bat.bid) 
		temp_dup(ni->bat.bid);

	for (n = i->columns->h; n; n = n->next) {
		sql_kc *okc = n->data;

		list_append(ni->columns, kc_dup(tr, flag, okc, t));
	}
	list_append(t->s->idxs, ni);
	return ni;
}

static sql_trigger *
trigger_dup(sql_trans *tr, int flag, sql_trigger * i, sql_table *t)
{
	sql_trigger *nt = NEW(sql_trigger);
	node *n;

	base_init(&nt->base, i->base.id, tr_flag(&i->base, flag), i->base.name);

	nt->columns = list_create((fdestroy) &kc_destroy);
	nt->t = t;
	nt->time = i->time;
	nt->orientation = i->orientation;
	nt->event = i->event;
	nt->old_name = nt->new_name = nt->condition = NULL;
	if (i->old_name)
		nt->old_name = _strdup(i->old_name);
	if (i->new_name)
		nt->new_name = _strdup(i->new_name);
	if (i->condition)
		nt->condition = _strdup(i->condition);
	nt->statement = _strdup(i->statement);

	for (n = i->columns->h; n; n = n->next) {
		sql_kc *okc = n->data;

		list_append(nt->columns, kc_dup(tr, flag, okc, t));
	}
	list_append(t->s->triggers, nt);
	return nt;
}

static sql_column *
column_dup(sql_trans *tr, int flag, sql_column *oc, sql_table *t)
{
	sql_column *c = NEW(sql_column);

	(void)tr;
	base_init(&c->base, oc->base.id, tr_flag(&oc->base, flag), oc->base.name);
	c->type = oc->type;
	c->def = NULL;
	if (oc->def)
		c->def = _strdup(oc->def);
	c->null = oc->null;
	c->colnr = oc->colnr;
	c->unique = oc->unique;

	c->t = t;

	c->bat.ibid = oc->bat.ibid;
	c->bat.bid = oc->bat.bid;
	c->bat.name = c->bat.uname = NULL;

	if (c->bat.ibid) {
		BAT *b;
		if (isTempTable(c->t)) {
			c->bat.ibid = temp_copy(c->bat.ibid, 1);
		} else if (isNew(oc)) { 
			int type = c->type.type->localtype;
			/* move the bat to the new column, fixup the old column */
			b = bat_new(TYPE_void, type, c->t->sz, "column_dup");
			oc->bat.ibid = temp_create(b);
			if (flag == TR_NEW && tr->parent == gtrans) { 
				/* new columns are moved to gtrans and bat.bid */
				temp_dup(c->bat.ibid);
				oc->bat.bid = c->bat.ibid;
				oc->base.flag = TR_OLD;
			}
			if (oc->bat.bid) {
				BAT *cb = temp_descriptor(oc->bat.bid);
				BATseqbase(b, BATcount(cb));
				bat_destroy(cb);
			}
			bat_destroy(b);
		} else { /* old column */
			c->bat.ibid = temp_copy(c->bat.ibid, 0); 
		}
	}
	c->bat.ubid = oc->bat.ubid;
	if (isTable(c->t) && !isTempTable(c->t)) { /* new ubid */
		if (c->bat.ubid) {
			c->bat.ubid = temp_copy(c->bat.ubid, 0);
		} else {
			int type = c->type.type->localtype;
			BAT *b = bat_new(TYPE_oid, type, c->t->sz,"column_dup");
			c->bat.ubid = temp_create(b);
			bat_destroy(b);
			
			/* old needs an update bat too */
			b = bat_new(TYPE_oid, type, c->t->sz, "column_dup");
			oc->bat.ubid = temp_create(b);
			bat_destroy(b);
		}
	}
	if (c->bat.bid)
		temp_dup(c->bat.bid);

	if (bs_debug&2) {
		fprintf(stderr, "column_dup %s.%s (%d) %d %d %d",
				c->t->base.name, c->base.name, c->base.flag,
				c->bat.ibid, c->bat.bid, c->bat.ubid
				);
		fprintf(stderr, " <- (%d) %d %d %d\n",
				oc->base.flag, 
				oc->bat.ibid, oc->bat.bid, oc->bat.ubid
				);
	}
	return c;
}

static sql_table *
table_dup(sql_trans *tr, int flag, sql_table *ot, sql_schema *s)
{
	node *n;
	sql_table *t = NEW(sql_table);

	base_init(&t->base, ot->base.id, tr_flag(&ot->base, flag), ot->base.name);

	t->type = ot->type;
	t->system = ot->system;
	t->persistence = ot->persistence;
	t->commit_action = ot->commit_action;
	t->query = (ot->query) ? _strdup(ot->query) : NULL;

	cs_init(&t->columns, (fdestroy) &column_destroy);
	cs_init(&t->keys, (fdestroy) &key_destroy);
	cs_init(&t->idxs, (fdestroy) &idx_destroy);
	cs_init(&t->triggers, (fdestroy) &trigger_destroy);

	t->pkey = NULL;

	t->dname = NULL;
	t->dbid = ot->dbid;
	if (t->dbid) {
		if (isNew(t)) {
			ot->dbid = temp_copy(t->dbid, isTempTable(t));
		} else {
			t->dbid = temp_copy(t->dbid, isTempTable(t));
		}
	}

	t->s = s;
	t->sz = ot->sz;
	t->cnt = ot->cnt;
	t->cleared = 0;

	if (ot->columns.set) {
		for (n = ot->columns.set->h; n; n = n->next) {
			sql_column *c = n->data;

			cs_add(&t->columns, column_dup(tr, flag, c, t), tr_flag(&c->base, flag));
		}
		ot->columns.nelm = NULL;
	}
	if (ot->idxs.set) {
		for (n = ot->idxs.set->h; n; n = n->next) {
			sql_idx *i = n->data;

			cs_add(&t->idxs, idx_dup(tr, flag, i, t), tr_flag(&i->base, flag));
		}
		ot->idxs.nelm = NULL;
	}
	if (ot->keys.set) {
		for (n = ot->keys.set->h; n; n = n->next) {
			sql_key *k = n->data;

			cs_add(&t->keys, key_dup(tr, flag, k, t), tr_flag(&k->base, flag));
		}
		ot->keys.nelm = NULL;
	}
	if (ot->triggers.set) {
		for (n = ot->triggers.set->h; n; n = n->next) {
			sql_trigger *k = n->data;

			cs_add(&t->triggers, trigger_dup(tr, flag, k, t), tr_flag(&k->base, flag));
		}
		ot->triggers.nelm = NULL;
	}
	if (flag == TR_NEW && tr->parent == gtrans) 
		ot->base.flag = TR_OLD;
	return t;
}

static sql_type *
type_dup(sql_trans *tr, int flag, sql_type *ot, sql_schema * s)
{
	sql_type *t = NEW(sql_type);

	(void) tr;
	base_init(&t->base, ot->base.id, tr_flag(&ot->base, flag), ot->base.name);

	t->sqlname = _strdup(ot->sqlname);
	t->digits = ot->digits;
	t->scale = ot->scale;
	t->radix = ot->radix;
	t->localtype = ot->localtype;
	t->s = s;
	return t;
}

static sql_func *
func_dup(sql_trans *tr, int flag, sql_func *of, sql_schema * s)
{
	node *n;
	sql_func *f = NEW(sql_func);

	(void)tr;
	base_init(&f->base, of->base.id, tr_flag(&of->base, flag), of->base.name);

	f->imp = _strdup(of->imp);
	f->mod = _strdup(of->mod);
	f->sql = of->sql;
	f->aggr = of->aggr;
	f->ops = list_create(of->ops->destroy);
	for(n=of->ops->h; n; n = n->next) 
		list_append(f->ops, arg_dup(n->data));
	f->res.type = NULL;
	if (of->res.type) {
		f->res = of->res;

		/* complex (table) types */
		if (f->res.type->localtype == TYPE_bat) 
			f->res.comp_type = schema_get_table(s, f->res.digits);
	}

	f->s = s;
	return f;
}

static sql_sequence *
seq_dup(sql_trans *tr, int flag, sql_sequence *oseq, sql_schema * s)
{
	sql_sequence *seq = NEW(sql_sequence);

	(void)tr;
	base_init(&seq->base, oseq->base.id, tr_flag(&oseq->base, flag), oseq->base.name);

	seq->start = oseq->start;
	seq->minvalue = oseq->minvalue;
	seq->maxvalue = oseq->maxvalue;
	seq->increment = oseq->increment;
	seq->cacheinc = oseq->cacheinc;
	seq->cycle = oseq->cycle;
	seq->s = s;
	return seq;
}

static sql_schema *
schema_dup(sql_trans *tr, int flag, sql_schema *os, sql_trans *o)
{
	node *n;
	sql_schema *s = NEW(sql_schema);

	(void) o;
	base_init(&s->base, os->base.id, tr_flag(&os->base, flag), os->base.name);

	s->auth_id = os->auth_id;
	cs_init(&s->tables, (fdestroy) &table_destroy);
	cs_init(&s->types, (fdestroy) &type_destroy);
	cs_init(&s->funcs, (fdestroy) &func_destroy);
	cs_init(&s->seqs, (fdestroy) &seq_destroy);
	s->keys = list_create((fdestroy) NULL);
	s->idxs = list_create((fdestroy) NULL);
	s->triggers = list_create((fdestroy) NULL);

	if (os->types.set) {
		for (n = os->types.set->h; n; n = n->next) {
			cs_add(&s->types, type_dup(tr, flag, n->data, s), tr_flag(&os->base, flag));
		}
		os->types.nelm = NULL;
	}
	if (os->tables.set) {
		for (n = os->tables.set->h; n; n = n->next) {
			sql_table *ot = n->data;

			if (ot->persistence != SQL_LOCAL_TEMP)
				cs_add(&s->tables, table_dup(tr, flag, ot, s), tr_flag(&ot->base, flag));
		}
		os->tables.nelm = NULL;
	}
	if (os->funcs.set) {
		for (n = os->funcs.set->h; n; n = n->next) {
			cs_add(&s->funcs, func_dup(tr, flag, n->data, s), tr_flag(&os->base, flag));
		}
		os->funcs.nelm = NULL;
	}
	if (os->seqs.set) {
		for (n = os->seqs.set->h; n; n = n->next) {
			cs_add(&s->seqs, seq_dup(tr, flag, n->data, s), tr_flag(&os->base, flag));
		}
		os->seqs.nelm = NULL;
	}
	if (flag == TR_NEW && tr->parent == gtrans) 
		os->base.flag = TR_OLD;
	return s;
}

static sql_trans *
trans_init(sql_trans *t, backend_stack stk, sql_trans *ot)
{
	t->wtime = t->rtime = 0;
	t->stime = timestamp ();
	t->schema_updates = 0;
	t->status = 0;
	if (ot != gtrans)
		t->schema_updates = ot->schema_updates;

	t->schema_number = store_schema_number();
	t->parent = ot;
	t->stk = stk;

	t->name = NULL;
	if (bs_debug) 
		fprintf(stderr, "trans init (%d,%d)\n", 
			t->stime, t->schema_number ); 
	return t;
}

static sql_trans *
trans_dup(backend_stack stk, sql_trans *ot, char *newname)
{
	node *n;
	sql_trans *t = NEW(sql_trans);

	t = trans_init(t, stk, ot);

	cs_init(&t->schemas, (fdestroy) &schema_destroy);

	/* name the old transaction */
	if (newname) {
		assert(ot->name == NULL);
		ot->name = _strdup(newname);
	}

	if (ot->schemas.set) {
		for (n = ot->schemas.set->h; n; n = n->next) {
			cs_add(&t->schemas, schema_dup(t, TR_OLD, n->data, t), TR_OLD);
		}
		ot->schemas.nelm = NULL;
	}
	return t;
}

typedef int (*rfufunc) (sql_trans *tr, sql_base * fs, sql_base * ts);
typedef sql_base *(*rfcfunc) (sql_trans *tr, sql_base * b);
typedef int (*rfdfunc) (sql_trans *tr, sql_base * b);
typedef sql_base *(*dupfunc) (sql_trans *tr, int flag, sql_base * b, sql_base * p);

static int
rollforward_changeset_updates(sql_trans *tr, changeset * fs, changeset * ts, sql_base * b, rfufunc rollforward_updates, rfcfunc rollforward_creates, rfdfunc rollforward_deletes, dupfunc fd)
{
	int ok = LOG_OK;
	node *n = NULL;

	/* delete removed bases */
	if (fs->dset)
		for (n = fs->dset->h; ok == LOG_OK && n; n = n->next) {
			sql_base *fb = n->data;
			node *tbn = cs_find_name(ts, fb->name);

			if (tbn) {
				sql_base *tb = tbn->data;

				if (rollforward_deletes)
					ok = rollforward_deletes(tr, tb);
				if (ts->nelm == tbn)
					ts->nelm = tbn->next;
				if (tr->parent != gtrans) {
					if (!ts->dset)
						ts->dset = list_create(ts->destroy);
					list_move_data(ts->set, ts->dset, tb);
				} else {
					list_remove_node(ts->set, tbn);
				}
			}
		}
		list_destroy(fs->dset);
		fs->dset = NULL;
	/* changes to the existing bases */
	if (fs->set) {
		/* update existing */
		if (rollforward_updates) {
			for (n = fs->set->h; ok == LOG_OK && n && n != fs->nelm; n = n->next) {
				sql_base *fb = n->data;
				node *tbn = cs_find_name(ts, fb->name);

				if (tbn && fb->wtime && fb->flag == TR_OLD) {
					sql_base *tb = tbn->data;

					/* update timestamps */
					if (fb->rtime && tr->stime > tb->rtime)
						tb->rtime = tr->stime;
					if (fb->wtime && tr->stime > tb->wtime)
						tb->wtime = tr->stime;

					ok = rollforward_updates(tr, fb, tb);
				}
				fb->rtime = fb->wtime = 0;
			}
		}
		/* add the new bases */
		if (fd && rollforward_creates) {
			for (n = fs->nelm; ok == LOG_OK && n; ) {
				node *nxt = n->next;
				sql_base *fb = n->data;
				sql_base *tb = fd(tr, TR_NEW, fb, b);

				/* conditional add the new bases */
				if (tb) {
					sql_base *r = rollforward_creates(tr, tb);

					if (r)
						cs_add(ts, r, TR_NEW);
					else
						ok = LOG_ERR;
				}
				fb->rtime = fb->wtime = 0;
				fb->flag = TR_OLD;
				n = nxt;
			}
			fs -> nelm = NULL;
		}
	}
	return ok;
}

static int
rollforward_changeset_creates(sql_trans *tr, changeset * cs, rfcfunc rf)
{
	if (cs->set) {
		node *n;

		for (n = cs->set->h; n; n = n->next) {
			sql_base *b = n->data;

			if (!rf(tr, b))
				return LOG_ERR;

			b->rtime = b->wtime = 0;
			b->flag = TR_OLD;
		}
		cs->nelm = NULL;
	}
	return LOG_OK;
}

static int
rollforward_changeset_deletes(sql_trans *tr, changeset * cs, rfdfunc rf)
{
	int ok = LOG_OK;

	if (!cs)
		return ok;
	if (cs->dset) {
		node *n;

		for (n = cs->dset->h; ok == LOG_OK && n; n = n->next) {
			sql_base *b = n->data;

			ok = rf(tr, b);
		}
		list_destroy(cs->dset);
		cs->dset = NULL;
	}
	if (cs->set) {
		node *n;

		for (n = cs->set->h; ok == LOG_OK && n; n = n->next) {
			sql_base *b = n->data;

			ok = rf(tr, b);
		}
	}
	return ok;
}

static sql_idx *
rollforward_create_idx(sql_trans *tr, sql_idx * i)
{
	int ok = LOG_OK;

	if (i->bat.ibid) {
		char bname[BUFSIZ];
		BAT *u, *I, *b = temp_descriptor(i->bat.ibid);

		snprintf(bname, BUFSIZ, "%s_%s_%s", i->t->s->base.name, i->t->base.name, i->base.name);
		i->bat.name = _strdup(bname);
		i->bat.bid = logger_add_bat(sql_logger, b, bname);
		temp_destroy(i->bat.ibid);
		i->bat.ibid = 0;

		if (tr->parent == gtrans)
			ok = log_bat_persists(sql_logger, b, i->bat.name);

		snprintf(bname, BUFSIZ, "U_%s", i->bat.name);
		i->bat.uname = _strdup(bname);
		if (i->bat.ubid)
			u = temp_descriptor(i->bat.ubid);
		else 
			u = bat_new(TYPE_oid, b->ttype, i->t->sz, "rollforward_create_idx");
		(void) logger_add_bat(sql_logger, u, bname);
		i->bat.ubid = temp_create(u);

		if (tr->parent == gtrans && ok == LOG_OK)
			ok = log_bat_persists(sql_logger, u, i->bat.uname);

		bat_destroy(u);

		I = bat_new(TYPE_void, b->ttype, i->t->sz, "rollforward");
		BATseqbase(I, BATcount(b));
		i->bat.ibid = temp_create(I);
		
		bat_destroy(I);
		bat_destroy(b);
	} else if (i->key != NULL) {
		/* TODO fix key-ed ness over two bats */
		sql_kc *c = i->columns->h->data;
		BAT *b = bind_bat(tr->parent, c->c, RDONLY);

		BATkey(BATmirror(b), BOUND2BTRUE);
		bat_destroy(b);
	}
	if (ok != LOG_OK)
		return NULL;
	return i;
}

static sql_key *
rollforward_create_key(sql_trans *tr, sql_key *k)
{
	(void) tr;
	return k;
}

static sql_trigger *
rollforward_create_trigger(sql_trans *tr, sql_trigger *k)
{
	(void) tr;
	return k;
}

static sql_type *
rollforward_create_type(sql_trans *tr, sql_type *k)
{
	(void) tr;
	return k;
}

static sql_func *
rollforward_create_func(sql_trans *tr, sql_func *k)
{
	(void) tr;
	return k;
}

static sql_sequence *
rollforward_create_seq(sql_trans *tr, sql_sequence *k)
{
	(void) tr;
	return k;
}


static sql_column *
rollforward_create_column(sql_trans *tr, sql_column *c)
{
	int ok = LOG_OK;
	char bname[BUFSIZ];
	BAT *b, *u, *i;

	if (!isTempTable(c->t)) {
		/* only log on toplevel */
		b = temp_descriptor(c->bat.ibid);

		snprintf(bname, BUFSIZ, "%s_%s_%s", c->t->s->base.name, c->t->base.name, c->base.name);
		c->bat.name = _strdup(bname);
		c->bat.bid = logger_add_bat(sql_logger, b, bname);
		temp_destroy(c->bat.ibid);
		c->bat.ibid = 0;

		if (tr->parent == gtrans)
			ok = log_bat_persists(sql_logger, b, c->bat.name);

		c->t->cnt = BATcount(b);

		snprintf(bname, BUFSIZ, "U_%s", c->bat.name);
		c->bat.uname = _strdup(bname);
		if (c->bat.ubid)
			u = temp_descriptor(c->bat.ubid);
		else 
			u = bat_new(TYPE_oid, b->ttype, c->t->sz, "rollforward");
		(void) logger_add_bat(sql_logger, u, bname);
		c->bat.ubid = temp_create(u);

		if (tr->parent == gtrans && ok == LOG_OK)
			ok = log_bat_persists(sql_logger, u, c->bat.uname);

		bat_destroy(u);

		i = bat_new(TYPE_void, b->ttype, c->t->sz, "rollforward");
		BATseqbase(i, BATcount(b));
		c->bat.ibid = temp_create(i);
		
		bat_destroy(i);
		bat_destroy(b);
	}
	if (tr->parent == gtrans) 
		c->base.flag = TR_OLD;	

	if (ok != LOG_OK)
		return NULL;
	return c;
}

static sql_table *
rollforward_create_table(sql_trans *tr, sql_table *t)
{
	int ok = LOG_OK;

	if (bs_debug) 
		fprintf(stderr, "create table %s\n", t->base.name);

	if (isTable(t) && isGlobalTable(t)) {
		/* only register bats without commit action tables */
		rollforward_changeset_creates(tr, &t->columns, (rfcfunc) &rollforward_create_column);
		if (!isTempTable(t)) {
			char name[BUFSIZ];

			BAT *d = temp_descriptor(t->dbid);
			t->dbid = temp_create(d);

			snprintf(name, BUFSIZ, "D_%s_%s", t->s->base.name, t->base.name);
			t->dname = _strdup(name);
			(void) logger_add_bat(sql_logger, d, t->dname);

			if (tr->parent == gtrans)
				ok = log_bat_persists(sql_logger, d, t->dname);

			t->cnt -= BATcount(d);
			bat_destroy(d);
		}

		rollforward_changeset_creates(tr, &t->keys, (rfcfunc) &rollforward_create_key);
		rollforward_changeset_creates(tr, &t->idxs, (rfcfunc) &rollforward_create_idx);
		rollforward_changeset_creates(tr, &t->triggers, (rfcfunc) &rollforward_create_trigger);
	}
	if (tr->parent == gtrans) 
		t->base.flag = TR_OLD;	
	if (ok != LOG_OK)
		return NULL;
	return t;
}

static int
rollforward_drop_column(sql_trans *tr, sql_column *c)
{
	int ok = LOG_OK;

	if (c->bat.bid && c->bat.ubid) {
		log_bid bid;

		if (tr->parent == gtrans) {
			ok = log_bat_transient(sql_logger, c->bat.name);

			if (ok == LOG_OK)
				ok = log_bat_transient(sql_logger, c->bat.uname);

			bid = logger_find_bat(sql_logger, c->bat.name);
			if (bid) 
				logger_del_bat(sql_logger, bid);

			bid = logger_find_bat(sql_logger, c->bat.uname);
			if (bid) 
				logger_del_bat(sql_logger, bid);
		}
	}
	return LOG_OK;
}

static int
rollforward_drop_idx(sql_trans *tr, sql_idx * i)
{
	int ok = LOG_OK;

	if (i->bat.bid && i->bat.ubid) {
		log_bid bid;
		if (tr->parent == gtrans) {
			ok = log_bat_transient(sql_logger, i->bat.name);

			if (ok == LOG_OK)
				ok = log_bat_transient(sql_logger, i->bat.uname);

			bid = logger_find_bat(sql_logger, i->bat.name);
			if (bid)
				logger_del_bat(sql_logger, bid);
		
			bid = logger_find_bat(sql_logger, i->bat.uname);
			if (bid) 
				logger_del_bat(sql_logger, bid);
		}
	}
	/* remove idx from schema */
	list_remove_data(i->t->s->idxs, i);
	return LOG_OK;
}

static int
rollforward_drop_key(sql_trans *tr, sql_key *k)
{
	(void) tr;		/* unused! */

	/* remove key from schema */
	list_remove_data(k->t->s->keys, k);
	if (k->type == fkey) {
		sql_fkey *fk = (sql_fkey *) k;
		node *n = list_find_name(fk->rkey->keys, fk->k.base.name);

		list_remove_node(fk->rkey->keys, n);
	}
	return LOG_OK;
}

static int
rollforward_drop_trigger(sql_trans *tr, sql_trigger * i)
{
	(void)tr;
	list_remove_data(i->t->s->triggers, i);
	return LOG_OK;
}

static int
rollforward_drop_seq(sql_trans *tr, sql_sequence * seq)
{
	(void)tr;
	(void)seq;
	/* TODO drop sequence */
	return LOG_OK;
}

static int
rollforward_drop_table(sql_trans *tr, sql_table *t)
{
	int ok = LOG_OK;

	if (bs_debug) 
		fprintf(stderr, "drop table %s\n", t->base.name);

	if (isTable(t) && !isTempTable(t)) {
		if (tr->parent == gtrans) {
			log_bid bid;

			ok = log_bat_transient(sql_logger, t->dname);

			bid = logger_find_bat(sql_logger, t->dname);
			if (bid) 
				logger_del_bat(sql_logger, bid);
		}
	}

	if (ok == LOG_OK)
		ok = rollforward_changeset_deletes(tr, &t->columns, (rfdfunc) &rollforward_drop_column);
	if (ok == LOG_OK)
		ok = rollforward_changeset_deletes(tr, &t->idxs, (rfdfunc) &rollforward_drop_idx);
	if (ok == LOG_OK)
		ok = rollforward_changeset_deletes(tr, &t->keys, (rfdfunc) &rollforward_drop_key);
	if (ok == LOG_OK)
		ok = rollforward_changeset_deletes(tr, &t->triggers, (rfdfunc) &rollforward_drop_trigger);
	return ok;
}

static int
rollforward_drop_schema(sql_trans *tr, sql_schema *s)
{
	int ok = LOG_OK;

	ok = rollforward_changeset_deletes(tr, &s->seqs, (rfdfunc) &rollforward_drop_seq);
	if (ok == LOG_OK)
		return rollforward_changeset_deletes(tr, &s->tables, (rfdfunc) &rollforward_drop_table);
	return ok;
}

static sql_schema *
rollforward_create_schema(sql_trans *tr, sql_schema *s)
{
	rollforward_changeset_creates(tr, &s->tables, (rfcfunc) &rollforward_create_table);
	return s;
}

static int
rollforward_update_table(sql_trans *tr, sql_table *ft, sql_table *tt)
{
	int ok = LOG_OK;
	sql_trans *ttr = tr->parent;
	node *n, *m;
	lng deleted = 0;
	BAT *db = NULL;

	/* cannot update views and temporaries tables */
	if (!isTable(ft) || isTempTable(ft))
		return ok;

	ok = rollforward_changeset_updates(tr, &ft->columns, &tt->columns, &tt->base, (rfufunc) NULL, (rfcfunc) &rollforward_create_column, (rfdfunc) &rollforward_drop_column, (dupfunc) &column_dup);
	if (ok == LOG_OK)
		ok = rollforward_changeset_updates(tr, &ft->idxs, &tt->idxs, &tt->base, (rfufunc) NULL, (rfcfunc) &rollforward_create_idx, (rfdfunc) &rollforward_drop_idx, (dupfunc) &idx_dup);
	if (ok == LOG_OK)
		ok = rollforward_changeset_updates(tr, &ft->keys, &tt->keys, &tt->base, (rfufunc) NULL, (rfcfunc) &rollforward_create_key, (rfdfunc) &rollforward_drop_key, (dupfunc) &key_dup);
	if (ok == LOG_OK)
		ok = rollforward_changeset_updates(tr, &ft->triggers, &tt->triggers, &tt->base, (rfufunc) NULL, (rfcfunc) &rollforward_create_trigger, (rfdfunc) &rollforward_drop_trigger, (dupfunc) &trigger_dup);

	assert(cs_size(&tt->columns) == cs_size(&ft->columns));

	n = ft->columns.set->h;
	m = tt->columns.set->h;

	if (ok != LOG_OK || !n || !m) 
		return LOG_ERR;

	deleted = 0;
	db = temp_descriptor(ft->dbid);

	if (ft->base.rtime)
		tt->base.rtime = tr->stime;
	tt->base.wtime = tr->stime;
	ft->base.rtime = ft->base.wtime = 0;

	if (ft->cleared) {
		BAT *odb = temp_descriptor(tt->dbid);

		bat_clear(odb);
		bat_destroy(odb);
		if (ttr == gtrans)
			ok = log_bat_clear(sql_logger, tt->dname);
	}

	if (bs_debug) 
		fprintf(stderr, "update table %s\n", tt->base.name);

	deleted = BATcount(db);
	tt->cnt = 0;
	if (BUNlast(db) > db->batInserted || ft->cleared) {
		BAT *odb = temp_descriptor(tt->dbid);

		append_inserted(odb, db);

		if (bs_debug) {
			fprintf(stderr, 
				"%s " SZFMT "\n", tt->dname, BATcount(odb));
		}

		if (ttr == gtrans)
			ok = log_bat(sql_logger, odb, tt->dname);
		bat_destroy(odb);
		BATcommit(db);
	}
	bat_destroy(db);

	do {
		sql_column *cc = n->data;
		sql_column *oc = m->data;
		BAT *ups, *ins, *cur;

		/* for cleared tables the bid is reset */
		if (cc->bat.bid == 0) {
			cc -> bat.bid = oc -> bat.bid;
			temp_dup(cc->bat.bid);
		}
		if (!cc->base.wtime) {
			n = n->next;
			m = m->next;
			continue;
		}

		cur = temp_descriptor(oc->bat.bid);
		if (ft->cleared && ttr == gtrans) {
			bat_clear(cur);
			ok = log_bat_clear(sql_logger, oc->bat.name);
			if (ok == LOG_OK) 
				ok = log_bat_clear(sql_logger, oc->bat.uname);
		}

		ins = temp_descriptor(cc->bat.ibid);
		/* any inserts */
		if (BUNlast(ins) > BUNfirst(ins)) {
			assert(nr_active>0);
			if (BUNlast(ins) > ins->batInserted) {
				if (nr_active > 1) { 
					BAT *ci = temp_descriptor(oc->bat.ibid);
					append_inserted(ci, ins);
					bat_destroy(ci);
				}
				if (ok == LOG_OK && ttr == gtrans)
					ok = log_bat(sql_logger, ins, oc->bat.name);
			}
			if (nr_active == 1) { /* flush all */
				BAT *pi = temp_descriptor(oc->bat.ibid);
				if (!BATcount(cur)) {
					/* swap cur and ins */
					BAT *swpbat = ins;
					bat swp = cc->bat.ibid;
					cc->bat.ibid = oc->bat.bid;
					oc->bat.bid = swp;
					temp_destroy(cc->bat.bid);
					cc->bat.bid = temp_create(swpbat);
					if (ttr == gtrans) 
						logger_add_bat(sql_logger, ins, oc->bat.name);
					ins = cur;
					cur = swpbat;
				} else {
					BATappend(cur,ins,TRUE);
					bat_clear(ins);
				}
				bat_clear(pi);
				BATseqbase(ins,BATcount(cur));
				BATseqbase(pi,BATcount(cur));
				bat_destroy(pi);
			}
			BATcommit(ins);
		}
		bat_destroy(ins);

		ups = temp_descriptor(cc->bat.ubid);
		/* any updates */
		if (BUNlast(ups) > BUNfirst(ups)) {
			if (BUNlast(ups) > ups->batInserted) {
				if (nr_active > 1) { 
					BAT *cu = temp_descriptor(oc->bat.ubid);
					copy_inserted(cu, ups);
					bat_destroy(cu);
				}
				if (ok == LOG_OK && ttr == gtrans)
					ok = log_bat(sql_logger, ups, oc->bat.uname);
			}
			if (nr_active == 1) { /* flush all */
				void_replace_bat(cur, ups, TRUE);
				/* cleanup the old deltas */
				if (BUNfirst(ups) != ups->batInserted) { 
					BAT *cu = temp_descriptor(oc->bat.ubid);
					bat_clear(cu);
					BATcommit(cu);
					bat_destroy(cu);
				}
				bat_clear(ups);
			}
			BATcommit(ups);
		}
		bat_destroy(ups);

		if (!tt->cnt)
			tt->cnt = BATcount(cur)-deleted;
		bat_destroy(cur);

		if (cc->base.rtime)
			oc->base.rtime = tr->stime;
		oc->base.wtime = tr->stime;
		cc->base.rtime = cc->base.wtime = 0;

		n = n->next;
		m = m->next;
	} while (ok == LOG_OK && n && m);
	if (tt->idxs.set) {
		for (n = ft->idxs.set->h, m = tt->idxs.set->h; ok == LOG_OK && n && m; n = n->next, m = m->next) {
			sql_idx *ci = n->data;
			sql_idx *oi = m->data;
			BAT *ups, *ins, *cur;

			/* some indices have no bats */
			if (!oi->bat.bid)
				continue;

			/* for cleared tables the bid is reset */
			if (ci->bat.bid == 0) {
				ci -> bat.bid = oi -> bat.bid;
				temp_dup(ci->bat.bid);
			}
			if (!ci->base.wtime) 
				continue;

			cur = temp_descriptor(oi->bat.bid);
			if (ft->cleared && ttr == gtrans) {
				bat_clear(cur);
				ok = log_bat_clear(sql_logger, oi->bat.name);
				if (ok == LOG_OK) 
					ok = log_bat_clear(sql_logger, oi->bat.uname);
			}

			ins = temp_descriptor(ci->bat.ibid);
			/* any inserts */
			if (BUNlast(ins) > BUNfirst(ins)) {
				assert(nr_active>0);
				if (BUNlast(ins) > ins->batInserted) {
					if (nr_active > 1) {
						BAT *ci = temp_descriptor(oi->bat.ibid);
						append_inserted(ci, ins);
						bat_destroy(ci);
					}
					if (ok == LOG_OK && ttr == gtrans)
						ok = log_bat(sql_logger, ins, oi->bat.name);
				}
				if (nr_active == 1) { /* flush all */
					BAT *pi = temp_descriptor(oi->bat.ibid);
					if (!BATcount(cur)) {
						/* swap cur and ins */
						BAT *swpbat = ins;
						bat swp = ci->bat.ibid;
						ci->bat.ibid = oi->bat.bid;
						oi->bat.bid = swp;
						temp_destroy(ci->bat.bid);
						ci->bat.bid = temp_create(swpbat);
						if (ttr == gtrans) 
							logger_add_bat(sql_logger, ins, oi->bat.name);
						ins = cur;
						cur = swpbat;
					} else {
						BATappend(cur,ins,TRUE);
						bat_clear(ins);
					}
					bat_clear(pi);
					BATseqbase(ins,BATcount(cur));
					BATseqbase(pi,BATcount(cur));
					bat_destroy(pi);
				}
				BATcommit(ins);
			} 
			bat_destroy(ins);

			ups = temp_descriptor(ci->bat.ubid);
			/* any updates */
			if (BUNlast(ups) > BUNfirst(ups)) {
				if (BUNlast(ups) > ups->batInserted) {
					if (nr_active > 1) { 
						BAT *cu = temp_descriptor(oi->bat.ubid);
						copy_inserted(cu, ups);
						bat_destroy(cu);
					}
					if (ok == LOG_OK && ttr == gtrans)
						ok = log_bat(sql_logger, ups, oi->bat.uname);
				}
				if (nr_active == 1) { /* flush all */
					void_replace_bat(cur, ups, TRUE);
					/* cleanup the old deltas */
					if (BUNfirst(ups) != ups->batInserted) {
						BAT *cu = temp_descriptor(oi->bat.ubid);
						bat_clear(cu);
						BATcommit(cu);
						bat_destroy(cu);
					}
					bat_clear(ups);
				}
				BATcommit(ups);
			}
			bat_destroy(ups);
			bat_destroy(cur);

			if (ci->base.rtime)
				oi->base.rtime = tr->stime;
			oi->base.wtime = tr->stime;
			ci->base.rtime = ci->base.wtime = 0;
		}
	}
	ft->cleared = 0;
	ft->base.rtime = ft->base.wtime = 0;
	return ok;
}

static int
rollforward_update_seq(sql_trans *tr, sql_sequence *ft, sql_sequence *tt)
{
	/* TODO what to update */
	(void)tr;
	if (ft->start != tt->start)
		tt->start = ft->start;
	tt->minvalue = ft->minvalue;
	tt->maxvalue = ft->maxvalue;
	tt->increment = ft->increment;
	tt->cacheinc = ft->cacheinc;
	tt->cycle = ft->cycle;
	return LOG_OK;
}

static sql_table *
conditional_table_dup(sql_trans *tr, int flag, sql_table *ot, sql_schema *s)
{
	/* persistent bats need to be dupped */
	if ((isGlobalTable(ot) && tr->parent == gtrans) ||
	    /* allways dup in recursive mode */
	    tr->parent != gtrans)
		return table_dup(tr, flag, ot, s);
	else if (!isGlobalTable(ot)){/* is local temp, may need to be cleared */
		if (ot->commit_action == CA_DELETE) {
			sql_trans_clear_table(tr, ot);
		} else if (ot->commit_action == CA_DROP) {
			sql_trans_drop_table(tr, ot->s, ot->base.name, 0);
		}
	}
	return NULL;
}

static int
rollforward_update_schema(sql_trans *tr, sql_schema *fs, sql_schema *ts)
{
	int ok = LOG_OK;

	if (ok == LOG_OK)
		ok = rollforward_changeset_updates(tr, &fs->types, &ts->types, &ts->base, (rfufunc) NULL, (rfcfunc) &rollforward_create_type, (rfdfunc) NULL, (dupfunc) &type_dup);

	if (ok == LOG_OK)
		ok = rollforward_changeset_updates(tr, &fs->tables, &ts->tables, &ts->base, (rfufunc) &rollforward_update_table, (rfcfunc) &rollforward_create_table, (rfdfunc) &rollforward_drop_table, (dupfunc) &conditional_table_dup);

	if (ok == LOG_OK) /* last as it may require complex (table) types */
		ok = rollforward_changeset_updates(tr, &fs->funcs, &ts->funcs, &ts->base, (rfufunc) NULL, (rfcfunc) &rollforward_create_func, (rfdfunc) NULL, (dupfunc) &func_dup);

	if (ok == LOG_OK) /* last as it may require complex (table) types */
		ok = rollforward_changeset_updates(tr, &fs->seqs, &ts->seqs, &ts->base, (rfufunc) &rollforward_update_seq, (rfcfunc) &rollforward_create_seq, (rfdfunc) &rollforward_drop_seq, (dupfunc) &seq_dup);

	return ok;
}

static int
rollforward_trans(sql_trans *tr)
{
	int ok = LOG_OK;

	if (tr->parent && tr->wtime > tr->parent->wtime) {
		tr->parent->wtime = tr->wtime;
		tr->parent->schema_updates = tr->schema_updates;
	}

	if (ok == LOG_OK)
		ok = rollforward_changeset_updates(tr, &tr->schemas, &tr->parent->schemas, (sql_base *) tr->parent, (rfufunc) &rollforward_update_schema, (rfcfunc) &rollforward_create_schema, (rfdfunc) &rollforward_drop_schema, (dupfunc) &schema_dup);
	if (tr->parent == gtrans) {
		gtrans->stime = tr->stime;
		
		if (tr->schema_updates) 
			schema_number++;
	}
	tr->wtime = tr->rtime = 0;
	return ok;
}

static int
validate_tables(sql_schema *s, sql_schema *os)
{
	node *n, *o, *p;

	if (cs_size(&s->tables))
		for (n = s->tables.set->h; n; n = n->next) {
			sql_table *t = n->data;
			sql_table *ot = find_sql_table(os, t->base.name);

			if (ot && isTable(ot) && isTable(t)) {
				if (t->base.wtime && (t->base.wtime < ot->base.rtime || (t->base.wtime < ot->base.wtime && t->base.rtime))) 
					return 0;
				if (t->base.rtime && t->base.rtime < ot->base.wtime) 
					return 0;
				for (o = t->columns.set->h, p = ot->columns.set->h; o && p; o = o->next, p = p->next) {
					sql_column *c = o->data;
					sql_column *oc = p->data;

					/* t wrote, ie. check read and write time */
					/* read or write after t's write */
					if (c->base.wtime && (c->base.wtime < oc->base.rtime
							      /* allow for late appends, ie 
							       * wtime but no rtime 
							       */
							      || (c->base.wtime < oc->base.wtime && c->base.rtime))) {
						return 0;
					}
					/* commited write before t's read */
					if (c->base.rtime && c->base.rtime < oc->base.wtime) {
						return 0;
					}
				}
			}
		}
	return 1;
}

/* merge any changes from the global transaction into the local transaction */
typedef int (*resetf) (sql_trans *tr, sql_base * fs, sql_base * pfs);

static int
reset_changeset(sql_trans *tr, changeset * fs, changeset * pfs, sql_base *b, resetf rf, dupfunc fd)
{
	int ok = LOG_OK;
	node *m = NULL, *n = NULL;

	(void)tr;
	/* first delete created */
	if (fs->nelm) {
		for (n = fs->nelm; n; ) {
			node *nxt = n->next;
			list_remove_node(fs->set, n);
			n = nxt;
		}
		fs->nelm = NULL;
	}
	/* scan through the parent set, 
		if child has it simply reset it (if needed)
		else add a new or add again the old
	*/
	if (fs->set)
		n = fs->set->h;
	if (pfs->set) {
		for (m = pfs->set->h; ok == LOG_OK && m && n; ) { 
			sql_base *fb = n->data;
			sql_base *pfb = m->data;

			/* lists ordered on id */
			/* changes to the existing bases */
			if (fb->id == pfb->id) {
				if (rf) 
					ok = rf(tr, fb, pfb);
				fb->rtime = fb->wtime = 0;
				n = n->next;
				m = m->next;
				if (bs_debug) 
					fprintf(stderr, "reset_cs %s\n",
						(fb->name)?fb->name:"help");
			} else if (fb->id < pfb->id) {  
				node *t = n->next;
				if (bs_debug) {
					sql_base *b = n->data;
					fprintf(stderr, "reset_cs free %s\n",
						(b->name)?b->name:"help");
				}
				list_remove_node(fs->set, n);
				n = t;
			} else { /* a new id */
				sql_base *r = fd(tr, TR_OLD, pfb,  b);
				/* cs_add_before add r to fs before node n */
				cs_add_before(fs, n, r);
				r->rtime = r->wtime = 0;
				m = m->next;
				if (bs_debug) {
					fprintf(stderr, "reset_cs new %s\n",
						(r->name)?r->name:"help");
				}
			}
		}
		/* add new bases */
		for (; ok == LOG_OK && m; m = m->next ) {
			sql_base *pfb = m->data;
			sql_base *r = fd(tr, TR_OLD, pfb,  b);
			cs_add(fs, r, TR_OLD);
			r->rtime = r->wtime = 0;
			if (bs_debug) {
				fprintf(stderr, "reset_cs new %s\n",
					(r->name)?r->name:"help");
			}
		}
		while ( ok == LOG_OK && n) { /* remove remaining old stuff */
			node *t = n->next;
			if (bs_debug) {
				sql_base *b = n->data;
				fprintf(stderr, "reset_cs free %s\n",
					(b->name)?b->name:"help");
			}
			list_remove_node(fs->set, n);
			n = t;
		}
	}
	if (fs->dset) {
		list_destroy(fs->dset);
		fs->dset = NULL;
	}
	return ok;
}

static int
reset_idx(sql_trans *tr, sql_idx *fi, sql_idx *pfi)
{
	/* did we make changes or is the global changed after we started */
	if (fi->base.wtime || tr->stime < pfi->base.wtime) {
		BAT *ins, *pi;
		BAT *upd, *pu;

		if (fi->bat.bid != pfi->bat.bid) {
			temp_destroy(fi->bat.bid);
			fi->bat.bid = pfi->bat.bid;
			temp_dup(pfi->bat.bid);
		}
 		ins = temp_descriptor(fi->bat.ibid);
 		pi = temp_descriptor(pfi->bat.ibid);
		bat_clear(ins);
		if (BATcount(pi)) 
			BATappend(ins, pi, TRUE);		
		BATseqbase(ins,pi->hseqbase);
		BATcommit(ins);
		bat_destroy(ins);
		bat_destroy(pi);

		upd = temp_descriptor(fi->bat.ubid);
 		pu = temp_descriptor(pfi->bat.ubid);
		bat_clear(upd);
		if (BATcount(pu)) 
			BATins(upd, pu, FALSE);		
		BATcommit(upd);
		bat_destroy(upd);
		bat_destroy(pu);
		fi->base.wtime = fi->base.rtime = 0;
	}
	return LOG_OK;
}

static int
reset_column(sql_trans *tr, sql_column *fc, sql_column *pfc)
{
	/* did we make changes or is the global changed after we started */
	if (fc->base.wtime || tr->stime < pfc->base.wtime) {
		BAT *ins, *pi;
		BAT *upd, *pu;

		if (fc->bat.bid != pfc->bat.bid) {
			temp_destroy(fc->bat.bid);
			fc->bat.bid = pfc->bat.bid;
			temp_dup(pfc->bat.bid);
		}
 		ins = temp_descriptor(fc->bat.ibid);
 		pi = temp_descriptor(pfc->bat.ibid);
		bat_clear(ins);
		if (BATcount(pi)) 
			BATappend(ins, pi, TRUE);		
		BATseqbase(ins,pi->hseqbase);
		BATcommit(ins);
		bat_destroy(ins);
		bat_destroy(pi);

		upd = temp_descriptor(fc->bat.ubid);
 		pu = temp_descriptor(pfc->bat.ubid);
		bat_clear(upd);
		if (BATcount(pu)) 
			BATins(upd, pu, FALSE);		
		BATcommit(upd);
		bat_destroy(upd);
		bat_destroy(pu);
		fc->base.wtime = fc->base.rtime = 0;
		if (bs_debug) {
			fprintf(stderr, "reset_column %s.%s (%d) %d %d %d", 
				fc->t->base.name, fc->base.name, fc->base.flag,
				fc->bat.ibid, fc->bat.bid, fc->bat.ubid
				);
			fprintf(stderr, " <- (%d) %d %d %d", 
				pfc->base.flag, 
				pfc->bat.ibid, pfc->bat.bid, pfc->bat.ubid
				);
			fprintf(stderr, " (%d<%d)\n", 
				tr->stime, pfc->base.wtime);
		}
	}
	return LOG_OK;
}

static int
reset_type(sql_trans *tr, sql_type *ft, sql_type *pft)
{
	(void)tr;
	(void)ft;
	(void)pft;
	return LOG_OK;
}

static int
reset_func(sql_trans *tr, sql_func *ft, sql_func *pft)
{
	(void)tr;
	(void)ft;
	(void)pft;
	return LOG_OK;
}

static int
reset_seq(sql_trans *tr, sql_sequence *ft, sql_sequence *pft)
{
	(void)tr;
	ft->start = pft->start;
	ft->minvalue = pft->minvalue;
	ft->maxvalue = pft->maxvalue;
	ft->increment = pft->increment;
	ft->cacheinc = pft->cacheinc;
	ft->cycle = pft->cycle;
	return LOG_OK;
}


static int
reset_table(sql_trans *tr, sql_table *ft, sql_table *pft)
{
	if (!isTable(ft) || isTempTable(ft))
		return LOG_OK;

	/* did we make changes or is the global changed after we started */
	if (ft->base.wtime || tr->stime < pft->base.wtime) {
		int ok = LOG_OK;

		temp_destroy(ft->dbid);
		ft->dbid = temp_copy(pft->dbid, isTempTable(ft));

		ft->base.wtime = ft->base.rtime = 0;
		ok = reset_changeset( tr, &ft->columns, &pft->columns, &ft->base, (resetf) &reset_column, (dupfunc) &column_dup);
		if (ok == LOG_OK)
			ok = reset_changeset( tr, &ft->idxs, &pft->idxs, &ft->base, (resetf) &reset_idx, (dupfunc) &idx_dup);
		if (ok == LOG_OK)
			ok = reset_changeset( tr, &ft->keys, &pft->keys, &ft->base, (resetf) NULL, (dupfunc) &key_dup);
		if (ok == LOG_OK)
			ok = reset_changeset( tr, &ft->triggers, &pft->triggers, &ft->base, (resetf) NULL, (dupfunc) &trigger_dup);

		if (bs_debug) {
			assert(ft->base.flag == 0);
			fprintf(stderr, "reset_table %s (%d) (%d<%d)\n", 
				ft->base.name, ft->base.flag,
				tr->stime, pft->base.wtime
			);
		}
		return ok;
	}
	return LOG_OK;
}

static int
reset_schema(sql_trans *tr, sql_schema *fs, sql_schema *pfs)
{
	/* did we make changes or is the global changed after we started */
	if (fs->base.wtime || tr->stime < pfs->base.wtime) {
		int ok = LOG_OK;
		fs->base.wtime = fs->base.rtime = 0;

		ok = reset_changeset(tr, &fs->types, &pfs->types, &fs->base, (resetf) &reset_type, (dupfunc) &type_dup);
		if (ok == LOG_OK)
			ok = reset_changeset(tr, &fs->funcs, &pfs->funcs, &fs->base, (resetf) &reset_func, (dupfunc) &func_dup);

		if (ok == LOG_OK)
			ok = reset_changeset(tr, &fs->seqs, &pfs->seqs, &fs->base, (resetf) &reset_seq, (dupfunc) &seq_dup);

		if (ok == LOG_OK)
			return reset_changeset(tr, &fs->tables, &pfs->tables, &fs->base, (resetf) &reset_table, (dupfunc) &table_dup);
	}
	return LOG_OK;
}

static int
reset_trans(sql_trans *tr, sql_trans *ptr)
{
	int res = reset_changeset(tr, &tr->schemas, &ptr->schemas, (sql_base *)tr->parent, (resetf) &reset_schema, (dupfunc) &schema_dup);
	tr->wtime = tr->rtime = 0;
	return res;
}

sql_trans *
sql_trans_create(backend_stack stk, sql_trans *parent, char *name)
{
	sql_trans *tr = NULL;

	transactions++;
	if (gtrans) {
		if (!parent && spares > 0 && !name) {
			tr = spare_trans[--spares];
#ifdef STORE_DEBUG
			fprintf(stderr, "reuse trans (%p) %d\n", tr, spares);
#endif
		} else {
			tr = trans_dup(stk, (parent) ? parent : gtrans, name);
#ifdef STORE_DEBUG
			fprintf(stderr, "new trans (%p)\n", tr);
#endif
		}
	}
	return tr;
}

int
sql_trans_validate(sql_trans *tr)
{
	node *n;

	/* depends on the iso level */

	if (tr->schema_number != store_schema_number())
		return 0;

	/* since we protect usage through private copies both the iso levels
	   read uncommited and read commited always succeed.
	if (tr->level == ISO_READ_UNCOMMITED || tr->level == ISO_READ_COMMITED)
		return 1;
	 */

	/* If only 'inserts' occurred on the read bats the repeatable reads
	   iso level can continue */

	/* the hard case */
	if (cs_size(&tr->schemas))
		for (n = tr->schemas.set->h; n; n = n->next) {
			sql_schema *s = n->data;
			sql_schema *os = find_sql_schema(tr->parent, s->base.name);

			if (strcmp(s->base.name,"tmp") == 0)
				continue;
			if (os || (s->base.wtime == 0 && s->base.rtime == 0)) {
				if (!validate_tables(s, os))
					return 0;
			}
		}
	return 1;
}

#ifdef CAT_DEBUG
void
catalog_corrupt( sql_trans *tr )
{
	node *k,*l;
	if (cs_size(&tr->schemas)) 
	for (k = tr->schemas.set->h; k; k = k->next) {
		sql_schema *s = k->data;

		if (cs_size(&s->tables))
		for (l = s->tables.set->h; l; l = l->next) {
			sql_table *t = l->data;

			if (!t->query && !isTempTable(t))
				table_check(tr, t);
		}
	}
}
#endif /*CAT_DEBUG*/

int
sql_trans_commit(sql_trans *tr)
{
	int ok = LOG_OK;

	/* write phase */
	if (bs_debug)
		fprintf(stderr, "forwarding changes %d,%d\n", gtrans->stime, tr->stime);
	if (tr->parent == gtrans) {
		tr->stime = timestamp ();
		if (!sql_logger)
			return LOG_ERR;
		ok = log_tstart(sql_logger);
	}
	if (ok == LOG_OK) {
		/*catalog_corrupt(tr); */
		ok = rollforward_trans(tr);
		/*catalog_corrupt(tr->parent);*/
	}
	if (tr->parent == gtrans) {
		ok = log_sequence(sql_logger, OBJ_SID, store_oid);
		if (ok == LOG_OK)
			ok = log_tend(sql_logger);
		tr->schema_number = store_schema_number();
	}
	if (bs_debug)
		fprintf(stderr, "done forwarding changes %d\n", gtrans->stime);
	return (ok==LOG_OK)?SQL_OK:SQL_ERR;
}

static void
sys_drop_kc(sql_trans *tr, sql_key *k, sql_kc *kc)
{
	sql_schema *syss = find_sql_schema(tr, isGlobalTable(k->t)?"sys":"tmp");
	sql_table *syskc = find_sql_table(syss, "keycolumns");
	oid rid = column_find_row(tr, find_sql_column(syskc, "id"), &k->base.id, NULL);

	(void) kc;		/* Stefan: unused!? */
	assert(rid != -1);
	table_delete(tr, syskc, rid);

	if (isGlobalTable(k->t)) 
		tr->schema_updates ++;
}

static void
sys_drop_key(sql_trans *tr, sql_key *k)
{
	node *n;
	sql_schema *syss = find_sql_schema(tr, isGlobalTable(k->t)?"sys":"tmp");
	sql_table *syskey = find_sql_table(syss, "keys");
	oid rid = column_find_row(tr, find_sql_column(syskey, "id"), &k->base.id, NULL);

	assert(rid != -1);
	table_delete(tr, syskey, rid);

	for (n = k->columns->h; n; n = n->next) {
		sql_kc *kc = n->data;

		sys_drop_kc(tr, k, kc);
	}
	/* remove key from schema */
	list_remove_data(k->t->s->keys, k);
	if (k->type == fkey) {
		sql_fkey *fk = (sql_fkey *) k;
		node *n = list_find_name(fk->rkey->keys, fk->k.base.name);

		list_remove_node(fk->rkey->keys, n);
	}
	if (isGlobalTable(k->t)) 
		tr->schema_updates ++;
}

static void
sys_drop_ic(sql_trans *tr, sql_idx * i, sql_kc *kc)
{
	sql_schema *syss = find_sql_schema(tr, isGlobalTable(i->t)?"sys":"tmp");
	sql_table *syskc = find_sql_table(syss, "keycolumns");
	sql_column *kc_id = find_sql_column(syskc, "id");
	oid rid = column_find_row(tr, kc_id, &i->base.id, NULL);

	(void) kc;		/* Stefan: unused!? */
	assert(rid != -1);
	table_delete(tr, syskc, rid);

	if (isGlobalTable(i->t)) 
		tr->schema_updates ++;
}

static void
sys_drop_idx(sql_trans *tr, sql_idx * i)
{
	node *n;
	sql_schema *syss = find_sql_schema(tr, isGlobalTable(i->t)?"sys":"tmp");
	sql_table *sysidx = find_sql_table(syss, "idxs");
	oid rid = column_find_row(tr, find_sql_column(sysidx, "id"), &i->base.id, NULL);

	assert(rid != -1);
	table_delete(tr, sysidx, rid);

	for (n = i->columns->h; n; n = n->next) {
		sql_kc *ic = n->data;

		sys_drop_ic(tr, i, ic);
	}

	/* remove idx from schema */
	list_remove_data(i->t->s->idxs, i);
	if (isGlobalTable(i->t)) 
		tr->schema_updates ++;
}

static void
sys_drop_tc(sql_trans *tr, sql_trigger * i, sql_kc *kc)
{
	sql_schema *syss = find_sql_schema(tr, isGlobalTable(i->t)?"sys":"tmp");
	sql_table *syskc = find_sql_table(syss, "keycolumns");
	oid rid = column_find_row(tr, find_sql_column(syskc, "id"), &i->base.id, NULL);

	(void) kc;		/* Stefan: unused!? */
	assert(rid != -1);
	table_delete(tr, syskc, rid);
	if (isGlobalTable(i->t)) 
		tr->schema_updates ++;
}

static void
sys_drop_trigger(sql_trans *tr, sql_trigger * i)
{
	node *n;
	sql_schema *syss = find_sql_schema(tr, isGlobalTable(i->t)?"sys":"tmp");
	sql_table *systrigger = find_sql_table(syss, "triggers");
	oid rid = column_find_row(tr, find_sql_column(systrigger, "id"), &i->base.id, NULL);

	assert(rid != -1);
	table_delete(tr, systrigger, rid);

	for (n = i->columns->h; n; n = n->next) {
		sql_kc *tc = n->data;

		sys_drop_tc(tr, i, tc);
	}
	/* remove trigger from schema */
	list_remove_data(i->t->s->triggers, i);
	if (isGlobalTable(i->t)) 
		tr->schema_updates ++;
}

static void
sys_drop_sequence(sql_trans *tr, sql_sequence * seq)
{
	sql_schema *syss = find_sql_schema(tr, "sys");
	sql_table *sysseqs = find_sql_table(syss, "sequences");
	oid rid = column_find_row(tr, find_sql_column(sysseqs, "id"), &seq->base.id, NULL);

	assert(rid != -1);
	table_delete(tr, sysseqs, rid);
}

static void
sys_drop_column(sql_trans *tr, sql_column *col)
{
	sql_schema *syss = find_sql_schema(tr, isGlobalTable(col->t)?"sys":"tmp"); 
	sql_table *syscolumn = find_sql_table(syss, "_columns");
	oid rid = column_find_row(tr, find_sql_column(syscolumn, "id"),
				  &col->base.id, NULL);

	assert(rid != -1);
	table_delete(tr, syscolumn, rid);
	if (isGlobalTable(col->t)) 
		tr->schema_updates ++;
}

static void
sys_drop_keys(sql_trans *tr, sql_table *t)
{
	node *n;

	if (cs_size(&t->keys))
		for (n = t->keys.set->h; n; n = n->next) {
			sql_key *k = n->data;

			sys_drop_key(tr, k);
		}
}

static void
sys_drop_idxs(sql_trans *tr, sql_table *t)
{
	node *n;

	if (cs_size(&t->idxs))
		for (n = t->idxs.set->h; n; n = n->next) {
			sql_idx *k = n->data;

			sys_drop_idx(tr, k);
		}
}

static void
sys_drop_columns(sql_trans *tr, sql_table *t)
{
	node *n;

	if (cs_size(&t->columns))
		for (n = t->columns.set->h; n; n = n->next) {
			sql_column *c = n->data;

			sys_drop_column(tr, c);
		}
}

static void
sys_drop_table(sql_trans *tr, sql_table *t)
{
	sql_schema *syss = find_sql_schema(tr, isGlobalTable(t)?"sys":"tmp");
	sql_table *systable = find_sql_table(syss, "_tables");
	sql_column *syscol = find_sql_column(systable, "id");
	oid rid = column_find_row(tr, syscol, &t->base.id, NULL);

	assert(rid != -1);
	table_delete(tr, systable, rid);
	sys_drop_keys(tr, t);
	sys_drop_idxs(tr, t);

	if (isTable(t))
		sys_drop_columns(tr, t);

	if (isGlobalTable(t)) 
		tr->schema_updates ++;
}

static void
sys_drop_type(sql_trans *tr, sql_type *type)
{
	sql_schema *syss = find_sql_schema(tr, "sys");
	sql_table *sys_tab_type = find_sql_table(syss, "types");
	sql_column *sys_type_col = find_sql_column(sys_tab_type, "id");
	oid rid = column_find_row(tr, sys_type_col, &type->base.id, NULL);

	assert(rid != -1);
	table_delete(tr, sys_tab_type, rid);

	tr->schema_updates ++;
}


static void
sys_drop_func(sql_trans *tr, sql_func *func)
{
	sql_schema *syss = find_sql_schema(tr, "sys");
	sql_table *sys_tab_func = find_sql_table(syss, "functions");
	sql_table *sys_tab_args = find_sql_table(syss, "args");
	sql_column *sys_func_col = find_sql_column(sys_tab_func, "id");
	sql_column *sys_args_col = find_sql_column(sys_tab_args, "func_id");
	oid rid_func = column_find_row(tr, sys_func_col, &func->base.id, NULL);
	oid rid_args = column_find_row(tr, sys_args_col, &func->base.id, NULL);

	assert(rid_func != -1);
	assert(rid_args != -1);
	table_delete(tr, sys_tab_func, rid_func);
	table_delete(tr, sys_tab_args, rid_args);

	tr->schema_updates ++;
}

static void
sys_drop_types(sql_trans *tr, sql_schema *s)
{
	node *n;

	if (cs_size(&s->types))
		for (n = s->types.set->h; n; n = n->next) {
			sql_type *t = n->data;

			sys_drop_type(tr, t);
		}
}

static void
sys_drop_tables(sql_trans *tr, sql_schema *s)
{
	node *n;

	if (cs_size(&s->tables))
		for (n = s->tables.set->h; n; n = n->next) {
			sql_table *t = n->data;

			sys_drop_table(tr, t);
		}
}

static void
sys_drop_funcs(sql_trans *tr, sql_schema *s)
{
	node *n;

	if (cs_size(&s->funcs))
		for (n = s->funcs.set->h; n; n = n->next) {
			sql_func *f = n->data;

			sys_drop_func(tr, f);
		}
}

static void
sys_drop_sequences(sql_trans *tr, sql_schema *s)
{
	node *n;

	if (cs_size(&s->seqs))
		for (n = s->seqs.set->h; n; n = n->next) {
			sql_sequence *seq = n->data;

			sys_drop_sequence(tr, seq);
		}
}


sql_type *
sql_trans_create_type(sql_trans *tr, sql_schema * s, char *sqlname, int digits, int scale, int radix, char *impl)
{
	sql_type *t;
	sql_table *systype;
	int localtype = ATOMindex(impl);

	if (localtype < 0) 
		return NULL;
	t = NEW(sql_type);
	systype = find_sql_table(find_sql_schema(tr, "sys"), "types");
	base_init(&t->base, next_oid(), TR_NEW, impl);
	t->sqlname = _strdup(sqlname);
	t->digits = digits;
	t->scale = scale;
	t->radix = radix;
	t->eclass = EC_ANY;
	t->localtype = localtype;
	t->s = s;

	cs_add(&s->types, t, TR_NEW);
	table_insert(tr, systype, &t->base.id, t->base.name, t->sqlname, &t->digits, &t->scale, &t->radix, &t->eclass, &s->base.id);

	t->base.wtime = s->base.wtime = tr->wtime = tr->stime;
	tr->schema_updates ++;
	return t;
}

sql_func *
sql_trans_create_func(sql_trans *tr, sql_schema * s, char *func, list *args, sql_subtype *res, bit sql, bit aggr, char *mod, char *impl)
{
	sql_func *t = NEW(sql_func);
	sql_table *sysfunc = find_sql_table(find_sql_schema(tr, "sys"), "functions");
	sql_table *sysarg = find_sql_table(find_sql_schema(tr, "sys"), "args");
	node *n;
	int number = 0;

	base_init(&t->base, next_oid(), TR_NEW, func);
	assert(impl && mod);
	t->imp = _strdup(impl);
	t->mod = _strdup(mod); 
	t->sql = sql;
	t->aggr = aggr;
	t->ops = list_dup(args, (fdup)&arg_dup);
	t->res.type = NULL;
	if (res)
		t->res = *res;
	t->s = s;

	cs_add(&s->funcs, t, TR_NEW);
	table_insert(tr, sysfunc, &t->base.id, t->base.name, t->imp, t->mod, &t->sql, &t->aggr, &s->base.id);
	if (t->res.type) {
		char *name = "result";
		oid id = next_oid();

		table_insert(tr, sysarg, &id, &t->base.id, name, t->res.type->sqlname, &t->res.digits, &t->res.scale, &number);
		number++;
	}
	if (t->ops) for (n = t->ops->h; n; n = n->next, number++) {
		sql_arg *a = n->data;
		oid id = next_oid();

		table_insert(tr, sysarg, &id, &t->base.id, a->name, a->type.type->sqlname, &a->type.type->digits, &a->type.type->scale, &number);
	}
/*
	if (!aggr && list_length(args) > 0) {
		node *n = t->ops->h;
		sql_arg *a = n->data;
		t->res = a->type;
		list_remove_node(t->ops, n);
	}
*/

	t->base.wtime = s->base.wtime = tr->wtime = tr->stime;
	tr->schema_updates ++;
	return t;
}


void
sql_trans_drop_func(sql_trans *tr, sql_schema *s, char *name, int cascade)
{
	node *n = find_sql_func_node(s, name);
	sql_func *func = n->data;

	(void) cascade;		/* Stefan: unused!? */

	sys_drop_func(tr, func);

	func->base.wtime = s->base.wtime = tr->wtime = tr->stime;
	tr->schema_updates ++;
	cs_del(&s->funcs, n, func->base.flag);

	/* TODO cascade, ie. remove al references to this table */
}

sql_schema *
sql_trans_create_schema(sql_trans *tr, char *name, int auth_id)
{
	sql_schema *s = NEW(sql_schema);
	sql_table *sysschema = find_sql_table(find_sql_schema(tr, "sys"), "schemas");

	base_init(&s->base, next_oid(), TR_NEW, name);
	s->auth_id = auth_id;
	cs_init(&s->tables, (fdestroy) &table_destroy);
	cs_init(&s->types, (fdestroy) &type_destroy);
	cs_init(&s->funcs, (fdestroy) &func_destroy);
	cs_init(&s->seqs, (fdestroy) &seq_destroy);
	s->keys = list_create((fdestroy) NULL);
	s->idxs = list_create((fdestroy) NULL);
	s->triggers = list_create((fdestroy) NULL);

	cs_add(&tr->schemas, s, TR_NEW);
	table_insert(tr, sysschema, &s->base.id, s->base.name, &s->auth_id);
	s->base.wtime = tr->wtime = tr->stime;
	tr->schema_updates ++;
	return s;
}

void
sql_trans_drop_schema(sql_trans *tr, char *sname)
{
	node *n = find_sql_schema_node(tr, sname);
	sql_schema *s = n->data;
	sql_table *sysschema = find_sql_table(find_sql_schema(tr, "sys"), "schemas");
	oid rid = column_find_row(tr, find_sql_column(sysschema, "id"), &s->base.id, NULL);

	assert(rid != -1);
	table_delete(tr, sysschema, rid);
	sys_drop_funcs(tr, s);
	sys_drop_tables(tr, s);
	sys_drop_types(tr, s);
	sys_drop_sequences(tr, s);

	s->base.wtime = tr->wtime = tr->stime;
	tr->schema_updates ++;
	cs_del(&tr->schemas, n, s->base.flag);
}

sql_table *
sql_trans_create_table(sql_trans *tr, sql_schema *s, char *name, bit system, int persistence, int commit_action, int sz)
{
	BAT *b;
	sql_table *t = create_sql_table(name, tt_table, system, persistence, commit_action);
	sql_schema *syss = find_sql_schema(tr, isGlobalTable(t)?"sys":"tmp");
	sql_table *systable = find_sql_table(syss, "_tables");
	sht ca;

	/* temps all belong to a special tmp schema */
	assert( !isTempTable(t) || (strcmp(s->base.name, "tmp") == 0));

	t->s = s;
	t->sz = sz;
	if (sz < 0)
		t->sz = BATSIZE;

	b = bat_new(TYPE_void, TYPE_oid, t->sz, "sql_trans_create_table");
	t->dbid = temp_create(b);
	bat_destroy(b);

	cs_add(&s->tables, t, TR_NEW);
	t->base.wtime = s->base.wtime = tr->wtime = tr->stime;
	ca = t->commit_action;
	table_insert(tr, systable, &t->base.id, t->base.name, &s->base.id, ATOMnilptr(TYPE_str), &t->type, &t->system, &ca);
	if (isGlobalTable(t)) 
		tr->schema_updates ++;
	return t;
}

sql_table *
sql_trans_create_view(sql_trans *tr, sql_schema *s, char *name, char *sql, bit system)
{
	sql_table *t = create_sql_table(name, tt_view, system, SQL_PERSIST, 0);
	sql_schema *syss = find_sql_schema(tr, "sys");
	sql_table *systable = find_sql_table(syss, "_tables");
	sht ca;

	t->query = sql ? _strdup(sql) : NULL;
	assert(sql);
	t->s = s;
	cs_add(&s->tables, t, TR_NEW);

	ca = t->commit_action;
	table_insert(tr, systable, &t->base.id, t->base.name, &s->base.id,
			(t->query) ? t->query : ATOMnilptr(TYPE_str), &t->type,
			&t->system, &ca);

	t->base.wtime = s->base.wtime = tr->wtime = tr->stime;
	tr->schema_updates ++;
	return t;
}

sql_table *
sql_trans_create_generated(sql_trans *tr, sql_schema *s, char *name, char *sql, bit system)
{
	sql_table *t = create_sql_table(name, tt_generated, system, SQL_PERSIST, 0);
	sql_schema *syss = find_sql_schema(tr, "sys");
	sql_table *systable = find_sql_table(syss, "_tables");
	sht ca;

	t->query = sql ? _strdup(sql) : NULL;
	t->s = s;
	cs_add(&s->tables, t, TR_NEW);

	ca = t->commit_action;
	table_insert(tr, systable, &t->base.id, t->base.name, &s->base.id,
			ATOMnilptr(TYPE_str), &t->type,
			&t->system, &ca);

	t->base.wtime = s->base.wtime = tr->wtime = tr->stime;
	tr->schema_updates ++;
	return t;
}

sql_column *
create_sql_column(sql_table *t, char *name, sql_subtype *tpe)
{
	sql_column *col = NEW(sql_column);
	base_init(&col->base, next_oid(), TR_NEW, name);

	col->type = *tpe;
	col->def = NULL;
	col->null = 1;
	col->colnr = cs_size(&t->columns);
	col->t = t;
	col->bat.ibid = col->bat.bid = col->bat.ubid = 0;
	col->bat.name = col->bat.uname = NULL;
	col->unique = 0;

	cs_add(&t->columns, col, TR_NEW);
	return col;
}

static
sql_column *
create_column_bat(sql_trans *tr, sql_table *t, char *name, sql_subtype *tpe, BAT *bb)
{
	sql_column *col = create_sql_column(t, name, tpe );
	sql_schema *syss = find_sql_schema(tr, isGlobalTable(t)?"sys":"tmp");
	sql_table *syscolumn = find_sql_table(syss, "_columns");

	col->base.wtime = t->base.wtime = t->s->base.wtime = tr->wtime = tr->stime;
	if (bb)
		col->bat.ibid = temp_create(bb);

	table_insert(tr, syscolumn, &col->base.id, col->base.name, col->type.type->sqlname, &col->type.digits, &col->type.scale, &t->base.id, (col->def) ? col->def : ATOMnilptr(TYPE_str), &col->null, &col->colnr);

	if (isGlobalTable(t)) 
		tr->schema_updates ++;
	return col;
}

void
sql_trans_drop_table(sql_trans *tr, sql_schema *s, char *name, int cascade)
{
	node *n = find_sql_table_node(s, name);
	sql_table *t = n->data;

	(void) cascade;		/* Stefan: unused!? */

	sys_drop_table(tr, t);

	t->base.wtime = s->base.wtime = tr->wtime = tr->stime;
	if (isGlobalTable(t)) 
		tr->schema_updates ++;
	cs_del(&s->tables, n, t->base.flag);

	/* TODO cascade, ie. remove al references to this table */
}

size_t
sql_trans_clear_table(sql_trans *tr, sql_table *t)
{
	node *n = t->columns.set->h;
	sql_column *c = n->data;
	size_t sz = 0;

	t->cleared = 1;
	t->base.wtime = t->s->base.wtime = tr->wtime = tr->stime;
	if (t->base.flag == TR_NEW || isTempTable(t)) {
		BAT *b = temp_descriptor(c->bat.ibid);

		sz = BATcount(b);
		bat_clear(b);
		bat_destroy(b);
		for (n = n->next; n; n = n->next) {
			c = n->data;
			b = temp_descriptor(c->bat.ibid);

			bat_clear(b);
			bat_destroy(b);
		}
		/* temp's do not have indices, but NEW may have idxs */
		if (t->idxs.set) {
			for (n = t->idxs.set->h; n; n = n->next) {
				sql_idx *ci = n->data;

				ci->base.wtime = tr->stime;
				if (ci->bat.ibid) {
					b = temp_descriptor(ci->bat.ibid);
					bat_clear(b);
					BATcommit(b);
					bat_destroy(b);
				}
			}
		}
	} else {
		BAT *b;

		c->base.wtime = tr->stime;
		b = temp_descriptor(c->bat.ibid);
		sz += BATcount(b);
		bat_clear(b);
		BATcommit(b);
		bat_destroy(b);

		if (c->bat.bid) {
			b = bind_bat(tr, c, RDONLY);
			sz += BATcount(b);
			bat_destroy(b);
				
			temp_destroy(c->bat.bid);
			c->bat.bid = 0;
		}
		if (c->bat.ubid) { 
			b = temp_descriptor(c->bat.ubid);
			bat_clear(b);
			BATcommit(b);
			bat_destroy(b);
		}
		if (t->dbid) {
			b = temp_descriptor(t->dbid);
			sz -= BATcount(b);
			bat_clear(b);
			BATcommit(b);
			bat_destroy(b);
		}

		for (n = n->next; n; n = n->next) {
			c = n->data;
			c->base.wtime = tr->stime;
			b = temp_descriptor(c->bat.ibid);
			bat_clear(b);
			BATcommit(b);
			bat_destroy(b);
			if (c->bat.bid) {
				temp_destroy(c->bat.bid);
				c->bat.bid = 0;
			}
			if (c->bat.ubid) {
				b = temp_descriptor(c->bat.ubid);
				bat_clear(b);
				BATcommit(b);
				bat_destroy(b);
			}
		}
		if (t->idxs.set) {
			for (n = t->idxs.set->h; n; n = n->next) {
				sql_idx *ci = n->data;

				ci->base.wtime = tr->stime;
				if (ci->bat.ibid) {
					b = temp_descriptor(ci->bat.ibid);
					bat_clear(b);
					BATcommit(b);
					bat_destroy(b);
				}
				if (ci->bat.bid) {
					temp_destroy(ci->bat.bid);
					ci->bat.bid = 0;
				}
				if (ci->bat.ubid) {
					b = temp_descriptor(ci->bat.ubid);
					bat_clear(b);
					BATcommit(b);
					bat_destroy(b);
				}
			}
		}
	}
	t->cnt = 0;
	return sz;
}

sql_column *
sql_trans_create_column(sql_trans *tr, sql_table *t, char *name, sql_subtype *tpe)
{
	sql_column *res = NULL;
	int type;

	if (!tpe)
		return NULL;

	type = tpe->type->localtype;

	if (isTable(t)) {
		BAT *b;

		b = bat_new(TYPE_void, type, t->sz, "sql_trans_create_column");

		if (!b) {
			if (b)
				BBPreclaim(b);
			return NULL;
		}

		res = create_column_bat(tr, t, name, tpe, b);
		bat_destroy(b);
	} else {
		res = create_column_bat(tr, t, name, tpe, NULL);
	}
	return res;
}

void
sql_trans_drop_column(sql_trans *tr, sql_table *t, char *name)
{
	node *n = find_sql_column_node(t, name);
	sql_column *col = n->data;

	if (isTable(t))
		sys_drop_column(tr, col);

	col->base.wtime = t->base.wtime = t->s->base.wtime = tr->wtime = tr->stime;
	cs_del(&t->columns, n, col->base.flag);
	if (isGlobalTable(t)) 
		tr->schema_updates ++;
}

sql_column *
sql_trans_alter_null(sql_trans *tr, sql_column *col, int isnull)
{
	if (col->null != isnull) {
		sql_schema *syss = find_sql_schema(tr, isGlobalTable(col->t)?"sys":"tmp"); 
		sql_table *syscolumn = find_sql_table(syss, "_columns");
		oid rid = column_find_row(tr, find_sql_column(syscolumn, "id"),
					  &col->base.id, NULL);

		assert(rid != -1);
		column_update_value(tr, find_sql_column(syscolumn, "null"), rid, &isnull);
		col->null = isnull;
		col->base.wtime = col->t->base.wtime = col->t->s->base.wtime = tr->wtime = tr->stime;
		if (isGlobalTable(col->t)) 
			tr->schema_updates ++;
	}

	return col;
}

sql_column *
sql_trans_alter_default(sql_trans *tr, sql_column *col, char *val)
{
	if (!col->def && !val)
		return col;	/* no change */

	if (!col->def || !val || strcmp(col->def, val) != 0) {
		void *p = val ? val : ATOMnilptr(TYPE_str);
		sql_schema *syss = find_sql_schema(tr, isGlobalTable(col->t)?"sys":"tmp"); 
		sql_table *syscolumn = find_sql_table(syss, "_columns");
		oid rid = column_find_row(tr, find_sql_column(syscolumn, "id"),
					  &col->base.id, NULL);

		assert(rid != -1);
		column_update_value(tr, find_sql_column(syscolumn, "default"), rid, p);
		if (col->def)
			_DELETE(col->def);
		col->def = NULL;
		if (val)
			col->def = _strdup(val);
		col->base.wtime = col->t->base.wtime = col->t->s->base.wtime = tr->wtime = tr->stime;
		if (isGlobalTable(col->t)) 
			tr->schema_updates ++;
	}
	return col;
}

sql_key *
sql_trans_create_key(sql_trans *tr, sql_table *t, char *name, key_type kt, sql_key *rkey)
{
/* can only have keys between persistent tables */
	int neg = -1;
	sql_key *nk;
	sql_schema *syss = find_sql_schema(tr, isGlobalTable(t)?"sys":"tmp");
	sql_table *syskey = find_sql_table(syss, "keys");

	if (isTempTable(t))
		return NULL;

	nk = (kt != fkey) ? (sql_key *) NEW(sql_ukey)
	: (sql_key *) NEW(sql_fkey);

	assert(name);
	base_init(&nk->base, next_oid(), TR_NEW, name);
	nk->type = kt;
	nk->columns = list_create((fdestroy) &kc_destroy);
	nk->t = t;
	nk->idx = sql_trans_create_idx(tr, t, name, (nk->type == fkey) ? join_idx : unique);
	nk->idx->key = nk;

	if (nk->type != fkey) {
		sql_ukey *uk = (sql_ukey *) nk;

		uk->keys = NULL;

		if (nk->type == pkey)
			t->pkey = uk;
	} else if (nk->type == fkey) {
		sql_fkey *fk = (sql_fkey *) nk;
		sql_ukey *uk = (sql_ukey *) rkey;

		fk->rkey = uk;
		if (!uk->keys)
			uk->keys = list_create(NULL);
		list_append(uk->keys, fk);
	}

	cs_add(&t->keys, nk, TR_NEW);
	list_append(t->s->keys, nk);

	table_insert(tr, syskey, &nk->base.id, &t->base.id, &nk->type, nk->base.name, (nk->type == fkey) ? &((sql_fkey *) nk)->rkey->k.base.id : &neg);

	syskey->base.wtime = syskey->s->base.wtime = t->base.wtime = t->s->base.wtime = tr->wtime = tr->stime;
	if (isGlobalTable(t)) 
		tr->schema_updates ++;
	return nk;
}


sql_key *
sql_trans_create_kc(sql_trans *tr, sql_key *k, sql_column *c /*, extra options such as trunc */ )
{
	sql_kc *kc = NEW(sql_kc);
	int nr = list_length(k->columns);
	sql_schema *syss = find_sql_schema(tr, isGlobalTable(k->t)?"sys":"tmp");
	sql_table *syskc = find_sql_table(syss, "keycolumns");

	assert(c);
	kc->c = c;
	kc->trunc = 0;
	list_append(k->columns, kc);
	if (k->idx)
		sql_trans_create_ic(tr, k->idx, c);

	if (k->type == pkey)
		sql_trans_alter_null(tr, c, 0);

	table_insert(tr, syskc, &k->base.id, kc->c->base.name, &kc->trunc, &nr);

	syskc->base.wtime = tr->wtime = tr->stime;
	if (isGlobalTable(k->t)) 
		tr->schema_updates ++;
	return k;
}

void
sql_trans_drop_key(sql_trans *tr, sql_schema *s, char *name)
{
	node *n = list_find_name(s->keys, name);
	sql_key *k = n->data;

	if (!isTempTable(k->t))
		sys_drop_key(tr, k);

	k->base.wtime = k->t->base.wtime = s->base.wtime = tr->wtime = tr->stime;
	if (isGlobalTable(k->t)) 
		tr->schema_updates ++;
	n = cs_find_name(&k->t->keys, name);
	if (n)
		cs_del(&k->t->keys, n, k->base.flag);
}

sql_idx *
sql_trans_create_idx(sql_trans *tr, sql_table *t, char *name, idx_type it)
{
	/* can only have idxs between persistent tables */
	sql_idx *ni = NEW(sql_idx);
	sql_schema *syss = find_sql_schema(tr, isGlobalTable(t)?"sys":"tmp");
	sql_table *sysidx = find_sql_table(syss, "idxs");

	assert(name);
	base_init(&ni->base, next_oid(), TR_NEW, name);
	ni->type = it;
	ni->columns = list_create((fdestroy) &kc_destroy);
	ni->t = t;
	ni->key = NULL;

	ni->bat.ibid = ni->bat.bid = ni->bat.ubid = 0;
	ni->bat.name = ni->bat.uname = NULL; 

	cs_add(&t->idxs, ni, TR_NEW);
	list_append(t->s->idxs, ni);

	/* create void,int bat to keep the hash values */
	if (it == join_idx) {
		BAT *b;

		b = bat_new(TYPE_void, TYPE_oid, t->sz, "sql_trans_create_idx");
		ni->bat.ibid = temp_create(b);
		bat_destroy(b);
	}

	table_insert(tr, sysidx, &ni->base.id, &t->base.id, &ni->type, ni->base.name);
	t->base.wtime = t->s->base.wtime = tr->wtime = tr->stime;
	if (isGlobalTable(t)) 
		tr->schema_updates ++;
	return ni;
}

sql_idx *
sql_trans_create_ic(sql_trans *tr, sql_idx * i, sql_column *c /*, extra options such as trunc */ )
{
	sql_kc *ic = NEW(sql_kc);
	int nr = list_length(i->columns);
	sql_schema *syss = find_sql_schema(tr, isGlobalTable(i->t)?"sys":"tmp");
	sql_table *sysic = find_sql_table(syss, "keycolumns");

	assert(c);
	ic->c = c;
	ic->trunc = 0;
	list_append(i->columns, ic);

	if (!i->bat.ibid && i->type == unique && list_length(i->columns) > 1) {
		BAT *b;

		b = bat_new(TYPE_void, TYPE_int, i->t->sz, "sql_trans_create_ic");
		i->bat.ibid = temp_create(b);
		bat_destroy(b);

		/* Correct the unique flag of the keys first column */
		c->unique = list_length(i->columns); 
		if (c->unique == 2) {
			sql_kc *ic1 = i->columns->h->data;
			ic1->c->unique ++;
		}
	}

	table_insert(tr, sysic, &i->base.id, ic->c->base.name, &ic->trunc, &nr);

	sysic->base.wtime = sysic->s->base.wtime = tr->wtime = tr->stime;
	if (isGlobalTable(i->t)) 
		tr->schema_updates ++;
	return i;
}

void
sql_trans_drop_idx(sql_trans *tr, sql_schema *s, char *name)
{
	node *n = list_find_name(s->idxs, name);
	sql_idx *i = n->data;

	if (!isTempTable(i->t))
		sys_drop_idx(tr, i);

	i->base.wtime = i->t->base.wtime = s->base.wtime = tr->wtime = tr->stime;
	if (isGlobalTable(i->t)) 
		tr->schema_updates ++;
	n = cs_find_name(&i->t->idxs, name);
	if (n)
		cs_del(&i->t->idxs, n, i->base.flag);
}

sql_trigger *
sql_trans_create_trigger(sql_trans *tr, sql_table *t, char *name, 
	sht time, sht orientation, sht event, char *old_name, char *new_name,
	char *condition, char *statement )
{
	sql_trigger *ni = NEW(sql_trigger);
	sql_schema *syss = find_sql_schema(tr, isGlobalTable(t)?"sys":"tmp");
	sql_table *systrigger = find_sql_table(syss, "triggers");
	str nilptr = ATOMnilptr(TYPE_str);

	assert(name);
	base_init(&ni->base, next_oid(), TR_NEW, name);
	ni->columns = list_create((fdestroy) &kc_destroy);
	ni->t = t;
	ni->time = time;
	ni->orientation = orientation;
	ni->event = event;
	ni->old_name = ni->new_name = ni->condition = NULL; 
	if (old_name)
		ni->old_name = _strdup(old_name);
	if (new_name)
		ni->new_name = _strdup(new_name);
	if (condition)
		ni->condition = _strdup(condition);
	ni->statement = _strdup(statement);

	cs_add(&t->triggers, ni, TR_NEW);
	list_append(t->s->triggers, ni);

	table_insert(tr, systrigger, &ni->base.id, ni->base.name, &t->base.id, &ni->time, &ni->orientation, &ni->event, (ni->old_name)?ni->old_name:nilptr, (ni->new_name)?ni->new_name:nilptr, (ni->condition)?ni->condition:nilptr, ni->statement);

	t->base.wtime = t->s->base.wtime = tr->wtime = tr->stime;
	if (isGlobalTable(t)) 
		tr->schema_updates ++;
	return ni;
}

sql_trigger *
sql_trans_create_tc(sql_trans *tr, sql_trigger * i, sql_column *c /*, extra options such as trunc */ )
{
	sql_kc *ic = NEW(sql_kc);
	int nr = list_length(i->columns);
	sql_schema *syss = find_sql_schema(tr, isGlobalTable(i->t)?"sys":"tmp");
	sql_table *sysic = find_sql_table(syss, "keycolumns");

	assert(c);
	ic->c = c;
	ic->trunc = 0;
	list_append(i->columns, ic);
	table_insert(tr, sysic, &i->base.id, ic->c->base.name, &ic->trunc, &nr);
	sysic->base.wtime = sysic->s->base.wtime = tr->wtime = tr->stime;
	if (isGlobalTable(i->t)) 
		tr->schema_updates ++;
	return i;
}

void
sql_trans_drop_trigger(sql_trans *tr, sql_schema *s, char *name)
{
	node *n = list_find_name(s->triggers, name);
	sql_trigger *i = n->data;

	sys_drop_trigger(tr, i);
	i->base.wtime = i->t->base.wtime = s->base.wtime = tr->wtime = tr->stime;
	if (isGlobalTable(i->t)) 
		tr->schema_updates ++;
	n = cs_find_name(&i->t->triggers, name);
	if (n)
		cs_del(&i->t->triggers, n, i->base.flag);
}

sql_sequence * 
sql_trans_create_sequence(sql_trans *tr, sql_schema *s, char *name, lng start, lng min, lng max, lng inc, lng cacheinc, bit cycle )
{
	sql_sequence *seq = NEW(sql_sequence);
	sql_schema *syss = find_sql_schema(tr, "sys");
	sql_table *sysseqs = find_sql_table(syss, "sequences");

	assert(name);
	base_init(&seq->base, next_oid(), TR_NEW, name);

	seq->start = start;
	seq->minvalue = min;
	seq->maxvalue = max;
	seq->increment = inc;
	seq->cacheinc = cacheinc;
	seq->cycle = cycle;
	seq->s = s;

	cs_add(&s->seqs, seq, TR_NEW);

	table_insert(tr, sysseqs, &seq->base.id, &s->base.id, seq->base.name, &seq->start, &seq->minvalue, &seq->maxvalue, &seq->increment, &seq->cacheinc, &seq->cycle);

	s->base.wtime = tr->wtime = tr->stime;
	return seq;
}

void
sql_trans_drop_sequence(sql_trans *tr, sql_schema *s, char *name)
{
	node *n = cs_find_name(&s->seqs, name);
	sql_sequence *seq = n->data;

	sys_drop_sequence(tr, seq);
	seq->base.wtime = s->base.wtime = tr->wtime = tr->stime;
	cs_del(&s->seqs, n, seq->base.flag);
}

sql_sequence *
sql_trans_alter_sequence(sql_trans *tr, sql_sequence *seq, lng min, lng max, lng inc, lng cache, lng cycle)
{
	sql_schema *syss = find_sql_schema(tr, "sys"); 
	sql_table *seqs = find_sql_table(syss, "sequences");
	oid rid = column_find_row(tr, find_sql_column(seqs, "id"),
				  &seq->base.id, NULL);
	sql_column *c;
	int changed = 0;

	assert(rid != -1);
	if (min >= 0 && seq->minvalue != min) {
		seq->minvalue = min; 
		c = find_sql_column(seqs, "minvalue");
		column_update_value(tr, c, rid, &seq->minvalue);
	}
	if (max >= 0 && seq->maxvalue != max) {
		seq->maxvalue = max; 
		changed = 1;
		c = find_sql_column(seqs, "maxvalue");
		column_update_value(tr, c, rid, &seq->maxvalue);
	}
	if (inc >= 0 && seq->increment != inc) {
		seq->increment = inc; 
		changed = 1;
		c = find_sql_column(seqs, "increment");
		column_update_value(tr, c, rid, &seq->increment);
	}
	if (cache >= 0 && seq->cacheinc != cache) {
		seq->cacheinc = cache; 
		changed = 1;
		c = find_sql_column(seqs, "cacheinc");
		column_update_value(tr, c, rid, &seq->cacheinc);
	}
	if (seq->cycle != cycle) {
		seq->cycle = cycle; 
		changed = 1;
		c = find_sql_column(seqs, "cycle");
		column_update_value(tr, c, rid, &seq->cycle);
	}

	if (changed) {
		seq->base.wtime = seq->s->base.wtime = tr->wtime = tr->stime;
		tr->schema_updates ++;
	}
	return seq;
}

lng 
sql_trans_sequence_restart(sql_trans *tr, sql_sequence *seq, lng start)
{
	if (seq->start != start) {
		sql_schema *syss = find_sql_schema(tr, "sys"); 
		sql_table *seqs = find_sql_table(syss, "sequences");
		oid rid = column_find_row(tr, find_sql_column(seqs, "id"),
				  &seq->base.id, NULL);
		sql_column *c = find_sql_column(seqs, "start");

		assert(rid != -1);
		seq->start = start; 
		column_update_value(tr, c, rid, &seq->start);

		seq->base.wtime = seq->s->base.wtime = tr->wtime = tr->stime;
		tr->schema_updates ++;
	}
	seq_restart(seq, seq->start);
	return seq->start;
}

sql_session *
sql_session_create(backend_stack stk, int ac )
{
	sql_session *s = NEW(sql_session);

	if (!s)
		return NULL;
	s->tr = sql_trans_create(s->stk, NULL, NULL);
	s->schema_name = NULL;
	s->active = 0;
	s->stk = stk;
	sql_session_reset(s, ac);
	nr_sessions++;
	return s;
}

void
sql_session_destroy(sql_session *s) 
{
	if (s->tr)
		sql_trans_destroy(s->tr);
	if (s->schema_name)
		_DELETE(s->schema_name);
	_DELETE(s);
	nr_sessions--;
}

void
sql_session_reset(sql_session *s, int ac) 
{
	sql_schema *tmp;

	if (!s->tr)
		return;

	tmp = find_sql_schema(s->tr, "tmp");
		
	if (tmp->tables.set) {
		node *n;
		for (n = tmp->tables.set->h; n; n = n->next) {
			sql_table *t = n->data;

			if (isGlobalTable(t))
				sql_trans_clear_table(s->tr, t);
			else if (!isGlobalTable(t)) /* remove local tmp*/
				sql_trans_drop_table(s->tr, tmp,t->base.name,0);
		}
	}
	assert(s->active == 0);

	if (s->schema_name)
		_DELETE(s->schema_name);
	s->schema_name = _strdup("sys");
	s->schema = NULL;
	s->auto_commit = s->ac_on_commit = ac;
	s->level = ISO_SERIALIZABLE;
}


void
sql_trans_all_dependencies(sql_trans *tr)
{
	backend_schema_user_dependencies(tr);
}

int
sql_trans_begin(sql_session *s)
{
	sql_trans *tr = s->tr;
	int snr = tr->schema_number;

	if (tr->stime < gtrans->stime || tr->wtime || 
			store_schema_number() != snr)
		reset_trans(tr, gtrans);
	tr = trans_init(tr, tr->stk, tr->parent);
	s->active = 1;
	s->schema = find_sql_schema(tr, s->schema_name);
	s->tr = tr;
	nr_active ++;
	s->status = 0;
	return snr != tr->schema_number;
}

void
sql_trans_end(sql_session *s)
{
	s->active = 0;
	s->auto_commit = s->ac_on_commit;
	nr_active --;
}
