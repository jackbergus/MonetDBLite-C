@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
@' Copyright August 2008- MonetDB B.V.
@' All Rights Reserved.

@f bat_storage

@h
#ifndef BATSTORAGE_H
#define BATSTORAGE_H

#include "sql_storage.h"
#include "bat_logger.h"

typedef struct sql_delta {	
	char *name;		/* name of the main bat */
	char *uname;		/* name of updates bat */
	int bid;
	oid ibase;		/* ibase: first id of inserts */
	int ibid;		/* bat with inserts */
	int ubid;		/* bat with updates */
	size_t cnt;		/* number of tuples (excluding the deletes) */
} sql_delta;

typedef struct sql_dbat {
	char *dname;		/* name of the persistent deletes bat */
	int dbid;		/* bat with deletes */
	size_t cnt;
} sql_dbat;

/* initialize bat storage call back functions interface */
extern int bat_storage_init( store_functions *sf );

extern void create_delta( sql_delta *d, BAT *b, BAT *i, bat u);
extern BAT * delta_bind_ubat(sql_delta *bat, int access);
extern BAT * delta_bind_bat( sql_delta *bat, int access, int temp);
extern BAT * delta_bind_del(sql_dbat *bat, int access);

extern void delta_update_bat( sql_delta *bat, BAT *upd);
extern void delta_update_val( sql_delta *bat, ssize_t rid, void *upd);
extern void delta_append_bat( sql_delta *bat, BAT *i );
extern void delta_append_val( sql_delta *bat, void *i );
extern void delta_delete_bat( sql_dbat *bat, BAT *i );
extern void delta_delete_val( sql_dbat *bat, ssize_t rid );

extern int load_delta(sql_delta *bat, int bid, int ubid, int type);
extern int load_dbat(sql_dbat *bat, int bid);
extern int new_persistent_delta( sql_delta *bat, int sz );
extern int new_persistent_dbat( sql_dbat *bat);

extern int log_create_delta(sql_delta *bat);
extern int log_create_dbat( sql_dbat *bat );

extern int dup_delta(sql_trans *tr, sql_delta *obat, sql_delta *bat, int type, int oc_isnew, int c_isnew, int temp, int sz);
extern int dup_dbat(sql_trans *tr, sql_dbat *obat, sql_dbat *bat, int isnew, int temp);
extern int destroy_delta(sql_delta *b);
extern int destroy_dbat(sql_dbat *bat);
extern int log_destroy_delta(sql_delta *b);
extern int log_destroy_dbat(sql_dbat *bat);
extern BUN clear_delta(sql_trans *tr, sql_delta *bat);
extern BUN clear_dbat(sql_trans *tr, sql_dbat *bat);
extern int tr_update_delta( sql_trans *tr, sql_delta *obat, sql_delta *cbat, int cluster, BUN snapshot_minsize);
extern int tr_update_dbat(sql_trans *tr, sql_dbat *tdb, sql_dbat *fdb, int cleared);
extern int tr_log_delta( sql_trans *tr, sql_delta *cbat, int cleared);
extern int tr_log_dbat(sql_trans *tr, sql_dbat *fdb, int cleared);

#endif /*BATSTORAGE_H */

@c
#include "sql_config.h"
#include "bat_storage.h"
#include "bat_utils.h"
#include <sql_string.h>

#define SNAPSHOT_MINSIZE ((BUN) 1024)

BAT *
delta_bind_ubat(sql_delta *bat, int access)
{
	BAT *b;

#ifdef NDEBUG
	(void) access; /* satisfy compiler */
#endif
	assert(access == RD_UPD);
	b = temp_descriptor(bat->ubid);
	assert(b);
	b->batDirty |= 2;
	return b;
}

static BAT *
bind_ucol(sql_trans *tr, sql_column *c, int access)
{
	c->t->s->base.rtime = c->t->base.rtime = c->base.rtime = tr->stime;
	return delta_bind_ubat(c->data, access);
}

static BAT *
bind_uidx(sql_trans *tr, sql_idx * i, int access)
{
	i->base.rtime = i->t->base.rtime = i->t->s->base.rtime = tr->rtime = tr->stime;
	return delta_bind_ubat(i->data, access);
}

BAT *
delta_bind_bat( sql_delta *bat, int access, int temp)
{
	BAT *b;

	assert(access == RDONLY || access == RD_INS);
	if (temp || access == RD_INS || !bat->bid) {
		assert(bat->ibid);
		b = temp_descriptor(bat->ibid);
	} else {
		b = temp_descriptor(bat->bid);
		bat_set_access(b, BAT_READ);
	}
	assert(b);
	b->batDirty |= 2;
	assert(b);
	return b;
}

static BAT *
bind_col(sql_trans *tr, sql_column *c, int access)
{
	if (access == RD_UPD)
		return bind_ucol(tr, c, access);
	c->base.rtime = c->t->base.rtime = c->t->s->base.rtime = tr->rtime = tr->stime;
	return delta_bind_bat( c->data, access, isTemp(c));
}

static BAT *
bind_idx(sql_trans *tr, sql_idx * i, int access)
{
	if (access == RD_UPD)
		return bind_uidx(tr, i, access);
	i->base.rtime = i->t->base.rtime = i->t->s->base.rtime = tr->rtime = tr->stime;
	return delta_bind_bat( i->data, access, isTemp(i));
}

BAT *
delta_bind_del(sql_dbat *bat, int access) 
{
	BAT *b;

#ifdef NDEBUG
	(void) access; /* satisfy compiler */
#endif
	assert(access == RDONLY || access == RD_INS);
	assert(access!=RD_UPD);

	b = temp_descriptor(bat->dbid);
	assert(b);
	b->batDirty |= 2;
	return b;
}


static BAT *
bind_del(sql_trans *tr, sql_table *t, int access)
{
	t->s->base.rtime = t->base.rtime = tr->stime;
	return delta_bind_del(t->data, access);
}

void
delta_update_bat( sql_delta *bat, BAT *upd) 
{
	BAT *b;

	if (bat->ubid) {
		b = temp_descriptor(bat->ubid);
		assert(b);
/*
		if (BATcount(b) == 0 && !isVIEW(upd) && upd->htype != TYPE_void && upd->ttype != TYPE_void){
			temp_destroy(bat->ubid);
			bat->ubid = temp_create(upd);
			upd->batDirty |= 2;
		} else {
*/
		if (isEUbat(b)){
			temp_destroy(bat->ubid);
			bat->ubid = temp_copy(b->batCacheid, FALSE);
			bat_destroy(b);
			b = temp_descriptor(bat->ubid);
		}
		/* TODO: multiple updates of the same row ? */ 
		BATins(b, upd, TRUE);
	} else {
		b = temp_descriptor(bat->ibid);
		void_replace_bat(b, upd, TRUE);
	}
	b->batDirty |= 2;
	bat_destroy(b);
}

void
delta_update_val( sql_delta *bat, ssize_t rid, void *upd) 
{
	BAT *b;

	assert(rid != (ssize_t)oid_nil);
	assert(rid != -1);

	if (bat->ubid) {
		b = temp_descriptor(bat->ubid);
		assert(b);

		if (isEUbat(b)){
			temp_destroy(bat->ubid);
			bat->ubid = temp_copy(b->batCacheid, FALSE);
			bat_destroy(b);
			b = temp_descriptor(bat->ubid);
		}
		BUNins(b, (ptr) &rid, upd, TRUE);
	} else {
		b = temp_descriptor(bat->ibid);
		void_inplace(b, (oid) rid, upd, TRUE);
	}
	bat_destroy(b);
}

static void
update_col(sql_trans *tr, sql_column *c, void *i, int tpe, ssize_t rid)
{
	sql_delta *bat = c->data;

	c->base.wtime = c->t->base.wtime = c->t->s->base.wtime = tr->wtime = tr->stime;
	c->base.rtime = c->t->base.rtime = c->t->s->base.rtime = tr->rtime = tr->stime;
	if (tpe == TYPE_bat)
		delta_update_bat(bat, i);
	else 
		delta_update_val(bat, rid, i);
}

static void 
update_idx(sql_trans *tr, sql_idx * i, void *ib, int tpe)
{
	sql_delta *bat = i->data;

	i->base.wtime = i->t->base.wtime = i->t->s->base.wtime = tr->wtime = tr->stime;
	i->base.rtime = i->t->base.rtime = i->t->s->base.rtime = tr->rtime = tr->stime;
	if (tpe == TYPE_bat)
		delta_update_bat(bat, ib);
	else
		assert(0);
}

void
delta_append_bat( sql_delta *bat, BAT *i ) 
{
	BAT *b = temp_descriptor(bat->ibid);

	bat->cnt += BATcount(i);
	if ( BATcount(b) == 0 && !isVIEW(i) && i->htype == TYPE_void && i->ttype != TYPE_void && bat->ibase == i->H->seq){
		temp_destroy(bat->ibid);
		bat->ibid = temp_create(i);
		BATseqbase(i, bat->ibase);
		i->batDirty |= 2;
	} else if (!isEbat(b)){
		/* try to use mmap() */
		if (BATcount(b)+BATcount(i) > (BUN) REMAP_PAGE_MAXSIZE) { 
       			BATmmap(b, STORE_MMAP, STORE_MMAP, STORE_MMAP, STORE_MMAP);
    		}
		BATappend(b, i, TRUE);
	} else {
		temp_destroy(bat->ibid);
		bat->ibid = ebat2real(i->batCacheid, bat->ibase);
	}
	bat_destroy(b);
}

void
delta_append_val( sql_delta *bat, void *i ) 
{
	BAT *b = temp_descriptor(bat->ibid);

	if (isEbat(b)) {
		bat_destroy(b);
		temp_destroy(bat->ibid);
		bat->ibid = ebat2real(bat->ibid, bat->ibase);
		b = temp_descriptor(bat->ibid);
	}
	BUNappend(b, i, TRUE);
	bat->cnt ++;
	bat_destroy(b);
}

static void 
append_col(sql_trans *tr, sql_column *c, void *i, int tpe)
{
	sql_delta *bat = c->data;

	c->base.wtime = c->t->base.wtime = c->t->s->base.wtime = tr->wtime = tr->stime;
	c->base.rtime = c->t->base.rtime = c->t->s->base.rtime = tr->rtime = tr->stime;
	if (tpe == TYPE_bat)
		delta_append_bat(bat, i);
	else
		delta_append_val(bat, i);
}

static void
append_idx(sql_trans *tr, sql_idx * i, void *ib, int tpe)
{
	sql_delta *bat = i->data;

	i->base.wtime = i->t->base.wtime = i->t->s->base.wtime = tr->wtime = tr->stime;
	i->base.rtime = i->t->base.rtime = i->t->s->base.rtime = tr->rtime = tr->stime;
	if (tpe == TYPE_bat)
		delta_append_bat(bat, ib);
	else
		delta_append_val(bat, ib);
}

void
delta_delete_bat( sql_dbat *bat, BAT *i ) 
{
	BAT *b = temp_descriptor(bat->dbid);

	bat->cnt += BATcount(i);
	if (BATcount(b) == 0 && !isVIEW(i) && i->htype == TYPE_void && i->ttype != TYPE_void){
		temp_destroy(bat->dbid);
		bat->dbid = temp_create(i);
		i->batDirty |= 2;
	} else {
		if (isEbat(b)) {
			temp_destroy(bat->dbid);
			bat->dbid = temp_copy(b->batCacheid, FALSE);
			bat_destroy(b);
			b = temp_descriptor(bat->dbid);
			b->batDirty |= 2;
		}
		BATappend(b, i, TRUE);
	}
	bat_destroy(b);
}

void
delta_delete_val( sql_dbat *bat, ssize_t rid ) 
{
	BAT *b = temp_descriptor(bat->dbid);

	bat->cnt ++;
	if (isEbat(b)) {
		temp_destroy(bat->dbid);
		bat->dbid = temp_copy(b->batCacheid, FALSE);
		bat_destroy(b);
		b = temp_descriptor(bat->dbid);
		b->batDirty |= 2;
	}
	BUNappend(b, (ptr)&rid, TRUE);
	bat_destroy(b);
}

static void
delete_tab(sql_trans *tr, sql_table * t, void *ib, int tpe)
{
	sql_dbat *bat = t->data;

	t->base.wtime = t->s->base.wtime = tr->wtime = tr->stime;
	t->base.rtime = t->s->base.rtime = tr->rtime = tr->stime;
	if (tpe == TYPE_bat)
		delta_delete_bat(bat, ib);
	else
		delta_delete_val(bat, *(ssize_t*)ib);
}

static size_t
count_col(sql_column *col)
{
	sql_delta *b = col->data;
	return b->cnt;
}

static size_t
count_idx(sql_idx *idx)
{
	sql_delta *b = idx->data;
	return b->cnt;
}

int
load_delta(sql_delta *bat, int bid, int ubid, int type)
{
	int destroy = 0;
	BAT *b, *u;

	b = quick_descriptor(bid);
	bat->bid = temp_create(b);
	bat->ibase = BATcount(b);
	bat->cnt = bat->ibase; 
	
	u = quick_descriptor(ubid);
	if (!u) {
		u = bat_new(TYPE_oid, type, 0);
		bat_set_access(u, BAT_READ);
		destroy = 1;
	}
	bat->ubid = temp_create(u);
	if (destroy)
		bat_destroy(u);

	bat->ibid = e_bat(type);
	if (bat->bid && bat->ubid) {
		BAT *ub = temp_descriptor(bat->ubid);

		if (BATcount(ub)) {
			BAT *b  = temp_descriptor(bat->bid);
			void_replace_bat(b, ub, TRUE);

			temp_destroy(bat->ubid);
			bat->ubid = e_ubat(ub->ttype); 
			bat_destroy(b);
		}
		bat_destroy(ub);
	}
	return LOG_OK;
}

static int 
load_bat(sql_delta *bat, int type) 
{
	int bid = logger_find_bat(bat_logger, bat->name);
	int ubid = logger_find_bat(bat_logger, bat->uname);

	return load_delta(bat, bid, ubid, type);
}

int
log_create_delta(sql_delta *bat) 
{
	int ok = LOG_OK;
	BAT *b = temp_descriptor(bat->ibid);
	BAT *u = temp_descriptor(bat->ubid);

	if (!u) {
		u = bat_new(TYPE_oid, b->ttype, 0);
		bat_set_access(u, BAT_READ);
		bat->ubid = temp_create(u);
	}

	logger_add_bat(bat_logger, u, bat->uname);
	if (ok == LOG_OK)
		ok = log_bat_persists(bat_logger, u, bat->uname);
	bat_destroy(u);

	logger_add_bat(bat_logger, b, bat->name);
	if (ok == LOG_OK)
		ok = log_bat_persists(bat_logger, b, bat->name);
	bat_destroy(b);
	return ok;
}

static int
snapshot_new_persistent_bat(sql_trans *tr, sql_delta *bat) 
{
	int ok = LOG_OK;
	BAT *b = temp_descriptor(bat->ibid);

	(void)tr;
	/* snapshot large bats */
	bat_set_access(b, BAT_READ);
	if (BATcount(b) > SNAPSHOT_MINSIZE) 
		BATmode(b, PERSISTENT);
	if (BATcount(b) > (BUN) REMAP_PAGE_MAXSIZE)
       		BATmmap(b, STORE_MMAP, STORE_MMAP, STORE_MMAP, STORE_MMAP);
	bat_destroy(b);
	return ok;
}

int
new_persistent_delta( sql_delta *bat, int sz )
{
	BAT *i, *b = temp_descriptor(bat->ibid);
	int ok = LOG_OK, type = b->ttype;

	assert(bat->bid == 0);
	bat->bid = bat->ibid;
	bat->ibase = BATcount(b);
	bat_destroy(b);

	i = bat_new(TYPE_void, type, sz);
	bat_set_access(i, BAT_READ);
	BATseqbase(i, bat->ibase);
	bat->ibid = temp_create(i);
	bat_destroy(i);
	return ok;
}

static int
new_persistent_bat(sql_trans *tr, sql_delta *bat, int sz) 
{
	(void)tr;
	return new_persistent_delta(bat, sz);
}

void
create_delta( sql_delta *d, BAT *b, BAT *i, bat u)
{
	d->cnt = BATcount(i);
	bat_set_access(i, BAT_READ);
	d->bid = 0;
	d->ibase = i->H->seq;
	d->ibid = temp_create(i);
	if (b) {
		d->cnt += BATcount(b);
		bat_set_access(b, BAT_READ);
		d->bid = temp_create(b);
	}
	d->ubid = u;
}

static int
create_col(sql_trans *tr, sql_column *c)
{
	int ok = LOG_OK;
	int type = c->type.type->localtype;
	sql_delta *bat = c->data;

	if (!bat)
		c->data = bat = ZNEW(sql_delta);
	if (!bat->uname) 
		bat->uname = sql_message("U_%s_%s_%s", c->t->s->base.name, c->t->base.name, c->base.name);
	if (!bat->name) 
		bat->name = bat->uname+2;

	(void)tr;
	if (c->base.flag == TR_OLD && !isTempTable(c->t)){
		return load_bat(bat, type);
	} else if (bat && bat->ibid && !isTempTable(c->t)) {
		return new_persistent_bat( tr, c->data, c->t->sz);
	} else {
		if (!bat)
 			bat = c->data = ZNEW(sql_delta);
		if (!bat->ibid) {
			BAT *b = bat_new(TYPE_void, type, c->t->sz);
			if (!b) 
				return LOG_ERR;
			create_delta( c->data, NULL, b, 0);
			bat_destroy(b);
		}
	}
	return ok;
}

static int
log_create_col(sql_trans *tr, sql_column *c)
{
	(void)tr;
	assert(tr->parent == gtrans && !isTempTable(c->t));
	return log_create_delta( c->data);
}


static int
snapshot_create_col(sql_trans *tr, sql_column *c)
{
	(void)tr;
	assert(tr->parent == gtrans && !isTempTable(c->t));
	return snapshot_new_persistent_bat( tr, c->data);
}

/* will be called for new idx's and when new index columns are create */
static int
create_idx(sql_trans *tr, sql_idx *ni)
{
	int ok = LOG_OK;
	sql_delta *bat = ni->data;
	int type = TYPE_wrd;

	if (ni->type == join_idx)
		type = TYPE_oid;

	/* no index bats for single column hash indices */
/* TODO single column indices ! 
		if (ni->key) {
			sql_kc *c = ni->columns->h->data;
			BAT *b = bind_col(tr->parent, c->c, RDONLY);

			BATkey(BATmirror(b), BOUND2BTRUE);
			bat_destroy(b);
		}
		return LOG_OK;
	}
*/

	if (!bat)
		ni->data = bat = ZNEW(sql_delta);
	if (!bat->uname) 
		bat->uname = sql_message("U_%s_%s_%s", ni->t->s->base.name, ni->t->base.name, ni->base.name);
	if (!bat->name) 
		bat->name = bat->uname+2;

	/* create bats for a loaded idx structure */
	if (ni->base.flag == TR_OLD && !isTempTable(ni->t)){
		return load_bat(bat, type);
	} else if (bat->ibid) { /* create bats for a new persistent idx */
		return new_persistent_bat( tr, ni->data, ni->t->sz);
	} else if (!bat->ibid) {
		BAT *b = bat_new(TYPE_void, type, ni->t->sz);
		if (!b) 
			return LOG_ERR;
		bat_set_access(b, BAT_READ);
		bat->ibid = temp_create(b);
		bat_destroy(b);
	}
	return ok;
}

static int
log_create_idx(sql_trans *tr, sql_idx *ni)
{
	(void)tr;
	assert(tr->parent == gtrans && !isTempTable(ni->t));
	return log_create_delta( ni->data);
}

static int
snapshot_create_idx(sql_trans *tr, sql_idx *ni)
{
	assert(tr->parent == gtrans && !isTempTable(ni->t));
	return snapshot_new_persistent_bat( tr, ni->data);
}

int
new_persistent_dbat( sql_dbat *bat)
{
	BAT *b = temp_descriptor(bat->dbid);

	bat->dbid = temp_create(b);
	bat_destroy(b);
	return LOG_OK;
}

int
load_dbat(sql_dbat *bat, int bid)
{
	BAT *b = quick_descriptor(bid);

	bat->dbid = temp_create(b);
	bat->cnt = BATcount(b); 
	return LOG_OK;
}


static int
create_del(sql_trans *tr, sql_table *t)
{
	int ok = LOG_OK;
	BAT *b;
	sql_dbat *bat = t->data;

	if (!bat)
		bat = t->data = ZNEW(sql_dbat);
	if (!bat->dname)
		bat->dname = sql_message("D_%s_%s", t->s->base.name, t->base.name);
	(void)tr;
	if (t->base.flag == TR_OLD && !isTempTable(t)) {
		return load_dbat(bat, logger_find_bat(bat_logger, bat->dname));
	} else if (bat->dbid && !isTempTable(t)) {
		return new_persistent_dbat(bat);
	} else if (!bat->dbid) {
		b = bat_new(TYPE_void, TYPE_oid, t->sz);
		bat_set_access(b, BAT_READ);
		bat->dbid = temp_create(b);
		bat_destroy(b);
	}
	return ok;
}

int
log_create_dbat( sql_dbat *bat )
{
	BAT *b = temp_descriptor(bat->dbid);
	int ok = LOG_OK;

	(void) logger_add_bat(bat_logger, b, bat->dname);
	ok = log_bat_persists(bat_logger, b, bat->dname);
	bat_destroy(b);
	return ok;
}

static int
log_create_del(sql_trans *tr, sql_table *t)
{
	(void)tr;
	assert(tr->parent == gtrans && !isTempTable(t));
	return log_create_dbat(t->data);
}

static int
snapshot_create_del(sql_trans *tr, sql_table *t)
{
	sql_dbat *bat = t->data;
	BAT *b = temp_descriptor(bat->dbid);

	(void)tr;
	/* snapshot large bats */
	bat_set_access(b, BAT_READ);
	if (BATcount(b) > SNAPSHOT_MINSIZE) 
		BATmode(b, PERSISTENT);
	if (BATcount(b) > (BUN) REMAP_PAGE_MAXSIZE)
       		BATmmap(b, STORE_MMAP, STORE_MMAP, STORE_MMAP, STORE_MMAP);
	bat_destroy(b);
	return LOG_OK;
}

int
dup_delta(sql_trans *tr, sql_delta *obat, sql_delta *bat, int type, int oc_isnew, int c_isnew, int temp, int sz)
{
	if (!obat)
		return LOG_OK;
	bat->ibid = obat->ibid;
	bat->bid = obat->bid;
	bat->ubid = obat->ubid;
	bat->ibase = obat->ibase;
	bat->cnt = obat->cnt;

	bat->uname = _strdup(obat->uname);
	bat->name = bat->uname+2;

	assert(bat->ibid);
	if (bat->ibid) {
		BAT *b;
		if (temp) {
			bat->ibid = temp_copy(bat->ibid, 1);
		} else if (oc_isnew) { 
			/* move the bat to the new col, fixup the old col*/
			b = bat_new(TYPE_void, type, sz);
			bat_set_access(b, BAT_READ);
			obat->ibid = temp_create(b);
			if (c_isnew && tr->parent == gtrans) { 
				/* new cols are moved to gtrans and bat.bid */
				temp_dup(bat->ibid);
				obat->bid = bat->ibid;
			}
			if (obat->bid) {
				BAT *cb = temp_descriptor(obat->bid);
				bat->ibase = obat->ibase = BATcount(cb);
				BATseqbase(b, obat->ibase);
				bat_destroy(cb);
			}
			bat_destroy(b);
		} else { /* old column */
			bat->ibid = ebat_copy(bat->ibid, bat->ibase, 0); 
		}
	}
	if (!temp && bat->ibid) { 
		if (bat->ubid) {
			bat->ubid = eubat_copy(bat->ubid, 0); 
		} else {
			BAT *b = bat_new(TYPE_oid, type, sz);
			bat_set_access(b, BAT_READ);
			bat->ubid = temp_create(b);
			bat_destroy(b);
			
			/* old needs an update bat too */
			b = bat_new(TYPE_oid, type, sz);
			bat_set_access(b, BAT_READ);
			obat->ubid = temp_create(b);
			bat_destroy(b);
		}
	}
	if (bat->bid)
		temp_dup(bat->bid);
	return LOG_OK;
}

static int 
dup_bat(sql_trans *tr, sql_table *t, sql_delta *obat, sql_delta *bat, int type, int oc_isnew, int c_isnew)
{
	return dup_delta( tr, obat, bat, type, oc_isnew, c_isnew, isTempTable(t), t->sz);
}

static int 
dup_col(sql_trans *tr, sql_column *oc, sql_column *c )
{
	if (oc->data) {
		int type = c->type.type->localtype;
		sql_delta *bat = c->data = ZNEW(sql_delta), *obat = oc->data;
		return dup_bat(tr, c->t, obat, bat, type, isNew(oc), c->base.flag == TR_NEW);
	}
	return LOG_OK;
}

static int 
dup_idx(sql_trans *tr, sql_idx *i, sql_idx *ni )
{
	if (i->data) {
		int type = (ni->type==join_idx)?TYPE_oid:TYPE_wrd;
		sql_delta *bat = ni->data = ZNEW(sql_delta), *obat = i->data;
		return dup_bat(tr, ni->t, obat, bat, type, isNew(i), ni->base.flag == TR_NEW);
	}
	return LOG_OK;
}

int
dup_dbat( sql_trans *tr, sql_dbat *obat, sql_dbat *bat, int is_new, int temp)
{
	bat->dbid = obat->dbid;
	bat->dname = _strdup(obat->dname);
	if (bat->dbid) {
		if (is_new) {
			obat->dbid = temp_copy(bat->dbid, temp);
		} else {
			bat->dbid = ebat_copy(bat->dbid, 0, temp);
		}
	}
	(void)tr;
	return LOG_OK;
}

static int
dup_del(sql_trans *tr, sql_table *ot, sql_table *t)
{
	sql_dbat *bat = t->data = ZNEW(sql_dbat), *obat = ot->data;
	return dup_dbat( tr, obat, bat, isNew(t), isTempTable(t));
}

int
log_destroy_delta(sql_delta *b)
{
	log_bid bid;
	int ok = LOG_OK;

	if (!b)
		return ok;
	if (b->bid && b->name) {
		ok = log_bat_transient(bat_logger, b->name);
		bid = logger_find_bat(bat_logger, b->name);
		if (bid) 
			logger_del_bat(bat_logger, bid);
	} 
	if (b->ubid && b->uname && ok == LOG_OK) {
		ok = log_bat_transient(bat_logger, b->uname);
		bid = logger_find_bat(bat_logger, b->uname);
		if (bid) 
			logger_del_bat(bat_logger, bid);
	}
	return ok;
}

static int
log_destroy_bat(sql_trans *tr, sql_delta *b)
{
	(void)tr;
	return log_destroy_delta(b);
}

int
destroy_delta(sql_delta *b)
{
	if (b->uname)
		_DELETE(b->uname);
	if (b->ibid)
		temp_destroy(b->ibid);
	if (b->ubid)
		temp_destroy(b->ubid);
	if (b->bid) 
		temp_destroy(b->bid);
	b->bid = b->ibid = b->ubid = 0;
	b->name = b->uname = NULL;
	return LOG_OK;
}

static int
destroy_bat(sql_trans *tr, sql_delta *b)
{
	if ((tr && tr->parent == gtrans) || !b)
		return LOG_OK;
	destroy_delta(b);
	_DELETE(b);
	return LOG_OK;
}

static int
destroy_col(sql_trans *tr, sql_column *c)
{
	int ok = destroy_bat(tr, c->data);
	if (!tr || tr->parent != gtrans) 
		c->data = NULL;
	return ok;
}

static int
log_destroy_col(sql_trans *tr, sql_column *c)
{
	return log_destroy_bat(tr, c->data);
}

static int
destroy_idx(sql_trans *tr, sql_idx *i)
{
	int ok = destroy_bat(tr, i->data);
	if (!tr || tr->parent != gtrans) 
		i->data = NULL;
	return ok;
}

static int
log_destroy_idx(sql_trans *tr, sql_idx *i)
{
	return log_destroy_bat(tr, i->data);
}

int
destroy_dbat(sql_dbat *bat)
{
	if (bat->dname)
		_DELETE(bat->dname);
	if (bat->dbid)
		temp_destroy(bat->dbid);
	bat->dbid = 0;
	bat->dname = NULL;
	return LOG_OK;
}

static int
destroy_del(sql_trans *tr, sql_table *t)
{
	int ok = 0;
	sql_dbat *bat = t->data;

	if ((tr && tr->parent == gtrans) || !bat)
		return LOG_OK;
	ok = destroy_dbat(bat);
	_DELETE(bat);
	t->data = NULL;
	return ok;
}

int 
log_destroy_dbat(sql_dbat *bat)
{
	int ok = LOG_OK;
	if (bat->dbid && bat->dname) {
		log_bid bid;

		ok = log_bat_transient(bat_logger, bat->dname);
		bid = logger_find_bat(bat_logger, bat->dname);
		if (bid) 
			logger_del_bat(bat_logger, bid);
	}
	return ok;
}

static int
log_destroy_del(sql_trans *tr, sql_table *t)
{
	(void)tr;
	return log_destroy_dbat(t->data);
}

BUN
clear_delta(sql_trans *tr, sql_delta *bat)
{
	BAT *b;
	BUN sz = 0;

	if (bat->ibid) {
		b = temp_descriptor(bat->ibid);
		sz += BATcount(b);
		bat_clear(b);
		BATcommit(b);
		bat_destroy(b);
	}
	if (bat->bid) {
		b = temp_descriptor(bat->bid);
		sz += BATcount(b);
		/* for transactions we simple switch to ibid only */
		if (tr != gtrans) {
			temp_destroy(bat->bid);
			bat->bid = 0;
		} else {
			bat_clear(b);
			BATcommit(b);
		}
		bat->ibase = 0;
		bat_destroy(b);
	}
	if (bat->ubid) { 
		b = temp_descriptor(bat->ubid);
		bat_clear(b);
		BATcommit(b);
		bat_destroy(b);
	}
	bat->cnt = 0;
	return sz;
}

static BUN 
clear_col(sql_trans *tr, sql_column *c)
{
	if (c->data)
		return clear_delta(tr, c->data);
	return 0;
}

static BUN
clear_idx(sql_trans *tr, sql_idx *i)
{
	if (i->data)
		return clear_delta(tr, i->data);
	return 0;
}

BUN
clear_dbat(sql_trans *tr, sql_dbat *bat)
{
	BUN sz = 0;

	(void)tr;
	if (bat->dbid) {
		BAT *b = temp_descriptor(bat->dbid);

		sz += BATcount(b);
		bat_clear(b);
		BATcommit(b);
		bat_destroy(b);
	}
	bat->cnt = 0;
	return sz;
}

static BUN
clear_del(sql_trans *tr, sql_table *t)
{
	return clear_dbat(tr, t->data);
}

int 
tr_update_delta( sql_trans *tr, sql_delta *obat, sql_delta *cbat, int cluster, BUN snapshot_minsize)
{
	int ok = LOG_OK;
	BAT *ups, *ins, *cur;

	(void)tr;
	assert(store_nr_active>0);

	/* for cleared tables the bid is reset */
	if (cbat->bid == 0) {
		cbat->bid = obat->bid;
		temp_dup(cbat->bid);
	}

	cur = temp_descriptor(obat->bid);
	ins = temp_descriptor(cbat->ibid);
	/* any inserts */
	if (BUNlast(ins) > BUNfirst(ins)) {
		if (BUNlast(ins) > ins->batInserted && (store_nr_active > 1 || cluster)) { 
			BAT *ci = temp_descriptor(obat->ibid);
			append_inserted(ci, ins);
			bat_destroy(ci);
		}
		obat->cnt = cbat->cnt;
		if (store_nr_active == 1 && !cluster) { /* flush all */
			BAT *pi = temp_descriptor(obat->ibid);
			if (!BATcount(cur) && BATcount(ins) > snapshot_minsize){
				/* swap cur and ins */
				BAT *newcur = ins;

				temp_destroy(obat->bid);
				temp_destroy(cbat->bid);

				obat->bid = cbat->bid = temp_create(newcur);
				cbat->ibid = e_bat(cur->ttype);
				ins = temp_descriptor(cbat->ibid);
				bat_destroy(cur);
				cur = newcur;
			} else {
				if (BATcount(cur)+BATcount(ins) > (BUN) REMAP_PAGE_MAXSIZE) { /* try to use mmap() */
       					BATmmap(cur, STORE_MMAP, STORE_MMAP, STORE_MMAP, STORE_MMAP);
    				}
				BATappend(cur,ins,TRUE);
				temp_destroy(cbat->ibid);
				cbat->ibid = e_bat(cur->ttype);
			}
			bat_clear(pi);
			obat->ibase = cbat->ibase = BATcount(cur);
			BATseqbase(pi, obat->ibase);
			bat_destroy(pi);
		} else {
			BATcommit(ins);
		}
	}
	bat_destroy(ins);

	ups = temp_descriptor(cbat->ubid);
	/* any updates */
	if (BUNlast(ups) > BUNfirst(ups)) {
		if (BUNlast(ups) > ups->batInserted && (store_nr_active > 1 || cluster)) { 
			BAT *cu = temp_descriptor(obat->ubid);

			if (isEUbat(cu)) {
				temp_destroy(obat->ubid);
				obat->ubid = temp_copy(cu->batCacheid, FALSE);
				bat_destroy(cu);
				cu = temp_descriptor(obat->ubid);
			}
			copy_inserted(cu, ups);
			bat_destroy(cu);
		}
		if (store_nr_active == 1 && !cluster) { /* flush all */
			void_replace_bat(cur, ups, TRUE);
			/* cleanup the old deltas */
			temp_destroy(obat->ubid);
			obat->ubid = e_ubat(cur->ttype);
			temp_destroy(cbat->ubid);
			cbat->ubid = e_ubat(cur->ttype);
		} else {
			BATcommit(ups);
		}
	}
	bat_destroy(ups);
	bat_destroy(cur);
	return ok;
}

int
tr_update_dbat(sql_trans *tr, sql_dbat *tdb, sql_dbat *fdb, int cleared)
{
	int ok = LOG_OK;
	BAT *db = NULL;

	(void)tr;
	db = temp_descriptor(fdb->dbid);
	if (BUNlast(db) > db->batInserted || cleared) {
		BAT *odb = temp_descriptor(tdb->dbid);

		append_inserted(odb, db);
		bat_destroy(odb);
		BATcommit(db);
		tdb->cnt = fdb->cnt;
	}
	bat_destroy(db);
	return ok;
}

static int
update_table(sql_trans *tr, sql_table *ft, sql_table *tt)
{
	int ok = LOG_OK;
	node *n, *m;

	if (ft->cleared) {
		(void)store_funcs.clear_del(tr->parent, tt);
		for (n = tt->columns.set->h; n; n = n->next) 
			(void)store_funcs.clear_col(tr->parent, n->data);
		if (tt->idxs.set) 
			for (n = tt->idxs.set->h; n; n = n->next) 
				(void)store_funcs.clear_idx(tr->parent, n->data);
	}

	tr_update_dbat(tr, tt->data, ft->data, ft->cleared);
	for (n = ft->columns.set->h, m = tt->columns.set->h; ok == LOG_OK && n && m; n = n->next, m = m->next) {
		sql_column *cc = n->data;
		sql_column *oc = m->data;

		if (!cc->base.wtime) 
			continue;
		tr_update_delta(tr, oc->data, cc->data, isCluster(ft), SNAPSHOT_MINSIZE);

		if (cc->base.rtime)
			oc->base.rtime = tr->stime;
		oc->base.wtime = tr->stime;
		cc->base.rtime = cc->base.wtime = 0;
	}
	if (ok == LOG_OK && tt->idxs.set) {
		for (n = ft->idxs.set->h, m = tt->idxs.set->h; ok == LOG_OK && n && m; n = n->next, m = m->next) {
			sql_idx *ci = n->data;
			sql_idx *oi = m->data;

			/* some indices have no bats */
			if (!oi->data || !ci->base.wtime)
				continue;

			tr_update_delta(tr, oi->data, ci->data, isCluster(ft), SNAPSHOT_MINSIZE);

			if (ci->base.rtime)
				oi->base.rtime = tr->stime;
			oi->base.wtime = tr->stime;
			ci->base.rtime = ci->base.wtime = 0;
		}
	}
	return ok;
}

int 
tr_log_delta( sql_trans *tr, sql_delta *cbat, int cleared)
{
	int ok = LOG_OK;
	BAT *ups, *ins, *cur = NULL;

	(void)tr;
	assert(tr->parent == gtrans);
	if (cbat->name && cbat->uname && cleared) 
		if (log_bat_clear(bat_logger, cbat->name) == LOG_OK)
			log_bat_clear(bat_logger, cbat->uname);

	ins = temp_descriptor(cbat->ibid);
	/* any inserts */
	if (BUNlast(ins) > BUNfirst(ins)) {
		assert(store_nr_active>0);
		if (cbat->bid)
			cur = temp_descriptor(cbat->bid);
		if (BUNlast(ins) > ins->batInserted && (store_nr_active != 1 || (cur && BATcount(cur)) || BATcount(ins) <= SNAPSHOT_MINSIZE))
			ok = log_bat(bat_logger, ins, cbat->name);
		if (store_nr_active == 1 && 
		    ((!cur || !BATcount(cur)) && BATcount(ins) > SNAPSHOT_MINSIZE)) {
			/* log new snapshot */
			logger_add_bat(bat_logger, ins, cbat->name);
			ok = log_bat_persists(bat_logger, ins, cbat->name);
		}
		if (cur)
			bat_destroy(cur);
	}
	bat_destroy(ins);

	ups = temp_descriptor(cbat->ubid);
	/* any updates */
	if (ok == LOG_OK && BUNlast(ups) > ups->batInserted) 
		ok = log_bat(bat_logger, ups, cbat->uname);
	bat_destroy(ups);
	return ok;
}

int
tr_log_dbat(sql_trans *tr, sql_dbat *fdb, int cleared)
{
	int ok = LOG_OK;
	BAT *db = NULL;

	(void)tr;
	assert (fdb->dname);
	if (cleared) 
		log_bat_clear(bat_logger, fdb->dname);

	db = temp_descriptor(fdb->dbid);
	if (BUNlast(db) > db->batInserted || cleared) 
		ok = log_bat(bat_logger, db, fdb->dname);
	bat_destroy(db);
	return ok;
}

static int
log_table(sql_trans *tr, sql_table *ft)
{
	int ok = LOG_OK;
	node *n;

	assert(tr->parent == gtrans);
	ok = tr_log_dbat(tr, ft->data, ft->cleared);
	for (n = ft->columns.set->h; ok == LOG_OK && n; n = n->next) {
		sql_column *cc = n->data;

		if (!cc->base.wtime) 
			continue;
		ok = tr_log_delta(tr, cc->data, ft->cleared);
	}
	if (ok == LOG_OK && ft->idxs.set) {
		for (n = ft->idxs.set->h; ok == LOG_OK && n; n = n->next) {
			sql_idx *ci = n->data;

			/* some indices have no bats or changes */
			if (!ci->data || !ci->base.wtime)
				continue;

			ok = tr_log_delta(tr, ci->data, ft->cleared);
		}
	}
	return ok;
}

static int 
tr_snapshot_bat( sql_trans *tr, sql_delta *cbat)
{
	int ok = LOG_OK;

	assert(tr->parent == gtrans);
	assert(store_nr_active>0);

	(void)tr;
	if (store_nr_active == 1) { 
		BAT *cur = NULL, *ins = temp_descriptor(cbat->ibid);

		/* any inserts */
		if (BUNlast(ins) > BUNfirst(ins)) {
			if (cbat->bid)
				cur = temp_descriptor(cbat->bid);
		        if ((!cur || !BATcount(cur)) && BATcount(ins) > SNAPSHOT_MINSIZE) {
				BATmode(ins, PERSISTENT);
				if (BATcount(ins) > (BUN) REMAP_PAGE_MAXSIZE)
       					BATmmap(ins, STORE_MMAP, STORE_MMAP, STORE_MMAP, STORE_MMAP);
			}
			if (cur)
				bat_destroy(cur);
		}
		bat_destroy(ins);
	}
	return ok;
}

static int
snapshot_table(sql_trans *tr, sql_table *ft)
{
	int ok = LOG_OK;
	node *n;

	assert(tr->parent == gtrans);

	if (isCluster(ft))
		return ok;
	for (n = ft->columns.set->h; ok == LOG_OK && n; n = n->next) {
		sql_column *cc = n->data;

		if (!cc->base.wtime) 
			continue;
		tr_snapshot_bat(tr, cc->data);
	}
	if (ok == LOG_OK && ft->idxs.set) {
		for (n = ft->idxs.set->h; ok == LOG_OK && n; n = n->next) {
			sql_idx *ci = n->data;

			/* some indices have no bats or changes */
			if (!ci->data || !ci->base.wtime)
				continue;

			tr_snapshot_bat(tr, ci->data);
		}
	}
	return ok;
}

int
bat_storage_init( store_functions *sf)
{
	sf->bind_col = (bind_col_fptr)&bind_col;
	sf->bind_idx = (bind_idx_fptr)&bind_idx;
	sf->bind_del = (bind_del_fptr)&bind_del;

	sf->append_col = (append_col_fptr)&append_col;
	sf->append_idx = (append_idx_fptr)&append_idx;
	sf->update_col = (update_col_fptr)&update_col;
	sf->update_idx = (update_idx_fptr)&update_idx;
	sf->delete_tab = (delete_tab_fptr)&delete_tab;

	sf->count_col = (count_col_fptr)&count_col;
	sf->count_idx = (count_idx_fptr)&count_idx;

	sf->create_col = (create_col_fptr)&create_col;
	sf->create_idx = (create_idx_fptr)&create_idx;
	sf->create_del = (create_del_fptr)&create_del;

	sf->log_create_col = (create_col_fptr)&log_create_col;
	sf->log_create_idx = (create_idx_fptr)&log_create_idx;
	sf->log_create_del = (create_del_fptr)&log_create_del;

	sf->snapshot_create_col = (create_col_fptr)&snapshot_create_col;
	sf->snapshot_create_idx = (create_idx_fptr)&snapshot_create_idx;
	sf->snapshot_create_del = (create_del_fptr)&snapshot_create_del;

	sf->dup_col = (dup_col_fptr)&dup_col;
	sf->dup_idx = (dup_idx_fptr)&dup_idx;
	sf->dup_del = (dup_del_fptr)&dup_del;

	sf->destroy_col = (destroy_col_fptr)&destroy_col;
	sf->destroy_idx = (destroy_idx_fptr)&destroy_idx;
	sf->destroy_del = (destroy_del_fptr)&destroy_del;

	sf->log_destroy_col = (destroy_col_fptr)&log_destroy_col;
	sf->log_destroy_idx = (destroy_idx_fptr)&log_destroy_idx;
	sf->log_destroy_del = (destroy_del_fptr)&log_destroy_del;

	sf->clear_col = (clear_col_fptr)&clear_col;
	sf->clear_idx = (clear_idx_fptr)&clear_idx;
	sf->clear_del = (clear_del_fptr)&clear_del;

	sf->update_table = (update_table_fptr)&update_table;
	sf->log_table = (update_table_fptr)&log_table;
	sf->snapshot_table = (update_table_fptr)&snapshot_table;
	return LOG_OK;
}

