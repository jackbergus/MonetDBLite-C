@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2005 CWI.
@' All Rights Reserved.

@f bat_bm
@t Bat Manager
@a N. J. Nes
@v 1.0
@T
@* Introduction
Manages a collection of bats. This gives an abstraction on top of the monet
bat ids.

@* Implementation Code 
@h
#ifndef _SQL_BM_H_
#define _SQL_BM_H_

#include "sql_mem.h"
#include <gdk.h>

extern void bat_destroy(BAT *b);
extern BAT *bat_descriptor(bat bid, char *func);
extern BAT *bat_copy(BAT *b, char *func);
extern BAT *bat_new(int ht, int tt, size_t size, char *func);
extern void bat_incref(bat bid, bit flag, char *func);
extern void bat_decref(bat bid, bit flag);

extern ptr bun_find(BAT *b, ptr v);

extern struct bm *bm_create(int debug);
extern void bm_destroy(struct bm *bm);
extern int bm_commit(struct bm *bm);

/* fake commits as real commits are handled by a log manager */
extern void bm_fakecommit(struct bm *bm );
extern void bm_abort(struct bm *bm );

extern oid bm_add_bat(struct bm *bm, BAT *b, char *name);
extern void bm_del_bat(struct bm *bm, oid bid);

extern oid bm_find_bat(struct bm *bm, char *name);

#endif /*_SQL_BM_H_*/
@c
#include "sql_mem.h"
#include "bat_bm.h"
#include "stream.h"

/* #define RENAME */

typedef struct bm {
	/* Store oids to circumvent trouble with reference counting */
	int debug;
	BAT *bat_name;		/*      [ oid, str ]   */
} bm;

static int bm_debug = 0;

void
bat_destroy(BAT *b)
{
	if (bm_debug)
		printf("destroy %d (%d,%d)\n", b->batCacheid, BBPrefs(b->batCacheid), BBP_lrefs(b->batCacheid));
	if (b)
		BBPunfix(b->batCacheid);
}

BAT *
bat_descriptor(bat bid, char *func)
{
	BAT *b = BATdescriptor(bid);

	if (bm_debug)
		printf("bat_destriptor %s %d (%d,%d)\n", func, bid, BBPrefs(bid), BBP_lrefs(bid));
	return b;
}

BAT *
bat_copy(BAT *b, char *func)
{
	BAT *nb = BATcopy(b);

	if (bm_debug)
		printf("bat_copy(%s) %d (%d,%d)\n", func, nb->batCacheid, BBPrefs(nb->batCacheid), BBP_lrefs(nb->batCacheid));
	return nb;
}

BAT *
bat_new(int ht, int tt, size_t size, char *func)
{
	BAT *nb = BATnew(ht, tt, size);

	if (bm_debug)
		printf("bat_new(%s) %d (%d,0)\n", func, nb->batCacheid, BBPrefs(nb->batCacheid));
	if (ht == TYPE_void)
		BATseqbase(nb, 0);
	nb->batDirty |= 2;
	return nb;
}

void
bat_incref(bat bid, bit flag, char *func)
{
	BBPincref(bid, flag);
	if (bm_debug)
		printf("bat_incref(%s) %d (%d,%d)\n", func, bid, BBP_refs(bid), BBP_lrefs(bid));
}

void
bat_decref(bat bid, bit flag)
{
	if (bm_debug)
		printf("bat_decref() %d (%d,%d)\n", bid, BBP_refs(bid), BBP_lrefs(bid));
	BBPdecref(bid, flag);
}

ptr
bun_find(BAT *b, ptr v)
{
	BUN p = BUNfnd(b, v);

	if (p)
		return BUNtail(b, p);
	return NULL;
}

static BAT *
bm_create_bat(int ht, int tt, size_t size)
{
	BAT *b = bat_new(ht, tt, size, "bm_create_bat");

	/* Make persistent as only persistent bats keep delta information */
	bat_incref(b->batCacheid, TRUE, "bm_create_bat");
	return b;
}

bm *
bm_create(int debug)
{
	bm *bm = NEW(struct bm);
	bat sql_catalog = BBPindex("sql_catalog");

	bm->debug = debug;
	if (sql_catalog == 0) {
		bm->bat_name = bm_create_bat(TYPE_oid, TYPE_str, BUFSIZ);
		BATmode(bm->bat_name, PERSISTENT);
		BBPrename(bm->bat_name->batCacheid, "sql_catalog");
	} else {
		bm->bat_name = bat_descriptor(sql_catalog, "bm_create");
	}
	BATcommit(bm->bat_name);
	return bm;
}

void
bm_destroy(bm *bm)
{
	BUN p, q;
	BAT *b = bm->bat_name;

	/* destroy the deleted */
	for (p = b->batDeleted; p < b->batFirst; p = BUNnext(b, p)) {
		bat bid = *(oid *) BUNhead(b, p);

		bat_decref(bid, TRUE);
	}
	/* free resources */
	BATloop(b, p, q) {
		bat bid = *(oid *) BUNhead(b, p);

		bat_decref(bid, TRUE);
	}

	bat_decref(bm->bat_name->batCacheid, TRUE);
	bat_destroy(bm->bat_name);

	_DELETE(bm);
}

int
bm_commit(bm *bm)
{
	(void)bm;
	if (TMcommit() != 0)	/* save new bats */
		return SQL_ERR;
	return 0;
}

void
bm_fakecommit(bm *bm)
{
	BUN p, q;
	BAT *b = bm->bat_name;

	BATloop(b, p, q) {
		oid bid = *(oid *) BUNhead(b, p);
		BAT *b = bat_descriptor(bid, "bm_fakecommit");

		BATcommit(b);
		bat_destroy(b);
	}

	/* remove the destroyed bats */
	for (p = b->batDeleted; p < b->batFirst; p = BUNnext(b, p)) {
		bat bid = *(oid *) BUNhead(b, p);

		bat_decref(bid, TRUE);
	}
	BATcommit(bm->bat_name);
}

void
bm_abort(bm *bm)
{
	BUN p;
	BAT *b = bm->bat_name;

	/* remove the created bats */
	for (p = b->batInserted; p < BUNlast(b); p = BUNnext(b, p)) {
		bat bid = *(oid *) BUNhead(b, p);

		bat_decref(bid, TRUE);
	}
	for (p = BUNfirst(b); p < b->batInserted; p = BUNnext(b, p)) {
		oid bid = *(oid *) BUNhead(b, p);
		BAT *b = bat_descriptor(bid, "bm_abort");

		BATundo(b);
		BATcommit(b);
		bat_destroy(b);
	}
	BATundo(bm->bat_name);
}

oid
bm_add_bat(bm *bm, BAT *b, char *name)
{
	oid bid = bm_find_bat(bm, name);

	if (bid && bid != b->batCacheid) 
		BUNdelHead(bm->bat_name, &bid);
	bid = b->batCacheid;
	BATmode(b, PERSISTENT);
	BUNins(bm->bat_name, &bid, name);
	bat_incref(bid, TRUE, "bm_add_bat");
	return bid;
}

void
bm_del_bat(bm *bm, oid bid)
{
	BUNdelHead(bm->bat_name, &bid);
}

oid
bm_find_bat(bm *bm, char *name)
{
	BAT *r_bat_name = BATmirror(bm->bat_name);
	oid res = 0;
	BUN p = BUNfnd(r_bat_name, name);

	if (p) 
		res = *(oid *) BUNtail(r_bat_name, p);
	return res;
}
