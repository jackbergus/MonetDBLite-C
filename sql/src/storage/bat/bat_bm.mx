@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2006 CWI.
@' All Rights Reserved.

@f bat_bm
@t Bat Manager
@a N. J. Nes
@v 1.0
@T
@* Introduction
Manages the collections of bats needed for the SQL frontend. This gives 
an abstraction on top of the monet bat ids. Currently it stores two sets;
the active and persistent bats. The active set is store in the bats current 
content, the deleted and inserted can then be found using the delta status. 

@* Implementation Code 
@h
#ifndef _SQL_BM_H_
#define _SQL_BM_H_

#include "sql_mem.h"
#include <gdk.h>

extern void bat_destroy(BAT *b);
extern BAT *bat_descriptor(bat bid, char *func);
extern BAT *bat_copy(BAT *b, char *func);
extern BAT *bat_new(int ht, int tt, size_t size, char *func);
extern void bat_incref(bat bid, bit flag, char *func);
extern void bat_decref(bat bid, bit flag);

extern ptr bun_find(BAT *b, ptr v);

#endif /*_SQL_BM_H_*/
@c
#include "sql_config.h"
#include "sql_mem.h"
#include "bat_bm.h"
#include "stream.h"

static int bat_debug = 0;

void
bat_destroy(BAT *b)
{
	if (bat_debug)
		printf("destroy %d (%d,%d)\n", b->batCacheid, BBPrefs(b->batCacheid), BBP_lrefs(b->batCacheid));
	if (b)
		BBPunfix(b->batCacheid);
}

BAT *
bat_descriptor(bat bid, char *func)
{
	BAT *b = BATdescriptor(bid);

	if (bat_debug)
		printf("bat_destriptor %s %d (%d,%d)\n", func, bid, BBPrefs(bid), BBP_lrefs(bid));
	return b;
}

BAT *
bat_copy(BAT *b, char *func)
{
	BAT *nb = BATcopy(b, b->htype, b->ttype, TRUE);

	if (bat_debug)
		printf("bat_copy(%s) %d (%d,%d)\n", func, nb->batCacheid, BBPrefs(nb->batCacheid), BBP_lrefs(nb->batCacheid));
	return nb;
}

BAT *
bat_new(int ht, int tt, size_t size, char *func)
{
	BAT *nb = BATnew(ht, tt, size);

	if (bat_debug)
		printf("bat_new(%s) %d (%d,0)\n", func, nb->batCacheid, BBPrefs(nb->batCacheid));
	if (ht == TYPE_void)
		BATseqbase(nb, 0);
	nb->batDirty |= 2;
	return nb;
}

void
bat_incref(bat bid, bit flag, char *func)
{
	BBPincref(bid, flag);
	if (bat_debug)
		printf("bat_incref(%s) %d (%d,%d)\n", func, bid, BBP_refs(bid), BBP_lrefs(bid));
}

void
bat_decref(bat bid, bit flag)
{
	if (bat_debug)
		printf("bat_decref() %d (%d,%d)\n", bid, BBP_refs(bid), BBP_lrefs(bid));
	BBPdecref(bid, flag);
}

ptr
bun_find(BAT *b, ptr v)
{
	BUN p = BUNfnd(b, v);

	if (p)
		return BUNtail(b, p);
	return NULL;
}

