@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2006 CWI.
@' All Rights Reserved.

@f res_table

@h
#ifndef RES_TABLE_H
#define RES_TABLE_H

#include "sql_catalog.h"

extern res_table *res_table_create(sql_trans *tr, int res_id, int nr_cols, int querytype, res_table *next);
extern res_col *res_col_create(sql_trans *tr, res_table *t, char *tn, char *name, char *typename, int digits, int scale);

extern void res_table_destroy(res_table *t);

extern res_table *res_tables_remove(res_table *results, res_table *t);
extern void res_tables_destroy(res_table *results);
extern res_table *res_tables_find(res_table *results, int res_id);

#endif /* RES_TABLE_H */
@c

#include "res_table.h"
#include "sql_types.h"
#include "bat_bm.h"

res_table *
res_table_create(sql_trans *tr, int res_id, int nr_cols, int type, res_table *next)
{
	res_table *t = NEW(res_table);

	(void) tr;
	t->id = res_id;

	t->query_type = type;
	t->nr_cols = nr_cols;
	t->cur_col = 0;
	t->cols = NEW_ARRAY(res_col, nr_cols);

	t->order = 0;
	t->next = next;
	return t;
}

res_col *
res_col_create(sql_trans *tr, res_table *t, char *tn, char *name, char *typename, int digits, int scale)
{
	res_col *c = t->cols + t->cur_col;
	
	if (!sql_find_subtype(&c->type, typename, digits, scale)) 
		sql_init_subtype(&c->type, sql_trans_bind_type(tr, typename), digits, scale);
	c->tn = _strdup(tn);
	c->name = _strdup(name);
	c->b = 0;
	c->p = NULL;
	c->mtype = TYPE_bat;
	t->cur_col++;
	return c;
}

void
res_col_destroy(res_col *c)
{
	if (c->b) {
		bat_decref(c->b, TRUE);
	} else {
		_DELETE(c->p);
	}
	_DELETE(c->name);
	_DELETE(c->tn);
}


void
res_table_destroy(res_table *t)
{
	int i;

	for (i = 0; i < t->nr_cols; i++) {
		res_col *c = t->cols + i;

		res_col_destroy(c);
	}
	if (t->order)
		bat_decref(t->order, TRUE);
	_DELETE(t->cols);
	_DELETE(t);
}

res_table *
res_tables_remove(res_table *results, res_table *t)
{
	res_table *r = results;

	if (r == t) {
		results = t->next;
	} else {
		for (; r; r = r->next) {
			if (r->next == t) {
				r->next = t->next;
				break;
			}
		}
	}
	res_table_destroy(t);
	return results;
}

void
res_tables_destroy(res_table *tab)
{
	if (tab) {
		res_table *r = tab, *t;

		for (t = r; t; t = r) {
			r = t->next;
			res_table_destroy(t);
		}
	}
}

res_table *
res_tables_find(res_table *results, int res_id)
{
	res_table *r = results;

	for (; r; r = r->next) {
		if (r->id == res_id)
			return r;
	}
	return NULL;
}
