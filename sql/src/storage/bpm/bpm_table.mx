@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2007 CWI.
@' All Rights Reserved.

@f bpm_table
@+ The bat table store
The bat table stores tables using, Monet's binary association tables (BATs).
In the global view of the database, a table with columns Cj with 1<j<n,
is stored on disk using the following set of BATs. Each column has one
base bat (Bj), containing the current column values. As we like to use
void bats we cannot use the bat delete functionality, so we keep an extra
bat with the deleted oids (D).

To support the full ACID properties we need to keep a little more. First
when we get inserts, we need to add bats (BIj) with these inserts (we cannot
change the read only base columns). For deletes we also need an extra
delete bat (DI) in which we can insert the newly deleted oids.

Last to support updates we need one more set of bats (Uj) which stores
oid, values pairs.

Merging of base, insert, deletes and updates is done during the query
execution. There we try to reduce the overhead of these extra bats by
pushing the union, minus and update operations through the relational
operators.  

@h
#ifndef BPM_TABLE_H
#define BPM_TABLE_H

#include "sql_storage.h"

/* initialize bat storage call back functions interface */
extern int bpm_table_init( table_functions *tf );

#endif /*BPM_TABLE_H*/
@c
#include "sql_config.h"
#include "bpm_table.h"
#include "bpm_storage.h"
#include "bat/bat_utils.h"

static BAT *
full_column(sql_column *c, BAT *d, BAT *s )
{
	sql_bpm *p = c->data;
	/* return full normalized column bat

		if (s) {
			b := b.semijoin(s);
			i := i.semijoin(s);
			u := u.semijoin(s);
		}
		b := b.kunion(i);
		b := b.kdiff(u);
		b := b.kunion(u);
		b := b.kdiff(reverse(d));
	*/
	BAT *r, *b, *u, *i = temp_descriptor(p->parts[p->ins].bid);

	if (p->ins==0) {
		r = i; 
		if (s) {
			r = BATsemijoin(i,s);
			bat_destroy(i);
		}
		return r;
	}
	b = temp_descriptor(p->parts[0].bid);
	u = temp_descriptor(p->parts[0].ubid);
	if (s) {
		BAT *t;

		t = BATsemijoin(b,s); bat_destroy(b); b = t;
		t = BATsemijoin(i,s); bat_destroy(i); i = t;
		t = BATsemijoin(u,s); bat_destroy(u); u = t;
	}
	assert(b->ttype == i->ttype);
	r = BATkunion(b,i); bat_destroy(b); bat_destroy(i); b = r;
	r = BATkdiff(b,u); bat_destroy(b); b = r;
	assert(b->ttype == u->ttype);
	r = BATkunion(b,u); bat_destroy(b); bat_destroy(u); b = r;
	if (d) {
		r = BATkdiff(b,BATmirror(d)); bat_destroy(b); b = r;
	}
	assert(r->T->hash == NULL);
	return r;
}

static ssize_t
column_find_row(sql_trans *tr, sql_column *c, void *value, ...)
{
	va_list va;
	BUN q;
	BAT *b = NULL, *s = NULL, *r = NULL, *d = NULL;
	ssize_t rid = -1;
	sql_column *nc;
	void *nv;
	sql_bpm *p = c->t->data;

	if (p->parts[0].bid) 
		d = store_funcs.bind_del(tr, c->t, RDONLY);
	va_start(va, value);
	while ((nc = va_arg(va, sql_column *)) != NULL) {
		nv = va_arg(va, void *);

		b = full_column(c, d, s);
		if (s)
			bat_destroy(s);
		s = BATselect(b, value, value);
		bat_destroy(b);
		c = nc;
		value = nv;
	}
	b = full_column(c, d, s);
	if (s)
		bat_destroy(s);
	if (d)
		bat_destroy(d);

	r = BATmirror(b);
	q = BUNfnd(r, value);
	if (q != BUN_NONE) {
		BATiter ri = bat_iterator(r);
		rid = *(oid *) BUNtail(ri, q);
	}
	bat_destroy(b);
	return rid;
}

static void *
column_find_value(sql_trans *tr, sql_column *c, ssize_t rid)
{
	BUN q;
	BAT *b, *d = NULL;
	void *res = NULL;
	sql_bpm *p = c->t->data;

	if (p->parts[0].bid) 
		d = store_funcs.bind_del(tr, c->t, RDONLY);
	b = full_column(c, d, NULL);
	if (d)
		bat_destroy(d);

	q = BUNfnd(b, (ptr) &rid);
	if (q != BUN_NONE) {
		BATiter bi = bat_iterator(b);
		void *r;
		int sz;

		res = BUNtail(bi, q);
                sz = ATOMlen(b->ttype, res);
                r = GDKmalloc(sz);
		memcpy(r,res,sz);
		res = r;
	}
	bat_destroy(b);
	return res;
}

static int
column_update_value(sql_trans *tr, sql_column *c, ssize_t rid, void *value)
{
	BAT *b;
	sql_bpm *p = c->data;

	assert(rid != (ssize_t)oid_nil);
	assert(rid != -1);

	if (p->parts[0].ubid) {
		b = temp_descriptor(p->parts[0].ubid);
		if (BUNfnd(b, &rid) != BUN_NONE) {
			BUNreplace(b, (ptr) &rid, value, TRUE);
		} else {
			bat_set_access(b, BAT_WRITE);
			BUNins(b, (ptr) &rid, value, FALSE);
			bat_set_access(b, BAT_READ);
		}
		bat_destroy(b);
	} else {
		b = temp_descriptor(p->parts[p->ins].bid);
		void_inplace(b, rid, value, TRUE);
		bat_destroy(b);
	}
	c->base.wtime = c->t->base.wtime = c->t->s->base.wtime = tr->wtime = tr->stime;
	return 0;
}

static int
table_insert(sql_trans *tr, sql_table *t, ...)
{
	va_list va;
	node *n = cs_first_node(&t->columns);
	sql_column *c = n->data;
	sql_bpm *p = c->data;
	BAT *b = temp_descriptor(p->parts[p->ins].bid);
	void *val = NULL;
	int cnt = 0;

	bat_destroy(b);
	va_start(va, t);

	c->base.wtime = tr->stime;
	for (val = va_arg(va, void *); n && val; n = n->next, val = va_arg(va, void *))
	{
		cnt++;
		c = n->data;
		p = c->data;
		b = temp_descriptor(p->parts[p->ins].bid);
		BUNappend(b, val, TRUE);
		bat_destroy(b);
		c->base.wtime = tr->stime;
	}
	t->cnt ++;
	if (n) {
		fprintf(stderr, "called table_insert(%s) with wrong number of args (%d,%d)\n", t->base.name, list_length(t->columns.set), cnt);
		assert(0);
		return -1;
	}
	t->base.wtime = t->s->base.wtime = tr->wtime = tr->stime;
	return 0;
}

static int
table_delete(sql_trans *tr, sql_table *t, ssize_t rid)
{
	assert(rid != (ssize_t)oid_nil);
	assert(rid != -1);

	store_funcs.delete_tab(tr, t, &rid, TYPE_oid);
	return 0;
}


#if 0
static int
table_dump(sql_trans *tr, sql_table *t)
{
	node *n = cs_first_node(&t->columns);
	int i, l = cs_size(&t->columns);
	BAT **b = (BAT**)GDKmalloc(sizeof(BAT*) * l);
	
	(void)tr;
	for (i = 0; n; n = n->next, i++) {
		sql_column *c = n->data;
		sql_bpm *p = c->data;

		b[i] = temp_descriptor(p->parts[0].bid);
	}
	BATmultiprintf(GDKstdout, l +1, b, TRUE, 0, 1);
	for (i = 0; i < l; i++)
		bat_destroy(b[i]);
	GDKfree(b);
	return 0;
}

static int
table_check(sql_trans *tr, sql_table *t)
{
	node *n = cs_first_node(&t->columns);
	ssize_t cnt = -1;

	(void)tr;
	for (; n; n = n->next) {
		sql_column *c = n->data;
		sql_bpm *p = c->data;
		BAT *b = temp_descriptor(p->parts[0].bid);

		if (cnt == -1) {
			cnt = BATcount(b);
		} else if (cnt != (ssize_t)BATcount(b)) {
			assert(0);
			return (int)(cnt - BATcount(b));
		}
		bat_destroy(b);
	}
	return 0;
}
#endif

/* returns table rids, for the given select ranges */
static rids *
rids_select( sql_trans *tr, sql_column *key, void *key_value_low, void *key_value_high, ...)
{
	va_list va;
	BAT *b = NULL, *s = NULL, *d = NULL;
	sql_column *nc;
	void *nvl, *nvh;
	rids *rs = NEW(rids);
	sql_bpm *p = key->t->data;

	/* special case, key_value_low and high NULL, ie return all */
	if (p->parts[0].bid) 
		d = store_funcs.bind_del(tr, key->t, RDONLY);
	if (key_value_low || key_value_high) {
		va_start(va, key_value_high);
		while ((nc = va_arg(va, sql_column *)) != NULL) {
			nvl = va_arg(va, void *);
			nvh = va_arg(va, void *);
	
			b = full_column(key, d, s);
			if (s)
				bat_destroy(s);
			if (!key_value_low)
				key_value_low = ATOMnilptr(b->ttype);
			if (!key_value_high)
				key_value_high = ATOMnilptr(b->ttype);
			s = BATselect(b, key_value_low, key_value_high);
			bat_destroy(b);
			key = nc;
			key_value_low = nvl;
			key_value_high = nvh;
		}
	}
	b = full_column(key, d, s);
	if (s)
		bat_destroy(s);
	if (d)
		bat_destroy(d);
	if (key_value_low || key_value_high) {
		if (!key_value_low)
			key_value_low = ATOMnilptr(b->ttype);
		if (!key_value_high)
			key_value_high = ATOMnilptr(b->ttype);
		rs->data = BATselect(b, key_value_low, key_value_high);
		bat_destroy(b);
	} else {
		rs->data = b;
	}
	rs->cur = 0;
	return rs;
}

/* order rids by orderby_column values */
static rids *
rids_orderby(sql_trans *tr, rids *r, sql_column *orderby_col)
{
	BAT *b, *d = NULL;
	sql_bpm *p = orderby_col->t->data;

	if (p->parts[0].bid) 
		d = store_funcs.bind_del(tr, orderby_col->t, RDONLY);
	b = full_column(orderby_col, d, r->data);
	if (d)
		bat_destroy(d);
	bat_destroy(r->data);
	b = BATmirror(b);
	r->data = BATmirror(BATsort(b));
	bat_destroy(b);
	return r;
}


/* return table rids from result of rids_select, return (-1) when done */
static ssize_t 
rids_next(rids *r)
{
	if (r->cur < BATcount(r->data)) {
		BATiter bi = bat_iterator(r->data);
		return *(oid*)BUNhead(bi, r->cur++);
	}
	return -1;
}

static rids *
rids_join(sql_trans *tr, rids *l, sql_column *lc, rids *r, sql_column *rc)
{
	BAT *lcb, *rcb, *d = NULL;
	sql_bpm *lp, *rp;
	
	lp = lc->t->data;
	if (lp->parts[0].bid) 
		d = store_funcs.bind_del(tr, lc->t, RDONLY);
	lcb = full_column(lc, d, r->data);
	if (d)
		bat_destroy(d);
	rp = rc->t->data;
	if (rp->parts[0].bid) 
		d = store_funcs.bind_del(tr, rc->t, RDONLY);
	rcb = full_column(rc, d, r->data);
	if (d)
		bat_destroy(d);
	bat_destroy(l->data);
	l->data = BATjoin(lcb, BATmirror(rcb), BATcount(lcb));
	bat_destroy(lcb);
	bat_destroy(rcb);
	return l;
}

/* clean up the resources taken by the result of rids_select */
static void 
rids_destroy(rids *r)
{
	bat_destroy(r->data);
	_DELETE(r);
}

int 
bpm_table_init( table_functions *tf )
{
	tf->column_find_row = column_find_row;
	tf->column_find_value = column_find_value;
	tf->column_update_value = column_update_value;
	tf->table_insert = table_insert;
	tf->table_delete = table_delete;
	
	tf->rids_select = rids_select;
	tf->rids_orderby = rids_orderby;
	tf->rids_join = rids_join;
	tf->rids_next = rids_next;
	tf->rids_destroy = rids_destroy;
	return LOG_OK;
}
