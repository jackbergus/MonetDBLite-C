# The contents of this file are subject to the MonetDB Public License
# Version 1.1 (the "License"); you may not use this file except in
# compliance with the License. You may obtain a copy of the License at
# http://www.monetdb.org/Legal/MonetDBLicense
#
# Software distributed under the License is distributed on an "AS IS"
# basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
# License for the specific language governing rights and limitations
# under the License.
#
# The Original Code is the MonetDB Database System.
#
# The Initial Developer of the Original Code is CWI.
# Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
# Copyright August 2008-2014 MonetDB B.V.
# All Rights Reserved.

import os
import sys
import re

dirlist = {
    'gdk': ['gdk', 'common/options', 'common/utils'],
    'mapi': ['clients/mapilib'],
    'monetdb5': ['monetdb5'],
    'stream': ['common/stream'],
    }
libs = sorted(dirlist.keys())
skipdirs = ['extras']
skipfiles = ['monet_getopt.h']
srcdir = r'@SOURCE@'
blddir = r'@BUILD@'

cmtre = re.compile(r'/\*.*?\*/|//[^\n]*', re.DOTALL)
expre = re.compile(r'\b[a-zA-Z_0-9]+export\s+(?P<decl>[^;]*;)', re.MULTILINE)
spcre = re.compile(r'\s+')
nmere = re.compile(r'\b(?P<name>[a-zA-Z_][a-zA-Z_0-9]*)\s*[[(;]')
strre = re.compile(r'([^ *])\*')
comre = re.compile(r',\s*')
defre = re.compile(r'^[ \t]*#[ \t]*define[ \t]+(?P<name>[a-zA-Z_][a-zA-Z0-9_]*)\((?P<args>[a-zA-Z0-9_, \t]*)\)[ \t]*(?P<def>.*)$', re.MULTILINE)
cldef = re.compile(r'^[ \t]*#', re.MULTILINE)

def extract(f):
    decls = []
    data = open(f).read()
    # remove C comments
    res = cmtre.search(data)
    while res is not None:
        data = data[:res.start(0)] + ' ' + data[res.end(0):]
        res = cmtre.search(data, res.start(0))
    # remove \ <newline> combo's
    data = data.replace('\\\n', '')

    defines = {}
    ndata = []
    for line in data.split('\n'):
        # print >> sys.stderr, 'processing',line
        res = defre.match(line)
        if res is not None:
            name, args, body = res.groups()
            args = tuple(map(lambda x: x.strip(), args.split(',')))
            defines[name] = (args, body)
        else:
            tried = {}
            changed = True
            while changed:
                changed = False
                for name, (args, body) in defines.items():
                    if name in tried:
                        continue
                    pat = r'\b%s\b' % name
                    sep = r'\('
                    for arg in args:
                        pat = pat + sep + r'([^,(]*(?:\([^,(]*\)[^,(]*)*)'
                        sep = ','
                    pat += r'\)'
                    repl = {}
                    r = re.compile(pat)
                    res = r.search(line)
                    if res is not None:
                        tried[name] = True
                        changed = True
                    while res is not None:
                        pars = map(lambda x: x.strip(), res.groups())
                        pat = r'\b(?:'
                        sep = ''
                        for a, p in zip(args, pars):
                            repl[a] = p
                            pat += sep + a
                            sep = '|'
                        pat += r')\b'
                        bd = body
                        if pat != r'\b(?:)\b':
                            r2 = re.compile(pat)
                            res2 = r2.search(bd)
                            while res2 is not None:
                                a = res2.group(0)
                                bd = bd[:res2.start(0)] + repl[a] + bd[res2.end(0):]
                                res2 = r2.search(bd, res2.start(0) + len(repl[a]))
                        bd = bd.replace('##', '')
                        line = line[:res.start(0)] + bd + line[res.end(0):]
                        res = r.search(line, res.start(0) + len(bd))
            if not cldef.match(line):
                ndata.append(line)
    data = '\n'.join(ndata)

    res = expre.search(data)
    while res is not None:
        pos = res.end(0)
        decl = res.group('decl')
        decl = spcre.sub(' ', decl) \
            .replace(' ;', ';') \
            .replace(' (', '(') \
            .replace('( ', '(') \
            .replace(' )', ')') \
            .replace(') ', ')') \
            .replace('* ', '*') \
            .replace(' ,', ',') \
            .replace(')__attribute__', ') __attribute__')
        decl = strre.sub(r'\1 *', decl)
        decl = comre.sub(', ', decl)
        res = nmere.search(decl)
        if res is not None:
            decls.append((res.group('name'), decl))
        else:
            decls.append(('', decl))
        res = expre.search(data, pos)
    return decls

def findfiles(dirlist, skipfiles = [], skipdirs = []):
    decls = []
    done = {}
    for d in dirlist:
        for root, dirs, files in os.walk(d):
            for d in skipdirs:
                if d in dirs:
                    dirs.remove(d)
            for f in files:
                if f not in done and \
                        (f.endswith('.c') or f.endswith('.h')) and \
                        not f.startswith('.') and \
                        f not in skipfiles and \
                        os.path.isfile(os.path.join(root, f)):
                    decls.extend(extract(os.path.join(root, f)))
                    done[f] = True
    decls.sort()
    names, decls = list(zip(*decls))
    return decls

for lib in libs:
    dirs = dirlist[lib]
    dl = [os.path.join(srcdir, d) for d in dirs]
    if srcdir != blddir:
        dl.extend([os.path.join(blddir, d) for d in dirs])
    decls = findfiles(dl, skipfiles = skipfiles, skipdirs = skipdirs)
    sys.stdout.write('# %s\n' % lib)
    for d in decls:
        sys.stdout.write(d)
        sys.stdout.write('\n')
    sys.stdout.write('\n')
