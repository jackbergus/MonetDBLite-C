# The contents of this file are subject to the MonetDB Public License
# Version 1.1 (the "License"); you may not use this file except in
# compliance with the License. You may obtain a copy of the License at
# http://www.monetdb.org/Legal/MonetDBLicense
#
# Software distributed under the License is distributed on an "AS IS"
# basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
# License for the specific language governing rights and limitations
# under the License.
#
# The Original Code is the MonetDB Database System.
#
# The Initial Developer of the Original Code is CWI.
# Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
# Copyright August 2008-2014 MonetDB B.V.
# All Rights Reserved.

import os
import sys
import re

# sets of directories that end up in the same shared object
dirlist = {
    'gdk': ['gdk', 'common/options', 'common/utils'],
    'mapi': ['clients/mapilib'],
    'monetdb5': ['monetdb5'],
    'stream': ['common/stream'],
    }
libs = sorted(dirlist.keys())

# directories we skip
skipdirs = ['extras']

# individual files we skip
skipfiles = ['monet_getopt.h']

# where the files are
srcdir = r'@SOURCE@'
blddir = r'@BUILD@'

# comments (/* ... */ where ... is as short as possible)
cmtre = re.compile(r'/\*.*?\*/|//[^\n]*', re.DOTALL)

# the export command; note the keyword we look for is a word that ends
# in "export"
expre = re.compile(r'\b[a-zA-Z_0-9]+export\s+(?P<decl>[^;]*;)', re.MULTILINE)

# white space
spcre = re.compile(r'\s+')

# the function or variable name
nmere = re.compile(r'\b(?P<name>[a-zA-Z_][a-zA-Z_0-9]*)\s*[[(;]')

# some regexps helping to normalize the output
strre = re.compile(r'([^ *])\*')
comre = re.compile(r',\s*')

# a function-like #define that we expand to also find exports hidden
# in preprocessor macros
defre = re.compile(r'^[ \t]*#[ \t]*define[ \t]+'            # #define
                   r'(?P<name>[a-zA-Z_][a-zA-Z0-9_]*)'      # name being defined
                   r'\((?P<args>[a-zA-Z0-9_, \t]*)\)[ \t]*' # arguments
                   r'(?P<def>.*)$',                         # macro replacement
                   re.MULTILINE)
# line starting with a "#"
cldef = re.compile(r'^[ \t]*#', re.MULTILINE)

# do something a bit like the C preprocessor
# we expand function-like macros and remove all ## sequences from the
# replacement (even when there are no adjacent parameters that were
# replaced), but this is good enough for our purpose of finding
# exports that are hidden away in several levels of macro definitions
def preprocess(data):
    defines = {}
    ndata = []
    for line in data.split('\n'):
        # print >> sys.stderr, 'processing',line
        res = defre.match(line)
        if res is not None:
            name, args, body = res.groups()
            args = tuple(map(lambda x: x.strip(), args.split(',')))
            if len(args) == 1 and args[0] == '':
                args = ()       # empty argument list
            defines[name] = (args, body)
        else:
            tried = {}
            changed = True
            while changed:
                changed = False
                for name, (args, body) in defines.items():
                    if name in tried:
                        continue
                    pat = r'\b%s\b' % name
                    sep = r'\('
                    for arg in args:
                        pat = pat + sep + r'([^,(]*(?:\([^,(]*\)[^,(]*)*)'
                        sep = ','
                    pat += r'\)'
                    repl = {}
                    r = re.compile(pat)
                    res = r.search(line)
                    if res is not None:
                        tried[name] = True
                        changed = True
                    while res is not None:
                        if len(args) > 0:
                            pars = map(lambda x: x.strip(), res.groups())
                            pat = r'\b(?:'
                            sep = ''
                            for arg, par in zip(args, pars):
                                repl[arg] = par
                                pat += sep + arg
                                sep = '|'
                            pat += r')\b'
                            r2 = re.compile(pat)
                            res2 = r2.search(body)
                            while res2 is not None:
                                arg = res2.group(0)
                                body = body[:res2.start(0)] + repl[arg] + body[res2.end(0):]
                                res2 = r2.search(body, res2.start(0) + len(repl[arg]))
                            body = body.replace('##', '')
                        line = line[:res.start(0)] + body + line[res.end(0):]
                        res = r.search(line, res.start(0) + len(body))
            if not cldef.match(line):
                ndata.append(line)
    return '\n'.join(ndata)

def extract(f):
    decls = []
    data = open(f).read()
    # remove C comments
    res = cmtre.search(data)
    while res is not None:
        data = data[:res.start(0)] + ' ' + data[res.end(0):]
        res = cmtre.search(data, res.start(0))
    # remove \ <newline> combo's
    data = data.replace('\\\n', '')

    data = preprocess(data)

    res = expre.search(data)
    while res is not None:
        pos = res.end(0)
        decl = res.group('decl')
        decl = spcre.sub(' ', decl) \
            .replace(' ;', ';') \
            .replace(' (', '(') \
            .replace('( ', '(') \
            .replace(' )', ')') \
            .replace(') ', ')') \
            .replace('* ', '*') \
            .replace(' ,', ',') \
            .replace(')__attribute__', ') __attribute__')
        decl = strre.sub(r'\1 *', decl)
        decl = comre.sub(', ', decl)
        res = nmere.search(decl)
        if res is not None:
            decls.append((res.group('name'), decl))
        else:
            decls.append(('', decl))
        res = expre.search(data, pos)
    return decls

def findfiles(dirlist, skipfiles = [], skipdirs = []):
    decls = []
    done = {}
    for d in dirlist:
        for root, dirs, files in os.walk(d):
            for d in skipdirs:
                if d in dirs:
                    dirs.remove(d)
            for f in files:
                if f not in done and \
                        (f.endswith('.c') or f.endswith('.h')) and \
                        not f.startswith('.') and \
                        f not in skipfiles and \
                        os.path.isfile(os.path.join(root, f)):
                    decls.extend(extract(os.path.join(root, f)))
                    done[f] = True
    decls.sort()
    names, decls = list(zip(*decls))
    return decls

def main():
    for lib in libs:
        dirs = dirlist[lib]
        dl = [os.path.join(srcdir, d) for d in dirs]
        if srcdir != blddir:
            dl.extend([os.path.join(blddir, d) for d in dirs])
        decls = findfiles(dl, skipfiles = skipfiles, skipdirs = skipdirs)
        sys.stdout.write('# %s\n' % lib)
        for d in decls:
            sys.stdout.write(d)
            sys.stdout.write('\n')
        sys.stdout.write('\n')

if __name__ == '__main__':
    main()
