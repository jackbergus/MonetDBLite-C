#!@PYTHON@

# The contents of this file are subject to the MonetDB Public License
# Version 1.1 (the "License"); you may not use this file except in
# compliance with the License. You may obtain a copy of the License at
# http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
#
# Software distributed under the License is distributed on an "AS IS"
# basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
# License for the specific language governing rights and limitations
# under the License.
#
# The Original Code is the MonetDB Database System.
#
# The Initial Developer of the Original Code is CWI.
# Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
# Copyright August 2008-2010 MonetDB B.V.
# All Rights Reserved.

#TODO:
#=====
# - check all TODO's below
# - tidy -up HTML-generation by "keeping in mind" during testing,
#   which OUT/ERR differ or not and which tests were skipped.
#   dump HTML-stuff only at end
#   print an ascii summary at end, too
# - if no diffs, but warnings, say so at end
# - produce, keep & reference LOG
# - add a "grep-like" function and replace "inlined" grep
#   contains(<file>,<string>)
# - do multi-level prompting?
# - normalize all path's used

try:
    True
except NameError:
    # provide values for old Python versions
    False, True = 0, 1

import os
import sys
import shutil
import re
import random
import time
import socket
import struct
import select
#import signal
#import getpass
import Mfilter

# Python 2.3 doesn't know about os.devnull...
try:
    os.devnull
except AttributeError:
    if os.name == 'nt':
        os.devnull = 'nul'
    else:
        os.devnull = '/dev/null'

def _configure(str):
    # expand configure variables in str and return result
    config = [
        ('${source}', '@QXMONETDB_SOURCE@'),
        ('${build}', '@QXMONETDB_BUILD@'),

        ('${bindir}', '@QXbindir@'),
##        ('${sbindir}', '@QXsbindir@'),
        ('${libexecdir}', '@QXlibexecdir@'),
        ('${datarootdir}', '@QXdatarootdir@'),
        ('${datadir}', '@QXdatadir@'),
        ('${sysconfdir}', '@QXsysconfdir@'),
##        ('${sharedstatedir}', '@QXsharedstatedir@'),
        ('${localstatedir}', '@QXlocalstatedir@'),
        ('${libdir}', '@QXlibdir@'),
        ('${includedir}', '@QXincludedir@'),
##        ('${oldincludedir}', '@QXoldincludedir@'),
        ('${infodir}', '@QXinfodir@'),
        ('${mandir}', '@QXmandir@'),
        ('${Qbindir}', '@QXbindir@'),
##        ('${Qsbindir}', '@QXsbindir@'),
        ('${Qlibexecdir}', '@QXlibexecdir@'),
        ('${Qdatarootdir}', '@QXdatarootdir@'),
        ('${Qdatadir}', '@QXdatadir@'),
        ('${Qsysconfdir}', '@QXsysconfdir@'),
##        ('${Qsharedstatedir}', '@QXsharedstatedir@'),
        ('${Qlocalstatedir}', '@QXlocalstatedir@'),
        ('${Qlibdir}', '@QXlibdir@'),
        ('${Qincludedir}', '@QXincludedir@'),
##        ('${Qoldincludedir}', '@QXoldincludedir@'),
        ('${Qinfodir}', '@QXinfodir@'),
        ('${Qmandir}', '@QXmandir@'),
        # put these at end (in this order!) for efficiency
        ('${exec_prefix}', '@QXexec_prefix@'),
        ('${Qexec_prefix}', '@QXexec_prefix@'),
        ('${prefix}', '@QXprefix@'),
        ('${Qprefix}', '@QXprefix@'),
        ]
    changed = True
    while '$' in str and changed:
        changed = False
        for key, val in config:
            nstr = str.replace(key, val)
            changed = changed or str != nstr
            str = nstr
    return str

try:
    import MonetDBtesting.subprocess26 as subprocess
except ImportError:
    import distutils.sysconfig
    if os.name != "nt" and os.uname()[0] + os.uname()[2][:1] == "Darwin9" and sys.version[:5] == "2.5.1":
        p = _configure(os.path.join('@QXprefix@',distutils.sysconfig.get_python_lib(0,1,""),'site-packages'))
    else:
        p = _configure(os.path.join('@QXprefix@',distutils.sysconfig.get_python_lib(0,0,"")))
    sys.path.insert(0, p)
    import MonetDBtesting.subprocess26 as subprocess
    if os.environ.has_key('PYTHONPATH'):
        p = p + os.pathsep + os.environ['PYTHONPATH']
    os.environ['PYTHONPATH'] = p

def isexecutable(TST, ext = '.sh') :
    if   os.name == "nt":
        for ext in ".exe", ".com", ".bat", ".cmd":
            if TST.lower().endswith(ext):
                ext = ''
            if os.path.isfile(TST+ext) or os.path.isfile(TST+ext+".src"):
                return [ 1, ext ]
    elif os.name == "posix":
        #TODO:
        # check with "file", and set executable
        TST = TST + ext
        if ( os.path.isfile(TST       ) and os.access(TST       ,os.X_OK) ) or \
           ( os.path.isfile(TST+".src") and os.access(TST+".src",os.X_OK) ):
            return [ 1, ext ]
    #TODO:
    #else:
        # ???
    return [ 0, "" ]
### isexecutable(TST, ext = '.sh') #

def CheckExec(cmd) :
    for p in os.environ['PATH'].split(os.pathsep):
        x = isexecutable(os.path.join(p,cmd),'')
        if x[0]:
            return os.path.join(p, cmd + x[1])
    return ""
### CheckExec(cmd) #

def GetConfig(cfg, arg) :
    cmd = CheckExec(cfg)
    proc = subprocess.Popen([cmd,arg], stdin = subprocess.PIPE, stdout = subprocess.PIPE, universal_newlines = True)
    qOut, qErr = proc.communicate()
    return _configure(qOut.split('\n', 1)[0].strip())
### GetConfig(pkg, arg) #

def GetMonetConfig(pkg, arg) :
    monetdb_config = pkg+'-config'
    try:
        return GetConfig(monetdb_config, arg)
    except:
        ErrXit('Could not find "%s" in your $PATH:\n%s' % (monetdb_config,os.environ['PATH']))
    return ''
### GetMonetConfig(pkg, arg) #

try:
    from MonetDBtesting import monet_options
except ImportError:
    import distutils.sysconfig
    if os.name != "nt" and os.uname()[0] + os.uname()[2][:1] == "Darwin9" and sys.version[:5] == "2.5.1":
        p = _configure(os.path.join('@QXprefix@',distutils.sysconfig.get_python_lib(0,1,""),'site-packages'))
    else:
        p = _configure(os.path.join('@QXprefix@',distutils.sysconfig.get_python_lib(0,0,"")))
    sys.path.insert(0, p)
    from MonetDBtesting import monet_options
    if os.environ.has_key('PYTHONPATH'):
        p = p + os.pathsep + os.environ['PYTHONPATH']
    os.environ['PYTHONPATH'] = p

import threading, signal

randomPortRepeat = 9

F_SKIP = -1
F_OK = 0
F_WARN = 1
F_SOCK = 2
F_TIME = 3
F_KILL = 4
F_SEGV = 5
F_ERROR = 6

FAILURES = {
    F_SKIP  : "F_SKIP",
    F_OK    : "F_OK",
    F_WARN  : "F_WARN",
    F_SOCK  : "F_SOCK",
    F_TIME  : "F_TIME",
    F_KILL  : "F_KILL",
    F_SEGV  : "F_SEGV",
    F_ERROR : "F_ERROR"
}

CONDITIONALS = {
    # X == true   =>  @X_TRUE@='',  @X_FALSE@='#'
    # X == false  =>  @X_TRUE@='#', @X_FALSE@=''
    # MonetDB:
    'CROSS_COMPILING'  : "@CROSS_COMPILING_FALSE@"
    # remaining conditionals are set dynamically at runtime
}

def GetCONDITIONALS(CONDS, pkg) :
    cfg = pkg+'-config'
    cmd = CheckExec(cfg)
    proc = subprocess.Popen([cmd,'--conds'], stdin = subprocess.PIPE, stdout = subprocess.PIPE, universal_newlines = True)
    qOut, qErr = proc.communicate()
    r = re.compile('^(.*)=(.*)$')
    for l in qOut.split('\n'):
        m = r.match(l.strip())
        if m:
            CONDS[m.group(1)] = m.group(2)
### GetCONDITIONALS(CONDS, pkg) #

# a bunch of classes to help with generating (X)HTML files
class _Encode:
    # mix-in class for encoding text and attribute values so that they
    # don't get interpreted as something else by the browser
    def encode(self, data, attr):
        map = [('&', '&amp;'),          # MUST be first
               ('<', '&lt;'),
               ('>', '&gt;'),
               (None, None),
               # following chars only translated in attr values (attr is True)
               ('"', '&quot;'),
               ('\t', '&#9;'),
               ('\n', '&#10;'),
               ('\r', '&#13;'),
               ]
        for c, tr in map:
            if c is None:
                if not attr:
                    break
                continue
            data = data.replace(c, tr)
        return data

class Element(_Encode):
    # class to represent an (X)HTML element with its attributes and
    # children

    # inline elements, we do not add newlines to the contents of these
    # elements
    inline = ['tt','i','b','big','small','em','strong','dfn','code',
              'samp','kbd','var','cite','abbr','acronym','a','img',
              'object','br','script','map','q','sub','sup','span',
              'bdo','input','select','textarea','label','button','font']
    # empty elements
    empty = ['link', 'basefont', 'br', 'area', 'img', 'param', 'hr',
             'input', 'col', 'frame', 'isindex', 'base', 'meta', ]
    xml = True                          # write XHTML instead of HTML

    def __init__(self, tag, attrdict = None, *children):
        self.tag = tag
        if attrdict is None:
            attrdict = {}
        self.attrdict = attrdict
        if children is None:
            children = []
        self.isempty = tag.lower() in self.empty
        if self.isempty:
            if children:
                raise ValueError("empty element can't have children")
            self.children = None
        else:
            self.children = list(children)

    def __str__(self):
        # string representation of the element with its children
        s = ['<%s' % self.tag]
        attrlist = self.attrdict.items()
        attrlist.sort()
        for name, value in attrlist:
            s.append(' %s="%s"' % (name, self.encode(value, True)))
        if self.children or (not self.xml and not self.isempty):
            s.append('>')
            for c in self.children:
                s.append(str(c))
            s.append('</%s>' % self.tag)
        elif self.xml:
            s.append('/>')
        else:
            s.append('>')               # empty HTML element
        return ''.join(s)

    def write(self, f, newline = False):
        # write the element with its children to a file
        # if newline is set, add newlines at strategic points
        if self.tag.lower() == 'html':
            # before we write the DOCTYPE we should really check
            # whether the document conforms...
            if self.xml:
                f.write('<!DOCTYPE html PUBLIC '
                        '"-//W3C//DTD XHTML 1.0 Transitional//EN"\n'
                        '                      '
                        '"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">\n')
            else:
                f.write('<!DOCTYPE html PUBLIC '
                        '"-//W3C//DTD HTML 4.01 Transitional//EN"\n'
                        '                      '
                        '"http://www.w3.org/TR/html4/loose.dtd">\n')
        inline = self.tag.lower() in self.inline
        f.write('<%s' % self.tag)
        attrlist = self.attrdict.items()
        attrlist.sort()
        for name, value in attrlist:
            f.write(' %s="%s"' % (name, self.encode(value, True)))
        if self.children or (not self.xml and not self.isempty):
            if not inline:
                for c in self.children:
                    if not isinstance(c, Element):
                        inline = True
                        break
            f.write('>')
            if newline and not inline:
                f.write('\n')
            for c in self.children:
                c.write(f, newline and not inline)
            f.write('</%s>' % self.tag)
        elif self.xml:
            f.write('/>')
        else:
            f.write('>')                # empty HTML element
        if newline:
            f.write('\n')

    def addchild(self, child):
        self.children.append(child)

    def addchildren(self, children):
        for child in children:
            self.children.append(child)

    def inschild(self, index, child):
        self.children.insert(index, child)

class Text(_Encode):
    # class to represent text in (X)HTML
    def __init__(self, text = '', raw = False):
        self.text = text
        self.raw = raw

    def __str__(self):
        if self.raw:
            return self.text
        return self.encode(self.text, False)

    def write(self, f, newline = False):
        f.write(str(self))
        if newline and not self.raw:
            f.write('\n')

class Comment:
    # class to represent an (X)HTML comment (not currently used)
    def __init__(self, text):
        self.text = text

    def __str__(self):
        return '<!--%s-->' % self.text

    def write(self, f, newline = False):
        f.write(str(self))

class Timer:
    # interface to the threading.Timer function that interprets a timeout of 0 as no timeout
    def __init__(self, interval, function, args):
        self.timer = None
        if interval > 0:
            self.timer = threading.Timer(interval, function, args = args)

    def start(self):
        if self.timer is not None:
            self.timer.start()

    def cancel(self):
        if self.timer is not None:
            self.timer.cancel()

STDOUT = sys.stdout
STDERR = sys.stdout     # err

black = 'black'                         # #000000
white = 'white'                         # #ffffff
red = 'red'                             # #ff0000
lime = 'lime'                           # #00ff00
green = '#00aa00'
darkgreen = '#005500'
orange = '#ffaa00'
purple = '#aa00aa'
stylesheet = Element('style', None, Text('''
.error   { font-weight: bold; font-style: italic; color: red; }
.killed  { font-weight: bold; font-style: italic; color: purple; }
.timeout { font-weight: bold; font-style: italic; color: purple; }
.socket  { font-weight: bold; font-style: italic; color: purple; }
.segfault { font-weight: bold; font-style: italic; color: purple; }
.warning { font-weight: bold; color: orange; }
.good    {  }
.header  { font-family: helvetica, arial; text-align: center; }
.black   { color: black; }
'''))

TIMES = []

random.seed(time.time())

def Usage (options) :
    try:
        monet_options.usage(options, '%s [options] ( [<dir>] [<tests>] | [<dirs>] )' % THISFILE)
    except monet_options.Error:
        pass

    sys.stderr.write("""
 <dir>   : if present, %(prog)s behaves as if called in <dir>
 <tests> : list of tests to be processed; if none or 'All' is given,
            all tests listed in 'Tests/All' are processed
            (defaults to 'All' if -r is used)
 <dirs>  : list of directories to be processed; if present, %(prog)s
            processes 'All' tests in each directory of <dirs>; -r may be used also

         See  %(readme)s
         for details about  %(prog)s.
""" % {'prog': THISFILE,
       'readme': os.path.join(GetMonetConfig('monetdb','--source'),'src','testing','README'),
       })
    raise

### Usage () #

#TODO:
#class TimeoutError:
#       def __init__(self, text):
#               self.text = text
#       def __str__(self):
#               return self.text
#
#def AlarmHandler(signum, frame) :
#       raise TimeoutError, "Timeout"
#### AlarmHandler(signum, frame) #

def ErrMsg(TEXT) :
    STDOUT.flush()
    STDERR.write("\n"+THISFILE+":  ERROR:  %s\n\n" % TEXT)
    STDERR.flush()
### ErrMsg(TEXT) #

def ErrXit(TEXT) :
    ErrMsg(TEXT)
    sys.exit(1)
### ErrXit(TEXT) #

def Warn(TEXT) :
    try:
        STDOUT.flush()
    except IOError:
        pass
    try:
        STDERR.write("\n"+THISFILE+"  Warning:  %s\n\n" % TEXT)
        STDERR.flush()
    except IOError:
        pass
### Warn(TEXT) #

def startswithpath(str,pre) :
    return os.path.normcase(str[:len(pre)]) == os.path.normcase(pre)
### startswithpath(str,pre) #

import urllib
##def path(str) :
##    return str.replace('/', os.sep)
path = urllib.url2pathname
### path(str) #

##def url(str) :
##    return str.replace(os.sep, '/')
url = urllib.pathname2url
### url(str) #

def try_open(path, mode) :
    try:
        f = open(path, mode)
    except IOError, (IOerrNo, IOerrStr):
        Warn("Opening file '%s' in mode '%s' failed with #%d: '%s'." % (path, mode, IOerrNo, IOerrStr))
        f = None
    return f
###  try_open(path, mode) #

def CreateHtmlIndex (env, *body) :
    TSTDIR=env['TSTDIR']
    TSTTRGBASE=env['TSTTRGBASE']
    TSTTRGDIR=env['TSTTRGDIR']

    if TSTDIR:
        INDEX=".index"
    else:
        INDEX="index"

    if body:
        BACK = os.getcwd()
        os.chdir(TSTTRGDIR)

        if TSTDIR:
            header = Text(TSTDIR)
            if URLPREFIX:
                header = Element('a',
                                 {'href': '%s%s/%s' % (URLPREFIX, url(TSTDIR), TSTSUFF),
                                  'target': '%s%s_%s_body' % (URLSUFFIX_D, DISTVER, TSTDIR),
                                  'class': 'black'},
                                 header)
        else:
            header = Element('span', {'class': 'black'},
                             Text(DISTVER))
        tr = Element('tr', {},
                     Element('th', {'class': 'header'},
                             header))
        tr.addchildren(body)
        html = Element('html', {},
                       Element('head', {},
                               Element('title', {},
                                       Text(HTMLTITLE)),
                               stylesheet),
                       Element('body',
                               {'bgcolor': white,
                                'text': black,
                                'link': green,
                                'vlink': darkgreen,
                                'alink': lime},
                               Element('center', {},
                                       Element('table',
                                               {'align': 'abscenter',
                                                'border': '1',
                                                'cellspacing': '0',
                                                'cellpadding': '3'},
                                               tr))))
        f = open(INDEX+".head.html","w")
        html.write(f, True)
        f.close()

        if TSTDIR:
            ROWS="72"
        else:
            ROWS="54"
        html = Element('html', {},
                       Element('head', {},
                               Element('title', {}, Text(HTMLTITLE))),
                       Element('frameset',
                               {'rows': '%s,*' % ROWS,
                                'frameborder': 'yes',
                                'border': '1',
                                'bordercolor': white,
                                'marginwidth': '0',
                                'marginheight': '0'},
                               Element('frame',
                                       {'src': '%s.head.html' % INDEX,
                                        'scrolling': 'auto',
                                        'name': '%s_%s_head' % (DISTVER, TSTDIR),
                                        'frameborder': 'yes',
                                        'bordercolor': white,
                                        'marginwidth': '0',
                                        'marginheight': '0'}),
                               Element('frame',
                                       {'src': url(env['_'+TSTDIR+'_BODY_'][0]),
                                        'scrolling': 'auto',
                                        'name': '%s_%s_body' % (DISTVER, TSTDIR),
                                        'frameborder': 'yes',
                                        'bordercolor': white,
                                        'marginwidth': '0',
                                        'marginheight': '0'})))
        f = open(INDEX+".html","w")
        html.write(f, True)
        f.close()
        env['_'+TSTDIR+'_BODY_'] = ["",0]
        os.chdir(BACK)
### CreateHtmlIndex (env, *body) #

def CreateTstWhatXhtml (env, TST, stableWHAT, EXT, SockTime) :
    WHAT = stableWHAT[7:11]
    TSTDIR    = env['TSTDIR']
    TSTSRCDIR = env['TSTSRCDIR']

    testT = re.compile("^/"+TST+EXT+"/([^/]*)/", re.MULTILINE)
    testS = re.compile("^/"+TST+stableWHAT+"/([^/]*)/", re.MULTILINE)
    REVt="?"
    REVs="?"
    entries = os.path.join(TSTSRCDIR,"CVS","Entries")
    if os.path.isfile(entries):
        for l in open(entries):
            mT = testT.match(l)
            if mT:
                REVt=mT.group(1)
            mS = testS.match(l)
            if mS:
                REVs=mS.group(1)
    l = ''
    for l in open(TST+WHAT+".diff.html"):
        pass
    if   l[:14] == '<!--NoDiffs-->':
        diffclass = 'good'
        difftext = 'No differences'
    elif l[:17] == '<!--MinorDiffs-->':
        diffclass = 'warning'
        difftext = 'Minor differences'
    elif l[:17] == '<!--MajorDiffs-->':
        diffclass = 'error'
        difftext = 'Major differences'
    else:
        Warn("Unexpected last line in %s:\n%s" % (TST+WHAT+".diff.html",l))
        f = open(TST+WHAT+".diff.html","a")
        f.write("\n<!--MajorDiffs-->\n")
        f.close()
        diffclass = 'error'
        difftext = 'Major differences'
    if diffclass == 'error' and SockTime in (F_SOCK, F_TIME, F_KILL, F_SEGV):
        if SockTime == F_SOCK:
            diffclass = 'socket'
            difftext = difftext + ' (Socket)'
        if SockTime == F_TIME:
            diffclass = 'timeout'
            difftext = difftext + ' (Timeout)'
        if SockTime == F_KILL:
            diffclass = 'killed'
            difftext = difftext + ' (Killed)'
        if SockTime == F_SEGV:
            diffclass = 'segfault'
            difftext = difftext + ' (Crash)'
    if COMPBITSOIDSLINK:
        SYSTEM = DISTVER+", "+COMPBITSOIDSLINK+":"
    else:
        SYSTEM = DISTVER+":"

    html = Element('html', {},
                   Element('head', {},
                           Element('title', {}, Text(HTMLTITLE)),
                           stylesheet),
                   Element('frameset', {'rows': '42,*',
                                        'frameborder': 'yes',
                                        'border': '1',
                                        'bordercolor': white,
                                        'marginwidth': '0',
                                        'marginheight': '0'},
                           Element('frame',
                                   {'src': '.%s%s.head.html' % (TST, WHAT),
                                    'scrolling': 'auto',
                                    'name': '%s_%s_%s_%s_head' % (DISTVER, TSTDIR, TST, WHAT[1:]),
                                    'frameborder': 'yes',
                                    'bordercolor': white,
                                    'marginwidth': '0',
                                    'marginheight': '0'}),
                           Element('frame',
                                   {'src': '%s%s.diff.html' % (TST, WHAT),
                                    'scrolling': 'auto',
                                    'name': '%s_%s_%s_%s_body' % (DISTVER, TSTDIR, TST, WHAT[1:]),
                                    'frameborder': 'yes',
                                    'bordercolor': white,
                                    'marginwidth': '0',
                                    'marginheight': '0'})))
    f = open(".%s%s.html" % (TST, WHAT),"w")
    html.write(f, True)
    f.close()
    f = open(".%s%s.head.html" % (TST, WHAT),"w")
    target = '%s_%s_%s_%s_body' % (DISTVER, TSTDIR, TST, WHAT[1:])
    cvs = Text('cvs')
    if URLPREFIX:
        cvs = Element('a', {'href': '%s%s/%s%s' % (URLPREFIX, url(TSTDIR), TSTSUFF, URLSUFFIX_D),
                            'target': target},
                      cvs)
    text = Element('div', {'class': 'header'},
                   Text(SYSTEM),
                   Text(' '),
                   Element('a', {'href': '%s%s.diff.html' % (TST, WHAT),
                                 'target': target,
                                 'class': diffclass},
                           Text(difftext)),
                   Text(' between '),
                   Element('a', {'href': '%s%s' % (TST, stableWHAT),
                                 'target': target},
                           Text('%s (r%s)' % (stableWHAT[1:], REVs))),
                   Text(' and '),
                   Element('a', {'href': '%s.test%s' % (TST, WHAT),
                                 'target': target},
                           Text('test%s' % WHAT)),
                   Text(' of '),
                   Element('a', {'href': TST + EXT, 'target': target},
                           Text('%s%s (r%s)' % (TST, EXT, REVt))),
                   Text(' in '),
                   Element('a', {'href': './', 'target': target},
                           Text(TSTDIR)),
                   Text(' ('),
                   cvs,
                   Text(', '),
                   Element('a', {'href': url(env['RELSRCDIR']),
                                 'target': target},
                           Text('src')))
    text.addchild(Text(')'))
    html = Element('html', {},
                   Element('head', {},
                           Element('title', {},
                                   Text(HTMLTITLE)),
                           stylesheet),
                   Element('body',
                           {'bgcolor': white,
                            'text': black,
                            'link': green,
                            'vlink': darkgreen,
                            'alink': lime},
                           text))

    html.write(f, True)
    f.close()
#TODO?
# <A HREF='.Mtest.Slave.Log.OutErr' TARGET='"""+DISTVER+"_"+TSTDIR+"_"+TST+"_"+WHAT[1:]+"""_body'>LOG</A>).
### CreateTstWhatXhtml (env, TST, stableWHAT, EXT) #

def CreateSrcIndex (env, TST, EXT) :
    TSTSRCDIR = env['TSTSRCDIR']
    TSTDIR    = env['TSTDIR']

    if URLPREFIX:
        framesrc = '%s%s/%s/%s%s%s' % (URLPREFIX, url(TSTDIR), TSTSUFF, TST, EXT, URLSUFFIX_F)
    else:
        f = open("."+TST+".nosrc.index.html","w")
        html = Element('html', {},
                       Element('head', {},
                               Element('title', {},
                                       Text(HTMLTITLE)),
                               stylesheet),
                       Element('body',
                               {'bgcolor': white,
                                'text': black,
                                'link': green,
                                'vlink': darkgreen,
                                'alink': lime},
                               Element('center', {},
                                       Text('no source available'))))
        framesrc = '.%s.nosrc.index.html' % TST
    html = Element('html', {},
                   Element('head', {},
                           Element('title', {}, Text(HTMLTITLE))),
                   Element('frameset',
                           {'rows': '54,*',
                            'frameborder': 'yes',
                            'border': '1',
                            'bordercolor': white,
                            'marginwidth': '0',
                            'marginheight': '0'},
                           Element('frame',
                                   {'src': '.%s.src.index.head.html' % TST,
                                    'scrolling': 'auto',
                                    'name': '%s_%s_%s_head' % (DISTVER, TSTDIR, TST),
                                    'frameborder': 'yes',
                                    'bordercolor': white,
                                    'marginwidth': '0',
                                    'marginheight': '0'}),
                           Element('frame',
                                   {'src': framesrc,
                                    'scrolling': 'auto',
                                    'name': '%s_%s_%s_body' % (DISTVER, TSTDIR, TST),
                                    'frameborder': 'yes',
                                    'bordercolor': white,
                                    'marginwidth': '0',
                                    'marginheight': '0'})))
    f = open("."+TST+".src.index.html","w")
    html.write(f, True)
    f.close()

    tr = Element('tr', {},
                 Element('th', {'class': 'header'},
                         Text(TST)))
    for s in os.listdir(TSTSRCDIR):
        if len(s) >= len(TST)  and  s[:len(TST)] == TST:
            slink = Text(s)
            if URLPREFIX:
                slink = Element('a',
                                {'href': '%s%s/%s/%s%s' % (URLPREFIX, url(TSTDIR), TSTSUFF, s, URLSUFFIX_F),
                                 'target': '%s_%s_%s_body' % (DISTVER, TSTDIR, TST)},
                                slink)
            tr.addchild(Element('td', {'class': 'header'},
                                slink))
    html = Element('html', {},
                   Element('head', {},
                           Element('title', {},
                                   Text(HTMLTITLE)),
                           stylesheet),
                   Element('body',
                           {'bgcolor': white,
                            'text': black,
                            'link': green,
                            'vlink': darkgreen,
                            'alink': lime},
                           Element('center', {},
                                   Element('table',
                                           {'align': 'abscenter',
                                            'border': '1',
                                            'cellspacing': '0',
                                            'cellpadding': '3'},
                                           tr))))
    f = open("."+TST+".src.index.head.html","w")
    html.write(f, True)
    f.close()
### CreateSrcIndex (env, TST, EXT) #

def AddHref (href, target, linktext, diff) :
    if   diff == F_ERROR:
        klass = 'error'
    elif diff == F_KILL:
        klass = 'killed'
    elif diff == F_TIME:
        klass = 'timeout'
    elif diff == F_SOCK:
        klass = 'socket'
    elif diff == F_SEGV:
        klass = 'segfault'
    elif diff == F_WARN:
        klass = 'warning'
    else:
        klass = 'good'
    a = Element('a', {'href': href, 'target': target, 'class': klass},
                Text(linktext))
    if klass == 'good':
        return [Text('('), a, Text(')')]
    else:
        return [a]
### AddHref (TSTDIR, TST, WHAT, diff) #

def AddTstToHtmlIndex (env, TST, STABLEout, STABLEerr, EXT, SockTime) :
    TSTDIR = env['TSTDIR']

    CreateTstWhatXhtml(env, TST, STABLEout, EXT, F_OK)
    CreateTstWhatXhtml(env, TST, STABLEerr, EXT, SockTime)

    for l in open(TST+".out.diff.html"):
        pass
    if   l[:14] == '<!--NoDiffs-->':
        o = F_OK
    elif l[:17] == '<!--MinorDiffs-->':
        o = F_WARN
    elif l[:17] == '<!--MajorDiffs-->':
        o = F_ERROR
    else:
        Warn("Unexpected last line in %s:\n%s" % (TST+".out.diff.html",l))
        ff = open(TST+WHAT+".out.diff.html","a")
        ff.write("\n<!--MajorDiffs-->\n")
        ff.close()
        o = F_ERROR
    for l in open(TST+".err.diff.html"):
        pass
    if   l[:14] == '<!--NoDiffs-->':
        e = F_OK
    elif l[:17] == '<!--MinorDiffs-->':
        e = F_WARN
    elif l[:17] == '<!--MajorDiffs-->':
        e = F_ERROR
    else:
        Warn("Unexpected last line in %s:\n%s" % (TST+".err.diff.html",l))
        ff = open(TST+WHAT+".err.diff.html","a")
        ff.write("\n<!--MajorDiffs-->\n")
        ff.close()
        e = F_ERROR
    if e == F_ERROR and SockTime in (F_SOCK, F_TIME, F_KILL, F_SEGV):
        e = SockTime
    if o == F_ERROR or e == F_ERROR:
        tstclass = 'error'
    elif e == F_KILL:
        tstclass = 'killed'
    elif e == F_TIME:
        tstclass = 'timeout'
    elif e == F_SOCK:
        tstclass = 'socket'
    elif e == F_SEGV:
        tstclass = 'segfault'
    elif o == F_WARN or e == F_WARN:
        tstclass = 'warning'
    else:
        tstclass = 'good'

    td = Element('td', {'class': 'header'},
                 Element('a', {'href': '.%s.src.index.html' % TST,
                               'target': '%s_%s_body' % (DISTVER, TSTDIR),
                               'class': tstclass},
                         Text(TST)),
                 Element('br'))
    td.addchildren(AddHref('.%s%s.html' % (TST, '.out'),
                           '%s_%s_body' % (DISTVER, TSTDIR),
                           'out', o))
    td.addchild(Text("&nbsp;|&nbsp;", raw = True))
    td.addchildren(AddHref('.%s%s.html' % (TST, '.err'),
                           '%s_%s_body' % (DISTVER, TSTDIR),
                           'err', e))
    if not env.has_key('_'+TSTDIR+'_BODY_')  or  \
       not env['_'+TSTDIR+'_BODY_'][0]  or  \
       ( (not env['_'+TSTDIR+'_BODY_'][1])  and  (o or e) ):
        if e and not o:
            env['_'+TSTDIR+'_BODY_'] = ["."+TST+".err.html", e]
        else:
            env['_'+TSTDIR+'_BODY_'] = ["."+TST+".out.html", o]

    CreateSrcIndex(env, TST, EXT)

    return o, e, td
### AddTstToHtmlIndex (env, TST, STABLEout, STABLEerr, EXT) #

def AddSubToHtmlIndex (env, TSTDIR, diff) :
    TSTTRGBASE = env['TSTTRGBASE']
    TSTPREF = env['TSTPREF']

    td = Element('td', {'class': 'header'})
    td.addchildren(AddHref('%s/.index.html' % url(TSTDIR), '%s__body' % DISTVER,
                           TSTDIR, diff))
    if not env.has_key('__BODY_')  or  \
       not env['__BODY_'][0]  or  \
       ( (not env['__BODY_'][1])  and  diff ):
        env['__BODY_'] = [TSTDIR+"/.index.html", diff]
    return td
### AddSubToHtmlIndex (env, TSTDIR, diff) #

def SkipTest(env, TST, EXT, REASON) :
    TSTDIR = env['TSTDIR']
    TEXT = "Skipping test %s%s %s" % (TST, EXT, REASON)
    if not env['QUIET']:
        Warn(TEXT)
    else:
        STDOUT.write("-")
    f = open("."+TST+".SKIPPED","w")
    f.write("\n%s  Warning:  %s\n\n" % (THISFILE, TEXT))
    f.close()
    target = '%s_%s_body' % (DISTVER, TSTDIR)
    td = Element('td', {'class': 'header'},
                 Element('a', {'href': '.%s.src.index.html' % TST,
                               'target': target,
                               'class': 'black'},
                         Text(TST)),
                 Element('br'),
                 Element('a', {'href': '.%s.SKIPPED' % TST,
                               'target': target},
                         Text('(skipped)')))
    if not env.has_key('_'+TSTDIR+'_BODY_')  or  \
       not env['_'+TSTDIR+'_BODY_'][0]  or  \
       not env['_'+TSTDIR+'_BODY_'][1]:
        env['_'+TSTDIR+'_BODY_'] = ["."+TST+".SKIPPED", F_SKIP]
    CreateSrcIndex(env, TST, EXT)
    return td
### SkipTest(env, TST, EXT, REASON) #

def find_test_dirs(thisdir) :
    testdirs = []
    thisdir = os.path.realpath(thisdir)
    dirnme = os.path.basename(thisdir)
    dirlst = os.listdir(thisdir)
    if dirnme == TSTSUFF  and  "All" in dirlst  and  os.path.isfile(os.path.join(thisdir,"All")):
        testdirs.append(os.path.dirname(thisdir))
    for d in dirlst:
        d = os.path.join(thisdir,d)
        if os.path.isdir(d):
            testdirs = testdirs + find_test_dirs(d)
    return testdirs
### find_test_dirs(thisdir) #

def PerformDir(env, testdir, testlist, BusyPorts) :
    td = 0
    elem = None
    FdOut = F_SKIP
    FdErr = F_SKIP
    TSTSRCBASE = env['TSTSRCBASE']
    TSTPREF = env['TSTPREF']
    if testdir == TSTSRCBASE:
        TSTDIR = os.curdir
    else:
        TSTDIR = testdir[len(TSTSRCBASE+os.sep):]
    TSTSRCDIR = os.path.normpath(os.path.join(testdir,TSTSUFF))
    TSTTRGDIR = os.path.normpath(os.path.join(env['TSTTRGBASE'],TSTPREF,TSTDIR))

    if THISFILE == "Mtest.py":
        TSTDB = TSTPREF+"_"+TSTDIR.replace(os.sep, '_')
    else: # THISFILE == "Mapprove.py"
        TSTDB = ""

    if testlist:
        tl = []
        for tst in testlist:
            tl.append((tst,None))
        testlist = tl
    else:
        for tc in open(os.path.join(TSTSRCDIR,"All")):
            tc = tc.strip()
            if tc  and  tc[0] != "#":
                if tc.find('?') > -1:
                    cond,tst = tc.split('?')
                else:
                    cond,tst = None,tc
                testlist.append((tst,cond))
    if not testlist:
        Warn("No tests found in '"+TSTSRCDIR+"`; skipping directory!")
        return td, elem

    env['TSTDB']     = TSTDB
    env['TSTDIR']    = TSTDIR
    env['TSTSRCDIR'] = TSTSRCDIR
    env['TSTTRGDIR'] = TSTTRGDIR
    env['RELSRCDIR'] = os.path.join(((os.pardir+os.sep)*(len(TSTDIR.split(os.sep))+1))+env['RELSRCBASE'],TSTDIR,TSTSUFF).replace(os.sep+os.sep,os.sep)
    os.environ['TSTDB']     = TSTDB
    os.environ['TSTDIR']    = TSTDIR
    os.environ['TSTSRCDIR'] = TSTSRCDIR
    os.environ['TSTTRGDIR'] = TSTTRGDIR
    os.environ['RELSRCDIR'] = env['RELSRCDIR']

    #STDERR.flush()
    #for v in 'RELSRCDIR':
    #       print v+" = "+str(env[v])
    #STDOUT.flush()

    if THISFILE == "Mtest.py":
        if env.has_key('GDK_DBFARM'):
            LogDBdir = os.path.join(env['GDK_DBFARM'],TSTDB)
            if LogDBdir and os.path.exists(LogDBdir):
                try:
                    shutil.rmtree(LogDBdir)
                except:
                    Warn("database '"+TSTDB+"` exists, but destroying it failed; skipping tests in '"+TSTSRCDIR+"`!")
                    #TODO:
                    # add "something" to HTML output
                    return td, elem
            if os.path.isabs(LogDBdir):
                try:
                    os.makedirs(LogDBdir)
                except:
                    Warn("creating database '"+TSTDB+" failed; skipping tests in '"+TSTSRCDIR+"`!")
                    #TODO:
                    # add "something" to HTML output
                    return td, elem
        if not os.path.exists(TSTTRGDIR):
            #TODO: set mode to umask
            os.makedirs(TSTTRGDIR)

        body = []
        oktests = []
        for TST,COND in testlist:
            os.environ['TST'] = TST
            tt, FtOut, FtErr, bodyline = RunTest(env, TST, BusyPorts, COND, oktests)
            if tt:
                t = "%7.3f" % tt
            else:
                t = '-.---'
            TIMES.append([TSTDIR,TST,t,tt,FtOut,FtErr])
            td = td + tt
            FdOut = max(FdOut,FtOut)
            FdErr = max(FdErr,FtErr)
            if bodyline is not None:
                body.append(bodyline)
            if FtOut == F_OK and FtErr == F_OK:
                oktests.append(TST)
        TIMES.append([TSTDIR,'',"%7.3f" % td,td,FdOut,FdErr])

        if THISFILE == "Mtest.py":
            CreateHtmlIndex(env, *body)
            elem = AddSubToHtmlIndex(env, TSTDIR, max(FdOut,FdErr))

        # HACK: remove large data-/input- files to save disk space
        for f in 'tcpip2.init.bat', 'ascii_io.4MBload', 'test100k', 'no.145.k100_unique1', 'test_00.k100_unique1', 'VOCrightpages.xml', 'VOCleftpages.xml':
            p = os.path.join(TSTTRGDIR,f)
            if os.path.isfile(p):
                os.remove(p)

    else: # THISFILE == "Mapprove.py"
        if not os.path.exists(TSTTRGDIR):
            Warn("Output directory '"+TSTTRGDIR+"` missing; skipping directory!")
            return td, elem

        for TST,COND in testlist:
            td = td + ApproveOutput(env, TST)

    return td, elem
### PerformDir(env, testdir, testlist, BusyPorts) #

def ApproveOutput (env, TST) :
    sem = 0
    TSTDB = env['TSTDB']
    TSTDIR  = env['TSTDIR']
    TSTSRCDIR = env['TSTSRCDIR']
    TSTTRGDIR = env['TSTTRGDIR']
    os.chdir(TSTSRCDIR)
    EXTENSIONS = par['EXTENSION']
    FORCE = par['FORCE']

#       filter = re.compile( "^!WARNING: TCPlisten\([0-9]*\): stopped.$"        "|"
#                            "^!WARNING: TCPepilogue: terminate [01] listeners$", re.MULTILINE)

    for WHAT in EXTENSIONS:
        testOUTPUT = os.path.join(TSTTRGDIR,TST+".test."+WHAT)
        TSTSRCDIRTST = os.path.join(TSTSRCDIR,TST)
        stableOUT  = TSTSRCDIRTST+".stable."+WHAT
        if par['SYSTEM']:
            SYSTEM = par['SYSTEM']
            stableOUTPUT = stableOUT+SYSTEM
        else:
            if WHAT == 'out':
                w = 0
            else: # WHAT == 'err'
                w = 1
            stableOUTPUT = TSTSRCDIRTST+StableOutErr(env,par,TSTSRCDIRTST,SYST,RELEASE,DIST,VERSION)[w]
            SYSTEM = stableOUTPUT.split(WHAT)[-1]

        if os.path.isfile(testOUTPUT):
#                       print "Approving "+testOUTPUT+" -> "+stableOUTPUT
            if os.path.isfile(stableOUTPUT):
                oc = 'overwriting old'
            else:
                oc = 'creating new'
                if os.path.isfile(stableOUT):
                    shutil.copy(stableOUT,stableOUTPUT)
                else:
                    open(stableOUTPUT,"w").close()

            for d in ('TMPDIR', 'TMP', 'TEMP'):
                if os.environ.has_key(d):
                    patch = os.environ[d]
                    break
            else:
                patch = os.path.join(os.sep, 'tmp')
            patch = os.path.join(patch, "%s.patch-%s" % (os.path.basename(stableOUTPUT), str(os.getpid())))
            os.system('diff -Bb "-I^[#=]" -U0 "%s" "%s" > "%s"' % (stableOUTPUT,testOUTPUT,patch+".0"))
            if os.path.getsize(patch+".0"):
                print "Approving  %s  ->  stable.%s%s   (%s file)" % (os.path.join(TSTDIR,TST+".test."+WHAT), WHAT, SYSTEM, oc)

                f = open(patch+".1", "w")
                for l in open(patch+".0"):
                    if len(l) < 2  or  \
                       ( l[:2] not in ['+!','+=']  and  l[:10] != '+ERROR = !'  and  \
                         l[:8] != '+ERROR: '  and  l[:10] != '+WARNING: ' ) :        # or  filter.match(ln):
                        f.write(l)
                    else:
                        if FORCE:
                            f.write(l)
                            sa = 'Approving'
                        else:
                            f.write(l[:1]+'\n')
                            sa = 'Skipping'
                        Warn('%s new (error) message: "%s"' % (sa,l.replace(os.linesep, '')))
                        sem = 1
                f.flush()
                f.close()
                shutil.copy(stableOUTPUT,stableOUTPUT+".ORG")
                os.system('patch "%s" "%s"' % (stableOUTPUT,patch+".1"))
                os.system('diff -u "%s" "%s" > "%s"' % (stableOUTPUT+".ORG",stableOUTPUT,patch))
                os.remove(stableOUTPUT+".ORG")
                os.remove(patch+".1")
            else:
                print "No differences detected between  %s and  stable.%s%s  that are not ignored by Mtest.py." % (os.path.join(TSTDIR,TST+".test."+WHAT), WHAT, SYSTEM)
            os.remove(patch+".0")

            thefile = os.path.split(stableOUTPUT)[1]
            dir,file = os.path.split(stableOUT)
            test = re.compile('^%s.*$' % re.escape(file))
            list = []
            for f in os.listdir(dir or os.curdir):
                if f != thefile and test.match(f):
                    list.append(f)
            if len(list) > 0:
                Warn('There are other (specific) stable outputs for test  %s:\n  %s' % (os.path.join(TSTDIR,'Tests',TST), str(list)))
                STDERR.write('  To propagate the changes that were just made in  %s\n' % os.path.join(TSTDIR,'Tests',thefile))
                STDERR.write('  to the other (specific) stable outputs,\n')
                STDERR.write('  simply apply the patch in  %s  to them.\n\n' % patch)
                STDERR.flush()
        else:
            i = TST.rfind('.')
            if i > 0:
                return ApproveOutput(env, TST[:i])
            Warn("Output file missing: '"+testOUTPUT+"`; skipping test!")
    return sem
### ApproveOutput (env, TST) #

# this function is a slightly modified copy of the posixpath version
# the differences are the doubling of \'s in the replacement value
# under a very specific condition: when the variable name starts with
# a Q and the variable name (with Q prefix) does not occur in the
# environment and the variable name minus the Q prefix does occur in
# the environment; and the addition of an extra parameter with default
# so that the environment which is used to expand can be replace.
_varprog = None
def expandvars(path, environ = os.environ):
    """Expand shell variables of form $var and ${var}.  Unknown variables
    are left unchanged."""
    global _varprog
    if '$' not in path:
        return path
    if not _varprog:
        import re
        _varprog = re.compile(r'\$(\w+|\{[^}]*\})')
    i = 0
    while True:
        m = _varprog.search(path, i)
        if not m:
            break
        i, j = m.span(0)
        name = m.group(1)
        if name.startswith('{') and name.endswith('}'):
            name = name[1:-1]
        if name in environ:
            tail = path[j:]
            val = environ[name]
            path = path[:i] + val
            i = len(path)
            path += tail
        elif name[:1] == 'Q' and name[1:] in environ:
            tail = path[j:]
            val = environ[name[1:]].replace('\\', '\\\\')
            path = path[:i] + val
            i = len(path)
            path += tail
        else:
            i = j
    return path

def GetBitsAndOIDsAndModsAndStatic(env) :
    rtrn = 0
    TSTPREF = env['TSTPREF']
    cmd = '%s --dbname=%s' % (env['exe']['Mserver'][1], TSTPREF)
    proc = subprocess.Popen(cmd, shell = True, stdin = subprocess.PIPE, stdout = subprocess.PIPE, stderr = subprocess.PIPE, universal_newlines = True)
    t = Timer(float(par['TIMEOUT']), killProc, args = [proc, proc.stderr, cmd])
    try:
        t.start()
        if par['M5']:
            input = '''\
                c := mdb.modules();
                mods := algebra.kunique(c);
                s := "\\nModules: ";
                sep := "";
                barrier (mloop:lng,h:int,t:str) := bat.newIterator(mods);
                        s := s + sep;
                        s := s + "\'";
                        s := s + t;
                        s := s + "\'";
                        sep := ",";
                redo (mloop:lng,h:int,t:str) := bat.hasMoreElements(mods);
                exit mloop;
                s := s + "\\n";
                io.printf(s);
                clients.quit();
            '''
        else:
            input = '''\
                help("kunion");
                {
                    # print a list of all modules found
                    # "Modules: mod1, mod2, ..."
                    var MODs := kunion(bat("monet_mod_nme").reverse().mark(oid(nil)),view_modules().reverse().mark(oid(nil))).kunique();
                    printf("\\nModules: ");
                    var x := "";
                    MODs@batloop(){
                        printf("%s\'%s\'",x,$h);
                        x:=",";
                    }
                    printf("\\n");
                }
                quit();
            '''
        ##module("NoModule");
        qOut, qErr = proc.communicate(input = input)
        t.cancel()
    except KeyboardInterrupt:
        t.cancel()
        killProc(proc, proc.stderr, cmd)
        raise
    env['TST_MODS'] = []
    env['TST_BITS'] = ""
    env['TST_OIDS'] = ""
    env['TST_FIVE'] = ""
    env['TST_STATIC'] = ""
    if qOut:
        tbs = re.compile("^# Compiled for .*/([63][42]bit) with ([63][42])bit OIDs;? (.*) linked", re.MULTILINE)
        tm = re.compile("^Modules: (.*)$", re.MULTILINE)
        #ts = re.compile("^!ERROR: DL_open: library not found \(STATIC\).$", re.MULTILINE)
        for l in qOut.split('\n'):
            bs = tbs.match(l)
            if bs:
                env['TST_BITS'] = bs.group(1)
                os.environ['TST_BITS'] = env['TST_BITS']
                env['TST_OIDS'] = "oid" + bs.group(2)
                os.environ['TST_OIDS'] = env['TST_OIDS']
                if bs.group(3) == "statically":
                    env['TST_STATIC'] = "STATIC"
                    os.environ['TST_STATIC'] = env['TST_STATIC']
            m = tm.match(l)
            if m:
                env['TST_MODS'] = eval(m.group(1))
            #s = ts.match(l)
            #if s:
            #       env['TST_STATIC'] = "1"
            #       os.environ['TST_STATIC'] = env['TST_STATIC']
        if not env['TST_BITS']:
            ErrMsg("Checking for Bits failed!")
        if not env['TST_OIDS']:
            ErrMsg("Checking for OIDs failed!")
        if not env['TST_MODS']:
            ErrMsg("Checking for Modules failed!")
        if not env['TST_BITS'] or not env['TST_OIDS'] or not env['TST_MODS']:
            STDERR.write(cmd + "\n\n")
            STDERR.write(qOut)
            STDERR.write("\n")
            STDERR.write(qErr)
            STDERR.write("\n")
            STDERR.flush()
            rtrn = 1
    else:
        rtrn = 1
        ErrMsg("No output from Mserver/mserver5 when checking for Bits, OIDs & Modules!?")
        if qErr:
            STDERR.write(cmd + "\n\n")
            STDERR.write(qErr)
            STDERR.write("\n")
            STDERR.flush()
    os.environ['TST_MODS'] = str(env['TST_MODS'])
    if par['M5']:
        env['TST_FIVE'] = "Five"
        os.environ['TST_FIVE'] = "Five"
    return rtrn
### GetBitsAndOIDsAndModsAndStatic(env) #

def CheckMods(env, TST, SERVER, CALL) :
    missing = []
    if os.path.isfile(TST+".modules"):
        for m in open(TST+".modules"):
            m = m.strip()
            if m  and  m[0] != "#"  and  m not in env['TST_MODS']:
                missing.append(m)
    if SERVER == "MIL":
        for m in "streams", "mapi":
            if m not in env['TST_MODS']:
                missing.append(m)
    if SERVER == "SQL":
        if par['M4']:
            sql_mods = ["sql_server", "streams", "ascii_io", "monettime", "alarm", "xtables", "aggrX3", "blob", "txtsim", "mmath", "mkey", "bat_arith", "pcre"]
        else:
            sql_mods = ["sql"]
        for m in sql_mods:
            if m not in env['TST_MODS']:
                missing.append(m)
    if SERVER == "XQUERY":
        for m in "pathfinder", "pf_support", "ascii_io", "alarm", "malalgebra", "aggrX3", "xtables", "mapi":
            if m not in env['TST_MODS']:
                missing.append(m)
    return missing
### CheckMods(env, TST, SERVER, CALL) #

def CheckBATs(env, TST, TSTDB) :
    missing = []

    if not os.path.isfile(TST+".BATs"):
        # no BATs required => no check required
        return missing

    if par['M5']:
        # Warn("MonetDB/5: Check, whether required BATs do exist, is not possible, yet!")
        return missing

    cmd = '%s --dbname=%s' % (env['exe']['Mserver'][1], TSTDB)
    proc = subprocess.Popen(cmd, shell = True, stdin = subprocess.PIPE, stdout = subprocess.PIPE, stderr = subprocess.PIPE, universal_newlines = True)
    t = Timer(float(par['TIMEOUT']), killProc, args = [proc, proc.stderr, cmd])
    try:
        t.start()
        qOut, qErr = proc.communicate('''\
            {
                # print a list of all persistent BATs
                # "BATs: bat1, bat2, ..."
                var BATs := view_bbp_name();
                printf("\\nBATs: ");
                var x := "";
                BATs@batloop(){
                    printf("%s\'%s\'",x,$t);
                    x:=",";
                }
                printf("\\n");
            }
            quit();
        ''')
        t.cancel()
    except KeyboardInterrupt:
        t.cancel()
        killProc(proc, proc.stderr, cmd)
        raise
    TST_BATS = []
    if qOut:
        tb = re.compile("^BATs: (.*)$", re.MULTILINE)
        for l in qOut.split('\n'):
            b = tb.match(l)
            if b:
                TST_BATS = eval(b.group(1))
    else:
        Warn("No output from Mserver when checking for Bats!?")
        if qErr:
            STDERR.write(cmd + "\n\n")
            STDERR.write(qErr)
            STDERR.write("\n")
            STDERR.flush()

    if os.path.isfile(TST+".BATs"):
        for b in open(TST+".BATs"):
            b = b.strip()
            if b  and  b[0] != "#"  and  b not in TST_BATS:
                missing.append(b)
    return missing
### CheckBATs(env, TST, TSTDB) #

def CheckTests(env, TST, oktests):
    missing = []
    if not os.path.isfile(TST+'.reqtests'):
        # no required tests, so none missing
        return missing

    for test in open(TST+'.reqtests'):
        test = test.strip()
        if not test or test[:1] == '#':
            continue
        if not test in oktests:
            missing.append(test)
    return missing
### CheckTests(env, TST, oktests) #

def StartAt(cmd) :
    proc = subprocess.Popen(cmd, shell = True, stdin = subprocess.PIPE, stdout = subprocess.PIPE, stderr = subprocess.PIPE, universal_newlines = True)
    qOut, qErr = proc.communicate()
    return qOut.split('\n', 1)[0].strip()
### StartAt(cmd) #

def StopAt(ATJOB,ME) :
    while  os.path.isfile(path("/tmp/.MkillUsers."+ME)):
        time.sleep(9)
    if SYST == "IRIX" or SYST == "IRIX64" or SYSTVER[:-1] == "SunOS5.1" or SYST == "Darwin":
        ATRM = 'at -r '
    elif SYST == "SunOS":
        ATRM = 'atrm -f '
    else:
        ATRM = 'atrm '
    os.system(ATRM+ATJOB)
    #TODO:
    #LOG1x at -l >&2
### StopAt(ATJOB,ME) #

def StableOutErr(env,par,TST,SYST,RELEASE,DIST,VERSION) :
    BITS = env['TST_BITS']
    OIDS = env['TST_OIDS']
    FIVE = env['TST_FIVE']
    STATIC = env['TST_STATIC']
    ALGEBRA = env['TST_ALGEBRA']
    NOALGEBRA = env['TST_NOALGEBRA']
    if FIVE:
        FIVE = "(\.Five)?"
    if STATIC:
        STATIC = "(\.STATIC)?"
    if ALGEBRA:
        ALGEBRA = "(\.Algebra)?"
    dir,file = os.path.split(TST)
    outre = re.compile('^'+re.escape(file)+'\.stable\.(?P<tp>out|err)(\.(%s(%s)?|%s(%s)?))?(\.%s)?(\.%s)?%s%s%s$' % (re.escape(SYST), re.escape(RELEASE), re.escape(DIST), re.escape(VERSION), BITS, OIDS, FIVE, STATIC, ALGEBRA))
    bestout = besterr = ''
    for f in os.listdir(dir or os.curdir):
        res = outre.match(f)
        if res is not None:
            if res.group('tp') == 'out':
                if len(bestout) < len(f):
                    bestout = f
            else:                   # res.group('tp') == 'err'
                if len(besterr) < len(f):
                    besterr = f
    if bestout:
        STABLEout = os.path.join(dir, bestout)[len(TST):]
    else:
        STABLEout = '.stable.out'
    if besterr:
        STABLEerr = os.path.join(dir, besterr)[len(TST):]
    else:
        STABLEerr = '.stable.err'
    return STABLEout, STABLEerr
### StableOutErr(env,par,TST,SYST,RELEASE,DIST,VERSION) #

def RunTest(env, TST, BusyPorts, COND, oktests) :
    Failed = F_SKIP
    FailedOut = F_SKIP
    FailedErr = F_SKIP
    TSTDB = env['TSTDB']
    TSTDIR  = env['TSTDIR']
    TSTSRCDIR = env['TSTSRCDIR']
    RELSRCDIR = env['RELSRCDIR']
    TSTTRGDIR = env['TSTTRGDIR']
    TSTTRGBASE = env['TSTTRGBASE']
    os.chdir(TSTSRCDIR)
    elem = None

    quiet = env['QUIET']

    TX = 0
    EXT = CALL = SERVER = ""
    x  = isexecutable(TST)
    if not x[0]:
        x  = isexecutable(TST,'')
    xI = isexecutable(TST+".MIL")
    xA = isexecutable(TST+".MAL")
    xS = isexecutable(TST+".SQL")
    xQ = isexecutable(TST+".XQUERY")
    if   x[0]:
        EXT = x[1]          ; CALL = "other"
    elif xI[0]:
        EXT = ".MIL"+xI[1]  ; CALL = "other"  ; SERVER = "MIL"
    elif xA[0]:
        EXT = ".MAL"+xA[1]  ; CALL = "other"  ; SERVER = "MAL"
    elif xS[0]:
        EXT = ".SQL"+xS[1]  ; CALL = "other"  ; SERVER = "SQL"
    elif xQ[0]:
        EXT = ".XQUERY"+xQ[1] ; CALL = "other" ; SERVER = "XQUERY"
    elif os.path.isfile(TST+".py")            or  os.path.isfile(TST+".py.src"):
        EXT = ".py"         ; CALL = "python"
    elif os.path.isfile(TST+".MIL"+".py")     or  os.path.isfile(TST+".MIL"+".py.src")     or  os.path.isfile(TST+".MIL"+".py.in"):
        EXT = ".MIL.py"     ; CALL = "python" ; SERVER = "MIL"
    elif os.path.isfile(TST+".MAL"+".py")     or  os.path.isfile(TST+".MAL"+".py.src")     or  os.path.isfile(TST+".MAL"+".py.in"):
        EXT = ".MAL.py"     ; CALL = "python" ; SERVER = "MAL"
    elif os.path.isfile(TST+".SQL"+".py")     or  os.path.isfile(TST+".SQL"+".py.src")     or  os.path.isfile(TST+".SQL"+".py.in"):
        EXT = ".SQL.py"     ; CALL = "python" ; SERVER = "SQL"
    elif os.path.isfile(TST+".XQUERY"+".py")  or  os.path.isfile(TST+".XQUERY"+".py.src")  or  os.path.isfile(TST+".XQUERY"+".py.in"):
        EXT = ".XQUERY.py"  ; CALL = "python" ; SERVER = "XQUERY"
    elif os.path.isfile(TST+".milS")          or  os.path.isfile(TST+".milS.src")          or  os.path.isfile(TST+".milS.in"):
        EXT = ".milS"       ; CALL = "milS"
    elif os.path.isfile(TST+".milC")          or  os.path.isfile(TST+".milC.src")          or  os.path.isfile(TST+".milC.in"):
        EXT = ".milC"       ; CALL = "milC"   ; SERVER = "MIL"
    elif os.path.isfile(TST+"_s00.milS")      or  os.path.isfile(TST+"_s00.milS.src")      or  os.path.isfile(TST+"_s00.milS.in"):
        EXT = ".milS"       ; CALL = "milSXs"
    elif os.path.isfile(TST+"_s00.milC")      or  os.path.isfile(TST+"_s00.milC.src")      or  os.path.isfile(TST+"_s00.milC.in"):
        EXT = ".milC"       ; CALL = "milCXs" ; SERVER = "MIL"
    elif os.path.isfile(TST+"_p00.milC")      or  os.path.isfile(TST+"_p00.milC.src")      or  os.path.isfile(TST+"_p00.milC.in"):
        EXT = ".milC"       ; CALL = "milCXp" ; SERVER = "MIL"
    elif os.path.isfile(TST+".mal")           or  os.path.isfile(TST+".mal.src")           or  os.path.isfile(TST+".mal.in"):
        EXT = ".mal"        ; CALL = "mal"
    elif os.path.isfile(TST+"_s00.mal")       or  os.path.isfile(TST+"_s00.mal.src")       or  os.path.isfile(TST+"_s00.mal.in"):
        EXT = ".mal"        ; CALL = "malXs"
    elif os.path.isfile(TST+".malC")          or  os.path.isfile(TST+".malC.src")          or  os.path.isfile(TST+".malC.in"):
        EXT = ".malC"       ; CALL = "malC"   ; SERVER = "MAL"
    elif os.path.isfile(TST+"_s00.malC")      or  os.path.isfile(TST+"_s00.malC.src")      or  os.path.isfile(TST+"_s00.malC.in"):
        EXT = ".malC"       ; CALL = "malCXs" ; SERVER = "MAL"
    elif os.path.isfile(TST+"_p00.malC")      or  os.path.isfile(TST+"_p00.malC.src")      or  os.path.isfile(TST+"_p00.malC.in"):
        EXT = ".malC"       ; CALL = "malCXp" ; SERVER = "MAL"
    elif os.path.isfile(TST+".sql")           or  os.path.isfile(TST+".sql.src")           or  os.path.isfile(TST+".sql.in"):
        EXT = ".sql"        ; CALL = "sql"    ; SERVER = "SQL"
    elif os.path.isfile(TST+"_s00.sql")       or  os.path.isfile(TST+"_s00.sql.src")       or  os.path.isfile(TST+"_s00.sql.in"):
        EXT = ".sql"        ; CALL = "sqlXs"  ; SERVER = "SQL"
    elif os.path.isfile(TST+"_p00.sql")       or  os.path.isfile(TST+"_p00.sql.src")       or  os.path.isfile(TST+"_p00.sql.in"):
        EXT = ".sql"        ; CALL = "sqlXp"  ; SERVER = "SQL"
    elif os.path.isfile(TST+".xq")            or  os.path.isfile(TST+".xq.src")            or  os.path.isfile(TST+".xq.in"):
        EXT = ".xq"         ; CALL = "xq"     ; SERVER = "XQUERY"
    elif os.path.isfile(TST+"_s00.xq")        or  os.path.isfile(TST+"_s00.xq.src")        or  os.path.isfile(TST+"_s00.xq.in"):
        EXT = ".xq"         ; CALL = "xqXs"   ; SERVER = "XQUERY"
    elif os.path.isfile(TST+"_p00.xq")        or  os.path.isfile(TST+"_p00.xq.src")        or  os.path.isfile(TST+"_p00.xq.in"):
        EXT = ".xq"         ; CALL = "xqXp"   ; SERVER = "XQUERY"
        #TODO:
        #elif [ -f "$TST.java"       ] ; then  EXT="java" ; CALL="Java   "+TST+" "+EXT
        #elif [ -f "${TST}_s00.java" ] ; then  EXT="java" ; CALL="JavaXs "+TST+" "+EXT
        #elif [ -f "${TST}_p00.java" ] ; then  EXT="java" ; CALL="JavaXp "+TST+" "+EXT
        #elif [ -f "$TST.odmg"       ] ; then  EXT="odmg" ; CALL="odmg   "+TST+" "+EXT
    else:
        i = TST.rfind('.')
        if i > 0:
            return RunTest(env, TST[:i], BusyPorts, COND, oktests)
        EXT = CALL = SERVER = ""
        if   COND and not CONDITIONALS.has_key(COND):
            elem = SkipTest(env, TST, EXT, "as conditional '%s' is unknown." % COND)
        elif COND and not CONDITIONALS[COND]:
            elem = SkipTest(env, TST, EXT, "as conditional '%s' does not hold." % COND)
        elif os.name == "nt":
            ErrMsg("test missing: '"+os.path.join(TSTSRCDIR,TST)+".(exe|com|bat|cmd|py|mal|malC|milS|milC|sql|xq)`")
            #TODO:
            #elif os.name == "posix":
        else:
            ErrMsg("test missing: '"+os.path.join(TSTSRCDIR,TST)+"[.py|.mal|.malC|.milS|.milC|.sql|.xq]`")
        return TX,Failed,Failed,elem

    if par['PACKAGE'] not in ('monetdb', 'monetdb-java', 'monetdb-clients'):
        MissingMods = CheckMods(env, TST, SERVER, CALL)
        MissingBATs = CheckBATs(env, TST, TSTDB)
    else:
        MissingMods = []
        MissingBATs = []
    MissingTests = CheckTests(env, TST, oktests)

    os.chdir(TSTTRGDIR)

    if   COND and not CONDITIONALS.has_key(COND):
        elem = SkipTest(env, TST, EXT, "as conditional '%s' is unknown." % COND)
    elif COND and not CONDITIONALS[COND]:
        elem = SkipTest(env, TST, EXT, "as conditional '%s' does not hold." % COND)
    elif MissingTests:
        elem = SkipTest(env, TST, EXT, "as required test%s '%s' failed." % (len(MissingTests) != 1 and 's' or '', "', '".join(MissingTests)))
    elif ( EXT[:4] == ".mil" or SERVER == "MIL" ) and par['M5']:
        elem = SkipTest(env, TST, EXT, "as MonetDB v5 does not support MIL.")
    elif ( EXT[:4] == ".mal" or SERVER == "MAL" ) and par['M4']:
        elem = SkipTest(env, TST, EXT, "as MonetDB v4 does not support MAL.")
    elif EXT == ".milC" and  not env['exe']['MIL_Client'][0]:
        elem = SkipTest(env, TST, EXT, "as "+env['MILCLIENT'].split(None, 1)[0]+" is not available.")
    elif EXT == ".malC" and  not env['exe']['MAL_Client'][0]:
        elem = SkipTest(env, TST, EXT, "as "+env['MALCLIENT'].split(None, 1)[0]+" is not available.")
    elif EXT == ".sql" and  not env['exe']['SQL_Client'][0]:
        elem = SkipTest(env, TST, EXT, "as "+env['SQLCLIENT'].split(None, 1)[0]+" is not available.")
    elif EXT == ".sql" and  not env['exe']['SQL_Dump'][0]:
        elem = SkipTest(env, TST, EXT, "as "+env['SQLDUMP'].split(None, 1)[0]+" is not available.")
    elif EXT == ".xq" and  not env['exe']['XQuery_Client'][0]:
        elem = SkipTest(env, TST, EXT, "as "+env['XQUERYCLIENT'].split(None, 1)[0]+" is not available.")
    elif SERVER in ["MIL", "MAL", "SQL", "XQUERY"] and not env['exe']['Mserver'][0]:
        elem = SkipTest(env, TST, EXT, "as "+env['MSERVER'].split(None, 1)[0]+" is not available.")
    elif CALL == "python"  and  not env['exe']['python'][0]:
        elem = SkipTest(env, TST, EXT, "as python is not available.")
        #TODO:
        #elif EXT == ".milC":
        #elem = SkipTest(env, TST, EXT, "as mclient-tests are temporary not supported by "+THISFILE+".")
        #TODO:
        #elif [ "$EXT" = "java"  -a  ! "`type -path java`" ] ; then
        #elem = SkipTest(env, TST, EXT, "as java is not in $PATH.")
    elif MissingMods:
        elem = SkipTest(env, TST, EXT, "as modules '"+str(MissingMods)+"` are missing.")
    elif MissingBATs:
        elem = SkipTest(env, TST, EXT, "as BATs '"+str(MissingBATs)+"` are missing in database '"+TSTDB+"`.")
    elif CALL == "milCXp":
        elem = SkipTest(env, TST, EXT, "as multiple MIL clients in parallel are currently not supported by "+THISFILE+".")
    elif CALL == "malCXp":
        elem = SkipTest(env, TST, EXT, "as multiple MAL clients in parallel are currently not supported by "+THISFILE+".")
    elif CALL == "sqlXp":
        elem = SkipTest(env, TST, EXT, "as multiple SQL clients in parallel are currently not supported by "+THISFILE+".")
    elif CALL == "xqXp":
        elem = SkipTest(env, TST, EXT, "as multiple XQuery clients in parallel are currently not supported by "+THISFILE+".")
    elif SERVER in ["MIL", "MAL", "SQL", "XQUERY"] and "MAPI" in BusyPorts:
        elem = SkipTest(env, TST, EXT, "as MAPIPORT=%s is not available." % (env['MAPIPORT']))
    elif SERVER == "XQUERY" and "XRPC" in BusyPorts:
        elem = SkipTest(env, TST, EXT, "as XRPCPORT=%s is not available." % (env['XRPCPORT']))
    else:
        test = re.compile("^"+TST+"((_[sp][0-9][0-9])?\..*)?$", re.MULTILINE)
        for f in os.listdir(RELSRCDIR):
            if test.match(f):
                SymlinkOrCopy(os.path.join(RELSRCDIR,f),os.path.join(TSTTRGDIR,f))

        # Check for available sockets and block them until we're ready to run the actual test
        MAPIsockets, reason = CheckSocket2(env, "MAPI")   #, SrvrErr)
        XRPCsockets = None
        if MAPIsockets is not None:
            XRPCsockets, reason = CheckSocket2(env, "XRPC")   #, SrvrErr)
        if None in (MAPIsockets, XRPCsockets):
            elem = SkipTest(env, TST, EXT, "as "+reason)
            return TX,Failed,Failed,elem

        if os.path.isfile(TST+EXT+".src")  and not os.path.isfile(TST+EXT):
            f = open(TST+EXT+".src","r")
            TSTSRC = expandvars(path(f.readline().strip()), env)
            f.close()
            if os.path.isfile(TSTSRC):
                SymlinkOrCopy(TSTSRC,TST+EXT)
            else:
                elem = SkipTest(env, TST, EXT+".src", "as source file '"+TSTSRC+"` is missing.")
                # Release reserved sockets before bailing out
                MAPIsockets[0].close()
                MAPIsockets[1].close()
                XRPCsockets[0].close()
                XRPCsockets[1].close()
                return TX,Failed,Failed,elem
        test = re.compile("^"+TST+"((_[sp][0-9][0-9])?\..*)?\.src$", re.MULTILINE)
        for ff in os.listdir(TSTTRGDIR):
            if test.match(ff) and not os.path.isfile(ff[:-4]):
                f = open(ff,"r")
                TSTSRC = expandvars(path(f.readline().strip()), env)
                f.close()
                if os.path.isfile(TSTSRC):
                    SymlinkOrCopy(TSTSRC,ff[:-4])
                else:
                    Warn("source file '"+TSTSRC+"` is missing.")
        test = re.compile("^"+TST+"(_[sp][0-9][0-9])?\..*\.in$", re.MULTILINE)
        for ff in os.listdir(TSTTRGDIR):
            fff = ff[:-3]
            if test.match(ff) and not os.path.isfile(fff):
                f = open(fff,"w")
                for l in open(ff):
                    f.write(expandvars(l, env))
                f.close()

        ACCURACYout = par['ACCURACY']
        ACCURACYerr = par['ACCURACY']
        STABLEout,STABLEerr = StableOutErr(env,par,TST,SYST,RELEASE,DIST,VERSION)
        if not os.path.isfile(TST+STABLEout):
            open(TST+STABLEout,"w").close()
            ACCURACYout = 0
        if not os.path.isfile(TST+STABLEerr):
            open(TST+STABLEerr,"w").close()
            ACCURACYerr = 0

        PRELUDE = ""
        #if EXT not in  ['.milC','.sql','.xq']:
        if EXT not in  ['.sql','.xq']:
            if os.path.isfile(TST+".prelude")  and  par['M4']:
                PRELUDE = TST+".prelude"
            if os.path.isfile(TST+".prelude5")  and  par['M5']:
                PRELUDE = TST+".prelude5"

        TIMEOUTED = "Mtimeout"
        for v in env['exe'].keys():
            TIMEOUTED = TIMEOUTED+"|"+v.upper()
        test = re.compile("^[^#]*("+TIMEOUTED+")[^#]*(# ([0-9]+)x|#.*)?$", re.MULTILINE)
        TIMEOUT = par['TIMEOUT']
        if os.path.isfile(TST+".timeout"):
            for f in open(TST+".timeout"):
                TOf = float(f.strip())
                if TOf > 0:
                    TIMEOUT = int(TIMEOUT * TOf)
                if TIMEOUT < 1 and par['TIMEOUT'] > 0:
                    TIMEOUT = 1
        if env['exe']['Mtimeout'][0]:
            env['exe']['Mtimeout'] = env['exe']['Mtimeout'][0], 'Mtimeout -timeout %s ' % str(TIMEOUT)
            SetExecEnv(env['exe'],0)
        CTIMEOUT = 0
        if   CALL in ["other", "python"]:
            if TIMEOUT > 0:
                CTIMEOUT = CTIMEOUT + min(TIMEOUT, par['TIMEOUT'])
            for l in open(TST+EXT):
                TOm = test.match(l)
                if TOm:
                    TOx = TOm.group(3)
                    if TOx and (int(TOx) > 1):
                        TOx = int(TOx)
                    else:
                        TOx = 1
                    CTIMEOUT = CTIMEOUT + ( TOx * TIMEOUT )
        elif CALL in ["malXs", "milSXs", "milCXs", "sqlXs", "xqXs"]:
            test = re.compile("^"+TST+"_s[0-9][0-9]"+EXT+"$", re.MULTILINE)
            d = os.listdir(os.getcwd())
            for f in d:
                if test.match(f):
                    CTIMEOUT = CTIMEOUT + TIMEOUT
        elif CALL in ["mal", "malC", "milS", "milC", "sql", "xq"]:
            CTIMEOUT = CTIMEOUT + TIMEOUT
        if  CTIMEOUT < TIMEOUT:
            CTIMEOUT = TIMEOUT
        STIMEOUT = CTIMEOUT
        if  SERVER in ["MIL", "MAL", "SQL", "XQUERY"] and TIMEOUT > 0:
            STIMEOUT = STIMEOUT + TIMEOUT + min(TIMEOUT, par['TIMEOUT'])

        ME = ""
        ATJOB1 = ""
        MkillUsers = ""
        MkillUsersAT = ""
        if TIMEOUT and os.name != "nt" and sys.platform != 'cygwin' and env.get('USE_AT'):
            for f in TST+".KILLED.out", TST+".KILLED.err":
                if os.path.isfile(f):
                    os.remove(f)
            ME = str(os.getpid())
            WAIT = str(int(STIMEOUT / 60) + 2)
            FILES = os.path.join(TSTTRGDIR,TST)+" "+os.path.join(TSTTRGDIR,TST)+".*"
            for f in ["bat/\\*", '.gdk_lock']:
                FILES = FILES+" "+os.path.join(env['GDK_DBFARM'],TSTDB,path(f))
            WHAT0 = os.path.join(THISPATH,"MkillUsers")
            if env.get('CONCURRENT'):
                 WHAT0 = WHAT0+" --concurrent"
            WHAT0 = WHAT0+" -l"+ME
            WHAT1 = FILES+r" \>\>"+os.path.join(TSTTRGDIR,TST+".KILLED.out")+r" 2\>\>"+os.path.join(TSTTRGDIR,TST+".KILLED.err")
            WHAT = WHAT0+" -p"+ME+" "+WHAT1
            WHEN = "now + "+WAIT+" minutes"
            cmd  = "echo  "+WHAT+"  2>/dev/null | at "+WHEN+" 2>&1 | awk '/^[Jj]ob/{print $2}'"
            ATJOB1 = StartAt(cmd)
            #TODO:
            #LOG1x at -l >&2
            MkillUsers = (WHAT0+" "+WHAT1).replace('\\','')
            MkillUsersAT = "echo  "+WHAT+"  2>/dev/null | at now + 1 minute 2>&1 | awk '/^[Jj]ob/{print $2}'"

        #if THISFILE == "Mtest.py":
        TestOutFile = TST+".test.out"
        TestErrFile = TST+".test.err"
        TestOut = open(TestOutFile,"w")
        TestErr = open(TestErrFile,"w")
        TestOut.write("stdout of test '"+TST+"` in directory '"+url(TSTDIR)+"` itself:\n\n")
        TestErr.write("stderr of test '"+TST+"` in directory '"+url(TSTDIR)+"` itself:\n\n")
        TestOut.close()
        TestErr.close()

        t0 = time.time()
        tres = DoIt(env, SERVER, CALL, TST, EXT, PRELUDE, TestOutFile, TestErrFile, STIMEOUT, CTIMEOUT, TIMEOUT, MkillUsersAT, ME, MAPIsockets, XRPCsockets)

        t1 = time.time()
        TX = t1 - t0
        if not quiet:
            STDOUT.write(" %7.3fs " % TX)

        timeout = F_OK
        killed = F_OK
        segfaulted = F_OK

        if tres == 'timeout':
            timeout = F_TIME
        elif tres == 'segfault':
            segfaulted = F_SEGV

        if ATJOB1:
            StopAt(ATJOB1,ME)
            os.system(WHAT.replace('\\', '').replace(" -p"+ME+" ", ' '))
        else:
            while os.path.exists(os.path.join(TSTTRGBASE,".KILLED.lck")):
                time.sleep(1)

        if MkillUsers:
            os.system(MkillUsers)

        n = TST+".KILLED."
        for (x,txf) in [("out",TestOutFile),("err",TestErrFile)]:
            f = n+x
            if os.name == "nt":
                for t in os.path.join(TSTTRGBASE,f), os.path.join(TSTTRGBASE,".KILLED."+x):
                    if os.path.isfile(t):
                        shutil.copy(t,f)
                        os.remove(t)
                        break
            if os.path.isfile(f) and os.path.getsize(f):
                p = try_open(txf, 'a')
                if p is not None:
                    for l in open(f):
                        p.write("! "+l)
                        killed = F_KILL
                    p.close()

        sockerr = F_OK
        sockerr = max(sockerr, CheckSocket3(env, "MAPI", TestErrFile))
        sockerr = max(sockerr, CheckSocket3(env, "XRPC", TestErrFile))

        #TODO:
        ##if [ ! -f $TSTTRGBASE/Tests/.old.left-over.tmp.bats. ] ; then  touch $TSTTRGBASE/Tests/.old.left-over.tmp.bats. ; fi
        ##LEFTOVERTMPBATS="`find $MONETDBFARM/dbfarm/*/bat/ -name tmp_\* -print 2> /dev/null`"
        ##if [ "$LEFTOVERTMPBATS" ] ; then
        ##      ls -alF $LEFTOVERTMPBATS 2> /dev/null > .all.left-over.tmp.bats.
        ##      diff -u0 $TSTTRGBASE/Tests/.old.left-over.tmp.bats. .all.left-over.tmp.bats. | grep '^\+[^\+]' > .new.left-over.tmp.bats.
        ##fi
        ##if [ -s .new.left-over.tmp.bats. ] ; then
        ##      echo -e "\n!ERROR: persistent temporary bats remained:" >> $LOGFILE.err
        ##      sed 's|^\+|! |g' .new.left-over.tmp.bats.               >> $LOGFILE.err
        ##      echo                                                    >> $LOGFILE.err
        ##fi
        ##rm -f .new.left-over.tmp.bats. $TSTTRGBASE/Tests/.old.left-over.tmp.bats.
        ##if [ -f .all.left-over.tmp.bats. ] ; then  mv -f .all.left-over.tmp.bats. $TSTTRGBASE/Tests/.old.left-over.tmp.bats. ; fi

        if timeout == F_TIME:
            if quiet:
                STDOUT.write("\n%s : Timeout!\n" % TST)
            else:
                STDOUT.write("(Timeout!) ")

        if killed == F_KILL:
            if quiet:
                STDOUT.write("\n%s : Killed!\n" % TST)
            else:
                STDOUT.write("(Killed!) ")

        if segfaulted == F_SEGV:
            if quiet:
                STDOUT.write("\n%s : Crashed!\n" % TST)
            else:
                STDOUT.write("(Crashed!) ")

        if not quiet:
            STDOUT.write("\n")

        try:
            STDOUT.flush()
        except IOError, (IOerrNo, IOerrStr):
            Warn("Flushing STDOUT in RunTest failed with #%d: '%s'." % (IOerrNo, IOerrStr))

        if env['exe']['Mtimeout'][0]:
            env['exe']['Mtimeout'] = env['exe']['Mtimeout'][0], 'Mtimeout -timeout %s ' % str(par['TIMEOUT'])
            SetExecEnv(env['exe'],0)

        if THISFILE == "Mtest.py":
            try:
                Mfilter.mFilter(TST+STABLEout,par['IGNORE'])
                Mfilter.mFilter(TST+STABLEerr,par['IGNORE'])
                Mfilter.mFilter(TST+".test.out",par['IGNORE'])
                Mfilter.mFilter(TST+".test.err",par['IGNORE'])
            except:
                Warn("mFilter failed\n")
                pass

            testO = re.compile("^/"+TST+STABLEout+"/([^/]*)/", re.MULTILINE)
            testE = re.compile("^/"+TST+STABLEerr+"/([^/]*)/", re.MULTILINE)
            REVo="?"
            REVe="?"
            entries = os.path.join(TSTSRCDIR,"CVS","Entries")
            if os.path.isfile(entries):
                for l in open(entries):
                    mO = testO.match(l)
                    if mO:
                        REVo=mO.group(1)
                    mE = testE.match(l)
                    if mE:
                        REVe=mE.group(1)
            REVo=" (r"+REVo+")"
            REVe=" (r"+REVe+")"

            MDIFF0 = env['exe']['Mdiff'][1]
            MDIFF1 = MDIFF0+' -d'

            #TODO:
            #timedout = 1
            #while timedout and ACCURACY >= 0:
            #       timedout = 0
            #       signal.alarm(par['TIMEOUT'])
            #       try:
            #               os.system(MDIFF+' -I"'+par['IGNORE']+'" -C'+par['CONTEXT']+' -A'+str(ACCURACY)+' -r"'+REVo+'" '+TST+STABLEout+'.FILTERED '+TST+'.test.out.FILTERED '+TST+'.out.diff.html')
            #       except TimeoutError, t:
            #               timedout = 1
            #       signal.alarm(0)
            #       ACCURACY = ACCURACY - 1
            MDIFF = MDIFF1
            diff_html = open('%s.out.diff.html' % TST,"w")
            diff_html.write('<!--MajorDiffs-->\n')
            diff_html.close()
            timedout = 1
            if timeout == F_TIME or killed == F_KILL or segfaulted == F_SEGV:
                # test run timed out or orphan processes were killed => expect major differences!
                ACCURACYout = -1
            else:
                fs = open("%s%s.FILTERED" % (TST, STABLEout))
                ft = open("%s.test.out.FILTERED" % TST)
                szs = os.fstat(fs.fileno())[6]
                szt = os.fstat(ft.fileno())[6]
                fs.close()
                ft.close()
                if szt < szs*0.5 or szt > szs*1.5:
                    # filesizes differ significantly => expect major differences!
                    ACCURACYout = -1
            while timedout and MDIFF == MDIFF1:
                cmd = ['Mdiff']
                if ACCURACYout == -1:
                    MDIFF = MDIFF0
                    ACCURACYout = 0
                else:
                    cmd.append('-d')
                if quiet:
                    cmd.append('-q')
                proc = subprocess.Popen(cmd + ['-I%s' % par['IGNORE'], '-C%s' % par['CONTEXT'], '-A%d' % ACCURACYout, '-r%s' % REVe, '%s%s.FILTERED' % (TST, STABLEout), '%s.test.out.FILTERED' % TST, '%s.out.diff.html' % TST])
                proc.killed = False
                t = Timer(float(par['TIMEOUT']), killProc, args = [proc])
                try:
                    t.start()
                    proc.wait()
                    t.cancel()
                except KeyboardInterrupt:
                    t.cancel()
                    killProc(proc)
                    raise
                timedout = proc.killed
                ACCURACYout = ACCURACYout - 1
            if env.get('ECHO_DIFF'):
                cmd = 'diff'
                if ACCURACYout >= 0:
                    cmd += ' -d'
                os.system('%s -Bb -I"%s" -U%s "%s%s.FILTERED" "%s.test.out.FILTERED"' % (cmd, par['IGNORE'], par['CONTEXT'], TST, STABLEout, TST))

            #TODO:
            #timedout = 1
            #while timedout and ACCURACY >= 0:
            #       timedout = 0
            #       signal.alarm(par['TIMEOUT'])
            #       try:
            #               os.system(MDIFF+' -I"'+par['IGNORE']+'" -C'+par['CONTEXT']+' -A'+str(ACCURACY)+' -r"'+REVe+'" '+TST+STABLEerr+'.FILTERED '+TST+'.test.err.FILTERED '+TST+'.err.diff.html')
            #       except TimeoutError, t:
            #               timedout = 1
            #       signal.alarm(0)
            #       ACCURACY = ACCURACY - 1
            MDIFF = MDIFF1
            diff_html = open('%s.err.diff.html' % TST,"w")
            diff_html.write('<!--MajorDiffs-->\n')
            diff_html.close()
            timedout = 1
            if timeout == F_TIME or killed == F_KILL or segfaulted == F_SEGV:
                # test run timed out or orphan processes were killed => expect major differences!
                ACCURACYerr = -1
            else:
                fs = open("%s%s.FILTERED" % (TST, STABLEerr))
                ft = open("%s.test.err.FILTERED" % TST)
                szs = os.fstat(fs.fileno())[6]
                szt = os.fstat(ft.fileno())[6]
                fs.close()
                ft.close()
                if szt < szs*0.5 or szt > szs*1.5:
                    # filesizes differ significantly => expect major differences!
                    ACCURACYerr = -1
            while timedout and MDIFF == MDIFF1:
                if ACCURACYerr == -1:
                    MDIFF = MDIFF0
                    ACCURACYerr = 0
                if not quiet:
                    timedout = os.system('%s -I"%s" -C%s -A%d -r"%s" "%s%s.FILTERED" "%s.test.err.FILTERED" "%s.err.diff.html"' % (MDIFF, par['IGNORE'], par['CONTEXT'], ACCURACYerr, REVe, TST, STABLEerr, TST, TST))
                else:
                    timedout = os.system('%s -q -I"%s" -C%s -A%d -r"%s" "%s%s.FILTERED" "%s.test.err.FILTERED" "%s.err.diff.html"' % (MDIFF, par['IGNORE'], par['CONTEXT'], ACCURACYerr, REVe, TST, STABLEerr, TST, TST))
                ACCURACYerr = ACCURACYerr - 1
            if env.get('ECHO_DIFF'):
                cmd = 'diff'
                if ACCURACYerr >= 0:
                    cmd += ' -d'
                os.system('%s -Bb -I"%s" -U%s "%s%s.FILTERED" "%s.test.err.FILTERED"' % (cmd, par['IGNORE'], par['CONTEXT'], TST, STABLEerr, TST))

            FailedOut, FailedErr, elem = AddTstToHtmlIndex(env, TST, STABLEout, STABLEerr, EXT, max(sockerr, timeout, killed, segfaulted))

    return TX,FailedOut,FailedErr,elem
### RunTest(env, TST, BusyPorts, COND, oktests) #

def CheckPort(port) :
    # Since 'localhost' and $HOST (i.e., `hostname`) are usually different interfaces,
    # we check both, unless $HOST (`hostname`) appears to be merely an alias for 'localhost'.
    busy = 0
    Serrno = 0
    Serrstr = ""
    S0 = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    S1 = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    S0.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1);
    S1.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1);
    host = 'localhost'
    try:
        S0.bind((host,port))
    except socket.error, (Serrno,Serrstr):
        busy = 1
    if not busy:
        host = os.environ['HOST']
        try:
            S1.bind((host,port))
        except socket.error, (Serrno,Serrstr):
            # $HOST just alias for 'localhost'?
            S0.close()
            try:
                S1.bind((host,port))
            except socket.error, (Serrno,Serrstr):
                busy = 1
    return busy, host, Serrno, Serrstr, (S0, S1)
### CheckPort(port) #

def randomPort(l,h) :
    repeat = randomPortRepeat
    port = 0
    rpt = 0
    while rpt < repeat:
        port = random.randrange(l,h,1)
        busy, host, Serrno, Serrstr, S = CheckPort(port)
        S[0].close()
        S[1].close()
        if busy:
            rpt = rpt + 1
        else:
            break
    return port
### randomPort(l,h) #

def CheckSocket2(env,SERVER) :  #,SrvrErr) :
    port = int(env[SERVER+'PORT'])
    newport = port
    busy, host, Serrno, Serrstr, S = CheckPort(port)
    if busy:
        S[0].close()
        S[1].close()
        Smsg = """
! Socket-Check failed for %sserver on <%s:%d> with #%d; '%s' !
""" % (SERVER, host, port, Serrno, Serrstr)
        newport = eval(dft[SERVER+'PORT'])
        busy, host, Serrno, Serrstr, S = CheckPort(int(newport))
        if busy:
            S[0].close()
            S[1].close()
            Smsg = Smsg + """
! Socket-Check failed for %sserver on <%s:%d> with #%d; '%s' !
! Giving up after %d attepts !
""" % (SERVER, host, int(newport), Serrno, Serrstr, randomPortRepeat)
            return None, Smsg

        env[SERVER+'PORT'] = newport
        os.environ[SERVER+'PORT'] = env[SERVER+'PORT']
        op = 'port=%d' % port
        np = 'port=%s' % env[SERVER+'PORT']
        env['exe']['Mserver']       = env['exe']['Mserver'][0]       , env['exe']['Mserver'][1].replace(op, np)
        env['exe']['MIL_Client']    = env['exe']['MIL_Client'][0]    , env['exe']['MIL_Client'][1].replace(op, np)
        env['exe']['MAL_Client']    = env['exe']['MAL_Client'][0]    , env['exe']['MAL_Client'][1].replace(op, np)
        env['exe']['SQL_Client']    = env['exe']['SQL_Client'][0]    , env['exe']['SQL_Client'][1].replace(op, np)
        env['exe']['SQL_Dump']      = env['exe']['SQL_Dump'][0]      , env['exe']['SQL_Dump'][1].replace(op, np)
        env['exe']['XQuery_Client'] = env['exe']['XQuery_Client'][0] , env['exe']['XQuery_Client'][1].replace(op, np)
        os.environ['MSERVER']       = os.environ['MSERVER'].replace(op, np)
        os.environ['MIL_CLIENT']    = os.environ['MIL_CLIENT'].replace(op, np)
        os.environ['MAL_CLIENT']    = os.environ['MAL_CLIENT'].replace(op, np)
        os.environ['SQL_CLIENT']    = os.environ['SQL_CLIENT'].replace(op, np)
        os.environ['SQL_DUMP']      = os.environ['SQL_DUMP'].replace(op, np)
        os.environ['XQUERY_CLIENT'] = os.environ['XQUERY_CLIENT'].replace(op, np)
        Smsg = Smsg + """
! Using new %sPORT=%s !
""" % (SERVER, env[SERVER+'PORT'])
#        STDERR.write(Smsg)
#        STDERR.flush()
#        SrvrErr.write(Smsg)
#        SrvrErr.flush()

    return S, None
### CheckSocket2(env,SERVER)    #,SrvrErr) #

def CheckSocket3(env,SERVER,ErrFileName) :
    res = F_OK
    port = int(env[SERVER+'PORT'])
    busy, host, Serrno, Serrstr, S = CheckPort(port)
    S[0].close()
    S[1].close()
    if busy:
        res = F_SOCK
        Smsg = """
! Socket-Check failed for %sserver on <%s:%d> with #%d; '%s' !
! %sPORT was not properly released by Mserver/mserver5 !
""" % (SERVER, host, port, Serrno, Serrstr, SERVER)
        STDERR.write(Smsg)
        STDERR.flush()
        ErrFile = open(ErrFileName, 'a')
        ErrFile.write(Smsg)
        ErrFile.flush()
        ErrFile.close()
    return res
### CheckSocket3(env,SERVER,ErrFileName) #

def prompt() :
    return time.strftime('%H:%M:%S> ',time.localtime(time.time()))
### prompt() #

def Prompt(cmd) :
    prmpt = time.strftime('\n# %H:%M:%S >  ',time.localtime(time.time()))
    return prmpt+prmpt+cmd+prmpt+"\n\n"
### Prompt(cmd) #

def killProc(proc, outfile = None, cmd = None):
    try:
        os.kill(-proc.pid, signal.SIGKILL)
    except AttributeError:
        subprocess.Popen(['taskkill','/T','/PID',str(proc.pid)])
    except OSError:
        pass
    if outfile is not None and cmd is not None:
        outfile.write('\n!Mtimeout: Timeout: %s\n' % cmd)
    proc.killed = True

def LaunchIt(cmd, TestInput, TestOut, TestErr, TimeOut) :
    TestOut.write(Prompt(cmd))
    TestOut.flush()
    TestErr.write(Prompt(cmd))
    TestErr.flush()

    proc = subprocess.Popen(cmd, shell = True, stdin = subprocess.PIPE, stdout = subprocess.PIPE, stderr = TestErr, universal_newlines = True)
    proc.killed = False
    t = Timer(TimeOut, killProc, args = [proc, TestErr, cmd])
    t.start()

    if TestInput:
        proc.stdin.write(TestInput)
        try:
            proc.stdin.flush()
        except IOError, (IOerrNo, IOerrStr):
            Warn("Flushing input pipe in LaunchIt failed with #%d: '%s'." % (IOerrNo, IOerrStr))

    return proc, t
### LaunchIt(cmd, TestIn, TestOut, TestErr) #

def CollectIt(pOut, TestOut) :
    if pOut:
        while True:
            buf = pOut.read(8192)
            if not buf:
                break
            TestOut.write(buf)
### CollectIt(pOut, pErr, TestOut, TestErr) #

def RunIt(cmd, TestIn, TestOut, TestErr, TimeOut) :
    if type(TestIn) is type(''):
        TestInput = TestIn
        TestIn = subprocess.PIPE
    else:
        TestInput = None
    TestOut.write(Prompt(cmd))
    TestOut.flush()
    TestErr.write(Prompt(cmd))
    TestErr.flush()
    proc = subprocess.Popen(cmd, shell = True, stdin = TestIn, stdout = TestOut, stderr = TestErr, universal_newlines = True)
    proc.killed = False
    t = Timer(TimeOut, killProc, args = [proc, TestErr, cmd])
    try:
        t.start()
        # since both stdout and stderr are redirected to files,
        # communicate will not return any useful data
        proc.communicate(input = TestInput)
        t.cancel()
    except KeyboardInterrupt:
        t.cancel()
        killProc(proc, TestErr, cmd)
        raise
    return proc.killed
### RunIt(cmd, TestIn, TestOut, TestErr) #

def Log() :
    time.strftime('%H:%M:%S> ',time.localtime(time.time()))
### Log() #

def mapi_ping(port,lang) :
    retry = 0
    wait = 1
    host = 'localhost'
    while retry < 3:
        retry += 1
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.connect((host, port))
            flag = sock.recv(2)
            unpacked = struct.unpack( '<H', flag )[0]  # little endian short
            len = ( unpacked >> 1 )     # get length
            data = sock.recv(len)
            # we don't send
            return True
        except socket.error, (Serrno,Serrstr):
            pass
        time.sleep(wait)
    return False
### mapi_ping() #

def DoIt(env, SERVER, CALL, TST, EXT, PRELUDE, TestOutFile, TestErrFile, STIMEOUT, CTIMEOUT, TIMEOUT, MkillUsersAT, ME, MAPIsockets, XRPCsockets) :
    quiet = env['QUIET']
    ATJOB2 = ""
    LogLine = os.path.join(env['TSTDIR'],TST+EXT)+' '+PRELUDE+' (<=%d,%d,%d) ...' % (TIMEOUT,CTIMEOUT,STIMEOUT)
    STDERR.flush()
    if not quiet:
        STDOUT.write(prompt()+LogLine)
    else:
        STDOUT.write(".")

    try:
        STDOUT.flush()
    except IOError, (IOerrNo, IOerrStr):
        Warn("Flushing STDOUT in DoIt failed with #%d: '%s'." % (IOerrNo, IOerrStr))
    TSTDB = env['TSTDB']
    exe = env['exe']

    LOCAL_CONF = ""
    if os.path.isfile(TST+".conf"):
        LOCAL_CONF = ' "--config=%s"' % TST+".conf"
    elif os.path.isfile(os.path.join(env['TSTSRCDIR'],"All.conf")):
        LOCAL_CONF = ' "--config=%s"' % os.path.join(env['TSTSRCDIR'],"All.conf")

    if par['M5']:
        PRINTF = "io.printf"
    else:
        PRINTF = "printf"

    # Release reserved sockets and run the actual test
    MAPIsockets[0].close()
    MAPIsockets[1].close()
    XRPCsockets[0].close()
    XRPCsockets[1].close()

    ServerReady = True
    pSrvr = None
    pSrvrTimer = None
    try:
        if SERVER in ["MIL", "MAL", "SQL", "XQUERY"]:
            SrvrOutFile = TST+".server.out"
            SrvrErrFile = TST+".server.err"
            SrvrOut = open(SrvrOutFile,"w")
            SrvrErr = open(SrvrErrFile,"w")
            ClntOutFile = TST+".client.out"
            ClntErrFile = TST+".client.err"
            ClntOut = open(ClntOutFile,"w")
            ClntErr = open(ClntErrFile,"w")

            PROLOGUE = ""
            if os.path.isfile(TST+".prologue") and par['M4']:
                PROLOGUE = " "+TST+".prologue"
            if os.path.isfile(TST+".prologue5") and par['M5']:
                PROLOGUE = " "+TST+".prologue5"

            Srvr = '%s%s "--dbname=%s"' % (exe['Mserver'][1], LOCAL_CONF, TSTDB)
            if par['ALGEBRA']:
                Srvr += ' --set xquery_backend=algebra'
            if par['NOALGEBRA']:
                Srvr += ' --set xquery_backend=milprint_summer'

            DBINIT=""
            if os.path.isfile(TST+".dbinit") and par['M4']:
                dbinit = TST+".dbinit"
                DBINIT = open(dbinit).readline().strip()
            if os.path.isfile(TST+".dbinit5") and par['M5']:
                dbinit = TST+".dbinit5"
                DBINIT = open(dbinit).readline().strip()

            lang=""

            if SERVER == "MIL":
                lang="mil"
                Srvr = '%s "--dbinit=%s module(mapi); mil_start();"' % (Srvr, DBINIT)
            if SERVER == "MAL":
                lang="mal"
                Srvr = '%s "--dbinit=%s"' % (Srvr, DBINIT)
            if SERVER == "SQL":
                lang="sql"
                if par['M5']:
                    Srvr = '%s --set mal_listing=0 "--dbinit=%s include sql;"' % (Srvr, DBINIT)
                else:
                    Srvr = '%s "--dbinit=%s module(sql_server);"' % (Srvr, DBINIT)
            if SERVER == "XQUERY":
                lang="xquery"
                Srvr = '%s "--dbinit=%s module(pathfinder);"' % (Srvr, DBINIT)
            Srvr = Srvr+PROLOGUE
            if os.name == "nt":
                Srvr = Srvr+' & echo.& '
            else:
                Srvr = Srvr+' ; echo ; '
            Srvr = Srvr+'echo Over..'

            pSrvr, pSrvrTimer = LaunchIt(Srvr, '\n%s("\\nReady.\\n");\n' % PRINTF, SrvrOut, SrvrErr, TIMEOUT)
            ln="dummy"
            while 0 < len(ln) and ln[:6] not in ['Ready.','Over..']:
                ln=pSrvr.stdout.readline()
                SrvrOut.write(ln)
                SrvrOut.flush()
            if ln[:6] != 'Ready.':
                ServerReady = False

            if ServerReady:
                port = int(env['MAPIPORT'])
                ServerReady = mapi_ping(port, lang)
            #if ServerReady and SERVER = "XQUERY":
            #    port = int(env['XRPCPORT'])
            #    ServerReady = mapi_ping(port, lang)

        else:
            ClntOut = open(TestOutFile, 'a')
            ClntErr = open(TestErrFile, 'a')

        timedout = False
        if ServerReady:
            if   CALL == "other":
                cmd = os.path.join(".",TST+EXT)+" "+TST+" "+PRELUDE
                timedout = RunIt(cmd, "", ClntOut, ClntErr, CTIMEOUT)
            elif CALL == "python":
                cmd = exe['python'][1]+" "+TST+EXT+" "+TST+" "+PRELUDE
                timedout = RunIt(cmd, "", ClntOut, ClntErr, CTIMEOUT)
            elif CALL in ["mal", "malXs", "milS", "milSXs"]:
                cmd = '%s%s --dbname=%s %s ' % (exe['Mserver'][1], LOCAL_CONF, TSTDB, PRELUDE)
                if par['ALGEBRA']:
                    cmd += ' --set xquery_backend=algebra'
                if par['NOALGEBRA']:
                    cmd += ' --set xquery_backend=milprint_summer'
                if CALL in ["mal", "milS"]:
                    X=""
                else:
                    X="_s[0-9][0-9]"
                test = re.compile("^"+TST+X+EXT+"$", re.MULTILINE)
                d = os.listdir(os.getcwd())
                d.sort()
                for f in d:
                    if test.match(f):
                        if CALL[:3] == "mal":
                            timedout = RunIt(cmd + f, open(os.devnull), ClntOut, ClntErr, TIMEOUT)
                        elif par['M5']:
                            timedout = RunIt(cmd+" --dbinit=\"include mil_scenario; mil();\" "+f, open(os.devnull), ClntOut, ClntErr, TIMEOUT)
                        else:
                            timedout = RunIt(cmd, open(f), ClntOut, ClntErr, TIMEOUT)
                    if timedout:
                        break
            elif CALL in ["milC", "milCXs", "malC", "malCXs"]:
                TSTs = []
                if CALL in ("milC", "malC"):
                    X=""
                else:
                    X="_s[0-9][0-9]"
                test = re.compile("^"+TST+X+EXT+"$", re.MULTILINE)
                d = os.listdir(os.getcwd())
                d.sort()
                for f in d:
                    if test.match(f):
                        TSTs.append(f)

                if CALL[:3] == "mil":
                    Clnt = exe['MIL_Client'][1]
                elif CALL[:3] == "mal":
                    Clnt = exe['MAL_Client'][1]
                else:
                    Clnt = ''               # cannot happen
                for f in TSTs:
                    timedout = RunIt(Clnt, open(f), ClntOut, ClntErr, TIMEOUT)
                    if timedout:
                        break

                #TODO
                #elif CALL == "milCXp":
            elif CALL in ["sql", "sqlXs"]:
                TSTs = []
                if CALL == "sql":
                    X=""
                else:
                    X="_s[0-9][0-9]"
                test = re.compile("^"+TST+X+EXT+"$", re.MULTILINE)
                d = os.listdir(os.getcwd())
                d.sort()
                for f in d:
                    if test.match(f):
                        TSTs.append(f)

                Clnt = exe['SQL_Client'][1]
                for f in TSTs:
                    timedout = RunIt(Clnt, open(f), ClntOut, ClntErr, TIMEOUT)
                    if timedout:
                        break
            elif CALL in ["xq", "xqXs"]:
                TSTs = []
                if CALL == "xq":
                    X=""
                else:
                    X="_s[0-9][0-9]"
                test = re.compile("^"+TST+X+EXT+"$", re.MULTILINE)
                d = os.listdir(os.getcwd())
                d.sort()
                for f in d:
                    if test.match(f):
                        TSTs.append(f)

                Clnt = exe['XQuery_Client'][1]+" "
                for f in TSTs:
                    timedout = RunIt(Clnt+f, "", ClntOut, ClntErr, TIMEOUT)
                    if timedout:
                        break
        else:
            for fp in ClntOut,ClntErr:
                fp.write('\n\n! Server not ready; skipping attempt to start client!\n\n')
        ClntOut.close()
        ClntErr.close()

        if SERVER in ["MIL", "MAL", "SQL", "XQUERY"]:
            EPILOGUE = None
            if os.path.isfile(TST+".epilogue") and par['M4']:
                EPILOGUE = open(TST+".epilogue",'r')
            if os.path.isfile(TST+".epilogue5") and par['M5']:
                EPILOGUE = open(TST+".epilogue5",'r')
            if EPILOGUE:
                EpiFailed = ""
                try:
                    pSrvr.stdin.write(EPILOGUE.read())
                    pSrvr.stdin.flush()
                    pSrvr.stdin.write(';\n%s("\\nDone..\\n");\n' % PRINTF)
                    pSrvr.stdin.flush()
                except IOError, (IOerrNo, IOerrStr):
                    EpiFailed = EpiFailed+"\n! Executing "+TST+".epilogue failed with #"+str(IOerrNo)+": '"+IOerrStr+"'. !"
                    EpiFailed = EpiFailed+"\n! Probably, Mserver/mserver5 has died before or during. !\n"
                ln="dummy"
                while 0 < len(ln) and ln[:6] not in ['Done..','Over..']:
                    ln=pSrvr.stdout.readline()
                    SrvrOut.write(ln)
                    SrvrOut.flush()
                SrvrOut.write(EpiFailed)
                SrvrOut.flush()
                EPILOGUE.close()

            try:
                if par['M5']:
                    pSrvr.stdin.write('clients.quit();\n')
                else:
                    pSrvr.stdin.write('quit();\n')
                pSrvr.stdin.flush()
            except IOError:
                pass
            try:
                pSrvr.stdin.close()
            except IOError, (IOerrNo, IOerrStr):
                Warn("Closing input pipe in DoIt failed with #%d: '%s'." % (IOerrNo, IOerrStr))

            if MkillUsersAT:
                ATJOB2 = StartAt(MkillUsersAT)
            CollectIt(pSrvr.stdout, SrvrOut)
            pSrvr.wait()
            pSrvrTimer.cancel()
            pSrvrTimer = None
            timedout = timedout or pSrvr.killed
            if MkillUsersAT:
                StopAt(ATJOB2,ME)

            AllOut = [SrvrOut, ClntOutFile]
            AllErr = [SrvrErr, ClntErrFile]
            TestOut = open(TestOutFile, 'a')
            for q in AllOut:
                if type(q) is type(''):
                    n = q
                else:
                    n = q.name
                    q.close()
                q = open(n,'r')
                try:
                    TestOut.write(q.read())
                except IOError, (IOerrNo, IOerrStr):
                    Warn("Reading from input '%s' or writing to output '%s' failed with #%d: '%s'." % (q.name, TestOut.name, IOerrNo, IOerrStr))
                except MemoryError:
                    Warn("Reading from input '%s' or writing to output '%s' failed with 'MemoryError'." % (q.name, TestOut.name))
                TestOut.flush()
                q.close()
            TestErr = open(TestErrFile, 'a')
            for q in AllErr:
                if type(q) is type(''):
                    n = q
                else:
                    n = q.name
                    q.close()
                q = open(n,'r')
                TestErr.write(q.read())
                TestErr.flush()
                q.close()
        else:
            TestOut = try_open(TestOutFile, 'a')
            TestErr = try_open(TestErrFile, 'a')

        if TestOut is not None:
            TestOut.write(Prompt('Done.'))
            TestOut.close()
        if TestErr is not None:
            TestErr.write(Prompt('Done.'))
            TestErr.close()
    except KeyboardInterrupt:
        if pSrvrTimer is not None:
            pSrvrTimer.cancel()
            killProc(pSrvr, SrvrErr, Srvr)
            raise

    segfaulted = False
    # Try to detect segfaults and the like
    TO = re.compile("(^|[\t ])(Memory [Ff]ault|Segmentation [Ff]ault|Bus [Ee]rror|Abort(|ed))([ \t]|$)", re.MULTILINE)
    # FIXME: this begs for a much nicer solution (100% copy of below)
    if os.path.isfile(TestErrFile):
        for l in open(TestErrFile):
            if TO.match(l):
                segfaulted = True
    if not segfaulted and os.path.isfile(TestOutFile):
        for l in open(TestOutFile):
            if TO.match(l):
                segfaulted = True

    timedout = False
    if not timedout and not segfaulted:
        TO = re.compile("^!.*Mtimeout.*: Timeout: ", re.MULTILINE)
        if os.path.isfile(TestErrFile):
            for l in open(TestErrFile):
                if TO.match(l):
                    timedout = True
        if not timedout and os.path.isfile(TestOutFile):
            for l in open(TestOutFile):
                if TO.match(l):
                    timedout = True

    if segfaulted:
        return "segfault"
    elif timedout:
        return "timeout"

    return None

### DoIt(env, SERVER, CALL, TST, EXT, PRELUDE, TestOut, TestErr, STIMEOUT, CTIMEOUT, TIMEOUT, MkillUsersAT, ME, MAPIsockets, XRPCsockets) #

def Check(command, input) :
    proc = subprocess.Popen(command, shell = True, stdin = subprocess.PIPE, stdout = subprocess.PIPE, stderr = subprocess.PIPE, universal_newlines = True)
    t = Timer(float(par['TIMEOUT']), killProc, args = [proc])
    try:
        t.start()
        qOut, qErr = proc.communicate(input = input)
        t.cancel()
    except KeyboardInterrupt:
        t.cancel()
        killProc(proc)
        raise
    qOut = qOut.split('\n')
    qErr = qErr.split('\n')
    if proc.returncode:
        qOut.append('! Exit 1')
    test = re.compile( r"^!WARNING: BATpropcheck: "                                          "|"
                       r"^!WARNING: monet_checkbat: "                                        "|"
                       r"^!WARNING: GDKlockHome: ignoring empty or invalid .gdk_lock."       "|"
                       r"^!WARNING: BBPdir: initializing BBP.",
                       re.MULTILINE)
    noErr = []
    for l in qOut+qErr:
        if l[:1] == "!":
            if test.match(l):
                if l[:10] != "!WARNING: ":
                    noErr.append(l+"\n")
            else:
                ErrMsg("'"+command+"` failed:")
                if qOut and len(qOut[-1]) >= 8 and qOut[-1][:8] == "! Exit 1":
                    qErr.append(qOut.pop())
                for l in qOut+qErr:
                    STDERR.write(l)
                    STDERR.write("\n")
                STDERR.write("\n")
                STDERR.flush()
                #sys.exit(1)
                return 1
    if noErr:
        STDOUT.flush()
        STDERR.writelines(noErr)
        STDERR.flush()
    return 0
### Check(command, input) #

def CheckClassPath(quiet) :
    if os.environ.has_key('CLASSPATH'):
        cp = os.environ['CLASSPATH']
        cpx = cp + os.pathsep
    else:
        cp = ''
        cpx = ''
    JARS = {
        'HAVE_MONETDBJDBC_JAR' : re.compile('^monetdb-[0-9]\.[0-9]+-jdbc\.jar$'),
        'HAVE_JDBCCLIENT_JAR'  : re.compile('^jdbcclient\.jar$'),
        'HAVE_JDBCTESTS_JAR'   : re.compile('^jdbctests\.jar$'),
        'HAVE_XRPCAPI_JAR'     : re.compile('^xrpcapi\.jar$'),
        'HAVE_XRPCCLIENT_JAR'  : re.compile('^xrpcclient\.jar$'),
        'HAVE_XRPCWRAPPER_JAR' : re.compile('^xrpcwrapper\.jar$'),
    }
    # check for known JARs in CLASSPATH files
    for p in cp.split(os.pathsep):
        if os.path.isfile(p):
            f = os.path.basename(p)
            C = 'HAVE_%s' % f.upper().replace('.','_')
            if not JARS.has_key(C):
                C = 'HAVE_MONETDBJDBC_JAR'
            if JARS[C].match(f):
                CONDITIONALS[C] = '#'
    # check for known JARs in CLASSPATH directories
    # + fall-back using `monetdb-config --pkgdatadir`/lib
    #               and `monetdb-config --pkgdatadir`/Tests
    cpx += os.path.join(GetMonetConfig('monetdb','--pkgdatadir'),'lib')
    cpx += os.pathsep
    cpx += os.path.join(GetMonetConfig('monetdb','--pkgdatadir'),'Tests')
    for d in cpx.split(os.pathsep):
        if os.path.isdir(d):
            for f in os.listdir(d):
                p = os.path.join(d,f)
                if os.path.isfile(p):
                    if f == 'BugConcurrent_clients_SF_1504657.class':
                        C = 'HAVE_JDBCTESTS_DIR'
                        if not CONDITIONALS.has_key(C):
                            cp = cp + os.pathsep + d
                            CONDITIONALS[C] = '#'
                    else:
                        C = 'HAVE_%s' % f.upper().replace('.','_')
                        if not JARS.has_key(C):
                            C = 'HAVE_MONETDBJDBC_JAR'
                        if not CONDITIONALS.has_key(C) and JARS[C].match(f):
                            cp = cp + os.pathsep + p
                            CONDITIONALS[C] = '#'
    if cp:
        os.environ['CLASSPATH'] = cp
    miss = ''
    for j in ['monetdbjdbc.jar', 'jdbcclient.jar', 'jdbctests.jar', 'xrpcapi.jar', 'xrpcclient.jar', 'xrpcwrapper.jar']:
        C = 'HAVE_%s' % j.upper().replace('.','_')
        if not CONDITIONALS.has_key(C):
            miss += ' "%s"' % j
    if miss and not quiet:
        Warn('Could not find%s in\nCLASSPATH="%s"' % (miss,cpx))
    if CONDITIONALS.has_key('HAVE_MONETDBJDBC_JAR') and ( CONDITIONALS.has_key('HAVE_JDBCTESTS_JAR') or CONDITIONALS.has_key('HAVE_JDBCTESTS_DIR')):
        CONDITIONALS['HAVE_JDBCTESTS'] = '#'
### CheckClassPath(quiet) #

def SetExecEnv(exe,verbose) :
    if os.name == "nt":
        CALL = "call "
    else:
        CALL = ""
    if verbose:
        STDERR.flush()
    for v in exe.keys():
        V = v.upper()
        if  v != 'Mtimeout':
            os.environ[V] = CALL+exe['Mtimeout'][1]+exe[v][1]
        elif exe[v][0]:
            os.environ[V] = CALL+exe[v][1]
        else:
            os.environ[V] = ""
        if verbose:
            print "%s = %s : %s" % (V, exe[v][0], exe[v][1])
    if verbose:
        STDOUT.flush()
### SetExecEnv(exe,verbose) #

def ReadMapproveRc(f) :
    v = {}
    v['SYST'] = SYST
    v['RELEASE'] = RELEASE
    v['DIST'] = DIST
    v['VERSION'] = VERSION
    v['BITS'] = ''
    v['OIDS'] = ''
    v['FIVE'] = ''
    v['STATIC'] = ''
    v['ALGEBRA'] = ''
    v['NOALGEBRA'] = ''
    if os.path.isfile(f):
        r = re.compile('^([A-Z]+) = "(.*)".*$')
        for l in open(f):
            m = r.match(l)
            if m:
                v[m.group(1)] = m.group(2)
    return v
### ReadMapproveRc(f) #

#############################################################################
#       MAIN

THISFILE = os.path.basename(sys.argv[0])
THISPATH = os.path.realpath(os.path.dirname(sys.argv[0]))
dftIGNORE = '^#'
TSTDBG = str(2+8)
TSTTHREADS = "0"
dftTSTPREF = "mTests"
TSTSUFF = "Tests"

if hasattr(os,"symlink"):
    SymlinkOrCopy = os.symlink
else:
    SymlinkOrCopy = shutil.copy

os.environ['CYGPATH_W'] = '@CYGPATH_W@'
os.environ['CYGPATH_WP'] = '@CYGPATH_WP@'

HOST = 'localhost'
if os.environ.has_key('HOST'):
    HOST = os.environ['HOST']
#else:
#    HOST = ''
elif os.name != "nt":
    HOST = os.uname()[1]
elif os.environ.has_key('COMPUTERNAME'):
    HOST = os.environ['COMPUTERNAME']
##else:
##    HOST = "WIN2000"
if os.environ.has_key('DOMAIN'):
    HOST = HOST.replace('.'+os.environ('DOMAIN'),'')
else:
    HOST = HOST.split('.', 1)[0]
os.environ['HOST'] = HOST

if os.name == "nt":
    SYST    = "Windows"
    RELEASE = "5.0"
    r = re.compile('^Microsoft Windows (.*)\[Version ([0-9]+\.[0-9]+)([^\[0-9].*)\]$')
    proc = subprocess.Popen('cmd /c ver', stdin = subprocess.PIPE, stdout = subprocess.PIPE, universal_newlines = True)
    qOut, qErr = proc.communicate()
    for l in qOut.split('\n'):
        m = r.match(l.strip())
        if m and m.group(2):
            RELEASE = m.group(2)
else:
    SYST    = os.uname()[0].split("_NT-", 1)[0]
    if SYST == "AIX":
        RELEASE = os.uname()[3]+"."+os.uname()[2]
    else:
        RELEASE = os.uname()[2].split("(", 1)[0]

# this is for the wine/mingw setup
if sys.platform == 'linux2' and CONDITIONALS['CROSS_COMPILING']:
    SYST = 'Windows'
    HOST = "WINE"
    RELEASE = "5.2"

if SYST == "Linux":
    #  Please keep this aligned / in sync with buildtools/conf/MonetDB.m4 & TestTools/.Mconfig.rc & TestTools/MdoServer !
    LINUX_DIST=''
    if os.path.isfile('/etc/fedora-release'):
        l = open('/etc/fedora-release').readline()
        x = re.compile('^.*(Fedora).* release ([0-9][^ \n]*)( .*)*$').match(l)
        if x:
            LINUX_DIST = '%s:%s' % (x.group(1),x.group(2))
    elif os.path.isfile('/etc/centos-release'):
        l = open('/etc/centos-release').readline()
        x = re.compile('^(CentOS) release ([0-9][^ \n]*)( .*)*$').match(l)
        if x:
            LINUX_DIST = '%s:%s' % (x.group(1),x.group(2))
    elif os.path.isfile('/etc/yellowdog-release'):
        l = open('/etc/yellowdog-release').readline()
        x = re.compile('^(Yellow) Dog Linux release ([0-9][^ \n]*)( .*)*$').match(l)
        if x:
            LINUX_DIST = '%s:%s' % (x.group(1),x.group(2))
    elif os.path.isfile('/etc/redhat-release'):
        l = open('/etc/redhat-release').readline()
        x0 = re.compile('^.*(Red) (Hat).* Linux *([A-Z]*) release ([0-9][^ \n]*)( .*)*$').match(l)
        x1 = re.compile('^Red Hat Enterprise Linux ([AW]S) release ([0-9][^ \n]*)( .*)*$').match(l)
        x2 = re.compile('^(CentOS) release ([0-9][^ \n]*)( .*)*$').match(l)
        x3 = re.compile('^(Scientific) Linux SL release ([0-9][^ \n]*)( .*)*$').match(l)
        if x0:
            LINUX_DIST = '%s%s:%s%s' % (x0.group(1),x0.group(2),x0.group(4),x0.group(3))
        elif x1:
            LINUX_DIST = 'RHEL:%s%s' % (x1.group(2),x1.group(1))
        elif x2:
            LINUX_DIST = '%s:%s' % (x2.group(1),x2.group(2))
        elif x3:
            LINUX_DIST = '%s:%s' % (x3.group(1),x3.group(2))
    elif os.path.isfile('/etc/SuSE-release'):
        l = open('/etc/SuSE-release').readline()
        x0 = re.compile('^.*(S[Uu]SE) LINUX Enterprise ([SD])[ervsktop]* ([0-9][^ \n]*)( .*)*$').match(l)
        x1 = re.compile('^S[Uu]SE LINUX Enterprise ([SD])[ervsktop]* ([0-9][^ \n]*)( .*)*$').match(l)
        x2 = re.compile('^.*(S[Uu]SE) [Ll][Ii][Nn][Uu][Xx].* ([0-9][^ \n]*)( .*)*$').match(l)
        x3 = re.compile('^open(S[Uu]SE) ([0-9][^ \n]*)( .*)*$').match(l)
        if x0:
            LINUX_DIST = '%s:%sE%s' % (x0.group(1),x0.group(3),x0.group(2))
        elif x1:
            LINUX_DIST = 'SLE%s:%s' % (x1.group(1),x1.group(2))
        elif x2:
            LINUX_DIST = '%s:%s' % (x2.group(1),x2.group(2))
        elif x3:
            LINUX_DIST = '%s:%s' % (x3.group(1),x3.group(2))
    elif os.path.isfile('/etc/gentoo-release'):
        l = open('/etc/gentoo-release').readline()
        x = re.compile('^.*(Gentoo) Base System.* [versionrelease]* ([0-9][^ \n]*)( .*)*$').match(l)
        if x:
            LINUX_DIST = '%s:%s' % (x.group(1),x.group(2))
    elif os.path.isfile('/etc/lsb-release'):
        x0 = x1 = None
        for l in open('/etc/lsb-release'):
            if not x0:
                x0 = re.compile('^DISTRIB_ID=([^ \n]*)( .*)*$').match(l)
            if not x1:
                x1 = re.compile('^DISTRIB_RELEASE=([^ \n]*)( .*)*$').match(l)
        if x0 and x1:
            LINUX_DIST = '%s:%s' % (x0.group(1),x1.group(1))
    elif os.path.isfile('/etc/debian_version'):
        LINUX_DIST = "Debian:"+open('/etc/debian_version').readline().strip()
    if not LINUX_DIST:
        LINUX_DIST = SYST+':'+re.compile('^([0-9\.]*)([^0-9\.].*)$').match(RELEASE).group(1)
    DIST,VERSION = LINUX_DIST.split(':', 1)
else:
    DIST = SYST
    VERSION = RELEASE

SYSTVER = SYST+RELEASE
DISTVER = DIST+VERSION
os.environ['SYST'] = SYST
os.environ['SYSTVER'] = SYSTVER
os.environ['RELEASE'] = RELEASE
os.environ['DIST'] = DIST
os.environ['DISTVER'] = DISTVER
os.environ['VERSION'] = VERSION

if os.environ.has_key('COMPBITSOIDSLINK'):
    COMPBITSOIDSLINK = os.environ['COMPBITSOIDSLINK']
else:
    COMPBITSOIDSLINK = ""

if os.environ.has_key('HTMLTITLE'):
    HTMLTITLE = os.environ['HTMLTITLE']
else:
    HTMLTITLE = ""
    if COMPBITSOIDSLINK:
        HTMLTITLE = " for "+COMPBITSOIDSLINK
    HTMLTITLE = ""+THISFILE+" results"+HTMLTITLE+" on "+DISTVER       #"+ ("`date`")"

URLPREFIXMAP = {
    'MonetDB': 'http://monetdb.cvs.sourceforge.net/monetdb/MonetDB/',
    'sql': 'http://monetdb.cvs.sourceforge.net/monetdb/sql/',
    'pathfinder': 'http://monetdb.cvs.sourceforge.net/monetdb/pathfinder/',
    'xml': 'http://monetdb.cvs.sourceforge.net/monetdb/xml/',
    'buildtools': 'http://monetdb.cvs.sourceforge.net/monetdb/buildtools/',
    'pf-tools': 'http://monetdb.cvs.sourceforge.net/monetdb/pf-tools/',
    'pf-haskell': 'http://monetdb.cvs.sourceforge.net/monetdb/pf-haskell/',
    }
URLPREFIX   = None
##URLSUFFIX_F = '?cvsroot=Monet-4.3'
URLSUFFIX_F = ''
##URLSUFFIX_D = '?cvsroot=Monet-4.3'
URLSUFFIX_D = ''

_PackageDict = {
    'java':       'monetdb-java',
    'clients':    'monetdb-clients',
    'template':   'monetdb-template',
    'sql':        'monetdb-sql',
    'xquery':     'monetdb-xquery',
    'pathfinder': 'monetdb-xquery',
    'xml':        'monetdb-xml',
    'geom':       'monetdb-geom',
    'datacell':   'monetdb-datacell',
    }

par = {}
# the default; only used for usage information in case -p/--package has not been given
par['PACKAGE'] = 'monetdb'
# try to be "smart"
if os.path.exists(os.path.join('CVS', 'Repository')):
    repo = open(os.path.join('CVS', 'Repository')).read()[:-1].lower()
    i = repo.find('/')
    if i > 0:
        repo = repo[:i]
    if repo[:6] != 'monetdb':
        if _PackageDict.has_key(repo):
            repo = _PackageDict[repo]
    par['PACKAGE'] = repo
    if not CheckExec(par['PACKAGE']+'-config'):
        if par['PACKAGE'] in ('monetdb', 'monetdb-clients', 'monetdb4', 'monetdb5'):
            ErrXit('Could not find "%s-config" in your $PATH:\n%s' % (par['PACKAGE'],os.environ['PATH']))
        elif par['PACKAGE'] != 'monetdb-java':
            if par['PACKAGE'] != '.':
                Warn('Could not find "%s-config" in your $PATH:\n%s' % (par['PACKAGE'],os.environ['PATH']))
            par['PACKAGE'] = 'monetdb'
            Warn('Using default package="%s".' % par['PACKAGE'])

dft = {}

def main(argv) :
    #TODO:
    #signal.signal(signal.SIGALRM, AlarmHandler)

    vars = ['TSTSRCBASE', 'TSTTRGBASE']
    if THISFILE == "Mtest.py":
        vars = vars + [ 'MILCLIENT', 'MALCLIENT', 'SQLCLIENT', 'SQLDUMP', 'XQUERYCLIENT']    #, 'MONETDB_MOD_PATH' ]

    env = {}

    # most intuitive (?) default settings
    dft['TSTSRCBASE']     = "GetMonetConfig(par['PACKAGE'],'--source')"
    dft['TSTTRGBASE']     = "GetMonetConfig(par['PACKAGE'],'--prefix')"   # or os.getcwd() ?
    if THISFILE == "Mtest.py":
        dft['GDK_DEBUG']      = "TSTDBG"
        dft['GDK_NR_THREADS'] = "TSTTHREADS"
        dft['MONETDB_MOD_PATH'] = "''"   #"GetMonetConfig(par['PACKAGE'],'--modpath')"
        dft['setMONETDB_MOD_PATH'] = "'--set \"monet_mod_path='+env['MONETDB_MOD_PATH']+'\"'"
        dft['setGDK_DBFARM']     = "'--set \"gdk_dbfarm='+env['GDK_DBFARM']+'\"'"
        dft['setXRPC_DOCROOT']   = "'--set \"xrpc_docroot='+env['XRPC_DOCROOT']+'\"'"
        dft['MAPIPORT']       = "str(randomPort(30000,39999))"
        dft['XRPCPORT']       = "str(randomPort(40000,49999))"
        dft['MILCLIENT']      = "'mclient -lmil -ftest'"
        dft['MALCLIENT']      = "'mclient -lmal -ftest'"
        dft['SQLCLIENT']      = "'mclient -lsql -ftest'"
        dft['SQLDUMP']        = "'msqldump'"
        dft['XQUERYCLIENT']   = "'mclient -lxquery -fxml'"

    #par = {}
    # get current environment
    env['HOST'] = os.environ['HOST']
    for v in vars:
        if os.environ.has_key(v):
            env[v] = os.environ[v]
            #TODO:
            # make sure, that PATHs are absolute

    # commandline options overrule environment
    cmd_options = [
        # long name, short name, GDK option, argument, comment
        ('package', 'p', 'package', '<package>',
         "package to be tested, e.g.:\nmonetdb(|4|5), [monetdb-](java|clients|template|sql|xquery|xml|geom|datacell);\ndefault: %s" % par['PACKAGE']),
        ('MonetDB4', '4', 'MonetDB4', None,
         "use Mserver of MonetDB Version 4 (default with <package> not in {monetdb5, monetdb-datacell})"),
        ('MonetDB5', '5', 'MonetDB5', None,
         "use mserver5 of MonetDB Version 5 (default with <package> in {monetdb5, monetdb-datacell})"),
        ('algebra', 'G', 'algebra', None,
         "use the algebra version of the XQuery compiler"),
        ('no-algebra', 'g', 'no-algebra', None,
         "do not use the algebra version of the XQuery compiler"),
        ('recursive', 'r', 'recursive', None,
         "recurse into subdirectories (implies 'All')"),
        ('TSTSRCBASE', None, 'TSTSRCBASE', '<path>',
         'default: `<package>-config --source` = "%s"' % GetMonetConfig(par['PACKAGE'],'--source')),
        ('TSTTRGBASE', None, 'TSTTRGBASE', '<path>',
         'default: `<package>-config --prefix` = "%s"' % GetMonetConfig(par['PACKAGE'],'--prefix')),
        ('quiet', 'q', 'quiet', None,
         "suppress messages on stdout"),
        ]

    if THISFILE == "Mtest.py":
        common_options = cmd_options + [
            (None, 'I', 'ignore', '<exp>',
             "ignore lines matching <exp> during diff (default: '%s')" % dftIGNORE),
            (None, 'C', 'context', '<num>',
             "use <num> lines of context during diff (default: -C1)"),
            (None, 'A', 'accuracy', '<num>',
             "accuracy for diff: 0=lines, 1=words, 2=chars (default: -A1)"),
            (None, 't', 'timeout', '<sec>',
             "timeout: kill (hanging) tests after <sec> seconds;\n"
             "-t0 means no timeout (default: -t60)"),
            ('debug', 'd', 'debug', '<num>',
             ("debug value to be used by Mserver/mserver5 (default: -d%s)\n"
              "(see `Mserver --help' / `mserver5 --help' for details)") % TSTDBG),
            ('nr_threads', 'n', 'nr_threads', '<num>',
             ("number of threads for mserver5 (default: -n%s)\n"
              "-n0 => mserver5 automatically determines the number of CPU cores") % TSTTHREADS),
            ('monet_mod_path', None, 'monet_mod_path', '<pathlist>',
             "override Mserver's/mserver5's default module search path"),
            ('dbfarm', None, 'gdk_dbfarm', '<directory>',
             "override default location of database directory"),
            ('xrpc_docroot', None, 'xrpc_docroot', '<directory>',
             "override default root directory from which the XRPC HTTP server will serve files"),
            ('MILCLIENT', None, 'MILCLIENT', '<mil-client program>',
             'default: %s' % dft['MILCLIENT']),
            ('MALCLIENT', None, 'MALCLIENT', '<mal-client program>',
             'default: %s' % dft['MALCLIENT']),
            ('SQLCLIENT', None, 'SQLCLIENT', '<sql-client program>',
             'default: %s' % dft['SQLCLIENT']),
            ('SQLDUMP', None, 'SQLDUMP', '<sql-dump program>',
             'default: %s' % dft['SQLDUMP']),
            ('XQUERYCLIENT', None, 'XQUERYCLIENT', '<XQuery-client program>',
             'default: %s' % dft['XQUERYCLIENT']),
            ('at', None, 'use_at', None, 'Use at command as watchdog'),
            ('concurrent', None, 'concurrent', None,
             'There are concurrent Mtest runs using the same MonetDB installation'),
            ('dbg', None, 'dbg', '<debugger/valgrind>',
             "debugger to start before each server"),
            ('echo-diff', None, 'echo-diff', None,
             "echo differences between stable and current test output to console (stdout)"),
            ('mserver_set', None, 'mserver_set', '<Mserver_option>',
             "This passes a single set to the server"),
            ]

    if THISFILE == 'Mtest.py':
        options = common_options # + []
    elif THISFILE == 'Mapprove.py':
        f = os.path.join(GetMonetConfig(par['PACKAGE'],'--prefix'),dftTSTPREF,'.Mapprove.rc')
        v = ReadMapproveRc(f)
        for i in 'BITS', 'OIDS', 'FIVE', 'STATIC', 'ALGEBRA', 'NOALGEBRA':
            if v[i]:
                v[i] = '[.%s]' % v[i]
        options = cmd_options + [
            (None, 'x', 'ext', '<ext>',
             "approve only output files *.<ext><sys> (<ext> = 'out' or 'err')\n"
             "(default: <ext> = 'out' & 'err')"),
            (None, 'S', 'sys', '<sys>',
             "approve specific output *.<ext><sys>\n"
             "(<sys> = '[.(<SYST>[<RELEASE>]|<DIST>[<VERSION>])][.(32|64)bit][.oid(32|64)][.Five][.STATIC][.Algebra]',\n"
             "(default: longest match for <sys> = '[.(%s[%s]|%s[%s])]%s%s%s%s%s')"
              % (v['SYST'], v['RELEASE'], v['DIST'], v['VERSION'], v['BITS'], v['OIDS'], v['FIVE'], v['STATIC'], v['ALGEBRA'])),
            (None, 'f', 'force', None,
             "force approval of error messages (i.e., lines starting with '!')"),
            ]
    else:
        options = []

    try:
        # let monet_options.parse_options() parse the command line arguments
        # without setting a --config default in case the is no --config given
        opts, args = monet_options.parse_options(argv[1:], options, Usage, False)
    except monet_options.Error:
        sys.exit(1)

    par['M4'] = opts.get('MonetDB4', 0)
    par['M5'] = opts.get('MonetDB5', 0)
    if par['M4'] and par['M5']:
        ErrXit('Specifying both "-4/--MonetDB4" and "-5/MonetDB5" is not allowed!')

    pkg = opts.get('package')
    if pkg is None:
        if par['PACKAGE'] == 'monetdb':
            if par['M4']:
                par['PACKAGE'] = 'monetdb4'
            elif par['M5']:
                par['PACKAGE'] = 'monetdb5'
            Warn('No (suitable) ./CVS/Repository found and no -p/--package specified. Using default package="%s". Please use -p/--package to overrule.' % par['PACKAGE'])
    else:
        pkg = pkg.lower()
        if pkg[:6] != 'monetdb':
            if _PackageDict.has_key(pkg):
                pkg = _PackageDict[pkg]
        par['PACKAGE'] = pkg
    if not CheckExec(par['PACKAGE']+'-config'):
        if par['PACKAGE'] in ('monetdb', 'monetdb-clients', 'monetdb4', 'monetdb5'):
            ErrXit('Could not find "%s-config" in your $PATH:\n%s' % (par['PACKAGE'],os.environ['PATH']))
        elif par['PACKAGE'] != 'monetdb-java':
            Warn('Could not find "%s-config" in your $PATH:\n%s' % (par['PACKAGE'],os.environ['PATH']))
            if par['M4']:
                par['PACKAGE'] = 'monetdb4'
            elif par['M5']:
                par['PACKAGE'] = 'monetdb5'
            else:
                par['PACKAGE'] = 'monetdb'
            Warn('Using default package="%s".' % par['PACKAGE'])

    if par['M4'] and par['PACKAGE'] == 'monetdb5':
        ErrXit('"-4/--MonetDB4" conflicts with "--package=monetdb5"!')
    if par['M5'] and par['PACKAGE'] == 'monetdb4':
        ErrXit('"-5/--MonetDB5" conflicts with "--package=monetdb4"!')
    if not par['M4'] and not par['M5']:
        par['M4'] = par['PACKAGE'] not in ['monetdb5', 'monetdb-datacell', 'monetdb-template', 'monetdb-sql', 'monetdb-geom']
        par['M5'] = par['PACKAGE']     in ['monetdb5', 'monetdb-datacell', 'monetdb-template', 'monetdb-sql', 'monetdb-geom']

    config = opts.get('config')
    if config is None and par['PACKAGE'] not in ('monetdb', 'monetdb-java', 'monetdb-clients'):
        # no --config given on the command line; we assume the M4/M5 default
        # and have monet_options.parse_options() re-parse the command line arguments
        if par['M5']:
            config = os.path.join(GetMonetConfig('monetdb5', '--sysconfdir'), 'monetdb5.conf')
        else:
            config = os.path.join(GetMonetConfig('monetdb4', '--sysconfdir'), 'MonetDB.conf')
        try:
            opts, args = monet_options.parse_options(['--config='+config] + argv[1:], options, Usage, False)
        except monet_options.Error:
            sys.exit(1)

    par['ALGEBRA'] = opts.get('algebra', 0)
    par['NOALGEBRA'] = opts.get('no-algebra', 0)
    if par['ALGEBRA'] and par['NOALGEBRA']:
        ErrXit('"-G/--algebra" conflicts with "-g/--no-algebra"!')
    par['RECURSIVE'] = opts.get('recursive', 0)
    par['QUIET'] = opts.get('quiet', 0)
    if THISFILE == "Mtest.py":
        _IGNORE = dftIGNORE
        par['IGNORE'] = opts.get('ignore', _IGNORE)
        par['CONTEXT'] = opts.get('context', '1')
        a = int(opts.get('accuracy', 1))
        if a not in (-1,0,1,2):
            ErrExit('Accuracy for diff (-A) must be one of: 0=lines, 1=words, 2=chars !')
        par['ACCURACY'] = a
        par['TIMEOUT'] = int(opts.get('timeout', 60))
        a = opts.get('debug')
        if a is not None:
            env['GDK_DEBUG'] = str(int(a))
        a = opts.get('nr_threads')
        if a is not None:
            env['GDK_NR_THREADS'] = str(int(a))
        a = opts.get('monet_mod_path')
        if a is not None:
            env['MONETDB_MOD_PATH'] = a
        a = opts.get('gdk_dbfarm')
        if a is not None:
            env['GDK_DBFARM'] = a
        a = opts.get('xrpc_docroot')
        if a is not None:
            env['XRPC_DOCROOT'] = a
        a = opts.get('use_at')
        if a is not None:
            env['USE_AT'] = a
        a = opts.get('concurrent')
        if a is not None:
            env['CONCURRENT'] = a
        a = opts.get('dbg')
        if a is not None:
            env['DBG'] = a
        a = opts.get('echo-diff')
        if a is not None:
            env['ECHO_DIFF'] = a
        a = opts.get('mserver_set')
        if a is not None:
            env['MSERVER_SET'] = "--set " + a
        else:
            env['MSERVER_SET'] = ""
    if THISFILE == 'Mapprove.py':
        a = opts.get('ext')
        if a is None:
            par['EXTENSION'] = ['out', 'err']
        elif a in ('out', 'err'):
            par['EXTENSION'] = [a]
        else:
            ErrXit("Extension (-x) must be one of: 'out', 'err' !")
        par['FORCE'] = opts.get('force', False)
        a = opts.get('sys')
        if a is None:
            par['SYSTEM'] = ''
        else:
            par['SYSTEM'] = a
    for v in vars:
        a = opts.get(v)
        if a is not None:
            env[v] = a

    quiet = par['QUIET']

    # display par's
    STDERR.flush()
    if not quiet:
        for v in par.keys():
            #os.environ[v] = par[v]
            print"%s = %s" % (v, str(par[v]))
    STDOUT.flush()
    #env['par'] = par

    # unknown at compile time, as Mtest.py is compiled with MonetDB;
    # hence, we set then at runtime.
    # X == true   =>  @X_TRUE@='',  @X_FALSE@='#'
    # X == false  =>  @X_TRUE@='#', @X_FALSE@=''
    GetCONDITIONALS(CONDITIONALS, par['PACKAGE'])
    if par['PACKAGE'] not in ('monetdb', 'monetdb-java', 'monetdb-clients'):
        clientsCONDS = {}
        GetCONDITIONALS(clientsCONDS, 'monetdb-clients')
        for l in ('RUBYGEM', 'PYTHON', 'PERL_SWIG'):
            c = 'HAVE_'+l
            if clientsCONDS.has_key(c):
                CONDITIONALS[c] = clientsCONDS[c]
    if CheckExec('php'):
        CONDITIONALS['HAVE_PHP'] = '#'
#     else:
#         CONDITIONALS['HAVE_PHP'] = ''
    if par['PACKAGE'] not in ('monetdb', 'monetdb-java'):
        monetdbCONDS = {}
        GetCONDITIONALS(monetdbCONDS, 'monetdb')
        for l in ('LIBZ', 'LIBBZ2'):
            c = 'HAVE_'+l
            if monetdbCONDS.has_key(c):
                CONDITIONALS[c] = monetdbCONDS[c]
    if par['M5']:
        CONDITIONALS['HAVE_MONETDB5'] = '#'
        CONDITIONALS['HAVE_MONETDB4'] = ''
    else:
        CONDITIONALS['HAVE_MONETDB5'] = ''
        CONDITIONALS['HAVE_MONETDB4'] = '#'
    CheckClassPath(quiet)
    if par['ALGEBRA']:
        CONDITIONALS['WITH_ALGEBRA'] = '#'
        CONDITIONALS['NOT_ALGEBRA']  = ''
    elif par['NOALGEBRA']:
        CONDITIONALS['WITH_ALGEBRA'] = ''
        CONDITIONALS['NOT_ALGEBRA']  = '#'
    else:
        CONDITIONALS['WITH_ALGEBRA'] = ''
        CONDITIONALS['NOT_ALGEBRA']  = '#'
    env['TST_ALGEBRA'] = ""
    env['TST_NOALGEBRA'] = ""
    if CONDITIONALS['WITH_ALGEBRA']:
        env['TST_ALGEBRA'] = "Algebra"
        os.environ['TST_ALGEBRA'] = "Algebra"
    if CONDITIONALS['NOT_ALGEBRA']:
        env['TST_NOALGEBRA'] = "NoAlgebra"
        os.environ['TST_NOALGEBRA'] = "NoAlgebra"
    if par['M4']:
        env['GDK_NR_THREADS'] = "1"

    # tidy-up and fall-back to defaults where necessary
    if THISFILE == "Mtest.py":
        vars_ = vars + ['MAPIPORT', 'XRPCPORT', 'GDK_DEBUG', 'GDK_NR_THREADS', 'MONETDB_MOD_PATH']
    else: # THISFILE == "Mapprove.py"
        vars_ = vars
    for v in vars_:
        if not env.has_key(v):
            env[v] = eval(dft[v])
            #TODO:
            # make sure, that PATHs are absolute
    if THISFILE == "Mtest.py":
        if env['MONETDB_MOD_PATH']:
            env['setMONETDB_MOD_PATH'] = eval(dft['setMONETDB_MOD_PATH'])
        else:
            env['setMONETDB_MOD_PATH'] = ''
        if env.has_key('GDK_DBFARM'):
            env['setGDK_DBFARM'] = eval(dft['setGDK_DBFARM'])
        else:
            env['setGDK_DBFARM'] = ''
        if env.has_key('XRPC_DOCROOT'):
            env['setXRPC_DOCROOT'] = eval(dft['setXRPC_DOCROOT'])
        else:
            env['setXRPC_DOCROOT'] = ''
        if env.has_key('DBG'):
            env['setDBG'] = env['DBG']
        else:
            env['setDBG'] = ''

    #TODO:
    ## in case of inconsistencies, try to fallback to "save" settings
    #
    #if not os.path.indir(TSTSRCBASE):
    #       ErrXit("Illegal TSTSRCBASE: directory '"+a"` does not exist!")

    # ensure consistent TSTSRCBASE
    if os.path.basename(env['TSTSRCBASE']) == TSTSUFF  and  os.path.isfile(os.path.join(env['TSTSRCBASE'],"All")):
        ErrXit('TSTSRCBASE itself must not be a test-directory, i.e., called "%s" and contain an "All" file!' % TSTSUFF)

    # make TSTxxxBASE absolute physical paths
    for p in 'TSTSRCBASE', 'TSTTRGBASE':
        if os.path.isdir(env[p]):
            rp = os.path.realpath(env[p])
            if not quiet and os.path.normcase(rp) != os.path.normcase(env[p]):
                Warn(p+": Replacing logical path  "+env[p]+
                     "  by absolute physical path  "+rp)
            env[p] = rp
        else:
            ErrXit("Illegal "+p+": directory '"+env[p]+"' does not exist!")

    if THISFILE == "Mapprove.py" \
       and not os.path.exists(os.path.join(env['TSTTRGBASE'],dftTSTPREF )) \
       and     os.path.isfile(os.path.join(env['TSTTRGBASE'],'times.lst')):
        env['TSTPREF'] = os.path.basename(env['TSTTRGBASE'])
        env['TSTTRGBASE'] = os.path.dirname(env['TSTTRGBASE'])
    else:
        env['TSTPREF'] = dftTSTPREF
    TSTPREF = env['TSTPREF']

    # read '.Mapprove.rc'
    if THISFILE == 'Mapprove.py':
        f = os.path.join(env['TSTTRGBASE'],TSTPREF,'.Mapprove.rc')
        v = ReadMapproveRc(f)
        SYST = v['SYST']
        RELEASE = v['RELEASE']
        SYSTVER = SYST+RELEASE
        DIST = v['DIST']
        VERSION = v['VERSION']
        DISTVER = DIST+VERSION
        os.environ['SYST'] = SYST
        os.environ['SYSTVER'] = SYSTVER
        os.environ['RELEASE'] = RELEASE
        os.environ['DIST'] = DIST
        os.environ['DISTVER'] = DISTVER
        os.environ['VERSION'] = VERSION
        w = {}
        for i in 'SYST', 'RELEASE', 'DIST', 'VERSION', 'BITS', 'OIDS', 'FIVE', 'STATIC', 'ALGEBRA', 'NOALGEBRA':
            w[i] = re.escape(v[i])
        for i in 'BITS', 'OIDS', 'FIVE', 'STATIC', 'ALGEBRA', 'NOALGEBRA':
            j = 'TST_'+i
            env[j] = v[i]
            os.environ[j] = v[i]
            if v[i]:
                v[i] = '(.%s)?' % v[i]
                w[i] = '(\.%s)?' % w[i]
        sv = '^(.(%s(%s)?|%s(%s)?))?%s%s%s%s%s$' % (v['SYST'], v['RELEASE'], v['DIST'], v['VERSION'], v['BITS'], v['OIDS'], v['FIVE'], v['STATIC'], v['ALGEBRA'])
        sw = '^(\.(%s(%s)?|%s(%s)?))?%s%s%s%s%s$' % (w['SYST'], w['RELEASE'], w['DIST'], w['VERSION'], w['BITS'], w['OIDS'], w['FIVE'], w['STATIC'], w['ALGEBRA'])
        r = re.compile(sw)
        if not r.match(par['SYSTEM']):
            ErrXit("System (-S) must match '"+sv+"' !")

    # some relative path's for relocatable HTML output
    if os.path.normcase(env['TSTSRCBASE']) == os.path.normcase(env['TSTTRGBASE']):
        RELSRCBASE = os.curdir
    else:
        TSTBASE = os.path.dirname(os.path.commonprefix([os.path.normcase(env['TSTSRCBASE']),os.path.normcase(env['TSTTRGBASE'])]))
        RELBASE = ((os.pardir+os.sep)*len(env['TSTTRGBASE'][len(TSTBASE+os.sep):].split(os.sep)))
        RELSRCBASE = RELBASE+env['TSTSRCBASE'][len(TSTBASE):]
    env['RELSRCBASE'] = RELSRCBASE

    #STDERR.flush()
    #for v in 'RELSRCBASE':
    #       print v+" = "+str(env[v])
    #STDOUT.flush()

    # find mil script for MIL and SQL server
    if THISFILE == "Mtest.py":
        env['SQL_TRACE'] = ""

    # fix up URLPREFIX
    global URLPREFIX
    if os.path.exists(os.path.join(env['TSTSRCBASE'], 'CVS', 'Repository')):
        repo = open(os.path.join(env['TSTSRCBASE'], 'CVS', 'Repository')).read()[:-1]
        i = repo.find('/')
        if i > 0:
            repo = repo[:i]
        URLPREFIX = URLPREFIXMAP.get(repo) # None if unknown
    # export and display env
    STDERR.flush()
    if THISFILE == "Mtest.py":
        vars_ = vars_ + ['XRPC_DOCROOT','GDK_DBFARM']
        vars_ = vars_ + ['setXRPC_DOCROOT','setGDK_DBFARM','setMONETDB_MOD_PATH']
    else: # THISFILE == "Mapprove.py"
        vars_ = vars_
    for v in vars_:
        if env.has_key(v):
            os.environ[v] = env[v]
            if not quiet:
                print "%s = %s" % (v, env[v])
    if not quiet:
        print "%s = %s" % ('PATH', os.environ['PATH'])
        if os.environ.has_key('PYTHONPATH'):
            print "%s = %s" % ('PYTHONPATH', os.environ['PYTHONPATH'])
        if os.environ.has_key('CLASSPATH'):
            print "%s = %s" % ('CLASSPATH', os.environ['CLASSPATH'])
    STDOUT.flush()

    # add QUIET par to env
    env['QUIET'] = quiet

    ## set/extend PATH & LD_LIBRARY_PATH
    #bp = ""        #os.path.join(GetMonetConfig(par['PACKAGE'],'--prefix'),"bin")
    #if THISFILE == "Mtest.py":
    #       lp = env['MONETDB_MOD_PATH']
    #else: # THISFILE == "Mapprove.py"
    #       lp = ""
    #if os.name == "nt"  and  lp:
    #       if bp:
    #               bp = bp+os.pathsep+lp
    #       else:
    #               bp = lp
    #if os.environ.has_key('PATH'):
    #       if bp:
    #               bp = bp+os.pathsep+os.environ['PATH']
    #       else:
    #               bp = os.environ['PATH']
    #os.environ['PATH'] = bp
    #print "PATH = "+bp
    #if os.name == "posix":
    #       if os.environ.has_key('LD_LIBRARY_PATH'):
    #               if lp:
    #                       lp = lp+os.pathsep+os.environ['LD_LIBRARY_PATH']
    #               else:
    #                       lp = os.environ['LD_LIBRARY_PATH']
    #       os.environ['LD_LIBRARY_PATH'] = lp
    #       print "LD_LIBRARY_PATH = "+lp

    if not startswithpath(os.getcwd()+os.sep, env['TSTSRCBASE']+os.sep):
        Warn("Current directory "+os.getcwd()+" is no descendant of TSTSRCBASE="+env['TSTSRCBASE']+";")
        Warn("changing to TSTSRCBASE="+env['TSTSRCBASE']+", now.")
        os.chdir(env['TSTSRCBASE'])

    # check for executables, set their standard options and export them
    if THISFILE == "Mtest.py":
        exe = {}
        exe['Mtimeout']      = CheckExec('Mtimeout')     , 'Mtimeout -timeout %d ' % par['TIMEOUT']
        if par['M5']:
            exe['Mserver']       = CheckExec('mserver5')     , '%s mserver5 "--config=%s" --debug=%s --set gdk_nr_threads=%s %s %s %s --set mapi_open=true --set xrpc_open=true --set mapi_port=%s --set xrpc_port=%s --set monet_prompt= --trace %s' % \
                                                               (env['setDBG'], config, env['GDK_DEBUG'], env['GDK_NR_THREADS'], env['setMONETDB_MOD_PATH'], env['setGDK_DBFARM'], env['setXRPC_DOCROOT'], env['MAPIPORT'], env['XRPCPORT'], env['MSERVER_SET'])
        else:
            exe['Mserver']       = CheckExec('Mserver')      , '%s Mserver "--config=%s" --debug=%s --set gdk_nr_threads=%s %s %s %s --set mapi_open=true --set xrpc_open=true --set mapi_port=%s --set xrpc_port=%s --set monet_prompt= --trace %s' % \
                                                               (env['setDBG'], config, env['GDK_DEBUG'], env['GDK_NR_THREADS'], env['setMONETDB_MOD_PATH'], env['setGDK_DBFARM'], env['setXRPC_DOCROOT'], env['MAPIPORT'], env['XRPCPORT'], env['MSERVER_SET'])
        exe['Mdiff']         = CheckExec('Mdiff')        , 'Mdiff'
        exe['python']        = CheckExec(sys.executable) , sys.executable
        exe['MIL_Client']    = CheckExec(env['MILCLIENT'].split(None, 1)[0])  , '%s -i -e --host=%s --port=%s' % (env['MILCLIENT'], HOST, env['MAPIPORT'])
        exe['MAL_Client']    = CheckExec(env['MALCLIENT'].split(None, 1)[0])  , '%s -i -e --host=%s --port=%s' % (env['MALCLIENT'], HOST, env['MAPIPORT'])
        exe['SQL_Client']    = CheckExec(env['SQLCLIENT'].split(None, 1)[0])   , '%s -i -e --host=%s --port=%s %s' % (env['SQLCLIENT'], HOST, env['MAPIPORT'], env['SQL_TRACE'])
        exe['SQL_Dump']      = CheckExec(env['SQLDUMP'].split(None, 1)[0])     , '%s --host=%s --port=%s %s' % (env['SQLDUMP'], HOST, env['MAPIPORT'], env['SQL_TRACE'])
        exe['XQuery_Client'] = CheckExec(env['XQUERYCLIENT'].split(None, 1)[0]), '%s --host=%s --port=%s' % (env['XQUERYCLIENT'], HOST, env['MAPIPORT'])
        if par['ALGEBRA']:
            exe['SQL_Client']    = exe['SQL_Client'][0]   , exe['SQL_Client'][1]   +' -G'
            exe['XQuery_Client'] = exe['XQuery_Client'][0], exe['XQuery_Client'][1]+' -G'
        if par['NOALGEBRA']:
            exe['SQL_Client']    = exe['SQL_Client'][0]   , exe['SQL_Client'][1]   +' -g'
            exe['XQuery_Client'] = exe['XQuery_Client'][0], exe['XQuery_Client'][1]+' -g'
        if par['TIMEOUT'] == 0 or not exe['Mtimeout'][0]:
            exe['Mtimeout'] = '', ''
        env['exe'] = exe
        if not quiet:
            SetExecEnv(exe,1)
        else:
            SetExecEnv(exe,0)

        #TODO:
        #exe['JAVA']       = 'java'
        #exe['JAVAC']      = 'javac'

    # parse commandline arguments
    testdirs = []
    testlist = []
    dirlist = []
    if   len(args) == 1:
        if   os.path.isdir(args[0]):
            d = os.path.realpath(args[0])
            if startswithpath(d+os.sep, env['TSTSRCBASE']+os.sep):
                dirlist.append(d)
            #TODO:
            #else:
                # WARNING/ERROR
        elif args[0].find(os.sep) != -1:
            ErrXit("'"+args[0]+"` is neither a valid directory in "+os.getcwd()+" nor a valid test-name!")
        elif args[0] != "All":
            #TODO:
            # check, whether args[0] in All
            testlist.append(args[0])
    elif len(args) > 1:
        i = 0
        while i < len(args)  and  os.path.isdir(args[i]):
            d = os.path.realpath(args[i])
            if startswithpath(d+os.sep, env['TSTSRCBASE']+os.sep):
                dirlist.append(os.path.realpath(args[i]))
            #TODO:
            #else:
                # WARNING/ERROR
            i = i + 1
        if len(dirlist) == 1  and  i < len(args)  and  args[i] != "All":
            while i < len(args):
                if args[i].find(os.sep) == -1:
                    #TODO:
                    # check, whether args[i] in All
                    testlist.append(args[i])
                #TODO
                #else:
                    # ERROR/WARNING
                i = i + 1
        else:
            if i < len(args)  and  args[i] == "All":
                i = i + 1
            #TODO:
            #if i < len(args):
                #if len(dirlist) > 1:
                    # Warn: dirlist => ignore testlist, assume All
                #else:
                    # Warn: All => ignore testlist
    if not dirlist:
        dirlist.append(os.getcwd())
    if par['RECURSIVE']:
        #TODO
        #if testlist:
            # WARNING
        testlist = []
        for d in dirlist:
            test_dirs = find_test_dirs(d)
            test_dirs.sort()
            for t in test_dirs:
                if t not in testdirs:
                    testdirs.append(t)
    else:
        for d in dirlist:
            if   os.path.basename(d) == TSTSUFF  and  os.path.isfile(os.path.join(d,"All")):
                testdirs.append(os.path.dirname(os.path.realpath(d)))
            elif os.path.isdir(os.path.join(d,TSTSUFF))  and  os.path.isfile(os.path.join(d,TSTSUFF,"All")):
                testdirs.append(os.path.realpath(d))
            else:
                Warn("No tests found in '"+d+"`; skipping directory!")

    if len(testdirs) > 1  and  testlist:
        testlist = []
        #TODO
        # WARNING
    if not testdirs:
        Warn("No tests found in "+str(dirlist)+"!")
        sys.exit(1)

    BusyPorts = []

    if THISFILE == "Mtest.py":

        if os.name == "nt":
            n = os.path.join(THISPATH,"MkillNT.")
            for x in "bat", "py":
                f = n+x
                if os.path.isfile(f):
                    shutil.copy(f,"C:"+os.sep+"Tools")

        if os.path.exists(os.path.join(env['TSTTRGBASE'],TSTPREF)):
            try:
                shutil.rmtree(os.path.join(env['TSTTRGBASE'],TSTPREF))
            except:
                ErrXit("Failed to remove %s" % os.path.join(env['TSTTRGBASE'],TSTPREF))
        if not os.path.exists(env['GDK_DBFARM']):
            #TODO: set mode to umask
            os.makedirs(env['GDK_DBFARM'])
        if env.has_key('XRPC_DOCROOT'):
            if not os.path.exists(env['XRPC_DOCROOT']):
                #TODO: set mode to umask
                os.makedirs(env['XRPC_DOCROOT'])

        if os.path.exists(os.path.join(env['GDK_DBFARM'],TSTPREF)):
            try:
                shutil.rmtree(os.path.join(env['GDK_DBFARM'],TSTPREF))
            except:
                ErrXit("Failed to remove %s" % os.path.join(env['GDK_DBFARM'],TSTPREF))
        try:
            os.makedirs(os.path.join(env['GDK_DBFARM'],TSTPREF))
        except:
            ErrXit("Failed to create %s" % os.path.join(env['GDK_DBFARM'],TSTPREF))

        os.makedirs(os.path.join(env['TSTTRGBASE'],TSTPREF))

        # write .monetdb file for mclient to do authentication with
        dotmonetdbfile = os.path.join(env['TSTTRGBASE'], ".monetdb")
        dotmonetdb = open(dotmonetdbfile, 'w')
        dotmonetdb.write('user=monetdb\n')
        dotmonetdb.write('password=monetdb\n')
        dotmonetdb.close()
        # and make mclient find it
        os.environ['DOTMONETDBFILE'] = dotmonetdbfile;

        if par['M5']:
            QUIT = 'clients.quit();\n'
        else:
            QUIT = 'quit();\n'

        env['TST_MODS'] = []
        env['TST_BITS'] = ""
        env['TST_OIDS'] = ""
        env['TST_FIVE'] = ""
        env['TST_STATIC'] = ""
        env['TST_ALGEBRA'] = ""
        env['TST_NOALGEBRA'] = ""
        if par['PACKAGE'] in ('monetdb', 'monetdb-java', 'monetdb-clients'):
            if   CONDITIONALS.has_key('BITS32') and CONDITIONALS['BITS32']:
                env['TST_BITS'] = "32bit"
            elif CONDITIONALS.has_key('BITS64') and CONDITIONALS['BITS64']:
                env['TST_BITS'] = "64bit"
            if   CONDITIONALS.has_key('LINK_STATIC') and CONDITIONALS['LINK_STATIC']:
                env['TST_STATIC'] = "STATIC"
        else:
            if Check('%s --dbname=%s' % (env['exe']['Mserver'][1], TSTPREF), QUIT):
                sys.exit(1)
            if GetBitsAndOIDsAndModsAndStatic(env):
                sys.exit(1)
        STDERR.flush()
        if not quiet:
            print "Bits: ", env['TST_BITS']
            print "OIDs: ", env['TST_OIDS']
            print "Modules: ", env['TST_MODS']
        STDOUT.flush()

        is_sql = par['PACKAGE'] == 'monetdb-sql'
        if not is_sql:
            # for backward compatibility when par['PACKAGE'] is forced back to monetdb(|4|5)
            # with packages that do not provide a <package>-config script, yet.
            am_init_sql = re.compile('AM_INIT_AUTOMAKE\("sql",.*,.*\)', re.MULTILINE)
            configure_ag = os.path.join(env['TSTSRCBASE'],"configure.ag")
            if os.path.isfile(configure_ag):
                for l in open(configure_ag):
                    if am_init_sql.match(l) and not is_sql:
                        is_sql = True
        if is_sql:
            MissingMods = CheckMods(env, '', 'SQL', '')
            if MissingMods:
                ErrXit('Stopping SQL testing as modules "%s" are missing!' % str(MissingMods))
            if par['M5']:
                mod_name = 'sql'
                mod_load = 'include %s;' % mod_name
            else:
                mod_name = 'sql_server'
                mod_load = 'module(%s);' % mod_name
            if Check('%s --dbname=%s "--dbinit=%s"' % (env['exe']['Mserver'][1], TSTPREF, mod_load), QUIT):
                ErrXit('Stopping SQL testing as module "%s" fails to load!' % mod_name)

        is_pf = par['PACKAGE'] == 'monetdb-xquery'
        if not is_pf:
            # for back-ward compatibility when par['PACKAGE'] is forced back to monetdb(|4|5)
            # with packages that do not provide a <package>-config script, yet.
            am_init_pf = re.compile('AM_INIT_AUTOMAKE\("pathfinder",.*,.*\)', re.MULTILINE)
            configure_ag = os.path.join(env['TSTSRCBASE'],"configure.ag")
            if os.path.isfile(configure_ag):
                for l in open(configure_ag):
                    if am_init_pf.match(l) and not is_pf:
                        is_pf = True
        if is_pf:
            if not CheckExec('pf'):
                ErrXit('Stopping Pathfinder testing as XQuery compiler "pf" is not available!')
            if par['ALGEBRA']:
                env['PF'] = 'pf -A'
                CONDITIONALS['WITH_ALGEBRA'] = '#'
                CONDITIONALS['NOT_ALGEBRA']  = ''
            elif par['NOALGEBRA']:
                env['PF'] = 'pf -M'
                CONDITIONALS['WITH_ALGEBRA'] = ''
                CONDITIONALS['NOT_ALGEBRA']  = '#'
            else:
                env['PF'] = 'pf'
                CONDITIONALS['WITH_ALGEBRA'] = ''
                CONDITIONALS['NOT_ALGEBRA']  = '#'
                rA = re.compile('-A.* \(default\)')
                rM = re.compile('-M.* \(default\)')
                proc = subprocess.Popen(['pf','-h'], stdin = subprocess.PIPE, stdout = subprocess.PIPE, universal_newlines = True)
                qOut, qErr = proc.communicate()
                if rA.search(qOut) is not None:
                    CONDITIONALS['WITH_ALGEBRA'] = '#'
                    CONDITIONALS['NOT_ALGEBRA']  = ''
                if rM.search(qOut) is not None:
                    CONDITIONALS['WITH_ALGEBRA'] = ''
                    CONDITIONALS['NOT_ALGEBRA']  = '#'
            if CONDITIONALS['WITH_ALGEBRA']:
                env['TST_ALGEBRA'] = "Algebra"
                os.environ['TST_ALGEBRA'] = "Algebra"
            if CONDITIONALS['NOT_ALGEBRA']:
                env['TST_NOALGEBRA'] = "NoAlgebra"
                os.environ['TST_NOALGEBRA'] = "NoAlgebra"
            os.environ['PF'] = env['PF']
            MissingMods = CheckMods(env, '', 'XQUERY', '')
            if MissingMods:
                ErrXit('Stopping Pathfinder testing as modules "%s" are missing!' % str(MissingMods))
            mod_name = 'pathfinder'
            if par['M5']:
                mod_load = 'include %s;' % mod_name
            else:
                mod_load = 'module(%s);' % mod_name
            if Check('%s --dbname=%s "--dbinit=%s"' % (env['exe']['Mserver'][1], TSTPREF, mod_load), QUIT):
                ErrXit('Stopping Pathfinder testing as module "%s" fails to load!' % mod_name)

        if par['PACKAGE'] == 'monetdb-geom':
            MissingMods = CheckMods(env, '', 'SQL', '')
            if 'geom' not in env['TST_MODS']:
                MissingMods.append('geom')
            if MissingMods:
                ErrXit('Stopping Geom testing as modules "%s" are missing!' % str(MissingMods))
            mod_name = 'geom'
            if par['M5']:
                mod_load = 'include %s;' % mod_name
            else:
                mod_load = 'module(%s);' % mod_name
            if Check('%s --dbname=%s "--dbinit=%s"' % (env['exe']['Mserver'][1], TSTPREF, mod_load), QUIT):
                ErrXit('Stopping Geom testing as module "%s" fails to load!' % mod_name)

        if par['PACKAGE'][:8] == 'monetdb-' and par['PACKAGE'][8:] in ('sql','geom'):
            if not env['exe']['SQL_Client'][0]:
                ErrXit('Stopping %s testing as "%s" is not available!' % (par['PACKAGE'][8:], env['SQLCLIENT'].split(None, 1)[0]))

        if par['PACKAGE'] == 'monetdb-xquery':
            if not env['exe']['XQuery_Client'][0]:
                ErrXit('Stopping XQuery testing as "%s" is not available!' % env['XQUERYCLIENT'].split(None, 1)[0])

        for SRVR in 'MAPI', 'XRPC':
            port = int(env[SRVR+'PORT'])
            busy, host, Serrno, Serrstr, S = CheckPort(port)
            S[0].close()
            S[1].close()
            if busy:
                Warn("Skipping %s tests as %sPORT=%s is not available on %s (Error #%d: '%s')!" % (SRVR,SRVR,env[SRVR+'PORT'],host,Serrno,Serrstr))
                BusyPorts.append(SRVR)

        # create '.Mapprove.rc'
        env['SYST'] = os.environ['SYST']
        env['RELEASE'] = os.environ['RELEASE']
        env['DIST'] = os.environ['DIST']
        env['VERSION'] = os.environ['VERSION']
        n = os.path.join(env['TSTTRGBASE'],TSTPREF,'.Mapprove.rc')
        f = open(n, 'w')
        for v in 'SYST', 'RELEASE', 'DIST', 'VERSION', 'TST_BITS', 'TST_OIDS', 'TST_FIVE', 'TST_STATIC', 'TST_ALGEBRA', 'TST_NOALGEBRA':
            w = v.replace('TST_','')
            f.write('%s = "%s"\n' % (w, env[v]))
        f.close()

    STDERR.flush()
    t_ = 0
    body = []
    if len(testdirs) == 1:
        if testlist:
            tsts = "tests "+str(testlist)
        else:
            tsts = "all tests"
        if not quiet:
            print "\nRunning %s in directory %s.\n" % (tsts , testdirs[0])
        t_, elem = PerformDir(env, testdirs[0], testlist, BusyPorts)
        if elem is not None:
            body.append(elem)
    else:
        if not quiet:
            print "\nRunning all tests in directories %s.\n" % str(testdirs)
        for d in testdirs:
            t, elem = PerformDir(env, d, [], BusyPorts)
            t_ = t_ + t
            if elem is not None:
                body.append(elem)

    if THISFILE == "Mtest.py":
        fn = os.path.join(env['TSTTRGBASE'],TSTPREF,"times.")
        fl = open(fn+"lst","w")
        Failure = [0,0,0,0,0,0,0,0]
        for TSTDIR,TST,tt,ms,FtOut,FtErr in TIMES:
            fl.write(url(os.path.join(TSTDIR,TST))+":\t"+tt+
                        "\t"+FAILURES[FtOut]+
                        "\t"+FAILURES[FtErr]+"\t\n")
            if TST != '':
                Failure[max(FtOut,FtErr)] += 1
        fl.write(":\t%7.3f\t\n" % t_)
        fl.close()

        fl = open(fn+"sql","w")
        host = socket.gethostname()
        product = os.path.split(env['TSTSRCBASE'])[-1]
        if product == 'sql':
            product += env['TST_FIVE']
            product += env['TST_ALGEBRA']
            product += env['TST_NOALGEBRA']

        compiler = ''
        # TODO:
        # use `monetdb*-config --compiler` for this
        # (and then also allow compiler-specific output)
        #if os.name == 'nt':
        #    compiler = 'Mic' # Microsoft Visual Studio C
        #    #compiler = 'Int' # Intel icc
        #else:
        #    f = os.path.join(env['TSTBLDBASE'],'Makefile')
        #    if os.path.isfile(f):
        #        r = re.compile("^CC = (.*)$", re.MULTILINE)
        #        for l in open(f):
        #            mt = r.match(l)
        #            if mt:
        #                compiler = mt.group(1)

        # start of times.sql output preparation
        try:
            from mx import DateTime
            now = "timestamp '" + str(DateTime.now()) + "'"
        except ImportError:
            now = 'now()'

        if env['TST_STATIC'] != '':
            isStatic = 'true'
        else:
            isStatic = 'false'

        # ok, we're not prepared for the 128 bits world yet
        bits = env['TST_BITS'][:2]
        oids = env['TST_OIDS'][-2:]

        # we write in SQL the same codes as testweb uses in the HTML
        # pages, for readability
        Fcodes = ['o', 'x', 'S', 'T', 'X', 'C', '-']

        # we are not interested in the compiler, not its path, nor its
        # options.  We do store the options separately, though
        hasSpace = compiler.find(' ')
        if hasSpace != -1:
            ccname = os.path.split(compiler[:hasSpace])[-1]
            ccopts = compiler[hasSpace + 1:]
        else:
            ccname = os.path.split(compiler)[-1]
            ccopts = ''

        for TSTDIR,TST,tt,ms,FtOut,FtErr in TIMES:
            if FtOut == F_SKIP and FtErr == F_SKIP:
                tms = 'NULL'
            else:
                tms = '%d' % ms

            if TST != '':
                # target is a platform and compilation options etc
                sql = """
INSERT INTO mtest (\"date\", \"machine\", \"os\", \"release\",
    \"compiler\", \"compiler_opts\", \"bits\", \"oid\", \"static\",
    \"product\", \"dir\", \"test\",
    \"time\", \"stdout\", \"stderr\")
VALUES (%s, '%s', '%s', '%s',
    '%s', '%s', %s, %s, %s,
    '%s', '%s', '%s',
    %s, '%s', '%s');
""" %(now, host, env['SYST'], env['RELEASE'],
        ccname, ccopts, bits, oids, isStatic,
        product, TSTDIR, TST,
        tms, Fcodes[FtOut], Fcodes[FtErr])
                fl.write(sql)
        fl.close()

    if THISFILE == "Mtest.py":
        env['TSTDIR'] = ""
        env['TSTTRGDIR'] = os.path.join(env['TSTTRGBASE'],TSTPREF)
        CreateHtmlIndex(env, *body)

        Failed = 0
        for f in Failure[1:]:
            Failed += f
        num_tests = 0
        for f in Failure:
            num_tests += f
        how = ""
        what = ""
        if Failure[F_SKIP]:
            what += "  %3d out of %3d tests could not be executed\n" % (Failure[F_SKIP],num_tests)
        if Failure[F_WARN]:
            how = "slightly"
            what += "  %3d out of %3d tests produced %s different output\n" % (Failure[F_WARN],num_tests,how)
        if Failure[F_SOCK]:
            how = "SIGNIFICANTLY"
            what += "  %3d out of %3d tests did not properly release socket(s)\n" % (Failure[F_SOCK],num_tests)
        if Failure[F_TIME]:
            how = "SIGNIFICANTLY"
            what += "  %3d out of %3d tests ran into timeout\n" % (Failure[F_TIME],num_tests)
        if Failure[F_KILL]:
            how = "SIGNIFICANTLY"
            what += "  %3d out of %3d tests had orphan processes killed\n" % (Failure[F_KILL],num_tests)
        if Failure[F_SEGV]:
            how = "SIGNIFICANTLY"
            what += "  %3d out of %3d tests resulted in a crash\n" % (Failure[F_SEGV],num_tests)
        if Failure[F_ERROR]:
            how = "SIGNIFICANTLY"
            what += "  %3d out of %3d tests produced %s different output\n" % (Failure[F_ERROR],num_tests,how)
        STDERR.flush()
        if Failed:
            print """\

 !ERROR:  Testing FAILED %s !

%s
 First, check the testing results in  %s  !

 Then, fix the problems by:
  - fixing sources and test scripts
  - fixing stable output by hand
  - approving test output by Mapprove.py (cf. Mapprove.py -?)

 After that, re-run Mtest.
""" % (how, what, os.path.join(env['TSTTRGBASE'],TSTPREF,"index.html"))
            sys.exit(1)
        else:
            if not quiet:
                print """\

 No differences encountered during testing.

 If necessary, you can checkin your modifications, now.
"""
            else:
                print ""
            sys.exit(0)

    if THISFILE == "Mapprove.py":
        print """\

 First, run 'cvs -q diff` to check what you have changed.

 Then, re-run Mtest.py.
"""
        if t_:
            if par['FORCE']:
                print """\
 In case (some of) the approved error messages are not correct/expected,
 re-run Mapprove.py without -f to skip their approval.
"""
            else:
                print """\
 In case (some of) the skipped error messages are correct/expected,
 re-run Mapprove.py with -f to force their approval.
"""
### main(argv) #

if __name__ == "__main__":
    if '--trace' in sys.argv:
        sys.argv.remove('--trace')
        from MonetDBtesting import trace
        t = trace.Trace(trace=1, count=0, ignoremods=('ntpath','monet_options','Mfilter','re', 'sre_parse', 'sre_compile'))
        t.runfunc(main, sys.argv)
    else:
        main(sys.argv)

#       END
#############################################################################
# vim: set ts=4 sw=4 expandtab:
