stdout of test '02_Modules_contrib` in directory 'tests/Availability` itself:


# 15:30:10 >  
# 15:30:10 >  Mtimeout -timeout 60 Mserver "--config=/ufs/boncz/MonetDB/linux/etc/monet.conf" --debug=10 --set "monet_mod_path=/ufs/boncz/MonetDB/linux/lib/MonetDB" --set "gdk_dbfarm=/ufs/boncz/MonetDB/linux/var/MonetDB/dbfarm" --set "sql_logdir=/ufs/boncz/MonetDB/linux/var/MonetDB/log" --set mapi_port=55437 --set sql_port=50559 --set monet_prompt= --trace --dbname=mTests_tests_Availability  < 02_Modules_contrib.milS
# 15:30:10 >  

# Monet Database Server V4.3.13
# Copyright (c) 1993-2004, CWI. All rights reserved.
# compiled for i686-pc-linux-gnu/32bit; dynamically linked.
setoid(oid(20000000));

var MODULES:=bat("MODULES");
var Static_fcn:=monet_fcntbl.reverse().copy();

var Fname:=new(oid,str);	Fname.col_name("function");
var FnameS:=new(oid,str);	FnameS.col_name("function");
var Ftype:=new(oid,str);	Ftype.col_name("type");
var Fsig:=new(oid,str);		Fsig.col_name("signature");
var Fhelp:=new(oid,str);	Fhelp.col_name("help");
var Fnts:=new(oid,str);

var Plain_mods:=MODULES.select("contrib").sort().copy();
table(Plain_mods.reverse().col_name(sprintf("%i modules",Plain_mods.count())));
#-----------------#
# 13 modules	  #
#-----------------#
[ "array"	  ]
[ "bat_cast"	  ]
[ "bat_mmath"	  ]
[ "bitset"	  ]
[ "bitvector"	  ]
[ "color"	  ]
[ "ddbench"	  ]
[ "image"	  ]
[ "iterator"	  ]
[ "malalgebra"	  ]
[ "mel"		  ]
[ "mprof"	  ]
[ "oo7"		  ]
[ "qt"		  ]
[ "txtsim"	  ]
[ "uchr"	  ]
[ "vector"	  ]
[ "wisc"	  ]
Plain_mods@batloop() {
	var The_mod:=$h;
	printf("\nModule: \"%s\"\n\n",The_mod);
	module($h);

	var Mod_fcn:=sdiff(monet_fcntbl.reverse(),Static_fcn).reverse();
	Mod_fcn.sort()@batloop() {
	    var addThis:=false;
	    if (not(monet_fcn_mid.exist($t))) {
		addThis:=true;
	    } else {
		var m:=monet_mod_nme.find(monet_fcn_mid.find($t));
		if (m.startsWith("_")) {
		    m:=string(m,1);
		}
		if (m = The_mod) {
		    addThis:=true;
		}
	    }
	    if (addThis) {
		var Tname:=$h;
		var Ttype:=help_tpe(monet_fcn_tpe.find($t));
		var Tsig:=format_fcn_sig($t);
		var Thelp:="";
		if (monet_fcn_dsc.exist($t)) {
			Thelp:=monet_fcn_dsc.find($t);
		} else {
			Thelp:="not available";
		}
		Fname.insert($t,Tname);
		Ftype.insert($t,Ttype);
		Fsig.insert($t,Tsig);
		Fhelp.insert($t,Thelp);
		Fnts.insert($t,sprintf("%s %s %s",Tname,Ttype,Tsig));
	    }
	}

	drop($h);
	Static_fcn:=sunion(Static_fcn,monet_fcntbl.reverse());

	Fnts.count().print();
	Fnts.reverse().sort().reverse()@batloop() {
		FnameS.insert($h,Fname.find($h));
	}
	FnameS.count().print(); table(1,FnameS,Ftype,Fsig,Fhelp);

	Fname.delete();
	FnameS.delete();
	Ftype.delete();
	Fsig.delete();
	Fhelp.delete();
	Fnts.delete();
}

Module: "array"

[ 5 ]
[ 5 ]
#---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------#
# function		type		signature								help									  # name
#---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------#
[ "concat",	  "PROC:      ",  "concat(BAT[oid,any::1], BAT[oid,any::1], int) : BAT[oid,any::1]",	  "Adds 'offset' two second arrays indexes and merges tables"		  ]
[ "cons",	  "PROC:      ",  "cons(int, any::1) : BAT[void,any::1]",				  "generates a bat with a constant column"				  ]
[ "grid",	  "COMMAND:   ",  "grid(int, int, int, int) : BAT[void,int]",				  "Generates an index BAT, (grpcount,grpsize,clustersize,offset)"	  ]
[ "grid",	  "COMMAND:   ",  "grid(lng, lng, lng, lng) : BAT[void,lng]",				  "Generates an index BAT, (grpcount,grpsize,clustersize,offset)"	  ]
[ "print_array",  "COMMAND:   ",  "print_array(BAT[any::1,any], ..BAT[any::1,int]..) : void",		  "Prints an array, using 1 value bat and N aligned index bats"		  ]

Module: "bat_cast"

[ 2 ]
[ 2 ]
#---------------------------------------------------------------------------------------------------------------------------------#
# function		type		signature				help							  # name
#---------------------------------------------------------------------------------------------------------------------------------#
[ "[dbl]",	  "COMMAND:   ",  "[dbl](BAT[void,int]) : BAT[void,dbl]", "optimized multiplexed dbl-cast on [void,int] BATs"	  ]
[ "[oid]",	  "COMMAND:   ",  "[oid](BAT[void,int]) : BAT[void,oid]", "optimized multiplexed oid-cast on [void,int] BATs"	  ]

Module: "bat_mmath"

[ 6 ]
[ 6 ]
#---------------------------------------------------------------------------------------------------------------------------------------------------------#
# function		type		signature						help								  # name
#---------------------------------------------------------------------------------------------------------------------------------------------------------#
[ "[exp]",	  "COMMAND:   ",  "[exp](BAT[void,dbl]) : BAT[void,dbl]",		  "optimized multiplexed exp on [void,dbl] BATs"		  ]
[ "[log]",	  "COMMAND:   ",  "[log](BAT[void,dbl]) : BAT[void,dbl]",		  "optimized multiplexed log on [void,dbl] BATs"		  ]
[ "[pow]",	  "COMMAND:   ",  "[pow](BAT[void,dbl], BAT[void,dbl]) : BAT[void,dbl]",  "optimized multiplexed pow on head-aligned [void,dbl] BATs"	  ]
[ "[pow]",	  "COMMAND:   ",  "[pow](BAT[void,dbl], dbl) : BAT[void,dbl]",		  "optimized multiplexed right-scalar pow on [void,dbl] BAT"	  ]
[ "[pow]",	  "COMMAND:   ",  "[pow](dbl, BAT[void,dbl]) : BAT[void,dbl]",		  "optimized multiplexed left-scalar pow on [void,dbl] BAT"	  ]
[ "[sqrt]",	  "COMMAND:   ",  "[sqrt](BAT[void,dbl]) : BAT[void,dbl]",		  "optimized multiplexed sqrt on [void,dbl] BATs"		  ]

Module: "bitset"

[ 13 ]
[ 13 ]
#-------------------------------------------------------------------------------------------------------------------------------------------------#
# function		| type		| signature					| help							  #
#-------------------------------------------------------------------------------------------------------------------------------------------------#
[ "bitset_and",		  "COMMAND:   ",  "bitset_and(bitset, bitset) : bitset",	  "AND this BitSet with an other BitSet."		  ]
[ "bitset_clearBit",	  "COMMAND:   ",  "bitset_clearBit(bitset, int) : bitset",	  "Clear the specified bit in this BitSet."		  ]
[ "bitset_flipBit",	  "COMMAND:   ",  "bitset_flipBit(bitset, int) : bitset",	  "Flip the specified bit in this BitSet."		  ]
[ "bitset_getBit",	  "COMMAND:   ",  "bitset_getBit(bitset, int) : bit",		  "Get the specified bit from this BitSet."		  ]
[ "bitset_not",		  "COMMAND:   ",  "bitset_not(bitset) : bitset",		  "NOT this BitSet."					  ]
[ "bitset_or",		  "COMMAND:   ",  "bitset_or(bitset, bitset) : bitset",		  "OR this BitSet with an other BitSet."		  ]
[ "bitset_setBit",	  "COMMAND:   ",  "bitset_setBit(bitset, int) : bitset",	  "Set the specified bit from this BitSet."		  ]
[ "bitset_toInt",	  "COMMAND:   ",  "bitset_toInt(bitset) : int",			  "Convert this BitSet to an integer."			  ]
[ "bitset_toStr",	  "PROC:      ",  "bitset_toStr(bitset) : str",			  "not available"					  ]
[ "bitset_xor",		  "COMMAND:   ",  "bitset_xor(bitset, bitset) : bitset",	  "XOR this BitSet with an other BitSet."		  ]
[ "newBitset",		  "COMMAND:   ",  "newBitset() : bitset",			  "Create a new empty BitSet."				  ]
[ "newBitset",		  "COMMAND:   ",  "newBitset(int) : bitset",			  "Create a new BitSet from an existing integer."	  ]
[ "test_bitset",	  "PROC:      ",  "test_bitset() : void",			  "not available"					  ]

Module: "bitvector"

[ 12 ]
[ 12 ]
#---------------------------------------------------------------------------------------------------------------------------------------------------------#
# function		| type		| signature						| help							  #
#---------------------------------------------------------------------------------------------------------------------------------------------------------#
[ "[allocate]",		  "COMMAND:   ",  "[allocate](int, bit) : BAT[void,lng]",		  "Allocate a new and empty bitvector"			  ]
[ "[and]",		  "COMMAND:   ",  "[and](BAT[void,lng], BAT[void,lng]) : BAT[void,lng]",  "Logically ANDs two bitvectors"			  ]
[ "[clr]",		  "COMMAND:   ",  "[clr](BAT[any::1,lng], int) : void",			  "Clear a bit in a bitvector"				  ]
[ "[count]",		  "COMMAND:   ",  "[count](BAT[void,lng]) : int",			  "Count the number of bits set"			  ]
[ "[decode]",		  "COMMAND:   ",  "[decode](BAT[void,lng]) : BAT[oid,oid]",		  "Decodes a bitvector into a real BAT"			  ]
[ "[encode]",		  "COMMAND:   ",  "[encode](BAT[any::1,oid]) : BAT[void,lng]",		  "Encode a BAT with tail values into a bitvector"	  ]
[ "[isclr]",		  "COMMAND:   ",  "[isclr](BAT[any::1,lng], int) : bit",		  "Is bit bnum not set?"				  ]
[ "[isset]",		  "COMMAND:   ",  "[isset](BAT[any::1,lng], int) : bit",		  "Is bit bnum set?"					  ]
[ "[or]",		  "COMMAND:   ",  "[or](BAT[void,lng], BAT[void,lng]) : BAT[void,lng]",	  "Logically ORs two bitvectors"			  ]
[ "[prt]",		  "COMMAND:   ",  "[prt](BAT[void,lng]) : void",			  "Print a bitvector"					  ]
[ "[set]",		  "COMMAND:   ",  "[set](BAT[any::1,lng], int) : void",			  "Set a bit in a bitvector"				  ]
[ "test_bitvector",	  "PROC:      ",  "test_bitvector() : void",				  "not available"					  ]

Module: "color"

[ 12 ]
[ 12 ]
#-------------------------------------------------------------------------------------------------------------------------#
# function		type		signature			help							  # name
#-------------------------------------------------------------------------------------------------------------------------#
[ "blue",	  "COMMAND:   ",  "blue(color) : int",		  "Extracts blue component from a color atom"		  ]
[ "cb",		  "COMMAND:   ",  "cb(color) : int",		  "Extracts Cb(blue color) component from a color atom"	  ]
[ "cr",		  "COMMAND:   ",  "cr(color) : int",		  "Extracts Cr(red color) component from a color atom"	  ]
[ "green",	  "COMMAND:   ",  "green(color) : int",		  "Extracts green component from a color atom"		  ]
[ "hsv",	  "COMMAND:   ",  "hsv(flt, flt, flt) : color",	  "Converts an HSV triplets to a color atom"		  ]
[ "hue",	  "COMMAND:   ",  "hue(color) : flt",		  "Extracts hue component from a color atom"		  ]
[ "luminance",	  "COMMAND:   ",  "luminance(color) : int",	  "Extracts Y(luminance) component from a color atom"	  ]
[ "red",	  "COMMAND:   ",  "red(color) : int",		  "Extracts red component from a color atom"		  ]
[ "rgb",	  "COMMAND:   ",  "rgb(int, int, int) : color",	  "Converts an RGB triplets to a color atom"		  ]
[ "saturation",	  "COMMAND:   ",  "saturation(color) : flt",	  "Extracts saturation component from a color atom"	  ]
[ "value",	  "COMMAND:   ",  "value(color) : flt",		  "Extracts value component from a color atom"		  ]
[ "ycc",	  "COMMAND:   ",  "ycc(int, int, int) : color",	  "Converts an YCC triplets to a color atom"		  ]

Module: "ddbench"

[ 55 ]
[ 55 ]
#---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------#
# function		| type		| signature										| help																																													  #
#---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------#
[ "CTderive",		  "PROC:      ",  "CTderive(BAT[oid,any], BAT[oid,any]) : grp",						  "not available"																																											  ]
[ "CTgroup",		  "PROC:      ",  "CTgroup(BAT[oid,any], BAT[oid,any]) : grp",						  "not available"																																											  ]
[ "CTorderby",		  "PROC:      ",  "CTorderby(BAT[oid,any], BAT[oid,any]) : BAT[oid,oid]",				  "not available"																																											  ]
[ "CTorderby_rev",	  "PROC:      ",  "CTorderby_rev(BAT[oid,any], BAT[oid,any]) : BAT[oid,oid]",				  "not available"																																											  ]
[ "CTsubgroup",		  "PROC:      ",  "CTsubgroup(BAT[oid,oid], BAT[oid,any], BAT[oid,any]) : BAT[oid,oid]",		  "not available"																																											  ]
[ "enum_group",		  "COMMAND:   ",  "enum_group(BAT[void,any], BAT[void,any]) : BAT[void,any]",				  "optimized group: use a byte-array[card(ct)*card(b)] instead of a hash\n\t           table and directly create enumerated group oid-s"																												  ]
[ "enum_join",		  "COMMAND:   ",  "enum_join(BAT[any::1,void], BAT[any,any::2]) : BAT[any::1,any::2]",			  "positional join if the b2 head type is an enumerated oid"																																						  ]
[ "enum_semijoin",	  "COMMAND:   ",  "enum_semijoin(BAT[void,any::1], BAT[any,any]) : BAT[oid,any::1]",			  "positional semijoin if the b2 head type is an enumerated oid"																																					  ]
[ "enum_view",		  "COMMAND:   ",  "enum_view(BAT[void,any]) : BAT[oid,int]",						  "produces a histogram that is an adaptation of the enum-lookup table\n  of the tail of b. Its head column differs: it contains oids; namely \n  the first oid of 'b' where the original lookup head value occured\n  in the tail of 'b'. In other words :-), this produces the lookup\n  table needed to create an 'enumeration view' that represents CTgroup(b)."	  ]
[ "extend",		  "PROC:      ",  "extend(grp) : BAT[any,int]",								  "not available"																																											  ]
[ "fclose",		  "PROC:      ",  "fclose(Stream) : void",								  "not available"																																											  ]
[ "fflush",		  "PROC:      ",  "fflush(Stream) : void",								  "not available"																																											  ]
[ "fopen",		  "PROC:      ",  "fopen(str, str) : Stream",								  "not available"																																											  ]
[ "fputs",		  "PROC:      ",  "fputs(str, Stream) : void",								  "not available"																																											  ]
[ "group",		  "PROC:      ",  "group(BAT[oid,any]) : BAT[oid,oid]",							  "not available"																																											  ]
[ "group",		  "PROC:      ",  "group(BAT[oid,any], BAT[oid,any]) : BAT[oid,any]",					  "not available"																																											  ]
[ "group",		  "PROC:      ",  "group(BAT[void,any]) : BAT[oid,oid]",						  "not available"																																											  ]
[ "group",		  "PROC:      ",  "group(BAT[void,any], BAT[void,any]) : BAT[oid,any]",					  "not available"																																											  ]
[ "histogram",		  "PROC:      ",  "histogram(grp) : BAT[any,int]",							  "not available"																																											  ]
[ "kintersect",		  "COMMAND:   ",  "kintersect(BAT[oid,any::1], BAT[void,bit32]) : BAT[oid,any::1]",			  "do b.semijoin(sel.tobat); b must be dense and sel must correspond to it.\n"																																				  ]
[ "map",		  "PROC:      ",  "map(grp) : BAT[oid,oid]",								  "not available"																																											  ]
[ "mjoin",		  "PROC:      ",  "mjoin(BAT[any::1,any::3], BAT[any::3,any::2]) : BAT[any::1,any::2]",			  "not available"																																											  ]
[ "mjoin",		  "PROC:      ",  "mjoin(BAT[any::1,any], BAT[void,any::2]) : BAT[any::1,any::2]",			  "not available"																																											  ]
[ "mjoin",		  "PROC:      ",  "mjoin(BAT[any::1,void], BAT[any,any::2]) : BAT[any::1,any::2]",			  "not available"																																											  ]
[ "not",		  "PROC:      ",  "not(BAT[void,bit32]) : BAT[void,bit32]",						  "not available"																																											  ]
[ "orderby_table",	  "PROC:      ",  "orderby_table(str, str, ..BAT[any::1,any]..) : void",				  "not available"																																											  ]
[ "print",		  "PROC:      ",  "print(str, BAT[any::1,any], ..BAT[any::1,any]..) : void",				  "not available"																																											  ]
[ "refine",		  "COMMAND:   ",  "refine(BAT[oid,void], BAT[oid,any::1], any::1) : BAT[oid,void]",			  "like val_oidsubsel(sel,b,v), but *OVERWRITES* sel with result."																																					  ]
[ "refine",		  "COMMAND:   ",  "refine(BAT[oid,void], BAT[oid,any::1], any::1, any::1) : BAT[oid,void]",		  "like rng_oidsubsel(sel,b,lo,hi), but *OVERWRITES* sel with result."																																					  ]
[ "refine",		  "COMMAND:   ",  "refine(BAT[void,bit32], BAT[oid,any::1], any::1) : BAT[void,bit32]",			  "like val_bitsubsel(sel,b,v), but *OVERWRITES* sel with result."																																					  ]
[ "refine",		  "COMMAND:   ",  "refine(BAT[void,bit32], BAT[oid,any::1], any::1, any::1) : BAT[void,bit32]",		  "like rng_bitsubsel(sel,b,lo,hi), but *OVERWRITES* sel with result."																																					  ]
[ "rng_bitselect",	  "COMMAND:   ",  "rng_bitselect(BAT[oid,any::1], any::1, any::1) : BAT[void,bit32]",			  "do a range-scan rangeselect, but output the result as a bitmask, partitioned\n  in 32-bits integers. "																																  ]
[ "rng_oidselect",	  "COMMAND:   ",  "rng_oidselect(BAT[oid,any::1], any::1, any::1) : BAT[void,oid]",			  "uselect, optimized for enumeration types"																																								  ]
[ "rngs_bitselect",	  "COMMAND:   ",  "rngs_bitselect(BAT[oid,any::1], any::1, any::1, ..any::1..) : BAT[int,BAT]",		  "computes multiple bitmasks for each equi-select 'v' on 'sel'"																																					  ]
[ "rngs_oidselect",	  "COMMAND:   ",  "rngs_oidselect(BAT[oid,any::1], any::1, any::1, ..any::1..) : BAT[int,BAT]",		  "uselect, optimized for enum types, on multiple range-select predicates"																																				  ]
[ "semijoin",		  "PROC:      ",  "semijoin(BAT[void,any::1], BAT[any,any]) : BAT[oid,any::1]",				  "not available"																																											  ]
[ "semijoin",		  "PROC:      ",  "semijoin(BAT[void,bit32], BAT[void,bit32]) : BAT[void,bit32]",			  "not available"																																											  ]
[ "stats",		  "COMMAND:   ",  "stats(BAT[void,bit32]) : BAT[str,lng]",						  "produce info on this bit-selection"																																									  ]
[ "subhisto",		  "COMMAND:   ",  "subhisto(BAT[oid,any::1], BAT[oid,any]) : BAT[any,int]",				  "computes a subset-histogram on b, receiving the subset as a selection BAT"																																				  ]
[ "subhisto",		  "COMMAND:   ",  "subhisto(BAT[oid,any::1], BAT[void,bit32]) : BAT[any,int]",				  "computes a subset-histogram on b, receiving the subset as a bitmask"																																					  ]
[ "subhistos",		  "COMMAND:   ",  "subhistos(BAT[oid,any::1], ..BAT[void,bit32]..) : BAT[int,BAT]",			  "computes multiple subset-histograms on b, receiving multiple bitmasks"																																				  ]
[ "subselect",		  "COMMAND:   ",  "subselect(BAT[oid,void], BAT[oid,any::1], any::1) : BAT[oid,void]",			  "uselect, on b.semijoin(sel), optimized for enum types"																																						  ]
[ "subselect",		  "COMMAND:   ",  "subselect(BAT[oid,void], BAT[oid,any::1], any::1, any::1) : BAT[oid,void]",		  "uselect, on b.semijoin(sel), optimized for enum types"																																						  ]
[ "subselect",		  "COMMAND:   ",  "subselect(BAT[void,bit32], BAT[oid,any::1], any::1) : BAT[void,bit32]",		  "do a bitselect on the subset indicated by the first BAT param"																																					  ]
[ "subselect",		  "COMMAND:   ",  "subselect(BAT[void,bit32], BAT[oid,any::1], any::1, any::1) : BAT[void,bit32]",	  "do a bitselect on the subset indicated by the first BAT param"																																					  ]
[ "table",		  "PROC:      ",  "table(str, BAT[any::1,any], ..BAT[any::1,any]..) : void",				  "not available"																																											  ]
[ "test_ddbench",	  "PROC:      ",  "test_ddbench() : void",								  "not available"																																											  ]
[ "tobat",		  "COMMAND:   ",  "tobat(BAT[void,bit32]) : BAT[oid,void]",						  "convert a bat[void,bit32] bitmap selection into a BAT of oids"																																					  ]
[ "val_bitselect",	  "COMMAND:   ",  "val_bitselect(BAT[oid,any::1], any::1) : BAT[void,bit32]",				  "do a range-scan equiselect, but output the result as a bitmask, partitioned\n  in 32-bits integers. "																																  ]
[ "val_oidselect",	  "COMMAND:   ",  "val_oidselect(BAT[oid,any::1], any::1) : BAT[void,oid]",				  "uselect, optimized for enumeration types"																																								  ]
[ "vals_bitselect",	  "COMMAND:   ",  "vals_bitselect(BAT[oid,any::1], any::1, ..any::1..) : BAT[int,BAT]",			  "computes multiple bitmasks for each equi-select 'v' on 'sel'"																																					  ]
[ "vals_oidselect",	  "COMMAND:   ",  "vals_oidselect(BAT[oid,any::1], any::1, ..any::1..) : BAT[int,BAT]",			  "uselect, optimized for enum types, on multiple equi-select predicates"																																				  ]
[ "{count}",		  "PROC:      ",  "{count}(BAT[any::1,any]) : BAT[any::1,int]",						  "not available"																																											  ]
[ "{count}",		  "PROC:      ",  "{count}(BAT[oid,bit], BAT[oid,oid], BAT[oid,int]) : BAT[oid,int]",			  "not available"																																											  ]
[ "{count}",		  "PROC:      ",  "{count}(BAT[void,bit], BAT[void,oid], BAT[oid,int]) : BAT[oid,int]",			  "not available"																																											  ]

Module: "image"

[ 0 ]
[ 0 ]
#-------------------------------------------------#
# function		type		signature		help			  # name
# str		str	str		str	  # type
#-------------------------------------------------#

Module: "iterator"

[ 16 ]
[ 16 ]
#-----------------------------------------------------------------------------------------------------------------------------------------------------------------#
# function		| type		| signature						| help								  #
#-----------------------------------------------------------------------------------------------------------------------------------------------------------------#
[ "aggr",		  "COMMAND:   ",  "aggr(iter, str, BAT[oid,any::1]) : BAT[any,any::1]",	  "groupby-aggregate(attr), aggr in {max,min,sum,avg}"		  ]
[ "chunk",		  "COMMAND:   ",  "chunk(iter) : BAT[any,any]",				  "get the next chunk"						  ]
[ "chunksize",		  "COMMAND:   ",  "chunksize() : int",					  "return the iterator chunksize (default=1)"			  ]
[ "chunksize",		  "COMMAND:   ",  "chunksize(int) : void",				  "set the iterator chunksize"					  ]
[ "collect",		  "COMMAND:   ",  "collect(iter) : BAT[any,any]",			  "recursively execute an iterator; collect results in a bat"	  ]
[ "count",		  "COMMAND:   ",  "count(iter) : int",					  "recursively execute an iterator; just count the elements"	  ]
[ "histo",		  "COMMAND:   ",  "histo(iter) : BAT[any,int]",				  "groupby-count on tail"					  ]
[ "join",		  "COMMAND:   ",  "join(iter, BAT[any,any]) : iter",			  "hash-join iterator"						  ]
[ "mark",		  "COMMAND:   ",  "mark(iter, oid) : iter",				  "mark tail buns of the input iterator"			  ]
[ "mirror",		  "COMMAND:   ",  "mirror(iter) : iter",				  "mirror buns (both head) in the input iterator"		  ]
[ "next",		  "COMMAND:   ",  "next(iter) : bit",					  "false: no more chunks / true: iter contains next chunk"	  ]
[ "reverse",		  "COMMAND:   ",  "reverse(iter) : iter",				  "reverse the buns in the input iterator"			  ]
[ "scan",		  "COMMAND:   ",  "scan(BAT[any,any]) : iter",				  "sequential-scan on bat"					  ]
[ "select",		  "COMMAND:   ",  "select(iter, bit, str, any) : iter",			  "select on tail (fcn in {eq,=,!=,<,>,<=,>=,..})"		  ]
[ "select",		  "COMMAND:   ",  "select(iter, bit, str, any, any) : iter",		  "select on tail (fcn in {rng,..})"				  ]
[ "test_iterator",	  "PROC:      ",  "test_iterator() : void",				  "not available"						  ]

Module: "malalgebra"

[ 30 ]
[ 30 ]
#-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------#
# function			type		signature									help																													  # name
# str			str		str										str																													  # type
#-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------#
[ "fetchjoin",		  "COMMAND:   ",  "fetchjoin(BAT[any::1,any::2], BAT[any::2,any::3]) : BAT[any::1,any::3]",	  "Hook directly into the 'fetchjoin' implementation of the join."																						  ]
[ "hashjoin",		  "COMMAND:   ",  "hashjoin(BAT[any::1,any::2], BAT[any::2,any::3]) : BAT[any::1,any::3]",	  "Hook directly into the 'hashjoin' implementation of the join."																						  ]
[ "leftfetchjoin",	  "COMMAND:   ",  "leftfetchjoin(BAT[any::1,any::2], BAT[any::2,any::3]) : BAT[any::1,any::3]",		  "Hook directly into the 'leftfetchjoin' implementation of the join.\n   prefix 'left' means that left and right input are not swapped during processing,\n   and hence, the order of the left input's head is maintained in the result."																							  ]
[ "lefthashjoin",	  "COMMAND:   ",  "lefthashjoin(BAT[any::1,any::2], BAT[any::2,any::3]) : BAT[any::1,any::3]",		  "Hook directly into the 'lefthashjoin' implementation of the join.\n   prefix 'left' means that left and right input are not swapped during processing,\n   and hence, the order of the left input's head is maintained in the result."																							  ]
[ "leftjoin",		  "COMMAND:   ",  "leftjoin(BAT[any::1,any::2], BAT[any::2,any::3]) : BAT[any::1,any::3]",		  "Hook directly into the 'leftjoin' implementation of the join.\n   prefix 'left' means that left and right input are not swapped during processing,\n   and hence, the order of the left input's head is maintained in the result."																								  ]
[ "leftmergejoin",	  "COMMAND:   ",  "leftmergejoin(BAT[any::1,any::2], BAT[any::2,any::3]) : BAT[any::1,any::3]",		  "Hook directly into the 'leftmergejoin' implementation of the join.\n   prefix 'left' means that left and right input are not swapped during processing,\n   and hence, the order of the left input's head is maintained in the result."																							  ]
[ "leftthetajoin",	  "COMMAND:   ",  "leftthetajoin(BAT[any::1,any::2], BAT[any::2,any::3], int) : BAT[any::1,any::3]",	  "Hook directly into the 'leftthetajoin' implementation of the join.\n   prefix 'left' means that left and right input are not swapped during processing,\n   and hence, the order of the left input's head is maintained in the result."																							  ]
[ "mergejoin",		  "COMMAND:   ",  "mergejoin(BAT[any::1,any::2], BAT[any::2,any::3]) : BAT[any::1,any::3]",	  "Hook directly into the 'mergejoin' implementation of the join."																						  ]
[ "nlthetajoin",	  "COMMAND:   ",  "nlthetajoin(BAT[any::1,any::2], BAT[any::2,any::3], int, lng) : BAT[any::1,any::3]",	  "Hook directly into the 'nested-loop-thetajoin' implementation of the join.\n   prefix 'left' means that left and right input are not swapped during processing,\n   and hence, the order of the left input's head is maintained in the result.\n   Also, for each left tuple, all matching right tuples will appear in their order\n   of appearrance in the right BAT. This property is handy for XQuery processing."	  ]
[ "ord_select",		  "COMMAND:   ",  "ord_select(BAT[any::1,any::2], any::2) : BAT[any::1,any::2]",			  "Like standard 'select(b, value);', but preserves the order of the input BAT;\n (for the time being) this means, only the scan-based select algorithm is used."										  ]
[ "ord_select",		  "COMMAND:   ",  "ord_select(BAT[any::1,any::2], any::2, any::2) : BAT[any::1,any::2]",		  "Like standard 'select(b, low, high);', but preserves the order of the input BAT;\n (for the time being) this means, only the scan-based select algorithm is used."										  ]
[ "ord_select",		  "COMMAND:   ",  "ord_select(BAT[any::1,any::2], any::2, any::2, bit, bit) : BAT[any::1,any::2]",	  "Like standard 'select(b, low, high, l_in, h_in);', but preserves the order of the input BAT;\n (for the time being) this means, only the scan-based select algorithm is used."								  ]
[ "ord_uselect",	  "COMMAND:   ",  "ord_uselect(BAT[any::1,any::2], any::2) : BAT[any::1,void]",				  "Like standard 'uselect(b, value);', but preserves the order of the input BAT;\n (for the time being) this means, only the scan-based select algorithm is used."										  ]
[ "ord_uselect",	  "COMMAND:   ",  "ord_uselect(BAT[any::1,any::2], any::2, any::2) : BAT[any::1,void]",			  "Like standard 'uselect(b, low, high);', but preserves the order of the input BAT;\n (for the time being) this means, only the scan-based select algorithm is used."										  ]
[ "ord_uselect",	  "COMMAND:   ",  "ord_uselect(BAT[any::1,any::2], any::2, any::2, bit, bit) : BAT[any::1,void]",	  "Like standard 'uselect(b, low, high, l_in, h_in);', but preserves the order of the input BAT;\n (for the time being) this means, only the scan-based select algorithm is used."								  ]
[ "test_malalgebra",	  "PROC:      ",  "test_malalgebra() : void",							  "not available"						  ]
[ "{_csum}",		  "COMMAND:   ",  "{_csum}(BAT[oid,bte]) : BAT[oid,bte]",						  "grouped tail sum"																																																		  ]
[ "{_csum}",		  "COMMAND:   ",  "{_csum}(BAT[oid,dbl]) : BAT[oid,dbl]",					  "grouped tail sum"						  ]
[ "{_csum}",		  "COMMAND:   ",  "{_csum}(BAT[oid,flt]) : BAT[oid,flt]",					  "grouped tail sum"						  ]
[ "{_csum}",		  "COMMAND:   ",  "{_csum}(BAT[oid,int]) : BAT[oid,int]",					  "grouped tail sum"						  ]
[ "{_csum}",		  "COMMAND:   ",  "{_csum}(BAT[oid,lng]) : BAT[oid,lng]",					  "grouped tail sum"						  ]
[ "{_csum}",		  "COMMAND:   ",  "{_csum}(BAT[oid,sht]) : BAT[oid,sht]",					  "grouped tail sum"						  ]
[ "{_csum}",		  "COMMAND:   ",  "{_csum}(BAT[oid,wrd]) : BAT[oid,wrd]",						  "grouped tail sum"																																																		  ]
[ "{csum}",		  "PROC:      ",  "{csum}(BAT[oid,bte]) : BAT[oid,bte]",						  "Choose a different implementation if b is sorted on head."																																													  ]
[ "{csum}",		  "PROC:      ",  "{csum}(BAT[oid,dbl]) : BAT[oid,dbl]",					  "Choose a different implementation if b is sorted on head."	  ]
[ "{csum}",		  "PROC:      ",  "{csum}(BAT[oid,flt]) : BAT[oid,flt]",					  "Choose a different implementation if b is sorted on head."	  ]
[ "{csum}",		  "PROC:      ",  "{csum}(BAT[oid,int]) : BAT[oid,int]",					  "Choose a different implementation if b is sorted on head."	  ]
[ "{csum}",		  "PROC:      ",  "{csum}(BAT[oid,lng]) : BAT[oid,lng]",					  "Choose a different implementation if b is sorted on head."	  ]
[ "{csum}",		  "PROC:      ",  "{csum}(BAT[oid,sht]) : BAT[oid,sht]",					  "Choose a different implementation if b is sorted on head."	  ]
[ "{csum}",		  "PROC:      ",  "{csum}(BAT[oid,wrd]) : BAT[oid,wrd]",						  "Choose a different implementation if b is sorted on head."																																													  ]

Module: "mel"

[ 2 ]
[ 2 ]
#---------------------------------------------------------------------------------#
# function	| type		| signature		| help			  #
#---------------------------------------------------------------------------------#
[ "mel_test",	  "PROC:      ",  "mel_test() : void",	  "not available"	  ]
[ "test_mel",	  "PROC:      ",  "test_mel() : void",	  "not available"	  ]

Module: "mprof"

[ 31 ]
[ 31 ]
#-------------------------------------------------------------------------------------------------------------------------------------------------#
# function		| type		| signature					| help							  #
#-------------------------------------------------------------------------------------------------------------------------------------------------#
[ "-",			  "OPERATOR:  ",  "-(Mallinfo, Mallinfo) : Mallinfo",		  "Subtract the memory info records"			  ]
[ "-",			  "OPERATOR:  ",  "-(Rusage, Rusage) : Rusage",			  "Subtract the io and swap records"			  ]
[ "-",			  "OPERATOR:  ",  "-(Tms, Tms) : Tms",				  "Subtract the timing records"				  ]
[ "Ma_arena",		  "COMMAND:   ",  "Ma_arena(Mallinfo) : int",			  "Dynamic allocated arena size"			  ]
[ "Ma_fordblks",	  "COMMAND:   ",  "Ma_fordblks(Mallinfo) : int",		  "Free ordinary blocks in arena"			  ]
[ "Ma_fsmblks",		  "COMMAND:   ",  "Ma_fsmblks(Mallinfo) : int",			  "Free small blocks in arena"				  ]
[ "Ma_new",		  "COMMAND:   ",  "Ma_new() : Mallinfo",			  "Get malloc information"				  ]
[ "Ma_uordblks",	  "COMMAND:   ",  "Ma_uordblks(Mallinfo) : int",		  "Used ordinary blocks in arena"			  ]
[ "Ma_usmblks",		  "COMMAND:   ",  "Ma_usmblks(Mallinfo) : int",			  "Used small blocks in arena"				  ]
[ "Ru_inblock",		  "COMMAND:   ",  "Ru_inblock(Rusage) : int",			  "Extract the actual physical read count"		  ]
[ "Ru_majflt",		  "COMMAND:   ",  "Ru_majflt(Rusage) : int",			  "Extract the major page faults"			  ]
[ "Ru_maxrss",		  "COMMAND:   ",  "Ru_maxrss(Rusage) : int",			  "Extract the maximum resident set size utilized"	  ]
[ "Ru_minflt",		  "COMMAND:   ",  "Ru_minflt(Rusage) : int",			  "Extract the minor page faults"			  ]
[ "Ru_new",		  "COMMAND:   ",  "Ru_new() : Rusage",				  "Extract system resource usage record"		  ]
[ "Ru_nivcsw",		  "COMMAND:   ",  "Ru_nivcsw(Rusage) : int",			  "Extract the non-voluntary context switch count"	  ]
[ "Ru_nswap",		  "COMMAND:   ",  "Ru_nswap(Rusage) : int",			  "Extract the actual process swap count"		  ]
[ "Ru_nvcsw",		  "COMMAND:   ",  "Ru_nvcsw(Rusage) : int",			  "Extract the voluntary context switch count"		  ]
[ "Ru_oublock",		  "COMMAND:   ",  "Ru_oublock(Rusage) : int",			  "Extract the actual physical write count"		  ]
[ "Tms_new",		  "COMMAND:   ",  "Tms_new() : Tms",				  "Create a new Tms record"				  ]
[ "Tms_stime",		  "COMMAND:   ",  "Tms_stime(Tms) : int",			  "Extract the system time part from the record"	  ]
[ "Tms_utime",		  "COMMAND:   ",  "Tms_utime(Tms) : int",			  "Extract the user time part from the record"		  ]
[ "emptyMallinfo",	  "PROC:      ",  "emptyMallinfo() : Mallinfo",			  "not available"					  ]
[ "insB",		  "COMMAND:   ",  "insB(str, int, Tms, Rusage, Mallinfo) : int",  "Insert the begin of a new labelled time period"	  ]
[ "insE",		  "COMMAND:   ",  "insE(str, int, Tms, Rusage, Mallinfo) : int",  "Insert the end of a new labelled time period"	  ]
[ "pmB",		  "COMMAND:   ",  "pmB(str) : int",				  "Start a new labelled timing period"			  ]
[ "pmClear",		  "COMMAND:   ",  "pmClear() : void",				  "Clear the performance bats"				  ]
[ "pmE",		  "COMMAND:   ",  "pmE(str) : int",				  "End a labelled timing period"			  ]
[ "pmPrint",		  "PROC:      ",  "pmPrint() : void",				  "not available"					  ]
[ "pmSummary",		  "PROC:      ",  "pmSummary() : void",				  "not available"					  ]
[ "pmTag",		  "COMMAND:   ",  "pmTag(str, str) : void",			  "Add comment to a timing period"			  ]
[ "test_mprof",		  "PROC:      ",  "test_mprof() : void",			  "not available"					  ]

Module: "oo7"

[ 5 ]
[ 5 ]
#-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------#
# function	| type		| signature									| help																																		  #
#-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------#
[ "closure",	  "COMMAND:   ",  "closure(BAT[any::1,any::1]) : BAT[any::1,any::1]",				  "Computes the transitive closure of all points in the 'edges'\ngraph. Breadth-first traversal is used (repeated forward joins)."																		  ]
[ "oo7create",	  "COMMAND:   ",  "oo7create(str) : void",							  "Create the OO7 database schema and fill it. Run with -help for info."																									  ]
[ "oo7delete",	  "COMMAND:   ",  "oo7delete() : void",								  "Delete all OO7 tables."																															  ]
[ "subgraph",	  "COMMAND:   ",  "subgraph(BAT[any::2,any::1], BAT[any::1,any::1]) : BAT[any::1,any::1]",	  "Uses the tail values from 'in' as starting points, and\ndetermines by recursive traversal which subgraph of 'edges'\ncan be reached from there. This subgraph is returned.\n\nTraversal order is currently breadth-first.\n\nWorks only on ANY::1 e {int,oid,flt,bat,ptr}. "	  ]
[ "traverse",	  "COMMAND:   ",  "traverse(BAT[any::2,any::1], BAT[any::1,any::1]) : BAT[any::1,any::1]",	  "From the starting points in 'in' (tail), compute all\nreachable points by (dag!) 'edges'."																							  ]

Module: "qt"

[ 10 ]
[ 10 ]
#---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------#
# function			| type		| signature																					| help																																																															  #
#---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------#
[ "[qt_cross_pre_select]",	  "COMMAND:   ",  "[qt_cross_pre_select](int, int, int) : BAT[oid,oid]",															  "Select images that _may_ satisfy the cross's color transitions"																																																							  ]
[ "[qt_debug]",			  "COMMAND:   ",  "[qt_debug](int) : void",																			  "Set debuging on/off"																																																													  ]
[ "[qt_delcross]",		  "COMMAND:   ",  "[qt_delcross](int) : void",																			  "Delete a cross."																																																													  ]
[ "[qt_ir_cluster]",		  "COMMAND:   ",  "[qt_ir_cluster](BAT[void,oid], BAT[void,int], BAT[void,int], BAT[void,uchr], BAT[void,uchr], BAT[void,uchr], int) : void",							  "Cluster all images in a set of bit vectors with 3 color transitions in\n  the Itten-Runge color space.  The clusters themselves are named \n  IR_[N|W]_C0_C1_C2"																																											  ]
[ "[qt_makecross]",		  "COMMAND:   ",  "[qt_makecross](BAT[int,uchr], BAT[int,uchr], BAT[int,uchr], int) : int",													  "Construct a cross from a spot quad tree.  When IR space is set, the \n  cross is stored in IR color space."																																																		  ]
[ "[qt_match]",			  "COMMAND:   ",  "[qt_match](int, oid, BAT[void,oid], BAT[void,int], BAT[void,int], BAT[void,uchr], BAT[void,uchr], BAT[void,uchr], BAT[oid,oid], BAT[oid,int], BAT[oid,int], int, flt) : void", "Look for a matching color cross, which is described by the cross \n  referenced by crossid, in the ID, H, S, and V table.  The requested quad\n  tree is presented in the tables qt_ioffs and qt_inum (offset and number\n  of features, respectively) at entry image_oid.  Fill in the r_* BATS\n  with matching images, number of colors and the IDs of the matched\n  features, respectively if more than or equal to the number of different\n  colors from the spot time the fraction match in the image."	  ]
[ "[qt_pre_select]",		  "COMMAND:   ",  "[qt_pre_select](int, int, int) : BAT[oid,oid]",																  "Select images that _may_ satisfy the cross's color transitions"																																																							  ]
[ "[qt_stats]",			  "COMMAND:   ",  "[qt_stats](int, str) : void",																		  "Control statistics output"																																																												  ]
[ "test_bitvector",		  "PROC:      ",  "test_bitvector() : void",																			  "not available"																																																													  ]
[ "test_uchr",			  "PROC:      ",  "test_uchr() : void",																				  "not available"																																																													  ]

Module: "txtsim"

[ 13 ]
[ 13 ]
#---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------#
# function			type		signature					help																	  # name
# str			str		str						str																	  # type
#---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------#
[ "editdistance",	  "COMMAND:   ",  "editdistance(str, str) : int",		  "Alias for Levenshtein(str,str)"													  ]
[ "editdistance2",	  "COMMAND:   ",  "editdistance2(str, str) : int",		  "Calculates Levenshtein distance (edit distance) between two strings. Cost of transposition is 1 instead of 2"			  ]
[ "levenshtein",	  "COMMAND:   ",  "levenshtein(str, str) : int",		  "Calculates Levenshtein distance (edit distance) between two strings"									  ]
[ "levenshtein",	  "COMMAND:   ",  "levenshtein(str, str, int, int, int) : int",	  "Calculates Levenshtein distance (edit distance) between two strings, variable operation costs (ins/del, replacement, transposition)"	  ]
[ "qgramnormalize",	  "COMMAND:   ",  "qgramnormalize(str) : str",												  "'Normalizes' strings (eg. toUpper and replaces non-alphanumerics with one space"							  ]
[ "qgramselect",	  "PROC:      ",  "qgramselect(BAT[void,oid], BAT[void,sht], BAT[void,sht], BAT[void,oid], BAT[void,str], str, flt, int) : BAT[flt,oid]", "not available"															  ]
[ "qgramselfjoin",	  "COMMAND:   ",  "qgramselfjoin(BAT[void,oid], BAT[void,int], BAT[void,int], BAT[void,int], flt, int) : BAT[int,int]",			  "QGram self-join on ordered(!) qgram tables and sub-ordered q-gram positions"								  ]
[ "qgramselfjoin_test",	  "PROC:      ",  "qgramselfjoin_test() : BAT[oid,oid]",										  "not available"															  ]
[ "similarity",		  "COMMAND:   ",  "similarity(str, str) : dbl",												  "Normalized edit distance between two strings"											  ]
[ "similarity",		  "COMMAND:   ",  "similarity(str, str, dbl) : dbl",											  "Normalized edit distance between two strings"											  ]
[ "soundex",		  "COMMAND:   ",  "soundex(str) : str",				  "Soundex function for phonetic matching"												  ]
[ "str2qgrams",		  "PROC:      ",  "str2qgrams(str) : BAT[oid,str]",											  "not available"															  ]
[ "stringdiff",		  "PROC:      ",  "stringdiff(str, str) : int",			  "not available"															  ]

Module: "uchr"

[ 1 ]
[ 1 ]
#---------------------------------------------------------------------------------#
# function		type		signature		help			  # name
# str		str		str			str			  # type
#---------------------------------------------------------------------------------#
[ "test_uchr",	  "PROC:      ",  "test_uchr() : void",	  "not available"	  ]

Module: "vector"

[ 139 ]
[ 139 ]
#-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------#
# function			| type		| signature							| help												  #
#-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------#
[ "*",				  "OPERATOR:  ",  "*(dbl_vector32, dbl) : dbl_vector32",			  "Multiplication of vector of dbls with scalar"						  ]
[ "*",				  "OPERATOR:  ",  "*(dbls, dbl) : dbls",					  "Multiplication of vector of dbls with scalar"						  ]
[ "*",				  "OPERATOR:  ",  "*(flts, flt) : flts",					  "Multiplication of vector of flts with scalar"						  ]
[ "*",				  "OPERATOR:  ",  "*(int_vector64, int) : int_vector64",			  "Multiplication of vector of ints with scalar"						  ]
[ "*",				  "OPERATOR:  ",  "*(ints, int) : ints",					  "Multiplication of vector of ints with scalar"						  ]
[ "+",				  "OPERATOR:  ",  "+(dbl_vector32, dbl_vector32) : dbl_vector32",		  "Addition of vectors of dbl_vector32"								  ]
[ "+",				  "OPERATOR:  ",  "+(dbls, dbls) : dbls",					  "Addition of vectors of dbls"									  ]
[ "+",				  "OPERATOR:  ",  "+(flts, flts) : flts",					  "Addition of vectors of flts"									  ]
[ "+",				  "OPERATOR:  ",  "+(int_vector64, int_vector64) : int_vector64",		  "Addition of vectors of int_vector64"								  ]
[ "+",				  "OPERATOR:  ",  "+(ints, ints) : ints",					  "Addition of vectors of ints"									  ]
[ "-",				  "OPERATOR:  ",  "-(dbl_vector32, dbl_vector32) : dbl_vector32",		  "Subtraction of vectors of dbls (param 1 - param 2)"						  ]
[ "-",				  "OPERATOR:  ",  "-(dbls, dbls) : dbls",					  "Subtraction of vectors of dbls (param 1 - param 2)"						  ]
[ "-",				  "OPERATOR:  ",  "-(flts, flts) : flts",					  "Subtraction of vectors of flts (param 1 - param 2)"						  ]
[ "-",				  "OPERATOR:  ",  "-(int_vector64, int_vector64) : int_vector64",		  "Subtraction of vectors of ints (param 1 - param 2)"						  ]
[ "-",				  "OPERATOR:  ",  "-(ints, ints) : ints",					  "Subtraction of vectors of ints (param 1 - param 2)"						  ]
[ "/",				  "OPERATOR:  ",  "/(dbl_vector32, dbl) : dbl_vector32",			  "Divide vector of dbls by dbl"								  ]
[ "/",				  "OPERATOR:  ",  "/(dbls, dbl) : dbls",					  "Divide vector of dbls by dbl"								  ]
[ "/",				  "OPERATOR:  ",  "/(flts, flt) : flts",					  "Divide vector of flts by flt"								  ]
[ "/",				  "OPERATOR:  ",  "/(int_vector64, int) : int_vector64",			  "Divide vector of ints by int"								  ]
[ "/",				  "OPERATOR:  ",  "/(ints, int) : ints",					  "Divide vector of ints by int"								  ]
[ "D1distance",			  "COMMAND:   ",  "D1distance(dbl_vector32, dbl_vector32) : dbl",		  "Calculates 'Relative' L1 distance between 2 vectors"						  ]
[ "D1distance",			  "COMMAND:   ",  "D1distance(dbls, dbls) : dbl",				  "Calculates 'Relative' L1 distance between 2 vectors"						  ]
[ "D1distance",			  "COMMAND:   ",  "D1distance(flts, flts) : dbl",				  "Calculates 'Relative' L1 distance between 2 vectors"						  ]
[ "D1distance",			  "COMMAND:   ",  "D1distance(int_vector64, int_vector64) : dbl",		  "Calculates 'Relative' L1 distance between 2 vectors"						  ]
[ "D1distance",			  "COMMAND:   ",  "D1distance(ints, ints) : dbl",				  "Calculates 'Relative' L1 distance between 2 vectors"						  ]
[ "IDdistance",			  "COMMAND:   ",  "IDdistance(dbl_vector32, dbl_vector32) : dbl",		  "Calculates Intersection distance between 2 vectors"						  ]
[ "IDdistance",			  "COMMAND:   ",  "IDdistance(dbls, dbls) : dbl",				  "Calculates Intersection (I) distance (D) between 2 vectors"					  ]
[ "IDdistance",			  "COMMAND:   ",  "IDdistance(flts, flts) : dbl",				  "Calculates Intersection (I) distance (D) between 2 vectors"					  ]
[ "IDdistance",			  "COMMAND:   ",  "IDdistance(int_vector64, int_vector64) : dbl",		  "Calculates Intersection distance between 2 vectors"						  ]
[ "IDdistance",			  "COMMAND:   ",  "IDdistance(ints, ints) : dbl",				  "Calculates Intersection (I) distance (D) between 2 vectors"					  ]
[ "KSdistance",			  "COMMAND:   ",  "KSdistance(dbl_vector32, dbl_vector32) : dbl",		  "Calculates Kolmogorov-Smirnov Coefficient between 2 vectors"					  ]
[ "KSdistance",			  "COMMAND:   ",  "KSdistance(dbls, dbls) : dbl",				  "Calculates Kolmogorov-Smirnov Coefficient between 2 vectors"					  ]
[ "KSdistance",			  "COMMAND:   ",  "KSdistance(flts, flts) : dbl",				  "Calculates Kolmogorov-Smirnov Coefficient between 2 vectors"					  ]
[ "KSdistance",			  "COMMAND:   ",  "KSdistance(int_vector64, int_vector64) : dbl",		  "Calculates Kolmogorov-Smirnov Coefficient between 2 vectors"					  ]
[ "KSdistance",			  "COMMAND:   ",  "KSdistance(ints, ints) : dbl",				  "Calculates Kolmogorov-Smirnov Coefficient between 2 vectors"					  ]
[ "L1distance",			  "COMMAND:   ",  "L1distance(dbl_vector32, dbl_vector32) : dbl",		  "Calculates 'absulte difference' distance between 2 vectors"					  ]
[ "L1distance",			  "COMMAND:   ",  "L1distance(dbls, dbls) : dbl",				  "Calculates 'absulte difference' distance between 2 vectors"					  ]
[ "L1distance",			  "COMMAND:   ",  "L1distance(flts, flts) : dbl",				  "Calculates 'absulte difference' distance between 2 vectors"					  ]
[ "L1distance",			  "COMMAND:   ",  "L1distance(int_vector64, int_vector64) : dbl",		  "Calculates 'absulte difference' distance between 2 vectors"					  ]
[ "L1distance",			  "COMMAND:   ",  "L1distance(ints, ints) : dbl",				  "Calculates 'absulte difference' distance between 2 vectors"					  ]
[ "L2distance",			  "COMMAND:   ",  "L2distance(dbl_vector32, dbl_vector32) : dbl",		  "Calculates Euclidean (L2) distance between 2 vectors"					  ]
[ "L2distance",			  "COMMAND:   ",  "L2distance(dbls, dbls) : dbl",				  "Calculates Euclidean (L2) distance between 2 vectors"					  ]
[ "L2distance",			  "COMMAND:   ",  "L2distance(flts, flts) : dbl",				  "Calculates Euclidean (L2) distance between 2 vectors"					  ]
[ "L2distance",			  "COMMAND:   ",  "L2distance(int_vector64, int_vector64) : dbl",		  "Calculates Euclidean (L2) distance between 2 vectors"					  ]
[ "L2distance",			  "COMMAND:   ",  "L2distance(ints, ints) : dbl",				  "Calculates Euclidean (L2) distance between 2 vectors"					  ]
[ "YLdistance",			  "COMMAND:   ",  "YLdistance(dbl_vector32, dbl_vector32) : dbl",		  "Calculates Yakimovsky Likelihood ratio between 2 vectors"					  ]
[ "YLdistance",			  "COMMAND:   ",  "YLdistance(dbls, dbls) : dbl",				  "Calculates Yakimovsky Likelihood ratio between 2 vectors"					  ]
[ "YLdistance",			  "COMMAND:   ",  "YLdistance(flts, flts) : dbl",				  "Calculates Yakimovsky Likelihood ratio between 2 vectors"					  ]
[ "YLdistance",			  "COMMAND:   ",  "YLdistance(int_vector64, int_vector64) : dbl",		  "Calculates Yakimovsky Likelihood ratio between 2 vectors"					  ]
[ "YLdistance",			  "COMMAND:   ",  "YLdistance(ints, ints) : dbl",				  "Calculates Yakimovsky Likelihood ratio between 2 vectors"					  ]
[ "acos",			  "PROC:      ",  "acos(flt) : flt",						  "not available"										  ]
[ "asin",			  "PROC:      ",  "asin(flt) : flt",						  "not available"										  ]
[ "atan",			  "PROC:      ",  "atan(flt) : flt",						  "not available"										  ]
[ "average",			  "COMMAND:   ",  "average(dbl_vector32) : dbl",				  "Calculates the average value of the vector elements."					  ]
[ "average",			  "COMMAND:   ",  "average(dbls) : dbl",					  "Calculates the average value of the vector elements."					  ]
[ "average",			  "COMMAND:   ",  "average(flts) : dbl",					  "Calculates the average value of the vector elements."					  ]
[ "average",			  "COMMAND:   ",  "average(int_vector64) : dbl",				  "Calculates the average value of the vector elements."					  ]
[ "average",			  "COMMAND:   ",  "average(ints) : dbl",					  "Calculates the average value of the vector elements."					  ]
[ "ceil",			  "PROC:      ",  "ceil(flt) : flt",						  "not available"										  ]
[ "centroid",			  "COMMAND:   ",  "centroid(dbl_vector32) : dbl",				  "Computes the centroid of the given vector"							  ]
[ "centroid",			  "COMMAND:   ",  "centroid(dbls) : dbl",					  "Computes the centroid of the given vector"							  ]
[ "centroid",			  "COMMAND:   ",  "centroid(flts) : dbl",					  "Computes the centroid of the given vector"							  ]
[ "centroid",			  "COMMAND:   ",  "centroid(int_vector64) : dbl",				  "Computes the centroid of the given vector"							  ]
[ "centroid",			  "COMMAND:   ",  "centroid(ints) : dbl",					  "Computes the centroid of the given vector"							  ]
[ "cos",			  "PROC:      ",  "cos(flt) : flt",						  "not available"										  ]
[ "cosh",			  "PROC:      ",  "cosh(flt) : flt",						  "not available"										  ]
[ "dbl_vector32_rancreate",	  "COMMAND:   ",  "dbl_vector32_rancreate() : dbl_vector32",			  "Creates random vector"									  ]
[ "dbls_rancreate",		  "COMMAND:   ",  "dbls_rancreate(int) : dbls",					  "Creates random vector"									  ]
[ "dimension",			  "COMMAND:   ",  "dimension(dbl_vector32) : int",				  "Retrieves the dimension of the vector"							  ]
[ "dimension",			  "COMMAND:   ",  "dimension(dbls) : int",					  "Retrieves the dimension of the vector"							  ]
[ "dimension",			  "COMMAND:   ",  "dimension(flts) : int",					  "Retrieves the dimension of the vector"							  ]
[ "dimension",			  "COMMAND:   ",  "dimension(int_vector64) : int",				  "Retrieves the dimension of the vector"							  ]
[ "dimension",			  "COMMAND:   ",  "dimension(ints) : int",					  "Retrieves the dimension of the vector"							  ]
[ "exp",			  "PROC:      ",  "exp(flt) : flt",						  "not available"										  ]
[ "floor",			  "PROC:      ",  "floor(flt) : flt",						  "not available"										  ]
[ "flts_rancreate",		  "COMMAND:   ",  "flts_rancreate(int) : flts",					  "Creates random vector"									  ]
[ "getval",			  "COMMAND:   ",  "getval(dbl_vector32, int) : dbl",				  "Project the Ith element value out of the vector."						  ]
[ "getval",			  "COMMAND:   ",  "getval(dbls, int) : dbl",					  "Project the Ith element value out of the vector."						  ]
[ "getval",			  "COMMAND:   ",  "getval(flts, int) : flt",					  "Project the Ith element value out of the vector."						  ]
[ "getval",			  "COMMAND:   ",  "getval(int_vector64, int) : int",				  "Project the Ith element value out of the vector."						  ]
[ "getval",			  "COMMAND:   ",  "getval(ints, int) : int",					  "Project the Ith element value out of the vector."						  ]
[ "int_vector64_rancreate",	  "COMMAND:   ",  "int_vector64_rancreate() : int_vector64",			  "Creates random vector"									  ]
[ "ints_rancreate",		  "COMMAND:   ",  "ints_rancreate(int) : ints",					  "Creates random vector"									  ]
[ "length",			  "COMMAND:   ",  "length(dbl_vector32) : dbl",					  "Computes the length of the vector"								  ]
[ "length",			  "COMMAND:   ",  "length(dbls) : dbl",						  "Computes the length of the vector"								  ]
[ "length",			  "COMMAND:   ",  "length(flts) : dbl",						  "Computes the length of the vector"								  ]
[ "length",			  "COMMAND:   ",  "length(int_vector64) : dbl",					  "Computes the length of the vector"								  ]
[ "length",			  "COMMAND:   ",  "length(ints) : dbl",						  "Computes the length of the vector"								  ]
[ "log",			  "PROC:      ",  "log(flt) : flt",						  "not available"										  ]
[ "log10",			  "PROC:      ",  "log10(flt) : flt",						  "not available"										  ]
[ "maxrange",			  "COMMAND:   ",  "maxrange(BAT[any,dbl_vector32]) : dbl_vector32",		  "Determines the 32 values of each dimension in the vectors."					  ]
[ "maxrange",			  "COMMAND:   ",  "maxrange(BAT[any,dbls]) : dbls",				  "Determine the max values of each dimension in the vectors."					  ]
[ "maxrange",			  "COMMAND:   ",  "maxrange(BAT[any,flts]) : flts",				  "Determine the max values of each dimension in the vectors."					  ]
[ "maxrange",			  "COMMAND:   ",  "maxrange(BAT[any,int_vector64]) : int_vector64",		  "Determines the 64 values of each dimension in the vectors."					  ]
[ "maxrange",			  "COMMAND:   ",  "maxrange(BAT[any,ints]) : ints",				  "Determine the max values of each dimension in the vectors."					  ]
[ "meanvector",			  "COMMAND:   ",  "meanvector(BAT[any,dbl_vector32]) : dbl_vector32",		  "Calculates mean vector of given set of vectors"						  ]
[ "meanvector",			  "COMMAND:   ",  "meanvector(BAT[any,dbls], int) : dbls",			  "Calculates mean vector of given set of vectors (Params: bat[vectors], dimension of vectors)"	  ]
[ "meanvector",			  "COMMAND:   ",  "meanvector(BAT[any,flts], int) : flts",			  "Calculates mean vector of given set of vectors (Params: bat[vectors], dimension of vectors)"	  ]
[ "meanvector",			  "COMMAND:   ",  "meanvector(BAT[any,ints], int) : flts",			  "Calculates mean vector of given set of vectors (Params: bat[vectors], dimension of vectors)"	  ]
[ "minrange",			  "COMMAND:   ",  "minrange(BAT[any,dbl_vector32]) : dbl_vector32",		  "Determines the 32 values of each dimension in the vectors."					  ]
[ "minrange",			  "COMMAND:   ",  "minrange(BAT[any,dbls]) : dbls",				  "Determine the min values of each dimension in the vectors."					  ]
[ "minrange",			  "COMMAND:   ",  "minrange(BAT[any,flts]) : flts",				  "Determine the min values of each dimension in the vectors."					  ]
[ "minrange",			  "COMMAND:   ",  "minrange(BAT[any,int_vector64]) : int_vector64",		  "Determines the 64 values of each dimension in the vectors."					  ]
[ "minrange",			  "COMMAND:   ",  "minrange(BAT[any,ints]) : ints",				  "Determine the min values of each dimension in the vectors."					  ]
[ "normalize",			  "COMMAND:   ",  "normalize(dbl_vector32) : dbl_vector32",			  "Normalizes vector"										  ]
[ "normalize",			  "COMMAND:   ",  "normalize(dbls) : dbls",					  "Normalizes vector"										  ]
[ "normalize",			  "COMMAND:   ",  "normalize(flts) : flts",					  "Normalizes vector"										  ]
[ "normalize",			  "COMMAND:   ",  "normalize(ints) : flts",					  "Normalizes vector"										  ]
[ "sin",			  "PROC:      ",  "sin(flt) : flt",						  "not available"										  ]
[ "sinh",			  "PROC:      ",  "sinh(flt) : flt",						  "not available"										  ]
[ "sqrt",			  "PROC:      ",  "sqrt(flt) : flt",						  "not available"										  ]
[ "sum",			  "COMMAND:   ",  "sum(dbl_vector32) : dbl",					  "Calculates the sum of the vector elements."							  ]
[ "sum",			  "COMMAND:   ",  "sum(dbls) : dbl",						  "Calculates the sum of the vector elements."							  ]
[ "sum",			  "COMMAND:   ",  "sum(flts) : flt",						  "Calculates the sum of the vector elements."							  ]
[ "sum",			  "COMMAND:   ",  "sum(int_vector64) : int",					  "Calculates the sum of the vector elements."							  ]
[ "sum",			  "COMMAND:   ",  "sum(ints) : int",						  "Calculates the sum of the vector elements."							  ]
[ "tan",			  "PROC:      ",  "tan(flt) : flt",						  "not available"										  ]
[ "tanh",			  "PROC:      ",  "tanh(flt) : flt",						  "not available"										  ]
[ "test_vector",		  "PROC:      ",  "test_vector() : void",					  "not available"										  ]
[ "todbls",			  "COMMAND:   ",  "todbls(flts) : dbls",					  "Converts vectors of flts to vector of dbls"							  ]
[ "todbls",			  "COMMAND:   ",  "todbls(ints) : dbls",					  "Converts vectors of ints to vector of dbls"							  ]
[ "toflts",			  "COMMAND:   ",  "toflts(dbls) : flts",					  "Converts vectors of dbls to vector of flts"							  ]
[ "toflts",			  "COMMAND:   ",  "toflts(ints) : flts",					  "Converts vectors of ints to vector of flts"							  ]
[ "toints",			  "COMMAND:   ",  "toints(dbls) : ints",					  "Converts vectors of dbls to vector of ints"							  ]
[ "toints",			  "COMMAND:   ",  "toints(flts) : ints",					  "Converts vectors of flts to vector of ints"							  ]
[ "twonormdiff",		  "COMMAND:   ",  "twonormdiff(dbl_vector32, dbl_vector32) : dbl_vector32",	  "Calculates 2norm difference between 2 vectors"						  ]
[ "twonormdiff",		  "COMMAND:   ",  "twonormdiff(dbls, dbls) : dbls",				  "Calculates 2norm difference between 2 vectors"						  ]
[ "twonormdiff",		  "COMMAND:   ",  "twonormdiff(flts, flts) : flts",				  "Calculates 2norm difference between 2 vectors"						  ]
[ "twonormdiff",		  "COMMAND:   ",  "twonormdiff(ints, ints) : flts",				  "Calculates 2norm difference between 2 vectors"						  ]
[ "variance",			  "COMMAND:   ",  "variance(dbl_vector32) : dbl",				  "Calculates the variance of the vector elements."						  ]
[ "variance",			  "COMMAND:   ",  "variance(dbls) : dbl",					  "Calculates the variance of the vector elements."						  ]
[ "variance",			  "COMMAND:   ",  "variance(flts) : dbl",					  "Calculates the variance of the vector elements."						  ]
[ "variance",			  "COMMAND:   ",  "variance(int_vector64) : dbl",				  "Calculates the variance of the vector elements."						  ]
[ "variance",			  "COMMAND:   ",  "variance(ints) : dbl",					  "Calculates the variance of the vector elements."						  ]
[ "variance2",			  "COMMAND:   ",  "variance2(dbl_vector32) : dbl",				  "Calculates the squared variance of the vector elements."					  ]
[ "variance2",			  "COMMAND:   ",  "variance2(dbls) : dbl",					  "Calculates the squared variance of the vector elements."					  ]
[ "variance2",			  "COMMAND:   ",  "variance2(flts) : dbl",					  "Calculates the squared variance of the vector elements."					  ]
[ "variance2",			  "COMMAND:   ",  "variance2(int_vector64) : dbl",				  "Calculates the squared variance of the vector elements."					  ]
[ "variance2",			  "COMMAND:   ",  "variance2(ints) : dbl",					  "Calculates the squared variance of the vector elements."					  ]

Module: "wisc"

[ 2 ]
[ 2 ]
#-----------------------------------------------------------------------------------------------------------------#
# function	| type		| signature			| help						  #
#-----------------------------------------------------------------------------------------------------------------#
[ "wisc",	  "COMMAND:   ",  "wisc(str, int) : void",	  "Wisconsin Benchmark Database Generator"	  ]
[ "wiscdestroy",  "COMMAND:   ",  "wiscdestroy(str) : void",	  "WBD destroy table"				  ]

quit();

# 15:30:10 >  
# 15:30:10 >  Done.
# 15:30:10 >  

