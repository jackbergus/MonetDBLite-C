module("str");
module("xtables");

# kdiff work around, 27-01-1999, blokh@cs.utwente.nl
PROC he_kdiff(BAT b1, BAT b2 ): BAT {
  IF ( b2.count() = 0 )
  {
    printf( "WARNING: second BAT is empty, using special kdiff!\n" );
    return b1.copy();
  }
  ELSE
  {
    return kdiff(b1, b2);
  }
}

PROC load_module( str mn ): void {
  IF ( monet_mod_nme.reverse().exist( mn ) )
  printf( "module %s already loaded\n", mn ); ELSE 
  {
    printf( "loading module %s\n", mn );
    eval( "module(\"" + mn + "\");" );
  }
}

PROC eq( any x, any y ): bit {RETURN x = y;}
PROC ne( any x, any y ): bit {RETURN x != y;}
PROC lt( any x, any y ): bit {RETURN x < y;}
PROC le( any x, any y ): bit {RETURN x <= y;}
PROC gt( any x, any y ): bit {RETURN x > y;}
PROC ge( any x, any y ): bit {RETURN x >= y;}

PROC str_concat( BAT[oid, str] s ):str {
  VAR cur_res := "";
  VAR first := true;
  VAR current_oid := nil;
  VAR res := new( oid, str );
  s @ batloop() {
    IF (first)
    {
      current_oid := $h;
      first := false;
    }
    IF (current_oid != $h)
    {
      res.insert( current_oid, cur_res );
      cur_res := ""; 
      current_oid := $h;
    }
    cur_res := cur_res + $t;
  }
  IF (first != true)
    res.insert( current_oid, cur_res );
  RETURN res;
}

PROC sunion(bat[any::1,any::2] bat1, bat[any::1,any::2] bat2):
  bat[any::1,any::2]
{
    var ht := htype(bat1);
    var tt := ttype(bat1);
    if (ht = void) { ht := oid; }
    if (tt = void) { tt := oid; }
    VAR result := new(ht, tt, count(bat1)+count(bat2));
    result.insert(bat1);
    result.insert(bat2);
    RETURN result;
}

PROC mergecast( BAT[any::1,any] bat1, BAT[any,any::2] bat2, any::2 val)
                        :BAT[any::1,any::2]
{
      VAR tmp := [exist](const bat2.mirror(),bat1.mirror());
      RETURN [ifthenelse](tmp,outerjoin(bat1.mirror(),bat2),val);
}

PROC concat( BAT[any::1,any::2] bat1, BAT[any::1,any::2] bat2)
  :BAT[any::1,any::2]
{
    VAR result := new(htype(bat1), ttype(bat1), count(bat1)+count(bat2));
    result.insert(bat1);
    result.insert(bat2);
    RETURN result;
}

PROC castval( BAT[any::1, any::2] bat1, any::3 val): BAT[any::1,any::3] {
    RETURN bat1.project(val);
}

PROC copy_order( BAT[oid,any] xs, BAT[oid,any::1] y ): BAT[oid,any::1] {
  # xs is ordered; orders y on oid following x's order
  VAR z, xy;
  z  := xs.mark(0@0).reverse();  
  xy := z.join(y).sort();
  RETURN z.reverse().join(xy);
}

PROC cast_copy_order( BAT[oid,any] xs, BAT[oid,any::1] y ): BAT[void,any::1] {
  # xs is ordered; orders y on oid following x's order
  VAR z;
  z  := xs.mark(nil).reverse();
  RETURN z.join(y).reverse().mark(0@0).reverse();
}

PROC CTOgroup( bat[oid,any] x ): bat[oid,int] {
  RETURN join( x, x.reverse().kunique().sort().number() );
}

PROC CTOgroup( bat[oid,any] x, bat[oid,any] y ): bat[oid,int] {
  VAR nx, ny;
  nx := CTOgroup( x );
  ny := CTOgroup( y );
  RETURN [+]([<<](nx,20),ny).reverse().sort().reverse();
}

#
# CTOgroup_last is more efficient, but cannot propagate the ordering
# to a new table
#

PROC CTOgroup_last( bat[any::1,any::2] x ): bat[any::1,int] {
  RETURN x.reverse().sort().reverse().number().sort();
}

PROC CTOgroup_last( bat[oid,any] x, bat[oid,any] y ): bat[oid,int] {
  VAR nx, ny;
  nx := CTOgroup( x );
  ny := CTOgroup_last( y );
  RETURN [+]([<<](nx,20),ny).reverse().sort().reverse();
}

#
# lexicographical sort of synced bats xv and yv
#

PROC lexsort_intern( bat[oid,any::1] xv, bat[oid,any::2] yv ): 
  bat[any::1,any::2]
{
  VAR x,y, cn, rel;

  # combine numbers, and sort
  cn := CTOgroup_last( xv, yv );
  rel := cn.mark(0@0);
  # propagate order
  x := xv.reverse().join(rel).reverse();
  y := yv.reverse().join(rel).reverse();

  RETURN join(x.reverse(), y);
}

#
# split and then sort
#

PROC lexsort( bat[any::1, any::2] XY ): bat[any::1,any::2] {
  #split XY
  VAR xv, yv;
  xv := XY.mark(0@0).reverse();
  yv := XY.reverse().mark(0@0).reverse();
  RETURN lexsort_intern( xv, yv );
}
