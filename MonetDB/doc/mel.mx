@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2006 CWI.
@' All Rights Reserved.

@f mel
@t MEL: MonetDB Extension Language 
@a Peter Boncz 
@d 04/08/2003
@v 1.2
@T 
@* Introduction
The primary interface
of MonetDB is called MIL, the MonetDB Interpreter Language (see the
@[<a href="../mil/index.html">MIL Reference Manual</a>@ for an exhaustive
description).
@-
MIL is an interpreted scripting language, designed as an intermediate 
language interface for a database kernel. MonetDB provides a number of 
atomic types, and one collection type called the @#BAT@, which stands 
for Binary Association Table. This simple design makes for a simple 
kernel; the idea being that simple kernels can be implemented very 
efficiently.

@+ Extending The Database
@T
MonetDB is an {\bf extensible database system}, and hence MIL is an 
extensible language. Persons, knowledgeable in 
some application domain, can extend the MonetDB database system to store
new kinds of data, and define operations on them. These can be added to
the existing operations and types already present in MonetDB.

Extending MonetDB is achieved by writing an {\em extension module} in
the MonetDB Extension Language (MEL). The MEL is a 
{\bf specification-only language}. 

A MEL module states with what types, and  
commands the extension programmer wants to extend MonetDB. A MEL module
also contains help texts on these new primitives which will be inserted
into MonetDB's on-line help system. Finally, a MEL module contains references
to C functions that implement the primitives.
@T
MEL modules can contain any of the following MonetDB Extensions: 
\begin{itemize}
\item {\em new atomic data types}
MIL has built-in support for \{ {\tt Boolean}, {\tt character}, {\tt integer}, {\tt oid}, {\tt pointer}, 
{\tt float}, {\tt double}, {\tt long}, and {\tt string} \} values. You can add new types, such as
{\tt date} or {\tt polygon}. 
\item {\em new algebraic commands or operators}
Algebraic commands get passed in a set of values as parameters, then 
do some execution, and return one value.  MIL allows for overloading 
of algebraic commands and operators. You specify a type-signature 
(with any-wildcarding and lambda expressions allowed), and MIL chooses at
run-time on the basis of the actual parameters.
\end{itemize}
This document describes MEL, and the C/C++ extension programmers
interface for implementing extensions.

@- Invoking the MEL Utility

Checking and installing your MEL extension modules is done   
using the 
@[<a href="mel-tool/index.html">mel utility</a>@.
@T
It checks the MEL syntax, and performs further operations depending on the command line switch.
\begin{description}
\item[-proto] Generate a {\em prototype file} that contains
function definitions in C/C++ for the implementations functions 
that you have to provide for the new commands that the module 
specifies. This also generates type declarations for new data types 
you define.
\item[-template] Like function prototype definitions, but also 
helps you on your way a bit with the implementation, in that it 
generates template implementations that just need to be filled in.
\item[-glue] This switch forms the important link between 
the MonetDB server and user-provided module code. Functions are 
generated for activating and de-activating a module. Also,
for each command or operator, MEL generates internal functions
that perform type checking and parameter packing between
MonetDB's internal structures, and the simple parameter passing
convention that module implementors must adhere to (see 
@[<a target="_self" href="#mod_3_4_0">Section 3.4</a>@).
\item[-html] Generate a simple html summary of the module's 
functionality.
\end{description}

@T
\begin{center}
\begin{figure}
        \mbox{\epsffile{mel.eps}}\\
        \caption{How MEL Aids The Construction Of Extension Modules}
\end{figure}
\end{center}

@- Programming Interface 
The C or C++ implementation can contain any kind of code, depending
on your application domain. For handling of MonetDB values and BATs,
and the existing GDK library of BAT operations, see the 
@[<a href="../gdk/index.html">GDK Interface</a>@. 

The MonetDB extension module loader expects unmangled routine names, 
so C++ programmers have to declare their top-level functions as 
@!extern "C" { }@ blocks (see the 
@[<a href="../Modules/monettime/index.html">monettime module</a>@ 
for an example of use of C++ as implementation language).

@- The Development Process
@T
The line of action when implementing a MonetDB extension module is 
the following:
\begin{enumerate}
\item think first. Of what you want to make, and how you want to make it.
\item write down a specification in the form of a MEL module.
\item generate a header file with {\tt mel -proto}
\item generate a C/C++ file with empty implementation bodies using 
{\tt mel -template}.
\item edit this template file into your implementation code.
\item test and compile it stand-alone (if possible).
\item generate interfacing code with {\tt mel -glue} into an additional file.
\item compile this additional code as well, using a C compiler.
\item link this additional code, together with your implementation, 
and possibly additional libraries of your choice into a dynamically
loadable library (in whatever way appropriate on your system).
\item move this library into the \$MONETHOME/lib directory. 
\end{enumerate}
The name-convention of the library in the \$MONETHOME/lib directory
steers module lookup when in the Mserver:
\begin{itemize}
\item A library called "module.so" is usable by everyone, by any valid MonetDB 
database. 
\item A library called "module-db.so" indicates that this module can only
be loaded by users of database "db". 
\end{itemize}

A standard Makefile is available in the \$MONETHOME/modules directory,
to ease the development process. This makefile assumes that you use the 
@[<a href="http://www.cwi.nl/htbin/ins1/publications?request=pdf&key=KeScBeBo:UNPUBLISHED:96">Mx</a>@ utility for integrating code 
and documentation. It also assumes that your module is in an Mx
file "module.mx" and contains just one source file "module.c" or
"module.cc". For more complex situations, you must invent something
yourself.

@* The MonetDB Extension Language (MEL)

This section will discuss the MonetDB Extension Language (MEL) 
in detail. 

@+ Grammar Specification
@T
Some general rules:
\begin{itemize}
\item white-space is ignored 
\item upper- and lower-case {\bf does} matter.
\item MEL keywords are accepted both in total upper- and total lower-case,
but not in mixed case.
\item the '\#' character initiates comment text; everything up until the 
next newline character is ignored.
\end{itemize}
 
@- Grammar Rules
@T
For those who are not accustomed to reading yacc style grammars
a few guidelines for interpreting the rules:

\begin{description}
\item[ [ something ] ] indicates zero or one times something.
\item[ \{ something \} ] indicates zero or more times something.
\item[ one $|$ another ] indicates one thing, or the other.
\item[ $<$ident: explanation$>$ ] an identifier, consisting of letters, 
digits or underscores (staring with a letter).
\item[ $<$string: explanation$>$ ] a string, enclosed by double quotes, 
like in "foo".
\item[ $<$integer: explanation$>$] a positive integer number.
\item[ $<$verbatim : explanation$>$] a block in which anything goes,
up to the next keyword is found.
\item[ $<$empty$>$] nothing there.
\end{description}
Other identifiers are expected as they are typed in the grammar. 
Individual characters are enclosed in single quotes.

@+ MEL Modules 
@T
MEL is used to write modules. One MEL file describes one module. 
These modules specify MonetDB extensions. Modules are the unit
of extension in MonetDB: a module is loaded, or not. When it
is loaded, all its new language elements are added to MonetDB's 
interpreter language (MIL). When a module is {\em dropped},
they are removed.

Modules can depend upon other modules. The MEL utility will
look for included specifications in the current directory. 
Extra directories can be specified with the {\tt -Idirectory} 
command line switch.

{\small\begin{verbatim}
module ::=
        .MODULE <ident: module name> ';'
            { .USE modulelist ';' }
            [ .EPILOGUE <ident: C routine just after dlopen()> ';' ]
            [ .PRELUDE  <ident: C epilogue just before dlclose()> ';' ]
 
            { atomdef | 
              command | unop | binop |
              builtin }
        .END <IDENT: module name> ';'

modulelist:
	<ident: external module> | <ident: external module> ',' modulelist
\end{verbatim}} 

As module-loading and -dropping is individual to MonetDB users, and 
modules can be shared; loading the (physical) OS shared library and 
logical module loading in the Mserver may occur at different points 
in time: if someone else
loaded earlier, the physical references in memory are shared, and 
the shared library will not need to be loaded physically for the second user.

The {\tt .PRELUDE} and {\tt .EPILOGUE} constructs allow for C routines
to be called when a module is loaded and dropped {\bf physically}.
An example for its use is the initiation of (empty) C structures,
or for instance the creation (/destruction) of shared locks.
The specified C routines are parameterless. The epilogue returns no value (void)
but the prelude returns a bat* (a zero-terminated array of BAT-ids).
Most preludes may just return a NULL pointer, but those modules
where the prelude create BATs that have a head/tail type which is
defined in the same module, must pass those BAT-ids in this array.

This mechanism allows MonetDB to properly analyze whether all live
references to atomic types introduced by a module will be cleaned
up at the drop. That is, if a 'polygon' module is dropped, the system
needs to ensure that no MIL variables or BATs with polygons are in 
memory anymore. With the @[<acronym title="Abstract Data Type">ADT</acronym>@s and dynamic libraries unloaded, using
even basic MIL functionalities (e.g. printing) would cause crashes. 
If live atoms are found at drop-time, the module drop is canceled 
(nothing is dropped, thus the epilogue is then not executed).  However, 
sometimes the last references to atoms which were created in the prelude 
are cleaned up only by the epilogue. This catch-22 then would cause such
modules never to be allowed to drop. Thus, the prelude-BAT-registration
feature allows the MIL interpreter to allow such a drop if the 
prelude-references are the only ones remaining.

@- MIL-only modules
@T
MonetDB now also has support for MIL-only extension modules. That is, extension
modules that are just MIL scripts. MonetDB just executes the MIL in them when 
they are loaded. When such MIL-only modules are dropped, MonetDB undefines 
all PROCs and variables they have introduced, and also drops all modules that 
they loaded.

As these MIL-only modules do not introduce new (C/C++ powered) language elements 
such as ATOMs and COMMANDs they have a functionality that is fully separate 
of MEL "true" extension modules.

However, it is often useful to define a number of MIL constants, variables
or even PROCs that go with a MEL extension module. The MonetDB Makefile systems 
allows for bundling a MIL-only module with a MEL C++/C extension module, when these
are implemented in a Mx file: the mel and c/C Mx-blocks are then compiled into a 
MEL module, and the mil Mx-block becomes the MIL-only module.

Technically, if the MEL specification introduces a module "X", the MIL-only 
module generated will be called X, whereas the MEL/C extension module will 
become _X. The X MIL-module first loads the dependent modules (from the .USE 
clause), and then loads the _X module, and for the rest consists of the MIL
code found in the mil Mx-blocks of your source file.

@+ Atomic Types
@T
MonetDB comes with a standard collection of atomic values that are
recognized automatically by MEL:

{\small\begin{verbatim}
atom ::=
	VOID | BIT | CHR | BTE | SHT | INT | OID | WRD | PTR | FLT | LNG | DBL | STR |
	<ident: extension atom defined until now or in any used module> |
        BAT[atom,atom]

atomdef ::=
	fixedsizeatom | varsizeatom | redefineatom
\end{verbatim}} 

As already shown in the example with the 'monettime' module, new
atomic types can be introduced to MonetDB.

{\small\begin{verbatim}
fixedsizeatom ::=
	.ATOM <ident: atom name> 
	       '[' <integer: byte-size> [ ',' <integer: byte alignment> ] ']' ';'
		{ fixedsizeADTops  ';'}
        .END;

varsizeatom ::=
	.ATOM <ident: atom name> ';'
		{ fixedsizeADTops  ';'| varsizeADTops  ';'}
        .END;
\end{verbatim}} 

@- Two kinds of atoms 
@T
An important point in MonetDB's atomic types is that there are basically 
two classes of them:
\begin{description}
\item[fixed-size atoms] Their memory management is simple because all possible
instances have the same size. They are stored directly in the BUN heap 
(tuple heap)
of a BAT. These types are very efficiently implemented in MonetDB. 
\item[variable-size atoms] From the built-in types, {\tt string} is the
only variable sized type. Values are stored in a separate heap, the BUN heap
contains integer byte-offsets into it. MonetDB ensures in this way that the 
BUN heap can be implemented as an array of fixed-size elements, even if 
it contains values of variable-size. 
\end{description}

The correct functioning of all MonetDB's standard operations (like 
{\tt join, select}) is guaranteed by your plight to implement
an @[<acronym title="Abstract Data Type">ADT</acronym>@ of operations for your new data type. For instance, you will have to
define a hash-function on a {\tt date} so that MonetDB's hash-join can work 
on columns of {\tt date}.

{\small\begin{verbatim}
fixedsizeADTops:
	.FROMSTR = <ident: C routine implementing parse from string>  
 |	.TOSTR   = <ident: C routine implementing print in string>  
 |	.HASH    = <ident: C routine implementing hash number computation>  
 |	.COMP    = <ident: C routine implementing comparison LT/EQ/GT>  
 |	.NEQUAL  = <ident: C routine implementing comparison NE>  
 |      .NULL	 = <ident: C routine returning pointer to the nil value>

varsizeADTops:
	.HEAP	= <ident: C routine that creates and initializes a heap>
 |	.PUT	= <ident: C routine implementing insert in heap>  
 |	.GET	= <ident: C routine implementing copy out of heap>  
 |	.DEL	= <ident: C routine implementing delete from heap>  
 | 	.LEN	= <ident: C routine implementing length function>

\end{verbatim}} 

Above we show the @[<acronym title="Abstract Data Type">ADT</acronym>@ interface that needs to be implemented.
In  @[<a target="_self" href="#mod_3_2_0">Section 3.2</a>@).
we will discuss the details (exact semantics
and parameter conventions) for them.

MonetDB will recognize each new atom as a MIL keyword. It will
also add new atoms to the virtual user table {\small\tt monet\_atomtbl}.

@- Redefined Atoms 
@T
An interesting feature in MEL is that you can define one atom as implemented
by another atom. You may recall that in the 'monettime' example we 
implemented {\tt timestamp} as a different interpretation of an 
{\tt integer}, using the below syntax:

{\small\begin{verbatim}
redefineatom ::=
	.ATOM <ident: atom name> = atom ';'
		{ fixedsizeADTops ';' | varsizeADTops  ';'}
        .END;
\end{verbatim}} 

This means that the new type is different from its implementation type on
the syntax level in MIL, but internally will use the implementations of
its father type (or actually its root ancestor).

The total-remap mechanisms allows for high efficiency: a selection on 
{\tt timestamp} falls into the highly optimized {\tt integer} code, 
without the algorithms having to use @[<acronym title="Abstract Data Type">ADT</acronym>@ jump-tables in  their inner loops.
This total-remap can only be exploited by the MonetDB kernel, if you do not 
redefine any @[<acronym title="Abstract Data Type">ADT</acronym>@ operation! You may in fact still redefine the TOSTR and 
FROMSTR in order to give the new atom a different appearance; this will
not prevent MonetDB from making the remap optimizations during query processing. 

As a very primitive form of inheritance, the redefine mechanism -- even 
if it is not a total remap -- eases software development, as code 
can be reused. To give an example, we come back to the @[<acronym title="Abstract Data Type">ADT</acronym>@ operations 
for variable-sized extension atoms. Since such values are managed 
in a separate heap, users have to implement heap managing @[<acronym title="Abstract Data Type">ADT</acronym>@ operations 
for e.g. the {\tt polygon} type. To facilitate development, you 
can declare a polygon as the {\tt blob} type from the 
@[<a href="../Modules/blob/index.html">standard library</a>@.

@+ New Primitives
Apart from new atomic types, the MEL extension mechanism also allows
you to introduce new execution primitives into MIL.

@- Commands and Operators
@T
The functional part of the MIL language is a set of algebraic commands
or binary and unary operators.  Commands get passed in a set
of values as parameters, then do some execution, and return one value. 
A collection of such commands and operators is called an algebra. 
\footnote{It is actually not correct to call this a true algebra, since 
BAT-parameters are call-by reference (as opposed to the simple
values which are call-by-value), and can hence be modified. This is
just a pragmatical choice.}

{\small\begin{verbatim}
command ::=
	.COMMAND <ident: command name> '(' (<empty> | argumentlist) ')' 
		(<empty> | ':' <atom: return type>)
		'=' <ident: C implementation for this command> ';'
		<string: help text about this command>
unop ::=
	.OPERATOR <string: operator token> '(' type ')' 
		':' <atom: return type>
		'=' <ident: C implementation for this operator> ';'
		<string: help text about this operator>

binop ::=
	.OPERATOR '(' type ')' <string: operator token> '(' type ')' 
		':' <atom: return type>
		'=' <ident: C implementation for this operator> ';'
		<string: help text about this operator>
\end{verbatim}} 

Commands and operators are much alike. The above definitions
expect a command name, a signature for the parameters expected,
possibly including a return type, then the name of a C implementation
function, and a string with helpful text about the command. 

This string may span multiple lines without need to escape the
newlines.

The exact way in which a command implementation in C will get 
passed its parameters and what it is expected to return is discussed
in @[<a target="_self" href="#mod_3_4_0">Section 3.4</a>@.

@- Command Signatures
@T
MIL allows function overloading according to signature. Parameters
can be any kind of known atom, but can also be the special 
keyword {\bf\tt any}. A simple-any can really be any value; whereas
a {\em tagged-any} acts like a free variable: the first occurrence
(from left to right in the signature) is free, the following any-values
with the same tag-number are required to be equal to the first 
occurrence.

Variable number of parameters is also possible. It is indicated 
by a atom name, enclosed by {\tt ...} dots. Note that this atom
name may well be a (tagged) any-type. 
@T
{\small\begin{verbatim}
type ::=
	atom | ANY | ANY::<integer: free variable tag number>

argument ::= 
	type [ <ident: descriptive variable name> ]   

argumentlist ::= 
	argument | '...' type '...' | argument ',' argumentlist
\end{verbatim}} 

In MonetDB, command signatures are registered in the order the
modules are loaded. Within a module, the order of definition
is preserved. When MonetDB does function resolution, it checks
all commands with the matching name in {\em reverse order} of 
definition. The first match of actual parameters with formal parameters
is chosen for execution.

MonetDB will recognize each new command and operator as a MIL keyword. 
It will also add new commands to the virtual user table {\small\tt monet\_fcntbl}.

@- Free-form Primitives
@T
To fork a new process that executes some piece of MIL, MonetDB has
the built-in primitive '{\small\tt fork}'. As only parameter it
expects a statement. If fork would be treated like a normal
command, the MonetDB interpreter would first evaluate that 
parameter, and on its return value initiate function resolution.

This is clearly not what we want. Sometimes you may need  more
control over the execution mode. For this purpose, there is
the possibility of providing BUILTIN primitives: 

{\small\begin{verbatim}
builtin ::=
	.BUILTIN <IDENT: command name> <verbatim: signature> 
		'=' <IDENT: C impl for this builtin> ';'
		<STRING: help text about this builtin>
\end{verbatim}} 

What happens with a built-in is that you get passed a syntax
tree as a parameter. From then on, what you do with that syntax tree 
is your own problem.   

Note that built-ins will override all other commands with the
same name by definition. The converse holds when a command
redefines a built-in.

@- Memory Objects
@T
[ This feature might be deleted in the future.] The {\tt .object} feature
allows you to have a reference to a C/C++ implementation object
in a MIL constant by that name. Such a constant if of the 
PTR type.

{\small\begin{verbatim}
object ::=
	.OBJECT <IDENT: object name> (<empty> | '=' <IDENT: C object name>) ';'
		<STRING: help text about this object>
\end{verbatim}} 

@* Writing Module Implementations
@T
Modules can be implemented in any language really. The one restriction
is that MonetDB calls out to the implementations using C-routines.
This makes C (ANSI) a natural choice. The {\tt mel} utilities takes care 
to generated {\small\tt extern "C" \{ \}} blocks around all interface
functions; so implementations can just as easily be provided in C++.  

Other languages might be possible, but would need a mapping 
environment from the C callout. For the moment, we have no
experiences with this.

@- Outline
First, we will shortly outline the general programming interface you 
can use for your implementations. It contains pointers to recommended
reading material.

After that, we will in turn describe for each new language item that can be
defined in MEL, what the specific C-language interface is for 
the implementations. 

@+ General Database Interface
@T
When interfacing with user-provided implementations functions, MonetDB 
passes atomic values and BATs to these user-generated functions. When
the to-be-implemented command returns a value, it also expects 
back a value of such kind. 

You will therefore have to use the {\tt GDK} interface for manipulating
MonetDB values, and possibly too the {\tt monet} interface (if you
get yourself into interpreting MIL trees or strings by hand). 

In this document we cannot go deeply in these details, so below we
provide references to their detailed definitions.

@- GDK 
@T
GDK stands for the Goblin Database Kernel,
(see the @[<a href="../gdk/index.html">The GDK Document</a>@), 
and forms the basic 
library on which on which MonetDB is built. GDK contains an extensive
collection of relational operators on the binary model. It
supports a standard collection of 
@[<a href="../gdk/index.html#mod_1_5_1">atoms</a>@ 
{\tt \{ void, bit, chr, bte, sht, int,
oid, wrd, flt, bat, lng, dbl, str \}}. All relational operators are
optimized for these atoms and use the standard {\tt hash}.

Of special interest is the section on how 
@[<a href="../gdk/index.html#mod_1_3_0">BATs</a>@
(Binary Association Tables) are managed.

@- MonetDB
MonetDB (see the 
@[<a href="../monet/index.html">The MonetDB Document</a>@), 
is a threaded execution system built on top of GDK.
Its specific features will only be used by extension programmers 
delving in the more complex extension possibilities (built-ins,
iterators).

@+ Implementing Fixed-size Atoms
@T
As discussed earlier, atoms are covered behind an @[<acronym title="Abstract Data Type">ADT</acronym>@ interface 
to GDK. The @[<acronym title="Abstract Data Type">ADT</acronym>@ interface required for implementing variable-size atoms 
is a superset of that of of fixed-size atoms as discussed in this section. 
The specifics for variable-size atoms are discussed in 
@[<a target="_self" href="#mod_3_3_0">the next section</a>@.

You are strongly urged to read the 
@[<a href="../gdk/index.html#mod_1_5_1">ATOM</a>@ and
@[<a href="../gdk/index.html#mod_1_3_2">HEAP</a>@ sections 
of the GDK Document and the @[<a href="../gdk_atoms/index.html">gdk\_atoms</a>@ 
file first.

We will use the fictitious  user-defined atoms called {\small\tt point} 
and {\small\tt polyline}, as the running examples in this section. 
The former is fixed-size the latter variable-size.

Suppose we have the C definitions:
{\small\begin{verbatim}
typedef struct {
	float x;
	float y;
} point;

typedef struct {
	int npoints;
	point data[1];	
} polyline;

#define POLYLINE_LENGTH(npoints) sizeof(polyline) + (npoints-1)*sizeof(point);
\end{verbatim}}

You will have noticed that we defined the {\small\tt struct polyline} 
in a tricky way.  The {\small\tt data[]} array is just declared as one 
item big! Polylines will contain more than just one point, of course.
In fact, we allocate {\small\tt polyline} values in a region
larger than {\small\tt sizeof(polyline)}; to be precise we will do
{\small\tt GDKmalloc(POLYLINE\_LENGTH(npoints))}.

The reason we define polylines in this way, is MonetDB's requirement
that atomic values occupy a {\em contiguous} memory space. 

We will go one-on-one with the @[<acronym title="Abstract Data Type">ADT</acronym>@ operations in the following 
subsections. 
\\
{\bf You are expected to be C-literate}; as each @[<acronym title="Abstract Data Type">ADT</acronym>@ operation
is first characterized by an example in the context of {\small\tt point} or 
{\small\tt polyline}.

@- FROMSTR: parse from string
@T
{\small\begin{verbatim}
int pointFromStr(char *src, int  *len, point **dst) {
	int nchars;
	if (*len < sizeof(point)) {
		if (*dst) GDKfree(*dst);
		*dst = GDKmalloc(*len = sizeof(point));
	}
	if (sscanf("(%f,%f)%n", &(*dst)->x, &(*dst)->y, &nchars) != 3) {
		return 0;
	}
	return nchars;
}
\end{verbatim}}

This function parses an atomic value from a string. It returns the number of
characters parsed. A return value of 0 indicates a parse error.
The {\tt *dst} pointer may be NULL, or may already point to some region.
In the latter case, {\tt *len} is not 0 and contains the size of this
region. 

It is the duty of this implementation function to see whether the
presented region is large enough to hold the new atom. If so, this
region is used, and {\tt dst} and {\tt len} are left untouched. 
If not, the function itself allocates enough space with
@[<a href="../gdk/index.html#mod_1_6_1">GDKmalloc(size) : void*</a>@
returns it in {\tt *dst} and stores the size in {\tt *len}.
If {\tt *dst} was not NULL, the old region is freed first with 
@[<a href="../gdk/index.html#mod_1_6_1">GDKfree(void*)</a>@.
 
@- TOSTR: print in string
@T
{\small\begin{verbatim} 
int pointToStr(char **dst, int  *len, point *src){
	if (*len < 24) {
		if (*dst) GDKfree(*dst);
		*dst = GDKmalloc(*len = 24);
	}
	sprintf(*dst, "(%f,%f)", src->x, src->y);
	return strlen(*dst);
}
\end{verbatim}}

This function formats an atomic value into a string. It returns the number of
characters printed. This number does {\bf not} include the closing zero
character you are supposed to print!

The {\tt *dst} pointer may be NULL, or may already point to some string.
In the latter case, {\tt *len} is not 0 and contains the size of this
region. 

It is the duty of this implementation function to see whether the
presented region is large enough to hold the string. If so, this
region is used, and {\tt dst} and {\tt len} are left untouched. 
If not, the function itself allocates enough space with
@[<a href="../gdk/index.html#mod_1_6_1">GDKmalloc(size) : void*</a>@
returns it in {\tt *dst} and stores the size in {\tt *len}.
If {\tt *dst} was not NULL, the old region is freed first with 
@[<a href="../gdk/index.html#mod_1_6_1">GDKfree(void*)</a>@.
 
@- HASH: hash number computation
@T
{\small\begin{verbatim} 
int pointHash(point *val) {
	return ((int) val->y) *((int) val->x); 
}
\end{verbatim}}

This routine maps an atomic value into an integer number, that is returned. 
No restrictions exist on the range of the integer.

@- COMP/NEQUAL: atomic comparison 
@T
{\small\begin{verbatim} 
// points: lexicographical ordering on (x,y)
int pointCompare(point *v1, point *v2) {
	if (v1->x == v2->x) {
		return (v1->y < v2->y)?-1:(v1->y == v2->y)?0:1;
	}
	return (v1->x < v2->x)?-1:1;
}

// polylines: no ordering available 
int polylineNequal(polyline *v1, polyline *v2)
	if (v1->npoints != v2->npoints) {
		return 0;
	}
	for(int i=0; i < v1->npoints; i++) {
		if (v1->data[i] != v2->data[i]) {
			return 0;
		}
	}
	return 1;
}
\end{verbatim}}
@
 
@T
On atoms on which an ordering exists, MonetDB will be able to use
sorting-based relational algorithms, and build binary index trees.
Some atoms though -- especially multi-dimensional ones -- do not
allow for linearization.

Atoms that can be sorted should implement the COMP function. It 
compares to atoms, and returns -1, 0 or 1 when 
{\tt\small v1 $<$ v2, v1 $==$ v2 } and  {\tt\small v1 $>$ v2},
respectively.

Specifying the NEQUAL operation though implicitly means that no
ordering exist. NEQUAL returns 1 when {\small\tt v1 == v2}, and 0 
otherwise.

You must implement either NEQUAL or COMP.

@- NULL: static nil pointer
@T
{\small\begin{verbatim} 
point point_nil = { flt_nil, flt_nil };

point* pointNull(){
	return &point_nil;
}
\end{verbatim}}

This simple function just returns a pointer to a static nil value.

@+ Variable-size Atoms
Probably the easiest way to create variable sized atoms is to
overload functions from the @[<a href="../Modules/blob/index.html">blob</a>@
module; which is provided in the standard collection of extension modules.

Only if very specific functionality is required, will you need to
write your own functions -- as described in this section. 
Variable-size atoms need to manage a 
additional @[<a href="../gdk/index.html#mod_1_3_2">Heap</a>@.
MonetDB provides a standard collection of functions to do this. 

@- LEN: atom length function 
@T
{\small\begin{verbatim} 
int polylineLength(polyline* val) {
	return POLYLINE_LENGTH(val->npoints);
}
\end{verbatim}}

This returns the byte-length of an atom. It is of course only
useful for variable-size atoms. Notice that you must design your
variable-size atom in such a way that it is possible 
to determine the length of an atom from its contents alone
(there are no other parameters to the length function). 


@- HEAP: initialize a heap
@T
{\small\begin{verbatim} 
#define POINTS_MEAN 12 

polylineHeap(Heap* h, int nitems){
	HEAP_initialize(h,				// heap 
	    nitems*POLYLINE_LENGTH(POINTS_MEAN),	// size in bytes
	    0,						// header offset 
	    sizeof(int) 				// alignment
	);
}
\end{verbatim}}

This creates a Heap structure and sets up some initial structures
to manage it. You can write your own function here as well.

@- PUT: insert in heap  
@T
{\small\begin{verbatim} 
int polylinePut(Heap *h, int* offset, polyline *val) {
	int len = polylineLength(val);
	*offset = HEAP_malloc(h, len); 
	memcpy(h->base + *offset, val, len);
}
\end{verbatim}}

The PUT function must allocate space in the heap and copy the atom there.
It furthermore must set the {\small\tt *offset} to the byte-offset from the
base of the heap.

@- GET: copy out of heap  
@T
{\small\begin{verbatim} 
int polylineGet(Heap *h, int* offset, *len, polyline **dst) {
	polyline *src  = (polyline*) (h->base + *offset);
	int size = polylineLength(src);

	if (size > *len) {
		if (*dst) GDKfree(*dst);
		*dst = (polyline*) GDKmalloc(*len = size);
	}
	memcpy(*dst, src, size);
	return size;
}
\end{verbatim}}

This functions extract a value from the heap, into a new region.
The semantics for allocation management is similar to FROMSTR and TOSTR.

@- DEL: delete from heap  
@T
{\small\begin{verbatim} 
int polylineDel(Heap*h, int* offset){
	HEAP_free(h, h->base + *offset);
}
\end{verbatim}}

Hook to free space in the heap.

@+ Implementing Commands and Operators
@T
Operators are just commands for which an infix notation is allowed. 
Implementation-wise they are the same - so we discuss both here.

To illustrate every detail that is discussed we recommend 
feeding your MEL module through the {\tt mel -template} utility,
which provides implementation templates that you just need
to fill in. This may be very helpful in your implementation
efforts.

@- general
@T
A command implementation gets passed in a number of values, 
and may return a (new) value. MIL doesn't know call-by-reference
parameters. BATs are an exception here: the internal state of 
a BAT can be modified by the programmer through the GDK interface.
Otherwise, the only way a command can give back a value is as a return value.
You are responsible for all deallocation of dynamically allocated 
memory that is not passed back as a return value!

A command implementation always gives back an integers status 
number. You have the choice between {\small\tt GDK\_SUCCEED} and {\small\tt GDK\_FAIL}. 
The latter will automatically produce a MIL error; stopping 
execution of the current statement.

You may print to {\small\tt stderr}, which is redirected to the MonetDB console.
Otherwise, you should print on the {\small\tt GDKout} file descriptor
(a C {\small\tt FILE*}). 

@- Normal Parameters
@T
MonetDB values can be subdivided in three categories, with respect
to the way they are passed to command implementations:

\begin{description}
\item[{\em BAT}] these are passed as a 
@[<href="../gdk/index.html#mod_1_3_1">BAT*</a>@ descriptor.
\item[{\em fixed-size atoms}] are just discriminated from..
\item[{\em variable-size atoms}] in the way they get stored in 
a BAT. Fixed-size atoms are stored in the tuples (BUNs), whereas 
variable-sized are stored in a separated  heap. The BUNs contain
an integer offset into that heap.
\end{description}

Fixed- and variable-size atoms are essentially treated in
the same way. MonetDB just requires them to consist of contiguous
range of memory. You can use the 
@[<a href="../gdk_atoms/index.html#mod_1_2_3">ATOMlen(tpe,val) : int</a>@
macro to inquire for the length of the region. For fixed-size
atoms, this will always yield the same value, that can be
statically looked up with the 
@[<a href="../gdk_atoms/index.html#mod_1_2_2">ATOMsize(tpe): int</a>@
macro as well.

The following example MEL definition:
{\small\begin{verbatim}
.COMMAND foo(BAT[STR,INT], STR name, INT age) = foo_impl; "example function"
\end{verbatim}}
expects a C implementation like this:
{\small\begin{verbatim}
int foo_impl(BAT* b, char* name, int* age){
	if (everything_goes_ok) {
		return GDK_SUCCEED;
	}
	return GDK_FAIL;
}
\end{verbatim}}

Note that passing the 'pointer to the atomic region' for fixed-size atoms
like {\tt int} means passing an {\tt int*}, whereas the variable-size
atom {\tt str} is passed as is. BAT parameters follow a different logic 
altogether. The BAT interface provides the macros 
@[<a href="../gdk/index.html#mod_1_3_5">BAThtype(bat) : int</a>@ and
@[<a href="../gdk/index.html#mod_1_3_5">BATttype(bat) : int</a>@ respectively,
to inquire about the type of the left column ({\em head}) and
right column ({\em tail}).

@- Any Parameters
@T
An any-parameter can be a any kind of atom. To make known its type,
the value pointer (which is passed in the way described above) is
followed by an {\tt int} type number.

The GDK interface has standard constants for all built-in atomic
types name {\tt TYPE\_$<$atom$>$} (e.g. {\tt TYPE\_int}). MEL
makes sure that for each newly introduced atomic type, such a 
constant is generated as well. 

Any-parameters can be tagged with a number. All tagged any-parameters
with the same tag-number must have the same type. MonetDB does not redundantly
pass the extra integer type numbers: the first occurrence of a tagged any
parameter is called the {\em free} any-parameter. It is passed with a 
type number. All following any-parameters with the same tag are said
to be {\em bound}. Their type is known, so no type integer is passed.

Any-parameters that occur in a BAT signature, like {\small\tt BAT[any::1,int]}
are an exception to the rules. If the any-type is untagged or free, one 
would expect the extra type integer to be passed. Because one can always 
inquire about the head- and tail-type of a 
@[<href="../gdk/index.html#mod_1_3_1">BAT</a>@ with the
@[<a href="../gdk/index.html#mod_1_3_5">BAThtype(bat) : int</a>@ and
@[<a href="../gdk/index.html#mod_1_3_5">BATttype(bat) : int</a>@ 
macros, MonetDB does *not* pass extra integer parameters to specify
head- and tail-types of a BAT.

As an example, consider the following example MEL definition:
{\small\begin{verbatim}
.COMMAND foo1(ANY::1 a, ANY::1 b) = foo1_impl; 
\end{verbatim}}
expects a C implementation with prototype:
{\small\begin{verbatim}
extern int foo1_impl(ptr a, int tpe, ptr b);
\end{verbatim}}
where {\tt ptr} is @[<a href="../gdk/index.html#mod_1_2_3">defined</a>@
as {\tt void*}. Since {\small\tt a} is a free any-parameter,
it is followed by an extra type integer. We know, however, that {\small\tt b}
has the same type as {\small\tt a}, so no second type integer is passed 
after it.

When you pass any types as head- or tail-types of a BAT parameter:
{\small\begin{verbatim}
.COMMAND foo2(BAT[ANY::1,ANY] a, ANY::1 b, ANY::2 c) = foo2_impl; 
\end{verbatim}}
you get a different prototype:
{\small\begin{verbatim}
extern int foo2_impl(BAT* a, ptr b, ptr c, int tpe);
\end{verbatim}}
Here the type of {\tt b} is
@[<a href="../gdk/index.html#mod_1_3_5">BAThtype(a)</a>@ and
is not passed. Since {\tt c} is a free any-parameter, it does
need a type integer.

@- Variable Number of Arguments
@T
Variable number of arguments is supported in MEL with a mechanism 
similar to the C/C++ {\tt stdarg} mechanism. The variable arguments
are passed using the same convention as normal parameters.

{\small\begin{verbatim}
.COMMAND sum(...FLT...) : FLT = sum_impl;
\end{verbatim}}
leads to:
{\small\begin{verbatim}
int sum(flt* retval, ...){
	va_list ap;
	int i;
	*retval = 0.0;
        va_start (ap, retval);
	while(i = va_arg(ap, int)) {
		*retval += i;
	} 
        va_end (ap);
	return GDK_SUCCEED;
}
\end{verbatim}}

Note that the semantics are a bit tricky in that passing a 
zero-value will terminate the sequence. You might need to
pass an argument count in your applications, in order to
know for sure when the sequence terminates.  

An even more tricky situation is when you pass a sequence
of {\em free} any-parameters as varargs. In this case, 
MonetDB prefixes the sequence with one type integer.

{\small\begin{verbatim}
.COMMAND sum(...ANY::1...) : ANY::1 = sum_impl;
\end{verbatim}}
yields a prototype:
{\small\begin{verbatim}
extern int sum(ptr retval, int tpe, ...);
\end{verbatim}}

One small caveat in using stdargs is that the GDK header file 
includes the incompatible definitions from {\small\tt varargs}. You must
therefore, before including {\small\tt gdk.h}, do the following:

{\small\begin{verbatim}
#include <stdarg.h>
/* define varargs so it will not be included (via gdk.h) later */
#define _VARARGS_H
#include "gdk.h"
\end{verbatim}}


@- Return Values
@T
If your command gives back a value, the {\bf first parameter} will be 
used for this. The actual parameters to the function just follow after 
it. The passing details depend on the type of atom. There are 
four possibilities:

\begin{description}
\item[{\em BAT return value}] in this case the first parameter has 
type {\tt BAT**}. You pass back the {\tt BAT*} BAT descriptor in it.
For example:

{\small\begin{verbatim}
.COMMAND empty_bat(int size) :BAT[int,str] = empty_bat_impl; 
\end{verbatim}}
leads to:
{\small\begin{verbatim}
int empty_bat_impl(BAT** retval, int* size) {
	*retval = BATnew(TYPE_int, TYPE_str, *size);
	return GDK_SUCCEED;
}
\end{verbatim}}

\item[{\em fixed-size atoms}] 
The first parameter is a pointer to already allocated storage. 
You can just fill this storage with the return value.
For example:

{\small\begin{verbatim}
.COMMAND pi() : flt = pi_impl; 
\end{verbatim}}
leads to:
{\small\begin{verbatim}
int pi_impl(flt* retval) {
	*retval = 3.14;
	return GDK_SUCCEED;
}
\end{verbatim}}

\item[{\em variable-size atoms}] 
The first parameter is the address of a region.  You must {\bf allocate} 
this region with 
@[<a href="../gdk/index.html#mod_1_6_1">GDKmalloc(size) : void*</a>@
(obligatory to use!).
For example:

{\small\begin{verbatim}
.COMMAND new_polygon(...point...) : polygon = new_polygon_impl; 
\end{verbatim}}
leads to:
{\small\begin{verbatim}
int new_polygon_impl(polygon** retval, ...) {
	va_list ap;
	polygon *pl;
	point *pt;
	int i;

        va_start (ap, retval);
	for(i=0; va_arg(ap, point*); i++); 
        va_end (ap, retval);

	*retval = pl = (polygon*) GDKmalloc(POLYGON_SIZE(i));

        va_start (ap, retval);
	for(i=0; pt = va_arg(ap, point*); i++) 
		pl->data[i] = *pt;
        va_end (ap, retval);

	return GDK_SUCCEED;
}
\end{verbatim}}
\end{description}

@- Unbound Any-Type Return Values
@T
The forth case are any-type return atoms.
These can have a more complex behavior. Normally they
don't, though: as the return type of 
a command will be derived from (one of) its parameters.
That is, if the any return value is {\em bound}, MonetDB knows
what to expect, and return values follow the normal logic as 
described above (bat, fixed-size or var-sized). 

Note that we talk in this section about the top-level type being
an unbound any-type: BAT return values with any head- and tail-types
count as 'normal' return values and are handled in the standard way.  

Only in the rather exceptional case that the any-return value is
{\em free}, complications occur. In this case, the MonetDB Interpreter
does not know what kind of value the command is going to return.
In order to tell this, there is an extra second parameter, which is an 
{\tt int*}, where the command should pass the type of the result value.

The first parameter is declared as an anonymous pointer {\tt ptr},
that is handled in the following ways:

\begin{description}
\item[{\em BAT return value}] in this case, the first parameter is
interpreter as being a {\tt BAT**}. You pass back the {\tt BAT*} BAT 
descriptor in it.

\item[{\em internal atoms}] are all built-in MonetDB atoms except
{\tt str} (that is \{{\small\tt bit, chr, bte, sht, int, oid, wrd, ptr, flt, lng, dbl}\}).
The first parameter is the supposed to point to already allocated storage. 
You can just fill this storage with the return value.

\item[{\em external atoms}] are all other kinds of values.
All variable-size atoms (like {\tt str}) are extern atoms. The same 
goes for all user-defined types that are not remapped to an existing 
internal type. 

External return atoms use the first parameter a the address of a pointer
to some region.  You must set this pointer to a region {\bf you allocate} 
with @[<a href="../gdk/index.html#mod_1_6_1">GDKmalloc(size) : void*</a>@.
\end{description}

Note that the internal/external distinction between atoms is different 
from fixed size/var-size!!
To discover run-time whether a type needs internal or external storage,
you can use the
@[<a href="../gdk/index.html#mod_1_2_4">ATOMextern(type) : int</a>@
macro, which returns TRUE for external atoms, and FALSE otherwise. 

@+ Implementing Built-ins
@T
{\small\begin{verbatim} 
.BUILTIN fork(STATEMENT) = fork_impl;
\end{verbatim}}

The careful reader will note that 'STATEMENT' is not correct MEL syntax.
Since built-ins bypass the function resolution mechanism and consequently
do not have signatures, but we want to feed some 'intuitive' information 
about the built-in into the help system; MEL accepts a free syntax between
the BUILTIN keyword and the '=' in front of the implementation name,

The implementation function has the syntax:
{\small\begin{verbatim} 
extern int fork_impl(Cntxt stk, YYSTREE lt, Value res);
\end{verbatim}}

The YYSTREE syntax
tree structure has the field {\tt lt->cnt} that indicates how many 
sons it has. The {\tt lt->yysons[YYMAXSONS]} contains these subtrees. 
If there are more sons than {\tt YYMAXSONS}, the node is recursively continued 
in {\tt lt->overflow}. A return value of 0 or more indicates correct 
execution; a result value is left in {\tt res}. Negative values
indicate an error, with two exceptions: {\tt -TOK\_RETURN} indicates
that execution was interrupted by a  {\tt return} MIL-statement; 
whereas a return value of {\tt -TOK\_BREAK} indicates that execution
was stopped prematurely by a {\tt break} MIL-statement.

Standard execution of a syntax tree is performed by the main
MIL interpretation routine:
{\small\begin{verbatim} 
extern int interpret(Cntxt stk, YYSTREE lt, Value res);
\end{verbatim}}
 

