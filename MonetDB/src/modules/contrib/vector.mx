@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2006 CWI.
@' All Rights Reserved.

@f vector.mx
@a Wilko Quak, Arjen P. de Vries, Alex Van Ballegooij, Johan List, Niels Nes
@d 18/05/2001
@t Variable length vector and fixed-size vectors for Monet

@* Introduction
The module defines some basic operations for a multidimensional vector type
for int, flt, or dbl and their fixed size counterparts for int_64 and dbl_32. 

Variable sized atoms are called:
\begin{itemize}
\item ints, vector of integers
\item flts, vector of floats
\item dbls, vector of doubles
\end{itemize}

The following fixed size vectors are predefined:
\begin{itemize}
\item dbl_vector32, vector of 32 doubles
\item int_vector64, vector of 64 ints
\end{itemize}
More fixed sized types can easily be defined, but are not currently defined
because we do not need them at this moment...

Revision History:
\begin{itemize}
\item Wilko Quak: First CPP version
\item Arjen P. de Vries: Port to monet-module
\item Alex van Ballegooij: Ported CPP implementation to C
\item Johan List: Added fixed-size atoms
\item Alex van Ballegooij/Johan List: Clean-up of code/Some bug-fixes
\end{itemize}

@* Module Definition
@m
.MODULE vector;
    .USE mmath;


@* Header file
@h
#ifndef __VECTOR_H__
#define __VECTOR_H__

@* Implementation file
@c

#include <gdk.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include "vector.h"
#include "vector.proto.h"

static long
get_long(const char *startp, char **endp)
{
	return (strtol(startp, endp, 10));
}

static double
get_double(const char *startp, char **endp)
{
	return (strtod(startp, endp));
}

#ifndef HAVE_MRAND48
long int
mrand48(void)
{
	/* for now we assume that RAND_MAX == 0x7FFF */
	return (rand() << 8) | (rand() << 1) | (rand() & 1);
}
#endif

#ifndef HAVE_DRAND48
double
drand48(void)
{
	return (double) mrand48() / 2147483648.0;
}
#endif
@= varsized_m
   .ATOM @1s;
      .TOSTR   = atom_@1s_tostr;
      .FROMSTR = atom_@1s_fromstr;
      .READ    = atom_@1s_read;
      .WRITE   = atom_@1s_write;
      .NEQUAL  = atom_@1s_nequal;
      .DEL     = atom_@1s_del;
      .NULL    = atom_@1s_null;
      .PUT     = atom_@1s_put;
      .LENGTH  = atom_@1s_length;
      .HEAP    = atom_@1s_heap;
      .HASH    = atom_@1s_hash;
   .END;

   .COMMAND @1s_rancreate(int)   : @1s = cmd_@1s_rancreate;
       "Creates random vector"

   .COMMAND dimension(@1s)       : int = cmd_@1s_dimension;
       "Retrieves the dimension of the vector"

   .COMMAND average(@1s)         : dbl = cmd_@1s_average;
       "Calculates the average value of the vector elements."

   .COMMAND variance(@1s)        : dbl = cmd_@1s_variance;
       "Calculates the variance of the vector elements."

   .COMMAND variance2(@1s)       : dbl = cmd_@1s_variance2;
       "Calculates the squared variance of the vector elements."

   .COMMAND sum(@1s)             : @1 = cmd_@1s_sum;
       "Calculates the sum of the vector elements."

   .COMMAND IDdistance(@1s, @1s) : dbl = cmd_@1s_iddistance;
       "Calculates Intersection (I) distance (D) between 2 vectors"

   .COMMAND D1distance(@1s, @1s) : dbl = cmd_@1s_d1distance;
       "Calculates 'Relative' L1 distance between 2 vectors"

   .COMMAND L1distance(@1s, @1s) : dbl = cmd_@1s_l1distance;
       "Calculates 'absulte difference' distance between 2 vectors"

   .COMMAND L2distance(@1s, @1s) : dbl = cmd_@1s_l2distance;
       "Calculates Euclidean (L2) distance between 2 vectors"

   .COMMAND YLdistance(@1s, @1s) : dbl = cmd_@1s_yldistance;
       "Calculates Yakimovsky Likelihood ratio between 2 vectors"

   .COMMAND KSdistance(@1s, @1s) : dbl = cmd_@1s_ksdistance;
       "Calculates Kolmogorov-Smirnov Coefficient between 2 vectors"

   .COMMAND getval(@1s,int)      : @1 = cmd_@1s_getval;
     "Project the Ith element value out of the vector."

   .COMMAND centroid(@1s)       : dbl = cmd_@1s_centroid;
     "Computes the centroid of the given vector"

   .COMMAND length(@1s)         : dbl = cmd_@1s_length;
     "Computes the length of the vector"
@

@= fixedsize_m
   .ATOM @1_vector@2 [@3];
       .FROMSTR = atom_@1_vector@2_fromstr;
       .TOSTR   = atom_@1_vector@2_tostr;
       .READ    = atom_@1_vector@2_read;
       .WRITE   = atom_@1_vector@2_write;
       .NEQUAL  = atom_@1_vector@2_nequal;
       .NULL    = atom_@1_vector@2_null;
   .END;

   .COMMAND @1_vector@2_rancreate()  : @1_vector@2 = cmd_@1_vector@2_rancreate;
       "Creates random vector"

   .COMMAND dimension(@1_vector@2)       : int = cmd_@1s_dimension;
       "Retrieves the dimension of the vector"
   
   .COMMAND average(@1_vector@2)         : dbl = cmd_@1s_average;
       "Calculates the average value of the vector elements."

   .COMMAND variance(@1_vector@2)        : dbl = cmd_@1s_variance;
       "Calculates the variance of the vector elements."

   .COMMAND variance2(@1_vector@2)       : dbl = cmd_@1s_variance2;
       "Calculates the squared variance of the vector elements."

   .COMMAND sum(@1_vector@2)             : @1 = cmd_@1s_sum;
       "Calculates the sum of the vector elements."

   .COMMAND D1distance(@1_vector@2, @1_vector@2) : dbl = cmd_@1s_d1distance;
       "Calculates 'Relative' L1 distance between 2 vectors"

   .COMMAND L1distance(@1_vector@2, @1_vector@2) : dbl = cmd_@1s_l1distance;
       "Calculates 'absulte difference' distance between 2 vectors"

   .COMMAND L2distance(@1_vector@2,@1_vector@2) : dbl = cmd_@1s_l2distance;
       "Calculates Euclidean (L2) distance between 2 vectors"

   .COMMAND YLdistance(@1_vector@2, @1_vector@2) : dbl = cmd_@1s_yldistance;
       "Calculates Yakimovsky Likelihood ratio between 2 vectors"

   .COMMAND KSdistance(@1_vector@2, @1_vector@2) : dbl = cmd_@1s_ksdistance;
       "Calculates Kolmogorov-Smirnov Coefficient between 2 vectors"

   .COMMAND IDdistance(@1_vector@2, @1_vector@2) : dbl = cmd_@1s_iddistance;
       "Calculates Intersection distance between 2 vectors"

   .COMMAND getval(@1_vector@2,int)      : @1 = cmd_@1s_getval;
     "Project the Ith element value out of the vector."
   
   .COMMAND centroid(@1_vector@2)        : dbl = cmd_@1s_centroid;
     "Computes the centroid of the given vector"

   .COMMAND length(@1_vector@2)          : dbl = cmd_@1s_length;
     "Computes the length of the vector"
@

@= varsized_normalize_m
    .COMMAND normalize(@1s) : @2s = cmd_@1s_normalize;
      "Normalizes vector"
@

@= fixedsize_normalize_m
    .COMMAND normalize(@1_vector@3) : @2_vector@3 = cmd_@1_vector@3_normalize;
      "Normalizes vector"
@

@= varsized_twonormdiff_m
    .COMMAND twonormdiff(@1s,@1s) : @2s = cmd_@1s_twonormdiff;
      "Calculates 2norm difference between 2 vectors"
@

@= fixedsize_twonormdiff_m
    .COMMAND twonormdiff(@1_vector@3, @1_vector@3) : @2_vector@3 = cmd_@1_vector@3_twonormdiff;
      "Calculates 2norm difference between 2 vectors"
@

@= varsized_meanvector_m
   .COMMAND meanvector(BAT[any,@1s],int) : @2s = cmd_@1s_meanvector;
      "Calculates mean vector of given set of vectors (Params: bat[vectors], dimension of vectors)"
@

@= fixedsize_meanvector_m
   .COMMAND meanvector(BAT[any,@1_vector@3]) : @2_vector@3 = cmd_@1_vector@3_meanvector;
      "Calculates mean vector of given set of vectors"
@

@= varsized_convert_m
   .COMMAND to@2s(@1s) : @2s = cmd_@1s_@2s_convert;
     "Converts vectors of @1s to vector of @2s"
@

@= fixedsize_convert_m
   .COMMAND to@2_vector@3(@1_vector@3) : @2_vector@3 = cmd_@2_@1_convert;
     "Converts vector of type @1_vector@3 to vector of type @2_vector@3"
@

@= varsized_aggregate_m
   .COMMAND @2range(bat[any,@1s] vecs) : @1s = cmd_@1s_@2range;
     "Determine the @2 values of each dimension in the vectors."
@

@= fixedsize_aggregate_m
   .COMMAND @3range(bat[any,@1_vector@2]) : @1_vector@2 = cmd_@1_vector@2_@3range;
     "Determines the @2 values of each dimension in the vectors."
@

@= varsized_operators_m
   .OPERATOR (@1s) "+" (@1s) : @1s = opr_@1s_add;
     "Addition of vectors of @1s"

   .OPERATOR (@1s) "-" (@1s) : @1s = opr_@1s_subtract;
     "Subtraction of vectors of @1s (param 1 - param 2)"

   .OPERATOR1 (@1s) "*" (@1)  : @1s = opr_@1s_multiply;
     "Multiplication of vector of @1s with scalar"

   .OPERATOR1 (@1s) "/" (@1)  : @1s = opr_@1s_divide;
     "Divide vector of @1s by @1"
@

@= fixedsize_operators_m
   .OPERATOR (@1_vector@2) "+" (@1_vector@2) : @1_vector@2 = opr_@1_vector@2_add;
     "Addition of vectors of @1_vector@2"

   .OPERATOR (@1_vector@2) "-" (@1_vector@2) : @1_vector@2 = opr_@1_vector@2_subtract;
     "Subtraction of vectors of @1s (param 1 - param 2)"

   .OPERATOR1 (@1_vector@2) "*" (@1)  : @1_vector@2 = opr_@1_vector@2_multiply;
     "Multiplication of vector of @1s with scalar"

   .OPERATOR1 (@1_vector@2) "/" (@1)  : @1_vector@2 = opr_@1_vector@2_divide;
     "Divide vector of @1s by @1"
@

@= varsized_h
typedef struct {
    int dimension;
    @1 data[1];
} @1s;

@1s* @1screate(int dim);
@

@= fixedsize_h
typedef @1s @1_vector@2;
/*
typedef struct {
    int dimension;
    @1 data[@2];
} @1_vector@2;
*/

@

@c
#define convert_int normal_int_SWAP
#define convert_flt normal_int_SWAP
#define convert_dbl long_long_SWAP

@= varsized_c
    size_t @1ssize(int dim) {
      return(sizeof(@1s) + (((dim > 0) ? (dim - 1) : (0)) * sizeof(@1)));
    }

    @1s* @1screate(int dim) {
       @1s *rval = (@1s *)GDKmalloc(@1ssize(dim));
       rval->dimension = dim;
       return(rval);
    }

    int atom_@1s_tostr(str *tostr, int* l, @1s* p) {
        char *s;
        int i;

        {
            int expectedlen = 20 + (p->dimension * 15);
            if(*l < expectedlen)
            {
                if(*tostr != NULL) {
                    GDKfree(*tostr);
                }
                *tostr = GDKmalloc(expectedlen);
                *l = expectedlen;
            }
        }

        sprintf(*tostr,"(%d:", p->dimension);
        s = *tostr + strlen(*tostr);

        for(i = 0; i < p->dimension; ++i) {
            sprintf(s, "%s@3", ( (i == 0) ? "" : "," ), p->data[i]);
            s += strlen(s);
        }
        *s++ = ')';
        *s = '\0';
        return (int) (s - *tostr);
    }

    int atom_@1s_fromstr(str instr,int* l,@1s** val) {
        long    dim = 0;
        char    *s;
        int     i;
        @1s     *result;

        for(i = 0, s = instr; *s && i < 1 && *s != ')' ; ++s) {
            if(*s == ',' || (*s == '(' && !i)) {
                dim = atol(s + 1);
                ++i;
            }
        }

        if(*val == NULL) {
            *val = GDKmalloc(@1ssize(dim));
            (*val)->dimension = dim;
            *l = (int) @1ssize(dim);
        } else if (*l < (int)@1ssize(dim)) {
            GDKfree(*val);
            *val = GDKmalloc(@1ssize(dim));
            (*val)->dimension = dim;
            *l = (int) @1ssize(dim);
        }
        result = *val;

        for(i = 0; *s && i < result->dimension && *s != ')'; ++s) {
            if(*s == ',' || *s == ':') {
                ++s;
                result->data[i] = (@1) @2(s,&s);
                --s;
                ++i;
            }
        }

        return (int) (s - instr);
    }

    @1s *atom_@1s_read(@1s* a, stream *s, size_t sz) {
	int dim;
	size_t i;
	for(i=0;i<sz;i++){
		if (!stream_readInt(s,&dim))
			return NULL;
	
        	if ((a = (@1s *)GDKmalloc(@1ssize(dim))) == NULL)
			return NULL;
		a->dimension = dim;
		stream_read(s, (char*)a->data, 1, dim*sizeof(@1));
		if (stream_errnr(s)) {
			GDKfree(a);
			return NULL;
		}
		if (stream_byteorder(s) != 1234){
			int i;
			for (i=0;i<dim;i++) {
				@6 *p = (@6 *) &a->data[i];
				*p = convert_@1(*p);
			}
		}
	}
	return a;
    }

    void atom_@1s_write(@1s* a, stream *s, size_t sz) {
	size_t i;
	for(i=0;i<sz;i++){
		if (!stream_writeInt(s,a->dimension))
			return;
		if (stream_write(s, (char*)a->data, 1, a->dimension*sizeof(@1)) < 0)
			return;
	}
    }

    int atom_@1s_nequal(@1s* l,@1s*  r) {
        int i;
        if(l->dimension != r->dimension) {
            return(0);
        }

        for(i = 0; i < l->dimension; i++) {
            if(l->data[i] != r->data[i]) {
                return(0);
            }
        }

        return(1);
    }

    void atom_@1s_del(Heap* h,var_t* index) {
        HEAP_free(h,(size_t)*index);
    }

    @1s *atom_@1s_null(void) {
        static @1s *nullptr = NULL;
        if(nullptr == NULL) {
            nullptr = @1screate(0);
        }
        return(nullptr);
    }
    
    var_t atom_@1s_put(Heap* h, var_t* bun, @1s* val) {
        char* base;

        *bun  = HEAP_malloc(h,@1ssize(val->dimension));
        base = h->base;
        if (*bun) memcpy(&base[*bun],(char *)val, @1ssize(val->dimension));
	return *bun;
    }

    int atom_@1s_length(@1s* p) {
        return (int) @1ssize(p->dimension);
    }

    void atom_@1s_heap(Heap *heap, size_t capacity) {
        HEAP_initialize(heap, capacity, 0, @5);
    }

    hash_t atom_@1s_hash(@1s* p) {
        return (hash_t) (@1ssize(p->dimension));
    }

    /************ Commands follow *************/
    int cmd_@1s_rancreate(@1s **rval, int *dim) {
        int i;
        
        *rval = @1screate(*dim);
        for(i=0;i<(*dim);++i) (*rval)->data[i] = (@1) @4rand48();
        return(GDK_SUCCEED);
    }

    int cmd_@1s_dimension(int *rval, @1s *i) {
        *rval = i->dimension;
        return(GDK_SUCCEED);
    }

    int cmd_@1s_sum(@1 *rval, @1s *in) {
        register int i,dim = in->dimension;
        register dbl tmp = 0.0;

        for(i=0;i<dim;++i) {
            tmp += (dbl)(in->data[i]);
        }

        *rval = (@1) tmp;
        return GDK_SUCCEED;
    }

    int cmd_@1s_average(dbl* rval, @1s *in) {
        register int i,dim = in->dimension;
        register dbl tmp = 0.0;

        if(dim == 0) {
            GDKerror("[cmd_@1s_average]: Error, zero dimension.\n");
            return GDK_FAIL;
        }

        for(i=0;i<dim;++i) {
            tmp += (dbl)(in->data[i]);
        }
        *rval = tmp / (dbl)dim; 
        return GDK_SUCCEED;
    }

    int cmd_@1s_variance(dbl* rval, @1s *in) {
        dbl average;
        register dbl sigma = 0.0;
        register int i,dim = in->dimension;

        if(dim == 0) {
            GDKerror("[cmd_@1s_variance]: Error, zero dimension.\n");
            return GDK_FAIL;
        }

        cmd_@1s_average(&average,in); 
        for(i=0;i<dim;++i) {
            register dbl tmp = (dbl)(in->data[i]) - average;
            sigma += (tmp * tmp);
        }
        *rval = sqrt(sigma / (dbl)dim); 
        return GDK_SUCCEED;
    }

    int cmd_@1s_variance2(dbl* rval, @1s *in) {
        dbl average;
        register dbl sigma = 0.0;
        register int i,dim = in->dimension;

        if(dim == 0) {
            GDKerror("[cmd_@1s_variance2]: Error, zero dimension.\n");
            return GDK_FAIL;
        }

        cmd_@1s_average(&average,in); 
        for(i=0;i<dim;++i) {
            register dbl tmp = (dbl)(in->data[i]) - average;
            sigma += (tmp * tmp);
        }
        *rval = sigma / (dbl)dim; 
        return GDK_SUCCEED;
    }

    int cmd_@1s_d1distance(dbl *rval, @1s *I1, @1s *I2) {
        int i,dim = I1->dimension;
   
        if(I1->dimension != I2->dimension) {
            GDKerror("[cmd_@1s_d1distance]: D1distance between vectors of different dimension.\n");
            return GDK_FAIL;
        }
  
        *rval = 0;
        for(i=0;i<dim;++i) {
            *rval += fabs(I2->data[i] - I1->data[i]) / 
                                    (1 + I2->data[i] + I1->data[i]);
        }

        return GDK_SUCCEED;
    }

    int cmd_@1s_l1distance(dbl *rval, @1s *I1, @1s *I2) {
        int i,dim = I1->dimension;
   
        if(I1->dimension != I2->dimension) {
            GDKerror("[cmd_@1s_l1distance]: L1distance between vectors of different dimension.\n");
            return GDK_FAIL;
        }
  
        *rval = 0;
        for(i=0;i<dim;++i) {
            *rval += fabs(I2->data[i] - I1->data[i]);
        }

        return GDK_SUCCEED;
    }

    int cmd_@1s_l2distance(dbl *rval, @1s *I1, @1s *I2) {
        double tmp;
        int i,dim = I1->dimension;
   
        if(I1->dimension != I2->dimension) {
            GDKerror("[cmd_@1s_l2distance]: L2distance between vectors of different dimension.\n");
            return GDK_FAIL;
        }
  
        *rval = 0;
        for(i=0;i<dim;++i) {
            tmp   = (double)(I2->data[i] - I1->data[i]);
            *rval += tmp * tmp;
        }
        *rval = sqrt(*rval);

        return GDK_SUCCEED;
    }

    int cmd_@1s_yldistance(dbl *rval,@1s *I1,@1s *I2) {
        double s0=0.0,s1=0.0,s2=0.0;
        register @1s *sum;
        register int i,dim = I1->dimension;
        @1 m,n;
        
        if(I1->dimension != I2->dimension) {
            GDKerror("[cmd_@1s_l2distance]: L2distance between vectors of different dimension.\n");
            return GDK_FAIL;
        }
  
        sum = GDKmalloc(@1ssize(dim));
        sum->dimension = dim;
        for(i=0;i<dim;++i) {
            sum->data[i] = I1->data[i] + I2->data[i];
        } 
        cmd_@1s_variance2(&s0,sum); 
        cmd_@1s_variance2(&s1,I1); 
        cmd_@1s_variance2(&s2,I2); 
        GDKfree(sum);

        cmd_@1s_sum(&m,I1);
        cmd_@1s_sum(&n,I2);
        if(m==n) {
            *rval = (s0/s1)*(s0/s2);
        } else {
            *rval = pow(s0,m+n) / (pow(s2,m) * pow(s2,n));
        }

        return GDK_SUCCEED;
    }


    int cmd_@1s_ksdistance(dbl *rval,@1s *I1,@1s *I2) {
        register int i,dim = I1->dimension;
        @1  n1,n2;
        dbl d,n,x,s,chp,chc,m1,m2;

        if(I1->dimension != I2->dimension) {
            GDKerror("[cmd_@1s_ksdistance]: KSdistance between vectors of different dimension.\n");
            return GDK_FAIL;
        }
        if(dim == 0) {
            GDKerror("[cmd_@1s_ksdistance]: Zero dimension !\n");
            return GDK_FAIL;
        }

        /* D = D+ + D-
         * D+ = m1 = MAXj (CHPj - CHCj)
         * D- = m2 = MAXj (CHCj - CHPj)
         */
        chp = chc = 0.0;
        m1  = m2  = 0.0;
        cmd_@1s_sum(&n1,I1);
        cmd_@1s_sum(&n2,I2);
        for(i=0;i<dim;++i) {
            register dbl t1,t2;
            /* Normalize... */
            chp += ((dbl)I1->data[i]) / ((dbl)n1);
            chc += ((dbl)I2->data[i]) / ((dbl)n2);
            t1  = chp - chc;
            t2  = chc - chp;
            if(t1 > m1) m1 = t1; 
            if(t2 > m2) m2 = t2; 
        }
        d = m1 + m2;

        /* Ne = n = N1*N2 / N1+N2
           Qtk = Q(sqrt(Ne) + 0.155 + 0.24/sqrt(Ne) * D)
         */
        n1 = n2 = (@1) dim;
        n = ((dbl)(n1+n2)) / ((dbl)(n1+n2));
        x = sqrt((dbl)n);
        x = x + 0.155 + ((0.24/x) * d);

        s = 0;
        x = x * x;
        #define SIGNPOW(X) ((((int)(X))&1)?(-1):(1))
        for(i=1;i<4;i++) {
            s += SIGNPOW(i+1) * (1.0/exp(2*i*i*x));
        }
        #undef SIGNPOW
        
        *rval = 2 * s;

        return GDK_SUCCEED;
    }

    int cmd_@1s_iddistance(dbl *rval,@1s *I1,@1s *I2) {
        register int i,dim = I1->dimension;
        register dbl id = 0.0;
        @1  n1,n2;

        if(I1->dimension != I2->dimension) {
            GDKerror("[cmd_@1s_iddistance]: IDdistance between vectors of different dimension.\n");
            return GDK_FAIL;
        }

        cmd_@1s_sum(&n1,I1);
        cmd_@1s_sum(&n2,I2);
        if((n1==0) || (n2==0)) {
            GDKerror("[cmd_@1s_iddistance]: IDdistance, caused divide by 0.\n");
            return GDK_FAIL;
        }

        if(n1 != n2) {
            for(i=0;i<dim;++i) {
                id += MIN((((dbl)I1->data[i])/((dbl)n1)),(((dbl)I2->data[i])/((dbl)n2)));
            }
            *rval = id;
        } else {
            for(i=0;i<dim;++i) {
                id += MIN(I1->data[i],I2->data[i]);
            }
            *rval = id / ((dbl)n1);
        }

        return GDK_SUCCEED;
    }

    int cmd_@1s_getval(@1 *rval, @1s *I, int *index) {
        if((*index > I->dimension) || (*index < 0)) {
            GDKwarning("[cmd_@1s_getval]: Index out of bounds.\n");
            return(GDK_FAIL);
        }
        *rval = I->data[*index];
        return(GDK_SUCCEED);
    }

    int cmd_@1s_centroid(dbl *res, @1s *vec) {
        int i;
        dbl num, denum;

        num = denum = 0.0;
        for(i = 0; i < vec->dimension; i++) {
            denum += vec->data[i];
            num += vec->data[i] * (i + 1);
        }
        *res = num / denum;

        return(GDK_SUCCEED);
    }

    int cmd_@1s_length(dbl *res, @1s *vec) {
        int i;
        dbl sum = 0.0;

        for(i = 0; i < vec->dimension; i++) {
            sum += ((dbl)vec->data[i] * (dbl)vec->data[i]);
        }

        *res = sqrt(sum);
        return(GDK_SUCCEED);
    }
@

@= varsized_convert_c
    int cmd_@1s_@2s_convert(@2s **res, @1s *v) {
        int i;

        *res = @2screate(v->dimension);
        for(i = 0; i < v->dimension; i++) (*res)->data[i] = (@2)(v->data[i] @3);
        return(GDK_SUCCEED);
    }
@

@= fixedsize_convert_c
    int cmd_fixedvec_@1_@2_convert(@2_vector@3 *res, @1_vector@3 *v) {
        int i;

        for(i = 0; i < v->dimension; i++) res->data[i] = (@2)(v->data[i] @4);
        return(GDK_SUCCEED);
    }
@

@= varsized_operators_c
    int opr_@1s_add(@1s **res, @1s *v1, @1s *v2) {
        int i;

        if(v1->dimension != v2->dimension) {
            GDKerror("[opr_@1s_add]: vectors have unequal dimension.\n");
            return(GDK_FAIL);
        }

        *res = @1screate(v1->dimension);
        for(i = 0; i < v1->dimension; i++) {
            (*res)->data[i] = v1->data[i] + v2->data[i];
        }

        return(GDK_SUCCEED);
    }
    
    int opr_@1s_subtract(@1s **res, @1s *v1, @1s *v2) {
        int i;

        if(v1->dimension != v2->dimension) {
            GDKerror("[opr_@1s_subtract]: vectors have unequal dimension.\n");
            return(GDK_FAIL);
        }

        *res = @1screate(v1->dimension);
        for(i = 0; i < v1->dimension; i++) {
            (*res)->data[i] = v1->data[i] - v2->data[i];
        }
   
        return(GDK_SUCCEED);
    }

    int opr_@1s_multiply(@1s **res, @1s *v, @1 *s) {
        int i;

        *res = @1screate(v->dimension);
        for(i = 0; i < v->dimension; i++) {
            (*res)->data[i] = v->data[i] * (*s);
        }
        return(GDK_SUCCEED);
    }

    int opr_@1s_divide(@1s **res, @1s *v, @1 *s) {
        int i;

        *res = @1screate(v->dimension);
        for(i = 0; i < v->dimension; i++) {
            (*res)->data[i] = v->data[i] / (*s);
        }
        return(GDK_SUCCEED);
    }
@

@= fixedsize_operators_c
    int opr_@1_vector@2_add(@1_vector@2 *res, @1_vector@2 *v1, @1_vector@2 *v2) {
        int i;

        if(v1->dimension != v2->dimension) {
            GDKerror("[opr_@1_vector@2_add]: vectors have unequal dimension.\n");
            return(GDK_FAIL);
        }

        for(i = 0; i < @2; i++) {
            res->data[i] = v1->data[i] + v2->data[i];
        }

        return(GDK_SUCCEED);
    }
    
    int opr_@1_vector@2_subtract(@1_vector@2 *res, @1_vector@2 *v1, @1_vector@2 *v2) {
        int i;

        if(v1->dimension != v2->dimension) {
            GDKerror("[opr_@1_vector@2_subtract]: vectors have unequal dimension.\n");
            return(GDK_FAIL);
        }

        for(i = 0; i < @2; i++) {
            res->data[i] = v1->data[i] - v2->data[i];
        }
   
        return(GDK_SUCCEED);
    }

    int opr_@1_vector@2_multiply(@1_vector@2 *res, @1_vector@2 *v, @1 *s) {
        int i;

        for(i = 0; i < @2; i++) {
            res->data[i] = v->data[i] * (*s);
        }
        return(GDK_SUCCEED);
    }

    int opr_@1_vector@2_divide(@1_vector@2 *res, @1_vector@2 *v, @1 *s) {
        int i;

        for(i = 0; i < @2; i++) {
            res->data[i] = v->data[i] / (*s);
        }
        return(GDK_SUCCEED);
    }
@

@= varsized_normalize_c
    int cmd_@1s_normalize(@2s **res, @1s *vec) {
        int i, zeroCtr = 0;
        @2 sum = 0;

        for(i = 0; i < vec->dimension; i++) {
            if(vec->data[i] == 0) zeroCtr++;
        }

        if(zeroCtr == vec->dimension) {
            GDKerror("[cmd_@1s_normalize]: trying to normalize a null-vector???\n");
            return(GDK_FAIL);
        }

        *res = @2screate(vec->dimension);
        for(i = 0; i < vec->dimension; i++) {
            sum += ((@2)vec->data[i] * (@2)vec->data[i]);
        }

        for(i = 0; i < vec->dimension; i++) {
            (*res)->data[i] = (@2)((dbl)vec->data[i] / sqrt((dbl)sum));
        }

        return(GDK_SUCCEED);
    }
@

@= fixedsize_normalize_c
    int cmd_@1_vector@3_normalize(@2_vector@3 *res, @1_vector@3 *vec) {
        int i, zeroCtr = 0;
        @2 sum = 0;

        for(i = 0; i < vec->dimension; i++) {
            if(vec->data[i] == 0) zeroCtr++;
        }

        if(zeroCtr == vec->dimension) {
            GDKerror("[cmd_@1_vector@2_normalize]: trying to normalize a null-vector???\n");
            return(GDK_FAIL);
        }

        for(i = 0; i < vec->dimension; i++) {
            sum += ((@2)vec->data[i] * (@2)vec->data[i]);
        }

        for(i = 0; i < vec->dimension; i++) {
            res->data[i] = (@2)((dbl)vec->data[i] / sqrt((dbl)sum));
        }

        return(GDK_SUCCEED);
    }
@

@= varsized_twonormdiff_c
    int cmd_@1s_twonormdiff(@2s **res, @1s *vec1, @1s *vec2) {
        @2s *normVec1=NULL, *normVec2=NULL;
        int i;

        if(vec1->dimension != vec2->dimension) {
            GDKerror("[@1s_@1s_2normdiff]: vectors have unequal dimension.\n");
            return(GDK_FAIL);
        }

        *res = @2screate(vec1->dimension);
        cmd_@1s_normalize(&normVec1, vec1);
        cmd_@1s_normalize(&normVec2, vec2);
        for(i = 0; i < (*res)->dimension; i++) {
            (*res)->data[i] = normVec1->data[i] - normVec2->data[i];
        }
        GDKfree(normVec1);
        GDKfree(normVec2);

        return(GDK_SUCCEED);
    }
@

@= fixedsize_twonormdiff_c
    int cmd_@1_vector@3_twonormdiff(@2_vector@3 *res, @1_vector@3 *vec1, @1_vector@3 *vec2) {
        @2s *normVec1=NULL,*normVec2=NULL;
        int i;

        if(vec1->dimension != vec2->dimension) {
            GDKerror("[@1s_@1s_2normdiff]: vectors have unequal dimension.\n");
            return(GDK_FAIL);
        }

        cmd_@1s_normalize(&normVec1, vec1);
        cmd_@1s_normalize(&normVec2, vec2);
        for(i = 0; i < @3; i++) {
            res->data[i] = normVec1->data[i] - normVec2->data[i];
        }
        GDKfree(normVec1);
        GDKfree(normVec2);

        return(GDK_SUCCEED);
    }
@

@= varsized_meanvector_c
    int cmd_@1s_meanvector(@2s **res, BAT *b, int *dim) {
        BUN p, q;
        int i, m;

        if(b->ttype != TYPE_@1s) {
            GDKerror("[cmd_@1s_meanvector]: BAT has wrong tail datatype (need @1s). (%d) (%d) (%d)\n", b->ttype,TYPE_@1s, ATOMindex("dbls"));
            return(GDK_FAIL);
        }

        *res = @2screate(*dim);
        for(i = 0; i < (*res)->dimension; i++) (*res)->data[i] = 0;
        BATloopFast(b, p, q, m) {
            @1s *val = (@1s *)BUNtvar(b, p);
            for(i = 0; i < (*res)->dimension; i++) {
                (*res)->data[i] += (@2)val->data[i];
            }
        }

        for(i = 0; i < (*res)->dimension; i++) {
            (*res)->data[i] /= (@2)BATcount(b);
        }

        return(GDK_SUCCEED);
    }
@

@= fixedsize_meanvector_c
    int cmd_@1_vector@3_meanvector(@2_vector@3 *res, BAT *b) {
        BUN p, q;
        int i, m;

        if(b->ttype != TYPE_@1_vector@3) {
            GDKerror("[cmd_@1_vector@3_meanvector]: BAT has wrong tail datatype (need @1_vector@3).\n");
            return(GDK_FAIL);
        }

        for(i = 0; i < @3; i++) res->data[i] = 0;
        BATloopFast(b, p, q, m) {
            @1_vector@3 *val = (@1_vector@3 *)BUNtail(b, p);
            for(i = 0; i < @3; i++) {
                res->data[i] += val->data[i];
            }
        }

        for(i = 0; i < @3; i++) {
            res->data[i] /= (@2)BATcount(b);
        }

        return(GDK_SUCCEED);
    }
@
    
@= varsized_aggregate_c
    int cmd_@1s_@2range(@1s **rval, BAT *vecs) {
        int  i,xx, first = 1;
        BUN  p,q;
        BUN  firstbun = BUNfirst(vecs);
        @1s* vec      = (@1s*)(BUNtvar(vecs, firstbun));
        int  dim      = vec->dimension;

        
        /* Make Copy... */
        if(first) {
            *rval = @1screate(dim);
            for(i = 0; i < dim; i++) {
                (*rval)->data[i] = vec->data[i];
            }
        }

        /* Compute aggregate */
        BATloopFast(vecs, p, q, xx) {
            if(first) { first = 0; continue; }
            vec = (@1s *)BUNtvar(vecs, p);
            if(vec->dimension != dim) {
                GDKerror( "[cmd_@1s_@2range]: Cannot compute @2range for vectors of different lengths.\n");
                return(GDK_FAIL);
            }
            for(i = 0; i < dim; i++) (*rval)->data[i] = @3((*rval)->data[i],vec->data[i]);
        }

        return(GDK_SUCCEED);
    }
@

@= fixedsize_aggregate_c
    int cmd_@1_vector@2_@3range(@1_vector@2 *rval, BAT *vecs) {
        int  i,xx, first = 1;
        BUN  p,q;
        BUN  firstbun = BUNfirst(vecs);
        @1_vector@2 *vec      = (@1_vector@2 *)(BUNtloc(vecs, firstbun));
        int  dim      = vec->dimension;

        /* Make Copy... */
        if(first) {
            for(i = 0; i < dim; i++) {
                rval->data[i] = vec->data[i];
            }
        }

        /* Compute aggregate */
        BATloopFast(vecs, p, q, xx) {
            if(first) { first = 0; continue; }
            vec = (@1_vector@2 *)BUNtvar(vecs, p);
            if(vec->dimension != dim) {
                GDKerror( "[cmd_@1_vector@2_@3range]: Cannot compute @3range for vectors of different lengths.\n");
                return(GDK_FAIL);
            }
            for(i = 0; i < dim; i++) rval->data[i] = @4(rval->data[i], vec->data[i]);
        }

        return(GDK_SUCCEED);
    }
@

@= varsized_opsmiltest
@3vbat.insert(str("Addition (@1s + @2s)"), (@1v + @2v));
@3vbat.insert(str("Subtraction (@1s - @2s)"), (@1v - @2v));
@3vbat.insert(str("Multiplication with scalar (@1s * @2(2))"), (@1v * @2(2)));
@3vbat.insert(str("Division with scalar (@1s / @2(2))"), (@1v / @2(2)));

@

@= varsized_opsmiltest
@3vbat.insert(str("Addition (@1s + @2s)"), (@1v + @2v));
@3vbat.insert(str("Subtraction (@1s - @2s)"), (@1v - @2v));
@3vbat.insert(str("Multiplication with scalar (@1s * @2(2))"), (@1v * @2(2)));
@3vbat.insert(str("Division with scalar (@1s / @2(2))"), (@1v / @2(2)));
@

@= varsized_commandsmiltest
printf("Length of normalized @1s vector:\n");
length(normalize(@1v)).print();

@1vecs := bat(void, @1s);
var i := 0;
while(i < 10) {
    @1vecs.insert(nil, @1s("(3:1,1,1)"));
    i := i + 1;
}

printf("Mean vector of @1vecs:\n");
meanvector(@1vecs,3).print();
@

@= varsized_tests
# create some data
vecs := new(void, flts);
vecs.insert(nil, flts_rancreate(10));
vecs.insert(nil, flts_rancreate(10));
vecs.insert(nil, flts_rancreate(10));
vecs.seqbase(0@0);

vecs.print();

# project 5th dimension
[getval](vecs,4).print();

# range of data
xmax:= maxrange(vecs);
xmin:= minrange(vecs);

printf("maxrange and minrange:\n");
xmax.print();
xmin.print();

printf("L2distance for xmax and xmin:\n");
L2distance(xmin, xmax).print();

intvbat := bat(str, ints);
fltvbat := bat(str, flts);
dblvbat := bat(str, dbls);

intv := ints("(3:1,1,1)"); 
fltv := flts("(3:1.0,1.0,1.0)"); 
dblv := dbls("(3:1.0,1.0,1.0)"); 

@:varsized_opsmiltest(int,int,int)@
@:varsized_opsmiltest(flt,flt,flt)@
@:varsized_opsmiltest(dbl,dbl,dbl)@

intv.print();
fltv.print();
dblv.print();

@:varsized_commandsmiltest(int)@
@:varsized_commandsmiltest(flt)@
@:varsized_commandsmiltest(dbl)@
@

@= fixedsize_c
    int atom_@1_vector@2_tostr(char **tostr, int *l, @1_vector@2 *p) {
        char *s;
        int i;

        {
            int expectedlen = 20 + @2 * 15;
            if(*l < expectedlen) {
                if(*tostr != NULL) {
                    GDKfree(*tostr);
                }
                *tostr = GDKmalloc(expectedlen);
                *l = expectedlen;
            }
        }

        sprintf(*tostr,"(%d:", @2);
        s = *tostr + strlen(*tostr);

        for(i = 0; i < @2; ++i) {
           sprintf(s,"%s@5", ((i == 0) ? "" : ","), p->data[i]);
           s += strlen(s);
        }

        *s++ = ')';
        *s = '\0';
        return (int) (s - *tostr);
    }

    int atom_@1_vector@2_fromstr(str instr, int *l, @1_vector@2 **val) {
        char         *s;
        int          i;
        @1_vector@2  *result;

        if(*val == NULL) {
            *val = GDKmalloc(@3);
            (*val)->dimension = @2;
            *l = @3;
        } else if(*l < @3) {
            GDKfree(*val);
            *val = GDKmalloc(@3);
            (*val)->dimension = @2;
            *l = @3;
        }

        result = *val;

        for(s = instr; *s != '('; ++s)
            ;

        for(i = 0; i < @2 && *s != ')'; ++s) {
            if(*s == ',' || *s == ':') {
                ++s;
                result->data[i] = @4(s,&s);
                --s;
                ++i;
            }
        }

        return (int) (s - instr);
    }

    @1_vector@2 *atom_@1_vector@2_read(@1_vector@2* a, stream *s, size_t sz) {
	a->dimension = @2;
	stream_read(s, (char*)a->data, sz, @2*sizeof(@1));
	if (stream_errnr(s))
		return NULL;
	
	if (stream_byteorder(s) != 1234){
		int i;
		size_t j;
		for (j=0;j<sz;j++) 
			for (i=0;i<@2;i++) {
				@8 *p = (@8 *) &a->data[i];
				*p = convert_@1(*p);
			}
	}
	return a;
    }

    void atom_@1_vector@2_write(@1_vector@2* a, stream *s, size_t sz) {
	stream_write(s, (char*)a->data, sz, @2*sizeof(@1));
    }


    @1_vector@2* atom_@1_vector@2_null(void) {
        static char nullptr[@3];
        static int init = 1;
        if(init) {
            int i;
            @1_vector@2* p = (@1_vector@2*)nullptr;
            init = 0;
            p->dimension = @2;
            for(i = 0; i < @2; i++) p->data[i] = 0;
        }
        return (@1_vector@2*)nullptr;
    }
    
    int atom_@1_vector@2_nequal(@1_vector@2 *l, @1_vector@2 *r) {
        int i;
        if(l->dimension != r->dimension) {
            return(0);
        }

        for(i = 0; i < @2; i++) {
            if(l->data[i] != r->data[i]) {
                return(0);
            }
        }

        return(1);
    }

    /** Commands follow **/
    int cmd_@1_vector@2_rancreate(@1_vector@2 *res) {
        int i;

        res->dimension = @2;
        for(i=0; i < @2; i++) {
            res->data[i] = @6rand48();
        }
        return(GDK_SUCCEED);
    }
@

@m
@:varsized_m(int)@
@:varsized_m(flt)@
@:varsized_m(dbl)@

@:fixedsize_m(dbl,32,264)@
@:fixedsize_m(int,64,260)@

@:varsized_convert_m(int,flt)@
@:varsized_convert_m(int,dbl)@
@:varsized_convert_m(flt,dbl)@
@:varsized_convert_m(flt,int)@
@:varsized_convert_m(dbl,flt)@
@:varsized_convert_m(dbl,int)@

@:varsized_normalize_m(int,flt)@
@:varsized_normalize_m(flt,flt)@
@:varsized_normalize_m(dbl,dbl)@

@:fixedsize_normalize_m(dbl,dbl,32)@

@:varsized_twonormdiff_m(int,flt)@
@:varsized_twonormdiff_m(flt,flt)@
@:varsized_twonormdiff_m(dbl,dbl)@

@:fixedsize_twonormdiff_m(dbl,dbl,32)@

@:varsized_meanvector_m(int,flt)@
@:varsized_meanvector_m(flt,flt)@
@:varsized_meanvector_m(dbl,dbl)@

@:fixedsize_meanvector_m(dbl,dbl,32)@

@:varsized_aggregate_m(int,max)@
@:varsized_aggregate_m(int,min)@
@:varsized_aggregate_m(flt,max)@
@:varsized_aggregate_m(flt,min)@
@:varsized_aggregate_m(dbl,max)@
@:varsized_aggregate_m(dbl,min)@

@:fixedsize_aggregate_m(dbl,32,max)@
@:fixedsize_aggregate_m(dbl,32,min)@
@:fixedsize_aggregate_m(int,64,max)@
@:fixedsize_aggregate_m(int,64,min)@

@:varsized_operators_m(int)@
@:varsized_operators_m(flt)@
@:varsized_operators_m(dbl)@

@:fixedsize_operators_m(dbl,32)@
@:fixedsize_operators_m(int,64)@

.END vector;

@h
@:varsized_h(int)@
@:varsized_h(flt)@
@:varsized_h(dbl)@

@:fixedsize_h(dbl,32)@
@:fixedsize_h(int,64)@

#endif

@c
@:varsized_c(int,get_long,%d,m,4,int)@
@:varsized_c(flt,get_double,%f,d,8,int)@
@:varsized_c(dbl,get_double,%f,d,8,lng)@

@:fixedsize_c(dbl,32,264,get_double,%f,d,8,lng)@
@:fixedsize_c(int,64,260,get_long,%d,m,4,int)@

@:varsized_convert_c(int,flt,/**/)@
@:varsized_convert_c(int,dbl,/**/)@
@:varsized_convert_c(flt,dbl,/**/)@
@:varsized_convert_c(dbl,flt,/**/)@
@:varsized_convert_c(flt,int,+0.5f)@
@:varsized_convert_c(dbl,int,+0.5)@

@:varsized_normalize_c(int,flt)@
@:varsized_normalize_c(flt,flt)@
@:varsized_normalize_c(dbl,dbl)@

@:fixedsize_normalize_c(dbl,dbl,32)@

@:varsized_twonormdiff_c(int,flt)@
@:varsized_twonormdiff_c(flt,flt)@
@:varsized_twonormdiff_c(dbl,dbl)@

@:fixedsize_twonormdiff_c(dbl,dbl,32)@

@:varsized_meanvector_c(int,flt)@
@:varsized_meanvector_c(flt,flt)@
@:varsized_meanvector_c(dbl,dbl)@

@:fixedsize_meanvector_c(dbl,dbl,32)@

@:varsized_aggregate_c(int,max,MAX)@
@:varsized_aggregate_c(int,min,MIN)@
@:varsized_aggregate_c(flt,max,MAX)@
@:varsized_aggregate_c(flt,min,MIN)@
@:varsized_aggregate_c(dbl,max,MAX)@
@:varsized_aggregate_c(dbl,min,MIN)@

@:fixedsize_aggregate_c(dbl,32,max,MAX)@
@:fixedsize_aggregate_c(dbl,32,min,MIN)@
@:fixedsize_aggregate_c(int,64,max,MAX)@
@:fixedsize_aggregate_c(int,64,min,MIN)@

@:varsized_operators_c(int)@
@:varsized_operators_c(flt)@
@:varsized_operators_c(dbl)@

@:fixedsize_operators_c(dbl,32)@
@:fixedsize_operators_c(int,64)@

@mil
PROC test_vector() : void {   
	@:varsized_tests@
}

