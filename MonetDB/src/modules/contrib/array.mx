@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2006 CWI.
@' All Rights Reserved.

@f array
@a A.R. van Ballegooij
@* Basic array support


@m
.MODULE array;
@= grid_mdefs
  .COMMAND grid(@1,@1,@1,@1) : bat[void,@1] = grid_@1;
    "Generates an index BAT, (grpcount,grpsize,clustersize,offset)"
@m
@:grid_mdefs(int)@
@:grid_mdefs(lng)@

  .COMMAND print_array(bat[any::1,any],...bat[any::1,int]...) : void = print_array;
    "Prints an array, using 1 value bat and N aligned index bats"
  
  .COMMAND ram(str,str,int,int,str) : str = ram_impl;
    "Converts ram to mil/x100. Caution: this is just a temporary hack. Parameters: ram basedir, ram query, optimization1 level, optimization2 level, translator "

.END array;

@h
/*============================================================================*/
#ifndef __array_h__
#define __array_h__

#include <gdk.h>
#include <algebra.h>		/* to include BATmin and BATmax */

#include "array.proto.h"
@= grid_hdefs
#define new_@1_bat(b,s) {(b)=BATnew(TYPE_void,TYPE_@1,(size_t) (s)); \
                         BATseqbase((b),0);                 }
#define add_@1s(b,n)    {(b)->batBuns->free+=(size_t)(n)*sizeof(@1);\
			                   (b)->batCount+=(size_t)n;\
                         BATkey(BATmirror((b)),0);          \
                         (b)->tsorted = 0;                  }
#define get_@1_ptr(b)   ((@1*)(BUNfirst((b))))
@h
@:grid_hdefs(int)@
@:grid_hdefs(lng)@

/* The maximum number of dimensions that the print-function can handle... */
#define MAX_ARRAY_DIM 16

#endif
/*============================================================================*/
@c
/*============================================================================*/
#include "array.h"
#include <math.h>
#include <time.h>

/*----------------------------------------------------------------------------*/

@= grid_impl
int
grid_@1(BAT **out, @1 *groups, @1 *groupsize, @1 *clustersize, @1 *offset)
{
	register @1 *ptr;
	@1 i = *groups;
	@1 n = *groupsize + *offset;
	@1 r = *clustersize;
	@1 o = *offset;

#ifdef EXCESSIVE_DEBUGGING
	fprintf(stderr, "[grid] (%d,%d,%d,%d)", i, n, r, o);
#endif

	new_@1_bat(*out, (i * (n - o) * r));
  if (out == NULL) {
    GDKerror("grid: cannot create the bat (%ld BUNs)\n", (i * (n - o) * r));
    return GDK_FAIL;
  }
  
	add_@1s(*out, (i * (n - o) * r));
	ptr = get_@1_ptr(*out);

	while (i--) {
		register @1 ni = o;

		while (ni < n) {
			register @1 ri = r;

			while (ri--)
				(*(ptr ++)) = ni;
			ni++;
		}
	}

#ifdef EXCESSIVE_DEBUGGING
	fprintf(stderr, "- done\n");
#endif

	return GDK_SUCCEED;
}
@c
@:grid_impl(int)@
@:grid_impl(lng)@


/*---------------------------------------------------------------------------*/
/*
   memory-hungry function;
   it internally builds the index to be able to print the array in-order.
*/

int
print_array(BAT *val, ...)
{
	va_list ap;
	BAT *tmp, *batptr[MAX_ARRAY_DIM];
	int *minvector;
	int *idxvector;
	int *maxvector;
	int *lenvector;
	oid *arrayindex;
	int i, dims;
	size_t j, c;
	stream *st = GDKout;
	int type_id = BATttype(val);

	va_start(ap, val);
	dims = 0;
	while ((tmp = va_arg(ap, BAT *)) != NULL) {
		if (dims == MAX_ARRAY_DIM) {
			GDKerror("print_array: Error, too high dimensionality.\n");
			goto exit_err_none;
		}
		batptr[dims++] = tmp;
	}
	if (dims == 0) {
		GDKerror("print_array: Error, no index bats provided.\n");
		goto exit_err_none;
	}
	va_end(ap);

#ifdef EXCESSIVE_DEBUGGING
	fprintf(stderr, "[PRINT_ARRAY] Dims = %d\n", dims);
#endif

	minvector = GDKmalloc(sizeof(ptr) * dims);
	idxvector = GDKmalloc(sizeof(int) * dims);
	maxvector = GDKmalloc(sizeof(ptr) * dims);
	lenvector = GDKmalloc(sizeof(ptr) * dims);

	c = 1;
	j = BATcount(val);
	for (i = 0; i < dims; i++) {
		if (BATttype(batptr[i]) != TYPE_int) {
			GDKerror("print_array: Index %d error, not int type\n", i);
			goto exit_err_part;
		}
		if (BATcount(batptr[i]) != j) {
			GDKerror("print_array: Index %d error, count doesn't match\n", i);
			goto exit_err_part;
		}

		BATmin(batptr[i], &(minvector[i]));
		BATmax(batptr[i], &(maxvector[i]));
		lenvector[i] = maxvector[i] - minvector[i] + 1;
		c *= lenvector[i];
#ifdef EXCESSIVE_DEBUGGING
		fprintf(stderr, "[PRINT_ARRAY] Axis %d = %d..%d\n", i, minvector[i], maxvector[i]);
#endif
	}

	if (c != j) {
		GDKerror("print_array: array size does not match array count\n");
		goto exit_err_part;
	}
	arrayindex = GDKmalloc(sizeof(oid) * c);

	/* Iterate over the first index BAT.              */
	/* And fetch additional indices (for a given oid) */
	/* building the full M-D structure (of oid's).    */
	{
		register BUN p, q;

		p = BUNfirst(batptr[0]);
		q = BUNlast(batptr[0]);
		while (p < q) {
			register oid *o = (oid *) BUNhead(batptr[0], p);
			register int offset;

			offset = *((int *) BUNtail(batptr[0], p)) - minvector[0];
			for (i = 1; i < dims; i++) {
				register BUN p = BUNfnd(batptr[i], o);

				if (p == NULL) {
					GDKerror("print_array: Index %d missing for oid %d.\n", i, *o);
					goto exit_err_full;
				}
				offset = (offset * lenvector[i]) + ((*((int *) p)) - minvector[i]);
			}
			arrayindex[offset] = *o;
			p = BUNnext(batptr[0], p);
		}
	}

	/* Iterate over all valid indices             */
	/* (note: normalized to [0..l-1] ranges !)    */
	/* And print the values within the 'correct'  */
	/* bracket structure...                       */
#ifdef EXCESSIVE_DEBUGGING
	fprintf(stderr, "[PRINT_ARRAY] ");
#endif
	for (i = 0; i < dims; i++)
		idxvector[i] = 0;
	while (idxvector[dims - 1] < lenvector[dims - 1]) {
		int offset;

		for (i = 0; i < dims; i++) {
			if (idxvector[i] != 0) {
#ifdef EXCESSIVE_DEBUGGING
				fprintf(stderr, ",");
#endif
				stream_printf(st, ",");
				break;
			}
		}
		i = 0;
		while (idxvector[i] == 0 && i < dims) {
#ifdef EXCESSIVE_DEBUGGING
			fprintf(stderr, "[");
#endif
			stream_printf(st, "[");
			i++;
		}
		for (offset = idxvector[0], i = 1; i < dims; i++) {
			offset = (offset * lenvector[i]) + idxvector[i];
		}
		{
			register BUN p = BUNfnd(val, &arrayindex[offset]);

			if (p == NULL) {
				GDKerror("print_array: Value missing for oid %d.\n", arrayindex[offset]);
				goto exit_err_full;
			}
#ifdef EXCESSIVE_DEBUGGING
			fprintf(stderr, "%d\@0", arrayindex[offset]);
#endif
			ATOMprint(type_id, BUNtail(val, p), st);
			if (stream_errnr(st))
				goto exit_err_full;
		}
		i = 0;
		while ((++idxvector[i]) == lenvector[i] && i < dims) {
#ifdef EXCESSIVE_DEBUGGING
			fprintf(stderr, "]");
#endif
			stream_printf(st, "]");
			if (i < dims - 1) {
				idxvector[i] = 0;
				i++;
			}
		}
	}
#ifdef EXCESSIVE_DEBUGGING
	fprintf(stderr, "\n");
#endif
	stream_printf(st, "\n");

	/* Exit strategies... */
	GDKfree(arrayindex);
	GDKfree(maxvector);
	GDKfree(idxvector);
	GDKfree(minvector);
	GDKfree(lenvector);
	return GDK_SUCCEED;

exit_err_full:
	GDKfree(arrayindex);
exit_err_part:
	GDKfree(maxvector);
	GDKfree(idxvector);
	GDKfree(minvector);
	GDKfree(lenvector);
exit_err_none:
	return GDK_FAIL;
}


/* Dirty hack to call RAM compiler from MIL/X100. This shouldn't be done at all. It's just used for preliminary tests */
int
ram_impl(str *output, str rampath, str ramquery, int *optlevel1, int *optlevel2, str translator)
{
  FILE *pin, *pout;
  char cmd[BUFSIZ];
  long size;
  
  if (strlen(ramquery) == 0) {
    GDKerror("Empty RAM query\n");
    return GDK_FAIL;
  }
  
  /* launch cmd using popen and writing the result to a tmp file */
  /* popen is not bidirectional, so we have to use a tmp file */ 
  
  if(strcmp(translator, "mil") == 0) {  
    sprintf(cmd, "%s/ram2alg -f%s/functions.txt | %s/alg_opt -o%d | %s/alg2mil >| .popen.out", 
                rampath, rampath, rampath, *optlevel1, rampath); 
  }
  else if(strcmp(translator, "x100") == 0) {  
    sprintf(cmd, "%s/ram2alg -f%s/functions.txt | %s/alg_opt -o%d | %s/alg2ralg -o%d | %s/ralg2amdb >| .popen.out", 
                rampath, rampath, rampath, *optlevel1, rampath, *optlevel2, rampath); 
  }
  pin = popen(cmd, "w");
  if (pin == NULL) {
    GDKerror("Command '%s' not executable\n", cmd);
    return GDK_FAIL;
  }
  fwrite((void *)ramquery, strlen(ramquery), 1, pin);
  pclose(pin);
  
  
  /* read the result from the tmp file */
  pout = fopen(".popen.out", "r");
  if (pout == NULL) {
    GDKerror("Error reading the output\n");
    return GDK_FAIL;
  }
  
  fseek(pout, 0L, SEEK_END);
  size = ftell(pout)+1;
  
  *output = (str) GDKmalloc(sizeof(char) * (size+1));
  memset((void *)*output, 0x00, size+1);
  rewind(pout);
  fread((void *)*output, size, 1, pout);
  fclose(pout);
  
/*
printf("size = %ld\n", size);
printf("cmd = %s\n", cmd);
*/
  
  return GDK_SUCCEED;
}

/*============================================================================*/
@mil

PROC cons(int n,any::1 v) : bat[void,any::1] {
	return project(grid(1,n,1,0),v);
}
ADDHELP("cons", "A.R. van Ballegooij", "Sep 20 2003",
"generates a bat with a constant column", "array");

PROC concat(bat[oid,any::1] a,bat[oid,any::1] b,int o) : bat[oid,any::1] {
	return access(insert(access(copy(a),BAT_WRITE),
			reverse([oid]([+]([int](reverse(b)),o)))) ,
			BAT_READ);
}
ADDHELP("concat", "A.R. van Ballegooij", "Sep 20 2003",
"Adds 'offset' two second arrays indexes and merges tables", "array");

if (mod() = "main"){
	print("Array module loaded...");
}
