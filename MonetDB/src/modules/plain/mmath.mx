@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2006 CWI.
@' All Rights Reserved.

@'		Alex van Ballegooij <Alex.van.Ballegooij@cwi.nl>

@f mmath
@a N.J. Nes
@d 07/01/1996
@t The math module

@* Introduction
This module contains the math commands. The implementation is very simply,
the c math library functions are called. See for documentation the
ANSI-C/POSIX manuals of the equally named functions.

@* Module Definition
@m
.MODULE mmath;

   .COMMAND acos(dbl)	  : dbl = math_unary_ACOS;
"The acos(x) function calculates the arc cosine of x;
that is the value whose cosine is x. The value is returned in radians
and is mathematically defined to be between 0 and PI (inclusive)."
   .COMMAND asin(dbl)	  : dbl = math_unary_ASIN;
"The asin(x) function calculates the arc sine of x;
that is the value whose sine is x. The value is returned in radians
and is mathematically defined to be between -PI/20 and -PI/2 (inclusive)."
   .COMMAND atan(dbl)	  : dbl = math_unary_ATAN;
"The atan(x) function calculates the arc tangent of x;
that is the value whose tangent is x. The value is returned in radians
and is mathematically defined to be between -PI/2 and PI/2 (inclusive)."
  .COMMAND atan2(dbl,dbl): dbl = math_binary_ATAN2;
"The atan2(x,y) function calculates the arc tangent of the two
variables x and y. It is similar to calculating the arc
tangent of y / x, except that the signs of both arguments
are used to determine the quadrant of the result.
The value is returned in radians and is mathematically defined
to be between -PI/2 and PI/2 (inclusive)."

   .COMMAND cos(dbl)	  : dbl = math_unary_COS;
"The cos(x) function returns the cosine of x,
where x is given in radians. The return value is between -1 and 1."
   .COMMAND sin(dbl)	  : dbl = math_unary_SIN;
"The sin(x) function returns the cosine of x,
where x is given in radians. The return value is between -1 and 1."
   .COMMAND tan(dbl)	  : dbl = math_unary_TAN;
"The tan(x) function returns the tangent of x,
where x is given in radians"

   .COMMAND cosh(dbl)	  : dbl = math_unary_COSH;
"The cosh() function returns the hyperbolic cosine of x,
which is defined mathematically as (exp(x) + exp(-x)) / 2."
   .COMMAND sinh(dbl)	  : dbl = math_unary_SINH;
"The sinh() function returns the hyperbolic sine of x,
which is defined mathematically as (exp(x) - exp(-x)) / 2."
   .COMMAND tanh(dbl)	  : dbl = math_unary_TANH;
"The tanh() function returns the hyperbolic tangent of x,
which is defined mathematically as sinh(x) / cosh(x)."

   .COMMAND exp(dbl)	  : dbl = math_unary_EXP;
"The exp(x) function returns the value of e
(the base of natural logarithms) raised to the power of x."
   .COMMAND log(dbl)	  : dbl = math_unary_LOG;
"The log(x) function returns the natural logarithm of x."
   .COMMAND log10(dbl)	  : dbl = math_unary_LOG10;
"The log10(x) function returns the base-10 logarithm of x."

   .COMMAND pow(dbl,dbl)  : dbl = math_binary_POW;
"The pow(x,y) function returns the value of x raised to the power of y."
   .COMMAND sqrt(dbl)	  : dbl = math_unary_SQRT;
"The sqrt(x) function returns the non-negative square root of x."

   .COMMAND ceil(dbl)	  : dbl = math_unary_CEIL;
"The ceil(x) function rounds x upwards to the nearest integer."
   .COMMAND fabs(dbl)	  : dbl = math_unary_FABS;
"The fabs(x) function returns the absolute value of the
floating-point number x."
   .COMMAND floor(dbl)	  : dbl = math_unary_FLOOR;
"The floor(x) function rounds x downwards to the nearest integer."
   .COMMAND fmod(dbl,dbl) : dbl = math_binary_FMOD;
"The fmod(x,y) function computes the remainder of dividing x by y.
The return value is x - n * y, where n is the quotient of x / y,
rounded towards zero to an integer."
   .COMMAND round(dbl,int)     : dbl = math_binary_ROUND;
"The round(n, m) returns n rounded to m places to the right of the
decimal point; if m is omitted, to 0 places. m can be negative to
round off digits left of the decimal point. m must be an integer."


   .COMMAND isnan(dbl) : bit = math_unary_ISNAN;
"The isnan(x) function returns true if x is 'not-a-number' (NaN), and false otherwise."
   .COMMAND isinf(dbl) : int = math_unary_ISINF;
"The isinf(x) function returns -1 if x represents negative infinity, 1 if x represents positive infinity, and 0 otherwise."
   .COMMAND finite(dbl) : bit = math_unary_FINITE;
"The finite(x) function returns true if x is neither infinite nor a 'not-a-number' (NaN) value, and false otherwise."

.END mmath;

@
The constants defined in math.h are defined using the following mil code.
@mil

	const M_E	:= 2.7182818284590452354LL;
	const M_LOG2E	:= 1.4426950408889634074LL;
	const M_LOG10E	:= 0.43429448190325182765LL;
	const M_LN2	:= 0.69314718055994530942LL;
	const M_LN10	:= 2.30258509299404568402LL;
	const M_PI	:= 3.14159265358979323846LL;
	const M_PI_2	:= 1.57079632679489661923LL;
	const M_PI_4	:= 0.78539816339744830962LL;
	const M_1_PI	:= 0.31830988618379067154LL;
	const M_2_PI	:= 0.63661977236758134308LL;
	const M_2_SQRTPI:= 1.12837916709551257390LL;
	const M_SQRT2	:= 1.41421356237309504880LL;
	const M_SQRT1_2	:= 0.70710678118654752440LL;

proc floor(flt f) : flt {return flt(floor(dbl(f)));}
proc ceil(flt f) : flt	{return flt(ceil(dbl(f)));}
proc sin(flt f) : flt	{return flt(sin(dbl(f)));}
proc cos(flt f) : flt	{return flt(cos(dbl(f)));}
proc tan(flt f) : flt	{return flt(tan(dbl(f)));}
proc asin(flt f) : flt	{return flt(asin(dbl(f)));}
proc acos(flt f) : flt	{return flt(acos(dbl(f)));}
proc atan(flt f) : flt	{return flt(atan(dbl(f)));}
proc sinh(flt f) : flt	{return flt(sinh(dbl(f)));}
proc cosh(flt f) : flt	{return flt(cosh(dbl(f)));}
proc tanh(flt f) : flt	{return flt(tanh(dbl(f)));}
proc sqrt(flt f) : flt	{return flt(sqrt(dbl(f)));}
proc exp(flt f) : flt	{return flt(exp(dbl(f)));}
proc log(flt f) : flt	{return flt(log(dbl(f)));}
proc log10(flt f) : flt {return flt(log10(dbl(f)));}

proc pi() : dbl 	{return M_PI; }

@{
@h
#ifndef __MMATH_H__
#define __MMATH_H__

#include <gdk.h>
#include "mmath.proto.h"

#endif /* __MMATH_H__ */
@}

@{
@* Implementation Code
@c

#include "mmath.h"
#include <math.h>

extern double sqrt(double x);
extern double cbrt(double x);
extern double sin(double x);
extern double cos(double x);
extern double fabs(double x);

#define acos_unary(x, z)      *z = acos(*x)
#define asin_unary(x, z)      *z = asin(*x)
#define atan_unary(x, z)      *z = atan(*x)
#define atan2_binary(x, y, z) *z = atan2(*x,*y)
#define cos_unary(x, z)	      *z = cos(*x)
#define sin_unary(x, z)	      *z = sin(*x)
#define tan_unary(x, z)	      *z = tan(*x)

#define cosh_unary(x, z)       *z = cosh(*x)
#define sinh_unary(x, z)       *z = sinh(*x)
#define tanh_unary(x, z)       *z = tanh(*x)

#define exp_unary(x, z)	      *z = exp(*x)
#define log_unary(x, z)	      *z = log(*x)
#define log10_unary(x, z)     *z = log10(*x)

#define pow_binary(x, y, z)   *z = pow(*x,*y)
#define sqrt_unary(x, z)      *z = sqrt(*x)

#define ceil_unary(x, z)      *z = ((-1.0<*x)&&(*x<0.0))?0.0:ceil(*x)
#define fabs_unary(x, z)      *z = fabs(*x)
#define floor_unary(x, z)     *z = floor(*x)
#define fmod_binary(x, y, z)  *z = fmod(*x,*y)

#ifdef _MSC_VER
#include <float.h>
/* Windows spells these differently */
#define isnan(x)	_isnan(x)
#define finite(x)	_finite(x)
/* NOTE: HAVE_FPCLASS assumed... */
#define fpclass(x)	_fpclass(x)
#define FP_NINF		_FPCLASS_NINF
#define FP_PINF		_FPCLASS_PINF
#else /* !_MSC_VER */
#ifdef HAVE_IEEEFP_H
#include <ieeefp.h>
#endif
#endif

#if defined(HAVE_FPCLASSIFY) || defined(fpclassify)

/* C99 interface: fpclassify */
#define MNisinf(x)	(fpclassify(x) == FP_INFINITE)
#define MNisnan(x)	(fpclassify(x) == FP_NAN)
#define MNfinite(x)	(!MNisinf(x) && !MNisnan(x))

#else

#define MNisnan(x)	isnan(x)
#define MNfinite(x)	finite(x)

#ifdef HAVE_ISINF

#define MNisinf(x)	isinf(x)

#else

static int
MNisinf(double x)
{
#ifdef HAVE_FPCLASS
	int cl = fpclass(x);

	return ((cl == FP_NINF) || (cl == FP_PINF));
#else
	return 0;		/* XXX not correct if infinite */
#endif /* HAVE_FPCLASS */
}

#endif /* HAVE_ISINF */
#endif /* HAVE_FPCLASSIFY */

@:unop(_ACOS,acos)@
@:unop(_ASIN,asin)@
@:unop(_ATAN,atan)@
@:binop(_ATAN2,atan2)@
@:unop(_COS,cos)@
@:unop(_SIN,sin)@
@:unop(_TAN,tan)@

@:unop(_COSH,cosh)@
@:unop(_SINH,sinh)@
@:unop(_TANH,tanh)@

@:unop(_EXP,exp)@
@:unop(_LOG,log)@
@:unop(_LOG10,log10)@

@:binop(_POW,pow)@
@:unop(_SQRT,sqrt)@

@:unop(_CEIL,ceil)@
@:unop(_FABS,fabs)@
@:unop(_FLOOR,floor)@
@:binop(_FMOD,fmod)@

@= unop
int
math_unary@1(dbl *res , dbl *a )
{
#ifdef DEBUG
	printf( "math_unary@1\n");
#endif
	if (*a == dbl_nil) {
		*res = dbl_nil;
	} else {
		errno = 0;
		@2_unary( a, res );
		if (errno == EDOM) {
			GDKerror("Negative argument is not allowed");
			return GDK_FAIL;
		}
		if (errno == ERANGE) {
			GDKerror("Range error");
			return GDK_FAIL;
		}
		if (MNisnan(*res)) {
			GDKerror("Negative argument is not allowed");
			return GDK_FAIL;
		}
		if (!MNfinite(*res)) {
			GDKerror("Range error");
			return GDK_FAIL;
		}
	}
	return(GDK_SUCCEED);
}
@

@= binop
int
math_binary@1(dbl *res, dbl *a, dbl *b )
{
#ifdef DEBUG
	printf( "math_binary@1\n");
#endif
	if (*a == dbl_nil || *b == dbl_nil) {
		*res = dbl_nil;
	} else {
		@2_binary( a, b, res);
	}
	return(GDK_SUCCEED);
}
@

@c
int
math_binary_ROUND(dbl *res, dbl *x, int *y)
{
	if (*x == dbl_nil || *y == int_nil) {
		*res = dbl_nil;
	} else {
		double factor = pow(10, *y), integral;
		double tmp = *y > 0 ? modf(*x, &integral) : *x;

		tmp *= factor;
		if (tmp >= 0)
			tmp = floor(tmp + 0.5);
		else
			tmp = ceil(tmp - 0.5);
		tmp /= factor;

		if (*y > 0)
			tmp += integral;

		*res = tmp;
	}

	return (GDK_SUCCEED);
}

int
math_unary_ISNAN(bit *res, dbl *a)
{
#ifdef DEBUG
	printf("math_unary_ISNAN\n");
#endif
	if (*a == dbl_nil) {
		*res = bit_nil;
	} else {
		*res = MNisnan(*a);
	}
	return (GDK_SUCCEED);
}

int
math_unary_ISINF(int *res, dbl *a)
{
#ifdef DEBUG
	printf("math_unary_ISINF\n");
#endif
	if (*a == dbl_nil) {
		*res = int_nil;
	} else {
		if (MNisinf(*a)) {
			*res = (*a < 0.0) ? -1 : 1;
		} else {
			*res = 0;
		}
	}
	return (GDK_SUCCEED);
}

int
math_unary_FINITE(bit *res, dbl *a)
{
#ifdef DEBUG
	printf("math_unary_FINITE\n");
#endif
	if (*a == dbl_nil) {
		*res = bit_nil;
	} else {
		*res = MNfinite(*a);
	}
	return (GDK_SUCCEED);
}

@}
