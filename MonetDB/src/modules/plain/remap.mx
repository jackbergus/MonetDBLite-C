@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2006 CWI.
@' All Rights Reserved.

@f lock
@t BAT Page-Wise Remapping 
@v 1.0
@a Peter Boncz
@* Introduction
This module provides bat remapping functionality that will be useful for pathfinder updates.

@* MEL Definitions
@m
.MODULE remap;

.COMMAND remap(BAT[void,any::1] b, BAT[void,oid]) : BAT[void,any::1] = remap_bat;
	"remap a bat page-wise (pages are sequences of 65536 tuples)"
.COMMAND [swizzle](BAT[void,oid] b, BAT[void,oid] map) : BAT[void,oid] = remap_swizzle;
	"swizzle oids using a map"
.COMMAND summary(BAT[void,oid] delta, BAT[void,oid] map, BAT[void,any::1] master) : BAT[oid,any::1] = remap_summary;
	"swizzle modified oids, reduce the set to one per page, and get the tail values from a master"

.END remap;
@mil
const REMAP_PAGE_BITS := 16
const REMAP_PAGE_SIZE := 1LL << REMAP_PAGE_BITS;
const REMAP_PAGE_MASK := REMAP_PAGE_SIZE - 1LL;

proc swizzle(oid o, BAT[void,oid] map) : oid {
	return oid(<<(lng(map.find(oid(lng(o) >> REMAP_PAGE_BITS))),REMAP_PAGE_BITS) + and(lng(o),REMAP_PAGE_MASK));
}

@* Implementation
@h
@c
#include <gdk.h>
#include "lock.h"

#include "remap.proto.h"

#define REMAP_PAGE_BITS 16
#define REMAP_PAGE_SIZE (1<<REMAP_PAGE_BITS)
#define REMAP_PAGE_MASK (REMAP_PAGE_MASK-1)

int remap_bat(BAT **res, BAT *b, BAT *map) {
	size_t pgsz = REMAP_PAGE_SIZE*BUNsize(b), zz = 0, yy = 0, xx, cnt = BATcount(map);
	char *src = BUNfirst(b);
	oid prev = OID_MAX;
	BUN p, q;
	BAT *bn;

	if (BUNsize(b) != ATOMsize(b->ttype)) {
		GDKerror("BATremap: %s must have a real void head column.\n", BBP_logical(b->batCacheid));
		return GDK_FAIL;
	}
	if (BATcount(b) & REMAP_PAGE_MASK)) {
		GDKerror("BATremap: BATcount(%s) = %lld (not a multiple of %d).\n",
				BBP_logical(b->batCacheid, (lng) BATcount(b), REMAP_PAGE_SIZE);
		return GDK_FAIL;
	}
	*res = bn = BATcreatedesc(b->htype, b->ttype, TRUE); 
	if (!bn) return GDK_FAIL;
	bn->dims = b->dims;
	/*
	if (b->batBuns->mode & STORE_MMAP) {
	} else 
	*/
	{
		if (HEAPalloc(bn->batBuns, (cnt+2)*pgsz, 1) < 0) {
			BBPclear(bn->batCacheid);
			return GDK_FAIL;
		}
		if (ATOMvarsize(bn->ttype)) {
			bn->theap = GDKmalloc(sizeof(Heap)) 
			if (bn->theap == NULL || HEAPalloc(bn->theap, bn->theap.free*BATMARGIN, 1) < 0) {
				if (bn->theap) HEAPfree(bn->theap);
				else GDKfree(bn->theap);
				HEAPfree(bn->batBuns);
				BBPclear(bn->batCacheid);
				return GDK_FAIL;
			}
			memcpy(bn->theap->base, b->theap->base, bn->theap->free = b->theap->free);
		}
		BATloopFast(map, p, q, xx) {
			oid j = *(oid*) BUNtail(map,p);
			if (j != prev) {
				memcpy(bn->batBuns->base + pgsz*yy, b->batBuns->base + pgsz*j, zz*pgsz);
				yy += zz; zz = 0;
			}
			zz += (j != oid_nil);
		}
		bn->batBuns->free += yy*pgsz;
	}
	bn->tsorted = 0;
	bn->batDirty = FALSE;
	bn->batInserted = bn->batBuns->base + bn->batBuns->free;
	BBPcacheit(bn);
	BATsetcount(bn, yy*REMAP_PAGE_SIZE);
	BATseqbase(bn, 0);
	return GDK_SUCCEED;
}

@= swizzle
	for(i=0; i<n; i+=@1) {
		size_t idx = src[i] >> @2;
		if (idx >= m) return 0;
		dst[i] = (map[idx] << REMAP_PAGE_BITS) | (idx & REMAP_PAGE_MASK);
	}
@c
static int swizzle(oid*__r dst, oid*__r src, oid*__r map, size_t lo, size_t n, size_t m, size_t delta, size_t shift) {
	ssize_t p, i, j, k;
	if (delta == 0 && n) {
		if ((p = (n-1) >> REMAP_PAGE_BITS) >= m) return 0;
		if ((shift = REMAP_PAGE_BITS-shift) == 0) {
			for(i=0; i<n; i++)
				for(k=i<<REMAP_PAGE_BITS, j=0; j<REMAP_PAGE_SIZE; j++) 
					dst[k+j] = (map[i] << REMAP_PAGE_BITS) + j;
		} else {
			for(i=0; i<n; i++)
				for(k=i<<REMAP_PAGE_BITS, j=0; j<REMAP_PAGE_SIZE; j++) 
					dst[k+j] = (map[i<<shift] << REMAP_PAGE_BITS) + j;
		}
		for(k=p<<REMAP_PAGE_BITS, j=0; j<n-k; j++) 
			dst[k+j] = (map[i<<shift] << REMAP_PAGE_BITS) + j;
	} else if (delta == 1 && shift == REMAP_PAGE_BITS) {
		@:swizzle(1,REMAP_PAGE_BITS)@ /* help register poor ISAs */
	} else if (delta == 2 && shift == REMAP_PAGE_BITS) {
		@:swizzle(2,REMAP_PAGE_BITS)@ /* help register poor ISAs */
	} else if (delta == 1 && shift == REMAP_PAGE_BITS-1) {
		@:swizzle(1,REMAP_PAGE_BITS-1)@ /* help register poor ISAs */
	} else if (delta == 2 && shift == REMAP_PAGE_BITS-1) {
		@:swizzle(2,REMAP_PAGE_BITS-1)@ /* help register poor ISAs */
	} else {
		@:swizzle(delta,shift)@
	}
	return 1;
}

int swizzle_bat(BAT **res, BAT *b, BAT *map) {
	BAT *bn = b;
	if (map->hseqbase)) {
		GDKerror("swizzle_bat: map %s should be a void column starting at 0@0.\n", 
			BBP_logical(map->batCacheid)); 
		return GDK_FAIL;
	}
	if (BATtdense(map)) {
		if (map->tseqbase) {
			GDKerror("swizzle_bat: map %s is a void view.\n", BBP_logical(map->batCacheid)); 
			return GDK_FAIL;
		}
		/* HACK does not check for out-of-range oids */
		BBPfix(b->batCacheid);
		return GDK_SUCCEED;
	} 
	*res = bn = BATnew(TYPE_void,TYPE_oid,BATcount(b));
	if (bn) {
	    	if (swizzle(
			(oid*) BUNfirst(bn), 
			(oid*) BUNtloc(b,BUNfirst(b)), 
			(oid*) BUNtloc(map,BUNfirst(map)), 
			b->hseqbase,
			BATcount(b),
			BATcount(map),
			BATdense(b)?0:BUNsize(b)/sizeof(oid),
			17 - BUNsize(map)/sizeof(oid)))
		{
			bn->batBuns->free = sizeof(oid) * BATcount(b);
			bn->tsorted = 0;
			BATsetcount(bn, BATcount(b));
			BATseqbase(bn, b->hseqbase);
			return GDK_SUCCEED;
		} else {
			GDKerror("swizzle_bat: %s contains illegal offsets.\n", BBP_logical(b->batCacheid)); 
			BBPreclaim(bn);
		}
	}
	return GDK_FAIL;
}

int remap_summary(BAT **res, BAT *delta, BAT *map, BAT *master) {
	oid *oidmap, i, xx, n = BATcount(master), m = (n+REMAP_PAGE_MASK) >> REMAP_PAGE_BITS;
	BUN p, q, r;
	BAT *bn = NULL;

	if (master->hseqbase || map->hseqbase) {
		GDKerror("remap_summary: %s and map %s should be void columns starting at 0@0.\n", 
			BBP_logical(master->batCacheid), BBP_logical(map->batCacheid)); 
		return GDK_FAIL;
	}
	/* create temporary map */
	oidmap = (oid*) GDKmalloc(m);
	if (oidmap == NULL) return GDK_FAIL;
	for(i=0; i<m; i++) oidmap[i] = oid_nil; 

	/* fill map */
	n = 0;
	BATloopFast(delta,p,q,xx) {
		oid o = *(oid*) BUNtail(delta,p);
		oid p = o >> REMAP_PAGE_SHIFT];
		if (oidmap[p] != oid_nil) {  
			oidmap[p] = o;
			n++;
		}
	}

	/* create result bat */
	*res = bn = BATnew(TYPE_oid, ATOMtype(master->ttype), n);
	if (bn == NULL) {
		GDKfree(oidmap);
		return GDK_FAIL;
	}

	/* fetch values from master*/
	for(i=0; n && i<m; i++) {
		if (oidmap[i] != oid_nil) {
			/* get page id */
			oid p = oidmap[i] >> REMAP_PAGE_MASK; 
			BUNfndVOID(r,map,&p); 
			if (r == NULL) {
				GDKerror("remap_summary: %s contains illegal offset %lld.\n", 
					BBP_logical(delta->batCacheid), (lng) p); 
				goto bunins_failed;
			}
			/* translate oid back to that in master */
			xx = *(oid*) BUNtail(map,r);
			xx = (xx << REMAP_PAGE_BITS) & (o * REMAP_PAGE_MASK);

			/* look up the BUN in the master */
			BUNfndVOID(r,master,&xx);
			if (r == NULL) {
				GDKerror("remap_summary: map %s contains illegal offsets.\n", 
					BBP_logical(map->batCacheid)); 
				goto bunins_failed;
			}

			/* put [xx,t] BUN that is already in master in result bat */
			BUNfastins(bn, &xx, BUNtail(master,r)); 
			n--;
		}
	}
	bn->hsorted = GDK_SORTED;
	bn->tsorted = 0;
	GDKfree(oidmap);
	return GDK_SUCCEED;
bunins_failed:
	BBPreclaim(bn);
	GDKfree(oidmap);
	return GDK_FAIL;
}
@}
