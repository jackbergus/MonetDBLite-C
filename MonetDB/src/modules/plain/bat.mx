@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2006 CWI.
@' All Rights Reserved.

@f bat
@v 1.0
@a Peter Boncz, M.L. Kersten
@* Binary Association Tables
@T
This module contains all commands that are of use when managing Binary
Association Tables (BATs). The relational operations you can execute
on BATs have the form of a @[<a href="../algebra/index.html">neat algebra</a>@.

But a database system needs more that just this algebra, since often it
is crucial to do table-updates (this would not be permitted in a strict
algebra).

All commands needed for BAT updates, property management, I/O, persistency, and storage options
can be found in this module.

@* Module Definition
@m
.MODULE bat;

@- BAT basics
@m
.COMMAND bat(int ht, int tt) : BAT[any,any] = CMDnew_default;
"Creates a new empty transient BAT, with head- and tail-types as indicated."

.COMMAND new(int ht, int tt) : BAT[any,any] = CMDnew_default;
"Creates a new empty transient BAT, with head- and tail-types as indicated."

.COMMAND bat(int ht, int tt, int size) : BAT[any,any] = CMDnew;
"Creates a new empty BAT, directly allocating for 'size' elements."

.COMMAND new(int ht, int tt, int size) : BAT[any,any] = CMDnew;
"Creates a new empty BAT, directly allocating for 'size' elements."

.COMMAND bat(int ht, int tt, lng size) : BAT[any,any] = CMDnew_lng;
"Creates a new empty BAT, directly allocating for 'size' elements."

.COMMAND new(int ht, int tt, lng size) : BAT[any,any] = CMDnew_lng;
"Creates a new empty BAT, directly allocating for 'size' elements."

.COMMAND reverse(BAT[any::1,any::2]) : BAT[any::2,any::1] = CMDreverse;
"Returns the reverse view of a BAT (head is tail and tail is head).
 BEWARE:  no copying is involved; input and output refer to the same object!"

.COMMAND mirror(BAT[any::1,any]) : BAT[any::1,any::1] = CMDmirror;
"Returns the head-mirror image of a BAT (two head columns)."

.COMMAND convert(BAT[any::1,any::2] ) : BAT[any::1,any::2] = CMDconvert;
"Convert the contents of a BAT from little-endian to big-endian and vice versa.
 THIS COMMAND SHOULD NOT BE USED FROM MIL! DANGEROUS! DEBUGGING PURPOSES ONLY!"

.COMMAND order(BAT[any::1,any::2] b) : BAT[any::1,any::2] = CMDorder;
"Sorts the BAT itself, in place, on ascending head values. Returns b."

.COMMAND order_rev(BAT[any::1,any::2] b) : BAT[any::1,any::2] = CMDorder_rev;
"Sorts the BAT itself, in place, on descending head values. Returns b."

.COMMAND revert(BAT[any::1,any::2] b) : BAT[any::1,any::2] = CMDrevert;
"Puts all BUNs in a BAT in reverse order. Returns b."

@- BAT updates
@m
.COMMAND insert(BAT[any::1, any::2], any::1 h, any::2 t)
				: BAT[any::1,any::2] = CMDinsert_bun;
"Insert one BUN[h,t] in a BAT.
 Returns the modified BAT."

.COMMAND insert(BAT[any::1, any::2], BAT[any::1,any::2])
				: BAT[any::1,any::2] = CMDinsert_bat;
"Insert all BUNs of the second BAT into the first.
 Returns the modified BAT."

.COMMAND replace(BAT[any::1, any::2], any::1 h, any::2 t)
				: BAT[any::1,any::2] = CMDreplace_bun;
"Replace the tail value of one BUN that has some head value.
 Returns the modified BAT."

.COMMAND replace(BAT[any::1, any::2], BAT[any::1,any::2])
				: BAT[any::1,any::2] = CMDreplace_bat;
"Perform replace for all BUNs of the second BAT into the first.
 Returns the modified BAT."

.COMMAND replace(BAT[any::1, any::2], any::1 h, any::2 t, bit force)
				: BAT[any::1,any::2] = CMDreplace_bun_force;
"Replace the tail value of one BUN that has some head value.
 Returns the modified BAT."

.COMMAND replace(BAT[any::1, any::2], BAT[any::1,any::2], bit force)
				: BAT[any::1,any::2] = CMDreplace_bat_force;
"Perform replace for all BUNs of the second BAT into the first.
 Returns the modified BAT."

.COMMAND delete(BAT[any::1, any::2], any::1 h, any::2 t)
				: BAT[any::1,any::2] = CMDdelete_bun;
"Delete one specific BUN.
 Returns the modified BAT."

.COMMAND delete(BAT[any::1, any::2], any::1 h)
				: BAT[any::1,any::2] = CMDdelete_head;
"Delete all BUNs with a certain head value.
 Returns the modified BAT."

.COMMAND delete(BAT[any::1, any::2])
				: BAT[any::1,any::2] = CMDdelete_all;
"Delete all BUNs in a BAT.
 Returns the modified BAT."

.COMMAND delete(BAT[any::1, any::2] b, BAT[any::1,any] bn)
				: BAT[any::1,any::2] = CMDdelete_bat_head;
"Delete from the first BAT all BUNs with a head value that is in the second.
 Returns the modified BAT."

.COMMAND deleteBuns(BAT[any::1, any::2], BAT[any::1,any::2])
				: BAT[any::1,any::2] = CMDdelete_bat_bun;
"Delete from the first BAT all BUNs with a corresponding BUN in the second.
 Returns the modified BAT."

@+ void bats
The append set of commands lets you append values (or bats) with unique 
head values which start at the maximum head value before inserting plus one.
The appended bats tail can not be set key-ed. 
@m
	.COMMAND append( BAT[oid,any::1] i, BAT[oid,any::1] u ) : BAT[oid,any::1] = BATappend_wrap; "append the content of u to i (renumbers u-oids' to unique numbers, starting at i.max()+1)"

	.COMMAND append( BAT[void,any::1] i, BAT[void,any::1] u ) : BAT[void,any::1] = BATappend_wrap; "append the content of u to i"

	.COMMAND append( BAT[void,any::1] i, BAT[oid,any::1] u ) : BAT[void,any::1] = BATappend_wrap; "append the content of u to i"

	.COMMAND append( BAT[oid,any::1] i, any::1 u ) : BAT[oid,any::1] = BUNappend_wrap; "append the value u to i"

	.COMMAND append( BAT[void,any::1] i, any::1 u ) : BAT[void,any::1] = BUNappend_wrap; "append the value u to i"

	.COMMAND inplace( BAT[void,any::1] o, oid id, any::1 val ) : BAT[void,any::1] = bat_inplace; "inplace replace values on the given locations"

	.COMMAND inplace( BAT[void,any::1] o, BAT[oid,any::1] d ) : BAT[void,any::1] = bat_replace_oid_bat_wrap; "inplace replace values on the given locations"

@- BAT properties
@T
Monet maintains a number of {\em properties} on each BAT that is used to steer tactical
query optimization (i.e. choosing a good algorithms for a particular algebra command).

These properties can be inspected with the {\tt info(BAT[any,any]) : BAT[str,str] } command:
\begin{verbatim}
> var car_age := bat(void,int);
> car_age.info().print();
#---------------------------------#
# BAT:		     tmp_31	  #
# (str)		     (str)	  #
#---------------------------------#
[ "batId",	     "car_age"	  ] # logical bat name
[ "batCacheid",	     "26"	  ] # BBP index
[ "batParentid",     "0"	  ] # set if a BAT is a view
[ "head",	     "void"	  ] # physical head-type
[ "tail",	     "int"	  ] # physical tail-type
[ "batPersistence",  "persistent" ] # transient/session/persistent
[ "batRestricted",   "updatable"  ] # read-only/append-only/updatable
[ "batDirty",	     "clean"	  ] # clean/dirty
[ "batRefcnt",	     "1"	  ] # physical refcount
[ "batLRefcnt",	     "1"	  ] # logical refcount (total)
[ "batPlevel",	     "1"	  ] # logical refcount (persistent part)
[ "batSet",	     "0"	  ] # [head,tail] combinations are unique
[ "batCopiedtodisk", "1"	  ] # has been saved or not
\end{verbatim}

The above are global BAT properties. The properties {\tt batPersistence},
{\tt batRestricted} and {\tt batDirty} will be explained in the next section,
and the various reference counts in the section that follows it.

Per column, a number of properties are kept. We only show the head-properties; the tail properties
have the first character of their named replaced by 't' ({\tt sorted}, {\tt tdense}, etc.):

\begin{verbatim}
[ "hsorted",	     "1"	  ] # column is known to be sorted
[ "hdense",	     "1"	  ] # column is known to be densely ascended
[ "hseqbase",	     "0@0"	  ] # if densely ascending (i.e. 0@0, 1@0, @,0, ...): first value
\end{verbatim}

As described in the @[<a href="../../gdk/index.html#mod_1_3_0">GDK Technical Reference</a>@,
BATs store their data in one to five heaps, of which at least one called {\tt batBuns}
is present always. For each column type that is {\em variable-sized} - like {\tt str} - another
heap might be present ({\tt hheap} and {\tt theap}). 

\begin{verbatim}
[ "batBuns.free",    "400004"	  ] # occupied size in bytes
[ "batBuns.size",    "400012"	  ] # allocated size in bytes
[ "batBuns.maxsize", "400012"	  ] # reserver virtual memory in bytes
[ "batBuns.storage", "malloced"	  ] # malloced/mmap/priv
\end{verbatim}

Properties steer the algorithms that Monet uses to execute algebra command. For instance,
the {\tt find(BAT[any::1,any::2] b, any:;1) : any::2) that looks up a tail value by head,
uses binary search if and only if the head column is sorted (in other cases, hash-lookup
and scan are execution options).

Sometimes new (extension) code contains bugs in the property management, leaving false
properties on produced BATs. You can imagine that later on, this leads to additional
bugs, as e,g, the binary search algorithms will yield erroneous results on a non-sorted
sequence.

To make problem detection easier, the MIL interpreter contains property checking code,
that is set with via the  {\tt debugmask(int)} command:
\begin{description}
\item[2] {\tt debugmask(debugmask() or 2)} makes that all properties on
newly created BATs are checked. You must realize that finding out that a column is sorted
({\tt hsorted/tsorted}) costs a full scan, and finding out that it contains unique values
({\tt hkeyed/tkeyed}) costs a full scan plus the creation of a full hash index.
\item[8] {\tt debugmask(debugmask() or 8)} makes that all properties on
{\bf all} BATs handled by the MIL interpreter are checked. This will catch all property errors.
\end{description}

By default, both bits in the {\tt debugmask} are off, which gives fastest performance.
@m
.COMMAND count ( int bid ) : lng = CMDcount_bat;
"Returns the current size (in number of elements) of a BAT."

.COMMAND count ( BAT[void,void] b, lng cnt ) : lng = CMDsetcount_bat;
"Sets the size (in number of elements) of a BAT."

.COMMAND capacity ( int bid ) : lng = CMDcapacity;
"Returns the current allocation size (in max number of elements) of a BAT."

.COMMAND info ( BAT[any,any] ) : BAT[str,str] = CMDinfo;
"Produce a BAT containing info about a BAT in \"attribute\",\"value\" format.
 It contains all properties of the BAT record. See the BAT documentation in
 GDK for more information."

.COMMAND head ( int bid ) : str = CMDhead;
"Returns the type of the head column of a BAT, as a string."

.COMMAND head ( BAT[any,any] b ) : str = CMDhead_bat;
"Returns the type of the head column of a BAT, as a string."

.COMMAND htype ( int bid ) : int = CMDhtype;
"Returns the type of the head column of a BAT."

.COMMAND htype ( BAT[any,any] b ) : int = CMDhtype_bat;
"Returns the type of the head column of a BAT."

.COMMAND tail ( int bid ) : str = CMDtail;
"Returns the type of the tail column of a BAT, as a string."

.COMMAND tail ( BAT[any,any] b ) : str = CMDtail_bat;
"Returns the type of the tail column of a BAT, as a string."

.COMMAND ttype ( int bid ) : int = CMDttype;
"Returns the type of the tail column of a BAT."

.COMMAND ttype ( BAT[any,any] b ) : int = CMDttype_bat;
"Returns the type of the tail column of a BAT."

.COMMAND key( BAT[any::1,any::2] b, bit mode)
				: BAT[any::1,any::2] = CMDsetkey;
"Sets the 'key' property of the head column to 'mode'. In 'key' mode,
 the kernel will silently block insertions that cause a duplicate entries
 in the head column.
 KNOWN BUG: when 'key' is set to TRUE, this function does not automatically
 eliminate duplicates. Use b := b.kunique;"

.COMMAND key( BAT[any::1,any::2] b) : bit = CMDgetkey;
"return whether the head column of a BAT is unique (key)."

.COMMAND set( BAT[any::1,any::2] b, bit mode)
				: BAT[any::1,any::2] = CMDsetset;
"Sets the 'set' property on this BAT to 'mode'. In 'set' mode, the kernel
 will silently block insertions that cause a duplicate BUN [head,tail] entries
 in the BAT.
 KNOWN BUG: when 'set' is set to TRUE, this function does not automatically
 eliminate duplicates. Use b := b.sunique;
 Returns the BAT itself."

.COMMAND access( BAT[any::1,any::2] b, int mode)
				: BAT[any::1,any::2] = CMDsetaccess;
"Try to change the update access priviliges to this BAT. Mode:
 BAT_READ   - allow only read access.
 BAT_APPEND - allow reads and insertions of new elements.
 BAT_WRITE  - allow reads, insertions, and updates.
 BATs are updateable by default. On making a BAT readonly, all
 subsequent updates fail with an error message.
 Returns the BAT itself."

.COMMAND access( BAT[any::1,any::2] b) : int = CMDgetaccess;
"Return the update access privilige of a BAT."

.COMMAND seqbase( BAT[oid,any::1] b ) : oid = CMDget_seqbase;
"Get the sequence base for the void vcolumn of a BAT."

.COMMAND seqbase( BAT[void,any::1] b ) : oid = CMDget_seqbase;
"Get the sequence base for the void vcolumn of a BAT."

.COMMAND seqbase( BAT[void,any::1] b, oid seqbase)
				: BAT[void,any::1] = CMDset_seqbase;
"Set the sequence base for the void vcolumn of a BAT.
 Returns the BAT itself."

.COMMAND ordered(BAT[any,any]) : bit = CMDordered;
"Returns whether a BAT is ordered on head or not."

.COMMAND ordered_rev(BAT[any,any]) : bit = CMDordered_rev;
"Returns whether a BAT is ordered on head or not."

.COMMAND chk_order(BAT[any::1,any::2]) : BAT[any::1,any::2] = CMDchk_order;
"Infer the sortedness property (or not) of both head and tail."

.COMMAND batsize(str batname) : lng = CMDbatsize_str;
"A version of BATsize that does not require loading the BAT."

.COMMAND batsize(BAT[any,any] b) : lng = CMDbatsize;
"A version of BATsize that does not require loading the BAT."

@- BUN Access
@m
.ITERATOR  batloop(BAT[any,any], ptr handle) = CMDbatloop_std;
"Iterators are special MIL constructs:
  <bat-expression> @ <iterator>(<parameters>) <MIL-statement>
 'b@batloop()..' iterates over all BUNs [$h,$t] of BAT b."

.ITERATOR  batloop(BAT[any,any], ptr handle, int low, int high) = CMDbatloop;
"Iterators are special MIL constructs:
  <bat-expression> @ <iterator>(<parameters>) <MIL-statement>
 'b@batloop(low,high)..' iterates over all BUNs of b.slice(low,high)"

.ITERATOR  hashloop(BAT[any::1,any] b, ptr handle, any::1 val) = CMDhashloop;
"Iterators are special MIL constructs:
  <bat-expression> @ <iterator>(<parameters>) <MIL-statement>
 'b@hashloop(v)..' iterates over all BUNs [$h,$t] of BAT b where ($h = val)."

@- BAT I/O, Persistency
@T
The BAT Buffer Pool (BBP) manages all known BATs. It administers
their logical and physical names and a reference count. BATs can
be {\em persistent}, {\em transient} or {\em session}. The BBP also manages
swapping on a BAT level: a BAT is either loaded entirely or not.
MIL variables of type {\tt bat} can either be loaded or not. When
the Monet server is started, all BATs are swapped out. If an unloaded
bat-variable is used as an operand in a command, it is automatically
loaded.	 The BBP applies a simple but effective LRU based swapping
algorithm. BATs have a {\em heat}, which drops over time, and is
increased when a BAT is used by some command.  If the size of the
allocated arena gets to be large, BATs may be swapped out.
@m
.COMMAND bbpname ( BAT[any,any] , str s) : BIT = CMDrename;
"Give a logical name to a BAT. This can fail if a BAT with name 's' already
 exists. The command then returns FALSE, else TRUE."

.COMMAND bbpname ( BAT[any,any]) : STR = CMDname;
"Gives back the logical name of a BAT."

.COMMAND roles ( BAT[any::1,any::2] , str h, str t)
				: BAT[any::1,any::2] = CMDroles;
"Give a logical name to the columns of a BAT.
 Returns the BAT itself."

.COMMAND col_name ( BAT[any,any] , str s) : BAT[any,any] = CMDcol_name;
"Give a logical name to tail column of a BAT.
 Returns the BAT itself."

.COMMAND persists( BAT[any::1,any::2], bit mode) : BAT[any::1,any::2] = CMDpersists;
"Make the BAT persistent (mode = TRUE), transient (mode = FALSE).
 or session (mode = bit(nil)). Returns the BAT itself."

.COMMAND destroy(str nme ) : bit = CMDdestroy;
"Destroys the BAT."

.COMMAND save(str nme) : bit = CMDsave;
"Save a BAT to storage, if it was loaded and dirty. Returns whether IO was necessary.
 Please realize that calling this function violates the atomic repository commit protocol!!"

.COMMAND unload(str name) : bit = CMDunload;
"Swapout a BAT to disk. Transient BATs can also be swapped out.
 Returns whether the unload indeed happened. "

.COMMAND hot(str name) : void = CMDhot;
"Makes a BAT very hot for the BBP. The chance of being chosen for swapout is
 small, afterwards."

.COMMAND cold(str nme) : void = CMDcold;
"Makes a BAT very cold for the BBP. The chance of being choses for swapout is
 big, afterwards."

.COMMAND heat(str nme) : int = CMDheat;
"returns the current BBP heat (LRU stamp)"


@- Heap Specific Commands
@T
BATs are stored in memory in a number of Heap objects. A heap is nothing
more than a contiguous range of memory. Bats are saved to disk by just writing
away their image. This approach without pointer swizzling makes it possible
to either load an image into an alloced range of memory (STORE\_MEM), or
memory-map (STORE\_MMAP) an image into virtual memory.

The heap images of a BAT are stored in the {\tt $MONETHOME/dbfarm/$DB/bat/}
directory.  For each bat X, the following heaps are stored:
\begin{description}
\item[X.buns] an array with all the fixed-size parts of all BUNs.
\item[X.hheap] if the head column contains a variable sized atoms (e.g. str),
then the fixed-size part of a BUN contains an integer byte-offset into
the heap. String values themselves are stored in this the X.hheap.
\item[X.theap] similar to X.hheap, but for the tail column.
\item[X.hacc]. On each column, you might create {\em persistent hash accelerator
structure}. 
\end{description}

Each of these heaps can be {\bf compressed} using the Unix {\tt compress}
utility forming a X.ext.Z file. Monet will automatically decompress it
upon load. Compressed heaps cannot be memory mapped.

A final file present for each t in the BAT directory is:
\begin{description}
\item[X.desc] the BAT descriptor. Stores most of the properties of a BAT.
\end{description}
@
For more technical information on BATs, we refer to the
@[<a href="../../gdk/index.html">GDK</a>@
documentation.
@m
.COMMAND mmap(BAT[any::1,any::2], int buns_mode, int hheap_mode, int theap_mode) : BAT[any::1,any::2] = CMDmmap;
"For each individual heap, you can change the allocation mode to
 either STORE_MEM or STORE_MMAP. Passing an int(nil) means: no change.
 Changing a dirty STORE_MEM heap into STORE_MMAP, will cause a BAT save
 (this has to happen before the heap can be mapped into virtual memory).
 These modes are persistent. "

.COMMAND madvise(BAT[any::1,any::2], int buns_mode, int hheap_mode, int theap_mode) : BAT[any::1,any::2] = CMDmadvise;
"Modern Operating Systems allow users to influence the buffer management
 policy of virtual memory. This is a crucial feature for database systems,
 and eliminates the need to reimplement the OS in a database buffer manager.
 The supported flags are BUF_NORMAL (the normal adaptive kernel algorithm),
 BUF_RANDOM (no page prefetching), BUF_SEQUENTIAL (prefetch and swapout),
 BUF_WILLNEED (load everything with prefetch), BUF_DONTNEED (swapout).
 These buffer management modes are not persistent.
 Returns the BAT operated upon."

.COMMAND remap(BAT[void,any::1] b, BAT[void,oid] map) : BAT[void,any::1] = CMDremap;
"create a page-wise access(BAT_WRITE) copy of the first parameter input BAT[void,X]. 

 The second parameter map BAT[void,oid] (seqbase 0@00) indicates the order
 in which the 65536-tuple logical pages must appear in the result. It may not 
 contain illegal nor duplicate page-ids in the tail (page-ids start at 0).

 If the last page of the input BAT is requested in the map, and the input bat is 
 not an exact multiple of 65536 (hence the last page is incomplete), the missing 
 tuples appear as NILs in the result. 

 Finally, note that this operation is optimized for the case where the input
 BAT is memory-mapped directly (not: privately mapped). In that case, you get
 a fast copy-on-write copy of the BUN heap. Otherwise, an im-memory copy is made."

.COMMAND [swizzle](BAT[void,oid] b, BAT[void,oid] map) : BAT[void,oid] = CMDswizzle;
"swizzle re-mapped oids (translate from logical to physical using a page-id map)"

@- BAT Accelerators
@m
.COMMAND accbuild(BAT[any,any] b, str acctype) = CMDaccbuild;
"Build an accelerator on the head column of b. The builtin accelerator
 types index and hash will be created as transient accelerators. They
 will not be saved on disk. User-defined accelerators must always be
 persistent."

@- Synced BATs
The binary model of Monet has important advantages when working in
main-memory. Tables are thin and very efficiently processed. The binary
model gives rise, however, to a larger-than-normal number of join
and semijoin operations. Relations are split up in vertical parts that
are very much related to each other. Then, for instance, multiple
similar semijoins occur on different vertical parts. By equipping the
kernel with knowledge about the correspondence of these parts, we
can greatly limit the amount of work to be done.

When two BATs effectively contain the same sequence of head elements,
we call them 'synced'. This is implemented by storing a very large
OID for each column. An update to the column destroys this OID.
By comparing two OIDs the Monet kernel can very quickly decide that
two columns are exactly equal. All BAT algebra operations propagate
these 'sync' OIDs with their own propagation rules.
@m
.COMMAND synced (BAT[any,any] b1, BAT[any,any] b2) : bit = CMDsynced;
"Tests whether two BATs are synced or not. "

.END bat;

@- system bats
@mil
    CONST monet_fcn_aut := bat("monet_fcn_aut");
    CONST monet_fcn_cnt := bat("monet_fcn_cnt");
    CONST monet_fcn_dat := bat("monet_fcn_dat");
    CONST monet_fcn_dsc := bat("monet_fcn_dsc");
    CONST monet_fcn_fcn := bat("monet_fcn_fcn");
    CONST monet_fcn_imp := bat("monet_fcn_imp");
    CONST monet_fcn_mid := bat("monet_fcn_mid");
    CONST monet_fcn_nme := bat("monet_fcn_nme");
    CONST monet_fcn_pro := bat("monet_fcn_pro");
    CONST monet_fcn_sig := bat("monet_fcn_sig");
    CONST monet_fcn_tpe := bat("monet_fcn_tpe");
    CONST monet_mod_acc := bat("monet_mod_acc");
    CONST monet_mod_atm := bat("monet_mod_atm");
    CONST monet_mod_cnt := bat("monet_mod_cnt");
    CONST monet_mod_dep := bat("monet_mod_dep");
    CONST monet_mod_drop := bat("monet_mod_drop");
    CONST monet_mod_hdl := bat("monet_mod_hdl");
    CONST monet_mod_load := bat("monet_mod_load");
    CONST monet_mod_nme := bat("monet_mod_nme");
    CONST monet_mod_proc := bat("monet_mod_proc");
    CONST monet_mod_use := bat("monet_mod_use");
    CONST monet_mod_var := bat("monet_mod_var");

@- constants for mmap()
@mil
    CONST STORE_MEM   := 0;	# load into GDKmalloced memory
    CONST STORE_MMAP  := 1;	# mmap() into virtual memory

    PROC mmap(bat[any::1,any::2] b, int memmode) : bat[any::1,any::2] {
	return mmap(b, memmode, memmode, memmode );
    }

    # overload madvise to pass the same memory mode for all heaps
    PROC madvise(bat[any::1,any::2] b, int memmode) : bat[any::1,any::2] {
	return madvise(b, memmode, memmode, memmode );
    }

@- constants for madvise()
@mil
    CONST BUF_NORMAL	:= 0;	# No further special treatment
    CONST BUF_RANDOM	:= 1;	# Expect random page references
    CONST BUF_SEQUENTIAL:= 2;	# Expect sequential page references
    CONST BUF_WILLNEED	:= 3;	# Will need these pages
    CONST BUF_DONTNEED	:= 4;	# Don't need these pages

@- constants for remap()
@mil
    CONST REMAP_PAGE_BITS := 16;
    CONST REMAP_PAGE_SIZE := 1LL << REMAP_PAGE_BITS;
    CONST REMAP_PAGE_MASK := REMAP_PAGE_SIZE - 1LL;

    PROC swizzle(oid o, BAT[void,oid] map) : oid {
        var pid := oid(lng(o) >> REMAP_PAGE_BITS);
        if (map.exist(pid))
	    return oid(<<(lng(map.find(pid)),REMAP_PAGE_BITS) + and(lng(o),REMAP_PAGE_MASK));
        return o;
    }

    PROC pagesample(BAT[oid,any] b) : BAT[oid,void] {
        var lb := [lng](b.project(nil)).access(BAT_WRITE);
	lb := reverse(kunique(reverse([:>>=](lb,REMAP_PAGE_BITS)))).access(BAT_WRITE);
        return reverse([oid]([:<<=](lb,REMAP_PAGE_BITS)));
    }

@- constants for readonly()
@mil
    CONST BAT_READ   := 1;	# allow only read access.
    CONST BAT_APPEND := 2;	# allow reads and insertions of new elements.
    CONST BAT_WRITE  := 0;	# allow reads, insertions, and updates.

    PROC destroy(bat[any,any] b) : bit{
	return destroy(str(b));
	}

    PROC capacity(bat[any,any] b) : lng {
	return capacity(int(b));
	}

    PROC save(bat[any::1,any::2] b) : bat[any::1,any::2] {
	save(bbpname(b));
	return b;
    }

    PROC load(str batname) : bat[any,any] {
	return bat(batname);
    }

    PROC cold(bat[any::1,any::2] b) : void {
	cold(b.bbpname());
    }

    PROC hot(bat[any::1,any::2] b) : void {
	hot(b.bbpname());
    }
@
@{
@{
@* Implementation Code

@= batconvert
	(BAT@2type(@1) == TYPE_bat)?(BUN)&((BAT*)@2)->batCacheid:(BUN)@2

@+ Information Functions

@h
#ifndef BAT_H
#define BAT_H

#include "gdk.h"
#include "monet.h"
#include "bat.proto.h"

bat_export ssize_t void_replace_bat(BAT *b, BAT *u);
bat_export int void_inplace(BAT *b, oid id, ptr val);

#endif /*BAT_H */
@c
#include "bat.h"

int
CMDnew_lng(BAT **ret, int *ht, int *tt, lng *cap)
{
	if (*cap < 0)
		*cap = 0;
	*ret = BATnew(*ht, *tt, (size_t) * cap);
	if (*ret)
		(*ret)->batDirty |= 2;
	return (*ret) ? GDK_SUCCEED : GDK_FAIL;
}

int
CMDnew(BAT **ret, int *ht, int *tt, int *cap)
{
	if (*cap < 0)
		*cap = 0;
	*ret = BATnew(*ht, *tt, (size_t) * cap);
	if (*ret)
		(*ret)->batDirty |= 2;
	return (*ret) ? GDK_SUCCEED : GDK_FAIL;
}

int
CMDnew_default(BAT **ret, int *ht, int *tt)
{
	int default_size = 0;

	return CMDnew(ret, ht, tt, &default_size);
}

int
CMDreverse(BAT **ret, BAT *b)
{
	*ret = BATmirror(b);
	BBPfix(b->batCacheid);
	return GDK_SUCCEED;
}

int
CMDmirror(BAT **ret, BAT *b)
{
	BAT *v = *ret = VIEWcombine(b);

	if (b->batRestricted == BAT_WRITE) {
		*ret = BATrcopy(v);
		BBPreclaim(v);
	}
	return (*ret) ? GDK_SUCCEED : GDK_FAIL;
}

int
CMDconvert(BAT **ret, BAT *b)
{
	if (BATconvert(*ret = b, CONV_HTON) == NULL)
		BBPfix(b->batCacheid);
	return GDK_SUCCEED;
}

int
CMDrevert(BAT **ret, BAT *b)
{
	if (BATrevert(*ret = b) == NULL)
		return GDK_FAIL;
	BBPfix(b->batCacheid);
	return GDK_SUCCEED;
}

int
CMDorder(BAT **ret, BAT *b)
{
	if (BATorder(*ret = b) == NULL)
		return GDK_FAIL;
	BBPfix(b->batCacheid);
	return GDK_SUCCEED;
}

int
CMDorder_rev(BAT **ret, BAT *b)
{
	if (BATorder_rev(*ret = b) == NULL)
		return GDK_FAIL;
	BBPfix(b->batCacheid);
	return GDK_SUCCEED;
}

int
CMDinsert_bun(BAT **r, BAT *b, ptr h, ptr t)
{
	if (BUNins(*r = b, @:batconvert(b,h)@, @:batconvert(b,t)@) == NULL)
		return GDK_FAIL;
	BBPfix(b->batCacheid);
	return GDK_SUCCEED;
}

int
CMDinsert_bat(BAT **r, BAT *b, BAT *s)
{
	if (BATins(*r = b, s) == NULL)
		return GDK_FAIL;
	BBPfix(b->batCacheid);
	return GDK_SUCCEED;
}

int
CMDreplace_bun(BAT **r, BAT *b, ptr h, ptr t)
{
	if (BUNreplace(*r = b, @:batconvert(b,h)@, @:batconvert(b,t)@, 0) == NULL)
		return GDK_FAIL;
	BBPfix(b->batCacheid);
	return GDK_SUCCEED;
}

int
CMDreplace_bat(BAT **r, BAT *b, BAT *s)
{
	if (BATreplace(*r = b, s, 0) == NULL)
		return GDK_FAIL;
	BBPfix(b->batCacheid);
	return GDK_SUCCEED;
}

int
CMDreplace_bun_force(BAT **r, BAT *b, ptr h, ptr t, bit *force)
{
	if (BUNreplace(*r = b, @:batconvert(b,h)@, @:batconvert(b,t)@, *force) == NULL)
		return GDK_FAIL;
	BBPfix(b->batCacheid);
	return GDK_SUCCEED;
}

int
CMDreplace_bat_force(BAT **r, BAT *b, BAT *s, bit *force)
{
	if (BATreplace(*r = b, s, *force) == NULL)
		return GDK_FAIL;
	BBPfix(b->batCacheid);
	return GDK_SUCCEED;
}

int
CMDdelete_bun(BAT **r, BAT *b, ptr h, ptr t)
{
	if (BUNdel(*r = b, h, t) == NULL)
		return GDK_FAIL;
	BBPfix(b->batCacheid);
	return GDK_SUCCEED;
}

int
CMDdelete_head(BAT **r, BAT *b, ptr h)
{
	if (BUNdelHead(*r = b, @:batconvert(b,h)@) == NULL)
		return GDK_FAIL;
	BBPfix(b->batCacheid);
	return GDK_SUCCEED;
}

int
CMDdelete_all(BAT **r, BAT *b)
{
	if (BATclear(*r = b) == NULL)
		return GDK_FAIL;
	BBPfix(b->batCacheid);
	return GDK_SUCCEED;
}

int
CMDdelete_bat_bun(BAT **r, BAT *b, BAT *s)
{
	if (BATdel(*r = b, s) == NULL)
		return GDK_FAIL;
	BBPfix(b->batCacheid);
	return GDK_SUCCEED;
}

int
CMDdelete_bat_head(BAT **r, BAT *b, BAT *s)
{
	if (BATdelHead(*r = b, s) == NULL)
		return GDK_FAIL;
	BBPfix(b->batCacheid);
	return GDK_SUCCEED;
}


int
void_inplace(BAT *b, oid id, ptr val)
{
	int res = GDK_SUCCEED;
	BUN p = NULL;
	BUN oldInserted = b->batInserted;

	assert(b->htype == TYPE_void);
	assert(b->hseqbase != oid_nil);
	assert(BATcount(b) > (id -b->hseqbase));

	b->batInserted = NULL;
	BUNfndVOID(p, b, (ptr) &id);

	assert(p >= b->batInserted);	/* we don't want delete/ins */
	assert(!b->batRestricted);
	if (!BUNinplace(b, p, (ptr) &id, val, 0))
		 res = GDK_FAIL;

	b->batInserted = oldInserted;
	return res;
}

int
bat_inplace(BAT **res, BAT *b, oid *id, ptr val )
{
	int ret = void_inplace(b,*id,val);
	*res = b;
	BBPfix(b->batCacheid);
	return ret;
}
 
ssize_t
void_replace_bat(BAT *b, BAT *u)
{
	size_t nr = 0;
	BUN r, s;

	BATloop(u, r, s) {
		oid updid = *(oid *) BUNhead(u, r);
		ptr val = BUNtail(u, r);

		if (void_inplace(b, updid, val) == GDK_FAIL)
			return -1;
		nr++;
	}
	return nr;
}

int
BATappend_wrap(BAT **res, BAT *i, BAT *u)
{
	if (!BATappend(i, u))
		return GDK_FAIL;
	*res = i;
	BBPfix(i->batCacheid);
	return GDK_SUCCEED;
}

int
BUNappend_wrap(BAT **res, BAT *i, ptr t)
{
	*res = BUNappend(i, @:batconvert(i,t)@
	    );
	if (*res) {
		BBPfix((*res)->batCacheid);
		return GDK_SUCCEED;
	}
	return GDK_FAIL;
}

int
bat_replace_oid_bat_wrap(BAT **res, BAT *o, BAT *d)
{
	*res = o;
	if (void_replace_bat(o, d) < 0)
		return GDK_FAIL;
	BBPfix(o->batCacheid);
	return GDK_SUCCEED;
}


/* descriptors may be unloaded by BBPtrim, so secure them with a hotfix while in use */
static BAT *
lock_desc(bat bid)
{
	BBPfix(bid);
	return (BAT *) BBPgetdesc(bid);
}

static void
unlock_desc(bat bid)
{
	BBPunfix(bid);
}

int
CMDcount_bat(lng *res, int *bid)
{
	if (BBPcheck((bat) *bid, "CMDcount_bat")) {
		BAT *b = lock_desc((bat) *bid);

		if (b == NULL) {
			*res = lng_nil;
		} else if (BBP_cache((bat) *bid)) {
			*res = (lng) BATcount(b);
		} else {
			/* BAT not loaded */
			*res = (lng) ((b->batBuns->free - (b->batFirst - b->batBuns->base)) / BUNsize(b) );
		}
		unlock_desc(*bid);
	}
	return GDK_SUCCEED;
}

int
CMDsetcount_bat(lng *res, BAT *b, lng *c)
{
#if SIZEOF_SIZE_T < SIZEOF_LNG
	if (*c >= ((lng) 1 << (8 * SIZEOF_SIZE_T))) {
		GDKerror("CMDslice: argument out of range\n");
		return GDK_FAIL;
	}
#endif
	BATsetcount(b, (size_t) *c);
	/* also need to set the end of the heap (allthough not used) */
	b->batBuns->free += (size_t) *c;
	*res = *c;
	return GDK_SUCCEED;
}

int
CMDcapacity(lng *res, int *bid)
{
	if (BBPcheck((bat) *bid, "CMDcapacity")) {
		BAT *b = lock_desc((bat) *bid);

		if (b == NULL) {
			*res = lng_nil;
		} else {
			*res = (lng) BATcapacity(b);
		}
		unlock_desc(*bid);
	}
	return GDK_SUCCEED;
}

int
CMDhead(str *res, int *bid)
{
	if (BBPcheck((bat) *bid, "CMDhead")) {
		str ret = (str)str_nil;
		BAT *b = lock_desc((bat) *bid);

		if (b) {
			ret = *bid > 0 ? ATOMname(b->htype) : ATOMname(b->ttype);
		}
		*res = GDKstrdup(ret);
		unlock_desc(*bid);
	} else {
		*res = GDKstrdup(str_nil);
	}
	return GDK_SUCCEED;
}

int
CMDhead_bat(str *res, BAT *b)
{
	return CMDhead(res, &b->batCacheid);
}

int
CMDhtype(int *res, int *bid)
{
	int ret = int_nil;
	if (BBPcheck((bat) *bid, "CMDhtype")) {
		BAT *b = lock_desc((bat) *bid);
		if (b) {
			ret = *bid > 0 ? b->htype : b->ttype;
		}
		unlock_desc(*bid);
	} *res = ret;
	return GDK_SUCCEED;
	
}

int
CMDhtype_bat(int *res, BAT *b)
{
	*res = b->htype; 
	return GDK_SUCCEED;
}

int
CMDtail(str *res, int *bid)
{
	if (BBPcheck((bat) *bid, "CMDtail")) {
		str ret = (str)str_nil;
		BAT *b = lock_desc((bat) *bid);

		if (b) {
			ret = *bid > 0 ? ATOMname(b->ttype) : ATOMname(b->htype);
		}
		*res = GDKstrdup(ret);
		unlock_desc(*bid);
	} else {
		*res = GDKstrdup(str_nil);
	}
	return GDK_SUCCEED;
}

int
CMDtail_bat(str *res, BAT *b)
{
	return CMDtail(res, &b->batCacheid);
}

int
CMDttype(int *res, int *bid)
{
	int ret = int_nil;
	if (BBPcheck((bat) *bid, "CMDttype")) {
		BAT *b = lock_desc((bat) *bid);
		if (b) {
			ret = *bid > 0 ? b->ttype : b->htype;
		}
		unlock_desc(*bid);
	} *res = ret;
	return GDK_SUCCEED;
}

int
CMDttype_bat(int *res, BAT *b)
{
	*res = b->ttype; 
	return GDK_SUCCEED;
}



int
CMDsetkey(BAT **result, BAT *input, bit *param)
{
	BATkey(*result = input, *param ? BOUND2BTRUE : FALSE);
	BBPfix(input->batCacheid);
	return GDK_SUCCEED;
}

int
CMDsetset(BAT **result, BAT *input, bit *param)
{
	BATset(*result = input, *param ? BOUND2BTRUE : FALSE);
	BBPfix(input->batCacheid);
	return GDK_SUCCEED;
}

int
CMDordered(bit *result, BAT *input)
{
	*result = BATordered(input) ? 1 : 0;
	return GDK_SUCCEED;
}

int
CMDchk_order(BAT **result, BAT *input)
{
	BATordered(input);
	BATordered(BATmirror(input));
	BBPfix(input->batCacheid);
	*result = input;
	return GDK_SUCCEED;
}

int
CMDordered_rev(bit *result, BAT *input)
{
	*result = BATordered_rev(input) ? 1 : 0;
	return GDK_SUCCEED;
}

int
CMDgetkey(bit *ret, BAT *b)
{
	/* we must take care of the special case of a nil column (TYPE_void,seqbase=nil)
	 * such nil columns never set hkey (and BUNins will never invalidate it if set) yet
	 * a nil column of a BAT with <= 1 entries does not contain doubles => return TRUE.
	 */
	if (BATcount(b) <= 1) {
		*ret = TRUE;
	} else {
		if (!b->hkey) {
			BATpropcheck(b, BATPROPS_ALL);
		}
		*ret = b->hkey ? TRUE : FALSE;
	}
	return GDK_SUCCEED;
}

int
CMDpersists(BAT **r, BAT *input, bit *param)
{
	BATmode(*r = input, (*param == TRUE) ? PERSISTENT : (*param == FALSE) ? TRANSIENT : SESSION);
	BBPfix(input->batCacheid);
	return GDK_SUCCEED;
}

int
CMDdestroy(bit *res, str input )
{
	int bid = BBPindex(input);

	*res = FALSE;
	if (bid) {
		BBPfix(bid);
		if (BBPindex(input) == bid) {
			BAT *b = (BAT*)BBPgetdesc(ABS(bid));

			BATmode(b, TRANSIENT);
			*res = TRUE;
		}
		BBPunfix(bid);
	}
	return GDK_SUCCEED;
}

int
CMDsetaccess(BAT **r, BAT *input, int *param)
{
	bat oldCacheid = input->batCacheid;

	*r = BATsetaccess(input, *param);
	if ((*r)->batCacheid == oldCacheid) {
		BBPfix(oldCacheid);
	}
	return GDK_SUCCEED;
}

int
CMDgetaccess(int *r, BAT *input)
{
	*r = BATgetaccess(input);
	return GDK_SUCCEED;
}

static char *
pre(str s1, str s2)
{
	static char buf[64];

	snprintf(buf, 64, "%s%s", s1, s2);
	return buf;
}
static char *
local_itoa(ssize_t i)
{
	static char buf[32];

	snprintf(buf, 32, SSZFMT, i);
	return buf;
}
static char *
local_utoa(size_t i)
{
	static char buf[32];

	snprintf(buf, 32, SZFMT, i);
	return buf;
}

#define COLLISION 6

void
HASHinfo(BAT *bn, Hash *h, str s)
{
	hash_t i;
	hash_t j;
	size_t cnt[COLLISION + 2];
	size_t largebuckets = 0;
	size_t largetot = 0;
	char buf[32];

	BUNins(bn, pre(s, "type"), ATOMname(h->type));
	BUNins(bn, pre(s, "mask"), local_utoa(h->mask));
	BUNins(bn, pre(s, "lim"), local_utoa(h->lim));

	for (i = 0; i <= COLLISION + 1; i++) {
		cnt[i] = 0;
	}
	for (i = 0; i <= h->mask; i++) {
		if (h->hash[i] == HASH_MAX) {
			cnt[0]++;
		} else if (h->hash[i] > h->lim) {
			GDKerror("HASHinfo: hash consistency problem %d\n", i);
		} else if ((j = HASHlist(h, h->hash[i])) <= COLLISION + 1) {
			cnt[j]++;
		} else {
			largebuckets++;
			largetot += j;
		}
	}

	for (i = 0; i <= COLLISION + 1; i++)
		if (cnt[i]) {
			BUNins(bn, pre(s, local_utoa(i)), local_utoa(cnt[i]));
		}
	snprintf(buf, 32, SZFMT " on " SZFMT, largetot, largebuckets);
	BUNins(bn, pre(s, "collision"), buf);
}

static void
infoHeap(BAT *bn, Heap *hp, str nme)
{
	char buf[1024], *p = buf;

	if (!hp)
		return;
	while (*nme)
		*p++ = *nme++;
	strcpy(p, "free");
	BUNins(bn, buf, local_utoa(hp->free));
	strcpy(p, "size");
	BUNins(bn, buf, local_utoa(hp->size));
	strcpy(p, "maxsize");
	BUNins(bn, buf, local_utoa(hp->maxsize));
	strcpy(p, "storage");
	BUNins(bn, buf, (hp->base == NULL) ? "absent" : (hp->storage == STORE_MMAP) ? (hp->filename ? "memory mapped" : "anonymous vm") : (hp->storage & STORE_PRIV) ? "private map" : "malloced");
	strcpy(p, "filename");
	BUNins(bn, buf, hp->filename ? hp->filename : "no file");
}

static char *
oidtostr(oid i)
{
	int len = 32;
	static char bf[32];
	char *p = bf;

	(void) OIDtoStr(&p, &len, &i);
	return bf;
}

int
CMDinfo(BAT **retval, BAT *b)
{
	BAT *bn;
	char mode[1024], *access;

	if (!(bn = BATnew(TYPE_str, TYPE_str, 128)))
		return GDK_FAIL;
	*retval = bn;

	if (b->batPersistence == PERSISTENT) {
		strcpy(mode, "persistent");
	} else if (b->batPersistence == SESSION) {
		strcpy(mode, "session");
	} else if (b->batPersistence == TRANSIENT) {
		strcpy(mode, "transient");
	} else {
		strcpy(mode, "unknown");
	}

	switch (b->batRestricted) {
	case BAT_READ:
		access = "read-only";
		break;
	case BAT_WRITE:
		access = "updatable";
		break;
	case BAT_APPEND:
		access = "append-only";
		break;
	default:
		access = "unknown";
	}

	BUNins(bn, "version", local_itoa(b->GDKversion));
	BUNins(bn, "batId", BATgetId(b));
	BUNins(bn, "batCacheid", local_itoa(b->batCacheid));
	BUNins(bn, "batParentid", local_itoa(b->batParentid));
	BUNins(bn, "batSharecnt", local_itoa(b->batSharecnt));
	BUNins(bn, "head", ATOMname(b->htype));
	BUNins(bn, "tail", ATOMname(b->ttype));
	BUNins(bn, "batPersistence", mode);
	BUNins(bn, "batRestricted", access);
	BUNins(bn, "batRefcnt", local_itoa(BBP_refs(b->batCacheid)));
	BUNins(bn, "batLRefcnt", local_itoa(BBP_lrefs(b->batCacheid)));
	BUNins(bn, "batDirty", BATdirty(b) ? "dirty" : "clean");
	BUNins(bn, "batSet", local_itoa(b->batSet));
	BUNins(bn, "void_tid", local_itoa(b->void_tid));
	BUNins(bn, "void_cnt", local_itoa(b->void_cnt));

	BUNins(bn, "hsorted", local_itoa(BAThordered(b)));
	BUNins(bn, "hident", b->hident);
	BUNins(bn, "hdense", local_itoa(BAThdense(b)));
	BUNins(bn, "hseqbase", oidtostr(b->hseqbase));
	BUNins(bn, "hkey", local_itoa(b->hkey));
	BUNins(bn, "hloc", local_itoa(b->hloc));
	BUNins(bn, "hvarsized", local_itoa(b->hvarsized));
	BUNins(bn, "halign", local_utoa(b->halign));
	BUNins(bn, "hnosorted", local_utoa(b->H->nosorted));
	BUNins(bn, "hnosorted_rev", local_utoa(b->H->nosorted_rev));
	BUNins(bn, "hnodense", local_utoa(b->H->nodense));
	BUNins(bn, "hnokey[0]", local_utoa(b->H->nokey[0]));
	BUNins(bn, "hnokey[1]", local_utoa(b->H->nokey[1]));

	BUNins(bn, "tident", b->tident);
	BUNins(bn, "tdense", local_itoa(BATtdense(b)));
	BUNins(bn, "tseqbase", oidtostr(b->tseqbase));
	BUNins(bn, "tsorted", local_itoa(BATtordered(b)));
	BUNins(bn, "tkey", local_itoa(b->tkey));
	BUNins(bn, "tloc", local_itoa(b->tloc));
	BUNins(bn, "tvarsized", local_itoa(b->tvarsized));
	BUNins(bn, "talign", local_utoa(b->talign));
	BUNins(bn, "tnosorted", local_utoa(b->T->nosorted));
	BUNins(bn, "tnosorted_rev", local_utoa(b->T->nosorted_rev));
	BUNins(bn, "tnodense", local_utoa(b->T->nodense));
	BUNins(bn, "tnokey[0]", local_utoa(b->T->nokey[0]));
	BUNins(bn, "tnokey[1]", local_utoa(b->T->nokey[1]));

	BUNins(bn, "batInserted", local_utoa(BUNindex(b, b->batInserted)));
	BUNins(bn, "batDeleted", local_utoa(BUNindex(b, b->batDeleted)));
	BUNins(bn, "batFirst", local_utoa(BUNindex(b, b->batFirst)));
	BUNins(bn, "top", local_utoa(BUNindex(b, (BUN) ((char *) Bunbase(b) + b->batBuns->free))));
	BUNins(bn, "batStamp", local_itoa(b->batStamp));
	BUNins(bn, "lastUsed", local_itoa(BBP_lastused(b->batCacheid)));
	BUNins(bn, "curStamp", local_itoa(BBPcurstamp()));
	BUNins(bn, "batCopiedtodisk", local_itoa(b->batCopiedtodisk));
	BUNins(bn, "batDirtydesc", b->batDirtydesc ? "dirty" : "clean");

	BUNins(bn, "batDirtybuns", b->batDirtybuns ? "dirty" : "clean");
	infoHeap(bn, b->batBuns, "batBuns.");

	BUNins(bn, "hheapdirty", b->hheapdirty ? "dirty" : "clean");
	infoHeap(bn, b->hheap, "hheap.");

	BUNins(bn, "theapdirty", b->theapdirty ? "dirty" : "clean");
	infoHeap(bn, b->theap, "theap.");

	/* dump index information */
	if (b->hhash) {
		HASHinfo(bn, b->hhash, "hhash->");
	}
	if (b->thash) {
		HASHinfo(bn, b->thash, "thash->");
	}
	return GDK_SUCCEED;
}

#define ROUND_UP(x,y) ((y)*(((x)+(y)-1)/(y)))

int
CMDbatsize(lng *tot, BAT *b)
{
	size_t blksize = MT_pagesize();
	size_t size = ROUND_UP(sizeof(BATstore), blksize);

	if (!VIEWparent(b)) {
		size_t cnt = BATcapacity(b);

		size += ROUND_UP(b->batBuns->size, blksize);
		if (b->hheap)
			size += ROUND_UP(b->hheap->size, blksize);
		if (b->theap)
			size += ROUND_UP(b->theap->size, blksize);
		if (b->hhash)
			size += ROUND_UP(sizeof(hash_t) * cnt, blksize);
		if (b->thash)
			size += ROUND_UP(sizeof(hash_t) * cnt, blksize);
	}
	*tot = size;
	return GDK_SUCCEED;
}

int
CMDbatsize_str(lng *tot, str batname)
{
	bat bid = BBPindex(batname);
	BAT *b = bid ? (BAT *) BBPgetdesc(bid) : NULL;

	if (b == NULL) {
		GDKerror("CMDbatsize_str: %s no such bat.\n", batname);
		return GDK_FAIL;
	}
	return CMDbatsize(tot, b);
}

@+ Synced BATs
@c
int
CMDsynced(bit *ret, BAT *b1, BAT *b2)
{
	*ret = ALIGNsynced(b1, b2) ? 1 : 0;
	return GDK_SUCCEED;
}

@+ BBP Management, IO
@c
int
CMDroles(BAT **r, BAT *b, str hname, str tname)
{
	BATroles(*r = b, hname, tname);
	BBPfix(b->batCacheid);
	return GDK_SUCCEED;
}

int
CMDcol_name(BAT **r, BAT *b, str tname)
{
	BATcol_name(*r = b, tname);
	BBPfix(b->batCacheid);
	return GDK_SUCCEED;
}

int
CMDrename(bit *retval, BAT *b, str s)
{
	int ret;
	int c;
	char *t = s;

	for ( ; (c = *t) != 0; t++) {
		if (c != '_' && !GDKisalnum(c)) {
			GDKerror("CMDrename: identifier expected: %s\n", s);
			return GDK_FAIL;
		}
	}

 	ret = BATname(b, s);
	*retval = FALSE;
	if (ret == 1) {
		GDKerror("CMDrename: identifier expected: %s\n", s);
		return GDK_FAIL;
	} else if (ret == BBPRENAME_ILLEGAL) {
		GDKerror("CMDrename: illegal temporary name: '%s'\n", s);
		return GDK_FAIL;
	} else if (ret == BBPRENAME_LONG) {
		GDKerror("CMDrename: name too long: '%s'\n", s);
		return GDK_FAIL;
	} else if (ret != BBPRENAME_ALREADY) {
		*retval = TRUE;
	}
	return GDK_SUCCEED;
}

int
CMDname(str *retval, BAT *b)
{
	*retval = GDKstrdup(BBPname(b->batCacheid));
	return GDK_SUCCEED;
}

int
CMDunload(bit *res, str input)
{
	bat bid = ABS(BBPindex(input));

	*res = FALSE;
	if (bid > 0) {
		BAT *b;

		BBPfix(bid);
		b = BBP_cache(bid);
		if (b) {
			if (b->batPersistence == SESSION)
				BATmode(b, TRANSIENT);
			BBPcold(bid);	/* will trigger unload of also persistent bats */
		}
		*res = BBPunfix(bid) == 0;
	}
	return GDK_SUCCEED;
}

int
CMDhot(str input)
{
	BBPhot(BBPindex(input));
	return GDK_SUCCEED;
}

int
CMDcold(str input)
{
	BBPcold(BBPindex(input));
	return GDK_SUCCEED;
}

int
CMDheat(int *res, str input)
{
	int bid = BBPindex(input);

	if (bid) {
		*res = BBP_lastused(bid) & 0x7fffffff;
	}
	return GDK_SUCCEED;
}

int
CMDsave(bit *res, str input)
{
	bat bid = BBPindex(input);
	BAT *b;

	*res = FALSE;
	if (bid) {
		BBPfix(bid);
		b = BBP_cache(bid);
		if (b && BATdirty(b)) {
			if (BBPsave(b) == 0)
				*res = TRUE;
		}
		BBPunfix(bid);
	}
	return GDK_SUCCEED;
}


@= change_heap
{
	if (@2) {
		int mode = (@2)->storage;

		if (mode == STORE_MMAP && (@2)->filename == NULL)
			mode = STORE_MEM;
		if (mode == STORE_PRIV)
			mode = STORE_MMAP;
		if (*@1 == int_nil || *@1 == mode) {
			*@1 = -1;
		}
	}
}
@c
int
CMDmmap(BAT **r, BAT *b, int *bns, int *hhp, int *thp)
{
	@:change_heap(bns,b->batBuns)@
	@:change_heap(hhp,b->hheap)@
	@:change_heap(thp,b->theap)@
	if (BATmmap(*r = b, *bns, *hhp, *thp) == 0) {
		BBPfix(b->batCacheid);
		return GDK_SUCCEED;
	}
	return GDK_FAIL;
}

int
CMDmadvise(BAT **r, BAT *b, int *bns, int *hhp, int *thp)
{
	BBPfix(b->batCacheid);
	return BATmadvise(*r = b, (*bns == int_nil) ? -1 : *bns, (*hhp == int_nil) ? -1 : *hhp, (*thp == int_nil) ? -1 : *thp) ? GDK_FAIL : GDK_SUCCEED;
}

@+ Accelerator Control
@c
int
CMDaccbuild(BAT *b, str acc )
{
	if (strcmp(acc, "hash") == 0 && BAThash(b,0)) {
		return GDK_SUCCEED;
	}
	return GDK_FAIL;
}

@+ Iterators
@= hashiter
	if (b->tvarsized) {
		HASHloop@1(b, b->hhash, idx, v, p)
			if ((i = ITERATE(v, BUNtvar(b,p), h)) < 0)
				return i;
	} else {
		HASHloop@1(b, b->hhash, idx, v, p)
			if ((i = ITERATE(v, BUNtloc(b,p), h)) < 0)
				return i;
	}
	break;
@c
int
CMDhashloop(BAT *b, ptr *handle, ptr v)
{
	Iteration h = *(Iteration *) handle;
	char *p;
	hash_t idx;
	int i;

	if (BATprepareHash(b))
		return GDK_FAIL;

	switch (ATOMstorage(BAThtype(b))) {
	case TYPE_chr:
		@:hashiter(_chr)@
	case TYPE_sht:
		@:hashiter(_sht)@
	case TYPE_int:
	case TYPE_flt:
		@:hashiter(_int)@
	case TYPE_dbl:
	case TYPE_lng:
		@:hashiter(_lng)@
	default:
		if (b->hvarsized) {
			@:hashiter(var)@
		} else {
			@:hashiter(loc)@
		}
	}
	return GDK_SUCCEED;
}

@= batlooparg
	if (@1 > BATcount(b)) {
		GDKerror("CMDbatloop: @1 parameter out of range (%lu %lu).\n", @1, BATcount(b));
		return GDK_FAIL;
	}
	@2 = BUNptr(b, BUNindex(b, BUNfirst(b)) + @1);
@= batloopitr
	while (p <= q) {
		if ((i = ITERATE(BUNh@1(b,p), BUNt@2(b,p), h)) < 0)
			return i;
		p = (BUN) ((char *) p + s);
	}
@c
static int
doCMDbatloop(BAT *b, ptr *handle, size_t low, size_t high)
{
	Iteration h = *(Iteration *) handle;
	BUN p, q;
	int i, s = BUNsize(b);

	if (high < low)
		return GDK_SUCCEED;
	@:batlooparg(low,p)@
	@:batlooparg(high,q)@
	if (b->hvarsized) {
		if (b->tvarsized) {
			@:batloopitr(var,var)@
		} else {
			@:batloopitr(var,loc)@
		}
	} else {
		if (b->tvarsized) {
			@:batloopitr(loc,var)@
		} else {
			@:batloopitr(loc,loc)@
		}
	}
	return GDK_SUCCEED;
}

/* XXX should be size_t *low, size_t *high for 64 bit architecture */
int
CMDbatloop(BAT *b, ptr *handle, int *low, int *high)
{
	return doCMDbatloop(b, handle, (size_t) * low, (size_t) * high);
}

int
CMDbatloop_std(BAT *b, ptr *handle)
{
	size_t n = BATcount(b);

	if (n == 0)
		return GDK_SUCCEED;
	return doCMDbatloop(b, handle, (size_t) 0, n - 1);
}

int
CMDget_seqbase(oid *o, BAT *b)
{
	*o = b->hseqbase;
	return GDK_SUCCEED;
}

int
CMDset_seqbase(BAT **r, BAT *b, oid *o)
{
	BATseqbase(*r = b, *o);
	BBPfix(b->batCacheid);
	return GDK_SUCCEED;
}

@+ Page-wise BAT remappings
@T
The XML node storage scheme of MonetDB/XQuery needs some extra kernel support. 

\begin{itemize}
\item
  we introduce a fast way to create BATs with the VM pages in a different order
  (to cheaply support inserting new pages halfway). 
\item
  we introduce a primitive to swizzle OIDs for such remappings between RIDs (the real
  voids on disk) and PREs (the voids of the remapped copy).
\end{itemize}

Also, we use copy-on-write maps for transaction isolation. Contrary to intuition, we 
write into STORE_MMAP read-only master bats (overriding the read-only protection 
with a new 'force' flag), and read only from the copy-on-write copies produced by 
the 'remap'. These copies provide efficient shadow paging. That is, before a master bat 
is replaced into (appends are no problem) then all live read copies (copy-on-write remaps) 
get a 'idempotent' replace on the affected pages (a BUN replace with a value that was 
already there), such that a shadow copy of the page is made by the OS. In this way, 
the subsequent update in the master bat is invisible in the copy-on-write copies 
(transaction isolation). There is a 'pagesample' PROC that produces such an 
idempotent

other changes were:

\begin{itemize}
\item
  gdk_bat.mx/gdk_batop.mx: a 'force' flag in update operations that allow to update
  read-only/append-only BATs anyway. Note that if used, another (WAL-based) recovery
  mechanism must be used to repair BATs after a system crash!! This is a user
  responability (in this case, of the MonetDB/XQuery frontend).
\item
  gdk_bat.mx: make a true copy of remapped BUN heaps if the bat becomes persistent or updatable. 
\item
  gdk_batop.mx: optimized fetchjoin for idempotent positional joins (into a bat[void,void]
  with equal seqbase and all tuples hitting).
\end{itemize}

In swizzling as well as in positional join, specific optimizations are made for
the common case where all pages appear in order (this occurs in XML tables that have
not yet received updates or are read-only). In this case swizzling is a no-op.

For read-only tables, logical node IDs (nids) are equal to both PREs and RIDs. A 
translation from NID to PRE (or RID) then becomes positional join onto a bat[void,void] 
with seqbases 0@0, which is an idempotent join. This case now returns a view at
zero cost.

@- Remapped Copy
@T
CMDremap makes a copy of a bat, putting the logical 'pages' (65536 tuples) in an 
alternative order, specified by a map. It is optimized to use copy-on-write memory 
mappings to make cheap copies, when possible.

The result is a read-only copy of the original. As it is a true copy, in principle 
we can replace (but nor insert/delete) BUNs in it, overriding the access restriction.

Making such bats persistent or appendable/writable, will force a true copy of the 
copy-on-write mmap heap to be made.
@c
static int
copy_segment(char* mmap, BAT *bn, BAT *b, int src, int dst, int cnt) {
	int ret = 0;
	if (cnt) {
	        size_t xx = REMAP_PAGE_SIZE * BUNsize(b);
		size_t src_off = ((size_t) src) * xx;
		size_t dst_off = ((size_t) dst) * xx;
		size_t nbytes  = ((size_t) cnt) * xx;
		size_t partial = (BUNlast(b) - BUNfirst(b)) - src_off;
		if (!mmap) {
			/* copy segment from master bat */
			memcpy(BUNfirst(bn) + dst_off, BUNfirst(b) + src_off, (partial < nbytes)?partial:nbytes);
		} else if (src_off != dst_off) { /* otherwise it is already mapped so */
			void *fixed = (bn->batBuns->base + dst_off);
                        if (GDKmmap(mmap, MMAP_READ|MMAP_SEQUENTIAL|MMAP_COPY, src_off, nbytes, fixed) != fixed) {
				return 0;
			}
		}
		if (partial < nbytes) {
			/* fill a partial page with nils */
			ptr nil = ATOMnilptr(bn->ttype);
			BUN cur = BUNfirst(bn) + dst_off + partial;
			BUN end = BUNlast(bn);
			for(xx=BUNsize(bn); cur < end; cur += xx) {
				ATOMreplace(bn->ttype, bn->theap, BUNtail(bn,cur), nil); 
			}
		}
	}
	ret = 1;
bunins_failed:			
	return ret;
}

int
CMDremap(BAT **res, BAT *b, BAT *map)
{
	size_t cnt = BATcount(map), n = BATcount(b), max = (((ssize_t) n) - 1) / REMAP_PAGE_SIZE;
	int (*fix) (ptr) = BATatoms[b->ttype].atomFix;
	oid* pid = (oid*) alloca(cnt*sizeof(oid));
        size_t xx, yy = 0, zz = 0;
	char path[MAXPATHLEN];
        char *chk;
	BUN p, q;
	BAT *bn;

   	/* try to use fast page-wise memory mapping technique on read-only mmapped [void,X] bats */ 
        int failure = 0;
        char* mmap = (((BUNfirst(b) - b->batBuns->base) & REMAP_PAGE_MASK) == 0 &&
                    (b->batRestricted != BAT_WRITE) &&
	            (b->batBuns->storage == STORE_MMAP))?path:NULL;

        /* sanity check on page map */
	if (BAThdense(map) == 0 || map->hseqbase ) {
		GDKerror("remap: map head column must be dense and starting from 0@0.\n");
		return GDK_FAIL;
	}
	if (b->ttype == TYPE_void) {
		/* remappings on bat[void,void] are only supported in the trivial case (all pages in order) */
		if (!BATtdense(map)) {
			GDKerror("remap: a bat[void,void] cannot me remapped.\n");
			return GDK_FAIL;
		}
		/* create another bat[void,void]. BEWARE: last page is not NIL padded!! */
		*res = bn = BATnew(TYPE_void, TYPE_void, 10);
		if (bn == NULL) return GDK_FAIL;
		BATseqbase(bn, 0);
		if (cnt) {
			oid pid = *(oid*) BUNtail(map,BUNfirst(map));
			BATseqbase(BATmirror(bn), pid << REMAP_PAGE_BITS);
		}
        	BATsetcount(bn,cnt <<= REMAP_PAGE_BITS);
		bn->batBuns->free += cnt*BUNsize(bn);
		return GDK_SUCCEED;
	}

        /* chk is a bit mask to ensure that no page is requested twice */
	chk = (char*) GDKmalloc(n = 1 + max/8);
	if (chk == NULL) return GDK_FAIL;
	memset(chk, 0, n);

	/* check that the set of requested page-ids is a subset of all existing page-ids */
	BATloopFast(map, p, q, xx) {
		oid id = *(oid*) BUNtail(map, p);
		size_t idx = id >> 3;  
		size_t mask = 1 << (id & 7);  
		if (id > max) {
			GDKerror("remap: map index " SZFMT "@0 out of range [0@0," SZFMT "@0]\n", id, max);
			GDKfree(chk);
			return GDK_FAIL;
		} else if (chk[idx] & mask) {
			GDKerror("remap: map index " SZFMT "@0 occurs twice.\n", id);
			GDKfree(chk);
			return GDK_FAIL;
		}
		pid[yy++] = id;
		chk[idx] |= mask;
	}
	GDKfree(chk);

	/* create result bat descriptor */
	*res = bn = BATcreatedesc(TYPE_void, b->ttype, TRUE); 
	if (bn == NULL) return GDK_FAIL;
        BATinit_idents(bn);
	bn->dims = b->dims;
	bn->htype = TYPE_void;
	bn->hvarsized = 1;
	bn->hseqbase = 0;
	bn->tsorted = 0;
	bn->tkey = 0;
	bn->batRestricted = BAT_READ;
	BATsetcount(bn, n = (cnt << REMAP_PAGE_BITS));
	n *= BUNsize(b);

	/* copy the entire tail heap (if present) */
	if (ATOMvarsized(bn->ttype)) {
		if (HEAPalloc(bn->theap, (size_t) (b->theap->free*BATMARGIN), 1) >= 0) {
        		memcpy(bn->theap->base, b->theap->base, bn->theap->free = b->theap->free);
		} else {
			failure = 1;
		}
	}
	/* try to get a reserved mmap region */
	if (failure == 0 && mmap) {
		if (bn->batBuns->filename) GDKfree(bn->batBuns->filename); 
		bn->batBuns->filename = GDKstrdup(b->batBuns->filename); 
		failure = (bn->batBuns->filename == NULL);
                GDKfilepath(mmap, BATDIR, bn->batBuns->filename, NULL);
	}
	if (failure == 0 && mmap) {
		bn->batBuns->base = GDKmmap(mmap, MMAP_READ|MMAP_SEQUENTIAL|MMAP_COPY, 0, n, NULL);

		if ((bn->batBuns->base != NULL) & (bn->batBuns->base != (BUN) -1)) {
			bn->batBuns->size = bn->batBuns->maxsize = n; 
			bn->batBuns->storage = STORE_MMAP | STORE_PRIV;
			bn->batBuns->copied = 1;
		} else {
			mmap = NULL; /* fall back on heap memory */
		}
	}
	if (failure == 0) {
retry:		if (!mmap) failure = (HEAPalloc(bn->batBuns, n, 1) < 0);
	}
	if (failure) {
		/* failed to allocate */
		if (bn->theap) {
			HEAPfree(bn->theap);
			GDKfree(bn->theap);
		}
		HEAPfree(bn->batBuns);
		BBPclear(bn->batCacheid);
		return GDK_FAIL;
        }

	/* set the right bat size */
	bn->batBuns->free = n;
	bn->batFirst = bn->batDeleted = bn->batBuns->base;
	bn->batInserted = bn->batBuns->base + n;

	/* go over all pages and copy them in segments that unite consecutively mapped pages */
	for(xx=1; xx<cnt; xx++) {
		if (pid[xx]-1 != pid[xx-1]) {
			if (!copy_segment(mmap, bn, b, pid[zz], zz, xx-zz)) break;
			zz = xx;
		}
	}
	if (xx < cnt || !copy_segment(mmap, bn, b, pid[zz], zz, cnt-zz)) {
		HEAPfree(bn->batBuns);
		failure = 1; mmap = (char*) (((size_t) mmap) ^ ((size_t) path));
		goto retry;
	}

	/* if the tail atom has refcounting, we must fix the copies */
	if (fix) {
		BATloopFast(bn, p, q, xx) {
			fix(BUNtail(bn, p));
		}
	}
	/* more safety: make mmap-ed remaps  a view to ensure the parent stays alive */
	if (mmap) {
		bn->batParentid = VIEWparent(b);
		if (bn->batParentid == 0) bn->batParentid = b->batCacheid;
		BBPshare(ABS(bn->batParentid));
	}
	BBPcacheit(bn);
	return GDK_SUCCEED;
}

@- page-wise OID swizzling

I am really sorry I did all these premature optimizions. However, they have been tested and work now.
@c
#ifdef HAVE_RESTRICT
#define __r     restrict
#else
#ifdef HAVE___RESTRICT__
#define __r     __restrict__
#else
#define __r
#endif
#endif

#define GET_IDX(pos,shift,mask) (((pos & ~REMAP_PAGE_MASK) >> shift) & mask)  
#define FAST_IDX(pos,shift,mask) ((pos >> shift) & mask)  

@= swizzle
{	int ok = 1, mask0, mask1, mask2, mask3;
	i = j = 0;
	m <<= REMAP_PAGE_BITS;
	for(n*=@1; i+@1+@1+@1<n; i+=@1+@1+@1+@1, j+=4) {
		mask0 = (src[i] >= m) - 1; 
		dst[j] = (map[@3_IDX(src[i],@2,mask0)] << REMAP_PAGE_BITS) | (src[i] & REMAP_PAGE_MASK);

		mask1 = (src[i+@1] >= m) - 1; 
		dst[j+1] = (map[@3_IDX(src[i+@1],@2,mask1)] << REMAP_PAGE_BITS) | (src[i+@1] & REMAP_PAGE_MASK);

		mask2 = (src[i+@1+@1] >= m) - 1; 
		dst[j+2] = (map[@3_IDX(src[i+@1+@1],@2,mask2)] << REMAP_PAGE_BITS) | (src[i+@1+@1] & REMAP_PAGE_MASK);

		mask3 = (src[i+@1+@1+@1] >= m) - 1; 
		dst[j+3] = (map[@3_IDX(src[i+@1+@1+@1],@2,mask3)] << REMAP_PAGE_BITS) | (src[i+@1+@1+@1] & REMAP_PAGE_MASK);

		/* hand unrolled above because compiler can't see through this dependency */
		ok &= mask0 & mask1 & mask2 & mask3;
	}
	for(; i<n; i+=@1, j++) {
		mask0 = (src[i] >= m) - 1; /* 0xFFFFFF if OK, 0 if out-of range */
		dst[j] = (map[@3_IDX(src[i],@2,mask0)] << REMAP_PAGE_BITS) | (src[i] & REMAP_PAGE_MASK);
		ok &= mask0;
	}
	if (!ok) return 0;
}
@c
static int
swizzle(oid *__r dst, oid *__r src, oid *__r map, size_t lo, size_t n, size_t m, size_t delta, size_t shift)
{
	size_t i, j, k;

	if (delta == 0 && n) {
		/* in case of a dense tail in b, we can check for overflow in advance */ 
		size_t base, p = (n+lo) >> REMAP_PAGE_BITS;
		if (p >= m) return 0; /* here it goes */ 

                /* the rest of the code is also faster as the index i in map[] stays constant per page */
		shift = REMAP_PAGE_BITS - shift;
                p <<= shift;

		/* first do the partial first page */
		j = lo & REMAP_PAGE_MASK;
		k = (j+n < REMAP_PAGE_SIZE)?j+n:REMAP_PAGE_SIZE;
		i = (lo >> REMAP_PAGE_BITS) << shift;
		for (base = map[i] << REMAP_PAGE_BITS; j < k; j++) { 
			*dst++ = base + j;
		}
		if (j < REMAP_PAGE_SIZE) return 1;

		/* do all full pages as fast as possible */
		for (i+= 1<<shift; i < p; i += 1<<shift) {
			k = i << (REMAP_PAGE_BITS-shift);
			for (base = map[i] << REMAP_PAGE_BITS, j = 0; j < REMAP_PAGE_SIZE; j++) 
				*dst++ = base + j;
		}
		/* finally do the partial last page */
		k = p << (REMAP_PAGE_BITS-shift);
		for (base = map[p] << REMAP_PAGE_BITS, j = 0; j < lo + n - k; j++) 
			*dst++ = base + j;
	} else if (delta == 1 && shift == REMAP_PAGE_BITS) {
		@:swizzle(1,REMAP_PAGE_BITS,FAST)@ /* help register poor ISAs */
	} else if (delta == 2 && shift == REMAP_PAGE_BITS) {
		@:swizzle(2,REMAP_PAGE_BITS,FAST)@ /* help register poor ISAs */
	} else if (delta == 1 && shift == REMAP_PAGE_BITS-1) {
		@:swizzle(1,(REMAP_PAGE_BITS-1),GET)@ /* help register poor ISAs */
	} else if (delta == 2 && shift == REMAP_PAGE_BITS-1) {
		@:swizzle(2,(REMAP_PAGE_BITS-1),GET)@ /* help register poor ISAs */
	} else {
		@:swizzle(delta,shift,GET)@
	}
	return 1;
}

int
CMDswizzle(BAT **res, BAT *b, BAT *map)
{
	BAT *bn = *res = b;

	if (map->hseqbase) {
		GDKerror("[swizzle]: map %s should be a void column starting at 0@0.\n", 
			BBP_logical(map->batCacheid));
		return GDK_FAIL;
	}
	if (BATcount(map) == 0) {
		/* special semantics: empty bat => no remapping */
		BBPfix(b->batCacheid);
		return GDK_SUCCEED;
	}
	if (BATtdense(map)) { 
		if (map->tseqbase) {
			GDKerror("[swizzle]: map %s is a void view.\n", BBP_logical(map->batCacheid)); 
			return GDK_FAIL;
		}
		/* HACK does not check for out-of-range oids */
		BBPfix(b->batCacheid);
		return GDK_SUCCEED;
	} 
	*res = bn = BATnew(TYPE_void, TYPE_oid, BATcount(b));
	if (bn) {
		int i = BUNsize(map)/sizeof(oid), shift = 0;
		while(i>>=1) shift++;
	    	if (swizzle(
			(oid *) BUNfirst(bn), 
			(oid *) BUNtloc(b, BUNfirst(b)), 
			(oid *) BUNtloc(map, BUNfirst(map)), 
			*(oid *) BUNtail(b, BUNfirst(b)), 
			BATcount(b),
			BATcount(map),
			BATtdense(b) ? 0 : BUNsize(b) / sizeof(oid),
			REMAP_PAGE_BITS - shift))
		{
			bn->batBuns->free = sizeof(oid) * BATcount(b);
			bn->tsorted = 0;
			BATsetcount(bn, BATcount(b));
			BATseqbase(bn, b->hseqbase);
			return GDK_SUCCEED;
		} else {
			GDKerror("[swizzle]: %s contains illegal offsets.\n", BBP_logical(b->batCacheid)); 
			BBPreclaim(bn);
		}
	}
	return GDK_FAIL;
}
@}
@}
