# the following example script will do each operation in the
# arith module. it can be used for testing.

module("arith");

setoid(oid(20000000));
var sht1 := sht(2);
var sht2 := sht(5);
var int1 := 5;
var int2 := 2;
var flt1 := 2.5;
var flt2 := 5.4;
var dbl1 := dbl(-2.500001);	 # may also need string since float is default
var dbl2 := dbl(54.00456789);      # real and is less significant	
var lng1 := lng("-9000000000000"); # string needed because lng doesn't fit in an
var lng2 := lng("5400456789");     # int
var oid1 := oid(int1);
var oid2 := oid(int2);

sht1.print();
sht2.print();
int1.print();
int2.print();
flt1.print();
flt2.print();
dbl1.print();
dbl2.print();
lng1.print();
lng2.print();
oid1.print();
oid2.print();

# DD/Bug 6389: (i%0) should return nil instead of crashing the server
CATCH((chr(1)%int(0))).print();
CATCH((sht(1)%int(0))).print();
CATCH((int(1)%sht(0))).print();
CATCH((int(1)%chr(0))).print();
CATCH((int(1)%int(0))).print();
CATCH((lng(1)%int(0))).print();
CATCH((dbl(1)%dbl(0))).print();
CATCH((flt(1)%flt(0))).print();

('a' < 'z').print();  ('z' < 'a').print();  ('a' < 'a').print();
('a' <= 'z').print(); ('z' <= 'a').print(); ('a' <= 'a').print();
('a' = 'z').print();  ('z' = 'a').print();  ('a' = 'a').print();
('a' >= 'z').print(); ('z' >= 'a').print(); ('a' >= 'a').print();
('a' > 'z').print();  ('z' > 'a').print();  ('a' > 'a').print();

(sht1 < sht2).print();  (sht2 < sht1).print();  (sht1 < sht1).print();
(sht1 <= sht2).print(); (sht2 <= sht1).print(); (sht1 <= sht1).print();
(sht1 = sht2).print();  (sht2 = sht1).print();  (sht1 = sht1).print();
(sht1 >= sht2).print(); (sht2 >= sht1).print(); (sht1 >= sht1).print();
(sht1 > sht2).print();  (sht2 > sht1).print();  (sht1 > sht1).print();

(int1 < int2).print();  (int2 < int1).print();  (int1 < int1).print();
(int1 <= int2).print(); (int2 <= int1).print(); (int1 <= int1).print();
(int1 = int2).print();  (int2 = int1).print();  (int1 = int1).print();
(int1 >= int2).print(); (int2 >= int1).print(); (int1 >= int1).print();
(int1 > int2).print();  (int2 > int1).print();  (int1 > int1).print();

(flt1 < flt2).print();  (flt2 < flt1).print();  (flt1 < flt1).print();
(flt1 <= flt2).print(); (flt2 <= flt1).print(); (flt1 <= flt1).print();
(flt1 = flt2).print();  (flt2 = flt1).print();  (flt1 = flt1).print();
(flt1 >= flt2).print(); (flt2 >= flt1).print(); (flt1 >= flt1).print();
(flt1 > flt2).print();  (flt2 > flt1).print();  (flt1 > flt1).print();

(dbl1 < dbl2).print();  (dbl2 < dbl1).print();  (dbl1 < dbl1).print();
(dbl1 <= dbl2).print(); (dbl2 <= dbl1).print(); (dbl1 <= dbl1).print();
(dbl1 = dbl2).print();  (dbl2 = dbl1).print();  (dbl1 = dbl1).print();
(dbl1 >= dbl2).print(); (dbl2 >= dbl1).print(); (dbl1 >= dbl1).print();
(dbl1 > dbl2).print();  (dbl2 > dbl1).print();  (dbl1 > dbl1).print();

(lng1 < lng2).print();  (lng2 < lng1).print();  (lng1 < lng1).print();
(lng1 <= lng2).print(); (lng2 <= lng1).print(); (lng1 <= lng1).print();
(lng1 = lng2).print();  (lng2 = lng1).print();  (lng1 = lng1).print();
(lng1 >= lng2).print(); (lng2 >= lng1).print(); (lng1 >= lng1).print();
(lng1 > lng2).print();  (lng2 > lng1).print();  (lng1 > lng1).print();

(oid1 < oid2).print();  (oid2 < oid1).print();  (oid1 < oid1).print();
(oid1 <= oid2).print(); (oid2 <= oid1).print(); (oid1 <= oid1).print();
(oid1 = oid2).print();  (oid2 = oid1).print();  (oid1 = oid1).print();
(oid1 >= oid2).print(); (oid2 >= oid1).print(); (oid1 >= oid1).print();
(oid1 > oid2).print();  (oid2 > oid1).print();  (oid1 > oid1).print();

("abcde" < "abcdf").print();  ("abcdf" < "abcde").print();  ("abcde" < "abcde").print();
("abcde" <= "abcdf").print(); ("abcdf" <= "abcde").print(); ("abcde" <= "abcde").print();
("abcde" = "abcdf").print();  ("abcdf" = "abcde").print();  ("abcde" = "abcde").print();
("abcde" >= "abcdf").print(); ("abcdf" >= "abcde").print(); ("abcde" >= "abcde").print();
("abcde" > "abcdf").print();  ("abcdf" > "abcde").print();  ("abcde" > "abcde").print();

const EPSILON := 0.00001;

proc check(str op, any res): void
{
    var r;
    eval("r := " + op + ";");
    if (type(r) != type(res)) {
        printf("operation \"%s\" yields unexpected type\n", op);
    }
    if (type(r) = flt) {
        if ((res = 0.0) and (abs(r) > EPSILON) or ((res != 0.0) and (abs(r - res) / res) > EPSILON)) {
            printf("operation \"%s\" yields unexpected value\n", op);
            print(r); print(res);
        }
    } else if (type(r) = dbl) {
        if ((res = 0.0LL) and (abs(r) > dbl(EPSILON)) or ((res != 0.0LL) and (abs(r - res) / res) > dbl(EPSILON))) {
            printf("operation \"%s\" yields unexpected value\n", op);
            print(r); print(res);
        }
    } else if (r != res) {
        printf("operation \"%s\" yields unexpected value\n", op);
        print(r); print(res);
    }
}

check("sht1 + sht2", sht(7));
check("sht1 - sht2", sht(-3));
check("sht1 * sht2", sht(10));
check("sht1 / sht2", sht(0));
check("sht1 % sht2", sht(2));

check("sht1 + int2", 4);
check("sht1 - int2", 0);
check("sht1 * int2", 4);
check("sht1 / int2", 1);
check("sht1 % int2", 0);

check("sht1 + flt2", 7.4);
check("sht1 - flt2", -3.4);
check("sht1 * flt2", 10.8);
check("sht1 / flt2", 0.37037037037037037);
check("sht1 % flt2", 2.0);

check("sht1 + dbl2", 56.00456789LL);
check("sht1 - dbl2", -52.00456789LL);
check("sht1 * dbl2", 108.00913578LL);
check("sht1 / dbl2", 0.037033904318496347LL);
check("sht1 % dbl2", 2.0LL);

check("sht1 + lng2", 5400456791LL);
check("sht1 - lng2", -5400456787LL);
check("sht1 * lng2", 10800913578LL);
check("sht1 / lng2", 0LL);
check("sht1 % lng2", 2LL);

check("int1 + sht2", 10);
check("int1 - sht2", 0);
check("int1 * sht2", 25);
check("int1 / sht2", 1);
check("int1 % sht2", sht(0));

check("int1 + int2", 7);
check("int1 - int2", 3);
check("int1 * int2", 10);
check("int1 / int2", 2);
check("int1 % int2", 1);

check("int1 + flt2", 10.4);
check("int1 - flt2", -0.4);
check("int1 * flt2", 27.0);
check("int1 / flt2", 0.92592592592592593);
check("int1 % flt2", 5.0);

check("int1 + dbl2", 59.00456789LL);
check("int1 - dbl2", -49.00456789LL);
check("int1 * dbl2", 270.02283945LL);
check("int1 / dbl2", 0.092584760796240867LL);
check("int1 % dbl2", 5.0LL);

check("int1 + lng2", 5400456794LL);
check("int1 - lng2", -5400456784LL);
check("int1 * lng2", 27002283945LL);
check("int1 / lng2", 0LL);
check("int1 % lng2", 5LL);

check("flt1 + sht2", 7.5);
check("flt1 - sht2", -2.5);
check("flt1 * sht2", 12.5);
check("flt1 / sht2", 0.5);
check("flt1 % sht2", 2.5);

check("flt1 + int2", 4.5);
check("flt1 - int2", 0.5);
check("flt1 * int2", 5.0);
check("flt1 / int2", 1.25);
check("flt1 % int2", 0.5);

check("flt1 + flt2", 7.9);
check("flt1 - flt2", -2.9);
check("flt1 * flt2", 13.5);
check("flt1 / flt2", 0.46296296296296297);
check("flt1 % flt2", 2.5);

check("flt1 + dbl2", 56.50456789LL);
check("flt1 - dbl2", -51.50456789LL);
check("flt1 * dbl2", 135.011419725LL);
check("flt1 / dbl2", 0.046292380398120433LL);
check("flt1 % dbl2", 2.5LL);

check("flt1 + lng2", 5400456791.5);
check("flt1 - lng2", -5400456786.5);
check("flt1 * lng2", 13501141972.5);
check("flt1 / lng2", 0.00000000046292380398120433);
check("flt1 % lng2", 2.5);

check("dbl1 + sht2", 2.499999LL);
check("dbl1 - sht2", -7.500001LL);
check("dbl1 * sht2", -12.500005LL);
check("dbl1 / sht2", -0.5000002LL);
check("dbl1 % sht2", -2.500001LL);

check("dbl1 + int2", -0.500001LL);
check("dbl1 - int2", -4.500001LL);
check("dbl1 * int2", -5.000002LL);
check("dbl1 / int2", -1.2500005LL);
check("dbl1 % int2", -0.500001LL);

check("dbl1 + flt2", 2.899999LL);
check("dbl1 - flt2", -7.900001LL);
check("dbl1 * flt2", -13.5000054LL);
check("dbl1 / flt2", -0.46296314814814815LL);
check("dbl1 % flt2", -2.500001LL);

check("dbl1 + dbl2", 51.50456689LL);
check("dbl1 - dbl2", -56.50456889LL);
check("dbl1 * dbl2", -135.01147372956789LL);
check("dbl1 / dbl2", -0.046292398915072593LL);
check("dbl1 % dbl2", -2.500001LL);

check("dbl1 + lng2", 5400456786.499999LL);
check("dbl1 - lng2", -5400456791.500001LL);
check("dbl1 * lng2", -13501147372.956789LL);
check("dbl1 / lng2", -0.00000000046292398915072589LL);
check("dbl1 % lng2", -2.500001LL);

check("lng1 + sht2", -8999999999995LL);
check("lng1 - sht2", -9000000000005LL);
check("lng1 * sht2", -45000000000000LL);
check("lng1 / sht2", -1800000000000LL);
check("lng1 % sht2", sht(0));

check("lng1 + int2", -8999999999998LL);
check("lng1 - int2", -9000000000002LL);
check("lng1 * int2", -18000000000000LL);
check("lng1 / int2", -4500000000000LL);
check("lng1 % int2", 0);

check("lng1 + flt2", -8999999999994.6LL);
check("lng1 - flt2", -9000000000005.4LL);
check("lng1 * flt2", -48600000000000.0LL);
check("lng1 / flt2", -1666666666666.6667LL);
# don't test this: due to rounding errors, the actual result is wildly inaccurate
# check("lng1 % flt2", -3.6);

check("lng1 + dbl2", -8999999999945.99543211LL);
check("lng1 - dbl2", -9000000000054.00456789LL);
check("lng1 * dbl2", -486041111010000.0LL);
check("lng1 / dbl2", -166652569433.23355LL);
# don't test this: due to rounding errors, the actual result is wildly inaccurate
# check("lng1 % dbl2", -12.61269363);

check("lng1 + lng2", -8994599543211LL);
check("lng1 - lng2", -9005400456789LL);
check("lng1 * lng2", 3059533224668508160LL); # overflow from -48604111101000000000000
check("lng1 / lng2", -1666LL);
check("lng1 % lng2", -2838989526LL);

abs(sht2).print();
abs(int2).print();
abs(flt2).print();
abs(dbl2).print();
abs(lng2).print();

max(sht1,sht2).print();
max(int1,int2).print();
max(flt1,flt2).print();
max(dbl1,dbl2).print();
max(lng1,lng2).print();

min(sht1,sht2).print();
min(int1,int2).print();
min(flt1,flt2).print();
min(dbl1,dbl2).print();
min(lng1,lng2).print();

max(oid1,oid2).print();
min(oid1,oid2).print();

inv(flt2).print();
inv(dbl2).print();

(int1<<int2).print();
(int1>>int2).print();

(int1 or  int2).print();
(int1 and int2).print();
(int1 xor int2).print();
not(int2).print();

var bit1 := true;
var bit2 := false;
(bit1 or  bit2).print();
(bit1 and bit2).print();
(bit1 xor bit2).print();
not(bit2).print();

quit();
