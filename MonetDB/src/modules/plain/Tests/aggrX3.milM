module("aggrX3");

proc toset(bat[any,any] b) : str {
        var res := "{ ";
        b@batloop() {
		if (isnil($t)) {
			res :+= "nil ";
		} else {
	                res :+= str($t) + " ";
		}
        }
        return res + "}";
}

proc aggrtst(int num, int fanout, str agg, ..str..) : void {
	var gagg := sprintf("{%s}",agg);
	var p := 3;
	while((p :+= 1) <= $0) {
	        var b, e, v := bat(void, int, num);
	        var tpe := $(p);
	        var i := 0;
	        while(i <= num) {
	                v.insert(nil, 42);
	                i :+= 1;
	        }
	        e := [oid](v.seqbase(0@0).reverse()).reverse();
	        if (fanout = 1) {
	                b := bat(void,(*tpe)()).seqbase(0@0);
	        } else {
	                b := bat(oid,(*tpe)());
	        }
	        var n := 0; 
	        e@batloop() {
		   if (int($h) < num) {
	                i := 0; 
	                while(i < fanout) {
	                        if  (n = 0) {
	                                b.insert($h, (*tpe)(-1));
	                        } else if  (($h = oid(num/2)) and (i = (fanout/2))) {
	                                b.insert($h, (*tpe)(nil));
	                        } else if (($h = oid(num - 1)) and (i = (fanout - 1))) {
	                                b.insert($h, (*tpe)(0));
	                        } else {
	                                b.insert($h, (*tpe)(n));
                        	} 
                        	n :+= 1; i :+= 1;
                	}
		    }
                }
		var gg := b.mark(0@0).reverse();
		var bb := b.reverse().mark(0@0).reverse();
		var bs := {toset}(b).col_name("test-set "+tail(b));
		var ab   := (*gagg)(b).col_name(sprintf("%s(b)",gagg));
		var abv  := (*gagg)(b,v).col_name(sprintf("%s(b,v)",gagg));
		var abe  := (*gagg)(b,e).col_name(sprintf("%s(b,e)",gagg));
		var abgv := (*gagg)(bb,gg,v).col_name(sprintf("%s(bb,gg,v)",gagg));
		var abge := (*gagg)(bb,gg,e).col_name(sprintf("%s(bb,gg,e)",gagg));
		if (not(printed)) {
			v.print();
			e.print();
			var bh := b.mark(0@0).reverse();
			var bt := b.reverse().mark(0@0).reverse();
			print(bh,bt,bt.[bte](),bt.[sht](),bt.[int](),bt.[wrd](),bt.[lng](),bt.[flt](),bt.[dbl](),[decimal]([int](bt)),bt.[str]());
			printed := TRUE;
		}
		var tpe2 := tail(ab);
		ab.access(BAT_WRITE).insert(oid(num),(*agg)(b.reverse().select(oid(num)).reverse()));
		bs.access(BAT_WRITE).insert(oid(num),"{  }");
        	print(bs,
        	      ab  , ab.[str]()  ,
        	      abv , abv.[str]() ,
        	      abe , abe.[str]() ,
        	      abgv, abgv.[str](),
        	      abge, abge.[str]());
        }
}

module("decimal");
var printed := FALSE;
aggrtst(5,9,"sum","bte","sht","int","wrd","lng","flt","dbl");
aggrtst(5,9,"sum_lng","bte","sht","int","wrd","lng");
aggrtst(5,9,"sum_dbl","flt","dbl");
aggrtst(5,9,"prod","bte","sht","int","wrd","lng","flt","dbl");
aggrtst(5,9,"prod_lng","bte","sht","int","wrd","lng");
aggrtst(5,9,"prod_dbl","flt","dbl");
aggrtst(5,9,"avg","bte","sht","int","wrd","lng","flt","dbl");
aggrtst(5,9,"min","bte","sht","int","wrd","lng","flt","dbl","decimal");
aggrtst(5,9,"max","bte","sht","int","wrd","lng","flt","dbl","decimal");
aggrtst(5,9,"count","bte","sht","int","wrd","lng","flt","dbl","decimal");
aggrtst(5,9,"count_no_nil","bte","sht","int","wrd","lng","flt","dbl","decimal");
aggrtst(5,9,"card","bte","sht","int","wrd","lng","flt","dbl","decimal");
quit();
