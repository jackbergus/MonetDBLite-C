@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2006 CWI.
@' All Rights Reserved.

@f bat_arith
@t Optimized Multiplexed Basic Arithmetics on BATs
@a S. Manegold, N. Nes
@v 1.0
@* Introduction

This module provides optimized code-expanded implementations of multiplexed
basic arithmetics ([+],[-],[*],[/],[%]) on void-headed, head-aligned BATs.
Only the standard types sht, int, lng, flt, dbl are supported.

@* Module Definition
@m
.MODULE bat_arith;

@T
\begin{verbatim}
	signatures
	@1:	sht, int, lng, flt, dbl arithmetic type
	@2:	+,   -,  *,   /,   %   basic arithmetic operator
	@3:	add, sub, mul, div, mod basic arithmetic operator name
\end{verbatim}
@= signatures
.OPERATOR@4 (BAT[void,@1]) "[@2]" (BAT[void,@1]) : BAT[void,@1] = batbat_@1_@3;
	"optimized multiplexed @3 ('@2') on head-aligned [void,@1] BATs"
.OPERATOR@4 (@1) "[@2]" (BAT[void,@1]) : BAT[void,@1] = valbat_@1_@3;
	"optimized multiplexed left-scalar @3 ('@2') on [void,@1] BAT"
.OPERATOR@4 (BAT[void,@1]) "[@2]" (@1) : BAT[void,@1] = batval_@1_@3;
	"optimized multiplexed right-scalar @3 ('@2') on [void,@1] BAT"
.OPERATOR@4 (BAT[void,@1]) "[:@2=]" (BAT[void,@1]) : BAT[void,@1] = batbat_@1_@3_inplace;
	"optimized multiplexed in-place @3 (':@2=') on head-aligned [void,@1] BATs (overwrites first operand)"
.OPERATOR@4 (@1) "[:@2=]" (BAT[void,@1]) : BAT[void,@1] = valbat_@1_@3_inplace;
	"optimized multiplexed left-scalar in-place @3 (':@2=') on [void,@1] BAT (overwrites second operand)"
.OPERATOR@4 (BAT[void,@1]) "[:@2=]" (@1) : BAT[void,@1] = batval_@1_@3_inplace;
	"optimized multiplexed right-scalar in-place @3 (':@2=') on [void,@1] BAT (overwrites first operand)"
@m
@:signatures(sht,+,add)@
@:signatures(sht,-,sub)@
@:signatures(sht,*,mul,1)@
@:signatures(sht,/,div,1)@
@:signatures(sht,%,mod,1)@
@:signatures(int,+,add)@
@:signatures(int,-,sub)@
@:signatures(int,*,mul,1)@
@:signatures(int,/,div,1)@
@:signatures(int,%,mod,1)@
@:signatures(lng,+,add)@
@:signatures(lng,-,sub)@
@:signatures(lng,*,mul,1)@
@:signatures(lng,/,div,1)@
@:signatures(lng,%,mod,1)@
@:signatures(flt,+,add)@
@:signatures(flt,-,sub)@
@:signatures(flt,*,mul,1)@
@:signatures(flt,/,div,1)@
@:signatures(dbl,+,add)@
@:signatures(dbl,-,sub)@
@:signatures(dbl,*,mul,1)@
@:signatures(dbl,/,div,1)@

.END bat_arith;

@* Implementation
@c
#include <gdk.h>
#include <gdk_scanselect.h>	/* for type-specific HT_bunfastins_nocheck_noinc(), until they're moved to gdk.mx */
#include "bat_arith.proto.h"

@c
/*	implementation
	@1:	sht, int, lng, flt, dbl arithmetic type
	@2:	+,   -,   *,   /,   %   basic arithmetic operator
	@3:	add, sub, mul, div, mod basic arithmetic operator name
	@4:		0 / 1		disable/enable division by zero check
	@5:		0 / 1 / 2	disable/enable sorting propagation
					1 propagate on bat,const
					2 propagate also on const,bat
*/
@= implementations
int
batbat_@1_@3(BAT **ret, BAT *l, BAT *r)
{
	REGISTER @1 *bnp;
	BAT *bn;

	ALGODEBUG THRprintf(GDKout, "batbat_@1_@3[@2,@4](l=%s,r=%s);\n",
		BATgetId(l),BATgetId(r));
	ERRORcheck((l->htype!=TYPE_void)||(r->htype!=TYPE_void)||(l->hseqbase!=r->hseqbase)||(BATcount(l)!=BATcount(r)),
		   "batbat_@1_@3: BATs l & r must be void-headed and head-aligned.\n");

	bn = BATnew(TYPE_void, l->ttype, BATcount(l));
	if (bn == NULL)
		return GDK_FAIL;
	BATseqbase(bn,l->hseqbase);
	bn->tsorted = 0;

	if ((BUNsize(l)==sizeof(@1))&&(BUNsize(r)==sizeof(@1))) {
		REGISTER @1 *lp, *lq, *rp;
		REGISTER int cnt = 4096/(int)sizeof(@1);
		@1* lbuf = GDKmalloc(2*cnt*sizeof(@1));
		@1* rbuf = lbuf+cnt;

		lq = (@1*)BUNtloc(l,BUNlast(l));
		lp = (@1*)BUNtloc(l,BUNfirst(l));
		rp = (@1*)BUNtloc(r,BUNfirst(r));
		bnp = (@1*)BUNtloc(bn,BUNlast(bn));
		for (; lp < lq; lp+=cnt, rp+=cnt) {
			/* 0 <= cnt <= 4096, so cast to int is safe */
			REGISTER int x = (int) (lq - lp < cnt ? lq - lp : cnt);
			REGISTER int y = x*(int)sizeof(@1);
			REGISTER int i;
			memcpy(lbuf,lp,y);
			memcpy(rbuf,rp,y);
			for (i=0; i<x; i++) {
				if (@4 && (rbuf[i] == 0)) {
					GDKerror("[@2] (batbat_@1_@3): Division by Zero!");
					GDKfree(lbuf);
					BBPreclaim(bn);
					return GDK_FAIL;
				} else if ((lbuf[i] != @1_nil) && (rbuf[i] != @1_nil)) {
					*bnp = lbuf[i] @2 rbuf[i];
				} else {
					*bnp = @1_nil;
				}
				bnp++;
			}
		}
		GDKfree(lbuf);
	} else if ((BUNsize(l)==BUNsize(r))) {
		REGISTER chr *lp, *lq, *rp;
		REGISTER int bs = BUNsize(l);
		REGISTER int sze = (4096/bs)*bs;
		chr* lbuf = GDKmalloc(2*sze);
		chr* rbuf = lbuf+sze;

		lq = (chr*)BUNtloc(l,BUNlast(l));
		lp = (chr*)BUNtloc(l,BUNfirst(l));
		rp = (chr*)BUNtloc(r,BUNfirst(r));
		bnp = (@1*)BUNtloc(bn,BUNlast(bn));
		for (; lp < lq; lp+=sze, rp+=sze) {
			/* 0 <= sze <= 4096, so cast to int is safe */
			REGISTER int z = (int) (lq - lp < sze ? lq - lp : sze);
			REGISTER chr *lbp=lbuf, *lbq=lbuf+z, *rbp=rbuf;
			memcpy(lbuf,lp,z);
			memcpy(rbuf,rp,z);
			for (; lbp < lbq; lbp+=bs, rbp+=bs) {
				if (@4 && (*(@1*)rbp == 0)) {
					GDKerror("[@2] (batbat_@1_@3): Division by Zero!");
					GDKfree(lbuf);
					BBPreclaim(bn);
					return GDK_FAIL;
				} else if ((*(@1*)lbp != @1_nil) && (*(@1*)rbp != @1_nil)) {
					*bnp = *(@1*)lbp @2 *(@1*)rbp;
				} else {
					*bnp = @1_nil;
				}
				bnp++;
			}
		}
		GDKfree(lbuf);
	} else {
		REGISTER chr *lp, *lq, *rp;
		REGISTER int ls = BUNsize(l);
		REGISTER int rs = BUNsize(r);

		lq = (chr*)BUNtloc(l,BUNlast(l));
		lp = (chr*)BUNtloc(l,BUNfirst(l));
		rp = (chr*)BUNtloc(r,BUNfirst(r));
		bnp = (@1*)BUNtloc(bn,BUNlast(bn));
		for (; lp < lq; lp+=ls, rp+=rs) {
			if (@4 && (*(@1*)rp == 0)) {
                                GDKerror("[@2] (batbat_@1_@3): Division by Zero!");
                                BBPreclaim(bn);
                                return GDK_FAIL;
			} else if ((*(@1*)lp != @1_nil) && (*(@1*)rp != @1_nil)) {
				*bnp = *(@1*)lp @2 *(@1*)rp;
			} else {
				*bnp = @1_nil;
			}
			bnp++;
		}
	}

	bn->batBuns->free = (BUN)bnp - bn->batBuns->base;
	BATsetcount(bn, bn->batBuns->free/BUNsize(bn));
	if (!bn->batDirty) bn->batDirty = TRUE;

	*ret = bn;
	return GDK_SUCCEED;
}
int
batbat_@1_@3_inplace(BAT **ret, BAT *l, BAT *r)
{
	REGISTER chr *lp, *lq, *rp;
	REGISTER int ls = BUNsize(l);
	REGISTER int rs = BUNsize(r);

	ALGODEBUG THRprintf(GDKout, "batbat_@1_@3_inplace[@2,@4](l=%s,r=%s);\n",
		BATgetId(l),BATgetId(r));
	ERRORcheck((l->htype!=TYPE_void)||(r->htype!=TYPE_void)||(l->hseqbase!=r->hseqbase)||(BATcount(l)!=BATcount(r)),
		   "batbat_@1_@3_inplace: BATs l & r must be void-headed and head-aligned.\n");

	l->tsorted = 0;
	lq = (chr*)BUNtloc(l,BUNlast(l));
	lp = (chr*)BUNtloc(l,BUNfirst(l));
	rp = (chr*)BUNtloc(r,BUNfirst(r));
	for (; lp < lq; lp+=ls, rp+=rs) {
		if (@4 && (*(@1*)rp == 0)) {
                        GDKerror("[:@2=] (batbat_@1_@3_inplace): Division by Zero!");
                        return GDK_FAIL;
		} else if ((*(@1*)lp != @1_nil) && (*(@1*)rp != @1_nil)) {
			*(@1*)lp @2= *(@1*)rp;
		} else {
			*(@1*)lp = @1_nil;
		}
	}
	if (!l->batDirty) l->batDirty = TRUE;

	BBPfix(l->batCacheid);
	*ret = l;
	return GDK_SUCCEED;
}
int
valbat_@1_@3(BAT **ret, @1 *v, BAT *b)
{
	REGISTER chr *bp, *bq;
	REGISTER @1 *bnp;
	REGISTER @1 vv = (((*v)!=@1_nil)?(*v):@1_nil);
	REGISTER int bs = BUNsize(b);
	BAT *bn;

	ALGODEBUG THRprintf(GDKout, "valbat_@1_@3[@2,@4](v,b=%s);\n",BATgetId(b));
	ERRORcheck((b->htype!=TYPE_void),
		   "valbat_@1_@3: BAT b must be void-headed.\n");
	/* todo for commutative operators call batval (ie. for *, + and - ) */

	bn = BATnew(TYPE_void, b->ttype, BATcount(b));
	if (bn == NULL)
		 return GDK_FAIL;
	BATseqbase(bn,b->hseqbase);
	bn->tsorted = 0;
	bq = (chr*)BUNtloc(b,BUNlast(b));
	bp = (chr*)BUNtloc(b,BUNfirst(b));
	bnp = (@1*)BUNtloc(bn,BUNlast(bn));
	if (vv != @1_nil) {
		for (; bp < bq; bp+=bs) {
			REGISTER @1 bv = *(@1*)bp;
			if (@4 && (bv == 0)) {
                                GDKerror("[@2] (valbat_@1_@3): Division by Zero!");
                                BBPreclaim(bn);
                                return GDK_FAIL;
			} else if (bv != @1_nil) {
				bv = vv @2 bv;
			}
			*bnp = bv;
			bnp++;
		}
	} else {
		for (; bp < bq; bp+=bs) {
			*bnp = vv;
			bnp++;
		}
	}
	bn->batBuns->free = (BUN)bnp - bn->batBuns->base;
	BATsetcount(bn, bn->batBuns->free/BUNsize(bn));
	if (!bn->batDirty) bn->batDirty = TRUE;

	if (@5 == 2) 
		bn->tsorted = BATtordered(b);

	*ret = bn;
	return GDK_SUCCEED;
}
int valbat_@1_@3_inplace(BAT **ret, @1 *v, BAT *b) {
	REGISTER chr *bp, *bq;
	REGISTER @1 vv = (((*v)!=@1_nil)?(*v):@1_nil);
	REGISTER int bs = BUNsize(b);

	ALGODEBUG THRprintf(GDKout, "valbat_@1_@3_inplace[@2,@4](v,b=%s);\n",BATgetId(b));
	ERRORcheck((b->htype!=TYPE_void),
		   "valbat_@1_@3_inplace: BAT b must be void-headed.\n");
	/* todo for commutative operators call batval (ie. for * and /) */

	b->tsorted = 0;
	bq = (chr*)BUNtloc(b,BUNlast(b));
	bp = (chr*)BUNtloc(b,BUNfirst(b));
	if (vv != @1_nil) {
		for (; bp < bq; bp+=bs) {
			if (@4 && (*(@1*)bp == 0)) {
                                GDKerror("[:@2=] (valbat_@1_@3_inplace): Division by Zero!");
                                return GDK_FAIL;
			} else if (*(@1*)bp != @1_nil) {
				*(@1*)bp = vv @2 *(@1*)bp;
			}
		}
	} else {
		for (; bp < bq; bp+=bs) {
			*(@1*)bp = vv;
		}
	}
	if (!b->batDirty) b->batDirty = TRUE;

	if (@5 == 2) 
		b->tsorted = BATtordered(b);

	BBPfix(b->batCacheid);
	*ret = b;
	return GDK_SUCCEED;
}
int
batval_@1_@3(BAT **ret, BAT *b, @1 *v)
{
	REGISTER chr *bp, *bq;
	REGISTER @1 *bnp;
	REGISTER @1 vv = (((*v)!=@1_nil)?(*v):@1_nil);
	REGISTER int bs = BUNsize(b);
	BAT *bn;

	ALGODEBUG THRprintf(GDKout, "batval_@1_@3[@2,@4](v,b=%s);\n",BATgetId(b));
	ERRORcheck((b->htype!=TYPE_void),
		   "batval_@1_@3: BAT b must be void-headed.\n");

	bn = BATnew(TYPE_void, b->ttype, BATcount(b));
	if( bn == NULL)
		return GDK_FAIL;
	BATseqbase(bn,b->hseqbase);
	bn->tsorted = 0;
	bq = (chr*)BUNtloc(b,BUNlast(b));
	bp = (chr*)BUNtloc(b,BUNfirst(b));
	bnp = (@1*)BUNtloc(bn,BUNlast(bn));
	if (@4 && (vv == 0)) {
                GDKerror("[@2] (batval_@1_@3): Division by Zero!");
                BBPreclaim(bn);
                return GDK_FAIL;
	} else if (vv != @1_nil) {
		for (; bp < bq; bp+=bs) {
			REGISTER @1 bv = *(@1*)bp;
			if (bv != @1_nil) {
				bv @2= vv;
			}
			*bnp = bv;
			bnp++;
		}
	} else {
		for (; bp < bq; bp+=bs) {
			*bnp = vv;
			bnp++;
		}
	}
	bn->batBuns->free = (BUN)bnp - bn->batBuns->base;
	BATsetcount(bn, bn->batBuns->free/BUNsize(bn));
	if (!bn->batDirty) bn->batDirty = TRUE;
	if (@5) 
		bn->tsorted = BATtordered(b);

	*ret = bn;
	return GDK_SUCCEED;
}
int
batval_@1_@3_inplace(BAT **ret, BAT *b, @1 *v)
{
	REGISTER chr *bp, *bq;
	REGISTER @1 vv = (((*v)!=@1_nil)?(*v):@1_nil);
	REGISTER int bs = BUNsize(b);

	ALGODEBUG THRprintf(GDKout, "batval_@1_@3_inplace[@2,@4](v,b=%s);\n",BATgetId(b));
	ERRORcheck((b->htype!=TYPE_void),
		   "batval_@1_@3_inplace: BAT b must be void-headed.\n");

	b->tsorted = 0;
	bq = (chr*)BUNtloc(b,BUNlast(b));
	bp = (chr*)BUNtloc(b,BUNfirst(b));
	if (@4 && (vv == 0)) {
                GDKerror("[:@2=] (batval_@1_@3_inplace): Division by Zero!");
                return GDK_FAIL;
	} else if (vv != @1_nil) {
		for (; bp < bq; bp+=bs) {
			if (*(@1*)bp != @1_nil) {
				*(@1*)bp @2= vv;
			}
		}
	} else {
		for (; bp < bq; bp+=bs) {
			*(@1*)bp = vv;
		}
	}
	if (!b->batDirty) b->batDirty = TRUE;
	if (@5) 
		b->tsorted = BATtordered(b);

	BBPfix(b->batCacheid);
	*ret = b;
	return GDK_SUCCEED;
}
@c
@:implementations(sht,+,add,0,2)@
@:implementations(sht,-,sub,0,2)@
@:implementations(sht,*,mul,0,2)@
@:implementations(sht,/,div,1,1)@
@:implementations(sht,%,mod,1,0)@
@:implementations(int,+,add,0,2)@
@:implementations(int,-,sub,0,2)@
@:implementations(int,*,mul,0,2)@
@:implementations(int,/,div,1,1)@
@:implementations(int,%,mod,1,0)@
@:implementations(lng,+,add,0,2)@
@:implementations(lng,-,sub,0,2)@
@:implementations(lng,*,mul,0,2)@
@:implementations(lng,/,div,1,1)@
@:implementations(lng,%,mod,1,0)@
@:implementations(flt,+,add,0,2)@
@:implementations(flt,-,sub,0,2)@
@:implementations(flt,*,mul,0,2)@
@:implementations(flt,/,div,1,1)@
@:implementations(dbl,+,add,0,2)@
@:implementations(dbl,-,sub,0,2)@
@:implementations(dbl,*,mul,0,2)@
@:implementations(dbl,/,div,1,1)@
