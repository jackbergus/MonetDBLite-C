@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2006 CWI.
@' All Rights Reserved.

@f lock
@t Lightweight Lock Module
@v 1.0
@a Peter Boncz
@* Introduction
This module provides simple SMP lock and thread functionality
as already present in the Monet system.

@* MEL Definitions
@m
.MODULE lock;

@- lock
@m
.ATOM lock = PTR;
.END;

.COMMAND lock_create() : lock = create_lock;
	"create an unset lock"
.COMMAND lock_set(lock) = set_lock;
	"try to set a lock; if set, block till it is freed"
.COMMAND lock_try(lock) : int = try_lock;
	"try a lock, if free set it and return 0, if not return EBUSY"
.COMMAND lock_unset(lock) = unset_lock;
	"unset a lock"
.COMMAND lock_destroy(lock) = destroy_lock;
	"destroy a lock"

@- semaphores
@m
.ATOM sema = PTR;
.END;

.COMMAND sema_create(int init) : sema = create_sema;
	"create an unset sema, with an initial value"
.COMMAND sema_down(sema) = down_sema;
	"decrease the semaphpore if >0; else block"
.COMMAND sema_up(sema) = up_sema;
	"increase the semaphore"
.COMMAND sema_destroy(sema) = destroy_sema;
	"destroy a sema"

.END lock;

@mil
	CONST EBUSY := 16;

@{
@* Implementation
@h
typedef ptr lock;
typedef ptr sema;
typedef ptr monet_lock;
typedef ptr monet_sema;
@c
#include <gdk.h>
#include "lock.h"

#include "lock.proto.h"

int
create_lock(monet_lock *l)
{
	*l = MT_create_lock();
	return GDK_SUCCEED;
}

int
set_lock(monet_lock *l)
{
	MT_set_lock((MT_Lock) *l, "set_lock");
	return GDK_SUCCEED;
}

int
try_lock(int *res, monet_lock *l)
{
	*res = MT_try_lock((MT_Lock) *l) ? EBUSY : 0;
	return GDK_SUCCEED;
}

int
unset_lock(monet_lock *l)
{
	MT_unset_lock((MT_Lock) *l, "unset_lock");
	return GDK_SUCCEED;
}

int
destroy_lock(monet_lock *l)
{
	MT_destroy_lock((MT_Lock) *l);
	return GDK_SUCCEED;
}

int
create_sema(monet_sema *s, int *init)
{
	*s = MT_create_sema(*init);
	return GDK_SUCCEED;
}

int
up_sema(monet_sema *s)
{
	MT_up_sema((MT_Sema) *s, "up_sema");
	return GDK_SUCCEED;
}

int
down_sema(monet_sema *s)
{
	MT_down_sema((MT_Sema) *s, "down_sema");
	return GDK_SUCCEED;
}

int
destroy_sema(monet_sema *s)
{
	MT_destroy_sema((MT_Sema) *s);
	return GDK_SUCCEED;
}

@}
