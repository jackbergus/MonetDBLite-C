@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2006 CWI.
@' All Rights Reserved.

@f ascii_io
@t The ASCII io Module
@a Niels Nes
@* Ascii io Module

@T
A database cannot live with out bulk load/store operations. The ASCII io
module can be used bulk load from an ASCII file or dump to one.
The file can plain ASCII, gzipped or bzipped, decided by the extension
(none, gz or bz2).

The load operation is for bulk loading a table, each column will be loaded
into its own bat. The arguments are void-aligned bats describing the
input, ie the name of the column, the tuple separator and the type.
The nr argument can be -1 (The input (datafile) is read until the end)
or a maximum.

The dump operation is for dumping a set of bats, which are aligned.
Again with void-aligned arguments, with name (currently not used),
tuple separator (the last is the record separator) and bat to be dumped.
With the nr argument the dump can be limited (-1 for unlimited).

The output operation is for ordered output. A bat (possibly form the collection)
gives the order. For each element in the order bat the values in the bats are
searched, if all are found they are output in the datafile, with the given
separators.

The scripts from the ascii_io.mil file are all there too for backward
compatibility with the old Mload format files.

The load_format loads the format file, since the old format file was
in a table format it can be loaded with the load command.

The result from load_format can be used with load_data to load the data
into a set of new bats.

These bats can be made persistent with the make_persistent script or
merge with existing bats with the merge_data script.

The dump_format scripts dump a format file for a given set of
to be dumped bats. These bats can be dumped with dump_data.

@d 12/01/2001
@m
.MODULE ascii_io;

.USE streams;

.COMMAND ascii_io_debug( int debug ) = init_ascii_io; ""

.COMMAND load( BAT[void,str] names, BAT[void,str] seps, BAT[void,str] types, str datafile, int nr ) : BAT[str,bat] = ascii_io_load; ""
.COMMAND input( BAT[void,str] names, BAT[void,str] seps, BAT[void,str] types, Stream s, int nr ) : BAT[str,bat] = ascii_io_input; ""
.COMMAND dump( BAT[void,str] names, BAT[void,str] seps, BAT[void,bat] bats, str datafile, int nr ) = ascii_io_dump; ""
.COMMAND output( BAT[any,any] order, BAT[void,str] seps, BAT[void,bat] bats, Stream s ) = ascii_io_output; ""

.END ascii_io;

@mil
proc load_format( str fmt ) : BAT[str,BAT] {
	var names := new(void,str); names.seqbase(oid(0));
	var seps := new(void,str); seps.seqbase(oid(0));
	var types := new(void,str); types.seqbase(oid(0));
	names.append("names");seps.append(",");types.append("str");
	names.append("seps");seps.append(",");types.append("str");
	names.append("types");seps.append("\n");types.append("str");
	return load(names, seps, types, fmt, 1000);
}
ADDHELP("load_format", "niels", "Jan 2005",
  "Load Mload-style format file fmt", "ascii_io");

proc load_data( BAT[str,BAT] fmt, str data, int nr ) : BAT[str,BAT] {
	var names := fmt.find("names");
	var seps := fmt.find("seps");
	var types := fmt.find("types");
	return load(names, seps, types, data, nr);
}
ADDHELP("load_data", "niels", "Jan 2005",
  "Load data given Mload-style format; limit to nr elements (all if -1)", "ascii_io");

proc make_persistent( BAT[str,BAT] bats ) : void {
	if (bats.exist("key")){
		var keybat := bats.find("key");
		var nbats := bats.diff(bats.reverse().select("key").reverse());
		nbats@batloop(){
			var b := keybat.reverse().join($t);
			b.rename($h);
			b.persists(true);
			if (b.count() > 1000000) {
				b.mmap(STORE_MMAP);
			}
		}
	} else {
		bats@batloop(){
			$t.rename($h);
			$t.persists(true);
			if ($t.count() > 1000000) {
				$t.mmap(STORE_MMAP);
			}
		}
	}
}
ADDHELP("make_persistent", "niels", "Jan 2005",
  "Make loaded bats persistent.", "ascii_io");

proc merge_data( BAT[str,BAT] bats ) : void {
	if (bats.exist("key")){
		var keybat := bats.find("key");
		var nbats := bats.diff(bats.reverse().select("key").reverse());
		nbats@batloop(){
			var b := keybat.reverse().join($t);
			var o := bat($h);
			var a := o.access();
			o.access(BAT_APPEND);
			o.append(b);
			o.access(a);
		}
	} else {
		bats@batloop(){
			var o := bat($h);
			var a := o.access();
			o.access(BAT_APPEND);
			o.append($t);
			o.access(a);
		}
	}
}
ADDHELP("merge_data", "niels", "Jan 2005",
  "Merge loaded bats with existing ones.", "ascii_io");

proc dump_seps( BAT[void,BAT] bats ) : BAT[void,str] {
	var seps := new(void,str); seps.seqbase(oid(0));
	var id := 0;
	var cnt := bats.count() - 1;
	bats@batloop(){
		if (id != cnt) {
			seps.append(",");
		} else {
			seps.append("\n");
		}
		id :+= 1;
	}
	return seps;
}

proc bat_ttype( bat b ) : str {
	return monet_atomtbl.reverse().find(b.ttype());
}

proc dump_format( BAT[void,BAT] bats, str fmt ) : BAT[str,BAT] {
	bats := bats.reverse().mark(oid(0)).reverse();
	var names := [bbpname](bats);
	var seps  := dump_seps(bats);
	var types := [bat_ttype](bats);
	var fmtbats:= new(void,bat); fmtbats.seqbase(oid(0));
	fmtbats.append(names);
	fmtbats.append(seps);
	fmtbats.append(types);

	names := new(void,str); names.seqbase(oid(0));
	seps := new(void,str); seps.seqbase(oid(0));
	names.append("names");seps.append(",");
	names.append("seps");seps.append(",");
	names.append("types");seps.append("\n");
	dump(names, seps, fmtbats, fmt, 1000);
	names.append("bats");
	fmtbats.append(bats);
	return names.reverse().join(fmtbats);
}

proc dump_data( BAT[str,BAT] fmt, str data, int cnt) : void {
	var names := fmt.find("names");
	var seps := fmt.find("seps");
	var bats;
	if (fmt.exist("bats")){
		bats := fmt.find("bats");
	} else {
		bats := [load](names);
	}
	dump( names, seps, bats, data, cnt );
}

proc dump_data( BAT[str,BAT] fmt, BAT[str,BAT] bats, str data, int cnt) : void {
	var names := fmt.find("names");
	var seps := fmt.find("seps");

	dump( names, seps, names.join(bats).reverse().mark().reverse(), data, cnt );
}

proc import( BAT[any,any] b, str filename ) : BAT[any,any] {

	var names := new(void,str).seqbase(0@0);
	names.append("head");
	names.append("tail");
	var seps := new(void,str).seqbase(0@0);
	seps.append(",");
	seps.append("\n");
	var types := new(void,str).seqbase(0@0);
	types.append(b.reverse().bat_ttype());
	types.append(b.bat_ttype());

	var bats := load( names, seps, types, filename, -1);
	b.insert (bats.find("head").reverse().join(bats.find("tail")));
	return b;
}

proc export( BAT[any,any] b, str filename ) : void {
	var hb := b.mark(0@0).reverse();
	var tb := b.reverse().mark(0@0).reverse();

	var names := new(void,str).seqbase(0@0);
	names.append("head");
	names.append("tail");
	var seps := new(void,str).seqbase(0@0);
	seps.append(",");
	seps.append("\n");
	var bats := new(void,bat).seqbase(0@0);
	bats.append(hb);
	bats.append(tb);

	dump( names, seps, bats, filename, b.count());
}

# todo add function to create a key (oid sequence) colom
@-
@{

@h
#ifndef _ASCII_IO2_H_
#define _ASCII_IO2_H_

#include <streams.h>
#include <ascii_io.proto.h>


typedef ptr *(*frStr) (void *extra, int type, char *s, char *e, char quote);
typedef int (*toStr) (void *extra, char **buf, int *len, int type, ptr a);

typedef struct ascii_io_t {
	char *name;
	char *sep;
	int seplen;
	char *type;
	int adt;
	BAT *c;
	BUN p;
	toStr tostr;
	frStr frstr;
	void *extra;
	void *data;
	int len;
} ascii_io;

typedef struct ascii_load_t {
	size_t offset;
	size_t nr;
	size_t nr_attrs;
	ascii_io *format;
} ascii;

extern BAT *ASCIIload(BAT *names, BAT *seps, BAT *types, char *datafile, size_t nr);
ascii_io_export BAT *ASCIIinput(BAT *names, BAT *seps, BAT *types, bstream *s, stream *out, size_t nr);
ascii_io_export size_t ASCIIoutput(BAT *order, BAT *seps, BAT *bats, stream *s);
extern void ASCIIdump(BAT *names, BAT *seps, BAT *bats, char *datafile, size_t nr);

@+ low level interface
@h
ascii_io_export int ASCIIcreate_bats(ascii *as);
ascii_io_export size_t ASCIIassign_BATs(ascii *as, BAT *bats);
ascii_io_export int ASCIIload_file(ascii *as, bstream *b, stream *out);
ascii_io_export BAT *ASCIIcollect_bats(ascii *as);
ascii_io_export void ASCIIdestroy_format(ascii *as);
ascii_io_export int ASCIIoutput_file(ascii *as, BAT *order, stream *s);

@+ Default from and to string functions
@h
ascii_io_export ptr *ASCIIstrFrStr(ascii_io* fmt, char *s, char *e);
ascii_io_export ptr *ASCIIadt_frStr(void *extra, int type, char *s, char *e, char quote);
ascii_io_export int ASCIIadt_toStr(void *extra, char **buf, int *len, int type, ptr a);

#endif
@c

#include <gdk.h>
#include "ascii_io.h"

#include <string.h>
#include <ctype.h>

static int ascii_io_debug = 0;

static ptr
bun_tail(BAT *b, size_t nr)
{
	REGISTER size_t _i = BUNindex((b), BUNfirst((b)));

	return (ptr) BUNtail(b, BUNptr(b, _i + nr));
}


static BAT *
void_bat_create(int adt, size_t nr)
{
	BAT *b = BATnew(TYPE_void, adt, nr);

	/* check for correct structures */
	if (b == NULL)
		return b;
	if (BATmirror(b))
		BATseqbase(b, 0);
	return b;
}

static char *
sep_dup(char *sep)
{
	size_t len = strlen(sep);
	char *res = GDKmalloc(len*2 + 1), *result = res;
	char *end = sep + len;

	while (sep < end) {
		if (*sep == '\\') {
			++sep;
			switch (*sep++) {
			case 'r':
				*res++ = '\r';
				break;
			case 'n':
				*res++ = '\n';
				break;
			case 't':
				*res++ = '\t';
				break;
			}
		} else {
			*res++ = *sep++;
		}
	}
	*res = '\0';
	return result;
}


ptr *
ASCIIstrFrStr(ascii_io *c, char *s, char *e)
{
	int len = e-s+1;

	if (c->len < len){
		c->len = len;
		c->data = GDKrealloc(c->data,len); 
	}

	if (s == e) {
		*(char *) c->data = 0;
	} else if (GDKstrFromStr(c->data, (unsigned char *) s, e - s) == 0) {
		return NULL;
	}
	return c->data;
}

ptr *
ASCIIadt_frStr(void *extra, int type, char *s, char *e, char quote)
{
	ptr *res = NULL;
	ascii_io *c = extra;

	if (s == NULL || (!(type == TYPE_str && quote) && strcmp(s, "nil") == 0)) {
		res = (ptr *) ATOMnil(type);
	} else if (type == TYPE_str) {
		return ASCIIstrFrStr(c, s, e);
	} else {
		(void) (*BATatoms[type].atomFromStr) (s, &c->len, (ptr) &c->data);
		res = c->data;
	}
	return res;
}

int
ASCIIadt_toStr(void *extra, char **buf, int *len, int type, ptr a)
{
	(void) extra;
	return (*BATatoms[type].atomToStr) (buf, len, a);
}

static size_t
create_loadformat(ascii *as, BAT *names, BAT *seps, BAT *types)
{
	size_t p;
	size_t nr_attrs = BATcount(names);
	ascii_io *fmt = as->format = (ascii_io *) GDKmalloc(sizeof(ascii_io) * (nr_attrs + 1));

	as->offset = 0;
	as->nr_attrs = nr_attrs;
	/* assert(as->nr_attrs == nr_attrs); *//* i.e. it fits */
	for (p = 0; p < nr_attrs; p++) {
		fmt[p].name = (char *) bun_tail(names, p);
		fmt[p].sep = sep_dup((char *) bun_tail(seps, p));
		fmt[p].seplen = (int) strlen(fmt[p].sep);
		fmt[p].type = (char *) bun_tail(types, p);
		fmt[p].adt = ATOMindex(fmt[p].type);
		if (fmt[p].adt < 0) {
			GDKerror("create_loadformat: %s has unknown type %s (using str instead).\n", fmt[p].name, fmt[p].name);
			fmt[p].adt = TYPE_str;
		}
		fmt[p].tostr = &ASCIIadt_toStr;
		fmt[p].frstr = &ASCIIadt_frStr;
		fmt[p].extra = fmt+p;
		fmt[p].data = NULL;
		fmt[p].len = 0;
		if (ascii_io_debug)
			stream_printf(GDKerr, "%s\n", fmt[p].name);
	}
	return as->nr_attrs;
}

static
    size_t
create_dumpformat(ascii *as, BAT *names, BAT *seps, BAT *bats)
{
	size_t p;
	size_t nr_attrs = BATcount(bats);
	ascii_io *fmt = as->format = (ascii_io *) GDKmalloc(sizeof(ascii_io) * (nr_attrs + 1));

	as->offset = 0;
	as->nr_attrs = nr_attrs;
	/* assert(as->nr_attrs == nr_attrs); *//* i.e. it fits */
	for (p = 0; p < nr_attrs; p++) {
		BAT *b = (BAT *) BATdescriptor(*(bat *) bun_tail(bats, p));

		if (!b)
			return ~(size_t) 0;	/* (size_t)(-1) */
		fmt[p].name = NULL;
		if (names)
			fmt[p].name = (char *) bun_tail(names, p);
		fmt[p].sep = sep_dup((char *) bun_tail(seps, p));
		fmt[p].seplen = (int) strlen(fmt[p].sep);
		fmt[p].type = ATOMname(b->ttype);
		fmt[p].adt = (b)->ttype;
		fmt[p].tostr = &ASCIIadt_toStr;
		fmt[p].frstr = &ASCIIadt_frStr;
		fmt[p].extra = fmt+p;
		fmt[p].data = NULL;
		fmt[p].len = 0;
		BBPunfix(b->batCacheid);
	}
	return as->nr_attrs;
}

void
ASCIIdestroy_format(ascii *as)
{
	size_t p;
	ascii_io *fmt = as->format;

	for (p = 0; p < as->nr_attrs; p++) {
		if (fmt[p].c)
			BBPunfix(fmt[p].c->batCacheid);
		GDKfree(fmt[p].sep);
		if (fmt[p].data)
			GDKfree(fmt[p].data);
	}
	GDKfree(fmt);
}

size_t
ASCIIassign_BATs(ascii *as, BAT *bats)
{
	ascii_io *fmt = as->format;
	size_t res = as->nr;
	size_t i;

	for (i = 0; i < as->nr_attrs; i++) {
		BAT *b = (BAT *) BATdescriptor(*(bat *) bun_tail(bats, i));

		fmt[i].c = (b);
		if (res == ~(size_t) 0 || BATcount(fmt[i].c) < res)
			res = BATcount(fmt[i].c);
	}
	as->nr = res;
	return res;
}

static
    oid
check_BATs(ascii *as)
{
	ascii_io *fmt = as->format;
	size_t i = 0;
	size_t cnt;
	oid base;

	if (fmt[i].c == NULL)
		i++;
	cnt = BATcount(fmt[i].c);
	base = fmt[i].c->hseqbase;

	if (!BAThdense(fmt[i].c) || as->nr != cnt )
		return oid_nil;

	for (i = 0; i < as->nr_attrs; i++) {
		BAT *b;
		int offset;

		b = fmt[i].c;
		if (b == NULL)
			continue;
		offset = BUNindex(b, BUNfirst(b)) + as->offset;

		if (BATcount(b) != cnt || !BAThdense(b) || b->hseqbase != base)
			return oid_nil;

		fmt[i].p = BUNptr(b, offset);
	}
	return base;
}

int
ASCIIcreate_bats(ascii *as)
{
	ascii_io *fmt = as->format;
	size_t i;
	size_t nr = 0; 

	if (as->nr != ~(size_t)0)
		nr = as->nr;
	for (i = 0; i < as->nr_attrs; i++) {
		fmt[i].c = void_bat_create(fmt[i].adt, nr);
		if (!fmt[i].c) {
			GDKerror("ASCIIcreate_bats: Failed to create bat of size %d\n", as->nr);
			return -1;
		}
	}
	return 0;
}

BAT *
ASCIIcollect_bats(ascii *as)
{
	BAT *bats = BATnew(TYPE_str, TYPE_bat, as->nr_attrs);
	ascii_io *fmt = as->format;
	size_t i;
	size_t cnt = BATcount(fmt[0].c);

	if (bats == NULL)
		return NULL;
	for (i = 0; i < as->nr_attrs; i++) {
		BUNins(bats, (ptr) fmt[i].name, (ptr) &fmt[i].c->batCacheid);
		BATsetaccess(fmt[i].c, BAT_READ);
		if (cnt != BATcount(fmt[i].c)) {
			GDKerror("ASCIIcollect: counts are not equal\n");
			return NULL;
		}
	}
	return bats;
}

static INLINE int
myisspace(int s)
{
	return s == ' ' || s == '\t' || s == '\n';
}

static INLINE char *
lstrip(char *s)
{
	while (myisspace((int) *s)) {
		s++;
	}
	return s;
}

static INLINE char *
rstrip(char *e)
{
	e--;
	while (myisspace((int) *e)) {
		e--;
	}
	e++;
	if (e && *e) {
		*e = 0;
	}
	return e;
}

static INLINE char *
find_quote(char *s, char quote)
{
	while (*s != quote)
		s++;
	return s;
}

static INLINE char *
rfind_quote(char *s, char quote)
{
	while (*s != quote)
		s--;
	return s;
}

static INLINE int
insert_val(ascii_io *fmt, char *s, char *e, char quote)
{
	char *end = e;
	char bak = *e;
	ptr *adt;

	if (quote) {
		/* string needs the quotes included */
		s = find_quote(s, quote);
		if (!s) {
			GDKwarning("quote '%c' expected but not found in \"%s\"\n", quote, s);
			return 1;
		}
		s++;
		e = rfind_quote(e, quote);
		*e = 0;
	} else if (e > s) {
		s = lstrip(s);
		e = rstrip(e);
	}
	if (e < s) {
		e = s;
	}
	adt = fmt->frstr(fmt->extra, fmt->adt, s, e, quote);
	*end = bak;

	if (!adt) {
		GDKerror("insert_val: %lx not inserted %s\n", (size_t) adt, s);
		return 1;
	}

	BUNappend(fmt->c, adt, FALSE);
	if (fmt->data != adt)
		GDKfree(adt);
	return 0;
}

static INLINE char *
skip_string(char *s, char quote)
{
	int esc = 0;

	while (*s) {
		if (*s == '\\' && !esc)
			esc = 1;
		else if (*s == quote && !esc)
			break;
		else
			esc = 0;
		s++;
	}
	if (*s)
		s++;
	else
		return NULL;
	return s;
}

static INLINE int
insert_line(ascii *as, char *line)
{
	int res = 0;
	ascii_io *fmt = as->format;
	char *s, *e = 0, quote = 0;
	size_t i;
	int first = 0;

	for (i = 0; i < as->nr_attrs - 1 && res == 0; i++) {
		first = 1;
		s = line;
		while (*line) {
			if (*line == *(fmt[i].sep) && strncmp(fmt[i].sep, line, fmt[i].seplen) == 0) {
				e = line;
				break;
			} else if (first && (*line == '\"' || *line == '\'')
				   && (line == s || *(line - 1) != '\\')) {
				quote = *line;
				line++;
				line = skip_string(line, quote);
				if (!line)
					return -1;
				first = 0;
			} else {
				if (first && !isspace((int) (*line)))
					first = 0;
				line++;
			}
		}
		if (e) {
			char *end = e;

			res |= insert_val(&fmt[i], s, e, quote);
			quote = 0;
			line = end + fmt[i].seplen;
		} else {
			GDKerror("insert_line: missing sep %s line %d field %d\n", fmt->sep, BATcount(fmt->c), i);
			return -1;
		}
		e = 0;
	}
	s = line;
	first = 1;
	while (*line) {
		if (*line == *(fmt[as->nr_attrs - 1].sep) && strncmp(fmt[as->nr_attrs - 1].sep, line, fmt[as->nr_attrs - 1].seplen) == 0) {
			e = line;	/*strstr( line, fmt[as->nr_attrs-1].sep ); */
			break;
		} else if (first && (*line == '\"' || *line == '\'')
			   && *(line - 1) != '\\') {
			quote = *line;
			line++;
			line = skip_string(line, quote);
			if (!line)
				return -1;
			first = 0;
		} else {
			if (first && !isspace((int) (*line)))
				first = 0;
			line++;
		}
	}
	if (!e)
		e = line;
	if (e) {
		char *end = e;

		res |= insert_val(&fmt[as->nr_attrs - 1], s, e, quote);
		quote = 0;
		line = end + fmt[as->nr_attrs - 1].seplen;
	} else {
		GDKerror("insert_line: missing sep %s line %d field %d\n", fmt->sep, BATcount(fmt->c), i);
		return -1;
	}
	e = 0;
	return res;
}

static int
ascii_io_error(stream *s)
{
	if (!stream_errnr(GDKerr)) {
		char *err = stream_error(s);

		stream_printf(GDKerr, "Stream error %s\n", err);
		/* use free as stream allocates out side GDK */
		if (err)
			free(err);
	}
	return -1;
}

static INLINE int
dump_line(char **buf, int *len, ascii_io *fmt, stream *fd, size_t nr_attrs, size_t id)
{
	size_t i;

	for (i = 0; i < nr_attrs; i++) {
		ascii_io *f;
		char *p;
		int l;

		f = fmt + i;
		if (f->c) {
			p = (char *) bun_tail(f->c, id);

			l = f->tostr(f->extra, buf, len, f->adt, p);
			if (stream_write(fd, *buf, 1, l) != l)
				return ascii_io_error(fd);
		}
		if (stream_write(fd, f->sep, 1, f->seplen) != f->seplen)
			return ascii_io_error(fd);
	}
	return 0;
}

static INLINE int
output_line(char **buf, int *len, ascii_io *fmt, stream *fd, size_t nr_attrs, ptr id)
{
	size_t i;

	for (i = 0; i < nr_attrs; i++) {
		if (fmt[i].c == NULL)
			continue;
		fmt[i].p = BUNfnd(fmt[i].c, id);

		if (fmt[i].p == 0)
			break;
	}
	if (i == nr_attrs) {
		for (i = 0; i < nr_attrs; i++) {
			ascii_io *f;
			char *p;
			int l;

			f = fmt + i;
			if (f->c) {
				p = BUNtail(f->c, f->p);
				l = f->tostr(f->extra, buf, len, f->adt, p);
				if (stream_write(fd, *buf, 1, l) != l)
					return ascii_io_error(fd);
			}
			if (stream_write(fd, f->sep, 1, f->seplen) != f->seplen)
				return ascii_io_error(fd);
		}
	}
	return 0;
}

static INLINE int
output_line_dense(char **buf, int *len, ascii_io *fmt, stream *fd, size_t nr_attrs)
{
	size_t i;

	for (i = 0; i < nr_attrs; i++) {
		ascii_io *f = fmt + i;

		if (f->c) {
			char *p = BUNtail(f->c, f->p);
			int l = f->tostr(f->extra, buf, len, f->adt, p);

			if (stream_write(fd, *buf, 1, l) != l)
				return ascii_io_error(fd);
			f->p = BUNnext(f->c, f->p);
		}
		if (stream_write(fd, f->sep, 1, f->seplen) != f->seplen)
			return ascii_io_error(fd);
	}
	return 0;
}

static INLINE int
output_line_lookup(char **buf, int *len, ascii_io *fmt, stream *fd, size_t nr_attrs, size_t id)
{
	size_t i;

	for (i = 0; i < nr_attrs; i++) {
		ascii_io *f = fmt + i;

		if (f->c) {
			char *p = BUNtail(f->c, BUNptr(f->c,
						   id +BUNindex(f->c, BUNfirst(f->c))));
			int l = f->tostr(f->extra, buf, len, f->adt, p);

			if (stream_write(fd, *buf, 1, l) != l)
				return ascii_io_error(fd);
		}
		if (stream_write(fd, f->sep, 1, f->seplen) != f->seplen)
			return ascii_io_error(fd);
	}
	return 0;
}

static INLINE int
read_more(bstream *in, stream *out, int n)
{
	if (out) {
		do {
			/* query is not finished ask for more */
			/* we need more query text */
			if (bstream_next(in) < 0)
				return EOF;
			if (in->eof) {
				if (out && stream_write(out, PROMPT2, sizeof(PROMPT2) - 1, 1) == 1)
					stream_flush(out);
				in->eof = 0;
				/* we need more query text */
				if (bstream_next(in) < 0)
					return EOF;
			}
		} while (in->len <= in->pos);
	} else {
		bstream_read(in, n);
	}
	return 1;
}


int
ASCIIload_file(ascii *as, bstream *b, stream *out)
{
	int res = 0, done = 0;
	size_t i = 0;
	char *sep = as->format[as->nr_attrs - 1].sep;
	int seplen = as->format[as->nr_attrs - 1].seplen;

	if (ascii_io_debug)
		stream_printf(GDKerr, "ASCIIload_file\n");

	while ((b->pos < b->len || !b->eof) && res == 0 && (as->nr == ~(size_t) 0 || i < as->nr)) {
		char *s, *end;

		if (b->pos >= b->len && read_more(b, out, b->size - (b->len - b->pos)) == EOF) {
			GDKerror("ASCIIload_file: read error\n");
			res = -1;
			break;
		}
		end = b->buf + b->len;
		s = b->buf + b->pos;
		*end = '\0';
		done = 0;
		while (s < end) {
			char *e = strstr(s, sep);

			if (e) {
				*e = '\0';
				if (insert_line(as, s) < 0) {
					GDKerror("ASCIIload_file: value %s not inserted\n", s);
					s = e + seplen;
					b->pos = (s - b->buf);
					res = -1;
					break;
				}
				s = e + seplen;
				done = 1;
			} else if (b->eof && s + as->nr_attrs < end) {
				if (insert_line(as, s) < 0) {
					GDKerror("ASCIIload_file: value %s not inserted\n", s);
					s = end;
					b->pos = (s - b->buf);
					res = -1;
					break;
				}
				s = end;
			} else {
				if (!done) {	/* nothing found in current buf
						 * ie. need to enlarge
						 */
					int size = b->size;

					if (b->pos == 0 || (b->len - b->pos > b->size >> 1))
						size <<= 4;
					if (read_more(b, out, size) == EOF) {
						GDKerror("ASCIIload_file: read error\n");
						res = -1;
						break;
					}
					end = b->buf + b->len;
					s = b->buf + b->pos;
					*end = '\0';
					continue;
				}
				break;
			}
			b->pos = (s - b->buf);
			i++;
			if (ascii_io_debug && (i % 100000) == 0)
				stream_printf(GDKerr, "inserted " SZFMT "\n", i);
			if (as->nr != ~(size_t) 0 && i >= as->nr)
				break;
		}
	}
	as->nr = i;
	if (res < 0)
		return res;
	return as->nr;
}

static
    int
dump_file(ascii *as, stream *fd)
{
	size_t i = 0;
	int len = BUFSIZ;
	char *buf = GDKmalloc(len);

	for (i = 0; i < as->nr; i++) {
		if (dump_line(&buf, &len, as->format, fd, as->nr_attrs, i) < 0) {
			GDKfree(buf);
			return -1;
		}
		if (ascii_io_debug && (i % 1000000) == 0)
			stream_printf(GDKerr, "dumped " SZFMT " lines\n", i);
	}
	GDKfree(buf);
	return 0;
}

static int
output_file_default(ascii *as, BAT *order, stream *fd)
{
	int len = BUFSIZ, res = 0;
	char *buf = GDKmalloc(len);
	BUN p, q;
	size_t i = 0;
	size_t offset = BUNindex(order, BUNfirst(order)) + as->offset;

	for (q = BUNptr(order, offset + as->nr), p = BUNptr(order, offset); p < q; p = BUNnext(order, p)) {
		ptr h = BUNhead(order, p);

		if ((res = output_line(&buf, &len, as->format, fd, as->nr_attrs, h)) < 0) {
			GDKfree(buf);
			return res;
		}
		i++;
		if (ascii_io_debug && (i % 1000000) == 0)
			stream_printf(GDKerr, "dumped " SZFMT " lines\n", i);
	}
	GDKfree(buf);
	return res;
}

static int
output_file_dense(ascii *as, stream *fd)
{
	int len = BUFSIZ, res = 0;
	char *buf = GDKmalloc(len);
	size_t i = 0;

	for (i = 0; i < as->nr; i++) {
		if ((res = output_line_dense(&buf, &len, as->format, fd, as->nr_attrs)) < 0) {
			GDKfree(buf);
			return res;
		}
		if (ascii_io_debug && (i % 1000000) == 0)
			stream_printf(GDKerr, "dumped " SZFMT " lines\n", i);
	}
	GDKfree(buf);
	return res;
}

static int
output_file_ordered(ascii *as, BAT *order, stream *fd, oid base)
{
	int len = BUFSIZ, res = 0;
	char *buf = GDKmalloc(len);
	BUN p, q;
	size_t i = 0;
	size_t offset = BUNindex(order, BUNfirst(order)) + as->offset;

	for (q = BUNptr(order, offset + as->nr), p = BUNptr(order, offset); p < q; p = BUNnext(order, p)) {
		size_t h = *(oid *) BUNhead(order, p) - base;

		if ((res = output_line_lookup(&buf, &len, as->format, fd, as->nr_attrs, h)) < 0) {
			GDKfree(buf);
			return res;
		}
		if (ascii_io_debug && (i % 1000000) == 0)
			stream_printf(GDKerr, "dumped " SZFMT " lines\n", i);
	}
	GDKfree(buf);
	return res;
}

#define SIZE 1*1024*1024

BAT *
ASCIIload(BAT *names, BAT *seps, BAT *types, char *datafile, size_t nr)
{
	BAT *res;
	stream *s = open_rastream(datafile);
	bstream *b = NULL;

	if (s == NULL || stream_errnr(s)) {
		GDKerror("ASCIIload: could not open file %s\n", datafile);
		if (s) {
			stream_destroy(s);
		}
		return NULL;
	}
	res = ASCIIinput(names, seps, types, b = bstream_create(s, SIZE), NULL, nr);
	bstream_destroy(b);
	stream_close(s);
	stream_destroy(s);
	return res;
}

BAT *
ASCIIinput(BAT *names, BAT *seps, BAT *types, bstream *s, stream *out, size_t nr)
{
	BAT *bats = NULL;
	ascii as;

	as.nr_attrs = 0;
	as.nr = nr;
	if (create_loadformat(&as, names, seps, types) != ~(size_t) 0 && ASCIIcreate_bats(&as) >= 0) {
		if (ASCIIload_file(&as, s, out) >= 0)
			bats = ASCIIcollect_bats(&as);
	}
	ASCIIdestroy_format(&as);
	return bats;
}

void
ASCIIdump(BAT *names, BAT *seps, BAT *bats, char *datafile, size_t nr)
{
	ascii as;

	as.nr_attrs = 0;
	as.nr = nr;
	if (create_dumpformat(&as, names, seps, bats) != ~(size_t) 0 && ASCIIassign_BATs(&as, bats) != ~(size_t) 0) {
		stream *s = open_wastream(datafile);

		if (s != NULL && !stream_errnr(s) && dump_file(&as, s) >= 0) {
			stream_printf(GDKerr, "saved in %s\n", datafile);
		}
		if (s == NULL || stream_errnr(s)) {
			GDKerror("ASCIIdump: could not open file %s\n", datafile);
		} else {
			stream_close(s);
		}
		stream_destroy(s);
	}
	ASCIIdestroy_format(&as);
}

int
ASCIIoutput_file(ascii *as, BAT *order, stream *s)
{
	oid base = oid_nil;
	size_t maxnr = BATcount(order);

	/* only set nr if it is zero or lower (bogus) to the maximum value
	 * possible (BATcount), if already set within BATcount range,
	 * preserve value such that for instance SQL's reply_size still
	 * works
	 */
	if (as->nr <= 0 || as->nr > maxnr)
		as->nr = maxnr;

	if ((base = check_BATs(as)) != oid_nil) {
		if (BAThdense(order) && order->hseqbase == base)
			return output_file_dense(as, s);
		else
			return output_file_ordered(as, order, s, base);
	} else {
		return output_file_default(as, order, s);
	}
}

size_t
ASCIIoutput(BAT *order, BAT *seps, BAT *bats, stream *s)
{
	int res = 0;
	ascii as;

	as.nr_attrs = 0;
	as.nr = ~(size_t) 0;
	if (create_dumpformat(&as, NULL, seps, bats) != ~(size_t) 0 && ASCIIassign_BATs(&as, bats) != ~(size_t) 0) {
		res = ASCIIoutput_file(&as, order, s);
	}
	ASCIIdestroy_format(&as);
	if (res >= 0)
		return as.nr;
	return ~(size_t) 0;
}

int
init_ascii_io(int *debug)
{
	ascii_io_debug = *debug;

	return GDK_SUCCEED;
}

int
ascii_io_load(BAT **bats, BAT *names, BAT *seps, BAT *types, str datafile, int *N)
{
	size_t nr = ~(size_t)0;

	if (*N >= 0)
		nr = *N;
	*bats = ASCIIload(names, seps, types, datafile, nr);
	if (*bats) {
		return GDK_SUCCEED;
	} else {
		return GDK_FAIL;
	}
}
int
ascii_io_input(BAT **bats, BAT *names, BAT *seps, BAT *types, Stream *s, int *N)
{
	bstream *b = NULL;
	size_t nr = ~(size_t)0;

	if (*N >= 0)
		nr = *N;
	*bats = ASCIIinput(names, seps, types, b = bstream_create(*(stream **) s, SIZE), NULL, nr);
	bstream_destroy(b);
	if (*bats) {
		return GDK_SUCCEED;
	} else {
		return GDK_FAIL;
	}
}

int
ascii_io_dump(BAT *names, BAT *seps, BAT *bats, str datafile, int *nr)
{
	ASCIIdump(names, seps, bats, datafile, *nr);
	return GDK_SUCCEED;
}

int
ascii_io_output(BAT *order, BAT *seps, BAT *bats, Stream *s)
{
	size_t res = ASCIIoutput(order, seps, bats, *(stream **) s);

	return ((res == ~(size_t) 0) ? GDK_FAIL : GDK_SUCCEED);
}

@}
