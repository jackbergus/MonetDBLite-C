@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2006 CWI.
@' All Rights Reserved.

@f monet
@T
% define titlepage
@t The Monet Database System
@v Version 4.2
@a Martin L. Kersten & Peter Boncz

% create table of contents
\newpage
\tableofcontents
\newpage

@* Monet
The Goblin Database Kernel library is complemented by a textual interface,
called @%Monet@.  This interface is easy to interpret, versatile and
flexible to accommodate system debugging and application tool development.
Although a textual interface potentially leads to a performance degradation,
our experience with earlier systems, e.g. Troll and PRISMA,
showed that the overhead can be kept within acceptable limits.
Moreover, a textual interface reduces the programming
effort otherwise needed to develop test and application programs.
@T
    \begin{figure}[hbt]
        \mbox{\hspace{120pt}\epsffile{monet.eps}}\\
        \caption{The Monet Modules}
    \end{figure}

The above figure shows the different components of the Monet system. The
{\tt processes} module offers support for multi-threading.
In this mode, the interpreter thread runs independent of the
initial thread. Moreover, a thread is started to accepts requests from the
internet. Each client can indicate the interpreter to interact with.
For example, one can envision a thread dedicated to the parsing and execution
of SQL statements.

The {\tt queue} contains the parsed user request. It
synchronizes (multiple) workers by locking. The {\tt interface} module
implements the interface to database clients. The {\tt lex/parser}
module converts requests into parse trees.
Those parse trees can be executed by the {\tt interpreter} module, which
invokes basic BAT algebra commands from the {\tt commands} module. There is
a {\tt procedures} module to load and execute user-defined procedures.

In the lower level modules there is support for event {\tt triggers},
temporary {\tt variables} management, and {\tt dynamic loading} of
routines. These parts of the system are still under development.

@+ Critical sections and semaphores
Monet is implemented as a collection of threads. This calls for extreme
care in coding. At several places locks and semaphores are necessary
to achieve predictable results. In particular, after they are created
and when they are inspected or being modified to take decisions.

In the current implementation the following list of locks and semaphores
is used:
@T
\begin{tabular}{|l | l | l |}\hline
Name & Used in & Protects\\
GDKthreadLock   & GDKinit       & {\em created }\\
                & GDKexit       & GDKnrofthreads\\
                &  dumplocktable & {\em inspected}\\
                &  THRget       & GDKthreads\\
                &  THRnew       & GDKnrofthreads, GDKthreads\\
                &  THRdel       & GDKnrofthreads\\
                &  THRkill      & GDKnrofthreads\\\hline
GDKcacheLock    & BBPdir        & BBPlogical, BBPphysical, BBPstatus,
                                  BBPcache, BBPsize, BBPrefs\\
                & BBPenter      & BBPlogical, BBPphysical, BBPstatus, \\
                &               & BBPcache, BBPsize, BBPrefs, BBPlimit,\\

                &               & BBPcachestore\\
                & BBPclear      & BBPlogical, BBPphysical, BBPstatus,
                                  BBPrefs\\
                & BBPuncacheit  & BBPcache \\\hline
monet\_critical          & monet.mx      & {\em created  }\\
                & clrRequest    & QMrequests, qm\_first, qm\_last, qm\_top, qm\_bot\\
monet\_contextLock       & monet.mx      & {\em created  }\\
                & CNTXTfree     & monet\_cntxt monet\_cntxtcur\\
                & CNTXTnew      & monet\_cntxt monet\_cntxtcur\\
                & VARnew        & monet\_cntxt\\\hline
monet\_parserLock        & monet\_init    & {\em created  }\\
                & parserEntry & ll\_client and parser\\
                & parserExit &  ll\_client and parser\\
monet\_notifyLock	& monet\_init    & {\em created  }\\
                & CMDstop & (trigger) notifiers \\
TBL\_readLock   & monet\_tbl.mx & {  }\\
TBL\_writeLock  & monet\_tbl.mx & {  }\\\hline
monet\_forksync & monet\_init   & {\em created}\\
                & main          & {\em down for Internet Thread}\\\hline
monet\_available	& monet\_init    & {\em created}\\
                & clrRequest    & QMrequests, qm\_first, qm\_last, qm\_top, qm\_bot\\
                & wakeupRequest & {\em up for available MIL request}\\
                & getRequest & {\em down to get request from queu} \\
                &               & {\em up to signal available requests}\\ \hline
\end{tabular}

@T
\begin{verbatim}
Some conclusions:
- BBPcache is also used in BBPdummy, BBPexit, BBPcacheit
- BBPsize is used in many places outside the buffer pool
- BBPlogical and BBPphysical is not protected in BBPrename
- BBPcachestore should become a local variable in BBPextend.
- BBPclear e.d. test on BBPsize should be in critical section always.
- BBPclear should include copy of BBPuncacheit in critical section
- qm_last is not always used in critical section
- monet_cntxt is also used in CNTXTclient, CNTXTdelete, VARfind, CARclearBAT
  and closeClient, CMDvars, CMDconstant, CMDfreeze, CMDbackground,
      CMDscope, CMDvars, interpret_assignment (Are these all safe?)
\end{verbatim}

@{
@+ Monet Basic Definitions
Definitions that need to included in every file of the Monet system,
as well as in user defined module implementations.
@h
#ifndef _MONET_H_

#define _MONET_H_

#include "gdk.h"

#ifdef NATIVE_WIN32
#ifndef LIBMONET
#define m_export extern __declspec(dllimport)
#else
#define m_export extern __declspec(dllexport)
#endif
#else
#define m_export extern
#endif



@- Parse Trees
MIL blocks get parsed into parse trees. The exact form is not important here,
as programmers will not need to manipulate parse trees directly.
@h
#define YYMAXSONS 	11
#define YYOVERFLOW(t)	((YYSTREE) (t->extendable?t->yysons[t->capacity]:NULL))

/* YYSTREE: changed in nov 2005 to squeeze Mbedded memory */
typedef struct YYS {
	ValRecord yyval;          /* MIL expression result value */ 
	unsigned int token:9,     /* MIL parse tree token */
                     noyyval:1,   /* yyval part is not allocated => BEWARE: first 16 bytes bogus */
                     iscopy:1,    /* yyval is a copy of something that must be alive (need no dealloc) */ 
                     cnt:5,       /* the actual number of yysons */ 
                     capacity:5,  /* the maximum number of yysons (default YYMAXSONS) */
 	             extendable:1,/* whether there is one extra slot at the end of yysons for an overflow pointer */ 
                     malloced:1,  /* whether this node was GDKmalloced() - if not it is part of a larger chunk */
                     dealloc:9;  /* runtime garbage collection info (see below) */
	union {
		ptr atmref;       /* garbage collectioon: must GDKfree an atom */
		batrec batref;    /* garbage collectioon: must BBPunfix a bat */
		struct YYS *delnode;  /* union space re-used only at final stage of Myyfree */
	} free; 
	struct YYS *yysons[YYMAXSONS+1]; /* tree sons. BEWARE: there may be fewer than YYMAXSONS space!! */
} yystree, *YYSTREE;

#define YYDEALLOC_BAT	1
#define YYDEALLOC_VAL	2

#ifndef YYSTYPE
#define YYSTYPE	YYSTREE
#endif

#define arg(T,	I)       ((T)->yysons[I])

#include "monet_parse.tab.h"	/* needed for lex */

@- Iteration Records

The iterator is a cursor-like construct, that according to some predicate
selects some BUNs out of a BAT. It takes them one by one, and executes a
piece of MIL for each BUN, substituting head and tail value as $1 and $2
respectively in the MIL block. MIL has a special syntactic form
for this: [bat-expression] @ [iterator] ( [params] ) [MIL-statement]
@
An example would be:
@
b@batloop() printf("[ %d %d ]\n", $1, $2);
@
which prints a BAT of decimal values. The MIL executing is done in the
Monet Interpreter. Standard iterators are @%CMDbatloop@ and  @%CMDhashloop@.
Iterators can also be written by Monet Extenders.
@
Iterators often use a search accelerator for making the selection. For
instance, if you have developed an R-Tree, you might
develop also iterators that use the R-Tree to iterate over points near
to each other.
@
They have the form of a loop over some selection of the BUNs of a BAT,
which is always the first parameter. The second parameter is a PTR
which points to the @%iteration-record@. The other parameters are the
parameters passed between parentheses. For each BUN, a call
ITERATE(head-ptr, tail-ptr, iteration-record) must be done. This will
execute the MIL block, on the BUN, where the head-ptr is a pointer to
the head atom of the current BUN, and tail-ptr a pointer to the tail-atom.
@
The iteration-record provides the necessary context information
that allows the Monet Interpreter to know what to execute on each call
of ITERATE(). As mentioned, it is passed to the iterator function at
startup in the second parameter.
@h
#include "yytree.h"
#define ITERATE(x,y,h) (*((Iteration) h)->tuple_interpret)((x), (y), (h))

#define Cntxt	int
/* typedef int Cntxt; */

typedef struct {
	Cntxt stk;		/* context for iterator body execution. */
	YYSTREE tree;		/* iterator body/ies. */
	ValPtr res;		/* iterator result value. */
	int status;		/* execution status so far. */
	int (*tuple_interpret) (ptr, ptr, ptr);
	int (*h_len) (ptr);	/* fcn returning var-sized h_atom length */
	int (*t_len) (ptr);	/* fcn returning var-sized t_atom length */
	ValPtr params;		/* (sequence of) head&&tail 2b substituted. */
	int parcnt;		/* current number of jobs in cointainer. */
	int parmax;		/* maximum number of jobs in cointainer. */
	int parcap;		/* maximum paralellism capacity. */
} ITrecord, *Iteration;

@}

@+ Interface functions
@h
#include "monet_process.h"
#include "monet_client.h"
#include "monet_context.h"
#include "monet_interpreter.h"
#include "monet_tbl.h"
#include "monet_multiplex.h"
#include "monet_queue.h"

m_export int monet_running;
m_export Client monet_init(void);
m_export int protectMonet(void);
m_export str monet_load_script(str file, str module);
m_export ptr monet_eval(str mil_script, int *ret_type);
m_export int monet_exec(str mil_script);
m_export void monet_exit(int status);
m_export void monet_hello(stream *out);
m_export int monet_sprintf(str *dst, str format, va_list ap);
m_export void monet_checkbat(BAT *b, int protect);
m_export int monet_syscall(GDKfcn addr, int argc, ValPtr argv);
m_export int monet_sigerror(str kind, str name, str extra, int argc, ValPtr argv);

@{
@- external declarations
belong to yacc part of monet_parse.mx, but cannot comfortably be
declared there.
@h
/* lexical analyzer */
m_export int ll_getch(void);
m_export void ll_init(void);
m_export str ll_lastline(void);
m_export void ll_clrids(void);
m_export void ll_idconflict(str s);

@}

@+ Monet Calling Options
The number of invocation arguments is kept to a minimum.
The listing flag is set automatically
when statements are read from a file.
The prompt character is printed each time @%Monet@ expects a new command.
@T
\begin{itemize}
\item
A dataset within the database server can be selected with the {\tt
-db} option.
\item
\end{itemize}
The input file for commands is standard input.
See the MonetDB.conf file for additional system variable settings
@
@h
#define MAXSCRIPT 64

m_export int monet_nostalgic; /* do not require () on empty parameters */
m_export char monet_cwd[PATHLENGTH];	/* where the server started */
m_export int monet_listing;	/* echo input */
m_export int monet_daemon;	/* set server console is deaf */
m_export int monet_forks;	/* count interpreter threads */
m_export int monet_upgrade_needed;	/* wait for locks */
m_export int monet_upgrade_done;	/* finshed it */
m_export str *monet_script;	/* batch of requests */
m_export str monet_dbinit;	/* initialization statement */
m_export str monet_general;
m_export MT_Lock monet_critical;	/* critical section queue mgmt */
m_export MT_Lock monet_parserLock;	/* protects access to yacc/lex */
m_export MT_Lock monet_contextLock;	/* protects CNTXT structures */
m_export MT_Lock monet_voidLock;	/* protects void hack */
m_export MT_Sema monet_available;	/* worker threads in queue */
m_export MT_Sema monet_forksync;	/* sync semaphore for fork */
m_export MT_Lock profilerLock;	        /* protects profiler */

m_export int monet_tokseq;	/* value of TOK_SEQ */
m_export int monet_tokident;	/* value of TOK_IDENT */
m_export int monet_tokconstant;	/* value of TOK_CONSTANT */
m_export int monet_tokbuiltin;	/* value of TOK_BUILTIN */
m_export int monet_tokcommand;	/* value of TOK_COMMAND */
m_export int monet_tokoperator;	/* value of TOK_OPERATOR */
m_export int monet_tokproc;	/* value of TOK_PROC */
m_export int monet_tokiterator;	/* value of TOK_ITERATOR */
m_export int monet_tokobject;	/* value of TOK_OBJECT */

m_export char monet_arch[PATHLENGTH];
m_export char monet_version[PATHLENGTH];

@-
Locking in an embedded situation can be relaxed.
Ideally, they are all removed.
@h
#define monet_set_lock(X,Y)   if(GDKprotected) MT_set_lock(X,Y)
#define monet_unset_lock(X,Y) if(GDKprotected) MT_unset_lock(X,Y)
#define monet_up_sema(X,Y)    if(GDKprotected) MT_up_sema(X,Y)
#define monet_down_sema(X,Y)  if(GDKprotected) MT_down_sema(X,Y)
#endif /* _MONET_H_ */
@c
#include "monet.h"

int monet_nostalgic = 0;
int monet_running = 0;
char monet_cwd[PATHLENGTH] = { 0 }, *monet_ver = 0;
int monet_listing = 0, monet_daemon = 0;
int monet_forks = 0;
int monet_needshared = 0;
str *monet_script = NULL;
str monet_dbinit = NULL;
str monet_general = 0;
MT_Lock monet_critical, monet_notifyLock, monet_voidLock;
MT_Lock monet_parserLock, monet_contextLock, profilerLock;
MT_Sema monet_available, monet_forksync;

@-
Fill in default tokens. yacc and bison yield different numbers.
This makes the kernel modules independent of libmonet in this respect.
@c
int monet_tokseq = TOK_SEQ;
int monet_tokident = TOK_IDENT;
int monet_tokconstant = TOK_CONSTANT;
int monet_tokbuiltin = TOK_BUILTIN;
int monet_tokcommand = TOK_COMMAND;
int monet_tokoperator = TOK_OPERATOR;
int monet_tokproc = TOK_PROC;
int monet_tokiterator = TOK_ITERATOR;
int monet_tokobject = TOK_OBJECT;

@-
A welcoming message is displayed to inform the user about recent
changes. The parameter settings is first delegated to GDK to pick
out what is needed. The remainder are considered relevant for the
monet interface.
@c
char monet_arch[PATHLENGTH] = HOST;
char monet_version[PATHLENGTH] = VERSION;

void
monet_hello(stream *out)
{
#ifdef STATIC
	char *linkinfo = "statically";
#else
	char *linkinfo = "dynamically";
#endif

	if (GDKgetenv_isyes("monet_welcome")) {
		if (out == NULL)
			out = GDKout;
		stream_printf(out, "# Monet Database Server V%s\n", monet_version);
		stream_printf(out, "# Copyright (c) 1993-2006, CWI. "
			      "All rights reserved.\n");
		stream_printf(out, "# Compiled for %s/" SZFMT "bit with " SZFMT "bit OIDs; %s linked.\n", 
		                   monet_arch, (size_t) (sizeof(ptr) * 8), (size_t) (sizeof(oid) * 8), linkinfo);
		stream_printf(out, "# Visit http://monetdb.cwi.nl/ for further information.\n");
	}
}

@- Monet Exit
The client threads are already killed upon closing their input file.
The server process interpreter is directly killed.
@c
void
monet_exit(int status)
{
	PARDEBUG THRprintf(GDKerr, "exit from main process\n");

/*DD:this line removed*/ while (THRexit("Interpreter"))
			;
	GDKexit(status);
}

extern BAT *TBL_mod_load;

@- Monet Init
Startup the monet server. This is the moment that modules that
are hardwired into the kernel are activated. The below macro is
provided to make inclusion of new modules a piece of cake.

@= tokenvar
{	Variable v = VARnew(0, "@1");
	v->binding.vtype = TYPE_int;
	v->binding.val.ival = @1;
	VARfreeze(v);
	VARfixate(v);
}

@c
int
protectMonet(void)
{
	if (!GDKprotected) {
		TMDEBUG printf("# protectMonet: upgrade protection %d>0\n", monet_forks);
		TMDEBUG printf("# Monet locks created\n");

		MT_init_lock(monet_critical);
		MT_init_lock(monet_contextLock);
		MT_init_lock(monet_parserLock);
		MT_init_lock(monet_notifyLock);
		MT_init_lock(monet_voidLock);
                MT_init_sema(monet_available, 0);
                MT_init_sema(monet_forksync, 0);
		MT_init_lock(profilerLock);
		TBL_protect();
		GDKprotect();
		monet_needshared = 0;
	}
	return 0;
}

@-
The client that notices the request for an upgrade is put on halt.
This client could be running processing a MIL program or awaiting
input from the user.
@c
void
protectMonetClient()
{
	if (GDKprotected)
		return;
	monet_needshared++;
	while (!GDKprotected) {
		MT_sleep_ms(1000);
	}
}

Client
monet_init(void)
{
	Client c;

	monet_running = 1;

	ll_init();

	CNTXTinit();
	TBL_init();		/* init MIL function table management. */
	c = initClient(GDKgetenv("monet_admin"), GDKgetenv("monet_prompt"),
		       /*DD:TRUE */ FALSE);
	if (c == 0)
		monet_exit(1);
	c->login = time(0);
	TBL_initclient(c, NULL);	/* register user 'adm' for a function table. */
@-
Make constants for important language tokens
@c
	@:tokenvar(TOK_BUILTIN)@
	@:tokenvar(TOK_PROC)@
	@:tokenvar(TOK_OPERATOR)@
	@:tokenvar(TOK_COMMAND)@
	@:tokenvar(TOK_ITERATOR)@
	@:tokenvar(TOK_OBJECT)@
	moduleClient(c, "main", NULL);
@-
Install all link-in modules.
@c

	c->listing = monet_listing;
	return c;
}

@- Monet load MIL script

@c
str
monet_load_script(str file, str mod)
{
	FILE *fp = NULL;
	size_t i = 0, totlen = 8192;
	char *buf, *p;
	char *mpop = "module_pop();\n";

#ifdef HAVE_FSTAT
	struct stat statb;
#endif

@-
Open the scriptfile.
@c
	if ((fp = fopen(file, "r")) == 0) {
		GDKerror("monet_load_script: could not open file: %s (%s)\n", file, mod ? mod : "main");
		return NULL;
	}
@-
Read the entire file, realloc if necessary.
@c
#ifdef HAVE_FSTAT
	/* figure out how much space we need to allocate */
	if (fstat(fileno(fp), &statb) == 0 && statb.st_size > 0) {
		totlen = statb.st_size + 1;
		/* add space for module_push and module_pop commands */
		if (mod)
			totlen += strlen(mod) + 31;
	}
#endif
	p = buf = GDKmalloc(totlen);

	if (mod) {
		i = snprintf(p, totlen, "module_push(\"%s\");\n", mod);
		p += i;
	}
	/* if the fstat call above worked, we should not need to enter the loop */
	while ((i += fread(p, 1, totlen - i, fp)) == totlen) {
		size_t len = totlen;

		totlen += 8192;
		p = GDKrealloc(buf, totlen);
		buf = p;
		p += len;
	}
	buf[i] = 0;
	fclose(fp);
	/* normalize line endings: replace CR-LF by space LF,
	   replace bare CR by LF */
	for (p = strchr(buf, '\r'); p; p = strchr(p, '\r')) {
		if (p[1] == '\n')	/* LF follows the CR */
			*p = ' ';
		else
			*p = '\n';
	}
	p = buf + i;

	if (mod) {
		size_t l = strlen(mpop);

		if ((i + l + 1) > totlen) {
			p = GDKrealloc(buf, i + l + 1);
			buf = p;
			p += i;
		}

		strncpy(p, mpop, l);
		i += l;
	}

	buf[i] = 0;
	return buf;
}

@- Monet MIL Evaluation
Monet MIL execution made easy: you provide a mil string. It gets
executed and you get a pointer to the return value (a GDK atom) back.
@T
Take good notice of the below points on return values:
\begin{itemize}
\item if there is no return value you get a NULL pointer back!
\item unless they are exited with a RETURN statement!
\item a single MIL statement {\bf is also} a sequential block.
\end{itemize}
Bottom line: if you want a return value, you should use RETURN!
@
You are supposed to know of which type this return value is..
The space is at least @%ATOMlen(t)@ long. It has to be freed.
by *you* with @%GDKfree@. On error, a NULL pointer is given back,
and the ret_tpe field is (mis)used for the error code..
@c
ptr
monet_eval(str mil_script, int *ret_type)
{
	ValPtr res = (ValPtr) GDKmalloc(sizeof(ValRecord));
	int i = interpret_str(0, mil_script, res);

	if (i == -TOK_RETURN) {
		*ret_type = res->vtype;
		if (ATOMextern(res->vtype)) {
			ptr p = res->val.pval;

			GDKfree(res);
			return p;
		}
		if (res->vtype == TYPE_bat) {
			BAT *b = BATdescriptor(res->val.bval);

			GDKfree(res);
			return (ptr) b;
		}
		return (ptr) res;	/* HACK: value space is first!! */
	} else if (i < 0) {
		*ret_type = i;
	} else {
		*ret_type = TYPE_void;
	}
	VALclear(res);
	GDKfree(res);
	return NULL;
}

@-
For those who don't bother about return values, there is @:monet_exec@.
It returns <0 on error; else >= 0;
@c
int
monet_exec(str mil_script)
{
	int restype = 0;
	ptr resval = monet_eval(mil_script, &restype);

	if (restype > 0) {
		ATOMunfix(restype, resval);
		GDKfree(resval);
	}
	return restype;
}

@-
The @%monet_sprintf@() gets a FILE*, str, and a sequence of (ptr,int) parameters
containing values and their type numbers. The @%printf@() proved to be a
great risk; people formatting badly their "%s" format strings were crashing
the kernel. This function will prevent you from doing so.

NEW implementation that repeatedly invokes sprintf => hacking the va_alist
for using vfsprintf proved to be too compiler-dependent (OLD approach).

@= writemem
	if (dst+@1 > buf+size) {
		ptrdiff_t offset = dst - buf;
		do {
			size *= 2;
		} while (dst+@1 > buf+size);
		buf = GDKrealloc(buf, size);
		dst = buf + offset;
	}
@= sprintf
	if (width > adds) {
		adds = width+10;
		add = (str) alloca((int)adds);
	}
#ifndef HAVE_SNPRINTF
	sprintf(add, meta, @1);
#else
	n = snprintf( add, adds, meta, @1 );
	while (n < 0 || (size_t) n >= adds) {
		if (n >= 0)	/* glibc 2.1 */
			adds = n+1; /* precisely what is needed */
		else		/* glibc 2.0 */
			adds *= 2; /* twice the old size */
		add = (str) alloca ((int)adds);
		n = snprintf( add, adds, meta, @1 );
	}
#endif /* HAVE_SNPRINTF */
@c
static char toofew_error[80] = "monet_sprintf(): at least %d parameters expected.\n";
static char format_error[80] = "monet_sprintf(): error in format before param %d.\n";
static char type_error[80] = "monet_sprintf(): illegal type in param %d.\n";

#define return_error(x)\
	GDKerror(x, argc); GDKfree(buf); return GDK_FAIL;

static char niltext[4] = "nil";

int
monet_sprintf(str *res, str format, va_list ap)
{
#ifdef HAVE_SNPRINTF
	int n;
#endif /* HAVE_SNPRINTF */

	int prec = 0, dotseen = 0, escaped = 0, type, size, argc = 1;
	size_t adds = 100, width = 0;
	char addbuf[100], *add = addbuf, *dst, *buf, *cur, *paramseen = NULL;

	if (format == NULL) {
		GDKerror("monet_sprintf: NULL pointer passed as format.\n");
		return GDK_FAIL;
	} else if (strchr(format, '%') == NULL) {
		*res = GDKstrdup(format);
		return GDK_SUCCEED;
	}
	buf = dst = (str) GDKmalloc(size = 80);
	*res = NULL;

	for (cur = format; *cur; cur++) {
		if (paramseen) {
			char *p, meta[100];
			ptrdiff_t extra = 0;
			ptrdiff_t len;

			if (GDKisdigit(*cur)) {
				if (dotseen) {
					prec = 10 * prec + (*cur - '0');
				} else {
					width = 10 * width + (*cur - '0');
				}
				continue;
			} else if (dotseen == 0 && *cur == '.') {
				dotseen = 1;
				continue;
			} else if (cur == paramseen + 1 && (*cur == '+' || *cur == '-' || *cur == ' ')) {
				continue;
			} else if (*cur == 'l') {
				cur++;
				if (*cur == 'l') {
					cur++;
					/* start of ll */
					extra = (cur - paramseen) - 2;
				}
			}
			if ((p = va_arg(ap, char *)) == NULL) {
				return_error(toofew_error);
			}
			type = ATOMstorage(va_arg(ap, int));

			len = 1 + (cur - paramseen);
			memcpy(meta, paramseen, len);
			meta[len] = 0;
			if (ATOMcmp(type, ATOMnilptr(type), p) == 0) {
				/* value is nil; attempt to print formatted 'nil'
				   without generating %ls etc. */
				char *csrc, *ctrg = meta;

				for (csrc = paramseen; csrc < cur; csrc++) {
					if (*csrc == '.')
						break;
					if (GDKisdigit(*csrc) || *csrc == '-')
						*(++ctrg) = *csrc;
				}
				*(++ctrg) = 's';
				*(++ctrg) = 0;
				@:sprintf(niltext)@
			} else if (strchr("cdiouxX", *cur) && !extra) {
				int ival;

				if (dotseen) {
					return_error(format_error);
				} else if (type == TYPE_chr) {
					ival = (int) *(chr *) p;
				} else if (type == TYPE_bte) {
					ival = (int) *(bte *) p;
				} else if (type == TYPE_sht) {
					ival = (int) *(sht *) p;
				} else if (type == TYPE_flt) {
					ival = (int) *(flt *) p;
				} else if (type == TYPE_int) {
					ival = *(int *) p;
				} else {
					return_error(type_error);
				}
				@:sprintf(ival)@
			} else if (strchr("diouxX", *cur)) {
#ifdef NATIVE_WIN32
				ptrdiff_t i;
#endif
				lng lval;

				if (dotseen) {
					return_error(format_error);
				}
				if (type == TYPE_chr) {
					lval = (lng) *(chr *) p;
				} else if (type == TYPE_bte) {
					lval = (lng) *(bte *) p;
				} else if (type == TYPE_sht) {
					lval = (lng) *(sht *) p;
				} else if (type == TYPE_int) {
					lval = (lng) *(int *) p;
				} else if (type == TYPE_flt) {
					lval = (lng) *(flt *) p;
				} else if (type == TYPE_dbl) {
					lval = (lng) *(dbl *) p;
				} else if (type == TYPE_lng) {
					lval = *(lng *) p;
				} else {
					return_error(type_error);
				}
#ifdef NATIVE_WIN32
				for (i = len; i >= (extra + 2); i--) {
					meta[i + 1] = meta[i];
				}
				meta[extra] = 'I';
				meta[extra + 1] = '6';
				meta[extra + 2] = '4';
#endif
				@:sprintf(lval)@
			} else if (strchr("feEgG", *cur)) {
				dbl dval;

				if (type == TYPE_flt) {
					dval = (dbl) *(flt *) p;
				} else if (type == TYPE_dbl) {
					dval = *(dbl *) p;
				} else {
					return_error(type_error);
				}
				width += (1 + prec);
#ifndef HAVE_SNPRINTF
				/* Brute force; this size always fits a double */
				width += 300;
#endif /* HAVE_SNPRINTF */
				@:sprintf(dval)@
			} else if (*cur == 's') {
				int len;

				if (extra) {
					return_error(format_error);
				} else if (type != TYPE_str) {
					return_error(type_error);
				}
				len = strLen(p);
				width++;
				prec++;	/* account for '\0' */
				if (dotseen && prec < len)
					len = prec;
				if ((size_t) len > width)
					width = (size_t) len;
				@:sprintf(p)@
			} else {
				return_error(format_error);
			}
			width = strlen(add);
			@:writemem(width)@
			memcpy(dst, add, width);
			dst += width;
			paramseen = NULL;
			argc++;
		} else if (!escaped) {
			if (*cur == '\\' || (*cur == '%' && cur[1] == '%')) {
				escaped = 1;
			} else if (*cur == '%') {
				paramseen = cur;
				dotseen = prec = 0;
				width = 0;
			} else {
				@:writemem(1)@
				*dst++ = *cur;
			}
		} else {
			escaped = 0;
			@:writemem(1)@
			*dst++ = *cur;
		}
	}

	if (va_arg(ap, char *) != NULL)
		 GDKwarning("monet_sprintf(): params %d and beyond ignored.\n", argc);

	@:writemem(1)@
	*dst = 0;
	*res = buf;
	return GDK_SUCCEED;
}


@- monet_syscall
this generic function can be used to call a C function with C-like
parameters extracted from a (argc,argv) setup.

This is quite tricky as we build a stack of integers by going through
the argv[] list. This stack will be used in a totally dependent way
by the C-routine. No checks possible.
Unsafe to call:  BE SURE TO PASS WHAT THE 'addr' ROUTINE EXPECTS
@c
int
monet_syscall(GDKfcn addr, int argc, ValPtr argv)
{
	int i, j;
	ssize_t v[MAXPARAMS * 2];

@-
Convert all parameter values to integers.
@c
	for (i = j = 0; i < argc; i++) {
		int tpe;

		if (argv[i].vtype == TYPE_bat) {
			argv[i].val.sval = (str) BBPname(argv[i].val.bval);
			argv[i].vtype = TYPE_str;
		}
		tpe = ATOMstorage(argv[i].vtype);
		if (tpe == TYPE_void)
			continue;

		/* normal passing conversions */
		if (tpe == TYPE_chr) {
			argv[i].val.ival = (int) argv[i].val.cval[0];
			tpe = TYPE_int;
		} else if (tpe == TYPE_bte) {
			argv[i].val.ival = (int) argv[i].val.btval;
			tpe = TYPE_int;
		} else if (tpe == TYPE_sht) {
			argv[i].val.ival = (int) argv[i].val.shval;
			tpe = TYPE_int;
		} else if (tpe == TYPE_flt) {
			argv[i].val.dval = (dbl) argv[i].val.fval;
			tpe = TYPE_lng;
		}
#if (SIZEOF_SIZE_T==8)
		/* 64-bits passing conversions */
		if (tpe == TYPE_int) {
			argv[i].val.lval = (lng) argv[i].val.ival;
			tpe = TYPE_lng;
		}
		v[j++] = argv[i].val.lval;
#else
		if (ATOMsize(tpe) == sizeof(int)) {
			v[j++] = argv[i].val.ival;
		} else {
#ifdef WORDS_BIGENDIAN
			v[j++] = (ssize_t) (argv[i].val.lval & LL_CONSTANT(0xFFFFFFFF));
			v[j++] = (ssize_t) (argv[i].val.lval >> 32);
#else
			v[j++] = (ssize_t) (argv[i].val.lval >> 32);
			v[j++] = (ssize_t) (argv[i].val.lval & LL_CONSTANT(0xFFFFFFFF));
#endif
		}
#endif
	}
@-
Now pass these integers.
@c
	switch (j) {
	case 0:
		return (*addr) ();
	case 1:
		return (*addr) (v[0]);
	case 2:
		return (*addr) (v[0], v[1]);
	case 3:
		return (*addr) (v[0], v[1], v[2]);

	case 4:
		return (*addr) (v[0], v[1], v[2], v[3]);
	case 5:
		return (*addr) (v[0], v[1], v[2], v[3], v[4]);
	case 6:
		return (*addr) (v[0], v[1], v[2], v[3], v[4], v[5]);
	case 7:
		return (*addr) (v[0], v[1], v[2], v[3], v[4], v[5], v[6]);
	case 8:
		return (*addr) (v[0], v[1], v[2], v[3], v[4], v[5], v[6], v[7]);
	}
@-
For all other #param cases, just pass all of them (this works).
@c
	return (*addr) (v[0],  v[1],  v[2],  v[3],  v[4],  v[5],  v[6],  v[7],
			v[8],  v[9],  v[10], v[11], v[12], v[13], v[14], v[15],
			v[16], v[17], v[18], v[19], v[20], v[21], v[22], v[23],
			v[24], v[25], v[26], v[27], v[28], v[29], v[30], v[31],
			v[32], v[33], v[34], v[35], v[36], v[37], v[38], v[39],
			v[40], v[41], v[42], v[43], v[44], v[45], v[46], v[47],
			v[48], v[49], v[50], v[51], v[52], v[53], v[54], v[55],
			v[56], v[57], v[58], v[59], v[60], v[61], v[62], v[63]);
}

@- monet_sigerror
this function prints a beautified error message for a function that
did not resolve well.
@c
int
monet_sigerror(str kind, str name, str extra, int argc, ValPtr argv)
{
	char buf[4096], *p = buf;
	BAT *b;
	int i;

	strcpy(p, name);
	p += strlen(p);
	*(p++) = '(';
	for (i = 1; i < argc; i++) {
		if (i > 1) {
			*(p++) = ',';
			*(p++) = ' ';
		}
		strcpy(p, ATOMname(argv[i].vtype));
		p += strlen(p);
		if ((argv[i].vtype == TYPE_bat) && (b = BATdescriptor(argv[i].val.bval))) {
			*(p++) = '[';
			strcpy(p, ATOMname((b->hseqbase == oid_nil)?b->htype:ATOMtype(b->htype)));
			p += strlen(p);
			*(p++) = ',';
			strcpy(p, ATOMname((b->tseqbase == oid_nil)?b->ttype:ATOMtype(b->ttype)));
			p += strlen(p);
			*(p++) = ']';
			BBPunfix(b->batCacheid);
		}
	}
	*(p++) = ')';
	*p = 0;
	if (extra) {
		GDKerror("interpret: no matching %s to '%s'.\n%s", kind, buf, extra);
	} else {
		GDKerror("interpret: %s invocation of '%s' with illegal types.\n", kind, buf);
	}
	return 0;
}

@-
the below routine tries to derive every possible property from a
given BAT. It should be fired off on new BATs in the MIL interpreter
in order to achieve optimal optimization decisions being made in MIL
algebra programs.
@c
static int _t3 = 0;
void
monet_checkbat(BAT *b, int protect)
{
	int _t2, _t1 = 0;
	BATDEBUG _t1 = GDKms();

@-
If we look at the copied column of a VIEWcombine (MIL mirror) BAT,
we can skip checking, as we can assume the reverse column will get checked.
@c
	if (b->H != b->T) {
		BATpropcheck(BATmirror(b), BATPROPS_QUICK);
	}
	BATpropcheck(b, BATPROPS_QUICK);
/*
 * StM: moved to CATCHVAL in yytree.mx, so it get's executed with GDKdebug=0, too.
 *
	if (protect) {
		PROPDEBUG if (BATgetaccess(b) != BAT_READ)
		GDKwarning("monet_checkbat: setting BAT %s BAT_READ.\n", BATgetId(b));
		BATsetaccess(b, BAT_READ);
	}
*/
	(void) protect;
	BATDEBUG {
		_t2 = GDKms() - _t1;
		_t3 += _t2;
		THRprintf(GDKerr, "check %s = %d (tot %d)\n", BATgetId(b), _t2, _t3);
	}
}
