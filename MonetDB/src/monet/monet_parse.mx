@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2005 CWI.
@' All Rights Reserved.

@f monet_parse
@a M. L. Kersten, P. Boncz

@* Parsing BAT algebra
@T
We will discuss how BAT algebra is lexically analyzed with {\tt lex},
parsed with {\tt yacc}, and discuss the dunction table.

@+ The lexical analyzer
The implementation of the lexical analyzer is straightforward:
the input is read from the client message buffer, from which all
tokens are extracted.

The variable YYLMAX should be increased to handle large strings.
[It would be better to adapt the lexical analyzer to
deal with 'infinite strings'. In fact, the input resides in the client
buffer, which is not reused until end-of-block. It can not be used,
because parse trees may be kept around for re-use]

@l
D	[0-9]
O	[0-7]
L	[_a-zA-Z\x80-\xff]
E	[Ee][-+]?{D}+
S	[\t\n ]*
P	[-!\$%\^\*~+|?<>/\\]
C	[!<>]
%{

#include "monet_parse.h"
#include "monet_tbl.h"

/* only needed for lex (we need  a big yytext array, since comments can
 * be lengthy. For lexis where yytext is a pointer this is not a problem
 * because they grow dynamically. But we must take care of copying yytext
 * before any unput is called.
 */
#define YYLMAX 100000

#ifndef FLEX_SCANNER
extern YYSTREE yylval;
#endif
#define YY_NEVER_INTERACTIVE	1 /* workaround to flex bug */
#define YY_USE_PROTOS		/* make sure ANSI-C prototyes are used */

char *lexname[] = {
	"TOK_ITERTEMP", "TOK_TEMPLATE", "TOK_VARTEMP", "TOK_RANGETEMP",
	"TOK_CONSTANT", "TOK_ASSIGNMENT", "TOK_SEQBLOCK", "TOK_SEQ",
	"TOK_PARBLOCK", "TOK_PAREND", "TOK_IDENT", "TOK_IF", "TOK_WHILE",
	"TOK_ITERATOR", "TOK_ITCOMPILED", "TOK_BREAK", "TOK_RETURN",
	"TOK_VAR", "TOK_ATOM", "TOK_CONST", "TOK_BUILTIN", "TOK_CAST",
	"TOK_BATCAST", "TOK_BATCONV", "TOK_TRG", "TOK_FUNCTION", "TOK_PROC",
	"TOK_COMPILED", "TOK_COMMAND", "TOK_OPERATOR0", "TOK_OPERATOR",
	"TOK_OPERATOR1", "TOK_SETOP", "TOK_ASSIGNOP", "TOK_SETAGGR",
	"TOK_PROCDEF", "TOK_STRING", "TOK_OBJECT", "TOK_ITERATION",
	"TOK_ELSE", "TOK_BAT", "TOK_TRGDEF", "TOK_ON", "TOK_MODULE",
	"TOK_DROP", "TOK_EVENT", "TOK_ANY", "TOK_UNDEF", "TOK_DEREF",
	"TOK_ANYNUM", 0,
};

char *
LEXNAME(int Y)
{
	if (Y >= TOK_ITERTEMP && Y <= TOK_ANYNUM) {
		return lexname[Y-TOK_ITERTEMP];
	} else {
		return "char";
	}
}

#define RETURN(Y)							\
	do {								\
		ll_lastval = Y;						\
		PARSEDEBUG {						\
			THRprintf(GDKerr, "%s %s\n", LEXNAME(Y), yytext); \
		}							\
		switch (ll_lastval) {					\
		case TOK_CONSTANT:					\
		case TOK_IDENT:						\
		case ')':						\
			BEGIN(IDCONST);					\
			break;						\
		default:						\
			BEGIN(0);					\
			break;						\
		}							\
		return Y;						\
	} while (0)
#ifdef FLEX_SCANNER
/*
#define YY_INPUT(buf,result,max_size)	{ int c = ll_getch();\
			   result = (c==0) ? YY_NULL: (buf[0] = (char)c,1);}
*/
#define YY_INPUT(buf,result,max_size)	(result = ll_getstring(buf,max_size))
#else
#undef input
#define input()		(yytchar = yysptr > yysbuf ? U(*--yysptr) : ll_getch())
#endif
#define Symbol(X)	RETURN(X)
#define Vector(X,Y,Z,V,L)			\
	do {					\
		yylval = Myylognode((X), (Y));	\
		yylval->yyval.val.Z = (V);	\
		yylval->yyval.len = (L);	\
		RETURN(X);			\
	} while (0)
#define Function(X,V)							\
	do {								\
		if ((X)==TOK_BUILTIN) {					\
			Vector(X, TYPE_ptr, pval, (ptr) V, 0);		\
		} else {						\
			str _s = GDKstrdup(V);				\
			Vector(X, TYPE_str, sval, _s, strLen(_s));	\
		}							\
	} while (0)

void
ll_flushbuffer(void)
{
#ifdef FLEX_SCANNER
	YY_FLUSH_BUFFER;
#else
	extern char yytext[];
	bzero(yytext, YYLMAX);
#endif
}

#define TBLSEARCH(r,s,token,cur_is_ident,guess_if_notfound,no_command)	\
	do {								\
		int spaces = 0, offend;					\
		do {							\
			offend = input();				\
		} while (GDKisspace(offend));				\
		if (offend && offend != EOF)				\
			unput(offend);					\
		while (spaces-- > 0)					\
			unput(' ');					\
		r = TBL_search(s, token, guess_if_notfound, cur_is_ident, \
			       no_command && ll_nocommand[offend],	\
			       (offend >= 'a' && offend <= 'z') ||	\
			       (offend >= 'A' && offend <= 'Z'));	\
	} while (0)

static void ll_skipcomment(void);
static str ll_getstr(int quote, int *len);
%}
%p 3400
%a 2300
%e 2000
%pointer
%s IDCONST
%%
"#"			ll_skipcomment();
("nil"|"NIL")		Vector(TOK_CONSTANT, TYPE_void, oval, void_nil, 0);
("proc"|"PROC")		Symbol(TOK_PROCDEF);
("undef"|"UNDEF")	Symbol(TOK_UNDEF);
("return"|"RETURN")	Symbol(TOK_RETURN);
("break"|"BREAK")	Symbol(TOK_BREAK);
("while"|"WHILE")	Symbol(TOK_WHILE);
("if"|"IF")		Symbol(TOK_IF);
("else"|"ELSE")		Symbol(TOK_ELSE);
("false"|"FALSE")	Vector(TOK_CONSTANT, TYPE_bit, cval[0], 0, 0);
("var"|"VAR")		Symbol(TOK_VAR);
("const"|"CONST")	Symbol(TOK_CONST);
("true"|"TRUE")		Vector(TOK_CONSTANT, TYPE_bit, cval[0], 1, 0);
("trigger"|"TRIGGER")	Symbol(TOK_TRGDEF);
("event"|"EVENT")	Symbol(TOK_EVENT);
("on"|"ON")		Symbol(TOK_ON);
("module"|"MODULE")   { if (!ll_modcmds)
				Symbol(TOK_MODULE);
			else
				goto command;
		      }
("any"|"ANY")		Vector(TOK_ANY, TYPE_int, ival, -1, 0);
"$("			Symbol(TOK_VARTEMP);
".."			Symbol(TOK_RANGETEMP);
"::"			Symbol(TOK_ANYNUM);
("$h"|"$H"|"$head"|"$HEAD")	Vector(TOK_ITERTEMP, TYPE_int, ival, 1, 0);
("$t"|"$T"|"$tail"|"$TAIL")	Vector(TOK_ITERTEMP, TYPE_int, ival, 2, 0);
"$"{D}+			Vector(TOK_TEMPLATE, TYPE_int, ival, atoi(yytext+1), 0);
":="			Symbol(TOK_ASSIGNMENT);
"(*"			Symbol(TOK_DEREF);
"[*"			Symbol(TOK_SETOP);
"{*"			Symbol(TOK_SETAGGR);
"@"			Symbol(TOK_ITERATION);
(":"{P}+"=") |
({P}+) |
({C}*"=")	      { int i, l = (int) strlen(yytext);
			char *s, *t = (str) alloca(l+1);
			strcpy(t, yytext); /* copy yytext before unput */
			if (l > 1 || (*t != '~' && *t != '?' && *t != ':')) {
				if (ll_resolution) {
					TBLSEARCH(s, t, &i, FALSE, TRUE, FALSE);
					if (s != NULL) {
						Function(i, s);
					}
				}
			}
			while (--l > 0)
				unput(t[l]);
			Symbol(*t);
		      }
(":"{L}({L}|{D})*"=") |
({L}({L}|{D})*)	 {
command:	      {	int i, l = (int) strlen(yytext);
			char *s, *t = (str) alloca(l + 1);
			strcpy(t, yytext); /* copy yytext before unput */
			if (ll_resolution) {
				TBLSEARCH(s, t, &i, TRUE, TRUE, TRUE);
				if (s != NULL) {
					Function(i, s);
				}
			}
			s = GDKstrdup(t);
			Vector(TOK_IDENT, TYPE_str, sval, s, 0);
		      }
		 }

("["{P}+"]") |
("["{C}*"=]") |
("[:"{P}+"=]") |
("["{L}({L}|{D})*"]") |
("[:"{L}({L}|{D})*"=]") |
("{"{L}({L}|{D})*"}") { int i, l = (int) strlen(yytext);
			char *s, *t = (str) alloca(l+1);
			strcpy(t, yytext); /* copy yytext before unput */
			if (ll_resolution) {
				char cb = t[l-1];      /* save bracket */
				TBLSEARCH(s, t, &i, TRUE, FALSE, FALSE);
				if (s) {
					Function(i, s);
				}
				t[l-1] = 0; /* remove last bracket */
				TBLSEARCH(s, t+1, &i, TRUE, TRUE, FALSE);
				if (s != NULL) {
					if (i == TOK_BUILTIN) {
						GDKerror("yyparse: cannot use a %cBUILTIN%c()\n", *t, (*t=='[')?']':'}');
					} else if (i != TOK_ASSIGNOP || *t == '[') {
						str nme = (str) alloca((int)strlen(s)+3);
						sprintf(nme, "%c%s%c", *t, s, cb);
						Function(i, nme);
					}
				}
			}
			yyleng--;
			unput(*t == '[' ? ']' : '}');
			while (--yyleng > 0)
				unput(t[yyleng]);
			Symbol(*t);
		      }
{D}+"@"{D}+	      { oid obj, *p=&obj;
			int l=sizeof(oid);
			OIDfromStr(yytext, &l, &p);
			Vector(TOK_CONSTANT, TYPE_oid, oval, obj, 0);
		      }
<INITIAL>"-"{D}+"LL"  { lng val, *p = &val; int l=sizeof(lng);
			lngFromStr(yytext, &l, &p);
			Vector(TOK_CONSTANT, TYPE_lng, lval, val, 0);
		      }
<INITIAL>"-"{D}+      { lng val, *p = &val; int l=sizeof(lng);
			lngFromStr(yytext, &l, &p);
			if (val > (lng) GDK_int_min &&
			    val <= (lng) GDK_int_max)
				Vector(TOK_CONSTANT, TYPE_int, ival, ((int) val), 0);
			else
				Vector(TOK_CONSTANT, TYPE_lng, lval, val, 0);
		      }
<INITIAL>"-"{D}+"."{D}+({E})?"LL" |
"-""."{D}+({E})?"LL" |
"-"{D}+{E}"LL"        { dbl val, *p = &val;
			int l = sizeof(dbl);
			dblFromStr(yytext, &l, &p);
			Vector(TOK_CONSTANT, TYPE_dbl, dval, val, 0);
		      }
<INITIAL>"-"{D}+"."{D}+({E})? |
"-""."{D}+({E})? |
"-"{D}+{E}	      { flt val, *p = &val;
			int l = sizeof(flt);
			fltFromStr(yytext, &l, &p);
			Vector(TOK_CONSTANT, TYPE_flt, fval, val, 0);
		      }
{D}+"LL"	      { lng val, *p = &val;
			int l=sizeof(lng);
			lngFromStr(yytext, &l, &p);
			Vector(TOK_CONSTANT, TYPE_lng, lval, val, 0);
		      }
{D}+		      { lng val, *p = &val;
			int l = sizeof(lng);
			lngFromStr(yytext, &l, &p);
			if (val > (lng) GDK_int_min &&
			    val <= (lng) GDK_int_max)
				Vector(TOK_CONSTANT, TYPE_int, ival, ((int) val), 0);
			else
				Vector(TOK_CONSTANT, TYPE_lng, lval, val, 0);
		      }
{D}+"."{D}+({E})?"LL" |
"."{D}+({E})?"LL"	    |
{D}+{E}"LL"	      { dbl val, *p = &val;
			int l = sizeof(dbl);
			dblFromStr(yytext, &l, &p);
			Vector(TOK_CONSTANT, TYPE_dbl, dval, val, 0);
		      }
{D}+"."{D}+({E})? |
"."{D}+({E})?	|
{D}+{E}		      { flt val, *p = &val;
			int l = sizeof(flt);
			fltFromStr(yytext, &l, &p);
			Vector(TOK_CONSTANT, TYPE_flt, fval, val, 0);
		      }
"'"\\0{O}({O})?({O})?"'" {
			unsigned int i;
			sscanf(yytext+2, "%o", &i);
			Vector(TOK_CONSTANT, TYPE_chr, cval[0], i, 0);
		      }
\"		      { int len;
			str s = ll_getstr(*yytext, &len);
			len = strFromStr(s, &len, &s);
			Vector(TOK_STRING, TYPE_str, sval, s, len);
		      }
\'		      { int len;
			str s = ll_getstr(*yytext, &len);
			char val, *p = &val;
			len = chrFromStr(s, &len, (ptr) &p);
			GDKfree(s);
			Vector(TOK_CONSTANT, TYPE_chr, cval[0], val, 0);
		      }
"{|"			Symbol(TOK_PARBLOCK);
"|}"			Symbol(TOK_PAREND);
{S}			/* skip white space */
.			Symbol((int) (unsigned char) *yytext);
%%
void
ll_skipcomment(void)
{
	int c;

	while ((c = input()) != 0 && c != EOF && c != '\n')
		;
}

static str
ll_getstr(int quote, int *len)
{
	str buf;
	size_t buflen;
	size_t i;
	int c;

	buflen = 128;
	buf = GDKmalloc(buflen + 2);
	i = 0;
	buf[i++] = quote;

	while ((c = input()) != 0 && c != EOF && c != quote) {
		if (c == '\\') {
			if ((c = input()) == 0 || c == EOF)
				break;
			if (c == '\n')
				continue;
			buf[i++] = '\\';
		}
		if (i >= buflen)
			buf = GDKrealloc(buf, (buflen += 128) + 2);
		buf[i++] = c;
	}
	buf[i++] = quote;
	buf[i] = 0;
	*len = (int) i;
	return buf;
}
@
@-
The routine @%ll_getch@ manipulates the input buffer for the current
client indicated by @%ll_client@.

BLACK MAGIC: the parse module-stack. In order to execute module initialize scripts in the correct
order we maintain a stack of scripts (= MIL input buffers).

In case of modules that include other modules, what happens is that the init scripts of the
included modules are put in front of each other. E.g. module(a); causes module(b) also
to be loaded, and b should be initialized before a.

But, parsing also loads (indepent) modules in sequence , e.g. module(a,c); In this case,
we get the initialization sequence a,b,c; and *not* c,b,a, which would happen if we would
alwas include initialization scripts upfront.

This behavior is steered by setting ll_reset() (i.e. ll_insert = NULL) in the parser at
TOK_MODULE after having included one module fully.

Ah. and don't confuse the parser module-stack with the execution module-stack (in monet_client.mx).
That one is used to obtain the module-id of the currently *executing* (not parsing) module
initialization script.
@c
#include "monet_parse.h"

Client ll_client = 0;
int ll_nlines = 0;		/* current number of string chunks */
int ll_maxlines = 0;		/* maximum number of string chunks */
str *ll_lines = 0;		/* string chunks */

char ll_nocommand[256] = { 0 };
int ll_lastval = 0;

typedef struct _strstack_t {
	str cleanup, cptr, cline, mod;
	struct _strstack_t *up;
} strstack;

strstack *ll_insert = NULL, *ll_stack = NULL;
str ll_mod = NULL;


void
ll_reset()
{
	ll_insert = NULL;
}

int
ll_push(str s, str mod)
{
	strstack *sp = (strstack *) GDKmalloc(sizeof(strstack));

	if (ll_insert) {
		*sp = *ll_insert;
		ll_insert->up = sp;
		ll_insert->cline = ll_insert->cptr = s;
		ll_insert->mod = GDKstrdup(mod);
		ll_insert = sp;
	} else {
		sp->cline = ll_client->cline;
		sp->cptr = ll_client->cptr;
		sp->mod = ll_mod;
		ll_mod = GDKstrdup(mod);
		ll_client->cline = ll_client->cptr = s;
		sp->up = ll_stack;
		ll_insert = ll_stack = sp;
	}
	sp->cleanup = s;
	return 1;
}

int
ll_pop(void)
{
	strstack *sp = ll_stack;

	if (ll_stack) {
		ll_insert = NULL;
		ll_stack = sp->up;
		if (ll_mod)
			GDKfree(ll_mod);
		ll_mod = sp->mod;
		if (sp->cleanup)
			GDKfree(sp->cleanup);
		ll_client->cptr = sp->cptr;
		ll_client->cline = sp->cline;
		GDKfree(sp);
		return 1;
	}
	return 0;
}

str
ll_parent_module()
{
	if (ll_mod)
		return ll_mod;
	return moduleGetClient(ll_client);
}

int
ll_getch(void)
{
	char ch;

	if (ll_client == 0) {
		GDKfatal("parser: no client for lexical.\n");
	}
	do {
		ch = *ll_client->cptr;
	} while (ch == 0 && ll_pop());

	if (ch == '\n') {
		if (ll_client->listing) {
			if (GDKdebug & 16384 || !ll_stack) {
				stream *s = ll_client->fdout;

				if (stream_write(s, ll_client->cline, ll_client->cptr - ll_client->cline + 1, 1) < 0 || stream_flush(s))
					GDKdebug &= ~16384;	/* stop logging after error */
			}
		}
		ll_client->cline = ll_client->cptr + 1;
	}
	if (ch)
		ll_client->cptr++;
	return ch;
}

int
ll_getstring(char *buf, int max_size)
{
	char *start = buf, *end = buf + max_size;
	char ch;
	int statement = 0;

	if (ll_client == 0) {
		GDKfatal("parser: no client for lexical.\n");
	}
	while (buf < end) {
		do {
			ch = *ll_client->cptr;
		} while (ch == 0 && ll_pop());

		if (ch == 0)
			break;
		if (statement && !GDKisspace(ch)) {
			/* quit before non-whitespace after end of statement */
			break;
		}

		ll_client->cptr++;
		*buf++ = ch;

		if (ch == '\n') {
			/* quit after end of line */
			ll_client->cline = ll_client->cptr;
			break;
		}
		if (ch == ';') {
			/* end of statement (unless quoted);
			 * don't quit, yet, but read trailing whitespaces */
			statement = 1;
		}
	}
	if (ll_client->listing && (GDKdebug & 16384 || !ll_stack)) {
		stream *s = ll_client->fdout;

		if (stream_write(s, start, 1, buf - start) < 0 || stream_flush(s))
			GDKdebug &= ~16384;	/* stop logging after error */
	}
	return (int) (buf - start);
}


void
ll_init(void)
{
	ll_lines = (str *) GDKmalloc((ll_maxlines = 500) * sizeof(str));

	/* when these chars are seen after an identifier, MIL language constructs impede it be an operator */
	ll_nocommand[(int) ';'] = 1;	/* a  ; */
	ll_nocommand[(int) ','] = 1;	/* fcn(a  , b) */
	ll_nocommand[(int) ')'] = 1;	/* fcn(a  ) */
	ll_nocommand[(int) '.'] = 1;	/* a . fcn(..) */
	ll_nocommand[(int) '@'] = 1;	/* a @ batloop() */
	ll_nocommand[(int) '?'] = 1;	/* a ? b : c */
	ll_nocommand[(int) ':'] = 1;	/* b ? a : c ALSO a := ... */
	ll_nocommand[(int) ']'] = 1;	/* b@batloop[ a ]() .. */
	ll_nocommand[(int) '['] = 1;	/* b@batloop[ a ]() .. */

	/* operator starter symbols (an operator cannot come after an operator) */
	ll_nocommand[(int) '<'] = 1;	/* a < .. */
	ll_nocommand[(int) '>'] = 1;	/* a > .. */
	ll_nocommand[(int) '='] = 1;	/* a = .. */
	ll_nocommand[(int) '%'] = 1;	/* a % b */
	ll_nocommand[(int) '/'] = 1;	/* a / b */
	ll_nocommand[(int) '-'] = 1;	/* a - b */
	ll_nocommand[(int) '+'] = 1;	/* a + b */
	ll_nocommand[(int) '*'] = 1;	/* a * b */

	/* symbols not yet used that in the future may be first chars of operators */
	ll_nocommand[(int) '|'] = 1;
	ll_nocommand[(int) '~'] = 1;
	ll_nocommand[(int) '!'] = 1;
	ll_nocommand[(int) '^'] = 1;
	ll_nocommand[(int) '&'] = 1;
	ll_nocommand[(int) '\\'] = 1;
}

str
ll_lastline(void)
{
	static char line[1024];
	char *l = line, *s = ll_client->cline;
	int c = *s--;

	if (ll_emptychar(c)) {
		while ((s >= ll_client->input) && ll_emptychar(c = *s))
			s--;
		while ((s >= ll_client->input) && *s && (*s != '\n'))
			s--;
	}
	if (ll_client->cline - s > 512) {
		s = ll_client->cline - 40;
	}
	while ((c = *++s) != 0) {
		if (c == '\n' || l > line + 1000)
			break;
		*l++ = c;
	}
	*l = 0;
	return line;
}

@+ The Parser
@h
#ifndef _MONET_PARSE_H
#define _MONET_PARSE_H

#include "monet.h"

#define YY_NEVER_INTERACTIVE	1	/* bison brain damage evasion */

m_export int ll_modcmds;	/* are "module" cmd or tokens? */
m_export int ll_resolution;	/* perform ident-->MIL resolution */
m_export Client ll_client;
m_export int ll_nlines;		/* current number of string chunks */
m_export int ll_maxlines;	/* maximum number of string chunks */
m_export str *ll_lines;		/* string chunks */
m_export int ll_parblockdepth;
m_export YYSTREE ll_firstnode, ll_sugarnode;
m_export int ll_templates;
m_export int ll_argc;
m_export char ll_nocommand[256];
m_export int ll_lastval;

#define ll_emptychar(x)	((x == 0) || GDKisspace(x))

m_export int CMDconstant(Cntxt stk, YYSTREE lt, ValPtr res);


m_export void ll_flushbuffer(void);
m_export int ll_getstring(char *buf, int max_size);
m_export int ll_push(str s, str mod);
m_export void ll_reset();
m_export str ll_parent_module();

#endif /* _MONET_PARSE_H */

@- Global variables for YACC
@c
int ll_parblockdepth = 0;	/* nesting depth of paralellism. */
int ll_templates = 0;		/* are templates currently allowed? */
int ll_modcmds = 0;		/* are "module" cmd or tokens? */
int ll_resolution = 1;		/* perform ident-->MIL resolution */
YYSTREE ll_firstnode, ll_sugarnode;	/* for parsing OO sugar syntax XX.op(YY) */
int ll_argc = 0;		/* */

@-
The Monet interpreter language provides a sugar version to OO
programming by considering the first argument the receiver of the method.
@c
YYSTREE
yysugar(YYSTREE node)
{
	YYSTREE t = Myylognode(0, TYPE_ptr);

	if (node) {
		Myylogexpand(t, node);	/* put the sugar argument in front. */
	}
	ll_sugarnode = NULL;
	return t;
}

int
yywrap(void)
{
	return 1;
}

@- The YACC Grammar
@T
A parse tree is built during parsing, such that a compact
representation for function calls result.

The code below is
{\tt yacc} input format. Executing {\tt yacc} produces the file
{y.tab.c}, which contains the parsing routine {\tt yyparse()}. It
parses the grammar, executing the inlined C statements along the way.
@
@y


%{
#ifndef YYSTYPE
#define YYSTYPE	YYSTREE
#endif

#include "monet_parse.h"	/* includes monet.h */


#define YYDEBUG	0

static void ll_parserror(str msg);

extern int yylex(void);

#undef yyerror
#define yyerror(X)	ll_parserror(NULL);
#define yylogkill(t)	((t)->yyval.vtype = TYPE_void)
#define yylogfree(t)

extern YYSTREE yysugar(YYSTREE node);
%}

%token TOK_ITERTEMP TOK_TEMPLATE TOK_VARTEMP TOK_RANGETEMP
%token TOK_CONSTANT TOK_ASSIGNMENT TOK_SEQBLOCK TOK_SEQ TOK_PARBLOCK
%token TOK_PAREND TOK_IDENT TOK_IF TOK_WHILE TOK_ITERATOR
%token TOK_ITCOMPILED TOK_BREAK TOK_RETURN TOK_VAR TOK_ATOM
%token TOK_CONST TOK_BUILTIN TOK_CAST TOK_BATCAST TOK_BATCONV TOK_TRG
%token TOK_FUNCTION TOK_PROC TOK_COMPILED TOK_COMMAND
%token TOK_OPERATOR0 TOK_OPERATOR TOK_OPERATOR1
%token TOK_SETOP TOK_ASSIGNOP TOK_SETAGGR TOK_PROCDEF
%token TOK_STRING TOK_OBJECT TOK_ITERATION TOK_ELSE TOK_BAT
%token TOK_TRGDEF TOK_ON TOK_MODULE TOK_DROP TOK_EVENT
%token TOK_ANY TOK_UNDEF TOK_DEREF TOK_ANYNUM

%left TOK_OPERATOR0
%left TOK_OPERATOR
%left TOK_OPERATOR1
%%
program:
	monet_session
	{
		ll_client->tree = Myylogout($1);
		if (ll_client->tree == NULL) {
			ll_clrids();
			yyerrok;
			yyclearin;
			ll_lastval = 0;
			return 1;
		}
		ll_lastval = 0;
	}
    |	error ';'
	{
		ll_clrids();
		yyerrok;
		yyclearin;
		ll_lastval = 0;
		return 1;
	}
    |	/* empty */
	{ $$ = NULL; }
    ;

monet_session:
	session
	{
		if (!$1 || $1->token != TOK_SEQ) {
			$$ = Myylognode(TOK_SEQ, 0);
			if ($1)
				Myylogexpand($$, $1);
		} else
			$$ = $1;
	}
    |	monet_session session
	{
		$$ = $1;
		if ($2)
			Myylogexpand($$, $2);
	}
    ;

session:
	';'
	{   $$ = 0 ;							      }
    |	definition
	{   $$ = 0 ;							      }
    |	statement
	{   $$ = $1;							      }
    |	TOK_MODULE { $$ = NULL; ll_resolution = 0; } '(' modidents ')' ';'
	{
		YYSTREE lt = $4;
		str initstr;
		str parmod = ll_parent_module();
		ll_resolution = 1;
		/* EXECUTE MODULE LOAD *DURING* PARSE!!*/
		while (lt) {
			unsigned i;
			for(i = 0; i < lt->cnt; i++)  {
				str mod;

				if (!lt->yysons[i])
					continue;
				if ((int) lt->yysons[i]->token == monet_tokident) {
					mod = arg(lt, i)->yyval.val.sval;
				} else {
					ValRecord res;
					int ret = interpret(ll_client->stk, lt->yysons[i], &res);
					if (ret < 0 || res.vtype != TYPE_str) {
						GDKerror("module: illegal argument.\n");
					}
					mod = res.val.sval;
				}
				initstr = moduleClient( ll_client, mod, parmod );
				if (initstr != NULL) {
					ll_push(initstr,mod);
				}
			}
			ll_reset();
			lt = YYOVERFLOW(lt);
		}
		$$ = 0;
		yylogfree($4);
	}
    ;

definition:
	proc_definition
    ;

statement_seq:
	/* empty */
	{   $$ = Myylognode(TOK_SEQ,0);					      }
    |	statement_list
	{   $$ = $1;							      }
    ;

statement_list:
	statement
	{   $$ = $1;							      }
    |	statement_list statement
	{
		if ($1->token != TOK_SEQ) {
			$$ = Myylognode(TOK_SEQ, 0);
			Myylogexpand($$, $1);
		} else
			$$ = $1;
		Myylogexpand($$, $2);
	}
    ;

statement:
	nonvar_statement
	{   $$ = $1;							      }
    |	TOK_VAR varidents ';'
	{   $$ = $2; $2->token = TOK_VAR;				      }
    |	TOK_CONST constidents ';'
	{
		YYSTREE t=$2,tt, n = Myylognode(TOK_BUILTIN, TYPE_ptr);
		unsigned i;
		n->yyval.val.pval = (ptr) CMDconstant;
		$$ = Myylognode(TOK_SEQ,0);
		$2->token = TOK_VAR;
		Myylogexpand($$, $2); Myylogexpand($$,n);
		while (t) {
			for (i = 0; i < t->cnt; i++)
				if (t->yysons[i]) {
					Myylogexpand(n, tt = Myylognode(TOK_IDENT, TYPE_str));
					tt->yyval.val.sval = GDKstrdup(t->yysons[i]->yyval.val.sval);
				}
			n->cnt = t->cnt;
			if ((t = YYOVERFLOW(t)) != NULL) {
				n->yysons[n->capacity] = Myylognode(0, 0);
				n = YYOVERFLOW(n);
			}
		}
	}
    ;

nonvar_statement:
	simple_expression { $$ = NULL; ll_firstnode = $1; } expr_rest
	{ $$ = NULL; ll_sugarnode = $3; } expr_statement
	{    $$ = $5;							      }
    |	blk_expression
	{    $$ = $1;							      }
    |	TOK_RETURN ret_value ';'
	{
		$$ = Myylognode(TOK_RETURN, 0);
		if ($2)
			Myylogexpand($$, $2);
	}
    |	TOK_WHILE '(' expression ')' nonvar_statement
	{
		$$ = Myylognode(TOK_WHILE, 0);
		Myylogexpand($$, $3);
		Myylogexpand($$, $5);
	}
    |	TOK_IF '(' expression ')' nonvar_statement else_statement
	{
		$$ = Myylognode(TOK_IF, 0);
		Myylogexpand($$, $3);
		Myylogexpand($$, $5);
		if ($6)
			Myylogexpand($$, $6);
	}
    |	TOK_BREAK ';'
	{    $$ = Myylognode(TOK_BREAK, 0);				      }
    ;

expr_statement:
	';'
	{   $$ = ll_sugarnode; ll_sugarnode = NULL;			      }
    |	TOK_ITERATION parallel TOK_ITERATOR argument_list
	{   $$ = ll_templates ? (YYSTREE)(size_t)1 /* non-NULL */ : (ptr) 0; ll_templates = 1; } nonvar_statement
	{
		ll_templates = ($5 != NULL);
		Myylogexpand($3, $6);
		Myylogexpand($3, $4);
		if ($2)
			Myylogexpand($3, $2);
		$$ = $3;
	}
    ;

else_statement:
	TOK_ELSE nonvar_statement
	{   $$ = $2;							      }
    |	/* empty */
	{   $$ = NULL;							      }
    ;

ret_value:
	expression
	{   $$ = $1;							      }
    |	    /* empty */
	{   $$ = NULL;							      }
    ;

parallel:
	'[' expression ']'
	{   $$ = $2;							      }
    |	/* empty */
	{   $$ = NULL;							      }
    ;

sequential_block:
	'{' { $$ = ll_modcmds ? (YYSTREE) (size_t) 1 : 0; ll_modcmds = 1; } statement_seq '}'
	{
		ll_modcmds = ($2 != NULL);
		$$ = $3;
		if ($3->token == TOK_SEQ || $3->token == TOK_SEQBLOCK) {
			$3->token = TOK_SEQBLOCK;
		} else if ($3->token != TOK_PARBLOCK) {
			$$ = Myylognode(TOK_SEQBLOCK, 0);
			if ($3)
				Myylogexpand($$, $3);
		}
	}
    ;

parallel_block:
	TOK_PARBLOCK
	{
		ll_parblockdepth++;
		$$ = ll_modcmds ? (YYSTREE) (size_t) 1 : 0;
		ll_modcmds = 1;
	}
	statement_seq TOK_PAREND
	{
		ll_modcmds = ($2 != NULL);
		if (--ll_parblockdepth == 0)
			ll_clrids();
		if ($3->token == TOK_SEQBLOCK ||
		    $3->token == TOK_SEQ ||
		    $3->token == TOK_PARBLOCK) {
			$$ = $3;
			$$->token = TOK_PARBLOCK;
		} else {
			$$ = Myylognode(TOK_SEQBLOCK, 0);
			Myylogexpand($$, $3);
		}
	}
    ;

assignment:
	TOK_ASSIGNMENT expression
	{   $$ = $2;							      }
    |	/* empty */
	{   $$ = NULL;							      }
    ;

variable_reference:
	TOK_IDENT assignment
	{
		ll_idconflict($1->yyval.val.sval);
		$1->yyval.len = 0; /* var depth.. */
		if ($2) {
			$$ = Myylognode(TOK_ASSIGNMENT, 0);
			Myylogexpand($$, $1); Myylogexpand($$, $2);
		} else
			$$ = $1;
	}
    |	template assignment
	{
		$1->yyval.len = 0;
		if ($2) {
			$$ = Myylognode(TOK_ASSIGNMENT, 0);
			Myylogexpand($$, $1);
			Myylogexpand($$, $2);
		} else
			$$ = $1;
	}
    ;

proc_definition:
	TOK_PROCDEF proc_name proc_header
	proc_assign { $$ = NULL; ll_templates = ll_modcmds = 1; } sequential_block

	{
		YYSTREE sig = (YYSTREE) ($3 ? $3->yyval.val.pval : NULL);
		YYSTREE ret = (YYSTREE) (sig ? sig->yyval.val.pval : NULL);
		int params = ($3 && $3->cnt > 0);

		if (params || (($6->token != TOK_SEQ) &&
			       ($6->token != TOK_SEQBLOCK) &&
			       ($6->token != TOK_PARBLOCK))) {
			$$ = Myylognode(params ? TOK_SEQBLOCK : TOK_SEQ, 0);
			if (params)
				Myylogexpand($$, $3);
			Myylogexpand($$, $6);
		} else {
			$$ = $6;
		}
		if ($3 && $3->cnt == 0) {
			yylogfree($3);
		}
		$$->yyval = $2->yyval;
		$2->yyval.vtype = TYPE_void;

		/* DIRECT: insert the new proc */
		$$ = Myylogout($$);
		TBL_newproc(ll_client, $2->yyval.val.sval, ll_parent_module(), $$, sig, ret);
		if (sig) {
			yylogfree(sig);
		}
		if (ret) {
			yylogfree(ret);
		}
		ll_modcmds = ll_templates = 0;
	}
    |	TOK_PROCDEF proc_name ';'
	{
		$$ = NULL;
		$2 = Myylogout($2);
		TBL_newproc(ll_client, $2->yyval.val.sval, ll_parent_module(), $2, $2, NULL);
		$2->token = TOK_CONSTANT;
		$2->yyval.vtype = TYPE_int;
	}
    |	TOK_UNDEF TOK_IDENT ';'
	{   $$ = NULL; TBL_delproc(ll_client, $2->yyval.val.sval); }
    ;

proc_assign:
	TOK_ASSIGNMENT
    |	/* empty */
	{ $$ = NULL; }
    ;

proc_name:
	TOK_IDENT
	{ $$ = $1; $1->token = TOK_PROC;				      }
    |	TOK_STRING
	{ $$ = $1; $1->token = TOK_PROC;				      }
    |	TOK_ATOM
	{ $$ = $1; $1->token = TOK_PROC;				      }
    |	TOK_COMMAND
	{ $$ = $1; $1->token = TOK_PROC;				      }
    |	TOK_OPERATOR0
	{ $$ = $1; $1->token = TOK_PROC;				      }
    |	TOK_OPERATOR
	{ $$ = $1; $1->token = TOK_PROC;				      }
    |	TOK_OPERATOR1
	{ $$ = $1; $1->token = TOK_PROC;				      }
    |	TOK_PROC
	{ $$ = $1; }
    ;

proc_header:
	'(' mel_header ')' mel_return
	{
		YYSTREE header = (YYSTREE) $2->yyval.val.pval;
		if (header) {
			header->yyval.val.pval = $4;
			header->yyval.vtype = TYPE_ptr;
		}
		$$ = $2;
	}
    ;

mel_header:
	mel_params mel_tail
	{
		YYSTREE h = (YYSTREE) $1->yyval.val.pval;
		$$ = $1;
		if ($2)
			Myylogexpand(h,$2);
	}
    |	mel_range
	{
		YYSTREE n = Myylognode(0,0); Myylogexpand(n,$1);
		$$ = Myylognode(0,TYPE_ptr);
		$$->yyval.val.pval = (ptr) n;
	}
    |	/* empty */
	{
		$$ = Myylognode(0,TYPE_ptr);
		$$->yyval.val.pval = (ptr) Myylognode(0,0);
	}
    ;

mel_tail:
	',' mel_range
	{   $$ = $2;							      }
    |	/* empty */
	{   $$ = NULL;							      }
    ;

mel_range:
	TOK_RANGETEMP mel_type TOK_RANGETEMP
	{   $$ = Myylognode(TOK_RANGETEMP,0); Myylogexpand($$,$2);	      }
    ;

mel_params:
	mel_type TOK_IDENT
	{
		YYSTREE temp = Myylognode(TOK_TEMPLATE, TYPE_int);
		YYSTREE sig = Myylognode(0,0);
		Myylogexpand(sig, $1);
		ll_argc = 0; temp->yyval.val.ival = ++ll_argc;
		$2->token = TOK_ASSIGNMENT;
		Myylogexpand($2, Myylognode(TOK_TEMPLATE,0));
		Myylogexpand($2, temp);
		$$ = Myylognode(TOK_VAR,TYPE_ptr);
		Myylogexpand($$, $2);
		$$->yyval.val.pval = (ptr) sig;
	}
    |	mel_params ',' mel_type TOK_IDENT
	{
		YYSTREE temp = Myylognode(TOK_TEMPLATE, TYPE_int);
		YYSTREE sig = (YYSTREE) $1->yyval.val.pval;
		Myylogexpand(sig, $3);
		temp->yyval.val.ival = ++ll_argc;
		$4->token = TOK_ASSIGNMENT;
		Myylogexpand($4, Myylognode(TOK_TEMPLATE,0));
		Myylogexpand($4, temp);
		Myylogexpand($1, $4);
		$$ = $1;
	}
    ;

mel_type:
	TOK_ATOM mel_bat
	{
		$$ = ($2 && $2->token == TOK_ATOM) ? $2 : NULL;
		if ($2 && strcmp($2->yyval.val.sval, "BAT")) {
			ll_parserror("only bat types are parametrized");
		} else if ($2 == NULL && strcmp($1->yyval.val.sval, "BAT") == 0) {
			YYSTREE any1 = Myylognode(TOK_ANY,TYPE_int);
			YYSTREE any2 = Myylognode(TOK_ANY,TYPE_int);
			any1->yyval.val.ival = any2->yyval.val.ival = -1;
			$$ = Myylognode(TOK_ATOM, TYPE_str);
			$$->yyval.val.sval = GDKstrdup(BATatoms[TYPE_bat].name);
			Myylogexpand($$, any1);
			Myylogexpand($$, any2);
		}
		if ($$ == NULL) {
			Myylogexpand($$ = $1, $2);
		} else {
			yylogfree($1);
		}
	}
    |	mel_other
	{ $$ = $1;							      }
    ;

mel_bat:
	'[' mel_atom ',' mel_atom ']'
	{
		$$ = Myylognode(TOK_ATOM,TYPE_str);
		$$->yyval.val.sval = GDKstrdup(BATatoms[TYPE_bat].name);
		Myylogexpand($$,$2);
		Myylogexpand($$,$4);
	}
    |	/* empty */
	{ $$ = NULL;							      }
    ;

mel_atom:
	TOK_ATOM
	{ $$ = $1;							      }
    |	mel_other
	{ $$ = $1;							      }
    ;

mel_other:
	TOK_ANY mel_any
	{
		$$ = $1;
		if ($2) {
			$$->yyval = $2->yyval;
			yylogfree($2);
		}
	}
    ;

mel_any:
	TOK_ANYNUM TOK_CONSTANT
	{
		$$ = $2;
		if ($2->yyval.vtype != TYPE_int)
			ll_parserror("any::<int> expected");
	}
    |	/* empty */
	{ $$ = NULL;							      }
    ;

mel_return:
	':' mel_type
	{
		if ($2->token == TOK_ANY && $2->yyval.val.ival == 0) {
			yylogfree($2);
			$2 = NULL;
		}
		$$ = $2;
	}
    ;

expression:
	simple_expression { $$ = NULL; ll_firstnode = $1; } expr_rest
	{   $$ = $3;							      }
    |	blk_expression
	{   $$ = $1;							      }
    ;

blk_expression:
	sequential_block
	{   $$ = $1;							      }
    |	parallel_block
	{   $$ = $1;							      }
    ;

expr_rest:
	'.' {$$ = NULL; ll_sugarnode = ll_firstnode; } command_or_ident_expression
	{ $$ = NULL; ll_firstnode = $3; } expr_rest
	{   $$ = $5;							      }
    |	operator_expression { $$ = NULL; ll_firstnode = $1; } expr_rest
	{   $$ = $3;							      }
    |	/* empty */
	{   $$ = ll_firstnode;						      }
    ;

simple_expression:
	deref_or_simple_expression
	{   $$ = $1;							      }
    |	constant_expression
	{   $$ = $1;							      }
    |	variable_reference
	{   $$ = $1;							      }
  |	{ $$ = NULL; ll_sugarnode = NULL; } command_expression
	{   $$ = $2;							      }
    ;

deref_or_simple_expression:
	TOK_DEREF expression ')' argument_list
	{
		$$ = Myylognode(TOK_FUNCTION,0);
		Myylogexpand($$,$2);
		Myylogexpand($$,$4);
	}
    |	TOK_SETOP expression ']' argument_list
	{
		$$ = Myylognode(TOK_SETOP,0);
		Myylogexpand($$,$2);
		Myylogexpand($$,$4);
	}
    |	TOK_SETAGGR expression '}' argument_list
	{
		$$ = Myylognode(TOK_SETAGGR,0);
		Myylogexpand($$,$2);
		Myylogexpand($$,$4);
	}
    |	'(' expression ')'
	{   $$ = $2;							      }
    ;

temptok:
	TOK_TEMPLATE
	{
		$$ = $1;
		if (!ll_templates) {
			ll_parserror("template not in procedure body");
			$$->token = TOK_CONSTANT;
		}
	}
    |	TOK_ITERTEMP
	{
		$$ = $1;
		if (!ll_templates) {
			ll_parserror("template not in iterator body");
			$$->token = TOK_CONSTANT;
		}
	}
    ;

template:
	temptok
	{   $$ = $1; }
    |	TOK_VARTEMP expression rangetemp
	{
		$$ = Myylognode((int)(size_t)$3, 0);
		Myylogexpand($$,$2);
	}
    ;

rangetemp:
	')'
	{ $$ = (YYSTREE) (size_t) TOK_VARTEMP; }
    |	TOK_RANGETEMP ')'
	{ $$ = (YYSTREE) (size_t) TOK_RANGETEMP; }
    ;

constant_expression:
	TOK_CONSTANT
	{   $$ = $1;							      }
    |	TOK_STRING
	{   $$ = $1; $$->token = TOK_CONSTANT;				      }
    ;

command_or_ident_expression:
	builtin argument_list
	{
		$2->token = $1->token;
		$2->yyval = $1->yyval;
		yylogkill($1);
		$$ = $2;
	}
    |	command_or_operator_or_ident argument_list
	{
		YYSTREE t1 = $1, t2 = $2;
		t2->yyval = t1->yyval;
		t2->token = t1->token == TOK_ASSIGNOP ? TOK_ASSIGNOP : TOK_FUNCTION;
		yylogkill(t1);
		$$ = t2;
	}
    |	TOK_ATOM argument_list_nocheck
	{
		YYSTREE t1 = $1, t2 = $2;
		t2->yyval = t1->yyval;
		t2->token = TOK_FUNCTION;
		yylogkill(t1);
		$$ = t2;
	}
    ;

command_expression:
	builtin argument_list
	{
		$2->token = $1->token;
		$2->yyval = $1->yyval;
		yylogkill($1);
		$$ = $2;
	}
    |	command_or_operator argument_list
	{
		YYSTREE t1 = $1, t2 = $2;
		t2->yyval = t1->yyval;
		t2->token = t1->token == TOK_ASSIGNOP ? TOK_ASSIGNOP : TOK_FUNCTION;
		yylogkill(t1);
		$$ = t2;
	}
    |	TOK_ATOM argument_list_nocheck
	{
		YYSTREE t1 = $1, t2 = $2;
		t2->yyval = t1->yyval;
		t2->token = TOK_FUNCTION;
		yylogkill(t1);
		$$ = t2;
	}
    ;

operator_expression:
	operator
	{
		$$ = NULL;
		if (ll_firstnode)
			Myylogexpand($1, ll_firstnode);
	}
	expression
	{
		Myylogexpand($1, $3);
		$1->token = $1->token == TOK_ASSIGNOP ? TOK_ASSIGNOP : TOK_FUNCTION;
		$$ = $1;
	}
    ;

command_or_operator_or_ident:
	command_or_operator
	{   $$ = $1;							      }
    |	TOK_IDENT
	{   $$ = $1;							      }
    ;

command_or_operator:
	TOK_COMMAND
	{   $$ = $1;							      }
    |	TOK_PROC
	{   $$ = $1;							      }
    |	operator
	{   $$ = $1;							      }
    ;

operator:
	TOK_ASSIGNOP
	{   $$ = $1;							      }
    |	TOK_OPERATOR
	{   $$ = $1;							      }
    |	TOK_OPERATOR0
	{   $$ = $1;							      }
    |	TOK_OPERATOR1
	{   $$ = $1;							      }
    ;

builtin:
	TOK_BUILTIN
	{   $$ = $1;							      }
    |	TOK_TRG
	{   $$ = $1;							      }
    ;

argument_list:
	'(' expressions ')'
	{   $$ = $2;							      }
    |	'(' ')'
	{   $$ = (ptr) yysugar(ll_sugarnode);				      }
    |	 /* empty */
	{
		$$ = (ptr) yysugar(ll_sugarnode);
		if (!monet_nostalgic) {
			ll_parserror("new MIL syntax (>=4.4) requires parentheses for all operators.\n");
			YYERROR;
		}
	}
    ;

argument_list_nocheck:
	'(' expressions ')'
	{   $$ = $2;							      }
    |	'(' ')'
	{   $$ = (ptr) yysugar(ll_sugarnode);				      }
    |	/* empty */ 
	{   if (ll_sugarnode && !monet_nostalgic) {
		ll_parserror("new MIL syntax (>=4.4) requires parentheses for all operators.\n");
		YYERROR;
	    }
	    $$ = (ptr) yysugar(ll_sugarnode);                                 }
    ;

expressions:
	{ $$ = ll_sugarnode; } param_expression
	{    $$ = (ptr) yysugar($1); Myylogexpand($$, $2);		      }
    |	expressions ',' param_expression
	{    Myylogexpand($1, $3); $$ = $1;				      }
    ;

param_expression:
	TOK_CONST expression
	{    $$ = Myylognode(TOK_CONST,0); Myylogexpand($$, $2);	      }
    |	expression
	{    $$ = $1;							      }
    ;

modident:
	TOK_STRING
	{   $$ = $1; $$->token = TOK_CONSTANT;				      }
    |	TOK_IDENT
	{   $$ = $1;							      }
    ;

modidents:
	modident
	{
		$$ = Myylognode(0,0);
		$1->yyval.len = 0;
		Myylogexpand($$, $1);
	}
    |	modidents ',' modident
	{    $3->yyval.len = 0; Myylogexpand($1, $3); $$ = $1;		      }
    ;

constidents:
	TOK_IDENT TOK_ASSIGNMENT expression
	{
		$$ = Myylognode(0,0);
		Myylogexpand($1, Myylognode(TOK_TEMPLATE, 0));
		Myylogexpand($1, $3);
		$1->token = TOK_ASSIGNMENT;
		$1->yyval.len = 0;
		Myylogexpand($$, $1);
	}
    |	constidents ',' TOK_IDENT TOK_ASSIGNMENT expression
	{
		Myylogexpand($3, Myylognode(TOK_TEMPLATE, 0));
		Myylogexpand($3, $5);
		$3->token = TOK_ASSIGNMENT;
		$3->yyval.len = 0;
		Myylogexpand($1, $3);
		$$ = $1;
	}
    ;

varidents:
	ident_decl
	{    $$ = Myylognode(0,0); Myylogexpand($$, $1);		      }
    |	varidents ',' ident_decl
	{    Myylogexpand($1, $3); $$ = $1;				      }
    ;

initialization:
	TOK_ASSIGNMENT expression
	{    $$ = $2;							      }
    |	/* empty */
	{    $$ = NULL;							      }
    ;

ident_decl:
	{ $$ = NULL; ll_resolution = 0; } TOK_IDENT { $$ = NULL; ll_resolution = 1; } initialization
	{
		$$ = $2; $2->yyval.len = 0;
		if ($4) {
			Myylogexpand($$, Myylognode(TOK_TEMPLATE, 0));
			Myylogexpand($$, $4);
			$$->token = TOK_ASSIGNMENT;
		}
	}
    ;
%%

@-
Display the error information for the current client.
If the list-flag is on an arrow and state number is printed at the "appropriate"
place. If no lookahead character is a used and the next character is a newline,
we should also copy the input.
@{
@y
void
ll_parserror(str msg)
{
	static char buf[1024];
	char *s=buf, *t, *l = ll_lastline();
	size_t i = strlen(GDKERROR);

	ll_modcmds = 0; ll_resolution = 1;
	ll_templates = 0; ll_parblockdepth = 0;

	*s++ = '"';
	for (t = l; *t; t++) {
		/* accidental %s directives in the lastline can
		   crash the vfsprintf later => escape them */
		if (*t == '%')
			*s++ = '%';
		*s++ = *t;
	}
	*s++ = '"';
	*s++ = '\n';

	for (*s++ = '!'; i > 0; i--)
		*s++ = ' ';
	for (; *l; l++) {
		*s++ = (*l != '\t') ? ' ' : '\t';
	}
	*s++ = '^';
	*s++ = '\n';
	*s = 0;
	if (msg) {
		sprintf(s, "! %s.\n", msg);
	} else {
		sprintf(s, "! "); s += 2;
@-
Inlining this is a non-solution which was forced upon me by the new
makefiles. It effectively introduces the new requirement that all yaccs
should be the same. And they are not.. Sucker!
@y
#ifndef WIN32
#ifndef YYBISON
		{
			extern int yystate;
			extern int yylineno;

			if (GDKdebug&32768) {
				switch (yystate) {
				case 3:	case 20: case 58:
				case 60: case 181: case 183:
					strcpy(s,"you forgot a closing ';'.\n");
					break;
				case 11: case 12:
					strcpy(s,"identifier expected.\n");
					break;
				case 13:
					strcpy(s,"command name expected.\n");
					break;
				case 14:
					strcpy(s,"procedure expected.\n");
					break;
				case 18: case 19: case 46: case 47:
					strcpy(s,"'(' expected.\n");
					break;
				case 24: case 33: case 156:
					strcpy(s,"command invocation missing.\n");
					break;
				case 36:
					strcpy(s,"would a identifier or ../ be missing?\n");
					break;
				case 48: case 51:
					strcpy(s,"would a ';' or ',' be missing?\n");
					break;
				case 52: case 105: case 108: case 149:
					strcpy(s,"':=' expected.\n");
					break;
				case 78: case 130: case 208: case 229: case 240: case 246:
					strcpy(s,"']' expected.\n");
					break;
				case 79:
					strcpy(s,"forgot to close a block?\n");
					break;
				case 77: case 80: case 117: case 118:
					strcpy(s,"')' expected.\n");
					break;
				case 87:
					strcpy(s,"would a '~' or '?' be missing?\n");
					break;
				case 95:
					strcpy(s,"would '..' or ')' be missing?\n");
					break;
				case 96: case 97: case 182:
					strcpy(s,"identifier or string missing.\n");
					break;
				case 99: case 103: case 107: case 187:
					strcpy(s,"identifier missing.\n");
					break;
				case 129:
					strcpy(s,"'~' expected.?\n");
					break;
				case 142: case 146: case 163:
				case 152: case 202:
					strcpy(s,"would a ')' or ',' be missing?\n");
					break;
				case 155:
					strcpy(s,"would a '@' or ';' be missing?\n");
					break;
				case 170:
					strcpy(s,"would a atom or ')' be missing?\n");
					break;
				case 209:
					strcpy(s,"':' expected.\n");
					break;
				case 217:
					strcpy(s,"iterator expected.\n");
					break;
				case 224: case 234: case 243:
					strcpy(s,"atom name expected.\n");
					break;
				case 239:
					strcpy(s,"comma expected.\n");
					break;
				}
			}
		}
#endif
#endif
		if (*s == 0)
			strcpy(s,"can't help you here, sorry.\n");
	}
	GDKerror(buf);
	ll_sugarnode = NULL;
}
@
@}

@+ Data conflicts
The parser performs a simple data dependency check for all
identifiers mentioned in a parallel block. Duplicate use
of an identifier is flagged as a potential conflict under
parallel execution.  It is up to the Monet programmer to assure
himself that these conflicts are avoided by other means (e.g.
if-then-else).

@{
@c
str ids[500];			/* contains all ids of the parblock. */
char iderrors[500];		/* just to avoid multiple warnings. */

@-
The identifier table is also used to map the formal arguments into their
position number.
In this case we start at the bottom.
@c
void
ll_clrids(void)
{
	str *t = ids;
	char *c = iderrors;

	while (t < ids + 500 && *t) {
		*t++ = 0;
		*c++ = 0;
	}
	for (t = ids + 499; *t; t--) {
		*t = 0;
	}
}

void
ll_idconflict(str s)
{
	str *t;
	char *c;

	if (ll_parblockdepth == 0) {
		return;
	}
	for (c = iderrors, t = ids; t < ids + 500 && *t && *(t + 1); t++, c++) {
		if (s && strcmp(*t, s) == 0) {
			if (*c == 0) {
				GDKwarning("// conflict on %s\n", s);
			}
			*c = *c + 1;
			return;
		}
	}
	if (t < ids + 500) {
		*t = s;
	} else {
		GDKerror("potential // conflicts\n");
	}
}


@-
All variables mentioned in the constant list become constant.
@c
int
CMDconstant(Cntxt stk, YYSTREE lt, ValPtr res)
{
	unsigned i;
	int j;
	Variable act;
	YYSTREE t;

	(void) res;

	for (t = lt; t; t = YYOVERFLOW(t)) {
		for (i = 0; i < lt->cnt; i++)
			if ((int) arg(t, i)->token == monet_tokident) {
				str nme = arg(t, i)->yyval.val.sval;
				int s = stk;

				for (j = arg(t, i)->yyval.len; j > 0; j--) {
					if (s >= 0) {
						s = monet_cntxt[s].outer;
					} else {
						GDKerror("CMDconstant: illegal context.\n");
						return -1;
					}
				}
				if ((act = VARfind(&s, nme)) == 0) {
					GDKerror("CMDconstant: variable '%s' does not exist.\n", nme);
					return -1;
				}
				if (act->constant) {
					GDKerror("CMDconstant: cannot assign to constant '%s'.\n", nme);
					return -1;
				}
				VARfixate(act);
			} else {
				GDKerror("CMDconstant: CONST works on variable names only.\n");
				return -1;
			}
	}
	return 0;
}

@
@}
