@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2006 CWI.
@' All Rights Reserved.

@f monet_client
@a M. L. Kersten, P. Boncz

@* Monet Client Interface
Clients gain access to the Monet server through a internet connection
or through its server console.
Access through the internet requires a Monet client program at the
source, but ordinary telnet connections can be applied when the internet
number of the database server is publicized.
@-
The number of clients permitted concurrent access is a compile time option.
They are referenced internally by number. The console is the first and
should always be present. It reads from standard input and writes to
standard output.
The number of clients depends on the permissible open file
descriptors.

@{
@h
#ifndef _MONET_CLIENT_H_
#define _MONET_CLIENT_H_

#define MAXCLIENTS	512
#define BLOCKMODE	32
#define FINISHED	0
#define STARTING	1
#define FINISHING	2
#define CONSOLE		0

typedef struct _modstack_t {
	str mod;
	ptr var;
	struct _modstack_t *up;
} modstack;

typedef struct CLIENT {
	str user;		/* user name. */
	str passwd;		/* passwd name. */
	time_t login;		/* session start time */
	int permission;		/* not yet used. */
	int blocked;		/* blocked stream ? */
	stream *fdin, *fdout;	/* streams from and to user. */
	stream *bkin, *bkout;	/* backup stream storage */
	int listing;		/* echo input */
	int mode;		/* FINISHED/BLOCKED */
	int father;		/* client number of father */
	int children;		/* has children? */
	str prompt, bkprompt;	/* prompts */
	str input, output;	/* char buffers */
	str top, limit;		/* parser pointers */
	char *cptr;		/* parser pointers */
	char *cline;		/* current parse line */
	YYSTREE tree;		/* current request */
	YYSTREE mil_accept;	/* accept request */
	Cntxt maxstk;		/* highest context stack */
	int stk;		/* lowest context stack */
	BAT *fcntbl;		/* BAT(str, FID) */
	BAT *atomtbl;		/* BAT(str, type-id) */
	BAT *triggers;		/* BAT(str, type-id) */
	BAT *events;		/* BAT(str, type-id) */
	modstack *m_stack;	/* module stack */
} *Client, ClientRec;

m_export ClientRec monet_clients[MAXCLIENTS + 1];
m_export Client ll_client;

m_export Client initClient(str name, str prompt, int thread);
m_export void freeClient(Client c);
m_export Client forkClient(Cntxt stk, int thread);
m_export int closeClient(Client c, int thread);
m_export void killClient(Client c, int thread);
m_export void scheduleClient(Client c);
m_export int readClient(Client c);
m_export YYSTREE parseClient(Client c, int reschedule);
m_export int serveClient(Cntxt stk, YYSTREE lt, ValPtr res);
m_export str moduleClient(Client c, str mod, str parmod);
m_export int dropClient(Client c, YYSTREE lt);
m_export void moduleEnterClient(Client c, str mod);
m_export void moduleExitClient(Client c);
m_export str moduleGetClient(Client c);

m_export void lockparser(Client c);
m_export void unlockparser(Client c);

#endif /* _MONET_CLIENT_H_ */
@c
#include "monet.h"
#ifdef HAVE_SYS_SOCKET_H
# include <sys/socket.h>
#endif
#ifdef NATIVE_WIN32
# include <winsock.h>
#endif
#include <sys/types.h>

ClientRec monet_clients[MAXCLIENTS + 1];
int monet_nclients = 0;

@-
Upon acceptance of a connection a client record is initialized.
@c
Client
initClient(str nme, str prompt, int thread)
{
	Client c;


	/* find an empty client slot. The console entry (0) is reserved. */
	monet_set_lock(monet_contextLock, "initClient");
	for (c = monet_clients; c < monet_clients + MAXCLIENTS; c++) {
		if (c->mode == FINISHED) {
			monet_nclients++;
			c->mode = STARTING;
			break;
		}
	}
	monet_unset_lock(monet_contextLock, "initClient");

	if (c == monet_clients + MAXCLIENTS) {
		GDKerror("initClient: Out of client slots\n");
		return 0;
	}
	if (thread && monetFork() == ~(MT_Id) 0) {
		return 0;	/* cannot create required MIL interpreter thread */
	}
	c->user = GDKstrdup(nme);
	c->passwd = NULL;
	c->prompt = GDKstrdup(prompt);
	c->fdin = GDKstdin;
	c->fdout = GDKstdout;
	c->maxstk = c->stk = (int) (c - monet_clients);
	c->father = -1;
	c->m_stack = NULL;
	monet_cntxt[c->stk].used = TRUE;
	monet_cntxt[c->stk].reuse = -1;
	monet_cntxt[c->stk].outer = c->stk ? 0 : -1;
	monet_cntxt[c->stk].next = -1;
	monet_cntxt[c->stk].shadow = 0;
	if (c->input == 0) {
		c->input = (str) GDKmalloc(4096);
	}
	if (c->output == 0) {
		c->output = (str) GDKmalloc(4096);
	}
	c->limit = c->input + 4096;
	c->top = c->input;
	*c->top = 0;
	c->mode = BLOCKMODE;
	c->mil_accept = NULL;
	c->cline = NULL;
	c->cptr = NULL;
	return c;
}

@-
The default action is to schedule processing of the start-up file
followed by reading a request from the socket.
Execution of the prelude file is scheduled as a separate action.
The first time a client needs input (or when the last input contained
errors) its read request is entered into the queue.
@c

static YYSTREE
scheduleFile(str filename)
{
	YYSTREE r = Myynode(TOK_BUILTIN, TYPE_ptr);
	YYSTREE n = Myynode(TOK_CONSTANT, 0);

	Myyexpand(r, n);
	n->yyval.vtype = TYPE_str;
	n->yyval.val.sval = GDKstrdup(filename);
	n->yyval.len = strLen(filename);
	r->yyval.val.pval = (ptr) interpret_file;
	r->dealloc = 0;
	return r;
}

#define QMADD(req, stk, lt, txt) {			\
	Request _tmp = newRequest(stk, lt, req!=NULL);	\
	QMmessage(_tmp, txt);				\
	if (req) {					\
		req->ev_wakeup = _tmp;			\
		req->ev_prev  = _tmp;			\
	}						\
	_tmp->ev_next = req;				\
	req = _tmp;					\
}

void
scheduleClient(Client c)
{
	Request req = NULL;
	YYSTREE t;
	int k;

	if (c->mil_accept == NULL) {
		Myyexpand(c->mil_accept = Myynode(TOK_BUILTIN, TYPE_int), t = Myynode(TOK_CONSTANT, TYPE_int));
		c->mil_accept->yyval.val.pval = (ptr) serveClient;
		t->yyval.val.ival = (int) (c - monet_clients);
	}
	if (monet_script) {	/* first time */
		if (monet_dbinit) {
			monet_eval(monet_dbinit, &k);
		}
		for (k = 0; monet_script[k]; k++) {
			QMADD(req, 0, scheduleFile(monet_script[k]), "source(<user script>);");
		}
		GDKfree(monet_script);
		monet_script = NULL;
	}
	if (c != monet_clients || monet_daemon != 1) {
		QMADD(req, c->stk, c->mil_accept, "readCmd;");
	}
	if (req)
		putRequest(req);
	else if (!monet_dbinit)
		GDKfatal("scheduleClient: Daemon mode without startup script\n");
}

void
rescheduleClient(Client c)
{
	Request rm = newRequest(c->stk, c->mil_accept, 0);

	QMmessage(rm, "readCmd;");
	putRequest(rm);
}

@-
Forking is a relatively cheap way to create a new client.
The new client record shares most datastructures with the father.
The idea of such a forked client is that it has its own MIL string
buffer, MIL parse tree, and own context management. It is typically
used for evaluating a MIL string from within MIL. This evaluation
takes place in a forked client, so that all MIL resources (context records)
can be freed immediately, independent from the MIL execution context
of the father.
@c
Client
forkClient(Cntxt stk, int thread)
{
	Client father = NULL, son = NULL;

	CNTXTclient(stk, &father);
	if (father && father->father >= 0) {
		/* if the father itself is a temporary client, let
		 * the new child depend on the grandfather.
		 * so: father always points to a real client session!
		 */
		father = monet_clients + father->father;
	}

	if (father && (son = initClient(father->user, father->prompt, FALSE))) {

		/* reuse all crucial table information from father */
		son->fdin = father->fdin;
		son->fdout = father->fdout;
		son->fcntbl = father->fcntbl;
		son->atomtbl = father->atomtbl;
		son->triggers = father->triggers;
		son->events = father->events;
		son->login = father->login;

		if (thread) {
			/* independent thread must be fully decoupled from father */
			CNTXTcopy(stk, son);	/* copy all variables available in father into private context */
			monet_cntxt[son->stk].outer = 0;
			son->father = -1;
			TBL_initclient(son, father);
			son->fdin = file_rastream(stdin, "stdin");
			son->fdout = file_wastream(stdout, "stdout");
		} else {
			/* temporary (synchronous) forks reuse father's stack */
			son->father = father->stk;
			monet_cntxt[son->stk].outer = stk;
			monet_cntxt[son->stk].shadow = 1;
		}
		monet_set_lock(monet_contextLock, "forkClient");
		father->children++;
		monet_unset_lock(monet_contextLock, "forkClient");

		if (thread)
			if (monetFork() == ~(MT_Id) 0)
				return 0;
	}
	return son;
}

@-
freeClient() frees up the client slot, file descriptors, user name and
prompt, and all cached context (i.e. MIL variable) records that were
used in the client session.
@c
void
freeClient(Client c)
{
	if (c->mode <= FINISHING) {
		GDKwarning("freeClient(%d): double entry prevented\n", c->stk);
		monet_unset_lock(monet_contextLock, "freeClient");
		return;
	}
	/* free the client record */
	if (c->father >= 0) {
		monet_clients[c->father].children--;
	}
	c->mode = FINISHING;
	monet_unset_lock(monet_contextLock, "freeClient");

	/* epilogue: free all resources taken by client */
	if (c->tree) {
		Myyfree(c->tree);	/* garbage collect return values in last MIL tree */
		c->tree = NULL;
	}
	/* destroy MIL stack (must happen before module drops) */
	CNTXTclear(c->stk);
	CNTXTfree2(c->stk, c);
	CNTXTdelete(c->stk);
	c->top = c->limit = NULL;

	/* free other buffers, fds referenced by the client */
	if (c->father >= 0) {
		/* tmp client resus parent so misses some epilogue work */
		c->father = monet_cntxt[c->stk].outer = -1;
	} else {
		Thread t;
		stream *bkin, *bkout;

		/* remove possible profiler channel */
		closeProfiler(c->fdout);

		/* normal client  */
		t = THRget(THRgettid());
		bkin = t->data[1];
		bkout = t->data[0];

		TBL_exitclient(c);	/* module drops */

		/* GDKlog("Mserver: %s session ends", c->user); */
		monetSetChannel(t, bkin, bkout);
		if (c->fdout != GDKstdout) {
			if (GDKout == c->fdout)
				t->data[0] = GDKstdout;
			stream_close(c->fdout);
			stream_destroy(c->fdout);
			c->fdout = NULL;
		} 
		if (c->fdin != GDKstdin) {
			if (GDKin == c->fdin) 
				t->data[1] = GDKstdin;
			stream_close(c->fdin);
			stream_destroy(c->fdin);
			c->fdin = NULL;
		} 
	}
	GDKfree(c->input);
	GDKfree(c->output);
	GDKfree(c->user);
	if (c->passwd)
		GDKfree(c->passwd);
	GDKfree(c->prompt);

	c->input = c->output = NULL;
	c->user = c->passwd = c->prompt = NULL;
	c->cline = c->cptr = NULL;
	c->mil_accept = NULL;
	c->children = 0;
	c->mode = FINISHED;
}

@-
closeClient is called if a MIL client session ends. Most of the time it leads
to a freeClient to free up resources.
@c
int
closeClient(Client c, int thread)
{
	static int killadm = FALSE;

	/* end of script reading client? */
	if (c->bkin || c->bkout) {
		c->fdin = c->bkin;
		c->fdout = c->bkout;
		c->bkin = c->bkout = 0;
		c->prompt = c->bkprompt;
		c->bkprompt = 0;
		if (c->fdin == GDKstdin) {
			c->listing = monet_listing;
		}
		rescheduleClient(c);
		return 1;
	}

	/* kill living background clients */
	if (c->children) {
		Client k;

		for (k = monet_clients; k < monet_clients + MAXCLIENTS; k++) {
			if ((k->mode > FINISHING) && (k->father == c->stk))
				killClient(k, TRUE);
		}
	}

	/* free resources */
	if (c == monet_clients) {
		/* adm: do not free immediately */
		int i, m = monetAdjustThreads(0);

		for (i = 0; i < m; i++) {
			putkillRequest();
		}
	} else {
		/* client: free your recources immediately */
		monet_set_lock(monet_contextLock, "closeClient");
		freeClient(c);
		if (thread) {
			putkillRequest();
		}
	}

	/* the adm is freed by the last client */
	monet_set_lock(monet_contextLock, "closeClient");
	if (killadm == FALSE && --monet_nclients == 0) {
		killadm = TRUE;
		freeClient(monet_clients);
	} else {
		monet_unset_lock(monet_contextLock, "closeClient");
	}
	return 0;
}


@-
killClient() interrupts the MIL session abruptly, killing any executing MIL
interpreter threads. It is not deadlock safe nor memory leak free, and should
be used only as a last resort to kill an out-of-control query.
@c
void
killClient(Client c, int thread)
{
	if (c && c->user) {
		int me = THRgettid();
		Request r, q = QMclient(0, c);

		if (q)
			do {
				r = QMclient(q, c);
				if (q->ev_status == EVRUNNING && q->ev_process != me) {
					Thread t = THRget(q->ev_process);

					if (t != NULL) {
						MT_Id victim = t->pid;

						THRdel(t);
						MT_kill_thread(victim);
						MT_sleep_ms(1000);	/* why is this needed, isn't MTsafe */
						monetFork();
					}
					rmRequest(q);
					clrRequest(q);
				}
			} while ((q = r) != NULL);
		closeClient(c, thread);
	}
}

@-
readClient() reads MIL from a string into the client MIL  buffer. It reads MIL (without really parsing it yet) until
the minimal point that something can be executed, hence it detects just when we have read one MIL statement. Notice
that a MIL (parallel) block counts as one statement, but may span many lines.
@c
static void
enlargebuffer(Client c)
{
	size_t i;
	size_t l;

	l = c->top - c->input;
	i = c->limit - c->input + 4096;
	c->input = GDKrealloc(c->input, i);
	c->top = c->input + l;
	c->limit = c->input + i;
}

int
readClient(Client c)
{
	ssize_t i;
	int doflush = 1;
	char instring = 0;
	int bracket = 0;
	int incomment = 0;
	int escaped = 0;
	stream *fd = GDKout;
	str s, p;
	int blocked;
	size_t offset = 0;

	PARSEDEBUG THRprintf(GDKerr, "accept client " PDFMT " input %s buffer:\n#%s\n", c - monet_clients, stream_name(c->fdin), c->top);

	c->top = c->input;

	if (stream_errnr(fd) || stream_errnr(c->fdin))
		return 0;
	blocked = isa_block_stream(c->fdin);
	do {
		if (c == monet_clients) {
			if (!blocked && instring != '"' && c->prompt && *c->prompt && stream_write(fd, c->prompt, strlen(c->prompt), 1) != 1)
				return 0;
		} else if (c->top == c->input) {
			if (!blocked && stream_write(fd, PROMPT1, sizeof(PROMPT1) - 1, 1) != 1)
				return 0;
		} else {
			if (stream_write(fd, PROMPT2, sizeof(PROMPT2) - 1, 1) != 1)
				return 0;
		}
		if (stream_flush(fd))
			return 0;
		if (blocked) {
			/* read to end of block (recognized by an
			   empty read) */
			ssize_t nsize;

			do {
				nsize = c->limit - c->top;
				i = stream_read(c->fdin, c->top, 1, nsize);
				if (stream_errnr(c->fdin) || i < 0)
					return 0;
				c->top += i;
				if (c->limit - c->top <= 1)
					enlargebuffer(c);
			} while (i > 0);
		} else {
			/* read to end of line */
			do {
				if (c->limit - c->top <= 1)
					enlargebuffer(c);
				i = stream_read(c->fdin, c->top, 1, 1);
				if (i == 0) {
					/* simulate quit command at EOF */
					if (c->top != c->input)
						GDKwarning("readClient: unexpected end of file; discarding partial input\n");
					strcpy(c->input, "quit();\n");
					c->top = c->input + strlen(c->input);
					return 1;
				}
				if (i < 0) {
					return 0;
				}
			} while (*c->top++ != '\n');
		}
		PARSEDEBUG THRprintf(GDKerr, "%.*s", c->top - (c->input + offset), c->input + offset);

		if (c->input + offset == c->top) {
			/* We didn't get any data this time round.
			   This means that the other side doesn't have
			   any more, so we will have to make do. */
			break;
		}
		/* this loop wil check whether we got enough data for
		   a complete MIL statement, and in addition will
		   normalize line endings. */
		for (s = p = c->input + offset; s < c->top; s++) {
			switch (*s) {
			case '\\':
				escaped = !escaped;
				*p++ = '\\';
				break;
			case '\r':
				if (s + 1 < c->top && s[1] == '\n')	/* Windows format line ending? */
					s++;
				/* else Mac format line ending: fall through */
			case '\n':
				incomment = 0;
				if (s > c->input && !escaped)
					instring = 0;
				escaped = 0;
				*p++ = '\n';
				break;
			case '\0':
				escaped = 0;
				*p++ = *s;
				c->top = p;
				return 0;
			case '#':
				if (!instring)
					incomment++;
				escaped = 0;
				*p++ = *s;
				break;
			case '{':
				if (!incomment && !instring) {
					bracket++;
					doflush = 0;
				}
				escaped = 0;
				*p++ = *s;
				break;
			case '}':
				if (!incomment && !instring) {
					bracket--;
					if (bracket == 0)
						doflush = 1;
				}
				escaped = 0;
				*p++ = *s;
				break;
			case '\'':
			case '"':
				if (!incomment && (s <= c->input || !escaped)) {
					if (instring == *s)
						instring = 0;
					else if (!instring)
						instring = *s;
					doflush = 0;
				}
				escaped = 0;
				*p++ = *s;
				break;
			case ';':
				if (!incomment && !instring)
					doflush = 1;
				escaped = 0;
				*p++ = *s;
				break;
			default:
				/* some implementations of isspace
				 * only handle ASCII, so check for
				 * non-ASCII-ness separately */
				if (!incomment &&
				    ((*s & ~0x7F) != 0 || !isspace((int) *s)))
					doflush = 0;
				escaped = 0;
				*p++ = *s;
				break;
			}
		}
		c->top = p;
		offset = c->top - c->input;	/* where we left off checking */
	} while (!doflush || bracket > 0);

	*c->top = 0;
	return 1;
}


@-
parseClient() parses the client MIL string buffer into a MIL parse tree. This
is also the point that the context resources of the previous MIL parse tree are
released. In the past, freeing resources could not be done right away after
executing the tree, because return values would be lost. Improvements in MIL
value fixing and the return statement have now made this unnecessary.

PETER: this could be changed; freeing ASAP makes purify output easier to judge.

As yacc/lex are not thread-safe, we lock around the parsing actions.
@c
void
lockparser(Client c)
{
	monet_set_lock(monet_parserLock, "lockparser");
	ll_client = c;
	c->cptr = c->input;
	c->cline = c->input;
}

void
unlockparser(Client c)
{
	Myylogclean();		/* clean supurfluous nodes */
	c->top = c->input;
	ll_client = 0;
	monet_unset_lock(monet_parserLock, "unlockparser");
}

extern int yyparse(void);
extern void ll_flushbuffer(void);

YYSTREE
parseClient(Client c, int reschedule)
{
	Request cur = 0, after = 0;
	int r;

	if (reschedule) {
		cur = thisRequest();
		after = newRequest(c->stk, c->mil_accept, 1);
		after->ev_wakeup = cur->ev_wakeup;
		cur->ev_wakeup = after;
		QMmessage(after, "readCmd;");
		putRequest(after);
	}
	lockparser(c);

	if (c->tree) {
		Myyfree(c->tree);
		c->tree = NULL;
		CNTXTfree2(c->stk, c);
	}
	r = yyparse();
	ll_flushbuffer();

	unlockparser(c);

	if (reschedule && (r == 0) && c->tree) {
		after = newRequest(c->stk, c->tree, 1);
		after->ev_wakeup = cur->ev_wakeup;
		cur->ev_wakeup = after;
		QMmessage(after, c->input);
		putRequest(after);
	}
	return c->tree;
}

@-
serveClient() tries to read MIL from the client input stream, and parse it.
It is typically called from the MIL queue, which basically has two kinds
of requests: serveClient and MIL execution.

It calls on parseClient(), which will again add a MIL execution request
containing a parsed MIL tree in to the MIL queue.

If and end-of-stream is detected, we signal in the queue that the
corresponding client should be terminated.
@c
int
serveClient(Cntxt stk, YYSTREE lt, ValPtr res)
{
	int i = 0;
	Client c;
	Thread t;

	if (lt->cnt != 1 || interpret(stk, lt->yysons[0], res) < 0 || res->vtype != TYPE_int || ((i = res->val.ival) < 0) || (i > MAXCLIENTS)) {
		GDKwarning("serveClient: lost\n");
		return -1;
	}
	res->vtype = TYPE_void;
	c = monet_clients + i;
	if (c->mode == FINISHED) {
		if (i)
			GDKwarning("serveClient: client died.\n");
		return -1;
	}
	t = THRget(THRgettid());
	if (monetSetChannel(t, c->fdin, c->fdout)) {
		return -1;
	}
	if (readClient(c)) {
		parseClient(c, TRUE);
	} else {
		Request q;

		if (monet_forks > 0)
			monet_forks--;
		q = thisRequest();
		q->ev_kill = c->stk + 1;
	}
	return 0;
}

str
moduleClient(Client c, str mod, str parmod)
{
	str init_script = NULL;

	if (TBL_loadmod(c, mod, parmod, 0, &init_script) == 0) {
		GDKerror("moduleClient: module(%s) load error.\n", mod);
		return init_script;
	}
	return init_script;
}

int
dropClient(Client c, YYSTREE lt)
{
	while (lt) {
		unsigned i;

		for (i = 0; i < lt->cnt; i++) {
			str mod;

			if (!lt->yysons[i])
				continue;
			if ((int) lt->yysons[i]->token == monet_tokident) {
				mod = arg(lt, i)->yyval.val.sval;
			} else {
				ValRecord res;
				int ret = interpret(c->stk, lt->yysons[i], &res);

				if (ret < 0 || res.vtype != TYPE_str) {
					GDKerror("dropClient: illegal argument.\n");
					return 0;
				}
				mod = res.val.sval;
			}
			if (TBL_unloadmod(c, mod, 0) == 0) {
				return 0;
			}
		}
		lt = YYOVERFLOW(lt);
	}
	return 1;
}

void
moduleEnterClient(Client c, str mod)
{
	if (mod) {
		modstack *s = (modstack *) GDKmalloc(sizeof(modstack));

		s->mod = GDKstrdup(mod);
		s->up = c->m_stack;
		s->var = CNTXTregvars(c);

		c->m_stack = s;
	}
}

void
moduleExitClient(Client c)
{
	if (c->m_stack) {
		modstack *s = c->m_stack;
		ptr var = CNTXTregvars(c);

		c->m_stack = s->up;
		if (c->m_stack)
			c->m_stack->var = var;

		GDKfree(s->mod);
		GDKfree(s);
	}
}

str
moduleGetClient(Client c)
{
	str mod = NULL;

	while (c && c->father >= 0 && !c->m_stack)
		c = monet_clients + c->father;

	if (c && c->m_stack)
		mod = c->m_stack->mod;
	return mod;
}

@
@}
