@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2006 CWI.
@' All Rights Reserved.

@f monet_tbl
@a Peter Boncz, Jonas S Karlsson, Niels J Nes
@v 2.0
@t Function Table and Module Management
@* Introduction
The dictionary maintained by Monet is geared towards administration of the
functions, atomary types and modules.

The information on modules is stored in a system global area.
Upon start of a server session its contents is obtained for use.
No concurrency control is currently applied to the module database.

This code is heavily used to map identifiers to internal values and
vice versa.
@h
#ifndef _MONET_TBL_H
#define _MONET_TBL_H

#include <assert.h>

#define BUNtailfnd(tp,  bt, bn, vl)	((bn=BUNfnd(bt, vl))?(tp *) BUNtail(bt,bn):0)

#ifdef __cplusplus
extern "C" {
#endif

/* Generic initialization/cleanup routines */
m_export void TBL_init(void);
m_export void TBL_protect(void);
m_export void TBL_initclient(Client c, Client father);
m_export void TBL_exitclient(Client c);

m_export void TBL_newproc(Client c, str nme, str mod, YYSTREE body, YYSTREE sig, YYSTREE ret);
m_export void TBL_delproc(Client client, str nme);

m_export int TBL_M_client_install(Client client, oid mid);
m_export int TBL_M_incref(Client client, oid mid);

/* old info functions */
m_export ptr TBL_unpacked(ptr imp);
m_export char *TBL_search(str name, int *t, int guess_if_notfound, int cur_is_ident, int no_command, int next_is_ident);
m_export str TBL_getname(ptr imp);
m_export str TBL_fndname(ptr imp);
m_export int TBL_getparams(ptr imp, str argv[]);
m_export BAT *TBL_getdir(void);
m_export char *TBL_atomname(int atm);
m_export void TBL_printsigs(str s, int stk, str nme);
m_export int TBL_formatsig(str s, oid fid);
m_export int TBL_procreturn(int argc, ValPtr argv, ValPtr res, YYSTREE t);
m_export void *TBL_iterator(Cntxt stk, str name, int argc, ValPtr argv);
m_export oid TBL_loadmod(Client client, str module, str parmod, int level, str *initstr);
m_export int TBL_unloadmod(Client client, str module, int level);

m_export BAT *TBL_fcn_nme;
m_export BAT *TBL_fcn_fcn;
m_export BAT *TBL_fcn_mid;
m_export BAT *TBL_fcn_imp;
m_export BAT *TBL_fcn_tpe;
m_export BAT *TBL_fcn_sig;
m_export BAT *TBL_fcn_dsc;
m_export BAT *TBL_fcn_aut;
m_export BAT *TBL_fcn_dat;
m_export BAT *TBL_fcn_pro;
m_export BAT *TBL_fcn_cnt;
m_export BAT *TBL_mod_nme;
m_export BAT *TBL_mod_cnt;
m_export BAT *TBL_mod_hdl;
m_export BAT *TBL_mod_atm;
m_export BAT *TBL_mod_dep;
m_export BAT *TBL_mod_use;
m_export BAT *TBL_mod_load;
m_export BAT *TBL_mod_drop;
m_export BAT *TBL_mod_proc;
m_export BAT *TBL_mod_var;

m_export ptr TBL_module_handle(oid);
m_export oid TBL_module_lookup(str);
m_export void *DL_sym(void *, const char *);
@
Declarations of Installing interface for modules.
@h
typedef struct TBLinstall_t {
	Client client;
	str *initstr;
	int level;
	oid curmid;
} TBLinstall;

m_export void TBL_Install_Depend(TBLinstall *i,	/* Passed on from "module"_Install */
				 oid mid, str user, /* Passed on from TBL_Install */
				 str name);

/* An oid is generated */
m_export oid TBL_Install_Info(TBLinstall *i, /* Passed on from "module"_Install */
			      str owner, str name);

m_export void TBL_Install_Atom(oid mid, str name, int size, /* 0 == not fixed size */
			       int align);	/* 0 == not fixed size */

m_export void TBL_Install_DropRefs(oid mid, bat *batrefs);

/* I think the types from parsing are only availiable as strings
   so we better input them as such */

void TBL_Deinstall_Function(oid pid);

typedef struct TBLfcn_t {
	str name;
	int token;
	ptr fcn;
	ptr unpack;
	ptr check;
	ptr oldsig;
	str help;
	str args[MAXPARAMS];
	str res;
} TBLfcn;

m_export void TBL_Install_Functions(oid mid, TBLfcn *fcns, str user, str date);
/* install all functions for the given module */

/* An oid is generated */
m_export oid TBL_Install_Function(oid mid, str name, int tpe, /* some sort of type? fcn_table[i].token */
				  ptr orig, ptr pack_imp, ptr type_imp,	/* functionpointers! */
				  str signature, str help, str author, str date);

/* Called after _Function */
m_export void TBL_Install_Function_Vararg(oid fid, str tpe);

@- function arguments
This one would have to be called several times, once for each argument
@h
m_export void TBL_Install_Function_Arg(oid fid, str tpe); /* Called after _Function / _Vararg */

m_export void TBL_Install_Function_Res(oid fid, str tpe); /* After _Arg */

m_export void TBL_Install_MilVar(Client client, str mod, ptr v);

@- function resolution
@h
#define TBL_RESOLVE_NOBAT (-4)	/* no bats passed to a multiplex */
#define TBL_RESOLVE_NOFCN (-3)	/* no function with this name and # params exists */
#define TBL_RESOLVE_NOSIG (-2)	/* no function with this exact signature exists */
#define TBL_RESOLVE_NOTPE (-1)	/* actual parameters contain illegal (no-loaded) type */

m_export int TBL_normal_resolve(str name, int argc, ValPtr Argv, monet_sig_t *sig, Cntxt stk);

m_export int TBL_multiplex_resolve(str name, int argc, ValPtr Argv, monet_sig_t *sig, Cntxt stk);

m_export int TBL_setaggr_resolve(str name, int argc, ValPtr Argv, monet_sig_t *sig, Cntxt stk);

@c
#include "monet.h"

#include <stdio.h>
#include <string.h>

#define dlPRINT(text)	DLDEBUG	THRprintf(GDKerr, text)
#define dlFPRINTF	DLDEBUG	THRprintf

static void TBL_Insert_Depend(oid mid, str name);

BAT *TBL_fcn_nme = NULL;	/* BAT(oid, str): (function name, FID). */
BAT *TBL_fcn_fcn = NULL;	/* BAT(oid, ptr): (FID, implementation fcn). */
BAT *TBL_fcn_mid = NULL;	/* BAT(oid, oid): (FID, MID). */
BAT *TBL_fcn_imp = NULL;	/* BAT(oid, ptr): (FID, packed implementation) */
BAT *TBL_fcn_tpe = NULL;	/* BAT(oid, int): (FID, token). */
BAT *TBL_fcn_sig = NULL;	/* BAT(oid, str): (FID, fcn signature text). */
BAT *TBL_fcn_dsc = NULL;	/* BAT(oid, str): (FID, fcn description text). */
BAT *TBL_fcn_aut = NULL;	/* BAT(oid, str): (FID, fcn author name). */
BAT *TBL_fcn_dat = NULL;	/* BAT(oid, str): (FID, fcn creation date). */
BAT *TBL_fcn_pro = NULL;	/* BAT(oid, str): (FID, type sequence). */
BAT *TBL_fcn_cnt = NULL;	/* BAT(oid, int): (FID, reference count (procs)). */
BAT *TBL_mod_nme = NULL;	/* BAT(oid, str): (MID, module name). */
BAT *TBL_mod_cnt = NULL;	/* BAT(oid, int): (MID, reference count). */
BAT *TBL_mod_hdl = NULL;	/* BAT(oid, ptr): (MID, OS dynlink handle). */
BAT *TBL_mod_atm = NULL;	/* BAT(oid, str): (MID, atom name). */
BAT *TBL_mod_dep = NULL;	/* BAT(oid, str): (MID, depends-of module name). */
BAT *TBL_mod_use = NULL;	/* BAT(oid, int): (which clients use a mod). */
BAT *TBL_mod_load = NULL;	/* BAT(oid, str): (MID, mil-script). */
BAT *TBL_mod_drop = NULL;	/* BAT(oid, int): (MID, batid). */
BAT *TBL_mod_proc = NULL;	/* BAT(str, oid): (modname, oid). */
BAT *TBL_mod_var = NULL;	/* BAT(str, ptr): (modname, ptr). */

oid TBL_top_mid;
MT_Lock TBL_protector, TBL_writelock;
MT_Sema TBL_barrier;
int TBL_readers = 0, TBL_writer = 0;

@- read-write locking
@T
The function tables are concurrently read by the parser and (multiple)
interpreter threads. When modules are loaded/dropped or procedures
defined, the parser thread may also write these tables.

Reading is much more frequent than writing, and as interpreter
threads do this possibly in parallel, we first used a read-write locking
scheme that permits either one writer or multiple readers.
\begin{verbatim}
set_readlock
	lock(protector)
	if (nreaders++ == 0) set_writelock()
	unlock(protector)
unset_readlock
	lock(protector)
	if (--nreaders == 0) unset_writelock()
	unlock(protector)
set_writelock
	sema_down(barrier);
unset_writelock
	sema_up(barrier);
\end{verbatim}
In this approach, the probability that a reader had to set the semaphore was
almost 100\%. Given the fact that locks are much cheaper than semaphores (on NT),
we switched an {\bf optimized} locking scheme, in which read-only access only
uses mutex locking.
\begin{verbatim}
set_readlock
	lock(writelock)
	lock(protector)
	nreaders++
	unlock(protector)
	unlock(writelock)
unset_readlock
	lock(protector)
	if (--nreaders == 0 and wr_waiting) sema_up(barrier);
	unlock(protector)
set_writelock
	lock(writelock)
	lock(protector)
	wr_waiting = (nreaders > 0);
	unlock(protector)
	if (wr_waiting) sema_down(barrier);
unset_writelock
	wr_waiting = 0;
	unlock(writelock)
\end{verbatim}
In a nutshell: there is a global writelock ('writelock') that stops
readers from entering when there is a writer. If the readers are first,
an entering writer goes to sleep on a semaphore ('barrier') and is woken
up by the last reader. Crucial counter variables are protected by a
short-term lock ('protector').
@c
#define TBL_set_readlock() {						\
    monet_set_lock(TBL_writelock, "TBL_set_readlock(writelock)");	\
    monet_set_lock(TBL_protector, "TBL_set_readlock(protector)");	\
    TBL_readers++;							\
    monet_unset_lock(TBL_protector, "TBL_set_readlock(protector)");	\
    monet_unset_lock(TBL_writelock, "TBL_set_readlock(writelock)");}
#define TBL_unset_readlock() {						\
    monet_set_lock(TBL_protector, "TBL_unset_readlock(protector)");	\
    if (--TBL_readers == 0 && TBL_writer)				\
		monet_up_sema(TBL_barrier, "TBL_unset_readlock");	\
    monet_unset_lock(TBL_protector, "TBL_unset_readlock(protector)");	}
#define TBL_set_writelock() {						\
    monet_set_lock(TBL_writelock, "TBL_set_writelock(writelock)");	\
    monet_set_lock(TBL_protector, "TBL_set_writelock(protector)");	\
    TBL_writer = TBL_readers;						\
    monet_unset_lock(TBL_protector, "TBL_set_writelock(protector)");	\
    if (TBL_writer)							\
	monet_down_sema(TBL_barrier, "TBL_set_writelock");		}
#define TBL_unset_writelock() {						\
    monet_set_lock(TBL_protector, "TBL_unset_writelock(protector)");	\
    TBL_writer = 0;							\
    monet_unset_lock(TBL_protector, "TBL_unset_writelock(protector)");	\
    monet_unset_lock(TBL_writelock, "TBL_unset_writelock");	}


@+ Dynamic Loading

@- Module Filename Convention
The file is assumed to be in directory: module_dir (set to
$PREFIX/lib(64)/ ?)  The file is assumed to have either of these file
names, searched in the following order; <module>-<database>_<user>.so,
<module>-<database>.so, <module>_<user>.so, <module>.soo .

The function returns the dlopen handle (!=0) if the module existed. If
there is no initfunction a library is loaded nothing more should be
done. In case there is a initfunction we call it.  This function will
install the functions etc..

@- Module Loading Interface
The DL_ interface offers a UNIX dl* 'dynamic loading'-like interface
that can either be implemented using dynamic loading or with static
loading. In case of static loading, libs and functions should first
be registered with the DL_register_* functions.
@h
m_export void *DL_reglib(str path, void *dynamic_handle, int maxsize);
m_export int DL_regfcn(void *tbl, ptr fcnptr, str name);

#ifdef __cplusplus
}
#endif
#endif				/* _MONET_TBL_H */
@c
#ifndef STATIC

#ifdef HAVE_DLFCN_H
# include <dlfcn.h>
#endif

#else

#define RTLD_LAZY	1
#define RTLD_NOW	2
#define RTLD_GLOBAL	4
#define RTLD_NOW_REPORT_ERROR	8

#endif

#define DL_TABLE_MAXLIBS 128

typedef struct {
	str name;
	ptr value;
} dlentry;

typedef struct {
	void *dynamic_handle;
	int size;
	dlentry entry[1];	/* extended to just the right length */
} dltable;

int DL_errno = 0;

#ifndef STATIC
static const char *DL_errmsg;
#endif
str DL_mod[DL_TABLE_MAXLIBS] = { 0 };
dltable *DL_table[DL_TABLE_MAXLIBS] = { 0 };

void *
DL_reglib(str nme, void *dynamic_handle, int maxsize)
{
	int i;

	for (i = 0; i < DL_TABLE_MAXLIBS; i++)
		if (DL_mod[i] == NULL) {
			dltable *tbl = (dltable *)
			    GDKmalloc(sizeof(dltable) + (maxsize - 1) * sizeof(dlentry));

			DL_mod[i] = GDKstrdup(nme);
			DL_table[i] = tbl;
			tbl->dynamic_handle = dynamic_handle;
			tbl->size = 0;
			return tbl;
		}
	GDKfatal("DL_reglib: too many libs");
	return NULL;
}

int
DL_regfcn(void *handle, ptr fcnptr, str name)
{
	dltable *tbl = (dltable *) handle;

	tbl->entry[tbl->size].value = fcnptr;
	tbl->entry[tbl->size++].name = GDKstrdup(name);
	return 0;
}


static char *
locate_file(const char *basename, const char *ext)
{
	char *mod_path = GDKgetenv("monet_mod_path");
	char *fullname;
	size_t fullnamelen;
	size_t filelen = strlen(basename) + strlen(ext);

	if (mod_path == NULL)
		return NULL;
	while (*mod_path == PATH_SEP)
		mod_path++;
	if (*mod_path == 0)
		return NULL;
	fullnamelen = 512;
	fullname = GDKmalloc(fullnamelen);
	while (*mod_path) {
		size_t i;
		char *p;
		int fd;

		if ((p = strchr(mod_path, PATH_SEP)) != NULL) {
			i = p - mod_path;
		} else {
			i = strlen(mod_path);
		}
		while (i + filelen + 2 > fullnamelen) {
			fullnamelen += 512;
			fullname = GDKrealloc(fullname, fullnamelen);
		}
		/* we are now sure the directory name, file
		   base name, extension, and separator fit
		   into fullname, so we don't need to do any
		   extra checks */
		strncpy(fullname, mod_path, i);
		fullname[i] = DIR_SEP;
		strcpy(fullname + i + 1, basename);
		strcat(fullname + i + 1, ext);
		if ((fd = open(fullname, O_RDONLY)) >= 0) {
			close(fd);
			return GDKrealloc(fullname, strlen(fullname) + 1);
		}
		if ((mod_path = p) == NULL)
			break;
		while (*mod_path == PATH_SEP)
			mod_path++;
	}
	/* not found */
	GDKfree(fullname);
	return NULL;
}

#define MIL_EXT ".mil"

static char *
MSP_locate_script(const char *mod_name)
{
	return locate_file(mod_name, MIL_EXT);
}

static char *
MSP_locate_module(const char *mod_name)
{
	char *lib_name = GDKmalloc(strlen(mod_name) + strlen(SO_PREFIX) + 1);
	char *fullname;

	strcpy(lib_name, SO_PREFIX);
	strcpy(lib_name + strlen(SO_PREFIX), mod_name);

	fullname = locate_file(lib_name, SO_EXT);
#ifdef _AIX
	fullname = GDKrealloc(fullname, strlen(fullname) + strlen(lib_name) + 5);
	strcat(fullname, "(");
	strcat(fullname, lib_name);
	strcat(fullname, ".0)");
#endif
	GDKfree(lib_name);
	return fullname;
}

void *
DL_open(char *nme, int mode)
{
	dltable *tbl = NULL;
	int i;

	DL_errno = 0;
#ifndef STATIC
	DL_errmsg = NULL;

/* AIX requires RTLD_MEMBER to load a module that is a member of an archive.  */
#ifdef RTLD_MEMBER
	mode |= RTLD_MEMBER;
#endif
#endif
	for (i = 0; i < DL_TABLE_MAXLIBS; i++)
		if (DL_mod[i] && strcmp(DL_mod[i], nme) == 0) {
			tbl = DL_table[i];
		}

	if (tbl == NULL) {
#ifndef STATIC
		char *fullname;

		if ((fullname = MSP_locate_module(nme)) != NULL) {
			void *hdl;

			if ((hdl = dlopen(fullname, mode)) != NULL) {
				tbl = (dltable *) DL_reglib(nme, hdl, 0);
			} else {
				DL_errmsg = dlerror();
				GDKerror("DL_open: dlopen(%s,%d) -> Error: %s.\n", fullname, mode, DL_errmsg);
			}
			GDKfree(fullname);
		} else
			DL_errmsg = "library not found";
#else
		(void) mode;
		DL_errno = 1;
#endif
	}
	return (void *) tbl;
}

void *
DL_sym(void *handle, const char *nme)
{
	dltable *tbl = (dltable *) handle;
	int i;

	DL_errno = 0;
#ifndef STATIC
	if (tbl->dynamic_handle) {
		return dlsym(tbl->dynamic_handle, nme);
	}
#endif
	for (i = 0; i < tbl->size; i++) {
		if (strcmp(tbl->entry[i].name, nme) == 0) {
			return (void *) tbl->entry[i].value;
		}
	}
	DL_errno = 2;
	return NULL;
}


int
DL_close(void *handle)
{
	int ret = 0;

#ifndef STATIC
	dltable *tbl = (dltable *) handle;
	int i;

	if (tbl->dynamic_handle) {
		ret = dlclose(tbl->dynamic_handle);
		for (i = 0; i < DL_TABLE_MAXLIBS; i++) {
			if (DL_table[i] == tbl) {
				GDKfree(DL_mod[i]);
				DL_table[i] = NULL;
				DL_mod[i] = NULL;
			}
		}
		GDKfree(tbl);
	}
#else
	(void) handle;
#endif
	return ret;
}


static short_str DL_errormsg[3] = { "no error occured (STATIC)", "library not found (STATIC)",
	"function name unknown (STATIC)"
};


const char *
DL_error(void)
{
#ifndef STATIC
	if (DL_errmsg != NULL)
		return DL_errmsg;
	if (DL_errno == 0)
		return dlerror();
#endif
	return DL_errormsg[DL_errno];
}


ptr
TBL_openmod(Client client, str module)
{
	ptr ret = 0;

	(void) client;
	if (module) {
		ret = (ptr) DL_open(module, (RTLD_NOW | RTLD_GLOBAL));
	} else {
		if (!ret)
			GDKerror("TBL_openmod: locate module: %s.\n", module);
		return 0;
	}

	if (!ret)
		GDKerror("TBL_openmod: DL_open: %s.\n", DL_error());
	return ret;		/* none found */
}


ptr
TBL_module_handle(oid mid)
{
	char *p;

	return (p = BUNfnd(TBL_mod_hdl, &mid)) ? *(int **) BUNtloc(TBL_mod_hdl, p) : 0;
}


oid
TBL_module_lookup(str module)
{
	BUN bun;		/* stupid temp storage? */
	oid *midp = BUNtailfnd(oid, BATmirror(TBL_mod_nme), bun, module);

	return midp ? *midp : 0;
}

int
TBL_M_cinstalled(Client client, oid mid)
{
	int cid = (int) (client - monet_clients);

	return (!!(BUNlocate(BATmirror(TBL_mod_use), &cid, &mid)));
}

#define BATfakeAbort(b)	((b) && ((b)->batInserted = BUNfirst(b)))

int
TBL_M_lock(Client c)
{
	dlPRINT("  -->TBL_M_lock\n");
	TBL_set_writelock();
	(void) BATfakeAbort(TBL_fcn_nme);
	(void) BATfakeAbort(TBL_fcn_fcn);
	(void) BATfakeAbort(TBL_fcn_mid);
	(void) BATfakeAbort(TBL_fcn_imp);
	(void) BATfakeAbort(TBL_fcn_tpe);
	(void) BATfakeAbort(TBL_fcn_sig);
	(void) BATfakeAbort(TBL_fcn_dsc);
	(void) BATfakeAbort(TBL_fcn_aut);
	(void) BATfakeAbort(TBL_fcn_dat);
	(void) BATfakeAbort(TBL_fcn_pro);
	(void) BATfakeAbort(TBL_fcn_cnt);
	(void) BATfakeAbort(TBL_mod_nme);
	(void) BATfakeAbort(TBL_mod_cnt);
	(void) BATfakeAbort(TBL_mod_hdl);
	(void) BATfakeAbort(TBL_mod_atm);
	(void) BATfakeAbort(TBL_mod_dep);
	(void) BATfakeAbort(TBL_mod_use);
	(void) BATfakeAbort(TBL_mod_load);
	(void) BATfakeAbort(TBL_mod_drop);
	(void) BATfakeAbort(TBL_mod_proc);
	(void) BATfakeAbort(TBL_mod_var);
	if (c && c->atomtbl) 
		(void) BATfakeAbort(c->atomtbl);
	dlPRINT("  <--TBL_M_lock\n");
	return 1;
}

int
TBL_M_unlock(Client c)
{
	dlPRINT("  -->TBL_M_unlock\n");
	BATfakeCommit(TBL_fcn_nme);
	BATfakeCommit(TBL_fcn_fcn);
	BATfakeCommit(TBL_fcn_mid);
	BATfakeCommit(TBL_fcn_imp);
	BATfakeCommit(TBL_fcn_tpe);
	BATfakeCommit(TBL_fcn_sig);
	BATfakeCommit(TBL_fcn_dsc);
	BATfakeCommit(TBL_fcn_aut);
	BATfakeCommit(TBL_fcn_dat);
	BATfakeCommit(TBL_fcn_pro);
	BATfakeCommit(TBL_fcn_cnt);
	BATfakeCommit(TBL_mod_nme);
	BATfakeCommit(TBL_mod_cnt);
	BATfakeCommit(TBL_mod_hdl);
	BATfakeCommit(TBL_mod_atm);
	BATfakeCommit(TBL_mod_dep);
	BATfakeCommit(TBL_mod_use);
	BATfakeCommit(TBL_mod_load);
	BATfakeCommit(TBL_mod_drop);
	BATfakeCommit(TBL_mod_proc);
	BATfakeCommit(TBL_mod_var);
	if (c) {
		if (BATdirty(c->fcntbl)) {
			/* Restore correct hash-list order for function resolution..
			 * (1) order on oid => have functions in order of definition
			 * (2) then rehash => last-defined first in hash-list
			 */
			BATorder(BATmirror(c->fcntbl));
			if (BATprepareHash(c->fcntbl))
				assert(0);
			BATfakeCommit(c->fcntbl);
		}
		BATfakeCommit(c->atomtbl);
	}
	TBL_unset_writelock();
	dlPRINT("  <--TBL_M_unlock\n");
	return 1;
}


@+ Misc Information Functions
@- TBL_unpacked
Return the implementation routine hidden behind its pack function.
@c
ptr
TBL_unpacked(ptr imp)
{
	BAT *b = BATmirror(TBL_fcn_imp);
	BUN bun;
	oid *fid;
	ptr *s = 0;

	TBL_set_readlock();
	fid = BUNtailfnd(oid, b, bun, &imp);

	if (fid)
		s = BUNtailfnd(ptr, TBL_fcn_fcn, bun, fid);

	TBL_unset_readlock();
	return (s) ? *s : 0;
}

@- TBL_getparams
We have info registered about the function prototype of each
implementation. Normally, this is hidden by the _chk and _pack
routines. The information is kept for those who want to use the
unpacked implementations directly (for optimization purposes).
@c
static int
getparams(oid fid, str argv[])
{
	str *s = argv, *t = s;
	hash_t i;
	int j = 0;
	BUN p;
	oid *fidp = &fid;

	if (BATprepareHash(TBL_fcn_pro))
		assert(0);
	HASHloop_oid(TBL_fcn_pro, TBL_fcn_pro->hhash, i, fidp, p) {
		*(t++) = (str) BUNtvar(TBL_fcn_pro, p);
		j++;
	}
	while (++s < --t) {
		str swap = *s;

		*s = *t;
		*t = swap;
	}
	return j;
}

int
TBL_getparams(ptr imp, str argv[])
{
	BAT *b = BATmirror(TBL_fcn_imp);
	BUN p;
	int nparams;

	TBL_set_readlock();
	nparams = getparams(*BUNtailfnd(oid, b, p, &imp), argv);

	TBL_unset_readlock();

	return nparams;
}

@- TBL_checkparams
@T
This routine checks whether a set of actual parameters make a match
with the signature of a certain registered MIL operator. Signatures
are registered in the {\tt monet\_fcn\_pro} system BAT, which
contains function oids and strings. This BAT contains sequences
of the same OIDS.

The sequence of strings in the tail contains the
successive parameters of the operator. The first string identifies the
return type, the second identifies the first parameter type, the third
its second parameter, etc.

The types are denoted by their usual MIL atomic type name. BATs are
spelled in lowercase, concatenated by two (comma separated) types for
their head and tail (enclosed by square brackets). For instance
'bat[oid,flt]' identifies a BAT withs OIDs in the head and floats
in the tail. Wildcard types are denoted with 'any', and -- like in MEL --
free type variables with 'any::<NUM>'. Finally, there is now support
for constant values to be used in overloading like 'str(inbox)'. This
identifies a string value "inbox".

This routine makes all generated and compiled type-checking routines
unnecessary, which has two advantages:
\begin{itemize}
\item the code size of the compiled modules will shrink considerably
\item at run-time, new signatures can be added. This enables the
      overloading mechanism to work on MIL procs as well.
\end{itemize}

When these routines are called, you are supposed to hold a readlock
on the TBL database!
@c
typedef struct {
	/* basic info about the params */
	int argc;		/* number of actual params + 1 */
	ValPtr argv;		/* array with actual params */
	str tps[1 + MAXPARAMS];	/* string type names of actual params */
	str htps[1 + MAXPARAMS];	/* (if tps[i]==bat) string head type name */
	str htpsl[1 + MAXPARAMS];	/* (if tps[i]==bat) string head logical type name */
	str ttps[1 + MAXPARAMS];	/* (if tps[i]==bat) string tail type name */
	str ttpsl[1 + MAXPARAMS];	/* (if tps[i]==bat) string tail logical type name */

	/* any resolution handling */
	int anynums;		/* number of instantiated any vars */
	int anynum[1 + MAXPARAMS];	/* tag number of the any var */
	str anyval[1 + MAXPARAMS];	/* instantiated type of any var */
} paramcheck_t;

/* for built-in types use BATatoms and not atomtbl because finding
   TYPE_bat is not reliable otherwise (there is both "bat" and "BAT"
   in atomtbl) */
#define ATOM_LOOKUP(nme, tpe, atomtbl) {			\
	int _tpe = tpe;						\
	if (_tpe <= TYPE_str) nme = BATatoms[_tpe].name;	\
	else {							\
		BUN _p = BUNfnd(atomtbl, &_tpe);		\
		if (_p == NULL) return TBL_RESOLVE_NOTPE;	\
			nme = (str) BUNtail(atomtbl, _p);	\
	}							\
}

int
TBL_checkparams_init(paramcheck_t *pt, int argc, ValPtr argv, BAT *atomtbl)
{
	int i;

	pt->argc = argc;
	pt->argv = argv;
	for (i = 1; i < argc; i++) {
		ATOM_LOOKUP(pt->tps[i], argv[i].vtype, atomtbl);

		pt->htps[i] = pt->ttps[i] = NULL;

		if (argv[i].vtype == TYPE_bat) {
			bat bid = argv[i].val.bval;
			int htpe = 0, ttpe = 0;
			int hvid = 0, tvid = 0;
			BAT *b;

			BBPfix(bid);
			b = (BAT*)BBPgetdesc(ABS(bid));
			if (b) {
				/* swap head/tail types in case of mirrored bats */
				htpe = (bid > 0) ? b->htype : b->ttype;
				ttpe = (bid > 0) ? b->ttype : b->htype;
				if (htpe == TYPE_void)
				 	hvid = (bid > 0)?(b->hseqbase != oid_nil):(b->tseqbase != oid_nil);
				if (ttpe == TYPE_void)
				 	tvid = (bid > 0)?(b->tseqbase != oid_nil):(b->hseqbase != oid_nil);
			}
			BBPunfix(bid);
			if (b) {
				ATOM_LOOKUP(pt->htps[i], htpe, atomtbl);
				pt->htpsl[i] = pt->htps[i];
				if (hvid)
					ATOM_LOOKUP(pt->htpsl[i], ATOMtype(htpe), atomtbl);
				ATOM_LOOKUP(pt->ttps[i], ttpe, atomtbl);
				pt->ttpsl[i] = pt->ttps[i];
				if (tvid)
					ATOM_LOOKUP(pt->ttpsl[i], ATOMtype(ttpe), atomtbl);
			}
		}
	}
	return 0;
}

#define same_type(s1,s2)	(strcmp(s1, s2) == 0)

static INLINE int
TBL_checkparam(paramcheck_t *pt, ValPtr v1, str tp1, str ltp, str tp2, bit void_equal_oid)
{
	int j, k;

	(void) v1;

	/* simple 1-1 match */
	if (same_type(tp1, tp2)) {
		return TRUE;
	}
	if (void_equal_oid && same_type(ltp, tp2)) {
		return TRUE;
	}

	/* wildcard type (any) in signature? */
	if (tp2[0] == 'a' && tp2[1] == 'n' && tp2[2] == 'y') {
		if (tp2[3] == 0) {
			return TRUE;
		}
		if (tp2[3] == ':') {
			k = atoi(tp2 + 5);
			for (j = 0; j < pt->anynums; j++)
				if (pt->anynum[j] == k) {
					return same_type(ltp, pt->anyval[j]);
				}
			pt->anyval[pt->anynums] = ltp;
			pt->anynum[pt->anynums++] = k;
			return TRUE;
		}
	}
	return FALSE;
}

int
TBL_checkparams(paramcheck_t *pt, oid op)
{
	str params[1 + MAXPARAMS], v;
	int i, j, nparams = getparams(op, params);

	pt->anynums = 0;

	/* check for too many actual params (including varargs check!) */
	if (nparams > 1 && params[nparams - 1][0] == '*') {
		if (pt->argc < nparams) {
			nparams--;	/* zero params */
		} else {
			v = ++(params[nparams - 1]);	/* eat away the '*' */
			while (nparams < pt->argc)
				params[nparams++] = v;	/* fill other params */
		}
	} else if (pt->argc > nparams) {
		return TBL_RESOLVE_NOFCN;
	}
	if (pt->argc < nparams) {
		return TBL_RESOLVE_NOFCN;
	}

	/* do the check between signature and actual params */
	for (i = 1; i < nparams; i++) {
		str param = params[i];

		if (param[0] == 'B' && param[1] == 'A' && param[2] == 'T' && param[3] == '[') {
			char tpe[IDLENGTH];

			if (pt->htps[i] == NULL)
				return TBL_RESOLVE_NOSIG;	/* quick bat check */

			for (v = tpe, j = 4; param[j] != ','; j++, v++)
				*v = param[j];
			*v = 0;
			if (!TBL_checkparam(pt, NULL, pt->htps[i], pt->htpsl[i], tpe, TRUE)) {
				return TBL_RESOLVE_NOSIG;
			}
			for (v = tpe, j++; param[j] != ']'; j++, v++)
				*v = param[j];
			*v = 0;
			if (!TBL_checkparam(pt, NULL, pt->ttps[i], pt->ttpsl[i], tpe, TRUE)) {
				return TBL_RESOLVE_NOSIG;
			}
		} else if (!TBL_checkparam(pt, pt->argv + i, pt->tps[i], pt->tps[i], param, FALSE)) {
			return TBL_RESOLVE_NOSIG;
		}
	}

	/* FOUND! now resolve the returntype to an actual type number */
	v = params[0];
	if (v[0] == 'a' && v[1] == 'n' && v[2] == 'y') {
		if (v[3] == ':' && v[4] == ':') {
			for (i = 0, j = atoi(v + 5); i < pt->anynums; i++)
				if (j == pt->anynum[i]) {
					v = pt->anyval[i];
					goto ready;
				}
		}
		return 0;
	}
      ready:
	if (v[0] == 'B' && v[1] == 'A' && v[2] == 'T') {
		return TYPE_bat;
	}
	i = ATOMindex(v);
	return (i < 0) ? 0 : i;
}

@- TBL_getname
For debugging purposes it may become necessary to locate the string
associated with a pointer in the fcntable.
@c
str
TBL_getname(ptr imp)
{
	BAT *b = BATmirror(TBL_fcn_imp);
	BUN bun;
	oid *fid;
	str s = 0;

	TBL_set_readlock();
	if ((fid = BUNtailfnd(oid, b, bun, &imp)) == 0) {
		GDKerror("TBL_getname: non-existing function %p.\n", imp);
	} else if ((s = BUNtailfnd(char, TBL_fcn_nme, bun, fid)) == 0) {
		GDKerror("TBL_getname: no name for function %lu.\n", *fid);
	}
	TBL_unset_readlock();
	return s;
}

/* used in lex_name() */
str
TBL_fndname(ptr imp)
{
	BAT *b = BATmirror(TBL_fcn_imp);
	BUN bun;
	oid *fid;
	str s = 0;

	TBL_set_readlock();
	if ((fid = BUNtailfnd(oid, b, bun, &imp)) == 0) {
		;
	} else if ((s = BUNtailfnd(char, TBL_fcn_nme, bun, fid)) == 0) {
		;
	}
	TBL_unset_readlock();
	return s;
}

@- TBL_getddir
Obtains a list of modules by looking at what files are present in the
module directory.
@c
BAT *
TBL_getdir(void)
{
	BAT *b = BATnew(TYPE_int, TYPE_str, 100);
	int i = 0;

#ifdef STATIC
	for (i = 0; i < DL_TABLE_MAXLIBS; i++) {
		if (DL_mod[i])
			BUNins(b, &i, DL_mod[i] + 1, FALSE);
	}
#else
	char *mod_path;
	size_t extlen = strlen(MIL_EXT);
	size_t len;
	struct dirent *dent;
	DIR *dirp = NULL;

	mod_path = GDKgetenv("monet_mod_path");
	if (mod_path == NULL)
		return b;
	while (*mod_path == PATH_SEP)
		mod_path++;
	if (*mod_path == 0)
		return b;

	while (mod_path || dirp) {
		if (dirp == NULL) {
			char *cur_dir;
			char *p;

			if ((p = strchr(mod_path, PATH_SEP)) != NULL) {
				i = (int) (p - mod_path);
			} else {
				i = (int) strlen(mod_path);
			}
			cur_dir = GDKmalloc(i + 1);
			strncpy(cur_dir, mod_path, i);
			cur_dir[i] = 0;
			if ((mod_path = p) != NULL) {
				while (*mod_path == PATH_SEP)
					mod_path++;
			}
			dirp = opendir(cur_dir);
			GDKfree(cur_dir);
			if (dirp == NULL)
				continue;
		}
		if ((dent = readdir(dirp)) == NULL) {
			closedir(dirp);
			dirp = NULL;
			continue;
		}
		len = strlen(dent->d_name);
		if (len < extlen || strcmp(dent->d_name + len - extlen, MIL_EXT) != 0)
			continue;
		dent->d_name[len - extlen] = 0;
		BUNins(b, &i, dent->d_name, FALSE);
		i++;
	}
#endif
	return b;
}

@- TBL_atomname
Atom names may be qualified by leading underscores. These are
considered internal and removed.
@c
char *
TBL_atomname(int atm)
{
	char *s = ATOMname(atm), *t = s;

	while (*t) {
		if (*t++ == '_')
			return t;
	}
	return s;
}


@+ Interface for Extension Modules
@- TBL_Install_Info
We expect this function NOT to be called if the module is already
in use. (That is <name>_Module_Install should not even be called.)
@c
size_t TBL_fcn_pro_size = 0;
oid TBL_oid = 10000;		/* we cannot use the db oids, as the user may change
				   the current number. This will turn around the order
				   of the functions in the function tables, corrupting
				   the order in which function resolution should happen */

oid				/* An oid is generated */
TBL_Install_Info(TBLinstall *inst, str owner, str name)
{
	oid mid = 0;

	dlFPRINTF(GDKerr, "  TBL_Install_Info(%s, %s) = " SZFMT "\n", owner, name, (size_t) mid);
@-
if it is already loaded then we delete it, this implies
that the TBL_Install_Info is the same as reload (delete)
so dependencies should not reinstall modules?
SHOULD NEVER OCCUR UNDER NEW 'RECURSIVE LOADING' POLICY! <= P. Boncz
@c
	if ((mid = TBL_module_lookup(name))) {
		GDKwarning("TBL_Install_Info: The module %s will be reloaded.\n", name);
		TBL_unloadmod(inst->client, name, inst->level + 1);
	}

	mid = TBL_oid++;

	if (BUNins(TBL_mod_nme, &mid, name, FALSE) == NULL)
		assert(0);
	{
		int zero = 0;

		if (BUNins(TBL_mod_cnt, &mid, &zero, FALSE) == NULL)
			assert(0);
	}
	return mid;
}

@+ MIL Procedure Management

@- MIL Proc Ref counting
@T
While MIL procs are typically introduced by MIL modules, they can be typed in at anytime
in a MIL session (not belonging to any specific module). They are represented as parsed
MIL trees, with their root in TBL\_fcn\_imp and shared in all client fcntbl-s. As a consequence,
we must do indiviual refcounting for them (i.e. they cannot use the module refcnt mechanism).

The following rules apply:
\begin{itemize}
\item each client having the proc in its fcntbl adds a refcnt
\item each module that defines the proc adds a refcnt
\end{itemize}

Thus, procs introduces by a module that are explicitly 'undef-ed' by the user keep existing.
Thus, a second user that loads the module (logical load only, as he is the second user) still
gets this proc as expected.
@c
void
TBL_incproc(oid pid)
{
	int cnt = *(int *) BUNtail(TBL_fcn_cnt, BUNfnd(TBL_fcn_cnt, &pid));

	cnt++;
	if (BUNreplace(TBL_fcn_cnt, &pid, &cnt, 0) == NULL)
		assert(0);
}

void
TBL_decproc(oid pid)
{
	int cnt = *(int *) BUNtail(TBL_fcn_cnt, BUNfnd(TBL_fcn_cnt, &pid));

	if (cnt > 1) {
		cnt--;
		if (BUNreplace(TBL_fcn_cnt, &pid, &cnt, 0) == NULL)
			assert(0);
	} else {
		/* remove last reference: free MIL tree, remove from TBL structures */
		YYSTREE *x = (YYSTREE *) BUNtloc(TBL_fcn_imp, BUNfnd(TBL_fcn_imp, &pid));

		if (x && *x) {
			GDKfree((*x)->yyval.val.pval);	/* free disguised name */
			Myyfree((*x));
		}
		TBL_Deinstall_Function(pid);
	}
}

@- TBL_newproc
registers a new MIL procedure.
@c
#define PROC_SET_TYPES(t,t1,t2)   t->yyval.len = (t1&((t2<<16)&0xFFFF))
#define PROC_TYPE1(t) 	 	 (t->yyval.len&0xFFFF)
#define PROC_TYPE2(t) 		((t->yyval.len>>16)&0xFFFF)

static int
format_type(YYSTREE t, str *p)
{
	int ret = 32768;
	str s = *p;

	if (t == NULL) {
		strcpy(s, "any");
	} else if (t->token == TOK_ANY) {
		strcpy(s, "any");
		if (t->yyval.val.ival >= 0) {
			sprintf(s + 3, "::%d", t->yyval.val.ival);
		}
		ret = t->yyval.val.ival;
	} else {
		strcpy(s, t->yyval.val.sval);
	}
	*p += strlen(s);
	return ret;
}

void
TBL_newproc(Client client, str nme, str mod, YYSTREE body, YYSTREE sig, YYSTREE ret)
{
	int j, tpe = TOK_PROC;
	oid pid = TBL_oid++;

	TBL_M_lock(NULL);
	TBL_fcn_pro_size++;
	if (body == sig) {
		/* forward definitions will never actually match */
		if (BUNins(TBL_fcn_pro, &pid, "<predefinition>", FALSE) == NULL)
			assert(0);
	} else {
		sht anynum, *any1 = NULL, *any2 = NULL;
		sht t1 = 0,t2 = 0;
		char returntpe[128];

		if (ret) {
			char *p = returntpe;

			format_type(ret, &p);

			/* analyze the return type specification */
			if (ret->token == TOK_ATOM) {
				t1 = ATOMindex(ret->yyval.val.sval);
				if (t1 == TYPE_bat) {
					*(p++) = '[';
					format_type(ret->yysons[0], &p);
					*(p++) = ',';
					format_type(ret->yysons[1], &p);
					*(p++) = ']';
					*(p++) = 0;
					if (ret->yysons[0]->token == TOK_ATOM) {
						t1 = 8192 + ATOMindex(ret->yysons[0]->yyval.val.sval);
					} else {	/* TOK_ANY */
						t1 = ret->yysons[0]->yyval.val.ival;
						any1 = &t1;
					}
					if (ret->yysons[1]->token == TOK_ATOM) {
						t2 = 8192 + ATOMindex(ret->yysons[1]->yyval.val.sval);
					} else {	/* TOK_ANY */
						t2 = ret->yysons[1]->yyval.val.ival;
						any2 = &t2;
					}
				} else {	/* simple atom */
					t1 += 8192;
				}
			} else {	/* TOK_ANY */
				t1 = ret->yyval.val.ival;
				any1 = &t1;
			}

		} else {
			strcpy(returntpe, "any");
		}

		/* insert a signature in TBL_fcn_pro */
		if (sig == NULL) {
			if (BUNins(TBL_fcn_pro, &pid, "*any", FALSE) == 0)
				assert(0);
		} else {
			YYSTREE cur = sig;

			for (j = 1; cur; cur = YYOVERFLOW(cur)) {
				unsigned i;

				for (i = 0; i < cur->cnt; i++, j++) {
					char tpenme[512], *p = tpenme;
					YYSTREE t = cur->yysons[i];

					if (t->token == TOK_RANGETEMP) {
						*(p++) = '*';
						t = t->yysons[0];
					}

					/* the any stuff resolves any::X expressions in
					   the return type specification, when we encounter
					   the any::X in the signature */
					anynum = format_type(t, &p);
					if (t->token == TOK_ATOM && strcmp(t->yyval.val.sval, "BAT") == 0) {
						*(p++) = '[';
						anynum = format_type(t->yysons[0], &p);
						if (any1 && *any1 == anynum)
							*any1 = 2048 + j;
						if (any2 && *any2 == anynum)
							*any2 = 2048 + j;
						*(p++) = ',';
						anynum = format_type(t->yysons[1], &p);
						if (any1 && *any1 == anynum)
							*any1 = 1024 + j;
						if (any2 && *any2 == anynum)
							*any2 = 1024 + j;
						*(p++) = ']';
						*(p++) = 0;
					} else {
						if (any1 && *any1 == anynum)
							*any1 = 4096 + j;
						if (any2 && *any2 == anynum)
							*any2 = 4096 + j;
						if (t->cnt > 0)
							t = t->yysons[0];
						if (t->token == TOK_STRING) {
							*(p++) = '(';
							strcpy(p, t->yyval.val.sval);
							p += strlen(p);
							*(p++) = ')';
							*(p++) = 0;
						}
					}
					if (BUNins(TBL_fcn_pro, &pid, tpenme, FALSE) == NULL)
						assert(0);
				}
			}
		}
		if ((any1 && *any1 < 1024) || (any2 && *any2 < 1024)) {
			if (any1 && *any1 < 1024)
				t1 = 4096;
			if (any2 && *any2 < 1024)
				t2 = 4096;
		}
		PROC_SET_TYPES(body,t1,t2);
		if (BUNins(TBL_fcn_pro, &pid, returntpe, FALSE) == NULL)
			assert(0);
	}
	j = 1;			/* initial reference count */
	if (mod) {
		if (BUNins(TBL_mod_proc, mod, &pid, FALSE) == NULL)
			assert(0);
		j++;		/* extra reference if it belongs to a module */
	}
	if (BUNins(TBL_fcn_cnt, &pid, &j, FALSE) == NULL)
		assert(0);
	if (BUNins(TBL_fcn_nme, &pid, nme, FALSE) == NULL)
		assert(0);
	if (BUNins(TBL_fcn_imp, &pid, &body, FALSE) == NULL)
		assert(0);
	if (BUNins(TBL_fcn_tpe, &pid, &tpe, FALSE) == NULL)
		assert(0);
	if (BUNins(client->fcntbl, nme, &pid, FALSE) == NULL)
		assert(0);

	/* use this space only once, so disguise name str as a ptr */
	body->yyval.vtype = TYPE_ptr;
	body->yyval.len = 0;

	TBL_M_unlock(client);
}

@- TBL_delproc
forcedly removes it from a client fcntbl.

depending on its refcnt, the proc may continue to exist for other clients
and for the module it was defined in.
@c
void
TBL_delproc(Client client, str nme)
{
	hash_t i;

	TBL_M_lock(client);
	if (BATprepareHash(client->fcntbl))
		assert(0);
	HASHloop_str(client->fcntbl, client->fcntbl->hhash, i, nme) {
		BUN p = BUNptr(client->fcntbl, i);
		oid pid = *(oid *) BUNtloc(client->fcntbl, p);

		if (*(int *) BUNtloc(TBL_fcn_tpe, BUNfnd(TBL_fcn_tpe, &pid)) == TOK_PROC) {
			TBL_decproc(pid);
			if (BUNdelete(client->fcntbl, p, FALSE) == NULL)
				assert(0);
		}
	}
	TBL_M_unlock(client);
}

@+ Initialization
Most dictionary tables are created once and loaded upon system
restart. By keeping the reference count at one we are assured that
they remain fixed in memory for the duration of the session.
@c
static BAT *
TBL_create(Client client, str nme, int cnt, int htpe, int ttpe, int hmode, int tmode)
{
	BAT *b = BATnew(htpe, ttpe, cnt);
	char buf[128], *user = client->user;
	Variable v;

	if (b == NULL)
		GDKfatal("TBL_create: could not allocate.");
	if (hmode)
		BATkey(b, hmode);
	if (tmode)
		BATkey(BATmirror(b), tmode);

	/* the batname is prefixed with the client user name to make in easy to spot
	 * in the BBP dir list. Note that this rename may fail if such a bat already
	 * exists (very rare and contrived though)
	 */
	sprintf(buf, "%s_%s", user ? user : "monet", nme);
	BBPrename(b->batCacheid, buf);

	/* whereas the batname is for debugging, each client sees his bat using the
	 * alias monet_X using a MIL variable.
	 */
	if (user) {
		sprintf(buf, "monet_%s", nme);
		v = VARnew((Cntxt) (client - monet_clients), buf);
		v->binding.val.bval = b->batCacheid;
		v->binding.vtype = TYPE_bat;
		v->binding.len = 0;
		BBPincref(b->batCacheid, TRUE);
		VARfreeze(v);
		VARfixate(v);
	}
	return b;
}

static BAT *
TBL_fathercopy(Client client, Client father, str nme)
{
	char buf[128];
	Variable v;
	BAT *b = NULL;

	sprintf(buf, "monet_%s", nme);
	v = VARfind(&father->stk, buf);
	if (v) {		/* dirty replacement of the client bats */
		Variable n = VARnew(client->stk, v->name);
		BAT *o = BATdescriptor(v->binding.val.bval);

		n->constant = TRUE;
		n->frozen = TRUE;
		n->binding.vtype = TYPE_bat;
		b = BATcopy(o, o->htype, o->ttype, TRUE);
		BBPincref(b->batCacheid, TRUE);
		BBPdecref(o->batCacheid, FALSE);
		n->binding.val.bval = b->batCacheid;
	} else {
		GDKerror("TBL_fathercopy: variable %s not found\n", buf);
	}
	return b;
}

@- TBL_Init
The TBL initialization creates a set of function tables.
Subsequently the starting address of all built-in functions is stored,
(and documentary information) [Should be removed or used as a view]
Since all code will move to modules this function will be come obsolute.
@= TBL_create
	TBL_@1_@2 = TBL_create(monet_clients,"@1_@2",@5,TYPE_@3,TYPE_@4,@6,@7);
@c
void
TBL_protect()
{
	TMDEBUG printf("# TBL locks created\n");

	MT_init_lock(TBL_protector);
	MT_init_lock(TBL_writelock);
	MT_init_sema(TBL_barrier, 0);
}
void
TBL_init(void)
{
	TBL_M_lock(NULL);

@- Empty the function table.
Since the BBP will no longer store these tables only creation is needed
@c
	@:TBL_create(fcn,fcn,oid,ptr,600,BOUND2BTRUE,TRUE)@
	@:TBL_create(fcn,imp,oid,ptr,600,BOUND2BTRUE,FALSE)@
	@:TBL_create(fcn,tpe,oid,int,600,BOUND2BTRUE,FALSE)@
	@:TBL_create(fcn,mid,oid,oid,600,BOUND2BTRUE,FALSE)@

	if (BATprepareHash(TBL_fcn_mid))
		assert(0);
	@:TBL_create(fcn,sig,oid,str,100,BOUND2BTRUE,FALSE)@
	@:TBL_create(fcn,dsc,oid,str,500,BOUND2BTRUE,FALSE)@
	@:TBL_create(fcn,aut,oid,str,500,BOUND2BTRUE,FALSE)@
	@:TBL_create(fcn,dat,oid,str,500,BOUND2BTRUE,FALSE)@
	@:TBL_create(fcn,nme,oid,str,600,BOUND2BTRUE,FALSE)@
	@:TBL_create(fcn,pro,oid,str,2400,FALSE,FALSE)@
	@:TBL_create(fcn,cnt,oid,int,600,BOUND2BTRUE,FALSE)@

@- Look up the module table.
@c
	@:TBL_create(mod,nme,oid,str,40,BOUND2BTRUE,BOUND2BTRUE)@
	@:TBL_create(mod,cnt,oid,int,40,BOUND2BTRUE,FALSE)@
	@:TBL_create(mod,atm,oid,str,40,FALSE,FALSE)@
	@:TBL_create(mod,hdl,oid,ptr,40,BOUND2BTRUE,TRUE)@
	@:TBL_create(mod,dep,oid,str,40,FALSE,FALSE)@
	@:TBL_create(mod,use,oid,int,40,FALSE,FALSE)@
	@:TBL_create(mod,load,oid,str,40,BOUND2BTRUE,FALSE)@
	@:TBL_create(mod,drop,oid,int,40,FALSE,FALSE)@
	@:TBL_create(mod,proc,str,oid,200,FALSE,FALSE)@
	@:TBL_create(mod,var,str,ptr,200,FALSE,FALSE)@

@-
The function tables have been updated with session specific
information. This is for the moment sufficient. The tables are not
saved on disk so no commit is needed.
@c
#ifdef MKMODS
	TEM_init();
#endif
	TBL_M_unlock(NULL);
}

@+ Loading and Dropping Modules
@c
oid
TBL_M_load(TBLinstall *inst, Client client, str module)
{
	ptr hdl = NULL;
	oid mid = 0;
	char mod_init_name[PATHLENGTH];
	oid (*mod_init) (TBLinstall *, str) = NULL;;

	dlFPRINTF(GDKerr, "  TBL_M_load(%s)\n", module);
	if (!(hdl = TBL_openmod(client, module))) {
		GDKerror("TBL_loadmod: module load %s cancelled.\n", module);
		return 0;
	}

	sprintf(mod_init_name, "%s_Module_Install", module);
	mod_init = (oid (*)(TBLinstall *, str)) DL_sym(hdl, mod_init_name);
	if (mod_init == NULL) {
		dlFPRINTF(GDKerr, "    No function %s\n", mod_init_name);
		GDKerror("TBL_M_load: %s not a module.\n", module);
		return 0;
	}

	dlFPRINTF(GDKerr, "    Calling %s\n", mod_init_name);
	mid = (*mod_init) (inst, client->user);
	if (mid == 0) {
		/* Not ok, an error is returned! */
		/* we should bail out! */
		GDKerror("TBL_M_load: %s_Module_Install experienced an error!\n", module);
		DL_close(hdl);
		return 0;
	}
	if (BUNdelHead(TBL_mod_hdl, &mid, FALSE) == NULL)
		assert(0);
	if (BUNins(TBL_mod_hdl, &mid, &hdl, FALSE) == NULL)
		assert(0);
	dlPRINT("TBL_M_load: Everything is ok, let's return...\n");
	return mid;
}

oid
TBL_load_script(TBLinstall *inst, Client client, str module, str *initscript)
{
	oid mid = 0;
	char *fullname;

	if (strcmp(module, "main") == 0) {
		mid = TBL_Install_Info(inst, client->user, module);
		dlPRINT("TBL_M_load: Everything is ok, let's return...\n");
	} else if ((fullname = MSP_locate_script(module)) != NULL) {
		*initscript = monet_load_script(fullname, module);
		GDKfree(fullname);
		mid = TBL_Install_Info(inst, client->user, module);
		dlPRINT("TBL_M_load: Everything is ok, let's return...\n");
	}
	return mid;
}

int
TBL_M_client_install(Client client, oid mid)
{
	char *nme, s[80];
	BAT *fcn_mid = BATmirror(TBL_fcn_mid);
	hash_t i;
	int aid, j;
	oid fid;
	oid *midp = &mid;
	BUN r;

	dlPRINT("  TBL_M_client_install");

	/* Install all atoms in user atomtbl.
	 */
	if (BATprepareHash(TBL_mod_atm))
		assert(0);
	HASHloop_oid(TBL_mod_atm, TBL_mod_atm->hhash, i, midp, r) {
		nme = (char *) BUNtail(TBL_mod_atm, r);
		for (j = 0; nme[j] && nme[j] != '='; j++)
			s[j] = nme[j];
		s[j] = 0;
		if ((aid = ATOMindex(s)) < 0) {
			GDKerror("TBL_M_client_install: atom '%s' unknown.\n", s);
		} else {
			if (BUNins(client->atomtbl, s, &aid, FALSE) == NULL)
				assert(0);
		}
	}

	/* Install all functions and operations in user fcntbl.
	 */
	if (BATprepareHash(fcn_mid))
		assert(0);
	assert(fcn_mid->hhash);
	HASHloop_oid(fcn_mid, fcn_mid->hhash, i, midp, r) {
		fid = *(oid *) BUNtail(fcn_mid, r);
		if (BUNins(client->fcntbl, BUNtailfnd(char, TBL_fcn_nme, r, &fid), &fid, FALSE) == NULL)
			assert(0);
	}
	return 1;
}

static int
countusage(Client client, oid mid)
{
	int xx, yy = 0, cid = (int) (client - monet_clients);
	BUN p, q;

	BATloopFast(TBL_mod_use, p, q, xx)
	    if (*(oid *) BUNhloc(TBL_mod_use, p) == mid && *(int *) BUNtloc(TBL_mod_use, p) == cid)
		yy++;
	return yy;
}

int
TBL_M_directloaded(Client client, oid mid, str module)
{
	int xx, yy = 0, zz = 0;
	BUN p, q;

	/* count the number of times we reference the module */
	zz = countusage(client, mid);

	/* count the number of references stemming from dependencies */
	BATloopFast(TBL_mod_dep, p, q, xx)
	    if (strCmp(module, BUNtvar(TBL_mod_dep, p)) == 0)
		yy += countusage(client, *(oid *) BUNhloc(TBL_mod_dep, p));

	if (zz > yy)
		return TRUE;
	if (zz < yy)
		GDKwarning("TBL_M_directloaded: %s relative refcounts are wrong (%d!=%d)!\n", module, zz, yy);

	return FALSE;
}

static int
TBL_M_clientrefs(oid mid, Client c)
{
	int xx, yy = 0, cid = (int) (c - monet_clients);
	BUN p, q;

	BATloopFast(TBL_mod_use, p, q, xx)
	    if (*(oid *) BUNhloc(TBL_mod_use, p) == mid && *(int *) BUNtloc(TBL_mod_use, p) == cid)
		yy++;
	return yy;
}

int
TBL_M_countref(oid mid)
{
	int xx, yy = 0;
	BUN p, q;

	/*debug */
	BATloopFast(TBL_mod_use, p, q, xx)
	    if (*(oid *) BUNhloc(TBL_mod_use, p) == mid)
		yy++;

	xx = *BUNtailfnd(int, TBL_mod_cnt, p, &mid);

	/*debug */
	if (xx != yy)
		GDKwarning("TBL_M_countref: mod(" SZFMT ") refcnt %d: should be %d.\n", (size_t) mid, xx, yy);

	return yy;
}

int
TBL_M_incref(Client client, oid mid)
{
	int cid = (int) (client - monet_clients);
	int i = TBL_M_countref(mid);

	if (BUNins(TBL_mod_use, &mid, &cid, FALSE) == NULL)
		assert(0);
	i++;
	if (BUNreplace(TBL_mod_cnt, &mid, &i, 0) == NULL)
		assert(0);
	dlFPRINTF(GDKerr, "  TBL_M_incref = %d\n", i);

	return 1;
}

int
TBL_M_decref(Client client, oid mid)
{
	int cid = (int) (client - monet_clients);
	int i = TBL_M_countref(mid);

	if (i <= 0) {
		GDKwarning("TBL_M_decref: mod(" SZFMT ") cannot decrease refcnt\n", (size_t) mid);
	} else {
		BUN p = BUNlocate(TBL_mod_use, &mid, &cid);

		assert(p);
		if (BUNdelete(TBL_mod_use, p, FALSE) == NULL)
			assert(0);
		if (--i == 0) {
			if (BUNdelHead(TBL_mod_nme, &mid, FALSE) == NULL)
				assert(0);
			if (BUNdelHead(TBL_mod_cnt, &mid, FALSE) == NULL)
				assert(0);
		} else {
			if (BUNreplace(TBL_mod_cnt, &mid, &i, FALSE) == NULL)
				assert(0);
		}
	}
	dlFPRINTF(GDKerr, "  TBL_M_decref = %d\n", i);
	return i;
}

void
TBL_inc_mod_use(Client client, Client father)
{
	int cid = (int) (father - monet_clients);
	BAT *modules_used;
	BUN p, q;
	int xx;

	modules_used = BATselect(TBL_mod_use, &cid, &cid);
	BATloopFast(modules_used, p, q, xx) {
		oid mid = *(oid *) BUNhloc(modules_used, p);

		TBL_M_incref(client, mid);
	}

	BBPreclaim(modules_used);
}


@- TBL_loadmod:
@T
byuser == cinstalled to the client
\begin{verbatim}
loaded	byuser	level	ACTION (in order!)

0	X	0	lock/       load/cinstall/incref/unlock
0	X	>0	            load/cinstall/incref
1	0	X	                 cinstall/incref
1	1	0	lock/                     incref/unlock
1	1	>0	                                 incref
\end{verbatim}
\begin{description}
\item[lock]	lock(tbl\_writelock)
\item[unlock]	unlock(tbl\_writelock)
\item[load]	openmod/mod\_inst
\item[unload]	TBL\_unload (includes decref,cunstall)
\item[cinstall]	copy TBL\_ to client->
\item[mod\_inst]	dlsym/<name>\_Module\_Install (that calls TBL\_Inst\_Depend)
\item[cinstall]	copies to client->xx tables and returns MIL init script.
\end{description}
@
@c


oid
TBL_loadmod(Client client, str module, str parmod, int level, str *initstr)
{
	/* State */
	TBLinstall inst;
	int loaded = 0;
	int cinstalled = 0;

	/* handles */
	oid mid = 0;

	dlFPRINTF(GDKerr, "TBL_loadmod(,%s,%d,)\n", module, level);
@
Save some state for recursive calls, without explicit arguments
@c

	/* identify as father */
	while (client->father != -1) {
		client = monet_clients + client->father;
	}
	inst.client = client;
	inst.initstr = initstr;
	inst.level = level;
@
Lets do the things in the right order, see above!
@c
	if (level == 0)
		TBL_M_lock(NULL);

	mid = TBL_module_lookup(module);
	loaded = (mid != 0);

	dlFPRINTF(GDKerr, "  loaded = %d\n", loaded);
	if (!loaded) {
		if (module[0] == '_') {
			mid = TBL_M_load(&inst, client, module);	/* generates a mid! */
		} else {
			mid = TBL_load_script(&inst, client, module, initstr);
		}
		loaded = (mid != 0);
	} else {
		/* load the (already known) dependency modules, just to add fcns and atoms to the parsing tables */
		BAT *b = BAT_select(BATmirror(TBL_mod_dep), &mid, &mid, FALSE);
		BUN p, q;

		BATloop(b, p, q) {
			TBL_loadmod(client, (str) BUNhvar(b, p), module, level + 1, initstr);
		}
		BBPreclaim(b);
	}
	dlFPRINTF(GDKerr, "  loaded = %d, mid = " SZFMT "\n", loaded, (size_t) mid);

	if (loaded) {
		cinstalled = TBL_M_cinstalled(client, mid);
		if (parmod) {
			oid pmid = TBL_module_lookup(parmod);

			TBL_Insert_Depend(pmid, module);
		}
		dlFPRINTF(GDKerr, "  installed = %d\n", cinstalled);
		if (!cinstalled) {
			dlPRINT("TBL_loadmod: loaded but not installed! Installing...\n");
			cinstalled = TBL_M_client_install(client, mid);
			dlFPRINTF(GDKerr, "  installed = %d\n", cinstalled);
		}
		TBL_M_incref(client, mid);
	}
	if (level == 0)
		TBL_M_unlock(client);
	return (cinstalled != 0);
}



@- TBL_unloadmod

We now check before unloading that there are no MIL variables or loaded BATs of object
types atoms introduced by the module-to-be-dropped. If there are any, the drop fails.
@c
static int
unloadmod_exit(int ret, Client father, int *tpes)
{
	if (father)
		TBL_M_unlock(father);
	GDKfree(tpes);
	return ret;
}

static int
unloadmod_bat(BAT *b, oid mid)
{
	int xx, yy = 0;
	int refs = BBP_refs(b->batCacheid);

	if (refs > 0) {
		BUN p, q;

		BATloopFast(TBL_mod_drop, p, q, xx) {
			if (*(oid *) BUNhloc(TBL_mod_drop, p) == mid && ABS(*(bat *) BUNtloc(TBL_mod_drop, p)) == ABS(b->batCacheid)) {
				yy++;
			}
		}
		return MAX(0, refs - yy);
	}
	return BBPreclaim(b);
}

static int
unloadmod_check_use(oid mid, str module, int ntpes, int *tpes )
{
	int i, j;
	BUN p, q;
	str foundvar;

	if (ntpes == 0)
		return 0;

	/* look in all MIL variable contexts for values of soon obsolete types */
	foundvar = VARfindinstance(&i, &j, ntpes, tpes);
	if (foundvar) {
		Client c;

		CNTXTclient(i, &c);
		GDKerror("unloadmod_check_use: drop(%s) failed: live variable %s of type %s in %s context %d.\n", module, foundvar, ATOMname(j), c->user, i);
		GDKfree(foundvar);
		return -1;	/* will not be able to drop module */
	}

	/* Go through the entire BBP, looking for soon obsolete types */
	BBPlock("drop");	/* wait for all unloads to finish and block all trims and BAT load decisions */
	for (i = 1; i < BBPsize; i++) {
		if (BBPvalid(i)) {
			BAT *b = (BBP_status(i) & BBPLOADING) ? BBPdescriptor(i) : BBP_cache(i);

			if (b == NULL)
				continue;	/* if not loaded; it is not a problem.. */

			/* bat exists, is loaded, check for forbidden types and unload if possible */
			for (j = 0; j < ntpes; j++) {
				if (BAThtype(b) == tpes[j] || BATttype(b) == tpes[j]) {
					int cnt = unloadmod_bat(b, mid);

					if (cnt == 0) {
						break;
					} else if (cnt > 0) {
						GDKerror("unloadmod_check_use: drop(%s) failed: %s[%s,%s] has %d reference%s.\n", module, BBPname(i), ATOMname(b->htype), ATOMname(b->ttype), cnt, cnt > 1 ? "s" : "");
					} else {
						GDKerror("unloadmod_check_use: drop(%s) failed: %s[%s,%s] could not be unloaded due to write errors.\n", module, BBPname(i), ATOMname(b->htype), ATOMname(b->ttype));
					}
					BBPunlock("drop");
					return -1;	/* will not be able to drop module */
				}
			}
			if (j != ntpes)
				continue;
		}
	}
	/* OK: drop can go through. */
	for (i = 0; i < ntpes; i++) 
		BATatoms[tpes[i]].deleting = 1;	/* block BAT loads of these atoms */
	/* start unload for all prologue bats such that they cannot receive new refcounts */
	BATloop(TBL_mod_drop, p, q) {
		if (*(oid *) BUNhloc(TBL_mod_drop, p) == mid) {
			bat bid = ABS(*(bat *) BUNtloc(TBL_mod_drop, p));

			BBP_status_on(bid, BBPUNLOADING, "TBL_unloadmod");
		}
	}
	if (BUNdelHead(TBL_mod_drop, &mid, FALSE) == NULL)
		assert(0);
	BBPunlock("drop");	/* others can try to load BATs again */
	return 0;
}


int
TBL_module_atoms(Client client, oid mid, int **Tpes) 
{
	hash_t i;
	size_t j;
	int mtpes = MAXATOMS, ntpes = 0;
	int *tpes = (int *) GDKmalloc(mtpes * sizeof(int));
	oid *midp = &mid;
	char s[80], *nme, *r;

	/* find out which atoms belong to it */
	if (BATprepareHash(TBL_mod_atm))
		assert(0);
	HASHloop_oid(TBL_mod_atm, TBL_mod_atm->hhash, i, midp, r) {
		nme = (char *) BUNtail(TBL_mod_atm, r);
		for (j = 0; nme[j] && nme[j] != '='; j++)
			s[j] = nme[j];
		s[j] = 0;
		r = (char *) BUNfnd(client->atomtbl, s);
		assert(r);
		tpes[ntpes++] = *(int *) BUNtloc(client->atomtbl, r);
	}
	*Tpes = tpes;
	return ntpes;
}

int
TBL_unloadmod(Client client, str module, int level)
{
	BAT *fcn_mid = BATmirror(TBL_fcn_mid);
	BAT *b, *fcntbl = BATmirror(client->fcntbl);
	int refcnt = 0, (*addr) (void), ntpes, *tpes;
	oid fid, *fidp = &fid, mid, *midp = &mid;
	hash_t j;
	int i;
	ptr hdl = NULL;
	BUN p, q;
	char *r;

	/* identify as father
	 */
	while (client->father != -1) {
		client = monet_clients + client->father;
	}

	if (level == 0)
		TBL_M_lock(client);
@-
Look up the module.
@c
	mid = TBL_module_lookup(module);
	if (mid == 0) {
		int cid = (int) (client - monet_clients);
		char s[80];

		snprintf(s, sizeof(s), "_%s", module);
		mid = TBL_module_lookup(s);
		if (mid && BUNlocate(TBL_mod_use, &mid, &cid))
			GDKerror("TBL_unloadmod: module %s does not exist (maybe you mean %s?).\n", module, s);
		else
			GDKerror("TBL_unloadmod: module %s does not exist.\n", module);

		return unloadmod_exit(0, level ? NULL : client, NULL);
	}
@-
Check if it is in use already.
@c
	if (level == 0) {
		int cid = (int) (client - monet_clients);

		r = BUNlocate(TBL_mod_use, &mid, &cid);
		if (r == NULL) {
			GDKerror("TBL_unloadmod: %s was not loaded.\n", module);
			return unloadmod_exit(0, client, NULL);
		}
		if (!TBL_M_directloaded(client, mid, module)) {
			GDKerror("TBL_unloadmod: others need %s.\n", module);
			return unloadmod_exit(0, client, NULL);
		}
	}
@-
preparation phase (only meaningful for C-modules) */
@c
	ntpes = TBL_module_atoms( client, mid, &tpes );
@-
check if the C-module is physically dropped that none of its atoms is in use
@c
	if (TBL_M_countref(mid) == 1 && unloadmod_check_use(mid, module, ntpes, tpes )) {
		return unloadmod_exit(level, level ? NULL : client, tpes);	/* NO GO */
	}
@-
decrease the refount of the module. we are ready if it isn't zero (LOGICAL DROP).
@c
	refcnt = TBL_M_decref(client, mid);
@-
drop will go through;
@c
	if (TBL_M_clientrefs(mid, client) == 0) {
		/* LOGICAL DROP */
		if (*module != '_') {
			/* decrease references to MIL procs and remove from client fcntbl */
			if (BATprepareHash(TBL_mod_proc))
				assert(0);
			HASHloop_str(TBL_mod_proc, TBL_mod_proc->hhash, j, module) {
				fid = *(oid *) BUNtloc(TBL_mod_proc, BUNptr(TBL_mod_proc, j));
				BUNfndOID(r, fcntbl, fidp);
				if (r) {
					TBL_decproc(fid);
					if (BUNdelete(fcntbl, r, FALSE) == NULL)
						assert(0);
				}
			}
		} else {
			/* delete all the C-modules's atoms and functions */
			for (i = 0; i < ntpes; i++)
				if (BUNdelHead(BATmirror(client->atomtbl), tpes + i, FALSE) == NULL)
					assert(0);
			if (BATprepareHash(fcn_mid))
				assert(0);
			HASHloop_oid(fcn_mid, fcn_mid->hhash, j, midp, r) {
				fid = *(oid *) BUNtail(fcn_mid, r);
				BUNfndOID(r, fcntbl, fidp);
				if (r && BUNdelete(fcntbl, r, FALSE) == NULL)
					assert(0);
			}
		}
	}
	b = BAT_select(BATmirror(TBL_mod_dep), &mid, &mid, FALSE);
	if (refcnt == 0) {
		/* PHYSICAL DROP */
		if (*module != '_') {
			/* MIL-modules kill the procs they introduced as well as the load-script variables */
			if (BATprepareHash(TBL_mod_proc))
				assert(0);
			HASHloop_str(TBL_mod_proc, TBL_mod_proc->hhash, j, module) {
				oid pid = *(oid *) BUNtloc(TBL_mod_proc, BUNptr(TBL_mod_proc, j));

				if ((r = BUNfnd(TBL_fcn_nme, &pid)) != NULL) {
					int cnt = *(int *) BUNtail(TBL_fcn_cnt, BUNfnd(TBL_fcn_cnt, &pid));

					if (cnt != 1)
						GDKwarning("drop(%s): MIL proc '%s' has %d dangling references.\n", module, BUNtail(TBL_fcn_nme, r), cnt - 1);
					TBL_decproc(pid);
				}
			}
			if (BATprepareHash(TBL_mod_var))
				assert(0);
			HASHloop_str(TBL_mod_var, TBL_mod_var->hhash, j, module) {
				p = BUNptr(TBL_mod_var, j);
				VARdel(client->stk, *(ptr *) BUNtloc(TBL_mod_var, p));
			}
			if (BUNdelHead(TBL_mod_proc, module, FALSE) == NULL)
				assert(0);
			if (BUNdelHead(TBL_mod_var, module, FALSE) == NULL)
				assert(0);
		} else {
			/* C-module: call C epilogue, dlcose, drop dependencies and deinstall it */
			BAT *b2 = BAT_select(TBL_fcn_mid, &mid, &mid, FALSE);

			BUNfndOID(p, TBL_mod_hdl, midp);
			if (p != NULL)
				hdl = *(ptr *) BUNtloc(TBL_mod_hdl, p);

			/* Call the internal deletion routine, and dlclose.  */
			if (hdl != NULL) {
				char mod_del_name[PATHLENGTH];

				sprintf(mod_del_name, "%s_Module_Delete", module);
				addr = (int (*)(void)) DL_sym(hdl, mod_del_name);
				if (addr != NULL)
					(*addr) ();
				if (BUNdelete(TBL_mod_hdl, p, FALSE) == NULL)
					assert(0);
				DL_close(hdl);
			}

			/* delete all function references in the TBL_ bats */
			BATloop(b2, p, q) {
				TBL_Deinstall_Function(*(oid *) BUNhloc(b2, p));
			}
			BBPreclaim(b2);
		}
		if (BUNdelHead(TBL_mod_dep, &mid, FALSE) == NULL)
			assert(0);
	}

	/* drop all dependency modules */
	BATloop(b, p, q) {
		if (TBL_unloadmod(client, BUNhead(b, p), level + 1) == 0)
			GDKwarning("TBL_unloadmod: module %s: dependencies.\n", module);
	}
	BBPreclaim(b);

	/* drop succeeded */
	return unloadmod_exit(1, level ? NULL : client, tpes);
}

@+ Function Resolution
@- TBL_search
The parser uses the routine TBL_search to locate the internal value
of an identifier.
@c
char *
TBL_search(str s, int *t, int guess_if_notfound, int cur_is_ident, int no_command, int next_is_ident)
{
	char *assignop = NULL, *p, *v, *name = s, *ret = 0;
	Client c = ll_client;

	TBL_set_readlock();
	if (name != NULL) {
		p = BUNfnd(c->atomtbl, name);
		if (p != NULL) {
			int tpe = *((int *) BUNtail(c->atomtbl, p));
			str atm = BATatoms[tpe].name;

			strcpy(s, atm);
			*t = TOK_ATOM;
			TBL_unset_readlock();
			return atm;
		}
#ifdef MKMODS
		p = (char *) TEMsearch(t);
		if (p != NULL) {
			*t = TOK_TRG;
			TBL_unset_readlock();
			return s;
		}
#endif
	}

      again:
	if (name != NULL) {
		p = BUNfnd(c->fcntbl, name);
		if (p != NULL) {
			oid fid = *((oid *) BUNtail(c->fcntbl, p));
			*t = *BUNtailfnd(int, TBL_fcn_tpe, v, &fid);

			if (*t == TOK_BUILTIN) {
				ret = (char *) *BUNtailfnd(ptr, TBL_fcn_imp, v, &fid);
			} else if (no_command == 0 && (cur_is_ident == 0 || (next_is_ident == 0 || *t == TOK_OPERATOR0 || *t == TOK_OPERATOR || *t == TOK_OPERATOR1))) {
				/* we refuse only if we know the following cannot be a command
				   or if we see a command followed by an identifier */
				ret = BUNhvar(c->fcntbl, p);
			}
		}
	}
@-
We recognize '+=' (and similar for other operators than +) as an TOK_ASSIGNOP.
@c
	if (assignop) {
		GDKfree(assignop);
		if (*t != TOK_OPERATOR0 && *t != TOK_OPERATOR && *t != TOK_OPERATOR1 && *t != TOK_COMMAND) {
			ret = NULL;
		} else {
			*t = TOK_ASSIGNOP;
		}
	} else if (ret == NULL && name[strlen(name) - 1] == '=') {
		name = assignop = GDKstrdup(*name == ':' ? name + 1 : name);
		name[strlen(name) - 1] = 0;
		goto again;
	}
	TBL_unset_readlock();

@-
if not found, the default is to say it is an identifier.
However, with the command-hint passed, we guess it is a command.
@c
	if (ret == NULL && guess_if_notfound && no_command == 0 && next_is_ident == 0) {
		ret = s;
		*t = next_is_ident ? TOK_OPERATOR : TOK_COMMAND;
	}
	return ret;
}

@- TBL_normal_resolve
The routine TBL_normal_resolve searches the table of function definitions
for one that matches the signature of the call. The first function that
matches is returned.
The type check is a function call derived from the module spec.
@c
int
TBL_normal_resolve(str name, int argc, ValPtr argv, monet_sig_t *sig, Cntxt stk)
{
	hash_t i;
	int ret = TBL_RESOLVE_NOFCN;
	paramcheck_t pt;
	Client c;
	BAT *atomtbl, *fcntbl;

	CNTXTclient(stk, &c);
	fcntbl = c->fcntbl;
	atomtbl = BATmirror(c->atomtbl);
@-
Try to resolve the function to an address.
@c
	TBL_set_readlock();
	if (BATprepareHash(fcntbl))
		assert(0);
	if (TBL_checkparams_init(&pt, argc, argv, atomtbl) < 0) {
		TBL_unset_readlock();
		return TBL_RESOLVE_NOTPE;
	}
	HASHloop_str(fcntbl, fcntbl->hhash, i, name) {
		int j = 0, tpe;
		BUN p = BUNptr(fcntbl, i);
		oid fid = *(oid *) BUNtail(fcntbl, p);
		oid *fidp = &fid;

		BUNfndOID(p, TBL_fcn_tpe, fidp);
		tpe = *(int *) BUNtloc(TBL_fcn_tpe, p);

		if (tpe == TOK_ITERATOR) {
			continue;
		}

		BUNfndOID(p, TBL_fcn_pro, fidp);
		if (p && (j = TBL_checkparams(&pt, fid)) < 0) {
			if (j == TBL_RESOLVE_NOSIG)
				ret = TBL_RESOLVE_NOSIG;
			continue;
		}
		if (BUNfnd(atomtbl, &j) == NULL)
			break;	/* matches, but return type not allowed */
@-
Found IT: substitute name by address.
@c
		BUNfndOID(p, TBL_fcn_imp, fidp);
		sig->pack_fcn = *(PackFcn *) BUNtloc(TBL_fcn_imp, p);
		sig->ret_tpe = j;

		if (tpe == TOK_PROC) {
			sig->fast_fcn = (GDKfcn) sig->pack_fcn;
		} else {
			BUNfndOID(p, TBL_fcn_fcn, fidp);
			if (p == NULL) {
				sig->fast_fcn = NULL;
			} else {
				sig->fast_fcn = *(GDKfcn *) BUNtloc(TBL_fcn_fcn, p);
			}
		}
		TBL_unset_readlock();
		return (tpe == TOK_OPERATOR0 || tpe == TOK_OPERATOR || tpe == TOK_OPERATOR1) ? TOK_COMMAND : tpe;	/* simplify */
	}
	TBL_unset_readlock();

	return ret;
}

@- multiplex Analysis Of The BAT Parameters
Do basic check on parameters. Look at the tail types in order to derive
a function signature. Check that all head types correspond. We also want
to discover if all the input BAT parameters are sorted or in sync. This
may enable the use optimizations. Constants passed into the multiplex
operator are a special case.
@c
#define RETURN(x)	tok=x; goto ready;

int
TBL_multiplex_resolve(str name, int argc, ValPtr argv, monet_sig_t *sig, Cntxt stk)
{
	int optimize = FALSE, optimize_true = TRUE;
	int consts = 0, i = 0, tok = TOK_COMMAND, tpe = TBL_RESOLVE_NOFCN;
	batrec swap[1 + MAXPARAMS];
	BAT *assignbat = NULL;

	if (argc <= 1 || argc >= MAXPARAMS) {
		GDKerror("interpret: 0 param multiplex operator.\n");
		return TBL_RESOLVE_NOFCN;
	}
	sig->array_opt = sig->merge_opt = 0;
	sig->ret_tpe = TBL_RESOLVE_NOFCN;
	for (i = 1; i < argc; i++) {
		swap[i].id = 0;

		swap[i].stamp = 0;
		if (argv[i].vtype == TYPE_bat && argv[i].len != int_nil) {
			BAT *b = BATdescriptor(argv[i].val.bval);
			int z = 0;
			ptr p = ATOMnilptr(b->ttype);

			if (b->ttype == TYPE_void) {
				optimize_true = FALSE;
			}
			argv[i].vtype = ATOMtype(b->ttype);
			swap[i].id = argv[i].val.br.id;

			swap[i].stamp = argv[i].val.br.stamp;

			/* we might need a real value for function resolution! */
			if (b->ttype == TYPE_bat) {
				p = (BATcount(b) <= 0) ? ((ptr) &z) : BUNtloc(b, BUNfirst(b));
			}
			VALset(argv + i, b->ttype == TYPE_void && b->tseqbase != oid_nil ? TYPE_oid : b->ttype, p);

			if (tpe < 0) {
				tpe = b->htype;
				if (i == 1 && sig->assignop) {
					assignbat = b;
				}
			} else if (ATOMtype(tpe) != ATOMtype(b->htype)) {
				argc = i + 1;
				RETURN(TBL_RESOLVE_NOSIG);
			}
			BBPunfix(b->batCacheid);
		} else {
			consts++;
		}
	}
@-
At least one BAT should be there..
@c
	if (tpe < 0) {
		/* GDKerror("[%s%s]: needs at least one BAT param.\n", name, sig->assignop ? "=" : ""); */
		RETURN(TBL_RESOLVE_NOBAT);
	}
	tpe = ATOMstorage(ATOMtype(tpe));
@-
For the [A?B:C] multiplex operators, certain restrictions exist on the type
(BIT) and number of their parameters (2 or 3).
@c
	if (sig->special) {
		if (argv[1].vtype != TYPE_bit) {
			GDKerror("[%s%s]: first param must be a BIT vector.\n", name, sig->assignop ? "=" : "");
			RETURN(TBL_RESOLVE_NOSIG);
		}
		if ((sig->special == 1) ? (argc != 4) : (argc != 3)) {
			GDKerror("[%s%s]: wrong number of params.\n", name, sig->assignop ? "=" : "");
			RETURN(TBL_RESOLVE_NOSIG);
		}
		if ((sig->special == 1) && ATOMtype(argv[3].vtype) != ATOMtype(argv[2].vtype)) {
			RETURN(TBL_RESOLVE_NOSIG);
		}
		sig->ret_tpe = ATOMtype(argv[2].vtype);	/* store return type here */
		if (sig->special == 1) {
			sig->pack_fcn = CMDifthenelse;
			sig->fast_fcn = interpret_ifthenelse;
		} else if (sig->special == 2) {
			sig->pack_fcn = CMDifthen;
			sig->fast_fcn = interpret_ifthen;
		} else if (sig->special == 3) {
			sig->pack_fcn = CMDifelse;
			sig->fast_fcn = interpret_ifelse;
		}
	} else if ((tok = TBL_normal_resolve(name, argc, argv, sig, stk)) < 0) {
		RETURN(tok);
	}
@-
constraints for assigment-multiplexing: first must be identically typed BAT
@c
	if (sig->assignop) {
		if (assignbat == NULL) {
			GDKerror("[%s=]: assignment to non-bat parameter.\n", name);
			RETURN(TBL_RESOLVE_NOFCN);
		} else if (assignbat->ttype != sig->ret_tpe) {
			GDKerror("[%s=]: assignment of bat[%s,%s] to bat[% s,%s]\n", name, ATOMname(assignbat->htype), ATOMname(sig->ret_tpe), ATOMname(assignbat->htype), ATOMname(assignbat->ttype));
			RETURN(TBL_RESOLVE_NOFCN);
		}
	}
@- optimization check
@T
The generic multiplex implementation fills an (argc,argv) array
of @%ValRecord@ structures before each tuple call. That tuple call
then reconstructs the original atomic values from its (argc,argv)
parameters.

We pick collection of interesting cases to optimize, and leave the
(argc,argv) way as a generic implementation for all non-optimizwed cases.
These cases are:
\begin{itemize}
\item unary, binary or 3-ary operators,
\item returning a fixed sized atomic type (BAT is forbidden too).
\item without ANY-type overloading or varargs as actual parameters.
\item that lookup is easy (all head columns unique and either all synced
      or all sorted).
\end{itemize}
The last condition can only be checked at run-time. It actually splits the
optimizations in two classes: namely array-lookup or merge-lookup.
Both have differnt run-time constraints. we compute now whether
our other criteria allow for execution of thexe optimizations,
and store the results in resp. sig->array\_opt and sig->merge\_opt.
@c
	if (sig->special) {
		optimize = optimize_true;
	} else if (tok != TOK_PROC && sig->fast_fcn && argc <= 3 && (BATatoms[sig->ret_tpe].atomFix == NULL) && sig->ret_tpe != TYPE_void && ATOMvarsized(sig->ret_tpe) == 0) {
		str t_argv[1 + MAXPARAMS];
		int t_argc = TBL_getparams((ptr) sig->pack_fcn, t_argv);

		for (i = 1; i < t_argc; i++) {
			if (ATOMindex(t_argv[i]) < 0) {
				break;	/* recognizes simple atoms only! */
			}
		}

		if (i == t_argc) {	/* passed the test? */
			optimize = optimize_true;
		}
	}
	if (optimize) {
		sig->array_opt = !ATOMvarsized(tpe);
		sig->merge_opt = (consts == 0) && (tpe == ATOMstorage(TYPE_oid));
	}
@-
Ready With Resolution
@c
      ready:
	for (i = 1; i < argc; i++) {
		if (swap[i].id) {
			argv[i].vtype = TYPE_bat;
			argv[i].val.br.id = swap[i].id;

			argv[i].val.br.stamp = swap[i].stamp;
		}
	}
	return tok;
}

static int
TBL_setaggr_cleanup(int res, BAT *b, BAT *e)
{
	if (b)
		BBPunfix(b->batCacheid);
	if (e)
		BBPunfix(e->batCacheid);
	return res;
}

int
TBL_setaggr_resolve(str nme, int argc, ValPtr argv, monet_sig_t *sig, Cntxt stk)
{
	ValRecord param[2];
	BAT *extent = NULL, *b = NULL, *tmp = NULL;
	int tok;

	if (argc > 3 || argc < 2) {
		GDKerror("{%s}(Y):  1 or 2 params expected.\n", nme);
		return TBL_setaggr_cleanup(TBL_RESOLVE_NOFCN, b, extent);
	}
	if (argv[1].vtype != TYPE_bat || !(b = BATdescriptor(argv[1].val.bval))) {
		GDKerror("{%s}(Y): must have BAT params\n", nme);
		return TBL_setaggr_cleanup(TBL_RESOLVE_NOSIG, b, extent);
	}
	if (b->ttype == TYPE_void && b->tseqbase == oid_nil) {
		GDKerror("{%s}(Y): void tailtype not allowed.\n", nme);
		return TBL_setaggr_cleanup(TBL_RESOLVE_NOFCN, b, extent);
	}
	if (argc == 3) {
		if (argv[2].vtype != TYPE_bat || !(extent = BATdescriptor(argv[2].val.bval))) {
			GDKerror("{%s}(Y): must have BAT params\n", nme);
			return TBL_setaggr_cleanup(TBL_RESOLVE_NOSIG, b, extent);
		}
		if (TYPEerror(b->htype, extent->htype)) {
			GDKerror("{%s}(Y): incompatible extent.\n", nme);
			return TBL_setaggr_cleanup(TBL_RESOLVE_NOSIG, b, extent);
		}
		if (extent->hkey == FALSE) {
			BATpropcheck(extent, BATPROPS_ALL);	/* try to derive hkey */
		}
		if (extent->hkey == FALSE) {
			GDKerror("{%s}(Y): extent must contain unique values.\n", nme);
			return TBL_setaggr_cleanup(TBL_RESOLVE_NOFCN, b, extent);
		}
	}
	tmp = BATnew(BATttype(b), BATttype(b), 1);
	if (tmp == NULL)
		return TBL_setaggr_cleanup(-4, b, extent);
	param[1].vtype = TYPE_bat;
	param[1].val.bval = tmp->batCacheid;

	tok = TBL_normal_resolve(nme, 2, param, sig, stk);
	BBPreclaim(tmp);
	if (tok < 0)
		return TBL_setaggr_cleanup(tok, b, extent);

	if (sig->ret_tpe == 0) {
		GDKerror("{%s}(Y): 'any' return types not allowed.\n", nme);
		return TBL_setaggr_cleanup(TBL_RESOLVE_NOFCN, b, extent);
	}
	return TBL_setaggr_cleanup(tok, b, extent);
}

@- TBL_printsigs
prints all signatures of known commands/procs with a certain name.
@c
static ptrdiff_t
formatsig(str s, str nme, oid fid)
{
	str src = s;
	BUN p;
	oid *fidp = &fid;

	BUNfndOID(p, TBL_fcn_sig, fidp);
	if (p) {
		/* precooked */
		strcpy(s, BUNtvar(TBL_fcn_sig, p));
	} else {
		BUNfndOID(p, TBL_fcn_pro, fidp);
		strcpy(s, nme);
		s += strlen(s);
		*s++ = '(';
		if (p == NULL) {
			/* no signature restrictions */
			strcpy(s, "..any..) : any");
			s += strlen(s);
		} else {
			/* construct signature on the fly */
			str argv[1 + MAXPARAMS];
			int k, argc = getparams(fid, argv);

			for (k = 1; k < argc; k++) {
				str param = argv[k];

				if (k > 1) {
					*s++ = ',';
					*s++ = ' ';
				}
				if (*argv[k] == '*') {
					*s++ = '.';
					*s++ = '.';
					param++;
				}
				strcpy(s, param);
				s += strlen(s);
				if (*argv[k] == '*') {
					*s++ = '.';
					*s++ = '.';
				}
			}
			*s++ = ')';
			*s++ = ' ';
			*s++ = ':';
			*s++ = ' ';
			strcpy(s, argv[0]);
			s += strlen(s);
		}
	}
	return s - src;
}

void
TBL_printsigs(str s, int stk, str nme)
{
	hash_t i;
	int j = 0;
	BAT *b;
	Client c;

	CNTXTclient(stk, &c);
	b = c->fcntbl;
	TBL_set_readlock();
	if (BATprepareHash(b) == 0)
		HASHloop_str(b, b->hhash, i, nme) {
		BUN p = BUNptr(b, i);
		oid fid = *(oid *) BUNtloc(b, p);

		if (j++ == 0) {
			sprintf(s, "!MAYBE YOU MEAN:\n");
			s += strlen(s);
		}
		*s++ = '!';
		*s++ = '\t';
		s += formatsig(s, nme, fid);
		*s++ = '\n';
		}
	*s++ = 0;
	TBL_unset_readlock();
}

@- TBL_formatsig
@c
int
TBL_formatsig(str s, oid fid)
{
	BUN p;
	oid *fidp = &fid;

	TBL_set_readlock();
	BUNfndOID(p, TBL_fcn_nme, fidp);
	if (p == NULL) {
		TBL_unset_readlock();
		return FALSE;
	}
	(void) formatsig(s, BUNtvar(TBL_fcn_nme, p), fid);
	TBL_unset_readlock();
	return TRUE;
}


@- TBL_iterator
Like TBL_search, but intened to do lookup for iterators.
@c
void *
TBL_iterator(Cntxt stk, str name, int argc, ValPtr argv)
{
	paramcheck_t pt;
	Client c;
	hash_t i;

	CNTXTclient(stk, &c);

	TBL_set_readlock();
	if (BATprepareHash(c->fcntbl) == 0)
		if (TBL_checkparams_init(&pt, argc, argv, BATmirror(c->atomtbl)) >= 0)
			HASHloop_str(c->fcntbl, c->fcntbl->hhash, i, name) {
			char *v = BUNptr(c->fcntbl, i);
			oid fid = *(oid *) BUNtail(c->fcntbl, v);
			int tpe = *BUNtailfnd(int, TBL_fcn_tpe, v, &fid);

			if (tpe != TOK_ITERATOR)
				continue;

			if (TBL_checkparams(&pt, fid) >= 0) {
				TBL_unset_readlock();
				return *BUNtailfnd(void *, TBL_fcn_imp, v, &fid);
			}
			}
	TBL_unset_readlock();
	return (void *) 0;
}

@- TBL_procreturn
@T
We now allow the user to specify a procedure return value.
This does not add much functionality, but allows for an
extra check on a procedure return value (TBL\_procreturn).

The procedure body is a MIL block that has as yyval a string with
the PROC name, and in the len /*HACK*/ field we find an int that is
a concatenation of two short integers 'type1' and 'type2':
- type1=type2=0 means 'any' (no check necessary)
- type2=0 means an atomic type (its number in type1)
- else we have a bat[type1,type2]
@
The type1,type2 are shorts consisting of a number, and a mask:
- 8192 => MIL type number
- 4096 => equal to type of 'num'th actual parameter
- 2048 => equal to head-type of BAT that is 'num'th actual parameter
- 1024 => equal to tail-type of BAT that is 'num'th actual parameter
@c
static
int check_type (int argc, ValPtr argv, int tpe, int mask) {
	int kind = mask & 15360;
	int num = mask & 1023;

	if (kind == 8192) {	/* direct type */
		return TYPEcastable(tpe, num);
	}
	if (argc <= num) {
		return 0;
	}
	if (kind == 4096) {	/* any-normal */
		if (num == 0)
			return 1;
		return TYPEcastable(argv[num].vtype, tpe);
	}
	if (argv[num].vtype != TYPE_bat) {
		return 0;
	}
	if (kind == 2048) {
		BAT *b = BBPdescriptor(argv[num].val.bval);

		return b && TYPEcastable(tpe, BAThtype(b));	/* any-head */
	}
	if (kind == 1024) {
		BAT *b = BBPdescriptor(argv[num].val.bval);

		return b && TYPEcastable(tpe, BATttype(b));	/* any-tail */
	}
	return 0;		/* illegal kind */
}

int
TBL_procreturn(int argc, ValPtr argv, ValPtr res, YYSTREE t)
{
	if (PROC_TYPE1(t) == 0 && PROC_TYPE2(t) == 0) {
		return 1;
	} else if (res->vtype == TYPE_bat) {
		BAT *b = BBPdescriptor(res->val.bval);
		return b && check_type (argc, argv, BAThtype(b), PROC_TYPE1(t))
		&& check_type (argc, argv, BATttype(b), PROC_TYPE2(t));
	} else if (PROC_TYPE2(t)) {
		return 0;
	}
	return check_type (argc, argv, res->vtype, PROC_TYPE1(t));
}


@+ Client Managament
@-
Each user gets a private function and atom table. They are
initialized with the built-in functions and atomary types. They are extended
later on when the user loads a module.

Both tables are session and user specific.
@c

#define TBL_SIZE	750

void
TBL_initclient(Client client, Client father)
{
	BUN p, q;
	int i, xx;

	client->fcntbl = client->atomtbl = NULL;
	TBL_M_lock(client);
	if (monet_clients != client) {
		client->fcntbl = TBL_fathercopy(client, father, "fcntbl");
		client->atomtbl = TBL_fathercopy(client, father, "atomtbl");

		/* for all procs in the client fcntbl, increment their refcnt */
		BATloopFast(client->fcntbl, p, q, xx) {
			oid pid = *(oid *) BUNtloc(client->fcntbl, p);

			if (*(int *) BUNtail(TBL_fcn_tpe, BUNfnd(TBL_fcn_tpe, &pid)) == TOK_PROC) {
				TBL_incproc(pid);
			}
		}
		if (father)
			TBL_inc_mod_use(client, father);	/* inc mod use counters */
	} else {
		client->fcntbl = TBL_create(client, "fcntbl", TBL_SIZE, TYPE_str, TYPE_oid, 0, BOUND2BTRUE);

		/* Create the client atom-table, and fill it
		 * with the standard types.
		 */
		client->atomtbl = TBL_create(client, "atomtbl", TBL_SIZE, TYPE_str, TYPE_int, BOUND2BTRUE, 0);
		i = TYPE_void;
		if (BUNins(client->atomtbl, "void", &i, FALSE) == NULL)
			assert(0);
		i = TYPE_bit;
		if (BUNins(client->atomtbl, "bit", &i, FALSE) == NULL)
			assert(0);
		i = TYPE_chr;
		if (BUNins(client->atomtbl, "chr", &i, FALSE) == NULL)
			assert(0);
		i = TYPE_bte;
		if (BUNins(client->atomtbl, "bte", &i, FALSE) == NULL)
			assert(0);
		i = TYPE_sht;
		if (BUNins(client->atomtbl, "sht", &i, FALSE) == NULL)
			assert(0);
		i = TYPE_bat;
		if (BUNins(client->atomtbl, "bat", &i, FALSE) == NULL)
			assert(0);
		if (BUNins(client->atomtbl, "BAT", &i, FALSE) == NULL)
			assert(0);
		i = TYPE_int;
		if (BUNins(client->atomtbl, "int", &i, FALSE) == NULL)
			assert(0);
		i = TYPE_oid;
		if (BUNins(client->atomtbl, "oid", &i, FALSE) == NULL)
			assert(0);
		i = TYPE_wrd;
		if (BUNins(client->atomtbl, "wrd", &i, FALSE) == NULL)
			assert(0);
		i = TYPE_ptr;
		if (BUNins(client->atomtbl, "ptr", &i, FALSE) == NULL)
			assert(0);
		i = TYPE_flt;
		if (BUNins(client->atomtbl, "flt", &i, FALSE) == NULL)
			assert(0);
		i = TYPE_dbl;
		if (BUNins(client->atomtbl, "dbl", &i, FALSE) == NULL)
			assert(0);
		i = TYPE_lng;
		if (BUNins(client->atomtbl, "lng", &i, FALSE) == NULL)
			assert(0);
		i = TYPE_str;
		if (BUNins(client->atomtbl, "str", &i, FALSE) == NULL)
			assert(0);
	}
	TBL_M_unlock(client);

#ifdef MKMODS
	TEM_initclient(client);
#endif
}

@-
We would like to deallocate all MIL proc trees.  Procs depend on functions in modules.
So the procs must be deleted before the (hard) module unload. However, those procs defined
by the module (load script) - as opposed to user procs - might well be used in the
module drop script. So, if we would delete the procs before the drop, the drop script
will give syntax errors.

Thus, we first execute the drop scripts of the modules to be unloaded. Then, we
delete all procs, and finally we drop the modules (with level=1). Due to the level==1,
it will not execute the drop scripts again.
@c
void
TBL_exitclient(Client client)
{
	BAT *b, *bn;
	BUN p, q, r;
	int xx, cid = (int) (client - monet_clients);

#ifdef MKMODS
	TEM_exitclient(client);
#endif
	TBL_M_lock(client);

	/* Unload all loaded modules in reverse loading order. */
	bn = BATselect(TBL_mod_use, &cid, &cid);
	assert(bn);
	b = BATsort(bn);
	assert(b);
	b = BATsetaccess(b, BAT_WRITE);
	assert(b);
	b = BATrevert(b);
	assert(b);
	BATloopFast(b, p, q, xx) {
		oid mid = *(oid *) BUNhloc(b, p);

		if (BUNlocate(TBL_mod_use, BUNhloc(b, p), &cid)) {
			str module = BUNtailfnd(char, TBL_mod_nme, r, &mid);

			if (TBL_M_directloaded(client, mid, module))
				TBL_unloadmod(client, module, 1);
		}
	}
	BBPreclaim(b);
	BBPreclaim(bn);

	/* Unload any remaining procs in your fcn table.  */
	BATloopFast(client->fcntbl, p, q, xx) {
		oid pid = *(oid *) BUNtloc(client->fcntbl, p);

		if (*(int *) BUNtail(TBL_fcn_tpe, BUNfnd(TBL_fcn_tpe, &pid)) == TOK_PROC) {
			TBL_decproc(*(oid *) BUNtloc(client->fcntbl, p));
		}
	}

	/* Clean up all client parser BATs */
	BBPunfix(client->fcntbl->batCacheid);
	BBPunfix(client->atomtbl->batCacheid);
	client->fcntbl = client->atomtbl = NULL;
	TBL_M_unlock(NULL);
}

@- TBL_Install_Depend
is called from the generated code in the routine <modulename>_Module_Install.
It is called one time for each module that it is dependent on.
@c

static void
TBL_Insert_Depend(oid mid, str name)
{
	if (BUNlocate(TBL_mod_dep, &mid, name) == NULL) {
		if (BUNins(TBL_mod_dep, &mid, name, FALSE) == NULL)
			assert(0);
	}
}

void
TBL_Install_Depend(TBLinstall *inst, oid mid, str user, str name)
{
	(void) user;
	/* use parent module NULL else circular dependencies are added */
	if (!TBL_loadmod(inst->client, name, NULL, inst->level + 1, inst->initstr)) {
		GDKwarning("TBL_Install_Depend: requires module %s, not loaded!\n", name);
	} else {
		TBL_Insert_Depend(mid, name);
	}
}


@- TBL_Install_Atom
@c
void
TBL_Install_Atom(oid mid, str name, int size,	/* 0 == not fixed size */
		 int align)
{				/* 0 == not fixed size */
	str extended = GDKmalloc(strlen(name) + 16);

	dlFPRINTF(GDKerr, "  TBL_Install_Atom(%s)\n", name);
	if ((size == 0) && (align == 0)) {	/* fixed */
		sprintf(extended, "%s=*", name);
		if (BUNins(TBL_mod_atm, &mid, extended, FALSE) == NULL)
			assert(0);
	} else {
		sprintf(extended, "%s=%d,%d", name, size, ABS(align));
		if (BUNins(TBL_mod_atm, &mid, extended, FALSE) == NULL)
			assert(0);
	}
	GDKfree(extended);
}

@- TBL_Install_Functions
@c
void
TBL_Install_Functions(oid mid, TBLfcn *fcns, str user, str date)
{
	TBLfcn *cur = fcns;

	while (cur->name) {
		oid fid = TBL_Install_Function(mid, cur->name, cur->token,
					       cur->fcn, cur->unpack, cur->check, cur->oldsig,
					       cur->help, user, date);
		str *arg = cur->args;

		while (*arg) {
			TBL_Install_Function_Arg(fid, *arg);
			arg++;
		}
		if (cur->res)
			TBL_Install_Function_Res(fid, cur->res);
		cur++;
	}
}

@- TBL_Install_Function
@c
/* I think the types from parsing are only availiable as strings
   so we better input them as such */

/* An oid is generated */
oid
TBL_Install_Function(oid mid, str name, int tpe,	/* some sort of type? fcn_table[i].token */
		     ptr orig, ptr pack_imp, ptr type_imp,	/* functionpointers! */
		     str signature, str help, str author, str date)
{
	int zero = 0;
	oid fid = TBL_oid++;

	(void) type_imp;

	dlFPRINTF(GDKerr, "  TBL_Install_Function(" SZFMT ",%s) = " SZFMT "\n", (size_t) mid, name, (size_t) fid);

	if (name[0] == 'b' && name[1] == 'a' && name[2] == 't' && name[3] == 0) {
		name = "BAT";	/* sorry */
	}
	if (BUNins(TBL_fcn_nme, &fid, name, FALSE) == NULL)
		assert(0);	/* or &name */
	if (BUNins(TBL_fcn_fcn, &fid, &orig, FALSE) == NULL)
		assert(0);	/* correct??? */
	if (BUNins(TBL_fcn_tpe, &fid, &tpe, FALSE) == NULL)
		assert(0);
	if (BUNins(TBL_fcn_mid, &fid, &mid, FALSE) == NULL)
		assert(0);
	if (BUNins(TBL_fcn_dsc, &fid, help, FALSE) == NULL)
		assert(0);
	if (BUNins(TBL_fcn_aut, &fid, author, FALSE) == NULL)
		assert(0);
	if (BUNins(TBL_fcn_dat, &fid, date, FALSE) == NULL)
		assert(0);

	if (BUNins(TBL_fcn_cnt, &fid, &zero, FALSE) == NULL)
		assert(0);
@-
We want to save pointer to the real function
for example use in a different interpreter
if (orig) BUNins(TBL_fcn_org, &fid, &orig, FALSE);
Its done in TBL_unpacked()
@c
	if (pack_imp && BUNins(TBL_fcn_imp, &fid, &pack_imp, FALSE) == NULL)
		assert(0);
	if (signature && BUNins(TBL_fcn_sig, &fid, signature, FALSE) == NULL)
		assert(0);
	TBL_fcn_pro_size++;

	return fid;
}

void
TBL_Deinstall_Function(oid pid)
{
	if (BUNdelHead(TBL_fcn_nme, &pid, FALSE) == NULL)
		assert(0);
	if (BUNdelHead(TBL_fcn_fcn, &pid, FALSE) == NULL)
		assert(0);
	if (BUNdelHead(TBL_fcn_mid, &pid, FALSE) == NULL)
		assert(0);
	if (BUNdelHead(TBL_fcn_imp, &pid, FALSE) == NULL)
		assert(0);
	if (BUNdelHead(TBL_fcn_tpe, &pid, FALSE) == NULL)
		assert(0);
	if (BUNdelHead(TBL_fcn_sig, &pid, FALSE) == NULL)
		assert(0);
	if (BUNdelHead(TBL_fcn_dsc, &pid, FALSE) == NULL)
		assert(0);
	if (BUNdelHead(TBL_fcn_aut, &pid, FALSE) == NULL)
		assert(0);
	if (BUNdelHead(TBL_fcn_dat, &pid, FALSE) == NULL)
		assert(0);
	if (BUNdelHead(TBL_fcn_cnt, &pid, FALSE) == NULL)
		assert(0);

	/* periodically clean up TBL_fcn_pro */
	if (BATcount(TBL_fcn_nme) + 100 < TBL_fcn_pro_size) {
		BAT *b = BATcopy(TBL_fcn_pro, TYPE_oid, TYPE_str, FALSE);
		BUN p, q, r;
		int xx;

		if (BATclear(TBL_fcn_pro) == NULL) {
			assert(0);
		}
		BATloopFast(b, p, q, xx) {
			oid *pidp = (oid *) BUNhead(b, p);

			BUNfndOID(r, TBL_fcn_nme, pidp);
			if (r && BUNfastins(TBL_fcn_pro, pidp, BUNtvar(b, p)) == NULL)
				assert(0);
		}
		TBL_fcn_pro->hsorted = TBL_fcn_pro->tsorted = 0;
		BBPreclaim(b);
		TBL_fcn_pro_size = BATcount(TBL_fcn_nme);
	}
}

/* Called after _Function */
void
TBL_Install_Function_Vararg(oid fid, str tpe)
{
	dlFPRINTF(GDKerr, "    TBL_Install_Function_Vararg(" SZFMT ",%s)\n", (size_t) fid, tpe);
	if (BUNins(TBL_fcn_pro, &fid, tpe, FALSE) == NULL)
		assert(0);
}


/* Called after _Function / _Vararg
   This one would have to be called several times, once for each argument */
void
TBL_Install_Function_Arg(oid fid, str tpe)
{
	dlFPRINTF(GDKerr, "    TBL_Install_Function_Arg(" SZFMT ",%s)\n", (size_t) fid, tpe);
	if (BUNins(TBL_fcn_pro, &fid, tpe, FALSE) == NULL)
		assert(0);
}

/* After _Arg */
void
TBL_Install_Function_Res(oid fid, str tpe)
{
	dlFPRINTF(GDKerr, "    TBL_Install_Function_Res(" SZFMT ",%s)\n", (size_t) fid, tpe);
	if (BUNins(TBL_fcn_pro, &fid, tpe, FALSE) == NULL)
		assert(0);
}

/* Use the output of the prelude function to register BAT hotfixes required by the module */
void
TBL_Install_DropRefs(oid mid, bat *batrefs)
{
	if (batrefs == NULL)
		return;
	while (*batrefs) {
		dlFPRINTF(GDKerr, "  TBL_Install_DropRefs(" SZFMT ",%s)\n", (size_t) mid, BBPname(*batrefs));
		if (BUNins(TBL_mod_drop, &mid, batrefs, FALSE) == NULL)
			assert(0);
		batrefs++;
	}
}

void
TBL_Install_MilVar(Client client, str mod, ptr v)
{
	TBL_M_lock(client);
	if (BUNins(TBL_mod_var, mod, &v, FALSE) == NULL)
		assert(0);
	TBL_M_unlock(client);
}
