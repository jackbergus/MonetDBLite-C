@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2007 CWI.
@' All Rights Reserved.

@f gdk_setop
@a Peter Boncz

@* Set Operations
Set operations are provided in two series:
@itemize
@item
k-@emph{operand}, which look only at the head column.
@item
s-@emph{operand} series, that look at the whole BUN.
@end itemize

Operands provided are:
@itemize
@item [s,k]unique
produces a copy of the bat, with double elimination
@item [s,k]union
produces a bat union.
@item [s,k]diff
produces bat difference.
@item [s,k]intersection
produce bat intersection.
@end itemize
Implementations typically take two forms: if the input relation(s) is/are
ordered, a merge-algorithm is used. Otherwise, hash-indices are produced
on demand for the hash-based versions.

The @emph{[k,s]intersect(l,r)} operations result in all BUNs of @emph{l} that
are also in @emph{r}. They do not do double-elimination over the @emph{l} BUNs.

The @emph{[k,s]diff(l,r)} operations result in all BUNs of @emph{l} that are
not in @emph{r}. They do not do double-elimination over the @emph{l} BUNs.

The @emph{[k,s]union(l,r)} operations result in all BUNs of @emph{l}, plus 
all BUNs of @emph{r} that are not in @emph{l}. They do not do double-elimination
over the @emph{l} nor @emph{r} BUNs.

Operations with double-elimination can be formed by performing @emph{[k,s]unique(l)} on their operands.

The @emph{kintersect(l,r)} is used also as implementation for the @emph{semijoin()}.
@{
@h
#ifndef _GDK_SETOP_H
#define _GDK_SETOP_H
#include "gdk.h"

#define HITk(t1,t2)             TRUE
#define HITs(t1,t2)             ((*cmp)(t1,t2) == 0)
#define TAILCHECKs(l,r)         TYPEerror(BATttype(l),	BATttype(r))
#define TAILCHECKk(l,r)         FALSE
#define EQUALs(t1,t2)           ((*cmp)(t1,t2) == 0 && (*cmp)(t1,tnil))
#define EQUALk(t1,t2)           TRUE
#define FLIPs(l,r)              TRUE
#define FLIPk(l,r)              FALSE

#define HITintersect(h,t)       bunfastins(bn,h,t)
#define HITdiff(h,t)
#define MISSintersect(h,t)
#define MISSdiff(h,t)           bunfastins(bn,h,t)
#define ENDintersect(h,t)
#define ENDdiff(h,t)            for(;p1<q1;p1+=s1) bunfastins(bn,h,t)
#define RALIGNdiff(bn,l,r)      FALSE
#define RALIGNintersect(bn,l,r) ((BAThordered(l)&BAThordered(r)&1) && l->hkey\
				 && BATcount(bn)==BATcount(r))
#endif /* _GDK_SETOP_H */

@c
#include "monetdb_config.h"
#include "gdk.h"
#include "gdk_setop.h"

@+ Double Elimination
Comes in two flavors: looking at one column, or at two at-a-time.
Implementation is either merge- or hash-based.
@= mergeelim
	BATloopFast(b, p, q, xx) {
		ptr h = BUNh@2(b,p);
		ptr t = BUNt@3(b,p);
		for (r = p + xx; (r < q) && (@4 == 0); r += xx) {
			if (HIT@1(t, BUNt@3(b,r)))
				goto next@2@3@5;
		}
		bunfastins(bn, h, t);
  next@2@3@5:;
	}
@= hashelim
	zz = BUNindex(bn, BUNfirst(bn));
	if (!bn->hhash){
		if (BAThash(bn, BATcapacity(bn)/2) == NULL) {
			BBPreclaim(bn);
			return NULL;
		}
	}
	BATloopFast(b, p, q, xx) {
		ptr h = BUNh@2(b,p);
		ptr t = BUNt@3(b,p);
		int ins = 1;
		hash_t yy;

		if (BATprepareHash(bn)) {
			BBPreclaim(bn);
			return NULL;
		}
		HASHloop@4(bn, bn->hhash, yy, h, r) {
			if (HIT@1(t, BUNt@3(bn,r))) {
				ins=0;
				break;
			}
		}
		if (ins) {
			bunfastins(bn, h, t);
			if (bn->hhash)
				HASHins@4(bn->hhash, (hash_t) zz, h);
			zz++;
		}
	}
@= elim
	{
		int xx, (*cmp)(ptr, ptr) = BATatoms[b->ttype].atomCmp;
		size_t zz;
		BUN p, q, r;

		if (BAThordered(b)&1) {
			if (b->tvarsized) {
				@:mergeelim(@1,@2,var,@4,@3)@
			} else {
				@:mergeelim(@1,@2,loc,@4,@3)@
			}
		} else if (b->tvarsized) {
			@:hashelim(@1,@2,var,@3)@
		} else {
			@:hashelim(@1,@2,loc,@3)@
		}
		(void) cmp;
		break;
	}
@= elim_doubles
	switch(ATOMstorage(b->htype)) {
#ifndef NOEXPAND_CHR
	case TYPE_chr:
		@:elim(@1,loc,_chr,simple_CMP(h,BUNhloc(b,r),chr))@
#endif
#ifndef NOEXPAND_BTE
	case TYPE_bte:
		@:elim(@1,loc,_bte,simple_CMP(h,BUNhloc(b,r),bte))@
#endif
#ifndef NOEXPAND_SHT
	case TYPE_sht:
		@:elim(@1,loc,_sht,simple_CMP(h,BUNhloc(b,r),sht))@
#endif
#ifndef NOEXPAND_INT
	case TYPE_int:
		@:elim(@1,loc,_int,simple_CMP(h,BUNhloc(b,r),int))@
#endif
#ifndef NOEXPAND_FLT
	case TYPE_flt:
		@:elim(@1,loc,_flt,simple_CMP(h,BUNhloc(b,r),flt))@
#endif
#ifndef NOEXPAND_DBL
	case TYPE_dbl:
		@:elim(@1,loc,_dbl,simple_CMP(h,BUNhloc(b,r),dbl))@
#endif
#ifndef NOEXPAND_LNG
	case TYPE_lng:
		@:elim(@1,loc,_lng,simple_CMP(h,BUNhloc(b,r),lng))@
#endif
	default:
		{
			int (*merge)(ptr, ptr)= BATatoms[b->htype].atomCmp;

			if (b->hvarsized) {
				@:elim(@1,var,var,((*merge)(h,BUNhvar(b,r))))@
			} else {
				@:elim(@1,loc,loc,((*merge)(h,BUNhloc(b,r))))@
			}
		}
	}
@c
BAT *
BATins_kunique(BAT *bn, BAT *b)
{
	bit unique = FALSE;
	BATcheck(b, "BATins_kunique: src BAT");
	BATcheck(bn, "BATins_kunique: dst BAT");
	unique = (BATcount(bn)==0);
	@:elim_doubles(k)@
	if (unique && bn->hkey == FALSE) {
		/* we inserted unique head-values into an empty BAT;
		   hence, the resulting BAT's head is (now) unique/key ... */
		BATkey(bn,TRUE);
	}
	return bn;
      bunins_failed:
	BBPreclaim(bn);
	return NULL;
}

static BAT *
BATins_sunique(BAT *bn, BAT *b)
{
	bit unique = FALSE;
	BUN fst1, fst2, last1, last2;

	BATcheck(b, "BATins_sunique: src BAT");
	BATcheck(bn, "BATins_sunique: dst BAT");

	unique = (BATcount(bn)==0);

	fst1 = BUNfirst(bn);
	fst2 = BUNfirst(b);

	last1 = (BUNlast(bn) - BUNsize(bn));
	last2 = (BUNlast(b) - BUNsize(b));

	if (BATcount(b) && (BAThordered(b) & 1) && ATOMcmp(b->htype, BUNhead(b, fst2), BUNhead(b, last2)) == 0 &&
	    (BATcount(bn) == 0 || (ATOMcmp(bn->htype, BUNhead(bn, fst1), BUNhead(b, fst2)) == 0 && (BAThordered(bn) & 1) && ATOMcmp(bn->htype, BUNhead(bn, fst1), BUNhead(bn, last1)) == 0))) {
		return BATins_kunique(BATmirror(bn), BATmirror(b));
	}
	if (BATcount(b) && (BATtordered(b) & 1) && ATOMcmp(b->ttype, BUNtail(b, fst2), BUNtail(b, last2)) == 0 &&
	    (BATcount(bn) == 0 || (ATOMcmp(bn->ttype, BUNtail(bn, fst1), BUNtail(b, fst2)) == 0 && (BATtordered(bn) & 1) && ATOMcmp(bn->ttype, BUNtail(bn, fst1), BUNtail(bn, last1)) == 0))) {
		return BATins_kunique(bn, b);
	}
	if ((BATtordered(b) & 1) && ATOMstorage(b->ttype) < TYPE_str) {
		bn= BATmirror(bn);
		b= BATmirror(b);
	}
	@:elim_doubles(s)@
	if (unique && bn->batSet == FALSE) {
		/* we inserted unique BUNs into an empty BAT;
		   hence, the resulting BAT is (now) unique/set ... */
		BATset(bn,TRUE);
	}
	return bn;
      bunins_failed:
	BBPreclaim(bn);
	return NULL;
}


@- Unique
The routine @`BATsunique@5 removes duplicate BUNs,
The routine @`BATkunique@5 removes duplicate head entries.
@c
BAT *
BATkunique(BAT *b)
{
	BAT *bn;

	BATcheck(b, "BATkunique:");

	if (b->hkey) {
		bn = BATcopy(b, b->htype, b->ttype, FALSE);
	} else {
		size_t cnt = BATcount(b);

		if (cnt > 10000) {
			BAT *tmp2 = NULL, *tmp1, *tmp0 = VIEWhead_(b, BAT_WRITE);

			if (tmp0) {
				tmp1 = BATsample(b, 1000);
				if (tmp1) {
					tmp2 = BATkunique(tmp1);
					if (tmp2) {
						cnt = (size_t) ((((lng) BATcount(tmp2)) * cnt) / 900);
						BBPreclaim(tmp2);
					}
					BBPreclaim(tmp1);
				}
				BBPreclaim(tmp0);
			}
			if (tmp2 == NULL)
				return NULL;
		}
		bn = BATnew(BAThtype(b), BATttype(b), cnt);
		if (bn == NULL || BATins_kunique(bn, b) == NULL)
			return NULL;
	}

	/* property management */
	if (b->halign == 0) {
		b->halign = OIDnew(1);
	}
	BATkey(bn, TRUE);	/* this we accomplished */
	BATkey(BATmirror(bn), b->tkey);
	bn->hsorted = BAThordered(b);
	bn->tsorted = BATtordered(b);
	if (BATcount(bn) == BATcount(b)) {
		ALIGNset(bn, b);
	}
	return bn;
}

BAT *
BATukunique(BAT *b)
{
	BAT *v, *bn;

	BATcheck(b, "BATukunique:");
	bn = BATkunique(v = VIEWhead(b));
	BBPreclaim(v);
	return bn;
}

BAT *
BATsunique(BAT *b)
{
	BAT *bn;

	BATcheck(b, "BATsnique:");

	if (b->hkey || b->tkey || b->batSet) {
		bn = BATcopy(b, b->htype, b->ttype, FALSE);
	} else {
		size_t cnt = BATcount(b);

		if (cnt > 10000) {
			BAT *tmp2 = NULL, *tmp1 = BATsample(b, 1000);

			if (tmp1) {
				tmp2 = BATkunique(tmp1);
				if (tmp2) {
					cnt = BATcount(tmp2) * (cnt / 1000);
					BBPreclaim(tmp2);
				}
				BBPreclaim(tmp1);
			}
			if (tmp2 == NULL)
				return NULL;
		}
		bn = BATnew(BAThtype(b), BATttype(b), cnt);
		if (bn == NULL || BATins_sunique(bn, b) == NULL)
			return NULL;
	}

	/* property management */
	BATset(bn, TRUE);	/* this we accomplished */
	BATkey(bn, b->hkey);
	BATkey(BATmirror(bn), b->tkey);
	bn->hsorted = BAThordered(b);
	bn->tsorted = BATtordered(b);
	if (BATcount(bn) == BATcount(b)) {
		ALIGNset(bn, b);
	}
	return bn;
}

@}
@+ Difference and Intersect
Difference and Intersection are handled together. For each routine
there are two versions: @`BATkdiff@5(l,r) and @`BATkintersect@5(l,r) (which
look at the head column only), versus @`BATsdiff@5(l,r) and
@`BATsintersect@5(l,r) (looking at both columns).
TODO synced/key case..
@{

@= mergecheck
	BUN p1 = BUNfirst(l), p2 = BUNfirst(r);
	BUN q1 = BUNlast(l),  q2 = BUNlast(r);
	int s1 = BUNsize(l),  s2 = BUNsize(r);

	ALGODEBUG THRprintf(GDKout, "#BATins_@1@2: mergecheck[@1, @2, @3, @4, @5];\n");
	if (p2 < q2) BATloopFast(l, p1, q1, s1) {
		ptr  h = BUNh@2(l,p1);
		ptr  t = BUNtail(l,p1);
		ptr h2 = BUNh@2(r,p2);
		int c;
		while ((c = @4) > 0) {
			if ((p2 += s2) >= q2)
				goto end@2@3;
			h2 = BUNh@2(r,p2);
		}
		if (c == 0) {
			h2 = hnil;
			if (@4) { /* check for not-nil (nils don't match anyway) */
				BUN pb = p2;
				for (;;) {
					if (EQUAL@5(t, BUNtail(r,pb))) {
						HIT@1(h, t);
						break;
					}
					if ((pb += s2) >= q2) {
						MISS@1(h, t);
						break;
					}
					h2 = BUNh@2(r,pb);
					if (@4) {
						MISS@1(h, t);
						break;
					}
				}
				continue;
			}
		}
		MISS@1(h, t);
	}
  end@2@3:;
	END@1(BUNh@2(l,p1), BUNtail(l,p1));
@= hashcheck
	BUN p1, q1, w;
	int ins, s1;
	hash_t s2;
	ptr h, t, t2 = NULL, h2 = hnil;

	ALGODEBUG THRprintf(GDKout, "#BATins_@1@2: hashcheck[@1, @2, @3, @4, @5];\n");
	pin = 1;
	BATmmap_pin(r);
	if (BATprepareHash(r))
		goto bunins_failed;
	BATloopFast(l, p1, q1, s1) {
		h = BUNh@2(l, p1);
		t = BUNtail(l,p1);
		ins = TRUE;
		if (@6) /* check for not-nil (nils don't match anyway) */
			HASHloop@4(r, r->hhash, s2, h, w) {
				t2 = BUNtail(r,w);
				if (EQUAL@5(t,t2)) {
					HIT@1(h, t);
					ins = FALSE;
					break;
				}
			}
		if (!ins)
			continue;
		MISS@1(h,t);
	}
	if (t2 || h2)
		ins = 0;	       /* dummy action for the compiler */
	BATmmap_unpin(r);

@= voidcheck
	{
		BUN p1 = BUNfirst(r), q1 = BUNlast(r);
		oid rl = *(oid*) BUNhead(r,p1);
		oid rh = rl + BATcount(r);
		ptr h, t = NULL, t2 = NULL;

		(void) t2;

		ALGODEBUG THRprintf(GDKout, "#BATins_@1@2: voidcheck[@1, @2];\n");
		if (BAThdense(l)) {
			oid ll = *(oid*) BUNhead(l,(p1=BUNfirst(l)));
			oid lh = ll + BATcount(l);
			BUN hit_start = (q1 = BUNlast(l)), hit_end = q1, w = BUNfirst(r);
			int s1 = BUNsize(l);
			int s2 = BUNsize(r);
			size_t off = BUNindex(l,p1);

			h = (ptr) &ll;

			if (rl >= ll && rl < lh) {
				hit_start = BUNptr(l, off+(rl-ll));
			} else if (rl < ll && rh > ll) {
				hit_start = p1;
				w += s2*(ll-rl);
			}
			if (rh >= ll && rh < lh) {
				hit_end = BUNptr(l, off+(rh-ll));
			}
			while(p1 < hit_start) {
				t = BUNtail(l,p1);
				MISS@1(h,t);
				ll++;
				p1 += s1;
			}
			while(p1 < hit_end) {
				t = BUNtail(l,p1);
				t2 = BUNtail(r,w);
				if (EQUAL@2(t,t2)) {
					HIT@1(h,t);
				} else {
					MISS@1(h,t);
				}
				ll++;
				p1 += s1;
				w += s2;
			}
			while(p1 < q1) {
				t = BUNtail(l,p1);
				MISS@1(h,t);
				ll++;
				p1 += s1;
			}
		} else {
			int s1;
			size_t off = BUNindex(r,p1);

			BATloopFast(l, p1, q1, s1) {
				oid o = *(oid*) BUNhloc(l, p1);

				h = (ptr) &o;
				t = BUNtail(l,p1);

				if (o >= rl && o < rh) {
					BUN w = BUNptr(r,off+(o-rl));

					t2 = BUNtail(r,w);
					if (EQUAL@2(t,t2)) {
						HIT@1(h, t);
						continue;
					}
				}
				MISS@1(h,t);
			}
		}
	}

@= check
	if (BAThdense(l)) {
		@:hashcheck(@1,pos,@2,@3,@5,TRUE)@
	} else if (hash) {
		@:hashcheck(@1,@2,@2,@3,@5,@4)@
	} else {
		@:mergecheck(@1,@2,@3,@4,@5)@
	}
	break;

@= batcheck
static BAT*
BATins_@1@2(BAT *bn, BAT *l, BAT *r)
{
	int hash = TRUE, (*cmp)(ptr, ptr), (*merge)(ptr, ptr) = NULL;
	ptr hnil, tnil;
	int pin = 0;

	/* determine how to do the intersect */
	if (BAThordered(l)&BAThordered(r)&1) {
		hash = FALSE;
	} else if (FLIP@1(l,r)) {
		int flip = (BATtordered(l)&BATtordered(r)&1);
		if (flip) {
			hash = FALSE;
		} else {
			flip = (r->hhash == NULL && r->thash != NULL);
		}
		if (flip) {
			merge = BATatoms[l->ttype].atomCmp;
			r= BATmirror(r);
			l= BATmirror(l);
			bn= BATmirror(bn);
		}
	}
	merge = BATatoms[l->htype].atomCmp;
	cmp = BATatoms[l->ttype].atomCmp;
	hnil = ATOMnilptr(l->htype);
	tnil = ATOMnilptr(l->ttype);
	(void) cmp;
	(void) tnil;
	(void) hnil;

	if (BAThdense(r)) {
		@:voidcheck(@2,@1)@
	} else {
		switch(ATOMstorage(r->htype)) {
#ifndef NOEXPAND_CHR
		case TYPE_chr:
			@:check(@2,loc,_chr,simple_CMP(h,h2,chr),@1)@
#endif
#ifndef NOEXPAND_BTE
		case TYPE_bte:
			@:check(@2,loc,_bte,simple_CMP(h,h2,bte),@1)@
#endif
#ifndef NOEXPAND_SHT
		case TYPE_sht:
			@:check(@2,loc,_sht,simple_CMP(h,h2,sht),@1)@
#endif
#ifndef NOEXPAND_INT
		case TYPE_int:
			@:check(@2,loc,_int,simple_CMP(h,h2,int),@1)@
#endif
#ifndef NOEXPAND_FLT
		case TYPE_flt:
			@:check(@2,loc,_flt,simple_CMP(h,h2,flt),@1)@
#endif
#ifndef NOEXPAND_DBL
		case TYPE_dbl:
			@:check(@2,loc,_dbl,simple_CMP(h,h2,dbl),@1)@
#endif
#ifndef NOEXPAND_LNG
		case TYPE_lng:
			@:check(@2,loc,_lng,simple_CMP(h,h2,lng),@1)@
#endif
		default:
			if (r->hvarsized) {
				@:check(@2,var,var,((*merge)(h,h2)),@1)@
			} else {
				@:check(@2,loc,loc,((*merge)(h,h2)),@1)@
			}
		}
	}
	return bn;
  bunins_failed:
	if (pin)
		BATmmap_unpin(r);
	BBPreclaim(bn);
	return NULL;
}

BAT *
BAT@1@2(BAT *l, BAT *r)
{
	size_t	smaller;
	BAT	*bn;

	ERRORcheck(l == NULL, "BAT@1@2: left is null");
	ERRORcheck(r == NULL, "BAT@1@2: right is null");
	ERRORcheck(TYPEerror(BAThtype(l), BAThtype(r)), "BUN@1@2: incompatible head-types");
	ERRORcheck(TAILCHECK@1(l,r), "BUN@1@2: incompatible tail-types");

	if (BATcount(r) == 0) {
		return EMPTYr@2(l);
	} else if (BATcount(l) == 0) {
		return EMPTYl@2(l);
	}
	smaller = @2_size(l,r);
	bn = BATnew(BAThtype(l), BATttype(l), MAX(smaller,BATTINY));
	if (bn == NULL)
		return NULL;

	/* fill result bat bn */
	ALGODEBUG THRprintf(GDKout, "#BAT@1@2: BATins_@1@2(bn, l, r);\n");
	if (BATins_@1@2(bn, l, r) == NULL) {
		return NULL;
	}

	/* propagate alignment info */
	if (BATcount(bn)==BATcount(l)) {
		ALIGNset(bn, l);
	}
	if (RALIGN@2(bn, l, r)) {
		ALIGNsetH(bn, r);
	}
	bn->hsorted = BAThordered(l);
	bn->tsorted = BATtordered(l);
	if (BATcount(bn)){
		BATkey(bn, l->hkey);
		BATkey(BATmirror(bn), l->tkey);
	} else {
		BATkey(bn, TRUE);
		BATkey(BATmirror(bn), TRUE);
	}
	return bn;
}
@c
#define EMPTYldiff(l) BATclone(l,10)
#define EMPTYrdiff(l) BATcopy(l, l->htype, l->ttype, FALSE)
#define EMPTYlintersect(l) BATclone(l,10)
#define EMPTYrintersect(l) EMPTYlintersect(l)

#define intersect_size(l,r) MIN(BATcount(l), BATcount(r))
#define diff_size(l,r) BATcount(l)

@:batcheck(s,intersect,)@
@:batcheck(s,diff,-)@
@:batcheck(k,intersect,)@
@:batcheck(k,diff,-)@


@+ Union
Union also consists of two versions: @`BATkunion@5(l,r), which
unites with double elimination over the head column only, and
@`BATsunion@5(l,r), that looks at both columns. Their
implementation uses the s/kdiff() and s/kunique() code for efficient
double elimination.
@c
#define KEYk	TRUE
#define KEYs	FALSE

static BAT *
BATmaterialize_(BAT *b, size_t size)
{
	BAT *bn = BATnew(TYPE_oid, b->ttype, size);
	BUN p, q;
	int xx;
	oid base;

	if (bn == NULL)
		return NULL;
	base = b->hseqbase;
	if (base == oid_nil) {
		BATloopFast(b, p, q, xx) {
			bunfastins(bn, &base, BUNtail(b, p));
		}
	} else {
		BATloopFast(b, p, q, xx) {
			bunfastins(bn, &base, BUNtail(b, p));
			base++;
		}
	}
	ALIGNsetH(bn, b);
	ALIGNsetT(bn, b);
	return bn;
      bunins_failed:
	BBPreclaim(bn);
	return NULL;
}

@:union(k)@
@:union(s)@

@= bndense
	/* r and l may be void */
	bn@1dense = (BAT@1dense(r)&BAT@1dense(l)&1) && @1disjunct &&
			( ( *(@3*)BUN@2(r,BUNfirst(r)) - *(@3*)BUN@2(l,BUNlast(l)-BUNsize(l)) ) == (@3)1 );
	break;
@= union
BAT *
BAT@1union(BAT *l, BAT *r)
{
	int hdisjunct, tdisjunct, bnhdense, bntdense;
	BAT *bn, *b=0;
	BUN p,q;
	int xx;

	BATcompatible(l, r);
	if (BATcount(l) == 0) {
		BAT* swap = l;
		l = r;
		r = swap;
	}
	if (BATcount(r) == 0) {
		return BATcopy(l, l->htype, l->ttype, FALSE);
	}
	if (l->htype == TYPE_void && l->hseqbase != oid_nil) {
		bn = BATmaterialize_(l, BATcount(l)+BATcount(r));
	} else if (l->ttype == TYPE_void && l->tseqbase != oid_nil) {
		bn = BATmirror(BATmaterialize_(BATmirror(l),
					       BATcount(l)+BATcount(r)));
	} else {
		bn = BATcopy(l, l->htype, l->ttype, TRUE);
	}
	if( bn == NULL)
		return NULL;

	hdisjunct = (BAThordered(r)&BAThordered(l)&1) && (ATOMcmp(l->htype,
	      BUNhead(l,BUNlast(l)-BUNsize(l)), BUNhead(r,BUNfirst(r))) < 0);
	tdisjunct = (BATtordered(r)&BATtordered(l)&1) && (ATOMcmp(l->ttype,
	      BUNtail(l,BUNlast(l)-BUNsize(l)), BUNtail(r,BUNfirst(r))) < 0);

	/* for now, only oid can be dense;
	   later, bte, sht, int, wrd, lng might become dense, too */
	switch (bn->htype) {
	case TYPE_oid:
	case TYPE_void:
		@:bndense(h,head,oid)@
	default:
	        bnhdense = 0;
	}
	switch (bn->ttype) {
	case TYPE_oid:
	case TYPE_void:
		@:bndense(t,tail,oid)@
	default:
		bntdense = 0;
	}

	if (!hdisjunct) {
		b = r = BAT@1diff(r, bn);
		if (b == NULL) {
			BBPreclaim(bn);
			return NULL;
		}
	}
	BATloopFast(r,p,q,xx) {
		bunfastins(bn, BUNhead(r,p), BUNtail(r,p));
	}
	if (b)
		BBPreclaim(b);
	HASHdestroy(bn);

	/* set alignment info */
	if (!bnhdense) {
		bn->hseqbase = oid_nil;
		bn->hdense = 0;
	}
	if (!bntdense) {
		bn->tseqbase = oid_nil;
		bn->tdense = 0;
	}
	bn->hsorted = hdisjunct?GDK_SORTED:FALSE;
	bn->tsorted = tdisjunct?GDK_SORTED:FALSE;
	bn->talign = bn->halign = 0;
	if (KEY@1 == FALSE && hdisjunct == FALSE)
		BATkey(bn, FALSE);
	BATkey(BATmirror(bn), tdisjunct?(l->tkey&&r->tkey):0);

	return bn;
  bunins_failed:
	BBPreclaim(bn);
	return NULL;
}
@}
@-
