@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2006 CWI.
@' All Rights Reserved.

@f gdk_tm
@a M. L. Kersten, P. Boncz, N. J. Nes

@* Transaction management
The Transaction Manager maintains the buffer of (permanent) BATS held resident.
Entries from the BAT buffer are always accessed by BAT id.
A BAT becomes permanent by assigning a name with @%BATrename@.
Access to the transaction table is regulated by a semaphore.
@{
@h
#ifndef _GDK_TM_H_
#define _GDK_TM_H_
#include "gdk.h"

#define SYSTRANSACTION	"tmp"
#define MAXTM		10

#endif /* _GDK_TM_H_ */
@c
#include "gdk.h"
#include "gdk_tm.h"

@- 
The physical (disk) commit protocol is handled mostly by BBPsync. Once a commit
succeeded, there is the task of removing ex-persistent bats (those that still
were persistent in the previous commit, but were made transient in this transaction).
Notice that such ex- (i.e. non-) persistent bats are not backed up by the BBPsync
protocol, so we cannot start deleting after we know the commit will succeed.

Another hairy issue are the delta statuses in BATs. These provide a fast way
to perform a transaction abort (HOT-abort, instead of COLD-abort, which is achieved
by the BBP recovery in a database restart). Hot-abort functionality has not been 
important in MonetDB for now, so it is not well-tested. The problem here is that 
if a commit fails in the physical part (BBPsync), we have not sufficient information 
to roll back the delta statuses. 

So a 'feature' of the abort is that after a failed commit, in-memory we
*will* commit the transaction. Subsequent commits can retry to achieve a physical
commit. The only way to abort in such a situation is COLD-abort: quit the server and 
restart, so you get the recovered disk images.
@{
@c
int
TMcommit(void)
{
	int i, ret = 0;

	/* Acquire BBP locks */
	BBPlock("TMcommit");

	/* commit the delta status of each BAT; we cannot soft-abort after this anymore */
	for (i = 1; i < BBPsize; i++) {
		if (BBP_status(i) & BBPPERSISTENT) {
			BAT *b = BBP_cache(i);

			if (b == NULL && (BBP_status(i) & BBPSWAPPED)) {
				b = BBPquickdesc(i, TRUE);
				if (b == NULL) {
					ret = 1;
				}
			}
			if (b) {
				BATcommit(b);
			}
		}
	}
	/* make sure the stable image of the persistent bATs is committed to disk */
	if (ret == 0) {
		ret = BBPsync(TRUE);
	}
	/* in case the commit succeeded; delete the disk images of ex-persistent bats */
	if (ret == 0) {
		for (i = 1; i < BBPsize; i++) {
			if (BBP_status(i) & BBPPERSISTENT) {
				BBP_status_on(i, BBPEXISTING, "TMcommit");
			} else if ((BBP_status(i) & (BBPDELETED | BBPTMP)) && BBP_refs(i) <= 0 && BBP_lrefs(i) <= 0) {
				BAT *b = BBPquickdesc(i, TRUE);

				/* the unloaded ones are deleted without loading */
				/* delete disk images */
				BATdelete(b);	
				if (BBP_cache(i)) {
					/* those that quickdesc decides to load => free memory */
					BATfree(b);
				}
				BBPclear(i);	/* clear with locking */
			}
			BBP_status_off(i, BBPDELETED | BBPSWAPPED | BBPNEW, "TMcommit");
		}
	}
	BBPunlock("TMcommit");
	return ret;
}

@- 
Transaction abort is cheap. We use the delta statuses
to go back to the previous version of each BAT. Also
for BATs that are currently swapped out. Persistent BATs 
that were made transient in this transaction become
persistent again.
@c
int
TMabort(void)
{
	int i;

	BBPlock("TMabort");
	for (i = 1; i < BBPsize; i++) {
		if (BBP_status(i) & BBPNEW) {
			BAT *b = BBPquickdesc(i, FALSE);

			if (b) {
				if (b->batPersistence == PERSISTENT)
					BBPdecref(i, TRUE);
				b->batPersistence = TRANSIENT;
				b->batDirtydesc = 1;
			}
		}
	}
	for (i = 1; i < BBPsize; i++) {
		if (BBP_status(i) & (BBPPERSISTENT | BBPDELETED | BBPSWAPPED)) {
			BAT *b = BBPquickdesc(i, TRUE);

			if (b == NULL)
				continue;

			BBPfix(i);
			if (BATdirty(b) || DELTAdirty(b)) {
				/* BUN move-backes need a real BAT! */
				/* Stefan: 
				 * Actually, in case DELTAdirty(b), i.e., a
				 * BAT with differences that is
				 * saved/swapped-out but not yet committed,
				 * we (AFAIK) don't have to load the BAT and
				 * apply the undo, but rather could simply
				 * discard the delta and revive the backup;
				 * however, I don't know how to do this
				 * (yet), hence we stick with this solution
				 * for the time being --- it should be
				 * correct though it might not be the most
				 * efficient way...
				 */
				b = BBPdescriptor(i);
				BATundo(b);
			}
			if (BBP_status(i) & BBPDELETED) {
				BBP_status_on(i, BBPEXISTING, "TMabort");
				if (b->batPersistence != PERSISTENT)
					BBPincref(i, TRUE);
				b->batPersistence = PERSISTENT;
				b->batDirtydesc = 1;
			}
			BBPunfix(i);
		}
		BBP_status_off(i, BBPDELETED | BBPSWAPPED | BBPNEW, "TMabort");
	}
	BBPunlock("TMabort");
	return 0;
}

@- TMsubcommit

Routine to quickly add new bats or remove old bats in a commited database state.
Both cases have in common that rollback actions are not necessary. This
allows for an implementation that comes down to just writing a new BBP.dir.

We assume that the thread calling this has exclusive write access to the 
bats it wants to commit (passed in the tail of bl).
In particular, if another thread updates one of the bats passed here during
the partial commit (or modifies its persistency status), inconsistent results
may occur.

Note that this primitive also assumes that the BATs being commited are independent
of the other persistent BATs. That is, no incosistent state is created by commiting 
the actual state of this subset of BAT and not committing the rest.
@c
int
TMsubcommit(BAT* bl) {
	int xx, cnt = 0, *changed = (int*) alloca(BATcount(bl)*sizeof(int));
	BUN p, q;

	/* first make our new bats persistent and saved on disk */
	BATloopFast(bl, p, q, xx) {
		int i = *(int*) BUNtloc(bl,p);
		BAT *b = NULL;
		if (i < 0) i = -i;
		if (BBPfix(i) >= 0) {
			b = BBPdescriptor(i);
			if (b) {
				BATcommit(b);
				if (b->batPersistence == PERSISTENT) { 
					/* not-yet-committed persistent bats */
					if (BBP_status(i) & BBPNEW) {
						changed[cnt++] = i;
						if (BBPsave(b)) b = NULL;
					} else if (BATdirty(b)) {
						GDKerror("TMsubcommit: %s has already been committed\n", 
							BBP_logical(i));
						b = NULL;
					}
				} else {
					/* no longer persistent bats */
					if (BBP_status(i) & (BBPDELETED|BBPEXISTING)) 
						changed[cnt++] = -i;
				}
			}
			BBPunfix(i);
		}
		if (b == NULL) return -1;
	}
	/* if the not-yet-committed count is 0, we don't need to write a new BBP.dir */
	if (cnt == 0) return 0;

	/* block other commits and BBPtrims that might remove non-persistent bats */
	gdk_set_lock(GDKtrimLock, "TMsubcommit");

	/* all bats clean on disk, now change their statuses for BBPdir */
	for(xx=0; xx<cnt; xx++) {
		int i = changed[xx];
		if (i > 0) {
			BBP_status_on(i, BBPEXISTING, "TMsubcommit");
			BBP_status_off(i, BBPNEW, "TMsubcommit");
		} else {
			BBP_status_off(-i, BBPEXISTING, "TMsubcommit");
			BBP_status_off(-i, BBPDELETED, "TMsubcommit");
		}
	}

	/* write the new BPP.dir with those BATs that were in the previous commit */
	if (BBPdir(TRUE) == 0) 
		cnt = 0; /* everything ok */

	for(xx=0; xx<cnt; xx++) {
		/* FAILED: undo the status changes */
		int i = changed[xx];
		if (i > 0) {
			BBP_status_off(i, BBPEXISTING, "TMsubcommit");
			BBP_status_on(i, BBPNEW, "TMsubcommit");
		} else {
			BBP_status_on(-i, BBPEXISTING, "TMsubcommit");
			BBP_status_on(-i, BBPDELETED, "TMsubcommit");
		}
	}
	gdk_unset_lock(GDKtrimLock, "TMsubcommit");

	return -cnt;
}
@}
