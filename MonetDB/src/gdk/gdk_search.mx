@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2007 CWI.
@' All Rights Reserved.

@f gdk_search
@a M. L. Kersten, P. Boncz

@* Search Accelerators

What sets BATs apart from normal arrays is their built-in ability to
search on both dimensions of the binary association.  The easiest way to
implement this is simply walk to the whole table and compare against each
element.  This method is of course highly inefficient, much better performance
can be obtained if the BATs use some kind of index method to speed up
searching.

While index methods speed up searching they also have disadvantages.
In the first place extra storage is needed for the index. Second,
insertion of data or removing old data requires updating of the index
structure, which takes extra time.

This means there is a need for both indexed and non-indexed BAT, the
first to be used when  little or no searching is needed, the
second to be used when searching is predominant. Also, there is no
best index method for all cases, different methods have different storage
needs and different performance. Thus, multiple index methods are provided,
each suited to particular types of usage.

For query-dominant environments it pays to build a search accelerator.
The main problems to be solved are:
@itemize
@item
avoidance of excessive storage requirements, and
@item
limited maintenance overhead.
@end itemize

@-
The idea that query intensive tasks need many different index methods has
been proven invalid. The current direction is multiple copies of data, which
can than be sorted or clustered.

@-
The BAT library automatically decides when an index becomes cost
effective.

In situations where an index is expected, a call is
made to @emph{BAThash}.
This operation check for indexing on the header.
@{
@+ Interface Declarations
@h
#ifndef _GDK_SEARCH_H_
#define _GDK_SEARCH_H_
#include "gdk.h"
@}
@+ Hash indexing
This is a highly efficient implementation of simple bucket-chained hashing.

In the past, we used integer modulo for hashing, with bucket chains of mean size 4.
This was shown to be inferior to direct hashing with integer anding. The new implementation
reflects this.
@{
@h
gdk_export Hash *HASHnew(Heap *hp, int tpe, size_t size, hash_t mask);
gdk_export hash_t HASHmask(size_t cnt);
gdk_export BAT *HASHprint(BAT *b);
gdk_export void HASHremove(BAT *b);
gdk_export void HASHdestroy(BAT *b);
gdk_export hash_t HASHprobe(Hash *h, ptr v);
gdk_export hash_t HASHlist(Hash *h, size_t i);

#define mix_sht(X)            (((X)>>7)^(X))
#define mix_int(X)            (((X)>>7)^((X)>>13)^((X)>>21)^(X))
#define hash_loc(H,V)         hash_any(H,V)
#define hash_var(H,V)         hash_any(H,V)
#define hash_any(H,V)         (ATOMhash((H)->type, (V)) & (H)->mask)
#define hash_bte(H,V)         ((hash_t) (*(unsigned char*) (V)) & (H)->mask)
#define hash_chr(H,V)         hash_bte(H,V)
#define hash_sht(H,V)         ((hash_t) mix_sht(*((unsigned short*) (V))) & (H)->mask)
#define hash_int(H,V)         ((hash_t) mix_int(*((unsigned int*) (V))) & (H)->mask)
/* XXX return size_t-sized value for 8-byte oid? */
#define hash_lng(H,V)         ((hash_t) mix_int((unsigned int) (*(lng *)(V) ^ (*(lng *)(V) >> 32))) & (H)->mask)


@= hashfnd
#define HASHfnd_@1(x,y,z)	{					\
	hash_t _i;							\
	BUN _v;								\
	(x) = NULL;							\
	if ((y)->hhash || BAThash((y), 0) || GDKfatal("HASHfnd_@1: hash build failed on %s.\n", BATgetId((y)))) \
		HASHloop_@1((y), (y)->hhash, _i, (z), _v) {		\
			(x) = _v;					\
			break;						\
		}							\
}
@h
#define HASHfnd_str(x,y,z)	{					\
	hash_t _i;							\
	(x) = NULL;							\
	if ((y)->hhash || BAThash((y), 0) || GDKfatal("HASHfnd_str: hash build failed on %s.\n", BATgetId((y)))) \
		HASHloop_str((y), (y)->hhash, _i, (z)) {		\
			(x) = BUNptr((y),_i);				\
			break;						\
		}							\
}
#define HASHfnd(x,y,z)	{						\
	size_t _i;							\
	x=NULL;								\
	if ((y)->hhash || BAThash((y), 0) || GDKfatal("HASHfnd: hash build failed on %s.\n", BATgetId((y)))) \
		HASHloop((y), (y)->hhash, _i, (z)) {			\
			(x) = BUNptr((y),_i);				\
			break;						\
		}							\
}
@:hashfnd(chr)@
@:hashfnd(bte)@
@:hashfnd(sht)@
@:hashfnd(int)@
@:hashfnd(lng)@

#if SIZEOF_VOID_P == SIZEOF_INT
#define HASHfnd_ptr(x,y,z)	HASHfnd_int(x,y,z)
#else /* SIZEOF_VOID_P == SIZEOF_LNG */
#define HASHfnd_ptr(x,y,z)	HASHfnd_lng(x,y,z)
#endif
#define HASHfnd_bit(x,y,z)	HASHfnd_chr(x,y,z)
#if SIZEOF_OID == SIZEOF_INT	/* OIDDEPEND */
#define HASHfnd_oid(x,y,z)	HASHfnd_int(x,y,z)
#else
#define HASHfnd_oid(x,y,z)	HASHfnd_lng(x,y,z)
#endif
#define HASHfnd_flt(x,y,z)	HASHfnd_int(x,y,z)
#define HASHfnd_dbl(x,y,z)	HASHfnd_lng(x,y,z)
#define HASHfnd_any(x,y,z)	HASHfnd(x,y,z)
@-
A new entry is added with @%HASHins@ using the BAT, the BUN index,
and a pointer to the value to be stored. An entry is removed by @%HASdel@.

@= hashins
#define HASHins_@1(h, i, v) {			\
	hash_t _c = hash_@1(h,v);		\
	h->link[i] = h->hash[_c];		\
	h->hash[_c] = i;			\
}
@h
#define HASHins_str(h,i,v) {			\
	hash_t _c;				\
	GDK_STRHASH(v,_c);			\
	_c &= (h)->mask;			\
	h->link[i] = h->hash[_c];		\
	h->hash[_c] = i;			\
}

#define HASHins(h,i,v) {			\
	hash_t _c = HASHprobe(h, v);		\
	h->link[i] = h->hash[_c];		\
	h->hash[_c] = i;			\
}

#if SIZEOF_VOID_P == SIZEOF_INT
#define HASHins_ptr(h,i,v)	HASHins_int(h,i,v)
#else /* SIZEOF_VOID_P == SIZEOF_LNG */
#define HASHins_ptr(h,i,v)	HASHins_lng(h,i,v)
#endif
#define HASHins_bit(h,i,v)	HASHins_chr(h,i,v)
#if SIZEOF_OID == SIZEOF_INT	/* OIDDEPEND */
#define HASHins_oid(h,i,v)	HASHins_int(h,i,v)
#else
#define HASHins_oid(h,i,v)	HASHins_lng(h,i,v)
#endif
#define HASHins_flt(h,i,v)	HASHins_int(h,i,v)
#define HASHins_dbl(h,i,v)	HASHins_lng(h,i,v)
#define HASHins_any(h,i,v)	HASHins(h,i,v)
#define HASHinsvar(h,i,v)	HASHins(h,i,v)
#define HASHinsloc(h,i,v)	HASHins(h,i,v)

@:hashins(chr)@
@:hashins(bte)@
@:hashins(sht)@
@:hashins(int)@
@:hashins(lng)@

#define HASHdel(h, i, v, next) {					\
	if (next && h->link[i+1] == i) {				\
		h->link[i+1] = h->link[i];				\
	} else {							\
		size_t _c = HASHprobe(h, v);				\
		if (h->hash[_c] == i) {					\
			h->hash[_c] = h->link[i];			\
		} else {						\
			for(_c = h->hash[_c]; _c != HASH_MAX; 		\
					_c = h->link[_c]){ 		\
				if (h->link[_c] == i) {			\
					h->link[_c] = h->link[i];	\
					break;				\
				}					\
			}						\
		}							\
	} h->link[i] = HASH_MAX;					\
}

#define HASHmove(h, i, j, v, next) {					\
	if (next && h->link[i+1] == i) {				\
		h->link[i+1] = j;					\
	} else {							\
		size_t _c = HASHprobe(h, v);				\
		if (h->hash[_c] == i) {					\
			h->hash[_c] = j;				\
		} else {						\
			for(_c = h->hash[_c]; _c != HASH_MAX; 		\
					_c = h->link[_c]){ 		\
				if (h->link[_c] == i) {			\
					h->link[_c] = j;		\
					break;				\
				}					\
			}						\
		}							\
	} h->link[j] = h->link[i];					\
}
@}
@- Hash Table Creation
The @emph{hash} indexing scheme for BATs reserves a block of memory to maintain
the hash table and a collision list. A one-to-one mapping exists between
the BAT and the collision list using the BUN index. NOTE: we alloc the
link list as a parallel array to the BUN array; hence the hash link array has
the same size as BATcapacity(b) (not BATcount(b)). This allows us in the
BUN insert and delete to assume that there is hash space iff there is BUN
space. If there is no BUN space, the BATextend now destroys the hash table.

The hash mask size is a power of two, so we can do bitwise AND on the
hash (integer) number to quickly find the head of the bucket chain.
Clearly, the hash mask size is a crucial parameter. If we know that the column
is unique (hkey), we use direct hashing (mask size ~= BATcount). Otherwise
we dynamically determine the mask size by starting out with mask size = BATcount/64
(just 1.5% of memory storage overhead). Then we start building the hash table
on the first 25% of the BAT. As we aim for max-collisions list length of 4,
the list on 25% should not exceed length 1. So, if a small number of collisssions
occurs (mask/2) then we abandon the attempt and restart with a mask that is 4 times
larger. This converges after three cycles to direct hashing.
@{
@c
#include "monetdb_config.h"
#include "gdk.h"

hash_t
HASHmask(size_t cnt)
{
	size_t m = 8;		/* minumum size */

	while (m + m < cnt)
		m += m;
	if (m + m - cnt < 2 * (cnt - m))
		m += m;
	return m;
}

void
HASHclear(Hash *h)
{
	hash_t *i, *j;

	for (i = h->hash, j = i + h->mask; i <= j; i++) {
		*i = HASH_MAX;
	}
}

Hash *
HASHnew(Heap *hp, int tpe, size_t size, hash_t mask)
{
	Hash *h = NULL;
	if (HEAPalloc(hp, mask + size, sizeof(hash_t)) < 0)
		return NULL;
	h = (Hash*)GDKmalloc(sizeof(Hash));
	if (!h)
		return h;
	h->lim = size;
	h->mask = mask - 1;
	h->link = (hash_t *) hp->base;
	h->hash = h->link + h->lim;
	h->type = tpe;
	h->heap = hp;
	HASHclear(h);		/* zero the mask */
	return h;
}

@= starthash
	for (xx = BUNsize(b); r < p; r += xx) {
		ptr v = BUN@2(b, r);
		hash_t c = hash_@1(h, v);

		if (h->hash[c] == HASH_MAX && nslots-- == 0) {
			break; /* mask too full */
		}
		h->link[i] = h->hash[c];
		h->hash[c] = (hash_t) i++;
	}
	break;
@= finishhash
	for (xx = BUNsize(b); p < q; p += xx) {
		ptr v = BUN@2(b, p);
		hash_t c = hash_@1(h, v);

		h->link[i] = h->hash[c];
		h->hash[c] = (hash_t) i++;
	}
	break;
@-
The prime routine for the BAT layer is to create a new hash index.
Its argument is the element type and the maximum number of BUNs
be stored under the hash function.
@c
BAT *
BAThash(BAT *b, size_t masksize)
{
	gdk_set_lock(GDKhashLock[ABS(b->batCacheid) & BBPLOCKMASK], "BAThash");
	if (b->hhash == NULL) {
		unsigned int xx, tpe = ATOMstorage(b->htype);
		size_t i, cnt = BATcount(b);
		hash_t mask;
		BUN p = BUNfirst(b), q = BUNlast(b), r;
		Hash *h = NULL;
		Heap *hp = NULL;
		str nme = BBP_physical(b->batCacheid);

		/* cnt = 0, hopefully there is a proper capacity from which
		 * we can derive enough information */
		if (!cnt)
			cnt = BATcapacity(b);

		if (b->htype == TYPE_void) {
			BATDEBUG GDKwarning("BAThash: creating hash-table on void column..\n");

			tpe = TYPE_void;
		}
		/* determine hash mask size */
		if (masksize > 0) {
			mask = HASHmask(masksize);	/* p = first; so no dynamic scheme */
		} else if (b->hkey) {
			mask = HASHmask(cnt);	/* p = first; so no dynamic scheme */
		} else {
			/* dynamic hash: we start with HASHmask(cnt/64); if there are too many collisions
			 * we try HASHmask(cnt/16), then HASHmask(cnt/4), and finally HASHmask(cnt).  */
			mask = HASHmask(cnt >> 6);
			p += (cnt >> 2) * BUNsize(b);	/* try out on first 25% of b */
			if (p > q)
				p = q;
		}
                if (mask < 1024) mask = 1024;
		do {
			size_t nslots = mask >> 1;	/* 1/2 full is too full */

			r = BUNfirst(b);
			i = BUNindex(b, r);
			if (hp) {
				HEAPfree(hp);
				GDKfree(hp);
			}
			if (h) 
				GDKfree(h);
			/* create the hash structures */
			hp = (Heap *) GDKmalloc(sizeof(Heap));
			hp->filename = GDKmalloc(strlen(nme) + 12);
			sprintf(hp->filename, "%s.%chash", nme, b->batCacheid > 0 ? 'h' : 't');
			if ((h = HASHnew(hp, ATOMtype(b->htype), BATcapacity(b), (size_t) mask)) == NULL) {
				gdk_unset_lock(GDKhashLock[ABS(b->batCacheid) & BBPLOCKMASK], "BAThash");
				GDKfree(hp->filename);
				GDKfree(hp);
				return NULL;
			}
			if (hp->storage & STORE_MMAP)
				MT_mmap_pin(hp->base, hp->maxsize);

			switch (tpe) {
#ifndef NOEXPAND_CHR
			case TYPE_chr:
				@:starthash(chr,hloc)@
#endif
#ifndef NOEXPAND_BTE
			case TYPE_bte:
				@:starthash(bte,hloc)@
#endif
#ifndef NOEXPAND_SHT
			case TYPE_sht:
				@:starthash(sht,hloc)@
#endif
#if !defined(NOEXPAND_INT) || !defined(NOEXPAND_FLT)
			case TYPE_int:
			case TYPE_flt:
				@:starthash(int,hloc)@
#endif
#if !defined(NOEXPAND_DBL) || !defined(NOEXPAND_LNG)
			case TYPE_dbl:
			case TYPE_lng:
				@:starthash(lng,hloc)@
#endif
			default:
				@:starthash(any,head)@
			}
		} while (r < p && mask < cnt && (mask <<= 2));

		/* finish the hashtable with the current mask */
		p = r;
		switch (tpe) {
#ifndef NOEXPAND_CHR
		case TYPE_chr:
			@:finishhash(chr,hloc)@
#endif
#ifndef NOEXPAND_BTE
		case TYPE_bte:
			@:finishhash(bte,hloc)@
#endif
#ifndef NOEXPAND_SHT
		case TYPE_sht:
			@:finishhash(sht,hloc)@
#endif
#if !defined(NOEXPAND_INT) || !defined(NOEXPAND_FLT)
		case TYPE_int:
		case TYPE_flt:
			@:finishhash(int,hloc)@
#endif
#if !defined(NOEXPAND_DBL) || !defined(NOEXPAND_LNG)
		case TYPE_dbl:
		case TYPE_lng:
			@:finishhash(lng,hloc)@
#endif
		default:
			@:finishhash(any,head)@
		}
		b->hhash = BATmirror(b)->thash = h;
	}
	gdk_unset_lock(GDKhashLock[ABS(b->batCacheid) & BBPLOCKMASK], "BAThash");
	return b;
}

@-
The entry on which a value hashes can be calculated with the
routine @%HASHprobe@.
@c
hash_t
HASHprobe(Hash *h, ptr v)
{
	switch (ATOMstorage(h->type)) {
#ifndef NOEXPAND_CHR
	case TYPE_chr:
		return hash_chr(h, v);
#endif
#ifndef NOEXPAND_BTE
	case TYPE_bte:
		return hash_bte(h, v);
#endif
#ifndef NOEXPAND_SHT
	case TYPE_sht:
		return hash_sht(h, v);
#endif
#if !defined(NOEXPAND_INT) || !defined(NOEXPAND_FLT)
	case TYPE_int:
	case TYPE_flt:
		return hash_int(h, v);
#endif
#if !defined(NOEXPAND_DBL) || !defined(NOEXPAND_LNG)
	case TYPE_dbl:
	case TYPE_lng:
		return hash_lng(h, v);
#endif
	default:
		return hash_any(h, v);
	}
}

BAT *
HASHprint(BAT *b)
{
#if SIZEOF_OID == SIZEOF_INT
	BAT *bn = BATnew(BAThtype(b), TYPE_int, BATcount(b));
#else
	BAT *bn = BATnew(BAThtype(b), TYPE_lng, BATcount(b));
#endif
	BUN p, q;

	if (bn == NULL)
		return NULL;
	if (!(b && b->hhash))
		return 0;
	BATloop(b, p, q) {
		size_t i = HASHprobe(b->hhash, BUNhead(b, p));

		bunfastins(bn, BUNhead(b, p), &i);
	}
	bn->hsorted = BAThordered(b);
	bn->tsorted = FALSE;
	return bn;
      bunins_failed:
	BBPreclaim(bn);
	return NULL;
}

hash_t
HASHlist(Hash *h, size_t i)
{
	hash_t j;
	hash_t c = 1;

	while ((j = h->link[i]) != HASH_MAX) {
		c++;
		i = j;
		if (i > h->lim) {
			stream_printf(GDKout, "hash inconsistency link " SZFMT "\n", i);
			break;
		}
	}
	return c;
}

void
HASHremove(BAT *b)
{
	if (b->hhash) {
		BAT *p = BBP_cache(VIEWparent(b));
		BAT *m = BATmirror(b);

		if (p && b->hhash == p->hhash) {
			GDKerror("HASHremove: view-bat cannot remove parent hash-table\n");
			assert(0);
		} else {
			HEAPfree(b->hhash->heap);
			if (b->hhash->heap->storage & STORE_MMAP)
				HEAPdelete(b->hhash->heap, BBP_physical(b->batCacheid), (b->batCacheid > 0) ? "hhash" : "thash");
			GDKfree(b->hhash->heap);
			GDKfree(b->hhash);
		}
		if (m)
			m->thash = NULL;
		b->hhash = NULL;
	}
}

void
HASHdestroy(BAT *b)
{
	HASHremove(b);
	if (BATmirror(b))
		HASHremove(BATmirror(b));
}

@}

@+ Binary Search on a Sorted BAT
We have two main routines, @`SORTfndfirst@5(b,v) and @`SORTfndlast@5(b,v), that
search for a TAIL value 'v' in a sorted BAT. If the value is present, 
the first routine returns a pointer to its first occurrence, while the second
routine returns a pointer to the BUN just after the last occurrence of 'v'.
In case value 'v' does not occur in the tail of BAT b, both routines return
a pointer to the first BUN with a tail value larger than 'v' 
(i.e., @%BUNfirst(b)@, in case all tail values are larger than 'v'); 
or @%BUNlast(b)@, in case all tail values are smaller than 'v'.
@
@
From the above routines we now also defined the @`SORTfnd@5 and @%SORTfnd_tpe@
routines that look for a certain value and return a (not necessarily the first
or last) reference to it, or NULL (if the value does not exist).

Note: of the SORTfnd, only @`SORTfndfirst@5(b,v) and
@`SORTfndlast@5(b,v) work on the tail of a bat!
@
@

@- Range Binary Search
Type-specific versions of @:SORTfndfirst@ are available using macro
expansions. It finds the first BUN larger or equal than a certain
value and expands to @`SORTfndfirst_chr@5, @`SORTfndfirst_sht@5,
@`SORTfndfirst_int@5, @`SORTfndfirst_flt@5, @`SORTfndfirst_lng@5,
@`SORTfndfirst_dbl@5, @`SORTfndfirst_loc@5 and @`SORTfndfirst_var@5.

Type-specific versions of @:SORTfndlast@ are available using macro
expansions. It finds the first BUN smaller or equal than a certain
value and expands to @`SORTfndlast_chr@5, @`SORTfndlast_sht@5,
@`SORTfndlast_int@5, @`SORTfndlast_flt@5, @`SORTfndlast_lng@5,
@`SORTfndlast_dbl@5, @`SORTfndlast_loc@5 and @`SORTfndlast_var@5.
@{
@h
/* type specific binary search implementations */
gdk_export BUN SORTfnd_chr(BAT *b, ptr v);
gdk_export BUN SORTfnd_bte(BAT *b, ptr v);
gdk_export BUN SORTfnd_sht(BAT *b, ptr v);
gdk_export BUN SORTfnd_int(BAT *b, ptr v);
gdk_export BUN SORTfnd_flt(BAT *b, ptr v);
gdk_export BUN SORTfnd_lng(BAT *b, ptr v);
gdk_export BUN SORTfnd_dbl(BAT *b, ptr v);
gdk_export BUN SORTfnd_loc(BAT *b, ptr v);
gdk_export BUN SORTfnd_var(BAT *b, ptr v);
gdk_export BUN SORTfndfirst_chr(BAT *b, ptr v);
gdk_export BUN SORTfndfirst_bte(BAT *b, ptr v);
gdk_export BUN SORTfndfirst_sht(BAT *b, ptr v);
gdk_export BUN SORTfndfirst_int(BAT *b, ptr v);
gdk_export BUN SORTfndfirst_flt(BAT *b, ptr v);
gdk_export BUN SORTfndfirst_lng(BAT *b, ptr v);
gdk_export BUN SORTfndfirst_dbl(BAT *b, ptr v);
gdk_export BUN SORTfndfirst_loc(BAT *b, ptr v);
gdk_export BUN SORTfndfirst_var(BAT *b, ptr v);
gdk_export BUN SORTfndlast_chr(BAT *b, ptr v);
gdk_export BUN SORTfndlast_bte(BAT *b, ptr v);
gdk_export BUN SORTfndlast_sht(BAT *b, ptr v);
gdk_export BUN SORTfndlast_int(BAT *b, ptr v);
gdk_export BUN SORTfndlast_flt(BAT *b, ptr v);
gdk_export BUN SORTfndlast_lng(BAT *b, ptr v);
gdk_export BUN SORTfndlast_dbl(BAT *b, ptr v);
gdk_export BUN SORTfndlast_loc(BAT *b, ptr v);
gdk_export BUN SORTfndlast_var(BAT *b, ptr v);

#endif /* _GDK_SEARCH_H_ */

@-
@}
By Peter sept-99. This is a simple implementation that avoids all multiply
and divs on most bats by using integer BUNindex numbers rather than absolute
pointers (the BUNptr employed to obtain a pointer uses shift where possible).
Also, the gradient-based approach has been dropped again, which allows all
atoms to be treated in one macro. Main motivation: distrust of gradient
performance on odmg data and its high mult/div overhead.
@{
@= SORTfnd
BUN
SORTfndfirst_@2(BAT *b, ptr v)
{
	BUN end = BUNfirst(b), cur = end;
	size_t lo = BUNindex(b,end), hi = BUNindex(b,BUNlast(b));
	int cmp = 1, bunsize = BUNsize(b);

        if (lo >= hi || @3_CMP(BUNt@1(b, cur), v, @4)>=0) {
		/* shortcut: if BAT is empty or first (and hence all) tail
		 * value is >= v, we're done. */
		return cur;
	}
	while (lo < hi) {
		size_t mid = (lo+hi)>>1;

		cur = BUNptr(b, mid);
		cmp = @3_CMP(BUNt@1(b, cur), v, @4);
		if (cmp < 0) {
			lo = ++mid;
			cur += bunsize;
		} else if (cmp > 0) {
			hi = mid;
		} else {
			break;
		}
	}
	if (cmp == 0 && b->tkey == 0) {  /* shift over multiple equals */
		while((cur-=bunsize) >= end) {
			if (!@3_EQ(BUNt@1(b,cur),v,@4))
				break;
		}
		cur += bunsize;
	}
	return cur;
}

BUN
SORTfndlast_@2(BAT *b, ptr v)
{
	BUN end = BUNlast(b), cur = end;
	size_t lo = BUNindex(b,BUNfirst(b)), hi = BUNindex(b,end);
	int cmp = 1, bunsize = BUNsize(b);

        if (lo >= hi || @3_CMP(BUNt@1(b, cur-bunsize), v, @4)<=0) {
		/* shortcut: if BAT is empty or last (and hence all) tail
		 * value is <= v, we're done. */
		return cur;
	}
	while (lo < hi) {
		size_t mid = (lo+hi)>>1;
		cur = BUNptr(b, mid);
		cmp = @3_CMP(BUNt@1(b,cur),v,@4);
		if (cmp < 0) {
			lo = ++mid;
			cur += bunsize;
		} else if (cmp > 0) {
			hi = mid;
		} else {
			break;
		}
	}
	if (cmp == 0 && b->tkey == 0) {  /* shift over multiple equals */
		while((cur+=bunsize) < end) {
			if (!@3_EQ(BUNt@1(b,cur),v,@4))
				break;
		}
	} else if (cmp == 0) {
		cur += bunsize;
	}
	return cur;
}

BUN
SORTfnd_@2(BAT *m, ptr v)
{
	BAT *b = BATmirror(m);
	size_t lo = BUNindex(b,BUNfirst(b)), hi = BUNindex(b,BUNlast(b));
	int cmp = 1, bunsize = BUNsize(b);
	BUN cur = NULL;

	while (lo < hi) {
		size_t mid = (lo+hi)>>1;
		cur = BUNptr(b, mid);
		cmp = @3_CMP(BUNt@1(b,cur),v,@4);
		if (cmp < 0) {
			lo = ++mid;
			cur += bunsize;
		} else if (cmp > 0) {
			hi = mid;
		} else {
			break;
		}
	}
	return cmp ? NULL : cur;
}

@= SORTfnd_switch
BUN
SORTfnd@2(BAT *b, ptr v)
{
	if (b && b->@1sorted&1) {
		switch(ATOMstorage(b->@1type)) {
#ifndef NOEXPAND_CHR
		case TYPE_chr:
			return SORTfnd@2_chr(b,v);
#endif
#ifndef NOEXPAND_BTE
		case TYPE_bte:
			return SORTfnd@2_bte(b,v);
#endif
#ifndef NOEXPAND_SHT
		case TYPE_sht:
			return SORTfnd@2_sht(b,v);
#endif
#ifndef NOEXPAND_INT
		case TYPE_int:
			return SORTfnd@2_int(b,v);
#endif
#ifndef NOEXPAND_FLT
		case TYPE_flt:
			return SORTfnd@2_flt(b,v);
#endif
#ifndef NOEXPAND_DBL
		case TYPE_dbl:
			return SORTfnd@2_dbl(b,v);
#endif
#ifndef NOEXPAND_LNG
		case TYPE_lng:
			return SORTfnd@2_lng(b,v);
#endif
		default:
			if (b->@1varsized) {
				return SORTfnd@2_var(b,v);
			} else {
				return SORTfnd@2_loc(b,v);
			}
		}
	}
	return NULL;
}
@c
@:SORTfnd(loc,chr,simple,chr)@
@:SORTfnd(loc,bte,simple,bte)@
@:SORTfnd(loc,sht,simple,sht)@
@:SORTfnd(loc,int,simple,int)@
@:SORTfnd(loc,lng,simple,lng)@
@:SORTfnd(loc,flt,simple,flt)@
@:SORTfnd(loc,dbl,simple,dbl)@
@:SORTfnd(loc,loc,atom,b->ttype)@
@:SORTfnd(var,var,atom,b->ttype)@

@:SORTfnd_switch(h,)@
@:SORTfnd_switch(t,last)@
@:SORTfnd_switch(t,first)@

@c

@}
