@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
@' Copyright August 2008-2010 MonetDB B.V.
@' All Rights Reserved.

@f gdk_qsort
@a Peter Boncz, Niels Nes et al
@* Qsort
There were two problems with the OS provided qsort() library routine:
@table @samp
@item unreliable
on certain OSs (e.g. SunOS), the qsort somehow degenerates
if there are a very small number of different values (on 
132K elements with 7 values, I never saw it return). 
This is a serious bug.
@item atom format
 when comparing GDK atoms (e.g. in BATs) it was not
possible to use qsort on varsized atoms (as monet stores them 
as integer offsets from a global base pointer that qsort does 
not know about), nor if the values were not placed at the start 
of the record (e.g.  if the column is the tail column of a BAT).
@end table

Both these problems are fixed in the new GDKqsort function, that
is based on the standard Berkeley qsort (see copyright notice below).

The routine was "monet"-ified with macro code expansions for the specific
data types to obtain extra speed (we know more about our data than the stdlib 
qsort() ever can).
@{
@c
#include "monetdb_config.h"
#include "gdk.h"

/*-
 * Copyright (c) 1992, 1993
 *      The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by the University of
 *      California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

@-
Record containing all data-specific info.
Introduced to reduce number of qsort parameters 
@c
typedef struct {
	int (*cmp) (ptr, ptr);	/* routine that compares two atoms */
	char *offst;		/* NULL or start of varsized heap */
	int hshift;		/* log2 of hs */
	int tshift;		/* log2 of hs */
	int vshift;		/* shift to be applied on var_ offsets */
	unsigned hs;		/* width of head record */
	unsigned ts;		/* width of tail record */
	void *h;		/* start of head buns */
	void *t;		/* start of tail buns */
} buf_t;

/* fast arithmetic on the record width */
#define MULT_WIDTH(d)	((d) << buf->hshift)
#define DIV_WIDTH(d)	((d) >> buf->hshift)
#define MULT_TS(d)	((d) << buf->tshift)

@= register_swap
/* fast record swapping */
#define @1_SWAP(TYPE, a, b, s)			\
	do {					\
		@1 *_pa = (@1 *) (a);		\
		@1 *_pb = (@1 *) (b);		\
		@1 _tmp = *_pa;			\
		*_pa = *_pb;			\
		*_pb = _tmp;			\
	} while (0)
#define direct_@1_SWAP(TYPE, a, b, s)			\
	@1_SWAP(TYPE, a, b, s)

#define offset_@1_SWAP(TYPE, a, b, s)	offset_any_SWAP(TYPE, a, b, s)

#define @1_multi_SWAP(TYPE, a, b, n, nt, s)		\
	tpe_SWAP(TYPE, a, b, n)

#define direct_@1_multi_SWAP(TYPE, a, b, n, nt, s)		\
	tpe_SWAP(TYPE, a, b, n)

#define offset_@1_multi_SWAP(TYPE, a, b, n, nt, s) offset_any_multi_SWAP(TYPE, a, b, n, nt, s)

@c
@:register_swap(chr)@
@:register_swap(bte)@
@:register_swap(sht)@
@:register_swap(int)@
@:register_swap(lng)@
@:register_swap(flt)@
@:register_swap(dbl)@

#define iterate_SWAP(TYPE, a, b, s) 		 tpe_SWAP(bte, a, b, s)
#define direct_any_SWAP(TYPE, a, b, s) 		 tpe_SWAP(bte, a, b, s)
#define offset_any_SWAP(TYPE, a, b, s)			\
	do {						\
		switch (s) {				\
		case 1: chr_SWAP(TYPE, a, b, s); break; \
		case 2: sht_SWAP(TYPE, a, b, s); break; \
		case 4: int_SWAP(TYPE, a, b, s); break; \
		case 8: lng_SWAP(TYPE, a, b, s); break; \
		default: assert(0);			\
		}					\
	} while (0)
#define iterate_multi_SWAP(TYPE, a, b, n, nt, s) tpe_SWAP(bte, a, b, nt)
#define direct_any_multi_SWAP(TYPE, a, b, n, nt, s) tpe_SWAP(bte, a, b, nt)
#define offset_any_multi_SWAP(TYPE, a, b, n, nt, s) 		\
	do {							\
		switch (s) {					\
		case 1: tpe_SWAP(chr, a, b, (nt)); break;	\
		case 2: tpe_SWAP(sht, a, b, (nt)>>1); break;	\
		case 4: tpe_SWAP(int, a, b, (nt)>>2); break;	\
		case 8: tpe_SWAP(lng, a, b, (nt)>>3); break;	\
		default: assert(0);				\
		}						\
	} while (0)

/* no swapping for voids */
#define void_SWAP(TYPE, a, b, s)
#define void_multi_SWAP(TYPE, a, b, n, nt, s)

#define tpe_SWAP(TYPE, a, b, n)			\
	do {					\
		ssize_t _i = (ssize_t) (n);	\
		TYPE *_pa = (TYPE*)(a);		\
		TYPE *_pb = (TYPE*)(b);		\
		while (--_i >= 0) {		\
			TYPE _tmp = *_pa;	\
			*_pa++ = *_pb;		\
			*_pb++ = _tmp;		\
		}				\
	} while (0)

@}
@-
qsort is macro expanded in four dimensions:
@table @samp
@item direction:2
	L: from lesser to greater is standard.
	G: from greater to lesser is the _rev version of quicksort.
@item type:7
	in order to factor out a type-specific check, or a function call for each 
	value comparison, we separate different qsort implementations by the comparison 
	type, of which each has the comparison hard-coded. We factor out the types 
	@{chr,bte,sht,int,wrd,flt,lng,dbl,any@} (the latter uses an adt function call).
@item storage:2
	denoted @{direct,offset@}, means whether the array to be sorted contains the 
	(fixed-width) values itself, or whether it contains integer byte-offsets, that point 
	into some heap. Note that we support byte-offset qsort also on fixed-size types, 
	as this is handy in many cases.
@item swapmethod:2
	qsort sorts an array by continually swapping entries. To do this, two
	implementations of the swap action are supported: @{iterate,register@}. 
	The default implementation takes the comparison type and does the swapping by 
	iterating a number of times per entry, copying one comparison value per iteration. 
	One often-occurring special case is when the entry width is 8 (two integers). These 
	can be copied by one long integer load and store; without the loop overhead.
@end table
Thus, there are 2 * 7 * 2 * 2 = 56 GDKqsort implementation routines.
@{
@c
#ifndef HAVE_PTRDIFF_T
#if SIZEOF_SIZE_T == SIZEOF_INT
typedef int ptrdiff_t;
#else
typedef lng ptrdiff_t;
#endif
#endif

#if SIZEOF_VAR_T == 8
#define offset(p)		(buf->offst + \
				 ((buf->hshift==0 ? (size_t)*(unsigned char*)(p)+GDK_VAROFFSET : \
				   (buf->hshift==1 ? (size_t)*(unsigned short*)(p)+GDK_VAROFFSET : \
				    (buf->hshift==2 ? (size_t)*(unsigned int*)(p) : \
				     (size_t)*(var_t*)(p)))) << buf->vshift))
#else
#define offset(p)		(buf->offst + \
				 ((buf->hshift==0 ? (size_t)*(unsigned char*)(p)+GDK_VAROFFSET : \
				   (buf->hshift==1 ? (size_t)*(unsigned short*)(p)+GDK_VAROFFSET : \
				    (size_t)*(var_t*)(p))) << buf->vshift))
#endif
#define direct(p)		(p)

#define any_LE(a,b)		((buf->cmp)(a,b) <= 0)
#define any_LT(a,b)		((buf->cmp)(a,b) <  0)
#define any_GE(a,b)		((buf->cmp)(a,b) >= 0)
#define any_GT(a,b)		((buf->cmp)(a,b) >  0)

@:qsort_L_or_G_direction(any)@

#ifndef NOEXPAND_CHR
@:qsort_cmpdef(chr)@
#endif
#ifndef NOEXPAND_BTE
@:qsort_cmpdef(bte)@
#endif
#ifndef NOEXPAND_SHT
@:qsort_cmpdef(sht)@
#endif
#ifndef NOEXPAND_INT
@:qsort_cmpdef(int)@
#endif
#ifndef NOEXPAND_FLT
@:qsort_cmpdef(flt)@
#endif
#ifndef NOEXPAND_DBL
@:qsort_cmpdef(dbl)@
#endif
#ifndef NOEXPAND_LNG
@:qsort_cmpdef(lng)@
#endif

@= qsort_cmpdef
#define @1_LE(a,b) (*(@1*) (a) <= *(@1*) (b))
#define @1_LT(a,b) (*(@1*) (a) <  *(@1*) (b))
#define @1_GE(a,b) (*(@1*) (a) >= *(@1*) (b))
#define @1_GT(a,b) (*(@1*) (a) >  *(@1*) (b))

@:qsort_L_or_G_direction(@1)@

@= qsort_L_or_G_direction
@:qsort_direct_or_offset_storage(@1,L)@
@:qsort_direct_or_offset_storage(@1,G,_rev)@

@= qsort_direct_or_offset_storage
#define @1_@2MED3(a,b,c,A,B,C)				\
	@1_@2T(a,b) ?					\
		(@1_@2T(b,c) ?				\
			(B):				\
			(@1_@2T(a,c) ?			\
				(C):			\
				(A))):			\
		(@1_@2T(c,b) ?				\
			(B):				\
			(@1_@2T(a,c) ?			\
				(A):			\
				(C)))

@:qsort_register_or_iterate_swapmethod(direct,@1,@2,@3)@
@:qsort_register_or_iterate_swapmethod(offset,@1,@2,@3)@

@= qsort_register_or_iterate_swapmethod
#define @1_@2_@3MED3(a,b,c,buf)	@2_@3MED3(@1(a),@1(b),@1(c),a,b,c)
#define @1_@2_@3T(a,b)		@2_@3T(@1(a),@1(b))
#define @1_@2_@3E(a,b)		@2_@3E(@1(a),@1(b))

@:qsort_algo(void,@1,@2,@3,@4)@
#ifndef NOEXPAND_BTE
@:qsort_algo(bte,@1,@2,@3,@4)@
#endif
#ifndef NOEXPAND_SHT
@:qsort_algo(sht,@1,@2,@3,@4)@
#endif
#ifndef NOEXPAND_INT
@:qsort_algo(int,@1,@2,@3,@4)@
#endif
#ifndef NOEXPAND_LNG
@:qsort_algo(lng,@1,@2,@3,@4)@
#endif
@:qsort_algo(iterate,@1,@2,@3,@4)@

@= qsort_algo
static void
GDKqsort_@1_@2_@3@5(char *h, char *t, size_t n, buf_t *buf)
{
	char *pa, *pb, *pc, *pd, *pl, *pm, *pn, *pmt, *plt;
	size_t r;
	int swap_cnt;

	/* Qsort routine from Bentley & McIlroy's "Engineering a Sort Function".  */
loop:
	swap_cnt = 0;
	if (n < 7) {
		for (pm = h + buf->hs, pmt = t + buf->ts; 
		     pm < h + MULT_WIDTH(n); 
		     pm += buf->hs, pmt += buf->ts) {
			for (pl = pm, plt = pmt; 
			     pl > h && @2_@3_@4E(pl, pl - buf->hs);
			     pl -= buf->hs, plt -= buf->ts) {
				@2_@3_SWAP(@3, pl, pl - buf->hs, buf->hs);
				@1_SWAP(@1, plt, plt - buf->ts, buf->ts);
			}
		}
		return;
	}
	pm = h + MULT_WIDTH(n >> 1);
	if (n > 7) {
		pl = h;
		pn = h + MULT_WIDTH(n - 1);
		if (n > 40) {
			size_t d;

			d = MULT_WIDTH(n >> 3);
			pl = @2_@3_@4MED3(pl, pl + d, pl + 2 * d, buf);
			pm = @2_@3_@4MED3(pm - d, pm, pm + d, buf);
			pn = @2_@3_@4MED3(pn - 2 * d, pn - d, pn, buf);
		}
		pm = @2_@3_@4MED3(pl, pm, pn, buf);
	}
	@2_@3_SWAP(@3, h, pm, buf->hs);
	@1_SWAP(@1, t, t+MULT_TS(DIV_WIDTH(pm-h)), buf->ts);
	pa = pb = h + buf->hs;
	pc = pd = h + MULT_WIDTH(n - 1);

	for (;;) {
		while (pb <= pc && @2_@3_@4E(pb, h)) {
			if (!@2_@3_@4T(pb, h)) { /* pb (<|>)= h && !(pb (<|>) h)  =>  pb == h */
				swap_cnt = 1;
				@2_@3_SWAP(@3, pa, pb, buf->hs);
				@1_SWAP(@1, 
					t+MULT_TS(DIV_WIDTH(pa-h)), 
					t+MULT_TS(DIV_WIDTH(pb-h)), 
					buf->ts);
				pa += buf->hs;
			}
			pb += buf->hs;
		}
		while (pb <= pc && @2_@3_@4E(h, pc)) {
			if (!@2_@3_@4T(h, pc)) { /* h (<|>)= pc && !(h (<|>) pc)  =>  h == pc */
				swap_cnt = 1;
				@2_@3_SWAP(@3, pc, pd, buf->hs);
				@1_SWAP(@1, 
					t+MULT_TS(DIV_WIDTH(pc-h)), 
					t+MULT_TS(DIV_WIDTH(pd-h)), 
					buf->ts);
				pd -= buf->hs;
			}
			pc -= buf->hs;
		}
		if (pb > pc) {
			break;
		}
		@2_@3_SWAP(@3, pb, pc, buf->hs);
		@1_SWAP(@1, 
			t+MULT_TS(DIV_WIDTH(pb-h)), 
			t+MULT_TS(DIV_WIDTH(pc-h)), 
			buf->ts);
		swap_cnt = 1;
		pb += buf->hs;
		pc -= buf->hs;
	}
	if (swap_cnt == 0 && n < 1024) {
		/* Switch to insertion sort, but only for small chucks */
		for (pm = h + buf->hs, pmt = t + buf->ts; 
		     pm < h + MULT_WIDTH(n); 
		     pm += buf->hs, pmt += buf->ts) {
			for (pl = pm, plt = pmt; 
			     pl > h && @2_@3_@4E(pl, pl - buf->hs);
			     pl -= buf->hs, plt -= buf->ts) {
				@2_@3_SWAP(@3, pl, pl - buf->hs, buf->hs);
				@1_SWAP(@1, plt, plt - buf->ts, buf->ts);
			}
		}
		return;
	}

	pn = h + MULT_WIDTH(n);
	r = MIN(pa - h, pb - pa);
	@2_@3_multi_SWAP(@3, h, pb - r, DIV_WIDTH(r), r, buf->hs);
	@1_multi_SWAP(@1, t, t+MULT_TS(DIV_WIDTH(pb-r-h)), DIV_WIDTH(r), MULT_TS(DIV_WIDTH(r)), buf->ts);
	r = MIN(pd - pc, (ptrdiff_t) (pn - pd - buf->hs));
	@2_@3_multi_SWAP(@3, pb, pn - r, DIV_WIDTH(r), r, buf->hs);
	@1_multi_SWAP(@1, t+MULT_TS(DIV_WIDTH(pb-h)), t+MULT_TS(DIV_WIDTH(pn-r-h)), DIV_WIDTH(r), MULT_TS(DIV_WIDTH(r)), buf->ts);
	if ((r = pb - pa) > buf->hs)
		GDKqsort_@1_@2_@3@5(h, t, DIV_WIDTH(r), buf);
	if ((r = pd - pc) > buf->hs) { 
		/* Iterate rather than recurse to save stack space */
		t = t+MULT_TS(DIV_WIDTH(pn-r-h));
		h = pn - r;
		n = DIV_WIDTH(r);
		goto loop;
	}
}

@= call_offset_or_direct_storage
	/* factorization by storage mode */
	if (base) {
		GDKqsort_@3_offset_@2@1(h, t, n, &buf); /* array of var_t, that are byte-offsets from some base */
	} else {
		GDKqsort_@3_direct_@2@1(h, t, n, &buf); /* array of fixed-size values */
	} 
	break;

@= call_iterate_or_register_swapmethod
	switch (ts) {
	case 0:
		@:call_offset_or_direct_storage(@1,@2,void)@
#ifndef NOEXPAND_BTE
	case 1:
		@:call_offset_or_direct_storage(@1,@2,bte)@
#endif
#ifndef NOEXPAND_SHT
	case 2:
		@:call_offset_or_direct_storage(@1,@2,sht)@
#endif
#ifndef NOEXPAND_INT
	case 4:
		@:call_offset_or_direct_storage(@1,@2,int)@
#endif
#ifndef NOEXPAND_LNG
	case 8:
		@:call_offset_or_direct_storage(@1,@2,lng)@
#endif
	default:
		@:call_offset_or_direct_storage(@1,@2,iterate)@
	}
	break;

@= qsort
void
GDKqsort@1(void *h, void *t, void* base, size_t n, int hs, int ts, int tpe)
{
	char x;
	buf_t buf;

	assert(tpe != TYPE_void);

	/* init the qsort record */
	buf.cmp = BATatoms[tpe].atomCmp;
	buf.offst = base;
	buf.hs = (unsigned) hs;
	buf.ts = (unsigned) ts;
	buf.hshift = ATOMelmshift(hs);
	buf.tshift = ATOMelmshift(ts);
	assert_shift_width(buf.hshift,buf.hs);
	assert_shift_width(buf.tshift,buf.ts);
	buf.vshift = ATOMvarsized(tpe)?GDK_VARSHIFT:0;
	buf.h = h;
	if (!t)
		t = &x;
	buf.t = t;

	/* factorization by comparsion type */
	switch (ATOMstorage(tpe)) {
#ifndef NOEXPAND_CHR
	case TYPE_chr:
		@:call_iterate_or_register_swapmethod(@1,chr)@
#endif
#ifndef NOEXPAND_BTE
	case TYPE_bte:
		@:call_iterate_or_register_swapmethod(@1,bte)@
#endif
#ifndef NOEXPAND_SHT
	case TYPE_sht:
		@:call_iterate_or_register_swapmethod(@1,sht)@
#endif
#ifndef NOEXPAND_INT
	case TYPE_int:
		@:call_iterate_or_register_swapmethod(@1,int)@
#endif
#ifndef NOEXPAND_FLT
	case TYPE_flt:
		@:call_iterate_or_register_swapmethod(@1,flt)@
#endif
#ifndef NOEXPAND_LNG
	case TYPE_lng:
		@:call_iterate_or_register_swapmethod(@1,lng)@
#endif
#ifndef NOEXPAND_DBL
	case TYPE_dbl:
		@:call_iterate_or_register_swapmethod(@1,dbl)@
#endif
	default:
		@:call_iterate_or_register_swapmethod(@1,any)@
	}
}
@c
@:qsort()@
@:qsort(_rev)@

@}
