@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2006 CWI.
@' All Rights Reserved.

@f gdk_ssort
@a Sjoerd Mullender
@* Ssort
This file implements a stable sort algorithm.  The algorithm is a
straight copy of the listsort function in the Python 2.5 source code,
heavily modified to fit into the MonetDB environment.
@{
@c
#include "gdk.h"

/* The maximum number of entries in a MergeState's pending-runs stack.
   This is enough to sort arrays of size up to about
       32 * phi ** MAX_MERGE_PENDING
   where phi ~= 1.618.  85 is ridiculously large enough, good for an array
   with 2**64 elements. */
#define MAX_MERGE_PENDING 85

/* When we get into galloping mode, we stay there until both runs win less
   often than MIN_GALLOP consecutive times.  See listsort.txt for more info. */
#define MIN_GALLOP 7

/* Avoid malloc for small temp arrays. */
#define MERGESTATE_TEMP_SIZE (256 * sizeof(void *))

/* One MergeState exists on the stack per invocation of mergesort.  It's just
   a convenient way to pass state around among the helper functions. */
struct slice {
	void *base;
	ssize_t len;
};

typedef struct {
	/* The comparison function. */
	int (*compare)(ptr, ptr);
	char *base;
	int width;
	int loc;
	int reverse;
	/* Temporary storage for a single entry. If an entry is at
	   most 2 lng's, we don't need to allocate anything. */
	void *t;
	char tempstorage[2 * sizeof(lng)];

	/* This controls when we get *into* galloping mode.  It's
	   initialized to MIN_GALLOP.  merge_lo and merge_hi tend to
	   nudge it higher for random data, and lower for highly
	   structured data. */
	ssize_t min_gallop;

	/* 'a' is temp storage to help with merges.  It contains room
	   for alloced entries. */
	void **a;
	ssize_t alloced;

	/* A stack of n pending runs yet to be merged.  Run #i starts
	   at address base[i] and extends for len[i] elements.  It's
	   always true (so long as the indices are in bounds) that

		pending[i].base + pending[i].len == pending[i+1].base

	   so we could cut the storage for this, but it's a minor
	   amount, and keeping all the info explicit simplifies the
	   code. */
	int n;
	struct slice pending[MAX_MERGE_PENDING];

	/* 'a' points to this when possible, rather than muck with
	   malloc. */
	char temparray[MERGESTATE_TEMP_SIZE];
} MergeState;

/* Free all the temp memory owned by the MergeState.  This must be called
   when you're done with a MergeState, and may be called before then if
   you want to free the temp memory early. */
static void
merge_freemem(MergeState *ms)
{
	assert(ms != NULL);
	if (ms->a != (void *) ms->temparray)
		GDKfree(ms->a);
	ms->a = (void *) ms->temparray;
	ms->alloced = MERGESTATE_TEMP_SIZE;
}

/* Ensure enough temp memory for 'need' array slots is available.
   Returns 0 on success and -1 if the memory can't be gotten. */
static int
merge_getmem(MergeState *ms, ssize_t need)
{
	assert(ms != NULL);
	need *= ms->width;
	if (need <= ms->alloced)
		return 0;
	/* Don't realloc!  That can cost cycles to copy the old data, but
	   we don't care what's in the block.
	 */
	merge_freemem(ms);
	ms->a = GDKmalloc(need);
	if (ms->a) {
		ms->alloced = need;
		return 0;
	}
	GDKerror("GDKssort: not enough memory\n");
	merge_freemem(ms);	/* reset to sane state */
	return -1;
}

#define COPY(d,s,w) do {				\
		switch (w) {				\
		case sizeof(chr):			\
			* (chr *) d = * (chr *) s;	\
			break;				\
		case sizeof(sht):			\
			* (sht *) d = * (sht *) s;	\
			break;				\
		case sizeof(int):			\
			* (int *) d = * (int *) s;	\
			break;				\
		case sizeof(lng):			\
			* (lng *) d = * (lng *) s;	\
			break;				\
		default:				\
			memcpy(d, s, (size_t) w);	\
			break;				\
		}					\
	} while (0)
#define PTRADD(p, n, w)		(void *) ((char *) (p) + (n) * (w))

/* Reverse a slice of a list in place, from lo up to (exclusive) hi. */
static void
reverse_slice(void *lo, void *hi, MergeState *ms)
{
	void *t;
	int width;

	assert(lo && hi);
	assert(ms);

	t = ms->t;
	width = ms->width;

	hi = PTRADD(hi, -1, width);
	while (lo < hi) {
		COPY(t, lo, width);
		COPY(lo, hi, width);
		COPY(hi, t, width);
		lo = PTRADD(lo, 1, width);
		hi = PTRADD(hi, -1, width);
	}
}

#define ISLT(X, Y)  (ms->reverse ? ((ms->base ? (*ms->compare)(ms->base + * (var_t *) PTRADD((X), ms->loc, 1), ms->base + * (var_t *) PTRADD((Y), ms->loc, 1)) : (*ms->compare)(PTRADD((X), ms->loc, 1), PTRADD((Y), ms->loc, 1))) > 0) : ((ms->base ? (*ms->compare)(ms->base + * (var_t *) PTRADD((X), ms->loc, 1), ms->base + * (var_t *) PTRADD((Y), ms->loc, 1)) : (*ms->compare)(PTRADD((X), ms->loc, 1), PTRADD((Y), ms->loc, 1))) < 0))

/* binarysort is the best method for sorting small arrays: it does
   few compares, but can do data movement quadratic in the number of
   elements.
   [lo, hi) is a contiguous slice of a list, and is sorted via
   binary insertion.  This sort is stable.
   On entry, must have lo <= start <= hi, and that [lo, start) is already
   sorted (pass start == lo if you don't know!). */
static void
binarysort(void *lo, void *hi, void *start, MergeState *ms)
{
	register void *l, *p, *r;

	assert(lo <= start && start <= hi);
	/* assert [lo, start) is sorted */
	if (lo == start)
		start = PTRADD(start, 1, ms->width);
	/* [lo,start) is sorted, insert start (the pivot) into this
	   area, finding its position using binary search. */
	for (; start < hi; start = PTRADD(start, 1, ms->width)) {
		/* set l to where start belongs */
		l = lo;
		r = start;
		/* ms->t is the pivot */
		COPY(ms->t, r, ms->width);
		/* Invariants:
		   pivot >= all in [lo, l).
		   pivot  < all in [r, start).
		   The second is vacuously true at the start.
		 */
		assert(l < r);
		do {
			p = PTRADD(l, (((char *) r - (char *) l) / ms->width) >> 1, ms->width);
			if (ISLT(ms->t, p))
				r = p;
			else
				l = PTRADD(p, 1, ms->width);
		} while (l < r);
		assert(l == r);
		/* The invariants still hold, so pivot >= all in [lo, l) and
		   pivot < all in [l, start), so pivot belongs at l.  Note
		   that if there are elements equal to pivot, l points to the
		   first slot after them -- that's why this sort is stable.
		   Slide over to make room.
		   Caution: using memmove is much slower under MSVC 5;
		   we're not usually moving many slots. */
		for (p = start, r = PTRADD(p, -1, ms->width); p > l; p = r, r = PTRADD(p, -1, ms->width))
			COPY(p, r, ms->width);
		COPY(l, ms->t, ms->width);
	}
}

/* Return the length of the run beginning at lo, in the slice [lo,
   hi).  lo < hi is required on entry.  "A run" is the longest
   ascending sequence, with

	lo[0] <= lo[1] <= lo[2] <= ...

   or the longest descending sequence, with

	lo[0] > lo[1] > lo[2] > ...

   Boolean *descending is set to 0 in the former  case, or to 1 in the
   latter.  For its intended use in a stable mergesort, the strictness
   of the defn of "descending" is needed so that the caller can safely
   reverse a descending sequence without violating stability (strict >
   ensures there are no equal elements to get out of order).

   Returns -1 in case of error. */
static ssize_t
count_run(void *lo, void *hi, MergeState *ms, int *descending)
{
	ssize_t n;
	void *olo;		/* "old" lo, i.e. lo-1 */

	assert(lo < hi);
	*descending = 0;
	olo = lo;
	lo = PTRADD(lo, 1, ms->width);
	if (lo == hi)
		return 1;

	n = 2;
	if (ISLT(lo, olo)) {
		*descending = 1;
		for (olo = lo, lo = PTRADD(lo, 1, ms->width);
		     lo < hi;
		     olo = lo, lo = PTRADD(lo, 1, ms->width), ++n) {
			if (!ISLT(lo, olo))
				break;
		}
	}
	else {
		for (olo = lo, lo = PTRADD(lo, 1, ms->width);
		     lo < hi;
		     olo = lo, lo = PTRADD(lo, 1, ms->width), ++n) {
			if (ISLT(lo, olo))
				break;
		}
	}

	return n;
}

/* Locate the proper position of key in a sorted vector; if the vector contains
   an element equal to key, return the position immediately to the left of
   the leftmost equal element.  [gallop_right() does the same except returns
   the position to the right of the rightmost equal element (if any).]

   "a" is a sorted vector with n elements, starting at a[0].  n must be > 0.

   "hint" is an index at which to begin the search, 0 <= hint < n.  The closer
   hint is to the final result, the faster this runs.

   The return value is the int k in 0..n such that

	a[k-1] < key <= a[k]

   pretending that *(a-1) is minus infinity and a[n] is plus infinity.  IOW,
   key belongs at index k; or, IOW, the first k elements of a should precede
   key, and the last n-k should follow key.

   Returns -1 on error.  See listsort.txt for info on the method. */
static ssize_t
gallop_left(void *key, void *a, ssize_t n, ssize_t hint, MergeState *ms)
{
	ssize_t ofs;
	ssize_t lastofs;
	ssize_t k;

	assert(key && a && n > 0 && hint >= 0 && hint < n);

	a = PTRADD(a, hint, ms->width);
	lastofs = 0;
	ofs = 1;
	if (ISLT(a, key)) {
		/* a[hint] < key -- gallop right, until
		   a[hint + lastofs] < key <= a[hint + ofs]
		 */
		const ssize_t maxofs = n - hint;	/* &a[n-1] is highest */
		while (ofs < maxofs) {
			if (ISLT(PTRADD(a, ofs, ms->width), key)) {
				lastofs = ofs;
				ofs = (ofs << 1) + 1;
				if (ofs <= 0)	/* int overflow */
					ofs = maxofs;
			} else	/* key <= a[hint + ofs] */
				break;
		}
		if (ofs > maxofs)
			ofs = maxofs;
		/* Translate back to offsets relative to &a[0]. */
		lastofs += hint;
		ofs += hint;
	} else {
		/* key <= a[hint] -- gallop left, until
		   a[hint - ofs] < key <= a[hint - lastofs]
		 */
		const ssize_t maxofs = hint + 1;	/* &a[0] is lowest */
		while (ofs < maxofs) {
			if (ISLT(PTRADD(a, -ofs, ms->width), key))
				break;
			/* key <= a[hint - ofs] */
			lastofs = ofs;
			ofs = (ofs << 1) + 1;
			if (ofs <= 0)	/* int overflow */
				ofs = maxofs;
		}
		if (ofs > maxofs)
			ofs = maxofs;
		/* Translate back to positive offsets relative to &a[0]. */
		k = lastofs;
		lastofs = hint - ofs;
		ofs = hint - k;
	}
	a = PTRADD(a, -hint, ms->width);

	assert(-1 <= lastofs && lastofs < ofs && ofs <= n);
	/* Now a[lastofs] < key <= a[ofs], so key belongs somewhere to the
	   right of lastofs but no farther right than ofs.  Do a binary
	   search, with invariant a[lastofs-1] < key <= a[ofs].
	 */
	++lastofs;
	while (lastofs < ofs) {
		ssize_t m = lastofs + ((ofs - lastofs) >> 1);

		if (ISLT(PTRADD(a, m, ms->width), key))
			lastofs = m + 1; /* a[m] < key */
		else
			ofs = m;	/* key <= a[m] */
	}
	assert(lastofs == ofs);		/* so a[ofs-1] < key <= a[ofs] */
	return ofs;
}

/* Exactly like gallop_left(), except that if key already exists in a[0:n],
   finds the position immediately to the right of the rightmost equal value.

   The return value is the int k in 0..n such that

	a[k-1] <= key < a[k]

   or -1 if error.

   The code duplication is massive, but this is enough different given that
   we're sticking to "<" comparisons that it's much harder to follow if
   written as one routine with yet another "left or right?" flag. */
static ssize_t
gallop_right(void *key, void *a, ssize_t n, ssize_t hint, MergeState *ms)
{
	ssize_t ofs;
	ssize_t lastofs;
	ssize_t k;

	assert(key && a && n > 0 && hint >= 0 && hint < n);

	a = PTRADD(a, hint, ms->width);
	lastofs = 0;
	ofs = 1;
	if (ISLT(key, a)) {
		/* key < a[hint] -- gallop left, until
		   a[hint - ofs] <= key < a[hint - lastofs]
		 */
		const ssize_t maxofs = hint + 1;	/* &a[0] is lowest */
		while (ofs < maxofs) {
			if (ISLT(key, PTRADD(a, -ofs, ms->width))) {
				lastofs = ofs;
				ofs = (ofs << 1) + 1;
				if (ofs <= 0)	/* int overflow */
					ofs = maxofs;
			} else	/* a[hint - ofs] <= key */
				break;
		}
		if (ofs > maxofs)
			ofs = maxofs;
		/* Translate back to positive offsets relative to &a[0]. */
		k = lastofs;
		lastofs = hint - ofs;
		ofs = hint - k;
	} else {
		/* a[hint] <= key -- gallop right, until
		   a[hint + lastofs] <= key < a[hint + ofs]
		*/
		const ssize_t maxofs = n - hint;	/* &a[n-1] is highest */
		while (ofs < maxofs) {
			if (ISLT(key, PTRADD(a, ofs, ms->width)))
				break;
			/* a[hint + ofs] <= key */
			lastofs = ofs;
			ofs = (ofs << 1) + 1;
			if (ofs <= 0)	/* int overflow */
				ofs = maxofs;
		}
		if (ofs > maxofs)
			ofs = maxofs;
		/* Translate back to offsets relative to &a[0]. */
		lastofs += hint;
		ofs += hint;
	}
	a = PTRADD(a, -hint, ms->width);

	assert(-1 <= lastofs && lastofs < ofs && ofs <= n);
	/* Now a[lastofs] <= key < a[ofs], so key belongs somewhere to the
	   right of lastofs but no farther right than ofs.  Do a binary
	   search, with invariant a[lastofs-1] <= key < a[ofs].
	 */
	++lastofs;
	while (lastofs < ofs) {
		ssize_t m = lastofs + ((ofs - lastofs) >> 1);

		if (ISLT(key, PTRADD(a, m, ms->width)))
			ofs = m;	/* key < a[m] */
		else
			lastofs = m+1;	/* a[m] <= key */
	}
	assert(lastofs == ofs);		/* so a[ofs-1] <= key < a[ofs] */
	return ofs;
}

#define MERGE_GETMEM(MS, NEED) ((NEED) * (MS)->width <= (MS)->alloced ? 0 :	\
				merge_getmem(MS, NEED))

/* Merge the na elements starting at pa with the nb elements starting at pb
   in a stable way, in-place.  na and nb must be > 0, and pa + na == pb.
   Must also have that *pb < *pa, that pa[na-1] belongs at the end of the
   merge, and should have na <= nb.  See listsort.txt for more info.
   Return 0 if successful, -1 if error. */
static ssize_t
merge_lo(MergeState *ms, void *pa, ssize_t na, void *pb, ssize_t nb)
{
	ssize_t k;
	void *dest;
	ssize_t min_gallop = ms->min_gallop;

	assert(ms && pa && pb && na > 0 && nb > 0 && pa + na == pb);
	if (MERGE_GETMEM(ms, na) < 0)
		return -1;
	memcpy(ms->a, pa, na * ms->width);
	dest = pa;
	pa = ms->a;

	COPY(dest, pb, ms->width);
	dest = PTRADD(dest, 1, ms->width);
	pb = PTRADD(pb, 1, ms->width);
	--nb;
	if (nb == 0)
		goto Succeed;
	if (na == 1)
		goto CopyB;

	for (;;) {
		ssize_t acount = 0;	/* # of times A won in a row */
		ssize_t bcount = 0;	/* # of times B won in a row */

		/* Do the straightforward thing until (if ever) one run
		   appears to win consistently.
		 */
 		for (;;) {
 			assert(na > 1 && nb > 0);
	 		k = ISLT(pb, pa);
			if (k) {
				COPY(dest, pb, ms->width);
				dest = PTRADD(dest, 1, ms->width);
				pb = PTRADD(pb, 1, ms->width);
				++bcount;
				acount = 0;
				--nb;
				if (nb == 0)
					goto Succeed;
				if (bcount >= min_gallop)
					break;
			} else {
				COPY(dest, pa, ms->width);
				dest = PTRADD(dest, 1, ms->width);
				pa = PTRADD(pa, 1, ms->width);
				++acount;
				bcount = 0;
				--na;
				if (na == 1)
					goto CopyB;
				if (acount >= min_gallop)
					break;
			}
 		}

		/* One run is winning so consistently that galloping may
		   be a huge win.  So try that, and continue galloping until
		   (if ever) neither run appears to be winning consistently
		   anymore.
		 */
		++min_gallop;
		do {
 			assert(na > 1 && nb > 0);
			min_gallop -= min_gallop > 1;
	 		ms->min_gallop = min_gallop;
			k = gallop_right(pb, pa, na, 0, ms);
			acount = k;
			if (k) {
				memcpy(dest, pa, k * ms->width);
				dest = PTRADD(dest, k, ms->width);
				pa = PTRADD(pa, k, ms->width);
				na -= k;
				if (na == 1)
					goto CopyB;
				/* na==0 is impossible now if the comparison
				   function is consistent, but we can't assume
				   that it is.
				 */
				if (na == 0)
					goto Succeed;
			}
			COPY(dest, pb, ms->width);
			dest = PTRADD(dest, 1, ms->width);
			pb = PTRADD(pb, 1, ms->width);
			--nb;
			if (nb == 0)
				goto Succeed;

 			k = gallop_left(pa, pb, nb, 0, ms);
 			bcount = k;
			if (k) {
				memmove(dest, pb, k * ms->width);
				dest = PTRADD(dest, k, ms->width);
				pb = PTRADD(pb, k, ms->width);
				nb -= k;
				if (nb == 0)
					goto Succeed;
			}
			COPY(dest, pa, ms->width);
			dest = PTRADD(dest, 1, ms->width);
			pa = PTRADD(pa, 1, ms->width);
			--na;
			if (na == 1)
				goto CopyB;
 		} while (acount >= MIN_GALLOP || bcount >= MIN_GALLOP);
 		++min_gallop;	/* penalize it for leaving galloping mode */
 		ms->min_gallop = min_gallop;
 	}
Succeed:
	if (na)
		memcpy(dest, pa, na * ms->width);
	return 0;
CopyB:
	assert(na == 1 && nb > 0);
	/* The last element of pa belongs at the end of the merge. */
	memmove(dest, pb, nb * ms->width);
	COPY(PTRADD(dest, nb, ms->width), pa, ms->width);
	return 0;
}

/* Merge the na elements starting at pa with the nb elements starting at pb
   in a stable way, in-place.  na and nb must be > 0, and pa + na == pb.
   Must also have that *pb < *pa, that pa[na-1] belongs at the end of the
   merge, and should have na >= nb.  See listsort.txt for more info.
   Return 0 if successful, -1 if error. */
static ssize_t
merge_hi(MergeState *ms, void *pa, ssize_t na, void *pb, ssize_t nb)
{
	ssize_t k;
	void *dest;
	void *basea;
	void *baseb;
	ssize_t min_gallop = ms->min_gallop;

	assert(ms && pa && pb && na > 0 && nb > 0 && PTRADD(pa, na, ms->width) == pb);
	if (MERGE_GETMEM(ms, nb) < 0)
		return -1;
	dest = PTRADD(pb, nb - 1, ms->width);
	memcpy(ms->a, pb, nb * ms->width);
	basea = pa;
	baseb = ms->a;
	pb = PTRADD(ms->a, nb - 1, ms->width);
	pa = PTRADD(pa, na - 1, ms->width);

	COPY(dest, pa, ms->width);
	dest = PTRADD(dest, -1, ms->width);
	pa = PTRADD(pa, -1, ms->width);
	--na;
	if (na == 0)
		goto Succeed;
	if (nb == 1)
		goto CopyA;

	for (;;) {
		ssize_t acount = 0;	/* # of times A won in a row */
		ssize_t bcount = 0;	/* # of times B won in a row */

		/* Do the straightforward thing until (if ever) one run
		   appears to win consistently.
		 */
 		for (;;) {
 			assert(na > 0 && nb > 1);
	 		k = ISLT(pb, pa);
			if (k) {
				COPY(dest, pa, ms->width);
				dest = PTRADD(dest, -1, ms->width);
				pa = PTRADD(pa, -1, ms->width);
				++acount;
				bcount = 0;
				--na;
				if (na == 0)
					goto Succeed;
				if (acount >= min_gallop)
					break;
			} else {
				COPY(dest, pb, ms->width);
				dest = PTRADD(dest, -1, ms->width);
				pb = PTRADD(pb, -1, ms->width);
				++bcount;
				acount = 0;
				--nb;
				if (nb == 1)
					goto CopyA;
				if (bcount >= min_gallop)
					break;
			}
 		}

		/* One run is winning so consistently that galloping may
		   be a huge win.  So try that, and continue galloping until
		   (if ever) neither run appears to be winning consistently
		   anymore.
		 */
		++min_gallop;
		do {
 			assert(na > 0 && nb > 1);
			min_gallop -= min_gallop > 1;
	 		ms->min_gallop = min_gallop;
			k = gallop_right(pb, basea, na, na - 1, ms);
			k = na - k;
			acount = k;
			if (k) {
				dest = PTRADD(dest, -k, ms->width);
				pa = PTRADD(pa, -k, ms->width);
				memmove(PTRADD(dest, 1, ms->width),
					PTRADD(pa, 1, ms->width),
					k * ms->width);
				na -= k;
				if (na == 0)
					goto Succeed;
			}
			COPY(dest, pb, ms->width);
			dest = PTRADD(dest, -1, ms->width);
			pb = PTRADD(pb, -1, ms->width);
			--nb;
			if (nb == 1)
				goto CopyA;

 			k = gallop_left(pa, baseb, nb, nb - 1, ms);
			k = nb - k;
			bcount = k;
			if (k) {
				dest = PTRADD(dest, -k, ms->width);
				pb = PTRADD(pb, -k, ms->width);
				memmove(PTRADD(dest, 1, ms->width),
					PTRADD(pb, 1, ms->width),
					k * ms->width);
				nb -= k;
				if (nb == 1)
					goto CopyA;
				/* nb==0 is impossible now if the comparison
				   function is consistent, but we can't assume
				   that it is.
				 */
				if (nb == 0)
					goto Succeed;
			}
			COPY(dest, pa, ms->width);
			dest = PTRADD(dest, -1, ms->width);
			pa = PTRADD(pa, -1, ms->width);
			--na;
			if (na == 0)
				goto Succeed;
 		} while (acount >= MIN_GALLOP || bcount >= MIN_GALLOP);
 		++min_gallop;	/* penalize it for leaving galloping mode */
 		ms->min_gallop = min_gallop;
 	}
Succeed:
	if (nb)
		memcpy(PTRADD(dest, 1 - nb, ms->width), baseb, nb * ms->width);
	return 0;
CopyA:
	assert(nb == 1 && na > 0);
	/* The first element of pb belongs at the front of the merge. */
	dest = PTRADD(dest, -na, ms->width);
	pa = PTRADD(pa, -na, ms->width);
	memmove(PTRADD(dest, 1, ms->width),
		PTRADD(pa, 1, ms->width),
		na * ms->width);
	COPY(dest, pb, ms->width);
	return 0;
}

/* Merge the two runs at stack indices i and i+1.
   Returns 0 on success, -1 on error. */
static ssize_t
merge_at(MergeState *ms, ssize_t i)
{
	void *pa, *pb;
	ssize_t na, nb;
	ssize_t k;

	assert(ms != NULL);
	assert(ms->n >= 2);
	assert(i >= 0);
	assert(i == ms->n - 2 || i == ms->n - 3);

	pa = ms->pending[i].base;
	na = ms->pending[i].len;
	pb = ms->pending[i + 1].base;
	nb = ms->pending[i + 1].len;
	assert(na > 0 && nb > 0);
	assert(PTRADD(pa, na, ms->width) == pb);

	/* Record the length of the combined runs; if i is the 3rd-last
	   run now, also slide over the last run (which isn't involved
	   in this merge).  The current run i+1 goes away in any case.
	 */
	ms->pending[i].len = na + nb;
	if (i == ms->n - 3)
		ms->pending[i + 1] = ms->pending[i + 2];
	--ms->n;

	/* Where does b start in a?  Elements in a before that can be
	   ignored (already in place).
	 */
	k = gallop_right(pb, pa, na, 0, ms);
	pa = PTRADD(pa, k, ms->width);
	na -= k;
	if (na == 0)
		return 0;

	/* Where does a end in b?  Elements in b after that can be
	   ignored (already in place).
	 */
	nb = gallop_left(PTRADD(pa, na - 1, ms->width), pb, nb, nb-1, ms);
	if (nb <= 0)
		return nb;

	/* Merge what remains of the runs, using a temp array with
	   min(na, nb) elements.
	 */
	if (na <= nb)
		return merge_lo(ms, pa, na, pb, nb);
	else
		return merge_hi(ms, pa, na, pb, nb);
}

/* Examine the stack of runs waiting to be merged, merging adjacent runs
   until the stack invariants are re-established:

   1. len[-3] > len[-2] + len[-1]
   2. len[-2] > len[-1]

   See listsort.txt for more info.

   Returns 0 on success, -1 on error. */
static int
merge_collapse(MergeState *ms)
{
	struct slice *p = ms->pending;

	assert(ms);
	while (ms->n > 1) {
		ssize_t n = ms->n - 2;

		if (n > 0 && p[n - 1].len <= p[n].len + p[n + 1].len) {
		    	if (p[n - 1].len < p[n + 1].len)
		    		--n;
			if (merge_at(ms, n) < 0)
				return -1;
		} else if (p[n].len <= p[n + 1].len) {
			 if (merge_at(ms, n) < 0)
			 	return -1;
		} else
			break;
	}
	return 0;
}

/* Regardless of invariants, merge all runs on the stack until only one
   remains.  This is used at the end of the mergesort.

   Returns 0 on success, -1 on error. */
static int
merge_force_collapse(MergeState *ms)
{
	struct slice *p = ms->pending;

	assert(ms);
	while (ms->n > 1) {
		ssize_t n = ms->n - 2;

		if (n > 0 && p[n - 1].len < p[n + 1].len)
			--n;
		if (merge_at(ms, n) < 0)
			return -1;
	}
	return 0;
}

static ssize_t
merge_compute_minrun(ssize_t n)
{
	ssize_t r = 0;		/* becomes 1 if any 1 bits are shifted off */

	assert(n >= 0);
	while (n >= 64) {
		r |= n & 1;
		n >>= 1;
	}
	return n + r;
}

/* Stable sort an array "a".  If "reverse" is true, sorts on
   descending key values, otherwise on ascending key values.
   "nitems" is the number of items to sort; "width" is the size of the
   items, "tpe" is the type of the key within the items, "loc" is the
   location (offset) of the key within the item.  If "base" is
   non-NULL, the key is actually an offset relative to "base" and the
   actual key is found at that offset (MonetDB var-sized atoms).
 */
int
GDKssort(void *a, void *base, size_t nitems, int width, int tpe, int loc, int reverse)
{
	MergeState ms;
	ssize_t nremaining;
	int result = -1;
	void *lo, *hi;
	ssize_t minrun;

	assert(a);
	assert(width > 0);
	assert(0 <= loc && loc < width);

	ms.a = (void *) ms.temparray;
	ms.alloced = MERGESTATE_TEMP_SIZE;
	ms.n = 0;
	ms.min_gallop = MIN_GALLOP;
	ms.compare = BATatoms[tpe].atomCmp;
	ms.base = base;
	ms.width = width;
	ms.loc = loc;
	ms.reverse = reverse;
	ms.t = (size_t) width <= sizeof(ms.tempstorage) ? ms.tempstorage : alloca(width);

	nremaining = nitems;

	if (nremaining < 2)
		goto succeed;

	/* March over the array once, left to right, finding natural
	   runs, and extending short natural runs to minrun
	   elements. */
	lo = a;
	hi = PTRADD(lo, nremaining, width);
	minrun = merge_compute_minrun(nremaining);
	do {
		int descending;
		ssize_t n;

		/* Identify next run. */
		n = count_run(lo, hi, &ms, &descending);
		if (descending)
			reverse_slice(lo, PTRADD(lo, n, ms.width), &ms);
		/* If short, extend to min(minrun, nremaining). */
		if (n < minrun) {
			ssize_t force = nremaining <= minrun ? nremaining : minrun;

			binarysort(lo, PTRADD(lo, force, width), PTRADD(lo, n, width), &ms);
			n = force;
		}
		/* Push run onto pending-runs stack, and maybe merge. */
		assert(ms.n < MAX_MERGE_PENDING);
		ms.pending[ms.n].base = lo;
		ms.pending[ms.n].len = n;
		ms.n++;
		if (merge_collapse(&ms) < 0)
			goto fail;
		/* Advance to find next run. */
		lo = PTRADD(lo, n, width);
		nremaining -= n;
	} while (nremaining > 0);
	assert(lo == hi);

	if (merge_force_collapse(&ms) < 0)
		goto fail;
	assert(ms.n == 1);
	assert(ms.pending[0].base == a);
	assert(ms.pending[0].len == (ssize_t) nitems);

  succeed:
	result = 0;
  fail:
	merge_freemem(&ms);
	return result;
}
@}
