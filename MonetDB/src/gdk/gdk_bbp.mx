@/
The contents of this file are subject to the MonetDB Public License
Version 1.1 (the "License"); you may not use this file except in
compliance with the License. You may obtain a copy of the License at
http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html

Software distributed under the License is distributed on an "AS IS"
basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations
under the License.

The Original Code is the MonetDB Database System.

The Initial Developer of the Original Code is CWI.
Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
Copyright August 2008-2011 MonetDB B.V.
All Rights Reserved.
@

@f gdk_bbp
@a M. L. Kersten, P. Boncz, N. J. Nes
@* BAT Buffer Pool (BBP)
The BATs created and loaded are collected in a BAT buffer pool.
The Bat Buffer Pool has a number of functions:
@table @code

@item administration and lookup
The BBP is a directory which contains status information about all known BATs.
This interface may be used very heavily, by data-intensive applications.
To eliminate all overhead, read-only access to the BBP may be done by
table-lookups. The integer index type for these lookups is @emph{bat}, as
retrieved by @emph{BBPcacheid(b)}. The @emph{bat} zero is reserved for the nil bat.

@item persistence
The BBP is made persistent by saving it to the dictionary file
called @emph{BBP.dir} in the database.

When the number of BATs rises, having all files in one directory
becomes a bottleneck.  The BBP therefore implements a scheme that distributes
all BATs in a growing directory tree with at most 64 BATs stored in one node.

@item buffer management
The BBP is responsible for loading and saving of BATs to disk. It also
contains routines to unload BATs from memory when memory resources
get scarce. For this purpose, it administers BAT memory reference
counts (to know which BATs can be unloaded) and BAT usage statistics
(it unloads the least recently used BATs).

@item recovery
When the database is closed or during a run-time syncpoint, the system
tables must be written to disk in a safe way, that is immune for system
failures (like disk full). To do so, the BBP implements an atomic commit and
recovery protocol: first all files to be overwritten are moved to a BACKUP/
dir. If that succeeds, the writes are done. If that also fully succeeds
the BACKUP/ dir is renamed to DELETE_ME/ and subsequently deleted.
If not, all files in BACKUP/ are moved back to their original location.

@item unloading
Bats which have a logical reference (ie. a lrefs > 0) but no memory
reference (refcnt == 0) can be unloaded. Unloading dirty bats means,
moving the original (committed version) to the BACKUP/ dir and saving
the bat. This complicates the commit and recovery/abort issues.
The commit has to check if the bat is already moved. And The recovery
has to always move back the files from the BACKUP/ dir.

@item reference counting
Bats use have two kinds of references: logical and physical (pointer) ones.
Both are administered with the BBPincref/BBPdecref routines. For
backward compatibility, we maintain BBPfix/BBPunfix as shorthands
for the adjusting the pointer references.

@item share counting
Views use the heaps of there parent bats. To save guard this, the
parent has a shared counter, which is incremented and decremented
using BBPshare and BBPunshare. These functions make sure the
parent is memory resident as required because of the 'pointer' sharing.
@end table
@{
@h
#ifndef _GDK_BBP_H_
#define _GDK_BBP_H_

#define BBPINIT		2048
#define BBPMAXSIZE	(1024*1024)

#define BBPLOADED	1	/* set if bat in memory */
#define BBPSWAPPED	2	/* set if dirty bat is not in memory */
#define BBPTMP          4	/* set if non-persistent bat has image on disk */
#define BBPDELETED	16	/* set if bat persistent at last commit is now transient */
#define BBPEXISTING	32	/* set if bat was already persistent at end of last commit */
#define BBPNEW 		64	/* set if bat has become persistent since last commit */
#define BBPPERSISTENT	(BBPEXISTING|BBPNEW)	/* mask for currently persistent bats */
#define BBPSTATUS	127

#define BBPUNLOADING	128	/* set while we are unloading */
#define BBPLOADING	256	/* set while we are loading */
#define BBPSAVING       512	/* set while we are saving */
#define BBPRENAMED	1024	/* set when bat is renamed in this transaction */
#define BBPDELETING	2048	/* set while we are deleting (special case in module unload) */
#define BBPUNSTABLE	(BBPUNLOADING|BBPDELETING)	/* set while we are unloading */
#define BBPWAITING      (BBPUNLOADING|BBPLOADING|BBPSAVING|BBPDELETING)

#define BBPTRIM_ALL	(((size_t)1) << (sizeof(size_t)*8 - 2))	/* very large positive size_t */
#define BBPLASTUSED(x)  ((x) & 0x7fffffff)	/* stamp is always a positive int */

gdk_export int BBPin;		/* BATs swapped into BBP  */
gdk_export int BBPout;		/* BATs swapped out of BBP */
gdk_export int BBPsize;		/* current occupied size of BBP array */

/* global calls */
gdk_export void BBPinit(void);
gdk_export bat BBPimportEntry(char *nme);
gdk_export void BBPexit(void);
gdk_export int BBPdir(int cnt, bat *subcommit);

/* update interface */
gdk_export void BBPclear(bat bid);
#ifdef LIBGDK			/* only used within GDK */
extern bat BBPinsert(BATstore *bs);
#endif
gdk_export void BBPcacheit(BATstore *bs, int lock);
gdk_export void BBPuncacheit(bat bid);
gdk_export int BBPreclaim(BAT *b);
gdk_export int BBPsave(BAT *b);
gdk_export int BBPrename(bat bid, str nme);
gdk_export BATstore *BBPrecycle(int ht, int tt, size_t cap);
gdk_export wrd BBPrecycle_minsize(wrd);

/* query interface */
gdk_export bat BBPindex(str nme);
gdk_export BAT *BBPdescriptor(bat b);

/* swapping interface */
gdk_export int BBPrecover(void);
gdk_export int BBPsync(int cnt, bat *subcommit);
gdk_export int BBPincref(bat b, int logical);
gdk_export void BBPkeepref(bat i);
gdk_export void BBPreleaseref(bat i);
gdk_export void BBPreleaselref(bat i);
gdk_export int BBPdecref(bat b, int logical);
gdk_export void BBPshare(bat b);
gdk_export void BBPunshare(bat b);
gdk_export void BBPextend(dbl factor, int buildhash);

gdk_export void BBPatom_drop(int atom);
gdk_export void BBPatom_load(int atom);

gdk_export int BBPbackup(BAT *b, bit subcommit);

@
@c
#include "monetdb_config.h"
#include "gdk.h"
#include "gdk_storage.h"
/*
@}
@-
The BBP has a fixed address, so re-allocation due to a growing BBP
caused by one thread does not disturb reads to the old entries by another.
This is implemented using anonymous virtual memory; extensions on the same
address are guaranteed because a large non-committed VM area is requested
initially. New slots in the BBP are found in O(1) by keeping a freelist
that uses the 'next' field in the BBPrec records.
@{
@c
*/
@c
BBPrec *BBP = NULL;		/* fixed base VM address of BBP array */
bat BBPmaxsize = BBPMAXSIZE;	/* size of non-committed VM BBP array */
bat BBPlimit = 0;		/* current committed VM BBP array */
bat BBPsize = 0;		/* current used size of BBP array */

#define BBPNONAME "."		/* filler for no name in BBP.dir */
/*
@}
@-
The hash index uses a bucket index (int array) of size mask that is
tuned for perfect hashing (1 lookup). The bucket chain uses the 'next'
field in the BBPrec records.
@{
@c
*/
@h
#define BBPtmpcheck(s) ((s)[0] == 't' && (s)[1] == 'm' && (s)[2] == 'p' && ((s)[3] == '_' || ((s)[3] == 'r' && (s)[4] == '_')))	/* (strncmp((s), "tmp_", 4) == 0) */
#define BBPnamecheck(s) (BBPtmpcheck(s) ? ((s)[3] == '_' ? strtol((s) + 4, NULL, 8) : -strtol((s) + 5, NULL, 8)) : 0)

@c
bat *BBP_hash = NULL;		/* BBP logical name hash buckets */
bat BBP_mask = 0;		/* number of buckets = & mask */

static void BBPspin(bat bid, str debug, int event);
static int BBPfree(BAT *b, str calledFrom);
static int BBPdestroy(BAT *b);
static void BBPuncacheit_(bat bid, int unloaddesc);
static void BBPinitcache(void);
static int BBPprepare(bit subcommit);
static BAT *getBBPdescriptor(bat i, int lock);


static int stamp = 0;
static INLINE int
BBPstamp(void)
{
	return ++stamp;
}

static void
BBPsetstamp(int newstamp)
{
	stamp = newstamp;
}


static void
BBP_insert(bat i)
{
	bat idx = (bat) (strHash(BBP_logical(i)) & BBP_mask);

	BBP_next(i) = BBP_hash[idx];
	BBP_hash[idx] = i;
}

static void
BBP_delete(bat i)
{
	bat *h = BBP_hash;
	str s = BBP_logical(i);
	bat idx = (bat) (strHash(s) & BBP_mask);

	for (h += idx; (i = *h) != 0; h = &BBP_next(i)) {
		if (strcmp(BBP_logical(i), s) == 0) {
			*h = BBP_next(i);
			break;
		}
	}
}

@-
other globals
@c
int BBP_curstamp = 0;		/* unique stamp for creation of a bat */
MT_Id BBP_notrim = ~((MT_Id) 0);	/* avoids BBPtrim when we really do not want it */
int BBP_dirty = 0;		/* BBP structures modified? */
int BBPin = 0;			/* bats loaded statistic */
int BBPout = 0;			/* bats saved statistic */

/*
@}

@+ BBP Consistency and Concurrency
While GDK provides the basic building blocks for an ACID system, in
itself it is not such a system, as we this would entail too much overhead
that is often not needed. Hence, some consistency control is left to the
user. The first important user constraint is that if a user updates a
BAT, (s)he himself must assure that no-one else accesses this BAT.

Concerning buffer management, the BBP carries out a swapping policy.
BATs are kept in memory till the memory is full. If the memory is full,
the malloc functions initiate BBP trim actions, that unload the coldest BATs
that have a zero reference count. The second important user constraint
is therefore that a user may only manipulate live BAT data in memory if it
is sure that there is at least one reference count to that BAT.

The main BBP array is protected by two locks:
@table @code
@item GDKcacheLock]
this lock guards the free slot management in the BBP array.  The BBP
operations that allocate a new slot for a new BAT (@emph{BBPinit},@emph{BBPcacheit}),
delete the slot of a destroyed BAT (@emph{BBPreclaim}), or rename a BAT
(@emph{BBPrename}), hold this lock. It also protects all BAT (re)naming actions
include (read and write) in the hash table with BAT names.
@item GDKswapLock
this lock guards the swap (loaded/unloaded) status of the BATs. Hence, all
BBP routines that influence the swapping policy, or actually carry out the
swapping policy itself, acquire this lock (e.g. @emph{BBPfix},@emph{BBPunfix}).
Note that this also means that updates to the BBP_status indicator array
must be protected by GDKswapLock.

To reduce contention GDKswapLock was split into multiple locks; it is now
an array of lock pointers which is accessed by GDKswapLock(ABS(bat))
@end table

Routines that need both locks should first acquire the locks in the GDKswapLock
array (in ascending order) and then GDKcacheLock (and release them in reverse order).

To obtain maximum speed, read operations to existing elements in the BBP are
unguarded. As said, it is the users responsibility that the BAT that is being
read is not being modified. BBP update actions that modify the BBP data structure
itself are locked by the BBP functions themselves. Hence, multiple concurrent BBP read
operations may be ongoing while at the same time at most one BBP write
operation @strong{on a different BAT} is executing.
This holds for accesses to the public (quasi-)
arrays @emph{BBPcache}, @emph{BBPstatus}, @emph{BBPrefs}, @emph{BBPlogical} and @emph{BBPphysical}. These
arrays are called quasi as now they are actually stored together in one big BBPrec
array called BBP, that is allocated in anonymous VM space, so we can reallocate
this structure without changing the base address (a crucial feature if read
actions are to go on unlocked while other entries in the BBP may be modified).
@{
@c
*/
@h
#define BBP_status_set(bid, mode, nme) {	\
		BBP_status(bid) = mode;		\
}

#define BBP_status_on(bid, flags, nme)					\
		BBP_status_set(bid, BBP_status(bid) | flags, nme);

#define BBP_status_off(bid, flags, nme)					\
		BBP_status_set(bid, BBP_status(bid) & ~(flags), nme);

#define BBP_unload_inc(bid, nme) {			\
		gdk_set_lock(GDKunloadLock, nme);	\
		BBPunloadCnt++;				\
		gdk_unset_lock(GDKunloadLock, nme);	\
 	}

#define BBP_unload_dec(bid, nme) {					\
		gdk_set_lock(GDKunloadLock, nme);			\
		if (--BBPunloadCnt == 0) gdk_signal_cond(GDKunloadCond, nme); \
		assert(BBPunloadCnt >= 0);				\
		gdk_unset_lock(GDKunloadLock, nme);			\
	}
@c
static MT_Id locked_by = 0;

static INLINE MT_Id
BBP_getpid(void)
{
	MT_Id x = MT_getpid();

	return x;
}

static int BBPunloadCnt = 0;

void
BBPlock(str nme)
{
	int i;

	/* wait for all pending unloads to finish */
	gdk_set_lock(GDKunloadLock, nme);
	if (BBPunloadCnt > 0)
		gdk_wait_cond(GDKunloadCond, GDKunloadLock, nme);

	for (i = 0; i <= BBP_THREADMASK; i++)
		gdk_set_lock(GDKtrimLock(i), nme);
	BBP_notrim = BBP_getpid();
	for (i = 0; i <= BBP_THREADMASK; i++)
		gdk_set_lock(GDKcacheLock(i), nme);
	for (i = 0; i <= BBP_BATMASK; i++)
		gdk_set_lock(GDKswapLock(i), nme);
	locked_by = BBP_notrim;

	gdk_unset_lock(GDKunloadLock, nme);
}

void
BBPunlock(str nme)
{
	int i;

	for (i = BBP_BATMASK; i >= 0; i--)
		gdk_unset_lock(GDKswapLock(i), nme);
	for (i = BBP_THREADMASK; i >= 0; i--)
		gdk_unset_lock(GDKcacheLock(i), nme);
	BBP_notrim = 0;
	locked_by = 0;
	for (i = BBP_THREADMASK; i >= 0; i--)
		gdk_unset_lock(GDKtrimLock(i), nme);
}


static void
BBPinithash(void)
{
	bat i = BBPsize;

	for (BBP_mask = 1; (BBP_mask << 1) <= BBPlimit; BBP_mask <<= 1)
		;
	BBP_hash = (bat *) GDKzalloc(BBP_mask * sizeof(bat));
	if (BBP_hash == NULL)
		GDKfatal("BBPinithash: cannot allocate memory\n");
	BBP_mask--;

	while (--i > 0) {
		str s = BBP_logical(i);

		if (s) {
			str sm = BBP_logical(-i);

			if (*s != '.' && BBPtmpcheck(s) == 0) {
				BBP_insert(i);
			}
			if (sm && *sm != '.' && BBPtmpcheck(sm) == 0) {
				BBP_insert(-i);
			}
		} else {
			BBP_next(i) = BBP_free(i & BBP_THREADMASK);
			BBP_free(i & BBP_THREADMASK) = i;
		}
	}
}

/*
@-
BBPextend must take the trimlock, as it is called when other BBP locks are
held and it will allocate memory. This could trigger a BBPtrim, causing deadlock.
@c
*/
@c
void
BBPextend(dbl factor, int buildhash)
{
	int newsize;
	size_t maxsize;

	/* make sure the new size is at least BBPsize large */
	newsize = (int) (BBPlimit * factor);
	while (newsize < BBPsize)
		newsize = (int) (newsize * factor);
	maxsize = MAX(newsize * 2, BBPmaxsize) * sizeof(BBPrec);

	BBP_notrim = BBP_getpid();
	BBP = (BBPrec *) GDKvmrealloc(BBP, BBPlimit * sizeof(BBPrec), newsize * sizeof(BBPrec), BBPmaxsize * sizeof(BBPrec), &maxsize, 1);
	if (BBP == NULL)
		GDKfatal("BBPextend: failed to extend BAT pool\n");

	memset(BBP + BBPlimit, 0, (newsize - BBPlimit) * sizeof(BBPrec));
	BBPlimit = newsize;
	BBPmaxsize = (int) (maxsize / sizeof(BBPrec));

	if (buildhash) {
		int i;

		GDKfree(BBP_hash);
		BBP_hash = NULL;
		for (i = 0; i <= BBP_THREADMASK; i++)
			BBP_free(i) = 0;
		BBPinithash();
	}
	BBP_notrim = 0;
}

static INLINE char *
BBPparse(str *cur)
{
	char *base, *c = *cur;

	for (c++; GDKisspace(*c); c++)
		;
	for (base = c; !(GDKisspace(*c) || *c == ','); c++)
		;
	*c = 0;
	*cur = c;
	return base;
}


static INLINE str
BBPtmpname(str s, int len, bat i)
{
	int reverse = i < 0;

	if (reverse)
		i = -i;
	s[--len] = 0;
	while (i > 0) {
		s[--len] = '0' + (i & 7);
		i >>= 3;
	}
	s[--len] = '_';
	if (reverse)
		s[--len] = 'r';
	s[--len] = 'p';
	s[--len] = 'm';
	s[--len] = 't';
	return s + len;
}

static INLINE str
BBPphysicalname(str s, int len, bat i)
{
	s[--len] = 0;
	while (i > 0) {
		s[--len] = '0' + (i & 7);
		i >>= 3;
	}
	return s + len;
}

static int
recover_dir(int direxists)
{
	if (direxists) {
		/* just try; don't care about these non-vital files */
		GDKunlink(BATDIR, "BBP", "bak");
		GDKmove(BATDIR, "BBP", "dir", BATDIR, "BBP", "bak");
	}
	return GDKmove(BAKDIR, "BBP", "dir", BATDIR, "BBP", "dir");
}

static int BBPrecover_subdir(void);
static int BBPdiskscan(const char *);

#if GDK_VARSHIFT != 0
/* Convert the old-style string heap to the new style.
   This function must be called at the end of BBPinit(), just before
   "normal processing" starts.  All errors that happen during the
   conversion are fatal.  This function is "safe" in the sense that
   when it is interrupted, recovery will just start over.  No
   permanent changes are made to the database until all string heaps
   have been converted, and then the changes are made atomically.
*/

static void
fixstrheap(void)
{
	bat bid;
	BATstore *bs;
	Heap h;
	str nme, bnme;
	long_str filename;
	BAT *b;
	BATiter bi;
	BUN p, q;
	str s;
	var_t loc;

	for (bid = 1; bid < BBPsize; bid++) {
		if ((bs = BBP[bid].cache) == NULL)
			continue;	/* not a valid BAT */
		if (bs->H.type != TYPE_str && bs->T.type != TYPE_str)
			continue;	/* no string heaps */
		nme = BBP_physical(bid);
		if ((bnme = strrchr(nme, DIR_SEP)) == NULL)
			bnme = nme;
		else
			bnme++;
		sprintf(filename, "BACKUP%c%s", DIR_SEP, bnme);
		BBPfix(bid);
		b = BBPdescriptor(bid);
		if (b == NULL)
			GDKfatal("fixstrheap: BBPdescriptor(%d) failed\n", bid);
		bi = bat_iterator(b);

		/* make backup copy */
		if (b->H->type == TYPE_str) {
			b->H->heap.dirty = TRUE;
			b->H->vheap->dirty = TRUE;
		}
		if (b->T->type == TYPE_str) {
			b->T->heap.dirty = TRUE;
			b->T->vheap->dirty = TRUE;
		}
		if (BBPsave(b))
			GDKfatal("fixstrheap: creating backup for BAT %d failed\n", bid);

@= fixstrheap
		if (b->@1->type == TYPE_str) {
			h = *b->@1->vheap;
			h.filename = NULL;
			h.base = NULL;
			h.dirty = 0;
			h.parentid = 0;

			/* load old string heap */
			if (HEAPload(&h, filename, "@2heap", 0) < 0)
				GDKfatal("fixstrheap: loading old string heap for BAT %d failed\n", bid);

			/* create new string heap */
			if (HEAPdelete(b->@1->vheap, nme, "@2heap"))
				GDKfatal("fixstrheap: deleting string heap for BAT %d failed\n", bid);
			memset(b->@1->vheap, 0, sizeof(Heap));
			b->@1->vheap->filename = GDKmalloc(strlen(nme) + 12);
			if (b->@1->vheap->filename == NULL)
				GDKfatal("fixstrheap: GDKmalloc failed\n");
			GDKfilepath(b->@1->vheap->filename, NULL, nme, "@2heap");
			if (ATOMheap(TYPE_str, b->@1->vheap, b->U->capacity))
				GDKfatal("fixstrheap: initializing new string heap failed\n");
			b->@1->vheap->parentid = b->batCacheid;

			/* do the conversion */
			b->@1->heap.dirty = TRUE;
			b->@1->vheap->dirty = TRUE;
			BATloop(b, p, q) {
				loc = * (var_t *) BUN@2loc(bi, p);
				s = h.base + loc;
				if (strPut(b->@1->vheap, &loc, s) == 0)
					GDKfatal("fixstrheap: strPut failed\n");
				* (var_t *) BUN@2loc(bi, p) = loc;
			}
			HEAPfree(&h);
		}
@c
		@:fixstrheap(H,h)@
		@:fixstrheap(T,t)@

		BBPunfix(bid);
		BBP_unload_inc(i, "fixstrheap");
		if (BBPfree(b, "fixstrheap"))
			GDKfatal("fixstrheap: BBPfree failed\n");
		b = NULL;

	}

	/* make permanent */
	if (TMcommit())
		GDKfatal("fixstrheap: commit failed\n");
}
#endif

@-
A read only BAT can be shared in a file system by reading its descriptor separately.
The default src=0 is to read the full BBPdir file.
@c
static BATstore *
BBPreadEntries(FILE *fp, char *src, int *min_stamp, int *max_stamp)
{
	bat bid = 0;
	char buf[4096];
	BATstore *bs;

	/* read the BBP.dir and insert the BATs into the BBP */
	while (fgets(buf, sizeof(buf), fp) != NULL) {
		lng batid;
		unsigned short status;
		char headname[129];
		char tailname[129];
		char filename[129];
		unsigned int properties;
		int lastused;
		int nread;
		char *s, *options = NULL;
		char logical[1024];
		lng inserted, deleted, first, count, capacity;
		unsigned short map_head, map_tail, map_hheap, map_theap;
		int Hhashash, Thashash;

		if (sscanf(buf,
			   "%lld %hu %128s %128s %128s %d %u %lld %lld %lld %lld %lld %hu %hu %hu %hu"
			   "%n",
			   &batid, &status, headname, tailname, filename,
			   &lastused, &properties, &inserted, &deleted, &first,
			   &count, &capacity, &map_head, &map_tail, &map_hheap,
			   &map_theap,
			   &nread) < 16)
			GDKfatal("BBPinit: invalid format for BBP.dir%s", buf);

		if (src && strcmp(src, filename) != 0)
			continue;

		bid = (bat) batid;
		if ((bat) batid >= BBPsize) {
			BBPsize = (bat) batid + 1;
			if (BBPsize >= BBPlimit)
				BBPextend(BATMARGIN, FALSE);
		}
		if (src == 0)
			assert(BBP[bid].cache == NULL);	/* no duplicates in BBP.dir */
		bs = GDKzalloc(sizeof(BATstore));
		if (bs == NULL)
			GDKfatal("BBPinit: cannot allocate memory for BATstore.");
		bs->B.H = &bs->H;
		bs->B.T = &bs->T;
		bs->B.P = &bs->P;
		bs->B.U = &bs->U;
		bs->B.batCacheid = bid;
		bs->BM.H = &bs->T;
		bs->BM.T = &bs->H;
		bs->BM.P = &bs->P;
		bs->BM.U = &bs->U;
		bs->BM.batCacheid = -bid;
		BATroles(&bs->B, NULL, NULL);
		bs->P.persistence = PERSISTENT;
		bs->P.copiedtodisk = 1;
		bs->P.set = properties & 0x01;
		bs->P.restricted = (properties & 0x06) >> 1;
		bs->U.inserted = (BUN) inserted;
		bs->U.deleted = (BUN) deleted;
		bs->U.first = (BUN) first;
		bs->U.count = (BUN) count;
		bs->U.capacity = (BUN) capacity;
		bs->P.map_head = (char) map_head;
		bs->P.map_tail = (char) map_tail;
		bs->P.map_hheap = (char) map_hheap;
		bs->P.map_theap = (char) map_theap;

@= heapinit
		{
			int t;
			char type[11];
			unsigned short width;
			unsigned short var;
			unsigned short properties;
			lng nokey0;
			lng nokey1;
			lng nosorted;
			lng base;
			lng align;
			lng free;
			lng size;
			unsigned short storage;
			int n;

			if (sscanf(buf + nread,
				   " %10s %hu %hu %hu %lld %lld %lld %lld %lld %lld %lld %hu"
				   "%n",
				   type, &width, &var, &properties, &nokey0,
				   &nokey1, &nosorted, &base, &align, &free,
				   &size, &storage,
				   &n) < 12)
				GDKfatal("BBPinit: invalid format for BBP.dir\n%s", buf);

			@1hashash = var & 2;
			var &= ~2;
			if ((t = ATOMindex(type)) < 0)
				t = ATOMunknown_find(type);
			else if (BATatoms[t].varsized != var)
				GDKfatal("BBPinit: inconsistent entry in BBP.dir: @1.varsized mismatch for BAT " LLFMT "\n", batid);
			else if (var && t != 0 ?
				 BATatoms[t].size < width ||
				 (width != 1 && width != 2 && width != 4
#if SIZEOF_VAR_T == 8
				  && width != 8
#endif
				 ) :
				 BATatoms[t].size != width)
				GDKfatal("BBPinit: inconsistent entry in BBP.dir: @1.size mismatch for BAT " LLFMT "\n", batid);
			bs->@1.type = t;
			bs->@1.width = width;
			bs->@1.varsized = var != 0;
			bs->@1.shift = ATOMelmshift(width);
			assert_shift_width(bs->@1.shift,bs->@1.width);
			bs->@1.nokey[0] = (BUN) nokey0;
			bs->@1.nokey[1] = (BUN) nokey1;
			bs->@1.sorted = (bit) (properties & 0x00FF);
			bs->@1.key = (properties & 0x0100) != 0;
			bs->@1.dense = (properties & 0x0200) != 0;
			bs->@1.nonil = (properties & 0x0400) != 0;
			bs->@1.nil = (properties & 0x0800) != 0;
			bs->@1.nosorted = (BUN) nosorted;
			bs->@1.seq = base < 0 ? oid_nil : (oid) base;
			bs->@1.align = (oid) align;
			bs->@1.heap.maxsize = (size_t) size;
			bs->@1.heap.free = (size_t) free;
			bs->@1.heap.size = (size_t) size;
			bs->@1.heap.base = NULL;
			bs->@1.heap.filename = NULL;
			bs->@1.heap.storage = (char) storage;
			bs->@1.heap.copied = 0;
			bs->@1.heap.newstorage = (chr) storage;
			bs->@1.heap.dirty = 0;
			nread += n;
		}
@c
		@:heapinit(H)@
		@:heapinit(T)@

@= vheapinit
		if (bs->@1.varsized && bs->@1.type != TYPE_void) {
			lng free, size;
			unsigned short storage;
			int n;

			bs->@1.vheap = GDKzalloc(sizeof(Heap));
			if (bs->@1.vheap == NULL)
				GDKfatal("BBPinit: cannot allocate memory for heap.");
			if (sscanf(buf + nread,
				   " %lld %lld %hu"
				   "%n",
				   &free, &size, &storage, &n) < 3)
				GDKfatal("BBPinit: invalid format for BBP.dir\n%s", buf);
			bs->@1.vheap->maxsize = (size_t) size;
			bs->@1.vheap->free = (size_t) free;
			bs->@1.vheap->size = (size_t) size;
			bs->@1.vheap->base = NULL;
			bs->@1.vheap->filename = NULL;
			bs->@1.vheap->storage = (char) storage;
			bs->@1.vheap->copied = 0;
			bs->@1.vheap->hashash = @1hashash != 0;
			bs->@1.vheap->newstorage = (chr) storage;
			bs->@1.vheap->dirty = 0;
			bs->@1.vheap->parentid = bid;
			nread += n;
		}
@c
		@:vheapinit(H)@
		@:vheapinit(T)@

		if (buf[nread] != '\n' && buf[nread] != ' ')
			GDKfatal("BBPinit: invalid format for BBP.dir\n%s", buf);
		if (buf[nread] == ' ')
			options = buf + nread + 1;

		if (src)
			return bs;
		BBP[bid].cache = bs;
		BBP[bid].status = BBPEXISTING;	/* do we need other status bits? */
		if ((s = strchr(headname, '~')) != NULL && s == headname) {
			s = BBPtmpname(logical, sizeof(logical), bid);
		} else {
			if (s)
				*s = 0;
			strncpy(logical, headname, sizeof(logical));
			s = logical;
		}
		BBP[bid].nme[0] = GDKstrdup(s);
		if (strcmp(tailname, BBPNONAME) != 0)
			BBP[bid].nme[1] = GDKstrdup(tailname);
		else
			BBP[bid].nme[1] = GDKstrdup(BBPtmpname(tailname, sizeof(tailname), -bid));
		BBP[bid].path = GDKstrdup(filename);
		BBP[bid].options = NULL;
		if (options)
			BBP[bid].options = GDKstrdup(options);
		BBP[bid].lastused = lastused;
		if (lastused > *max_stamp)
			*max_stamp = lastused;
		if (lastused < *min_stamp)
			*min_stamp = lastused;
		BBP[bid].refs = 0;
		BBP[bid].lrefs = 1;	/* any BAT we encounter here is persistent, so has a logical reference */
	}
	return NULL;
}

static int
BBPheader(FILE *fp, int *BBPlimit, oid *BBPoid, int silent)
{
	char buf[BUFSIZ];
	int sz, bbpversion, ptrsize, oidsize;
	char *s;

	if (fgets(buf, sizeof(buf), fp) == NULL) {
		if (silent) {
			GDKerror("BBPinit: BBP.dir is empty");
			return -1;
		}
		GDKfatal("BBPinit: BBP.dir is empty");
	}
	if (sscanf(buf, "BBP.dir, GDKversion %d\n", &bbpversion) != 1) {
		GDKerror("BBPinit: old BBP without version number");
		GDKerror("dump the database using a compatible version,");
		GDKerror("then restore into new database using this version.\n");
		if (silent)
			return -1;
		exit(1);
	}
	if (bbpversion != GDKLIBRARY &&
	    bbpversion != GDKLIBRARY_PRE_VARWIDTH &&
	    bbpversion != GDKLIBRARY_PRE_VARSHIFT) {
		if (silent) {
			GDKerror("BBPinit: incompatible BBP version: expected 0%o, got 0%o.", GDKLIBRARY, bbpversion);
			return -1;
		}
		GDKfatal("BBPinit: incompatible BBP version: expected 0%o, got 0%o.", GDKLIBRARY, bbpversion);
	}
	if (fgets(buf, sizeof(buf), fp) == NULL) {
		if (silent) {
			GDKerror("BBPinit: short BBP");
			return -1;
		}
		GDKfatal("BBPinit: short BBP");
	}
	if (sscanf(buf, "%d %d", &ptrsize, &oidsize) != 2) {
		if (silent) {
			GDKerror("BBPinit: BBP.dir has incompatible format: pointer and OID sizes are missing");
			return -1;
		}
		GDKfatal("BBPinit: BBP.dir has incompatible format: pointer and OID sizes are missing");
	}
	if (ptrsize != SIZEOF_SIZE_T || oidsize != SIZEOF_OID) {
		if (silent) {
			GDKerror("BBPinit: database created with incompatible server:\n"
				 "expected pointer size %d, got %d, expected OID size %d, got %d.",
				 (int) SIZEOF_SIZE_T, ptrsize, (int) SIZEOF_OID, oidsize);
			return -1;
		}
		GDKfatal("BBPinit: database created with incompatible server:\n"
			 "expected pointer size %d, got %d, expected OID size %d, got %d.",
			 (int) SIZEOF_SIZE_T, ptrsize, (int) SIZEOF_OID, oidsize);
	}
	if (fgets(buf, sizeof(buf), fp) == NULL) {
		if (silent) {
			GDKerror("BBPinit: short BBP");
			return -1;
		}
		GDKfatal("BBPinit: short BBP");
	}
	*BBPoid = OIDread(buf);
	if ((s = strstr(buf, "BBPsize")) != NULL) {
		sscanf(s, "BBPsize=%d", &sz);
		sz = (int) (sz * BATMARGIN);
		if (sz > *BBPlimit)
			*BBPlimit = sz;
	}
	return bbpversion;
}
@-
In a distributed version of MonetDB, it would be nice to easily share the BATs
with other server instances. Although concurrency control issues should be handled
with care, it can avoid excessive communiction costs. The BBPimportEntry creates
a BATdescriptor using symbolic links to its source. Presummably this would lead
to a transparant behavior.
@= linkHeap
	lstat(@3, &st);
	GDKfilepath(path, BATDIR, BBP_physical(bn->batCacheid), "@4");
	GDKcreatedir(path);
	IODEBUG mnstr_printf(GDKerr, "#symlink %s ->%s\n", @3, path);
	if (symlink(@3, path) < 0) {
		GDKerror("attach.bind:cannot link '%s' -> '%s'\n", path, @3);
		BBPdestroy(bn);
		return 0;
	}
	bn->@1->@2.free = bn->@1->@2.size = (size_t) st.st_size;
	bn->@1->@2.storage = (bn->@1->@2.size < REMAP_PAGE_MAXSIZE) ? STORE_MEM : STORE_MMAP;
	if (bn->@1->@2.filename) {
		GDKfree(bn->@1->@2.filename);
		bn->@1->@2.filename = 0;
	}
	HEAPload(&bn->@1->@2, BBP_physical(bn->batCacheid), "@4", TRUE);

@= linkvHeap
	lstat(@2, &st);
	GDKfilepath(path, BATDIR, BBP_physical(bn->batCacheid), "@3");
	GDKcreatedir(path);
	IODEBUG mnstr_printf(GDKerr, "#symlink %s ->%s\n", @2, path);
	if (symlink(@2, path) < 0) {
		GDKerror("attach.bind:cannot link '%s' -> '%s'\n", path, @2);
		BBPdestroy(bn);
		return 0;
	}
	if (bn->@1->vheap == 0)
		bn->@1->vheap = (Heap *) GDKzalloc(sizeof(Heap));
	bn->@1->vheap->parentid = bn->batCacheid;
	bn->@1->vheap->free = bn->@1->vheap->size = (size_t) st.st_size;
	bn->@1->vheap->storage = (bn->@1->vheap->size < REMAP_PAGE_MAXSIZE) ? STORE_MEM : STORE_MMAP;
	if (bn->@1->vheap->filename) {
		GDKfree(bn->@1->vheap->filename);
		bn->@1->vheap->filename = 0;
	}
	HEAPload(bn->@1->vheap, BBP_physical(bn->batCacheid), "@3", TRUE);

@c
bat
BBPimportEntry(char *nme)
{
#ifdef WIN32
	GDKerror("BBPimportEntry: not tested under Windows");
	return 0;
#else
	char *s;
	FILE *fd;
	int min_stamp = 0x7fffffff, max_stamp = 0;
	BAT *bn = 0;
	BATstore *bs;
	char bbpdir[BUFSIZ];
	char bufhead[BUFSIZ];
	char buftail[BUFSIZ];
	char bufhheap[BUFSIZ];
	char buftheap[BUFSIZ];
	char path[BUFSIZ];
	struct stat st;
	oid BBPoid;
	int BBPlimit;

	IODEBUG mnstr_printf(GDKerr,"#importEntry %s\n",nme);
	strcpy(bbpdir,nme);
	s= strstr(bbpdir,BATDIR);
	if (s == 0)
		return 0;
	*s = 0;
	nme = s + strlen(BATDIR) + 1;
	snprintf(path, BUFSIZ, "%s%c%s/BBP.dir", bbpdir, DIR_SEP, BATDIR);
	fd = fopen(path,"r");
	if (fd == 0) {
		snprintf(path, BUFSIZ, "%s%c%s%c/BBP.bak", bbpdir, DIR_SEP, BATDIR, DIR_SEP);
		fd = fopen(path,"r");
		if (fd == 0) {
			snprintf(path, BUFSIZ, "%s%c%s%cBACKUP/BBP.dir", bbpdir, DIR_SEP, BATDIR, DIR_SEP);
			fd = fopen(path,"r");
			if (fd == 0)
				return 0;
		}
	}

	if (BBPheader(fd, &BBPlimit, &BBPoid, TRUE) < 0)
		return 0;
	bs = BBPreadEntries(fd, nme, &min_stamp, &max_stamp);
	fclose(fd);
	if (bs == 0)
		return 0;
	bs->B.batCacheid = 0;

	BBPinsert(bs);
	BBPcacheit(bs, 0);
	bn = &bs->B;
	BBP_refs(bn->batCacheid)++;
	BBP_lrefs(bn->batCacheid)++;

	/* re-adjust the files to become symbolic links */
	snprintf(bufhead, BUFSIZ, "%s%c%s%c%s.head", bbpdir, DIR_SEP, BATDIR, DIR_SEP, nme);
	snprintf(buftail, BUFSIZ, "%s%c%s%c%s.tail",  bbpdir, DIR_SEP, BATDIR, DIR_SEP, nme);
	snprintf(bufhheap, BUFSIZ, "%s%c%s%c%s.hheap",  bbpdir,  DIR_SEP, BATDIR, DIR_SEP, nme);
	snprintf(buftheap, BUFSIZ, "%s%c%s%c%s.theap",  bbpdir,  DIR_SEP, BATDIR, DIR_SEP, nme);

	BATmode(bn, TRANSIENT);
	bn->batCopiedtodisk = 1;

	if (bn->htype != TYPE_void ) {
		@:linkHeap(H,heap,bufhead,head)@
		if (bn->tvarsized) {
			@:linkvHeap(T,bufhheap,hheap)@
		}
	}
	if (bn->ttype != TYPE_void ) {
		@:linkHeap(T,heap,buftail,tail)@
		if (bn->tvarsized) {
			@:linkvHeap(T,buftheap,theap)@
		}
	}
	BATsetaccess(bn, BAT_READ);
	if (bn->batCapacity > 1) {
		BATpropcheck(bn, BATPROPS_QUICK);
		BATpropcheck(BATmirror(bn), BATPROPS_QUICK);
	}

	return bn->batCacheid;
#endif
}

void
BBPinit(void)
{
	FILE *fp = NULL;
	char buf[4096];
	struct stat st;
	int min_stamp = 0x7fffffff, max_stamp = 0;
	bat bid;
	int bbpversion;
	oid BBPoid;

	/* first move everything from SUBDIR to BAKDIR (its parent) */
	if (BBPrecover_subdir() < 0)
		GDKfatal("BBPinit: cannot properly process %s.", SUBDIR);

	/* try to obtain a BBP.dir from bakdir */
	GDKfilepath(buf, BAKDIR, "BBP", "dir");

	if (stat(buf, &st) == 0) {
		/* backup exists; *must* use it */
		GDKfilepath(buf, BATDIR, "BBP", "dir");
		if (recover_dir(stat(buf, &st) == 0) < 0)
			goto bailout;
		if ((fp = GDKfilelocate("BBP", "r", "dir")) == NULL)
			GDKfatal("BBPinit: cannot open recovered BBP.dir.");
	} else if ((fp = GDKfilelocate("BBP", "r", "dir")) == NULL) {
		/* there was no BBP.dir either. Panic! try to use a BBP.bak */
		GDKfilepath(buf, BAKDIR, "BBP", "bak");
		if (stat(buf, &st) < 0) {
			/* no BBP.bak (nor BBP.dir or BACKUP/BBP.dir): create a new one */
			IODEBUG THRprintf(GDKout, "#BBPdir: initializing BBP.\n");	/* BBPdir instead of BBPinit for backward compatibility of error messages */
			if (BBPdir(0, NULL) < 0)
				goto bailout;
		} else if (GDKmove(BATDIR, "BBP", "bak", BATDIR, "BBP", "dir") == 0)
			IODEBUG THRprintf(GDKout, "#BBPinit: reverting to dir saved in BBP.bak.\n");

		if ((fp = GDKfilelocate("BBP", "r", "dir")) == NULL)
			goto bailout;
	}
	assert(fp != NULL);

	/* scan the BBP.dir to obtain current size */
	BBPlimit = BBPINIT;
	BBPsize = 1;

	bbpversion = BBPheader(fp, &BBPlimit, &BBPoid,FALSE);

	/* allocate structures: try to reserve as much space as
	   possible */
	for (;;) {
		size_t size = BBPlimit * sizeof(BBPrec);
		size_t maxsize = BBPmaxsize * sizeof(BBPrec);

		BBP = GDKvmalloc(size, &maxsize, 1);
		assert(BBP != NULL);	/* GDKvmalloc panics if it can't allocate */
		MT_alloc_register(BBP, maxsize, 'P');
		if (maxsize >= BBPmaxsize * sizeof(BBPrec)) {
			BBPmaxsize = (bat) (maxsize / sizeof(BBPrec));
			break;
		}
		MT_alloc_register(BBP, maxsize, 'p');
		GDKvmfree(BBP, size, maxsize);
		if ((BBPmaxsize /= 2) < BBPlimit)
			GDKfatal("BBPinit: could not alloc arena");
	}
	memset(BBP, 0, BBPlimit * sizeof(BBPrec));

	(void) BBPreadEntries(fp, 0, &min_stamp, &max_stamp);
	fclose(fp);

	/* normalize saved LRU stamps */
	if (min_stamp <= max_stamp) {
		for (bid = 1; bid < BBPsize; bid++)
			if (BBPvalid(bid))
				BBP[bid].lastused -= min_stamp;
		BBPsetstamp(max_stamp - min_stamp);
	}

	BBPinitcache();
	BBPinithash();
	BBP_notrim = 0;

	OIDbase(BBPoid);

	/* will call BBPrecover if needed */
	if (BBPprepare(FALSE))
		GDKfatal("BBPinit: cannot properly process %s.", BAKDIR);

	/* cleanup any leftovers (must be done after BBPrecover) */
	BBPdiskscan(BATDIR);

#if GDK_VARSHIFT != 0
	if (bbpversion == GDKLIBRARY_PRE_VARSHIFT)
		fixstrheap();
#else
	(void) bbpversion;
#endif

	return;

      bailout:
	/* now it is time for real panic */
	GDKfatal("BBPinit: could not write %s%cBBP.dir", BATDIR, DIR_SEP);
}

/*
@}
@-
During the exit phase all non-persistent BATs are removed.
Upon exit the status of the BBP tables is saved on disk.
This function is called once and during the shutdown of the
server. Since shutdown may be issued from any thread (dangerous)
it may lead to interference in a parallel session.
@{
@c
*/
@c

void
BBPexit(void)
{
	bat i;
	int skipped;

	if (!BBP)
		return;		/* AARGH */

	BBPrecycle_minsize(0);	/* clear the bat cache */
	BBPlock("BBPexit");	/* stop all threads ever touching more descriptors */

	/* free all memory (just for leak-checking in Purify) */
	do {
		skipped = 0;
		for (i = 0; i < BBPsize; i++) {
			if (BBPvalid(i)) {
				BAT *b = BBP_cache(i);

				if (b) {
					if (b->batSharecnt > 0) {
						skipped = 1;
						continue;
					}
					/* NIELS ?? Why reduce share count, its done in VIEWdestroy !! */
					if (isVIEW(b)) {
						bat hp = VIEWhparent(b), tp = VIEWtparent(b);
						bat vhp = VIEWvhparent(b), vtp = VIEWvtparent(b);
						if (hp) {
							BBP_cache(hp)->batSharecnt--;
							--BBP_lrefs(hp);
						}
						if (tp) {
							BBP_cache(tp)->batSharecnt--;
							--BBP_lrefs(tp);
						}
						if (vhp) {
							BBP_cache(vhp)->batSharecnt--;
							--BBP_lrefs(vhp);
						}
						if (vtp) {
							BBP_cache(vtp)->batSharecnt--;
							--BBP_lrefs(vtp);
						}
					}
					if (isVIEW(b))
						VIEWdestroy(b);
					else
						BATfree(b);
				}
				BBPuncacheit_(i, TRUE);
				if (BBP[i].nme[0] != BBP[i].bak[0])
					GDKfree(BBP[i].bak[0]);
				BBP[i].bak[0] = NULL;
				GDKfree(BBP[i].nme[0]);
				BBP[i].nme[0] = NULL;
				GDKfree(BBP[i].nme[1]);
				BBP[i].nme[1] = NULL;
			}
			if (BBP_physical(i)) {
				GDKfree(BBP_physical(i));
				BBP_physical(i) = NULL;
			}
			if (BBP[i].bak[0])
				GDKfree(BBP[i].bak[0]);
			BBP[i].bak[0] = NULL;
		}
	} while (skipped);
	GDKfree(BBP_hash);
	BBP_hash = 0;
}

/*
@}
@-
The routine @%BBPdir@ creates the BAT pool dictionary file.
It includes some information about the current state of affair in the pool.
The location in the buffer pool is saved for later use as well.
This is merely done for ease of debugging and of no importance to front-ends.
The tail of non-used entries is reclaimed as well.
@{
@c
*/
@c
static int
new_bbpentry(stream *s, bat i)
{
	int t;

	assert(i > 0);
	assert(i < BBPsize);
	assert(BBP[i].cache);
	assert(BBP[i].cache->B.batCacheid == i);

	if (mnstr_printf(s, SSZFMT " %d %s %s %s %d %u " BUNFMT " " BUNFMT " " BUNFMT " " BUNFMT " " BUNFMT " %u %u %u %u",	/* BAT info */
			  (ssize_t) i, BBP[i].status & BBPPERSISTENT,
			  BBP[i].nme[0],
			  BBP[i].nme[1] ? BBP[i].nme[1] : BBPNONAME,
			  BBP[i].path,
			  BBP[i].lastused,
			  (BBP[i].cache->P.restricted << 1) | BBP[i].cache->P.set,
			  BBP[i].cache->U.inserted,
			  BBP[i].cache->U.deleted,
			  BBP[i].cache->U.first,
			  BBP[i].cache->U.count,
			  BBP[i].cache->U.capacity,
			  (unsigned char) BBP[i].cache->P.map_head,
			  (unsigned char) BBP[i].cache->P.map_tail,
			  (unsigned char) BBP[i].cache->P.map_hheap,
			  (unsigned char) BBP[i].cache->P.map_theap) < 0)
		return -1;
@= columnprint
	t = BBP[i].cache->@1.type;
	if (mnstr_printf(s, " %s %u %u %u " BUNFMT " " BUNFMT " " BUNFMT " " OIDFMT " " OIDFMT " " SZFMT " " SZFMT " %d",
			  t >= 0 ? BATatoms[t].name : ATOMunknown_name(t),
			  BBP[i].cache->@1.width,
			  BBP[i].cache->@1.varsized | (BBP[i].cache->@1.vheap ? BBP[i].cache->@1.vheap->hashash << 1 : 0),
			  ((unsigned short) BBP[i].cache->@1.sorted & 0xFF) | (((unsigned short) BBP[i].cache->@1.key & 0x01) << 8) | (((unsigned short) BBP[i].cache->@1.dense & 0x01) << 9) | (((unsigned short) BBP[i].cache->@1.nonil & 0x01) << 10) | (((unsigned short) BBP[i].cache->@1.nil & 0x01) << 11),
			  BBP[i].cache->@1.nokey[0],
			  BBP[i].cache->@1.nokey[1],
			  BBP[i].cache->@1.nosorted,
			  BBP[i].cache->@1.seq,
			  BBP[i].cache->@1.align,
			  BBP[i].cache->@1.heap.free,
			  BBP[i].cache->@1.heap.size,
			  BBP[i].cache->@1.heap.newstorage) < 0)
		return -1;
@c
	@:columnprint(H)@
	@:columnprint(T)@

@= vheapprint
	if (BBP[i].cache->@1.vheap &&
	    mnstr_printf(s, " " SZFMT " " SZFMT " %d",
			  BBP[i].cache->@1.vheap->free,
			  BBP[i].cache->@1.vheap->size,
			  BBP[i].cache->@1.vheap->newstorage) < 0)
		return -1;
@c
	@:vheapprint(H)@
	@:vheapprint(T)@

	if (BBP[i].options)
		mnstr_printf(s, " %s", BBP[i].options);

	return mnstr_printf(s, "\n");
}

static int
BBPdir_header(stream *s, int n)
{
	if (mnstr_printf(s, "BBP.dir, GDKversion %d\n", GDKLIBRARY) < 0 ||
	    mnstr_printf(s, "%d %d\n", SIZEOF_SIZE_T, SIZEOF_OID) < 0 ||
	    OIDwrite(s) != 0 ||
	    mnstr_printf(s, " BBPsize=%d\n", n) < 0)
		return -1;
	return 0;
}

static int
BBPdir_subcommit(int cnt, bat *subcommit)
{
	FILE *fp;
	stream *s = NULL;
	bat i, j = 1;
	char buf[3000];
	char *p;
	int n;

	assert(subcommit != NULL);

	if ((fp = GDKfilelocate("BBP", "w", "dir")) == NULL)
		goto bailout;
	if ((s = file_wastream(fp, "BBP.dir")) == NULL)
		goto bailout;
	fp = NULL;

	n = BBPsize;

	/* we need to copy the backup BBP.dir to the new, but
	   replacing the entries for the subcommitted bats */
	GDKfilepath(buf, SUBDIR, "BBP", "dir");
	if ((fp = fopen(buf, "r")) == NULL) {
		GDKfilepath(buf, BAKDIR, "BBP", "dir");
		if ((fp = fopen(buf, "r")) == NULL)
			GDKfatal("BBPdir: subcommit attempted without backup BBP.dir.");
	}
	/* read first three lines */
	if (fgets(buf, sizeof(buf), fp) == NULL ||	/* BBP.dir, GDKversion %d */
	    fgets(buf, sizeof(buf), fp) == NULL ||	/* SIZEOF_SIZE_T SIZEOF_OID */
	    fgets(buf, sizeof(buf), fp) == NULL)	/* BBPsize=%d */
		GDKfatal("BBPdir: subcommit attempted with invalid backup BBP.dir.");
	/* second line contains BBPsize */
	if ((p = strstr(buf, "BBPsize")) != NULL)
		sscanf(p, "BBPsize=%d", &n);
	if (n < BBPsize)
		n = BBPsize;

	if (GDKdebug & (IOMASK | 1))
		THRprintf(GDKout, "#BBPdir: writing BBP.dir (%d bats).\n", n);
	IODEBUG {
		THRprintf(GDKout, "#BBPdir start oid=");
		OIDwrite(GDKout);
		THRprintf(GDKout, "\n");
	}

	if (BBPdir_header(s, n) < 0)
		goto bailout;
	n = 0;
	i = 1;
	for (;;) {
		int mask = BBPPERSISTENT;	/* BBP.dir consists of all persistent bats only */

		/* but for subcommits, all except the bats in the list retain their existing mode */
		if (n == 0 && fp != NULL) {
			if (fgets(buf, sizeof(buf), fp) == NULL) {
				fclose(fp);
				fp = NULL;
			} else if (sscanf(buf, "%d", &n) != 1 || n <= 0)
				GDKfatal("BBPdir: subcommit attempted with invalid backup BBP.dir.");
		}
		if (j == cnt && n == 0)
			break;
		if (j < cnt && (n == 0 || subcommit[j] <= n || fp == NULL)) {
			i = subcommit[j];
			if (BBP_status(i) & mask) {
				if (new_bbpentry(s, i) < 0)
					goto bailout;
				IODEBUG new_bbpentry(GDKerr, i);
			}
			if (i == n)
				n = 0;	/* read new entry (i.e. skip this one from old BBP.dir */
			do
				/* go to next, skipping duplicates */
				j++;
			while (j < cnt && subcommit[j] == i);
		} else {
			i = n;
			mnstr_printf(s, "%s", buf);
			IODEBUG mnstr_printf(GDKerr, "%s", buf);
			n = 0;
		}
	}

	mnstr_close(s);
	mnstr_destroy(s);

	IODEBUG THRprintf(GDKout, "#BBPdir end\n");

	return 0;

      bailout:
	if (s != NULL) {
		mnstr_close(s);
		mnstr_destroy(s);
	}
	if (fp != NULL)
		fclose(fp);
	GDKsyserror("BBPdir failed:\n");
	return -1;
}

int
BBPdir(int cnt, bat *subcommit)
{
	FILE *fp;
	stream *s;
	bat i;

	if (subcommit)
		return BBPdir_subcommit(cnt, subcommit);

	if (GDKdebug & (IOMASK | 1))
		THRprintf(GDKout, "#BBPdir: writing BBP.dir (%d bats).\n", (int) BBPsize);
	IODEBUG {
		THRprintf(GDKout, "#BBPdir start oid=");
		OIDwrite(GDKout);
		THRprintf(GDKout, "\n");
	}
	if ((fp = GDKfilelocate("BBP", "w", "dir")) == NULL)
		goto bailout;
	if ((s = file_wastream(fp, "BBP.dir")) == NULL) {
		fclose(fp);
		goto bailout;
	}

	if (BBPdir_header(s, BBPsize) < 0)
		goto bailout;

	for (i = 1; i < BBPsize; i++) {
		int mask = BBPPERSISTENT;	/* BBP.dir consists of all persistent bats */

		/* write the entry */
		if (BBP_status(i) & mask) {
			if (new_bbpentry(s, i) < 0)
				break;
			IODEBUG new_bbpentry(GDKerr, i);
		}
	}

	mnstr_close(s);
	mnstr_destroy(s);

	IODEBUG THRprintf(GDKout, "#BBPdir end\n");

	if (i < BBPsize)
		goto bailout;

	return 0;

      bailout:
	GDKsyserror("BBPdir failed:\n");
	return -1;
}

void
BBPdump()
{
	bat i;
	size_t mem = 0, vm = 0;
	size_t cmem = 0, cvm = 0;
	int n = 0, nc = 0;

	for (i = 0; i < BBPsize; i++) {
		BAT *b = BBP[i].b[0];
		if (b == NULL)
			continue;
		THRprintf(GDKout,
			  "# %d[%s,%s]: nme=['%s','%s'] refs=%d lrefs=%d status=%d count=" BUNFMT " "
			  "Hheap=[" SZFMT "," SZFMT "] Hvheap=[" SZFMT "," SZFMT "] Hhash=[" SZFMT "," SZFMT "] "
			  "Theap=[" SZFMT "," SZFMT "] Tvheap=[" SZFMT "," SZFMT "] Thash=[" SZFMT "," SZFMT "]\n",
			  i,
			  ATOMname(b->H->type),
			  ATOMname(b->T->type),
			  BBP[i].nme[0] ? BBP[i].nme[0] : "<NULL>",
			  BBP[i].nme[1] ? BBP[i].nme[1] : "<NULL>",
			  BBP[i].refs,
			  BBP[i].lrefs,
			  BBP[i].status,
			  BBP[i].b[0]->U->count,
			  HEAPmemsize(&b->H->heap),
			  HEAPvmsize(&b->H->heap),
			  HEAPmemsize(b->H->vheap),
			  HEAPvmsize(b->H->vheap),
			  b->H->hash ? HEAPmemsize(b->H->hash->heap) : 0,
			  b->H->hash ? HEAPvmsize(b->H->hash->heap) : 0,
			  HEAPmemsize(&b->T->heap),
			  HEAPvmsize(&b->T->heap),
			  HEAPmemsize(b->T->vheap),
			  HEAPvmsize(b->T->vheap),
			  b->T->hash ? HEAPmemsize(b->T->hash->heap) : 0,
			  b->T->hash ? HEAPvmsize(b->T->hash->heap) : 0);
		if (BBP[i].nme[0] && BBP[i].nme[0][0] == '.') {
			cmem += HEAPmemsize(&b->H->heap);
			cvm += HEAPvmsize(&b->H->heap);
			nc++;
		} else {
			mem += HEAPmemsize(&b->H->heap);
			vm += HEAPvmsize(&b->H->heap);
			n++;
		}
		if (b->H->vheap) {
			if (BBP[i].nme[0] && BBP[i].nme[0][0] == '.') {
				cmem += HEAPmemsize(b->H->vheap);
				cvm += HEAPvmsize(b->H->vheap);
			} else {
				mem += HEAPmemsize(b->H->vheap);
				vm += HEAPvmsize(b->H->vheap);
			}
		}
		if (b->H->hash) {
			if (BBP[i].nme[0] && BBP[i].nme[0][0] == '.') {
				cmem += HEAPmemsize(b->H->hash->heap);
				cvm += HEAPvmsize(b->H->hash->heap);
			} else {
				mem += HEAPmemsize(b->H->hash->heap);
				vm += HEAPvmsize(b->H->hash->heap);
			}
		}
		if (BBP[i].nme[0] && BBP[i].nme[0][0] == '.') {
			cmem += HEAPmemsize(&b->T->heap);
			cvm += HEAPvmsize(&b->T->heap);
		} else {
			mem += HEAPmemsize(&b->T->heap);
			vm += HEAPvmsize(&b->T->heap);
		}
		if (b->T->vheap) {
			if (BBP[i].nme[0] && BBP[i].nme[0][0] == '.') {
				cmem += HEAPmemsize(b->T->vheap);
				cvm += HEAPvmsize(b->T->vheap);
			} else {
				mem += HEAPmemsize(b->T->vheap);
				vm += HEAPvmsize(b->T->vheap);
			}
		}
		if (b->T->hash) {
			if (BBP[i].nme[0] && BBP[i].nme[0][0] == '.') {
				cmem += HEAPmemsize(b->T->hash->heap);
				cvm += HEAPvmsize(b->T->hash->heap);
			} else {
				mem += HEAPmemsize(b->T->hash->heap);
				vm += HEAPvmsize(b->T->hash->heap);
			}
		}
	}
	THRprintf(GDKout,
		  "# %d bats: mem=" SZFMT ", vm=" SZFMT " %d cached bats: mem=" SZFMT ", vm=" SZFMT "\n",
		  n, mem, vm, nc, cmem, cvm);
}

/*
@}
@+ BBP Readonly Interface

These interface functions do not change the BBP tables. If they only
access one specific BAT, the caller must have ensured that no other thread
is modifying that BAT, therefore such functions do not need locking.
@{
@-
BBP index lookup by BAT name:
@c
*/
@c
static INLINE bat
BBP_find(str nme, int lock)
{
	bat i = BBPnamecheck(nme);

	if (i != 0) {
		/* for tmp_X and tmpr_X BATs, we already know X */
		str s;

		if (ABS(i) >= BBPsize || (s = BBP_logical(i)) == NULL || strcmp(s, nme)) {
			i = 0;
		}
	} else if (*nme != '.') {
		/* must lock since hash-lookup traverses other BATs */
		if (lock)
			gdk_set_lock(GDKnameLock, "BBPindex");
		for (i = BBP_hash[strHash(nme) & BBP_mask]; i; i = BBP_next(i)) {
			if (strcmp(BBP_logical(i), nme) == 0)
				break;
		}
		if (lock)
			gdk_unset_lock(GDKnameLock, "BBPindex");
	}
	return i;
}

bat
BBPindex(str nme)
{
	return BBP_find(nme, TRUE);
}

BATstore *
BBPgetdesc(bat i)
{
	if (i < 0)
		i = -i;
	if (i != bat_nil && i < BBPsize && i && BBP_logical(i)) {
		return BBP_desc(i);
	}
	return NULL;
}

str
BBPlogical(bat bid, str buf)
{
	if (buf == NULL) {
		return NULL;
	} else if (BBPcheck(bid, "BBPlogical")) {
		if (bid < 0 && BBP_logical(bid) == NULL)
			bid = -bid;
		strcpy(buf, BBP_logical(bid));
	} else {
		*buf = 0;
	}
	return buf;
}

str
BBPphysical(bat bid, str buf)
{
	if (buf == NULL) {
		return NULL;
	} else if (BBPcheck(bid, "BBPphysical")) {
		strcpy(buf, BBP_physical(ABS(bid)));
	} else {
		*buf = 0;
	}
	return buf;
}

/*
@}
@+ BBP Update Interface
Operations to insert, delete, clear, and modify BBP entries.
Our policy for the BBP is to provide unlocked BBP access for
speed, but still write operations have to be locked.
@{
#ifdef DEBUG_THREADLOCAL_BATS
Create the shadow version (reversed) of a bat.
@-
An existing BAT is inserted into the BBP
@c
*/
@c
static INLINE str
BBPsubdir_recursive(str s, bat i)
{
	i >>= 6;
	if (i >= 0100) {
		s = BBPsubdir_recursive(s, i);
		*s++ = DIR_SEP;
	}
	i &= 077;
	*s++ = '0' + (i >> 3);
	*s++ = '0' + (i & 7);
	return s;
}

static INLINE void
BBPgetsubdir(str s, bat i)
{
	if (i >= 0100) {
		s = BBPsubdir_recursive(s, i);
	}
	*s = 0;
}

bat
BBPinsert(BATstore *bs)
{
	MT_Id pid = BBP_getpid();
	int lock = locked_by ? pid != locked_by : 1;
	str s;
	long_str dirname;
	bat i;
	int idx = (int) (pid & BBP_THREADMASK);

	assert(bs->B.H != NULL);
	assert(bs->B.T != NULL);
	assert(bs->B.H == bs->BM.T);
	assert(bs->B.T == bs->BM.H);

	/* critical section: get a new BBP entry */
	if (lock) {
		gdk_set_lock(GDKtrimLock(idx), "BBPreplace");
		gdk_set_lock(GDKcacheLock(idx), "BBPinsert");
	}

	/* find an empty slot */
	if (BBP_free(idx) <= 0) {
		/* we need to extend the BBP */
		if (lock) {
			/* we must take all locks in a consistent order
			   so first unset the one we've already got */
			gdk_unset_lock(GDKcacheLock(idx), "BBPinsert");
			for (i = 0; i <= BBP_THREADMASK; i++)
				gdk_set_lock(GDKcacheLock(i), "BBPinsert");
		}
		gdk_set_lock(GDKnameLock, "BBPinsert");
		/* check again in case some other thread extended
		   while we were waiting */
		if (BBP_free(idx) <= 0) {
			if (BBPsize++ >= BBPlimit) {
				BBPextend(BATMARGIN, TRUE);
				/* it seems BBPextend could return and
				   still leaving BBP_free(idx) == 0 */
				if (BBP_free(idx) == 0)
					BBP_free(idx) = BBPsize - 1;
			} else {
				BBP_free(idx) = BBPsize - 1;
			}
		}
		gdk_unset_lock(GDKnameLock, "BBPinsert");
		if (lock)
			for (i = BBP_THREADMASK; i >= 0; i--)
				if (i != idx)
					gdk_unset_lock(GDKcacheLock(i), "BBPinsert");
	}
	i = BBP_free(idx);
	assert(i > 0);
	BBP_free(idx) = BBP_next(BBP_free(idx));

	if (lock) {
		gdk_unset_lock(GDKcacheLock(idx), "BBPinsert");
		gdk_unset_lock(GDKtrimLock(idx), "BBPreplace");
	}
	/* rest of the work outside the lock , as GDKstrdup/GDKmalloc may trigger a BBPtrim */

	/* fill in basic BBP fields for the new bat */

	if (++BBP_curstamp < 0)
		BBP_curstamp = 0;
	bs->B.batCacheid = i;
	bs->BM.batCacheid = -i;
	bs->P.stamp = BBP_curstamp;
	bs->P.tid = BBP_getpid();

	BBP_status_set(i, BBPDELETING, "BBPentry");
	BBP_cache(i) = NULL;
	BBP_desc(i) = NULL;
	BBP_refs(i) = 1;	/* new bats have 1 pin */
	BBP_lrefs(i) = 0;	/* ie. no logical refs */

	if (BBP[i].bak[0] == NULL) {
		s = BBPtmpname(dirname, 64, i);
		BBP_logical(i) = GDKstrdup(s);
		BBP[i].bak[0] = BBP_logical(i);
	} else
		BBP_logical(i) = BBP[i].bak[0];
	s = BBPtmpname(dirname, 64, -i);
	BBP_logical(-i) = GDKstrdup(s);

	/* Keep the physical location around forever */
	if (BBP_physical(i) == NULL) {
		char name[64], *nme;

		BBPgetsubdir(dirname, i);
		nme = BBPphysicalname(name, 64, i);

		BBP_physical(i) = (str) GDKmalloc(strlen(dirname) + strlen(nme) + 1 + 1 /* EOS + DIR_SEP */ );
		GDKfilepath(BBP_physical(i), dirname, nme, NULL);

		BATDEBUG THRprintf(GDKout, "#%d = new %s(%s,%s)\n", (int) i, BBPname(i), ATOMname(bs->H.type), ATOMname(bs->T.type));
	}

	return i;
}

void
BBPcacheit(BATstore *bs, int lock)
{
	bat i = bs->B.batCacheid;
	int mode;

	if (lock)
		lock = locked_by ? BBP_getpid() != locked_by : 1;

	if (i) {
		assert(i > 0);
	} else {
		i = BBPinsert(bs);	/* bat was not previously entered */
		if (bs->H.vheap)
			bs->H.vheap->parentid = i;
		if (bs->T.vheap)
			bs->T.vheap->parentid = i;
	}
	assert(bs->B.batCacheid > 0);
	assert(bs->BM.batCacheid < 0);
	assert(bs->B.batCacheid == -bs->BM.batCacheid);

	if (lock)
		gdk_set_lock(GDKswapLock(i), "BBPcacheit");
	mode = (BBP_status(i) | BBPLOADED) & ~(BBPLOADING | BBPDELETING);
	BBP_status_set(i, mode, "BBPcacheit");
	BBP_lastused(i) = BBPLASTUSED(BBPstamp() + ((mode == BBPLOADED) ? 150 : 0));
	BBP_desc(i) = bs;

	/* cache it! */
	BBP_cache(i) = &bs->B;
	BBP_cache(-i) = &bs->BM;

	if (lock)
		gdk_unset_lock(GDKswapLock(i), "BBPcacheit");
}

/*
@-
@%BBPuncacheit@ changes the BBP status to swapped out.  Currently only
used in BBPfree (bat swapped out) and BBPclear (bat destroyed forever).
@c
*/
@c

void
BBPuncacheit(bat i)
{
	BBPuncacheit_(i, FALSE);
}

static void
BBPuncacheit_(bat i, int unloaddesc)
{
	if (i < 0)
		i = -i;
	if (BBPcheck(i, "BBPuncacheit")) {
		BATstore *bs = BBP_desc(i);

		if (bs) {
			if (BBP_cache(i)) {
				BATDEBUG THRprintf(GDKout, "#uncache %d (%s)\n", (int) i, BBPname(i));

				BBP_cache(i) = BBP_cache(-i) = NULL;

				/* clearing bits can be done without the lock */
				BBP_status_off(i, BBPLOADED, "BBPuncacheit");
			}
			if (unloaddesc) {
				BBP_desc(i) = NULL;
				BATdestroy(bs);
			}
		}
	}
}

/*
@- BBPclear
@%BBPclear@ removes a BAT from the BBP directory forever.
@c
*/
@c
static INLINE void
bbpclear(bat i, int idx, str lock)
{
	BATDEBUG {
		THRprintf(GDKout, "#clear %d (%s)\n", (int) i, BBPname(i));
	}
	BBPuncacheit_(i, TRUE);
	BATDEBUG {
		mnstr_printf(GDKout, "#BBPclear set to unloading %d\n", i);
	}
	BBP_status_set(i, BBPUNLOADING, "BBPclear");
	BBP_refs(i) = 0;
	BBP_lrefs(i) = 0;
	if (lock)
		gdk_set_lock(GDKcacheLock(idx), lock);

	if (BBPtmpcheck(BBP_logical(i)) == 0) {
		gdk_set_lock(GDKnameLock, "bbpclear");
		BBP_delete(i);
		gdk_unset_lock(GDKnameLock, "bbpclear");
	}
	if (BBPtmpcheck(BBP_logical(-i)) == 0) {
		gdk_set_lock(GDKnameLock, "bbpclear");
		BBP_delete(-i);
		gdk_unset_lock(GDKnameLock, "bbpclear");
	}
	if (BBP_logical(i) != BBP[ABS(i)].bak[(i) < 0])
		GDKfree(BBP_logical(i));
	if (BBP_logical(-i) != BBP[ABS(i)].bak[(-i) < 0])
		GDKfree(BBP_logical(-i));
	BBP_status_set(i, 0, "BBPclear");
	BBP_logical(i) = NULL;
	BBP_logical(-i) = NULL;
	BBP_next(i) = BBP_free(idx);
	BBP_free(idx) = i;
	if (lock)
		gdk_unset_lock(GDKcacheLock(idx), lock);
}

void
BBPclear(bat i)
{
	MT_Id pid = BBP_getpid();
	int lock = locked_by ? pid != locked_by : 1;

	if (BBPcheck(i, "BBPclear")) {
		bbpclear(ABS(i), (int) (pid & BBP_THREADMASK), lock ? "BBPclear" : NULL);
	}
}

/*
@}
@- BBP rename

Each BAT has a logical name that is globally unique. Its reverse view can
also be assigned a name, that also has to be globally unique.  The batId is
the same as the logical BAT name.

The default logical name of a BAT is tmp_X, where X is the batCacheid.
Apart from being globally unique, new logical bat names cannot be of the
form tmp_X, unless X is the batCacheid.

Physical names consist of a directory name followed by a logical name suffix.
The directory name is derived from the batCacheid, and is currently organized
in a hierarchy that puts max 64 bats in each directory (see BBPgetsubdir).

Concerning the physical suffix: it is almost always bat_X. This saves us
a whole lot of trouble, as bat_X is always unique and no conflicts can occur.
Other suffixes are only supported in order just for backward compatibility with
old repositories (you won't see them anymore in new repositories).
@{
@c
*/
@c
int
BBPrename(bat bid, str nme)
{
	BAT *b = BBPdescriptor(bid);
	long_str dirname;
	bat tmpid = 0, i;
	int idx;

	if (b == NULL)
		return 0;

	/* If name stays same, do nothing */
	if (BBP_logical(bid) && strcmp(BBP_logical(bid), nme) == 0)
		return 0;

	BBPgetsubdir(dirname, ABS(bid));

	if ((tmpid = BBPnamecheck(nme)) && (bid < 0 || tmpid != bid)) {
		return BBPRENAME_ILLEGAL;
	}
	if (strlen(dirname) + strLen(nme) + 1 >= IDLENGTH) {
		return BBPRENAME_LONG;
	}
	idx = (int) (BBP_getpid() & BBP_THREADMASK);
	gdk_set_lock(GDKtrimLock(idx), "BBPrename");
	gdk_set_lock(GDKnameLock, "BBPrename");
	i = BBP_find(nme, FALSE);
	if (i != 0) {
		gdk_unset_lock(GDKnameLock, "BBPrename");
		gdk_unset_lock(GDKtrimLock(idx), "BBPrename");
		return BBPRENAME_ALREADY;
	}
	BBP_notrim = BBP_getpid();

	/* carry through the name change */
	if (BBP_logical(bid) && BBPtmpcheck(BBP_logical(bid)) == 0) {
		BBP_delete(bid);
	}
	if (BBP_logical(bid) != BBP[ABS(bid)].bak[(bid) < 0])
		GDKfree(BBP_logical(bid));
	BBP_logical(bid) = GDKstrdup(nme);
	if (tmpid == 0) {
		BBP_insert(bid);
	}
	b->batDirtydesc = 1;
	if (b->batPersistence == PERSISTENT) {
		int lock = locked_by ? BBP_getpid() != locked_by : 1;

		if (lock)
			gdk_set_lock(GDKswapLock(i), "BBPrename");
		BBP_status_on(ABS(bid), BBPRENAMED, "BBPrename");
		if (lock)
			gdk_unset_lock(GDKswapLock(i), "BBPrename");
		BBPdirty(1);
	}
	gdk_unset_lock(GDKnameLock, "BBPrename");
	BBP_notrim = 0;
	gdk_unset_lock(GDKtrimLock(idx), "BBPrename");
	return 0;
}

/*
@}

@+ BBP swapping Policy
The BAT can be moved back to disk using the routine @%BBPfree@.
It frees the storage for other BATs. After this call BAT* references
maintained for the BAT are wrong.
We should keep track of dirty unloaded BATs. They may have to be committed
later on, which may include reading them in again.

BBPswappable: may this bat be unloaded?
Only real bats without memory references can be unloaded.
@{
@c
*/
@h
#define BBPswappable(b) ((b) && (b)->batCacheid && BBP_refs((b)->batCacheid) == 0)
#define BBPtrimmable(b) (BBPswappable(b) && b->P->lview == 0 && isVIEW(b) == 0 && (BBP_status((b)->batCacheid)&BBPWAITING) == 0)
/*
@-
The @%BBP_ref@ contains the amount of live references to a BAT.
These might be in recursive BATs, C or MIL variables.  The count is
incremented with @%BBPfix@ and decremented with @%BBPunfix@.
@h
*/
@c
static INLINE void
BBPspin(bat i, str s, int event)
{
	if (BBPcheck(i, "BBPspin") && (BBP_status(i) & event)) {
		lng spin = LL_CONSTANT(0);

		while (BBP_status(i) & event) {
			MT_sleep_ms(1);
			spin++;
		}
		BATDEBUG THRprintf(GDKout, "#BBPspin(%d,%s,%d): " LLFMT " loops\n", (int) i, s, event, spin);
	}
}

static INLINE int
incref(bat i, int logical, int lock)
{
	int refs;
	bat hp, tp, hvp, tvp;
	BATstore *bs;
	BAT *b;
	int load = 0;

	if (i == bat_nil) {
		/* Stefan: May this happen? Or should we better call GDKerror(), here? */
		/* GDKerror("BBPincref() called with bat_nil!\n"); */
		return 0;
	}
	if (i < 0)
		i = -i;

	if (!BBPcheck(i, "BBPincref"))
		return 0;

	if (lock) {
		for (;;) {
			gdk_set_lock(GDKswapLock(i), "BBPincref");
			if (!(BBP_status(i) & (BBPUNSTABLE|BBPLOADING)))
				break;
			/* the BATs is "unstable", try again */
			gdk_unset_lock(GDKswapLock(i), "BBPincref");
			MT_sleep_ms(1);
		}
	}
	/* we have the lock */

	bs = BBP_desc(i);

	/* parent BATs are not relevant for logical refs */
	hp = logical ? 0 : bs->B.H->heap.parentid;
	tp = logical ? 0 : bs->B.T->heap.parentid;
	hvp = logical || bs->B.H->vheap == 0 || bs->B.H->vheap->parentid == i ? 0 : bs->B.H->vheap->parentid;
	tvp = logical || bs->B.T->vheap == 0 || bs->B.T->vheap->parentid == i ? 0 : bs->B.T->vheap->parentid;

	assert(BBP_refs(i) + BBP_lrefs(i) ||
	       BBP_status(i) & (BBPDELETED | BBPSWAPPED));
	if (logical)
		refs = ++BBP_lrefs(i);
	else {
		refs = ++BBP_refs(i);
		if (refs == 1 && (hp || tp || hvp || tvp)) {
			/* If this is a view, we must load the parent
			   BATs, but we must do that outside of the
			   lock.  Set the BBPLOADING flag so that
			   other threads will wait until we're
			   done. */
			BBP_status_on(i, BBPLOADING, "BBPincref");
			load = 1;
		}
	}
	if (lock)
		gdk_unset_lock(GDKswapLock(i), "BBPincref");

	if (load) {
		/* load the parent BATs and set the heap base
		   pointers to the correct values */
		assert(!logical);
		if (hp) {
			incref(hp, 0, lock);
			if (!bs->P.lview) {
				b = getBBPdescriptor(hp, lock);
				bs->B.H->heap.base = b->H->heap.base + (size_t) bs->B.H->heap.base;
				/* if we shared the hash before, share
				   it again note that if the parent's
				   hash is destroyed, we also don't
				   have a hash anymore */
				if (bs->B.H->hash == (Hash *) -1)
					bs->B.H->hash = b->H->hash;
			}
		}
		if (tp) {
			incref(tp, 0, lock);
			if (!bs->P.lview &&
			    bs->B.H != bs->B.T) {  /* mirror? */
				b = getBBPdescriptor(tp, lock);
				bs->B.T->heap.base = b->H->heap.base + (size_t) bs->B.T->heap.base;
				/* if we shared the hash before, share
				   it again note that if the parent's
				   hash is destroyed, we also don't
				   have a hash anymore */
				if (bs->B.T->hash == (Hash *) -1)
					bs->B.T->hash = b->H->hash;
			}
		}
		if (hvp)
			incref(hvp, 0, lock);
		if (tvp)
			incref(tvp, 0, lock);
		/* done loading, release descriptor */
		BBP_status_off(i, BBPLOADING, "BBPincref");
	}
	return refs;
}

int
BBPincref(bat i, int logical)
{
	int lock = locked_by ? BBP_getpid() != locked_by : 1;

	return incref(i, logical, lock);
}

void
BBPshare(bat parent)
{
	int lock = locked_by ? BBP_getpid() != locked_by : 1;

	if (parent < 0)
		parent = -parent;
	if (lock)
		gdk_set_lock(GDKswapLock(parent), "BBPshare");
	(void) incref(parent, TRUE, 0);
	++BBP_cache(parent)->batSharecnt;
	assert(BBP_refs(parent) > 0);
	(void) incref(parent, FALSE, 0);
	if (lock)
		gdk_unset_lock(GDKswapLock(parent), "BBPshare");
}

static INLINE int
decref(bat i, int logical, int releaseShare, int lock)
{
	int refs = 0, swap = 0;
	bat hp = 0, tp = 0, hvp = 0, tvp = 0;
	BAT *b;

	assert(i > 0);
	if (lock)
		gdk_set_lock(GDKswapLock(i), "BBPdecref");
	assert(!BBP_cache(i) || BBP_cache(i)->batSharecnt >= releaseShare);
	if (releaseShare) {
		--BBP_desc(i)->P.sharecnt;
		if (lock)
			gdk_unset_lock(GDKswapLock(i), "BBPdecref");
		return refs;
	}

	while (BBP_status(i) & BBPUNLOADING) {
		if (lock)
			gdk_unset_lock(GDKswapLock(i), "BBPdecref");
		BBPspin(i, "BBPdecref", BBPUNLOADING);
		if (lock)
			gdk_set_lock(GDKswapLock(i), "BBPdecref");
	}

	b = BBP_cache(i);

	/* decrement references by one */
	if (logical) {
		if (BBP_lrefs(i) == 0) {
			GDKerror("BBPdecref: %s does not have logical references.\n", BBPname(i));
			assert(0);
		} else {
			refs = --BBP_lrefs(i);
		}
	} else {
		if (BBP_refs(i) == 0) {
			GDKerror("BBPdecref: %s does not have pointer fixes.\n", BBPname(i));
			assert(0);
		} else {
			assert(b == NULL || b->H->heap.parentid == 0 || BBP_refs(b->H->heap.parentid) > 0);
			assert(b == NULL || b->T->heap.parentid == 0 || BBP_refs(b->T->heap.parentid) > 0);
			assert(b == NULL || b->H->vheap == NULL || b->H->vheap->parentid == 0 || BBP_refs(b->H->vheap->parentid) > 0);
			assert(b == NULL || b->T->vheap == NULL || b->T->vheap->parentid == 0 || BBP_refs(b->T->vheap->parentid) > 0);
			refs = --BBP_refs(i);
			if (b && refs == 0) {
				if ((hp = b->H->heap.parentid) != 0 &&
				    !b->P->lview)
					b->H->heap.base = (char *) (b->H->heap.base - BBP_cache(hp)->H->heap.base);
				if ((tp = b->T->heap.parentid) != 0 &&
				    b->H != b->T &&
				    !b->P->lview)
					b->T->heap.base = (char *) (b->T->heap.base - BBP_cache(tp)->H->heap.base);
				/* if a view shared the hash with its
				   parent, indicate this, but only if
				   view isn't getting destroyed */
				if (hp && b->H->hash &&
				    b->H->hash == BBP_cache(hp)->H->hash)
					b->H->hash = (Hash *) -1;
				if (tp && b->T->hash &&
				    b->T->hash == BBP_cache(tp)->H->hash)
					b->T->hash = (Hash *) -1;
				hvp = VIEWvhparent(b);
				tvp = VIEWvtparent(b);
			}
		}
	}

	/* we destroy transients asap and unload persistent bats only
	   if they have been made cold */
	if (BBP_refs(i) > 0 || (BBP_lrefs(i) > 0 && BBP_lastused(i) != 0)) {
		/* bat cannot be swapped out. renew its last usage
		   stamp for the BBP LRU policy */
		int sec = BBPLASTUSED(BBPstamp());

		if (sec > BBPLASTUSED(BBP_lastused(i)))
			BBP_lastused(i) = sec;
	} else if (b || (BBP_status(i) & BBPTMP)) {
		/* bat will be unloaded now. set the UNLOADING bit
		   while locked so no other thread thinks its
		   available anymore */
		assert((BBP_status(i) & BBPUNLOADING) == 0);
		BATDEBUG {
			mnstr_printf(GDKout, "#BBPdecref set to unloading BAT %d\n", i);
		}
		BBP_status_on(i, BBPUNLOADING, "BBPdecref");
		swap = TRUE;
	}

	/* unlock before re-locking in unload; as saving a dirty
	   persistent bat may take a long time */
	if (lock)
		gdk_unset_lock(GDKswapLock(i), "BBPdecref");

	if (swap) {
		int destroy = BBP_lrefs(i) == 0 && (BBP_status(i) & BBPDELETED) == 0;

		if (b && destroy) {
			int flag = 0;
			if (b->H->heap.parentid == 0)
				flag |= USE_HEAD;
			if (b->T->heap.parentid == 0)
				flag |= USE_TAIL;
			if (flag)
				BATaccessBegin(b, flag, MMAP_DONTNEED);
			BBPdestroy(b);	/* free memory (if loaded) and delete from disk (if transient but saved) */
		} else if (b) {
			BATDEBUG {
				mnstr_printf(GDKout, "#BBPdecref unload and free bat %d\n", i);
			}
			BBP_unload_inc(i, "BBPdecref");
			if (BBPfree(b, "BBPdecref"))	/* free memory of transient */
				return -1;	/* indicate failure */
		}
	}
	if (hp)
		decref(ABS(hp), FALSE, FALSE, lock);
	if (tp)
		decref(ABS(tp), FALSE, FALSE, lock);
	if (hvp)
		decref(ABS(hvp), FALSE, FALSE, lock);
	if (tvp)
		decref(ABS(tvp), FALSE, FALSE, lock);
	return refs;
}

int
BBPdecref(bat i, int logical)
{
	if (BBPcheck(i, "BBPdecref") == 0) {
		return -1;
	}
	if (i < 0)
		i = -i;
	return decref(i, logical, FALSE, TRUE);
}

/*
@-
M5 often changes the physical ref into a logical reference.
This state change consist of the sequence BBPincref(b,TRUE);BBPunfix(b).
A faster solution is given below, because it does not trigger
the BBP management actions, such as garbage collecting the bats.
[first step, initiate code change]
@c
*/
@c
void
BBPkeepref(bat i)
{
	if (i == bat_nil)
		return;
	if (i < 0)
		i = -i;
	if (BBPcheck(i, "BBPkeepref")) {
		int lock = locked_by ? BBP_getpid() != locked_by : 1;

		incref(i, TRUE, lock);
		assert(BBP_refs(i));
		decref(i, FALSE, FALSE, lock);
	}
}

void
BBPreleaselref(bat i)
{
	int lock = locked_by ? BBP_getpid() != locked_by : 1;

	if (i == bat_nil)
		return;
	if (i < 0)
		i = -i;
	assert(BBP_refs(i) > 0);
	decref(i, TRUE, FALSE, lock);
}

void
BBPreleaseref(bat i)
{
        int lock = locked_by ? BBP_getpid() != locked_by : 1;

        if (i == bat_nil)
                return;
        if (i < 0)
                i = -i;
        assert(BBP_refs(i) > 0);
        decref(i, FALSE, FALSE, lock);
}

static INLINE void
GDKunshare(bat parent)
{
	if (parent < 0)
		parent = -parent;
	(void) decref(parent, FALSE, TRUE, TRUE);
	(void) decref(parent, TRUE, FALSE, TRUE);
}

void
BBPunshare(bat parent)
{
	GDKunshare(parent);
}

/*
@-
BBPreclaim is a user-exported function; the common way to destroy a BAT the hard way.

Return values:
-1 = bat cannot be unloaded (it has more than your own memory fix)
 0 = unloaded successfully
 1 = unload failed (due to write-to-disk failure)
@c
*/
@c
int
BBPreclaim(BAT *b)
{
	bat i;
	int lock = locked_by ? BBP_getpid() != locked_by : 1;

	if (b == NULL)
		return -1;
	i = ABS(b->batCacheid);

	assert(BBP_refs(i) == 1);

	return decref(i, 0, 0, lock) <0;
}

/*
@-
BBPdescriptor checks whether BAT needs loading and does so if necessary. You must
have at least one fix on the BAT before calling this.
@c
*/
@c
static BAT *
getBBPdescriptor(bat i, int lock)
{
	int load = FALSE;
	bat j = ABS(i);
	BAT *b = NULL;

	if (!BBPcheck(i, "BBPdescriptor")) {
		return NULL;
	}
	assert(BBP_refs(i));
	if ((b = BBP_cache(i)) == NULL) {

		if (lock)
			gdk_set_lock(GDKswapLock(j), "BBPdescriptor");
		while (BBP_status(j) & BBPWAITING) {	/* wait for bat to be loaded by other thread */
			if (lock)
				gdk_unset_lock(GDKswapLock(j), "BBPdescriptor");
			MT_sleep_ms(1);
			if (lock)
				gdk_set_lock(GDKswapLock(j), "BBPdescriptor");
		}
		if (BBPvalid(j)) {
			b = BBP_cache(i);
			if (b == NULL) {
				load = TRUE;
				BATDEBUG {
					mnstr_printf(GDKout, "#BBPdescriptor set to unloading BAT %d\n", j);
				}
				BBP_status_on(j, BBPLOADING, "BBPdescriptor");
			}
		}
		if (lock)
			gdk_unset_lock(GDKswapLock(j), "BBPdescriptor");
	}
	if (load) {
		IODEBUG THRprintf(GDKout, "#load %s\n", BBPname(i));

		b = BATload_intern(i, lock);
		BBPin++;

		/* clearing bits can be done without the lock */
		BBP_status_off(j, BBPLOADING, "BBPdescriptor");
	}
	return b;
}

BAT *
BBPdescriptor(bat i)
{
	int lock = locked_by ? BBP_getpid() != locked_by : 1;

	return getBBPdescriptor(i, lock);
}

/*
@-
In BBPsave executes unlocked; it just marks the BBP_status of the BAT to BBPsaving, so others
that want to save or unload this BAT must spin lock on the BBP_status field.
@c
*/
@c
int
BBPsave(BAT *b)
{
	int lock = locked_by ? BBP_getpid() != locked_by : 1;
	bat bid = ABS(b->batCacheid);
	int ret = 0;

	if (BBP_lrefs(bid) == 0 || isVIEW(b) || !BATdirty(b))
		/* do nothing */
		return 0;

	if (lock)
		gdk_set_lock(GDKswapLock(bid), "BBPsave");

	if (BBP_status(bid) & BBPSAVING) {
		/* wait until save in other thread completes */
		if (lock)
			gdk_unset_lock(GDKswapLock(bid), "BBPsave");
		BBPspin(bid, "BBPsave", BBPSAVING);
	} else {
		/* save it */
		int flags = BBPSAVING;

		if (DELTAdirty(b)) {
			flags |= BBPSWAPPED;
			BBPdirty(1);
		}
		if (b->batPersistence != PERSISTENT) {
			flags |= BBPTMP;
		}
		BBP_status_on(bid, flags, "BBPsave");
		if (lock)
			gdk_unset_lock(GDKswapLock(bid), "BBPsave");

		IODEBUG THRprintf(GDKout, "#save %s\n", BATgetId(b));

		/* do the time-consuming work unlocked */
		if (BBP_status(bid) & BBPEXISTING)
			ret = BBPbackup(b, FALSE);
		if (ret == 0) {
			BBPout++;
			ret = (BATsave(b) == NULL);
		}
		/* clearing bits can be done without the lock */
		BBP_status_off(bid, BBPSAVING, "BBPsave");
	}
	return ret;
}

/*
@-
TODO merge BBPfree with BATfree? Its function is to prepare a BAT for being
unloaded (or even destroyed, if the BAT is not persistent).
@c
*/
@c
static int BBPaddtobin(BAT *b);
static int
BBPdestroy(BAT *b)
{
	int clear = 1;
	bat hp = b->H->heap.parentid, tp = b->T->heap.parentid;
	bat vhp = VIEWvhparent(b), vtp = VIEWvtparent(b);

	if (isVIEW(b)) {	/* a physical view */
		VIEWdestroy(b);
	} else {
		/* bats that get destroyed must unfix their atoms */
		int (*hunfix) (ptr) = BATatoms[b->htype].atomUnfix;
		int (*tunfix) (ptr) = BATatoms[b->ttype].atomUnfix;
		BUN p, q;
		BATiter bi = bat_iterator(b);

		assert(b->batSharecnt == 0);
		if (hunfix) {
			DELloop(b, p, q) {
				(*hunfix) (BUNhead(bi, p));
			}
			BATloop(b, p, q) {
				(*hunfix) (BUNhead(bi, p));
			}
		}
		if (tunfix) {
			DELloop(b, p, q) {
				(*tunfix) (BUNtail(bi, p));
			}
			BATloop(b, p, q) {
				(*tunfix) (BUNtail(bi, p));
			}
		}
		clear = BBPaddtobin(b);	/* plan for re-use */
	}
	if (clear)
		BBPclear(b->batCacheid);	/* if destroyed; de-register from BBP */

	/* parent released when completely done with child */
	if (hp)
		GDKunshare(hp);
	if (vhp)
		GDKunshare(vhp);
	if (tp)
		GDKunshare(tp);
	if (vtp)
		GDKunshare(vtp);
	return 0;
}

static int
BBPfree(BAT *b, str calledFrom)
{
	bat bid = ABS(b->batCacheid), hp = VIEWhparent(b), tp = VIEWtparent(b), vhp = VIEWvhparent(b), vtp = VIEWvtparent(b);
	int ret;

	assert(BBPswappable(b));

	/* write dirty BATs before being unloaded */
	ret = BBPsave(b);
	if (ret == 0) {
		if (isVIEW(b)) {	/* physical view */
			VIEWdestroy(b);
		} else {
			if (BBP_cache(bid))
				BATfree(b);	/* free memory */
		}
		BBPuncacheit_(bid, FALSE);
	}
	/* clearing bits can be done without the lock */
	BATDEBUG {
		mnstr_printf(GDKout, "#BBPfree turn off unloading %d\n", bid);
	}
	BBP_status_off(bid, BBPUNLOADING, calledFrom);
	BBP_unload_dec(bid, calledFrom);

	/* parent released when completely done with child */
	if (ret == 0 && hp)
		GDKunshare(hp);
	if (ret == 0 && tp)
		GDKunshare(tp);
	if (ret == 0 && vhp)
		GDKunshare(vhp);
	if (ret == 0 && vtp)
		GDKunshare(vtp);
	return ret;
}

/*
@}
@- Storage trimming
BBPtrim unloads the least recently used BATs to free memory resources.
It gets passed targets in bytes of physical memory and logical
virtual memory resources to free. Overhead costs are reduced by
making just one scan, analyzing the first BBPMAXTRIM bats
and keeping the result in a list for later use (the oldest bat
now is going to be the oldest bat in the future as well).
This list is sorted on last-used timestamp. BBPtrim keeps unloading
BATs till the targets are met or there are no more BATs to unload.

In determining whether a BAT will be unloaded, first it has
to be BBPswappable, and second its resources occupied must
be of the requested type. The algorithm actually makes two passes,
in the first only clean bats are unloaded (in order of their stamp).

In order to keep this under control with multiple threads all
running out of memory at the same time, we make sure that
@itemize
@item
just one thread does a BBPtrim at a time (by having a BBPtrimLock set).
@item
while decisions are made as to which bats to unload (1) the BBP is
scanned, and (2) unload decisions are made. Due to these properties,
the search&decide phase of BBPtrim acquires both GDKcacheLock (due to (1))
and all GDKswapLocks (due to (2)). They must be released during the actual
unloading.  (as otherwise deadlock occurs => unloading a bat may e.g. kill
an accelerator that is a BAT, which in turn requires BBP lock acquisition).
@item
to avoid further deadlock, the update functions in BBP that hold either
GDKcacheLock or a GDKswapLock may never cause a BBPtrim (notice that BBPtrim
could theoretically be set off just by allocating a little piece of memory, e.g.
GDKstrdup()). If these routines must alloc memory, they must set the BBP_notrim
variable, acquiring the addition GDKtrimLock, in order to prevent such deadlock.
@item
the BBPtrim is atomic; only releases its locks when all BAT unload
work is done. This ensures that if all memory requests that triggered
BBPtrim could possible be satisfied by unloading BATs, this will succeed.
@end itemize

The scan phase was optimized further in order to stop early when
it is a priori known that the targets are met (which is the case if the
BBPtrim is not due to memory shortage but due to the ndesc quota).
Note that scans may always stop before BBPsize as the BBPMAXTRIM is a fixed
number which may be smaller. As such, a mechanism was added to resume
a broken off scan at the point where scanning was broken off rather than
always starting at BBP[1] (this does more justice to the lower numbered
bats and will more quickly find fresh unload candidates).

We also refined the swap criterion. If the BBPtrim was initiated due to:
- too much descriptors: small bats are unloaded first (from LRU cold to hot)
- too little memory: big bats are unloaded first (from LRU cold to hot).
Unloading-first is enforced by subtracting @math{2^31} from the stamp in the
field where the candidates are sorted on.

BBPtrim is abandoned when the application has indicated that it does not
need it anymore.
@{
@c
*/
@c
#define BBPMAXTRIM 40000
#define BBPSMALLBAT 1000

typedef struct {
	int lastused;		/* bat lastused stamp; sort on this field */
	bat bid;		/* bat id */
	BUN cnt;		/* bat count */
	int next;		/* next position in list */
#if SIZEOF_SIZE_T == 8
	size_t dummy;		/* round up */
#endif
} bbptrim_t;

bbptrim_t bbptrim[BBPMAXTRIM];
int bbptrimfirst = BBPMAXTRIM, bbptrimlast = 0, bbpunloadtail, bbpunload, bbptrimmax = BBPMAXTRIM, bbpscanstart = 1;

static bat
BBPtrim_scan(int mem, int vm, bat bbppos, bat bbplim)
{
	bbptrimlast = 0;
	bbptrimmax = BBPMAXTRIM;
	MEMDEBUG THRprintf(GDKout, "#TRIMSCAN: mem=%d vm=%d, start=%d, limit=%d\n", mem, vm, (int) bbppos, (int) bbplim);

	if (bbppos < BBPsize)
		do {
			if (BBPvalid(bbppos)) {
				BAT *b = BBP_cache(bbppos);

				if (BBPtrimmable(b)) {
					/* when unloading for memory, treat small BATs with a preference over big ones.
					 * rationale: I/O penalty for cache miss is relatively higher for small bats
					 */
					int swap_first = 0;
					BUN cnt = BUN_NONE;

					if (b) {
						cnt = BATcount(b);
						swap_first = (cnt >= BBPSMALLBAT);
					}

					/* however, when we are looking to decrease the number of descriptors,
					 * try to put the small bats in front of the load list instead..
					 */

					/* subtract 2-billion to make sure the swap_first class bats are unloaded first */
					bbptrim[bbptrimlast].lastused = BBPLASTUSED(BBP_lastused(bbppos)) | (swap_first << 31);
					bbptrim[bbptrimlast].bid = bbppos;
					bbptrim[bbptrimlast].cnt = cnt;
					if (++bbptrimlast == bbptrimmax)
						break;
				}
			}
			if (++bbppos == BBPsize)
				bbppos = 1;	/* treat BBP as a circular buffer */
		} while (bbppos != bbplim);

	if (bbptrimlast > 0) {
		int i;
		GDKqsort(bbptrim, NULL, NULL, bbptrimlast, sizeof(bbptrim_t), 0, TYPE_int);
		for (i = bbptrimfirst = 0; i < bbptrimlast; i++) {
			MEMDEBUG THRprintf(GDKout, "#TRIMSCAN: %11d%c %9d=%s\t(#" BUNFMT ")\n", BBPLASTUSED(bbptrim[i].lastused), (bbptrim[i].lastused & 0x80000000) ? '*' : ' ', i, BBPname(bbptrim[i].bid), bbptrim[i].cnt);

			bbptrim[i].next = i + 1;
		}
		bbptrim[bbptrimlast - 1].next = BBPMAXTRIM;
	} else {
		bbptrimfirst = BBPMAXTRIM;
	}
	MEMDEBUG THRprintf(GDKout, "#TRIMSCAN: end at %d (size=%d)\n", bbppos, (int) BBPsize);

	return bbppos;
}


/* insert BATs to unload from bbptrim list into bbpunload list; rebuild bbptrimlist only with the useful leftovers */
static void
BBPtrim_select(size_t *memtarget, size_t *vmtarget, int dirty)
{
	int bbptrimtail = BBPMAXTRIM, next = bbptrimfirst;

	MEMDEBUG THRprintf(GDKout, "#TRIMSELECT: dirty = %d\n", dirty);

	/* make the bbptrim-list empty; we will insert the untouched elements in it */
	bbptrimfirst = BBPMAXTRIM;

	while (next != BBPMAXTRIM) {
		int cur = next;	/* cur is the entry in the old bbptrimlist we are processing */
		int untouched = BBPLASTUSED(BBP_lastused(bbptrim[cur].bid)) <= BBPLASTUSED(bbptrim[cur].lastused);
		BAT *b = BBP_cache(bbptrim[cur].bid);

		next = bbptrim[cur].next;	/* do now, because we overwrite bbptrim[cur].next below */

		MEMDEBUG if (b) {
			THRprintf(GDKout,
				  "#TRIMSELECT: candidate=%s BAT*=" PTRFMT "\n",
				  BBPname(bbptrim[cur].bid),
				  PTRFMTCAST(void *)b);

			THRprintf(GDKout,
				  "#            (cnt=" BUNFMT ", mode=%d, refs=%d, wait=%d, parent=%d,%d, lastused=%d,%d,%d)\n",
				  bbptrim[cur].cnt,
				  b->batPersistence,
				  BBP_refs(b->batCacheid),
				  (BBP_status(b->batCacheid) & BBPWAITING) != 0,
				  VIEWhparent(b),
				  VIEWtparent(b),
				  BBP_lastused(b->batCacheid),
				  BBPLASTUSED(bbptrim[cur].lastused),
				  bbptrim[cur].lastused);
		}
		/* recheck if conditions encountered by trimscan in the past still hold */
		if (BBPtrimmable(b) && untouched) {
			size_t memdelta = BATmemsize(b, FALSE);
			size_t vmdelta = BATvmsize(b, FALSE);
			size_t memdirty = BATmemsize(b, TRUE);
			size_t vmdirty = BATvmsize(b, TRUE);

			if (((b->batPersistence == TRANSIENT &&
			      BBP_lrefs(bbptrim[cur].bid) == 0) || /* needs not be saved when unloaded, OR.. */
			     (vmdirty == 0 && memdirty <= sizeof(BATstore)) || /* the BAT is actually clean, OR.. */
			     dirty) /* we are allowed to cause I/O (second run).. */
			    &&	/* AND ... */
			    ((*memtarget > 0 && (memdelta > 0)) ||
			     (*vmtarget > 0 && (vmdelta > 0))))
				/* there is some reward in terms of memory requirements */
			{
				/* only then we unload! */
				MEMDEBUG {
					THRprintf(GDKout,
						  "#TRIMSELECT: unload %s [" SZFMT "," SZFMT "] bytes [" SZFMT "," SZFMT "] dirty\n",
						  BBPname(b->batCacheid),
						  memdelta,
						  vmdelta,
						  memdirty,
						  vmdirty);
				}
				BATDEBUG {
					mnstr_printf(GDKout,
						      "#BBPtrim_select set to unloading BAT %d\n",
						      bbptrim[cur].bid);
				}
				BBP_status_on(bbptrim[cur].bid, BBPUNLOADING, "BBPtrim_select");
				BBP_unload_inc(bbptrim[cur].bid, "BBPtrim_select");
				*memtarget = *memtarget > memdelta ? *memtarget - memdelta : 0;
				*vmtarget = *vmtarget > vmdelta ? *vmtarget - vmdelta : 0;

				/* add to bbpunload list */
				if (bbpunload == BBPMAXTRIM) {
					bbpunload = cur;
				} else {
					bbptrim[bbpunloadtail].next = cur;
				}
				bbptrim[cur].next = BBPMAXTRIM;
				bbpunloadtail = cur;
			} else if (!dirty) {
				/* do not unload now, but keep around; insert at the end of the new bbptrim list */
				MEMDEBUG {
					THRprintf(GDKout,
						  "#TRIMSELECT: keep %s [" SZFMT "," SZFMT "] bytes [" SZFMT "," SZFMT "] dirty target(mem=" SZFMT " vm=" SZFMT ")\n",
						  BBPname(b->batCacheid),
						  memdelta,
						  vmdelta,
						  memdirty,
						  vmdirty,
						  MAX(0, *memtarget),
						  MAX(0, *vmtarget));
				}
				if (bbptrimtail == BBPMAXTRIM) {
					bbptrimfirst = cur;
				} else {
					bbptrim[bbptrimtail].next = cur;
				}
				bbptrim[cur].next = BBPMAXTRIM;
				bbptrimtail = cur;
			} else {
				/* bats that even in the second (dirty) run are not selected, should be acquitted from the trimlist until a next scan */
				MEMDEBUG THRprintf(GDKout, "#TRIMSELECT: delete %s from trimlist (does not match trim needs)\n", BBPname(bbptrim[cur].bid));
			}
		} else {
			/* BAT was touched (or unloaded) since trimscan =>  it is discarded from both lists */
			char buf[80], *bnme = BBP_logical(bbptrim[cur].bid);

			if (bnme == NULL) {
				bnme = BBPtmpname(buf, 64, bbptrim[cur].bid);
			}
			MEMDEBUG THRprintf(GDKout,
					   "#TRIMSELECT: delete %s from trimlist (has been %s)\n",
					   bnme,
					   b ? "touched since last scan" : "unloaded already");
		}

		if (*memtarget == 0 && *vmtarget == 0) {
			/* we're done; glue the rest of the old bbptrim list to the new bbptrim list */
			if (bbptrimtail == BBPMAXTRIM) {
				bbptrimfirst = next;
			} else {
				bbptrim[bbptrimtail].next = next;
			}
			break;
		}
	}
	MEMDEBUG THRprintf(GDKout, "#TRIMSELECT: end\n");
}

extern int monet_exec(str);

void
BBPtrim(size_t memtarget, size_t vmtarget)
{
	int i, limit, scan, did_scan = FALSE, done = BBP_THREADMASK;
	int msec = 0, bats_written = 0, bats_unloaded = 0;	/* performance info */
	MT_Id t = BBP_getpid();

	PERFDEBUG msec = GDKms();

	if (BBP_notrim == t)
		return;		/* avoid deadlock by one thread going here twice */

	for (i = 0; i <= BBP_THREADMASK; i++)
		gdk_set_lock(GDKtrimLock(i), "BBPtrim");
	BBP_notrim = t;

	/* recheck targets to see whether the work was already done by another thread */
	if (memtarget && memtarget != BBPTRIM_ALL) {
		memtarget = GDKmem_inuse();
		if (memtarget > GDK_mem_maxsize)
			memtarget -= GDK_mem_maxsize;
		else
			memtarget = 0;
	}
	if (vmtarget && vmtarget != BBPTRIM_ALL) {
		vmtarget = GDKvm_cursize();
		if (vmtarget > GDK_vm_maxsize)
			vmtarget -= GDK_vm_maxsize;
		else
			vmtarget = 0;
	}
	MEMDEBUG THRprintf(GDKout,
			   "#BBPTRIM_ENTER: memsize=" SZFMT ",vmsize=" SZFMT "\n",
			   GDKmem_inuse(), GDKvm_cursize());

	MEMDEBUG THRprintf(GDKout,
			   "#BBPTRIM: memtarget=" SZFMT " vmtarget=" SZFMT "\n",
			   memtarget, vmtarget);
	PERFDEBUG THRprintf(GDKout, "#BBPtrim(mem=%d,vm=%d)\n",
			    memtarget > 0, vmtarget > 0);

	scan = (bbptrimfirst == BBPMAXTRIM);
	if (bbpscanstart >= BBPsize)
		bbpscanstart = 1;	/* sometimes, the BBP shrinks! */
	limit = bbpscanstart;

	while (memtarget > 0 || vmtarget > 0) {
		/* check for runtime overruling */
		if (GDK_vm_trim == 0)
			break;
		if (done-- < 0)
			break;
		/* acquire the BBP locks */
		for (i = 0; i <= BBP_THREADMASK; i++)
			gdk_set_lock(GDKcacheLock(i), "BBPtrim");
		for (i = 0; i <= BBP_BATMASK; i++)
			gdk_set_lock(GDKswapLock(i), "BBPtrim");

		/* gather a list of unload candidate BATs, but try to
		   avoid scanning by reusing previous leftovers
		   first */
		if (scan) {
			did_scan = TRUE;
			bbpscanstart = BBPtrim_scan((memtarget > 0), (vmtarget > 0), bbpscanstart, limit);
			scan = (bbpscanstart != limit);
		} else {
			scan = TRUE;
		}

		/* decide which of the candidates to unload using LRU */
		bbpunload = BBPMAXTRIM;
		BBPtrim_select(&memtarget, &vmtarget, FALSE);	/* first try to select only clean BATs */
		if (did_scan && (memtarget > 0 || vmtarget > 0)) {
			BBPtrim_select(&memtarget, &vmtarget, TRUE);	/* if that is not enough, also unload dirty BATs */
		}

		/* release the BBP locks */
		for (i = 0; i <= BBP_BATMASK; i++)
			gdk_unset_lock(GDKswapLock(i), "BBPtrim");
		for (i = 0; i <= BBP_THREADMASK; i++)
			gdk_unset_lock(GDKcacheLock(i), "BBPtrim");

		/* do the unload work unlocked */
		MEMDEBUG THRprintf(GDKout, "#BBPTRIM: %s\n",
				   (bbpunload != BBPMAXTRIM) ? " lastused   batid name" : "no more unload candidates!");

		for (i = bbpunload; i != BBPMAXTRIM; i = bbptrim[i].next) {
			BAT *b = BBP_cache(bbptrim[i].bid);

			if (b == NULL || !(BBP_status(bbptrim[i].bid) & BBPUNLOADING)) {
				IODEBUG THRprintf(GDKout,
						  "BBPtrim: bat(%d) gone\n",
						  bbptrim[i].bid);
				continue;
			}
			MEMDEBUG THRprintf(GDKout, "#BBPTRIM: %9d %7d %s\n",
					   bbptrim[i].lastused,
					   (int) bbptrim[i].bid,
					   BBPname(bbptrim[i].bid));

			bats_written += (b->batPersistence != TRANSIENT && BATdirty(b));
			bats_unloaded++;
			BATDEBUG {
				mnstr_printf(GDKout,
					      "#BBPtrim unloaded and free bat %d\n",
					      b->batCacheid);
			}
			BBPfree(b, "BBPtrim");
		}
		/* continue while we can scan for more candiates */
		if (!scan)
			break;
	}
	/* done trimming */
	MEMDEBUG THRprintf(GDKout, "#BBPTRIM_EXIT: memsize=" SZFMT ",vmsize=" SZFMT "\n", GDKmem_cursize(), GDKvm_cursize());
	PERFDEBUG THRprintf(GDKout, "#BBPtrim(did_scan=%d, bats_unloaded=%d, bats_written=%d) %d ms\n", did_scan, bats_unloaded, bats_written, GDKms() - msec);

	BBP_notrim = 0;
	for (i = BBP_THREADMASK; i >= 0; i--)
		gdk_unset_lock(GDKtrimLock(i), "BBPtrim");
}

void
BBPhot(bat i)
{
	if (i < 0)
		i = -i;
	if (BBPcheck(i, "BBPhot")) {
		int lock = locked_by ? BBP_getpid() != locked_by : 1;

		if (lock)
			gdk_set_lock(GDKswapLock(i), "BBPhot");
		BBP_lastused(i) = BBPLASTUSED(BBPstamp() + 30000);
		if (lock)
			gdk_unset_lock(GDKswapLock(i), "BBPhot");
	}
}

void
BBPcold(bat i)
{
	if (i < 0)
		i = -i;
	if (BBPcheck(i, "BBPcold")) {
		MT_Id pid = BBP_getpid();
		int lock = locked_by ? pid != locked_by : 1;

		gdk_set_lock(GDKtrimLock(pid & BBP_THREADMASK), "BBPcold");
		if (lock)
			gdk_set_lock(GDKswapLock(i), "BBPcold");
		/* make very cold and insert on top of trim list */
		BBP_lastused(i) = 0;
		if (BBP_cache(i) && bbptrimlast < bbptrimmax) {
			bbptrim[--bbptrimmax].lastused = 0;
			bbptrim[bbptrimmax].bid = i;
			bbptrim[bbptrimmax].next = bbptrimfirst;
			bbptrimfirst = bbptrimmax;
		}
		if (lock)
			gdk_unset_lock(GDKswapLock(i), "BBPcold");
		gdk_unset_lock(GDKtrimLock(pid & BBP_THREADMASK), "BBPcold");
	}
}

/*
@}
@-
BBPquickdesc loads a BAT descriptor without loading the entire BAT, of which the
result be used only for a *limited* number of purposes. Specifically, during the
global sync/commit, we do not want to load any BATs that are not already loaded, both
because this costs performance, and because getting into memory shortage during a commit
is extremely dangerous, as the global sync has all the BBPlocks, so no BBPtrim() can be
done to free memory when needed. Loading a BAT tends not to be required, since the commit
actions mostly involve moving some pointers in the BAT descriptor. However, some column
types do require loading the full bat. This is tested by the complexatom() routine. Such
columns are those of which the type has a fix/unfix method, or those that have HeapDelete
methods. The HeapDelete actions are not always required and therefore the BBPquickdesc
is parametrized.
@{
@c
*/
@c
static int
complexatom(int t, int delaccess)
{
	if (t >= 0 && (BATatoms[t].atomFix || (delaccess && BATatoms[t].atomDel))) {
		return TRUE;
	}
	return FALSE;
}

BAT *
BBPquickdesc(bat bid, int delaccess)
{
	BAT *b = BBP_cache(bid);

	if (bid < 0) {
		GDKerror("BBPquickdesc: called with negative batid.\n");
		assert(0);
		return NULL;
	}
	if (b) {
		return b;	/* already cached */
	}
	b = (BAT *) BBPgetdesc(bid);
	if (b == NULL ||
	    complexatom(b->htype, delaccess) ||
	    complexatom(b->ttype, delaccess)) {
		b = BATload_intern(bid, 1);
		BBPin++;
	}
	return b;
}

/*
@}

@+ Small BAT Cache
PETER: rewrote the batcache to make it stable with views and actually faster
       than allocating new bats (I guess that was the purpose of it)

this is tuned to minimizing the needed actions to get a BAT, in particular
we will do no BBPinsert, BUN dimension modifications, BATextends().

it also covers more cases, such as views and TYPE_str

main ideas:
- have [htpe,ttpe] specific lists to O(1) get a BAT from the desired type (bin-lists)
- implement LRU when the cache is full, with O(1) delete cost by using a fifo list
- keep bats in the BBP, as zombies (by invalidating their name)
- support views as void,void bats (they have in common that they lack heaps)
- support TYPE_str as well, zapping their built-in string hash table
- only recycle BATTINY bats. Increase BATTINY to make more BATnews use the cache.
  BATTINY=256 leading to bunheaps ~1K-2K (in balance with ~500byte BAT record)

and then benchmark it (missing in the previous exercise) :

 module(alarm);
 bbp_batcache_minsize(wrd(256));
 @{ var t := time(), i := 0; while((i :+= 1) < 100000) bat(int,int); print(time() - t); @}
 [ 490 ]
 bbp_batcache_minsize(wrd(0));
 @{ var t := time(), i := 0; while((i :+= 1) < 100000) bat(int,int); print(time() - t); @}
 [ 847 ]

so with caching *some* MIL programs can be nearly twice as fast (optimized compile),
though I expect the gains to be smaller in general.
@{
@c
*/
@c
#define BATCACHE_NOTYPE(t) 	(ATOMstorage(t) > TYPE_str || BATatoms[t].atomFix != NULL)
#define BATCACHE_SIZE 		1023	/* max size: 32767 */
#define BATCACHE_DIMS 		6	/* 0,1,2,4,8 byte types + str */
#define BATCACHE_BIN(h,t) 	(batcache_headbin[ATOMstorage(h)]+batcache_tailbin[ATOMstorage(t)])
#define BATCACHE_BUCKETS	2	/* initial value */
#define BATCACHE_MAXBUCKETS	4	/* how big this can ever be */

int batcache_headbin[TYPE_str + 1], batcache_tailbin[TYPE_str + 1];	/* fast bin computation */

typedef signed short batcache_int;	/* make compact, whole structure is < 500 bytes: CPU cache resident  */

int batcache_maxbuckets = BATCACHE_BUCKETS;
@h
extern int batcache_maxbuckets;	/* used in gdk_relop.mx */
@c

/* the list elements, use int as element pointer type (<0 means: no such element) */
typedef struct {
	bat bid;
	batcache_int bin_next, bin_prev;	/* doubly linked list that connects all BATs for a bin */
	batcache_int fifo_next, fifo_prev;	/* doubly linked list for getting the LRU BAT O(1) */
} batcache_elt_t;

typedef struct {
	MT_Lock lock;

	/* each bin starts a bin_next/prev list */
	batcache_int batbin[BATCACHE_DIMS * BATCACHE_DIMS];
	batcache_elt_t elt[BATCACHE_SIZE];	/* main storage */

	/* fifo queue */
	batcache_int first, last;

	/* free list */
	batcache_int free;	/* misuses ->fifo_next for connecting the list */
} batcache_t;

/* we have multiple bat caches for different bat sizes */
static batcache_t batcache[BATCACHE_MAXBUCKETS];

void
BBPdumpcache(void)
{
	int t;

	for (t = 0; t < BATCACHE_MAXBUCKETS; t++) {
		batcache_t *bc = batcache + t;
		int i, p, b;

		if (bc->first == -1 && bc->last == -1) {
			for (b = 0; b < BATCACHE_DIMS * BATCACHE_DIMS; b++)
				if (bc->batbin[b] != -1)
					mnstr_printf(GDKout, "#THREAD %d, BIN %d X\n", t, b);
			continue;
		}
		mnstr_printf(GDKout, "#THREAD %d\nFIFO:", t);
		for (p = -1, i = bc->first; i >= 0; p = i, i = bc->elt[i].fifo_next) {
			mnstr_printf(GDKout, " %d", bc->elt[i].bid);
			if (bc->elt[i].fifo_prev != p)
				mnstr_printf(GDKout, "X");
		}
		if (bc->last != p)
			mnstr_printf(GDKout, "Z");
		mnstr_printf(GDKout, "\n");
		for (b = 0; b < BATCACHE_DIMS * BATCACHE_DIMS; b++) {
			mnstr_printf(GDKout, "#BIN %d:", b);
			for (p = -1, i = bc->batbin[b]; i >= 0; p = i, i = bc->elt[i].bin_next) {
				mnstr_printf(GDKout, " %d", bc->elt[i].bid);
				if (bc->elt[i].bin_prev != p)
					mnstr_printf(GDKout, "X");
			}
			mnstr_printf(GDKout, "\n");
		}
	}
}

static void
BBPinitcache(void)
{
	batcache_int i;
	int j;

	/* initialize the type remap arrays */
	for (i = 0; i < TYPE_str; i++) {
		int k = 0;

		for (j = ATOMsize(i); j; j /= 2)
			k++;
		batcache_headbin[i] = k;
		batcache_tailbin[i] = k * BATCACHE_DIMS;
	}
	batcache_headbin[i] = 5;
	batcache_tailbin[i] = 5 * BATCACHE_DIMS;	/* TYPE_str */

	/* initialize the cache */
	for (j = 0; j < BATCACHE_MAXBUCKETS; j++) {
		MT_init_lock(batcache[j].lock, "GDKbinsLock");

		for (i = 0; i < BATCACHE_SIZE; i++) {
			batcache[j].elt[i].bid = 0;
			batcache[j].elt[i].fifo_next = i + 1;
			batcache[j].elt[i].fifo_prev = i - 1;
			batcache[j].elt[i].bin_next = -1;
			batcache[j].elt[i].bin_prev = -1;
		}
		batcache[j].elt[BATCACHE_SIZE - 1].fifo_next = -1;

		/* initialize the lookup mechanism */
		for (i = 0; i < BATCACHE_DIMS * BATCACHE_DIMS; i++) {
			batcache[j].batbin[i] = -1;
		}
		batcache[j].free = 0;
		batcache[j].first = -1;
		batcache[j].last = -1;
	}
}

/* throw the LRU bat out using the fifo list */
static INLINE batcache_int
batcache_del(batcache_t * bc)
{
	batcache_int i = bc->first;
	bat bid = bc->elt[i].bid;
	BAT *b = BBP_cache(bid);
	int bin = BATCACHE_BIN(b->htype, b->ttype);

	/* manage bin-list */
	batcache_int j = bc->elt[i].bin_prev;

	if (j >= 0) {
		bc->elt[j].bin_next = -1;
	} else {
		bc->batbin[bin] = -1;	/* had a single entry only */
	}
	assert(bc->elt[i].bin_next < 0);	/* LRU: we always delete the last */

	/* manage fifo-list */
	bc->first = bc->elt[i].fifo_next;
	if (bc->first >= 0) {
		bc->elt[bc->first].fifo_prev = -1;
	} else {
		bc->last = -1;
	}

	/* revive and free the old bat */
	assert(b->H->heap.parentid == 0 && b->T->heap.parentid == 0);
	BATfree(b);		/* maybe unsafe without lock ? */
	*BBP_logical(bid) = 't';
	assert(bc - batcache < batcache_maxbuckets);
	bbpclear(bid, (int) (bc - batcache), "batcache_del");
	return i;
}

/* insert a new bat into the cache */
static INLINE int
batcache_put(batcache_t * bc, int bin, bat bid)
{
	/* get a free slot */
	batcache_int j, i;
	MT_set_lock(bc->lock, "batcache_put");

	i = bc->free;
	if (i >= 0) {
		bc->free = bc->elt[i].fifo_next;
	} else {
		i = batcache_del(bc);	/* delete a bat from the cache */
	}

	/* fill in the batcache record */
	bc->elt[i].bid = bid;
	bc->elt[i].bin_next = j = bc->batbin[bin];
	if (j >= 0)
		bc->elt[j].bin_prev = i;
	bc->elt[i].bin_prev = -1;
	bc->elt[i].fifo_next = -1;
	bc->elt[i].fifo_prev = bc->last;
	bc->batbin[bin] = i;
	if (bc->first < 0)
		bc->first = i;
	if (bc->last >= 0)
		bc->elt[bc->last].fifo_next = i;
	bc->last = i;

	/* make the bat a zombie */
	*BBP_logical(bid) = '.';
	*BBP_logical(-bid) = '.';

	MT_unset_lock(bc->lock, "batcache_put");

	return i;
}

/* return and revive a cached bat from the cache */
static INLINE bat
batcache_get(batcache_t * bc, int bin)
{
	batcache_int i;
	bat bid = 0;

	MT_set_lock(bc->lock, "batcache_get");

	i = bc->batbin[bin];
	if (i >= 0) {
		/* manage fifo-list */
		batcache_int j = bc->elt[i].fifo_prev;
		batcache_int k = bc->elt[i].fifo_next;

		bid = bc->elt[i].bid;

		if (j < 0) {
			assert(bc->first == i);
			bc->first = k;
		} else {
			bc->elt[j].fifo_next = k;
		}
		if (k < 0) {
			assert(bc->last == i);
			bc->last = j;
		} else {
			bc->elt[k].fifo_prev = j;
		}
		bc->elt[i].fifo_next = bc->free;
		bc->free = i;

		/* manage bin-list */
		bc->batbin[bin] = j = bc->elt[i].bin_next;
		if (j >= 0)
			bc->elt[j].bin_prev = -1;

		/* revive the bat */
		*BBP_logical(bid) = 't';
		*BBP_logical(-bid) = 't';
		BBP_refs(bid)++;

		BATDEBUG {
			mnstr_printf(GDKout, "#BBPrecycle turn off unloading %d\n", bid);
		}
		/* clearing bits can be done without the lock */
		BBP_status_off(bid, BBPUNLOADING, "BBPrecycle");
	}
	MT_unset_lock(bc->lock, "batcache_get");

	return bid;
}

extern char *BATstring_h;
extern char *BATstring_t;

static int
BBPaddtobin(BAT *b)
{
	int bin = BATCACHE_BIN(b->htype, b->ttype);
	bat bid = b->batCacheid, hp = VIEWhparent(b), tp = VIEWtparent(b);
	char *s = BBP_logical(bid);
	char *sm = BBP_logical(-bid);
	BAT *m = BBP_cache(-bid);

	/* only cache simple non-saved non-renamed transient bats */
	if (m == NULL ||
	    batcache_maxbuckets == 0 ||
	    b->batCopiedtodisk ||
	    b->H->heap.storage != STORE_MEM ||
	    b->T->heap.storage != STORE_MEM ||
	    b->P->lview ||
	    BBPtmpcheck(s) == 0 ||
	    BBPtmpcheck(sm) == 0 ||
	    (b->htype == TYPE_str && b->H->width > 1) ||
	    (b->ttype == TYPE_str && b->T->width > 1) ||
	    b->htype > TYPE_str ||
	    b->ttype > TYPE_str ||
	    VIEWvhparent(b) ||
	    VIEWvtparent(b)) {
		BATDEBUG THRprintf(GDKout, "#BBPaddtobin %d %d " BUNFMT " %d N1\n", b->htype, b->ttype, b->U->capacity, bin);
		BATdelete(b);	/* handles persistent case also (file deletes) */
		return 1;
	}
	if ((hp == 0 && tp == 0) && (b->htype | b->ttype)) {
		/* additional restrictions do not hold for views and void,void bats */
		/* bat should be of the right size, types and BUN layout */
		if (b->U->capacity > (BUN) BATTINY * batcache_maxbuckets ||
		    (b->U->capacity & ((BUN) BATTINY - 1)) != 0 ||
		    BATCACHE_NOTYPE(b->htype) ||
		    BATCACHE_NOTYPE(b->ttype)) {
			BATDEBUG THRprintf(GDKout, "#BBPaddtobin %d %d " BUNFMT " %d N2\n", b->htype, b->ttype, b->U->capacity, bin);
			BATdelete(b);	/* handles persistent case also (file deletes) */
			return 1;
		}
	}
	assert(BBP_refs(bid) == 0);
	assert(BBP_lrefs(bid) == 0);
	assert(b->batCacheid > 0);

	BATDEBUG THRprintf(GDKout, "#BBPaddtobin %d %d " BUNFMT " %d Y\n", b->htype, b->ttype, b->U->capacity, bin);
	/* change views into void,void bats */
	if (hp || tp) {
		BATstore *bs = BBP_desc(b->batCacheid);

		/* cut view loose from parent */
		VIEWunlink(b);
		if (hp)
			GDKunshare(hp);
		if (tp)
			GDKunshare(tp);
		assert(VIEWvhparent(b) == 0);
		assert(VIEWvtparent(b) == 0);
		b->H->heap.parentid = b->T->heap.parentid = 0;
		b->H->heap.forcemap = 0;
		b->T->heap.forcemap = 0;
		b->batPersistence = TRANSIENT;

		/* take care of mirror views */
		bs->B.H = &bs->H;
		bs->B.T = &bs->T;
		bs->BM.H = &bs->T;
		bs->BM.T = &bs->H;

		/* make it a void,void bat */
		b->H->type = TYPE_void;
		b->H->key = FALSE;
		b->H->varsized = TRUE;
		b->H->shift = 0;
		b->H->width = 0;
		b->H->seq = oid_nil;

		b->T->type = TYPE_void;
		b->T->key = FALSE;
		b->T->varsized = TRUE;
		b->T->shift = 0;
		b->T->width = 0;
		b->T->seq = oid_nil;

		bin = BATCACHE_BIN(b->htype, b->ttype);

		/* was shared with parent! */
		b->H->heap.base = b->T->heap.base = NULL;
		b->H->vheap = b->T->vheap = NULL;
	}
	/* free non-reusable stuff that has to be freed anyway */
	if (b->hident != BATstring_h) {
		if (b->hident)
			GDKfree(b->hident);
		b->hident = BATstring_h;
	}
	if (b->tident != BATstring_t) {
		if (b->tident)
			GDKfree(b->tident);
		b->tident = BATstring_t;
	}
	if (b->H->hash)
		HASHremove(b);
	if (b->T->hash)
		HASHremove(BBPcache(-bid));
	if (b->H->props) {
		PROPdestroy(b->H->props);
		b->H->props = NULL;
	}
	if (b->T->props) {
		PROPdestroy(b->T->props);
		b->T->props = NULL;
	}

	batcache_put(batcache + (bin == 0 ? 0 : (b->U->capacity >> BATTINY_BITS) - 1), bin, b->batCacheid);
	return 0;
}

BATstore *
BBPrecycle(int ht, int tt, size_t cap)
{
	int bin = BATCACHE_BIN(ht, tt);
	bat bid = 0;
	BATstore *bs;

	if (ht == TYPE_void && tt == TYPE_void)
		cap = BATTINY;
	if (batcache_maxbuckets == 0 ||
	    cap > batcache_maxbuckets * (BUN) BATTINY ||
	    BATCACHE_NOTYPE(ht) ||
	    BATCACHE_NOTYPE(tt)) {
		BATDEBUG THRprintf(GDKout, "#BBPrecycle %d %d " SZFMT " (%d, %d %d %d) N1\n", ht, tt, cap, BATCACHE_NOTYPE(ht), BATCACHE_NOTYPE(tt), batcache_maxbuckets, bin);
		return NULL;
	}

	assert((cap & (BATTINY - 1)) == 0);

	bid = batcache_get(batcache + (bin == 0 ? 0 : (cap >> BATTINY_BITS) - 1), bin);
	bs = BBP_desc(bid);
	if (bs) {
		BATDEBUG THRprintf(GDKout, "#BBPrecycle %d %d " SZFMT " (%d, %d %d %d) Y\n", ht, tt, cap, BATCACHE_NOTYPE(ht), BATCACHE_NOTYPE(tt), batcache_maxbuckets, bin);
		/* make the bat empty; do this extra work only if the bat is reused (not in BBPaddtobin) */
		bs->H.type = ht;
		bs->H.varsized = BATatoms[bs->H.type].varsized;
		bs->H.sorted = ATOMlinear(ht) ? GDK_SORTED : 0;
		if (ht == TYPE_str)
			bs->H.width = 1;
		bs->H.align = 0;
		bs->H.key = FALSE;
		bs->H.dense = 0;
		bs->H.nonil = 1;
		bs->H.nil = 0;
		bs->H.seq = (ht == TYPE_void) ? oid_nil : 0;

		bs->T.type = tt;
		bs->T.varsized = BATatoms[bs->T.type].varsized;
		bs->T.sorted = ATOMlinear(tt) ? GDK_SORTED : 0;
		if (tt == TYPE_str)
			bs->T.width = 1;
		bs->T.align = 0;
		bs->T.key = FALSE;
		bs->T.dense = 0;
		bs->T.nonil = 1;
		bs->T.nil = 0;
		bs->T.seq = (tt == TYPE_void) ? oid_nil : 0;

		bs->P.set = FALSE;
		bs->U.first = bs->U.inserted = bs->U.deleted = 0;
		bs->P.restricted = 0;
		bs->H.heap.free = 0;
		bs->T.heap.free = 0;
		bs->P.dirty = TRUE;
		bs->P.stamp = 0;

		BATsetcount(&bs->B, 0);

		if (bs->H.vheap)
			memset(bs->H.vheap->base, 0, bs->H.vheap->free = GDK_STRHASHTABLE * sizeof(stridx_t));
		if (bs->T.vheap)
			memset(bs->T.vheap->base, 0, bs->T.vheap->free = GDK_STRHASHTABLE * sizeof(stridx_t));
		return bs;
	}
	BATDEBUG THRprintf(GDKout, "#BBPrecycle %d %d " SZFMT " (%d, %d %d %d) N2\n", ht, tt, cap, BATCACHE_NOTYPE(ht), BATCACHE_NOTYPE(tt), batcache_maxbuckets, bin);
	return NULL;
}

/* query and change the minimum bat size to cache */
wrd
BBPrecycle_minsize(wrd val)
{
	if (val != wrd_nil) {
		int j;		/* flush the caches */

		for (j = 0; j < batcache_maxbuckets; j++) {
			gdk_set_lock(batcache[j].lock, "BBPrecycle_minsize");

			while (batcache[j].first >= 0) {
				batcache_int i = batcache_del(batcache + j);

				batcache[j].elt[i].fifo_next = batcache[j].free;
				batcache[j].free = i;
			}
			gdk_unset_lock(batcache[j].lock, "BBPrecycle_minsize");
		}
		batcache_maxbuckets = (int) ((val + BATTINY - 1) / BATTINY);
		if (batcache_maxbuckets < 0)
			batcache_maxbuckets = 0;
		if (batcache_maxbuckets > BATCACHE_MAXBUCKETS)
			batcache_maxbuckets = BATCACHE_MAXBUCKETS;
	}
	val = (wrd) (batcache_maxbuckets * BATTINY);
	return val;
}

/*
@}

@+ Global Commit

@{
@c
*/
@c
static BAT *
dirty_bat(bat *i, int subcommit)
{
	if (BBPvalid(*i)) {
		BAT *b;
		BBPspin(*i, "dirty_bat", BBPSAVING);
		b = BBP_cache(*i);
		if (b != NULL) {
			if ((BBP_status(*i) & BBPNEW) && BATcheckmodes(b, FALSE))	/* check mmap modes */
				*i = 0;	/* error */
			if ((BBP_status(*i) & BBPPERSISTENT) &&
			    (subcommit || BATdirty(b)))
				return b;	/* the bat is loaded, persistent and dirty */
		} else if (BBP_status(*i) & BBPSWAPPED) {
			b = (BAT *) BBPquickdesc(*i, TRUE);
			if (b && (subcommit || b->batDirtydesc))
				return b;	/* only the desc is loaded & dirty */
		}
	}
	return NULL;
}

/*
@}

@- backup-bat
Backup-bat moves all files of a BAT to a backup directory. Only after this
succeeds, it may be saved. If some failure occurs halfway saving, we
can thus always roll back.
@{
@c
*/
@c
static int
file_move(str srcdir, str dstdir, str name, str e)
{
	long_str ext;
	int ret = 0;

	strcpy(ext, e);
	ret = GDKmove(srcdir, name, ext, dstdir, name, ext);
	if (ret == 0) {
		return 0;
	} else {
		long_str path;
		struct stat st;

		GDKfilepath(path, srcdir, name, ext);
		if (stat(path, &st)) {
			/* source file does not exist; the best recovery is to give an error but continue
			 * by considering the BAT as not saved; making sure that this time it does get saved.
			 */
			return 2;	/* indicate something fishy, but not fatal */
		}
	}
	return 1;
}

/* returns 1 if the file exists */
static int
file_exists(str dir, str name, str ext)
{
	long_str path;
	struct stat st;
	int ret;

	GDKfilepath(path, dir, name, ext);
	ret = stat(path, &st);
	IODEBUG THRprintf(GDKout, "#stat(%s) = %d\n", path, ret);
	return (ret == 0);
}

static int
heap_move(Heap *hp, str srcdir, str dstdir, str nme, str ext)
{
	/* see doc at BATsetaccess()/gdk_bat.mx for an expose on mmap heap modes */
	if (file_exists(dstdir, nme, ext)) {
		return 0;	/* dont overwrite heap with the committed state already in dstdir */
	} else if (hp->filename &&
		   hp->newstorage == STORE_PRIV &&
		   !file_exists(srcdir, nme, ext)) {

		/* In order to prevent half-saved X.new files surviving a
		 * recover we create a dummy file in the BACKUP(dstdir)
		 * whose presence will trigger BBPrecover to remove them.
		 * Thus, X will prevail where it otherwise wouldn't have.
		 * If X already has a saved X.new, that one is backed up
		 * as normal.
		 */

		FILE *fp;
		long_str kill_ext;
		long_str path;

		strcpy(kill_ext, ext);
		strcat(kill_ext, ".kill");
		GDKfilepath(path, dstdir, nme, kill_ext);
		fp = fopen(path, "w");
		IODEBUG THRprintf(GDKout, "#open %s = %d\n", path, fp ? 0 : -1);

		if (fp != NULL) {
			fclose(fp);
			return 0;
		} else {
			return 1;
		}
	}
	return file_move(srcdir, dstdir, nme, ext);
}

/*
@}

@- BBPprepare

this routine makes sure there is a BAKDIR/, and initiates one if not.
For subcommits, it does the same with SUBDIR.

It is now locked, to get proper file counters, and also to prevent
concurrent BBPrecovers, etc.

backup_dir == 0 => no backup BBP.dir
backup_dir == 1 => BBP.dir saved in BACKUP/
backup_dir == 2 => BBP.dir saved in SUBCOMMIT/
@{
@c
*/
@c
static int backup_files = 0, backup_dir = 0, backup_subdir = 0;

static int
BBPprepare(bit subcommit)
{
	int start_subcommit, ret = 0, set = 1 + subcommit;

	/* tmLock is only used here, helds usually very shortly just to protect the file counters */
	gdk_set_lock(GDKtmLock, "BBPprepare");

	start_subcommit = (subcommit && backup_subdir == 0);
	if (start_subcommit) {
		/* starting a subcommit. Make sure SUBDIR and DELDIR are clean */
		ret = (BBPrecover_subdir() < 0);
	}
	if (backup_files == 0) {
		struct stat st;

		backup_dir = 0;
		ret = (stat(BAKDIR, &st) == 0 && BBPrecover());

		if (ret == 0) {
			/* make a new BAKDIR */
			ret = mkdir(BAKDIR, 0755);
			IODEBUG THRprintf(GDKout, "#mkdir %s = %d\n", BAKDIR, ret);
		}
	}
	if (ret == 0 && start_subcommit) {
		/* make a new SUBDIR (subdir of BAKDIR) */
		ret = mkdir(SUBDIR, 0755);
		IODEBUG THRprintf(GDKout, "#mkdir %s = %d\n", SUBDIR, ret);
	}
	if (ret == 0 && backup_dir != set) {
		/* a valid backup dir *must* at least contain BBP.dir */
		if (GDKmove(backup_dir ? BAKDIR : BATDIR, "BBP", "dir", subcommit ? SUBDIR : BAKDIR, "BBP", "dir")) {
			ret = 1;
		} else {
			backup_dir = set;
		}
	}
	/* increase counters */
	if (ret == 0) {
		backup_subdir += subcommit;
		backup_files++;
	}
	gdk_unset_lock(GDKtmLock, "BBPprepare");

	return ret ? -1 : 0;
}

int
BBPbackup(BAT *b, bit subcommit)
{
	long_str srcdir, nme;
	str s = BBP_physical(b->batCacheid);
	int ret = 0;

	if (BBPprepare(subcommit)) {
		return -1;
	}
	if (b->batCopiedtodisk == 0 || nme == NULL || b->batPersistence != PERSISTENT) {
		return 0;
	}
	/* determine location dir and physical suffix */
	GDKfilepath(srcdir, BATDIR, s, NULL);
	s = strrchr(srcdir, DIR_SEP);
	if (!s)
		return -1;
	strcpy(nme, ++s);
	srcdir[s - srcdir] = 0;

@= backup
	if (@2 && @2->storage != STORE_MMAP) { /* direct mmap is unprotected (readonly usage, or has WAL protection)  */
		/* STORE_PRIV saves into X.new files. Two cases could happen.
		   The first is when a valid X.new exists because of
		   an access change or a previous commit. This X.new
		   should be backed up as usual. The second case is
		   when X.new doesn't exist. In that case we could
		   have half written X.new files (after a crash). To
		   protect against these we write X.new.kill files in
		   the backup directory (see heap_move).
		*/
		str ext = (@2->filename && @2->newstorage == STORE_PRIV) ? "@1.new" : "@1";
   		int mvret = 0;
		if (@3 && @4 && !file_exists(BAKDIR, nme, ext)) {
                	/* file will be saved (is dirty), move the old image into backup */
		        mvret = heap_move(@2, srcdir, subcommit ? SUBDIR : BAKDIR, nme, ext);
       		} else if (subcommit && @3 && (@4 || file_exists(BAKDIR, nme, ext))) {
                	/* file is clean. move the backup into the subcommit dir (commit should eliminate backup) */
			mvret = file_move(BAKDIR, SUBDIR, nme, ext);
		}
		/* there is a situation where the move may fail, namely if this heap was not supposed
                 * to be existing before, i.e. after a BATmaterialize on a persistent bat
                 * as a workaround, do not complain about move failure if the source file is nonexistent
 		 */
		if (mvret && file_exists(srcdir, nme, ext)) {
			ret |= mvret;
		}
       		if (subcommit && (@2->storage == STORE_PRIV || @2->newstorage == STORE_PRIV)) {
			long_str kill_ext;
			strcpy(kill_ext, ext);
			strcat(kill_ext, ".new.kill");
			if (file_exists(BAKDIR, nme, kill_ext)) {
				ret |= file_move(BAKDIR, SUBDIR, nme, kill_ext);
			}
		}
		if (ret) return -1;
	}
@c
	@:backup(head,(&b->H->heap), b->htype, (b->batDirty || b->H->heap.dirty))@
	@:backup(tail,(&b->T->heap), b->ttype, (b->batDirty || b->T->heap.dirty))@
	@:backup(hheap,b->H->vheap, b->htype && b->hvarsized, (b->batDirty || (b->H->vheap && b->H->vheap->dirty)))@
	@:backup(theap,b->T->vheap, b->ttype && b->tvarsized, (b->batDirty || (b->T->vheap && b->T->vheap->dirty)))@
	return 0;
}

/*
@}

@+ Atomic Write
The atomic BBPsync() function first safeguards the old images of all files
to be written in BAKDIR. It then saves all files. If that succeeds
fully, BAKDIR is renamed to DELDIR. The rename is considered an
atomic action. If it succeeds, the DELDIR is removed.
If something fails, the pre-sync status can be obtained by moving
back all backed up files; this is done by BBPrecover().

The BBP.dir is also moved into the BAKDIR.

@{
@c
*/
@c
int
BBPsync(int cnt, bat *subcommit)
{
	int ret = 0, bbpdirty = 0;
	int t0 = 0, t1 = 0;

	PERFDEBUG t0 = t1 = GDKms();

	ret = BBPprepare(subcommit != NULL);

	/* PHASE 1: safeguard everything in a backup-dir */
	bbpdirty = BBP_dirty;
	if (OIDdirty()) {
		bbpdirty = BBP_dirty = 1;
	}
	if (ret == 0) {
		int idx = 0;

		while (++idx < cnt) {
			bat i = subcommit ? subcommit[idx] : idx;
			BAT *b = dirty_bat(&i, subcommit != NULL);
			if (i <= 0)
				break;
			if (BBP_status(i) & BBPEXISTING) {
				if (b != NULL && BBPbackup(b, subcommit != NULL))
					break;
			}
		}
		ret = (idx < cnt);
	}
	PERFDEBUG THRprintf(GDKout, "#BBPsync (move time %d) %d files\n", (t1 = GDKms()) - t0, backup_files);

	/* PHASE 2: save the repository */
	if (ret == 0) {
		int idx = 0;

		while (++idx < cnt) {
			bat i = subcommit ? subcommit[idx] : idx;

			if (BBP_status(i) & BBPPERSISTENT) {
				BAT *b = dirty_bat(&i, subcommit != NULL);
				if (i <= 0)
					break;
				if (b != NULL && BATsave(b) == NULL)
					break;	/* write error */
			}
		}
		ret = (idx < cnt);
	}

	PERFDEBUG THRprintf(GDKout, "#BBPsync (write time %d)\n", (t0 = GDKms()) - t1);

	if (ret == 0) {
		if (bbpdirty) {
			ret = BBPdir(cnt, subcommit);
		} else if (backup_dir && GDKmove((backup_dir == 1) ? BAKDIR : SUBDIR, "BBP", "dir", BATDIR, "BBP", "dir")) {
			ret = -1;	/* tried a cheap way to get BBP.dir; but it failed */
		} else {
			/* commit might still fail; we must remember that we moved BBP.dir out of BAKDIR */
			backup_dir = 0;
		}
	}

	PERFDEBUG THRprintf(GDKout, "#BBPsync (dir time %d) %d bats\n", (t1 = GDKms()) - t0, BBPsize);

	if (bbpdirty || backup_files > 0) {
		if (ret == 0) {
			char *bakdir = subcommit ? SUBDIR : BAKDIR;

			/* atomic switchover */
			/* this is the big one: this call determines
			 * whether the operation of this function
			 * succeeded, so no changing of ret after this
			 * call anymore */
			ret = rename(bakdir, DELDIR);
			if (ret && GDKremovedir(DELDIR) == 0)	/* maybe there was an old deldir */
				ret = rename(bakdir, DELDIR);
			if (ret)
				GDKsyserror("BBPsync: rename(%s,%s) failed.\n", bakdir, DELDIR);
			IODEBUG THRprintf(GDKout, "#BBPsync: rename %s %s = %d\n", bakdir, DELDIR, ret);
		}

		/* AFTERMATH */
		if (ret == 0) {
			BBP_dirty = 0;
			backup_files = subcommit ? (backup_files - backup_subdir) : 0;
			backup_dir = backup_subdir = 0;
			(void) GDKremovedir(DELDIR);
			(void) BBPprepare(0);	/* (try to) remove DELDIR and set up new BAKDIR */
		}
	}
	PERFDEBUG THRprintf(GDKout, "#BBPsync (ready time %d)\n", (t0 = GDKms()) - t1);

	return ret;
}

/*
@}
@-
Recovery just moves all files back to their original location. this is an incremental
process: if something fails, just stop with still files left for moving in BACKUP/.
The recovery process can resume later with the left over files.
@{
@c
*/
@c
static int
force_move(str srcdir, str dstdir, str name)
{
	char *p;
	long_str srcpath, dstpath, killfile;
	int ret = 0;

	if ((p = strrchr(name, '.')) != NULL && strcmp(p, ".kill") == 0) {
		/* Found a X.new.kill file, ie remove the X.new file */
		struct stat st;
		ptrdiff_t len = p - name;

		strncpy(srcpath, name, len);
		srcpath[len] = '\0';
		GDKfilepath(dstpath, dstdir, srcpath, NULL);

		/* step 1: remove the X.new file that is going to be overridden by X */
		if (stat(dstpath, &st) == 0) {
			ret = unlink(dstpath);	/* clear destination */
			if (ret) {
				/* if it exists and cannot be removed, all this is going to fail */
				GDKsyserror("force_move: unlink(%s)\n", dstpath);
				return ret;
			}
		}

		/* step 2: now remove the .kill file. This one is crucial, otherwise we'll never finish recovering */
		GDKfilepath(killfile, srcdir, name, NULL);
		ret = unlink(killfile);
		if (ret) {
			GDKsyserror("force_move: unlink(%s)\n", killfile);
			return ret;
		}
		return 0;
	}
	/* try to rename it */
	ret = GDKmove(srcdir, name, NULL, dstdir, name, NULL);

	if (ret) {
		/* two legal possible causes: file exists or dir notexist */
		GDKfilepath(dstpath, dstdir, name, NULL);
		GDKfilepath(srcpath, srcdir, name, NULL);
		ret = unlink(dstpath);	/* clear destination */
		IODEBUG THRprintf(GDKout, "#unlink %s = %d\n", dstpath, ret);

		if (GDKcreatedir(dstdir))
			ret = 0;
		ret = GDKmove(srcdir, name, NULL, dstdir, name, NULL);
		if (ret)
			GDKsyserror("force_move: link(%s,%s)=%d\n", srcpath, dstpath, ret);
		IODEBUG THRprintf(GDKout, "#link %s %s = %d\n", srcpath, dstpath, ret);
	}
	return ret;
}

int
BBPrecover(void)
{
	DIR *dirp = opendir(BAKDIR);
	struct dirent *dent;
	long_str path, dstpath;
	bat i;
	size_t j = strlen(BATDIR);
	int ret = 0, dirseen = FALSE;
	str dstdir;

	if (dirp == NULL) {
		return 0;	/* nothing to do */
	}
	memcpy(dstpath, BATDIR, j);
	dstpath[j] = DIR_SEP;
	dstpath[++j] = 0;
	dstdir = dstpath + j;
	IODEBUG THRprintf(GDKout, "#BBPrecover(start)\n");

	mkdir(LEFTDIR, 0755);

	/* move back all files */
	while ((dent = readdir(dirp)) != NULL) {
		str q = strchr(dent->d_name, '.');

		if (q == dent->d_name) {
			int uret;

			if (strcmp(dent->d_name, ".") == 0 ||
			    strcmp(dent->d_name, "..") == 0)
				continue;
			GDKfilepath(path, BAKDIR, dent->d_name, NULL);
			uret = unlink(path);
			IODEBUG THRprintf(GDKout, "#unlink %s = %d\n", path, uret);

			continue;
		} else if (strcmp(dent->d_name, "BBP.dir") == 0) {
			dirseen = TRUE;
			continue;
		}
		if (q == NULL)
			q = dent->d_name + strlen(dent->d_name);
		if ((j = q - dent->d_name) + 1 > sizeof(path)) {
			/* name too long: ignore */
			continue;
		}
		strncpy(path, dent->d_name, j);
		path[j] = 0;
		if (GDKisdigit(*path)) {
			i = strtol(path, NULL, 8);
		} else {
			i = BBP_find(path, FALSE);
			if (i < 0)
				i = -i;
		}
		if (i == 0 || i >= BBPsize || !BBPvalid(i)) {
			force_move(BAKDIR, LEFTDIR, dent->d_name);
		} else {
			BBPgetsubdir(dstdir, i);
			ret += force_move(BAKDIR, dstpath, dent->d_name);
		}
	}
	closedir(dirp);
	if (dirseen && ret == 0) {	/* we have a saved BBP.dir; it should be moved back!! */
		struct stat st;

		GDKfilepath(path, BATDIR, "BBP", "dir");
		ret = recover_dir(stat(path, &st) == 0);
	}

	if (ret == 0) {
		ret = rmdir(BAKDIR);
		IODEBUG THRprintf(GDKout, "#rmdir %s = %d\n", BAKDIR, ret);
	}
	if (ret)
		GDKerror("BBPrecover: recovery failed. Please check whether your disk is full or write-protected.\n");

	IODEBUG THRprintf(GDKout, "#BBPrecover(end)\n");

	return ret;
}

/*
@
SUBDIR recovery is quite mindlessly moving all files back to the parent (BAKDIR).
We do recognize moving back BBP.dir and set backed_up_subdir accordingly.
@c
*/
@c
int
BBPrecover_subdir(void)
{
	DIR *dirp = opendir(SUBDIR);
	struct dirent *dent;
	int ret = 0;

	if (dirp == NULL) {
		return 0;	/* nothing to do */
	}
	IODEBUG THRprintf(GDKout, "#BBPrecover_subdir(start)\n");

	/* move back all files */
	while ((dent = readdir(dirp)) != NULL) {
		if (dent->d_name[0] == '.')
			continue;
		ret = GDKmove(SUBDIR, dent->d_name, NULL, BAKDIR, dent->d_name, NULL);
		if (ret == 0 && strcmp(dent->d_name, "BBP.dir") == 0)
			backup_dir = 1;
		if (ret < 0)
			break;
	}
	closedir(dirp);

	/* delete the directory */
	if (ret == 0) {
		ret = GDKremovedir(SUBDIR);
		if (backup_dir == 2) {
			IODEBUG THRprintf(GDKout, "BBPrecover_subdir: %s%cBBP.dir had disappeared!", SUBDIR, DIR_SEP);
			backup_dir = 0;
		}
	}
	IODEBUG THRprintf(GDKout, "#BBPrecover_subdir(end) = %d\n", ret);

	if (ret)
		GDKerror("BBPrecover_subdir: recovery failed. Please check whether your disk is full or write-protected.\n");
	return ret;
}

/*
@}
@- The diskscan
The BBPdiskscan routine walks through the BAT dir, cleans up leftovers, and measures disk occupancy.
Leftovers are files that cannot belong to a BAT. in order to establish this for [ht]heap files,
the BAT descriptor is loaded in order to determine whether these files are still required.

The routine gathers all bat sizes in a bat that contains bat-ids and bytesizes. The return value is
the number of bytes of space freed.
@{
@c
*/
@c
static int
persistent_bat(bat bid)
{
	if (bid >= 0 && bid < BBPsize && BBPvalid(bid)) {
		BAT *b = BBP_cache(bid);

		if (b == NULL || b->batCopiedtodisk) {
			return TRUE;
		}
	}
	return FALSE;
}

static BAT *
getdesc(bat bid)
{
	BATstore *bs = BBPgetdesc(bid);

	if (bs == NULL)
		BBPclear(bid);
	return &bs->B;
}

static int
BBPdiskscan(const char *parent)
{
	DIR *dirp = opendir(parent);
	struct dirent *dent;
	long_str fullname;
	str dst = fullname;
	const char *src = parent;

	if (dirp == NULL)
		return -1;	/* nothing to do */

	while (*src)
		*dst++ = *src++;
	if (dst[-1] != DIR_SEP)
		*dst++ = DIR_SEP;

	while ((dent = readdir(dirp)) != NULL) {
		str p;
		bat bid;
		int ok, delete;
		struct stat st;

		if (dent->d_name[0] == '.')
			continue;	/* ignore .dot files and directories (. ..) */

		if (strncmp(dent->d_name, "BBP.", 4) == 0 &&
		    (strcmp(parent, BATDIR) == 0 ||
		     strncmp(parent, BAKDIR, strlen(BAKDIR)) == 0 ||
		     strncmp(parent, SUBDIR, strlen(SUBDIR)) == 0))
			continue;

		p = strchr(dent->d_name, '.');
		bid = strtol(dent->d_name, NULL, 8);
		ok = p && bid;
		delete = FALSE;

		strcpy(dst, dent->d_name);
		if (p == NULL && BBPdiskscan(fullname) == 0) {
			/* it was a directory */
			continue;
		}
		if (stat(fullname, &st)) {
			IODEBUG mnstr_printf(GDKerr,"BBPdiskscan: stat(%s)", fullname);
			continue;
		}
		IODEBUG THRprintf(GDKout, "#BBPdiskscan: stat(%s) = 0\n", fullname);

		if (ok == FALSE || !persistent_bat(bid)) {
			delete = TRUE;
		} else if (strstr(p + 1, ".tmp")) {
			delete = 1;	/* throw away any .tmp file */
		} else if (strncmp(p + 1, "head", 4) == 0) {
			BAT *b = getdesc(bid);
			delete = (b == NULL || !b->htype || b->batCopiedtodisk == 0);
		} else if (strncmp(p + 1, "tail", 4) == 0) {
			BAT *b = getdesc(bid);
			delete = (b == NULL || !b->ttype || b->batCopiedtodisk == 0);
		} else if (strncmp(p + 1, "hheap", 5) == 0) {
			BAT *b = getdesc(bid);
			delete = (b == NULL || !b->H->vheap || b->batCopiedtodisk == 0);
		} else if (strncmp(p + 1, "theap", 5) == 0) {
			BAT *b = getdesc(bid);
			delete = (b == NULL || !b->T->vheap || b->batCopiedtodisk == 0);
		} else if (strncmp(p + 1, "hhash", 5) == 0) {
			BAT *b = getdesc(bid);
			delete = (b == NULL || !b->H->hash);
		} else if (strncmp(p + 1, "thash", 5) == 0) {
			BAT *b = getdesc(bid);
			delete = (b == NULL || !b->T->hash);
		} else if (strncmp(p + 1, "priv", 4) != 0 && strncmp(p + 1, "new", 3) != 0 && strncmp(p + 1, "head", 4) != 0 && strncmp(p + 1, "tail", 4) != 0) {
			ok = FALSE;
		}
		if (!ok) {
			/* found an unknown file; stop pruning in this subdir */
			IODEBUG THRprintf(GDKout, "BBPdiskscan: unexpected file %s, leaving %s.\n", dent->d_name, parent);
			break;
		}
		if (delete) {
			if (unlink(fullname) < 0) {
				GDKsyserror("BBPdiskscan: unlink(%s)", fullname);
				continue;
			}
			IODEBUG THRprintf(GDKout, "#BBPcleanup: unlink(%s) = 0\n", fullname);
		}
	}
	closedir(dirp);
	return 0;
}

void
BBPatom_drop(int atom)
{
	int i;
	str nme = ATOMname(atom);
	int unknown = ATOMunknown_add(nme);

	BBPlock("BBPatom_drop");
	for (i = 0; i < BBPsize; i++) {
		if (BBPvalid(i)) {
			BATstore *b = BBP_desc(i);

			if (!b)
				continue;

			if (b->B.htype == atom)
				b->B.htype = unknown;
			if (b->B.ttype == atom)
				b->B.ttype = unknown;
		}
	}
	BBPunlock("BBPatom_drop");
}

void
BBPatom_load(int atom)
{
	str nme;
	int i, unknown;

	BBPlock("BBPatom_load");
	nme = ATOMname(atom);
	unknown = ATOMunknown_find(nme);
	ATOMunknown_del(unknown);
	for (i = 0; i < BBPsize; i++) {
		if (BBPvalid(i)) {
			BATstore *b = BBP_desc(i);

			if (!b)
				continue;

			if (b->B.htype == unknown)
				b->B.htype = atom;
			if (b->B.ttype == unknown)
				b->B.ttype = atom;
		}
	}
	BBPunlock("BBPatom_load");
}

@}
@{
@h
#endif /* _GDK_BBP_H_ */
@}
