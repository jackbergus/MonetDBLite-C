@/
The contents of this file are subject to the MonetDB Public License
Version 1.1 (the "License"); you may not use this file except in
compliance with the License. You may obtain a copy of the License at
http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html

Software distributed under the License is distributed on an "AS IS"
basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations
under the License.

The Original Code is the MonetDB Database System.

The Initial Developer of the Original Code is CWI.
Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
Copyright August 2008-2011 MonetDB B.V.
All Rights Reserved.
@

@f gdk_utils
@a M. L. Kersten, P. Boncz, N. Nes

@* Utilities
The utility section contains functions to initialize the Monet database
system, memory allocation details, and a basic system logging scheme.
@-
@{
@h
#ifndef _GDK_UTILS_H_
#define _GDK_UTILS_H_

#include <monet_options.h>

gdk_export void GDKlog(const char *format, ...);
gdk_export void GDKlockHome(void);
gdk_export void GDKunlockHome(void);
gdk_export int GDKgetHome(void);

gdk_export lng GDKusec(void);
gdk_export int GDKms(void);

gdk_export BAT *GDKenv;

@c
#include "monetdb_config.h"

#include "gdk.h"

static int gdk_alloc_map = 0;
static char GDKdbfarmStr[PATHLENGTH] = { "dbfarm" };
static char GDKdbnameStr[PATHLENGTH] = { 0 };

BAT *GDKenv = NULL;

#ifdef HAVE_FCNTL_H
#include <fcntl.h>
#endif

#ifdef HAVE_FTIME
#include <sys/timeb.h>
#endif

#ifdef TIME_WITH_SYS_TIME
# include <sys/time.h>
# include <time.h>
#else
# ifdef HAVE_SYS_TIME_H
#  include <sys/time.h>
# else
#  include <time.h>
# endif
#endif

#ifdef HAVE_PWD_H
# include <pwd.h>
#endif

#ifdef NATIVE_WIN32
#define chdir _chdir
#endif

#ifdef NDEBUG
#ifndef NVALGRIND
#define NVALGRIND NDEBUG
#endif
#endif

#if defined(__GNUC__) && defined(HAVE_VALGRIND)
#include <valgrind.h>
#else
#define VALGRIND_MALLOCLIKE_BLOCK(addr, sizeB, rzB, is_zeroed)
#define VALGRIND_FREELIKE_BLOCK(addr, rzB)
#endif

static int GDKstopped = 1;

@}
@+ Monet configuration file
Parse a possible MonetDB.conf file (either in the default location
<prefix>/etc/MonetDB.conf, or as specified by either an environment variable
$MONETDB_CONFIG, or by command line option -c/--config)
to extract pre-settings of system variables.
Un-recognized parameters are simply skipped, because they  may be
picked up by other components of the system.
The consequence is that making a typing error in the configuration file
may be unnoticed for a long time.
Syntax errors are immediately flagged, though.

Since the GDK kernel moves into the database directory, we need
to keep the absolute path to the MonetDB.conf file for top-levels
to access its information.
@{
@c

static int
GDKenvironment(str dbname, str dbfarm)
{
	if (dbname == 0) {
		fprintf(stdout, "!GDKenvironment: database name missing.\n");
		return 0;
	}
	if (dbfarm == 0) {
		fprintf(stdout, "!GDKenvironment: dbfarm missing.\n");
		return 0;
	}

	if (!MT_path_absolute(dbfarm)) {
		fprintf(stdout, "!GDKenvironment: wrong directory %s.\n", dbfarm);
		return 0;
	}

	strncpy(GDKdbnameStr, dbname, PATHLENGTH);
	strncpy(GDKdbfarmStr, dbfarm, PATHLENGTH);
	return 1;
}

@h
gdk_export char *GDKgetenv(const char *name);

@c
char *
GDKgetenv(const char *name)
{
	BUN b = BUNfnd(GDKenv, (ptr) name);

	if (b != BUN_NONE) {
		BATiter GDKenvi = bat_iterator(GDKenv);
		return BUNtail(GDKenvi, b);
	}
	return NULL;
}

@h
gdk_export int GDKgetenv_isyes(const char *name);

@c
int
GDKgetenv_isyes(const char *name)
{
	char *val = GDKgetenv(name);

	if (val && strcasecmp(val, "yes") == 0) {
		return 1;
	}
	return 0;
}

@h
gdk_export int GDKgetenv_istrue(const char *name);

@c
int
GDKgetenv_istrue(const char *name)
{
	char *val = GDKgetenv(name);

	if (val && strcasecmp(val, "true") == 0) {
		return 1;
	}
	return 0;
}

@h
gdk_export int GDKgetenv_int(const char *name, int def);

@c
int
GDKgetenv_int(const char *name, int def)
{
	char *val = GDKgetenv(name);

	if (val)
		return atoi(val);
	return def;
}

@h
gdk_export void GDKsetenv(str name, str value);

@c
void
GDKsetenv(str name, str value)
{
	BUNins(GDKenv, name, value, FALSE);
	BATfakeCommit(GDKenv);
}

@}

@+ System logging
Per database a log file can be maintained for collection
of system management information. Its contents is driven
by the upper layers, which encode information such as
who logged on and how long the session went on.
The lower layers merely store error information on the file.
It should not be used for crash recovery, because this should be
dealt with on a per client basis.

@-
A system log can be maintained in the database to keep track
of session and crash information. It should regularly be
refreshed to avoid disk overflow.
@{
@c
#define GDKLOCK	".gdk_lock"

static FILE *GDKlockFile = 0;

#define GDKLOGOFF	"LOGOFF"
#define GDKFOUNDDEAD	"FOUND	DEAD"
#define GDKLOGON	"LOGON"
#define GDKCRASH	"CRASH"

@-
Single-lined comments can now be logged safely, together with process, thread
and user ID, and the current time.
@c
/* VARARGS */
void
GDKlog(const char *format, ...)
{
	va_list ap;
	char *p = 0, buf[1024];
	int mustopen = GDKgetHome();
	time_t tm = time(0);

	if (!MT_initialized())
		return;

	va_start(ap, format);
	vsprintf(buf, format, ap);
	va_end(ap);

	/* remove forbidden characters from message */
	for (p = buf; (p = strchr(p, '\n')) != NULL; *p = ' ')
		;
	for (p = buf; (p = strchr(p, '\@')) != NULL; *p = ' ')
		;

	fseek(GDKlockFile, 0, SEEK_END);
#ifndef HAVE_GETUID
#define getuid() 0
#endif
	fprintf(GDKlockFile, "USR=%d PID=%d TIME=%s \@ %s", (int) getuid(), (int) getpid(), ctime(&tm), buf);
	fflush(GDKlockFile);

	if (mustopen)
		GDKunlockHome();
}

@}
@+ Interrupt handling
The current version simply catches signals and prints a warning.
It should be extended to cope with the specifics of the interrupt
received.
@{
@c
#include <signal.h>
#if 0				/* these are unused */
static void
BATSIGignore(int nr)
{
	GDKsyserror("! ERROR signal %d caught by thread " SZFMT "\n", nr, (size_t) MT_getpid());
}
#endif

#ifdef WIN32
static void
BATSIGabort(int nr)
{
	GDKfatal("BATSIGabort: signal %d caught by thread " SZFMT "\n", nr, (size_t) MT_getpid());
}
#endif

#ifndef NATIVE_WIN32
static void
BATSIGinterrupt(int nr)
{
	GDKexit(nr);
}

#ifdef SIGCHLD
static void
BATSIGchild(int nr)
{
	int status;

	(void) nr;

	while (waitpid(-1, &status, WNOHANG) > 0)
		;
	PARDEBUG THRprintf(GDKerr, "CHILD EXITED \n");

	(void) signal(SIGPIPE, BATSIGchild);
}
#endif

static int
BATSIGinit(void)
{
#ifdef SIGCHLD
	(void) signal(SIGCHLD, BATSIGchild);
#endif
/* HACK to pacify compiler */
#if (defined(__INTEL_COMPILER) && (SIZEOF_VOID_P > SIZEOF_INT))
#undef  SIG_IGN			/*((__sighandler_t)1 ) */
#define SIG_IGN   ((__sighandler_t)1L)
#endif

#ifdef SIGPIPE
	(void) signal(SIGPIPE, SIG_IGN);
#endif
#ifdef __SIGRTMIN
	(void) signal(__SIGRTMIN + 1, SIG_IGN);
#endif
#ifdef SIGHUP
	(void) signal(SIGHUP, MT_global_exit);
#endif
#ifdef SIGINT
	(void) signal(SIGINT, BATSIGinterrupt);
#endif
#ifdef SIGTERM
	(void) signal(SIGTERM, BATSIGinterrupt);
#endif
	return 0;
}
#endif /* NATIVE_WIN32 */

@}
@+ Memory management
Memory management in GDK mostly relies on the facilities offered by the
underlying OS.  The below routines monitor the available memory resources
which consist of physical swap space and logical vm space.
There are three kinds of memory, that affect these two resources in different ways:
@table @samp

@item memory mapping
 which ask for a logical region of virtual memory space.
In principal, no physical memory is needed to keep the system afloat here,
as the memory mapped file is swapped onto a disk object that already exists.

Actually, there are two kings of memory mapping used in GDK, namely
read-only direct mapped and writable copy-on write. For the dirty
pages, the latter actually also consumes physical memory resources,
but that is ignored here for simplicity.

@item anonymous virtual memory
This is virtual memory that is mapped on the swap file. Hence, this consumes
both logical VM space resources and physical memory space.

@item malloced memory
comes from the heap and directly consumes physical memory resources.
@end table

We check the resource consumption with preset target values, and if these
are exceeded, the routine BBPtrim is called that will unload the
least recently used BATs in order to decrease memory usage.

The malloc routine checks the memory consumption every 1000 calls,
or for calls larger that 50000 bytes. Consequently, at least every
50MB increase, alloc memory is checked. The VM calls always check
the memory consumption.
@{
@h
/* default setting to administer everything */
#define GDK_MEM_NULLALLOWED

#if SIZEOF_VOID_P==8
#define GDK_VM_MAXSIZE	LL_CONSTANT(4398046511104)	/* :-) a 64-bit OS: 4TB */
#else
#define GDK_VM_MAXSIZE	LL_CONSTANT(1610612736)	/* :-| a 32-bit OS: 1.5GB */
#endif
@c
/* memory thresholds; these values some "sane" constants only, really set in GDKinit() */
size_t GDK_mmap_minsize = GDK_VM_MAXSIZE;
size_t GDK_mem_maxsize_max = GDK_VM_MAXSIZE;
size_t GDK_mem_maxsize = GDK_VM_MAXSIZE;
size_t GDK_mem_bigsize = 1 << 20; /* please keep in sync with MonetDB.conf.in & monetdb5.conf.in */
size_t GDK_vm_maxsize = GDK_VM_MAXSIZE;

int GDK_vm_allocs = 0;
int GDK_mem_allocs = 0;
int GDK_vm_trim = 1;

/* at least each 50M of memory increase, BBPtrim is run */
#define CHKMEM(meminc, vminc) do {					\
	int memchk, vmchk; \
	malloc_lock(); \
	memchk = (meminc>0 && (++GDK_mem_allocs>=1000 || meminc>LL_CONSTANT(50000))); \
	vmchk = (vminc>0 && (++GDK_vm_allocs>=10 || vminc>LL_CONSTANT(5000000))); \
	malloc_unlock(); \
	if (memchk || vmchk) GDKmemchk(memchk, vmchk);			\
} while (0)

#define SEG_SIZE(x,y)   ((x)+(((x)&((1<<(y))-1))?(1<<(y))-((x)&((1<<(y))-1)):0))
#define MAX_BIT         ((int) (sizeof(ssize_t)<<3))

/* histogram update macro */
#define GDKmallidx(idx,size)				\
	{						\
		int _mask;				\
		if (size < 128) {			\
			_mask = (1<<6);			\
			idx = 7;			\
		} else {				\
			_mask = (1<<(MAX_BIT-1));	\
			idx = MAX_BIT;			\
		}					\
		while(idx-- > 4) {			\
			if (_mask&size) break;		\
			_mask >>=1;			\
		}					\
	}

volatile size_t GDK_mallocedbytes_estimate = 0;
static ssize_t GDK_mem_cursize = 0;
static ssize_t GDK_vm_cursize = 0;

#ifdef GDK_MEM_TRACE
static int mtrace = 0;
#endif

#ifndef NDEBUG
static MT_Lock mbyteslock;
#define malloc_lock() gdk_set_lock(mbyteslock, "malloc")
#define	malloc_unlock()	gdk_unset_lock(mbyteslock, "malloc");
#define malloc_lock_init() MT_init_lock(mbyteslock, "mbyteslock")
#else
#define malloc_lock()
#define	malloc_unlock()
#define malloc_lock_init()
#endif

size_t
GDKvm_heapsize(void)
{
#ifdef _CYGNUS_H_
	return (size_t) 96 << 20;
#else
	size_t ret = GDKmem_heapsize();

#ifdef __linux__
	/* on linux, malloc may also use mmapped space, so the bytes-in-malloc may be much bigger than the sbrk() region */
	malloc_lock();
	ret = MAX(GDK_mallocedbytes_estimate, ret);
	malloc_unlock();
#endif
	return ret;
#endif
}

size_t
GDKmem_heapsize(void)
{
	size_t heapsize = MT_heapcur() - MT_heapbase;

	return (size_t) SEG_SIZE(heapsize, MT_VMUNITLOG);
}

size_t
GDKmem_inuse(void)
{
	/* RAM/swapmem that Monet is really using now */
	ssize_t mem_cursize = GDK_mem_cursize;
	size_t mem_mallocedbytes_estimate;

	malloc_lock();
	mem_mallocedbytes_estimate = GDK_mallocedbytes_estimate;
	malloc_unlock();
	if (mem_cursize < 0)
		mem_cursize = GDK_mem_cursize = 0;

	return mem_cursize + mem_mallocedbytes_estimate;
}

size_t
GDKmem_cursize(void)
{
	/* RAM/swapmem that Monet has claimed from OS */
	ssize_t mem_cursize = GDK_mem_cursize;

	if (mem_cursize < 0)
		mem_cursize = GDK_mem_cursize = 0;

	return mem_cursize + GDKmem_heapsize();
}

size_t
GDKvm_cursize(void)
{
	/* current Monet VM address space usage */
	ssize_t vm_cursize = GDK_vm_cursize;

	if (vm_cursize < 0)
		vm_cursize = GDK_vm_cursize = 0;

	return vm_cursize + GDKvm_heapsize();
}

#ifdef GDK_VM_KEEPHISTO
volatile ssize_t GDK_vm_nallocs[MAX_BIT] = { 0 };
#endif
#ifdef GDK_MEM_KEEPHISTO
volatile ssize_t GDK_nmallocs[MAX_BIT] = { 0 };
#endif

size_t
GDKmem_heapinuse(void)
{
	return GDK_mallocedbytes_estimate;
}

volatile int GDK_heapcheck_last = 0;

static inline void
GDKmem_heapcheck(int t)
{
	/* correct heap estimate with the real thing */
	struct Mallinfo m = MT_mallinfo();

	GDK_mallocedbytes_estimate = (size_t) (m.usmblks + m.uordblks + m.hblkhd);
	GDK_heapcheck_last = t;
}

@- heapinc(size_t _memdelta, void* _blk)
@= heapinc
	{
		size_t _memdelta = (size_t) @1;
#ifdef GDK_MEM_TRACE
		void*  _blk = (void*) @2;

		if (mtrace) {
			int _idx = add_stack(stackBat);

			add_mem(memBat, _blk, _idx);
		}
#endif
		malloc_lock();
		GDK_mallocedbytes_estimate += _memdelta;
		malloc_unlock();
#ifdef GDK_MEM_KEEPHISTO
		{
			int _idx;

			GDKmallidx(_idx, _memdelta);
			GDK_nmallocs[_idx]++;
		}
#endif
	}

@- heapdec(size_t memdelta, void* _blk)
@= heapdec
	{
		size_t _memdelta = (size_t) @1;
#ifdef GDK_MEM_TRACE
		void*  _blk = (void*) @2;

		if (mtrace) {
			del_mem(memBat,_blk);
		}
#endif

		malloc_lock();
		if (_memdelta > GDK_mallocedbytes_estimate) {
			/* clearly, the stats are off: it should never become less-than-zero */
			GDKmem_heapcheck(GDKms());
		} else {
			GDK_mallocedbytes_estimate -= _memdelta;
		}
		malloc_unlock();
#ifdef GDK_MEM_KEEPHISTO
		{
			int _idx;

			GDKmallidx(_idx, _memdelta);
			GDK_nmallocs[_idx]--;
		}
#endif
	}

@- meminc(size_t memdelta, size_t vmdelta, str fcn)
@= meminc
	{
		ssize_t _memdelta = (ssize_t) @1;
		ssize_t _vmdelta = (ssize_t) SEG_SIZE(@2,MT_VMUNITLOG);

		gdk_set_lock(GDKthreadLock, @3);
		GDK_mem_cursize += _memdelta;
#ifdef GDK_VM_KEEPHISTO
		{
			int _idx;

			GDKmallidx(_idx, _vmdelta);
			GDK_vm_nallocs[_idx]++;
		}
#endif
		GDK_vm_cursize += _vmdelta;
		gdk_unset_lock(GDKthreadLock, @3);
	}

@- memdec(size_t memdelta, size_t vmdelta, str nme)
@= memdec
	{
		ssize_t _memdelta = (ssize_t) @1;
		ssize_t _vmdelta = (ssize_t) SEG_SIZE(@2,MT_VMUNITLOG);

		gdk_set_lock(GDKthreadLock, @3);
		GDK_mem_cursize -= _memdelta;
#ifdef GDK_VM_KEEPHISTO
		{
			int _idx;

			GDKmallidx(_idx, _vmdelta);
			GDK_vm_nallocs[_idx]--;
		}
#endif
		GDK_vm_cursize -= _vmdelta;
		gdk_unset_lock(GDKthreadLock, @3);
	}
@c
static void
GDKmemdump(void)
{
	struct Mallinfo m = MT_mallinfo();

	MEMDEBUG {
		THRprintf(GDKout, "\n#mallinfo.arena = " SSZFMT "\n", (ssize_t) m.arena);
		THRprintf(GDKout, "#mallinfo.ordblks = " SSZFMT "\n", (ssize_t) m.ordblks);
		THRprintf(GDKout, "#mallinfo.smblks = " SSZFMT "\n", (ssize_t) m.smblks);
		THRprintf(GDKout, "#mallinfo.hblkhd = " SSZFMT "\n", (ssize_t) m.hblkhd);
		THRprintf(GDKout, "#mallinfo.hblks = " SSZFMT "\n", (ssize_t) m.hblks);
		THRprintf(GDKout, "#mallinfo.usmblks = " SSZFMT "\n", (ssize_t) m.usmblks);
		THRprintf(GDKout, "#mallinfo.fsmblks = " SSZFMT "\n", (ssize_t) m.fsmblks);
		THRprintf(GDKout, "#mallinfo.uordblks = " SSZFMT "\n", (ssize_t) m.uordblks);
		THRprintf(GDKout, "#mallinfo.fordblks = " SSZFMT "\n", (ssize_t) m.fordblks);
	}
#ifdef GDK_MEM_KEEPHISTO
	{
		int i;

		THRprintf(GDKout, "#memory histogram\n");
		for (i = 3; i < GDK_HISTO_MAX_BIT - 1; i++) {
			size_t j = 1 << i;

			THRprintf(GDKout, "# " SZFMT " " SZFMT "\n", j, GDK_nmallocs[i]);
		}
	}
#endif
#ifdef GDK_VM_KEEPHISTO
	{
		int i;

		THRprintf(GDKout, "\n#virtual memory histogram\n");
		for (i = 12; i < GDK_HISTO_MAX_BIT - 1; i++) {
			size_t j = 1 << i;

			THRprintf(GDKout, "# " SZFMT " " SZFMT "\n", j, GDK_vm_nallocs[i]);
		}
	}
#endif
}


static void
GDKmemchk(int memchk, int vmchk)
{
	size_t memtarget = GDKmem_inuse();
	size_t vmtarget = GDKvm_cursize();

	MEMDEBUG {
		/* Protect from being called recursively because THRprintf
		   allocates memory */
		static int printing[THREADS];
		int tid = THRgettid();

		if (!printing[tid - 1]) {
			printing[tid - 1] = TRUE;
			THRprintf(GDKout, "#GDKmemchk (memcur=" SZFMT ",memmax=" SZFMT ") (vmcur=" SZFMT ",vmmax=" SZFMT ")\n", memtarget, GDK_mem_maxsize, GDKvm_cursize(), GDK_vm_maxsize);
			printing[tid - 1] = FALSE;
		}
	}
	memtarget = (memchk && memtarget > GDK_mem_maxsize) ? memtarget - GDK_mem_maxsize : 0;
	vmtarget = (vmchk && vmtarget > GDK_vm_maxsize) ? vmtarget - GDK_vm_maxsize : 0;
	if (memtarget > 0 || vmtarget > 0) {
		if (memtarget > 0) {
			int t = GDKms();

			/* check max every 10 secs, and only if its incorrectness bothers us (i.e. causes BBPtrim) */
			if ((t - GDK_heapcheck_last) > 10000) {
				malloc_lock();
				GDKmem_heapcheck(t);	/* correct thread-unsafe estimate */
				malloc_unlock();
			}
		}
		BBPtrim(memtarget, vmtarget);
		GDK_mem_allocs = GDK_vm_allocs = 0;
	} else {
		if (memchk)
			GDK_mem_allocs = 0;
		if (vmchk)
			GDK_vm_allocs = 0;
	}
}

@}

@+ Stack tracing

Very simple malloc tracing implementation that allows to retain on which stack frame
a malloc was done. This is code originally developed by DD, and
is used only  by them.
Two bats are used: stackBat and memBat.
StackBat contains a DAG of all methods used for memory allocation.
MemBat contains a mapping from allocated memory addresses to an index
in the stackBat which indicates the place the memory is allocated.
@{
@c
#ifdef GDK_MEM_TRACE

static BAT *stackBat = NULL;
static BAT *memBat = NULL;
typedef ptr mem_t;

char *
stack_test(int i, int j)
{
	if (--i == 0)
		return (char *) GDKmalloc(j);

	return stack_test(i, j);
}


void
mtrace_test()
{
	char *t = stack_test(1, 1);

	GDKfree(t);
	GDKfree(t);		/* double delete */
	t = stack_test(2, 2);
	t = GDKrealloc(t, 20);	/* leaked */
}


static int
GDKmtrace(bit *enable)
{
	if (*enable) {
		if (memBat == NULL) {
			memBat = BATnew(TYPE_ptr, TYPE_int, 16384);
			if (memBat == NULL)
				return GDK_FAIL;
			stackBat = BATnew(TYPE_ptr, TYPE_ptr, 16384);
			if (stackBat == NULL)
				return GDK_FAIL;
			BBPrename(memBat->batCacheid, "mem_trace");
			BBPrename(stackBat->batCacheid, "mem_stack");
			memBat->hsorted = memBat->tsorted = 0;
			memBat->H->nonil = 0;
			BATkey(memBat, TRUE);
			stackBat->hsorted = stackBat->tsorted = 0;
			BATset(stackBat, TRUE);
			memBat->T->nonil = 0;
		}
		mtrace++;
	} else if (mtrace > 0)
		mtrace--;

	memBat->batDirty = TRUE;
	stackBat->batDirty = TRUE;

	if (*enable == bit_nil) {
		printf("testing mtrace:\n");
		mtrace_test();
		--mtrace;
	}

	return GDK_SUCCEED;
}


BUN
add_dag(BAT *b, BUN p, mem_t current, mem_t parent)
{
	const static int bunsize = sizeof(mem_t) + sizeof(mem_t);
	BUN last = BUNlast(b);

	while (p != last) {
		if ((*(mem_t *) BUNhloc(b, p)) == current && (*(mem_t *) BUNtloc(b, p)) == parent)
			return p;
		p += bunsize;
	}

	if (b->batBuns->free + bunsize > b->batBuns->size) {
		int tmp = mtrace;

		mtrace = 0;
		if (BATextend(b, BATgrows(b)) == NULL)
			return BUNlast(b);
		mtrace = tmp;
		last = BUNlast(b);
	}
	bunfastins_nocheck(b, last, &current, &parent, bunsize);
	return last;
}


#define MAX_STACK_ADDR 16
#define STACK_LIST(STACK_ENTRY)						\
	STACK_ENTRY(1) STACK_ENTRY(2) STACK_ENTRY(3)			\
	STACK_ENTRY(4) STACK_ENTRY(5) STACK_ENTRY(6) STACK_ENTRY(7)	\
	STACK_ENTRY(8) STACK_ENTRY(9) STACK_ENTRY(10) STACK_ENTRY(11)	\
	STACK_ENTRY(12) STACK_ENTRY(13) STACK_ENTRY(14) STACK_ENTRY(15)

#define STACK_READ(X)						\
	if (continue_stack_trace &&				\
	    ((mem_t)__builtin_frame_address((X)) != 0L) &&	\
	    ((X) < MAX_STACK_ADDR)) {				\
		parent = current;				\
		current = (mem_t)__builtin_return_address((X)); \
		if(parent)					\
			p = add_dag(b, p, current, parent);	\
	} else if (continue_stack_trace) {			\
		continue_stack_trace = FALSE;			\
	}

int
add_stack(BAT *b)
{
	mem_t current = 0, parent = 0;
	bit continue_stack_trace = TRUE;
	BUN p = BUNfirst(b);

	STACK_LIST(STACK_READ);
	return BUNindex(b, p);
}

#define __USE_GNU 1
#include <dlfcn.h>
void
print_address(ptr address)
{
	Dl_info dlip;
	char *filename;

	dladdr(address, &dlip);

	filename = 0;		/* strrchr(dlip.dli_fname,'/'); */
	printf(PTRFMT "\t%s\t%s\n", PTRFMTCAST address, dlip.dli_sname, filename ? filename + 1 : dlip.dli_fname);
}

static int
GDKmprint(int *pidx)
{
	int idx = *pidx;
	BUN p = BUNptr(stackBat, idx), first = BUNfirst(stackBat);
	const static int bunsize = sizeof(mem_t) + sizeof(mem_t);
	mem_t *a;

	if (p == NULL)
		printf("No stack for index %d\n", idx);

	a = (mem_t *) BUNhloc(stackBat, p);
	print_address(*a);
	a = (mem_t *) BUNtloc(stackBat, p);
	print_address(*a);

	while (p > first) {
		p -= bunsize;
		if (*(mem_t *) BUNhloc(stackBat, p) == *a) {
			a = (mem_t *) BUNtloc(stackBat, p);
			print_address(*a);
		}
	}

	return GDK_SUCCEED;
}


void
add_mem(BAT *b, mem_t mem, int idx)
{
	register BUN last;
	const static int bunsize = sizeof(mem_t) + sizeof(int);

	if (b->batBuns->free + bunsize > b->batBuns->size) {
		int tmp = mtrace;

		mtrace = 0;
		if (BATextend(b, BATgrows(b)))
			return;
		mtrace = tmp;
	}
	last = BUNlast(b);
	bunfastins_nocheck(b, last, &mem, &idx, bunsize);
}


void
del_mem(BAT *b, mem_t mem)
{
	register BUN first = BUNfirst(b), p = BUNlast(b);
	const static int bunsize = sizeof(mem_t) + sizeof(int);

	for (p -= bunsize; p >= first; p -= bunsize) {
		if (*(mem_t *) BUNhloc(b, p) == mem) {
			int idx = -*(int *) BUNtloc(b, p);

			if (idx > 0) {
				printf("Double deletion of memory " PTRFMT ", "
				       "size: " SSZFMT ", stack:%d\n",
				       PTRFMTCAST(void *)mem,
				       ((ssize_t *) mem)[-1],
				       idx);

				if (mtrace > 1)
					GDKmprint(&idx);
			} else {
				BUNdelete(b, p);
				/* BUNinplace(b,p,&mem,&idx,0); */
			}
			return;
		}
	}
	printf("Free of unknown memory " PTRFMT ", size: " SSZFMT "\n", PTRFMTCAST(void *) mem, ((ssize_t *) mem)[-1]);
}
#endif
@}

@+ Malloc
Malloc normally maps through directly to the OS provided malloc/free/realloc
calls. Where possible, we want to use the -lmalloc library on Unix systems,
because it allows to influence the memory allocation strategy. This can prevent
fragmentation and greatly help enhance performance.

The "added-value" of the GDKmalloc/GDKfree/GDKrealloc over the standard OS
primitives is that the GDK versions try to do recovery from failure to malloc by
initiating a BBPtrim. Also, big requests are redirected to anonymous virtual
memory. Finally, additional information on block sizes is kept (helping efficient
reallocations) as well as some debugging that guards against duplicate frees.

A number of different strategies are available using different switches, however:
@table @samp

@item zero sized blocks
Normally, GDK gives fatal errors on illegal block sizes.
This can be overridden with  GDK_MEM_NULLALLOWED.

@item resource tracking
Many malloc interfaces lack a routine that tells the size of a block
by the pointer. We need this information for correct malloc statistics.

@item outstanding block histograms
In order to solve the problem, we allocate extra memory in front of the
returned block. With the resource tracking in place, we keep a total of
allocated bytes.  Also, if GDK_MEM_KEEPHISTO is defined, we keep a histogram
of the outstanding blocks on the log2 of the block size (similarly for virtual.
memory blocks; define GDK_VM_KEEPHISTO).

@item ensuring 8-byte alignment
While doing the resource tracking, we can in one go solve the problem
of 32-bit systems that return non-8 bytes aligned pointers. This is
encoded by storing a size + 1 (we always normalize sizes to multiples of
8, so this is easily recognized). This check only done if
GDK_MEM_MISALIGN is @strong{not} enabled.

@item redirection to anonymous VM
Sometimes, fragmentation problems arise on mallocs that are not tunable.
In that case, it makes sense to redirect large block requests (taken to be
larger than GDK_mem_bigsize) to anonymous virtual memory. The seamless
implementation of this stores the @strong{negative} block size in front of the
pointer (as well as the VM maxsize), so the malloc primitives can recognize
these redirected blocks.
@end table

64-bits update: Some 64-bit implementations (Linux) of mallinfo is severely broken, as they use int-s for memory sizes!!
This causes corruption of mallinfo stats. As we depend on those, we should keep the
malloc arena small. Thus, VM redirection is now quickly applied: for all mallocs > 1MB.
@{
@c
static void
GDKmemfail(str s, size_t len, size_t memtarget, size_t vmtarget)
{
	int bak = GDKdebug;

	/* bumped your nose against the wall; try to prevent repetition by adjusting maxsizes 
	   if (memtarget < 0.3 * GDKmem_inuse()) {
		   size_t newmax = (size_t) (0.7 * (double) GDKmem_inuse());

		   if (newmax < GDK_mem_maxsize)
		   GDK_mem_maxsize = newmax;
	   }
	   if (vmtarget < 0.3 * GDKvm_cursize()) {
		   size_t newmax = (size_t) (0.7 * (double) GDKvm_cursize());

		   if (newmax < GDK_vm_maxsize)
			   GDK_vm_maxsize = newmax;
	   }
	 */

	gdk_set_lock(GDKthreadLock, "GDKmemfail");
	THRprintf(GDKout, "#%s(" SZFMT ") fails, try to free up space [memory in use=" SZFMT ",virtual memory in use=" SZFMT "]\n", s, len, GDKmem_inuse(), GDKvm_cursize());
	GDKmemdump();
/*	GDKdebug |= 4;  avoid debugging output */
	gdk_unset_lock(GDKthreadLock, "GDKmemfail");

	BBPtrim(memtarget, vmtarget);

	gdk_set_lock(GDKthreadLock, "GDKmemfail");
	GDKdebug = MIN(GDKdebug, bak);
	THRprintf(GDKout, "#%s(" SZFMT ") result [mem=" SZFMT ",vm=" SZFMT "]\n", s, len, GDKmem_inuse(), GDKvm_cursize());
	GDKmemdump();
	gdk_unset_lock(GDKthreadLock, "GDKmemfail");
}

/* the blocksize is stored in the ssize_t before it. Negative size <=> VM memory */
#define GDK_MEM_BLKSIZE(p) ((ssize_t*) (p))[-1]
#ifdef __GLIBC__
#define GLIBC_BUG 8
#else
#define GLIBC_BUG 0
#endif

#ifndef GDK_MEM_MISALIGN

/* allocate 8 bytes extra (so it stays 8-bytes aligned) and put realsize in front */
#define GDKmalloc_prefixsize(s,size) {					\
	s = (ssize_t *) malloc(size + 8 + GLIBC_BUG);			\
	if (s != NULL) {						\
		assert((((size_t) s)&7) == 0); /* no MISALIGN */	\
		s = (ssize_t*) ((char*) s + 8);				\
		s[-1] = (ssize_t) (size + 8);				\
	}								\
}

#else
/* work around old stupid libc mallocs that give 4-byte aligned pointers */
#define GDKmalloc_prefixsize(s,size) {					\
	s = (ssize_t *) malloc(size+8);					\
	if (((size_t) s) & 4) { /* misaligned */			\
		assert(sizeof(size_t) == 4); /* not on 64-bits */	\
		s = (ssize_t*) ((char*) s + 4);				\
		s[-1] = (ssize_t) (size + 9);  /* 1-bit is a marker */	\
	} else if (s != NULL) {						\
		s = (ssize_t*) ((char*) s + 8);				\
		s[-1] = (ssize_t) (size + 8);				\
	}								\
}
#endif


@-
The emergency flag can be set to force a fatal error if needed.
Otherwise, the caller is able to deal with the lack of memory.
@c
void *
GDKmallocmax(size_t size, size_t *maxsize, int emergency)
{
	ssize_t *s = NULL;

	if (size == 0) {
#ifdef GDK_MEM_NULLALLOWED
		return NULL;
#else
		GDKfatal("GDKmallocmax: called with size " SZFMT "", size);
#endif
	}
	size = (size + 7) & ~7;	/* round up to a multiple of eight */
	if (size > GDK_mem_bigsize) {
		size_t newsize = size + sizeof(size_t) + sizeof(size_t);
		size_t newmax = MAX(*maxsize, newsize);

		/* round up to multiple of 64k */
		newmax = ((newmax + 0xffff) >> 16) << 16;
		s = (ssize_t *) GDKvmalloc(newsize, &newmax, emergency);
		if (s == 0)
			return s;
		MT_alloc_register(s, *maxsize, 'S');
		s += 2;
		s[-2] = (ssize_t) newmax;
		s[-1] = -((ssize_t) newsize);
		*maxsize = newmax - (sizeof(size_t) + sizeof(size_t));
		return (void *) s;
	}
	CHKMEM(size, 0);
	GDKmalloc_prefixsize(s, size);
	if (s == NULL) {
		GDKmemfail("GDKmalloc", size, BBPTRIM_ALL, 0);
		GDKmalloc_prefixsize(s, size);
		if (s == NULL) {
			if (emergency == 0) {
				GDKerror("GDKmallocmax: failed for " SZFMT " bytes", size);
				return NULL;
			}
			MT_alloc_print();
			GDKfatal("GDKmallocmax: failed for " SZFMT " bytes", size);
		} else {
			THRprintf(GDKout, "#GDKmallocmax: recovery ok. Continuing..\n");
		}
	}
	*maxsize = size;
	@:heapinc(size+8,s)@
	return (void *) s;
}

void *
GDKmalloc(size_t size)
{
	size_t sz = size;
	void *p;
	p = GDKmallocmax(size, &size, 0);
	ALLOCDEBUG fprintf(stderr, "#GDKmalloc " SZFMT " " SZFMT " " PTRFMT "\n", sz, size, PTRFMTCAST p);
	return p;
}

void *
GDKzalloc(size_t size)
{
	size_t maxsize = size;
	void *p = GDKmallocmax(size, &maxsize, 0);
	ALLOCDEBUG fprintf(stderr, "#GDKzalloc " SZFMT " " SZFMT " " PTRFMT "\n", size, maxsize, PTRFMTCAST p);
	if (p)
		memset(p, 0, size);
	return p;
}

static void
GDKfree_(void *blk)
{
	ssize_t size = 0, *s = (ssize_t *) blk;

	if (s == NULL)
		return;

	size = GDK_MEM_BLKSIZE(s);

	/* check against duplicate free */
	assert((size & 2) == 0);

	assert(size != 0);

	if (size < 0) {
		size_t maxsize = (size_t) s[-2];

		size = -size;
		MT_alloc_register((char *) (s - 2), maxsize, 's');
		GDKvmfree((char *) (s - 2), (size_t) size, maxsize);
	} else {
#ifndef NDEBUG
		/* The check above detects obvious duplicate free's,
		 * but fails in case the "check-bit" is cleared between
		 * two free's (e.g., as the respective memory has been 
		 * re-allocated and initialized.
		 * To simplify detection & debugging of duplicate free's,
		 * we now overwrite the to be freed memory, which will
		 * (1) trigger a segfault in case the memory had already
		 * been freed and/or trigger some error in case the memory
		 * is accessed after is has been freed.
		 * To avoid performance penalty in the "production version",
		 * we only do this in debugging/development mode (i.e.,
		 * when configured with --enable-assert).
		 * Disable at runtime via `Mserver --debug=33554432` or
		 * `debugmask(or(debugmask(),33554432));` in MIL.
		 */
		DEADBEEFCHK memset(s, 0xDB, size - (8 + (size & 1)));	/* 0xDeadBeef */
#endif
#ifdef GDK_MEM_MISALIGN
		if (size & 1)
			free(((char *) s) - 4);
		else
#endif
			free(((char *) s) - 8);
		@:heapdec(size,s)@
	}
}

void
GDKfree(void *blk)
{
	ALLOCDEBUG fprintf(stderr, "#GDKfree " PTRFMT "\n", PTRFMTCAST blk);
	GDKfree_(blk);
}

ptr
GDKreallocmax(void *blk, size_t size, size_t *maxsize, int emergency)
{
	void *oldblk = blk;
	ssize_t oldsize = 0;

	if (blk == NULL) {
		return GDKmallocmax(size, maxsize, emergency);
	}
#ifdef GDK_MEM_NULLALLOWED
	if (size == 0) {
		GDKfree_(blk);
		*maxsize = 0;
		return NULL;
	}
#endif
	if (size <= 0) {
		GDKfatal("GDKreallocmax: called with size " SZFMT "", size);
	}
	size = (size + 7) & ~7;	/* round up to a multiple of eight */
	oldsize = GDK_MEM_BLKSIZE(blk);

	/* check against duplicate free */
	assert((oldsize & 2) == 0);

	if (oldsize < 0) {
		ssize_t *s = (ssize_t *) blk;
		size_t newsize = size + sizeof(size_t) + sizeof(size_t);
		size_t oldmax = (size_t) s[-2];
		size_t newmax = MAX(*maxsize, newsize);

		s = (ssize_t *) GDKvmrealloc((ptr) (s - 2), (size_t) - oldsize, newsize, oldmax, &newmax, emergency);
		if (s) {
			s[0] = (ssize_t) newmax;
			s[1] = -((ssize_t) newsize);
			*maxsize = newmax - (sizeof(size_t) + sizeof(size_t));
			return (ptr) (s + 2);
		}
	}
#ifndef GDK_MEM_MISALIGN
	else if (size <= GDK_mem_bigsize) {
		size_t newsize = size + 8;

		CHKMEM(newsize, 0);
		blk = realloc(((char *) blk) - 8, newsize + GLIBC_BUG);
		if (blk == NULL) {
			GDKmemfail("GDKrealloc", newsize, BBPTRIM_ALL, 0);
			blk = realloc(((char *) oldblk) - 8, newsize);
			if (blk == NULL) {
				if (emergency == 0) {
					GDKerror("GDKreallocmax: failed for " SZFMT " bytes", newsize);
					return NULL;
				}
				MT_alloc_print();
				GDKfatal("GDKreallocmax: failed for " SZFMT " bytes", newsize);
			} else {
				THRprintf(GDKout, "#GDKremallocmax: recovery ok. Continuing..\n");
			}
		}
		if (blk != NULL) {
			/* place 8 bytes before it */
			assert((((size_t) blk) & 4) == 0);
			blk = ((char *) blk) + 8;
			((ssize_t *) blk)[-1] = (ssize_t) newsize;

			/* adapt statistics */
			@:heapinc(newsize,blk)@
			@:heapdec(oldsize,oldblk)@
			*maxsize = size;
			return blk;
		}
	}
	/* alloc&copy due to failed realloc (may be very big heap that needs vm) */
#else
	/* alloc&copy because we cannot trust realloc due to misalignment */
	if (oldsize & 1)
		oldsize = MIN((ssize_t) size, oldsize - 5);
	else
#endif
		oldsize = MIN((ssize_t) size, oldsize - 8);
	blk = GDKmallocmax(size, maxsize, emergency);
	if (blk) {
		memcpy(blk, oldblk, oldsize);
		GDKfree_(oldblk);
	}
	return blk;
}

ptr
GDKrealloc(void *blk, size_t size)
{
	size_t sz = size;
	void *p;
	p = GDKreallocmax(blk, size, &size, 0);
	ALLOCDEBUG fprintf(stderr, "#GDKrealloc " SZFMT " " SZFMT " " PTRFMT " " PTRFMT "\n", sz, size, PTRFMTCAST blk, PTRFMTCAST p);
	return p;
}


char *
GDKstrdup(const char *s)
{
	int l = strLen(s);
	char *n = (char *) GDKmalloc(l);

	if (n)
		memcpy(n, s, l);
	return n;
}


@- virtual memory
allocations affect only the logical VM resources.
@c
void
GDKvminc(size_t len)
{
	@:meminc(0,len,"GDKvminc")@
	CHKMEM(0, len);
}

void *
GDKmmap(char *path, int mode, off_t off, size_t len)
{
	void *ret = MT_mmap(path, mode, off, len);

	if (ret == (void *) -1L) {
		GDKmemfail("GDKmmap", len, 0, BBPTRIM_ALL);
		ret = MT_mmap(path, mode, off, len);
		if (ret != (void *) -1L) {
			THRprintf(GDKout, "#GDKmmap: recovery ok. Continuing..\n");
		}
	}
	ALLOCDEBUG fprintf(stderr, "#GDKmmap " LLFMT " " SZFMT " " PTRFMT "\n", (lng) off, len, PTRFMTCAST ret);
	if (ret != (void *) -1L) {
		/* since mmap directly have content we say its zero-ed memory */
		VALGRIND_MALLOCLIKE_BLOCK(ret, len, 0, 1);
		MT_alloc_register(ret, len, 'M');
		GDKvminc(len);
	}
	return (void *) ret;
}

int
GDKmunmap(void *addr, size_t size)
{
	int ret;

	ALLOCDEBUG fprintf(stderr, "#GDKmunmap " SZFMT " " PTRFMT "\n", size, PTRFMTCAST addr);
	MT_alloc_register(addr, size, 'm');
	ret = MT_munmap(addr, size);
	VALGRIND_FREELIKE_BLOCK(addr, 0);
	if (ret == 0) {
		@:memdec(0,size,"GDKunmap")@
	}
	return ret;
}


@- VM alloc
this affects both physical and logical memory resources.
The emergency flag can be set to force a fatal error if needed.
Otherwise, the caller is able to deal with the lack of memory.
@c
void *
GDKvmalloc(size_t size, size_t *maxsize, int emergency)
{
	void *ret = MT_vmalloc(size, maxsize);

	if (ret == NULL) {
		GDKmemfail("GDKvmalloc", size, BBPTRIM_ALL, BBPTRIM_ALL);
		ret = MT_vmalloc(size, maxsize);
		if (ret == NULL) {
			if (emergency == 0) {
				ALLOCDEBUG fprintf(stderr, "#GDKvmalloc " SZFMT " " SZFMT " " PTRFMT "\n", size, *maxsize, PTRFMTCAST ret);
				return NULL;
			}
			MT_alloc_print();
			GDKfatal("GDKvmalloc: failed for " SZFMT " bytes", size);
		} else {
			THRprintf(GDKout, "#GDKvmalloc(" SZFMT "): recovery ok. Continuing..\n", size);
		}
	}
	ALLOCDEBUG fprintf(stderr, "#GDKvmalloc " SZFMT " " SZFMT " " PTRFMT "\n", size, *maxsize, PTRFMTCAST ret);
	if (ret != NULL) {
		@:meminc(size,*maxsize,"GDKvmalloc")@
		CHKMEM(size, *maxsize);
	}
	return ret;
}

void *
GDKvmrealloc(void *pold, size_t oldsize, size_t newsize, size_t oldmax, size_t *newmax, int emergency)
{
	void *ret = MT_vmrealloc(pold, oldsize, newsize, oldmax, newmax);

	if (ret == NULL) {
		GDKmemfail("GDKvmrealloc", newsize, BBPTRIM_ALL, BBPTRIM_ALL);
		ret = MT_vmrealloc(pold, oldsize, newsize, oldmax, newmax);
		if (ret == NULL) {
			if (emergency == 0) {
				ALLOCDEBUG fprintf(stderr, "#GDKvmrealloc " SZFMT " " SZFMT " " PTRFMT " " PTRFMT "\n", newsize, *newmax, PTRFMTCAST pold, PTRFMTCAST ret);
				return NULL;
			}
			MT_alloc_print();
			GDKfatal("GDKvmrealloc: failed for " SZFMT " bytes (from " SZFMT ")", newsize, oldsize);
		} else {
			THRprintf(GDKout, "#GDKvmrealloc(" SZFMT "): recovery ok. Continuing..\n", newsize);
		}
	}
	ALLOCDEBUG fprintf(stderr, "#GDKvmrealloc " SZFMT " " SZFMT " " PTRFMT " " PTRFMT "\n", newsize, *newmax, PTRFMTCAST pold, PTRFMTCAST ret);
	if (ret != NULL) {
		@:memdec(oldsize,oldmax,"GDKvmrealloc")@
		@:meminc(newsize,*newmax,"GDKvmrealloc")@
		CHKMEM(newsize, *newmax);
	}
	return ret;
}

void
GDKvmfree(void *blk, size_t size, size_t maxsize)
{
	ALLOCDEBUG fprintf(stderr, "#GDKvmfree " SZFMT " " PTRFMT "\n", maxsize, PTRFMTCAST blk);
	MT_vmfree(blk, maxsize);
	@:memdec(size,maxsize,"GDKvmfree")@
}

@}

@+ Session Initialization
The parameter @emph{db} is followed by the database name relative to
the environment variable dbfarm.
The parameter @emph{monetrc} tells that the system variables setting
should be overruled by the specification given in the file argument.
This format is only necessary to temporarily experiment with variable settings,
without disturbing a system/site default setting.

The interface code to the operating system is highly dependent on
the processing environment. It can be filtered away with compile-time flags.
Suicide is necessary due to some system implementation errors.

The kernel requires file descriptors for I/O with the user.
They are thread specific and should be obtained by a function.

The arguments relevant for the kernel are extracted from the list.
Their value is turned into a blanc space.
@{
@h
gdk_export int GDKrecovery;

@c
int GDKrecovery = 0;

@h
gdk_export int GDKinit(opt *set, int setlen);

@c
void
GDKprotect(void)
{
	int i;

	if (GDKprotected == 0) {
		TMDEBUG printf("# GDKlocks created\n");

		for (i = 0; i <= BBP_BATMASK; i++) {
			MT_init_lock(GDKbatLock[i].swap, "GDKswapLock");
			MT_init_lock(GDKbatLock[i].hash, "GDKhashLock");
		}
		for (i = 0; i <= BBP_THREADMASK; i++) {
			MT_init_lock(GDKbbpLock[i].alloc, "GDKcacheLock");
			MT_init_lock(GDKbbpLock[i].trim, "GDKtrimLock");
			GDKbbpLock[i].free = 0;
		}
		MT_init_lock(GDKnameLock, "GDKnameLock");
		MT_init_lock(GDKthreadLock, "GDKthreadLock");
		MT_init_lock(GDKunloadLock, "GDKunloadLock");
		MT_init_cond(GDKunloadCond, "GDKunloadCond");
		MT_init_lock(GDKtmLock, "GDKtmLock");
		malloc_lock_init();
		GDKprotected = 1;
	}
}

#ifdef HAVE_POSIX_FADVISE
static str highload_name[] = { "idle", "low", "medium", "high", "extreme" };

static MT_Id GDKvmtrim_id;
static int membits = 0;
static void
GDKvmtrim(void *limit)
{
	size_t bak_mmap_minsize = 0;
	int highload = 0;

	if (membits == 0) {
		/* compute rounded down log2 of memsize / nr_threads */
		size_t s = GDK_mem_maxsize_max / GDKnr_threads;
		while ((s >>= 1) > 0)
			membits++;
		membits = (MAX(0, membits - MT_MMAP_LOG)) / 4;
	}
	do {
		stream *fp = NULL;
		int t;
		/* sleep using catnaps so we can exit in a timely fashion */
		for (t = highload ? 500 : 5000; t > 0; t -= 50) {
			MT_sleep_ms(50);
			if (GDKstopped)
				return;
		}
		/* check for runtime overruling */
		if (GDK_vm_trim == 0) {
			highload = 0;
			continue;
		}
		MEMDEBUG {
			fp = GDKout;
			THRprintf(fp, "#GDKvmtrim(load=%s, rsstarget=" SZFMT ", GDK_mmap_minsize=" SZFMT ")\n", highload_name[highload], *(size_t *) limit, GDK_mmap_minsize);
		}
		highload = MT_mmap_trim(*(size_t *) limit, fp);
		if (highload >= 4) {
			/* in extreme load, push out VM until the rss limit */
			BBPtrim(*(size_t *) limit, *(size_t *) limit);
		}
		if (highload) {	/* memcrunch distress varies from 1 to 4 */
			/* rss is above 0.75mem_maxsize!! start using mmap-on-tempfile */
			/* minsize = memsize/threads iff highload = 0
			 *         =  ..in between.. iff highload = 1-3
			 *         =           128MB iff highload = 4
			 */
			size_t new_mmap_minsize = ((size_t) 1) << (MT_MMAP_LOG + membits * (4 - highload));
			if (!bak_mmap_minsize)
				bak_mmap_minsize = GDK_mmap_minsize;
			if (new_mmap_minsize < bak_mmap_minsize) {
				GDK_mmap_minsize = new_mmap_minsize;
			}
		} else if (bak_mmap_minsize) {
			GDK_mmap_minsize = bak_mmap_minsize;	/* revert to default setting */
			bak_mmap_minsize = 0;
		}
	} while (!GDKstopped);
}
#endif

int
GDKinit(opt *set, int setlen)
{
	char *dbname = mo_find_option(set, setlen, "gdk_dbname");
	char *dbfarm = mo_find_option(set, setlen, "gdk_dbfarm");
	char *alloc_map = mo_find_option(set, setlen, "gdk_alloc_map");
	char *p;
	opt *n;
	int i, j, nlen = 0;
	char buf[16];

	/* some sanity checks (should also find if symbols are not defined) */
	assert(sizeof(char) == SIZEOF_CHAR);
	assert(sizeof(short) == SIZEOF_SHORT);
	assert(sizeof(int) == SIZEOF_INT);
	assert(sizeof(long) == SIZEOF_LONG);
	assert(sizeof(lng) == SIZEOF_LNG);
	assert(sizeof(oid) == SIZEOF_OID);
	assert(sizeof(void *) == SIZEOF_VOID_P);
	assert(sizeof(wrd) == SIZEOF_WRD);
	assert(sizeof(size_t) == SIZEOF_SIZE_T);
	assert(sizeof(ptrdiff_t) == SIZEOF_PTRDIFF_T);
	assert(SIZEOF_OID == SIZEOF_INT || SIZEOF_OID == SIZEOF_LNG);

#ifndef PTHREAD_MUTEX_INITIALIZER
	MT_lock_init(&MT_system_lock,"GDKinit");
#endif
	gdk_alloc_map = strcasecmp(alloc_map, "yes") == 0;
	errno = 0;
	dbfarm = mo_substitute(set, setlen, dbfarm);
	if (!GDKenvironment(dbname, dbfarm)) {
		free(dbfarm);
		return 0;
	}
	free(dbfarm);

	if ((p = mo_find_option(set, setlen, "gdk_debug")))
		GDKdebug = strtol(p, NULL, 10);

	if ((p = mo_find_option(set, setlen, "gdk_mem_pagebits")))
		GDK_mem_pagebits = (int) strtol(p, NULL, 10);

	if ((p = mo_find_option(set, setlen, "gdk_vmtrim")))
		GDK_vm_trim = strcasecmp(p, "yes") == 0;

	mnstr_init();
	MT_init_posix(gdk_alloc_map);
	THRinit();
#ifndef NATIVE_WIN32
	BATSIGinit();
#endif
#ifdef WIN32
	(void) signal(SIGABRT, BATSIGabort);
	_set_abort_behavior(0, _CALL_REPORTFAULT | _WRITE_ABORT_MSG);
#endif
	GDKlockHome();

	/* Mserver by default takes 80% of all memory as a default */
	GDK_mem_maxsize_max = (size_t) ((double) MT_npages() * (double) MT_pagesize() * 0.815);
	GDK_mmap_minsize = GDK_mem_maxsize = GDK_mem_maxsize_max;
	GDKmemchk(TRUE, TRUE);
	GDKremovedir(DELDIR);
	BBPinit();

	GDKenv = BATnew(TYPE_str, TYPE_str, 100);
	if (GDKenv == NULL)
		GDKfatal("GDKinit: Could not create environment BAT");
	BATkey(GDKenv, BOUND2BTRUE);
	BATrename(GDKenv, "monet_environment");
	BATmode(GDKenv, TRANSIENT);

	n = (opt *) malloc(setlen * sizeof(opt));
	for (i = 0; i < setlen; i++) {
		int done = 0;

		for (j = 0; j < nlen; j++) {
			if (strcmp(n[j].name, set[i].name) == 0) {
				if (n[j].kind < set[i].kind) {
					n[j] = set[i];
				}
				done = 1;
				break;
			}
		}
		if (!done) {
			n[nlen] = set[i];
			nlen++;
		}
	}
	for (i = 0; i < nlen; i++) {
		char *value;

		value = mo_substitute(n, nlen, n[i].value);
		GDKsetenv(n[i].name, value);
		free(value);
	}
	free(n);

	if ((p = GDKgetenv("gdk_mem_maxsize"))) {
		GDK_mem_maxsize = MAX(1 << 26, (size_t) strtoll(p, NULL, 10));
	}
	if ((p = GDKgetenv("gdk_vm_maxsize"))) {
		GDK_vm_maxsize = MAX(1 << 30, (size_t) strtoll(p, NULL, 10));
	}
	if ((p = GDKgetenv("gdk_mem_bigsize"))) {
		/* when allocating >6% of all RAM; do so using vmalloc() iso malloc() */
		lng max_mem_bigsize = GDK_mem_maxsize_max / 16;

		/* sanity check to avoid memory fragmentation */
		GDK_mem_bigsize = (size_t) MIN(max_mem_bigsize, strtoll(p, NULL, 10));
	}
	if ((p = GDKgetenv("gdk_mmap_minsize"))) {
		GDK_mmap_minsize = MAX(REMAP_PAGE_MAXSIZE, (size_t) strtoll(p, NULL, 10));
	}
	if (GDKgetenv_isyes("gdk_embedded") || GDKgetenv_isyes("embedded"))
		GDKembedded = 1;
	if (GDKgetenv("gdk_mem_pagebits") == NULL) {
		snprintf(buf, sizeof(buf), "%d", GDK_mem_pagebits);
		GDKsetenv("gdk_mem_pagebits", buf);
	}
	if (GDKgetenv("gdk_mem_bigsize") == NULL) {
		snprintf(buf, sizeof(buf), SZFMT, GDK_mem_bigsize);
		GDKsetenv("gdk_mem_bigsize", buf);
	}
	if (GDKgetenv("monet_pid") == NULL) {
		snprintf(buf, sizeof(buf), "%d", (int) getpid());
		GDKsetenv("monet_pid", buf);
	}

	GDKnr_threads = GDKgetenv_int("gdk_nr_threads", 0);
	if (GDKnr_threads == 0)
		GDKnr_threads = MT_check_nr_cores();
#ifdef NATIVE_WIN32
	if (GDKnr_threads)
		GDK_mmap_minsize /= GDKnr_threads;
#else
	GDK_mmap_minsize = 256 * 1024 * 1024;
#endif

#ifdef HAVE_POSIX_FADVISE
	if (!GDKembedded && GDK_vm_trim)
		MT_create_thread(&GDKvmtrim_id, GDKvmtrim, &GDK_mem_maxsize, MT_THR_JOINABLE);
#endif

	return 1;
}

@-
Upon closing the session, all persistent BATs should be saved and
the transient BATs should be removed.
The buffer pool manager takes care of this.
@h
gdk_export int GDKnr_threads;

@c
int GDKnr_threads = 0;

@h
gdk_export void GDKexit(int status);

@c
/* coverity[+kill] */
void
GDKexit(int status)
{
	gdk_set_lock(GDKthreadLock, "GDKexit");
	if (GDKstopped == 0) {
		GDKstopped = 1;	/* shouldn't there be a lock here? */
#ifdef HAVE_POSIX_FADVISE
		if (!GDKembedded && GDK_vm_trim)
			MT_join_thread(GDKvmtrim_id);
#endif
		GDKnrofthreads = 0;
		gdk_unset_lock(GDKthreadLock, "GDKexit");

		/* Kill all threads except myself */
		if (status == 0) {
			MT_Id pid = MT_getpid();
			Thread t, s;

			for (t = GDKthreads, s = t + THREADS; t < s; t++) {
				if (t->pid) {
					MT_Id victim = t->pid;

					if (t->pid != pid)
						MT_kill_thread(victim);
				}
			}
		}
		(void) GDKgetHome();
#if 0
		/* we can't clean up after killing threads */
		BBPexit();
#endif
		GDKlog(GDKLOGOFF);
		GDKunlockHome();
		MT_global_exit(status);
	}
	gdk_unset_lock(GDKthreadLock, "GDKexit");
}

@
All semaphores used by the application should be mentioned here.
They are initialized during system initialization.
@c
int GDKdebug = 0;
int GDKembedded = 0;
int GDKprotected = 0;

batlock_t GDKbatLock[BBP_BATMASK + 1];
bbplock_t GDKbbpLock[BBP_THREADMASK + 1];
MT_Lock GDKnameLock;
MT_Lock GDKthreadLock;
MT_Lock GDKunloadLock;
MT_Lock GDKtmLock;
MT_Cond GDKunloadCond;

@}

@+ Concurrency control
Concurrency control requires actions at several levels of the system.
First, it should be ensured that each database  is controlled by a single
server process (group). Subsequent attempts should be stopped.
This is regulated through file locking against ".gdk_lock".
Furthermore, the server process is moved to the database directory
for improved speed.
@-
Before the locks and threads are initiated, we cannot use the
normal routines yet. So we have a local fatal here instead of GDKfatal.
@{
@c
void
GDKlockHome(void)
{
	char *p = 0, buf[1024], host[PATHLENGTH];
	char GDKdirStr[PATHLENGTH];

@-
Go there and obtain the global database lock.
@c
	/* The DIR_SEP at the end of the path is needed for a succesfull
	   call to GDKcreatedir */

	snprintf(GDKdirStr, PATHLENGTH, "%s%c%s%c", GDKdbfarmStr, DIR_SEP, GDKdbnameStr, DIR_SEP);

	if (chdir(GDKdirStr) < 0) {
		if (!GDKcreatedir(GDKdirStr))
			GDKfatal("GDKlockHome: could not create %s\n", GDKdirStr);
		if (chdir(GDKdirStr) < 0)
			GDKfatal("GDKlockHome: could not move to %s\n", GDKdirStr);
		IODEBUG THRprintf(GDKout, "#GDKlockHome: created directory %s\n", GDKdirStr);
	}
	if (GDKrecovery && unlink(GDKLOCK) < 0) {
		GDKfatal("GDKlockHome: unlock DB failed\n");
	}
	if (MT_lockf(GDKLOCK, F_TLOCK, 4, 1) < 0) {
		GDKlockFile = 0;
		GDKfatal("GDKlockHome: Database lock '%s' denied\n", GDKLOCK);
	}
	if ((GDKlockFile = fopen(GDKLOCK, "rb+")) == NULL) {
		GDKfatal("GDKlockHome: Could not open %s\n", GDKLOCK);
	}
	if (fgets(buf, 1024, GDKlockFile) && (p = strchr(buf, ':')))
		*p = 0;
	if (p) {
		sprintf(host, " from '%s'", buf);
	} else {
		IODEBUG THRprintf(GDKout, "#GDKlockHome: ignoring empty or invalid %s.\n", GDKLOCK);
		host[0] = 0;
	}
@-
We have the lock, are the only process currently allowed in this section.
@c
	MT_init();
	OIDinit();
@-
Print the new process list in the global lock file.
@c
	fseek(GDKlockFile, 0, SEEK_SET);
	if (ftruncate(fileno(GDKlockFile), 0) < 0)
		GDKfatal("GDKlockHome: Could not truncate %s\n", GDKLOCK);
	fflush(GDKlockFile);
	GDKlog(GDKLOGON);
@-
In shared mode, we allow more parties to join. Release the lock.
@c
	GDKstopped = 0;
}

void
GDKunlockHome(void)
{
	if (GDKlockFile) {
		MT_lockf(GDKLOCK, F_ULOCK, 4, 1);
		fclose(GDKlockFile);
		GDKlockFile = 0;
	}
}

@-
Really really get the lock. Now!!
@c
int
GDKgetHome(void)
{
	if (MT_initialized() == 0 || GDKlockFile)
		return 0;
	while ((GDKlockFile = fopen(GDKLOCK, "r+")) == NULL) {
		GDKerror("GDKgetHome: PANIC on open %s. sleep(1)\n", GDKLOCK);
		MT_sleep_ms(1000);
	}
	if (MT_lockf(GDKLOCK, F_TLOCK, 4, 1) < 0) {
		IODEBUG THRprintf(GDKout, "#GDKgetHome: blocking on lock '%s'.\n", GDKLOCK);
		MT_lockf(GDKLOCK, F_LOCK, 4, 1);
	}
	return 1;
}

@}

@+ Error handling
Errors come in three flavors: warnings, non-fatal and fatal errors.
A fatal error leaves a core dump behind after trying to
safe the content of the relation.
A non-fatal error returns a message to the user
and aborts the current transaction.
Fatal errors are also recorded on the system log for post-mortem
analysis.
In non-silent mode the errors are immediately sent to output,
which makes it hard for upper layers to detect if an error
was produced in the process. To facilitate such testing,
a global error count is maintained on a thread basis,
which can be read out by the function GDKerrorCount();
Furthermore, threads may have set their private error buffer.
@{
@c
int GDKsilent = 0;
static int THRerrorcount[THREADDATA];

/* do the real work for GDKaddbuf below. */
static void
doGDKaddbuf(const char *prefix, const char *message, size_t messagelen, const char *suffix)
{
	char *buf;

	THRerrorcount[THRgettid()]++;
	buf = GDKerrbuf;
	if (buf) {
		char *dst = buf + strlen(buf);
		size_t maxlen = GDKMAXERRLEN - (dst - buf) - 1;

		if (prefix && *prefix && dst < buf + GDKMAXERRLEN) {
			size_t preflen;

			strncpy(dst, prefix, maxlen);
			dst[maxlen] = '\0';
			preflen = strlen(dst);
			maxlen -= preflen;
			dst += preflen;
		}
		if (maxlen > messagelen)
			maxlen = messagelen;
		strncpy(dst, message, maxlen);
		dst += maxlen;
		if (suffix && *suffix && dst < buf + GDKMAXERRLEN) {
			size_t sufflen;

			maxlen = buf + GDKMAXERRLEN - dst - 1;
			strncpy(dst, suffix, maxlen);
			dst[maxlen] = '\0';
			sufflen = strlen(dst);
			maxlen -= sufflen;
			dst += sufflen;
		}
		*dst = '\0';
	} else if (!GDKsilent) {
		/* construct format string because the format string
		   must start with ! */
		char format[32];

		snprintf(format, sizeof(format), "%s%%.*s%s", prefix ? prefix : "", suffix ? suffix : "");
		THRprintf(GDKout, format, (int) messagelen, message);
	}
}

/* print an error or warning message, making sure the message ends in
   a newline, and also that every line in the message (if there are
   multiple), starts with an exclamation point.
   One of the problems complicating this whole issue is that each line
   should be printed using a single call to THRprintf, and moreover,
   the format string should start with a "!".  This is because
   THRprintf adds a "#" to the start of the printed text if the format
   string doesn't start with "!".
   Another problem is that we're religious about bounds checking.
   It would probably also not be quite as bad if we could write in the
   message buffer.
 */
void
GDKaddbuf(const char *message)
{
	const char *p, *q;
	char prefix[16];

	if (message == NULL || *message == '\0')	/* empty message, nothing to do */
		return;
	p = message;
	strcpy(prefix, "!");	/* default prefix */
	while (p && *p) {
		if (*p == '!') {
			size_t preflen;

			/* remember last ! prefix (e.g. "!ERROR: ")
			   for any subsequent lines that start without ! */
			message = p;
			/* A prefix consists of a ! immediately
			   followed by some text, followed by a : and
			   a space.  Anything else results in no
			   prefix being remembered */
			while (*++p && *p != ':' && *p != '\n' && *p != ' ')
				;
			if (*p == ':' && *++p == ' ') {
				/* found prefix, now remember it */
				preflen = (size_t) (p - message) + 1;
				if (preflen > sizeof(prefix) - 1)
					preflen = sizeof(prefix) - 1;
				strncpy(prefix, message, preflen);
				prefix[preflen] = 0;
			} else {
				/* there is a ! but no proper prefix */
				strcpy(prefix, "!");
				preflen = 1;
			}
			p = message + preflen;
		}

		/* find end of line */
		q = strchr(p, '\n');
		if (q) {
			/* print line including newline */
			q++;
			doGDKaddbuf(prefix, p, (size_t) (q - p), "");
		} else {
			/* no newline at end of buffer: print all the
			   rest and add a newline */
			doGDKaddbuf(prefix, p, strlen(p), "\n");
			/* we're done since there were no more newlines */
			break;
		}
		p = q;
	}
}

#define GDKERRLEN	(1024+512)

 /*VARARGS*/ int
GDKwarning(const char *format, ...)
{
	char message[GDKERRLEN];
	size_t len = strlen(GDKWARNING);
	va_list ap;

	if (!strncmp(format, GDKWARNING, len)) {
		len = 0;
	} else {
		strcpy(message, GDKWARNING);
	}
	va_start(ap, format);
	vsnprintf(message + len, sizeof(message) - (len + 2), format, ap);
	va_end(ap);

	GDKaddbuf(message);

	return 0;
}


 /*VARARGS*/ int
GDKerror(const char *format, ...)
{
	char message[GDKERRLEN];
	size_t len = strlen(GDKERROR);
	va_list ap;

	if (!strncmp(format, GDKERROR, len)) {
		len = 0;
	} else {
		strcpy(message, GDKERROR);
	}
	va_start(ap, format);
	vsnprintf(message + len, sizeof(message) - (len + 2), format, ap);
	va_end(ap);

	GDKaddbuf(message);

	return 0;
}

 /*VARARGS*/ int
GDKsyserror(const char *format, ...)
{
	char message[GDKERRLEN];
	size_t len = strlen(GDKERROR);

#ifdef NATIVE_WIN32
	DWORD err = GetLastError();
#else
	int err = errno;
#endif
	va_list ap;

	if (strncmp(format, GDKERROR, len) == 0) {
		len = 0;
	} else {
		strncpy(message, GDKERROR, sizeof(message));
	}
	va_start(ap, format);
	vsnprintf(message + len, sizeof(message) - (len + 2), format, ap);
	va_end(ap);
#ifndef NATIVE_WIN32
	if (err > 0 && err < 1024)
#endif
	{
		size_t len1;
		size_t len2;
		size_t len3;
		char *osmsg;
#ifdef NATIVE_WIN32
		char osmsgbuf[256];
		osmsg = osmsgbuf;
		FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, NULL, err,
			      MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
			      (LPTSTR) osmsgbuf, sizeof(osmsgbuf), NULL);
#else
		osmsg = strerror(err);
#endif
		len1 = strlen(message);
		len2 = len1 + strlen(GDKMESSAGE);
		len3 = len2 + strlen(osmsg);

		if (len3 + 2 < sizeof(message)) {
			strcpy(message + len1, GDKMESSAGE);
			strcpy(message + len2, osmsg);
			if (len3 > 0 && message[len3 - 1] != '\n') {
				message[len3] = '\n';
				message[len3 + 1] = 0;
			}
		}
	}
	GDKaddbuf(message);

	errno = 0;
	return err;
}

void
GDKclrerr(void)
{
	char *buf;

	buf = GDKerrbuf;
	if (buf)
		*buf = 0;
}

/* coverity[+kill] */
 /*VARARGS*/ int
GDKfatal(const char *format, ...)
{
	char message[GDKERRLEN];
	size_t len = strlen(GDKFATAL);
	va_list ap;
	FILE *fd = stderr;

	GDKdebug |= 16;
#ifndef NATIVE_WIN32
	BATSIGinit();
#endif
	if (!strncmp(format, GDKFATAL, len)) {
		len = 0;
	} else {
		strcpy(message, GDKFATAL);
	}
	va_start(ap, format);
	vsnprintf(message + len, sizeof(message) - (len + 2), format, ap);
	va_end(ap);

	if (GDKsilent == 0) {
		fputs(message, fd);
		fputs("\n", fd);
		fflush(fd);
	}
@-
Real errors should be saved in the lock file for post-crash inspection.
@c
	if (GDKstopped) {
		fflush(stdout);
		MT_exit_thread(1);
		/* exit(1); */
	} else {
		GDKlog("%s", message);
#ifdef COREDUMP
		abort();
#else
		GDKexit(1);
	}
#endif
	return -1;
}

int
GDKerrorCount(void)
{
	return THRerrorcount[THRgettid()];
}


@- Timers
The following relative timers are available for inspection.
Note that they may consume recognizable overhead.
@c

lng
GDKusec(void)
{
	/* Return the time in milliseconds since an epoch.  The epoch
	   is roughly the time this program started. */
#ifdef HAVE_QUERYPERFORMANCECOUNTER
	static LARGE_INTEGER freq, start;	/* automatically initialized to 0 */
	LARGE_INTEGER ctr;

	if (start.QuadPart == 0 &&
	    (!QueryPerformanceFrequency(&freq) ||
	     !QueryPerformanceCounter(&start)))
		start.QuadPart = -1;
	if (start.QuadPart > 0) {
		QueryPerformanceCounter(&ctr);
		return (lng) (((ctr.QuadPart - start.QuadPart) * 1000000) / freq.QuadPart);
	}
#endif
#ifdef HAVE_GETTIMEOFDAY
	{
		static struct timeval tpbase;	/* automatically initialized to 0 */
		struct timeval tp;

		if (tpbase.tv_sec == 0)
			gettimeofday(&tpbase, NULL);
		gettimeofday(&tp, NULL);
		tp.tv_sec -= tpbase.tv_sec;
		return (lng) tp.tv_sec * 1000000 + (lng) tp.tv_usec;
	}
#else
#ifdef HAVE_FTIME
	{
		static struct timeb tbbase;	/* automatically initialized to 0 */
		struct timeb tb;

		if (tbbase.time == 0)
			ftime(&tbbase);
		ftime(&tb);
		tb.time -= tbbase.time;
		return (lng) tb.time * 1000000 + (lng) tb.millitm * 1000;
	}
#endif
#endif
}


int
GDKms(void)
{
	return (int) (GDKusec() / 1000);
}

@}

@+ Logical Thread management

All semaphores used by the application should be mentioned here.
They are initialized during system initialization.

@-
The first action upon thread creation is to add it to the pool
of known threads. This should be done by the thread itself.
Subsequently, the thread descriptor can be obtained using @%THRget@.
Note that the users should have gained exclusive access already.
A new entry is initialized automatically when not found.
Its file descriptors are the same as for the server and should be
subsequently reset.
@{
@c
int GDKnrofthreads;
ThreadRec GDKthreads[THREADS];
void *THRdata[THREADDATA] = { 0 };

Thread
THRget(int tid)
{
	assert(0 < tid && tid <= THREADS);
	return (GDKthreads + tid - 1);
}

static inline size_t
THRsp(void)
{
	int l = 0;
	size_t sp = (size_t) (&l);

	return sp;
}

static Thread
GDK_find_thread(MT_Id pid)
{
	Thread t, s;

	for (t = GDKthreads, s = t + THREADS; t < s; t++) {
		if (t->pid && t->pid == pid) {
			return t;
		}
	}
	return NULL;
}

Thread
THRnew(MT_Id pid, str name)
{
	int tid = 0;
	Thread t;
	Thread s;

	gdk_set_lock(GDKthreadLock, "THRnew");
	s = GDK_find_thread(pid);
	if (s == NULL) {
		for (s = GDKthreads, t = s + THREADS; s < t; s++) {
			if (s->pid == pid) {
				gdk_unset_lock(GDKthreadLock, "THRnew");
				IODEBUG THRprintf(GDKout, "#THRnew:duplicate " SZFMT "\n", (size_t) pid);
				return s;
			}
		}
		for (s = GDKthreads, t = s + THREADS; s < t; s++) {
			if (s->pid == 0) {
				break;
			}
		}
		if (s == t) {
			gdk_unset_lock(GDKthreadLock, "THRnew");
			IODEBUG THRprintf(GDKout, "#THRnew: too many threads\n");
			return NULL;
		}
		tid = s->tid;
		memset((char *) s, 0, sizeof(*s));
		s->pid = pid;
		s->tid = tid;
		s->data[1] = THRdata[1];
		s->data[0] = THRdata[0];
		s->cleanup = NULL;
		s->sp = THRsp();

		PARDEBUG THRprintf(GDKout, "#%x " SZFMT " sp = " SZFMT "\n", s->tid, (size_t) pid, s->sp);
		PARDEBUG THRprintf(GDKout, "#nrofthreads %d\n", GDKnrofthreads);

		GDKnrofthreads++;
		MT_alloc_register(&tid, 1, (char) ('0' + ((int) tid) - 1));
	}
	s->name = name;
	gdk_unset_lock(GDKthreadLock, "THRnew");

	return s;
}

void
THRdel(Thread t)
{
	if (t < GDKthreads || t > GDKthreads + THREADS) {
		GDKfatal("THRdel: illegal call\n");
	}
	gdk_set_lock(GDKthreadLock, "THRdel");
	if (t->cleanup) {
		(*t->cleanup) (t);
	}
/*	The stream may haven been closed (e.g. in freeClient)  causing an abort
	PARDEBUG THRprintf(GDKout, "#pid = " SZFMT ", disconnected, %d left\n", (size_t) t->pid, GDKnrofthreads);
*/

	t->pid = 0;
	GDKnrofthreads--;
	gdk_unset_lock(GDKthreadLock, "THRdel");
}

@-
The easiest way to terminate a thread is to identify its name
A zero is returned when the thread could not be found
@c
int
THRexit(const char *nme)
{
	Thread t;
	Thread s;

	for (t = GDKthreads, s = t + THREADS; t < s; t++) {
		if (t->pid && t->name && strcmp(t->name, nme) == 0) {
			MT_Id victim = t->pid;

			THRdel(t);
			MT_kill_thread(victim);
			return 1;
		}
	}
	return 0;
}

int
THRcnt(void)
{
	return GDKnrofthreads;
}

int
THRhighwater(void)
{
	size_t c;
	Thread s;
	size_t diff;

	s = GDK_find_thread(MT_getpid());
	if (s == NULL)
		return 0;
	c = THRsp();
	diff = (c < s->sp) ? s->sp - c : c - s->sp;
	if (diff > (THREAD_STACK_SIZE - 16 * 1024)) {
		return 1;
	}
	return 0;
}

@-
I/O is organized per thread, because users may gain access through
the network.
The code below should be improved to gain speed.
@c

int
THRinit(void)
{
	int i = 0;

	THRdata[0] = (void *) file_wastream(stdout, "stdout");
	THRdata[1] = (void *) file_rastream(stdin, "stdin");
	for (i = 0; i < THREADS; i++) {
		GDKthreads[i].tid = i + 1;
	}
	return 0;
}

void
THRsetdata(int n, ptr val)
{
	Thread s = GDK_find_thread(MT_getpid());

	if (s)
		s->data[n] = val;
}

void *
THRgetdata(int n)
{
	Thread s = GDK_find_thread(MT_getpid());

	return (s ? s->data[n] : THRdata[n]);
}

int
THRgettid(void)
{
	Thread s = GDK_find_thread(MT_getpid());

	return s ? s->tid : 1;
}

static char THRprintbuf[BUFSIZ];

 /*VARARGS*/ int
THRprintf(stream *s, const char *format, ...)
{
	str bf = THRprintbuf, p = 0;
	size_t bfsz = BUFSIZ;
	int n = 0;
	ptrdiff_t m = 0;
	char c;
	va_list ap;

	if (!s)
		return -1;

	gdk_set_lock(MT_system_lock, "THRprintf");
	if (*format != '!') {
		c = '#';
		if (*format == '#')
			format++;
	} else {
		c = '!';
		format++;
	}

@= THRprintf_va_vsnprintf
	p = bf;
	*p++ = c;
	if (GDKdebug&1) {
		sprintf(p, "%02d ", THRgettid());
		while (*p)
			p++;
	}
	m = p - bf;
	va_start(ap, format);
	n = vsnprintf(p, bfsz-m, format, ap);
	va_end(ap);
@c
	@:THRprintf_va_vsnprintf@
	if (n < 0)
		goto cleanup;
	if ((size_t) n >= bfsz - m) {
		bfsz = m + n + 1;	/* precisely what is needed */
		if (bf != THRprintbuf)
			free(bf);
		bf = (str) malloc(bfsz);
		assert(bf != NULL);
		@:THRprintf_va_vsnprintf@
	}
	p += n;

	n = 0;
	if (mnstr_write(s, bf, p - bf, 1) != 1)
		n = -1;
      cleanup:
	if (bf != THRprintbuf)
		free(bf);
	gdk_unset_lock(MT_system_lock, "THRprintf");
	return n;
}

@h
gdk_export const char *GDKversion(void);

@c
static char *_gdk_version_string = VERSION;
/**
 * Returns the GDK version as internally allocated string.  Hence the
 * string does not have to (and should not) be freed.  Do not inline
 * this function or the wrong VERSION will be used.
 */
const char *
GDKversion(void)
{
	return (_gdk_version_string);
}

@h
#endif /* _GDK_UTILS_H_ */
@}
