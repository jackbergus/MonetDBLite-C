@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2006 CWI.
@' All Rights Reserved.

@f gdk_storage
@a M. L. Kersten, P. Boncz

@* Database Storage Management
Contains routines for writing and reading GDK data to and from disk.
This section contains the primitives to manage the disk-based images
of the BATs. It relies on the existence of a UNIX file system, including
memory mapped files. Solaris and IRIX have different implementations of
madvise().

The current version assumes that all BATs are stored on a single disk
partition. This simplistic assumption should be replaced in the near
future by a multi-volume version. The intension is to use several
BAT home locations.
The files should be owned by the database server. Otherwise, IO operations are
likely to fail. This is accomplished by setting the GID and UID upon
system start.
@{
@h
#ifndef _GDK_STORAGE_H_
#define _GDK_STORAGE_H_
#include "gdk.h"

extern void DESCclean(BAT *);
extern void DESCsetmodes(BAT *b, BAT *img);

#ifndef MAXPATHLEN
#define MAXPATHLEN 1024
#endif

#endif /* _GDK_STORAGE_H_ */
@c
#include "gdk.h"
#include <stdlib.h>
#include "gdk_storage.h"

@
@c
void
GDKfilepath(str path, str dir, str name, str ext)
{
	*path = 0;
	if (dir && *name != DIR_SEP) {
		strcpy(path, dir);
		path += strlen(dir);
	}
	strcpy(path, name);
	if (ext) {
		path += strlen(name);
		*path++ = '.';
		strcpy(path, ext);
	}
}

int
GDKcreatedir(char *dir)
{
	char path[MAXPATHLEN];
	char *r;
	int ret = TRUE;

	strcpy(path, dir);
	r = strrchr(path, DIR_SEP);
	IODEBUG THRprintf(GDKerr, "GDKcreatedir(%s)\n", path);

	if (r) {
		DIR *dirp;

		*r = 0;
		dirp = opendir(path);
		if (dirp) {
			closedir(dirp);
		} else {
			GDKcreatedir(path);
			ret = mkdir(path, 0755);
			IODEBUG THRprintf(GDKerr, "mkdir %s = %d\n", path, ret);
		}
		*r = DIR_SEP;
	}
	return !ret;
}

int
GDKremovedir(str dirname)
{
	DIR *dirp = opendir(dirname);
	char path[MAXPATHLEN];
	struct dirent *dent;
	int ret;

	IODEBUG THRprintf(GDKerr, "GDKremovedir(%s)\n", dirname);

	if (dirp == NULL)
		return 0;
	while ((dent = readdir(dirp)) != NULL) {
		if ((dent->d_name[0] == '.') && ((dent->d_name[1] == 0) || (dent->d_name[1] == '.' && dent->d_name[2] == 0))) {
			continue;
		}
		GDKfilepath(path, dirname, dent->d_name, NULL);
		ret = unlink(path);
		IODEBUG THRprintf(GDKerr, "unlink %s = %d\n", path, ret);
	}
	closedir(dirp);
	ret = rmdir(dirname);
	if (ret < 0) {
		GDKsyserror("GDKremovedir: rmdir(%s) failed.\n", DELDIR);
	}
	IODEBUG THRprintf(GDKerr, "rmdir %s = %d\n", dirname, ret);

	return ret;
}

#define _FUNBUF         0x040000
#define _FWRTHR         0x080000
#define _FRDSEQ         0x100000

int
GDKfdlocate(str nme, str mode, str extension)
{
	char buf[PATHLENGTH], *path = buf;
	int fd, flags = 0;

	if ((nme == NULL) || (*nme == 0)) {
		return 0;
	}
	GDKfilepath(path, BATDIR, nme, extension);

	if (*mode == 'm') {	/* file open for mmap? */
		mode++;
#ifdef _CYGNUS_H_
	} else {
		flags = _FRDSEQ;	/* WIN32 CreateFile(FILE_FLAG_SEQUENTIAL_SCAN) */
#endif
	}

	if (strchr(mode, 'w')) {
		flags |= O_WRONLY | O_CREAT;
	} else if (!strchr(mode, '+')) {
		flags |= O_RDONLY;
	} else {
		flags |= O_RDWR;
	}
#ifdef WIN32
	flags |= strchr(mode, 'b') ? O_BINARY : O_TEXT;
#endif
	fd = open(path, flags, 0644);
	if (fd < 0 && *mode == 'w') {
		/* try to create the directory, if that was the problem */
		char tmp[PATHLENGTH];

		strcpy(tmp, buf);
		if (GDKcreatedir(tmp)) {
			fd = open(path, flags, 0644);
		}
	}
	return fd;
}

FILE *
GDKfilelocate(str nme, str mode, str extension)
{
	int fd = GDKfdlocate(nme, mode, extension);

	if (*mode == 'm')
		mode++;
	return (fd < 0) ? NULL : fdopen(fd, mode);
}


@-
Unlink the file.
@c
static int
delete_file(str path)
{
	int err = unlink(path);

	if (err)
		GDKsyserror("GDKunlink(%s)\n", path);
	IODEBUG THRprintf(GDKerr, "unlink %s = %d\n", path, err);

	return err;
}

int
GDKunlink(str dir, str nme, str ext)
{
	if (nme && *nme) {
		char path[MAXPATHLEN];
		struct stat st;

		GDKfilepath(path, dir, nme, ext);
		if (stat(path, &st) == 0)
			return delete_file(path);
	}
	return -1;
}

@-
A move routine is overloaded to deal with extensions.
@c
int
GDKmove(str dir1, str nme1, str ext1, str dir2, str nme2, str ext2)
{
	char path1[PATHLENGTH];
	char path2[PATHLENGTH];
	int ret, t0 = 0;

	IODEBUG t0 = GDKms();

	if ((nme1 == NULL) || (*nme1 == 0)) {
		return -1;
	}
	GDKfilepath(path1, dir1, nme1, ext1);
	GDKfilepath(path2, dir2, nme2, ext2);
	ret = rename(path1, path2);

	IODEBUG THRprintf(GDKerr, "move %s %s = %d (%dms)\n", path1, path2, ret, GDKms() - t0);

	return ret;
}

@}
@+ Save and load.
The BAT is saved on disk in several files. The extension DESC
denotes the descriptor, BUNs the bun heap, and HHEAP and THEAP
the other heaps. The storage mechanism off a file can be memory mapped
(STORE_MMAP) or malloced (STORE_MEM).

These modes indicates the disk-layout and the intended mapping.
The primary concern here is to handle STORE_MMAP and STORE_MEM.
@{
@c
int
GDKsave(str nme, str ext, void *buf, size_t size, int mode)
{
	int fd = -1, err = 0;
	FILE *fp = NULL;

	IODEBUG THRprintf(GDKerr, "GDKsave: name=%s, ext=%s, mode %d\n", nme, ext ? ext : "", mode);

	if (mode == STORE_MMAP) {
@-
@}
Only dirty pages must be written to disk. Unchanged block will still be mapped
on the file, reading those will be cheap.  Only the changed blocks are now
mapped to swap space. PUSHED OUT: due to rather horrendous performance
caused by updating the image on disk.

Maybe it is better to make use of @%MT_msync()@. But then, we would need to
bring in a backup mechanism, in which stable images of the BATs are created
at commit-time.
@{
@c
		if (size) 
			err = MT_msync(buf, size, MMAP_SYNC);
		if (err)
			GDKsyserror("GDKsave: error on: name=%s, ext=%s, mode=%d\n", nme, ext ? ext : "", mode);
		IODEBUG THRprintf(GDKerr, "MT_msync(buf " PTRFMT ", size " SZFMT ", MMAP_SYNC) = %d\n", PTRFMTCAST buf, size, err);
	} else {
		if ((fd = GDKfdlocate(nme, "wb", ext)) >= 0) {
			/* write() on 64-bits Redhat for IA64 returns 32-bits signed result (= OS BUG)! */
			while (size > 0) {
				/* circumvent problems by writing huge buffers in chunks <= 1GB */
				int ret = write(fd, buf, MIN(1 << 30, size));

				if (ret < 0) {
					err = ret;
					GDKsyserror("GDKsave: error %d on: name=%s, ext=%s, mode=%d\n", err, nme, ext ? ext : "", mode);
					break;
				}
				size -= ret;
				buf = (void *) ((char *) buf + ret);
			}
			IODEBUG THRprintf(GDKerr, "fwrite(buf " PTRFMT ", size " SZFMT ", fd %d) = %d\n", PTRFMTCAST buf, size, fd, err);
		} else {
			err = -1;
		}
	}
	if (fp) {
		err |= fclose(fp);
	} else if (fd >= 0) {
		err |= close(fd);
		if (err && GDKunlink(BATDIR, nme, ext)) {
			/* do not tolerate corrupt heap images (BBPrecover on restart will kill them) */
			GDKfatal("GDKsave: could not open: name=%s, ext=%s, mode %d\n", nme, ext ? ext : "", mode);
		}
	} else if (mode != STORE_MMAP) {
		GDKerror("GDKsave: could not open: name=%s, ext=%s, mode %d\n", nme, ext ? ext : "", mode);
	}
	return err;
}

@-
Space for the load is directly allocated and the heaps are mapped.
Further initialization of the atom heaps require a separate action
defined in their implementation.
@c
char *
GDKload(str nme, str ext, size_t size, size_t chunk, int mode)
{
	char *buf = NULL;
	int fd = -1;
	ssize_t n;
	size_t n_expected = 0;
	int varsize = mode & STORE_VARSIZE;
	int store = mode & STORE_MODEMASK;
	FILE *fp = NULL;

	IODEBUG {
		THRprintf(GDKerr, "GDKload: name=%s, ext=%s, mode %d\n", nme, ext ? ext : "", store);
	}

	if (store == STORE_MEM) {
		if ((fd = GDKfdlocate(nme, "rb", ext)) >= 0) {
			/* some systems do not give you all at once */
			char *dst = buf = (char *) GDKmalloc(chunk);

			for (n_expected = size; n_expected > 0; n_expected -= n) {
				n = read(fd, dst, MIN(1 << 30, n_expected));
				IODEBUG THRprintf(GDKerr, "read(dst " PTRFMT ", n_expected " SZFMT ", fd %d) = " SSZFMT "\n", PTRFMTCAST(void *)dst, n_expected, fd, n);

				if (n <= 0)
					break;
				dst += n;
			}
		}
	} else {
		if ((fp = GDKfilelocate(nme, "mrb+", ext)) != NULL) {
			char path[MAXPATHLEN];
			int tpe = 0;
			int mod = MMAP_READ | MMAP_WRITE | MMAP_SEQUENTIAL | MMAP_SYNC;

			fseek(fp, (ssize_t) chunk, SEEK_SET);
			fputc('\n', fp);
			fflush(fp);
			fclose(fp);
			fp = NULL;

			if (mode == STORE_PRIV) 
				mod |= MMAP_COPY;
			GDKfilepath(path, BATDIR, nme, ext);
			buf = (char *) GDKmmap(path, mod, (off_t) 0, chunk, (void *) 0);
			if (buf == (char *) -1L) {
				GDKsyserror("GDKload: cannot mmap(): name=%s, ext=%s\n", nme, ext ? ext : "");
				buf = NULL;
			}
			IODEBUG THRprintf(GDKerr, "mmap(NULL, 0, chunk " SZFMT ", mod %d, tpe %d, path %s, 0) = " PTRFMT "\n", chunk, mod, tpe, path, PTRFMTCAST(void *)buf);

			n_expected = 0;
		}
	}
	n = (ssize_t) n_expected;
	if (n > 0 && !varsize) {
		GDKerror("GDKload: read error: name=%s, ext=%s, n=%d\n", nme, ext ? ext : "", n);
		return 0;
	} else if (n < 0) {
		GDKwarning("GDKload: file larger than expected: name=%s, ext=%s\n", nme, ext ? ext : "");
	}
	if (fd >= 0)
		close(fd);
	if (fp != NULL)
		fclose(fp);
	return buf;
}

@}
@+ BAT disk storage

Between sessions the BATs comprising the database are saved on disk.
To simplify code, we assume a UNIX directory called its  physical @%home@
where they are to be located.
The subdirectories BAT and PRG contain what its name says.

A BAT created by @%BATnew@ is considered temporary until one calls
the routine @%BATsave@. This routine reserves disk space and checks
for name clashes.

Saving and restoring BATs is left to the upper layers. The library merely
copies the data into place.
Failure to read or write the BAT results in a NULL, otherwise
it returns the BAT pointer.
@{
@c
static BAT *
DESCload(int i)
{
	str s, nme = BBP_physical(i);
	BATstore *bs;
	BAT *b = NULL;
	int ht, tt; 

	IODEBUG {
		THRprintf(GDKerr, "DESCload %s\n", nme);
	}
	bs = BBPgetdesc(i);

	if (bs == NULL)
		return 0;
	b = &bs->B;

	ht = b->htype;
	tt = b->ttype;
	if ((ht < 0 && (ht = ATOMindex(s = ATOMunknown_name(ht))) < 0 ) ||
	    (tt < 0 && (tt = ATOMindex(s = ATOMunknown_name(tt))) < 0 )) {
		GDKerror("DESCload: atom '%s' unknown, in BAT '%s'.\n", s, nme);
		return NULL;
	}
	b->htype = ht;
	b->ttype = tt;
	b->hhash = b->thash = NULL;
	b->batSharecnt = 0;
	b->void_cnt = 0;
	/* mil shouldn't mess with just loaded bats */
	if (b->batStamp > 0)
		b->batStamp = -b->batStamp;

	/* reconstruct mode from BBP status (BATmode doesn't flush descriptor, so loaded mode may be stale) */
	b->batPersistence = (BBP_status(b->batCacheid) & BBPTMP) ? TRANSIENT : (BBP_status(b->batCacheid) & (BBPNEW | BBPPERSISTENT)) ? PERSISTENT : SESSION;
	b->batCopiedtodisk = 1;

	return b;
}

void
DESCsetmodes(BAT *b, BAT *img)
{
	/* propagate the proposed modes to the separate img of the bat (so concurrent execution on this bat is not affected) */
	if (b->batMapbuns != (char) -1) {
		img->batBuns->storage = b->batMapbuns;
	}
	if (img->hheap && b->batMaphheap != (char) -1) {
		img->hheap->storage = b->batMaphheap;
	}
	if (img->theap && b->batMaptheap != (char) -1) {
		img->theap->storage = b->batMaptheap;
	}

	/* change modes in img into legal modes, and reset b's mapdity if something had to be corrected */
	b->batMapdirty |= BATcheckmodes(img, BBP_status(b->batCacheid) & BBPEXISTING, FALSE);
}

void
DESCclean(BAT *b)
{
	b->batDirtyflushed = DELTAdirty(b) ? TRUE : FALSE;
	b->batDirty = 0;
	b->batDirtydesc = 0;
	b->batDirtybuns = 0;
	b->hheapdirty = 0;
	b->theapdirty = 0;
}


BAT *
BATsave(BAT *bd)
{
	int err = 0;
	char *nme;
	BATstore bs;
	BAT *b = bd;

	BATcheck(b, "BATsave");
	if (VIEWparent(b)) {
		GDKerror("BATsave: %s is a view on %s; cannot be saved\n", BATgetId(b), BBPname(VIEWparent(b)));
		return NULL;
	}
	if (!BATdirty(b)) {
		return b;
	}
	if (b->batCacheid < 0) {
		b = BATmirror(b);
	}
	if (!DELTAdirty(b))
		ALIGNcommit(b);
	if (!b->halign)
		b->halign = OIDnew(1);
	if (!b->talign)
		b->talign = OIDnew(1);

	/* copy the descriptor to a local variable in order to let our messing in
	 * the BAT descriptor not affect other threads that only read it. */
	bs = *(BATstore *) b;
	b = &bs.B;
	b->U = &bs.U;
	b->P = &bs.P;
	b->H = &bs.H;
	b->T = &bs.T;

	b->batBuns = &b->U->buns;

	if (b->hheap) {
		b->hheap = (Heap*)GDKmalloc(sizeof(Heap));
		*b->hheap = *bd->hheap; 
	}
	if (b->theap) {
		b->theap = (Heap*)GDKmalloc(sizeof(Heap));
		*b->theap = *bd->theap; 
	}

	/* start saving data */
	nme = BBP_physical(b->batCacheid);
	if ((b->batCopiedtodisk == 0 || b->batDirty || b->batDirtybuns) &&
	    (b->htype != TYPE_void || b->ttype != TYPE_void)) {
		if (err == 0)
			err = HEAPsave(b->batBuns, nme, "buns");
	}
	if (b->hheap && (b->batCopiedtodisk == 0 || b->batDirty || b->hheapdirty))
		if (b->htype && b->hvarsized) {
			if (err == 0)
				err = HEAPsave(b->hheap, nme, "hheap");
		}
	if (b->theap && (b->batCopiedtodisk == 0 || b->batDirty || b->theapdirty))
		if (b->ttype && b->tvarsized) {
			if (err == 0) 
				err = HEAPsave(b->theap, nme, "theap");
		}
	/* correct heap modes such that they are ACID respecting */
	DESCsetmodes(bd, b);

	if (err == 0)
		if (b->batCopiedtodisk == 0 || b->batDirty || b->batDirtydesc) {
			DESCclean(b);
			b->batCopiedtodisk = 1;
			err = BATsavedesc(b, nme);
			IODEBUG THRprintf(GDKerr, "BATsavedesc(%s,free=%d) = %d\n", nme, b->batBuns->free, err);
		}

	if (b->hheap) GDKfree(b->hheap);
	if (b->theap) GDKfree(b->theap);

	if (err == 0) {
		bd->batCopiedtodisk = 1;
		DESCclean(bd);
		return bd;
	}
	return NULL;
}


@-
TODO: move to gdk_bbp.mx
@c
BAT *
BATload_intern(bat i)
{
	bat bid = ABS(i);
	str nme = BBP_physical(bid);
	BAT *b = DESCload(bid);
	int ret = 0;

	if (b == NULL) {
		return NULL;
	}
	/* LOAD bun heap */
	if (b->htype != TYPE_void || b->ttype != TYPE_void) {
		ret = HEAPload(b->batBuns, nme, "buns", b->batRestricted == BAT_READ);
		if (ret < 0) {
			return NULL;
		}
	}

	/* LOAD head heap */
	if (ATOMvarsized(b->htype) && ret >= 0) {
		ret |= HEAPload(b->hheap, nme, "hheap", b->batRestricted == BAT_READ);
		assert(ret >= 0);
		if (ret >= 0 && BATatoms[b->htype].atomHeapCheck == HEAP_check)
			HEAP_init(b->hheap, b->htype);
	}

	/* LOAD tail heap */
	if (ATOMvarsized(b->ttype) && ret >= 0) {
		ret |= HEAPload(b->theap, nme, "theap", b->batRestricted == BAT_READ);
		assert(ret >= 0);
		if (ret >= 0 && BATatoms[b->ttype].atomHeapCheck == HEAP_check)
			HEAP_init(b->theap, b->ttype);
	}

	/* handle fatal errors */
	if (ret < 0) {
		HEAPfree(b->batBuns);
		if (b->hheap) 
			HEAPfree(b->hheap);
		if (b->theap) 
			HEAPfree(b->theap);
		return NULL;
	}

	/* initialize descriptor */
	b->batMapdirty = ret;	/* heap mode changed during load? */
	b->batDirtydesc = FALSE;
	b->batParentid = 0;
	b->batSharecnt = 0;
	DELTAload(b);

	/* load succeeded; register it in BBP */
	BBPcacheit(b);

	if (!DELTAdirty(b)) {
		ALIGNcommit(b);
	}
	b->batDirtydesc |= b->batMapdirty;	/* if some heap mode changed, make desc dirty */
	b->batMapbuns = (char) b->batBuns->storage;
	if (b->hheap) b->batMaphheap = (char) b->hheap->storage;
	if (b->theap) b->batMaptheap = (char) b->theap->storage;

	if ((b->batRestricted == BAT_WRITE && (GDKdebug & 2)) || (GDKdebug & 8)) {
		++b->batSharecnt;
		BATpropcheck(b, BATPROPS_CHECK);
		--b->batSharecnt;
	}
	return (i < 0) ? BATmirror(b) : b;
}

BAT *
BATload(str nme)
{
	str s = strrchr(nme, DIR_SEP);
	bat i = BBPindex(s ? s + 1 : nme);
	BAT *b = BBP_cache(i);

	if (i == 0 || b != NULL) {
		return b;	/* inexistent bat or already loaded */
	}
	return BATload_intern(i);
}

@}

@- BATdelete
The new behavior is to let the routine produce warnings but always succeed.
rationale: on a delete, we must get rid of *all* the files. We do not have to care
about preserving them or be too much concerned if a file that had to be deleted was
not found (end result is still that it does not exist). The past behavior to delete
some files and then fail was erroneous. The BAT would continue to exist with an
incorrect disk status, causing havoc later on.

NT forces us to close all files before deleting them; in case of memory mapped
files this means that we have to unload the BATs before deleting. This is
enforced now.
@{
@c
int
BATdelete(BAT *b)
{
	bat bid = ABS(b->batCacheid);
	str o = BBP_physical(bid);
	BAT *loaded = BBP_cache(bid);

	if (loaded) {
		b = loaded;
		HASHdestroy(b);
		GDKfree(BATmirror(b));
		BBP_cache(-b->batCacheid) = NULL;
	}
	if (b->batCopiedtodisk) {
		IODEBUG THRprintf(GDKerr, "BATdelete %s\n", o);

		if (GDKunlink(BATDIR, o, "desc")) {
			GDKwarning("BATdelete(%s): descriptor\n", BATgetId(b));
		}
	}
	if (b->batCopiedtodisk || (b->batBuns->storage & STORE_MMAP)) {
		if ((b->htype != TYPE_void || b->ttype != TYPE_void) &&
		    HEAPdelete(b->batBuns, o, "buns") &&
		    b->batCopiedtodisk)
			GDKwarning("BATdelete(%s): bun heap\n", BATgetId(b));
	} else if (b->batBuns->base) {
		HEAPfree(b->batBuns);
	}
	if (b->hheap) {
		if (b->batCopiedtodisk || (b->hheap->storage & STORE_MMAP)) {
			if (HEAPdelete(b->hheap, o, "hheap") && b->batCopiedtodisk)
				GDKwarning("BATdelete(%s): head heap\n", BATgetId(b));
		} else {
			HEAPfree(b->hheap);
		}
	}
	if (b->theap) {
		if (b->batCopiedtodisk || (b->theap->storage & STORE_MMAP)) {
			if (HEAPdelete(b->theap, o, "theap") && b->batCopiedtodisk)
				GDKwarning("BATdelete(%s): tail heap\n", BATgetId(b));
		} else {
			HEAPfree(b->theap);
		}
	}
	b->batCopiedtodisk = FALSE;
	return 0;
}

@
@}

@+ Printing and debugging
Printing BATs is based on the multi-join on heads. The multijoin
exploits all possible Monet properties and accelerators. Due
to this property, the n-ary table printing is quite fast and
can be used for producing ASCII dumps of large tables.

It all works with hooks.  The multijoin routine finds matching ranges
of rows. For each found match in a column it first calls a value-routine
hook. This routine we use to format a substring.
For each found match-tuple (the Cartesian product of all matches
across columns) a match routine hook is called. We use this routine
to print a line.
Due to this setup, we only format each value once, though it
might participate in many lines (due to the Cartesian product).

The multijoin is quite complex, and we use a @%col_format_t@
struct to keep track of column specific data.
The multiprint can indicate arbitrary orderings. This is done
by passing a pattern-string that matches the following regexp:

@verbatim
	"[X:] Y0 {,Yi}"
@end verbatim

where X and Yi are column numbers, @strong{starting at 1} for the first
BAT parameter.

The table ordering has two aspects:
@enumerate
@item (1)
 	the order in which the matches appear (a.k.a. the major ordering).
	This is equivalent to the order of the head values of the BATs
	(as we match=multijoin on head value).
@item (2)
	within each match, the order in which the Cartesian
   	product is produced. This is used to sub-order on
	the tail values of the BATs = the columns in the table.
@end enumerate

Concerning (1), the multijoin limits itself to *respecting*
the order one one elected BAT, that can be identified with X.
Using this, a major ordering on tail value can be enforced,
by first passing "Bx.reverse.sort.reverse" (BAT ordered on tail).
As the multijoin will respect the order of X, its tail values
will be printed in sorted order.

Concerning sub-ordering on other columns (2), the multijoin
itself employs qsort() to order the Cartesian product on
the matched tail values.
@{
@c
#define LINE(s,	X)	do {						\
				int n=X-1;				\
				if (stream_write(s, "#", 1, 1) != 1)	\
					break;				\
				while(n-->0)				\
					if (stream_write(s, "-", 1, 1) != 1) \
						break;			\
				if (!stream_errnr(s))			\
					stream_write(s, "#\n", 2, 1);	\
			} while (0)
#define TABS(s,	X)	do {						\
				int n=X;				\
				while (n-->0)				\
					if (stream_write(s, "\t", 1, 1) != 1) \
						break;			\
			} while (0)

typedef int (*strFcn) (str *s, int *len, ptr val);

typedef struct {
	int tabs;		/* tab width of output */
	strFcn format;		/* tostr function */
	/* dynamic fields, set by print_format */
	str buf;		/* tail value as string */
	str tpe;		/* type of this column as string */
	int size;		/* size of buf */
	int len;		/* strlen(buf) */
} col_format_t;

static int
print_nil(char **dst, int *len, ptr dummy)
{
	(void) dummy;
	if (*len < 3) {
		if (*dst)
			GDKfree(*dst);
		*dst = (char *) GDKmalloc(*len = 40);
	}
	strcpy(*dst, "nil");
	return 3;
}

#define printfcn(b)	((b->ttype==TYPE_void && b->tseqbase==oid_nil)?\
			          print_nil:BATatoms[b->ttype].atomToStr)

static int
print_tabwidth(BAT *b, str title, col_format_t *c)
{
	strFcn tostr = printfcn(b);
	size_t cnt = BATcount(b);
	int max, t = BATttype(b);

	c->tpe = ATOMname(b->ttype);
	c->buf = (char *) GDKmalloc(c->size = strLen(title));
	max = (int) MAX((2 + strlen(c->tpe)), strlen(title));

	if (t >= 0 && t < GDKatomcnt && tostr) {
		size_t off = BUNindex(b, BUNfirst(b));
		int k;
		size_t j, i, probe = MIN(cnt, MAX(200, MIN(1024, cnt / 100)));

		for (i = 0; i < probe; i++) {
			j = off + ((probe == cnt) ? i : (rand() % MIN(16384, cnt)));
			k = (*tostr) (&c->buf, &c->size, BUNtail(b, BUNptr(b, j)));
			if (k > max)
				max = k;
		}
	}
	strcpy(c->buf, title);
	max += 2;		/* account for ", " separator */
	/* if (max > 60) max = 60; */
	return 1 + (max - 1) / 8;
}

static void
print_line(stream *s, col_format_t **l)
{
	col_format_t *c = *(l++);

	if (stream_write(s, "[ ", 2, 1) != 1)
		return;
	if (c->format) {
		if (stream_write(s, c->buf, c->len, 1) != 1)
			return;
		if (stream_write(s, ",", 1, 1) != 1)
			return;
		TABS(s, c->tabs - ((c->len + 3) / 8));
		if (stream_errnr(s))
			return;
		if (c->tabs * 8 >= c->len + 3 && stream_write(s, " ", 1, 1) != 1)
			return;
		if (stream_write(s, " ", 1, 1) != 1)
			return;
	}
	for (c = *l; *(++l); c = *l) {
		if (!c->format) 
			continue;
		if (stream_write(s, c->buf, c->len, 1) != 1)
			return;
		if (stream_write(s, ",", 1, 1) != 1)
			return;
		TABS(s, c->tabs - ((c->len + 3) / 8));
		if (stream_errnr(s))
			return;
		if (c->tabs * 8 >= c->len + 3 && stream_write(s, " ", 1, 1) != 1)
			return;
		if (stream_write(s, " ", 1, 1) != 1)
			return;
	}
	if (stream_write(s, c->buf, c->len, 1) != 1)
		return;
	TABS(s, c->tabs - ((c->len + 2) / 8));
	if (stream_errnr(s))
		return;
	stream_printf(s, "  ]\n");
}

static void
print_format(col_format_t *c, ptr v)
{
	if (c->format)
		c->len = (*c->format) (&c->buf, &c->size, v);
}

@= print_head
	str buf = @1?argv[@2].tpe:argv[@2].buf; /* contains column title */
	int len = (int) strlen(buf);

	if (stream_write(s, buf, len, 1) != 1)
		return -1;
	TABS(s, argv[@2].tabs-((@1+len-1)/8));
	if (stream_errnr(s))
		return -1;
@= print_header
	k = 1;
	if (stream_write(s, "# ", 2, 1) != 1)
		return -1;
	if (argv[0].format) {
		@:print_head(@1,0)@
	}
	for (;;) {
		@:print_head(@1,k)@
		if (k++ >= argc)
			break;
	}
	if(@1) {
		if (stream_printf(s, "  # type\n") < 0)
			return -1;
	} else {
		if (stream_printf(s, "  # name\n") < 0)
			return -1;
	}
@c
static int
print_header(int argc, col_format_t *argv, stream *s)
{
	int k;

	@:print_header(0)@
	@:print_header(2)@
	return 0;
}

@-
The simple BAT printing routines make use of the complex case.
@c
int
BATprint(BAT *b)
{
	ERRORcheck(b == NULL, "BATprint: BAT expected");
	return BATmultiprintf(GDKstdout, 2, &b, TRUE, 0, 1);
}

int
BATprintf(stream *s, BAT *b)
{
	ERRORcheck(b == NULL, "BATprintf: BAT expected");
	return BATmultiprintf(s, 2, &b, TRUE, 0, 1);
}

@+ Multi-Bat Printing
This routines uses the multi-join operation to print
an n-ary table. Such a table is the reconstruction of
the relational model from Monet's BATs, and consists of
all tail values of matching head-values in n-ary equijoin.
@c

int
BATmultiprintf(stream *s,	/* output stream */
	       int argc,	/* #ncolumns = #nbats +  */
	       BAT *argv[],	/* the bats 2b printed */
	       int printhead,	/* boolean: print the head column? */
	       int order,	/* respect order of bat X (X=0 is none) */
	       int printorder   /* boolean: print the orderby column? */
    )
{
	col_format_t *c = (col_format_t *) alloca((unsigned) (argc * sizeof(col_format_t)));
	col_format_t **cp = (col_format_t **) alloca((unsigned) ((argc + 1) * sizeof(void *)));
	ColFcn *value_fcn = (ColFcn *) alloca((unsigned) (argc * sizeof(ColFcn)));
	int ret = 0, j, total = 0;

@-
Init the column descriptor of the head column.
@c
	cp[argc] = NULL;	/* terminator */
	cp[0] = c;
	memset(c, 0, (argc--) * sizeof(col_format_t));
@-
Init the column descriptors of the tail columns.
@c
	value_fcn[0] = (ColFcn) print_format;
	if (printhead) {
		BAT *b = BATmirror(argv[0]);

		total = c[0].tabs = print_tabwidth(b, b->tident, c + 0);
		c[0].format = printfcn(b);
	}
	for (j = 0; j < argc; j++, total += c[j].tabs) {
		cp[j + 1] = c + (j + 1);
		if (!printorder && order==j+1)
			c[j + 1].format = NULL;
		else
			c[j + 1].format = printfcn(argv[j]);
		c[j + 1].tabs = print_tabwidth(argv[j], argv[j]->tident, c + (j + 1));
		value_fcn[j + 1] = (ColFcn) print_format;
	}
	total = 2 + (total * 8);
@-
Print the table header and then the multijoin.
@c
	ret = -1;
	LINE(s, total);
	if (stream_errnr(s))
		goto cleanup;
	if (print_header(argc, c, s) < 0)
		goto cleanup;
	LINE(s, total);
	if (stream_errnr(s))
		goto cleanup;
	else if (argc == 1) {
		BAT *b = argv[0];
		BUN p, q;

		BATloop(b, p, q) {
			print_format(cp[0], BUNhead(b, p));
			print_format(cp[1], BUNtail(b, p));
			print_line(s, cp);
			if (stream_errnr(s))
				goto cleanup;
		}
		MULTIJOIN_LEAD(ret) = 1;
		MULTIJOIN_SORTED(ret) = (BAThordered(b) & 1);
		MULTIJOIN_KEY(ret) = b->hkey;
		MULTIJOIN_SYNCED(ret) = 1;
	} else {
		ret = BATmultijoin(argc, argv, (RowFcn) print_line, (void *) s, value_fcn, (void **) cp, order);
	}
@-
Cleanup.
@c
      cleanup:
	for (j = 0; j <= argc; j++) {
		if (c[j].buf)
			GDKfree(c[j].buf);
	}
	return ret;
}

@}
