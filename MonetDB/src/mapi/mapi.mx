@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2005 CWI.
@' All Rights Reserved.

@f mapi
@a N.J. Nes, P. Boncz
@t MonetDB's Simple Network Interface
@v 1.1

This module contains a simple interface for network connections.

@m
.MODULE mapi;
	.USE streams;

	.BUILTIN mapi_listen2(int port, str sockfile, int maxusers, str cmd, bit open, ptr handle) = MAPIlisten; 
		"Start the Mapi listener on <port> and/or <sockfile> for <maxusers>.\n For a new client connection MIL procedure <cmd>(Stream s_in, Stream s_out) is called.\nIf no <cmd> is specified a new client thread is forked.\n <sockfile> is the name of a Unix socket.\n If <open> is true, accept connections from everywhere, otherwise only from localhost."

	.BUILTIN mapi_listen_ssl(int port, int maxusers, str keyfile, str certfile, str cmd) = MAPIlistenSSL;
		"Start the Mapi listener on <port> for <maxusers> using SSL.\n<keyfile> and <certfile> give the path names for files with the server key and certificates in PEM format.\nFor a new client connection MIL procedure <cmd>(Stream s_in, Stream s_out) is called.\nIf no <cmd> is specified a new client thread is forked."

	.COMMAND stream_until(Stream S,str stop) : str = stream_read_until;
		"read a string from <S> until the <stop> word"

	.BUILTIN milclient(stream in, stream out) : void = client; 
		"mapi-client" 

	.PRELUDE = mapi_prelude;
	.EPILOGUE = mapi_epilogue;

.END mapi;

@mil
	VAR mapi_params := bat(int,str);
	mapi_params.rename("mapi_params");

	PROC mapi_listen(int port, int maxusers, str cmd, bit open, ptr handle) : void {
		mapi_listen2(port, str(nil), maxusers, cmd, open, handle);
	}
	ADDHELP("mapi_listen", "sjoerd", "May 23 2005",
		"Start the Mapi listener on <port> for <maxusers>.\n For a new client connection MIL procedure <cmd>(Stream s_in, Stream s_out) is called.\nIf no <cmd> is specified a new client thread is forked.\n If <open> is true, accept connections from everywhere, otherwise only from localhost.",
		mod());

	PROC mapi_listen(int port, int maxusers, str cmd, bit open) : void {
		mapi_listen2(port, str(nil), maxusers, cmd, open, ptr(0LL));
	}

	PROC mapi_listen(int port, int maxusers, str cmd) : void {
		mapi_listen(port, maxusers, cmd, false);
	}
	ADDHELP("mapi_listen", "sjoerd", "Oct 5 2004",
		"Start the Mapi listener on <port> for <maxusers>.\n For a new client connection MIL procedure <cmd>(Stream s_in, Stream s_out) is called.\nIf no <cmd> is specified a new client thread is forked.",
		mod());

	PROC listen(int port, str sockfile, int maxusers, str cmd, bit open) : void {
		mapi_params.insert(port,cmd);
		mapi_listen2(port,sockfile,maxusers,cmd,open);
	}
	ADDHELP("listen", "sjoerd", "May 23 2005",
		"Start the Mapi listener on <port> and/or <sockfile> for <maxusers>.\nFor a new client connection MIL procedure <cmd>(int sock) is called.\nIf no <cmd> is specified a new client thread is forked.\n If <open> is true, accept connections from everywhere, otherwise only from localhost.",
		mod());

	PROC listen(int port, str sockfile, int maxusers, str cmd) : void {
		listen(port,sockfile,maxusers,cmd,false);
	}
	ADDHELP("listen", "sjoerd", "Oct  5 2004",
		"Start the Mapi listener on <port> and/or <sockfile> for <maxusers>.\nFor a new client connection MIL procedure <cmd>(int sock) is called.\nIf no <cmd> is specified a new client thread is forked.",
		mod());

	PROC listen(int port, int maxusers, str cmd, bit open) : void {
		listen(port,str(nil),maxusers,cmd,open);
	}
	ADDHELP("listen", "sjoerd", "May 23 2005",
		"Start the Mapi listener on <port> for <maxusers>.\nFor a new client connection MIL procedure <cmd>(int sock) is called.\nIf no <cmd> is specified a new client thread is forked.\n If <open> is true, accept connections from everywhere, otherwise only from localhost.\n If <open> is true, accept connections from everywhere, otherwise only from localhost.",
		mod());

	PROC listen(int port, int maxusers, str cmd) : void {
		listen(port,str(nil),maxusers,cmd);
	}
	ADDHELP("listen", "windhouw", "June  22 2001",
		"Start the Mapi listener on <port> for <maxusers>.\nFor a new client connection MIL procedure <cmd>(int sock) is called.\nIf no <cmd> is specified a new client thread is forked.",
		mod());

	PROC listen(int port, int maxusers, bit open) : void {
		listen(port,str(nil),maxusers,"",open);
	}
	ADDHELP("listen", "sjoerd", "May  23 2005",
		"Start the Mapi listener on <port> for <maxusers>.\n If <open> is true, accept connections from everywhere, otherwise only from localhost.",
		mod());

	PROC listen(int port, int maxusers) : void {
		listen(port,str(nil),maxusers,"");
	}
	ADDHELP("listen", "windhouw", "June  22 2001",
		"Start the Mapi listener on <port> for <maxusers>.",
		mod());

	PROC listen(int port, str cmd, bit open) : void {
		listen(port,str(nil),5,cmd,open);
	}
	ADDHELP("listen", "sjoerd", "May 23 2005",
		"Start the Mapi listener on <port>.\nFor a new client connection MIL procedure <cmd>(int sock) is called.\n If <open> is true, accept connections from everywhere, otherwise only from localhost.",
		mod());

	PROC listen(int port, str cmd) : void {
		listen(port,str(nil),5,cmd);
	}
	ADDHELP("listen", "windhouw", "June  22 2001",
		"Start the Mapi listener on <port>.\nFor a new client connection MIL procedure <cmd>(int sock) is called.",
		mod());

	PROC listen(int port, bit open) : void {
		listen(port,str(nil),5,"",open);
	}
	ADDHELP("listen", "sjoerd", "May 23 2005",
		"Start the Mapi listener on <port>.\n If <open> is true, accept connections from everywhere, otherwise only from localhost.",
		mod());

	PROC listen(int port) : void { listen(port,str(nil),5,""); }
	ADDHELP("listen", "windhouw", "June  22 2001",
		"Start the Mapi listener on <port>.",
		mod());

	PROC listen(str cmd, bit open) : void {
		listen(50000,str(nil),5,cmd,open);
	}
	ADDHELP("listen", "sjoerd", "May 23 2005",
		"Start the Mapi listener on 50000.\nFor a new client connection MIL procedure <cmd>(int sock) is called.\n If <open> is true, accept connections from everywhere, otherwise only from localhost.",
		mod());

	PROC listen(str cmd) : void { listen(50000,str(nil),5,cmd); }
	ADDHELP("listen", "windhouw", "June  22 2001",
		"Start the Mapi listener on 50000.\nFor a new client connection MIL procedure <cmd>(int sock) is called.",
		mod());

	PROC listen(bit open) : void {
		listen(50000,str(nil),5,"",open);
	}
	ADDHELP("listen", "sjoerd", "May 23 2005",
		"Start the Mapi listener on 50000.\n If <open> is true, accept connections from everywhere, otherwise only from localhost.",
		mod());

	PROC listen() : void {
		listen(50000,str(nil),5,"");
	}
	ADDHELP("listen", "windhouw", "June  22 2001",
		"Start the Mapi listener on 50000.",
		mod());

	PROC stream_strip(Stream s,str stop) : str {
		VAR res := stream_until(s,stop);
		VAR pos := r_search(res,stop);
		IF (pos != -1) {
			res := string(res,0,pos);
		}
		RETURN res;
	}
	ADDHELP("stream_strip", "windhouw", "June  22 2001",
		"Read a string from <S> until the <stop> word.\nThe <stop> word is stripped from the result string.",
		mod());

	PROC mapi_stream_read(Stream s) : str {
		RETURN stream_strip(s,(""+chr(1)));
	}
	ADDHELP("mapi_stream_read", "windhouw", "June  22 2001",
		"Read a string from <S> until a '\1' character.",
		mod());

	PROC stream_line(Stream s) : str {
		RETURN stream_strip(s,sprintf("%c",chr(10)));
	}
	ADDHELP("stream_line", "windhouw", "June  22 2001",
		"Read a string from <S> until a newline.",
		mod());
@{
@h
#ifndef MAPI_H
#define MAPI_H

#include <streams.h>
#include <monet_context.h>
#include <mapi.proto.h>

#define NEW_ARRAY( type, size )	(type*)GDKmalloc((size)*sizeof(type))
#define STREQ(a, b) 		(strcmp(a, b)==0)

#define MAPIPORT		50000
#define MAPISSLPORT		40000
#define MAPIMAXUSERS 		5

mapi_export int MAPIinitClient(Client c, str cmd, stream *fdin, stream *fdout);

#endif /* MAPI_H */
@c
#include <monet.h>
#include "mapi.h"
#include  <sys/types.h>
#ifdef HAVE_SYS_SOCKET_H
# include <sys/socket.h>
#endif
#ifdef NATIVE_WIN32
# include <winsock.h>
#endif
#ifdef HAVE_SYS_UN_H
#include <sys/un.h>
#endif

#define SOCKPTR struct sockaddr *
#if HAVE_SOCKLEN_T
#define SOCKLEN socklen_t
#else
#define SOCKLEN int
#endif

#ifdef HAVE_OPENSSL
#include <openssl/ssl.h>
#include <openssl/err.h>
#endif

@= builtin_operand
{       int _k = interpret(stk, arg(lt, @1), res);
        if (_k < 0) {
                return _k;
        }
        @3 = VALconvert(@2, res);
        if (((ptr) @3 == ILLEGALVALUE)  || (@2 == TYPE_bat && !@3)) {
                return handle_paramerror(res,@1,res->vtype,@2);
        }
}
@c
int MAPIinitClient(Client c, str cmd, stream *fdin, stream *fdout) {
	if (c->mil_accept == NULL) {				
		int stream_tpe = ATOMindex("Stream");
		ValRecord fds[3];
		monet_sig_t sig;
	
		fds[1].vtype = fds[2].vtype = stream_tpe;
		Myyexpand(	
			Myyexpand(
				c->mil_accept = Myynode(TOK_BUILTIN, TYPE_int), 
				Myynode(TOK_CONSTANT, stream_tpe)),
			Myynode(TOK_CONSTANT, stream_tpe));
		sig.token = TBL_normal_resolve(cmd, 3, fds, &sig, c->stk);
		if (sig.token != TOK_BUILTIN) {
			GDKerror("MAPIinitClient: builtin function %s(stream,stream) unknown\n", cmd);
			closeClient(c, FALSE);
			return -1;
		}
		c->mil_accept->yyval.val.pval = sig.fast_fcn;
	}
	c->mil_accept->yysons[0]->yyval.val.pval = fdin;
	c->mil_accept->yysons[1]->yyval.val.pval = fdout;
	return 0;
}

int
MAPIlisten(Cntxt stk, YYSTREE lt, ValPtr res)
{
	struct sockaddr_in server;
	int sock = -1;

#ifdef HAVE_SYS_UN_H
	struct sockaddr_un userver;
	int usock = -1;
#endif
	char *usockfile;
	SOCKLEN length = 0;
	int on = 1;
	int i = 0;

	int port, *Port;
	int maxusers, *Maxusers;
	char *cmd;
	Client father;
	int accept_any, *Accept_any;
	Client (*get_client)(stream*, stream*) = NULL; 
	ptr *Get_client;

	CNTXTclient(stk, &father);
	if (lt->cnt > 6) {
		return handle_argerror(res, lt->cnt, 5);
	}
	@:builtin_operand(0,TYPE_int,Port)@
	port = *Port;
	@:builtin_operand(1,TYPE_str,usockfile)@
	if (usockfile == NULL || *usockfile == 0 || strcmp(usockfile, str_nil) == 0)
		usockfile = NULL;
	else {
#ifdef HAVE_SYS_UN_H
		usockfile = GDKstrdup(usockfile);
#else
		usockfile = NULL;
		GDKwarning("MAPIlisten: Unix domain sockets are not supported\n");
#endif
	}
	@:builtin_operand(2,TYPE_int,Maxusers)@
	maxusers = *Maxusers;
	@:builtin_operand(3,TYPE_str,cmd)@
	cmd = GDKstrdup(cmd);
	@:builtin_operand(4,TYPE_bit,Accept_any);
	accept_any = *Accept_any;
	res->vtype = TYPE_void;
	if (lt->cnt == 6) {
		@:builtin_operand(5,TYPE_ptr,Get_client);
		get_client = (Client (*)(stream *, stream *))*Get_client;
	}

	port = (port ? port : MAPIPORT);
	maxusers = (maxusers ? maxusers : MAPIMAXUSERS);

	if (!GDKembedded) {
		char *m_clients = GDKgetenv("mapi_clients");
		int nr = (m_clients)?strtol(m_clients, NULL, 10):1;
		monetAdjustThreads(nr);
	}

	if (port <= 0 && usockfile == NULL) {
		GDKsyserror("MAPIlisten: no port or socket file specified\n");
		return GDK_FAIL;
	}

	if (port > 0) {
		sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
		if (sock < 0) {
			GDKsyserror("MAPIlisten:creation of stream socket failed\n");
			return GDK_FAIL;
		}
@-
Set server port and allow network connections from any workstation.
Bind the socket to the server port.
The port id should be obtained from the Homes file.
@c
		server.sin_family = AF_INET;
		if (accept_any)
			server.sin_addr.s_addr = htonl(INADDR_ANY);
		else
			server.sin_addr.s_addr = htonl(INADDR_LOOPBACK);
		server.sin_port = htons((unsigned short) ((port) & 0xFFFF));
		for (i = 0; i < 8; i++)
			server.sin_zero[i] = 0;

		setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, (char *) &on, sizeof on);

		length = (SOCKLEN) sizeof(server);
		if (bind(sock, (SOCKPTR) &server, length) < 0) {
			GDKsyserror("MAPIlisten:binding to stream socket (%d) failed\n", port);
			return GDK_FAIL;
		}
@-
Get the new information for the server socket and start listening.
@c
		if (getsockname(sock, (SOCKPTR) &server, &length) < 0) {
			GDKsyserror("MAPIlisten:getting socket name\n");
			return GDK_FAIL;
		}
		listen(sock, maxusers);
	}
#ifdef HAVE_SYS_UN_H
	if (usockfile) {
		usock = socket(AF_UNIX, SOCK_STREAM, 0);
		if (usock < 0) {
			GDKsyserror("MAPIlisten:creation of Unix socket failed\n");
			return GDK_FAIL;
		}
		userver.sun_family = AF_UNIX;
		strncpy(userver.sun_path, usockfile, sizeof(userver.sun_path));

		length = (SOCKLEN) sizeof(userver);
		if (bind(usock, (SOCKPTR) & userver, length) < 0) {
			GDKsyserror("MAPIlisten:binding to Unix socket (%s) failed\n", usockfile);
			return GDK_FAIL;
		}
		listen(usock, maxusers);
	}
#endif

	PARDEBUG {
		THRprintf(GDKerr, "MAPIlisten:Network started at %d\n", port);
	}
	do {
		int retval;
		struct timeval tv;
		fd_set fds;
		int msgsock;

		FD_ZERO(&fds);
		if (sock >= 0)
			FD_SET(sock, &fds);
#ifdef HAVE_SYS_UN_H
		if (usock >= 0)
			FD_SET(usock, &fds);
#endif
		/* Wait up to 0.5 seconds. */
		tv.tv_sec = 0;
		tv.tv_usec = 500;

		/* temporarily use msgsock to record the larger of sock and usock */
		msgsock = sock;
#ifdef HAVE_SYS_UN_H
		if (usock > sock)
			msgsock = usock;
#endif
		retval = select(msgsock + 1, &fds, NULL, NULL, &tv);
		if (retval == 0) {
			/* nothing interesting has happened */
			continue;
		}
		if (retval < 0) {
			if (MT_geterrno() != EINTR) {
				GDKsyserror("MAPIlisten:select failed\n");
				goto error;
			}
			continue;
		}
		if (sock >= 0 && FD_ISSET(sock, &fds)) {
			if ((msgsock = accept(sock, (SOCKPTR) 0, (SOCKLEN *) 0)) < 0) {
				if (MT_geterrno() != EINTR) {
					GDKsyserror("MAPIlisten:accept failed\n");
					goto error;
				}
				continue;
			}
#ifdef HAVE_SYS_UN_H
		} else if (usock >= 0 && FD_ISSET(usock, &fds)) {
			if ((msgsock = accept(usock, (SOCKPTR) 0, (SOCKLEN *) 0)) < 0) {
				if (MT_geterrno() != EINTR) {
					GDKsyserror("MAPIlisten:accept failed\n");
					goto error;
				}
				continue;
			}
#endif
		} else
			continue;
		{
			stream *fdin = socket_rastream(msgsock, "Mserver mapi read");
			stream *fdout = socket_wastream(msgsock, "Mserver mapi write");
			char *mp = GDKgetenv("monet_prompt");
			char *name = father->user;
			Client c = NULL;

			/* in embedded mode we allow just one client */
			if (GDKembedded && monet_forks > 0) {
				stream_close(fdin);
				stream_destroy(fdin);
				continue;
			}

			if (STREQ(cmd, "")) { 
				char userbuf[BLOCK];
				char *user;
				int blocked = 0;
				char *challenge, *s;
				int i = 0;

				name = user = userbuf;
				if (fdin == 0 || stream_errnr(fdin)) {
					GDKsyserror("MAPIlisten:fdin problems\n");
					continue;
				}
				/* write challenge string, the challenge is currently empty (disabled) */
				challenge = "::mserver_mil:4\n";
				/* temporarily misuse name */
				snprintf(name, BLOCK, "%2u%s", (unsigned int)strlen(challenge), challenge);
				stream_write(fdout, name, strlen(name), 1);
				
				/* get user name */
				stream_read(fdin, user, 1, 1);
				for (i = 0; !stream_errnr(fdin) && i < BLOCK && *user != '\n'; i++) {
					user++;
					stream_read(fdin, user, 1, 1);
				}
				*user = 0;
				if (stream_errnr(fdin)) {
					GDKsyserror("MAPIlisten: fdin problems\n");
					stream_close(fdin);
					stream_destroy(fdin);
					continue;
				}
				s = strrchr(name, ':');
				blocked = s && strncmp(s, ":blocked", 8) == 0;
				if (blocked) {
					/* printf("mapi:use blocked mode\n");fflush(stdout); */
					*s = 0;
					fdin = block_stream(stream_rstream(fdin));
					fdout = block_stream(socket_wstream(msgsock, "Mserver mapi write"));
				} else {
					fdout = socket_wastream(msgsock, "Mserver mapi write");
				}
				/* remove password (eventually we have to
				   check the password, for now ignore it) */
				s = strchr(name, ':');
				if (s != NULL)
					*s = 0;
				
				if (fdout == 0) {
					GDKsyserror("MAPIlisten:fdout problems\n");
					continue;
				}
			}
			if (get_client) {
				/* try to get a cached client session */
				c = (*get_client)(fdin, fdout);
			} 
			if (c == 0) {
				c = initClient(name, mp, FALSE);
				if (c == 0) {
					stream_printf(fdout, "MAPIlisten:Failed to init client for user %s\n", name);
					GDKfree(name);
				
					/* Make sure that the write- (from-) stream is closed first,
					 * as the related read- (in-) stream closes the shared
					 * socket; see also src/common/stream.mx:socket_close .
					 */
					stream_close(fdout);
					stream_destroy(fdout);
					stream_close(fdin);
					stream_destroy(fdin);
					continue;
				}
				c->mode = BLOCKMODE;
				c->listing = 0;
				c->login = time(0);
				c->fdin = fdin;
				c->fdout = fdout;
				CNTXTcopy(stk, c);
				TBL_initclient(c, father);
			
				if (STREQ(cmd, "")) { 
					(void) monetFork();
				} else {
					if (MAPIinitClient(c, cmd, fdin, fdout) < 0) {
						closeClient(c, 0);
						continue;
					}
				}
			}
			scheduleClient(c);
			PARDEBUG THRprintf(GDKerr, "MAPIlisten:client accepted %d\n", msgsock);
		}
	} while (monet_running);
#ifdef HAVE_SYS_UN_H
	if (usockfile)
		unlink(usockfile);
#endif
	return GDK_SUCCEED;
      error:
#ifdef HAVE_SYS_UN_H
	if (usockfile)
		unlink(usockfile);
#endif
	return GDK_FAIL;
}

#ifdef HAVE_OPENSSL
static char *
ssl_error(const char *name, int err, int ret)
{
	char *errstr, *s;
	char buf[120];
	unsigned long e;

	switch (err) {
	case SSL_ERROR_ZERO_RETURN:
		errstr = "TLS/SSL connection has been closed";
		break;
	case SSL_ERROR_WANT_READ:
		errstr = "The operation did not complete (read)";
		break;
	case SSL_ERROR_WANT_WRITE:
		errstr = "The operation did not complete (write)";
		break;
	case SSL_ERROR_WANT_X509_LOOKUP:
		errstr = "The operation did not complete (X509 lookup)";
		break;
	case SSL_ERROR_WANT_CONNECT:
		errstr = "The operation did not complete (connect)";
		break;
	case SSL_ERROR_SYSCALL:
		e = ERR_get_error();
		if (e == 0) {
			if (ret == 0) {
				errstr = "EOF occurred in violation of protocol";
			} else if (ret == -1) {
				/* the underlying BIO reported an I/O error */
				errstr = "I/O error";
			} else {	/* possible? */
				errstr = "Some I/O error occurred";
			}
		} else {
			errstr = ERR_error_string(e, buf);
		}
		break;
	case SSL_ERROR_SSL:
		e = ERR_get_error();
		if (e != 0)
			errstr = ERR_error_string(e, buf);
		else {		/* possible? */
			errstr = "A failure in the SSL library occurred";
		}
		break;
	default:
		errstr = "Invalid error code";
	}
	s = GDKmalloc(strlen(errstr) + strlen(name) + 4);
	sprintf(s, "%s: %s\n", name, errstr);	/* we allocated enough, so it fits */
	return s;
}

static MT_Lock *mutex_buf;

static void
locking_function(int mode, int n, const char *file, int line)
{
	(void) file;
	(void) line;
	if (mode & CRYPTO_LOCK)
		MT_set_lock(mutex_buf[n], "locking_function");
	else
		MT_unset_lock(mutex_buf[n], "locking_function");
}

static unsigned long
id_function(void)
{
	return (unsigned long) MT_getpid();
}
#endif /* HAVE_OPENSSL */

bat *
mapi_prelude(void)
{
#ifdef HAVE_OPENSSL
	int i, nlocks;

	nlocks = CRYPTO_num_locks();
	mutex_buf = GDKmalloc(nlocks * sizeof(*mutex_buf));
	if (mutex_buf == NULL) {
		GDKsyserror("mapi_prelude: failed to allocate %d mutexes\n", nlocks);
		return NULL;
	}
	for (i = 0; i < nlocks; i++)
		mutex_buf[i] = MT_create_lock();
	CRYPTO_set_locking_callback(locking_function);
	CRYPTO_set_id_callback(id_function);
#endif
	return NULL;
}

void
mapi_epilogue(void)
{
#ifdef HAVE_OPENSSL
	if (mutex_buf) {
		int i, nlocks;

		nlocks = CRYPTO_num_locks();
		CRYPTO_set_id_callback(NULL);
		CRYPTO_set_locking_callback(NULL);
		for (i = 0; i < nlocks; i++)
			MT_destroy_lock(mutex_buf[i]);
		GDKfree(mutex_buf);
		mutex_buf = NULL;
	}
#endif /* HAVE_OPENSSL */
}

int
MAPIlistenSSL(Cntxt stk, YYSTREE lt, ValPtr res)
{
#ifdef HAVE_OPENSSL
	struct sockaddr_in server;
	int sock = -1;
	SOCKLEN length = 0;
	int on = 1;
	int msgsock;
	int i = 0;

	int port, *Port;
	int maxusers, *Maxusers;
	char *keyfile;
	char *certfile;
	char *cmd;
	Client father;
	SSL_CTX *ctx = NULL;
	SSL *ssl = NULL;

	CNTXTclient(stk, &father);
	if (lt->cnt != 5) {
		return handle_argerror(res, lt->cnt, 5);
	}
	@:builtin_operand(0,TYPE_int,Port)@;
	port = *Port;
	@:builtin_operand(1,TYPE_int,Maxusers)@;
	maxusers = *Maxusers;
	@:builtin_operand(2,TYPE_str,keyfile)@;
	keyfile = GDKstrdup(keyfile);
	@:builtin_operand(3,TYPE_str,certfile)@;
	certfile = GDKstrdup(certfile);
	@:builtin_operand(4,TYPE_str,cmd)@;
	cmd = GDKstrdup(cmd);
	res->vtype = TYPE_void;

	if (!port)
		port = MAPISSLPORT;
	if (!maxusers)
		maxusers = MAPIMAXUSERS;

	if (!GDKembedded) {
		char *m_clients = GDKgetenv("mapi_clients");
		int nr = (m_clients)?strtol(m_clients, NULL, 10):1;
		monetAdjustThreads(nr);
	}

	ctx = SSL_CTX_new(SSLv23_method());
	if (ctx == NULL) {
		GDKsyserror("MAPIlistenSSL: creation of SSL context failed\n");
		goto fail;
	}
	if (SSL_CTX_set_cipher_list(ctx, "ALL:!LOW") == 0) {
		GDKsyserror("MAPIlistenSSL: SSL_CTX_set_cipher_list failed\n");
		goto fail;
	}
	if (keyfile && *keyfile && certfile && *certfile) {
		if (SSL_CTX_use_PrivateKey_file(ctx, keyfile, SSL_FILETYPE_PEM) < 1) {
			GDKsyserror("MAPIlistenSSL: SSL_CTX_use_PrivateKey_file %s failed\n", keyfile);
			goto fail;
		}
		if (SSL_CTX_use_certificate_chain_file(ctx, certfile) < 1) {
			GDKsyserror("MAPIlistenSSL: SSL_CTX_use_certificate_chain_file %s failed\n", certfile);
			goto fail;
		}
	}
	if (keyfile)
		GDKfree(keyfile);
	if (certfile)
		GDKfree(certfile);

	SSL_CTX_set_verify(ctx, SSL_VERIFY_NONE, NULL);

	sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
	if (sock < 0) {
		GDKsyserror("MAPIlistenSSL:creation of stream socket failed\n");
		goto fail;
	}
@-
Set server port and allow network connections from any workstation.
Bind the socket to the server port.
The port id should be obtained from the Homes file.
@c
	server.sin_family = AF_INET;
	server.sin_addr.s_addr = INADDR_ANY;
	server.sin_port = htons((unsigned short) ((port) & 0xFFFF));
	for (i = 0; i < 8; i++)
		server.sin_zero[i] = 0;

	setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, (char *) &on, sizeof on);

	length = (SOCKLEN) sizeof(server);
	if (bind(sock, (SOCKPTR) & server, length) < 0) {
		GDKsyserror("MAPIlistenSSL:binding to stream socket (%d) failed\n", port);
		goto fail;
	}
@-
Get the new information for the server socket and start listening.
@c
	if (getsockname(sock, (SOCKPTR) & server, &length) < 0) {
		GDKsyserror("MAPIlistenSSL:getting socket name\n");
		goto fail;
	}
	listen(sock, maxusers);

	PARDEBUG {
		THRprintf(GDKerr, "MAPIlistenSSL:Network started at %d\n", port);
	}
	do {
		int retval;
		struct timeval tv;
		fd_set fds;

		FD_ZERO(&fds);
		FD_SET(sock, &fds);
		/* Wait up to 0.5 seconds. */
		tv.tv_sec = 0;
		tv.tv_usec = 500;

		retval = select(sock + 1, &fds, &fds, &fds, &tv);
		if (retval == 0) {
			/* nothing interesting has happened */
			continue;
		}
		if (retval < 0) {
			GDKsyserror("MAPIlistenSSL:select failed\n");
			goto fail;
		}
		if ((msgsock = accept(sock, (SOCKPTR) 0, (SOCKLEN *) 0)) < 0) {
			if (MT_geterrno() != EINTR) {
				GDKsyserror("MAPIlistenSSL:accept failed\n");
				goto fail;
			}
			continue;
		}
		if ((ssl = SSL_new(ctx)) == 0) {
			GDKsyserror("MAPIlistenSSL: SSL_new failed\n");
			goto fail;
		}

		if (!SSL_set_fd(ssl, msgsock)) {
			GDKsyserror("MAPIlistenSSL: SSL_set_fd failed\n");
			goto fail;
		}

		for (;;) {
			int ret, err;
			char *errstr;

			ret = SSL_accept(ssl);
			err = SSL_get_error(ssl, ret);
			switch (err) {
			case SSL_ERROR_WANT_READ:
			case SSL_ERROR_WANT_WRITE:
				/* try again */
				continue;
			case SSL_ERROR_NONE:
				/* successful connect */
				break;
			case SSL_ERROR_WANT_CONNECT:
			case SSL_ERROR_WANT_ACCEPT:
			case SSL_ERROR_WANT_X509_LOOKUP:
			default:
				/* some error occurred */
				errstr = ssl_error("MAPIlistenSSL", err, ret);
				GDKsyserror(errstr);
				GDKfree(errstr);
				SSL_free(ssl);
				close(msgsock);
				goto end_loop;
			}
			break;
		}

		if (STREQ(cmd, "")) {
			int i = 0;
			char *name = (char *) GDKmalloc(BLOCK), *user = name, *s;
			char *mp;
			int blocked = 0;
			stream *fdin = ssl_rastream(ssl, "Mserver mapi read");
			stream *fdout = NULL;
			Client c;

			assert(name);
			memset(name, 0, BLOCK);
			if (fdin == 0 || stream_errnr(fdin)) {
				GDKsyserror("MAPIlistenSSL:fdin problems\n");
				if (fdin)
					stream_destroy(fdin);
				continue;
			}
			/* get user name */
			stream_read(fdin, user, 1, 1);
			for (i = 0; i < BLOCK && *user != '\n' && !stream_errnr(fdin); i++) {
				user++;
				stream_read(fdin, user, 1, 1);
			}
			if (stream_errnr(fdin)) {
				GDKsyserror("MAPIlistenSSL: fdin problems\n");
				stream_close(fdin);
				stream_destroy(fdin);
				continue;
			}
			*user = 0;
			/* printf("mapi:Client accepted %s\n", name);fflush(stdout); */
			s = strrchr(name, ':');
			blocked = s && strncmp(s, ":blocked", 8) == 0;
			if (blocked) {
				/* printf("mapi:use blocked mode\n");fflush(stdout); */
				*s = 0;
				fdin = block_stream(stream_rstream(fdin));
				fdout = block_stream(ssl_wstream(SSL_dup(ssl), "Mserver mapi write"));
			} else {
				fdout = ssl_wastream(SSL_dup(ssl), "Mserver mapi write");
			}

			if (fdout == 0) {
				GDKsyserror("MAPIlistenSSL:fdout problems\n");
				continue;
			}
			*user = 0;
			mp = GDKgetenv("monet_prompt");
			c = initClient(name, mp, FALSE);
			if (c == 0) {
				stream_printf(fdout, "MAPIlistenSSL:Failed to init client for user %s\n", name);
				GDKfree(name);

				/* Make sure that the write- (out-) stream is closed first,
				 * as the related read- (in-) stream closes the shared
				 * socket; see also src/common/stream.mx:ssl_close .
				 */
				stream_close(fdout);
				stream_destroy(fdout);
				stream_close(fdin);
				stream_destroy(fdin);
				continue;
			}
			GDKfree(name);
			c->login = time(0);
			c->listing = 0;
			c->fdin = fdin;
			c->fdout = fdout;
			c->mode = BLOCKMODE;
			CNTXTcopy(stk, c);
			TBL_initclient(c, father);
			(void) monetFork();
			scheduleClient(c);
			PARDEBUG THRprintf(GDKerr, "MAPIlistenSSL:client accepted %d\n", msgsock);
		} else {
			ValRecord res;
			char buf[BUFSIZ];
			stream *sin, *sout;

			sin = ssl_rastream(ssl, "mapi-r");
			sout = ssl_wastream(SSL_dup(ssl), "mapi-w");
			snprintf(buf, BUFSIZ, "%s(Stream(\"" PTRFMT "\"), Stream(\"" PTRFMT "\"));\n", cmd, PTRFMTCAST sin, PTRFMTCAST sout);
			THRprintf(GDKerr, "MAPIlistenSSL: %s", buf);
			res.vtype = TYPE_void;
			interpret_str(stk, buf, &res);
		}
	      end_loop:;
	} while (monet_running);
	SSL_CTX_free(ctx);
	close(sock);
	if (cmd)
		GDKfree(cmd);
	return GDK_SUCCEED;
      fail:;
	if (sock >= 0)
		close(sock);
	if (ctx)
		SSL_CTX_free(ctx);
	if (cmd)
		GDKfree(cmd);
	return GDK_FAIL;
#else
	(void) stk;
	(void) lt;
	(void) res;
	GDKerror("No SSL support\n");
	return GDK_FAIL;
#endif /* HAVE_OPENSSL */
}

int
stream_read_until(str *res, Stream *S, str stop)
{
	stream *s = *(stream **) S;
	int slen = strlen(stop);
	int len = 0;
	char buf[BUFSIZ + 1], *start = buf;

	while (stream_read(s, start, 1, 1) > 0) {
		if (start - buf >= slen - 1 && strncmp(start - slen + 1, stop, slen) == 0) {
/*
				start = start-slen+1;
*/
			start++;
			break;
		}
		start++;
	}

	if (stream_errnr(s))
		return GDK_FAIL;

	len = start - buf;
	if (len > 0) {
		*res = NEW_ARRAY(char, len + 1);

		buf[len] = '\0';
		memcpy(*res, buf, len + 1);
	} else {
		*res = GDKstrdup("");
	}
	return GDK_SUCCEED;
}

int
client(Cntxt stk, YYSTREE lt, ValPtr res)
{
	ssize_t i = 0;
	char buf[BUFSIZ + 1];
	char *user, *passwd, *challenge;
	int blocked = 0;

	stream **In, **Out;
	stream *in, *out;
	bstream *rs;

	Client client;

	CNTXTclient((Cntxt) (ptrdiff_t) stk, &client);
	/* get the streams from the argument list */
	if (lt->cnt != 2) {
		closeClient(client, 0);
		return handle_argerror(res, lt->cnt, 2);
	}
	@:builtin_operand(0,TYPE_Stream,In)@
	in = *In;
	@:builtin_operand(1,TYPE_Stream,Out)@
	out = *Out;
	if (in == 0) {
		GDKsyserror("client:stream-r problems\n");
		closeClient(client, 0);
		return GDK_FAIL;
	}
	if (out == 0) {
		GDKsyserror("client:stream-w problems\n");
		closeClient(client, 0);
		return GDK_FAIL;
	}

	/* send challenge string, currently empty (disabled) */
	challenge = "::mserver_mil:4\n";

	snprintf(buf, 100, "%2u%s", (unsigned int)strlen(challenge), challenge);
	stream_write(out, buf, strlen(buf), 1);

	/* get user name */
	user = buf;
	for (i = 0; i < BUFSIZ; i++, user++) {
		if (stream_read(in, user, 1, 1) < 0) {
			closeClient(client, 0);
			return GDK_FAIL;
		}
		if (*user== '\n')
			break;
	}
	*user = 0;
	user = buf;
	passwd = strrchr(user, ':');
	if (passwd && strncmp(passwd, ":blocked", 8) == 0) {
		blocked = 1;
		*passwd = 0;
	}
	passwd = strrchr(user, ':');
	if (passwd) {
		/* skip :'server string' only used for M5 */
		*passwd = 0;
	}

	passwd = strchr(user, ':');
	if (passwd) {
		*passwd = 0;
		passwd++;
		user = GDKstrdup(buf);
		passwd = GDKstrdup(passwd);
	} else {
		closeClient(client, 0);
		return GDK_FAIL;
	}

	if (blocked) {
		in = block_stream(stream_rstream(in));
		out = block_stream(stream_wstream(out));

		monetSetChannel(THRget(THRgettid()), in, out);
	}

	if (out == 0) {
		GDKsyserror("client:stream-w problems\n");
		GDKfree(user);
		GDKfree(passwd);
		closeClient(client, 0);
		return GDK_FAIL;
	}

	rs = bstream_create(in, isa_block_stream(in) ? (128 * BLOCK) : 0);
	/* TODO create a context here */
	GDKfree(user);
	GDKfree(passwd);

	/* read all */
	{ 
	int go = 1;

	rs->eof = 1;            /* force prompt on first iteration */
	while(go) {
		ValRecord v;

		/* skip whitespace */
		while (rs->pos < rs->len && (isspace((int) (rs->buf[rs->pos])) || rs->buf[rs->pos] == ';'))
		rs->pos++;

               	if (rs->pos >= rs->len) {
                	ssize_t rd;
                
                       	assert(rs->pos == rs->len);

                       	if (rs->eof || !blocked) {
				if ((!blocked && stream_write(out, PROMPT1, sizeof(PROMPT1) - 1, 1) != 1) || stream_flush(out)) {
                                	go = FALSE;
                                       	break;
                               	}
                               	rs->eof = 0;
                       	}
                       	if ((rd = bstream_next(rs)) <= 0) {
                        	if (rd == 0 && rs->eof) {
                               		/* we hadn't seen the EOF before, 
						so just try again
                                       		(this time with prompt) */
                                        continue;
                                }
                                go = FALSE;
                                break;
                        }
		}
		v.vtype = TYPE_void;

		(void) interpret_str(stk, rs->buf+rs->pos, &v);
		rs->pos = rs->len;
	}
	}

	/* destroy context */
	bstream_destroy(rs);
	closeClient(client, 0); 	
	return GDK_SUCCEED;
}


@}
@- daemon initialization
@mil
proc get_mapi_port() : int {
	if (monet_environment.exist("mapi_port")){
		return int(monet_environment.find("mapi_port"));
	}
	ERROR("mapi_port is not set\n");
}

proc mapi_server(int port, int nr) : void {
        var l := listen(port, nr);
	quit();
}

proc mapi_start(bit global) : void {
	fork(listen(
		get_mapi_port(),
		5,
		global
		)
	);
}

proc mapi_start() : void {
	mapi_start(false);
}

if (mod() = "main"){
	mapi_start();
}
