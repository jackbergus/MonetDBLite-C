@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2006 CWI.
@' All Rights Reserved.

@f stream
@a Niels Nes
@* An simple interface to streams
Processing files, streams, and sockets is quite different on Linux and Windows
platforms. To improve portability between both, we advise to replace the stdio
actions with the stream functionality provided here.

This interface can also be used to open 'non compressed, gzipped, bz2zipped'
data files and sockets. Using this interface one could easily switch between
the various underlying storage types.

@h
#ifndef _STREAM_H_
#define _STREAM_H_

/*
 * File: stream.h
 * Auteur: Niels J. Nes
 * Date: 09-01-2001
 *
 * Version 0.1: start
 *
 * This is the general interface to input/output. Each stream will
 * contains some stream info (for now only byteorder). This is
 * required for proper conversion on different byte order platforms.
 */

#include <monet_utils.h>

#include <unistd.h>
#include <ctype.h>
#include <assert.h>

#ifdef HAVE_MALLOC_H
#include <malloc.h>
#endif
#include <signal.h>
#include <limits.h>

#ifdef NATIVE_WIN32
#ifndef LIBSTREAM
#define stream_export extern __declspec(dllimport)
#else
#define stream_export extern __declspec(dllexport)
#endif
#else
#define stream_export extern
#endif

#define EOT 4

#define ST_ASCII  0
#define ST_BIN 1

#define ST_READ  0
#define ST_WRITE 1

#define short_int_SWAP(s) ((short)(((0x00ff&(s))<<8) | ((0xff00&(s))>>8)))

#define normal_int_SWAP(i) (((0x000000ff&(i))<<24) | ((0x0000ff00&(i))<<8) | \
	               ((0x00ff0000&(i))>>8)  | ((0xff000000&(i))>>24))

#define long_long_SWAP(l) \
		((((lng)normal_int_SWAP(l))<<32) |\
		 (0xffffffff&normal_int_SWAP(l>>32)))

typedef struct stream stream;

/* some os specific initialization */
stream_export int stream_init(void);

/* all stream_readX/stream_writeX 
   return 
	0 on error 
       !0 on success
 */
stream_export int stream_readBte(stream *s, signed char *val);
stream_export int stream_writeBte(stream *s, signed char val);
stream_export int stream_readSht(stream *s, short *val);
stream_export int stream_writeSht(stream *s, short val);
stream_export int stream_readInt(stream *s, int *val);
stream_export int stream_writeInt(stream *s, int val);
stream_export int stream_readLng(stream *s, lng *val);
stream_export int stream_writeLng(stream *s, lng val);

stream_export int stream_readBteArray(stream *s, signed char *val, size_t cnt);
stream_export int stream_writeBteArray(stream *s, const signed char *val, size_t cnt);
stream_export int stream_readShtArray(stream *s, short *val, size_t cnt);
stream_export int stream_writeShtArray(stream *s, const short *val, size_t cnt);
stream_export int stream_readIntArray(stream *s, int *val, size_t cnt);
stream_export int stream_writeIntArray(stream *s, const int *val, size_t cnt);
stream_export int stream_readLngArray(stream *s, lng *val, size_t cnt);
stream_export int stream_writeLngArray(stream *s, const lng *val, size_t cnt);
stream_export int stream_printf(stream *s, const char *format, ...);
stream_export ssize_t stream_read(stream *s, void *buf, size_t elmsize, size_t cnt);
stream_export ssize_t stream_readline(stream *s, void *buf, size_t maxcnt);
stream_export ssize_t stream_write(stream *s, const void *buf, size_t elmsize, size_t cnt);
stream_export void stream_close(stream *s);
stream_export void stream_destroy(stream *s);
stream_export char *stream_error(stream *s);
stream_export int stream_flush(stream *s);
stream_export int stream_fsync(stream *s);
stream_export char *stream_name(stream *s);
stream_export int stream_errnr(stream *s);
stream_export int stream_type(stream *s);
stream_export int stream_byteorder(stream *s);
stream_export stream *stream_rstream(stream *s);
stream_export stream *stream_wstream(stream *s);

stream_export stream *open_rstream(const char *filename);
stream_export stream *open_wstream(const char *filename);

/* append to stream */
stream_export stream *append_wstream(const char *filename);

/* open in ascii stream in read mode */
stream_export stream *open_rastream(const char *filename);

/* open in ascii stream in write mode*/
stream_export stream *open_wastream(const char *filename);

/* append to ascii stream */
stream_export stream *append_wastream(const char *filename);

#ifdef HAVE_LIBZ
stream_export stream *open_gzrstream(const char *filename);
stream_export stream *open_gzwstream(const char *filename);
stream_export stream *open_gzrastream(const char *filename);
stream_export stream *open_gzwastream(const char *filename);
#endif

#ifdef HAVE_LIBBZ2
stream_export stream *open_bzrstream(const char *filename);
stream_export stream *open_bzwstream(const char *filename);
stream_export stream *open_bzrastream(const char *filename);
stream_export stream *open_bzwastream(const char *filename);
#endif

stream_export void close_stream(stream *s);

#ifdef HAVE_CURL
stream_export stream * open_urlstream(const char *url);
#endif

stream_export stream *socket_rstream(int socket, const char *name);
stream_export stream *socket_wstream(int socket, const char *name);
stream_export stream *socket_rastream(int socket, const char *name);
stream_export stream *socket_wastream(int socket, const char *name);

#ifdef HAVE_OPENSSL
#include <openssl/ssl.h>
#include <openssl/err.h>

stream_export stream *ssl_rstream(SSL * ssl, const char *name);
stream_export stream *ssl_wstream(SSL * ssl, const char *name);
stream_export stream *ssl_rastream(SSL * ssl, const char *name);
stream_export stream *ssl_wastream(SSL * ssl, const char *name);
#endif

stream_export stream *file_rstream(FILE *fp, const char *name);
stream_export stream *file_wstream(FILE *fp, const char *name);
stream_export stream *file_rastream(FILE *fp, const char *name);
stream_export stream *file_wastream(FILE *fp, const char *name);

stream_export int rendezvous_streams(stream **in, stream **out, const char *name);

typedef struct buffer {
	char *buf;
	size_t pos;
	size_t len;
} buffer;

stream_export void buffer_init(buffer *b, char *buf, size_t size);
stream_export buffer *buffer_create(size_t size);
stream_export char *buffer_get_buf(buffer *b);
stream_export void buffer_destroy(buffer *b);

stream_export stream *buffer_rastream(buffer *b, const char *name);
stream_export stream *buffer_wastream(buffer *b, const char *name);
stream_export buffer *stream_get_buffer(stream *s);

/* note, the size is fixed to 8K, you cannot simply change it to any
   value */
#define BLOCK (8 * 1024 - 2)
/*
   Block stream is a stream which sends data in blocks of a known
   size (BLOCK size or dynamically changed using CHANGE_BLOCK_SIZE msg).

   A block is written once more then BLOCK size data has been written using
   the write commands or when the flush command is sent.

   All full blocks together with a single not full block form a major
   block. Major blocks can be used to synchronize the communication.
   Example server sends some reply, ie a major block consisting of
   various minor blocks. The header of the major block can contain
   special info which the client can interpret.

   Each read attempt tries to return the number of bytes. Once a lower number
   of bytes can be read the end of the major block is found. The next
   read will then start with a new major block.
 */
stream_export stream *block_stream(stream *s);
stream_export ssize_t bs_read_next(stream *s, void *buf, size_t nbytes, int *last);
stream_export int isa_block_stream(stream *s);

@+ buffered streams

The bstream (or buffered_stream) can be used for efficient reading
of a stream. Reading can be done in large chunks and
access can be done in smaller bits, by directly accessing the underlying
buffer.

Beware that a flush on a buffered stream emits an empty block to
synchronize with the other side, telling it has reached the end
of the sequence and can close its descriptors.
@h
typedef struct bstream {
	stream *s;
	char *buf;
	size_t size;		/* size of buf */
	size_t pos;		/* the data cursor (ie read uptil pos) */
	size_t len;		/* len of the data (could < size but usually == size) */
	int eof;
	int mode;		/* 0 line mode else size for block mode */
} bstream;

stream_export bstream *bstream_create(stream *rs, size_t chunk_size);
stream_export void bstream_destroy(bstream *s);
stream_export ssize_t bstream_read(bstream *s, size_t size);
stream_export ssize_t bstream_next(bstream *s);

@+ bstream functions
The bstream_create gets a read stream (rs) as input and the initial chunk size
and creates a buffered stream from this. A spare byte is kept at the end
of the buffer.
The bstream_read will at least read the next 'size' bytes. If the not read data
(aka pos < len) together with the new data will not fit in the current buffer
it is resized. The spare byte is kept.

@h

typedef enum stream_errors {
	NO__ERROR = 0,
	OPEN_ERROR,
	READ_ERROR,
	WRITE_ERROR
} stream_errors;
#endif /*_STREAM_H_*/
@c
#include "stream.h"
#include <string.h>

#ifdef HAVE_SYS_SOCKET_H
#include <sys/socket.h>
#endif

#ifdef HAVE_NETDB_H
# include <sys/types.h>
# include <netinet/in_systm.h>
# include <netinet/in.h>
# include <netinet/ip.h>
# include <netinet/tcp.h>
# include <netdb.h>
#endif
#ifdef NATIVE_WIN32
#include <winsock.h>
#include <io.h>
#endif
#ifdef HAVE_FCNTL_H
#include <fcntl.h>
#endif
#ifdef HAVE_LIBZ
#include <zlib.h>
#endif
#ifdef HAVE_LIBBZ2
#include <bzlib.h>
#endif

#ifndef SHUT_RD
#define SHUT_RD		0
#define SHUT_WR		1
#define SHUT_RDWR	2
#endif

#ifndef EWOULDBLOCK
#define EWOULDBLOCK EAGAIN
#endif

#ifndef EINTR
#define EINTR 	EAGAIN
#endif

struct stream {
	short byteorder;
	short access;		/* read/write */
	short type;		/* ascii/binary */
	char *name;
	union {
		void *p;
		int i;
	} stream_data;
	int errnr;
	ssize_t (*read) (stream *s, void *buf, size_t elmsize, size_t cnt);
	ssize_t (*readline) (stream *s, void *buf, size_t maxcnt);
	ssize_t (*write) (stream *s, const void *buf, size_t elmsize, size_t cnt);
	void (*close) (stream *s);
	char *(*error) (stream *s);
	void (*destroy) (stream *s);
	int (*flush) (stream *s);
	int (*fsync) (stream *s);
};

#if !HAVE_DECL_STRDUP
#ifdef HAVE_STRDUP
extern char *strdup(const char *);
#else
#define strdup(s)	strcpy(malloc(strlen(s)+1),(s))
#endif
#endif
#ifdef NATIVE_WIN32
#define strdup _strdup
#endif

int
stream_init(void)
{
	static int inited = 0;

	if (inited)
		return 0;

#ifdef NATIVE_WIN32
	{
		int sockopt = SO_SYNCHRONOUS_NONALERT;
		WSADATA w;

		if (WSAStartup(0x0101, &w) != 0)
			return -1;

		if (setsockopt(INVALID_SOCKET, SOL_SOCKET, SO_OPENTYPE, (void *) &sockopt, sizeof(sockopt)) < 0) {
			WSACleanup();
			return -1;
		}
	}
#endif
#ifdef HAVE_OPENSSL
	SSL_load_error_strings();
	(void) SSL_library_init();
#endif
	inited = 1;
	return 0;
}

/* #define STREAM_DEBUG 1  */
/* #define BSTREAM_DEBUG 1 */

#ifdef STREAM_DEBUG
/* code adapted from gdk.mx */
/* define printf formats for printing size_t and ssize_t variables */
#if defined(__STDC_VERSION__) && __STDC_VERSION__ >= 199901 && !defined(__svr4__) && !defined(WIN32) && !defined(__sgi)
#define SZFMT "%zu"
#elif SIZEOF_SIZE_T == SIZEOF_INT
#define SZFMT "%u"
#elif SIZEOF_SIZE_T == SIZEOF_LONG
#define SZFMT "%lu"
#elif SIZEOF_SIZE_T == SIZEOF_LONG_LONG
#define SZFMT "%llu"
#elif SIZEOF_SIZE_T == SIZEOF___INT64
#define SZFMT "%I64u"
#else
#error no definition for SZFMT
#endif
/* define printf format for printing pointer values */
#if defined(__STDC_VERSION__) && __STDC_VERSION__ >= 199901
#define PTRFMT		"%p"
#define PTRFMTCAST		/* no cast needed */
#elif SIZEOF_VOID_P == SIZEOF_INT
#define PTRFMT		"%x"
#define PTRFMTCAST	(unsigned int)
#elif SIZEOF_VOID_P == SIZEOF_LONG
#define PTRFMT		"%lx"
#define PTRFMTCAST	(unsigned long)
#elif SIZEOF_VOID_P == SIZEOF_LONG_LONG
#define PTRFMT		"%llx"
#define PTRFMTCAST	(unsigned long long)
#elif SIZEOF_VOID_P == SIZEOF___INT64
#define PTRFMT		"%I64x"
#define PTRFMTCAST	(unsigned __int64)
#else
#error no definition for PTRFMT
#endif
#endif /* STREAM_DEBUG */

/* Read at most cnt elements of size elmsize from the stream.  Returns
   the number of elements actually read. */
ssize_t
stream_read(stream *s, void *buf, size_t elmsize, size_t cnt)
{
#ifdef STREAM_DEBUG
	printf("read %s " SZFMT " " SZFMT "\n", s->name ? s->name : "<unnamed>", elmsize, cnt);
#endif
	assert(s->access == ST_READ);
	if (s->errnr) return s->errnr;
	return (*s->read) (s, buf, elmsize, cnt);
}

/* Read one line (seperated by \n) of atmost maxcnt characters from the stream. 
   Returns the number of characters actually read. */
ssize_t
stream_readline(stream *s, void *buf, size_t maxcnt)
{
#ifdef STREAM_DEBUG
	printf("readline %s " SZFMT "\n", s->name ? s->name : "<unnamed>", cnt);
#endif
	assert(s->access == ST_READ);
	if (s->errnr) return s->errnr;
	if (!s->readline) {
		size_t len = 0;
		char *b = buf, *start = buf;
		while ((*s->read)(s, start, 1, 1) > 0 && len < maxcnt) {
			if (*start == '\n')
				break;
			start++;
		}
		if (s->errnr) return s->errnr;
		return (start - b);
	} else
		return (*s->readline) (s, buf, maxcnt);
}

/* Write cnt elements of size elmsize to the stream.  Returns the
   number of elements actually written.  If elmsize or cnt equals zero,
   returns cnt. */
ssize_t
stream_write(stream *s, const void *buf, size_t elmsize, size_t cnt)
{
#ifdef STREAM_DEBUG
	printf("write %s " SZFMT " " SZFMT "\n", s->name ? s->name : "<unnamed>", elmsize, cnt);
#endif
	assert(s->access == ST_WRITE);
	if (s->errnr) return s->errnr;
	return (*s->write) (s, buf, elmsize, cnt);
}

void
stream_close(stream *s)
{
#ifdef STREAM_DEBUG
	printf("close %s\n", s->name ? s->name : "<unnamed>");
#endif
	if (s)
		(*s->close) (s);
}

void
stream_destroy(stream *s)
{
#ifdef STREAM_DEBUG
	printf("destroy %s\n", s->name ? s->name : "<unnamed>");
#endif
	if (s)
		(*s->destroy) (s);
}

char *
stream_error(stream *s)
{
	if (s == 0)
		return "Connection terminated";
	return (*s->error) (s);
}

int
stream_flush(stream *s)
{
#ifdef STREAM_DEBUG
	printf("flush %s\n", s->name ? s->name : "<unnamed>");
#endif
	if (!s) return -1;
	assert(s->access == ST_WRITE);
	if (s->errnr) return s->errnr;
	if (s->flush)
		return (*s->flush) (s);
	return 0;
}

int
stream_fsync(stream *s)
{
#ifdef STREAM_DEBUG
	printf("fsync %s\n", s->name ? s->name : "<unnamed>");
#endif
	if (!s) return -1;
	assert(s->access == ST_WRITE);
	if (s->errnr) return s->errnr;
	if (s->fsync)
		return (*s->fsync) (s);
	return 0;
}

char *
stream_name(stream *s)
{
	if (s == 0)
		return "connection terminated";
	return s->name;
}

int
stream_errnr(stream *s)
{
	if (s == 0)
		return READ_ERROR;
	return s->errnr;
}

int
stream_type(stream *s)
{
	if (s == 0)
		return 0;
	return s->type;
}

int
stream_byteorder(stream *s)
{
	if (s == 0)
		return 0;
	return s->byteorder;
}

void
close_stream(stream *s)
{
	s->close(s);
	s->destroy(s);
}

stream *
stream_rstream(stream *s)
{
#ifdef STREAM_DEBUG
	printf("stream_rstream %s\n", s->name ? s->name : "<unnamed>");
#endif
	assert(s->access == ST_READ);
	s->type = ST_BIN;
	if (s->errnr == NO__ERROR)
		s->read(s, (void *) &s->byteorder, sizeof(s->byteorder), 1);
	return s;
}

stream *
stream_wstream(stream *s)
{
#ifdef STREAM_DEBUG
	printf("stream_wstream %s\n", s->name ? s->name : "<unnamed>");
#endif
	assert(s->access == ST_WRITE);
	s->type = ST_BIN;
	if (s->errnr == NO__ERROR)
		s->write(s, (void *) &s->byteorder, sizeof(s->byteorder), 1);
	return s;
}

#define EXT_LEN 4
static const char *
get_extention(const char *file)
{
	char *ext_start;

	return (ext_start = strrchr(file, '.')) != NULL ? ext_start + 1 : "";
}

static void
destroy(stream *s)
{
	free(s->name);
	free(s);
}

static char *
error(stream *s)
{
	char buf[BUFSIZ];

	switch (s->errnr) {
	case OPEN_ERROR:
		snprintf(buf, BUFSIZ, "error could not open file %s\n", s->name);
		return strdup(buf);
	case READ_ERROR:
		snprintf(buf, BUFSIZ, "error reading file %s\n", s->name);
		return strdup(buf);
	case WRITE_ERROR:
		snprintf(buf, BUFSIZ, "error writing file %s\n", s->name);
		return strdup(buf);
	}
	return strdup("Unknown error");
}

static stream *
create_stream(const char *name)
{
	stream *s;

	if ((s = (stream *) malloc(sizeof(*s))) == NULL)
		return NULL;
	s->byteorder = 1234;
	s->access = ST_READ;
	s->type = ST_ASCII;
	s->name = strdup(name);
	s->stream_data.p = NULL;
	s->errnr = NO__ERROR;
	s->stream_data.p = NULL;
	s->read = NULL;
	s->readline = NULL;
	s->write = NULL;
	s->close = NULL;
	s->error = error;
	s->destroy = destroy;
	s->flush = NULL;
	s->fsync = NULL;
#ifdef STREAM_DEBUG
	printf("create_stream %s -> " PTRFMT "\n", name ? name : "<unnamed>", PTRFMTCAST s);
#endif
	return s;
}

static ssize_t
file_read(stream *s, void *buf, size_t elmsize, size_t cnt)
{
	FILE *fp = (FILE *) s->stream_data.p;
	size_t rc = 0;

	if (!feof(fp)) {
		rc = fread(buf, elmsize, cnt, fp);
		if (ferror(fp))
			s->errnr = READ_ERROR;
	}
	return rc;
}

static ssize_t
file_write(stream *s, const void *buf, size_t elmsize, size_t cnt)
{
	if (elmsize && cnt) {
		size_t rc = fwrite(buf, elmsize, cnt, (FILE *) s->stream_data.p);

		if (rc < cnt)
			s->errnr = WRITE_ERROR;
		return (ssize_t) rc;
	}
	return cnt;
}

static void
file_close(stream *s)
{
	FILE *fp = (FILE *) s->stream_data.p;

	if (!fp)
		return;
	if (fp != stdin && fp != stdout && fp != stderr)
		fclose(fp);
	else if (s->access == ST_WRITE)
		fflush(fp);
	s->stream_data.p = NULL;
}

static int
file_flush(stream *s)
{
	FILE *fp = (FILE*)s->stream_data.p;

	if (s->access == ST_WRITE && fflush(fp) < 0){
		s->errnr = WRITE_ERROR;
		return 1;
	}
	return 0;
}

static int
file_fsync(stream *s)
{

	FILE *fp = (FILE*)s->stream_data.p;

	if (s->access == ST_WRITE &&
#ifdef NATIVE_WIN32
	    _commit(fileno(fp)) < 0
#else
	    fsync(fileno(fp)) < 0
#endif
		){
		s->errnr = WRITE_ERROR;
		return 1;
	}
	return 0;
}

static stream *
open_stream(const char *filename, const char *flags)
{
	stream *s;
	FILE *fp;

	if ((s = create_stream(filename)) == NULL)
		return NULL;
	if ((fp = fopen(filename, flags)) == NULL)
		s->errnr = OPEN_ERROR;
	s->read = file_read;
	s->readline = NULL;
	s->write = file_write;
	s->close = file_close;
	s->flush = file_flush;
	s->fsync = file_fsync;
	s->stream_data.p = (void *) fp;
	return s;
}

#ifdef HAVE_LIBZ
static ssize_t
stream_gzread(stream *s, void *buf, size_t elmsize, size_t cnt)
{
	gzFile *fp = (gzFile *) s->stream_data.p;
	int size = (int) (elmsize * cnt);

	if (!gzeof(fp)) {
		size = gzread(fp, buf, size);
		if (size)
			return size / elmsize;
	}
	return 0;
}

static ssize_t
stream_gzwrite(stream *s, const void *buf, size_t elmsize, size_t cnt)
{
	int size = (int) (elmsize * cnt);

	if (size) {
		size = gzwrite((gzFile *) s->stream_data.p, (void *) buf, size);
		return size / elmsize;
	}
	return cnt;
}

static void
stream_gzclose(stream *s)
{
	if (s->stream_data.p)
		gzclose((gzFile *) s->stream_data.p);
	s->stream_data.p = NULL;
}

static int
stream_gzflush(stream *s)
{
	if (s->access == ST_WRITE)
		gzflush((gzFile *) s->stream_data.p, Z_SYNC_FLUSH);
	return 0;
}

static stream *
open_gzstream(const char *filename, const char *flags)
{
	stream *s;
	gzFile *fp;

	if ((s = create_stream(filename)) == NULL)
		return NULL;
	if ((fp = gzopen(filename, flags)) == NULL)
		s->errnr = OPEN_ERROR;
	s->read = stream_gzread;
	s->write = stream_gzwrite;
	s->close = stream_gzclose;
	s->flush = stream_gzflush;
	s->stream_data.p = (void *) fp;
	return s;
}

stream *
open_gzrstream(const char *filename)
{
	stream *s;

	if ((s = open_gzstream(filename, "rb")) == NULL)
		return NULL;
	s->type = ST_BIN;
	if (s->errnr == NO__ERROR)
		gzread((gzFile *) s->stream_data.p, (void *) &s->byteorder, sizeof(s->byteorder));
	return s;
}

static stream *
open_gzwstream_(const char *filename, const char *mode)
{
	stream *s;

	if ((s = open_gzstream(filename, mode)) == NULL)
		return NULL;
	s->access = ST_WRITE;
	s->type = ST_BIN;
	if (s->errnr == NO__ERROR)
		gzwrite((gzFile *) s->stream_data.p, (void *) &s->byteorder, sizeof(s->byteorder));
	return s;
}

stream *
open_gzwstream(const char *filename)
{
	return open_gzwstream_(filename, "wb");
}

stream *
open_gzrastream(const char *filename)
{
	stream *s;

	if ((s = open_gzstream(filename, "rb")) == NULL)
		return NULL;
	s->type = ST_ASCII;
	return s;
}

static stream *
open_gzwastream_(const char *filename, const char *mode)
{
	stream *s;

	if ((s = open_gzstream(filename, mode)) == NULL)
		return NULL;
	s->access = ST_WRITE;
	s->type = ST_ASCII;
	return s;
}

stream *
open_gzwastream(const char *filename)
{
	return open_gzwastream_(filename, "wb");
}
#endif

#ifdef HAVE_LIBBZ2
static ssize_t
stream_bzread(stream *s, void *buf, size_t elmsize, size_t cnt)
{
	int size = (int) (elmsize * cnt);

	size = BZ2_bzread((BZFILE *) s->stream_data.p, buf, size);
	if (size)
		return size / elmsize;
	return 0;
}

static ssize_t
stream_bzwrite(stream *s, const void *buf, size_t elmsize, size_t cnt)
{
	int size = (int) (elmsize * cnt);

	if (size) {
		size = BZ2_bzwrite((BZFILE *) s->stream_data.p, (void *) buf, size);
		return size / elmsize;
	}
	return cnt;
}

static void
stream_bzclose(stream *s)
{
	if (s->stream_data.p)
		BZ2_bzclose((BZFILE *) s->stream_data.p);
	s->stream_data.p = NULL;
}

static int
stream_bzflush(stream *s)
{
	if (s->access == ST_WRITE)
		BZ2_bzflush((BZFILE *) s->stream_data.p);
	return 0;
}

static stream *
open_bzstream(const char *filename, const char *flags)
{
	stream *s;
	BZFILE *fp;

	if ((s = create_stream(filename)) == NULL)
		return NULL;
	if ((fp = BZ2_bzopen(filename, flags)) == NULL)
		s->errnr = OPEN_ERROR;
	s->read = stream_bzread;
	s->write = stream_bzwrite;
	s->close = stream_bzclose;
	s->flush = stream_bzflush;
	s->stream_data.p = (void *) fp;
	return s;
}

stream *
open_bzrstream(const char *filename)
{
	stream *s;

	if ((s = open_bzstream(filename, "rb")) == NULL)
		return NULL;
	s->type = ST_BIN;
	if (s->errnr == NO__ERROR)
		BZ2_bzread((BZFILE *) s->stream_data.p, (void *) &s->byteorder, sizeof(s->byteorder));
	return s;
}

static stream *
open_bzwstream_(const char *filename, const char *mode)
{
	stream *s;

	if ((s = open_bzstream(filename, mode)) == NULL)
		return NULL;
	s->access = ST_WRITE;
	s->type = ST_BIN;
	if (s->errnr == NO__ERROR)
		BZ2_bzwrite((BZFILE *) s->stream_data.p, (void *) &s->byteorder, sizeof(s->byteorder));
	return s;
}

stream *
open_bzwstream(const char *filename)
{
	return open_bzwstream_(filename, "wb");
}

stream *
open_bzrastream(const char *filename)
{
	stream *s;

	if ((s = open_bzstream(filename, "rb")) == NULL)
		return NULL;
	s->type = ST_ASCII;
	return s;
}

static stream *
open_bzwastream_(const char *filename, const char *mode)
{
	stream *s;

	if ((s = open_bzstream(filename, mode)) == NULL)
		return NULL;
	s->access = ST_WRITE;
	s->type = ST_ASCII;
	return s;
}

stream *
open_bzwastream(const char *filename)
{
	return open_bzwastream_(filename, "wb");
}
#endif

stream *
open_rstream(const char *filename)
{
	stream *s;
	const char *ext;

#ifdef STREAM_DEBUG
	printf("open_rstream %s\n", filename);
#endif
	ext = get_extention(filename);

	if (strcmp(ext, "gz") == 0) {
#ifdef HAVE_LIBZ
		return open_gzrstream(filename);
#else
		if ((s = create_stream(filename)) != NULL)
			s->errnr = OPEN_ERROR;
		return s;
#endif
	}
	if (strcmp(ext, "bz2") == 0) {
#ifdef HAVE_LIBBZ2
		return open_bzrstream(filename);
#else
		if ((s = create_stream(filename)) != NULL)
			s->errnr = OPEN_ERROR;
		return s;
#endif
	}
	if ((s = open_stream(filename, "rb")) == NULL)
		return NULL;
	s->type = ST_BIN;
	if (s->errnr == NO__ERROR) {
		fread((void *) &s->byteorder, sizeof(s->byteorder), 1, (FILE *) s->stream_data.p);
		if (ferror((FILE *) s->stream_data.p))
			s->errnr = OPEN_ERROR;
	}
	return s;
}

static stream *
open_wstream_(const char *filename, char *mode)
{
	stream *s;
	const char *ext;

#ifdef STREAM_DEBUG
	printf("open_wstream %s\n", filename);
#endif
	ext = get_extention(filename);

	if (strcmp(ext, "gz") == 0) {
#ifdef HAVE_LIBZ
		return open_gzwstream_(filename, mode);
#else
		if ((s = create_stream(filename)) != NULL)
			s->errnr = OPEN_ERROR;
		return s;
#endif
	}
	if (strcmp(ext, "bz2") == 0) {
#ifdef HAVE_LIBBZ2
		return open_bzwstream_(filename, mode);
#else
		if ((s = create_stream(filename)) != NULL)
			s->errnr = OPEN_ERROR;
		return s;
#endif
	}
	if ((s = open_stream(filename, mode)) == NULL)
		return NULL;
	s->access = ST_WRITE;
	s->type = ST_BIN;
	if (s->errnr == NO__ERROR)
		fwrite((void *) &s->byteorder, sizeof(s->byteorder), 1, (FILE *) s->stream_data.p);
	return s;
}

stream *
open_wstream(const char *filename)
{
	return open_wstream_(filename, "wb");
}

stream *
append_wstream(const char *filename)
{
	return open_wstream_(filename, "ab");
}

stream *
open_rastream(const char *filename)
{
	stream *s;
	const char *ext;

#ifdef STREAM_DEBUG
	printf("open_rastream %s\n", filename);
#endif
	ext = get_extention(filename);

	if (strcmp(ext, "gz") == 0) {
#ifdef HAVE_LIBZ
		return open_gzrastream(filename);
#else
		if ((s = create_stream(filename)) != NULL)
			s->errnr = OPEN_ERROR;
		return s;
#endif
	}
	if (strcmp(ext, "bz2") == 0) {
#ifdef HAVE_LIBBZ2
		return open_bzrastream(filename);
#else
		if ((s = create_stream(filename)) != NULL)
			s->errnr = OPEN_ERROR;
		return s;
#endif
	}
	if ((s = open_stream(filename, "r")) == NULL)
		return NULL;
	s->type = ST_ASCII;
	return s;
}

static stream *
open_wastream_(const char *filename, char *mode)
{
	stream *s;
	const char *ext;

#ifdef STREAM_DEBUG
	printf("open_wastream %s\n", filename);
#endif
	ext = get_extention(filename);

	if (strcmp(ext, "gz") == 0) {
#ifdef HAVE_LIBZ
		return open_gzwastream_(filename, mode);
#else
		if ((s = create_stream(filename)) != NULL)
			s->errnr = OPEN_ERROR;
		return s;
#endif
	}
	if (strcmp(ext, "bz2") == 0) {
#ifdef HAVE_LIBBZ2
		return open_bzwastream_(filename, mode);
#else
		if ((s = create_stream(filename)) != NULL)
			s->errnr = OPEN_ERROR;
		return s;
#endif
	}
	if ((s = open_stream(filename, mode)) == NULL)
		return NULL;
	s->access = ST_WRITE;
	s->type = ST_ASCII;
	return s;
}

stream *
open_wastream(const char *filename)
{
	return open_wastream_(filename, "w");
}

stream *
append_wastream(const char *filename)
{
	return open_wastream_(filename, "a");
}

#ifdef HAVE_CURL
#include <curl/curl.h>

#ifdef USE_CURL_MULTI
static CURLM *multi_handle;
#endif

struct curl_data {
	CURL *handle;
	char *buffer;		/* buffer to store incoming data */
	size_t maxsize;		/* size of allocated buffer */
	size_t usesize;		/* end of used data */
	size_t offset;		/* start of unread data */
	int running;		/* whether still transferring */
#ifdef USE_CURL_MULTI
	CURLMcode result;	/* result of transfer (if !running) */
	struct curl_data *next;	/* linked list (curl_handles) */
#endif
};
#ifdef USE_CURL_MULTI
static struct curl_data *curl_handles;
#endif

/* this function is called by libcurl when there is data for us */
static size_t
write_callback(char *buffer, size_t size, size_t nitems, void *userp)
{
	stream *s = (stream *) userp;
	struct curl_data *c = (struct curl_data *) s->stream_data.p;

	size *= nitems;
	/* allocate a buffer if we don't have one yet */
	if (c->buffer == NULL && size != 0) {
		/* BLOCK had better be a power of 2! */
		c->maxsize = (size + BLOCK - 1) & ~(BLOCK - 1);
		if ((c->buffer = malloc(c->maxsize)) == NULL)
			return 0;
		c->usesize = 0;
		c->offset = 0;
	}
#ifndef USE_CURL_MULTI
	/* move data if we don't have enough space */
	if (c->maxsize - c->usesize < size && c->offset > 0) {
		memmove(c->buffer, c->buffer + c->offset, c->usesize - c->offset);
		c->usesize -= c->offset;
		c->offset = 0;
	}
#endif
	/* allocate more buffer space if we still don't have enough space */
	if (c->maxsize - c->usesize < size) {
		c->maxsize = (c->usesize + size + BLOCK - 1) & ~(BLOCK - 1);
		c->buffer = realloc(c->buffer, c->usesize + size);
	}
	/* finally, store the data we received */
	memcpy(c->buffer + c->usesize, buffer, size);
	c->usesize += size;
	return size;
}

static void
curl_destroy(stream *s)
{
	struct curl_data *c;
#ifdef USE_CURL_MULTI
	struct curl_data **cp;
#endif

	if ((c = (struct curl_data *) s->stream_data.p) != NULL) {
		s->stream_data.p = NULL;
#ifdef USE_CURL_MULTI
		/* lock access to curl_handles */
		cp = &curl_handles;
		while (*cp && *cp != c)
			cp = &(*cp)->next;
		if (*cp)
			*cp = c->next;
		/* unlock access to curl_handles */
#endif
		if (c->handle) {
#ifdef USE_CURL_MULTI
			curl_multi_remove_handle(mult_handle, c->handle);
#endif
			curl_easy_cleanup(c->handle);
		}
		if (c->buffer)
			free(c->buffer);
		free(c);
	}
	destroy(s);
}

static ssize_t
curl_read(stream *s, void *buf, size_t elmsize, size_t cnt)
{
	struct curl_data *c = (struct curl_data *) s->stream_data.p;
	size_t size;

	if (c->usesize - c->offset >= elmsize || !c->running) {
		/* there is at least one element's worth of data
		   available, or we have reached the end: return as
		   much as we have, but no more than requested */
		if (cnt * elmsize > c->usesize - c->offset)
			cnt = (c->usesize - c->offset) / elmsize;
		size = cnt * elmsize;
		memcpy(buf, c->buffer + c->offset, size);
		c->offset += size;
		if (c->offset == c->usesize)
			c->usesize = c->offset = 0;
		return (ssize_t) cnt;
	}
	/* not enough data, we must wait until we get some */
#ifndef USE_CURL_MULTI
	return 0;
#endif
}

static ssize_t
curl_write(stream *s, const void *buf, size_t elmsize, size_t cnt)
{
	(void) s;
	(void) buf;
	(void) elmsize;
	(void) cnt;
	assert(0);
	return -1;
}

static void
curl_close(stream *s)
{
	(void) s;
}

stream *
open_urlstream(const char *url)
{
	stream *s;
	struct curl_data *c;
#ifdef USE_CURL_MULTI
	CURLMsg *msg;
#endif

	if ((c = malloc(sizeof(*c))) == NULL)
		return NULL;
	c->handle = NULL;
	c->buffer = NULL;
	c->maxsize = c->usesize = c->offset = 0;
	c->running = 1;
	if ((s = create_stream(url)) == NULL) {
		free(c);
		return NULL;
	}
#ifdef USE_CURL_MULTI
	/* lock access to curl_handles */
	c->next = curl_handles;
	curl_handles = c;
	/* unlock access to curl_handles */
#endif
	s->read = curl_read;
	s->write = curl_write;
	s->close = curl_close;
	s->destroy = curl_destroy;
	s->stream_data.p = (void *) c;
	if ((c->handle = curl_easy_init()) == NULL) {
		destroy(s);
		return NULL;
	}
	curl_easy_setopt(c->handle, CURLOPT_URL, s->name);
	curl_easy_setopt(c->handle, CURLOPT_WRITEDATA, s);
	curl_easy_setopt(c->handle, CURLOPT_VERBOSE, FALSE);
	curl_easy_setopt(c->handle, CURLOPT_NOSIGNAL, TRUE);
	curl_easy_setopt(c->handle, CURLOPT_WRITEFUNCTION, write_callback);
#ifdef USE_CURL_MULTI
	if (multi_handle == NULL)
		multi_handle = curl_multi_init();
	curl_multi_add_handle(multi_handle, c->handle);
	while (curl_multi_perform(multi_handle, NULL) == CURLM_CALL_MULTI_PERFORM)
		;
	while ((msg = curl_multi_info_read(multi_handle, NULL)) != NULL) {
		struct curl_data *p;
		/* lock access to curl_handles */
		for (p = curl_handles; p; p = p->next) {
			if (p->handle == msg->easy_handle) {
				switch (msg->msg) {
				case CURLMSG_DONE:
					p->running = 0;
					p->result = msg->data.result;
					curl_multi_remove_handle(multi_handle, p->handle);
					curl_easy_cleanup(p->handle);
					p->handle = NULL;
					break;
				default:
					break;
				}
				break;
			}
		}
		/* unlock access to curl_handles */
	}
#else
	if (curl_easy_perform(c->handle) != CURLE_OK)
		s->errnr = OPEN_ERROR;
	curl_easy_cleanup(c->handle);
	c->handle = NULL;
	c->running = 0;
#endif
	return s;
}

#endif /* HAVE_CURL */

static ssize_t
socket_write(stream *s, const void *buf, size_t elmsize, size_t cnt)
{
	ssize_t nr = 0, res = 0, size = elmsize * cnt;

	if (!s || s->errnr) 
		return -1;

	if (size == 0 || elmsize == 0)
		return cnt;

	errno = 0;
	while (res < size && (
#ifdef NATIVE_WIN32
				     ((nr = send(s->stream_data.i, (void *) ((char *) buf + res), size - res, 0)) > 0)
#else
				     ((nr = write(s->stream_data.i, (void *) ((char *) buf + res), size - res)) > 0)
#endif
				     || errno == EAGAIN || errno == EWOULDBLOCK || errno == EINTR)
	    ) {
		errno = 0;
		if (nr > 0)
			res += nr;
	}
	if (nr < 0) {
		s->errnr = WRITE_ERROR;
		return nr;
	}
	if (res > 0)
		return res / elmsize;
	s->errnr = WRITE_ERROR;
	return -1;
}

static ssize_t
socket_read(stream *s, void *buf, size_t elmsize, size_t cnt)
{
	ssize_t nr = 0, res = 0, size = elmsize * cnt;

	if (!s || s->errnr) 
		return(-1);

	errno = 0;
	while (res < size && (
#ifdef NATIVE_WIN32
				     ((nr = recv(s->stream_data.i, (void *) ((char *) buf + res), size - res, 0)) > 0)
#else
				     ((nr = read(s->stream_data.i, (void *) ((char *) buf + res), size - res)) > 0)
#endif
				     || errno == EAGAIN || errno == EWOULDBLOCK || errno == EINTR)
	    ) {
		errno = 0;
		if (nr > 0)
			res += nr;
	}
	if (nr < 0) {
		s->errnr = READ_ERROR;
		return nr;
	}
	return res / elmsize;
}

/* Read one line (seperated by \n) of at most maxcnt characters from the 
   stream. Returns the number of characters actually read. */
static ssize_t
socket_readline(stream *s, void *buf, size_t maxcnt)
{
	size_t len = 0;
	char *b = buf, *start = buf;

	while (socket_read(s, start, 1, 1) > 0 && len < maxcnt) {
		if (*start == '\n')
			break;
		start++;
	}
	if (s->errnr) return s->errnr;
	return (start - b);
}


#ifdef NATIVE_WIN32
#define s_close(s)	closesocket(s)
#else
#define s_close(s)	close(s)
#endif

static void
socket_close(stream *s)
{
	int fd = s->stream_data.i;

	if (fd >= 0) {
		/* Related read/write (in/out, from/to) streams
		 * share a single socket which is not dup'ed (anymore)
		 * as Windows' dup doesn't work on sockets;
		 * hence, only one of the streams must/may close that
		 * socket; we choose to let the read socket do the
		 * job, since in mapi.mx it may happen that the read
		 * stream is closed before the write stream was even
		 * created.
		 */
		if (s->access == ST_READ) {
#ifdef HAVE_SHUTDOWN
			shutdown(fd, SHUT_RDWR);
#endif
			s_close(fd);
		}
	}
	s->stream_data.i = -1;
}

static stream *
socket_open(int socket, const char *name)
{
	stream *s;

	if ((s = create_stream(name)) == NULL)
		return NULL;
	s->read = socket_read;
	s->readline = socket_readline;
	s->write = socket_write;
	s->close = socket_close;
	s->flush = NULL;
	s->stream_data.i = socket;

	errno = 0;
#if defined(SO_KEEPALIVE) && !defined(WIN32)
	{
		int opt = 0;
		if (setsockopt(socket, SOL_SOCKET, SO_KEEPALIVE, (void *) &opt, sizeof(opt)) < 0) {
			s->errnr = OPEN_ERROR;
			return s;
		}
	}
#endif
#if defined(IPTOS_THROUGHPUT) && !defined(WIN32)
	{
		int tos = IPTOS_THROUGHPUT;

		if (setsockopt(socket, IPPROTO_IP, IP_TOS, (void *) &tos, sizeof(tos)) < 0) {
			s->errnr = OPEN_ERROR;
			return s;
		}
	}
#endif
#ifdef TCP_NODELAY
	{
		int nodelay = 1;

		if (setsockopt(socket, IPPROTO_TCP, TCP_NODELAY, (void *) &nodelay, sizeof(nodelay)) < 0) {
			s->errnr = OPEN_ERROR;
			return s;
		}
	}
#endif
#ifdef HAVE_FCNTL
	{
		int fl = fcntl(socket, F_GETFL);

		fl &= ~O_NONBLOCK;
		if (fcntl(socket, F_SETFL, fl) < 0) {
			s->errnr = OPEN_ERROR;
			return s;
		}
	}
#endif

	return s;
}

stream *
socket_rstream(int socket, const char *name)
{
	stream *s;

#ifdef STREAM_DEBUG
	printf("socket_rstream %d %s\n", socket, name);
#endif
	if ((s = socket_open(socket, name)) == NULL)
		return NULL;
	s->type = ST_BIN;
	if (s->errnr == NO__ERROR)
		socket_read(s, (void *) &s->byteorder, sizeof(s->byteorder), 1);
	return s;
}

stream *
socket_wstream(int socket, const char *name)
{
	stream *s;

#ifdef STREAM_DEBUG
	printf("socket_wstream %d %s\n", socket, name);
#endif
	if ((s = socket_open(socket, name)) == NULL)
		return NULL;
	s->access = ST_WRITE;
	s->type = ST_BIN;
	if (s->errnr == NO__ERROR)
		socket_write(s, (void *) &s->byteorder, sizeof(s->byteorder), 1);
	return s;
}

stream *
socket_rastream(int socket, const char *name)
{
	stream *s;

#ifdef STREAM_DEBUG
	printf("socket_rastream %d %s\n", socket, name);
#endif
	if ((s = socket_open(socket, name)) != NULL)
		s->type = ST_ASCII;
	return s;
}

stream *
socket_wastream(int socket, const char *name)
{
	stream *s;

#ifdef STREAM_DEBUG
	printf("socket_wastream %d %s\n", socket, name);
#endif
	if ((s = socket_open(socket, name)) == NULL)
		return NULL;
	s->access = ST_WRITE;
	s->type = ST_ASCII;
	return s;
}

#ifdef HAVE_OPENSSL
struct ssl_data {
	int error;
	int ret;
	SSL *ssl;
};

static ssize_t
ssl_read(stream *s, void *buf, size_t elmsize, size_t cnt)
{
	SSL *ssl;
	size_t res = 0, size = elmsize * cnt;

	if (!s || s->errnr) 
		return(-1);

	assert(s->stream_data.p);
	ssl = ((struct ssl_data *) s->stream_data.p)->ssl;
	assert(ssl);
	while (res < size) {
		int nr, err;

		nr = SSL_read(ssl, (void *) ((char *) buf + res), (int) (size - res));
		err = SSL_get_error(ssl, nr);
		switch (err) {
		case SSL_ERROR_WANT_READ:
		case SSL_ERROR_WANT_WRITE:
		case SSL_ERROR_WANT_CONNECT:
		case SSL_ERROR_WANT_ACCEPT:
		case SSL_ERROR_WANT_X509_LOOKUP:
			/* try again with the same args */
			continue;
		case SSL_ERROR_NONE:
			/* successful read */
			res += nr;
			break;
		default:
			/* some error occurred */
			s->errnr = READ_ERROR;
			((struct ssl_data *) s->stream_data.p)->error = err;
			((struct ssl_data *) s->stream_data.p)->ret = nr;
			return -1;
		}
	}
	return res / elmsize;
}

static ssize_t
ssl_write(stream *s, const void *buf, size_t elmsize, size_t cnt)
{
	SSL *ssl;
	int size = (int) (elmsize * cnt);

	assert(s->stream_data.p);
	ssl = ((struct ssl_data *) s->stream_data.p)->ssl;
	assert(ssl);
	if (size == 0 || elmsize == 0)
		return cnt;	/* nothing to do */
	for (;;) {
		int nr, err;

		nr = SSL_write(ssl, buf, size);
		err = SSL_get_error(ssl, nr);
		switch (err) {
		case SSL_ERROR_WANT_READ:
		case SSL_ERROR_WANT_WRITE:
		case SSL_ERROR_WANT_CONNECT:
		case SSL_ERROR_WANT_ACCEPT:
		case SSL_ERROR_WANT_X509_LOOKUP:
			/* try again with the same args */
			continue;
		case SSL_ERROR_NONE:
			/* successful write */
			return cnt;
		default:
			/* some error occurred */
			s->errnr = READ_ERROR;
			((struct ssl_data *) s->stream_data.p)->error = err;
			((struct ssl_data *) s->stream_data.p)->ret = nr;
			return -1;
		}
	}
}

static void
ssl_destroy(stream *s)
{
	if (s->stream_data.p)
		free(s->stream_data.p);
	s->stream_data.p = NULL;
	destroy(s);
}

static void
ssl_close(stream *s)
{
	struct ssl_data *ssl_data = (struct ssl_data *) s->stream_data.p;

	if (ssl_data && ssl_data->ssl) {
		int sock = SSL_shutdown(ssl_data->ssl);

		if (sock == 0)
			sock = SSL_shutdown(ssl_data->ssl);
#ifdef REPORT_SSL_SHUTDOWN_ERROR	/* usually undefined */
		if (sock == -1) {
			int err = SSL_get_error(ssl_data->ssl, sock);
			char *errstr = error(err, sock);

			fprintf(stderr, "SSL_shutdown: %s\n", errstr);
			free(errstr);
		}
#endif
		sock = SSL_get_fd(ssl_data->ssl);
		/* Related read/write (in/out, from/to) streams
		 * share a single socket which is not dup'ed (anymore)
		 * as Windows' dup doesn't work on sockets;
		 * hence, only one of the streams must/may close that
		 * socket; we choose to let the write socket do the job.
		 */
		if (s->access == ST_READ) {
			shutdown(sock, SHUT_RD);
			close(sock);
		} else {
			shutdown(sock, SHUT_WR);
		}
		if (ssl_data->ssl)
			SSL_free(ssl_data->ssl);
		ssl_data->ssl = NULL;
	}
}

static char *
ssl_error(stream *s)
{
	char *errstr;
	char buf[120];
	unsigned long e;

	assert(s->stream_data.p);
	switch (((struct ssl_data *) s->stream_data.p)->error) {
	case SSL_ERROR_ZERO_RETURN:
		errstr = "TLS/SSL connection has been closed";
		break;
	case SSL_ERROR_WANT_READ:
		errstr = "The operation did not complete (read)";
		break;
	case SSL_ERROR_WANT_WRITE:
		errstr = "The operation did not complete (write)";
		break;
	case SSL_ERROR_WANT_X509_LOOKUP:
		errstr = "The operation did not complete (X509 lookup)";
		break;
	case SSL_ERROR_WANT_CONNECT:
		errstr = "The operation did not complete (connect)";
		break;
	case SSL_ERROR_SYSCALL:
		e = ERR_get_error();
		if (e == 0) {
			if (((struct ssl_data *) s->stream_data.p)->ret == 0) {
				errstr = "EOF occurred in violation of protocol";
			} else if (((struct ssl_data *) s->stream_data.p)->ret == -1) {
				/* the underlying BIO reported an I/O error */
				errstr = "I/O error";
			} else {	/* possible? */
				errstr = "Some I/O error occurred";
			}
		} else {
			errstr = ERR_error_string(e, buf);
		}
		break;
	case SSL_ERROR_SSL:
		e = ERR_get_error();
		if (e != 0)
			errstr = ERR_error_string(e, buf);
		else {		/* possible? */
			errstr = "A failure in the SSL library occurred";
		}
		break;
	default:
		errstr = "Invalid error code";
	}
	return strdup(errstr);
}

static stream *
ssl_open(SSL * ssl, const char *name)
{
	struct ssl_data *ssl_data;
	stream *s;

	assert(ssl);
	if ((s = create_stream(name)) == NULL)
		return NULL;

	s->read = ssl_read;
	s->write = ssl_write;
	s->close = ssl_close;
	s->error = ssl_error;
	s->flush = NULL;
	s->destroy = ssl_destroy;

	if ((ssl_data = malloc(sizeof(*ssl_data))) == NULL) {
		destroy(s);
		return NULL;
	}
	ssl_data->ret = 0;
	ssl_data->error = 0;
	ssl_data->ssl = ssl;
	s->stream_data.p = (void *) ssl_data;
	return s;
}

stream *
ssl_rstream(SSL * ssl, const char *name)
{
	stream *s;

#ifdef STREAM_DEBUG
	printf("ssl_rstream " PTRFMT " %s\n", PTRFMTCAST ssl, name);
#endif
	if ((s = ssl_open(ssl, name)) == NULL)
		return NULL;
	s->access = ST_READ;
	s->type = ST_BIN;
	if (s->errnr == NO__ERROR)
		ssl_read(s, (void *) &s->byteorder, sizeof(s->byteorder), 1);
	return s;
}

stream *
ssl_wstream(SSL * ssl, const char *name)
{
	stream *s;

#ifdef STREAM_DEBUG
	printf("ssl_wstream " PTRFMT " %s\n", PTRFMTCAST ssl, name);
#endif
	if ((s = ssl_open(ssl, name)) == NULL)
		return NULL;
	s->access = ST_WRITE;
	s->type = ST_BIN;
	if (s->errnr == NO__ERROR)
		ssl_write(s, (void *) &s->byteorder, sizeof(s->byteorder), 1);
	return s;
}

stream *
ssl_rastream(SSL * ssl, const char *name)
{
	stream *s;

#ifdef STREAM_DEBUG
	printf("ssl_rastream " PTRFMT " %s\n", PTRFMTCAST ssl, name);
#endif
	if ((s = ssl_open(ssl, name)) == NULL)
		return NULL;
	s->access = ST_READ;
	s->type = ST_ASCII;
	return s;
}

stream *
ssl_wastream(SSL * ssl, const char *name)
{
	stream *s;

#ifdef STREAM_DEBUG
	printf("ssl_wastream " PTRFMT " %s\n", PTRFMTCAST ssl, name);
#endif
	if ((s = ssl_open(ssl, name)) == NULL)
		return NULL;
	s->access = ST_WRITE;
	s->type = ST_ASCII;
	return s;
}
#endif /* HAVE_OPENSSL */

static stream *
file_stream(const char *name)
{
	stream *s;

	if ((s = create_stream(name)) == NULL)
		return NULL;
	s->read = file_read;
	s->write = file_write;
	s->close = file_close;
	s->flush = file_flush;
	return s;
}

stream *
file_rstream(FILE *fp, const char *name)
{
	stream *s;

#ifdef STREAM_DEBUG
	printf("file_rstream %s\n", name);
#endif
	if ((s = file_stream(name)) == NULL)
		return NULL;
	s->type = ST_BIN;
	if (fp == NULL)
		s->errnr = OPEN_ERROR;
	s->stream_data.p = (void *) fp;

	if (s->errnr == NO__ERROR) {
		fread((void *) &s->byteorder, sizeof(s->byteorder), 1, fp);
		if (ferror(fp))
			s->errnr = OPEN_ERROR;
	}
	return s;
}

stream *
file_wstream(FILE *fp, const char *name)
{
	stream *s;

#ifdef STREAM_DEBUG
	printf("file_wstream %s\n", name);
#endif
	if ((s = file_stream(name)) == NULL)
		return NULL;
	s->access = ST_WRITE;
	s->type = ST_BIN;
	if (fp == NULL)
		s->errnr = OPEN_ERROR;
	s->stream_data.p = (void *) fp;

	if (s->errnr == NO__ERROR) {
		fwrite((void *) &s->byteorder, sizeof(s->byteorder), 1, fp);
		if (ferror(fp))
			s->errnr = OPEN_ERROR;
	}
	return s;
}

stream *
file_rastream(FILE *fp, const char *name)
{
	stream *s;

#ifdef STREAM_DEBUG
	printf("file_rastream %s\n", name);
#endif
	if ((s = file_stream(name)) == NULL)
		return NULL;
	s->type = ST_ASCII;
	if (fp == NULL)
		s->errnr = OPEN_ERROR;
	s->stream_data.p = (void *) fp;
	return s;
}

stream *
file_wastream(FILE *fp, const char *name)
{
	stream *s;

#ifdef STREAM_DEBUG
	printf("file_wastream %s\n", name);
#endif
	if ((s = file_stream(name)) == NULL)
		return NULL;
	s->access = ST_WRITE;
	s->type = ST_ASCII;
	if (fp == NULL)
		s->errnr = OPEN_ERROR;
	s->stream_data.p = (void *) fp;
	return s;
}

void
buffer_init(buffer *b, char *buf, size_t size)
{
	b->pos = 0;
	b->buf = buf;
	b->len = size;
}

buffer *
buffer_create(size_t size)
{
	buffer *b;

	if ((b = malloc(sizeof(*b))) == NULL)
		return NULL;
	b->pos = 0;
	b->buf = malloc(size);
	b->len = b->buf ? size : 0;
	return b;
}

char *
buffer_get_buf(buffer *b)
{
	char *r = b->buf;

	if (b->pos == b->len && (b->buf = realloc(b->buf, b->len+1)) == NULL) 
		return NULL;
	r[b->pos] = '\0';
	b->buf = malloc(b->len);
	b->len = b->buf ? b->len : 0;
	b->pos = 0;
	return r;
}

void
buffer_destroy(buffer *b)
{
	free(b->buf);
	free(b);
}

buffer *
stream_get_buffer(stream *s)
{
	return (buffer *) s->stream_data.p;
}

static ssize_t
buffer_read(stream *s, void *buf, size_t elmsize, size_t cnt)
{
	size_t size = elmsize * cnt;
	buffer *b = (buffer *) s->stream_data.p;

	assert(b);
	if (b->pos + size <= b->len) {
		memcpy(buf, b->buf + b->pos, size);
		b->pos += size;
		return size / elmsize;
	} else {
		s->errnr = READ_ERROR;
		return 0;
	}
}

static ssize_t
buffer_write(stream *s, const void *buf, size_t elmsize, size_t cnt)
{
	size_t size = elmsize * cnt;
	buffer *b = (buffer *) s->stream_data.p;

	assert(b);
	if (b->pos + size > b->len) {
		size_t ns = b->len;

		while (b->pos + size > ns)
			ns *= 2;
		if ((b->buf = realloc(b->buf, ns)) == NULL) {
			s->errnr = WRITE_ERROR;
			return -1;
		}
		b->len = ns;
	}
	memcpy(b->buf + b->pos, buf, size);
	b->pos += size;
	return cnt;
}

static void
buffer_close(stream *s)
{
	(void) s;
}

static int
buffer_flush(stream *s)
{
	buffer *b = (buffer *) s->stream_data.p;

	assert(b);
	b->pos = 0;
	return 0;
}

stream *
buffer_rastream(buffer *b, const char *name)
{
	stream *s;

#ifdef STREAM_DEBUG
	printf("buffer_rastream %s\n", name);
#endif
	if ((s = create_stream(name)) == NULL)
		return NULL;
	s->type = ST_ASCII;
	s->read = buffer_read;
	s->write = buffer_write;
	s->close = buffer_close;
	s->flush = buffer_flush;
	s->stream_data.p = (void *) b;
	return s;
}

stream *
buffer_wastream(buffer *b, const char *name)
{
	stream *s;

#ifdef STREAM_DEBUG
	printf("buffer_wastream %s\n", name);
#endif
	if ((s = create_stream(name)) == NULL)
		return NULL;
	s->access = ST_WRITE;
	s->type = ST_ASCII;
	s->read = buffer_read;
	s->write = buffer_write;
	s->close = buffer_close;
	s->flush = buffer_flush;
	s->stream_data.p = (void *) b;
	return s;
}

/* A buffered stream consists of a sequence of blocks.  Each block
   consists of a count followed by the data in the block.  A flush is
   indicated by an empty block (i.e. just a count of 0).
 */
typedef struct bs {
	stream *s;		/* underlying stream */
	unsigned nr;		/* how far we got in buf */
	unsigned itotal;	/* amount available in current read block */
	char buf[BLOCK];	/* the buffered data (minus the size of
	                           size-short */
} bs;

static bs *
bs_create(stream *s)
{
	/* should be a binary stream */
	bs *ns;

	if ((ns = malloc(sizeof(*ns))) == NULL)
		return NULL;
	ns->s = s;
	ns->nr = 0;
	ns->itotal = 0;
	return ns;
}

/* Collect data until the internal buffer is filled, then write the
   filled buffer to the underlying stream.
   Struct field usage:
   s - the underlying stream;
   buf - the buffer in which data is collected;
   nr - how much of buf is already filled (if nr == sizeof(buf) the
        data is written to the underlying stream, so upon entry nr <
        sizeof(buf));
   itotal - unused.
 */
static ssize_t
bs_write(stream *ss, const void *buf, size_t elmsize, size_t cnt)
{
	bs *s = (bs *) ss->stream_data.p;
	size_t todo = cnt * elmsize;
	short blksize;

	assert(ss->access == ST_WRITE);
	assert(s->nr < sizeof(s->buf));
	while (todo > 0) {
		size_t n = sizeof(s->buf) - s->nr;

		if (todo < n)
			n = todo;
		memcpy(s->buf + s->nr, buf, n);
		s->nr += n;
		todo -= n;
		buf = (void *) ((char *) buf + n);
		if (s->nr == sizeof(s->buf)) {
			/* block is full, write it to the stream */
#ifdef BSTREAM_DEBUG
			{
				unsigned i;

				printf("W %s %u \"", ss->name, s->nr);
				for (i = 0; i < s->nr; i++)
					if (' ' <= s->buf[i] && s->buf[i] < 127)
						putchar(s->buf[i]);
					else
						printf("\\%03o", s->buf[i]);
				printf("\"\n");
			}
#endif
			/* since the block is at max BLOCK (8K) - 2 size we can
			   store it in a two byte integer */
			blksize = (short) s->nr;
			/* the last bit tells whether a flush is in there, it's not
			 * at this moment, so shift it to the left */
			blksize <<= 1;
			if (!stream_writeSht(s->s, blksize) || s->s->write(s->s, s->buf, 1, s->nr) != (ssize_t) s->nr) {
				ss->errnr = WRITE_ERROR;
				return -1;
			}
			s->nr = 0;
		}
	}
	return cnt;
}

/* If the internal buffer is partially filled, write it to the
   underlying stream.  Then in any case write an empty buffer to the
   underlying stream to indicate to the receiver that the data was
   flushed.
 */
static int
bs_flush(stream *ss)
{
	short blksize;
	bs *s = (bs *) ss->stream_data.p;

	assert(ss->access == ST_WRITE);
	assert(s->nr < sizeof(s->buf));
	if (ss->access == ST_WRITE) {
		/* flush the rest of buffer (if s->nr > 0), then set the
		 * last bit to 1 to to indicate user-instigated flush */
#ifdef BSTREAM_DEBUG
		if (s->nr > 0) {
			unsigned i;

			printf("W %s %u \"", ss->name, s->nr);
			for (i = 0; i < s->nr; i++)
				if (' ' <= s->buf[i] && s->buf[i] < 127)
					putchar(s->buf[i]);
				else
					printf("\\%03o", s->buf[i]);
			printf("\"\n");
			printf("W %s 0\n", ss->name);
		}
#endif
		blksize = (short) (s->nr << 1);
		/* indicate that this is the last buffer of a block by
		   setting the low-order bit */
		blksize |= (short) 1;
		/* allways flush (even empty blocks) needed for the protocol) */
		if ((!stream_writeSht(s->s, blksize) || s->s->write(s->s, s->buf, 1, s->nr) != (ssize_t) s->nr)) {
			ss->errnr = WRITE_ERROR;
			return -1;
		}
		s->nr = 0;
	}
	return 0;
}

/* Read buffered data and return the number of items read.  At the
   flush boundary we will return 0 to indicate the end of a block.

   Structure field usage:
   s - the underlying stream;
   buf - not used;
   itotal - the amount of data in the current block that hasn't yet
            been read;
   nr - indicates whether the flush marker has to be returned.
 */
static ssize_t
bs_read(stream *ss, void *buf, size_t elmsize, size_t cnt)
{
	bs *s = (bs *) ss->stream_data.p;
	size_t todo = cnt * elmsize;
	size_t n;

	assert(ss->access == ST_READ);
	assert(s->nr <= 1);

	if (s->itotal == 0) {
		short blksize = 0;

		if (s->nr) {
			/* We read the closing block but hadn't returned that yet.
			   Return it now, and note that we did by setting s->nr to
			   0.
			*/
			assert(s->nr == 1);
			s->nr = 0;
			return 0;
		}

		assert(s->nr == 0);

		/* There is nothing more to read in the current block,
		   so read the count for the next block */
		if (!stream_readSht(s->s, &blksize) || blksize < 0) {
			ss->errnr = READ_ERROR;
			return -1;
		}
#ifdef BSTREAM_DEBUG
		printf("RC size: %d, final: %s\n", blksize >> 1, blksize & 1 ? "true" : "false");
		printf("RC %s %d\n", ss->name, blksize);
#endif
		s->itotal = (unsigned) (blksize >> 1); /* amount readable */
		/* store whether this was the last block or not */
		s->nr = blksize & 1;
	}

	/* Fill the caller's buffer. */
	cnt = 0;		/* count how much we put into the buffer */
	while (todo > 0) {
		/* there is more data waiting in the current block,
		   so read it */
		n = todo < s->itotal ? todo : s->itotal;
		while (n > 0) {
			ssize_t m = s->s->read(s->s, buf, 1, n);

			if (m <= 0) {
				ss->errnr = READ_ERROR;
				return -1;
			}
#ifdef BSTREAM_DEBUG
			{
				ssize_t i;

				printf("RD %s %zd \"", ss->name, m);
				for (i = 0; i < m; i++)
					if (' ' <= ((char *) buf)[i] && ((char *) buf)[i] < 127)
						putchar(((char *) buf)[i]);
					else
						printf("\\%03o", ((char *) buf)[i]);
				printf("\"\n");
			}
#endif
			if (m == 0 && !isa_block_stream(s->s))
				break;
			buf = (void *) ((char *) buf + m);
			cnt += m;
			n -= m;
			s->itotal -= m;
			todo -= m;
		}

		if (s->itotal == 0) {
			short blksize = 0;

			/* The current block has been completely read,
			   so read the count for the next block, only if the
			   previous was not the last one */
			if (s->nr) {
				break;
			} else if (!stream_readSht(s->s, &blksize) || blksize < 0) {
				ss->errnr = READ_ERROR;
				return -1;
			}
#ifdef BSTREAM_DEBUG
			printf("RC size: %d, final: %s\n", blksize >> 1, blksize & 1 ? "true" : "false");
			printf("RC %s %d\n", ss->name, s->nr);
			printf("RC %s %d\n", ss->name, blksize);
#endif
			s->itotal = (unsigned) (blksize >> 1); /* amount readable */
			/* store whether this was the last block or not */
			s->nr = blksize & 1;
		}
	}
	/* if we got an empty block with the end-of-sequence marker
	   set (low-order bit) we must only return an empty read once, so
	   we must squash the flag that we still have to return an empty
	   read */
	if (todo > 0 && cnt == 0)
		s->nr = 0;
	return cnt / elmsize;
}

/* Read the next bit of a block.  If this was the last bit of the
   current block, set the value pointed to by last to 1, otherwise set
   it to 0. */
ssize_t
bs_read_next(stream *ss, void *buf, size_t nbytes, int *last)
{
	ssize_t n;
	bs *s = (bs *) ss->stream_data.p;

	n = bs_read(ss, buf, 1, nbytes);
	if (n < 0) {
		if (last)
			*last = 1;
		return -1;
	}
	if (last)
		*last = s->itotal == 0;
	if (s->itotal == 0) {
		/* we don't want to get an empty buffer at the next read */
		s->nr = 0;
	}
	return n;
}

static void
bs_close(stream *ss)
{
	bs *s = (bs *) ss->stream_data.p;

	assert(s);
	assert(s->s);
	s->s->close(s->s);
}

static void
bs_destroy(stream *ss)
{
	bs *s = (bs *) ss->stream_data.p;

	assert(s);
	assert(s->s);
	s->s->destroy(s->s);
	free(s);
	destroy(ss);
}

stream *
block_stream(stream *s)
{
	stream *ns;
	bs *bs;

#ifdef STREAM_DEBUG
	printf("block_stream %s\n", s->name ? s->name : "<unnamed>");
#endif
	if ((ns = create_stream(s->name)) == NULL)
		return NULL;
	if ((bs = bs_create(s)) == NULL)
		ns->errnr = OPEN_ERROR;
	ns->type = s->type;
	ns->access = s->access;
	ns->read = bs_read;
	ns->write = bs_write;
	ns->close = bs_close;
	ns->flush = bs_flush;
	ns->destroy = bs_destroy;
	ns->stream_data.p = (void *) bs;

	return ns;
}

int
isa_block_stream(stream *s)
{
	return s->read == bs_read || s->write == bs_write;
}

@= stream_readVal
int
stream_read@1(stream *s, @2 *val)
{
	switch (s->read(s, (void *) val, sizeof(*val), 1)) {
	case 1:
		if (s->byteorder != 1234)
			*val = @3_SWAP(*val);
		return 1;
	case 0:
		/* consider EOF an error */
		s->errnr = READ_ERROR;
		/* fall through */
	default:
		/* read failed */
		return 0;
	}
}
@c

#define no_SWAP(x) x

@:stream_readVal(Bte,signed char,no)@

int
stream_writeBte(stream *s, signed char val)
{
	if (!s || s->errnr) return(0);
	return s->write(s, (void *) &val, sizeof(val), 1) == 1;
}

@:stream_readVal(Sht,short,short_int)@

int
stream_writeSht(stream *s, short val)
{
	if (!s || s->errnr) return(0);
	return s->write(s, (void *) &val, sizeof(val), 1) == 1;
}

@:stream_readVal(Int,int,normal_int)@

int
stream_writeInt(stream *s, int val)
{
	if (!s || s->errnr) return(0);
	return s->write(s, (void *) &val, sizeof(val), (size_t) 1) == 1;
}

@:stream_readVal(Lng,lng,long_long)@

int
stream_writeLng(stream *s, lng val)
{
	if (!s || s->errnr) return(0);
	return s->write(s, (void *) &val, sizeof(val), (size_t) 1) == 1;
}

@= stream_readArray
int
stream_read@1Array(stream *s, @2 *val, size_t cnt)
{
	if (s->read(s, (void *) val, sizeof(*val), cnt) < (ssize_t) cnt) {
		s->errnr = READ_ERROR;
		return 0;
	}

	if (s->byteorder != 1234) {
		size_t i;
		for (i = 0; i < cnt; i++, val++)
			*val = @3_SWAP(*val);	
	}
	return 1;
}
@c

@:stream_readArray(Bte,signed char,no)@

int
stream_writeBteArray(stream *s, const signed char *val, size_t cnt)
{
	if (!s || s->errnr) return(0);
	return s->write(s, (void *) val, sizeof(*val), cnt) == (ssize_t) cnt;
}

@:stream_readArray(Sht,short,short_int)@

int
stream_writeShtArray(stream *s, const short *val, size_t cnt)
{
	if (!s || s->errnr) return(0);
	return s->write(s, (void *) val, sizeof(*val), cnt) == (ssize_t) cnt;
}

@:stream_readArray(Int,int,normal_int)@

int
stream_writeIntArray(stream *s, const int *val, size_t cnt)
{
	if (!s || s->errnr) return(0);
	return s->write(s, (void *) val, sizeof(*val), cnt) == (ssize_t) cnt;
}

@:stream_readArray(Lng,lng,long_long)@

int
stream_writeLngArray(stream *s, const lng *val, size_t cnt)
{
	if (!s || s->errnr) return(0);
	return s->write(s, (void *) val, sizeof(*val), cnt) == (ssize_t) cnt;
}

int
stream_printf(stream *s, const char *format, ...)
{
	char buf[BUFSIZ], *bf = buf;
	int i = 0;
	size_t bfsz = BUFSIZ;
	va_list ap;
	if (!s || s->errnr) return(-1);

@= stream_printf_va_vsnprintf
	va_start(ap, format);
	i = vsnprintf(bf, bfsz, format, ap);
	va_end (ap);
@c
	@:stream_printf_va_vsnprintf@
	while (i < 0 || (size_t) i >= bfsz) {
		if (i >= 0)	/* glibc 2.1 */
			bfsz = (size_t) i + 1;	/* precisely what is needed */
		else		/* glibc 2.0 */
			bfsz *= 2;	/* twice the old size */
		if (bf != buf)
			free(bf);
		bf = malloc(bfsz);
		assert(bf != NULL);
		if (bf == NULL) {
			s->errnr = WRITE_ERROR;
			return -1;
		}
		@:stream_printf_va_vsnprintf@
	}
	s->write(s, (void *) bf, (size_t) i, (size_t) 1);
	if (bf != buf)
		free(bf);
	return s->errnr ? -1 : i;
}


bstream *
bstream_create(stream *s, size_t size)
{
	bstream *b;

	if ((b = malloc(sizeof(*b))) == NULL)
		return NULL;
	b->mode = size;
	if (size == 0)
		size = BUFSIZ;
	b->s = s;
	b->buf = malloc(size + 1);
	b->size = b->buf ? size : 0;
	b->pos = 0;
	b->len = 0;
	b->eof = 0;
	return b;
}

ssize_t
bstream_read(bstream *s, size_t size)
{
	ssize_t rd;

	if (s->eof)
		return 0;

	if (s->pos > 0) {
		if (s->pos < s->len)
			/* move all data and end of string marker */
			memmove(s->buf, s->buf + s->pos, s->len - s->pos + 1);
		s->len -= s->pos;
		s->pos = 0;
	}

	if (s->len == s->size && (s->buf = realloc(s->buf, (s->size <<= 1) + 1)) == NULL) {
		s->size = 0;
		s->len = 0;
		s->pos = 0;
		return -1;
	}

	if (size > s->size - s->len)
		size = s->size - s->len;

	rd = s->s->read(s->s, s->buf + s->len, 1, size);

	if (rd < 0)
		return rd;

	if (rd == 0) {
		s->eof = 1;
		return 0;
	}
	s->len += rd;
	s->buf[s->len] = 0;	/* fill in the spare with EOS */
	return rd;
}

#ifdef _POSIX2_LINE_MAX
#define STREAM_LINE_MAX _POSIX2_LINE_MAX
#else
#define STREAM_LINE_MAX 2048
#endif

static ssize_t
bstream_readline(bstream *s)
{
	size_t size = STREAM_LINE_MAX;
	ssize_t rd;

	if (s->eof)
		return 0;

	if (s->pos > 0 && s->len + size >= s->size) {
		if (s->pos < s->len)
			/* move all data and end of string marker */
			memmove(s->buf, s->buf + s->pos, s->len - s->pos + 1);
		s->len -= s->pos;
		s->pos = 0;
	}

	if (s->len == s->size && (s->buf = realloc(s->buf, (s->size <<= 1) + 1)) == NULL) {
		s->size = 0;
		s->len = 0;
		s->pos = 0;
		return -1;
	}

	if (size > s->size - s->len)
		size = s->size - s->len;

	if (fgets(s->buf + s->len, size, s->s->stream_data.p) == NULL)
		return -1;

	rd = strlen(s->buf + s->len);

	if (rd == 0) {
		s->eof = 1;
		return 0;
	}
	s->len += rd;
	s->buf[s->len] = 0;	/* fill in the spare with EOS */
	return rd;
}


ssize_t
bstream_next(bstream *s)
{
	if (s->mode) {
		return bstream_read(s, s->mode);
	} else if (s->s->read == file_read) {
		return bstream_readline(s);
	} else {
		int sz = 0, rd;

		while ((rd = bstream_read(s, 1)) == 1 && s->buf[s->pos + sz] != '\n') {
			sz += rd;
		}
		if (rd < 0)
			return rd;
		return sz;
	}
}

void
bstream_destroy(bstream *s)
{
	free(s->buf);
	free(s);
}

#ifdef HAVE_PIPE
static ssize_t
pipe_write(stream *s, const void *buf, size_t elmsize, size_t cnt)
{
	size_t size = elmsize * cnt;
	ssize_t sz;

	if (s->errnr)
		return -1;

	if (size == 0 || elmsize == 0)
		return cnt;
	sz = write(s->stream_data.i, buf, size);
	if (sz > 0)
		return sz / elmsize;
	if (sz < 0)
		s->errnr = WRITE_ERROR;
	return sz;
}

static ssize_t
pipe_read(stream *s, void *buf, size_t elmsize, size_t cnt)
{
	ssize_t nr = 0;
	size_t res = 0, size = elmsize * cnt;

	if (s->errnr)
		return -1;

	while (res < size && (nr = read(s->stream_data.i, (void *) ((char *) buf + res), size - res)) > 0) {
		res += nr;
	}
	if (nr < 0) {
		s->errnr = READ_ERROR;
		return nr;
	}
	if (res)
		return res / elmsize;
	return 0;
}

static void
pipe_close(stream *s)
{
	if (s->stream_data.i >= 0)
		close(s->stream_data.i);
	s->stream_data.i = -1;
}

int
rendezvous_streams(stream **in, stream **out, const char *name)
{
	stream *sin, *sout;
	int pipes[2];

	if ((sin = create_stream(name)) == NULL)
		return 0;
	if ((sout = create_stream(name)) == NULL) {
		destroy(sin);
		return 0;
	}
	if (pipe(pipes) != 0) {
		destroy(sin);
		destroy(sout);
		return 0;
	}
	sin->access = ST_READ;
	sin->close = pipe_close;
	sin->read = pipe_read;
	sin->stream_data.i = pipes[0];
	sin->type = ST_BIN;
	sout->access = ST_WRITE;
	sout->close = pipe_close;
	sout->stream_data.i = pipes[1];
	sout->type = ST_BIN;
	sout->write = pipe_write;
	*in = sin;
	*out = sout;
	return 1;
}
#else
int
rendezvous_streams(stream **in, stream **out, const char *name)
{
	(void) in;
	(void) out;
	(void) name;
	return 0;
}
#endif /* HAVE_PIPE */
