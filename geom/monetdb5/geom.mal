# The contents of this file are subject to the MonetDB Public License
# Version 1.1 (the "License"); you may not use this file except in
# compliance with the License. You may obtain a copy of the License at
# http://www.monetdb.org/Legal/MonetDBLicense
#
# Software distributed under the License is distributed on an "AS IS"
# basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
# License for the specific language governing rights and limitations
# under the License.
#
# The Original Code is the MonetDB Database System.
#
# The Initial Developer of the Original Code is CWI.
# Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
# Copyright August 2008-2014 MonetDB B.V.
# All Rights Reserved.

module geom;

# @' overwrite lng needed for fixed size! Sizes are fixed in geom.prelude
atom mbr:lng;

command tostr() :str		address mbrTOSTR;
command fromstr() :mbr		address mbrFROMSTR;
command hash() :int		address mbrHASH;
command null() :int		address mbrNULL;
command cmp() :int		address mbrCOMP;
command read()			address mbrREAD;
command write()			address mbrWRITE;

#command mbr(v:str) :mbr address mbrFromString;

atom wkb;

command tostr() :str		address wkbTOSTR;
command fromstr() :wkb		address wkbFROMSTR;
command hash() :int		address wkbHASH;
command null() :int		address wkbNULL;
command cmp() :int		address wkbCOMP;
command read()			address wkbREAD;
command write()			address wkbWRITE;
command put() :int		address wkbPUT;
command del() :int		address wkbDEL;
command length() :int		address wkbLENGTH;
command heap() :int		address wkbHEAP;

#command wkb{unsafe}(v:str) :wkb address wkbFromString;
command FromText{unsafe}(wkt:str, srid:int, type:int) :wkb	address wkbFromText;
command ToText(w:wkb, withSRID:int) :str address wkbAsText;

module geom;

command hasZ{unsafe}(flags:int) :int address geoHasZ
comment "returns 1 if the geometry has z coordinate";
command hasM{unsafe}(flags:int) :int address geoHasM
comment "returns 1 if the geometry has m coordinate";
command getType{unsafe}(flags:int, format:int) :str address geoGetType
comment "returns the str representation of the geometry type";


command GeometryType{unsafe}(w:wkb, flag:int) :str address wkbGeometryType;
command NumRings{unsafe}(w:wkb, exterior:int) :int address wkbNumRings
comment "Returns the number of interior rings+exterior on the first polygon of the geometry";
#command MLineStringToPolygon{unsafe}(wkt:str, srid:int, flag:int) :wkb address wkbMLineStringToPolygon
#comment "Creates polygons using the MultiLineString provided as WKT. Depending on the flag creates one (flag=0) or multiple (flag=1) polygons"; 


#Geometry Constructors
command AsBinary(w:wkb) :str address wkbAsBinary
comment "Returns the wkb representation into HEX format";
command FromBinary(w:str) :wkb address wkbFromBinary
comment "Creates a wkb using the HEX representation";

#command AsText(w:wkb) :str address wkbAsText
#comment "Creates the text representation of the Geometry.";
#command AsEWKT(w:wkb) :str address wkbAsEWKT
#comment "Returns the text representation of the geometry including the srid";

function AsText(w:wkb) :str;
	x := wkb.ToText(w,0);
	return x;
end AsText;
function AsEWKT(w:wkb) :str;
	x := wkb.ToText(w,1);
	return x;
end AsEWKT;


function GeomFromText{unsafe}(wkt:str, srid:int) :wkb; 
	x := wkb.FromText(wkt,srid,0);
	return x;
end GeomFromText;
function PointFromText{unsafe}(wkt:str, srid:int) :wkb; 
	x := wkb.FromText(wkt,srid,1);
	return x;
end PointFromText;
function LineFromText{unsafe}(wkt:str, srid:int) :wkb;
	x := wkb.FromText(wkt,srid,2);
	return x;
end LineFromText;
function PolygonFromText{unsafe}(wkt:str, srid:int) :wkb;
	x := wkb.FromText(wkt,srid,4);
	return x;
end PolygonFromText;
function MPointFromText{unsafe}(wkt:str, srid:int) :wkb;
	x := wkb.FromText(wkt,srid,5);
	return x;
end MPointFromText;
function MLineFromText{unsafe}(wkt:str, srid:int) :wkb;
	x := wkb.FromText(wkt,srid,6);
	return x;
end MLineFromText;
function MPolyFromText{unsafe}(wkt:str, srid:int) :wkb;
	x := wkb.FromText(wkt,srid,7);
	return x;
end MPolyFromText;
function GeomCollFromText{unsafe}(wkt:str, srid:int) :wkb;
	x := wkb.FromText(wkt,srid,8);
	return x;
end GeomCollFromText;

function GeomFromText{unsafe}(wkt:str) :wkb; 
	x := wkb.FromText(wkt,0,0);
	return x;
end GeomFromText;
function PointFromText{unsafe}(wkt:str) :wkb; 
	x := wkb.FromText(wkt,0,1);
	return x;
end PointFromText;
function LineFromText{unsafe}(wkt:str) :wkb;
	x := wkb.FromText(wkt,0,2);
	return x;
end LineFromText;
function PolygonFromText{unsafe}(wkt:str) :wkb;
	x := wkb.FromText(wkt,0,4);
	return x;
end PolygonFromText;
function MPointFromText{unsafe}(wkt:str) :wkb;
	x := wkb.FromText(wkt,0,5);
	return x;
end MPointFromText;
function MLineFromText{unsafe}(wkt:str) :wkb;
	x := wkb.FromText(wkt,0,6);
	return x;
end MLineFromText;
function MPolyFromText{unsafe}(wkt:str) :wkb;
	x := wkb.FromText(wkt,0,7);
	return x;
end MPolyFromText;
function GeomCollFromText{unsafe}(wkt:str) :wkb;
	x := wkb.FromText(wkt,0,8);
	return x;
end GeomCollFromText;

#function GeomFromWKB{unsafe}(wkb_raw:????, srid:int) : wkb;
#	x := wkb.FromWKB(wkb_raw, srid, 0);
#	return x;
#end GeomFromWKB;


function NumInteriorRings{unsafe}(w:wkb) :int;
	x := NumRings(w, 0);
	return x;
end NumInteriorRings
function NRings{unsafe}(w:wkb) :int;
	x := NumRings(w, 1);
	return x;
end NRings;

#function BdPolyFromText{unsafe}(wkt:str, srid:int) :wkb;
#	x := MLineStringToPolygon(wkt,srid,0);
#	return x;
#end BdPolyFromText;
#function BdMPolyFromText{unsafe}(wkt:str, srid:int) :wkb;
#	x := MLineStringToPolygon(wkt,srid,1);
#	return x;
#end BdMPolyFromText;

command MakePoint{unsafe}(x:dbl, y:dbl) :wkb address geomMakePoint2D
comment "creates a point using the coordinates";
command MakePoint{unsafe}(x:dbl, y:dbl, z:dbl) :wkb address geomMakePoint3D
comment "creates a point using the coordinates";
#Gives error. I do not know how to create 4d point
command MakePoint{unsafe}(x:dbl, y:dbl, z:dbl, m:dbl) :wkb address geomMakePoint4D
comment "creates a point using the coordinates";
command MakePointM{unsafe}(x:dbl, y:dbl, m:dbl) :wkb address geomMakePointM
comment "creates a point using the coordinates";

#Geometry Accessors
function GeometryType1{unsafe}(w:wkb) :str;
	x := GeometryType(w, 0);
	return x;
end GeometryType1;
function GeometryType2{unsafe}(w:wkb) :str;
	x := GeometryType(w, 1);
	return x;
end GeometryType2;

command Boundary(w:wkb) :wkb address wkbBoundary
comment "Returns the closure of the combinatorial boundary of the Geometry.";
command CoordDim(w:wkb) :int address wkbCoordDim
comment " Return the coordinate dimension of the geometry";
command Dimension(w:wkb) :int address wkbDimension
comment "The inherent dimension of this Geometry object, which must be less than or equal to the coordinate dimension.";
command getSRID(w:wkb) :int address wkbGetSRID
comment "Returns the Spatial Reference System ID for this Geometry.";
command setSRID(w:wkb, srid:int) :wkb address wkbSetSRID
comment "Sets the Reference System ID for this Geometry.";
command X(g:wkb) :dbl address wkbGetCoordX
comment  "Return the X coordinate of the point, or NULL if not available. Input must be a point.";
command Y(g:wkb) :dbl address wkbGetCoordY
comment "Return the Y coordinate of the point, or NULL if not available. Input must be a point.";
command Z(g:wkb) :dbl address wkbGetCoordZ
comment "Return the Z coordinate of the point, or NULL if not available. Input must be a point.";
command StartPoint(w:wkb) :wkb address wkbStartPoint
comment "Returns the first point of a LINESTRING geometry as a POINT or NULL if the input parameter is not a LINESTRING";
command EndPoint(w:wkb) :wkb address wkbEndPoint
comment "Returns the last point of a LINESTRING geometry as a POINT or NULL if the input parameter is not a LINESTRING.";
command NumPoints(w:wkb) :int address wkbNumPoints
comment "The number of points in the Geometry. The geometry should be a linestring";
command PointN(w:wkb, n:int) :wkb address wkbPointN
comment "Returns the n-th point of the Geometry. Argument w should be Linestring.";
command Envelope(w:wkb) :wkb address wkbEnvelope
comment "The minimum bounding box for this Geometry, returned as a Geometry. The polygon is defined by the corner points of the bounding box ((MINX,MINY),(MAXX,MINY),(MAXX,MAXY),(MINX,MAXY)).";
command EnvelopeFromCoordinates(:dbl, :dbl, :dbl, :dbl, :int) :wkb address wkbEnvelopeFromCoordinates
comment "A polygon created by the provided coordinates";
command Polygon(:wkb, :bat[:oid,:wkb], :int) :wkb address wkbMakePolygon
comment "Returns a Polygon created from the provided LineStrings";
command ExteriorRing(w:wkb) :wkb address wkbExteriorRing
comment "Returns a line string representing the exterior ring of the POLYGON geometry. Return NULL if the geometry is not a polygon.";
command InteriorRingN(w:wkb, n:int) :wkb address wkbInteriorRingN
comment "Return the Nth interior linestring ring of the polygon geometry. Return NULL if the geometry is not a polygon or the given N is out of range.";
command IsClosed(w:wkb) :bit address wkbIsClosed
comment "Returns TRUE if the LINESTRING's start and end points are coincident.";
command IsEmpty(w:wkb) :bit address wkbIsEmpty
comment "Returns true if this Geometry is an empty geometry.";
command IsRing(w:wkb) :bit address wkbIsRing
comment "Returns TRUE if this LINESTRING is both closed and simple.";
command IsSimple(w:wkb) :bit address wkbIsSimple
comment "Returns (TRUE) if this Geometry has no anomalous geometric points, such as self intersection or self tangency.";
command IsValid(w:wkb) :bit address wkbIsValid
comment "Returns true if the ST_Geometry is well formed.";
command IsValidReason(w:wkb) :str address wkbIsValidReason
comment "Returns text stating if a geometry is valid or not and if not valid, a reason why.";
command IsValidDetail(w:wkb) :str address wkbIsValidDetail
comment "Returns a valid_detail (valid,reason,location) row stating if a geometry is valid or not and if not valid, a reason why and a location where.";
command Area(w:wkb) :dbl address wkbArea
comment "Returns the area of the surface if it is a polygon or multi-polygon";
command Centroid(w:wkb) :wkb address wkbCentroid
comment "Computes the geometric center of a geometry, or equivalently, the center of mass of the geometry as a POINT.";
command Distance(a:wkb, b:wkb) :dbl address wkbDistance
comment "Returns the 2-dimensional minimum cartesian distance between the two geometries in projected units (spatial ref units.";
command Length(w:wkb) :dbl address wkbLength
comment "Returns the cartesian 2D length of the geometry if it is a linestrin or multilinestring";
command ConvexHull(w:wkb) :wkb address wkbConvexHull
comment "Returns a geometry that represents the convex hull of this geometry. The convex hull of a geometry represents the minimum convex geometry that encloses all geometries within the set.";
command Intersection(a:wkb, b:wkb) :wkb address wkbIntersection
comment "Returns a geometry that represents the point set intersection of the Geometries a, b";
command Union(a:wkb, b:wkb) :wkb address wkbUnion
comment "Returns a geometry that represents the point set union of the Geometries a, b";
command Difference(a:wkb, b:wkb) :wkb address wkbDifference
comment "Returns a geometry that represents that part of geometry A that does not intersect with geometry B";
command SymDifference(a:wkb, b:wkb) :wkb address wkbSymDifference
comment "Returns a geometry that represents the portions of A and B that do not intersect";
command Buffer(a:wkb, distance:dbl) :wkb address wkbBuffer
comment "Returns a geometry that represents all points whose distance from this geometry is less than or equal to distance. Calculations are in the Spatial Reference System of this Geometry.";
command Contains(a:wkb, b:wkb) :bit address wkbContains
comment "Returns true if and only if no points of B lie in the exterior of A, and at least one point of the interior of B lies in the interior of A.";
command Crosses(a:wkb, b:wkb) :bit address wkbCrosses
comment "Returns TRUE if the supplied geometries have some, but not all, interior points in common.";
command Disjoint(a:wkb, b:wkb) :bit address wkbDisjoint
comment "Returns true if these Geometries are 'spatially disjoint'";
command Equals(a:wkb, b:wkb) :bit address wkbEquals
comment "Returns true if the given geometries represent the same geometry. Directionality is ignored.";
command Intersects(a:wkb, b:wkb) :bit address wkbIntersects
comment "Returns true if these Geometries 'spatially intersect in 2D'";
command Overlaps(a:wkb, b:wkb) :bit address wkbOverlaps
comment " Returns TRUE if the Geometries intersect but are not completely contained by each other.";
command Relate(a:wkb, b:wkb, intersection_matrix_pattern:str) :bit address wkbRelate
comment "Returns true if the Geometry a 'spatially related' to Geometry b, by testing for intersection between the Interior, Boundary and Exterior of the two geometries as specified by the values in the intersectionPatternMatrix.";
command Touches(a:wkb, b:wkb) :bit address wkbTouches
comment "Returns TRUE if the geometries have at least one point in common, but their interiors do not intersect.";
command Within(a:wkb, b:wkb) :bit address wkbWithin
comment "Returns TRUE if the geometry A is completely inside geometry B";
command Covers(a:wkb, b:wkb) :bit address wkbCovers
comment "Returns TRUE if no point of geometry B is outside geometry A";
command CoveredBy(a:wkb, b:wkb) :bit address wkbCoveredBy
comment "Returns TRUE if no point of geometry A is outside geometry B";
command GeometryN(g:wkb, n:int) :wkb address wkbGeometryN
comment "Returns the 1-based Nth geometry if the geometry is a GEOMETRYCOLLECTION, (MULTI)POINT, (MULTI)LINESTRING, MULTICURVE or (MULTI)POLYGON. Otherwise, return NULL";
command NumGeometries(g:wkb) :int address wkbNumGeometries
comment "Returns the number of geometries";

command Transform(g:wkb, srid_src:int, srid_dst:int, proj_src:str, proj_dest:str) :wkb address wkbTransform
comment "Transforms a geometry from one srid to another";

function MakeEnvelope(xmin:dbl, ymin:dbl, xmax:dbl, ymax:dbl, srid:int) :wkb;
	x := EnvelopeFromCoordinates(xmin, ymin, xmax, ymax, srid);
	return x;
end MakeEnvelope;

function MakeEnvelope(xmin:dbl, ymin:dbl, xmax:dbl, ymax:dbl) :wkb;
	x := EnvelopeFromCoordinates(xmin, ymin, xmax, ymax, 0);
	return x;
end MakeEnvelope;

function MakePolygon(external:wkb) :wkb;
	x := Polygon(external, nil:bat, 0);
	return x;
end MakePolygon;
function MakePolygon(external:wkb, srid:int) :wkb;
	x := Polygon(external, nil:bat, srid);
	return x;
end MakePolygon;
#function MakePolygon(external:wkb, internal:bat[:oid,:wkb]) :wkb;
#	x := Polygon(external, internal, 0);
#	return x;
#end MakePolygon;

command mbr(:wkb) :mbr address wkbMBR
comment "Creates the mbr for the given wkb.";
command MakeBox2D(:wkb,:wkb) :mbr address wkbBox2D
comment "Creates an mbr from the two 2D points";

command mbrOverlaps(geom1:wkb, geom2:wkb) :bit address mbrOverlaps_wkb
comment "Returns true if the mbr of geom1 overlaps the mbr of geom2";
command mbrOverlaps(box1:mbr, box2:mbr) :bit address mbrOverlaps
comment "Returns true if box1 overlaps box2";
command mbrOverlapOrLeft(geom1:wkb, geom2:wkb) :bit address mbrOverlapOrLeft_wkb
comment "Returns true if the mbr of geom1 overlaps or is to the left of thr mbr of geom2";
command mbrOverlapOrLeft(box1:mbr, box2:mbr) :bit address mbrOverlapOrLeft
comment "Returns true if box1 overlaps or is to the left of box2";
command mbrOverlapOrBelow(geom1:wkb, geom2:wkb) :bit address mbrOverlapOrBelow_wkb
comment "Returns true if the mbr of geom1 overlaps or is below the mbr of geom2";
command mbrOverlapOrBelow(box1:mbr, box2:mbr) :bit address mbrOverlapOrBelow
comment "Returns true if box1 overlaps or is below box2";
command mbrOverlapOrRight(geom1:wkb, geom2:wkb) :bit address mbrOverlapOrRight_wkb
comment "Returns true if the mbr of geom1 overlalps or is right of the mbr of geom2";
command mbrOverlapOrRight(box1:mbr, box2:mbr) :bit address mbrOverlapOrRight
comment "Returns true if box1 overlalps or is right of box2";
command mbrLeft(geom1:wkb, geom2:wkb) :bit address mbrLeft_wkb
comment "Returns true if the mbr of geom1 is left of the mbr of geom2";
command mbrLeft(box1:mbr, box2:mbr) :bit address mbrLeft
comment "Returns true if box1 is left of box2";
command mbrBelow(geom1:wkb, geom2:wkb) :bit address mbrBelow_wkb
comment "Returns true if the mbr of geom1 is below the mbr of geom2";
command mbrBelow(box1:mbr, box2:mbr) :bit address mbrBelow
comment "Returns true if box1 is below box2";
command mbrEqual(geom1:wkb, geom2:wkb) :bit address mbrEqual_wkb
comment "Returns true if the mbr of geom1 is the same as the mbr of geom2";
command mbrEqual(box1:mbr, box2:mbr) :bit address mbrEqual
comment "Returns true if box1 is the same as box2";
command mbrRight(geom1:wkb, geom2:wkb) :bit address mbrRight_wkb
comment "Returns true if the mbr of geom1 is right of the mbr of geom2";
command mbrRight(box1:mbr, box2:mbr) :bit address mbrRight
comment "Returns true if box1 is right of box2";
command mbrContained(geom1:wkb, geom2:wkb) :bit address mbrContained_wkb
comment "Returns true if the mbr of geom1 is contained by the mbr of geom2";
command mbrContained(box1:mbr, box2:mbr) :bit address mbrContained
comment "Returns true if box1 is contained by box2";
command mbrOverlapOrAbove(geom1:wkb, geom2:wkb) :bit address mbrOverlapOrAbove_wkb
comment "Returns true if the mbr of geom1 overlaps or is above the mbr of geom2";
command mbrOverlapOrAbove(box1:mbr, box2:mbr) :bit address mbrOverlapOrAbove
comment "Returns true if box1 overlaps or is above box2";
command mbrAbove(geom1:wkb, geom2:wkb) :bit address mbrAbove_wkb
comment "Returns true if the mbr of geom1 is above the mbr of geom2";
command mbrAbove(box1:mbr, box2:mbr) :bit address mbrAbove
comment "Returns true if box1 is above box2";
command mbrContains(geom1:wkb, geom2:wkb) :bit address mbrContains_wkb
comment "Returns true if the mbr of geom1 contains the mbr of geom2";
command mbrContains(box1:mbr, box2:mbr) :bit address mbrContains
comment "Returns true if box1 contains box2";
command mbrDistance(geom1:wkb, geom2:wkb) :dbl address mbrDistance_wkb
comment "Returns the distance of the centroids of the mbrs of the two geometries";
command mbrDistance(box1:mbr, box2:mbr) :dbl address mbrDistance
comment "Returns the distance of the centroids of the two boxes";
command coordinateFromWKB(:wkb, :int) :dbl address wkbCoordinateFromWKB
comment "returns xmin (=1), ymin (=2), xmax (=3) or ymax(=4) of the provided geometry";
command coordinateFromMBR(:mbr, :int) :dbl address wkbCoordinateFromMBR
comment "returns xmin (=1), ymin (=2), xmax (=3) or ymax(=4) of the provided mbr";

function XMinFromWKB(g:wkb) :dbl;
	x := coordinateFromWKB(g, 1);
	return x;
end XMinFromWKB;
function YMinFromWKB(g:wkb) :dbl;
	x := coordinateFromWKB(g, 2);
	return x;
end YMinFromWKB;
function XMaxFromWKB(g:wkb) :dbl;
	x := coordinateFromWKB(g, 3);
	return x;
end XMaxFromWKB;
function YMaxFromWKB(g:wkb) :dbl;
	x := coordinateFromWKB(g, 4);
	return x;
end YMaxFromWKB;
function XMinFromMBR(b:mbr) :dbl;
	x := coordinateFromMBR(b, 1);
	return x;
end XMinFromMBR;
function YMinFromMBR(b:mbr) :dbl;
	x := coordinateFromMBR(b, 2);
	return x;
end YMinFromMBR;
function XMaxFromMBR(b:mbr) :dbl;
	x := coordinateFromMBR(b, 3);
	return x;
end XMaxFromMBR;
function YMaxFromMBR(b:mbr) :dbl;
	x := coordinateFromMBR(b, 4);
	return x;
end YMaxFromMBR;


#command mbr(:flt,:flt,:flt,:flt) :mbr
#address ordinatesMBR
#comment "Creates the mbr for the given (xmin,ymin) and (xmax,ymax).";


command prelude():void	address geom_prelude;
command epilogue():void address geom_epilogue;

geom.prelude();

module batgeom;

command ContainsFilter{unsafe}(a:bat[:oid,:wkb], b:bat[:oid,:wkb]) (aFiltered:bat[:oid,:wkb], bFiltered:bat[:oid,:wkb]) address wkbContainsFilter_bat
comment "Filters the points in the bats according to the MBR of the other bat.";

#command point(x:bat[:oid,:dbl],y:bat[:oid,:dbl]) :bat[:oid,:wkb]
#address wkbcreatepoint_bat
#comment "Construct a point-BAT from two geometry-BATs";
command MakePoint{unsafe}(x:bat[:oid,:dbl], y:bat[:oid,:dbl]) :bat[:oid,:wkb] address geomMakePoint2D_bat
comment "creates a 2D points BAT using two double BATs";
command MakePoint{unsafe}(x:bat[:oid,:dbl], y:bat[:oid,:dbl], z:bat[:oid,:dbl]) :bat[:oid,:wkb] address geomMakePoint3D_bat
comment "creates a 3D points BAT using three double BATs";
#Gives error. I do not know how to create 4d point
command MakePoint{unsafe}(x:bat[:oid,:dbl], y:bat[:oid,:dbl], z:bat[:oid,:dbl], m:bat[:oid,:dbl]) :bat[:oid,:wkb] address geomMakePoint4D_bat
comment "creates a 4D points BAT using four double BATs";
command MakePointM{unsafe}(x:bat[:oid,:dbl], y:bat[:oid,:dbl], m:bat[:oid,:dbl]) :bat[:oid,:wkb] address geomMakePointM_bat
comment "creates a 2D with m attribute points BAT using three double BATs";
command setSRID(w:bat[:oid,:wkb], srid:int) :bat[:oid,:wkb] address wkbSetSRID_bat
comment "Sets the Reference System ID for this Geometry.";

#create one pattern for each possible combination of bat - scalar
#pattern Contains(a:wkb, b:bat[:oid,:wkb]) :bat[:oid,:bit] address wkbContains_bat;
#pattern Contains(a:bat[:oid,:wkb], b:wkb) :bat[:oid,:bit] address wkbContains_bat;
#pattern Contains(a:bat[:oid,:wkb], b:bat[:oid,:wkb]) :bat[:oid,:bit] address wkbContains_bat;
command Contains(a:bat[:oid,:wkb], b:bat[:oid,:wkb]) :bat[:oid,:bit] address wkbContains_bat_bat;


command mbr(:bat[:oid,:wkb]) :bat[:oid,:mbr] address wkbMBR_bat
comment "Creates the mbr for the given wkb.";

command coordinateFromWKB(:bat[:oid,:wkb], :int) :bat[:oid,:dbl] address wkbCoordinateFromWKB_bat
comment "returns xmin (=1), ymin (=2), xmax (=3) or ymax(=4) of the provided geometry";
command coordinateFromMBR(:bat[:oid,:mbr], :int) :bat[:oid,:dbl] address wkbCoordinateFromMBR_bat
comment "returns xmin (=1), ymin (=2), xmax (=3) or ymax(=4) of the provided mbr";

function XMinFromWKB(g:bat[:oid,:wkb]) :bat[:oid,:dbl];
	x := coordinateFromWKB(g, 1);
	return x;
end XMinFromWKB;
function YMinFromWKB(g:bat[:oid,:wkb]) :bat[:oid,:dbl];
	x := coordinateFromWKB(g, 2);
	return x;
end YMinFromWKB;
function XMaxFromWKB(g:bat[:oid,:wkb]) :bat[:oid,:dbl];
	x := coordinateFromWKB(g, 3);
	return x;
end XMaxFromWKB;
function YMaxFromWKB(g:bat[:oid,:wkb]) :bat[:oid,:dbl];
	x := coordinateFromWKB(g, 4);
	return x;
end YMaxFromWKB;
function XMinFromMBR(b:bat[:oid,:mbr]) :bat[:oid,:dbl];
	x := coordinateFromMBR(b, 1);
	return x;
end XMinFromMBR;
function YMinFromMBR(b:bat[:oid,:mbr]) :bat[:oid,:dbl];
	x := coordinateFromMBR(b, 2);
	return x;
end YMinFromMBR;
function XMaxFromMBR(b:bat[:oid,:mbr]) :bat[:oid,:dbl];
	x := coordinateFromMBR(b, 3);
	return x;
end XMaxFromMBR;
function YMaxFromMBR(b:bat[:oid,:mbr]) :bat[:oid,:dbl];
	x := coordinateFromMBR(b, 4);
	return x;
end YMaxFromMBR;



module calc;

#command mbr{unsafe}(v:str) :mbr address mbrFromString;
#It is needed to add a new mbr colum to an existing table
command mbr(v:mbr) :mbr address mbrFromMBR;
#command wkb{unsafe}(v:str) :wkb address wkbFromString;
command wkb(v:wkb) :wkb address wkbFromWKB
comment "It is called when adding a new geometry column to an existing table";
command wkb(geo:wkb, columnType:int, columnSRID:int) :wkb address geom_2_geom
comment "Called when inserting values to a table in order to check if the inserted geometries are of the same type and srid required by the column definition";

#module batcalc;

command batcalc.wkb(geo:bat[:oid,:wkb], columnType:int, columnSRID:int) :bat[:oid,:wkb] address geom_2_geom_bat
comment "Called when inserting values to a table in order to check if the inserted geometries are of the same type and srid required by the column definition";
#Is it needed ???
#command wkb(v:bat[:oid,:wkb]) :bat[:oid,:wkb] address wkbFromWKB_bat;
#comment "It is called when adding a new geometry column to an existing table";



#module geom;
command calc.isnil(v:wkb):bit
address wkbIsnil
comment "Nil test for wkb value";


# wkbPoint := 1;
# wkbLineString := 2;
# wkbPolygon := 3;
# wkbMultiPoint := 4;
# wkbMultiLineString := 5;
# wkbMultiPolygon := 6;
# wkbGeometryCollection := 7;

