@/
The contents of this file are subject to the MonetDB Public License
Version 1.1 (the "License"); you may not use this file except in
compliance with the License. You may obtain a copy of the License at
http://www.monetdb.org/Legal/MonetDBLicense

Software distributed under the License is distributed on an "AS IS"
basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations
under the License.

The Original Code is the MonetDB Database System.

The Initial Developer of the Original Code is CWI.
Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
Copyright August 2008-2011 MonetDB B.V.
All Rights Reserved.
@

@f geom

@c
/*
 * @a Wouter Scherphof, Niels Nes
 * @* The simple geom module
 */
@mal
module geom;

# @' overwrite lng needed for fixed size! Sizes are fixed in geom.prelude
atom mbr:lng;

command tostr() :str		address mbrTOSTR;
command fromstr() :mbr		address mbrFROMSTR;
command hash() :int		address mbrHASH;
command null() :int		address mbrNULL;
command cmp() :int		address mbrCOMP;
command read()			address mbrREAD;
command write()			address mbrWRITE;

command mbr(v:str) :mbr address mbrFromString;

atom wkb;

command tostr() :str		address wkbTOSTR;
command fromstr() :wkb		address wkbFROMSTR;
command hash() :int		address wkbHASH;
command null() :int		address wkbNULL;
command cmp() :int		address wkbCOMP;
command read()			address wkbREAD;
command write()			address wkbWRITE;

command put() :int		address wkbPUT;
command del() :int		address wkbDEL;
command length() :int		address wkbLENGTH;
command heap() :int		address wkbHEAP;

command wkb{unsafe}(v:str) :wkb address wkbFromString;
command FromText{unsafe}(w:str, type:int) :wkb	address wkbFromText;

module geom;

@= types
function @1FromText{unsafe}( wkt:str, srid:sht ) :wkb;
	x := wkb.FromText(wkt,@3);
	return x;
end @1FromText;

@
@mal
@:types(Point,point,1)@
@:types(Curve,curve,2)@
@:types(Line,linestring,2)@
@:types(Surface,surface,3)@
@:types(Poly,polygon,3)@
@:types(MultiPoint,multipoint,4)@
@:types(MultiCurve,multicurve,5)@
@:types(MultiLine,multilinestring,5)@
@:types(MultiSurface,multisurface,6)@
@:types(MultiPoly,multipolygon,6)@
@:types(Geom,geometry,7)@
@:types(GeomCollection,geomcollection,7)@

command mbroverlaps(a:mbr, b:mbr) :bit
address mbroverlaps
comment "Returns true if the two mbrs overlap";


command AsText(w:wkb) :str	address wkbAsText;
command mbr(:flt,:flt,:flt,:flt) :mbr
address ordinatesMBR
comment "Creates the mbr for the given (xmin,ymin) and (xmax,ymax).";

command mbr(:wkb) :mbr
address wkbMBR
comment "Creates the mbr for the given wkb.";

# @+
# command mbr(:bat[:any_1,:wkb]) :bat[:any_1,:mbr]
# address bat_wkbMBR
# comment "Creates the mbr's for the given wkb's.";
#
# @+ ogc basic methods
command Dimension(w:wkb) :int
address wkbDimension
comment "The inherent dimension of this geometry object, which must be less than or equal to the coordinate dimension. This specification is restricted to geometries in two-dimensional coordinate space.";

command GeometryTypeId(w:wkb) :int
address wkbGeometryTypeId
comment "Returns the name of the instantiable subtype of Geometry of which this Geometry instance is a member. The name of the instantiable subtype of Geometry is returned as string.";

command SRID(w:wkb) :int
address wkbSRID
comment "Returns the Spatial Reference System ID for this Geometry.";

command Envelope(w:wkb) :wkb
address wkbEnvelope
comment "The minimum bounding box for this Geometry, returned as a Geometry. The polygon is defined by the corner points of the bounding box ((MINX,MINY),(MAXX,MINY),(MAXX,MAXY),(MINX,MAXY)).";

command IsEmpty(w:wkb) :bit
address wkbIsEmpty
comment "Returns true if this Geometry is the empty geometry. If true, then this Geometry represents the empty point set, for the coordinate space.";

command IsSimple(w:wkb) :bit
address wkbIsSimple
comment "Returns true if this Geometry has no anomalous geometric points, such as self intersection or self tangency. The description of each instantiable geometric class will include the specific conditions that cause an instance of that class to be classified as not simple.";

command Boundary(w:wkb) :wkb
address wkbBoundary
comment "Returns the closure of the combinatorial boundary of this Geometry.";

# @+ ogc spatial relation methods

command Equals(a:wkb, b:wkb) :bit
address wkbEquals
comment "Returns true if these Geometries are 'spatially equal'";

command Disjoint(a:wkb, b:wkb) :bit
address wkbDisjoint
comment "Returns true if these Geometries are 'spatially disjoint'";

command Intersect(a:wkb, b:wkb) :bit
address wkbIntersect
comment "Returns true if these Geometries 'spatially intersect'";

command Touches(a:wkb, b:wkb) :bit
address wkbTouches
comment "Returns true if these Geometries 'spatially touch' each other";

command Crosses(a:wkb, b:wkb) :bit
address wkbCrosses
comment "Returns true if the Geometry a 'spatially crosses' Geometry b";

command Within(a:wkb, b:wkb) :bit
address wkbWithin
comment "Returns true if the Geometry a 'spatially within' Geometry b";

command Contains(a:wkb, b:wkb) :bit
address wkbContains
comment "Returns true if the Geometry a 'spatially contains' Geometry b";

command Overlaps(a:wkb, b:wkb) :bit
address wkbOverlaps
comment "Returns true if the Geometry a 'spatially overlaps' Geometry b";

command Relate(a:wkb, b:wkb, intersectionPatternMatrix:str) :bit
address wkbRelate
comment "Returns true if the Geometry a 'spatially related' to Geometry b, by testing for intersection between the Interior, Boundary and Exterior of the two geometries as specified by the values in the intersectionPatternMatrix.";

# @+ ogc constructor functions
command point(x:dbl,y:dbl) :wkb
address wkbcreatepoint
comment "Construct a point from two geometries";

module batgeom;
command point(x:bat[:oid,:dbl],y:bat[:oid,:dbl]) :bat[:oid,:wkb]
address wkbcreatepoint_bat
comment "Construct a point-BAT from two geometry-BATs";
module geom;

# @+ ogc information methods
command X(g:wkb) :dbl
address wkbgetcoordX
comment "Returns the x-coordinate of a point geometry.";

command Y(g:wkb) :dbl
address wkbgetcoordY
comment "Returns the y-coordinate of a point geometry.";

# @+ ogc Spatial Analysis methods

command Area(g:wkb) :dbl
address wkbArea
comment "Returns the area of the geometry.";

command Length(g:wkb) :dbl
address wkbLength
comment "Returns the length of the geometry.";

command Distance(a:wkb, b:wkb) :dbl
address wkbDistance
comment "Returns the shortest distance between any two points in the two geometries as calculated in the spatial reference system of this Geometries.";

command Buffer(a:wkb, distance:dbl) :wkb
address wkbBuffer
comment "Returns a geometry that represents all points whose distance from this geometry is less than or equal to distance. Calculations are in the Spatial Reference System of this Geometry.";

command ConvexHull(a:wkb) :wkb
address wkbConvexHull
comment "Returns a geometry that represents the convex hull of this geometry.";

command Intersection(a:wkb, b:wkb) :wkb
address wkbIntersection
comment "Returns a geometry that represents the point set intersection of Geometry a with b.";

command Union(a:wkb, b:wkb) :wkb
address wkbUnion
comment "Returns a geometry that represents the point set union of Geometry a with b.";

command Difference(a:wkb, b:wkb) :wkb
address wkbDifference
comment "Returns a geometry that represents the point set difference of Geometry a with b.";

command SymDifference(a:wkb, b:wkb) :wkb
address wkbSymDifference
comment "Returns a geometry that represents the point set semmetric difference of Geometry a with b.";


command prelude():void	address geom_prelude;
command epilogue():void address geom_epilogue;

geom.prelude();

module calc;

command mbr{unsafe}(v:str) :mbr address mbrFromString;
command mbr(v:mbr) :mbr address mbrFromMBR;
command wkb{unsafe}(v:str) :wkb address wkbFromString;
command wkb(v:wkb) :wkb address wkbFromWKB;

@= ctypes
function @2{unsafe}( wkt:str ) :wkb;
	x := wkb.FromText(wkt,@3);
	return x;
end @2;
@
@mal
@:ctypes(Point,point,1)@
@:ctypes(Curve,curve,2)@
@:ctypes(Line,linestring,2)@
@:ctypes(Surface,surface,3)@
@:ctypes(Poly,polygon,3)@
@:ctypes(MultiPoint,multipoint,4)@
@:ctypes(MultiCurve,multicurve,5)@
@:ctypes(MultiLine,multilinestring,5)@
@:ctypes(MultiSurface,multisurface,6)@
@:ctypes(MultiPoly,multipolygon,6)@
@:ctypes(Geom,geometry,7)@
@:ctypes(GeomCollection,geometrycollection,7)@

module geom;
command calc.isnil(v:wkb):bit
address wkbIsnil
comment "Nil test for wkb value";

@c

#include <monetdb_config.h>
#include <mal.h>
#include <mal_atom.h>
#include <mal_exception.h>
#include "libgeom.h"

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <time.h>

#ifdef WIN32
#ifndef LIBGEOM
#define geom_export extern __declspec(dllimport)
#else
#define geom_export extern __declspec(dllexport)
#endif
#else
#define geom_export extern
#endif

int TYPE_mbr;

geom_export wkb *wkbNULL(void);

geom_export bat *geom_prelude(void);

bat *
geom_prelude(void)
{
	libgeom_init();
	TYPE_mbr = malAtomSize(sizeof(mbr), sizeof(oid), "mbr");
	return NULL;
}

geom_export void geom_epilogue(void);

void
geom_epilogue(void)
{
	libgeom_exit();
}

/*
 * Implementation of fixed-sized atom mbr.
 */
static int
mbr_isnil(mbr *m)
{
	if (!m || m->xmin == flt_nil || m->ymin == flt_nil ||
	    m->xmax == flt_nil || m->ymax == flt_nil)
		return 1;
	return 0;
}

/* NULL: generic nil mbr. */
/* returns a pointer to a nil-mbr. */
geom_export mbr *mbrNULL(void);

mbr *
mbrNULL(void)
{
	static mbr mbrNIL;
	mbrNIL.xmin = flt_nil;
	mbrNIL.ymin = flt_nil;
	mbrNIL.xmax = flt_nil;
	mbrNIL.ymax = flt_nil;
	return (&mbrNIL);
}

/* FROMSTR: parse string to mbr. */
/* return number of parsed characters. */
geom_export int mbrFROMSTR(char *src, int *len, mbr **atom);

int
mbrFROMSTR(char *src,		/* IN: to-be-parsed string. */
	   int *len,		/* INOUT: length of area pointed to by atom [may need enlarging!] */
	   mbr **atom		/* INOUT: ptr to atom-ptr [may need (re-)alloc!] */
    )
{
	int nil = 0;
	int nchars = 0;		/* The number of characters parsed; the return value. */
	GEOSGeom geosMbr = NULL;	/* The geometry object that is parsed from the src string. */

	if (strcmp(src, str_nil) == 0)
		nil = 1;

	if (!nil && (geosMbr = GEOSGeomFromWKT(src)) == NULL)
		return 0;

	if (*len < (int) sizeof(mbr)) {
		if (*atom)
			GDKfree(*atom);
		*atom = GDKmalloc(*len = sizeof(mbr));
	}
	if (nil) {
		nchars = 3;
		**atom = *mbrNULL();
	} else if (getMbrGeos(*atom, geosMbr)) {
		size_t l = strlen(src);
		assert(l <= GDK_int_max);
		nchars = (int) l;
	}
	if (geosMbr)
		GEOSGeom_destroy(geosMbr);
	return nchars;
}

#define MBR_WKTLEN 256

/* TOSTR: print atom in a string. */
/* return length of resulting string. */
geom_export int mbrTOSTR(char **dst, int *len, mbr *atom);

int
mbrTOSTR(char **dst,		/* INOUT: dst charbuffer [maybe 0, may need realloc] */
	 int *len,		/* INOUT: length of buffer */
	 mbr *atom		/* IN: to-be-printed mbr. */
    )
{
	static char tempWkt[MBR_WKTLEN];
	size_t dstStrLen = 3;

	if (!mbr_isnil(atom)) {
		snprintf(tempWkt, MBR_WKTLEN, "BOX (%f %f, %f %f)", atom->xmin, atom->ymin, atom->xmax, atom->ymax);
		dstStrLen = strlen(tempWkt) + 2;
		assert(dstStrLen < GDK_int_max);
	}

	if (*len < (int) dstStrLen + 1) {
		if (*dst)
			GDKfree(*dst);
		*dst = GDKmalloc(*len = (int) dstStrLen + 1);
	}

	if (dstStrLen > 3)
		snprintf(*dst, *len, "\"%s\"", tempWkt);
	else
		strcpy(*dst, "nil");
	return (int) dstStrLen;
}

/* HASH: compute a hash value. */
/* returns a positive integer hash value */
geom_export BUN mbrHASH(mbr *atom);

BUN
mbrHASH(mbr *atom		/* IN: to-be-hashed mbr. */
    )
{
	return (BUN) (((int) atom->xmin * (int) atom->ymin) *
		      ((int) atom->xmax * (int) atom->ymax));
}

/* COMP: compare two mbrs. */
/* returns int <0 if l<r, 0 if l==r, >0 else */
geom_export int mbrCOMP(mbr *l, mbr *r);

int
mbrCOMP(mbr *l,			/* IN: first geom_point. */
	mbr *r			/* IN: second geom_point. */
    )
{
	/* simple lexicographical ordering on (x,y) */
	int res;
	if (l->xmin == r->xmin)
		res = (l->ymin < r->ymin) ? -1 : (l->ymin == r->ymin) ? 0 : 1;
	else
		res = (l->xmin < r->xmin) ? -1 : 1;
	if (res == 0) {
		if (l->xmax == r->xmax)
			res = (l->ymax < r->ymax) ? -1 : (l->ymax == r->ymax) ? 0 : 1;
		else
			res = (l->xmax < r->xmax) ? -1 : 1;
	}
	return res;
}

geom_export mbr *mbrREAD(mbr *a, stream *s, size_t cnt);

mbr *
mbrREAD(mbr *a, stream *s, size_t cnt)
{
	mbr *c;
	size_t i;
	int xmin, ymin, xmax, ymax;

	for (i = 0, c = a; i < cnt; i++, c++) {
		if (!mnstr_readInt(s, &xmin) ||
		    !mnstr_readInt(s, &ymin) ||
		    !mnstr_readInt(s, &xmax) ||
		    !mnstr_readInt(s, &ymax))
			return NULL;
		c->xmin = (flt) xmin;
		c->ymin = (flt) ymin;
		c->xmax = (flt) xmax;
		c->ymax = (flt) ymax;
	}
	return a;
}

geom_export int mbrWRITE(mbr *c, stream *s, size_t cnt);

int
mbrWRITE(mbr *c, stream *s, size_t cnt)
{
	size_t i;

	for (i = 0; i < cnt; i++, c++) {
		/* use binary writeInt (as sizeof (flt) == sizeof(int)); */
		/* We want to write nil's here too.
		   So no overflow checking needed */
		if (!mnstr_writeInt(s, (int) c->xmin) ||
		    !mnstr_writeInt(s, (int) c->ymin) ||
		    !mnstr_writeInt(s, (int) c->xmax) ||
		    !mnstr_writeInt(s, (int) c->ymax))
			return GDK_FAIL;
	}
	return GDK_SUCCEED;
}

geom_export str mbrFromString(mbr **w, str *src);

str
mbrFromString(mbr **w, str *src)
{
	int len = 0;
	char *errbuf;

	if (mbrFROMSTR(*src, &len, w))
		return MAL_SUCCEED;
	errbuf = GDKerrbuf;
	if (errbuf) {
		if (strncmp(errbuf, "!ERROR: ", 8) == 0)
			errbuf += 8;
		errbuf = strcpy(alloca(strlen(errbuf) + 1), errbuf);
		GDKerrbuf[0] = 0;
	}
	throw(MAL, "mbr.FromString", "%s", errbuf ? errbuf : "cannot parse string");
}

geom_export str mbrFromMBR(mbr **w, mbr **src);

str
mbrFromMBR(mbr **w, mbr **src)
{
	*w = (mbr *) GDKmalloc(sizeof(mbr));

	**w = **src;
	return MAL_SUCCEED;
}

/*
 * Implementation of variable-sized atom wkb.
 */

static var_t
wkb_size(size_t len)
{
	if (len == ~(size_t) 0)
		len = 0;
	assert(sizeof(wkb) - 1 + len <= VAR_MAX);
	return (var_t) (sizeof(wkb) - 1 + len);
}

/* TOSTR: print atom in a string. */
/* return length of resulting string. */
geom_export int wkbTOSTR(char **dst, int *len, wkb *atom);

int
wkbTOSTR(char **dst,		/* INOUT: dst charbuffer [maybe 0, may need realloc] */
	 int *len,		/* INOUT: length of buffer */
	 wkb *atom		/* IN: to-be-printed geom_geometry. */
    )
{
	char *wkt = NULL;
	int dstStrLen = 3;	/* "nil" */
	GEOSGeom geosGeometry = wkb2geos(atom);

	if (geosGeometry) {
		size_t l;
		wkt = GEOSGeomToWKT(geosGeometry);
		l = strlen(wkt);
		assert(l < GDK_int_max);
		dstStrLen = (int) l + 2;	/* add quotes */
		GEOSGeom_destroy(geosGeometry);
	}

	if (*len < dstStrLen + 1) {	/* + 1 for the '\0' */
		if (*dst)
			GDKfree(*dst);
		*dst = GDKmalloc(*len = dstStrLen + 1);
	}

	if (wkt) {
		snprintf(*dst, *len, "\"%s\"", wkt);
		free(wkt);
	} else {
		strcpy(*dst, "nil");
	}

	return dstStrLen;
}

/* FROMSTR: parse string to @1. */
/* return number of parsed characters. */
geom_export int wkbFROMSTR(char *src, int *len, wkb **atom);

int
wkbFROMSTR(char *src,		/* IN: to-be-parsed string. */
	   int *len,		/* INOUT: length of area pointed to by atom [may need enlarging!] */
	   wkb **atom		/* INOUT: ptr to atom-ptr [may need (re-)alloc!] */
    )
{
	GEOSGeom geosGeometry = NULL;	/* The geometry object that is parsed from the src string. */
	unsigned char *wkbSer = NULL;	/* The "well known binary" serialization of the geometry object. */
	size_t wkbLen = 0;	/* The length of the wkbSer string. */
	int nil = 0;

	if (strcmp(src, str_nil) == 0)
		nil = 1;

	if (!nil && (geosGeometry = GEOSGeomFromWKT(src)) == NULL) {
		goto return_nil;
	}

	if (!nil && GEOSGeomTypeId(geosGeometry) == -1) {
		GEOSGeom_destroy(geosGeometry);
		goto return_nil;
	}

	if (!nil) {
		wkbSer = GEOSGeomToWKB_buf(geosGeometry, &wkbLen);
		GEOSGeom_destroy(geosGeometry);
	}
	if (*len < (int) wkb_size(wkbLen)) {
		if (*atom)
			GDKfree(*atom);
		*atom = GDKmalloc(*len = (int) wkb_size(wkbLen));
	}
	if (!wkbSer) {
		**atom = *wkbNULL();
	} else {
		assert(wkbLen <= GDK_int_max);
		(*atom)->len = (int) wkbLen;
		memcpy(&(*atom)->data, wkbSer, wkbLen);
		free(wkbSer);
	}
	wkbLen = strlen(src);
	assert(wkbLen <= GDK_int_max);
	return (int) wkbLen;
      return_nil:
	if ((size_t) *len < sizeof(wkb)) {
		if (*atom)
			GDKfree(*atom);
		*atom = GDKmalloc(*len = (int) sizeof(wkb));
	}
	**atom = *wkbNULL();
	return 0;
}

geom_export str wkbFromString(wkb **w, str *wkt);

str
wkbFromString(wkb **w, str *wkt)
{
	int len = 0;
	char *errbuf;

	if (wkbFROMSTR(*wkt, &len, w))
		return MAL_SUCCEED;
	errbuf = GDKerrbuf;
	if (errbuf) {
		if (strncmp(errbuf, "!ERROR: ", 8) == 0)
			errbuf += 8;
		errbuf = strcpy(alloca(strlen(errbuf) + 1), errbuf);
		GDKerrbuf[0] = 0;
	}
	throw(MAL, "wkb.FromString", "%s", errbuf ? errbuf : "cannot parse string");
}

geom_export str wkbFromWKB(wkb **w, wkb **src);

str
wkbFromWKB(wkb **w, wkb **src)
{
	*w = (wkb *) GDKmalloc(wkb_size((*src)->len));

	if (wkb_isnil(*src)) {
		**w = *wkbNULL();
	} else {
		(*w)->len = (*src)->len;
		memcpy(&(*w)->data, &(*src)->data, (*src)->len);
	}
	return MAL_SUCCEED;
}

geom_export str wkbFromText(wkb **w, str *wkt, int *tpe);

str
wkbFromText(wkb **w, str *wkt, int *tpe)
{
	int len = 0, te = *tpe;
	char *errbuf;

	*w = NULL;
	if (wkbFROMSTR(*wkt, &len, w) &&
	    (wkb_isnil(*w) || *tpe == wkbGeometryCollection ||
	     (te = (((*w)->data[1]) & 0x0f)) == *tpe))
		return MAL_SUCCEED;
	if (!(*w))
		*w = (wkb *) GDKmalloc(sizeof(wkb));
	**w = *wkbNULL();
	if (te != *tpe)
		throw(MAL, "wkb.FromText", "Geometry type '%s' not found", geom_type2str(*tpe));
	errbuf = GDKerrbuf;
	if (errbuf) {
		if (strncmp(errbuf, "!ERROR: ", 8) == 0)
			errbuf += 8;
		errbuf = strcpy(alloca(strlen(errbuf) + 1), errbuf);
		GDKerrbuf[0] = 0;
	}
	throw(MAL, "wkb.FromText", "%s", errbuf ? errbuf : "cannot parse string");
}

geom_export BUN wkbHASH(wkb *w);

BUN
wkbHASH(wkb *w)
{
	int i;
	BUN h = 0;

	for (i = 0; i < (w->len - 1); i += 2) {
		int a = w->data[i], b = w->data[i + 1];
		h = (h << 3) ^ (h >> 11) ^ (h >> 17) ^ (b << 8) ^ a;
	}
	return h;
}

geom_export int wkbCOMP(wkb *l, wkb *r);

int
wkbCOMP(wkb *l, wkb *r)
{
	int len = l->len;

	if (len != r->len)
		return len - r->len;

	if (len == ~(int) 0)
		return (0);

	return memcmp(l->data, r->data, len);
}

geom_export wkb *wkbNULL(void);

wkb *
wkbNULL(void)
{
	static wkb nullval;

	nullval.len = ~(int) 0;
	return (&nullval);
}

geom_export str wkbIsnil(bit *r, wkb **v);

str
wkbIsnil(bit *r, wkb **v)
{
	*r = wkb_isnil(*v);
	return MAL_SUCCEED;
}

geom_export str wkbAsText(str *r, wkb **w);

str
wkbAsText(str *r, wkb **w)
{
	int len = 0;

	wkbTOSTR(r, &len, *w);
	if (len)
		return MAL_SUCCEED;
	throw(MAL, "geom.AsText", "Failed to create Text from Well Known Format");
}

geom_export void wkbDEL(Heap *h, var_t *index);

void
wkbDEL(Heap *h, var_t *index)
{
	HEAP_free(h, *index);
}

geom_export wkb *wkbREAD(wkb *a, stream *s, size_t cnt);

wkb *
wkbREAD(wkb *a, stream *s, size_t cnt)
{
	int len;

	(void) cnt;
	assert(cnt == 1);
	if (!mnstr_readInt(s, &len))
		return NULL;
	if ((a = GDKmalloc(wkb_size(len))) == NULL)
		return NULL;
	a->len = len;
	if (len > 0 && mnstr_read(s, (char *) a->data, len, 1) != 1) {
		GDKfree(a);
		return NULL;
	}
	return a;
}

geom_export int wkbWRITE(wkb *a, stream *s, size_t cnt);

int
wkbWRITE(wkb *a, stream *s, size_t cnt)
{
	int len = a->len;

	(void) cnt;
	assert(cnt == 1);
	if (!mnstr_writeInt(s, len))	/* 64bit: check for overflow */
		return GDK_FAIL;
	if (len > 0)		/* 64bit: check for overflow */
		mnstr_write(s, (char *) a->data, len, 1);
	return GDK_SUCCEED;
}

geom_export void wkbCONVERT(wkb *b, int direction);

void
wkbCONVERT(wkb *b, int direction)
{
	(void) direction;
	b->len = normal_int_SWAP(b->len);
}

geom_export int wkbLENGTH(wkb *p);

int
wkbLENGTH(wkb *p)
{
	var_t len = wkb_size(p->len);
	assert(len <= GDK_int_max);
	return (int) len;
}

geom_export void wkbHEAP(Heap *heap, size_t capacity);

void
wkbHEAP(Heap *heap, size_t capacity)
{
	HEAP_initialize(heap, capacity, 0, (int) sizeof(var_t));
}

geom_export var_t wkbPUT(Heap *h, var_t *bun, wkb *val);

var_t
wkbPUT(Heap *h, var_t *bun, wkb *val)
{
	char *base;

	*bun = HEAP_malloc(h, wkb_size(val->len));
	base = h->base;
	if (*bun)
		memcpy(&base[*bun << GDK_VARSHIFT], (char *) val, wkb_size(val->len));
	return *bun;
}

/* COMMAND mbr
 * Creates the mbr for the given geom_geometry.
 */
geom_export str ordinatesMBR(mbr **res, flt *minX, flt *minY, flt *maxX, flt *maxY);

str
ordinatesMBR(mbr **res,		/* INOUT. */
	     flt *minX,		/* IN. */
	     flt *minY,		/* IN. */
	     flt *maxX,		/* IN. */
	     flt *maxY		/* IN. */
    )
{
	if ((*res = (mbr *) GDKmalloc(sizeof(mbr))) == NULL)
		throw(MAL, "geom.mbr", MAL_MALLOC_FAIL);
	if (*minX == flt_nil || *minY == flt_nil ||
	    *maxX == flt_nil || *maxY == flt_nil)
		**res = *mbrNULL();
	else {
		(*res)->xmin = *minX;
		(*res)->ymin = *minY;
		(*res)->xmax = *maxX;
		(*res)->ymax = *maxY;
	}
	return MAL_SUCCEED;
}


/* COMMAND mbr
 * Creates the mbr for the given geom_geometry.
 */
geom_export str wkbMBR(mbr **res, wkb **geom);

str
wkbMBR(mbr **res,		/* INOUT. */
       wkb **geom		/* IN. */
    )
{
	*res = (mbr *) GDKmalloc(sizeof(mbr));
	if (*res != NULL) {
		if (wkb_isnil(*geom)) {
			**res = *mbrNULL();
			return MAL_SUCCEED;
		} else if (getMbrGeom(*res, *geom))
			return MAL_SUCCEED;
	}
	throw(MAL, "geom.mbr", "Failed to create mbr");
}

geom_export wkb *geos2wkb(GEOSGeom geosGeometry);

wkb *
geos2wkb(GEOSGeom geosGeometry)
{
	size_t wkbLen = 0;
	unsigned char *w = NULL;
	wkb *atom;

	if (geosGeometry != NULL)
		w = GEOSGeomToWKB_buf(geosGeometry, &wkbLen);

	atom = GDKmalloc(wkb_size(wkbLen));
	if (atom == NULL)
		return NULL;

	if (geosGeometry == NULL || w == NULL) {
		*atom = *wkbNULL();
	} else {
		assert(wkbLen <= GDK_int_max);
		atom->len = (int) wkbLen;
		memcpy(&atom->data, w, wkbLen);
		free(w);
	}
	return atom;
}

@= getcoord
geom_export str wkbgetcoord@1(double *out, wkb **geom);

str
wkbgetcoord@1(double *out, wkb **geom)
{
	str ret = MAL_SUCCEED;
	GEOSGeom geosGeometry = wkb2geos(*geom);
#if GEOS_CAPI_VERSION_MAJOR >= 1 && GEOS_CAPI_VERSION_MINOR >= 3
	const GEOSCoordSequence *gcs;
#else
	const GEOSCoordSeq gcs;
#endif

	if (!geosGeometry) {
		*out = dbl_nil;
		return MAL_SUCCEED;
	}

	gcs = GEOSGeom_getCoordSeq(geosGeometry);

	if (!gcs)
		throw(MAL, "geom.wkbgetcoord@1", "GEOSGeom_getCoordSeq failed");

	/* we could also check if geom is a
		LineString, LinearRing or Point */
	if (GEOSCoordSeq_get@1(gcs, 0, out) == 0)
		ret = "GEOSCoordSeq_get@1 failed";

	/* gcs shouldn't be freed, its internal to the GEOSGeom */
	GEOSGeom_destroy(geosGeometry);

	if (ret != MAL_SUCCEED)
		throw(MAL, "geom.@1", "%s", ret);

	return ret;
}
@
@c
@:getcoord(X)@
@:getcoord(Y)@

geom_export str wkbcreatepoint(wkb **out, dbl *x, dbl *y);

str
wkbcreatepoint(wkb **out, dbl *x, dbl *y)
{
	GEOSCoordSeq pnt;
	if (*x == dbl_nil || *y == dbl_nil) {
		if ((*out = GDKmalloc(sizeof(wkb))) != NULL)
			**out = *wkbNULL();
	} else {
		pnt = GEOSCoordSeq_create(1, 2);
		GEOSCoordSeq_setX(pnt, 0, *x);
		GEOSCoordSeq_setY(pnt, 0, *y);
		*out = geos2wkb(GEOSGeom_createPoint(pnt));
		GEOSCoordSeq_destroy(pnt);
	}
	if (*out == NULL)
		throw(MAL, "geom.point", MAL_MALLOC_FAIL);
	return MAL_SUCCEED;
}

geom_export str wkbcreatepoint_bat(int *out, int *x, int *y);

str
wkbcreatepoint_bat(int *out, int *ix, int *iy)
{
	BAT *bo = NULL, *bx = NULL, *by = NULL;
	dbl *x = NULL, *y = NULL;
	BUN i, o;
	wkb *p = NULL;

	if ((bx = BATdescriptor(*ix)) == NULL) {
		throw(MAL, "geom.point", RUNTIME_OBJECT_MISSING);
	}
	if ((by = BATdescriptor(*iy)) == NULL) {
		BBPreleaseref(bx->batCacheid);
		throw(MAL, "geom.point", RUNTIME_OBJECT_MISSING);
	}
	if (!BAThdense(bx) || !BAThdense(by) ||
	    bx->hseqbase != by->hseqbase || BATcount(bx) != BATcount(by)) {
		BBPreleaseref(bx->batCacheid);
		BBPreleaseref(by->batCacheid);
		throw(MAL, "geom.point", "both arguments must have dense and aligned heads");
	}

	if ((bo = BATnew(TYPE_void, ATOMindex("wkb"), BATcount(bx))) == NULL) {
		BBPreleaseref(bx->batCacheid);
		BBPreleaseref(by->batCacheid);
		throw(MAL, "geom.point", MAL_MALLOC_FAIL);
	}
	BATseqbase(bo, bx->hseqbase);
	bo->hdense = TRUE;
	bo->hsorted = TRUE;
	bo->H->nonil = TRUE;
	BATkey(bo, TRUE);

	x = (dbl *) Tloc(bx, BUNfirst(bx));
	y = (dbl *) Tloc(by, BUNfirst(bx));
	for (i = 0, o = BUNlast(bo); i < BATcount(bx); i++, o++) {
		str err = NULL;
		if ((err = wkbcreatepoint(&p, &x[i], &y[i])) != MAL_SUCCEED) {
			BBPreleaseref(bx->batCacheid);
			BBPreleaseref(by->batCacheid);
			BBPreleaseref(bo->batCacheid);
			throw(MAL, "geom.point", "%s", err);
		}
		tfastins_nocheck(bo, o, p, Tsize(bo));
		GDKfree(p);
		p = NULL;
	}

	BATsetcount(bo, BATcount(bx));
	bo->batDirty = TRUE;
	bo->tdense = FALSE;
	bo->tsorted = FALSE;
	bo->T->nonil = (bx->T->nonil && by->T->nonil);
	BATkey(BATmirror(bo), (bx->tkey && by->tkey));

	BBPreleaseref(bx->batCacheid);
	BBPreleaseref(by->batCacheid);
	BBPkeepref(*out = bo->batCacheid);
	return MAL_SUCCEED;

      bunins_failed:
	if (p)
		GDKfree(p);
	BBPreleaseref(bx->batCacheid);
	BBPreleaseref(by->batCacheid);
	BBPreleaseref(bo->batCacheid);
	throw(MAL, "geom.point", "bunins failed");
}

geom_export str mbroverlaps(bit *out, mbr *b1, mbr *b2);

str
mbroverlaps(bit *out, mbr *b1, mbr *b2)
{
	if (mbr_isnil(b1) || mbr_isnil(b2))
		*out = 0;
	else
		*out = ((b1->ymax >= b2->ymax && b1->xmin <= b2->ymax) ||
			(b2->ymax >= b1->ymax && b2->xmin <= b1->ymax)) &&
		       ((b1->xmax >= b2->xmax && b1->ymin <= b2->xmax) ||
			(b2->xmax >= b1->xmax && b2->ymin <= b1->xmax));
	return MAL_SUCCEED;
}

@= basic
geom_export str wkb@1( @2 *out, wkb **geom);

str
wkb@1( @2 *out, wkb **geom)
{
	GEOSGeom geosGeometry = wkb2geos(*geom);

	if (!geosGeometry) {
		@7;
		return MAL_SUCCEED;
	}

	*out = @4(@3(geosGeometry));

	GEOSGeom_destroy(geosGeometry);

#if @6
	if (*out == @5)
		throw(MAL, "geom.@1", "@3 failed");
#endif
	return MAL_SUCCEED;

}
@
@c
@:basic(Dimension,int,GEOSGeom_getDimensions,,0,1,*out=int_nil)@
@:basic(GeometryTypeId,int,GEOSGeomTypeId,,-1,1,*out=int_nil)@
@:basic(SRID,int,GEOSGetSRID,,,0,*out=int_nil)@
@:basic(Envelope,wkb*,GEOSEnvelope,geos2wkb,NULL,1,*out=geos2wkb(NULL))@
@:basic(IsEmpty,bit,GEOSisEmpty,,2,1,*out=bit_nil)@
@:basic(IsSimple,bit,GEOSisSimple,,2,1,*out=bit_nil)@
@:basic(Boundary,wkb*,GEOSBoundary,geos2wkb,NULL,1,*out=geos2wkb(NULL))@

@= spatial
geom_export str wkb@1( bit *out, wkb **a, wkb **b);

str
wkb@1( bit *out, wkb **a, wkb **b)
{
	GEOSGeom ga = wkb2geos(*a);
	GEOSGeom gb = wkb2geos(*b);

	if (!ga && gb) {
		GEOSGeom_destroy(gb);
		*out = bit_nil;
		return MAL_SUCCEED;
	}
	if (ga && !gb) {
		GEOSGeom_destroy(ga);
		*out = bit_nil;
		return MAL_SUCCEED;
	}
	if (!ga && !gb) {
		*out = bit_nil;
		return MAL_SUCCEED;
	}

	*out = @2(ga, gb);

	GEOSGeom_destroy(ga);
	GEOSGeom_destroy(gb);

	return MAL_SUCCEED;
}
@= spatial2
geom_export str wkb@1( bit *out, wkb **a, wkb **b, @3 @4);

str
wkb@1( bit *out, wkb **a, wkb **b, @3 @4)
{
	GEOSGeom ga = wkb2geos(*a);
	GEOSGeom gb = wkb2geos(*b);

	if (!ga && gb) {
		GEOSGeom_destroy(gb);
		*out = bit_nil;
		return MAL_SUCCEED;
	}
	if (ga && !gb) {
		GEOSGeom_destroy(ga);
		*out = bit_nil;
		return MAL_SUCCEED;
	}
	if (!ga && !gb) {
		*out = bit_nil;
		return MAL_SUCCEED;
	}

	*out = @2(ga, gb, * @4);

	GEOSGeom_destroy(ga);
	GEOSGeom_destroy(gb);

	return MAL_SUCCEED;
}
@
@c
@:spatial(Equals,GEOSEquals)@
@:spatial(Disjoint,GEOSDisjoint)@
@:spatial(Intersect,GEOSIntersects)@
@:spatial(Touches,GEOSTouches)@
@:spatial(Crosses,GEOSCrosses)@
@:spatial(Within,GEOSWithin)@
@:spatial(Contains,GEOSContains)@
@:spatial(Overlaps,GEOSOverlaps)@
@:spatial2(Relate,GEOSRelatePattern,str*,pattern)@

@= analysis
geom_export str wkb@1( dbl *out, wkb **a);

str
wkb@1( dbl *out, wkb **a)
{
	str ret = MAL_SUCCEED;
	GEOSGeom ga = wkb2geos(*a);

	if (!ga) {
		*out = dbl_nil;
		return ret;
	}

	if (@2(ga, out) == 0)
		ret = "@2 failed";

	GEOSGeom_destroy(ga);

	if (ret != MAL_SUCCEED)
		throw(MAL, "geom.@1", "%s", ret);
	return ret;
}
@= analysis2
geom_export str wkb@1( dbl *out, wkb **a, wkb **b);

str
wkb@1( dbl *out, wkb **a, wkb **b)
{
	str ret = MAL_SUCCEED;
	GEOSGeom ga = wkb2geos(*a);
	GEOSGeom gb = wkb2geos(*b);

	if (!ga && gb) {
		GEOSGeom_destroy(gb);
		*out = dbl_nil;
		return ret;
	}
	if (ga && !gb) {
		GEOSGeom_destroy(ga);
		*out = dbl_nil;
		return ret;
	}
	if (!ga && !gb) {
		*out = dbl_nil;
		return ret;
	}

	if (@2(ga, gb, out) == 0)
		ret = "@2 failed";

	GEOSGeom_destroy(ga);
	GEOSGeom_destroy(gb);

	if (ret != MAL_SUCCEED)
		throw(MAL, "geom.@1", "%s", ret);
	return ret;
}
@= analysis3
geom_export str wkb@1( wkb **out, wkb **a, wkb **b);

str
wkb@1( wkb **out, wkb **a, wkb **b)
{
	GEOSGeom ga = wkb2geos(*a);
	GEOSGeom gb = wkb2geos(*b);

	if (!ga && gb) {
		GEOSGeom_destroy(gb);
		*out = geos2wkb(NULL);
		return MAL_SUCCEED;
	}
	if (ga && !gb) {
		GEOSGeom_destroy(ga);
		*out = geos2wkb(NULL);
		return MAL_SUCCEED;
	}
	if (!ga && !gb) {
		*out = geos2wkb(NULL);
		return MAL_SUCCEED;
	}

	*out = @3(@2( ga, gb));

	GEOSGeom_destroy(ga);
	GEOSGeom_destroy(gb);

	if (*out != NULL)
		return MAL_SUCCEED;

	throw(MAL, "geom.@1", "@2 failed");
}
@
@c
@:analysis(Area,GEOSArea)@
@:analysis(Length,GEOSLength)@
@:analysis2(Distance,GEOSDistance)@
@:basic(ConvexHull,wkb*,GEOSConvexHull,geos2wkb,NULL,1,*out=geos2wkb(NULL))@
@:analysis3(Intersection,GEOSIntersection,geos2wkb)@
@:analysis3(Union,GEOSUnion,geos2wkb)@
@:analysis3(Difference,GEOSDifference,geos2wkb)@
@:analysis3(SymDifference,GEOSSymDifference,geos2wkb)@

geom_export str wkbBuffer(wkb **out, wkb **geom, dbl *distance);

str
wkbBuffer(wkb **out, wkb **geom, dbl *distance)
{
	GEOSGeom geosGeometry = wkb2geos(*geom);

	if (!geosGeometry) {
		*out = geos2wkb(NULL);
		return MAL_SUCCEED;
	}

	*out = geos2wkb(GEOSBuffer(geosGeometry, *distance, -1));

	GEOSGeom_destroy(geosGeometry);

	if (*out != NULL)
		return MAL_SUCCEED;

	throw(MAL, "geom.Buffer", "GEOSBuffer failed");
}

@(
#define prepareOperand(X,Y,Z) \
	if( (X= BATdescriptor(*Y)) == NULL ) \
		throw(MAL, "geom." Z, "Cannot access descriptor");
#define prepareResult(X,Y,T,Z) \
	X= BATnew(Y->htype,T,BATcount(Y)); \
	if( Y->htype== TYPE_void) \
		BATseqbase(X, Y->hseqbase); \
	if( X == NULL){ \
		BBPreleaseref(Y->batCacheid); \
		throw(MAL, "geom." Z, "no space available "); \
	} \
	X->hsorted=Y->hsorted; \
	X->tsorted=0;
#define finalizeResult(X,Y,Z) \
	if (!((Y)->batDirty&2)) (Y) = BATsetaccess((Y), BAT_READ); \
	*X = (Y)->batCacheid; \
	BBPkeepref(*(X));\
	BBPreleaseref(Z->batCacheid);

geom_export str bat_wkbMBR(int *ret, int *l);

str
bat_wkbMBR(int *ret, int *l)
{
	BAT *bn, *b;
	BUN p,q;
	int xx;
	wkb *x;
	mbr y;

	prepareOperand(b,l,"mbr");
	prepareResult(bn,b,TYPE_mbr,"mbr");

	BATloopFast(b, p, q, xx) {
		mbr *yp = &y;
		ptr h = BUNhead(b,p);
		x = (wkb*)BUNtail(b,p);
		if (wkb_isnil(x))
			yp = mbrNULL();
		else
			wkbMBR(yp,&x);
		bunfastins(bn, h, yp);
	}
	finalizeResult(ret,bn,b);
	return MAL_SUCCEED;
bunins_failed:
	BBPreleaseref(b->batCacheid);
	BBPunfix(bn->batCacheid);
	throw(MAL, "geom.mbr", "bunins failed");
}
@)

@mal

# wkbPoint := 1;
# wkbLineString := 2;
# wkbPolygon := 3;
# wkbMultiPoint := 4;
# wkbMultiLineString := 5;
# wkbMultiPolygon := 6;
# wkbGeometryCollection := 7;

