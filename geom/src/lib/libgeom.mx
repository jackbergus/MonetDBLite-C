@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2007 CWI.
@' All Rights Reserved.

@f libgeom
@a Niels Nes

@* The simple geom library
@h
#ifndef LIBGEOM_H
#define LIBGEOM_H

#include <gdk.h>

@+ Geos
The geom library is based on the geos (Geometry Engine Open Source) library.
@h

#ifdef WIN32
#ifndef LIBGEOM
#define libgeom_export extern __declspec(dllimport)
#else
#define libgeom_export extern __declspec(dllexport)
#endif
#else
#define libgeom_export extern
#endif

#include "geos_c.h"

typedef struct mbr
{
        float xmin;
        float ymin;
        float xmax;
        float ymax;
} mbr;

@+
Geometry objects have 4 attributes: type, bbox, SRID and data. This 
implementation uses a varized atom for the data, which stores the WKB format
as defined by OpenGIS.
@h

/* 'WKB'
==Geometry Type byte==


All serialiezd geometries start with a single byte
encoding geometry type (lower nibble) and flags
(higher nibble).

First Byte is for the order (little (1) or big endian)

Geometry Type Byte:

     [BSZM] [TTTT]

Flags values:

      B = 16 byte BOX2DFLOAT4 follows (probably not aligned) [before SRID]
      S = 4 byte SRID attached (0= not attached (-1), 1= attached)
      ZM = dimensionality (hasZ, hasM)

Type values:

*/

typedef enum wkb_type {
      wkbPoint = 1,
      wkbLineString = 2,
      wkbPolygon = 3,
      wkbMultiPoint = 4,
      wkbMultiLineString = 5,
      wkbMultiPolygon = 6,
      wkbGeometryCollection = 7,
} wkb_type;

libgeom_export const char * geom_type2str(int t);

typedef struct wkb
{
	int  len;
	char data[1];
} wkb;

typedef struct 
{
	unsigned char 	type;	
	mbr	bbox;
	int		SRID;
	wkb	wkb;	
} geom_geometry;

libgeom_export void libgeom_init(void);
libgeom_export void libgeom_exit(void);

/* Macro wkb2geos
 * Returns a GEOSGeom, created from a geom_geometry.
 * On failure, returns NULL.
 */
#define wkb2geos( geom ) \
	wkb_isnil((geom))? NULL: \
	GEOSGeomFromWKB_buf((unsigned char *)((geom)->data), (geom)->len)

libgeom_export int wkb_isnil(wkb *wkb);
libgeom_export int getMbrGeos( mbr *mbr, const GEOSGeom geosGeometry );
libgeom_export int getMbrGeom( mbr *res,  wkb* geom );

#endif /* LIBGEOM_H */
@c

#include <geom_config.h>
#include "libgeom.h"

#include <math.h>

void
libgeom_init(void) 
{
	initGEOS((GEOSMessageHandler)GDKwarning, (GEOSMessageHandler)GDKerror);
}

void
libgeom_exit(void) 
{
	finishGEOS();
}

int
wkb_isnil(wkb *wkb)
{
	if (!wkb || wkb->len == ~0) 
		return 1;
	return 0;
}


/* Function getMbrGeos
 * Creates an mbr holding the lower left and upper right coordinates
 * of a GEOSGeom.
 */
int
getMbrGeos( mbr *res, const GEOSGeom geosGeometry )
{
	GEOSGeom envelope;
	GEOSCoordSeq coords;
	double xmin, ymin, xmax, ymax;

	if (!geosGeometry || (envelope = GEOSEnvelope(geosGeometry)) == NULL)
		return 0;

	if (GEOSGeomTypeId(envelope) == GEOS_POINT) {
		coords = (GEOSCoordSeq)GEOSGeom_getCoordSeq(envelope);
		GEOSCoordSeq_getX(coords, 0, &xmin);
		GEOSCoordSeq_getY(coords, 0, &ymin);
		res->xmin = xmin;
		res->ymin = ymin;
		res->xmax = xmin;
		res->ymax = ymin;
	} else { /* GEOSGeomTypeId(envelope) == GEOS_POLYGON */
		GEOSGeom ring = (GEOSGeom)GEOSGetExteriorRing(envelope);
		if (ring) {
			coords = (GEOSCoordSeq)GEOSGeom_getCoordSeq(ring); 
			GEOSCoordSeq_getX(coords, 0, &xmin);
			GEOSCoordSeq_getY(coords, 0, &ymin);
			GEOSCoordSeq_getX(coords, 2, &xmax);
			GEOSCoordSeq_getY(coords, 2, &ymax);
			res->xmin = xmin;
			res->ymin = ymin;
			res->xmax = xmax;
			res->ymax = ymax;
		}
	}
	GEOSGeom_destroy(envelope);
	return 1;
}

/* Function getMbrGeom
 * A wrapper for getMbrGeos on a geom_geometry.
 */
int
getMbrGeom( mbr *res,  wkb* geom )
{
	GEOSGeom geosGeometry = wkb2geos(geom);

	if (geosGeometry) {
		int r = getMbrGeos(res, geosGeometry);
		GEOSGeom_destroy(geosGeometry);
		return r;
	}
	return 0;
}

const char *
geom_type2str(int t)
{
	switch(t) {
	case wkbPoint: return "Point";
      	case wkbLineString: return "Line";
	case wkbPolygon: return "Polygon";
	case wkbMultiPoint: return "MultiPoint";
	case wkbMultiLineString: return "MultiLine";
	case wkbMultiPolygon: return "MultiPolygon";
	case wkbGeometryCollection: return "GeomCollection";
	}
	return "unknown";
}


