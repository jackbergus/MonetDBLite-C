@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2006 CWI.
@' All Rights Reserved.

@f libgeom
@a Niels Nes

@* The simple geom library
@h
#ifndef LIBGEOM_H
#define LIBGEOM_H

#include <gdk.h>

@+ Geos
The geom library is based on the geos (Geometry Engine Open Source) library.
@h

#ifdef WIN32
#ifndef LIBGEOM
#define libgeom_export extern __declspec(dllimport)
#else
#define libgeom_export extern __declspec(dllexport)
#endif
#else
#define libgeom_export extern
#endif

#include "geos_c.h"

typedef struct mbr
{
        float xmin;
        float ymin;
        float xmax;
        float ymax;
} mbr;

@+
Geometry objects have 4 attributes: type, bbox, SRID and data. This 
implementation uses a varized atom for the data, which stores the WKB format
as defined by OpenGIS.
@h

/* 'WKB'
==Geometry Type byte==


All serialiezd geometries start with a single byte
encoding geometry type (lower nibble) and flags
(higher nibble).

First Byte is for the order (little (1) or big endian)

Geometry Type Byte:

     [BSZM] [TTTT]

Flags values:

      B = 16 byte BOX2DFLOAT4 follows (probably not aligned) [before SRID]
      S = 4 byte SRID attached (0= not attached (-1), 1= attached)
      ZM = dimensionality (hasZ, hasM)

Type values:

*/

typedef enum wkb_type {
      wkbPoint = 1,
      wkbLineString = 2,
      wkbPolygon = 3,
      wkbMultiPoint = 4,
      wkbMultiLineString = 5,
      wkbMultiPolygon = 6,
      wkbGeometryCollection = 7,
} wkb_type;

libgeom_export const char * geom_type2str(int t);

typedef struct wkb
{
	int  len;
	char data[1];
} wkb;

typedef struct 
{
	unsigned char 	type;	
	mbr	bbox;
	int		SRID;
	wkb	wkb;	
} geom_geometry;

libgeom_export void libgeom_init(void);
libgeom_export void libgeom_exit(void);

/* Macro wkb2geos
 * Returns a GEOSGeom, created from a geom_geometry.
 * On failure, returns NULL.
 */
#define wkb2geos( geom ) \
	wkb_isnil(geom)? NULL: \
	GEOSGeomFromWKB_buf((unsigned char *)geom->data, geom->len)

libgeom_export int wkb_isnil(wkb *wkb);
libgeom_export int getMbrGeos( mbr *mbr, const GEOSGeom geosGeometry );
libgeom_export int getMbrGeom( mbr *res,  wkb* geom );

/* 
 * geom_filter type (fixed-sized atom),
 * including the XZ-Ordering primary filter algorithms.
 * 
 */
#define geom_filter int
#define GEOM_FILTER_MAX GDK_int_max
#define geom_filter_nil int_nil

#define xzSequence geom_filter
#define XZ_SEQUENCE_MAX GEOM_FILTER_MAX

/* XZ_LEVEL_MAX
 * Holds the maximum number of quad splitting levels in XZ-Ordering.
 * See the xzLevelMax function.
 */
#define XZ_LEVEL_MAX 15

/* Macro XZ_MBR_WIDTH
 * Returns the width of an mbr, in terms of XZ-Ordering,
 * i.e. the mbr is "squared"; either the width or the height is returned,
 * whichever is larger.
 */
#define XZ_MBR_WIDTH( \
	mbr /* IN (mbr*): The mbr in question. */ \
) \
MAX(mbr->xmax - mbr->xmin, mbr->ymax - mbr->ymin) 

/* Function xzEncodeWKB
 * Computes the XZ-Ordering sequence code for a wkb.
 */
libgeom_export xzSequence xzEncodeWKB(mbr* universe, wkb* wkb);
libgeom_export BAT* xzOverlap( xzSequence baseCode) ;

#endif /* LIBGEOM_H */
@c

#include <geom_config.h>
#include "libgeom.h"

#include <math.h>

/* Array XZ_NUM_ELEMENTS_AT_LEVEL
 * If we move one quadrant along the Z curve at this level, how many elements at
 * all deeper levels do we skip? I.e. what number should we add to get the
 * sequence code of the next quadrant?
 * See Definition 2 of the XZ-Ordering paper.
 */
xzSequence XZ_NUM_ELEMENTS_AT_LEVEL[XZ_LEVEL_MAX + 1];

void
libgeom_init(void) 
{
	size_t i;

	for (i = 0; i <= XZ_LEVEL_MAX; i++) {
		size_t x = XZ_LEVEL_MAX - i + 1;
		if (x < XZ_LEVEL_MAX+1) { 
			XZ_NUM_ELEMENTS_AT_LEVEL[i] = (((xzSequence) (1LL << (2 * x)) - 1) / 3);
		} else {
			XZ_NUM_ELEMENTS_AT_LEVEL[i] = (((xzSequence) pow(4, x) - 1) / 3);
		}
	}
	initGEOS((GEOSMessageHandler)GDKwarning, (GEOSMessageHandler)GDKerror);
}

void
libgeom_exit(void) 
{
	finishGEOS();
}

int
wkb_isnil(wkb *wkb)
{
	if (!wkb || wkb->len == ~0) 
		return 1;
	return 0;
}


/* Function getMbrGeos
 * Creates an mbr holding the lower left and upper right coordinates
 * of a GEOSGeom.
 */
int
getMbrGeos( mbr *res, const GEOSGeom geosGeometry )
{
	GEOSGeom envelope;
	GEOSCoordSeq coords;
	double xmin, ymin, xmax, ymax;

	if (!geosGeometry || (envelope = GEOSEnvelope(geosGeometry)) == NULL)
		return 0;

	if (GEOSGeomTypeId(envelope) == GEOS_POINT) {
		coords = (GEOSCoordSeq)GEOSGeom_getCoordSeq(envelope);
		GEOSCoordSeq_getX(coords, 0, &xmin);
		GEOSCoordSeq_getY(coords, 0, &ymin);
		res->xmin = xmin;
		res->ymin = ymin;
		res->xmax = xmin;
		res->ymax = ymin;
	} else { /* GEOSGeomTypeId(envelope) == GEOS_POLYGON */
		GEOSGeom ring = (GEOSGeom)GEOSGetExteriorRing(envelope);
		if (ring) {
			coords = (GEOSCoordSeq)GEOSGeom_getCoordSeq(ring); 
			GEOSCoordSeq_getX(coords, 0, &xmin);
			GEOSCoordSeq_getY(coords, 0, &ymin);
			GEOSCoordSeq_getX(coords, 2, &xmax);
			GEOSCoordSeq_getY(coords, 2, &ymax);
			res->xmin = xmin;
			res->ymin = ymin;
			res->xmax = xmax;
			res->ymax = ymax;
		}
	}
	GEOSGeom_destroy(envelope);
	return 1;
}

/* Function getMbrGeom
 * A wrapper for getMbrGeos on a geom_geometry.
 */
int
getMbrGeom( mbr *res,  wkb* geom )
{
	GEOSGeom geosGeometry = wkb2geos(geom);

	if (geosGeometry) {
		int r = getMbrGeos(res, geosGeometry);
		GEOSGeom_destroy(geosGeometry);
		return r;
	}
	return 0;
}

/* Function xzLevel
 * Determines the level at which the sequence code for an mbr should be computed.
 */
static
size_t
xzLevel(
	mbr* universe, /* IN */
	mbr* mbr /* IN */
)
{
	size_t level;
	double qWidth = XZ_MBR_WIDTH(universe);
	double mbrWidth = XZ_MBR_WIDTH(mbr);

	if (mbrWidth == 0)
		return XZ_LEVEL_MAX;

	/* We're looking for the level at which the mbr will definitely cross no more
	 * than 1 grid line, so that it will definitely fit whithin an
	 * "enlarged region", that has the size of the grid elements at 1 level higher.
	 */
	for (level = 0; level < XZ_LEVEL_MAX; level++)
		if (mbrWidth > (qWidth /= 2))
			break;

	return level;
}

/* Function xzEncode
 * Does the computation of the XZ-Ordering sequence code.
 */
static
xzSequence
xzEncode(
	size_t xzLevel, /* IN: The quad splitting level for the sequence code (determined by the xzLevel() function. */
	double x, double y, /* IN: The lower left coordinate of the geometry's bounding box. */
	mbr* universe /* IN: The bounds of the universe we're quad splitting. */
)
{
	xzSequence sequenceCode = 0;
	double qWidth = XZ_MBR_WIDTH(universe);
	double limX = universe->xmin, limY = universe->ymin;
	char q; size_t i;
	/* Recursively split up the universe in quadrants, up to the specified level.
	 * At each level, determine in which of the 4 quadrants we are.
	 * Along the way, add up the "sequence code" (one could build the 
	 * "quadrant sequence" along, but it's really not needed).
	 */
	for (i = 1; i <= xzLevel; i++) {
		qWidth /= 2;
		q = 0;
		if (x - limX >= qWidth)
			q = 1;
		if (y - limY >= qWidth)
			q += 2;
		if (q&1) limX += qWidth;
		if (q>1) limY += qWidth;
		// printf("x %f, y %f, level %d, qWidth %f, limX %f, limY %f, q %d\n", x, y, i, qWidth, limX, limY, q);
		// printf("level %d, number of elements at level %d: %d\n", i, i, XZ_NUM_ELEMENTS_AT_LEVEL[i]);
		/* 
		 * See Definition 2 of the XZ-Ordering paper.
		 */
		sequenceCode +=
			q // The quadrant at this level (0, 1, 2, or 3).
			* XZ_NUM_ELEMENTS_AT_LEVEL[i] // The number of (sub)elements in deeper levels that we skip.
			+ 1; // And this one.
	}
	return sequenceCode;
}

/* Function xzEncodeGeos
 * A wrapper for xzEncode on a GEOSGeom.
 */
static
xzSequence
xzEncodeGeos(
	mbr* universe, /* IN */
	GEOSGeom geosGeometry /* IN */
)
{
	xzSequence sequenceCode = -1;
	mbr mbr;  

	if (getMbrGeos(&mbr, geosGeometry)) {
		sequenceCode = xzEncode( xzLevel(universe, &mbr),
			mbr.xmin, mbr.ymin, universe );
	}
	return sequenceCode;
}

/* Function xzEncodeWKB
 * A wrapper for xzEncodeWKB on a wkb.
 */
xzSequence
xzEncodeWKB(
	mbr* universe, /* IN */
	wkb* geom /* IN */
)
{
	xzSequence sequenceCode = -1;
	GEOSGeom geosGeometry = wkb2geos(geom);
	if (geosGeometry) {
		sequenceCode = xzEncodeGeos(universe, geosGeometry);
		GEOSGeom_destroy(geosGeometry);
	}
	return sequenceCode;
}

/*
 * Implementation of fixed-sized atom geom_filter.
 * 
 * Really an implementation of "XZ-Ordering".
 * For a description, see Wouter's graduation thesis, and/or:
 *  BÃ¶hm C, Klump G, Kriegel HP (1999)
 *   "XZ-Ordering: A Space-Filling Curve for Objects with Spatial Extension",
 *   SSD '99, pp. 75-90 Lecture Notes in Computer Science 1651
 */

/* Function xzLevelMax
 * Was used to compute the value for XZ_LEVEL_MAX.
 * The level is hard-coded, however, since it would become
 * very annoying if different machines use different values.
 */ 
#if 0
static
void
xzLevelMax(void) {
	size_t xzLevelMax;
	double maxSequence = 0.0;
	double nextMaxSequence = 1.0;
	// At level n, the largest sequence code is (a bit less than):
	// 4^0 + 4^1 + ... + 4^n-1 + 4^n
	for (xzLevelMax = 0; nextMaxSequence > maxSequence; xzLevelMax++) {
		double extra = 1LL << (xzLevelMax * 2);
		maxSequence = nextMaxSequence;
		printf("level " SZFMT ", maxSequence %f\n", xzLevelMax, maxSequence);
		if (extra < XZ_SEQUENCE_MAX && (XZ_SEQUENCE_MAX - extra) >= maxSequence)
			nextMaxSequence += (xzSequence) extra;
	}
	xzLevelMax -= 1; // This appears to be important.
}
#endif

/* Function xzQuadrantSequence
 * Makes up a quadrant sequence from a sequence code.
 */
static inline
void
xzQuadrantSequence(
	xzSequence sequenceCode, /* IN */
	char* quadrantSequence /* INOUT: *quadrantSequence must be char[XZ_LEVEL_MAX + 1]. */
)
{
	char q; size_t i;
	/* The same computation as in xzEncode, but now in reverse. */
	for (i = 1; i <= XZ_LEVEL_MAX && sequenceCode > 0; i++) {
		q = (char) (--sequenceCode / XZ_NUM_ELEMENTS_AT_LEVEL[i]);
		quadrantSequence[i-1] = '0' + q;
		sequenceCode %= XZ_NUM_ELEMENTS_AT_LEVEL[i];
	}
	quadrantSequence[i-1] = 0;
}

/* Macro XZ_Q
 * This is because '0' != (char) 0 and (int) '0' != 0, although 
 * (int) (charVar = 0) == 0, which is used in xzEncode.
 */
#define XZ_Q(q) (q - '0')

/* Function xzSequenceCode
 * Computes a sequence code from a quadrant sequence.
 */
static inline
void
xzSequenceCode(
	const char* quadrantSequence, /* IN */
	xzSequence* sequenceCode /* OUT */
)
{
	size_t level = strlen(quadrantSequence);
	char q; size_t i;
	/* The same computation as in xzEncode, but now it's easier to get the quadrants. */
	*sequenceCode = 0;
	for (i = 1; i <= level; i++) {
		q = quadrantSequence[i - 1];
		*sequenceCode += XZ_Q(q) * XZ_NUM_ELEMENTS_AT_LEVEL[i] + 1;
	}
}

@= xzShift
/* Function xzShift@1
 * Shifts the sequence code to let it correspond with the @1 neighbour of the
 * element that it currently corresponds to.
 */
static inline
void
xzShift@1(
	xzSequence* sequenceCode, /* INOUT */
	char* quadrantSequence, /* INOUT: *quadrantSequence must be char[XZ_LEVEL_MAX + 1]. */
	size_t level /* IN */
)
{
	xzSequence delta, numAtLevel;
	char q;
	
	if (*sequenceCode < 1) // At level 0 (sequence code 0, quadrant sequence ""), any shifting would go out of the universe.
		return;
	
	/* This rule is not described in the XZ-Ordering paper.
	 * Suppose XZ_LEVEL_MAX is 3. Then, when you move from element 19 ("031") to
	 * the East, you come in 34 ("120"). The highest level at which a grid line
	 * was crossed, is level 1. The number of elements at level 1 is 21, at
	 * level 2 it's 5 and at level 3 it's 1. Now 34 can be computed by adding
	 * (21 - 5 - 1) to 19.
	 */
	for (delta = 0 ; level >= 1; ) {
		numAtLevel = XZ_NUM_ELEMENTS_AT_LEVEL[level]; 
		delta += numAtLevel;
		q = quadrantSequence[level - 1];
		if (@2) // The shift crosses a grid line.
			level--;
		else
			break;
	}
	if (level > 0) {
		*sequenceCode @3= @4 * (numAtLevel - (delta - numAtLevel));
		xzQuadrantSequence(*sequenceCode, quadrantSequence);
	}
	else { // We shifted out of the universe.
		*sequenceCode = -1;
	}
}
@c
@:xzShift(North,q>'1',+,2)@
@:xzShift(East,q&1,+,1)@
@:xzShift(South,q<'2',-,2)@
@:xzShift(West,!(q&1),-,1)@

static inline
void
xzAddInterval(
	BAT* intervalBAT,
	xzSequence from,
	xzSequence to
)
{
	if (from >=0 && to >= 0) {
		BUN p = BUNlast(intervalBAT);
		int s = BUNsize(intervalBAT);
		if (intervalBAT->batBuns->free + s > intervalBAT->batBuns->size) {
			if (BATextend(intervalBAT, BATgrows(intervalBAT)) == NULL)
				goto bunins_failed;
			p = BUNlast(intervalBAT);
		}
		*(geom_filter*)BUNhloc(intervalBAT, p) = from;
		*(geom_filter*)BUNtloc(intervalBAT, p) = to;
		intervalBAT->batBuns->free += s;
		intervalBAT->batCount ++;
	}
	return;

bunins_failed:
	GDKerror("xzAddInterval: bunfastins failed\n");
	return;
}

static inline
void
xzAddInterval_noExtend(
	BAT* intervalBAT,
	xzSequence from,
	xzSequence to
)
{
	if (from >=0 && to >= 0) {
		BUN p = BUNlast(intervalBAT);
		int s = BUNsize(intervalBAT);
		*(geom_filter*)BUNhloc(intervalBAT, p) = from;
		*(geom_filter*)BUNtloc(intervalBAT, p) = to;
		intervalBAT->batBuns->free += s;
		intervalBAT->batCount ++;
	}
	return;
}

static inline
void
xzCloseIntervalBAT(
	BAT* b,
	bit I_know_head_sorted,
	bit I_know_tail_sorted,
	bit I_know_head_unique,
	bit I_know_tail_unique
)
{
/*
	(void)b;
	(void)I_know_head_sorted;
	(void)I_know_tail_sorted;
	(void)I_know_head_unique;
	(void)I_know_tail_unique;
*/
	size_t count = BATcount(b);
	bit trivial = count < 2;

	b->hdense = FALSE;
	b->hsorted = (trivial || I_know_head_sorted) ? GDK_SORTED : FALSE;
	BATkey(b, trivial || I_know_head_unique);

	b->tdense = FALSE;
	b->tsorted = (trivial || I_know_tail_sorted) ? GDK_SORTED : FALSE;
	BATkey(BATmirror(b), trivial || I_know_tail_unique);

	if (!b->batDirty)
		b->batDirty = TRUE;
}

@= xzDrillDown
/* Function xzDrillDown@1
 * Determines regions at deeper levels, overlapping that of the given sequence
 * code in the @1. Recursively drills down till level maxLevel.
 */
static inline
void
xzDrillDown@1(
	xzSequence sequenceCode,
	size_t level,
	size_t* maxLevel, /* IN */
	BAT* intervalBAT /* INOUT */
)
{
	xzSequence step;
	if (sequenceCode < 0 || ++level > *maxLevel)
		return;
	step = XZ_NUM_ELEMENTS_AT_LEVEL[level];
	sequenceCode++; // First inner quadrant. Same as appending "0" to the quadrantSequence.
	sequenceCode += @2 * step;
	xzAddInterval(intervalBAT, sequenceCode, sequenceCode);
	// printf("Drill down @1, level %d, sequence code %f\n", level, (double) sequenceCode);
	xzDrillDown@1(sequenceCode, level, maxLevel, intervalBAT);
	if (@3 > 0) {
		sequenceCode += @3 * step;
		xzAddInterval(intervalBAT, sequenceCode, sequenceCode);
		// printf("Drill down @1, level %d, sequence code %f\n", level, (double) sequenceCode);
		xzDrillDown@1(sequenceCode, level, maxLevel, intervalBAT);
	}
}
@c
@:xzDrillDown(North,2,1)@
@:xzDrillDown(NorthEast,3,0)@
@:xzDrillDown(East,1,2)@

/* Function xzDrillUp
 * Determines the overlapping regions at higher levels, recursively up to level 0.
 */
static inline
void
xzDrillUp(
	xzSequence sequenceCode, /* IN */
	char* quadrantSequence, /* IN */
	size_t level, /* IN */
	BAT* intervalBAT /* INOUT */
)
{
	char q;
	xzSequence scHigherLevel, scShift;
	char qsShift[XZ_LEVEL_MAX + 1] = "";
	
	if (sequenceCode < 0 || level < 1)
		return;
	
	if (level == 1) {
		xzAddInterval(intervalBAT, 0, 0);
		// printf("Drill up, level %d, sequence code %f\n", level -1, (double) 0);
		return;
	}

	/* Compute the sequence code of the containing element at 1 level higher.
	 * For example, with XZ_LEVEL_MAX = 3:
	 * XZ_NUM_ELEMENTS_AT_LEVEL[2] = 5
	 * Sequence code 33 (quadrantSequence "12") -> 33 - 2 * 5 - 1 = 22 (quadrant sequence "3")
	 * XZ_NUM_ELEMENTS_AT_LEVEL[3] = 1
	 * Sequence code 19 (quadrantSequence "031") -> 19 - 1 * 1 - 1 = 17 (quadrant sequence "03")
	 */
	q = quadrantSequence[level - 1]; // The last character, i.e. the quad at the deeper level.
	// printf("Drilling up..., sequenceCode %f, quadrantSequence %s, level %d\n", (double) sequenceCode, quadrantSequence, level);
	// printf("Drilling up..., %f - %d * %f - 1 = %f\n", (double) sequenceCode, (q == '0'? 0: q == '1'? 1: q == '2'? 2: /* q == '3'? */ 3), (double) XZ_NUM_ELEMENTS_AT_LEVEL[level], (double) (sequenceCode - (q == '0'? 0: q == '1'? 1: q == '2'? 2: /* q == '3'? */ 3) * XZ_NUM_ELEMENTS_AT_LEVEL[level] - 1));
	scHigherLevel = sequenceCode - XZ_Q(q) * XZ_NUM_ELEMENTS_AT_LEVEL[level] - 1;
	level--; // We're now at one level higher.
	xzAddInterval(intervalBAT, scHigherLevel, scHigherLevel);
	// printf("Drill up, level %d, sequence code %f\n", level, (double) scHigherLevel);
	
	/* Also include the codes of the element neighbouring in the South, SouthWest
	 * and West, because the enlarged regions of these extend over us.
	 */
	// South
	qsShift[0] = '\0'; strncat(qsShift, quadrantSequence, level); // Almost the same; just without the last character.
	scShift = scHigherLevel;
	xzShiftSouth(&scShift, qsShift, level);
	xzAddInterval(intervalBAT, scShift, scShift);
	// printf("Drill up, level %d, sequence code %f\n", level, (double) scShift);
	// SouthWest
	xzShiftWest(&scShift, qsShift, level);
	xzAddInterval(intervalBAT, scShift, scShift);
	// printf("Drill up, level %d, sequence code %f\n", level, (double) scShift);
	// West
	qsShift[0] = '\0'; strncat(qsShift, quadrantSequence, level);
	scShift = scHigherLevel;
	xzShiftWest(&scShift, qsShift, level);
	xzAddInterval(intervalBAT, scShift, scShift);
	// printf("Drill up, level %d, sequence code %f\n", level, (double) scShift);
	
	/* Now do the next higher level
	 */
	qsShift[0] = '\0'; strncat(qsShift, quadrantSequence, level);
	scShift = scHigherLevel;
	xzDrillUp(scShift, qsShift, level, intervalBAT);
}

/* Macro XZ_SUITABLE_LEVEL
 * In the XZ-Ordering paper, there's a complex algorithm for determining a
 * suitable level to drill down to, given a certain number of intervals wanted.
 * However, this doesn't need to be very exact, it's only needed to put some
 * limit in how far we want to drill down. The only thing that this limit must
 * take into account is that the deeper the starting level is, the higher the
 * impact is of drilling down 1 level deeper. The sqrt below takes care of that.
 * 
 * In fact, the current implementation DOESN'T DRILL DOWN AT ALL.
 * 
 */
#define XZ_SUITABLE_LEVEL(baseLevel) \
baseLevel
/*
// baseLevel >= XZ_LEVEL_MAX? XZ_LEVEL_MAX: \
// (size_t) (baseLevel + ceil( (XZ_LEVEL_MAX - baseLevel) / sqrt(XZ_LEVEL_MAX - baseLevel) ))
*/

/* Macro XZ_MAX_SEQUENCE_CODE_INSIDE
 * For example, with XZ_LEVEL_MAX = 3:
 * XZ_NUM_ELEMENTS_AT_LEVEL[0] = 85
 * XZ_MAX_SEQUENCE_CODE_INSIDE(0 (quadrantSequence "")) = 0 + 85 - 1 = 84
 * XZ_NUM_ELEMENTS_AT_LEVEL[1] = 21
 * XZ_MAX_SEQUENCE_CODE_INSIDE(1 (quadrantSequence "0")) = 1 + 21 - 1 = 21
 * XZ_NUM_ELEMENTS_AT_LEVEL[2] = 5
 * XZ_MAX_SEQUENCE_CODE_INSIDE(80 (quadrantSequence "33")) = 80 + 5 - 1 = 84
 * XZ_NUM_ELEMENTS_AT_LEVEL[3] = 1
 * XZ_MAX_SEQUENCE_CODE_INSIDE(34 (quadrantSequence "120")) = 34 + 1 - 1 = 34
 */
#define XZ_MAX_SEQUENCE_CODE_INSIDE(sequenceCode, level) \
sequenceCode + XZ_NUM_ELEMENTS_AT_LEVEL[level] - 1

#define TYPE_geom_filter ATOMindex("geom_filter")

/* Function xzCompressIntervals
 * Returns a BAT with the intervals from intervalBAT, with double entries and
 * overlap weeded out.
 * intervalBAT is freed, the result must be freed by the caller.
 */
static
BAT*
xzCompressIntervals(
	BAT* intervalBAT /* IN */
)
{
	BUN iBun, lastBun, nextBun;
	size_t bunSize;
	xzSequence from, to;
	BAT* compressedBAT = BATnew(TYPE_geom_filter, TYPE_geom_filter, BATcount(intervalBAT));
	
	// Sort on head.
	BATorder(intervalBAT);
	// Loop over the sorted intervals.
	BATloopFast(intervalBAT, iBun, lastBun, bunSize) {
		from = *(xzSequence*) BUNhloc(intervalBAT, iBun);
		to = *(xzSequence*) BUNtloc(intervalBAT, iBun);
		// See if we can merge it with the next interval.
		for (nextBun = iBun + bunSize; nextBun < lastBun; nextBun += bunSize) {
			xzSequence nextFrom, nextTo;
			nextFrom = *(xzSequence*) BUNhloc(intervalBAT, nextBun);
			if (nextFrom > to + 1)
				break;
			// Else, we'll merge the next interval with the current one.
			// The BATloop may skip this one.
			iBun = nextBun;
			// Enlarge the current interval if the next stretches further.
			nextTo = *(xzSequence*) BUNtloc(intervalBAT, nextBun);
			if (nextTo > to)
				to = nextTo;
		}
		xzAddInterval_noExtend(compressedBAT, from, to);
	}
	BBPreclaim(intervalBAT);
	xzCloseIntervalBAT(compressedBAT, TRUE, TRUE, TRUE, TRUE);
	return compressedBAT;
}

/* Function xzOverlap
 * Returns the intervals of sequence codes that correspond with >= all enlarged
 * regions that overlap with that of the given sequence code.
 */
BAT*
xzOverlap(
	xzSequence baseCode
)
{
	/* By using 4 different variables, instead of reusing 1, the code becomes more
	 * eligible for parallel execution.
	 */
	xzSequence scN, scE, scS, scW;
	char qsN[XZ_LEVEL_MAX + 1] = "", qsE[XZ_LEVEL_MAX + 1] = "", qsS[XZ_LEVEL_MAX + 1] = "", qsW[XZ_LEVEL_MAX + 1] = "";
	size_t level, maxLevel;
	BAT* intervalBAT = BATnew(TYPE_geom_filter, TYPE_geom_filter, 600);

	xzQuadrantSequence(scN = baseCode, qsN);
	level = strlen(qsN);

	/* It's important to start at the base element again as soon as possible,
	 * instead of only moving around it, since it can well be that underway,
	 * you shifted out of the universe and then cannot shift back in again.
	 */
	
	// Everything inside the element self.
	xzAddInterval(intervalBAT, baseCode, XZ_MAX_SEQUENCE_CODE_INSIDE(baseCode, level));
	// printf("Center %f - %f\n", (double) baseCode, (double) XZ_MAX_SEQUENCE_CODE_INSIDE(baseCode, level));
	
	if (level == 0) {
		xzCloseIntervalBAT(intervalBAT, TRUE, TRUE, TRUE, TRUE);
		return intervalBAT;
	}
	
	// And the containing elements at higher levels.
	// Drill up
	xzDrillUp(baseCode, qsN, level, intervalBAT);
	
	// Also, everything in the other 3 elements that make up the enlarged region.
	
	// North
	xzShiftNorth(&scN, qsN, level);
	xzAddInterval(intervalBAT, scN, XZ_MAX_SEQUENCE_CODE_INSIDE(scN, level));
	// printf("North %f - %f\n", (double) scN, (double) XZ_MAX_SEQUENCE_CODE_INSIDE(scN, level));
	// Drill up
	xzDrillUp(scN, qsN, level, intervalBAT);

	// NorthEast
	xzShiftEast(&scN, qsN, level);
	xzAddInterval(intervalBAT, scN, XZ_MAX_SEQUENCE_CODE_INSIDE(scN, level));
	// printf("North East %f - %f\n", (double) scN, (double) XZ_MAX_SEQUENCE_CODE_INSIDE(scN, level));
	// Drill up
	xzDrillUp(scN, qsN, level, intervalBAT);
	
	// East
	xzQuadrantSequence(scE = baseCode, qsE);
	xzShiftEast(&scE, qsE, level);
	xzAddInterval(intervalBAT, scE, XZ_MAX_SEQUENCE_CODE_INSIDE(scE, level));
	// printf("East %f - %f\n", (double) scE, (double) XZ_MAX_SEQUENCE_CODE_INSIDE(scE, level));
	// Drill up
	xzDrillUp(scE, qsE, level, intervalBAT);
	
	// And, everything neighbouring at the South and West sides. At this level,
	// but also at deeper levels. Maybe not all the way down to the deepest level,
	// since that would yield a high number of intervals, without really adding
	// much information.
	maxLevel = XZ_SUITABLE_LEVEL(level);
	// printf("base level %d, suitable level %d\n", level, maxLevel);
	
	// South East
	xzShiftSouth(&scE, qsE, level);
	xzAddInterval(intervalBAT, scE, scE);
	// printf("South East %f\n", (double) scE);
	// Drill down
	xzDrillDownNorth(scE, level, &maxLevel, intervalBAT);
	
	// South
	xzQuadrantSequence(scS = baseCode, qsS);
	xzShiftSouth(&scS, qsS, level);
	xzAddInterval(intervalBAT, scS, scS);
	// printf("South %f\n", (double) scS);
	// Drill down
	xzDrillDownNorth(scS, level, &maxLevel, intervalBAT);
	
	// South West
	xzShiftWest(&scS, qsS, level);
	xzAddInterval(intervalBAT, scS, scS);
	// printf("South West %f\n", (double) scS);
	// Drill down
	xzDrillDownNorthEast(scS, level, &maxLevel, intervalBAT);
	
	// West
	xzQuadrantSequence(scW = baseCode, qsW);
	xzShiftWest(&scW, qsW, level);
	xzAddInterval(intervalBAT, scW, scW);
	// printf("West %f\n", (double) scW);
	// Drill down
	xzDrillDownEast(scW, level, &maxLevel, intervalBAT);
	
	// North West
	xzShiftNorth(&scW, qsW, level);
	xzAddInterval(intervalBAT, scW, scW);
	// printf("North West %f\n", (double) scW);
	// Drill down
	xzDrillDownEast(scW, level, &maxLevel, intervalBAT);

	xzCloseIntervalBAT(intervalBAT, FALSE, FALSE, TRUE, TRUE);	
	return xzCompressIntervals(intervalBAT);

}

const char *
geom_type2str(int t)
{
	switch(t) {
	case wkbPoint: return "Point";
      	case wkbLineString: return "Line";
	case wkbPolygon: return "Polygon";
	case wkbMultiPoint: return "MultiPoint";
	case wkbMultiLineString: return "MultiLine";
	case wkbMultiPolygon: return "MultiPolygon";
	case wkbGeometryCollection: return "GeomCollection";
	}
	return "unknown";
}


