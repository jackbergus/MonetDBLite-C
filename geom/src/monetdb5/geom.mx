@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2007 CWI.
@' All Rights Reserved.

@f geom
@a Wouter Scherphof, Niels Nes
@* The simple geom module

@mal
module geom;

atom mbr:lng;

command tostr() :str 		address mbrTOSTR;
command fromstr() :mbr		address mbrFROMSTR;
command hash() :int    		address mbrHASH;
command null() :int   		address mbrNULL;
command comp() :int		address mbrCOMP;
#command read()    		address mbrREAD;
#command write()   		address mbrWRITE;
#command convert() 		address mbrCONVERT;

atom wkb;

command tostr() :str 		address wkbTOSTR;
command fromstr() :wkb		address wkbFROMSTR;
command nequal() :int		address wkbNEQUAL;
command hash() :int    		address wkbHASH;
command null() :int   		address wkbNULL;
command read()    		address wkbREAD;
command write()   		address wkbWRITE;

command put() :int		address wkbPUT;
command del() :int		address wkbDEL;
command length() :int		address wkbLENGTH;
command heap() :int		address wkbHEAP;

command wkb(v:str) :wkb address wkbFromString;
command FromText(w:str, type:int) :wkb	address wkbFromText;

@= types
function @1FromText( wkt:str ) :wkb;
	x := wkb.FromText(wkt,@3);
	return x;
end @1FromText;

@mal
@:types(Geom,geometry,7)@
@:types(Point,point,1)@
@:types(Curve,curve,2)@
@:types(Line,linestring,2)@
@:types(Surface,surface,3)@
@:types(Poly,polygon,3)@


module geom;

command AsText(w:wkb) :str	address wkbAsText;
command mbr(:flt,:flt,:flt,:flt) :mbr 
address ordinatesMBR
comment "Creates the mbr for the given (xmin,ymin) and (xmax,ymax).";
   
command mbr(:wkb) :mbr 
address wkbMBR
comment "Creates the mbr for the given wkb.";

command mbr(:bat[:any_1,:wkb]) :bat[:any_1,:mbr]
address bat_wkbMBR
comment "Creates the mbr's for the given wkb's.";

command prelude():void 	address geom_prelude;
command epilogue():void address geom_epilogue;
   
geom.prelude();

module calc;

command wkb(v:str) :wkb address wkbFromString;

@= ctypes
function @2( wkt:str ) :wkb;
	x := wkb.FromText(wkt,@3);
	return x;
end @2;
@mal
@:ctypes(Geom,geometry,7)@
@:ctypes(Point,point,1)@
@:ctypes(Curve,curve,2)@
@:ctypes(Line,linestring,2)@
@:ctypes(Surface,surface,3)@
@:ctypes(Poly,polygon,3)@

@h
#ifndef GEOM_H
#define GEOM_H

#include "libgeom.h"

#ifdef WIN32
#ifndef GEOM
#define geom_export extern __declspec(dllimport)
#else
#define geom_export extern __declspec(dllexport)
#endif
#else
#define geom_export extern
#endif

geom_export wkb * wkbNULL(void);

#endif /* GEOM_H */

@c

#include <geom_config.h>
#include <mal.h>
#include <mal_atom.h>
#include <mal_exception.h>
#include "geom.h"

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <time.h>

static int TYPE_mbr;

bat*
geom_prelude(void)
{
	libgeom_init();
	TYPE_mbr = malAtomSize(sizeof(mbr), sizeof(oid), "mbr");
	return NULL;	
}

void
geom_epilogue(void)
{
	libgeom_exit();
}

/*
 * Implementation of fixed-sized atom mbr.
 */
static int
mbr_isnil(mbr *mbr)
{
	if (!mbr || mbr->xmin == flt_nil || mbr->ymin == flt_nil ||
	            mbr->xmax == flt_nil || mbr->ymax == flt_nil )
		return 1;
	return 0;
}

/* NULL: generic nil mbr. */
/* returns a pointer to a nil-mbr. */
mbr*
mbrNULL(void)
{
	static mbr mbrNIL;
	mbrNIL.xmin = flt_nil;
	mbrNIL.ymin = flt_nil;
	mbrNIL.xmax = flt_nil;
	mbrNIL.ymax = flt_nil;
	return (&mbrNIL);
}

/* FROMSTR: parse string to mbr. */
/* return number of parsed characters. */
int
mbrFROMSTR(
   char*	src,	/* IN: to-be-parsed string. */
   int*		len,	/* INOUT: length of area pointed to by atom [may need enlarging!] */
   mbr**	atom	/* INOUT: ptr to atom-ptr [may need (re-)alloc!] */
)
{
	int nil = 0;
	int nchars = 0; /* The number of characters parsed; the return value. */
	GEOSGeom geosMbr = NULL; /* The geometry object that is parsed from the src string. */
	
	if (strcmp(src, str_nil) == 0) 
		nil = 1;

	if (!nil && (geosMbr = GEOSGeomFromWKT(src)) == NULL)
		return 0;

	if (*len < (int)sizeof(mbr)) {
		if (*atom) GDKfree(*atom);
		*atom = GDKmalloc(*len = sizeof(mbr));
	}
	if (nil) {
		nchars = 3;
		**atom = *mbrNULL();
	} else if (getMbrGeos(*atom, geosMbr))
		nchars = strlen(src);
	if (geosMbr)
		GEOSGeom_destroy(geosMbr);
	return nchars;
}

#define MBR_WKTLEN 256

/* TOSTR: print atom in a string. */
/* return length of resulting string. */
int
mbrTOSTR(
   char**	dst,	/* INOUT: dst charbuffer [maybe 0, may need realloc]*/
   int*		len,	/* INOUT: length of buffer */
   mbr*	atom	/* IN: to-be-printed mbr. */
)
{
	static char tempWkt[MBR_WKTLEN];
	size_t dstStrLen = 3;
	
	if (!mbr_isnil(atom)) {
		snprintf(tempWkt, MBR_WKTLEN, "BOX (%f %f, %f %f)",
			atom->xmin, atom->ymin,
			atom->xmax, atom->ymax
		);
		dstStrLen = strlen(tempWkt);
	}
	
	if (*len < (int) dstStrLen + 1) { 
		if (*dst) GDKfree(*dst);
		*dst = GDKmalloc(*len = dstStrLen + 1);
	}
	
	if (dstStrLen > 3)
		strcpy(*dst, tempWkt);
	else
		strcpy(*dst, "nil");
	return dstStrLen;
}

/* HASH: compute a hash value. */
/* returns a positive integer hash value */
hash_t
mbrHASH(
   mbr*	atom	/* IN: to-be-hashed mbr. */
)
{
	return (hash_t) ( (((int) atom->xmin) * ((int) atom->ymin)) * (((int) atom->xmax) * ((int) atom->ymax)) );
}

/* COMP: compare two mbrs. */
/* returns int <0 if l<r, 0 if l==r, >0 else */
int
mbrCOMP(
   mbr*	l,	/* IN: first geom_point. */
   mbr*	r	/* IN: second geom_point. */
)
{
	/* For now, lexicographical ordering on (x,y)
	// TODO: involve xzEncode() to get an ordering on spatial proximity.
	*/
	int res;
	if (l->xmin == r->xmin)
		res = (l->ymin < r->ymin)? -1: (l->ymin == r->ymin)? 0: 1;
	else 
		res = (l->xmin < r->xmin)? -1: 1;
	if (res == 0) {
		if (l->xmax == r->xmax)
			res = (l->ymax < r->ymax)? -1: (l->ymax == r->ymax)? 0: 1;
		else 
			res = (l->xmax < r->xmax)? -1: 1;
	}
	return res;
}

/*
 * Implementation of variable-sized atom wkb.
 */

static size_t
wkb_size(size_t len)
{
	if (len == ~(size_t) 0)
		len = 0;
	return sizeof(wkb) - 1 + len;
}

/* TOSTR: print atom in a string. */
/* return length of resulting string. */
int
wkbTOSTR(
   char**	dst,	/* INOUT: dst charbuffer [maybe 0, may need realloc]*/
   int*		len,	/* INOUT: length of buffer */
   wkb*	atom	/* IN: to-be-printed geom_geometry. */
)
{
	char* wkt = NULL;
	int dstStrLen = 3; /* "nil" */
	GEOSGeom geosGeometry = wkb2geos(atom);
	
	if (geosGeometry) {
		wkt = GEOSGeomToWKT(geosGeometry);
		dstStrLen = strlen(wkt);
		GEOSGeom_destroy(geosGeometry);
	}
	
	if (*len < dstStrLen + 1) { /* + 1 for the '\0' */
		if (*dst) GDKfree(*dst);
		*dst = GDKmalloc(*len = dstStrLen + 1);
	}
	
	if (wkt) {
		strcpy(*dst, wkt);
		free(wkt);
	} else {
		strcpy(*dst, "nil");
	}

	return dstStrLen;
}

/* FROMSTR: parse string to @1. */
/* return number of parsed characters. */
int
wkbFROMSTR(
   char*	src,	/* IN: to-be-parsed string. */
   int*		len,	/* INOUT: length of area pointed to by atom [may need enlarging!] */
   wkb**	atom	/* INOUT: ptr to atom-ptr [may need (re-)alloc!] */
)
{
	GEOSGeom geosGeometry = NULL; /* The geometry object that is parsed from the src string. */
	unsigned char* wkb = NULL; /* The "well known binary" serialization of the geometry object. */
	size_t wkbLen = 0; /* The length of the wkb string. */
	int nil = 0;

	if (strcmp(src, str_nil) == 0) 
		nil = 1;

	if (!nil && (geosGeometry = GEOSGeomFromWKT(src)) == NULL)
		return 0;
	
	if (!nil && GEOSGeomTypeId(geosGeometry) == -1) {
		GEOSGeom_destroy(geosGeometry);
		return 0;
	}

	if (!nil) {
		wkb = GEOSGeomToWKB_buf(geosGeometry, &wkbLen);
		GEOSGeom_destroy(geosGeometry);
	}
	if (*len < (int)wkb_size(wkbLen)) {
		if (*atom) GDKfree(*atom);
		*atom = GDKmalloc(*len = (int)wkb_size(wkbLen));
	}
	if (!wkb) {
		**atom = *wkbNULL();
	} else {
		(*atom)->len = wkbLen;
		memcpy(&(*atom)->data, wkb, wkbLen);
		free(wkb);
	}
	return strlen(src);
}

str
wkbFromString(wkb **w, str *wkt)
{
	int len = 0;

	if (wkbFROMSTR(*wkt, &len, w))
		return MAL_SUCCEED;
	throw(MAL, "wkb.FromString", GDKerrbuf);
}

str
wkbFromText(wkb **w, str *wkt, int *tpe)
{
	int len = 0, te = *tpe;

	*w = NULL;
	if (wkbFROMSTR(*wkt, &len, w) && 
	    (wkb_isnil(*w) ||
	     *tpe == wkbGeometryCollection || (te = (((*w)->data[1])&0x0f)) == *tpe ))
		return MAL_SUCCEED;
	if (!(*w))
		*w = (wkb*)GDKmalloc(sizeof(wkb));
	*w = wkbNULL();
	if (te != *tpe) 
		throw(MAL, "wkb.FromText", "Geometry type '%s' not found", geom_type2str(*tpe));
	throw(MAL, "wkb.FromText", GDKerrbuf);
}

hash_t
wkbHASH(wkb *w)
{
	int i;
	hash_t h = 0;

	for (i = 0; i<(w->len-1); i+=2) {
		int a = w->data[i], b = w->data[i+1];
                h = (h << 3) ^ (h >> 11) ^ (h >> 17) ^ (b << 8) ^ a;
	}
	return h;
}

int
wkbNEQUAL(wkb *l, wkb *r)
{
	int len = l->len;

	if (len != r->len)
		return (1);

	if (len == ~(int) 0)
		return (0);

	return memcmp(l->data, r->data, len) != 0;
}

wkb *
wkbNULL(void)
{
	static wkb nullval;

	nullval.len = ~(int) 0;
	return (&nullval);
}

str
wkbAsText(str *r, wkb** w) 
{
	int len = 0;

	wkbTOSTR(r, &len, *w);
	if (len)
		return MAL_SUCCEED;
	throw(MAL, "geom.AsText", "Failed to create Text from Well Known Format");
}

void
wkbDEL(Heap *h, var_t *index)
{
	HEAP_free(h, *index);
}

wkb *
wkbREAD(wkb *a, stream *s, size_t cnt)
{
	int len;

	(void) cnt;
	assert(cnt == 1);
	if (!stream_readInt(s, &len))
		return NULL;
	if ((a = GDKmalloc(wkb_size(len))) == NULL)
		return NULL;
	a->len = len;
	if (len > 0 && stream_read(s, (char *) a->data, len, 1) != 1) {
		GDKfree(a);
		return NULL;
	}
	return a;
}

void
wkbWRITE(wkb *a, stream *s, size_t cnt)
{
	int len = a->len;

	(void) cnt;
	assert(cnt == 1);
	if (stream_writeInt(s, len) && len > 0) /* 64bit: check for overflow */
		stream_write(s, (char *) a->data, len, 1);
}

void
wkbCONVERT(wkb *b, int direction)
{
	(void) direction;
	b->len = normal_int_SWAP(b->len);
}

int
wkbLENGTH(wkb *p)
{
	return wkb_size(p->len);
}

void
wkbHEAP(Heap *heap, size_t capacity)
{
	HEAP_initialize(heap, capacity, 0, (int) sizeof(var_t));
}

var_t
wkbPUT(Heap *h, var_t *bun, wkb *val)
{
	char *base;

	*bun = HEAP_malloc(h, wkb_size(val->len));
	base = h->base;
	if (*bun)
		memcpy(&base[*bun], (char *) val, wkb_size(val->len));
	return *bun;
}

/* COMMAND mbr
 * Creates the mbr for the given geom_geometry.
 */
str
ordinatesMBR(
	mbr* res, /* INOUT. */
	flt* minX, /* IN. */
	flt* minY, /* IN. */
	flt* maxX, /* IN. */
	flt* maxY /* IN. */
)
{
	res->xmin = *minX;
	res->ymin = *minY;
	res->xmax = *maxX;
	res->ymax = *maxY;
	return MAL_SUCCEED;
}


/* COMMAND mbr
 * Creates the mbr for the given geom_geometry.
 */
str
wkbMBR(
	mbr* res, /* INOUT. */
	wkb** geom /* IN. */
)
{
	if (getMbrGeom(res, *geom))
		return MAL_SUCCEED;
	throw(MAL, "geom.mbr", "Failed to create mbr");
}

#define prepareOperand(X,Y,Z) \
	if( (X= BATdescriptor(*Y)) == NULL ) \
		throw(MAL, "geom." Z, "Cannot access descriptor");
#define prepareResult(X,Y,T,Z) \
	X= BATnew(Y->htype,T,BATcount(Y)); \
	if( Y->htype== TYPE_void) \
		BATseqbase(X, Y->hseqbase); \
	if( X == NULL){ \
		BBPreleaseref(Y->batCacheid); \
		throw(MAL, "geom." Z, "no space available "); \
	} \
	X->hsorted=Y->hsorted; \
	X->tsorted=0; 
#define finalizeResult(X,Y,Z) \
	if (!((Y)->batDirty&2)) (Y) = BATsetaccess((Y), BAT_READ); \
	*X = (Y)->batCacheid; \
	BBPkeepref(*(X));\
	BBPreleaseref(Z->batCacheid);
str 
bat_wkbMBR(int *ret, int *l)
{   
	BAT *bn, *b;
	BUN p,q;
	int xx;
	wkb *x;
	mbr y;

	prepareOperand(b,l,"mbr");
	prepareResult(bn,b,TYPE_mbr,"mbr");

	BATloopFast(b, p, q, xx) {
		mbr *yp = &y;
		ptr h = BUNhead(b,p);
		x = (wkb*)BUNtail(b,p);
		if (wkb_isnil(x))
			yp = mbrNULL();
		else 
			wkbMBR(yp,&x);
		bunfastins(bn, h, yp);
	}
	finalizeResult(ret,bn,b);
	return MAL_SUCCEED;
bunins_failed:
	BBPreleaseref(b->batCacheid);
	BBPunfix(bn->batCacheid);
	throw(MAL, "geom.mbr", "bunins failed");
}




@mal

# wkbPoint := 1;
# wkbLineString := 2;
# wkbPolygon := 3;
# wkbMultiPoint := 4;
# wkbMultiLineString := 5;
# wkbMultiPolygon := 6;
# wkbGeometryCollection := 7;

@mil
PROC oids( str cluster) : BAT[void, oid]
{
	return bat(cluster + "_geom_oid");
}
ADDHELP("oids",
	"Wouter Scherphof", "November 30 2006",
	"Returns the 'oid' bat from a geom_cluster.",
	"geom");

PROC voids( str cluster) : BAT[oid, void]
{
	return bat(cluster + "_geom_void");
}
ADDHELP("voids",
	"Wouter Scherphof", "November 30 2006",
	"Returns the 'void' bat from a geom_cluster.",
	"geom");

PROC filters( str cluster) : BAT[void, geom_filter]
{
	return bat(cluster + "_geom_filter");
}
ADDHELP("filters",
	"Wouter Scherphof", "November 30 2006",
	"Returns the 'filter' bat from a geom_cluster.",
	"geom");

PROC geoms( str cluster) : BAT[void, any]
{
	return bat(cluster + "_geom_geom");
}
ADDHELP("geoms",
	"Wouter Scherphof", "November 30 2006",
	"Returns the 'geom' bat from a geom_cluster.",
	"geom");

PROC mbrs( str cluster) : BAT[void, any]
{
	return bat(cluster + "_mbr");
}
ADDHELP("mbrs",
	"Wouter Scherphof", "November 30 2006",
	"Returns the 'mbr' bat from a geom_cluster.",
	"geom");

PROC universe( str cluster) : mbr
{
	return bat(cluster + "_geom_universe").fetch(0@0);
}
ADDHELP("universe",
	"Wouter Scherphof", "November 30 2006",
	"Returns the universe mbr from a geom_cluster.",
	"geom");

PROC geom_cluster( str name, BAT[void, wkb] geoms, mbr universe) : str
{
	# Compute filter codes.
	var filters:= [filter](geoms, universe);
	# Sort on filter code, i.e. sort on spatial proximity.
	filters := filters.reverse().sort().reverse();
	var clusterOids := filters.mark(0@0).reverse().rename(name + "_geom_oid").persists(true).access(BAT_READ);
	# inverse of clusterOids, to enable positional lookup of geoms with oid.
	clusterOids.sort().mark(0@0).reverse().rename(name + "_geom_void").persists(true).access(BAT_READ);
	filters.reverse().mark(0@0).reverse().rename(name + "_geom_filter").persists(true).access(BAT_READ);
	geoms.fetch(filters).reverse().mark(0@0).reverse().rename(name + "_geom_geom").persists(true).access(BAT_READ);
	# Compute minimum bounding rectangles.
	filters.destroy();
	var clusterUniverse := bat(void, mbr).rename(name + "_geom_universe").persists(true);
	clusterUniverse.seqbase(0@0);
	clusterUniverse.append(universe);
	clusterUniverse.access(BAT_READ);
	commit();
	return name;
}
ADDHELP("geom_cluster",
	"Wouter Scherphof", "November 29 2006",
	"Creates (and saves) the storage structure for a geometry column, given a name for it and the bounds of the universe.\nCreates a number of synced BATs, which can be retrieved with their respective procs: oids(cluster_name), voids(cluster_name), filters(cluster_name), geoms(cluster_name), mbrs(cluster_name) and universe(cluster_name).",
	"geom"
);

@mal
# Functions prescribed by OGC's SFA standard:

@mil
PROC geom_cluster_print( str cluster) : void
{
	print(cluster);
	print(cluster.universe());
	print(cluster.oids(), cluster.voids(), cluster.filters(), cluster.mbrs(), cluster.geoms());
}
ADDHELP("geom_cluster_print",
	"Wouter Scherphof", "November 30 2006",
	"Prints the contents of a geom_cluster.",
	"geom");

PROC geom_cluster_persists( str cluster, bit mode) : void
{
	cluster.oids().persists(mode);
	cluster.voids().persists(mode);
	cluster.filters().persists(mode);
	cluster.geoms().persists(mode);
	cluster.mbrs().persists(mode);
}
ADDHELP("geom_cluster_persists",
	"Wouter Scherphof", "November 30 2006",
	"Persists (or not) the contents of a geom_cluster.",
	"geom");

PROC geom_primary_filter( str cluster, wkb geom) : BAT[void, oid]
{
	var filterCode := geom.filter(cluster.universe());
	# Expand the filter code to a BAT[geom_filter, geom_filter] with [from, to] intervals.
	var filterIntervals := filterCode.expand();
	var filterVoids := geom_select_filter(cluster.filters(), filterIntervals);
	var mbrs := filterVoids.reverse().mirror().join(cluster.mbrs());
	var interactingMbrs := [interact](mbrs, geom.mbr()).uselect(true);
	return interactingMbrs.mirror().join(cluster.oids());
}
ADDHELP("geom_primary_filter",
	"Wouter Scherphof", "November 29 2006",
	"Quickly selects >= all geometries from the cluster that have a spatial interaction with the given @1.\nI.e. a set of 'candidates' is selected.\nReturns the ids from the originating unclustered geometry BAT in the tail and the local cluster oids in the head.\nThe given @1's coordinates must be in the same universe as the cluster geometries.",
	"geom");

# module(alarm);

PROC geom_primary_filter( str cluster1, str cluster2) : BAT[oid, oid]
{
	if (not( cluster1.universe() = cluster2.universe() )) {
		print("!ERROR: The two geometry clusters are in different universes.");
		cluster1.geom_cluster_print();
		cluster2.geom_cluster_print();
		return nil;
	}
	var count1 := cluster1.oids().count();
	var count2 := cluster2.oids().count();
	var outerCluster, innerCluster;
	if (count1 < count2) {
		outerCluster := cluster1;
		innerCluster := cluster2;
	}
	else {
		outerCluster := cluster2;
		innerCluster := cluster1;
	}
	var outerType := outerCluster.geoms().ttype();
	var innerType := innerCluster.geoms().ttype();
	var innerFilters := innerCluster.filters();
	var outerMbrs := outerCluster.mbrs();
	var innerMbrs := innerCluster.mbrs();
	var res := bat(oid, oid);
#		var tt, tExpand := 0.0, tSelectFilter := 0.0, tJoinInnerMbrs := 0.0, tInteract := 0.0, tProject := 0.0, tInsert := 0.0, filterCount := 0;
	outerCluster.filters()@batloop() {
#			tt := usec();
		var filterIntervals := $t.expand();
#			tExpand := tExpand + ((usec() - tt) / 1000000.0);
#			tt := usec();
		var matches := geom_select_filter(innerFilters, filterIntervals);  # BAT[void, inner-cluster-oid]
#			tSelectFilter := tSelectFilter + ((usec() - tt) / 1000000.0);
#			filterCount := filterCount + matches.count();
#			tt := usec();
		matches := matches.reverse().mirror().join(innerMbrs);  # BAT[inner-cluster-oid, inner-mbr]
#			tJoinInnerMbrs := tJoinInnerMbrs + ((usec() - tt) / 1000000.0);
#			tt := usec();
		matches := [interact](matches, outerMbrs.fetch($h)).uselect(true);  # BAT[inner-cluster-oid, void]
#			tInteract := tInteract + ((usec() - tt) / 1000000.0);
#			tt := usec();
		matches := matches.project($h).reverse();  # BAT[outer-cluster-oid, inner-cluster-oid]
#			tProject := tProject + ((usec() - tt) / 1000000.0);
#			tt := usec();
		res.insert(matches);
#			tInsert := tInsert + ((usec() - tt) / 1000000.0);
#			tt := usec();
	}
	res := res.access(BAT_READ);
	res := res.join(innerCluster.oids());  # BAT[outer-cluster-oid, inner-original-oid]
	res := res.reverse().join(outerCluster.oids()).reverse();  # BAT[outer-original-oid, inner-original-oid]
#		print("cross product count: " + str(cluster1.oids().count() * cluster2.oids().count()));
#		print("filter count: " + filterCount);
#		print("res count: " + res.count());
#		print("tExpand: " + tExpand);
#		print("tSelectFilter: " + tSelectFilter);
#		print("tJoinInnerMbrs: " + tJoinInnerMbrs);
#		print("tInteract: " + tInteract);
#		print("tProject: " + tProject);
#		print("tInsert: " + tInsert);
	if (count1 >= count2)
		res := res.reverse();
	return res.sort();
}
ADDHELP("geom_primary_filter",
	"Wouter Scherphof", "November 30 2006",
	"Quickly selects for each geometry in cluster 1 >= all geometries from cluster2 that have a spatial interaction with it.\nI.e. a set of 'candidate' geometry pairs for a spatial join is selected.\nReturns the ids from the originating unclustered geometry BATs.\nBoth clusters must be in the same universe.",
	"geom");


# utility procs

PROC store_ascii_io( str name, BAT[str, BAT] table, mbr universe) : void
{
	var tableName := table.bbpname();
	table@batloop() {
		var tp := $t.ttype();
		if (
			(tp = geom_point) or
			(tp = geom_geometry) or
			(tp = geom_curve) or
			(tp = geom_linestring) or
			(tp = geom_surface) or
			(tp = geom_polygon)
		) {
			geom_cluster(name + "_" + $h, $t, universe);
			$t.destroy();
		}
		else {
			$t.rename(name + "_" + $h).persists(true).access(BAT_READ);
		}
	}
	commit();
}
