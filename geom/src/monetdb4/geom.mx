@' tHE COntents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2007 CWI.
@' All Rights Reserved.

@f geom
@a Wouter Scherphof, Niels Nes
@* The simple geom module

@m
.MODULE geom;

   .PRELUDE = geom_prelude;
   .EPILOGUE = geom_epilogue;
   
   .ATOM mbr [16];
     .FROMSTR = mbrFROMSTR;
     .TOSTR   = mbrTOSTR;
     .HASH    = mbrHASH;
     .COMP    = mbrCOMP;
     .NULL    = mbrNULL;
   .END;

   .ATOM wkb;
     .TOSTR   = wkbTOSTR;
     .FROMSTR = wkbFROMSTR;

     .NEQUAL   = wkbNEQUAL;
     .HASH     = wkbHASH;
     .NULL     = wkbNULL;
     .READ     = wkbREAD;
     .WRITE    = wkbWRITE;

     .PUT      = wkbPUT;
     .DEL      = wkbDEL;
     .LENGTH   = wkbLENGTH;
     .HEAP     = wkbHEAP;
   .END;

   .COMMAND wkb_from_text(str wkt, int tpe) : wkb = wkbFromText;
   "Try to creates the a wkb of type, tpe, from the given wkt."

   .COMMAND mbr(flt,flt,flt,flt) : mbr = ordinatesMBR;
   "Creates the mbr for the given (xmin,ymin) and (xmax,ymax)."
   
   .COMMAND mbr(wkb) : mbr = wkbMBR;
   "Creates the mbr for the given wkb."

@+ ogc basic methods
@m
   .COMMAND Dimension( wkb w) : int = wkbDimension;
   "The inherent dimension of this geometry object, which must be less than or equal
    to the coordinate dimension. 
    This specification is restricted to geometries in two-dimensional coordinate space."

   .COMMAND GeometryType(wkb w) : str = wkbGeometryType;
   "Returns the name of the instantiable subtype of Geometry of which this 
    Geometry instance is a member. The name of the instantiable subtype of Geometry is returned as string."

   .COMMAND SRID(wkb w) : int = wkbSRID;
   "Returns the Spatial Reference System ID for this Geometry."

   .COMMAND Envelope(wkb w): wkb = wkbEnvelope;
   "The minimum bounding box for this Geometry, returned as a Geometry. The
    polygon is defined by the corner points of the bounding box 
    ((MINX,MINY),(MAXX,MINY),(MAXX,MAXY),(MINX,MAXY))."

   .COMMAND IsEmpty(wkb w): bit = wkbIsEmpty;
   "Returns true if this Geometry is the empty geometry. If true, then this 
    Geometry represents the empty point set, for the coordinate space."

   .COMMAND IsSimple(wkb w): bit = wkbIsSimple;
   "Returns true if this Geometry has no anomalous geometric points, such as self
    intersection or self tangency. The description of each instantiable geometric class will include the specific
    conditions that cause an instance of that class to be classified as not simple."

   .COMMAND Boundary(wkb w): wkb = wkbBoundary;
   "Returns the closure of the combinatorial boundary of this Geometry." 

@+ ogc spatial relation methods
@m

   .COMMAND Equals(wkb a, wkb b) : bit = wkbEquals;
   	"Returns true if these Geometries are 'spatially equal'"

   .COMMAND Disjoint(wkb a, wkb b) : bit = wkbDisjoint;
   	"Returns true if these Geometries are 'spatially disjoint'"

   .COMMAND Intersect(wkb a, wkb b) : bit = wkbIntersect;
   	"Returns true if these Geometries 'spatially intersect'"

   .COMMAND Touches(wkb a, wkb b) : bit = wkbTouches;
   	"Returns true if these Geometries 'spatially touch' each other"

   .COMMAND Crosses(wkb a, wkb b) : bit = wkbCrosses;
   	"Returns true if the Geometry a 'spatially crosses' Geometry b"

   .COMMAND Within(wkb a, wkb b) : bit = wkbWithin;
   	"Returns true if the Geometry a 'spatially within' Geometry b"

   .COMMAND Contains(wkb a, wkb b) : bit = wkbContains;
   	"Returns true if the Geometry a 'spatially contains' Geometry b"

   .COMMAND Overlaps(wkb a, wkb b) : bit = wkbOverlaps;
   	"Returns true if the Geometry a 'spatially overlaps' Geometry b"

   .COMMAND Relate(wkb a, wkb b, str intersectionPatternMatrix) : bit = wkbRelate;
   	"Returns true if the Geometry a 'spatially related' to Geometry b, by testing for intersection between the
         Interior, Boundary and Exterior of the two geometries as specified by the values in the intersectionPatternMatrix."

@+ ogc Spatial Analysis methods

   .COMMAND Distance(wkb a, wkb b) : dbl = wkbDistance;
    	"Returns the shortest distance between any two points in the two geometries
         as calculated in the spatial reference system of this Geometries."

   .COMMAND Buffer(wkb a, dbl distance) : wkb = wkbBuffer;
    	"Returns a geometry that represents all points whose distance from this geometry is less than
	or equal to distance. Calculations are in the Spatial Reference System of this Geometry."

   .COMMAND ConvexHull(wkb a) : wkb = wkbConvexHull;
	"Returns a geometry that represents the convex hull of this geometry."

   .COMMAND Intersection(wkb a, wkb b): wkb = wkbIntersection;
   	"Returns a geometry that represents the point set intersection of Geometry a with b."

   .COMMAND Union(wkb a, wkb b): wkb = wkbUnion;
   	"Returns a geometry that represents the point set union of Geometry a with b."

   .COMMAND Difference(wkb a, wkb b): wkb = wkbDifference;
   	"Returns a geometry that represents the point set difference of Geometry a with b."

   .COMMAND SymDifference(wkb a, wkb b): wkb = wkbSymDifference;
   	"Returns a geometry that represents the point set semmetric difference of Geometry a with b."

@+
   .COMMAND interact(mbr, mbr) : bit = mbrINTERACTmbr;
   "Tests whether 2 mbr's spatially interact (i.e. whether they're not disjoint)."

   .COMMAND interact(wkb, mbr) : bit = wkbINTERACTmbr;
   "Tests whether a wkb and a mbr spatially interact (i.e. whether they're not disjoint)."

   .COMMAND interact(mbr, wkb) : bit = mbrINTERACTwkb;
   "Tests whether a mbr and a wkb spatially interact (i.e. whether they're not disjoint)."

   .COMMAND interact(wkb, wkb) : bit = wkbINTERACTwkb;
   "Tests whether 2 wkbs spatially interact (i.e. whether they're not disjoint)."
   
@m
   .ATOM geom_filter = int;
   .END;
   
   .COMMAND filter(wkb, mbr) : geom_filter = wkbFILTER;
   "Computes the filter code to use in the primary filter, given a universe that is bounded by the given mbr."

   .COMMAND expand(geom_filter) : BAT[geom_filter, geom_filter] = geom_filterEXPAND;
   "Returns a set of intervals of filter codes that can be used by the primary_filter procs to quickly select >= all geometries that interact with another geometry, given its filter code."

   .COMMAND geom_select_filter(BAT[void, geom_filter], BAT[geom_filter, geom_filter]) : BAT[void, oid] = geom_select_filterImpl;
   "Returns the oids of the filter codes from the filter BAT that are within the given set of intervals. The first argument contains the filter BAT of the concerned geometry cluster. The second argument is the set of intervals, as determined by expanding a filter code."
   
.END geom;

@h
#ifndef __geom_H__
#define __geom_H__

#include "libgeom.h"

#define point wkb
#define curve wkb
#define line wkb
#define surface wkb
#define poly wkb

#include "geom.proto.h"

#endif /* __geom_H__ */

@c

#include <geom_config.h>
#include <gdk.h>

#include "geom.h"

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <time.h>

bat*
geom_prelude(void)
{
	libgeom_init();
	return NULL;	
}

void
geom_epilogue(void)
{
	libgeom_exit();
}

/*
 * Implementation of fixed-sized atom mbr.
 */
static int
mbr_isnil(mbr *mbr)
{
	if (!mbr || mbr->xmin == flt_nil || mbr->ymin == flt_nil ||
	            mbr->xmax == flt_nil || mbr->ymax == flt_nil )
		return 1;
	return 0;
}

/* NULL: generic nil mbr. */
/* returns a pointer to a nil-mbr. */
mbr*
mbrNULL(void)
{
	static mbr mbrNIL;
	mbrNIL.xmin = flt_nil;
	mbrNIL.ymin = flt_nil;
	mbrNIL.xmax = flt_nil;
	mbrNIL.ymax = flt_nil;
	return (&mbrNIL);
}

/* FROMSTR: parse string to mbr. */
/* return number of parsed characters. */
int
mbrFROMSTR(
   char*	src,	/* IN: to-be-parsed string. */
   int*		len,	/* INOUT: length of area pointed to by atom [may need enlarging!] */
   mbr**	atom	/* INOUT: ptr to atom-ptr [may need (re-)alloc!] */
)
{
	int nil = 0;
	int nchars = 0; /* The number of characters parsed; the return value. */
	GEOSGeom geosMbr = NULL; /* The geometry object that is parsed from the src string. */
	
	if (strcmp(src, str_nil) == 0) 
		nil = 1;

	if (!nil && (geosMbr = GEOSGeomFromWKT(src)) == NULL)
		return 0;

	if (*len < (int)sizeof(mbr)) {
		if (*atom) GDKfree(*atom);
		*atom = GDKmalloc(*len = sizeof(mbr));
	}
	if (nil) {
		nchars = 3;
		**atom = *mbrNULL();
	} else if (getMbrGeos(*atom, geosMbr))
		nchars = strlen(src);
	if (geosMbr)
		GEOSGeom_destroy(geosMbr);
	return nchars;
}

#define MBR_WKTLEN 256

/* TOSTR: print atom in a string. */
/* return length of resulting string. */
int
mbrTOSTR(
   char**	dst,	/* INOUT: dst charbuffer [maybe 0, may need realloc]*/
   int*		len,	/* INOUT: length of buffer */
   mbr*	atom	/* IN: to-be-printed mbr. */
)
{
	static char tempWkt[MBR_WKTLEN];
	size_t dstStrLen = 3;
	
	if (!mbr_isnil(atom)) {
		snprintf(tempWkt, MBR_WKTLEN, "BOX (%f %f, %f %f)",
			atom->xmin, atom->ymin,
			atom->xmax, atom->ymax
		);
		dstStrLen = strlen(tempWkt);
	}
	
	if (*len < (int) dstStrLen + 1) { 
		if (*dst) GDKfree(*dst);
		*dst = GDKmalloc(*len = dstStrLen + 1);
	}
	
	if (dstStrLen > 3)
		strcpy(*dst, tempWkt);
	else
		strcpy(*dst, "nil");
	return dstStrLen;
}

/* HASH: compute a hash value. */
/* returns a positive integer hash value */
hash_t
mbrHASH(
   mbr*	atom	/* IN: to-be-hashed mbr. */
)
{
	return (hash_t) ( (((int) atom->xmin) * ((int) atom->ymin)) * (((int) atom->xmax) * ((int) atom->ymax)) );
}

/* COMP: compare two mbrs. */
/* returns int <0 if l<r, 0 if l==r, >0 else */
int
mbrCOMP(
   mbr*	l,	/* IN: first geom_point. */
   mbr*	r	/* IN: second geom_point. */
)
{
	/* For now, lexicographical ordering on (x,y)
	// TODO: involve xzEncode() to get an ordering on spatial proximity.
	*/
	int res;
	if (l->xmin == r->xmin)
		res = (l->ymin < r->ymin)? -1: (l->ymin == r->ymin)? 0: 1;
	else 
		res = (l->xmin < r->xmin)? -1: 1;
	if (res == 0) {
		if (l->xmax == r->xmax)
			res = (l->ymax < r->ymax)? -1: (l->ymax == r->ymax)? 0: 1;
		else 
			res = (l->xmax < r->xmax)? -1: 1;
	}
	return res;
}

/*
 * Implementation of variable-sized atom wkb.
 */

static size_t
wkb_size(size_t len)
{
	if (len == ~(size_t) 0)
		len = 0;
	return sizeof(wkb) - 1 + len;
}

/* TOSTR: print atom in a string. */
/* return length of resulting string. */
int
wkbTOSTR(
   char**	dst,	/* INOUT: dst charbuffer [maybe 0, may need realloc]*/
   int*		len,	/* INOUT: length of buffer */
   wkb*	atom	/* IN: to-be-printed geom_geometry. */
)
{
	char* wkt = NULL;
	int dstStrLen = 3; /* "nil" */
	GEOSGeom geosGeometry = wkb2geos(atom);
	
	if (geosGeometry) {
		wkt = GEOSGeomToWKT(geosGeometry);
		dstStrLen = strlen(wkt);
		GEOSGeom_destroy(geosGeometry);
	}
	
	if (*len < dstStrLen + 1) { /* + 1 for the '\0' */
		if (*dst) GDKfree(*dst);
		*dst = GDKmalloc(*len = dstStrLen + 1);
	}
	
	if (wkt) {
		strcpy(*dst, wkt);
		free(wkt);
	} else {
		strcpy(*dst, "nil");
	}

	return dstStrLen;
}

/* FROMSTR: parse string to @1. */
/* return number of parsed characters. */
int
wkbFROMSTR(
   char*	src,	/* IN: to-be-parsed string. */
   int*		len,	/* INOUT: length of area pointed to by atom [may need enlarging!] */
   wkb**	atom	/* INOUT: ptr to atom-ptr [may need (re-)alloc!] */
)
{
	GEOSGeom geosGeometry = NULL; /* The geometry object that is parsed from the src string. */
	unsigned char* wkb = NULL; /* The "well known binary" serialization of the geometry object. */
	size_t wkbLen = 0; /* The length of the wkb string. */
	int nil = 0;

	if (strcmp(src, str_nil) == 0) 
		nil = 1;

	if (!nil && (geosGeometry = GEOSGeomFromWKT(src)) == NULL)
		return 0;
	
	if (!nil && GEOSGeomTypeId(geosGeometry) == -1) {
		GEOSGeom_destroy(geosGeometry);
		return 0;
	}

	if (!nil) {
		wkb = GEOSGeomToWKB_buf(geosGeometry, &wkbLen);
		GEOSGeom_destroy(geosGeometry);
	}
	if (*len < (int)wkb_size(wkbLen)) {
		if (*atom) GDKfree(*atom);
		*atom = GDKmalloc(*len = (int)wkb_size(wkbLen));
	}
	if (!wkb) {
		**atom = *wkbNULL();
	} else {
		(*atom)->len = wkbLen;
		memcpy(&(*atom)->data, wkb, wkbLen);
		free(wkb);
	}
	return strlen(src);
}

int
wkbFromText(wkb **w, str wkt, int *tpe) 
{
	int len = 0;

	*w = NULL;
	if (wkbFROMSTR(wkt, &len, w) && 
	    (wkb_isnil(*w) ||
	     *tpe == wkbGeometryCollection || *tpe == (((*w)->data[1])&0x0f)))
		return GDK_SUCCEED;
	if (!(*w))
		*w = (wkb*)GDKmalloc(sizeof(wkb));
	**w = *wkbNULL();
	return GDK_FAIL;
}

hash_t
wkbHASH(wkb *w)
{
	int i;
	hash_t h = 0;

	for (i = 0; i<(w->len-1); i+=2) {
		int a = w->data[i], b = w->data[i+1];
                h = (h << 3) ^ (h >> 11) ^ (h >> 17) ^ (b << 8) ^ a;
	}
	return h;
}

int
wkbNEQUAL(wkb *l, wkb *r)
{
	int len = l->len;

	if (len != r->len)
		return (1);

	if (len == ~(int) 0)
		return (0);

	return memcmp(l->data, r->data, len) != 0;
}

wkb *
wkbNULL(void)
{
	static wkb nullval;

	nullval.len = ~(int) 0;
	return (&nullval);
}

void
wkbDEL(Heap *h, var_t *index)
{
	HEAP_free(h, *index);
}

wkb *
wkbREAD(wkb *a, stream *s, size_t cnt)
{
	int len;

	(void) cnt;
	assert(cnt == 1);
	if (!stream_readInt(s, &len))
		return NULL;
	if ((a = GDKmalloc(wkb_size(len))) == NULL)
		return NULL;
	a->len = len;
	if (len > 0 && stream_read(s, (char *) a->data, len, 1) != 1) {
		GDKfree(a);
		return NULL;
	}
	return a;
}

void
wkbWRITE(wkb *a, stream *s, size_t cnt)
{
	int len = a->len;

	(void) cnt;
	assert(cnt == 1);
	if (stream_writeInt(s, len) && len > 0) /* 64bit: check for overflow */
		stream_write(s, (char *) a->data, len, 1);
}

void
wkbCONVERT(wkb *b, int direction)
{
	(void) direction;
	b->len = normal_int_SWAP(b->len);
}

int
wkbLENGTH(wkb *p)
{
	return wkb_size(p->len);
}

void
wkbHEAP(Heap *heap, size_t capacity)
{
	HEAP_initialize(heap, capacity, 0, (int) sizeof(var_t));
}

var_t
wkbPUT(Heap *h, var_t *bun, wkb *val)
{
	char *base;

	*bun = HEAP_malloc(h, wkb_size(val->len));
	base = h->base;
	if (*bun)
		memcpy(&base[*bun], (char *) val, wkb_size(val->len));
	return *bun;
}

/* COMMAND mbr
 * Creates the mbr for the given geom_geometry.
 */
int
ordinatesMBR(
	mbr* res, /* INOUT. */
	flt* minX, /* IN. */
	flt* minY, /* IN. */
	flt* maxX, /* IN. */
	flt* maxY /* IN. */
)
{
	res->xmin = *minX;
	res->ymin = *minY;
	res->xmax = *maxX;
	res->ymax = *maxY;
	return GDK_SUCCEED;
}


/* COMMAND mbr
 * Creates the mbr for the given geom_geometry.
 */
int
wkbMBR(
	mbr* res, /* INOUT. */
	wkb* geom /* IN. */
)
{
	if (getMbrGeom(res, geom))
		return GDK_SUCCEED;
	return GDK_FAIL;
}


/* COMMAND filter
 * Compute the value to use in the primary filter,
 * given a universe stretching from (minX,minY) to (maxX, maxY).
 */
int
wkbFILTER(
	geom_filter* res, /* INOUT: The result. */
	wkb* geom, /* IN: The geom_geometry to operate on. */
	mbr* universe /* IN: The universe. */
)
{
	*res = xzEncodeWKB(universe, geom);

	if (*res < 0)
		return GDK_FAIL;

	return GDK_SUCCEED;
}

/* COMMAND expand
 * Quickly returns a set of intervals of filter codes that can be used to select 
 * >= all geometries that interact with the one with the given filter code.
 */
int
geom_filterEXPAND(
	BAT** res,
	geom_filter* filterCode
)
{
	*res = xzOverlap(*filterCode);
	return GDK_SUCCEED;
}

/* COMMAND geom_select_filterImpl
 * Returns the oids of the filter codes from the filter BAT that are within the 
 * given set of intervals.
 */
int
geom_select_filterImpl(
	BAT** res,
	BAT* filters,
	BAT* intervals
)
{
	BAT *r = NULL;
	BUN curInt, lstInt, fstFil, curFil, lstFil;
	int bunSzeInt, bunSzeFil, shift;
	oid *curRes, oidFil, sqbs;
	size_t cntRes, capRes;
	geom_filter fst, lst;

	BATcheck(filters, "geom_select_filter: filters");
	BATcheck(intervals, "geom_select_filter: intervals");
	ERRORcheck(!BAThdense(filters), "geom_select_filter: head of filters BAT not dense\n");
	ERRORcheck(!(BATtordered(filters)&1), "geom_select_filter: tail of filters BAT not sorted\n");
	ERRORcheck(!(BAThordered(intervals)&1), "geom_select_filter: head of intervals BAT not sorted\n");
		
	/* intervals must not overlap; hence, |res| <= |filters| */
	r = BATnew(TYPE_void, TYPE_oid, BATcount(filters));
	if (!r) {
		GDKerror("geom_select_filter: failed to allocate result BAT\n");
		return GDK_FAIL;
	}
	assert(BUNsize(r) == sizeof(oid));
	cntRes = 0;
	capRes = BATcapacity(r);
	curRes = (oid*) BUNtloc(r, BUNfirst(r));

	curFil = BUNtloc(filters, BUNfirst(filters));
	lstFil = BUNtloc(filters, BUNlast(filters));
	bunSzeFil = BUNsize(filters);
	fstFil = curFil - filters->hseqbase * bunSzeFil;
	shift = 1;
	while (bunSzeFil>>shift) shift++;
	shift--;

	lst = geom_filter_nil;
	BATloopFast(intervals, curInt, lstInt, bunSzeInt) {
		fst = *(geom_filter*) BUNhloc(intervals, curInt);
		assert(fst > lst); /* intervals must not overlap */
		lst = *(geom_filter*) BUNtloc(intervals, curInt);
		assert(fst <= lst); /* interval consistency */ 

		/* poor man's binary search / exploiting forward scan */
		while (curFil+1048576 < lstFil && *(geom_filter*) (curFil+1048576) < fst)
			curFil += 1048576; /* this avoids mmapped I/O */
		while (curFil+32768 < lstFil && *(geom_filter*) (curFil+32768) < fst)
			curFil += 32768;
		while (curFil+1024 < lstFil && *(geom_filter*) (curFil+1024) < fst)
			curFil += 1024;
		while (curFil+32 < lstFil && *(geom_filter*) (curFil+32) < fst)
			curFil += 32;
		while (curFil < lstFil && *(geom_filter*) curFil < fst)
			curFil += bunSzeFil;
		oidFil = ((curFil - fstFil) >> shift);

		/* collect results */
		while (curFil < lstFil && *(geom_filter*) curFil <= lst) {
			assert(cntRes < capRes); /* |res| <= |filters| */
			curRes[cntRes++] = oidFil++;
			curFil += bunSzeFil;
		}
	}
	
	/* set result count */
	r->batBuns->free = cntRes * BUNsize(r);
	BATsetcount(r, cntRes);

	/* set result properties */
	r->hdense = TRUE;
	BATseqbase(r, 0);
	r->hsorted = GDK_SORTED;
	BATkey(r, TRUE);
	sqbs = cntRes == 0 ? 0 : *(oid*)BUNtloc(r,BUNfirst(r));
	r->tdense = (cntRes < 2 && sqbs != oid_nil);
	if (r->tdense) {
		BATseqbase(BATmirror(r), sqbs);
	}
	r->tsorted = GDK_SORTED;
	BATkey(BATmirror(r), TRUE);

	*res = r;
	return GDK_SUCCEED;
}

@mil

const wkbPoint := 1;
const wkbLineString := 2;
const wkbPolygon := 3;
const wkbMultiPoint := 4;
const wkbMultiLineString := 5;
const wkbMultiPolygon := 6;
const wkbGeometryCollection := 7;

PROC oids( str cluster) : BAT[void, oid]
{
	return bat(cluster + "_geom_oid");
}
ADDHELP("oids",
	"Wouter Scherphof", "November 30 2006",
	"Returns the 'oid' bat from a geom_cluster.",
	"geom");

PROC voids( str cluster) : BAT[oid, void]
{
	return bat(cluster + "_geom_void");
}
ADDHELP("voids",
	"Wouter Scherphof", "November 30 2006",
	"Returns the 'void' bat from a geom_cluster.",
	"geom");

PROC filters( str cluster) : BAT[void, geom_filter]
{
	return bat(cluster + "_geom_filter");
}
ADDHELP("filters",
	"Wouter Scherphof", "November 30 2006",
	"Returns the 'filter' bat from a geom_cluster.",
	"geom");

PROC geoms( str cluster) : BAT[void, any]
{
	return bat(cluster + "_geom_geom");
}
ADDHELP("geoms",
	"Wouter Scherphof", "November 30 2006",
	"Returns the 'geom' bat from a geom_cluster.",
	"geom");

PROC mbrs( str cluster) : BAT[void, any]
{
	return bat(cluster + "_mbr");
}
ADDHELP("mbrs",
	"Wouter Scherphof", "November 30 2006",
	"Returns the 'mbr' bat from a geom_cluster.",
	"geom");

PROC universe( str cluster) : mbr
{
	return bat(cluster + "_geom_universe").fetch(0@0);
}
ADDHELP("universe",
	"Wouter Scherphof", "November 30 2006",
	"Returns the universe mbr from a geom_cluster.",
	"geom");

PROC geom_cluster( str name, BAT[void, wkb] geoms, mbr universe) : str
{
	# Compute filter codes.
	var filters:= [filter](geoms, universe);
	# Sort on filter code, i.e. sort on spatial proximity.
	filters := filters.reverse().sort().reverse();
	var clusterOids := filters.mark(0@0).reverse().rename(name + "_geom_oid").persists(true).access(BAT_READ);
	# inverse of clusterOids, to enable positional lookup of geoms with oid.
	clusterOids.sort().mark(0@0).reverse().rename(name + "_geom_void").persists(true).access(BAT_READ);
	filters.reverse().mark(0@0).reverse().rename(name + "_geom_filter").persists(true).access(BAT_READ);
	geoms.fetch(filters).reverse().mark(0@0).reverse().rename(name + "_geom_geom").persists(true).access(BAT_READ);
	# Compute minimum bounding rectangles.
	filters.destroy();
	var clusterUniverse := bat(void, mbr).rename(name + "_geom_universe").persists(true);
	clusterUniverse.seqbase(0@0);
	clusterUniverse.append(universe);
	clusterUniverse.access(BAT_READ);
	commit();
	return name;
}
ADDHELP("geom_cluster",
	"Wouter Scherphof", "November 29 2006",
	"Creates (and saves) the storage structure for a geometry column, given a name for it and the bounds of the universe.\nCreates a number of synced BATs, which can be retrieved with their respective procs: oids(cluster_name), voids(cluster_name), filters(cluster_name), geoms(cluster_name), mbrs(cluster_name) and universe(cluster_name).",
	"geom"
);

# Functions prescribed by OGC's SFA standard:

PROC AsText( wkb geom) : str
{
	return str(geom);
}
ADDHELP("AsText",
	"Wouter Scherphof", "December 04 2006",
	"As specified by OGC's SFA standard:\nReturns the 'well known text' representation of the given geometry.", "geom");

var wkb_nil := wkb(nil);
@= types
PROC @1FromText( str wkt, sht srid): wkb
{
	return wkb_from_text(wkt, @3);
}
ADDHELP("@1FromText",
	"Wouter Scherphof", "December 04 2006",
	"As specified by OGC's SFA standard:\nCreates a @1 from its 'well known text' representation.",
	"geom");
PROC @2( str wkt ): wkb
{
	return wkb_from_text(wkt, @3);
}
PROC @2( wkb w ): wkb
{
	#/* todo check type */
	#//return wkb_from_text(wkt, @3);
	return w;
}

@mil
@:types(Geom,geometry,wkbGeometryCollection)@
@:types(Point,point,wkbPoint)@
@:types(Curve,curve,wkbLineString)@
@:types(Line,linestring,wkbLineString)@
@:types(Surface,surface,wkbPolygon)@
@:types(Poly,polygon,wkbPolygon)@

PROC geom_cluster_print( str cluster) : void
{
	print(cluster);
	print(cluster.universe());
	print(cluster.oids(), cluster.voids(), cluster.filters(), cluster.mbrs(), cluster.geoms());
}
ADDHELP("geom_cluster_print",
	"Wouter Scherphof", "November 30 2006",
	"Prints the contents of a geom_cluster.",
	"geom");

PROC geom_cluster_persists( str cluster, bit mode) : void
{
	cluster.oids().persists(mode);
	cluster.voids().persists(mode);
	cluster.filters().persists(mode);
	cluster.geoms().persists(mode);
	cluster.mbrs().persists(mode);
}
ADDHELP("geom_cluster_persists",
	"Wouter Scherphof", "November 30 2006",
	"Persists (or not) the contents of a geom_cluster.",
	"geom");

PROC geom_primary_filter( str cluster, wkb geom) : BAT[void, oid]
{
	var filterCode := geom.filter(cluster.universe());
	# Expand the filter code to a BAT[geom_filter, geom_filter] with [from, to] intervals.
	var filterIntervals := filterCode.expand();
	var filterVoids := geom_select_filter(cluster.filters(), filterIntervals);
	var mbrs := filterVoids.reverse().mirror().join(cluster.mbrs());
	var interactingMbrs := [interact](mbrs, geom.mbr()).uselect(true);
	return interactingMbrs.mirror().join(cluster.oids());
}
ADDHELP("geom_primary_filter",
	"Wouter Scherphof", "November 29 2006",
	"Quickly selects >= all geometries from the cluster that have a spatial interaction with the given @1.\nI.e. a set of 'candidates' is selected.\nReturns the ids from the originating unclustered geometry BAT in the tail and the local cluster oids in the head.\nThe given @1's coordinates must be in the same universe as the cluster geometries.",
	"geom");

# module(alarm);

PROC geom_primary_filter( str cluster1, str cluster2) : BAT[oid, oid]
{
	if (not( cluster1.universe() = cluster2.universe() )) {
		print("!ERROR: The two geometry clusters are in different universes.");
		cluster1.geom_cluster_print();
		cluster2.geom_cluster_print();
		return nil;
	}
	var count1 := cluster1.oids().count();
	var count2 := cluster2.oids().count();
	var outerCluster, innerCluster;
	if (count1 < count2) {
		outerCluster := cluster1;
		innerCluster := cluster2;
	}
	else {
		outerCluster := cluster2;
		innerCluster := cluster1;
	}
	var outerType := outerCluster.geoms().ttype();
	var innerType := innerCluster.geoms().ttype();
	var innerFilters := innerCluster.filters();
	var outerMbrs := outerCluster.mbrs();
	var innerMbrs := innerCluster.mbrs();
	var res := bat(oid, oid);
#		var tt, tExpand := 0.0, tSelectFilter := 0.0, tJoinInnerMbrs := 0.0, tInteract := 0.0, tProject := 0.0, tInsert := 0.0, filterCount := 0;
	outerCluster.filters()@batloop() {
#			tt := usec();
		var filterIntervals := $t.expand();
#			tExpand := tExpand + ((usec() - tt) / 1000000.0);
#			tt := usec();
		var matches := geom_select_filter(innerFilters, filterIntervals);  # BAT[void, inner-cluster-oid]
#			tSelectFilter := tSelectFilter + ((usec() - tt) / 1000000.0);
#			filterCount := filterCount + matches.count();
#			tt := usec();
		matches := matches.reverse().mirror().join(innerMbrs);  # BAT[inner-cluster-oid, inner-mbr]
#			tJoinInnerMbrs := tJoinInnerMbrs + ((usec() - tt) / 1000000.0);
#			tt := usec();
		matches := [interact](matches, outerMbrs.fetch($h)).uselect(true);  # BAT[inner-cluster-oid, void]
#			tInteract := tInteract + ((usec() - tt) / 1000000.0);
#			tt := usec();
		matches := matches.project($h).reverse();  # BAT[outer-cluster-oid, inner-cluster-oid]
#			tProject := tProject + ((usec() - tt) / 1000000.0);
#			tt := usec();
		res.insert(matches);
#			tInsert := tInsert + ((usec() - tt) / 1000000.0);
#			tt := usec();
	}
	res := res.access(BAT_READ);
	res := res.join(innerCluster.oids());  # BAT[outer-cluster-oid, inner-original-oid]
	res := res.reverse().join(outerCluster.oids()).reverse();  # BAT[outer-original-oid, inner-original-oid]
#		print("cross product count: " + str(cluster1.oids().count() * cluster2.oids().count()));
#		print("filter count: " + filterCount);
#		print("res count: " + res.count());
#		print("tExpand: " + tExpand);
#		print("tSelectFilter: " + tSelectFilter);
#		print("tJoinInnerMbrs: " + tJoinInnerMbrs);
#		print("tInteract: " + tInteract);
#		print("tProject: " + tProject);
#		print("tInsert: " + tInsert);
	if (count1 >= count2)
		res := res.reverse();
	return res.sort();
}
ADDHELP("geom_primary_filter",
	"Wouter Scherphof", "November 30 2006",
	"Quickly selects for each geometry in cluster 1 >= all geometries from cluster2 that have a spatial interaction with it.\nI.e. a set of 'candidate' geometry pairs for a spatial join is selected.\nReturns the ids from the originating unclustered geometry BATs.\nBoth clusters must be in the same universe.",
	"geom");


# utility procs

PROC store_ascii_io( str name, BAT[str, BAT] table, mbr universe) : void
{
	var tableName := table.bbpname();
	table@batloop() {
		var tp := $t.ttype();
		if (
			(tp = geom_point) or
			(tp = geom_geometry) or
			(tp = geom_curve) or
			(tp = geom_linestring) or
			(tp = geom_surface) or
			(tp = geom_polygon)
		) {
			geom_cluster(name + "_" + $h, $t, universe);
			$t.destroy();
		}
		else {
			$t.rename(name + "_" + $h).persists(true).access(BAT_READ);
		}
	}
	commit();
}
