@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
@' Copyright August 2008- MonetDB B.V.
@' All Rights Reserved.

@f glue
@a Niels Nes

@h
#ifndef _GLUE_H_
#define _GLUE_H_

#include "language.h"

@+ The glue Class
The glue class generates the code which glues extensions to Monet. It
generates the install and delete functions for the module and type check
and unpack functions for the commands/operators. For atoms 
the properties are set. It inherits form language so only the code
generation methods needed have to be re-implemented.

@h
class glue:public language {
      public:
	glue() {
		arg_nr = 0;
	}
	const char *get_name() const {
		return "glue";
	}
	int generate_code(ostream & o, Symbol *rootptr);
	int generate_table(ostream & o, Symtable * tableptr);

	ostream & gen_module(ostream & o, const Module & m);

      public:
	int arg_nr;
	Symtable *tableptr;
	ostream & gen_command_args(ostream & o, const Command & m, const char *sep = "");
	ostream & gen_operator_args(ostream & o, const Operator & m, const char *sep = "");
};

#endif //_GLUE_H_

@C 
#include <mel_config.h>
#include "glue.h"
#include "ListIterator.h"
#include "mel.h"
#include "mel.tab.h"

// generate the unpack functions
@+ unpack
The unpack class generates the unpack functions. Monet uses ValPtr 
records to store built-in types and atoms. The unpack function will 
unpack these records and calls the user defined function properly. 
The user defined functions should be in the following format.
All parameters of the mel function are passed using pointers. The first
argument, if the function has a return type, will point to the
return value. In case of a fixed sized atom the system will allocate space
for the return value. In case of a variable sized atom the first argument
will have an extra indirection so the user can (should) allocate the space
for the return value.

@C
class unpack : public glue {
	ostream &gen_command( ostream &o, const Command &m );
	ostream &gen_operator( ostream &o, const Operator &m );
};

@+ setresult
The setresult initializes the result value record and allocates space for
result values of fixed sizes. The type is set with the setresult member.

@C
class unpack_setresult_type : public glue {

	ostream &gen_atom_arg( ostream &o, const AtomArg &m );
	ostream &gen_type_arg( ostream &o, const TypeArg &m );
	ostream &gen_bat_arg( ostream &o, const BatArg &m );
};

class unpack_setresult : public glue {
	ostream &gen_command( ostream &o, const Command &m );
	ostream &gen_operator( ostream &o, const Operator &m );

	ostream &gen_atom_arg( ostream &o, const AtomArg &m );
	ostream &gen_type_arg( ostream &o, const TypeArg &m );
	ostream &gen_bat_arg( ostream &o, const BatArg &m );

    public:
	unpack_setresult_type setresult;
};

@+ call
The call class generates the actual call of the user supplied c-function.
Each parameter is passed by address. The result parameter (first argument)
will have an extra indirection when the user should allocate space.
This indirection is needed so the user can set the pointer to
the allocated space.

@C
class unpack_call : public glue {
    public:
   	unpack_call( ){ varargs = 0; }
    private:
	ostream &gen_command( ostream &o, const Command &m );
	ostream &gen_operator( ostream &o, const Operator &m );

	ostream &gen_atom_arg( ostream &o, const AtomArg &m );
	ostream &gen_type_arg( ostream &o, const TypeArg &m );
	ostream &gen_bat_arg( ostream &o, const BatArg &m );
	ostream &gen_any_arg( ostream &o, const AnyArg &m );
	ostream &gen_var_arg( ostream &o, const VarArg &m );

	int varargs;
};

@+ getresult
The getresult class generates the code to move the result into the result
value record, check for errors and giving error messages. 

@C
class unpack_getresult : public glue {
	ostream &gen_atom_arg( ostream &o, const AtomArg &m );
	ostream &gen_type_arg( ostream &o, const TypeArg &m );
	ostream &gen_bat_arg( ostream &o, const BatArg &m );
	ostream &gen_any_arg( ostream &o, const AnyArg &m );
    public:
    	char *fcn;
};

@+ protoize
generates forward definitions for the user defined functions and types.

@C
class protoize: public glue {
    public:
	ostream &gen_atom( ostream &o, const Atom &m );

	ostream &gen_prelude( ostream &o, const Prelude &m );
	ostream &gen_epilogue( ostream &o, const Epilogue &m );
};
@+ exports
generates export definitions

@C
class exports: public glue {
    public:
	ostream &gen_atom( ostream &o, const Atom &m );
};

@+ forward 
The forward class generates forward definitions for the unpack and type 
check functions. So the stuff could be compiled using a c++ compiler.

@C
class forward: public glue {
    public:
	ostream &gen_command( ostream &o, const Command &m );
	ostream &gen_operator( ostream &o, const Operator &m );
	ostream &gen_builtin( ostream &o, const Builtin &m );

	ostream &gen_atom_arg( ostream &o, const AtomArg &m );
	ostream &gen_type_arg( ostream &o, const TypeArg &m );
	ostream &gen_bat_arg( ostream &o, const BatArg &m );
	ostream &gen_any_arg( ostream &o, const AnyArg &m );
	ostream &gen_var_arg( ostream &o, const VarArg &m );

};

@+ install
The install class generates the install functions. The install functions
update the monet tables and load the user defined functions dynamically.
The install functions also installs the modules in its use list.
Modules will be installed only once. When a module is installed for the
second time (a different user) only its reference count will be increased.
@C
class install: public glue {
    public:
	ostream &gen_dependency( ostream &o, const Dependency &m );
	ostream &gen_atom( ostream &o, const Atom &m );

    public:
	char *atom;
};
class install_fcntbl: public glue {
    public:
	ostream &gen_command( ostream &o, const Command &m );
	ostream &gen_operator( ostream &o, const Operator &m );
	ostream &gen_builtin( ostream &o, const Builtin &m );
	ostream &gen_object( ostream &o, const Object &m );
    
	ostream &gen_atom_arg( ostream &o, const AtomArg &m );
	ostream &gen_type_arg( ostream &o, const TypeArg &m );
	ostream &gen_bat_arg( ostream &o, const BatArg &m );
	ostream &gen_any_arg( ostream &o, const AnyArg &m );
	ostream &gen_var_arg( ostream &o, const VarArg &m );
};

class install_prelude: public glue {
    public:
	ostream &gen_prelude( ostream &o, const Prelude &m );
};

// generates delete functions  
@+ deinstall
The deinstall class deinstalls everything including modules from its use list. 
A module only gets deinstalled when its reference count hits zero.
So if the module is used more than once it will not be deinstalled, only
its reference count will be decreased.
Deinstall is split in deinstall and run_epilogue, as the epilogue needs to
be run before deinstalling all atoms.

@C
class run_epilogue: public glue {
    public:
	ostream &gen_epilogue( ostream &o, const Epilogue &m );
};

class deinstall: public glue {
    public:
	ostream &gen_atom( ostream &o, const Atom &m );
};


@+ type check functions
The typecheck class generates the type check functions. These functions
check if the actual types of the given value record array are equal to 
the formal types as defined in the mel module. If they are equal
1 is returned else 0.

@C
class typecheck: public glue {
    public:
	ostream &gen_atom( ostream &o, const Atom &m );
	ostream &gen_atomops( ostream &o, const Atomops &m );
};

class tpchk_bat_type: public glue {
    public:
	tpchk_bat_type(int argnr = 0 ){ head = 0; arg_nr = argnr; }
	ostream &gen_atom_arg( ostream &o, const AtomArg &m );
	ostream &gen_type_arg( ostream &o, const TypeArg &m );
	ostream &gen_any_arg( ostream &o, const AnyArg &m );
	ostream &gen_bat_arg( ostream &o, const BatArg &m );
    public:
	int head;
};


#define MAXPARAMS	32	// also see gdk.mx

// implementation
int
glue::generate_code(ostream &o, Symbol *rootptr)
{
	rootptr->print(this, o);
	return 0;
}

int
glue::generate_table(ostream &o, Symtable *_tableptr)
{
	tableptr = _tableptr;
	o << "/*\n";
	o << " * This module is generated using the mel -glue utility\n";
	o << " * not intended for reading !!! \n";
	o << " */\n\n";
	o << "#include \"" << config_h << "\"\n";
	o << "#include \"gdk.h\"\n";
	o << "#include \"monet.h\"\n";
	o << "#include \"monet_tbl.h\"\n\n";

	o << "#ifdef __cplusplus\n";
	o << "extern \"C\" {\n";
	o << "#endif\n\n";

	language *l = new protoize ();

	_tableptr->traverse(l, o);
	delete(l);
	o << "\n";

	o << "#ifdef __cplusplus\n";
	o << "}\n";
	o << "#endif\n\n";

	return 0;
}

ostream &
glue::gen_command_args(ostream &o, const Command &d, const char *sep)
{
	if (d.args()) {
		arg_nr = 1;
		ListIterator *iter = d.args()->iterator();
		Symbol *s = NULL;

		if (iter->next((void **)&s)) {
			s->print(this, o);
			arg_nr++;
		}
		while (iter->next((void **)&s)) {
			o << sep;
			s->print(this, o);
			arg_nr++;
		}
	}
	return o;
}

ostream &
glue::gen_operator_args(ostream &o, const Operator &d, const char *sep)
{
	return this->gen_command_args(o, d, sep);
}

ostream &
print_list(ostream &o, List *l, language *u)
{

	if (l) {
		ListIterator *iter = l->iterator();
		Symbol *s = NULL;

		while (iter->next((void **)&s)) {
			s->print(u, o);
		}
	}
	return o;
}

#include <ctype.h>
#include <string.h>

#ifdef TIME_WITH_SYS_TIME
# include <sys/time.h>
# include <time.h>
#else
# ifdef HAVE_SYS_TIME_H
#  include <sys/time.h>
# else
#  include <time.h>
# endif
#endif

char *
gen_time()
{
	static char buf[128];
	time_t t = time(NULL);
	char *q, *p = ctime(&t);

	strcpy(buf, p);
	if ((q = strchr(buf, '\n')) != 0)
		*q = 0;
	return buf;
}

char *modulename = NULL;

ostream &
glue::gen_module(ostream &o, const Module &d)
{

	o << "#include \"" << d.Name() << ".proto.h\"\n";
	o << "#ifdef __cplusplus\n";
	o << "extern \"C\" {\n";
	o << "#endif\n\n";

	o << d.Name() << "_export oid _" << d.Name();
	o << "_Module_Install( TBLinstall *inst, str user );\n";
	o << d.Name() << "_export int _" << d.Name() << "_Module_Delete( str user );\n";


#if 0
	language *l = new exports ();

	tableptr->traverse(l, o);
	delete(l);
	o << "\n";

	l = new forward ();

	print_list(o, d.Defs(), l);
	delete(l);
	o << "\n";
#else
	language *l;
#endif

	l = new typecheck ();

	print_list(o, d.Defs(), l);
	delete(l);

	o << "#ifdef __cplusplus\n";
	o << "}\n";
	o << "#endif\n\n";

	l = new unpack ();

	print_list(o, d.Defs(), l);
	delete(l);

	modulename = (char *) d.Name();
	o << "char " << modulename;
	o << "_compile_time[] = \"" << gen_time() << "\";\n\n";

	l = new install_fcntbl ();

	o << "static TBLfcn " << modulename << "_fcns[] = {\n";
	l->gen_list(o, d.Defs());
	o << "   { NULL, 0, NULL, NULL, NULL, NULL, NULL, { NULL },  NULL } };\n";
	delete(l);

	o << "oid _" << d.Name();
	o << "_Module_Install( TBLinstall *inst, str user ){\n";
	o << "   oid mid = TBL_Install_Info( inst, user, \"_" << d.Name();
	o << "\");\n";

	l = new install ();

	print_list(o, d.Deps(), l);
	o << "\n";
	print_list(o, d.Defs(), l);
	o << "\n";
	delete(l);

	o << "   TBL_Install_Functions( mid, " << modulename << "_fcns, user, " << modulename << "_compile_time );\n";

	/* execute prelude as *last* step */
	l = new install_prelude();
	print_list(o, d.Defs(), l);
	o << "\n";
	delete(l);

	o << "   return mid;\n}\n\n";

	o << "int _" << d.Name() << "_Module_Delete( str user ){\n";
	o << "   (void)user;\n";
	/* run epiloque */
	l = new run_epilogue();
	print_list(o, d.Defs(), l);
	delete(l);

	/* deinstall atoms */
	l = new deinstall ();

	print_list(o, d.Defs(), l);
	delete(l);
	o << "   return 1;\n";
	o << "}\n\n";
	return o;
}

void
gen_extern_typeops(ostream &o, int op, Arg *t)
{
	o << "extern int " << t->toString();
	switch (op) {
	case OP_TOSTR:
		o << "_tostr(char **dst, int *len, char *src );\n";
		break;
	case OP_FROMSTR:
		o << "_fromstr(char *src, int *len, char **dst );\n";
		break;
	default:
		return;
	}
}

void
gen_default_atomops(ostream &o, int op, const Atom &d)
{
	const char *atom = d.Name();
	char len[1024];

	if (d.size()) {
		sprintf(len, "%d", d.size());
	} else {
		sprintf(len, "%s_size()", atom);
	}
	switch (op) {
	case OP_TOSTR:
		o << "static int " << atom;

		o << "_tostr(char **dst, int *len, char *src ){\n";
		o << "   int i = 0; char *buf = 0;\n";
		o << "   if( *len < " << len << "*4+1 ){\n";
		o << "      if (*dst && *len > 0) GDKfree(*dst);\n";
		o << "      *dst = (char*)GDKmalloc(*len = " << len << "*4+1 );\n";
		o << "   }\n";
		o << "   for( i = 0, buf = *dst; i < " << len << "; i++){\n";
		o << "      char c = *src++;\n";
		o << "      if (GDKisprint(c)) *buf++ = c;\n";
		o << "      else {\n";
		o << "         *buf++ = '\\\\';\n";
		o << "         *buf++ = '0'+c/64;\n";
		o << "         *buf++ = '0'+(c%64)/8;\n";
		o << "         *buf++ = '0'+c%8;\n\n";
		o << "      }\n";
		o << "   }\n";
		o << "   *buf = 0;\n";
		o << "   return (int) (buf - *dst);\n";
		o << "}\n\n";
		break;
	case OP_FROMSTR:
		o << "static int " << atom;

		o << "_fromstr(char *src, int *len, char **dst ){\n";
		o << "   int i = 0; char *buf = 0;\n";
		o << "   if( *len < " << len << " ){\n";
		o << "      if (*dst && *len > 0) GDKfree(*dst);\n";
		o << "      *dst = (char*)GDKmalloc(*len = " << len << " );\n";
		o << "   }\n";
		o << "   for( i = 0, buf = src; i < " << len << "; i++,buf++){\n";
		o << "      if (*buf == '\\\\'){\n";
		o << "         if ((buf[1] != '0')||(buf[2]<'0')||(buf[2]>'3')||\n";
		o << "             (buf[3]<'0')||(buf[3]>'7')||\n";
		o << "             (buf[4]<'0')||(buf[4]>'7')) continue;\n";
		o << " 	       (*dst)[i] = buf[2]*64+buf[3]*8+buf[4];\n";
		o << "         buf += 4;\n";
		o << "      } else {\n";
		o << "         (*dst)[i] = *buf;\n";
		o << "      }\n";
		o << "   }\n";
		o << "   return (int) (buf - src);\n";
		o << "}\n\n";
		break;

	case OP_READ:
		o << "static char * " << atom;

		o << "_read( char *a, stream *s, size_t cnt) {\n";
		o << "   (void) a; (void) s; (void) cnt;";
		o << "   return NULL;\n";
		o << "}\n\n";
		break;
	case OP_WRITE:
		o << "static void " << atom;

		o << "_write( char *a, stream *s, size_t cnt) {\n";
		o << "   (void) a; (void) s; (void) cnt;";
		o << "}\n\n";
		break;

	case OP_COMP:
	case OP_NEQUAL:
		o << "static int " << atom;

		o << "_cmp( unsigned char *v1, unsigned char *v2 ){\n";
		o << "   int i;\n";
		o << "   unsigned char *p;\n";
		o << "   for(p=v1+" << len << "; v1<p; v1++, v2++)\n";
		o << "      if ((i = (*v1-*v2)) != 0) return i;\n";
		o << "   return 0;\n";
		o << "}\n\n";
		break;
	case OP_HASH:
		o << "static BUN " << atom;

		o << "_hash( unsigned char *v ){\n";
		o << "   BUN i=0,s=" << len << ";\n";
		o << "   unsigned char *p;\n";
		o << "   for(p=v+" << len << "; v<p; v+=s)\n";
		o << "      i = 19*i + *v;\n";
		o << "   return i;\n";
		o << "}\n\n";
		break;
	case OP_NULL:
		o << "static char *" << atom <<"_nil = NULL;\n";
		o << "static ptr " << atom;

		o << "_null(void){\n";
		o << "   char *p1,*p2;\n";
		o << "   if (" << atom <<"_nil == NULL)\n";
		o << "      " << atom <<"_nil = (char*)GDKmalloc(" << len << ");\n";
		o << "   p1 = " << atom <<"_nil;\n";

		o << "   p2 = p1 + " << len << ";\n";
		o << "   while(p1 < p2) *p1++ = -127;\n";
		o << "   return (ptr)" << atom <<"_nil;\n";

		o << "}\n\n";
		break;
	case OP_FIX:
		o << "static int " << atom;

		o << "_fix(char *src){\n";
		o << "   return 0;\n";
		o << "}\n\n";
		break;
	case OP_UNFIX:
		o << "static int " << atom;

		o << "_unfix(char *src){\n";
		o << "   return 0;\n";
		o << "}\n\n";
		break;
	case OP_PUT:
		o << "static var_t " << atom;

		o << "_put(Heap *hp, char *dst, char *src ){\n";
		o << "   memcpy(dst, src, " << len << ");\n";
		o << "   return 1;\n";
		o << "}\n\n";
		break;
	case OP_CONVERT:
		o << "static void " << atom;

		o << "_convert( char *a, int direction ){ (void)a; (void) direction; }\n\n";
		break;
	case OP_HCONVERT:
		o << "static void " << atom;

		o << "_heap_convert( Heap *hp ){ (void)hp; }\n\n";
		break;
	case OP_LEN:
		break;
	case OP_DEL:
		break;
	case OP_HEAP:
		break;
	case OP_CHECK:
		break;
	}
}


ostream &
print_size(ostream &o, int size, Arg *arg, const char *atom_name)
{
	if (!arg) {
		if (size > 0)
			o << size;
		else if (size < 0)
			o << "0";
		else
			o << atom_name << "_size()";
	} else {
		o << "sizeof(" << arg->toString() << ")";
	}
	return o;
}

ostream &
print_align(ostream &o, int size, int align, Arg *arg, const char *atom_name)
{
	if (!arg) {
		if (size < 0) {
			o << "0";
		} else if (size == 0) {
			o << atom_name << "_align()";
		} else {
			o << align;
		}
	} else {
		o << "sizeof(" << arg->toString() << ")";
	}
	return o;
}

ostream &
unpack_setresult::gen_command(ostream &o, const Command &d)
{
	const Symbol *res = d.result();

	if (res && res->Token() != MEL_ANY) {
		res->print(&setresult, o);
		res->print(this, o);
	} else {
		AnyArg *binding;

		if (res && (binding = ((AnyArg *) res)->bound())) {
			o << "   argv[0].vtype = ";
			o << "ATOMtype(" << binding->typestr << ");\n      ";
			o << "   argv[0].val.pval = (ATOMextern(argv[0].vtype) &&\n";
			o << "ATOMvarsized(argv[0].vtype)==0)?\n\tATOMnil(argv[0].vtype):NULL;\n";
		} else {
			o << "   argv[0].vtype = TYPE_void;\n";
			o << "   argv[0].val.oval = void_nil;\n";
		}
	}
	return o;
}

ostream &
unpack_call::gen_command(ostream &o, const Command &d)
{
	varargs = d.varargs();

	o << "\n   if (!" << d.fcn() << "(\n";
	if (d.result()) {
		arg_nr = 0;
		d.result()->print(this, o);
	}
	if (d.args()) {
		if (d.result())
			o << ",\n";
		gen_command_args(o, d, ",\n");
	}
	o << ")\n   ){\n";
	varargs = 0;
	return o;
}

ostream &
unpack::gen_command(ostream &o, const Command &d)
{
	o << "static int " << d.fcn() << "_unpack" << d.Id();
	o << "( int argc, ValPtr argv ){\n";
	o << "   if (argc > " << MAXPARAMS + 1 << ") {\n";
	o << "      GDKerror(\"%s: too many arguments.\\n\", \"";
	o << d.Name() << "\");\n";
	o << "      argv[0].vtype = TYPE_void;\n";
	o << "      argv[0].val.oval = void_nil;\n";
	o << "      return -1;\n";
	o << "   }\n";
	language *l = new unpack_setresult ();

	d.print(l, o);
	delete(l);

	l = new unpack_call ();

	d.print(l, o);
	delete(l);

	o << "      GDKerror(\"%s: operation failed.\\n\", \"";
	o << d.fcn() << "\");\n";	// d.Name() gives better error message
	o << "      argv[0].vtype = TYPE_void;\n";
	o << "      argv[0].val.oval = void_nil;\n";
	o << "      return -1;\n";
	o << "   }\n";

	unpack_getresult *u = new unpack_getresult ();

	u->fcn = d.fcn();
	if (d.result())
		d.result()->print(u, o);
	delete(u);

	o << "   return 0;\n";
	o << "}\n\n";
	return o;
}


ostream &
unpack_setresult::gen_operator(ostream &o, const Operator &d)
{
	return gen_command(o, d);
}

ostream &
unpack_call::gen_operator(ostream &o, const Operator &d)
{
	return this->gen_command(o, d);
}

ostream &
unpack::gen_operator(ostream &o, const Operator &d)
{
	return this->gen_command(o, d);
}

ostream &
unpack_setresult_type::gen_atom_arg(ostream &o, const AtomArg &d)
{
	o << "   argv[0].vtype = TYPE_" << d.arg()->Name() << ";\n";
	return o;
}

ostream &
unpack_setresult::gen_atom_arg(ostream &o, const AtomArg &d)
{
	if (d.arg() && d.arg()->top_type()) {
		d.arg()->top_type()->print(this, o);
		return o;
	}
	o << "   argv[0].val.pval = ";
	if (d.arg() && d.arg()->isFixed()) {
		o << "ATOMnil(TYPE_" << d.arg()->Name() << ");\n";
	} else {
		o << "NULL;\n";
	}
	return o;
}

ostream &
unpack_call::gen_atom_arg(ostream &o, const AtomArg &d)
{
	if (d.arg() && d.arg()->top_type()) {
		d.arg()->top_type()->print(this, o);
		return o;
	}
	if (d.arg()->isFixed() || arg_nr > 0) {
		o << "      (" << d.arg()->Name() << "*)argv[";
		o << arg_nr << "].val.pval";
	} else {
		o << "      (" << d.arg()->Name() << "**)&argv[";
		o << arg_nr << "].val.pval";
	}
	return o;
}

ostream &
unpack_getresult::gen_atom_arg(ostream &o, const AtomArg &d)
{
	if (d.arg() && d.arg()->top_type()) {
		d.arg()->top_type()->print(this, o);
		return o;
	}
	// if atom is not derived for a base type it is always stored
	// in the pval so we can check if it is non zero
	o << "   if (!argv[0].val.pval) {\n";
	o << "     GDKerror(\"%s: returned invalid pointer.\\n\", \"";
	o << fcn << "\");\n";
	o << "     argv[0].vtype = TYPE_void;\n";
	o << "     argv[0].val.oval = void_nil;\n";
	o << "     return -1;\n";
	o << "   }\n";
	if (d.arg()->isFixed()) {
		o << "   argv[0].len = ";
		if (d.arg()->size()) {
			o << d.arg()->size();
		} else {
			o << d.arg()->Name() << "_size()";
		}
		o << ";\n";
	} else {
		o << "   argv[0].len = ATOMlen(TYPE_" << d.arg()->Name();
		o << ", argv[0].val.pval);\n";
	}
	return o;
}


ostream &
unpack_setresult_type::gen_type_arg(ostream &o, const TypeArg &d)
{
	o << "   argv[0].vtype = TYPE_" << d.toString() << ";\n";
	return o;
}

ostream &
unpack_setresult::gen_type_arg(ostream &o, const TypeArg &d)
{
	o << "   argv[0].val.";
	switch (d.type()) {
	case TYPE_BIT:
		o << "cval[0] = chr_nil;\n";
		break;
	case TYPE_CHR:
		o << "cval[0] = chr_nil;\n";
		break;
	case TYPE_BTE:
		o << "btval = bte_nil;\n";
		break;
	case TYPE_SHT:
		o << "shval = sht_nil;\n";
		break;
	case TYPE_INT:
		o << "ival = int_nil;\n";
		break;
	case TYPE_PTR:
		o << "pval = ptr_nil;\n";
		break;
	case TYPE_OID:
		o << "oval = oid_nil;\n";
		break;
	case TYPE_WRD:
		o << "wval = wrd_nil;\n";
		break;
	case TYPE_FLT:
		o << "fval = flt_nil;\n";
		break;
	case TYPE_DBL:
		o << "dval = dbl_nil;\n";
		break;
	case TYPE_LNG:
		o << "lval = lng_nil;\n";
		break;
	case TYPE_STR:
		o << "sval = (str)str_nil;\n";
		break;
	}
	return o;
}

ostream &
unpack_call::gen_type_arg(ostream &o, const TypeArg &d)
{
	o << "      ";
	if (d.type() != TYPE_STR || arg_nr == 0)
		o << "(" << type2str(d.type()) << "*) &";
	o << "argv[" << arg_nr << "].val.";
	switch (d.type()) {
	case TYPE_BIT:
		o << "cval[0]";
		break;
	case TYPE_CHR:
		o << "cval[0]";
		break;
	case TYPE_BTE:
		o << "btval";
		break;
	case TYPE_SHT:
		o << "shval";
		break;
	case TYPE_INT:
		o << "ival";
		break;
	case TYPE_PTR:
		o << "pval";
		break;
	case TYPE_OID:
		o << "oval";
		break;
	case TYPE_WRD:
		o << "wval";
		break;
	case TYPE_FLT:
		o << "fval";
		break;
	case TYPE_DBL:
		o << "dval";
		break;
	case TYPE_LNG:
		o << "lval";
		break;
	case TYPE_STR:
		o << "sval";
		break;
	}
	return o;
}

ostream &
unpack_getresult::gen_type_arg(ostream &o, const TypeArg &d)
{
	if (d.type() == TYPE_STR) {
		o << "   if (!argv[0].val.sval) {\n";
		o << "     GDKerror(\"%s: returned invalid pointer.\\n\", \"";
		o << fcn << "\");\n";
		o << "     argv[0].vtype = TYPE_void;\n";
		o << "     argv[0].val.oval = void_nil;\n";
		o << "     return -1;\n";
		o << "   }\n";
		o << "   argv[0].len = ATOMlen(TYPE_str, ";
		o << "argv[0].val.pval);\n";
	}
	return o;
}


ostream &
unpack_setresult_type::gen_bat_arg(ostream &o, const BatArg &)
{
	o << "   argv[0].vtype = TYPE_bat;\n";
	o << "   argv[0].len = 0;\n";
	return o;
}

ostream &
unpack_setresult::gen_bat_arg(ostream &o, const BatArg &)
{
	o << "   argv[0].val.bval = 0;\n";
	return o;
}

ostream &
unpack_call::gen_bat_arg(ostream &o, const BatArg &)
{
	if (arg_nr > 0)
		o << "     BBPdescriptor(argv[" << arg_nr << "].val.bval)";
	else
		o << "     &argv[0].val.Bval";
	return o;
}


void
gen_resultbat_chk(ostream &o, const Symbol *d, int head, char *fcn)
{
	if (d && d->Token() == MEL_ANY && !((AnyArg *) d)->bound()) {
		return;
	}
	tpchk_bat_type bt(0);

	bt.head = head;
	o << "   if (!";
	if (d) {
		d->print(&bt, o);
	} else {
		o << "TYPEcastable(BBPdescriptor(argv[0].val.bval)->";
		o << (head ? "h" : "t") << "type, TYPE_void)\n";
	}
	o << "   ){\n     GDKerror(\"%s: returned BAT has unexpected ";
	o << (head ? "head" : "tail") << ".\\n\", \"" << fcn << "\");\n";
	o << "     return -1;\n";
	o << "   }\n";
}

ostream &
unpack_getresult::gen_bat_arg(ostream &o, const BatArg &d)
{
	o << "   if (!argv[0].val.pval) {\n";
	o << "     GDKerror(\"%s: returned invalid pointer.\\n\", \"";
	o << fcn << "\");\n";
	o << "     argv[0].vtype = TYPE_void;\n";
	o << "     argv[0].val.oval = void_nil;\n";
	o << "     return -1;\n";
	o << "   }\n";
	o << "   argv[0].val.bval=argv[0].val.Bval->batCacheid;\n";
	gen_resultbat_chk(o, d.atom1(), 1, fcn);
	gen_resultbat_chk(o, d.atom2(), 0, fcn);
	return o;
}

ostream &
gen_unpack_any_arg(ostream &o, int arg_nr, int varargs, int *bound)
{
	int n = arg_nr;

	if (varargs)
		o << "      (argc <= " << arg_nr << ")?0:\n";
	o << "       (argv[" << n << "].vtype == TYPE_bat)?\n";
	o << "         (ptr)BBPdescriptor(argv[" << n << "].val.bval):\n";
	o << "         VALptr(argv+" << n << ")";
	if (!bound) {
		o << ", ";
		if (varargs)
			o << "(argc <= " << arg_nr << ")?0:";
		o << "argv[" << n << "].vtype";
	}
	return o;
}

ostream &
unpack_call::gen_any_arg(ostream &o, const AnyArg &d)
{

	if (arg_nr > 0) {
		gen_unpack_any_arg(o, arg_nr, varargs, (int *) d.bound());
	} else if (d.bound()) {
		o << "     argv[0].val.pval?argv[0].val.pval:((ptr) &argv[0].val.ival)";
	} else {
		o << "     (ptr)&argv[0].val.ival, &argv[0].vtype";
	}
	return o;
}

ostream &
unpack_getresult::gen_any_arg(ostream &o, const AnyArg &)
{
	o << "   if(ATOMextern(argv[0].vtype) || argv[0].vtype == TYPE_bat){\n";
	o << "      if (!argv[0].val.pval) {\n";
	o << "     GDKerror(\"%s: returned invalid pointer.\\n\", \"";
	o << fcn << "\");\n";
	o << "         argv[0].vtype = TYPE_void;\n";
	o << "         argv[0].val.oval = void_nil;\n";
	o << "         return -1;\n";
	o << "      }\n";
	o << "      if (argv[0].vtype == TYPE_bat){\n";
	o << "         argv[0].val.bval=argv[0].val.Bval->batCacheid;\n";
	o << "         argv[0].len = 0;\n";
	o << "      } else {\n";
	o << "         argv[0].len = ATOMlen(argv[0].vtype, argv[0].val.pval);\n";
	o << "      }\n";
	o << "   }\n";
	return o;
}

ostream &
unpack_call::gen_var_arg(ostream &o, const VarArg &d)
{

	for (int i = arg_nr; i <= MAXPARAMS; i++, arg_nr++) {
		if (d.arg()) {
			// variable number of known type, eg ...int...
			o << "\t(argc <= " << arg_nr << ")?0:\n\t";
			d.arg()->print(this, o);
		} else {
			// variable number of any type, eg ...any...
			gen_unpack_any_arg(o, arg_nr, varargs, 0);
		}
		o << ",\n";
	}
	o << "\t(void *) NULL";
	if (!d.arg())
		o << ", 0";
	return o;
}


// the protoize language
ostream &
protoize::gen_atom(ostream &o, const Atom &d)
{
	o << "typedef ";
	if (d.top_type()) {
		o << d.top_type()->toString();
	} else if (d.top_parent()) {
		o << d.top_parent()->Name();
	} else {
		o << "void";
	}
	o << " " << d.Name() << ";\n";
/*
	if (d.size() == 0 && !d.parent() && !d.type() ){
		o << "extern int " << d.Name() << "_size();\n";
		o << "extern int " << d.Name() << "_align();\n";
	}
*/
	return o;
}

ostream &
exports::gen_atom(ostream &o, const Atom &d)
{
	o << "typedef ";
	if (d.top_type()) {
		o << d.top_type()->toString();
	} else if (d.top_parent()) {
		o << d.top_parent()->Name();
	} else {
		o << "void";
	}
	o << " " << d.Name() << ";\n";
/*
	if (d.size() == 0 && !d.parent() && !d.type() ){
		o << "extern int " << d.Name() << "_size();\n";
		o << "extern int " << d.Name() << "_align();\n";
	}
*/
	o << "extern int TYPE_" << d.Name() << ";\n";
	return o;
}

ostream &
forward::gen_command(ostream &o, const Command &d)
{
	o << "extern int " << d.fcn() << "_unpack" << d.Id();
	o << "( int, ValPtr argv );\n";
	o << "extern int " << d.fcn() << "(";
	arg_nr = 0;
	if (d.result()) {
		d.result()->print(this, o);
	}
	if (d.args()) {
		if (d.result())
			o << ", ";
		ListIterator *iter = d.args()->iterator();
		Symbol *s = NULL;

		if (iter->next((void **)&s)) {
			arg_nr++;
			s->print(this, o);
		}
		while (iter->next((void **)&s)) {
			arg_nr++;
			o << ", ";
			s->print(this, o);
		}
	}
	o << ");\n";
	return o;
}

ostream &
forward::gen_operator(ostream &o, const Operator &d)
{
	return this->gen_command(o, d);
}

ostream &
forward::gen_builtin(ostream &o, const Builtin &d)
{
	o << "extern int " << d.fcn();
	o << "( int stk, YYSTREE lt, ValPtr res);\n\n";
	return o;
}

ostream &
gen_extern_arg(ostream &o, const char *str, int ptr_included, int need_ptr)
{
	o << str;

	if (!ptr_included)
		o << "*";
	if (need_ptr)
		o << "*";
	return o;
}

ostream &
forward::gen_atom_arg(ostream &o, const AtomArg &d)
{
	return gen_extern_arg(o, d.arg()->Name(), (d.arg()->top_type() && d.arg()->top_type()->type() == TYPE_STR), (arg_nr == 0 && !d.arg()->isFixed()));
}

ostream &
forward::gen_type_arg(ostream &o, const TypeArg &d)
{
	return gen_extern_arg(o, d.toString(), (d.type() == TYPE_STR), (d.type() == TYPE_STR && arg_nr == 0));
}

ostream &
forward::gen_bat_arg(ostream &o, const BatArg &)
{
	return gen_extern_arg(o, "BAT", 0, (arg_nr == 0));
}

ostream &
forward::gen_any_arg(ostream &o, const AnyArg &d)
{
	o << "ptr";
	if (arg_nr == 0)
		o << " *";
	if (!d.bound()) {
		o << ",int";
		if (arg_nr == 0)
			o << " *";
	}
	return o;
}

ostream &
forward::gen_var_arg(ostream &o, const VarArg &)
{
	o << "...";
	return o;
}

ostream &
protoize::gen_prelude(ostream &o, const Prelude &d)
{
	o << "extern void " << d.Name() << "(void);\n\n";
	return o;
}

ostream &
protoize::gen_epilogue(ostream &o, const Epilogue &d)
{
	o << "extern void " << d.Name() << "(void);\n\n";
	return o;
}

ostream &
install::gen_dependency(ostream &o, const Dependency &d)
{
	(void) d;
	//o << "   TBL_Install_Depend(inst, mid, user, \"_"<<d.Name()<<"\");\n";
	return o;
}

ostream &
atom_property(ostream &o, const char *name, const char *property)
{
	o << "   ATOMproperty(\"" << name << "\", \"" << property << "\",(GDKfcn)";
	return o;
}

ostream &
install::gen_atom(ostream &o, const Atom &d)
{
	Atom *a = d.top_parent();
	Arg *t = d.top_type();

	o << "   TBL_Install_Atom( mid, \"" << d.Name() << "\", ";
	if (a) {
		print_size(o, a->size(), a->type(), a->Name());
	} else {
		print_size(o, d.size(), d.type(), d.Name());
	}
	o << ", ";
	if (!a) {
		print_align(o, d.size(), d.align(), d.type(), d.Name());
	} else {
		print_align(o, a->size(), a->align(), a->type(), a->Name());
	}
	o << ");\n";

	if (a) {
		Atom *p = d.parent();

		atom_property(o, d.Name(), "storage");
		o << "NULL, ";
		o << "ATOMindex(\"";
		if (p->type()) {
			o << p->type()->toString();
		} else
			o << p->Name();
		o << "\"));\n";
	}
	if (d.type()) {
		atom_property(o, d.Name(), "storage");
		o << "NULL, ";
		o << "ATOMindex(\"" << d.type()->toString() << "\"));\n";
	}
	if (!a && !t && d.isFixed()) {
		atom_property(o, d.Name(), "size");
		o << "NULL, ";
		print_size(o, d.size(), d.type(), d.Name());
		o << ");\n";
		atom_property(o, d.Name(), "align");
		o << "NULL, ";
		print_align(o, d.size(), d.align(), d.type(), d.Name());
		o << ");\n";
	}

	if (d.cmds()) {
		Ops **cmds = d.cmds();
		int end = OP_HCONVERT;

		if (d.isFixed()) {
			end = OP_PUT;
		}
		Atom *cmp_atom = (Atom *) &d;

		for (int i = OP_FIX; i < end; i++) {
			int found = 0;
			Ops *s = cmds[i];

			if (s) {
				atom_property(o, d.Name(), Atomops::string(i));

				o << s->Name();
				o << ", 0);\n";
				found = 1;
			}
			if (!found && (d.type() || d.parent())) {
				continue;
			}
			if (!found && d.isFixed() && i > OP_UNFIX) {
				atom_property(o, d.Name(), Atomops::string(i));

				if (!d.parent())
					o << d.Name();
				else
					o << d.top_parent()->Name();
				o << "_" << Atomops::string(i);

				o << ", 0);\n";
			}
		}
		if (cmp_atom->cmds()[OP_NEQUAL]) {
			atom_property(o, d.Name(), "linear");
			o << "NULL, 0);\n";
		}
	} else if (d.isFixed() && !d.type() && !d.parent()) {
		for (int i = OP_TOSTR; i < OP_PUT; i++) {
			atom_property(o, d.Name(), Atomops::string(i));
			o << d.Name() << "_" << Atomops::string(i);
			o << ", 0);\n";
		}
	}
	o << "   BATatoms[TYPE_" << d.Name() << " = ATOMindex(\"" << d.Name() << "\")].deleting = 0;\n";
	o << "   BBPatom_load(TYPE_" << d.Name() << ");\n";
	return o;
}

#include <stdio.h>

ostream &
install_fcntbl::gen_command(ostream &o, const Command &d)
{
	//int varargs = d.varargs();
	o << "   { \"";
	if (d.type() == MULTIPLEX) {
		o << "[";
	} else if (d.type() == AGGREGATE) {
		o << "{";
	}
	o << d.Name();
	if (d.type() == MULTIPLEX) {
		o << "]";
	} else if (d.type() == AGGREGATE) {
		o << "}";
	}
	o << "\", " << d.Token() << ", ";

	/* Function pointers names
	 */
	o << "(void*)" << d.fcn() << ", ";
	o << "(void*)" << d.fcn() << "_unpack" << d.Id() << ", ";
	o << "NULL, NULL, ";
	o << "\"" << d.hlp() << "\"";
	o << ", { ";
	gen_command_args(o, d, ", ");
	if (d.args())
		o << ", ";
	o << "(NULL)},";	// end of args
	arg_nr = 0;
	if (d.result()) {
		d.result()->print(this, o);
	} else {
		o << "\"void\"";
	}
	o << "},\n";
	return o;
}

ostream &
install_fcntbl::gen_operator(ostream &o, const Operator &d)
{
	return this->gen_command(o, d);
}

ostream &
install_fcntbl::gen_builtin(ostream &o, const Builtin &d)
{
	o << "   { ";
	o << "\"" << d.Name() << "\", TOK_BUILTIN, ";

	/* Function pointers names
	 */
	o << "(void*)" << d.fcn() << ", ";
	o << "(void*)" << d.fcn() << ", ";	// unpack is same for builtin
	o << "(void*)" << "NULL, ";	// no type checking available
	o << "\"" << d.sig() << "\", ";
	o << "\"" << d.hlp() << "\"";
	o << ",{ (NULL) }, NULL },\n";	// no args no result
	return o;
}

ostream &
install_fcntbl::gen_object(ostream &o, const Object &d)
{
	const char *fcn = d.arg()? d.arg()->Name() : d.Name();

	o << "   { ";
	o << "\"" << d.Name() << "\", ";
	o << "TOK_OBJECT" << ", ";

	/* Function pointers names
	 */
	o << fcn << ", ";
	o << d.Name() << "_unpack";
	o << ", ";
	o << d.Name() << "_type";
	o << ", ";

	o << " \"" << d.Name() << "\", \"\"";
	o << ",{ (NULL) }, NULL },\n";	// no args no result
	return o;
}

ostream &
gen_install_arg(ostream &o, const char *name, const Arg &d)
{
	(void) d;
	o << "\"" << name << "\"";
	//if (d.value()) {
	//      o << d.value();
	//}
	return o;
}

ostream &
install_fcntbl::gen_atom_arg(ostream &o, const AtomArg &d)
{
	gen_install_arg(o, d.arg()->toString(), d);
	return o;
}

ostream &
install_fcntbl::gen_type_arg(ostream &o, const TypeArg &d)
{
	gen_install_arg(o, d.toString(), d);
	return o;
}

ostream &
install_fcntbl::gen_bat_arg(ostream &o, const BatArg &d)
{
	char buf[80];

	sprintf(buf, "BAT[%s,%s]", d.atom1()? d.atom1()->toString() : "void", d.atom2()? d.atom2()->toString() : "void");
	gen_install_arg(o, buf, d);
	return o;
}

ostream &
install_fcntbl::gen_any_arg(ostream &o, const AnyArg &d)
{
	gen_install_arg(o, d.toString(), d);
	return o;
}

ostream &
install_fcntbl::gen_var_arg(ostream &o, const VarArg &d)
{
	o << "\"" << d.toString() << "\"";
	return o;
}

ostream &
install_prelude::gen_prelude(ostream &o, const Prelude &d)
{
	o << "   TBL_Install_DropRefs(mid, " << d.Name() << "());\n";
	return o;
}

ostream &
deinstall::gen_atom(ostream &o, const Atom &d)
{
	o << "   BBPatom_drop(TYPE_" << d.Name() << ");\n";
	o << "   ATOMdelete(TYPE_" << d.Name() << ");\n";
	return o;
}

ostream &
run_epilogue::gen_epilogue(ostream &o, const Epilogue &d)
{
	o << "   " << d.Name() << "();\n";
	return o;
}


ostream &
typecheck::gen_atom(ostream &o, const Atom &d)
{
	o << "int TYPE_" << d.Name() << ";\n\n";

	if (d.cmds()) {
		Ops **cmds = d.cmds();
		int end = d.isFixed()? OP_PUT : OP_HCONVERT;

		for (int i = OP_TOSTR; i < end; i++) {
			Ops *s = cmds[i];
			int found = 0;

			if (s) {
				s->print(this, o);
				found = 1;
			}
			if (!found && d.type()) {
				if (i == OP_TOSTR || i == OP_FROMSTR)
					gen_extern_typeops(o, i, d.type());
				found = 1;
			}
			if (!found && d.parent()) {
				Atom *a = d.parent();

				while (a && a->cmds()[i] == NULL)
					a = a->parent();
				if (a) {
					a->cmds()[i]->print(this, o);
				}
				found = 1;

			}
			if (!found && d.isFixed()) {
				gen_default_atomops(o, i, d);
				/* default derived ADT functions */
			}
		}
	} else if (d.isFixed() && !d.type() && !d.parent()) {
		for (int i = OP_TOSTR; i < OP_PUT; i++) {
			gen_default_atomops(o, i, d);
		}
	}
	return o;
}

ostream &
typecheck::gen_atomops(ostream &o, const Atomops &d)
{
#if 0
	char *fcn = d.Name();

	switch (d.operation()) {
	case OP_TOSTR:
		o << "extern int " << fcn;
		o << "(char **dst, int *len, char *src );\n";
		break;
	case OP_FROMSTR:
		o << "extern int " << fcn;
		o << "(char *src, int *len, char **dst );\n";
		break;
	case OP_WRITE:
		o << "extern void " << fcn;
		o << "(void *atom, stream *s, size_t cnt);\n";
		break;
	case OP_READ:
		o << "extern void *" << fcn;
		o << "(void *atom, stream *s, size_t cnt);\n";
		break;
	case OP_COMP:
	case OP_NEQUAL:
		o << "extern int " << fcn;
		o << "( unsigned char *v1, unsigned char *v2 );\n";
		break;
	case OP_HASH:
		o << "extern BUN " << fcn << "( unsigned char *v );\n";
		break;
	case OP_NULL:
		o << "extern ptr " << fcn << "();\n";
		break;
	case OP_CONVERT:
		o << "extern void " << fcn;
		o << "( char *a );\n";
		break;
	case OP_FIX:
		o << "extern int " << fcn;
		o << "(char *atom);\n";
		break;
	case OP_UNFIX:
		o << "extern int " << fcn;
		o << "(char *atom);\n";
		break;
	case OP_PUT:
		o << "extern int " << fcn;
		o << "(Heap *hp, char *dst, char *src );\n";
		break;
	case OP_LEN:
		o << "extern int " << fcn;
		o << "( char *atom );\n";
		break;
	case OP_DEL:
		o << "extern void " << fcn;
		o << "( Heap* hp, var_t* offset);\n";
		break;
	case OP_HEAP:
		o << "extern int " << fcn;
		o << "( Heap* hp, int size );\n";
		break;
	case OP_CHECK:
		o << "extern int " << fcn;
		o << "( Heap* hp, HeapRepair* hr);\n";
		break;
	case OP_HCONVERT:
		o << "extern void " << fcn;
		o << "( Heap *hp );\n";
		break;
	}
#else
	(void) d;
#endif
	return o;
}

ostream &
gen_bat_typecheck_arg(ostream &o, const char *prefix, const char *name, int head, int arg_nr)
{
	if (arg_nr)
		o << "\t&& ";	//hack
	o << "TYPEequal(BBPdescriptor(argv[" << arg_nr << "].";
	if (head)
		o << "val.bval)->htype";
	else
		o << "val.bval)->ttype";

	o << ", " << prefix << name << ")\n";
	return o;
}

ostream &
tpchk_bat_type::gen_atom_arg(ostream &o, const AtomArg &d)
{
	return gen_bat_typecheck_arg(o, "TYPE_", d.arg()->Name(), head, arg_nr);
}

ostream &
tpchk_bat_type::gen_type_arg(ostream &o, const TypeArg &d)
{
	return gen_bat_typecheck_arg(o, "TYPE_", d.toString(), head, arg_nr);
}

ostream &
tpchk_bat_type::gen_bat_arg(ostream &o, const BatArg &)
{
	return gen_bat_typecheck_arg(o, "TYPE_", "bat", head, arg_nr);
}

ostream &
tpchk_bat_type::gen_any_arg(ostream &o, const AnyArg &d)
{
	AnyArg *binding = d.bound();

	if (d.nr() > 0 && binding)
		return gen_bat_typecheck_arg(o, (strlen(binding->typestr) > 12) ? "\n\t\t" : "", (char *) binding->typestr, head, arg_nr);
	return o;
}
