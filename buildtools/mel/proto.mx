@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
@' Copyright August 2008-2009 MonetDB B.V.
@' All Rights Reserved.

@f proto
@a Niels Nes

@h
#ifndef _MPROTO_H_
#define _MPROTO_H_

#include "language.h"

class proto : public language {
      public:
	proto() {
		result = 0;
	}
	const char *get_name() const {
		return "proto";
	}
	int generate_code(ostream &o, Symbol *root);

	ostream &gen_module(ostream &o, const Module &m);
	ostream &gen_atom(ostream &o, const Atom &m);
	ostream &gen_atomops(ostream &o, const Atomops &m);
	ostream &gen_command(ostream &o, const Command &m);
	ostream &gen_operator(ostream &o, const Operator &m);
	ostream &gen_builtin(ostream &o, const Builtin &m);
	ostream &gen_iterator(ostream &o, const Iterator &m);
	ostream &gen_atom_arg(ostream &o, const AtomArg &m);
	ostream &gen_type_arg(ostream &o, const TypeArg &m);
	ostream &gen_var_arg(ostream &o, const VarArg &m);
	ostream &gen_bat_arg(ostream &o, const BatArg &m);
	ostream &gen_any_arg(ostream &o, const AnyArg &m);
	ostream &gen_prelude(ostream &o, const Prelude &m);
	ostream &gen_epilogue(ostream &o, const Epilogue &m);
	ostream &gen_dependency(ostream &o, const Dependency &m);

      private:
	const Atom *atom;
	int result;
};

#endif //_MPROTO_H_

@C
#include <mel_config.h>
#include "proto.h"
#include "ListIterator.h"
#include "mel.h"
#include "mel.tab.h"
#include <string.h>
#include <ctype.h>

int
proto::generate_code(ostream &o, Symbol *root)
{
	root->print(this, o);
	return 0;
}

static char mod_export[1024];

char *
upper(const char *str)
{
	size_t i,l = strlen(str);
	char *res = new char[l+1];

	for (i=0;i<l;i++)
		res[i]=toupper(str[i]);	
	res[l] = '\0';
	return res;
}

ostream &
proto::gen_dependency(ostream &o, const Dependency &d)
{ 
	o << "#include <" << d.Module()->Name() << ".proto.h>\n";
	return o;
}

ostream &
proto::gen_module(ostream &o, const Module &d)
{ 

	o << "/*\n";
	o << " * This module is generated using the mel -proto utility\n";
	o << " */\n\n"; 
	o << "#ifndef _" << upper(d.Name()) << "_PROTO_H_INCLUDED\n";
	o << "#define _" << upper(d.Name()) << "_PROTO_H_INCLUDED\n\n";
	o << "#include <gdk.h>\n\n";

	o << "#ifdef WIN32\n";
	o << "#ifndef LIB" << upper(d.Name()) << "\n";
	o << "#define " << d.Name() << "_export extern __declspec(dllimport)\n";
	o << "#else\n";
	o << "#define " << d.Name() << "_export extern __declspec(dllexport)\n";
	o << "#endif\n";
	o << "#else\n";
	o << "#define " << d.Name() << "_export extern\n"; 
	o << "#endif\n";

	strcpy(mod_export,d.Name());
	strcat(mod_export,"_export");

	o << "#ifdef __cplusplus\n";
	o << "extern \"C\" {\n";
	o << "#endif\n\n";

	gen_list(o, d.Deps(), "");
	gen_list(o, d.Defs(), "");

	o << "#ifdef __cplusplus\n";
	o << "}\n";
	o << "#endif\n\n";
	o << "#endif\n";
	return o; 
}

ostream &
proto::gen_atom(ostream &o, const Atom &d)
{
	atom = &d;

	o << mod_export << " int\tTYPE_" << d.Name() << ";\n";

	if (!d.type() && !d.parent() && d.size() == 0) {
 		o << mod_export << " int " << d.Name() << "_size(void);\n";
 		o << mod_export << " int " << d.Name() << "_align(void);\n";
	}
	o << "\n\n";
	
	if (d.cmds()) {
	   	Ops **cmds = d.cmds();
	   	for (int i = OP_FIX; i <= OP_NEQUAL; i++) {  
			Ops *s = cmds[i];
			if (s) 
				s->print(this, o);
		}
	}
	return o; 
}

ostream &
proto::gen_atomops(ostream &o, const Atomops &d)
{
	const char *name = atom->Name();
	int hasPtr = 0;

	if (atom->top_type() && atom->top_type()->type() == TYPE_STR)
		 hasPtr = 1;
	
	switch (d.operation()) {
	case OP_TOSTR 	:
		o << mod_export;
		o << " int\n";
		o << d.Name() << "(\n";
		o << "   char**\tdst,\t";
		o << "/* INOUT: dst charbuffer [maybe 0, may need realloc]*/\n";
		o << "   int*\t\tlen,\t/* INOUT: length of buffer */\n";
		o << "   " << name;
		if (!hasPtr)
			o << "*";
		o << "\tatom\t";
		o << "/* IN: to-be-printed " << name << ". */\n);\n";
		o << "\t/* TOSTR: print atom in a string. */\n";
		o << "\t/* return length of resulting string. */\n\n\n" ;
		break;
        case OP_FROMSTR :
		o << mod_export;
		o << " int\n";
		o << d.Name() << "(\n";
		o << "   char*\tsrc,\t/* IN: to-be-parsed string. */\n";
		o << "   int*\t\tlen,\t";
		o << "/* INOUT: length of area pointed to by atom ";
		o << "[may need enlarging!] */\n";
		o << "   " << name;
		if (!hasPtr)
			o << "*";
		o << "*\tatom\t";
		o << "/* INOUT: ptr to atom-ptr [may need (re-)alloc!] */\n);\n";
		o << "\t/* FROMSTR: parse string to " << name << ". */\n";
		o << "\t/* return number of parsed characters. */\n\n\n";
		break;
	case OP_WRITE 	:
		o << mod_export;
		o << " void\n";
		o << d.Name() << "(\n";
		o << "   " << name << " ";
		if (!hasPtr)
			o << "*";
		o << "\tatom,\t";
		o << "/* IN: to-be-writen " << name << ". */\n";
		o << "   stream *\ts,\t/* IN: s stream to write data to. */\n";
		o << "   size_t \tcnt\t/* IN: to be writen atoms (only >1 for fixed size atoms)*/\n);\n";
		o << "\t/* WRITE: write atom to a stream. */\n";
		o << "\t/* return success or failure. */\n\n\n" ;
		break;
        case OP_READ :
		o << "\n";
		o << mod_export;
		o << " " << name << " ";
		if (!hasPtr)
			o << "*";
		o << d.Name() << "(\n";
		o << "   " << name << " ";
		if (!hasPtr)
			o << "*";
		o << "\tatom,\t";
		o << "/* IN: to-be-read " << name << ". */\n";
		o << "   stream *\ts,\t/* IN: s stream to read from. */\n";
		o << "   size_t \tcnt\t/* IN: to be read atoms (only >1 for fixed size atoms)*/\n);\n";
		o << "\t/* READ: read " << name << " from stream s. */\n";
		o << "\t/* return new atom (in case of var atoms allocation is required). */\n\n\n";
		break;
        case OP_COMP 	:
		o << mod_export;
		o << " int\n";
		o << d.Name() << "(\n   " << name;
		if (!hasPtr)
			o << "*";
		o << "\tl,\t";
		o << "/* IN: first " << name << ". */\n";
		o << "   " << name;
		if (!hasPtr)
			o << "*";
		o << "\tr\t";
		o << "/* IN: second " << name << ". */\n);\n";
		o << "\t/* COMP: compare two " << name << "s. */\n";
		o << "\t/* returns int <0 if l<r, 0 if l==r, >0 else */\n\n\n";
		break;
        case OP_NEQUAL 	:
		o << mod_export;
		o << " int\n";
		o << d.Name() << "(\n   " << name;
		if (!hasPtr)
			o << "*";
		o << "\tl,\t";
		o << "/* IN: first " << name << ". */\n";
		o << "   " << name;
		if (!hasPtr)
			o << "*";
		o << "\tr\t";
		o << "/* IN: second " << name << ". */\n);\n";
		o << "\t/* NEQUAL: check if l is not equal to r.*/\n";
		o << "\t/* returns int !=0 if l!=r, 0 else */\n\n\n";
		break;
        case OP_DEL 	:
		o << mod_export;
		o << " void\n";
		o << d.Name() << "(\n";
		o << "   Heap*\thp,\t/* INOUT: heap of " << name << "s. */\n";
		o << "   var_t*\t\toffset\t/* IN: offset from heapbase.  */\n);\n";
		o << "\t/* DEL: delete a " << name << " from the heap.  */\n\n\n";
		break;
        case OP_HASH 	:
		o << mod_export;
		o << " BUN\n";
		o << d.Name() << "(\n";
		o << "   " << name;
		if (!hasPtr)
			o << "*";
		o << "\tatom\t/* IN: to-be-hashed " << name;
		o << ". */\n);\n";
		o << "\t/* HASH: compute a hash value. */\n";
		o << "\t/* returns a positive integer hash value */\n\n\n";
		break;
        case OP_NULL 	:
		o << mod_export;
		o << " " << name; 
		if (!hasPtr)
			o << "*";
		o << "\n";
		o << d.Name() << "(void);\n\t/* NIL: generic nil " << name << ". */\n";
		o << "\t/* returns a pointer to a nil-" << name << ". */\n\n\n";
		break;
        case OP_PUT 	:
		o << mod_export;
		o << " var_t\n";
		o << d.Name() << "(\n";
		o << "   Heap*\thp,\t/* INOUT: heap of " << name << "s. */\n";
		o << "   var_t*\t\toffset,\t/* OUT: offset from heapbase. */\n";
		o << "   " << name;
		if (!hasPtr)
			o << "*";
		o << "\tatom\t/* IN: to-be-stored atom. */\n);\n";
		o << "\t/* PUT: put a copy of a " << name; 
		o << " into a heap. */\n\n\n";
		break;
        case OP_FIX 	:
		o << mod_export;
		o << " int\n";
		o << d.Name() << "(\n";
		o << "   " << name;
		if (!hasPtr) o << "*";
		o << "\tatom\t/* INOUT: ptr to atom */\n);\n";
		o << "\t/* FIX: decrease the refcnt and return it */\n\n\n";
		break;
        case OP_UNFIX 	:
		o << mod_export;
		o << " int\n";
		o << d.Name() << "(\n";
		o << "   " << name;
		if (!hasPtr) o << "*";
		o << "\tatom\t/* INOUT: ptr to atom */\n);\n";
		o << "\t/* UNFIX: decrease the refcnt and return it */\n\n\n";
		break;
        case OP_LEN 	:
		o << mod_export;
		o << " int\n";
		o << d.Name() << "(\n";
		o << "   " << name;
		if (!hasPtr)
			o << "*";
		o << "\tatom\t/* IN: to-be-measured atom. */\n);";
		o << "\n\t/* LEN: measure length of a variable-sized atom.  */\n";
		o << "\t/* returns the byte-length of the " << name << " */\n\n\n";
		break;
        case OP_HEAP 	:
		o << mod_export;
		o << " void\n";
		o << d.Name() << "(\n";
		o << "   Heap*\thp,\t/* OUT: heap of " << name << "s. */\n";
		o << "   size_t\t\tsize\t/* IN: #atoms you expect to store.*/\n);\n";
		o << "\t/* HEAP: create an empty heap for storing ";
		o << name << "s. */\n";
		o << "\n\n\n";
		break;
        case OP_CHECK 	:
		o << mod_export;
		o << " int\n";
		o << d.Name() << "(\n";
		o << "   Heap*\th,\n   HeapRepair*\thr\n";
		o << ");\t/* returns 1 on success 0 on failure */\n\n\n";
		break;
	case OP_CONVERT  :
		o << mod_export;
		o << " void\n";
		o << d.Name() << "(\n";
		o << "   " << name;
		if (!hasPtr)
			o << "*";
		o << "\tval,\t\t/* IN/OUT: inplace conversion.*/\n";
		o << "   int\t\tdirection\t/* IN: CONV_NTOH or CONV_HTON */\n);\n";
		o << "\t/* This conversion routine is used for both conversions\n";
		o << "\t * from host to network and network to host */\n\n\n";
		break;
	case OP_HCONVERT  :
		o << mod_export;
		o << " void\n";
		o << d.Name() << "(Heap *hp\n";
		o << "\t/* IN/OUT: inplace heap conversion.*/);\n";
		o << "/* This conversion routine is used for both conversions\n";
		o << " * from host to network and network to host */\n";
		break;
	}
	return o; 
}

ostream &
proto::gen_command(ostream &o, const Command &d)
{
   	o << "/* COMMAND " << d.Name() <<  "\n";
	o << " * " << d.hlp() << "\n";
	o << " */\n";
	o << mod_export << " int " << d.fcn() <<"(";
	int hasargs = 0;
	if (d.result()) {
	   	result = 1;
	   	d.result()->Name("res");
	   	d.result()->print(this, o);
	   	result = 0;
		hasargs = 1;
	}
	if (d.args()) {
	   	if (d.result()) {
		   	o << ", ";
		}
		ListIterator *iter = d.args()->iterator();
		Symbol *s = NULL;
		if (iter->next((void**)&s))
			s->print(this, o);
		while(iter->next((void**)&s)) {
		   	o << ", ";
			s->print(this, o);
		}
		hasargs = 1;
	}
	if (!hasargs)
		o << "void";
	o << ");\n\n";
 	return o; 
}

ostream &
proto::gen_operator(ostream &o, const Operator &d)
{
   	o << "/* Operator " << d.Name() <<  "\n";
	o << " * " << d.hlp() << "\n";
	o << " */\n";
	o << mod_export << " int " << d.fcn() <<"(";
	if (d.result()) {
	   	result = 1;
	   	d.result()->Name("res");
	   	d.result()->print(this, o);
	   	result = 0;
		o << ", ";
	}
	d.op1()->print(this, o);
	if (d.op2()) {
		o << ", ";
		d.op2()->print(this, o);
	}
	o << ");\n\n";
 	return o; 
}

ostream &
proto::gen_builtin(ostream &o, const Builtin &d)
{
   	o << "/* Builtin " << d.Name() <<  "\n";
	o << " * " << d.hlp() << "\n";
	o << " */\n";
	o << mod_export << " int " << d.fcn() << "(Cntxt stk, YYSTREE lt, ValPtr res);\n\n";
 	return o; 
}

ostream &
proto::gen_iterator(ostream &o, const Iterator &d)
{
   	o << "/* Iterator " << d.Name() <<  "\n";
	o << " * " << d.hlp() << "\n";
	o << " */\n";
	o << "int " << d.fcn() <<"(";
	if (d.args()) {
		ListIterator *iter = d.args()->iterator();
		Symbol *s = NULL;
		if (iter->next((void**)&s))
			s->print(this, o);
		while(iter->next((void**)&s)) {
		   	o << ", ";
			s->print(this, o);
		}
	}
	o << ");\n\n";
 	return o; 
}

ostream &
proto::gen_atom_arg(ostream &o, const AtomArg &d)
{
	 o << d.arg()->Name(); 
	 if (!(d.arg()->top_type() && d.arg()->top_type()->type() == TYPE_STR))
	 	o << "*"; 
	 if (result && !d.arg()->isFixed())
	 	o << "*"; 
	 o << " " << d.Name();
	 return o; 
}

ostream &
proto::gen_type_arg(ostream &o, const TypeArg &d)
{
   	switch (d.type()) {
	case TYPE_BIT:
		o << "bit*";
		break;
	case TYPE_CHR:
		o << "chr*";
		break;
	case TYPE_BTE:
		o << "bte*";
		break;
	case TYPE_SHT:
		o << "sht*";
		break;
	case TYPE_INT:
		o << "int*";
		break;
	case TYPE_PTR:
		o << "ptr*";
		break;
	case TYPE_OID:
		o << "oid*";
		break;
	case TYPE_WRD:
		o << "wrd*";
		break;
	case TYPE_FLT:
		o << "flt*";
		break;
	case TYPE_DBL:
		o << "dbl*";
		break;
	case TYPE_LNG:
		o << "lng*";
		break;
	case TYPE_STR:
		o << "str"; 
		if (result) 
			o << "*"; 
		break;
	}
	o << " " << d.Name();
	return o; 
}

ostream &
proto::gen_var_arg(ostream &o, const VarArg &)
{
	o << "...";
	return o; 
}

ostream &
proto::gen_bat_arg(ostream &o, const BatArg &d)
{
   	o << "BAT*";
	if (result)
	 	o << "*"; 
	o << " " << d.Name();
	return o; 
}

ostream &
proto::gen_any_arg(ostream &o, const AnyArg &d)
{
	o << "ptr " << d.Name(); 
	if (!d.bound()) {
		if (result) {
			o << ", int *" << d.Name() << "_type";
		} else {
			o << ", int " << d.Name() << "_type";
		}
	}
	return o; 
}

ostream &
proto::gen_prelude(ostream &o, const Prelude &d)
{
   	 o << "/* The prelude function */\n";
	 o << "bat* " << d.Name() << "(void);\n\n";
	 return o; 
}

ostream &
proto::gen_epilogue(ostream &o, const Epilogue &d)
{
   	 o << "/* The epilogue function */\n";
	 o << "void " << d.Name() << "(void);\n\n";
	 return o; 
}
