@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2006 CWI.
@' All Rights Reserved.

@f mel
@a Niels Nes
@v 2.0
@* The Mel Utility
@T
The {\tt mel} utility is a tool for extending monet. 

@+ Manual Page
@T
Monet can be extended using the MEL language. 
We refer to the @[<a href="../index.html">MEL Reference Manual</a>@
for the syntax and semantics of the MEL module specification language.

@- Usage
@T
\begin{verbatim}
	 usage: mel [options] [type] [type_options] file
	    general options
               -Iinclude_dir
            types
               -html     * Documentation generation       		   
               -proto    * Proto-type generation          		     
               -depend   * Dependency generation          		   
               -use      * Use list generation            		     
               -L     	 * List needed for linking used modules            	
               -glue     * generation of code to glue this module to Monet
	       -mil	 * generation of mil module load code
\end{verbatim}
@T
Extending Monet involves several steps. 
\begin{itemize}
\item The extension writer first step is to build the MEL module 
expressing the extension. 

\item Based on this module the mel utility option {\tt -proto} can generate 
a prototype file.

\item The prototype file will contain the prototypes for each function which 
should be implemented in c/c++ by the developer. 

\item Once the prototypes are implemented by the developer, that code 
should be compiled to an object file.

\item The next step is gluing this to Monet. For this the {\tt -glue}
option will generate the necessary wrapper functions to connect the
user defined functions to the Monet kernel and to update the monet
function and atom tables. 

\item The generated file should also be compiled. 

\item Both object files should be linked together to a single 
shared library and copied to the \$MONETHOME/\$ARCH/mlib directory.
The module can be loaded in the Monet server using the module mil
statement. 

\item It  is also possible to have a database specific module, then the
shared library should be copied in the same directory but with filename
postfixed with "-database". 

\item Since modules may depend on other modules (USE statement) building the
necessary object-files and shared libraries should be done in a specific
order. The option {\tt -depend} will generate a {\bf MAKE(1)} like output
expressing the dependencies of the given module.

\item Also when a module depends on an other module the resulting shared 
library should be linked with the shared library of the depending module.
This is needed because else during dynamic loading there are unresolved
references to functions and variables for the depending modules.
The option {\tt -use} generates a list of depending modules. The -L option
returns a list which can be used to link the shared libraries together.

\item Another option of mel is {\tt -html}, which is still under development.
It generates html code for the modules.  
\end{itemize}

@{
@+ Implementation
@T
The {\tt mel} utility is built as a front-end/back-end tool. The front-end 
parses mel in to a symbol table and a syntax tree. The parsing phase
consists also of syntactic and semantic checks. If the parser ends without
errors a back end is started.

The front end started depends on options given to the command. Currently
-html, -glue, -proto, -depend, -mil, -use and -L are supported. 

For each mel keyword a c++ class is constructed which holds the properties
of the statement. These classes inherit from the symbol class so they
can be stored in the symbol table. These classes follow the structure of
the mel module. So the syntax tree resembles the underlying module files
including the once imported via the USE statement. 

The back ends are implemented by overloading the language [language.mx] class. 
Each mel keyword class needs to have a print function which calls its 
gen\_keyword method of the language class. This double dispatch solves the 
problem of finding out what to print in which form. The second parameter 
tells what to print. In case of the gen\_atom method an Atom should be
outputted. The output type, prototype, documentation etc., is defined in
the class overloading the language.

That construction allows us to have special generating classes for each 
needed option or even for parts of an option. The special generating 
classes only implement the needed gen methods. So if only atoms should 
generate output only the gen\_atom method needs to be implemented. 

The language class has an method for handling the options following the
one which equals the string returned from the method get\_name. 
The last argument will not be given to this method. It is assumed to 
be the mel module.

The mel file contains the code for the parser and lexical analyzer.
It uses the class FileInfo for recursive inclusion of USED files.
The FileInfo class keeps various information about these file, including
filename, basename etc. The symbols found by the parser are put in a
symtable. The symtable (see file symtable) depends on the base class 
symbol. As explained before the Symbol class is the bases for all 
keyword classes of mel. 

The classes use, depend, proto, debug, html and glue implement the options of
with the same name. 

Other files needed are list and ListIterator these are simple
implementations of a linked list and an iterator over this list.

For further details look in the code.
@h
#ifndef _MEL_H_
#define _MEL_H_

#ifndef YYSTYPE
#define YYSTYPE	yystype
#endif

#include <stdio.h>
#include "symtable.h"
#include "symbol.h"
#include "list.h"
#include "FileInfo.h"

#include "ops.h"
#include "atomops.h"
#include "type_arg.h"

#include <stdlib.h>

typedef union {
	int i;			// integer
	char *s;		// string
	Symbol *sym;		// symbol
	List *l;		// symbol list
	Ops **a;		// symbol array
	Ops *op;		// Operation
	struct {
		int i1, i2;
	} r;
} yystype;

#define yyerror(err)	mel_yyerror(err)


int yylex();
extern int yyparse();
extern void mel_yyerror(const char *);

extern void *get_cur_buffer();
extern void new_buffer(FILE *f);
extern void close_and_change(void *buf, FILE *f);
extern void semerror();

extern const char *token2str(int token);
extern const char *type2str(int tpe);
extern const char *get_signature(char *fcn);


#define yywrap()	1

extern int parse_error;
extern int sem_error;
extern char *progname;
extern int yylineno;

extern FILE *yyin;

extern Symtable *table;
extern Symbol *root;
extern FileInfo *fileinfo;
extern List *dirs;

#endif

@C
#include <mel_config.h>
#include "mel.h"
#include "mel.tab.h"
#ifdef HAVE_IOSTREAM
#include <iostream>
#include <fstream>
using namespace std;
#else
#include <iostream.h>
#include <fstream.h>
#endif

#ifdef HAVE_UNISTD_H
# include <unistd.h>
#endif
#ifdef HAVE_IO_H
# include <io.h>
#endif

#include "use.h"
#include "link.h"
#include "depend.h"
#include "proto.h"
#include "html.h"
#include "glue.h"
#include "mil.h"

int parse_error = 0;		/* number of parse errors. */
int sem_error = 0;		/* number of semantic errors. */
char *progname = 0;
char *outfile = 0;
Symtable *table = NULL;
Symbol *root = NULL;
FileInfo *fileinfo = NULL;
List *dirs = NULL;

language *l = NULL;

#if defined(__MINGW32_VERSION) || HAVE_DECL_STRDUP==0
char *
strdup(const char *s)
{
	return strcpy((char *) malloc(strlen(s) + 1), s);
}
#endif

const char *
token2str(int token)
{
	switch (token) {
	case MEL_MODULE:
		return "module";
	case MEL_ITERATOR:
		return "iterator";
	case MEL_USE:
		return "use";
	case MEL_PRELUDE:
		return "prelude";
	case MEL_EPILOGUE:
		return "epilogue";
	case MEL_END:
		return "end";
	case MEL_IDENTIFIER:
		return "identifier";
	case MEL_STRING:
		return "string";
	case MEL_BUILTIN:
		return "builtin";
	case MEL_OBJECT:
		return "object";
	case MEL_COMMAND:
		return "command";
	case MEL_OPERATOR0:
		return "operator0";
	case MEL_OPERATOR:
		return "operator";
	case MEL_OPERATOR1:
		return "operator1";
	case MEL_ATOM:
		return "atom";
	case MEL_ATOMOP:
		return "atom TODO";
	case MEL_ANY:
		return "any";
	case MEL_BAT:
		return "BAT";
	case MEL_TYPE:
		return "builtin type";
	case MEL_VARARGS:
		return "...";
	case MEL_SEP:
		return "::";
	case MEL_NUMBER:
		return "number";
	}
	return "default";
}

const char *
type2str(int t)
{
	switch (t) {
	case TYPE_BIT:
		return "bit";
	case TYPE_CHR:
		return "chr";
	case TYPE_SHT:
		return "sht";
	case TYPE_INT:
		return "int";
	case TYPE_PTR:
		return "ptr";
	case TYPE_OID:
		return "oid";
	case TYPE_FLT:
		return "flt";
	case TYPE_DBL:
		return "dbl";
	case TYPE_LNG:
		return "lng";
	case TYPE_STR:
		return "str";
	}
	return "void";
}

void
usage(char *prg)
{
	cerr << "usage: " << prg << " [options] [type] [type_options] file\n";
	cerr << "options\n";
	cerr << "\t -Iinclude_dir\n";
	cerr << "\t -o output_file\n";
	cerr << "types\n";
	cerr << "\t -html     /* Documentation generation            */\n";
	cerr << "\t -proto    /* Proto-type generation               */\n";
	cerr << "\t -depend   /* Dependency generation               */\n";
	cerr << "\t -use      /* Use list generation                 */\n";
	cerr << "\t -L        /* Link information                    */\n";
	cerr << "\t -glue     /* generation of code to glue this mel module to Monet */\n";
	cerr << "\t -mil      /* generation of mil module load code */\n";
}

int
handle_args(int argc, char *argv[])
{
	int i = 1;

	if (argc < 2) {
		usage(argv[0]);
		return 0;
	}
	progname = argv[0];
	while (i < argc - 1) {
		if (argv[i][0] != '-') {
			cerr << "Unknown option " << argv[i] << "\n";
			usage(argv[0]);
			return 0;
		}
		switch (argv[i][1]) {
		case 'I':
			if (argv[i][2] == '\0') {
				i++;
				dirs->insert(strdup(argv[i]));
			} else {
				dirs->insert(strdup(argv[i] + 2));
			}
			break;
		case 'D':
			/* ignore -D option */
			if (argv[i][2] == '\0')
				i++;
			break;
		case 'd':
			l = new depend ();

			break;
		case 'u':
			l = new use();
			break;
		case 'o':
			if (argv[i][2] == '\0') {
				i++;
				dirs->insert(strdup(argv[i]));
				outfile = strdup(argv[i]);
			} else {
				outfile = strdup(argv[i] + 2);
			}
			break;
		case 'm':
			l = new mil();
			break;
		case 'p':
			l = new proto ();

			break;
		case 'g':
			l = new glue ();

			break;
		case 'h':
			l = new html();
			break;
		case 'L':
			l = new Link();
			break;
		default:
			cerr << "Unknown option " << argv[i] << "\n";
			usage(argv[0]);
			return 0;
		}
		i++;
		if (l) {
			return l->handle_args(argc - 1 - i, argv + i);
		}
	}
	return 1;
}

int
main(int argc, char *argv[])
{
	/* argument parsing will be done in two parts
	 * First general arguments
	 * second lang specific
	 */
	dirs = new List (50);

	if (!handle_args(argc, argv)) {
		exit(EXIT_FAILURE);
	}
	char *filename = argv[argc - 1];
	fileinfo = FileInfo::open(filename);

	if (fileinfo) {
		yyin = fileinfo->FilePtr();
		table = new Symtable (500);
		table->insert(*new Symbol (MEL_USE, fileinfo->BaseName()));

		(void) yyparse();
		if (parse_error || sem_error) {
			if (parse_error) {
				cerr << "Found " << parse_error;
				cerr << " syntax errors.\n";
			}
			if (sem_error) {
				cerr << "Found " << sem_error;
				cerr << " semantic errors.\n";
			}
			exit(EXIT_FAILURE);
		}
		if (!l) {
			l = new proto ();
		}
		if (outfile) {
			ofstream & o = *new ofstream(outfile);
			if (!o) {
				cerr << "Error: output file exists.\n";
				exit(EXIT_FAILURE);
			}
			l->generate_table(o, table);
			l->generate_code(o, root);
			o.close();
			delete(&o);
		} else {
			l->generate_table(cout, table);
			l->generate_code(cout, root);
		}
		delete(l);
		delete(table);
		delete(root);
	} else {
		cerr << "File not found " << filename << "\n";
		exit(EXIT_FAILURE);
	}
	delete(fileinfo);
	return 0;
}
@L 
%{
#include <mel_config.h>
#include "mel.h"
#include "mel.tab.h"
#include <stdlib.h>
#include <ctype.h>
#include <string.h>

extern yystype yylval;

#ifdef FLEX_SCANNER
#if !defined(YY_FLEX_SUBMINOR_VERSION) || YY_FLEX_SUBMINOR_VERSION < 5
/* flex 2.5.31 declares yylineno.  I don't know which other versions
   do as well. */
int yylineno;
#endif
#define YY_SKIP_YYWRAP
/*
#define YY_INPUT(buf,result,max_size)	{ \
			int c = getc(yyin); \
			if (c == '\n') yylineno++; \
                        result = (c==EOF) ? YY_NULL: (buf[0] = (char)c,1);}
 */
#else
extern int yyerrok;

#undef YYLMAX
#define YYLMAX	100000
#endif

#ifdef __MINGW32_VERSION
int
isatty(int fd)
{
	(void) fd;
	return 1;
}
#endif

void
check_lineno(char *line)
{
	int l;

	if (sscanf(line, "%d", &l) == 1) {
		char *p = strchr(line + 1, '"');

		if (p) {
			char *filename = (char *) strdup(++p);

			yylineno = l;
			p = strchr(filename, '"');
			if (p)
				*p = 0;
			if (filename)
				fileinfo->FileName(filename);
		}
	}
}

/*
int
yywrap()
{
	return(1);
}
*/

#ifdef FLEX_SCANNER
void *
get_cur_buffer()
{
	return (void *) YY_CURRENT_BUFFER;
}

void
new_buffer(FILE *f)
{
	yy_switch_to_buffer(yy_create_buffer(f, YY_BUF_SIZE));
}

void
close_and_change(void *buf, FILE *)
{
	yy_delete_buffer(YY_CURRENT_BUFFER);
	yy_switch_to_buffer((yy_buffer_state *) buf);
}
#else

struct yy_buffer {
/*   	unsigned char yysbuf[YYLMAX];
	unsigned char *yysptr; */
	char yysbuf[YYLMAX];
	char *yysptr;
};

void *
get_cur_buffer()
{
	yy_buffer *b = new yy_buffer;

	memcpy(b->yysbuf, yysbuf, YYLMAX);
	b->yysptr = yysptr;
	return (void *) b;
}

void
new_buffer(FILE *f)
{
	yysptr = yysbuf;
	yyin = f;
}

void
close_and_change(void *buf, FILE *f)
{
	yy_buffer *b = (yy_buffer *) buf;

	fclose(yyin);
	memcpy(yysbuf, b->yysbuf, YYLMAX);
	yysptr = b->yysptr;
	yyin = f;
}

#endif

int script_nr = 0;
int script_len = 0;
char *script = NULL;

extern void script_start();
%}
%p 3400
%a 2300
%e 2000

YY_DIGIT    	[0-9]
YY_LETTER    	[_a-zA-Z]
YY_SPACE    	[\t\n ]
YY_SPACES    	[\t\n ]*
%%
(".iterator"|".ITERATOR") { return MEL_ITERATOR; 		  	}
(".module"|".MODULE")	  { return MEL_MODULE; 		     		}
(".USE"|".use")		  { return MEL_USE;				}
(".PRELUDE"|".prelude")	  { return MEL_PRELUDE; 			}
(".EPILOGUE"|".epilogue") { return MEL_EPILOGUE;			}
(".END"|".end")		  { return MEL_END; 	     			}
(".BUILTIN"|".builtin")	  { return MEL_BUILTIN; 			}
(".OBJECT"|".object")	  { return MEL_OBJECT; 				}
(".COMMAND"|".command")	  { return MEL_COMMAND; 			}
(".OPERATOR0"|".operator0") { return MEL_OPERATOR0; 			}
(".OPERATOR"|".operator") { return MEL_OPERATOR; 			}
(".OPERATOR1"|".operator1") { return MEL_OPERATOR1; 			}
(".ATOM"|".atom")	  { return MEL_ATOM; 	     			}
(".FIXED_ATOM"|".fixed_atom")	  { return MEL_FIXEDATOM; 		}
(".TOSTR"|".tostr")	  { yylval.i = OP_TOSTR; return MEL_ATOMOP;	}
(".FROMSTR"|".fromstr")	  { yylval.i = OP_FROMSTR; return MEL_ATOMOP; 	}
(".READ"|".read")	  { yylval.i = OP_READ; return MEL_ATOMOP;	}
(".WRITE"|".write")	  { yylval.i = OP_WRITE; return MEL_ATOMOP; 	}
(".COMP"|".comp")	  { yylval.i = OP_COMP; return MEL_ATOMOP; 	}
(".NEQUAL"|".nequal")	  { yylval.i = OP_NEQUAL; return MEL_ATOMOP; 	}
(".DEL"|".del")		  { yylval.i = OP_DEL; return MEL_ATOMOP; 	}
(".HASH"|".hash")	  { yylval.i = OP_HASH; return MEL_ATOMOP; 	}
(".NULL"|".null")	  { yylval.i = OP_NULL; return MEL_ATOMOP; 	}
(".CONVERT"|".CONVERT")	  { yylval.i = OP_CONVERT; return MEL_ATOMOP; 	}
(".HEAPCONVERT"|".heapconvert")	  { yylval.i = OP_HCONVERT; return MEL_ATOMOP; 	}
(".PUT"|".put")		  { yylval.i = OP_PUT; return MEL_ATOMOP; 	}
(".FIX"|".fix")		  { yylval.i = OP_FIX; return MEL_ATOMOP; 	}
(".UNFIX"|".unfix")	  { yylval.i = OP_UNFIX; return MEL_ATOMOP; 	}
(".LENGTH"|".length")	  { yylval.i = OP_LEN; return MEL_ATOMOP; 	}
(".HEAP"|".heap")	  { yylval.i = OP_HEAP; return MEL_ATOMOP; 	}
(".CHECK"|".check")	  { yylval.i = OP_CHECK; return MEL_ATOMOP; 	}

("ANY"|"any") 		  { return MEL_ANY;     			}
("BAT"|"bat")		  { return MEL_BAT;     			}
("VOID"|"void")		  { return MEL_VOID;   				}
("BIT"|"bit")		  { yylval.i = TYPE_BIT; return MEL_TYPE;	}
("CHR"|"chr")		  { yylval.i = TYPE_CHR; return MEL_TYPE;	}
("SHT"|"sht")		  { yylval.i = TYPE_SHT; return MEL_TYPE;	}
("INT"|"int")		  { yylval.i = TYPE_INT; return MEL_TYPE;    	}
("PTR"|"ptr") 		  { yylval.i = TYPE_PTR; return MEL_TYPE;	}
("OID"|"oid")		  { yylval.i = TYPE_OID; return MEL_TYPE;	}
("FLT"|"flt")		  { yylval.i = TYPE_FLT; return MEL_TYPE;	}
("DBL"|"dbl")		  { yylval.i = TYPE_DBL; return MEL_TYPE;	}
("LNG"|"lng")		  { yylval.i = TYPE_LNG; return MEL_TYPE; 	}
("STR"|"str")		  { yylval.i = TYPE_STR; return MEL_TYPE;	}
("..."|"..")		  { return MEL_VARARGS;				}
"::"			  { return MEL_SEP;				}
"="			  { return '='; 				}
":"			  { return ':';					}
";"			  { return ';'; 				}
","			  { return ','; 				}
"("			  { return '('; 				}
")"			  { return ')'; 				}
"["			  { return '['; 				}
"]"			  { return ']'; 				}
"{"			  { return '{'; 				}
"}"			  { return '}'; 				}
\"[^"]*         	  { if (yytext[yyleng-1] == '\\') {
                      		yymore();  /* " can be escaped */
                	  } else {
				char *s; int i=1;
				yyinput(); /* read '"' */
				yytext[yyleng] = 0;
				for(s = yytext+1; *s; s++,i++)
				    if (*s=='\t' || *s=='\n') i++;
				s = (char*)malloc(i);
				yylval.s = (char*) s;
				for(i = 1; yytext[i]; i++)
				    if (yytext[i]=='\t') {
				        *s++ = '\\'; *s++='t';
				    } else if (yytext[i]=='\n') {
				        *s++ = '\\'; *s++='n';
				    } else *s++ = yytext[i];
				*s = 0;
				return MEL_STRING;
			  }						}
{YY_LETTER}({YY_LETTER}|{YY_DIGIT})* {
			yytext[yyleng] = 0; yylval.s = strdup(yytext);
			if (table->find(MEL_USE, yylval.s))
				return MEL_USED;
			return MEL_IDENTIFIER; 	     			}
{YY_DIGIT}+	{	yytext[yyleng] = 0; yylval.i = (int) atoi(yytext);
			return MEL_NUMBER;	 		     	}
"#line"		{     char line[1024], *p=line;
			while ((*p = yyinput()) != '\n') p++;
			check_lineno(line); return yylex();	      	}
"#"		{     while (yyinput() != '\n'); return yylex();	}
{YY_SPACES}		;
.		{ 	fprintf(stderr, "discarding '%c'\n", yytext[0]);}
%%
int str = 0, esc = 0, chr = 0;

void
mel_yyerror(const char *err)
{
	if (progname) {
		cerr << progname << ": ";
	}
	if (fileinfo->FileName()) {
		cerr << "\"" << fileinfo->FileName() << "\", ";
	}
	if (yylineno > 0) {
		cerr << "line " << (yylineno) << ", ";
	}
	cerr << err;
	if (*yytext) {
		int i;

		for (i = 0; i < 20; i++) {
			if (!yytext[i] || yytext[i] == '\n') {
				break;
			}
		}
		if (i) {
			cerr << " at \"" << i << "\" of " << yytext;
		}
	} else {
		cerr << " at end-of-file";
	}
	cerr << ".\n";
	parse_error++;
}

void
script_start()
{
	script_nr = 0;
	script_len = BUFSIZ;
	script = new char[script_len];
	str = esc = chr = 0;

	script[0] = '\0';
}

int
char_concat(char c)
{
	if (script_nr + 10 > script_len) {
		script_len *= 2;
		char *new_script = new char[script_len];

		strncpy(new_script, script, script_nr);
		delete(script);
		script = new_script;
	}
	if (str == 0 && chr == 0 && esc == 0 && c == '#') {
		return 0;
	} else if (c == '\\') {
		script[script_nr++] = '\\';
		script[script_nr++] = '\\';
		if (esc == 0 && str == 0 && chr == 0) {
			esc = 1;
		}
	} else {
		if (c == '\t') {
			script[script_nr++] = '\\';
			script[script_nr++] = 't';
		} else if (c == '\'') {
			script[script_nr++] = '\'';
			if (esc == 0 && str == 0)
				chr = chr ? 0 : 4;
		} else if (c == '"') {
			script[script_nr++] = '\\';
			script[script_nr++] = '"';
			if (esc == 0 && chr == 0)
				str = str ? 0 : 1;
		} else {
			script[script_nr++] = c;
		}
		esc = 0;
	}
	if (chr)
		chr --;

	return 1;
}

const char *
get_signature(char *fcn)
{
	int c, echo = 1;

	script_start();
	while (*fcn) {
		char_concat(*fcn++);
	}
	while ((c = yyinput()) && c != '=') {
		if (c == '\n')
			echo = 1;
		if (echo)
			echo = char_concat(c);
	}
	script[script_nr] = 0;
	return script;
}
@Y
%{
#include <mel_config.h>
#include "mel.h"
#include <string.h>
#ifdef HAVE_MALLOC_H
#include <malloc.h>
#endif
#ifdef HAVE_IOSTREAM
#include <iostream>
#else
#include <iostream.h>
#endif
#ifdef HAVE_CSTDIO
#include  <cstdio>
#else
#include <stdio.h>
#endif
#if defined(HAVE_IOSTREAM) || defined(HAVE_CSTDIO)
using namespace std;
#endif

#include "FileInfo.h"
#include "module.h"
#include "dependency.h"
#include "atom.h"
#include "atomops.h"
#include "command.h"
#include "operator.h"
#include "builtin.h"
#include "iterator.h"
#include "object.h"
#include "atom_arg.h"
#include "type_arg.h"
#include "var_arg.h"
#include "bat_arg.h"
#include "any_arg.h"
#include "prelude.h"
#include "epilogue.h"

extern char *script;
%}

%token MEL_MODULE MEL_PRELUDE MEL_EPILOGUE MEL_END MEL_COMMAND 
%token MEL_OPERATOR0 MEL_OPERATOR MEL_OPERATOR1
%token MEL_FIXEDATOM MEL_ATOM MEL_USE MEL_ATOMOP MEL_STRING MEL_IDENTIFIER
%token MEL_USED
%token MEL_NUMBER
%token MEL_ANY MEL_BAT MEL_TYPE MEL_VOID MEL_BUILTIN MEL_OBJECT
%token MEL_VARARGS MEL_SEP MEL_ITERATOR 
%token '=' ';' ':' ',' '(' ')'
%%
module:
      { yylineno = fileinfo->LineNo();
	yyin = fileinfo->FilePtr(); }
	module_begin dependencies definitions module_end
      { FileInfo *f = fileinfo->Parent();
	if (f == NULL) {
	    root = new Module(MEL_MODULE, $2.s,
	    	fileinfo->FileName(), $3.l, $4.l);
	} else {
      	 	yylineno = f->LineNo();
		$$.sym = new Module(MEL_MODULE, $2.s,
	    		fileinfo->FileName(), $3.l, $4.l);
		close_and_change(f->Buffer(), f->FilePtr());
		delete(fileinfo);
		fileinfo = f;
	} }
    ;

module_begin:
    	MEL_MODULE ident ';'
      { $$.s = $2.s; }
    |	MEL_MODULE ident
      { $$.s = $2.s;
        yyerror("missing \';\'"); }
    |	MEL_MODULE ';'
      { $$.s = fileinfo->BaseName();
        yyerror("missing \'module name\'"); }
    ;

module_end:
	MEL_END ident ';'
      { $$.s = $2.s; }
    |	MEL_END ';'
      { $$.s = fileinfo->BaseName();
        yyerror("missing \'module name\'"); }
    ;

dependencies:
	ne_dependencies
    |  /* empty */
      { $$.l = NULL; }
    ;

ne_dependencies:
	ne_dependencies dependency
      { $$.l = $1.l;
	if ($2.l) {
		$$.l->insert($2.l);
		delete($2.l);
	} }
   |	dependency
      { $$.l = $1.l; }
    ;

dependency:
	MEL_USE modulelist ';'
      { $$.l = $2.l; }
    ;

modulelist:
	modulelist ',' modulename
       { $$.l = $1.l;
         if ($3.sym)
	 	$$.l->insert($3.sym); }
    |   modulename
       { $$.l = new List(50);
         if ($1.sym)
	 	$$.l->insert($1.sym); }
    ;

modulename:
	module_ident
      { fileinfo->Buffer(get_cur_buffer());
	fileinfo->LineNo(yylineno);
	char *filename = FileInfo::find_module($1.s, dirs);
	if (filename) {
		fileinfo = FileInfo::open(filename, $1.s, fileinfo);
		new_buffer(fileinfo->FilePtr());
		$1.sym = new Dependency(MEL_USE, $1.s, fileinfo->FileName());
	  	table->insert(*$1.sym);
	} else {
		yyerror("Module not found");
		$1.sym = NULL;
	} }
	module
	{ $$.sym = $1.sym;
	  ((Dependency*)$$.sym)->setModule($3.sym); }
    | 	MEL_USED
    	{ $$.sym = NULL; }
    ;

definitions:
     	ne_definitions
   |  /* empty */
      { $$.l = NULL; }
    ;

ne_definitions:
     	ne_definitions definition
      { $$.l = $1.l;
	if ($2.sym)
		$$.l->insert($2.sym); }
   |    definition
      { $$.l = new List(500);
	if ($1.sym)
		$$.l->insert($1.sym); }
    ;

definition:
   	atomdef
   |	command
   |	iterator
   |	builtin
   |	operator
   |	object
   |    MEL_PRELUDE '=' ident ';'
      { $$.sym = new Prelude(MEL_PRELUDE, $3.s); 	}
   |	MEL_EPILOGUE '=' ident ';'
      { $$.sym = new Epilogue(MEL_EPILOGUE, $3.s); 	}
    ;

iterator:
     	MEL_ITERATOR ident
	'(' args ')'
     	'=' ident ';' MEL_STRING
      { $$.sym = new Iterator(MEL_ITERATOR, $2.s, $7.s, $4.l, $9.s); }
    ;

builtin:
     	MEL_BUILTIN commandname { get_signature($2.s); } ident ';' MEL_STRING
      { $$.sym = new Builtin(MEL_BUILTIN, $2.s, $4.s, $6.s, script); }
    ;

command:
     	MEL_COMMAND commandname '(' args ')' returntype
	'=' ident ';' MEL_STRING
      { $$.sym = new Command(
      		MEL_COMMAND, $2.s, $8.s, NORMAL, $6.sym, $4.l, $10.s); }
   |	MEL_COMMAND '{' commandname '}' '(' args ')' returntype
	'=' ident ';' MEL_STRING
      { $$.sym = new Command(
      		MEL_COMMAND, $3.s, $10.s, AGGREGATE, $8.sym, $6.l, $12.s); }
   |	MEL_COMMAND '[' commandname ']' '(' args ')' returntype
	'=' ident ';' MEL_STRING
      { $$.sym = new Command(
      		MEL_COMMAND, $3.s, $10.s, MULTIPLEX, $8.sym, $6.l, $12.s); }
    ;

commandname:
      	ident
    |  	MEL_STRING
    ;

operator:
      { anynr_clear(); }
     	MEL_OPERATOR0 operand MEL_STRING operand returntype
	'=' ident ';' MEL_STRING
      { $$.sym = new Operator(
      		MEL_OPERATOR0, $4.s, $8.s, $6.sym, $3.sym, $5.sym, $10.s); }
    |
      { anynr_clear(); }
     	MEL_OPERATOR operand MEL_STRING operand returntype
	'=' ident ';' MEL_STRING
      { $$.sym = new Operator(
      		MEL_OPERATOR, $4.s, $8.s, $6.sym, $3.sym, $5.sym, $10.s); }
    |
      { anynr_clear(); }
     	MEL_OPERATOR1 operand MEL_STRING operand returntype
	'=' ident ';' MEL_STRING
      { $$.sym = new Operator(
      		MEL_OPERATOR1, $4.s, $8.s, $6.sym, $3.sym, $5.sym, $10.s); }
    ;

operand:
     	'(' arg ')'
      { $$.sym = $2.sym; }
   |  /* empty */
      { $$.sym = NULL; }
    ;

object:
     	MEL_OBJECT ident ';'
      { $$.sym = new Object(MEL_OBJECT, $2.s); }
   |    MEL_OBJECT ident '=' ident ';'
      { const Symbol *s = table->find(MEL_ATOM, $4.s);
        if (s) {
       	 	$$.sym = new Object(MEL_OBJECT, $2.s, s);
	} else {
	   	yyerror("object not found");
		$$.sym = NULL;
	} }
    ;

args:
      { anynr_clear(); }
	ne_args
      { $$ = $2; }
   |	/* empty */
      { $$.l = NULL; }
    ;

ne_args:
	ne_args ',' lastarg
       { $$.l = $1.l;
	 if ($3.sym)
	 	$$.l->insert($3.sym); }
    |	arg
       { $$.l = new List(20);
	 if ($1.sym)
	 	$$.l->insert($1.sym); }
    ;

lastarg:
	arg
   |	MEL_VARARGS atom MEL_VARARGS
      { $$.sym = new VarArg(MEL_VARARGS, NULL, $2.sym); }
   |    MEL_VARARGS
      { $$.sym = new VarArg(MEL_VARARGS, NULL); }
    ;

arg:
     	atom varname
      { if ($1.sym)
	 	$1.sym->Name($2.s);
	$$.sym = $1.sym; 		}
    ;

varname:
	ident
      { $$.s = $1.s; }
    |	/* empty */
      { $$.s = NULL; }
    ;

returntype:
     	':' atom
      { $$.sym = $2.sym; }
   |	/* empty */
      { $$.sym = NULL; }
    ;

atomdef:
   	MEL_ATOM ident '=' parentatom ';' atomops MEL_END ';'
      { $$.sym = new Atom(MEL_ATOM, $2.s, -1, 0, (Atom*)$4.sym, $6.a);
      	if (!table->find(MEL_ATOM, $2.s))
		table->insert(*$$.sym);
	else {
	   	yyerror("Atom redefined");
		semerror();
	} }
   |	MEL_ATOM ident '=' type ';' atomops MEL_END ';'
      { $$.sym = new Atom(MEL_ATOM, $2.s, -1, 0, (Arg*)$4.sym, $6.a);
      	if (!table->find(MEL_ATOM, $2.s))
		table->insert(*$$.sym);
	else {
	   	yyerror("Atom redefined");
		semerror();
	} }
   | 	MEL_ATOM ident fixedmeasures ';' atomops MEL_END ';'
      { $$.sym = new Atom(MEL_ATOM, $2.s, $3.r.i1, $3.r.i2, (Atom*)NULL, $5.a);
      	if (!table->find(MEL_ATOM, $2.s))
		table->insert(*$$.sym);
	else {
	   	yyerror("Atom redefined");
		semerror();
	} }
   | 	MEL_FIXEDATOM ident ';' atomops MEL_END ';'
      { $$.sym = new Atom(MEL_ATOM, $2.s, 0, 0, (Atom*)NULL, $4.a);
      	if (!table->find(MEL_ATOM, $2.s))
		table->insert(*$$.sym);
	else {
	   	yyerror("Atom redefined");
		semerror();
	} }
   | 	error
      { $$.sym = NULL; }
    ;

fixedmeasures:
    	'[' fixedspec ']'
      { $$.r.i1 = $2.r.i1;
	$$.r.i2 = $2.r.i2; }
   |  	/* empty */
      { $$.r.i1 = -1;
	$$.r.i2 = 0; }
    ;

fixedspec:
	MEL_NUMBER alignment
      { $$.r.i1 = $1.i;
	$$.r.i2 = $2.i; }
   |  	/* empty */
      { $$.r.i1 = -1;
	$$.r.i2 = 0; }
    ;

alignment:
	',' MEL_NUMBER
       { $$.i = $2.i; }
   |  /* empty */
       { $$.i = 0; }
    ;

atomops:
	ne_atomops
   |	/* empty */
      { $$.a = NULL; }
    ;

ne_atomops:
	ne_atomops atomop
       { $$.a = $1.a;
         if ($2.op)
	 	$$.a[$2.op->operation()] = $2.op;
	    	if ($2.op->operation() == OP_NEQUAL)
	 		$$.a[OP_COMP] = $2.op;
	}
    |   atomop
       { $$.a = new Ops*[20]; for(int i =0; i<20;i++) $$.a[i] = NULL;
         if ($1.op)
	 	$$.a[$1.op->operation()] = $1.op;
	    	if ($1.op->operation() == OP_NEQUAL)
	 		$$.a[OP_COMP] = $1.op; }
    ;

atomop:
   	MEL_ATOMOP '=' ident ';'
      { $$.op = new Atomops(MEL_ATOMOP, $3.s, $1.i); }
    ;


parentatom:
   	ident
      { const Symbol *s = table->find(MEL_ATOM, $1.s);
        if (s) {
        	$$.sym = (Symbol*)s;
	} else {
		yyerror("Atom not found");
		$$.sym = NULL;
	} }
    ;

trueatom:
   	ident
      { const Symbol *s = table->find(MEL_ATOM, $1.s);
        if (s)
        	$$.sym = new AtomArg(MEL_ATOM, "", (Atom*)s , NULL);
	else {
		yyerror("Atom not found");
		$$.sym = NULL;
	} }
    ;

type:
       MEL_TYPE
      { $$.sym = new TypeArg(MEL_TYPE, NULL, $1.i , NULL);   	}
   |   MEL_BAT
      { $$.sym = new BatArg(MEL_BAT, NULL, NULL, NULL); 	}
    ;

atom:
     	MEL_ANY	anyspec
      { $$.sym = new AnyArg(MEL_ANY, NULL, $2.i); }
   |    type
   |    trueatom
   |	MEL_BAT '[' atom ','  atom ']'
      { $$.sym = new BatArg(MEL_BAT, NULL, (Arg*) $3.sym, (Arg*) $5.sym); }
   |    MEL_VOID
      { $$.sym = NULL; }
    ;

anyspec:
	MEL_SEP MEL_NUMBER
      { $$.i = $2.i;
        if ($2.i >= ANY_MAX || $2.i < 0) {
	   yyerror("Wrong any number, should be in range [0..31]");
	   $$.i = -1;
	} }
   |	/* empty */
      { $$.i = -1; }
    ;

ident:
	MEL_IDENTIFIER
    |   MEL_USED
    |	MEL_BAT
	{ $$.s = strdup("bat"); }
    |   MEL_VOID
	{ $$.s = strdup("void"); }
    |   MEL_TYPE
	{ $$.s = (char*)type2str(yyval.i); }
    ;

module_ident:
	MEL_IDENTIFIER
    |	MEL_BAT
	{ $$.s = strdup("bat"); }
    |   MEL_VOID
	{ $$.s = strdup("void"); }
    |   MEL_TYPE
	{ $$.s = (char*)type2str(yyval.i); }
    ;
%%

void
semerror()
{
	if (progname) {
		cerr << progname << ": ";
	}
	if (fileinfo->FileName()) {
		cerr << "\"" << fileinfo->FileName() << "\", ";
	}
	if (yylineno > 0) {
		cerr << "line " << (yylineno) << ", ";
	}
	cerr << "semantic error: ";
	sem_error++;
}
@}
