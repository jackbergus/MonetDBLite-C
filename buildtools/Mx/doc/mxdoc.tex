\documentclass{article}
\usepackage{html}
\begin{document}
\newcommand{\Mx}{{\it M}x }
\begin{htmlonly}
\newcommand{\Lc}[1]{\it{\char92#1}}
\end{htmlonly}
%begin{latexonly}
\newcommand{\Lc}[1]{$\backslash #1$}
%end{latexonly}

\title{Mx documentation tool}
\author{M.L. Kersten, F. Schippers, C.A. van den Berg, P. Boncz}
\maketitle

\section{Introduction}
The \Mx documentation tool enables the programmer to keep 
source code and documentation in a single file. Thus once the program 
is finished the documentation of the program is also written. 
The use of a text formatter enables the programmer to express more 
clearly properties of the program. 

Just consider a pictorial presentation of the program structure or an 
assertion on a set of variables, typeset in a mathematical style. 
The result is clearly a readable document. 

Moreover, keeping the documentation with the source code
and supporting software debugging through the \Mx-document,
stimulates the programmer to provide up-to-date and better quality code.
Therefore, the programmer uses special \Mx-directives, to separate
the code sections from the documentation sections. 
The overhead involved of writing a program as a \Mx-document is 
kept minimal.

The development of Mx was inspired by the articles of Knuth on the
WEB system \cite{Literate} \cite{Programming}. 
Our implementation was driven by need for certain facilities
and by avoiding needless type-setting directives in code fragments.
It is currently being used within a large, multi-person programming
effort aimed at the development of a distributed main-memory database
management system.

\newpage
\section{Use of \Mx}
An \Mx document consists of text blocks, which are separated by \Mx
directives. The \Mx program uses these directives to separate code
from comment. The \Mx program can be run in two different modes:
code extraction mode and document mode. 

In code extraction mode it will gather all the code blocks from the
\Mx document and direct it to a code file. The name of this code file
is determined by the basename of the \Mx document file and the specific
code directive, which precedes the code block. The code directive
depends therefore on the programming language used. Currently the
languages  C, Prolog, Qnap, POOL, Yacc, Lex and MEL (Monet Extension Language)
are supported.
The basename can be changed in the \Mx document using a special
directive. This enables to describe several different program units in
a single \Mx file. Line directives are added to the code file, 
which refer to the position of the code block in the original \Mx document. 

In document extraction mode, a file for a document formatting program
is generated, which includes the comment and the program code.
Currently the \LaTeX\ and ``troff -ms'' and Netscape-enhanced HTML 
formatting programs are supported. 
In-line directives for typesetting characters in bold,
italics or in code font are included in \Mx. It is not possible to
express everything you want in \Mx. There is an escape mechanism,
which allows you to use the document formatter of your choice, if you
want to present figures or tables in your document.

\Mx creates a table of contents containing a reference to all sections
and subsections of the document. The user can also create up to 9
different indexes himself. The indexes are sorted
alphabetically on the entries.

\Mx supports multilevel hiding of text. Large parts of
programs are generally not interesting enough to include them in a
final document. By running \Mx with different
hiding levels, one can produce documents in several gradations of
detail, from manager style to system programmer style.
Some comments on the code will never be included in the final
document. An archiving option is available to retain the early
attempts, valuable remarks on buggy code, etc.,  
within the \Mx document by marking them as being archived.

Two kind of directives influence both the code extraction and the
document extraction mode. They are parametrized text macros and 
conditional statements. The macros calls are expanded for code extraction,
but not for document extraction. In a document the macro calls are
annotated with a reference to the section and subsection, where
the macro is defined.
Conditional statements are used to define different versions of the
code or document. For instance if the code must be written for two
different compilers, it is possible to include two different versions
in a single document and distinguish between them using a conditional
statement. The condition is triggered by the existence of a macro
definition. Simple macros can also be defined on the command line of
the \Mx program. 

\newpage
\section{Command line options}
\newcommand{\macro}{{$<${\it macro}$>$}}
\newcommand{\file}{{$<${\it file}$>$}}
\newcommand{\text}{{$<${\it text}$>$}}
\newcommand{\mxfile}{{\file{\bf .mx}}}
\newcommand{\example}[2]{
	\begin{table}
	\begin{tabular}{|lp{0.5 \linewidth}|}\hline #2 \hline \end{tabular}
	\caption{#1}
	\end{table}}
\newcommand{\n}{$<n>$}

\begin{verbatim}
Usage: Mx <flags> <file>.mx.
        -t              Produce LaTeX document (default).
        -c              Extract code.
        -R<dir>         Set target directory to <dir>).
        -S<style>       Set LaTeX documentstyle to 'style'.
        -s              Produce nroff -ms document.
        -1              Single column (default) .
        -2              Double column.
        -H<n>           Set hide level to 'n' (-H0 default).
        -d              Produce a draft document.
        -x <extension>  Extract <extension> labelled code.
        -w              Extract HTML code.
        -D<id>          Define macro 'id'.
        -T<string>      Define default hide text <string>.
\end{verbatim}

\subsection{Code extraction}

For code extraction \Mx is called with the following arguments:
\noindent
\begin{center}
        {\tt Mx -c\{\file\} \{-D\macro\}$^+$ \mxfile }
\end{center}

The {\tt -c} option sets \Mx in code extraction mode. If a \file
argument is given \Mx will only extract the code blocks, which are
directed to a file with the same basename. 
By default \Mx extracts all the code files. 

The {\tt -D\macro} option is used for defining body-less macros. If used in
combination with the conditional statements, a single \Mx document can
produce different document and code versions.

The example in table 1 illustrates the use of code directives,
conditional statements and the definition of the base name for the
code file.

\example{Code extraction}{
@f Xra & 
{\it This defines the base name for the file 
to which the following code is copied}\\
@i &{\it This directive introduces a POOL implementation unit}\\
@ifdef PPMX &{\it a conditional statement on PPMX}\\
\hspace{0.5cm}a:= Deep\_copy(D).new(b); & \\
@else & \\
\hspace{0.5cm}a:= b!deep\_copy(); & \\
@endif\\
}

\subsection{Document extraction}

For document extraction \Mx is called with the following arguments:

\noindent
\begin{center}
	{\tt Mx [-t -s -w] -S\file [-1 -2] -H\n  \{-D\macro\}$^+$\mxfile}
\end{center}

The options enclosed in ``['' and ``]'' are mutual exclusive. 
All the flags are optional. By default \Mx generates a \LaTeX\
document in single column style.

\subsubsection{Troff or \LaTeX}
The options {\tt -s} and {\tt -t} select between extracting 
respectively a document in ``troff -ms'' format and in \LaTeX\ format.
The default format is \LaTeX. With the {\tt -S\file} option
it is possible to use an alternative \LaTeX\ style file. 
\Mx produces a document either in single column format, using the
{\tt -1} option or in double column format with the {\tt -2} option.
Single column format is the default.

\subsubsection{HTML documents}
The {\tt -w} option selects the HTML document extraction. This will
produce a single {\em .html} document with the basename of the Mx-file. To
format the document nicely, this extraction mode uses Netscape extensions
to HTML, like tables, colors and background.  Since many code uses @T 
(\LaTeX) blocks for documentation, the extraction performs an on-the-fly,
opportunistic, \LaTeX-to-HTML translation. This translation
works for all \LaTeX\ commands, and also bibliographies and EPFS imagery
({\em .bib/.eps} files expected in the "." directory). {\bf Beware}:
\LaTeX\ command definitions with {\Lc def} and
{\Lc newcommand}, are not supported, though.

This process will produce one single -- unstructured -- file. Internal
URL links are generated only for: 
\begin{itemize}
\item the index (table at top of the document),
\item Mx-macro definitions and their uses, 
\item references to labels in \LaTeX\ blocks.
\end{itemize}
Note that any type of code (such as an URL) can be included in HTML
using the "@[$<sgml-text>$@" macro. It will be extracted "as is" in HTML
extraction mode. This facility is exploited by the special utilities 
{\tt WWWidx} and {\tt WWWlink} to interlink Mx documents into a source code
web.

\subsubsection{Hide Levels}
The {\tt -H\n} option is used to set the hide level to \n. In the \Mx
document text can be bracketed by @\{ and @\}. These 'hide'
brackets can be nested. If \Mx is called with option {\tt -H1}, then
all text enclosed within @\{ and @\} is replaced by the hide text.
(...). Hide level 2 ({\tt -H2}) will replace all text within 
@\{ @\{ {\it $<$text$>$} @\} @\} by its hide text. 
In the section on multi-level hiding, methods for changing the hide
text are defined.

Again the {\tt -D\macro} option defines body-less macros.
This option is very useful in combination with the conditional
statement directives. (@ifdef \macro, @else and @endif.

\section{\Mx-file structure}
The \Mx file is a text file interspersed with code and text directives.
Typically a \Mx document consists of a prologue, which defines the
title, author, version and date of the document , a body, which
contains code fragments and comment, organized in sections,
subsections and (numbered) paragraphs, and an epilogue. The epilogue
is generated by the \Mx program and contains the macro- and user
defined indexes. A table of contents is added by \Mx to the prologue,
listing all the sections and subsections.

\example{\Mx file structure}{
@t The Sieve of Eratosthenes & 
{\it Defines the document title title.}\\
@a C.A. van den Berg & {\it Defines the author}\\
@v 1.00 & {\it Defines the version number}\\
@d 1/1/90 & {\it Defines the date}\\
@f Sieve & {\it Defines the basename for the code files} \\
@* Introduction & {\it A section}\\
The sieve of ...& Some comment \\
@s	& {\it precedes POOL specification code}\\
CLASS Sieve & \\
.... & \\
END Sieve\\
@+ The implementation & {\it A subsection}\\
.... & \\
@i & {\it precedes POOL implementation code} \\
.... & \\
CLASS Sieve & \\
.... & \\
}
\section{Code directives}
The code directives, summarized below, all start at the beginning of a line.
The text following a code directive until another \Mx directive,
is copied after macro expansion, to a file {\it basename}.{\it suffix}.
The default for {\it basename} is the basename of the supplied \Mx
file. This default can be changed using the @f \file  directive. This
command changes the basename to \file.
The {\it suffix} is implied by the code directive used.

\begin{tabular}{|l|p{0.5 \linewidth}|}
\hline
@f \file & sets the base name to \file \\
@s & 	
copies the following POOL text to {\file}.spec. \Mx automatically
includes the line {\tt SPEC UNIT \file} as the first line in the
file. \\
@i &
copies the following POOL text to {\file}.impl.\Mx automatically
includes the line {\tt IMPL UNIT \file} as the first line in the
file. \\
@c &
copies the following C text to {\file}.c. \\
@h &
copies the following C-define text to {\file}.h. \\
@y &
copies the following Yacc text to {\file}.y. \\
@l &
copies the following Lex text to {\file}.l.\\
@p &
copies the following Prolog text to {\file}.plg. \\
@Qnap &
copies the following Qnap text to {\file}.qnp. \\
@m &
copies the following MEL text to {\file}.m. \\
\hline
@$<extension>$ &
copies the following text to {\file}.$extension$. \\
& {\bf Works only with the {\tt -x $<extension>$} switch!}\\
\hline
\end{tabular}

\section{Layout directives}
All text directives must directly follow a newline. The text directives
influence the outlook of the document. In the prologue of the \Mx file
the information for the title page is defined. In the body of the \Mx
file sections, subsections and sub-subsections can be defined. 
Both the title and author must be specified to generate a 
title page and a table of contents.  If not, no title page and table of
contents are generated.  The following table summarizes the layout
directives.
\newcommand{\Title}{$<${\it title}$>$}
\newcommand{\Author}{$<${\it author}$>$}
\newcommand{\Version}{$<${\it version}$>$}
\newcommand{\Date}{$<${\it date}$>$}

\begin{tabular}{|l|p{0.5 \linewidth}|}
\hline
@t \Title & Defines the title of the document.  \\
@a \Author & Defines the author of the document \\
@v \Version & Defines the version of the document \\
@d \Date & Defines the date of the document. \\
@* \Title & Defines a numbered section named \Title. \\
@+ \Title & Defines a numbered subsection named \Title. \\
@- \Title & Defines a numbered sub-subsection named \Title. The title
is optional. If it is not defined, a paragraph is produced.\\
@. \Title & a named paragraph. Paragraphs are unnumbered. \\ 
\hline
\end{tabular}

The arguments \Title, \Author, \Version, and \Date must be strings
consisting of printable character sequences. The definition of @t, @a,
@v and @d end at the end of the line. 

The sections, subsections and sub-subsections end at the first @
character. This character is escaped by  {\Lc @}. 
The section and subsection titles included in the table of contents.

\section{Macros and conditionals}
\Mx offers parametrized text macros to simplify the description of 
seemingly identical code and text.
Currently, the arguments are referred from within the definition by number
@\n, where $0 < n < 10 $. Macros can be defined and they can be
called. In document extraction mode \Mx will add to each macro call a
reference to the section, where the macro is defined. In code
extraction mode, macro calls are expanded.

Macros definitions can also be used in conditional statements. The
conditional statement is an {\it if-then-else} construct, which can be
arbitrarily nested. The condition is a macro name. If the macro is
defined, the {\it if} part of the statement is processed, otherwise
the {\it else} part is processed. The conditional statement influences
both code extraction as well as document extraction. In combination
with the {\tt -D \macro} commandline option, it can be used to combine
several versions of the software in a single \Mx document.

\begin{tabular}{|l|p{0.5 \linewidth}}
@= \macro & Defines the macro with the name \macro. In the body @\n is
used to represent the arguments. A @ character is escaped by
{\Lc @}.\\
@:\macro($arg_{1}$,\ldots , $arg_{n}$)@ & Calls the macro with name
\macro. The optional argument $arg_{i}$ replaces the @i in the macro
body.\\
&\\
@ifdef \macro & Conditional statement on \macro. \\
@ifndef \macro & Negated conditional statement on \macro. \\
@else & Introduces the {\it else} part of the conditional statement.\\
@endif & Closing bracket of the conditional statement \\
&\\
@[$<sgml-text>$@ & wraps a SGML code, for use during HTML extraction\\ 
\end{tabular}

\example{Macros and conditionals}{
@ifdef PPMX & The body-less macro PPMX can be defined on the command line.\\
@=copy & \\
\hspace{0.5cm}Deep\_copy(@1).new(@2); & PPMX version of deep\_copy \\
@else & \\
@=copy & \\
\hspace{0.5cm}@2!deep\_copy(); & POOLX version of deep\_copy \\
@endif & \\
@i & \\
...& \\
\hspace{0.5cm}a:= @:copy(B,b) & The macro {\it copy} is called and
expanded in the extracted code.\\
}

\section{Indexes}
An index is an alphabetically sorted list of words with a section and
subsection reference. 
The user can define up to 10 different indexes. He can add any
word in the document to one of the defined index tables. This can be done in
code sections as well as text sections of the document. The defined indexes 
are printed out at the end of the document. The following directives 
manipulate indexes:

\begin{tabular}{|l|p{0.5 \linewidth}}
@\n \Title & Defines the index \n with name \Title. The \n is a number
between 0 and 9. \\
@`\text@\n & Adds the entry \text to the index \n. The section and
subsection is also recorded. \\
\end{tabular}
\section{Direct mode}
In some cases the layout facilities provided for by \Mx 
are insufficient for obtaining a nice layout. 
For these occasions the user can directly use Latex or troff-ms
portions started with @T. Beware, that \LaTeX\ and ``troff -ms''
are not automatically converted. 
For instance to create a table you use:
\begin{verbatim}
@T
\begin{tabular}{c|c|l}
.... etc.
\end{tabular}
\end{verbatim}
\section{Inline directives}
\Mx provides a number of inline directives, which can be used to
print words in boldface, italic or in the same font as code. There is
a special directive '@\$' for passing literal text to the {\bf nroff}
or {\bf LaTeX} formatter. This directive allows using the full
expressive power of the format program. All these
directives are terminated by '@'. The following list summarizes the 
inline directives.

\begin{tabular}{|l|p{0.5 \linewidth}|}
@\#\text@ & The text formatter prints \text in the code font.\\
@!\text@ & The text formatter prints \text  in boldface. \\
@%\text@ & The text formatter prints \text in italic. \\
@\$\text@ & Mx passes \text literally to the text formatter.
\end{tabular}

\section{Multilevel hiding and archiving}
By enclosing pieces of text in @\{ .. @\} pairs, possibly nested,
text can be compressed using the -H\n option. Here \n specifies the level.
The pieces of text are replaced by the hide text in  the document. 
This hide text is optional and can be defined by $@|@$. 
The default hide text is \dots.
For instance:
\begin{verbatim}
@*Introduction
@{
@*Details
@|Consult your local guru for details
@}
@*Conclusion
\end{verbatim}
Produces a document with the modules {\bf Introduction} , followed by the text 
"Consult your local guru for details" and the module 
{\bf Conclusion} if the option {\tt -H1} is given, but produces the complete 
document if the option {\tt -H} is omitted. Of course without the hiding text.

Portions of the \Mx document can be moved to the archive by
enclosing them with @( ...@). The text portion stays within the 
\Mx file but will not be reproduced in a derived document.
The purpose of the archive mode is to retain all potential valuable
information, such as previous versions of an algorithm or 
observation malfunctioning algorithms, together with the code.
This way it won't be forgotten.
\begin{thebibliography}{Knuth xx}
\bibitem[Knuth 83]{Literate}
{ Literate Programming, Donald E. Knuth, The Computer Journal, September 1983}
\bibitem[Bentley 86]{Programming}
{ Literate Programming, Jon Bentley, Communications of the ACM, May 1986, V.29}
\bibitem[America 88]{Pool}
{ A sketch for POOL-X, Pierre America, Philips Research Laboratories Eindhoven,
, Document P0151, April 1988 }
\end{thebibliography}
\end{document}
