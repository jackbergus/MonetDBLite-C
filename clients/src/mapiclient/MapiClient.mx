@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
@' Copyright August 2008- MonetDB B.V.
@' All Rights Reserved.

@a Sjoerd Mullender, M. Kersten, Peter Boncz, Niels Nes
@v 6
@f MapiClient
@* The Mapi Client Interface 
A textual interface to the Monet server using the Mapi library,
providing command-line access for its users. It is the preferred
interface for non-DBAs.

@+ Manual Page
The @code{mclient} program provides a textual
interface to the MonetDB server. Unlike the Mserver console, the
@code{mclient} program is intended not only for the database
administrator, but for all users. It is more comfortable than the
console, since it provides a command history and automatic file name
completion. 

@verbatim
mclient [options] [inputfile+]
@end verbatim

The following options are supported:

@multitable @columnfractions .25 .25 .25 
@item -h hostname 
@tab --host=hostname  
@tab host to connect to 
@item -l language 
@tab --language=lang  
@tab @{mal,sql,mil@} 
@item -P passwd   
@tab --passwd=passwd  
@tab password 
@item -p portnr   
@tab --port=portnr    
@tab port to connect to 
@item -s stmt     
@tab --statement=stmt 
@tab run single statement 
@item -X          
@tab --Xdebug
@tab trace mapi network interaction
@item -t          
@tab --time           
@tab time commands 
@item -u user     
@tab --user=user      
@tab user id 
@item -H          
@tab --history        
@tab load/save cmdline history (default off) 
@item -?          
@tab --help           
@tab show this usage message 
@end multitable

Calling "mclient -l sql" establishes a SQL connection with an
Mserver server running on the local machine. The default user
'monetdb' is used, which provides administrative rights.
To protect your database you may want to introduce another DBA name and
limit the access permissions of 'monetdb' to the level of a guest account.

In the SQL mode, a few more convenient commands are available.
@multitable @columnfractions .25 .75
@item --rows
@tab to control the pagination behavior
@item --width
@tab to control the maximum column width (default=80)
@end multitable
@{
@+ Implementation
@c
#include "clients_config.h"
#include "monet_utils.h"
#ifndef HAVE_GETOPT_LONG
#  include "monet_getopt.h"
#else
# ifdef HAVE_GETOPT_H
#  include "getopt.h"
# endif
#endif
#include "mapilib/Mapi.h"
#include <unistd.h>
#include <stdlib.h>
#include <ctype.h>
#include <sys/stat.h>
#include <errno.h>
#ifdef HAVE_STRING_H
#include <string.h>
#endif
#ifdef HAVE_STRINGS_H
#include <strings.h>
#endif
#ifdef HAVE_LIBREADLINE
#include <readline/readline.h>
#include <readline/history.h>
#include "ReadlineTools.h"
#endif
#include "stream.h"
#include "msqldump.h"
#include "mprompt.h"
#ifdef HAVE_LOCALE_H
#include <locale.h>
#endif
#ifdef HAVE_ICONV
#ifdef HAVE_ICONV_H
#include <iconv.h>
#endif
#ifdef HAVE_NL_LANGINFO
#ifdef HAVE_LANGINFO_H
#include <langinfo.h>
#endif
#else
#ifdef NATIVE_WIN32
#include <Windows.h>
#endif
#endif
#endif

#ifndef S_ISCHR
#define S_ISCHR(m)	(((m) & S_IFMT) == S_IFCHR)
#endif

#ifdef NATIVE_WIN32
#define strdup _strdup
#endif

#ifndef HAVE_GETLOGIN
#define getlogin() "win32"
#endif

enum modes {
	NOLANGUAGE,
	MAL,
	SQL,
	XQUERY,
	MIL
};

static enum modes mode = NOLANGUAGE;
static stream *toConsole;
static stream *toConsole_raw;	       /* toConsole without iconv conversion */
static stream *stdout_stream;
static stream *stderr_stream;
static FILE *fromConsole = NULL;
static char *language = NULL;
static char *logfile = NULL;
static int start_with_help = 0;
static char promptbuf[16];
static int echoquery = 0;
#ifdef HAVE_ICONV
static char *encoding;
static iconv_t cd_in;
#endif

#define setPrompt() sprintf(promptbuf, "%.*s>", (int) sizeof(promptbuf) - 2, language)
#define debugMode() (strncmp(promptbuf, "mdb", 3) == 0)

/* the internal formatters */
enum formatters {
	NOformatter,
	RAWformatter,
	TABLEformatter,
	CSVformatter,
	TABformatter,
	XMLformatter
};
static enum formatters formatter = NOformatter;
char *output = NULL;		/* output format as string */

#define DEFWIDTH 80

/* try to use a 64 bit integer for the timer, but fall back to plain long */
#ifdef HAVE_LONG_LONG
typedef long long timertype;
#else
#ifdef HAVE___INT64
typedef __int64 timertype;
#else
typedef long timertype;
#endif
#endif

static timertype t0, t1;	/* used for timing */
static char *mark, *mark2;

@-
Pagination and simple ASCII-based rendering is
provided for SQL sessions.
The result set size is limited by the cache size
of the Mapi Library. It is sufficiently large to
accommodate most result to be browsed manually.

The pagewidth determines the maximum space
allocated for a single row. If the total space
required is larger, then a heuristic routine is
called to distribute the available space.
Attribute values may then span multiple lines.
Setting the pagewidth to 0 turns off row size
control.
@c
#ifdef HAVE_POPEN
static char *pager = 0;		/* use external pager */
#endif
static int rowsperpage = 0;	/* for SQL pagination */
static int pagewidth = -1;	/* use raw mode for file input, tabular format in stdin */
static int pagewidthset = 0;	/* whether the user set the width explicitly */
static int interactive_stdin = 0;

enum modifiers {
	NOmodifier,
	EXPLAINmodifier,
	DEBUGmodifier,
	TRACEmodifier
};
static enum modifiers specials = NOmodifier; 
/* set when we see EXPLAIN,DEBUG, or TRACE (only if mode == SQL).
Also retain these modes until after you have received the answer. */

#define MINCOLSIZE 5

/* stolen piece */
#ifdef HAVE_FTIME
#include <sys/timeb.h>
#endif

#ifdef TIME_WITH_SYS_TIME
# include <sys/time.h>
# include <time.h>
#else
# ifdef HAVE_SYS_TIME_H
#  include <sys/time.h>
# else
#  include <time.h>
# endif
#endif
#ifdef HAVE_SYS_IOCTL_H
#include <sys/ioctl.h>
#endif

#if defined(_MSC_VER) && _MSC_VER >= 1400
#define fileno _fileno
#endif

static timertype
gettime(void)
{
	/* Return the time in milliseconds since an epoch.  The epoch
	  is roughly the time this program started. */
#ifdef HAVE_GETTIMEOFDAY
	static struct timeval tpbase;  /* automatically initialized to 0 */
	struct timeval tp;

	if (tpbase.tv_sec == 0)
		gettimeofday(&tpbase, NULL);
	gettimeofday(&tp, NULL);
	tp.tv_sec -= tpbase.tv_sec;
	return (timertype) tp.tv_sec * 1000000 + (timertype) tp.tv_usec;
#else
#ifdef HAVE_FTIME
	static struct timeb tbbase;  /* automatically initialized to 0 */
	struct timeb tb;

	if (tbbase.time == 0)
		ftime(&tbbase);
	ftime(&tb);
	tb.time -= tbbase.time;
	return (timertype) tb.time * 1000000 + (timertype) tb.millitm * 1000;
#endif
#endif
}

static void
timerStart(void)
{
	t0 = gettime();
}

static void
timerPause(void)
{
	t1 = gettime();
}

static void
timerResume(void)
{
	t0 = gettime() - (t1 - t0);
}

static void
timerEnd(void)
{
	t1 = gettime();
	if (mark && specials == NOmodifier) {
		stream_printf(toConsole, "%s %7ld.%03ld msec %s\n", mark, (long) ((t1 - t0) / 1000), (long) ((t1 - t0) % 1000), mark2 ? mark2 : "");
		stream_flush(toConsole);
	}
}

@-
The Mapi library eats away the comment lines, which
we need to detect end of debugging. We overload
the routine to our liking.
@c
static char *
fetch_line(MapiHdl hdl)
{
	char *reply;

	if ((reply = mapi_fetch_line(hdl)) == NULL)
		return NULL;
	if (strncmp(reply, "mdb>#", 5) == 0) {
		if (strncmp(reply, "mdb>#EOD", 8) == 0)
			setPrompt();
		else
			sprintf(promptbuf, "mdb>");
	}
	return reply;
}

static int
fetch_row(MapiHdl hdl)
{
	char *reply;

	do {
		if ((reply = fetch_line(hdl)) == NULL)
			return 0;
	} while (*reply != '[' && *reply != '=');
	return mapi_split_line(hdl);
}

static void
SQLsetSpecial(const char *command)
{
	if (mode == SQL && command && 
		( specials==NOmodifier || specials == TRACEmodifier)) {
		/* catch the specials for better rendering */
		while (*command == ' ' || *command == '\t')
			command++;
		if (strncmp(command, "explain", 7) == 0)
			specials = EXPLAINmodifier;
		else if (strncmp(command, "debug", 5) == 0)
			specials = DEBUGmodifier;
		else if (strncmp(command, "trace", 5) == 0)
			specials = TRACEmodifier;
		else
			specials = NOmodifier;
	}
}

/* return the display length of a UTF-8 string */
static size_t
utf8strlen(const char *s)
{
	size_t len = 0;

	if (s == NULL)
		return 0;
	while (*s) {
		/* only count first byte of a sequence */
		if ((*s & 0xC0) != 0x80)
			len++;
		s++;
	}
	return len;
}

/* skip the specified number of UTF-8 characters */
static char *
utf8skip(char *s, size_t i)
{
	while (*s && i > 0) {
		if ((*s & 0xC0) == 0xC0) {
			s++;
			while ((*s & 0xC0) == 0x80)
				s++;
		} else
			s++;
		i--;
	}
	return s;
}
	
static int
SQLrow(int *len, int *numeric, char **rest, int fields, int trim)
{
	int i, more, first = 1;
	char *t;
	int rows = 0;		/* return number of output lines printed */

	/* trim the text if needed */
	if (trim) {
		for (i = 0; i < fields; i++) {
			if ((t = rest[i]) != NULL && utf8strlen(t) > (size_t) len[i]) {
				while (*t != 0 && isspace((int) *t))
					t++;
				rest[i] = t;
			}
		}
	}

	do {
		more = 0;
		for (i = 0; i < fields; i++) {
			if (rest[i] == NULL || *rest[i] == 0) 
				stream_printf(toConsole, "%c %*s ",
						first ? '|' : ':', len[i], "");
			else {
				/* break the string into pieces and left-adjust them in the column */
				if (utf8strlen(rest[i]) > (size_t) len[i]) {
					t = utf8skip(rest[i], len[i]);
					while (t > rest[i] && !isspace((int) *t))
						while ((*--t & 0xC0) == 0x80)
							;
					if (t == rest[i] && !isspace((int) *t))
						t = utf8skip(rest[i], len[i]);
					stream_printf(toConsole, "%c", first ? '|' : ':');
					if (numeric[i])
						stream_printf(toConsole, "%*s", (int) (len[i] - (utf8strlen(rest[i]) - utf8strlen(t))), "");
					stream_printf(toConsole, " %.*s ", (int) (t - rest[i]), rest[i]);
					if (!numeric[i])
						stream_printf(toConsole, "%*s", (int) (len[i] - (utf8strlen(rest[i]) - utf8strlen(t))), "");
					while (isspace((int) *t))
						t++;
					rest[i] = *t ? t : 0;
					if (rest[i])
						more = 1;
				} else {
					stream_printf(toConsole, "%c", first ? '|' : ':');
					if (numeric[i])
						stream_printf(toConsole, "%*s", (int) (len[i] - utf8strlen(rest[i])), "");
					stream_printf(toConsole, " %s ", rest[i]);
					if (!numeric[i])
						stream_printf(toConsole, "%*s", (int) (len[i] - utf8strlen(rest[i])), "");
					rest[i] = 0;
				}
			}
		}
		stream_printf(toConsole, "%c\n", first ? '|' : ':');
		first = 0;
		rows++;
	} while (more);
	return rows;
}

static void
XMLprdata(const char *val)
{
	if (val == NULL)
		return;
	while (*val) {
		if (*val == '&')
			stream_printf(toConsole_raw, "&amp;");
		else if (*val == '<')
			stream_printf(toConsole_raw, "&lt;");
		else if (*val == '>')
			stream_printf(toConsole_raw, "&gt;");
		else if (*val == '"')
			stream_printf(toConsole_raw, "&quot;");
		else if (*val == '\'')
			stream_printf(toConsole_raw, "&apos;");
		else if ((*val & 0xFF) < 0x20)  /* control character */
			stream_printf(toConsole_raw, "&#%d;", *val & 0xFF);
		else if ((*val & 0x80) != 0 /* && encoding != NULL */) {
			int n, m;
			int c = *val & 0x7F;

			for (n = 0, m = 0x40; c & m; n++, m >>= 1)
				c &= ~m;
			while (--n >= 0)
				c = (c << 6) | (*++val & 0x3F);
			stream_printf(toConsole_raw, "&#x%x;", c);
		} else
			stream_write(toConsole_raw, val, 1, 1);
		val++;
	}
}

static void
XMLprattr(const char *name, const char *val)
{
	stream_printf(toConsole_raw, " %s=\"", name);
	XMLprdata(val);
	stream_write(toConsole_raw, "\"", 1, 1);
}

static void
XMLrenderer(MapiHdl hdl)
{
	int i, fields;
	char *name;

	/* we must use toConsole_raw since the XML file is encoded in UTF-8 */
	stream_flush(toConsole);
	stream_printf(toConsole_raw, "<?xml version='1.0' encoding='UTF-8'?>\n");
	stream_printf(toConsole_raw, "<!DOCTYPE table [\n"
		" <!ELEMENT table (row)*>\n"			/* a table consists of zero or more rows */
		" <!ELEMENT row (column)+>\n"			/* a row consists of one or more columns */
		" <!ELEMENT column (#PCDATA)>\n"
		" <!ATTLIST table name CDATA #IMPLIED>\n"	/* a table may have a name */
		" <!ATTLIST column name CDATA #IMPLIED>]>\n");	/* a column may have a name */
	stream_printf(toConsole_raw, "<table");
	name = mapi_get_table(hdl, 0);
	if (name != NULL && *name != 0)
		XMLprattr("name", name);
	stream_printf(toConsole_raw, ">\n");
	while ((fields = fetch_row(hdl)) != 0) {
		stream_printf(toConsole_raw, "<row>");
		for (i = 0; i < fields; i++) {
			char *data = mapi_fetch_field(hdl, i);

			stream_printf(toConsole_raw, "<column");
			name = mapi_get_name(hdl, i);
			if (name != NULL && *name != 0)
				XMLprattr("name", name);
			stream_write(toConsole_raw, ">", 1, 1);
			if (data)
				XMLprdata(data);
			stream_printf(toConsole_raw, "</column>");
		}
		stream_printf(toConsole_raw, "</row>\n");
	}
	stream_printf(toConsole_raw, "</table>\n");
	stream_flush(toConsole_raw);
}

static void
CSVrenderer(MapiHdl hdl)
{
	int fields;
	char *s;
	char *sep = formatter == CSVformatter ? "," : "\t";
	int i;

	while ((fields = fetch_row(hdl)) != 0) {
		for (i = 0; i < fields; i++) {
			s = mapi_fetch_field(hdl, i);
			if (s == NULL)
				s = "";
			if (strchr(s, *sep) != NULL || strchr(s, '\n') != NULL || strchr(s, '"') != NULL) {
				stream_printf(toConsole, "%s\"", i == 0 ? "" : sep);
				while (*s) {
					switch (*s) {
					case '\n':
						stream_write(toConsole, "\\n", 1, 2);
						break;
					case '\t':
						stream_write(toConsole, "\\t", 1, 2);
						break;
					case '\r':
						stream_write(toConsole, "\\r", 1, 2);
						break;
					case '\\':
						stream_write(toConsole, "\\\\", 1, 2);
						break;
					case '"':
						stream_write(toConsole, "\\\"", 1, 2);
						break;
					default:
						if (*s == *sep)
							stream_write(toConsole, "\\", 1, 1);
						stream_write(toConsole, s, 1, 1);
						break;
					}
					s++;
				}
				stream_write(toConsole, "\"", 1, 1);
			} else
				stream_printf(toConsole, "%s%s", i == 0 ? "" : sep, s ? s : "");
		}
		stream_printf(toConsole, "\n");
	}
}

static void
SQLseparator(int *len, int fields, char sep)
{
	int i, j;

	stream_printf(toConsole, "+");
	for (i = 0; i < fields; i++) {
		stream_printf(toConsole, "%c", sep);
		for (j = 0; j < (len[i] < 0 ? -len[i] : len[i]); j++)
			stream_printf(toConsole, "%c", sep);
		stream_printf(toConsole, "%c+", sep);
	}
	stream_printf(toConsole, "\n");
}

static void
SQLqueryEcho(MapiHdl hdl)
{
	if (echoquery) {
		char *qry;

		qry = mapi_get_query(hdl);
		if (qry) {
			if (!interactive_stdin) {
				char *p = qry;
				char *q = p;
				while ((q = strchr(q, '\n')) != NULL) {
					*q++ = '\0';
					stream_printf(toConsole, "#%s\n", p);
					p = q;
				}
			} else {
				stream_printf(toConsole, "%s", qry);
			}
			free(qry);
		}
	}
}

static void
RAWrenderer(MapiHdl hdl)
{
	char *line;

	SQLqueryEcho(hdl);
	while ((line = fetch_line(hdl)) != 0) {
		if (*line == '=')
			line++;
		stream_printf(toConsole, "%s\n", line);
	}
}

static void
SQLheader(MapiHdl hdl, int *len, int fields)
{
	SQLqueryEcho(hdl);
	SQLseparator(len, fields, '-');
	if (mapi_get_name(hdl, 0)) {
		int i;
		char **names = (char **) alloca(fields * sizeof(char *));
		int *numeric = (int *) alloca(fields * sizeof(int));

		for (i = 0; i < fields; i++) {
			names[i] = mapi_get_name(hdl, i);
			numeric[i] = 0;
		}
		SQLrow(len, numeric, names, fields, 1);
		SQLseparator(len, fields, '=');
	}
}

static void
SQLdebugRendering(MapiHdl hdl)
{
	char *reply;
	int cnt = 0;

	sprintf(promptbuf, "mdb>");
	while ((reply = fetch_line(hdl))) {
		cnt++;
		stream_printf(toConsole, "%s\n", reply);
		if (strncmp(reply, "mdb>#EOD", 8) == 0) {
			cnt = 0;
			break;
		}
	}
	if (cnt == 0) {
		setPrompt();
		specials = NOmodifier;
	}
}

static void
SQLpagemove(int *len, int fields, int *ps, int *silent)
{
	int c;

	SQLseparator(len, fields, '-');
	stream_printf(toConsole, "next page? (continue,quit,next)");
	c = getc(fromConsole);
	if (c == 'c')
		*ps = 0;
	if (c == 'q')
		*silent = 1;
	while (c != EOF && c != '\n')
		c = getc(fromConsole);
	if (*silent == 0)
		SQLseparator(len, fields, '-');
}

static void
SQLexplainRendering(MapiHdl hdl)
{
	int ps = rowsperpage, rows = 0, silent = 0;
	char *fields[1];
	int len[1], numeric[1];

	SQLqueryEcho(hdl);

	len[0] = pagewidth - 4;	/* remove borders */
	numeric[0] = 0;
	SQLseparator(len, 1, '-');
	while ((fields[0] = fetch_line(hdl)) != NULL) {
		if (silent)
			continue;
		if (*fields[0] == '%')
			continue;

		if (ps > 0 && rows >= ps && fromConsole != NULL) {
			SQLpagemove(len, 1, &ps, &silent);
			rows = 0;
			if (silent)
				continue;
		}

		rows += SQLrow(len, numeric, fields, 1, 0);
	}
	SQLseparator(len, 1, '-');
	specials = NOmodifier;
}

static void
SQLtraceRenderer(MapiHdl hdl)
{
	int ps = rowsperpage, rows = 0, silent = 0;
	char *fields[2];
	char *s;
	int len[2];
	int cols = 1;
	int numeric[2];

	SQLqueryEcho(hdl);
	len[0] = pagewidth - 4;	/* remove borders */
	numeric[0] = 0;
	numeric[1] = 0;

	while ((fields[0] = fetch_line(hdl)) != NULL) {
		if (silent)
			continue;
		if (*fields[0] == '%')
			continue;

		/* simple render */
		fields[0] = fields[0] + 1;
		s = strrchr(fields[0], ']');
		if (s)
			*s = 0;


		if ((s = strchr(fields[0], '#')) != NULL) {
			*s = 0;
			fields[1] = s + 1;
			if (cols == 1) {
				size_t l = strlen(fields[0]);
				assert(l <= INT_MAX);
				len[1] = len[0] - (int) l;
				len[0] = (int) l - 2;	/* border */
				SQLseparator(len, 2, '-');
				cols = 2;
			}
		} else {
			int olen[1];
			char *t;

			olen[0] = pagewidth - 4;
			for (t = fields[0]; *t; t++)
				if (*t == '\t')
					*t = ' ';
			SQLrow(olen, numeric, fields, 1, 0);
			continue;	/* output should be rendered differently */
		}

		if (ps > 0 && rows >= ps && fromConsole != NULL) {
			SQLpagemove(len, cols, &ps, &silent);
			rows = 0;
			if (silent)
				continue;
		}
		rows += SQLrow(len, numeric, fields, cols, 0);
	}
	SQLseparator(len, cols, '-');
}

static void
SQLrenderer(MapiHdl hdl)
{
	int i, total, fields, oldfields = 0, max = 1;
	int *len = NULL;
	char **rest = NULL;
	char buf[50];
	char nullstring[5] = "null";
	int ps = rowsperpage, silent = 0, rows = 0;
	int *numeric = NULL;

	if (mark2)
		free(mark2);
	mark2 = NULL;
	while ((fields = fetch_row(hdl)) != 0) {
		if (silent)
			continue;
		if (len == 0 || fields != oldfields) {
			if (oldfields != fields) {
				if (len)
					free(len);
				if (rest)
					free(rest);
				if (numeric)
					free(numeric);
				len = (int *) malloc(sizeof(int) * fields);
				rest = (char **) malloc(sizeof(char *) * fields);
				numeric = (int *) malloc(sizeof(int) * fields);
			}
			memset(len, 0, sizeof(int) * fields);
			memset(rest, 0, sizeof(char *) * fields);
			memset(numeric, 0, sizeof(int) * fields);

			total = 0;
			for (i = 0; i < fields; i++) {
				char *s;

				len[i] = mapi_get_len(hdl, i);
				if (len[i] == 0) {
					/* no table widths known, so
					   divide columns evenly over
					   available space */
					len[i] = (pagewidth - 2 * fields - (fields - 1) - 2) / fields;
					if (len[i] <= MINCOLSIZE)
						len[i] = MINCOLSIZE;
				}
				s = mapi_get_name(hdl, i);
				if (s != NULL) {
					size_t l = strlen(s);
					assert(l <= INT_MAX);
					if ((max = (int) l) > len[i])
						len[i] = max;
				}
				total += len[i];
				s = mapi_get_type(hdl, i);
				numeric[i] = s != NULL && (strcmp(s, "int") == 0 ||
							   strcmp(s, "tinyint") == 0 ||
							   strcmp(s, "bigint") == 0 ||
							   strcmp(s, "wrd") == 0 ||
							   strcmp(s, "smallint") == 0 ||
							   strcmp(s, "double") == 0 ||
							   strcmp(s, "float") == 0);
			}
			/* punish the column headers first until you cannot squeeze  */
			while (2 * fields + (fields - 1) + 2 + total > pagewidth && max) {
				max = 0;
				total = 0;
				for (i = 0; i < fields; i++)
					total += len[i];

				for (i = 0; i < fields; i++) {
					char *name = mapi_get_name(hdl, i);

					if (name != NULL &&
					    strlen(name) > (size_t) mapi_get_len(hdl, i) &&
					    len[i] > MINCOLSIZE) {
						len[i]--;
						total--;
						if (2 * fields + (fields - 1) + 2 + total == pagewidth)
							break;
						max = 1;
					}
				}
			}
			/* punish the long value fields, first the multi-lines */
			for (i = 0; i < fields; i++)
				if( len[i] >= pagewidth-2*fields)
					len[i]= pagewidth-2*fields;
			/* finetune the long value fields */
			while (2 * fields + (fields - 1) + 2 + total >= pagewidth) {
				total = 0;
				max = 0;
				for (i = 0; i < fields; i++) {
					total += len[i];
					if (len[i] > len[max])
						max = i;
				}
				
				/* penalty for largest field */
				len[max]--;
				total--;
				/* no more squeezing possible */
				if (len[max] == 1)
					break;
			}

			SQLheader(hdl, len, fields);
			oldfields = fields;
		}

		for (i = 0; i < fields; i++) {
			rest[i] = mapi_fetch_field(hdl, i);
			if (rest[i] == NULL)
				rest[i] = nullstring;
		}

		if (ps > 0 && rows >= ps && fromConsole != NULL) {
			SQLpagemove(len, fields, &ps, &silent);
			rows = 0;
			if (silent)
				continue;
		}

		rows += SQLrow(len, numeric, rest, fields, 1);
	}
	if (oldfields)
		SQLseparator(len, oldfields, '-');
	rows = mapi_get_row_count(hdl);
	snprintf(buf, sizeof(buf), "%d rows", rows);
	mark2 = strdup(buf);
	printf("%d tuple%s\n", rows, rows != 1 ? "s" : "");
	if (len)
		free(len);
	if (rest)
		free(rest);
	if (numeric)
		free(numeric);
}

static void
setFormatter(Mapi mid, char *s)
{
	if (mode == XQUERY) {
		mapi_output(mid, s);
		if (s != output) {
			if (output != NULL)
				free(output);
			output = strdup(s);
		}
	} else if (strcmp(s, "sql") == 0)
		formatter = TABLEformatter;
	else if (strcmp(s, "csv") == 0)
		formatter = CSVformatter;
	else if (strcmp(s, "tab") == 0)
		formatter = TABformatter;
	else if (strcmp(s, "raw") == 0)
		formatter = RAWformatter;
	else if (strcmp(s, "xml") == 0)
		formatter = XMLformatter;
	else
		stream_printf(toConsole, "unsupported formatter\n");
}

static void
setWidth(void)
{
	if (!pagewidthset) {
#ifdef TIOCGWINSZ
		struct winsize ws;

		if (ioctl(fileno(stdin), TIOCGWINSZ, &ws) == 0 && ws.ws_col > 0)
			pagewidth = ws.ws_col;
		else
#endif
		pagewidth = DEFWIDTH;
	}
}

static int
format_result(MapiHdl hdl)
{
#ifdef HAVE_POPEN
	stream *saveFD = NULL, *saveFD_raw = NULL; /* for external paging */
#endif
	MapiMsg rc;

#ifdef HAVE_POPEN
	if (pager) {
		FILE *p;

		p = popen(pager, "w");
		if (p == NULL)
			fprintf(stderr, "Starting '%s' failed\n", pager);
		else {
			saveFD = toConsole;
			saveFD_raw = toConsole_raw;
			/* put | in name to indicate that file should be closed with pclose */
			toConsole = file_wastream(p, "|pager");
			toConsole_raw = toConsole;
#ifdef HAVE_ICONV
			if (encoding != NULL)
				toConsole = iconv_wstream(toConsole, encoding, "pager");
#endif
		}
	}
#endif

	setWidth();

	do {
		char *reply;
		int oldpagewidth;

		oldpagewidth = pagewidth;
		if ((reply = mapi_result_error(hdl)) != NULL) {
			if (formatter == RAWformatter)
				mapi_explain_result(hdl, stderr);
			else
				stream_printf(toConsole, "%s", reply);
		}
		if (mapi_get_querytype(hdl) == Q_UPDATE) {
			if (formatter == RAWformatter)
				stream_printf(toConsole, "[ %d\t]\n", mapi_rows_affected(hdl));
			else
				stream_printf(toConsole, "Rows affected %d\n", mapi_rows_affected(hdl));
			continue;
		}
		if (pagewidth <= 0) {
			int i, n = mapi_get_field_count(hdl);

			pagewidth = 2 * n + 4;
			for (i = 0; i < n; i++) {
				int len = mapi_get_len(hdl, i);

				pagewidth += len < MINCOLSIZE ? MINCOLSIZE : len;
			}
		}
		/* note: specials != NOmodifier implies mode == SQL */
		if (specials != NOmodifier && debugMode()) {
			SQLdebugRendering(hdl);
			continue;
		}
		if (debugMode())
			RAWrenderer(hdl);
		else {
			switch (formatter) {
			case XMLformatter:
				XMLrenderer(hdl);
				break;
			case CSVformatter:
			case TABformatter:
				CSVrenderer(hdl);
				break;
			case TABLEformatter:
				switch (specials) {
				case DEBUGmodifier:
					SQLdebugRendering(hdl);
					break;
				case EXPLAINmodifier:
					SQLexplainRendering(hdl);
					break;
				case TRACEmodifier:
					SQLtraceRenderer(hdl);
					break;
				default:
					SQLrenderer(hdl);
					break;
				}
				break;
			default:
				RAWrenderer(hdl);
				break;
			}
		}
		pagewidth = oldpagewidth;
	} while ((rc = mapi_needmore(hdl)) == MOK && (rc = mapi_next_result(hdl)) == 1);
	if (stream_errnr(toConsole)) {
		stream_clearerr(toConsole);
		fprintf(stderr, "write error\n");
	}

#ifdef HAVE_POPEN
	if (saveFD) {
		stream_close(toConsole);
		toConsole = saveFD;
		toConsole_raw = saveFD_raw;
	}
#endif

	return rc;
}

static int
doRequest(Mapi mid, const char *buf, int interactive)
{
	MapiHdl hdl;

	if (mode == SQL)
		SQLsetSpecial(buf);

	if ((hdl = mapi_query(mid, buf)) == NULL || mapi_error(mid) || mapi_result_error(hdl)) {
		mapi_explain_result(hdl, stderr);
		mapi_close_handle(hdl);
		return 1;
	}

	format_result(hdl);

	if (mapi_get_active(mid) == NULL || !interactive)
		mapi_close_handle(hdl);
	return 0;
}

#define CHECK_RESULT(mid, hdl, buf, break_or_continue)			\
		switch (mapi_error(mid)) {				\
		case MOK:						\
			/* everything A OK */				\
			break;						\
		case MERROR:						\
			/* some error, but try to continue */		\
			if (hdl) {					\
				mapi_explain_query(hdl, stderr);	\
				mapi_close_handle(hdl);			\
				hdl = NULL;				\
			} else						\
				mapi_explain(mid, stderr);		\
			break_or_continue;				\
		case MTIMEOUT:						\
			/* lost contact with the server */		\
			if (hdl) {					\
				mapi_explain_query(hdl, stderr);	\
				mapi_close_handle(hdl);			\
				hdl = NULL;				\
			} else						\
				mapi_explain(mid, stderr);		\
			timerEnd();					\
			free(buf);					\
			return 1;					\
		}

static int
doFile(Mapi mid, const char *file)
{
	FILE *fp;
	char *buf = NULL;
	size_t length;
	MapiHdl hdl = NULL;
	MapiMsg rc = MOK;
	int bufsize = 0;
	int xquery_sep = 0;    /* we saw an XQuery separator (<>\n) */

	if (file == NULL)
		fp = stdin;
	else if ((fp = fopen(file, "r")) == NULL) {
		fprintf(stderr, "%s: cannot open\n", file);
		return 1;
	}

	bufsize = BLOCK - 1;
	buf = malloc(bufsize);
	if (!buf) {
		fprintf(stderr, "cannot allocate memory for send buffer\n");
		if (file != NULL)
			fclose(fp);
		return 1;
	}

	timerStart();
	do {
		timerPause();
		if (mode == XQUERY) {
			/* In XQuery mode we must read one line at a
			   time so that we can stop when we encounter
			   a line with just "<>" on it. */
			if (fgets(buf, bufsize, fp) == NULL) {
				/* end of file */
				if (file != NULL) {
					fclose(fp);
					file = NULL;
				}
				length = 0;
				if (hdl == NULL)
					break;  /* nothing more to do */
			} else {
				length = strlen(buf);
				xquery_sep = length >= 3 && buf[0] == '<' && buf[1] == '>' && (buf[2] == '\n' || buf[2] == '\r');
			}
		} else if ((length = fread(buf, 1, bufsize, fp)) == 0) {
			/* end of file */
			if (file != NULL) {
				fclose(fp);
				file = NULL;
			}
			if (hdl == NULL)
				break;	/* nothing more to do */
		}
		timerResume();

		if (hdl == NULL) {
			hdl = mapi_query_prep(mid);
			CHECK_RESULT(mid, hdl, buf, continue);
		}
		if (length > 0 && !xquery_sep) {
			assert(hdl != NULL);

			mapi_query_part(hdl, buf, length);
			CHECK_RESULT(mid, hdl, buf, continue);

			/* in case of XQuery; do the whole file in one go */
			if (mode == XQUERY)
				continue;
		}

		assert(hdl != NULL);
		/* If the server wants more but we're at the end of
		   file (length == 0), notify the server that we
		   don't have anything more.  If the server still
		   wants more (shouldn't happen according to the
		   protocol) we break out of the loop (via the
		   continue).  The assertion at the end will then go
		   off. */
		if (mapi_query_done(hdl) == MMORE && (length > 0 || mapi_query_done(hdl) == MMORE))
			continue;	/* get more data */

		CHECK_RESULT(mid, hdl, buf, continue);

		rc = format_result(hdl);

		if (rc == MMORE && (length > 0 || mapi_query_done(hdl) != MOK))
			continue;	/* get more data */

		CHECK_RESULT(mid, hdl, buf, continue);

		mapi_close_handle(hdl);
		hdl = NULL;

	} while (length > 0);
	/* reached on end of file */
	if (hdl)
		mapi_close_handle(hdl);
	timerEnd();

	free(buf);
	if (file != NULL)
		fclose(fp);
	stream_flush(toConsole);
	return 0;
}

@-
The options available for controlling input and rendering depends
on the language mode.
@c
static void
showCommands(void)
{
	/* XQuery prelude */
	if (mode == XQUERY) {
		stream_printf(toConsole, "mclient interactive MonetDB/XQuery session: type an XQuery or XQUF update.\n");
		stream_printf(toConsole, "\nSupported document-management XQuery extensions:\n");
		stream_printf(toConsole, " pf:collections() as node()\n");
		stream_printf(toConsole, " pf:documents($collectionName as xs:string) as node()\n");
		stream_printf(toConsole, " pf:del-doc($documentName as xs:string)\n");
		stream_printf(toConsole, " pf:add-doc($uri as xs:string, $documentName as xs:string\n");
		stream_printf(toConsole, "     [,$collectionName as xs:string [,$freePercentage as xs:integer]])\n");
		stream_printf(toConsole, "\nSession commands:\n");
		stream_printf(toConsole, "<>      - send query to server (or %s)\n",
#ifdef WIN32
			"CTRL-Z"
#else
			"CTRL-D"
#endif
		    );
	}

	/* shared control options */
	stream_printf(toConsole, "\\?      - show this message\n");
	if (mode == MAL)
		stream_printf(toConsole, "?pat    - MAL function help. pat=[modnme[.fcnnme][(][)]] wildcard *\n");
	stream_printf(toConsole, "\\<file  - read input from file\n");
	stream_printf(toConsole, "\\>file  - save response in file, or stdout if no file is given\n");
	stream_printf(toConsole, "\\|cmd   - pipe result to process, or stop when no command is given\n");
#ifdef HAVE_LIBREADLINE
	stream_printf(toConsole, "\\h      - show the readline history\n");
#endif
	stream_printf(toConsole, "\\t      - toggle timer\n");
	if (mode == SQL) {
		stream_printf(toConsole, "\\D table- dumps the table, or the complete database if none given.\n");
		stream_printf(toConsole, "\\d table- describe the table, or the complete database if none given.\n");
		stream_printf(toConsole, "\\A      - enable auto commit\n");
		stream_printf(toConsole, "\\a      - disable auto commit\n");
	}
	if (mode == SQL || mode == XQUERY) {
		stream_printf(toConsole, "\\G      - switch to algebra frontend\n");
		stream_printf(toConsole, "\\g      - switch to old frontend\n");
	}
	if (mode == XQUERY) {
		stream_printf(toConsole, "\\f      - result format: dm or xml[-noheader][-typed|-noroot|-root-FOOBAR]\n");
	} else {
		stream_printf(toConsole, "\\e      - echo the query in sql formatting mode\n");
		stream_printf(toConsole, "\\f      - format using a built-in renderer {csv,tab,raw,sql,xml}\n");
		stream_printf(toConsole, "\\w#     - set maximal page width (-1=raw,0=no limit, >0 max char)\n");
		stream_printf(toConsole, "\\r#     - set maximum rows per page (-1=raw)\n");
	}
	stream_printf(toConsole, "\\L file - save client/server interaction\n");
	stream_printf(toConsole, "\\X      - trace mclient code\n");
	stream_printf(toConsole, "\\q      - terminate session\n");
}

static int
doFileByLines(Mapi mid, FILE *fp, const char *prompt)
{
	char *line = NULL;
	char *oldbuf = NULL, *buf = NULL;
	size_t length;
	MapiHdl hdl = mapi_get_active(mid);
	MapiMsg rc = MOK;
	int sent = 0;		/* whether we sent any data to the server */

#ifdef HAVE_LIBREADLINE
	if (prompt == NULL)
#endif
		oldbuf = buf = malloc(BUFSIZ);

	do {
		timerPause();
#ifdef HAVE_LIBREADLINE
		if (prompt) {
			rl_completion_func_t *func = NULL;

			if (buf)
				free(buf);
			if (hdl)
				func = suspend_completion();
			buf = readline(hdl ? "more>" : prompt);
			if (hdl)
				continue_completion(func);
			/* add a newline to the end since that makes
			   further processing easier */
			/* don't store shortcut command in the history */
			if (buf) {
				length = strlen(buf);
				if (length > 1)
					add_history(buf);
				buf = realloc(buf, length + 2);
				buf[length++] = '\n';
				buf[length] = 0;
			}
			line = buf;
		} else
#endif
		{
#ifndef HAVE_LIBREADLINE
			if (prompt) {
				fputs(hdl ? "more>" : prompt, stdout);
				fflush(stdout);
			}
#endif
			if (buf != oldbuf)
				free(buf);
			buf = oldbuf; 
			line = fgets(buf, BUFSIZ, fp);
		}
#ifdef HAVE_ICONV
		if (line != NULL && encoding != NULL && cd_in != (iconv_t) -1) {
			ICONV_CONST char *from = line;
			size_t fromlen = strlen(from);
			size_t tolen = 4 * fromlen + 1;
			char *to = malloc(tolen);

			line = to;
			iconv(cd_in, &from, &fromlen, &to, &tolen);
			*to = 0;
			if (!oldbuf)
				free(buf);
			buf = line;
		}
#endif
		if (line == NULL || (mode == XQUERY && line[0] == '<' && line[1] == '>')) {
			/* end of file */
			if (hdl == NULL) {
				if (line != NULL)
					continue;
				/* nothing more to do */
				return 0;
			}

			/* hdl != NULL, we should finish the current query */
			line = NULL;
			length = 0;
		} else
			length = strlen(line);
		if (hdl == NULL && length > 0 && line[length - 1] == '\n') {
			/* test for special commands */
			if (mode != MAL)
				while (length > 0 && (*line & ~0x7F) == 0 && isspace((int) *line)) {
					line++;
					length--;
				}
			/* in the switch, use continue if the line was
			   processed, use break to send to server */
			switch (*line) {
			case '\n':
			case '\0':
				break;
			case '\\':
				switch (line[1]) {
				case 'q':
					free(buf);
					return 0;
				case 't':
					mark = mark ? NULL : "Timer";
					if (mark2)
						free(mark2);
					mark2 = strdup(line + 2);
					if (mode == XQUERY)
						mapi_profile(mid, mark != NULL);
					continue;
				case 'X':
					/* toggle interaction trace */
					mapi_trace(mid, !mapi_get_trace(mid));
					continue;
				case 'A':
					if (mode != SQL)
						break;
					mapi_setAutocommit(mid, 1);
					continue;
				case 'a':
					if (mode != SQL)
						break;
					mapi_setAutocommit(mid, 0);
					continue;
				case 'G':
					if (mode != SQL && mode != XQUERY)
						break;
					mapi_setAlgebra(mid, 1);
					continue;
				case 'g':
					if (mode != SQL && mode != XQUERY)
						break;
					mapi_setAlgebra(mid, 0);
					continue;
				case 'w':
					pagewidth = atoi(line + 2);
					pagewidthset = pagewidth > 0;
					continue;
				case 'r':
					rowsperpage = atoi(line + 2);
					continue;
				case 'd':
					if (mode != SQL)
						break;
					while (isspace((int) line[length - 1]))
						line[--length] = 0;
					for (line += 2; *line && isspace((int) *line); line++)
						;
					if (*line) {
						dump_table(mid, NULL, line, toConsole, 1, 1);
					} else {
						/* get all table names in current schema */
						if ((hdl = mapi_query(mid,
								      "SELECT \"t\".\"name\" "
								      "FROM \"sys\".\"tables\" \"t\", "
								      "\"sys\".\"schemas\" \"s\" "
								      "WHERE \"t\".\"schema_id\" = \"s\".\"id\" "
								      "AND \"s\".\"name\" = \"current_schema\" "
								      "ORDER BY \"t\".\"name\"")) != NULL &&
						    mapi_error(mid) == MOK)
							format_result(hdl);
						mapi_close_handle(hdl);
						hdl = NULL;
					}
					continue;

				case 'D':
					if (mode != SQL)
						break;
					while (isspace((int) line[length - 1]))
						line[--length] = 0;
					for (line += 2; *line && isspace((int) *line); line++)
						;
					if (*line) {
						stream_printf(toConsole, "START TRANSACTION;\n");
						dump_table(mid, NULL, line, toConsole, 0, 1);
						stream_printf(toConsole, "COMMIT;\n");
					} else
						dump_tables(mid, toConsole, 0);
					continue;
				case '<':
					/* read commands from file */
					while (isspace((int) line[length - 1]))
						line[--length] = 0;
					for (line += 2; *line && isspace((int) *line); line++)
						;
					doFile(mid, line);
					continue;
				case '>':
					/* redirect output to file */
					while (isspace((int) line[length - 1]))
						line[--length] = 0;
					for (line += 2; *line && isspace((int) *line); line++)
						;
					if (toConsole != stdout_stream && toConsole != stderr_stream)
						stream_close(toConsole);
					if (*line == 0 || strcmp(line, "stdout") == 0)
						toConsole = stdout_stream;
					else if (strcmp(line, "stderr") == 0)
						toConsole = stderr_stream;
					else if ((toConsole = open_wastream(line)) == NULL ||
						 stream_errnr(toConsole)) {
						if (toConsole != NULL)
							stream_close(toConsole);
						toConsole = stdout_stream;
						fprintf(stderr, "Cannot open %s\n", line);
					}
					continue;
				case 'L':
					free(logfile);
					logfile = NULL;
					while (isspace((int) line[length - 1]))
						line[--length] = 0;
					for (line += 2; *line && isspace((int) *line); line++)
						;
					if (*line == 0) {
						/* turn of logging */
						mapi_log(mid, NULL);
					} else {
						logfile = strdup(line);
						mapi_log(mid, logfile);
					}
					continue;
				case '?':
					showCommands();
					continue;
#ifdef HAVE_POPEN
				case '|':
					if (pager)
						free(pager);
					pager = NULL;
					setWidth();	/* reset to system default */

					while (isspace((int) line[length - 1]))
						line[--length] = 0;
					for (line += 2; *line && isspace((int) *line); line++)
						;
					if (*line == 0)
						continue;
					pager = strdup(line);
					continue;
#endif
#ifdef HAVE_LIBREADLINE
				case 'h':
				{
					int h;
					char *nl;

					for (h = 0; h < history_length; h++) {
						nl = history_get(h) ? history_get(h)->line : 0;
						if (nl)
							stream_printf(toConsole, "%d %s\n", h, nl);
					}
					continue;
				}
/* for later
				case '!':
				{
					char *nl;

					nl = strchr(line, '\n');
					if (nl)
						*nl = 0;
					if (history_expand(line + 2, &nl)) {
						stream_printf(toConsole, "%s\n", nl);
					}
					stream_printf(toConsole, "Expansion needs work\n");
					continue;
				}
*/
#endif
				case 'e':
					echoquery = 1;
					continue;
				case 'f':
					while (isspace((int) line[length - 1]))
						line[--length] = 0;
					for (line += 2; *line && isspace((int) *line); line++)
						;
					if (*line == 0) {
						stream_printf(toConsole, "Current formatter: ");
						if (mode == XQUERY)
							stream_printf(toConsole, "%s\n", output == NULL ? "dm" : output);
						else {
							switch (formatter) {
							case RAWformatter:
								stream_printf(toConsole, "raw\n");
								break;
							case TABLEformatter:
								stream_printf(toConsole, "sql\n");
								break;
							case CSVformatter:
								stream_printf(toConsole, "csv\n");
								break;
							case TABformatter:
								stream_printf(toConsole, "tab\n");
								break;
							case XMLformatter:
								stream_printf(toConsole, "xml\n");
								break;
							default:
								stream_printf(toConsole, "none\n");
								break;
							}
						}
					} else
						setFormatter(mid, line);
					continue;
				default:
					showCommands();
					continue;
				}
			}
		}

		if (hdl == NULL) {
			timerStart();
			hdl = mapi_query_prep(mid);
			CHECK_RESULT(mid, hdl, buf, continue);
		} else
			timerResume();

		assert(hdl != NULL);

		if (length > 0) {
			sent = 1;
			SQLsetSpecial(line);
			mapi_query_part(hdl, line, length);
			CHECK_RESULT(mid, hdl, buf, continue);
		}

		/* If the server wants more but we're at the
		   end of file (line == NULL), notify the
		   server that we don't have anything more.
		   If the server still wants more (shouldn't
		   happen according to the protocol) we break
		   out of the loop (via the continue).  The
		   assertion at the end will then go off.

		   Note that XQuery is weird: we continue
		   sending more until we reach end-of-file,
		   and *then* we send the mapi_query_done.  To
		   exit, you need to send an end-of-file
		   again. */
		if (mode == XQUERY || mapi_query_done(hdl) == MMORE) {
			if (line != NULL) {
				continue;	/* get more data */
			} else if (mapi_query_done(hdl) == MMORE) {
				assert(mode != XQUERY);	/* XQuery never sends MMORE */
				hdl = NULL;
				continue;	/* done */
			}
		}
		CHECK_RESULT(mid, hdl, buf, continue);

		rc = format_result(hdl);

		if (rc == MMORE && (line != NULL || mapi_query_done(hdl) != MOK))
			continue;	/* get more data */

		CHECK_RESULT(mid, hdl, buf, continue);

		timerEnd();
		mapi_close_handle(hdl);
		hdl = NULL;

		/* for XQuery, only exit when end-of-file and we
		   didn't send any data */
	} while (line != NULL || (mode == XQUERY && sent));
	/* reached on end of file */
	assert(hdl == NULL);
	return 0;
}

static void
usage(const char *prog)
{
	fprintf(stderr, "Usage: %s --language=(sql|xquery|mal|mil) [ options ]\n", prog);
	fprintf(stderr, "\nOptions are:\n");
	fprintf(stderr, " -d database | --database=database  database to connect to\n");

	fprintf(stderr, " -e          | --echo             echo the query\n");
#ifdef HAVE_ICONV
	fprintf(stderr, " -E charset  | --encoding=charset specify encoding (character set) of the terminal\n");
#endif
	fprintf(stderr, " -f kind     | --format=kind      specify output format {xml,typed,dm} for XQuery, or {csv,tab,raw,sql,xml}\n");
	fprintf(stderr, " -H          | --history          load/save cmdline history (default off)\n");
	fprintf(stderr, " -h hostname | --host=hostname    host to connect to\n");
	fprintf(stderr, " -i          | --interactive      read stdin after command line args\n");
	fprintf(stderr, " -l language | --language=lang    {sql,xquery,mal,mil}\n");
	fprintf(stderr, " -L logfile  | --log=logfile      save client/server interaction\n");
	fprintf(stderr, " -P passwd   | --passwd=passwd    password\n");
	fprintf(stderr, " -p portnr   | --port=portnr      port to connect to\n");
	fprintf(stderr, " -s stmt     | --statement=stmt   run single statement\n");
	fprintf(stderr, " -t          | --time             time commands\n");
	fprintf(stderr, " -X          | --Xdebug           trace mapi network interaction\n");
	fprintf(stderr, " -u user     | --user=user        user id\n");
	fprintf(stderr, " -?          | --help             show this usage message\n");
#ifdef HAVE_POPEN
	fprintf(stderr, " -| cmd      | --pager=cmd        for pagination\n");
#endif

	fprintf(stderr, "\nSQL specific opions \n");
	fprintf(stderr, " -r nr       | --rows=nr          for pagination\n");
	fprintf(stderr, " -w nr       | --width=nr         for pagination\n");
	fprintf(stderr, " -D          | --dump             create an SQL dump\n");
	fprintf(stderr, " -G          | --algebra          use algebra frontend\n");
	fprintf(stderr, " -g          | --no-algebra       use old frontend\n");

	fprintf(stderr, "\nXQuery specific options\n");
	fprintf(stderr, " -C colname  | --collection=colname  collection name\n");
	fprintf(stderr, " -I docname  | --input=docname    document name, XML document on standard input\n");
	fprintf(stderr, " -G          | --algebra          use algebra frontend\n");
	fprintf(stderr, " -g          | --no-algebra       use old frontend\n");
	exit(-1);
}

/* hardwired defaults, only used if monet environment cannot be found */
#define defaultPort 50000

int
main(int argc, char **argv)
{
	int port = 0;
	char *user = NULL;
	char *passwd = NULL;
	char *host = NULL;
	char *command = NULL;
	char *dbname = NULL;
	char *input = NULL;
	char *colname = NULL;
	int trace = 0;
	int guest = 1;
	int dump = 0;
	int algebra = -1;
	int c = 0;
	Mapi mid;
	int save_history = 0;
	int interactive = 0;
	int option_index = 0;
	struct stat statb;
	static struct option long_options[] = {
		{"algebra", 0, 0, 'G'},
		{"no-algebra", 0, 0, 'g'},
		{"collection", 1, 0, 'C'},
		{"database", 1, 0, 'd'},
		{"dump", 0, 0, 'D'},
		{"echo", 0, 0, 'e'},
#ifdef HAVE_ICONV
		{"encoding", 1, 0, 'E'},
#endif
		{"format", 1, 0, 'f'},
		{"help", 0, 0, '?'},
		{"history", 0, 0, 'H'},
		{"host", 1, 0, 'h'},
		{"input", 1, 0, 'I'},
		{"interactive", 0, 0, 'i'},
		{"language", 1, 0, 'l'},
		{"log", 1, 0, 'L'},
#ifdef HAVE_POPEN
		{"pager", 1, 0, '|'},
#endif
		{"passwd", 2, 0, 'P'},
		{"port", 1, 0, 'p'},
		{"rows", 1, 0, 'r'},
		{"statement", 1, 0, 's'},
		{"time", 0, 0, 't'},
		{"user", 2, 0, 'u'},
		{"width", 1, 0, 'w'},
		{"Xdebug", 0, 0, 'X'},
		{0, 0, 0, 0}
	};

#ifndef WIN32
	/* don't set locale on Windows: setting the locale like this
	 * causes the output to be converted (we could set it to
	 * ".OCP" if we knew for sure that we were running in a cmd
	 * window) */
#ifdef HAVE_SETLOCALE
	setlocale(LC_ALL, "");
#endif
#endif
	toConsole = stdout_stream = file_wastream(stdout, "stdout");
	toConsole_raw = toConsole;
	stderr_stream = file_wastream(stderr, "stderr");

	/* execute from stdin? */
	if (fstat(fileno(stdin), &statb) == 0 && S_ISCHR(statb.st_mode))
		interactive_stdin = 1;

	mark = NULL;
	mark2 = NULL;

	while ((c = getopt_long(argc, argv, "C:Dd:e"
#ifdef HAVE_ICONV
				"E:"
#endif
				"f:Ggh:I:iL:l:"
#ifdef HAVE_POPEN
				"|:"
#endif
				"w:r:P::p:s:tXu::H?", long_options, &option_index)) != -1) {
		switch (c) {
		case 0:
#ifdef HAVE_POPEN
			if (strcmp(long_options[option_index].name, "pager") == 0) {
				pager = optarg;
				(void) pager;	/* will be further used later */
			}
#endif
			break;
		case 'C':
			colname = optarg;
			break;
		case 'e':
			echoquery = 1;
			break;
#ifdef HAVE_ICONV
		case 'E':
			encoding = optarg;
			break;
#endif
		case 'L':
			logfile = strdup(optarg);
			break;
		case 'l':
			/* accept unambiguous prefix of language */
			if (strcmp(optarg, "sql") == 0 ||
			    strcmp(optarg, "sq") == 0 ||
			    strcmp(optarg, "s") == 0) {
				language = "sql";
				mode = SQL;
			} else if (strcmp(optarg, "mil") == 0 ||
				   strcmp(optarg, "mi") == 0) {
				language = "mil";
				mode = MIL;
			} else if (strcmp(optarg, "mal") == 0 ||
				   strcmp(optarg, "ma") == 0) {
				language = "mal";

				mode = MAL;
			} else if (strcmp(optarg, "xquery") == 0 ||
				   strcmp(optarg, "xquer") == 0 ||
				   strcmp(optarg, "xque") == 0 ||
				   strcmp(optarg, "xqu") == 0 ||
				   strcmp(optarg, "xq") == 0 ||
				   strcmp(optarg, "x") == 0) {
				language = "xquery";
				mode = XQUERY;
			} else {
				fprintf(stderr, "language option needs to be one of sql, mil, mal, or xquery\n");
				exit(-1);
			}
			break;
		case 'u':
			guest = 0;
			user = optarg;	/* can be NULL */
			break;
		case 'P':
			guest = 0;
			passwd = optarg;	/* can be NULL */
			break;
		case 'f':
			output = strdup(optarg); /* output format */
			break;
		case 'I':
			input = optarg;
			break;
		case 'i':
			interactive = 1;
			break;
		case 'h':
			host = optarg;
			break;
		case 'G':
			algebra = 1;
			break;
		case 'g':
			algebra = 0;
			break;
		case 'p':
			port = atoi(optarg);
			break;
		case 'D':
			dump = 1;
			break;
		case 'd':
			dbname = optarg;
			break;
		case 's':
			command = optarg;
			break;
		case 'w':
			pagewidth = atoi(optarg);
			pagewidthset = pagewidth > 0;
			break;
		case 'r':
			rowsperpage = atoi(optarg);
			break;
#ifdef HAVE_POPEN
		case '|':
			pager = optarg;
			break;
#endif
		case 't':
			mark = "Timer";
			break;
		case 'X':
			trace = MAPI_TRACE;
			break;
		case 'H':
			save_history = 1;
			break;
		case '?':
			if (mode != NOLANGUAGE) {
				start_with_help = 1;
				break;
			}
			/* fall through */
		default:
			usage(argv[0]);
		}
	}
	/* language value is mandatory */
	if (mode == NOLANGUAGE) {
		fprintf(stderr, "Please specify a language option\n\n");
		usage(argv[0]);
	}
	if (input != NULL && mode != XQUERY) {
		fprintf(stderr, "--input (-I) option only with XQuery\n\n");
		usage(argv[0]);
	}
	if (input != NULL && interactive) {
		fprintf(stderr, "--input (-I) and --interactive (-i) cannot both be specified\n\n");
		usage(argv[0]);
	}

#ifdef HAVE_ICONV
#ifdef HAVE_NL_LANGINFO
	if (encoding == NULL)
		encoding = nl_langinfo(CODESET);
#endif
	if (encoding != NULL && strcasecmp(encoding, "utf-8") == 0)
		encoding = NULL;
	if (encoding != NULL) {
		toConsole = iconv_wstream(toConsole, encoding, "stdout");
		if (toConsole == NULL || stream_errnr(toConsole)) {
			fprintf(stderr, "%s: warning: cannot convert local character set %s to UTF-8\n", argv[0], encoding);
			if (toConsole != NULL)
				stream_close(toConsole);
			toConsole = toConsole_raw;
		}
		stdout_stream = toConsole;
		if ((cd_in = iconv_open("utf-8", encoding)) == (iconv_t) -1)
			fprintf(stderr, "%s: warning: cannot convert UTF-8 to local character set %s\n", argv[0], encoding);
	}
#endif	/* HAVE_ICONV */

	/* default to administrator account (eeks) when being called without
	 * any arguments, default to the current user if -u flag is given */
	if (guest) {
		user = "monetdb";
		passwd = "monetdb";
	} else {
		if (user == NULL)
			user = simple_prompt("User ", BUFSIZ, 1, getlogin());
		if (passwd == NULL)
			passwd = simple_prompt("Password", BUFSIZ, 0, NULL);
	}

	mid = mapi_connect(host, port, user, passwd, language, dbname);

	if (mid == NULL) {
		fprintf(stderr, "failed to allocate Mapi structure\n");
		exit(2);
	}

	if (mapi_error(mid)) {
		if( trace)
			mapi_explain(mid, stderr);
		else
			fprintf(stderr,"%s\n",mapi_error_str(mid));
		exit(2);
	}
	if (dump) {
		if (mode == SQL) {
			dump_tables(mid, toConsole, 0);
			exit(0);
		} else {
			fprintf(stderr, "Dump only supported for SQL\n");
			exit(1);
		}
	}

	if (logfile)
		mapi_log(mid, logfile);

	if (algebra != -1 && (mode == SQL || mode == XQUERY))
		mapi_setAlgebra(mid, algebra);
	mapi_profile(mid, mark != NULL);
	mapi_trace(mid, trace);
	if (output)
		setFormatter(mid, output);

	c = 0;

	/* we're interactive if explicit or if no files and no -s option
	   we're also interactive if no files */
	interactive |= (optind == argc && command == NULL);

	/* default formatter depends on whether we're interactive */
	if (formatter == NOformatter)
		formatter = interactive && interactive_stdin && mode != XQUERY && mode != MAL ? TABLEformatter : RAWformatter;

	if (input != NULL && mode == XQUERY) {
		/* stream xml document into the server */
		MapiMsg rc;

		rc = mapi_stream_into(mid, input, colname, stdin);
		if (rc != MOK) {
			mapi_explain(mid, stderr);
			exit(1);
		}
		/* we just read stdin, so can't be interactive */
		interactive = 0;
	}

	if (command != NULL) {
#ifdef HAVE_ICONV
		if (encoding != NULL && cd_in != (iconv_t) -1) {
			ICONV_CONST char *from = command;
			size_t fromlen = strlen(from);
			size_t tolen = 4 * fromlen + 1;
			char *to = malloc(tolen);

			command = to;
			iconv(cd_in, &from, &fromlen, &to, &tolen);
			*to = 0;
		}
#endif
		/* execute from command-line */
		c = doRequest(mid, command, interactive);
	}

	if (optind < argc) {
		/* execute from file(s) */
		while (optind < argc) {
			c |= doFile(mid, argv[optind]);
			optind++;
		}
	}

	if (interactive) {
		char *prompt = NULL;

		if (interactive_stdin) {
			if (start_with_help)
				showCommands();
#ifdef HAVE_LIBREADLINE
			init_readline(mid, language, save_history);
#else
			(void) save_history;	/* pacify compiler */
#endif
			/* reading from terminal, prepare prompt */
			setPrompt();
			prompt = promptbuf;
			fromConsole = stdin;
		}
		/* use default rendering if not overruled at commandline */
		c = doFileByLines(mid, stdin, prompt);

#ifdef HAVE_LIBREADLINE
		if (interactive_stdin) {
			deinit_readline();
		}
#endif
	}
	mapi_disconnect(mid);
	return c;
}

@}
