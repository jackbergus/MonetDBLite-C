@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2007 CWI.
@' All Rights Reserved.

@a Sjoerd Mullender, M. Kersten, Peter Boncz, Niels Nes
@v 6
@f MapiClient
@* The Mapi Client Interface 
A textual interface to the Monet server using the Mapi library,
providing command-line access for its users. It is the preferred
interface for non-DBAs.

@+ Manual Page
The @code{MapiClient} program provides a textual
interface to the MonetDB server. Unlike the Mserver console, the
@code{MapiClient} program is intended not only for the database
administrator, but for all users. It is more comfortable than the
console, since it provides a command history and automatic file name
completion. 

@verbatim
MapiClient [options] [inputfile+]
@end verbatim

The following options are supported:

@multitable @columnfractions .25 .25 .25 @verb @verb @verb
@item -b t/f      
@tab --blocked=true/false
@tab blocked mode 
@item -x          
@tab --error          
@tab exit on error 
@item -h hostname 
@tab --host=hostname  
@tab host to connect to 
@item -l language 
@tab --language=lang  
@tab {mal,sql,mil} 
@item -P passwd   
@tab --passwd=passwd  
@tab password 
@item -p portnr   
@tab --port=portnr    
@tab port to connect to 
@item -s stmt     
@tab --statement=stmt 
@tab run single statement 
@item -t          
@tab --trace
@tab trace mapi network interaction
@item -T          
@tab --time           
@tab time commands 
@item -u user     
@tab --user=user      
@tab user id 
@item -H          
@tab --history        
@tab load/save cmdline history (default off) 
@item -?          
@tab --help           
@tab show this usage message 
@end multitable

Calling "MapiClient -l sql" establishes a SQL connection with an
Mserver server running on the local machine. The default user
'monetdb' is used, which provides administrative rights.
To protect your database you may want to introduce another DBA name and
limit the access permisions of 'monetdb' to the level of a guest account.

In the SQL mode, a few more convenient commands are available.
@multitable @columnfractions .25 .75 @verb @verb
@item --rows
@tab to control the pagination behavior
@item --width
@tab to control the maximum column width (default=80)
@end multitable
@{
@+ Implementation
@c
#include "clients_config.h"
#include <monet_options.h>
#include "Mapi.h"
#include <unistd.h>
#include <stdlib.h>
#include <ctype.h>
#include <sys/stat.h>
#include <errno.h>
#include <string.h>
#ifdef HAVE_LIBREADLINE
#include <readline/readline.h>
#include <readline/history.h>
#include "ReadlineTools.h"
#endif
#include "msqldump.h"
#include "mprompt.h"
#include "stream.h"

#ifndef S_ISCHR
#define S_ISCHR(m)	(((m) & S_IFMT) == S_IFCHR)
#endif

#ifdef NATIVE_WIN32
/* Windows doesn't declare chdir, even though it does provide the function */
extern int chdir(const char *);

#define strdup _strdup
#endif

#ifndef HAVE_GETLOGIN
#define getlogin() "win32"
#endif

#define MAL 1
#define SQL 2
#define XQUERY 4
#define MIL 8

static int mode;
static FILE *toConsole;
static FILE *fromConsole;
static char *language = NULL;
static char *logfile = NULL;
static int start_with_help = 0;
static char promptbuf[16];
static int echoquery = 0;

/* some internal formatters */
#define RAWformatter	0
#define TABLEformatter 	1
#define CSVformatter 	2
#define TABformatter 	4
#define XMLformatter	8

#define DEFWIDTH 80

static int formatter = TABLEformatter;

char *command = NULL;

static long t0, t1;		/* used for timing */
static char *mark, *mark2;

@-
Pagination and simple ascii-based rendering is
provided for SQL sessions.
The result set size is limited by the cache size
of the Mapi Library. It is sufficiently large to
accomodate most result to be browsed manually.

The pagewidth determines the maximum space
allocted for a single row. If the total space
required is larger, then a heuristic routine is
called to distribute the available space.
Attribute values may then span multiple lines.
Setting the pagewidth to 0 turns of row size
control.
@c
#ifdef HAVE_POPEN
static char *pager = 0;		/* use external pager */
#endif
static int rows = 0;
static int rowsperpage = 0;	/* for SQL pagination */
static int pagewidth = -1;	/* use raw mode for file input, tabular format in stdin */
static int specials = 0;	/* set when we see EXPLAIN,DEBUG, or TRACE */
static int interactive_stdin = 0;

#define MINCOLSIZE 5

/* stolen piece */
#ifdef HAVE_FTIME
#include <sys/timeb.h>
#endif

#if TIME_WITH_SYS_TIME
# include <sys/time.h>
# include <time.h>
#else
# if HAVE_SYS_TIME_H
#  include <sys/time.h>
# else
#  include <time.h>
# endif
#endif
#ifdef HAVE_SYS_IOCTL_H
#include <sys/ioctl.h>
#endif

#if defined(_MSC_VER) && _MSC_VER >= 1400
#define fileno _fileno
#endif

static long
gettime(void)
{
#ifdef HAVE_GETTIMEOFDAY
	struct timeval tp;

	gettimeofday(&tp, NULL);
	return (long) tp.tv_sec * 1000000 + (long) tp.tv_usec;
#else
#ifdef HAVE_FTIME
	struct timeb tb;

	ftime(&tb);
	return (long) tb.time * 1000000 + (long) tb.millitm * 1000;
#endif
#endif
}

static void
timerStart(void)
{
	t0 = gettime();
}

static void
timerEnd(void)
{
	t1 = gettime();
	if (mark &&
	    strncmp(promptbuf, "mdb", 3) != 0 &&
	    (mode != SQL || pagewidth >= 0)) {
		fprintf(toConsole, "%s % 7ld.%03ld msec %s\n", mark, (t1 - t0) / 1000, (t1 - t0) % 1000, mark2 ? mark2 : "");
		fflush(toConsole);
	}
}

static void
SQLsetSpecial(const char *command)
{
	if (mode == SQL) {
		/* catch the specials for better rendering */
		const char *s = command;

		while (*s == ' ' || *s == '\t')
			s++;
		if (strncmp(s, "explain", 7) == 0)
			specials = 1;
		if (strncmp(s, "debug", 5) == 0)
			specials = 2;
		if (strncmp(s, "trace", 5) == 0)
			specials = 3;
	}
}

static void
SQLrow(int *len, int *numeric, char **rest, int fields)
{
	int i, more, first = 1;
	char old;
	char *t;
	char separator = ',';

	/* trim the text upon need */
	switch (formatter) {
	case TABLEformatter:
		for (i = 0; i < fields; i++) {
			if (rest[i] && (int) strlen(rest[i]) > len[i]) {
				int cnt = strlen(rest[i]) - len[i];

				/* first remove a leading spaces */
				for (t = rest[i]; t && *t && cnt; t++)
					if (*t != ' ' && *t != '\t')
						break;
					else
						cnt--;
				rest[i] = t;
			}
		}

		do {
			fprintf(toConsole, "| ");
			more = 0;
			for (i = 0; i < fields; i++) {
				if (rest[i] == NULL)
					fprintf(toConsole, "%*s |", len[i], " ");
				else {
					/* break the string into pieces and left-adjust them in the column */
					if ((int) strlen(rest[i]) > len[i]) {
						t = rest[i] + len[i];
						while (t > rest[i] && *t != ' ' && *t != '\t')
							t--;
						if (t == rest[i] && *t != ' ' && *t != '\t')
							t = rest[i] + len[i];
						old = *t;
						*t = 0;
						fprintf(toConsole, "%*s |", first && numeric[i] ? len[i] : -len[i], rest[i]);
						*t = old;
						if (old) {
							while (*t && (*t == ' ' || *t == '\n'))
								t++;
							rest[i] = *t ? t : 0;
						} else
							rest[i] = 0;
						if (rest[i]) {
							more++;
						}
					} else {
						fprintf(toConsole, "%*s |", first && numeric[i] ? len[i] : -len[i], rest[i]);
						rest[i] = 0;
					}
				}
			}
			first = 0;
			fprintf(toConsole, "\n");
		} while (more);
		break;
	case TABformatter:
		separator = '\t';
	case CSVformatter:
		for (i = 0; i < fields;) {
			if (rest[i])
				fprintf(toConsole, "%s", rest[i]);
			if (++i < fields)
				fputc(separator, toConsole);
		}
		fputc('\n', toConsole);
		break;
	default:
		break;
	}
}

static void
XMLprdata(const char *val)
{
	while (*val) {
		if (*val == '&')
			fprintf(toConsole, "&amp;");
		else if (*val == '<')
			fprintf(toConsole, "&lt;");
		else if (*val == '>')
			fprintf(toConsole, "&gt;");
		else if (*val == '"')
			fprintf(toConsole, "&quot;");
		else if (*val == '\'')
			fprintf(toConsole, "&apos;");
		else if ((*val & 0xFF) < 0x20)
			fprintf(toConsole, "&#%d;", *val & 0xFF);
		else
			fputc(*val, toConsole);
		val++;
	}
}

static void
XMLprattr(const char *name, const char *val)
{
	fprintf(toConsole, " %s=\"", name);
	XMLprdata(val);
	fputc('"', toConsole);
}

static void
XMLrenderer(MapiHdl hdl)
{
	int i, fields;

	fprintf(toConsole, "<?xml version='1.0' encoding='utf-8'?>\n");
	fprintf(toConsole,
		"<!DOCTYPE table ["
		" <!ELEMENT table (row)*>"  /* a table consists of zero or more rows */
		" <!ELEMENT row (column)+>"  /* a row consists of one or more columns */
		" <!ELEMENT column (#PCDATA)>"
		" <!ATTLIST table name CDATA #REQUIRED>"  /* a table has a name */
		" <!ATTLIST column name CDATA #REQUIRED>]>\n"); /* a column has a name */
	fprintf(toConsole, "<table");
	XMLprattr("name", mapi_get_table(hdl, 0));
	fprintf(toConsole, ">\n");
	while ((fields = mapi_fetch_row(hdl)) != 0) {
		fprintf(toConsole, "<row>");
		for (i = 0; i < fields; i++) {
			char *data = mapi_fetch_field(hdl, i);

			fprintf(toConsole, "<column");
			XMLprattr("name", mapi_get_name(hdl, i));
			fputc('>', toConsole);
			if (data)
				XMLprdata(data);
			fprintf(toConsole, "</column>");
		}
		fprintf(toConsole, "</row>\n");
	}
	fprintf(toConsole, "</table>\n");
}
static void
RAWrenderer(MapiHdl hdl)
{
	char *line;

	while ((line = mapi_fetch_line(hdl)) != 0) {
		fprintf(toConsole, "%s\n", line);
	}
}

static void
SQLseparator(int *len, int fields, char sep)
{
	int i, j;

	switch (formatter) {
	case TABLEformatter:
		fprintf(toConsole, "+%c", sep);
		for (i = 0; i < fields; i++) {
			for (j = 0; j < (len[i] < 0 ? -len[i] : len[i]); j++)
				fprintf(toConsole, "%c", sep);
			fprintf(toConsole, "%c+", sep);
		}
		fprintf(toConsole, "\n");
		break;
	default:
		break;
	}
}

static void
SQLheader(MapiHdl hdl, int *len, int fields)
{
	int i;
	char **names = (char **) alloca(fields * sizeof(char *));
	int *numeric = (int *) alloca(fields * sizeof(int));

	if (echoquery) {
		char *qry;

		qry = mapi_get_query(hdl);
		if (!interactive_stdin)
			fputc('#', toConsole);
		fprintf(toConsole, "%s", qry);
		free(qry);
	}
	switch (formatter) {
	case TABLEformatter:
		SQLseparator(len, fields, '-');
		if (mapi_get_name(hdl, 0)) {
			for (i = 0; i < fields; i++) {
				names[i] = mapi_get_name(hdl, i);
				numeric[i] = 0;
			}
			SQLrow(len, numeric, names, fields);
		}
		SQLseparator(len, fields, '=');
		break;
	default:
		break;
	}
}

static void
SQLdebugRendering(MapiHdl hdl)
{
	char *reply;

	if (mapi_result_error(hdl) != NULL) {
		mapi_explain_result(hdl, stderr);
	}
	sprintf(promptbuf, "mdb>");
	while ((reply = mapi_fetch_line(hdl))) {
		fprintf(toConsole, "%s\n", reply);
		if (strncmp(reply, "mdb>#EOD", 7) == 0) {
			specials = 0;
			sprintf(promptbuf, "%.*s>", (int) sizeof(promptbuf) - 2, language);
		}
	}
}

static void
SQLexplainRendering(MapiHdl hdl)
{
	int ps = rowsperpage, rows = 0, silent = 0;
	char *fields[1];
	int len[1], numeric[1];

	if (mapi_result_error(hdl) != NULL) {
		mapi_explain_result(hdl, stderr);
	}

	len[0] = pagewidth;
	numeric[0] = 0;
	SQLheader(hdl, len, 1);
	while ((fields[0] = mapi_fetch_line(hdl)) != NULL) {
		if (silent)
			continue;
		SQLrow(len, numeric, fields, 1);
		if (ps && rows % ps == ps - 1 && rows != mapi_get_row_count(hdl) && fromConsole) {
			char buf[BUFSIZ];

			SQLseparator(len, 1, '-');
			fprintf(toConsole, "next page? (continue,quit,next)");
			fgets(buf, BUFSIZ, fromConsole);
			if (buf[0] == 'c')
				ps = 0;
			if (buf[0] == 'q')
				silent = 1;
			if (silent == 0)
				SQLseparator(len, 1, '-');
		}
		rows++;
	}
	SQLseparator(len, 1, '-');
}

static void
SQLtraceRenderer(MapiHdl hdl)
{
	int ps = rowsperpage, rows = 0, silent = 0;
	char *fields[1];
	char *s;
	int len[1];
	int kind = 1;
	int numeric[1];

	if (mapi_result_error(hdl) != NULL) {
		mapi_explain_result(hdl, stderr);
	}
	len[0] = pagewidth;
	numeric[0] = 0;

	SQLseparator(len, 1, '-');
	while ((fields[0] = mapi_fetch_line(hdl)) != NULL) {
		if (silent)
			continue;
		if (strstr(fields[0], "usec ")) {
			if (kind == 0)
				SQLseparator(len, 1, '+');
			kind = 1;
		} else {
			if (kind == 1)
				SQLseparator(len, 1, '+');
			kind = 0;
		}
		/* simple render */
		fields[0] = fields[0] + 1;
		s = strrchr(fields[0], ']');
		if (s)
			*s = 0;
		SQLrow(len, numeric, fields, 1);
		if (ps && rows % ps == ps - 1 && rows != mapi_get_row_count(hdl) && fromConsole) {
			char buf[BUFSIZ];

			SQLseparator(len, 1, '-');
			fprintf(toConsole, "next page? (continue,quit,next)");
			fgets(buf, BUFSIZ, fromConsole);
			if (buf[0] == 'c')
				ps = 0;
			if (buf[0] == 'q')
				silent = 1;
			if (silent == 0)
				SQLseparator(len, 1, '-');
		}
		rows++;
	}
	SQLseparator(len, 1, '-');
}

static void
SQLrenderer(MapiHdl hdl)
{
	int i, total, fields, oldfields = 0, max=1;
	int *len = 0;
	char **rest = 0;
	char buf[50];
	char nullstring[5] = "null";
	int ps = rowsperpage, silent = 0, rows = 0;
	int *numeric = 0;

	if (mark2)
		free(mark2);
	mark2 = NULL;
	while ((fields = mapi_fetch_row(hdl)) != 0) {
		if (silent)
			continue;
		if (len == 0) {
			char *type;

			len = (int *) alloca(sizeof(int) * fields);
			rest = (char **) alloca(sizeof(char *) * fields);
			numeric = (int *) alloca(sizeof(int) * fields);

			for (i = 0; i < fields; i++) {
				len[i] = mapi_get_len(hdl, i);
				if ((max = strlen(mapi_get_name(hdl, i))) > len[i])
					len[i] = max;
				type = mapi_get_type(hdl, i);
				numeric[i] = strcmp(type, "int") == 0 ||
					strcmp(type, "tinyint") == 0 ||
					strcmp(type, "smallint") == 0 ||
					strcmp(type, "double") == 0 ||
					strcmp(type, "float") == 0;
			}
			if (pagewidth) {
				total = 0;
				for (i = 0; i < fields; i++)
					total += len[i];
				while (2 * fields + total >= pagewidth && max) {
					max = 0;
					total = 0;
					for (i = 0; i < fields; i++)
						total += len[i];

					/* punish the column headers first */
					for (i = 0; i < fields; i++)
						if (strlen(mapi_get_name(hdl, i)) > (size_t) mapi_get_len(hdl, i) &&
						    len[i] > MINCOLSIZE) {
							len[i]--;
							total--;
							if (2 * fields + total == pagewidth)
								break;
							max = 1;
						}
				}
				/* punish the long value fields */
				while (2 * fields + total >= pagewidth && len[max] > 1) {
					total = 0;
					max = 1;
					for (i = 0; i < fields; i++) {
						total += len[i];
						if (len[i] > len[max])
							max = i;
					}

					if (2 * fields + total >= pagewidth) {
						/* penalty for largest field */
						total -= len[max];
						len[max] *= 0.9;
						total += len[max];
					}
				}
			}

			SQLheader(hdl, len, fields);
			oldfields = fields;
		}

		for (i = 0; i < fields; i++) {
			rest[i] = mapi_fetch_field(hdl, i);
			if (rest[i] == NULL && formatter == TABLEformatter)
				rest[i] = nullstring;
		}

		SQLrow(len, numeric, rest, fields);
		rows++;
		if (ps && (rows % ps) == ps - 1 && rows != mapi_get_row_count(hdl) && fromConsole) {
			char buf[BUFSIZ];

			SQLseparator(len, oldfields, '-');
			fprintf(toConsole, "next page? (continue,quit,next)");
			fgets(buf, BUFSIZ, fromConsole);
			if (buf[0] == 'c')
				ps = 0;
			if (buf[0] == 'q')
				silent = 1;
			if (silent == 0)
				SQLheader(hdl, len, fields);
		}
	}
	if (oldfields)
		SQLseparator(len, oldfields, '-');
	snprintf(buf, 50, "%d rows", mapi_get_row_count(hdl));
	mark2 = strdup(buf);
}

static void
setFormatter(char *s)
{
	if (strcmp(s, "sql") == 0)
		formatter = TABLEformatter;
	else if (strcmp(s, "csv") == 0)
		formatter = CSVformatter;
	else if (strcmp(s, "tab") == 0)
		formatter = TABformatter;
	else if (strcmp(s, "raw") == 0)
		formatter = RAWformatter;
	else if (strcmp(s, "xml") == 0)
		formatter = XMLformatter;
	else
		fprintf(toConsole, "non-supported formatter\n");
}

static void
setWidth(void)
{
#ifdef TIOCGWINSZ
	struct winsize ws;

	pagewidth = DEFWIDTH;
	if (rows == 0 && ioctl(fileno(stdin), TIOCGWINSZ, &ws) == 0) {
		rows = ws.ws_row;
		pagewidth = ws.ws_col > 0 ? ws.ws_col : DEFWIDTH;
	}
#else
	pagewidth = DEFWIDTH;
#endif
}

static int
doRequest(Mapi mid, const char *buf, int interactive)
{
	MapiHdl hdl;

	if (mode == SQL)
		SQLsetSpecial(buf);

	if ((hdl = mapi_query(mid, buf)) != NULL) {
		if (formatter == XMLformatter)
			XMLrenderer(hdl);
		else if (formatter == RAWformatter)
			RAWrenderer(hdl);
		else
			SQLrenderer(hdl);
	}
	if (mapi_result_error(hdl)) {
		mapi_explain_result(hdl, stderr);
		mapi_close_handle(hdl);
		return 1;
	}
	if (mapi_error(mid)) {
		mapi_explain_query(hdl, stderr);
		mapi_close_handle(hdl);
		return 1;
	}
	if (!mapi_get_active(mid) || !interactive)
		mapi_close_handle(hdl);
	return 0;
}

#define CHECK_RESULT(mid, hdl, buf, break_or_continue)			\
		switch (mapi_error(mid)) {				\
		case MOK:						\
			/* everything A OK */				\
			break;						\
		case MERROR:						\
			/* some error, but try to continue */		\
			if (hdl) {					\
				mapi_explain_query(hdl, stderr);	\
				mapi_close_handle(hdl);			\
				hdl = NULL;				\
			} else						\
				mapi_explain(mid, stderr);		\
			break_or_continue;				\
		case MTIMEOUT:						\
			/* lost contact with the server */		\
			if (hdl) {					\
				mapi_explain_query(hdl, stderr);	\
				mapi_close_handle(hdl);			\
				hdl = NULL;				\
			} else						\
				mapi_explain(mid, stderr);		\
			timerEnd();					\
			free(buf);					\
			return 1;					\
		}


static int
doFile(Mapi mid, const char *file)
{
	FILE *fp;
	char *buf = NULL;
	size_t length;
	MapiHdl hdl = NULL;
	MapiMsg rc = MOK;
	int bufsize = 0;

	if (file == NULL)
		fp = stdin;
	else if ((fp = fopen(file, "r")) == NULL) {
		fprintf(stderr, "%s: cannot open\n", file);
		return 1;
	}

	bufsize = BLOCK - 1;
	buf = malloc(bufsize);
	if (!buf) {
		fprintf(stderr, "cannot allocate memory for send buffer\n");
		if (file != NULL)
			fclose(fp);
		return 1;
	}

	timerStart();
	do {
		if ((length = fread(buf, 1, bufsize, fp)) == 0) {
			/* end of file */
			if (file != NULL) {
				fclose(fp);
				file = NULL;
			}
			if (hdl == NULL) {
				/* nothing more to do */
				timerEnd();
				free(buf);
				return 0;
			}
			/* hdl != NULL, we should finish the current query */
		}

		if (hdl == NULL) {
			hdl = mapi_query_prep(mid);
			CHECK_RESULT(mid, hdl, buf, continue);
		}
		if (length > 0) {
			char *xquery_sep = buf;

			assert(hdl != NULL);

			if (mode == XQUERY) {
				/* support <>\n xquery separator in file mode 
				   (must be at start of line) */
				while (xquery_sep) {
					xquery_sep = strstr(xquery_sep + 1, "<>");
					if (xquery_sep && (xquery_sep[-1] == 10 || xquery_sep[-1] == 13)) {
						char *next = xquery_sep + 2;

						while (*next && isspace(*next))
							next++;
						fseek(fp, next - (buf + length), SEEK_CUR);
						length = xquery_sep - buf;
						buf[length] = 0;
						break;
					}
				}
			}

			mapi_query_part(hdl, buf, length);
			CHECK_RESULT(mid, hdl, buf, continue);

			/* in case of xquery; do the whole file in one go */
			if (xquery_sep == NULL && !feof(fp))
				continue;
		}

		assert(hdl != NULL);
		/* If the server wants more but we're at the end of
		   file (length == 0), notify the server that we
		   don't have anything more.  If the server still
		   wants more (shouldn't happen according to the
		   protocol) we break out of the loop (via the
		   continue).  The assertion at the end will then go
		   off. */
		if (mapi_query_done(hdl) == MMORE && (length > 0 || mapi_query_done(hdl) == MMORE))
			continue;	/* get more data */

		CHECK_RESULT(mid, hdl, buf, continue);

		do {
			char *reply;

			if ((reply = mapi_result_error(hdl)) != NULL)
				mapi_explain_result(hdl, stderr);
			if (mapi_get_querytype(hdl) == Q_UPDATE) {
				fprintf(toConsole, "[ %d\t]\n", mapi_rows_affected(hdl));
			} else {
				while ((reply = mapi_fetch_line(hdl)) != NULL) {
					if (mode == XQUERY && *reply == '=')
						reply++;
					fprintf(toConsole, "%s\n", reply);
				}
			}
		} while ((rc = mapi_needmore(hdl)) == MOK && (rc = mapi_next_result(hdl)) == 1);
		if (rc == MMORE && (length > 0 || mapi_query_done(hdl) != MOK))
			continue;	/* get more data */

		CHECK_RESULT(mid, hdl, buf, continue);

		mapi_close_handle(hdl);
		hdl = NULL;

	} while (length > 0);
	/* reached on end of file */
	assert(hdl == NULL);
	timerEnd();

	free(buf);
	if (file != NULL)
		fclose(fp);
	fflush(stdout);
	return 0;
}

@-
The options available for controlling input and rendering depends
on the language mode.
@c
static void
showCommands(void)
{
	/* XQuery prelude */
	if (mode == XQUERY) {
		fprintf(toConsole, "MapiClient interactive MonetDB/XQuery session: type an XQuery or XQUF update.\n");
		fprintf(toConsole, "\nSupported document-management XQuery extensions:\n");
		fprintf(toConsole, " pf:collections() as node()\n");
		fprintf(toConsole, " pf:documents($collectionName as xs:string) as node()\n");
		fprintf(toConsole, " pf:del-doc($documentName as xs:string)\n");
		fprintf(toConsole, " pf:add-doc($uri as xs:string, $documentName as xs:string\n");
		fprintf(toConsole, "     [,$collectionName as xs:string [,$freePercentage as xs:integer]])\n");
		fprintf(toConsole, "\nSession commands:\n");
	}

	/* shared control options */
		fprintf(toConsole, "\\?      - show this message\n");
		fprintf(toConsole, "\\<file  - read input from file\n");
		fprintf(toConsole, "\\>file  - save response in file, or stdout if no file is given\n");
		fprintf(toConsole, "\\|cmd   - pipe result to process\n");
#ifdef HAVE_LIBREADLINE
		fprintf(toConsole, "\\h      - show the readline history\n");
#endif
		fprintf(toConsole, "\\q      - terminate session\n");
		fprintf(toConsole, "\\T      - toggle timer\n");

	switch (mode) {
	case XQUERY:
		fprintf(toConsole, "<>       - send query to server (or %s)\n",
#ifdef WIN32
			"CTRL-Z"
#else
			"CTRL-D"
#endif
		    );
		break;
	case MAL:
		fprintf(toConsole, "\\?pat   - help on MAL function using pattern [modnme[.fcnnme][(][)]] using wildcard *\n");
		break;
	case SQL:
		fprintf(toConsole, "\\w#     - set maximal page width (-1=raw,0=no limit, >0 max char)\n");
		fprintf(toConsole, "\\r#     - set maximum rows per page (-1=raw)\n");
		fprintf(toConsole, "\\e      - echo the query \n");
		fprintf(toConsole, "\\f      - format using a built-in renderer {csv,tab,raw,sql,xml} \n");
		fprintf(toConsole, "\\D table- dumps the table, or the complete database if none given.\n");
		fprintf(toConsole, "\\d table- describe the table, or the complete database if none given.\n");
		fprintf(toConsole, "\\A      - enable auto commit\n");
		fprintf(toConsole, "\\a      - disable auto commit\n");
	default:
		fprintf(toConsole, "\\l      - line is sent immediately\n");
	}
		fprintf(toConsole, "\\L file - save client/server interaction\n");
		fprintf(toConsole, "\\t      - toggle interaction trace\n");
}

static int
doFileByLines(Mapi mid, FILE *fp, const char *prompt, int linemode, int exit_on_error)
{
	char *line = NULL;
	char *buf = NULL;
	size_t length;
	MapiHdl hdl = mapi_get_active(mid);
	MapiMsg rc = MOK;
	int sent = 0;		/* whether we sent any data to the server */

#ifdef HAVE_POPEN
	FILE *pagerFD = 0;	/* for external paging */
#endif

#ifdef HAVE_LIBREADLINE
	if (prompt == NULL)
#endif
		buf = malloc(BUFSIZ);

	do {
#ifdef HAVE_LIBREADLINE
		if (prompt) {
			rl_completion_func_t *func = NULL;

			if (buf)
				free(buf);
			if (hdl)
				func = suspend_completion();
			buf = readline(hdl ? "more>" : prompt);
			if (hdl)
				continue_completion(func);
			/* add a newline to the end since that makes
			   further processing easier */
			if (buf) {
				add_history(buf);
				length = strlen(buf);
				buf = realloc(buf, length + 2);
				buf[length++] = '\n';
				buf[length] = 0;
			}
			line = buf;
		} else
#endif
		{
#ifndef HAVE_LIBREADLINE
			if (prompt) {
				fputs(hdl ? "more>" : prompt, stdout);
				fflush(stdout);
			}
#endif
			line = fgets(buf, BUFSIZ, fp);
		}
		if (line == NULL || (mode == XQUERY && line[0] == '<' && line[1] == '>')) {
			/* end of file */
			if (hdl == NULL) {
				/* nothing more to do */
				return 0;
			}
			/* hdl != NULL, we should finish the current query */
			line = NULL;
			length = 0;
		} else
			length = strlen(line);

		if (length > 0 && (!linemode || (hdl == NULL && length > 0 && line[length - 1] == '\n'))) {
			/* test for special commands */
			while (length > 0 && (*line & ~0x7F) == 0 && isspace((int) *line)) {
				line++;
				length--;
			}
			/* in the switch, use continue if the line was
			   processed, use break to send to server */
			switch (*line) {
			case '\0':
				/* empty line */
				continue;
			case '\\':
				switch (line[1]) {
				case 'q':
					free(buf);
					return 0;
				case 'T':
					mark = mark ? NULL : "Timer";
					if (mark2)
						free(mark2);
					mark2 = strdup(line + 2);
					continue;
				case 't':
					/* toggle interaction trace */
					mapi_trace(mid, !mapi_get_trace(mid));
					continue;
				case 'l':
					if (mode == XQUERY)
						break;
					linemode = 1;
					line = "";
					length = 0;
					continue;
				case 'b':
					if (mode == XQUERY)
						break;
					linemode = 0;
					continue;
				case 'A':
					if (mode == XQUERY)
						break;
					mapi_setAutocommit(mid, 1);
					continue;
				case 'a':
					if (mode == XQUERY)
						break;
					mapi_setAutocommit(mid, 0);
					continue;
				case 'w':
					if (mode == XQUERY)
						break;
					for (line += 2; *line && isspace((int) *line); line++)
						;
					pagewidth = (int) atol(line);
					continue;
				case 'r':
					for (line += 2; *line && isspace((int) *line); line++)
						;
					rowsperpage = (int) atol(line);
				case 'p':
					if (mode == XQUERY)
						break;
					continue;
				case 'd':
					if (mode != SQL)
						break;
					if (line[length - 1] == '\n')
						line[--length] = 0;
					if (line[length - 1] == '\r')
						line[--length] = 0;
					for (line += 2; *line && isspace((int) *line); line++)
						;
					if (*line) {
						dump_table(mid, line, toConsole, 1);
					} else {
						int old = pagewidth;

						/* get all table names in current schema */
						pagewidth = 0;
						if ((hdl = mapi_query(mid, "SELECT \"t\".\"name\" "
								      "FROM \"sys\".\"tables\" \"t\", "
								      "\"sys\".\"schemas\" \"s\" "
								      "WHERE \"t\".\"schema_id\" = \"s\".\"id\" "
								      "AND \"s\".\"name\" = \"current_schema\" "
								      "ORDER BY \"t\".\"name\"")) != NULL &&
						    mapi_error(mid) == MOK) {
							if (formatter == XMLformatter)
								XMLrenderer(hdl);
							else if (formatter == RAWformatter)
								RAWrenderer(hdl);
							else
								SQLrenderer(hdl);
						}
						mapi_close_handle(hdl);
						hdl = 0;
						pagewidth = old;
					}
					continue;

				case 'D':
					if (mode != SQL)
						break;
					if (line[length - 1] == '\n')
						line[--length] = 0;
					if (line[length - 1] == '\r')
						line[--length] = 0;
					for (line += 2; *line && isspace((int) *line); line++)
						;
					if (*line) {
						fprintf(toConsole, "START TRANSACTION;\n");
						dump_table(mid, line, toConsole, 0);
						fprintf(toConsole, "COMMIT;\n");
					} else
						dump_tables(mid, toConsole);
					continue;
				case '<':
					/* read commands from file */
					if (line[length - 1] == '\n')
						line[--length] = 0;
					if (line[length - 1] == '\r')
						line[--length] = 0;
					doFile(mid, line + 2);
					continue;
				case '>':
					/* redirect output to file */
					line += 2;
					length -= 2;
					if (line[length - 1] == '\n')
						line[--length] = 0;
					if (line[length - 1] == '\r')
						line[--length] = 0;
					if (toConsole != stdout && toConsole != stderr)
						fclose(toConsole);
					if (length == 0 || strcmp(line, "stdout") == 0)
						toConsole = stdout;
					else if (strcmp(line, "stderr") == 0)
						toConsole = stderr;
					else if ((toConsole = fopen(line, "w")) == NULL) {
						toConsole = stdout;
						fprintf(stderr, "Cannot open %s\n", line);
					}
					continue;
				case 'L':
					{	char buf[1024];
						line += 2;
						length -= 2;
						if (line[length - 1] == '\n')
							line[--length] = 0;
						if (line[length - 1] == '\r')
							line[--length] = 0;
						for (; *line && isspace((int) *line); line++)
							;
						if( *line == 0)
						{
							snprintf(buf,1024,"monet_%d", getpid());
							line=buf;
						}
						logfile= optarg? optarg: strdup(line);
						if ( logfile) 
							mapi_log(mid,logfile);
						continue;
					}
				case '?':
					if (!isspace((int) line[1]) && mode == MAL) {
						strcpy(line, line + 1);
						break;
					}
					showCommands();
					continue;
#ifdef HAVE_POPEN
				case '|':
				{
					char *s;

					if (pager)
						free(pager);
					pager = NULL;
					setWidth();	/* reset to system default */

					s = line + 2;
					while (*s && isspace((int) *s))
						s++;
					if (*s == 0)
						continue;
					s[strlen(s) - 1] = 0;
					pager = *s ? strdup(s) : NULL;
					pagewidth = -1;	/* disable pagination */
				}
					continue;
#endif
#ifdef HAVE_LIBREADLINE
				case 'h':
				{
					int h;
					char *nl;

					for (h = 0; h < history_length; h++) {
						nl = history_get(h) ? history_get(h)->line : 0;
						if (nl)
							fprintf(toConsole, "%d %s\n", h, nl);
					}
					continue;
				}
/* for later
				case '!':
				{	char *nl;
					nl= strchr(line,'\n');
					if( nl) *nl=0;
					if( history_expand(line+2,&nl)){
						fprintf(toConsole, "%s\n",nl);
					}
					fprintf(toConsole,"Expansion needs work\n");
					continue;
				}
*/
#endif
				case 'e':
					echoquery = 1;
					continue;
				case 'f':
				{
					char *s;

					if (line[length - 1] == '\n')
						line[--length] = 0;
					if (line[length - 1] == '\r')
						line[--length] = 0;
					s = line + 2;
					while (*s && isspace((int) *s))
						s++;
					setFormatter(s);
					continue;
				}
				case 'x':
					exit_on_error = 1;
				default:
					continue;
				}
			}
		}

		if (hdl == NULL) {
			timerStart();
			hdl = mapi_query_prep(mid);
			CHECK_RESULT(mid, hdl, buf, continue);
		}
		if (length > 0) {
			assert(hdl != NULL);
			sent = 1;
			SQLsetSpecial(line);
			mapi_query_part(hdl, line, length);
			CHECK_RESULT(mid, hdl, buf, continue);
		}
		if (linemode || 
			(mode==SQL && line[length-2]==';' && line[length-1]=='\n')) {
			timerStart();
			assert(hdl != NULL);
			/* If the server wants more but we're at the
			   end of file (line == NULL), notify the
			   server that we don't have anything more.
			   If the server still wants more (shouldn't
			   happen according to the protocol) we break
			   out of the loop (via the continue).  The
			   assertion at the end will then go off.

			   Note that XQuery is weird: we continue
			   sending more until we reach end-of-file,
			   and *then* we send the mapi_query_done.  To
			   exit, you need to send an end-of-file
			   again. */
			if (mode == XQUERY || mapi_query_done(hdl) == MMORE) {
				if (line != NULL) {
					continue;	/* get more data */
				} else if (mapi_query_done(hdl) == MMORE) {
					assert(mode != XQUERY);	/* XQuery never sends MMORE */
					hdl = NULL;
					continue;	/* done */
				}
			}
			CHECK_RESULT(mid, hdl, buf, continue);

#ifdef HAVE_POPEN
			if (pager) {
				pagerFD = popen(pager, "w");
				if (pagerFD == NULL)
					fprintf(stderr, "Starting '%s' failed\n", pager);
			}
#endif

			do {
				char *reply;

				if (mapi_get_querytype(hdl) == Q_UPDATE) {
					fprintf(toConsole, "[ %d\t]\n", mapi_rows_affected(hdl));
				} else if (mode == SQL) {
					if (specials && strncmp(promptbuf, "mdb", 3) == 0)
						SQLdebugRendering(hdl);
					else if ((reply = mapi_result_error(hdl)) != NULL) {
						if (pagewidth < 0)
							goto nononsense;
						fprintf(toConsole, "%s", reply);
						if (exit_on_error) {
							timerEnd();
							return 1;
						}
					} else
						switch (specials) {
						case 1:
							if (pagewidth < 0)
								goto nononsense;
							SQLexplainRendering(hdl);
							break;
						case 2:
							SQLdebugRendering(hdl);
							break;
						case 3:
							if (pagewidth < 0)
								goto nononsense;
							SQLtraceRenderer(hdl);
							break;
						default:
							if (pagewidth < 0)
								goto nononsense;
							if (formatter == XMLformatter)
								XMLrenderer(hdl);
							else if (formatter == RAWformatter)
								RAWrenderer(hdl);
							else
								SQLrenderer(hdl);
						}
				} else {
				      nononsense:
					if ((reply = mapi_result_error(hdl)) != NULL) {
						mapi_explain_result(hdl, stderr);
						if (exit_on_error) {
							timerEnd();
							return 1;
						}
					}
					if (mode == SQL && pagewidth >= 0 && (reply = mapi_fetch_line(hdl)) != NULL) {
						if (*reply == '%') {
							if (formatter == XMLformatter)
								XMLrenderer(hdl);
							else if (formatter == RAWformatter)
								RAWrenderer(hdl);
							else
								SQLrenderer(hdl);
						} else
							fprintf(toConsole, "%s\n", reply);
					}
					while ((reply = mapi_fetch_line(hdl)) != NULL) {
						if ((mode == XQUERY || mode == MAL) && *reply == '=')
							reply++;
#ifdef HAVE_POPEN
						if (pagerFD)
							fprintf(pagerFD, "%s\n", reply);
						else
#endif
							fprintf(toConsole, "%s\n", reply);
					}
				}
			} while ((rc = mapi_needmore(hdl)) == MOK && (rc = mapi_next_result(hdl)) == 1);
			if (rc == MMORE && (line != NULL || mapi_query_done(hdl) != MOK))
				continue;	/* get more data */

			CHECK_RESULT(mid, hdl, buf, continue);

#ifdef HAVE_POPEN
			if (pagerFD) {
				pclose(pagerFD);
				pagerFD = NULL;
			}
#endif
			timerEnd();
			mapi_close_handle(hdl);
			hdl = NULL;
		}
		/* for XQuery, only exit when end-of-file and we
		   didn't send any data */
	} while (line != NULL || (mode == XQUERY && sent));
	/* reached on end of file */
	assert(hdl == NULL);
	return 0;
}

static void
usage(const char *prog)
{
	fprintf(stderr, "Usage: %s --language=(sql|xquery|mal|mil) [ options ]\n", prog);
	fprintf(stderr, "\nOptions are:\n");
	fprintf(stderr, " -b t/f      | --blocked=true/false  blocked mode\n");
	fprintf(stderr, " -c config   | --config=file     config filename\n");
	fprintf(stderr, " -d database | --database=database  database to connect to\n");

	fprintf(stderr, " -e          | --echo            echo the query\n");
	fprintf(stderr, " -H          | --history         load/save cmdline history (default off)\n");
	fprintf(stderr, " -h hostname | --host=hostname   host to connect to\n");
	fprintf(stderr, " -i          | --interactive     read stdin after command line args\n");
	fprintf(stderr, " -l language | --language=lang   {sql,xquery,mal,mil}\n");
	fprintf(stderr, " -L logfile  | --log=logfile     save client/server interaction\n");
	fprintf(stderr, " -P passwd   | --passwd=passwd   password\n");
	fprintf(stderr, " -p portnr   | --port=portnr     port to connect to\n");
	fprintf(stderr, " -q          | --quiet           don't print welcome message\n");
	fprintf(stderr, " -s stmt     | --statement=stmt  run single statement\n");
	fprintf(stderr, " -T          | --time            time commands\n");
	fprintf(stderr, " -t          | --trace           trace mapi network interaction\n");
	fprintf(stderr, " -u user     | --user=user       user id\n");
	fprintf(stderr, " -x          | --error           exit on error\n");
	fprintf(stderr, " -?          | --help            show this usage message\n");
#ifdef HAVE_POPEN
	fprintf(stderr, " -|          | --pager=cmd        for pagination\n");
#endif

	fprintf(stderr, "\nSQL specific opions \n");
	fprintf(stderr, " -r          | --rows=nr          for pagination\n");
	fprintf(stderr, " -w          | --width=nr         for pagination\n");

	fprintf(stderr, "\nXQuery specific options\n");
	fprintf(stderr, " -C colname  | --collection=name  collection name\n");
	fprintf(stderr, " -o format   | --output=format   output format (dm (default) or xml)\n");
	exit(-1);
}

/* hardwired defaults, only used if monet environment cannot be found */
#define defaultPort 50000

int
main(int argc, char **argv)
{
	opt *set = NULL;
	int setlen;
	int port = 0;
	char *user = NULL;
	char *passwd = NULL;
	char *host = NULL;
	char *dbname = NULL;
	char *output = NULL;
	char *input = NULL;
	char *colname = NULL;
	int trace = 0;
	int guest = 1;
	int linemode = 1;
	int exit_on_error = 0;
	int c = 0;
	Mapi mid;
	int quiet = 0;
	int save_history = 0;
	int interactive = 0;
	int option_index=0;
	struct stat statb;
	static struct option long_options[] = {
		{"blocked", 1, 0, 'b'},
		{"config", 1, 0, 'c'},
		{"collection", 1, 0, 'C'},
		{"error", 0, 0, 'e'},
		{"echo", 0, 0, 'E'},
		{"format", 1, 0, 'f'},
		{"interactive", 0, 0, 'i'},
		{"input", 1, 0, 'i'},
		{"host", 1, 0, 'h'},
		{"log", 2, 0, 'L'},
		{"language", 1, 0, 'l'},
		{"output", 1, 0, 'o'},
		{"rows", 1, 0, 0},
#ifdef HAVE_POPEN
		{"pager", 1, 0, '|'},
#endif
		{"width", 1, 0, 'w'},
		{"rows", 1, 0, 'r'},
		{"passwd", 2, 0, 'P'},
		{"port", 1, 0, 'p'},
		{"database", 1, 0, 'd'},
		{"set", 1, 0, 'S'},
		{"statement", 1, 0, 's'},
		{"time", 0, 0, 'T'},
		{"trace", 2, 0, 't'},
		{"user", 2, 0, 'u'},
		{"history", 0, 0, 'H'},
		{"quiet", 0, 0, 'q'},
		{"help", 0, 0, '?'},
		{0, 0, 0, 0}
	};

	toConsole = stdout;

	/* execute from stdin? */
	if (fstat(fileno(stdin), &statb) == 0 && S_ISCHR(statb.st_mode))
		interactive_stdin = 1;

	mark = NULL;
	mark2 = NULL;

	if ((setlen = mo_builtin_settings(&set)) == 0)
		usage(argv[0]);

	while ((c = getopt_long(argc, argv, "b:c:C:xef:i::h:l:o:"
#ifdef HAVE_POPEN
				"|:"
#endif
				"w:r:P::p:d:S:s:Tt::u::Hq?", long_options, &option_index)) != -1) {
		switch (c) {
		case 0:
			if (strcmp(long_options[option_index].name, "rows") == 0 && optarg) {
				rowsperpage = atol(optarg);
			}
#ifdef HAVE_POPEN
			if (strcmp(long_options[option_index].name, "pager") == 0) {
				pager = optarg;
				(void) pager;	/* will be further used later */
			}
#endif
			if (strcmp(long_options[option_index].name, "width") == 0 && optarg) {
				pagewidth = atol(optarg);
			}
			break;
		case 'b':
			if (*optarg == 't' || *optarg == 'T' || *optarg == '1')
				linemode = 0;
			else if (*optarg == 'f' || *optarg == 'F' || *optarg == '0')
				linemode = 1;
			else
				usage(argv[0]);
			break;
		case 'c':
			setlen = mo_add_option(&set, setlen, opt_cmdline, "config", optarg);
			break;
		case 'C':
			colname = optarg;
			break;
		case 'E':
			if (strcmp(long_options[option_index].name, "echo") == 0 && optarg) 
				echoquery= atol(optarg);
			break;
		case 'f':
			setFormatter(optarg);
			break;
		case 'x':
			exit_on_error = 1;
			break;
		case 'L':
			{	char buf[1024];
				snprintf(buf,1024,"monet_%d", getpid());
				logfile= optarg? optarg: strdup(buf);
				break;
			}
		case 'l':
			/* accept unambiguous prefix of language */
			if (strcmp(optarg, "sql") == 0 || strcmp(optarg, "sq") == 0 || strcmp(optarg, "s") == 0) {
				language = "sql";
				linemode=0;
				mode = SQL;
				mark = "Timer";	/* default style */
			} else if (strcmp(optarg, "mil") == 0 || strcmp(optarg, "mi") == 0) {
				language = "mil";

				mode = MIL;
			} else if (strcmp(optarg, "mal") == 0 || strcmp(optarg, "ma") == 0) {
				language = "mal";

				mode = MAL;
			} else if (strcmp(optarg, "xquery") == 0 ||
				   strcmp(optarg, "xquer") == 0 ||
				   strcmp(optarg, "xque") == 0 ||
				   strcmp(optarg, "xqu") == 0 ||
				   strcmp(optarg, "xq") == 0 ||
				   strcmp(optarg, "x") == 0) {
				language = "xquery";

				mode = XQUERY;
			} else {
				fprintf(stderr, "language option needs to be one of sql, mil, mal, or xquery\n");
				exit(-1);
			}
			break;
		case 'u':
			guest = 0;
			user = optarg;	/* can be NULL */
			break;
		case 'P':
			guest = 0;
			passwd = optarg;	/* can be NULL */
			break;
		case 'i':
			interactive = 1;
			if (optarg)
				input = optarg;
			break;
		case 'h':
			host = optarg;
			break;
		case 'o':
			output = optarg;
			break;
		case 'p':
			port = atoi(optarg);
			setlen = mo_add_option(&set, setlen, opt_cmdline, "port", optarg);
			break;
		case 'd':
			dbname = optarg;
			break;
		case 's':
			if (rows == 0)
				pagewidth = DEFWIDTH;
			command = optarg;
			break;
		case 'w':
			if( optarg){
				pagewidth = atol(optarg);
				rows= -1; /* don't reset pagewidth */
			}
			break;
		case 'r':
			if( optarg)
				rowsperpage = atol(optarg);
			break;
#ifdef HAVE_POPEN
		case '|':
		{
			char *s;

			s = optarg;
			while (*s && isspace((int) *s))
				s++;
			pager = s;
		}
			break;
#endif
		case 'q':
			quiet = 1;
			break;
		case 'T':
			mark = mark ? NULL : "Timer";
			break;
		case 't':
			trace = MAPI_TRACE;
			break;
		case 'S':{
			char *eq = strchr(optarg, '=');

			if (eq)
				*eq = 0;
			setlen = mo_add_option(&set, setlen, opt_cmdline, optarg, eq ? eq + 1 : "");
			if (eq)
				*eq = '=';
			break;
		}
		case 'H':
			save_history = 1;
			break;
		case '?':
			if (language) {
				start_with_help = 1;
				break;
			}
		default:
			usage(argv[0]);
		}
	}
	/* language value is mandatory */
	if (mode == 0)
		usage(argv[0]);

	setlen = mo_system_config(&set, setlen);

	if (port == 0) {
		char *s = "mapi_port";
		int p = defaultPort;

		if ((s = mo_find_option(set, setlen, s)) != NULL) {
			port = strtol(s, NULL, 10);
		} else {
			port = p;
		}
	}

	if (mode == XQUERY && output == NULL) {
		output = mo_find_option(set, setlen, "xquery_output");
	}

	if (host == NULL) {
		host = mo_find_option(set, setlen, "host");
		if (host == NULL)
			host = "localhost";
	}

	/* default to administrator account (eeks) when being called without
	 * any arguments, default to the current user if -u flag is given */
	if (guest) {
		user = "monetdb";
		passwd = "monetdb";
	} else {
		if (user == NULL)
			user = simple_prompt("User ", BUFSIZ, 1, getlogin());
		if (passwd == NULL)
			passwd = simple_prompt("Password", BUFSIZ, 0, NULL);
	}

	mid = mapi_connect(host, port, user, passwd, language, dbname);

	if (mid == NULL) {
		fprintf(stderr, "failed to allocate Mapi structure\n");
		exit(2);
	}

	if (mapi_error(mid)) {
		mapi_explain(mid, stderr);
		exit(2);
	}

	if ( logfile) 
		mapi_log(mid,logfile);
	
	if (!quiet) {
		char *motd = mapi_get_motd(mid);

		if (motd)
			printf("%s", motd);
	}
	mapi_profile(mid, mark != NULL);
	mapi_trace(mid, trace);
	if (output)
		mapi_output(mid, output);

	c = 0;

	/* we're interactive if explicit or if no files and no -s option
	   we're also interactive if no files */
	interactive |= (optind == argc && command == NULL);

	if (command) {
		/* execute from command-line */
		c = doRequest(mid, command, interactive);
		command = NULL;
	}
	if (optind < argc) {
		/* execute from file(s) */
		while (optind < argc) {
			c |= doFile(mid, argv[optind]);
			optind++;
		}
	}
	if (interactive) {
		char *prompt = NULL;

		if (interactive_stdin) {
			if (start_with_help)
				showCommands();
#ifdef HAVE_LIBREADLINE
			init_readline(mid, language, save_history);
#else
			(void) save_history;	/* pacify compiler */
#endif
			/* reading from terminal, prepare prompt */
			sprintf(promptbuf, "%.*s>", (int) sizeof(promptbuf) - 2, language);

			/* use default rendering if not overruled at commandline */
			setWidth();

			prompt = promptbuf;
			fromConsole = stdin;
		}
		/* stream xml document into the server */
		if (input && mode == XQUERY) {
			mapi_stream_into(mid, input, colname);
			c = doFile(mid, NULL);
		} else
			c = doFileByLines(mid, stdin, prompt, linemode, exit_on_error);

#ifdef HAVE_LIBREADLINE
		if (interactive_stdin) {
			deinit_readline();
		}
#endif
	}
	mapi_disconnect(mid);
	return c;
}

@}
