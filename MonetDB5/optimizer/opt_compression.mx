@/
The contents of this file are subject to the MonetDB Public License
Version 1.1 (the "License"); you may not use this file except in
compliance with the License. You may obtain a copy of the License at
http://www.monetdb.org/Legal/MonetDBLicense

Software distributed under the License is distributed on an "AS IS"
basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations
under the License.

The Original Code is the MonetDB Database System.

The Initial Developer of the Original Code is CWI.
Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
Copyright August 2008-2011 MonetDB B.V.
All Rights Reserved.
@

@f opt_compression
@- The compressed database
Column stores mostly exploit some form of compression to reduce the
footprint on disk and to improve disk/memory/cache bandwidth at 
the expense of cpu/memory cycles. 

A naive approach is to take a (preferrably lightweight) compression
algorithm and deploy it against the units of access, e.g. disk/buffers.
In MonetDB our granularity is a BAT, which therefore forms the basis
for (de)compressed access.

This optimizer simple injects calls to a
decompression routine to exploit any available compressed image
in favor of accessing the expanded version. This would allow
for experimentation with readonly databases.
@verbatim
b:bat[:oid,:int]:= sql.bind("sys","tab","col",0);
@end verbatim
becomes 
@verbatim
 _1:bat[:oid,:int]:= sql.bind("sys","tab","col",0);
 b:bat[:oid,:int]:= bbp.decompress(_1,"sys_tab_col_0");
@end verbatim

Caveats. The benefit from this approach should not be overestimated.
For example, accessing corresponding attributes for a small result set
stil calls for a complete decoding of the complete column. 
The recycler would come in handy to avoid this overhead over multiple
queries.

Furthermore, the BAT id associated with a SQL column will change
under updates. This means you can effectively only use it in
readonly mode. Create database, load it, compress it, and 
only read it afterwards. Therefore, we inject a symbolic name,
which in the context of SQL would be unique.

The optimizer merely functions as an example on how to deal with
foreign storage schemes, which are converted into the BAT format
as part of a binding phase. The routines CMDbbpcompress and CMDbbpdecompress
in the bbp module contains further details on how to extract the
data and move it into a temporary memory mapped BAT.
@mal
pattern optimizer.compression():str
address OPTcompress;
pattern optimizer.compression(mod:str, fcn:str):str
address OPTcompress
comment "Compression code injection";

@-
@h
#ifndef _OPT_COMPRESS_
#define _OPT_COMPRESS_

#include "opt_prelude.h"
#include "opt_support.h"
#include "mal_interpreter.h"

#define OPTDEBUGcompress  if ( optDebug & ((lng)1 <<DEBUG_OPT_COMPRESS) )

@-
@c
#include "monetdb_config.h"
#include "opt_compression.h"

static int
OPTcompressImplementation(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	int i, actions=0, limit, k;
	InstrPtr *old, q;
	char buf[PATHLENGTH];

	(void) stk;
	(void) cntxt;

	limit= mb->stop;
	old = mb->stmt;
	if ( newMalBlkStmt(mb, mb->ssize) < 0)
		return 0;
	pushInstruction(mb,old[0]);

	for (i = 1; i<limit; i++) {
		p = old[i];
		if (getModuleId(p)== sqlRef && (getFunctionId(p) == bindRef) ) {
			pushInstruction(mb,p);
			q= newStmt(mb,bbpRef,decompressRef);
			setArgType(mb,q,0, getArgType(mb,p,0));
			setVarUDFtype(mb,getArg(q,0));
			k = getArg(p,0);
			getArg(p,0)= getArg(q,0);
			getArg(q,0)= k;
			q= pushArgument(mb,q,getArg(p,0));
			snprintf(buf,PATHLENGTH,"%s_%s_%s_%d",
				getVarConstant(mb,getArg(p,1)).val.sval,
				getVarConstant(mb,getArg(p,2)).val.sval,
				getVarConstant(mb,getArg(p,3)).val.sval,
				getVarConstant(mb,getArg(p,4)).val.ival);
			p= pushStr(mb,q,buf);
			actions++;
			continue;
		} 
		pushInstruction(mb,p);
	}

	GDKfree(old);

	return actions;
}
@include optimizerWrapper.mx
@h
@:exportOptimizer(compress)@
@h
#endif
@c
#include "opt_statistics.h"
@:wrapOptimizer(compress,OPT_CHECK_ALL)@

