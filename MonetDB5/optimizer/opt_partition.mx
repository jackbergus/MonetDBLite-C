@/
The contents of this file are subject to the MonetDB Public License
Version 1.1 (the "License"); you may not use this file except in
compliance with the License. You may obtain a copy of the License at
http://www.monetdb.org/Legal/MonetDBLicense

Software distributed under the License is distributed on an "AS IS"
basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations
under the License.

The Original Code is the MonetDB Database System.

The Initial Developer of the Original Code is CWI.
Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
Copyright August 2008-2011 MonetDB B.V.
All Rights Reserved.
@

@c
/*
 * @f opt_partition
 * @a M. Kersten
 * @- Partitioning
 * Documentation in accompanying paper.
 * Partition optimizer should be followed by the aliases optimizer.
 */
@mal
module partition;
pattern optimizer.partition():str
address OPTpartition;
pattern optimizer.partition(mod:str, fcn:str):str
address OPTpartition
comment "Modify the plan to exploit parallel processing on multiple cores";

command partition.materialize(b:bat[:any_1,:any_2], low:any_2, high:any_2) :bat[:any_1,:any_2]
address OPTpartitionMaterialize
comment "Implement the partition operation. Throw an exception if the partition was empty, 
because then the subquery should produce a NIL ";

command partition.markH( b:bat[:any_1,:any_2] ) :bat[:oid,:any_2] 
address OPTmarkHead
comment "Ignore a NIL bat";

pattern partition.vector(b:bat[:oid,:any_1]) :any_1...
address OPTvector
comment "Derive a series of slices values based on sampling";

@h
#ifndef _OPT_SLICING_
#define _OPT_SLICING_
#include "opt_prelude.h"
#include "opt_support.h"

#define MAXSITES 4		/* to be refined */
@:exportOptimizer(partition)@

opt_export str OPTvector(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
opt_export str OPTpartitionMaterialize(int *result, int *bid, ptr low, ptr high);
opt_export str OPTmarkHead(int *result, int *bid);

/* #define DEBUG_DETAIL*/
#define _DEBUG_OPT_PARTITION_ 
#define OPTDEBUGpartition  if ( optDebug & ((lng)1 <<DEBUG_OPT_PARTITION) )
#endif
@c
#include "monetdb_config.h"
#include "opt_partition.h"
#include "opt_deadcode.h"
#include "mal_builder.h"
#include "mal_recycle.h"
#include "mal_interpreter.h"

static int nrpeers;				/* peers active in sliced processing */
static bte slicingLocal;		/* only use local node without remote calls*/

typedef	struct{
	InstrPtr target;
	str schema, table, column;
	int type, slice;	
	int lslices, hslices;
	ValRecord bounds[MAXSITES];
} Slices;

static MalBlkPtr
OPTplanCntrl(Client cntxt, MalBlkPtr mb, MalBlkPtr pmb, Slices *slices)
{
	MalBlkPtr cmb;
	Symbol s;
	char nme[BUFSIZ];
	int x, i, j, k, *alias, nrpack;
	InstrPtr ret, p, q, *pack;

#ifdef _DEBUG_OPT_PARTITION_
	mnstr_printf(cntxt->fdout,"#original plan \n");
	printFunction(cntxt->fdout, mb, 0, LIST_MAL_STMT);
#endif
	/* define the query controller */
	snprintf(nme,BUFSIZ,"%s_cntrl",getFunctionId( getInstrPtr(mb,0)));
	s = newFunction(userRef, putName(nme, strlen(nme)),FUNCTIONsymbol);
	if ( s == NULL)
		return 0;
	freeMalBlk(s->def);
	s->def = copyMalBlk(pmb);	/* get variables */
	cmb = s->def;
	if ( newMalBlkStmt(cmb,cmb->ssize) < 0 )
		return 0;
	nrpack= getInstrPtr(pmb,0)->retc;
	pack = (InstrPtr *) GDKzalloc(sizeof(InstrPtr) * nrpack);
	pushInstruction(cmb, copyInstruction(pmb->stmt[0]));
	getFunctionId( getInstrPtr(cmb,0)) = putName(nme,strlen(nme));
	insertSymbol(cntxt->nspace,s);

	/* initialize binds and histograms */
	q= newFcnCall(cmb, sqlRef, mvcRef);
	x= getArg(q,0);
	alias = (int*) GDKzalloc(nrpeers * sizeof(int));
	if( slices->column) {
		q= newInstruction(cmb, ASSIGNsymbol);
		getModuleId(q) = sqlRef;
		getFunctionId(q) = bindRef;
		q = pushArgument(cmb,q,x);
		j = getArg(q,0) = newTmpVariable(cmb,newBatType(TYPE_oid, slices->type));
		setVarUDFtype(cmb,j);
		setVarFixed(cmb,j);
		q= pushStr(cmb,q, slices->schema);
		q= pushStr(cmb,q, slices->table);
		q= pushStr(cmb,q, slices->column);
		q= pushInt(cmb,q, 0);
		pushInstruction(cmb,q);

		q= newInstruction(cmb, ASSIGNsymbol);
		getModuleId(q) = partitionRef;
		getFunctionId(q) = vectorRef;
		q = pushArgument(cmb, q, j);
		for ( j = 0; j < nrpeers +1; j++) {
			k = alias[j] = newTmpVariable(cmb, slices->type);
			q= pushReturn(cmb,q, k);
		}
		pushInstruction(cmb,q);
	}
	/* pack[i] := mat.pack(x1,...xn) */
	if ( slices->column) {
		p = getInstrPtr(pmb,0);
		for ( k=0  ;k < nrpack ; k++){
			pack[k] = newInstruction(cmb,ASSIGNsymbol);
			getModuleId(pack[k]) = matRef;
			getFunctionId(pack[k]) = packRef;
			getArg(pack[k],0) = newTmpVariable(cmb, newBatType(TYPE_oid, getTailType(getArgType(cmb,p,k))) );
		}
	}

	/* under dataflow control, initialize the variables */
	for ( k=0 ; k < nrpack ; k++){
		q = newInstruction(cmb,ASSIGNsymbol);
		getArg(q,0) = getArg(pack[k],0);
		pushNil(cmb,q, getArgType(cmb,pack[k],0));
		pushInstruction(cmb,q);
	}

	/* mark start of dataflow block */
	q= newFcnCall(cmb,languageRef,dataflowRef);
	q->barrier= BARRIERsymbol;
	x = getArg(q,0);
	setVarType(cmb,x,TYPE_int);

	for ( i = 0; i < nrpeers ; i++) {
		q= copyInstruction(getInstrPtr(pmb,0));
		q->token = ASSIGNsymbol;
		q->barrier = 0;
		q->argc -= 2; /* remove the bounds */
		for ( k=0 ; k < q->retc; k++) {
			getArg(q,k) = newTmpVariable(cmb, getArgType(pmb,q,k));
			pack[k] = pushArgument(cmb,pack[k], getArg(q,k));
		}

		if ( slices->column){
			/* add the splitter arguments */
			q= pushArgument(cmb,q,alias[i]);
			q= pushArgument(cmb,q,alias[i+1]);
		}
		pushInstruction(cmb,q);
	}
	/* put all mat.pack instructions into the program
	  and make sure that they have contiguous void headed columns 
	*/
	p = getInstrPtr(pmb,0);
	if ( slices->column) 
	for ( k=0 ; k < nrpack; k++) {
		pushInstruction(cmb, pack[k]);
		q= newFcnCall(cmb,partitionRef,markHRef);
		getArg(q,0) = getArg(p,k); 
		q= pushArgument(cmb,q, getArg(pack[k],0));
	}

	/* finalize the dataflow block */
	q= newAssignment(cmb);
	q->barrier = EXITsymbol;
	getArg(q,0) = x;

	/* consolidate the result */
	ret = copyInstruction(getInstrPtr(cmb,0));
	clrFunction(ret);
	ret->barrier = RETURNsymbol;
	ret->argc = ret->retc;
	/* make it a correct assignment to ensure ref counts */
	for( k= 0; k< ret->retc; k++)
		ret = pushArgument(cmb,ret,getArg(ret,k));
	pushInstruction(cmb,ret);
	getInstrPtr(cmb,0)->argc -= 2;

	pushEndInstruction(cmb);
	GDKfree(alias);
	GDKfree(pack);

	return cmb;
}

/* prepare slicing a column  by addition over the target */
static int
OPTpreparePartition(MalBlkPtr nmb, InstrPtr p, Slices *slices, int pc)
{
	InstrPtr q;
	int i,fnd,parallel = 0;

	if ( slices->slice == 0){
		slices->slice = newTmpVariable(nmb, getVarType(nmb, getArg(slices->target,0)));
		setVarUDFtype(nmb, slices->slice);
		setVarUsed(nmb, slices->slice);
		nmb->stmt[0] = pushArgument(nmb, nmb->stmt[0], slices->lslices);
		nmb->stmt[0] = pushArgument(nmb, nmb->stmt[0], slices->hslices);
		parallel=2;	/* return number of arguments added for later disposal */
	} 
	/* check if the partition column instruction is already added */
	fnd =0;
	for ( i = pc -1; i-- > 0 && fnd == 0; i--){
		q= getInstrPtr(nmb,i);
		fnd = getFunctionId(q) && getModuleId(q) == sqlRef && getFunctionId(q) == bindRef &&
			  strcmp(slices->column, getVarConstant(nmb, getArg(p,4)).val.sval) == 0;
	}
	if ( fnd == 0)
		insertInstruction(nmb, p = copyInstruction(slices->target),pc);
	q= newInstruction(nmb,ASSIGNsymbol);
	/* add the slices->to the call */
	q= pushArgument(nmb,q, getArg(p,0));
	q= pushArgument(nmb,q, slices->lslices);
	q= pushArgument(nmb,q, slices->hslices);
	setModuleId(q,partitionRef);
	setFunctionId(q,materializeRef);
	getArg(q,0)= slices->slice;
	getArg(q,1) = getArg(p,0);
	pushInstruction(nmb,q);
	return parallel;
}

static int 
OPTsliceColumn(Client cntxt, MalBlkPtr nmb, MalBlkPtr mb, InstrPtr p, Slices *slices, int pc)
{
	int k, parallel = 0;
	InstrPtr q;

	(void) cntxt;
	if ( ! (getModuleId(p) == sqlRef && getFunctionId(p) == bindRef )  &&
		 ! (getModuleId(p) == sqlRef && getFunctionId(p) == bindidxRef ) )
		return 0;
	if ( ! (strcmp(slices->schema, getVarConstant(mb, getArg(p,2)).val.sval) == 0 &&
		strcmp(slices->table, getVarConstant(mb, getArg(p,3)).val.sval) == 0) )
		return 0;

	if ( slices->slice == 0)
		parallel =OPTpreparePartition(nmb, p, slices, pc);

	if (strcmp(slices->column, getVarConstant(nmb, getArg(p,4)).val.sval) )   {
		/* sideways projection the range selection */
		q= newInstruction(nmb,ASSIGNsymbol);
		setModuleId(q,algebraRef);
		setFunctionId(q,semijoinRef);
		k = newTmpVariable(nmb, getVarType(mb, getArg(p,0)));
		setVarUDFtype(nmb,k);
		setVarUsed(nmb,k);
		getArg(q,0)= getArg(p,0);
		getArg(p,0)= k;
		q= pushArgument(nmb,q, k);
		q= pushArgument(nmb,q, slices->slice);
		pushInstruction(nmb,q);
	} 
	return parallel;
} 

/* 
 * The plan is analysed for the maximal subplan that involves a partitioned table
 * and that does not require data exchanges.
 * This portion is extracted for possibly remote execution.
*/
#define BLOCKED 1
#define REQUIRED 2
#define EXPORTED 3
#define NEEDED 4
static int 
OPTplanFragment(Client cntxt, MalBlkPtr mb, Slices *slices)
{
	char *plan,*vars;
	int i, j, k, limit, last;
	InstrPtr ret, call, p, *old;
	Symbol s;
	MalBlkPtr nmb, cmb;
	str msg;
	char nme[BUFSIZ];

	plan = GDKzalloc(mb->ssize);
	if( plan == 0)
		return 0;
	vars = GDKzalloc(mb->vsize);
	if( vars == 0){
		GDKfree(plan);
		return 0;
	}

	snprintf(nme,BUFSIZ,"%s_plan",getFunctionId( getInstrPtr(mb,0)));
	s = newFunction(userRef, putName(nme, strlen(nme)),FUNCTIONsymbol);
	if ( s == NULL)
		return 0;
	freeMalBlk(s->def);
	s->def = copyMalBlk(mb);
	nmb = s->def;
	getFunctionId( getInstrPtr(nmb,0)) = putName(nme,strlen(nme));

	limit = nmb->stop;
	old = nmb->stmt;
	if ( newMalBlkStmt(nmb,nmb->ssize) < 0 )
		return 0;

#ifdef _DEBUG_OPT_PARTITION_
	mnstr_printf(cntxt->fdout,"#Remote plan framework\n");
	mnstr_printf(cntxt->fdout,"#partition %s.%s.%s type %d\n",
		slices->schema,
		slices->table,
		(slices->column ? slices->column: ""),
		slices->type);
#else
	(void) slices;
#endif

	/* Phase 1: determine all variables/instructions indirectly dependent on a
	   fragmented column
	*/
	last = limit;
	for ( i = 0; i < limit ; i++) {
		p = old[i];
		if ( p->token == ENDsymbol || i > last) {
			plan[i] = REQUIRED;
			last = i;
		} else
		if ( getModuleId(p) == sqlRef && (getFunctionId(p) == bindRef || getFunctionId(p) == bindidxRef) &&
			strcmp(slices->schema, getVarConstant(mb, getArg(p,2)).val.sval) == 0 &&
			strcmp(slices->table, getVarConstant(mb, getArg(p,3)).val.sval) == 0 ) {
			vars[getArg(p,0)] = REQUIRED;
			plan[i] = REQUIRED;
		} else
		/* all arguments should be free to use in distributed setting */
		for( j = p->retc; j < p->argc; j++)
		if (vars[getArg(p,j)] == BLOCKED) 
			plan[i] = BLOCKED;

		/* blocking instructions */
		if (    (getModuleId(p) == groupRef && (getFunctionId(p) == doneRef || getFunctionId(p) == newRef ||getFunctionId(p) == deriveRef) )  ||
				getModuleId(p) == pqueueRef || getModuleId(p) == aggrRef || getModuleId(p) == ioRef ||
				(getModuleId(p) == sqlRef && (getFunctionId(p) == resultSetRef || getFunctionId(p) == putName("exportValue",11) )) ||
				(getModuleId(p) == algebraRef &&(getFunctionId(p) == sliceRef || getFunctionId(p) == joinRef)) )  {
			/* add the targets of its argument to the output */
			plan[i] = BLOCKED;
		}

		if( plan[i] == BLOCKED){
			for ( j= 0; j< p->retc; j++)
				vars[getArg(p,j)] = BLOCKED;
		} else {
			for( j = 0; j < p->argc; j++)
			if (vars[getArg(p,j)] == REQUIRED) 
				break;
			if ( j != p->argc) {
				for ( j= 0; j< p->retc; j++)
					vars[getArg(p,j)] = REQUIRED;
				plan[i] = REQUIRED;
			}
		}
	}

	/* Phase 2: determine all variables/instructions contributing */
	mnstr_printf(cntxt->fdout,"#phase 2\n");
	for ( i = limit -1; i >= 0 ; i--)
	if ( plan[i] != BLOCKED ){
		p = old[i];
		for( j = 0; j < p->argc; j++)
		if (vars[getArg(p,j)] == REQUIRED) 
			plan[i] = REQUIRED;

		if( plan[i] == REQUIRED)
			for ( j= p->retc; j< p->argc; j++)
				vars[getArg(p,j)] = REQUIRED;
	}
	/* Phase 3: determine all variables to be exported */
	mnstr_printf(cntxt->fdout,"#phase 3\n");
	ret= newInstruction(nmb,ASSIGNsymbol);
	ret->barrier = RETURNsymbol;
	ret->argc= ret->retc = 0;
	for ( i = 0; i < limit ; i++)
	if ( plan[i] != REQUIRED ){
		p = old[i];
		for( j = p->retc; j < p->argc; j++)
		if (vars[getArg(p,j)] == REQUIRED && isaBatType(getArgType(nmb,p,j)) ) {
			for ( k = 0; k < ret->retc; k++)
			if (getArg(ret,k) == getArg(p,j))
				break;
			if ( k == ret->retc) 
				ret= pushReturn(nmb,ret, getArg(p,j));
		}
	}

	/* Phase 4: Bake a new function that produces them */
	plan[0] = REQUIRED;
	for ( i = 0; i < limit ; i++) 
	if( plan[i] == REQUIRED ) {
		p = copyInstruction(getInstrPtr(mb, i));
		if ( old[i]->token == ENDsymbol) {
			getFunctionId(nmb->stmt[0]) = putName(nme,strlen(nme));
			pushInstruction(nmb,ret);
			pushEndInstruction(nmb);
		} else
			pushInstruction(nmb,p);
		if (getModuleId(p) == sqlRef && (getFunctionId(p) == bindRef || getFunctionId(p) == bindidxRef))  
			OPTsliceColumn(cntxt, nmb, mb, p, slices, nmb->stop-1);
	}

	/* fix the signature and modify the underlying plan */
	while ( nmb->stmt[0]->retc )
		delArgument(nmb->stmt[0],0);
	for( i =0; i< ret->retc; i++) {
		nmb->stmt[0]= pushReturn(nmb, nmb->stmt[0], getArg(ret,i));
		for( j = 0; j< mb->stop; j++) {
			p = getInstrPtr(mb,j);
			for ( k = 0; k< p->retc; k++)
			if( getArg(p,k) == getArg(ret,i)){
				mnstr_printf(cntxt->fdout,"#adjust instruction %d\n",j);
				getArg(p,k) = newTmpVariable(mb, getArgType(mb,p,k));
			}
		}
	}

	insertSymbol(cntxt->nspace,s);
	/* construct the control plan */
	cmb = OPTplanCntrl(cntxt,mb,nmb, slices);
	msg= optimizeMALBlock(cntxt, cmb);
	if ( cmb) 
		chkProgram(cntxt->nspace, cmb);
#ifdef _DEBUG_OPT_PARTITION_
	mnstr_printf(cntxt->fdout,"#control plan errors %d %s \n",cmb->errors,msg?msg:"");
	printFunction(cntxt->fdout, cmb, 0, LIST_MAL_STMT);
#endif

	call = copyInstruction(getInstrPtr(nmb,0));
	call->barrier = 0;
	call->token = ASSIGNsymbol;
	call->argc -= 2; /* bounds are removed */
	getFunctionId(call) = getFunctionId(getInstrPtr(cmb,0));
	insertInstruction(mb,call, 1);

#ifdef _DEBUG_OPT_PARTITION_
	msg= optimizeMALBlock(cntxt, nmb);
	chkProgram(cntxt->nspace, nmb);
	mnstr_printf(cntxt->fdout,"#partition error %d %s\n", nmb->errors, msg?msg:"");
	printFunction(cntxt->fdout, nmb, 0, LIST_MAL_STMT);
#endif
	GDKfree(plan);
	GDKfree(vars);
	return 0;
}

/*
 * The general tactic is to identify instructions that are blocked in a distributed setting.
 * For those instruction we inject a multi-assignment to map is arguments to new variables
 * and the aliases are propagated thru the plan.
 * The next step is to derived a distribution consolidation plan for all arguments whose
 * portions are needed.
*/
static int
OPTpartitionImplementation(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	int i;
	wrd r = 0, rowcnt=0;	/* table should be sizeable to consider parallel execution*/
	InstrPtr q, target= 0;
	Slices slices;
	str msg = NULL;
	MalBlkPtr  omb;

	(void)cntxt;
	(void) stk;
	(void) pci;

	msg = GDKgetenv("gdk_readonly");
	if( msg == 0 || strcmp(msg,"yes"))
		mnstr_printf(cntxt->fdout,"#WARNING centipede only works for readonly databases\n");
	/* nrpeers = GDKnr_threads ? GDKnr_threads:1;*/
	/* to ease debugging now */
	nrpeers = 2;
	slicingLocal = 1;

	/* modify the block as we go */
	omb= copyMalBlk(mb);
	memset((char*) &slices,0, sizeof(slices));
	/* locate the largest non-partitioned table */
	/* Much more intelligence can be injected here */
	for (i=1; i< mb->stop; i++){
		q= getInstrPtr(mb,i);
		if ( ! (getModuleId(q) == sqlRef && getFunctionId(q) == bindRef ) )
			continue;
		/* don't split insert BATs */
		if (getVarConstant(mb, getArg(q,5)).val.ival != 0 )
			continue;
		r = getVarRows(mb, getArg(q, 0));
		if (r >= rowcnt && getTailType( getArgType(mb,q,0)) <= TYPE_str){
			rowcnt = r;
			target = q;
			r = 0;
		}
	}
	if (target == 0)
		return 0;

	/* for the time being assume one target colum */
	slices.target = target;
	slices.schema = GDKstrdup(getVarConstant(mb, getArg(target,2)).val.sval);
	slices.table = GDKstrdup(getVarConstant(mb, getArg(target,3)).val.sval);
	slices.type = getTailType(getVarType(mb,getArg(target,0)));
	slices.lslices=  newTmpVariable(mb, slices.type);
	slices.hslices=  newTmpVariable(mb, slices.type);
	slices.column = GDKstrdup(getVarConstant(mb,getArg(target,4)).val.sval);
	slices.slice = 0;

	OPTDEBUGpartition
		mnstr_printf(cntxt->fdout,"#opt_partition: target is %s.%s "
			" with " SSZFMT " rows into %d peers\n",
				getVarConstant(mb, getArg(slices.target,2)).val.sval,
				getVarConstant(mb, getArg(slices.target,3)).val.sval,
				rowcnt, nrpeers);

	/* derive a local plan based on forward flow reasoning */
	if( OPTplanFragment(cntxt, mb, &slices)== 0) {
		/* bake the controller function */
	} 
#ifdef DEBUG_DETAIL
	mnstr_printf(cntxt->fdout,"#orig BEFORE optimizer test\n");
	printFunction(cntxt->fdout, mb, 0, LIST_MAL_STMT);
#endif
#ifdef _DEBUG_OPT_PARTITION_
	msg= optimizeMALBlock(cntxt, mb);
	chkProgram(cntxt->nspace, mb);
	mnstr_printf(cntxt->fdout,"#partition %s.%s.%s type %d %s\n",
		slices.schema,
		slices.table,
		(slices.column ? slices.column: ""),
		slices.type,
		msg?msg:"");
	printFunction(cntxt->fdout, mb, 0, LIST_MAL_STMT);
#endif
	GDKfree(slices.schema);
	GDKfree(slices.table);
	if (msg || mb->errors ) {
		/* restore MAL block */
		mnstr_printf(cntxt->fdout,"#partition %s\n", msg?msg:"generic error");
		/* freeMalBlk(mb);*/
		*mb = *omb;
		return 0;
	}
	return 1;
}
@include optimizerWrapper.mx
@c
#include "opt_statistics.h"
#include "algebra.h"
@:wrapOptimizer(partition,OPT_CHECK_ALL)@

/*
 * @-
 */
@= histo
	{ @1 *vv;
		vv= (@1 *) getArgReference(stk, pci, 0 );
		*vv = @1_nil;
		vx = (ptr) &max.val.@2;
		BATmax(b, vx);
		vv= (ptr) getArgReference(stk, pci, pci->retc -1 );
		*vv = @1_nil;
		vm = (ptr) &min.val.@2;
		BATmin(b, vm);
		step.val.@2 = (max.val.@2 - min.val.@2) / (pci->retc - 2);
		if ( step.val.@2 == 0)
				step.val.@2 = max.val.@2;
		for ( i = 1; i < pci->retc-1; i++) {
			vx= (ptr) getArgReference(stk, pci, i );
			((ValPtr) vx ) ->val.@2 = min.val.@2 + i * step.val.@2;
		}
	}
@
@c
/* determine the initial slices values */
/* the min/max bounds are null values */
/* It is the heart of the approach and requires experimentation */
str
OPTvector(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{	
	BAT *b;
	int bid = *(int*) getArgReference(stk,pci, pci->argc-1);
	ValRecord min,max, step;
	int i, j;
	ptr vx,vm;

	(void) cntxt;
	(void) mb;
	if ( pci->retc < 2)
		throw(SQL,"sql.partition","Not enough slices");
	b = BATdescriptor(bid);
	if (b == NULL)
		throw(SQL,"sql.partition","Can not access BAT");
    switch ( ATOMtype(b->ttype)) {
    case TYPE_bit: @:histo(bit,cval[0])@ break;
    case TYPE_chr: @:histo(chr,cval[0])@ break;
    case TYPE_bte: @:histo(bte,btval)@ break;
    case TYPE_sht: @:histo(sht,shval)@ break;
    case TYPE_int: @:histo(int,ival)@ break;
    case TYPE_wrd: @:histo(wrd,wval)@ break;
    case TYPE_lng: @:histo(lng,lval)@ break;
    case TYPE_oid: @:histo(oid,oval)@ break;
    case TYPE_flt: @:histo(flt,fval)@ break;
    case TYPE_dbl: @:histo(dbl,dval)@ break;
	case TYPE_str:
		/* fake split, ignore the data distribution */

		j = pci->retc > 26 ?26 : pci->retc;
		for ( i = 1; i < pci->retc-1; i++) {
			char buf[BUFSIZ];
			snprintf(buf,BUFSIZ,"%c", 'a' + 26 / j);
			vx= (ptr) getArgReference(stk, pci, i );
			*(str*)vx = GDKstrdup(buf);
		}
		break;
	default:
		throw(SQL,"sql.slices","Can not slice column ");
    }

	BBPreleaseref(bid);
	return MAL_SUCCEED;
}
/* overload the select operator such as to return a NIL instead of an empty BAT */
str OPTpartitionMaterialize(int *result, int *bid, ptr low, ptr high)
{
	bit bitlow=TRUE, bithigh= FALSE;

	return ALGselectInclusive( result, bid, low, high, &bitlow, &bithigh);
}

opt_export str OPTmarkHead(int *result, int *bid)
{
	oid base = 0;
	if ( *bid == 0){
		*result = 0;
		return MAL_SUCCEED;
	}
	return ALGmarkHead(result,bid, &base);
}
