@/
The contents of this file are subject to the MonetDB Public License
Version 1.1 (the "License"); you may not use this file except in
compliance with the License. You may obtain a copy of the License at
http://www.monetdb.org/Legal/MonetDBLicense

Software distributed under the License is distributed on an "AS IS"
basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations
under the License.

The Original Code is the MonetDB Database System.

The Initial Developer of the Original Code is CWI.
Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
Copyright August 2008-2011 MonetDB B.V.
All Rights Reserved.
@

@c
/*
 * @f opt_partition
 * @a M. Kersten
 * @- Partitioning
 * Documentation in accompanying paper.
 * Partition optimizer should be followed by the aliases optimizer.
 */
@mal
module partition;
pattern optimizer.partition():str
address OPTpartition;
pattern optimizer.partition(mod:str, fcn:str):str
address OPTpartition
comment "Modify the plan to exploit parallel processing on multiple cores";

command partition.materialize(b:bat[:any_1,:any_2], low:any_2, high:any_2) :bat[:any_1,:any_2]
address OPTpartitionMaterialize
comment "Implement the partition operation. Throw an exception if the partition was empty, 
because then the subquery should produce a NIL ";

command partition.markH( b:bat[:any_1,:any_2] ) :bat[:oid,:any_2] 
address OPTmarkHead
comment "Ignore a NIL bat";

pattern partition.vector(b:bat[:oid,:any_1]) :any_1...
address OPTvector
comment "Derive a series of slices values based on sampling";

@h
#ifndef _OPT_SLICING_
#define _OPT_SLICING_
#include "opt_prelude.h"
#include "opt_support.h"

#define MAXSITES 4		/* to be refined */
@:exportOptimizer(partition)@

opt_export str OPTvector(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
opt_export str OPTpartitionMaterialize(int *result, int *bid, ptr low, ptr high);
opt_export str OPTmarkHead(int *result, int *bid);

/* #define DEBUG_DETAIL*/
#define _DEBUG_OPT_PARTITION_ 
#define OPTDEBUGpartition  if ( optDebug & ((lng)1 <<DEBUG_OPT_PARTITION) )
#endif
@c
#include "monetdb_config.h"
#include "opt_partition.h"
#include "opt_deadcode.h"
#include "mal_builder.h"
#include "mal_recycle.h"
#include "mal_interpreter.h"

static int nrpeers;				/* peers active in sliced processing */
static bte slicingLocal;		/* only use local node without remote calls*/

typedef	struct{
	InstrPtr target;
	str schema, table, column;
	int type, slice;	
	int lslices, hslices;
	ValRecord bounds[MAXSITES];
} Slices;

static int
OPTinitcode(Client cntxt, MalBlkPtr mb){
    InstrPtr p;
    str s;
    str l = NULL;

    (void) cntxt;

    /* _x := remote.connect(uri,"monetdb","monetdb","msql"); */
    p = newStmt(mb, remoteRef,connectRef);
    s = GDKgetenv("merovingian_uri");
    if (s == NULL)  /* aparently not under Merovingian control, fall back to local only */
		s= "dummyconnection";
        /* SABAOTHgetLocalConnection(&l);*/
    p= pushStr(mb,p, s == NULL ? l : s);
    p= pushStr(mb,p,"monetdb");
    p= pushStr(mb,p,"monetdb");
    p= pushStr(mb,p,"msql");
    if (l)
        GDKfree(l);
    return getArg(p,0);
}

static MalBlkPtr
OPTpartitionStub(Client cntxt, MalBlkPtr mb, int pc, MalBlkPtr pmb, Slices *slices)
{
	MalBlkPtr smb = 0;
	Symbol s;
	InstrPtr sig, q, ret;
	int j,k,conn, *arg;
	char nme[BUFSIZ];

	(void) slices;
	/* define the sub query stub for remote processing */
	snprintf(nme,BUFSIZ,"%s_stub%d",getFunctionId( getInstrPtr(mb,0)), pc);
	s = newFunction(userRef, putName(nme, strlen(nme)),FUNCTIONsymbol);
	if ( s == NULL)
		return 0;
	freeMalBlk(s->def);
	s->def = copyMalBlk(pmb);	/* get variables */
	smb = s->def;
	if ( newMalBlkStmt(smb,smb->ssize) < 0 )
		return 0;
	pushInstruction(smb, copyInstruction(pmb->stmt[0]));
	getFunctionId( getInstrPtr(smb,0)) = putName(nme,strlen(nme));
	insertSymbol(cntxt->nspace,s);

	conn = OPTinitcode(cntxt,smb);
	sig = getInstrPtr(smb,0);
	arg = (int*) GDKzalloc(sizeof(int) * sig->argc);
	/* k:= remote.put(conn,kvar) */
	for (j= sig->retc; j < sig->argc; j++) {
		q= newFcnCall(smb,remoteRef,putRef);
		setVarType(smb, getArg(q,0), TYPE_str);
		setVarUDFtype(smb, getArg(q,0));
		q= pushArgument(smb,q,conn);
		q= pushArgument(smb,q,getArg(sig,j));
		arg[j]= getArg(q,0);
	}

	/* (k1,...kn):= remote.exec(conn,slicing,qry,version....) */
	snprintf(nme,BUFSIZ,"%s_qry_%d",getFunctionId( getInstrPtr(mb,0)),pc);
	q = newInstruction(smb,ASSIGNsymbol);
	getModuleId(q) = remoteRef;
	getFunctionId(q) = execRef;
	q->retc=  q->argc= 0;
	for (j=0; j < sig->retc; j++){
		arg[j]= newTmpVariable(smb,TYPE_str);
		q = pushReturn(smb,q,arg[j]);
	}
	q= pushArgument(smb,q,conn);
	q= pushStr(smb,q,userRef);
	q= pushStr(smb,q,putName(nme,strlen(nme)));
	/* deal with all arguments ! */
	for (j=sig->retc; j < sig->argc; j++)
		q = pushArgument(smb,q,arg[j]);
	pushInstruction(smb,q);

	/* return exec_qry; */
	ret = newInstruction(smb, ASSIGNsymbol);
	ret->barrier= RETURNsymbol;
	ret->argc = ret->retc = 0;
	/* l:=remote.get(conn,k) */
	for ( j=0; j< sig->retc; j++){
		q= newFcnCall(smb,remoteRef,getRef);
		q= pushArgument(smb,q,conn);
		q= pushArgument(smb,q,arg[j]);
		k= getArg(q,0);
		setVarType(smb,k, getArgType(smb,sig,j));
		setVarUDFtype(smb, k);
		ret = pushArgument(smb,ret,k);
		ret = pushReturn(smb,ret,getArg(sig,j));
	}

    newCatchStmt(smb, "ANYexception");
    q = newStmt(smb, remoteRef, disconnectRef);
    pushArgument(smb, q, conn);
    newRaiseStmt(smb, "ANYexception");   /* pass to caller */
    newExitStmt(smb, "ANYexception");

    q = newStmt(smb, remoteRef, disconnectRef);
    pushArgument(smb, q, conn);
	if ( sig->retc)
		pushInstruction(smb,ret);
    pushEndInstruction(smb);

	GDKfree(arg);
	return smb;
}

static MalBlkPtr
OPTpartitionCntrl(Client cntxt, MalBlkPtr mb, int pc, MalBlkPtr pmb, Slices *slices)
{
	MalBlkPtr cmb;
	Symbol s;
	char nme[BUFSIZ];
	int x, i, j, k, *alias, nrpack;
	InstrPtr call, ret, p, q, *pack;

	/* define the query controller */
	snprintf(nme,BUFSIZ,"%s_cntrl_%d",getFunctionId( getInstrPtr(mb,0)),pc);
	s = newFunction(userRef, putName(nme, strlen(nme)),FUNCTIONsymbol);
	if ( s == NULL)
		return 0;
	freeMalBlk(s->def);
	s->def = copyMalBlk(pmb);	/* get variables */
	cmb = s->def;
	if ( newMalBlkStmt(cmb,cmb->ssize) < 0 )
		return 0;
	q= getInstrPtr(mb,pc);
	assert(q->token == ASSIGNsymbol);
	nrpack = q->retc;
	pack = (InstrPtr *) GDKzalloc(sizeof(InstrPtr) * nrpack);
	pushInstruction(cmb, copyInstruction(pmb->stmt[0]));
	call = copyInstruction(getInstrPtr(mb,0));
	getFunctionId( getInstrPtr(cmb,0)) = putName(nme,strlen(nme));
	insertSymbol(cntxt->nspace,s);

	/* initialize binds and histograms */
	q= newFcnCall(cmb, sqlRef, mvcRef);
	x= getArg(q,0);
	alias = (int*) GDKzalloc(nrpeers * sizeof(int));
	if( slices->column) {
		q= newInstruction(cmb, ASSIGNsymbol);
		getModuleId(q) = sqlRef;
		getFunctionId(q) = bindRef;
		q = pushArgument(cmb,q,x);
		j = getArg(q,0) = newTmpVariable(cmb,newBatType(TYPE_oid, slices->type));
		setVarUDFtype(cmb,j);
		setVarFixed(cmb,j);
		q= pushStr(cmb,q, slices->schema);
		q= pushStr(cmb,q, slices->table);
		q= pushStr(cmb,q, slices->column);
		q= pushInt(cmb,q, 0);
		pushInstruction(cmb,q);

		q= newInstruction(cmb, ASSIGNsymbol);
		getModuleId(q) = partitionRef;
		getFunctionId(q) = vectorRef;
		q = pushArgument(cmb, q, j);
		for ( j = 0; j < nrpeers +1; j++) {
			k = alias[j] = newTmpVariable(cmb, slices->type);
			q= pushReturn(cmb,q, k);
		}
		pushInstruction(cmb,q);
	}
	/* dataflow */
	if ( slices->column) {
		p = getInstrPtr(pmb,0);
		for ( k=0  ;k < nrpack ; k++){
			pack[k] = newInstruction(cmb,ASSIGNsymbol);
			getModuleId(pack[k]) = matRef;
			getFunctionId(pack[k]) = packRef;
			getArg(pack[k],0) = newTmpVariable(cmb, newBatType(TYPE_oid, getTailType(getArgType(cmb,p,k))) );
		}
	}

	if ( slicingLocal == 0){
		/* under dataflow control, initialize the variables */
		for ( k=0 ; k < nrpack ; k++){
			q = newInstruction(cmb,ASSIGNsymbol);
			getArg(q,0) = getArg(pack[k],0);
			pushNil(cmb,q, getArgType(cmb,pack[k],0));
			pushInstruction(cmb,q);
		}

		/* mark start of dataflow block */
		q= newFcnCall(cmb,languageRef,dataflowRef);
		q->barrier= BARRIERsymbol;
		x = getArg(q,0);
		setVarType(cmb,x,TYPE_int);
	}

	for ( i = 0; i < nrpeers ; i++) {
		q= copyInstruction(getInstrPtr(pmb,0));
		q->argc = call->argc- call->retc + pmb->stmt[0]->retc;;
		q->token = ASSIGNsymbol;
		q->barrier = 0;
		for ( k=0 ; k < q->retc; k++) {
			getArg(q,k) = newTmpVariable(cmb, getArgType(pmb,q,k));
			pack[k] = pushArgument(cmb,pack[k], getArg(q,k));
		}

		if ( slices->column){
			/* add the splitter arguments */
			q= pushArgument(cmb,q,alias[i]);
			q= pushArgument(cmb,q,alias[i+1]);
		}
		pushInstruction(cmb,q);
	}
	/* put all mat.pack instructions into the program
	  and make sure that they have contiguous void headed columns 
	*/
	if ( slices->column) 
	for ( k=0 ; k < nrpack; k++) {
		pushInstruction(cmb, pack[k]);
		j = newTmpVariable(cmb,getArgType(cmb,pack[k],0));
		q= newFcnCall(cmb,partitionRef,markHRef);
		getArg(q,0) = getArg(pack[k],0);
		q= pushArgument(cmb,q, j);
		getArg(pack[k],0) = j;
		pack[k] = q;
	}

	/* finalize the dataflow block */
	if ( slicingLocal == 0){
		q= newAssignment(cmb);
		q->barrier = EXITsymbol;
		getArg(q,0) = x;
	}

	/* consolidate the result */
	p= getInstrPtr(mb,pc);
	q= getInstrPtr(cmb,0);
	while(q->retc > 0)
		delArgument(q,0);
	ret = newInstruction(NULL,ASSIGNsymbol);
	ret->barrier = RETURNsymbol;
	for( i = 0 ; i< p->retc; i++){
		cmb->stmt[0] = pushReturn(cmb, cmb->stmt[0], getArg(p,i));
		ret = pushReturn(cmb, ret, getArg(p,i));
		ret = pushArgument(cmb, ret, getArg(pack[i],0));
	}
	/* remove the splitter arguments */
	if ( slices->column){
		delArgument(q,q->argc-1);
		delArgument(q,q->argc-1);
	}
	pushInstruction(cmb,ret);

	pushEndInstruction(cmb);
	GDKfree(alias);
	GDKfree(pack);

	return cmb;
}

static char *
OPTsliceDependency(MalBlkPtr mb, int pc)
{
	char *vec;
	char *var;
	int i, j, fnd;
	InstrPtr p;

	vec= (char*) GDKzalloc(mb->ssize * 2);
	if( vec == 0)
		return 0;
	var= (char*) GDKzalloc(mb->vsize * 2);
	if ( var == 0)
		return 0;

	vec[0]= 1;
	p= getInstrPtr(mb,0);
	for ( i = p->retc; i < p->argc; i++)
		var[getArg(p,i)] = 1;
	p= getInstrPtr(mb,pc);
	for ( i = p->retc; i < p->argc; i++)
		var[getArg(p,i)] = 1;
	vec[pc] = 1;
	for ( i = pc -1; i >= 0; i--){
		p = getInstrPtr(mb,i);
		fnd = 0;
		for ( j = 0; j < p->argc; j++)
			fnd += var[getArg(p,j)];
		if ( fnd){
			vec[i] = 1;
			for( j = 0; j< p->argc; j++)
				var[getArg(p,j)] = 1;
		}
	}
	GDKfree(var);
	return vec;
}

/* prepare slicing a column  by addition over the target */
static int
OPTpreparePartition(MalBlkPtr nmb, InstrPtr p, Slices *slices, int pc)
{
	InstrPtr q;
	int i,fnd,parallel = 0;

	if ( slices->slice == 0){
		slices->slice = newTmpVariable(nmb, getVarType(nmb, getArg(slices->target,0)));
		setVarUDFtype(nmb, slices->slice);
		setVarUsed(nmb, slices->slice);
		nmb->stmt[0] = pushArgument(nmb, nmb->stmt[0], slices->lslices);
		nmb->stmt[0] = pushArgument(nmb, nmb->stmt[0], slices->hslices);
		parallel=2;	/* return number of arguments added for later disposal */
	} 
	/* check if the partition column instruction is already added */
	fnd =0;
	for ( i = pc -1; i-- > 0 && fnd == 0; i--){
		q= getInstrPtr(nmb,i);
		fnd = getFunctionId(q) && getModuleId(q) == sqlRef && getFunctionId(q) == bindRef &&
			  strcmp(slices->column, getVarConstant(nmb, getArg(p,4)).val.sval) == 0;
	}
	if ( fnd == 0)
		insertInstruction(nmb, p = copyInstruction(slices->target),pc);
	q= newInstruction(nmb,ASSIGNsymbol);
	/* add the slices->to the call */
	q= pushArgument(nmb,q, getArg(p,0));
	q= pushArgument(nmb,q, slices->lslices);
	q= pushArgument(nmb,q, slices->hslices);
	setModuleId(q,partitionRef);
	setFunctionId(q,materializeRef);
	getArg(q,0)= slices->slice;
	getArg(q,1) = getArg(p,0);
	pushInstruction(nmb,q);
	return parallel;
}

static int 
OPTsliceColumn(Client cntxt, MalBlkPtr nmb, MalBlkPtr mb, InstrPtr p, Slices *slices, int pc)
{
	int k, parallel = 0;
	InstrPtr q;

	(void) cntxt;
	if ( ! (getModuleId(p) == sqlRef && getFunctionId(p) == bindRef )  &&
		 ! (getModuleId(p) == sqlRef && getFunctionId(p) == bindidxRef ) )
		return 0;
	if ( ! (strcmp(slices->schema, getVarConstant(mb, getArg(p,2)).val.sval) == 0 &&
		strcmp(slices->table, getVarConstant(mb, getArg(p,3)).val.sval) == 0) )
		return 0;

	if ( slices->slice == 0)
		parallel =OPTpreparePartition(nmb, p, slices, pc);

	if (strcmp(slices->column, getVarConstant(nmb, getArg(p,4)).val.sval) )   {
		/* sideways projection the range selection */
		q= newInstruction(nmb,ASSIGNsymbol);
		setModuleId(q,algebraRef);
		setFunctionId(q,semijoinRef);
		k = newTmpVariable(nmb, getVarType(mb, getArg(p,0)));
		setVarUDFtype(nmb,k);
		setVarUsed(nmb,k);
		getArg(q,0)= getArg(p,0);
		getArg(p,0)= k;
		q= pushArgument(nmb,q, k);
		q= pushArgument(nmb,q, slices->slice);
		pushInstruction(nmb,q);
	} 
	return parallel;
} 

/* run through a plan recursively to detect if it is already consolidating a partitioned database */
static int
OPTconsolidated(MalBlkPtr mb)
{
	int i;
	InstrPtr p;
	for( i =1 ; i < mb->stop; i++) {
		p = getInstrPtr(mb,i);
		if ( getFunctionId(p) ){
			if ( strstr(getFunctionId(p),"_cntrl_")  ||
				 strstr(getFunctionId(p),"_bag_") )
				return 1;
			if ( p->blk  && OPTconsolidated(p->blk))
				return 1;
		} 
	}
	return 0;
}

/*
 * The multi-assignment pointed at is turned into separate function to gather
 * all arguments
*/
static int
OPTparallelcode(Client cntxt, MalBlkPtr mb, int pc, Slices *slices)
{
	char *vec = 0;
	int parallel = 0, i, k, limit;
	MalBlkPtr nmb = 0, smb = 0 , cmb = 0 ;
	InstrPtr p, q, *old;
	Symbol s;
	char nme[BUFSIZ];
	str msg= MAL_SUCCEED;
	
	assert(getInstrPtr(mb,pc)->token == ASSIGNsymbol);
	/* define the sub query as part of the user space */
	snprintf(nme,BUFSIZ,"%s_qry_%d",getFunctionId( getInstrPtr(mb,0)), pc);
	s = newFunction(userRef, putName(nme, strlen(nme)),FUNCTIONsymbol);
	if ( s == NULL)
		return 0;
	freeMalBlk(s->def);
	s->def = copyMalBlk(mb);
	nmb = s->def;
	getFunctionId( getInstrPtr(nmb,0)) = putName(nme,strlen(nme));
	/* slices variables should be reset. */
	slices->slice = 0;

	limit = nmb->stop;
	old = nmb->stmt;
	if ( newMalBlkStmt(nmb,nmb->ssize) < 0 )
		return 0;

	vec = OPTsliceDependency(mb, pc);

	for ( i = 0; i < limit; i++) {
		p = old[i];
		if ( vec[i]) {
			if ( i == pc) {
				/* return the result of this multi-assignment */
				/* adjust the signature */
				pushInstruction(nmb,p);
				p->barrier = RETURNsymbol;
				continue;
			} else  {
				pushInstruction(nmb,p);
				if (getModuleId(p) == sqlRef && (getFunctionId(p) == bindRef || getFunctionId(p) == bindidxRef))  
					parallel += OPTsliceColumn(cntxt, nmb, mb, p, slices,nmb->stop-1);
			}
		} else
		if ( p->token == ENDsymbol) {
			pushEndInstruction(nmb);
			continue;
		}
		else if ( getModuleId(p) == optimizerRef)
			pushInstruction(nmb,old[i]);
		else {
			freeInstruction(old[i]);
			old[i] = 0;
		}
	}

	if ( parallel == 0 || (0 && OPTconsolidated(nmb)) ){
		/* no partitioned column used or portions are already consolidated */
		if (vec) GDKfree(vec);
		freeMalBlk(nmb);
		return 0;
	}
	insertSymbol(cntxt->nspace,s);

	p= getInstrPtr(mb,pc);
	while(getInstrPtr(nmb,0)->retc > 0)
		delArgument(getInstrPtr(nmb,0),0);
	for ( k = 0; k < p->retc; k++) 
		nmb->stmt[0] =  pushReturn(nmb, nmb->stmt[0], getArg(p,k));

#ifdef DEBUG_DETAIL
	mnstr_printf(cntxt->fdout,"#nmb, CODEGEN BEFORE SUBS? %d\n", nmb->errors);
	if ( nmb)
		printFunction(cntxt->fdout, nmb, 0, LIST_MAL_STMT);
#endif
	/* supportive routines */
	smb = OPTpartitionStub(cntxt, mb, pc,  nmb, slices);
#ifdef DEBUG_DETAIL
	mnstr_printf(cntxt->fdout,"#smb,BEFORE test? %d\n", smb->errors);
	if ( smb)
		printFunction(cntxt->fdout, smb, 0, LIST_MAL_STMT);
#endif
	msg = OPTdeadcode(cntxt, smb, 0, 0);
	if ( msg)
		goto wrapup;

	cmb = OPTpartitionCntrl(cntxt,mb,pc,nmb, slices);
	chkProgram(cntxt->nspace, cmb);
#ifdef DEBUG_DETAIL
	mnstr_printf(cntxt->fdout,"#cntrl,AFTER test? %d\n", cmb->errors);
	if ( cmb)
		printFunction(cntxt->fdout, cmb, 0, LIST_MAL_STMT);
#endif
	if ( cmb->errors)
		goto wrapup;

	msg = OPTdeadcode(cntxt, nmb, 0, 0);
	if ( msg)
		goto wrapup;

#ifdef DEBUG_DETAIL
	mnstr_printf(cntxt->fdout,"#nmb,BEFORE test? %d\n", nmb->errors);
	if ( nmb)
		printFunction(cntxt->fdout, nmb, 0, LIST_MAL_STMT);
#endif
	chkProgram(cntxt->nspace, nmb);
	if ( nmb->errors)
		goto wrapup;
	/* beware, optimizer may reorder/relabel variables */
	msg= optimizeMALBlock(cntxt, nmb);
	if ( msg)
		goto wrapup;

	/* correct the caller and the callees */
	p= getInstrPtr(mb,pc);
	getFunctionId(p) = getFunctionId(getInstrPtr(cmb,0));
	getModuleId(p) = userRef;
	p->argc= p->retc;
	q= getInstrPtr(cmb,0);
	for( i = q->retc; i < q->argc; i++)
		mb->stmt[pc] = pushArgument(mb, mb->stmt[pc], getArg(q,i));
	
wrapup:
#ifdef _DEBUG_OPT_PARTITION_
	mnstr_printf(cntxt->fdout,"#Grabbed part, nmb error ? %d\n",nmb->errors);
	if ( nmb)
		printFunction(cntxt->fdout, nmb, 0, LIST_MAL_STMT);
	mnstr_printf(cntxt->fdout,"#stub, smb error ? %d\n", smb->errors);
	if ( smb)
		printFunction(cntxt->fdout, smb, 0, LIST_MAL_STMT);
	mnstr_printf(cntxt->fdout,"#cntrl, cmb error? %d\n", cmb->errors);
	if ( cmb)
		printFunction(cntxt->fdout, cmb, 0, LIST_MAL_STMT);
#endif

	if (vec) GDKfree(vec);
	return 1;
}

static void
remapVariable( MalBlkPtr mb, int i, int old, int new)
{
	InstrPtr p;
	int k;

	for( ; i< mb->stop; i++){
		p= getInstrPtr(mb,i);
		for ( k = 0; k < p->argc; k++)
		if ( getArg(p,k) == old)
			getArg(p,k) = new;
	}
}

/* 
 * take a multi-assignement and resolve the distributed plan
 * for all right-hand arguments
*/
static int
OPTcollect(Client cntxt, MalBlkPtr mb, int pc, Slices *slices)
{
	InstrPtr p;
	int  parallel;

	p = getInstrPtr(mb, pc);
	assert(p->token == ASSIGNsymbol);
	if( (parallel = OPTparallelcode(cntxt, mb, pc, slices) ) ) {
/*
		q= getInstrPtr(mb,0);
		for( j = q->retc; j < q->argc; j++)
			mb->stmt[pc] = pushArgument(mb, mb->stmt[pc], getArg(q,j));
*/
	} /* else no parallelism, just a multi-assignment */
	return parallel;
} 

/*
 * The general tactic is to identify instructions that are blocked in a distributed setting.
 * For those instruction we inject a multi-assignment to map is arguments to new variables
 * and the aliases are propagated thru the plan.
 * The next step is to derived a distribution consolidation plan for all arguments whose
 * portions are needed.
*/
static int
OPTpartitionImplementation(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	int i,j,k,pc = 0;
	wrd r = 0, rowcnt=0;	/* table should be sizeable to consider parallel execution*/
	InstrPtr p,q, target= 0, rsset=0;
	Slices slices;
	str msg = NULL;
	MalBlkPtr  omb;

	(void)cntxt;
	(void) stk;
	(void) pci;

	msg = GDKgetenv("gdk_readonly");
	if( msg == 0 || strcmp(msg,"yes"))
		mnstr_printf(cntxt->fdout,"#WARNING centipede only works for readonly databases\n");
    /* nrpeers = GDKnr_threads ? GDKnr_threads:1;*/
	/* to ease debugging now */
	nrpeers = 2;
	slicingLocal = 1;

	/* modify the block as we go */
	omb= copyMalBlk(mb);
	memset((char*) &slices,0, sizeof(slices));
	/* locate the largest non-partitioned table */
	/* Much more intelligence can be injected here */
	for (i=1; i< mb->stop; i++){
		q= getInstrPtr(mb,i);
		if ( ! (getModuleId(q) == sqlRef && getFunctionId(q) == bindRef ) )
			continue;
		/* don't split insert BATs */
		if (getVarConstant(mb, getArg(q,5)).val.ival != 0 )
			continue;
		r = getVarRows(mb, getArg(q, 0));
		if (r >= rowcnt && getTailType( getArgType(mb,q,0)) <= TYPE_str){
			rowcnt = r;
			target = q;
			r = 0;
		}
	}
	if (target == 0)
		return 0;

	/* for the time being assume one target colum */
	slices.target = target;
	slices.schema = GDKstrdup(getVarConstant(mb, getArg(target,2)).val.sval);
	slices.table = GDKstrdup(getVarConstant(mb, getArg(target,3)).val.sval);
	slices.type = getTailType(getVarType(mb,getArg(target,0)));
	slices.lslices=  newTmpVariable(mb, slices.type);
	slices.hslices=  newTmpVariable(mb, slices.type);
	slices.column = GDKstrdup(getVarConstant(mb,getArg(target,4)).val.sval);
	slices.slice = 0;

	OPTDEBUGpartition
		mnstr_printf(cntxt->fdout,"#opt_partition: target is %s.%s "
			" with " SSZFMT " rows into %d peers\n",
				getVarConstant(mb, getArg(slices.target,2)).val.sval,
				getVarConstant(mb, getArg(slices.target,3)).val.sval,
				rowcnt, nrpeers);



	for(i=0; i < mb->stop; i++){
		p= getInstrPtr(mb,i);

		if ( getModuleId(p) == sqlRef && getFunctionId(p) == resultSetRef ) {
			/* for result sets we have to collect the arguments of the rsColumn */
			/* gather all columns into the resultSet constructor to ease code generation */
			rsset= newInstruction(mb,ASSIGNsymbol);
			for (j= i+1; j< mb->stop; j++){
				q= getInstrPtr(mb,j);
				if ( getModuleId(q) == sqlRef) {
					if ( getFunctionId(q) == rsColumnRef) {
						k = newTmpVariable(mb, getArgType(mb,q,7));
						rsset= pushReturn(mb,rsset, k); 
						rsset= pushArgument(mb,rsset, getArg(q,7));
						getArg(q,7) = k;
					}
				}
			}
			/* be aware that the resultSet already has a column argument */
			getArg(p,3) = getArg(rsset,0);
			insertInstruction(mb,rsset,i);
			OPTcollect(cntxt,mb,i, &slices);
			i++;
			continue;
		}

		if ( getModuleId(p) == sqlRef && getFunctionId(p) == putName("exportValue",11) &&
				isaBatType(getArgType(mb,p,8)) ){
			rsset= newInstruction(mb,ASSIGNsymbol);
			getArg(rsset,0) = newTmpVariable(mb, getArgType(mb,p,8));
			rsset= pushArgument(mb,rsset, getArg(p,8));
			getArg(p,8) = getArg(rsset,0);
			insertInstruction(mb,rsset,i);
			OPTcollect(cntxt,mb,i, &slices);
			i++;
			continue;
		}

		/* grouping and aggregation are blocking instruction for the time being */
		if (  (getModuleId(p) == groupRef && (getFunctionId(p) == doneRef || getFunctionId(p) == newRef ||getFunctionId(p) == deriveRef) )  ||
				getModuleId(p) == aggrRef ) {
			rsset= newInstruction(mb,ASSIGNsymbol);
			for ( j = p->retc; j < p->argc; j++)  {
				for ( k = p->retc; k < j; k++)
					if( getArg(p,j) == getArg(p,k))
						break;
				if ( k == j && isaBatType(getArgType(mb,p,j)) ){
					k = newTmpVariable(mb, getArgType(mb,p,j));
					rsset= pushReturn(mb,rsset, k); 
					rsset= pushArgument(mb,rsset, getArg(p,j));
					remapVariable(mb, i, getArg(p,j), k);
				}
			}
			if ( rsset->argc ) {
				insertInstruction(mb,rsset,i);
				OPTcollect(cntxt,mb,i, &slices);
				i++;
			}
			continue;
		}
		if ( p->token == ENDsymbol)
			pc = i -1;
	}
#ifdef DEBUG_DETAIL
	mnstr_printf(cntxt->fdout,"#orig BEFORE optimizer test\n");
	printFunction(cntxt->fdout, mb, 0, LIST_MAL_STMT);
#endif
#ifdef _DEBUG_OPT_PARTITION_
	msg= optimizeMALBlock(cntxt, mb);
	chkProgram(cntxt->nspace, mb);
	mnstr_printf(cntxt->fdout,"#partition %s.%s.%s type %d %s\n",
		slices.schema,
		slices.table,
		(slices.column ? slices.column: ""),
		slices.type,
		msg?msg:"");
	printFunction(cntxt->fdout, mb, 0, LIST_MAL_STMT);
#endif
	GDKfree(slices.schema);
	GDKfree(slices.table);
	if (msg || mb->errors ) {
		/* restore MAL block */
		mnstr_printf(cntxt->fdout,"#partition %s\n", msg?msg:"generic error");
		/* freeMalBlk(mb);*/
		*mb = *omb;
		return 0;
	}
	return 1;
}
@include optimizerWrapper.mx
@c
#include "opt_statistics.h"
#include "algebra.h"
@:wrapOptimizer(partition,OPT_CHECK_ALL)@

/*
 * @-
 */
@= histo
	{ @1 *vv;
		vv= (@1 *) getArgReference(stk, pci, 0 );
		*vv = @1_nil;
		vx = (ptr) &max.val.@2;
		BATmax(b, vx);
		vv= (ptr) getArgReference(stk, pci, pci->retc -1 );
		*vv = @1_nil;
		vm = (ptr) &min.val.@2;
		BATmin(b, vm);
		step.val.@2 = (max.val.@2 - min.val.@2) / (pci->retc - 2);
		if ( step.val.@2 == 0)
				step.val.@2 = max.val.@2;
		for ( i = 1; i < pci->retc-1; i++) {
			vx= (ptr) getArgReference(stk, pci, i );
			((ValPtr) vx ) ->val.@2 = min.val.@2 + i * step.val.@2;
		}
	}
@
@c
/* determine the initial slices values */
/* the min/max bounds are null values */
/* It is the heart of the approach and requires experimentation */
str
OPTvector(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{	
	BAT *b;
	int bid = *(int*) getArgReference(stk,pci, pci->argc-1);
	ValRecord min,max, step;
	int i, j;
	ptr vx,vm;

	(void) cntxt;
	(void) mb;
	if ( pci->retc < 2)
		throw(SQL,"sql.partition","Not enough slices");
	b = BATdescriptor(bid);
	if (b == NULL)
		throw(SQL,"sql.partition","Can not access BAT");
    switch ( ATOMtype(b->ttype)) {
    case TYPE_bit: @:histo(bit,cval[0])@ break;
    case TYPE_chr: @:histo(chr,cval[0])@ break;
    case TYPE_bte: @:histo(bte,btval)@ break;
    case TYPE_sht: @:histo(sht,shval)@ break;
    case TYPE_int: @:histo(int,ival)@ break;
    case TYPE_wrd: @:histo(wrd,wval)@ break;
    case TYPE_lng: @:histo(lng,lval)@ break;
    case TYPE_oid: @:histo(oid,oval)@ break;
    case TYPE_flt: @:histo(flt,fval)@ break;
    case TYPE_dbl: @:histo(dbl,dval)@ break;
	case TYPE_str:
		/* fake split, ignore the data distribution */

		j = pci->retc > 26 ?26 : pci->retc;
		for ( i = 1; i < pci->retc-1; i++) {
			char buf[BUFSIZ];
			snprintf(buf,BUFSIZ,"%c", 'a' + 26 / j);
			vx= (ptr) getArgReference(stk, pci, i );
			*(str*)vx = GDKstrdup(buf);
		}
		break;
	default:
		throw(SQL,"sql.slices","Can not slice column ");
    }

	BBPreleaseref(bid);
	return MAL_SUCCEED;
}
/* overload the select operator such as to return a NIL instead of an empty BAT */
str OPTpartitionMaterialize(int *result, int *bid, ptr low, ptr high)
{
	bit bitlow=TRUE, bithigh= FALSE;

	return ALGselectInclusive( result, bid, low, high, &bitlow, &bithigh);
}

opt_export str OPTmarkHead(int *result, int *bid)
{
	oid base = 0;
	if ( *bid == 0){
		*result = 0;
		return MAL_SUCCEED;
	}
	return ALGmarkHead(result,bid, &base);
}
