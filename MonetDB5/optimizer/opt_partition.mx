@/
The contents of this file are subject to the MonetDB Public License
Version 1.1 (the "License"); you may not use this file except in
compliance with the License. You may obtain a copy of the License at
http://www.monetdb.org/Legal/MonetDBLicense

Software distributed under the License is distributed on an "AS IS"
basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations
under the License.

The Original Code is the MonetDB Database System.

The Initial Developer of the Original Code is CWI.
Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
Copyright August 2008-2011 MonetDB B.V.
All Rights Reserved.
@

@c
/*
 * @f opt_partition
 * @a M. Kersten
 * @- Partitioning
 * Documentation in accompanying paper.
 */
@mal
module partition;
pattern optimizer.partition():str
address OPTpartition;
pattern optimizer.partition(mod:str, fcn:str):str
address OPTpartition
comment "Modify the plan to exploit parallel processing on multiple cores";

command partition.materialize(b:bat[:any_1,:any_2], low:any_2, high:any_2) :bat[:any_1,:any_2]
address OPTpartitionMaterialize
comment "Implement the partition operation. Throw an exception if the partition was empty, 
because then the subquery should produce a NIL ";

command partition.markH( b:bat[:any_1,:any_2] ) :bat[:oid,:any_2] 
address OPTmarkHead
comment "Ignore a NIL bat";

pattern partition.vector(b:bat[:oid,:any_1]) :any_1...
address OPTvector
comment "Derive a series of slices values based on sampling";

@h
#ifndef _OPT_SLICING_
#define _OPT_SLICING_
#include "opt_prelude.h"
#include "opt_support.h"

#define MAXSITES 4		/* to be refined */
@:exportOptimizer(partition)@

opt_export str OPTvector(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
opt_export str OPTpartitionMaterialize(int *result, int *bid, ptr low, ptr high);
opt_export str OPTmarkHead(int *result, int *bid);

/* #define DEBUG_DETAIL*/
#define _DEBUG_OPT_PARTITION_ 
#define OPTDEBUGpartition  if ( optDebug & ((lng)1 <<DEBUG_OPT_PARTITION) )
#endif
@c
#include "monetdb_config.h"
#include "opt_partition.h"
#include "opt_deadcode.h"
#include "mal_builder.h"
#include "mal_recycle.h"
#include "mal_interpreter.h"

static int nrpeers;				/* peers active in sliced processing */
static bte slicingLocal;		/* only use local node without remote calls*/

typedef	struct{
	InstrPtr target;
	str schema, table, column;
	int type, slice;	
	int lslices, hslices;
	ValRecord bounds[MAXSITES];
} Slices;

static int
OPTinitcode(Client cntxt, MalBlkPtr mb){
    InstrPtr p;
    str s;
    str l = NULL;

    (void) cntxt;

    /* _x := remote.connect(uri,"monetdb","monetdb","msql"); */
    p = newStmt(mb, remoteRef,connectRef);
    s = GDKgetenv("merovingian_uri");
    if (s == NULL)  /* aparently not under Merovingian control, fall back to local only */
		s= "dummyconnection";
        /* SABAOTHgetLocalConnection(&l);*/
    p= pushStr(mb,p, s == NULL ? l : s);
    p= pushStr(mb,p,"monetdb");
    p= pushStr(mb,p,"monetdb");
    p= pushStr(mb,p,"msql");
    if (l)
        GDKfree(l);
    return getArg(p,0);
}

static void
OPTcatchcode(MalBlkPtr nmb, int aggrflg){
	InstrPtr p, q;
	int i;

	(void) aggrflg;
	/* in case of aggregates we return empty bats */
    q = newCatchStmt(nmb,"ANYexception");
	p = getInstrPtr(nmb,0);
	for ( i=0; i< p->retc; i++){
		q = newAssignment(nmb);
		getArg(q,0) = getArg(p,i);
		q= pushNil(nmb,q, TYPE_void);
	}
	/* clear the exception */
	q= newAssignment(nmb);
	getArg(q,0) = findVariable(nmb,"ANYexception");
	pushNil(nmb,q,TYPE_str);
	q = newExitStmt(nmb,"ANYexception");
}

static MalBlkPtr
OPTpartitionStub(Client cntxt, MalBlkPtr mb, int pc, MalBlkPtr pmb, Slices slices)
{
	MalBlkPtr smb = 0;
	Symbol s;
	InstrPtr sig, q, ret;
	int j,k,conn, *arg;
	char nme[BUFSIZ];
	(void) slices;

	/* define the sub query stub for remote processing */
	snprintf(nme,BUFSIZ,"%s_stub%d",getFunctionId( getInstrPtr(mb,0)), pc);
	s = newFunction(userRef, putName(nme, strlen(nme)),FUNCTIONsymbol);
	if ( s == NULL)
		return 0;
	freeMalBlk(s->def);
	s->def = copyMalBlk(pmb);	/* get variables */
	smb = s->def;
	if ( newMalBlkStmt(smb,smb->ssize) < 0 )
		return 0;
	pushInstruction(smb, copyInstruction(pmb->stmt[0]));
	getFunctionId( getInstrPtr(smb,0)) = putName(nme,strlen(nme));
	insertSymbol(cntxt->nspace,s);

	conn = OPTinitcode(cntxt,smb);
	sig = getInstrPtr(smb,0);
	arg = (int*) GDKzalloc(sizeof(int) * sig->argc);
	/* k:= remote.put(conn,kvar) */
	for (j= sig->retc; j < sig->argc; j++) {
		q= newFcnCall(smb,remoteRef,putRef);
		setVarType(smb, getArg(q,0), TYPE_str);
		setVarUDFtype(smb, getArg(q,0));
		q= pushArgument(smb,q,conn);
		q= pushArgument(smb,q,getArg(sig,j));
		arg[j]= getArg(q,0);
	}

	/* (k1,...kn):= remote.exec(conn,slicing,qry,version....) */
	snprintf(nme,BUFSIZ,"%s_qry_%d",getFunctionId( getInstrPtr(mb,0)),pc);
	q = newInstruction(smb,ASSIGNsymbol);
	getModuleId(q) = remoteRef;
	getFunctionId(q) = execRef;
	q->retc=  q->argc= 0;
	for (j=0; j < sig->retc; j++){
		arg[j]= newTmpVariable(smb,TYPE_str);
		q = pushReturn(smb,q,arg[j]);
	}
	q= pushArgument(smb,q,conn);
	q= pushStr(smb,q,userRef);
	q= pushStr(smb,q,putName(nme,strlen(nme)));
	/* deal with all arguments ! */
	for (j=sig->retc; j < sig->argc; j++)
		q = pushArgument(smb,q,arg[j]);
	pushInstruction(smb,q);

	/* return exec_qry; */
	ret = newInstruction(smb, ASSIGNsymbol);
	ret->barrier= RETURNsymbol;
	ret->argc = ret->retc = 0;
	/* l:=remote.get(conn,k) */
	for ( j=0; j< sig->retc; j++){
		q= newFcnCall(smb,remoteRef,getRef);
		q= pushArgument(smb,q,conn);
		q= pushArgument(smb,q,arg[j]);
		k= getArg(q,0);
		setVarType(smb,k, getArgType(smb,sig,j));
		setVarUDFtype(smb, k);
		ret = pushArgument(smb,ret,k);
		ret = pushReturn(smb,ret,getArg(sig,j));
	}

    newCatchStmt(smb, "ANYexception");
    q = newStmt(smb, remoteRef, disconnectRef);
    pushArgument(smb, q, conn);
    newRaiseStmt(smb, "ANYexception");   /* pass to caller */
    newExitStmt(smb, "ANYexception");

    q = newStmt(smb, remoteRef, disconnectRef);
    pushArgument(smb, q, conn);
	if ( sig->retc)
		pushInstruction(smb,ret);
    pushEndInstruction(smb);

	GDKfree(arg);
	return smb;
}

static MalBlkPtr
OPTpartitionCntrl(Client cntxt, MalBlkPtr mb, int pc, MalBlkPtr pmb, Slices slices)
{
	MalBlkPtr cmb;
	Symbol s;
	char nme[BUFSIZ];
	int x, i, j, k, *alias, nrpack;
	InstrPtr call, ret, p, q, *pack;

	(void) slices;
	/* define the query controller */
	snprintf(nme,BUFSIZ,"%s_cntrl_%d",getFunctionId( getInstrPtr(mb,0)),pc);
	s = newFunction(userRef, putName(nme, strlen(nme)),FUNCTIONsymbol);
	if ( s == NULL)
		return 0;
	freeMalBlk(s->def);
	s->def = copyMalBlk(pmb);	/* get variables */
	cmb = s->def;
	if ( newMalBlkStmt(cmb,cmb->ssize) < 0 )
		return 0;
	q= getInstrPtr(mb,pc);
	if ( getModuleId(q) == groupRef && 
		( getFunctionId(q) == doneRef ||getFunctionId(q) == newRef))
		nrpack = 1;
	else
	if ( getModuleId(q) == sqlRef && getFunctionId(q) == resultSetRef) 
		nrpack = q->retc -1;
	else
		nrpack = q->retc;
	pack = (InstrPtr *) GDKzalloc(sizeof(InstrPtr) * nrpack);
	pushInstruction(cmb, copyInstruction(pmb->stmt[0]));
	call = copyInstruction(getInstrPtr(mb,0));
	getFunctionId( getInstrPtr(cmb,0)) = putName(nme,strlen(nme));
	insertSymbol(cntxt->nspace,s);

	/* initialize binds and histograms */
	q= newFcnCall(cmb, sqlRef, mvcRef);
	x= getArg(q,0);
	alias = (int*) GDKzalloc(nrpeers * sizeof(int));
	if( slices.column) {
		q= newInstruction(cmb, ASSIGNsymbol);
		getModuleId(q) = sqlRef;
		getFunctionId(q) = bindRef;
		q = pushArgument(cmb,q,x);
		j = getArg(q,0) = newTmpVariable(cmb,newBatType(TYPE_oid, slices.type));
		setVarUDFtype(cmb,j);
		setVarFixed(cmb,j);
		q= pushStr(cmb,q, slices.schema);
		q= pushStr(cmb,q, slices.table);
		q= pushStr(cmb,q, slices.column);
		q= pushInt(cmb,q, 0);
		pushInstruction(cmb,q);

		q= newInstruction(cmb, ASSIGNsymbol);
		getModuleId(q) = partitionRef;
		getFunctionId(q) = vectorRef;
		q = pushArgument(cmb, q, j);
		for ( j = 0; j < nrpeers +1; j++) {
			k = alias[j] = newTmpVariable(cmb, slices.type);
			q= pushReturn(cmb,q, k);
		}
		pushInstruction(cmb,q);
	}
	/* dataflow */
	if ( slices.column) {
		p = getInstrPtr(pmb,0);
		for ( k=0  ;k < nrpack ; k++){
			pack[k] = newInstruction(cmb,ASSIGNsymbol);
			getModuleId(pack[k]) = matRef;
			getFunctionId(pack[k]) = packRef;
			getArg(pack[k],0) = newTmpVariable(cmb, newBatType(TYPE_oid, getTailType(getArgType(cmb,p,k))) );
		}
	}

	if ( slicingLocal == 0){
		/* under dataflow control, initialize the variables */
		for ( k=0 ; k < nrpack ; k++){
			q = newInstruction(cmb,ASSIGNsymbol);
			getArg(q,0) = getArg(pack[k],0);
			pushNil(cmb,q, getArgType(cmb,pack[k],0));
			pushInstruction(cmb,q);
		}

		/* mark start of dataflow block */
		q= newFcnCall(cmb,languageRef,dataflowRef);
		q->barrier= BARRIERsymbol;
		x = getArg(q,0);
		setVarType(cmb,x,TYPE_int);
	}

	for ( i = 0; i < nrpeers ; i++) {
		q= copyInstruction(getInstrPtr(pmb,0));
		q->argc = call->argc- call->retc + pmb->stmt[0]->retc;;
		q->token = ASSIGNsymbol;
		q->barrier = 0;
		for ( k=0 ; k < q->retc; k++) {
			getArg(q,k) = newTmpVariable(cmb, getArgType(pmb,q,k));
			pack[k] = pushArgument(cmb,pack[k], getArg(q,k));
		}

		if ( slices.column){
			/* add the splitter arguments */
			q= pushArgument(cmb,q,alias[i]);
			q= pushArgument(cmb,q,alias[i+1]);
		}
		pushInstruction(cmb,q);
	}
	/* put all mat.pack instructions into the program
	  and make sure that they have contiguous void headed columns 
	*/
	if ( slices.column) 
	for ( k=0 ; k < nrpack; k++) {
		pushInstruction(cmb, pack[k]);
		j = newTmpVariable(cmb,getArgType(cmb,pack[k],0));
		q= newFcnCall(cmb,partitionRef,markHRef);
		getArg(q,0) = getArg(pack[k],0);
		q= pushArgument(cmb,q, j);
		getArg(pack[k],0) = j;
		pack[k] = q;
	}

	/* finalize the dataflow block */
	if ( slicingLocal == 0){
		q= newAssignment(cmb);
		q->barrier = EXITsymbol;
		getArg(q,0) = x;
	}

	/* consolidate the result */
	q = copyInstruction(getInstrPtr(mb,pc));
	if ( getFunctionId(q) == countRef || getFunctionId(q) == sumRef ){
		getFunctionId(q) = sumRef;
		getArg(q,1) = getArg(pack[0],0);
		setVarType(cmb,getArg(getInstrPtr(cmb,0),0),getArgType(cmb,q,0));
	} else 
	if ( getFunctionId(q) == minRef || getFunctionId(q) == maxRef) {
		getArg(q,1) = getArg(pack[0],0);
	} else 
	if ( getFunctionId(q) == avgRef)
		assert(0);
	else
	if ( getFunctionId(q) == putName("exportValue",11)) 
		getArg(q,8)= getArg(pack[0],0);
	else
	if ( getModuleId(q) == groupRef && 
		( getFunctionId(q) == doneRef || getFunctionId(q) == newRef)) {
		/* just return the argument */
		clrFunction(q);
		q->argc = q->retc = 1;
		q = pushArgument(cmb,q, getArg(pack[0],0));
		getArg(q,0) = getArg(q,1);
	} else
	if ( getModuleId(q) == sqlRef && getFunctionId(q) == resultSetRef) {
		p = newInstruction(NULL,ASSIGNsymbol);
		for ( k = q->retc +3; k< q->argc; k++){
			p = pushReturn(cmb,p,getArg(q,k));
			p = pushArgument(cmb,p, getArg(pack[k - q->retc-3], 0));
		}
		q= p;
	} else
	if ( getFunctionId(q) == NULL){
		/* simple assignment */
		assert(nrpack == q->retc);
		for( k = 0; k < nrpack; k++)
			getArg(q, q->retc + k) = getArg(pack[k],0);
	}
	
	pushInstruction(cmb,q);

	ret = newInstruction(NULL,ASSIGNsymbol);
	ret->barrier = RETURNsymbol;
	ret->argc = ret->retc =0;
	for( i = 0 ; i< q->retc; i++)
		ret = pushReturn(cmb,ret,getArg(q,i));
	pushInstruction(cmb,ret);

	pushEndInstruction(cmb);
	GDKfree(alias);
	GDKfree(pack);

	return cmb;
}

static char *
OPTsliceDependency(MalBlkPtr mb, int pc)
{
	char *vec;
	char *var;
	int i, j, fnd;
	InstrPtr p;

	vec= (char*) GDKzalloc(mb->ssize * 2);
	if( vec == 0)
		return 0;
	var= (char*) GDKzalloc(mb->vsize * 2);
	if ( var == 0)
		return 0;

	p= getInstrPtr(mb,pc);
	for ( i = p->retc; i < p->argc; i++)
		var[getArg(p,i)] = 1;
	vec[pc] = 1;
	for ( i = pc -1; i >= 0; i--){
		p = getInstrPtr(mb,i);
		fnd = 0;
		for ( j = 0; j < p->argc; j++)
			fnd += var[getArg(p,j)];
		if ( fnd){
			vec[i] = 1;
			for( j = 0; j< p->argc; j++)
				var[getArg(p,j)] = 1;
		}
	}
	vec[0] = 1;
	GDKfree(var);
	return vec;
}

static int *
OPTvarDependency(MalBlkPtr mb, int pc, int varid)
{
	int *vec;
	char *var;
	int i, j, fnd, error = FALSE;
	InstrPtr p;

	vec= (int*) GDKzalloc(mb->ssize * sizeof(int));
	if( vec == 0)
		return 0;
	var= (char*) GDKzalloc(mb->vsize );
	if ( var == 0)
		return 0;

	p= getInstrPtr(mb,pc);
	var[varid] = 1;
	vec[pc] = 1;
	for ( i = pc -1; error == FALSE && i >= 0; i--){
		p = getInstrPtr(mb,i);
		fnd = 0;
		for ( j = 0; j < p->argc; j++)
			fnd += var[getArg(p,j)];
		if ( fnd){
			vec[i] = 1;
			for( j = 0; j< p->argc; j++)
				var[getArg(p,j)] = 1;
			/* abort when we find blocking operations */
			if ( getModuleId(p) == groupRef && getFunctionId(p) == newRef)
				error = TRUE;
		}
	}
	vec[0] = 1;
	GDKfree(var);
	if ( error ) {
		GDKfree(vec);
		return 0;
	}
	return vec;
}

/* prepare slicing a column  by addition over the target */
static int
OPTpreparePartition(MalBlkPtr nmb, InstrPtr p, Slices *slices)
{
	InstrPtr q;
	int parallel = 0;

	if ( slices->slice == 0){
		if (strcmp(slices->column, getVarConstant(nmb, getArg(p,4)).val.sval) ) 
			pushInstruction(nmb, p = copyInstruction(slices->target));
		slices->slice = newTmpVariable(nmb, getVarType(nmb, getArg(slices->target,0)));
		setVarUDFtype(nmb, slices->slice);
		setVarUsed(nmb, slices->slice);
		nmb->stmt[0] = pushArgument(nmb, nmb->stmt[0], slices->lslices);
		nmb->stmt[0] = pushArgument(nmb, nmb->stmt[0], slices->hslices);
		parallel=2;	/* return number of arguments added for later disposal */
	} 
	q= newInstruction(nmb,ASSIGNsymbol);
	/* add the slices->to the call */
	q= pushArgument(nmb,q, getArg(p,0));
	q= pushArgument(nmb,q, slices->lslices);
	q= pushArgument(nmb,q, slices->hslices);
	setModuleId(q,partitionRef);
	setFunctionId(q,materializeRef);
	getArg(q,0)= slices->slice;
	getArg(q,1) = getArg(p,0);
	pushInstruction(nmb,q);
	return parallel;
}

static int 
OPTsliceColumn(Client cntxt, MalBlkPtr nmb, MalBlkPtr mb, InstrPtr p, Slices *slices)
{
	int k, parallel = 0;
	InstrPtr q;

	(void) cntxt;
	if ( ! (getModuleId(p) == sqlRef && getFunctionId(p) == bindRef )  &&
		 ! (getModuleId(p) == sqlRef && getFunctionId(p) == bindidxRef ) )
		return 0;
	if ( ! (strcmp(slices->schema, getVarConstant(mb, getArg(p,2)).val.sval) == 0 &&
		strcmp(slices->table, getVarConstant(mb, getArg(p,3)).val.sval) == 0) )
		return 0;

	if ( slices->slice == 0)
		parallel =OPTpreparePartition(nmb, p, slices);

	if (strcmp(slices->column, getVarConstant(nmb, getArg(p,4)).val.sval) )   {
		/* sideways projection the range selection */
		q= newInstruction(nmb,ASSIGNsymbol);
		setModuleId(q,algebraRef);
		setFunctionId(q,semijoinRef);
		k = newTmpVariable(nmb, getVarType(mb, getArg(p,0)));
		setVarUDFtype(nmb,k);
		setVarUsed(nmb,k);
		getArg(q,0)= getArg(p,0);
		getArg(p,0)= k;
		q= pushArgument(nmb,q, k);
		q= pushArgument(nmb,q, slices->slice);
		pushInstruction(nmb,q);
	} else {
		/* it is the target itself */
		clrFunction(p);
		getArg(p,1) = slices->slice;
		p->argc =2;
	}
	return parallel;
} 

/* Gather the input for a variable by chasing its flow graph.
 * It is not allowed to depend on a blocking operation, such as new/done
 * It should be called for each variable considered 
*/
static MalBlkPtr
OPTgather(Client cntxt, MalBlkPtr mb, int pc, int varid, Slices *slices)
{
	MalBlkPtr gmb;
	InstrPtr p,sig;
	int i, parallel = 0;
	char nme[BUFSIZ];
	int *vec;
	Symbol s;
	str msg;
	Slices newslices = *slices;

	vec = OPTvarDependency( mb, pc, varid);
	if ( vec == 0 )
		return 0;

	snprintf(nme,BUFSIZ,"%s_bag_%d_%d",getFunctionId( getInstrPtr(mb,0)), pc,varid);
	s = newFunction(userRef, putName(nme, strlen(nme)),FUNCTIONsymbol);
	if ( s == NULL)
		return 0;
	freeMalBlk(s->def);
	s->def = copyMalBlk(mb);
	gmb = s->def;
	getFunctionId( getInstrPtr(gmb,0)) = putName(nme,strlen(nme));
	sig = getInstrPtr(gmb,0);
	getArg( sig,0) = varid;
	gmb->stop = 1;
	/* slices variables should be reset. */
	newslices.slice = 0;
	
	for( i = 1; i < pc; i++)
	if ( vec[i]) {
		p = copyInstruction(getInstrPtr(mb,i));
		pushInstruction(gmb, p);
		parallel = 0;
		if (getModuleId(p) == sqlRef && (getFunctionId(p) == bindRef || getFunctionId(p) == bindidxRef))  
			parallel = OPTsliceColumn(cntxt, gmb, mb, p, &newslices);
	}

	p = newInstruction(NULL,ASSIGNsymbol);
	p->barrier = RETURNsymbol;
	getArg(p,0) = varid;
	pushInstruction(gmb,p);

	for( ; i < mb->stop; i++)
	if ( getInstrPtr(mb,i)->token == ENDsymbol)
		break;
	for( ; i < mb->stop; i++)
		pushInstruction(gmb, copyInstruction(getInstrPtr(mb,i)));
	
#ifdef DEBUG_DETAIL
	mnstr_printf(cntxt->fdout,"#Bag for %d_%d\n",pc,varid);
	printFunction(cntxt->fdout, gmb, 0, LIST_MAL_STMT);
#endif
	chkProgram(cntxt->nspace, gmb);
	msg= optimizeMALBlock(cntxt, gmb);
#ifdef _DEBUG_OPT_PARTITION_
	mnstr_printf(cntxt->fdout,"#Bag errors:%s\n", (msg?msg:""));
	printFunction(cntxt->fdout, gmb, 0, LIST_MAL_STMT);
#endif
	GDKfree(vec);
	if ( msg || parallel ){
		GDKfree(gmb);
		if ( msg) GDKfree(msg);
		gmb = 0;
	}
	/* bounds may have been added, which are not needed in the remainder */
	getInstrPtr(gmb,0)->argc = getInstrPtr(mb,0)->argc;
	insertSymbol(cntxt->nspace,s);
	return gmb;
}

static int
OPTconsolidated(MalBlkPtr mb)
{
	int i;
	InstrPtr p;
	for( i =1 ; i < mb->stop; i++) {
		p = getInstrPtr(mb,i);
		if ( getFunctionId(p) && strstr(getFunctionId(p),"_cntrl_") )
			return 1;
	}

	return 0;
}

static InstrPtr
OPTcodegen(Client cntxt, MalBlkPtr mb, int pc, Slices slices, int aggrflag)
{
	char *vec = 0;
	int parallel = 0, last, i, k, limit;
	MalBlkPtr nmb = 0, smb = 0 , cmb = 0 ;
	InstrPtr ret, p,q,*old;
	Symbol s;
	char nme[BUFSIZ];
	str msg= MAL_SUCCEED;
	
	/* define the sub query as part of the user space */
	snprintf(nme,BUFSIZ,"%s_qry_%d",getFunctionId( getInstrPtr(mb,0)), pc);
	s = newFunction(userRef, putName(nme, strlen(nme)),FUNCTIONsymbol);
	if ( s == NULL)
		return 0;
	freeMalBlk(s->def);
	s->def = copyMalBlk(mb);
	nmb = s->def;
	getFunctionId( getInstrPtr(nmb,0)) = putName(nme,strlen(nme));
	/* slices variables should be reset. */
	slices.slice = 0;

	limit = nmb->stop;
	old = nmb->stmt;
	if ( newMalBlkStmt(nmb,nmb->ssize) < 0 )
		return 0;

	ret = newInstruction(NULL,ASSIGNsymbol);
	ret->barrier = RETURNsymbol;
	ret->argc = ret->retc =0;
	delArgument(old[0],0);	/* we dont need it */

	vec = OPTsliceDependency(mb, pc);
	for ( last = i = 0; i < limit; i++)
		if ( vec[i] ) 
			last = i;

	for ( i = 0; i < limit; i++) {
		p = old[i];
		if ( vec[i]) {
			if ( i == last) {
				if ( getFunctionId(old[i]) == resultSetRef) {
					for ( k = p->retc +3; k < p->argc; k++) {
						ret = pushReturn(nmb, ret, getArg(p,k));
						nmb->stmt[0] =  pushReturn(nmb, getInstrPtr(nmb,0), getArg(p,k));
					}
					p->argc = p->retc + 3;
					for ( k = p->retc-1; k > 0 ; k--)
						delArgument(p,1);
					continue;
				} else
				if ( getFunctionId(old[i]) == putName("exportValue",11)) {
					ret = pushReturn(nmb, ret, getArg(p,0));
				} else 
				if ( getModuleId(p)== groupRef && 
					( getFunctionId(p) == doneRef || getFunctionId(p) == newRef)){
					/* return alternative */
					ret = pushReturn(nmb,ret,getArg(p,p->retc));
					nmb->stmt[0] =  pushReturn(nmb, getInstrPtr(nmb,0), getArg(p,p->retc));
					continue;
				} else
				if ( getModuleId(p)== aggrRef &&  getFunctionId(p) == sumRef && p->argc == 2) {
					int ag, c, t;
					/* we will return a BAT with a result if the target was not empty */
					/* ag:= bat.new(:void,:lng) */
					q = newStmt(nmb,batRef,newRef);
					q = pushType(nmb,q, getHeadType(getArgType(mb,p,1)));
					q = pushType(nmb,q, getTailType(getArgType(mb,p,1)));
					ag = getArg(q,0);
					setVarType(nmb, ag, getArgType(mb,p,1));
					setVarUDFtype(nmb, ag);
					/* cnt:= aggr.count(B) */
					q = newStmt(nmb,aggrRef,countRef);
					q= pushArgument(nmb,q,getArg(p,1));
					t = getArg(q,0);
					/* barrier t:= cnt>0 */
					q = newStmt(nmb,calcRef,putName(">",1));
					q->barrier = BARRIERsymbol;
					q= pushArgument(nmb,q,t);
					q= pushInt(nmb,q,0);
					t = getArg(q,0);
					/* c:= aggr.sum(B); */
					q = newStmt(nmb,aggrRef,sumRef);
					q = pushArgument(nmb,q, getArg(p,1));
					c = getArg(q,0);
					/* bat.append(ag,c); */
					q = newStmt(nmb, batRef, appendRef);
					q = pushArgument(nmb, q, ag);
					q = pushArgument(nmb, q, c);
					/* exit t; */
					q = newAssignment(nmb);
					q->barrier = EXITsymbol;
					getArg(q,0) = t;
					/* return ag */
					ret = pushReturn(nmb, ret, ag);
					nmb->stmt[0] =  pushReturn(nmb, getInstrPtr(nmb,0), ag);
				} else {
					pushInstruction(nmb,old[i]);
					for ( k = 0; k < p->retc; k++) {
						ret = pushReturn(nmb, ret, getArg(p,k));
						nmb->stmt[0] =  pushReturn(nmb, getInstrPtr(nmb,0), getArg(p,k));
					}
				}
			} else  {
				pushInstruction(nmb,p);
				if (getModuleId(p) == sqlRef && (getFunctionId(p) == bindRef || getFunctionId(p) == bindidxRef))  
					parallel += OPTsliceColumn(cntxt, nmb, mb, p, &slices);
			}
		} else
		if ( p->token == ENDsymbol) {
			if(0) OPTcatchcode(nmb, aggrflag); /* pass all errors */
			pushInstruction(nmb,ret);
			pushEndInstruction(nmb);
			continue;
		}
		else if ( getModuleId(p) == optimizerRef)
			pushInstruction(nmb,old[i]);
		else {
			freeInstruction(old[i]);
			old[i] = 0;
		}
	}

	if ( parallel == 0 || (0 &&OPTconsolidated(nmb)) ){
		/* no partitioned column used or portions are already consolidated */
		if (vec) GDKfree(vec);
		freeMalBlk(nmb);
		return 0;
	}
	insertSymbol(cntxt->nspace,s);

	q = 0;

#ifdef DEBUG_DETAIL
	mnstr_printf(cntxt->fdout,"#nmb, CODEGEN BEFORE SUBS? %d\n", nmb->errors);
	if ( nmb)
		printFunction(cntxt->fdout, nmb, 0, LIST_MAL_STMT);
#endif
	/* supportive routines */
	smb = OPTpartitionStub(cntxt, mb, pc,  nmb, slices);
#ifdef DEBUG_DETAIL
	mnstr_printf(cntxt->fdout,"#smb,BEFORE test? %d\n", smb->errors);
	if ( smb)
		printFunction(cntxt->fdout, smb, 0, LIST_MAL_STMT);
#endif
	msg = OPTdeadcode(cntxt, smb, 0, 0);
	if ( msg)
		goto wrapup;

	cmb = OPTpartitionCntrl(cntxt,mb,pc,nmb, slices);
	chkProgram(cntxt->nspace, cmb);
#ifdef DEBUG_DETAIL
	mnstr_printf(cntxt->fdout,"#cntrl,AFTER test? %d\n", cmb->errors);
	if ( cmb)
		printFunction(cntxt->fdout, cmb, 0, LIST_MAL_STMT);
#endif
	if ( cmb->errors)
		goto wrapup;

	msg = OPTdeadcode(cntxt, nmb, 0, 0);
	if ( msg)
		goto wrapup;

#ifdef DEBUG_DETAIL
	mnstr_printf(cntxt->fdout,"#nmb,BEFORE test? %d\n", nmb->errors);
	if ( nmb)
		printFunction(cntxt->fdout, nmb, 0, LIST_MAL_STMT);
#endif
	chkProgram(cntxt->nspace, nmb);
	if ( nmb->errors)
		goto wrapup;
	/* beware, optimizer may reorder/relabel variables */
	msg= optimizeMALBlock(cntxt, nmb);
	if ( msg)
		goto wrapup;

	q = copyInstruction(getInstrPtr(cmb,0));
	q->barrier = 0;
	q->token = ASSIGNsymbol;
	q->argc = mb->stmt[0]->argc - mb->stmt[0]->retc + q->retc; /* get rid of temporary arguments */
	cmb->stmt[0]->argc = mb->stmt[0]->argc - mb->stmt[0]->retc + q->retc; /* get rid of temporary arguments */
	/* beware this instruction refers to cmb variables */
wrapup:
#ifdef _DEBUG_OPT_PARTITION_
	mnstr_printf(cntxt->fdout,"#Grabbed part, nmb error ? %d\n",nmb->errors);
	if ( nmb)
		printFunction(cntxt->fdout, nmb, 0, LIST_MAL_STMT);
	mnstr_printf(cntxt->fdout,"#stub, smb error ? %d\n", smb->errors);
	if ( smb)
		printFunction(cntxt->fdout, smb, 0, LIST_MAL_STMT);
	mnstr_printf(cntxt->fdout,"#cntrl, cmb error? %d\n", cmb->errors);
	if ( cmb)
		printFunction(cntxt->fdout, cmb, 0, LIST_MAL_STMT);
#endif

	if (vec) GDKfree(vec);
	return q;
}

static void
remapVariable( MalBlkPtr mb, int i, int old, int new)
{
	InstrPtr p;
	int k;

	for( ; i< mb->stop; i++){
		p= getInstrPtr(mb,i);
		for ( k = 0; k < p->argc; k++)
		if ( getArg(p,k) == old)
			getArg(p,k) = new;
	}
}

static int
OPTgatherArgs(Client cntxt, MalBlkPtr mb, InstrPtr p, int i, Slices *slices)
{
	MalBlkPtr gmb;
	InstrPtr q, sig = getInstrPtr(mb,0);
	int hits = 0;
	int j,k;

	for ( j = p->retc; j < p->argc; j++)
	if ( isaBatType(getArgType(mb,p,j)) ){
		gmb = OPTgather(cntxt,mb,i, getArg(p,j), slices);
		if ( gmb ) {
			q= newInstruction(mb, ASSIGNsymbol);
			getModuleId(q) = userRef;
			getFunctionId(q) = getFunctionId(getInstrPtr(gmb,0));
			getArg(q,0) = getArg(p,j);
			for ( k =sig->retc; k < sig->argc; k++)
				q= pushArgument(mb,q, getArg(sig,k));
			insertInstruction(mb,q,i);
			k = newTmpVariable(mb, getArgType(mb,q,0));
			remapVariable(mb, i, getArg(p,j), k);
			hits++;
		}
	}
	return hits;
} 
static int
OPTpartitionImplementation(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	int i,j,k,pc = 0;
	wrd r = 0, rowcnt=0;	/* table should be sizeable to consider parallel execution*/
	InstrPtr p,q, target= 0, rsset=0;
	Slices slices;
	str msg = NULL;
	MalBlkPtr  omb;
	char *vec;
	int	*alias;
	int parallel = TRUE;	/* stop parallel execution when we have reconstructed the db */

	(void)cntxt;
	(void) stk;
	(void) pci;

	msg = GDKgetenv("gdk_readonly");
	if( msg == 0 || strcmp(msg,"yes"))
		mnstr_printf(cntxt->fdout,"#WARNING centipede only works for readonly databases\n");
    /* nrpeers = GDKnr_threads ? GDKnr_threads:1;*/
	/* to ease debugging now */
	nrpeers = 2;
	slicingLocal = 1;

	/* modify the block as we go */
	omb= copyMalBlk(mb);
	memset((char*) &slices,0, sizeof(slices));
	/* locate the largest non-partitioned table */
	for (i=1; i< mb->stop; i++){
		q= getInstrPtr(mb,i);
		if ( ! (getModuleId(q) == sqlRef && getFunctionId(q) == bindRef ) )
			continue;
		/* don't split insert BATs */
		if (getVarConstant(mb, getArg(q,5)).val.ival != 0 )
			continue;
		r = getVarRows(mb, getArg(q, 0));
		if (r >= rowcnt && getTailType( getArgType(mb,q,0)) <= TYPE_str){
			rowcnt = r;
			target = q;
			r = 0;
		}
	}
	if (target == 0)
		return 0;

	/* for the time being assume one target colum */
	slices.target = target;
	slices.schema = GDKstrdup(getVarConstant(mb, getArg(target,2)).val.sval);
	slices.table = GDKstrdup(getVarConstant(mb, getArg(target,3)).val.sval);
	slices.type = getTailType(getVarType(mb,getArg(target,0)));
	slices.lslices=  newTmpVariable(mb, slices.type);
	slices.hslices=  newTmpVariable(mb, slices.type);
	slices.column = GDKstrdup(getVarConstant(mb,getArg(target,4)).val.sval);
	slices.slice = 0;

	/* for result sets we have to collect the arguments of the rsColumn */
	/* gather all columns into the resultSet constructor to ease code generation */
	/* be aware that the resultSet already has three arguments */
	/* be careful with first result column */
	for (i=1; i< mb->stop; i++){
		q= getInstrPtr(mb,i);
		if ( getModuleId(q) == sqlRef) {
			if ( getFunctionId(q) == resultSetRef)
				rsset= copyInstruction(q);
			if ( getFunctionId(q) == rsColumnRef) {
				assert(rsset != NULL);
				/* j = newTmpVariable(mb, getArgType(mb,q,7));
				rsset= pushReturn(mb,rsset, j); */
				rsset= pushReturn(mb,rsset, j = getArg(q,7));
				rsset= pushArgument(mb,rsset, getArg(q,7));
				getArg(q,7) = j;
			}
		}
	}
#ifdef DEBUG_DETAIL
	if ( rsset) {
		mnstr_printf(cntxt->fdout,"#replaced resultSet constructor\n");
		printInstruction(cntxt->fdout, mb, 0, rsset, LIST_MAL_STMT);
	}
#endif

	OPTDEBUGpartition
		mnstr_printf(cntxt->fdout,"#opt_partition: target is %s.%s "
			" with " SSZFMT " rows into %d peers\n",
				getVarConstant(mb, getArg(slices.target,2)).val.sval,
				getVarConstant(mb, getArg(slices.target,3)).val.sval,
				rowcnt, nrpeers);

	/* reserve space for all exisiting and new variables */
	alias= (int*) GDKzalloc(sizeof(int) * 2 * mb->vsize);

	for(i=0; i < mb->stop; i++){
		p= getInstrPtr(mb,i);


		if ( getModuleId(p) == sqlRef && getFunctionId(p) == resultSetRef ) {
			if ( parallel) {
				mb->stmt[i]  = rsset;
				q = OPTcodegen(cntxt, mb, i, slices, FALSE);
				parallel = FALSE;
			} else q = 0;
			if ( q ) {
				clrFunction(rsset);
#ifdef DEBUGDETAILS
				mnstr_printf(cntxt->fdout, "#codegenerated resultSet constructor\n");
				printInstruction(cntxt->fdout, mb, 0, q, LIST_MAL_STMT);
#endif
				getModuleId(rsset) = userRef;
				getFunctionId(rsset) = getFunctionId(q);
				delArgument(rsset,0);
				/* now drop the column arguments added and pass the additional argument */
				rsset->argc = rsset->retc;
				getArg(p,3) = getArg(rsset,0);
				/* add original arguments to cntrl call */
				q = getInstrPtr(mb,0);
				for( j = q->retc; j < q->argc; j++)
					mb->stmt[i] = pushArgument(mb, mb->stmt[i], getArg(q,j));
				insertInstruction(mb,p,i+1);
				/* remap the other result variables as well */
				for ( k = 0; k < rsset->retc; k++) {
					j = newTmpVariable(mb, getArgType(mb,rsset,k));
					remapVariable(mb, i, getArg(rsset,k), j);
					getArg(rsset,k) = j;
				}
				i++;
				msg = OPTdeadcode(cntxt, mb, 0, 0);
				if ( msg )
					mnstr_printf(cntxt->fdout,"codegen deadcode %s\n",msg);
			} else {
				/* gather arguments */
				mb->stmt[i] = p;
				i += OPTgatherArgs(cntxt,mb,p,i, &slices);
				freeInstruction(rsset);
				rsset = NULL;
			}
			continue;
		}

		if ( getModuleId(p) == sqlRef && getFunctionId(p) == putName("exportValue",11)) {
			q = OPTcodegen(cntxt, mb, i, slices, FALSE);
			parallel = FALSE;
			if ( q ) {
				getArg(p,8) = getArg(q,0);
				freeInstruction(q);
				msg = OPTdeadcode(cntxt, mb, 0, 0);
				if ( msg )
					mnstr_printf(cntxt->fdout,"codegen deadcode %s\n",msg);
			}
			continue;
		}

		if ( getModuleId(p) == aggrRef && p->argc ==2 ) {
			q = OPTcodegen(cntxt, mb, i, slices, TRUE);
			if ( q ) {
				clrFunction(p);
				getModuleId(p) = userRef;
				getFunctionId(p) = getFunctionId(q);
				p->argc = p->retc;
				freeInstruction(q);
				/* add original arguments to cntrl call */
				q = getInstrPtr(mb,0);
				for( j = q->retc; j < q->argc; j++)
					mb->stmt[i] = pushArgument(mb, mb->stmt[i], getArg(q,j));
				msg = OPTdeadcode(cntxt, mb, 0, 0);
				if ( msg )
					mnstr_printf(cntxt->fdout,"codegen deadcode %s\n",msg);
				continue;
			}
		}
		if ( getModuleId(p) == aggrRef && p->argc == 4 ) {
			/* grouped aggregation */
			i += OPTgatherArgs(cntxt,mb,p,i, &slices);
			continue;
		}
		/* grouping for now is a blocking instruction */
		if ( getModuleId(p) == groupRef && 
			(getFunctionId(p) == doneRef || getFunctionId(p) == newRef) &&
			alias[getArg(p,3)] == 0) {
			/* except consolidated input arguments */
			if ( parallel ) 
			{	/* database not yet consolidated */
				q = OPTcodegen(cntxt, mb, i, slices, FALSE);
				parallel = FALSE;
				if ( q ) {
					j = newTmpVariable(mb, getArgType(mb,q,0));
					remapVariable(mb, i, getArg(p,p->retc), j);
					alias[getArg(p,p->retc)] = j;
					getArg(q,0) = getArg(p,p->retc) = j;
					q->argc = getInstrPtr(mb,0)->argc - getInstrPtr(mb,0)->retc + q->retc;
					insertInstruction(mb,q,i);
#ifdef DEBUG_DETAIL
					mnstr_printf(cntxt->fdout,"#done instruction BEFORE deadcode test\n");
					printFunction(cntxt->fdout, mb, 0, LIST_MAL_STMT);
#endif
					msg = OPTdeadcode(cntxt, mb, 0, 0);
					if ( msg )
						mnstr_printf(cntxt->fdout,"codegen deadcode %s\n",msg);
					i++;
					continue;
				}
			} else 
				i += OPTgatherArgs(cntxt,mb,p,i, &slices);
		}
		if ( p->token == ENDsymbol)
			pc = i -1;
	}
	if ( pc ){
		vec = OPTsliceDependency(mb, pc);
		for ( i = 0; i< pc; i++)
		if ( vec[i] == 0)
			getInstrPtr(mb,i)->token = NOOPsymbol;
		GDKfree(vec);
	}
#ifdef _DEBUG_OPT_PARTITION_
#ifdef DEBUG_DETAIL
	mnstr_printf(cntxt->fdout,"#orig BEFORE deadcode test\n");
	printFunction(cntxt->fdout, mb, 0, LIST_MAL_STMT);
#endif
	msg= optimizeMALBlock(cntxt, mb);
	mnstr_printf(cntxt->fdout,"#partition %s.%s.%s type %d %s\n",
		slices.schema,
		slices.table,
		(slices.column ? slices.column: ""),
		slices.type,
		msg?msg:"");
	printFunction(cntxt->fdout, mb, 0, LIST_MAL_STMT);
#endif
	GDKfree(slices.schema);
	GDKfree(slices.table);
	if (msg || mb->errors ) {
		/* restore MAL block */
		mnstr_printf(cntxt->fdout,"#partition %s\n", msg?msg:"generic error");
		/* freeMalBlk(mb);*/
		*mb = *omb;
		GDKfree(alias);
		return 0;
	}
	return 1;
}
@include optimizerWrapper.mx
@c
#include "opt_statistics.h"
#include "algebra.h"
@:wrapOptimizer(partition,OPT_CHECK_ALL)@

/*
 * @-
 */
@= histo
	{ @1 *vv;
		vv= (@1 *) getArgReference(stk, pci, 0 );
		*vv = @1_nil;
		vx = (ptr) &max.val.@2;
		BATmax(b, vx);
		vv= (ptr) getArgReference(stk, pci, pci->retc -1 );
		*vv = @1_nil;
		vm = (ptr) &min.val.@2;
		BATmin(b, vm);
		step.val.@2 = (max.val.@2 - min.val.@2) / (pci->retc - 2);
		if ( step.val.@2 == 0)
				step.val.@2 = max.val.@2;
		for ( i = 1; i < pci->retc-1; i++) {
			vx= (ptr) getArgReference(stk, pci, i );
			((ValPtr) vx ) ->val.@2 = min.val.@2 + i * step.val.@2;
		}
	}
@
@c
/* determine the initial slices values */
/* the min/max bounds are null values */
/* It is the heart of the approach and requires experimentation */
str
OPTvector(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{	
	BAT *b;
	int bid = *(int*) getArgReference(stk,pci, pci->argc-1);
	ValRecord min,max, step;
	int i, j;
	ptr vx,vm;

	(void) cntxt;
	(void) mb;
	if ( pci->retc < 2)
		throw(SQL,"sql.partition","Not enough slices");
	b = BATdescriptor(bid);
	if (b == NULL)
		throw(SQL,"sql.partition","Can not access BAT");
    switch ( ATOMtype(b->ttype)) {
    case TYPE_bit: @:histo(bit,cval[0])@ break;
    case TYPE_chr: @:histo(chr,cval[0])@ break;
    case TYPE_bte: @:histo(bte,btval)@ break;
    case TYPE_sht: @:histo(sht,shval)@ break;
    case TYPE_int: @:histo(int,ival)@ break;
    case TYPE_wrd: @:histo(wrd,wval)@ break;
    case TYPE_lng: @:histo(lng,lval)@ break;
    case TYPE_oid: @:histo(oid,oval)@ break;
    case TYPE_flt: @:histo(flt,fval)@ break;
    case TYPE_dbl: @:histo(dbl,dval)@ break;
	case TYPE_str:
		/* fake split, ignore the data distribution */

		j = pci->retc > 26 ?26 : pci->retc;
		for ( i = 1; i < pci->retc-1; i++) {
			char buf[BUFSIZ];
			snprintf(buf,BUFSIZ,"%c", 'a' + 26 / j);
			vx= (ptr) getArgReference(stk, pci, i );
			*(str*)vx = GDKstrdup(buf);
		}
		break;
	default:
		throw(SQL,"sql.slices","Can not slice column ");
    }

	BBPreleaseref(bid);
	return MAL_SUCCEED;
}
/* overload the select operator such as to return a NIL instead of an empty BAT */
str OPTpartitionMaterialize(int *result, int *bid, ptr low, ptr high)
{
	bit bitlow=TRUE, bithigh= FALSE;

	return ALGselectInclusive( result, bid, low, high, &bitlow, &bithigh);
}

opt_export str OPTmarkHead(int *result, int *bid)
{
	oid base = 0;
	if ( *bid == 0){
		*result = 0;
		return MAL_SUCCEED;
	}
	return ALGmarkHead(result,bid, &base);
}
