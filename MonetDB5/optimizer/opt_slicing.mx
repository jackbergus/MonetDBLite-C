@/
The contents of this file are subject to the MonetDB Public License
Version 1.1 (the "License"); you may not use this file except in
compliance with the License. You may obtain a copy of the License at
http://www.monetdb.org/Legal/MonetDBLicense

Software distributed under the License is distributed on an "AS IS"
basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations
under the License.

The Original Code is the MonetDB Database System.

The Initial Developer of the Original Code is CWI.
Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
Copyright August 2008-2011 MonetDB B.V.
All Rights Reserved.
@
Use a single gauge structure to split the largest table.
@f opt_slicing
@a M. Kersten
@- Slicing
@{
@mal
pattern optimizer.slicing():str
address OPTslicing;
pattern optimizer.slicing(mod:str, fcn:str):str
address OPTslicing
comment "Modify the plan to exploit parallel processing on multiple cores";

pattern sql.gauges(b:bat[:oid,:any_1]) :any_1...
address OPTgauges
comment "Derive a series of gauge values based on sampling";
@h
#ifndef _OPT_SLICING_
#define _OPT_SLICING_
#include "opt_prelude.h"
#include "opt_support.h"

#define MAXSITES 4		/* to be refined */
@:exportOptimizer(slicing)@

opt_export str OPTgauges(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);

/* #define _DEBUG_OPT_SLICE_ */
#define OPTDEBUGslicing  if ( optDebug & ((lng)1 <<DEBUG_OPT_SLICING) )
#endif
@c
#include "monetdb_config.h"
#include "opt_slicing.h"
#include "opt_deadcode.h"
#include "mal_builder.h"
#include <mapi.h>
#include "remote.h"
#include "mal_sabaoth.h"
#include "mal_recycle.h"

#include "mal_interpreter.h"

typedef struct REGMAL{
    str fcn;
    struct REGMAL *nxt;
} *Registry;

typedef struct {
    str uri;
    str usr;
    str pwd;
    Registry nxt; /* list of registered mal functions */
    bte active;
    str conn;
    int inuse;
} Peer;

static Peer peers[MAXSITES];    /* registry of peer servers */
static int nrpeers;				/* peers active in sliced processing */
static bte slicingLocal;		/* only use local node without remote calls*/

typedef	struct{
	InstrPtr target;
	str schema, table, column;
	int type, slice;	
	int lgauge, hgauge;
	ValRecord bounds[MAXSITES];
} Gauge;

static int
OPTfindPeer(str uri)
{
    int i;
    for (i = 0; i < nrpeers; i++)
        if ( strcmp(uri, peers[i].uri) == 0 )
            return i;
    return -1;
}
/* Look for and add a peer with uri in the registry.  Return index in registry */
int
OPTgetPeer(str uri)
{
	int i;

	i = OPTfindPeer(uri);
	if ( i >=0 ) {
		peers[i].active = 1;
		return i;
	}
	if ( nrpeers == MAXSITES)
		return -1;
	i = nrpeers;
	peers[i].usr = GDKstrdup("monetdb");
	peers[i].uri = GDKstrdup(uri);
	peers[i].pwd = GDKstrdup("monetdb");
	peers[i].active = 1;
	peers[i].nxt = NULL;
	peers[i].inuse = 0;		
	nrpeers++;
	return i;
}

/* Clean function registry of non-active peers */

void OPTcleanFunReg(int i)
{	
	Registry r, q;
	mal_set_lock(mal_contextLock,"slicing.cleanFunReg");
	r = peers[i].nxt;
	peers[i].nxt = NULL;
	mal_unset_lock(mal_contextLock,"slicing.cleanFunReg");
	while ( r ) {
			q = r->nxt;
			GDKfree(r->fcn);
			GDKfree(r);
			r = q;
	}
}

str
OPTdiscover(Client cntxt)
{
	bat bid = 0;
	BAT *b;
	BUN p,q;
	str msg = MAL_SUCCEED;
	BATiter bi;
	char buf[BUFSIZ]= "*/slicing", *s= buf;
	int i, nrworkers = 0;

	slicingLocal = 0;

	/* we have a new list of candidate peers */
	for (i=0; i<nrpeers; i++)
		peers[i].active = 0;

	msg = RMTresolve(&bid,&s);
	if ( msg == MAL_SUCCEED) {
		b = BATdescriptor(bid);
		if ( b != NULL && BATcount(b) > 0 ) {
			bi = bat_iterator(b);
			BATloop(b,p,q){
				str t= (str) BUNtail(bi,p);
				nrworkers += OPTgetPeer(t) >= 0; 
			}
		}
		BBPreleaseref(bid);
	} else
		GDKfree(msg);

	if ( !nrworkers  ) {
	 	/* there is a last resort, local execution */
		SABAOTHgetLocalConnection(&s);
	
		nrworkers += OPTgetPeer(s) >= 0;
		slicingLocal = 1; 
	}

#ifdef DEBUG_RUN_OPT
	mnstr_printf(cntxt->fdout,"Active peers discovered %d\n",nrworkers);
	for (i=0; i<nrpeers; i++)
	if ( peers[i].uri )
		mnstr_printf(cntxt->fdout,"%s\n", peers[i].uri);
#else
		(void) cntxt;
#endif

	for (i=0; i<nrpeers; i++)
		if ( !peers[i].active )
			OPTcleanFunReg(i);

	return MAL_SUCCEED;
}
static int
OPTinitcode(Client cntxt, MalBlkPtr mb){
    InstrPtr p;
    str s;
    str l = NULL;

    (void) cntxt;

    /* _x := remote.connect(uri,"monetdb","monetdb","msql"); */
    p = newStmt(mb, remoteRef,connectRef);
    s = GDKgetenv("merovingian_uri");
    if (s == NULL) /* aparently not under Merovingian control, fall back to local only */
        SABAOTHgetLocalConnection(&l);
    p= pushStr(mb,p, s == NULL ? l : s);
    p= pushStr(mb,p,"monetdb");
    p= pushStr(mb,p,"monetdb");
    p= pushStr(mb,p,"msql");
    if (l)
        GDKfree(l);
    return getArg(p,0);
}

static MalBlkPtr
OPTslicingStub(Client cntxt, MalBlkPtr mb, int pc, MalBlkPtr pmb, Gauge gauge)
{
	MalBlkPtr smb = 0;
	Symbol s;
	InstrPtr sig, q, ret;
	int j,k,conn, *arg;
	char nme[BUFSIZ];
	(void) gauge;

	/* define the sub query stub for remote processing */
	snprintf(nme,BUFSIZ,"%s_stub%d",getFunctionId( getInstrPtr(mb,0)), pc);
	s = newFunction(userRef, putName(nme, strlen(nme)),FUNCTIONsymbol);
	if ( s == NULL)
		return 0;
	freeMalBlk(s->def);
	s->def = copyMalBlk(pmb);	/* get variables */
	smb = s->def;
	if ( newMalBlkStmt(smb,smb->ssize) < 0 )
		return 0;
	pushInstruction(smb, copyInstruction(pmb->stmt[0]));
	getFunctionId( getInstrPtr(smb,0)) = putName(nme,strlen(nme));
	insertSymbol(cntxt->nspace,s);

	conn = OPTinitcode(cntxt,smb);
	sig = getInstrPtr(smb,0);
	arg = (int*) GDKzalloc(sizeof(int) * sig->argc);
	/* k:= remote.put(conn,kvar) */
	for (j= sig->retc; j < sig->argc; j++) {
		q= newFcnCall(smb,remoteRef,putRef);
		setVarType(smb, getArg(q,0), TYPE_str);
		setVarUDFtype(smb, getArg(q,0));
		q= pushArgument(smb,q,conn);
		q= pushArgument(smb,q,getArg(sig,j));
		arg[j]= getArg(q,0);
	}

	/* (k1,...kn):= remote.exec(conn,slicing,qry,version....) */
	snprintf(nme,BUFSIZ,"%s_sub",getFunctionId( getInstrPtr(mb,0)));
	q= newFcnCall(smb,remoteRef,execRef);
	q->retc=  q->argc= 0;
	for (j=0; j < sig->retc; j++){
		arg[j]= newTmpVariable(smb,TYPE_str);
		q = pushReturn(smb,q,arg[j]);
	}
	q= pushArgument(smb,q,conn);
	q= pushStr(smb,q,userRef);
	q= pushStr(smb,q,putName(nme,strlen(nme)));
	/* deal with all arguments ! */
	for (j=sig->retc; j < sig->argc; j++)
		q = pushArgument(smb,q,arg[j]);

	/* return exec_qry; */
	ret = newInstruction(smb, ASSIGNsymbol);
	ret->barrier= RETURNsymbol;
	ret->argc = ret->retc = 0;
	/* l:=remote.get(conn,k) */
	for ( j=0; j< sig->retc; j++){
		q= newFcnCall(smb,remoteRef,getRef);
		q= pushArgument(smb,q,conn);
		q= pushArgument(smb,q,arg[j]);
		k= getArg(q,0);
		setVarType(smb,k, getArgType(smb,sig,j));
		setVarUDFtype(smb, k);
		ret = pushArgument(smb,ret,k);
		ret = pushReturn(smb,ret,getArg(sig,j));
	}

    newCatchStmt(smb, "ANYexception");
    q = newStmt(smb, remoteRef, disconnectRef);
    pushArgument(smb, q, conn);
    newRaiseStmt(smb, "ANYexception");   /* pass to caller */
    newExitStmt(smb, "ANYexception");

    q = newStmt(smb, remoteRef, disconnectRef);
    pushArgument(smb, q, conn);
	pushInstruction(smb,ret);
    pushEndInstruction(smb);

	GDKfree(arg);
	return smb;
}

static MalBlkPtr
OPTslicingCntrl(Client cntxt, MalBlkPtr mb, int pc, MalBlkPtr pmb, Gauge gauge)
{
	MalBlkPtr cmb;
	Symbol s;
	char nme[BUFSIZ];
	int /*tpe,*/ x, i, j, k, *alias, nrpack;
	InstrPtr call, ret, q, *pack;

	(void) gauge;
	/* define the query controller */
	snprintf(nme,BUFSIZ,"%s_cntrl%d",getFunctionId( getInstrPtr(mb,0)),pc);
	s = newFunction(userRef, putName(nme, strlen(nme)),FUNCTIONsymbol);
	if ( s == NULL)
		return 0;
	freeMalBlk(s->def);
	s->def = copyMalBlk(pmb);	/* get variables */
	cmb = s->def;
	if ( newMalBlkStmt(cmb,cmb->ssize) < 0 )
		return 0;
	nrpack = getInstrPtr(mb,pc)->retc;
	pack = (InstrPtr *) GDKzalloc(sizeof(InstrPtr) * nrpack);
	pushInstruction(cmb, copyInstruction(pmb->stmt[0]));
	call = copyInstruction(getInstrPtr(pmb,0));
	cmb->stmt[0]->argc -= 2;	/* no bounds */
	getFunctionId( getInstrPtr(cmb,0)) = putName(nme,strlen(nme));
	insertSymbol(cntxt->nspace,s);

	/* initialize binds and histograms */
	q= newFcnCall(cmb, sqlRef, mvcRef);
	x= getArg(q,0);
	alias = (int*) GDKzalloc(nrpeers * sizeof(int));
	if( gauge.column) {
		q= newInstruction(cmb, ASSIGNsymbol);
		getModuleId(q) = sqlRef;
		getFunctionId(q) = bindRef;
		q = pushArgument(cmb,q,x);
		j = getArg(q,0) = newTmpVariable(cmb,newBatType(TYPE_oid, gauge.type));
		q= pushStr(cmb,q, gauge.schema);
		q= pushStr(cmb,q, gauge.table);
		q= pushStr(cmb,q, gauge.column);
		q= pushInt(cmb,q, 0);
		pushInstruction(cmb,q);

		q= newInstruction(cmb, ASSIGNsymbol);
		getModuleId(q) = sqlRef;
		getFunctionId(q) = putName("gauges",6);
		q = pushArgument(cmb, q, j);
		for ( j = 0; j < nrpeers +1; j++) {
			k = alias[j] = newTmpVariable(cmb, gauge.type);
			q= pushReturn(cmb,q, k);
		}
		pushInstruction(cmb,q);
	}
	/* dataflow */
	if ( gauge.column) {
		for ( k = 0; k < nrpack ; k++){
			pack[k] = newInstruction(cmb,ASSIGNsymbol);
			getModuleId(pack[k]) = matRef;
			getFunctionId(pack[k]) = packRef;
			getArg(pack[k],0) = newTmpVariable(cmb, newBatType(TYPE_oid, getTailType(getArgType(cmb,getInstrPtr(pmb,0),k))) );
		}
	}

	for ( k = 0; k < nrpack ; k++){
		q = newInstruction(cmb,ASSIGNsymbol);
		getArg(q,0) = getArg(pack[k],0);
		pushNil(cmb,q, getArgType(cmb,pack[k],0));
		pushInstruction(cmb,q);
	}

	if ( slicingLocal == 0){
		q= newFcnCall(cmb,languageRef,dataflowRef);
		q->barrier= BARRIERsymbol;
		x = getArg(q,0);
		setVarType(cmb,x,TYPE_int);
	}

	/* tpe = getArgType( pmb, getInstrPtr(pmb,0),0); */

	for ( i = 0; i < nrpeers ; i++) {
		q= copyInstruction(call);
		q->token = ASSIGNsymbol;
		q->barrier = 0;
		for ( k = 0; k < q->retc; k++) {
			getArg(q,k) = newTmpVariable(cmb, getArgType(mb,q,k));
			pack[k] = pushArgument(cmb,pack[k], getArg(q,k));
		}

		if ( gauge.column){
			getArg(q, q->argc-2 ) = alias[i];
			getArg(q, q->argc-1) = alias[i+1];
		}
		pushInstruction(cmb,q);
	}
	if ( gauge.column) 
	for ( k = 0; k < nrpack; k++)
		pushInstruction(cmb, pack[k]);


	if ( slicingLocal == 0){
		q= newAssignment(cmb);
		q->barrier = EXITsymbol;
		getArg(q,0) = x;
	}

	q = copyInstruction(getInstrPtr(mb,pc));
	if ( getFunctionId(q) == countRef) {
		getFunctionId(q) = sumRef;
		getArg(q,1) = getArg(pack[0],0);
	} else 
	if ( getFunctionId(q) == putName("exportValue",11)) 
		getArg(q,8)= getArg(pack[0],0);
	else
	if ( getFunctionId(q) == NULL){
		/* simple assignment */
		assert(nrpack == q->retc);
		for( k = 0; k < nrpack; k++)
			getArg(q, q->retc + k) = getArg(pack[k],0);
	}
	
	pushInstruction(cmb,q);

	ret = newInstruction(NULL,ASSIGNsymbol);
	ret->barrier = RETURNsymbol;
	ret->argc = ret->retc =0;
	for( i = 0 ; i< q->retc; i++)
		ret = pushReturn(cmb,ret,getArg(q,i));
	pushInstruction(cmb,ret);

	pushEndInstruction(cmb);
	GDKfree(alias);
	GDKfree(pack);

	return cmb;
}

static char *
OPTsliceDependency(Client cntxt, MalBlkPtr mb, int pc)
{
	char *vec;
	char *var;
	int i, j, fnd;
	InstrPtr p;

	(void) cntxt;
	vec= (char*) GDKzalloc(mb->ssize * 2);
	if( vec == 0)
		return 0;
	var= (char*) GDKzalloc(mb->vsize * 2);
	if ( var == 0)
		return 0;

	p= getInstrPtr(mb,pc);
	for ( i = p->retc; i < p->argc; i++)
		var[getArg(p,i)] = 1;
	vec[pc] = 1;
	for ( i = pc -1; i >= 0; i--){
		p = getInstrPtr(mb,i);
		fnd = 0;
		for ( j = 0; j < p->argc; j++)
			fnd += var[getArg(p,j)];
		if ( fnd){
			vec[i] = 1;
			for( j = 0; j< p->argc; j++)
				var[getArg(p,j)] = 1;
		}
	}
	vec[0] = 1;
	GDKfree(var);
	return vec;
}

static InstrPtr
OPTcodegen(Client cntxt, MalBlkPtr mb, int pc, Gauge gauge )
{
	char *vec = 0;
	int parallel = 0, last, i, k, limit;
	MalBlkPtr nmb = 0, smb = 0 , cmb = 0 ;
	InstrPtr ret, p,q,*old;
	Symbol s;
	char nme[BUFSIZ];
	str msg= MAL_SUCCEED;
	
	/* define the sub query as part of the user space */
	snprintf(nme,BUFSIZ,"%s_qry%d",getFunctionId( getInstrPtr(mb,0)), pc);
	s = newFunction(userRef, putName(nme, strlen(nme)),FUNCTIONsymbol);
	if ( s == NULL)
		return 0;
	freeMalBlk(s->def);
	s->def = copyMalBlk(mb);
	nmb = s->def;
	getFunctionId( getInstrPtr(nmb,0)) = putName(nme,strlen(nme));

	limit = nmb->stop;
	old = nmb->stmt;
	if ( newMalBlkStmt(nmb,nmb->ssize) < 0 )
		return 0;

	ret = newInstruction(NULL,ASSIGNsymbol);
	ret->barrier = RETURNsymbol;
	ret->argc = ret->retc =0;
	delArgument(old[0],0);	/* we dont need it */

	vec = OPTsliceDependency(cntxt, mb, pc);
	for ( last = i = 0; i < limit; i++)
		if ( vec[i] ) 
			last = i;

	/* reset the column admin */
	if ( gauge.column)
		GDKfree(gauge.column);
	gauge.column = 0;

	for ( i = 0; i < limit; i++) {
		p = old[i];
		if ( vec[i]) {
			if ( i == last) {
				if ( getFunctionId(old[i]) == rsColumnRef) {
					ret = pushReturn(nmb, ret, getArg(p,7));
					nmb->stmt[0] =  pushReturn(nmb, getInstrPtr(nmb,0), getArg(p,7));
					continue;
				} else 
				if ( getFunctionId(old[i]) == putName("exportValue",11)) {
					ret = pushReturn(nmb, ret, getArg(p,0));
				} else {
					pushInstruction(nmb,old[i]);
					for ( k = 0; k < p->retc; k++) {
						ret = pushReturn(nmb, ret, getArg(p,k));
						nmb->stmt[0] =  pushReturn(nmb, getInstrPtr(nmb,0), getArg(p,k));
					}
				}
			} else
				pushInstruction(nmb,old[i]);

			if ( ! (getModuleId(p) == sqlRef && getFunctionId(p) == bindRef ) )
				continue;
			if ( ! (strcmp(gauge.schema, getVarConstant(nmb, getArg(p,2)).val.sval) == 0 &&
				strcmp(gauge.table, getVarConstant(nmb, getArg(p,3)).val.sval) == 0) )
				continue;

			if ( gauge.column == 0) {
				gauge.column = GDKstrdup(getVarConstant(nmb,getArg(p,4)).val.sval);
				gauge.type = getTailType(getVarType(nmb,getArg(p,0)));
				gauge.lgauge =  newTmpVariable(nmb, gauge.type);
				gauge.hgauge =  newTmpVariable(nmb, gauge.type);
				/* temporary extend signature with bounds */
				nmb->stmt[0] =  pushArgument(nmb,getInstrPtr(nmb,0), gauge.lgauge);
				nmb->stmt[0] =  pushArgument(nmb,getInstrPtr(nmb,0), gauge.hgauge);
			}
			
			if (strcmp(gauge.column, getVarConstant(nmb, getArg(p,4)).val.sval) == 0) {
				/* add the slice operation */
				parallel = 1;
				q= newInstruction(nmb,ASSIGNsymbol);
				setModuleId(q,algebraRef);
				setFunctionId(q,selectRef);
				gauge.slice = k = newTmpVariable(nmb, getVarType(nmb, getArg(p,0)));
				setVarUDFtype(nmb,k);
				setVarUsed(nmb,k);
				getArg(q,0)= getArg(p,0);
				getArg(p,0)= k;
				/* add the gauge to the call */
				q= pushArgument(nmb,q, getArg(p,0));
				q= pushArgument(nmb,q, gauge.lgauge);
				q= pushArgument(nmb,q, gauge.hgauge);
				q= pushBit(nmb,q, TRUE);
				q= pushBit(nmb,q, FALSE);
				pushInstruction(nmb,q);
			} else {
				/* sideways projection the range selection */
				q= newInstruction(nmb,ASSIGNsymbol);
				setModuleId(q,algebraRef);
				setFunctionId(q,semijoinRef);
				k = newTmpVariable(nmb, getVarType(nmb, getArg(p,0)));
				setVarUDFtype(nmb,k);
				setVarUsed(nmb,k);
				getArg(q,0)= getArg(p,0);
				getArg(p,0)= k;
				q= pushArgument(nmb,q, k);
				q= pushArgument(nmb,q, gauge.slice);
				pushInstruction(nmb,q);
			}
		} else if ( p->token == ENDsymbol) {
			pushInstruction(nmb,ret);
			pushEndInstruction(nmb);
			continue;
		}
		else if ( getModuleId(p) == optimizerRef)
			pushInstruction(nmb,old[i]);
		else {
			freeInstruction(old[i]);
			old[i] = 0;
		}
	}

	if ( parallel == 0 ){
		/* no partitioned column used */
		if (vec) GDKfree(vec);
		freeMalBlk(nmb);
		return 0;
	}
	insertSymbol(cntxt->nspace,s);


	q = 0;

	/* supportive routines */
	smb = OPTslicingStub(cntxt, mb, pc,  nmb, gauge);
	msg = OPTdeadcode(cntxt, smb, 0, 0);
	if ( msg)
		goto wrapup;

	cmb = OPTslicingCntrl(cntxt,mb,pc,nmb, gauge);
	chkProgram(cntxt->nspace, cmb);
	if ( cmb->errors)
		goto wrapup;

	msg = OPTdeadcode(cntxt, nmb, 0, 0);
	if ( msg)
		goto wrapup;
	chkProgram(cntxt->nspace, nmb);
	if ( nmb->errors)
		goto wrapup;
	/* beware, optimizer may reorder/relabel variables */
	msg= optimizeMALBlock(cntxt, nmb);
	if ( msg)
		goto wrapup;

	/* remove the gauge variables */
	/* nmb->stmt[0]->argc -= 2;*/
	q = copyInstruction(getInstrPtr(cmb,0));
	q->barrier = 0;
	q->token = ASSIGNsymbol;
	/* beware this instruction refers to cmb variables */
wrapup:
#ifdef _DEBUG_OPT_SLICE_
	mnstr_printf(cntxt->fdout,"#Grabbed part\n");
	if ( nmb)
		printFunction(cntxt->fdout, nmb, 0, LIST_MAL_STMT);
	mnstr_printf(cntxt->fdout,"#stub\n");
	if ( smb)
		printFunction(cntxt->fdout, smb, 0, LIST_MAL_STMT);
	mnstr_printf(cntxt->fdout,"#cntrl\n");
	if ( cmb)
		printFunction(cntxt->fdout, cmb, 0, LIST_MAL_STMT);
#endif

	if (vec) GDKfree(vec);
	return q;
}

static int
OPTslicingImplementation(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	int i,j,pc = 0;
	wrd r = 0, rowcnt=0;	/* table should be sizeable to consider parallel execution*/
	InstrPtr p,q, target= 0, rsset;
	Gauge gauge;
	str msg = NULL;
	MalBlkPtr  omb;
	char *vec;

	(void)cntxt;
	(void) stk;
	(void) pci;

	/* determine the peers using merovingian */ 
	mal_set_lock(mal_contextLock,"optimizer.slicing");
	if ( nrpeers == 0 )
		OPTdiscover(cntxt);
	mal_unset_lock(mal_contextLock,"optimizer.slicing");
    /* nrpeers = GDKnr_threads ? GDKnr_threads:1;*/
	/* to ease debugging now */
	nrpeers = 2;
	slicingLocal = 1;

	/* modify the block as we go */
	omb= copyMalBlk(mb);
	rsset= newInstruction(mb, ASSIGNsymbol);
	gauge.column = 0;
	/* locate the largest non-partitioned table */
	for (i=1; i< mb->stop; i++){
		q= getInstrPtr(mb,i);
		if ( ! (getModuleId(q) == sqlRef && getFunctionId(q) == bindRef ) )
			continue;
		/* don't split insert BATs */
		if (getVarConstant(mb, getArg(q,5)).val.ival != 0 )
			continue;
		r = getVarRows(mb, getArg(q, 0));
		if (r >= rowcnt){
			rowcnt = r;
			target = q;
			r = 0;
		}
	}
	if (target == 0)
		return 0;

	/* for the time being assume one target colum */
	gauge.target = target;
	gauge.schema = getVarConstant(mb, getArg(target,2)).val.sval;
	gauge.table = getVarConstant(mb, getArg(target,3)).val.sval;
	for (i=1; i< mb->stop; i++){
		q= getInstrPtr(mb,i);
		if ( getModuleId(q) == sqlRef) {
			if ( getFunctionId(q) == rsColumnRef) {
				j = newTmpVariable(mb, getArgType(mb,q,7));
				rsset= pushReturn(mb,rsset, j);
				rsset= pushArgument(mb,rsset, getArg(q,7));
				getArg(q,7) = j;
			}
		}
	}
	OPTDEBUGslicing
		mnstr_printf(cntxt->fdout,"#opt_slicing: target is %s.%s "
			" with " SSZFMT " rows into %d peers\n",
				getVarConstant(mb, getArg(gauge.target,2)).val.sval,
				getVarConstant(mb, getArg(gauge.target,3)).val.sval,
				rowcnt, nrpeers);

	for(i=0; i < mb->stop; i++){
		p= getInstrPtr(mb,i);


		if ( getModuleId(p) == sqlRef && getFunctionId(p) == resultSetRef) {
			insertInstruction(mb,rsset,i);
			q = OPTcodegen(cntxt, mb, i, gauge);
			i++;

			if ( q ) {
				getModuleId(rsset) = userRef;
				getFunctionId(rsset) = getFunctionId(q);
				/* now drop the arguments */
				rsset->argc -= rsset->retc;
				freeInstruction(q);
				q= getInstrPtr(mb,0);
				for ( j = q->retc; j < q->argc; j++)
					rsset = pushArgument(mb,rsset, getArg(q,j));
				getArg(p,3) = getArg(rsset,0);
				msg = OPTdeadcode(cntxt, mb, 0, 0);
				if ( msg )
					mnstr_printf(cntxt->fdout,"codegen deadcode %s\n",msg);
			}
			continue;
		}

		if ( getModuleId(p) == sqlRef && getFunctionId(p) == putName("exportValue",11)) {
			q = OPTcodegen(cntxt, mb, i, gauge);
			if ( q ) {
				getArg(p,8) = getArg(q,0);
				freeInstruction(q);
				msg = OPTdeadcode(cntxt, mb, 0, 0);
				if ( msg )
					mnstr_printf(cntxt->fdout,"codegen deadcode %s\n",msg);
			}
			continue;
		}

		if ( getModuleId(p) == aggrRef && p->argc ==2 ) {
			q = OPTcodegen(cntxt, mb, i, gauge);
			if ( q ) {
				getModuleId(p) = userRef;
				getFunctionId(p) = getFunctionId(q);
				p->argc = p->retc;
				freeInstruction(q);
				msg = OPTdeadcode(cntxt, mb, 0, 0);
				if ( msg )
					mnstr_printf(cntxt->fdout,"codegen deadcode %s\n",msg);
				continue;
			}
		}
		if ( p->token == ENDsymbol)
			pc = i -1;
	}
	if ( pc ){
		vec = OPTsliceDependency(cntxt, mb, pc);
		for ( i = 0; i< pc; i++)
		if ( vec[i] == 0)
			getInstrPtr(mb,i)->token = NOOPsymbol;
		GDKfree(vec);
	}

	msg = OPTdeadcode(cntxt, mb, 0, 0);
	if ( msg)
		goto wrapup;
	chkProgram(cntxt->nspace, mb);
#ifdef _DEBUG_OPT_SLICE_
	mnstr_printf(cntxt->fdout,"#gauge %s.%s.%s type %d %s\n",
		gauge.schema,
		gauge.table,
		(gauge.column ? gauge.column: ""),
		gauge.type,
		msg?msg:"");
	mnstr_printf(cntxt->fdout,"#orig\n");
	printFunction(cntxt->fdout, mb, 0, LIST_MAL_STMT);
#endif
	if (msg || mb->errors ) {
wrapup:
		/* restore MAL block */
		mnstr_printf(cntxt->fdout,"#slicing %s\n", msg?msg:"generic error");
		/* freeMalBlk(mb);*/
		*mb = *omb;
		return 0;
	}
	return 1;
}
@include optimizerWrapper.mx
@c
#include "opt_statistics.h"
#include "algebra.h"
@:wrapOptimizer(slicing,OPT_CHECK_ALL)@

@-
@= histo
	{ @1 *vv;
		vv= (@1 *) getArgReference(stk, pci, 0 );
		*vv = @1_nil;
		vx = (ptr) &max.val.@2;
		BATmax(b, vx);
		vv= (ptr) getArgReference(stk, pci, pci->retc -1 );
		*vv = @1_nil;
		vm = (ptr) &min.val.@2;
		BATmin(b, vm);
		step.val.@2 = (max.val.@2 - min.val.@2) / pci->retc-2;
		if ( step.val.@2 == 0)
				step.val.@2 = max.val.@2;
		for ( i = 1; i < pci->retc-1; i++) {
			vx= (ptr) getArgReference(stk, pci, i );
			((ValPtr) vx ) ->val.@2 = min.val.@2 + i * step.val.@2;
		}
	}
@c
/* determine the initial gauge values */
/* the min/max bounds are null values */
/* It is the heart of the approach and requires experimentation */
str
OPTgauges(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{	
	BAT *b;
	int bid = *(int*) getArgReference(stk,pci, pci->argc-1);
	ValRecord min,max, step;
	int i;
	ptr vx,vm;

	(void) cntxt;
	(void) mb;
	if ( pci->retc < 2)
		throw(SQL,"sql.gauges","Not enough gauges");
	b = BATdescriptor(bid);
	if (b == NULL)
		throw(SQL,"sql.gauges","Can not access BAT");
    switch (ATOMstorage(b->ttype)) {
    case TYPE_bte: @:histo(bte,btval)@ break;
    case TYPE_sht: @:histo(sht,shval)@ break;
    case TYPE_int: @:histo(int,ival)@ break;
    case TYPE_wrd: @:histo(wrd,wval)@ break;
    case TYPE_lng: @:histo(lng,lval)@ break;
    case TYPE_oid: @:histo(oid,oval)@ break;
    case TYPE_flt: @:histo(flt,fval)@ break;
    case TYPE_dbl: @:histo(dbl,dval)@ break;
	default:
		throw(SQL,"sql.gauges","Can not slice column by value or oid");
    }

	for( i = 0; i < pci->retc; i++){
	}

	BBPreleaseref(bid);
	return MAL_SUCCEED;
}
@}
