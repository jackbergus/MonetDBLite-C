@/
The contents of this file are subject to the MonetDB Public License
Version 1.1 (the "License"); you may not use this file except in
compliance with the License. You may obtain a copy of the License at
http://www.monetdb.org/Legal/MonetDBLicense

Software distributed under the License is distributed on an "AS IS"
basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations
under the License.

The Original Code is the MonetDB Database System.

The Initial Developer of the Original Code is CWI.
Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
Copyright August 2008-2011 MonetDB B.V.
All Rights Reserved.
@

@c
/*
 * @f opt_joinselect
 * @a S. Idreos
 * The combination of joins and selects is effective in the
 * context of cracker optimizations.
 */
@mal
pattern optimizer.joinselect():str
address OPTjoinselect;
pattern optimizer.joinselect(mod:str, fcn:str):str
address OPTjoinselect
comment "Replace select with join select";
@h
#ifndef _MAL_JOINSEL
#define _MAL_JOINSEL
#include "opt_prelude.h"
#include "opt_support.h"

#define match2(X,M,F) ( (X) && getFunctionId(X) && getFunctionId(X)==F && \
        getModuleId(X) && getModuleId(X)==M)
#define match3(X,M) (getModuleId(X) && getModuleId(X)==M) 

@:exportOptimizer(joinselect)@

#define OPTDEBUGjoinselect  if ( optDebug & (1 <<DEBUG_OPT_JOINSELECT) )

#endif
@c
#include "monetdb_config.h"
#include "opt_joinselect.h"
#include "mal_interpreter.h"	/* for showErrors() */
#include "mal_exception.h"

static int
OPTjoinselectImplementation(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	InstrPtr p, *old, qs, qi, qu, qd, r, d, k;
	int i, limit, slimit, attr;
	int start = -1;
	int *scr_s, *scr_i, *scr_u, *scr_d;
	int *ps, *pi, *pu, *pd;
	int scr_size = 10; 
	int xx = sizeof(int);
	int pivot = -1;

	OPTDEBUGjoinselect
		mnstr_printf(cntxt->fdout, "Joinselect optimizer started\n");

	ps= scr_s = (int*) GDKmalloc(scr_size * sizeof(int));
	pi= scr_i = (int*) GDKmalloc(scr_size * sizeof(int));
	pu= scr_u = (int*) GDKmalloc(scr_size * sizeof(int));
	pd= scr_d = (int*) GDKmalloc(scr_size * sizeof(int));

	if (ps == NULL || pi == NULL || pu == NULL || pd == NULL){
		if (ps) GDKfree(ps);
		if (pi) GDKfree(pi);
		if (pu) GDKfree(pu);
		if (pd) GDKfree(pd);
		return 0;
	}

	(void) stk;
	(void) pci;
	limit = mb->stop;
	slimit = mb->ssize;
	old = mb->stmt;

	if ( newMalBlkStmt(mb, mb->ssize) < 0){
		GDKfree(ps);
		GDKfree(pi);
		GDKfree(pu);
		GDKfree(pd);
		return 0;
	}
	
	/* The first loop identifies all the select calls and keeps a reference 
		to the operations.
	  Also the end of the selection part is found where the pivot is made.	 
	  All operations before the first select call are added to the new plan	*/
	for (i = 0; i < limit; i++) {
		p = old[i];

		if (match2(p, algebraRef, uselectRef)){
			if (start == -1) 
				start = i;

			if (varGetProp(mb, getArg(p,1), stableProp) != NULL){
				*(int*)ps = i;
				ps += xx;
			}
			if (varGetProp(mb, getArg(p,1), insertionsProp) != NULL){
				*(int*)pi = i;
				pi += xx;
			}
			if (varGetProp(mb, getArg(p,1), updatesProp) != NULL){
				*(int*)pu = i;
				pu += xx;
			}
		}
		
		if (match2(p, batRef, reverseRef)){
			if (varGetProp(mb, getArg(p,1), deletesProp) != NULL){
				*(int*)pd = i;
				pd += xx;
			}
		}
	
		if (match2(p, sqlRef, bindRef)){
			switch( getVar(mb,getArg(p,5))->value.val.ival ){
			case 0:
				varSetProp(mb, getArg(p,0), stableProp, 0, NULL);
				break;
			case 1:
				varSetProp(mb, getArg(p,0), insertionsProp, 0, NULL);
				break;
			case 3:
				varSetProp(mb, getArg(p,0), updatesProp, 0, NULL);
				break;
			}
		}
		if (match2(p, sqlRef, binddbatRef))
			varSetProp(mb, getArg(p,0), deletesProp, 0, NULL);

		if (match2(p, batRef, setWriteModeRef)){ 
			if (varGetProp(mb, getArg(p,1), stableProp) != NULL)
				varSetProp(mb, getArg(p,0), stableProp, 0, NULL);
			if (varGetProp(mb, getArg(p,1), insertionsProp) != NULL)
				varSetProp(mb, getArg(p,0), insertionsProp, 0, NULL);
			if (varGetProp(mb, getArg(p,1), updatesProp) != NULL)
				varSetProp(mb, getArg(p,0), updatesProp, 0, NULL);
		}

		if (match2(p, algebraRef, markTRef)){
			pivot = i;
			break;
		}
		
		if (start == -1)
			pushInstruction(mb, p);
	}
	for( ; i<slimit; i++)
	if( old[i])
		freeInstruction(old[i]);

	/*Nothing to optimize*/
	if (start== -1) goto end;

	/*if not more than one attributes in the where clause then keep the same plan*/
	attr = (int) ((ps -scr_s)/xx);
	if (attr <= 1){
		for (i = start; i < limit; i++) 
			pushInstruction(mb, old[i]);
		goto end;
	}

	/*The following loop transfers all calc operations in the beggining of the selections part*/
	for (i = start; i < pivot; i++) {
		p = old[i];
		if (match3(p, calcRef))
			pushInstruction(mb, p);
	}	

	/*join select on the stable bats */
	ps = scr_s;
	qs = old[*(int*)ps];
	pushInstruction(mb, qs);
	i = 1;		
	while(i<attr){
		p=qs;
		ps+=xx; 
		qs = old[*(int*)ps];
		setModuleId(qs, putName("crackers", 8));
		setFunctionId(qs, putName("joinuselect", 11));
		qs= pushArgument(mb, qs, getArg(p, 0));
		pushInstruction(mb, qs);
		i++;	
	}

	/*join select on the insertions bats */
	pi = scr_i;
	qi = old[*(int*)pi];
	pushInstruction(mb, qi);
	i = 1;		
	while(i<attr){
		p=qi;
		pi+=xx; 
		qi = old[*(int*)pi];
		setModuleId(qi, putName("crackers", 8));
		setFunctionId(qi, putName("joinuselect", 11));
		qi= pushArgument(mb, qi, getArg(p, 0));
		pushInstruction(mb, qi);
		i++;	
	}

	/*union the result of the join select on the stable bats with the join select on the insertions bat*/
	r = newInstruction(mb,ASSIGNsymbol);
	getArg(r,0) = newTmpVariable(mb, newBatType(TYPE_void, TYPE_void));
	setModuleId(r, putName("algebra", 7));
        setFunctionId(r, putName("kunion", 6));        
        r= pushArgument(mb, r, getArg(qs, 0));
        r= pushArgument(mb, r, getArg(qi, 0));
	pushInstruction(mb, r);


/*	d = newInstruction(mb,ASSIGNsymbol);
        getArg(d,0) = newTmpVariable(mb, newBatType(TYPE_oid, TYPE_void));
        setModuleId(d, putName("bat", 3));
        setFunctionId(d, putName("reverse", 7));
        d= pushArgument(mb, d, getArg(r, 0));
        pushInstruction(mb, d);
	r=d;
*/

	/*remove updated buns*/
	i = 1;		
	pu = scr_u;
	while(i<=attr){
		d = old[*(int*)pu];
		k = newInstruction(mb,ASSIGNsymbol);
		getArg(k,0) = newTmpVariable(mb, newBatType(TYPE_oid, TYPE_void));
		setModuleId(k, putName("algebra", 7));
		setFunctionId(k, putName("kdifference", 11));
		k= pushArgument(mb, k, getArg(r, 0));
		k= pushArgument(mb, k, getArg(d, 1));
		pushInstruction(mb, k);
		pu+=xx;
		r = k; 
		i++;	
	}

	/*join select on the updated bats*/
	pu = scr_u;
	qu = old[*(int*)pu];
	pushInstruction(mb, qu);
	i = 1;		
	while(i<attr){
		p=qu;
		pu+=xx; 
		qu = old[*(int*)pu];
		setModuleId(qu, putName("crackers", 8));
		setFunctionId(qu, putName("joinuselect", 11));
		qu= pushArgument(mb, qu, getArg(p, 0));
		pushInstruction(mb, qu);
		i++;	
	}

	/*union with the updates*/
	p = newInstruction(mb,ASSIGNsymbol);
	getArg(p,0) = newTmpVariable(mb, getArgType(mb,r,0));
	setModuleId(p, putName("algebra", 7));
	setFunctionId(p, putName("kunion", 6));        
	p= pushArgument(mb, p, getArg(r, 0));
	p= pushArgument(mb, p, getArg(qu, 0));
	pushInstruction(mb, p);

	/*remove any bun that is deleted*/
	pd = scr_d;
	i = 1;		
	while(i<=attr){
		qd = old[*(int*)pd];
		pushInstruction(mb, qd); /*this is the reverse operation*/
		k = newInstruction(mb,ASSIGNsymbol);
		getArg(k,0) = newTmpVariable(mb, newBatType(TYPE_oid, TYPE_void));
		setModuleId(k, putName("algebra", 7));
		setFunctionId(k, putName("kdifference", 11));
		k= pushArgument(mb, k, getArg(p, 0));
       	k= pushArgument(mb, k, getArg(qd, 0));
		pushInstruction(mb, k);
		pd += xx;
		p = k; 
		i++;	
	}

	/*now just append the remaining instructions. Only set the pivot to the correct variable*/	
	r = old[pivot];
	getArg(r,1) = getArg(p,0);
	pushInstruction(mb, r) ;

	for (i = pivot+1; i < limit; i++) {
                p = old[i];
                pushInstruction(mb, p);
        }       

end:

	OPTDEBUGjoinselect
		printFunction(cntxt->fdout, mb,0, LIST_MAL_ALL);
	GDKfree(old);
	GDKfree(ps);
	GDKfree(pi);
	GDKfree(pu);
	GDKfree(pd);
	return 1;
}
@include optimizerWrapper.mx
@c
#include "opt_statistics.h"
@:wrapOptimizer(joinselect,OPT_CHECK_ALL)@
