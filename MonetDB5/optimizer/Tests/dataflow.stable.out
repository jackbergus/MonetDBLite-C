stdout of test 'dataflow` in directory 'monetdb5/optimizer` itself:


# 18:05:39 >  
# 18:05:39 >   mserver5  --debug=10 --set gdk_nr_threads=0  --set "gdk_dbfarm=/ufs/mk/Aug2011//Linux/var/MonetDB" --set mapi_open=true --set mapi_port=32759 --set monet_prompt= --trace --forcemito --set mal_listing=2  --dbname=mTests_optimizer  dataflow.mal
# 18:05:39 >  

# MonetDB 5 server v11.5.0
# This is an unreleased version
# Serving database 'mTests_optimizer', using 4 threads
# Compiled for x86_64-unknown-linux-gnu/64bit with 64bit OIDs dynamically linked
# Found 7.749 GiB available main-memory.
# Copyright (c) 1993-July 2008 CWI.
# Copyright (c) August 2008-2015 MonetDB B.V., all rights reserved
# Visit http://monetdb.cwi.nl/ for further information
# Listening for connection requests on mapi:monetdb://eir.ins.cwi.nl:32759/
# MonetDB/GIS module loaded
# MonetDB/SQL module loaded
# SQLException:mvc:SQL module not initialized
function user.tst():void;
    s := microbenchmark.uniform(0@0:oid,10000000:wrd,10000000);
    l := aggr.min(s);
    h := l;
#mdb.setTimer(true); 
#mdb.setThread(true); 
    z := nil:bat[:oid,:oid];
barrier go := language.dataflow();
    t1 := algebra.subselect(s,l,h,true,true,false);
    t2 := algebra.subselect(s,l,h,true,true,false);
    t3 := algebra.subselect(s,l,h,true,true,false);
    t4 := algebra.subselect(s,l,h,true,true,false);
    t5 := algebra.subselect(s,l,h,true,true,false);
    t6 := algebra.subselect(s,l,h,true,true,false);
    t7 := algebra.subselect(s,l,h,true,true,false);
    t8 := algebra.subselect(s,l,h,true,true,false);
    z := mat.pack(t1,t2,t3,t4,t5,t6,t7,t8);
exit go;
    mdb.var();
    c := aggr.count(z);
    io.print(c);
    io.print("done");
end user.tst;
function user.main():void;
# a simple dataflow test 
    mdb.List("user","tst");
    user.tst();
end user.main;
function user.tst():void;               	#[0]  0 
    s:bat[:oid,:int] := microbenchmark.uniform(0@0:oid,10000000:wrd,10000000:int);	#[1] MBMuniform 1 <- 2 3 4 
    l:int := aggr.min(s:bat[:oid,:int]);	#[2] ALGminany 5 <- 1 
    h:int := l:int;                     	#[3]  6 <- 5 
#mdb.setTimer(true);                    
#mdb.setThread(true);                   
    z:bat[:oid,:oid] := nil:bat[:oid,:oid];	#[6]  9 <- 10 
barrier go:bit := language.dataflow();  	#[7] MALstartDataflow 11 
    t1:bat[:oid,:oid] := algebra.subselect(s:bat[:oid,:int],l:int,h:int,true:bit,true:bit,false:bit);	#[8] ALGsubselect1 12 <- 1 5 6 13 14 15 
    t2:bat[:oid,:oid] := algebra.subselect(s:bat[:oid,:int],l:int,h:int,true:bit,true:bit,false:bit);	#[9] ALGsubselect1 16 <- 1 5 6 13 13 15 
    t3:bat[:oid,:oid] := algebra.subselect(s:bat[:oid,:int],l:int,h:int,true:bit,true:bit,false:bit);	#[10] ALGsubselect1 17 <- 1 5 6 13 13 15 
    t4:bat[:oid,:oid] := algebra.subselect(s:bat[:oid,:int],l:int,h:int,true:bit,true:bit,false:bit);	#[11] ALGsubselect1 18 <- 1 5 6 13 13 15 
    t5:bat[:oid,:oid] := algebra.subselect(s:bat[:oid,:int],l:int,h:int,true:bit,true:bit,false:bit);	#[12] ALGsubselect1 19 <- 1 5 6 13 13 15 
    t6:bat[:oid,:oid] := algebra.subselect(s:bat[:oid,:int],l:int,h:int,true:bit,true:bit,false:bit);	#[13] ALGsubselect1 20 <- 1 5 6 13 13 15 
    t7:bat[:oid,:oid] := algebra.subselect(s:bat[:oid,:int],l:int,h:int,true:bit,true:bit,false:bit);	#[14] ALGsubselect1 21 <- 1 5 6 13 13 15 
    t8:bat[:oid,:oid] := algebra.subselect(s:bat[:oid,:int],l:int,h:int,true:bit,true:bit,false:bit);	#[15] ALGsubselect1 22 <- 1 5 6 13 13 15 
    z:bat[:oid,:oid] := mat.pack(t1:bat[:oid,:oid],t2:bat[:oid,:oid],t3:bat[:oid,:oid],t4:bat[:oid,:oid],t5:bat[:oid,:oid],t6:bat[:oid,:oid],t7:bat[:oid,:oid],t8:bat[:oid,:oid]);	#[16] MATpack 9 <- 12 16 17 18 19 20 21 22 
exit go:bit;                            	#[17]  11 
    s:bat[:oid,:int] := nil:bat[:oid,:int];	#[18]  1 <- 29 
    mdb.var();                          	#[19] MDBvar 23 
    c:wrd := aggr.count(z:bat[:oid,:oid]);	#[20] ALGcount_bat 24 <- 9 
    io.print(c:wrd);                    	#[21] IOprint_val 25 <- 24 
    io.print("done":str);               	#[22] IOprint_val 26 <- 27 
end user.tst;                           	#[23]  
#Stack 'tst' size=32 top=27
#[1]     s = nil :bat[:oid,:int]   eolife=18 
#[2]    _2 = 0@0 :oid  constant 
#[3]    _3 = 10000000 :wrd  constant 
#[4]    _4 = 10000000 :int  constant 
#[5]     l = 0 :int  
#[6]     h = 0 :int  
#[9]     z = <tmp_160> :bat[:void,:int] rows=8   eolife=20 
#[10]   _10 = nil :bat[:oid,:int]  constant  eolife=6 
#[11]    go = false :bit  
#[12]    t1 = nil :bat[:oid,:int]   eolife=16 
#[13]    t2 = nil :bat[:oid,:int]   eolife=16 
#[14]    t3 = nil :bat[:oid,:int]   eolife=16 
#[15]    t4 = nil :bat[:oid,:int]   eolife=16 
#[16]    t5 = nil :bat[:oid,:int]   eolife=16 
#[17]    t6 = nil :bat[:oid,:int]   eolife=16 
#[18]    t7 = nil :bat[:oid,:int]   eolife=16 
#[19]    t8 = nil :bat[:oid,:int]   eolife=16 
#[21]     c = 0 :wrd  
#[24]   _24 = "done" :str  constant 
#[26]   _26 = nil :bat[:oid,:int]  constant 
[ 8 ]

[ "done" ]



# 18:05:41 >  
# 18:05:41 >  Done.
# 18:05:41 >  

