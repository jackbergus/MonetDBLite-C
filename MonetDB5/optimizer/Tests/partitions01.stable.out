stdout of test 'partitions01` in directory 'optimizer` itself:


# 09:48:30 >  
# 09:48:30 >  Mtimeout -timeout 60 mserver5 "--config=/ufs/mk/monet5/Linux/etc/monetdb5.conf" --debug=10 --set "monet_mod_path=/ufs/mk/monet5//Linux/lib/MonetDB5:/ufs/mk/monet5//Linux/lib/MonetDB5/lib:/ufs/mk/monet5//Linux/lib/MonetDB5/bin" --set "gdk_dbfarm=/ufs/mk/monet5//Linux/var/MonetDB5/dbfarm" --set "sql_logdir=/ufs/mk/monet5//Linux/var/MonetDB5/sql_logs" --set "xquery_logdir=/ufs/mk/monet5//Linux/var/MonetDB5/xquery_logs" --set mapi_port=36708 --set xrpc_port=48585 --set monet_prompt= --trace --dbname=mTests_src_optimizer  partitions01.mal
# 09:48:30 >  

# MonetDB Server v5.0.0_beta2_1
# Copyright (c) 1993-2007 CWI, all rights reserved
# Compiled for x86_64-redhat-linux-gnu/64bit with 64bit OIDs dynamically linked
# dbname:mTests_src_optimizer
# Visit http://monetdb.cwi.nl/ for further information
# Listening for connection requests on mapi:monetdb://eir.ins.cwi.nl:32348/
pattern sql.bind(s:str,t:str,i:str,flag:int):bat[:oid,:int] address MDBdummy;
pattern sql.rsColumn(b:any...):void address MDBdummy;
pattern sql.resultSet(b:any...):void address MDBdummy;
pattern sql.exportResult(b:any...):void address MDBdummy;
function sql.query(A0:sht):void;
    x1:bat[:oid,:int]  := sql.bind("sys","x","i",0);
    x6:bat[:oid,:int]  := sql.bind("sys","x","i",1);
    constraints.emptySet(x6);
    x9:bat[:oid,:int]  := sql.bind("sys","x","i",2);
    constraints.emptySet(x9);
    x21:bat[:oid,:int]  := sql.bind("sys","x","j",1);
    x18 := algebra.markT(x1,0@0);
    x19 := bat.reverse(x18);
    x20 := algebra.join(x19,x1);
    x28 := algebra.join(x19,x21);
    x29 := sql.resultSet(2,1,x20);
    sql.rsColumn(x29,"sys.x","i","int",32,0,x20);
    sql.rsColumn(x29,"sys.x","j","int",32,0,x28);
    sql.exportResult(x29,"");
end query;
function user.main():void;
#testing the BAT partition manager 
# use a fake sql library 
    mdb.List("sql","query");
end main;
function sql.query(A0:sht):void;        #  0 query:void := sql.query(A0:sht) {G}
    x1:bat[:oid,:int] {bid=812, rows=1, notnil=true} := sql.bind("sys","x","i",0);#  1 x1:bat[:oid,:int] := MDBdummy(_6:str, _7:str, _8:str, _9:int) {G}
    x6:bat[:oid,:int] {bid=808, rows=0, notnil=true} := sql.bind("sys","x","i",1);#  2 x6:bat[:oid,:int] := MDBdummy(_6:str, _7:str, _8:str, _4:int) {G}
    bpm10:bat[:oid,:int]  := bpm.unfold(x6{bid=808, rows=0, notnil=true});#  3 bpm10:bat[:oid,:int] := BPMunfold(x6:bat[:oid,:int]) {G}
    bpm.emptySet(bpm10);                #  4 _12:void := BPMemptySet(bpm10:bat[:oid,:int]) {G}
    x9:bat[:oid,:int] {bid=814, rows=0, notnil=true} := sql.bind("sys","x","i",2);#  5 x9:bat[:oid,:int] := MDBdummy(_6:str, _7:str, _8:str, _15:int) {G}
    bpm13:bat[:oid,:int]  := bpm.unfold(x9{bid=814, rows=0, notnil=true});#  6 bpm13:bat[:oid,:int] := BPMunfold(x9:bat[:oid,:int]) {G}
    bpm.emptySet(bpm13);                #  7 _16:void := BPMemptySet(bpm13:bat[:oid,:int]) {G}
    x21:bat[:oid,:int] {bid=815, rows=1, notnil=true} := sql.bind("sys","x","j",1);#  8 x21:bat[:oid,:int] := MDBdummy(_6:str, _7:str, _19:str, _4:int) {G}
    bpm17:bat[:oid,:int]  := bpm.unfold(x21{bid=815, rows=1, notnil=true});#  9 bpm17:bat[:oid,:int] := BPMunfold(x21:bat[:oid,:int]) {G}
    x18{rows=1} := algebra.markT(x1{bid=812, rows=1, notnil=true},0@0);# 10 x18:bat[:oid,:oid] := ALGtmark(x1:bat[:oid,:int], _21:oid) {G}
    x19{rows=1} := bat.reverse(x18{rows=1});# 11 x19:bat[:oid,:oid] := BKCreverse(x18:bat[:oid,:oid]) {G}
    x20{rows=1} := algebra.join(x19{rows=1},x1{bid=812, rows=1, notnil=true});# 12 x20:bat[:oid,:int] := ALGjoin(x19:bat[:oid,:oid], x1:bat[:oid,:int]) {G}
    X_39 := bpm.new(:oid,:int);         # 13 _39:bat[:oid,:int] := BPMnew(_40:oid, _41:int) {G}
    x28{rows=1} := nil:bat[:oid,:int];  # 14 x28:bat[:oid,:int] := _43:bat[:oid,:int] {G}
barrier x21:bat[:oid,:int] {bid=815, rows=1, notnil=true} := bpm.newIterator(bpm17);# 15 x21:bat[:oid,:int] := BPMnewIterator(bpm17:bat[:oid,:int]) {GJ19}
    x28{rows=1} := algebra.join(x19{rows=1},x21{bid=815, rows=1, notnil=true});# 16 x28:bat[:oid,:int] := ALGjoin(x19:bat[:oid,:oid], x21:bat[:oid,:int]) {G}
    bpm.addPartition(X_39,x28{rows=1}); # 17 _45:void := BPMaddPartition(_39:bat[:oid,:int], x28:bat[:oid,:int]) {G}
    redo x21:bat[:oid,:int] {bid=815, rows=1, notnil=true} := bpm.hasMoreElements(bpm17);# 18 x21:bat[:oid,:int] := BPMhasMoreElements(bpm17:bat[:oid,:int]) {GJ16}
exit x21:bat[:oid,:int] {bid=815, rows=1, notnil=true};# 19 x21:bat[:oid,:int] 
    x29 := sql.resultSet(2,1,x20{rows=1});# 20 x29:void := MDBdummy(_15:int, _4:int, x20:bat[:oid,:int]) {G}
    sql.rsColumn(x29,"sys.x","i","int",32,0,x20{rows=1});# 21 _26:void := MDBdummy(x29:void, _27:str, _8:str, _28:str, _29:int, _9:int, x20:bat[:oid,:int]) {G}
    x28{rows=1} := bpm.fold(X_39);      # 22 x28:bat[:oid,:int] := BPMfold(_39:bat[:oid,:int]) {G}
    sql.rsColumn(x29,"sys.x","j","int",32,0,x28{rows=1});# 23 _30:void := MDBdummy(x29:void, _27:str, _19:str, _28:str, _29:int, _9:int, x28:bat[:oid,:int]) {G}
    sql.exportResult(x29,"");           # 24 _31:void := MDBdummy(x29:void, _32:str) {G}
catch SQLexception;                     # 25 SQLexception:str {J30}
    bpm.garbage(bpm10);                 # 26 _50:void := BPMgarbage(bpm10:bat[:oid,:int]) {G}
    bpm.garbage(bpm13);                 # 27 _51:void := BPMgarbage(bpm13:bat[:oid,:int]) {G}
    bpm.garbage(bpm17);                 # 28 _52:void := BPMgarbage(bpm17:bat[:oid,:int]) {G}
    raise SQLexception;                 # 29 SQLexception:str 
exit SQLexception;                      # 30 SQLexception:str 
    bpm.garbage(bpm10);                 # 31 _55:void := BPMgarbage(bpm10:bat[:oid,:int]) {G}
    bpm.garbage(bpm13);                 # 32 _56:void := BPMgarbage(bpm13:bat[:oid,:int]) {G}
    bpm.garbage(bpm17);                 # 33 _57:void := BPMgarbage(bpm17:bat[:oid,:int]) {G}
end query;                              # 34  

# 09:48:30 >  
# 09:48:30 >  Done.
# 09:48:30 >  

