stdout of test 'mat01` in directory 'optimizer` itself:


# 11:53:46 >  
# 11:53:46 >  Mtimeout -timeout 60 Mserver "--config=/ufs/mk/monet5/src/mal/Tests/All.conf" --debug=10 --set "monet_mod_path=/ufs/mk/monet5/Linux/lib/MonetDB5:/ufs/mk/opensource/MonetDB/Linux/lib/MonetDB" --set "gdk_dbfarm=/ufs/mk/opensource/MonetDB/Linux/var/MonetDB5/dbfarm" --set "sql_logdir=/ufs/mk/opensource/MonetDB/Linux/var/MonetDB5/log" --set mapi_port=39582 --set sql_port=44122 --set xquery_port=52828 --set monet_prompt= --trace --dbname=mTests_src_optimizer  mat01.mal < /dev/null
# 11:53:46 >  

# MonetDB 5 server v11.10.0
# This is an unreleased version
# Serving database 'mTests_optimizer', using 8 threads
# Compiled for x86_64-unknown-linux-gnu/64bit with 64bit OIDs dynamically linked
# Found 15.630 GiB available main-memory.
# Copyright (c) 1993-July 2008 CWI.
# Copyright (c) August 2008-2012 MonetDB B.V., all rights reserved
# Visit http://www.monetdb.org/ for further information
# Listening for connection requests on mapi:monetdb://vienna.ins.cwi.nl:33397/
# MonetDB/GIS module loaded
# MonetDB/SQL module loaded
function user.main():void;
# the Multi Assocation Tables 
# use two mats at the same time. 
    mdb.List();
    m0 := bat.new(:oid,:int);
    bat.insert(m0,nil:oid,0);
    m1 := bat.new(:oid,:int);
    bat.insert(m1,nil:oid,1);
    m2 := bat.new(:oid,:int);
    bat.insert(m2,nil:oid,2);
    X_38 := algebra.select(m0,0,2);
    X_39 := algebra.select(m1,0,2);
    X_40 := algebra.select(m2,0,2);
    X_42 := aggr.count(X_38);
    X_43 := aggr.count(X_39);
    X_44 := aggr.count(X_40);
    X_41 := mat.pack(X_42,X_43,X_44);
    X_45 := algebra.selectNotNil(X_41);
    i := aggr.sum(X_45);
    s := mat.pack(X_38,X_39,X_40);
    io.print(s);
    io.print(i);
    c0 := bat.new(:int,:int);
    bat.insert(c0,0,4);
    c1 := bat.new(:int,:int);
    bat.insert(c1,1,5);
    c := mat.pack(c0,c1);
    bat.insert(c,1,6);
    X_46 := algebra.join(m0,c);
    X_47 := algebra.join(m1,c);
    X_48 := algebra.join(m2,c);
    j := mat.pack(X_46,X_47,X_48);
    io.print(j);
    X_49 := algebra.select(m1,0,2);
    X_50 := algebra.select(m2,0,2);
    X_52 := aggr.count(X_49);
    X_53 := aggr.count(X_50);
    X_51 := mat.pack(X_52,X_53);
    X_54 := algebra.selectNotNil(X_51);
    i := aggr.sum(X_54);
    s := mat.pack(X_49,X_50);
    io.print(s);
    b := mat.pack(m0,m1,m2);
    io.print(b);
    io.print(c);
    d := mat.pack(m1,m2);
    io.print(d);
end main;
function user.main():void;              #  0 main:void := user.main() {G}
# the Multi Assocation Tables 
# use two mats at the same time. 
    mdb.List();                         #  3 _3:void := MDBlistDetail() 
    m0 := bat.new(:oid,:int);           #  4 m0:bat[:oid,:int] := CMDBATnew(_5:oid, _6:int) {G}
    bat.insert(m0,nil:oid,0);           #  5 _7:bat[:oid,:int] := BKCinsert_bun(m0:bat[:oid,:int], _8:oid, _9:int) {G}
    m1 := bat.new(:oid,:int);           #  6 m1:bat[:oid,:int] := CMDBATnew(_5:oid, _6:int) {G}
    bat.insert(m1,nil:oid,1);           #  7 _11:bat[:oid,:int] := BKCinsert_bun(m1:bat[:oid,:int], _8:oid, _12:int) {G}
    m2 := bat.new(:oid,:int);           #  8 m2:bat[:oid,:int] := CMDBATnew(_5:oid, _6:int) {G}
    bat.insert(m2,nil:oid,2);           #  9 _14:bat[:oid,:int] := BKCinsert_bun(m2:bat[:oid,:int], _8:oid, _15:int) {G}
    X_38 := algebra.select(m0,0,2);     # 10 _38:bat[:oid,:int] := ALGselect(m0:bat[:oid,:int], _9:int, _15:int) {G}
    X_39 := algebra.select(m1,0,2);     # 11 _39:bat[:oid,:int] := ALGselect(m1:bat[:oid,:int], _9:int, _15:int) {G}
    X_40 := algebra.select(m2,0,2);     # 12 _40:bat[:oid,:int] := ALGselect(m2:bat[:oid,:int], _9:int, _15:int) {G}
    X_42 := aggr.count(X_38);           # 13 _42:wrd := ALGcount_bat(_38:bat[:oid,:int]) {G}
    X_43 := aggr.count(X_39);           # 14 _43:wrd := ALGcount_bat(_39:bat[:oid,:int]) {G}
    X_44 := aggr.count(X_40);           # 15 _44:wrd := ALGcount_bat(_40:bat[:oid,:int]) {G}
    X_41 := mat.pack(X_42,X_43,X_44);   # 16 _41:bat[:void,:wrd] := MATpackValues(_42:wrd, _43:wrd, _44:wrd) {G}
    X_45 := algebra.selectNotNil(X_41); # 17 _45:bat[:void,:wrd] := ALGselectNotNil(_41:bat[:void,:wrd]) {G}
    i := aggr.sum(X_45);                # 18 i:wrd := aggr.sum(_45:bat[:void,:wrd]) {G}
    s := mat.pack(X_38,X_39,X_40);      # 19 s:bat[:oid,:int] := MATpack(_38:bat[:oid,:int], _39:bat[:oid,:int], _40:bat[:oid,:int]) {G}
    io.print(s);                        # 20 _20:void := IOprint_val(s:bat[:oid,:int]) {G}
    io.print(i);                        # 21 _21:void := IOprint_val(i:wrd) 
    c0 := bat.new(:int,:int);           # 22 c0:bat[:int,:int] := CMDBATnew(_6:int, _6:int) {G}
    bat.insert(c0,0,4);                 # 23 _23:bat[:int,:int] := BKCinsert_bun(c0:bat[:int,:int], _9:int, _24:int) {G}
    c1 := bat.new(:int,:int);           # 24 c1:bat[:int,:int] := CMDBATnew(_6:int, _6:int) {G}
    bat.insert(c1,1,5);                 # 25 _26:bat[:int,:int] := BKCinsert_bun(c1:bat[:int,:int], _12:int, _27:int) {G}
    c := mat.pack(c0,c1);               # 26 c:bat[:int,:int] := MATpack(c0:bat[:int,:int], c1:bat[:int,:int]) {G}
    bat.insert(c,1,6);                  # 27 _29:bat[:int,:int] := BKCinsert_bun(c:bat[:int,:int], _12:int, _30:int) {G}
    X_46 := algebra.join(m0,c);         # 28 _46:bat[:oid,:int] := ALGjoin(m0:bat[:oid,:int], c:bat[:int,:int]) {G}
    X_47 := algebra.join(m1,c);         # 29 _47:bat[:oid,:int] := ALGjoin(m1:bat[:oid,:int], c:bat[:int,:int]) {G}
    X_48 := algebra.join(m2,c);         # 30 _48:bat[:oid,:int] := ALGjoin(m2:bat[:oid,:int], c:bat[:int,:int]) {G}
    j := mat.pack(X_46,X_47,X_48);      # 31 j:bat[:oid,:int] := MATpack(_46:bat[:oid,:int], _47:bat[:oid,:int], _48:bat[:oid,:int]) {G}
    io.print(j);                        # 32 _32:void := IOprint_val(j:bat[:oid,:int]) {G}
    X_49 := algebra.select(m1,0,2);     # 33 _49:bat[:oid,:int] := ALGselect(m1:bat[:oid,:int], _9:int, _15:int) {G}
    X_50 := algebra.select(m2,0,2);     # 34 _50:bat[:oid,:int] := ALGselect(m2:bat[:oid,:int], _9:int, _15:int) {G}
    X_52 := aggr.count(X_49);           # 35 _52:wrd := ALGcount_bat(_49:bat[:oid,:int]) {G}
    X_53 := aggr.count(X_50);           # 36 _53:wrd := ALGcount_bat(_50:bat[:oid,:int]) {G}
    X_51 := mat.pack(X_52,X_53);        # 37 _51:bat[:void,:wrd] := MATpackValues(_52:wrd, _53:wrd) {G}
    X_54 := algebra.selectNotNil(X_51); # 38 _54:bat[:void,:wrd] := ALGselectNotNil(_51:bat[:void,:wrd]) {G}
    i := aggr.sum(X_54);                # 39 i:wrd := aggr.sum(_54:bat[:void,:wrd]) {G}
    s := mat.pack(X_49,X_50);           # 40 s:bat[:oid,:int] := MATpack(_49:bat[:oid,:int], _50:bat[:oid,:int]) {G}
    io.print(s);                        # 41 _33:void := IOprint_val(s:bat[:oid,:int]) {G}
    b := mat.pack(m0,m1,m2);            # 42 b:bat[:oid,:int] := MATpack(m0:bat[:oid,:int], m1:bat[:oid,:int], m2:bat[:oid,:int]) {G}
    io.print(b);                        # 43 _34:void := IOprint_val(b:bat[:oid,:int]) {G}
    io.print(c);                        # 44 _35:void := IOprint_val(c:bat[:int,:int]) {G}
    d := mat.pack(m1,m2);               # 45 d:bat[:oid,:int] := MATpack(m1:bat[:oid,:int], m2:bat[:oid,:int]) {G}
    io.print(d);                        # 46 _36:void := IOprint_val(d:bat[:oid,:int]) {G}
end main;                               # 47  
#-----------------#
# h	t	  # name
# oid	int	  # type
#-----------------#
[ nil,	  0	  ]
[ nil,	  1	  ]
[ nil,	  2	  ]
[ 3 ]
#-----------------#
# h	t	  # name
# oid	int	  # type
#-----------------#
[ nil,	  4	  ]
[ nil,	  5	  ]
[ nil,	  6	  ]
#-----------------#
# h	t	  # name
# oid	int	  # type
#-----------------#
[ nil,	  1	  ]
[ nil,	  2	  ]
#-----------------#
# h	t	  # name
# oid	int	  # type
#-----------------#
[ nil,	  0	  ]
[ nil,	  1	  ]
[ nil,	  2	  ]
#-----------------#
# h	t	  # name
# int	int	  # type
#-----------------#
[ 0,	  4	  ]
[ 1,	  5	  ]
[ 1,	  6	  ]
#-----------------#
# h	t	  # name
# oid	int	  # type
#-----------------#
[ nil,	  1	  ]
[ nil,	  2	  ]

# 11:53:46 >  
# 11:53:46 >  Done.
# 11:53:46 >  

