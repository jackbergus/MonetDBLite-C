#testing the BAT partition manager
# use a fake sql library
# see how you handle an aggregation
module sql;
pattern bind(s:str,t:str,i:str,flag:int):bat[:oid,:int]
address MDBdummy;
pattern rsColumn(b:any...):void
address MDBdummy;
pattern resultSet(b:any...):void
address MDBdummy;
pattern exportResult(b:any...):void
address MDBdummy;
pattern exportValue(b:any...):void
address MDBdummy;

#select i,j from y group by i,j;

function query(A0:sht):void;
    x1:bat[:oid,:int]{notnil=true,rows=1,bid=1489}  := sql.bind("sys","y","i",0);
    x6:bat[:oid,:int]{notnil=true,rows=0,bid=1485}  := sql.bind("sys","y","i",1);
    constraints.emptySet(x6);
    x8:bat[:oid,:int]{notnil=true,rows=0,bid=1491}  := sql.bind("sys","y","i",2);
    constraints.emptySet(x8);
    x16:bat[:oid,:int]{notnil=true,rows=1,bid=1492}  := sql.bind("sys","y","j",0);
    x11{rows=1} := algebra.markT(x1,0@0);
    x12{rows=1} := bat.reverse(x11);
    x13{rows=1} := algebra.join(x12,x1);
    (ext23,grp21):= group.new(x13);
    x18{rows=1} := algebra.join(x12,x16);
    (ext34,grp32):= group.derive(ext23,grp21,x18);
    x21 := bat.mirror(ext34);
    x22 := algebra.joinPath(x21,x12,x1);
    x23 := algebra.joinPath(x21,x12,x16);
    x24 := sql.resultSet(2,1,x22);
    sql.rsColumn(x24,"sys.y","i","int",32,0,x22);
    sql.rsColumn(x24,"sys.y","j","int",32,0,x23);
    sql.exportResult(x24,"");
end query;
optimizer.partitions("sql","query");
mdb.List("sql","query");
