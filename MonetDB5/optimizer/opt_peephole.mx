@/
The contents of this file are subject to the MonetDB Public License
Version 1.1 (the "License"); you may not use this file except in
compliance with the License. You may obtain a copy of the License at
http://www.monetdb.org/Legal/MonetDBLicense

Software distributed under the License is distributed on an "AS IS"
basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations
under the License.

The Original Code is the MonetDB Database System.

The Initial Developer of the Original Code is CWI.
Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
Copyright August 2008-2011 MonetDB B.V.
All Rights Reserved.
@

@c
/*
 * @f opt_peephole
 * @a M. Kersten
 * @- Peephole optimization
 * Recursive descend query compilers easily miss opportunities
 * for better code generation, because limited context is retained
 * or lookahead available. The peephole optimizer is
 * built around such recurring patterns and compensates
 * for the compilers 'mistakes'.
 * The collection of peephole patterns should grow over time and
 * front-end specific variations are foreseen.
 */
@mal
pattern optimizer.peephole():str
address OPTpeephole;
pattern optimizer.peephole(mod:str, fcn:str):str
address OPTpeephole
comment "Perform local rewrites";
@h
#ifndef _MAL_PEEPHOLE_
#define _MAL_PEEPHOLE_
#include "opt_support.h"
#include "mal_interpreter.h"	/* for showErrors() */
#include "opt_prelude.h"

#define match(X,M,F) ( (X) && getFunctionId(X) && strcmp(getFunctionId(X),F)==0 && \
	getModuleId(X) && strcmp(getModuleId(X),M)==0)

#define OPTDEBUGpeephole  if ( optDebug & (1 <<DEBUG_OPT_PEEPHOLE) )
@c
#include "monetdb_config.h"
#include "opt_peephole.h"
#include "opt_aliases.h"
/*
 * @-
 * The SQL frontend heavily relies on a pivot table, which
 * is a generated oid sequence. Unfortunately, this
 * is not seen and the pattern '$i := calc.oid(0@@0); $j:= algebra.markT($k,$i);'
 * occurs often. This can be replaced with '$j:= algebra.markT($k)';
 *
 * Another example of a 2-way instruction sequence produced is then
 * '$j:= algebra.markT($k); $l:= bat.reverse($j);',
 * which can be replaced by '$l:= algebra.markH($k);'.
 *
 * The reverse-reverse operation also falls into this category.
 * Reversal pairs may result from the processing scheme of a front-end compiler
 * or from a side-effect from other optimization steps. Such reversal pairs should
 * be removed as quickly as possible, so as to reduce the complexity of finding
 * alternative optimization opportunities.
 * As in all cases we should ensure that the intermediates dropped are not
 * used for other purposes as well.
 *
 * @verbatim
 * 	r:bat[:int,:int]:= bat.new(:int,:int);
 * 	o:= calc.oid(0@0);
 * 	z:= algebra.markT(r,o);
 * 	rr:= bat.reverse(z);
 * 	s := bat.reverse(r);
 * 	t := bat.reverse(s);
 * 	io.print(t);
 * 	optimizer.peephole();
 * @end verbatim
 * which is translated by the peephole optimizer into:
 * @verbatim
 * 	r:bat[:int,:int] := bat.new(:int,:int);
 * 	rr := algebra.markH(r);
 * 	io.print(r);
 * @end verbatim
 *
 * Another example is the combination of a BAT partition operation
 * followed by a re-construction without using the partitions
 * individually.
 * The type of a variable may have to be reset when you change
 * the program structure.
 */
static int
OPTpartitionpack(InstrPtr p, InstrPtr part[], int top)
{
	int i,k,cnt;

	assert(getModuleId(p)==matRef && getFunctionId(p) == packRef);
	for ( i= top-1; i>=0; i--){
		cnt =0;
		if ( p->argc-p->retc == part[i]->retc)
		for ( k=0; k<part[i]->retc; k++)
			cnt += getArg(p,p->retc+k) == getArg(part[i],k);
		if ( cnt == p->argc-p->retc ){
			clrFunction(p);
			p->argc=2;
			getArg(p,1) = getArg(part[i],part[i]->retc);
			return 1;
		}
	}
	return 0;
}

static int
OPTpeepholeImplementation(Client cntxt,MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	InstrPtr p, q, r, *old;
	int i, limit, slimit, doit, actions = 0, ltop=0;
	Lifespan span;
	InstrPtr *part= GDKzalloc(sizeof(InstrPtr)*mb->stop);

	(void) stk;
	(void) pci;
	actions = 0;
	doit = 0;
	
	if ( part == NULL)
		return 0;
	span = setLifespan(mb);
	if ( span == NULL)
		return 0;
	limit = mb->stop;
	slimit = mb->ssize;
	old = mb->stmt;

	if ( newMalBlkStmt(mb, mb->ssize) < 0 ){
		GDKfree(span);
		return 0;
	}
	for (i = 0; i < limit; i++) {
		p = old[i];
		q = i < limit - 1 ? old[i + 1] : 0;
		if ( getModuleId(p)== batRef &&
			 getFunctionId(p) == partitionRef)
			part[ltop++]= p;
		if ( getModuleId(p)== matRef &&
			 getFunctionId(p) == packRef)
				actions += OPTpartitionpack(p, part, ltop);
			
		if (q && match(p, batRef, reverseRef) && 
					match(q, batRef, reverseRef) && 
					getArg(p, 0) == getArg(q, 1) && 
					getEndLifespan(span,getArg(p,0)) == i + 1) {
			OPTDEBUGpeephole {
				printf("PEEPHOLE reverse-reverse\n");
				printInstruction(cntxt->fdout, mb, 0,  p, LIST_MAL_ALL);
				printInstruction(cntxt->fdout, mb, 0,  q, LIST_MAL_ALL);
			}
			r = newInstruction(mb,ASSIGNsymbol);
			getArg(r, 0) = getArg(q, 0);
			r= pushArgument(mb, r, getArg(p, 1));
			freeInstruction(p);
			freeInstruction(q);
			pushInstruction(mb, r);
			i++;
			actions++;
			doit++;
		} else if (match(p, "optimizer", "peephole"))
			freeInstruction(p);
		else
			pushInstruction(mb, p);
	}
	for( ; i<slimit; i++)
	if( old[i])
		freeInstruction(old[i]);
	GDKfree(old);
	GDKfree(part);
	if (doit) {
		chkProgram(cntxt->nspace, mb);
	}
	GDKfree(span);
	return actions;
}

@include optimizerWrapper.mx
@h
@:exportOptimizer(peephole)@
#endif
@c
#include "opt_statistics.h"
@:wrapOptimizer(peephole,OPT_CHECK_ALL)@

