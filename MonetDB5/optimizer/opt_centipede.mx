@/
The contents of this file are subject to the MonetDB Public License
Version 1.1 (the "License"); you may not use this file except in
compliance with the License. You may obtain a copy of the License at
http://www.monetdb.org/Legal/MonetDBLicense

Software distributed under the License is distributed on an "AS IS"
basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations
under the License.

The Original Code is the MonetDB Database System.

The Initial Developer of the Original Code is CWI.
Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
Copyright August 2008-2012 MonetDB B.V.
All Rights Reserved.
@

@c
/*
 * @f opt_centipede
 * @a M. Kersten
 * @- Centipede
 * Documentation in accompanying paper.
 */
@mal
module centipede;
pattern optimizer.centipede():str
address OPTcentipede;
pattern optimizer.centipede(mod:str, fcn:str):str
address OPTcentipede
comment "Modify the plan to exploit parallel processing on multiple cores";

command centipede.materialize(b:bat[:any_1,:any_2], low:any_2, high:any_2) :bat[:any_1,:any_2]
address OPTcentipedeMaterialize
comment "Implement the centipede partition operation. Throw an exception if the partition was empty, 
because then the subquery should produce a NIL ";

pattern centipede.vector(b:bat[:oid,:any_1]) :any_1...
address OPTvector
comment "Derive a series of slices values based on sampling";

@h
#ifndef _OPT_CENTIPEDE_
#define _OPT_CENTIPEDE_
#include "opt_prelude.h"
#include "opt_support.h"

#define MAXSITES 4		/* to be refined */
@:exportOptimizer(centipede)@

opt_export str OPTvector(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
opt_export str OPTcentipedeMaterialize(int *result, int *bid, ptr low, ptr high);
opt_export str OPTpeers(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);

#define REMOTE_EXECUTION	/* or LOCAL_EXECUTION */

/* #define DEBUG_DETAIL*/
#define _DEBUG_OPT_CENTIPEDE_ 
#define OPTDEBUGcentipede  if ( optDebug & ((lng)1 <<DEBUG_OPT_CENTIPEDE) )
#endif
@c
#include "monetdb_config.h"
#include "opt_centipede.h"
#include "opt_deadcode.h"
#include "mal_builder.h"
#include "mal_recycle.h"
#include "mal_interpreter.h"

typedef	struct{
	InstrPtr target;
	str schema, table, column;
	int type, slice;	
	int lslices, hslices;
	ValRecord bounds[MAXSITES];
} Slices;

/*
 * The query will be controlled from the coordinator with a plan
 * geared at parallel execution 
 * TODO pack is expensive, move to mat.new
*/
static MalBlkPtr
OPTplanCntrl(Client cntxt, MalBlkPtr mb, MalBlkPtr pmb, Slices *slices, oid plantag)
{
	MalBlkPtr cmb;
	Symbol s;
	char nme[BUFSIZ], *plan, *stub;
#ifndef REMOTE_EXECUTION
	int base;
#endif
	int barrier, x, i, j, k, *alias, nrpack;
	InstrPtr ret, p, q, *pack;

#ifdef _DEBUG_OPT_CENTIPEDE_
	mnstr_printf(cntxt->fdout,"#original plan \n");
	printFunction(cntxt->fdout, mb, 0, LIST_MAL_STMT);
#endif
	/* define the query controller */
	snprintf(nme, BUFSIZ, "%s_plan"OIDFMT, getFunctionId( getInstrPtr(mb,0)), plantag);
	plan = putName(nme, strlen(nme));
	snprintf(nme,BUFSIZ,"%s_stub",getFunctionId( getInstrPtr(mb,0)));
	stub = putName(nme, strlen(nme));

	snprintf(nme,BUFSIZ,"%s_cntrl",getFunctionId( getInstrPtr(mb,0)));
	s = newFunction(userRef, putName(nme, strlen(nme)),FUNCTIONsymbol);
	if ( s == NULL)
		return 0;
	freeMalBlk(s->def);
	s->def = copyMalBlk(pmb);	/* get variables */
	cmb = s->def;
	if ( newMalBlkStmt(cmb,cmb->ssize) < 0 )
		return 0;
	nrpack= getInstrPtr(pmb,0)->retc;
	pack = (InstrPtr *) GDKzalloc(sizeof(InstrPtr) * nrpack);
	pushInstruction(cmb, copyInstruction(pmb->stmt[0]));
	getFunctionId( getInstrPtr(cmb,0)) = putName(nme,strlen(nme));
	insertSymbol(cntxt->nspace,s);

	/* initialize binds and histograms */
	q= newFcnCall(cmb, sqlRef, mvcRef);
	x= getArg(q,0);
	alias = (int*) GDKzalloc(nrservers * sizeof(int));
	if( slices->column) {
		q= newInstruction(cmb, ASSIGNsymbol);
		getModuleId(q) = sqlRef;
		getFunctionId(q) = bindRef;
		q = pushArgument(cmb,q,x);
		j = getArg(q,0) = newTmpVariable(cmb,newBatType(TYPE_oid, slices->type));
		setVarUDFtype(cmb,j);
		setVarFixed(cmb,j);
		q= pushStr(cmb,q, slices->schema);
		q= pushStr(cmb,q, slices->table);
		q= pushStr(cmb,q, slices->column);
		q= pushInt(cmb,q, 0);
		pushInstruction(cmb,q);

		q= newInstruction(cmb, ASSIGNsymbol);
		getModuleId(q) = centipedeRef;
		getFunctionId(q) = vectorRef;
		q = pushArgument(cmb, q, j);
		for ( j = 0; j < nrservers +1; j++) {
			k = alias[j] = newTmpVariable(cmb, slices->type);
			q= pushReturn(cmb,q, k);
		}
		pushInstruction(cmb,q);
	}
	/* pack[i] := mat.pack(x1,...xn) */
	if ( slices->column) {
		p = getInstrPtr(pmb,0);
		for ( k=0  ;k < nrpack ; k++){
			pack[k] = newInstruction(cmb,ASSIGNsymbol);
			getModuleId(pack[k]) = matRef;
			getFunctionId(pack[k]) = putName("pack3",5);
			getArg(pack[k],0) = newTmpVariable(cmb, newBatType(TYPE_oid, getTailType(getArgType(cmb,p,k))) );
		}
	}

	/* under dataflow control, initialize the variables 
	   Arguments are considered defined already
	for ( k=0 ; k < nrpack ; k++){
		q = newInstruction(cmb,ASSIGNsymbol);
		getArg(q,0) = getArg(pack[k],0);
		pushNil(cmb,q, getArgType(cmb,pack[k],0));
		pushInstruction(cmb,q);
	}
	*/

#ifdef REMOTE_EXECUTION
	/* PHASE 1: run in distributed  mode */
	q= newFcnCall(cmb,schedulerRef,srvpoolRef);
	q->barrier= BARRIERsymbol;
	barrier = getArg(q,0);
	setVarType(cmb,x,TYPE_int);

	/* get servers to execute the query */
	q= newStmt(cmb,srvpoolRef,putName("query",5));
	q->retc= q->argc = 0;
	for( i = 0; i < nrservers; i++)
		q= pushReturn(cmb,q, newTmpVariable(cmb,TYPE_str));
	q= pushStr(cmb,q,plan);
	p= q;

	for ( i = 0; i < nrservers ; i++) {
		q= copyInstruction(getInstrPtr(pmb,0));
		q->token = ASSIGNsymbol;
		q->barrier = 0;
		q->argc -= 2; /* remove the bounds */
		for ( k=0 ; k < q->retc; k++) {
			getArg(q,k) = newTmpVariable(cmb, getArgType(pmb,q,k));
			pack[k] = pushArgument(cmb,pack[k], getArg(q,k));
		}

		if ( slices->column){
			/* add the splitter arguments */
			q= pushArgument(cmb,q,alias[i]);
			q= pushArgument(cmb,q,alias[i+1]);
		}
		/* for distributed execution we use the stub */
		getFunctionId(q) = stub;
		q= setArgument(cmb,q,q->retc, getArg(p,i));
		pushInstruction(cmb,q);
	}

	/* put all mat.pack instructions into the program
	  make sure that they have contiguous void headed columns 
	*/
	p = getInstrPtr(pmb,0);
	if ( slices->column) 
	for ( k=0 ; k < nrpack; k++) {
		pushInstruction(cmb, pack[k]);
		getArg(pack[k],0)= getArg(p,k);
	}

	/* finalize the dataflow block */
	q= newAssignment(cmb);
	q->barrier = EXITsymbol;
	getArg(q,0) = barrier;
#else
	/* PHASE 2 The second block runs the query in local mode */
	/* re-use instructions, injecting missing server selections */
	base = cmb->stop;
	for ( i = 0; i < nrservers ; i++) {
		q= copyInstruction(getInstrPtr(cmb,base + i));
		getFunctionId(q) = plan;
		delArgument(q,q->retc);
		pushInstruction(cmb,q);
	}
	/* put all mat.pack instructions into the program
	  make sure that they have contiguous void headed columns 
	*/
	p = getInstrPtr(pmb,0);
	if ( slices->column) 
	for ( k=0 ; k < nrpack; k++) {
		pushInstruction(cmb, copyInstruction(pack[k]));
		getArg(pack[k],0)= getArg(p,k);
	}
#endif

	/* consolidate the result */
	ret = copyInstruction(getInstrPtr(cmb,0));
	clrFunction(ret);
	ret->barrier = RETURNsymbol;
	ret->argc = ret->retc;
	/* make it a correct assignment to ensure ref counts */
	for( k= 0; k< ret->retc; k++) {
		setVarUsed(cmb,getArg(ret,k));
		ret = pushArgument(cmb,ret,getArg(ret,k));
	}
	pushInstruction(cmb,ret);
	getInstrPtr(cmb,0)->argc -= 2;

	pushEndInstruction(cmb);
	GDKfree(alias);
	GDKfree(pack);

	return cmb;
}

static MalBlkPtr
OPTplanStub(Client cntxt, MalBlkPtr mb, MalBlkPtr pmb, oid plantag)
{
	MalBlkPtr smb = 0;
	Symbol s;
	InstrPtr sig, q, ret;
	int j,k,conn, *arg;
	char nme[BUFSIZ];

	/* define the sub query stub for remote processing */
	snprintf(nme,BUFSIZ,"%s_stub",getFunctionId( getInstrPtr(mb,0)));
	s = newFunction(userRef, putName(nme, strlen(nme)),FUNCTIONsymbol);
	if ( s == NULL)
		return 0;
	freeMalBlk(s->def);
	s->def = copyMalBlk(pmb);	/* get variables */
	smb = s->def;
	if ( newMalBlkStmt(smb,smb->ssize) < 0 )
		return 0;
	pushInstruction(smb, copyInstruction(pmb->stmt[0]));
	getFunctionId( getInstrPtr(smb,0)) = putName(nme,strlen(nme));
	insertSymbol(cntxt->nspace,s);

	conn = newTmpVariable(smb, TYPE_str);
	setArgument(smb,getInstrPtr(smb,0), getInstrPtr(smb,0)->retc, conn);
	/* conn = getArg(q,0);*/

	sig = getInstrPtr(smb,0);
	arg = (int*) GDKzalloc(sizeof(int) * sig->argc);
	/* k:= remote.put(conn,kvar) */
	for (j= sig->retc+1; j < sig->argc; j++) {
		q= newFcnCall(smb,remoteRef,putRef);
		setVarType(smb, getArg(q,0), TYPE_str);
		setVarUDFtype(smb, getArg(q,0));
		q= pushArgument(smb,q,conn);
		q= pushArgument(smb,q,getArg(sig,j));
		arg[j]= getArg(q,0);
	}
	for (j= 0; j < sig->retc; j++) {
		q= newFcnCall(smb,remoteRef,putRef);
		setVarType(smb, getArg(q,0), TYPE_str);
		setVarUDFtype(smb, getArg(q,0));
		q= pushArgument(smb,q,conn);
		q= pushArgument(smb,q,getArg(sig,j));
		arg[j]= getArg(q,0);
	}

	/* (k1,...kn):= remote.exec(conn,srvpool,qry,version....) */
	snprintf(nme, BUFSIZ, "%s_plan"OIDFMT, getFunctionId( getInstrPtr(mb,0)), plantag);
	q = newInstruction(smb,ASSIGNsymbol);
	getModuleId(q) = remoteRef;
	getFunctionId(q) = execRef;
	q->retc=  q->argc= 0;
	for (j=0; j < sig->retc; j++)
		q = pushReturn(smb,q,arg[j]);
	q= pushArgument(smb,q,conn);
	q= pushStr(smb,q,userRef);
	q= pushStr(smb,q,putName(nme,strlen(nme)));
	/* deal with all arguments ! */
	for (j=sig->retc+1; j < sig->argc; j++)
		q = pushArgument(smb,q,arg[j]);
	pushInstruction(smb,q);

	/* return exec_qry; */
	ret = newInstruction(smb, ASSIGNsymbol);
	ret->barrier= RETURNsymbol;
	ret->argc = ret->retc = 0;
	/* l:=remote.get(conn,k) */
	for ( j=0; j< sig->retc; j++){
		q= newFcnCall(smb,remoteRef,getRef);
		q= pushArgument(smb,q,conn);
		q= pushArgument(smb,q,arg[j]);
		k= getArg(q,0);
		setVarType(smb,k, getArgType(smb,sig,j));
		setVarUDFtype(smb, k);
		ret = pushArgument(smb,ret,k);
		ret = pushReturn(smb,ret,getArg(sig,j));
	}

/*
    newCatchStmt(smb, "ANYexception");
    q = newStmt(smb, remoteRef, disconnectRef);
    pushArgument(smb, q, conn);
    newRaiseStmt(smb, "ANYexception");   
    newExitStmt(smb, "ANYexception");

    q = newStmt(smb, remoteRef, disconnectRef);
    pushArgument(smb, q, conn);
*/
	if ( sig->retc)
		pushInstruction(smb,ret);
    pushEndInstruction(smb);

	GDKfree(arg);
	return smb;
}

/* prepare access to partitions by injection of the materialize instructions */
static int
OPTpreparePartition(MalBlkPtr nmb, InstrPtr p, Slices *slices, int pc)
{
	InstrPtr q;
	int i,fnd,parallel = 0;

	if ( slices->slice == 0){
		slices->slice = newTmpVariable(nmb, getVarType(nmb, getArg(slices->target,0)));
		setVarUDFtype(nmb, slices->slice);
		setVarUsed(nmb, slices->slice);
		nmb->stmt[0] = pushArgument(nmb, nmb->stmt[0], slices->lslices);
		nmb->stmt[0] = pushArgument(nmb, nmb->stmt[0], slices->hslices);
		parallel=2;	/* return number of arguments added for later disposal */
	} 
	/* check if the partition column instruction is already added */
	fnd =0;
	for ( i = pc -1; i > 0 && fnd == 0; i--){
		q= getInstrPtr(nmb,i);
		fnd = getFunctionId(q) && getModuleId(q) == sqlRef && getFunctionId(q) == bindRef &&
			  strcmp(slices->column, getVarConstant(nmb, getArg(p,2)).val.sval) == 0 &&
			  strcmp(slices->column, getVarConstant(nmb, getArg(p,3)).val.sval) == 0;
	}
	if ( fnd == 0)
		pushInstruction(nmb, p = copyInstruction(slices->target));
	q= newInstruction(nmb,ASSIGNsymbol);
	/* add the slices->to the call */
	q= pushArgument(nmb,q, getArg(p,0));
	q= pushArgument(nmb,q, slices->lslices);
	q= pushArgument(nmb,q, slices->hslices);
	setModuleId(q,algebraRef);
	setFunctionId(q,selectRef);
	getArg(q,0)= slices->slice;
	getArg(q,1) = getArg(p,0);
	q= pushBit(nmb,q,TRUE);
	q= pushBit(nmb,q,FALSE);
	pushInstruction(nmb,q);
	return parallel;
}

/*
 * For bind instructions we have to inject materialize and semijoin instructions
*/
static int 
OPTsliceColumn(Client cntxt, MalBlkPtr nmb, MalBlkPtr mb, InstrPtr p, Slices *slices, int pc)
{
	int k, parallel = 0;
	InstrPtr q;

	(void) cntxt;
	if ( ! (getModuleId(p) == sqlRef && getFunctionId(p) == bindRef )  &&
		 ! (getModuleId(p) == sqlRef && getFunctionId(p) == bindidxRef ) ) {
		pushInstruction(nmb,p);
		return 0;
	}
	if ( ! (strcmp(slices->schema, getVarConstant(mb, getArg(p,2)).val.sval) == 0 &&
		strcmp(slices->table, getVarConstant(mb, getArg(p,3)).val.sval) == 0) ) {
		pushInstruction(nmb,p);
		return 0;
	}

	if ( slices->slice == 0)
		parallel =OPTpreparePartition(nmb, p, slices, pc);

	if (strcmp(slices->column, getVarConstant(nmb, getArg(p,4)).val.sval) )   {
		/* sideways projection the range selection */
		pushInstruction(nmb,p);
		q= newInstruction(nmb,ASSIGNsymbol);
		setModuleId(q,algebraRef);
		setFunctionId(q,semijoinRef);
		k = newTmpVariable(nmb, getVarType(mb, getArg(p,0)));
		setVarUDFtype(nmb,k);
		setVarUsed(nmb,k);
		getArg(q,0)= getArg(p,0);
		getArg(p,0)= k;
		q= pushArgument(nmb,q, k);
		q= pushArgument(nmb,q, slices->slice);
		pushInstruction(nmb,q);
	} else {
		q= newInstruction(nmb,ASSIGNsymbol);
		k = newTmpVariable(nmb, getVarType(mb, getArg(p,0)));
		setVarUDFtype(nmb,k);
		setVarUsed(nmb,k);
		getArg(q,0)= getArg(p,0);
		getArg(p,0)= k;
		q= pushArgument(nmb,q, slices->slice);
		pushInstruction(nmb,q);
	}
	return parallel;
} 

/* 
 * The plan is analysed for the maximal subplan that involves a partitioned table
 * and that does not require data exchanges.
 * Algebraic operators that can be executed on fragments are delegated too.
 * For example join(A,B) where A is fragmented and B is not can be done elsewhere.
 * In all cases we should ensure that the result of the remote execution can be
 * simply unioned together.
 * All plans should be uniquely tagged, because we have to avoid potential conflicts
 * when a connection is re-used by different client sessions.
*/
#define BLOCKED 1
#define REQUIRED 2
#define SUPPORTIVE 3
#define EXPORTED 4
#define KEEPLOCAL 5

#ifdef _DEBUG_OPT_CENTIPEDE_ 
static char *status[6]= {"", "blocked  ", "required ", "support  ", "exported ", "keeplocal "};
#endif

static int 
OPTplanFragment(Client cntxt, MalBlkPtr mb, Slices *slices)
{
	int *plan,*vars;
	int i, j, k, limit, last;
	InstrPtr ret, call, p, *old;
	Symbol s;
	MalBlkPtr nmb, cmb, smb;
	str msg;
	char nme[BUFSIZ];
	char *head, *tail; /* oid reference to target table*/
	oid plantag= OIDnew(1);

	plan = GDKzalloc(mb->ssize * sizeof(int));
	if( plan == 0)
		return 0;
	vars = GDKzalloc(mb->vsize * sizeof(int));
	if( vars == 0){
		GDKfree(plan);
		return 0;
	}

	snprintf(nme,BUFSIZ,"%s_plan"OIDFMT,getFunctionId( getInstrPtr(mb,0)), plantag);
	s = newFunction(userRef, putName(nme, strlen(nme)),FUNCTIONsymbol);
	if ( s == NULL)
		return 0;
	freeMalBlk(s->def);
	s->def = copyMalBlk(mb);
	nmb = s->def;

	limit = nmb->stop;
	old = nmb->stmt;
	if ( newMalBlkStmt(nmb,nmb->ssize) < 0 )
		return 0;
	head = GDKzalloc(mb->vsize);
	tail = GDKzalloc(mb->vsize);

#ifdef _DEBUG_OPT_CENTIPEDE_
	mnstr_printf(cntxt->fdout,"#Remote plan framework\n");
	mnstr_printf(cntxt->fdout,"#partition %s.%s.%s type %d\n",
		slices->schema,
		slices->table,
		(slices->column ? slices->column: ""),
		slices->type);
#else
	(void) slices;
#endif

	/* Phase 1: determine all variables/instructions indirectly dependent on a fragmented column */
	last = limit;
	for ( i = 1; i < limit ; i++) {
		p = old[i];
		if ( p->token == ENDsymbol || i > last) {
			plan[i] = REQUIRED;
			last = i;
		} else
		if ( getModuleId(p) == sqlRef && (getFunctionId(p) == bindRef || getFunctionId(p) == bindidxRef) &&
			strcmp(slices->schema, getVarConstant(mb, getArg(p,2)).val.sval) == 0 &&
			strcmp(slices->table, getVarConstant(mb, getArg(p,3)).val.sval) == 0 ) {
			plan[i] = REQUIRED;
			head[getArg(p,0)] = 1;
			tail[getArg(p,0)] = getFunctionId(p) != bindidxRef;
		} 

		/* blocking instructions are those that require data exchange or total view */
		if (    getModuleId(p) == algebraRef && getFunctionId(p) == joinRef ) {
			/* be aware that supportive subqueries may produce pivot sets */
			/* this means we have to enforce the following */
			if ( vars[getArg(p,1)] == REQUIRED && vars[getArg(p,2)] != REQUIRED  ) {
				plan[i] = SUPPORTIVE;
				head[getArg(p,0)] = 1;
			}
		} else
		if (    getModuleId(p) == algebraRef && getFunctionId(p) == leftjoinRef ) {
				head[getArg(p,0)] = head[getArg(p,1)];
				tail[getArg(p,0)] = tail[getArg(p,1)];
				if ( head[getArg(p,0)] + tail[getArg(p,0)])
					plan[i] = REQUIRED;
		} else
		if (    getModuleId(p) == algebraRef && (getFunctionId(p)==markTRef || getFunctionId(p)== thetauselectRef) )  {
			if (vars[getArg(p,p->retc)] == REQUIRED ) {
				head[getArg(p,0)] = 1;
				plan[i] = REQUIRED;
			} 
		} else
		if (    getModuleId(p) == algebraRef && getFunctionId(p)==markHRef )  {
			if (vars[getArg(p,p->retc)] == REQUIRED )
				tail[getArg(p,0)] = 1;
		} else
		if (    getModuleId(p) == batRef && getFunctionId(p)==reverseRef )  {
			if (vars[getArg(p,p->retc)] == REQUIRED ){
				head[getArg(p,0)] = tail[getArg(p,p->retc)];
				tail[getArg(p,0)] = head[getArg(p,p->retc)];
				plan[i] = REQUIRED;
			}
		} else
		if (   (getModuleId(p) == groupRef && (getFunctionId(p) == doneRef || getFunctionId(p) == newRef ||getFunctionId(p) == deriveRef) )  ||
				getModuleId(p) == pqueueRef || getModuleId(p) == aggrRef ){
			/* this is blocking for partitioned columns, this can be achieved by propagating the REQUIRED property over variables */
			for( j = p->retc; j < p->argc; j++)
			if (vars[getArg(p,j)] == REQUIRED )
				break;
		} 

		if( plan[i] == BLOCKED){
			for ( j= 0; j< p->retc; j++)
				vars[getArg(p,j)] = BLOCKED;
		} else {
			/* one blocking argument blocks the instruction */
			for( j = p->retc; j < p->argc; j++)
			if (vars[getArg(p,j)] == BLOCKED ) 
				break;
			if ( j != p->argc )
				plan[i]= BLOCKED;

			/* one required then instruction is needed */
			k = 0;
			for( j = p->retc; j < p->argc; j++)
			if (vars[getArg(p,j)] == REQUIRED )
				k++;
			if (k && k == p->argc-p->retc && plan[i] != BLOCKED )
				plan[i]= REQUIRED;
			else
			if ( k  && plan[i] != BLOCKED )
				plan[i] = REQUIRED;

			for ( j= 0; j< p->retc; j++)
			if ( vars[getArg(p,j)] == 0)
				vars[getArg(p,j)] = plan[i];
		}
	}

	/* Phase 2: extend the set of supportive instructions.
	   we have to avoid common ancestor dependency on partitioned variables
	*/
	for ( i = limit -1; i >= 0 ; i--)
	if ( plan[i] != BLOCKED ){
		p = old[i];

		for( j = 0; j < p->argc; j++)
		if ( vars[getArg(p,j)] == SUPPORTIVE || vars[getArg(p,j)] == REQUIRED)  
			break;

		if( j< p->argc) {
			for ( j= p->retc; j< p->argc; j++)
			if ( vars[getArg(p,j)] != REQUIRED)
				vars[getArg(p,j)] = SUPPORTIVE;
			if ( plan[i] != REQUIRED)
				plan[i] = SUPPORTIVE;
		}
		/* be careful in adding operations that require exchange or full view */
		if (    (getModuleId(p) == sqlRef && (getFunctionId(p) == resultSetRef || getFunctionId(p) == putName("exportValue",11) ) )  ||
				getModuleId(p) == ioRef )
			plan[i] = BLOCKED;
		if (getModuleId(p) == algebraRef && getFunctionId(p) == joinRef )  {
			/* if we produce an oid/oid based on the target, then we need an exchange */
			if ( head[getArg(p,1)] && tail[getArg(p,2)] )
				plan[i] = BLOCKED;
		}
		if (    (getModuleId(p) == groupRef && (getFunctionId(p) == doneRef || getFunctionId(p) == newRef ||getFunctionId(p) == deriveRef) )  ||
				getModuleId(p) == pqueueRef || getModuleId(p) == aggrRef || getModuleId(p) == ioRef ) {
			/* this is blocking for partitioned columns, this can be achieved by propagating the REQUIRED property over variables */
			for( j = p->retc; j < p->argc; j++)
			if (vars[getArg(p,j)] == REQUIRED )
				break;
			if ( j != p->argc)
				plan[i] = BLOCKED;
		}
	}
	/* Phase 3: check all instructions for blocked arguments.
	   The variable may not be produced by a blocked instruction
	   and all arguments must be required/supportive/constant
	   (not blocked)
	*/
	for ( i = 0; i < limit; i++) 
	if( plan[i] != 0){
		p = old[i];
		for( j = 0; j < p->argc; j++)
		if (vars[getArg(p,j)] == BLOCKED)
			break;
		if( j != p->argc || plan[i] == BLOCKED) {
			plan[i] = BLOCKED;
			for( j = 0; j < p->retc; j++)
				vars[getArg(p,j)] = BLOCKED;

		}
		for( j = 0; j < p->argc; j++)
		if (vars[getArg(p,j)] == REQUIRED)
			break;
		if( j != p->argc && plan[i] != BLOCKED ) 
			for( j = 0; j < p->retc; j++)
				vars[getArg(p,j)] = REQUIRED;

	}
#ifdef _DEBUG_OPT_CENTIPEDE_ 
	mnstr_printf(cntxt->fdout,"\n#phase 3\n");
	for( i= 0; i< limit; i++)
	if (plan[i] ) {
		int x = old[i]->argv[0];
		mnstr_printf(cntxt->fdout,"%s %c%c ",status[plan[i]], head[x]+'0', tail[x]+'0');
		if( old[i])
			printInstruction(cntxt->fdout, mb,0,old[i],LIST_MAL_STMT);
	}
#endif
	/* Phase 4: determine all variables to be exported 
	   this is limited to all variables produced but not consumed
	   and only those that have an oid of the target
	*/
	ret= newInstruction(nmb,ASSIGNsymbol);
	ret->barrier = RETURNsymbol;
	ret->argc= ret->retc = 0;

	for ( i = limit-1; i >= 0 ; i--)
	if ( plan[i] == REQUIRED || plan[i] == SUPPORTIVE ){
		p = old[i];
		for ( j=0; j < p->retc; j++)
		if ( vars[getArg(p,j)] == REQUIRED  && isaBatType(getArgType(nmb,p,j)) )
				vars[getArg(p,j)] = EXPORTED;
		else
		if ( vars[getArg(p,j)] != 0 && vars[getArg(p,j)] != KEEPLOCAL  && vars[getArg(p,j)] != SUPPORTIVE && isaBatType(getArgType(nmb,p,j)) ) {
			/* limit the number of returned BATs to those that are expensive */
			if ( (getModuleId(p) == algebraRef && (getFunctionId(p) == markHRef || getFunctionId(p) == markTRef)) ||
				 (getModuleId(p) == batRef && (getFunctionId(p) == reverseRef || getFunctionId(p) == mirrorRef )) )
				continue;
#ifdef _DEBUG_OPT_CENTIPEDE_ 
		mnstr_printf(cntxt->fdout,"#phase 4 export %d\n", getArg(p,j));
#endif
			vars[getArg(p,j)] = EXPORTED;
		}
		for ( j=p->retc; j< p->argc; j++)
		if ( vars[getArg(p,j)] != EXPORTED)
			vars[getArg(p,j)] = KEEPLOCAL;
	}
	for ( i = 0; i< limit; i++)
	{
		p = old[i];
		for( j = p->retc; j < p->argc; j++)
		if ( vars[getArg(p,j)] == EXPORTED ){
			for ( k = 0; k < ret->retc; k++)
			if (getArg(ret,k) == getArg(p,j))
				break;
			if ( k == ret->retc) 
				ret= pushReturn(nmb,ret, getArg(p,j));
		}
	}

	/* Phase 4: Bake a new function that produces them */

	p = copyInstruction(getInstrPtr(mb, 0));
	getModuleId(p) = userRef;
	pushInstruction(nmb,p);

	for ( i = 1; i < limit ; i++) 
	if( plan[i] == REQUIRED || plan[i] == SUPPORTIVE ) {
		p = copyInstruction(getInstrPtr(mb, i));
		if ( old[i]->token == ENDsymbol) {
			getFunctionId(nmb->stmt[0]) = putName(nme,strlen(nme));
			pushInstruction(nmb,ret);
			pushEndInstruction(nmb);
		} else
		if (getModuleId(p) == sqlRef && (getFunctionId(p) == bindRef || getFunctionId(p) == bindidxRef))  
			OPTsliceColumn(cntxt, nmb, mb, p, slices, nmb->stop);
		else
			pushInstruction(nmb,p);
	}

	/* fix the signature and modify the underlying plan */
	while ( nmb->stmt[0]->retc )
		delArgument(nmb->stmt[0],0);
	for( i =0; i< ret->retc; i++) {
		nmb->stmt[0]= pushReturn(nmb, nmb->stmt[0], getArg(ret,i));
		for( j = 0; j< mb->stop; j++) {
			p = getInstrPtr(mb,j);
			for ( k = 0; k< p->retc; k++)
			if( getArg(p,k) == getArg(ret,i))
				getArg(p,k) = newTmpVariable(mb, getArgType(mb,p,k));
		}
	}

	insertSymbol(cntxt->nspace,s);
#ifdef _DEBUG_OPT_CENTIPEDE_
	mnstr_printf(cntxt->fdout,"#rough plan errors %d \n", nmb->errors);
	//printFunction(cntxt->fdout, nmb, 0, LIST_MAL_STMT);
#endif

	/* construct the remote stub plan */
	smb = OPTplanStub(cntxt, mb, nmb, plantag);
	msg= optimizeMALBlock(cntxt, smb);
	if ( smb) 
		chkProgram(cntxt->fdout, cntxt->nspace, smb);
#ifdef _DEBUG_OPT_CENTIPEDE_
	mnstr_printf(cntxt->fdout,"#stub plan errors %d %s \n",smb->errors,msg?msg:"");
	printFunction(cntxt->fdout, smb, 0, LIST_MAL_STMT);
#endif

	/* construct the control plan for local/remote execution */
	cmb = OPTplanCntrl(cntxt,mb,nmb, slices, plantag);
	msg= optimizeMALBlock(cntxt, cmb);
	if ( cmb) 
		chkProgram(cntxt->fdout, cntxt->nspace, cmb);
#ifdef _DEBUG_OPT_CENTIPEDE_
	mnstr_printf(cntxt->fdout,"#control plan errors %d %s \n",cmb->errors,msg?msg:"");
	printFunction(cntxt->fdout, cmb, 0, LIST_MAL_STMT);
#endif

	call = copyInstruction(getInstrPtr(nmb,0));
	call->barrier = 0;
	call->token = ASSIGNsymbol;
	call->argc -= 2; /* bounds are removed */
	getFunctionId(call) = getFunctionId(getInstrPtr(cmb,0));
	insertInstruction(mb,call, 1);

#ifdef _DEBUG_OPT_CENTIPEDE_
	mnstr_printf(cntxt->fdout,"#non-optimized remote plan error %d %s\n", nmb->errors, msg?msg:"");
	printFunction(cntxt->fdout, nmb, 0, LIST_MAL_ALL);
	msg= optimizeMALBlock(cntxt, nmb);
	chkProgram(cntxt->fdout, cntxt->nspace, nmb);
	mnstr_printf(cntxt->fdout,"#optimized remote plan error %d %s\n", nmb->errors, msg?msg:"");
	printFunction(cntxt->fdout, nmb, 0, LIST_MAL_STMT);
#endif
	GDKfree(plan);
	GDKfree(vars);
	return 0;
}

/*
 * The general tactic is to identify instructions that are blocked in a distributed setting.
 * For those instruction we inject a multi-assignment to map is arguments to new variables
 * and the aliases are propagated thru the plan.
 * The next step is to derived a distribution consolidation plan for all arguments whose
 * portions are needed.
*/
static int
OPTcentipedeImplementation(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	int i;
	wrd r = 0, rowcnt=0;	/* table should be sizeable to consider parallel execution*/
	InstrPtr q, target= 0;
	Slices slices;
	str msg = NULL;
	MalBlkPtr  omb;

	(void)cntxt;
	(void) stk;
	(void) pci;

	msg = GDKgetenv("gdk_readonly");
	if( msg == 0 || strcmp(msg,"yes"))
		mnstr_printf(cntxt->fdout,"#WARNING centipede only works for readonly databases\n");
	if ( nrservers == 0)
		nrservers = 2; /* to ease debugging now */

	/* modify the block as we go */
	omb= copyMalBlk(mb);
	memset((char*) &slices,0, sizeof(slices));
	/* locate the largest non-partitioned table */
	/* Much more intelligence can be injected here */
	for (i=1; i< mb->stop; i++){
		q= getInstrPtr(mb,i);
		if ( ! (getModuleId(q) == sqlRef && getFunctionId(q) == bindRef ) )
			continue;
		/* don't split insert BATs */
		if (getVarConstant(mb, getArg(q,5)).val.ival != 0 )
			continue;
		r = getVarRows(mb, getArg(q, 0));
		if (r > rowcnt && getTailType( getArgType(mb,q,0)) <= TYPE_str){
			rowcnt = r;
			target = q;
			r = 0;
		}
	}
	if (target == 0)
		return 0;

	/* the target becomes the table against which we break the query */
	/* for the time being assume we use the first column of the target*/
	slices.target = target;
	slices.schema = GDKstrdup(getVarConstant(mb, getArg(target,2)).val.sval);
	slices.table = GDKstrdup(getVarConstant(mb, getArg(target,3)).val.sval);
	slices.column = GDKstrdup(getVarConstant(mb,getArg(target,4)).val.sval);
	slices.type = getTailType(getVarType(mb,getArg(target,0)));
	slices.lslices=  newTmpVariable(mb, slices.type);
	slices.hslices=  newTmpVariable(mb, slices.type);
	slices.slice = 0;

	OPTDEBUGcentipede
		mnstr_printf(cntxt->fdout,"#opt_centipede: target is %s.%s "
			" with " SSZFMT " rows into %d servers\n",
				getVarConstant(mb, getArg(slices.target,2)).val.sval,
				getVarConstant(mb, getArg(slices.target,3)).val.sval,
				rowcnt, nrservers);

	/* derive a local plan based on forward flow reasoning */
	if( OPTplanFragment(cntxt, mb, &slices)== 0) {
		/* bake the controller function */
	} 
#ifdef DEBUG_DETAIL
	mnstr_printf(cntxt->fdout,"#orig BEFORE optimizer test\n");
	printFunction(cntxt->fdout, mb, 0, LIST_MAL_STMT);
#endif
#ifdef _DEBUG_OPT_CENTIPEDE_
	msg= optimizeMALBlock(cntxt, mb);
	chkProgram(cntxt->fdout, cntxt->nspace, mb);
	mnstr_printf(cntxt->fdout,"#partition %s.%s.%s type %d %s\n",
		slices.schema,
		slices.table,
		(slices.column ? slices.column: ""),
		slices.type,
		msg?msg:"");
	printFunction(cntxt->fdout, mb, 0, LIST_MAL_STMT);
#endif
	GDKfree(slices.schema);
	GDKfree(slices.table);
	if (msg || mb->errors ) {
		/* restore MAL block */
		mnstr_printf(cntxt->fdout,"#partition %s\n", msg?msg:"generic error");
		/* freeMalBlk(mb);*/
		*mb = *omb;
		return 0;
	}
	return 1;
}
@include optimizerWrapper.mx
@c
#include "opt_statistics.h"
#include "algebra.h"
@:wrapOptimizer(centipede,OPT_CHECK_ALL)@

/*
 * @-
 */
@= histo
	{ 	@1 *vv;
		@1 *p = (@1*)Hloc(uniq, BUNfirst(uniq));
		int step = (int) (BATcount(uniq) / (pci->retc-1));

		/* extract split points from the sample */
		/* bounds are unspecified */
		for ( j=step, i = 0; i < pci->retc; i++) {
			vv= (@1 *) getArgReference(stk, pci, i );
			if ( i > 0 && i< pci->retc-1){
				*vv = p[j]; j+= step;
			} else
				*vv = @1_nil;
		}
	}

@c

/* the min/max bounds are null values */
/* It is the heart of the approach and requires experimentation */
str
OPTvector(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{	
	BAT *b, *sample, *uniq;
	int bid = *(int*) getArgReference(stk,pci, pci->argc-1);
	int i, j;
	ptr vx;

	(void) cntxt;
	(void) mb;
	if ( pci->retc < 2)
		throw(SQL,"centipede.vector","Not enough slices");
	b = BATdescriptor(bid);
	if (b == NULL)
		throw(SQL,"centipede.vector","Can not access BAT");
	sample= BATsample(b,1000);
	uniq = BATkunique(BATmirror(sample));
    switch ( ATOMtype(b->ttype)) {
    case TYPE_bit: @:histo(bit,"%d")@ break;
    case TYPE_bte: @:histo(bte,"%d")@ break;
    case TYPE_sht: @:histo(sht,"%d")@ break;
    case TYPE_int: @:histo(int,"%d")@ break;
    case TYPE_wrd: @:histo(wrd,wval)@ break;
    case TYPE_lng: @:histo(lng,"%d")@ break;
    case TYPE_oid: @:histo(oid,OIDFMT)@ break;
    case TYPE_flt: @:histo(flt,"%f")@ break;
    case TYPE_dbl: @:histo(dbl,"%f")@ break;
	case TYPE_str:
		/* fake split, ignore the data distribution */

		j = pci->retc > 26 ?26 : pci->retc;
		for ( i = 1; i < pci->retc-1; i++) {
			char buf[BUFSIZ];
			snprintf(buf,BUFSIZ,"%c", 'a' + 26 / j);
			vx= (ptr) getArgReference(stk, pci, i );
			*(str*)vx = GDKstrdup(buf);
		}
		break;
	default:
		throw(SQL,"sql.centipede","Can not slice column ");
    }

	BBPreleaseref(bid);
	BBPreleaseref(sample->batCacheid);
	BBPreleaseref(uniq->batCacheid);
	return MAL_SUCCEED;
}

str OPTcentipedeMaterialize(int *result, int *bid, ptr low, ptr high)
{
	bit bitlow=TRUE, bithigh= FALSE;

	return ALGselectInclusive( result, bid, low, high, &bitlow, &bithigh);
}
