@/
The contents of this file are subject to the MonetDB Public License
Version 1.1 (the "License"); you may not use this file except in
compliance with the License. You may obtain a copy of the License at
http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html

Software distributed under the License is distributed on an "AS IS"
basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations
under the License.

The Original Code is the MonetDB Database System.

The Initial Developer of the Original Code is CWI.
Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
Copyright August 2008-2011 MonetDB B.V.
All Rights Reserved.
@

@f opt_garbageCollector
@a M. Kersten
@- Garbage Collection
Garbage collection of temporary variables, such as strings and BATs,
takes place upon returning from a function call. Especially for BATs
this may keep sizable resources locked longer than strictly necessary.
Although the programmer can influence their lifespan by assignment
of the @sc{nil}, thereby triggering the garbage collector,
it is more appropriate to rely on an optimizer to inject these statements. 
For, it keeps the program smaller and a better
target for code-optimizations.

The operation @sc{optimizer.garbageCollector()} removes all 
BAT references that are at their end of life to make room for new ones.
It is typically called as one of the last optimizer steps.
A snippet of a the effect of the garbage collector:
@verbatim
    t1 := bat.new(:oid,:int);
    t2 := array.grid(132000,8,1,0);
    t3 := array.grid(1,100,10560,0);
    t4 := array.grid(1,100,10560,0,8);
    t5 := batcalc.+(t2,t4);
    t6 := batcalc.oid(t5);
    t7 := algebra.join(t6,t1);
    optimizer.garbageCollector();
@end verbatim
is translated into the following code block:
@verbatim
    t1 := bat.new(:oid,:int);
    t2 := array.grid(132000,8,1,0);
    t3 := array.grid(1,100,10560,0);
    t4 := array.grid(1,100,10560,0,8);
    t5 := batcalc.+(t2,t4);
    bat.setGarbage(t2);
    bat.setGarbage(t4);
    t6 := batcalc.oid(t5);
    bat.setGarbage(t5);
    t7 := algebra.join(t6,t1);
    bat.setGarbage(t6);
    bat.setGarbage(t1);
@end verbatim

The current algorithm is straight forward. After each instruction,
we check whether its BAT arguments are needed in the future.
If not, we inject a garbage collection statement to release them,
provided there are no other reasons to retain it.
This should be done carefully, because the instruction may be part of a loop.
If the variable is defined inside the loop, we can safely remove it. 

@{
A variable can only be released in the scope in which
it is introduced. This means we need an overview of
the scope nesting and maintain a list of variables
still to be garbage collected.

We don;t have to worry about pre-mature return from the
function, because this will trigger garbage collection
anyway.

This optimizer should not be called when the scheduler
intends to keep intermediates around for re-use.
@mal
pattern optimizer.garbageCollector():str
address OPTgarbageCollector;
pattern optimizer.garbageCollector(mod:str, fcn:str):str
address OPTgarbageCollector
comment "Garbage collector optimizer";
@h
#ifndef _MAL_GARBAGE_
#define _MAL_GARBAGE_
#include "opt_support.h"

@:exportOptimizer(garbageCollector)@

#define OPTDEBUGgarbageCollector  if ( optDebug & (1 <<DEBUG_OPT_GARBAGE) )

#endif
@c
#include "monetdb_config.h"
#include "opt_garbageCollector.h"
#include "mal_interpreter.h"	/* for showErrors() */
#include "mal_builder.h"
#include "opt_prelude.h"
#include "mal_properties.h"

@-
There are three ways to release a BAT. The cheapest one is to
let the system do it automatically upon last use. Alternative,
to assign a nil value, which triggers the decrement
of the reference count. The second option is to call a function,
which could take care of more things, such as saving
potential interesting results or issueing a memory map advice.
Furthermore, it makes sense to only release larger temporary BATs
during the execution, because they may unnecessarily push base
tables out of memory.
@= releaseBATbyFunction
{
	q= newInstruction(NULL,ASSIGNsymbol);
	setModuleId(q,batRef);
	setFunctionId(q,putName("flush",5));
	q= pushArgument(mb,q,getArg(p,j));
	getArg(q,0) = newTmpVariable(mb,TYPE_any);
	pushInstruction(mb,q);
	typeChecker(s,mb,q,TRUE);
}
@-
@{
[this is dropped, because memory footprint should
be handled at a different level, it incurs reshuffling
code and calls for a cost-based assessment ]
One of the sources for resource consumption are auxilary
datastructures introduced to speed up an algorithm,
e.g. building a hash-table.
Since such structures are 'dirty' memory pages, they may
become the target for forced write to disk.
To void this situation, the garbage collector injects
an early release of resources.
This step is only take against private (=temporary)
tables.
@= releaseHash
{
	q= newInstruction(NULL,ASSIGNsymbol);
	setModuleId(q,batRef);
	setFunctionId(q,putName("reduce",6));
	q= pushArgument(mb,q,getArg(p,j));
	getArg(q,0) = getArg(p,j);
	pushInstruction(mb,q);
	typeChecker(s,mb,q,TRUE);
	actions++;
}
@}
@-
Keeping variables around beyond their end-of-life-span
can be marked with the proper 'keep'.
@c
static int
OPTgarbageCollectorImplementation(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	int i, j, k, n = 0, limit, vlimit, depth=0, slimit;
	InstrPtr p, q, *old;
	int actions = 0;
	Lifespan span;

	(void) pci;
	(void) cntxt;
	(void) stk;
	if (varGetProp(mb, getArg(mb->stmt[0], 0), inlineProp) != NULL)
		return 0;

	span = setLifespan(mb);
	if ( span == NULL)
		return 0;

	old= mb->stmt;
	limit = mb->stop;
	slimit = mb->ssize;
	vlimit = mb->vtop;
	if ( newMalBlkStmt(mb,mb->ssize) < 0) {
		GDKfree(span);
		return 0;
	}

	p = NULL;
	for (i = 0; i < limit; i++) {
		p = old[i];
		p->gc &=  ~GARBAGECONTROL;

		if ( p->barrier == RETURNsymbol){
			pushInstruction(mb, p);
			continue;
		}
		if (blockStart(p) )
			depth++;
		if ( p->token == ENDsymbol)
			break;
		
		pushInstruction(mb, p);
		n = mb->stop-1;
		for (j = 0; j < p->argc; j++) {
			if (getEndLifespan(span,getArg(p,j)) == i && isaBatType(getArgType(mb, p, j)) ){
				mb->var[getArg(p,j)]->eolife = n;
				p->gc |= GARBAGECONTROL;
			} 
		}
		if (blockExit(p) ){
			/* force garbage collection of all within upper block */
			depth--;
			for (k = 0; k < vlimit; k++) {
				if (getEndLifespan(span,k) == i &&
					isaBatType(getVarType(mb,k)) &&
					varGetProp(mb, k, keepProp) == NULL){
						q= newAssignment(mb);
						getArg(q,0) = k;
						q= pushNil(mb,q, TYPE_bat);
						q->gc |= GARBAGECONTROL;
						mb->var[k]->eolife = mb->stop-1;
						actions++;
				}
			}
		}
	}
	assert(p);
	assert( p->token == ENDsymbol);
	pushInstruction(mb, p);
	for (i++; i < limit; i++) 
		pushInstruction(mb, old[i]);
	for (; i < slimit; i++) 
		if (old[i])
			freeInstruction(old[i]);
	getInstrPtr(mb,0)->gc |= GARBAGECONTROL;
	GDKfree(old);
	OPTDEBUGgarbageCollector{ 
		mnstr_printf(cntxt->fdout, "#Garbage collected BAT variables \n");
		for ( k =0; k < vlimit; k++)
		mnstr_printf(cntxt->fdout,"%10s eolife %3d  begin %3d lastupd %3d end %3d\n",
			getVarName(mb,k), mb->var[k]->eolife,
			getBeginLifespan(span,k), getLastUpdate(span,k), getEndLifespan(span,k));
		mnstr_printf(cntxt->fdout, "End of GCoptimizer\n");
	}
	GDKfree(span);

	DEBUGoptimizers
		mnstr_printf(cntxt->fdout,"#opt_garbagecollector: %d variables reset\n",actions);
	return actions+1;
}

@include optimizerWrapper.mx
@c
#include "opt_statistics.h"
@:wrapOptimizer(garbageCollector,OPT_CHECK_ALL)@
@}
