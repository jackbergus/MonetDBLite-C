stdout of test 'bpm06` in directory 'modules/mal` itself:


# 08:52:59 >  
# 08:52:59 >  Mtimeout -timeout 60 mserver5 "--config=/ufs/mk/monet5/Linux/etc/monetdb5.conf" --debug=10 --set "monet_mod_path=/ufs/mk/monet5//Linux/lib/MonetDB5:/ufs/mk/monet5//Linux/lib/MonetDB5/lib:/ufs/mk/monet5//Linux/lib/MonetDB5/bin" --set "gdk_dbfarm=/ufs/mk/monet5//Linux/var/MonetDB5/dbfarm" --set "sql_logdir=/ufs/mk/monet5//Linux/var/MonetDB5/sql_logs" --set "xquery_logdir=/ufs/mk/monet5//Linux/var/MonetDB5/xquery_logs" --set mapi_port=33962 --set xrpc_port=47544 --set monet_prompt= --trace --dbname=mTests_src_modules_mal  bpm06.mal
# 08:52:59 >  

# MonetDB Server v5.0.0_beta2_1
# Copyright (c) 1993-2007 CWI, all rights reserved
# Compiled for x86_64-redhat-linux-gnu/64bit with 64bit OIDs dynamically linked
# dbname:mTests_src_modules_mal
# Visit http://monetdb.cwi.nl/ for further information
##testing the BAT partition manager
## addPartition for incremental addition of partitioned resuls
## saveCatalog for persistency
#
#d:=bat.new(:oid,:flt);
#bat.insert(d,1:oid,2.5);
#bat.insert(d,2:oid,6.8);
#da:=bpm.deposit("myflt",d);
#
#dd:=bat.new(:oid,:flt);
#bat.insert(dd,15:oid,3.5);
#bat.insert(dd,20:oid,4.8);
#dda:=bpm.addPartition("myflt",dd,10:oid,30:oid,1.0,10.0);
#
#bpm.dump();
#
#function user.partinfo(Ra:bat[:any_1,:any_2]):void;
#barrier Rp:= bpm.newIterator(Ra);
#	Ri:= bat.info(Rp);
#	io.print(Ri);
#	redo Rp:= bpm.hasMoreElements(Ra);
#exit Rp;
#end pr;
function user.pr(Ra:bat[:any_1,:any_2]):void;	# 0  (pr:void)<-(Ra:bat[:any_1,:any_2])
barrier Rp := bpm.newIterator(Ra);	# 1 BPMnewIterator (Rp:bat[:any,:any])<-(Ra:bat[:any_1,:any_2]) jump 4
    io.print(Rp);	# 2 IOprint_val (_3:void)<-(Rp:bat[:any,:any])
    redo Rp := bpm.hasMoreElements(Ra);	# 3 BPMhasMoreElements (Rp:bat[:any,:any])<-(Ra:bat[:any_1,:any_2]) jump 2
exit Rp;	# 4  (Rp:bat[:any,:any])
end pr;	# 5  
#user.pr(Ra);
#
##Second partitioned bat
#d:=bat.new(:oid,:flt);
#bat.insert(d,1:oid,2.5);
#bat.insert(d,2:oid,6.8);
#bat.insert(d,5:oid,-1.3);
#da:=bpm.deposit("myflt",d);
#
#f:bat[:oid,:flt]:=bpm.take("myflt");
#user.partinfo(f);
#
#bpm.saveCatalog();
#
#
#
#
function user.main():void;	# 0  (main:void)
#testing the BAT partition manager 	# 1  (_1:str)
# addPartition for incremental addition of partitioned resuls 	# 2  (_2:str)
# saveCatalog for persistency 	# 3  (_3:str)
#First partitioned bat 	# 4  (_4:str)
    R := bat.new(:oid,:sht);	# 5 CMDBATnew (R:bat[:oid,:sht])<-(_6:oid)(_7:sht)
    bat.append(R,1:sht);	# 6 BKCappend_val_wrap (_8:void)<-(R:bat[:oid,:sht])(_9:sht)
    bat.append(R,3:sht);	# 7 BKCappend_val_wrap (_10:void)<-(R:bat[:oid,:sht])(_11:sht)
    bat.append(R,5:sht);	# 8 BKCappend_val_wrap (_12:void)<-(R:bat[:oid,:sht])(_13:sht)
    bat.append(R,7:sht);	# 9 BKCappend_val_wrap (_14:void)<-(R:bat[:oid,:sht])(_15:sht)
    bat.append(R,11:sht);	# 10 BKCappend_val_wrap (_16:void)<-(R:bat[:oid,:sht])(_17:sht)
    Ra := bpm.deposit("myR",R);	# 11 BPMdeposit (Ra:bat[:oid,:sht])<-(_19:str)(R:bat[:oid,:sht])
    io.print("Range partition it ");	# 12 IOprint_val (_20:void)<-(_21:str)
    pv := bat.new(:oid,:sht);	# 13 CMDBATnew (pv:bat[:oid,:sht])<-(_6:oid)(_7:sht)
    bat.append(pv,0:sht);	# 14 BKCappend_val_wrap (_23:void)<-(pv:bat[:oid,:sht])(_24:sht)
    bat.append(pv,5:sht);	# 15 BKCappend_val_wrap (_25:void)<-(pv:bat[:oid,:sht])(_13:sht)
    bpm.rangePartition(Ra,pv);	# 16 BPMrangeVector (_26:void)<-(Ra:bat[:oid,:sht])(pv:bat[:oid,:sht])
#bpm.dump(); 	# 17  (_27:str)
    user.pr(Ra);	# 18  (_28:void)<-(Ra:bat[:oid,:sht])
#Second partitioned bat 	# 19  (_29:str)
    d := bat.new(:oid,:flt);	# 20 CMDBATnew (d:bat[:oid,:flt])<-(_6:oid)(_31:flt)
    bat.insert(d,1@0:oid,2.5);	# 21 BKCinsert_bun (_32:void)<-(d:bat[:oid,:flt])(_33:oid)(_34:flt)
    bat.insert(d,2@0:oid,6.80000019);	# 22 BKCinsert_bun (_35:void)<-(d:bat[:oid,:flt])(_36:oid)(_37:flt)
    bat.insert(d,5@0:oid,-1.29999995);	# 23 BKCinsert_bun (_38:void)<-(d:bat[:oid,:flt])(_39:oid)(_40:flt)
    da := bpm.deposit("myflt",d);	# 24 BPMdeposit (da:bat[:oid,:flt])<-(_42:str)(d:bat[:oid,:flt])
    io.print("Range partition it ");	# 25 IOprint_val (_43:void)<-(_21:str)
    pd := bat.new(:oid,:flt);	# 26 CMDBATnew (pd:bat[:oid,:flt])<-(_6:oid)(_31:flt)
    bat.append(pd,2.29999995);	# 27 BKCappend_val_wrap (_45:void)<-(pd:bat[:oid,:flt])(_46:flt)
    bat.append(pd,5);	# 28 BKCappend_val_wrap (_47:void)<-(pd:bat[:oid,:flt])(_48:flt)
    bpm.rangePartition(da,pd);	# 29 BPMrangeVector (_49:void)<-(da:bat[:oid,:flt])(pd:bat[:oid,:flt])
    user.pr(da);	# 30  (_50:void)<-(da:bat[:oid,:flt])
#bpm.dump(); 	# 31  (_27:str)
    bpm.saveCatalog();	# 32 BPMsaveCatalog (_51:void)
end main;	# 33  
[ "Range partition it " ]
#-----------------#
# h	t	  # name
# oid	sht	  # type
#-----------------#
#-----------------#
# h	t	  # name
# oid	sht	  # type
#-----------------#
[ 0@0,	  1	  ]
[ 1@0,	  3	  ]
#-----------------#
# h	t	  # name
# void	sht	  # type
#-----------------#
[ 2@0,	  5	  ]
[ 3@0,	  7	  ]
[ 4@0,	  11	  ]
[ "Range partition it " ]
#-------------------------#
# h	t		  # name
# oid	flt		  # type
#-------------------------#
[ 5@0,	  -1.29999995	  ]
#-----------------#
# h	t	  # name
# oid	flt	  # type
#-----------------#
[ 1@0,	  2.5	  ]
#-------------------------#
# h	t		  # name
# oid	flt		  # type
#-------------------------#
[ 2@0,	  6.80000019	  ]

# 08:52:59 >  
# 08:52:59 >  Done.
# 08:52:59 >  

