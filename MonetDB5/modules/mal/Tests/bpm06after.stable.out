stdout of test 'bpm06after` in directory 'src/modules/mal` itself:


# 07:29:10 >  
# 07:29:10 >  Mtimeout -timeout 60 mserver5 "--config=/ufs/mk/monet5/Linux/etc/monetdb5.conf" --debug=10 --set "monet_mod_path=/ufs/mk/monet5//Linux/lib/MonetDB5:/ufs/mk/monet5//Linux/lib/MonetDB5/lib:/ufs/mk/monet5//Linux/lib/MonetDB5/bin" --set "gdk_dbfarm=/ufs/mk/monet5//Linux/var/MonetDB5/dbfarm" --set "sql_logdir=/ufs/mk/monet5//Linux/var/MonetDB5/sql_logs" --set "xquery_logdir=/ufs/mk/monet5//Linux/var/MonetDB5/xquery_logs" --set mapi_port=32384 --set xrpc_port=49483 --set monet_prompt= --trace --dbname=mTests_src_modules_mal  bpm06after.mal
# 07:29:10 >  

# MonetDB Server v5.0.0_beta2_1
# Copyright (c) 1993-2007 CWI, all rights reserved
# Compiled for x86_64-redhat-linux-gnu/64bit with 64bit OIDs dynamically linked
# dbname:mTests_src_modules_mal
# Visit http://monetdb.cwi.nl/ for further information
#bpm.open();
##bpm.dump();
#
#function user.pr(Ra:bat[:any_1,:any_2]):void;
#barrier Rp:= bpm.newIterator(Ra);
#    io.print(Rp);
#    redo Rp:= bpm.hasMoreElements(Ra);
#exit Rp;
#end pr;
function user.pr(Ra:bat[:any_1,:any_2]):void;	# 0  (pr:void)<-(Ra:bat[:any_1,:any_2])
barrier Rp := bpm.newIterator(Ra);	# 1 BPMnewIterator (Rp:bat[:any,:any])<-(Ra:bat[:any_1,:any_2]) jump 4
    io.print(Rp);	# 2 IOprint_val (_3:void)<-(Rp:bat[:any,:any])
    redo Rp := bpm.hasMoreElements(Ra);	# 3 BPMhasMoreElements (Rp:bat[:any,:any])<-(Ra:bat[:any_1,:any_2]) jump 2
exit Rp;	# 4  (Rp:bat[:any,:any])
end pr;	# 5  
##check content of the partitions
#f:bat[:oid,:flt]:=bpm.take("myflt");
#user.pr(f);
#r:bat[:oid,:sht]:=bpm.take("myR");
#user.pr(r);
#
#function user.partinfo(Ra:bat[:any_1,:any_2]):void;
#barrier Rp:= bpm.newIterator(Ra);
#	Ri:= bat.info(Rp);
#	io.print(Ri);
#	redo Rp:= bpm.hasMoreElements(Ra);
#exit Rp;
#end partinfo;
function user.partinfo(Ra:bat[:any_1,:any_2]):void;	# 0  (partinfo:void)<-(Ra:bat[:any_1,:any_2])
barrier Rp := bpm.newIterator(Ra);	# 1 BPMnewIterator (Rp:bat[:any,:any])<-(Ra:bat[:any_1,:any_2]) jump 5
    Ri := bat.info(Rp);	# 2 BKCinfo (Ri:bat[:str,:str])<-(Rp:bat[:any,:any])
    io.print(Ri);	# 3 IOprint_val (_4:void)<-(Ri:bat[:str,:str])
    redo Rp := bpm.hasMoreElements(Ra);	# 4 BPMhasMoreElements (Rp:bat[:any,:any])<-(Ra:bat[:any_1,:any_2]) jump 2
exit Rp;	# 5  (Rp:bat[:any,:any])
end partinfo;	# 6  
#
#f:bat[:oid,:flt]:=bpm.take("myflt");
##user.partinfo(f);
#bpm.discard(f);
#
#r:bat[:oid,:sht]:=bpm.take("myR");
##user.partinfo(r);
#bpm.discard(r);
#
#bpm.saveCatalog();
#bpm.dump();
#
function user.main():void;	# 0  (main:void)
    bpm.open();	# 1 BPMopen (_1:void)
#bpm.dump(); 	# 2  (_2:str)
#check content of the partitions 	# 3  (_3:str)
    f:bat[:oid,:flt]  := bpm.take("myflt");	# 4 BPMtake (f:bat[:oid,:flt])<-(_5:str)
    user.pr(f);	# 5  (_6:void)<-(f:bat[:oid,:flt])
    r:bat[:oid,:sht]  := bpm.take("myR");	# 6 BPMtake (r:bat[:oid,:sht])<-(_8:str)
    user.pr(r);	# 7  (_9:void)<-(r:bat[:oid,:sht])
#user.partinfo(f); 	# 8  (_10:str)
    bpm.discard(f);	# 9 BPMdiscard (_11:void)<-(f:bat[:oid,:flt])
#user.partinfo(r); 	# 10  (_12:str)
    bpm.discard(r);	# 11 BPMdiscard (_13:void)<-(r:bat[:oid,:sht])
    bpm.saveCatalog();	# 12 BPMsaveCatalog (_14:void)
#io.print("after cleanup"); 	# 13  (_15:str)
#bpm.dump(); 	# 14  (_2:str)
end main;	# 15  
#-------------------------#
# h	t		  # name
# oid	flt		  # type
#-------------------------#
[ 5@0,	  -1.29999995	  ]
#-----------------#
# h	t	  # name
# oid	flt	  # type
#-----------------#
[ 1@0,	  2.5	  ]
#-------------------------#
# h	t		  # name
# oid	flt		  # type
#-------------------------#
[ 2@0,	  6.80000019	  ]
#-----------------#
# h	t	  # name
# oid	sht	  # type
#-----------------#
#-----------------#
# h	t	  # name
# oid	sht	  # type
#-----------------#
[ 0@0,	  1	  ]
[ 1@0,	  3	  ]
#-----------------#
# h	t	  # name
# void	sht	  # type
#-----------------#
[ 2@0,	  5	  ]
[ 3@0,	  7	  ]
[ 4@0,	  11	  ]

# 07:29:10 >  
# 07:29:10 >  Done.
# 07:29:10 >  

