@/
The contents of this file are subject to the MonetDB Public License
Version 1.1 (the "License"); you may not use this file except in
compliance with the License. You may obtain a copy of the License at
http://www.monetdb.org/Legal/MonetDBLicense

Software distributed under the License is distributed on an "AS IS"
basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations
under the License.

The Original Code is the MonetDB Database System.

The Initial Developer of the Original Code is CWI.
Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
Copyright August 2008-2012 MonetDB B.V.
All Rights Reserved.
@

@f aggr_bge_minmax

@c
/*
 * @a S. Manegold
 * @v 1.0
 * @+ Aggregates Module
 *
 *
 * @+ Implementation
 * These implementations need just one scan and a simple hash-maintained data
 * structure to compute a group of common aggregates.
 */
#include "monetdb_config.h"
#include <gdk.h>
#include <gdk_scanselect.h>	/* for type-specific HT_bunfastins_nocheck_noinc(), until they're moved to gdk.mx */
#include "aggr.h"
#include "aggr_bge_minmax.h"
#include "aggr_be_minmax.h"

/*
 * @- Result initialization
 * //	init_result
 * 	@1:	tail-type:	bte/sht/int/wrd/lng/flt/dbl / any / void
 *
 */
@include aggr_ri.mx
@c
/*
 * @- "Extremes" (Min & Max)
 */
/*	aggrX3_minmax3_ptr
		e-void-head	e-oid-head	e-oid-head	e-oid-head
		void-lookup	array-lookup	scan-lookup	hash-lookup

	@1:	</>		</>		</>		</>		compare operator: <(min) or >(max)
	@2:	0		0		0		1		do BATprepareHash?
	@3:	BUNfndVOID	CHKrange	SCANfndOID	HASHfnd_oid	lookup
	@4:	var		loc		loc		loc		e/bn-head-access

	@5:	"BUNhloc(b,p)" for  (oid) b-head-type,		b-head access
		"&bhsb; bhsb++" for (void) b-head-type

	@6:	bte / sht / int / lng / any		b/bn-tail-storage-type
	@7:	"loc" for fixsized b/bn-tail-type,		b/bn-tail-access
		"var" for varsized b/bn-tail-type

	@8:		r-off		(*(oid*)h)-min	index in extremes array
	@9:		max/min					initial result value
*/
@= aggrX3_minmax3_ptr
	ALGODEBUG THRprintf(GDKout, "#aggrX3_minmax3_ptr(@1,@2,@3,@4,@5,@6,@7,@8,@9);\n");
#if @2
	if (BATprepareHash(e)) {
		GDKerror("aggrX3_minmax3_ptr(@1,@2,@3,@4,@5,@6,@6,@7,@8,@9): BATprepareHash(e) failed");
		BBPreclaim(e);
		return GDK_FAIL;
	}
#endif
	/* init: create extremes and set all to the zero pointer */
	extremes = (ptr*) GDKzalloc(slots*sizeof(ptr));
	if (extremes == NULL) {
		GDKerror("aggrX3_minmax3_ptr(@1,@2,@3,@4,@5,@6,@7,@8,@9): extremes = GDKzalloc("OIDFMT"*"SZFMT") failed", slots, sizeof(ptr));
		BBPreclaim(bn);
		return GDK_FAIL;
	}
	/* scan b & g and replace totals by the extreme value (just pointers to vals in b) */
	base = BUNfirst(g);
	gh_offset = (ssize_t) base - (ssize_t) g->hseqbase;
	gt_offset = (ssize_t) g->tseqbase - (ssize_t) g->hseqbase;
	end = base + BATcount(g);
	bhsb = b->hseqbase;
	if (b_use)
		BATaccessBegin(b,b_use,MMAP_SEQUENTIAL);
	if (BATtdense(g)) {
		@:aggrX3_minmax3_ptr_body(@1,@2,@3,@4,@5,@6,@7,@8,@9,oid hh = (oid) (gt_offset + v); oid *h = &hh)@
	} else {
		BATaccessBegin(g,USE_TAIL,MMAP_SEQUENTIAL);
		@:aggrX3_minmax3_ptr_body(@1,@2,@3,@4,@5,@6,@7,@8,@9,oid *h = (oid*) Tloc(g, w))@
		BATaccessEnd(g,USE_TAIL,MMAP_SEQUENTIAL);
	}
	if (b_use)
		BATaccessEnd(b,b_use,MMAP_SEQUENTIAL);
	/* insert the extreme values into the result */
	BATaccessBegin(bn,USE_HEAD|USE_TAIL,MMAP_SEQUENTIAL);
	BATloop(bn, r, q) {
		oid *h = (oid*)BUNh@4(bni,r);
		ptr val = extremes[@8];
		(void) h;	/* silence compiler about unused variable */
		Tputvalue(bn, BUNtloc(bni,r), val?val:nil, 0);
	}
	BATaccessEnd(bn,USE_HEAD|USE_TAIL,MMAP_SEQUENTIAL);
@
@c
/*	aggrX3_minmax3_ptr_body
	@[10]:	oid hh = (oid) (gt_offset + v); oid *h = &hh		g tail value calculation
		oid *h = (oid*) Tloc(g, w)				g tail value lookup
*/
@= aggrX3_minmax3_ptr_body
	ALGODEBUG THRprintf(GDKout, "#aggrX3_minmax3_ptr_body(@1,@2,@3,@4,@5,@6,@7,@8,@9,@[10]);\n");
	if (b->T->nonil) {
		BATloop(b, p, q) {
			ptr t = BUNt@7(bi,p);
			oid v = *(oid*) @5;

			w = (BUN) (gh_offset + v);
			if (w >= base && w < end) {
				@[10];

				@3(r, bni, (oid*)h);
				if (r != BUN_NONE) {
					ptr *val = &extremes[@8];
					if (*val == NULL || (*cmp)(t,*val) @1 0) {
						*val = t;
					}
				}
			}
		}
	} else {
		BATloop(b, p, q) {
			ptr t = BUNt@7(bi,p);
			oid v = *(oid*) @5;

			w = (BUN) (gh_offset + v);
			if (w >= base && w < end) {
				@[10];

				@3(r, bni, (oid*)h);
				if (r != BUN_NONE) {
					ptr *val = &extremes[@8];
					if (*val != nil) {
						if ((*cmp)(t,nil) == 0) {
							*val = nil;
						} else if (*val == NULL || (*cmp)(t,*val) @1 0) {
							*val = t;
						}
					}
				}
			}
		}
	}
@
@c
/*	aggrX3_minmax3_oid
		e-void-head	e-oid-head	e-oid-head	e-oid-head
		void-lookup	array-lookup	scan-lookup	hash-lookup

	@1:	</>		</>		</>		</>		compare operator: <(min) or >(max)
	@2:	0		0		0		1		do BATprepareHash?
	@3:	BUNfndVOID	CHKrange	SCANfndOID	HASHfnd_oid	lookup
	@4:	var		loc		loc		loc		e/bn-head-access

	@5:	"BUNhloc(b,p)" for  (oid) b-head-type,		b-head access
		"&bhsb; bhsb++" for (void) b-head-type

	@6:	bte / sht / int / lng / any		b/bn-tail-storage-type
	@7:	"loc" for fixsized b/bn-tail-type,		b/bn-tail-access
		"var" for varsized b/bn-tail-type

	@8:		r-off		(*(oid*)h)-min	index in extremes array
	@9:		max/min					initial result value
*/
@= aggrX3_minmax3_oid
	ALGODEBUG THRprintf(GDKout, "#aggrX3_minmax3_oid(@1,@2,@3,@4,@5,@6,@7,@8,@9);\n");
#if @2
	if (BATprepareHash(e)) {
		GDKerror("aggrX3_minmax3_oid(@1,@2,@3,@4,@5,@6,@6,@7,@8,@9): BATprepareHash(e) failed");
		BBPreclaim(e);
		return GDK_FAIL;
	}
#endif
	/* init: create extremes and set all to the zero pointer */
	extremes = (oid*) GDKmalloc(slots*sizeof(oid));
	if (extremes == NULL) {
		GDKerror("aggrX3_minmax3_oid(@1,@2,@3,@4,@5,@6,@7,@8,@9): extremes = GDKmalloc("OIDFMT"*"SZFMT") failed", slots, sizeof(oid));
		BBPreclaim(bn);
		return GDK_FAIL;
	}
	{ BUN i = 0; for (; i < slots; i++ ) extremes[i] = GDK_oid_@9; }
	hit = (bit*) GDKzalloc(slots*sizeof(bit));
	if (hit == NULL) {
		GDKerror("aggrX3_minmax3_oid(@1,@2,@3,@4,@5,@6,@7,@8,@9): hit = GDKzalloc("OIDFMT"*"SZFMT") failed", slots, sizeof(bit));
		GDKfree(extremes);
		BBPreclaim(bn);
		return GDK_FAIL;
	}
	/* scan b & g and replace totals by the extreme value (just pointers to vals in b) */
	base = BUNfirst(g);
	gh_offset = (ssize_t) base - (ssize_t) g->hseqbase;
	gt_offset = (ssize_t) g->tseqbase - (ssize_t) g->hseqbase;
	end = base + BATcount(g);
	bhsb = b->hseqbase;
	if (b_use)
		BATaccessBegin(b,b_use,MMAP_SEQUENTIAL);
	if (BATtdense(g)) {
		@:aggrX3_minmax3_oid_body(@1,@2,@3,@4,@5,@6,@7,@8,@9,oid hh = (oid) (gt_offset + v); oid *h = &hh)@
	} else {
		BATaccessBegin(g,USE_TAIL,MMAP_SEQUENTIAL);
		@:aggrX3_minmax3_oid_body(@1,@2,@3,@4,@5,@6,@7,@8,@9,oid *h = (oid*) Tloc(g, w))@
		BATaccessEnd(g,USE_TAIL,MMAP_SEQUENTIAL);
	}
@
@c
/*	aggrX3_minmax3_oid_body
	@[10]:	oid hh = (oid) (gt_offset + v); oid *h = &hh		g tail value calculation
		oid *h = (oid*) Tloc(g, w)				g tail value lookup
*/
@= aggrX3_minmax3_oid_body
	ALGODEBUG THRprintf(GDKout, "#aggrX3_minmax3_oid_body(@1,@2,@3,@4,@5,@6,@7,@8,@9,@[10]);\n");
	if (b->T->nonil) {
		BATloop(b, p, q) {
			ptr t = BUNt@7(bi,p);
			oid v = *(oid*) @5;

			w = (BUN) (gh_offset + v);
			if (w >= base && w < end) {
				@[10];

				@3(r, bni, (oid*)h);
				if (r != BUN_NONE) {
					oid *val = &extremes[@8];
					if ((*cmp)(t,val) @1 0) {
						*val = *(oid*)t;
						hit[@8] = 1;
					}
				}
			}
		}
	} else {
		BATloop(b, p, q) {
			ptr t = BUNt@7(bi,p);
			oid v = *(oid*) @5;

			w = (BUN) (gh_offset + v);
			if (w >= base && w < end) {
				@[10];

				@3(r, bni, (oid*)h);
				if (r != BUN_NONE) {
					oid *val = &extremes[@8];
					if (*val != *(oid*)nil) {
						if ((*cmp)(t,nil) == 0) {
							*val = *(oid*)nil;
						} else if ((*cmp)(t,val) @1 0) {
							*val = *(oid*)t;
							hit[@8] = 1;
						}
					}
				}
			}
		}
	}
	BATaccessEnd(g,USE_TAIL,MMAP_SEQUENTIAL);
	if (b_use)
		BATaccessEnd(b,b_use,MMAP_SEQUENTIAL);
	/* insert the extreme values into the result */
	BATloop(bn, r, q) {
		oid *h = (oid*)BUNh@4(bni,r);
		oid val = hit[@8] ? extremes[@8] : *(oid*)nil;
		(void) h;	/* silence compiler about unused variable */
		Tputvalue(bn, BUNtloc(bni,r), &val, 0);
	}
@
@c

/*	extreme_typed
	@1:	min/max
	@2:	 < / >
	@3:	b/bn-tail-storage-type			bte/sht/int/lng/any
	@4:	"loc" for fixsized b/bn-tail-type,	b/bn-tail-access
		"var" for varsized b/bn-tail-type
	@5:	ptr/oid					void/any
	@6:	max/min					initial result value
*/
@= extreme3_typed
static int
aggrX3_@13_@3_@4_@5(BAT **ret, BAT *b, BAT *g, BAT *e)
{
	BAT *bn;
	BATiter bni, bi = bat_iterator(b);
	int (*cmp)(const void *, const void *);
	ptr nil;
	BUN off;
	@5 *extremes = NULL;
#if TYPE_@5 == TYPE_oid
	bit *hit = NULL;
#endif
	BUN p, q, r;
	BUN slots;
	oid range;
	oid min, max;
	oid bhsb;
	BUN base, end, w;
	ssize_t gh_offset, gt_offset;
	int b_use = USE_TAIL;

	*ret = NULL;

	ALGODEBUG THRprintf(GDKout, "#aggrX3_@1_@3_@4_@5[@2,@6](b=%s,g=%s,e=%s);\n",
		BATgetId(b),BATgetId(g),BATgetId(e));
/*	ERRORcheck((BATcount(b)!=BATcount(g)), "aggrX3_@13_@3_@4: BATs b & g must be of equal size.\n");	*/
	ERRORcheck((g->htype == TYPE_void) && (g->hseqbase == oid_nil) && (BATcount(g) > 0), "aggrX3_@13_@3_@4_@5: head of BAT g must not be nil.\n");

	if (g->hseqbase == oid_nil || !BAThdense(g) || !BAThordered(b) || !g->hkey) {
		BAT *gb = BATjoin(BATmirror(g),b,BUN_NONE);
		int rtrn = CMDaggrX3_@1(ret, gb, e);
		BBPunfix(gb->batCacheid);
		return rtrn;
	}

	bn = BATnew(TYPE_void, BATttype(b), BATcount(e));
	if( bn == NULL) {
		GDKerror("aggrX3_@13_@3_@4_@5(): BATnew() failed");
		return GDK_FAIL;
	}

	/* init: prepare the result bat;
	 * trick: by using "tail-type" void, we only write the head column, here */
	@:init_result(void)@
	bni = bat_iterator(bn);
	cmp = BATatoms[bn->ttype].atomCmp;
	nil = ATOMnilptr(bn->ttype);
	off = BUNfirst(bn);
	range = max - min + 1;

	/* scan b & g and replace totals by the extreme value (just pointers to vals in b) */
	slots = BATcount(e);
	if (slots == 0) {
		/* empty extend => empty result */
		*ret = bn;
		return GDK_SUCCEED;
	}
	if (!BAThdense(b))
		b_use |= USE_HEAD;
	if (e->htype == TYPE_void) {
		/* void lookup */
		if (BAThdense(b)) {
			@:aggrX3_minmax3_@5(@2,0,BUNfndVOID,var,&bhsb; bhsb++,@3,@4,r-off,@6)@
		} else {
			@:aggrX3_minmax3_@5(@2,0,BUNfndVOID,var,BUNhloc(bi,p),@3,@4,r-off,@6)@
		}
	/* e->htype == TYPE_oid */
	} else if (range <= SMALL_AGGR_MAX) {
		/* array lookup */
		slots = range;
		if (BAThdense(b)) {
			@:aggrX3_minmax3_@5(@2,0,CHKrange,loc,&bhsb; bhsb++,@3,@4,(*(oid*)h)-min,@6)@
		} else {
			@:aggrX3_minmax3_@5(@2,0,CHKrange,loc,BUNhloc(bi,p),@3,@4,(*(oid*)h)-min,@6)@
		}
	} else if (BATcount(e) <= SCAN_AGGR_MAX) {
		/* scan lookup */
		SCAN_aggr_init;
		if (BAThdense(b)) {
			@:aggrX3_minmax3_@5(@2,0,SCANfndOID,loc,&bhsb;bhsb++,@3,@4,r-off,@6)@
		} else {
			@:aggrX3_minmax3_@5(@2,0,SCANfndOID,loc,BUNhloc(bi,p),@3,@4,r-off,@6)@
		}
	} else if (BATtordered(g)&BAThordered(e)) {
		/* merge lookup */
		MERGE_aggr_init;
		if (BAThdense(b)) {
			@:aggrX3_minmax3_@5(@2,0,MERGEfndOID,loc,&bhsb;bhsb++,@3,@4,r-off,@6)@
		} else {
			@:aggrX3_minmax3_@5(@2,0,MERGEfndOID,loc,BUNhloc(bi,p),@3,@4,r-off,@6)@
		}
	} else {
		/* hash lookup */
		if (BAThdense(b)) {
			@:aggrX3_minmax3_@5(@2,1,HASHfnd_oid,loc,&bhsb; bhsb++,@3,@4,r-off,@6)@
		} else {
			@:aggrX3_minmax3_@5(@2,1,HASHfnd_oid,loc,BUNhloc(bi,p),@3,@4,r-off,@6)@
		}
	}
	*ret = bn;
bunins_failed:
	if (extremes)
		GDKfree(extremes);
#if TYPE_@5 == TYPE_oid
	if (hit)
		GDKfree(hit);
#endif
	return *ret?GDK_SUCCEED:GDK_FAIL;
}
@
@c
/*	extreme
	@1:	min/max
	@2:	 < / >
*/
@= extreme3_h
int
CMDaggrX3_@13(BAT **ret, BAT *b, BAT *g, BAT *e);
@= extreme3_c
@:extreme3_typed(@1,@2,bte,loc,ptr,@3)@
@:extreme3_typed(@1,@2,sht,loc,ptr,@3)@
@:extreme3_typed(@1,@2,int,loc,ptr,@3)@
@:extreme3_typed(@1,@2,lng,loc,ptr,@3)@
@:extreme3_typed(@1,@2,any,loc,ptr,@3)@
@:extreme3_typed(@1,@2,any,var,ptr,@3)@
@:extreme3_typed(@1,@2,any,var,oid,@3)@

int
CMDaggrX3_@13(BAT **ret, BAT *b, BAT *g, BAT *e)
{
	int rtrn, tt = ATOMstorage(b->ttype);
	ALGODEBUG THRprintf(GDKout, "#CMDaggrX3_@1[@2](b=%s,g=%s,e=%s);\n",
		BATgetId(b),BATgetId(g),BATgetId(e));
/*	ERRORcheck((BATcount(b)!=BATcount(g)), "aggrX3_@13: BATs b & g must be of equal size.\n");	*/
	ERRORcheck((g->htype == TYPE_void) && (g->hseqbase == oid_nil) && (BATcount(g) > 0), "aggrX3_@13: head of BAT g must not be nil.\n");

	if (g->hseqbase == oid_nil || !BAThdense(g) || !BAThordered(b) || !g->hkey) {
		BAT *gb = BATjoin(BATmirror(g),b,BUN_NONE);
		rtrn = CMDaggrX3_@1(ret, gb, e);
		BBPunfix(gb->batCacheid);
		return rtrn;
	}

	if (b->ttype == TYPE_void) {
		rtrn = aggrX3_@13_any_var_oid(ret, b, g, e);
	} else if (tt == TYPE_bte) {
		rtrn = aggrX3_@13_bte_loc_ptr(ret, b, g, e);
	} else if (tt == TYPE_sht) {
		rtrn = aggrX3_@13_sht_loc_ptr(ret, b, g, e);
	} else if (tt == TYPE_int || tt == TYPE_flt) {
		rtrn = aggrX3_@13_int_loc_ptr(ret, b, g, e);
	} else if (tt == TYPE_dbl || tt == TYPE_lng) {
		rtrn = aggrX3_@13_lng_loc_ptr(ret, b, g, e);
	} else if (b->tvarsized) {
		rtrn = aggrX3_@13_any_var_ptr(ret, b, g, e);
	} else {
		rtrn = aggrX3_@13_any_loc_ptr(ret, b, g, e);
	}
	return rtrn;
}
@
@h
@:extreme3_h(min,<,max)@
@:extreme3_h(max,>,min)@
@c
@:extreme3_c(min,<,max)@
@:extreme3_c(max,>,min)@

