@/
The contents of this file are subject to the MonetDB Public License
Version 1.1 (the "License"); you may not use this file except in
compliance with the License. You may obtain a copy of the License at
http://www.monetdb.org/Legal/MonetDBLicense

Software distributed under the License is distributed on an "AS IS"
basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations
under the License.

The Original Code is the MonetDB Database System.

The Initial Developer of the Original Code is CWI.
Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
Copyright August 2008-2012 MonetDB B.V.
All Rights Reserved.
@

@f calc

@c
/*
 * @a N.J. Nes, P. Boncz, M. Kersten, A. de Vries
 * @v 2.0
 * @+ Basic arithmetic
 * This module is an extended version of the V4 arithmetic module.
 * It implements the arithmetic operations on the built-in types,
 * @emph{chr}, @emph{bte}, @emph{sht}, @emph{int}, @emph{flt}, @emph{dbl} and @emph{lng}.
 * All combinations are implemented. Limited combinations are implemented
 * for @emph{bit}, @emph{oid} and @emph{str}.
 *
 * @table @code
 * @item [binary operators]
 * The implemented operators are first of all all comparison that return a
 * TRUE/FALSE value (@emph{bit} values), i.e.
 * @emph{<=}, @emph{<}, @emph{==}, @emph{!=}, @emph{>=}, and @emph{>=}.
 *
 * The module also implements the operators @emph{+}, @emph{-}, @emph{*} and @emph{/}.
 * The rules for the return types operators is as follows.
 * If one of the input types is a floating point the result will be a
 * floating point.  The largest type of the input types is taken.
 *
 * The @emph{max} and @emph{min} functions return the maximum and minimum of
 * the two input parameters.
 *
 * @item [unary operators]
 * This module also implements the unary @emph{abs}() function, which calculates
 * the absolute value of the given input parameter, as well as the @emph{-} unary
 * operator.
 *
 * The @emph{inv} unary operation calculates the inverse of the input value.
 * An error message is given when the input value is zero.
 *
 * @item [bitwise operators]
 * For integers there are some additional operations. The @emph{%} operator
 * implements the congruent modulo operation. The @emph{<<} and @emph{>>}
 * are the left and right bit shift. The @emph{or}, @emph{and}, @emph{xor} and
 * @emph{not} for integers are implemented as bitwise boolean operations.
 *
 * @item [boolean operators]
 * The @emph{or}, @emph{and}, @emph{xor} and @emph{not} for the bit atomic type
 * in MIL (this corresponds to what is normally called boolean)
 * are implemented as the logic operations.
 *
 * @item [random numbers]
 * This module also contains the rand and srand functions. The @emph{srand}()
 * function initializes the random number generator using a seed value. The
 * subsequent calls to @emph{rand}() are pseudo random numbers (with the same
 * seed the sequence can be repeated).
 * @end table
 *
 * The general interpretation for the NIL value is "unknown".
 * This semantics mean that any operation that receives at least one NIL
 * value, will produce a NIL value in the output for sure.
 *
 * The only exception to this rule are the "==" and "!=" equality
 * test routines (it would otherwise become rather difficult to test
 * whether a value is nil).
 *
 * The collection of type conversion routines are included here as well.
 *
 * The definitions shown are limited to the Mx macros.
 * This should be sufficient to understand the functionality
 * at the cost of precision.
 * In most situations the macros are expanded using the
 * built-in type set (int,lng,sht,bit,oid,flt,...)
 */
@= mal_isnil
	command isnil(v:@1) :bit 
	address CALCisnil_@1
	comment "is a value nil?";
	command isnotnil(v:@1) :bit 
	address CALCisnotnil_@1
	comment "is a value not equal to nil?";
@
@mal
# @-
# [Mx bug, space required here]
module calc;

	@:mal_isnil(bit)@
	@:mal_isnil(chr)@
	@:mal_isnil(bte)@
	@:mal_isnil(sht)@
	@:mal_isnil(int)@
	@:mal_isnil(oid)@
	@:mal_isnil(wrd)@
	@:mal_isnil(lng)@
	@:mal_isnil(flt)@
	@:mal_isnil(dbl)@
	@:mal_isnil(str)@
	@:mal_isnil(bat)@
command isnil(v:void) :bit 
address CALCisnil_void
comment "is a value nil?";
command isnotnil(v:void) :bit 
address CALCisnotnil_void
comment "is a value not equal to nil?";
# @+ Comparison operations
# The @emph{eq_ops} and @emph{cmp_ops} Mx macro implements the interface to the
# arithmetic comparisons. Note that comparison operators with different
# operand types are already supported in the kernel, but are not nearly as fast,
# (because they have to convert values on the fly).
# The code expansion is organized such that
# the least interesting one is pushed onto the symbol table stack first.
@= eq_ops
		command ==(left:@1, right:@2) :bit 
		address CALCcompEQ@1@2;
		command !=(left:@1, right:@2) :bit 
		address CALCcompNEQ@1@2;
@= cmp_ops
		@:eq_ops(@1,@2)@

		command <(left:@1, right:@2) :bit 
		address CALCcompLT@1@2;
		command <=(left:@1, right:@2) :bit 
		address CALCcompLE@1@2;
		command >=(left:@1, right:@2) :bit 
		address CALCcompGE@1@2;
		command >(left:@1, right:@2) :bit 
		address CALCcompGT@1@2;
		command between(val:@1, low:@1, high:@1) :bit 
		address CALCcompBetween@1;
@
@mal

		@:cmp_ops(oid,oid)@
		@:cmp_ops(flt,flt)@
		@:cmp_ops(flt,dbl)@
		@:cmp_ops(dbl,dbl)@

		@:eq_ops(bit,bit)@
		@:eq_ops(bit,chr)@
		@:eq_ops(bit,bte)@
		@:eq_ops(bit,sht)@
		@:eq_ops(bit,int)@
		@:eq_ops(bit,lng)@

		@:cmp_ops(chr,chr)@
		@:cmp_ops(chr,bte)@
		@:cmp_ops(chr,sht)@
		@:cmp_ops(chr,int)@
		@:cmp_ops(chr,wrd)@
		@:cmp_ops(chr,lng)@

		@:cmp_ops(bte,chr)@
		@:cmp_ops(bte,bte)@
		@:cmp_ops(bte,sht)@
		@:cmp_ops(bte,int)@
		@:cmp_ops(bte,wrd)@
		@:cmp_ops(bte,lng)@

		@:cmp_ops(sht,chr)@
		@:cmp_ops(sht,bte)@
		@:cmp_ops(sht,sht)@
		@:cmp_ops(sht,wrd)@
		@:cmp_ops(sht,int)@
		@:cmp_ops(sht,lng)@

		@:cmp_ops(wrd,chr)@
		@:cmp_ops(wrd,bte)@
		@:cmp_ops(wrd,sht)@
		@:cmp_ops(wrd,wrd)@
		@:cmp_ops(wrd,int)@
		@:cmp_ops(wrd,lng)@

		@:cmp_ops(int,chr)@
		@:cmp_ops(int,wrd)@
		@:cmp_ops(int,bte)@
		@:cmp_ops(int,sht)@
		@:cmp_ops(int,int)@
		@:cmp_ops(int,lng)@

		@:cmp_ops(lng,chr)@
		@:cmp_ops(wrd,bte)@
		@:cmp_ops(lng,sht)@
		@:cmp_ops(lng,int)@
		@:cmp_ops(lng,lng)@

		@:cmp_ops(str,str)@
# @+ Arithmetic computation
# The operators @{ +, -, *, /, % @} are handled here.
# The macro expects three parameters, two input atomic types and a result type.
command +(l:str,r:str):str
address CALCstrConcat
comment "Concatenate two strings";
command +(l:str,r:int):str
address CALCstrConcatInt
comment "Concatenate two strings";

@= mal_calc_ops
		command sqladd(left:@1, right:@2) :@3 
		address CALCbinarySQLADD@1@2; 
		command +(left:@1, right:@2) :@3 
		address CALCbinaryADD@1@2; 
		command -(left:@1, right:@2) :@3 
		address CALCbinarySUB@1@2;
		command *(left:@1, right:@2) :@3 
		address CALCbinaryMUL@1@2;
		command /(left:@1, right:@2) :@3 
		address CALCbinarycheckDIV@1@2;
		command %(left:@1, right:@2) :@4 
		address CALCbinarycheckMOD@1@2;
@
@mal
# @-
# The coercions described below ensure that there is never any information loss.
@= calc_ops
	@:@1_calc_ops(oid,oid,oid,oid)@

	@:@1_calc_ops(chr,chr,chr,chr)@
	@:@1_calc_ops(chr,bte,bte,bte)@
	@:@1_calc_ops(chr,sht,sht,sht)@
	@:@1_calc_ops(chr,int,int,int)@
	@:@1_calc_ops(chr,wrd,wrd,wrd)@
	@:@1_calc_ops(chr,lng,lng,lng)@
	@:@1_calc_ops(chr,flt,flt,flt)@
	@:@1_calc_ops(chr,dbl,dbl,dbl)@

	@:@1_calc_ops(bte,bte,bte,bte)@
	@:@1_calc_ops(bte,chr,bte,chr)@
	@:@1_calc_ops(bte,sht,sht,sht)@
	@:@1_calc_ops(bte,int,int,int)@
	@:@1_calc_ops(bte,wrd,wrd,wrd)@
	@:@1_calc_ops(bte,lng,lng,lng)@
	@:@1_calc_ops(bte,flt,flt,flt)@
	@:@1_calc_ops(bte,dbl,dbl,dbl)@

	@:@1_calc_ops(sht,chr,sht,chr)@
	@:@1_calc_ops(sht,bte,sht,bte)@
	@:@1_calc_ops(sht,sht,sht,sht)@
	@:@1_calc_ops(sht,int,int,int)@
	@:@1_calc_ops(sht,wrd,wrd,wrd)@
	@:@1_calc_ops(sht,lng,lng,lng)@
	@:@1_calc_ops(sht,flt,flt,flt)@
	@:@1_calc_ops(sht,dbl,dbl,dbl)@

	@:@1_calc_ops(int,chr,int,chr)@
	@:@1_calc_ops(int,bte,int,bte)@
	@:@1_calc_ops(int,sht,int,sht)@
	@:@1_calc_ops(int,int,int,int)@
	@:@1_calc_ops(int,wrd,wrd,wrd)@
	@:@1_calc_ops(int,lng,lng,lng)@
	@:@1_calc_ops(int,flt,flt,flt)@
	@:@1_calc_ops(int,dbl,dbl,dbl)@

	@:@1_calc_ops(wrd,chr,wrd,chr)@
	@:@1_calc_ops(wrd,bte,wrd,bte)@
	@:@1_calc_ops(wrd,sht,wrd,sht)@
	@:@1_calc_ops(wrd,int,wrd,int)@
	@:@1_calc_ops(wrd,wrd,wrd,wrd)@
	@:@1_calc_ops(wrd,lng,lng,lng)@
	@:@1_calc_ops(wrd,flt,flt,flt)@
	@:@1_calc_ops(wrd,dbl,dbl,dbl)@

	@:@1_calc_ops(flt,chr,flt,flt)@
	@:@1_calc_ops(flt,bte,flt,flt)@
	@:@1_calc_ops(flt,sht,flt,flt)@
	@:@1_calc_ops(flt,int,flt,flt)@
	@:@1_calc_ops(flt,wrd,flt,flt)@
	@:@1_calc_ops(flt,lng,flt,flt)@
	@:@1_calc_ops(flt,flt,flt,flt)@
	@:@1_calc_ops(flt,dbl,dbl,dbl)@

	@:@1_calc_ops(dbl,chr,dbl,dbl)@
	@:@1_calc_ops(dbl,bte,dbl,dbl)@
	@:@1_calc_ops(dbl,sht,dbl,dbl)@
	@:@1_calc_ops(dbl,int,dbl,dbl)@
	@:@1_calc_ops(dbl,wrd,dbl,dbl)@
	@:@1_calc_ops(dbl,lng,dbl,dbl)@
	@:@1_calc_ops(dbl,flt,dbl,dbl)@
	@:@1_calc_ops(dbl,dbl,dbl,dbl)@

	@:@1_calc_ops(lng,chr,lng,chr)@
	@:@1_calc_ops(lng,bte,lng,bte)@
	@:@1_calc_ops(lng,sht,lng,sht)@
	@:@1_calc_ops(lng,int,lng,int)@
	@:@1_calc_ops(lng,wrd,lng,wrd)@
	@:@1_calc_ops(lng,lng,lng,lng)@
	@:@1_calc_ops(lng,flt,dbl,flt)@
	@:@1_calc_ops(lng,dbl,dbl,dbl)@
@
@mal
@:calc_ops(mal)@

# @+ Binary  operations { max, min, }
@= mal_binary_ops
		command max(l:@1, r:@1) :@1 
		address CALCbinaryMAX@2; 
		command min(l:@1, r:@1) :@1 
		address CALCbinaryMIN@2;
		command max_no_nil(l:@1, r:@1) :@1 
		address CALCbinaryMAX_NO_NIL@2; 
		command min_no_nil(ll:@1, r:@1) :@1 
		address CALCbinaryMIN_NO_NIL@2;
@
@mal
# @-
	@:mal_binary_ops(bit,bit)@
	@:mal_binary_ops(chr,chr)@
	@:mal_binary_ops(bte,bte)@
	@:mal_binary_ops(sht,sht)@
	@:mal_binary_ops(int,int)@
	@:mal_binary_ops(wrd,wrd)@
	@:mal_binary_ops(oid,oid)@
	@:mal_binary_ops(flt,flt)@
	@:mal_binary_ops(lng,lng)@
	@:mal_binary_ops(dbl,dbl)@
	# @+ Unary operations { abs, inv }
	# The unary operators include coercion routines for built-in types
@= mal_unary_ops
		command abs(x:@1) :@1 
		address CALCunary@1ABS 
		comment "absolute value";
		command inv(x:@1) :@1 
		address CALCunarycheck@1INV 	
		comment "inverse value (1/x)";
		command -(x:@1) :@1 
		address CALCunary@1NEG 
		comment "negative value";
		command sizeof(x:@1):int
		address CALCsizeof@1;
		command sign(x:@1) :int
		address CALCunary@1SIGN 
		comment "Returns +1, 0, -1 based on the sign of the given expression";
@= unary_ops
	@:@1_unary_ops(bit)@
	@:@1_unary_ops(chr)@
	@:@1_unary_ops(bte)@
	@:@1_unary_ops(sht)@
	@:@1_unary_ops(int)@
	@:@1_unary_ops(wrd)@
	@:@1_unary_ops(flt)@
	@:@1_unary_ops(lng)@
	@:@1_unary_ops(dbl)@
@
@mal
@:unary_ops(mal)@

	command length(x:str):int
	address CALClengthstr;
	# @-
	# Coercion functions are typical used in multiplex calls.
@= mal_coercion
		command @1(x:@2):@1 
		address CALC@22@1 
		comment "coercion @2 to @1";
@= scalar_coercion
	@:mal_coercion(@1,oid)@
	@:mal_coercion(@1,bit)@
	@:mal_coercion(@1,chr)@
	@:mal_coercion(@1,bte)@
	@:mal_coercion(@1,sht)@
	@:mal_coercion(@1,int)@
	@:mal_coercion(@1,wrd)@
	@:mal_coercion(@1,lng)@
	@:mal_coercion(@1,flt)@
	@:mal_coercion(@1,dbl)@
@
@mal
	@:scalar_coercion(bit)@
	@:scalar_coercion(chr)@
	@:scalar_coercion(bte)@
	@:scalar_coercion(wrd)@
	@:scalar_coercion(lng)@
	@:scalar_coercion(int)@
	@:scalar_coercion(sht)@

	@:mal_coercion(oid,oid)@
	@:mal_coercion(oid,lng)@
	@:mal_coercion(oid,wrd)@
	@:mal_coercion(oid,bte)@
	@:mal_coercion(oid,sht)@
	@:mal_coercion(oid,int)@
	@:mal_coercion(oid,flt)@
	@:mal_coercion(oid,dbl)@

	@:mal_coercion(ptr,ptr)@

	@:mal_coercion(flt,flt)@
	@:mal_coercion(flt,dbl)@
	@:mal_coercion(flt,bte)@
	@:mal_coercion(flt,sht)@
	@:mal_coercion(flt,int)@
	@:mal_coercion(flt,lng)@

	@:mal_coercion(dbl,dbl)@
	@:mal_coercion(dbl,flt)@
	@:mal_coercion(dbl,bte)@
	@:mal_coercion(dbl,sht)@
	@:mal_coercion(dbl,int)@
	@:mal_coercion(dbl,lng)@

	@:mal_coercion(str,bte)@
	@:mal_coercion(str,sht)@
	@:mal_coercion(str,int)@
	@:mal_coercion(str,lng)@
	@:mal_coercion(str,flt)@
	@:mal_coercion(str,dbl)@

	@:mal_coercion(chr,chr)@
	@:mal_coercion(chr,bte)@
	@:mal_coercion(chr,sht)@
	@:mal_coercion(chr,int)@
	@:mal_coercion(chr,lng)@

	@:mal_coercion(bte,chr)@
	@:mal_coercion(bte,bte)@
	@:mal_coercion(bte,sht)@
	@:mal_coercion(bte,int)@
	@:mal_coercion(bte,lng)@
# @+ Boolean operations { or, xor, and, not }
command or(left:bit, right:bit) :bit 
address CALCbinaryORbit;
command and(left:bit, right:bit) :bit 
address CALCbinaryANDbit;
command xor(left:bit, right:bit) :bit 
address CALCbinaryXORbit;
command not(left:bit) :bit 
address CALCunarybitNOT ;

pattern ifthenelse(b:bit,t:any_1,f:any_1):any_1 
address CALCswitchbit;

# @+ Bitwise operations
# Cardinal numerical types (inclusing @emph{chr} can be regarded as a bit
# array. Specific operations work with this interpretation.
@= mal_bitwise_ops
		command or(left:@1, right:@1) :@1 
		address CALCbinaryOR@1@1;
		command and(left:@1, right:@1) :@1 
		address CALCbinaryAND@1@1;
		command xor(left:@1, right:@1) :@1 
		address CALCbinaryXOR@1@1;
		command not(left:@1) :@1 
		address CALCunary@1NOT;
		command <<(left:@1,right:int) :@1 
		address CALCbinaryLSH@1int;
		command >>(left:@1, right:int) :@1 
		address CALCbinaryRSH@1int;
@
@mal
	@:mal_bitwise_ops(chr)@
	@:mal_bitwise_ops(bte)@
	@:mal_bitwise_ops(sht)@
	@:mal_bitwise_ops(int)@
	@:mal_bitwise_ops(lng)@
	# @+ Type coercions
	# The Monet kernel contains a few built-in atomic types together
	# with useful functions.
	# Those accessible at the MAL command level are introduced below.
@= convertCmd
		command @1(v:str):@1 
		address CALCstr2@1;
		command str(v:@1):str 
		address CALC@12str;
		command @1(v:void) :@1 
		address CALCnil2@1;

@
@mal
@:convertCmd(oid)@
@:convertCmd(sht)@
@:convertCmd(int)@
@:convertCmd(bat)@
@:convertCmd(lng)@
@:convertCmd(flt)@
@:convertCmd(dbl)@
@:convertCmd(bit)@
@:convertCmd(ptr)@
@:convertCmd(chr)@
@:convertCmd(bte)@

command bat(v:str):bat[:any_1,:any_2] 
address CALCstr2bat;
command str(v:bat[:any_1,:any_2]):str 
address CALCbat2str;
command bat(v:void) :bat[:any_1,:any_2] 
address CALCnil2bat;

# @-
# command bat(b:bat):bat[:any_1,:any_2]
# address CALCBAT2bat;
# command bat(b:bat[:any_1,:any_2]):bat
# address CALCbat2BAT;

command str(v:void) :str 
address CALCnil2str;
command str(v:str) :str 
address CALCstr2str;

command void(v:void) :void 
address CALCnil2void;
command void(v:int) :void 
address CALCint2void;
command void(v:sht) :void 
address CALCsht2void;
command void(v:lng) :void 
address CALClng2void;

command setoid(v:int)
address intSetoidImpl;
command setoid(v:lng)
address lngSetoidImpl;
command setoid(v:oid)
address oidSetoidImpl;

command getBATidentifier(b:bat[:any_1,:any_2]):bat
address CALCbat2batid
comment "Coerce bat to BAT identifier";
command getBAT(b:bat):bat[:any_1,:any_2]
address CALCbatid2bat
comment "Coerce bat to BAT identifier";

# @-
# We should also deal with superflous operations, such as int(v:int).
# This is a noop operation that should ideally be filtered out with
# the code squeezer. [TODO]
# @+ OID utility functions
command newoid{unsafe}() :oid 
address CALCnewoidBase
comment "Generate a new oid. Equivalent to newoid(0,1)";

command newoid{unsafe}(incr:lng) :oid 
address CALCnewoidInclng;
command newoid{unsafe}(incr:int) :oid 
address CALCnewoidInc
comment "Reserves a range of consecutive unique OIDs; returns the lowest 
		in range.  equivalent to newoid(0,incr)";

command setoid{unsafe}(base:oid) :oid 
address CALCsetoidInc
comment "Sets the oid range of consecutive unique OIDs; returns the 
		lowest in range.";

command setoid{unsafe}() :oid 
address CALCsetoidBase
comment "Equivalent to setoid(1:oid).";
@h
/*
 * @+ Implementation
 * The implementation below differs from the pre-V5 implementation in
 * that all strings and pointers are passed by reference, rather than
 * by value. Since it is unclear in the module implementation whether
 * such references are static or refer to dynamic allocated space,
 * we have to be conservative. All deallocation calls should be prepared
 * and handled by the environment.
 * For this module this won't be a problem, because we do not change
 * the string representations.
 */
#ifndef __calc_H__
#define __calc_H__

#include "stdlib.h"
#include "mal.h"
#include "mal_exception.h"
#include "mal_interpreter.h"

#ifdef WIN32
#if !defined(LIBMAL) && !defined(LIBATOMS) && !defined(LIBKERNEL) && !defined(LIBMAL) && !defined(LIBOPTIMIZER) && !defined(LIBSCHEDULER) && !defined(LIBMONETDB5)
#define calc_export extern __declspec(dllimport)
#else
#define calc_export extern __declspec(dllexport)
#endif
#else
#define calc_export extern
#endif

#endif /* __calc_H__ */
@c
#include "monetdb_config.h"
#include "calc.h"

/* third param indicates return value if one of the params is nil */
@:c_comp_ops(<,LT)@
@:c_comp_ops(<=,LE)@
@:c_comp_ops(==,EQ)@
@:c_comp_ops(!=,NEQ)@
@:c_comp_ops(>=,GE)@
@:c_comp_ops(>,GT)@

/* the normal implementation of an operator is to just stick the
   operator between the operands */
#define calc_abs(s) ((s) > 0 ? (s) : -(s))
#define calc_inv(s) (1/(s))
#define calc_neg(s) (-(s))
#define calc_sign(s) ((s) < 0 ? -1 : (s) == 0 ? 0 : 1)

@= calc_length
calc_export str CALCsizeof@1(int *res , @1 *a );
str CALCsizeof@1(int *res , @1 *a ) {
   *res = sizeof(*a);
   return(MAL_SUCCEED);
}
@
@c

@= c_unary_ops
@:calc_unop(ABS,calc_abs,@1)@
@:check_unop(INV,calc_inv,@1)@
@:calc_unop(NEG,calc_neg,@1)@
@:calc_unopint(SIGN,calc_sign,@1)@
@:calc_length(@1)@
@
@c
@:unary_ops(c)@

calc_export str CALClengthstr(int *res , str *a );
str CALClengthstr(int *res , str *a ) {
   *res = (int) strlen(*a);
   return(MAL_SUCCEED);
}
@:any_binary_minmax(MIN,<=)@
@:any_binary_minmax(MAX,>)@
@:any_binary_minmax_no_nil(MIN,<=)@
@:any_binary_minmax_no_nil(MAX,>)@

/*
 * @-
 */
@= calc_macrobinop
calc_export str CALCbinary@1@3(@3 *res , @3 *a, @3 *b );
str CALCbinary@1@3(@3 *res , @3 *a, @3 *b ) {
#ifdef DEBUG
	printf( "CALCbinary@1@3\n");
#endif
   if (*a == @3_nil || *b == @3_nil) {
	*res = @3_nil;
   } else {
   	*res = @2 (*a,*b);
   }
   return(MAL_SUCCEED);
}
@
@c
/*
 * @-
 */
@= calc_macrobinop_no_nil
calc_export str CALCbinary@1_NO_NIL@3(@3 *res , @3 *a, @3 *b );
str CALCbinary@1_NO_NIL@3(@3 *res , @3 *a, @3 *b ) {
#ifdef DEBUG
	printf( "CALCbinary@1_NO_NIL@3\n");
#endif
   *res = @2 (*a,*b);
   return(MAL_SUCCEED);
}
@
@c
#define calc_max(s1,s2) ((s1)>(s2))?(s1):(s2)
#define calc_min(s1,s2) ((s1)<(s2))?(s1):(s2)

@= max_min_def
#define calc_max_no_nil_@1(s1,s2) (s1==@1_nil)?(s2):(s2==@1_nil)?(s1):calc_max(s1,s2) 
#define calc_min_no_nil_@1(s1,s2) (s1==@1_nil)?(s2):(s2==@1_nil)?(s1):calc_min(s1,s2) 
@
@c

@= calc_min_max
@:calc_macrobinop(MAX,calc_max,@1)@
@:calc_macrobinop(MIN,calc_min,@1)@
@:max_min_def(@1)@
@:calc_macrobinop_no_nil(MAX,calc_max_no_nil_@1,@1)@
@:calc_macrobinop_no_nil(MIN,calc_min_no_nil_@1,@1)@
@
@c

@:calc_min_max(bit)@
@:calc_min_max(chr)@
@:calc_min_max(bte)@
@:calc_min_max(sht)@
@:calc_min_max(int)@
@:calc_min_max(wrd)@
@:calc_min_max(oid)@
@:calc_min_max(flt)@
@:calc_min_max(dbl)@
@:calc_min_max(lng)@

@:c_bitwise_ops(chr)@
@:c_bitwise_ops(bte)@
@:c_bitwise_ops(sht)@
@:c_bitwise_ops(int)@
@:c_bitwise_ops(lng)@

@:c_shift_ops(chr)@
@:c_shift_ops(bte)@
@:c_shift_ops(sht)@
@:c_shift_ops(int)@

calc_export str CALCstrConcat(str *ret, str *l, str *r);
str
CALCstrConcat(str *ret, str *l, str *r)
{
	str s;

	if ( strNil(*l) || strNil(*r)){
		*ret= GDKstrdup(str_nil);
		return MAL_SUCCEED;
	}
	s = GDKmalloc(strlen(*l) +  strlen(*r) + 1);
	if ( s == NULL)
		throw(MAL, "strConcat", MAL_MALLOC_FAIL);
	*s = 0;
	strcpy(s, *l);
	strcat(s, *r);
	*ret = s;
	return MAL_SUCCEED;
}

calc_export str CALCstrConcatInt(str *ret, str *l, int *r);
str
CALCstrConcatInt(str *ret, str *l, int *r)
{
	str s;
	int len;

	if (strNil(*l)|| *r == int_nil){
		*ret= GDKstrdup(str_nil);
		return MAL_SUCCEED;
	}
	len = (int) (*l?strlen(*l):0) + 32;
	s = GDKmalloc(len);
	if ( s == NULL)
		throw(MAL, "strConcatInt", MAL_MALLOC_FAIL);
	snprintf(s, len, "%s%d", (*l?*l:""), *r);
	*ret = s;
	return MAL_SUCCEED;
}

calc_export str CALCbinaryRSHlngint(lng *ret, lng *val, int *shift);
str
CALCbinaryRSHlngint(lng *ret, lng *val, int *shift)
{
	if (*val == lng_nil || *shift == int_nil) {
		*ret = lng_nil;
	} else {
		*ret = *val >> *shift;
	}
	return MAL_SUCCEED;
}

calc_export str CALCbinaryLSHlngint(lng *ret, lng *val, int *shift);
str
CALCbinaryLSHlngint(lng *ret, lng *val, int *shift)
{
	if (*val == lng_nil || *shift == int_nil) {
		*ret = lng_nil;
	} else {
		*ret = *val << *shift;
	}
	return MAL_SUCCEED;
}

calc_export str CALCbinaryANDbit(bit *retval, bit *v1, bit *v2);
str
CALCbinaryANDbit(bit *retval, bit *v1, bit *v2)
{
	if (*v1 == FALSE || *v2 == FALSE) {
		*retval = FALSE;
	} else if (*v1 == bit_nil || *v2 == bit_nil) {
		*retval = bit_nil;
	} else {
		*retval = TRUE;
	}
	return MAL_SUCCEED;
}

calc_export str CALCbinaryORbit(bit *retval, bit *v1, bit *v2);
str
CALCbinaryORbit(bit *retval, bit *v1, bit *v2)
{
	if (*v1 && *v1 != bit_nil) {
		*retval = TRUE;
	} else if (*v2 && *v2 != bit_nil) {
		*retval = TRUE;
	} else if (*v1 == bit_nil || *v2 == bit_nil) {
		*retval = bit_nil;
	} else {
		*retval = *v1 || *v2;
	}
	return MAL_SUCCEED;
}

calc_export str CALCbinaryXORbit(bit *retval, bit *v1, bit *v2);
str
CALCbinaryXORbit(bit *retval, bit *v1, bit *v2)
{
	if (*v1 == bit_nil || *v2 == bit_nil) {
		*retval = bit_nil;
	} else {
		*retval = ((*v1 && *v2 == FALSE) || (*v1 == FALSE && *v2));
	}
	return MAL_SUCCEED;
}

calc_export str CALCunarybitNOT(bit *retval, bit *value);
str
CALCunarybitNOT(bit *retval, bit *value)
{
	if (*value == bit_nil) {
		*retval = bit_nil;
	} else {
		*retval = (*value) ? FALSE : TRUE;
	}
	return MAL_SUCCEED;
}

/*
calc_export str CALCswitchbit(ptr retval, bit *b, ptr v1, ptr v2);
str
*/
calc_export str CALCswitchbit(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
str 
CALCswitchbit(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr P)
{
	ptr p;
	ptr retval = getArgReference(stk,P,0);
	bit b = *(bit*) getArgReference(stk,P,1);
	int t1 = getArgType(mb, P, 2);
	int t2 = getArgType(mb, P, 3);

	(void) cntxt;
	if (t1 != t2)
		throw(MAL, "ifthenelse", SEMANTIC_TYPE_MISMATCH);

	if (b == bit_nil) {
		*(ptr**)retval = p = ATOMnilptr(t1);
		return MAL_SUCCEED;
	} else if (b) {
		p = getArgReference(stk,P,2);
	} else {
		p = getArgReference(stk,P,3);
	}
	if (ATOMextern(t1)) {
		*(ptr **) retval = ATOMdup(t1, *(ptr**)p);
	} else {
		memcpy(retval, p, ATOMsize(t1));
	}
	return MAL_SUCCEED;
}


/*
 * @-
 * The @emph{c_comp} and @emph{c_comp_ops} macros implement the mil comparison
 * operations.
 */
@= any_binary_minmax
calc_export str CALCbinary@1any(ptr ret, ptr v1, int t, ptr v2);
str CALCbinary@1any(ptr ret, ptr v1, int t, ptr v2){
	int (*cmp)(ptr,ptr) = BATatoms[t].atomCmp;
	ptr src, nil = ATOMnilptr(t);
	if ((*cmp)(v1, nil) == 0 || (*cmp)(v2, nil) == 0) {
		src = nil;
	} else {
		src = ((*cmp)(v1, v2) @2 0)?v1:v2;
	}
	if (ATOMextern(t)) {
		int s = ATOMlen(t, src);
		str buf = *(str*) ret = (char*) GDKmalloc(s);
		if ( buf == NULL)
			throw(MAL, "CALCbinary@1any", MAL_MALLOC_FAIL);
		memcpy(buf, src, s);
	} else {
		memcpy(ret, src, ATOMsize(t));
	}
	return MAL_SUCCEED;
}

@= any_binary_minmax_no_nil
calc_export str CALCbinary@1_no_nilany(ptr ret, ptr v1, int t, ptr v2);
str CALCbinary@1_no_nilany(ptr ret, ptr v1, int t, ptr v2){
	int (*cmp)(ptr,ptr) = BATatoms[t].atomCmp;
	ptr src, nil = ATOMnilptr(t);
	if ((*cmp)(v1, nil) == 0)
		src = v2;
	else if ((*cmp)(v2, nil) == 0) {
		src = v1;
	} else {
		src = ((*cmp)(v1, v2) @2 0)?v1:v2;
	}
	if (ATOMextern(t)) {
		int s = ATOMlen(t, src);
		str buf = *(str*) ret = (char*) GDKmalloc(s);
		if ( buf == NULL)
			throw(MAL, "CALCbinary@1_no_nilany", MAL_MALLOC_FAIL);
		memcpy(buf, src, s);
	} else {
		memcpy(ret, src, ATOMsize(t));
	}
	return MAL_SUCCEED;
}

@= c_comp_op
calc_export str CALCcomp@4@2@3(bit *retval, @2 *v1, @3 *v2);
str CALCcomp@4@2@3(bit *retval, @2 *v1, @3 *v2){
	if (*v1 == @2_nil || *v2 == @3_nil) {
		*retval = bit_nil;
	} else {
		*retval = *v1 @1 *v2;	
	}
	return MAL_SUCCEED;
}
@= c_comp_ops
		@:c_comp_op(@1,oid,oid,@2)@
		@:c_comp_op(@1,flt,flt,@2)@
		@:c_comp_op(@1,flt,dbl,@2)@
		@:c_comp_op(@1,dbl,dbl,@2)@

		@:c_comp_op(@1,chr,chr,@2)@
		@:c_comp_op(@1,chr,bte,@2)@
		@:c_comp_op(@1,chr,sht,@2)@
		@:c_comp_op(@1,chr,int,@2)@
		@:c_comp_op(@1,chr,wrd,@2)@
		@:c_comp_op(@1,chr,lng,@2)@

		@:c_comp_op(@1,bte,chr,@2)@
		@:c_comp_op(@1,bte,bte,@2)@
		@:c_comp_op(@1,bte,sht,@2)@
		@:c_comp_op(@1,bte,wrd,@2)@
		@:c_comp_op(@1,bte,int,@2)@
		@:c_comp_op(@1,bte,lng,@2)@

		@:c_comp_op(@1,bit,bit,@2)@
		@:c_comp_op(@1,bit,chr,@2)@
		@:c_comp_op(@1,bit,bte,@2)@
		@:c_comp_op(@1,bit,sht,@2)@
		@:c_comp_op(@1,bit,wrd,@2)@
		@:c_comp_op(@1,bit,int,@2)@
		@:c_comp_op(@1,bit,lng,@2)@

		@:c_comp_op(@1,sht,chr,@2)@
		@:c_comp_op(@1,sht,bte,@2)@
		@:c_comp_op(@1,sht,sht,@2)@
		@:c_comp_op(@1,sht,int,@2)@
		@:c_comp_op(@1,sht,wrd,@2)@
		@:c_comp_op(@1,sht,lng,@2)@

		@:c_comp_op(@1,int,chr,@2)@
		@:c_comp_op(@1,int,bte,@2)@
		@:c_comp_op(@1,int,sht,@2)@
		@:c_comp_op(@1,int,int,@2)@
		@:c_comp_op(@1,int,wrd,@2)@
		@:c_comp_op(@1,int,lng,@2)@

		@:c_comp_op(@1,wrd,chr,@2)@
		@:c_comp_op(@1,wrd,bte,@2)@
		@:c_comp_op(@1,wrd,sht,@2)@
		@:c_comp_op(@1,wrd,int,@2)@
		@:c_comp_op(@1,wrd,wrd,@2)@
		@:c_comp_op(@1,wrd,lng,@2)@

		@:c_comp_op(@1,lng,chr,@2)@
		@:c_comp_op(@1,lng,bte,@2)@
		@:c_comp_op(@1,lng,sht,@2)@
		@:c_comp_op(@1,lng,int,@2)@
		@:c_comp_op(@1,lng,wrd,@2)@
		@:c_comp_op(@1,lng,lng,@2)@

calc_export str CALCcomp@2strstr(bit *retval, str *s1, str *s2);
str CALCcomp@2strstr(bit *retval, str *s1, str *s2){
	if (strNil(*s1) || strNil(*s2)) {
		*retval = bit_nil; 
	} else {
		*retval = (strcmp(*s1,*s2) @1 0);
	}
	return MAL_SUCCEED;
}
calc_export str CALCcomp@2any(bit *retval, ptr *v1, int tpe, ptr *v2);
str CALCcomp@2any(bit *retval, ptr *v1, int tpe, ptr *v2){
	int (*cmp)(ptr,ptr) = BATatoms[tpe].atomCmp;
	ptr nil = ATOMnilptr(tpe);

	if ((*cmp)(*v1, nil) == 0 || (*cmp)(*v2, nil) == 0) {
		*retval = bit_nil; 
	} else {
		*retval = ((*cmp)( *v1, *v2) @1 0);
	}
	return MAL_SUCCEED;
}
@
@c
@:c_between_op(chr)@
@:c_between_op(bte)@
@:c_between_op(sht)@
@:c_between_op(int)@
@:c_between_op(oid)@
@:c_between_op(flt)@
@:c_between_op(dbl)@
@:c_between_op(lng)@
@:c_between_op(wrd)@
calc_export str CALCcompBetweenstr(bit *retval, str *val, str *low, str *high);
str
CALCcompBetweenstr(bit *retval, str *val, str *low, str *high)
{
	int val_nil = strNil(*val);
	int low_nil = strNil(*low);
	int high_nil = strNil(*high);

	if (val_nil || (low_nil && high_nil)) {
		*retval = bit_nil;
	} else if (low_nil) {
		*retval = (strcmp(*val, *high) <= 0);
	} else if (high_nil) {
		*retval = (strcmp(*low, *val) <= 0);
	} else {
		*retval = (strcmp(*low, *val) <= 0 && strcmp(*val, *high) <= 0);
	}
	return MAL_SUCCEED;
}

calc_export str CALCcompBetweenany(bit *retval, ptr *val, int tpe, ptr *low, ptr *high);
str
CALCcompBetweenany(bit *retval, ptr *val, int tpe, ptr *low, ptr *high)
{
	int (*cmp) (ptr, ptr) = BATatoms[tpe].atomCmp;
	ptr nilptr = ATOMnilptr(tpe);
	int val_nil = ((*cmp) (*val, nilptr) == 0);
	int low_nil = ((*cmp) (*low, nilptr) == 0);
	int high_nil = ((*cmp) (*high, nilptr) == 0);

	if (val_nil || (low_nil && high_nil)) {
		*retval = bit_nil;
	} else if (low_nil) {
		*retval = ((*cmp) (*val, *high) <= 0);
	} else if (high_nil) {
		*retval = ((*cmp) (*low, *val) <= 0);
	} else {
		*retval = ((*cmp) (*low, *val) <= 0 && (*cmp) (*val, *high) <= 0);
	}
	return MAL_SUCCEED;
}

@= c_isnil
calc_export str CALCisnil_@1(bit *retval, @1 *val);
str CALCisnil_@1(bit *retval, @1 *val) {
	*retval = (*val == @1_nil);
	return MAL_SUCCEED;
}
calc_export str CALCisnotnil_@1(bit *retval, @1 *val);
str CALCisnotnil_@1(bit *retval, @1 *val) {
	*retval = (*val != @1_nil);
	return MAL_SUCCEED;
}
calc_export str CALCnil2@1(@1 *retval, ptr val);
str CALCnil2@1(@1 *retval, ptr val){
	(void) val;/* fool compiler */
	memcpy(retval, ATOMnilptr(TYPE_@1), ATOMsize(TYPE_@1));
	return MAL_SUCCEED;
}
@
@c
@:c_isnil(bit)@
@:c_isnil(chr)@
@:c_isnil(bte)@
@:c_isnil(sht)@
@:c_isnil(int)@
@:c_isnil(oid)@
@:c_isnil(wrd)@
@:c_isnil(lng)@
@:c_isnil(flt)@
@:c_isnil(dbl)@
@:c_isnil(ptr)@
@:c_isnil(bat)@

calc_export str CALCisnil_str(bit *retval, str *val);
str
CALCisnil_str(bit *retval, str *val)
{
	*retval = strcmp(*val, ATOMnilptr(TYPE_str)) == 0;
	return MAL_SUCCEED;
}

calc_export str CALCisnotnil_str(bit *retval, str *val);
str
CALCisnotnil_str(bit *retval, str *val)
{
	*retval = strcmp(*val, ATOMnilptr(TYPE_str));
	return MAL_SUCCEED;
}

calc_export str CALCstr2nil(str *retval, str *val);
str
CALCstr2nil(str *retval, str *val)
{
	(void) val;		/* fool compiler */
	*retval = GDKstrdup(ATOMnilptr(TYPE_str));
	return MAL_SUCCEED;
}

calc_export str CALCisnil_any(bit *retval, ptr *val, int tpe);
str
CALCisnil_any(bit *retval, ptr *val, int tpe)
{
	ptr nilval = ATOMnilptr(tpe);

	*retval = (ATOMcmp(tpe, nilval, *val) == 0);
	return MAL_SUCCEED;
}

calc_export str CALCisnil_void(bit *retval, oid *val);
str
CALCisnil_void(bit *retval, oid *val)
{
	*retval = (*val == oid_nil);
	return MAL_SUCCEED;
}

calc_export str CALCisnotnil_void(bit *retval, oid *val);
str
CALCisnotnil_void(bit *retval, oid *val)
{
	*retval = (*val != oid_nil);
	return MAL_SUCCEED;
}

@= c_between_op
calc_export str CALCcompBetween@1(bit *retval, @1 *v, @1 *low, @1 *high);
str CALCcompBetween@1(bit *retval, @1 *v, @1 *low, @1 *high){
	if (*v == @1_nil || (*low == @1_nil && *high == @1_nil)) {
		*retval = bit_nil;
	} else if (*low == @1_nil) {
		*retval = (*v <= *high);
	} else if (*high == @1_nil) {
		*retval = (*low <= *v);
	} else {
		*retval = (*low <= *v) && (*v <= *high);	
	}
	return MAL_SUCCEED;
}
@
@c
/*
 * @-
 * The @emph{c_calc_ops} implement the arithmetic operations on the given type.
 * The @emph{c_calc_ops} macro gets three arguments, two input types and a
 * result type.
 *
 * // these defines are used in the implementation of
 *    *_checkbinary_{DIV,MOD} (see Mx macro check_binop)
 */
#define CMD_MOD 1
#define CMD_DIV 0

@= c_calc_ops
@:sqlnull_binop(SQLADD,+,@1,@2,@3)@
@:calc_binop(ADD,+,@1,@2,@3)@
@:calc_binop(SUB,-,@1,@2,@3)@
@:calc_binop(MUL,*,@1,@2,@3)@
@:check_binop(DIV,/,@1,@2,@3,@3,"Division by zero")@
@:check_binop(MOD,%,@1,@2,@3,@4,"Modulo zero is not possible")@
@
@c
@:calc_ops(c)@

@= calc_unop
calc_export str CALCunary@3@1(@3 *res , @3 *a );
str CALCunary@3@1(@3 *res , @3 *a ) {
#ifdef DEBUG
	printf( "CALCunary@3@1\n");
#endif
   if (*a == @3_nil) {
	   *res = @3_nil;
   } else {   
		   *res = (@3) (@2 (*a));
   }
   return(MAL_SUCCEED);
}
@
@= calc_unopint
calc_export str CALCunary@3@1(int *res , @3 *a );
str CALCunary@3@1(int *res , @3 *a ) {
#ifdef DEBUG
	printf( "CALCunary@3@1\n");
#endif
   if (*a == @3_nil) {
	   *res = int_nil;
   } else {
		   *res = (int) (@2 (*a));
   }
   return(MAL_SUCCEED);
}
@
@= check_unop
calc_export str CALCunarycheck@3@1(@3 *res , @3 *a );
str CALCunarycheck@3@1(@3 *res , @3 *a ) {
#ifdef DEBUG
	printf( "CALCunary@3@1\n");
#endif
	if (*a == 0 ){
		throw(MAL, "calc.@3", ILLEGAL_ARGUMENT " Reference error");
	} else if ( *a == @3_nil) {
		*res = @3_nil;
	} else {
		*res = @2 (*a);
	}
	return(MAL_SUCCEED);
}
@
@= calc_binop
calc_export str CALCbinary@1@3@4(@5 *res, @3 *a, @4 *b );
str CALCbinary@1@3@4(@5 *res, @3 *a, @4 *b ) {
#ifdef DEBUG
	printf( "CALCbinary@1@3@4\n");
#endif
   if (*a == @3_nil || *b == @4_nil) {
	*res = @5_nil;
   } else {
   	*res = ((@5)(*a)) @2 ((@5)(*b));
   }
   return(MAL_SUCCEED);
}

@= sqlnull_binop
calc_export str CALCbinary@1@3@4(@5 *res, @3 *a, @4 *b );
str CALCbinary@1@3@4(@5 *res, @3 *a, @4 *b ) {
#ifdef DEBUG
	printf( "CALCbinary@1@3@4\n");
#endif
   if (*a == @3_nil && *b == @4_nil) {
	*res = @5_nil;
   } else if (*a == @3_nil && *b != @4_nil) {
	*res = (@5)*b;
   } else if (*a != @3_nil && *b == @4_nil) {
	*res = (@5)*a;
   } else {
   	*res = ((@5)(*a)) @2 ((@5)(*b));
   }
   return(MAL_SUCCEED);
}
@
 * //
 * 	1: function name suffix (_MOD,_DIV etc)
 * 	2: operator (%,/ etc)
 * 	3: type argument 1
 * 	4: type argument 2
 * 	5: result type
 * 	6: intermediate type (sometimes the result is a smaller type (%))
 * 	7: Error message when something goes wrong.
 *
@= check_binop
calc_export str CALCbinarycheck@1@3@4(@5 *res, @3 *a, @4 *b );
str CALCbinarycheck@1@3@4(@5 *res, @3 *a, @4 *b ) {
#ifdef DEBUG
	printf( "CALCbinarycheck@1@3@4\n");
#endif
   if (*a == @3_nil || *b == @4_nil) {
	*res = @5_nil;
   } else if (*b == 0) {
	throw(MAL, "calc.@2", ILLEGAL_ARGUMENT " "@7);
   } else {
#if TYPE_@3 == TYPE_flt || TYPE_@3 == TYPE_dbl || TYPE_@4 == TYPE_flt || TYPE_@4 == TYPE_dbl
		/* at least one of the operands is a floating point
		   type, do calculations in double precision */
#if CMD_@1
		/* special case for floating point modulo */
		*res = (@5) ((dbl)*a - (dbl) ((lng) ((dbl)*a / (dbl)*b)) * (dbl)*b);
#else
		*res = (@5) ((dbl)*a @2 (dbl)*b);
#endif
#else
		/* neither operand is floating point, use the largest
		   of the operands as intermediate type */
#if TYPE_@3 > TYPE_@4
		*res = (@5) ((@3)*a @2 (@3)*b);
#else
		*res = (@5) ((@4)*a @2 (@4)*b);
#endif
#endif
   }
   return(MAL_SUCCEED);
}
@
@= c_bitwise_ops
@:calc_binop(OR,|,@1,@1,@1)@
@:calc_binop(AND,&,@1,@1,@1)@
@:calc_binop(XOR,^,@1,@1,@1)@
@:calc_unop(NOT,~,@1)@

@= c_shift_ops
@:calc_binop(LSH,<<,@1,int,@1)@
@:calc_binop(RSH,>>,@1,int,@1)@

@
 * @+ The Coercion implementation
 * Coercions generally do not check on information loss
 * @-
@= mal_coercion_impl
calc_export str CALC@22@1(@1 *res, @2 *a);
str CALC@22@1(@1 *res, @2 *a)
{
	if (*a == @2_nil @3) {
		*res= @1_nil;
/*	obey semantics above, don't check for information loss
		if (*a != @2_nil)
			throw(MAL, "calc.@1", ARGUMENT_TOO_LARGE);
*/
	} else {
		*res= @4;
	}
	return MAL_SUCCEED;
}
@
@c
/*
 * @-
 */
@:mal_coercion_impl(bit,bit, , *a != 0)@
@:mal_coercion_impl(bit,oid, , *a != 0)@
@:mal_coercion_impl(bit,chr, , *a != 0)@
@:mal_coercion_impl(bit,bte, , *a != 0)@
@:mal_coercion_impl(bit,sht, , *a != 0)@
@:mal_coercion_impl(bit,int, , *a != 0)@
@:mal_coercion_impl(bit,wrd, , *a != 0)@
@:mal_coercion_impl(bit,lng, , *a != 0)@
@:mal_coercion_impl(bit,flt, , *a != 0)@
@:mal_coercion_impl(bit,dbl, , *a != 0)@

@:mal_coercion_impl(lng,oid,, (lng) *a)@
@:mal_coercion_impl(lng,chr,, (lng) *a)@
@:mal_coercion_impl(lng,bte,, (lng) *a)@
@:mal_coercion_impl(lng,bit,, (lng) *a)@
@:mal_coercion_impl(lng,sht,, (lng) *a)@
@:mal_coercion_impl(lng,int,, (lng) *a)@
@:mal_coercion_impl(lng,wrd,, (lng) *a)@
@:mal_coercion_impl(lng,lng,,       *a)@
@:mal_coercion_impl(lng,flt, || *a < (flt) GDK_lng_min || *a > (flt) GDK_lng_max, (lng) *a)@
@:mal_coercion_impl(lng,dbl, || *a < (dbl) GDK_lng_min || *a > (dbl) GDK_lng_max, (lng) *a)@

@:mal_coercion_impl(sht,oid, || *a > GDK_sht_max, (sht) *a)@
@:mal_coercion_impl(sht,bit, , (sht) *a)@
@:mal_coercion_impl(sht,chr, , (sht) *a)@
@:mal_coercion_impl(sht,bte, , (sht) *a)@
@:mal_coercion_impl(sht,sht, ,       *a)@
@:mal_coercion_impl(sht,int, || *a < GDK_sht_min || *a > GDK_sht_max, (sht) *a)@
@:mal_coercion_impl(sht,wrd, || *a < GDK_sht_min || *a > GDK_sht_max, (sht) *a)@
@:mal_coercion_impl(sht,lng, || *a < GDK_sht_min || *a > GDK_sht_max, (sht) *a)@
@:mal_coercion_impl(sht,flt, || *a < GDK_sht_min || *a > GDK_sht_max, (sht) *a)@
@:mal_coercion_impl(sht,dbl, || *a < GDK_sht_min || *a > GDK_sht_max, (sht) *a)@

#if SIZEOF_OID == SIZEOF_INT
@:mal_coercion_impl(int,oid, , (int) *a)@
#else
@:mal_coercion_impl(int,oid, || *a > GDK_int_max, (int) *a)@
#endif
@:mal_coercion_impl(int,bit, , (int) *a)@
@:mal_coercion_impl(int,chr, , (int) *a)@
@:mal_coercion_impl(int,bte, , (int) *a)@
@:mal_coercion_impl(int,sht, , (int) *a)@
@:mal_coercion_impl(int,int, ,       *a)@
#if SIZEOF_WRD == SIZEOF_INT
@:mal_coercion_impl(int,wrd, , (int) *a)@
#else
@:mal_coercion_impl(int,wrd, || *a < GDK_int_min || *a > GDK_int_max, (int) *a)@
#endif
@:mal_coercion_impl(int,lng, || *a < GDK_int_min || *a > GDK_int_max, (int) *a)@
@:mal_coercion_impl(int,flt, || *a < GDK_int_min || *a > GDK_int_max, (int) *a)@
@:mal_coercion_impl(int,dbl, || *a < GDK_int_min || *a > GDK_int_max, (int) *a)@

@:mal_coercion_impl(wrd,oid, , (wrd) *a)@
@:mal_coercion_impl(wrd,bit, , (wrd) *a)@
@:mal_coercion_impl(wrd,chr, , (wrd) *a)@
@:mal_coercion_impl(wrd,bte, , (wrd) *a)@
@:mal_coercion_impl(wrd,sht, , (wrd) *a)@
@:mal_coercion_impl(wrd,int, , (wrd) *a)@
@:mal_coercion_impl(wrd,wrd, ,       *a)@
#if SIZEOF_WRD == SIZEOF_LNG
@:mal_coercion_impl(wrd,lng, , (wrd) *a)@
#else
@:mal_coercion_impl(wrd,lng, || *a < GDK_wrd_min || *a > GDK_wrd_max, (wrd) *a)@
#endif
@:mal_coercion_impl(wrd,flt, || *a < GDK_wrd_min || *a > GDK_wrd_max, (wrd) *a)@
@:mal_coercion_impl(wrd,dbl, || *a < GDK_wrd_min || *a > GDK_wrd_max, (wrd) *a)@

@:mal_coercion_impl(oid,bit, || *a < 0 , (oid) *a)@
@:mal_coercion_impl(oid,chr, || *a < 0 , (oid) *a)@
@:mal_coercion_impl(oid,bte, || *a < 0 , (oid) *a)@
@:mal_coercion_impl(oid,oid, , *a)@
#if SIZEOF_OID == SIZEOF_LNG
@:mal_coercion_impl(oid,lng, || *a < 0 , (oid) *a)@
#else
@:mal_coercion_impl(oid,lng, || *a < 0 || *a > GDK_oid_max, (oid) *a)@
#endif
@:mal_coercion_impl(oid,sht, || *a < 0 , (oid) *a)@
@:mal_coercion_impl(oid,int, || *a < 0 , (oid) *a)@
@:mal_coercion_impl(oid,wrd, || *a < 0 , (oid) *a)@
@:mal_coercion_impl(oid,flt, || *a < 0 || *a > GDK_oid_max, (oid) *a)@
@:mal_coercion_impl(oid,dbl, || *a < 0 || *a > GDK_oid_max, (oid) *a)@

@:mal_coercion_impl(ptr,ptr, , *a)@

@:mal_coercion_impl(flt,flt, ,       *a)@
@:mal_coercion_impl(flt,dbl, || *a < GDK_flt_min || *a > GDK_flt_max, (flt) *a)@
@:mal_coercion_impl(flt,sht, , (flt) *a)@
@:mal_coercion_impl(flt,chr, , (flt) *a)@
@:mal_coercion_impl(flt,bte, , (flt) *a)@
@:mal_coercion_impl(flt,int, , (flt) *a)@
@:mal_coercion_impl(flt,wrd, , (flt) *a)@
@:mal_coercion_impl(flt,lng, , (flt) *a)@

@:mal_coercion_impl(dbl,dbl, ,       *a)@
@:mal_coercion_impl(dbl,flt, , (dbl) *a)@
@:mal_coercion_impl(dbl,sht, , (dbl) *a)@
@:mal_coercion_impl(dbl,int, , (dbl) *a)@
@:mal_coercion_impl(dbl,wrd, , (dbl) *a)@
@:mal_coercion_impl(dbl,chr, , (dbl) *a)@
@:mal_coercion_impl(dbl,bte, , (dbl) *a)@
@:mal_coercion_impl(dbl,lng, , (dbl) *a)@

@:mal_coercion_impl(chr,bit, , (chr) *a)@
@:mal_coercion_impl(chr,chr, ,       *a)@
@:mal_coercion_impl(chr,bte, , (chr) *a)@
@:mal_coercion_impl(chr,oid, || *a > GDK_chr_max, (chr) *a)@
@:mal_coercion_impl(chr,flt, || *a < GDK_chr_min || *a > GDK_chr_max, (chr) *a)@
@:mal_coercion_impl(chr,dbl, || *a < GDK_chr_min || *a > GDK_chr_max, (chr) *a)@
@:mal_coercion_impl(chr,sht, || *a < GDK_chr_min || *a > GDK_chr_max, (chr) *a)@
@:mal_coercion_impl(chr,int, || *a < GDK_chr_min || *a > GDK_chr_max, (chr) *a)@
@:mal_coercion_impl(chr,wrd, || *a < GDK_chr_min || *a > GDK_chr_max, (chr) *a)@
@:mal_coercion_impl(chr,lng, || *a < GDK_chr_min || *a > GDK_chr_max, (chr) *a)@

@:mal_coercion_impl(bte,bit, , (bte) *a)@
@:mal_coercion_impl(bte,chr, , (bte) *a)@
@:mal_coercion_impl(bte,bte, ,       *a)@
@:mal_coercion_impl(bte,oid, || *a > GDK_bte_max, (bte) *a)@
@:mal_coercion_impl(bte,flt, || *a < GDK_bte_min || *a > GDK_bte_max, (bte) *a)@
@:mal_coercion_impl(bte,dbl, || *a < GDK_bte_min || *a > GDK_bte_max, (bte) *a)@
@:mal_coercion_impl(bte,sht, || *a < GDK_bte_min || *a > GDK_bte_max, (bte) *a)@
@:mal_coercion_impl(bte,int, || *a < GDK_bte_min || *a > GDK_bte_max, (bte) *a)@
@:mal_coercion_impl(bte,wrd, || *a < GDK_bte_min || *a > GDK_bte_max, (bte) *a)@
@:mal_coercion_impl(bte,lng, || *a < GDK_bte_min || *a > GDK_bte_max, (bte) *a)@

calc_export str CALCbat2BAT(int *res, bat *bid);
str CALCbat2BAT(int *res, bat *bid){
	*res= *bid;
	BBPincref(*res, TRUE);
	return MAL_SUCCEED;
}
calc_export str CALCBAT2bat(bat *res, int *bid);
str CALCBAT2bat(int *res, bat *bid){
	*res= *bid;
	return MAL_SUCCEED;
}
/*
 * @-
 * The conversion routines are relatively easy to define.
 */
@= convertImpl

calc_export str CALCstr2@1(@1 *ret, str *val);
str CALCstr2@1(@1 *ret, str *val){
	int l = sizeof(@1);
	(void) @1FromStr(*val, &l, &ret);
	return MAL_SUCCEED;
}
calc_export str CALC@12str(str *ret, @1 *val);
str CALC@12str(str *ret, @1 *val){
	int l=0;

	if( *val == @1_nil)
		*ret= GDKstrdup(str_nil);
	else {
		*ret = NULL;
		(void) @1ToStr(ret,&l,val);
	}
	return MAL_SUCCEED;
}
@
@c
/*
 * @-
 * Strings have to be dealt with differently, because
 * we recieve a pointer to the string directly.
 * To make it work properly, we need a call be reference
 * in those places where we leave a result behind.
 */
calc_export str CALCnil2str(str *ret, void *val);
str
CALCnil2str(str *ret, void *val)
{
	(void) val;		/* fool compiler */
	*ret = GDKstrdup(str_nil);
	return MAL_SUCCEED;
}

calc_export str CALCstr2str(str *ret, str *val);
str
CALCstr2str(str *ret, str *val)
{
	if(*val) 
		*ret = GDKstrdup(*val);
	else *ret = 0;
	return MAL_SUCCEED;
}

calc_export str CALCstr2oid(oid *ret, str *val);
str
CALCstr2oid(oid *ret, str *val)
{
	int l = (int) strlen(*val);

	(void) OIDfromStr(*val, &l, (ptr) ret);
	return MAL_SUCCEED;
}

calc_export str CALCoid2str(str *ret, oid *val);
str
CALCoid2str(str *ret, oid *val)
{
	int l = sizeof(oid);

	(void) OIDtoStr(ret, &l, val);
	return MAL_SUCCEED;
}

calc_export str CALCnil2void(oid *ret, ptr *val);
str
CALCnil2void(oid *ret, ptr *val)
{
	(void) val;		/* fool compiler */
	*ret = oid_nil;
	return MAL_SUCCEED;
}

calc_export str CALClng2void(oid *ret, lng *val);
str
CALClng2void(oid *ret, lng *val)
{
	*ret = (oid) *val;
	return MAL_SUCCEED;
}

calc_export str CALCsht2void(oid *ret, sht *val);
str
CALCsht2void(oid *ret, sht *val)
{
	*ret = *val;
	return MAL_SUCCEED;
}

calc_export str CALCint2void(oid *ret, int *val);
str
CALCint2void(oid *ret, int *val)
{
	*ret = *val;
	return MAL_SUCCEED;
}

calc_export str oidFromoidImpl(oid *ret, oid *val);
str
oidFromoidImpl(oid *ret, oid *val)
{
	*ret = *val;
	return MAL_SUCCEED;
}

calc_export str oidFromvoidImpl(oid *ret, void *val);
str
oidFromvoidImpl(oid *ret, void *val)
{
	(void) val;		/* fool compiler */
	memcpy(ret, ATOMnilptr(TYPE_oid), ATOMsize(TYPE_oid));
	return MAL_SUCCEED;
}

calc_export str CALCbat2batid(int *ret, int *bid);
str
CALCbat2batid(bat *ret, int *bid)
{
	BAT *b;

	if( *bid == bat_nil){
		*ret= bat_nil;
		return MAL_SUCCEED;
	}
	b = BATdescriptor(*bid);
	if (b == 0)
		throw(MAL, "calc.getBAT", RUNTIME_OBJECT_MISSING);
	*ret = b->batCacheid;
	BBPkeepref(b->batCacheid);
	return MAL_SUCCEED;
}

calc_export str CALCbatid2bat(int *bid, int *ret);
str
CALCbatid2bat(int *bid, int *ret)
{
	BAT *b;

	if( *ret == bat_nil){
		*bid= bat_nil;
		return MAL_SUCCEED;
	}
	b = BATdescriptor(*ret);
	if (b == 0)
		throw(MAL, "calc.:bat", RUNTIME_OBJECT_MISSING);
	*bid = b->batCacheid;
	BBPkeepref(*bid);
	return MAL_SUCCEED;
}

@:convertImpl(sht)@
@:convertImpl(int)@
@:convertImpl(lng)@
@:convertImpl(flt)@
@:convertImpl(dbl)@
@:convertImpl(bit)@
@:convertImpl(ptr)@
@:convertImpl(bat)@
@:convertImpl(chr)@
@:convertImpl(bte)@

/*
 * @-
 */
@= setoidCode
calc_export str @1SetoidImpl(str *ret, @1 *v);
str @1SetoidImpl(str *ret, @1 *v){
	(void) ret; /* fool compiler */
	OIDbase((oid) *v);
	return MAL_SUCCEED;
}
@
@c
@:setoidCode(oid)@
@:setoidCode(lng)@
@:setoidCode(int)@

/*
 * @-
 * Type conversion template. Only allowed then no information is lost.
 */
@= coercionImpl
calc_export str @1From@2Impl(@1 *res, @2 *val);
str @1From@2Impl(@1 *res, @2 *val){
	*res = (@1) *val;
	return MAL_SUCCEED;
}
@
@c
@:coercionImpl(lng,oid)@
@:coercionImpl(lng,int)@
@:coercionImpl(lng,sht)@
@:coercionImpl(lng,bit)@
@:coercionImpl(int,sht)@
@:coercionImpl(int,bit)@
@:coercionImpl(dbl,flt)@
@:coercionImpl(oid,lng)@
@:coercionImpl(oid,int)@
@:coercionImpl(oid,sht)@

calc_export str shtFromlngImpl(sht *res, lng *val);
str
shtFromlngImpl(sht *res, lng *val)
{
	/* perform a range check !! */
	if (*val < 0 || *val > 255)
		throw(MAL, "calc.sht", OPERATION_FAILED " Coercion error");
	*res = (sht) *val;
	return MAL_SUCCEED;
}

calc_export str shtFromintImpl(sht *res, int *val);
str
shtFromintImpl(sht *res, int *val)
{
	/* perform a range check !! */
	if (*val < 0 || *val > 255)
		throw(MAL, "calc.sht", OPERATION_FAILED " Coercion error");
	*res = *val;
	return MAL_SUCCEED;
}

/*
 * @+ Value, Types and Variables
 * The routines below implement the OID utility functions.
 */
calc_export str CALCnewoidBase(oid *res);
str
CALCnewoidBase(oid *res)
{
	*res = OIDnew(1);
	return MAL_SUCCEED;
}

calc_export str CALCnewoidInc(oid *res, int *inc);
str
CALCnewoidInc(oid *res, int *inc)
{
	if (*inc <= 0)
		*res = OIDnew(1);
	else {
		*res = OIDnew(*inc);
	}
	return MAL_SUCCEED;
}

calc_export str CALCnewoidInclng(oid *res, lng *inc);
str
CALCnewoidInclng(oid *res, lng *inc)
{
	if (*inc <= 0)
		*res = OIDnew(1);
	else {
		*res = OIDnew((oid) *inc);
	}
	return MAL_SUCCEED;
}

calc_export str CALCsetoidBase(oid *res);
str
CALCsetoidBase(oid *res)
{
	*res = OIDbase(1);
	return MAL_SUCCEED;
}

calc_export str CALCsetoidInc(oid *res, oid *inc);
str
CALCsetoidInc(oid *res, oid *inc)
{
	*res = OIDbase(*inc);
	return MAL_SUCCEED;
}
