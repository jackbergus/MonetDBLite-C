@/
The contents of this file are subject to the MonetDB Public License
Version 1.1 (the "License"); you may not use this file except in
compliance with the License. You may obtain a copy of the License at
http://www.monetdb.org/Legal/MonetDBLicense

Software distributed under the License is distributed on an "AS IS"
basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations
under the License.

The Original Code is the MonetDB Database System.

The Initial Developer of the Original Code is CWI.
Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
Copyright August 2008-2011 MonetDB B.V.
All Rights Reserved.
@

@f lock
@a Peter Boncz
@v 1.0
@+ Lightweight Lock Module
This module provides simple SMP lock and thread functionality
as already present in the MonetDB system.
@{
@+ Locks
@mal
atom lock:ptr;

command create() :lock 
address LCKcreate
comment "Create an unset lock";
command set(l:lock) 
address LCKset
comment "Try to set a lock. If set, block till it is freed";
command try(l:lock) :int 
address LCKtry
comment "Try a lock. If free set it, if not return EBUSY";
command unset(l:lock) 
address LCKunset
comment "Unset a lock";
command destroy(l:lock) 
address LCKdestroy
comment "Destroy a lock";
command tostr(l:lock) 
address lockToStr
comment "Overloaded atom function";

@+ Implementation

@h
#ifndef _LOCK_H
#define _LOCK_H

#include <gdk.h>

typedef ptr lock;
typedef ptr monet_lock;

#ifdef WIN32
#if !defined(LIBMAL) && !defined(LIBATOMS) && !defined(LIBKERNEL) && !defined(LIBMAL) && !defined(LIBOPTIMIZER) && !defined(LIBSCHEDULER) && !defined(LIBMONETDB5)
#define lock_export extern __declspec(dllimport)
#else
#define lock_export extern __declspec(dllexport)
#endif
#else
#define lock_export extern
#endif

lock_export int lockToStr(char **dst, int *len, ptr *src);
lock_export str LCKcreate(monet_lock *l);
lock_export str LCKset(int *res, monet_lock *l);
lock_export str LCKtry(int *res, monet_lock *l);
lock_export str LCKunset(int *res, monet_lock *l);
lock_export str LCKdestroy(int *res, monet_lock *l);

#endif /* _LOCK_H */

@c
#include "monetdb_config.h"
#include "mal.h"
#include "mal_exception.h"
#include "lock.h"

int
create_lock(monet_lock *l)
{
	*l = (monet_lock) GDKmalloc(sizeof(MT_Lock));
	if (*l == NULL || *l == ptr_nil) return GDK_FAIL;
	MT_lock_init((MT_Lock*) *l, "M5_create_lock");
	return GDK_SUCCEED;
}

int
set_lock(monet_lock *l)
{
	if (*l == NULL || *l == ptr_nil) return GDK_FAIL;
	MT_lock_set((MT_Lock*) *l, "set_lock");
	return GDK_SUCCEED;
}

int
try_lock(int *res, monet_lock *l)
{
	if (*l == NULL || *l == ptr_nil) return GDK_FAIL;
	*res = MT_lock_try((MT_Lock*) *l) ? EBUSY : 0;
	return GDK_SUCCEED;
}

int
unset_lock(monet_lock *l)
{
	if (*l == NULL || *l == ptr_nil) return GDK_FAIL;
	MT_lock_unset((MT_Lock*) *l, "unset_lock");
	return GDK_SUCCEED;
}

int
destroy_lock(monet_lock *l)
{
	if (*l == NULL || *l == ptr_nil) return GDK_FAIL;
	MT_lock_destroy((MT_Lock*) *l);
	GDKfree(*l);
	return GDK_SUCCEED;
}


@-
The old code base is wrapped to ease update propagation.
@c
int
lockToStr(char **dst, int *len, ptr *src)
{
	(void) len;		/* fool compiler */
	if (src == ptr_nil) {
		strcpy(*dst, "nil");
		return 3;
	}
	/* sprintf(*dst,"%o", (ptr)*src); */
	sprintf(*dst, "redo lockToStr");
	return (int) strlen(*dst);
}

str
LCKcreate(monet_lock *l)
{
	create_lock(l);
	return MAL_SUCCEED;
}

str
LCKset(int *res, monet_lock *l)
{
	set_lock(l);
	*res = 1;
	return MAL_SUCCEED;
}

str
LCKtry(int *res, monet_lock *l)
{
	try_lock(res, l);
	return MAL_SUCCEED;
}

str
LCKunset(int *res, monet_lock *l)
{
	unset_lock(l);
	*res = 1;
	return MAL_SUCCEED;
}

str
LCKdestroy(int *res, monet_lock *l)
{
	destroy_lock(l);
	*res = 1;
	return MAL_SUCCEED;
}

@}
