@/
The contents of this file are subject to the MonetDB Public License
Version 1.1 (the "License"); you may not use this file except in
compliance with the License. You may obtain a copy of the License at
http://www.monetdb.org/Legal/MonetDBLicense

Software distributed under the License is distributed on an "AS IS"
basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations
under the License.

The Original Code is the MonetDB Database System.

The Initial Developer of the Original Code is CWI.
Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
Copyright August 2008-2011 MonetDB B.V.
All Rights Reserved.
@

@c
/*
 * @f aggr_be_avg
 * @a S. Manegold
 * @v 1.0
 * @+ Aggregates Module
 *
 *
 * @+ Implementation
 * These implementations need just one scan and a simple hash-maintained data
 * structure to compute a group of common aggregates.
 */
#include "monetdb_config.h"
#include <gdk.h>
#include <gdk_scanselect.h>	/* for type-specific HT_bunfastins_nocheck_noinc(), until they're moved to gdk.mx */
#include "aggr.h"
#include "aggr_be_avg.h"

/*
 * @- Result initialization
 * //	init_result
 * 	@1:	tail-type:	bte/sht/int/wrd/lng/flt/dbl / any / void
 *
 */
@include aggr_ri.mx
@c
/*
 * @- Average
 */
/*	aggrX3_avg
		e-void-head	e-oid-head	e-oid-head	e-oid-head
		void-lookup	array-lookup	scan-lookup	hash-lookup

	@1:	0		1		0		0		use sums-array?
	@2:	0		0		0		1		do BATprepareHash?
	@3:	BUNfndVOID	CHKrange	SCANfndOID	HASHfnd_oid	lookup
	@4:	var		loc		loc		loc		e/bn-head-access

	@5:	"BUNhloc(b,p)"	for  (oid) b-head-type,		b-head access
		"&bhsb; bhsb++" for (void) b-head-type

	@6:	bte / sht / int / wrd / lng / flt / dbl		b-tail-type
	@7:	"loc" for fixsized b-tail-type,			b-tail-access
		"var" for varsized b-tail-type			(only loc used currently)

	@8:	BUNt@7(bn,r)	BUNt@7(bn,r)	&sums[(*(oid*)h)-min]
								*dst: sum in-place or in sums-array ?

	@9:		r-off		(*(oid*)h)-min	index in cnt array
*/
@= aggrX3_avg
	ALGODEBUG THRprintf(GDKout, "#aggrX3_avg(@1,@2,@3,@4,@5,@6,@7,@8,@9);\n");
	if (@1 && range > 0) {
		/* create tmp. sums array */
		sums = (dbl*) GDKzalloc(range*sizeof(dbl));
		if (sums == NULL) {
			GDKerror("aggrX3_avg(@1,@2,@3,@4,@5,@6,@7,@8,@9): sums = GDKzalloc("OIDFMT"*"SZFMT") failed", range, sizeof(dbl));
			BBPreclaim(bn);
			return GDK_FAIL;
		}
	}
	if (@2 && BATprepareHash(bn)) {
		GDKerror("aggrX3_avg(@1,@2,@3,@4,@5,@6,@7,@8,@9): BATprepareHash(bn) failed");
		if (@1 && sums)
			GDKfree(sums);
		BBPreclaim(bn);
		return GDK_FAIL;
	}
	cnt = (BUN*) GDKzalloc(slots*sizeof(cnt[0]));
	if (cnt == NULL) {
		GDKerror("aggrX3_avg(@1,@2,@3,@4,@5,@6,@7,@8,@9): cnt = GDKzalloc("OIDFMT"*"SZFMT") failed", slots, sizeof(cnt[0]));
		if (@1 && sums)
			GDKfree(sums);
		BBPreclaim(bn);
		return GDK_FAIL;
	}
	/* scan b, adding sums, and incrementing counts */
	bhsb = b->hseqbase - 1;
	if (!(@1 && sums))
		BATaccessBegin(bn,USE_HEAD|USE_HHASH|USE_TAIL,BAThordered(b)&BAThordered(e)&1?MMAP_SEQUENTIAL:MMAP_WILLNEED);
	if (b_use)
		BATaccessBegin(b,b_use,MMAP_SEQUENTIAL);
	if (b->T->nonil) {
		BATloop(b, p, q) {
			@6 *t = (@6*) BUNt@7(bi,p);
			oid *h = (oid*) @5;

			@3(r, bni, h);
			if (r != BUN_NONE) {
				dbl *dst = (dbl*) @8;
				*dst += *t;
				cnt[@9]++;
			}
		}
	} else {
		BATloop(b, p, q) {
			@6 *t = (@6*) BUNt@7(bi,p);
			oid *h = (oid*) @5;

			@3(r, bni, h);
			if (r != BUN_NONE) {
				dbl *dst = (dbl*) @8;
				if (*dst != dbl_nil) {
					if (*t == @6_nil) {
						*dst = dbl_nil;
					} else {
						*dst += *t;
					}
					cnt[@9]++;
				}
			}
		}
	}
	if (b_use)
		BATaccessEnd(b,b_use,MMAP_SEQUENTIAL);
	if (!(@1 && sums))
		BATaccessEnd(bn,USE_HEAD|USE_HHASH|USE_TAIL,BAThordered(b)&BAThordered(e)&1?MMAP_SEQUENTIAL:MMAP_WILLNEED);
	/* postprocess by dividing sums by counts */
	if (@1) {
	    if (sums) {
		/* sums in sums-array */
		BATaccessBegin(bn,USE_HEAD|USE_TAIL,MMAP_SEQUENTIAL);
		BATloop(bn, p, q) {
			oid h = (*(oid*) BUNh@4(bni,p)) - min;
			dbl *dst = (dbl*) BUNt@7(bni, p);
			if (cnt[h] == 0 || sums[h] == dbl_nil) {
				*dst = dbl_nil;
			} else {
				*dst = (dbl) (sums[h]/cnt[h]);
			}
		}
		BATaccessEnd(bn,USE_HEAD|USE_TAIL,MMAP_SEQUENTIAL);
		GDKfree(sums);
	    }
	} else {
		/* sums in-place */
		BUN yy = 0;
		BATaccessBegin(bn,USE_TAIL,MMAP_SEQUENTIAL);
		BATloop(bn, p, q) {
			dbl *dst = (dbl*) BUNt@7(bni, p);
			if (cnt[yy] == 0) {
				*dst = dbl_nil;
			} else if (*dst != dbl_nil) {
				*dst = (dbl) (*dst / cnt[yy]);
			}
			yy++;
		}
		BATaccessEnd(bn,USE_TAIL,MMAP_SEQUENTIAL);

	}
	if (cnt)
		GDKfree(cnt);
@
@c

/*	arithavg
	@6:	bte / sht / int / wrd / lng / flt / dbl	b-tail-type
	@7:	"loc" for fixsized b-tail-type,		b-tail-access
		"var" for varsized b-tail-type		(only loc used currently)
*/
@= arithavg_h
int
CMDaggrX3_avg_@1(BAT **ret, BAT *b, BAT *e);
@= arithavg_c
int
CMDaggrX3_avg_@1(BAT **ret, BAT *b, BAT *e)
{
	BAT *bn = BATnew(TYPE_void, TYPE_dbl, BATcount(e));
	BATiter bni, bi = bat_iterator(b);
	BUN off;
	BUN *cnt = NULL;
	BUN slots;
	oid range;
	oid min, max;
	dbl zero = (dbl) 0, *sums = NULL;
	BUN p, q, r;
	oid bhsb;
	int b_use = USE_TAIL;

	if( bn == NULL) {
		GDKerror("CMDaggrX3_avg_@1(): BATnew() failed");
		return GDK_FAIL;
	}

	ALGODEBUG THRprintf(GDKout, "#CMDaggrX3_avg_@1[@2](b=%s,e=%s);\n",
		BATgetId(b),BATgetId(e));
	/* init: set all sums & counts to zero and calculate min/max oid */
	@:init_result(dbl)@
	bni = bat_iterator(bn);
	off = BUNfirst(bn);
	range = max - min + 1;

	/* scan b, calculate sums & counts, derive averages */
	slots = BATcount(e);
	if (slots == 0) {
		/* empty extend => empty result */
		*ret = bn;
		return GDK_SUCCEED;
	}
	if (!BAThdense(b))
		b_use |= USE_HEAD;
	if (e->htype == TYPE_void) {
		/* void lookup */
		if (BAThdense(b)) {
			@:aggrX3_avg(0,0,BUNfndVOID,var,&bhsb;bhsb++,@1,@2,BUNt@2(bni,r),r-off)@
		} else {
			@:aggrX3_avg(0,0,BUNfndVOID,var,BUNhloc(bi,p),@1,@2,BUNt@2(bni,r),r-off)@
		}
	/* e->htype == TYPE_oid */
	} else if (range <= SMALL_AGGR_MAX) {
		/* array lookup */
		slots = range;
		if (BAThdense(b)) {
			@:aggrX3_avg(1,0,CHKrange,loc,&bhsb;bhsb++,@1,@2,&sums[(*(oid*)h)-min],(*(oid*)h)-min)@
		} else {
			@:aggrX3_avg(1,0,CHKrange,loc,BUNhloc(bi,p),@1,@2,&sums[(*(oid*)h)-min],(*(oid*)h)-min)@
		}
	} else if (BATcount(e) <= SCAN_AGGR_MAX) {
		/* scan lookup */
		SCAN_aggr_init;
		if (BAThdense(b)) {
			@:aggrX3_avg(0,0,SCANfndOID,loc,&bhsb;bhsb++,@1,@2,BUNt@2(bni,r),r-off)@
		} else {
			@:aggrX3_avg(0,0,SCANfndOID,loc,BUNhloc(bi,p),@1,@2,BUNt@2(bni,r),r-off)@
		}
	} else if (BATtordered(b)&BAThordered(e)&1) {
		/* merge lookup */
		MERGE_aggr_init;
		if (BAThdense(b)) {
			@:aggrX3_avg(0,0,MERGEfndOID,loc,&bhsb;bhsb++,@1,@2,BUNt@2(bni,r),r-off)@
		} else {
			@:aggrX3_avg(0,0,MERGEfndOID,loc,BUNhloc(bi,p),@1,@2,BUNt@2(bni,r),r-off)@
		}
	} else {
		/* hash lookup */
		if (BAThdense(b)) {
			@:aggrX3_avg(0,1,HASHfnd_oid,loc,&bhsb;bhsb++,@1,@2,BUNt@2(bni,r),r-off)@
		} else {
			@:aggrX3_avg(0,1,HASHfnd_oid,loc,BUNhloc(bi,p),@1,@2,BUNt@2(bni,r),r-off)@
		}
	}

	*ret = bn;
	return GDK_SUCCEED;
}
@= arithavg_hc
@:arithavg_@1(@2,@3)@
@= arithavg
@:arithavg_hc(@1,bte,loc)@
@:arithavg_hc(@1,sht,loc)@
@:arithavg_hc(@1,int,loc)@
@:arithavg_hc(@1,wrd,loc)@
@:arithavg_hc(@1,lng,loc)@
@:arithavg_hc(@1,flt,loc)@
@:arithavg_hc(@1,dbl,loc)@
@
@h
@:arithavg(h)@
@c
@:arithavg(c)@

