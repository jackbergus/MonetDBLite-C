@/
The contents of this file are subject to the MonetDB Public License
Version 1.1 (the "License"); you may not use this file except in
compliance with the License. You may obtain a copy of the License at
http://www.monetdb.org/Legal/MonetDBLicense

Software distributed under the License is distributed on an "AS IS"
basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations
under the License.

The Original Code is the MonetDB Database System.

The Initial Developer of the Original Code is CWI.
Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
Copyright August 2008-2013 MonetDB B.V.
All Rights Reserved.
@

@f group

@c
/*
 * @a M.L. Kersten, P. Boncz, A.P. de Vries, N.J. Nes
 * @v 2.3
 * @+ The group module
 * This module contains the primitives to construct, derive, and
 * perform statistical operations on BATs representing groups.
 * The default scheme in Monet is to assume the head to represent
 * the group identifier and the tail an element in the group.
 *
 * Groups play an important role in datamining, where they are used
 * to construct cross-tables. Such cross tables over a single
 * BAT are already supported by the histogram function.
 * This module provides extensions to support identification of groups in a
 * (multi-)dimensional space.
 *
 * The module implementation has a long history. The first implementation
 * provided several alternatives to produce/derive the grouping.
 * A more complete (and complex) scheme was derived during its
 * extensive use in the context of the Data Distilleries  product.
 * The current implementation is partly a cleanup of this code-base,
 * but also enables provides better access to the intermediate
 * structures produced in the process, i.e. the histogram and
 * the sub-group mapping. They can be used for various optimization
 * schemes at the MAL level.
 *
 * The prime limitation of the current implementation is that an
 * underlying database of @code{oid->any} BATs is assumed.
 * This enables representation of each group using an oid,
 * and the value representation of the group can be accordingly be
 * retrieved easily. An optimized implementation in which we use positional
 * integer id's (as embodied by Monet's void type) is also available.
 *
 * This limitation on (v)oid-headers is marginal. The primitive GRPsplit
 * produces for any BAT two copies with both a (v)oid header.
 * @- Algorithms
 * There are several approaches to build a cross table. The one chosen here
 * is aimed at incremental construction, such that re-use of intermediates
 * becomes possible. Starting with the first dimension, a BAT is derived to
 * represent the various groups, called a @emph{GRP BAT} or cross-table BAT.
 *
 * @- Cross Table (GRP)
 * A cross table is an <oid,oid> BAT where the first (head) denotes a tuple in
 * the cross table and the second (tail) marks all identical lists.
 * The tail-oids contain group identifiers; that is, @emph{this value is equal
 * @strong{iff} two tuples belong to the same group}. The group identifiers are
 * chosen from the domain of the tuple-identifiers. This simplifies
 * getting back to the original tuples, when talking about a group.
 * If the tuple-oid of 'John' is chosen as a group-id, you might view this
 * as saying that each member of the group is 'like John' with respect
 * to the grouping-criterion.
 *
 * @-
 * Successively the subgroups can be identified by modifying the GRP BAT or
 * to derive a new GRP BAT for the subgroups. After all groups have been
 * identified this way, a BAT histogram operation can be used to obtain
 * the counts of each data cube. Other aggregation operations using the MIL
 * set aggregate construct @code{@{X@}(bat)}
 * can be used as well; note for instance that @code{histogram == @{count@}(b.reverse())}.
 *
 * The Monet interface module specification is shown below.
 * Ideally we should defined stronger type constraints, e.g.
 * command group.new(attr:bat[@{void,oid@},:any_1]
 */
@mal
module group;

command new(b:bat[:any_1,:any_2], start:int, incr:int, grpsize:int)
			:bat[:any_1,:int] 
address GRPgroup0
comment "Produces a new BAT with identical head column, and in the tail 
		column groups of equally valued integers within each group. 
		Parameters: a start group -value, -number increment, -size.";

command new(attr:bat[:any_1,:any_2] )
	(histo:bat[:any_1,:wrd], grp:bat[:any_1,:void]) 
address GRPgroup;

command new(attr:bat[:any_1,:any_2] )
	(histo:bat[:any_1,:wrd], grp:bat[:any_1,:oid]) 
address GRPgroup;

command new(attr:bat[:any_1,:any_2], N:int, rng:int)
	(histo:bat[:any_1,:wrd],grp:bat[:any_1,:oid]) 
address GRPgroup_custom
comment "Cross tabulation group initialization like GRPgroup, but with 
		user provided #bits in hashmask and #distinct values in range.";

command done(attr:bat[:any_1,:any_2] )
	(histo:bat[:any_1,:wrd], grp:bat[:any_1,:void]) 
address GRPgroup;

command done(attr:bat[:any_1,:any_2] )
	(histo:bat[:any_1,:wrd], grp:bat[:any_1,:oid]) 
address GRPgroup;

command done(attr:bat[:any_1,:any_2], N:int, rng:int)
	(histo:bat[:any_1,:wrd],grp:bat[:any_1,:oid]) 
address GRPgroup_custom;

command derive(hist:bat[:any_1,:wrd], map:bat[:any_1,:oid], a:bat[:any_1,:any_2])
	(histo:bat[:any_1,:wrd],grp:bat[:any_1,:oid]) 
address GRPderive
comment "Cross tabulation group extension step.  Returned head values are 
		identical as in 'ct'. Tail values are from the same domain and 
		indicate further refinement of the groups in 'ct', taking into 
		account also the tail-values in 'attr'.";
command derive(histo:bat[:void,:wrd], map:bat[:void,:oid], a:bat[:oid,:any_2])
	(hist:bat[:oid,:wrd],grp:bat[:oid,:oid]) 
address GRPderive;

command done(hist:bat[:any_1,:wrd], map:bat[:any_1,:oid], a:bat[:any_1,:any_2])
	(histo:bat[:any_1,:wrd],grp:bat[:any_1,:oid]) 
address GRPderive;

command done(histo:bat[:void,:wrd], map:bat[:void,:oid], a:bat[:oid,:any_2])
	(hist:bat[:oid,:wrd],grp:bat[:oid,:oid]) 
address GRPderive;

command refine(b:bat[:any_2,:any_3], a:bat[:any_2,:any_1]) :bat[:any_2,:oid] 
address GRPrefine
comment "refine the ordering of a tail-ordered BAT by sub-ordering on the 
		values of a second bat 'a' (where the heads of a and b match 1-1).
		The effect of this is similar to (hash-based) GRPderive, with the 
		distinction that the group ids respect the ordering of the group 
		values.";

command refine(b:bat[:oid,:any_3], a:bat[:void,:any_1]) :bat[:oid,:oid] 
address GRPrefine;
command refine(b:bat[:void,:any_3], a:bat[:oid,:any_1]) :bat[:oid,:oid] 
address GRPrefine;

command refine_reverse(b:bat[:any_2,:any_3], a:bat[:any_2,:any_1]) :bat[:any_2,:oid] 
address GRPrefine_rev
comment "refine the ordering of a tail-ordered BAT by sub-ordering on the 
		values of a second bat 'a' (where the heads of a and b match 1-1).
		The effect of this is similar to (hash-based) GRPderive, with the 
		distinction that the group ids respect the ordering of the group 
		values.";
		# @-
		# @+ Group Aggregate operations
		#
		# This module also contains some efficient aggregate functions over
		# groups that compute their result in one scan.
		#
		# For the groups we assume a bat structure where the head indicates the group
		# and the tail contains the group elements. This leads to the situation that
		# most value-based operators work on the tail, while counting groups
		# is focussed on the head.
@= grpSignature
command sum(b:bat[:any_2,:@1], e:bat[:any_2,:any_1]) :bat[:any_2,:@1] 
address GRPsum_@1_@1
comment "grouped tail sum";

command sum(b:bat[:any_2,:@1], size:int) :bat[:any_2,:@1] 
address GRPwindowsum_@1
comment "Tail sum of groups of a fixed size";

command sum(b:bat[:any_2,:@1], size:int, shift:int) :bat[:any_2,:@1] 
address GRPslidingsum_@1
comment "Tail sum of groups of a sliding window of fixed size";

command avg(b:bat[:any_2,:@1], e:bat[:any_2,:any_1]) :bat[:any_2,:@1] 
address GRPavg_@1
comment "grouped tail average";

command variance(b:bat[:any_2,:@1], e:bat[:any_2,:any_1]) :bat[:any_2,:@1] 
address GRPvar_@1
comment "grouped tail variance";

@
@mal
# @-
# Not used yet
# #command min(b:bat[:any_2,:@1], size:int) :bat[:any_2,:@1]
# #address GRPwindowmin@1
# #comment "Tail minimum of groups of a fixed size";
# #command max(b:bat[:any_2,:@1], size:int) :bat[:any_2,:@1]
# #address GRPwindowmax@1
# #comment "Tail minimum of groups of a fixed size";
	@:grpSignature(bte)@
	@:grpSignature(sht)@
	@:grpSignature(int)@
	@:grpSignature(lng)@
	@:grpSignature(wrd)@
	@:grpSignature(flt)@
	@:grpSignature(dbl)@
	@:grpSignature(oid)@

command min(b:bat[:any_2,:any_1], e:bat[:any_2,:any_3]) :bat[:any_2,:any_1] 
address GRPmin
comment "Grouped tail minimum";
command max(b:bat[:any_2,:any_1], e:bat[:any_2,:any_3]) :bat[:any_2,:any_1] 
address GRPmax
comment "Grouped tail maximum";

command count(b:bat[:any_2,:any_1], e:bat[:any_2,:any_3], nonils:bit) :bat[:any_2,:wrd] 
address GRPaggr_count
comment "Grouped count";
command size(b:bat[:any_2,:bit], e:bat[:any_2,:any_1]) :bat[:any_2,:wrd] 
address GRPsize
comment "Grouped count of true values";

command prelude()
address GRPprelude;

group.prelude();
@h
/*
 * @+ Implementation Code
 * Inclusion of the xtables requires some preliminary definitions
 * and als renaming :group by something else, because Mx can;t handle
 * macros identical to file names.
 */
#ifndef _GROUP_H_
#define _GROUP_H_
#include "gdk.h"

#ifdef WIN32
#if !defined(LIBMAL) && !defined(LIBATOMS) && !defined(LIBKERNEL) && !defined(LIBMAL) && !defined(LIBOPTIMIZER) && !defined(LIBSCHEDULER) && !defined(LIBMONETDB5)
#define group_export extern __declspec(dllimport)
#else
#define group_export extern __declspec(dllexport)
#endif
#else
#define group_export extern
#endif

group_export str GRPprelude(void);
group_export str GRPgroup_custom(int *rethisto, int *retbid, int *bid, int *N, int *rng);
group_export str GRPgroup(int *rethisto, int *retbid, int *bid);
group_export str GRPgroup0(int *ret, int *bid, int *start, int *incr, int *grpsize);
group_export str GRPderive(int *hid, int *mid, int *ct_histoid, int *ct_mapid, int *bid);
group_export str GRPrefine(int *retid, int *bid, int *aid);
group_export str GRPrefine_rev(int *retid, int *bid, int *aid);

/* used by rdf_shredder.mx */
group_export int CTrefine(BAT **res, BAT *b, BAT *a);
group_export int CTrefine_rev(BAT **res, BAT *b, BAT *a);

#endif /* _GROUP_H_ */
@c
#include "monetdb_config.h"
#include "mal.h"
#include "mal_exception.h"
#include "mal_atom.h"
#include "group.h"
#include "algebra.h"

static int TYPE_mapentry;


static int
grp_new(BAT *b, BAT *h)
{
	if (h) {
		BATkey(h, TRUE);
		h->tsorted = 0;
		h->trevsorted = 0;
		h->hrevsorted = BAThrevordered(b);
		if ((h->hsorted = BAThordered(b))) {
			if (BATcount(h) == BATcount(b)) {
				ALIGNsetH(h, BATmirror(b));
			}
		} else if (!h->batRestricted && BATorder(h) == NULL) {
			BBPreclaim(h);
			return GDK_FAIL;
		}
		if (!(h->batDirty&2)) h = BATsetaccess(h, BAT_READ); 
	} else {
		assert(h);
	}
	if (!(b->batDirty&2)) b = BATsetaccess(b, BAT_READ); 
	return GDK_SUCCEED;
}


/*
 * @+ Core Grouping Algorithms
 * We use hash-grouping all the way. This implementation employs
 * a simple sequential scan through the operands, adding group
 * values to a hash-table. This hash-table gives access to the group
 * identifiers, which are always OIDs.
 *
 * This strategy is also followed on binary groupings; here
 * we construct a special integer consisting of the XORed hashnumber
 * of both columns. In such a way, we can build a hash table on
 * map_entries (instead of simple atomic values -- the unary case).
 *
 * In the unary group case, we optimized processing on 1-byte
 * and 2-byte values by using direct mapping in an array instead of
 * hashing.
 */
#if SIZEOF_BUN == SIZEOF_INT
#define mix_BUN(v) mix_int(v)
#else
#define mix_BUN(v) mix_int((v)^((v)>>31))
#endif
#define HASH_bte(p) ((BUN) (*(const unsigned char*) (p)))
#define HASH_sht(p) ((BUN) (*(const unsigned short*) (p)))
#define HASH_int(p) ((BUN) (*(const unsigned int*) (p)))
#if SIZEOF_BUN == SIZEOF_LNG
#define HASH_lng(p) ((BUN) (*(BUN *) (p)))
#else
#define HASH_lng(p) ((BUN) (((const unsigned int*)(p))[0]^((const unsigned int*)(p))[1]))
#endif
#define HASH_str_hv(p) (((BUN *) (p))[-1])
#define HASH_any(p) ((*hashfcn)(p))

#define match_sync(bi,p,r) r++
#define match_hash(bi,p,r) BUNfndOID(r,bi,p); if (r == BUN_NONE) continue;

#define declare_atom int any = b->ttype; BUN (*hashfcn)(const void *) = BATatoms[any].atomHash;
#define declare_simple	/* any and hash would otherwise give unused variable warning */
#define declare_str_hv

#define htype_sync(b) BAThdense(b)?TYPE_void:TYPE_oid
#define htype_hash(b) TYPE_oid

#define ttype_simple(b,t) t
#define ttype_atom(b,t) b->ttype

#define STANDARD_MASK ((BUN) 1023)

#define str_hv_EQ(a,b,t) GDK_STREQ(a,b)

/*
   Note:
	following macros take advantage of clustered property;
	if b is clustered, then we can stop early traversing collision lists.

	BTW, simply stopping possibly breaks chain construction, so the resulting
	map is not directly reuseable as a hash table; the current Monet cannot
	however handle multiple accellerators, so this ain't a real problem for now :)
 */

#define declare_unclustered	/* avoid warning */
#define declare_clustered   int samecluster = TRUE;

#define chain_unclustered   for (zz = hash[c]; zz != BUN_NONE; zz = e->use.link)
#define chain_clustered     for (zz = hash[c]; (zz != BUN_NONE) && (samecluster); zz = e->use.link)

#define tst_grp_unclustered(eq,p,t)    (eq(p, tcur, t))
#define tst_grp_clustered(eq,p,t)      (samecluster = eq(p, tcur, t))

#define tst_derive_unclustered(eq,p,t) (e->use.hcur == hcur && eq(p, tcur, t))
#define tst_derive_clustered(eq,p,t)   ((samecluster = e->use.hcur == hcur) && eq(p, tcur, t))

typedef union {
	struct {
		oid hcur;	/* old group id */
		BUN link;	/* hash link */
		oid gid;	/* new group id */
		wrd cnt;	/* histogram count */
	} use;			/* use this one */
	struct {
		wrd w1, w2, w3, w4;
	} pad;			/* padding to ensure power of 2 width */
} mapentry_t;


@:map_init_def(STANDARD,STANDARD_MASK,4096)@
@:map_init_def(CUSTOM,custom_MASK,custom_rng)@

@= map_init_def
#define map_init_@1(map,hash,mask,entry,mapsize)			\
	BUN _yy;							\
	map = BATnew(TYPE_mapentry, tailtype(b,TRUE), @3);		\
	hash = (BUN*) GDKmalloc((size_t)(sizeof(BUN)*((mask=@2)+1)));	\
	if (hash) for (_yy=0; _yy<=@2; _yy++) {				\
		hash[_yy] = BUN_NONE;					\
	}								\
	entry.use.cnt = 1;						\
	if (map == NULL || hash == NULL) {				\
		if (map) BBPunfix(map->batCacheid);			\
		if (hash) GDKfree(hash);				\
		return NULL;						\
	}								\
	mapsize = BUNlast(map);
@
@c

static BAT *
map2histo(BAT *map)
{
	BUN p, q;
	BAT *bn;
	BUN sz;

	if (map == NULL || map->htype != TYPE_mapentry || isVIEW(map) || map->batSharecnt > 1 || BATgetaccess(map) != BAT_WRITE) {
		if (map)
			BBPreclaim(map);
		return NULL;
	}
	BATaccessBegin(map, USE_HEAD, MMAP_SEQUENTIAL);
	sz = BATcount(map);
	bn = BATnew(TYPE_oid,TYPE_wrd,sz);
	if ( bn == NULL){
		if (map)
			BBPreclaim(map);
		return NULL;
	}
	BATloop(map, p, q) {
		bunfastins(bn, 
			&((mapentry_t*)Hloc(map, p))->use.gid, 
			&((mapentry_t*)Hloc(map, p))->use.cnt);
	}
	BATkey(BATmirror(bn),FALSE);
	bn->tsorted = 0;
	bn->trevsorted = 0;
bunins_failed:
	BATaccessEnd(map, USE_HEAD, MMAP_SEQUENTIAL);
	if (map)
		BBPreclaim(map);
	return bn;
}
/*
 * @-
 * The group macro is split along three dimensions:
 * @multitable @columnfractions 0.2 0.8
 * @item [type:]
 * @tab
 * Type specific implementation for selecting the right
 * hash function and data size etc.;
 * @item [clustered:]
 * @tab
 * The @{clustered and unclustered@} select the
 * appropriate algorithm, i.e., with or without taking advantage of
 * an order of values in the parent groups;
 * @item [physical properties:]
 * @tab
 * Values @{standard and custom@},
 * choosing between a fixed predefined and a custom hashmask. Custom
 * allows the user to determine the size of the hashmask (and indirectly
 * the estimated size of the result). The hashmask is @math{2^n - 1} where @math{n}
 * is given by the user, or 1023 otherwise, and the derived result
 * size is @math{4 @dots{} 2^n}.
 * @end multitable
 *
 * Further research should point out whether fitting a simple statistical
 * model (possibly a simple mixture model) can help choose these parameters
 * automatically; the current idea is that the user (which could be a
 * domain-specific extension of the higher-level language) knows the
 * properties of the data, especially for IR in which the standard grouping
 * settings differ significantly from the original datamining application.
 */
#define group_params_STANDARD	/* fixed */
#define group_params_CUSTOM   BUN custom_MASK, BUN custom_rng,

@= groupAll
static BAT *
CTgroup_@1_@4_@5(group_params_@5 BAT *b, BAT *bn)
{
	lng _t_ = GDKusec();
	BATiter bi = bat_iterator(b), mapi;
	oid *hdst = (oid*) Hloc(bn, BUNfirst(bn)), *dst = (oid*) Tloc(bn, BUNfirst(bn));
	BUN *hash, mask;
	BUN zz, mapsize;
	mapentry_t entry, *e;
	BUN p, q, r;
	BAT *map = NULL, *rtrn = NULL;
	declare_@3

	map_init_@5(map,hash,mask,entry,mapsize);

	ALGODEBUG fprintf(stderr,
		"#  CTgroup_@1_@4_@5 <@2,@3> ( b=#%d:[%s,%s]:"BUNFMT" , bn=#%d:[%s,%s]:"BUNFMT" )\n",
		b->batCacheid, ATOMname(b->htype), ATOMname(b->ttype), BATcount(b),
		bn->batCacheid, ATOMname(bn->htype), ATOMname(bn->ttype), BATcount(bn));

	mapi = bat_iterator(map);
	/* core hash grouping algorithm */
	BATaccessBegin(b, USE_HEAD|USE_TAIL, MMAP_SEQUENTIAL);
	BATaccessBegin(map, USE_HEAD|USE_TAIL, MMAP_WILLNEED);
	BATloop(b, p, q) {
		declare_@4
		ptr tcur = BUN@2(bi,p);

		/* hash-lookup of 'tcur' in map */
		BUN c = HASH_@1(tcur);
		c = mix_BUN(c) & mask;
		chain_@4 {
			r = zz;
			e = (mapentry_t*) BUNhloc(mapi,r);
			if (tst_grp_@4(@3_EQ, BUN@2(mapi,r), @1)) {
				e->use.cnt++;
				goto found;
			}
		}

		/* not found-> insert new element in map (and hash) */
		entry.use.gid = *(oid*) BUNhead(bi,p);
		entry.use.link = hash[c];
		hash[c] = mapsize++;
		bunfastins(map, &entry, tcur);
		e = &entry;

		/* TODO fix head by a column copy */
found:		/* ultra-fast 'insert' of [oid,gid] into ct */
		if (bn->htype)
			*hdst++ = *(oid*) BUNhead(bi,p);
		*dst++ = e->use.gid;
	}
	BATsetcount(bn, BATcount(b));
	bn->tsorted = 0;
	bn->trevsorted = 0;
	bn->T->nonil = 0;
	ALIGNsetH(bn,b);
	if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ);
	if (hash)
		GDKfree(hash);
	BATaccessEnd(map, USE_HEAD|USE_TAIL, MMAP_WILLNEED);
	BATaccessEnd(b, USE_HEAD|USE_TAIL, MMAP_SEQUENTIAL);
	rtrn = map2histo(map);

	_t_ = GDKusec() - _t_;
	ALGODEBUG fprintf(stderr,
		"#  CTgroup_@1_@4_@5 <@2,@3> ( b=#%d:[%s,%s]:"BUNFMT" , bn=#%d:[%s,%s]:"BUNFMT" ) -> rtrn=#%d:[%s,%s]:"BUNFMT" {%d.%06d s}\n",
		b->batCacheid, ATOMname(b->htype), ATOMname(b->ttype), BATcount(b),
		bn->batCacheid, ATOMname(bn->htype), ATOMname(bn->ttype), BATcount(bn),
		rtrn->batCacheid, ATOMname(rtrn->htype), ATOMname(rtrn->ttype), BATcount(rtrn),
		(int)(_t_ / 1000000),(int)(_t_ % 1000000));

	return rtrn;
bunins_failed:
	BATaccessEnd(map, USE_HEAD|USE_TAIL, MMAP_WILLNEED);
	BATaccessEnd(b, USE_HEAD|USE_TAIL, MMAP_SEQUENTIAL);
	BBPreclaim(bn);
	if (hash)
		GDKfree(hash);
	return NULL;
}

@
@c
static int
tailtype(BAT *b, int str_trick)
{
	int tpe = ATOMstorage(b->ttype);	/* standard type remappings */

	/* more daring remappings possible under simple equality */
	switch (tpe) {
	case TYPE_flt:
		return TYPE_int;
	case TYPE_dbl:
		return TYPE_lng;
	case TYPE_str:
		if (str_trick && GDK_ELIMDOUBLES((b->T->vheap))) {
			/* string offsets are identifying integers */
			return b->T->width == 1 ? TYPE_bte : (b->T->width == 2 ? TYPE_sht : (b->T->width == 4? TYPE_int : TYPE_lng));
		}
	}
	return tpe;
}

/* Generate both 'normal' CTgroup and clustered CTgroups */
@= wrappedgroupinner
@:groupAll(bte,tloc,simple,@1,@2)@
@:groupAll(sht,tloc,simple,@1,@2)@
@:groupAll(int,tloc,simple,@1,@2)@
@:groupAll(lng,tloc,simple,@1,@2)@
@:groupAll(str_hv,tvar,str_hv,@1,@2)@
@:groupAll(any,tail,atom,@1,@2)@

/* Generate both 'normal' CTgroup and parameterized CTgroups */
@= wrappedgroupouter
@:wrappedgroupinner(unclustered,@1)@
@:wrappedgroupinner(clustered,@1)@

@
@c
@:wrappedgroupouter(STANDARD)@
@:wrappedgroupouter(CUSTOM)@

@= returnvalue
	@1 =
@
@c
#define declare_mask_STANDARD	/* fixed */
#define declare_mask_CUSTOM	BUN mask = (((BUN)1) << *N) - 1;

static int
CTgroup(BAT **retval,		/* put pointer to BAT[oid,oid] record here. */
	BAT **hbat,		/* put histogram BAT here */
	BAT *b			/* pointer to BAT[oid,oid] record. */
)
{
	@:CTgroupbody(STANDARD)@
}

static int
CTgroup_custom(BAT **retval,	/* put pointer to BAT[oid,oid] record here. */
   BAT **hbat,	/* put histogram BAT here */
   BAT *b,		/* pointer to BAT[oid,oid] record. */
   int *N,		/* number of bits for hashmask */
   int *rng		/* expected number of entries in map */
)
{
	@:CTgroupbody(CUSTOM)@
}

static int 
bits(BUN i)
{
	int sh;

        for (sh = 0; i != 0; sh++) {
                i >>= 1;
        }
	return sh;
}


@= CTgroupbody
	BAT *histo = NULL, *bn = NULL;
	declare_mask_@1

	/* b->tkey, simply return mirror(0), and hist = project(reverse(bn),1) */
	if (b->tkey) {
		wrd one = 1;
		BAT *v = VIEWcombine(b);

		bn = v;
		if (b->batRestricted == BAT_WRITE) {
			bn = BATcopy(v, v->htype, v->ttype, FALSE);
			BBPreclaim(v);
		}
		histo = BATconst(BATmirror(bn), TYPE_wrd, &one);
	} else {
		bn = BATnew(b->htype, TYPE_oid, BATcount(b));
		if (bn == NULL) {
			return GDK_FAIL;
		}

		/* Poor man's clustered test: sorted & !keyed => clustered  */
		if (b->tsorted && !b->tkey) {
			@:choosegroup@1(tailtype(b,TRUE),bn,clustered,histo)@
		} else {
			@:choosegroup@1(tailtype(b,TRUE),bn,unclustered,histo)@
		}
		if (histo == NULL) {
			BBPreclaim(bn);
			return GDK_FAIL;
		}
		bn->tsorted = 0;
		bn->trevsorted = 0;
	}
	if (BATcount(histo) == BATcount(bn)) {
		BATkey(BATmirror(bn),TRUE);
	}
	ALIGNsetH(bn, b);
	if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ);
	*retval = bn;
	*hbat = histo;
	return grp_new(bn, histo);

@= choosegroupSTANDARD
	/* Choose appropriate @3 CTgroup implementation */
	switch(@1) {
	case TYPE_bte:
		@?@4:returnvalue(@4)@ CTgroup_bte_@3_STANDARD(b,@2);
		break;
	case TYPE_sht:
		@?@4:returnvalue(@4)@ CTgroup_sht_@3_STANDARD(b,@2);
		break;
	case TYPE_int:
		@?@4:returnvalue(@4)@ CTgroup_int_@3_STANDARD(b,@2);
		break;
	case TYPE_lng:
		@?@4:returnvalue(@4)@ CTgroup_lng_@3_STANDARD(b,@2);
		break;
	case TYPE_str:
		if (b->T->vheap->hashash) {
			@?@4:returnvalue(@4)@ CTgroup_str_hv_@3_STANDARD(b,@2);
			break;
		}
		/* fall through */
	default:
		@?@4:returnvalue(@4)@ CTgroup_any_@3_STANDARD(b,@2);
		break;
	}

@= choosegroupCUSTOM
	/* Choose appropriate @3 CTgroup implementation */
	switch(@1) {
	case TYPE_bte:
		@?@4:returnvalue(@4)@ CTgroup_bte_@3_CUSTOM(mask,*rng,b,@2);
		break;
	case TYPE_sht:
		@?@4:returnvalue(@4)@ CTgroup_sht_@3_CUSTOM(mask,*rng,b,@2);
		break;
	case TYPE_int:
		@?@4:returnvalue(@4)@ CTgroup_int_@3_CUSTOM(mask,*rng,b,@2);
		break;
	case TYPE_lng:
		@?@4:returnvalue(@4)@ CTgroup_lng_@3_CUSTOM(mask,*rng,b,@2);
		break;
	case TYPE_str:
		if (b->T->vheap->hashash) {
			@?@4:returnvalue(@4)@ CTgroup_str_hv_@3_CUSTOM(mask,*rng,b,@2);
			break;
		}
		/* fall through */
	default:
		@?@4:returnvalue(@4)@ CTgroup_any_@3_CUSTOM(mask,*rng,b,@2);
		break;
	}

@
@c
static int
CTderive(BAT **M, BAT **H, BAT *ct_histo, BAT *ct_map, BAT *b);

#define SAMPLE_SIZE 	1024
#define SAMPLE_LIMIT	(SAMPLE_SIZE<<3)
static BUN
derive_mask( BAT *ct_map, BAT *ct_histo, BAT *b)
{
	lng _t_ = GDKusec();
	BUN cnt = BATcount(b), rtrn = 0;
	int n = bits(BATcount(ct_histo)), *N = &n;

	ALGODEBUG fprintf(stderr,
		"#    derive_mask ( ct_map=#%d:[%s,%s]:"BUNFMT" , ct_histo=#%d:[%s,%s]:"BUNFMT" , b=#%d:[%s,%s]:"BUNFMT" )\n",
		ct_map->batCacheid, ATOMname(ct_map->htype), ATOMname(ct_map->ttype), BATcount(ct_map),
		ct_histo->batCacheid, ATOMname(ct_histo->htype), ATOMname(ct_histo->ttype), BATcount(ct_histo),
		b->batCacheid, ATOMname(b->htype), ATOMname(b->ttype), BATcount(b));

	if (BATcount(b) > SAMPLE_LIMIT) {
		BAT *s = BATsample(b, SAMPLE_SIZE);
		BUN p, q;
		BAT *histo, *map;
		BUN r = 0;

		if (CTderive(&map, &histo, ct_histo, ct_map, s) != GDK_SUCCEED){
			BBPunfix(s->batCacheid);
			return GDK_FAIL;
		}
		BBPunfix(s->batCacheid);
		BBPfix(histo->batCacheid);
		BBPfix(map->batCacheid);
		BATaccessBegin(histo, USE_TAIL, MMAP_SEQUENTIAL);
		BATloop(histo, p, q) {
			/* + 4 for an average chain list of 4 */
			r += (BUN) (((dbl)cnt/SAMPLE_SIZE)/(*(wrd*)Tloc(histo,p)+4));
		}
		BATaccessEnd(histo, USE_TAIL, MMAP_SEQUENTIAL);
		BBPunfix(histo->batCacheid);
		BBPunfix(map->batCacheid);
		if (histo != ct_histo)
			BBPreclaim(histo);
		if (map != ct_map)
			BBPreclaim(map);
		if (r == 0)
			r = BATcount(ct_histo);
		if (bits(r) > *N) {
			rtrn = (((BUN)1)<<bits(r))-1;

			_t_ = GDKusec() - _t_;
			ALGODEBUG fprintf(stderr,
				"#    derive_mask ( ct_map=#%d:[%s,%s]:"BUNFMT" , ct_histo=#%d:[%s,%s]:"BUNFMT" , b=#%d:[%s,%s]:"BUNFMT" ) -> rtrn="BUNFMT" {%d.%06d s}\n",
				ct_map->batCacheid, ATOMname(ct_map->htype), ATOMname(ct_map->ttype), BATcount(ct_map),
				ct_histo->batCacheid, ATOMname(ct_histo->htype), ATOMname(ct_histo->ttype), BATcount(ct_histo),
				b->batCacheid, ATOMname(b->htype), ATOMname(b->ttype), BATcount(b),
				rtrn,
				(int)(_t_ / 1000000),(int)(_t_ % 1000000));

			return rtrn;
		}
	}
	/* default to */
	rtrn = (((BUN)1)<<*N) - 1;

	_t_ = GDKusec() - _t_;
	ALGODEBUG fprintf(stderr,
		"#    derive_mask ( ct_map=#%d:[%s,%s]:"BUNFMT" , ct_histo=#%d:[%s,%s]:"BUNFMT" , b=#%d:[%s,%s]:"BUNFMT" ) -> rtrn="BUNFMT" {%d.%06d s}\n",
		ct_map->batCacheid, ATOMname(ct_map->htype), ATOMname(ct_map->ttype), BATcount(ct_map),
		ct_histo->batCacheid, ATOMname(ct_histo->htype), ATOMname(ct_histo->ttype), BATcount(ct_histo),
		b->batCacheid, ATOMname(b->htype), ATOMname(b->ttype), BATcount(b),
		rtrn,
		(int)(_t_ / 1000000),(int)(_t_ % 1000000));

	return rtrn;
}

@= derive
static BAT *
CTderive_@1_@2_@5(BAT* ct_map, BAT *ct_histo, BAT *b, BAT *bn)
{
	lng _t_ = GDKusec();
	BATiter bi = bat_iterator(b), mapi, ct_mapi = bat_iterator(ct_map);
	oid *hdst = (oid*) Hloc(bn, BUNfirst(bn)), *dst = (oid*) Tloc(bn, BUNfirst(bn));
	BUN zz, mapsize;
	BUN *hash;
	BUN p, q, r, cp = BUNfirst(ct_map) - 1;
	mapentry_t entry, *e;
	BAT *map, *rtrn;
	declare_@4
	BUN mask = derive_mask(ct_map, ct_histo, b); 
	BUN custom_rng = BATcount(ct_histo); /* expected number of groups */
	BUN custom_MASK = mask;

	map_init_CUSTOM(map,hash,mask,entry,mapsize);

	ALGODEBUG fprintf(stderr,
		"#  CTderive_@1_@2_@5 <@3,@4> ( ct_map=#%d:[%s,%s]:"BUNFMT" , ct_histo=#%d:[%s,%s]:"BUNFMT" , b=#%d:[%s,%s]:"BUNFMT" , bn=#%d:[%s,%s]:"BUNFMT" )\n",
		ct_map->batCacheid, ATOMname(ct_map->htype), ATOMname(ct_map->ttype), BATcount(ct_map),
		ct_histo->batCacheid, ATOMname(ct_histo->htype), ATOMname(ct_histo->ttype), BATcount(ct_histo),
		b->batCacheid, ATOMname(b->htype), ATOMname(b->ttype), BATcount(b),
		bn->batCacheid, ATOMname(bn->htype), ATOMname(bn->ttype), BATcount(bn));

	mapi = bat_iterator(map);
	/* core hash grouping algorithm */
	BATaccessBegin(b, USE_HEAD|USE_TAIL, MMAP_SEQUENTIAL);
	BATaccessBegin(map, USE_HEAD|USE_TAIL, MMAP_WILLNEED);
	BATloop(b, p, q) {
		ptr tcur = BUN@3(bi,p);
		BUN c;
		oid hcur;
		declare_@5

		/* find corresponding value in 'ct_map' */
		match_@1(ct_mapi, BUNhead(bi,p), cp);
		hcur = *(oid*) BUNtloc(ct_mapi,cp);

		/* hash-lookup of [hcur,tcur] in map */
		c = (((BUN) hcur) ^ mix_BUN(HASH_@2(tcur)));
		c = mix_BUN(c) & mask;
		chain_@5 {
			r = zz;
			e = (mapentry_t*) Hloc(map,r);
			if (tst_derive_@5(@4_EQ, BUN@3(mapi,r), @2)) {
				e->use.cnt++;
				goto found;
			}
		}
		/* not found-> insert new element in map (and hash) */
		entry.use.gid = *(oid*) BUNhead(bi,p);
		entry.use.hcur = hcur;
		entry.use.link = hash[c];
		hash[c] = mapsize++;
		bunfastins(map, &entry, tcur);
		e = &entry;

		/* TODO fix head by a column copy */
found:		/* ultra-fast 'insert' of [oid,gid] into result ct */
		if (bn->htype)
			*hdst++ = *(oid*) BUNhead(bi,p);
		*dst++ = e->use.gid;
	}
	bn->tsorted = 0;
	bn->trevsorted = 0;
	BATsetcount(bn, (BUN) (dst - (oid *) bn->T->heap.base)); 
	if (hash)
		GDKfree(hash);
	if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ);
	BATaccessEnd(map, USE_HEAD|USE_TAIL, MMAP_WILLNEED);
	BATaccessEnd(b, USE_HEAD|USE_TAIL, MMAP_SEQUENTIAL);
	rtrn = map2histo(map);

	_t_ = GDKusec() - _t_;
	ALGODEBUG fprintf(stderr,
		"#  CTderive_@1_@2_@5 <@3,@4> ( ct_map=#%d:[%s,%s]:"BUNFMT" , ct_histo=#%d:[%s,%s]:"BUNFMT" , b=#%d:[%s,%s]:"BUNFMT" , bn=#%d:[%s,%s]:"BUNFMT" ) -> ",
		ct_map->batCacheid, ATOMname(ct_map->htype), ATOMname(ct_map->ttype), BATcount(ct_map),
		ct_histo->batCacheid, ATOMname(ct_histo->htype), ATOMname(ct_histo->ttype), BATcount(ct_histo),
		b->batCacheid, ATOMname(b->htype), ATOMname(b->ttype), BATcount(b),
		bn->batCacheid, ATOMname(bn->htype), ATOMname(bn->ttype), BATcount(bn));
	if (rtrn) {
		ALGODEBUG fprintf(stderr,
			"rtrn=#%d:[%s,%s]:"BUNFMT" {%d.%06d s}\n",
			rtrn->batCacheid, ATOMname(rtrn->htype), ATOMname(rtrn->ttype), BATcount(rtrn),
			(int)(_t_ / 1000000),(int)(_t_ % 1000000));
	} else {
		ALGODEBUG fprintf(stderr,
			"NULL {%d.%06d s}\n",
			(int)(_t_ / 1000000),(int)(_t_ % 1000000));
	}

	return rtrn;
bunins_failed:
	BATaccessEnd(map, USE_HEAD|USE_TAIL, MMAP_WILLNEED);
	BATaccessEnd(b, USE_HEAD|USE_TAIL, MMAP_SEQUENTIAL);
	if (hash)
		GDKfree(hash);
	BBPreclaim(bn);
	return NULL;
}

@
@c

/* Generate both 'normal' CTderive and clustered CTderive */
@= wrappedderive
@:derive(sync,bte,tloc,simple,@1)@
@:derive(sync,sht,tloc,simple,@1)@
@:derive(sync,int,tloc,simple,@1)@
@:derive(sync,lng,tloc,simple,@1)@
@:derive(sync,str_hv,tvar,str_hv,@1)@
@:derive(sync,any,tail,atom,@1)@
@:derive(hash,bte,tloc,simple,@1)@
@:derive(hash,sht,tloc,simple,@1)@
@:derive(hash,int,tloc,simple,@1)@
@:derive(hash,lng,tloc,simple,@1)@
@:derive(hash,str_hv,tvar,str_hv,@1)@
@:derive(hash,any,tail,atom,@1)@
@
@c
@:wrappedderive(unclustered)@
@:wrappedderive(clustered)@

@= choosederive
	/* Choose appropriate (@1 && @2) CTderive implementation */
	switch(tt) {
	case TYPE_bte:
		histo = CTderive_@1_bte_@2(ct_map,ct_histo,b,bn);
		break;
	case TYPE_sht:
		histo = CTderive_@1_sht_@2(ct_map,ct_histo,b,bn);
		break;
	case TYPE_int:
		histo = CTderive_@1_int_@2(ct_map,ct_histo,b,bn);
		break;
	case TYPE_lng:
		histo = CTderive_@1_lng_@2(ct_map,ct_histo,b,bn);
		break;
	case TYPE_str:
		if (b->T->vheap->hashash) {
			histo = CTderive_@1_str_hv_@2(ct_map,ct_histo,b,bn);
			break;
		}
		/* fall through */
	default:
		histo = CTderive_@1_any_@2(ct_map,ct_histo,b,bn);
		break;
	}
@
@c

#if 0
/*
Stefan.Manegold@cwi.nl:

Disabled partion based sub-order derive as its performance benefits appear
to be questionable.

With many (small) groups that need to be sub-grouped, the overhead of
calling GRPgroup for each (small) group appears to be significant.
Even with few (large) groups, sub-group each one individually appears to be
more expensive than a "normal" (apparently also clustered on sorted data)
holistic derive.

Here are the results for a scenario that Roberto (& Wouter) reported:
Input are two tables (termID int, docID int, count double) with the
following statistics:

     count(*)  count(distinct termID)  count(distinct docID)
T1:   5000000                     103                  92317
T2:   5000000                 1014049                  85306

Though of equal size, T1 has only 103 termID groups with an average size of
almost 50000 tuples each, while T2 has 1014049 termID groups with an average
size of harly 5 tuples each.
There are 1321544 distinct (termID,docID) combination in T1.
There are 3251714 distinct (termID,docID) combination in T2.

The first column (termID) is sorted in both tables.

Here are the timings (debug build of Feb2010 on 64-bit Fedora 12, 2.40GHz
Core2 Quad, 8 GB RAM) for the following query (with Tx from {T1,T2}):

CREATE TABLE TT AS
SELECT termID, docID, sum(count) AS count
FROM Tx
GROUP BY termID, docID
WITH DATA;

OptPipe   CTderive_ordered()     T1          T2

default   on                   2.69 sec   69.79 sec
          off                  2.65 sec    6.15 sec

nov2009   on                   2.18 sec   27.80 sec
          off                  1.80 sec    3.42 sec

I guess, the rough 10x improvement with many (small) groups, and up to 10%
improvment with few (large) groups indeed makes the general benefits of
partion based sub-order derive via CTderive_ordered() at least questionable.

Once we are confident that CTderive_ordered() has no benefits at all in any
cases, we should remove the code completely.

Of course, with inputs that exceed main memory size, ordered data allows for
rather straight forward partitioning into (few) large chunks that fit into
main memory to perform the derive step of each chunk independently in
memory. These chunks can consist of multiple "outer" groups, provided each
chunk contains only complete outer groups.
This is what "CTderive_clustered()" (see below) does.
*/

/* partion based sub-order derive */
static int 
CTderive_ordered(BAT *ohisto, BAT *b, BAT **res, BAT **reshisto) 
{
	lng _t_ = GDKusec();
	BAT *bn = BATnew(TYPE_void, TYPE_oid, BATcount(b));
	BAT *histo = BATnew(TYPE_oid, TYPE_wrd, BATcount(b)); 
	wrd prv=0, *t = (wrd*)Tloc(ohisto, BUNfirst(ohisto));
	wrd *e = t + BATcount(ohisto);
	bit ordered = 1;
	str msg = NULL;

	ALGODEBUG fprintf(stderr,
		"#  CTderive_ordered ( ohisto=#%d:[%s,%s]:"BUNFMT" , b=#%d:[%s,%s]:"BUNFMT" )\n",
		ohisto->batCacheid, ATOMname(ohisto->htype), ATOMname(ohisto->ttype), BATcount(ohisto),
		b->batCacheid, ATOMname(b->htype), ATOMname(b->ttype), BATcount(b));

	if (bn == NULL || histo == NULL) {
		if (histo)
			BBPreclaim(histo);
		if (bn)
			BBPreclaim(bn);
		return -1;
	}

	bn->hseqbase = b->hseqbase;
	for(;t < e; t++) {
		BAT *bx = BATslice(b, (BUN)prv, (BUN)(prv+*t));
		bat nh, nbn;

		prv += *t;
		/* propcheck slice */
		if (!BATtordered(bx)) 
			BATderiveHeadProps(BATmirror(bx), 0);
		if (!BATtordered(bx)) {

			ordered = 0;
		}
		if ((msg = GRPgroup(&nh, &nbn, &bx->batCacheid)) == NULL){
			BAT *nhisto = BATdescriptor(nh);
			BAT *B = BATdescriptor(nbn);
			BATins(histo, nhisto, FALSE);
			BATappend(bn, B, FALSE);
			/* Stefan.Manegold@cwi.nl:
			 * To prevent leaking BATs, we need to release not only
			 * the physical reference of BATdescriptor() bu also
			 * the logical reference of BBPkeepref() in GRPgroup().
			 * However, simply calling BBPreleaselref() in addition
			 * to BBPreleaseref() does not do the job, possibly
			 * because they both merely do a plain "--BBP_refs(i);"
			 * resp.  "--BBP_lrefs(i);" instead of calling
			 * [BBP]decref() which triggers the free/reclaim of
			 * BATs once the number of both physical & logical
			 * references becomes 0.  Only if we call BBPunfix()
			 * (and hence [BBP]decref(,FALSE)) instead of
			 * BBPreleaseref() *after* BBPreleaselref(), the BATs
			 * are indeed freed.  Alternatively, when also calling
			 * BBPdecref(,TRUE) instead of BBPreleaselref(), either
			 * order of BBPunfix(i) & BBPdecref(,TRUE) yield the
			 * desired effect of freeing the BATs.
			 * It remains open, whether similar situations that
			 * need similar fixes exist elsewhere in the code base.
			 */
			BBPunfix(nh);
			BBPunfix(nbn);
			BBPdecref(nh, TRUE);
			BBPdecref(nbn, TRUE);
		} else {
			if (msg != M5OutOfMemory)
				GDKfree(msg);
			BBPreleaseref(bx->batCacheid);
			BBPreleaseref(histo->batCacheid);
			BBPreleaseref(bn->batCacheid);
			return -1;
		}
		BBPreleaseref(bx->batCacheid);
	}

	if (b->htype != bn->htype) {
		BAT *r = VIEWcreate(b,bn);

		BBPreleaseref(bn->batCacheid);
		bn = r;
	}
	if (ordered) {
		bn->tsorted = TRUE;
		bn->trevsorted = 0;
		histo->hsorted = b->hsorted;
		histo->hrevsorted = b->hrevsorted;
		histo->tsorted = 0;
		histo->trevsorted = 0;
		BATkey(histo, TRUE);
	}
	if (b->hkey)
		BATkey(bn, TRUE);
	*res = bn;
	*reshisto = histo;

	_t_ = GDKusec() - _t_;
	ALGODEBUG fprintf(stderr,
		"#  CTderive_ordered ( ohisto=#%d:[%s,%s]:"BUNFMT" , b=#%d:[%s,%s]:"BUNFMT" ) -> ( res=#%d:[%s,%s]:"BUNFMT" , reshisto=#%d:[%s,%s]:"BUNFMT" ) {%d.%06d s}\n",
		ohisto->batCacheid, ATOMname(ohisto->htype), ATOMname(ohisto->ttype), BATcount(ohisto),
		b->batCacheid, ATOMname(b->htype), ATOMname(b->ttype), BATcount(b),
		(*res)->batCacheid, ATOMname((*res)->htype), ATOMname((*res)->ttype), BATcount(*res),
		(*reshisto)->batCacheid, ATOMname((*reshisto)->htype), ATOMname((*reshisto)->ttype), BATcount(*reshisto),
		(int)(_t_ / 1000000),(int)(_t_ % 1000000));

	return 0;
}
#endif

static int
derive(BAT **H, BAT **M, BAT *ct_histo, BAT *ct_map, BAT *b, int tt);

/* break large (out-of-memory) derive over ordered outer groups into
 * disjoint slices that fit into memory and perform in-memory derive step
 * independently on each slice
 */
static int
CTderive_clustered(BAT **H, BAT **M, BAT *_histo, BAT *_map, BAT *_b, int tt, wrd limit)
{
	lng _t0_ = GDKusec(), _t1_=0,_t2_=0,_t3_=0,_t4_=0,_t5_=0,_t6_=0,_T_;
	wrd s0 = 0, s1 = 0, *t = 0;
	BUN i0 = 0, i1 = 0, j = 0;
	BAT *mn = 0, *hn = 0;
	int rtrn;

	ALGODEBUG fprintf(stderr,
		"#  CTderive_clustered ( _histo=#%d:[%s,%s]:"BUNFMT" , _map=#%d:[%s,%s]:"BUNFMT" , _b=#%d:[%s,%s]:"BUNFMT" , tt=%d , limit="LLFMT" )\n",
		_histo->batCacheid, ATOMname(_histo->htype), ATOMname(_histo->ttype), BATcount(_histo),
		_map->batCacheid, ATOMname(_map->htype), ATOMname(_map->ttype), BATcount(_map),
		_b->batCacheid, ATOMname(_b->htype), ATOMname(_b->ttype), BATcount(_b),
		tt, (lng)limit);

	if (!_histo || !_map || !_b)
		return GDK_FAIL;

	/* complete result map */
	mn = BATnew(TYPE_void, TYPE_oid, BATcount(_b));
	if (!mn)
		return GDK_FAIL;
	/* complete result histo */
	hn = BATnew(TYPE_oid, TYPE_wrd, BATcount(_b));
	if (!hn) {
		BBPreclaim(mn);
		return GDK_FAIL;
	}
	/* outer group sizes */
	t = (wrd*)Tloc(_histo, BUNfirst(_histo));
	/* number of outer groups */
	j = BATcount(_histo);

	/* iterate over outer groups */
	while (i1 < j) {
		BAT *ct_histo, *ct_map, *b, *histo = 0, *bn = 0;

		/* collect outer groups for large in-memory slice */
		s1 = t[i1++];
		while (i1 < j && s1 + t[i1] < limit)
			s1 += t[i1++];
		s1 += s0;

		/* get disjoint slices of input */
		b = BATslice(_b, (BUN)s0, (BUN)s1);
		ct_map = BATslice(_map, (BUN)s0, (BUN)s1);
		ct_histo = BATslice(_histo, (BUN)i0, (BUN)i1);
		if (!b || !ct_map || !ct_histo) {
			if (b)
				BBPreleaseref(b->batCacheid);
			if (ct_map)
				BBPreleaseref(ct_map->batCacheid);
			if (ct_histo)
				BBPreleaseref(ct_histo->batCacheid);
			BBPreclaim(mn);
			BBPreclaim(hn);
			return GDK_FAIL;
		}
		/* invest in scan to check tail-sortedness */
		/* (net effect: make required data hot) */
		_T_ = GDKusec();
		(void)BATordered(BATmirror(b));
		_t1_ += GDKusec() - _T_;

		bn = BATnew(TYPE_void, TYPE_oid, BATcount(b));
		if (bn == NULL) {
			BBPreleaseref(b->batCacheid);
			BBPreleaseref(ct_map->batCacheid);
			BBPreleaseref(ct_histo->batCacheid);
			BBPreclaim(mn);
			BBPreclaim(hn);
			return GDK_FAIL;
		}

		/* perform derive on independent slice */
		_T_ = GDKusec();
		@:choosederive(sync,clustered)@
		_t2_ += GDKusec() - _T_;
		if (histo == NULL) {
			BBPreleaseref(b->batCacheid);
			BBPreleaseref(ct_map->batCacheid);
			BBPreleaseref(ct_histo->batCacheid);
			BBPreclaim(mn);
			BBPreclaim(hn);
			BBPreclaim(bn);
			return GDK_FAIL;
		}

		BBPreleaseref(b->batCacheid);
		BBPreleaseref(ct_map->batCacheid);
		BBPreleaseref(ct_histo->batCacheid);

		/* invest in scan to check tail-sortedness */
		/* (data is still hot) */
		_T_ = GDKusec();
		(void)BATordered(BATmirror(bn));
		_t3_ += GDKusec() - _T_;
		/* append partial map to total map */
		_T_ = GDKusec();
		BATappend(mn, bn, FALSE);
		_t4_ += GDKusec() - _T_;
		BBPreclaim(bn);

		/* invest in scan to check head- & tail-sortedness */
		/* (data is still hot) */
		_T_ = GDKusec();
		(void)BATordered(histo);
		(void)BATordered(BATmirror(histo));
		_t5_ += GDKusec() - _T_;
		/* append partial histo to total histo */
		_T_ = GDKusec();
		BATins(hn, histo, FALSE);
		_t6_ += GDKusec() - _T_;
		BBPreclaim(histo);

		s0 = s1;
		i0 = i1;
	}

	/* initialize map head */
	ALIGNsetH(mn, _b);

	*H = hn;
	*M = mn;
	rtrn = grp_new(mn, hn);

	ALGODEBUG fprintf(stderr, "#  CTderive_clustered: BATordered(BATmirror(b)): %d.%06d s\n", (int)(_t1_ / 1000000),(int)(_t1_ % 1000000));
	ALGODEBUG fprintf(stderr, "#  CTderive_clustered: choosederive(sync,clustered): %d.%06d s\n", (int)(_t2_ / 1000000),(int)(_t2_ % 1000000));
	ALGODEBUG fprintf(stderr, "#  CTderive_clustered: BATordered(BATmirror(bn)): %d.%06d s\n", (int)(_t3_ / 1000000),(int)(_t3_ % 1000000));
	ALGODEBUG fprintf(stderr, "#  CTderive_clustered: BATappend(mn, bn, FALSE): %d.%06d s\n", (int)(_t4_ / 1000000),(int)(_t4_ % 1000000));
	ALGODEBUG fprintf(stderr, "#  CTderive_clustered: BATordered(histo),BATordered(BATmirror(histo)): %d.%06d s\n", (int)(_t5_ / 1000000),(int)(_t5_ % 1000000));
	ALGODEBUG fprintf(stderr, "#  CTderive_clustered: BATins(hn, histo, FALSE): %d.%06d s\n", (int)(_t6_ / 1000000),(int)(_t6_ % 1000000));

	_t0_ = GDKusec() - _t0_;
	ALGODEBUG fprintf(stderr,
		"#  CTderive_clustered ( _histo=#%d:[%s,%s]:"BUNFMT" , _map=#%d:[%s,%s]:"BUNFMT" , _b=#%d:[%s,%s]:"BUNFMT" , tt=%d , limit="LLFMT" ) -> ",
		_histo->batCacheid, ATOMname(_histo->htype), ATOMname(_histo->ttype), BATcount(_histo),
		_map->batCacheid, ATOMname(_map->htype), ATOMname(_map->ttype), BATcount(_map),
		_b->batCacheid, ATOMname(_b->htype), ATOMname(_b->ttype), BATcount(_b),
		tt, (lng)limit);
	if (rtrn == GDK_SUCCEED) {
		ALGODEBUG fprintf(stderr,
			"( H=#%d:[%s,%s]:"BUNFMT" , M=#%d:[%s,%s]:"BUNFMT" ) {%d.%06d s}\n",
			(*H)->batCacheid, ATOMname((*H)->htype), ATOMname((*H)->ttype), BATcount(*H),
			(*M)->batCacheid, ATOMname((*M)->htype), ATOMname((*M)->ttype), BATcount(*M),
			(int)(_t0_ / 1000000),(int)(_t0_ % 1000000));
	} else {
		ALGODEBUG fprintf(stderr,
			"( NULL, NULL ) {%d.%06d s}\n",
			(int)(_t0_ / 1000000),(int)(_t0_ % 1000000));
	}

	return rtrn;
}

static int
derive(BAT **H, BAT **M, BAT *ct_histo, BAT *ct_map, BAT *b, int tt)
{
	lng _t_ = GDKusec();
	wrd limit = SAMPLE_LIMIT; /* fits well into L2 */
	BAT *histo = NULL, *bn = NULL;
	int synced = ALIGNsynced(ct_map, b), rtrn;

	/* create the result bat 'bn' */
	int ht = (synced && BAThdense(b)) ? TYPE_void : TYPE_oid;

	ALGODEBUG fprintf(stderr,
		"#    derive ( ct_histo=#%d:[%s,%s]:"BUNFMT" , ct_map=#%d:[%s,%s]:"BUNFMT" , b=#%d:[%s,%s]:"BUNFMT" , tt=%d )\n",
		ct_histo->batCacheid, ATOMname(ct_histo->htype), ATOMname(ct_histo->ttype), BATcount(ct_histo),
		ct_map->batCacheid, ATOMname(ct_map->htype), ATOMname(ct_map->ttype), BATcount(ct_map),
		b->batCacheid, ATOMname(b->htype), ATOMname(b->ttype), BATcount(b),
		tt);

	if (ct_map->tkey ||
	    BATcount(ct_histo) >= MAX(BATcount(ct_map),BATcount(b))) {
		/* cannot derive more groups */
		bn = ct_map;
		histo = ct_histo;
		if (!synced) {
			bn = BATsemijoin(ct_map, b);
			histo = BATsemijoin(ct_histo, BATmirror(bn));
		} else {
			BBPfix(ct_map->batCacheid);
			BBPfix(ct_histo->batCacheid);
		}
	} else {
		if (synced &&
		    !BATtkey(b) &&
			BAThdense(b) &&
		    BATtordered(ct_map) &&
		    BAThordered(ct_histo) &&
		    (wrd)BATcount(b) > 2 * limit) {
			/* break large (out-of-memory) derive over ordered
			 * outer groups into disjoint slices that fit into
			 * memory and perform in-memory derive step
			 * independently on each slice
			 */
			rtrn = CTderive_clustered(H, M, ct_histo, ct_map, b, tt, limit);

			_t_ = GDKusec() - _t_;
			ALGODEBUG fprintf(stderr,
				"#    derive ( ct_histo=#%d:[%s,%s]:"BUNFMT" , ct_map=#%d:[%s,%s]:"BUNFMT" , b=#%d:[%s,%s]:"BUNFMT" , tt=%d ) -> ",
				ct_histo->batCacheid, ATOMname(ct_histo->htype), ATOMname(ct_histo->ttype), BATcount(ct_histo),
				ct_map->batCacheid, ATOMname(ct_map->htype), ATOMname(ct_map->ttype), BATcount(ct_map),
				b->batCacheid, ATOMname(b->htype), ATOMname(b->ttype), BATcount(b),
				tt);
			if (rtrn == GDK_SUCCEED) {
				ALGODEBUG fprintf(stderr,
					"( H=#%d:[%s,%s]:"BUNFMT" , M=#%d:[%s,%s]:"BUNFMT" ) {%d.%06d s}\n",
					(*H)->batCacheid, ATOMname((*H)->htype), ATOMname((*H)->ttype), BATcount(*H),
					(*M)->batCacheid, ATOMname((*M)->htype), ATOMname((*M)->ttype), BATcount(*M),
					(int)(_t_ / 1000000),(int)(_t_ % 1000000));
			} else {
				ALGODEBUG fprintf(stderr,
					"( NULL, NULL ) {%d.%06d s}\n",
					(int)(_t_ / 1000000),(int)(_t_ % 1000000));
			}

			return rtrn;
		}
#if 0
		/* see comment above */
		if (!b->tkey && BATcount(b) > 1 && BATtordered(ct_map) && 
			BAThordered(ct_histo) &&
	    		ATOMtype(b->htype) == TYPE_oid && 
	    		b->ttype < TYPE_str) {
			int ret = 0;

			ret = CTderive_ordered(ct_histo, b, &bn, &histo);
			if (ret==0) {
				*H = histo;
				*M = bn;
			}
			rtrn = ret?GDK_FAIL:GDK_SUCCEED;

			_t_ = GDKusec() - _t_;
			ALGODEBUG fprintf(stderr,
				"#    derive ( ct_histo=#%d:[%s,%s]:"BUNFMT" , ct_map=#%d:[%s,%s]:"BUNFMT" , b=#%d:[%s,%s]:"BUNFMT" , tt=%d ) -> ",
				ct_histo->batCacheid, ATOMname(ct_histo->htype), ATOMname(ct_histo->ttype), BATcount(ct_histo),
				ct_map->batCacheid, ATOMname(ct_map->htype), ATOMname(ct_map->ttype), BATcount(ct_map),
				b->batCacheid, ATOMname(b->htype), ATOMname(b->ttype), BATcount(b),
				tt);
			if (rtrn == GDK_SUCCEED) {
				ALGODEBUG fprintf(stderr,
					"( H=#%d:[%s,%s]:"BUNFMT" , M=#%d:[%s,%s]:"BUNFMT" ) {%d.%06d s}\n",
					(*H)->batCacheid, ATOMname((*H)->htype), ATOMname((*H)->ttype), BATcount(*H),
					(*M)->batCacheid, ATOMname((*M)->htype), ATOMname((*M)->ttype), BATcount(*M),
					(int)(_t_ / 1000000),(int)(_t_ % 1000000));
			} else {
				ALGODEBUG fprintf(stderr,
					"( NULL, NULL ) {%d.%06d s}\n",
					(int)(_t_ / 1000000),(int)(_t_ % 1000000));
			}

			return rtrn;
		}
#endif
		bn = BATnew(ht, TYPE_oid, BATcount(b));
		if (bn == NULL) 
			return GDK_FAIL;
	

		/* CTderive with correct lookup method (hash,synced) and type */
		if (synced) {
			if (ct_map->tsorted) {
				@:choosederive(sync,clustered)@
			} else {
				@:choosederive(sync,unclustered)@
			}
		} else {
			if (ct_map->tsorted) {
				@:choosederive(hash,clustered)@
			} else {
				@:choosederive(hash,unclustered)@
			}
		}
		if (histo == NULL) {
			BBPunfix(bn->batCacheid);
			return GDK_FAIL;
		}

		/* postprocess the result bat 'bn' */
		if (BATcount(bn) == BATcount(b)) {
			ALIGNsetH(bn, b);
		} else {
			bn->hsorted = BAThordered(b);
			bn->hrevsorted = BAThrevordered(b);
			if (b->hkey)
				BATkey(bn, TRUE);
		}

	}
	*M = bn;
	*H = histo;
	rtrn =  grp_new(bn, histo);

	_t_ = GDKusec() - _t_;
	ALGODEBUG fprintf(stderr,
		"#    derive ( ct_histo=#%d:[%s,%s]:"BUNFMT" , ct_map=#%d:[%s,%s]:"BUNFMT" , b=#%d:[%s,%s]:"BUNFMT" , tt=%d ) -> ",
		ct_histo->batCacheid, ATOMname(ct_histo->htype), ATOMname(ct_histo->ttype), BATcount(ct_histo),
		ct_map->batCacheid, ATOMname(ct_map->htype), ATOMname(ct_map->ttype), BATcount(ct_map),
		b->batCacheid, ATOMname(b->htype), ATOMname(b->ttype), BATcount(b),
		tt);
	if (rtrn == GDK_SUCCEED) {
		ALGODEBUG fprintf(stderr,
			"( H=#%d:[%s,%s]:"BUNFMT" , M=#%d:[%s,%s]:"BUNFMT" ) {%d.%06d s}\n",
			(*H)->batCacheid, ATOMname((*H)->htype), ATOMname((*H)->ttype), BATcount(*H),
			(*M)->batCacheid, ATOMname((*M)->htype), ATOMname((*M)->ttype), BATcount(*M),
			(int)(_t_ / 1000000),(int)(_t_ % 1000000));
	} else {
		ALGODEBUG fprintf(stderr,
			"( NULL, NULL ) {%d.%06d s}\n",
			(int)(_t_ / 1000000),(int)(_t_ % 1000000));
	}

	return rtrn;
}

static int
CTderive(BAT **M, BAT **H, BAT *ct_histo, BAT *ct_map, BAT *b)
{
	lng _t_ = GDKusec();
	int ret;

	ALGODEBUG fprintf(stderr,
		"#  CTderive ( ct_histo=#%d:[%s,%s]:"BUNFMT" , ct_map=#%d:[%s,%s]:"BUNFMT" , b=#%d:[%s,%s]:"BUNFMT" )\n",
		ct_histo->batCacheid, ATOMname(ct_histo->htype), ATOMname(ct_histo->ttype), BATcount(ct_histo),
		ct_map->batCacheid, ATOMname(ct_map->htype), ATOMname(ct_map->ttype), BATcount(ct_map),
		b->batCacheid, ATOMname(b->htype), ATOMname(b->ttype), BATcount(b));

	ret = derive(H, M, ct_histo, ct_map, b, tailtype(b, TRUE));

	_t_ = GDKusec() - _t_;
	ALGODEBUG fprintf(stderr,
		"#  CTderive ( ct_histo=#%d:[%s,%s]:"BUNFMT" , ct_map=#%d:[%s,%s]:"BUNFMT" , b=#%d:[%s,%s]:"BUNFMT" ) -> ",
		ct_histo->batCacheid, ATOMname(ct_histo->htype), ATOMname(ct_histo->ttype), BATcount(ct_histo),
		ct_map->batCacheid, ATOMname(ct_map->htype), ATOMname(ct_map->ttype), BATcount(ct_map),
		b->batCacheid, ATOMname(b->htype), ATOMname(b->ttype), BATcount(b));
	if (ret == GDK_SUCCEED) {
		ALGODEBUG fprintf(stderr,
			"( H=#%d:[%s,%s]:"BUNFMT" , M=#%d:[%s,%s]:"BUNFMT" ) {%d.%06d s}\n",
			(*H)->batCacheid, ATOMname((*H)->htype), ATOMname((*H)->ttype), BATcount(*H),
			(*M)->batCacheid, ATOMname((*M)->htype), ATOMname((*M)->ttype), BATcount(*M),
			(int)(_t_ / 1000000),(int)(_t_ % 1000000));
	} else {
		ALGODEBUG fprintf(stderr,
			"( NULL, NULL ) {%d.%06d s}\n",
			(int)(_t_ / 1000000),(int)(_t_ % 1000000));
	}

	return ret;
}

/*
 * @+ Support for Order-by
 */
#define DEFAULT_SIZE 10000

static inline BUN
sort_flush(var_t *off, oid *o, BUN size, int tpe, char *base, oid *hdst, oid *tdst, oid *idp, int reverse)
{
	int (*cmp) (const void *, const void *) = BATatoms[tpe].atomCmp;
	int shift = 0;
	oid id = *idp + 1;
	ptr cur, val;
	BUN i;

	/* StM: we don't need to sort voids, do we??? */
	if (tpe != TYPE_void) {
		/* qsort works fine for small amount of tuples; with few duplicates */
		if (reverse) {
			GDKqsort_rev(off, o, base, size, sizeof(var_t), sizeof(oid), tpe);
		} else {
			GDKqsort(off, o, base, size, sizeof(var_t), sizeof(oid), tpe);
		}
		if (ATOMvarsized(tpe)) shift = GDK_VARSHIFT;
	}

	cur = base + (off[0] << shift);
	for (i=0; i < size; i++) {
		val = base + (off[i] << shift);
		if ((*cmp) (cur, val)) {
			cur = val;
			id++;
		}
		*hdst++ = o[i];
		*tdst++ = id;
	}
	*idp = id;

	return i;
}

static int
refine(BAT **res, BAT *b, BAT *a, int rv)
{
	str rev = rv ? "_rev" : "";
	BAT *bn = NULL;

	if (BATcount(b) != BATcount(a)) {
		GDKerror("CTrefine%s: both BATs must have the same cardinality and their heads must form a 1-1 match.\n", rev);
		return GDK_FAIL;
	}
@(
	/* checking only the key property is too strict,
	 * as it might not be set although it does hold;
	 * exhaustively checking keyness is too expensive;
	 * hence, we just don't check, and keep our fingers crossed...
	 */
	if (!(b->hkey && a->hkey)) {
		if (a->hkey) {
			GDKerror("CTrefine%s: head of first BAT is not unique (key);", rev);
		} else if (b->hkey) {
			GDKerror("CTrefine%s: head of second BAT is not unique (key);", rev);
		} else {
			GDKerror("CTrefine%s: heads of both BATs are not unique (key);", rev);
		}
		GDKerror("CTrefine%s: heads of both BATs must be unique (key) to form a 1-1 match.\n", rev);
		return GDK_FAIL;
	}
@)
	if (b->tkey) {		/* if key, no further refinements can take place */
		bn = BATmark(b, 0);
	} else {
		int (*cmp) (const void *, const void *) = BATatoms[b->ttype].atomCmp;
		BUN cnt = 0;
		BUN p, q, r, last = BUNfirst(b);
		char *base = a->T->vheap ? NULL : a->T->heap.base, *this = NULL;
		BUN cur, end, off;
		var_t *offp;
		oid *ids;
		bit a_void = (a->ttype == TYPE_void);
		int xx, tpe = a_void ? TYPE_oid : a->ttype;
		BUN size = DEFAULT_SIZE;
		oid *hdst, *tdst, o, *op = &o, id = 0;
		BATiter ai = bat_iterator(a), bi = bat_iterator(b);

		/* create tmp BAT that holds one cluster; estimate required size using sampling */
		if (BATcount(b) > DEFAULT_SIZE) {
			BAT *histo = NULL, *sample = BATsample(b, DEFAULT_SIZE);

			if (sample) {
				histo = BAThistogram(sample);
				if (histo) {
					BATmax(histo, &xx);
					if (xx > 1)
						size = MAX(size, (BUN) (xx * (((float) BATcount(b)) / DEFAULT_SIZE)));
					BBPreclaim(histo);
				}
				BBPreclaim(sample);
			}
			if (histo == NULL)
				return GDK_FAIL;
		}
		/* create a temporary BAT of the estimated size holding pointers to the a tail atoms */
		cur = 0;
		end = size;
		offp = (var_t*) GDKmalloc(size * sizeof(var_t));
		ids = (oid*) GDKmalloc(size * sizeof(oid));
		if (offp == NULL || ids == NULL) {
			if (offp) GDKfree(offp);
			if (ids) GDKfree(ids);
			return GDK_FAIL;
		}
		if (a_void) {
			base = this = (char*) GDKmalloc(size * sizeof(oid));
			if (base == NULL) {
				GDKfree(offp);
				GDKfree(ids);
				return GDK_FAIL;
			}
		}

		/* create result BAT */
		bn = BATnew(TYPE_oid, TYPE_oid, BATcount(b));
		if (bn == NULL) {
			GDKfree(offp);
			GDKfree(ids);
			if (a_void)
				GDKfree(base);
			return GDK_FAIL;
		}
		bn->hsorted = bn->tsorted = FALSE;
		bn->hrevsorted = bn->trevsorted = FALSE;
		hdst = (oid *) Hloc(bn,BUNfirst(bn));
		tdst = (oid *) Tloc(bn,BUNfirst(bn));

		if (a_void) {
			@:refine_loop(@:refine_void_1@,@:refine_void_2@,GDKfree(base);,this = base;)@
		} else {
			@:refine_loop()@
		}
@= refine_void_2
	off = (BUN) (this - base);
	base = (char*) GDKrealloc(base, size * sizeof(oid));
	this = base + off;
@= refine_void_1
	*(oid*)this = a->tseqbase+r;
	r = (BUN) (this - base);
@= refine_loop
		/* merge-scan tail of b, finding chunks with equal values; then sort each chunk on a */
		BATaccessBegin(b, USE_HEAD|USE_TAIL, MMAP_SEQUENTIAL);
		if (BAThordered(b)&1 && BAThdense(a))
			BATaccessBegin(a, USE_TAIL, MMAP_SEQUENTIAL);
		else
			BATaccessBegin(a, USE_HEAD|USE_HHASH|USE_TAIL, MMAP_WILLNEED);
		BATloop(b, p, q) {
			if ((*cmp) (BUNtail(bi, last), BUNtail(bi, p))) {
				cnt = sort_flush(offp, ids, cur, tpe, base ? base : a->T->vheap->base, hdst, tdst, &id, rv);
				hdst += cnt;
				tdst += cnt;

				last = p;
				cur = 0;
				@4
			}
			o = *(oid *) BUNhead(bi, p);
			BUNfndOID(r, ai, op);
			if (r == BUN_NONE) {
				GDKerror("CTrefine%s: value "OIDFMT"@0 not found in head of second BAT;\n"
					 "CTrefine%s: heads of both BATs do not form a 1-1 match.\n", rev, o, rev);
				BBPreclaim(bn);
				GDKfree(offp);
				GDKfree(ids);
				@3
				return GDK_FAIL;
			}
			if (cur >= end) {
				offp = (var_t*) GDKrealloc(offp, (size *= 2) * sizeof(var_t));
				ids = (oid*) GDKrealloc(ids, size * sizeof(oid));
				end = size;
				@2
			}
			@1
			offp[cur] = (base) ? r<<a->T->shift : VarHeapValRaw(a->T->heap.base, r, a->T->width);
			ids[cur] = o;
			cur++;
			this += sizeof(oid);
		}
		if (BAThordered(b)&1 && BAThdense(a))
			BATaccessEnd(a, USE_TAIL, MMAP_SEQUENTIAL);
		else
			BATaccessEnd(a, USE_HEAD|USE_HHASH|USE_TAIL, MMAP_WILLNEED);
		BATaccessEnd(b, USE_HEAD|USE_TAIL, MMAP_SEQUENTIAL);
@
@c
		cnt = sort_flush(offp, ids, cur, tpe, base ? base : a->T->vheap->base, hdst, tdst, &id, rv);
		hdst += cnt;
		tdst += cnt;

		GDKfree(offp);
		GDKfree(ids);
		if (a_void)
			GDKfree(base);
		BATsetcount(bn, (BUN) (((char*) tdst - bn->T->heap.base) / Tsize(bn)));
		bn->tsorted = 1;
		bn->trevsorted = 0;
	}
	*res = bn;
	return GDK_SUCCEED;
}

int
CTrefine(BAT **res, BAT *b, BAT *a)
{
	return refine(res, b, a, FALSE);
}

int
CTrefine_rev(BAT **res, BAT *b, BAT *a)
{
	return refine(res, b, a, TRUE);
}


str
GRPprelude(void)
{
	/* printf("#init group\n"); */
	TYPE_mapentry = malAtomFixed(sizeof(mapentry_t), sizeof(oid), "mapentry");
	if ( TYPE_mapentry < 0)
		throw(MAL,"group.prelude", RUNTIME_OBJECT_MISSING);
	return MAL_SUCCEED;
}

str
GRPgroup0(int *ret, int *bid, int *start, int *incr, int *grpsize)
{
	lng _t_ = GDKusec();
	BAT *result, *b;

	ALGODEBUG fprintf(stderr,
		"# GRPgroup0 ( bid=%d , start=%d , incr=%d , grpsize=%d )\n",
		*bid, *start, *incr, *grpsize);

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "group.new", RUNTIME_OBJECT_MISSING);
	}

	result = BATgroup(b, *start, *incr, *grpsize);
	if (result == 0)
		throw(MAL, "group.new", OPERATION_FAILED " Failed to group");
	*ret = result->batCacheid;
	BBPkeepref(*ret);
	BBPreleaseref(b->batCacheid);

	_t_ = GDKusec() - _t_;
	ALGODEBUG fprintf(stderr,
		"# GRPgroup0 ( bid=%d , start=%d , incr=%d , grpsize=%d ) -> ret=%d {%d.%06d s}\n",
		*bid, *start, *incr, *grpsize, *ret, (int)(_t_ / 1000000),(int)(_t_ % 1000000));

	return MAL_SUCCEED;
}

@= group_ordered
static BAT *
CTgroup_@1_ordered(BAT *b, BAT **res) 
{
	lng _t_ = GDKusec();
	BAT *bn;
	BAT *histo;
	@1 *t, *e, cur;
	wrd cnt = 0;
	oid *rt, curid;

	ALGODEBUG fprintf(stderr,
		"#  CTgroup_@1_ordered ( b=#%d:[%s,%s]:"BUNFMT" )\n",
		b->batCacheid, ATOMname(b->htype), ATOMname(b->ttype), BATcount(b));

	bn = BATnew(TYPE_void, TYPE_oid, BATcount(b));
	if (bn == NULL) 
		return NULL;
	histo = BATnew(TYPE_oid, TYPE_wrd, 1024); 
	if (histo == NULL) {
		BBPreclaim(bn);
		return NULL;
	}

	t = (@1*)Tloc(b, BUNfirst(b));
	e = t + BATcount(b);
	rt = (oid*)Tloc(bn, BUNfirst(bn));

	bn->hseqbase = b->hseqbase;
	bn->hsorted = 1;
	if (bn->hseqbase == oid_nil) {
		bn->hkey = 0;
		bn->hrevsorted = 1;
		bn->H->nonil = 0;
		bn->H->nil = 1;
	} else {
		bn->hkey = 1;
		bn->hrevsorted = 0;
		bn->H->nonil = 1;
		bn->H->nil = 0;
	}
	cur = *t;
	if (b->htype == TYPE_void) {
		oid h = b->hseqbase;

		curid = h;
		for(; t < e; t++, h++) {
			if (*t != cur) {
				BUNins(histo, &curid, &cnt, FALSE);
				cur = *t;
				curid = h;
				cnt = 0;
			}
			cnt++;
			*rt++ = curid;
		}
	} else { /* TYPE_oid */
		oid *h = (oid*)Hloc(b, BUNfirst(b));
	
		curid = *h;
		for(; t < e; t++, h++) {
			if (*t != cur) {
				BUNins(histo, &curid, &cnt, FALSE);
				cur = *t;
				curid = *h;
				cnt = 0;
			}
			cnt++;
			*rt++ = curid;
		}
	}
	BATsetcount(bn, BATcount(b));
	if (BATcount(b))
		BUNins(histo, &curid, &cnt, FALSE);
	if (b->htype != bn->htype) {
		BAT *r = VIEWcreate(b,bn);

		BBPreleaseref(bn->batCacheid);
		bn = r;
	}
	if (BAThordered(b)) {
		bn->tsorted = b->tsorted;
		bn->trevsorted = b->trevsorted;
		histo->hsorted = b->hsorted;
		histo->hrevsorted = b->hrevsorted;
		histo->tsorted = 0;
		histo->trevsorted = 0;
		BATkey(histo, TRUE);
	}
	if (b->hkey)
		BATkey(bn, TRUE);
	*res = bn;

	_t_ = GDKusec() - _t_;
	ALGODEBUG fprintf(stderr,
		"#  CTgroup_@1_ordered ( b=#%d:[%s,%s]:"BUNFMT" ) -> ( res=#%d:[%s,%s]:"BUNFMT" , histo=#%d:[%s,%s]:"BUNFMT" ) {%d.%06d s}\n",
		b->batCacheid, ATOMname(b->htype), ATOMname(b->ttype), BATcount(b),
		(*res)->batCacheid, ATOMname((*res)->htype), ATOMname((*res)->ttype), BATcount(*res),
		histo->batCacheid, ATOMname(histo->htype), ATOMname(histo->ttype), BATcount(histo),
		(int)(_t_ / 1000000),(int)(_t_ % 1000000));

	return histo;
}
@
@c
@:group_ordered(bte)@
@:group_ordered(sht)@
@:group_ordered(int)@
@:group_ordered(lng)@

str
GRPgroup(int *rethisto, int *retbid, int *bid)
{
	lng _t_ = GDKusec();
	BAT *histo = 0, *b, *bn = 0;

	ALGODEBUG fprintf(stderr,
		"# GRPgroup ( bid=%d )\n",
		*bid);

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "group.new", RUNTIME_OBJECT_MISSING);
	}
	if (!b->tkey && BATcount(b) > 1 &&
	    BATtordered(b) && 
	    ATOMtype(b->htype) == TYPE_oid && 
	    b->htype > TYPE_void &&
	    b->ttype < TYPE_str) {
		switch(tailtype(b,TRUE)) {
		case TYPE_bte:
			histo = CTgroup_bte_ordered(b, &bn);
			break;
		case TYPE_sht:
			histo = CTgroup_sht_ordered(b, &bn);
			break;
		case TYPE_int:
			histo = CTgroup_int_ordered(b, &bn);
			break;
		case TYPE_lng:
			histo = CTgroup_lng_ordered(b, &bn);
			break;
		default:
			throw(MAL, "group.new", SEMANTIC_TYPE_ERROR " expected {bte,sht,int,lng}");
		}
		if (!histo)
			throw(MAL, "group.new", OPERATION_FAILED);
		BBPkeepref(*rethisto = histo->batCacheid);
		BBPkeepref(*retbid = bn->batCacheid);
		BBPreleaseref(b->batCacheid);

		_t_ = GDKusec() - _t_;
		ALGODEBUG fprintf(stderr,
			"# GRPgroup ( bid=%d ) -> ( rethisto=%d , retbid=%d ) {%d.%06d s}\n",
			*bid, *rethisto, *retbid, (int)(_t_ / 1000000),(int)(_t_ % 1000000));

		return MAL_SUCCEED;
	}
	if (BATcount(b) > 32*1024 &&
	    (ATOMstorage(b->ttype) == TYPE_int || 
	     ATOMstorage(b->ttype) == TYPE_lng)) { 
		str rtrn;
		BUN N = BATcount(b);
		int B, one = 1;
		assert(N);
		if (b->ttype == TYPE_int) {
			int h, l;
			BATmax(b,&h);
			BATmin(b,&l);
			if (h != int_nil && l != int_nil && h-l > 0 && (BUN) (h-l) < N) 
				N = (BUN) (h-l);
		} else if (b->ttype == TYPE_wrd) {
			wrd h, l;
			BATmax(b,&h);
			BATmin(b,&l);
			if (h != wrd_nil && l != wrd_nil && h-l > 0 && (BUN) (h-l) < N) {
				assert(h-l <= (wrd) BUN_MAX);
				N = (BUN) (h-l);
			}
		} else if (b->ttype == TYPE_lng) {
			lng h, l;
			BATmax(b,&h);
			BATmin(b,&l);
			if (h != lng_nil && l != lng_nil && h-l > 0 && (BUN) (h-l) < N) {
				assert(h-l <= (lng) BUN_MAX);
				N = (BUN) (h-l);
			}
		}
		B = bits(N);
		assert(B);
		BBPunfix(b->batCacheid);
		rtrn = GRPgroup_custom(rethisto, retbid, bid, &B, &one);

		_t_ = GDKusec() - _t_;
		ALGODEBUG fprintf(stderr,
			"# GRPgroup ( bid=%d ) -> ( rethisto=%d , retbid=%d ) {%d.%06d s}\n",
			*bid, *rethisto, *retbid, (int)(_t_ / 1000000),(int)(_t_ % 1000000));

		return rtrn;
	}
	if(b->htype != TYPE_oid && b->htype != TYPE_void)
		throw(MAL, "group.GRPgroup", SEMANTIC_TYPE_ERROR "(v)oid head required\n");
	if (CTgroup(&bn, &histo, b) == GDK_FAIL) {
		BBPreleaseref(b->batCacheid);
		throw(MAL, "group.new",OPERATION_FAILED);
	}
	BBPkeepref(bn->batCacheid);
	BBPkeepref(histo->batCacheid);
	*rethisto = histo->batCacheid;
	*retbid = bn->batCacheid;
	BBPreleaseref(b->batCacheid);

	_t_ = GDKusec() - _t_;
	ALGODEBUG fprintf(stderr,
		"# GRPgroup ( bid=%d ) -> ( rethisto=%d , retbid=%d ) {%d.%06d s}\n",
		*bid, *rethisto, *retbid, (int)(_t_ / 1000000),(int)(_t_ % 1000000));

	return MAL_SUCCEED;
}

str
GRPgroup_custom(int *rethisto, int *retbid, int *bid, int *N, int *rng)
{
	lng _t_ = GDKusec();
	BAT *histo = 0, *b, *bn = 0;

	ALGODEBUG fprintf(stderr,
		"# GRPgroup ( bid=%d , N=%d , rng=%d )\n",
		*bid, *N, *rng);

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "group.new", RUNTIME_OBJECT_MISSING);
	}
	if(b->htype != TYPE_oid && b->htype != TYPE_void)
		throw(MAL, "group.GRPgroup", SEMANTIC_TYPE_ERROR "(v)oid head required\n");
	if (CTgroup_custom(&bn, &histo, b, N, rng) == GDK_FAIL) {
		BBPreleaseref(b->batCacheid);
		throw(MAL, "group.new",OPERATION_FAILED);
	}
	BBPkeepref(bn->batCacheid);
	BBPkeepref(histo->batCacheid);
	*rethisto = histo->batCacheid;
	*retbid = bn->batCacheid;
	BBPreleaseref(b->batCacheid);

	_t_ = GDKusec() - _t_;
	ALGODEBUG fprintf(stderr,
		"# GRPgroup ( bid=%d , N=%d , rng=%d ) -> ( rethisto=%d , retbid=%d ) {%d.%06d s}\n",
		*bid, *N, *rng, *rethisto, *retbid, (int)(_t_ / 1000000),(int)(_t_ % 1000000));

	return MAL_SUCCEED;
}

str
GRPderive(int *hid, int *mid, int *ct_histoid, int *ct_mapid, int *bid)
{
	lng _t_ = GDKusec();
	BAT *ct_map, *ct_histo, *b;
	BAT *bn = NULL, *histo = NULL;

	ALGODEBUG fprintf(stderr,
		"# GRPderive ( ct_histoid=%d , ct_mapid=%d , bid=%d )\n",
		*ct_histoid, *ct_mapid, *bid);

	if ((ct_map = BATdescriptor(*ct_mapid)) == NULL) {
		throw(MAL, "group.derive", RUNTIME_OBJECT_MISSING);
	}
	if(ct_map->htype != TYPE_oid && ct_map->htype != TYPE_void)
		throw(MAL, "group.GRPderive", SEMANTIC_TYPE_ERROR "(v)oid head required\n");
	if ((ct_histo = BATdescriptor(*ct_histoid)) == NULL) {
		BBPreleaseref(ct_map->batCacheid);
		throw(MAL, "group.derive", RUNTIME_OBJECT_MISSING);
	}
	if(ct_histo->htype != TYPE_oid && ct_histo->htype != TYPE_void)
		throw(MAL, "group.GRPderive", SEMANTIC_TYPE_ERROR "(v)oid head required\n");
	if ((b = BATdescriptor(*bid)) == NULL) {
		BBPreleaseref(ct_map->batCacheid);
		BBPreleaseref(ct_histo->batCacheid);
		throw(MAL, "group.derive", RUNTIME_OBJECT_MISSING);
	}
	if(b->htype != TYPE_oid && b->htype != TYPE_void)
		throw(MAL, "group.derive", SEMANTIC_TYPE_ERROR "(v)oid head required\n");
	if( derive(&histo, &bn, ct_histo, ct_map, b, tailtype(b, TRUE)) == GDK_FAIL){
		BBPreleaseref(b->batCacheid);
		BBPreleaseref(ct_map->batCacheid);
		BBPreleaseref(ct_histo->batCacheid);
		throw(MAL, "group.derive","Could not derive group");
	}
	BBPkeepref(bn->batCacheid);
	BBPkeepref(histo->batCacheid);

	*mid = bn->batCacheid;
	*hid = histo->batCacheid;
	BBPreleaseref(b->batCacheid);
	BBPreleaseref(ct_map->batCacheid);
	BBPreleaseref(ct_histo->batCacheid);

	_t_ = GDKusec() - _t_;
	ALGODEBUG fprintf(stderr,
		"# GRPderive ( ct_histoid=%d , ct_mapid=%d , bid=%d ) -> ( hid=%d , mid=%d ) {%d.%06d s}\n",
		*ct_histoid, *ct_mapid, *bid, *hid, *mid, (int)(_t_ / 1000000),(int)(_t_ % 1000000));

	return MAL_SUCCEED;
}

str
GRPrefine(int *retid, int *bid, int *aid)
{
	BAT *b, *a;
	BAT *bn = NULL;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "group.refine", RUNTIME_OBJECT_MISSING);
	}
	if(b->htype != TYPE_oid && b->htype != TYPE_void)
		throw(MAL, "group.refine", SEMANTIC_TYPE_ERROR "(v)oid head required\n");
	if ((a = BATdescriptor(*aid)) == NULL) {
		BBPreleaseref(b->batCacheid);
		throw(MAL, "group.refine", RUNTIME_OBJECT_MISSING);
	}
	if(a->htype != TYPE_oid && a->htype != TYPE_void)
		throw(MAL, "group.GRPrefine", SEMANTIC_TYPE_ERROR "(v)oid head required\n");

	CTrefine(&bn, b, a);
	if (!bn){
		BBPreleaseref(b->batCacheid);
		BBPreleaseref(a->batCacheid);
		throw(MAL, "group.refine", OPERATION_FAILED);
	}
	BBPkeepref(*retid = bn->batCacheid);
	BBPreleaseref(b->batCacheid);
	BBPreleaseref(a->batCacheid);
	return MAL_SUCCEED;
}

str
GRPrefine_rev(int *retid, int *bid, int *aid)
{
	BAT *b, *a;
	BAT *bn;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "group.refine", RUNTIME_OBJECT_MISSING);
	}
	if(b->htype != TYPE_oid && b->htype != TYPE_void)
		throw(MAL, "group.GRPrefine", SEMANTIC_TYPE_ERROR "(v)oid head required\n");
	if ((a = BATdescriptor(*aid)) == NULL) {
		BBPreleaseref(b->batCacheid);
		throw(MAL, "group.refine", RUNTIME_OBJECT_MISSING);
	}
	if(a->htype != TYPE_oid && a->htype != TYPE_void)
		throw(MAL, "group.GRPrefine", SEMANTIC_TYPE_ERROR "(v)oid head required\n");

	CTrefine_rev(&bn, b, a);
	if (!bn){
		BBPreleaseref(b->batCacheid);
		BBPreleaseref(a->batCacheid);
		throw(MAL, "group.refine", OPERATION_FAILED);
	}
	BBPkeepref(*retid = bn->batCacheid);
	BBPreleaseref(b->batCacheid);
	BBPreleaseref(a->batCacheid);
	return MAL_SUCCEED;
}

/*
 * @-
 *
 * These implementations need just one scan and a simple hash-maintained data
 * structure to compute a group of common aggregates.
 *
 * With group OIDs spanning a range of less SMALL_AGGR_MAX (the actual number
 * of groups might be even less, in case there are "holes" in the group OID
 * range), we use a simple array as temporary sum/cnt table on order to benefit
 * from positional lookups; with size of sum <= 8 bytes and size of cnt == 4
 * bytes, we stay below 16 KBytes, i.e., within (almost) any L1 cache
 */
#define SMALL_AGGR_MAX 1024

/*
 * @-
 */
@= large_aggr_sum
	if (BATprepareHash(bn)) {
		BBPreclaim(bn);
		throw(MAL, "group.sum", MAL_MALLOC_FAIL);
	}
	BATaccessBegin(b, USE_HEAD|USE_TAIL, MMAP_SEQUENTIAL);
	if (BAThordered(b) && BAThdense(bn))
		BATaccessBegin(bn, USE_TAIL, MMAP_SEQUENTIAL);
	else
		BATaccessBegin(bn, USE_HEAD|USE_HHASH|USE_TAIL, MMAP_WILLNEED);
	BATloop(b, p, q) {
		oid *h = (oid*) BUNhead(bi,p);
		@1 *t = (@1*) BUN@2(bi,p);

		BUNfndOID(r, bni, h);
		if (r != BUN_NONE) {
			@3 *dst = (@3*) BUN@2(bni, r);
			if (*dst != @3_nil) {
				if (*t == @1_nil) {
					*dst = @3_nil;
				} else {
					*dst += *t;
				}
			}
		}
	}
	if (BAThordered(b) && BAThdense(bn))
		BATaccessEnd(bn, USE_TAIL, MMAP_SEQUENTIAL);
	else
		BATaccessEnd(bn, USE_HEAD|USE_HHASH|USE_TAIL, MMAP_WILLNEED);
	BATaccessEnd(b, USE_HEAD|USE_TAIL, MMAP_SEQUENTIAL);
@
 * @-
@= small_aggr_sum
	sums = (@3*) GDKzalloc(range*sizeof(@3));
	BATaccessBegin(b, USE_HEAD|USE_TAIL, MMAP_SEQUENTIAL);
	BATloop(b, p, q) {
		oid h = (*(oid*) BUNhead(bi,p)) - min;
		@1 *t = (@1*) BUN@2(bi,p);

		if (h < range) {
			@3 *dst = sums + h;
			if (*dst != @3_nil) {
				if (*t == @1_nil) {
					*dst = @3_nil;
				} else {
					*dst += *t;
				}
			}
		}
	}
	BATaccessEnd(b, USE_HEAD|USE_TAIL, MMAP_SEQUENTIAL);
	BATloop(bn, p, q) {
		oid h = (*(oid*) BUNhead(bni,p)) - min;
		*(@3*)BUN@2(bni, p) = sums[h];
	}
	GDKfree(sums);
@= large_aggr_prod
	if (BATprepareHash(bn)) {
		BBPreclaim(bn);
		throw(MAL, "group.prod", MAL_MALLOC_FAIL);
	}
	BATaccessBegin(b, USE_HEAD|USE_TAIL, MMAP_SEQUENTIAL);
	if (BAThordered(b) && BAThdense(bn))
		BATaccessBegin(bn, USE_TAIL, MMAP_SEQUENTIAL);
	else
		BATaccessBegin(bn, USE_HEAD|USE_HHASH|USE_TAIL, MMAP_WILLNEED);
	BATloop(b, p, q) {
		oid *h = (oid*) BUNhead(bi,p);
		@1 *t = (@1*) BUN@2(bi,p);

		BUNfndOID(r, bni, h);
		if (r != BUN_NONE) {
			@3 *dst = (@3*) BUN@2(bni, r);
			if (*dst != @3_nil) {
				if (*t == @1_nil) {
					*dst = @3_nil;
				} else {
					*dst *= *t;
				}
			}
		}
	}
	if (BAThordered(b) && BAThdense(bn))
		BATaccessEnd(bn, USE_TAIL, MMAP_SEQUENTIAL);
	else
		BATaccessEnd(bn, USE_HEAD|USE_HHASH|USE_TAIL, MMAP_WILLNEED);
	BATaccessEnd(b, USE_HEAD|USE_TAIL, MMAP_SEQUENTIAL);
@
@c
@= small_aggr_prod
	prods = (@3*) GDKmalloc(range*sizeof(@3));
	for (i = 0; i < range; i++)
		prods[i] = one;
	BATaccessBegin(b, USE_HEAD|USE_TAIL, MMAP_SEQUENTIAL);
	BATloop(b, p, q) {
		oid h = (*(oid*) BUNhead(bi,p)) - min;
		@1 *t = (@1*) BUN@2(bi,p);

		if (h < range) {
			@3 *dst = prods + h;
			if (*dst != @3_nil) {
				if (*t == @1_nil) {
					*dst = @3_nil;
				} else {
					*dst *= *t;
				}
			}
		}
	}
	BATaccessEnd(b, USE_HEAD|USE_TAIL, MMAP_SEQUENTIAL);
	BATloop(bn, p, q) {
		oid h = (*(oid*) BUNhead(bni,p)) - min;
		*(@3*)BUN@2(bni, p) = prods[h];
	}
        GDKfree(prods);
@= large_aggr_avg
	cnt  = (BUN*) GDKzalloc(BATcount(e)*sizeof(BUN));
	if (BATprepareHash(bn)) {
		GDKfree(cnt);
		BBPreclaim(bn);
		throw(MAL, "group.@1", MAL_MALLOC_FAIL);
	}
	BATaccessBegin(b, USE_HEAD|USE_TAIL, MMAP_SEQUENTIAL);
	if (BAThordered(b) && BAThdense(bn))
		BATaccessBegin(bn, USE_TAIL, MMAP_SEQUENTIAL);
	else
		BATaccessBegin(bn, USE_HEAD|USE_HHASH|USE_TAIL, MMAP_WILLNEED);
	BATloop(b, p, q) {
		oid *h = (oid*) BUNhead(bi,p);
		@1 *t = (@1*) BUN@2(bi,p);

		BUNfndOID(r,bni,h);
		if (r != BUN_NONE) {
			dbl *dst = (dbl*) BUN@2(bni, r);
			if (*dst != dbl_nil) {
				if (*t == @1_nil) {
					*dst = dbl_nil;
				} else {
					*dst += *t;
				}
				cnt[r-off]++;
			}
		}
	}
	if (BAThordered(b) && BAThdense(bn))
		BATaccessEnd(bn, USE_TAIL, MMAP_SEQUENTIAL);
	else
		BATaccessEnd(bn, USE_HEAD|USE_HHASH|USE_TAIL, MMAP_WILLNEED);
	BATaccessEnd(b, USE_HEAD|USE_TAIL, MMAP_SEQUENTIAL);
	/* postprocess by dividing sums by counts */
	BATloop(bn, p, q) {
		dbl *dst = (dbl*) BUN@2(bni, p);
		if (cnt[yy] == 0) {
			*dst = dbl_nil;
		} else if (*dst != dbl_nil) {
			*dst = (dbl) (*dst / cnt[yy]);
		}
		yy++;
	}
	GDKfree(cnt);
@
@c
@= small_aggr_avg
	sums = (dbl*) GDKzalloc(range*sizeof(dbl));
	cnt  = (BUN*) GDKzalloc(range*sizeof(BUN));
	BATaccessBegin(b, USE_HEAD|USE_TAIL, MMAP_SEQUENTIAL);
	BATloop(b, p, q) {
		oid h = (*(oid*) BUNhead(bi,p)) - min;
		@1 *t = (@1*) BUN@2(bi,p);

		if (h < range) {
			dbl *dst = sums + h;
			if (*dst != dbl_nil) {
				if (*t == @1_nil) {
					*dst = dbl_nil;
				} else {
					*dst += *t;
				}
				cnt[h]++;
			}
		}
	}
	BATaccessEnd(b, USE_HEAD|USE_TAIL, MMAP_SEQUENTIAL);
	/* postprocess by dividing sums by counts */
	BATloop(bn, p, q) {
		oid h = (*(oid*) BUNhead(bni,p)) - min;
		dbl *dst = (dbl*) BUN@2(bni, p);
		if (cnt[h] == 0 || sums[h] == dbl_nil) {
			*dst = dbl_nil;
		} else {
			*dst = (dbl) (sums[h]/cnt[h]);
		}
	}
        GDKfree(sums);
	GDKfree(cnt);

@= arithsumprod
group_export str GRPsum_@1_@3(int *retval, int *bid, int  *eid, bit *ignore_nils);
str GRPsum_@1_@3(int *retval, int *bid, int  *eid, bit *ignore_nils)
{
	BAT *b = NULL, *e = NULL;
	BAT *bn;
	BATiter ei, bi, bni;
	@3 zero = (@3) 0, *sums;
	BUN p, q, r;
	oid i, range, min, max;


	(void) ignore_nils; /* fool compiler */
	if( (b= BATdescriptor(*bid)) == NULL ){
		throw(MAL, "group.sum", RUNTIME_OBJECT_MISSING);
	}

	if(b->htype != TYPE_oid && b->htype != TYPE_void)
		throw(MAL, "group.GRPsum_@1_@3", SEMANTIC_TYPE_ERROR "(v)oid head required\n");
	if( (e= BATdescriptor(*eid)) == NULL ){
		BBPreleaseref(b->batCacheid);
		throw(MAL, "group.sum", RUNTIME_OBJECT_MISSING);
	}
	bn = BATnew(e->htype, BATttype(b), BATcount(e));
	if (bn == NULL){
		BBPreleaseref(e->batCacheid);
		BBPreleaseref(b->batCacheid);
		throw(MAL, "group.sum", MAL_MALLOC_FAIL);
	}

	if(e->htype != TYPE_oid && e->htype != TYPE_void)
		throw(MAL, "group.GRPsum_@1_@3", SEMANTIC_TYPE_ERROR "(v)oid head required\n");
	/* init: set all sums to zero */
	bn->tsorted = bn->hsorted = 0;
	bn->trevsorted = bn->hrevsorted = 0;
	bn->T->nonil = 0;
	ALIGNsetH(bn, e);
	ei = bat_iterator(e);
	bi = bat_iterator(b);
	bni = bat_iterator(bn);

	if (BAThordered(e)) {
		min = *(oid*)BUNhead(ei, BUNfirst(e));
		BATaccessBegin(e, USE_HEAD, MMAP_SEQUENTIAL);
		BATloop(e, p, q) {
			if (BUNfastins(bn, BUNhead(ei,p), &zero) == NULL) {
				BBPreclaim(bn);
				throw(MAL, "group.sum", OPERATION_FAILED " Cannot insert zero");
			}
		}
		BATaccessEnd(e, USE_HEAD, MMAP_SEQUENTIAL);
		max = *(oid*)BUNhead(ei, BUNlast(e)-1);
	} else {
		min = max = *(oid*)BUNhead(ei, BUNfirst(e));
		BATaccessBegin(e, USE_HEAD, MMAP_SEQUENTIAL);
		BATloop(e, p, q) {
			if (BUNfastins(bn, BUNhead(ei,p), &zero) == NULL) {
				BBPreclaim(bn);
				throw(MAL, "group.sum", OPERATION_FAILED " Cannot insert zero");
			}
			i = *(oid*)BUNhead(ei, p);
			if (i < min)
				min = i;
			else if (i > max)
				max = i;
		}
		BATaccessEnd(e, USE_HEAD, MMAP_SEQUENTIAL);
	}
	range = max - min + 1;

	/* scan b, and add values to sums in-place */
	if (range > SMALL_AGGR_MAX) {
		ALGODEBUG fprintf(stderr, "#CMDaggr_sum_@1_@3: range(=" OIDFMT ") > SMALL_AGGR_MAX(=%d)  => large_aggr_sum\n",range,SMALL_AGGR_MAX);
		@:large_aggr_sum(@1,@2,@3)@
	} else {
		ALGODEBUG fprintf(stderr, "#CMDaggr_sum_@1_@3: range(=" OIDFMT ") <= SMALL_AGGR_MAX(=%d)  => small_aggr_sum\n",range,SMALL_AGGR_MAX);
		@:small_aggr_sum(@1,@2,@3)@
	}
	BBPkeepref(*retval = bn->batCacheid);
	BBPreleaseref(b->batCacheid);
	BBPreleaseref(e->batCacheid);
	return MAL_SUCCEED;
}

group_export str GRPprod_@1_@3(int *retval, int *bid, int  *eid, bit *ignore_nils);
str GRPprod_@1_@3(int *retval, int *bid, int  *eid, bit *ignore_nils)
{
	BAT *bn, *b, *e;
	BATiter ei, bi, bni;
	@3 one = (@3) 1, *prods;
	BUN p, q, r;
	oid i, range, min, max;

	(void) ignore_nils; /* fool compiler */
	if( (b= BATdescriptor(*bid)) == NULL )
		throw(MAL, "group.prod", RUNTIME_OBJECT_MISSING);

	if(b->htype != TYPE_oid && b->htype != TYPE_void)
		throw(MAL, "group.GRPgroup_@1_@3", SEMANTIC_TYPE_ERROR "(v)oid head required\n");
	if( (e= BATdescriptor(*eid)) == NULL ){
		BBPreleaseref(b->batCacheid);
		throw(MAL, "group.prod", RUNTIME_OBJECT_MISSING);
	}
 	bn = BATnew(e->htype, TYPE_@3, BATcount(e));
	if (bn == NULL){
		BBPreleaseref(b->batCacheid);
		BBPreleaseref(e->batCacheid);
		throw(MAL, "group.prod", MAL_MALLOC_FAIL);
	}

	if(e->htype != TYPE_oid && e->htype != TYPE_void)
		throw(MAL, "group.GRPprod_@1_@3", SEMANTIC_TYPE_ERROR "(v)oid head required\n");
	/* init: set all prods to one */
	bn->tsorted = bn->hsorted = 0;
	bn->trevsorted = bn->hrevsorted = 0;
	bn->T->nonil = 0;
	ALIGNsetH(bn, e);
	ei = bat_iterator(e);
	bi = bat_iterator(b);
	bni = bat_iterator(bn);

	if (BAThordered(e)) {
		min = *(oid*)BUNhead(ei, BUNfirst(e));
		BATaccessBegin(e, USE_HEAD, MMAP_SEQUENTIAL);
		BATloop(e, p, q) {
			if (BUNfastins(bn, BUNhead(ei,p), &one) == NULL) {
				BBPreclaim(bn);
				throw(MAL, "group.prod", OPERATION_FAILED " Cannot insert one");
			}
		}
		BATaccessEnd(e, USE_HEAD, MMAP_SEQUENTIAL);
		max = *(oid*)BUNhead(ei, BUNlast(e)-1);
	} else {
		min = max = *(oid*)BUNhead(ei, BUNfirst(e));
		BATaccessBegin(e, USE_HEAD, MMAP_SEQUENTIAL);
		BATloop(e, p, q) {
			if (BUNfastins(bn, BUNhead(ei,p), &one) == NULL) {
				BBPreclaim(bn);
				throw(MAL, "group.prod", OPERATION_FAILED " Cannot insert one");
			}
			i = *(oid*)BUNhead(ei, p);
			if (i < min)
				min = i;
			else if (i > max)
				max = i;
		}
		BATaccessEnd(e, USE_HEAD, MMAP_SEQUENTIAL);
	}
	range = max - min + 1;

	/* scan b, and mul values to prods in-place */
	if (range > SMALL_AGGR_MAX) {
		ALGODEBUG fprintf(stderr, "#CMDaggr_prod_@1_@3: range(=" OIDFMT ") > SMALL_AGGR_MAX(=%d)  => large_aggr_prod\n",range,SMALL_AGGR_MAX);
		@:large_aggr_prod(@1,@2,@3)@
	} else {
		ALGODEBUG fprintf(stderr, "#CMDaggr_prod_@1_@3: range(=" OIDFMT ") <= SMALL_AGGR_MAX(=%d)  => small_aggr_prod\n",range,SMALL_AGGR_MAX);
		@:small_aggr_prod(@1,@2,@3)@
	}
	BBPkeepref(*retval = bn->batCacheid);
	BBPreleaseref(b->batCacheid);
	BBPreleaseref(e->batCacheid);
	return MAL_SUCCEED;
}
@
@c
@:arithsumprod(bte,tloc,bte)@
@:arithsumprod(bte,tloc,sht)@
@:arithsumprod(bte,tloc,int)@
@:arithsumprod(bte,tloc,wrd)@
@:arithsumprod(bte,tloc,lng)@
@:arithsumprod(sht,tloc,sht)@
@:arithsumprod(sht,tloc,int)@
@:arithsumprod(sht,tloc,wrd)@
@:arithsumprod(sht,tloc,lng)@
@:arithsumprod(int,tloc,int)@
@:arithsumprod(int,tloc,wrd)@
@:arithsumprod(int,tloc,lng)@
@:arithsumprod(wrd,tloc,wrd)@
@:arithsumprod(wrd,tloc,lng)@
@:arithsumprod(lng,tloc,lng)@
@:arithsumprod(oid,tloc,oid)@
@:arithsumprod(flt,tloc,flt)@
@:arithsumprod(flt,tloc,dbl)@
@:arithsumprod(dbl,tloc,dbl)@

@= arithavg
group_export str GRPavg_@1(int *ret, int *bid, int *eid);
str GRPavg_@1(int *ret, int *bid, int *eid)
{
	BAT *b = NULL, *e = NULL;
	BAT *bn = NULL;
	BATiter ei, bi, bni;
	BUN yy = 0, off;
	BUN *cnt;
	oid i, range, min, max;
	dbl zero = (dbl) 0, *sums;
	BUN p, q, r;

	if ((b = BATdescriptor(*bid)) == NULL ){
		throw(MAL, "group.@1", RUNTIME_OBJECT_MISSING);
	}
	if(b->htype != TYPE_oid && b->htype != TYPE_void)
		throw(MAL, "group.GRPavg_@1", SEMANTIC_TYPE_ERROR "(v)oid head required\n");
	if( (e= BATdescriptor(*eid)) == NULL ){
		BBPreleaseref(b->batCacheid);
		throw(MAL, "group.@1", RUNTIME_OBJECT_MISSING);
	}
	if(e->htype != TYPE_oid && e->htype != TYPE_void)
		throw(MAL, "group.GRPavg_@1", SEMANTIC_TYPE_ERROR "(v)oid head required\n");
	bn = BATnew(e->htype, BATttype(b), BATcount(e));
	if (bn == NULL){
		BBPreleaseref(b->batCacheid);
		BBPreleaseref(e->batCacheid);
		throw(MAL, "group.@1", MAL_MALLOC_FAIL);
	}

	/* init sums and counts to zero */
	bn->tsorted = bn->hsorted = 0;
	bn->trevsorted = bn->hrevsorted = 0;
	bn->T->nonil = 0;
	ALIGNsetH(bn, e);
	ei = bat_iterator(e);
	bi = bat_iterator(b);
	bni = bat_iterator(bn);
	off = BUNfirst(bn);

	if (BAThordered(e)) {
		min = *(oid*)BUNhead(ei, BUNfirst(e));
		BATaccessBegin(e, USE_HEAD, MMAP_SEQUENTIAL);
		BATloop(e, p, q) {
			if (BUNfastins(bn, BUNhead(ei,p), &zero) == NULL) {
				BBPreclaim(bn);
				throw(MAL, "group.@1", OPERATION_FAILED " Cannot insert zero");
			}
		}
		BATaccessEnd(e, USE_HEAD, MMAP_SEQUENTIAL);
		max = *(oid*)BUNhead(ei, BUNlast(e)-1);
	} else {
		min = max = *(oid*)BUNhead(ei, BUNfirst(e));
		BATaccessBegin(e, USE_HEAD, MMAP_SEQUENTIAL);
		BATloop(e, p, q) {
			if (BUNfastins(bn, BUNhead(ei,p), &zero) == NULL) {
				BBPreclaim(bn);
				throw(MAL, "group.@1", OPERATION_FAILED " Cannot insert zero");
			}
			i = *(oid*)BUNhead(ei, p);
			if (i < min)
				min = i;
			else if (i > max)
				max = i;
		}
		BATaccessEnd(e, USE_HEAD, MMAP_SEQUENTIAL);
	}
	range = max - min + 1;

	/* scan b, adding sums, and incrementing counts */
	if (range > SMALL_AGGR_MAX) {
		ALGODEBUG fprintf(stderr, "#CMDaggr_avg_@1: range(=" OIDFMT ") > SMALL_AGGR_MAX(=%d)  =>  large_aggr_avg\n",range,SMALL_AGGR_MAX);
		@:large_aggr_avg(@1,@2)@
	} else {
		ALGODEBUG fprintf(stderr, "#CMDaggr_avg_@1: range(=" OIDFMT ") <= SMALL_AGGR_MAX(=%d)  =>  small_aggr_avg\n",range,SMALL_AGGR_MAX);
		@:small_aggr_avg(@1,@2)@
	}
	BBPkeepref(*ret= bn->batCacheid);
	BBPreleaseref(b->batCacheid);
	BBPreleaseref(e->batCacheid);
	return MAL_SUCCEED;
}
@
@c
@:arithavg(bte,tloc)@
@:arithavg(sht,tloc)@
@:arithavg(int,tloc)@
@:arithavg(wrd,tloc)@
@:arithavg(oid,tloc)@
@:arithavg(lng,tloc)@
@:arithavg(flt,tloc)@
@:arithavg(dbl,tloc)@

@= arithvar
group_export str GRPvar_@1(int *ret, int *bid, int *eid);
str GRPvar_@1(int *ret, int *bid, int *eid)
{
	int err = 0;
	BUN nElements;
	BAT *b = NULL, *e = NULL;
	BAT *bn = NULL;
	BATiter ei, bi;
	BUN off, idx = 0;
	wrd *cnt;
	@1 zero = (@1) 0;
	dbl *sum ;
	dbl *sumsquares ;
	BUN p, q, r;
	oid previousOid = oid_nil;

	if ((b = BATdescriptor(*bid)) == NULL ){
		throw(MAL, "group.@1", RUNTIME_OBJECT_MISSING);
	}
	if(b->htype != TYPE_oid && b->htype != TYPE_void)
		throw(MAL, "group.GRPavg_@1", SEMANTIC_TYPE_ERROR "(v)oid head required\n");
	if( (e= BATdescriptor(*eid)) == NULL ){
		BBPreleaseref(b->batCacheid);
		throw(MAL, "group.@1", RUNTIME_OBJECT_MISSING);
	}
	if(e->htype != TYPE_oid && e->htype != TYPE_void)
		throw(MAL, "group.GRPavg_@1", SEMANTIC_TYPE_ERROR "(v)oid head required\n");
	bn = BATnew(e->htype, BATttype(b), BATcount(e));
	if (bn == NULL){
		BBPreleaseref(b->batCacheid);
		BBPreleaseref(e->batCacheid);
		throw(MAL, "group.@1", MAL_MALLOC_FAIL);
	}
	nElements = BATcount(e);

	off = BUNfirst(e);
	/* init sums and counts to zero */
	bn->tsorted = bn->hsorted = 0;
	bn->trevsorted = bn->hrevsorted = 0;
	bn->T->nonil = 0;
	ALIGNsetH(bn, e);
	ei = bat_iterator(e);
	bi = bat_iterator(b);
	cnt = (wrd*) GDKmalloc(nElements*sizeof(wrd));
	if (cnt == NULL) {
		BBPreclaim(bn);
		throw(MAL, "group.@1", MAL_MALLOC_FAIL);
	}
	sum = (dbl*) GDKmalloc(nElements*sizeof(dbl));
	if (sum == NULL) {
		BBPreclaim(bn);
		GDKfree(cnt);
		throw(MAL, "group.@1", MAL_MALLOC_FAIL);
	}
	sumsquares = (dbl*) GDKmalloc(nElements*sizeof(dbl));
	if (sumsquares == NULL) {
		BBPreclaim(bn);
		GDKfree(cnt);
		GDKfree(sum);
		throw(MAL, "group.@1", MAL_MALLOC_FAIL);
	}

	/* scan b, adding sums, and incrementing counts */
	if (BATprepareHash(bn)) {
		BBPreclaim(bn);
		GDKfree(cnt);
		GDKfree(sum);
		GDKfree(sumsquares);
		throw(MAL, "group.@1", MAL_MALLOC_FAIL);
	}

	/* init sums and counts to zero */
	memset(cnt, 0, nElements*sizeof(wrd));
	memset(sum, 0, nElements*sizeof(dbl));
	memset(sumsquares, 0, nElements*sizeof(dbl));

	BATaccessBegin(b, USE_HEAD, MMAP_SEQUENTIAL);
	if (!BAThordered(b) || !BAThdense(e))
		BATaccessBegin(e, USE_HEAD|USE_HHASH, MMAP_WILLNEED);
	BATloop(b, p, q) {
		oid *h = (oid*) BUNhead(bi,p);
		if (*h != previousOid) {
			previousOid = *h;
			BUNfndOID(r,ei,h);
			if (r == BUN_NONE)
				continue;
			idx = r-off;
		}

		if (cnt[idx] != wrd_nil) {
			@1 v = *(@1*) BUNtloc(bi,p);
			if (v == @1_nil) {
				cnt[idx] = wrd_nil;
			} else {
				cnt[idx]++;
				sum[idx] += v;
				sumsquares[idx] += (v * v);
			}
		}
	}
	if (!BAThordered(b) || !BAThdense(e))
		BATaccessEnd(e, USE_HEAD|USE_HHASH, MMAP_WILLNEED);
	BATaccessEnd(b, USE_HEAD, MMAP_SEQUENTIAL);

	/* postprocess by dividing sumsquares and sum by counts and
	   substracting square of the averages from the average sum of
	   squares */
	idx = 0;
	BATaccessBegin(e, USE_HEAD, MMAP_SEQUENTIAL);
	BATloop(e, p, q) {
		if (cnt[idx] == wrd_nil) {
			@1 _nil = @1_nil;
			if (BUNfastins(bn, BUNhead(ei,p), (ptr)&_nil) == NULL) {
				err = 1;
				break;
			}
		} else if (cnt[idx] <= 1) {
			if (BUNfastins(bn, BUNhead(ei,p), &zero) == NULL) {
				err = 1;
				break;
			}
		} else {
			dbl avg = (sum[idx] / cnt[idx]);
			@1 variance = (@1) (sumsquares[idx] / cnt[idx] - (avg * avg));
			if (BUNfastins(bn, BUNhead(ei,p), &variance) == NULL) {
				err = 1;
				break;
			}
		}
		idx++;
	}
	BATaccessEnd(e, USE_HEAD, MMAP_SEQUENTIAL);
	GDKfree(cnt);
	GDKfree(sum);
	if (err) {
		BBPreclaim(bn);
		throw(MAL, "group.@1", "failed");
	}
	bn->hsorted = bn->tsorted = 0;
	bn->hrevsorted = bn->trevsorted = 0;
	bn->T->nonil = 0;
	ALIGNsetH(bn, e);
	BBPkeepref(*ret= bn->batCacheid);
	BBPreleaseref(b->batCacheid);
	BBPreleaseref(e->batCacheid);
	return MAL_SUCCEED;
}
@
@c
@:arithvar(bte)@
@:arithvar(sht)@
@:arithvar(int)@
@:arithvar(wrd)@
@:arithvar(lng)@
@:arithvar(oid)@
@:arithvar(flt)@
@:arithvar(dbl)@


@= extreme
static int
CMDaggr_@1_@3(BAT **ret, BAT *b, BAT *e)
{
	BAT *bn = *ret = BATnew(e->htype, BATttype(b), BATcount(e));
	BATiter ei = bat_iterator(e), bi = bat_iterator(b);
	int (*cmp)(const void *, const void *);
	ptr nil;
	BUN yy = 0, off;
	@3 *extremes;
	BUN p, q, r;

	if (bn == NULL)
		return GDK_FAIL;
	cmp = BATatoms[bn->ttype].atomCmp;
	nil = ATOMnilptr(bn->ttype);
	off = BUNfirst(e);
	extremes = (@3*) GDKmalloc(BATcount(e)*sizeof(@3));
	if (extremes == NULL) {
		BBPreclaim(bn);
		return GDK_FAIL;
	}

	/* init: set all extremes to the zero pointer */
	@:extreme_init_@3(@4)@

	/* scan b and replace totals by the extreme value (just pointers to vals in b) */
	if (BATprepareHash(e)) {
		BBPreclaim(bn);
		GDKfree(extremes);
		return GDK_FAIL;
	}
	if (!BAThordered(b) || !BAThdense(e))
		BATaccessBegin(e, USE_HEAD|USE_HHASH, MMAP_WILLNEED);
	BATaccessBegin(b, USE_HEAD|USE_TAIL, MMAP_WILLNEED);
	BATloop(b, p, q) {
		oid *h = (oid*) BUNhead(bi,p);
		ptr t =  BUNtail(bi,p);

		BUNfndOID(r,ei,h);
		if (r != BUN_NONE) {
			@:extreme_body_@3(@2)@
		}
	}
	BATaccessEnd(b, USE_HEAD|USE_TAIL, MMAP_WILLNEED);
	if (!BAThordered(b) || !BAThdense(e))
		BATaccessEnd(e, USE_HEAD|USE_HHASH, MMAP_WILLNEED);
	/* insert the extreme values into the result */
	yy = 0;
	BATaccessBegin(e, USE_HEAD, MMAP_SEQUENTIAL);
	BATloop(e, p, q) {
		@3 val = extremes[yy++];
		if (BUNfastins(bn, BUNhead(ei,p), @:extreme_tail_@3@) == NULL) {
			ret = NULL;
			break;
		}
	}
	BATaccessEnd(e, USE_HEAD, MMAP_SEQUENTIAL);
	GDKfree(extremes);
	if (!ret) {
		BBPreclaim(bn);
		return GDK_FAIL;
	}
	bn->tsorted = bn->hsorted = 0;
	bn->trevsorted = bn->hrevsorted = 0;
	bn->T->nonil = 0;
	ALIGNsetH(bn, e);
	return GDK_SUCCEED;
}
@= extreme_init_oid
	for (yy = 0 ; yy < BATcount(e) ; yy++) extremes[yy] = GDK_oid_@1;
@= extreme_init_ptr
	memset(extremes, 0, BATcount(e)*sizeof(ptr));
@= extreme_body_oid
			oid *val = extremes + r - off;
			if (*val != *(oid*)nil) {
				if ((*cmp)(t,nil) == 0) {
					*val = *(oid*)nil;
				} else if ((*cmp)(t,val) @1 0) {
					*val = *(oid*)t;
				}
			}
@= extreme_body_ptr
			ptr *val = extremes + r - off;
			if (*val != nil) {
				if ((*cmp)(t,nil) == 0) {
					*val = nil;
				} else if (*val == NULL || (*cmp)(t,*val) @1 0) {
					*val = t;
				}
			}
@= extreme_tail_oid
	&val
@= extreme_tail_ptr
	val?val:nil
@= extreme_
@:extreme(@1,@2,oid,@3)@
@:extreme(@1,@2,ptr,@3)@
group_export str GRP@1(int *retval, int *bid, int *eid);
str
GRP@1(int *retval, int *bid, int *eid)
{
	BAT *b = NULL, *e = NULL, *bn;
	int res = 0;

	if ((b = BATdescriptor(*bid)) == NULL ){
		throw(MAL, "group.@1", RUNTIME_OBJECT_MISSING);
	}
	if(b->htype != TYPE_oid && b->htype != TYPE_void)
		throw(MAL, "group.GRP@1", SEMANTIC_TYPE_ERROR "(v)oid head required\n");
	if ((e = BATdescriptor(*eid)) == NULL ){
		BBPreleaseref(b->batCacheid);
		throw(MAL, "group.@1", RUNTIME_OBJECT_MISSING);
	}
	if(e->htype != TYPE_oid && e->htype != TYPE_void)
		throw(MAL, "group.GRP@1", SEMANTIC_TYPE_ERROR "(v)oid head required\n");

	if (b->ttype == TYPE_void) {
		res = CMDaggr_@1_oid(&bn, b, e);
	} else {
		res = CMDaggr_@1_ptr(&bn, b, e);
	}
	if (!res){
		BBPreleaseref(b->batCacheid);
		BBPreleaseref(e->batCacheid);
		throw(MAL, "group.@1", RUNTIME_OBJECT_MISSING);
	}
	BBPkeepref(*retval = bn->batCacheid);
	BBPreleaseref(b->batCacheid);
	BBPreleaseref(e->batCacheid);
	return MAL_SUCCEED;
}
@
@c
@:extreme_(min,<,max)@
@:extreme_(max,>,min)@

@= large_aggr_count
	if (BATprepareHash(bn)) {
		BBPreclaim(bn);
		throw(MAL, "group.count", MAL_MALLOC_FAIL);
	}
	BATaccessBegin(b, USE_HEAD|USE_TAIL, MMAP_SEQUENTIAL);
	if (BAThordered(b) && BAThdense(bn))
		BATaccessBegin(bn, USE_TAIL, MMAP_SEQUENTIAL);
	else
		BATaccessBegin(bn, USE_HEAD|USE_HHASH|USE_TAIL, MMAP_WILLNEED);
	BATloop(b, p, q) {
		oid *h = (oid*) BUNhead(bi,p);

		BUNfndOID(r, bni, h);
		if (r != BUN_NONE) {
			ptr t = BUNtail(bi,p);
			(void) t; /* silence compiler about unused variable */
			@1 {
				wrd *dst = (wrd*) BUNtloc(bni, r);
				(*dst)++;
			}
		}
	}
	if (BAThordered(b) && BAThdense(bn))
		BATaccessEnd(bn, USE_TAIL, MMAP_SEQUENTIAL);
	else
		BATaccessEnd(bn, USE_HEAD|USE_HHASH|USE_TAIL, MMAP_WILLNEED);
	BATaccessEnd(b, USE_HEAD|USE_TAIL, MMAP_SEQUENTIAL);
@
@c
@= small_aggr_count
	cnt  = (wrd*) GDKzalloc(range*sizeof(wrd));
	BATaccessBegin(b, USE_HEAD|USE_TAIL, MMAP_SEQUENTIAL);
	BATloop(b, p, q) {
		oid h = (*(oid*) BUNhead(bi,p)) - min;

		if (h < range) {
			ptr t = BUNtail(bi,p);
			(void) t; /* silence compiler about unused variable */
			@1 {
				cnt[h]++;
			}
		}
	}
	BATaccessEnd(b, USE_HEAD|USE_TAIL, MMAP_SEQUENTIAL);
	BATloop(bn, p, q) {
		oid h = (*(oid*) BUNhead(bni,p)) - min;
		*(wrd*)BUNtloc(bni, p) = cnt[h];
	}
        GDKfree(cnt);
@
@c

group_export str GRPaggr_count(int *retval, int *bid, int *eid, bit *ignore_nils);
str
GRPaggr_count(int *retval, int *bid, int *eid, bit *ignore_nils)
{
/* XXX in a large BAT, it is conceivable that there are head elements
   that occur more often than fits in an "int", so the return BAT
   should really have a tail type of BUN.
 */
	BAT *bn, *b = NULL, *e = NULL;
	BATiter ei, bi, bni;
	wrd zero = 0, *cnt;
	BUN p, q, r;
	oid i, range, min, max;
	int btt;
	ptr bt_nil;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "group.count", RUNTIME_OBJECT_MISSING);
	}

	if(b->htype != TYPE_oid && b->htype != TYPE_void)
		throw(MAL, "group.GRPaggr_count", SEMANTIC_TYPE_ERROR "(v)oid head required\n");
	if ((e = BATdescriptor(*eid)) == NULL) {
		BBPreleaseref(b->batCacheid);
		throw(MAL, "group.count", RUNTIME_OBJECT_MISSING);
	}
	if(e->htype != TYPE_oid && e->htype != TYPE_void)
		throw(MAL, "group.GRPaggr_count", SEMANTIC_TYPE_ERROR "(v)oid head required\n");

	bn = BATnew(e->htype, TYPE_wrd, BATcount(e));
	if (bn == NULL){
		BBPreleaseref(b->batCacheid);
		BBPreleaseref(e->batCacheid);
		throw(MAL, "group.count", MAL_MALLOC_FAIL);
	}
	btt = b->ttype;
	bt_nil = ATOMnilptr(b->ttype);

	/* init: set all sums to zero */
	bn->tsorted = bn->hsorted = 0;
	bn->trevsorted = bn->hrevsorted = 0;
	bn->T->nonil = 1;
	ALIGNsetH(bn, e);
	ei = bat_iterator(e);
	bi = bat_iterator(b);
	bni = bat_iterator(bn);
	if (BAThordered(e)) {
		min = *(oid *) BUNhead(ei, BUNfirst(e));
		BATloop(e, p, q) {
			if (BUNfastins(bn, BUNhead(ei, p), &zero) == NULL) {
				BBPreclaim(bn);
				throw(MAL, "group.count", OPERATION_FAILED );
			}
		}
		max = *(oid *) BUNhead(ei, BUNlast(e) - 1);
	} else {
		min = max = *(oid *) BUNhead(ei, BUNfirst(e));
		BATaccessBegin(e, USE_HEAD, MMAP_SEQUENTIAL);
		BATloop(e, p, q) {
			if (BUNfastins(bn, BUNhead(ei, p), &zero) == NULL) {
				BBPreclaim(bn);
				throw(MAL, "group.count", OPERATION_FAILED);
			}
			i = *(oid *) BUNhead(ei, p);
			if (i < min)
				min = i;
			else if (i > max)
				max = i;
		}
		BATaccessEnd(e, USE_HEAD, MMAP_SEQUENTIAL);
	}
	range = max - min + 1;

	/* scan b, and add increment totals for true values */
	if (range > SMALL_AGGR_MAX) {
		if (*ignore_nils && !b->T->nonil) {
			ALGODEBUG fprintf(stderr, "#CMDaggr_count: range(=" OIDFMT ") > SMALL_AGGR_MAX(=%d)  =>  large_aggr_count(if (ATOMcmp(btt,t,bt_nil)))\n", range, SMALL_AGGR_MAX);

			@:large_aggr_count(if(ATOMcmp(btt,t,bt_nil)))@
		} else {
			ALGODEBUG fprintf(stderr, "#CMDaggr_count: range(=" OIDFMT ") > SMALL_AGGR_MAX(=%d)  =>  large_aggr_count()\n", range, SMALL_AGGR_MAX);

			@:large_aggr_count()@
		}
	} else {
		if (*ignore_nils && !b->T->nonil) {
			ALGODEBUG fprintf(stderr, "#CMDaggr_count: range(=" OIDFMT ") <= SMALL_AGGR_MAX(=%d)  =>  small_aggr_count(if (ATOMcmp(btt,t,bt_nil)))\n", range, SMALL_AGGR_MAX);

			@:small_aggr_count(if(ATOMcmp(btt,t,bt_nil)))@
		} else {
			ALGODEBUG fprintf(stderr, "#CMDaggr_count: range(=" OIDFMT ") <= SMALL_AGGR_MAX(=%d)  =>  small_aggr_count()\n", range, SMALL_AGGR_MAX);

			@:small_aggr_count()@
		}
	}
	BBPkeepref(*retval = bn->batCacheid);
	BBPreleaseref(b->batCacheid);
	BBPreleaseref(e->batCacheid);
	return MAL_SUCCEED;
}

group_export str GRPsize(int *retval, int *bid, int *eid);
str
GRPsize(int *retval, int *bid, int *eid)
{
	BAT *bn, *b = NULL, *e = NULL;
	BATiter ei, bi, bni;
	wrd zero = 0;
	BUN p, q, r;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "group.size", RUNTIME_OBJECT_MISSING);
	}

	if(b->htype != TYPE_oid && b->htype != TYPE_void)
		throw(MAL, "group.GRPsize", SEMANTIC_TYPE_ERROR "(v)oid head required\n");
	if ((e = BATdescriptor(*eid)) == NULL) {
		BBPreleaseref(b->batCacheid);
		throw(MAL, "group.size", RUNTIME_OBJECT_MISSING);
	}
	if(e->htype != TYPE_oid && e->htype != TYPE_void)
		throw(MAL, "group.GRPsize", SEMANTIC_TYPE_ERROR "(v)oid head required\n");

	bn = BATnew(e->htype, TYPE_wrd, BATcount(e));
	if (bn == NULL){
		BBPreleaseref(b->batCacheid);
		BBPreleaseref(e->batCacheid);
		throw(MAL, "group.size", MAL_MALLOC_FAIL);
	}
	/* init: set all sums to zero */
	bn->tsorted = bn->hsorted = 0;
	bn->trevsorted = bn->hrevsorted = 0;
	bn->T->nonil = 1;
	ALIGNsetH(bn, e);
	ei = bat_iterator(e);
	bi = bat_iterator(b);
	bni = bat_iterator(bn);
	BATaccessBegin(e, USE_HEAD, MMAP_SEQUENTIAL);
	BATloop(e, p, q) {
		if (BUNfastins(bn, BUNhead(ei, p), &zero) == NULL) {
			BBPreclaim(bn);
			throw(MAL, "group.count", OPERATION_FAILED);
		}
	}
	BATaccessEnd(e, USE_HEAD, MMAP_SEQUENTIAL);
	/* scan b, and add increment totals for true values */
	if (BATprepareHash(bn)) {
		BBPreclaim(bn);
		throw(MAL, "group.count", MAL_MALLOC_FAIL);
	}
	BATaccessBegin(b, USE_HEAD|USE_TAIL, MMAP_SEQUENTIAL);
	if (BAThordered(b) && BAThdense(bn))
		BATaccessBegin(bn, USE_TAIL, MMAP_SEQUENTIAL);
	else
		BATaccessBegin(bn, USE_HEAD|USE_HHASH|USE_TAIL, MMAP_WILLNEED);
	BATloop(b, p, q) {
		if (*(bit *) BUNtloc(bi, p) == TRUE) {
			oid *h = (oid *) BUNhead(bi, p);

			BUNfndOID(r, bni, h);
			if (r != BUN_NONE) {
				wrd *dst = (wrd *) BUNtloc(bni, r);

				(*dst)++;
			}
		}
	}
	if (BAThordered(b) && BAThdense(bn))
		BATaccessEnd(bn, USE_TAIL, MMAP_SEQUENTIAL);
	else
		BATaccessEnd(bn, USE_HEAD|USE_HHASH|USE_TAIL, MMAP_WILLNEED);
	BATaccessEnd(b, USE_HEAD|USE_TAIL, MMAP_SEQUENTIAL);
	BBPkeepref(*retval = bn->batCacheid);
	BBPreleaseref(b->batCacheid);
	BBPreleaseref(e->batCacheid);
	return MAL_SUCCEED;
}

/*
 * @-
 * The window aggregate functions
 */
@= windowsum
group_export str GRPslidingsum_@1(int *retval, int *bid, int  *size, int *shift);
str GRPslidingsum_@1(int *retval, int *bid, int  *size, int *shift)
{
	BATiter bi;
	BAT *b, *bn;
	@2 sum;
	oid o= oid_nil;
	BUN p, q;
	int i;

	if( *shift <=0){
		throw(MAL, "group.sum", ILLEGAL_ARGUMENT " Illegal shift value");
	}
		
	if( (b= BATdescriptor(*bid)) == NULL ){
		throw(MAL, "group.sum", RUNTIME_OBJECT_MISSING);
	}
	if(b->htype != TYPE_oid && b->htype != TYPE_void)
		throw(MAL, "group.GRPwindowsum_@1", SEMANTIC_TYPE_ERROR "(v)oid head required\n");

	/* init: set all sums to zero */
	bn= BATnew( TYPE_void, TYPE_@2, BATcount(b)/ *size +1);
	if ( bn == NULL){
		BBPreleaseref(b->batCacheid);
		throw(MAL, "group.sum", RUNTIME_OBJECT_MISSING);
	}

	i = *size;
	sum =0;
	bi = bat_iterator(b);
	BATaccessBegin(b, USE_TAIL, MMAP_SEQUENTIAL);
	BATloop(b, p, q) {
		sum += *(@1*) BUNtail(bi,p);
		if (--i == 0){
			BUNfastins(bn, &o, &sum);
			/* slide here */
			if (*size != *shift ){
				p -= (*size-*shift);
			}
			i = *size;
			sum =0;
		}
	}
	BATaccessEnd(b, USE_TAIL, MMAP_SEQUENTIAL);
	if(i != *size)
		BUNfastins(bn, &o, &sum);

	bn->tsorted = bn->hsorted = 0;
	bn->trevsorted = bn->hrevsorted = 0;
	BATseqbase(bn,0);

	*retval= bn->batCacheid;
	BBPkeepref(*retval);
	BBPreleaseref(b->batCacheid);
	return MAL_SUCCEED;
}
group_export str GRPwindowsum_@1(int *retval, int *bid, int  *size);
str GRPwindowsum_@1(int *retval, int *bid, int  *size){
	return GRPslidingsum_@1(retval,bid,size,size);
}
@
@c
@:windowsum(bte,lng)@
@:windowsum(sht,lng)@
@:windowsum(int,lng)@
@:windowsum(lng,lng)@
@:windowsum(oid,lng)@
@:windowsum(wrd,lng)@
@:windowsum(flt,dbl)@
@:windowsum(dbl,dbl)@
