# The contents of this file are subject to the MonetDB Public License
# Version 1.1 (the "License"); you may not use this file except in
# compliance with the License. You may obtain a copy of the License at
# http://www.monetdb.org/Legal/MonetDBLicense
#
# Software distributed under the License is distributed on an "AS IS"
# basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
# License for the specific language governing rights and limitations
# under the License.
#
# The Original Code is the MonetDB Database System.
#
# The Initial Developer of the Original Code is CWI.
# Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
# Copyright August 2008-2015 MonetDB B.V.
# All Rights Reserved.

module bat;
#TO BE MADE HEADLESS PLAN

command reverse(b:bat[:any_1,:any_2]) :bat[:any_2,:any_1] 
address BKCreverse
comment "Returns the reverse view of a BAT (head is tail and tail is head).
        BEWARE  no copying is involved; input and output refer to the 
        same object!";

command mirror(b:bat[:any_1,:any_2]) :bat[:any_1,:any_1] 
address BKCmirror
comment "Returns the head-mirror image of a BAT (two head columns).";

command order(b:bat[:any_1,:any_2]) :bat[:any_1,:any_2] 
address BKCorder
comment "Sorts the BAT itself on the head, in place. ";
command orderReverse(b:bat[:any_1,:any_2]) :bat[:any_1,:any_2] 
address BKCorder_rev
comment "Reverse sorts the BAT itself on the head, in place. ";

command revert(b:bat[:any_1,:any_2]) :bat[:any_1,:any_2] 
address BKCrevert
comment "Puts all BUNs in a BAT in reverse order.  (Belongs to the 
        BAT sequence module)";

command getHeadType(b:bat[:any_1,:any_2] ) :str 
address BKCgetHeadType
comment "Returns the type of the head column of a BAT, as an integer type number.";

command insert(b:bat[:any_1,:any_2], src:bat[:any_1,:any_2]):bat[:any_1,:any_2]
address BKCinsert_bat
comment "Insert all BUNs of the second BAT into the first.";

command insert(b:bat[:any_1,:any_2], src:bat[:any_1,:any_2], force:bit):bat[:any_1,:any_2]
address BKCinsert_bat_force
comment "Insert all BUNs of the second BAT into the first.";

command insert(b:bat[:any_1,:any_2], h:any_1, t:any_2) :bat[:any_1,:any_2]
address BKCinsert_bun
comment "Insert one BUN[h,t] in a BAT.";

command insert(b:bat[:any_1,:any_2], h:any_1, t:any_2, force:bit) :bat[:any_1,:any_2]
address BKCinsert_bun_force
comment "Insert one BUN[h,t] in a BAT.";

command replace(b:bat[:any_1, :any_2], src:bat[:any_1,:any_2]) :bat[:any_1,:any_2]
address BKCreplace_bat
comment "Perform replace for all BUNs of the second BAT into the first.";

command replace(b:bat[:any_1, :any_2], src:bat[:any_1,:any_2], force:bit) :bat[:any_1,:any_2]
address BKCreplace_bat_force
comment "Perform replace for all BUNs of the second BAT into the first.";

command replace(b:bat[:any_1, :any_2], h:any_1, t:any_2) :bat[:any_1,:any_2]
address BKCreplace_bun
comment "Replace the tail value of one BUN that has some head value.";

command replace(b:bat[:any_1, :any_2], h:any_1, t:any_2, force:bit) :bat[:any_1,:any_2]
address BKCreplace_bun_force
comment "Replace the tail value of one BUN that has some head value.";
command append( i:bat[:any_1,:any_2], u:bat[:any_1,:any_2] ) :bat[:any_1,:any_2]
address BKCappend_wrap
comment "append the content of u to i";

command append( i:bat[:any_1,:any_2], u:bat[:any_1,:any_2], force:bit ) :bat[:any_1,:any_2]
address BKCappend_force_wrap
comment "append the content of u to i";

command append(i:bat[:any_1,:any_2], u:any_2, force:bit):bat[:any_1,:any_2]
address BKCappend_val_force_wrap
comment "append the value u to i";

command inplace( o:bat[:any_1,:any_2], id:oid, t:any_2) :bat[:oid,:any_2]
address BKCbun_inplace
comment "inplace replace values on the given locations";

command inplace( o:bat[:any_1,:any_2], d:bat[:any_1,:any_2]) :bat[:any_1,:any_2]
address BKCbat_inplace
comment "inplace replace values on the given locations";

command inplace( o:bat[:any_1,:any_2], id:oid, t:any_2, force:bit) :bat[:oid,:any_2]
address BKCbun_inplace_force
comment "inplace replace values on the given locations";

command inplace( o:bat[:any_1,:any_2], d:bat[:any_1,:any_2], force:bit) :bat[:any_1,:any_2]
address BKCbat_inplace_force
comment "inplace replace values on the given locations";

command delete(b:bat[:any_1, :any_2], h:any_1, t:any_2) :bat[:any_1,:any_2]
address BKCdelete_bun
comment "Delete one specific BUN.";

command delete(b:bat[:any_1, :any_2], h:any_1) :bat[:any_1,:any_2]
address BKCdelete
comment "Delete all BUNs with a certain head value.";

command delete(b:bat[:any_1, :any_2]) :bat[:any_1,:any_2]
address BKCdelete_all
comment "Delete all BUNs in a BAT.";

command delete(b:bat[:any_1, :any_2], src:bat[:any_1,:any_2]) :bat[:any_1,:any_2]
address BKCdelete_bat_bun
comment "Delete from the first BAT all BUNs with a corresponding BUN 
        in the second.";

command getAlpha(b:bat[:any_1,:any_2]) :bat[:any_1,:any_2] 
address BKCgetAlpha
comment "Obtain the list of BUNs added";
command getDelta(b:bat[:any_1,:any_2]) :bat[:any_1,:any_2] 
address BKCgetDelta
comment "Obtain the list of BUNs deleted";

#END OF HEADLESS PLAN

command attach(tt:int, heapfile:str) :bat[:oid,:any_1]
address BKCattach
comment "Returns a new BAT with dense head and tail of the given type and uses
        the given file to initialize the tail. The file will be owned by the
        server.";

command densebat(sz:wrd) :bat[:oid,:oid]
address BKCdensebat
comment "Creates a new [void,void] BAT of size 'sz'.";
command info ( b:bat[:oid,:any_2]) (:bat[:oid,:str], :bat[:oid,:str])
address BKCinfo
comment "Produce a table containing information about a BAT in [attribute,value] format. 
        It contains all properties of the BAT record. See the BAT documentation 
        in GDK for more information.";

command getSize ( b:bat[:oid,:any_1]) :lng
address BKCgetSize
comment "Calculate the actual size of the BAT descriptor, heaps, hashes and imprint indices in bytes
         rounded to the memory page size (see bbp.getPageSize()).";

command getCapacity(b:bat[:oid,:any_2]):lng 
address BKCgetCapacity
comment "Returns the current allocation size (in max number of elements) of a BAT.";

command getColumnType( b:bat[:oid,:any_2] ) :str 
address BKCgetColumnType 
comment "Returns the type of the tail column of a BAT, as an integer type number.";

command getRole ( bid:bat[:oid,:any_2] ) :str 
address BKCgetRole
comment "Returns the rolename of the head column of a BAT.";

command setKey( b:bat[:oid,:any_2], mode:bit) :bat[:oid,:any_2] 
address BKCsetkey
comment "Sets the 'key' property of the tail column to 'mode'. In 'key' mode, 
        the kernel will silently block insertions that cause a duplicate 
        entries in the head column. KNOWN BUG:when 'key' is set to TRUE, this 
		function does not automatically eliminate duplicates. ";

command isaKey( b:bat[:oid,:any_1]) :bit 
address BKCgetKey
comment "Return whether the column tail values are unique (key).";

command setAccess( b:bat[:oid,:any_1], mode:str) :bat[:oid,:any_1]
address BKCsetAccess
comment "Try to change the update access priviliges 
	to this BAT. Mode:
	 r[ead-only]      - allow only read access.
	 a[append-only]   - allow reads and update.
	 w[riteable]      - allow all operations.
	 BATs are updatable by default. On making a BAT read-only, 
     all subsequent updates fail with an error message.
	 Returns the BAT itself.";

command getAccess( b:bat[:oid,:any_1]):str 
address BKCgetAccess
comment "Return the access mode attached to this BAT as a character.";

command getSequenceBase( b:bat[:oid,:any_1]):oid 
address BKCgetSequenceBase
comment "Get the sequence base for the void column of a BAT.";

command isSorted(b:bat[:oid,:any_1]) :bit 
address BKCisSorted
comment "Returns true if BAT values are ordered.";
command isSortedReverse(b:bat[:oid,:any_1]) :bit 
address BKCisSortedReverse
comment "Returns true if BAT values are reversely ordered.";

command append(i:bat[:oid,:any_1], u:any_1):bat[:oid,:any_1]
address BKCappend_val_wrap
comment "append the value u to i";

command setName ( b:bat[:oid,:any_2] , s:str) :void
address BKCsetName
comment "Give a logical name to a BAT. ";

command getName ( b:bat[:oid,:any_2]) :str 
address BKCgetBBPname
comment "Gives back the logical name of a BAT.";

command setRole( b:bat[:oid,:any_2], h:str, t:str) :void
address BKCsetRole
comment "Give a logical name to the columns of a BAT.";

command setColumn( b:bat[:oid,:any_2], t:str) :void
address BKCsetColumn
comment "Give a logical name to the tail column of a BAT.";
command setColumn( b:bat[:oid,:any_2], h:str, t:str) :void
address BKCsetColumns
comment "Give both columns of a BAT a new name.";


command isTransient( b:bat[:oid,:any_2]) :bit 
address BKCisTransient;
command setTransient( b:bat[:oid,:any_2]) :void
address BKCsetTransient
comment "Make the BAT transient.  Returns 
	boolean which indicates if the
BAT administration has indeed changed.";

command isPersistent( b:bat[:oid,:any_2]) :bit 
address BKCisPersistent;
command setPersistent( b:bat[:oid,:any_2],f:bit) :void
address BKCpersists
comment "Backward compatibility";
command setPersistent( b:bat[:oid,:any_2]) :void
address BKCsetPersistent
comment "Make the BAT persistent.";

command save(nme:bat[:oid,:any_2]) :void
address BKCsave2;

command save(nme:str) :bit 
address BKCsave
comment "Save a BAT to storage, if it was loaded and dirty.  
        Returns whether IO was necessary.  Please realize that 
	calling this function violates the atomic commit protocol!!";


command load(name:str) :bat[:oid,:any_2] 
address BKCload
comment "Load a particular BAT from disk";

command unload(name:str) :bit 
address BKCunload
comment "Swapout a BAT to disk. Transient BATs can also be swapped out.     
        Returns whether the unload indeed happened. ";

command setCold(b:bat[:oid,:any_1]) :void 
address BKCsetColdBAT
comment "Makes a BAT very cold for the BBP. The chance of being choses 
        for swapout is big, afterwards.";
command setHot(b:bat[:oid,:any_2]) :void 
address BKCsetHotBAT
comment "Makes a BAT very hot for the BBP. The chance of being chosen for 
        swapout is small, afterwards.";

command setMemoryMap(b:bat[:oid,:any_2], head_mode:int, tail_mode:int, hheap_mode:int, theap_mode:int) :bit 
address BKCmmap
comment "For each individual heap, you can change the allocation mode 
        to either STORE_MEM or STORE_MMAP. Passing an int(nil) means:
        no change.  Changing a dirty STORE_MEM heap into STORE_MMAP, 
	will cause a BAT save (this has to happen before the heap can 
        be mapped into virtual memory). These modes are persistent. ";

command setMemoryMap(b:bat[:oid,:any_2], mode:int):bit 
address BKCmmap2
comment "Alias for mmap(b, mode, mode, mode, mode)";

command setHash(b:bat[:oid,:any_2]):bit 
address BKCsetHash
comment "Create a hash structure on the column";

command setImprints(b:bat[:oid,:any_2]):bit 
address BKCsetImprints
comment "Create n imprints structure on the column";

command isSynced (b1:bat[:oid,:any_2], b2:bat[:oid,:any_4]) :bit 
address BKCisSynced
comment "Tests whether two BATs are synced or not. ";

command shrink(b:bat[:oid,:any_1],del:bat[:oid,:oid]):bat[:oid,:any_1]
address BKCshrinkBAT
comment "Shrink the BAT based on a list of entries identified as to-be-deleted";

command shrinkMap(b:bat[:oid,:any_1],del:bat[:oid,:oid]):bat[:oid,:oid]
address BKCshrinkBATmap
comment "Derive the oid mapping for shrink BAT based on list of to-be-deleted";

command reuse(b:bat[:oid,:any_1],del:bat[:oid,:oid]):bat[:oid,:any_1]
address BKCreuseBAT
comment "Shuffle the values around to restore a dense representation of buns.";

command reuseMap(b:bat[:oid,:any_1],del:bat[:oid,:oid]):bat[:oid,:oid]
address BKCreuseBATmap
comment "Derive the oid mapping for reuse BAT based on list of to-be-deleted";

command mergecand(a:bat[:oid,:oid],b:bat[:oid,:oid]) :bat[:oid,:oid]
address BKCmergecand
comment "Merge two candidate lists into one";

command intersectcand(a:bat[:oid,:oid],b:bat[:oid,:oid]) :bat[:oid,:oid]
address BKCintersectcand
comment "Intersect two candidate lists into one";
