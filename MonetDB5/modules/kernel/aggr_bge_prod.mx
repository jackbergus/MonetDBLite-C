@/
The contents of this file are subject to the MonetDB Public License
Version 1.1 (the "License"); you may not use this file except in
compliance with the License. You may obtain a copy of the License at
http://www.monetdb.org/Legal/MonetDBLicense

Software distributed under the License is distributed on an "AS IS"
basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations
under the License.

The Original Code is the MonetDB Database System.

The Initial Developer of the Original Code is CWI.
Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
Copyright August 2008-2012 MonetDB B.V.
All Rights Reserved.
@

@f aggr_bge_prod

@c
/*
 * @a S. Manegold
 * @v 1.0
 * @+ Aggregates Module
 *
 *
 * @+ Implementation
 * These implementations need just one scan and a simple hash-maintained data
 * structure to compute a group of common aggregates.
 */
#include "monetdb_config.h"
#include <gdk.h>
#include "aggr.h"
#include "aggr_bge_prod.h"
#include "aggr_be_prod.h"

/*
 * @- Result initialization
 * //	init_result
 * 	@1:	tail-type:	bte/sht/int/wrd/lng/flt/dbl / any / void
 *
 */
@include aggr_ri.mx
@c
/*
 * @- Product
 */
/*	aggrX3_prod3
		e-void-head	e-oid-head	e-oid-head	e-oid-head
		void-lookup	array-lookup	scan-lookup	hash-lookup

	@1:	0		1		0		0		use prods-array?
	@2:	0		0		0		1		do BATprepareHash?
	@3:	BUNfndVOID	CHKrange	SCANfndOID	HASHfnd_oid	lookup
	@4:	var		loc		loc		loc		e/bn-head-access

	@5:	"BUNhloc(b,p)"	for  (oid) b-head-type,		b-head access
		"&bhsb; bhsb++" for (void) b-head-type

	@6:	bte / sht / int / wrd / lng / flt / dbl		b-tail-type

#	not used any more as the result-type needs an argument
#	@7:	"loc" for fixsized b-tail-type,			b-tail-access
#		"var" for varsized b-tail-type			(only loc used currently)

	@7:	BUNt@7(bn,r)	BUNt@7(bn,r)	&prods[(*(oid*)h)-min]
								*dst: prod in-place or in prods-array ?
	@8:	<empty> / if (w >= base && w < end)		check head (oid) ranges in case b & g
								are not void-headed and aligned
	@9:	result type
	@[10]:		r-off		(*(oid*)h)-min	index in hit array
*/
@= aggrX3_prod3
	ALGODEBUG fprintf(stderr, "#aggrX3_prod3(@1,@2,@3,@4,@5,@6,@7,@8,@9,@[10]);\n");
#if @1
	if (range > 0) {
		/* create tmp. prods array */
		oid i;
		prods = (@9*) GDKmalloc(range*sizeof(@9));
		if (prods == NULL) {
			GDKerror("aggrX3_prod3(@1,@2,@3,@4,@5,@6,@6,@7,@8,@9,@[10]): prods = GDKmalloc("OIDFMT"*"SZFMT") failed", range, sizeof(@9));
			BBPreclaim(bn);
			return GDK_FAIL;
		}
		for (i = 0; i < range; i++)
			prods[i] = (@9) 1;
	}
#endif
#if @2
	if (BATprepareHash(bn)) {
		GDKerror("aggrX3_prod3(@1,@2,@3,@4,@5,@6,@6,@7,@8,@9,@[10]): BATprepareHash(bn) failed");
#if @1
		if (prods)
			GDKfree(prods);
#endif
		BBPreclaim(bn);
		return GDK_FAIL;
	}
#endif
	hit = (bit*) GDKzalloc(slots*sizeof(bit));
	if (hit == NULL) {
		GDKerror("aggrX3_prod3(@1,@2,@3,@4,@5,@6,@7,@8,@9,@[10]): hit = GDKzalloc("OIDFMT"*"SZFMT") failed", slots, sizeof(bit));
#if @1
		if (prods)
			GDKfree(prods);
#endif
		BBPreclaim(bn);
		return GDK_FAIL;
	}
	/* scan b & g, and add values to prods in-place or in prods-array */
	base = BUNfirst(g);
	gh_offset = (ssize_t) base - (ssize_t) g->hseqbase;
	gt_offset = (ssize_t) g->tseqbase - (ssize_t) g->hseqbase;
	end = base + BATcount(g);
	(void) end;		/* keep compilers happy */
	bhsb = b->hseqbase;
	if (BATtdense(g)) {
		@:aggrX3_prod3_body(@1,@2,@3,@4,@5,@6,@7,@8,@9,@[10],oid hh = (oid) (gt_offset + v); oid *h = &hh)@
	} else {
		@:aggrX3_prod3_body(@1,@2,@3,@4,@5,@6,@7,@8,@9,@[10],oid *h = (oid*) Tloc(g, w))@
	}
#if @1
	if (prods) {
		/* copy prods array to final result */
		BATloop(bn, p, q) {
			oid h = (*(oid*) BUNh@4(bni,p)) - min;
			@9 *dst = (@9*)BUNtloc(bni, p);
			if (hit[h] == 0) {
				*dst = @9_nil;
			} else {
				*dst = prods[h];
			}
		}
		GDKfree(prods);
	}
#else
	{
		BUN yy = 0;
		BATloop(bn, p, q) {
			@9 *dst = (@9*)BUNtloc(bni, p);
			if (hit[yy] == 0) {
				*dst = @9_nil;
			}
			yy++;
		}
	}
#endif
	if (hit)
		GDKfree(hit);
@
@c
/*	aggrX3_prod3_body
	@[11]:	oid hh = (oid) (gt_offset + v); oid *h = &hh		g tail value calculation
		oid *h = (oid*) Tloc(g, w)				g tail value lookup
*/
@= aggrX3_prod3_body
	ALGODEBUG fprintf(stderr, "#aggrX3_prod3_oid_body(@1,@2,@3,@4,@5,@6,@7,@8,@9,@[10],@[11]);\n");
	if (b->T->nonil) {
		BATloop(b, p, q) {
			@6 *t = (@6*) BUNtloc(bi,p);
			oid v = *(oid*) @5;

			w = (BUN) (gh_offset + v);
			@8 {
				@[11];

				@3(r, bni, (oid*)h);
				if (r != BUN_NONE) {
					@9 *dst = (@9*) @7;
					*dst *= (@9) *t;
					hit[@[10]] = 1;
				}
			}
		}
	} else {
		BATloop(b, p, q) {
			@6 *t = (@6*) BUNtloc(bi,p);
			oid v = *(oid*) @5;

			w = (BUN) (gh_offset + v);
			@8 {
				@[11];

				@3(r, bni, (oid*)h);
				if (r != BUN_NONE) {
					@9 *dst = (@9*) @7;
					if (*dst != @9_nil) {
						if (*t == @6_nil) {
							*dst = @9_nil;
						} else {
							*dst *= (@9) *t;
							hit[@[10]] = 1;
						}
					}
				}
			}
		}
	}
@
@c

/*	arithprod3
	@6:	bte / sht / int / wrd / lng / flt / dbl		b-tail-type

#	not used any more
#	@7:	"loc" for fixsized b-tail-type,		b-tail-access
#		"var" for varsized b-tail-type		(only loc used currently)

	@9:	result type
*/
@= arithprod3_h
int
CMDaggrX3_prod3_@1_@2(BAT **ret, BAT *b, BAT *g, BAT *e);
@= arithprod3_c

static int
aggrX3_prod3_@1_@2_EarrayBvoidGvoid (BAT *bn, BAT *b, BAT *g, BAT *e, oid range, oid min, oid max)
{
	@2 *prods = NULL;
	bit *hit = NULL;
	BUN slots = range;
	BUN p, q, r;
	oid bhsb;
	BUN base, end, w;
	ssize_t gh_offset, gt_offset;
	BATiter bni = bat_iterator(bn), bi = bat_iterator(b);

	ALGODEBUG fprintf(stderr, "#aggrX3_prod3_@1_@2_EarrayBvoidGvoid(bn=%s,b=%s,g=%s,e=%s,range=" OIDFMT ",min=" OIDFMT ",max=" OIDFMT ");\n",
					BATgetId(bn),BATgetId(b),BATgetId(g),BATgetId(e),
					range,min,max);
	@:aggrX3_prod3(1,0,CHKrange,loc,&bhsb;bhsb++,@1,&prods[(*(oid*)h)-min],,@2,(*(oid*)h)-min)@

	return GDK_SUCCEED;
}

int
CMDaggrX3_prod3_@1_@2(BAT **ret, BAT *b, BAT *g, BAT *e)
{
	BAT *bn;
	BATiter bni, bi = bat_iterator(b);
	@2 zero = (@2) 1, *prods = NULL;
	bit *hit = NULL;
	BUN slots, off;
	BUN p, q, r;
	oid range;
	oid min, max;
	oid bhsb;
	BUN base, end, w;
	ssize_t gh_offset, gt_offset;

	ALGODEBUG fprintf(stderr, "#CMDaggrX3_prod3_@1_@2(b=%s,g=%s,e=%s);\n",
		BATgetId(b),BATgetId(g),BATgetId(e));
/*	ERRORcheck((BATcount(b)!=BATcount(g)), "CMDaggrX3_prod3_@1: BATs b & g must be of equal size.\n");	*/
	ERRORcheck((g->htype == TYPE_void) && (g->hseqbase == oid_nil) && (BATcount(g) > 0), "CMDaggrX3_prod3_@1: head of BAT g must not be nil.\n");

	if (g->hseqbase == oid_nil || !BAThdense(g) || !BAThordered(b) || !g->hkey) {
		BAT *gb = BATjoin(BATmirror(g),b,BUN_NONE);
		int rtrn = CMDaggrX3_prod_@1_@2(ret, gb, e);
		BBPunfix(gb->batCacheid);
		return rtrn;
	}

	bn = BATnew(TYPE_void, TYPE_@2, BATcount(e));
	if( bn == NULL) {
		GDKerror("CMDaggrX3_prod3_@1_@2(): BATnew() failed");
		return GDK_FAIL;
	}

	/* init: set all prods to zero and calculate min/max oid */
	@:init_result(@2)@
	bni = bat_iterator(bn);
	off = BUNfirst(bn);
	*ret = bn;
	range = max - min + 1;

	/* scan b & g, and calculate prods */
	slots = BATcount(e);
	if (slots == 0) {
		/* empty extend => empty result */
		*ret = bn;
		return GDK_SUCCEED;
	}
	if (e->htype == TYPE_void) {
		/* void lookup */
		if (BAThdense(b)) {
			if ((BAThdense(g))&&(BATcount(b)==BATcount(g))&&(b->hseqbase==g->hseqbase)) {
				@:aggrX3_prod3(0,0,BUNfndVOID,var,&bhsb;bhsb++,@1,BUNtloc(bni,r),,@2,r-off)@
			} else {
				@:aggrX3_prod3(0,0,BUNfndVOID,var,&bhsb;bhsb++,@1,BUNtloc(bni,r),if (w >= base && w < end),@2,r-off)@
			}
		} else {
			@:aggrX3_prod3(0,0,BUNfndVOID,var,BUNhloc(bi,p),@1,BUNtloc(bni,r),if (w >= base && w < end),@2,r-off)@
		}
	/* e->htype == TYPE_oid */
	} else if (range <= SMALL_AGGR_MAX) {
		/* array lookup */
		slots = range;
		if (BAThdense(b)) {
			if ((BAThdense(g))&&(BATcount(b)==BATcount(g))&&(b->hseqbase==g->hseqbase)) {
				return aggrX3_prod3_@1_@2_EarrayBvoidGvoid (bn, b, g, e, range, min, max);
			} else {
				@:aggrX3_prod3(1,0,CHKrange,loc,&bhsb;bhsb++,@1,&prods[(*(oid*)h)-min],if (w >= base && w < end),@2,(*(oid*)h)-min)@
			}
		} else {
			@:aggrX3_prod3(1,0,CHKrange,loc,BUNhloc(bi,p),@1,&prods[(*(oid*)h)-min],if (w >= base && w < end),@2,(*(oid*)h)-min)@
		}
	} else if (BATcount(e) <= SCAN_AGGR_MAX) {
		/* scan lookup */
		SCAN_aggr_init;
		if (BAThdense(b)) {
			if ((BAThdense(g))&&(BATcount(b)==BATcount(g))&&(b->hseqbase==g->hseqbase)) {
				@:aggrX3_prod3(0,0,SCANfndOID,loc,&bhsb;bhsb++,@1,BUNtloc(bni,r),,@2,r-off)@
			} else {
				@:aggrX3_prod3(0,0,SCANfndOID,loc,&bhsb;bhsb++,@1,BUNtloc(bni,r),if (w >= base && w < end),@2,r-off)@
			}
		} else {
			@:aggrX3_prod3(0,0,SCANfndOID,loc,BUNhloc(bi,p),@1,BUNtloc(bni,r),if (w >= base && w < end),@2,r-off)@
		}
	} else if (BATtordered(g)&BAThordered(e)) {
		/* merge lookup */
		MERGE_aggr_init;
		if (BAThdense(b)) {
			if ((BAThdense(g))&&(BATcount(b)==BATcount(g))&&(b->hseqbase==g->hseqbase)) {
				@:aggrX3_prod3(0,0,MERGEfndOID,loc,&bhsb;bhsb++,@1,BUNtloc(bni,r),,@2,r-off)@
			} else {
				@:aggrX3_prod3(0,0,MERGEfndOID,loc,&bhsb;bhsb++,@1,BUNtloc(bni,r),if (w >= base && w < end),@2,r-off)@
			}
		} else {
			@:aggrX3_prod3(0,0,MERGEfndOID,loc,BUNhloc(bi,p),@1,BUNtloc(bni,r),if (w >= base && w < end),@2,r-off)@
		}
	} else {
		/* hash lookup */
		if (BAThdense(b)) {
			if ((BAThdense(g))&&(BATcount(b)==BATcount(g))&&(b->hseqbase==g->hseqbase)) {
				@:aggrX3_prod3(0,1,HASHfnd_oid,loc,&bhsb;bhsb++,@1,BUNtloc(bni,r),,@2,r-off)@
			} else {
				@:aggrX3_prod3(0,1,HASHfnd_oid,loc,&bhsb;bhsb++,@1,BUNtloc(bni,r),if (w >= base && w < end),@2,r-off)@
			}
		} else {
			@:aggrX3_prod3(0,1,HASHfnd_oid,loc,BUNhloc(bi,p),@1,BUNtloc(bni,r),if (w >= base && w < end),@2,r-off)@
		}
	}

	return GDK_SUCCEED;
}
@
@= arithprod3_hc
@:arithprod3_@1(@2,@3)@
@= arithprod3
@:arithprod3_hc(@1,bte,bte)@
@:arithprod3_hc(@1,bte,sht)@
@:arithprod3_hc(@1,bte,int)@
@:arithprod3_hc(@1,bte,wrd)@
@:arithprod3_hc(@1,bte,lng)@
@:arithprod3_hc(@1,sht,sht)@
@:arithprod3_hc(@1,sht,int)@
@:arithprod3_hc(@1,sht,wrd)@
@:arithprod3_hc(@1,sht,lng)@
@:arithprod3_hc(@1,int,int)@
@:arithprod3_hc(@1,int,wrd)@
@:arithprod3_hc(@1,int,lng)@
@:arithprod3_hc(@1,wrd,wrd)@
@:arithprod3_hc(@1,wrd,lng)@
@:arithprod3_hc(@1,lng,wrd)@
@:arithprod3_hc(@1,lng,lng)@
@:arithprod3_hc(@1,flt,flt)@
@:arithprod3_hc(@1,flt,dbl)@
@:arithprod3_hc(@1,dbl,dbl)@
@
@h
@:arithprod3(h)@
@c
@:arithprod3(c)@

