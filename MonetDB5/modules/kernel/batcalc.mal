# The contents of this file are subject to the MonetDB Public License
# Version 1.1 (the "License"); you may not use this file except in
# compliance with the License. You may obtain a copy of the License at
# http://www.monetdb.org/Legal/MonetDBLicense
#
# Software distributed under the License is distributed on an "AS IS"
# basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
# License for the specific language governing rights and limitations
# under the License.
#
# The Original Code is the MonetDB Database System.
#
# The Initial Developer of the Original Code is CWI.
# Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
# Copyright August 2008-2012 MonetDB B.V.
# All Rights Reserved.

# This file was generated by using the script batcalc.mal.sh.

module batcalc;

command iszero(b:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatISZERO
comment "Unary check for zero over the tail of the bat";

command iszero(b:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatISZERO
comment "Unary check for zero over the tail of the bat";

command iszero(b:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatISZERO
comment "Unary check for zero over the tail of the bat";

command iszero(b:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatISZERO
comment "Unary check for zero over the tail of the bat";

command iszero(b:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatISZERO
comment "Unary check for zero over the tail of the bat";

command iszero(b:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatISZERO
comment "Unary check for zero over the tail of the bat";

command iszero(b:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatISZERO
comment "Unary check for zero over the tail of the bat";


command isnil(b:bat[:oid,:bit]) :bat[:oid,:bit]
address CMDbatISNIL
comment "Unary check for nil over the tail of the bat";

command isnil(b:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatISNIL
comment "Unary check for nil over the tail of the bat";

command isnil(b:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatISNIL
comment "Unary check for nil over the tail of the bat";

command isnil(b:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatISNIL
comment "Unary check for nil over the tail of the bat";

command isnil(b:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatISNIL
comment "Unary check for nil over the tail of the bat";

command isnil(b:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatISNIL
comment "Unary check for nil over the tail of the bat";

command isnil(b:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatISNIL
comment "Unary check for nil over the tail of the bat";

command isnil(b:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatISNIL
comment "Unary check for nil over the tail of the bat";

command isnil(b:bat[:oid,:oid]) :bat[:oid,:bit]
address CMDbatISNIL
comment "Unary check for nil over the tail of the bat";

command isnil(b:bat[:oid,:str]) :bat[:oid,:bit]
address CMDbatISNIL
comment "Unary check for nil over the tail of the bat";


command not(b:bat[:oid,:bit]) :bat[:oid,:bit]
address CMDbatNOT
comment "Return the Boolean inverse";
command not(b:bat[:oid,:bit],accum:int) :bat[:oid,:bit]
address CMDbatNOTaccum
comment "Return the Boolean inverse, reuse B if ACCUM is set";

command not(b:bat[:oid,:bte]) :bat[:oid,:bte]
address CMDbatNOT
comment "Unary bitwise not over the tail of the bat";
command not(b:bat[:oid,:bte],accum:int) :bat[:oid,:bte]
address CMDbatNOTaccum
comment "Unary bitwise not over the tail of the bat, reuse B if ACCUM is set";

command not(b:bat[:oid,:sht]) :bat[:oid,:sht]
address CMDbatNOT
comment "Unary bitwise not over the tail of the bat";
command not(b:bat[:oid,:sht],accum:int) :bat[:oid,:sht]
address CMDbatNOTaccum
comment "Unary bitwise not over the tail of the bat, reuse B if ACCUM is set";

command not(b:bat[:oid,:int]) :bat[:oid,:int]
address CMDbatNOT
comment "Unary bitwise not over the tail of the bat";
command not(b:bat[:oid,:int],accum:int) :bat[:oid,:int]
address CMDbatNOTaccum
comment "Unary bitwise not over the tail of the bat, reuse B if ACCUM is set";

command not(b:bat[:oid,:wrd]) :bat[:oid,:wrd]
address CMDbatNOT
comment "Unary bitwise not over the tail of the bat";
command not(b:bat[:oid,:wrd],accum:int) :bat[:oid,:wrd]
address CMDbatNOTaccum
comment "Unary bitwise not over the tail of the bat, reuse B if ACCUM is set";

command not(b:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatNOT
comment "Unary bitwise not over the tail of the bat";
command not(b:bat[:oid,:lng],accum:int) :bat[:oid,:lng]
address CMDbatNOTaccum
comment "Unary bitwise not over the tail of the bat, reuse B if ACCUM is set";


command sign(b:bat[:oid,:bte]) :bat[:oid,:bte]
address CMDbatSIGN
comment "Unary sign (-1,0,1) over the tail of the bat";

command sign(b:bat[:oid,:sht]) :bat[:oid,:bte]
address CMDbatSIGN
comment "Unary sign (-1,0,1) over the tail of the bat";

command sign(b:bat[:oid,:int]) :bat[:oid,:bte]
address CMDbatSIGN
comment "Unary sign (-1,0,1) over the tail of the bat";

command sign(b:bat[:oid,:wrd]) :bat[:oid,:bte]
address CMDbatSIGN
comment "Unary sign (-1,0,1) over the tail of the bat";

command sign(b:bat[:oid,:lng]) :bat[:oid,:bte]
address CMDbatSIGN
comment "Unary sign (-1,0,1) over the tail of the bat";

command sign(b:bat[:oid,:flt]) :bat[:oid,:bte]
address CMDbatSIGN
comment "Unary sign (-1,0,1) over the tail of the bat";

command sign(b:bat[:oid,:dbl]) :bat[:oid,:bte]
address CMDbatSIGN
comment "Unary sign (-1,0,1) over the tail of the bat";


command abs(b:bat[:oid,:bte]) :bat[:oid,:bte]
address CMDbatABS
comment "Unary abs over the tail of the bat";
command abs(b:bat[:oid,:bte],accum:int) :bat[:oid,:bte]
address CMDbatABSaccum
comment "Unary abs over the tail of the bat, reuse B if ACCUM is set";

command abs(b:bat[:oid,:sht]) :bat[:oid,:sht]
address CMDbatABS
comment "Unary abs over the tail of the bat";
command abs(b:bat[:oid,:sht],accum:int) :bat[:oid,:sht]
address CMDbatABSaccum
comment "Unary abs over the tail of the bat, reuse B if ACCUM is set";

command abs(b:bat[:oid,:int]) :bat[:oid,:int]
address CMDbatABS
comment "Unary abs over the tail of the bat";
command abs(b:bat[:oid,:int],accum:int) :bat[:oid,:int]
address CMDbatABSaccum
comment "Unary abs over the tail of the bat, reuse B if ACCUM is set";

command abs(b:bat[:oid,:wrd]) :bat[:oid,:wrd]
address CMDbatABS
comment "Unary abs over the tail of the bat";
command abs(b:bat[:oid,:wrd],accum:int) :bat[:oid,:wrd]
address CMDbatABSaccum
comment "Unary abs over the tail of the bat, reuse B if ACCUM is set";

command abs(b:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatABS
comment "Unary abs over the tail of the bat";
command abs(b:bat[:oid,:lng],accum:int) :bat[:oid,:lng]
address CMDbatABSaccum
comment "Unary abs over the tail of the bat, reuse B if ACCUM is set";

command abs(b:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatABS
comment "Unary abs over the tail of the bat";
command abs(b:bat[:oid,:flt],accum:int) :bat[:oid,:flt]
address CMDbatABSaccum
comment "Unary abs over the tail of the bat, reuse B if ACCUM is set";

command abs(b:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatABS
comment "Unary abs over the tail of the bat";
command abs(b:bat[:oid,:dbl],accum:int) :bat[:oid,:dbl]
address CMDbatABSaccum
comment "Unary abs over the tail of the bat, reuse B if ACCUM is set";


command -(b:bat[:oid,:bte]) :bat[:oid,:bte]
address CMDbatNEG
comment "Unary neg over the tail of the bat";
command -(b:bat[:oid,:bte],accum:int) :bat[:oid,:bte]
address CMDbatNEGaccum
comment "Unary neg over the tail of the bat, reuse B if ACCUM is set";

command -(b:bat[:oid,:sht]) :bat[:oid,:sht]
address CMDbatNEG
comment "Unary neg over the tail of the bat";
command -(b:bat[:oid,:sht],accum:int) :bat[:oid,:sht]
address CMDbatNEGaccum
comment "Unary neg over the tail of the bat, reuse B if ACCUM is set";

command -(b:bat[:oid,:int]) :bat[:oid,:int]
address CMDbatNEG
comment "Unary neg over the tail of the bat";
command -(b:bat[:oid,:int],accum:int) :bat[:oid,:int]
address CMDbatNEGaccum
comment "Unary neg over the tail of the bat, reuse B if ACCUM is set";

command -(b:bat[:oid,:wrd]) :bat[:oid,:wrd]
address CMDbatNEG
comment "Unary neg over the tail of the bat";
command -(b:bat[:oid,:wrd],accum:int) :bat[:oid,:wrd]
address CMDbatNEGaccum
comment "Unary neg over the tail of the bat, reuse B if ACCUM is set";

command -(b:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatNEG
comment "Unary neg over the tail of the bat";
command -(b:bat[:oid,:lng],accum:int) :bat[:oid,:lng]
address CMDbatNEGaccum
comment "Unary neg over the tail of the bat, reuse B if ACCUM is set";

command -(b:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatNEG
comment "Unary neg over the tail of the bat";
command -(b:bat[:oid,:flt],accum:int) :bat[:oid,:flt]
address CMDbatNEGaccum
comment "Unary neg over the tail of the bat, reuse B if ACCUM is set";

command -(b:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatNEG
comment "Unary neg over the tail of the bat";
command -(b:bat[:oid,:dbl],accum:int) :bat[:oid,:dbl]
address CMDbatNEGaccum
comment "Unary neg over the tail of the bat, reuse B if ACCUM is set";


command ++(b:bat[:oid,:bte]) :bat[:oid,:bte]
address CMDbatINCR
comment "Unary increment over the tail of the bat";
command ++(b:bat[:oid,:bte],accum:int) :bat[:oid,:bte]
address CMDbatINCRaccum
comment "Unary increment over the tail of the bat, reuse B if ACCUM is set";

command ++(b:bat[:oid,:sht]) :bat[:oid,:sht]
address CMDbatINCR
comment "Unary increment over the tail of the bat";
command ++(b:bat[:oid,:sht],accum:int) :bat[:oid,:sht]
address CMDbatINCRaccum
comment "Unary increment over the tail of the bat, reuse B if ACCUM is set";

command ++(b:bat[:oid,:int]) :bat[:oid,:int]
address CMDbatINCR
comment "Unary increment over the tail of the bat";
command ++(b:bat[:oid,:int],accum:int) :bat[:oid,:int]
address CMDbatINCRaccum
comment "Unary increment over the tail of the bat, reuse B if ACCUM is set";

command ++(b:bat[:oid,:wrd]) :bat[:oid,:wrd]
address CMDbatINCR
comment "Unary increment over the tail of the bat";
command ++(b:bat[:oid,:wrd],accum:int) :bat[:oid,:wrd]
address CMDbatINCRaccum
comment "Unary increment over the tail of the bat, reuse B if ACCUM is set";

command ++(b:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatINCR
comment "Unary increment over the tail of the bat";
command ++(b:bat[:oid,:lng],accum:int) :bat[:oid,:lng]
address CMDbatINCRaccum
comment "Unary increment over the tail of the bat, reuse B if ACCUM is set";

command ++(b:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatINCR
comment "Unary increment over the tail of the bat";
command ++(b:bat[:oid,:flt],accum:int) :bat[:oid,:flt]
address CMDbatINCRaccum
comment "Unary increment over the tail of the bat, reuse B if ACCUM is set";

command ++(b:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatINCR
comment "Unary increment over the tail of the bat";
command ++(b:bat[:oid,:dbl],accum:int) :bat[:oid,:dbl]
address CMDbatINCRaccum
comment "Unary increment over the tail of the bat, reuse B if ACCUM is set";


command --(b:bat[:oid,:bte]) :bat[:oid,:bte]
address CMDbatDECR
comment "Unary decrement over the tail of the bat";
command --(b:bat[:oid,:bte],accum:int) :bat[:oid,:bte]
address CMDbatDECRaccum
comment "Unary decrement over the tail of the bat, reuse B if ACCUM is set";

command --(b:bat[:oid,:sht]) :bat[:oid,:sht]
address CMDbatDECR
comment "Unary decrement over the tail of the bat";
command --(b:bat[:oid,:sht],accum:int) :bat[:oid,:sht]
address CMDbatDECRaccum
comment "Unary decrement over the tail of the bat, reuse B if ACCUM is set";

command --(b:bat[:oid,:int]) :bat[:oid,:int]
address CMDbatDECR
comment "Unary decrement over the tail of the bat";
command --(b:bat[:oid,:int],accum:int) :bat[:oid,:int]
address CMDbatDECRaccum
comment "Unary decrement over the tail of the bat, reuse B if ACCUM is set";

command --(b:bat[:oid,:wrd]) :bat[:oid,:wrd]
address CMDbatDECR
comment "Unary decrement over the tail of the bat";
command --(b:bat[:oid,:wrd],accum:int) :bat[:oid,:wrd]
address CMDbatDECRaccum
comment "Unary decrement over the tail of the bat, reuse B if ACCUM is set";

command --(b:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatDECR
comment "Unary decrement over the tail of the bat";
command --(b:bat[:oid,:lng],accum:int) :bat[:oid,:lng]
address CMDbatDECRaccum
comment "Unary decrement over the tail of the bat, reuse B if ACCUM is set";

command --(b:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatDECR
comment "Unary decrement over the tail of the bat";
command --(b:bat[:oid,:flt],accum:int) :bat[:oid,:flt]
address CMDbatDECRaccum
comment "Unary decrement over the tail of the bat, reuse B if ACCUM is set";

command --(b:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatDECR
comment "Unary decrement over the tail of the bat";
command --(b:bat[:oid,:dbl],accum:int) :bat[:oid,:dbl]
address CMDbatDECRaccum
comment "Unary decrement over the tail of the bat, reuse B if ACCUM is set";


command +(b1:bat[:oid,:bte],b2:bat[:oid,:bte]) :bat[:oid,:sht]
address CMDbatADDenlarge
comment "Return B1 + B2, guarantee no overflow by returning larger type";
pattern +(b:bat[:oid,:bte],v:bte) :bat[:oid,:sht]
address CMDbatADDcstenlarge
comment "Return B + V, guarantee no overflow by returning larger type";
pattern +(v:bte,b:bat[:oid,:bte]) :bat[:oid,:sht]
address CMDbatADDcstsignal
comment "Return V + B, guarantee no overflow by returning larger type";

command +(b1:bat[:oid,:bte],b2:bat[:oid,:sht]) :bat[:oid,:int]
address CMDbatADDenlarge
comment "Return B1 + B2, guarantee no overflow by returning larger type";
pattern +(b:bat[:oid,:bte],v:sht) :bat[:oid,:int]
address CMDbatADDcstenlarge
comment "Return B + V, guarantee no overflow by returning larger type";
pattern +(v:bte,b:bat[:oid,:sht]) :bat[:oid,:int]
address CMDbatADDcstsignal
comment "Return V + B, guarantee no overflow by returning larger type";

command +(b1:bat[:oid,:bte],b2:bat[:oid,:int]) :bat[:oid,:lng]
address CMDbatADDenlarge
comment "Return B1 + B2, guarantee no overflow by returning larger type";
pattern +(b:bat[:oid,:bte],v:int) :bat[:oid,:lng]
address CMDbatADDcstenlarge
comment "Return B + V, guarantee no overflow by returning larger type";
pattern +(v:bte,b:bat[:oid,:int]) :bat[:oid,:lng]
address CMDbatADDcstsignal
comment "Return V + B, guarantee no overflow by returning larger type";

command +(b1:bat[:oid,:bte],b2:bat[:oid,:flt]) :bat[:oid,:dbl]
address CMDbatADDenlarge
comment "Return B1 + B2, guarantee no overflow by returning larger type";
pattern +(b:bat[:oid,:bte],v:flt) :bat[:oid,:dbl]
address CMDbatADDcstenlarge
comment "Return B + V, guarantee no overflow by returning larger type";
pattern +(v:bte,b:bat[:oid,:flt]) :bat[:oid,:dbl]
address CMDbatADDcstsignal
comment "Return V + B, guarantee no overflow by returning larger type";

command +(b1:bat[:oid,:sht],b2:bat[:oid,:bte]) :bat[:oid,:int]
address CMDbatADDenlarge
comment "Return B1 + B2, guarantee no overflow by returning larger type";
pattern +(b:bat[:oid,:sht],v:bte) :bat[:oid,:int]
address CMDbatADDcstenlarge
comment "Return B + V, guarantee no overflow by returning larger type";
pattern +(v:sht,b:bat[:oid,:bte]) :bat[:oid,:int]
address CMDbatADDcstsignal
comment "Return V + B, guarantee no overflow by returning larger type";

command +(b1:bat[:oid,:sht],b2:bat[:oid,:sht]) :bat[:oid,:int]
address CMDbatADDenlarge
comment "Return B1 + B2, guarantee no overflow by returning larger type";
pattern +(b:bat[:oid,:sht],v:sht) :bat[:oid,:int]
address CMDbatADDcstenlarge
comment "Return B + V, guarantee no overflow by returning larger type";
pattern +(v:sht,b:bat[:oid,:sht]) :bat[:oid,:int]
address CMDbatADDcstsignal
comment "Return V + B, guarantee no overflow by returning larger type";

command +(b1:bat[:oid,:sht],b2:bat[:oid,:int]) :bat[:oid,:lng]
address CMDbatADDenlarge
comment "Return B1 + B2, guarantee no overflow by returning larger type";
pattern +(b:bat[:oid,:sht],v:int) :bat[:oid,:lng]
address CMDbatADDcstenlarge
comment "Return B + V, guarantee no overflow by returning larger type";
pattern +(v:sht,b:bat[:oid,:int]) :bat[:oid,:lng]
address CMDbatADDcstsignal
comment "Return V + B, guarantee no overflow by returning larger type";

command +(b1:bat[:oid,:sht],b2:bat[:oid,:flt]) :bat[:oid,:dbl]
address CMDbatADDenlarge
comment "Return B1 + B2, guarantee no overflow by returning larger type";
pattern +(b:bat[:oid,:sht],v:flt) :bat[:oid,:dbl]
address CMDbatADDcstenlarge
comment "Return B + V, guarantee no overflow by returning larger type";
pattern +(v:sht,b:bat[:oid,:flt]) :bat[:oid,:dbl]
address CMDbatADDcstsignal
comment "Return V + B, guarantee no overflow by returning larger type";

command +(b1:bat[:oid,:int],b2:bat[:oid,:bte]) :bat[:oid,:lng]
address CMDbatADDenlarge
comment "Return B1 + B2, guarantee no overflow by returning larger type";
pattern +(b:bat[:oid,:int],v:bte) :bat[:oid,:lng]
address CMDbatADDcstenlarge
comment "Return B + V, guarantee no overflow by returning larger type";
pattern +(v:int,b:bat[:oid,:bte]) :bat[:oid,:lng]
address CMDbatADDcstsignal
comment "Return V + B, guarantee no overflow by returning larger type";

command +(b1:bat[:oid,:int],b2:bat[:oid,:sht]) :bat[:oid,:lng]
address CMDbatADDenlarge
comment "Return B1 + B2, guarantee no overflow by returning larger type";
pattern +(b:bat[:oid,:int],v:sht) :bat[:oid,:lng]
address CMDbatADDcstenlarge
comment "Return B + V, guarantee no overflow by returning larger type";
pattern +(v:int,b:bat[:oid,:sht]) :bat[:oid,:lng]
address CMDbatADDcstsignal
comment "Return V + B, guarantee no overflow by returning larger type";

command +(b1:bat[:oid,:int],b2:bat[:oid,:int]) :bat[:oid,:lng]
address CMDbatADDenlarge
comment "Return B1 + B2, guarantee no overflow by returning larger type";
pattern +(b:bat[:oid,:int],v:int) :bat[:oid,:lng]
address CMDbatADDcstenlarge
comment "Return B + V, guarantee no overflow by returning larger type";
pattern +(v:int,b:bat[:oid,:int]) :bat[:oid,:lng]
address CMDbatADDcstsignal
comment "Return V + B, guarantee no overflow by returning larger type";

command +(b1:bat[:oid,:int],b2:bat[:oid,:flt]) :bat[:oid,:dbl]
address CMDbatADDenlarge
comment "Return B1 + B2, guarantee no overflow by returning larger type";
pattern +(b:bat[:oid,:int],v:flt) :bat[:oid,:dbl]
address CMDbatADDcstenlarge
comment "Return B + V, guarantee no overflow by returning larger type";
pattern +(v:int,b:bat[:oid,:flt]) :bat[:oid,:dbl]
address CMDbatADDcstsignal
comment "Return V + B, guarantee no overflow by returning larger type";

command +(b1:bat[:oid,:lng],b2:bat[:oid,:flt]) :bat[:oid,:dbl]
address CMDbatADDenlarge
comment "Return B1 + B2, guarantee no overflow by returning larger type";
pattern +(b:bat[:oid,:lng],v:flt) :bat[:oid,:dbl]
address CMDbatADDcstenlarge
comment "Return B + V, guarantee no overflow by returning larger type";
pattern +(v:lng,b:bat[:oid,:flt]) :bat[:oid,:dbl]
address CMDbatADDcstsignal
comment "Return V + B, guarantee no overflow by returning larger type";

command +(b1:bat[:oid,:flt],b2:bat[:oid,:bte]) :bat[:oid,:dbl]
address CMDbatADDenlarge
comment "Return B1 + B2, guarantee no overflow by returning larger type";
pattern +(b:bat[:oid,:flt],v:bte) :bat[:oid,:dbl]
address CMDbatADDcstenlarge
comment "Return B + V, guarantee no overflow by returning larger type";
pattern +(v:flt,b:bat[:oid,:bte]) :bat[:oid,:dbl]
address CMDbatADDcstsignal
comment "Return V + B, guarantee no overflow by returning larger type";

command +(b1:bat[:oid,:flt],b2:bat[:oid,:sht]) :bat[:oid,:dbl]
address CMDbatADDenlarge
comment "Return B1 + B2, guarantee no overflow by returning larger type";
pattern +(b:bat[:oid,:flt],v:sht) :bat[:oid,:dbl]
address CMDbatADDcstenlarge
comment "Return B + V, guarantee no overflow by returning larger type";
pattern +(v:flt,b:bat[:oid,:sht]) :bat[:oid,:dbl]
address CMDbatADDcstsignal
comment "Return V + B, guarantee no overflow by returning larger type";

command +(b1:bat[:oid,:flt],b2:bat[:oid,:int]) :bat[:oid,:dbl]
address CMDbatADDenlarge
comment "Return B1 + B2, guarantee no overflow by returning larger type";
pattern +(b:bat[:oid,:flt],v:int) :bat[:oid,:dbl]
address CMDbatADDcstenlarge
comment "Return B + V, guarantee no overflow by returning larger type";
pattern +(v:flt,b:bat[:oid,:int]) :bat[:oid,:dbl]
address CMDbatADDcstsignal
comment "Return V + B, guarantee no overflow by returning larger type";

command +(b1:bat[:oid,:flt],b2:bat[:oid,:lng]) :bat[:oid,:dbl]
address CMDbatADDenlarge
comment "Return B1 + B2, guarantee no overflow by returning larger type";
pattern +(b:bat[:oid,:flt],v:lng) :bat[:oid,:dbl]
address CMDbatADDcstenlarge
comment "Return B + V, guarantee no overflow by returning larger type";
pattern +(v:flt,b:bat[:oid,:lng]) :bat[:oid,:dbl]
address CMDbatADDcstsignal
comment "Return V + B, guarantee no overflow by returning larger type";

command +(b1:bat[:oid,:flt],b2:bat[:oid,:flt]) :bat[:oid,:dbl]
address CMDbatADDenlarge
comment "Return B1 + B2, guarantee no overflow by returning larger type";
pattern +(b:bat[:oid,:flt],v:flt) :bat[:oid,:dbl]
address CMDbatADDcstenlarge
comment "Return B + V, guarantee no overflow by returning larger type";
pattern +(v:flt,b:bat[:oid,:flt]) :bat[:oid,:dbl]
address CMDbatADDcstsignal
comment "Return V + B, guarantee no overflow by returning larger type";


command -(b1:bat[:oid,:bte],b2:bat[:oid,:bte]) :bat[:oid,:sht]
address CMDbatSUBenlarge
comment "Return B1 - B2, guarantee no overflow by returning larger type";
pattern -(b:bat[:oid,:bte],v:bte) :bat[:oid,:sht]
address CMDbatSUBcstenlarge
comment "Return B - V, guarantee no overflow by returning larger type";
pattern -(v:bte,b:bat[:oid,:bte]) :bat[:oid,:sht]
address CMDbatSUBcstsignal
comment "Return V - B, guarantee no overflow by returning larger type";

command -(b1:bat[:oid,:bte],b2:bat[:oid,:sht]) :bat[:oid,:int]
address CMDbatSUBenlarge
comment "Return B1 - B2, guarantee no overflow by returning larger type";
pattern -(b:bat[:oid,:bte],v:sht) :bat[:oid,:int]
address CMDbatSUBcstenlarge
comment "Return B - V, guarantee no overflow by returning larger type";
pattern -(v:bte,b:bat[:oid,:sht]) :bat[:oid,:int]
address CMDbatSUBcstsignal
comment "Return V - B, guarantee no overflow by returning larger type";

command -(b1:bat[:oid,:bte],b2:bat[:oid,:int]) :bat[:oid,:lng]
address CMDbatSUBenlarge
comment "Return B1 - B2, guarantee no overflow by returning larger type";
pattern -(b:bat[:oid,:bte],v:int) :bat[:oid,:lng]
address CMDbatSUBcstenlarge
comment "Return B - V, guarantee no overflow by returning larger type";
pattern -(v:bte,b:bat[:oid,:int]) :bat[:oid,:lng]
address CMDbatSUBcstsignal
comment "Return V - B, guarantee no overflow by returning larger type";

command -(b1:bat[:oid,:bte],b2:bat[:oid,:flt]) :bat[:oid,:dbl]
address CMDbatSUBenlarge
comment "Return B1 - B2, guarantee no overflow by returning larger type";
pattern -(b:bat[:oid,:bte],v:flt) :bat[:oid,:dbl]
address CMDbatSUBcstenlarge
comment "Return B - V, guarantee no overflow by returning larger type";
pattern -(v:bte,b:bat[:oid,:flt]) :bat[:oid,:dbl]
address CMDbatSUBcstsignal
comment "Return V - B, guarantee no overflow by returning larger type";

command -(b1:bat[:oid,:sht],b2:bat[:oid,:bte]) :bat[:oid,:int]
address CMDbatSUBenlarge
comment "Return B1 - B2, guarantee no overflow by returning larger type";
pattern -(b:bat[:oid,:sht],v:bte) :bat[:oid,:int]
address CMDbatSUBcstenlarge
comment "Return B - V, guarantee no overflow by returning larger type";
pattern -(v:sht,b:bat[:oid,:bte]) :bat[:oid,:int]
address CMDbatSUBcstsignal
comment "Return V - B, guarantee no overflow by returning larger type";

command -(b1:bat[:oid,:sht],b2:bat[:oid,:sht]) :bat[:oid,:int]
address CMDbatSUBenlarge
comment "Return B1 - B2, guarantee no overflow by returning larger type";
pattern -(b:bat[:oid,:sht],v:sht) :bat[:oid,:int]
address CMDbatSUBcstenlarge
comment "Return B - V, guarantee no overflow by returning larger type";
pattern -(v:sht,b:bat[:oid,:sht]) :bat[:oid,:int]
address CMDbatSUBcstsignal
comment "Return V - B, guarantee no overflow by returning larger type";

command -(b1:bat[:oid,:sht],b2:bat[:oid,:int]) :bat[:oid,:lng]
address CMDbatSUBenlarge
comment "Return B1 - B2, guarantee no overflow by returning larger type";
pattern -(b:bat[:oid,:sht],v:int) :bat[:oid,:lng]
address CMDbatSUBcstenlarge
comment "Return B - V, guarantee no overflow by returning larger type";
pattern -(v:sht,b:bat[:oid,:int]) :bat[:oid,:lng]
address CMDbatSUBcstsignal
comment "Return V - B, guarantee no overflow by returning larger type";

command -(b1:bat[:oid,:sht],b2:bat[:oid,:flt]) :bat[:oid,:dbl]
address CMDbatSUBenlarge
comment "Return B1 - B2, guarantee no overflow by returning larger type";
pattern -(b:bat[:oid,:sht],v:flt) :bat[:oid,:dbl]
address CMDbatSUBcstenlarge
comment "Return B - V, guarantee no overflow by returning larger type";
pattern -(v:sht,b:bat[:oid,:flt]) :bat[:oid,:dbl]
address CMDbatSUBcstsignal
comment "Return V - B, guarantee no overflow by returning larger type";

command -(b1:bat[:oid,:int],b2:bat[:oid,:bte]) :bat[:oid,:lng]
address CMDbatSUBenlarge
comment "Return B1 - B2, guarantee no overflow by returning larger type";
pattern -(b:bat[:oid,:int],v:bte) :bat[:oid,:lng]
address CMDbatSUBcstenlarge
comment "Return B - V, guarantee no overflow by returning larger type";
pattern -(v:int,b:bat[:oid,:bte]) :bat[:oid,:lng]
address CMDbatSUBcstsignal
comment "Return V - B, guarantee no overflow by returning larger type";

command -(b1:bat[:oid,:int],b2:bat[:oid,:sht]) :bat[:oid,:lng]
address CMDbatSUBenlarge
comment "Return B1 - B2, guarantee no overflow by returning larger type";
pattern -(b:bat[:oid,:int],v:sht) :bat[:oid,:lng]
address CMDbatSUBcstenlarge
comment "Return B - V, guarantee no overflow by returning larger type";
pattern -(v:int,b:bat[:oid,:sht]) :bat[:oid,:lng]
address CMDbatSUBcstsignal
comment "Return V - B, guarantee no overflow by returning larger type";

command -(b1:bat[:oid,:int],b2:bat[:oid,:int]) :bat[:oid,:lng]
address CMDbatSUBenlarge
comment "Return B1 - B2, guarantee no overflow by returning larger type";
pattern -(b:bat[:oid,:int],v:int) :bat[:oid,:lng]
address CMDbatSUBcstenlarge
comment "Return B - V, guarantee no overflow by returning larger type";
pattern -(v:int,b:bat[:oid,:int]) :bat[:oid,:lng]
address CMDbatSUBcstsignal
comment "Return V - B, guarantee no overflow by returning larger type";

command -(b1:bat[:oid,:int],b2:bat[:oid,:flt]) :bat[:oid,:dbl]
address CMDbatSUBenlarge
comment "Return B1 - B2, guarantee no overflow by returning larger type";
pattern -(b:bat[:oid,:int],v:flt) :bat[:oid,:dbl]
address CMDbatSUBcstenlarge
comment "Return B - V, guarantee no overflow by returning larger type";
pattern -(v:int,b:bat[:oid,:flt]) :bat[:oid,:dbl]
address CMDbatSUBcstsignal
comment "Return V - B, guarantee no overflow by returning larger type";

command -(b1:bat[:oid,:lng],b2:bat[:oid,:flt]) :bat[:oid,:dbl]
address CMDbatSUBenlarge
comment "Return B1 - B2, guarantee no overflow by returning larger type";
pattern -(b:bat[:oid,:lng],v:flt) :bat[:oid,:dbl]
address CMDbatSUBcstenlarge
comment "Return B - V, guarantee no overflow by returning larger type";
pattern -(v:lng,b:bat[:oid,:flt]) :bat[:oid,:dbl]
address CMDbatSUBcstsignal
comment "Return V - B, guarantee no overflow by returning larger type";

command -(b1:bat[:oid,:flt],b2:bat[:oid,:bte]) :bat[:oid,:dbl]
address CMDbatSUBenlarge
comment "Return B1 - B2, guarantee no overflow by returning larger type";
pattern -(b:bat[:oid,:flt],v:bte) :bat[:oid,:dbl]
address CMDbatSUBcstenlarge
comment "Return B - V, guarantee no overflow by returning larger type";
pattern -(v:flt,b:bat[:oid,:bte]) :bat[:oid,:dbl]
address CMDbatSUBcstsignal
comment "Return V - B, guarantee no overflow by returning larger type";

command -(b1:bat[:oid,:flt],b2:bat[:oid,:sht]) :bat[:oid,:dbl]
address CMDbatSUBenlarge
comment "Return B1 - B2, guarantee no overflow by returning larger type";
pattern -(b:bat[:oid,:flt],v:sht) :bat[:oid,:dbl]
address CMDbatSUBcstenlarge
comment "Return B - V, guarantee no overflow by returning larger type";
pattern -(v:flt,b:bat[:oid,:sht]) :bat[:oid,:dbl]
address CMDbatSUBcstsignal
comment "Return V - B, guarantee no overflow by returning larger type";

command -(b1:bat[:oid,:flt],b2:bat[:oid,:int]) :bat[:oid,:dbl]
address CMDbatSUBenlarge
comment "Return B1 - B2, guarantee no overflow by returning larger type";
pattern -(b:bat[:oid,:flt],v:int) :bat[:oid,:dbl]
address CMDbatSUBcstenlarge
comment "Return B - V, guarantee no overflow by returning larger type";
pattern -(v:flt,b:bat[:oid,:int]) :bat[:oid,:dbl]
address CMDbatSUBcstsignal
comment "Return V - B, guarantee no overflow by returning larger type";

command -(b1:bat[:oid,:flt],b2:bat[:oid,:lng]) :bat[:oid,:dbl]
address CMDbatSUBenlarge
comment "Return B1 - B2, guarantee no overflow by returning larger type";
pattern -(b:bat[:oid,:flt],v:lng) :bat[:oid,:dbl]
address CMDbatSUBcstenlarge
comment "Return B - V, guarantee no overflow by returning larger type";
pattern -(v:flt,b:bat[:oid,:lng]) :bat[:oid,:dbl]
address CMDbatSUBcstsignal
comment "Return V - B, guarantee no overflow by returning larger type";

command -(b1:bat[:oid,:flt],b2:bat[:oid,:flt]) :bat[:oid,:dbl]
address CMDbatSUBenlarge
comment "Return B1 - B2, guarantee no overflow by returning larger type";
pattern -(b:bat[:oid,:flt],v:flt) :bat[:oid,:dbl]
address CMDbatSUBcstenlarge
comment "Return B - V, guarantee no overflow by returning larger type";
pattern -(v:flt,b:bat[:oid,:flt]) :bat[:oid,:dbl]
address CMDbatSUBcstsignal
comment "Return V - B, guarantee no overflow by returning larger type";


command *(b1:bat[:oid,:bte],b2:bat[:oid,:bte]) :bat[:oid,:sht]
address CMDbatMULenlarge
comment "Return B1 * B2, guarantee no overflow by returning larger type";
pattern *(b:bat[:oid,:bte],v:bte) :bat[:oid,:sht]
address CMDbatMULcstenlarge
comment "Return B * V, guarantee no overflow by returning larger type";
pattern *(v:bte,b:bat[:oid,:bte]) :bat[:oid,:sht]
address CMDbatMULcstsignal
comment "Return V * B, guarantee no overflow by returning larger type";

command *(b1:bat[:oid,:bte],b2:bat[:oid,:sht]) :bat[:oid,:int]
address CMDbatMULenlarge
comment "Return B1 * B2, guarantee no overflow by returning larger type";
pattern *(b:bat[:oid,:bte],v:sht) :bat[:oid,:int]
address CMDbatMULcstenlarge
comment "Return B * V, guarantee no overflow by returning larger type";
pattern *(v:bte,b:bat[:oid,:sht]) :bat[:oid,:int]
address CMDbatMULcstsignal
comment "Return V * B, guarantee no overflow by returning larger type";

command *(b1:bat[:oid,:bte],b2:bat[:oid,:int]) :bat[:oid,:lng]
address CMDbatMULenlarge
comment "Return B1 * B2, guarantee no overflow by returning larger type";
pattern *(b:bat[:oid,:bte],v:int) :bat[:oid,:lng]
address CMDbatMULcstenlarge
comment "Return B * V, guarantee no overflow by returning larger type";
pattern *(v:bte,b:bat[:oid,:int]) :bat[:oid,:lng]
address CMDbatMULcstsignal
comment "Return V * B, guarantee no overflow by returning larger type";

command *(b1:bat[:oid,:bte],b2:bat[:oid,:flt]) :bat[:oid,:dbl]
address CMDbatMULenlarge
comment "Return B1 * B2, guarantee no overflow by returning larger type";
pattern *(b:bat[:oid,:bte],v:flt) :bat[:oid,:dbl]
address CMDbatMULcstenlarge
comment "Return B * V, guarantee no overflow by returning larger type";
pattern *(v:bte,b:bat[:oid,:flt]) :bat[:oid,:dbl]
address CMDbatMULcstsignal
comment "Return V * B, guarantee no overflow by returning larger type";

command *(b1:bat[:oid,:sht],b2:bat[:oid,:bte]) :bat[:oid,:int]
address CMDbatMULenlarge
comment "Return B1 * B2, guarantee no overflow by returning larger type";
pattern *(b:bat[:oid,:sht],v:bte) :bat[:oid,:int]
address CMDbatMULcstenlarge
comment "Return B * V, guarantee no overflow by returning larger type";
pattern *(v:sht,b:bat[:oid,:bte]) :bat[:oid,:int]
address CMDbatMULcstsignal
comment "Return V * B, guarantee no overflow by returning larger type";

command *(b1:bat[:oid,:sht],b2:bat[:oid,:sht]) :bat[:oid,:int]
address CMDbatMULenlarge
comment "Return B1 * B2, guarantee no overflow by returning larger type";
pattern *(b:bat[:oid,:sht],v:sht) :bat[:oid,:int]
address CMDbatMULcstenlarge
comment "Return B * V, guarantee no overflow by returning larger type";
pattern *(v:sht,b:bat[:oid,:sht]) :bat[:oid,:int]
address CMDbatMULcstsignal
comment "Return V * B, guarantee no overflow by returning larger type";

command *(b1:bat[:oid,:sht],b2:bat[:oid,:int]) :bat[:oid,:lng]
address CMDbatMULenlarge
comment "Return B1 * B2, guarantee no overflow by returning larger type";
pattern *(b:bat[:oid,:sht],v:int) :bat[:oid,:lng]
address CMDbatMULcstenlarge
comment "Return B * V, guarantee no overflow by returning larger type";
pattern *(v:sht,b:bat[:oid,:int]) :bat[:oid,:lng]
address CMDbatMULcstsignal
comment "Return V * B, guarantee no overflow by returning larger type";

command *(b1:bat[:oid,:sht],b2:bat[:oid,:flt]) :bat[:oid,:dbl]
address CMDbatMULenlarge
comment "Return B1 * B2, guarantee no overflow by returning larger type";
pattern *(b:bat[:oid,:sht],v:flt) :bat[:oid,:dbl]
address CMDbatMULcstenlarge
comment "Return B * V, guarantee no overflow by returning larger type";
pattern *(v:sht,b:bat[:oid,:flt]) :bat[:oid,:dbl]
address CMDbatMULcstsignal
comment "Return V * B, guarantee no overflow by returning larger type";

command *(b1:bat[:oid,:int],b2:bat[:oid,:bte]) :bat[:oid,:lng]
address CMDbatMULenlarge
comment "Return B1 * B2, guarantee no overflow by returning larger type";
pattern *(b:bat[:oid,:int],v:bte) :bat[:oid,:lng]
address CMDbatMULcstenlarge
comment "Return B * V, guarantee no overflow by returning larger type";
pattern *(v:int,b:bat[:oid,:bte]) :bat[:oid,:lng]
address CMDbatMULcstsignal
comment "Return V * B, guarantee no overflow by returning larger type";

command *(b1:bat[:oid,:int],b2:bat[:oid,:sht]) :bat[:oid,:lng]
address CMDbatMULenlarge
comment "Return B1 * B2, guarantee no overflow by returning larger type";
pattern *(b:bat[:oid,:int],v:sht) :bat[:oid,:lng]
address CMDbatMULcstenlarge
comment "Return B * V, guarantee no overflow by returning larger type";
pattern *(v:int,b:bat[:oid,:sht]) :bat[:oid,:lng]
address CMDbatMULcstsignal
comment "Return V * B, guarantee no overflow by returning larger type";

command *(b1:bat[:oid,:int],b2:bat[:oid,:int]) :bat[:oid,:lng]
address CMDbatMULenlarge
comment "Return B1 * B2, guarantee no overflow by returning larger type";
pattern *(b:bat[:oid,:int],v:int) :bat[:oid,:lng]
address CMDbatMULcstenlarge
comment "Return B * V, guarantee no overflow by returning larger type";
pattern *(v:int,b:bat[:oid,:int]) :bat[:oid,:lng]
address CMDbatMULcstsignal
comment "Return V * B, guarantee no overflow by returning larger type";

command *(b1:bat[:oid,:int],b2:bat[:oid,:flt]) :bat[:oid,:dbl]
address CMDbatMULenlarge
comment "Return B1 * B2, guarantee no overflow by returning larger type";
pattern *(b:bat[:oid,:int],v:flt) :bat[:oid,:dbl]
address CMDbatMULcstenlarge
comment "Return B * V, guarantee no overflow by returning larger type";
pattern *(v:int,b:bat[:oid,:flt]) :bat[:oid,:dbl]
address CMDbatMULcstsignal
comment "Return V * B, guarantee no overflow by returning larger type";

command *(b1:bat[:oid,:lng],b2:bat[:oid,:flt]) :bat[:oid,:dbl]
address CMDbatMULenlarge
comment "Return B1 * B2, guarantee no overflow by returning larger type";
pattern *(b:bat[:oid,:lng],v:flt) :bat[:oid,:dbl]
address CMDbatMULcstenlarge
comment "Return B * V, guarantee no overflow by returning larger type";
pattern *(v:lng,b:bat[:oid,:flt]) :bat[:oid,:dbl]
address CMDbatMULcstsignal
comment "Return V * B, guarantee no overflow by returning larger type";

command *(b1:bat[:oid,:flt],b2:bat[:oid,:bte]) :bat[:oid,:dbl]
address CMDbatMULenlarge
comment "Return B1 * B2, guarantee no overflow by returning larger type";
pattern *(b:bat[:oid,:flt],v:bte) :bat[:oid,:dbl]
address CMDbatMULcstenlarge
comment "Return B * V, guarantee no overflow by returning larger type";
pattern *(v:flt,b:bat[:oid,:bte]) :bat[:oid,:dbl]
address CMDbatMULcstsignal
comment "Return V * B, guarantee no overflow by returning larger type";

command *(b1:bat[:oid,:flt],b2:bat[:oid,:sht]) :bat[:oid,:dbl]
address CMDbatMULenlarge
comment "Return B1 * B2, guarantee no overflow by returning larger type";
pattern *(b:bat[:oid,:flt],v:sht) :bat[:oid,:dbl]
address CMDbatMULcstenlarge
comment "Return B * V, guarantee no overflow by returning larger type";
pattern *(v:flt,b:bat[:oid,:sht]) :bat[:oid,:dbl]
address CMDbatMULcstsignal
comment "Return V * B, guarantee no overflow by returning larger type";

command *(b1:bat[:oid,:flt],b2:bat[:oid,:int]) :bat[:oid,:dbl]
address CMDbatMULenlarge
comment "Return B1 * B2, guarantee no overflow by returning larger type";
pattern *(b:bat[:oid,:flt],v:int) :bat[:oid,:dbl]
address CMDbatMULcstenlarge
comment "Return B * V, guarantee no overflow by returning larger type";
pattern *(v:flt,b:bat[:oid,:int]) :bat[:oid,:dbl]
address CMDbatMULcstsignal
comment "Return V * B, guarantee no overflow by returning larger type";

command *(b1:bat[:oid,:flt],b2:bat[:oid,:lng]) :bat[:oid,:dbl]
address CMDbatMULenlarge
comment "Return B1 * B2, guarantee no overflow by returning larger type";
pattern *(b:bat[:oid,:flt],v:lng) :bat[:oid,:dbl]
address CMDbatMULcstenlarge
comment "Return B * V, guarantee no overflow by returning larger type";
pattern *(v:flt,b:bat[:oid,:lng]) :bat[:oid,:dbl]
address CMDbatMULcstsignal
comment "Return V * B, guarantee no overflow by returning larger type";

command *(b1:bat[:oid,:flt],b2:bat[:oid,:flt]) :bat[:oid,:dbl]
address CMDbatMULenlarge
comment "Return B1 * B2, guarantee no overflow by returning larger type";
pattern *(b:bat[:oid,:flt],v:flt) :bat[:oid,:dbl]
address CMDbatMULcstenlarge
comment "Return B * V, guarantee no overflow by returning larger type";
pattern *(v:flt,b:bat[:oid,:flt]) :bat[:oid,:dbl]
address CMDbatMULcstsignal
comment "Return V * B, guarantee no overflow by returning larger type";


command +(b1:bat[:oid,:bte],b2:bat[:oid,:bte]) :bat[:oid,:bte]
address CMDbatADDsignal
comment "Return B1 + B2, signal error on overflow";
command +(b1:bat[:oid,:bte],b2:bat[:oid,:bte],accum:int) :bat[:oid,:bte]
address CMDbatADDsignalaccum
comment "Return B1 + B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command add_noerror(b1:bat[:oid,:bte],b2:bat[:oid,:bte]) :bat[:oid,:bte]
address CMDbatADD
comment "Return B1 + B2, overflow causes NIL value";
pattern +(b:bat[:oid,:bte],v:bte) :bat[:oid,:bte]
address CMDbatADDcstsignal
comment "Return B + V, signal error on overflow";
pattern +(b:bat[:oid,:bte],v:bte,accum:int) :bat[:oid,:bte]
address CMDbatADDcstsignal
comment "Return B + V, signal error on overflow, reuse B if ACCUM is set";
pattern add_noerror(b:bat[:oid,:bte],v:bte) :bat[:oid,:bte]
address CMDbatADDcst
comment "Return B + V, overflow causes NIL value";
pattern +(v:bte,b:bat[:oid,:bte]) :bat[:oid,:bte]
address CMDbatADDcstsignal
comment "Return V + B, signal error on overflow";
pattern +(v:bte,b:bat[:oid,:bte],accum:int) :bat[:oid,:bte]
address CMDbatADDcstsignal
comment "Return V + B, signal error on overflow, reuse B if ACCUM is set";
pattern add_noerror(v:bte,b:bat[:oid,:bte]) :bat[:oid,:bte]
address CMDbatADDcst
comment "Return V + B, overflow causes NIL value";

command +(b1:bat[:oid,:bte],b2:bat[:oid,:sht]) :bat[:oid,:sht]
address CMDbatADDsignal
comment "Return B1 + B2, signal error on overflow";
command +(b1:bat[:oid,:bte],b2:bat[:oid,:sht],accum:int) :bat[:oid,:sht]
address CMDbatADDsignalaccum
comment "Return B1 + B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command add_noerror(b1:bat[:oid,:bte],b2:bat[:oid,:sht]) :bat[:oid,:sht]
address CMDbatADD
comment "Return B1 + B2, overflow causes NIL value";
pattern +(b:bat[:oid,:bte],v:sht) :bat[:oid,:sht]
address CMDbatADDcstsignal
comment "Return B + V, signal error on overflow";
pattern add_noerror(b:bat[:oid,:bte],v:sht) :bat[:oid,:sht]
address CMDbatADDcst
comment "Return B + V, overflow causes NIL value";
pattern +(v:bte,b:bat[:oid,:sht]) :bat[:oid,:sht]
address CMDbatADDcstsignal
comment "Return V + B, signal error on overflow";
pattern +(v:bte,b:bat[:oid,:sht],accum:int) :bat[:oid,:sht]
address CMDbatADDcstsignal
comment "Return V + B, signal error on overflow, reuse B if ACCUM is set";
pattern add_noerror(v:bte,b:bat[:oid,:sht]) :bat[:oid,:sht]
address CMDbatADDcst
comment "Return V + B, overflow causes NIL value";

command +(b1:bat[:oid,:bte],b2:bat[:oid,:int]) :bat[:oid,:int]
address CMDbatADDsignal
comment "Return B1 + B2, signal error on overflow";
command +(b1:bat[:oid,:bte],b2:bat[:oid,:int],accum:int) :bat[:oid,:int]
address CMDbatADDsignalaccum
comment "Return B1 + B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command add_noerror(b1:bat[:oid,:bte],b2:bat[:oid,:int]) :bat[:oid,:int]
address CMDbatADD
comment "Return B1 + B2, overflow causes NIL value";
pattern +(b:bat[:oid,:bte],v:int) :bat[:oid,:int]
address CMDbatADDcstsignal
comment "Return B + V, signal error on overflow";
pattern add_noerror(b:bat[:oid,:bte],v:int) :bat[:oid,:int]
address CMDbatADDcst
comment "Return B + V, overflow causes NIL value";
pattern +(v:bte,b:bat[:oid,:int]) :bat[:oid,:int]
address CMDbatADDcstsignal
comment "Return V + B, signal error on overflow";
pattern +(v:bte,b:bat[:oid,:int],accum:int) :bat[:oid,:int]
address CMDbatADDcstsignal
comment "Return V + B, signal error on overflow, reuse B if ACCUM is set";
pattern add_noerror(v:bte,b:bat[:oid,:int]) :bat[:oid,:int]
address CMDbatADDcst
comment "Return V + B, overflow causes NIL value";

command +(b1:bat[:oid,:bte],b2:bat[:oid,:wrd]) :bat[:oid,:wrd]
address CMDbatADDsignal
comment "Return B1 + B2, signal error on overflow";
command +(b1:bat[:oid,:bte],b2:bat[:oid,:wrd],accum:int) :bat[:oid,:wrd]
address CMDbatADDsignalaccum
comment "Return B1 + B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command add_noerror(b1:bat[:oid,:bte],b2:bat[:oid,:wrd]) :bat[:oid,:wrd]
address CMDbatADD
comment "Return B1 + B2, overflow causes NIL value";
pattern +(b:bat[:oid,:bte],v:wrd) :bat[:oid,:wrd]
address CMDbatADDcstsignal
comment "Return B + V, signal error on overflow";
pattern add_noerror(b:bat[:oid,:bte],v:wrd) :bat[:oid,:wrd]
address CMDbatADDcst
comment "Return B + V, overflow causes NIL value";
pattern +(v:bte,b:bat[:oid,:wrd]) :bat[:oid,:wrd]
address CMDbatADDcstsignal
comment "Return V + B, signal error on overflow";
pattern +(v:bte,b:bat[:oid,:wrd],accum:int) :bat[:oid,:wrd]
address CMDbatADDcstsignal
comment "Return V + B, signal error on overflow, reuse B if ACCUM is set";
pattern add_noerror(v:bte,b:bat[:oid,:wrd]) :bat[:oid,:wrd]
address CMDbatADDcst
comment "Return V + B, overflow causes NIL value";

command +(b1:bat[:oid,:bte],b2:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatADDsignal
comment "Return B1 + B2, signal error on overflow";
command +(b1:bat[:oid,:bte],b2:bat[:oid,:lng],accum:int) :bat[:oid,:lng]
address CMDbatADDsignalaccum
comment "Return B1 + B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command add_noerror(b1:bat[:oid,:bte],b2:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatADD
comment "Return B1 + B2, overflow causes NIL value";
pattern +(b:bat[:oid,:bte],v:lng) :bat[:oid,:lng]
address CMDbatADDcstsignal
comment "Return B + V, signal error on overflow";
pattern add_noerror(b:bat[:oid,:bte],v:lng) :bat[:oid,:lng]
address CMDbatADDcst
comment "Return B + V, overflow causes NIL value";
pattern +(v:bte,b:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatADDcstsignal
comment "Return V + B, signal error on overflow";
pattern +(v:bte,b:bat[:oid,:lng],accum:int) :bat[:oid,:lng]
address CMDbatADDcstsignal
comment "Return V + B, signal error on overflow, reuse B if ACCUM is set";
pattern add_noerror(v:bte,b:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatADDcst
comment "Return V + B, overflow causes NIL value";

command +(b1:bat[:oid,:bte],b2:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatADDsignal
comment "Return B1 + B2, signal error on overflow";
command +(b1:bat[:oid,:bte],b2:bat[:oid,:flt],accum:int) :bat[:oid,:flt]
address CMDbatADDsignalaccum
comment "Return B1 + B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command add_noerror(b1:bat[:oid,:bte],b2:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatADD
comment "Return B1 + B2, overflow causes NIL value";
pattern +(b:bat[:oid,:bte],v:flt) :bat[:oid,:flt]
address CMDbatADDcstsignal
comment "Return B + V, signal error on overflow";
pattern add_noerror(b:bat[:oid,:bte],v:flt) :bat[:oid,:flt]
address CMDbatADDcst
comment "Return B + V, overflow causes NIL value";
pattern +(v:bte,b:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatADDcstsignal
comment "Return V + B, signal error on overflow";
pattern +(v:bte,b:bat[:oid,:flt],accum:int) :bat[:oid,:flt]
address CMDbatADDcstsignal
comment "Return V + B, signal error on overflow, reuse B if ACCUM is set";
pattern add_noerror(v:bte,b:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatADDcst
comment "Return V + B, overflow causes NIL value";

command +(b1:bat[:oid,:bte],b2:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatADDsignal
comment "Return B1 + B2, signal error on overflow";
command +(b1:bat[:oid,:bte],b2:bat[:oid,:dbl],accum:int) :bat[:oid,:dbl]
address CMDbatADDsignalaccum
comment "Return B1 + B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command add_noerror(b1:bat[:oid,:bte],b2:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatADD
comment "Return B1 + B2, overflow causes NIL value";
pattern +(b:bat[:oid,:bte],v:dbl) :bat[:oid,:dbl]
address CMDbatADDcstsignal
comment "Return B + V, signal error on overflow";
pattern add_noerror(b:bat[:oid,:bte],v:dbl) :bat[:oid,:dbl]
address CMDbatADDcst
comment "Return B + V, overflow causes NIL value";
pattern +(v:bte,b:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatADDcstsignal
comment "Return V + B, signal error on overflow";
pattern +(v:bte,b:bat[:oid,:dbl],accum:int) :bat[:oid,:dbl]
address CMDbatADDcstsignal
comment "Return V + B, signal error on overflow, reuse B if ACCUM is set";
pattern add_noerror(v:bte,b:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatADDcst
comment "Return V + B, overflow causes NIL value";

command +(b1:bat[:oid,:sht],b2:bat[:oid,:bte]) :bat[:oid,:sht]
address CMDbatADDsignal
comment "Return B1 + B2, signal error on overflow";
command +(b1:bat[:oid,:sht],b2:bat[:oid,:bte],accum:int) :bat[:oid,:sht]
address CMDbatADDsignalaccum
comment "Return B1 + B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command add_noerror(b1:bat[:oid,:sht],b2:bat[:oid,:bte]) :bat[:oid,:sht]
address CMDbatADD
comment "Return B1 + B2, overflow causes NIL value";
pattern +(b:bat[:oid,:sht],v:bte) :bat[:oid,:sht]
address CMDbatADDcstsignal
comment "Return B + V, signal error on overflow";
pattern +(b:bat[:oid,:sht],v:bte,accum:int) :bat[:oid,:sht]
address CMDbatADDcstsignal
comment "Return B + V, signal error on overflow, reuse B if ACCUM is set";
pattern add_noerror(b:bat[:oid,:sht],v:bte) :bat[:oid,:sht]
address CMDbatADDcst
comment "Return B + V, overflow causes NIL value";
pattern +(v:sht,b:bat[:oid,:bte]) :bat[:oid,:sht]
address CMDbatADDcstsignal
comment "Return V + B, signal error on overflow";
pattern add_noerror(v:sht,b:bat[:oid,:bte]) :bat[:oid,:sht]
address CMDbatADDcst
comment "Return V + B, overflow causes NIL value";

command +(b1:bat[:oid,:sht],b2:bat[:oid,:sht]) :bat[:oid,:sht]
address CMDbatADDsignal
comment "Return B1 + B2, signal error on overflow";
command +(b1:bat[:oid,:sht],b2:bat[:oid,:sht],accum:int) :bat[:oid,:sht]
address CMDbatADDsignalaccum
comment "Return B1 + B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command add_noerror(b1:bat[:oid,:sht],b2:bat[:oid,:sht]) :bat[:oid,:sht]
address CMDbatADD
comment "Return B1 + B2, overflow causes NIL value";
pattern +(b:bat[:oid,:sht],v:sht) :bat[:oid,:sht]
address CMDbatADDcstsignal
comment "Return B + V, signal error on overflow";
pattern +(b:bat[:oid,:sht],v:sht,accum:int) :bat[:oid,:sht]
address CMDbatADDcstsignal
comment "Return B + V, signal error on overflow, reuse B if ACCUM is set";
pattern add_noerror(b:bat[:oid,:sht],v:sht) :bat[:oid,:sht]
address CMDbatADDcst
comment "Return B + V, overflow causes NIL value";
pattern +(v:sht,b:bat[:oid,:sht]) :bat[:oid,:sht]
address CMDbatADDcstsignal
comment "Return V + B, signal error on overflow";
pattern +(v:sht,b:bat[:oid,:sht],accum:int) :bat[:oid,:sht]
address CMDbatADDcstsignal
comment "Return V + B, signal error on overflow, reuse B if ACCUM is set";
pattern add_noerror(v:sht,b:bat[:oid,:sht]) :bat[:oid,:sht]
address CMDbatADDcst
comment "Return V + B, overflow causes NIL value";

command +(b1:bat[:oid,:sht],b2:bat[:oid,:int]) :bat[:oid,:int]
address CMDbatADDsignal
comment "Return B1 + B2, signal error on overflow";
command +(b1:bat[:oid,:sht],b2:bat[:oid,:int],accum:int) :bat[:oid,:int]
address CMDbatADDsignalaccum
comment "Return B1 + B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command add_noerror(b1:bat[:oid,:sht],b2:bat[:oid,:int]) :bat[:oid,:int]
address CMDbatADD
comment "Return B1 + B2, overflow causes NIL value";
pattern +(b:bat[:oid,:sht],v:int) :bat[:oid,:int]
address CMDbatADDcstsignal
comment "Return B + V, signal error on overflow";
pattern add_noerror(b:bat[:oid,:sht],v:int) :bat[:oid,:int]
address CMDbatADDcst
comment "Return B + V, overflow causes NIL value";
pattern +(v:sht,b:bat[:oid,:int]) :bat[:oid,:int]
address CMDbatADDcstsignal
comment "Return V + B, signal error on overflow";
pattern +(v:sht,b:bat[:oid,:int],accum:int) :bat[:oid,:int]
address CMDbatADDcstsignal
comment "Return V + B, signal error on overflow, reuse B if ACCUM is set";
pattern add_noerror(v:sht,b:bat[:oid,:int]) :bat[:oid,:int]
address CMDbatADDcst
comment "Return V + B, overflow causes NIL value";

command +(b1:bat[:oid,:sht],b2:bat[:oid,:wrd]) :bat[:oid,:wrd]
address CMDbatADDsignal
comment "Return B1 + B2, signal error on overflow";
command +(b1:bat[:oid,:sht],b2:bat[:oid,:wrd],accum:int) :bat[:oid,:wrd]
address CMDbatADDsignalaccum
comment "Return B1 + B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command add_noerror(b1:bat[:oid,:sht],b2:bat[:oid,:wrd]) :bat[:oid,:wrd]
address CMDbatADD
comment "Return B1 + B2, overflow causes NIL value";
pattern +(b:bat[:oid,:sht],v:wrd) :bat[:oid,:wrd]
address CMDbatADDcstsignal
comment "Return B + V, signal error on overflow";
pattern add_noerror(b:bat[:oid,:sht],v:wrd) :bat[:oid,:wrd]
address CMDbatADDcst
comment "Return B + V, overflow causes NIL value";
pattern +(v:sht,b:bat[:oid,:wrd]) :bat[:oid,:wrd]
address CMDbatADDcstsignal
comment "Return V + B, signal error on overflow";
pattern +(v:sht,b:bat[:oid,:wrd],accum:int) :bat[:oid,:wrd]
address CMDbatADDcstsignal
comment "Return V + B, signal error on overflow, reuse B if ACCUM is set";
pattern add_noerror(v:sht,b:bat[:oid,:wrd]) :bat[:oid,:wrd]
address CMDbatADDcst
comment "Return V + B, overflow causes NIL value";

command +(b1:bat[:oid,:sht],b2:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatADDsignal
comment "Return B1 + B2, signal error on overflow";
command +(b1:bat[:oid,:sht],b2:bat[:oid,:lng],accum:int) :bat[:oid,:lng]
address CMDbatADDsignalaccum
comment "Return B1 + B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command add_noerror(b1:bat[:oid,:sht],b2:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatADD
comment "Return B1 + B2, overflow causes NIL value";
pattern +(b:bat[:oid,:sht],v:lng) :bat[:oid,:lng]
address CMDbatADDcstsignal
comment "Return B + V, signal error on overflow";
pattern add_noerror(b:bat[:oid,:sht],v:lng) :bat[:oid,:lng]
address CMDbatADDcst
comment "Return B + V, overflow causes NIL value";
pattern +(v:sht,b:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatADDcstsignal
comment "Return V + B, signal error on overflow";
pattern +(v:sht,b:bat[:oid,:lng],accum:int) :bat[:oid,:lng]
address CMDbatADDcstsignal
comment "Return V + B, signal error on overflow, reuse B if ACCUM is set";
pattern add_noerror(v:sht,b:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatADDcst
comment "Return V + B, overflow causes NIL value";

command +(b1:bat[:oid,:sht],b2:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatADDsignal
comment "Return B1 + B2, signal error on overflow";
command +(b1:bat[:oid,:sht],b2:bat[:oid,:flt],accum:int) :bat[:oid,:flt]
address CMDbatADDsignalaccum
comment "Return B1 + B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command add_noerror(b1:bat[:oid,:sht],b2:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatADD
comment "Return B1 + B2, overflow causes NIL value";
pattern +(b:bat[:oid,:sht],v:flt) :bat[:oid,:flt]
address CMDbatADDcstsignal
comment "Return B + V, signal error on overflow";
pattern add_noerror(b:bat[:oid,:sht],v:flt) :bat[:oid,:flt]
address CMDbatADDcst
comment "Return B + V, overflow causes NIL value";
pattern +(v:sht,b:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatADDcstsignal
comment "Return V + B, signal error on overflow";
pattern +(v:sht,b:bat[:oid,:flt],accum:int) :bat[:oid,:flt]
address CMDbatADDcstsignal
comment "Return V + B, signal error on overflow, reuse B if ACCUM is set";
pattern add_noerror(v:sht,b:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatADDcst
comment "Return V + B, overflow causes NIL value";

command +(b1:bat[:oid,:sht],b2:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatADDsignal
comment "Return B1 + B2, signal error on overflow";
command +(b1:bat[:oid,:sht],b2:bat[:oid,:dbl],accum:int) :bat[:oid,:dbl]
address CMDbatADDsignalaccum
comment "Return B1 + B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command add_noerror(b1:bat[:oid,:sht],b2:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatADD
comment "Return B1 + B2, overflow causes NIL value";
pattern +(b:bat[:oid,:sht],v:dbl) :bat[:oid,:dbl]
address CMDbatADDcstsignal
comment "Return B + V, signal error on overflow";
pattern add_noerror(b:bat[:oid,:sht],v:dbl) :bat[:oid,:dbl]
address CMDbatADDcst
comment "Return B + V, overflow causes NIL value";
pattern +(v:sht,b:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatADDcstsignal
comment "Return V + B, signal error on overflow";
pattern +(v:sht,b:bat[:oid,:dbl],accum:int) :bat[:oid,:dbl]
address CMDbatADDcstsignal
comment "Return V + B, signal error on overflow, reuse B if ACCUM is set";
pattern add_noerror(v:sht,b:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatADDcst
comment "Return V + B, overflow causes NIL value";

command +(b1:bat[:oid,:int],b2:bat[:oid,:bte]) :bat[:oid,:int]
address CMDbatADDsignal
comment "Return B1 + B2, signal error on overflow";
command +(b1:bat[:oid,:int],b2:bat[:oid,:bte],accum:int) :bat[:oid,:int]
address CMDbatADDsignalaccum
comment "Return B1 + B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command add_noerror(b1:bat[:oid,:int],b2:bat[:oid,:bte]) :bat[:oid,:int]
address CMDbatADD
comment "Return B1 + B2, overflow causes NIL value";
pattern +(b:bat[:oid,:int],v:bte) :bat[:oid,:int]
address CMDbatADDcstsignal
comment "Return B + V, signal error on overflow";
pattern +(b:bat[:oid,:int],v:bte,accum:int) :bat[:oid,:int]
address CMDbatADDcstsignal
comment "Return B + V, signal error on overflow, reuse B if ACCUM is set";
pattern add_noerror(b:bat[:oid,:int],v:bte) :bat[:oid,:int]
address CMDbatADDcst
comment "Return B + V, overflow causes NIL value";
pattern +(v:int,b:bat[:oid,:bte]) :bat[:oid,:int]
address CMDbatADDcstsignal
comment "Return V + B, signal error on overflow";
pattern add_noerror(v:int,b:bat[:oid,:bte]) :bat[:oid,:int]
address CMDbatADDcst
comment "Return V + B, overflow causes NIL value";

command +(b1:bat[:oid,:int],b2:bat[:oid,:sht]) :bat[:oid,:int]
address CMDbatADDsignal
comment "Return B1 + B2, signal error on overflow";
command +(b1:bat[:oid,:int],b2:bat[:oid,:sht],accum:int) :bat[:oid,:int]
address CMDbatADDsignalaccum
comment "Return B1 + B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command add_noerror(b1:bat[:oid,:int],b2:bat[:oid,:sht]) :bat[:oid,:int]
address CMDbatADD
comment "Return B1 + B2, overflow causes NIL value";
pattern +(b:bat[:oid,:int],v:sht) :bat[:oid,:int]
address CMDbatADDcstsignal
comment "Return B + V, signal error on overflow";
pattern +(b:bat[:oid,:int],v:sht,accum:int) :bat[:oid,:int]
address CMDbatADDcstsignal
comment "Return B + V, signal error on overflow, reuse B if ACCUM is set";
pattern add_noerror(b:bat[:oid,:int],v:sht) :bat[:oid,:int]
address CMDbatADDcst
comment "Return B + V, overflow causes NIL value";
pattern +(v:int,b:bat[:oid,:sht]) :bat[:oid,:int]
address CMDbatADDcstsignal
comment "Return V + B, signal error on overflow";
pattern add_noerror(v:int,b:bat[:oid,:sht]) :bat[:oid,:int]
address CMDbatADDcst
comment "Return V + B, overflow causes NIL value";

command +(b1:bat[:oid,:int],b2:bat[:oid,:int]) :bat[:oid,:int]
address CMDbatADDsignal
comment "Return B1 + B2, signal error on overflow";
command +(b1:bat[:oid,:int],b2:bat[:oid,:int],accum:int) :bat[:oid,:int]
address CMDbatADDsignalaccum
comment "Return B1 + B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command add_noerror(b1:bat[:oid,:int],b2:bat[:oid,:int]) :bat[:oid,:int]
address CMDbatADD
comment "Return B1 + B2, overflow causes NIL value";
pattern +(b:bat[:oid,:int],v:int) :bat[:oid,:int]
address CMDbatADDcstsignal
comment "Return B + V, signal error on overflow";
pattern +(b:bat[:oid,:int],v:int,accum:int) :bat[:oid,:int]
address CMDbatADDcstsignal
comment "Return B + V, signal error on overflow, reuse B if ACCUM is set";
pattern add_noerror(b:bat[:oid,:int],v:int) :bat[:oid,:int]
address CMDbatADDcst
comment "Return B + V, overflow causes NIL value";
pattern +(v:int,b:bat[:oid,:int]) :bat[:oid,:int]
address CMDbatADDcstsignal
comment "Return V + B, signal error on overflow";
pattern +(v:int,b:bat[:oid,:int],accum:int) :bat[:oid,:int]
address CMDbatADDcstsignal
comment "Return V + B, signal error on overflow, reuse B if ACCUM is set";
pattern add_noerror(v:int,b:bat[:oid,:int]) :bat[:oid,:int]
address CMDbatADDcst
comment "Return V + B, overflow causes NIL value";

command +(b1:bat[:oid,:int],b2:bat[:oid,:wrd]) :bat[:oid,:wrd]
address CMDbatADDsignal
comment "Return B1 + B2, signal error on overflow";
command +(b1:bat[:oid,:int],b2:bat[:oid,:wrd],accum:int) :bat[:oid,:wrd]
address CMDbatADDsignalaccum
comment "Return B1 + B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command add_noerror(b1:bat[:oid,:int],b2:bat[:oid,:wrd]) :bat[:oid,:wrd]
address CMDbatADD
comment "Return B1 + B2, overflow causes NIL value";
pattern +(b:bat[:oid,:int],v:wrd) :bat[:oid,:wrd]
address CMDbatADDcstsignal
comment "Return B + V, signal error on overflow";
pattern add_noerror(b:bat[:oid,:int],v:wrd) :bat[:oid,:wrd]
address CMDbatADDcst
comment "Return B + V, overflow causes NIL value";
pattern +(v:int,b:bat[:oid,:wrd]) :bat[:oid,:wrd]
address CMDbatADDcstsignal
comment "Return V + B, signal error on overflow";
pattern +(v:int,b:bat[:oid,:wrd],accum:int) :bat[:oid,:wrd]
address CMDbatADDcstsignal
comment "Return V + B, signal error on overflow, reuse B if ACCUM is set";
pattern add_noerror(v:int,b:bat[:oid,:wrd]) :bat[:oid,:wrd]
address CMDbatADDcst
comment "Return V + B, overflow causes NIL value";

command +(b1:bat[:oid,:int],b2:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatADDsignal
comment "Return B1 + B2, signal error on overflow";
command +(b1:bat[:oid,:int],b2:bat[:oid,:lng],accum:int) :bat[:oid,:lng]
address CMDbatADDsignalaccum
comment "Return B1 + B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command add_noerror(b1:bat[:oid,:int],b2:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatADD
comment "Return B1 + B2, overflow causes NIL value";
pattern +(b:bat[:oid,:int],v:lng) :bat[:oid,:lng]
address CMDbatADDcstsignal
comment "Return B + V, signal error on overflow";
pattern add_noerror(b:bat[:oid,:int],v:lng) :bat[:oid,:lng]
address CMDbatADDcst
comment "Return B + V, overflow causes NIL value";
pattern +(v:int,b:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatADDcstsignal
comment "Return V + B, signal error on overflow";
pattern +(v:int,b:bat[:oid,:lng],accum:int) :bat[:oid,:lng]
address CMDbatADDcstsignal
comment "Return V + B, signal error on overflow, reuse B if ACCUM is set";
pattern add_noerror(v:int,b:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatADDcst
comment "Return V + B, overflow causes NIL value";

command +(b1:bat[:oid,:int],b2:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatADDsignal
comment "Return B1 + B2, signal error on overflow";
command +(b1:bat[:oid,:int],b2:bat[:oid,:flt],accum:int) :bat[:oid,:flt]
address CMDbatADDsignalaccum
comment "Return B1 + B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command add_noerror(b1:bat[:oid,:int],b2:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatADD
comment "Return B1 + B2, overflow causes NIL value";
pattern +(b:bat[:oid,:int],v:flt) :bat[:oid,:flt]
address CMDbatADDcstsignal
comment "Return B + V, signal error on overflow";
pattern add_noerror(b:bat[:oid,:int],v:flt) :bat[:oid,:flt]
address CMDbatADDcst
comment "Return B + V, overflow causes NIL value";
pattern +(v:int,b:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatADDcstsignal
comment "Return V + B, signal error on overflow";
pattern +(v:int,b:bat[:oid,:flt],accum:int) :bat[:oid,:flt]
address CMDbatADDcstsignal
comment "Return V + B, signal error on overflow, reuse B if ACCUM is set";
pattern add_noerror(v:int,b:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatADDcst
comment "Return V + B, overflow causes NIL value";

command +(b1:bat[:oid,:int],b2:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatADDsignal
comment "Return B1 + B2, signal error on overflow";
command +(b1:bat[:oid,:int],b2:bat[:oid,:dbl],accum:int) :bat[:oid,:dbl]
address CMDbatADDsignalaccum
comment "Return B1 + B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command add_noerror(b1:bat[:oid,:int],b2:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatADD
comment "Return B1 + B2, overflow causes NIL value";
pattern +(b:bat[:oid,:int],v:dbl) :bat[:oid,:dbl]
address CMDbatADDcstsignal
comment "Return B + V, signal error on overflow";
pattern add_noerror(b:bat[:oid,:int],v:dbl) :bat[:oid,:dbl]
address CMDbatADDcst
comment "Return B + V, overflow causes NIL value";
pattern +(v:int,b:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatADDcstsignal
comment "Return V + B, signal error on overflow";
pattern +(v:int,b:bat[:oid,:dbl],accum:int) :bat[:oid,:dbl]
address CMDbatADDcstsignal
comment "Return V + B, signal error on overflow, reuse B if ACCUM is set";
pattern add_noerror(v:int,b:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatADDcst
comment "Return V + B, overflow causes NIL value";

command +(b1:bat[:oid,:wrd],b2:bat[:oid,:bte]) :bat[:oid,:wrd]
address CMDbatADDsignal
comment "Return B1 + B2, signal error on overflow";
command +(b1:bat[:oid,:wrd],b2:bat[:oid,:bte],accum:int) :bat[:oid,:wrd]
address CMDbatADDsignalaccum
comment "Return B1 + B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command add_noerror(b1:bat[:oid,:wrd],b2:bat[:oid,:bte]) :bat[:oid,:wrd]
address CMDbatADD
comment "Return B1 + B2, overflow causes NIL value";
pattern +(b:bat[:oid,:wrd],v:bte) :bat[:oid,:wrd]
address CMDbatADDcstsignal
comment "Return B + V, signal error on overflow";
pattern +(b:bat[:oid,:wrd],v:bte,accum:int) :bat[:oid,:wrd]
address CMDbatADDcstsignal
comment "Return B + V, signal error on overflow, reuse B if ACCUM is set";
pattern add_noerror(b:bat[:oid,:wrd],v:bte) :bat[:oid,:wrd]
address CMDbatADDcst
comment "Return B + V, overflow causes NIL value";
pattern +(v:wrd,b:bat[:oid,:bte]) :bat[:oid,:wrd]
address CMDbatADDcstsignal
comment "Return V + B, signal error on overflow";
pattern add_noerror(v:wrd,b:bat[:oid,:bte]) :bat[:oid,:wrd]
address CMDbatADDcst
comment "Return V + B, overflow causes NIL value";

command +(b1:bat[:oid,:wrd],b2:bat[:oid,:sht]) :bat[:oid,:wrd]
address CMDbatADDsignal
comment "Return B1 + B2, signal error on overflow";
command +(b1:bat[:oid,:wrd],b2:bat[:oid,:sht],accum:int) :bat[:oid,:wrd]
address CMDbatADDsignalaccum
comment "Return B1 + B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command add_noerror(b1:bat[:oid,:wrd],b2:bat[:oid,:sht]) :bat[:oid,:wrd]
address CMDbatADD
comment "Return B1 + B2, overflow causes NIL value";
pattern +(b:bat[:oid,:wrd],v:sht) :bat[:oid,:wrd]
address CMDbatADDcstsignal
comment "Return B + V, signal error on overflow";
pattern +(b:bat[:oid,:wrd],v:sht,accum:int) :bat[:oid,:wrd]
address CMDbatADDcstsignal
comment "Return B + V, signal error on overflow, reuse B if ACCUM is set";
pattern add_noerror(b:bat[:oid,:wrd],v:sht) :bat[:oid,:wrd]
address CMDbatADDcst
comment "Return B + V, overflow causes NIL value";
pattern +(v:wrd,b:bat[:oid,:sht]) :bat[:oid,:wrd]
address CMDbatADDcstsignal
comment "Return V + B, signal error on overflow";
pattern add_noerror(v:wrd,b:bat[:oid,:sht]) :bat[:oid,:wrd]
address CMDbatADDcst
comment "Return V + B, overflow causes NIL value";

command +(b1:bat[:oid,:wrd],b2:bat[:oid,:int]) :bat[:oid,:wrd]
address CMDbatADDsignal
comment "Return B1 + B2, signal error on overflow";
command +(b1:bat[:oid,:wrd],b2:bat[:oid,:int],accum:int) :bat[:oid,:wrd]
address CMDbatADDsignalaccum
comment "Return B1 + B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command add_noerror(b1:bat[:oid,:wrd],b2:bat[:oid,:int]) :bat[:oid,:wrd]
address CMDbatADD
comment "Return B1 + B2, overflow causes NIL value";
pattern +(b:bat[:oid,:wrd],v:int) :bat[:oid,:wrd]
address CMDbatADDcstsignal
comment "Return B + V, signal error on overflow";
pattern +(b:bat[:oid,:wrd],v:int,accum:int) :bat[:oid,:wrd]
address CMDbatADDcstsignal
comment "Return B + V, signal error on overflow, reuse B if ACCUM is set";
pattern add_noerror(b:bat[:oid,:wrd],v:int) :bat[:oid,:wrd]
address CMDbatADDcst
comment "Return B + V, overflow causes NIL value";
pattern +(v:wrd,b:bat[:oid,:int]) :bat[:oid,:wrd]
address CMDbatADDcstsignal
comment "Return V + B, signal error on overflow";
pattern add_noerror(v:wrd,b:bat[:oid,:int]) :bat[:oid,:wrd]
address CMDbatADDcst
comment "Return V + B, overflow causes NIL value";

command +(b1:bat[:oid,:wrd],b2:bat[:oid,:wrd]) :bat[:oid,:wrd]
address CMDbatADDsignal
comment "Return B1 + B2, signal error on overflow";
command +(b1:bat[:oid,:wrd],b2:bat[:oid,:wrd],accum:int) :bat[:oid,:wrd]
address CMDbatADDsignalaccum
comment "Return B1 + B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command add_noerror(b1:bat[:oid,:wrd],b2:bat[:oid,:wrd]) :bat[:oid,:wrd]
address CMDbatADD
comment "Return B1 + B2, overflow causes NIL value";
pattern +(b:bat[:oid,:wrd],v:wrd) :bat[:oid,:wrd]
address CMDbatADDcstsignal
comment "Return B + V, signal error on overflow";
pattern +(b:bat[:oid,:wrd],v:wrd,accum:int) :bat[:oid,:wrd]
address CMDbatADDcstsignal
comment "Return B + V, signal error on overflow, reuse B if ACCUM is set";
pattern add_noerror(b:bat[:oid,:wrd],v:wrd) :bat[:oid,:wrd]
address CMDbatADDcst
comment "Return B + V, overflow causes NIL value";
pattern +(v:wrd,b:bat[:oid,:wrd]) :bat[:oid,:wrd]
address CMDbatADDcstsignal
comment "Return V + B, signal error on overflow";
pattern +(v:wrd,b:bat[:oid,:wrd],accum:int) :bat[:oid,:wrd]
address CMDbatADDcstsignal
comment "Return V + B, signal error on overflow, reuse B if ACCUM is set";
pattern add_noerror(v:wrd,b:bat[:oid,:wrd]) :bat[:oid,:wrd]
address CMDbatADDcst
comment "Return V + B, overflow causes NIL value";

command +(b1:bat[:oid,:wrd],b2:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatADDsignal
comment "Return B1 + B2, signal error on overflow";
command +(b1:bat[:oid,:wrd],b2:bat[:oid,:lng],accum:int) :bat[:oid,:lng]
address CMDbatADDsignalaccum
comment "Return B1 + B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command add_noerror(b1:bat[:oid,:wrd],b2:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatADD
comment "Return B1 + B2, overflow causes NIL value";
pattern +(b:bat[:oid,:wrd],v:lng) :bat[:oid,:lng]
address CMDbatADDcstsignal
comment "Return B + V, signal error on overflow";
pattern add_noerror(b:bat[:oid,:wrd],v:lng) :bat[:oid,:lng]
address CMDbatADDcst
comment "Return B + V, overflow causes NIL value";
pattern +(v:wrd,b:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatADDcstsignal
comment "Return V + B, signal error on overflow";
pattern +(v:wrd,b:bat[:oid,:lng],accum:int) :bat[:oid,:lng]
address CMDbatADDcstsignal
comment "Return V + B, signal error on overflow, reuse B if ACCUM is set";
pattern add_noerror(v:wrd,b:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatADDcst
comment "Return V + B, overflow causes NIL value";

command +(b1:bat[:oid,:wrd],b2:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatADDsignal
comment "Return B1 + B2, signal error on overflow";
command +(b1:bat[:oid,:wrd],b2:bat[:oid,:flt],accum:int) :bat[:oid,:flt]
address CMDbatADDsignalaccum
comment "Return B1 + B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command add_noerror(b1:bat[:oid,:wrd],b2:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatADD
comment "Return B1 + B2, overflow causes NIL value";
pattern +(b:bat[:oid,:wrd],v:flt) :bat[:oid,:flt]
address CMDbatADDcstsignal
comment "Return B + V, signal error on overflow";
pattern add_noerror(b:bat[:oid,:wrd],v:flt) :bat[:oid,:flt]
address CMDbatADDcst
comment "Return B + V, overflow causes NIL value";
pattern +(v:wrd,b:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatADDcstsignal
comment "Return V + B, signal error on overflow";
pattern +(v:wrd,b:bat[:oid,:flt],accum:int) :bat[:oid,:flt]
address CMDbatADDcstsignal
comment "Return V + B, signal error on overflow, reuse B if ACCUM is set";
pattern add_noerror(v:wrd,b:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatADDcst
comment "Return V + B, overflow causes NIL value";

command +(b1:bat[:oid,:wrd],b2:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatADDsignal
comment "Return B1 + B2, signal error on overflow";
command +(b1:bat[:oid,:wrd],b2:bat[:oid,:dbl],accum:int) :bat[:oid,:dbl]
address CMDbatADDsignalaccum
comment "Return B1 + B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command add_noerror(b1:bat[:oid,:wrd],b2:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatADD
comment "Return B1 + B2, overflow causes NIL value";
pattern +(b:bat[:oid,:wrd],v:dbl) :bat[:oid,:dbl]
address CMDbatADDcstsignal
comment "Return B + V, signal error on overflow";
pattern add_noerror(b:bat[:oid,:wrd],v:dbl) :bat[:oid,:dbl]
address CMDbatADDcst
comment "Return B + V, overflow causes NIL value";
pattern +(v:wrd,b:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatADDcstsignal
comment "Return V + B, signal error on overflow";
pattern +(v:wrd,b:bat[:oid,:dbl],accum:int) :bat[:oid,:dbl]
address CMDbatADDcstsignal
comment "Return V + B, signal error on overflow, reuse B if ACCUM is set";
pattern add_noerror(v:wrd,b:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatADDcst
comment "Return V + B, overflow causes NIL value";

command +(b1:bat[:oid,:lng],b2:bat[:oid,:bte]) :bat[:oid,:lng]
address CMDbatADDsignal
comment "Return B1 + B2, signal error on overflow";
command +(b1:bat[:oid,:lng],b2:bat[:oid,:bte],accum:int) :bat[:oid,:lng]
address CMDbatADDsignalaccum
comment "Return B1 + B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command add_noerror(b1:bat[:oid,:lng],b2:bat[:oid,:bte]) :bat[:oid,:lng]
address CMDbatADD
comment "Return B1 + B2, overflow causes NIL value";
pattern +(b:bat[:oid,:lng],v:bte) :bat[:oid,:lng]
address CMDbatADDcstsignal
comment "Return B + V, signal error on overflow";
pattern +(b:bat[:oid,:lng],v:bte,accum:int) :bat[:oid,:lng]
address CMDbatADDcstsignal
comment "Return B + V, signal error on overflow, reuse B if ACCUM is set";
pattern add_noerror(b:bat[:oid,:lng],v:bte) :bat[:oid,:lng]
address CMDbatADDcst
comment "Return B + V, overflow causes NIL value";
pattern +(v:lng,b:bat[:oid,:bte]) :bat[:oid,:lng]
address CMDbatADDcstsignal
comment "Return V + B, signal error on overflow";
pattern add_noerror(v:lng,b:bat[:oid,:bte]) :bat[:oid,:lng]
address CMDbatADDcst
comment "Return V + B, overflow causes NIL value";

command +(b1:bat[:oid,:lng],b2:bat[:oid,:sht]) :bat[:oid,:lng]
address CMDbatADDsignal
comment "Return B1 + B2, signal error on overflow";
command +(b1:bat[:oid,:lng],b2:bat[:oid,:sht],accum:int) :bat[:oid,:lng]
address CMDbatADDsignalaccum
comment "Return B1 + B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command add_noerror(b1:bat[:oid,:lng],b2:bat[:oid,:sht]) :bat[:oid,:lng]
address CMDbatADD
comment "Return B1 + B2, overflow causes NIL value";
pattern +(b:bat[:oid,:lng],v:sht) :bat[:oid,:lng]
address CMDbatADDcstsignal
comment "Return B + V, signal error on overflow";
pattern +(b:bat[:oid,:lng],v:sht,accum:int) :bat[:oid,:lng]
address CMDbatADDcstsignal
comment "Return B + V, signal error on overflow, reuse B if ACCUM is set";
pattern add_noerror(b:bat[:oid,:lng],v:sht) :bat[:oid,:lng]
address CMDbatADDcst
comment "Return B + V, overflow causes NIL value";
pattern +(v:lng,b:bat[:oid,:sht]) :bat[:oid,:lng]
address CMDbatADDcstsignal
comment "Return V + B, signal error on overflow";
pattern add_noerror(v:lng,b:bat[:oid,:sht]) :bat[:oid,:lng]
address CMDbatADDcst
comment "Return V + B, overflow causes NIL value";

command +(b1:bat[:oid,:lng],b2:bat[:oid,:int]) :bat[:oid,:lng]
address CMDbatADDsignal
comment "Return B1 + B2, signal error on overflow";
command +(b1:bat[:oid,:lng],b2:bat[:oid,:int],accum:int) :bat[:oid,:lng]
address CMDbatADDsignalaccum
comment "Return B1 + B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command add_noerror(b1:bat[:oid,:lng],b2:bat[:oid,:int]) :bat[:oid,:lng]
address CMDbatADD
comment "Return B1 + B2, overflow causes NIL value";
pattern +(b:bat[:oid,:lng],v:int) :bat[:oid,:lng]
address CMDbatADDcstsignal
comment "Return B + V, signal error on overflow";
pattern +(b:bat[:oid,:lng],v:int,accum:int) :bat[:oid,:lng]
address CMDbatADDcstsignal
comment "Return B + V, signal error on overflow, reuse B if ACCUM is set";
pattern add_noerror(b:bat[:oid,:lng],v:int) :bat[:oid,:lng]
address CMDbatADDcst
comment "Return B + V, overflow causes NIL value";
pattern +(v:lng,b:bat[:oid,:int]) :bat[:oid,:lng]
address CMDbatADDcstsignal
comment "Return V + B, signal error on overflow";
pattern add_noerror(v:lng,b:bat[:oid,:int]) :bat[:oid,:lng]
address CMDbatADDcst
comment "Return V + B, overflow causes NIL value";

command +(b1:bat[:oid,:lng],b2:bat[:oid,:wrd]) :bat[:oid,:lng]
address CMDbatADDsignal
comment "Return B1 + B2, signal error on overflow";
command +(b1:bat[:oid,:lng],b2:bat[:oid,:wrd],accum:int) :bat[:oid,:lng]
address CMDbatADDsignalaccum
comment "Return B1 + B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command add_noerror(b1:bat[:oid,:lng],b2:bat[:oid,:wrd]) :bat[:oid,:lng]
address CMDbatADD
comment "Return B1 + B2, overflow causes NIL value";
pattern +(b:bat[:oid,:lng],v:wrd) :bat[:oid,:lng]
address CMDbatADDcstsignal
comment "Return B + V, signal error on overflow";
pattern +(b:bat[:oid,:lng],v:wrd,accum:int) :bat[:oid,:lng]
address CMDbatADDcstsignal
comment "Return B + V, signal error on overflow, reuse B if ACCUM is set";
pattern add_noerror(b:bat[:oid,:lng],v:wrd) :bat[:oid,:lng]
address CMDbatADDcst
comment "Return B + V, overflow causes NIL value";
pattern +(v:lng,b:bat[:oid,:wrd]) :bat[:oid,:lng]
address CMDbatADDcstsignal
comment "Return V + B, signal error on overflow";
pattern add_noerror(v:lng,b:bat[:oid,:wrd]) :bat[:oid,:lng]
address CMDbatADDcst
comment "Return V + B, overflow causes NIL value";

command +(b1:bat[:oid,:lng],b2:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatADDsignal
comment "Return B1 + B2, signal error on overflow";
command +(b1:bat[:oid,:lng],b2:bat[:oid,:lng],accum:int) :bat[:oid,:lng]
address CMDbatADDsignalaccum
comment "Return B1 + B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command add_noerror(b1:bat[:oid,:lng],b2:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatADD
comment "Return B1 + B2, overflow causes NIL value";
pattern +(b:bat[:oid,:lng],v:lng) :bat[:oid,:lng]
address CMDbatADDcstsignal
comment "Return B + V, signal error on overflow";
pattern +(b:bat[:oid,:lng],v:lng,accum:int) :bat[:oid,:lng]
address CMDbatADDcstsignal
comment "Return B + V, signal error on overflow, reuse B if ACCUM is set";
pattern add_noerror(b:bat[:oid,:lng],v:lng) :bat[:oid,:lng]
address CMDbatADDcst
comment "Return B + V, overflow causes NIL value";
pattern +(v:lng,b:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatADDcstsignal
comment "Return V + B, signal error on overflow";
pattern +(v:lng,b:bat[:oid,:lng],accum:int) :bat[:oid,:lng]
address CMDbatADDcstsignal
comment "Return V + B, signal error on overflow, reuse B if ACCUM is set";
pattern add_noerror(v:lng,b:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatADDcst
comment "Return V + B, overflow causes NIL value";

command +(b1:bat[:oid,:lng],b2:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatADDsignal
comment "Return B1 + B2, signal error on overflow";
command +(b1:bat[:oid,:lng],b2:bat[:oid,:flt],accum:int) :bat[:oid,:flt]
address CMDbatADDsignalaccum
comment "Return B1 + B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command add_noerror(b1:bat[:oid,:lng],b2:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatADD
comment "Return B1 + B2, overflow causes NIL value";
pattern +(b:bat[:oid,:lng],v:flt) :bat[:oid,:flt]
address CMDbatADDcstsignal
comment "Return B + V, signal error on overflow";
pattern add_noerror(b:bat[:oid,:lng],v:flt) :bat[:oid,:flt]
address CMDbatADDcst
comment "Return B + V, overflow causes NIL value";
pattern +(v:lng,b:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatADDcstsignal
comment "Return V + B, signal error on overflow";
pattern +(v:lng,b:bat[:oid,:flt],accum:int) :bat[:oid,:flt]
address CMDbatADDcstsignal
comment "Return V + B, signal error on overflow, reuse B if ACCUM is set";
pattern add_noerror(v:lng,b:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatADDcst
comment "Return V + B, overflow causes NIL value";

command +(b1:bat[:oid,:lng],b2:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatADDsignal
comment "Return B1 + B2, signal error on overflow";
command +(b1:bat[:oid,:lng],b2:bat[:oid,:dbl],accum:int) :bat[:oid,:dbl]
address CMDbatADDsignalaccum
comment "Return B1 + B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command add_noerror(b1:bat[:oid,:lng],b2:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatADD
comment "Return B1 + B2, overflow causes NIL value";
pattern +(b:bat[:oid,:lng],v:dbl) :bat[:oid,:dbl]
address CMDbatADDcstsignal
comment "Return B + V, signal error on overflow";
pattern add_noerror(b:bat[:oid,:lng],v:dbl) :bat[:oid,:dbl]
address CMDbatADDcst
comment "Return B + V, overflow causes NIL value";
pattern +(v:lng,b:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatADDcstsignal
comment "Return V + B, signal error on overflow";
pattern +(v:lng,b:bat[:oid,:dbl],accum:int) :bat[:oid,:dbl]
address CMDbatADDcstsignal
comment "Return V + B, signal error on overflow, reuse B if ACCUM is set";
pattern add_noerror(v:lng,b:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatADDcst
comment "Return V + B, overflow causes NIL value";

command +(b1:bat[:oid,:flt],b2:bat[:oid,:bte]) :bat[:oid,:flt]
address CMDbatADDsignal
comment "Return B1 + B2, signal error on overflow";
command +(b1:bat[:oid,:flt],b2:bat[:oid,:bte],accum:int) :bat[:oid,:flt]
address CMDbatADDsignalaccum
comment "Return B1 + B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command add_noerror(b1:bat[:oid,:flt],b2:bat[:oid,:bte]) :bat[:oid,:flt]
address CMDbatADD
comment "Return B1 + B2, overflow causes NIL value";
pattern +(b:bat[:oid,:flt],v:bte) :bat[:oid,:flt]
address CMDbatADDcstsignal
comment "Return B + V, signal error on overflow";
pattern +(b:bat[:oid,:flt],v:bte,accum:int) :bat[:oid,:flt]
address CMDbatADDcstsignal
comment "Return B + V, signal error on overflow, reuse B if ACCUM is set";
pattern add_noerror(b:bat[:oid,:flt],v:bte) :bat[:oid,:flt]
address CMDbatADDcst
comment "Return B + V, overflow causes NIL value";
pattern +(v:flt,b:bat[:oid,:bte]) :bat[:oid,:flt]
address CMDbatADDcstsignal
comment "Return V + B, signal error on overflow";
pattern add_noerror(v:flt,b:bat[:oid,:bte]) :bat[:oid,:flt]
address CMDbatADDcst
comment "Return V + B, overflow causes NIL value";

command +(b1:bat[:oid,:flt],b2:bat[:oid,:sht]) :bat[:oid,:flt]
address CMDbatADDsignal
comment "Return B1 + B2, signal error on overflow";
command +(b1:bat[:oid,:flt],b2:bat[:oid,:sht],accum:int) :bat[:oid,:flt]
address CMDbatADDsignalaccum
comment "Return B1 + B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command add_noerror(b1:bat[:oid,:flt],b2:bat[:oid,:sht]) :bat[:oid,:flt]
address CMDbatADD
comment "Return B1 + B2, overflow causes NIL value";
pattern +(b:bat[:oid,:flt],v:sht) :bat[:oid,:flt]
address CMDbatADDcstsignal
comment "Return B + V, signal error on overflow";
pattern +(b:bat[:oid,:flt],v:sht,accum:int) :bat[:oid,:flt]
address CMDbatADDcstsignal
comment "Return B + V, signal error on overflow, reuse B if ACCUM is set";
pattern add_noerror(b:bat[:oid,:flt],v:sht) :bat[:oid,:flt]
address CMDbatADDcst
comment "Return B + V, overflow causes NIL value";
pattern +(v:flt,b:bat[:oid,:sht]) :bat[:oid,:flt]
address CMDbatADDcstsignal
comment "Return V + B, signal error on overflow";
pattern add_noerror(v:flt,b:bat[:oid,:sht]) :bat[:oid,:flt]
address CMDbatADDcst
comment "Return V + B, overflow causes NIL value";

command +(b1:bat[:oid,:flt],b2:bat[:oid,:int]) :bat[:oid,:flt]
address CMDbatADDsignal
comment "Return B1 + B2, signal error on overflow";
command +(b1:bat[:oid,:flt],b2:bat[:oid,:int],accum:int) :bat[:oid,:flt]
address CMDbatADDsignalaccum
comment "Return B1 + B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command add_noerror(b1:bat[:oid,:flt],b2:bat[:oid,:int]) :bat[:oid,:flt]
address CMDbatADD
comment "Return B1 + B2, overflow causes NIL value";
pattern +(b:bat[:oid,:flt],v:int) :bat[:oid,:flt]
address CMDbatADDcstsignal
comment "Return B + V, signal error on overflow";
pattern +(b:bat[:oid,:flt],v:int,accum:int) :bat[:oid,:flt]
address CMDbatADDcstsignal
comment "Return B + V, signal error on overflow, reuse B if ACCUM is set";
pattern add_noerror(b:bat[:oid,:flt],v:int) :bat[:oid,:flt]
address CMDbatADDcst
comment "Return B + V, overflow causes NIL value";
pattern +(v:flt,b:bat[:oid,:int]) :bat[:oid,:flt]
address CMDbatADDcstsignal
comment "Return V + B, signal error on overflow";
pattern add_noerror(v:flt,b:bat[:oid,:int]) :bat[:oid,:flt]
address CMDbatADDcst
comment "Return V + B, overflow causes NIL value";

command +(b1:bat[:oid,:flt],b2:bat[:oid,:wrd]) :bat[:oid,:flt]
address CMDbatADDsignal
comment "Return B1 + B2, signal error on overflow";
command +(b1:bat[:oid,:flt],b2:bat[:oid,:wrd],accum:int) :bat[:oid,:flt]
address CMDbatADDsignalaccum
comment "Return B1 + B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command add_noerror(b1:bat[:oid,:flt],b2:bat[:oid,:wrd]) :bat[:oid,:flt]
address CMDbatADD
comment "Return B1 + B2, overflow causes NIL value";
pattern +(b:bat[:oid,:flt],v:wrd) :bat[:oid,:flt]
address CMDbatADDcstsignal
comment "Return B + V, signal error on overflow";
pattern +(b:bat[:oid,:flt],v:wrd,accum:int) :bat[:oid,:flt]
address CMDbatADDcstsignal
comment "Return B + V, signal error on overflow, reuse B if ACCUM is set";
pattern add_noerror(b:bat[:oid,:flt],v:wrd) :bat[:oid,:flt]
address CMDbatADDcst
comment "Return B + V, overflow causes NIL value";
pattern +(v:flt,b:bat[:oid,:wrd]) :bat[:oid,:flt]
address CMDbatADDcstsignal
comment "Return V + B, signal error on overflow";
pattern add_noerror(v:flt,b:bat[:oid,:wrd]) :bat[:oid,:flt]
address CMDbatADDcst
comment "Return V + B, overflow causes NIL value";

command +(b1:bat[:oid,:flt],b2:bat[:oid,:lng]) :bat[:oid,:flt]
address CMDbatADDsignal
comment "Return B1 + B2, signal error on overflow";
command +(b1:bat[:oid,:flt],b2:bat[:oid,:lng],accum:int) :bat[:oid,:flt]
address CMDbatADDsignalaccum
comment "Return B1 + B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command add_noerror(b1:bat[:oid,:flt],b2:bat[:oid,:lng]) :bat[:oid,:flt]
address CMDbatADD
comment "Return B1 + B2, overflow causes NIL value";
pattern +(b:bat[:oid,:flt],v:lng) :bat[:oid,:flt]
address CMDbatADDcstsignal
comment "Return B + V, signal error on overflow";
pattern +(b:bat[:oid,:flt],v:lng,accum:int) :bat[:oid,:flt]
address CMDbatADDcstsignal
comment "Return B + V, signal error on overflow, reuse B if ACCUM is set";
pattern add_noerror(b:bat[:oid,:flt],v:lng) :bat[:oid,:flt]
address CMDbatADDcst
comment "Return B + V, overflow causes NIL value";
pattern +(v:flt,b:bat[:oid,:lng]) :bat[:oid,:flt]
address CMDbatADDcstsignal
comment "Return V + B, signal error on overflow";
pattern add_noerror(v:flt,b:bat[:oid,:lng]) :bat[:oid,:flt]
address CMDbatADDcst
comment "Return V + B, overflow causes NIL value";

command +(b1:bat[:oid,:flt],b2:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatADDsignal
comment "Return B1 + B2, signal error on overflow";
command +(b1:bat[:oid,:flt],b2:bat[:oid,:flt],accum:int) :bat[:oid,:flt]
address CMDbatADDsignalaccum
comment "Return B1 + B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command add_noerror(b1:bat[:oid,:flt],b2:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatADD
comment "Return B1 + B2, overflow causes NIL value";
pattern +(b:bat[:oid,:flt],v:flt) :bat[:oid,:flt]
address CMDbatADDcstsignal
comment "Return B + V, signal error on overflow";
pattern +(b:bat[:oid,:flt],v:flt,accum:int) :bat[:oid,:flt]
address CMDbatADDcstsignal
comment "Return B + V, signal error on overflow, reuse B if ACCUM is set";
pattern add_noerror(b:bat[:oid,:flt],v:flt) :bat[:oid,:flt]
address CMDbatADDcst
comment "Return B + V, overflow causes NIL value";
pattern +(v:flt,b:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatADDcstsignal
comment "Return V + B, signal error on overflow";
pattern +(v:flt,b:bat[:oid,:flt],accum:int) :bat[:oid,:flt]
address CMDbatADDcstsignal
comment "Return V + B, signal error on overflow, reuse B if ACCUM is set";
pattern add_noerror(v:flt,b:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatADDcst
comment "Return V + B, overflow causes NIL value";

command +(b1:bat[:oid,:flt],b2:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatADDsignal
comment "Return B1 + B2, signal error on overflow";
command +(b1:bat[:oid,:flt],b2:bat[:oid,:dbl],accum:int) :bat[:oid,:dbl]
address CMDbatADDsignalaccum
comment "Return B1 + B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command add_noerror(b1:bat[:oid,:flt],b2:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatADD
comment "Return B1 + B2, overflow causes NIL value";
pattern +(b:bat[:oid,:flt],v:dbl) :bat[:oid,:dbl]
address CMDbatADDcstsignal
comment "Return B + V, signal error on overflow";
pattern add_noerror(b:bat[:oid,:flt],v:dbl) :bat[:oid,:dbl]
address CMDbatADDcst
comment "Return B + V, overflow causes NIL value";
pattern +(v:flt,b:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatADDcstsignal
comment "Return V + B, signal error on overflow";
pattern +(v:flt,b:bat[:oid,:dbl],accum:int) :bat[:oid,:dbl]
address CMDbatADDcstsignal
comment "Return V + B, signal error on overflow, reuse B if ACCUM is set";
pattern add_noerror(v:flt,b:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatADDcst
comment "Return V + B, overflow causes NIL value";

command +(b1:bat[:oid,:dbl],b2:bat[:oid,:bte]) :bat[:oid,:dbl]
address CMDbatADDsignal
comment "Return B1 + B2, signal error on overflow";
command +(b1:bat[:oid,:dbl],b2:bat[:oid,:bte],accum:int) :bat[:oid,:dbl]
address CMDbatADDsignalaccum
comment "Return B1 + B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command add_noerror(b1:bat[:oid,:dbl],b2:bat[:oid,:bte]) :bat[:oid,:dbl]
address CMDbatADD
comment "Return B1 + B2, overflow causes NIL value";
pattern +(b:bat[:oid,:dbl],v:bte) :bat[:oid,:dbl]
address CMDbatADDcstsignal
comment "Return B + V, signal error on overflow";
pattern +(b:bat[:oid,:dbl],v:bte,accum:int) :bat[:oid,:dbl]
address CMDbatADDcstsignal
comment "Return B + V, signal error on overflow, reuse B if ACCUM is set";
pattern add_noerror(b:bat[:oid,:dbl],v:bte) :bat[:oid,:dbl]
address CMDbatADDcst
comment "Return B + V, overflow causes NIL value";
pattern +(v:dbl,b:bat[:oid,:bte]) :bat[:oid,:dbl]
address CMDbatADDcstsignal
comment "Return V + B, signal error on overflow";
pattern add_noerror(v:dbl,b:bat[:oid,:bte]) :bat[:oid,:dbl]
address CMDbatADDcst
comment "Return V + B, overflow causes NIL value";

command +(b1:bat[:oid,:dbl],b2:bat[:oid,:sht]) :bat[:oid,:dbl]
address CMDbatADDsignal
comment "Return B1 + B2, signal error on overflow";
command +(b1:bat[:oid,:dbl],b2:bat[:oid,:sht],accum:int) :bat[:oid,:dbl]
address CMDbatADDsignalaccum
comment "Return B1 + B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command add_noerror(b1:bat[:oid,:dbl],b2:bat[:oid,:sht]) :bat[:oid,:dbl]
address CMDbatADD
comment "Return B1 + B2, overflow causes NIL value";
pattern +(b:bat[:oid,:dbl],v:sht) :bat[:oid,:dbl]
address CMDbatADDcstsignal
comment "Return B + V, signal error on overflow";
pattern +(b:bat[:oid,:dbl],v:sht,accum:int) :bat[:oid,:dbl]
address CMDbatADDcstsignal
comment "Return B + V, signal error on overflow, reuse B if ACCUM is set";
pattern add_noerror(b:bat[:oid,:dbl],v:sht) :bat[:oid,:dbl]
address CMDbatADDcst
comment "Return B + V, overflow causes NIL value";
pattern +(v:dbl,b:bat[:oid,:sht]) :bat[:oid,:dbl]
address CMDbatADDcstsignal
comment "Return V + B, signal error on overflow";
pattern add_noerror(v:dbl,b:bat[:oid,:sht]) :bat[:oid,:dbl]
address CMDbatADDcst
comment "Return V + B, overflow causes NIL value";

command +(b1:bat[:oid,:dbl],b2:bat[:oid,:int]) :bat[:oid,:dbl]
address CMDbatADDsignal
comment "Return B1 + B2, signal error on overflow";
command +(b1:bat[:oid,:dbl],b2:bat[:oid,:int],accum:int) :bat[:oid,:dbl]
address CMDbatADDsignalaccum
comment "Return B1 + B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command add_noerror(b1:bat[:oid,:dbl],b2:bat[:oid,:int]) :bat[:oid,:dbl]
address CMDbatADD
comment "Return B1 + B2, overflow causes NIL value";
pattern +(b:bat[:oid,:dbl],v:int) :bat[:oid,:dbl]
address CMDbatADDcstsignal
comment "Return B + V, signal error on overflow";
pattern +(b:bat[:oid,:dbl],v:int,accum:int) :bat[:oid,:dbl]
address CMDbatADDcstsignal
comment "Return B + V, signal error on overflow, reuse B if ACCUM is set";
pattern add_noerror(b:bat[:oid,:dbl],v:int) :bat[:oid,:dbl]
address CMDbatADDcst
comment "Return B + V, overflow causes NIL value";
pattern +(v:dbl,b:bat[:oid,:int]) :bat[:oid,:dbl]
address CMDbatADDcstsignal
comment "Return V + B, signal error on overflow";
pattern add_noerror(v:dbl,b:bat[:oid,:int]) :bat[:oid,:dbl]
address CMDbatADDcst
comment "Return V + B, overflow causes NIL value";

command +(b1:bat[:oid,:dbl],b2:bat[:oid,:wrd]) :bat[:oid,:dbl]
address CMDbatADDsignal
comment "Return B1 + B2, signal error on overflow";
command +(b1:bat[:oid,:dbl],b2:bat[:oid,:wrd],accum:int) :bat[:oid,:dbl]
address CMDbatADDsignalaccum
comment "Return B1 + B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command add_noerror(b1:bat[:oid,:dbl],b2:bat[:oid,:wrd]) :bat[:oid,:dbl]
address CMDbatADD
comment "Return B1 + B2, overflow causes NIL value";
pattern +(b:bat[:oid,:dbl],v:wrd) :bat[:oid,:dbl]
address CMDbatADDcstsignal
comment "Return B + V, signal error on overflow";
pattern +(b:bat[:oid,:dbl],v:wrd,accum:int) :bat[:oid,:dbl]
address CMDbatADDcstsignal
comment "Return B + V, signal error on overflow, reuse B if ACCUM is set";
pattern add_noerror(b:bat[:oid,:dbl],v:wrd) :bat[:oid,:dbl]
address CMDbatADDcst
comment "Return B + V, overflow causes NIL value";
pattern +(v:dbl,b:bat[:oid,:wrd]) :bat[:oid,:dbl]
address CMDbatADDcstsignal
comment "Return V + B, signal error on overflow";
pattern add_noerror(v:dbl,b:bat[:oid,:wrd]) :bat[:oid,:dbl]
address CMDbatADDcst
comment "Return V + B, overflow causes NIL value";

command +(b1:bat[:oid,:dbl],b2:bat[:oid,:lng]) :bat[:oid,:dbl]
address CMDbatADDsignal
comment "Return B1 + B2, signal error on overflow";
command +(b1:bat[:oid,:dbl],b2:bat[:oid,:lng],accum:int) :bat[:oid,:dbl]
address CMDbatADDsignalaccum
comment "Return B1 + B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command add_noerror(b1:bat[:oid,:dbl],b2:bat[:oid,:lng]) :bat[:oid,:dbl]
address CMDbatADD
comment "Return B1 + B2, overflow causes NIL value";
pattern +(b:bat[:oid,:dbl],v:lng) :bat[:oid,:dbl]
address CMDbatADDcstsignal
comment "Return B + V, signal error on overflow";
pattern +(b:bat[:oid,:dbl],v:lng,accum:int) :bat[:oid,:dbl]
address CMDbatADDcstsignal
comment "Return B + V, signal error on overflow, reuse B if ACCUM is set";
pattern add_noerror(b:bat[:oid,:dbl],v:lng) :bat[:oid,:dbl]
address CMDbatADDcst
comment "Return B + V, overflow causes NIL value";
pattern +(v:dbl,b:bat[:oid,:lng]) :bat[:oid,:dbl]
address CMDbatADDcstsignal
comment "Return V + B, signal error on overflow";
pattern add_noerror(v:dbl,b:bat[:oid,:lng]) :bat[:oid,:dbl]
address CMDbatADDcst
comment "Return V + B, overflow causes NIL value";

command +(b1:bat[:oid,:dbl],b2:bat[:oid,:flt]) :bat[:oid,:dbl]
address CMDbatADDsignal
comment "Return B1 + B2, signal error on overflow";
command +(b1:bat[:oid,:dbl],b2:bat[:oid,:flt],accum:int) :bat[:oid,:dbl]
address CMDbatADDsignalaccum
comment "Return B1 + B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command add_noerror(b1:bat[:oid,:dbl],b2:bat[:oid,:flt]) :bat[:oid,:dbl]
address CMDbatADD
comment "Return B1 + B2, overflow causes NIL value";
pattern +(b:bat[:oid,:dbl],v:flt) :bat[:oid,:dbl]
address CMDbatADDcstsignal
comment "Return B + V, signal error on overflow";
pattern +(b:bat[:oid,:dbl],v:flt,accum:int) :bat[:oid,:dbl]
address CMDbatADDcstsignal
comment "Return B + V, signal error on overflow, reuse B if ACCUM is set";
pattern add_noerror(b:bat[:oid,:dbl],v:flt) :bat[:oid,:dbl]
address CMDbatADDcst
comment "Return B + V, overflow causes NIL value";
pattern +(v:dbl,b:bat[:oid,:flt]) :bat[:oid,:dbl]
address CMDbatADDcstsignal
comment "Return V + B, signal error on overflow";
pattern add_noerror(v:dbl,b:bat[:oid,:flt]) :bat[:oid,:dbl]
address CMDbatADDcst
comment "Return V + B, overflow causes NIL value";

command +(b1:bat[:oid,:dbl],b2:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatADDsignal
comment "Return B1 + B2, signal error on overflow";
command +(b1:bat[:oid,:dbl],b2:bat[:oid,:dbl],accum:int) :bat[:oid,:dbl]
address CMDbatADDsignalaccum
comment "Return B1 + B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command add_noerror(b1:bat[:oid,:dbl],b2:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatADD
comment "Return B1 + B2, overflow causes NIL value";
pattern +(b:bat[:oid,:dbl],v:dbl) :bat[:oid,:dbl]
address CMDbatADDcstsignal
comment "Return B + V, signal error on overflow";
pattern +(b:bat[:oid,:dbl],v:dbl,accum:int) :bat[:oid,:dbl]
address CMDbatADDcstsignal
comment "Return B + V, signal error on overflow, reuse B if ACCUM is set";
pattern add_noerror(b:bat[:oid,:dbl],v:dbl) :bat[:oid,:dbl]
address CMDbatADDcst
comment "Return B + V, overflow causes NIL value";
pattern +(v:dbl,b:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatADDcstsignal
comment "Return V + B, signal error on overflow";
pattern +(v:dbl,b:bat[:oid,:dbl],accum:int) :bat[:oid,:dbl]
address CMDbatADDcstsignal
comment "Return V + B, signal error on overflow, reuse B if ACCUM is set";
pattern add_noerror(v:dbl,b:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatADDcst
comment "Return V + B, overflow causes NIL value";


command -(b1:bat[:oid,:bte],b2:bat[:oid,:bte]) :bat[:oid,:bte]
address CMDbatSUBsignal
comment "Return B1 - B2, signal error on overflow";
command -(b1:bat[:oid,:bte],b2:bat[:oid,:bte],accum:int) :bat[:oid,:bte]
address CMDbatSUBsignalaccum
comment "Return B1 - B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command sub_noerror(b1:bat[:oid,:bte],b2:bat[:oid,:bte]) :bat[:oid,:bte]
address CMDbatSUB
comment "Return B1 - B2, overflow causes NIL value";
pattern -(b:bat[:oid,:bte],v:bte) :bat[:oid,:bte]
address CMDbatSUBcstsignal
comment "Return B - V, signal error on overflow";
pattern -(b:bat[:oid,:bte],v:bte,accum:int) :bat[:oid,:bte]
address CMDbatSUBcstsignal
comment "Return B - V, signal error on overflow, reuse B if ACCUM is set";
pattern sub_noerror(b:bat[:oid,:bte],v:bte) :bat[:oid,:bte]
address CMDbatSUBcst
comment "Return B - V, overflow causes NIL value";
pattern -(v:bte,b:bat[:oid,:bte]) :bat[:oid,:bte]
address CMDbatSUBcstsignal
comment "Return V - B, signal error on overflow";
pattern -(v:bte,b:bat[:oid,:bte],accum:int) :bat[:oid,:bte]
address CMDbatSUBcstsignal
comment "Return V - B, signal error on overflow, reuse B if ACCUM is set";
pattern sub_noerror(v:bte,b:bat[:oid,:bte]) :bat[:oid,:bte]
address CMDbatSUBcst
comment "Return V - B, overflow causes NIL value";

command -(b1:bat[:oid,:bte],b2:bat[:oid,:sht]) :bat[:oid,:sht]
address CMDbatSUBsignal
comment "Return B1 - B2, signal error on overflow";
command -(b1:bat[:oid,:bte],b2:bat[:oid,:sht],accum:int) :bat[:oid,:sht]
address CMDbatSUBsignalaccum
comment "Return B1 - B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command sub_noerror(b1:bat[:oid,:bte],b2:bat[:oid,:sht]) :bat[:oid,:sht]
address CMDbatSUB
comment "Return B1 - B2, overflow causes NIL value";
pattern -(b:bat[:oid,:bte],v:sht) :bat[:oid,:sht]
address CMDbatSUBcstsignal
comment "Return B - V, signal error on overflow";
pattern sub_noerror(b:bat[:oid,:bte],v:sht) :bat[:oid,:sht]
address CMDbatSUBcst
comment "Return B - V, overflow causes NIL value";
pattern -(v:bte,b:bat[:oid,:sht]) :bat[:oid,:sht]
address CMDbatSUBcstsignal
comment "Return V - B, signal error on overflow";
pattern -(v:bte,b:bat[:oid,:sht],accum:int) :bat[:oid,:sht]
address CMDbatSUBcstsignal
comment "Return V - B, signal error on overflow, reuse B if ACCUM is set";
pattern sub_noerror(v:bte,b:bat[:oid,:sht]) :bat[:oid,:sht]
address CMDbatSUBcst
comment "Return V - B, overflow causes NIL value";

command -(b1:bat[:oid,:bte],b2:bat[:oid,:int]) :bat[:oid,:int]
address CMDbatSUBsignal
comment "Return B1 - B2, signal error on overflow";
command -(b1:bat[:oid,:bte],b2:bat[:oid,:int],accum:int) :bat[:oid,:int]
address CMDbatSUBsignalaccum
comment "Return B1 - B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command sub_noerror(b1:bat[:oid,:bte],b2:bat[:oid,:int]) :bat[:oid,:int]
address CMDbatSUB
comment "Return B1 - B2, overflow causes NIL value";
pattern -(b:bat[:oid,:bte],v:int) :bat[:oid,:int]
address CMDbatSUBcstsignal
comment "Return B - V, signal error on overflow";
pattern sub_noerror(b:bat[:oid,:bte],v:int) :bat[:oid,:int]
address CMDbatSUBcst
comment "Return B - V, overflow causes NIL value";
pattern -(v:bte,b:bat[:oid,:int]) :bat[:oid,:int]
address CMDbatSUBcstsignal
comment "Return V - B, signal error on overflow";
pattern -(v:bte,b:bat[:oid,:int],accum:int) :bat[:oid,:int]
address CMDbatSUBcstsignal
comment "Return V - B, signal error on overflow, reuse B if ACCUM is set";
pattern sub_noerror(v:bte,b:bat[:oid,:int]) :bat[:oid,:int]
address CMDbatSUBcst
comment "Return V - B, overflow causes NIL value";

command -(b1:bat[:oid,:bte],b2:bat[:oid,:wrd]) :bat[:oid,:wrd]
address CMDbatSUBsignal
comment "Return B1 - B2, signal error on overflow";
command -(b1:bat[:oid,:bte],b2:bat[:oid,:wrd],accum:int) :bat[:oid,:wrd]
address CMDbatSUBsignalaccum
comment "Return B1 - B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command sub_noerror(b1:bat[:oid,:bte],b2:bat[:oid,:wrd]) :bat[:oid,:wrd]
address CMDbatSUB
comment "Return B1 - B2, overflow causes NIL value";
pattern -(b:bat[:oid,:bte],v:wrd) :bat[:oid,:wrd]
address CMDbatSUBcstsignal
comment "Return B - V, signal error on overflow";
pattern sub_noerror(b:bat[:oid,:bte],v:wrd) :bat[:oid,:wrd]
address CMDbatSUBcst
comment "Return B - V, overflow causes NIL value";
pattern -(v:bte,b:bat[:oid,:wrd]) :bat[:oid,:wrd]
address CMDbatSUBcstsignal
comment "Return V - B, signal error on overflow";
pattern -(v:bte,b:bat[:oid,:wrd],accum:int) :bat[:oid,:wrd]
address CMDbatSUBcstsignal
comment "Return V - B, signal error on overflow, reuse B if ACCUM is set";
pattern sub_noerror(v:bte,b:bat[:oid,:wrd]) :bat[:oid,:wrd]
address CMDbatSUBcst
comment "Return V - B, overflow causes NIL value";

command -(b1:bat[:oid,:bte],b2:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatSUBsignal
comment "Return B1 - B2, signal error on overflow";
command -(b1:bat[:oid,:bte],b2:bat[:oid,:lng],accum:int) :bat[:oid,:lng]
address CMDbatSUBsignalaccum
comment "Return B1 - B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command sub_noerror(b1:bat[:oid,:bte],b2:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatSUB
comment "Return B1 - B2, overflow causes NIL value";
pattern -(b:bat[:oid,:bte],v:lng) :bat[:oid,:lng]
address CMDbatSUBcstsignal
comment "Return B - V, signal error on overflow";
pattern sub_noerror(b:bat[:oid,:bte],v:lng) :bat[:oid,:lng]
address CMDbatSUBcst
comment "Return B - V, overflow causes NIL value";
pattern -(v:bte,b:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatSUBcstsignal
comment "Return V - B, signal error on overflow";
pattern -(v:bte,b:bat[:oid,:lng],accum:int) :bat[:oid,:lng]
address CMDbatSUBcstsignal
comment "Return V - B, signal error on overflow, reuse B if ACCUM is set";
pattern sub_noerror(v:bte,b:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatSUBcst
comment "Return V - B, overflow causes NIL value";

command -(b1:bat[:oid,:bte],b2:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatSUBsignal
comment "Return B1 - B2, signal error on overflow";
command -(b1:bat[:oid,:bte],b2:bat[:oid,:flt],accum:int) :bat[:oid,:flt]
address CMDbatSUBsignalaccum
comment "Return B1 - B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command sub_noerror(b1:bat[:oid,:bte],b2:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatSUB
comment "Return B1 - B2, overflow causes NIL value";
pattern -(b:bat[:oid,:bte],v:flt) :bat[:oid,:flt]
address CMDbatSUBcstsignal
comment "Return B - V, signal error on overflow";
pattern sub_noerror(b:bat[:oid,:bte],v:flt) :bat[:oid,:flt]
address CMDbatSUBcst
comment "Return B - V, overflow causes NIL value";
pattern -(v:bte,b:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatSUBcstsignal
comment "Return V - B, signal error on overflow";
pattern -(v:bte,b:bat[:oid,:flt],accum:int) :bat[:oid,:flt]
address CMDbatSUBcstsignal
comment "Return V - B, signal error on overflow, reuse B if ACCUM is set";
pattern sub_noerror(v:bte,b:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatSUBcst
comment "Return V - B, overflow causes NIL value";

command -(b1:bat[:oid,:bte],b2:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatSUBsignal
comment "Return B1 - B2, signal error on overflow";
command -(b1:bat[:oid,:bte],b2:bat[:oid,:dbl],accum:int) :bat[:oid,:dbl]
address CMDbatSUBsignalaccum
comment "Return B1 - B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command sub_noerror(b1:bat[:oid,:bte],b2:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatSUB
comment "Return B1 - B2, overflow causes NIL value";
pattern -(b:bat[:oid,:bte],v:dbl) :bat[:oid,:dbl]
address CMDbatSUBcstsignal
comment "Return B - V, signal error on overflow";
pattern sub_noerror(b:bat[:oid,:bte],v:dbl) :bat[:oid,:dbl]
address CMDbatSUBcst
comment "Return B - V, overflow causes NIL value";
pattern -(v:bte,b:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatSUBcstsignal
comment "Return V - B, signal error on overflow";
pattern -(v:bte,b:bat[:oid,:dbl],accum:int) :bat[:oid,:dbl]
address CMDbatSUBcstsignal
comment "Return V - B, signal error on overflow, reuse B if ACCUM is set";
pattern sub_noerror(v:bte,b:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatSUBcst
comment "Return V - B, overflow causes NIL value";

command -(b1:bat[:oid,:sht],b2:bat[:oid,:bte]) :bat[:oid,:sht]
address CMDbatSUBsignal
comment "Return B1 - B2, signal error on overflow";
command -(b1:bat[:oid,:sht],b2:bat[:oid,:bte],accum:int) :bat[:oid,:sht]
address CMDbatSUBsignalaccum
comment "Return B1 - B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command sub_noerror(b1:bat[:oid,:sht],b2:bat[:oid,:bte]) :bat[:oid,:sht]
address CMDbatSUB
comment "Return B1 - B2, overflow causes NIL value";
pattern -(b:bat[:oid,:sht],v:bte) :bat[:oid,:sht]
address CMDbatSUBcstsignal
comment "Return B - V, signal error on overflow";
pattern -(b:bat[:oid,:sht],v:bte,accum:int) :bat[:oid,:sht]
address CMDbatSUBcstsignal
comment "Return B - V, signal error on overflow, reuse B if ACCUM is set";
pattern sub_noerror(b:bat[:oid,:sht],v:bte) :bat[:oid,:sht]
address CMDbatSUBcst
comment "Return B - V, overflow causes NIL value";
pattern -(v:sht,b:bat[:oid,:bte]) :bat[:oid,:sht]
address CMDbatSUBcstsignal
comment "Return V - B, signal error on overflow";
pattern sub_noerror(v:sht,b:bat[:oid,:bte]) :bat[:oid,:sht]
address CMDbatSUBcst
comment "Return V - B, overflow causes NIL value";

command -(b1:bat[:oid,:sht],b2:bat[:oid,:sht]) :bat[:oid,:sht]
address CMDbatSUBsignal
comment "Return B1 - B2, signal error on overflow";
command -(b1:bat[:oid,:sht],b2:bat[:oid,:sht],accum:int) :bat[:oid,:sht]
address CMDbatSUBsignalaccum
comment "Return B1 - B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command sub_noerror(b1:bat[:oid,:sht],b2:bat[:oid,:sht]) :bat[:oid,:sht]
address CMDbatSUB
comment "Return B1 - B2, overflow causes NIL value";
pattern -(b:bat[:oid,:sht],v:sht) :bat[:oid,:sht]
address CMDbatSUBcstsignal
comment "Return B - V, signal error on overflow";
pattern -(b:bat[:oid,:sht],v:sht,accum:int) :bat[:oid,:sht]
address CMDbatSUBcstsignal
comment "Return B - V, signal error on overflow, reuse B if ACCUM is set";
pattern sub_noerror(b:bat[:oid,:sht],v:sht) :bat[:oid,:sht]
address CMDbatSUBcst
comment "Return B - V, overflow causes NIL value";
pattern -(v:sht,b:bat[:oid,:sht]) :bat[:oid,:sht]
address CMDbatSUBcstsignal
comment "Return V - B, signal error on overflow";
pattern -(v:sht,b:bat[:oid,:sht],accum:int) :bat[:oid,:sht]
address CMDbatSUBcstsignal
comment "Return V - B, signal error on overflow, reuse B if ACCUM is set";
pattern sub_noerror(v:sht,b:bat[:oid,:sht]) :bat[:oid,:sht]
address CMDbatSUBcst
comment "Return V - B, overflow causes NIL value";

command -(b1:bat[:oid,:sht],b2:bat[:oid,:int]) :bat[:oid,:int]
address CMDbatSUBsignal
comment "Return B1 - B2, signal error on overflow";
command -(b1:bat[:oid,:sht],b2:bat[:oid,:int],accum:int) :bat[:oid,:int]
address CMDbatSUBsignalaccum
comment "Return B1 - B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command sub_noerror(b1:bat[:oid,:sht],b2:bat[:oid,:int]) :bat[:oid,:int]
address CMDbatSUB
comment "Return B1 - B2, overflow causes NIL value";
pattern -(b:bat[:oid,:sht],v:int) :bat[:oid,:int]
address CMDbatSUBcstsignal
comment "Return B - V, signal error on overflow";
pattern sub_noerror(b:bat[:oid,:sht],v:int) :bat[:oid,:int]
address CMDbatSUBcst
comment "Return B - V, overflow causes NIL value";
pattern -(v:sht,b:bat[:oid,:int]) :bat[:oid,:int]
address CMDbatSUBcstsignal
comment "Return V - B, signal error on overflow";
pattern -(v:sht,b:bat[:oid,:int],accum:int) :bat[:oid,:int]
address CMDbatSUBcstsignal
comment "Return V - B, signal error on overflow, reuse B if ACCUM is set";
pattern sub_noerror(v:sht,b:bat[:oid,:int]) :bat[:oid,:int]
address CMDbatSUBcst
comment "Return V - B, overflow causes NIL value";

command -(b1:bat[:oid,:sht],b2:bat[:oid,:wrd]) :bat[:oid,:wrd]
address CMDbatSUBsignal
comment "Return B1 - B2, signal error on overflow";
command -(b1:bat[:oid,:sht],b2:bat[:oid,:wrd],accum:int) :bat[:oid,:wrd]
address CMDbatSUBsignalaccum
comment "Return B1 - B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command sub_noerror(b1:bat[:oid,:sht],b2:bat[:oid,:wrd]) :bat[:oid,:wrd]
address CMDbatSUB
comment "Return B1 - B2, overflow causes NIL value";
pattern -(b:bat[:oid,:sht],v:wrd) :bat[:oid,:wrd]
address CMDbatSUBcstsignal
comment "Return B - V, signal error on overflow";
pattern sub_noerror(b:bat[:oid,:sht],v:wrd) :bat[:oid,:wrd]
address CMDbatSUBcst
comment "Return B - V, overflow causes NIL value";
pattern -(v:sht,b:bat[:oid,:wrd]) :bat[:oid,:wrd]
address CMDbatSUBcstsignal
comment "Return V - B, signal error on overflow";
pattern -(v:sht,b:bat[:oid,:wrd],accum:int) :bat[:oid,:wrd]
address CMDbatSUBcstsignal
comment "Return V - B, signal error on overflow, reuse B if ACCUM is set";
pattern sub_noerror(v:sht,b:bat[:oid,:wrd]) :bat[:oid,:wrd]
address CMDbatSUBcst
comment "Return V - B, overflow causes NIL value";

command -(b1:bat[:oid,:sht],b2:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatSUBsignal
comment "Return B1 - B2, signal error on overflow";
command -(b1:bat[:oid,:sht],b2:bat[:oid,:lng],accum:int) :bat[:oid,:lng]
address CMDbatSUBsignalaccum
comment "Return B1 - B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command sub_noerror(b1:bat[:oid,:sht],b2:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatSUB
comment "Return B1 - B2, overflow causes NIL value";
pattern -(b:bat[:oid,:sht],v:lng) :bat[:oid,:lng]
address CMDbatSUBcstsignal
comment "Return B - V, signal error on overflow";
pattern sub_noerror(b:bat[:oid,:sht],v:lng) :bat[:oid,:lng]
address CMDbatSUBcst
comment "Return B - V, overflow causes NIL value";
pattern -(v:sht,b:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatSUBcstsignal
comment "Return V - B, signal error on overflow";
pattern -(v:sht,b:bat[:oid,:lng],accum:int) :bat[:oid,:lng]
address CMDbatSUBcstsignal
comment "Return V - B, signal error on overflow, reuse B if ACCUM is set";
pattern sub_noerror(v:sht,b:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatSUBcst
comment "Return V - B, overflow causes NIL value";

command -(b1:bat[:oid,:sht],b2:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatSUBsignal
comment "Return B1 - B2, signal error on overflow";
command -(b1:bat[:oid,:sht],b2:bat[:oid,:flt],accum:int) :bat[:oid,:flt]
address CMDbatSUBsignalaccum
comment "Return B1 - B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command sub_noerror(b1:bat[:oid,:sht],b2:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatSUB
comment "Return B1 - B2, overflow causes NIL value";
pattern -(b:bat[:oid,:sht],v:flt) :bat[:oid,:flt]
address CMDbatSUBcstsignal
comment "Return B - V, signal error on overflow";
pattern sub_noerror(b:bat[:oid,:sht],v:flt) :bat[:oid,:flt]
address CMDbatSUBcst
comment "Return B - V, overflow causes NIL value";
pattern -(v:sht,b:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatSUBcstsignal
comment "Return V - B, signal error on overflow";
pattern -(v:sht,b:bat[:oid,:flt],accum:int) :bat[:oid,:flt]
address CMDbatSUBcstsignal
comment "Return V - B, signal error on overflow, reuse B if ACCUM is set";
pattern sub_noerror(v:sht,b:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatSUBcst
comment "Return V - B, overflow causes NIL value";

command -(b1:bat[:oid,:sht],b2:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatSUBsignal
comment "Return B1 - B2, signal error on overflow";
command -(b1:bat[:oid,:sht],b2:bat[:oid,:dbl],accum:int) :bat[:oid,:dbl]
address CMDbatSUBsignalaccum
comment "Return B1 - B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command sub_noerror(b1:bat[:oid,:sht],b2:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatSUB
comment "Return B1 - B2, overflow causes NIL value";
pattern -(b:bat[:oid,:sht],v:dbl) :bat[:oid,:dbl]
address CMDbatSUBcstsignal
comment "Return B - V, signal error on overflow";
pattern sub_noerror(b:bat[:oid,:sht],v:dbl) :bat[:oid,:dbl]
address CMDbatSUBcst
comment "Return B - V, overflow causes NIL value";
pattern -(v:sht,b:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatSUBcstsignal
comment "Return V - B, signal error on overflow";
pattern -(v:sht,b:bat[:oid,:dbl],accum:int) :bat[:oid,:dbl]
address CMDbatSUBcstsignal
comment "Return V - B, signal error on overflow, reuse B if ACCUM is set";
pattern sub_noerror(v:sht,b:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatSUBcst
comment "Return V - B, overflow causes NIL value";

command -(b1:bat[:oid,:int],b2:bat[:oid,:bte]) :bat[:oid,:int]
address CMDbatSUBsignal
comment "Return B1 - B2, signal error on overflow";
command -(b1:bat[:oid,:int],b2:bat[:oid,:bte],accum:int) :bat[:oid,:int]
address CMDbatSUBsignalaccum
comment "Return B1 - B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command sub_noerror(b1:bat[:oid,:int],b2:bat[:oid,:bte]) :bat[:oid,:int]
address CMDbatSUB
comment "Return B1 - B2, overflow causes NIL value";
pattern -(b:bat[:oid,:int],v:bte) :bat[:oid,:int]
address CMDbatSUBcstsignal
comment "Return B - V, signal error on overflow";
pattern -(b:bat[:oid,:int],v:bte,accum:int) :bat[:oid,:int]
address CMDbatSUBcstsignal
comment "Return B - V, signal error on overflow, reuse B if ACCUM is set";
pattern sub_noerror(b:bat[:oid,:int],v:bte) :bat[:oid,:int]
address CMDbatSUBcst
comment "Return B - V, overflow causes NIL value";
pattern -(v:int,b:bat[:oid,:bte]) :bat[:oid,:int]
address CMDbatSUBcstsignal
comment "Return V - B, signal error on overflow";
pattern sub_noerror(v:int,b:bat[:oid,:bte]) :bat[:oid,:int]
address CMDbatSUBcst
comment "Return V - B, overflow causes NIL value";

command -(b1:bat[:oid,:int],b2:bat[:oid,:sht]) :bat[:oid,:int]
address CMDbatSUBsignal
comment "Return B1 - B2, signal error on overflow";
command -(b1:bat[:oid,:int],b2:bat[:oid,:sht],accum:int) :bat[:oid,:int]
address CMDbatSUBsignalaccum
comment "Return B1 - B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command sub_noerror(b1:bat[:oid,:int],b2:bat[:oid,:sht]) :bat[:oid,:int]
address CMDbatSUB
comment "Return B1 - B2, overflow causes NIL value";
pattern -(b:bat[:oid,:int],v:sht) :bat[:oid,:int]
address CMDbatSUBcstsignal
comment "Return B - V, signal error on overflow";
pattern -(b:bat[:oid,:int],v:sht,accum:int) :bat[:oid,:int]
address CMDbatSUBcstsignal
comment "Return B - V, signal error on overflow, reuse B if ACCUM is set";
pattern sub_noerror(b:bat[:oid,:int],v:sht) :bat[:oid,:int]
address CMDbatSUBcst
comment "Return B - V, overflow causes NIL value";
pattern -(v:int,b:bat[:oid,:sht]) :bat[:oid,:int]
address CMDbatSUBcstsignal
comment "Return V - B, signal error on overflow";
pattern sub_noerror(v:int,b:bat[:oid,:sht]) :bat[:oid,:int]
address CMDbatSUBcst
comment "Return V - B, overflow causes NIL value";

command -(b1:bat[:oid,:int],b2:bat[:oid,:int]) :bat[:oid,:int]
address CMDbatSUBsignal
comment "Return B1 - B2, signal error on overflow";
command -(b1:bat[:oid,:int],b2:bat[:oid,:int],accum:int) :bat[:oid,:int]
address CMDbatSUBsignalaccum
comment "Return B1 - B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command sub_noerror(b1:bat[:oid,:int],b2:bat[:oid,:int]) :bat[:oid,:int]
address CMDbatSUB
comment "Return B1 - B2, overflow causes NIL value";
pattern -(b:bat[:oid,:int],v:int) :bat[:oid,:int]
address CMDbatSUBcstsignal
comment "Return B - V, signal error on overflow";
pattern -(b:bat[:oid,:int],v:int,accum:int) :bat[:oid,:int]
address CMDbatSUBcstsignal
comment "Return B - V, signal error on overflow, reuse B if ACCUM is set";
pattern sub_noerror(b:bat[:oid,:int],v:int) :bat[:oid,:int]
address CMDbatSUBcst
comment "Return B - V, overflow causes NIL value";
pattern -(v:int,b:bat[:oid,:int]) :bat[:oid,:int]
address CMDbatSUBcstsignal
comment "Return V - B, signal error on overflow";
pattern -(v:int,b:bat[:oid,:int],accum:int) :bat[:oid,:int]
address CMDbatSUBcstsignal
comment "Return V - B, signal error on overflow, reuse B if ACCUM is set";
pattern sub_noerror(v:int,b:bat[:oid,:int]) :bat[:oid,:int]
address CMDbatSUBcst
comment "Return V - B, overflow causes NIL value";

command -(b1:bat[:oid,:int],b2:bat[:oid,:wrd]) :bat[:oid,:wrd]
address CMDbatSUBsignal
comment "Return B1 - B2, signal error on overflow";
command -(b1:bat[:oid,:int],b2:bat[:oid,:wrd],accum:int) :bat[:oid,:wrd]
address CMDbatSUBsignalaccum
comment "Return B1 - B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command sub_noerror(b1:bat[:oid,:int],b2:bat[:oid,:wrd]) :bat[:oid,:wrd]
address CMDbatSUB
comment "Return B1 - B2, overflow causes NIL value";
pattern -(b:bat[:oid,:int],v:wrd) :bat[:oid,:wrd]
address CMDbatSUBcstsignal
comment "Return B - V, signal error on overflow";
pattern sub_noerror(b:bat[:oid,:int],v:wrd) :bat[:oid,:wrd]
address CMDbatSUBcst
comment "Return B - V, overflow causes NIL value";
pattern -(v:int,b:bat[:oid,:wrd]) :bat[:oid,:wrd]
address CMDbatSUBcstsignal
comment "Return V - B, signal error on overflow";
pattern -(v:int,b:bat[:oid,:wrd],accum:int) :bat[:oid,:wrd]
address CMDbatSUBcstsignal
comment "Return V - B, signal error on overflow, reuse B if ACCUM is set";
pattern sub_noerror(v:int,b:bat[:oid,:wrd]) :bat[:oid,:wrd]
address CMDbatSUBcst
comment "Return V - B, overflow causes NIL value";

command -(b1:bat[:oid,:int],b2:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatSUBsignal
comment "Return B1 - B2, signal error on overflow";
command -(b1:bat[:oid,:int],b2:bat[:oid,:lng],accum:int) :bat[:oid,:lng]
address CMDbatSUBsignalaccum
comment "Return B1 - B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command sub_noerror(b1:bat[:oid,:int],b2:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatSUB
comment "Return B1 - B2, overflow causes NIL value";
pattern -(b:bat[:oid,:int],v:lng) :bat[:oid,:lng]
address CMDbatSUBcstsignal
comment "Return B - V, signal error on overflow";
pattern sub_noerror(b:bat[:oid,:int],v:lng) :bat[:oid,:lng]
address CMDbatSUBcst
comment "Return B - V, overflow causes NIL value";
pattern -(v:int,b:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatSUBcstsignal
comment "Return V - B, signal error on overflow";
pattern -(v:int,b:bat[:oid,:lng],accum:int) :bat[:oid,:lng]
address CMDbatSUBcstsignal
comment "Return V - B, signal error on overflow, reuse B if ACCUM is set";
pattern sub_noerror(v:int,b:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatSUBcst
comment "Return V - B, overflow causes NIL value";

command -(b1:bat[:oid,:int],b2:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatSUBsignal
comment "Return B1 - B2, signal error on overflow";
command -(b1:bat[:oid,:int],b2:bat[:oid,:flt],accum:int) :bat[:oid,:flt]
address CMDbatSUBsignalaccum
comment "Return B1 - B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command sub_noerror(b1:bat[:oid,:int],b2:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatSUB
comment "Return B1 - B2, overflow causes NIL value";
pattern -(b:bat[:oid,:int],v:flt) :bat[:oid,:flt]
address CMDbatSUBcstsignal
comment "Return B - V, signal error on overflow";
pattern sub_noerror(b:bat[:oid,:int],v:flt) :bat[:oid,:flt]
address CMDbatSUBcst
comment "Return B - V, overflow causes NIL value";
pattern -(v:int,b:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatSUBcstsignal
comment "Return V - B, signal error on overflow";
pattern -(v:int,b:bat[:oid,:flt],accum:int) :bat[:oid,:flt]
address CMDbatSUBcstsignal
comment "Return V - B, signal error on overflow, reuse B if ACCUM is set";
pattern sub_noerror(v:int,b:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatSUBcst
comment "Return V - B, overflow causes NIL value";

command -(b1:bat[:oid,:int],b2:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatSUBsignal
comment "Return B1 - B2, signal error on overflow";
command -(b1:bat[:oid,:int],b2:bat[:oid,:dbl],accum:int) :bat[:oid,:dbl]
address CMDbatSUBsignalaccum
comment "Return B1 - B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command sub_noerror(b1:bat[:oid,:int],b2:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatSUB
comment "Return B1 - B2, overflow causes NIL value";
pattern -(b:bat[:oid,:int],v:dbl) :bat[:oid,:dbl]
address CMDbatSUBcstsignal
comment "Return B - V, signal error on overflow";
pattern sub_noerror(b:bat[:oid,:int],v:dbl) :bat[:oid,:dbl]
address CMDbatSUBcst
comment "Return B - V, overflow causes NIL value";
pattern -(v:int,b:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatSUBcstsignal
comment "Return V - B, signal error on overflow";
pattern -(v:int,b:bat[:oid,:dbl],accum:int) :bat[:oid,:dbl]
address CMDbatSUBcstsignal
comment "Return V - B, signal error on overflow, reuse B if ACCUM is set";
pattern sub_noerror(v:int,b:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatSUBcst
comment "Return V - B, overflow causes NIL value";

command -(b1:bat[:oid,:wrd],b2:bat[:oid,:bte]) :bat[:oid,:wrd]
address CMDbatSUBsignal
comment "Return B1 - B2, signal error on overflow";
command -(b1:bat[:oid,:wrd],b2:bat[:oid,:bte],accum:int) :bat[:oid,:wrd]
address CMDbatSUBsignalaccum
comment "Return B1 - B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command sub_noerror(b1:bat[:oid,:wrd],b2:bat[:oid,:bte]) :bat[:oid,:wrd]
address CMDbatSUB
comment "Return B1 - B2, overflow causes NIL value";
pattern -(b:bat[:oid,:wrd],v:bte) :bat[:oid,:wrd]
address CMDbatSUBcstsignal
comment "Return B - V, signal error on overflow";
pattern -(b:bat[:oid,:wrd],v:bte,accum:int) :bat[:oid,:wrd]
address CMDbatSUBcstsignal
comment "Return B - V, signal error on overflow, reuse B if ACCUM is set";
pattern sub_noerror(b:bat[:oid,:wrd],v:bte) :bat[:oid,:wrd]
address CMDbatSUBcst
comment "Return B - V, overflow causes NIL value";
pattern -(v:wrd,b:bat[:oid,:bte]) :bat[:oid,:wrd]
address CMDbatSUBcstsignal
comment "Return V - B, signal error on overflow";
pattern sub_noerror(v:wrd,b:bat[:oid,:bte]) :bat[:oid,:wrd]
address CMDbatSUBcst
comment "Return V - B, overflow causes NIL value";

command -(b1:bat[:oid,:wrd],b2:bat[:oid,:sht]) :bat[:oid,:wrd]
address CMDbatSUBsignal
comment "Return B1 - B2, signal error on overflow";
command -(b1:bat[:oid,:wrd],b2:bat[:oid,:sht],accum:int) :bat[:oid,:wrd]
address CMDbatSUBsignalaccum
comment "Return B1 - B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command sub_noerror(b1:bat[:oid,:wrd],b2:bat[:oid,:sht]) :bat[:oid,:wrd]
address CMDbatSUB
comment "Return B1 - B2, overflow causes NIL value";
pattern -(b:bat[:oid,:wrd],v:sht) :bat[:oid,:wrd]
address CMDbatSUBcstsignal
comment "Return B - V, signal error on overflow";
pattern -(b:bat[:oid,:wrd],v:sht,accum:int) :bat[:oid,:wrd]
address CMDbatSUBcstsignal
comment "Return B - V, signal error on overflow, reuse B if ACCUM is set";
pattern sub_noerror(b:bat[:oid,:wrd],v:sht) :bat[:oid,:wrd]
address CMDbatSUBcst
comment "Return B - V, overflow causes NIL value";
pattern -(v:wrd,b:bat[:oid,:sht]) :bat[:oid,:wrd]
address CMDbatSUBcstsignal
comment "Return V - B, signal error on overflow";
pattern sub_noerror(v:wrd,b:bat[:oid,:sht]) :bat[:oid,:wrd]
address CMDbatSUBcst
comment "Return V - B, overflow causes NIL value";

command -(b1:bat[:oid,:wrd],b2:bat[:oid,:int]) :bat[:oid,:wrd]
address CMDbatSUBsignal
comment "Return B1 - B2, signal error on overflow";
command -(b1:bat[:oid,:wrd],b2:bat[:oid,:int],accum:int) :bat[:oid,:wrd]
address CMDbatSUBsignalaccum
comment "Return B1 - B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command sub_noerror(b1:bat[:oid,:wrd],b2:bat[:oid,:int]) :bat[:oid,:wrd]
address CMDbatSUB
comment "Return B1 - B2, overflow causes NIL value";
pattern -(b:bat[:oid,:wrd],v:int) :bat[:oid,:wrd]
address CMDbatSUBcstsignal
comment "Return B - V, signal error on overflow";
pattern -(b:bat[:oid,:wrd],v:int,accum:int) :bat[:oid,:wrd]
address CMDbatSUBcstsignal
comment "Return B - V, signal error on overflow, reuse B if ACCUM is set";
pattern sub_noerror(b:bat[:oid,:wrd],v:int) :bat[:oid,:wrd]
address CMDbatSUBcst
comment "Return B - V, overflow causes NIL value";
pattern -(v:wrd,b:bat[:oid,:int]) :bat[:oid,:wrd]
address CMDbatSUBcstsignal
comment "Return V - B, signal error on overflow";
pattern sub_noerror(v:wrd,b:bat[:oid,:int]) :bat[:oid,:wrd]
address CMDbatSUBcst
comment "Return V - B, overflow causes NIL value";

command -(b1:bat[:oid,:wrd],b2:bat[:oid,:wrd]) :bat[:oid,:wrd]
address CMDbatSUBsignal
comment "Return B1 - B2, signal error on overflow";
command -(b1:bat[:oid,:wrd],b2:bat[:oid,:wrd],accum:int) :bat[:oid,:wrd]
address CMDbatSUBsignalaccum
comment "Return B1 - B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command sub_noerror(b1:bat[:oid,:wrd],b2:bat[:oid,:wrd]) :bat[:oid,:wrd]
address CMDbatSUB
comment "Return B1 - B2, overflow causes NIL value";
pattern -(b:bat[:oid,:wrd],v:wrd) :bat[:oid,:wrd]
address CMDbatSUBcstsignal
comment "Return B - V, signal error on overflow";
pattern -(b:bat[:oid,:wrd],v:wrd,accum:int) :bat[:oid,:wrd]
address CMDbatSUBcstsignal
comment "Return B - V, signal error on overflow, reuse B if ACCUM is set";
pattern sub_noerror(b:bat[:oid,:wrd],v:wrd) :bat[:oid,:wrd]
address CMDbatSUBcst
comment "Return B - V, overflow causes NIL value";
pattern -(v:wrd,b:bat[:oid,:wrd]) :bat[:oid,:wrd]
address CMDbatSUBcstsignal
comment "Return V - B, signal error on overflow";
pattern -(v:wrd,b:bat[:oid,:wrd],accum:int) :bat[:oid,:wrd]
address CMDbatSUBcstsignal
comment "Return V - B, signal error on overflow, reuse B if ACCUM is set";
pattern sub_noerror(v:wrd,b:bat[:oid,:wrd]) :bat[:oid,:wrd]
address CMDbatSUBcst
comment "Return V - B, overflow causes NIL value";

command -(b1:bat[:oid,:wrd],b2:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatSUBsignal
comment "Return B1 - B2, signal error on overflow";
command -(b1:bat[:oid,:wrd],b2:bat[:oid,:lng],accum:int) :bat[:oid,:lng]
address CMDbatSUBsignalaccum
comment "Return B1 - B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command sub_noerror(b1:bat[:oid,:wrd],b2:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatSUB
comment "Return B1 - B2, overflow causes NIL value";
pattern -(b:bat[:oid,:wrd],v:lng) :bat[:oid,:lng]
address CMDbatSUBcstsignal
comment "Return B - V, signal error on overflow";
pattern sub_noerror(b:bat[:oid,:wrd],v:lng) :bat[:oid,:lng]
address CMDbatSUBcst
comment "Return B - V, overflow causes NIL value";
pattern -(v:wrd,b:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatSUBcstsignal
comment "Return V - B, signal error on overflow";
pattern -(v:wrd,b:bat[:oid,:lng],accum:int) :bat[:oid,:lng]
address CMDbatSUBcstsignal
comment "Return V - B, signal error on overflow, reuse B if ACCUM is set";
pattern sub_noerror(v:wrd,b:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatSUBcst
comment "Return V - B, overflow causes NIL value";

command -(b1:bat[:oid,:wrd],b2:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatSUBsignal
comment "Return B1 - B2, signal error on overflow";
command -(b1:bat[:oid,:wrd],b2:bat[:oid,:flt],accum:int) :bat[:oid,:flt]
address CMDbatSUBsignalaccum
comment "Return B1 - B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command sub_noerror(b1:bat[:oid,:wrd],b2:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatSUB
comment "Return B1 - B2, overflow causes NIL value";
pattern -(b:bat[:oid,:wrd],v:flt) :bat[:oid,:flt]
address CMDbatSUBcstsignal
comment "Return B - V, signal error on overflow";
pattern sub_noerror(b:bat[:oid,:wrd],v:flt) :bat[:oid,:flt]
address CMDbatSUBcst
comment "Return B - V, overflow causes NIL value";
pattern -(v:wrd,b:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatSUBcstsignal
comment "Return V - B, signal error on overflow";
pattern -(v:wrd,b:bat[:oid,:flt],accum:int) :bat[:oid,:flt]
address CMDbatSUBcstsignal
comment "Return V - B, signal error on overflow, reuse B if ACCUM is set";
pattern sub_noerror(v:wrd,b:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatSUBcst
comment "Return V - B, overflow causes NIL value";

command -(b1:bat[:oid,:wrd],b2:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatSUBsignal
comment "Return B1 - B2, signal error on overflow";
command -(b1:bat[:oid,:wrd],b2:bat[:oid,:dbl],accum:int) :bat[:oid,:dbl]
address CMDbatSUBsignalaccum
comment "Return B1 - B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command sub_noerror(b1:bat[:oid,:wrd],b2:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatSUB
comment "Return B1 - B2, overflow causes NIL value";
pattern -(b:bat[:oid,:wrd],v:dbl) :bat[:oid,:dbl]
address CMDbatSUBcstsignal
comment "Return B - V, signal error on overflow";
pattern sub_noerror(b:bat[:oid,:wrd],v:dbl) :bat[:oid,:dbl]
address CMDbatSUBcst
comment "Return B - V, overflow causes NIL value";
pattern -(v:wrd,b:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatSUBcstsignal
comment "Return V - B, signal error on overflow";
pattern -(v:wrd,b:bat[:oid,:dbl],accum:int) :bat[:oid,:dbl]
address CMDbatSUBcstsignal
comment "Return V - B, signal error on overflow, reuse B if ACCUM is set";
pattern sub_noerror(v:wrd,b:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatSUBcst
comment "Return V - B, overflow causes NIL value";

command -(b1:bat[:oid,:lng],b2:bat[:oid,:bte]) :bat[:oid,:lng]
address CMDbatSUBsignal
comment "Return B1 - B2, signal error on overflow";
command -(b1:bat[:oid,:lng],b2:bat[:oid,:bte],accum:int) :bat[:oid,:lng]
address CMDbatSUBsignalaccum
comment "Return B1 - B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command sub_noerror(b1:bat[:oid,:lng],b2:bat[:oid,:bte]) :bat[:oid,:lng]
address CMDbatSUB
comment "Return B1 - B2, overflow causes NIL value";
pattern -(b:bat[:oid,:lng],v:bte) :bat[:oid,:lng]
address CMDbatSUBcstsignal
comment "Return B - V, signal error on overflow";
pattern -(b:bat[:oid,:lng],v:bte,accum:int) :bat[:oid,:lng]
address CMDbatSUBcstsignal
comment "Return B - V, signal error on overflow, reuse B if ACCUM is set";
pattern sub_noerror(b:bat[:oid,:lng],v:bte) :bat[:oid,:lng]
address CMDbatSUBcst
comment "Return B - V, overflow causes NIL value";
pattern -(v:lng,b:bat[:oid,:bte]) :bat[:oid,:lng]
address CMDbatSUBcstsignal
comment "Return V - B, signal error on overflow";
pattern sub_noerror(v:lng,b:bat[:oid,:bte]) :bat[:oid,:lng]
address CMDbatSUBcst
comment "Return V - B, overflow causes NIL value";

command -(b1:bat[:oid,:lng],b2:bat[:oid,:sht]) :bat[:oid,:lng]
address CMDbatSUBsignal
comment "Return B1 - B2, signal error on overflow";
command -(b1:bat[:oid,:lng],b2:bat[:oid,:sht],accum:int) :bat[:oid,:lng]
address CMDbatSUBsignalaccum
comment "Return B1 - B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command sub_noerror(b1:bat[:oid,:lng],b2:bat[:oid,:sht]) :bat[:oid,:lng]
address CMDbatSUB
comment "Return B1 - B2, overflow causes NIL value";
pattern -(b:bat[:oid,:lng],v:sht) :bat[:oid,:lng]
address CMDbatSUBcstsignal
comment "Return B - V, signal error on overflow";
pattern -(b:bat[:oid,:lng],v:sht,accum:int) :bat[:oid,:lng]
address CMDbatSUBcstsignal
comment "Return B - V, signal error on overflow, reuse B if ACCUM is set";
pattern sub_noerror(b:bat[:oid,:lng],v:sht) :bat[:oid,:lng]
address CMDbatSUBcst
comment "Return B - V, overflow causes NIL value";
pattern -(v:lng,b:bat[:oid,:sht]) :bat[:oid,:lng]
address CMDbatSUBcstsignal
comment "Return V - B, signal error on overflow";
pattern sub_noerror(v:lng,b:bat[:oid,:sht]) :bat[:oid,:lng]
address CMDbatSUBcst
comment "Return V - B, overflow causes NIL value";

command -(b1:bat[:oid,:lng],b2:bat[:oid,:int]) :bat[:oid,:lng]
address CMDbatSUBsignal
comment "Return B1 - B2, signal error on overflow";
command -(b1:bat[:oid,:lng],b2:bat[:oid,:int],accum:int) :bat[:oid,:lng]
address CMDbatSUBsignalaccum
comment "Return B1 - B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command sub_noerror(b1:bat[:oid,:lng],b2:bat[:oid,:int]) :bat[:oid,:lng]
address CMDbatSUB
comment "Return B1 - B2, overflow causes NIL value";
pattern -(b:bat[:oid,:lng],v:int) :bat[:oid,:lng]
address CMDbatSUBcstsignal
comment "Return B - V, signal error on overflow";
pattern -(b:bat[:oid,:lng],v:int,accum:int) :bat[:oid,:lng]
address CMDbatSUBcstsignal
comment "Return B - V, signal error on overflow, reuse B if ACCUM is set";
pattern sub_noerror(b:bat[:oid,:lng],v:int) :bat[:oid,:lng]
address CMDbatSUBcst
comment "Return B - V, overflow causes NIL value";
pattern -(v:lng,b:bat[:oid,:int]) :bat[:oid,:lng]
address CMDbatSUBcstsignal
comment "Return V - B, signal error on overflow";
pattern sub_noerror(v:lng,b:bat[:oid,:int]) :bat[:oid,:lng]
address CMDbatSUBcst
comment "Return V - B, overflow causes NIL value";

command -(b1:bat[:oid,:lng],b2:bat[:oid,:wrd]) :bat[:oid,:lng]
address CMDbatSUBsignal
comment "Return B1 - B2, signal error on overflow";
command -(b1:bat[:oid,:lng],b2:bat[:oid,:wrd],accum:int) :bat[:oid,:lng]
address CMDbatSUBsignalaccum
comment "Return B1 - B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command sub_noerror(b1:bat[:oid,:lng],b2:bat[:oid,:wrd]) :bat[:oid,:lng]
address CMDbatSUB
comment "Return B1 - B2, overflow causes NIL value";
pattern -(b:bat[:oid,:lng],v:wrd) :bat[:oid,:lng]
address CMDbatSUBcstsignal
comment "Return B - V, signal error on overflow";
pattern -(b:bat[:oid,:lng],v:wrd,accum:int) :bat[:oid,:lng]
address CMDbatSUBcstsignal
comment "Return B - V, signal error on overflow, reuse B if ACCUM is set";
pattern sub_noerror(b:bat[:oid,:lng],v:wrd) :bat[:oid,:lng]
address CMDbatSUBcst
comment "Return B - V, overflow causes NIL value";
pattern -(v:lng,b:bat[:oid,:wrd]) :bat[:oid,:lng]
address CMDbatSUBcstsignal
comment "Return V - B, signal error on overflow";
pattern sub_noerror(v:lng,b:bat[:oid,:wrd]) :bat[:oid,:lng]
address CMDbatSUBcst
comment "Return V - B, overflow causes NIL value";

command -(b1:bat[:oid,:lng],b2:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatSUBsignal
comment "Return B1 - B2, signal error on overflow";
command -(b1:bat[:oid,:lng],b2:bat[:oid,:lng],accum:int) :bat[:oid,:lng]
address CMDbatSUBsignalaccum
comment "Return B1 - B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command sub_noerror(b1:bat[:oid,:lng],b2:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatSUB
comment "Return B1 - B2, overflow causes NIL value";
pattern -(b:bat[:oid,:lng],v:lng) :bat[:oid,:lng]
address CMDbatSUBcstsignal
comment "Return B - V, signal error on overflow";
pattern -(b:bat[:oid,:lng],v:lng,accum:int) :bat[:oid,:lng]
address CMDbatSUBcstsignal
comment "Return B - V, signal error on overflow, reuse B if ACCUM is set";
pattern sub_noerror(b:bat[:oid,:lng],v:lng) :bat[:oid,:lng]
address CMDbatSUBcst
comment "Return B - V, overflow causes NIL value";
pattern -(v:lng,b:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatSUBcstsignal
comment "Return V - B, signal error on overflow";
pattern -(v:lng,b:bat[:oid,:lng],accum:int) :bat[:oid,:lng]
address CMDbatSUBcstsignal
comment "Return V - B, signal error on overflow, reuse B if ACCUM is set";
pattern sub_noerror(v:lng,b:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatSUBcst
comment "Return V - B, overflow causes NIL value";

command -(b1:bat[:oid,:lng],b2:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatSUBsignal
comment "Return B1 - B2, signal error on overflow";
command -(b1:bat[:oid,:lng],b2:bat[:oid,:flt],accum:int) :bat[:oid,:flt]
address CMDbatSUBsignalaccum
comment "Return B1 - B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command sub_noerror(b1:bat[:oid,:lng],b2:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatSUB
comment "Return B1 - B2, overflow causes NIL value";
pattern -(b:bat[:oid,:lng],v:flt) :bat[:oid,:flt]
address CMDbatSUBcstsignal
comment "Return B - V, signal error on overflow";
pattern sub_noerror(b:bat[:oid,:lng],v:flt) :bat[:oid,:flt]
address CMDbatSUBcst
comment "Return B - V, overflow causes NIL value";
pattern -(v:lng,b:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatSUBcstsignal
comment "Return V - B, signal error on overflow";
pattern -(v:lng,b:bat[:oid,:flt],accum:int) :bat[:oid,:flt]
address CMDbatSUBcstsignal
comment "Return V - B, signal error on overflow, reuse B if ACCUM is set";
pattern sub_noerror(v:lng,b:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatSUBcst
comment "Return V - B, overflow causes NIL value";

command -(b1:bat[:oid,:lng],b2:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatSUBsignal
comment "Return B1 - B2, signal error on overflow";
command -(b1:bat[:oid,:lng],b2:bat[:oid,:dbl],accum:int) :bat[:oid,:dbl]
address CMDbatSUBsignalaccum
comment "Return B1 - B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command sub_noerror(b1:bat[:oid,:lng],b2:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatSUB
comment "Return B1 - B2, overflow causes NIL value";
pattern -(b:bat[:oid,:lng],v:dbl) :bat[:oid,:dbl]
address CMDbatSUBcstsignal
comment "Return B - V, signal error on overflow";
pattern sub_noerror(b:bat[:oid,:lng],v:dbl) :bat[:oid,:dbl]
address CMDbatSUBcst
comment "Return B - V, overflow causes NIL value";
pattern -(v:lng,b:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatSUBcstsignal
comment "Return V - B, signal error on overflow";
pattern -(v:lng,b:bat[:oid,:dbl],accum:int) :bat[:oid,:dbl]
address CMDbatSUBcstsignal
comment "Return V - B, signal error on overflow, reuse B if ACCUM is set";
pattern sub_noerror(v:lng,b:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatSUBcst
comment "Return V - B, overflow causes NIL value";

command -(b1:bat[:oid,:flt],b2:bat[:oid,:bte]) :bat[:oid,:flt]
address CMDbatSUBsignal
comment "Return B1 - B2, signal error on overflow";
command -(b1:bat[:oid,:flt],b2:bat[:oid,:bte],accum:int) :bat[:oid,:flt]
address CMDbatSUBsignalaccum
comment "Return B1 - B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command sub_noerror(b1:bat[:oid,:flt],b2:bat[:oid,:bte]) :bat[:oid,:flt]
address CMDbatSUB
comment "Return B1 - B2, overflow causes NIL value";
pattern -(b:bat[:oid,:flt],v:bte) :bat[:oid,:flt]
address CMDbatSUBcstsignal
comment "Return B - V, signal error on overflow";
pattern -(b:bat[:oid,:flt],v:bte,accum:int) :bat[:oid,:flt]
address CMDbatSUBcstsignal
comment "Return B - V, signal error on overflow, reuse B if ACCUM is set";
pattern sub_noerror(b:bat[:oid,:flt],v:bte) :bat[:oid,:flt]
address CMDbatSUBcst
comment "Return B - V, overflow causes NIL value";
pattern -(v:flt,b:bat[:oid,:bte]) :bat[:oid,:flt]
address CMDbatSUBcstsignal
comment "Return V - B, signal error on overflow";
pattern sub_noerror(v:flt,b:bat[:oid,:bte]) :bat[:oid,:flt]
address CMDbatSUBcst
comment "Return V - B, overflow causes NIL value";

command -(b1:bat[:oid,:flt],b2:bat[:oid,:sht]) :bat[:oid,:flt]
address CMDbatSUBsignal
comment "Return B1 - B2, signal error on overflow";
command -(b1:bat[:oid,:flt],b2:bat[:oid,:sht],accum:int) :bat[:oid,:flt]
address CMDbatSUBsignalaccum
comment "Return B1 - B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command sub_noerror(b1:bat[:oid,:flt],b2:bat[:oid,:sht]) :bat[:oid,:flt]
address CMDbatSUB
comment "Return B1 - B2, overflow causes NIL value";
pattern -(b:bat[:oid,:flt],v:sht) :bat[:oid,:flt]
address CMDbatSUBcstsignal
comment "Return B - V, signal error on overflow";
pattern -(b:bat[:oid,:flt],v:sht,accum:int) :bat[:oid,:flt]
address CMDbatSUBcstsignal
comment "Return B - V, signal error on overflow, reuse B if ACCUM is set";
pattern sub_noerror(b:bat[:oid,:flt],v:sht) :bat[:oid,:flt]
address CMDbatSUBcst
comment "Return B - V, overflow causes NIL value";
pattern -(v:flt,b:bat[:oid,:sht]) :bat[:oid,:flt]
address CMDbatSUBcstsignal
comment "Return V - B, signal error on overflow";
pattern sub_noerror(v:flt,b:bat[:oid,:sht]) :bat[:oid,:flt]
address CMDbatSUBcst
comment "Return V - B, overflow causes NIL value";

command -(b1:bat[:oid,:flt],b2:bat[:oid,:int]) :bat[:oid,:flt]
address CMDbatSUBsignal
comment "Return B1 - B2, signal error on overflow";
command -(b1:bat[:oid,:flt],b2:bat[:oid,:int],accum:int) :bat[:oid,:flt]
address CMDbatSUBsignalaccum
comment "Return B1 - B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command sub_noerror(b1:bat[:oid,:flt],b2:bat[:oid,:int]) :bat[:oid,:flt]
address CMDbatSUB
comment "Return B1 - B2, overflow causes NIL value";
pattern -(b:bat[:oid,:flt],v:int) :bat[:oid,:flt]
address CMDbatSUBcstsignal
comment "Return B - V, signal error on overflow";
pattern -(b:bat[:oid,:flt],v:int,accum:int) :bat[:oid,:flt]
address CMDbatSUBcstsignal
comment "Return B - V, signal error on overflow, reuse B if ACCUM is set";
pattern sub_noerror(b:bat[:oid,:flt],v:int) :bat[:oid,:flt]
address CMDbatSUBcst
comment "Return B - V, overflow causes NIL value";
pattern -(v:flt,b:bat[:oid,:int]) :bat[:oid,:flt]
address CMDbatSUBcstsignal
comment "Return V - B, signal error on overflow";
pattern sub_noerror(v:flt,b:bat[:oid,:int]) :bat[:oid,:flt]
address CMDbatSUBcst
comment "Return V - B, overflow causes NIL value";

command -(b1:bat[:oid,:flt],b2:bat[:oid,:wrd]) :bat[:oid,:flt]
address CMDbatSUBsignal
comment "Return B1 - B2, signal error on overflow";
command -(b1:bat[:oid,:flt],b2:bat[:oid,:wrd],accum:int) :bat[:oid,:flt]
address CMDbatSUBsignalaccum
comment "Return B1 - B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command sub_noerror(b1:bat[:oid,:flt],b2:bat[:oid,:wrd]) :bat[:oid,:flt]
address CMDbatSUB
comment "Return B1 - B2, overflow causes NIL value";
pattern -(b:bat[:oid,:flt],v:wrd) :bat[:oid,:flt]
address CMDbatSUBcstsignal
comment "Return B - V, signal error on overflow";
pattern -(b:bat[:oid,:flt],v:wrd,accum:int) :bat[:oid,:flt]
address CMDbatSUBcstsignal
comment "Return B - V, signal error on overflow, reuse B if ACCUM is set";
pattern sub_noerror(b:bat[:oid,:flt],v:wrd) :bat[:oid,:flt]
address CMDbatSUBcst
comment "Return B - V, overflow causes NIL value";
pattern -(v:flt,b:bat[:oid,:wrd]) :bat[:oid,:flt]
address CMDbatSUBcstsignal
comment "Return V - B, signal error on overflow";
pattern sub_noerror(v:flt,b:bat[:oid,:wrd]) :bat[:oid,:flt]
address CMDbatSUBcst
comment "Return V - B, overflow causes NIL value";

command -(b1:bat[:oid,:flt],b2:bat[:oid,:lng]) :bat[:oid,:flt]
address CMDbatSUBsignal
comment "Return B1 - B2, signal error on overflow";
command -(b1:bat[:oid,:flt],b2:bat[:oid,:lng],accum:int) :bat[:oid,:flt]
address CMDbatSUBsignalaccum
comment "Return B1 - B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command sub_noerror(b1:bat[:oid,:flt],b2:bat[:oid,:lng]) :bat[:oid,:flt]
address CMDbatSUB
comment "Return B1 - B2, overflow causes NIL value";
pattern -(b:bat[:oid,:flt],v:lng) :bat[:oid,:flt]
address CMDbatSUBcstsignal
comment "Return B - V, signal error on overflow";
pattern -(b:bat[:oid,:flt],v:lng,accum:int) :bat[:oid,:flt]
address CMDbatSUBcstsignal
comment "Return B - V, signal error on overflow, reuse B if ACCUM is set";
pattern sub_noerror(b:bat[:oid,:flt],v:lng) :bat[:oid,:flt]
address CMDbatSUBcst
comment "Return B - V, overflow causes NIL value";
pattern -(v:flt,b:bat[:oid,:lng]) :bat[:oid,:flt]
address CMDbatSUBcstsignal
comment "Return V - B, signal error on overflow";
pattern sub_noerror(v:flt,b:bat[:oid,:lng]) :bat[:oid,:flt]
address CMDbatSUBcst
comment "Return V - B, overflow causes NIL value";

command -(b1:bat[:oid,:flt],b2:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatSUBsignal
comment "Return B1 - B2, signal error on overflow";
command -(b1:bat[:oid,:flt],b2:bat[:oid,:flt],accum:int) :bat[:oid,:flt]
address CMDbatSUBsignalaccum
comment "Return B1 - B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command sub_noerror(b1:bat[:oid,:flt],b2:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatSUB
comment "Return B1 - B2, overflow causes NIL value";
pattern -(b:bat[:oid,:flt],v:flt) :bat[:oid,:flt]
address CMDbatSUBcstsignal
comment "Return B - V, signal error on overflow";
pattern -(b:bat[:oid,:flt],v:flt,accum:int) :bat[:oid,:flt]
address CMDbatSUBcstsignal
comment "Return B - V, signal error on overflow, reuse B if ACCUM is set";
pattern sub_noerror(b:bat[:oid,:flt],v:flt) :bat[:oid,:flt]
address CMDbatSUBcst
comment "Return B - V, overflow causes NIL value";
pattern -(v:flt,b:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatSUBcstsignal
comment "Return V - B, signal error on overflow";
pattern -(v:flt,b:bat[:oid,:flt],accum:int) :bat[:oid,:flt]
address CMDbatSUBcstsignal
comment "Return V - B, signal error on overflow, reuse B if ACCUM is set";
pattern sub_noerror(v:flt,b:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatSUBcst
comment "Return V - B, overflow causes NIL value";

command -(b1:bat[:oid,:flt],b2:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatSUBsignal
comment "Return B1 - B2, signal error on overflow";
command -(b1:bat[:oid,:flt],b2:bat[:oid,:dbl],accum:int) :bat[:oid,:dbl]
address CMDbatSUBsignalaccum
comment "Return B1 - B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command sub_noerror(b1:bat[:oid,:flt],b2:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatSUB
comment "Return B1 - B2, overflow causes NIL value";
pattern -(b:bat[:oid,:flt],v:dbl) :bat[:oid,:dbl]
address CMDbatSUBcstsignal
comment "Return B - V, signal error on overflow";
pattern sub_noerror(b:bat[:oid,:flt],v:dbl) :bat[:oid,:dbl]
address CMDbatSUBcst
comment "Return B - V, overflow causes NIL value";
pattern -(v:flt,b:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatSUBcstsignal
comment "Return V - B, signal error on overflow";
pattern -(v:flt,b:bat[:oid,:dbl],accum:int) :bat[:oid,:dbl]
address CMDbatSUBcstsignal
comment "Return V - B, signal error on overflow, reuse B if ACCUM is set";
pattern sub_noerror(v:flt,b:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatSUBcst
comment "Return V - B, overflow causes NIL value";

command -(b1:bat[:oid,:dbl],b2:bat[:oid,:bte]) :bat[:oid,:dbl]
address CMDbatSUBsignal
comment "Return B1 - B2, signal error on overflow";
command -(b1:bat[:oid,:dbl],b2:bat[:oid,:bte],accum:int) :bat[:oid,:dbl]
address CMDbatSUBsignalaccum
comment "Return B1 - B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command sub_noerror(b1:bat[:oid,:dbl],b2:bat[:oid,:bte]) :bat[:oid,:dbl]
address CMDbatSUB
comment "Return B1 - B2, overflow causes NIL value";
pattern -(b:bat[:oid,:dbl],v:bte) :bat[:oid,:dbl]
address CMDbatSUBcstsignal
comment "Return B - V, signal error on overflow";
pattern -(b:bat[:oid,:dbl],v:bte,accum:int) :bat[:oid,:dbl]
address CMDbatSUBcstsignal
comment "Return B - V, signal error on overflow, reuse B if ACCUM is set";
pattern sub_noerror(b:bat[:oid,:dbl],v:bte) :bat[:oid,:dbl]
address CMDbatSUBcst
comment "Return B - V, overflow causes NIL value";
pattern -(v:dbl,b:bat[:oid,:bte]) :bat[:oid,:dbl]
address CMDbatSUBcstsignal
comment "Return V - B, signal error on overflow";
pattern sub_noerror(v:dbl,b:bat[:oid,:bte]) :bat[:oid,:dbl]
address CMDbatSUBcst
comment "Return V - B, overflow causes NIL value";

command -(b1:bat[:oid,:dbl],b2:bat[:oid,:sht]) :bat[:oid,:dbl]
address CMDbatSUBsignal
comment "Return B1 - B2, signal error on overflow";
command -(b1:bat[:oid,:dbl],b2:bat[:oid,:sht],accum:int) :bat[:oid,:dbl]
address CMDbatSUBsignalaccum
comment "Return B1 - B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command sub_noerror(b1:bat[:oid,:dbl],b2:bat[:oid,:sht]) :bat[:oid,:dbl]
address CMDbatSUB
comment "Return B1 - B2, overflow causes NIL value";
pattern -(b:bat[:oid,:dbl],v:sht) :bat[:oid,:dbl]
address CMDbatSUBcstsignal
comment "Return B - V, signal error on overflow";
pattern -(b:bat[:oid,:dbl],v:sht,accum:int) :bat[:oid,:dbl]
address CMDbatSUBcstsignal
comment "Return B - V, signal error on overflow, reuse B if ACCUM is set";
pattern sub_noerror(b:bat[:oid,:dbl],v:sht) :bat[:oid,:dbl]
address CMDbatSUBcst
comment "Return B - V, overflow causes NIL value";
pattern -(v:dbl,b:bat[:oid,:sht]) :bat[:oid,:dbl]
address CMDbatSUBcstsignal
comment "Return V - B, signal error on overflow";
pattern sub_noerror(v:dbl,b:bat[:oid,:sht]) :bat[:oid,:dbl]
address CMDbatSUBcst
comment "Return V - B, overflow causes NIL value";

command -(b1:bat[:oid,:dbl],b2:bat[:oid,:int]) :bat[:oid,:dbl]
address CMDbatSUBsignal
comment "Return B1 - B2, signal error on overflow";
command -(b1:bat[:oid,:dbl],b2:bat[:oid,:int],accum:int) :bat[:oid,:dbl]
address CMDbatSUBsignalaccum
comment "Return B1 - B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command sub_noerror(b1:bat[:oid,:dbl],b2:bat[:oid,:int]) :bat[:oid,:dbl]
address CMDbatSUB
comment "Return B1 - B2, overflow causes NIL value";
pattern -(b:bat[:oid,:dbl],v:int) :bat[:oid,:dbl]
address CMDbatSUBcstsignal
comment "Return B - V, signal error on overflow";
pattern -(b:bat[:oid,:dbl],v:int,accum:int) :bat[:oid,:dbl]
address CMDbatSUBcstsignal
comment "Return B - V, signal error on overflow, reuse B if ACCUM is set";
pattern sub_noerror(b:bat[:oid,:dbl],v:int) :bat[:oid,:dbl]
address CMDbatSUBcst
comment "Return B - V, overflow causes NIL value";
pattern -(v:dbl,b:bat[:oid,:int]) :bat[:oid,:dbl]
address CMDbatSUBcstsignal
comment "Return V - B, signal error on overflow";
pattern sub_noerror(v:dbl,b:bat[:oid,:int]) :bat[:oid,:dbl]
address CMDbatSUBcst
comment "Return V - B, overflow causes NIL value";

command -(b1:bat[:oid,:dbl],b2:bat[:oid,:wrd]) :bat[:oid,:dbl]
address CMDbatSUBsignal
comment "Return B1 - B2, signal error on overflow";
command -(b1:bat[:oid,:dbl],b2:bat[:oid,:wrd],accum:int) :bat[:oid,:dbl]
address CMDbatSUBsignalaccum
comment "Return B1 - B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command sub_noerror(b1:bat[:oid,:dbl],b2:bat[:oid,:wrd]) :bat[:oid,:dbl]
address CMDbatSUB
comment "Return B1 - B2, overflow causes NIL value";
pattern -(b:bat[:oid,:dbl],v:wrd) :bat[:oid,:dbl]
address CMDbatSUBcstsignal
comment "Return B - V, signal error on overflow";
pattern -(b:bat[:oid,:dbl],v:wrd,accum:int) :bat[:oid,:dbl]
address CMDbatSUBcstsignal
comment "Return B - V, signal error on overflow, reuse B if ACCUM is set";
pattern sub_noerror(b:bat[:oid,:dbl],v:wrd) :bat[:oid,:dbl]
address CMDbatSUBcst
comment "Return B - V, overflow causes NIL value";
pattern -(v:dbl,b:bat[:oid,:wrd]) :bat[:oid,:dbl]
address CMDbatSUBcstsignal
comment "Return V - B, signal error on overflow";
pattern sub_noerror(v:dbl,b:bat[:oid,:wrd]) :bat[:oid,:dbl]
address CMDbatSUBcst
comment "Return V - B, overflow causes NIL value";

command -(b1:bat[:oid,:dbl],b2:bat[:oid,:lng]) :bat[:oid,:dbl]
address CMDbatSUBsignal
comment "Return B1 - B2, signal error on overflow";
command -(b1:bat[:oid,:dbl],b2:bat[:oid,:lng],accum:int) :bat[:oid,:dbl]
address CMDbatSUBsignalaccum
comment "Return B1 - B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command sub_noerror(b1:bat[:oid,:dbl],b2:bat[:oid,:lng]) :bat[:oid,:dbl]
address CMDbatSUB
comment "Return B1 - B2, overflow causes NIL value";
pattern -(b:bat[:oid,:dbl],v:lng) :bat[:oid,:dbl]
address CMDbatSUBcstsignal
comment "Return B - V, signal error on overflow";
pattern -(b:bat[:oid,:dbl],v:lng,accum:int) :bat[:oid,:dbl]
address CMDbatSUBcstsignal
comment "Return B - V, signal error on overflow, reuse B if ACCUM is set";
pattern sub_noerror(b:bat[:oid,:dbl],v:lng) :bat[:oid,:dbl]
address CMDbatSUBcst
comment "Return B - V, overflow causes NIL value";
pattern -(v:dbl,b:bat[:oid,:lng]) :bat[:oid,:dbl]
address CMDbatSUBcstsignal
comment "Return V - B, signal error on overflow";
pattern sub_noerror(v:dbl,b:bat[:oid,:lng]) :bat[:oid,:dbl]
address CMDbatSUBcst
comment "Return V - B, overflow causes NIL value";

command -(b1:bat[:oid,:dbl],b2:bat[:oid,:flt]) :bat[:oid,:dbl]
address CMDbatSUBsignal
comment "Return B1 - B2, signal error on overflow";
command -(b1:bat[:oid,:dbl],b2:bat[:oid,:flt],accum:int) :bat[:oid,:dbl]
address CMDbatSUBsignalaccum
comment "Return B1 - B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command sub_noerror(b1:bat[:oid,:dbl],b2:bat[:oid,:flt]) :bat[:oid,:dbl]
address CMDbatSUB
comment "Return B1 - B2, overflow causes NIL value";
pattern -(b:bat[:oid,:dbl],v:flt) :bat[:oid,:dbl]
address CMDbatSUBcstsignal
comment "Return B - V, signal error on overflow";
pattern -(b:bat[:oid,:dbl],v:flt,accum:int) :bat[:oid,:dbl]
address CMDbatSUBcstsignal
comment "Return B - V, signal error on overflow, reuse B if ACCUM is set";
pattern sub_noerror(b:bat[:oid,:dbl],v:flt) :bat[:oid,:dbl]
address CMDbatSUBcst
comment "Return B - V, overflow causes NIL value";
pattern -(v:dbl,b:bat[:oid,:flt]) :bat[:oid,:dbl]
address CMDbatSUBcstsignal
comment "Return V - B, signal error on overflow";
pattern sub_noerror(v:dbl,b:bat[:oid,:flt]) :bat[:oid,:dbl]
address CMDbatSUBcst
comment "Return V - B, overflow causes NIL value";

command -(b1:bat[:oid,:dbl],b2:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatSUBsignal
comment "Return B1 - B2, signal error on overflow";
command -(b1:bat[:oid,:dbl],b2:bat[:oid,:dbl],accum:int) :bat[:oid,:dbl]
address CMDbatSUBsignalaccum
comment "Return B1 - B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command sub_noerror(b1:bat[:oid,:dbl],b2:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatSUB
comment "Return B1 - B2, overflow causes NIL value";
pattern -(b:bat[:oid,:dbl],v:dbl) :bat[:oid,:dbl]
address CMDbatSUBcstsignal
comment "Return B - V, signal error on overflow";
pattern -(b:bat[:oid,:dbl],v:dbl,accum:int) :bat[:oid,:dbl]
address CMDbatSUBcstsignal
comment "Return B - V, signal error on overflow, reuse B if ACCUM is set";
pattern sub_noerror(b:bat[:oid,:dbl],v:dbl) :bat[:oid,:dbl]
address CMDbatSUBcst
comment "Return B - V, overflow causes NIL value";
pattern -(v:dbl,b:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatSUBcstsignal
comment "Return V - B, signal error on overflow";
pattern -(v:dbl,b:bat[:oid,:dbl],accum:int) :bat[:oid,:dbl]
address CMDbatSUBcstsignal
comment "Return V - B, signal error on overflow, reuse B if ACCUM is set";
pattern sub_noerror(v:dbl,b:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatSUBcst
comment "Return V - B, overflow causes NIL value";


command *(b1:bat[:oid,:bte],b2:bat[:oid,:bte]) :bat[:oid,:bte]
address CMDbatMULsignal
comment "Return B1 * B2, signal error on overflow";
command *(b1:bat[:oid,:bte],b2:bat[:oid,:bte],accum:int) :bat[:oid,:bte]
address CMDbatMULsignalaccum
comment "Return B1 * B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command mul_noerror(b1:bat[:oid,:bte],b2:bat[:oid,:bte]) :bat[:oid,:bte]
address CMDbatMUL
comment "Return B1 * B2, overflow causes NIL value";
pattern *(b:bat[:oid,:bte],v:bte) :bat[:oid,:bte]
address CMDbatMULcstsignal
comment "Return B * V, signal error on overflow";
pattern *(b:bat[:oid,:bte],v:bte,accum:int) :bat[:oid,:bte]
address CMDbatMULcstsignal
comment "Return B * V, signal error on overflow, reuse B if ACCUM is set";
pattern mul_noerror(b:bat[:oid,:bte],v:bte) :bat[:oid,:bte]
address CMDbatMULcst
comment "Return B * V, overflow causes NIL value";
pattern *(v:bte,b:bat[:oid,:bte]) :bat[:oid,:bte]
address CMDbatMULcstsignal
comment "Return V * B, signal error on overflow";
pattern *(v:bte,b:bat[:oid,:bte],accum:int) :bat[:oid,:bte]
address CMDbatMULcstsignal
comment "Return V * B, signal error on overflow, reuse B if ACCUM is set";
pattern mul_noerror(v:bte,b:bat[:oid,:bte]) :bat[:oid,:bte]
address CMDbatMULcst
comment "Return V * B, overflow causes NIL value";

command *(b1:bat[:oid,:bte],b2:bat[:oid,:sht]) :bat[:oid,:sht]
address CMDbatMULsignal
comment "Return B1 * B2, signal error on overflow";
command *(b1:bat[:oid,:bte],b2:bat[:oid,:sht],accum:int) :bat[:oid,:sht]
address CMDbatMULsignalaccum
comment "Return B1 * B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command mul_noerror(b1:bat[:oid,:bte],b2:bat[:oid,:sht]) :bat[:oid,:sht]
address CMDbatMUL
comment "Return B1 * B2, overflow causes NIL value";
pattern *(b:bat[:oid,:bte],v:sht) :bat[:oid,:sht]
address CMDbatMULcstsignal
comment "Return B * V, signal error on overflow";
pattern mul_noerror(b:bat[:oid,:bte],v:sht) :bat[:oid,:sht]
address CMDbatMULcst
comment "Return B * V, overflow causes NIL value";
pattern *(v:bte,b:bat[:oid,:sht]) :bat[:oid,:sht]
address CMDbatMULcstsignal
comment "Return V * B, signal error on overflow";
pattern *(v:bte,b:bat[:oid,:sht],accum:int) :bat[:oid,:sht]
address CMDbatMULcstsignal
comment "Return V * B, signal error on overflow, reuse B if ACCUM is set";
pattern mul_noerror(v:bte,b:bat[:oid,:sht]) :bat[:oid,:sht]
address CMDbatMULcst
comment "Return V * B, overflow causes NIL value";

command *(b1:bat[:oid,:bte],b2:bat[:oid,:int]) :bat[:oid,:int]
address CMDbatMULsignal
comment "Return B1 * B2, signal error on overflow";
command *(b1:bat[:oid,:bte],b2:bat[:oid,:int],accum:int) :bat[:oid,:int]
address CMDbatMULsignalaccum
comment "Return B1 * B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command mul_noerror(b1:bat[:oid,:bte],b2:bat[:oid,:int]) :bat[:oid,:int]
address CMDbatMUL
comment "Return B1 * B2, overflow causes NIL value";
pattern *(b:bat[:oid,:bte],v:int) :bat[:oid,:int]
address CMDbatMULcstsignal
comment "Return B * V, signal error on overflow";
pattern mul_noerror(b:bat[:oid,:bte],v:int) :bat[:oid,:int]
address CMDbatMULcst
comment "Return B * V, overflow causes NIL value";
pattern *(v:bte,b:bat[:oid,:int]) :bat[:oid,:int]
address CMDbatMULcstsignal
comment "Return V * B, signal error on overflow";
pattern *(v:bte,b:bat[:oid,:int],accum:int) :bat[:oid,:int]
address CMDbatMULcstsignal
comment "Return V * B, signal error on overflow, reuse B if ACCUM is set";
pattern mul_noerror(v:bte,b:bat[:oid,:int]) :bat[:oid,:int]
address CMDbatMULcst
comment "Return V * B, overflow causes NIL value";

command *(b1:bat[:oid,:bte],b2:bat[:oid,:wrd]) :bat[:oid,:wrd]
address CMDbatMULsignal
comment "Return B1 * B2, signal error on overflow";
command *(b1:bat[:oid,:bte],b2:bat[:oid,:wrd],accum:int) :bat[:oid,:wrd]
address CMDbatMULsignalaccum
comment "Return B1 * B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command mul_noerror(b1:bat[:oid,:bte],b2:bat[:oid,:wrd]) :bat[:oid,:wrd]
address CMDbatMUL
comment "Return B1 * B2, overflow causes NIL value";
pattern *(b:bat[:oid,:bte],v:wrd) :bat[:oid,:wrd]
address CMDbatMULcstsignal
comment "Return B * V, signal error on overflow";
pattern mul_noerror(b:bat[:oid,:bte],v:wrd) :bat[:oid,:wrd]
address CMDbatMULcst
comment "Return B * V, overflow causes NIL value";
pattern *(v:bte,b:bat[:oid,:wrd]) :bat[:oid,:wrd]
address CMDbatMULcstsignal
comment "Return V * B, signal error on overflow";
pattern *(v:bte,b:bat[:oid,:wrd],accum:int) :bat[:oid,:wrd]
address CMDbatMULcstsignal
comment "Return V * B, signal error on overflow, reuse B if ACCUM is set";
pattern mul_noerror(v:bte,b:bat[:oid,:wrd]) :bat[:oid,:wrd]
address CMDbatMULcst
comment "Return V * B, overflow causes NIL value";

command *(b1:bat[:oid,:bte],b2:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatMULsignal
comment "Return B1 * B2, signal error on overflow";
command *(b1:bat[:oid,:bte],b2:bat[:oid,:lng],accum:int) :bat[:oid,:lng]
address CMDbatMULsignalaccum
comment "Return B1 * B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command mul_noerror(b1:bat[:oid,:bte],b2:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatMUL
comment "Return B1 * B2, overflow causes NIL value";
pattern *(b:bat[:oid,:bte],v:lng) :bat[:oid,:lng]
address CMDbatMULcstsignal
comment "Return B * V, signal error on overflow";
pattern mul_noerror(b:bat[:oid,:bte],v:lng) :bat[:oid,:lng]
address CMDbatMULcst
comment "Return B * V, overflow causes NIL value";
pattern *(v:bte,b:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatMULcstsignal
comment "Return V * B, signal error on overflow";
pattern *(v:bte,b:bat[:oid,:lng],accum:int) :bat[:oid,:lng]
address CMDbatMULcstsignal
comment "Return V * B, signal error on overflow, reuse B if ACCUM is set";
pattern mul_noerror(v:bte,b:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatMULcst
comment "Return V * B, overflow causes NIL value";

command *(b1:bat[:oid,:bte],b2:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatMULsignal
comment "Return B1 * B2, signal error on overflow";
command *(b1:bat[:oid,:bte],b2:bat[:oid,:flt],accum:int) :bat[:oid,:flt]
address CMDbatMULsignalaccum
comment "Return B1 * B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command mul_noerror(b1:bat[:oid,:bte],b2:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatMUL
comment "Return B1 * B2, overflow causes NIL value";
pattern *(b:bat[:oid,:bte],v:flt) :bat[:oid,:flt]
address CMDbatMULcstsignal
comment "Return B * V, signal error on overflow";
pattern mul_noerror(b:bat[:oid,:bte],v:flt) :bat[:oid,:flt]
address CMDbatMULcst
comment "Return B * V, overflow causes NIL value";
pattern *(v:bte,b:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatMULcstsignal
comment "Return V * B, signal error on overflow";
pattern *(v:bte,b:bat[:oid,:flt],accum:int) :bat[:oid,:flt]
address CMDbatMULcstsignal
comment "Return V * B, signal error on overflow, reuse B if ACCUM is set";
pattern mul_noerror(v:bte,b:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatMULcst
comment "Return V * B, overflow causes NIL value";

command *(b1:bat[:oid,:bte],b2:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatMULsignal
comment "Return B1 * B2, signal error on overflow";
command *(b1:bat[:oid,:bte],b2:bat[:oid,:dbl],accum:int) :bat[:oid,:dbl]
address CMDbatMULsignalaccum
comment "Return B1 * B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command mul_noerror(b1:bat[:oid,:bte],b2:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatMUL
comment "Return B1 * B2, overflow causes NIL value";
pattern *(b:bat[:oid,:bte],v:dbl) :bat[:oid,:dbl]
address CMDbatMULcstsignal
comment "Return B * V, signal error on overflow";
pattern mul_noerror(b:bat[:oid,:bte],v:dbl) :bat[:oid,:dbl]
address CMDbatMULcst
comment "Return B * V, overflow causes NIL value";
pattern *(v:bte,b:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatMULcstsignal
comment "Return V * B, signal error on overflow";
pattern *(v:bte,b:bat[:oid,:dbl],accum:int) :bat[:oid,:dbl]
address CMDbatMULcstsignal
comment "Return V * B, signal error on overflow, reuse B if ACCUM is set";
pattern mul_noerror(v:bte,b:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatMULcst
comment "Return V * B, overflow causes NIL value";

command *(b1:bat[:oid,:sht],b2:bat[:oid,:bte]) :bat[:oid,:sht]
address CMDbatMULsignal
comment "Return B1 * B2, signal error on overflow";
command *(b1:bat[:oid,:sht],b2:bat[:oid,:bte],accum:int) :bat[:oid,:sht]
address CMDbatMULsignalaccum
comment "Return B1 * B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command mul_noerror(b1:bat[:oid,:sht],b2:bat[:oid,:bte]) :bat[:oid,:sht]
address CMDbatMUL
comment "Return B1 * B2, overflow causes NIL value";
pattern *(b:bat[:oid,:sht],v:bte) :bat[:oid,:sht]
address CMDbatMULcstsignal
comment "Return B * V, signal error on overflow";
pattern *(b:bat[:oid,:sht],v:bte,accum:int) :bat[:oid,:sht]
address CMDbatMULcstsignal
comment "Return B * V, signal error on overflow, reuse B if ACCUM is set";
pattern mul_noerror(b:bat[:oid,:sht],v:bte) :bat[:oid,:sht]
address CMDbatMULcst
comment "Return B * V, overflow causes NIL value";
pattern *(v:sht,b:bat[:oid,:bte]) :bat[:oid,:sht]
address CMDbatMULcstsignal
comment "Return V * B, signal error on overflow";
pattern mul_noerror(v:sht,b:bat[:oid,:bte]) :bat[:oid,:sht]
address CMDbatMULcst
comment "Return V * B, overflow causes NIL value";

command *(b1:bat[:oid,:sht],b2:bat[:oid,:sht]) :bat[:oid,:sht]
address CMDbatMULsignal
comment "Return B1 * B2, signal error on overflow";
command *(b1:bat[:oid,:sht],b2:bat[:oid,:sht],accum:int) :bat[:oid,:sht]
address CMDbatMULsignalaccum
comment "Return B1 * B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command mul_noerror(b1:bat[:oid,:sht],b2:bat[:oid,:sht]) :bat[:oid,:sht]
address CMDbatMUL
comment "Return B1 * B2, overflow causes NIL value";
pattern *(b:bat[:oid,:sht],v:sht) :bat[:oid,:sht]
address CMDbatMULcstsignal
comment "Return B * V, signal error on overflow";
pattern *(b:bat[:oid,:sht],v:sht,accum:int) :bat[:oid,:sht]
address CMDbatMULcstsignal
comment "Return B * V, signal error on overflow, reuse B if ACCUM is set";
pattern mul_noerror(b:bat[:oid,:sht],v:sht) :bat[:oid,:sht]
address CMDbatMULcst
comment "Return B * V, overflow causes NIL value";
pattern *(v:sht,b:bat[:oid,:sht]) :bat[:oid,:sht]
address CMDbatMULcstsignal
comment "Return V * B, signal error on overflow";
pattern *(v:sht,b:bat[:oid,:sht],accum:int) :bat[:oid,:sht]
address CMDbatMULcstsignal
comment "Return V * B, signal error on overflow, reuse B if ACCUM is set";
pattern mul_noerror(v:sht,b:bat[:oid,:sht]) :bat[:oid,:sht]
address CMDbatMULcst
comment "Return V * B, overflow causes NIL value";

command *(b1:bat[:oid,:sht],b2:bat[:oid,:int]) :bat[:oid,:int]
address CMDbatMULsignal
comment "Return B1 * B2, signal error on overflow";
command *(b1:bat[:oid,:sht],b2:bat[:oid,:int],accum:int) :bat[:oid,:int]
address CMDbatMULsignalaccum
comment "Return B1 * B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command mul_noerror(b1:bat[:oid,:sht],b2:bat[:oid,:int]) :bat[:oid,:int]
address CMDbatMUL
comment "Return B1 * B2, overflow causes NIL value";
pattern *(b:bat[:oid,:sht],v:int) :bat[:oid,:int]
address CMDbatMULcstsignal
comment "Return B * V, signal error on overflow";
pattern mul_noerror(b:bat[:oid,:sht],v:int) :bat[:oid,:int]
address CMDbatMULcst
comment "Return B * V, overflow causes NIL value";
pattern *(v:sht,b:bat[:oid,:int]) :bat[:oid,:int]
address CMDbatMULcstsignal
comment "Return V * B, signal error on overflow";
pattern *(v:sht,b:bat[:oid,:int],accum:int) :bat[:oid,:int]
address CMDbatMULcstsignal
comment "Return V * B, signal error on overflow, reuse B if ACCUM is set";
pattern mul_noerror(v:sht,b:bat[:oid,:int]) :bat[:oid,:int]
address CMDbatMULcst
comment "Return V * B, overflow causes NIL value";

command *(b1:bat[:oid,:sht],b2:bat[:oid,:wrd]) :bat[:oid,:wrd]
address CMDbatMULsignal
comment "Return B1 * B2, signal error on overflow";
command *(b1:bat[:oid,:sht],b2:bat[:oid,:wrd],accum:int) :bat[:oid,:wrd]
address CMDbatMULsignalaccum
comment "Return B1 * B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command mul_noerror(b1:bat[:oid,:sht],b2:bat[:oid,:wrd]) :bat[:oid,:wrd]
address CMDbatMUL
comment "Return B1 * B2, overflow causes NIL value";
pattern *(b:bat[:oid,:sht],v:wrd) :bat[:oid,:wrd]
address CMDbatMULcstsignal
comment "Return B * V, signal error on overflow";
pattern mul_noerror(b:bat[:oid,:sht],v:wrd) :bat[:oid,:wrd]
address CMDbatMULcst
comment "Return B * V, overflow causes NIL value";
pattern *(v:sht,b:bat[:oid,:wrd]) :bat[:oid,:wrd]
address CMDbatMULcstsignal
comment "Return V * B, signal error on overflow";
pattern *(v:sht,b:bat[:oid,:wrd],accum:int) :bat[:oid,:wrd]
address CMDbatMULcstsignal
comment "Return V * B, signal error on overflow, reuse B if ACCUM is set";
pattern mul_noerror(v:sht,b:bat[:oid,:wrd]) :bat[:oid,:wrd]
address CMDbatMULcst
comment "Return V * B, overflow causes NIL value";

command *(b1:bat[:oid,:sht],b2:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatMULsignal
comment "Return B1 * B2, signal error on overflow";
command *(b1:bat[:oid,:sht],b2:bat[:oid,:lng],accum:int) :bat[:oid,:lng]
address CMDbatMULsignalaccum
comment "Return B1 * B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command mul_noerror(b1:bat[:oid,:sht],b2:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatMUL
comment "Return B1 * B2, overflow causes NIL value";
pattern *(b:bat[:oid,:sht],v:lng) :bat[:oid,:lng]
address CMDbatMULcstsignal
comment "Return B * V, signal error on overflow";
pattern mul_noerror(b:bat[:oid,:sht],v:lng) :bat[:oid,:lng]
address CMDbatMULcst
comment "Return B * V, overflow causes NIL value";
pattern *(v:sht,b:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatMULcstsignal
comment "Return V * B, signal error on overflow";
pattern *(v:sht,b:bat[:oid,:lng],accum:int) :bat[:oid,:lng]
address CMDbatMULcstsignal
comment "Return V * B, signal error on overflow, reuse B if ACCUM is set";
pattern mul_noerror(v:sht,b:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatMULcst
comment "Return V * B, overflow causes NIL value";

command *(b1:bat[:oid,:sht],b2:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatMULsignal
comment "Return B1 * B2, signal error on overflow";
command *(b1:bat[:oid,:sht],b2:bat[:oid,:flt],accum:int) :bat[:oid,:flt]
address CMDbatMULsignalaccum
comment "Return B1 * B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command mul_noerror(b1:bat[:oid,:sht],b2:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatMUL
comment "Return B1 * B2, overflow causes NIL value";
pattern *(b:bat[:oid,:sht],v:flt) :bat[:oid,:flt]
address CMDbatMULcstsignal
comment "Return B * V, signal error on overflow";
pattern mul_noerror(b:bat[:oid,:sht],v:flt) :bat[:oid,:flt]
address CMDbatMULcst
comment "Return B * V, overflow causes NIL value";
pattern *(v:sht,b:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatMULcstsignal
comment "Return V * B, signal error on overflow";
pattern *(v:sht,b:bat[:oid,:flt],accum:int) :bat[:oid,:flt]
address CMDbatMULcstsignal
comment "Return V * B, signal error on overflow, reuse B if ACCUM is set";
pattern mul_noerror(v:sht,b:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatMULcst
comment "Return V * B, overflow causes NIL value";

command *(b1:bat[:oid,:sht],b2:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatMULsignal
comment "Return B1 * B2, signal error on overflow";
command *(b1:bat[:oid,:sht],b2:bat[:oid,:dbl],accum:int) :bat[:oid,:dbl]
address CMDbatMULsignalaccum
comment "Return B1 * B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command mul_noerror(b1:bat[:oid,:sht],b2:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatMUL
comment "Return B1 * B2, overflow causes NIL value";
pattern *(b:bat[:oid,:sht],v:dbl) :bat[:oid,:dbl]
address CMDbatMULcstsignal
comment "Return B * V, signal error on overflow";
pattern mul_noerror(b:bat[:oid,:sht],v:dbl) :bat[:oid,:dbl]
address CMDbatMULcst
comment "Return B * V, overflow causes NIL value";
pattern *(v:sht,b:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatMULcstsignal
comment "Return V * B, signal error on overflow";
pattern *(v:sht,b:bat[:oid,:dbl],accum:int) :bat[:oid,:dbl]
address CMDbatMULcstsignal
comment "Return V * B, signal error on overflow, reuse B if ACCUM is set";
pattern mul_noerror(v:sht,b:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatMULcst
comment "Return V * B, overflow causes NIL value";

command *(b1:bat[:oid,:int],b2:bat[:oid,:bte]) :bat[:oid,:int]
address CMDbatMULsignal
comment "Return B1 * B2, signal error on overflow";
command *(b1:bat[:oid,:int],b2:bat[:oid,:bte],accum:int) :bat[:oid,:int]
address CMDbatMULsignalaccum
comment "Return B1 * B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command mul_noerror(b1:bat[:oid,:int],b2:bat[:oid,:bte]) :bat[:oid,:int]
address CMDbatMUL
comment "Return B1 * B2, overflow causes NIL value";
pattern *(b:bat[:oid,:int],v:bte) :bat[:oid,:int]
address CMDbatMULcstsignal
comment "Return B * V, signal error on overflow";
pattern *(b:bat[:oid,:int],v:bte,accum:int) :bat[:oid,:int]
address CMDbatMULcstsignal
comment "Return B * V, signal error on overflow, reuse B if ACCUM is set";
pattern mul_noerror(b:bat[:oid,:int],v:bte) :bat[:oid,:int]
address CMDbatMULcst
comment "Return B * V, overflow causes NIL value";
pattern *(v:int,b:bat[:oid,:bte]) :bat[:oid,:int]
address CMDbatMULcstsignal
comment "Return V * B, signal error on overflow";
pattern mul_noerror(v:int,b:bat[:oid,:bte]) :bat[:oid,:int]
address CMDbatMULcst
comment "Return V * B, overflow causes NIL value";

command *(b1:bat[:oid,:int],b2:bat[:oid,:sht]) :bat[:oid,:int]
address CMDbatMULsignal
comment "Return B1 * B2, signal error on overflow";
command *(b1:bat[:oid,:int],b2:bat[:oid,:sht],accum:int) :bat[:oid,:int]
address CMDbatMULsignalaccum
comment "Return B1 * B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command mul_noerror(b1:bat[:oid,:int],b2:bat[:oid,:sht]) :bat[:oid,:int]
address CMDbatMUL
comment "Return B1 * B2, overflow causes NIL value";
pattern *(b:bat[:oid,:int],v:sht) :bat[:oid,:int]
address CMDbatMULcstsignal
comment "Return B * V, signal error on overflow";
pattern *(b:bat[:oid,:int],v:sht,accum:int) :bat[:oid,:int]
address CMDbatMULcstsignal
comment "Return B * V, signal error on overflow, reuse B if ACCUM is set";
pattern mul_noerror(b:bat[:oid,:int],v:sht) :bat[:oid,:int]
address CMDbatMULcst
comment "Return B * V, overflow causes NIL value";
pattern *(v:int,b:bat[:oid,:sht]) :bat[:oid,:int]
address CMDbatMULcstsignal
comment "Return V * B, signal error on overflow";
pattern mul_noerror(v:int,b:bat[:oid,:sht]) :bat[:oid,:int]
address CMDbatMULcst
comment "Return V * B, overflow causes NIL value";

command *(b1:bat[:oid,:int],b2:bat[:oid,:int]) :bat[:oid,:int]
address CMDbatMULsignal
comment "Return B1 * B2, signal error on overflow";
command *(b1:bat[:oid,:int],b2:bat[:oid,:int],accum:int) :bat[:oid,:int]
address CMDbatMULsignalaccum
comment "Return B1 * B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command mul_noerror(b1:bat[:oid,:int],b2:bat[:oid,:int]) :bat[:oid,:int]
address CMDbatMUL
comment "Return B1 * B2, overflow causes NIL value";
pattern *(b:bat[:oid,:int],v:int) :bat[:oid,:int]
address CMDbatMULcstsignal
comment "Return B * V, signal error on overflow";
pattern *(b:bat[:oid,:int],v:int,accum:int) :bat[:oid,:int]
address CMDbatMULcstsignal
comment "Return B * V, signal error on overflow, reuse B if ACCUM is set";
pattern mul_noerror(b:bat[:oid,:int],v:int) :bat[:oid,:int]
address CMDbatMULcst
comment "Return B * V, overflow causes NIL value";
pattern *(v:int,b:bat[:oid,:int]) :bat[:oid,:int]
address CMDbatMULcstsignal
comment "Return V * B, signal error on overflow";
pattern *(v:int,b:bat[:oid,:int],accum:int) :bat[:oid,:int]
address CMDbatMULcstsignal
comment "Return V * B, signal error on overflow, reuse B if ACCUM is set";
pattern mul_noerror(v:int,b:bat[:oid,:int]) :bat[:oid,:int]
address CMDbatMULcst
comment "Return V * B, overflow causes NIL value";

command *(b1:bat[:oid,:int],b2:bat[:oid,:wrd]) :bat[:oid,:wrd]
address CMDbatMULsignal
comment "Return B1 * B2, signal error on overflow";
command *(b1:bat[:oid,:int],b2:bat[:oid,:wrd],accum:int) :bat[:oid,:wrd]
address CMDbatMULsignalaccum
comment "Return B1 * B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command mul_noerror(b1:bat[:oid,:int],b2:bat[:oid,:wrd]) :bat[:oid,:wrd]
address CMDbatMUL
comment "Return B1 * B2, overflow causes NIL value";
pattern *(b:bat[:oid,:int],v:wrd) :bat[:oid,:wrd]
address CMDbatMULcstsignal
comment "Return B * V, signal error on overflow";
pattern mul_noerror(b:bat[:oid,:int],v:wrd) :bat[:oid,:wrd]
address CMDbatMULcst
comment "Return B * V, overflow causes NIL value";
pattern *(v:int,b:bat[:oid,:wrd]) :bat[:oid,:wrd]
address CMDbatMULcstsignal
comment "Return V * B, signal error on overflow";
pattern *(v:int,b:bat[:oid,:wrd],accum:int) :bat[:oid,:wrd]
address CMDbatMULcstsignal
comment "Return V * B, signal error on overflow, reuse B if ACCUM is set";
pattern mul_noerror(v:int,b:bat[:oid,:wrd]) :bat[:oid,:wrd]
address CMDbatMULcst
comment "Return V * B, overflow causes NIL value";

command *(b1:bat[:oid,:int],b2:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatMULsignal
comment "Return B1 * B2, signal error on overflow";
command *(b1:bat[:oid,:int],b2:bat[:oid,:lng],accum:int) :bat[:oid,:lng]
address CMDbatMULsignalaccum
comment "Return B1 * B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command mul_noerror(b1:bat[:oid,:int],b2:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatMUL
comment "Return B1 * B2, overflow causes NIL value";
pattern *(b:bat[:oid,:int],v:lng) :bat[:oid,:lng]
address CMDbatMULcstsignal
comment "Return B * V, signal error on overflow";
pattern mul_noerror(b:bat[:oid,:int],v:lng) :bat[:oid,:lng]
address CMDbatMULcst
comment "Return B * V, overflow causes NIL value";
pattern *(v:int,b:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatMULcstsignal
comment "Return V * B, signal error on overflow";
pattern *(v:int,b:bat[:oid,:lng],accum:int) :bat[:oid,:lng]
address CMDbatMULcstsignal
comment "Return V * B, signal error on overflow, reuse B if ACCUM is set";
pattern mul_noerror(v:int,b:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatMULcst
comment "Return V * B, overflow causes NIL value";

command *(b1:bat[:oid,:int],b2:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatMULsignal
comment "Return B1 * B2, signal error on overflow";
command *(b1:bat[:oid,:int],b2:bat[:oid,:flt],accum:int) :bat[:oid,:flt]
address CMDbatMULsignalaccum
comment "Return B1 * B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command mul_noerror(b1:bat[:oid,:int],b2:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatMUL
comment "Return B1 * B2, overflow causes NIL value";
pattern *(b:bat[:oid,:int],v:flt) :bat[:oid,:flt]
address CMDbatMULcstsignal
comment "Return B * V, signal error on overflow";
pattern mul_noerror(b:bat[:oid,:int],v:flt) :bat[:oid,:flt]
address CMDbatMULcst
comment "Return B * V, overflow causes NIL value";
pattern *(v:int,b:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatMULcstsignal
comment "Return V * B, signal error on overflow";
pattern *(v:int,b:bat[:oid,:flt],accum:int) :bat[:oid,:flt]
address CMDbatMULcstsignal
comment "Return V * B, signal error on overflow, reuse B if ACCUM is set";
pattern mul_noerror(v:int,b:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatMULcst
comment "Return V * B, overflow causes NIL value";

command *(b1:bat[:oid,:int],b2:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatMULsignal
comment "Return B1 * B2, signal error on overflow";
command *(b1:bat[:oid,:int],b2:bat[:oid,:dbl],accum:int) :bat[:oid,:dbl]
address CMDbatMULsignalaccum
comment "Return B1 * B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command mul_noerror(b1:bat[:oid,:int],b2:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatMUL
comment "Return B1 * B2, overflow causes NIL value";
pattern *(b:bat[:oid,:int],v:dbl) :bat[:oid,:dbl]
address CMDbatMULcstsignal
comment "Return B * V, signal error on overflow";
pattern mul_noerror(b:bat[:oid,:int],v:dbl) :bat[:oid,:dbl]
address CMDbatMULcst
comment "Return B * V, overflow causes NIL value";
pattern *(v:int,b:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatMULcstsignal
comment "Return V * B, signal error on overflow";
pattern *(v:int,b:bat[:oid,:dbl],accum:int) :bat[:oid,:dbl]
address CMDbatMULcstsignal
comment "Return V * B, signal error on overflow, reuse B if ACCUM is set";
pattern mul_noerror(v:int,b:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatMULcst
comment "Return V * B, overflow causes NIL value";

command *(b1:bat[:oid,:wrd],b2:bat[:oid,:bte]) :bat[:oid,:wrd]
address CMDbatMULsignal
comment "Return B1 * B2, signal error on overflow";
command *(b1:bat[:oid,:wrd],b2:bat[:oid,:bte],accum:int) :bat[:oid,:wrd]
address CMDbatMULsignalaccum
comment "Return B1 * B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command mul_noerror(b1:bat[:oid,:wrd],b2:bat[:oid,:bte]) :bat[:oid,:wrd]
address CMDbatMUL
comment "Return B1 * B2, overflow causes NIL value";
pattern *(b:bat[:oid,:wrd],v:bte) :bat[:oid,:wrd]
address CMDbatMULcstsignal
comment "Return B * V, signal error on overflow";
pattern *(b:bat[:oid,:wrd],v:bte,accum:int) :bat[:oid,:wrd]
address CMDbatMULcstsignal
comment "Return B * V, signal error on overflow, reuse B if ACCUM is set";
pattern mul_noerror(b:bat[:oid,:wrd],v:bte) :bat[:oid,:wrd]
address CMDbatMULcst
comment "Return B * V, overflow causes NIL value";
pattern *(v:wrd,b:bat[:oid,:bte]) :bat[:oid,:wrd]
address CMDbatMULcstsignal
comment "Return V * B, signal error on overflow";
pattern mul_noerror(v:wrd,b:bat[:oid,:bte]) :bat[:oid,:wrd]
address CMDbatMULcst
comment "Return V * B, overflow causes NIL value";

command *(b1:bat[:oid,:wrd],b2:bat[:oid,:sht]) :bat[:oid,:wrd]
address CMDbatMULsignal
comment "Return B1 * B2, signal error on overflow";
command *(b1:bat[:oid,:wrd],b2:bat[:oid,:sht],accum:int) :bat[:oid,:wrd]
address CMDbatMULsignalaccum
comment "Return B1 * B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command mul_noerror(b1:bat[:oid,:wrd],b2:bat[:oid,:sht]) :bat[:oid,:wrd]
address CMDbatMUL
comment "Return B1 * B2, overflow causes NIL value";
pattern *(b:bat[:oid,:wrd],v:sht) :bat[:oid,:wrd]
address CMDbatMULcstsignal
comment "Return B * V, signal error on overflow";
pattern *(b:bat[:oid,:wrd],v:sht,accum:int) :bat[:oid,:wrd]
address CMDbatMULcstsignal
comment "Return B * V, signal error on overflow, reuse B if ACCUM is set";
pattern mul_noerror(b:bat[:oid,:wrd],v:sht) :bat[:oid,:wrd]
address CMDbatMULcst
comment "Return B * V, overflow causes NIL value";
pattern *(v:wrd,b:bat[:oid,:sht]) :bat[:oid,:wrd]
address CMDbatMULcstsignal
comment "Return V * B, signal error on overflow";
pattern mul_noerror(v:wrd,b:bat[:oid,:sht]) :bat[:oid,:wrd]
address CMDbatMULcst
comment "Return V * B, overflow causes NIL value";

command *(b1:bat[:oid,:wrd],b2:bat[:oid,:int]) :bat[:oid,:wrd]
address CMDbatMULsignal
comment "Return B1 * B2, signal error on overflow";
command *(b1:bat[:oid,:wrd],b2:bat[:oid,:int],accum:int) :bat[:oid,:wrd]
address CMDbatMULsignalaccum
comment "Return B1 * B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command mul_noerror(b1:bat[:oid,:wrd],b2:bat[:oid,:int]) :bat[:oid,:wrd]
address CMDbatMUL
comment "Return B1 * B2, overflow causes NIL value";
pattern *(b:bat[:oid,:wrd],v:int) :bat[:oid,:wrd]
address CMDbatMULcstsignal
comment "Return B * V, signal error on overflow";
pattern *(b:bat[:oid,:wrd],v:int,accum:int) :bat[:oid,:wrd]
address CMDbatMULcstsignal
comment "Return B * V, signal error on overflow, reuse B if ACCUM is set";
pattern mul_noerror(b:bat[:oid,:wrd],v:int) :bat[:oid,:wrd]
address CMDbatMULcst
comment "Return B * V, overflow causes NIL value";
pattern *(v:wrd,b:bat[:oid,:int]) :bat[:oid,:wrd]
address CMDbatMULcstsignal
comment "Return V * B, signal error on overflow";
pattern mul_noerror(v:wrd,b:bat[:oid,:int]) :bat[:oid,:wrd]
address CMDbatMULcst
comment "Return V * B, overflow causes NIL value";

command *(b1:bat[:oid,:wrd],b2:bat[:oid,:wrd]) :bat[:oid,:wrd]
address CMDbatMULsignal
comment "Return B1 * B2, signal error on overflow";
command *(b1:bat[:oid,:wrd],b2:bat[:oid,:wrd],accum:int) :bat[:oid,:wrd]
address CMDbatMULsignalaccum
comment "Return B1 * B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command mul_noerror(b1:bat[:oid,:wrd],b2:bat[:oid,:wrd]) :bat[:oid,:wrd]
address CMDbatMUL
comment "Return B1 * B2, overflow causes NIL value";
pattern *(b:bat[:oid,:wrd],v:wrd) :bat[:oid,:wrd]
address CMDbatMULcstsignal
comment "Return B * V, signal error on overflow";
pattern *(b:bat[:oid,:wrd],v:wrd,accum:int) :bat[:oid,:wrd]
address CMDbatMULcstsignal
comment "Return B * V, signal error on overflow, reuse B if ACCUM is set";
pattern mul_noerror(b:bat[:oid,:wrd],v:wrd) :bat[:oid,:wrd]
address CMDbatMULcst
comment "Return B * V, overflow causes NIL value";
pattern *(v:wrd,b:bat[:oid,:wrd]) :bat[:oid,:wrd]
address CMDbatMULcstsignal
comment "Return V * B, signal error on overflow";
pattern *(v:wrd,b:bat[:oid,:wrd],accum:int) :bat[:oid,:wrd]
address CMDbatMULcstsignal
comment "Return V * B, signal error on overflow, reuse B if ACCUM is set";
pattern mul_noerror(v:wrd,b:bat[:oid,:wrd]) :bat[:oid,:wrd]
address CMDbatMULcst
comment "Return V * B, overflow causes NIL value";

command *(b1:bat[:oid,:wrd],b2:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatMULsignal
comment "Return B1 * B2, signal error on overflow";
command *(b1:bat[:oid,:wrd],b2:bat[:oid,:lng],accum:int) :bat[:oid,:lng]
address CMDbatMULsignalaccum
comment "Return B1 * B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command mul_noerror(b1:bat[:oid,:wrd],b2:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatMUL
comment "Return B1 * B2, overflow causes NIL value";
pattern *(b:bat[:oid,:wrd],v:lng) :bat[:oid,:lng]
address CMDbatMULcstsignal
comment "Return B * V, signal error on overflow";
pattern mul_noerror(b:bat[:oid,:wrd],v:lng) :bat[:oid,:lng]
address CMDbatMULcst
comment "Return B * V, overflow causes NIL value";
pattern *(v:wrd,b:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatMULcstsignal
comment "Return V * B, signal error on overflow";
pattern *(v:wrd,b:bat[:oid,:lng],accum:int) :bat[:oid,:lng]
address CMDbatMULcstsignal
comment "Return V * B, signal error on overflow, reuse B if ACCUM is set";
pattern mul_noerror(v:wrd,b:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatMULcst
comment "Return V * B, overflow causes NIL value";

command *(b1:bat[:oid,:wrd],b2:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatMULsignal
comment "Return B1 * B2, signal error on overflow";
command *(b1:bat[:oid,:wrd],b2:bat[:oid,:flt],accum:int) :bat[:oid,:flt]
address CMDbatMULsignalaccum
comment "Return B1 * B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command mul_noerror(b1:bat[:oid,:wrd],b2:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatMUL
comment "Return B1 * B2, overflow causes NIL value";
pattern *(b:bat[:oid,:wrd],v:flt) :bat[:oid,:flt]
address CMDbatMULcstsignal
comment "Return B * V, signal error on overflow";
pattern mul_noerror(b:bat[:oid,:wrd],v:flt) :bat[:oid,:flt]
address CMDbatMULcst
comment "Return B * V, overflow causes NIL value";
pattern *(v:wrd,b:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatMULcstsignal
comment "Return V * B, signal error on overflow";
pattern *(v:wrd,b:bat[:oid,:flt],accum:int) :bat[:oid,:flt]
address CMDbatMULcstsignal
comment "Return V * B, signal error on overflow, reuse B if ACCUM is set";
pattern mul_noerror(v:wrd,b:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatMULcst
comment "Return V * B, overflow causes NIL value";

command *(b1:bat[:oid,:wrd],b2:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatMULsignal
comment "Return B1 * B2, signal error on overflow";
command *(b1:bat[:oid,:wrd],b2:bat[:oid,:dbl],accum:int) :bat[:oid,:dbl]
address CMDbatMULsignalaccum
comment "Return B1 * B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command mul_noerror(b1:bat[:oid,:wrd],b2:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatMUL
comment "Return B1 * B2, overflow causes NIL value";
pattern *(b:bat[:oid,:wrd],v:dbl) :bat[:oid,:dbl]
address CMDbatMULcstsignal
comment "Return B * V, signal error on overflow";
pattern mul_noerror(b:bat[:oid,:wrd],v:dbl) :bat[:oid,:dbl]
address CMDbatMULcst
comment "Return B * V, overflow causes NIL value";
pattern *(v:wrd,b:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatMULcstsignal
comment "Return V * B, signal error on overflow";
pattern *(v:wrd,b:bat[:oid,:dbl],accum:int) :bat[:oid,:dbl]
address CMDbatMULcstsignal
comment "Return V * B, signal error on overflow, reuse B if ACCUM is set";
pattern mul_noerror(v:wrd,b:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatMULcst
comment "Return V * B, overflow causes NIL value";

command *(b1:bat[:oid,:lng],b2:bat[:oid,:bte]) :bat[:oid,:lng]
address CMDbatMULsignal
comment "Return B1 * B2, signal error on overflow";
command *(b1:bat[:oid,:lng],b2:bat[:oid,:bte],accum:int) :bat[:oid,:lng]
address CMDbatMULsignalaccum
comment "Return B1 * B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command mul_noerror(b1:bat[:oid,:lng],b2:bat[:oid,:bte]) :bat[:oid,:lng]
address CMDbatMUL
comment "Return B1 * B2, overflow causes NIL value";
pattern *(b:bat[:oid,:lng],v:bte) :bat[:oid,:lng]
address CMDbatMULcstsignal
comment "Return B * V, signal error on overflow";
pattern *(b:bat[:oid,:lng],v:bte,accum:int) :bat[:oid,:lng]
address CMDbatMULcstsignal
comment "Return B * V, signal error on overflow, reuse B if ACCUM is set";
pattern mul_noerror(b:bat[:oid,:lng],v:bte) :bat[:oid,:lng]
address CMDbatMULcst
comment "Return B * V, overflow causes NIL value";
pattern *(v:lng,b:bat[:oid,:bte]) :bat[:oid,:lng]
address CMDbatMULcstsignal
comment "Return V * B, signal error on overflow";
pattern mul_noerror(v:lng,b:bat[:oid,:bte]) :bat[:oid,:lng]
address CMDbatMULcst
comment "Return V * B, overflow causes NIL value";

command *(b1:bat[:oid,:lng],b2:bat[:oid,:sht]) :bat[:oid,:lng]
address CMDbatMULsignal
comment "Return B1 * B2, signal error on overflow";
command *(b1:bat[:oid,:lng],b2:bat[:oid,:sht],accum:int) :bat[:oid,:lng]
address CMDbatMULsignalaccum
comment "Return B1 * B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command mul_noerror(b1:bat[:oid,:lng],b2:bat[:oid,:sht]) :bat[:oid,:lng]
address CMDbatMUL
comment "Return B1 * B2, overflow causes NIL value";
pattern *(b:bat[:oid,:lng],v:sht) :bat[:oid,:lng]
address CMDbatMULcstsignal
comment "Return B * V, signal error on overflow";
pattern *(b:bat[:oid,:lng],v:sht,accum:int) :bat[:oid,:lng]
address CMDbatMULcstsignal
comment "Return B * V, signal error on overflow, reuse B if ACCUM is set";
pattern mul_noerror(b:bat[:oid,:lng],v:sht) :bat[:oid,:lng]
address CMDbatMULcst
comment "Return B * V, overflow causes NIL value";
pattern *(v:lng,b:bat[:oid,:sht]) :bat[:oid,:lng]
address CMDbatMULcstsignal
comment "Return V * B, signal error on overflow";
pattern mul_noerror(v:lng,b:bat[:oid,:sht]) :bat[:oid,:lng]
address CMDbatMULcst
comment "Return V * B, overflow causes NIL value";

command *(b1:bat[:oid,:lng],b2:bat[:oid,:int]) :bat[:oid,:lng]
address CMDbatMULsignal
comment "Return B1 * B2, signal error on overflow";
command *(b1:bat[:oid,:lng],b2:bat[:oid,:int],accum:int) :bat[:oid,:lng]
address CMDbatMULsignalaccum
comment "Return B1 * B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command mul_noerror(b1:bat[:oid,:lng],b2:bat[:oid,:int]) :bat[:oid,:lng]
address CMDbatMUL
comment "Return B1 * B2, overflow causes NIL value";
pattern *(b:bat[:oid,:lng],v:int) :bat[:oid,:lng]
address CMDbatMULcstsignal
comment "Return B * V, signal error on overflow";
pattern *(b:bat[:oid,:lng],v:int,accum:int) :bat[:oid,:lng]
address CMDbatMULcstsignal
comment "Return B * V, signal error on overflow, reuse B if ACCUM is set";
pattern mul_noerror(b:bat[:oid,:lng],v:int) :bat[:oid,:lng]
address CMDbatMULcst
comment "Return B * V, overflow causes NIL value";
pattern *(v:lng,b:bat[:oid,:int]) :bat[:oid,:lng]
address CMDbatMULcstsignal
comment "Return V * B, signal error on overflow";
pattern mul_noerror(v:lng,b:bat[:oid,:int]) :bat[:oid,:lng]
address CMDbatMULcst
comment "Return V * B, overflow causes NIL value";

command *(b1:bat[:oid,:lng],b2:bat[:oid,:wrd]) :bat[:oid,:lng]
address CMDbatMULsignal
comment "Return B1 * B2, signal error on overflow";
command *(b1:bat[:oid,:lng],b2:bat[:oid,:wrd],accum:int) :bat[:oid,:lng]
address CMDbatMULsignalaccum
comment "Return B1 * B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command mul_noerror(b1:bat[:oid,:lng],b2:bat[:oid,:wrd]) :bat[:oid,:lng]
address CMDbatMUL
comment "Return B1 * B2, overflow causes NIL value";
pattern *(b:bat[:oid,:lng],v:wrd) :bat[:oid,:lng]
address CMDbatMULcstsignal
comment "Return B * V, signal error on overflow";
pattern *(b:bat[:oid,:lng],v:wrd,accum:int) :bat[:oid,:lng]
address CMDbatMULcstsignal
comment "Return B * V, signal error on overflow, reuse B if ACCUM is set";
pattern mul_noerror(b:bat[:oid,:lng],v:wrd) :bat[:oid,:lng]
address CMDbatMULcst
comment "Return B * V, overflow causes NIL value";
pattern *(v:lng,b:bat[:oid,:wrd]) :bat[:oid,:lng]
address CMDbatMULcstsignal
comment "Return V * B, signal error on overflow";
pattern mul_noerror(v:lng,b:bat[:oid,:wrd]) :bat[:oid,:lng]
address CMDbatMULcst
comment "Return V * B, overflow causes NIL value";

command *(b1:bat[:oid,:lng],b2:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatMULsignal
comment "Return B1 * B2, signal error on overflow";
command *(b1:bat[:oid,:lng],b2:bat[:oid,:lng],accum:int) :bat[:oid,:lng]
address CMDbatMULsignalaccum
comment "Return B1 * B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command mul_noerror(b1:bat[:oid,:lng],b2:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatMUL
comment "Return B1 * B2, overflow causes NIL value";
pattern *(b:bat[:oid,:lng],v:lng) :bat[:oid,:lng]
address CMDbatMULcstsignal
comment "Return B * V, signal error on overflow";
pattern *(b:bat[:oid,:lng],v:lng,accum:int) :bat[:oid,:lng]
address CMDbatMULcstsignal
comment "Return B * V, signal error on overflow, reuse B if ACCUM is set";
pattern mul_noerror(b:bat[:oid,:lng],v:lng) :bat[:oid,:lng]
address CMDbatMULcst
comment "Return B * V, overflow causes NIL value";
pattern *(v:lng,b:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatMULcstsignal
comment "Return V * B, signal error on overflow";
pattern *(v:lng,b:bat[:oid,:lng],accum:int) :bat[:oid,:lng]
address CMDbatMULcstsignal
comment "Return V * B, signal error on overflow, reuse B if ACCUM is set";
pattern mul_noerror(v:lng,b:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatMULcst
comment "Return V * B, overflow causes NIL value";

command *(b1:bat[:oid,:lng],b2:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatMULsignal
comment "Return B1 * B2, signal error on overflow";
command *(b1:bat[:oid,:lng],b2:bat[:oid,:flt],accum:int) :bat[:oid,:flt]
address CMDbatMULsignalaccum
comment "Return B1 * B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command mul_noerror(b1:bat[:oid,:lng],b2:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatMUL
comment "Return B1 * B2, overflow causes NIL value";
pattern *(b:bat[:oid,:lng],v:flt) :bat[:oid,:flt]
address CMDbatMULcstsignal
comment "Return B * V, signal error on overflow";
pattern mul_noerror(b:bat[:oid,:lng],v:flt) :bat[:oid,:flt]
address CMDbatMULcst
comment "Return B * V, overflow causes NIL value";
pattern *(v:lng,b:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatMULcstsignal
comment "Return V * B, signal error on overflow";
pattern *(v:lng,b:bat[:oid,:flt],accum:int) :bat[:oid,:flt]
address CMDbatMULcstsignal
comment "Return V * B, signal error on overflow, reuse B if ACCUM is set";
pattern mul_noerror(v:lng,b:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatMULcst
comment "Return V * B, overflow causes NIL value";

command *(b1:bat[:oid,:lng],b2:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatMULsignal
comment "Return B1 * B2, signal error on overflow";
command *(b1:bat[:oid,:lng],b2:bat[:oid,:dbl],accum:int) :bat[:oid,:dbl]
address CMDbatMULsignalaccum
comment "Return B1 * B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command mul_noerror(b1:bat[:oid,:lng],b2:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatMUL
comment "Return B1 * B2, overflow causes NIL value";
pattern *(b:bat[:oid,:lng],v:dbl) :bat[:oid,:dbl]
address CMDbatMULcstsignal
comment "Return B * V, signal error on overflow";
pattern mul_noerror(b:bat[:oid,:lng],v:dbl) :bat[:oid,:dbl]
address CMDbatMULcst
comment "Return B * V, overflow causes NIL value";
pattern *(v:lng,b:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatMULcstsignal
comment "Return V * B, signal error on overflow";
pattern *(v:lng,b:bat[:oid,:dbl],accum:int) :bat[:oid,:dbl]
address CMDbatMULcstsignal
comment "Return V * B, signal error on overflow, reuse B if ACCUM is set";
pattern mul_noerror(v:lng,b:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatMULcst
comment "Return V * B, overflow causes NIL value";

command *(b1:bat[:oid,:flt],b2:bat[:oid,:bte]) :bat[:oid,:flt]
address CMDbatMULsignal
comment "Return B1 * B2, signal error on overflow";
command *(b1:bat[:oid,:flt],b2:bat[:oid,:bte],accum:int) :bat[:oid,:flt]
address CMDbatMULsignalaccum
comment "Return B1 * B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command mul_noerror(b1:bat[:oid,:flt],b2:bat[:oid,:bte]) :bat[:oid,:flt]
address CMDbatMUL
comment "Return B1 * B2, overflow causes NIL value";
pattern *(b:bat[:oid,:flt],v:bte) :bat[:oid,:flt]
address CMDbatMULcstsignal
comment "Return B * V, signal error on overflow";
pattern *(b:bat[:oid,:flt],v:bte,accum:int) :bat[:oid,:flt]
address CMDbatMULcstsignal
comment "Return B * V, signal error on overflow, reuse B if ACCUM is set";
pattern mul_noerror(b:bat[:oid,:flt],v:bte) :bat[:oid,:flt]
address CMDbatMULcst
comment "Return B * V, overflow causes NIL value";
pattern *(v:flt,b:bat[:oid,:bte]) :bat[:oid,:flt]
address CMDbatMULcstsignal
comment "Return V * B, signal error on overflow";
pattern mul_noerror(v:flt,b:bat[:oid,:bte]) :bat[:oid,:flt]
address CMDbatMULcst
comment "Return V * B, overflow causes NIL value";

command *(b1:bat[:oid,:flt],b2:bat[:oid,:sht]) :bat[:oid,:flt]
address CMDbatMULsignal
comment "Return B1 * B2, signal error on overflow";
command *(b1:bat[:oid,:flt],b2:bat[:oid,:sht],accum:int) :bat[:oid,:flt]
address CMDbatMULsignalaccum
comment "Return B1 * B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command mul_noerror(b1:bat[:oid,:flt],b2:bat[:oid,:sht]) :bat[:oid,:flt]
address CMDbatMUL
comment "Return B1 * B2, overflow causes NIL value";
pattern *(b:bat[:oid,:flt],v:sht) :bat[:oid,:flt]
address CMDbatMULcstsignal
comment "Return B * V, signal error on overflow";
pattern *(b:bat[:oid,:flt],v:sht,accum:int) :bat[:oid,:flt]
address CMDbatMULcstsignal
comment "Return B * V, signal error on overflow, reuse B if ACCUM is set";
pattern mul_noerror(b:bat[:oid,:flt],v:sht) :bat[:oid,:flt]
address CMDbatMULcst
comment "Return B * V, overflow causes NIL value";
pattern *(v:flt,b:bat[:oid,:sht]) :bat[:oid,:flt]
address CMDbatMULcstsignal
comment "Return V * B, signal error on overflow";
pattern mul_noerror(v:flt,b:bat[:oid,:sht]) :bat[:oid,:flt]
address CMDbatMULcst
comment "Return V * B, overflow causes NIL value";

command *(b1:bat[:oid,:flt],b2:bat[:oid,:int]) :bat[:oid,:flt]
address CMDbatMULsignal
comment "Return B1 * B2, signal error on overflow";
command *(b1:bat[:oid,:flt],b2:bat[:oid,:int],accum:int) :bat[:oid,:flt]
address CMDbatMULsignalaccum
comment "Return B1 * B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command mul_noerror(b1:bat[:oid,:flt],b2:bat[:oid,:int]) :bat[:oid,:flt]
address CMDbatMUL
comment "Return B1 * B2, overflow causes NIL value";
pattern *(b:bat[:oid,:flt],v:int) :bat[:oid,:flt]
address CMDbatMULcstsignal
comment "Return B * V, signal error on overflow";
pattern *(b:bat[:oid,:flt],v:int,accum:int) :bat[:oid,:flt]
address CMDbatMULcstsignal
comment "Return B * V, signal error on overflow, reuse B if ACCUM is set";
pattern mul_noerror(b:bat[:oid,:flt],v:int) :bat[:oid,:flt]
address CMDbatMULcst
comment "Return B * V, overflow causes NIL value";
pattern *(v:flt,b:bat[:oid,:int]) :bat[:oid,:flt]
address CMDbatMULcstsignal
comment "Return V * B, signal error on overflow";
pattern mul_noerror(v:flt,b:bat[:oid,:int]) :bat[:oid,:flt]
address CMDbatMULcst
comment "Return V * B, overflow causes NIL value";

command *(b1:bat[:oid,:flt],b2:bat[:oid,:wrd]) :bat[:oid,:flt]
address CMDbatMULsignal
comment "Return B1 * B2, signal error on overflow";
command *(b1:bat[:oid,:flt],b2:bat[:oid,:wrd],accum:int) :bat[:oid,:flt]
address CMDbatMULsignalaccum
comment "Return B1 * B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command mul_noerror(b1:bat[:oid,:flt],b2:bat[:oid,:wrd]) :bat[:oid,:flt]
address CMDbatMUL
comment "Return B1 * B2, overflow causes NIL value";
pattern *(b:bat[:oid,:flt],v:wrd) :bat[:oid,:flt]
address CMDbatMULcstsignal
comment "Return B * V, signal error on overflow";
pattern *(b:bat[:oid,:flt],v:wrd,accum:int) :bat[:oid,:flt]
address CMDbatMULcstsignal
comment "Return B * V, signal error on overflow, reuse B if ACCUM is set";
pattern mul_noerror(b:bat[:oid,:flt],v:wrd) :bat[:oid,:flt]
address CMDbatMULcst
comment "Return B * V, overflow causes NIL value";
pattern *(v:flt,b:bat[:oid,:wrd]) :bat[:oid,:flt]
address CMDbatMULcstsignal
comment "Return V * B, signal error on overflow";
pattern mul_noerror(v:flt,b:bat[:oid,:wrd]) :bat[:oid,:flt]
address CMDbatMULcst
comment "Return V * B, overflow causes NIL value";

command *(b1:bat[:oid,:flt],b2:bat[:oid,:lng]) :bat[:oid,:flt]
address CMDbatMULsignal
comment "Return B1 * B2, signal error on overflow";
command *(b1:bat[:oid,:flt],b2:bat[:oid,:lng],accum:int) :bat[:oid,:flt]
address CMDbatMULsignalaccum
comment "Return B1 * B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command mul_noerror(b1:bat[:oid,:flt],b2:bat[:oid,:lng]) :bat[:oid,:flt]
address CMDbatMUL
comment "Return B1 * B2, overflow causes NIL value";
pattern *(b:bat[:oid,:flt],v:lng) :bat[:oid,:flt]
address CMDbatMULcstsignal
comment "Return B * V, signal error on overflow";
pattern *(b:bat[:oid,:flt],v:lng,accum:int) :bat[:oid,:flt]
address CMDbatMULcstsignal
comment "Return B * V, signal error on overflow, reuse B if ACCUM is set";
pattern mul_noerror(b:bat[:oid,:flt],v:lng) :bat[:oid,:flt]
address CMDbatMULcst
comment "Return B * V, overflow causes NIL value";
pattern *(v:flt,b:bat[:oid,:lng]) :bat[:oid,:flt]
address CMDbatMULcstsignal
comment "Return V * B, signal error on overflow";
pattern mul_noerror(v:flt,b:bat[:oid,:lng]) :bat[:oid,:flt]
address CMDbatMULcst
comment "Return V * B, overflow causes NIL value";

command *(b1:bat[:oid,:flt],b2:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatMULsignal
comment "Return B1 * B2, signal error on overflow";
command *(b1:bat[:oid,:flt],b2:bat[:oid,:flt],accum:int) :bat[:oid,:flt]
address CMDbatMULsignalaccum
comment "Return B1 * B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command mul_noerror(b1:bat[:oid,:flt],b2:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatMUL
comment "Return B1 * B2, overflow causes NIL value";
pattern *(b:bat[:oid,:flt],v:flt) :bat[:oid,:flt]
address CMDbatMULcstsignal
comment "Return B * V, signal error on overflow";
pattern *(b:bat[:oid,:flt],v:flt,accum:int) :bat[:oid,:flt]
address CMDbatMULcstsignal
comment "Return B * V, signal error on overflow, reuse B if ACCUM is set";
pattern mul_noerror(b:bat[:oid,:flt],v:flt) :bat[:oid,:flt]
address CMDbatMULcst
comment "Return B * V, overflow causes NIL value";
pattern *(v:flt,b:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatMULcstsignal
comment "Return V * B, signal error on overflow";
pattern *(v:flt,b:bat[:oid,:flt],accum:int) :bat[:oid,:flt]
address CMDbatMULcstsignal
comment "Return V * B, signal error on overflow, reuse B if ACCUM is set";
pattern mul_noerror(v:flt,b:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatMULcst
comment "Return V * B, overflow causes NIL value";

command *(b1:bat[:oid,:flt],b2:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatMULsignal
comment "Return B1 * B2, signal error on overflow";
command *(b1:bat[:oid,:flt],b2:bat[:oid,:dbl],accum:int) :bat[:oid,:dbl]
address CMDbatMULsignalaccum
comment "Return B1 * B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command mul_noerror(b1:bat[:oid,:flt],b2:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatMUL
comment "Return B1 * B2, overflow causes NIL value";
pattern *(b:bat[:oid,:flt],v:dbl) :bat[:oid,:dbl]
address CMDbatMULcstsignal
comment "Return B * V, signal error on overflow";
pattern mul_noerror(b:bat[:oid,:flt],v:dbl) :bat[:oid,:dbl]
address CMDbatMULcst
comment "Return B * V, overflow causes NIL value";
pattern *(v:flt,b:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatMULcstsignal
comment "Return V * B, signal error on overflow";
pattern *(v:flt,b:bat[:oid,:dbl],accum:int) :bat[:oid,:dbl]
address CMDbatMULcstsignal
comment "Return V * B, signal error on overflow, reuse B if ACCUM is set";
pattern mul_noerror(v:flt,b:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatMULcst
comment "Return V * B, overflow causes NIL value";

command *(b1:bat[:oid,:dbl],b2:bat[:oid,:bte]) :bat[:oid,:dbl]
address CMDbatMULsignal
comment "Return B1 * B2, signal error on overflow";
command *(b1:bat[:oid,:dbl],b2:bat[:oid,:bte],accum:int) :bat[:oid,:dbl]
address CMDbatMULsignalaccum
comment "Return B1 * B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command mul_noerror(b1:bat[:oid,:dbl],b2:bat[:oid,:bte]) :bat[:oid,:dbl]
address CMDbatMUL
comment "Return B1 * B2, overflow causes NIL value";
pattern *(b:bat[:oid,:dbl],v:bte) :bat[:oid,:dbl]
address CMDbatMULcstsignal
comment "Return B * V, signal error on overflow";
pattern *(b:bat[:oid,:dbl],v:bte,accum:int) :bat[:oid,:dbl]
address CMDbatMULcstsignal
comment "Return B * V, signal error on overflow, reuse B if ACCUM is set";
pattern mul_noerror(b:bat[:oid,:dbl],v:bte) :bat[:oid,:dbl]
address CMDbatMULcst
comment "Return B * V, overflow causes NIL value";
pattern *(v:dbl,b:bat[:oid,:bte]) :bat[:oid,:dbl]
address CMDbatMULcstsignal
comment "Return V * B, signal error on overflow";
pattern mul_noerror(v:dbl,b:bat[:oid,:bte]) :bat[:oid,:dbl]
address CMDbatMULcst
comment "Return V * B, overflow causes NIL value";

command *(b1:bat[:oid,:dbl],b2:bat[:oid,:sht]) :bat[:oid,:dbl]
address CMDbatMULsignal
comment "Return B1 * B2, signal error on overflow";
command *(b1:bat[:oid,:dbl],b2:bat[:oid,:sht],accum:int) :bat[:oid,:dbl]
address CMDbatMULsignalaccum
comment "Return B1 * B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command mul_noerror(b1:bat[:oid,:dbl],b2:bat[:oid,:sht]) :bat[:oid,:dbl]
address CMDbatMUL
comment "Return B1 * B2, overflow causes NIL value";
pattern *(b:bat[:oid,:dbl],v:sht) :bat[:oid,:dbl]
address CMDbatMULcstsignal
comment "Return B * V, signal error on overflow";
pattern *(b:bat[:oid,:dbl],v:sht,accum:int) :bat[:oid,:dbl]
address CMDbatMULcstsignal
comment "Return B * V, signal error on overflow, reuse B if ACCUM is set";
pattern mul_noerror(b:bat[:oid,:dbl],v:sht) :bat[:oid,:dbl]
address CMDbatMULcst
comment "Return B * V, overflow causes NIL value";
pattern *(v:dbl,b:bat[:oid,:sht]) :bat[:oid,:dbl]
address CMDbatMULcstsignal
comment "Return V * B, signal error on overflow";
pattern mul_noerror(v:dbl,b:bat[:oid,:sht]) :bat[:oid,:dbl]
address CMDbatMULcst
comment "Return V * B, overflow causes NIL value";

command *(b1:bat[:oid,:dbl],b2:bat[:oid,:int]) :bat[:oid,:dbl]
address CMDbatMULsignal
comment "Return B1 * B2, signal error on overflow";
command *(b1:bat[:oid,:dbl],b2:bat[:oid,:int],accum:int) :bat[:oid,:dbl]
address CMDbatMULsignalaccum
comment "Return B1 * B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command mul_noerror(b1:bat[:oid,:dbl],b2:bat[:oid,:int]) :bat[:oid,:dbl]
address CMDbatMUL
comment "Return B1 * B2, overflow causes NIL value";
pattern *(b:bat[:oid,:dbl],v:int) :bat[:oid,:dbl]
address CMDbatMULcstsignal
comment "Return B * V, signal error on overflow";
pattern *(b:bat[:oid,:dbl],v:int,accum:int) :bat[:oid,:dbl]
address CMDbatMULcstsignal
comment "Return B * V, signal error on overflow, reuse B if ACCUM is set";
pattern mul_noerror(b:bat[:oid,:dbl],v:int) :bat[:oid,:dbl]
address CMDbatMULcst
comment "Return B * V, overflow causes NIL value";
pattern *(v:dbl,b:bat[:oid,:int]) :bat[:oid,:dbl]
address CMDbatMULcstsignal
comment "Return V * B, signal error on overflow";
pattern mul_noerror(v:dbl,b:bat[:oid,:int]) :bat[:oid,:dbl]
address CMDbatMULcst
comment "Return V * B, overflow causes NIL value";

command *(b1:bat[:oid,:dbl],b2:bat[:oid,:wrd]) :bat[:oid,:dbl]
address CMDbatMULsignal
comment "Return B1 * B2, signal error on overflow";
command *(b1:bat[:oid,:dbl],b2:bat[:oid,:wrd],accum:int) :bat[:oid,:dbl]
address CMDbatMULsignalaccum
comment "Return B1 * B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command mul_noerror(b1:bat[:oid,:dbl],b2:bat[:oid,:wrd]) :bat[:oid,:dbl]
address CMDbatMUL
comment "Return B1 * B2, overflow causes NIL value";
pattern *(b:bat[:oid,:dbl],v:wrd) :bat[:oid,:dbl]
address CMDbatMULcstsignal
comment "Return B * V, signal error on overflow";
pattern *(b:bat[:oid,:dbl],v:wrd,accum:int) :bat[:oid,:dbl]
address CMDbatMULcstsignal
comment "Return B * V, signal error on overflow, reuse B if ACCUM is set";
pattern mul_noerror(b:bat[:oid,:dbl],v:wrd) :bat[:oid,:dbl]
address CMDbatMULcst
comment "Return B * V, overflow causes NIL value";
pattern *(v:dbl,b:bat[:oid,:wrd]) :bat[:oid,:dbl]
address CMDbatMULcstsignal
comment "Return V * B, signal error on overflow";
pattern mul_noerror(v:dbl,b:bat[:oid,:wrd]) :bat[:oid,:dbl]
address CMDbatMULcst
comment "Return V * B, overflow causes NIL value";

command *(b1:bat[:oid,:dbl],b2:bat[:oid,:lng]) :bat[:oid,:dbl]
address CMDbatMULsignal
comment "Return B1 * B2, signal error on overflow";
command *(b1:bat[:oid,:dbl],b2:bat[:oid,:lng],accum:int) :bat[:oid,:dbl]
address CMDbatMULsignalaccum
comment "Return B1 * B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command mul_noerror(b1:bat[:oid,:dbl],b2:bat[:oid,:lng]) :bat[:oid,:dbl]
address CMDbatMUL
comment "Return B1 * B2, overflow causes NIL value";
pattern *(b:bat[:oid,:dbl],v:lng) :bat[:oid,:dbl]
address CMDbatMULcstsignal
comment "Return B * V, signal error on overflow";
pattern *(b:bat[:oid,:dbl],v:lng,accum:int) :bat[:oid,:dbl]
address CMDbatMULcstsignal
comment "Return B * V, signal error on overflow, reuse B if ACCUM is set";
pattern mul_noerror(b:bat[:oid,:dbl],v:lng) :bat[:oid,:dbl]
address CMDbatMULcst
comment "Return B * V, overflow causes NIL value";
pattern *(v:dbl,b:bat[:oid,:lng]) :bat[:oid,:dbl]
address CMDbatMULcstsignal
comment "Return V * B, signal error on overflow";
pattern mul_noerror(v:dbl,b:bat[:oid,:lng]) :bat[:oid,:dbl]
address CMDbatMULcst
comment "Return V * B, overflow causes NIL value";

command *(b1:bat[:oid,:dbl],b2:bat[:oid,:flt]) :bat[:oid,:dbl]
address CMDbatMULsignal
comment "Return B1 * B2, signal error on overflow";
command *(b1:bat[:oid,:dbl],b2:bat[:oid,:flt],accum:int) :bat[:oid,:dbl]
address CMDbatMULsignalaccum
comment "Return B1 * B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command mul_noerror(b1:bat[:oid,:dbl],b2:bat[:oid,:flt]) :bat[:oid,:dbl]
address CMDbatMUL
comment "Return B1 * B2, overflow causes NIL value";
pattern *(b:bat[:oid,:dbl],v:flt) :bat[:oid,:dbl]
address CMDbatMULcstsignal
comment "Return B * V, signal error on overflow";
pattern *(b:bat[:oid,:dbl],v:flt,accum:int) :bat[:oid,:dbl]
address CMDbatMULcstsignal
comment "Return B * V, signal error on overflow, reuse B if ACCUM is set";
pattern mul_noerror(b:bat[:oid,:dbl],v:flt) :bat[:oid,:dbl]
address CMDbatMULcst
comment "Return B * V, overflow causes NIL value";
pattern *(v:dbl,b:bat[:oid,:flt]) :bat[:oid,:dbl]
address CMDbatMULcstsignal
comment "Return V * B, signal error on overflow";
pattern mul_noerror(v:dbl,b:bat[:oid,:flt]) :bat[:oid,:dbl]
address CMDbatMULcst
comment "Return V * B, overflow causes NIL value";

command *(b1:bat[:oid,:dbl],b2:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatMULsignal
comment "Return B1 * B2, signal error on overflow";
command *(b1:bat[:oid,:dbl],b2:bat[:oid,:dbl],accum:int) :bat[:oid,:dbl]
address CMDbatMULsignalaccum
comment "Return B1 * B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command mul_noerror(b1:bat[:oid,:dbl],b2:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatMUL
comment "Return B1 * B2, overflow causes NIL value";
pattern *(b:bat[:oid,:dbl],v:dbl) :bat[:oid,:dbl]
address CMDbatMULcstsignal
comment "Return B * V, signal error on overflow";
pattern *(b:bat[:oid,:dbl],v:dbl,accum:int) :bat[:oid,:dbl]
address CMDbatMULcstsignal
comment "Return B * V, signal error on overflow, reuse B if ACCUM is set";
pattern mul_noerror(b:bat[:oid,:dbl],v:dbl) :bat[:oid,:dbl]
address CMDbatMULcst
comment "Return B * V, overflow causes NIL value";
pattern *(v:dbl,b:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatMULcstsignal
comment "Return V * B, signal error on overflow";
pattern *(v:dbl,b:bat[:oid,:dbl],accum:int) :bat[:oid,:dbl]
address CMDbatMULcstsignal
comment "Return V * B, signal error on overflow, reuse B if ACCUM is set";
pattern mul_noerror(v:dbl,b:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatMULcst
comment "Return V * B, overflow causes NIL value";


command /(b1:bat[:oid,:bte],b2:bat[:oid,:bte]) :bat[:oid,:bte]
address CMDbatDIVsignal
comment "Return B1 / B2, signal error on overflow";
command /(b1:bat[:oid,:bte],b2:bat[:oid,:bte],accum:int) :bat[:oid,:bte]
address CMDbatDIVsignalaccum
comment "Return B1 / B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command div_noerror(b1:bat[:oid,:bte],b2:bat[:oid,:bte]) :bat[:oid,:bte]
address CMDbatDIV
comment "Return B1 / B2, overflow causes NIL value";
pattern /(b:bat[:oid,:bte],v:bte) :bat[:oid,:bte]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow";
pattern /(b:bat[:oid,:bte],v:bte,accum:int) :bat[:oid,:bte]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow, reuse B if ACCUM is set";
pattern div_noerror(b:bat[:oid,:bte],v:bte) :bat[:oid,:bte]
address CMDbatDIVcst
comment "Return B / V, overflow causes NIL value";
pattern /(v:bte,b:bat[:oid,:bte]) :bat[:oid,:bte]
address CMDbatDIVcstsignal
comment "Return V / B, signal error on overflow";
pattern /(v:bte,b:bat[:oid,:bte],accum:int) :bat[:oid,:bte]
address CMDbatDIVcstsignal
comment "Return V / B, signal error on overflow, reuse B if ACCUM is set";
pattern div_noerror(v:bte,b:bat[:oid,:bte]) :bat[:oid,:bte]
address CMDbatDIVcst
comment "Return V / B, overflow causes NIL value";

command /(b1:bat[:oid,:bte],b2:bat[:oid,:sht]) :bat[:oid,:bte]
address CMDbatDIVsignal
comment "Return B1 / B2, signal error on overflow";
command /(b1:bat[:oid,:bte],b2:bat[:oid,:sht],accum:int) :bat[:oid,:bte]
address CMDbatDIVsignalaccum
comment "Return B1 / B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command div_noerror(b1:bat[:oid,:bte],b2:bat[:oid,:sht]) :bat[:oid,:bte]
address CMDbatDIV
comment "Return B1 / B2, overflow causes NIL value";
pattern /(b:bat[:oid,:bte],v:sht) :bat[:oid,:bte]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow";
pattern /(b:bat[:oid,:bte],v:sht,accum:int) :bat[:oid,:bte]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow, reuse B if ACCUM is set";
pattern div_noerror(b:bat[:oid,:bte],v:sht) :bat[:oid,:bte]
address CMDbatDIVcst
comment "Return B / V, overflow causes NIL value";
pattern /(v:bte,b:bat[:oid,:sht]) :bat[:oid,:bte]
address CMDbatDIVcstsignal
comment "Return V / B, signal error on overflow";
pattern div_noerror(v:bte,b:bat[:oid,:sht]) :bat[:oid,:bte]
address CMDbatDIVcst
comment "Return V / B, overflow causes NIL value";

command /(b1:bat[:oid,:bte],b2:bat[:oid,:int]) :bat[:oid,:bte]
address CMDbatDIVsignal
comment "Return B1 / B2, signal error on overflow";
command /(b1:bat[:oid,:bte],b2:bat[:oid,:int],accum:int) :bat[:oid,:bte]
address CMDbatDIVsignalaccum
comment "Return B1 / B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command div_noerror(b1:bat[:oid,:bte],b2:bat[:oid,:int]) :bat[:oid,:bte]
address CMDbatDIV
comment "Return B1 / B2, overflow causes NIL value";
pattern /(b:bat[:oid,:bte],v:int) :bat[:oid,:bte]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow";
pattern /(b:bat[:oid,:bte],v:int,accum:int) :bat[:oid,:bte]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow, reuse B if ACCUM is set";
pattern div_noerror(b:bat[:oid,:bte],v:int) :bat[:oid,:bte]
address CMDbatDIVcst
comment "Return B / V, overflow causes NIL value";
pattern /(v:bte,b:bat[:oid,:int]) :bat[:oid,:bte]
address CMDbatDIVcstsignal
comment "Return V / B, signal error on overflow";
pattern div_noerror(v:bte,b:bat[:oid,:int]) :bat[:oid,:bte]
address CMDbatDIVcst
comment "Return V / B, overflow causes NIL value";

command /(b1:bat[:oid,:bte],b2:bat[:oid,:wrd]) :bat[:oid,:bte]
address CMDbatDIVsignal
comment "Return B1 / B2, signal error on overflow";
command /(b1:bat[:oid,:bte],b2:bat[:oid,:wrd],accum:int) :bat[:oid,:bte]
address CMDbatDIVsignalaccum
comment "Return B1 / B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command div_noerror(b1:bat[:oid,:bte],b2:bat[:oid,:wrd]) :bat[:oid,:bte]
address CMDbatDIV
comment "Return B1 / B2, overflow causes NIL value";
pattern /(b:bat[:oid,:bte],v:wrd) :bat[:oid,:bte]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow";
pattern /(b:bat[:oid,:bte],v:wrd,accum:int) :bat[:oid,:bte]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow, reuse B if ACCUM is set";
pattern div_noerror(b:bat[:oid,:bte],v:wrd) :bat[:oid,:bte]
address CMDbatDIVcst
comment "Return B / V, overflow causes NIL value";
pattern /(v:bte,b:bat[:oid,:wrd]) :bat[:oid,:bte]
address CMDbatDIVcstsignal
comment "Return V / B, signal error on overflow";
pattern div_noerror(v:bte,b:bat[:oid,:wrd]) :bat[:oid,:bte]
address CMDbatDIVcst
comment "Return V / B, overflow causes NIL value";

command /(b1:bat[:oid,:bte],b2:bat[:oid,:lng]) :bat[:oid,:bte]
address CMDbatDIVsignal
comment "Return B1 / B2, signal error on overflow";
command /(b1:bat[:oid,:bte],b2:bat[:oid,:lng],accum:int) :bat[:oid,:bte]
address CMDbatDIVsignalaccum
comment "Return B1 / B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command div_noerror(b1:bat[:oid,:bte],b2:bat[:oid,:lng]) :bat[:oid,:bte]
address CMDbatDIV
comment "Return B1 / B2, overflow causes NIL value";
pattern /(b:bat[:oid,:bte],v:lng) :bat[:oid,:bte]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow";
pattern /(b:bat[:oid,:bte],v:lng,accum:int) :bat[:oid,:bte]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow, reuse B if ACCUM is set";
pattern div_noerror(b:bat[:oid,:bte],v:lng) :bat[:oid,:bte]
address CMDbatDIVcst
comment "Return B / V, overflow causes NIL value";
pattern /(v:bte,b:bat[:oid,:lng]) :bat[:oid,:bte]
address CMDbatDIVcstsignal
comment "Return V / B, signal error on overflow";
pattern div_noerror(v:bte,b:bat[:oid,:lng]) :bat[:oid,:bte]
address CMDbatDIVcst
comment "Return V / B, overflow causes NIL value";

command /(b1:bat[:oid,:bte],b2:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatDIVsignal
comment "Return B1 / B2, signal error on overflow";
command /(b1:bat[:oid,:bte],b2:bat[:oid,:flt],accum:int) :bat[:oid,:flt]
address CMDbatDIVsignalaccum
comment "Return B1 / B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command div_noerror(b1:bat[:oid,:bte],b2:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatDIV
comment "Return B1 / B2, overflow causes NIL value";
pattern /(b:bat[:oid,:bte],v:flt) :bat[:oid,:flt]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow";
pattern div_noerror(b:bat[:oid,:bte],v:flt) :bat[:oid,:flt]
address CMDbatDIVcst
comment "Return B / V, overflow causes NIL value";
pattern /(v:bte,b:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatDIVcstsignal
comment "Return V / B, signal error on overflow";
pattern /(v:bte,b:bat[:oid,:flt],accum:int) :bat[:oid,:flt]
address CMDbatDIVcstsignal
comment "Return V / B, signal error on overflow, reuse B if ACCUM is set";
pattern div_noerror(v:bte,b:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatDIVcst
comment "Return V / B, overflow causes NIL value";

command /(b1:bat[:oid,:bte],b2:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatDIVsignal
comment "Return B1 / B2, signal error on overflow";
command /(b1:bat[:oid,:bte],b2:bat[:oid,:dbl],accum:int) :bat[:oid,:dbl]
address CMDbatDIVsignalaccum
comment "Return B1 / B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command div_noerror(b1:bat[:oid,:bte],b2:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatDIV
comment "Return B1 / B2, overflow causes NIL value";
pattern /(b:bat[:oid,:bte],v:dbl) :bat[:oid,:dbl]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow";
pattern div_noerror(b:bat[:oid,:bte],v:dbl) :bat[:oid,:dbl]
address CMDbatDIVcst
comment "Return B / V, overflow causes NIL value";
pattern /(v:bte,b:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatDIVcstsignal
comment "Return V / B, signal error on overflow";
pattern /(v:bte,b:bat[:oid,:dbl],accum:int) :bat[:oid,:dbl]
address CMDbatDIVcstsignal
comment "Return V / B, signal error on overflow, reuse B if ACCUM is set";
pattern div_noerror(v:bte,b:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatDIVcst
comment "Return V / B, overflow causes NIL value";

command /(b1:bat[:oid,:sht],b2:bat[:oid,:bte]) :bat[:oid,:sht]
address CMDbatDIVsignal
comment "Return B1 / B2, signal error on overflow";
command /(b1:bat[:oid,:sht],b2:bat[:oid,:bte],accum:int) :bat[:oid,:sht]
address CMDbatDIVsignalaccum
comment "Return B1 / B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command div_noerror(b1:bat[:oid,:sht],b2:bat[:oid,:bte]) :bat[:oid,:sht]
address CMDbatDIV
comment "Return B1 / B2, overflow causes NIL value";
pattern /(b:bat[:oid,:sht],v:bte) :bat[:oid,:sht]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow";
pattern /(b:bat[:oid,:sht],v:bte,accum:int) :bat[:oid,:sht]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow, reuse B if ACCUM is set";
pattern div_noerror(b:bat[:oid,:sht],v:bte) :bat[:oid,:sht]
address CMDbatDIVcst
comment "Return B / V, overflow causes NIL value";
pattern /(v:sht,b:bat[:oid,:bte]) :bat[:oid,:sht]
address CMDbatDIVcstsignal
comment "Return V / B, signal error on overflow";
pattern div_noerror(v:sht,b:bat[:oid,:bte]) :bat[:oid,:sht]
address CMDbatDIVcst
comment "Return V / B, overflow causes NIL value";

command /(b1:bat[:oid,:sht],b2:bat[:oid,:sht]) :bat[:oid,:sht]
address CMDbatDIVsignal
comment "Return B1 / B2, signal error on overflow";
command /(b1:bat[:oid,:sht],b2:bat[:oid,:sht],accum:int) :bat[:oid,:sht]
address CMDbatDIVsignalaccum
comment "Return B1 / B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command div_noerror(b1:bat[:oid,:sht],b2:bat[:oid,:sht]) :bat[:oid,:sht]
address CMDbatDIV
comment "Return B1 / B2, overflow causes NIL value";
pattern /(b:bat[:oid,:sht],v:sht) :bat[:oid,:sht]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow";
pattern /(b:bat[:oid,:sht],v:sht,accum:int) :bat[:oid,:sht]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow, reuse B if ACCUM is set";
pattern div_noerror(b:bat[:oid,:sht],v:sht) :bat[:oid,:sht]
address CMDbatDIVcst
comment "Return B / V, overflow causes NIL value";
pattern /(v:sht,b:bat[:oid,:sht]) :bat[:oid,:sht]
address CMDbatDIVcstsignal
comment "Return V / B, signal error on overflow";
pattern /(v:sht,b:bat[:oid,:sht],accum:int) :bat[:oid,:sht]
address CMDbatDIVcstsignal
comment "Return V / B, signal error on overflow, reuse B if ACCUM is set";
pattern div_noerror(v:sht,b:bat[:oid,:sht]) :bat[:oid,:sht]
address CMDbatDIVcst
comment "Return V / B, overflow causes NIL value";

command /(b1:bat[:oid,:sht],b2:bat[:oid,:int]) :bat[:oid,:sht]
address CMDbatDIVsignal
comment "Return B1 / B2, signal error on overflow";
command /(b1:bat[:oid,:sht],b2:bat[:oid,:int],accum:int) :bat[:oid,:sht]
address CMDbatDIVsignalaccum
comment "Return B1 / B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command div_noerror(b1:bat[:oid,:sht],b2:bat[:oid,:int]) :bat[:oid,:sht]
address CMDbatDIV
comment "Return B1 / B2, overflow causes NIL value";
pattern /(b:bat[:oid,:sht],v:int) :bat[:oid,:sht]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow";
pattern /(b:bat[:oid,:sht],v:int,accum:int) :bat[:oid,:sht]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow, reuse B if ACCUM is set";
pattern div_noerror(b:bat[:oid,:sht],v:int) :bat[:oid,:sht]
address CMDbatDIVcst
comment "Return B / V, overflow causes NIL value";
pattern /(v:sht,b:bat[:oid,:int]) :bat[:oid,:sht]
address CMDbatDIVcstsignal
comment "Return V / B, signal error on overflow";
pattern div_noerror(v:sht,b:bat[:oid,:int]) :bat[:oid,:sht]
address CMDbatDIVcst
comment "Return V / B, overflow causes NIL value";

command /(b1:bat[:oid,:sht],b2:bat[:oid,:wrd]) :bat[:oid,:sht]
address CMDbatDIVsignal
comment "Return B1 / B2, signal error on overflow";
command /(b1:bat[:oid,:sht],b2:bat[:oid,:wrd],accum:int) :bat[:oid,:sht]
address CMDbatDIVsignalaccum
comment "Return B1 / B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command div_noerror(b1:bat[:oid,:sht],b2:bat[:oid,:wrd]) :bat[:oid,:sht]
address CMDbatDIV
comment "Return B1 / B2, overflow causes NIL value";
pattern /(b:bat[:oid,:sht],v:wrd) :bat[:oid,:sht]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow";
pattern /(b:bat[:oid,:sht],v:wrd,accum:int) :bat[:oid,:sht]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow, reuse B if ACCUM is set";
pattern div_noerror(b:bat[:oid,:sht],v:wrd) :bat[:oid,:sht]
address CMDbatDIVcst
comment "Return B / V, overflow causes NIL value";
pattern /(v:sht,b:bat[:oid,:wrd]) :bat[:oid,:sht]
address CMDbatDIVcstsignal
comment "Return V / B, signal error on overflow";
pattern div_noerror(v:sht,b:bat[:oid,:wrd]) :bat[:oid,:sht]
address CMDbatDIVcst
comment "Return V / B, overflow causes NIL value";

command /(b1:bat[:oid,:sht],b2:bat[:oid,:lng]) :bat[:oid,:sht]
address CMDbatDIVsignal
comment "Return B1 / B2, signal error on overflow";
command /(b1:bat[:oid,:sht],b2:bat[:oid,:lng],accum:int) :bat[:oid,:sht]
address CMDbatDIVsignalaccum
comment "Return B1 / B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command div_noerror(b1:bat[:oid,:sht],b2:bat[:oid,:lng]) :bat[:oid,:sht]
address CMDbatDIV
comment "Return B1 / B2, overflow causes NIL value";
pattern /(b:bat[:oid,:sht],v:lng) :bat[:oid,:sht]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow";
pattern /(b:bat[:oid,:sht],v:lng,accum:int) :bat[:oid,:sht]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow, reuse B if ACCUM is set";
pattern div_noerror(b:bat[:oid,:sht],v:lng) :bat[:oid,:sht]
address CMDbatDIVcst
comment "Return B / V, overflow causes NIL value";
pattern /(v:sht,b:bat[:oid,:lng]) :bat[:oid,:sht]
address CMDbatDIVcstsignal
comment "Return V / B, signal error on overflow";
pattern div_noerror(v:sht,b:bat[:oid,:lng]) :bat[:oid,:sht]
address CMDbatDIVcst
comment "Return V / B, overflow causes NIL value";

command /(b1:bat[:oid,:sht],b2:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatDIVsignal
comment "Return B1 / B2, signal error on overflow";
command /(b1:bat[:oid,:sht],b2:bat[:oid,:flt],accum:int) :bat[:oid,:flt]
address CMDbatDIVsignalaccum
comment "Return B1 / B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command div_noerror(b1:bat[:oid,:sht],b2:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatDIV
comment "Return B1 / B2, overflow causes NIL value";
pattern /(b:bat[:oid,:sht],v:flt) :bat[:oid,:flt]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow";
pattern div_noerror(b:bat[:oid,:sht],v:flt) :bat[:oid,:flt]
address CMDbatDIVcst
comment "Return B / V, overflow causes NIL value";
pattern /(v:sht,b:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatDIVcstsignal
comment "Return V / B, signal error on overflow";
pattern /(v:sht,b:bat[:oid,:flt],accum:int) :bat[:oid,:flt]
address CMDbatDIVcstsignal
comment "Return V / B, signal error on overflow, reuse B if ACCUM is set";
pattern div_noerror(v:sht,b:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatDIVcst
comment "Return V / B, overflow causes NIL value";

command /(b1:bat[:oid,:sht],b2:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatDIVsignal
comment "Return B1 / B2, signal error on overflow";
command /(b1:bat[:oid,:sht],b2:bat[:oid,:dbl],accum:int) :bat[:oid,:dbl]
address CMDbatDIVsignalaccum
comment "Return B1 / B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command div_noerror(b1:bat[:oid,:sht],b2:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatDIV
comment "Return B1 / B2, overflow causes NIL value";
pattern /(b:bat[:oid,:sht],v:dbl) :bat[:oid,:dbl]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow";
pattern div_noerror(b:bat[:oid,:sht],v:dbl) :bat[:oid,:dbl]
address CMDbatDIVcst
comment "Return B / V, overflow causes NIL value";
pattern /(v:sht,b:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatDIVcstsignal
comment "Return V / B, signal error on overflow";
pattern /(v:sht,b:bat[:oid,:dbl],accum:int) :bat[:oid,:dbl]
address CMDbatDIVcstsignal
comment "Return V / B, signal error on overflow, reuse B if ACCUM is set";
pattern div_noerror(v:sht,b:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatDIVcst
comment "Return V / B, overflow causes NIL value";

command /(b1:bat[:oid,:int],b2:bat[:oid,:bte]) :bat[:oid,:int]
address CMDbatDIVsignal
comment "Return B1 / B2, signal error on overflow";
command /(b1:bat[:oid,:int],b2:bat[:oid,:bte],accum:int) :bat[:oid,:int]
address CMDbatDIVsignalaccum
comment "Return B1 / B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command div_noerror(b1:bat[:oid,:int],b2:bat[:oid,:bte]) :bat[:oid,:int]
address CMDbatDIV
comment "Return B1 / B2, overflow causes NIL value";
pattern /(b:bat[:oid,:int],v:bte) :bat[:oid,:int]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow";
pattern /(b:bat[:oid,:int],v:bte,accum:int) :bat[:oid,:int]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow, reuse B if ACCUM is set";
pattern div_noerror(b:bat[:oid,:int],v:bte) :bat[:oid,:int]
address CMDbatDIVcst
comment "Return B / V, overflow causes NIL value";
pattern /(v:int,b:bat[:oid,:bte]) :bat[:oid,:int]
address CMDbatDIVcstsignal
comment "Return V / B, signal error on overflow";
pattern div_noerror(v:int,b:bat[:oid,:bte]) :bat[:oid,:int]
address CMDbatDIVcst
comment "Return V / B, overflow causes NIL value";

command /(b1:bat[:oid,:int],b2:bat[:oid,:sht]) :bat[:oid,:int]
address CMDbatDIVsignal
comment "Return B1 / B2, signal error on overflow";
command /(b1:bat[:oid,:int],b2:bat[:oid,:sht],accum:int) :bat[:oid,:int]
address CMDbatDIVsignalaccum
comment "Return B1 / B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command div_noerror(b1:bat[:oid,:int],b2:bat[:oid,:sht]) :bat[:oid,:int]
address CMDbatDIV
comment "Return B1 / B2, overflow causes NIL value";
pattern /(b:bat[:oid,:int],v:sht) :bat[:oid,:int]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow";
pattern /(b:bat[:oid,:int],v:sht,accum:int) :bat[:oid,:int]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow, reuse B if ACCUM is set";
pattern div_noerror(b:bat[:oid,:int],v:sht) :bat[:oid,:int]
address CMDbatDIVcst
comment "Return B / V, overflow causes NIL value";
pattern /(v:int,b:bat[:oid,:sht]) :bat[:oid,:int]
address CMDbatDIVcstsignal
comment "Return V / B, signal error on overflow";
pattern div_noerror(v:int,b:bat[:oid,:sht]) :bat[:oid,:int]
address CMDbatDIVcst
comment "Return V / B, overflow causes NIL value";

command /(b1:bat[:oid,:int],b2:bat[:oid,:int]) :bat[:oid,:int]
address CMDbatDIVsignal
comment "Return B1 / B2, signal error on overflow";
command /(b1:bat[:oid,:int],b2:bat[:oid,:int],accum:int) :bat[:oid,:int]
address CMDbatDIVsignalaccum
comment "Return B1 / B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command div_noerror(b1:bat[:oid,:int],b2:bat[:oid,:int]) :bat[:oid,:int]
address CMDbatDIV
comment "Return B1 / B2, overflow causes NIL value";
pattern /(b:bat[:oid,:int],v:int) :bat[:oid,:int]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow";
pattern /(b:bat[:oid,:int],v:int,accum:int) :bat[:oid,:int]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow, reuse B if ACCUM is set";
pattern div_noerror(b:bat[:oid,:int],v:int) :bat[:oid,:int]
address CMDbatDIVcst
comment "Return B / V, overflow causes NIL value";
pattern /(v:int,b:bat[:oid,:int]) :bat[:oid,:int]
address CMDbatDIVcstsignal
comment "Return V / B, signal error on overflow";
pattern /(v:int,b:bat[:oid,:int],accum:int) :bat[:oid,:int]
address CMDbatDIVcstsignal
comment "Return V / B, signal error on overflow, reuse B if ACCUM is set";
pattern div_noerror(v:int,b:bat[:oid,:int]) :bat[:oid,:int]
address CMDbatDIVcst
comment "Return V / B, overflow causes NIL value";

command /(b1:bat[:oid,:int],b2:bat[:oid,:wrd]) :bat[:oid,:int]
address CMDbatDIVsignal
comment "Return B1 / B2, signal error on overflow";
command /(b1:bat[:oid,:int],b2:bat[:oid,:wrd],accum:int) :bat[:oid,:int]
address CMDbatDIVsignalaccum
comment "Return B1 / B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command div_noerror(b1:bat[:oid,:int],b2:bat[:oid,:wrd]) :bat[:oid,:int]
address CMDbatDIV
comment "Return B1 / B2, overflow causes NIL value";
pattern /(b:bat[:oid,:int],v:wrd) :bat[:oid,:int]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow";
pattern /(b:bat[:oid,:int],v:wrd,accum:int) :bat[:oid,:int]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow, reuse B if ACCUM is set";
pattern div_noerror(b:bat[:oid,:int],v:wrd) :bat[:oid,:int]
address CMDbatDIVcst
comment "Return B / V, overflow causes NIL value";
pattern /(v:int,b:bat[:oid,:wrd]) :bat[:oid,:int]
address CMDbatDIVcstsignal
comment "Return V / B, signal error on overflow";
pattern div_noerror(v:int,b:bat[:oid,:wrd]) :bat[:oid,:int]
address CMDbatDIVcst
comment "Return V / B, overflow causes NIL value";

command /(b1:bat[:oid,:int],b2:bat[:oid,:lng]) :bat[:oid,:int]
address CMDbatDIVsignal
comment "Return B1 / B2, signal error on overflow";
command /(b1:bat[:oid,:int],b2:bat[:oid,:lng],accum:int) :bat[:oid,:int]
address CMDbatDIVsignalaccum
comment "Return B1 / B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command div_noerror(b1:bat[:oid,:int],b2:bat[:oid,:lng]) :bat[:oid,:int]
address CMDbatDIV
comment "Return B1 / B2, overflow causes NIL value";
pattern /(b:bat[:oid,:int],v:lng) :bat[:oid,:int]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow";
pattern /(b:bat[:oid,:int],v:lng,accum:int) :bat[:oid,:int]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow, reuse B if ACCUM is set";
pattern div_noerror(b:bat[:oid,:int],v:lng) :bat[:oid,:int]
address CMDbatDIVcst
comment "Return B / V, overflow causes NIL value";
pattern /(v:int,b:bat[:oid,:lng]) :bat[:oid,:int]
address CMDbatDIVcstsignal
comment "Return V / B, signal error on overflow";
pattern div_noerror(v:int,b:bat[:oid,:lng]) :bat[:oid,:int]
address CMDbatDIVcst
comment "Return V / B, overflow causes NIL value";

command /(b1:bat[:oid,:int],b2:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatDIVsignal
comment "Return B1 / B2, signal error on overflow";
command /(b1:bat[:oid,:int],b2:bat[:oid,:flt],accum:int) :bat[:oid,:flt]
address CMDbatDIVsignalaccum
comment "Return B1 / B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command div_noerror(b1:bat[:oid,:int],b2:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatDIV
comment "Return B1 / B2, overflow causes NIL value";
pattern /(b:bat[:oid,:int],v:flt) :bat[:oid,:flt]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow";
pattern div_noerror(b:bat[:oid,:int],v:flt) :bat[:oid,:flt]
address CMDbatDIVcst
comment "Return B / V, overflow causes NIL value";
pattern /(v:int,b:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatDIVcstsignal
comment "Return V / B, signal error on overflow";
pattern /(v:int,b:bat[:oid,:flt],accum:int) :bat[:oid,:flt]
address CMDbatDIVcstsignal
comment "Return V / B, signal error on overflow, reuse B if ACCUM is set";
pattern div_noerror(v:int,b:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatDIVcst
comment "Return V / B, overflow causes NIL value";

command /(b1:bat[:oid,:int],b2:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatDIVsignal
comment "Return B1 / B2, signal error on overflow";
command /(b1:bat[:oid,:int],b2:bat[:oid,:dbl],accum:int) :bat[:oid,:dbl]
address CMDbatDIVsignalaccum
comment "Return B1 / B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command div_noerror(b1:bat[:oid,:int],b2:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatDIV
comment "Return B1 / B2, overflow causes NIL value";
pattern /(b:bat[:oid,:int],v:dbl) :bat[:oid,:dbl]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow";
pattern div_noerror(b:bat[:oid,:int],v:dbl) :bat[:oid,:dbl]
address CMDbatDIVcst
comment "Return B / V, overflow causes NIL value";
pattern /(v:int,b:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatDIVcstsignal
comment "Return V / B, signal error on overflow";
pattern /(v:int,b:bat[:oid,:dbl],accum:int) :bat[:oid,:dbl]
address CMDbatDIVcstsignal
comment "Return V / B, signal error on overflow, reuse B if ACCUM is set";
pattern div_noerror(v:int,b:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatDIVcst
comment "Return V / B, overflow causes NIL value";

command /(b1:bat[:oid,:wrd],b2:bat[:oid,:bte]) :bat[:oid,:wrd]
address CMDbatDIVsignal
comment "Return B1 / B2, signal error on overflow";
command /(b1:bat[:oid,:wrd],b2:bat[:oid,:bte],accum:int) :bat[:oid,:wrd]
address CMDbatDIVsignalaccum
comment "Return B1 / B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command div_noerror(b1:bat[:oid,:wrd],b2:bat[:oid,:bte]) :bat[:oid,:wrd]
address CMDbatDIV
comment "Return B1 / B2, overflow causes NIL value";
pattern /(b:bat[:oid,:wrd],v:bte) :bat[:oid,:wrd]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow";
pattern /(b:bat[:oid,:wrd],v:bte,accum:int) :bat[:oid,:wrd]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow, reuse B if ACCUM is set";
pattern div_noerror(b:bat[:oid,:wrd],v:bte) :bat[:oid,:wrd]
address CMDbatDIVcst
comment "Return B / V, overflow causes NIL value";
pattern /(v:wrd,b:bat[:oid,:bte]) :bat[:oid,:wrd]
address CMDbatDIVcstsignal
comment "Return V / B, signal error on overflow";
pattern div_noerror(v:wrd,b:bat[:oid,:bte]) :bat[:oid,:wrd]
address CMDbatDIVcst
comment "Return V / B, overflow causes NIL value";

command /(b1:bat[:oid,:wrd],b2:bat[:oid,:sht]) :bat[:oid,:wrd]
address CMDbatDIVsignal
comment "Return B1 / B2, signal error on overflow";
command /(b1:bat[:oid,:wrd],b2:bat[:oid,:sht],accum:int) :bat[:oid,:wrd]
address CMDbatDIVsignalaccum
comment "Return B1 / B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command div_noerror(b1:bat[:oid,:wrd],b2:bat[:oid,:sht]) :bat[:oid,:wrd]
address CMDbatDIV
comment "Return B1 / B2, overflow causes NIL value";
pattern /(b:bat[:oid,:wrd],v:sht) :bat[:oid,:wrd]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow";
pattern /(b:bat[:oid,:wrd],v:sht,accum:int) :bat[:oid,:wrd]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow, reuse B if ACCUM is set";
pattern div_noerror(b:bat[:oid,:wrd],v:sht) :bat[:oid,:wrd]
address CMDbatDIVcst
comment "Return B / V, overflow causes NIL value";
pattern /(v:wrd,b:bat[:oid,:sht]) :bat[:oid,:wrd]
address CMDbatDIVcstsignal
comment "Return V / B, signal error on overflow";
pattern div_noerror(v:wrd,b:bat[:oid,:sht]) :bat[:oid,:wrd]
address CMDbatDIVcst
comment "Return V / B, overflow causes NIL value";

command /(b1:bat[:oid,:wrd],b2:bat[:oid,:int]) :bat[:oid,:wrd]
address CMDbatDIVsignal
comment "Return B1 / B2, signal error on overflow";
command /(b1:bat[:oid,:wrd],b2:bat[:oid,:int],accum:int) :bat[:oid,:wrd]
address CMDbatDIVsignalaccum
comment "Return B1 / B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command div_noerror(b1:bat[:oid,:wrd],b2:bat[:oid,:int]) :bat[:oid,:wrd]
address CMDbatDIV
comment "Return B1 / B2, overflow causes NIL value";
pattern /(b:bat[:oid,:wrd],v:int) :bat[:oid,:wrd]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow";
pattern /(b:bat[:oid,:wrd],v:int,accum:int) :bat[:oid,:wrd]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow, reuse B if ACCUM is set";
pattern div_noerror(b:bat[:oid,:wrd],v:int) :bat[:oid,:wrd]
address CMDbatDIVcst
comment "Return B / V, overflow causes NIL value";
pattern /(v:wrd,b:bat[:oid,:int]) :bat[:oid,:wrd]
address CMDbatDIVcstsignal
comment "Return V / B, signal error on overflow";
pattern div_noerror(v:wrd,b:bat[:oid,:int]) :bat[:oid,:wrd]
address CMDbatDIVcst
comment "Return V / B, overflow causes NIL value";

command /(b1:bat[:oid,:wrd],b2:bat[:oid,:wrd]) :bat[:oid,:wrd]
address CMDbatDIVsignal
comment "Return B1 / B2, signal error on overflow";
command /(b1:bat[:oid,:wrd],b2:bat[:oid,:wrd],accum:int) :bat[:oid,:wrd]
address CMDbatDIVsignalaccum
comment "Return B1 / B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command div_noerror(b1:bat[:oid,:wrd],b2:bat[:oid,:wrd]) :bat[:oid,:wrd]
address CMDbatDIV
comment "Return B1 / B2, overflow causes NIL value";
pattern /(b:bat[:oid,:wrd],v:wrd) :bat[:oid,:wrd]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow";
pattern /(b:bat[:oid,:wrd],v:wrd,accum:int) :bat[:oid,:wrd]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow, reuse B if ACCUM is set";
pattern div_noerror(b:bat[:oid,:wrd],v:wrd) :bat[:oid,:wrd]
address CMDbatDIVcst
comment "Return B / V, overflow causes NIL value";
pattern /(v:wrd,b:bat[:oid,:wrd]) :bat[:oid,:wrd]
address CMDbatDIVcstsignal
comment "Return V / B, signal error on overflow";
pattern /(v:wrd,b:bat[:oid,:wrd],accum:int) :bat[:oid,:wrd]
address CMDbatDIVcstsignal
comment "Return V / B, signal error on overflow, reuse B if ACCUM is set";
pattern div_noerror(v:wrd,b:bat[:oid,:wrd]) :bat[:oid,:wrd]
address CMDbatDIVcst
comment "Return V / B, overflow causes NIL value";

command /(b1:bat[:oid,:wrd],b2:bat[:oid,:lng]) :bat[:oid,:wrd]
address CMDbatDIVsignal
comment "Return B1 / B2, signal error on overflow";
command /(b1:bat[:oid,:wrd],b2:bat[:oid,:lng],accum:int) :bat[:oid,:wrd]
address CMDbatDIVsignalaccum
comment "Return B1 / B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command div_noerror(b1:bat[:oid,:wrd],b2:bat[:oid,:lng]) :bat[:oid,:wrd]
address CMDbatDIV
comment "Return B1 / B2, overflow causes NIL value";
pattern /(b:bat[:oid,:wrd],v:lng) :bat[:oid,:wrd]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow";
pattern /(b:bat[:oid,:wrd],v:lng,accum:int) :bat[:oid,:wrd]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow, reuse B if ACCUM is set";
pattern div_noerror(b:bat[:oid,:wrd],v:lng) :bat[:oid,:wrd]
address CMDbatDIVcst
comment "Return B / V, overflow causes NIL value";
pattern /(v:wrd,b:bat[:oid,:lng]) :bat[:oid,:wrd]
address CMDbatDIVcstsignal
comment "Return V / B, signal error on overflow";
pattern div_noerror(v:wrd,b:bat[:oid,:lng]) :bat[:oid,:wrd]
address CMDbatDIVcst
comment "Return V / B, overflow causes NIL value";

command /(b1:bat[:oid,:wrd],b2:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatDIVsignal
comment "Return B1 / B2, signal error on overflow";
command /(b1:bat[:oid,:wrd],b2:bat[:oid,:flt],accum:int) :bat[:oid,:flt]
address CMDbatDIVsignalaccum
comment "Return B1 / B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command div_noerror(b1:bat[:oid,:wrd],b2:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatDIV
comment "Return B1 / B2, overflow causes NIL value";
pattern /(b:bat[:oid,:wrd],v:flt) :bat[:oid,:flt]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow";
pattern div_noerror(b:bat[:oid,:wrd],v:flt) :bat[:oid,:flt]
address CMDbatDIVcst
comment "Return B / V, overflow causes NIL value";
pattern /(v:wrd,b:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatDIVcstsignal
comment "Return V / B, signal error on overflow";
pattern /(v:wrd,b:bat[:oid,:flt],accum:int) :bat[:oid,:flt]
address CMDbatDIVcstsignal
comment "Return V / B, signal error on overflow, reuse B if ACCUM is set";
pattern div_noerror(v:wrd,b:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatDIVcst
comment "Return V / B, overflow causes NIL value";

command /(b1:bat[:oid,:wrd],b2:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatDIVsignal
comment "Return B1 / B2, signal error on overflow";
command /(b1:bat[:oid,:wrd],b2:bat[:oid,:dbl],accum:int) :bat[:oid,:dbl]
address CMDbatDIVsignalaccum
comment "Return B1 / B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command div_noerror(b1:bat[:oid,:wrd],b2:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatDIV
comment "Return B1 / B2, overflow causes NIL value";
pattern /(b:bat[:oid,:wrd],v:dbl) :bat[:oid,:dbl]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow";
pattern div_noerror(b:bat[:oid,:wrd],v:dbl) :bat[:oid,:dbl]
address CMDbatDIVcst
comment "Return B / V, overflow causes NIL value";
pattern /(v:wrd,b:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatDIVcstsignal
comment "Return V / B, signal error on overflow";
pattern /(v:wrd,b:bat[:oid,:dbl],accum:int) :bat[:oid,:dbl]
address CMDbatDIVcstsignal
comment "Return V / B, signal error on overflow, reuse B if ACCUM is set";
pattern div_noerror(v:wrd,b:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatDIVcst
comment "Return V / B, overflow causes NIL value";

command /(b1:bat[:oid,:lng],b2:bat[:oid,:bte]) :bat[:oid,:lng]
address CMDbatDIVsignal
comment "Return B1 / B2, signal error on overflow";
command /(b1:bat[:oid,:lng],b2:bat[:oid,:bte],accum:int) :bat[:oid,:lng]
address CMDbatDIVsignalaccum
comment "Return B1 / B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command div_noerror(b1:bat[:oid,:lng],b2:bat[:oid,:bte]) :bat[:oid,:lng]
address CMDbatDIV
comment "Return B1 / B2, overflow causes NIL value";
pattern /(b:bat[:oid,:lng],v:bte) :bat[:oid,:lng]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow";
pattern /(b:bat[:oid,:lng],v:bte,accum:int) :bat[:oid,:lng]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow, reuse B if ACCUM is set";
pattern div_noerror(b:bat[:oid,:lng],v:bte) :bat[:oid,:lng]
address CMDbatDIVcst
comment "Return B / V, overflow causes NIL value";
pattern /(v:lng,b:bat[:oid,:bte]) :bat[:oid,:lng]
address CMDbatDIVcstsignal
comment "Return V / B, signal error on overflow";
pattern div_noerror(v:lng,b:bat[:oid,:bte]) :bat[:oid,:lng]
address CMDbatDIVcst
comment "Return V / B, overflow causes NIL value";

command /(b1:bat[:oid,:lng],b2:bat[:oid,:sht]) :bat[:oid,:lng]
address CMDbatDIVsignal
comment "Return B1 / B2, signal error on overflow";
command /(b1:bat[:oid,:lng],b2:bat[:oid,:sht],accum:int) :bat[:oid,:lng]
address CMDbatDIVsignalaccum
comment "Return B1 / B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command div_noerror(b1:bat[:oid,:lng],b2:bat[:oid,:sht]) :bat[:oid,:lng]
address CMDbatDIV
comment "Return B1 / B2, overflow causes NIL value";
pattern /(b:bat[:oid,:lng],v:sht) :bat[:oid,:lng]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow";
pattern /(b:bat[:oid,:lng],v:sht,accum:int) :bat[:oid,:lng]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow, reuse B if ACCUM is set";
pattern div_noerror(b:bat[:oid,:lng],v:sht) :bat[:oid,:lng]
address CMDbatDIVcst
comment "Return B / V, overflow causes NIL value";
pattern /(v:lng,b:bat[:oid,:sht]) :bat[:oid,:lng]
address CMDbatDIVcstsignal
comment "Return V / B, signal error on overflow";
pattern div_noerror(v:lng,b:bat[:oid,:sht]) :bat[:oid,:lng]
address CMDbatDIVcst
comment "Return V / B, overflow causes NIL value";

command /(b1:bat[:oid,:lng],b2:bat[:oid,:int]) :bat[:oid,:lng]
address CMDbatDIVsignal
comment "Return B1 / B2, signal error on overflow";
command /(b1:bat[:oid,:lng],b2:bat[:oid,:int],accum:int) :bat[:oid,:lng]
address CMDbatDIVsignalaccum
comment "Return B1 / B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command div_noerror(b1:bat[:oid,:lng],b2:bat[:oid,:int]) :bat[:oid,:lng]
address CMDbatDIV
comment "Return B1 / B2, overflow causes NIL value";
pattern /(b:bat[:oid,:lng],v:int) :bat[:oid,:lng]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow";
pattern /(b:bat[:oid,:lng],v:int,accum:int) :bat[:oid,:lng]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow, reuse B if ACCUM is set";
pattern div_noerror(b:bat[:oid,:lng],v:int) :bat[:oid,:lng]
address CMDbatDIVcst
comment "Return B / V, overflow causes NIL value";
pattern /(v:lng,b:bat[:oid,:int]) :bat[:oid,:lng]
address CMDbatDIVcstsignal
comment "Return V / B, signal error on overflow";
pattern div_noerror(v:lng,b:bat[:oid,:int]) :bat[:oid,:lng]
address CMDbatDIVcst
comment "Return V / B, overflow causes NIL value";

command /(b1:bat[:oid,:lng],b2:bat[:oid,:wrd]) :bat[:oid,:lng]
address CMDbatDIVsignal
comment "Return B1 / B2, signal error on overflow";
command /(b1:bat[:oid,:lng],b2:bat[:oid,:wrd],accum:int) :bat[:oid,:lng]
address CMDbatDIVsignalaccum
comment "Return B1 / B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command div_noerror(b1:bat[:oid,:lng],b2:bat[:oid,:wrd]) :bat[:oid,:lng]
address CMDbatDIV
comment "Return B1 / B2, overflow causes NIL value";
pattern /(b:bat[:oid,:lng],v:wrd) :bat[:oid,:lng]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow";
pattern /(b:bat[:oid,:lng],v:wrd,accum:int) :bat[:oid,:lng]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow, reuse B if ACCUM is set";
pattern div_noerror(b:bat[:oid,:lng],v:wrd) :bat[:oid,:lng]
address CMDbatDIVcst
comment "Return B / V, overflow causes NIL value";
pattern /(v:lng,b:bat[:oid,:wrd]) :bat[:oid,:lng]
address CMDbatDIVcstsignal
comment "Return V / B, signal error on overflow";
pattern div_noerror(v:lng,b:bat[:oid,:wrd]) :bat[:oid,:lng]
address CMDbatDIVcst
comment "Return V / B, overflow causes NIL value";

command /(b1:bat[:oid,:lng],b2:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatDIVsignal
comment "Return B1 / B2, signal error on overflow";
command /(b1:bat[:oid,:lng],b2:bat[:oid,:lng],accum:int) :bat[:oid,:lng]
address CMDbatDIVsignalaccum
comment "Return B1 / B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command div_noerror(b1:bat[:oid,:lng],b2:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatDIV
comment "Return B1 / B2, overflow causes NIL value";
pattern /(b:bat[:oid,:lng],v:lng) :bat[:oid,:lng]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow";
pattern /(b:bat[:oid,:lng],v:lng,accum:int) :bat[:oid,:lng]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow, reuse B if ACCUM is set";
pattern div_noerror(b:bat[:oid,:lng],v:lng) :bat[:oid,:lng]
address CMDbatDIVcst
comment "Return B / V, overflow causes NIL value";
pattern /(v:lng,b:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatDIVcstsignal
comment "Return V / B, signal error on overflow";
pattern /(v:lng,b:bat[:oid,:lng],accum:int) :bat[:oid,:lng]
address CMDbatDIVcstsignal
comment "Return V / B, signal error on overflow, reuse B if ACCUM is set";
pattern div_noerror(v:lng,b:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatDIVcst
comment "Return V / B, overflow causes NIL value";

command /(b1:bat[:oid,:lng],b2:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatDIVsignal
comment "Return B1 / B2, signal error on overflow";
command /(b1:bat[:oid,:lng],b2:bat[:oid,:flt],accum:int) :bat[:oid,:flt]
address CMDbatDIVsignalaccum
comment "Return B1 / B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command div_noerror(b1:bat[:oid,:lng],b2:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatDIV
comment "Return B1 / B2, overflow causes NIL value";
pattern /(b:bat[:oid,:lng],v:flt) :bat[:oid,:flt]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow";
pattern div_noerror(b:bat[:oid,:lng],v:flt) :bat[:oid,:flt]
address CMDbatDIVcst
comment "Return B / V, overflow causes NIL value";
pattern /(v:lng,b:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatDIVcstsignal
comment "Return V / B, signal error on overflow";
pattern /(v:lng,b:bat[:oid,:flt],accum:int) :bat[:oid,:flt]
address CMDbatDIVcstsignal
comment "Return V / B, signal error on overflow, reuse B if ACCUM is set";
pattern div_noerror(v:lng,b:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatDIVcst
comment "Return V / B, overflow causes NIL value";

command /(b1:bat[:oid,:lng],b2:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatDIVsignal
comment "Return B1 / B2, signal error on overflow";
command /(b1:bat[:oid,:lng],b2:bat[:oid,:dbl],accum:int) :bat[:oid,:dbl]
address CMDbatDIVsignalaccum
comment "Return B1 / B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command div_noerror(b1:bat[:oid,:lng],b2:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatDIV
comment "Return B1 / B2, overflow causes NIL value";
pattern /(b:bat[:oid,:lng],v:dbl) :bat[:oid,:dbl]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow";
pattern div_noerror(b:bat[:oid,:lng],v:dbl) :bat[:oid,:dbl]
address CMDbatDIVcst
comment "Return B / V, overflow causes NIL value";
pattern /(v:lng,b:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatDIVcstsignal
comment "Return V / B, signal error on overflow";
pattern /(v:lng,b:bat[:oid,:dbl],accum:int) :bat[:oid,:dbl]
address CMDbatDIVcstsignal
comment "Return V / B, signal error on overflow, reuse B if ACCUM is set";
pattern div_noerror(v:lng,b:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatDIVcst
comment "Return V / B, overflow causes NIL value";

command /(b1:bat[:oid,:flt],b2:bat[:oid,:bte]) :bat[:oid,:flt]
address CMDbatDIVsignal
comment "Return B1 / B2, signal error on overflow";
command /(b1:bat[:oid,:flt],b2:bat[:oid,:bte],accum:int) :bat[:oid,:flt]
address CMDbatDIVsignalaccum
comment "Return B1 / B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command div_noerror(b1:bat[:oid,:flt],b2:bat[:oid,:bte]) :bat[:oid,:flt]
address CMDbatDIV
comment "Return B1 / B2, overflow causes NIL value";
pattern /(b:bat[:oid,:flt],v:bte) :bat[:oid,:flt]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow";
pattern /(b:bat[:oid,:flt],v:bte,accum:int) :bat[:oid,:flt]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow, reuse B if ACCUM is set";
pattern div_noerror(b:bat[:oid,:flt],v:bte) :bat[:oid,:flt]
address CMDbatDIVcst
comment "Return B / V, overflow causes NIL value";
pattern /(v:flt,b:bat[:oid,:bte]) :bat[:oid,:flt]
address CMDbatDIVcstsignal
comment "Return V / B, signal error on overflow";
pattern div_noerror(v:flt,b:bat[:oid,:bte]) :bat[:oid,:flt]
address CMDbatDIVcst
comment "Return V / B, overflow causes NIL value";

command /(b1:bat[:oid,:flt],b2:bat[:oid,:sht]) :bat[:oid,:flt]
address CMDbatDIVsignal
comment "Return B1 / B2, signal error on overflow";
command /(b1:bat[:oid,:flt],b2:bat[:oid,:sht],accum:int) :bat[:oid,:flt]
address CMDbatDIVsignalaccum
comment "Return B1 / B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command div_noerror(b1:bat[:oid,:flt],b2:bat[:oid,:sht]) :bat[:oid,:flt]
address CMDbatDIV
comment "Return B1 / B2, overflow causes NIL value";
pattern /(b:bat[:oid,:flt],v:sht) :bat[:oid,:flt]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow";
pattern /(b:bat[:oid,:flt],v:sht,accum:int) :bat[:oid,:flt]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow, reuse B if ACCUM is set";
pattern div_noerror(b:bat[:oid,:flt],v:sht) :bat[:oid,:flt]
address CMDbatDIVcst
comment "Return B / V, overflow causes NIL value";
pattern /(v:flt,b:bat[:oid,:sht]) :bat[:oid,:flt]
address CMDbatDIVcstsignal
comment "Return V / B, signal error on overflow";
pattern div_noerror(v:flt,b:bat[:oid,:sht]) :bat[:oid,:flt]
address CMDbatDIVcst
comment "Return V / B, overflow causes NIL value";

command /(b1:bat[:oid,:flt],b2:bat[:oid,:int]) :bat[:oid,:flt]
address CMDbatDIVsignal
comment "Return B1 / B2, signal error on overflow";
command /(b1:bat[:oid,:flt],b2:bat[:oid,:int],accum:int) :bat[:oid,:flt]
address CMDbatDIVsignalaccum
comment "Return B1 / B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command div_noerror(b1:bat[:oid,:flt],b2:bat[:oid,:int]) :bat[:oid,:flt]
address CMDbatDIV
comment "Return B1 / B2, overflow causes NIL value";
pattern /(b:bat[:oid,:flt],v:int) :bat[:oid,:flt]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow";
pattern /(b:bat[:oid,:flt],v:int,accum:int) :bat[:oid,:flt]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow, reuse B if ACCUM is set";
pattern div_noerror(b:bat[:oid,:flt],v:int) :bat[:oid,:flt]
address CMDbatDIVcst
comment "Return B / V, overflow causes NIL value";
pattern /(v:flt,b:bat[:oid,:int]) :bat[:oid,:flt]
address CMDbatDIVcstsignal
comment "Return V / B, signal error on overflow";
pattern div_noerror(v:flt,b:bat[:oid,:int]) :bat[:oid,:flt]
address CMDbatDIVcst
comment "Return V / B, overflow causes NIL value";

command /(b1:bat[:oid,:flt],b2:bat[:oid,:wrd]) :bat[:oid,:flt]
address CMDbatDIVsignal
comment "Return B1 / B2, signal error on overflow";
command /(b1:bat[:oid,:flt],b2:bat[:oid,:wrd],accum:int) :bat[:oid,:flt]
address CMDbatDIVsignalaccum
comment "Return B1 / B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command div_noerror(b1:bat[:oid,:flt],b2:bat[:oid,:wrd]) :bat[:oid,:flt]
address CMDbatDIV
comment "Return B1 / B2, overflow causes NIL value";
pattern /(b:bat[:oid,:flt],v:wrd) :bat[:oid,:flt]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow";
pattern /(b:bat[:oid,:flt],v:wrd,accum:int) :bat[:oid,:flt]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow, reuse B if ACCUM is set";
pattern div_noerror(b:bat[:oid,:flt],v:wrd) :bat[:oid,:flt]
address CMDbatDIVcst
comment "Return B / V, overflow causes NIL value";
pattern /(v:flt,b:bat[:oid,:wrd]) :bat[:oid,:flt]
address CMDbatDIVcstsignal
comment "Return V / B, signal error on overflow";
pattern div_noerror(v:flt,b:bat[:oid,:wrd]) :bat[:oid,:flt]
address CMDbatDIVcst
comment "Return V / B, overflow causes NIL value";

command /(b1:bat[:oid,:flt],b2:bat[:oid,:lng]) :bat[:oid,:flt]
address CMDbatDIVsignal
comment "Return B1 / B2, signal error on overflow";
command /(b1:bat[:oid,:flt],b2:bat[:oid,:lng],accum:int) :bat[:oid,:flt]
address CMDbatDIVsignalaccum
comment "Return B1 / B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command div_noerror(b1:bat[:oid,:flt],b2:bat[:oid,:lng]) :bat[:oid,:flt]
address CMDbatDIV
comment "Return B1 / B2, overflow causes NIL value";
pattern /(b:bat[:oid,:flt],v:lng) :bat[:oid,:flt]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow";
pattern /(b:bat[:oid,:flt],v:lng,accum:int) :bat[:oid,:flt]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow, reuse B if ACCUM is set";
pattern div_noerror(b:bat[:oid,:flt],v:lng) :bat[:oid,:flt]
address CMDbatDIVcst
comment "Return B / V, overflow causes NIL value";
pattern /(v:flt,b:bat[:oid,:lng]) :bat[:oid,:flt]
address CMDbatDIVcstsignal
comment "Return V / B, signal error on overflow";
pattern div_noerror(v:flt,b:bat[:oid,:lng]) :bat[:oid,:flt]
address CMDbatDIVcst
comment "Return V / B, overflow causes NIL value";

command /(b1:bat[:oid,:flt],b2:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatDIVsignal
comment "Return B1 / B2, signal error on overflow";
command /(b1:bat[:oid,:flt],b2:bat[:oid,:flt],accum:int) :bat[:oid,:flt]
address CMDbatDIVsignalaccum
comment "Return B1 / B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command div_noerror(b1:bat[:oid,:flt],b2:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatDIV
comment "Return B1 / B2, overflow causes NIL value";
pattern /(b:bat[:oid,:flt],v:flt) :bat[:oid,:flt]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow";
pattern /(b:bat[:oid,:flt],v:flt,accum:int) :bat[:oid,:flt]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow, reuse B if ACCUM is set";
pattern div_noerror(b:bat[:oid,:flt],v:flt) :bat[:oid,:flt]
address CMDbatDIVcst
comment "Return B / V, overflow causes NIL value";
pattern /(v:flt,b:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatDIVcstsignal
comment "Return V / B, signal error on overflow";
pattern /(v:flt,b:bat[:oid,:flt],accum:int) :bat[:oid,:flt]
address CMDbatDIVcstsignal
comment "Return V / B, signal error on overflow, reuse B if ACCUM is set";
pattern div_noerror(v:flt,b:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatDIVcst
comment "Return V / B, overflow causes NIL value";

command /(b1:bat[:oid,:flt],b2:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatDIVsignal
comment "Return B1 / B2, signal error on overflow";
command /(b1:bat[:oid,:flt],b2:bat[:oid,:dbl],accum:int) :bat[:oid,:dbl]
address CMDbatDIVsignalaccum
comment "Return B1 / B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command div_noerror(b1:bat[:oid,:flt],b2:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatDIV
comment "Return B1 / B2, overflow causes NIL value";
pattern /(b:bat[:oid,:flt],v:dbl) :bat[:oid,:dbl]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow";
pattern div_noerror(b:bat[:oid,:flt],v:dbl) :bat[:oid,:dbl]
address CMDbatDIVcst
comment "Return B / V, overflow causes NIL value";
pattern /(v:flt,b:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatDIVcstsignal
comment "Return V / B, signal error on overflow";
pattern /(v:flt,b:bat[:oid,:dbl],accum:int) :bat[:oid,:dbl]
address CMDbatDIVcstsignal
comment "Return V / B, signal error on overflow, reuse B if ACCUM is set";
pattern div_noerror(v:flt,b:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatDIVcst
comment "Return V / B, overflow causes NIL value";

command /(b1:bat[:oid,:dbl],b2:bat[:oid,:bte]) :bat[:oid,:dbl]
address CMDbatDIVsignal
comment "Return B1 / B2, signal error on overflow";
command /(b1:bat[:oid,:dbl],b2:bat[:oid,:bte],accum:int) :bat[:oid,:dbl]
address CMDbatDIVsignalaccum
comment "Return B1 / B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command div_noerror(b1:bat[:oid,:dbl],b2:bat[:oid,:bte]) :bat[:oid,:dbl]
address CMDbatDIV
comment "Return B1 / B2, overflow causes NIL value";
pattern /(b:bat[:oid,:dbl],v:bte) :bat[:oid,:dbl]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow";
pattern /(b:bat[:oid,:dbl],v:bte,accum:int) :bat[:oid,:dbl]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow, reuse B if ACCUM is set";
pattern div_noerror(b:bat[:oid,:dbl],v:bte) :bat[:oid,:dbl]
address CMDbatDIVcst
comment "Return B / V, overflow causes NIL value";
pattern /(v:dbl,b:bat[:oid,:bte]) :bat[:oid,:dbl]
address CMDbatDIVcstsignal
comment "Return V / B, signal error on overflow";
pattern div_noerror(v:dbl,b:bat[:oid,:bte]) :bat[:oid,:dbl]
address CMDbatDIVcst
comment "Return V / B, overflow causes NIL value";

command /(b1:bat[:oid,:dbl],b2:bat[:oid,:sht]) :bat[:oid,:dbl]
address CMDbatDIVsignal
comment "Return B1 / B2, signal error on overflow";
command /(b1:bat[:oid,:dbl],b2:bat[:oid,:sht],accum:int) :bat[:oid,:dbl]
address CMDbatDIVsignalaccum
comment "Return B1 / B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command div_noerror(b1:bat[:oid,:dbl],b2:bat[:oid,:sht]) :bat[:oid,:dbl]
address CMDbatDIV
comment "Return B1 / B2, overflow causes NIL value";
pattern /(b:bat[:oid,:dbl],v:sht) :bat[:oid,:dbl]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow";
pattern /(b:bat[:oid,:dbl],v:sht,accum:int) :bat[:oid,:dbl]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow, reuse B if ACCUM is set";
pattern div_noerror(b:bat[:oid,:dbl],v:sht) :bat[:oid,:dbl]
address CMDbatDIVcst
comment "Return B / V, overflow causes NIL value";
pattern /(v:dbl,b:bat[:oid,:sht]) :bat[:oid,:dbl]
address CMDbatDIVcstsignal
comment "Return V / B, signal error on overflow";
pattern div_noerror(v:dbl,b:bat[:oid,:sht]) :bat[:oid,:dbl]
address CMDbatDIVcst
comment "Return V / B, overflow causes NIL value";

command /(b1:bat[:oid,:dbl],b2:bat[:oid,:int]) :bat[:oid,:dbl]
address CMDbatDIVsignal
comment "Return B1 / B2, signal error on overflow";
command /(b1:bat[:oid,:dbl],b2:bat[:oid,:int],accum:int) :bat[:oid,:dbl]
address CMDbatDIVsignalaccum
comment "Return B1 / B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command div_noerror(b1:bat[:oid,:dbl],b2:bat[:oid,:int]) :bat[:oid,:dbl]
address CMDbatDIV
comment "Return B1 / B2, overflow causes NIL value";
pattern /(b:bat[:oid,:dbl],v:int) :bat[:oid,:dbl]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow";
pattern /(b:bat[:oid,:dbl],v:int,accum:int) :bat[:oid,:dbl]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow, reuse B if ACCUM is set";
pattern div_noerror(b:bat[:oid,:dbl],v:int) :bat[:oid,:dbl]
address CMDbatDIVcst
comment "Return B / V, overflow causes NIL value";
pattern /(v:dbl,b:bat[:oid,:int]) :bat[:oid,:dbl]
address CMDbatDIVcstsignal
comment "Return V / B, signal error on overflow";
pattern div_noerror(v:dbl,b:bat[:oid,:int]) :bat[:oid,:dbl]
address CMDbatDIVcst
comment "Return V / B, overflow causes NIL value";

command /(b1:bat[:oid,:dbl],b2:bat[:oid,:wrd]) :bat[:oid,:dbl]
address CMDbatDIVsignal
comment "Return B1 / B2, signal error on overflow";
command /(b1:bat[:oid,:dbl],b2:bat[:oid,:wrd],accum:int) :bat[:oid,:dbl]
address CMDbatDIVsignalaccum
comment "Return B1 / B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command div_noerror(b1:bat[:oid,:dbl],b2:bat[:oid,:wrd]) :bat[:oid,:dbl]
address CMDbatDIV
comment "Return B1 / B2, overflow causes NIL value";
pattern /(b:bat[:oid,:dbl],v:wrd) :bat[:oid,:dbl]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow";
pattern /(b:bat[:oid,:dbl],v:wrd,accum:int) :bat[:oid,:dbl]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow, reuse B if ACCUM is set";
pattern div_noerror(b:bat[:oid,:dbl],v:wrd) :bat[:oid,:dbl]
address CMDbatDIVcst
comment "Return B / V, overflow causes NIL value";
pattern /(v:dbl,b:bat[:oid,:wrd]) :bat[:oid,:dbl]
address CMDbatDIVcstsignal
comment "Return V / B, signal error on overflow";
pattern div_noerror(v:dbl,b:bat[:oid,:wrd]) :bat[:oid,:dbl]
address CMDbatDIVcst
comment "Return V / B, overflow causes NIL value";

command /(b1:bat[:oid,:dbl],b2:bat[:oid,:lng]) :bat[:oid,:dbl]
address CMDbatDIVsignal
comment "Return B1 / B2, signal error on overflow";
command /(b1:bat[:oid,:dbl],b2:bat[:oid,:lng],accum:int) :bat[:oid,:dbl]
address CMDbatDIVsignalaccum
comment "Return B1 / B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command div_noerror(b1:bat[:oid,:dbl],b2:bat[:oid,:lng]) :bat[:oid,:dbl]
address CMDbatDIV
comment "Return B1 / B2, overflow causes NIL value";
pattern /(b:bat[:oid,:dbl],v:lng) :bat[:oid,:dbl]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow";
pattern /(b:bat[:oid,:dbl],v:lng,accum:int) :bat[:oid,:dbl]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow, reuse B if ACCUM is set";
pattern div_noerror(b:bat[:oid,:dbl],v:lng) :bat[:oid,:dbl]
address CMDbatDIVcst
comment "Return B / V, overflow causes NIL value";
pattern /(v:dbl,b:bat[:oid,:lng]) :bat[:oid,:dbl]
address CMDbatDIVcstsignal
comment "Return V / B, signal error on overflow";
pattern div_noerror(v:dbl,b:bat[:oid,:lng]) :bat[:oid,:dbl]
address CMDbatDIVcst
comment "Return V / B, overflow causes NIL value";

command /(b1:bat[:oid,:dbl],b2:bat[:oid,:flt]) :bat[:oid,:dbl]
address CMDbatDIVsignal
comment "Return B1 / B2, signal error on overflow";
command /(b1:bat[:oid,:dbl],b2:bat[:oid,:flt],accum:int) :bat[:oid,:dbl]
address CMDbatDIVsignalaccum
comment "Return B1 / B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command div_noerror(b1:bat[:oid,:dbl],b2:bat[:oid,:flt]) :bat[:oid,:dbl]
address CMDbatDIV
comment "Return B1 / B2, overflow causes NIL value";
pattern /(b:bat[:oid,:dbl],v:flt) :bat[:oid,:dbl]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow";
pattern /(b:bat[:oid,:dbl],v:flt,accum:int) :bat[:oid,:dbl]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow, reuse B if ACCUM is set";
pattern div_noerror(b:bat[:oid,:dbl],v:flt) :bat[:oid,:dbl]
address CMDbatDIVcst
comment "Return B / V, overflow causes NIL value";
pattern /(v:dbl,b:bat[:oid,:flt]) :bat[:oid,:dbl]
address CMDbatDIVcstsignal
comment "Return V / B, signal error on overflow";
pattern div_noerror(v:dbl,b:bat[:oid,:flt]) :bat[:oid,:dbl]
address CMDbatDIVcst
comment "Return V / B, overflow causes NIL value";

command /(b1:bat[:oid,:dbl],b2:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatDIVsignal
comment "Return B1 / B2, signal error on overflow";
command /(b1:bat[:oid,:dbl],b2:bat[:oid,:dbl],accum:int) :bat[:oid,:dbl]
address CMDbatDIVsignalaccum
comment "Return B1 / B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command div_noerror(b1:bat[:oid,:dbl],b2:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatDIV
comment "Return B1 / B2, overflow causes NIL value";
pattern /(b:bat[:oid,:dbl],v:dbl) :bat[:oid,:dbl]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow";
pattern /(b:bat[:oid,:dbl],v:dbl,accum:int) :bat[:oid,:dbl]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow, reuse B if ACCUM is set";
pattern div_noerror(b:bat[:oid,:dbl],v:dbl) :bat[:oid,:dbl]
address CMDbatDIVcst
comment "Return B / V, overflow causes NIL value";
pattern /(v:dbl,b:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatDIVcstsignal
comment "Return V / B, signal error on overflow";
pattern /(v:dbl,b:bat[:oid,:dbl],accum:int) :bat[:oid,:dbl]
address CMDbatDIVcstsignal
comment "Return V / B, signal error on overflow, reuse B if ACCUM is set";
pattern div_noerror(v:dbl,b:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatDIVcst
comment "Return V / B, overflow causes NIL value";


command %(b1:bat[:oid,:bte],b2:bat[:oid,:bte]) :bat[:oid,:bte]
address CMDbatMODsignal
comment "Return B1 % B2, signal error on divide by zero";
command %(b1:bat[:oid,:bte],b2:bat[:oid,:bte],accum:int) :bat[:oid,:bte]
address CMDbatMODsignalaccum
comment "Return B1 % B2, signal error on divide by zero, reuse B1 or B2 depending on ACCUM";
command mod_noerror(b1:bat[:oid,:bte],b2:bat[:oid,:bte]) :bat[:oid,:bte]
address CMDbatMOD
comment "Return B1 % B2, divide by zero causes NIL value";
pattern %(b:bat[:oid,:bte],v:bte) :bat[:oid,:bte]
address CMDbatMODcstsignal
comment "Return B % V, signal error on divide by zero";
pattern %(b:bat[:oid,:bte],v:bte,accum:int) :bat[:oid,:bte]
address CMDbatMODcstsignal
comment "Return B % V, signal error on divide by zero, reuse B if ACCUM is set";
pattern mod_noerror(b:bat[:oid,:bte],v:bte) :bat[:oid,:bte]
address CMDbatMODcst
comment "Return B % V, divide by zero causes NIL value";
pattern %(v:bte,b:bat[:oid,:bte]) :bat[:oid,:bte]
address CMDbatMODcstsignal
comment "Return V % B, signal error on divide by zero";
pattern %(v:bte,b:bat[:oid,:bte],accum:int) :bat[:oid,:bte]
address CMDbatMODcstsignal
comment "Return V % B, signal error on divide by zero, reuse B if ACCUM is set";
pattern mod_noerror(v:bte,b:bat[:oid,:bte]) :bat[:oid,:bte]
address CMDbatMODcst
comment "Return V % B, divide by zero causes NIL value";

command %(b1:bat[:oid,:bte],b2:bat[:oid,:sht]) :bat[:oid,:bte]
address CMDbatMODsignal
comment "Return B1 % B2, signal error on divide by zero";
command %(b1:bat[:oid,:bte],b2:bat[:oid,:sht],accum:int) :bat[:oid,:bte]
address CMDbatMODsignalaccum
comment "Return B1 % B2, signal error on divide by zero, reuse B1 or B2 depending on ACCUM";
command mod_noerror(b1:bat[:oid,:bte],b2:bat[:oid,:sht]) :bat[:oid,:bte]
address CMDbatMOD
comment "Return B1 % B2, divide by zero causes NIL value";
pattern %(b:bat[:oid,:bte],v:sht) :bat[:oid,:bte]
address CMDbatMODcstsignal
comment "Return B % V, signal error on divide by zero";
pattern %(b:bat[:oid,:bte],v:sht,accum:int) :bat[:oid,:bte]
address CMDbatMODcstsignal
comment "Return B % V, signal error on divide by zero, reuse B if ACCUM is set";
pattern mod_noerror(b:bat[:oid,:bte],v:sht) :bat[:oid,:bte]
address CMDbatMODcst
comment "Return B % V, divide by zero causes NIL value";
pattern %(v:bte,b:bat[:oid,:sht]) :bat[:oid,:bte]
address CMDbatMODcstsignal
comment "Return V % B, signal error on divide by zero";
pattern mod_noerror(v:bte,b:bat[:oid,:sht]) :bat[:oid,:bte]
address CMDbatMODcst
comment "Return V % B, divide by zero causes NIL value";

command %(b1:bat[:oid,:bte],b2:bat[:oid,:int]) :bat[:oid,:bte]
address CMDbatMODsignal
comment "Return B1 % B2, signal error on divide by zero";
command %(b1:bat[:oid,:bte],b2:bat[:oid,:int],accum:int) :bat[:oid,:bte]
address CMDbatMODsignalaccum
comment "Return B1 % B2, signal error on divide by zero, reuse B1 or B2 depending on ACCUM";
command mod_noerror(b1:bat[:oid,:bte],b2:bat[:oid,:int]) :bat[:oid,:bte]
address CMDbatMOD
comment "Return B1 % B2, divide by zero causes NIL value";
pattern %(b:bat[:oid,:bte],v:int) :bat[:oid,:bte]
address CMDbatMODcstsignal
comment "Return B % V, signal error on divide by zero";
pattern %(b:bat[:oid,:bte],v:int,accum:int) :bat[:oid,:bte]
address CMDbatMODcstsignal
comment "Return B % V, signal error on divide by zero, reuse B if ACCUM is set";
pattern mod_noerror(b:bat[:oid,:bte],v:int) :bat[:oid,:bte]
address CMDbatMODcst
comment "Return B % V, divide by zero causes NIL value";
pattern %(v:bte,b:bat[:oid,:int]) :bat[:oid,:bte]
address CMDbatMODcstsignal
comment "Return V % B, signal error on divide by zero";
pattern mod_noerror(v:bte,b:bat[:oid,:int]) :bat[:oid,:bte]
address CMDbatMODcst
comment "Return V % B, divide by zero causes NIL value";

command %(b1:bat[:oid,:bte],b2:bat[:oid,:wrd]) :bat[:oid,:bte]
address CMDbatMODsignal
comment "Return B1 % B2, signal error on divide by zero";
command %(b1:bat[:oid,:bte],b2:bat[:oid,:wrd],accum:int) :bat[:oid,:bte]
address CMDbatMODsignalaccum
comment "Return B1 % B2, signal error on divide by zero, reuse B1 or B2 depending on ACCUM";
command mod_noerror(b1:bat[:oid,:bte],b2:bat[:oid,:wrd]) :bat[:oid,:bte]
address CMDbatMOD
comment "Return B1 % B2, divide by zero causes NIL value";
pattern %(b:bat[:oid,:bte],v:wrd) :bat[:oid,:bte]
address CMDbatMODcstsignal
comment "Return B % V, signal error on divide by zero";
pattern %(b:bat[:oid,:bte],v:wrd,accum:int) :bat[:oid,:bte]
address CMDbatMODcstsignal
comment "Return B % V, signal error on divide by zero, reuse B if ACCUM is set";
pattern mod_noerror(b:bat[:oid,:bte],v:wrd) :bat[:oid,:bte]
address CMDbatMODcst
comment "Return B % V, divide by zero causes NIL value";
pattern %(v:bte,b:bat[:oid,:wrd]) :bat[:oid,:bte]
address CMDbatMODcstsignal
comment "Return V % B, signal error on divide by zero";
pattern mod_noerror(v:bte,b:bat[:oid,:wrd]) :bat[:oid,:bte]
address CMDbatMODcst
comment "Return V % B, divide by zero causes NIL value";

command %(b1:bat[:oid,:bte],b2:bat[:oid,:lng]) :bat[:oid,:bte]
address CMDbatMODsignal
comment "Return B1 % B2, signal error on divide by zero";
command %(b1:bat[:oid,:bte],b2:bat[:oid,:lng],accum:int) :bat[:oid,:bte]
address CMDbatMODsignalaccum
comment "Return B1 % B2, signal error on divide by zero, reuse B1 or B2 depending on ACCUM";
command mod_noerror(b1:bat[:oid,:bte],b2:bat[:oid,:lng]) :bat[:oid,:bte]
address CMDbatMOD
comment "Return B1 % B2, divide by zero causes NIL value";
pattern %(b:bat[:oid,:bte],v:lng) :bat[:oid,:bte]
address CMDbatMODcstsignal
comment "Return B % V, signal error on divide by zero";
pattern %(b:bat[:oid,:bte],v:lng,accum:int) :bat[:oid,:bte]
address CMDbatMODcstsignal
comment "Return B % V, signal error on divide by zero, reuse B if ACCUM is set";
pattern mod_noerror(b:bat[:oid,:bte],v:lng) :bat[:oid,:bte]
address CMDbatMODcst
comment "Return B % V, divide by zero causes NIL value";
pattern %(v:bte,b:bat[:oid,:lng]) :bat[:oid,:bte]
address CMDbatMODcstsignal
comment "Return V % B, signal error on divide by zero";
pattern mod_noerror(v:bte,b:bat[:oid,:lng]) :bat[:oid,:bte]
address CMDbatMODcst
comment "Return V % B, divide by zero causes NIL value";

command %(b1:bat[:oid,:sht],b2:bat[:oid,:bte]) :bat[:oid,:bte]
address CMDbatMODsignal
comment "Return B1 % B2, signal error on divide by zero";
command %(b1:bat[:oid,:sht],b2:bat[:oid,:bte],accum:int) :bat[:oid,:bte]
address CMDbatMODsignalaccum
comment "Return B1 % B2, signal error on divide by zero, reuse B1 or B2 depending on ACCUM";
command mod_noerror(b1:bat[:oid,:sht],b2:bat[:oid,:bte]) :bat[:oid,:bte]
address CMDbatMOD
comment "Return B1 % B2, divide by zero causes NIL value";
pattern %(b:bat[:oid,:sht],v:bte) :bat[:oid,:bte]
address CMDbatMODcstsignal
comment "Return B % V, signal error on divide by zero";
pattern mod_noerror(b:bat[:oid,:sht],v:bte) :bat[:oid,:bte]
address CMDbatMODcst
comment "Return B % V, divide by zero causes NIL value";
pattern %(v:sht,b:bat[:oid,:bte]) :bat[:oid,:bte]
address CMDbatMODcstsignal
comment "Return V % B, signal error on divide by zero";
pattern %(v:sht,b:bat[:oid,:bte],accum:int) :bat[:oid,:bte]
address CMDbatMODcstsignal
comment "Return V % B, signal error on divide by zero, reuse B if ACCUM is set";
pattern mod_noerror(v:sht,b:bat[:oid,:bte]) :bat[:oid,:bte]
address CMDbatMODcst
comment "Return V % B, divide by zero causes NIL value";

command %(b1:bat[:oid,:sht],b2:bat[:oid,:sht]) :bat[:oid,:sht]
address CMDbatMODsignal
comment "Return B1 % B2, signal error on divide by zero";
command %(b1:bat[:oid,:sht],b2:bat[:oid,:sht],accum:int) :bat[:oid,:sht]
address CMDbatMODsignalaccum
comment "Return B1 % B2, signal error on divide by zero, reuse B1 or B2 depending on ACCUM";
command mod_noerror(b1:bat[:oid,:sht],b2:bat[:oid,:sht]) :bat[:oid,:sht]
address CMDbatMOD
comment "Return B1 % B2, divide by zero causes NIL value";
pattern %(b:bat[:oid,:sht],v:sht) :bat[:oid,:sht]
address CMDbatMODcstsignal
comment "Return B % V, signal error on divide by zero";
pattern %(b:bat[:oid,:sht],v:sht,accum:int) :bat[:oid,:sht]
address CMDbatMODcstsignal
comment "Return B % V, signal error on divide by zero, reuse B if ACCUM is set";
pattern mod_noerror(b:bat[:oid,:sht],v:sht) :bat[:oid,:sht]
address CMDbatMODcst
comment "Return B % V, divide by zero causes NIL value";
pattern %(v:sht,b:bat[:oid,:sht]) :bat[:oid,:sht]
address CMDbatMODcstsignal
comment "Return V % B, signal error on divide by zero";
pattern %(v:sht,b:bat[:oid,:sht],accum:int) :bat[:oid,:sht]
address CMDbatMODcstsignal
comment "Return V % B, signal error on divide by zero, reuse B if ACCUM is set";
pattern mod_noerror(v:sht,b:bat[:oid,:sht]) :bat[:oid,:sht]
address CMDbatMODcst
comment "Return V % B, divide by zero causes NIL value";

command %(b1:bat[:oid,:sht],b2:bat[:oid,:int]) :bat[:oid,:sht]
address CMDbatMODsignal
comment "Return B1 % B2, signal error on divide by zero";
command %(b1:bat[:oid,:sht],b2:bat[:oid,:int],accum:int) :bat[:oid,:sht]
address CMDbatMODsignalaccum
comment "Return B1 % B2, signal error on divide by zero, reuse B1 or B2 depending on ACCUM";
command mod_noerror(b1:bat[:oid,:sht],b2:bat[:oid,:int]) :bat[:oid,:sht]
address CMDbatMOD
comment "Return B1 % B2, divide by zero causes NIL value";
pattern %(b:bat[:oid,:sht],v:int) :bat[:oid,:sht]
address CMDbatMODcstsignal
comment "Return B % V, signal error on divide by zero";
pattern %(b:bat[:oid,:sht],v:int,accum:int) :bat[:oid,:sht]
address CMDbatMODcstsignal
comment "Return B % V, signal error on divide by zero, reuse B if ACCUM is set";
pattern mod_noerror(b:bat[:oid,:sht],v:int) :bat[:oid,:sht]
address CMDbatMODcst
comment "Return B % V, divide by zero causes NIL value";
pattern %(v:sht,b:bat[:oid,:int]) :bat[:oid,:sht]
address CMDbatMODcstsignal
comment "Return V % B, signal error on divide by zero";
pattern mod_noerror(v:sht,b:bat[:oid,:int]) :bat[:oid,:sht]
address CMDbatMODcst
comment "Return V % B, divide by zero causes NIL value";

command %(b1:bat[:oid,:sht],b2:bat[:oid,:wrd]) :bat[:oid,:sht]
address CMDbatMODsignal
comment "Return B1 % B2, signal error on divide by zero";
command %(b1:bat[:oid,:sht],b2:bat[:oid,:wrd],accum:int) :bat[:oid,:sht]
address CMDbatMODsignalaccum
comment "Return B1 % B2, signal error on divide by zero, reuse B1 or B2 depending on ACCUM";
command mod_noerror(b1:bat[:oid,:sht],b2:bat[:oid,:wrd]) :bat[:oid,:sht]
address CMDbatMOD
comment "Return B1 % B2, divide by zero causes NIL value";
pattern %(b:bat[:oid,:sht],v:wrd) :bat[:oid,:sht]
address CMDbatMODcstsignal
comment "Return B % V, signal error on divide by zero";
pattern %(b:bat[:oid,:sht],v:wrd,accum:int) :bat[:oid,:sht]
address CMDbatMODcstsignal
comment "Return B % V, signal error on divide by zero, reuse B if ACCUM is set";
pattern mod_noerror(b:bat[:oid,:sht],v:wrd) :bat[:oid,:sht]
address CMDbatMODcst
comment "Return B % V, divide by zero causes NIL value";
pattern %(v:sht,b:bat[:oid,:wrd]) :bat[:oid,:sht]
address CMDbatMODcstsignal
comment "Return V % B, signal error on divide by zero";
pattern mod_noerror(v:sht,b:bat[:oid,:wrd]) :bat[:oid,:sht]
address CMDbatMODcst
comment "Return V % B, divide by zero causes NIL value";

command %(b1:bat[:oid,:sht],b2:bat[:oid,:lng]) :bat[:oid,:sht]
address CMDbatMODsignal
comment "Return B1 % B2, signal error on divide by zero";
command %(b1:bat[:oid,:sht],b2:bat[:oid,:lng],accum:int) :bat[:oid,:sht]
address CMDbatMODsignalaccum
comment "Return B1 % B2, signal error on divide by zero, reuse B1 or B2 depending on ACCUM";
command mod_noerror(b1:bat[:oid,:sht],b2:bat[:oid,:lng]) :bat[:oid,:sht]
address CMDbatMOD
comment "Return B1 % B2, divide by zero causes NIL value";
pattern %(b:bat[:oid,:sht],v:lng) :bat[:oid,:sht]
address CMDbatMODcstsignal
comment "Return B % V, signal error on divide by zero";
pattern %(b:bat[:oid,:sht],v:lng,accum:int) :bat[:oid,:sht]
address CMDbatMODcstsignal
comment "Return B % V, signal error on divide by zero, reuse B if ACCUM is set";
pattern mod_noerror(b:bat[:oid,:sht],v:lng) :bat[:oid,:sht]
address CMDbatMODcst
comment "Return B % V, divide by zero causes NIL value";
pattern %(v:sht,b:bat[:oid,:lng]) :bat[:oid,:sht]
address CMDbatMODcstsignal
comment "Return V % B, signal error on divide by zero";
pattern mod_noerror(v:sht,b:bat[:oid,:lng]) :bat[:oid,:sht]
address CMDbatMODcst
comment "Return V % B, divide by zero causes NIL value";

command %(b1:bat[:oid,:int],b2:bat[:oid,:bte]) :bat[:oid,:bte]
address CMDbatMODsignal
comment "Return B1 % B2, signal error on divide by zero";
command %(b1:bat[:oid,:int],b2:bat[:oid,:bte],accum:int) :bat[:oid,:bte]
address CMDbatMODsignalaccum
comment "Return B1 % B2, signal error on divide by zero, reuse B1 or B2 depending on ACCUM";
command mod_noerror(b1:bat[:oid,:int],b2:bat[:oid,:bte]) :bat[:oid,:bte]
address CMDbatMOD
comment "Return B1 % B2, divide by zero causes NIL value";
pattern %(b:bat[:oid,:int],v:bte) :bat[:oid,:bte]
address CMDbatMODcstsignal
comment "Return B % V, signal error on divide by zero";
pattern mod_noerror(b:bat[:oid,:int],v:bte) :bat[:oid,:bte]
address CMDbatMODcst
comment "Return B % V, divide by zero causes NIL value";
pattern %(v:int,b:bat[:oid,:bte]) :bat[:oid,:bte]
address CMDbatMODcstsignal
comment "Return V % B, signal error on divide by zero";
pattern %(v:int,b:bat[:oid,:bte],accum:int) :bat[:oid,:bte]
address CMDbatMODcstsignal
comment "Return V % B, signal error on divide by zero, reuse B if ACCUM is set";
pattern mod_noerror(v:int,b:bat[:oid,:bte]) :bat[:oid,:bte]
address CMDbatMODcst
comment "Return V % B, divide by zero causes NIL value";

command %(b1:bat[:oid,:int],b2:bat[:oid,:sht]) :bat[:oid,:sht]
address CMDbatMODsignal
comment "Return B1 % B2, signal error on divide by zero";
command %(b1:bat[:oid,:int],b2:bat[:oid,:sht],accum:int) :bat[:oid,:sht]
address CMDbatMODsignalaccum
comment "Return B1 % B2, signal error on divide by zero, reuse B1 or B2 depending on ACCUM";
command mod_noerror(b1:bat[:oid,:int],b2:bat[:oid,:sht]) :bat[:oid,:sht]
address CMDbatMOD
comment "Return B1 % B2, divide by zero causes NIL value";
pattern %(b:bat[:oid,:int],v:sht) :bat[:oid,:sht]
address CMDbatMODcstsignal
comment "Return B % V, signal error on divide by zero";
pattern mod_noerror(b:bat[:oid,:int],v:sht) :bat[:oid,:sht]
address CMDbatMODcst
comment "Return B % V, divide by zero causes NIL value";
pattern %(v:int,b:bat[:oid,:sht]) :bat[:oid,:sht]
address CMDbatMODcstsignal
comment "Return V % B, signal error on divide by zero";
pattern %(v:int,b:bat[:oid,:sht],accum:int) :bat[:oid,:sht]
address CMDbatMODcstsignal
comment "Return V % B, signal error on divide by zero, reuse B if ACCUM is set";
pattern mod_noerror(v:int,b:bat[:oid,:sht]) :bat[:oid,:sht]
address CMDbatMODcst
comment "Return V % B, divide by zero causes NIL value";

command %(b1:bat[:oid,:int],b2:bat[:oid,:int]) :bat[:oid,:int]
address CMDbatMODsignal
comment "Return B1 % B2, signal error on divide by zero";
command %(b1:bat[:oid,:int],b2:bat[:oid,:int],accum:int) :bat[:oid,:int]
address CMDbatMODsignalaccum
comment "Return B1 % B2, signal error on divide by zero, reuse B1 or B2 depending on ACCUM";
command mod_noerror(b1:bat[:oid,:int],b2:bat[:oid,:int]) :bat[:oid,:int]
address CMDbatMOD
comment "Return B1 % B2, divide by zero causes NIL value";
pattern %(b:bat[:oid,:int],v:int) :bat[:oid,:int]
address CMDbatMODcstsignal
comment "Return B % V, signal error on divide by zero";
pattern %(b:bat[:oid,:int],v:int,accum:int) :bat[:oid,:int]
address CMDbatMODcstsignal
comment "Return B % V, signal error on divide by zero, reuse B if ACCUM is set";
pattern mod_noerror(b:bat[:oid,:int],v:int) :bat[:oid,:int]
address CMDbatMODcst
comment "Return B % V, divide by zero causes NIL value";
pattern %(v:int,b:bat[:oid,:int]) :bat[:oid,:int]
address CMDbatMODcstsignal
comment "Return V % B, signal error on divide by zero";
pattern %(v:int,b:bat[:oid,:int],accum:int) :bat[:oid,:int]
address CMDbatMODcstsignal
comment "Return V % B, signal error on divide by zero, reuse B if ACCUM is set";
pattern mod_noerror(v:int,b:bat[:oid,:int]) :bat[:oid,:int]
address CMDbatMODcst
comment "Return V % B, divide by zero causes NIL value";

command %(b1:bat[:oid,:int],b2:bat[:oid,:wrd]) :bat[:oid,:int]
address CMDbatMODsignal
comment "Return B1 % B2, signal error on divide by zero";
command %(b1:bat[:oid,:int],b2:bat[:oid,:wrd],accum:int) :bat[:oid,:int]
address CMDbatMODsignalaccum
comment "Return B1 % B2, signal error on divide by zero, reuse B1 or B2 depending on ACCUM";
command mod_noerror(b1:bat[:oid,:int],b2:bat[:oid,:wrd]) :bat[:oid,:int]
address CMDbatMOD
comment "Return B1 % B2, divide by zero causes NIL value";
pattern %(b:bat[:oid,:int],v:wrd) :bat[:oid,:int]
address CMDbatMODcstsignal
comment "Return B % V, signal error on divide by zero";
pattern %(b:bat[:oid,:int],v:wrd,accum:int) :bat[:oid,:int]
address CMDbatMODcstsignal
comment "Return B % V, signal error on divide by zero, reuse B if ACCUM is set";
pattern mod_noerror(b:bat[:oid,:int],v:wrd) :bat[:oid,:int]
address CMDbatMODcst
comment "Return B % V, divide by zero causes NIL value";
pattern %(v:int,b:bat[:oid,:wrd]) :bat[:oid,:int]
address CMDbatMODcstsignal
comment "Return V % B, signal error on divide by zero";
pattern mod_noerror(v:int,b:bat[:oid,:wrd]) :bat[:oid,:int]
address CMDbatMODcst
comment "Return V % B, divide by zero causes NIL value";

command %(b1:bat[:oid,:int],b2:bat[:oid,:lng]) :bat[:oid,:int]
address CMDbatMODsignal
comment "Return B1 % B2, signal error on divide by zero";
command %(b1:bat[:oid,:int],b2:bat[:oid,:lng],accum:int) :bat[:oid,:int]
address CMDbatMODsignalaccum
comment "Return B1 % B2, signal error on divide by zero, reuse B1 or B2 depending on ACCUM";
command mod_noerror(b1:bat[:oid,:int],b2:bat[:oid,:lng]) :bat[:oid,:int]
address CMDbatMOD
comment "Return B1 % B2, divide by zero causes NIL value";
pattern %(b:bat[:oid,:int],v:lng) :bat[:oid,:int]
address CMDbatMODcstsignal
comment "Return B % V, signal error on divide by zero";
pattern %(b:bat[:oid,:int],v:lng,accum:int) :bat[:oid,:int]
address CMDbatMODcstsignal
comment "Return B % V, signal error on divide by zero, reuse B if ACCUM is set";
pattern mod_noerror(b:bat[:oid,:int],v:lng) :bat[:oid,:int]
address CMDbatMODcst
comment "Return B % V, divide by zero causes NIL value";
pattern %(v:int,b:bat[:oid,:lng]) :bat[:oid,:int]
address CMDbatMODcstsignal
comment "Return V % B, signal error on divide by zero";
pattern mod_noerror(v:int,b:bat[:oid,:lng]) :bat[:oid,:int]
address CMDbatMODcst
comment "Return V % B, divide by zero causes NIL value";

command %(b1:bat[:oid,:wrd],b2:bat[:oid,:bte]) :bat[:oid,:bte]
address CMDbatMODsignal
comment "Return B1 % B2, signal error on divide by zero";
command %(b1:bat[:oid,:wrd],b2:bat[:oid,:bte],accum:int) :bat[:oid,:bte]
address CMDbatMODsignalaccum
comment "Return B1 % B2, signal error on divide by zero, reuse B1 or B2 depending on ACCUM";
command mod_noerror(b1:bat[:oid,:wrd],b2:bat[:oid,:bte]) :bat[:oid,:bte]
address CMDbatMOD
comment "Return B1 % B2, divide by zero causes NIL value";
pattern %(b:bat[:oid,:wrd],v:bte) :bat[:oid,:bte]
address CMDbatMODcstsignal
comment "Return B % V, signal error on divide by zero";
pattern mod_noerror(b:bat[:oid,:wrd],v:bte) :bat[:oid,:bte]
address CMDbatMODcst
comment "Return B % V, divide by zero causes NIL value";
pattern %(v:wrd,b:bat[:oid,:bte]) :bat[:oid,:bte]
address CMDbatMODcstsignal
comment "Return V % B, signal error on divide by zero";
pattern %(v:wrd,b:bat[:oid,:bte],accum:int) :bat[:oid,:bte]
address CMDbatMODcstsignal
comment "Return V % B, signal error on divide by zero, reuse B if ACCUM is set";
pattern mod_noerror(v:wrd,b:bat[:oid,:bte]) :bat[:oid,:bte]
address CMDbatMODcst
comment "Return V % B, divide by zero causes NIL value";

command %(b1:bat[:oid,:wrd],b2:bat[:oid,:sht]) :bat[:oid,:sht]
address CMDbatMODsignal
comment "Return B1 % B2, signal error on divide by zero";
command %(b1:bat[:oid,:wrd],b2:bat[:oid,:sht],accum:int) :bat[:oid,:sht]
address CMDbatMODsignalaccum
comment "Return B1 % B2, signal error on divide by zero, reuse B1 or B2 depending on ACCUM";
command mod_noerror(b1:bat[:oid,:wrd],b2:bat[:oid,:sht]) :bat[:oid,:sht]
address CMDbatMOD
comment "Return B1 % B2, divide by zero causes NIL value";
pattern %(b:bat[:oid,:wrd],v:sht) :bat[:oid,:sht]
address CMDbatMODcstsignal
comment "Return B % V, signal error on divide by zero";
pattern mod_noerror(b:bat[:oid,:wrd],v:sht) :bat[:oid,:sht]
address CMDbatMODcst
comment "Return B % V, divide by zero causes NIL value";
pattern %(v:wrd,b:bat[:oid,:sht]) :bat[:oid,:sht]
address CMDbatMODcstsignal
comment "Return V % B, signal error on divide by zero";
pattern %(v:wrd,b:bat[:oid,:sht],accum:int) :bat[:oid,:sht]
address CMDbatMODcstsignal
comment "Return V % B, signal error on divide by zero, reuse B if ACCUM is set";
pattern mod_noerror(v:wrd,b:bat[:oid,:sht]) :bat[:oid,:sht]
address CMDbatMODcst
comment "Return V % B, divide by zero causes NIL value";

command %(b1:bat[:oid,:wrd],b2:bat[:oid,:int]) :bat[:oid,:int]
address CMDbatMODsignal
comment "Return B1 % B2, signal error on divide by zero";
command %(b1:bat[:oid,:wrd],b2:bat[:oid,:int],accum:int) :bat[:oid,:int]
address CMDbatMODsignalaccum
comment "Return B1 % B2, signal error on divide by zero, reuse B1 or B2 depending on ACCUM";
command mod_noerror(b1:bat[:oid,:wrd],b2:bat[:oid,:int]) :bat[:oid,:int]
address CMDbatMOD
comment "Return B1 % B2, divide by zero causes NIL value";
pattern %(b:bat[:oid,:wrd],v:int) :bat[:oid,:int]
address CMDbatMODcstsignal
comment "Return B % V, signal error on divide by zero";
pattern mod_noerror(b:bat[:oid,:wrd],v:int) :bat[:oid,:int]
address CMDbatMODcst
comment "Return B % V, divide by zero causes NIL value";
pattern %(v:wrd,b:bat[:oid,:int]) :bat[:oid,:int]
address CMDbatMODcstsignal
comment "Return V % B, signal error on divide by zero";
pattern %(v:wrd,b:bat[:oid,:int],accum:int) :bat[:oid,:int]
address CMDbatMODcstsignal
comment "Return V % B, signal error on divide by zero, reuse B if ACCUM is set";
pattern mod_noerror(v:wrd,b:bat[:oid,:int]) :bat[:oid,:int]
address CMDbatMODcst
comment "Return V % B, divide by zero causes NIL value";

command %(b1:bat[:oid,:wrd],b2:bat[:oid,:wrd]) :bat[:oid,:wrd]
address CMDbatMODsignal
comment "Return B1 % B2, signal error on divide by zero";
command %(b1:bat[:oid,:wrd],b2:bat[:oid,:wrd],accum:int) :bat[:oid,:wrd]
address CMDbatMODsignalaccum
comment "Return B1 % B2, signal error on divide by zero, reuse B1 or B2 depending on ACCUM";
command mod_noerror(b1:bat[:oid,:wrd],b2:bat[:oid,:wrd]) :bat[:oid,:wrd]
address CMDbatMOD
comment "Return B1 % B2, divide by zero causes NIL value";
pattern %(b:bat[:oid,:wrd],v:wrd) :bat[:oid,:wrd]
address CMDbatMODcstsignal
comment "Return B % V, signal error on divide by zero";
pattern %(b:bat[:oid,:wrd],v:wrd,accum:int) :bat[:oid,:wrd]
address CMDbatMODcstsignal
comment "Return B % V, signal error on divide by zero, reuse B if ACCUM is set";
pattern mod_noerror(b:bat[:oid,:wrd],v:wrd) :bat[:oid,:wrd]
address CMDbatMODcst
comment "Return B % V, divide by zero causes NIL value";
pattern %(v:wrd,b:bat[:oid,:wrd]) :bat[:oid,:wrd]
address CMDbatMODcstsignal
comment "Return V % B, signal error on divide by zero";
pattern %(v:wrd,b:bat[:oid,:wrd],accum:int) :bat[:oid,:wrd]
address CMDbatMODcstsignal
comment "Return V % B, signal error on divide by zero, reuse B if ACCUM is set";
pattern mod_noerror(v:wrd,b:bat[:oid,:wrd]) :bat[:oid,:wrd]
address CMDbatMODcst
comment "Return V % B, divide by zero causes NIL value";

command %(b1:bat[:oid,:wrd],b2:bat[:oid,:lng]) :bat[:oid,:wrd]
address CMDbatMODsignal
comment "Return B1 % B2, signal error on divide by zero";
command %(b1:bat[:oid,:wrd],b2:bat[:oid,:lng],accum:int) :bat[:oid,:wrd]
address CMDbatMODsignalaccum
comment "Return B1 % B2, signal error on divide by zero, reuse B1 or B2 depending on ACCUM";
command mod_noerror(b1:bat[:oid,:wrd],b2:bat[:oid,:lng]) :bat[:oid,:wrd]
address CMDbatMOD
comment "Return B1 % B2, divide by zero causes NIL value";
pattern %(b:bat[:oid,:wrd],v:lng) :bat[:oid,:wrd]
address CMDbatMODcstsignal
comment "Return B % V, signal error on divide by zero";
pattern %(b:bat[:oid,:wrd],v:lng,accum:int) :bat[:oid,:wrd]
address CMDbatMODcstsignal
comment "Return B % V, signal error on divide by zero, reuse B if ACCUM is set";
pattern mod_noerror(b:bat[:oid,:wrd],v:lng) :bat[:oid,:wrd]
address CMDbatMODcst
comment "Return B % V, divide by zero causes NIL value";
pattern %(v:wrd,b:bat[:oid,:lng]) :bat[:oid,:wrd]
address CMDbatMODcstsignal
comment "Return V % B, signal error on divide by zero";
pattern mod_noerror(v:wrd,b:bat[:oid,:lng]) :bat[:oid,:wrd]
address CMDbatMODcst
comment "Return V % B, divide by zero causes NIL value";

command %(b1:bat[:oid,:lng],b2:bat[:oid,:bte]) :bat[:oid,:bte]
address CMDbatMODsignal
comment "Return B1 % B2, signal error on divide by zero";
command %(b1:bat[:oid,:lng],b2:bat[:oid,:bte],accum:int) :bat[:oid,:bte]
address CMDbatMODsignalaccum
comment "Return B1 % B2, signal error on divide by zero, reuse B1 or B2 depending on ACCUM";
command mod_noerror(b1:bat[:oid,:lng],b2:bat[:oid,:bte]) :bat[:oid,:bte]
address CMDbatMOD
comment "Return B1 % B2, divide by zero causes NIL value";
pattern %(b:bat[:oid,:lng],v:bte) :bat[:oid,:bte]
address CMDbatMODcstsignal
comment "Return B % V, signal error on divide by zero";
pattern mod_noerror(b:bat[:oid,:lng],v:bte) :bat[:oid,:bte]
address CMDbatMODcst
comment "Return B % V, divide by zero causes NIL value";
pattern %(v:lng,b:bat[:oid,:bte]) :bat[:oid,:bte]
address CMDbatMODcstsignal
comment "Return V % B, signal error on divide by zero";
pattern %(v:lng,b:bat[:oid,:bte],accum:int) :bat[:oid,:bte]
address CMDbatMODcstsignal
comment "Return V % B, signal error on divide by zero, reuse B if ACCUM is set";
pattern mod_noerror(v:lng,b:bat[:oid,:bte]) :bat[:oid,:bte]
address CMDbatMODcst
comment "Return V % B, divide by zero causes NIL value";

command %(b1:bat[:oid,:lng],b2:bat[:oid,:sht]) :bat[:oid,:sht]
address CMDbatMODsignal
comment "Return B1 % B2, signal error on divide by zero";
command %(b1:bat[:oid,:lng],b2:bat[:oid,:sht],accum:int) :bat[:oid,:sht]
address CMDbatMODsignalaccum
comment "Return B1 % B2, signal error on divide by zero, reuse B1 or B2 depending on ACCUM";
command mod_noerror(b1:bat[:oid,:lng],b2:bat[:oid,:sht]) :bat[:oid,:sht]
address CMDbatMOD
comment "Return B1 % B2, divide by zero causes NIL value";
pattern %(b:bat[:oid,:lng],v:sht) :bat[:oid,:sht]
address CMDbatMODcstsignal
comment "Return B % V, signal error on divide by zero";
pattern mod_noerror(b:bat[:oid,:lng],v:sht) :bat[:oid,:sht]
address CMDbatMODcst
comment "Return B % V, divide by zero causes NIL value";
pattern %(v:lng,b:bat[:oid,:sht]) :bat[:oid,:sht]
address CMDbatMODcstsignal
comment "Return V % B, signal error on divide by zero";
pattern %(v:lng,b:bat[:oid,:sht],accum:int) :bat[:oid,:sht]
address CMDbatMODcstsignal
comment "Return V % B, signal error on divide by zero, reuse B if ACCUM is set";
pattern mod_noerror(v:lng,b:bat[:oid,:sht]) :bat[:oid,:sht]
address CMDbatMODcst
comment "Return V % B, divide by zero causes NIL value";

command %(b1:bat[:oid,:lng],b2:bat[:oid,:int]) :bat[:oid,:int]
address CMDbatMODsignal
comment "Return B1 % B2, signal error on divide by zero";
command %(b1:bat[:oid,:lng],b2:bat[:oid,:int],accum:int) :bat[:oid,:int]
address CMDbatMODsignalaccum
comment "Return B1 % B2, signal error on divide by zero, reuse B1 or B2 depending on ACCUM";
command mod_noerror(b1:bat[:oid,:lng],b2:bat[:oid,:int]) :bat[:oid,:int]
address CMDbatMOD
comment "Return B1 % B2, divide by zero causes NIL value";
pattern %(b:bat[:oid,:lng],v:int) :bat[:oid,:int]
address CMDbatMODcstsignal
comment "Return B % V, signal error on divide by zero";
pattern mod_noerror(b:bat[:oid,:lng],v:int) :bat[:oid,:int]
address CMDbatMODcst
comment "Return B % V, divide by zero causes NIL value";
pattern %(v:lng,b:bat[:oid,:int]) :bat[:oid,:int]
address CMDbatMODcstsignal
comment "Return V % B, signal error on divide by zero";
pattern %(v:lng,b:bat[:oid,:int],accum:int) :bat[:oid,:int]
address CMDbatMODcstsignal
comment "Return V % B, signal error on divide by zero, reuse B if ACCUM is set";
pattern mod_noerror(v:lng,b:bat[:oid,:int]) :bat[:oid,:int]
address CMDbatMODcst
comment "Return V % B, divide by zero causes NIL value";

command %(b1:bat[:oid,:lng],b2:bat[:oid,:wrd]) :bat[:oid,:wrd]
address CMDbatMODsignal
comment "Return B1 % B2, signal error on divide by zero";
command %(b1:bat[:oid,:lng],b2:bat[:oid,:wrd],accum:int) :bat[:oid,:wrd]
address CMDbatMODsignalaccum
comment "Return B1 % B2, signal error on divide by zero, reuse B1 or B2 depending on ACCUM";
command mod_noerror(b1:bat[:oid,:lng],b2:bat[:oid,:wrd]) :bat[:oid,:wrd]
address CMDbatMOD
comment "Return B1 % B2, divide by zero causes NIL value";
pattern %(b:bat[:oid,:lng],v:wrd) :bat[:oid,:wrd]
address CMDbatMODcstsignal
comment "Return B % V, signal error on divide by zero";
pattern mod_noerror(b:bat[:oid,:lng],v:wrd) :bat[:oid,:wrd]
address CMDbatMODcst
comment "Return B % V, divide by zero causes NIL value";
pattern %(v:lng,b:bat[:oid,:wrd]) :bat[:oid,:wrd]
address CMDbatMODcstsignal
comment "Return V % B, signal error on divide by zero";
pattern %(v:lng,b:bat[:oid,:wrd],accum:int) :bat[:oid,:wrd]
address CMDbatMODcstsignal
comment "Return V % B, signal error on divide by zero, reuse B if ACCUM is set";
pattern mod_noerror(v:lng,b:bat[:oid,:wrd]) :bat[:oid,:wrd]
address CMDbatMODcst
comment "Return V % B, divide by zero causes NIL value";

command %(b1:bat[:oid,:lng],b2:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatMODsignal
comment "Return B1 % B2, signal error on divide by zero";
command %(b1:bat[:oid,:lng],b2:bat[:oid,:lng],accum:int) :bat[:oid,:lng]
address CMDbatMODsignalaccum
comment "Return B1 % B2, signal error on divide by zero, reuse B1 or B2 depending on ACCUM";
command mod_noerror(b1:bat[:oid,:lng],b2:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatMOD
comment "Return B1 % B2, divide by zero causes NIL value";
pattern %(b:bat[:oid,:lng],v:lng) :bat[:oid,:lng]
address CMDbatMODcstsignal
comment "Return B % V, signal error on divide by zero";
pattern %(b:bat[:oid,:lng],v:lng,accum:int) :bat[:oid,:lng]
address CMDbatMODcstsignal
comment "Return B % V, signal error on divide by zero, reuse B if ACCUM is set";
pattern mod_noerror(b:bat[:oid,:lng],v:lng) :bat[:oid,:lng]
address CMDbatMODcst
comment "Return B % V, divide by zero causes NIL value";
pattern %(v:lng,b:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatMODcstsignal
comment "Return V % B, signal error on divide by zero";
pattern %(v:lng,b:bat[:oid,:lng],accum:int) :bat[:oid,:lng]
address CMDbatMODcstsignal
comment "Return V % B, signal error on divide by zero, reuse B if ACCUM is set";
pattern mod_noerror(v:lng,b:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatMODcst
comment "Return V % B, divide by zero causes NIL value";


command and(b1:bat[:oid,:bit],b2:bat[:oid,:bit]) :bat[:oid,:bit]
address CMDbatAND
comment "Return B1 AND B2";
command and(b1:bat[:oid,:bit],b2:bat[:oid,:bit], accum:int) :bat[:oid,:bit]
address CMDbatANDaccum
comment "Return B1 AND B2";
pattern and(b:bat[:oid,:bit],v:bit) :bat[:oid,:bit]
address CMDbatANDcst
comment "Return B AND V";
pattern and(b:bat[:oid,:bit],v:bit,accum:int) :bat[:oid,:bit]
address CMDbatANDcst
comment "Return B AND V";
pattern and(v:bit,b:bat[:oid,:bit]) :bat[:oid,:bit]
address CMDbatANDcst
comment "Return V AND B";
pattern and(v:bit,b:bat[:oid,:bit],accum:int) :bat[:oid,:bit]
address CMDbatANDcst
comment "Return V AND B";

command and(b1:bat[:oid,:bte],b2:bat[:oid,:bte]) :bat[:oid,:bte]
address CMDbatAND
comment "Return B1 AND B2";
command and(b1:bat[:oid,:bte],b2:bat[:oid,:bte], accum:int) :bat[:oid,:bte]
address CMDbatANDaccum
comment "Return B1 AND B2";
pattern and(b:bat[:oid,:bte],v:bte) :bat[:oid,:bte]
address CMDbatANDcst
comment "Return B AND V";
pattern and(b:bat[:oid,:bte],v:bte,accum:int) :bat[:oid,:bte]
address CMDbatANDcst
comment "Return B AND V";
pattern and(v:bte,b:bat[:oid,:bte]) :bat[:oid,:bte]
address CMDbatANDcst
comment "Return V AND B";
pattern and(v:bte,b:bat[:oid,:bte],accum:int) :bat[:oid,:bte]
address CMDbatANDcst
comment "Return V AND B";

command and(b1:bat[:oid,:sht],b2:bat[:oid,:sht]) :bat[:oid,:sht]
address CMDbatAND
comment "Return B1 AND B2";
command and(b1:bat[:oid,:sht],b2:bat[:oid,:sht], accum:int) :bat[:oid,:sht]
address CMDbatANDaccum
comment "Return B1 AND B2";
pattern and(b:bat[:oid,:sht],v:sht) :bat[:oid,:sht]
address CMDbatANDcst
comment "Return B AND V";
pattern and(b:bat[:oid,:sht],v:sht,accum:int) :bat[:oid,:sht]
address CMDbatANDcst
comment "Return B AND V";
pattern and(v:sht,b:bat[:oid,:sht]) :bat[:oid,:sht]
address CMDbatANDcst
comment "Return V AND B";
pattern and(v:sht,b:bat[:oid,:sht],accum:int) :bat[:oid,:sht]
address CMDbatANDcst
comment "Return V AND B";

command and(b1:bat[:oid,:int],b2:bat[:oid,:int]) :bat[:oid,:int]
address CMDbatAND
comment "Return B1 AND B2";
command and(b1:bat[:oid,:int],b2:bat[:oid,:int], accum:int) :bat[:oid,:int]
address CMDbatANDaccum
comment "Return B1 AND B2";
pattern and(b:bat[:oid,:int],v:int) :bat[:oid,:int]
address CMDbatANDcst
comment "Return B AND V";
pattern and(b:bat[:oid,:int],v:int,accum:int) :bat[:oid,:int]
address CMDbatANDcst
comment "Return B AND V";
pattern and(v:int,b:bat[:oid,:int]) :bat[:oid,:int]
address CMDbatANDcst
comment "Return V AND B";
pattern and(v:int,b:bat[:oid,:int],accum:int) :bat[:oid,:int]
address CMDbatANDcst
comment "Return V AND B";

command and(b1:bat[:oid,:wrd],b2:bat[:oid,:wrd]) :bat[:oid,:wrd]
address CMDbatAND
comment "Return B1 AND B2";
command and(b1:bat[:oid,:wrd],b2:bat[:oid,:wrd], accum:int) :bat[:oid,:wrd]
address CMDbatANDaccum
comment "Return B1 AND B2";
pattern and(b:bat[:oid,:wrd],v:wrd) :bat[:oid,:wrd]
address CMDbatANDcst
comment "Return B AND V";
pattern and(b:bat[:oid,:wrd],v:wrd,accum:int) :bat[:oid,:wrd]
address CMDbatANDcst
comment "Return B AND V";
pattern and(v:wrd,b:bat[:oid,:wrd]) :bat[:oid,:wrd]
address CMDbatANDcst
comment "Return V AND B";
pattern and(v:wrd,b:bat[:oid,:wrd],accum:int) :bat[:oid,:wrd]
address CMDbatANDcst
comment "Return V AND B";

command and(b1:bat[:oid,:lng],b2:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatAND
comment "Return B1 AND B2";
command and(b1:bat[:oid,:lng],b2:bat[:oid,:lng], accum:int) :bat[:oid,:lng]
address CMDbatANDaccum
comment "Return B1 AND B2";
pattern and(b:bat[:oid,:lng],v:lng) :bat[:oid,:lng]
address CMDbatANDcst
comment "Return B AND V";
pattern and(b:bat[:oid,:lng],v:lng,accum:int) :bat[:oid,:lng]
address CMDbatANDcst
comment "Return B AND V";
pattern and(v:lng,b:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatANDcst
comment "Return V AND B";
pattern and(v:lng,b:bat[:oid,:lng],accum:int) :bat[:oid,:lng]
address CMDbatANDcst
comment "Return V AND B";


command or(b1:bat[:oid,:bit],b2:bat[:oid,:bit]) :bat[:oid,:bit]
address CMDbatOR
comment "Return B1 OR B2";
command or(b1:bat[:oid,:bit],b2:bat[:oid,:bit], accum:int) :bat[:oid,:bit]
address CMDbatORaccum
comment "Return B1 OR B2";
pattern or(b:bat[:oid,:bit],v:bit) :bat[:oid,:bit]
address CMDbatORcst
comment "Return B OR V";
pattern or(b:bat[:oid,:bit],v:bit,accum:int) :bat[:oid,:bit]
address CMDbatORcst
comment "Return B OR V";
pattern or(v:bit,b:bat[:oid,:bit]) :bat[:oid,:bit]
address CMDbatORcst
comment "Return V OR B";
pattern or(v:bit,b:bat[:oid,:bit],accum:int) :bat[:oid,:bit]
address CMDbatORcst
comment "Return V OR B";

command or(b1:bat[:oid,:bte],b2:bat[:oid,:bte]) :bat[:oid,:bte]
address CMDbatOR
comment "Return B1 OR B2";
command or(b1:bat[:oid,:bte],b2:bat[:oid,:bte], accum:int) :bat[:oid,:bte]
address CMDbatORaccum
comment "Return B1 OR B2";
pattern or(b:bat[:oid,:bte],v:bte) :bat[:oid,:bte]
address CMDbatORcst
comment "Return B OR V";
pattern or(b:bat[:oid,:bte],v:bte,accum:int) :bat[:oid,:bte]
address CMDbatORcst
comment "Return B OR V";
pattern or(v:bte,b:bat[:oid,:bte]) :bat[:oid,:bte]
address CMDbatORcst
comment "Return V OR B";
pattern or(v:bte,b:bat[:oid,:bte],accum:int) :bat[:oid,:bte]
address CMDbatORcst
comment "Return V OR B";

command or(b1:bat[:oid,:sht],b2:bat[:oid,:sht]) :bat[:oid,:sht]
address CMDbatOR
comment "Return B1 OR B2";
command or(b1:bat[:oid,:sht],b2:bat[:oid,:sht], accum:int) :bat[:oid,:sht]
address CMDbatORaccum
comment "Return B1 OR B2";
pattern or(b:bat[:oid,:sht],v:sht) :bat[:oid,:sht]
address CMDbatORcst
comment "Return B OR V";
pattern or(b:bat[:oid,:sht],v:sht,accum:int) :bat[:oid,:sht]
address CMDbatORcst
comment "Return B OR V";
pattern or(v:sht,b:bat[:oid,:sht]) :bat[:oid,:sht]
address CMDbatORcst
comment "Return V OR B";
pattern or(v:sht,b:bat[:oid,:sht],accum:int) :bat[:oid,:sht]
address CMDbatORcst
comment "Return V OR B";

command or(b1:bat[:oid,:int],b2:bat[:oid,:int]) :bat[:oid,:int]
address CMDbatOR
comment "Return B1 OR B2";
command or(b1:bat[:oid,:int],b2:bat[:oid,:int], accum:int) :bat[:oid,:int]
address CMDbatORaccum
comment "Return B1 OR B2";
pattern or(b:bat[:oid,:int],v:int) :bat[:oid,:int]
address CMDbatORcst
comment "Return B OR V";
pattern or(b:bat[:oid,:int],v:int,accum:int) :bat[:oid,:int]
address CMDbatORcst
comment "Return B OR V";
pattern or(v:int,b:bat[:oid,:int]) :bat[:oid,:int]
address CMDbatORcst
comment "Return V OR B";
pattern or(v:int,b:bat[:oid,:int],accum:int) :bat[:oid,:int]
address CMDbatORcst
comment "Return V OR B";

command or(b1:bat[:oid,:wrd],b2:bat[:oid,:wrd]) :bat[:oid,:wrd]
address CMDbatOR
comment "Return B1 OR B2";
command or(b1:bat[:oid,:wrd],b2:bat[:oid,:wrd], accum:int) :bat[:oid,:wrd]
address CMDbatORaccum
comment "Return B1 OR B2";
pattern or(b:bat[:oid,:wrd],v:wrd) :bat[:oid,:wrd]
address CMDbatORcst
comment "Return B OR V";
pattern or(b:bat[:oid,:wrd],v:wrd,accum:int) :bat[:oid,:wrd]
address CMDbatORcst
comment "Return B OR V";
pattern or(v:wrd,b:bat[:oid,:wrd]) :bat[:oid,:wrd]
address CMDbatORcst
comment "Return V OR B";
pattern or(v:wrd,b:bat[:oid,:wrd],accum:int) :bat[:oid,:wrd]
address CMDbatORcst
comment "Return V OR B";

command or(b1:bat[:oid,:lng],b2:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatOR
comment "Return B1 OR B2";
command or(b1:bat[:oid,:lng],b2:bat[:oid,:lng], accum:int) :bat[:oid,:lng]
address CMDbatORaccum
comment "Return B1 OR B2";
pattern or(b:bat[:oid,:lng],v:lng) :bat[:oid,:lng]
address CMDbatORcst
comment "Return B OR V";
pattern or(b:bat[:oid,:lng],v:lng,accum:int) :bat[:oid,:lng]
address CMDbatORcst
comment "Return B OR V";
pattern or(v:lng,b:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatORcst
comment "Return V OR B";
pattern or(v:lng,b:bat[:oid,:lng],accum:int) :bat[:oid,:lng]
address CMDbatORcst
comment "Return V OR B";


command xor(b1:bat[:oid,:bit],b2:bat[:oid,:bit]) :bat[:oid,:bit]
address CMDbatXOR
comment "Return B1 XOR B2";
command xor(b1:bat[:oid,:bit],b2:bat[:oid,:bit], accum:int) :bat[:oid,:bit]
address CMDbatXORaccum
comment "Return B1 XOR B2";
pattern xor(b:bat[:oid,:bit],v:bit) :bat[:oid,:bit]
address CMDbatXORcst
comment "Return B XOR V";
pattern xor(b:bat[:oid,:bit],v:bit,accum:int) :bat[:oid,:bit]
address CMDbatXORcst
comment "Return B XOR V";
pattern xor(v:bit,b:bat[:oid,:bit]) :bat[:oid,:bit]
address CMDbatXORcst
comment "Return V XOR B";
pattern xor(v:bit,b:bat[:oid,:bit],accum:int) :bat[:oid,:bit]
address CMDbatXORcst
comment "Return V XOR B";

command xor(b1:bat[:oid,:bte],b2:bat[:oid,:bte]) :bat[:oid,:bte]
address CMDbatXOR
comment "Return B1 XOR B2";
command xor(b1:bat[:oid,:bte],b2:bat[:oid,:bte], accum:int) :bat[:oid,:bte]
address CMDbatXORaccum
comment "Return B1 XOR B2";
pattern xor(b:bat[:oid,:bte],v:bte) :bat[:oid,:bte]
address CMDbatXORcst
comment "Return B XOR V";
pattern xor(b:bat[:oid,:bte],v:bte,accum:int) :bat[:oid,:bte]
address CMDbatXORcst
comment "Return B XOR V";
pattern xor(v:bte,b:bat[:oid,:bte]) :bat[:oid,:bte]
address CMDbatXORcst
comment "Return V XOR B";
pattern xor(v:bte,b:bat[:oid,:bte],accum:int) :bat[:oid,:bte]
address CMDbatXORcst
comment "Return V XOR B";

command xor(b1:bat[:oid,:sht],b2:bat[:oid,:sht]) :bat[:oid,:sht]
address CMDbatXOR
comment "Return B1 XOR B2";
command xor(b1:bat[:oid,:sht],b2:bat[:oid,:sht], accum:int) :bat[:oid,:sht]
address CMDbatXORaccum
comment "Return B1 XOR B2";
pattern xor(b:bat[:oid,:sht],v:sht) :bat[:oid,:sht]
address CMDbatXORcst
comment "Return B XOR V";
pattern xor(b:bat[:oid,:sht],v:sht,accum:int) :bat[:oid,:sht]
address CMDbatXORcst
comment "Return B XOR V";
pattern xor(v:sht,b:bat[:oid,:sht]) :bat[:oid,:sht]
address CMDbatXORcst
comment "Return V XOR B";
pattern xor(v:sht,b:bat[:oid,:sht],accum:int) :bat[:oid,:sht]
address CMDbatXORcst
comment "Return V XOR B";

command xor(b1:bat[:oid,:int],b2:bat[:oid,:int]) :bat[:oid,:int]
address CMDbatXOR
comment "Return B1 XOR B2";
command xor(b1:bat[:oid,:int],b2:bat[:oid,:int], accum:int) :bat[:oid,:int]
address CMDbatXORaccum
comment "Return B1 XOR B2";
pattern xor(b:bat[:oid,:int],v:int) :bat[:oid,:int]
address CMDbatXORcst
comment "Return B XOR V";
pattern xor(b:bat[:oid,:int],v:int,accum:int) :bat[:oid,:int]
address CMDbatXORcst
comment "Return B XOR V";
pattern xor(v:int,b:bat[:oid,:int]) :bat[:oid,:int]
address CMDbatXORcst
comment "Return V XOR B";
pattern xor(v:int,b:bat[:oid,:int],accum:int) :bat[:oid,:int]
address CMDbatXORcst
comment "Return V XOR B";

command xor(b1:bat[:oid,:wrd],b2:bat[:oid,:wrd]) :bat[:oid,:wrd]
address CMDbatXOR
comment "Return B1 XOR B2";
command xor(b1:bat[:oid,:wrd],b2:bat[:oid,:wrd], accum:int) :bat[:oid,:wrd]
address CMDbatXORaccum
comment "Return B1 XOR B2";
pattern xor(b:bat[:oid,:wrd],v:wrd) :bat[:oid,:wrd]
address CMDbatXORcst
comment "Return B XOR V";
pattern xor(b:bat[:oid,:wrd],v:wrd,accum:int) :bat[:oid,:wrd]
address CMDbatXORcst
comment "Return B XOR V";
pattern xor(v:wrd,b:bat[:oid,:wrd]) :bat[:oid,:wrd]
address CMDbatXORcst
comment "Return V XOR B";
pattern xor(v:wrd,b:bat[:oid,:wrd],accum:int) :bat[:oid,:wrd]
address CMDbatXORcst
comment "Return V XOR B";

command xor(b1:bat[:oid,:lng],b2:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatXOR
comment "Return B1 XOR B2";
command xor(b1:bat[:oid,:lng],b2:bat[:oid,:lng], accum:int) :bat[:oid,:lng]
address CMDbatXORaccum
comment "Return B1 XOR B2";
pattern xor(b:bat[:oid,:lng],v:lng) :bat[:oid,:lng]
address CMDbatXORcst
comment "Return B XOR V";
pattern xor(b:bat[:oid,:lng],v:lng,accum:int) :bat[:oid,:lng]
address CMDbatXORcst
comment "Return B XOR V";
pattern xor(v:lng,b:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatXORcst
comment "Return V XOR B";
pattern xor(v:lng,b:bat[:oid,:lng],accum:int) :bat[:oid,:lng]
address CMDbatXORcst
comment "Return V XOR B";


command <<(b1:bat[:oid,:bte],b2:bat[:oid,:bte]) :bat[:oid,:bte]
address CMDbatLSHsignal
comment "Return B1 << B2, raise error on out of range second operand";
command <<(b1:bat[:oid,:bte],b2:bat[:oid,:bte],accum:int) :bat[:oid,:bte]
address CMDbatLSHsignalaccum
comment "Return B1 << B2, raise error on out of range second operand, reuse B if ACCUM is set";
command lsh_noerror(b1:bat[:oid,:bte],b2:bat[:oid,:bte]) :bat[:oid,:bte]
address CMDbatLSH
comment "Return B1 << B2, out of range second operand causes NIL value";
pattern <<(b:bat[:oid,:bte],v:bte) :bat[:oid,:bte]
address CMDbatLSHcstsignal
comment "Return B << V, raise error on out of range second operand";
pattern <<(b:bat[:oid,:bte],v:bte,accum:int) :bat[:oid,:bte]
address CMDbatLSHcstsignal
comment "Return B << V, raise error on out of range second operand, reuse B if ACCUM is set";
pattern lsh_noerror(b:bat[:oid,:bte],v:bte) :bat[:oid,:bte]
address CMDbatLSHcst
comment "Return B << V, out of range second operand causes NIL value";
pattern <<(v:bte,b:bat[:oid,:bte]) :bat[:oid,:bte]
address CMDbatLSHcstsignal
comment "Return V << B, raise error on out of range second operand";
pattern lsh_noerror(v:bte,b:bat[:oid,:bte]) :bat[:oid,:bte]
address CMDbatLSHcst
comment "Return V << B, out of range second operand causes NIL value";

command <<(b1:bat[:oid,:bte],b2:bat[:oid,:sht]) :bat[:oid,:bte]
address CMDbatLSHsignal
comment "Return B1 << B2, raise error on out of range second operand";
command <<(b1:bat[:oid,:bte],b2:bat[:oid,:sht],accum:int) :bat[:oid,:bte]
address CMDbatLSHsignalaccum
comment "Return B1 << B2, raise error on out of range second operand, reuse B if ACCUM is set";
command lsh_noerror(b1:bat[:oid,:bte],b2:bat[:oid,:sht]) :bat[:oid,:bte]
address CMDbatLSH
comment "Return B1 << B2, out of range second operand causes NIL value";
pattern <<(b:bat[:oid,:bte],v:sht) :bat[:oid,:bte]
address CMDbatLSHcstsignal
comment "Return B << V, raise error on out of range second operand";
pattern <<(b:bat[:oid,:bte],v:sht,accum:int) :bat[:oid,:bte]
address CMDbatLSHcstsignal
comment "Return B << V, raise error on out of range second operand, reuse B if ACCUM is set";
pattern lsh_noerror(b:bat[:oid,:bte],v:sht) :bat[:oid,:bte]
address CMDbatLSHcst
comment "Return B << V, out of range second operand causes NIL value";
pattern <<(v:bte,b:bat[:oid,:sht]) :bat[:oid,:bte]
address CMDbatLSHcstsignal
comment "Return V << B, raise error on out of range second operand";
pattern lsh_noerror(v:bte,b:bat[:oid,:sht]) :bat[:oid,:bte]
address CMDbatLSHcst
comment "Return V << B, out of range second operand causes NIL value";

command <<(b1:bat[:oid,:bte],b2:bat[:oid,:int]) :bat[:oid,:bte]
address CMDbatLSHsignal
comment "Return B1 << B2, raise error on out of range second operand";
command <<(b1:bat[:oid,:bte],b2:bat[:oid,:int],accum:int) :bat[:oid,:bte]
address CMDbatLSHsignalaccum
comment "Return B1 << B2, raise error on out of range second operand, reuse B if ACCUM is set";
command lsh_noerror(b1:bat[:oid,:bte],b2:bat[:oid,:int]) :bat[:oid,:bte]
address CMDbatLSH
comment "Return B1 << B2, out of range second operand causes NIL value";
pattern <<(b:bat[:oid,:bte],v:int) :bat[:oid,:bte]
address CMDbatLSHcstsignal
comment "Return B << V, raise error on out of range second operand";
pattern <<(b:bat[:oid,:bte],v:int,accum:int) :bat[:oid,:bte]
address CMDbatLSHcstsignal
comment "Return B << V, raise error on out of range second operand, reuse B if ACCUM is set";
pattern lsh_noerror(b:bat[:oid,:bte],v:int) :bat[:oid,:bte]
address CMDbatLSHcst
comment "Return B << V, out of range second operand causes NIL value";
pattern <<(v:bte,b:bat[:oid,:int]) :bat[:oid,:bte]
address CMDbatLSHcstsignal
comment "Return V << B, raise error on out of range second operand";
pattern lsh_noerror(v:bte,b:bat[:oid,:int]) :bat[:oid,:bte]
address CMDbatLSHcst
comment "Return V << B, out of range second operand causes NIL value";

command <<(b1:bat[:oid,:bte],b2:bat[:oid,:wrd]) :bat[:oid,:bte]
address CMDbatLSHsignal
comment "Return B1 << B2, raise error on out of range second operand";
command <<(b1:bat[:oid,:bte],b2:bat[:oid,:wrd],accum:int) :bat[:oid,:bte]
address CMDbatLSHsignalaccum
comment "Return B1 << B2, raise error on out of range second operand, reuse B if ACCUM is set";
command lsh_noerror(b1:bat[:oid,:bte],b2:bat[:oid,:wrd]) :bat[:oid,:bte]
address CMDbatLSH
comment "Return B1 << B2, out of range second operand causes NIL value";
pattern <<(b:bat[:oid,:bte],v:wrd) :bat[:oid,:bte]
address CMDbatLSHcstsignal
comment "Return B << V, raise error on out of range second operand";
pattern <<(b:bat[:oid,:bte],v:wrd,accum:int) :bat[:oid,:bte]
address CMDbatLSHcstsignal
comment "Return B << V, raise error on out of range second operand, reuse B if ACCUM is set";
pattern lsh_noerror(b:bat[:oid,:bte],v:wrd) :bat[:oid,:bte]
address CMDbatLSHcst
comment "Return B << V, out of range second operand causes NIL value";
pattern <<(v:bte,b:bat[:oid,:wrd]) :bat[:oid,:bte]
address CMDbatLSHcstsignal
comment "Return V << B, raise error on out of range second operand";
pattern lsh_noerror(v:bte,b:bat[:oid,:wrd]) :bat[:oid,:bte]
address CMDbatLSHcst
comment "Return V << B, out of range second operand causes NIL value";

command <<(b1:bat[:oid,:bte],b2:bat[:oid,:lng]) :bat[:oid,:bte]
address CMDbatLSHsignal
comment "Return B1 << B2, raise error on out of range second operand";
command <<(b1:bat[:oid,:bte],b2:bat[:oid,:lng],accum:int) :bat[:oid,:bte]
address CMDbatLSHsignalaccum
comment "Return B1 << B2, raise error on out of range second operand, reuse B if ACCUM is set";
command lsh_noerror(b1:bat[:oid,:bte],b2:bat[:oid,:lng]) :bat[:oid,:bte]
address CMDbatLSH
comment "Return B1 << B2, out of range second operand causes NIL value";
pattern <<(b:bat[:oid,:bte],v:lng) :bat[:oid,:bte]
address CMDbatLSHcstsignal
comment "Return B << V, raise error on out of range second operand";
pattern <<(b:bat[:oid,:bte],v:lng,accum:int) :bat[:oid,:bte]
address CMDbatLSHcstsignal
comment "Return B << V, raise error on out of range second operand, reuse B if ACCUM is set";
pattern lsh_noerror(b:bat[:oid,:bte],v:lng) :bat[:oid,:bte]
address CMDbatLSHcst
comment "Return B << V, out of range second operand causes NIL value";
pattern <<(v:bte,b:bat[:oid,:lng]) :bat[:oid,:bte]
address CMDbatLSHcstsignal
comment "Return V << B, raise error on out of range second operand";
pattern lsh_noerror(v:bte,b:bat[:oid,:lng]) :bat[:oid,:bte]
address CMDbatLSHcst
comment "Return V << B, out of range second operand causes NIL value";

command <<(b1:bat[:oid,:sht],b2:bat[:oid,:bte]) :bat[:oid,:sht]
address CMDbatLSHsignal
comment "Return B1 << B2, raise error on out of range second operand";
command <<(b1:bat[:oid,:sht],b2:bat[:oid,:bte],accum:int) :bat[:oid,:sht]
address CMDbatLSHsignalaccum
comment "Return B1 << B2, raise error on out of range second operand, reuse B if ACCUM is set";
command lsh_noerror(b1:bat[:oid,:sht],b2:bat[:oid,:bte]) :bat[:oid,:sht]
address CMDbatLSH
comment "Return B1 << B2, out of range second operand causes NIL value";
pattern <<(b:bat[:oid,:sht],v:bte) :bat[:oid,:sht]
address CMDbatLSHcstsignal
comment "Return B << V, raise error on out of range second operand";
pattern <<(b:bat[:oid,:sht],v:bte,accum:int) :bat[:oid,:sht]
address CMDbatLSHcstsignal
comment "Return B << V, raise error on out of range second operand, reuse B if ACCUM is set";
pattern lsh_noerror(b:bat[:oid,:sht],v:bte) :bat[:oid,:sht]
address CMDbatLSHcst
comment "Return B << V, out of range second operand causes NIL value";
pattern <<(v:sht,b:bat[:oid,:bte]) :bat[:oid,:sht]
address CMDbatLSHcstsignal
comment "Return V << B, raise error on out of range second operand";
pattern lsh_noerror(v:sht,b:bat[:oid,:bte]) :bat[:oid,:sht]
address CMDbatLSHcst
comment "Return V << B, out of range second operand causes NIL value";

command <<(b1:bat[:oid,:sht],b2:bat[:oid,:sht]) :bat[:oid,:sht]
address CMDbatLSHsignal
comment "Return B1 << B2, raise error on out of range second operand";
command <<(b1:bat[:oid,:sht],b2:bat[:oid,:sht],accum:int) :bat[:oid,:sht]
address CMDbatLSHsignalaccum
comment "Return B1 << B2, raise error on out of range second operand, reuse B if ACCUM is set";
command lsh_noerror(b1:bat[:oid,:sht],b2:bat[:oid,:sht]) :bat[:oid,:sht]
address CMDbatLSH
comment "Return B1 << B2, out of range second operand causes NIL value";
pattern <<(b:bat[:oid,:sht],v:sht) :bat[:oid,:sht]
address CMDbatLSHcstsignal
comment "Return B << V, raise error on out of range second operand";
pattern <<(b:bat[:oid,:sht],v:sht,accum:int) :bat[:oid,:sht]
address CMDbatLSHcstsignal
comment "Return B << V, raise error on out of range second operand, reuse B if ACCUM is set";
pattern lsh_noerror(b:bat[:oid,:sht],v:sht) :bat[:oid,:sht]
address CMDbatLSHcst
comment "Return B << V, out of range second operand causes NIL value";
pattern <<(v:sht,b:bat[:oid,:sht]) :bat[:oid,:sht]
address CMDbatLSHcstsignal
comment "Return V << B, raise error on out of range second operand";
pattern lsh_noerror(v:sht,b:bat[:oid,:sht]) :bat[:oid,:sht]
address CMDbatLSHcst
comment "Return V << B, out of range second operand causes NIL value";

command <<(b1:bat[:oid,:sht],b2:bat[:oid,:int]) :bat[:oid,:sht]
address CMDbatLSHsignal
comment "Return B1 << B2, raise error on out of range second operand";
command <<(b1:bat[:oid,:sht],b2:bat[:oid,:int],accum:int) :bat[:oid,:sht]
address CMDbatLSHsignalaccum
comment "Return B1 << B2, raise error on out of range second operand, reuse B if ACCUM is set";
command lsh_noerror(b1:bat[:oid,:sht],b2:bat[:oid,:int]) :bat[:oid,:sht]
address CMDbatLSH
comment "Return B1 << B2, out of range second operand causes NIL value";
pattern <<(b:bat[:oid,:sht],v:int) :bat[:oid,:sht]
address CMDbatLSHcstsignal
comment "Return B << V, raise error on out of range second operand";
pattern <<(b:bat[:oid,:sht],v:int,accum:int) :bat[:oid,:sht]
address CMDbatLSHcstsignal
comment "Return B << V, raise error on out of range second operand, reuse B if ACCUM is set";
pattern lsh_noerror(b:bat[:oid,:sht],v:int) :bat[:oid,:sht]
address CMDbatLSHcst
comment "Return B << V, out of range second operand causes NIL value";
pattern <<(v:sht,b:bat[:oid,:int]) :bat[:oid,:sht]
address CMDbatLSHcstsignal
comment "Return V << B, raise error on out of range second operand";
pattern lsh_noerror(v:sht,b:bat[:oid,:int]) :bat[:oid,:sht]
address CMDbatLSHcst
comment "Return V << B, out of range second operand causes NIL value";

command <<(b1:bat[:oid,:sht],b2:bat[:oid,:wrd]) :bat[:oid,:sht]
address CMDbatLSHsignal
comment "Return B1 << B2, raise error on out of range second operand";
command <<(b1:bat[:oid,:sht],b2:bat[:oid,:wrd],accum:int) :bat[:oid,:sht]
address CMDbatLSHsignalaccum
comment "Return B1 << B2, raise error on out of range second operand, reuse B if ACCUM is set";
command lsh_noerror(b1:bat[:oid,:sht],b2:bat[:oid,:wrd]) :bat[:oid,:sht]
address CMDbatLSH
comment "Return B1 << B2, out of range second operand causes NIL value";
pattern <<(b:bat[:oid,:sht],v:wrd) :bat[:oid,:sht]
address CMDbatLSHcstsignal
comment "Return B << V, raise error on out of range second operand";
pattern <<(b:bat[:oid,:sht],v:wrd,accum:int) :bat[:oid,:sht]
address CMDbatLSHcstsignal
comment "Return B << V, raise error on out of range second operand, reuse B if ACCUM is set";
pattern lsh_noerror(b:bat[:oid,:sht],v:wrd) :bat[:oid,:sht]
address CMDbatLSHcst
comment "Return B << V, out of range second operand causes NIL value";
pattern <<(v:sht,b:bat[:oid,:wrd]) :bat[:oid,:sht]
address CMDbatLSHcstsignal
comment "Return V << B, raise error on out of range second operand";
pattern lsh_noerror(v:sht,b:bat[:oid,:wrd]) :bat[:oid,:sht]
address CMDbatLSHcst
comment "Return V << B, out of range second operand causes NIL value";

command <<(b1:bat[:oid,:sht],b2:bat[:oid,:lng]) :bat[:oid,:sht]
address CMDbatLSHsignal
comment "Return B1 << B2, raise error on out of range second operand";
command <<(b1:bat[:oid,:sht],b2:bat[:oid,:lng],accum:int) :bat[:oid,:sht]
address CMDbatLSHsignalaccum
comment "Return B1 << B2, raise error on out of range second operand, reuse B if ACCUM is set";
command lsh_noerror(b1:bat[:oid,:sht],b2:bat[:oid,:lng]) :bat[:oid,:sht]
address CMDbatLSH
comment "Return B1 << B2, out of range second operand causes NIL value";
pattern <<(b:bat[:oid,:sht],v:lng) :bat[:oid,:sht]
address CMDbatLSHcstsignal
comment "Return B << V, raise error on out of range second operand";
pattern <<(b:bat[:oid,:sht],v:lng,accum:int) :bat[:oid,:sht]
address CMDbatLSHcstsignal
comment "Return B << V, raise error on out of range second operand, reuse B if ACCUM is set";
pattern lsh_noerror(b:bat[:oid,:sht],v:lng) :bat[:oid,:sht]
address CMDbatLSHcst
comment "Return B << V, out of range second operand causes NIL value";
pattern <<(v:sht,b:bat[:oid,:lng]) :bat[:oid,:sht]
address CMDbatLSHcstsignal
comment "Return V << B, raise error on out of range second operand";
pattern lsh_noerror(v:sht,b:bat[:oid,:lng]) :bat[:oid,:sht]
address CMDbatLSHcst
comment "Return V << B, out of range second operand causes NIL value";

command <<(b1:bat[:oid,:int],b2:bat[:oid,:bte]) :bat[:oid,:int]
address CMDbatLSHsignal
comment "Return B1 << B2, raise error on out of range second operand";
command <<(b1:bat[:oid,:int],b2:bat[:oid,:bte],accum:int) :bat[:oid,:int]
address CMDbatLSHsignalaccum
comment "Return B1 << B2, raise error on out of range second operand, reuse B if ACCUM is set";
command lsh_noerror(b1:bat[:oid,:int],b2:bat[:oid,:bte]) :bat[:oid,:int]
address CMDbatLSH
comment "Return B1 << B2, out of range second operand causes NIL value";
pattern <<(b:bat[:oid,:int],v:bte) :bat[:oid,:int]
address CMDbatLSHcstsignal
comment "Return B << V, raise error on out of range second operand";
pattern <<(b:bat[:oid,:int],v:bte,accum:int) :bat[:oid,:int]
address CMDbatLSHcstsignal
comment "Return B << V, raise error on out of range second operand, reuse B if ACCUM is set";
pattern lsh_noerror(b:bat[:oid,:int],v:bte) :bat[:oid,:int]
address CMDbatLSHcst
comment "Return B << V, out of range second operand causes NIL value";
pattern <<(v:int,b:bat[:oid,:bte]) :bat[:oid,:int]
address CMDbatLSHcstsignal
comment "Return V << B, raise error on out of range second operand";
pattern lsh_noerror(v:int,b:bat[:oid,:bte]) :bat[:oid,:int]
address CMDbatLSHcst
comment "Return V << B, out of range second operand causes NIL value";

command <<(b1:bat[:oid,:int],b2:bat[:oid,:sht]) :bat[:oid,:int]
address CMDbatLSHsignal
comment "Return B1 << B2, raise error on out of range second operand";
command <<(b1:bat[:oid,:int],b2:bat[:oid,:sht],accum:int) :bat[:oid,:int]
address CMDbatLSHsignalaccum
comment "Return B1 << B2, raise error on out of range second operand, reuse B if ACCUM is set";
command lsh_noerror(b1:bat[:oid,:int],b2:bat[:oid,:sht]) :bat[:oid,:int]
address CMDbatLSH
comment "Return B1 << B2, out of range second operand causes NIL value";
pattern <<(b:bat[:oid,:int],v:sht) :bat[:oid,:int]
address CMDbatLSHcstsignal
comment "Return B << V, raise error on out of range second operand";
pattern <<(b:bat[:oid,:int],v:sht,accum:int) :bat[:oid,:int]
address CMDbatLSHcstsignal
comment "Return B << V, raise error on out of range second operand, reuse B if ACCUM is set";
pattern lsh_noerror(b:bat[:oid,:int],v:sht) :bat[:oid,:int]
address CMDbatLSHcst
comment "Return B << V, out of range second operand causes NIL value";
pattern <<(v:int,b:bat[:oid,:sht]) :bat[:oid,:int]
address CMDbatLSHcstsignal
comment "Return V << B, raise error on out of range second operand";
pattern lsh_noerror(v:int,b:bat[:oid,:sht]) :bat[:oid,:int]
address CMDbatLSHcst
comment "Return V << B, out of range second operand causes NIL value";

command <<(b1:bat[:oid,:int],b2:bat[:oid,:int]) :bat[:oid,:int]
address CMDbatLSHsignal
comment "Return B1 << B2, raise error on out of range second operand";
command <<(b1:bat[:oid,:int],b2:bat[:oid,:int],accum:int) :bat[:oid,:int]
address CMDbatLSHsignalaccum
comment "Return B1 << B2, raise error on out of range second operand, reuse B if ACCUM is set";
command lsh_noerror(b1:bat[:oid,:int],b2:bat[:oid,:int]) :bat[:oid,:int]
address CMDbatLSH
comment "Return B1 << B2, out of range second operand causes NIL value";
pattern <<(b:bat[:oid,:int],v:int) :bat[:oid,:int]
address CMDbatLSHcstsignal
comment "Return B << V, raise error on out of range second operand";
pattern <<(b:bat[:oid,:int],v:int,accum:int) :bat[:oid,:int]
address CMDbatLSHcstsignal
comment "Return B << V, raise error on out of range second operand, reuse B if ACCUM is set";
pattern lsh_noerror(b:bat[:oid,:int],v:int) :bat[:oid,:int]
address CMDbatLSHcst
comment "Return B << V, out of range second operand causes NIL value";
pattern <<(v:int,b:bat[:oid,:int]) :bat[:oid,:int]
address CMDbatLSHcstsignal
comment "Return V << B, raise error on out of range second operand";
pattern lsh_noerror(v:int,b:bat[:oid,:int]) :bat[:oid,:int]
address CMDbatLSHcst
comment "Return V << B, out of range second operand causes NIL value";

command <<(b1:bat[:oid,:int],b2:bat[:oid,:wrd]) :bat[:oid,:int]
address CMDbatLSHsignal
comment "Return B1 << B2, raise error on out of range second operand";
command <<(b1:bat[:oid,:int],b2:bat[:oid,:wrd],accum:int) :bat[:oid,:int]
address CMDbatLSHsignalaccum
comment "Return B1 << B2, raise error on out of range second operand, reuse B if ACCUM is set";
command lsh_noerror(b1:bat[:oid,:int],b2:bat[:oid,:wrd]) :bat[:oid,:int]
address CMDbatLSH
comment "Return B1 << B2, out of range second operand causes NIL value";
pattern <<(b:bat[:oid,:int],v:wrd) :bat[:oid,:int]
address CMDbatLSHcstsignal
comment "Return B << V, raise error on out of range second operand";
pattern <<(b:bat[:oid,:int],v:wrd,accum:int) :bat[:oid,:int]
address CMDbatLSHcstsignal
comment "Return B << V, raise error on out of range second operand, reuse B if ACCUM is set";
pattern lsh_noerror(b:bat[:oid,:int],v:wrd) :bat[:oid,:int]
address CMDbatLSHcst
comment "Return B << V, out of range second operand causes NIL value";
pattern <<(v:int,b:bat[:oid,:wrd]) :bat[:oid,:int]
address CMDbatLSHcstsignal
comment "Return V << B, raise error on out of range second operand";
pattern lsh_noerror(v:int,b:bat[:oid,:wrd]) :bat[:oid,:int]
address CMDbatLSHcst
comment "Return V << B, out of range second operand causes NIL value";

command <<(b1:bat[:oid,:int],b2:bat[:oid,:lng]) :bat[:oid,:int]
address CMDbatLSHsignal
comment "Return B1 << B2, raise error on out of range second operand";
command <<(b1:bat[:oid,:int],b2:bat[:oid,:lng],accum:int) :bat[:oid,:int]
address CMDbatLSHsignalaccum
comment "Return B1 << B2, raise error on out of range second operand, reuse B if ACCUM is set";
command lsh_noerror(b1:bat[:oid,:int],b2:bat[:oid,:lng]) :bat[:oid,:int]
address CMDbatLSH
comment "Return B1 << B2, out of range second operand causes NIL value";
pattern <<(b:bat[:oid,:int],v:lng) :bat[:oid,:int]
address CMDbatLSHcstsignal
comment "Return B << V, raise error on out of range second operand";
pattern <<(b:bat[:oid,:int],v:lng,accum:int) :bat[:oid,:int]
address CMDbatLSHcstsignal
comment "Return B << V, raise error on out of range second operand, reuse B if ACCUM is set";
pattern lsh_noerror(b:bat[:oid,:int],v:lng) :bat[:oid,:int]
address CMDbatLSHcst
comment "Return B << V, out of range second operand causes NIL value";
pattern <<(v:int,b:bat[:oid,:lng]) :bat[:oid,:int]
address CMDbatLSHcstsignal
comment "Return V << B, raise error on out of range second operand";
pattern lsh_noerror(v:int,b:bat[:oid,:lng]) :bat[:oid,:int]
address CMDbatLSHcst
comment "Return V << B, out of range second operand causes NIL value";

command <<(b1:bat[:oid,:wrd],b2:bat[:oid,:bte]) :bat[:oid,:wrd]
address CMDbatLSHsignal
comment "Return B1 << B2, raise error on out of range second operand";
command <<(b1:bat[:oid,:wrd],b2:bat[:oid,:bte],accum:int) :bat[:oid,:wrd]
address CMDbatLSHsignalaccum
comment "Return B1 << B2, raise error on out of range second operand, reuse B if ACCUM is set";
command lsh_noerror(b1:bat[:oid,:wrd],b2:bat[:oid,:bte]) :bat[:oid,:wrd]
address CMDbatLSH
comment "Return B1 << B2, out of range second operand causes NIL value";
pattern <<(b:bat[:oid,:wrd],v:bte) :bat[:oid,:wrd]
address CMDbatLSHcstsignal
comment "Return B << V, raise error on out of range second operand";
pattern <<(b:bat[:oid,:wrd],v:bte,accum:int) :bat[:oid,:wrd]
address CMDbatLSHcstsignal
comment "Return B << V, raise error on out of range second operand, reuse B if ACCUM is set";
pattern lsh_noerror(b:bat[:oid,:wrd],v:bte) :bat[:oid,:wrd]
address CMDbatLSHcst
comment "Return B << V, out of range second operand causes NIL value";
pattern <<(v:wrd,b:bat[:oid,:bte]) :bat[:oid,:wrd]
address CMDbatLSHcstsignal
comment "Return V << B, raise error on out of range second operand";
pattern lsh_noerror(v:wrd,b:bat[:oid,:bte]) :bat[:oid,:wrd]
address CMDbatLSHcst
comment "Return V << B, out of range second operand causes NIL value";

command <<(b1:bat[:oid,:wrd],b2:bat[:oid,:sht]) :bat[:oid,:wrd]
address CMDbatLSHsignal
comment "Return B1 << B2, raise error on out of range second operand";
command <<(b1:bat[:oid,:wrd],b2:bat[:oid,:sht],accum:int) :bat[:oid,:wrd]
address CMDbatLSHsignalaccum
comment "Return B1 << B2, raise error on out of range second operand, reuse B if ACCUM is set";
command lsh_noerror(b1:bat[:oid,:wrd],b2:bat[:oid,:sht]) :bat[:oid,:wrd]
address CMDbatLSH
comment "Return B1 << B2, out of range second operand causes NIL value";
pattern <<(b:bat[:oid,:wrd],v:sht) :bat[:oid,:wrd]
address CMDbatLSHcstsignal
comment "Return B << V, raise error on out of range second operand";
pattern <<(b:bat[:oid,:wrd],v:sht,accum:int) :bat[:oid,:wrd]
address CMDbatLSHcstsignal
comment "Return B << V, raise error on out of range second operand, reuse B if ACCUM is set";
pattern lsh_noerror(b:bat[:oid,:wrd],v:sht) :bat[:oid,:wrd]
address CMDbatLSHcst
comment "Return B << V, out of range second operand causes NIL value";
pattern <<(v:wrd,b:bat[:oid,:sht]) :bat[:oid,:wrd]
address CMDbatLSHcstsignal
comment "Return V << B, raise error on out of range second operand";
pattern lsh_noerror(v:wrd,b:bat[:oid,:sht]) :bat[:oid,:wrd]
address CMDbatLSHcst
comment "Return V << B, out of range second operand causes NIL value";

command <<(b1:bat[:oid,:wrd],b2:bat[:oid,:int]) :bat[:oid,:wrd]
address CMDbatLSHsignal
comment "Return B1 << B2, raise error on out of range second operand";
command <<(b1:bat[:oid,:wrd],b2:bat[:oid,:int],accum:int) :bat[:oid,:wrd]
address CMDbatLSHsignalaccum
comment "Return B1 << B2, raise error on out of range second operand, reuse B if ACCUM is set";
command lsh_noerror(b1:bat[:oid,:wrd],b2:bat[:oid,:int]) :bat[:oid,:wrd]
address CMDbatLSH
comment "Return B1 << B2, out of range second operand causes NIL value";
pattern <<(b:bat[:oid,:wrd],v:int) :bat[:oid,:wrd]
address CMDbatLSHcstsignal
comment "Return B << V, raise error on out of range second operand";
pattern <<(b:bat[:oid,:wrd],v:int,accum:int) :bat[:oid,:wrd]
address CMDbatLSHcstsignal
comment "Return B << V, raise error on out of range second operand, reuse B if ACCUM is set";
pattern lsh_noerror(b:bat[:oid,:wrd],v:int) :bat[:oid,:wrd]
address CMDbatLSHcst
comment "Return B << V, out of range second operand causes NIL value";
pattern <<(v:wrd,b:bat[:oid,:int]) :bat[:oid,:wrd]
address CMDbatLSHcstsignal
comment "Return V << B, raise error on out of range second operand";
pattern lsh_noerror(v:wrd,b:bat[:oid,:int]) :bat[:oid,:wrd]
address CMDbatLSHcst
comment "Return V << B, out of range second operand causes NIL value";

command <<(b1:bat[:oid,:wrd],b2:bat[:oid,:wrd]) :bat[:oid,:wrd]
address CMDbatLSHsignal
comment "Return B1 << B2, raise error on out of range second operand";
command <<(b1:bat[:oid,:wrd],b2:bat[:oid,:wrd],accum:int) :bat[:oid,:wrd]
address CMDbatLSHsignalaccum
comment "Return B1 << B2, raise error on out of range second operand, reuse B if ACCUM is set";
command lsh_noerror(b1:bat[:oid,:wrd],b2:bat[:oid,:wrd]) :bat[:oid,:wrd]
address CMDbatLSH
comment "Return B1 << B2, out of range second operand causes NIL value";
pattern <<(b:bat[:oid,:wrd],v:wrd) :bat[:oid,:wrd]
address CMDbatLSHcstsignal
comment "Return B << V, raise error on out of range second operand";
pattern <<(b:bat[:oid,:wrd],v:wrd,accum:int) :bat[:oid,:wrd]
address CMDbatLSHcstsignal
comment "Return B << V, raise error on out of range second operand, reuse B if ACCUM is set";
pattern lsh_noerror(b:bat[:oid,:wrd],v:wrd) :bat[:oid,:wrd]
address CMDbatLSHcst
comment "Return B << V, out of range second operand causes NIL value";
pattern <<(v:wrd,b:bat[:oid,:wrd]) :bat[:oid,:wrd]
address CMDbatLSHcstsignal
comment "Return V << B, raise error on out of range second operand";
pattern lsh_noerror(v:wrd,b:bat[:oid,:wrd]) :bat[:oid,:wrd]
address CMDbatLSHcst
comment "Return V << B, out of range second operand causes NIL value";

command <<(b1:bat[:oid,:wrd],b2:bat[:oid,:lng]) :bat[:oid,:wrd]
address CMDbatLSHsignal
comment "Return B1 << B2, raise error on out of range second operand";
command <<(b1:bat[:oid,:wrd],b2:bat[:oid,:lng],accum:int) :bat[:oid,:wrd]
address CMDbatLSHsignalaccum
comment "Return B1 << B2, raise error on out of range second operand, reuse B if ACCUM is set";
command lsh_noerror(b1:bat[:oid,:wrd],b2:bat[:oid,:lng]) :bat[:oid,:wrd]
address CMDbatLSH
comment "Return B1 << B2, out of range second operand causes NIL value";
pattern <<(b:bat[:oid,:wrd],v:lng) :bat[:oid,:wrd]
address CMDbatLSHcstsignal
comment "Return B << V, raise error on out of range second operand";
pattern <<(b:bat[:oid,:wrd],v:lng,accum:int) :bat[:oid,:wrd]
address CMDbatLSHcstsignal
comment "Return B << V, raise error on out of range second operand, reuse B if ACCUM is set";
pattern lsh_noerror(b:bat[:oid,:wrd],v:lng) :bat[:oid,:wrd]
address CMDbatLSHcst
comment "Return B << V, out of range second operand causes NIL value";
pattern <<(v:wrd,b:bat[:oid,:lng]) :bat[:oid,:wrd]
address CMDbatLSHcstsignal
comment "Return V << B, raise error on out of range second operand";
pattern lsh_noerror(v:wrd,b:bat[:oid,:lng]) :bat[:oid,:wrd]
address CMDbatLSHcst
comment "Return V << B, out of range second operand causes NIL value";

command <<(b1:bat[:oid,:lng],b2:bat[:oid,:bte]) :bat[:oid,:lng]
address CMDbatLSHsignal
comment "Return B1 << B2, raise error on out of range second operand";
command <<(b1:bat[:oid,:lng],b2:bat[:oid,:bte],accum:int) :bat[:oid,:lng]
address CMDbatLSHsignalaccum
comment "Return B1 << B2, raise error on out of range second operand, reuse B if ACCUM is set";
command lsh_noerror(b1:bat[:oid,:lng],b2:bat[:oid,:bte]) :bat[:oid,:lng]
address CMDbatLSH
comment "Return B1 << B2, out of range second operand causes NIL value";
pattern <<(b:bat[:oid,:lng],v:bte) :bat[:oid,:lng]
address CMDbatLSHcstsignal
comment "Return B << V, raise error on out of range second operand";
pattern <<(b:bat[:oid,:lng],v:bte,accum:int) :bat[:oid,:lng]
address CMDbatLSHcstsignal
comment "Return B << V, raise error on out of range second operand, reuse B if ACCUM is set";
pattern lsh_noerror(b:bat[:oid,:lng],v:bte) :bat[:oid,:lng]
address CMDbatLSHcst
comment "Return B << V, out of range second operand causes NIL value";
pattern <<(v:lng,b:bat[:oid,:bte]) :bat[:oid,:lng]
address CMDbatLSHcstsignal
comment "Return V << B, raise error on out of range second operand";
pattern lsh_noerror(v:lng,b:bat[:oid,:bte]) :bat[:oid,:lng]
address CMDbatLSHcst
comment "Return V << B, out of range second operand causes NIL value";

command <<(b1:bat[:oid,:lng],b2:bat[:oid,:sht]) :bat[:oid,:lng]
address CMDbatLSHsignal
comment "Return B1 << B2, raise error on out of range second operand";
command <<(b1:bat[:oid,:lng],b2:bat[:oid,:sht],accum:int) :bat[:oid,:lng]
address CMDbatLSHsignalaccum
comment "Return B1 << B2, raise error on out of range second operand, reuse B if ACCUM is set";
command lsh_noerror(b1:bat[:oid,:lng],b2:bat[:oid,:sht]) :bat[:oid,:lng]
address CMDbatLSH
comment "Return B1 << B2, out of range second operand causes NIL value";
pattern <<(b:bat[:oid,:lng],v:sht) :bat[:oid,:lng]
address CMDbatLSHcstsignal
comment "Return B << V, raise error on out of range second operand";
pattern <<(b:bat[:oid,:lng],v:sht,accum:int) :bat[:oid,:lng]
address CMDbatLSHcstsignal
comment "Return B << V, raise error on out of range second operand, reuse B if ACCUM is set";
pattern lsh_noerror(b:bat[:oid,:lng],v:sht) :bat[:oid,:lng]
address CMDbatLSHcst
comment "Return B << V, out of range second operand causes NIL value";
pattern <<(v:lng,b:bat[:oid,:sht]) :bat[:oid,:lng]
address CMDbatLSHcstsignal
comment "Return V << B, raise error on out of range second operand";
pattern lsh_noerror(v:lng,b:bat[:oid,:sht]) :bat[:oid,:lng]
address CMDbatLSHcst
comment "Return V << B, out of range second operand causes NIL value";

command <<(b1:bat[:oid,:lng],b2:bat[:oid,:int]) :bat[:oid,:lng]
address CMDbatLSHsignal
comment "Return B1 << B2, raise error on out of range second operand";
command <<(b1:bat[:oid,:lng],b2:bat[:oid,:int],accum:int) :bat[:oid,:lng]
address CMDbatLSHsignalaccum
comment "Return B1 << B2, raise error on out of range second operand, reuse B if ACCUM is set";
command lsh_noerror(b1:bat[:oid,:lng],b2:bat[:oid,:int]) :bat[:oid,:lng]
address CMDbatLSH
comment "Return B1 << B2, out of range second operand causes NIL value";
pattern <<(b:bat[:oid,:lng],v:int) :bat[:oid,:lng]
address CMDbatLSHcstsignal
comment "Return B << V, raise error on out of range second operand";
pattern <<(b:bat[:oid,:lng],v:int,accum:int) :bat[:oid,:lng]
address CMDbatLSHcstsignal
comment "Return B << V, raise error on out of range second operand, reuse B if ACCUM is set";
pattern lsh_noerror(b:bat[:oid,:lng],v:int) :bat[:oid,:lng]
address CMDbatLSHcst
comment "Return B << V, out of range second operand causes NIL value";
pattern <<(v:lng,b:bat[:oid,:int]) :bat[:oid,:lng]
address CMDbatLSHcstsignal
comment "Return V << B, raise error on out of range second operand";
pattern lsh_noerror(v:lng,b:bat[:oid,:int]) :bat[:oid,:lng]
address CMDbatLSHcst
comment "Return V << B, out of range second operand causes NIL value";

command <<(b1:bat[:oid,:lng],b2:bat[:oid,:wrd]) :bat[:oid,:lng]
address CMDbatLSHsignal
comment "Return B1 << B2, raise error on out of range second operand";
command <<(b1:bat[:oid,:lng],b2:bat[:oid,:wrd],accum:int) :bat[:oid,:lng]
address CMDbatLSHsignalaccum
comment "Return B1 << B2, raise error on out of range second operand, reuse B if ACCUM is set";
command lsh_noerror(b1:bat[:oid,:lng],b2:bat[:oid,:wrd]) :bat[:oid,:lng]
address CMDbatLSH
comment "Return B1 << B2, out of range second operand causes NIL value";
pattern <<(b:bat[:oid,:lng],v:wrd) :bat[:oid,:lng]
address CMDbatLSHcstsignal
comment "Return B << V, raise error on out of range second operand";
pattern <<(b:bat[:oid,:lng],v:wrd,accum:int) :bat[:oid,:lng]
address CMDbatLSHcstsignal
comment "Return B << V, raise error on out of range second operand, reuse B if ACCUM is set";
pattern lsh_noerror(b:bat[:oid,:lng],v:wrd) :bat[:oid,:lng]
address CMDbatLSHcst
comment "Return B << V, out of range second operand causes NIL value";
pattern <<(v:lng,b:bat[:oid,:wrd]) :bat[:oid,:lng]
address CMDbatLSHcstsignal
comment "Return V << B, raise error on out of range second operand";
pattern lsh_noerror(v:lng,b:bat[:oid,:wrd]) :bat[:oid,:lng]
address CMDbatLSHcst
comment "Return V << B, out of range second operand causes NIL value";

command <<(b1:bat[:oid,:lng],b2:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatLSHsignal
comment "Return B1 << B2, raise error on out of range second operand";
command <<(b1:bat[:oid,:lng],b2:bat[:oid,:lng],accum:int) :bat[:oid,:lng]
address CMDbatLSHsignalaccum
comment "Return B1 << B2, raise error on out of range second operand, reuse B if ACCUM is set";
command lsh_noerror(b1:bat[:oid,:lng],b2:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatLSH
comment "Return B1 << B2, out of range second operand causes NIL value";
pattern <<(b:bat[:oid,:lng],v:lng) :bat[:oid,:lng]
address CMDbatLSHcstsignal
comment "Return B << V, raise error on out of range second operand";
pattern <<(b:bat[:oid,:lng],v:lng,accum:int) :bat[:oid,:lng]
address CMDbatLSHcstsignal
comment "Return B << V, raise error on out of range second operand, reuse B if ACCUM is set";
pattern lsh_noerror(b:bat[:oid,:lng],v:lng) :bat[:oid,:lng]
address CMDbatLSHcst
comment "Return B << V, out of range second operand causes NIL value";
pattern <<(v:lng,b:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatLSHcstsignal
comment "Return V << B, raise error on out of range second operand";
pattern lsh_noerror(v:lng,b:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatLSHcst
comment "Return V << B, out of range second operand causes NIL value";


command >>(b1:bat[:oid,:bte],b2:bat[:oid,:bte]) :bat[:oid,:bte]
address CMDbatRSHsignal
comment "Return B1 >> B2, raise error on out of range second operand";
command >>(b1:bat[:oid,:bte],b2:bat[:oid,:bte],accum:int) :bat[:oid,:bte]
address CMDbatRSHsignalaccum
comment "Return B1 >> B2, raise error on out of range second operand, reuse B if ACCUM is set";
command rsh_noerror(b1:bat[:oid,:bte],b2:bat[:oid,:bte]) :bat[:oid,:bte]
address CMDbatRSH
comment "Return B1 >> B2, out of range second operand causes NIL value";
pattern >>(b:bat[:oid,:bte],v:bte) :bat[:oid,:bte]
address CMDbatRSHcstsignal
comment "Return B >> V, raise error on out of range second operand";
pattern >>(b:bat[:oid,:bte],v:bte,accum:int) :bat[:oid,:bte]
address CMDbatRSHcstsignal
comment "Return B >> V, raise error on out of range second operand, reuse B if ACCUM is set";
pattern rsh_noerror(b:bat[:oid,:bte],v:bte) :bat[:oid,:bte]
address CMDbatRSHcst
comment "Return B >> V, out of range second operand causes NIL value";
pattern >>(v:bte,b:bat[:oid,:bte]) :bat[:oid,:bte]
address CMDbatRSHcstsignal
comment "Return V >> B, raise error on out of range second operand";
pattern rsh_noerror(v:bte,b:bat[:oid,:bte]) :bat[:oid,:bte]
address CMDbatRSHcst
comment "Return V >> B, out of range second operand causes NIL value";

command >>(b1:bat[:oid,:bte],b2:bat[:oid,:sht]) :bat[:oid,:bte]
address CMDbatRSHsignal
comment "Return B1 >> B2, raise error on out of range second operand";
command >>(b1:bat[:oid,:bte],b2:bat[:oid,:sht],accum:int) :bat[:oid,:bte]
address CMDbatRSHsignalaccum
comment "Return B1 >> B2, raise error on out of range second operand, reuse B if ACCUM is set";
command rsh_noerror(b1:bat[:oid,:bte],b2:bat[:oid,:sht]) :bat[:oid,:bte]
address CMDbatRSH
comment "Return B1 >> B2, out of range second operand causes NIL value";
pattern >>(b:bat[:oid,:bte],v:sht) :bat[:oid,:bte]
address CMDbatRSHcstsignal
comment "Return B >> V, raise error on out of range second operand";
pattern >>(b:bat[:oid,:bte],v:sht,accum:int) :bat[:oid,:bte]
address CMDbatRSHcstsignal
comment "Return B >> V, raise error on out of range second operand, reuse B if ACCUM is set";
pattern rsh_noerror(b:bat[:oid,:bte],v:sht) :bat[:oid,:bte]
address CMDbatRSHcst
comment "Return B >> V, out of range second operand causes NIL value";
pattern >>(v:bte,b:bat[:oid,:sht]) :bat[:oid,:bte]
address CMDbatRSHcstsignal
comment "Return V >> B, raise error on out of range second operand";
pattern rsh_noerror(v:bte,b:bat[:oid,:sht]) :bat[:oid,:bte]
address CMDbatRSHcst
comment "Return V >> B, out of range second operand causes NIL value";

command >>(b1:bat[:oid,:bte],b2:bat[:oid,:int]) :bat[:oid,:bte]
address CMDbatRSHsignal
comment "Return B1 >> B2, raise error on out of range second operand";
command >>(b1:bat[:oid,:bte],b2:bat[:oid,:int],accum:int) :bat[:oid,:bte]
address CMDbatRSHsignalaccum
comment "Return B1 >> B2, raise error on out of range second operand, reuse B if ACCUM is set";
command rsh_noerror(b1:bat[:oid,:bte],b2:bat[:oid,:int]) :bat[:oid,:bte]
address CMDbatRSH
comment "Return B1 >> B2, out of range second operand causes NIL value";
pattern >>(b:bat[:oid,:bte],v:int) :bat[:oid,:bte]
address CMDbatRSHcstsignal
comment "Return B >> V, raise error on out of range second operand";
pattern >>(b:bat[:oid,:bte],v:int,accum:int) :bat[:oid,:bte]
address CMDbatRSHcstsignal
comment "Return B >> V, raise error on out of range second operand, reuse B if ACCUM is set";
pattern rsh_noerror(b:bat[:oid,:bte],v:int) :bat[:oid,:bte]
address CMDbatRSHcst
comment "Return B >> V, out of range second operand causes NIL value";
pattern >>(v:bte,b:bat[:oid,:int]) :bat[:oid,:bte]
address CMDbatRSHcstsignal
comment "Return V >> B, raise error on out of range second operand";
pattern rsh_noerror(v:bte,b:bat[:oid,:int]) :bat[:oid,:bte]
address CMDbatRSHcst
comment "Return V >> B, out of range second operand causes NIL value";

command >>(b1:bat[:oid,:bte],b2:bat[:oid,:wrd]) :bat[:oid,:bte]
address CMDbatRSHsignal
comment "Return B1 >> B2, raise error on out of range second operand";
command >>(b1:bat[:oid,:bte],b2:bat[:oid,:wrd],accum:int) :bat[:oid,:bte]
address CMDbatRSHsignalaccum
comment "Return B1 >> B2, raise error on out of range second operand, reuse B if ACCUM is set";
command rsh_noerror(b1:bat[:oid,:bte],b2:bat[:oid,:wrd]) :bat[:oid,:bte]
address CMDbatRSH
comment "Return B1 >> B2, out of range second operand causes NIL value";
pattern >>(b:bat[:oid,:bte],v:wrd) :bat[:oid,:bte]
address CMDbatRSHcstsignal
comment "Return B >> V, raise error on out of range second operand";
pattern >>(b:bat[:oid,:bte],v:wrd,accum:int) :bat[:oid,:bte]
address CMDbatRSHcstsignal
comment "Return B >> V, raise error on out of range second operand, reuse B if ACCUM is set";
pattern rsh_noerror(b:bat[:oid,:bte],v:wrd) :bat[:oid,:bte]
address CMDbatRSHcst
comment "Return B >> V, out of range second operand causes NIL value";
pattern >>(v:bte,b:bat[:oid,:wrd]) :bat[:oid,:bte]
address CMDbatRSHcstsignal
comment "Return V >> B, raise error on out of range second operand";
pattern rsh_noerror(v:bte,b:bat[:oid,:wrd]) :bat[:oid,:bte]
address CMDbatRSHcst
comment "Return V >> B, out of range second operand causes NIL value";

command >>(b1:bat[:oid,:bte],b2:bat[:oid,:lng]) :bat[:oid,:bte]
address CMDbatRSHsignal
comment "Return B1 >> B2, raise error on out of range second operand";
command >>(b1:bat[:oid,:bte],b2:bat[:oid,:lng],accum:int) :bat[:oid,:bte]
address CMDbatRSHsignalaccum
comment "Return B1 >> B2, raise error on out of range second operand, reuse B if ACCUM is set";
command rsh_noerror(b1:bat[:oid,:bte],b2:bat[:oid,:lng]) :bat[:oid,:bte]
address CMDbatRSH
comment "Return B1 >> B2, out of range second operand causes NIL value";
pattern >>(b:bat[:oid,:bte],v:lng) :bat[:oid,:bte]
address CMDbatRSHcstsignal
comment "Return B >> V, raise error on out of range second operand";
pattern >>(b:bat[:oid,:bte],v:lng,accum:int) :bat[:oid,:bte]
address CMDbatRSHcstsignal
comment "Return B >> V, raise error on out of range second operand, reuse B if ACCUM is set";
pattern rsh_noerror(b:bat[:oid,:bte],v:lng) :bat[:oid,:bte]
address CMDbatRSHcst
comment "Return B >> V, out of range second operand causes NIL value";
pattern >>(v:bte,b:bat[:oid,:lng]) :bat[:oid,:bte]
address CMDbatRSHcstsignal
comment "Return V >> B, raise error on out of range second operand";
pattern rsh_noerror(v:bte,b:bat[:oid,:lng]) :bat[:oid,:bte]
address CMDbatRSHcst
comment "Return V >> B, out of range second operand causes NIL value";

command >>(b1:bat[:oid,:sht],b2:bat[:oid,:bte]) :bat[:oid,:sht]
address CMDbatRSHsignal
comment "Return B1 >> B2, raise error on out of range second operand";
command >>(b1:bat[:oid,:sht],b2:bat[:oid,:bte],accum:int) :bat[:oid,:sht]
address CMDbatRSHsignalaccum
comment "Return B1 >> B2, raise error on out of range second operand, reuse B if ACCUM is set";
command rsh_noerror(b1:bat[:oid,:sht],b2:bat[:oid,:bte]) :bat[:oid,:sht]
address CMDbatRSH
comment "Return B1 >> B2, out of range second operand causes NIL value";
pattern >>(b:bat[:oid,:sht],v:bte) :bat[:oid,:sht]
address CMDbatRSHcstsignal
comment "Return B >> V, raise error on out of range second operand";
pattern >>(b:bat[:oid,:sht],v:bte,accum:int) :bat[:oid,:sht]
address CMDbatRSHcstsignal
comment "Return B >> V, raise error on out of range second operand, reuse B if ACCUM is set";
pattern rsh_noerror(b:bat[:oid,:sht],v:bte) :bat[:oid,:sht]
address CMDbatRSHcst
comment "Return B >> V, out of range second operand causes NIL value";
pattern >>(v:sht,b:bat[:oid,:bte]) :bat[:oid,:sht]
address CMDbatRSHcstsignal
comment "Return V >> B, raise error on out of range second operand";
pattern rsh_noerror(v:sht,b:bat[:oid,:bte]) :bat[:oid,:sht]
address CMDbatRSHcst
comment "Return V >> B, out of range second operand causes NIL value";

command >>(b1:bat[:oid,:sht],b2:bat[:oid,:sht]) :bat[:oid,:sht]
address CMDbatRSHsignal
comment "Return B1 >> B2, raise error on out of range second operand";
command >>(b1:bat[:oid,:sht],b2:bat[:oid,:sht],accum:int) :bat[:oid,:sht]
address CMDbatRSHsignalaccum
comment "Return B1 >> B2, raise error on out of range second operand, reuse B if ACCUM is set";
command rsh_noerror(b1:bat[:oid,:sht],b2:bat[:oid,:sht]) :bat[:oid,:sht]
address CMDbatRSH
comment "Return B1 >> B2, out of range second operand causes NIL value";
pattern >>(b:bat[:oid,:sht],v:sht) :bat[:oid,:sht]
address CMDbatRSHcstsignal
comment "Return B >> V, raise error on out of range second operand";
pattern >>(b:bat[:oid,:sht],v:sht,accum:int) :bat[:oid,:sht]
address CMDbatRSHcstsignal
comment "Return B >> V, raise error on out of range second operand, reuse B if ACCUM is set";
pattern rsh_noerror(b:bat[:oid,:sht],v:sht) :bat[:oid,:sht]
address CMDbatRSHcst
comment "Return B >> V, out of range second operand causes NIL value";
pattern >>(v:sht,b:bat[:oid,:sht]) :bat[:oid,:sht]
address CMDbatRSHcstsignal
comment "Return V >> B, raise error on out of range second operand";
pattern rsh_noerror(v:sht,b:bat[:oid,:sht]) :bat[:oid,:sht]
address CMDbatRSHcst
comment "Return V >> B, out of range second operand causes NIL value";

command >>(b1:bat[:oid,:sht],b2:bat[:oid,:int]) :bat[:oid,:sht]
address CMDbatRSHsignal
comment "Return B1 >> B2, raise error on out of range second operand";
command >>(b1:bat[:oid,:sht],b2:bat[:oid,:int],accum:int) :bat[:oid,:sht]
address CMDbatRSHsignalaccum
comment "Return B1 >> B2, raise error on out of range second operand, reuse B if ACCUM is set";
command rsh_noerror(b1:bat[:oid,:sht],b2:bat[:oid,:int]) :bat[:oid,:sht]
address CMDbatRSH
comment "Return B1 >> B2, out of range second operand causes NIL value";
pattern >>(b:bat[:oid,:sht],v:int) :bat[:oid,:sht]
address CMDbatRSHcstsignal
comment "Return B >> V, raise error on out of range second operand";
pattern >>(b:bat[:oid,:sht],v:int,accum:int) :bat[:oid,:sht]
address CMDbatRSHcstsignal
comment "Return B >> V, raise error on out of range second operand, reuse B if ACCUM is set";
pattern rsh_noerror(b:bat[:oid,:sht],v:int) :bat[:oid,:sht]
address CMDbatRSHcst
comment "Return B >> V, out of range second operand causes NIL value";
pattern >>(v:sht,b:bat[:oid,:int]) :bat[:oid,:sht]
address CMDbatRSHcstsignal
comment "Return V >> B, raise error on out of range second operand";
pattern rsh_noerror(v:sht,b:bat[:oid,:int]) :bat[:oid,:sht]
address CMDbatRSHcst
comment "Return V >> B, out of range second operand causes NIL value";

command >>(b1:bat[:oid,:sht],b2:bat[:oid,:wrd]) :bat[:oid,:sht]
address CMDbatRSHsignal
comment "Return B1 >> B2, raise error on out of range second operand";
command >>(b1:bat[:oid,:sht],b2:bat[:oid,:wrd],accum:int) :bat[:oid,:sht]
address CMDbatRSHsignalaccum
comment "Return B1 >> B2, raise error on out of range second operand, reuse B if ACCUM is set";
command rsh_noerror(b1:bat[:oid,:sht],b2:bat[:oid,:wrd]) :bat[:oid,:sht]
address CMDbatRSH
comment "Return B1 >> B2, out of range second operand causes NIL value";
pattern >>(b:bat[:oid,:sht],v:wrd) :bat[:oid,:sht]
address CMDbatRSHcstsignal
comment "Return B >> V, raise error on out of range second operand";
pattern >>(b:bat[:oid,:sht],v:wrd,accum:int) :bat[:oid,:sht]
address CMDbatRSHcstsignal
comment "Return B >> V, raise error on out of range second operand, reuse B if ACCUM is set";
pattern rsh_noerror(b:bat[:oid,:sht],v:wrd) :bat[:oid,:sht]
address CMDbatRSHcst
comment "Return B >> V, out of range second operand causes NIL value";
pattern >>(v:sht,b:bat[:oid,:wrd]) :bat[:oid,:sht]
address CMDbatRSHcstsignal
comment "Return V >> B, raise error on out of range second operand";
pattern rsh_noerror(v:sht,b:bat[:oid,:wrd]) :bat[:oid,:sht]
address CMDbatRSHcst
comment "Return V >> B, out of range second operand causes NIL value";

command >>(b1:bat[:oid,:sht],b2:bat[:oid,:lng]) :bat[:oid,:sht]
address CMDbatRSHsignal
comment "Return B1 >> B2, raise error on out of range second operand";
command >>(b1:bat[:oid,:sht],b2:bat[:oid,:lng],accum:int) :bat[:oid,:sht]
address CMDbatRSHsignalaccum
comment "Return B1 >> B2, raise error on out of range second operand, reuse B if ACCUM is set";
command rsh_noerror(b1:bat[:oid,:sht],b2:bat[:oid,:lng]) :bat[:oid,:sht]
address CMDbatRSH
comment "Return B1 >> B2, out of range second operand causes NIL value";
pattern >>(b:bat[:oid,:sht],v:lng) :bat[:oid,:sht]
address CMDbatRSHcstsignal
comment "Return B >> V, raise error on out of range second operand";
pattern >>(b:bat[:oid,:sht],v:lng,accum:int) :bat[:oid,:sht]
address CMDbatRSHcstsignal
comment "Return B >> V, raise error on out of range second operand, reuse B if ACCUM is set";
pattern rsh_noerror(b:bat[:oid,:sht],v:lng) :bat[:oid,:sht]
address CMDbatRSHcst
comment "Return B >> V, out of range second operand causes NIL value";
pattern >>(v:sht,b:bat[:oid,:lng]) :bat[:oid,:sht]
address CMDbatRSHcstsignal
comment "Return V >> B, raise error on out of range second operand";
pattern rsh_noerror(v:sht,b:bat[:oid,:lng]) :bat[:oid,:sht]
address CMDbatRSHcst
comment "Return V >> B, out of range second operand causes NIL value";

command >>(b1:bat[:oid,:int],b2:bat[:oid,:bte]) :bat[:oid,:int]
address CMDbatRSHsignal
comment "Return B1 >> B2, raise error on out of range second operand";
command >>(b1:bat[:oid,:int],b2:bat[:oid,:bte],accum:int) :bat[:oid,:int]
address CMDbatRSHsignalaccum
comment "Return B1 >> B2, raise error on out of range second operand, reuse B if ACCUM is set";
command rsh_noerror(b1:bat[:oid,:int],b2:bat[:oid,:bte]) :bat[:oid,:int]
address CMDbatRSH
comment "Return B1 >> B2, out of range second operand causes NIL value";
pattern >>(b:bat[:oid,:int],v:bte) :bat[:oid,:int]
address CMDbatRSHcstsignal
comment "Return B >> V, raise error on out of range second operand";
pattern >>(b:bat[:oid,:int],v:bte,accum:int) :bat[:oid,:int]
address CMDbatRSHcstsignal
comment "Return B >> V, raise error on out of range second operand, reuse B if ACCUM is set";
pattern rsh_noerror(b:bat[:oid,:int],v:bte) :bat[:oid,:int]
address CMDbatRSHcst
comment "Return B >> V, out of range second operand causes NIL value";
pattern >>(v:int,b:bat[:oid,:bte]) :bat[:oid,:int]
address CMDbatRSHcstsignal
comment "Return V >> B, raise error on out of range second operand";
pattern rsh_noerror(v:int,b:bat[:oid,:bte]) :bat[:oid,:int]
address CMDbatRSHcst
comment "Return V >> B, out of range second operand causes NIL value";

command >>(b1:bat[:oid,:int],b2:bat[:oid,:sht]) :bat[:oid,:int]
address CMDbatRSHsignal
comment "Return B1 >> B2, raise error on out of range second operand";
command >>(b1:bat[:oid,:int],b2:bat[:oid,:sht],accum:int) :bat[:oid,:int]
address CMDbatRSHsignalaccum
comment "Return B1 >> B2, raise error on out of range second operand, reuse B if ACCUM is set";
command rsh_noerror(b1:bat[:oid,:int],b2:bat[:oid,:sht]) :bat[:oid,:int]
address CMDbatRSH
comment "Return B1 >> B2, out of range second operand causes NIL value";
pattern >>(b:bat[:oid,:int],v:sht) :bat[:oid,:int]
address CMDbatRSHcstsignal
comment "Return B >> V, raise error on out of range second operand";
pattern >>(b:bat[:oid,:int],v:sht,accum:int) :bat[:oid,:int]
address CMDbatRSHcstsignal
comment "Return B >> V, raise error on out of range second operand, reuse B if ACCUM is set";
pattern rsh_noerror(b:bat[:oid,:int],v:sht) :bat[:oid,:int]
address CMDbatRSHcst
comment "Return B >> V, out of range second operand causes NIL value";
pattern >>(v:int,b:bat[:oid,:sht]) :bat[:oid,:int]
address CMDbatRSHcstsignal
comment "Return V >> B, raise error on out of range second operand";
pattern rsh_noerror(v:int,b:bat[:oid,:sht]) :bat[:oid,:int]
address CMDbatRSHcst
comment "Return V >> B, out of range second operand causes NIL value";

command >>(b1:bat[:oid,:int],b2:bat[:oid,:int]) :bat[:oid,:int]
address CMDbatRSHsignal
comment "Return B1 >> B2, raise error on out of range second operand";
command >>(b1:bat[:oid,:int],b2:bat[:oid,:int],accum:int) :bat[:oid,:int]
address CMDbatRSHsignalaccum
comment "Return B1 >> B2, raise error on out of range second operand, reuse B if ACCUM is set";
command rsh_noerror(b1:bat[:oid,:int],b2:bat[:oid,:int]) :bat[:oid,:int]
address CMDbatRSH
comment "Return B1 >> B2, out of range second operand causes NIL value";
pattern >>(b:bat[:oid,:int],v:int) :bat[:oid,:int]
address CMDbatRSHcstsignal
comment "Return B >> V, raise error on out of range second operand";
pattern >>(b:bat[:oid,:int],v:int,accum:int) :bat[:oid,:int]
address CMDbatRSHcstsignal
comment "Return B >> V, raise error on out of range second operand, reuse B if ACCUM is set";
pattern rsh_noerror(b:bat[:oid,:int],v:int) :bat[:oid,:int]
address CMDbatRSHcst
comment "Return B >> V, out of range second operand causes NIL value";
pattern >>(v:int,b:bat[:oid,:int]) :bat[:oid,:int]
address CMDbatRSHcstsignal
comment "Return V >> B, raise error on out of range second operand";
pattern rsh_noerror(v:int,b:bat[:oid,:int]) :bat[:oid,:int]
address CMDbatRSHcst
comment "Return V >> B, out of range second operand causes NIL value";

command >>(b1:bat[:oid,:int],b2:bat[:oid,:wrd]) :bat[:oid,:int]
address CMDbatRSHsignal
comment "Return B1 >> B2, raise error on out of range second operand";
command >>(b1:bat[:oid,:int],b2:bat[:oid,:wrd],accum:int) :bat[:oid,:int]
address CMDbatRSHsignalaccum
comment "Return B1 >> B2, raise error on out of range second operand, reuse B if ACCUM is set";
command rsh_noerror(b1:bat[:oid,:int],b2:bat[:oid,:wrd]) :bat[:oid,:int]
address CMDbatRSH
comment "Return B1 >> B2, out of range second operand causes NIL value";
pattern >>(b:bat[:oid,:int],v:wrd) :bat[:oid,:int]
address CMDbatRSHcstsignal
comment "Return B >> V, raise error on out of range second operand";
pattern >>(b:bat[:oid,:int],v:wrd,accum:int) :bat[:oid,:int]
address CMDbatRSHcstsignal
comment "Return B >> V, raise error on out of range second operand, reuse B if ACCUM is set";
pattern rsh_noerror(b:bat[:oid,:int],v:wrd) :bat[:oid,:int]
address CMDbatRSHcst
comment "Return B >> V, out of range second operand causes NIL value";
pattern >>(v:int,b:bat[:oid,:wrd]) :bat[:oid,:int]
address CMDbatRSHcstsignal
comment "Return V >> B, raise error on out of range second operand";
pattern rsh_noerror(v:int,b:bat[:oid,:wrd]) :bat[:oid,:int]
address CMDbatRSHcst
comment "Return V >> B, out of range second operand causes NIL value";

command >>(b1:bat[:oid,:int],b2:bat[:oid,:lng]) :bat[:oid,:int]
address CMDbatRSHsignal
comment "Return B1 >> B2, raise error on out of range second operand";
command >>(b1:bat[:oid,:int],b2:bat[:oid,:lng],accum:int) :bat[:oid,:int]
address CMDbatRSHsignalaccum
comment "Return B1 >> B2, raise error on out of range second operand, reuse B if ACCUM is set";
command rsh_noerror(b1:bat[:oid,:int],b2:bat[:oid,:lng]) :bat[:oid,:int]
address CMDbatRSH
comment "Return B1 >> B2, out of range second operand causes NIL value";
pattern >>(b:bat[:oid,:int],v:lng) :bat[:oid,:int]
address CMDbatRSHcstsignal
comment "Return B >> V, raise error on out of range second operand";
pattern >>(b:bat[:oid,:int],v:lng,accum:int) :bat[:oid,:int]
address CMDbatRSHcstsignal
comment "Return B >> V, raise error on out of range second operand, reuse B if ACCUM is set";
pattern rsh_noerror(b:bat[:oid,:int],v:lng) :bat[:oid,:int]
address CMDbatRSHcst
comment "Return B >> V, out of range second operand causes NIL value";
pattern >>(v:int,b:bat[:oid,:lng]) :bat[:oid,:int]
address CMDbatRSHcstsignal
comment "Return V >> B, raise error on out of range second operand";
pattern rsh_noerror(v:int,b:bat[:oid,:lng]) :bat[:oid,:int]
address CMDbatRSHcst
comment "Return V >> B, out of range second operand causes NIL value";

command >>(b1:bat[:oid,:wrd],b2:bat[:oid,:bte]) :bat[:oid,:wrd]
address CMDbatRSHsignal
comment "Return B1 >> B2, raise error on out of range second operand";
command >>(b1:bat[:oid,:wrd],b2:bat[:oid,:bte],accum:int) :bat[:oid,:wrd]
address CMDbatRSHsignalaccum
comment "Return B1 >> B2, raise error on out of range second operand, reuse B if ACCUM is set";
command rsh_noerror(b1:bat[:oid,:wrd],b2:bat[:oid,:bte]) :bat[:oid,:wrd]
address CMDbatRSH
comment "Return B1 >> B2, out of range second operand causes NIL value";
pattern >>(b:bat[:oid,:wrd],v:bte) :bat[:oid,:wrd]
address CMDbatRSHcstsignal
comment "Return B >> V, raise error on out of range second operand";
pattern >>(b:bat[:oid,:wrd],v:bte,accum:int) :bat[:oid,:wrd]
address CMDbatRSHcstsignal
comment "Return B >> V, raise error on out of range second operand, reuse B if ACCUM is set";
pattern rsh_noerror(b:bat[:oid,:wrd],v:bte) :bat[:oid,:wrd]
address CMDbatRSHcst
comment "Return B >> V, out of range second operand causes NIL value";
pattern >>(v:wrd,b:bat[:oid,:bte]) :bat[:oid,:wrd]
address CMDbatRSHcstsignal
comment "Return V >> B, raise error on out of range second operand";
pattern rsh_noerror(v:wrd,b:bat[:oid,:bte]) :bat[:oid,:wrd]
address CMDbatRSHcst
comment "Return V >> B, out of range second operand causes NIL value";

command >>(b1:bat[:oid,:wrd],b2:bat[:oid,:sht]) :bat[:oid,:wrd]
address CMDbatRSHsignal
comment "Return B1 >> B2, raise error on out of range second operand";
command >>(b1:bat[:oid,:wrd],b2:bat[:oid,:sht],accum:int) :bat[:oid,:wrd]
address CMDbatRSHsignalaccum
comment "Return B1 >> B2, raise error on out of range second operand, reuse B if ACCUM is set";
command rsh_noerror(b1:bat[:oid,:wrd],b2:bat[:oid,:sht]) :bat[:oid,:wrd]
address CMDbatRSH
comment "Return B1 >> B2, out of range second operand causes NIL value";
pattern >>(b:bat[:oid,:wrd],v:sht) :bat[:oid,:wrd]
address CMDbatRSHcstsignal
comment "Return B >> V, raise error on out of range second operand";
pattern >>(b:bat[:oid,:wrd],v:sht,accum:int) :bat[:oid,:wrd]
address CMDbatRSHcstsignal
comment "Return B >> V, raise error on out of range second operand, reuse B if ACCUM is set";
pattern rsh_noerror(b:bat[:oid,:wrd],v:sht) :bat[:oid,:wrd]
address CMDbatRSHcst
comment "Return B >> V, out of range second operand causes NIL value";
pattern >>(v:wrd,b:bat[:oid,:sht]) :bat[:oid,:wrd]
address CMDbatRSHcstsignal
comment "Return V >> B, raise error on out of range second operand";
pattern rsh_noerror(v:wrd,b:bat[:oid,:sht]) :bat[:oid,:wrd]
address CMDbatRSHcst
comment "Return V >> B, out of range second operand causes NIL value";

command >>(b1:bat[:oid,:wrd],b2:bat[:oid,:int]) :bat[:oid,:wrd]
address CMDbatRSHsignal
comment "Return B1 >> B2, raise error on out of range second operand";
command >>(b1:bat[:oid,:wrd],b2:bat[:oid,:int],accum:int) :bat[:oid,:wrd]
address CMDbatRSHsignalaccum
comment "Return B1 >> B2, raise error on out of range second operand, reuse B if ACCUM is set";
command rsh_noerror(b1:bat[:oid,:wrd],b2:bat[:oid,:int]) :bat[:oid,:wrd]
address CMDbatRSH
comment "Return B1 >> B2, out of range second operand causes NIL value";
pattern >>(b:bat[:oid,:wrd],v:int) :bat[:oid,:wrd]
address CMDbatRSHcstsignal
comment "Return B >> V, raise error on out of range second operand";
pattern >>(b:bat[:oid,:wrd],v:int,accum:int) :bat[:oid,:wrd]
address CMDbatRSHcstsignal
comment "Return B >> V, raise error on out of range second operand, reuse B if ACCUM is set";
pattern rsh_noerror(b:bat[:oid,:wrd],v:int) :bat[:oid,:wrd]
address CMDbatRSHcst
comment "Return B >> V, out of range second operand causes NIL value";
pattern >>(v:wrd,b:bat[:oid,:int]) :bat[:oid,:wrd]
address CMDbatRSHcstsignal
comment "Return V >> B, raise error on out of range second operand";
pattern rsh_noerror(v:wrd,b:bat[:oid,:int]) :bat[:oid,:wrd]
address CMDbatRSHcst
comment "Return V >> B, out of range second operand causes NIL value";

command >>(b1:bat[:oid,:wrd],b2:bat[:oid,:wrd]) :bat[:oid,:wrd]
address CMDbatRSHsignal
comment "Return B1 >> B2, raise error on out of range second operand";
command >>(b1:bat[:oid,:wrd],b2:bat[:oid,:wrd],accum:int) :bat[:oid,:wrd]
address CMDbatRSHsignalaccum
comment "Return B1 >> B2, raise error on out of range second operand, reuse B if ACCUM is set";
command rsh_noerror(b1:bat[:oid,:wrd],b2:bat[:oid,:wrd]) :bat[:oid,:wrd]
address CMDbatRSH
comment "Return B1 >> B2, out of range second operand causes NIL value";
pattern >>(b:bat[:oid,:wrd],v:wrd) :bat[:oid,:wrd]
address CMDbatRSHcstsignal
comment "Return B >> V, raise error on out of range second operand";
pattern >>(b:bat[:oid,:wrd],v:wrd,accum:int) :bat[:oid,:wrd]
address CMDbatRSHcstsignal
comment "Return B >> V, raise error on out of range second operand, reuse B if ACCUM is set";
pattern rsh_noerror(b:bat[:oid,:wrd],v:wrd) :bat[:oid,:wrd]
address CMDbatRSHcst
comment "Return B >> V, out of range second operand causes NIL value";
pattern >>(v:wrd,b:bat[:oid,:wrd]) :bat[:oid,:wrd]
address CMDbatRSHcstsignal
comment "Return V >> B, raise error on out of range second operand";
pattern rsh_noerror(v:wrd,b:bat[:oid,:wrd]) :bat[:oid,:wrd]
address CMDbatRSHcst
comment "Return V >> B, out of range second operand causes NIL value";

command >>(b1:bat[:oid,:wrd],b2:bat[:oid,:lng]) :bat[:oid,:wrd]
address CMDbatRSHsignal
comment "Return B1 >> B2, raise error on out of range second operand";
command >>(b1:bat[:oid,:wrd],b2:bat[:oid,:lng],accum:int) :bat[:oid,:wrd]
address CMDbatRSHsignalaccum
comment "Return B1 >> B2, raise error on out of range second operand, reuse B if ACCUM is set";
command rsh_noerror(b1:bat[:oid,:wrd],b2:bat[:oid,:lng]) :bat[:oid,:wrd]
address CMDbatRSH
comment "Return B1 >> B2, out of range second operand causes NIL value";
pattern >>(b:bat[:oid,:wrd],v:lng) :bat[:oid,:wrd]
address CMDbatRSHcstsignal
comment "Return B >> V, raise error on out of range second operand";
pattern >>(b:bat[:oid,:wrd],v:lng,accum:int) :bat[:oid,:wrd]
address CMDbatRSHcstsignal
comment "Return B >> V, raise error on out of range second operand, reuse B if ACCUM is set";
pattern rsh_noerror(b:bat[:oid,:wrd],v:lng) :bat[:oid,:wrd]
address CMDbatRSHcst
comment "Return B >> V, out of range second operand causes NIL value";
pattern >>(v:wrd,b:bat[:oid,:lng]) :bat[:oid,:wrd]
address CMDbatRSHcstsignal
comment "Return V >> B, raise error on out of range second operand";
pattern rsh_noerror(v:wrd,b:bat[:oid,:lng]) :bat[:oid,:wrd]
address CMDbatRSHcst
comment "Return V >> B, out of range second operand causes NIL value";

command >>(b1:bat[:oid,:lng],b2:bat[:oid,:bte]) :bat[:oid,:lng]
address CMDbatRSHsignal
comment "Return B1 >> B2, raise error on out of range second operand";
command >>(b1:bat[:oid,:lng],b2:bat[:oid,:bte],accum:int) :bat[:oid,:lng]
address CMDbatRSHsignalaccum
comment "Return B1 >> B2, raise error on out of range second operand, reuse B if ACCUM is set";
command rsh_noerror(b1:bat[:oid,:lng],b2:bat[:oid,:bte]) :bat[:oid,:lng]
address CMDbatRSH
comment "Return B1 >> B2, out of range second operand causes NIL value";
pattern >>(b:bat[:oid,:lng],v:bte) :bat[:oid,:lng]
address CMDbatRSHcstsignal
comment "Return B >> V, raise error on out of range second operand";
pattern >>(b:bat[:oid,:lng],v:bte,accum:int) :bat[:oid,:lng]
address CMDbatRSHcstsignal
comment "Return B >> V, raise error on out of range second operand, reuse B if ACCUM is set";
pattern rsh_noerror(b:bat[:oid,:lng],v:bte) :bat[:oid,:lng]
address CMDbatRSHcst
comment "Return B >> V, out of range second operand causes NIL value";
pattern >>(v:lng,b:bat[:oid,:bte]) :bat[:oid,:lng]
address CMDbatRSHcstsignal
comment "Return V >> B, raise error on out of range second operand";
pattern rsh_noerror(v:lng,b:bat[:oid,:bte]) :bat[:oid,:lng]
address CMDbatRSHcst
comment "Return V >> B, out of range second operand causes NIL value";

command >>(b1:bat[:oid,:lng],b2:bat[:oid,:sht]) :bat[:oid,:lng]
address CMDbatRSHsignal
comment "Return B1 >> B2, raise error on out of range second operand";
command >>(b1:bat[:oid,:lng],b2:bat[:oid,:sht],accum:int) :bat[:oid,:lng]
address CMDbatRSHsignalaccum
comment "Return B1 >> B2, raise error on out of range second operand, reuse B if ACCUM is set";
command rsh_noerror(b1:bat[:oid,:lng],b2:bat[:oid,:sht]) :bat[:oid,:lng]
address CMDbatRSH
comment "Return B1 >> B2, out of range second operand causes NIL value";
pattern >>(b:bat[:oid,:lng],v:sht) :bat[:oid,:lng]
address CMDbatRSHcstsignal
comment "Return B >> V, raise error on out of range second operand";
pattern >>(b:bat[:oid,:lng],v:sht,accum:int) :bat[:oid,:lng]
address CMDbatRSHcstsignal
comment "Return B >> V, raise error on out of range second operand, reuse B if ACCUM is set";
pattern rsh_noerror(b:bat[:oid,:lng],v:sht) :bat[:oid,:lng]
address CMDbatRSHcst
comment "Return B >> V, out of range second operand causes NIL value";
pattern >>(v:lng,b:bat[:oid,:sht]) :bat[:oid,:lng]
address CMDbatRSHcstsignal
comment "Return V >> B, raise error on out of range second operand";
pattern rsh_noerror(v:lng,b:bat[:oid,:sht]) :bat[:oid,:lng]
address CMDbatRSHcst
comment "Return V >> B, out of range second operand causes NIL value";

command >>(b1:bat[:oid,:lng],b2:bat[:oid,:int]) :bat[:oid,:lng]
address CMDbatRSHsignal
comment "Return B1 >> B2, raise error on out of range second operand";
command >>(b1:bat[:oid,:lng],b2:bat[:oid,:int],accum:int) :bat[:oid,:lng]
address CMDbatRSHsignalaccum
comment "Return B1 >> B2, raise error on out of range second operand, reuse B if ACCUM is set";
command rsh_noerror(b1:bat[:oid,:lng],b2:bat[:oid,:int]) :bat[:oid,:lng]
address CMDbatRSH
comment "Return B1 >> B2, out of range second operand causes NIL value";
pattern >>(b:bat[:oid,:lng],v:int) :bat[:oid,:lng]
address CMDbatRSHcstsignal
comment "Return B >> V, raise error on out of range second operand";
pattern >>(b:bat[:oid,:lng],v:int,accum:int) :bat[:oid,:lng]
address CMDbatRSHcstsignal
comment "Return B >> V, raise error on out of range second operand, reuse B if ACCUM is set";
pattern rsh_noerror(b:bat[:oid,:lng],v:int) :bat[:oid,:lng]
address CMDbatRSHcst
comment "Return B >> V, out of range second operand causes NIL value";
pattern >>(v:lng,b:bat[:oid,:int]) :bat[:oid,:lng]
address CMDbatRSHcstsignal
comment "Return V >> B, raise error on out of range second operand";
pattern rsh_noerror(v:lng,b:bat[:oid,:int]) :bat[:oid,:lng]
address CMDbatRSHcst
comment "Return V >> B, out of range second operand causes NIL value";

command >>(b1:bat[:oid,:lng],b2:bat[:oid,:wrd]) :bat[:oid,:lng]
address CMDbatRSHsignal
comment "Return B1 >> B2, raise error on out of range second operand";
command >>(b1:bat[:oid,:lng],b2:bat[:oid,:wrd],accum:int) :bat[:oid,:lng]
address CMDbatRSHsignalaccum
comment "Return B1 >> B2, raise error on out of range second operand, reuse B if ACCUM is set";
command rsh_noerror(b1:bat[:oid,:lng],b2:bat[:oid,:wrd]) :bat[:oid,:lng]
address CMDbatRSH
comment "Return B1 >> B2, out of range second operand causes NIL value";
pattern >>(b:bat[:oid,:lng],v:wrd) :bat[:oid,:lng]
address CMDbatRSHcstsignal
comment "Return B >> V, raise error on out of range second operand";
pattern >>(b:bat[:oid,:lng],v:wrd,accum:int) :bat[:oid,:lng]
address CMDbatRSHcstsignal
comment "Return B >> V, raise error on out of range second operand, reuse B if ACCUM is set";
pattern rsh_noerror(b:bat[:oid,:lng],v:wrd) :bat[:oid,:lng]
address CMDbatRSHcst
comment "Return B >> V, out of range second operand causes NIL value";
pattern >>(v:lng,b:bat[:oid,:wrd]) :bat[:oid,:lng]
address CMDbatRSHcstsignal
comment "Return V >> B, raise error on out of range second operand";
pattern rsh_noerror(v:lng,b:bat[:oid,:wrd]) :bat[:oid,:lng]
address CMDbatRSHcst
comment "Return V >> B, out of range second operand causes NIL value";

command >>(b1:bat[:oid,:lng],b2:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatRSHsignal
comment "Return B1 >> B2, raise error on out of range second operand";
command >>(b1:bat[:oid,:lng],b2:bat[:oid,:lng],accum:int) :bat[:oid,:lng]
address CMDbatRSHsignalaccum
comment "Return B1 >> B2, raise error on out of range second operand, reuse B if ACCUM is set";
command rsh_noerror(b1:bat[:oid,:lng],b2:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatRSH
comment "Return B1 >> B2, out of range second operand causes NIL value";
pattern >>(b:bat[:oid,:lng],v:lng) :bat[:oid,:lng]
address CMDbatRSHcstsignal
comment "Return B >> V, raise error on out of range second operand";
pattern >>(b:bat[:oid,:lng],v:lng,accum:int) :bat[:oid,:lng]
address CMDbatRSHcstsignal
comment "Return B >> V, raise error on out of range second operand, reuse B if ACCUM is set";
pattern rsh_noerror(b:bat[:oid,:lng],v:lng) :bat[:oid,:lng]
address CMDbatRSHcst
comment "Return B >> V, out of range second operand causes NIL value";
pattern >>(v:lng,b:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatRSHcstsignal
comment "Return V >> B, raise error on out of range second operand";
pattern rsh_noerror(v:lng,b:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatRSHcst
comment "Return V >> B, out of range second operand causes NIL value";


command <(b1:bat[:oid,:bit],b2:bat[:oid,:bit]) :bat[:oid,:bit]
address CMDbatLT
comment "Return B1 < B2";
pattern <(b:bat[:oid,:bit],v:bit) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return B < V";
pattern <(v:bit,b:bat[:oid,:bit]) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return V < B";

command <(b1:bat[:oid,:str],b2:bat[:oid,:str]) :bat[:oid,:bit]
address CMDbatLT
comment "Return B1 < B2";
pattern <(b:bat[:oid,:str],v:str) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return B < V";
pattern <(v:str,b:bat[:oid,:str]) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return V < B";

command <(b1:bat[:oid,:oid],b2:bat[:oid,:oid]) :bat[:oid,:bit]
address CMDbatLT
comment "Return B1 < B2";
pattern <(b:bat[:oid,:oid],v:oid) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return B < V";
pattern <(v:oid,b:bat[:oid,:oid]) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return V < B";

command <(b1:bat[:oid,:bte],b2:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatLT
comment "Return B1 < B2";
pattern <(b:bat[:oid,:bte],v:bte) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return B < V";
pattern <(v:bte,b:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return V < B";

command <(b1:bat[:oid,:bte],b2:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatLT
comment "Return B1 < B2";
pattern <(b:bat[:oid,:bte],v:sht) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return B < V";
pattern <(v:bte,b:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return V < B";

command <(b1:bat[:oid,:bte],b2:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatLT
comment "Return B1 < B2";
pattern <(b:bat[:oid,:bte],v:int) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return B < V";
pattern <(v:bte,b:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return V < B";

command <(b1:bat[:oid,:bte],b2:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatLT
comment "Return B1 < B2";
pattern <(b:bat[:oid,:bte],v:wrd) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return B < V";
pattern <(v:bte,b:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return V < B";

command <(b1:bat[:oid,:bte],b2:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatLT
comment "Return B1 < B2";
pattern <(b:bat[:oid,:bte],v:lng) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return B < V";
pattern <(v:bte,b:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return V < B";

command <(b1:bat[:oid,:bte],b2:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatLT
comment "Return B1 < B2";
pattern <(b:bat[:oid,:bte],v:flt) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return B < V";
pattern <(v:bte,b:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return V < B";

command <(b1:bat[:oid,:bte],b2:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatLT
comment "Return B1 < B2";
pattern <(b:bat[:oid,:bte],v:dbl) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return B < V";
pattern <(v:bte,b:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return V < B";

command <(b1:bat[:oid,:sht],b2:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatLT
comment "Return B1 < B2";
pattern <(b:bat[:oid,:sht],v:bte) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return B < V";
pattern <(v:sht,b:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return V < B";

command <(b1:bat[:oid,:sht],b2:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatLT
comment "Return B1 < B2";
pattern <(b:bat[:oid,:sht],v:sht) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return B < V";
pattern <(v:sht,b:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return V < B";

command <(b1:bat[:oid,:sht],b2:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatLT
comment "Return B1 < B2";
pattern <(b:bat[:oid,:sht],v:int) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return B < V";
pattern <(v:sht,b:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return V < B";

command <(b1:bat[:oid,:sht],b2:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatLT
comment "Return B1 < B2";
pattern <(b:bat[:oid,:sht],v:wrd) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return B < V";
pattern <(v:sht,b:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return V < B";

command <(b1:bat[:oid,:sht],b2:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatLT
comment "Return B1 < B2";
pattern <(b:bat[:oid,:sht],v:lng) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return B < V";
pattern <(v:sht,b:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return V < B";

command <(b1:bat[:oid,:sht],b2:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatLT
comment "Return B1 < B2";
pattern <(b:bat[:oid,:sht],v:flt) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return B < V";
pattern <(v:sht,b:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return V < B";

command <(b1:bat[:oid,:sht],b2:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatLT
comment "Return B1 < B2";
pattern <(b:bat[:oid,:sht],v:dbl) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return B < V";
pattern <(v:sht,b:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return V < B";

command <(b1:bat[:oid,:int],b2:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatLT
comment "Return B1 < B2";
pattern <(b:bat[:oid,:int],v:bte) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return B < V";
pattern <(v:int,b:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return V < B";

command <(b1:bat[:oid,:int],b2:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatLT
comment "Return B1 < B2";
pattern <(b:bat[:oid,:int],v:sht) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return B < V";
pattern <(v:int,b:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return V < B";

command <(b1:bat[:oid,:int],b2:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatLT
comment "Return B1 < B2";
pattern <(b:bat[:oid,:int],v:int) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return B < V";
pattern <(v:int,b:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return V < B";

command <(b1:bat[:oid,:int],b2:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatLT
comment "Return B1 < B2";
pattern <(b:bat[:oid,:int],v:wrd) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return B < V";
pattern <(v:int,b:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return V < B";

command <(b1:bat[:oid,:int],b2:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatLT
comment "Return B1 < B2";
pattern <(b:bat[:oid,:int],v:lng) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return B < V";
pattern <(v:int,b:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return V < B";

command <(b1:bat[:oid,:int],b2:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatLT
comment "Return B1 < B2";
pattern <(b:bat[:oid,:int],v:flt) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return B < V";
pattern <(v:int,b:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return V < B";

command <(b1:bat[:oid,:int],b2:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatLT
comment "Return B1 < B2";
pattern <(b:bat[:oid,:int],v:dbl) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return B < V";
pattern <(v:int,b:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return V < B";

command <(b1:bat[:oid,:wrd],b2:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatLT
comment "Return B1 < B2";
pattern <(b:bat[:oid,:wrd],v:bte) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return B < V";
pattern <(v:wrd,b:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return V < B";

command <(b1:bat[:oid,:wrd],b2:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatLT
comment "Return B1 < B2";
pattern <(b:bat[:oid,:wrd],v:sht) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return B < V";
pattern <(v:wrd,b:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return V < B";

command <(b1:bat[:oid,:wrd],b2:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatLT
comment "Return B1 < B2";
pattern <(b:bat[:oid,:wrd],v:int) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return B < V";
pattern <(v:wrd,b:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return V < B";

command <(b1:bat[:oid,:wrd],b2:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatLT
comment "Return B1 < B2";
pattern <(b:bat[:oid,:wrd],v:wrd) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return B < V";
pattern <(v:wrd,b:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return V < B";

command <(b1:bat[:oid,:wrd],b2:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatLT
comment "Return B1 < B2";
pattern <(b:bat[:oid,:wrd],v:lng) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return B < V";
pattern <(v:wrd,b:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return V < B";

command <(b1:bat[:oid,:wrd],b2:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatLT
comment "Return B1 < B2";
pattern <(b:bat[:oid,:wrd],v:flt) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return B < V";
pattern <(v:wrd,b:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return V < B";

command <(b1:bat[:oid,:wrd],b2:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatLT
comment "Return B1 < B2";
pattern <(b:bat[:oid,:wrd],v:dbl) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return B < V";
pattern <(v:wrd,b:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return V < B";

command <(b1:bat[:oid,:lng],b2:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatLT
comment "Return B1 < B2";
pattern <(b:bat[:oid,:lng],v:bte) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return B < V";
pattern <(v:lng,b:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return V < B";

command <(b1:bat[:oid,:lng],b2:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatLT
comment "Return B1 < B2";
pattern <(b:bat[:oid,:lng],v:sht) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return B < V";
pattern <(v:lng,b:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return V < B";

command <(b1:bat[:oid,:lng],b2:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatLT
comment "Return B1 < B2";
pattern <(b:bat[:oid,:lng],v:int) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return B < V";
pattern <(v:lng,b:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return V < B";

command <(b1:bat[:oid,:lng],b2:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatLT
comment "Return B1 < B2";
pattern <(b:bat[:oid,:lng],v:wrd) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return B < V";
pattern <(v:lng,b:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return V < B";

command <(b1:bat[:oid,:lng],b2:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatLT
comment "Return B1 < B2";
pattern <(b:bat[:oid,:lng],v:lng) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return B < V";
pattern <(v:lng,b:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return V < B";

command <(b1:bat[:oid,:lng],b2:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatLT
comment "Return B1 < B2";
pattern <(b:bat[:oid,:lng],v:flt) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return B < V";
pattern <(v:lng,b:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return V < B";

command <(b1:bat[:oid,:lng],b2:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatLT
comment "Return B1 < B2";
pattern <(b:bat[:oid,:lng],v:dbl) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return B < V";
pattern <(v:lng,b:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return V < B";

command <(b1:bat[:oid,:flt],b2:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatLT
comment "Return B1 < B2";
pattern <(b:bat[:oid,:flt],v:bte) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return B < V";
pattern <(v:flt,b:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return V < B";

command <(b1:bat[:oid,:flt],b2:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatLT
comment "Return B1 < B2";
pattern <(b:bat[:oid,:flt],v:sht) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return B < V";
pattern <(v:flt,b:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return V < B";

command <(b1:bat[:oid,:flt],b2:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatLT
comment "Return B1 < B2";
pattern <(b:bat[:oid,:flt],v:int) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return B < V";
pattern <(v:flt,b:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return V < B";

command <(b1:bat[:oid,:flt],b2:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatLT
comment "Return B1 < B2";
pattern <(b:bat[:oid,:flt],v:wrd) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return B < V";
pattern <(v:flt,b:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return V < B";

command <(b1:bat[:oid,:flt],b2:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatLT
comment "Return B1 < B2";
pattern <(b:bat[:oid,:flt],v:lng) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return B < V";
pattern <(v:flt,b:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return V < B";

command <(b1:bat[:oid,:flt],b2:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatLT
comment "Return B1 < B2";
pattern <(b:bat[:oid,:flt],v:flt) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return B < V";
pattern <(v:flt,b:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return V < B";

command <(b1:bat[:oid,:flt],b2:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatLT
comment "Return B1 < B2";
pattern <(b:bat[:oid,:flt],v:dbl) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return B < V";
pattern <(v:flt,b:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return V < B";

command <(b1:bat[:oid,:dbl],b2:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatLT
comment "Return B1 < B2";
pattern <(b:bat[:oid,:dbl],v:bte) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return B < V";
pattern <(v:dbl,b:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return V < B";

command <(b1:bat[:oid,:dbl],b2:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatLT
comment "Return B1 < B2";
pattern <(b:bat[:oid,:dbl],v:sht) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return B < V";
pattern <(v:dbl,b:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return V < B";

command <(b1:bat[:oid,:dbl],b2:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatLT
comment "Return B1 < B2";
pattern <(b:bat[:oid,:dbl],v:int) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return B < V";
pattern <(v:dbl,b:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return V < B";

command <(b1:bat[:oid,:dbl],b2:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatLT
comment "Return B1 < B2";
pattern <(b:bat[:oid,:dbl],v:wrd) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return B < V";
pattern <(v:dbl,b:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return V < B";

command <(b1:bat[:oid,:dbl],b2:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatLT
comment "Return B1 < B2";
pattern <(b:bat[:oid,:dbl],v:lng) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return B < V";
pattern <(v:dbl,b:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return V < B";

command <(b1:bat[:oid,:dbl],b2:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatLT
comment "Return B1 < B2";
pattern <(b:bat[:oid,:dbl],v:flt) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return B < V";
pattern <(v:dbl,b:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return V < B";

command <(b1:bat[:oid,:dbl],b2:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatLT
comment "Return B1 < B2";
pattern <(b:bat[:oid,:dbl],v:dbl) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return B < V";
pattern <(v:dbl,b:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return V < B";


command <=(b1:bat[:oid,:bit],b2:bat[:oid,:bit]) :bat[:oid,:bit]
address CMDbatLE
comment "Return B1 <= B2";
pattern <=(b:bat[:oid,:bit],v:bit) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return B <= V";
pattern <=(v:bit,b:bat[:oid,:bit]) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return V <= B";

command <=(b1:bat[:oid,:str],b2:bat[:oid,:str]) :bat[:oid,:bit]
address CMDbatLE
comment "Return B1 <= B2";
pattern <=(b:bat[:oid,:str],v:str) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return B <= V";
pattern <=(v:str,b:bat[:oid,:str]) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return V <= B";

command <=(b1:bat[:oid,:oid],b2:bat[:oid,:oid]) :bat[:oid,:bit]
address CMDbatLE
comment "Return B1 <= B2";
pattern <=(b:bat[:oid,:oid],v:oid) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return B <= V";
pattern <=(v:oid,b:bat[:oid,:oid]) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return V <= B";

command <=(b1:bat[:oid,:bte],b2:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatLE
comment "Return B1 <= B2";
pattern <=(b:bat[:oid,:bte],v:bte) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return B <= V";
pattern <=(v:bte,b:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return V <= B";

command <=(b1:bat[:oid,:bte],b2:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatLE
comment "Return B1 <= B2";
pattern <=(b:bat[:oid,:bte],v:sht) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return B <= V";
pattern <=(v:bte,b:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return V <= B";

command <=(b1:bat[:oid,:bte],b2:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatLE
comment "Return B1 <= B2";
pattern <=(b:bat[:oid,:bte],v:int) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return B <= V";
pattern <=(v:bte,b:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return V <= B";

command <=(b1:bat[:oid,:bte],b2:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatLE
comment "Return B1 <= B2";
pattern <=(b:bat[:oid,:bte],v:wrd) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return B <= V";
pattern <=(v:bte,b:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return V <= B";

command <=(b1:bat[:oid,:bte],b2:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatLE
comment "Return B1 <= B2";
pattern <=(b:bat[:oid,:bte],v:lng) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return B <= V";
pattern <=(v:bte,b:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return V <= B";

command <=(b1:bat[:oid,:bte],b2:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatLE
comment "Return B1 <= B2";
pattern <=(b:bat[:oid,:bte],v:flt) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return B <= V";
pattern <=(v:bte,b:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return V <= B";

command <=(b1:bat[:oid,:bte],b2:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatLE
comment "Return B1 <= B2";
pattern <=(b:bat[:oid,:bte],v:dbl) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return B <= V";
pattern <=(v:bte,b:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return V <= B";

command <=(b1:bat[:oid,:sht],b2:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatLE
comment "Return B1 <= B2";
pattern <=(b:bat[:oid,:sht],v:bte) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return B <= V";
pattern <=(v:sht,b:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return V <= B";

command <=(b1:bat[:oid,:sht],b2:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatLE
comment "Return B1 <= B2";
pattern <=(b:bat[:oid,:sht],v:sht) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return B <= V";
pattern <=(v:sht,b:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return V <= B";

command <=(b1:bat[:oid,:sht],b2:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatLE
comment "Return B1 <= B2";
pattern <=(b:bat[:oid,:sht],v:int) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return B <= V";
pattern <=(v:sht,b:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return V <= B";

command <=(b1:bat[:oid,:sht],b2:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatLE
comment "Return B1 <= B2";
pattern <=(b:bat[:oid,:sht],v:wrd) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return B <= V";
pattern <=(v:sht,b:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return V <= B";

command <=(b1:bat[:oid,:sht],b2:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatLE
comment "Return B1 <= B2";
pattern <=(b:bat[:oid,:sht],v:lng) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return B <= V";
pattern <=(v:sht,b:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return V <= B";

command <=(b1:bat[:oid,:sht],b2:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatLE
comment "Return B1 <= B2";
pattern <=(b:bat[:oid,:sht],v:flt) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return B <= V";
pattern <=(v:sht,b:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return V <= B";

command <=(b1:bat[:oid,:sht],b2:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatLE
comment "Return B1 <= B2";
pattern <=(b:bat[:oid,:sht],v:dbl) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return B <= V";
pattern <=(v:sht,b:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return V <= B";

command <=(b1:bat[:oid,:int],b2:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatLE
comment "Return B1 <= B2";
pattern <=(b:bat[:oid,:int],v:bte) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return B <= V";
pattern <=(v:int,b:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return V <= B";

command <=(b1:bat[:oid,:int],b2:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatLE
comment "Return B1 <= B2";
pattern <=(b:bat[:oid,:int],v:sht) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return B <= V";
pattern <=(v:int,b:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return V <= B";

command <=(b1:bat[:oid,:int],b2:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatLE
comment "Return B1 <= B2";
pattern <=(b:bat[:oid,:int],v:int) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return B <= V";
pattern <=(v:int,b:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return V <= B";

command <=(b1:bat[:oid,:int],b2:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatLE
comment "Return B1 <= B2";
pattern <=(b:bat[:oid,:int],v:wrd) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return B <= V";
pattern <=(v:int,b:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return V <= B";

command <=(b1:bat[:oid,:int],b2:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatLE
comment "Return B1 <= B2";
pattern <=(b:bat[:oid,:int],v:lng) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return B <= V";
pattern <=(v:int,b:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return V <= B";

command <=(b1:bat[:oid,:int],b2:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatLE
comment "Return B1 <= B2";
pattern <=(b:bat[:oid,:int],v:flt) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return B <= V";
pattern <=(v:int,b:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return V <= B";

command <=(b1:bat[:oid,:int],b2:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatLE
comment "Return B1 <= B2";
pattern <=(b:bat[:oid,:int],v:dbl) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return B <= V";
pattern <=(v:int,b:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return V <= B";

command <=(b1:bat[:oid,:wrd],b2:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatLE
comment "Return B1 <= B2";
pattern <=(b:bat[:oid,:wrd],v:bte) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return B <= V";
pattern <=(v:wrd,b:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return V <= B";

command <=(b1:bat[:oid,:wrd],b2:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatLE
comment "Return B1 <= B2";
pattern <=(b:bat[:oid,:wrd],v:sht) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return B <= V";
pattern <=(v:wrd,b:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return V <= B";

command <=(b1:bat[:oid,:wrd],b2:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatLE
comment "Return B1 <= B2";
pattern <=(b:bat[:oid,:wrd],v:int) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return B <= V";
pattern <=(v:wrd,b:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return V <= B";

command <=(b1:bat[:oid,:wrd],b2:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatLE
comment "Return B1 <= B2";
pattern <=(b:bat[:oid,:wrd],v:wrd) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return B <= V";
pattern <=(v:wrd,b:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return V <= B";

command <=(b1:bat[:oid,:wrd],b2:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatLE
comment "Return B1 <= B2";
pattern <=(b:bat[:oid,:wrd],v:lng) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return B <= V";
pattern <=(v:wrd,b:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return V <= B";

command <=(b1:bat[:oid,:wrd],b2:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatLE
comment "Return B1 <= B2";
pattern <=(b:bat[:oid,:wrd],v:flt) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return B <= V";
pattern <=(v:wrd,b:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return V <= B";

command <=(b1:bat[:oid,:wrd],b2:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatLE
comment "Return B1 <= B2";
pattern <=(b:bat[:oid,:wrd],v:dbl) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return B <= V";
pattern <=(v:wrd,b:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return V <= B";

command <=(b1:bat[:oid,:lng],b2:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatLE
comment "Return B1 <= B2";
pattern <=(b:bat[:oid,:lng],v:bte) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return B <= V";
pattern <=(v:lng,b:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return V <= B";

command <=(b1:bat[:oid,:lng],b2:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatLE
comment "Return B1 <= B2";
pattern <=(b:bat[:oid,:lng],v:sht) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return B <= V";
pattern <=(v:lng,b:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return V <= B";

command <=(b1:bat[:oid,:lng],b2:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatLE
comment "Return B1 <= B2";
pattern <=(b:bat[:oid,:lng],v:int) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return B <= V";
pattern <=(v:lng,b:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return V <= B";

command <=(b1:bat[:oid,:lng],b2:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatLE
comment "Return B1 <= B2";
pattern <=(b:bat[:oid,:lng],v:wrd) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return B <= V";
pattern <=(v:lng,b:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return V <= B";

command <=(b1:bat[:oid,:lng],b2:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatLE
comment "Return B1 <= B2";
pattern <=(b:bat[:oid,:lng],v:lng) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return B <= V";
pattern <=(v:lng,b:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return V <= B";

command <=(b1:bat[:oid,:lng],b2:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatLE
comment "Return B1 <= B2";
pattern <=(b:bat[:oid,:lng],v:flt) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return B <= V";
pattern <=(v:lng,b:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return V <= B";

command <=(b1:bat[:oid,:lng],b2:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatLE
comment "Return B1 <= B2";
pattern <=(b:bat[:oid,:lng],v:dbl) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return B <= V";
pattern <=(v:lng,b:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return V <= B";

command <=(b1:bat[:oid,:flt],b2:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatLE
comment "Return B1 <= B2";
pattern <=(b:bat[:oid,:flt],v:bte) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return B <= V";
pattern <=(v:flt,b:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return V <= B";

command <=(b1:bat[:oid,:flt],b2:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatLE
comment "Return B1 <= B2";
pattern <=(b:bat[:oid,:flt],v:sht) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return B <= V";
pattern <=(v:flt,b:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return V <= B";

command <=(b1:bat[:oid,:flt],b2:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatLE
comment "Return B1 <= B2";
pattern <=(b:bat[:oid,:flt],v:int) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return B <= V";
pattern <=(v:flt,b:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return V <= B";

command <=(b1:bat[:oid,:flt],b2:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatLE
comment "Return B1 <= B2";
pattern <=(b:bat[:oid,:flt],v:wrd) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return B <= V";
pattern <=(v:flt,b:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return V <= B";

command <=(b1:bat[:oid,:flt],b2:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatLE
comment "Return B1 <= B2";
pattern <=(b:bat[:oid,:flt],v:lng) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return B <= V";
pattern <=(v:flt,b:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return V <= B";

command <=(b1:bat[:oid,:flt],b2:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatLE
comment "Return B1 <= B2";
pattern <=(b:bat[:oid,:flt],v:flt) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return B <= V";
pattern <=(v:flt,b:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return V <= B";

command <=(b1:bat[:oid,:flt],b2:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatLE
comment "Return B1 <= B2";
pattern <=(b:bat[:oid,:flt],v:dbl) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return B <= V";
pattern <=(v:flt,b:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return V <= B";

command <=(b1:bat[:oid,:dbl],b2:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatLE
comment "Return B1 <= B2";
pattern <=(b:bat[:oid,:dbl],v:bte) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return B <= V";
pattern <=(v:dbl,b:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return V <= B";

command <=(b1:bat[:oid,:dbl],b2:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatLE
comment "Return B1 <= B2";
pattern <=(b:bat[:oid,:dbl],v:sht) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return B <= V";
pattern <=(v:dbl,b:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return V <= B";

command <=(b1:bat[:oid,:dbl],b2:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatLE
comment "Return B1 <= B2";
pattern <=(b:bat[:oid,:dbl],v:int) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return B <= V";
pattern <=(v:dbl,b:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return V <= B";

command <=(b1:bat[:oid,:dbl],b2:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatLE
comment "Return B1 <= B2";
pattern <=(b:bat[:oid,:dbl],v:wrd) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return B <= V";
pattern <=(v:dbl,b:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return V <= B";

command <=(b1:bat[:oid,:dbl],b2:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatLE
comment "Return B1 <= B2";
pattern <=(b:bat[:oid,:dbl],v:lng) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return B <= V";
pattern <=(v:dbl,b:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return V <= B";

command <=(b1:bat[:oid,:dbl],b2:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatLE
comment "Return B1 <= B2";
pattern <=(b:bat[:oid,:dbl],v:flt) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return B <= V";
pattern <=(v:dbl,b:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return V <= B";

command <=(b1:bat[:oid,:dbl],b2:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatLE
comment "Return B1 <= B2";
pattern <=(b:bat[:oid,:dbl],v:dbl) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return B <= V";
pattern <=(v:dbl,b:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return V <= B";


command >(b1:bat[:oid,:bit],b2:bat[:oid,:bit]) :bat[:oid,:bit]
address CMDbatGT
comment "Return B1 > B2";
pattern >(b:bat[:oid,:bit],v:bit) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return B > V";
pattern >(v:bit,b:bat[:oid,:bit]) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return V > B";

command >(b1:bat[:oid,:str],b2:bat[:oid,:str]) :bat[:oid,:bit]
address CMDbatGT
comment "Return B1 > B2";
pattern >(b:bat[:oid,:str],v:str) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return B > V";
pattern >(v:str,b:bat[:oid,:str]) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return V > B";

command >(b1:bat[:oid,:oid],b2:bat[:oid,:oid]) :bat[:oid,:bit]
address CMDbatGT
comment "Return B1 > B2";
pattern >(b:bat[:oid,:oid],v:oid) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return B > V";
pattern >(v:oid,b:bat[:oid,:oid]) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return V > B";

command >(b1:bat[:oid,:bte],b2:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatGT
comment "Return B1 > B2";
pattern >(b:bat[:oid,:bte],v:bte) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return B > V";
pattern >(v:bte,b:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return V > B";

command >(b1:bat[:oid,:bte],b2:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatGT
comment "Return B1 > B2";
pattern >(b:bat[:oid,:bte],v:sht) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return B > V";
pattern >(v:bte,b:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return V > B";

command >(b1:bat[:oid,:bte],b2:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatGT
comment "Return B1 > B2";
pattern >(b:bat[:oid,:bte],v:int) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return B > V";
pattern >(v:bte,b:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return V > B";

command >(b1:bat[:oid,:bte],b2:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatGT
comment "Return B1 > B2";
pattern >(b:bat[:oid,:bte],v:wrd) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return B > V";
pattern >(v:bte,b:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return V > B";

command >(b1:bat[:oid,:bte],b2:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatGT
comment "Return B1 > B2";
pattern >(b:bat[:oid,:bte],v:lng) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return B > V";
pattern >(v:bte,b:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return V > B";

command >(b1:bat[:oid,:bte],b2:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatGT
comment "Return B1 > B2";
pattern >(b:bat[:oid,:bte],v:flt) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return B > V";
pattern >(v:bte,b:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return V > B";

command >(b1:bat[:oid,:bte],b2:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatGT
comment "Return B1 > B2";
pattern >(b:bat[:oid,:bte],v:dbl) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return B > V";
pattern >(v:bte,b:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return V > B";

command >(b1:bat[:oid,:sht],b2:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatGT
comment "Return B1 > B2";
pattern >(b:bat[:oid,:sht],v:bte) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return B > V";
pattern >(v:sht,b:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return V > B";

command >(b1:bat[:oid,:sht],b2:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatGT
comment "Return B1 > B2";
pattern >(b:bat[:oid,:sht],v:sht) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return B > V";
pattern >(v:sht,b:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return V > B";

command >(b1:bat[:oid,:sht],b2:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatGT
comment "Return B1 > B2";
pattern >(b:bat[:oid,:sht],v:int) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return B > V";
pattern >(v:sht,b:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return V > B";

command >(b1:bat[:oid,:sht],b2:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatGT
comment "Return B1 > B2";
pattern >(b:bat[:oid,:sht],v:wrd) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return B > V";
pattern >(v:sht,b:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return V > B";

command >(b1:bat[:oid,:sht],b2:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatGT
comment "Return B1 > B2";
pattern >(b:bat[:oid,:sht],v:lng) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return B > V";
pattern >(v:sht,b:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return V > B";

command >(b1:bat[:oid,:sht],b2:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatGT
comment "Return B1 > B2";
pattern >(b:bat[:oid,:sht],v:flt) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return B > V";
pattern >(v:sht,b:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return V > B";

command >(b1:bat[:oid,:sht],b2:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatGT
comment "Return B1 > B2";
pattern >(b:bat[:oid,:sht],v:dbl) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return B > V";
pattern >(v:sht,b:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return V > B";

command >(b1:bat[:oid,:int],b2:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatGT
comment "Return B1 > B2";
pattern >(b:bat[:oid,:int],v:bte) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return B > V";
pattern >(v:int,b:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return V > B";

command >(b1:bat[:oid,:int],b2:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatGT
comment "Return B1 > B2";
pattern >(b:bat[:oid,:int],v:sht) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return B > V";
pattern >(v:int,b:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return V > B";

command >(b1:bat[:oid,:int],b2:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatGT
comment "Return B1 > B2";
pattern >(b:bat[:oid,:int],v:int) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return B > V";
pattern >(v:int,b:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return V > B";

command >(b1:bat[:oid,:int],b2:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatGT
comment "Return B1 > B2";
pattern >(b:bat[:oid,:int],v:wrd) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return B > V";
pattern >(v:int,b:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return V > B";

command >(b1:bat[:oid,:int],b2:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatGT
comment "Return B1 > B2";
pattern >(b:bat[:oid,:int],v:lng) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return B > V";
pattern >(v:int,b:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return V > B";

command >(b1:bat[:oid,:int],b2:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatGT
comment "Return B1 > B2";
pattern >(b:bat[:oid,:int],v:flt) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return B > V";
pattern >(v:int,b:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return V > B";

command >(b1:bat[:oid,:int],b2:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatGT
comment "Return B1 > B2";
pattern >(b:bat[:oid,:int],v:dbl) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return B > V";
pattern >(v:int,b:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return V > B";

command >(b1:bat[:oid,:wrd],b2:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatGT
comment "Return B1 > B2";
pattern >(b:bat[:oid,:wrd],v:bte) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return B > V";
pattern >(v:wrd,b:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return V > B";

command >(b1:bat[:oid,:wrd],b2:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatGT
comment "Return B1 > B2";
pattern >(b:bat[:oid,:wrd],v:sht) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return B > V";
pattern >(v:wrd,b:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return V > B";

command >(b1:bat[:oid,:wrd],b2:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatGT
comment "Return B1 > B2";
pattern >(b:bat[:oid,:wrd],v:int) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return B > V";
pattern >(v:wrd,b:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return V > B";

command >(b1:bat[:oid,:wrd],b2:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatGT
comment "Return B1 > B2";
pattern >(b:bat[:oid,:wrd],v:wrd) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return B > V";
pattern >(v:wrd,b:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return V > B";

command >(b1:bat[:oid,:wrd],b2:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatGT
comment "Return B1 > B2";
pattern >(b:bat[:oid,:wrd],v:lng) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return B > V";
pattern >(v:wrd,b:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return V > B";

command >(b1:bat[:oid,:wrd],b2:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatGT
comment "Return B1 > B2";
pattern >(b:bat[:oid,:wrd],v:flt) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return B > V";
pattern >(v:wrd,b:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return V > B";

command >(b1:bat[:oid,:wrd],b2:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatGT
comment "Return B1 > B2";
pattern >(b:bat[:oid,:wrd],v:dbl) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return B > V";
pattern >(v:wrd,b:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return V > B";

command >(b1:bat[:oid,:lng],b2:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatGT
comment "Return B1 > B2";
pattern >(b:bat[:oid,:lng],v:bte) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return B > V";
pattern >(v:lng,b:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return V > B";

command >(b1:bat[:oid,:lng],b2:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatGT
comment "Return B1 > B2";
pattern >(b:bat[:oid,:lng],v:sht) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return B > V";
pattern >(v:lng,b:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return V > B";

command >(b1:bat[:oid,:lng],b2:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatGT
comment "Return B1 > B2";
pattern >(b:bat[:oid,:lng],v:int) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return B > V";
pattern >(v:lng,b:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return V > B";

command >(b1:bat[:oid,:lng],b2:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatGT
comment "Return B1 > B2";
pattern >(b:bat[:oid,:lng],v:wrd) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return B > V";
pattern >(v:lng,b:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return V > B";

command >(b1:bat[:oid,:lng],b2:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatGT
comment "Return B1 > B2";
pattern >(b:bat[:oid,:lng],v:lng) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return B > V";
pattern >(v:lng,b:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return V > B";

command >(b1:bat[:oid,:lng],b2:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatGT
comment "Return B1 > B2";
pattern >(b:bat[:oid,:lng],v:flt) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return B > V";
pattern >(v:lng,b:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return V > B";

command >(b1:bat[:oid,:lng],b2:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatGT
comment "Return B1 > B2";
pattern >(b:bat[:oid,:lng],v:dbl) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return B > V";
pattern >(v:lng,b:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return V > B";

command >(b1:bat[:oid,:flt],b2:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatGT
comment "Return B1 > B2";
pattern >(b:bat[:oid,:flt],v:bte) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return B > V";
pattern >(v:flt,b:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return V > B";

command >(b1:bat[:oid,:flt],b2:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatGT
comment "Return B1 > B2";
pattern >(b:bat[:oid,:flt],v:sht) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return B > V";
pattern >(v:flt,b:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return V > B";

command >(b1:bat[:oid,:flt],b2:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatGT
comment "Return B1 > B2";
pattern >(b:bat[:oid,:flt],v:int) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return B > V";
pattern >(v:flt,b:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return V > B";

command >(b1:bat[:oid,:flt],b2:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatGT
comment "Return B1 > B2";
pattern >(b:bat[:oid,:flt],v:wrd) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return B > V";
pattern >(v:flt,b:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return V > B";

command >(b1:bat[:oid,:flt],b2:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatGT
comment "Return B1 > B2";
pattern >(b:bat[:oid,:flt],v:lng) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return B > V";
pattern >(v:flt,b:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return V > B";

command >(b1:bat[:oid,:flt],b2:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatGT
comment "Return B1 > B2";
pattern >(b:bat[:oid,:flt],v:flt) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return B > V";
pattern >(v:flt,b:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return V > B";

command >(b1:bat[:oid,:flt],b2:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatGT
comment "Return B1 > B2";
pattern >(b:bat[:oid,:flt],v:dbl) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return B > V";
pattern >(v:flt,b:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return V > B";

command >(b1:bat[:oid,:dbl],b2:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatGT
comment "Return B1 > B2";
pattern >(b:bat[:oid,:dbl],v:bte) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return B > V";
pattern >(v:dbl,b:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return V > B";

command >(b1:bat[:oid,:dbl],b2:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatGT
comment "Return B1 > B2";
pattern >(b:bat[:oid,:dbl],v:sht) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return B > V";
pattern >(v:dbl,b:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return V > B";

command >(b1:bat[:oid,:dbl],b2:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatGT
comment "Return B1 > B2";
pattern >(b:bat[:oid,:dbl],v:int) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return B > V";
pattern >(v:dbl,b:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return V > B";

command >(b1:bat[:oid,:dbl],b2:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatGT
comment "Return B1 > B2";
pattern >(b:bat[:oid,:dbl],v:wrd) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return B > V";
pattern >(v:dbl,b:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return V > B";

command >(b1:bat[:oid,:dbl],b2:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatGT
comment "Return B1 > B2";
pattern >(b:bat[:oid,:dbl],v:lng) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return B > V";
pattern >(v:dbl,b:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return V > B";

command >(b1:bat[:oid,:dbl],b2:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatGT
comment "Return B1 > B2";
pattern >(b:bat[:oid,:dbl],v:flt) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return B > V";
pattern >(v:dbl,b:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return V > B";

command >(b1:bat[:oid,:dbl],b2:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatGT
comment "Return B1 > B2";
pattern >(b:bat[:oid,:dbl],v:dbl) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return B > V";
pattern >(v:dbl,b:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return V > B";


command >=(b1:bat[:oid,:bit],b2:bat[:oid,:bit]) :bat[:oid,:bit]
address CMDbatGE
comment "Return B1 >= B2";
pattern >=(b:bat[:oid,:bit],v:bit) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return B >= V";
pattern >=(v:bit,b:bat[:oid,:bit]) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return V >= B";

command >=(b1:bat[:oid,:str],b2:bat[:oid,:str]) :bat[:oid,:bit]
address CMDbatGE
comment "Return B1 >= B2";
pattern >=(b:bat[:oid,:str],v:str) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return B >= V";
pattern >=(v:str,b:bat[:oid,:str]) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return V >= B";

command >=(b1:bat[:oid,:oid],b2:bat[:oid,:oid]) :bat[:oid,:bit]
address CMDbatGE
comment "Return B1 >= B2";
pattern >=(b:bat[:oid,:oid],v:oid) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return B >= V";
pattern >=(v:oid,b:bat[:oid,:oid]) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return V >= B";

command >=(b1:bat[:oid,:bte],b2:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatGE
comment "Return B1 >= B2";
pattern >=(b:bat[:oid,:bte],v:bte) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return B >= V";
pattern >=(v:bte,b:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return V >= B";

command >=(b1:bat[:oid,:bte],b2:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatGE
comment "Return B1 >= B2";
pattern >=(b:bat[:oid,:bte],v:sht) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return B >= V";
pattern >=(v:bte,b:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return V >= B";

command >=(b1:bat[:oid,:bte],b2:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatGE
comment "Return B1 >= B2";
pattern >=(b:bat[:oid,:bte],v:int) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return B >= V";
pattern >=(v:bte,b:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return V >= B";

command >=(b1:bat[:oid,:bte],b2:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatGE
comment "Return B1 >= B2";
pattern >=(b:bat[:oid,:bte],v:wrd) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return B >= V";
pattern >=(v:bte,b:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return V >= B";

command >=(b1:bat[:oid,:bte],b2:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatGE
comment "Return B1 >= B2";
pattern >=(b:bat[:oid,:bte],v:lng) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return B >= V";
pattern >=(v:bte,b:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return V >= B";

command >=(b1:bat[:oid,:bte],b2:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatGE
comment "Return B1 >= B2";
pattern >=(b:bat[:oid,:bte],v:flt) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return B >= V";
pattern >=(v:bte,b:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return V >= B";

command >=(b1:bat[:oid,:bte],b2:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatGE
comment "Return B1 >= B2";
pattern >=(b:bat[:oid,:bte],v:dbl) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return B >= V";
pattern >=(v:bte,b:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return V >= B";

command >=(b1:bat[:oid,:sht],b2:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatGE
comment "Return B1 >= B2";
pattern >=(b:bat[:oid,:sht],v:bte) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return B >= V";
pattern >=(v:sht,b:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return V >= B";

command >=(b1:bat[:oid,:sht],b2:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatGE
comment "Return B1 >= B2";
pattern >=(b:bat[:oid,:sht],v:sht) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return B >= V";
pattern >=(v:sht,b:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return V >= B";

command >=(b1:bat[:oid,:sht],b2:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatGE
comment "Return B1 >= B2";
pattern >=(b:bat[:oid,:sht],v:int) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return B >= V";
pattern >=(v:sht,b:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return V >= B";

command >=(b1:bat[:oid,:sht],b2:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatGE
comment "Return B1 >= B2";
pattern >=(b:bat[:oid,:sht],v:wrd) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return B >= V";
pattern >=(v:sht,b:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return V >= B";

command >=(b1:bat[:oid,:sht],b2:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatGE
comment "Return B1 >= B2";
pattern >=(b:bat[:oid,:sht],v:lng) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return B >= V";
pattern >=(v:sht,b:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return V >= B";

command >=(b1:bat[:oid,:sht],b2:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatGE
comment "Return B1 >= B2";
pattern >=(b:bat[:oid,:sht],v:flt) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return B >= V";
pattern >=(v:sht,b:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return V >= B";

command >=(b1:bat[:oid,:sht],b2:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatGE
comment "Return B1 >= B2";
pattern >=(b:bat[:oid,:sht],v:dbl) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return B >= V";
pattern >=(v:sht,b:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return V >= B";

command >=(b1:bat[:oid,:int],b2:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatGE
comment "Return B1 >= B2";
pattern >=(b:bat[:oid,:int],v:bte) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return B >= V";
pattern >=(v:int,b:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return V >= B";

command >=(b1:bat[:oid,:int],b2:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatGE
comment "Return B1 >= B2";
pattern >=(b:bat[:oid,:int],v:sht) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return B >= V";
pattern >=(v:int,b:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return V >= B";

command >=(b1:bat[:oid,:int],b2:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatGE
comment "Return B1 >= B2";
pattern >=(b:bat[:oid,:int],v:int) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return B >= V";
pattern >=(v:int,b:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return V >= B";

command >=(b1:bat[:oid,:int],b2:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatGE
comment "Return B1 >= B2";
pattern >=(b:bat[:oid,:int],v:wrd) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return B >= V";
pattern >=(v:int,b:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return V >= B";

command >=(b1:bat[:oid,:int],b2:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatGE
comment "Return B1 >= B2";
pattern >=(b:bat[:oid,:int],v:lng) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return B >= V";
pattern >=(v:int,b:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return V >= B";

command >=(b1:bat[:oid,:int],b2:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatGE
comment "Return B1 >= B2";
pattern >=(b:bat[:oid,:int],v:flt) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return B >= V";
pattern >=(v:int,b:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return V >= B";

command >=(b1:bat[:oid,:int],b2:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatGE
comment "Return B1 >= B2";
pattern >=(b:bat[:oid,:int],v:dbl) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return B >= V";
pattern >=(v:int,b:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return V >= B";

command >=(b1:bat[:oid,:wrd],b2:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatGE
comment "Return B1 >= B2";
pattern >=(b:bat[:oid,:wrd],v:bte) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return B >= V";
pattern >=(v:wrd,b:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return V >= B";

command >=(b1:bat[:oid,:wrd],b2:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatGE
comment "Return B1 >= B2";
pattern >=(b:bat[:oid,:wrd],v:sht) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return B >= V";
pattern >=(v:wrd,b:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return V >= B";

command >=(b1:bat[:oid,:wrd],b2:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatGE
comment "Return B1 >= B2";
pattern >=(b:bat[:oid,:wrd],v:int) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return B >= V";
pattern >=(v:wrd,b:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return V >= B";

command >=(b1:bat[:oid,:wrd],b2:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatGE
comment "Return B1 >= B2";
pattern >=(b:bat[:oid,:wrd],v:wrd) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return B >= V";
pattern >=(v:wrd,b:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return V >= B";

command >=(b1:bat[:oid,:wrd],b2:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatGE
comment "Return B1 >= B2";
pattern >=(b:bat[:oid,:wrd],v:lng) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return B >= V";
pattern >=(v:wrd,b:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return V >= B";

command >=(b1:bat[:oid,:wrd],b2:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatGE
comment "Return B1 >= B2";
pattern >=(b:bat[:oid,:wrd],v:flt) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return B >= V";
pattern >=(v:wrd,b:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return V >= B";

command >=(b1:bat[:oid,:wrd],b2:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatGE
comment "Return B1 >= B2";
pattern >=(b:bat[:oid,:wrd],v:dbl) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return B >= V";
pattern >=(v:wrd,b:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return V >= B";

command >=(b1:bat[:oid,:lng],b2:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatGE
comment "Return B1 >= B2";
pattern >=(b:bat[:oid,:lng],v:bte) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return B >= V";
pattern >=(v:lng,b:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return V >= B";

command >=(b1:bat[:oid,:lng],b2:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatGE
comment "Return B1 >= B2";
pattern >=(b:bat[:oid,:lng],v:sht) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return B >= V";
pattern >=(v:lng,b:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return V >= B";

command >=(b1:bat[:oid,:lng],b2:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatGE
comment "Return B1 >= B2";
pattern >=(b:bat[:oid,:lng],v:int) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return B >= V";
pattern >=(v:lng,b:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return V >= B";

command >=(b1:bat[:oid,:lng],b2:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatGE
comment "Return B1 >= B2";
pattern >=(b:bat[:oid,:lng],v:wrd) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return B >= V";
pattern >=(v:lng,b:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return V >= B";

command >=(b1:bat[:oid,:lng],b2:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatGE
comment "Return B1 >= B2";
pattern >=(b:bat[:oid,:lng],v:lng) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return B >= V";
pattern >=(v:lng,b:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return V >= B";

command >=(b1:bat[:oid,:lng],b2:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatGE
comment "Return B1 >= B2";
pattern >=(b:bat[:oid,:lng],v:flt) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return B >= V";
pattern >=(v:lng,b:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return V >= B";

command >=(b1:bat[:oid,:lng],b2:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatGE
comment "Return B1 >= B2";
pattern >=(b:bat[:oid,:lng],v:dbl) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return B >= V";
pattern >=(v:lng,b:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return V >= B";

command >=(b1:bat[:oid,:flt],b2:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatGE
comment "Return B1 >= B2";
pattern >=(b:bat[:oid,:flt],v:bte) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return B >= V";
pattern >=(v:flt,b:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return V >= B";

command >=(b1:bat[:oid,:flt],b2:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatGE
comment "Return B1 >= B2";
pattern >=(b:bat[:oid,:flt],v:sht) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return B >= V";
pattern >=(v:flt,b:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return V >= B";

command >=(b1:bat[:oid,:flt],b2:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatGE
comment "Return B1 >= B2";
pattern >=(b:bat[:oid,:flt],v:int) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return B >= V";
pattern >=(v:flt,b:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return V >= B";

command >=(b1:bat[:oid,:flt],b2:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatGE
comment "Return B1 >= B2";
pattern >=(b:bat[:oid,:flt],v:wrd) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return B >= V";
pattern >=(v:flt,b:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return V >= B";

command >=(b1:bat[:oid,:flt],b2:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatGE
comment "Return B1 >= B2";
pattern >=(b:bat[:oid,:flt],v:lng) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return B >= V";
pattern >=(v:flt,b:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return V >= B";

command >=(b1:bat[:oid,:flt],b2:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatGE
comment "Return B1 >= B2";
pattern >=(b:bat[:oid,:flt],v:flt) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return B >= V";
pattern >=(v:flt,b:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return V >= B";

command >=(b1:bat[:oid,:flt],b2:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatGE
comment "Return B1 >= B2";
pattern >=(b:bat[:oid,:flt],v:dbl) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return B >= V";
pattern >=(v:flt,b:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return V >= B";

command >=(b1:bat[:oid,:dbl],b2:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatGE
comment "Return B1 >= B2";
pattern >=(b:bat[:oid,:dbl],v:bte) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return B >= V";
pattern >=(v:dbl,b:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return V >= B";

command >=(b1:bat[:oid,:dbl],b2:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatGE
comment "Return B1 >= B2";
pattern >=(b:bat[:oid,:dbl],v:sht) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return B >= V";
pattern >=(v:dbl,b:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return V >= B";

command >=(b1:bat[:oid,:dbl],b2:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatGE
comment "Return B1 >= B2";
pattern >=(b:bat[:oid,:dbl],v:int) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return B >= V";
pattern >=(v:dbl,b:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return V >= B";

command >=(b1:bat[:oid,:dbl],b2:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatGE
comment "Return B1 >= B2";
pattern >=(b:bat[:oid,:dbl],v:wrd) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return B >= V";
pattern >=(v:dbl,b:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return V >= B";

command >=(b1:bat[:oid,:dbl],b2:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatGE
comment "Return B1 >= B2";
pattern >=(b:bat[:oid,:dbl],v:lng) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return B >= V";
pattern >=(v:dbl,b:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return V >= B";

command >=(b1:bat[:oid,:dbl],b2:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatGE
comment "Return B1 >= B2";
pattern >=(b:bat[:oid,:dbl],v:flt) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return B >= V";
pattern >=(v:dbl,b:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return V >= B";

command >=(b1:bat[:oid,:dbl],b2:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatGE
comment "Return B1 >= B2";
pattern >=(b:bat[:oid,:dbl],v:dbl) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return B >= V";
pattern >=(v:dbl,b:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return V >= B";


command ==(b1:bat[:oid,:bit],b2:bat[:oid,:bit]) :bat[:oid,:bit]
address CMDbatEQ
comment "Return B1 == B2";
pattern ==(b:bat[:oid,:bit],v:bit) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return B == V";
pattern ==(v:bit,b:bat[:oid,:bit]) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return V == B";

command ==(b1:bat[:oid,:str],b2:bat[:oid,:str]) :bat[:oid,:bit]
address CMDbatEQ
comment "Return B1 == B2";
pattern ==(b:bat[:oid,:str],v:str) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return B == V";
pattern ==(v:str,b:bat[:oid,:str]) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return V == B";

command ==(b1:bat[:oid,:oid],b2:bat[:oid,:oid]) :bat[:oid,:bit]
address CMDbatEQ
comment "Return B1 == B2";
pattern ==(b:bat[:oid,:oid],v:oid) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return B == V";
pattern ==(v:oid,b:bat[:oid,:oid]) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return V == B";

command ==(b1:bat[:oid,:bte],b2:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatEQ
comment "Return B1 == B2";
pattern ==(b:bat[:oid,:bte],v:bte) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return B == V";
pattern ==(v:bte,b:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return V == B";

command ==(b1:bat[:oid,:bte],b2:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatEQ
comment "Return B1 == B2";
pattern ==(b:bat[:oid,:bte],v:sht) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return B == V";
pattern ==(v:bte,b:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return V == B";

command ==(b1:bat[:oid,:bte],b2:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatEQ
comment "Return B1 == B2";
pattern ==(b:bat[:oid,:bte],v:int) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return B == V";
pattern ==(v:bte,b:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return V == B";

command ==(b1:bat[:oid,:bte],b2:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatEQ
comment "Return B1 == B2";
pattern ==(b:bat[:oid,:bte],v:wrd) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return B == V";
pattern ==(v:bte,b:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return V == B";

command ==(b1:bat[:oid,:bte],b2:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatEQ
comment "Return B1 == B2";
pattern ==(b:bat[:oid,:bte],v:lng) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return B == V";
pattern ==(v:bte,b:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return V == B";

command ==(b1:bat[:oid,:bte],b2:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatEQ
comment "Return B1 == B2";
pattern ==(b:bat[:oid,:bte],v:flt) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return B == V";
pattern ==(v:bte,b:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return V == B";

command ==(b1:bat[:oid,:bte],b2:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatEQ
comment "Return B1 == B2";
pattern ==(b:bat[:oid,:bte],v:dbl) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return B == V";
pattern ==(v:bte,b:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return V == B";

command ==(b1:bat[:oid,:sht],b2:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatEQ
comment "Return B1 == B2";
pattern ==(b:bat[:oid,:sht],v:bte) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return B == V";
pattern ==(v:sht,b:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return V == B";

command ==(b1:bat[:oid,:sht],b2:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatEQ
comment "Return B1 == B2";
pattern ==(b:bat[:oid,:sht],v:sht) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return B == V";
pattern ==(v:sht,b:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return V == B";

command ==(b1:bat[:oid,:sht],b2:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatEQ
comment "Return B1 == B2";
pattern ==(b:bat[:oid,:sht],v:int) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return B == V";
pattern ==(v:sht,b:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return V == B";

command ==(b1:bat[:oid,:sht],b2:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatEQ
comment "Return B1 == B2";
pattern ==(b:bat[:oid,:sht],v:wrd) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return B == V";
pattern ==(v:sht,b:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return V == B";

command ==(b1:bat[:oid,:sht],b2:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatEQ
comment "Return B1 == B2";
pattern ==(b:bat[:oid,:sht],v:lng) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return B == V";
pattern ==(v:sht,b:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return V == B";

command ==(b1:bat[:oid,:sht],b2:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatEQ
comment "Return B1 == B2";
pattern ==(b:bat[:oid,:sht],v:flt) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return B == V";
pattern ==(v:sht,b:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return V == B";

command ==(b1:bat[:oid,:sht],b2:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatEQ
comment "Return B1 == B2";
pattern ==(b:bat[:oid,:sht],v:dbl) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return B == V";
pattern ==(v:sht,b:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return V == B";

command ==(b1:bat[:oid,:int],b2:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatEQ
comment "Return B1 == B2";
pattern ==(b:bat[:oid,:int],v:bte) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return B == V";
pattern ==(v:int,b:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return V == B";

command ==(b1:bat[:oid,:int],b2:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatEQ
comment "Return B1 == B2";
pattern ==(b:bat[:oid,:int],v:sht) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return B == V";
pattern ==(v:int,b:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return V == B";

command ==(b1:bat[:oid,:int],b2:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatEQ
comment "Return B1 == B2";
pattern ==(b:bat[:oid,:int],v:int) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return B == V";
pattern ==(v:int,b:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return V == B";

command ==(b1:bat[:oid,:int],b2:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatEQ
comment "Return B1 == B2";
pattern ==(b:bat[:oid,:int],v:wrd) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return B == V";
pattern ==(v:int,b:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return V == B";

command ==(b1:bat[:oid,:int],b2:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatEQ
comment "Return B1 == B2";
pattern ==(b:bat[:oid,:int],v:lng) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return B == V";
pattern ==(v:int,b:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return V == B";

command ==(b1:bat[:oid,:int],b2:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatEQ
comment "Return B1 == B2";
pattern ==(b:bat[:oid,:int],v:flt) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return B == V";
pattern ==(v:int,b:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return V == B";

command ==(b1:bat[:oid,:int],b2:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatEQ
comment "Return B1 == B2";
pattern ==(b:bat[:oid,:int],v:dbl) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return B == V";
pattern ==(v:int,b:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return V == B";

command ==(b1:bat[:oid,:wrd],b2:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatEQ
comment "Return B1 == B2";
pattern ==(b:bat[:oid,:wrd],v:bte) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return B == V";
pattern ==(v:wrd,b:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return V == B";

command ==(b1:bat[:oid,:wrd],b2:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatEQ
comment "Return B1 == B2";
pattern ==(b:bat[:oid,:wrd],v:sht) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return B == V";
pattern ==(v:wrd,b:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return V == B";

command ==(b1:bat[:oid,:wrd],b2:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatEQ
comment "Return B1 == B2";
pattern ==(b:bat[:oid,:wrd],v:int) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return B == V";
pattern ==(v:wrd,b:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return V == B";

command ==(b1:bat[:oid,:wrd],b2:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatEQ
comment "Return B1 == B2";
pattern ==(b:bat[:oid,:wrd],v:wrd) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return B == V";
pattern ==(v:wrd,b:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return V == B";

command ==(b1:bat[:oid,:wrd],b2:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatEQ
comment "Return B1 == B2";
pattern ==(b:bat[:oid,:wrd],v:lng) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return B == V";
pattern ==(v:wrd,b:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return V == B";

command ==(b1:bat[:oid,:wrd],b2:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatEQ
comment "Return B1 == B2";
pattern ==(b:bat[:oid,:wrd],v:flt) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return B == V";
pattern ==(v:wrd,b:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return V == B";

command ==(b1:bat[:oid,:wrd],b2:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatEQ
comment "Return B1 == B2";
pattern ==(b:bat[:oid,:wrd],v:dbl) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return B == V";
pattern ==(v:wrd,b:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return V == B";

command ==(b1:bat[:oid,:lng],b2:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatEQ
comment "Return B1 == B2";
pattern ==(b:bat[:oid,:lng],v:bte) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return B == V";
pattern ==(v:lng,b:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return V == B";

command ==(b1:bat[:oid,:lng],b2:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatEQ
comment "Return B1 == B2";
pattern ==(b:bat[:oid,:lng],v:sht) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return B == V";
pattern ==(v:lng,b:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return V == B";

command ==(b1:bat[:oid,:lng],b2:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatEQ
comment "Return B1 == B2";
pattern ==(b:bat[:oid,:lng],v:int) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return B == V";
pattern ==(v:lng,b:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return V == B";

command ==(b1:bat[:oid,:lng],b2:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatEQ
comment "Return B1 == B2";
pattern ==(b:bat[:oid,:lng],v:wrd) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return B == V";
pattern ==(v:lng,b:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return V == B";

command ==(b1:bat[:oid,:lng],b2:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatEQ
comment "Return B1 == B2";
pattern ==(b:bat[:oid,:lng],v:lng) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return B == V";
pattern ==(v:lng,b:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return V == B";

command ==(b1:bat[:oid,:lng],b2:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatEQ
comment "Return B1 == B2";
pattern ==(b:bat[:oid,:lng],v:flt) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return B == V";
pattern ==(v:lng,b:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return V == B";

command ==(b1:bat[:oid,:lng],b2:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatEQ
comment "Return B1 == B2";
pattern ==(b:bat[:oid,:lng],v:dbl) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return B == V";
pattern ==(v:lng,b:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return V == B";

command ==(b1:bat[:oid,:flt],b2:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatEQ
comment "Return B1 == B2";
pattern ==(b:bat[:oid,:flt],v:bte) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return B == V";
pattern ==(v:flt,b:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return V == B";

command ==(b1:bat[:oid,:flt],b2:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatEQ
comment "Return B1 == B2";
pattern ==(b:bat[:oid,:flt],v:sht) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return B == V";
pattern ==(v:flt,b:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return V == B";

command ==(b1:bat[:oid,:flt],b2:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatEQ
comment "Return B1 == B2";
pattern ==(b:bat[:oid,:flt],v:int) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return B == V";
pattern ==(v:flt,b:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return V == B";

command ==(b1:bat[:oid,:flt],b2:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatEQ
comment "Return B1 == B2";
pattern ==(b:bat[:oid,:flt],v:wrd) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return B == V";
pattern ==(v:flt,b:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return V == B";

command ==(b1:bat[:oid,:flt],b2:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatEQ
comment "Return B1 == B2";
pattern ==(b:bat[:oid,:flt],v:lng) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return B == V";
pattern ==(v:flt,b:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return V == B";

command ==(b1:bat[:oid,:flt],b2:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatEQ
comment "Return B1 == B2";
pattern ==(b:bat[:oid,:flt],v:flt) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return B == V";
pattern ==(v:flt,b:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return V == B";

command ==(b1:bat[:oid,:flt],b2:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatEQ
comment "Return B1 == B2";
pattern ==(b:bat[:oid,:flt],v:dbl) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return B == V";
pattern ==(v:flt,b:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return V == B";

command ==(b1:bat[:oid,:dbl],b2:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatEQ
comment "Return B1 == B2";
pattern ==(b:bat[:oid,:dbl],v:bte) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return B == V";
pattern ==(v:dbl,b:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return V == B";

command ==(b1:bat[:oid,:dbl],b2:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatEQ
comment "Return B1 == B2";
pattern ==(b:bat[:oid,:dbl],v:sht) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return B == V";
pattern ==(v:dbl,b:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return V == B";

command ==(b1:bat[:oid,:dbl],b2:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatEQ
comment "Return B1 == B2";
pattern ==(b:bat[:oid,:dbl],v:int) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return B == V";
pattern ==(v:dbl,b:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return V == B";

command ==(b1:bat[:oid,:dbl],b2:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatEQ
comment "Return B1 == B2";
pattern ==(b:bat[:oid,:dbl],v:wrd) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return B == V";
pattern ==(v:dbl,b:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return V == B";

command ==(b1:bat[:oid,:dbl],b2:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatEQ
comment "Return B1 == B2";
pattern ==(b:bat[:oid,:dbl],v:lng) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return B == V";
pattern ==(v:dbl,b:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return V == B";

command ==(b1:bat[:oid,:dbl],b2:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatEQ
comment "Return B1 == B2";
pattern ==(b:bat[:oid,:dbl],v:flt) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return B == V";
pattern ==(v:dbl,b:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return V == B";

command ==(b1:bat[:oid,:dbl],b2:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatEQ
comment "Return B1 == B2";
pattern ==(b:bat[:oid,:dbl],v:dbl) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return B == V";
pattern ==(v:dbl,b:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return V == B";


command !=(b1:bat[:oid,:bit],b2:bat[:oid,:bit]) :bat[:oid,:bit]
address CMDbatNE
comment "Return B1 != B2";
pattern !=(b:bat[:oid,:bit],v:bit) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return B != V";
pattern !=(v:bit,b:bat[:oid,:bit]) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return V != B";

command !=(b1:bat[:oid,:str],b2:bat[:oid,:str]) :bat[:oid,:bit]
address CMDbatNE
comment "Return B1 != B2";
pattern !=(b:bat[:oid,:str],v:str) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return B != V";
pattern !=(v:str,b:bat[:oid,:str]) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return V != B";

command !=(b1:bat[:oid,:oid],b2:bat[:oid,:oid]) :bat[:oid,:bit]
address CMDbatNE
comment "Return B1 != B2";
pattern !=(b:bat[:oid,:oid],v:oid) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return B != V";
pattern !=(v:oid,b:bat[:oid,:oid]) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return V != B";

command !=(b1:bat[:oid,:bte],b2:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatNE
comment "Return B1 != B2";
pattern !=(b:bat[:oid,:bte],v:bte) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return B != V";
pattern !=(v:bte,b:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return V != B";

command !=(b1:bat[:oid,:bte],b2:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatNE
comment "Return B1 != B2";
pattern !=(b:bat[:oid,:bte],v:sht) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return B != V";
pattern !=(v:bte,b:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return V != B";

command !=(b1:bat[:oid,:bte],b2:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatNE
comment "Return B1 != B2";
pattern !=(b:bat[:oid,:bte],v:int) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return B != V";
pattern !=(v:bte,b:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return V != B";

command !=(b1:bat[:oid,:bte],b2:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatNE
comment "Return B1 != B2";
pattern !=(b:bat[:oid,:bte],v:wrd) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return B != V";
pattern !=(v:bte,b:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return V != B";

command !=(b1:bat[:oid,:bte],b2:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatNE
comment "Return B1 != B2";
pattern !=(b:bat[:oid,:bte],v:lng) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return B != V";
pattern !=(v:bte,b:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return V != B";

command !=(b1:bat[:oid,:bte],b2:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatNE
comment "Return B1 != B2";
pattern !=(b:bat[:oid,:bte],v:flt) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return B != V";
pattern !=(v:bte,b:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return V != B";

command !=(b1:bat[:oid,:bte],b2:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatNE
comment "Return B1 != B2";
pattern !=(b:bat[:oid,:bte],v:dbl) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return B != V";
pattern !=(v:bte,b:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return V != B";

command !=(b1:bat[:oid,:sht],b2:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatNE
comment "Return B1 != B2";
pattern !=(b:bat[:oid,:sht],v:bte) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return B != V";
pattern !=(v:sht,b:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return V != B";

command !=(b1:bat[:oid,:sht],b2:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatNE
comment "Return B1 != B2";
pattern !=(b:bat[:oid,:sht],v:sht) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return B != V";
pattern !=(v:sht,b:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return V != B";

command !=(b1:bat[:oid,:sht],b2:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatNE
comment "Return B1 != B2";
pattern !=(b:bat[:oid,:sht],v:int) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return B != V";
pattern !=(v:sht,b:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return V != B";

command !=(b1:bat[:oid,:sht],b2:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatNE
comment "Return B1 != B2";
pattern !=(b:bat[:oid,:sht],v:wrd) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return B != V";
pattern !=(v:sht,b:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return V != B";

command !=(b1:bat[:oid,:sht],b2:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatNE
comment "Return B1 != B2";
pattern !=(b:bat[:oid,:sht],v:lng) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return B != V";
pattern !=(v:sht,b:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return V != B";

command !=(b1:bat[:oid,:sht],b2:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatNE
comment "Return B1 != B2";
pattern !=(b:bat[:oid,:sht],v:flt) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return B != V";
pattern !=(v:sht,b:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return V != B";

command !=(b1:bat[:oid,:sht],b2:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatNE
comment "Return B1 != B2";
pattern !=(b:bat[:oid,:sht],v:dbl) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return B != V";
pattern !=(v:sht,b:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return V != B";

command !=(b1:bat[:oid,:int],b2:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatNE
comment "Return B1 != B2";
pattern !=(b:bat[:oid,:int],v:bte) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return B != V";
pattern !=(v:int,b:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return V != B";

command !=(b1:bat[:oid,:int],b2:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatNE
comment "Return B1 != B2";
pattern !=(b:bat[:oid,:int],v:sht) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return B != V";
pattern !=(v:int,b:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return V != B";

command !=(b1:bat[:oid,:int],b2:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatNE
comment "Return B1 != B2";
pattern !=(b:bat[:oid,:int],v:int) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return B != V";
pattern !=(v:int,b:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return V != B";

command !=(b1:bat[:oid,:int],b2:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatNE
comment "Return B1 != B2";
pattern !=(b:bat[:oid,:int],v:wrd) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return B != V";
pattern !=(v:int,b:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return V != B";

command !=(b1:bat[:oid,:int],b2:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatNE
comment "Return B1 != B2";
pattern !=(b:bat[:oid,:int],v:lng) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return B != V";
pattern !=(v:int,b:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return V != B";

command !=(b1:bat[:oid,:int],b2:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatNE
comment "Return B1 != B2";
pattern !=(b:bat[:oid,:int],v:flt) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return B != V";
pattern !=(v:int,b:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return V != B";

command !=(b1:bat[:oid,:int],b2:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatNE
comment "Return B1 != B2";
pattern !=(b:bat[:oid,:int],v:dbl) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return B != V";
pattern !=(v:int,b:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return V != B";

command !=(b1:bat[:oid,:wrd],b2:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatNE
comment "Return B1 != B2";
pattern !=(b:bat[:oid,:wrd],v:bte) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return B != V";
pattern !=(v:wrd,b:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return V != B";

command !=(b1:bat[:oid,:wrd],b2:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatNE
comment "Return B1 != B2";
pattern !=(b:bat[:oid,:wrd],v:sht) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return B != V";
pattern !=(v:wrd,b:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return V != B";

command !=(b1:bat[:oid,:wrd],b2:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatNE
comment "Return B1 != B2";
pattern !=(b:bat[:oid,:wrd],v:int) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return B != V";
pattern !=(v:wrd,b:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return V != B";

command !=(b1:bat[:oid,:wrd],b2:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatNE
comment "Return B1 != B2";
pattern !=(b:bat[:oid,:wrd],v:wrd) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return B != V";
pattern !=(v:wrd,b:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return V != B";

command !=(b1:bat[:oid,:wrd],b2:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatNE
comment "Return B1 != B2";
pattern !=(b:bat[:oid,:wrd],v:lng) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return B != V";
pattern !=(v:wrd,b:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return V != B";

command !=(b1:bat[:oid,:wrd],b2:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatNE
comment "Return B1 != B2";
pattern !=(b:bat[:oid,:wrd],v:flt) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return B != V";
pattern !=(v:wrd,b:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return V != B";

command !=(b1:bat[:oid,:wrd],b2:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatNE
comment "Return B1 != B2";
pattern !=(b:bat[:oid,:wrd],v:dbl) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return B != V";
pattern !=(v:wrd,b:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return V != B";

command !=(b1:bat[:oid,:lng],b2:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatNE
comment "Return B1 != B2";
pattern !=(b:bat[:oid,:lng],v:bte) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return B != V";
pattern !=(v:lng,b:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return V != B";

command !=(b1:bat[:oid,:lng],b2:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatNE
comment "Return B1 != B2";
pattern !=(b:bat[:oid,:lng],v:sht) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return B != V";
pattern !=(v:lng,b:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return V != B";

command !=(b1:bat[:oid,:lng],b2:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatNE
comment "Return B1 != B2";
pattern !=(b:bat[:oid,:lng],v:int) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return B != V";
pattern !=(v:lng,b:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return V != B";

command !=(b1:bat[:oid,:lng],b2:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatNE
comment "Return B1 != B2";
pattern !=(b:bat[:oid,:lng],v:wrd) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return B != V";
pattern !=(v:lng,b:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return V != B";

command !=(b1:bat[:oid,:lng],b2:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatNE
comment "Return B1 != B2";
pattern !=(b:bat[:oid,:lng],v:lng) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return B != V";
pattern !=(v:lng,b:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return V != B";

command !=(b1:bat[:oid,:lng],b2:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatNE
comment "Return B1 != B2";
pattern !=(b:bat[:oid,:lng],v:flt) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return B != V";
pattern !=(v:lng,b:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return V != B";

command !=(b1:bat[:oid,:lng],b2:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatNE
comment "Return B1 != B2";
pattern !=(b:bat[:oid,:lng],v:dbl) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return B != V";
pattern !=(v:lng,b:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return V != B";

command !=(b1:bat[:oid,:flt],b2:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatNE
comment "Return B1 != B2";
pattern !=(b:bat[:oid,:flt],v:bte) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return B != V";
pattern !=(v:flt,b:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return V != B";

command !=(b1:bat[:oid,:flt],b2:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatNE
comment "Return B1 != B2";
pattern !=(b:bat[:oid,:flt],v:sht) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return B != V";
pattern !=(v:flt,b:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return V != B";

command !=(b1:bat[:oid,:flt],b2:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatNE
comment "Return B1 != B2";
pattern !=(b:bat[:oid,:flt],v:int) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return B != V";
pattern !=(v:flt,b:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return V != B";

command !=(b1:bat[:oid,:flt],b2:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatNE
comment "Return B1 != B2";
pattern !=(b:bat[:oid,:flt],v:wrd) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return B != V";
pattern !=(v:flt,b:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return V != B";

command !=(b1:bat[:oid,:flt],b2:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatNE
comment "Return B1 != B2";
pattern !=(b:bat[:oid,:flt],v:lng) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return B != V";
pattern !=(v:flt,b:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return V != B";

command !=(b1:bat[:oid,:flt],b2:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatNE
comment "Return B1 != B2";
pattern !=(b:bat[:oid,:flt],v:flt) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return B != V";
pattern !=(v:flt,b:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return V != B";

command !=(b1:bat[:oid,:flt],b2:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatNE
comment "Return B1 != B2";
pattern !=(b:bat[:oid,:flt],v:dbl) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return B != V";
pattern !=(v:flt,b:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return V != B";

command !=(b1:bat[:oid,:dbl],b2:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatNE
comment "Return B1 != B2";
pattern !=(b:bat[:oid,:dbl],v:bte) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return B != V";
pattern !=(v:dbl,b:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return V != B";

command !=(b1:bat[:oid,:dbl],b2:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatNE
comment "Return B1 != B2";
pattern !=(b:bat[:oid,:dbl],v:sht) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return B != V";
pattern !=(v:dbl,b:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return V != B";

command !=(b1:bat[:oid,:dbl],b2:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatNE
comment "Return B1 != B2";
pattern !=(b:bat[:oid,:dbl],v:int) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return B != V";
pattern !=(v:dbl,b:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return V != B";

command !=(b1:bat[:oid,:dbl],b2:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatNE
comment "Return B1 != B2";
pattern !=(b:bat[:oid,:dbl],v:wrd) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return B != V";
pattern !=(v:dbl,b:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return V != B";

command !=(b1:bat[:oid,:dbl],b2:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatNE
comment "Return B1 != B2";
pattern !=(b:bat[:oid,:dbl],v:lng) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return B != V";
pattern !=(v:dbl,b:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return V != B";

command !=(b1:bat[:oid,:dbl],b2:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatNE
comment "Return B1 != B2";
pattern !=(b:bat[:oid,:dbl],v:flt) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return B != V";
pattern !=(v:dbl,b:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return V != B";

command !=(b1:bat[:oid,:dbl],b2:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatNE
comment "Return B1 != B2";
pattern !=(b:bat[:oid,:dbl],v:dbl) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return B != V";
pattern !=(v:dbl,b:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return V != B";


command cmp(b1:bat[:oid,:bit],b2:bat[:oid,:bit]) :bat[:oid,:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2";
pattern cmp(b:bat[:oid,:bit],v:bit) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if B </==/> V";
pattern cmp(v:bit,b:bat[:oid,:bit]) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if V </==/> B";

command cmp(b1:bat[:oid,:str],b2:bat[:oid,:str]) :bat[:oid,:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2";
pattern cmp(b:bat[:oid,:str],v:str) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if B </==/> V";
pattern cmp(v:str,b:bat[:oid,:str]) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if V </==/> B";

command cmp(b1:bat[:oid,:oid],b2:bat[:oid,:oid]) :bat[:oid,:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2";
pattern cmp(b:bat[:oid,:oid],v:oid) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if B </==/> V";
pattern cmp(v:oid,b:bat[:oid,:oid]) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if V </==/> B";

command cmp(b1:bat[:oid,:bte],b2:bat[:oid,:bte]) :bat[:oid,:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2";
pattern cmp(b:bat[:oid,:bte],v:bte) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if B </==/> V";
pattern cmp(v:bte,b:bat[:oid,:bte]) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if V </==/> B";

command cmp(b1:bat[:oid,:bte],b2:bat[:oid,:sht]) :bat[:oid,:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2";
pattern cmp(b:bat[:oid,:bte],v:sht) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if B </==/> V";
pattern cmp(v:bte,b:bat[:oid,:sht]) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if V </==/> B";

command cmp(b1:bat[:oid,:bte],b2:bat[:oid,:int]) :bat[:oid,:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2";
pattern cmp(b:bat[:oid,:bte],v:int) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if B </==/> V";
pattern cmp(v:bte,b:bat[:oid,:int]) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if V </==/> B";

command cmp(b1:bat[:oid,:bte],b2:bat[:oid,:wrd]) :bat[:oid,:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2";
pattern cmp(b:bat[:oid,:bte],v:wrd) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if B </==/> V";
pattern cmp(v:bte,b:bat[:oid,:wrd]) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if V </==/> B";

command cmp(b1:bat[:oid,:bte],b2:bat[:oid,:lng]) :bat[:oid,:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2";
pattern cmp(b:bat[:oid,:bte],v:lng) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if B </==/> V";
pattern cmp(v:bte,b:bat[:oid,:lng]) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if V </==/> B";

command cmp(b1:bat[:oid,:bte],b2:bat[:oid,:flt]) :bat[:oid,:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2";
pattern cmp(b:bat[:oid,:bte],v:flt) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if B </==/> V";
pattern cmp(v:bte,b:bat[:oid,:flt]) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if V </==/> B";

command cmp(b1:bat[:oid,:bte],b2:bat[:oid,:dbl]) :bat[:oid,:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2";
pattern cmp(b:bat[:oid,:bte],v:dbl) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if B </==/> V";
pattern cmp(v:bte,b:bat[:oid,:dbl]) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if V </==/> B";

command cmp(b1:bat[:oid,:sht],b2:bat[:oid,:bte]) :bat[:oid,:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2";
pattern cmp(b:bat[:oid,:sht],v:bte) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if B </==/> V";
pattern cmp(v:sht,b:bat[:oid,:bte]) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if V </==/> B";

command cmp(b1:bat[:oid,:sht],b2:bat[:oid,:sht]) :bat[:oid,:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2";
pattern cmp(b:bat[:oid,:sht],v:sht) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if B </==/> V";
pattern cmp(v:sht,b:bat[:oid,:sht]) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if V </==/> B";

command cmp(b1:bat[:oid,:sht],b2:bat[:oid,:int]) :bat[:oid,:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2";
pattern cmp(b:bat[:oid,:sht],v:int) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if B </==/> V";
pattern cmp(v:sht,b:bat[:oid,:int]) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if V </==/> B";

command cmp(b1:bat[:oid,:sht],b2:bat[:oid,:wrd]) :bat[:oid,:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2";
pattern cmp(b:bat[:oid,:sht],v:wrd) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if B </==/> V";
pattern cmp(v:sht,b:bat[:oid,:wrd]) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if V </==/> B";

command cmp(b1:bat[:oid,:sht],b2:bat[:oid,:lng]) :bat[:oid,:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2";
pattern cmp(b:bat[:oid,:sht],v:lng) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if B </==/> V";
pattern cmp(v:sht,b:bat[:oid,:lng]) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if V </==/> B";

command cmp(b1:bat[:oid,:sht],b2:bat[:oid,:flt]) :bat[:oid,:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2";
pattern cmp(b:bat[:oid,:sht],v:flt) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if B </==/> V";
pattern cmp(v:sht,b:bat[:oid,:flt]) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if V </==/> B";

command cmp(b1:bat[:oid,:sht],b2:bat[:oid,:dbl]) :bat[:oid,:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2";
pattern cmp(b:bat[:oid,:sht],v:dbl) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if B </==/> V";
pattern cmp(v:sht,b:bat[:oid,:dbl]) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if V </==/> B";

command cmp(b1:bat[:oid,:int],b2:bat[:oid,:bte]) :bat[:oid,:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2";
pattern cmp(b:bat[:oid,:int],v:bte) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if B </==/> V";
pattern cmp(v:int,b:bat[:oid,:bte]) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if V </==/> B";

command cmp(b1:bat[:oid,:int],b2:bat[:oid,:sht]) :bat[:oid,:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2";
pattern cmp(b:bat[:oid,:int],v:sht) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if B </==/> V";
pattern cmp(v:int,b:bat[:oid,:sht]) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if V </==/> B";

command cmp(b1:bat[:oid,:int],b2:bat[:oid,:int]) :bat[:oid,:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2";
pattern cmp(b:bat[:oid,:int],v:int) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if B </==/> V";
pattern cmp(v:int,b:bat[:oid,:int]) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if V </==/> B";

command cmp(b1:bat[:oid,:int],b2:bat[:oid,:wrd]) :bat[:oid,:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2";
pattern cmp(b:bat[:oid,:int],v:wrd) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if B </==/> V";
pattern cmp(v:int,b:bat[:oid,:wrd]) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if V </==/> B";

command cmp(b1:bat[:oid,:int],b2:bat[:oid,:lng]) :bat[:oid,:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2";
pattern cmp(b:bat[:oid,:int],v:lng) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if B </==/> V";
pattern cmp(v:int,b:bat[:oid,:lng]) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if V </==/> B";

command cmp(b1:bat[:oid,:int],b2:bat[:oid,:flt]) :bat[:oid,:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2";
pattern cmp(b:bat[:oid,:int],v:flt) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if B </==/> V";
pattern cmp(v:int,b:bat[:oid,:flt]) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if V </==/> B";

command cmp(b1:bat[:oid,:int],b2:bat[:oid,:dbl]) :bat[:oid,:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2";
pattern cmp(b:bat[:oid,:int],v:dbl) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if B </==/> V";
pattern cmp(v:int,b:bat[:oid,:dbl]) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if V </==/> B";

command cmp(b1:bat[:oid,:wrd],b2:bat[:oid,:bte]) :bat[:oid,:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2";
pattern cmp(b:bat[:oid,:wrd],v:bte) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if B </==/> V";
pattern cmp(v:wrd,b:bat[:oid,:bte]) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if V </==/> B";

command cmp(b1:bat[:oid,:wrd],b2:bat[:oid,:sht]) :bat[:oid,:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2";
pattern cmp(b:bat[:oid,:wrd],v:sht) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if B </==/> V";
pattern cmp(v:wrd,b:bat[:oid,:sht]) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if V </==/> B";

command cmp(b1:bat[:oid,:wrd],b2:bat[:oid,:int]) :bat[:oid,:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2";
pattern cmp(b:bat[:oid,:wrd],v:int) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if B </==/> V";
pattern cmp(v:wrd,b:bat[:oid,:int]) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if V </==/> B";

command cmp(b1:bat[:oid,:wrd],b2:bat[:oid,:wrd]) :bat[:oid,:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2";
pattern cmp(b:bat[:oid,:wrd],v:wrd) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if B </==/> V";
pattern cmp(v:wrd,b:bat[:oid,:wrd]) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if V </==/> B";

command cmp(b1:bat[:oid,:wrd],b2:bat[:oid,:lng]) :bat[:oid,:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2";
pattern cmp(b:bat[:oid,:wrd],v:lng) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if B </==/> V";
pattern cmp(v:wrd,b:bat[:oid,:lng]) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if V </==/> B";

command cmp(b1:bat[:oid,:wrd],b2:bat[:oid,:flt]) :bat[:oid,:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2";
pattern cmp(b:bat[:oid,:wrd],v:flt) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if B </==/> V";
pattern cmp(v:wrd,b:bat[:oid,:flt]) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if V </==/> B";

command cmp(b1:bat[:oid,:wrd],b2:bat[:oid,:dbl]) :bat[:oid,:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2";
pattern cmp(b:bat[:oid,:wrd],v:dbl) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if B </==/> V";
pattern cmp(v:wrd,b:bat[:oid,:dbl]) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if V </==/> B";

command cmp(b1:bat[:oid,:lng],b2:bat[:oid,:bte]) :bat[:oid,:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2";
pattern cmp(b:bat[:oid,:lng],v:bte) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if B </==/> V";
pattern cmp(v:lng,b:bat[:oid,:bte]) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if V </==/> B";

command cmp(b1:bat[:oid,:lng],b2:bat[:oid,:sht]) :bat[:oid,:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2";
pattern cmp(b:bat[:oid,:lng],v:sht) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if B </==/> V";
pattern cmp(v:lng,b:bat[:oid,:sht]) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if V </==/> B";

command cmp(b1:bat[:oid,:lng],b2:bat[:oid,:int]) :bat[:oid,:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2";
pattern cmp(b:bat[:oid,:lng],v:int) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if B </==/> V";
pattern cmp(v:lng,b:bat[:oid,:int]) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if V </==/> B";

command cmp(b1:bat[:oid,:lng],b2:bat[:oid,:wrd]) :bat[:oid,:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2";
pattern cmp(b:bat[:oid,:lng],v:wrd) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if B </==/> V";
pattern cmp(v:lng,b:bat[:oid,:wrd]) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if V </==/> B";

command cmp(b1:bat[:oid,:lng],b2:bat[:oid,:lng]) :bat[:oid,:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2";
pattern cmp(b:bat[:oid,:lng],v:lng) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if B </==/> V";
pattern cmp(v:lng,b:bat[:oid,:lng]) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if V </==/> B";

command cmp(b1:bat[:oid,:lng],b2:bat[:oid,:flt]) :bat[:oid,:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2";
pattern cmp(b:bat[:oid,:lng],v:flt) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if B </==/> V";
pattern cmp(v:lng,b:bat[:oid,:flt]) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if V </==/> B";

command cmp(b1:bat[:oid,:lng],b2:bat[:oid,:dbl]) :bat[:oid,:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2";
pattern cmp(b:bat[:oid,:lng],v:dbl) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if B </==/> V";
pattern cmp(v:lng,b:bat[:oid,:dbl]) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if V </==/> B";

command cmp(b1:bat[:oid,:flt],b2:bat[:oid,:bte]) :bat[:oid,:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2";
pattern cmp(b:bat[:oid,:flt],v:bte) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if B </==/> V";
pattern cmp(v:flt,b:bat[:oid,:bte]) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if V </==/> B";

command cmp(b1:bat[:oid,:flt],b2:bat[:oid,:sht]) :bat[:oid,:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2";
pattern cmp(b:bat[:oid,:flt],v:sht) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if B </==/> V";
pattern cmp(v:flt,b:bat[:oid,:sht]) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if V </==/> B";

command cmp(b1:bat[:oid,:flt],b2:bat[:oid,:int]) :bat[:oid,:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2";
pattern cmp(b:bat[:oid,:flt],v:int) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if B </==/> V";
pattern cmp(v:flt,b:bat[:oid,:int]) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if V </==/> B";

command cmp(b1:bat[:oid,:flt],b2:bat[:oid,:wrd]) :bat[:oid,:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2";
pattern cmp(b:bat[:oid,:flt],v:wrd) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if B </==/> V";
pattern cmp(v:flt,b:bat[:oid,:wrd]) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if V </==/> B";

command cmp(b1:bat[:oid,:flt],b2:bat[:oid,:lng]) :bat[:oid,:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2";
pattern cmp(b:bat[:oid,:flt],v:lng) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if B </==/> V";
pattern cmp(v:flt,b:bat[:oid,:lng]) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if V </==/> B";

command cmp(b1:bat[:oid,:flt],b2:bat[:oid,:flt]) :bat[:oid,:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2";
pattern cmp(b:bat[:oid,:flt],v:flt) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if B </==/> V";
pattern cmp(v:flt,b:bat[:oid,:flt]) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if V </==/> B";

command cmp(b1:bat[:oid,:flt],b2:bat[:oid,:dbl]) :bat[:oid,:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2";
pattern cmp(b:bat[:oid,:flt],v:dbl) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if B </==/> V";
pattern cmp(v:flt,b:bat[:oid,:dbl]) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if V </==/> B";

command cmp(b1:bat[:oid,:dbl],b2:bat[:oid,:bte]) :bat[:oid,:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2";
pattern cmp(b:bat[:oid,:dbl],v:bte) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if B </==/> V";
pattern cmp(v:dbl,b:bat[:oid,:bte]) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if V </==/> B";

command cmp(b1:bat[:oid,:dbl],b2:bat[:oid,:sht]) :bat[:oid,:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2";
pattern cmp(b:bat[:oid,:dbl],v:sht) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if B </==/> V";
pattern cmp(v:dbl,b:bat[:oid,:sht]) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if V </==/> B";

command cmp(b1:bat[:oid,:dbl],b2:bat[:oid,:int]) :bat[:oid,:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2";
pattern cmp(b:bat[:oid,:dbl],v:int) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if B </==/> V";
pattern cmp(v:dbl,b:bat[:oid,:int]) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if V </==/> B";

command cmp(b1:bat[:oid,:dbl],b2:bat[:oid,:wrd]) :bat[:oid,:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2";
pattern cmp(b:bat[:oid,:dbl],v:wrd) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if B </==/> V";
pattern cmp(v:dbl,b:bat[:oid,:wrd]) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if V </==/> B";

command cmp(b1:bat[:oid,:dbl],b2:bat[:oid,:lng]) :bat[:oid,:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2";
pattern cmp(b:bat[:oid,:dbl],v:lng) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if B </==/> V";
pattern cmp(v:dbl,b:bat[:oid,:lng]) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if V </==/> B";

command cmp(b1:bat[:oid,:dbl],b2:bat[:oid,:flt]) :bat[:oid,:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2";
pattern cmp(b:bat[:oid,:dbl],v:flt) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if B </==/> V";
pattern cmp(v:dbl,b:bat[:oid,:flt]) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if V </==/> B";

command cmp(b1:bat[:oid,:dbl],b2:bat[:oid,:dbl]) :bat[:oid,:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2";
pattern cmp(b:bat[:oid,:dbl],v:dbl) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if B </==/> V";
pattern cmp(v:dbl,b:bat[:oid,:dbl]) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if V </==/> B";


pattern between(b:bat[:oid,:bit],lo:bat[:oid,:bit],hi:bat[:oid,:bit]) :bit
address CMDbatBETWEEN
comment "B between LO and HI inclusive, nil border is (minus) infinity";
pattern between(b:bat[:oid,:bit],lo:bat[:oid,:bit],hi:bit) :bit
address CMDbatBETWEEN
comment "B between LO and HI inclusive, nil border is (minus) infinity";
pattern between(b:bat[:oid,:bit],lo:bit,hi:bat[:oid,:bit]) :bit
address CMDbatBETWEEN
comment "B between LO and HI inclusive, nil border is (minus) infinity";
pattern between(b:bat[:oid,:bit],lo:bit,hi:bit) :bit
address CMDbatBETWEEN
comment "B between LO and HI inclusive, nil border is (minus) infinity";

pattern between(b:bat[:oid,:bte],lo:bat[:oid,:bte],hi:bat[:oid,:bte]) :bit
address CMDbatBETWEEN
comment "B between LO and HI inclusive, nil border is (minus) infinity";
pattern between(b:bat[:oid,:bte],lo:bat[:oid,:bte],hi:bte) :bit
address CMDbatBETWEEN
comment "B between LO and HI inclusive, nil border is (minus) infinity";
pattern between(b:bat[:oid,:bte],lo:bte,hi:bat[:oid,:bte]) :bit
address CMDbatBETWEEN
comment "B between LO and HI inclusive, nil border is (minus) infinity";
pattern between(b:bat[:oid,:bte],lo:bte,hi:bte) :bit
address CMDbatBETWEEN
comment "B between LO and HI inclusive, nil border is (minus) infinity";

pattern between(b:bat[:oid,:sht],lo:bat[:oid,:sht],hi:bat[:oid,:sht]) :bit
address CMDbatBETWEEN
comment "B between LO and HI inclusive, nil border is (minus) infinity";
pattern between(b:bat[:oid,:sht],lo:bat[:oid,:sht],hi:sht) :bit
address CMDbatBETWEEN
comment "B between LO and HI inclusive, nil border is (minus) infinity";
pattern between(b:bat[:oid,:sht],lo:sht,hi:bat[:oid,:sht]) :bit
address CMDbatBETWEEN
comment "B between LO and HI inclusive, nil border is (minus) infinity";
pattern between(b:bat[:oid,:sht],lo:sht,hi:sht) :bit
address CMDbatBETWEEN
comment "B between LO and HI inclusive, nil border is (minus) infinity";

pattern between(b:bat[:oid,:int],lo:bat[:oid,:int],hi:bat[:oid,:int]) :bit
address CMDbatBETWEEN
comment "B between LO and HI inclusive, nil border is (minus) infinity";
pattern between(b:bat[:oid,:int],lo:bat[:oid,:int],hi:int) :bit
address CMDbatBETWEEN
comment "B between LO and HI inclusive, nil border is (minus) infinity";
pattern between(b:bat[:oid,:int],lo:int,hi:bat[:oid,:int]) :bit
address CMDbatBETWEEN
comment "B between LO and HI inclusive, nil border is (minus) infinity";
pattern between(b:bat[:oid,:int],lo:int,hi:int) :bit
address CMDbatBETWEEN
comment "B between LO and HI inclusive, nil border is (minus) infinity";

pattern between(b:bat[:oid,:wrd],lo:bat[:oid,:wrd],hi:bat[:oid,:wrd]) :bit
address CMDbatBETWEEN
comment "B between LO and HI inclusive, nil border is (minus) infinity";
pattern between(b:bat[:oid,:wrd],lo:bat[:oid,:wrd],hi:wrd) :bit
address CMDbatBETWEEN
comment "B between LO and HI inclusive, nil border is (minus) infinity";
pattern between(b:bat[:oid,:wrd],lo:wrd,hi:bat[:oid,:wrd]) :bit
address CMDbatBETWEEN
comment "B between LO and HI inclusive, nil border is (minus) infinity";
pattern between(b:bat[:oid,:wrd],lo:wrd,hi:wrd) :bit
address CMDbatBETWEEN
comment "B between LO and HI inclusive, nil border is (minus) infinity";

pattern between(b:bat[:oid,:lng],lo:bat[:oid,:lng],hi:bat[:oid,:lng]) :bit
address CMDbatBETWEEN
comment "B between LO and HI inclusive, nil border is (minus) infinity";
pattern between(b:bat[:oid,:lng],lo:bat[:oid,:lng],hi:lng) :bit
address CMDbatBETWEEN
comment "B between LO and HI inclusive, nil border is (minus) infinity";
pattern between(b:bat[:oid,:lng],lo:lng,hi:bat[:oid,:lng]) :bit
address CMDbatBETWEEN
comment "B between LO and HI inclusive, nil border is (minus) infinity";
pattern between(b:bat[:oid,:lng],lo:lng,hi:lng) :bit
address CMDbatBETWEEN
comment "B between LO and HI inclusive, nil border is (minus) infinity";

pattern between(b:bat[:oid,:flt],lo:bat[:oid,:flt],hi:bat[:oid,:flt]) :bit
address CMDbatBETWEEN
comment "B between LO and HI inclusive, nil border is (minus) infinity";
pattern between(b:bat[:oid,:flt],lo:bat[:oid,:flt],hi:flt) :bit
address CMDbatBETWEEN
comment "B between LO and HI inclusive, nil border is (minus) infinity";
pattern between(b:bat[:oid,:flt],lo:flt,hi:bat[:oid,:flt]) :bit
address CMDbatBETWEEN
comment "B between LO and HI inclusive, nil border is (minus) infinity";
pattern between(b:bat[:oid,:flt],lo:flt,hi:flt) :bit
address CMDbatBETWEEN
comment "B between LO and HI inclusive, nil border is (minus) infinity";

pattern between(b:bat[:oid,:dbl],lo:bat[:oid,:dbl],hi:bat[:oid,:dbl]) :bit
address CMDbatBETWEEN
comment "B between LO and HI inclusive, nil border is (minus) infinity";
pattern between(b:bat[:oid,:dbl],lo:bat[:oid,:dbl],hi:dbl) :bit
address CMDbatBETWEEN
comment "B between LO and HI inclusive, nil border is (minus) infinity";
pattern between(b:bat[:oid,:dbl],lo:dbl,hi:bat[:oid,:dbl]) :bit
address CMDbatBETWEEN
comment "B between LO and HI inclusive, nil border is (minus) infinity";
pattern between(b:bat[:oid,:dbl],lo:dbl,hi:dbl) :bit
address CMDbatBETWEEN
comment "B between LO and HI inclusive, nil border is (minus) infinity";

pattern between(b:bat[:oid,:oid],lo:bat[:oid,:oid],hi:bat[:oid,:oid]) :bit
address CMDbatBETWEEN
comment "B between LO and HI inclusive, nil border is (minus) infinity";
pattern between(b:bat[:oid,:oid],lo:bat[:oid,:oid],hi:oid) :bit
address CMDbatBETWEEN
comment "B between LO and HI inclusive, nil border is (minus) infinity";
pattern between(b:bat[:oid,:oid],lo:oid,hi:bat[:oid,:oid]) :bit
address CMDbatBETWEEN
comment "B between LO and HI inclusive, nil border is (minus) infinity";
pattern between(b:bat[:oid,:oid],lo:oid,hi:oid) :bit
address CMDbatBETWEEN
comment "B between LO and HI inclusive, nil border is (minus) infinity";


command avg(b:bat[:oid,:bte]) :dbl
address CMDcalcavg
comment "average of non-nil values of B";
command avg2(b:bat[:oid,:bte]) (:dbl, :lng)
address CMDcalcavg2
comment "average and number of non-nil values of B";

command avg(b:bat[:oid,:sht]) :dbl
address CMDcalcavg
comment "average of non-nil values of B";
command avg2(b:bat[:oid,:sht]) (:dbl, :lng)
address CMDcalcavg2
comment "average and number of non-nil values of B";

command avg(b:bat[:oid,:int]) :dbl
address CMDcalcavg
comment "average of non-nil values of B";
command avg2(b:bat[:oid,:int]) (:dbl, :lng)
address CMDcalcavg2
comment "average and number of non-nil values of B";

command avg(b:bat[:oid,:wrd]) :dbl
address CMDcalcavg
comment "average of non-nil values of B";
command avg2(b:bat[:oid,:wrd]) (:dbl, :lng)
address CMDcalcavg2
comment "average and number of non-nil values of B";

command avg(b:bat[:oid,:lng]) :dbl
address CMDcalcavg
comment "average of non-nil values of B";
command avg2(b:bat[:oid,:lng]) (:dbl, :lng)
address CMDcalcavg2
comment "average and number of non-nil values of B";

command avg(b:bat[:oid,:flt]) :dbl
address CMDcalcavg
comment "average of non-nil values of B";
command avg2(b:bat[:oid,:flt]) (:dbl, :lng)
address CMDcalcavg2
comment "average and number of non-nil values of B";

command avg(b:bat[:oid,:dbl]) :dbl
address CMDcalcavg
comment "average of non-nil values of B";
command avg2(b:bat[:oid,:dbl]) (:dbl, :lng)
address CMDcalcavg2
comment "average and number of non-nil values of B";

command bit(b:bat[:any_1,:bit]) :bat[:any_1,:bit]
address CMDconvertsignal_bit
comment "cast from bit to bit, signal error on overflow";
pattern bit(v:bit) :bit
address CMDconvertsignal
comment "cast from bit to bit, signal error on overflow";
command bit_noerror(b:bat[:any_1,:bit]) :bat[:any_1,:bit]
address CMDconvert_bit
comment "cast from bit to bit";
pattern bit_noerror(v:bit) :bit
address CMDconvert
comment "cast from bit to bit";

command bit(b:bat[:any_1,:bte]) :bat[:any_1,:bit]
address CMDconvertsignal_bit
comment "cast from bte to bit, signal error on overflow";
pattern bit(v:bte) :bit
address CMDconvertsignal
comment "cast from bte to bit, signal error on overflow";
command bit_noerror(b:bat[:any_1,:bte]) :bat[:any_1,:bit]
address CMDconvert_bit
comment "cast from bte to bit";
pattern bit_noerror(v:bte) :bit
address CMDconvert
comment "cast from bte to bit";

command bit(b:bat[:any_1,:sht]) :bat[:any_1,:bit]
address CMDconvertsignal_bit
comment "cast from sht to bit, signal error on overflow";
pattern bit(v:sht) :bit
address CMDconvertsignal
comment "cast from sht to bit, signal error on overflow";
command bit_noerror(b:bat[:any_1,:sht]) :bat[:any_1,:bit]
address CMDconvert_bit
comment "cast from sht to bit";
pattern bit_noerror(v:sht) :bit
address CMDconvert
comment "cast from sht to bit";

command bit(b:bat[:any_1,:int]) :bat[:any_1,:bit]
address CMDconvertsignal_bit
comment "cast from int to bit, signal error on overflow";
pattern bit(v:int) :bit
address CMDconvertsignal
comment "cast from int to bit, signal error on overflow";
command bit_noerror(b:bat[:any_1,:int]) :bat[:any_1,:bit]
address CMDconvert_bit
comment "cast from int to bit";
pattern bit_noerror(v:int) :bit
address CMDconvert
comment "cast from int to bit";

command bit(b:bat[:any_1,:wrd]) :bat[:any_1,:bit]
address CMDconvertsignal_bit
comment "cast from wrd to bit, signal error on overflow";
pattern bit(v:wrd) :bit
address CMDconvertsignal
comment "cast from wrd to bit, signal error on overflow";
command bit_noerror(b:bat[:any_1,:wrd]) :bat[:any_1,:bit]
address CMDconvert_bit
comment "cast from wrd to bit";
pattern bit_noerror(v:wrd) :bit
address CMDconvert
comment "cast from wrd to bit";

command bit(b:bat[:any_1,:lng]) :bat[:any_1,:bit]
address CMDconvertsignal_bit
comment "cast from lng to bit, signal error on overflow";
pattern bit(v:lng) :bit
address CMDconvertsignal
comment "cast from lng to bit, signal error on overflow";
command bit_noerror(b:bat[:any_1,:lng]) :bat[:any_1,:bit]
address CMDconvert_bit
comment "cast from lng to bit";
pattern bit_noerror(v:lng) :bit
address CMDconvert
comment "cast from lng to bit";

command bit(b:bat[:any_1,:flt]) :bat[:any_1,:bit]
address CMDconvertsignal_bit
comment "cast from flt to bit, signal error on overflow";
pattern bit(v:flt) :bit
address CMDconvertsignal
comment "cast from flt to bit, signal error on overflow";
command bit_noerror(b:bat[:any_1,:flt]) :bat[:any_1,:bit]
address CMDconvert_bit
comment "cast from flt to bit";
pattern bit_noerror(v:flt) :bit
address CMDconvert
comment "cast from flt to bit";

command bit(b:bat[:any_1,:dbl]) :bat[:any_1,:bit]
address CMDconvertsignal_bit
comment "cast from dbl to bit, signal error on overflow";
pattern bit(v:dbl) :bit
address CMDconvertsignal
comment "cast from dbl to bit, signal error on overflow";
command bit_noerror(b:bat[:any_1,:dbl]) :bat[:any_1,:bit]
address CMDconvert_bit
comment "cast from dbl to bit";
pattern bit_noerror(v:dbl) :bit
address CMDconvert
comment "cast from dbl to bit";

command bit(b:bat[:any_1,:oid]) :bat[:any_1,:bit]
address CMDconvertsignal_bit
comment "cast from oid to bit, signal error on overflow";
pattern bit(v:oid) :bit
address CMDconvertsignal
comment "cast from oid to bit, signal error on overflow";
command bit_noerror(b:bat[:any_1,:oid]) :bat[:any_1,:bit]
address CMDconvert_bit
comment "cast from oid to bit";
pattern bit_noerror(v:oid) :bit
address CMDconvert
comment "cast from oid to bit";

command bit(b:bat[:any_1,:str]) :bat[:any_1,:bit]
address CMDconvertsignal_bit
comment "cast from str to bit, signal error on overflow";
pattern bit(v:str) :bit
address CMDconvertsignal
comment "cast from str to bit, signal error on overflow";
command bit_noerror(b:bat[:any_1,:str]) :bat[:any_1,:bit]
address CMDconvert_bit
comment "cast from str to bit";
pattern bit_noerror(v:str) :bit
address CMDconvert
comment "cast from str to bit";

command bte(b:bat[:any_1,:bit]) :bat[:any_1,:bte]
address CMDconvertsignal_bte
comment "cast from bit to bte, signal error on overflow";
pattern bte(v:bit) :bte
address CMDconvertsignal
comment "cast from bit to bte, signal error on overflow";
command bte_noerror(b:bat[:any_1,:bit]) :bat[:any_1,:bte]
address CMDconvert_bte
comment "cast from bit to bte";
pattern bte_noerror(v:bit) :bte
address CMDconvert
comment "cast from bit to bte";

command bte(b:bat[:any_1,:bte]) :bat[:any_1,:bte]
address CMDconvertsignal_bte
comment "cast from bte to bte, signal error on overflow";
pattern bte(v:bte) :bte
address CMDconvertsignal
comment "cast from bte to bte, signal error on overflow";
command bte_noerror(b:bat[:any_1,:bte]) :bat[:any_1,:bte]
address CMDconvert_bte
comment "cast from bte to bte";
pattern bte_noerror(v:bte) :bte
address CMDconvert
comment "cast from bte to bte";

command bte(b:bat[:any_1,:sht]) :bat[:any_1,:bte]
address CMDconvertsignal_bte
comment "cast from sht to bte, signal error on overflow";
pattern bte(v:sht) :bte
address CMDconvertsignal
comment "cast from sht to bte, signal error on overflow";
command bte_noerror(b:bat[:any_1,:sht]) :bat[:any_1,:bte]
address CMDconvert_bte
comment "cast from sht to bte";
pattern bte_noerror(v:sht) :bte
address CMDconvert
comment "cast from sht to bte";

command bte(b:bat[:any_1,:int]) :bat[:any_1,:bte]
address CMDconvertsignal_bte
comment "cast from int to bte, signal error on overflow";
pattern bte(v:int) :bte
address CMDconvertsignal
comment "cast from int to bte, signal error on overflow";
command bte_noerror(b:bat[:any_1,:int]) :bat[:any_1,:bte]
address CMDconvert_bte
comment "cast from int to bte";
pattern bte_noerror(v:int) :bte
address CMDconvert
comment "cast from int to bte";

command bte(b:bat[:any_1,:wrd]) :bat[:any_1,:bte]
address CMDconvertsignal_bte
comment "cast from wrd to bte, signal error on overflow";
pattern bte(v:wrd) :bte
address CMDconvertsignal
comment "cast from wrd to bte, signal error on overflow";
command bte_noerror(b:bat[:any_1,:wrd]) :bat[:any_1,:bte]
address CMDconvert_bte
comment "cast from wrd to bte";
pattern bte_noerror(v:wrd) :bte
address CMDconvert
comment "cast from wrd to bte";

command bte(b:bat[:any_1,:lng]) :bat[:any_1,:bte]
address CMDconvertsignal_bte
comment "cast from lng to bte, signal error on overflow";
pattern bte(v:lng) :bte
address CMDconvertsignal
comment "cast from lng to bte, signal error on overflow";
command bte_noerror(b:bat[:any_1,:lng]) :bat[:any_1,:bte]
address CMDconvert_bte
comment "cast from lng to bte";
pattern bte_noerror(v:lng) :bte
address CMDconvert
comment "cast from lng to bte";

command bte(b:bat[:any_1,:flt]) :bat[:any_1,:bte]
address CMDconvertsignal_bte
comment "cast from flt to bte, signal error on overflow";
pattern bte(v:flt) :bte
address CMDconvertsignal
comment "cast from flt to bte, signal error on overflow";
command bte_noerror(b:bat[:any_1,:flt]) :bat[:any_1,:bte]
address CMDconvert_bte
comment "cast from flt to bte";
pattern bte_noerror(v:flt) :bte
address CMDconvert
comment "cast from flt to bte";

command bte(b:bat[:any_1,:dbl]) :bat[:any_1,:bte]
address CMDconvertsignal_bte
comment "cast from dbl to bte, signal error on overflow";
pattern bte(v:dbl) :bte
address CMDconvertsignal
comment "cast from dbl to bte, signal error on overflow";
command bte_noerror(b:bat[:any_1,:dbl]) :bat[:any_1,:bte]
address CMDconvert_bte
comment "cast from dbl to bte";
pattern bte_noerror(v:dbl) :bte
address CMDconvert
comment "cast from dbl to bte";

command bte(b:bat[:any_1,:oid]) :bat[:any_1,:bte]
address CMDconvertsignal_bte
comment "cast from oid to bte, signal error on overflow";
pattern bte(v:oid) :bte
address CMDconvertsignal
comment "cast from oid to bte, signal error on overflow";
command bte_noerror(b:bat[:any_1,:oid]) :bat[:any_1,:bte]
address CMDconvert_bte
comment "cast from oid to bte";
pattern bte_noerror(v:oid) :bte
address CMDconvert
comment "cast from oid to bte";

command bte(b:bat[:any_1,:str]) :bat[:any_1,:bte]
address CMDconvertsignal_bte
comment "cast from str to bte, signal error on overflow";
pattern bte(v:str) :bte
address CMDconvertsignal
comment "cast from str to bte, signal error on overflow";
command bte_noerror(b:bat[:any_1,:str]) :bat[:any_1,:bte]
address CMDconvert_bte
comment "cast from str to bte";
pattern bte_noerror(v:str) :bte
address CMDconvert
comment "cast from str to bte";

command sht(b:bat[:any_1,:bit]) :bat[:any_1,:sht]
address CMDconvertsignal_sht
comment "cast from bit to sht, signal error on overflow";
pattern sht(v:bit) :sht
address CMDconvertsignal
comment "cast from bit to sht, signal error on overflow";
command sht_noerror(b:bat[:any_1,:bit]) :bat[:any_1,:sht]
address CMDconvert_sht
comment "cast from bit to sht";
pattern sht_noerror(v:bit) :sht
address CMDconvert
comment "cast from bit to sht";

command sht(b:bat[:any_1,:bte]) :bat[:any_1,:sht]
address CMDconvertsignal_sht
comment "cast from bte to sht, signal error on overflow";
pattern sht(v:bte) :sht
address CMDconvertsignal
comment "cast from bte to sht, signal error on overflow";
command sht_noerror(b:bat[:any_1,:bte]) :bat[:any_1,:sht]
address CMDconvert_sht
comment "cast from bte to sht";
pattern sht_noerror(v:bte) :sht
address CMDconvert
comment "cast from bte to sht";

command sht(b:bat[:any_1,:sht]) :bat[:any_1,:sht]
address CMDconvertsignal_sht
comment "cast from sht to sht, signal error on overflow";
pattern sht(v:sht) :sht
address CMDconvertsignal
comment "cast from sht to sht, signal error on overflow";
command sht_noerror(b:bat[:any_1,:sht]) :bat[:any_1,:sht]
address CMDconvert_sht
comment "cast from sht to sht";
pattern sht_noerror(v:sht) :sht
address CMDconvert
comment "cast from sht to sht";

command sht(b:bat[:any_1,:int]) :bat[:any_1,:sht]
address CMDconvertsignal_sht
comment "cast from int to sht, signal error on overflow";
pattern sht(v:int) :sht
address CMDconvertsignal
comment "cast from int to sht, signal error on overflow";
command sht_noerror(b:bat[:any_1,:int]) :bat[:any_1,:sht]
address CMDconvert_sht
comment "cast from int to sht";
pattern sht_noerror(v:int) :sht
address CMDconvert
comment "cast from int to sht";

command sht(b:bat[:any_1,:wrd]) :bat[:any_1,:sht]
address CMDconvertsignal_sht
comment "cast from wrd to sht, signal error on overflow";
pattern sht(v:wrd) :sht
address CMDconvertsignal
comment "cast from wrd to sht, signal error on overflow";
command sht_noerror(b:bat[:any_1,:wrd]) :bat[:any_1,:sht]
address CMDconvert_sht
comment "cast from wrd to sht";
pattern sht_noerror(v:wrd) :sht
address CMDconvert
comment "cast from wrd to sht";

command sht(b:bat[:any_1,:lng]) :bat[:any_1,:sht]
address CMDconvertsignal_sht
comment "cast from lng to sht, signal error on overflow";
pattern sht(v:lng) :sht
address CMDconvertsignal
comment "cast from lng to sht, signal error on overflow";
command sht_noerror(b:bat[:any_1,:lng]) :bat[:any_1,:sht]
address CMDconvert_sht
comment "cast from lng to sht";
pattern sht_noerror(v:lng) :sht
address CMDconvert
comment "cast from lng to sht";

command sht(b:bat[:any_1,:flt]) :bat[:any_1,:sht]
address CMDconvertsignal_sht
comment "cast from flt to sht, signal error on overflow";
pattern sht(v:flt) :sht
address CMDconvertsignal
comment "cast from flt to sht, signal error on overflow";
command sht_noerror(b:bat[:any_1,:flt]) :bat[:any_1,:sht]
address CMDconvert_sht
comment "cast from flt to sht";
pattern sht_noerror(v:flt) :sht
address CMDconvert
comment "cast from flt to sht";

command sht(b:bat[:any_1,:dbl]) :bat[:any_1,:sht]
address CMDconvertsignal_sht
comment "cast from dbl to sht, signal error on overflow";
pattern sht(v:dbl) :sht
address CMDconvertsignal
comment "cast from dbl to sht, signal error on overflow";
command sht_noerror(b:bat[:any_1,:dbl]) :bat[:any_1,:sht]
address CMDconvert_sht
comment "cast from dbl to sht";
pattern sht_noerror(v:dbl) :sht
address CMDconvert
comment "cast from dbl to sht";

command sht(b:bat[:any_1,:oid]) :bat[:any_1,:sht]
address CMDconvertsignal_sht
comment "cast from oid to sht, signal error on overflow";
pattern sht(v:oid) :sht
address CMDconvertsignal
comment "cast from oid to sht, signal error on overflow";
command sht_noerror(b:bat[:any_1,:oid]) :bat[:any_1,:sht]
address CMDconvert_sht
comment "cast from oid to sht";
pattern sht_noerror(v:oid) :sht
address CMDconvert
comment "cast from oid to sht";

command sht(b:bat[:any_1,:str]) :bat[:any_1,:sht]
address CMDconvertsignal_sht
comment "cast from str to sht, signal error on overflow";
pattern sht(v:str) :sht
address CMDconvertsignal
comment "cast from str to sht, signal error on overflow";
command sht_noerror(b:bat[:any_1,:str]) :bat[:any_1,:sht]
address CMDconvert_sht
comment "cast from str to sht";
pattern sht_noerror(v:str) :sht
address CMDconvert
comment "cast from str to sht";

command int(b:bat[:any_1,:bit]) :bat[:any_1,:int]
address CMDconvertsignal_int
comment "cast from bit to int, signal error on overflow";
pattern int(v:bit) :int
address CMDconvertsignal
comment "cast from bit to int, signal error on overflow";
command int_noerror(b:bat[:any_1,:bit]) :bat[:any_1,:int]
address CMDconvert_int
comment "cast from bit to int";
pattern int_noerror(v:bit) :int
address CMDconvert
comment "cast from bit to int";

command int(b:bat[:any_1,:bte]) :bat[:any_1,:int]
address CMDconvertsignal_int
comment "cast from bte to int, signal error on overflow";
pattern int(v:bte) :int
address CMDconvertsignal
comment "cast from bte to int, signal error on overflow";
command int_noerror(b:bat[:any_1,:bte]) :bat[:any_1,:int]
address CMDconvert_int
comment "cast from bte to int";
pattern int_noerror(v:bte) :int
address CMDconvert
comment "cast from bte to int";

command int(b:bat[:any_1,:sht]) :bat[:any_1,:int]
address CMDconvertsignal_int
comment "cast from sht to int, signal error on overflow";
pattern int(v:sht) :int
address CMDconvertsignal
comment "cast from sht to int, signal error on overflow";
command int_noerror(b:bat[:any_1,:sht]) :bat[:any_1,:int]
address CMDconvert_int
comment "cast from sht to int";
pattern int_noerror(v:sht) :int
address CMDconvert
comment "cast from sht to int";

command int(b:bat[:any_1,:int]) :bat[:any_1,:int]
address CMDconvertsignal_int
comment "cast from int to int, signal error on overflow";
pattern int(v:int) :int
address CMDconvertsignal
comment "cast from int to int, signal error on overflow";
command int_noerror(b:bat[:any_1,:int]) :bat[:any_1,:int]
address CMDconvert_int
comment "cast from int to int";
pattern int_noerror(v:int) :int
address CMDconvert
comment "cast from int to int";

command int(b:bat[:any_1,:wrd]) :bat[:any_1,:int]
address CMDconvertsignal_int
comment "cast from wrd to int, signal error on overflow";
pattern int(v:wrd) :int
address CMDconvertsignal
comment "cast from wrd to int, signal error on overflow";
command int_noerror(b:bat[:any_1,:wrd]) :bat[:any_1,:int]
address CMDconvert_int
comment "cast from wrd to int";
pattern int_noerror(v:wrd) :int
address CMDconvert
comment "cast from wrd to int";

command int(b:bat[:any_1,:lng]) :bat[:any_1,:int]
address CMDconvertsignal_int
comment "cast from lng to int, signal error on overflow";
pattern int(v:lng) :int
address CMDconvertsignal
comment "cast from lng to int, signal error on overflow";
command int_noerror(b:bat[:any_1,:lng]) :bat[:any_1,:int]
address CMDconvert_int
comment "cast from lng to int";
pattern int_noerror(v:lng) :int
address CMDconvert
comment "cast from lng to int";

command int(b:bat[:any_1,:flt]) :bat[:any_1,:int]
address CMDconvertsignal_int
comment "cast from flt to int, signal error on overflow";
pattern int(v:flt) :int
address CMDconvertsignal
comment "cast from flt to int, signal error on overflow";
command int_noerror(b:bat[:any_1,:flt]) :bat[:any_1,:int]
address CMDconvert_int
comment "cast from flt to int";
pattern int_noerror(v:flt) :int
address CMDconvert
comment "cast from flt to int";

command int(b:bat[:any_1,:dbl]) :bat[:any_1,:int]
address CMDconvertsignal_int
comment "cast from dbl to int, signal error on overflow";
pattern int(v:dbl) :int
address CMDconvertsignal
comment "cast from dbl to int, signal error on overflow";
command int_noerror(b:bat[:any_1,:dbl]) :bat[:any_1,:int]
address CMDconvert_int
comment "cast from dbl to int";
pattern int_noerror(v:dbl) :int
address CMDconvert
comment "cast from dbl to int";

command int(b:bat[:any_1,:oid]) :bat[:any_1,:int]
address CMDconvertsignal_int
comment "cast from oid to int, signal error on overflow";
pattern int(v:oid) :int
address CMDconvertsignal
comment "cast from oid to int, signal error on overflow";
command int_noerror(b:bat[:any_1,:oid]) :bat[:any_1,:int]
address CMDconvert_int
comment "cast from oid to int";
pattern int_noerror(v:oid) :int
address CMDconvert
comment "cast from oid to int";

command int(b:bat[:any_1,:str]) :bat[:any_1,:int]
address CMDconvertsignal_int
comment "cast from str to int, signal error on overflow";
pattern int(v:str) :int
address CMDconvertsignal
comment "cast from str to int, signal error on overflow";
command int_noerror(b:bat[:any_1,:str]) :bat[:any_1,:int]
address CMDconvert_int
comment "cast from str to int";
pattern int_noerror(v:str) :int
address CMDconvert
comment "cast from str to int";

command wrd(b:bat[:any_1,:bit]) :bat[:any_1,:wrd]
address CMDconvertsignal_wrd
comment "cast from bit to wrd, signal error on overflow";
pattern wrd(v:bit) :wrd
address CMDconvertsignal
comment "cast from bit to wrd, signal error on overflow";
command wrd_noerror(b:bat[:any_1,:bit]) :bat[:any_1,:wrd]
address CMDconvert_wrd
comment "cast from bit to wrd";
pattern wrd_noerror(v:bit) :wrd
address CMDconvert
comment "cast from bit to wrd";

command wrd(b:bat[:any_1,:bte]) :bat[:any_1,:wrd]
address CMDconvertsignal_wrd
comment "cast from bte to wrd, signal error on overflow";
pattern wrd(v:bte) :wrd
address CMDconvertsignal
comment "cast from bte to wrd, signal error on overflow";
command wrd_noerror(b:bat[:any_1,:bte]) :bat[:any_1,:wrd]
address CMDconvert_wrd
comment "cast from bte to wrd";
pattern wrd_noerror(v:bte) :wrd
address CMDconvert
comment "cast from bte to wrd";

command wrd(b:bat[:any_1,:sht]) :bat[:any_1,:wrd]
address CMDconvertsignal_wrd
comment "cast from sht to wrd, signal error on overflow";
pattern wrd(v:sht) :wrd
address CMDconvertsignal
comment "cast from sht to wrd, signal error on overflow";
command wrd_noerror(b:bat[:any_1,:sht]) :bat[:any_1,:wrd]
address CMDconvert_wrd
comment "cast from sht to wrd";
pattern wrd_noerror(v:sht) :wrd
address CMDconvert
comment "cast from sht to wrd";

command wrd(b:bat[:any_1,:int]) :bat[:any_1,:wrd]
address CMDconvertsignal_wrd
comment "cast from int to wrd, signal error on overflow";
pattern wrd(v:int) :wrd
address CMDconvertsignal
comment "cast from int to wrd, signal error on overflow";
command wrd_noerror(b:bat[:any_1,:int]) :bat[:any_1,:wrd]
address CMDconvert_wrd
comment "cast from int to wrd";
pattern wrd_noerror(v:int) :wrd
address CMDconvert
comment "cast from int to wrd";

command wrd(b:bat[:any_1,:wrd]) :bat[:any_1,:wrd]
address CMDconvertsignal_wrd
comment "cast from wrd to wrd, signal error on overflow";
pattern wrd(v:wrd) :wrd
address CMDconvertsignal
comment "cast from wrd to wrd, signal error on overflow";
command wrd_noerror(b:bat[:any_1,:wrd]) :bat[:any_1,:wrd]
address CMDconvert_wrd
comment "cast from wrd to wrd";
pattern wrd_noerror(v:wrd) :wrd
address CMDconvert
comment "cast from wrd to wrd";

command wrd(b:bat[:any_1,:lng]) :bat[:any_1,:wrd]
address CMDconvertsignal_wrd
comment "cast from lng to wrd, signal error on overflow";
pattern wrd(v:lng) :wrd
address CMDconvertsignal
comment "cast from lng to wrd, signal error on overflow";
command wrd_noerror(b:bat[:any_1,:lng]) :bat[:any_1,:wrd]
address CMDconvert_wrd
comment "cast from lng to wrd";
pattern wrd_noerror(v:lng) :wrd
address CMDconvert
comment "cast from lng to wrd";

command wrd(b:bat[:any_1,:flt]) :bat[:any_1,:wrd]
address CMDconvertsignal_wrd
comment "cast from flt to wrd, signal error on overflow";
pattern wrd(v:flt) :wrd
address CMDconvertsignal
comment "cast from flt to wrd, signal error on overflow";
command wrd_noerror(b:bat[:any_1,:flt]) :bat[:any_1,:wrd]
address CMDconvert_wrd
comment "cast from flt to wrd";
pattern wrd_noerror(v:flt) :wrd
address CMDconvert
comment "cast from flt to wrd";

command wrd(b:bat[:any_1,:dbl]) :bat[:any_1,:wrd]
address CMDconvertsignal_wrd
comment "cast from dbl to wrd, signal error on overflow";
pattern wrd(v:dbl) :wrd
address CMDconvertsignal
comment "cast from dbl to wrd, signal error on overflow";
command wrd_noerror(b:bat[:any_1,:dbl]) :bat[:any_1,:wrd]
address CMDconvert_wrd
comment "cast from dbl to wrd";
pattern wrd_noerror(v:dbl) :wrd
address CMDconvert
comment "cast from dbl to wrd";

command wrd(b:bat[:any_1,:oid]) :bat[:any_1,:wrd]
address CMDconvertsignal_wrd
comment "cast from oid to wrd, signal error on overflow";
pattern wrd(v:oid) :wrd
address CMDconvertsignal
comment "cast from oid to wrd, signal error on overflow";
command wrd_noerror(b:bat[:any_1,:oid]) :bat[:any_1,:wrd]
address CMDconvert_wrd
comment "cast from oid to wrd";
pattern wrd_noerror(v:oid) :wrd
address CMDconvert
comment "cast from oid to wrd";

command wrd(b:bat[:any_1,:str]) :bat[:any_1,:wrd]
address CMDconvertsignal_wrd
comment "cast from str to wrd, signal error on overflow";
pattern wrd(v:str) :wrd
address CMDconvertsignal
comment "cast from str to wrd, signal error on overflow";
command wrd_noerror(b:bat[:any_1,:str]) :bat[:any_1,:wrd]
address CMDconvert_wrd
comment "cast from str to wrd";
pattern wrd_noerror(v:str) :wrd
address CMDconvert
comment "cast from str to wrd";

command lng(b:bat[:any_1,:bit]) :bat[:any_1,:lng]
address CMDconvertsignal_lng
comment "cast from bit to lng, signal error on overflow";
pattern lng(v:bit) :lng
address CMDconvertsignal
comment "cast from bit to lng, signal error on overflow";
command lng_noerror(b:bat[:any_1,:bit]) :bat[:any_1,:lng]
address CMDconvert_lng
comment "cast from bit to lng";
pattern lng_noerror(v:bit) :lng
address CMDconvert
comment "cast from bit to lng";

command lng(b:bat[:any_1,:bte]) :bat[:any_1,:lng]
address CMDconvertsignal_lng
comment "cast from bte to lng, signal error on overflow";
pattern lng(v:bte) :lng
address CMDconvertsignal
comment "cast from bte to lng, signal error on overflow";
command lng_noerror(b:bat[:any_1,:bte]) :bat[:any_1,:lng]
address CMDconvert_lng
comment "cast from bte to lng";
pattern lng_noerror(v:bte) :lng
address CMDconvert
comment "cast from bte to lng";

command lng(b:bat[:any_1,:sht]) :bat[:any_1,:lng]
address CMDconvertsignal_lng
comment "cast from sht to lng, signal error on overflow";
pattern lng(v:sht) :lng
address CMDconvertsignal
comment "cast from sht to lng, signal error on overflow";
command lng_noerror(b:bat[:any_1,:sht]) :bat[:any_1,:lng]
address CMDconvert_lng
comment "cast from sht to lng";
pattern lng_noerror(v:sht) :lng
address CMDconvert
comment "cast from sht to lng";

command lng(b:bat[:any_1,:int]) :bat[:any_1,:lng]
address CMDconvertsignal_lng
comment "cast from int to lng, signal error on overflow";
pattern lng(v:int) :lng
address CMDconvertsignal
comment "cast from int to lng, signal error on overflow";
command lng_noerror(b:bat[:any_1,:int]) :bat[:any_1,:lng]
address CMDconvert_lng
comment "cast from int to lng";
pattern lng_noerror(v:int) :lng
address CMDconvert
comment "cast from int to lng";

command lng(b:bat[:any_1,:wrd]) :bat[:any_1,:lng]
address CMDconvertsignal_lng
comment "cast from wrd to lng, signal error on overflow";
pattern lng(v:wrd) :lng
address CMDconvertsignal
comment "cast from wrd to lng, signal error on overflow";
command lng_noerror(b:bat[:any_1,:wrd]) :bat[:any_1,:lng]
address CMDconvert_lng
comment "cast from wrd to lng";
pattern lng_noerror(v:wrd) :lng
address CMDconvert
comment "cast from wrd to lng";

command lng(b:bat[:any_1,:lng]) :bat[:any_1,:lng]
address CMDconvertsignal_lng
comment "cast from lng to lng, signal error on overflow";
pattern lng(v:lng) :lng
address CMDconvertsignal
comment "cast from lng to lng, signal error on overflow";
command lng_noerror(b:bat[:any_1,:lng]) :bat[:any_1,:lng]
address CMDconvert_lng
comment "cast from lng to lng";
pattern lng_noerror(v:lng) :lng
address CMDconvert
comment "cast from lng to lng";

command lng(b:bat[:any_1,:flt]) :bat[:any_1,:lng]
address CMDconvertsignal_lng
comment "cast from flt to lng, signal error on overflow";
pattern lng(v:flt) :lng
address CMDconvertsignal
comment "cast from flt to lng, signal error on overflow";
command lng_noerror(b:bat[:any_1,:flt]) :bat[:any_1,:lng]
address CMDconvert_lng
comment "cast from flt to lng";
pattern lng_noerror(v:flt) :lng
address CMDconvert
comment "cast from flt to lng";

command lng(b:bat[:any_1,:dbl]) :bat[:any_1,:lng]
address CMDconvertsignal_lng
comment "cast from dbl to lng, signal error on overflow";
pattern lng(v:dbl) :lng
address CMDconvertsignal
comment "cast from dbl to lng, signal error on overflow";
command lng_noerror(b:bat[:any_1,:dbl]) :bat[:any_1,:lng]
address CMDconvert_lng
comment "cast from dbl to lng";
pattern lng_noerror(v:dbl) :lng
address CMDconvert
comment "cast from dbl to lng";

command lng(b:bat[:any_1,:oid]) :bat[:any_1,:lng]
address CMDconvertsignal_lng
comment "cast from oid to lng, signal error on overflow";
pattern lng(v:oid) :lng
address CMDconvertsignal
comment "cast from oid to lng, signal error on overflow";
command lng_noerror(b:bat[:any_1,:oid]) :bat[:any_1,:lng]
address CMDconvert_lng
comment "cast from oid to lng";
pattern lng_noerror(v:oid) :lng
address CMDconvert
comment "cast from oid to lng";

command lng(b:bat[:any_1,:str]) :bat[:any_1,:lng]
address CMDconvertsignal_lng
comment "cast from str to lng, signal error on overflow";
pattern lng(v:str) :lng
address CMDconvertsignal
comment "cast from str to lng, signal error on overflow";
command lng_noerror(b:bat[:any_1,:str]) :bat[:any_1,:lng]
address CMDconvert_lng
comment "cast from str to lng";
pattern lng_noerror(v:str) :lng
address CMDconvert
comment "cast from str to lng";

command flt(b:bat[:any_1,:bit]) :bat[:any_1,:flt]
address CMDconvertsignal_flt
comment "cast from bit to flt, signal error on overflow";
pattern flt(v:bit) :flt
address CMDconvertsignal
comment "cast from bit to flt, signal error on overflow";
command flt_noerror(b:bat[:any_1,:bit]) :bat[:any_1,:flt]
address CMDconvert_flt
comment "cast from bit to flt";
pattern flt_noerror(v:bit) :flt
address CMDconvert
comment "cast from bit to flt";

command flt(b:bat[:any_1,:bte]) :bat[:any_1,:flt]
address CMDconvertsignal_flt
comment "cast from bte to flt, signal error on overflow";
pattern flt(v:bte) :flt
address CMDconvertsignal
comment "cast from bte to flt, signal error on overflow";
command flt_noerror(b:bat[:any_1,:bte]) :bat[:any_1,:flt]
address CMDconvert_flt
comment "cast from bte to flt";
pattern flt_noerror(v:bte) :flt
address CMDconvert
comment "cast from bte to flt";

command flt(b:bat[:any_1,:sht]) :bat[:any_1,:flt]
address CMDconvertsignal_flt
comment "cast from sht to flt, signal error on overflow";
pattern flt(v:sht) :flt
address CMDconvertsignal
comment "cast from sht to flt, signal error on overflow";
command flt_noerror(b:bat[:any_1,:sht]) :bat[:any_1,:flt]
address CMDconvert_flt
comment "cast from sht to flt";
pattern flt_noerror(v:sht) :flt
address CMDconvert
comment "cast from sht to flt";

command flt(b:bat[:any_1,:int]) :bat[:any_1,:flt]
address CMDconvertsignal_flt
comment "cast from int to flt, signal error on overflow";
pattern flt(v:int) :flt
address CMDconvertsignal
comment "cast from int to flt, signal error on overflow";
command flt_noerror(b:bat[:any_1,:int]) :bat[:any_1,:flt]
address CMDconvert_flt
comment "cast from int to flt";
pattern flt_noerror(v:int) :flt
address CMDconvert
comment "cast from int to flt";

command flt(b:bat[:any_1,:wrd]) :bat[:any_1,:flt]
address CMDconvertsignal_flt
comment "cast from wrd to flt, signal error on overflow";
pattern flt(v:wrd) :flt
address CMDconvertsignal
comment "cast from wrd to flt, signal error on overflow";
command flt_noerror(b:bat[:any_1,:wrd]) :bat[:any_1,:flt]
address CMDconvert_flt
comment "cast from wrd to flt";
pattern flt_noerror(v:wrd) :flt
address CMDconvert
comment "cast from wrd to flt";

command flt(b:bat[:any_1,:lng]) :bat[:any_1,:flt]
address CMDconvertsignal_flt
comment "cast from lng to flt, signal error on overflow";
pattern flt(v:lng) :flt
address CMDconvertsignal
comment "cast from lng to flt, signal error on overflow";
command flt_noerror(b:bat[:any_1,:lng]) :bat[:any_1,:flt]
address CMDconvert_flt
comment "cast from lng to flt";
pattern flt_noerror(v:lng) :flt
address CMDconvert
comment "cast from lng to flt";

command flt(b:bat[:any_1,:flt]) :bat[:any_1,:flt]
address CMDconvertsignal_flt
comment "cast from flt to flt, signal error on overflow";
pattern flt(v:flt) :flt
address CMDconvertsignal
comment "cast from flt to flt, signal error on overflow";
command flt_noerror(b:bat[:any_1,:flt]) :bat[:any_1,:flt]
address CMDconvert_flt
comment "cast from flt to flt";
pattern flt_noerror(v:flt) :flt
address CMDconvert
comment "cast from flt to flt";

command flt(b:bat[:any_1,:dbl]) :bat[:any_1,:flt]
address CMDconvertsignal_flt
comment "cast from dbl to flt, signal error on overflow";
pattern flt(v:dbl) :flt
address CMDconvertsignal
comment "cast from dbl to flt, signal error on overflow";
command flt_noerror(b:bat[:any_1,:dbl]) :bat[:any_1,:flt]
address CMDconvert_flt
comment "cast from dbl to flt";
pattern flt_noerror(v:dbl) :flt
address CMDconvert
comment "cast from dbl to flt";

command flt(b:bat[:any_1,:oid]) :bat[:any_1,:flt]
address CMDconvertsignal_flt
comment "cast from oid to flt, signal error on overflow";
pattern flt(v:oid) :flt
address CMDconvertsignal
comment "cast from oid to flt, signal error on overflow";
command flt_noerror(b:bat[:any_1,:oid]) :bat[:any_1,:flt]
address CMDconvert_flt
comment "cast from oid to flt";
pattern flt_noerror(v:oid) :flt
address CMDconvert
comment "cast from oid to flt";

command flt(b:bat[:any_1,:str]) :bat[:any_1,:flt]
address CMDconvertsignal_flt
comment "cast from str to flt, signal error on overflow";
pattern flt(v:str) :flt
address CMDconvertsignal
comment "cast from str to flt, signal error on overflow";
command flt_noerror(b:bat[:any_1,:str]) :bat[:any_1,:flt]
address CMDconvert_flt
comment "cast from str to flt";
pattern flt_noerror(v:str) :flt
address CMDconvert
comment "cast from str to flt";

command dbl(b:bat[:any_1,:bit]) :bat[:any_1,:dbl]
address CMDconvertsignal_dbl
comment "cast from bit to dbl, signal error on overflow";
pattern dbl(v:bit) :dbl
address CMDconvertsignal
comment "cast from bit to dbl, signal error on overflow";
command dbl_noerror(b:bat[:any_1,:bit]) :bat[:any_1,:dbl]
address CMDconvert_dbl
comment "cast from bit to dbl";
pattern dbl_noerror(v:bit) :dbl
address CMDconvert
comment "cast from bit to dbl";

command dbl(b:bat[:any_1,:bte]) :bat[:any_1,:dbl]
address CMDconvertsignal_dbl
comment "cast from bte to dbl, signal error on overflow";
pattern dbl(v:bte) :dbl
address CMDconvertsignal
comment "cast from bte to dbl, signal error on overflow";
command dbl_noerror(b:bat[:any_1,:bte]) :bat[:any_1,:dbl]
address CMDconvert_dbl
comment "cast from bte to dbl";
pattern dbl_noerror(v:bte) :dbl
address CMDconvert
comment "cast from bte to dbl";

command dbl(b:bat[:any_1,:sht]) :bat[:any_1,:dbl]
address CMDconvertsignal_dbl
comment "cast from sht to dbl, signal error on overflow";
pattern dbl(v:sht) :dbl
address CMDconvertsignal
comment "cast from sht to dbl, signal error on overflow";
command dbl_noerror(b:bat[:any_1,:sht]) :bat[:any_1,:dbl]
address CMDconvert_dbl
comment "cast from sht to dbl";
pattern dbl_noerror(v:sht) :dbl
address CMDconvert
comment "cast from sht to dbl";

command dbl(b:bat[:any_1,:int]) :bat[:any_1,:dbl]
address CMDconvertsignal_dbl
comment "cast from int to dbl, signal error on overflow";
pattern dbl(v:int) :dbl
address CMDconvertsignal
comment "cast from int to dbl, signal error on overflow";
command dbl_noerror(b:bat[:any_1,:int]) :bat[:any_1,:dbl]
address CMDconvert_dbl
comment "cast from int to dbl";
pattern dbl_noerror(v:int) :dbl
address CMDconvert
comment "cast from int to dbl";

command dbl(b:bat[:any_1,:wrd]) :bat[:any_1,:dbl]
address CMDconvertsignal_dbl
comment "cast from wrd to dbl, signal error on overflow";
pattern dbl(v:wrd) :dbl
address CMDconvertsignal
comment "cast from wrd to dbl, signal error on overflow";
command dbl_noerror(b:bat[:any_1,:wrd]) :bat[:any_1,:dbl]
address CMDconvert_dbl
comment "cast from wrd to dbl";
pattern dbl_noerror(v:wrd) :dbl
address CMDconvert
comment "cast from wrd to dbl";

command dbl(b:bat[:any_1,:lng]) :bat[:any_1,:dbl]
address CMDconvertsignal_dbl
comment "cast from lng to dbl, signal error on overflow";
pattern dbl(v:lng) :dbl
address CMDconvertsignal
comment "cast from lng to dbl, signal error on overflow";
command dbl_noerror(b:bat[:any_1,:lng]) :bat[:any_1,:dbl]
address CMDconvert_dbl
comment "cast from lng to dbl";
pattern dbl_noerror(v:lng) :dbl
address CMDconvert
comment "cast from lng to dbl";

command dbl(b:bat[:any_1,:flt]) :bat[:any_1,:dbl]
address CMDconvertsignal_dbl
comment "cast from flt to dbl, signal error on overflow";
pattern dbl(v:flt) :dbl
address CMDconvertsignal
comment "cast from flt to dbl, signal error on overflow";
command dbl_noerror(b:bat[:any_1,:flt]) :bat[:any_1,:dbl]
address CMDconvert_dbl
comment "cast from flt to dbl";
pattern dbl_noerror(v:flt) :dbl
address CMDconvert
comment "cast from flt to dbl";

command dbl(b:bat[:any_1,:dbl]) :bat[:any_1,:dbl]
address CMDconvertsignal_dbl
comment "cast from dbl to dbl, signal error on overflow";
pattern dbl(v:dbl) :dbl
address CMDconvertsignal
comment "cast from dbl to dbl, signal error on overflow";
command dbl_noerror(b:bat[:any_1,:dbl]) :bat[:any_1,:dbl]
address CMDconvert_dbl
comment "cast from dbl to dbl";
pattern dbl_noerror(v:dbl) :dbl
address CMDconvert
comment "cast from dbl to dbl";

command dbl(b:bat[:any_1,:oid]) :bat[:any_1,:dbl]
address CMDconvertsignal_dbl
comment "cast from oid to dbl, signal error on overflow";
pattern dbl(v:oid) :dbl
address CMDconvertsignal
comment "cast from oid to dbl, signal error on overflow";
command dbl_noerror(b:bat[:any_1,:oid]) :bat[:any_1,:dbl]
address CMDconvert_dbl
comment "cast from oid to dbl";
pattern dbl_noerror(v:oid) :dbl
address CMDconvert
comment "cast from oid to dbl";

command dbl(b:bat[:any_1,:str]) :bat[:any_1,:dbl]
address CMDconvertsignal_dbl
comment "cast from str to dbl, signal error on overflow";
pattern dbl(v:str) :dbl
address CMDconvertsignal
comment "cast from str to dbl, signal error on overflow";
command dbl_noerror(b:bat[:any_1,:str]) :bat[:any_1,:dbl]
address CMDconvert_dbl
comment "cast from str to dbl";
pattern dbl_noerror(v:str) :dbl
address CMDconvert
comment "cast from str to dbl";

command oid(b:bat[:any_1,:bit]) :bat[:any_1,:oid]
address CMDconvertsignal_oid
comment "cast from bit to oid, signal error on overflow";
pattern oid(v:bit) :oid
address CMDconvertsignal
comment "cast from bit to oid, signal error on overflow";
command oid_noerror(b:bat[:any_1,:bit]) :bat[:any_1,:oid]
address CMDconvert_oid
comment "cast from bit to oid";
pattern oid_noerror(v:bit) :oid
address CMDconvert
comment "cast from bit to oid";

command oid(b:bat[:any_1,:bte]) :bat[:any_1,:oid]
address CMDconvertsignal_oid
comment "cast from bte to oid, signal error on overflow";
pattern oid(v:bte) :oid
address CMDconvertsignal
comment "cast from bte to oid, signal error on overflow";
command oid_noerror(b:bat[:any_1,:bte]) :bat[:any_1,:oid]
address CMDconvert_oid
comment "cast from bte to oid";
pattern oid_noerror(v:bte) :oid
address CMDconvert
comment "cast from bte to oid";

command oid(b:bat[:any_1,:sht]) :bat[:any_1,:oid]
address CMDconvertsignal_oid
comment "cast from sht to oid, signal error on overflow";
pattern oid(v:sht) :oid
address CMDconvertsignal
comment "cast from sht to oid, signal error on overflow";
command oid_noerror(b:bat[:any_1,:sht]) :bat[:any_1,:oid]
address CMDconvert_oid
comment "cast from sht to oid";
pattern oid_noerror(v:sht) :oid
address CMDconvert
comment "cast from sht to oid";

command oid(b:bat[:any_1,:int]) :bat[:any_1,:oid]
address CMDconvertsignal_oid
comment "cast from int to oid, signal error on overflow";
pattern oid(v:int) :oid
address CMDconvertsignal
comment "cast from int to oid, signal error on overflow";
command oid_noerror(b:bat[:any_1,:int]) :bat[:any_1,:oid]
address CMDconvert_oid
comment "cast from int to oid";
pattern oid_noerror(v:int) :oid
address CMDconvert
comment "cast from int to oid";

command oid(b:bat[:any_1,:wrd]) :bat[:any_1,:oid]
address CMDconvertsignal_oid
comment "cast from wrd to oid, signal error on overflow";
pattern oid(v:wrd) :oid
address CMDconvertsignal
comment "cast from wrd to oid, signal error on overflow";
command oid_noerror(b:bat[:any_1,:wrd]) :bat[:any_1,:oid]
address CMDconvert_oid
comment "cast from wrd to oid";
pattern oid_noerror(v:wrd) :oid
address CMDconvert
comment "cast from wrd to oid";

command oid(b:bat[:any_1,:lng]) :bat[:any_1,:oid]
address CMDconvertsignal_oid
comment "cast from lng to oid, signal error on overflow";
pattern oid(v:lng) :oid
address CMDconvertsignal
comment "cast from lng to oid, signal error on overflow";
command oid_noerror(b:bat[:any_1,:lng]) :bat[:any_1,:oid]
address CMDconvert_oid
comment "cast from lng to oid";
pattern oid_noerror(v:lng) :oid
address CMDconvert
comment "cast from lng to oid";

command oid(b:bat[:any_1,:flt]) :bat[:any_1,:oid]
address CMDconvertsignal_oid
comment "cast from flt to oid, signal error on overflow";
pattern oid(v:flt) :oid
address CMDconvertsignal
comment "cast from flt to oid, signal error on overflow";
command oid_noerror(b:bat[:any_1,:flt]) :bat[:any_1,:oid]
address CMDconvert_oid
comment "cast from flt to oid";
pattern oid_noerror(v:flt) :oid
address CMDconvert
comment "cast from flt to oid";

command oid(b:bat[:any_1,:dbl]) :bat[:any_1,:oid]
address CMDconvertsignal_oid
comment "cast from dbl to oid, signal error on overflow";
pattern oid(v:dbl) :oid
address CMDconvertsignal
comment "cast from dbl to oid, signal error on overflow";
command oid_noerror(b:bat[:any_1,:dbl]) :bat[:any_1,:oid]
address CMDconvert_oid
comment "cast from dbl to oid";
pattern oid_noerror(v:dbl) :oid
address CMDconvert
comment "cast from dbl to oid";

command oid(b:bat[:any_1,:oid]) :bat[:any_1,:oid]
address CMDconvertsignal_oid
comment "cast from oid to oid, signal error on overflow";
pattern oid(v:oid) :oid
address CMDconvertsignal
comment "cast from oid to oid, signal error on overflow";
command oid_noerror(b:bat[:any_1,:oid]) :bat[:any_1,:oid]
address CMDconvert_oid
comment "cast from oid to oid";
pattern oid_noerror(v:oid) :oid
address CMDconvert
comment "cast from oid to oid";

command oid(b:bat[:any_1,:str]) :bat[:any_1,:oid]
address CMDconvertsignal_oid
comment "cast from str to oid, signal error on overflow";
pattern oid(v:str) :oid
address CMDconvertsignal
comment "cast from str to oid, signal error on overflow";
command oid_noerror(b:bat[:any_1,:str]) :bat[:any_1,:oid]
address CMDconvert_oid
comment "cast from str to oid";
pattern oid_noerror(v:str) :oid
address CMDconvert
comment "cast from str to oid";

command str(b:bat[:any_1,:bit]) :bat[:any_1,:str]
address CMDconvertsignal_str
comment "cast from bit to str, signal error on overflow";
pattern str(v:bit) :str
address CMDconvertsignal
comment "cast from bit to str, signal error on overflow";
command str_noerror(b:bat[:any_1,:bit]) :bat[:any_1,:str]
address CMDconvert_str
comment "cast from bit to str";
pattern str_noerror(v:bit) :str
address CMDconvert
comment "cast from bit to str";

command str(b:bat[:any_1,:bte]) :bat[:any_1,:str]
address CMDconvertsignal_str
comment "cast from bte to str, signal error on overflow";
pattern str(v:bte) :str
address CMDconvertsignal
comment "cast from bte to str, signal error on overflow";
command str_noerror(b:bat[:any_1,:bte]) :bat[:any_1,:str]
address CMDconvert_str
comment "cast from bte to str";
pattern str_noerror(v:bte) :str
address CMDconvert
comment "cast from bte to str";

command str(b:bat[:any_1,:sht]) :bat[:any_1,:str]
address CMDconvertsignal_str
comment "cast from sht to str, signal error on overflow";
pattern str(v:sht) :str
address CMDconvertsignal
comment "cast from sht to str, signal error on overflow";
command str_noerror(b:bat[:any_1,:sht]) :bat[:any_1,:str]
address CMDconvert_str
comment "cast from sht to str";
pattern str_noerror(v:sht) :str
address CMDconvert
comment "cast from sht to str";

command str(b:bat[:any_1,:int]) :bat[:any_1,:str]
address CMDconvertsignal_str
comment "cast from int to str, signal error on overflow";
pattern str(v:int) :str
address CMDconvertsignal
comment "cast from int to str, signal error on overflow";
command str_noerror(b:bat[:any_1,:int]) :bat[:any_1,:str]
address CMDconvert_str
comment "cast from int to str";
pattern str_noerror(v:int) :str
address CMDconvert
comment "cast from int to str";

command str(b:bat[:any_1,:wrd]) :bat[:any_1,:str]
address CMDconvertsignal_str
comment "cast from wrd to str, signal error on overflow";
pattern str(v:wrd) :str
address CMDconvertsignal
comment "cast from wrd to str, signal error on overflow";
command str_noerror(b:bat[:any_1,:wrd]) :bat[:any_1,:str]
address CMDconvert_str
comment "cast from wrd to str";
pattern str_noerror(v:wrd) :str
address CMDconvert
comment "cast from wrd to str";

command str(b:bat[:any_1,:lng]) :bat[:any_1,:str]
address CMDconvertsignal_str
comment "cast from lng to str, signal error on overflow";
pattern str(v:lng) :str
address CMDconvertsignal
comment "cast from lng to str, signal error on overflow";
command str_noerror(b:bat[:any_1,:lng]) :bat[:any_1,:str]
address CMDconvert_str
comment "cast from lng to str";
pattern str_noerror(v:lng) :str
address CMDconvert
comment "cast from lng to str";

command str(b:bat[:any_1,:flt]) :bat[:any_1,:str]
address CMDconvertsignal_str
comment "cast from flt to str, signal error on overflow";
pattern str(v:flt) :str
address CMDconvertsignal
comment "cast from flt to str, signal error on overflow";
command str_noerror(b:bat[:any_1,:flt]) :bat[:any_1,:str]
address CMDconvert_str
comment "cast from flt to str";
pattern str_noerror(v:flt) :str
address CMDconvert
comment "cast from flt to str";

command str(b:bat[:any_1,:dbl]) :bat[:any_1,:str]
address CMDconvertsignal_str
comment "cast from dbl to str, signal error on overflow";
pattern str(v:dbl) :str
address CMDconvertsignal
comment "cast from dbl to str, signal error on overflow";
command str_noerror(b:bat[:any_1,:dbl]) :bat[:any_1,:str]
address CMDconvert_str
comment "cast from dbl to str";
pattern str_noerror(v:dbl) :str
address CMDconvert
comment "cast from dbl to str";

command str(b:bat[:any_1,:oid]) :bat[:any_1,:str]
address CMDconvertsignal_str
comment "cast from oid to str, signal error on overflow";
pattern str(v:oid) :str
address CMDconvertsignal
comment "cast from oid to str, signal error on overflow";
command str_noerror(b:bat[:any_1,:oid]) :bat[:any_1,:str]
address CMDconvert_str
comment "cast from oid to str";
pattern str_noerror(v:oid) :str
address CMDconvert
comment "cast from oid to str";

command str(b:bat[:any_1,:str]) :bat[:any_1,:str]
address CMDconvertsignal_str
comment "cast from str to str, signal error on overflow";
pattern str(v:str) :str
address CMDconvertsignal
comment "cast from str to str, signal error on overflow";
command str_noerror(b:bat[:any_1,:str]) :bat[:any_1,:str]
address CMDconvert_str
comment "cast from str to str";
pattern str_noerror(v:str) :str
address CMDconvert
comment "cast from str to str";

