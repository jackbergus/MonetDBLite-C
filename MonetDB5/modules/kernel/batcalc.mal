# The contents of this file are subject to the MonetDB Public License
# Version 1.1 (the "License"); you may not use this file except in
# compliance with the License. You may obtain a copy of the License at
# http://www.monetdb.org/Legal/MonetDBLicense
#
# Software distributed under the License is distributed on an "AS IS"
# basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
# License for the specific language governing rights and limitations
# under the License.
#
# The Original Code is the MonetDB Database System.
#
# The Initial Developer of the Original Code is CWI.
# Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
# Copyright August 2008-2012 MonetDB B.V.
# All Rights Reserved.

# This file was generated by using the script batcalc.mal.sh.

module batcalc;

command iszero(b:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatISZERO
comment "Unary check for zero over the tail of the bat";

command iszero(b:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatISZERO
comment "Unary check for zero over the tail of the bat";

command iszero(b:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatISZERO
comment "Unary check for zero over the tail of the bat";

command iszero(b:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatISZERO
comment "Unary check for zero over the tail of the bat";

command iszero(b:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatISZERO
comment "Unary check for zero over the tail of the bat";

command iszero(b:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatISZERO
comment "Unary check for zero over the tail of the bat";

command iszero(b:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatISZERO
comment "Unary check for zero over the tail of the bat";


command isnil(b:bat[:oid,:bit]) :bat[:oid,:bit]
address CMDbatISNIL
comment "Unary check for nil over the tail of the bat";

command isnil(b:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatISNIL
comment "Unary check for nil over the tail of the bat";

command isnil(b:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatISNIL
comment "Unary check for nil over the tail of the bat";

command isnil(b:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatISNIL
comment "Unary check for nil over the tail of the bat";

command isnil(b:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatISNIL
comment "Unary check for nil over the tail of the bat";

command isnil(b:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatISNIL
comment "Unary check for nil over the tail of the bat";

command isnil(b:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatISNIL
comment "Unary check for nil over the tail of the bat";

command isnil(b:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatISNIL
comment "Unary check for nil over the tail of the bat";

command isnil(b:bat[:oid,:oid]) :bat[:oid,:bit]
address CMDbatISNIL
comment "Unary check for nil over the tail of the bat";

command isnil(b:bat[:oid,:str]) :bat[:oid,:bit]
address CMDbatISNIL
comment "Unary check for nil over the tail of the bat";


command not(b:bat[:oid,:bit]) :bat[:oid,:bit]
address CMDbatNOT
comment "Return the Boolean inverse";
command not(b:bat[:oid,:bit],accum:int) :bat[:oid,:bit]
address CMDbatNOTaccum
comment "Return the Boolean inverse, reuse B if ACCUM is set";

command not(b:bat[:oid,:bte]) :bat[:oid,:bte]
address CMDbatNOT
comment "Unary bitwise not over the tail of the bat";
command not(b:bat[:oid,:bte],accum:int) :bat[:oid,:bte]
address CMDbatNOTaccum
comment "Unary bitwise not over the tail of the bat, reuse B if ACCUM is set";

command not(b:bat[:oid,:sht]) :bat[:oid,:sht]
address CMDbatNOT
comment "Unary bitwise not over the tail of the bat";
command not(b:bat[:oid,:sht],accum:int) :bat[:oid,:sht]
address CMDbatNOTaccum
comment "Unary bitwise not over the tail of the bat, reuse B if ACCUM is set";

command not(b:bat[:oid,:int]) :bat[:oid,:int]
address CMDbatNOT
comment "Unary bitwise not over the tail of the bat";
command not(b:bat[:oid,:int],accum:int) :bat[:oid,:int]
address CMDbatNOTaccum
comment "Unary bitwise not over the tail of the bat, reuse B if ACCUM is set";

command not(b:bat[:oid,:wrd]) :bat[:oid,:wrd]
address CMDbatNOT
comment "Unary bitwise not over the tail of the bat";
command not(b:bat[:oid,:wrd],accum:int) :bat[:oid,:wrd]
address CMDbatNOTaccum
comment "Unary bitwise not over the tail of the bat, reuse B if ACCUM is set";

command not(b:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatNOT
comment "Unary bitwise not over the tail of the bat";
command not(b:bat[:oid,:lng],accum:int) :bat[:oid,:lng]
address CMDbatNOTaccum
comment "Unary bitwise not over the tail of the bat, reuse B if ACCUM is set";


command sign(b:bat[:oid,:bte]) :bat[:oid,:bte]
address CMDbatSIGN
comment "Unary sign (-1,0,1) over the tail of the bat";

command sign(b:bat[:oid,:sht]) :bat[:oid,:bte]
address CMDbatSIGN
comment "Unary sign (-1,0,1) over the tail of the bat";

command sign(b:bat[:oid,:int]) :bat[:oid,:bte]
address CMDbatSIGN
comment "Unary sign (-1,0,1) over the tail of the bat";

command sign(b:bat[:oid,:wrd]) :bat[:oid,:bte]
address CMDbatSIGN
comment "Unary sign (-1,0,1) over the tail of the bat";

command sign(b:bat[:oid,:lng]) :bat[:oid,:bte]
address CMDbatSIGN
comment "Unary sign (-1,0,1) over the tail of the bat";

command sign(b:bat[:oid,:flt]) :bat[:oid,:bte]
address CMDbatSIGN
comment "Unary sign (-1,0,1) over the tail of the bat";

command sign(b:bat[:oid,:dbl]) :bat[:oid,:bte]
address CMDbatSIGN
comment "Unary sign (-1,0,1) over the tail of the bat";


command abs(b:bat[:oid,:bte]) :bat[:oid,:bte]
address CMDbatABS
comment "Unary abs over the tail of the bat";
command abs(b:bat[:oid,:bte],accum:int) :bat[:oid,:bte]
address CMDbatABSaccum
comment "Unary abs over the tail of the bat, reuse B if ACCUM is set";

command abs(b:bat[:oid,:sht]) :bat[:oid,:sht]
address CMDbatABS
comment "Unary abs over the tail of the bat";
command abs(b:bat[:oid,:sht],accum:int) :bat[:oid,:sht]
address CMDbatABSaccum
comment "Unary abs over the tail of the bat, reuse B if ACCUM is set";

command abs(b:bat[:oid,:int]) :bat[:oid,:int]
address CMDbatABS
comment "Unary abs over the tail of the bat";
command abs(b:bat[:oid,:int],accum:int) :bat[:oid,:int]
address CMDbatABSaccum
comment "Unary abs over the tail of the bat, reuse B if ACCUM is set";

command abs(b:bat[:oid,:wrd]) :bat[:oid,:wrd]
address CMDbatABS
comment "Unary abs over the tail of the bat";
command abs(b:bat[:oid,:wrd],accum:int) :bat[:oid,:wrd]
address CMDbatABSaccum
comment "Unary abs over the tail of the bat, reuse B if ACCUM is set";

command abs(b:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatABS
comment "Unary abs over the tail of the bat";
command abs(b:bat[:oid,:lng],accum:int) :bat[:oid,:lng]
address CMDbatABSaccum
comment "Unary abs over the tail of the bat, reuse B if ACCUM is set";

command abs(b:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatABS
comment "Unary abs over the tail of the bat";
command abs(b:bat[:oid,:flt],accum:int) :bat[:oid,:flt]
address CMDbatABSaccum
comment "Unary abs over the tail of the bat, reuse B if ACCUM is set";

command abs(b:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatABS
comment "Unary abs over the tail of the bat";
command abs(b:bat[:oid,:dbl],accum:int) :bat[:oid,:dbl]
address CMDbatABSaccum
comment "Unary abs over the tail of the bat, reuse B if ACCUM is set";


command -(b:bat[:oid,:bte]) :bat[:oid,:bte]
address CMDbatNEG
comment "Unary neg over the tail of the bat";
command -(b:bat[:oid,:bte],accum:int) :bat[:oid,:bte]
address CMDbatNEGaccum
comment "Unary neg over the tail of the bat, reuse B if ACCUM is set";

command -(b:bat[:oid,:sht]) :bat[:oid,:sht]
address CMDbatNEG
comment "Unary neg over the tail of the bat";
command -(b:bat[:oid,:sht],accum:int) :bat[:oid,:sht]
address CMDbatNEGaccum
comment "Unary neg over the tail of the bat, reuse B if ACCUM is set";

command -(b:bat[:oid,:int]) :bat[:oid,:int]
address CMDbatNEG
comment "Unary neg over the tail of the bat";
command -(b:bat[:oid,:int],accum:int) :bat[:oid,:int]
address CMDbatNEGaccum
comment "Unary neg over the tail of the bat, reuse B if ACCUM is set";

command -(b:bat[:oid,:wrd]) :bat[:oid,:wrd]
address CMDbatNEG
comment "Unary neg over the tail of the bat";
command -(b:bat[:oid,:wrd],accum:int) :bat[:oid,:wrd]
address CMDbatNEGaccum
comment "Unary neg over the tail of the bat, reuse B if ACCUM is set";

command -(b:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatNEG
comment "Unary neg over the tail of the bat";
command -(b:bat[:oid,:lng],accum:int) :bat[:oid,:lng]
address CMDbatNEGaccum
comment "Unary neg over the tail of the bat, reuse B if ACCUM is set";

command -(b:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatNEG
comment "Unary neg over the tail of the bat";
command -(b:bat[:oid,:flt],accum:int) :bat[:oid,:flt]
address CMDbatNEGaccum
comment "Unary neg over the tail of the bat, reuse B if ACCUM is set";

command -(b:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatNEG
comment "Unary neg over the tail of the bat";
command -(b:bat[:oid,:dbl],accum:int) :bat[:oid,:dbl]
address CMDbatNEGaccum
comment "Unary neg over the tail of the bat, reuse B if ACCUM is set";


command ++(b:bat[:oid,:bte]) :bat[:oid,:bte]
address CMDbatINCR
comment "Unary increment over the tail of the bat";
command ++(b:bat[:oid,:bte],accum:int) :bat[:oid,:bte]
address CMDbatINCRaccum
comment "Unary increment over the tail of the bat, reuse B if ACCUM is set";

command ++(b:bat[:oid,:sht]) :bat[:oid,:sht]
address CMDbatINCR
comment "Unary increment over the tail of the bat";
command ++(b:bat[:oid,:sht],accum:int) :bat[:oid,:sht]
address CMDbatINCRaccum
comment "Unary increment over the tail of the bat, reuse B if ACCUM is set";

command ++(b:bat[:oid,:int]) :bat[:oid,:int]
address CMDbatINCR
comment "Unary increment over the tail of the bat";
command ++(b:bat[:oid,:int],accum:int) :bat[:oid,:int]
address CMDbatINCRaccum
comment "Unary increment over the tail of the bat, reuse B if ACCUM is set";

command ++(b:bat[:oid,:wrd]) :bat[:oid,:wrd]
address CMDbatINCR
comment "Unary increment over the tail of the bat";
command ++(b:bat[:oid,:wrd],accum:int) :bat[:oid,:wrd]
address CMDbatINCRaccum
comment "Unary increment over the tail of the bat, reuse B if ACCUM is set";

command ++(b:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatINCR
comment "Unary increment over the tail of the bat";
command ++(b:bat[:oid,:lng],accum:int) :bat[:oid,:lng]
address CMDbatINCRaccum
comment "Unary increment over the tail of the bat, reuse B if ACCUM is set";

command ++(b:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatINCR
comment "Unary increment over the tail of the bat";
command ++(b:bat[:oid,:flt],accum:int) :bat[:oid,:flt]
address CMDbatINCRaccum
comment "Unary increment over the tail of the bat, reuse B if ACCUM is set";

command ++(b:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatINCR
comment "Unary increment over the tail of the bat";
command ++(b:bat[:oid,:dbl],accum:int) :bat[:oid,:dbl]
address CMDbatINCRaccum
comment "Unary increment over the tail of the bat, reuse B if ACCUM is set";


command --(b:bat[:oid,:bte]) :bat[:oid,:bte]
address CMDbatDECR
comment "Unary decrement over the tail of the bat";
command --(b:bat[:oid,:bte],accum:int) :bat[:oid,:bte]
address CMDbatDECRaccum
comment "Unary decrement over the tail of the bat, reuse B if ACCUM is set";

command --(b:bat[:oid,:sht]) :bat[:oid,:sht]
address CMDbatDECR
comment "Unary decrement over the tail of the bat";
command --(b:bat[:oid,:sht],accum:int) :bat[:oid,:sht]
address CMDbatDECRaccum
comment "Unary decrement over the tail of the bat, reuse B if ACCUM is set";

command --(b:bat[:oid,:int]) :bat[:oid,:int]
address CMDbatDECR
comment "Unary decrement over the tail of the bat";
command --(b:bat[:oid,:int],accum:int) :bat[:oid,:int]
address CMDbatDECRaccum
comment "Unary decrement over the tail of the bat, reuse B if ACCUM is set";

command --(b:bat[:oid,:wrd]) :bat[:oid,:wrd]
address CMDbatDECR
comment "Unary decrement over the tail of the bat";
command --(b:bat[:oid,:wrd],accum:int) :bat[:oid,:wrd]
address CMDbatDECRaccum
comment "Unary decrement over the tail of the bat, reuse B if ACCUM is set";

command --(b:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatDECR
comment "Unary decrement over the tail of the bat";
command --(b:bat[:oid,:lng],accum:int) :bat[:oid,:lng]
address CMDbatDECRaccum
comment "Unary decrement over the tail of the bat, reuse B if ACCUM is set";

command --(b:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatDECR
comment "Unary decrement over the tail of the bat";
command --(b:bat[:oid,:flt],accum:int) :bat[:oid,:flt]
address CMDbatDECRaccum
comment "Unary decrement over the tail of the bat, reuse B if ACCUM is set";

command --(b:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatDECR
comment "Unary decrement over the tail of the bat";
command --(b:bat[:oid,:dbl],accum:int) :bat[:oid,:dbl]
address CMDbatDECRaccum
comment "Unary decrement over the tail of the bat, reuse B if ACCUM is set";


command +(b1:bat[:oid,:bte],b2:bat[:oid,:bte]) :bat[:oid,:sht]
address CMDbatADDenlarge
comment "Return B1 + B2, guarantee no overflow by returning larger type";
pattern +(b:bat[:oid,:bte],v:bte) :bat[:oid,:sht]
address CMDbatADDcstenlarge
comment "Return B + V, guarantee no overflow by returning larger type";
pattern +(v:bte,b:bat[:oid,:bte]) :bat[:oid,:sht]
address CMDbatADDcstsignal
comment "Return V + B, guarantee no overflow by returning larger type";

command +(b1:bat[:oid,:bte],b2:bat[:oid,:sht]) :bat[:oid,:int]
address CMDbatADDenlarge
comment "Return B1 + B2, guarantee no overflow by returning larger type";
pattern +(b:bat[:oid,:bte],v:sht) :bat[:oid,:int]
address CMDbatADDcstenlarge
comment "Return B + V, guarantee no overflow by returning larger type";
pattern +(v:bte,b:bat[:oid,:sht]) :bat[:oid,:int]
address CMDbatADDcstsignal
comment "Return V + B, guarantee no overflow by returning larger type";

command +(b1:bat[:oid,:bte],b2:bat[:oid,:int]) :bat[:oid,:lng]
address CMDbatADDenlarge
comment "Return B1 + B2, guarantee no overflow by returning larger type";
pattern +(b:bat[:oid,:bte],v:int) :bat[:oid,:lng]
address CMDbatADDcstenlarge
comment "Return B + V, guarantee no overflow by returning larger type";
pattern +(v:bte,b:bat[:oid,:int]) :bat[:oid,:lng]
address CMDbatADDcstsignal
comment "Return V + B, guarantee no overflow by returning larger type";

command +(b1:bat[:oid,:bte],b2:bat[:oid,:flt]) :bat[:oid,:dbl]
address CMDbatADDenlarge
comment "Return B1 + B2, guarantee no overflow by returning larger type";
pattern +(b:bat[:oid,:bte],v:flt) :bat[:oid,:dbl]
address CMDbatADDcstenlarge
comment "Return B + V, guarantee no overflow by returning larger type";
pattern +(v:bte,b:bat[:oid,:flt]) :bat[:oid,:dbl]
address CMDbatADDcstsignal
comment "Return V + B, guarantee no overflow by returning larger type";

command +(b1:bat[:oid,:sht],b2:bat[:oid,:bte]) :bat[:oid,:int]
address CMDbatADDenlarge
comment "Return B1 + B2, guarantee no overflow by returning larger type";
pattern +(b:bat[:oid,:sht],v:bte) :bat[:oid,:int]
address CMDbatADDcstenlarge
comment "Return B + V, guarantee no overflow by returning larger type";
pattern +(v:sht,b:bat[:oid,:bte]) :bat[:oid,:int]
address CMDbatADDcstsignal
comment "Return V + B, guarantee no overflow by returning larger type";

command +(b1:bat[:oid,:sht],b2:bat[:oid,:sht]) :bat[:oid,:int]
address CMDbatADDenlarge
comment "Return B1 + B2, guarantee no overflow by returning larger type";
pattern +(b:bat[:oid,:sht],v:sht) :bat[:oid,:int]
address CMDbatADDcstenlarge
comment "Return B + V, guarantee no overflow by returning larger type";
pattern +(v:sht,b:bat[:oid,:sht]) :bat[:oid,:int]
address CMDbatADDcstsignal
comment "Return V + B, guarantee no overflow by returning larger type";

command +(b1:bat[:oid,:sht],b2:bat[:oid,:int]) :bat[:oid,:lng]
address CMDbatADDenlarge
comment "Return B1 + B2, guarantee no overflow by returning larger type";
pattern +(b:bat[:oid,:sht],v:int) :bat[:oid,:lng]
address CMDbatADDcstenlarge
comment "Return B + V, guarantee no overflow by returning larger type";
pattern +(v:sht,b:bat[:oid,:int]) :bat[:oid,:lng]
address CMDbatADDcstsignal
comment "Return V + B, guarantee no overflow by returning larger type";

command +(b1:bat[:oid,:sht],b2:bat[:oid,:flt]) :bat[:oid,:dbl]
address CMDbatADDenlarge
comment "Return B1 + B2, guarantee no overflow by returning larger type";
pattern +(b:bat[:oid,:sht],v:flt) :bat[:oid,:dbl]
address CMDbatADDcstenlarge
comment "Return B + V, guarantee no overflow by returning larger type";
pattern +(v:sht,b:bat[:oid,:flt]) :bat[:oid,:dbl]
address CMDbatADDcstsignal
comment "Return V + B, guarantee no overflow by returning larger type";

command +(b1:bat[:oid,:int],b2:bat[:oid,:bte]) :bat[:oid,:lng]
address CMDbatADDenlarge
comment "Return B1 + B2, guarantee no overflow by returning larger type";
pattern +(b:bat[:oid,:int],v:bte) :bat[:oid,:lng]
address CMDbatADDcstenlarge
comment "Return B + V, guarantee no overflow by returning larger type";
pattern +(v:int,b:bat[:oid,:bte]) :bat[:oid,:lng]
address CMDbatADDcstsignal
comment "Return V + B, guarantee no overflow by returning larger type";

command +(b1:bat[:oid,:int],b2:bat[:oid,:sht]) :bat[:oid,:lng]
address CMDbatADDenlarge
comment "Return B1 + B2, guarantee no overflow by returning larger type";
pattern +(b:bat[:oid,:int],v:sht) :bat[:oid,:lng]
address CMDbatADDcstenlarge
comment "Return B + V, guarantee no overflow by returning larger type";
pattern +(v:int,b:bat[:oid,:sht]) :bat[:oid,:lng]
address CMDbatADDcstsignal
comment "Return V + B, guarantee no overflow by returning larger type";

command +(b1:bat[:oid,:int],b2:bat[:oid,:int]) :bat[:oid,:lng]
address CMDbatADDenlarge
comment "Return B1 + B2, guarantee no overflow by returning larger type";
pattern +(b:bat[:oid,:int],v:int) :bat[:oid,:lng]
address CMDbatADDcstenlarge
comment "Return B + V, guarantee no overflow by returning larger type";
pattern +(v:int,b:bat[:oid,:int]) :bat[:oid,:lng]
address CMDbatADDcstsignal
comment "Return V + B, guarantee no overflow by returning larger type";

command +(b1:bat[:oid,:int],b2:bat[:oid,:flt]) :bat[:oid,:dbl]
address CMDbatADDenlarge
comment "Return B1 + B2, guarantee no overflow by returning larger type";
pattern +(b:bat[:oid,:int],v:flt) :bat[:oid,:dbl]
address CMDbatADDcstenlarge
comment "Return B + V, guarantee no overflow by returning larger type";
pattern +(v:int,b:bat[:oid,:flt]) :bat[:oid,:dbl]
address CMDbatADDcstsignal
comment "Return V + B, guarantee no overflow by returning larger type";

command +(b1:bat[:oid,:lng],b2:bat[:oid,:flt]) :bat[:oid,:dbl]
address CMDbatADDenlarge
comment "Return B1 + B2, guarantee no overflow by returning larger type";
pattern +(b:bat[:oid,:lng],v:flt) :bat[:oid,:dbl]
address CMDbatADDcstenlarge
comment "Return B + V, guarantee no overflow by returning larger type";
pattern +(v:lng,b:bat[:oid,:flt]) :bat[:oid,:dbl]
address CMDbatADDcstsignal
comment "Return V + B, guarantee no overflow by returning larger type";

command +(b1:bat[:oid,:flt],b2:bat[:oid,:bte]) :bat[:oid,:dbl]
address CMDbatADDenlarge
comment "Return B1 + B2, guarantee no overflow by returning larger type";
pattern +(b:bat[:oid,:flt],v:bte) :bat[:oid,:dbl]
address CMDbatADDcstenlarge
comment "Return B + V, guarantee no overflow by returning larger type";
pattern +(v:flt,b:bat[:oid,:bte]) :bat[:oid,:dbl]
address CMDbatADDcstsignal
comment "Return V + B, guarantee no overflow by returning larger type";

command +(b1:bat[:oid,:flt],b2:bat[:oid,:sht]) :bat[:oid,:dbl]
address CMDbatADDenlarge
comment "Return B1 + B2, guarantee no overflow by returning larger type";
pattern +(b:bat[:oid,:flt],v:sht) :bat[:oid,:dbl]
address CMDbatADDcstenlarge
comment "Return B + V, guarantee no overflow by returning larger type";
pattern +(v:flt,b:bat[:oid,:sht]) :bat[:oid,:dbl]
address CMDbatADDcstsignal
comment "Return V + B, guarantee no overflow by returning larger type";

command +(b1:bat[:oid,:flt],b2:bat[:oid,:int]) :bat[:oid,:dbl]
address CMDbatADDenlarge
comment "Return B1 + B2, guarantee no overflow by returning larger type";
pattern +(b:bat[:oid,:flt],v:int) :bat[:oid,:dbl]
address CMDbatADDcstenlarge
comment "Return B + V, guarantee no overflow by returning larger type";
pattern +(v:flt,b:bat[:oid,:int]) :bat[:oid,:dbl]
address CMDbatADDcstsignal
comment "Return V + B, guarantee no overflow by returning larger type";

command +(b1:bat[:oid,:flt],b2:bat[:oid,:lng]) :bat[:oid,:dbl]
address CMDbatADDenlarge
comment "Return B1 + B2, guarantee no overflow by returning larger type";
pattern +(b:bat[:oid,:flt],v:lng) :bat[:oid,:dbl]
address CMDbatADDcstenlarge
comment "Return B + V, guarantee no overflow by returning larger type";
pattern +(v:flt,b:bat[:oid,:lng]) :bat[:oid,:dbl]
address CMDbatADDcstsignal
comment "Return V + B, guarantee no overflow by returning larger type";

command +(b1:bat[:oid,:flt],b2:bat[:oid,:flt]) :bat[:oid,:dbl]
address CMDbatADDenlarge
comment "Return B1 + B2, guarantee no overflow by returning larger type";
pattern +(b:bat[:oid,:flt],v:flt) :bat[:oid,:dbl]
address CMDbatADDcstenlarge
comment "Return B + V, guarantee no overflow by returning larger type";
pattern +(v:flt,b:bat[:oid,:flt]) :bat[:oid,:dbl]
address CMDbatADDcstsignal
comment "Return V + B, guarantee no overflow by returning larger type";


command -(b1:bat[:oid,:bte],b2:bat[:oid,:bte]) :bat[:oid,:sht]
address CMDbatSUBenlarge
comment "Return B1 - B2, guarantee no overflow by returning larger type";
pattern -(b:bat[:oid,:bte],v:bte) :bat[:oid,:sht]
address CMDbatSUBcstenlarge
comment "Return B - V, guarantee no overflow by returning larger type";
pattern -(v:bte,b:bat[:oid,:bte]) :bat[:oid,:sht]
address CMDbatSUBcstsignal
comment "Return V - B, guarantee no overflow by returning larger type";

command -(b1:bat[:oid,:bte],b2:bat[:oid,:sht]) :bat[:oid,:int]
address CMDbatSUBenlarge
comment "Return B1 - B2, guarantee no overflow by returning larger type";
pattern -(b:bat[:oid,:bte],v:sht) :bat[:oid,:int]
address CMDbatSUBcstenlarge
comment "Return B - V, guarantee no overflow by returning larger type";
pattern -(v:bte,b:bat[:oid,:sht]) :bat[:oid,:int]
address CMDbatSUBcstsignal
comment "Return V - B, guarantee no overflow by returning larger type";

command -(b1:bat[:oid,:bte],b2:bat[:oid,:int]) :bat[:oid,:lng]
address CMDbatSUBenlarge
comment "Return B1 - B2, guarantee no overflow by returning larger type";
pattern -(b:bat[:oid,:bte],v:int) :bat[:oid,:lng]
address CMDbatSUBcstenlarge
comment "Return B - V, guarantee no overflow by returning larger type";
pattern -(v:bte,b:bat[:oid,:int]) :bat[:oid,:lng]
address CMDbatSUBcstsignal
comment "Return V - B, guarantee no overflow by returning larger type";

command -(b1:bat[:oid,:bte],b2:bat[:oid,:flt]) :bat[:oid,:dbl]
address CMDbatSUBenlarge
comment "Return B1 - B2, guarantee no overflow by returning larger type";
pattern -(b:bat[:oid,:bte],v:flt) :bat[:oid,:dbl]
address CMDbatSUBcstenlarge
comment "Return B - V, guarantee no overflow by returning larger type";
pattern -(v:bte,b:bat[:oid,:flt]) :bat[:oid,:dbl]
address CMDbatSUBcstsignal
comment "Return V - B, guarantee no overflow by returning larger type";

command -(b1:bat[:oid,:sht],b2:bat[:oid,:bte]) :bat[:oid,:int]
address CMDbatSUBenlarge
comment "Return B1 - B2, guarantee no overflow by returning larger type";
pattern -(b:bat[:oid,:sht],v:bte) :bat[:oid,:int]
address CMDbatSUBcstenlarge
comment "Return B - V, guarantee no overflow by returning larger type";
pattern -(v:sht,b:bat[:oid,:bte]) :bat[:oid,:int]
address CMDbatSUBcstsignal
comment "Return V - B, guarantee no overflow by returning larger type";

command -(b1:bat[:oid,:sht],b2:bat[:oid,:sht]) :bat[:oid,:int]
address CMDbatSUBenlarge
comment "Return B1 - B2, guarantee no overflow by returning larger type";
pattern -(b:bat[:oid,:sht],v:sht) :bat[:oid,:int]
address CMDbatSUBcstenlarge
comment "Return B - V, guarantee no overflow by returning larger type";
pattern -(v:sht,b:bat[:oid,:sht]) :bat[:oid,:int]
address CMDbatSUBcstsignal
comment "Return V - B, guarantee no overflow by returning larger type";

command -(b1:bat[:oid,:sht],b2:bat[:oid,:int]) :bat[:oid,:lng]
address CMDbatSUBenlarge
comment "Return B1 - B2, guarantee no overflow by returning larger type";
pattern -(b:bat[:oid,:sht],v:int) :bat[:oid,:lng]
address CMDbatSUBcstenlarge
comment "Return B - V, guarantee no overflow by returning larger type";
pattern -(v:sht,b:bat[:oid,:int]) :bat[:oid,:lng]
address CMDbatSUBcstsignal
comment "Return V - B, guarantee no overflow by returning larger type";

command -(b1:bat[:oid,:sht],b2:bat[:oid,:flt]) :bat[:oid,:dbl]
address CMDbatSUBenlarge
comment "Return B1 - B2, guarantee no overflow by returning larger type";
pattern -(b:bat[:oid,:sht],v:flt) :bat[:oid,:dbl]
address CMDbatSUBcstenlarge
comment "Return B - V, guarantee no overflow by returning larger type";
pattern -(v:sht,b:bat[:oid,:flt]) :bat[:oid,:dbl]
address CMDbatSUBcstsignal
comment "Return V - B, guarantee no overflow by returning larger type";

command -(b1:bat[:oid,:int],b2:bat[:oid,:bte]) :bat[:oid,:lng]
address CMDbatSUBenlarge
comment "Return B1 - B2, guarantee no overflow by returning larger type";
pattern -(b:bat[:oid,:int],v:bte) :bat[:oid,:lng]
address CMDbatSUBcstenlarge
comment "Return B - V, guarantee no overflow by returning larger type";
pattern -(v:int,b:bat[:oid,:bte]) :bat[:oid,:lng]
address CMDbatSUBcstsignal
comment "Return V - B, guarantee no overflow by returning larger type";

command -(b1:bat[:oid,:int],b2:bat[:oid,:sht]) :bat[:oid,:lng]
address CMDbatSUBenlarge
comment "Return B1 - B2, guarantee no overflow by returning larger type";
pattern -(b:bat[:oid,:int],v:sht) :bat[:oid,:lng]
address CMDbatSUBcstenlarge
comment "Return B - V, guarantee no overflow by returning larger type";
pattern -(v:int,b:bat[:oid,:sht]) :bat[:oid,:lng]
address CMDbatSUBcstsignal
comment "Return V - B, guarantee no overflow by returning larger type";

command -(b1:bat[:oid,:int],b2:bat[:oid,:int]) :bat[:oid,:lng]
address CMDbatSUBenlarge
comment "Return B1 - B2, guarantee no overflow by returning larger type";
pattern -(b:bat[:oid,:int],v:int) :bat[:oid,:lng]
address CMDbatSUBcstenlarge
comment "Return B - V, guarantee no overflow by returning larger type";
pattern -(v:int,b:bat[:oid,:int]) :bat[:oid,:lng]
address CMDbatSUBcstsignal
comment "Return V - B, guarantee no overflow by returning larger type";

command -(b1:bat[:oid,:int],b2:bat[:oid,:flt]) :bat[:oid,:dbl]
address CMDbatSUBenlarge
comment "Return B1 - B2, guarantee no overflow by returning larger type";
pattern -(b:bat[:oid,:int],v:flt) :bat[:oid,:dbl]
address CMDbatSUBcstenlarge
comment "Return B - V, guarantee no overflow by returning larger type";
pattern -(v:int,b:bat[:oid,:flt]) :bat[:oid,:dbl]
address CMDbatSUBcstsignal
comment "Return V - B, guarantee no overflow by returning larger type";

command -(b1:bat[:oid,:lng],b2:bat[:oid,:flt]) :bat[:oid,:dbl]
address CMDbatSUBenlarge
comment "Return B1 - B2, guarantee no overflow by returning larger type";
pattern -(b:bat[:oid,:lng],v:flt) :bat[:oid,:dbl]
address CMDbatSUBcstenlarge
comment "Return B - V, guarantee no overflow by returning larger type";
pattern -(v:lng,b:bat[:oid,:flt]) :bat[:oid,:dbl]
address CMDbatSUBcstsignal
comment "Return V - B, guarantee no overflow by returning larger type";

command -(b1:bat[:oid,:flt],b2:bat[:oid,:bte]) :bat[:oid,:dbl]
address CMDbatSUBenlarge
comment "Return B1 - B2, guarantee no overflow by returning larger type";
pattern -(b:bat[:oid,:flt],v:bte) :bat[:oid,:dbl]
address CMDbatSUBcstenlarge
comment "Return B - V, guarantee no overflow by returning larger type";
pattern -(v:flt,b:bat[:oid,:bte]) :bat[:oid,:dbl]
address CMDbatSUBcstsignal
comment "Return V - B, guarantee no overflow by returning larger type";

command -(b1:bat[:oid,:flt],b2:bat[:oid,:sht]) :bat[:oid,:dbl]
address CMDbatSUBenlarge
comment "Return B1 - B2, guarantee no overflow by returning larger type";
pattern -(b:bat[:oid,:flt],v:sht) :bat[:oid,:dbl]
address CMDbatSUBcstenlarge
comment "Return B - V, guarantee no overflow by returning larger type";
pattern -(v:flt,b:bat[:oid,:sht]) :bat[:oid,:dbl]
address CMDbatSUBcstsignal
comment "Return V - B, guarantee no overflow by returning larger type";

command -(b1:bat[:oid,:flt],b2:bat[:oid,:int]) :bat[:oid,:dbl]
address CMDbatSUBenlarge
comment "Return B1 - B2, guarantee no overflow by returning larger type";
pattern -(b:bat[:oid,:flt],v:int) :bat[:oid,:dbl]
address CMDbatSUBcstenlarge
comment "Return B - V, guarantee no overflow by returning larger type";
pattern -(v:flt,b:bat[:oid,:int]) :bat[:oid,:dbl]
address CMDbatSUBcstsignal
comment "Return V - B, guarantee no overflow by returning larger type";

command -(b1:bat[:oid,:flt],b2:bat[:oid,:lng]) :bat[:oid,:dbl]
address CMDbatSUBenlarge
comment "Return B1 - B2, guarantee no overflow by returning larger type";
pattern -(b:bat[:oid,:flt],v:lng) :bat[:oid,:dbl]
address CMDbatSUBcstenlarge
comment "Return B - V, guarantee no overflow by returning larger type";
pattern -(v:flt,b:bat[:oid,:lng]) :bat[:oid,:dbl]
address CMDbatSUBcstsignal
comment "Return V - B, guarantee no overflow by returning larger type";

command -(b1:bat[:oid,:flt],b2:bat[:oid,:flt]) :bat[:oid,:dbl]
address CMDbatSUBenlarge
comment "Return B1 - B2, guarantee no overflow by returning larger type";
pattern -(b:bat[:oid,:flt],v:flt) :bat[:oid,:dbl]
address CMDbatSUBcstenlarge
comment "Return B - V, guarantee no overflow by returning larger type";
pattern -(v:flt,b:bat[:oid,:flt]) :bat[:oid,:dbl]
address CMDbatSUBcstsignal
comment "Return V - B, guarantee no overflow by returning larger type";


command *(b1:bat[:oid,:bte],b2:bat[:oid,:bte]) :bat[:oid,:sht]
address CMDbatMULenlarge
comment "Return B1 * B2, guarantee no overflow by returning larger type";
pattern *(b:bat[:oid,:bte],v:bte) :bat[:oid,:sht]
address CMDbatMULcstenlarge
comment "Return B * V, guarantee no overflow by returning larger type";
pattern *(v:bte,b:bat[:oid,:bte]) :bat[:oid,:sht]
address CMDbatMULcstsignal
comment "Return V * B, guarantee no overflow by returning larger type";

command *(b1:bat[:oid,:bte],b2:bat[:oid,:sht]) :bat[:oid,:int]
address CMDbatMULenlarge
comment "Return B1 * B2, guarantee no overflow by returning larger type";
pattern *(b:bat[:oid,:bte],v:sht) :bat[:oid,:int]
address CMDbatMULcstenlarge
comment "Return B * V, guarantee no overflow by returning larger type";
pattern *(v:bte,b:bat[:oid,:sht]) :bat[:oid,:int]
address CMDbatMULcstsignal
comment "Return V * B, guarantee no overflow by returning larger type";

command *(b1:bat[:oid,:bte],b2:bat[:oid,:int]) :bat[:oid,:lng]
address CMDbatMULenlarge
comment "Return B1 * B2, guarantee no overflow by returning larger type";
pattern *(b:bat[:oid,:bte],v:int) :bat[:oid,:lng]
address CMDbatMULcstenlarge
comment "Return B * V, guarantee no overflow by returning larger type";
pattern *(v:bte,b:bat[:oid,:int]) :bat[:oid,:lng]
address CMDbatMULcstsignal
comment "Return V * B, guarantee no overflow by returning larger type";

command *(b1:bat[:oid,:bte],b2:bat[:oid,:flt]) :bat[:oid,:dbl]
address CMDbatMULenlarge
comment "Return B1 * B2, guarantee no overflow by returning larger type";
pattern *(b:bat[:oid,:bte],v:flt) :bat[:oid,:dbl]
address CMDbatMULcstenlarge
comment "Return B * V, guarantee no overflow by returning larger type";
pattern *(v:bte,b:bat[:oid,:flt]) :bat[:oid,:dbl]
address CMDbatMULcstsignal
comment "Return V * B, guarantee no overflow by returning larger type";

command *(b1:bat[:oid,:sht],b2:bat[:oid,:bte]) :bat[:oid,:int]
address CMDbatMULenlarge
comment "Return B1 * B2, guarantee no overflow by returning larger type";
pattern *(b:bat[:oid,:sht],v:bte) :bat[:oid,:int]
address CMDbatMULcstenlarge
comment "Return B * V, guarantee no overflow by returning larger type";
pattern *(v:sht,b:bat[:oid,:bte]) :bat[:oid,:int]
address CMDbatMULcstsignal
comment "Return V * B, guarantee no overflow by returning larger type";

command *(b1:bat[:oid,:sht],b2:bat[:oid,:sht]) :bat[:oid,:int]
address CMDbatMULenlarge
comment "Return B1 * B2, guarantee no overflow by returning larger type";
pattern *(b:bat[:oid,:sht],v:sht) :bat[:oid,:int]
address CMDbatMULcstenlarge
comment "Return B * V, guarantee no overflow by returning larger type";
pattern *(v:sht,b:bat[:oid,:sht]) :bat[:oid,:int]
address CMDbatMULcstsignal
comment "Return V * B, guarantee no overflow by returning larger type";

command *(b1:bat[:oid,:sht],b2:bat[:oid,:int]) :bat[:oid,:lng]
address CMDbatMULenlarge
comment "Return B1 * B2, guarantee no overflow by returning larger type";
pattern *(b:bat[:oid,:sht],v:int) :bat[:oid,:lng]
address CMDbatMULcstenlarge
comment "Return B * V, guarantee no overflow by returning larger type";
pattern *(v:sht,b:bat[:oid,:int]) :bat[:oid,:lng]
address CMDbatMULcstsignal
comment "Return V * B, guarantee no overflow by returning larger type";

command *(b1:bat[:oid,:sht],b2:bat[:oid,:flt]) :bat[:oid,:dbl]
address CMDbatMULenlarge
comment "Return B1 * B2, guarantee no overflow by returning larger type";
pattern *(b:bat[:oid,:sht],v:flt) :bat[:oid,:dbl]
address CMDbatMULcstenlarge
comment "Return B * V, guarantee no overflow by returning larger type";
pattern *(v:sht,b:bat[:oid,:flt]) :bat[:oid,:dbl]
address CMDbatMULcstsignal
comment "Return V * B, guarantee no overflow by returning larger type";

command *(b1:bat[:oid,:int],b2:bat[:oid,:bte]) :bat[:oid,:lng]
address CMDbatMULenlarge
comment "Return B1 * B2, guarantee no overflow by returning larger type";
pattern *(b:bat[:oid,:int],v:bte) :bat[:oid,:lng]
address CMDbatMULcstenlarge
comment "Return B * V, guarantee no overflow by returning larger type";
pattern *(v:int,b:bat[:oid,:bte]) :bat[:oid,:lng]
address CMDbatMULcstsignal
comment "Return V * B, guarantee no overflow by returning larger type";

command *(b1:bat[:oid,:int],b2:bat[:oid,:sht]) :bat[:oid,:lng]
address CMDbatMULenlarge
comment "Return B1 * B2, guarantee no overflow by returning larger type";
pattern *(b:bat[:oid,:int],v:sht) :bat[:oid,:lng]
address CMDbatMULcstenlarge
comment "Return B * V, guarantee no overflow by returning larger type";
pattern *(v:int,b:bat[:oid,:sht]) :bat[:oid,:lng]
address CMDbatMULcstsignal
comment "Return V * B, guarantee no overflow by returning larger type";

command *(b1:bat[:oid,:int],b2:bat[:oid,:int]) :bat[:oid,:lng]
address CMDbatMULenlarge
comment "Return B1 * B2, guarantee no overflow by returning larger type";
pattern *(b:bat[:oid,:int],v:int) :bat[:oid,:lng]
address CMDbatMULcstenlarge
comment "Return B * V, guarantee no overflow by returning larger type";
pattern *(v:int,b:bat[:oid,:int]) :bat[:oid,:lng]
address CMDbatMULcstsignal
comment "Return V * B, guarantee no overflow by returning larger type";

command *(b1:bat[:oid,:int],b2:bat[:oid,:flt]) :bat[:oid,:dbl]
address CMDbatMULenlarge
comment "Return B1 * B2, guarantee no overflow by returning larger type";
pattern *(b:bat[:oid,:int],v:flt) :bat[:oid,:dbl]
address CMDbatMULcstenlarge
comment "Return B * V, guarantee no overflow by returning larger type";
pattern *(v:int,b:bat[:oid,:flt]) :bat[:oid,:dbl]
address CMDbatMULcstsignal
comment "Return V * B, guarantee no overflow by returning larger type";

command *(b1:bat[:oid,:lng],b2:bat[:oid,:flt]) :bat[:oid,:dbl]
address CMDbatMULenlarge
comment "Return B1 * B2, guarantee no overflow by returning larger type";
pattern *(b:bat[:oid,:lng],v:flt) :bat[:oid,:dbl]
address CMDbatMULcstenlarge
comment "Return B * V, guarantee no overflow by returning larger type";
pattern *(v:lng,b:bat[:oid,:flt]) :bat[:oid,:dbl]
address CMDbatMULcstsignal
comment "Return V * B, guarantee no overflow by returning larger type";

command *(b1:bat[:oid,:flt],b2:bat[:oid,:bte]) :bat[:oid,:dbl]
address CMDbatMULenlarge
comment "Return B1 * B2, guarantee no overflow by returning larger type";
pattern *(b:bat[:oid,:flt],v:bte) :bat[:oid,:dbl]
address CMDbatMULcstenlarge
comment "Return B * V, guarantee no overflow by returning larger type";
pattern *(v:flt,b:bat[:oid,:bte]) :bat[:oid,:dbl]
address CMDbatMULcstsignal
comment "Return V * B, guarantee no overflow by returning larger type";

command *(b1:bat[:oid,:flt],b2:bat[:oid,:sht]) :bat[:oid,:dbl]
address CMDbatMULenlarge
comment "Return B1 * B2, guarantee no overflow by returning larger type";
pattern *(b:bat[:oid,:flt],v:sht) :bat[:oid,:dbl]
address CMDbatMULcstenlarge
comment "Return B * V, guarantee no overflow by returning larger type";
pattern *(v:flt,b:bat[:oid,:sht]) :bat[:oid,:dbl]
address CMDbatMULcstsignal
comment "Return V * B, guarantee no overflow by returning larger type";

command *(b1:bat[:oid,:flt],b2:bat[:oid,:int]) :bat[:oid,:dbl]
address CMDbatMULenlarge
comment "Return B1 * B2, guarantee no overflow by returning larger type";
pattern *(b:bat[:oid,:flt],v:int) :bat[:oid,:dbl]
address CMDbatMULcstenlarge
comment "Return B * V, guarantee no overflow by returning larger type";
pattern *(v:flt,b:bat[:oid,:int]) :bat[:oid,:dbl]
address CMDbatMULcstsignal
comment "Return V * B, guarantee no overflow by returning larger type";

command *(b1:bat[:oid,:flt],b2:bat[:oid,:lng]) :bat[:oid,:dbl]
address CMDbatMULenlarge
comment "Return B1 * B2, guarantee no overflow by returning larger type";
pattern *(b:bat[:oid,:flt],v:lng) :bat[:oid,:dbl]
address CMDbatMULcstenlarge
comment "Return B * V, guarantee no overflow by returning larger type";
pattern *(v:flt,b:bat[:oid,:lng]) :bat[:oid,:dbl]
address CMDbatMULcstsignal
comment "Return V * B, guarantee no overflow by returning larger type";

command *(b1:bat[:oid,:flt],b2:bat[:oid,:flt]) :bat[:oid,:dbl]
address CMDbatMULenlarge
comment "Return B1 * B2, guarantee no overflow by returning larger type";
pattern *(b:bat[:oid,:flt],v:flt) :bat[:oid,:dbl]
address CMDbatMULcstenlarge
comment "Return B * V, guarantee no overflow by returning larger type";
pattern *(v:flt,b:bat[:oid,:flt]) :bat[:oid,:dbl]
address CMDbatMULcstsignal
comment "Return V * B, guarantee no overflow by returning larger type";


command +(b1:bat[:oid,:bte],b2:bat[:oid,:bte]) :bat[:oid,:bte]
address CMDbatADDsignal
comment "Return B1 + B2, signal error on overflow";
command +(b1:bat[:oid,:bte],b2:bat[:oid,:bte],accum:int) :bat[:oid,:bte]
address CMDbatADDsignalaccum
comment "Return B1 + B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command add_noerror(b1:bat[:oid,:bte],b2:bat[:oid,:bte]) :bat[:oid,:bte]
address CMDbatADD
comment "Return B1 + B2, overflow causes NIL value";
pattern +(b:bat[:oid,:bte],v:bte) :bat[:oid,:bte]
address CMDbatADDcstsignal
comment "Return B + V, signal error on overflow";
pattern +(b:bat[:oid,:bte],v:bte,accum:int) :bat[:oid,:bte]
address CMDbatADDcstsignal
comment "Return B + V, signal error on overflow, reuse B if ACCUM is set";
pattern add_noerror(b:bat[:oid,:bte],v:bte) :bat[:oid,:bte]
address CMDbatADDcst
comment "Return B + V, overflow causes NIL value";
pattern +(v:bte,b:bat[:oid,:bte]) :bat[:oid,:bte]
address CMDbatADDcstsignal
comment "Return V + B, signal error on overflow";
pattern +(v:bte,b:bat[:oid,:bte],accum:int) :bat[:oid,:bte]
address CMDbatADDcstsignal
comment "Return V + B, signal error on overflow, reuse B if ACCUM is set";
pattern add_noerror(v:bte,b:bat[:oid,:bte]) :bat[:oid,:bte]
address CMDbatADDcst
comment "Return V + B, overflow causes NIL value";

command +(b1:bat[:oid,:bte],b2:bat[:oid,:sht]) :bat[:oid,:sht]
address CMDbatADDsignal
comment "Return B1 + B2, signal error on overflow";
command +(b1:bat[:oid,:bte],b2:bat[:oid,:sht],accum:int) :bat[:oid,:sht]
address CMDbatADDsignalaccum
comment "Return B1 + B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command add_noerror(b1:bat[:oid,:bte],b2:bat[:oid,:sht]) :bat[:oid,:sht]
address CMDbatADD
comment "Return B1 + B2, overflow causes NIL value";
pattern +(b:bat[:oid,:bte],v:sht) :bat[:oid,:sht]
address CMDbatADDcstsignal
comment "Return B + V, signal error on overflow";
pattern add_noerror(b:bat[:oid,:bte],v:sht) :bat[:oid,:sht]
address CMDbatADDcst
comment "Return B + V, overflow causes NIL value";
pattern +(v:bte,b:bat[:oid,:sht]) :bat[:oid,:sht]
address CMDbatADDcstsignal
comment "Return V + B, signal error on overflow";
pattern +(v:bte,b:bat[:oid,:sht],accum:int) :bat[:oid,:sht]
address CMDbatADDcstsignal
comment "Return V + B, signal error on overflow, reuse B if ACCUM is set";
pattern add_noerror(v:bte,b:bat[:oid,:sht]) :bat[:oid,:sht]
address CMDbatADDcst
comment "Return V + B, overflow causes NIL value";

command +(b1:bat[:oid,:bte],b2:bat[:oid,:int]) :bat[:oid,:int]
address CMDbatADDsignal
comment "Return B1 + B2, signal error on overflow";
command +(b1:bat[:oid,:bte],b2:bat[:oid,:int],accum:int) :bat[:oid,:int]
address CMDbatADDsignalaccum
comment "Return B1 + B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command add_noerror(b1:bat[:oid,:bte],b2:bat[:oid,:int]) :bat[:oid,:int]
address CMDbatADD
comment "Return B1 + B2, overflow causes NIL value";
pattern +(b:bat[:oid,:bte],v:int) :bat[:oid,:int]
address CMDbatADDcstsignal
comment "Return B + V, signal error on overflow";
pattern add_noerror(b:bat[:oid,:bte],v:int) :bat[:oid,:int]
address CMDbatADDcst
comment "Return B + V, overflow causes NIL value";
pattern +(v:bte,b:bat[:oid,:int]) :bat[:oid,:int]
address CMDbatADDcstsignal
comment "Return V + B, signal error on overflow";
pattern +(v:bte,b:bat[:oid,:int],accum:int) :bat[:oid,:int]
address CMDbatADDcstsignal
comment "Return V + B, signal error on overflow, reuse B if ACCUM is set";
pattern add_noerror(v:bte,b:bat[:oid,:int]) :bat[:oid,:int]
address CMDbatADDcst
comment "Return V + B, overflow causes NIL value";

command +(b1:bat[:oid,:bte],b2:bat[:oid,:wrd]) :bat[:oid,:wrd]
address CMDbatADDsignal
comment "Return B1 + B2, signal error on overflow";
command +(b1:bat[:oid,:bte],b2:bat[:oid,:wrd],accum:int) :bat[:oid,:wrd]
address CMDbatADDsignalaccum
comment "Return B1 + B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command add_noerror(b1:bat[:oid,:bte],b2:bat[:oid,:wrd]) :bat[:oid,:wrd]
address CMDbatADD
comment "Return B1 + B2, overflow causes NIL value";
pattern +(b:bat[:oid,:bte],v:wrd) :bat[:oid,:wrd]
address CMDbatADDcstsignal
comment "Return B + V, signal error on overflow";
pattern add_noerror(b:bat[:oid,:bte],v:wrd) :bat[:oid,:wrd]
address CMDbatADDcst
comment "Return B + V, overflow causes NIL value";
pattern +(v:bte,b:bat[:oid,:wrd]) :bat[:oid,:wrd]
address CMDbatADDcstsignal
comment "Return V + B, signal error on overflow";
pattern +(v:bte,b:bat[:oid,:wrd],accum:int) :bat[:oid,:wrd]
address CMDbatADDcstsignal
comment "Return V + B, signal error on overflow, reuse B if ACCUM is set";
pattern add_noerror(v:bte,b:bat[:oid,:wrd]) :bat[:oid,:wrd]
address CMDbatADDcst
comment "Return V + B, overflow causes NIL value";

command +(b1:bat[:oid,:bte],b2:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatADDsignal
comment "Return B1 + B2, signal error on overflow";
command +(b1:bat[:oid,:bte],b2:bat[:oid,:lng],accum:int) :bat[:oid,:lng]
address CMDbatADDsignalaccum
comment "Return B1 + B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command add_noerror(b1:bat[:oid,:bte],b2:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatADD
comment "Return B1 + B2, overflow causes NIL value";
pattern +(b:bat[:oid,:bte],v:lng) :bat[:oid,:lng]
address CMDbatADDcstsignal
comment "Return B + V, signal error on overflow";
pattern add_noerror(b:bat[:oid,:bte],v:lng) :bat[:oid,:lng]
address CMDbatADDcst
comment "Return B + V, overflow causes NIL value";
pattern +(v:bte,b:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatADDcstsignal
comment "Return V + B, signal error on overflow";
pattern +(v:bte,b:bat[:oid,:lng],accum:int) :bat[:oid,:lng]
address CMDbatADDcstsignal
comment "Return V + B, signal error on overflow, reuse B if ACCUM is set";
pattern add_noerror(v:bte,b:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatADDcst
comment "Return V + B, overflow causes NIL value";

command +(b1:bat[:oid,:bte],b2:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatADDsignal
comment "Return B1 + B2, signal error on overflow";
command +(b1:bat[:oid,:bte],b2:bat[:oid,:flt],accum:int) :bat[:oid,:flt]
address CMDbatADDsignalaccum
comment "Return B1 + B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command add_noerror(b1:bat[:oid,:bte],b2:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatADD
comment "Return B1 + B2, overflow causes NIL value";
pattern +(b:bat[:oid,:bte],v:flt) :bat[:oid,:flt]
address CMDbatADDcstsignal
comment "Return B + V, signal error on overflow";
pattern add_noerror(b:bat[:oid,:bte],v:flt) :bat[:oid,:flt]
address CMDbatADDcst
comment "Return B + V, overflow causes NIL value";
pattern +(v:bte,b:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatADDcstsignal
comment "Return V + B, signal error on overflow";
pattern +(v:bte,b:bat[:oid,:flt],accum:int) :bat[:oid,:flt]
address CMDbatADDcstsignal
comment "Return V + B, signal error on overflow, reuse B if ACCUM is set";
pattern add_noerror(v:bte,b:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatADDcst
comment "Return V + B, overflow causes NIL value";

command +(b1:bat[:oid,:bte],b2:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatADDsignal
comment "Return B1 + B2, signal error on overflow";
command +(b1:bat[:oid,:bte],b2:bat[:oid,:dbl],accum:int) :bat[:oid,:dbl]
address CMDbatADDsignalaccum
comment "Return B1 + B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command add_noerror(b1:bat[:oid,:bte],b2:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatADD
comment "Return B1 + B2, overflow causes NIL value";
pattern +(b:bat[:oid,:bte],v:dbl) :bat[:oid,:dbl]
address CMDbatADDcstsignal
comment "Return B + V, signal error on overflow";
pattern add_noerror(b:bat[:oid,:bte],v:dbl) :bat[:oid,:dbl]
address CMDbatADDcst
comment "Return B + V, overflow causes NIL value";
pattern +(v:bte,b:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatADDcstsignal
comment "Return V + B, signal error on overflow";
pattern +(v:bte,b:bat[:oid,:dbl],accum:int) :bat[:oid,:dbl]
address CMDbatADDcstsignal
comment "Return V + B, signal error on overflow, reuse B if ACCUM is set";
pattern add_noerror(v:bte,b:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatADDcst
comment "Return V + B, overflow causes NIL value";

command +(b1:bat[:oid,:sht],b2:bat[:oid,:bte]) :bat[:oid,:sht]
address CMDbatADDsignal
comment "Return B1 + B2, signal error on overflow";
command +(b1:bat[:oid,:sht],b2:bat[:oid,:bte],accum:int) :bat[:oid,:sht]
address CMDbatADDsignalaccum
comment "Return B1 + B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command add_noerror(b1:bat[:oid,:sht],b2:bat[:oid,:bte]) :bat[:oid,:sht]
address CMDbatADD
comment "Return B1 + B2, overflow causes NIL value";
pattern +(b:bat[:oid,:sht],v:bte) :bat[:oid,:sht]
address CMDbatADDcstsignal
comment "Return B + V, signal error on overflow";
pattern +(b:bat[:oid,:sht],v:bte,accum:int) :bat[:oid,:sht]
address CMDbatADDcstsignal
comment "Return B + V, signal error on overflow, reuse B if ACCUM is set";
pattern add_noerror(b:bat[:oid,:sht],v:bte) :bat[:oid,:sht]
address CMDbatADDcst
comment "Return B + V, overflow causes NIL value";
pattern +(v:sht,b:bat[:oid,:bte]) :bat[:oid,:sht]
address CMDbatADDcstsignal
comment "Return V + B, signal error on overflow";
pattern add_noerror(v:sht,b:bat[:oid,:bte]) :bat[:oid,:sht]
address CMDbatADDcst
comment "Return V + B, overflow causes NIL value";

command +(b1:bat[:oid,:sht],b2:bat[:oid,:sht]) :bat[:oid,:sht]
address CMDbatADDsignal
comment "Return B1 + B2, signal error on overflow";
command +(b1:bat[:oid,:sht],b2:bat[:oid,:sht],accum:int) :bat[:oid,:sht]
address CMDbatADDsignalaccum
comment "Return B1 + B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command add_noerror(b1:bat[:oid,:sht],b2:bat[:oid,:sht]) :bat[:oid,:sht]
address CMDbatADD
comment "Return B1 + B2, overflow causes NIL value";
pattern +(b:bat[:oid,:sht],v:sht) :bat[:oid,:sht]
address CMDbatADDcstsignal
comment "Return B + V, signal error on overflow";
pattern +(b:bat[:oid,:sht],v:sht,accum:int) :bat[:oid,:sht]
address CMDbatADDcstsignal
comment "Return B + V, signal error on overflow, reuse B if ACCUM is set";
pattern add_noerror(b:bat[:oid,:sht],v:sht) :bat[:oid,:sht]
address CMDbatADDcst
comment "Return B + V, overflow causes NIL value";
pattern +(v:sht,b:bat[:oid,:sht]) :bat[:oid,:sht]
address CMDbatADDcstsignal
comment "Return V + B, signal error on overflow";
pattern +(v:sht,b:bat[:oid,:sht],accum:int) :bat[:oid,:sht]
address CMDbatADDcstsignal
comment "Return V + B, signal error on overflow, reuse B if ACCUM is set";
pattern add_noerror(v:sht,b:bat[:oid,:sht]) :bat[:oid,:sht]
address CMDbatADDcst
comment "Return V + B, overflow causes NIL value";

command +(b1:bat[:oid,:sht],b2:bat[:oid,:int]) :bat[:oid,:int]
address CMDbatADDsignal
comment "Return B1 + B2, signal error on overflow";
command +(b1:bat[:oid,:sht],b2:bat[:oid,:int],accum:int) :bat[:oid,:int]
address CMDbatADDsignalaccum
comment "Return B1 + B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command add_noerror(b1:bat[:oid,:sht],b2:bat[:oid,:int]) :bat[:oid,:int]
address CMDbatADD
comment "Return B1 + B2, overflow causes NIL value";
pattern +(b:bat[:oid,:sht],v:int) :bat[:oid,:int]
address CMDbatADDcstsignal
comment "Return B + V, signal error on overflow";
pattern add_noerror(b:bat[:oid,:sht],v:int) :bat[:oid,:int]
address CMDbatADDcst
comment "Return B + V, overflow causes NIL value";
pattern +(v:sht,b:bat[:oid,:int]) :bat[:oid,:int]
address CMDbatADDcstsignal
comment "Return V + B, signal error on overflow";
pattern +(v:sht,b:bat[:oid,:int],accum:int) :bat[:oid,:int]
address CMDbatADDcstsignal
comment "Return V + B, signal error on overflow, reuse B if ACCUM is set";
pattern add_noerror(v:sht,b:bat[:oid,:int]) :bat[:oid,:int]
address CMDbatADDcst
comment "Return V + B, overflow causes NIL value";

command +(b1:bat[:oid,:sht],b2:bat[:oid,:wrd]) :bat[:oid,:wrd]
address CMDbatADDsignal
comment "Return B1 + B2, signal error on overflow";
command +(b1:bat[:oid,:sht],b2:bat[:oid,:wrd],accum:int) :bat[:oid,:wrd]
address CMDbatADDsignalaccum
comment "Return B1 + B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command add_noerror(b1:bat[:oid,:sht],b2:bat[:oid,:wrd]) :bat[:oid,:wrd]
address CMDbatADD
comment "Return B1 + B2, overflow causes NIL value";
pattern +(b:bat[:oid,:sht],v:wrd) :bat[:oid,:wrd]
address CMDbatADDcstsignal
comment "Return B + V, signal error on overflow";
pattern add_noerror(b:bat[:oid,:sht],v:wrd) :bat[:oid,:wrd]
address CMDbatADDcst
comment "Return B + V, overflow causes NIL value";
pattern +(v:sht,b:bat[:oid,:wrd]) :bat[:oid,:wrd]
address CMDbatADDcstsignal
comment "Return V + B, signal error on overflow";
pattern +(v:sht,b:bat[:oid,:wrd],accum:int) :bat[:oid,:wrd]
address CMDbatADDcstsignal
comment "Return V + B, signal error on overflow, reuse B if ACCUM is set";
pattern add_noerror(v:sht,b:bat[:oid,:wrd]) :bat[:oid,:wrd]
address CMDbatADDcst
comment "Return V + B, overflow causes NIL value";

command +(b1:bat[:oid,:sht],b2:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatADDsignal
comment "Return B1 + B2, signal error on overflow";
command +(b1:bat[:oid,:sht],b2:bat[:oid,:lng],accum:int) :bat[:oid,:lng]
address CMDbatADDsignalaccum
comment "Return B1 + B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command add_noerror(b1:bat[:oid,:sht],b2:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatADD
comment "Return B1 + B2, overflow causes NIL value";
pattern +(b:bat[:oid,:sht],v:lng) :bat[:oid,:lng]
address CMDbatADDcstsignal
comment "Return B + V, signal error on overflow";
pattern add_noerror(b:bat[:oid,:sht],v:lng) :bat[:oid,:lng]
address CMDbatADDcst
comment "Return B + V, overflow causes NIL value";
pattern +(v:sht,b:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatADDcstsignal
comment "Return V + B, signal error on overflow";
pattern +(v:sht,b:bat[:oid,:lng],accum:int) :bat[:oid,:lng]
address CMDbatADDcstsignal
comment "Return V + B, signal error on overflow, reuse B if ACCUM is set";
pattern add_noerror(v:sht,b:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatADDcst
comment "Return V + B, overflow causes NIL value";

command +(b1:bat[:oid,:sht],b2:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatADDsignal
comment "Return B1 + B2, signal error on overflow";
command +(b1:bat[:oid,:sht],b2:bat[:oid,:flt],accum:int) :bat[:oid,:flt]
address CMDbatADDsignalaccum
comment "Return B1 + B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command add_noerror(b1:bat[:oid,:sht],b2:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatADD
comment "Return B1 + B2, overflow causes NIL value";
pattern +(b:bat[:oid,:sht],v:flt) :bat[:oid,:flt]
address CMDbatADDcstsignal
comment "Return B + V, signal error on overflow";
pattern add_noerror(b:bat[:oid,:sht],v:flt) :bat[:oid,:flt]
address CMDbatADDcst
comment "Return B + V, overflow causes NIL value";
pattern +(v:sht,b:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatADDcstsignal
comment "Return V + B, signal error on overflow";
pattern +(v:sht,b:bat[:oid,:flt],accum:int) :bat[:oid,:flt]
address CMDbatADDcstsignal
comment "Return V + B, signal error on overflow, reuse B if ACCUM is set";
pattern add_noerror(v:sht,b:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatADDcst
comment "Return V + B, overflow causes NIL value";

command +(b1:bat[:oid,:sht],b2:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatADDsignal
comment "Return B1 + B2, signal error on overflow";
command +(b1:bat[:oid,:sht],b2:bat[:oid,:dbl],accum:int) :bat[:oid,:dbl]
address CMDbatADDsignalaccum
comment "Return B1 + B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command add_noerror(b1:bat[:oid,:sht],b2:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatADD
comment "Return B1 + B2, overflow causes NIL value";
pattern +(b:bat[:oid,:sht],v:dbl) :bat[:oid,:dbl]
address CMDbatADDcstsignal
comment "Return B + V, signal error on overflow";
pattern add_noerror(b:bat[:oid,:sht],v:dbl) :bat[:oid,:dbl]
address CMDbatADDcst
comment "Return B + V, overflow causes NIL value";
pattern +(v:sht,b:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatADDcstsignal
comment "Return V + B, signal error on overflow";
pattern +(v:sht,b:bat[:oid,:dbl],accum:int) :bat[:oid,:dbl]
address CMDbatADDcstsignal
comment "Return V + B, signal error on overflow, reuse B if ACCUM is set";
pattern add_noerror(v:sht,b:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatADDcst
comment "Return V + B, overflow causes NIL value";

command +(b1:bat[:oid,:int],b2:bat[:oid,:bte]) :bat[:oid,:int]
address CMDbatADDsignal
comment "Return B1 + B2, signal error on overflow";
command +(b1:bat[:oid,:int],b2:bat[:oid,:bte],accum:int) :bat[:oid,:int]
address CMDbatADDsignalaccum
comment "Return B1 + B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command add_noerror(b1:bat[:oid,:int],b2:bat[:oid,:bte]) :bat[:oid,:int]
address CMDbatADD
comment "Return B1 + B2, overflow causes NIL value";
pattern +(b:bat[:oid,:int],v:bte) :bat[:oid,:int]
address CMDbatADDcstsignal
comment "Return B + V, signal error on overflow";
pattern +(b:bat[:oid,:int],v:bte,accum:int) :bat[:oid,:int]
address CMDbatADDcstsignal
comment "Return B + V, signal error on overflow, reuse B if ACCUM is set";
pattern add_noerror(b:bat[:oid,:int],v:bte) :bat[:oid,:int]
address CMDbatADDcst
comment "Return B + V, overflow causes NIL value";
pattern +(v:int,b:bat[:oid,:bte]) :bat[:oid,:int]
address CMDbatADDcstsignal
comment "Return V + B, signal error on overflow";
pattern add_noerror(v:int,b:bat[:oid,:bte]) :bat[:oid,:int]
address CMDbatADDcst
comment "Return V + B, overflow causes NIL value";

command +(b1:bat[:oid,:int],b2:bat[:oid,:sht]) :bat[:oid,:int]
address CMDbatADDsignal
comment "Return B1 + B2, signal error on overflow";
command +(b1:bat[:oid,:int],b2:bat[:oid,:sht],accum:int) :bat[:oid,:int]
address CMDbatADDsignalaccum
comment "Return B1 + B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command add_noerror(b1:bat[:oid,:int],b2:bat[:oid,:sht]) :bat[:oid,:int]
address CMDbatADD
comment "Return B1 + B2, overflow causes NIL value";
pattern +(b:bat[:oid,:int],v:sht) :bat[:oid,:int]
address CMDbatADDcstsignal
comment "Return B + V, signal error on overflow";
pattern +(b:bat[:oid,:int],v:sht,accum:int) :bat[:oid,:int]
address CMDbatADDcstsignal
comment "Return B + V, signal error on overflow, reuse B if ACCUM is set";
pattern add_noerror(b:bat[:oid,:int],v:sht) :bat[:oid,:int]
address CMDbatADDcst
comment "Return B + V, overflow causes NIL value";
pattern +(v:int,b:bat[:oid,:sht]) :bat[:oid,:int]
address CMDbatADDcstsignal
comment "Return V + B, signal error on overflow";
pattern add_noerror(v:int,b:bat[:oid,:sht]) :bat[:oid,:int]
address CMDbatADDcst
comment "Return V + B, overflow causes NIL value";

command +(b1:bat[:oid,:int],b2:bat[:oid,:int]) :bat[:oid,:int]
address CMDbatADDsignal
comment "Return B1 + B2, signal error on overflow";
command +(b1:bat[:oid,:int],b2:bat[:oid,:int],accum:int) :bat[:oid,:int]
address CMDbatADDsignalaccum
comment "Return B1 + B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command add_noerror(b1:bat[:oid,:int],b2:bat[:oid,:int]) :bat[:oid,:int]
address CMDbatADD
comment "Return B1 + B2, overflow causes NIL value";
pattern +(b:bat[:oid,:int],v:int) :bat[:oid,:int]
address CMDbatADDcstsignal
comment "Return B + V, signal error on overflow";
pattern +(b:bat[:oid,:int],v:int,accum:int) :bat[:oid,:int]
address CMDbatADDcstsignal
comment "Return B + V, signal error on overflow, reuse B if ACCUM is set";
pattern add_noerror(b:bat[:oid,:int],v:int) :bat[:oid,:int]
address CMDbatADDcst
comment "Return B + V, overflow causes NIL value";
pattern +(v:int,b:bat[:oid,:int]) :bat[:oid,:int]
address CMDbatADDcstsignal
comment "Return V + B, signal error on overflow";
pattern +(v:int,b:bat[:oid,:int],accum:int) :bat[:oid,:int]
address CMDbatADDcstsignal
comment "Return V + B, signal error on overflow, reuse B if ACCUM is set";
pattern add_noerror(v:int,b:bat[:oid,:int]) :bat[:oid,:int]
address CMDbatADDcst
comment "Return V + B, overflow causes NIL value";

command +(b1:bat[:oid,:int],b2:bat[:oid,:wrd]) :bat[:oid,:wrd]
address CMDbatADDsignal
comment "Return B1 + B2, signal error on overflow";
command +(b1:bat[:oid,:int],b2:bat[:oid,:wrd],accum:int) :bat[:oid,:wrd]
address CMDbatADDsignalaccum
comment "Return B1 + B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command add_noerror(b1:bat[:oid,:int],b2:bat[:oid,:wrd]) :bat[:oid,:wrd]
address CMDbatADD
comment "Return B1 + B2, overflow causes NIL value";
pattern +(b:bat[:oid,:int],v:wrd) :bat[:oid,:wrd]
address CMDbatADDcstsignal
comment "Return B + V, signal error on overflow";
pattern add_noerror(b:bat[:oid,:int],v:wrd) :bat[:oid,:wrd]
address CMDbatADDcst
comment "Return B + V, overflow causes NIL value";
pattern +(v:int,b:bat[:oid,:wrd]) :bat[:oid,:wrd]
address CMDbatADDcstsignal
comment "Return V + B, signal error on overflow";
pattern +(v:int,b:bat[:oid,:wrd],accum:int) :bat[:oid,:wrd]
address CMDbatADDcstsignal
comment "Return V + B, signal error on overflow, reuse B if ACCUM is set";
pattern add_noerror(v:int,b:bat[:oid,:wrd]) :bat[:oid,:wrd]
address CMDbatADDcst
comment "Return V + B, overflow causes NIL value";

command +(b1:bat[:oid,:int],b2:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatADDsignal
comment "Return B1 + B2, signal error on overflow";
command +(b1:bat[:oid,:int],b2:bat[:oid,:lng],accum:int) :bat[:oid,:lng]
address CMDbatADDsignalaccum
comment "Return B1 + B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command add_noerror(b1:bat[:oid,:int],b2:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatADD
comment "Return B1 + B2, overflow causes NIL value";
pattern +(b:bat[:oid,:int],v:lng) :bat[:oid,:lng]
address CMDbatADDcstsignal
comment "Return B + V, signal error on overflow";
pattern add_noerror(b:bat[:oid,:int],v:lng) :bat[:oid,:lng]
address CMDbatADDcst
comment "Return B + V, overflow causes NIL value";
pattern +(v:int,b:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatADDcstsignal
comment "Return V + B, signal error on overflow";
pattern +(v:int,b:bat[:oid,:lng],accum:int) :bat[:oid,:lng]
address CMDbatADDcstsignal
comment "Return V + B, signal error on overflow, reuse B if ACCUM is set";
pattern add_noerror(v:int,b:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatADDcst
comment "Return V + B, overflow causes NIL value";

command +(b1:bat[:oid,:int],b2:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatADDsignal
comment "Return B1 + B2, signal error on overflow";
command +(b1:bat[:oid,:int],b2:bat[:oid,:flt],accum:int) :bat[:oid,:flt]
address CMDbatADDsignalaccum
comment "Return B1 + B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command add_noerror(b1:bat[:oid,:int],b2:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatADD
comment "Return B1 + B2, overflow causes NIL value";
pattern +(b:bat[:oid,:int],v:flt) :bat[:oid,:flt]
address CMDbatADDcstsignal
comment "Return B + V, signal error on overflow";
pattern add_noerror(b:bat[:oid,:int],v:flt) :bat[:oid,:flt]
address CMDbatADDcst
comment "Return B + V, overflow causes NIL value";
pattern +(v:int,b:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatADDcstsignal
comment "Return V + B, signal error on overflow";
pattern +(v:int,b:bat[:oid,:flt],accum:int) :bat[:oid,:flt]
address CMDbatADDcstsignal
comment "Return V + B, signal error on overflow, reuse B if ACCUM is set";
pattern add_noerror(v:int,b:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatADDcst
comment "Return V + B, overflow causes NIL value";

command +(b1:bat[:oid,:int],b2:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatADDsignal
comment "Return B1 + B2, signal error on overflow";
command +(b1:bat[:oid,:int],b2:bat[:oid,:dbl],accum:int) :bat[:oid,:dbl]
address CMDbatADDsignalaccum
comment "Return B1 + B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command add_noerror(b1:bat[:oid,:int],b2:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatADD
comment "Return B1 + B2, overflow causes NIL value";
pattern +(b:bat[:oid,:int],v:dbl) :bat[:oid,:dbl]
address CMDbatADDcstsignal
comment "Return B + V, signal error on overflow";
pattern add_noerror(b:bat[:oid,:int],v:dbl) :bat[:oid,:dbl]
address CMDbatADDcst
comment "Return B + V, overflow causes NIL value";
pattern +(v:int,b:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatADDcstsignal
comment "Return V + B, signal error on overflow";
pattern +(v:int,b:bat[:oid,:dbl],accum:int) :bat[:oid,:dbl]
address CMDbatADDcstsignal
comment "Return V + B, signal error on overflow, reuse B if ACCUM is set";
pattern add_noerror(v:int,b:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatADDcst
comment "Return V + B, overflow causes NIL value";

command +(b1:bat[:oid,:wrd],b2:bat[:oid,:bte]) :bat[:oid,:wrd]
address CMDbatADDsignal
comment "Return B1 + B2, signal error on overflow";
command +(b1:bat[:oid,:wrd],b2:bat[:oid,:bte],accum:int) :bat[:oid,:wrd]
address CMDbatADDsignalaccum
comment "Return B1 + B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command add_noerror(b1:bat[:oid,:wrd],b2:bat[:oid,:bte]) :bat[:oid,:wrd]
address CMDbatADD
comment "Return B1 + B2, overflow causes NIL value";
pattern +(b:bat[:oid,:wrd],v:bte) :bat[:oid,:wrd]
address CMDbatADDcstsignal
comment "Return B + V, signal error on overflow";
pattern +(b:bat[:oid,:wrd],v:bte,accum:int) :bat[:oid,:wrd]
address CMDbatADDcstsignal
comment "Return B + V, signal error on overflow, reuse B if ACCUM is set";
pattern add_noerror(b:bat[:oid,:wrd],v:bte) :bat[:oid,:wrd]
address CMDbatADDcst
comment "Return B + V, overflow causes NIL value";
pattern +(v:wrd,b:bat[:oid,:bte]) :bat[:oid,:wrd]
address CMDbatADDcstsignal
comment "Return V + B, signal error on overflow";
pattern add_noerror(v:wrd,b:bat[:oid,:bte]) :bat[:oid,:wrd]
address CMDbatADDcst
comment "Return V + B, overflow causes NIL value";

command +(b1:bat[:oid,:wrd],b2:bat[:oid,:sht]) :bat[:oid,:wrd]
address CMDbatADDsignal
comment "Return B1 + B2, signal error on overflow";
command +(b1:bat[:oid,:wrd],b2:bat[:oid,:sht],accum:int) :bat[:oid,:wrd]
address CMDbatADDsignalaccum
comment "Return B1 + B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command add_noerror(b1:bat[:oid,:wrd],b2:bat[:oid,:sht]) :bat[:oid,:wrd]
address CMDbatADD
comment "Return B1 + B2, overflow causes NIL value";
pattern +(b:bat[:oid,:wrd],v:sht) :bat[:oid,:wrd]
address CMDbatADDcstsignal
comment "Return B + V, signal error on overflow";
pattern +(b:bat[:oid,:wrd],v:sht,accum:int) :bat[:oid,:wrd]
address CMDbatADDcstsignal
comment "Return B + V, signal error on overflow, reuse B if ACCUM is set";
pattern add_noerror(b:bat[:oid,:wrd],v:sht) :bat[:oid,:wrd]
address CMDbatADDcst
comment "Return B + V, overflow causes NIL value";
pattern +(v:wrd,b:bat[:oid,:sht]) :bat[:oid,:wrd]
address CMDbatADDcstsignal
comment "Return V + B, signal error on overflow";
pattern add_noerror(v:wrd,b:bat[:oid,:sht]) :bat[:oid,:wrd]
address CMDbatADDcst
comment "Return V + B, overflow causes NIL value";

command +(b1:bat[:oid,:wrd],b2:bat[:oid,:int]) :bat[:oid,:wrd]
address CMDbatADDsignal
comment "Return B1 + B2, signal error on overflow";
command +(b1:bat[:oid,:wrd],b2:bat[:oid,:int],accum:int) :bat[:oid,:wrd]
address CMDbatADDsignalaccum
comment "Return B1 + B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command add_noerror(b1:bat[:oid,:wrd],b2:bat[:oid,:int]) :bat[:oid,:wrd]
address CMDbatADD
comment "Return B1 + B2, overflow causes NIL value";
pattern +(b:bat[:oid,:wrd],v:int) :bat[:oid,:wrd]
address CMDbatADDcstsignal
comment "Return B + V, signal error on overflow";
pattern +(b:bat[:oid,:wrd],v:int,accum:int) :bat[:oid,:wrd]
address CMDbatADDcstsignal
comment "Return B + V, signal error on overflow, reuse B if ACCUM is set";
pattern add_noerror(b:bat[:oid,:wrd],v:int) :bat[:oid,:wrd]
address CMDbatADDcst
comment "Return B + V, overflow causes NIL value";
pattern +(v:wrd,b:bat[:oid,:int]) :bat[:oid,:wrd]
address CMDbatADDcstsignal
comment "Return V + B, signal error on overflow";
pattern add_noerror(v:wrd,b:bat[:oid,:int]) :bat[:oid,:wrd]
address CMDbatADDcst
comment "Return V + B, overflow causes NIL value";

command +(b1:bat[:oid,:wrd],b2:bat[:oid,:wrd]) :bat[:oid,:wrd]
address CMDbatADDsignal
comment "Return B1 + B2, signal error on overflow";
command +(b1:bat[:oid,:wrd],b2:bat[:oid,:wrd],accum:int) :bat[:oid,:wrd]
address CMDbatADDsignalaccum
comment "Return B1 + B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command add_noerror(b1:bat[:oid,:wrd],b2:bat[:oid,:wrd]) :bat[:oid,:wrd]
address CMDbatADD
comment "Return B1 + B2, overflow causes NIL value";
pattern +(b:bat[:oid,:wrd],v:wrd) :bat[:oid,:wrd]
address CMDbatADDcstsignal
comment "Return B + V, signal error on overflow";
pattern +(b:bat[:oid,:wrd],v:wrd,accum:int) :bat[:oid,:wrd]
address CMDbatADDcstsignal
comment "Return B + V, signal error on overflow, reuse B if ACCUM is set";
pattern add_noerror(b:bat[:oid,:wrd],v:wrd) :bat[:oid,:wrd]
address CMDbatADDcst
comment "Return B + V, overflow causes NIL value";
pattern +(v:wrd,b:bat[:oid,:wrd]) :bat[:oid,:wrd]
address CMDbatADDcstsignal
comment "Return V + B, signal error on overflow";
pattern +(v:wrd,b:bat[:oid,:wrd],accum:int) :bat[:oid,:wrd]
address CMDbatADDcstsignal
comment "Return V + B, signal error on overflow, reuse B if ACCUM is set";
pattern add_noerror(v:wrd,b:bat[:oid,:wrd]) :bat[:oid,:wrd]
address CMDbatADDcst
comment "Return V + B, overflow causes NIL value";

command +(b1:bat[:oid,:wrd],b2:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatADDsignal
comment "Return B1 + B2, signal error on overflow";
command +(b1:bat[:oid,:wrd],b2:bat[:oid,:lng],accum:int) :bat[:oid,:lng]
address CMDbatADDsignalaccum
comment "Return B1 + B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command add_noerror(b1:bat[:oid,:wrd],b2:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatADD
comment "Return B1 + B2, overflow causes NIL value";
pattern +(b:bat[:oid,:wrd],v:lng) :bat[:oid,:lng]
address CMDbatADDcstsignal
comment "Return B + V, signal error on overflow";
pattern add_noerror(b:bat[:oid,:wrd],v:lng) :bat[:oid,:lng]
address CMDbatADDcst
comment "Return B + V, overflow causes NIL value";
pattern +(v:wrd,b:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatADDcstsignal
comment "Return V + B, signal error on overflow";
pattern +(v:wrd,b:bat[:oid,:lng],accum:int) :bat[:oid,:lng]
address CMDbatADDcstsignal
comment "Return V + B, signal error on overflow, reuse B if ACCUM is set";
pattern add_noerror(v:wrd,b:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatADDcst
comment "Return V + B, overflow causes NIL value";

command +(b1:bat[:oid,:wrd],b2:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatADDsignal
comment "Return B1 + B2, signal error on overflow";
command +(b1:bat[:oid,:wrd],b2:bat[:oid,:flt],accum:int) :bat[:oid,:flt]
address CMDbatADDsignalaccum
comment "Return B1 + B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command add_noerror(b1:bat[:oid,:wrd],b2:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatADD
comment "Return B1 + B2, overflow causes NIL value";
pattern +(b:bat[:oid,:wrd],v:flt) :bat[:oid,:flt]
address CMDbatADDcstsignal
comment "Return B + V, signal error on overflow";
pattern add_noerror(b:bat[:oid,:wrd],v:flt) :bat[:oid,:flt]
address CMDbatADDcst
comment "Return B + V, overflow causes NIL value";
pattern +(v:wrd,b:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatADDcstsignal
comment "Return V + B, signal error on overflow";
pattern +(v:wrd,b:bat[:oid,:flt],accum:int) :bat[:oid,:flt]
address CMDbatADDcstsignal
comment "Return V + B, signal error on overflow, reuse B if ACCUM is set";
pattern add_noerror(v:wrd,b:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatADDcst
comment "Return V + B, overflow causes NIL value";

command +(b1:bat[:oid,:wrd],b2:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatADDsignal
comment "Return B1 + B2, signal error on overflow";
command +(b1:bat[:oid,:wrd],b2:bat[:oid,:dbl],accum:int) :bat[:oid,:dbl]
address CMDbatADDsignalaccum
comment "Return B1 + B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command add_noerror(b1:bat[:oid,:wrd],b2:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatADD
comment "Return B1 + B2, overflow causes NIL value";
pattern +(b:bat[:oid,:wrd],v:dbl) :bat[:oid,:dbl]
address CMDbatADDcstsignal
comment "Return B + V, signal error on overflow";
pattern add_noerror(b:bat[:oid,:wrd],v:dbl) :bat[:oid,:dbl]
address CMDbatADDcst
comment "Return B + V, overflow causes NIL value";
pattern +(v:wrd,b:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatADDcstsignal
comment "Return V + B, signal error on overflow";
pattern +(v:wrd,b:bat[:oid,:dbl],accum:int) :bat[:oid,:dbl]
address CMDbatADDcstsignal
comment "Return V + B, signal error on overflow, reuse B if ACCUM is set";
pattern add_noerror(v:wrd,b:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatADDcst
comment "Return V + B, overflow causes NIL value";

command +(b1:bat[:oid,:lng],b2:bat[:oid,:bte]) :bat[:oid,:lng]
address CMDbatADDsignal
comment "Return B1 + B2, signal error on overflow";
command +(b1:bat[:oid,:lng],b2:bat[:oid,:bte],accum:int) :bat[:oid,:lng]
address CMDbatADDsignalaccum
comment "Return B1 + B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command add_noerror(b1:bat[:oid,:lng],b2:bat[:oid,:bte]) :bat[:oid,:lng]
address CMDbatADD
comment "Return B1 + B2, overflow causes NIL value";
pattern +(b:bat[:oid,:lng],v:bte) :bat[:oid,:lng]
address CMDbatADDcstsignal
comment "Return B + V, signal error on overflow";
pattern +(b:bat[:oid,:lng],v:bte,accum:int) :bat[:oid,:lng]
address CMDbatADDcstsignal
comment "Return B + V, signal error on overflow, reuse B if ACCUM is set";
pattern add_noerror(b:bat[:oid,:lng],v:bte) :bat[:oid,:lng]
address CMDbatADDcst
comment "Return B + V, overflow causes NIL value";
pattern +(v:lng,b:bat[:oid,:bte]) :bat[:oid,:lng]
address CMDbatADDcstsignal
comment "Return V + B, signal error on overflow";
pattern add_noerror(v:lng,b:bat[:oid,:bte]) :bat[:oid,:lng]
address CMDbatADDcst
comment "Return V + B, overflow causes NIL value";

command +(b1:bat[:oid,:lng],b2:bat[:oid,:sht]) :bat[:oid,:lng]
address CMDbatADDsignal
comment "Return B1 + B2, signal error on overflow";
command +(b1:bat[:oid,:lng],b2:bat[:oid,:sht],accum:int) :bat[:oid,:lng]
address CMDbatADDsignalaccum
comment "Return B1 + B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command add_noerror(b1:bat[:oid,:lng],b2:bat[:oid,:sht]) :bat[:oid,:lng]
address CMDbatADD
comment "Return B1 + B2, overflow causes NIL value";
pattern +(b:bat[:oid,:lng],v:sht) :bat[:oid,:lng]
address CMDbatADDcstsignal
comment "Return B + V, signal error on overflow";
pattern +(b:bat[:oid,:lng],v:sht,accum:int) :bat[:oid,:lng]
address CMDbatADDcstsignal
comment "Return B + V, signal error on overflow, reuse B if ACCUM is set";
pattern add_noerror(b:bat[:oid,:lng],v:sht) :bat[:oid,:lng]
address CMDbatADDcst
comment "Return B + V, overflow causes NIL value";
pattern +(v:lng,b:bat[:oid,:sht]) :bat[:oid,:lng]
address CMDbatADDcstsignal
comment "Return V + B, signal error on overflow";
pattern add_noerror(v:lng,b:bat[:oid,:sht]) :bat[:oid,:lng]
address CMDbatADDcst
comment "Return V + B, overflow causes NIL value";

command +(b1:bat[:oid,:lng],b2:bat[:oid,:int]) :bat[:oid,:lng]
address CMDbatADDsignal
comment "Return B1 + B2, signal error on overflow";
command +(b1:bat[:oid,:lng],b2:bat[:oid,:int],accum:int) :bat[:oid,:lng]
address CMDbatADDsignalaccum
comment "Return B1 + B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command add_noerror(b1:bat[:oid,:lng],b2:bat[:oid,:int]) :bat[:oid,:lng]
address CMDbatADD
comment "Return B1 + B2, overflow causes NIL value";
pattern +(b:bat[:oid,:lng],v:int) :bat[:oid,:lng]
address CMDbatADDcstsignal
comment "Return B + V, signal error on overflow";
pattern +(b:bat[:oid,:lng],v:int,accum:int) :bat[:oid,:lng]
address CMDbatADDcstsignal
comment "Return B + V, signal error on overflow, reuse B if ACCUM is set";
pattern add_noerror(b:bat[:oid,:lng],v:int) :bat[:oid,:lng]
address CMDbatADDcst
comment "Return B + V, overflow causes NIL value";
pattern +(v:lng,b:bat[:oid,:int]) :bat[:oid,:lng]
address CMDbatADDcstsignal
comment "Return V + B, signal error on overflow";
pattern add_noerror(v:lng,b:bat[:oid,:int]) :bat[:oid,:lng]
address CMDbatADDcst
comment "Return V + B, overflow causes NIL value";

command +(b1:bat[:oid,:lng],b2:bat[:oid,:wrd]) :bat[:oid,:lng]
address CMDbatADDsignal
comment "Return B1 + B2, signal error on overflow";
command +(b1:bat[:oid,:lng],b2:bat[:oid,:wrd],accum:int) :bat[:oid,:lng]
address CMDbatADDsignalaccum
comment "Return B1 + B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command add_noerror(b1:bat[:oid,:lng],b2:bat[:oid,:wrd]) :bat[:oid,:lng]
address CMDbatADD
comment "Return B1 + B2, overflow causes NIL value";
pattern +(b:bat[:oid,:lng],v:wrd) :bat[:oid,:lng]
address CMDbatADDcstsignal
comment "Return B + V, signal error on overflow";
pattern +(b:bat[:oid,:lng],v:wrd,accum:int) :bat[:oid,:lng]
address CMDbatADDcstsignal
comment "Return B + V, signal error on overflow, reuse B if ACCUM is set";
pattern add_noerror(b:bat[:oid,:lng],v:wrd) :bat[:oid,:lng]
address CMDbatADDcst
comment "Return B + V, overflow causes NIL value";
pattern +(v:lng,b:bat[:oid,:wrd]) :bat[:oid,:lng]
address CMDbatADDcstsignal
comment "Return V + B, signal error on overflow";
pattern add_noerror(v:lng,b:bat[:oid,:wrd]) :bat[:oid,:lng]
address CMDbatADDcst
comment "Return V + B, overflow causes NIL value";

command +(b1:bat[:oid,:lng],b2:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatADDsignal
comment "Return B1 + B2, signal error on overflow";
command +(b1:bat[:oid,:lng],b2:bat[:oid,:lng],accum:int) :bat[:oid,:lng]
address CMDbatADDsignalaccum
comment "Return B1 + B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command add_noerror(b1:bat[:oid,:lng],b2:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatADD
comment "Return B1 + B2, overflow causes NIL value";
pattern +(b:bat[:oid,:lng],v:lng) :bat[:oid,:lng]
address CMDbatADDcstsignal
comment "Return B + V, signal error on overflow";
pattern +(b:bat[:oid,:lng],v:lng,accum:int) :bat[:oid,:lng]
address CMDbatADDcstsignal
comment "Return B + V, signal error on overflow, reuse B if ACCUM is set";
pattern add_noerror(b:bat[:oid,:lng],v:lng) :bat[:oid,:lng]
address CMDbatADDcst
comment "Return B + V, overflow causes NIL value";
pattern +(v:lng,b:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatADDcstsignal
comment "Return V + B, signal error on overflow";
pattern +(v:lng,b:bat[:oid,:lng],accum:int) :bat[:oid,:lng]
address CMDbatADDcstsignal
comment "Return V + B, signal error on overflow, reuse B if ACCUM is set";
pattern add_noerror(v:lng,b:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatADDcst
comment "Return V + B, overflow causes NIL value";

command +(b1:bat[:oid,:lng],b2:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatADDsignal
comment "Return B1 + B2, signal error on overflow";
command +(b1:bat[:oid,:lng],b2:bat[:oid,:flt],accum:int) :bat[:oid,:flt]
address CMDbatADDsignalaccum
comment "Return B1 + B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command add_noerror(b1:bat[:oid,:lng],b2:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatADD
comment "Return B1 + B2, overflow causes NIL value";
pattern +(b:bat[:oid,:lng],v:flt) :bat[:oid,:flt]
address CMDbatADDcstsignal
comment "Return B + V, signal error on overflow";
pattern add_noerror(b:bat[:oid,:lng],v:flt) :bat[:oid,:flt]
address CMDbatADDcst
comment "Return B + V, overflow causes NIL value";
pattern +(v:lng,b:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatADDcstsignal
comment "Return V + B, signal error on overflow";
pattern +(v:lng,b:bat[:oid,:flt],accum:int) :bat[:oid,:flt]
address CMDbatADDcstsignal
comment "Return V + B, signal error on overflow, reuse B if ACCUM is set";
pattern add_noerror(v:lng,b:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatADDcst
comment "Return V + B, overflow causes NIL value";

command +(b1:bat[:oid,:lng],b2:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatADDsignal
comment "Return B1 + B2, signal error on overflow";
command +(b1:bat[:oid,:lng],b2:bat[:oid,:dbl],accum:int) :bat[:oid,:dbl]
address CMDbatADDsignalaccum
comment "Return B1 + B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command add_noerror(b1:bat[:oid,:lng],b2:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatADD
comment "Return B1 + B2, overflow causes NIL value";
pattern +(b:bat[:oid,:lng],v:dbl) :bat[:oid,:dbl]
address CMDbatADDcstsignal
comment "Return B + V, signal error on overflow";
pattern add_noerror(b:bat[:oid,:lng],v:dbl) :bat[:oid,:dbl]
address CMDbatADDcst
comment "Return B + V, overflow causes NIL value";
pattern +(v:lng,b:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatADDcstsignal
comment "Return V + B, signal error on overflow";
pattern +(v:lng,b:bat[:oid,:dbl],accum:int) :bat[:oid,:dbl]
address CMDbatADDcstsignal
comment "Return V + B, signal error on overflow, reuse B if ACCUM is set";
pattern add_noerror(v:lng,b:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatADDcst
comment "Return V + B, overflow causes NIL value";

command +(b1:bat[:oid,:flt],b2:bat[:oid,:bte]) :bat[:oid,:flt]
address CMDbatADDsignal
comment "Return B1 + B2, signal error on overflow";
command +(b1:bat[:oid,:flt],b2:bat[:oid,:bte],accum:int) :bat[:oid,:flt]
address CMDbatADDsignalaccum
comment "Return B1 + B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command add_noerror(b1:bat[:oid,:flt],b2:bat[:oid,:bte]) :bat[:oid,:flt]
address CMDbatADD
comment "Return B1 + B2, overflow causes NIL value";
pattern +(b:bat[:oid,:flt],v:bte) :bat[:oid,:flt]
address CMDbatADDcstsignal
comment "Return B + V, signal error on overflow";
pattern +(b:bat[:oid,:flt],v:bte,accum:int) :bat[:oid,:flt]
address CMDbatADDcstsignal
comment "Return B + V, signal error on overflow, reuse B if ACCUM is set";
pattern add_noerror(b:bat[:oid,:flt],v:bte) :bat[:oid,:flt]
address CMDbatADDcst
comment "Return B + V, overflow causes NIL value";
pattern +(v:flt,b:bat[:oid,:bte]) :bat[:oid,:flt]
address CMDbatADDcstsignal
comment "Return V + B, signal error on overflow";
pattern add_noerror(v:flt,b:bat[:oid,:bte]) :bat[:oid,:flt]
address CMDbatADDcst
comment "Return V + B, overflow causes NIL value";

command +(b1:bat[:oid,:flt],b2:bat[:oid,:sht]) :bat[:oid,:flt]
address CMDbatADDsignal
comment "Return B1 + B2, signal error on overflow";
command +(b1:bat[:oid,:flt],b2:bat[:oid,:sht],accum:int) :bat[:oid,:flt]
address CMDbatADDsignalaccum
comment "Return B1 + B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command add_noerror(b1:bat[:oid,:flt],b2:bat[:oid,:sht]) :bat[:oid,:flt]
address CMDbatADD
comment "Return B1 + B2, overflow causes NIL value";
pattern +(b:bat[:oid,:flt],v:sht) :bat[:oid,:flt]
address CMDbatADDcstsignal
comment "Return B + V, signal error on overflow";
pattern +(b:bat[:oid,:flt],v:sht,accum:int) :bat[:oid,:flt]
address CMDbatADDcstsignal
comment "Return B + V, signal error on overflow, reuse B if ACCUM is set";
pattern add_noerror(b:bat[:oid,:flt],v:sht) :bat[:oid,:flt]
address CMDbatADDcst
comment "Return B + V, overflow causes NIL value";
pattern +(v:flt,b:bat[:oid,:sht]) :bat[:oid,:flt]
address CMDbatADDcstsignal
comment "Return V + B, signal error on overflow";
pattern add_noerror(v:flt,b:bat[:oid,:sht]) :bat[:oid,:flt]
address CMDbatADDcst
comment "Return V + B, overflow causes NIL value";

command +(b1:bat[:oid,:flt],b2:bat[:oid,:int]) :bat[:oid,:flt]
address CMDbatADDsignal
comment "Return B1 + B2, signal error on overflow";
command +(b1:bat[:oid,:flt],b2:bat[:oid,:int],accum:int) :bat[:oid,:flt]
address CMDbatADDsignalaccum
comment "Return B1 + B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command add_noerror(b1:bat[:oid,:flt],b2:bat[:oid,:int]) :bat[:oid,:flt]
address CMDbatADD
comment "Return B1 + B2, overflow causes NIL value";
pattern +(b:bat[:oid,:flt],v:int) :bat[:oid,:flt]
address CMDbatADDcstsignal
comment "Return B + V, signal error on overflow";
pattern +(b:bat[:oid,:flt],v:int,accum:int) :bat[:oid,:flt]
address CMDbatADDcstsignal
comment "Return B + V, signal error on overflow, reuse B if ACCUM is set";
pattern add_noerror(b:bat[:oid,:flt],v:int) :bat[:oid,:flt]
address CMDbatADDcst
comment "Return B + V, overflow causes NIL value";
pattern +(v:flt,b:bat[:oid,:int]) :bat[:oid,:flt]
address CMDbatADDcstsignal
comment "Return V + B, signal error on overflow";
pattern add_noerror(v:flt,b:bat[:oid,:int]) :bat[:oid,:flt]
address CMDbatADDcst
comment "Return V + B, overflow causes NIL value";

command +(b1:bat[:oid,:flt],b2:bat[:oid,:wrd]) :bat[:oid,:flt]
address CMDbatADDsignal
comment "Return B1 + B2, signal error on overflow";
command +(b1:bat[:oid,:flt],b2:bat[:oid,:wrd],accum:int) :bat[:oid,:flt]
address CMDbatADDsignalaccum
comment "Return B1 + B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command add_noerror(b1:bat[:oid,:flt],b2:bat[:oid,:wrd]) :bat[:oid,:flt]
address CMDbatADD
comment "Return B1 + B2, overflow causes NIL value";
pattern +(b:bat[:oid,:flt],v:wrd) :bat[:oid,:flt]
address CMDbatADDcstsignal
comment "Return B + V, signal error on overflow";
pattern +(b:bat[:oid,:flt],v:wrd,accum:int) :bat[:oid,:flt]
address CMDbatADDcstsignal
comment "Return B + V, signal error on overflow, reuse B if ACCUM is set";
pattern add_noerror(b:bat[:oid,:flt],v:wrd) :bat[:oid,:flt]
address CMDbatADDcst
comment "Return B + V, overflow causes NIL value";
pattern +(v:flt,b:bat[:oid,:wrd]) :bat[:oid,:flt]
address CMDbatADDcstsignal
comment "Return V + B, signal error on overflow";
pattern add_noerror(v:flt,b:bat[:oid,:wrd]) :bat[:oid,:flt]
address CMDbatADDcst
comment "Return V + B, overflow causes NIL value";

command +(b1:bat[:oid,:flt],b2:bat[:oid,:lng]) :bat[:oid,:flt]
address CMDbatADDsignal
comment "Return B1 + B2, signal error on overflow";
command +(b1:bat[:oid,:flt],b2:bat[:oid,:lng],accum:int) :bat[:oid,:flt]
address CMDbatADDsignalaccum
comment "Return B1 + B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command add_noerror(b1:bat[:oid,:flt],b2:bat[:oid,:lng]) :bat[:oid,:flt]
address CMDbatADD
comment "Return B1 + B2, overflow causes NIL value";
pattern +(b:bat[:oid,:flt],v:lng) :bat[:oid,:flt]
address CMDbatADDcstsignal
comment "Return B + V, signal error on overflow";
pattern +(b:bat[:oid,:flt],v:lng,accum:int) :bat[:oid,:flt]
address CMDbatADDcstsignal
comment "Return B + V, signal error on overflow, reuse B if ACCUM is set";
pattern add_noerror(b:bat[:oid,:flt],v:lng) :bat[:oid,:flt]
address CMDbatADDcst
comment "Return B + V, overflow causes NIL value";
pattern +(v:flt,b:bat[:oid,:lng]) :bat[:oid,:flt]
address CMDbatADDcstsignal
comment "Return V + B, signal error on overflow";
pattern add_noerror(v:flt,b:bat[:oid,:lng]) :bat[:oid,:flt]
address CMDbatADDcst
comment "Return V + B, overflow causes NIL value";

command +(b1:bat[:oid,:flt],b2:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatADDsignal
comment "Return B1 + B2, signal error on overflow";
command +(b1:bat[:oid,:flt],b2:bat[:oid,:flt],accum:int) :bat[:oid,:flt]
address CMDbatADDsignalaccum
comment "Return B1 + B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command add_noerror(b1:bat[:oid,:flt],b2:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatADD
comment "Return B1 + B2, overflow causes NIL value";
pattern +(b:bat[:oid,:flt],v:flt) :bat[:oid,:flt]
address CMDbatADDcstsignal
comment "Return B + V, signal error on overflow";
pattern +(b:bat[:oid,:flt],v:flt,accum:int) :bat[:oid,:flt]
address CMDbatADDcstsignal
comment "Return B + V, signal error on overflow, reuse B if ACCUM is set";
pattern add_noerror(b:bat[:oid,:flt],v:flt) :bat[:oid,:flt]
address CMDbatADDcst
comment "Return B + V, overflow causes NIL value";
pattern +(v:flt,b:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatADDcstsignal
comment "Return V + B, signal error on overflow";
pattern +(v:flt,b:bat[:oid,:flt],accum:int) :bat[:oid,:flt]
address CMDbatADDcstsignal
comment "Return V + B, signal error on overflow, reuse B if ACCUM is set";
pattern add_noerror(v:flt,b:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatADDcst
comment "Return V + B, overflow causes NIL value";

command +(b1:bat[:oid,:flt],b2:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatADDsignal
comment "Return B1 + B2, signal error on overflow";
command +(b1:bat[:oid,:flt],b2:bat[:oid,:dbl],accum:int) :bat[:oid,:dbl]
address CMDbatADDsignalaccum
comment "Return B1 + B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command add_noerror(b1:bat[:oid,:flt],b2:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatADD
comment "Return B1 + B2, overflow causes NIL value";
pattern +(b:bat[:oid,:flt],v:dbl) :bat[:oid,:dbl]
address CMDbatADDcstsignal
comment "Return B + V, signal error on overflow";
pattern add_noerror(b:bat[:oid,:flt],v:dbl) :bat[:oid,:dbl]
address CMDbatADDcst
comment "Return B + V, overflow causes NIL value";
pattern +(v:flt,b:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatADDcstsignal
comment "Return V + B, signal error on overflow";
pattern +(v:flt,b:bat[:oid,:dbl],accum:int) :bat[:oid,:dbl]
address CMDbatADDcstsignal
comment "Return V + B, signal error on overflow, reuse B if ACCUM is set";
pattern add_noerror(v:flt,b:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatADDcst
comment "Return V + B, overflow causes NIL value";

command +(b1:bat[:oid,:dbl],b2:bat[:oid,:bte]) :bat[:oid,:dbl]
address CMDbatADDsignal
comment "Return B1 + B2, signal error on overflow";
command +(b1:bat[:oid,:dbl],b2:bat[:oid,:bte],accum:int) :bat[:oid,:dbl]
address CMDbatADDsignalaccum
comment "Return B1 + B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command add_noerror(b1:bat[:oid,:dbl],b2:bat[:oid,:bte]) :bat[:oid,:dbl]
address CMDbatADD
comment "Return B1 + B2, overflow causes NIL value";
pattern +(b:bat[:oid,:dbl],v:bte) :bat[:oid,:dbl]
address CMDbatADDcstsignal
comment "Return B + V, signal error on overflow";
pattern +(b:bat[:oid,:dbl],v:bte,accum:int) :bat[:oid,:dbl]
address CMDbatADDcstsignal
comment "Return B + V, signal error on overflow, reuse B if ACCUM is set";
pattern add_noerror(b:bat[:oid,:dbl],v:bte) :bat[:oid,:dbl]
address CMDbatADDcst
comment "Return B + V, overflow causes NIL value";
pattern +(v:dbl,b:bat[:oid,:bte]) :bat[:oid,:dbl]
address CMDbatADDcstsignal
comment "Return V + B, signal error on overflow";
pattern add_noerror(v:dbl,b:bat[:oid,:bte]) :bat[:oid,:dbl]
address CMDbatADDcst
comment "Return V + B, overflow causes NIL value";

command +(b1:bat[:oid,:dbl],b2:bat[:oid,:sht]) :bat[:oid,:dbl]
address CMDbatADDsignal
comment "Return B1 + B2, signal error on overflow";
command +(b1:bat[:oid,:dbl],b2:bat[:oid,:sht],accum:int) :bat[:oid,:dbl]
address CMDbatADDsignalaccum
comment "Return B1 + B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command add_noerror(b1:bat[:oid,:dbl],b2:bat[:oid,:sht]) :bat[:oid,:dbl]
address CMDbatADD
comment "Return B1 + B2, overflow causes NIL value";
pattern +(b:bat[:oid,:dbl],v:sht) :bat[:oid,:dbl]
address CMDbatADDcstsignal
comment "Return B + V, signal error on overflow";
pattern +(b:bat[:oid,:dbl],v:sht,accum:int) :bat[:oid,:dbl]
address CMDbatADDcstsignal
comment "Return B + V, signal error on overflow, reuse B if ACCUM is set";
pattern add_noerror(b:bat[:oid,:dbl],v:sht) :bat[:oid,:dbl]
address CMDbatADDcst
comment "Return B + V, overflow causes NIL value";
pattern +(v:dbl,b:bat[:oid,:sht]) :bat[:oid,:dbl]
address CMDbatADDcstsignal
comment "Return V + B, signal error on overflow";
pattern add_noerror(v:dbl,b:bat[:oid,:sht]) :bat[:oid,:dbl]
address CMDbatADDcst
comment "Return V + B, overflow causes NIL value";

command +(b1:bat[:oid,:dbl],b2:bat[:oid,:int]) :bat[:oid,:dbl]
address CMDbatADDsignal
comment "Return B1 + B2, signal error on overflow";
command +(b1:bat[:oid,:dbl],b2:bat[:oid,:int],accum:int) :bat[:oid,:dbl]
address CMDbatADDsignalaccum
comment "Return B1 + B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command add_noerror(b1:bat[:oid,:dbl],b2:bat[:oid,:int]) :bat[:oid,:dbl]
address CMDbatADD
comment "Return B1 + B2, overflow causes NIL value";
pattern +(b:bat[:oid,:dbl],v:int) :bat[:oid,:dbl]
address CMDbatADDcstsignal
comment "Return B + V, signal error on overflow";
pattern +(b:bat[:oid,:dbl],v:int,accum:int) :bat[:oid,:dbl]
address CMDbatADDcstsignal
comment "Return B + V, signal error on overflow, reuse B if ACCUM is set";
pattern add_noerror(b:bat[:oid,:dbl],v:int) :bat[:oid,:dbl]
address CMDbatADDcst
comment "Return B + V, overflow causes NIL value";
pattern +(v:dbl,b:bat[:oid,:int]) :bat[:oid,:dbl]
address CMDbatADDcstsignal
comment "Return V + B, signal error on overflow";
pattern add_noerror(v:dbl,b:bat[:oid,:int]) :bat[:oid,:dbl]
address CMDbatADDcst
comment "Return V + B, overflow causes NIL value";

command +(b1:bat[:oid,:dbl],b2:bat[:oid,:wrd]) :bat[:oid,:dbl]
address CMDbatADDsignal
comment "Return B1 + B2, signal error on overflow";
command +(b1:bat[:oid,:dbl],b2:bat[:oid,:wrd],accum:int) :bat[:oid,:dbl]
address CMDbatADDsignalaccum
comment "Return B1 + B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command add_noerror(b1:bat[:oid,:dbl],b2:bat[:oid,:wrd]) :bat[:oid,:dbl]
address CMDbatADD
comment "Return B1 + B2, overflow causes NIL value";
pattern +(b:bat[:oid,:dbl],v:wrd) :bat[:oid,:dbl]
address CMDbatADDcstsignal
comment "Return B + V, signal error on overflow";
pattern +(b:bat[:oid,:dbl],v:wrd,accum:int) :bat[:oid,:dbl]
address CMDbatADDcstsignal
comment "Return B + V, signal error on overflow, reuse B if ACCUM is set";
pattern add_noerror(b:bat[:oid,:dbl],v:wrd) :bat[:oid,:dbl]
address CMDbatADDcst
comment "Return B + V, overflow causes NIL value";
pattern +(v:dbl,b:bat[:oid,:wrd]) :bat[:oid,:dbl]
address CMDbatADDcstsignal
comment "Return V + B, signal error on overflow";
pattern add_noerror(v:dbl,b:bat[:oid,:wrd]) :bat[:oid,:dbl]
address CMDbatADDcst
comment "Return V + B, overflow causes NIL value";

command +(b1:bat[:oid,:dbl],b2:bat[:oid,:lng]) :bat[:oid,:dbl]
address CMDbatADDsignal
comment "Return B1 + B2, signal error on overflow";
command +(b1:bat[:oid,:dbl],b2:bat[:oid,:lng],accum:int) :bat[:oid,:dbl]
address CMDbatADDsignalaccum
comment "Return B1 + B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command add_noerror(b1:bat[:oid,:dbl],b2:bat[:oid,:lng]) :bat[:oid,:dbl]
address CMDbatADD
comment "Return B1 + B2, overflow causes NIL value";
pattern +(b:bat[:oid,:dbl],v:lng) :bat[:oid,:dbl]
address CMDbatADDcstsignal
comment "Return B + V, signal error on overflow";
pattern +(b:bat[:oid,:dbl],v:lng,accum:int) :bat[:oid,:dbl]
address CMDbatADDcstsignal
comment "Return B + V, signal error on overflow, reuse B if ACCUM is set";
pattern add_noerror(b:bat[:oid,:dbl],v:lng) :bat[:oid,:dbl]
address CMDbatADDcst
comment "Return B + V, overflow causes NIL value";
pattern +(v:dbl,b:bat[:oid,:lng]) :bat[:oid,:dbl]
address CMDbatADDcstsignal
comment "Return V + B, signal error on overflow";
pattern add_noerror(v:dbl,b:bat[:oid,:lng]) :bat[:oid,:dbl]
address CMDbatADDcst
comment "Return V + B, overflow causes NIL value";

command +(b1:bat[:oid,:dbl],b2:bat[:oid,:flt]) :bat[:oid,:dbl]
address CMDbatADDsignal
comment "Return B1 + B2, signal error on overflow";
command +(b1:bat[:oid,:dbl],b2:bat[:oid,:flt],accum:int) :bat[:oid,:dbl]
address CMDbatADDsignalaccum
comment "Return B1 + B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command add_noerror(b1:bat[:oid,:dbl],b2:bat[:oid,:flt]) :bat[:oid,:dbl]
address CMDbatADD
comment "Return B1 + B2, overflow causes NIL value";
pattern +(b:bat[:oid,:dbl],v:flt) :bat[:oid,:dbl]
address CMDbatADDcstsignal
comment "Return B + V, signal error on overflow";
pattern +(b:bat[:oid,:dbl],v:flt,accum:int) :bat[:oid,:dbl]
address CMDbatADDcstsignal
comment "Return B + V, signal error on overflow, reuse B if ACCUM is set";
pattern add_noerror(b:bat[:oid,:dbl],v:flt) :bat[:oid,:dbl]
address CMDbatADDcst
comment "Return B + V, overflow causes NIL value";
pattern +(v:dbl,b:bat[:oid,:flt]) :bat[:oid,:dbl]
address CMDbatADDcstsignal
comment "Return V + B, signal error on overflow";
pattern add_noerror(v:dbl,b:bat[:oid,:flt]) :bat[:oid,:dbl]
address CMDbatADDcst
comment "Return V + B, overflow causes NIL value";

command +(b1:bat[:oid,:dbl],b2:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatADDsignal
comment "Return B1 + B2, signal error on overflow";
command +(b1:bat[:oid,:dbl],b2:bat[:oid,:dbl],accum:int) :bat[:oid,:dbl]
address CMDbatADDsignalaccum
comment "Return B1 + B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command add_noerror(b1:bat[:oid,:dbl],b2:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatADD
comment "Return B1 + B2, overflow causes NIL value";
pattern +(b:bat[:oid,:dbl],v:dbl) :bat[:oid,:dbl]
address CMDbatADDcstsignal
comment "Return B + V, signal error on overflow";
pattern +(b:bat[:oid,:dbl],v:dbl,accum:int) :bat[:oid,:dbl]
address CMDbatADDcstsignal
comment "Return B + V, signal error on overflow, reuse B if ACCUM is set";
pattern add_noerror(b:bat[:oid,:dbl],v:dbl) :bat[:oid,:dbl]
address CMDbatADDcst
comment "Return B + V, overflow causes NIL value";
pattern +(v:dbl,b:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatADDcstsignal
comment "Return V + B, signal error on overflow";
pattern +(v:dbl,b:bat[:oid,:dbl],accum:int) :bat[:oid,:dbl]
address CMDbatADDcstsignal
comment "Return V + B, signal error on overflow, reuse B if ACCUM is set";
pattern add_noerror(v:dbl,b:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatADDcst
comment "Return V + B, overflow causes NIL value";


command -(b1:bat[:oid,:bte],b2:bat[:oid,:bte]) :bat[:oid,:bte]
address CMDbatSUBsignal
comment "Return B1 - B2, signal error on overflow";
command -(b1:bat[:oid,:bte],b2:bat[:oid,:bte],accum:int) :bat[:oid,:bte]
address CMDbatSUBsignalaccum
comment "Return B1 - B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command sub_noerror(b1:bat[:oid,:bte],b2:bat[:oid,:bte]) :bat[:oid,:bte]
address CMDbatSUB
comment "Return B1 - B2, overflow causes NIL value";
pattern -(b:bat[:oid,:bte],v:bte) :bat[:oid,:bte]
address CMDbatSUBcstsignal
comment "Return B - V, signal error on overflow";
pattern -(b:bat[:oid,:bte],v:bte,accum:int) :bat[:oid,:bte]
address CMDbatSUBcstsignal
comment "Return B - V, signal error on overflow, reuse B if ACCUM is set";
pattern sub_noerror(b:bat[:oid,:bte],v:bte) :bat[:oid,:bte]
address CMDbatSUBcst
comment "Return B - V, overflow causes NIL value";
pattern -(v:bte,b:bat[:oid,:bte]) :bat[:oid,:bte]
address CMDbatSUBcstsignal
comment "Return V - B, signal error on overflow";
pattern -(v:bte,b:bat[:oid,:bte],accum:int) :bat[:oid,:bte]
address CMDbatSUBcstsignal
comment "Return V - B, signal error on overflow, reuse B if ACCUM is set";
pattern sub_noerror(v:bte,b:bat[:oid,:bte]) :bat[:oid,:bte]
address CMDbatSUBcst
comment "Return V - B, overflow causes NIL value";

command -(b1:bat[:oid,:bte],b2:bat[:oid,:sht]) :bat[:oid,:sht]
address CMDbatSUBsignal
comment "Return B1 - B2, signal error on overflow";
command -(b1:bat[:oid,:bte],b2:bat[:oid,:sht],accum:int) :bat[:oid,:sht]
address CMDbatSUBsignalaccum
comment "Return B1 - B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command sub_noerror(b1:bat[:oid,:bte],b2:bat[:oid,:sht]) :bat[:oid,:sht]
address CMDbatSUB
comment "Return B1 - B2, overflow causes NIL value";
pattern -(b:bat[:oid,:bte],v:sht) :bat[:oid,:sht]
address CMDbatSUBcstsignal
comment "Return B - V, signal error on overflow";
pattern sub_noerror(b:bat[:oid,:bte],v:sht) :bat[:oid,:sht]
address CMDbatSUBcst
comment "Return B - V, overflow causes NIL value";
pattern -(v:bte,b:bat[:oid,:sht]) :bat[:oid,:sht]
address CMDbatSUBcstsignal
comment "Return V - B, signal error on overflow";
pattern -(v:bte,b:bat[:oid,:sht],accum:int) :bat[:oid,:sht]
address CMDbatSUBcstsignal
comment "Return V - B, signal error on overflow, reuse B if ACCUM is set";
pattern sub_noerror(v:bte,b:bat[:oid,:sht]) :bat[:oid,:sht]
address CMDbatSUBcst
comment "Return V - B, overflow causes NIL value";

command -(b1:bat[:oid,:bte],b2:bat[:oid,:int]) :bat[:oid,:int]
address CMDbatSUBsignal
comment "Return B1 - B2, signal error on overflow";
command -(b1:bat[:oid,:bte],b2:bat[:oid,:int],accum:int) :bat[:oid,:int]
address CMDbatSUBsignalaccum
comment "Return B1 - B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command sub_noerror(b1:bat[:oid,:bte],b2:bat[:oid,:int]) :bat[:oid,:int]
address CMDbatSUB
comment "Return B1 - B2, overflow causes NIL value";
pattern -(b:bat[:oid,:bte],v:int) :bat[:oid,:int]
address CMDbatSUBcstsignal
comment "Return B - V, signal error on overflow";
pattern sub_noerror(b:bat[:oid,:bte],v:int) :bat[:oid,:int]
address CMDbatSUBcst
comment "Return B - V, overflow causes NIL value";
pattern -(v:bte,b:bat[:oid,:int]) :bat[:oid,:int]
address CMDbatSUBcstsignal
comment "Return V - B, signal error on overflow";
pattern -(v:bte,b:bat[:oid,:int],accum:int) :bat[:oid,:int]
address CMDbatSUBcstsignal
comment "Return V - B, signal error on overflow, reuse B if ACCUM is set";
pattern sub_noerror(v:bte,b:bat[:oid,:int]) :bat[:oid,:int]
address CMDbatSUBcst
comment "Return V - B, overflow causes NIL value";

command -(b1:bat[:oid,:bte],b2:bat[:oid,:wrd]) :bat[:oid,:wrd]
address CMDbatSUBsignal
comment "Return B1 - B2, signal error on overflow";
command -(b1:bat[:oid,:bte],b2:bat[:oid,:wrd],accum:int) :bat[:oid,:wrd]
address CMDbatSUBsignalaccum
comment "Return B1 - B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command sub_noerror(b1:bat[:oid,:bte],b2:bat[:oid,:wrd]) :bat[:oid,:wrd]
address CMDbatSUB
comment "Return B1 - B2, overflow causes NIL value";
pattern -(b:bat[:oid,:bte],v:wrd) :bat[:oid,:wrd]
address CMDbatSUBcstsignal
comment "Return B - V, signal error on overflow";
pattern sub_noerror(b:bat[:oid,:bte],v:wrd) :bat[:oid,:wrd]
address CMDbatSUBcst
comment "Return B - V, overflow causes NIL value";
pattern -(v:bte,b:bat[:oid,:wrd]) :bat[:oid,:wrd]
address CMDbatSUBcstsignal
comment "Return V - B, signal error on overflow";
pattern -(v:bte,b:bat[:oid,:wrd],accum:int) :bat[:oid,:wrd]
address CMDbatSUBcstsignal
comment "Return V - B, signal error on overflow, reuse B if ACCUM is set";
pattern sub_noerror(v:bte,b:bat[:oid,:wrd]) :bat[:oid,:wrd]
address CMDbatSUBcst
comment "Return V - B, overflow causes NIL value";

command -(b1:bat[:oid,:bte],b2:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatSUBsignal
comment "Return B1 - B2, signal error on overflow";
command -(b1:bat[:oid,:bte],b2:bat[:oid,:lng],accum:int) :bat[:oid,:lng]
address CMDbatSUBsignalaccum
comment "Return B1 - B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command sub_noerror(b1:bat[:oid,:bte],b2:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatSUB
comment "Return B1 - B2, overflow causes NIL value";
pattern -(b:bat[:oid,:bte],v:lng) :bat[:oid,:lng]
address CMDbatSUBcstsignal
comment "Return B - V, signal error on overflow";
pattern sub_noerror(b:bat[:oid,:bte],v:lng) :bat[:oid,:lng]
address CMDbatSUBcst
comment "Return B - V, overflow causes NIL value";
pattern -(v:bte,b:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatSUBcstsignal
comment "Return V - B, signal error on overflow";
pattern -(v:bte,b:bat[:oid,:lng],accum:int) :bat[:oid,:lng]
address CMDbatSUBcstsignal
comment "Return V - B, signal error on overflow, reuse B if ACCUM is set";
pattern sub_noerror(v:bte,b:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatSUBcst
comment "Return V - B, overflow causes NIL value";

command -(b1:bat[:oid,:bte],b2:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatSUBsignal
comment "Return B1 - B2, signal error on overflow";
command -(b1:bat[:oid,:bte],b2:bat[:oid,:flt],accum:int) :bat[:oid,:flt]
address CMDbatSUBsignalaccum
comment "Return B1 - B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command sub_noerror(b1:bat[:oid,:bte],b2:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatSUB
comment "Return B1 - B2, overflow causes NIL value";
pattern -(b:bat[:oid,:bte],v:flt) :bat[:oid,:flt]
address CMDbatSUBcstsignal
comment "Return B - V, signal error on overflow";
pattern sub_noerror(b:bat[:oid,:bte],v:flt) :bat[:oid,:flt]
address CMDbatSUBcst
comment "Return B - V, overflow causes NIL value";
pattern -(v:bte,b:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatSUBcstsignal
comment "Return V - B, signal error on overflow";
pattern -(v:bte,b:bat[:oid,:flt],accum:int) :bat[:oid,:flt]
address CMDbatSUBcstsignal
comment "Return V - B, signal error on overflow, reuse B if ACCUM is set";
pattern sub_noerror(v:bte,b:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatSUBcst
comment "Return V - B, overflow causes NIL value";

command -(b1:bat[:oid,:bte],b2:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatSUBsignal
comment "Return B1 - B2, signal error on overflow";
command -(b1:bat[:oid,:bte],b2:bat[:oid,:dbl],accum:int) :bat[:oid,:dbl]
address CMDbatSUBsignalaccum
comment "Return B1 - B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command sub_noerror(b1:bat[:oid,:bte],b2:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatSUB
comment "Return B1 - B2, overflow causes NIL value";
pattern -(b:bat[:oid,:bte],v:dbl) :bat[:oid,:dbl]
address CMDbatSUBcstsignal
comment "Return B - V, signal error on overflow";
pattern sub_noerror(b:bat[:oid,:bte],v:dbl) :bat[:oid,:dbl]
address CMDbatSUBcst
comment "Return B - V, overflow causes NIL value";
pattern -(v:bte,b:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatSUBcstsignal
comment "Return V - B, signal error on overflow";
pattern -(v:bte,b:bat[:oid,:dbl],accum:int) :bat[:oid,:dbl]
address CMDbatSUBcstsignal
comment "Return V - B, signal error on overflow, reuse B if ACCUM is set";
pattern sub_noerror(v:bte,b:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatSUBcst
comment "Return V - B, overflow causes NIL value";

command -(b1:bat[:oid,:sht],b2:bat[:oid,:bte]) :bat[:oid,:sht]
address CMDbatSUBsignal
comment "Return B1 - B2, signal error on overflow";
command -(b1:bat[:oid,:sht],b2:bat[:oid,:bte],accum:int) :bat[:oid,:sht]
address CMDbatSUBsignalaccum
comment "Return B1 - B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command sub_noerror(b1:bat[:oid,:sht],b2:bat[:oid,:bte]) :bat[:oid,:sht]
address CMDbatSUB
comment "Return B1 - B2, overflow causes NIL value";
pattern -(b:bat[:oid,:sht],v:bte) :bat[:oid,:sht]
address CMDbatSUBcstsignal
comment "Return B - V, signal error on overflow";
pattern -(b:bat[:oid,:sht],v:bte,accum:int) :bat[:oid,:sht]
address CMDbatSUBcstsignal
comment "Return B - V, signal error on overflow, reuse B if ACCUM is set";
pattern sub_noerror(b:bat[:oid,:sht],v:bte) :bat[:oid,:sht]
address CMDbatSUBcst
comment "Return B - V, overflow causes NIL value";
pattern -(v:sht,b:bat[:oid,:bte]) :bat[:oid,:sht]
address CMDbatSUBcstsignal
comment "Return V - B, signal error on overflow";
pattern sub_noerror(v:sht,b:bat[:oid,:bte]) :bat[:oid,:sht]
address CMDbatSUBcst
comment "Return V - B, overflow causes NIL value";

command -(b1:bat[:oid,:sht],b2:bat[:oid,:sht]) :bat[:oid,:sht]
address CMDbatSUBsignal
comment "Return B1 - B2, signal error on overflow";
command -(b1:bat[:oid,:sht],b2:bat[:oid,:sht],accum:int) :bat[:oid,:sht]
address CMDbatSUBsignalaccum
comment "Return B1 - B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command sub_noerror(b1:bat[:oid,:sht],b2:bat[:oid,:sht]) :bat[:oid,:sht]
address CMDbatSUB
comment "Return B1 - B2, overflow causes NIL value";
pattern -(b:bat[:oid,:sht],v:sht) :bat[:oid,:sht]
address CMDbatSUBcstsignal
comment "Return B - V, signal error on overflow";
pattern -(b:bat[:oid,:sht],v:sht,accum:int) :bat[:oid,:sht]
address CMDbatSUBcstsignal
comment "Return B - V, signal error on overflow, reuse B if ACCUM is set";
pattern sub_noerror(b:bat[:oid,:sht],v:sht) :bat[:oid,:sht]
address CMDbatSUBcst
comment "Return B - V, overflow causes NIL value";
pattern -(v:sht,b:bat[:oid,:sht]) :bat[:oid,:sht]
address CMDbatSUBcstsignal
comment "Return V - B, signal error on overflow";
pattern -(v:sht,b:bat[:oid,:sht],accum:int) :bat[:oid,:sht]
address CMDbatSUBcstsignal
comment "Return V - B, signal error on overflow, reuse B if ACCUM is set";
pattern sub_noerror(v:sht,b:bat[:oid,:sht]) :bat[:oid,:sht]
address CMDbatSUBcst
comment "Return V - B, overflow causes NIL value";

command -(b1:bat[:oid,:sht],b2:bat[:oid,:int]) :bat[:oid,:int]
address CMDbatSUBsignal
comment "Return B1 - B2, signal error on overflow";
command -(b1:bat[:oid,:sht],b2:bat[:oid,:int],accum:int) :bat[:oid,:int]
address CMDbatSUBsignalaccum
comment "Return B1 - B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command sub_noerror(b1:bat[:oid,:sht],b2:bat[:oid,:int]) :bat[:oid,:int]
address CMDbatSUB
comment "Return B1 - B2, overflow causes NIL value";
pattern -(b:bat[:oid,:sht],v:int) :bat[:oid,:int]
address CMDbatSUBcstsignal
comment "Return B - V, signal error on overflow";
pattern sub_noerror(b:bat[:oid,:sht],v:int) :bat[:oid,:int]
address CMDbatSUBcst
comment "Return B - V, overflow causes NIL value";
pattern -(v:sht,b:bat[:oid,:int]) :bat[:oid,:int]
address CMDbatSUBcstsignal
comment "Return V - B, signal error on overflow";
pattern -(v:sht,b:bat[:oid,:int],accum:int) :bat[:oid,:int]
address CMDbatSUBcstsignal
comment "Return V - B, signal error on overflow, reuse B if ACCUM is set";
pattern sub_noerror(v:sht,b:bat[:oid,:int]) :bat[:oid,:int]
address CMDbatSUBcst
comment "Return V - B, overflow causes NIL value";

command -(b1:bat[:oid,:sht],b2:bat[:oid,:wrd]) :bat[:oid,:wrd]
address CMDbatSUBsignal
comment "Return B1 - B2, signal error on overflow";
command -(b1:bat[:oid,:sht],b2:bat[:oid,:wrd],accum:int) :bat[:oid,:wrd]
address CMDbatSUBsignalaccum
comment "Return B1 - B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command sub_noerror(b1:bat[:oid,:sht],b2:bat[:oid,:wrd]) :bat[:oid,:wrd]
address CMDbatSUB
comment "Return B1 - B2, overflow causes NIL value";
pattern -(b:bat[:oid,:sht],v:wrd) :bat[:oid,:wrd]
address CMDbatSUBcstsignal
comment "Return B - V, signal error on overflow";
pattern sub_noerror(b:bat[:oid,:sht],v:wrd) :bat[:oid,:wrd]
address CMDbatSUBcst
comment "Return B - V, overflow causes NIL value";
pattern -(v:sht,b:bat[:oid,:wrd]) :bat[:oid,:wrd]
address CMDbatSUBcstsignal
comment "Return V - B, signal error on overflow";
pattern -(v:sht,b:bat[:oid,:wrd],accum:int) :bat[:oid,:wrd]
address CMDbatSUBcstsignal
comment "Return V - B, signal error on overflow, reuse B if ACCUM is set";
pattern sub_noerror(v:sht,b:bat[:oid,:wrd]) :bat[:oid,:wrd]
address CMDbatSUBcst
comment "Return V - B, overflow causes NIL value";

command -(b1:bat[:oid,:sht],b2:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatSUBsignal
comment "Return B1 - B2, signal error on overflow";
command -(b1:bat[:oid,:sht],b2:bat[:oid,:lng],accum:int) :bat[:oid,:lng]
address CMDbatSUBsignalaccum
comment "Return B1 - B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command sub_noerror(b1:bat[:oid,:sht],b2:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatSUB
comment "Return B1 - B2, overflow causes NIL value";
pattern -(b:bat[:oid,:sht],v:lng) :bat[:oid,:lng]
address CMDbatSUBcstsignal
comment "Return B - V, signal error on overflow";
pattern sub_noerror(b:bat[:oid,:sht],v:lng) :bat[:oid,:lng]
address CMDbatSUBcst
comment "Return B - V, overflow causes NIL value";
pattern -(v:sht,b:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatSUBcstsignal
comment "Return V - B, signal error on overflow";
pattern -(v:sht,b:bat[:oid,:lng],accum:int) :bat[:oid,:lng]
address CMDbatSUBcstsignal
comment "Return V - B, signal error on overflow, reuse B if ACCUM is set";
pattern sub_noerror(v:sht,b:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatSUBcst
comment "Return V - B, overflow causes NIL value";

command -(b1:bat[:oid,:sht],b2:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatSUBsignal
comment "Return B1 - B2, signal error on overflow";
command -(b1:bat[:oid,:sht],b2:bat[:oid,:flt],accum:int) :bat[:oid,:flt]
address CMDbatSUBsignalaccum
comment "Return B1 - B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command sub_noerror(b1:bat[:oid,:sht],b2:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatSUB
comment "Return B1 - B2, overflow causes NIL value";
pattern -(b:bat[:oid,:sht],v:flt) :bat[:oid,:flt]
address CMDbatSUBcstsignal
comment "Return B - V, signal error on overflow";
pattern sub_noerror(b:bat[:oid,:sht],v:flt) :bat[:oid,:flt]
address CMDbatSUBcst
comment "Return B - V, overflow causes NIL value";
pattern -(v:sht,b:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatSUBcstsignal
comment "Return V - B, signal error on overflow";
pattern -(v:sht,b:bat[:oid,:flt],accum:int) :bat[:oid,:flt]
address CMDbatSUBcstsignal
comment "Return V - B, signal error on overflow, reuse B if ACCUM is set";
pattern sub_noerror(v:sht,b:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatSUBcst
comment "Return V - B, overflow causes NIL value";

command -(b1:bat[:oid,:sht],b2:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatSUBsignal
comment "Return B1 - B2, signal error on overflow";
command -(b1:bat[:oid,:sht],b2:bat[:oid,:dbl],accum:int) :bat[:oid,:dbl]
address CMDbatSUBsignalaccum
comment "Return B1 - B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command sub_noerror(b1:bat[:oid,:sht],b2:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatSUB
comment "Return B1 - B2, overflow causes NIL value";
pattern -(b:bat[:oid,:sht],v:dbl) :bat[:oid,:dbl]
address CMDbatSUBcstsignal
comment "Return B - V, signal error on overflow";
pattern sub_noerror(b:bat[:oid,:sht],v:dbl) :bat[:oid,:dbl]
address CMDbatSUBcst
comment "Return B - V, overflow causes NIL value";
pattern -(v:sht,b:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatSUBcstsignal
comment "Return V - B, signal error on overflow";
pattern -(v:sht,b:bat[:oid,:dbl],accum:int) :bat[:oid,:dbl]
address CMDbatSUBcstsignal
comment "Return V - B, signal error on overflow, reuse B if ACCUM is set";
pattern sub_noerror(v:sht,b:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatSUBcst
comment "Return V - B, overflow causes NIL value";

command -(b1:bat[:oid,:int],b2:bat[:oid,:bte]) :bat[:oid,:int]
address CMDbatSUBsignal
comment "Return B1 - B2, signal error on overflow";
command -(b1:bat[:oid,:int],b2:bat[:oid,:bte],accum:int) :bat[:oid,:int]
address CMDbatSUBsignalaccum
comment "Return B1 - B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command sub_noerror(b1:bat[:oid,:int],b2:bat[:oid,:bte]) :bat[:oid,:int]
address CMDbatSUB
comment "Return B1 - B2, overflow causes NIL value";
pattern -(b:bat[:oid,:int],v:bte) :bat[:oid,:int]
address CMDbatSUBcstsignal
comment "Return B - V, signal error on overflow";
pattern -(b:bat[:oid,:int],v:bte,accum:int) :bat[:oid,:int]
address CMDbatSUBcstsignal
comment "Return B - V, signal error on overflow, reuse B if ACCUM is set";
pattern sub_noerror(b:bat[:oid,:int],v:bte) :bat[:oid,:int]
address CMDbatSUBcst
comment "Return B - V, overflow causes NIL value";
pattern -(v:int,b:bat[:oid,:bte]) :bat[:oid,:int]
address CMDbatSUBcstsignal
comment "Return V - B, signal error on overflow";
pattern sub_noerror(v:int,b:bat[:oid,:bte]) :bat[:oid,:int]
address CMDbatSUBcst
comment "Return V - B, overflow causes NIL value";

command -(b1:bat[:oid,:int],b2:bat[:oid,:sht]) :bat[:oid,:int]
address CMDbatSUBsignal
comment "Return B1 - B2, signal error on overflow";
command -(b1:bat[:oid,:int],b2:bat[:oid,:sht],accum:int) :bat[:oid,:int]
address CMDbatSUBsignalaccum
comment "Return B1 - B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command sub_noerror(b1:bat[:oid,:int],b2:bat[:oid,:sht]) :bat[:oid,:int]
address CMDbatSUB
comment "Return B1 - B2, overflow causes NIL value";
pattern -(b:bat[:oid,:int],v:sht) :bat[:oid,:int]
address CMDbatSUBcstsignal
comment "Return B - V, signal error on overflow";
pattern -(b:bat[:oid,:int],v:sht,accum:int) :bat[:oid,:int]
address CMDbatSUBcstsignal
comment "Return B - V, signal error on overflow, reuse B if ACCUM is set";
pattern sub_noerror(b:bat[:oid,:int],v:sht) :bat[:oid,:int]
address CMDbatSUBcst
comment "Return B - V, overflow causes NIL value";
pattern -(v:int,b:bat[:oid,:sht]) :bat[:oid,:int]
address CMDbatSUBcstsignal
comment "Return V - B, signal error on overflow";
pattern sub_noerror(v:int,b:bat[:oid,:sht]) :bat[:oid,:int]
address CMDbatSUBcst
comment "Return V - B, overflow causes NIL value";

command -(b1:bat[:oid,:int],b2:bat[:oid,:int]) :bat[:oid,:int]
address CMDbatSUBsignal
comment "Return B1 - B2, signal error on overflow";
command -(b1:bat[:oid,:int],b2:bat[:oid,:int],accum:int) :bat[:oid,:int]
address CMDbatSUBsignalaccum
comment "Return B1 - B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command sub_noerror(b1:bat[:oid,:int],b2:bat[:oid,:int]) :bat[:oid,:int]
address CMDbatSUB
comment "Return B1 - B2, overflow causes NIL value";
pattern -(b:bat[:oid,:int],v:int) :bat[:oid,:int]
address CMDbatSUBcstsignal
comment "Return B - V, signal error on overflow";
pattern -(b:bat[:oid,:int],v:int,accum:int) :bat[:oid,:int]
address CMDbatSUBcstsignal
comment "Return B - V, signal error on overflow, reuse B if ACCUM is set";
pattern sub_noerror(b:bat[:oid,:int],v:int) :bat[:oid,:int]
address CMDbatSUBcst
comment "Return B - V, overflow causes NIL value";
pattern -(v:int,b:bat[:oid,:int]) :bat[:oid,:int]
address CMDbatSUBcstsignal
comment "Return V - B, signal error on overflow";
pattern -(v:int,b:bat[:oid,:int],accum:int) :bat[:oid,:int]
address CMDbatSUBcstsignal
comment "Return V - B, signal error on overflow, reuse B if ACCUM is set";
pattern sub_noerror(v:int,b:bat[:oid,:int]) :bat[:oid,:int]
address CMDbatSUBcst
comment "Return V - B, overflow causes NIL value";

command -(b1:bat[:oid,:int],b2:bat[:oid,:wrd]) :bat[:oid,:wrd]
address CMDbatSUBsignal
comment "Return B1 - B2, signal error on overflow";
command -(b1:bat[:oid,:int],b2:bat[:oid,:wrd],accum:int) :bat[:oid,:wrd]
address CMDbatSUBsignalaccum
comment "Return B1 - B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command sub_noerror(b1:bat[:oid,:int],b2:bat[:oid,:wrd]) :bat[:oid,:wrd]
address CMDbatSUB
comment "Return B1 - B2, overflow causes NIL value";
pattern -(b:bat[:oid,:int],v:wrd) :bat[:oid,:wrd]
address CMDbatSUBcstsignal
comment "Return B - V, signal error on overflow";
pattern sub_noerror(b:bat[:oid,:int],v:wrd) :bat[:oid,:wrd]
address CMDbatSUBcst
comment "Return B - V, overflow causes NIL value";
pattern -(v:int,b:bat[:oid,:wrd]) :bat[:oid,:wrd]
address CMDbatSUBcstsignal
comment "Return V - B, signal error on overflow";
pattern -(v:int,b:bat[:oid,:wrd],accum:int) :bat[:oid,:wrd]
address CMDbatSUBcstsignal
comment "Return V - B, signal error on overflow, reuse B if ACCUM is set";
pattern sub_noerror(v:int,b:bat[:oid,:wrd]) :bat[:oid,:wrd]
address CMDbatSUBcst
comment "Return V - B, overflow causes NIL value";

command -(b1:bat[:oid,:int],b2:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatSUBsignal
comment "Return B1 - B2, signal error on overflow";
command -(b1:bat[:oid,:int],b2:bat[:oid,:lng],accum:int) :bat[:oid,:lng]
address CMDbatSUBsignalaccum
comment "Return B1 - B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command sub_noerror(b1:bat[:oid,:int],b2:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatSUB
comment "Return B1 - B2, overflow causes NIL value";
pattern -(b:bat[:oid,:int],v:lng) :bat[:oid,:lng]
address CMDbatSUBcstsignal
comment "Return B - V, signal error on overflow";
pattern sub_noerror(b:bat[:oid,:int],v:lng) :bat[:oid,:lng]
address CMDbatSUBcst
comment "Return B - V, overflow causes NIL value";
pattern -(v:int,b:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatSUBcstsignal
comment "Return V - B, signal error on overflow";
pattern -(v:int,b:bat[:oid,:lng],accum:int) :bat[:oid,:lng]
address CMDbatSUBcstsignal
comment "Return V - B, signal error on overflow, reuse B if ACCUM is set";
pattern sub_noerror(v:int,b:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatSUBcst
comment "Return V - B, overflow causes NIL value";

command -(b1:bat[:oid,:int],b2:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatSUBsignal
comment "Return B1 - B2, signal error on overflow";
command -(b1:bat[:oid,:int],b2:bat[:oid,:flt],accum:int) :bat[:oid,:flt]
address CMDbatSUBsignalaccum
comment "Return B1 - B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command sub_noerror(b1:bat[:oid,:int],b2:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatSUB
comment "Return B1 - B2, overflow causes NIL value";
pattern -(b:bat[:oid,:int],v:flt) :bat[:oid,:flt]
address CMDbatSUBcstsignal
comment "Return B - V, signal error on overflow";
pattern sub_noerror(b:bat[:oid,:int],v:flt) :bat[:oid,:flt]
address CMDbatSUBcst
comment "Return B - V, overflow causes NIL value";
pattern -(v:int,b:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatSUBcstsignal
comment "Return V - B, signal error on overflow";
pattern -(v:int,b:bat[:oid,:flt],accum:int) :bat[:oid,:flt]
address CMDbatSUBcstsignal
comment "Return V - B, signal error on overflow, reuse B if ACCUM is set";
pattern sub_noerror(v:int,b:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatSUBcst
comment "Return V - B, overflow causes NIL value";

command -(b1:bat[:oid,:int],b2:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatSUBsignal
comment "Return B1 - B2, signal error on overflow";
command -(b1:bat[:oid,:int],b2:bat[:oid,:dbl],accum:int) :bat[:oid,:dbl]
address CMDbatSUBsignalaccum
comment "Return B1 - B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command sub_noerror(b1:bat[:oid,:int],b2:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatSUB
comment "Return B1 - B2, overflow causes NIL value";
pattern -(b:bat[:oid,:int],v:dbl) :bat[:oid,:dbl]
address CMDbatSUBcstsignal
comment "Return B - V, signal error on overflow";
pattern sub_noerror(b:bat[:oid,:int],v:dbl) :bat[:oid,:dbl]
address CMDbatSUBcst
comment "Return B - V, overflow causes NIL value";
pattern -(v:int,b:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatSUBcstsignal
comment "Return V - B, signal error on overflow";
pattern -(v:int,b:bat[:oid,:dbl],accum:int) :bat[:oid,:dbl]
address CMDbatSUBcstsignal
comment "Return V - B, signal error on overflow, reuse B if ACCUM is set";
pattern sub_noerror(v:int,b:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatSUBcst
comment "Return V - B, overflow causes NIL value";

command -(b1:bat[:oid,:wrd],b2:bat[:oid,:bte]) :bat[:oid,:wrd]
address CMDbatSUBsignal
comment "Return B1 - B2, signal error on overflow";
command -(b1:bat[:oid,:wrd],b2:bat[:oid,:bte],accum:int) :bat[:oid,:wrd]
address CMDbatSUBsignalaccum
comment "Return B1 - B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command sub_noerror(b1:bat[:oid,:wrd],b2:bat[:oid,:bte]) :bat[:oid,:wrd]
address CMDbatSUB
comment "Return B1 - B2, overflow causes NIL value";
pattern -(b:bat[:oid,:wrd],v:bte) :bat[:oid,:wrd]
address CMDbatSUBcstsignal
comment "Return B - V, signal error on overflow";
pattern -(b:bat[:oid,:wrd],v:bte,accum:int) :bat[:oid,:wrd]
address CMDbatSUBcstsignal
comment "Return B - V, signal error on overflow, reuse B if ACCUM is set";
pattern sub_noerror(b:bat[:oid,:wrd],v:bte) :bat[:oid,:wrd]
address CMDbatSUBcst
comment "Return B - V, overflow causes NIL value";
pattern -(v:wrd,b:bat[:oid,:bte]) :bat[:oid,:wrd]
address CMDbatSUBcstsignal
comment "Return V - B, signal error on overflow";
pattern sub_noerror(v:wrd,b:bat[:oid,:bte]) :bat[:oid,:wrd]
address CMDbatSUBcst
comment "Return V - B, overflow causes NIL value";

command -(b1:bat[:oid,:wrd],b2:bat[:oid,:sht]) :bat[:oid,:wrd]
address CMDbatSUBsignal
comment "Return B1 - B2, signal error on overflow";
command -(b1:bat[:oid,:wrd],b2:bat[:oid,:sht],accum:int) :bat[:oid,:wrd]
address CMDbatSUBsignalaccum
comment "Return B1 - B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command sub_noerror(b1:bat[:oid,:wrd],b2:bat[:oid,:sht]) :bat[:oid,:wrd]
address CMDbatSUB
comment "Return B1 - B2, overflow causes NIL value";
pattern -(b:bat[:oid,:wrd],v:sht) :bat[:oid,:wrd]
address CMDbatSUBcstsignal
comment "Return B - V, signal error on overflow";
pattern -(b:bat[:oid,:wrd],v:sht,accum:int) :bat[:oid,:wrd]
address CMDbatSUBcstsignal
comment "Return B - V, signal error on overflow, reuse B if ACCUM is set";
pattern sub_noerror(b:bat[:oid,:wrd],v:sht) :bat[:oid,:wrd]
address CMDbatSUBcst
comment "Return B - V, overflow causes NIL value";
pattern -(v:wrd,b:bat[:oid,:sht]) :bat[:oid,:wrd]
address CMDbatSUBcstsignal
comment "Return V - B, signal error on overflow";
pattern sub_noerror(v:wrd,b:bat[:oid,:sht]) :bat[:oid,:wrd]
address CMDbatSUBcst
comment "Return V - B, overflow causes NIL value";

command -(b1:bat[:oid,:wrd],b2:bat[:oid,:int]) :bat[:oid,:wrd]
address CMDbatSUBsignal
comment "Return B1 - B2, signal error on overflow";
command -(b1:bat[:oid,:wrd],b2:bat[:oid,:int],accum:int) :bat[:oid,:wrd]
address CMDbatSUBsignalaccum
comment "Return B1 - B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command sub_noerror(b1:bat[:oid,:wrd],b2:bat[:oid,:int]) :bat[:oid,:wrd]
address CMDbatSUB
comment "Return B1 - B2, overflow causes NIL value";
pattern -(b:bat[:oid,:wrd],v:int) :bat[:oid,:wrd]
address CMDbatSUBcstsignal
comment "Return B - V, signal error on overflow";
pattern -(b:bat[:oid,:wrd],v:int,accum:int) :bat[:oid,:wrd]
address CMDbatSUBcstsignal
comment "Return B - V, signal error on overflow, reuse B if ACCUM is set";
pattern sub_noerror(b:bat[:oid,:wrd],v:int) :bat[:oid,:wrd]
address CMDbatSUBcst
comment "Return B - V, overflow causes NIL value";
pattern -(v:wrd,b:bat[:oid,:int]) :bat[:oid,:wrd]
address CMDbatSUBcstsignal
comment "Return V - B, signal error on overflow";
pattern sub_noerror(v:wrd,b:bat[:oid,:int]) :bat[:oid,:wrd]
address CMDbatSUBcst
comment "Return V - B, overflow causes NIL value";

command -(b1:bat[:oid,:wrd],b2:bat[:oid,:wrd]) :bat[:oid,:wrd]
address CMDbatSUBsignal
comment "Return B1 - B2, signal error on overflow";
command -(b1:bat[:oid,:wrd],b2:bat[:oid,:wrd],accum:int) :bat[:oid,:wrd]
address CMDbatSUBsignalaccum
comment "Return B1 - B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command sub_noerror(b1:bat[:oid,:wrd],b2:bat[:oid,:wrd]) :bat[:oid,:wrd]
address CMDbatSUB
comment "Return B1 - B2, overflow causes NIL value";
pattern -(b:bat[:oid,:wrd],v:wrd) :bat[:oid,:wrd]
address CMDbatSUBcstsignal
comment "Return B - V, signal error on overflow";
pattern -(b:bat[:oid,:wrd],v:wrd,accum:int) :bat[:oid,:wrd]
address CMDbatSUBcstsignal
comment "Return B - V, signal error on overflow, reuse B if ACCUM is set";
pattern sub_noerror(b:bat[:oid,:wrd],v:wrd) :bat[:oid,:wrd]
address CMDbatSUBcst
comment "Return B - V, overflow causes NIL value";
pattern -(v:wrd,b:bat[:oid,:wrd]) :bat[:oid,:wrd]
address CMDbatSUBcstsignal
comment "Return V - B, signal error on overflow";
pattern -(v:wrd,b:bat[:oid,:wrd],accum:int) :bat[:oid,:wrd]
address CMDbatSUBcstsignal
comment "Return V - B, signal error on overflow, reuse B if ACCUM is set";
pattern sub_noerror(v:wrd,b:bat[:oid,:wrd]) :bat[:oid,:wrd]
address CMDbatSUBcst
comment "Return V - B, overflow causes NIL value";

command -(b1:bat[:oid,:wrd],b2:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatSUBsignal
comment "Return B1 - B2, signal error on overflow";
command -(b1:bat[:oid,:wrd],b2:bat[:oid,:lng],accum:int) :bat[:oid,:lng]
address CMDbatSUBsignalaccum
comment "Return B1 - B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command sub_noerror(b1:bat[:oid,:wrd],b2:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatSUB
comment "Return B1 - B2, overflow causes NIL value";
pattern -(b:bat[:oid,:wrd],v:lng) :bat[:oid,:lng]
address CMDbatSUBcstsignal
comment "Return B - V, signal error on overflow";
pattern sub_noerror(b:bat[:oid,:wrd],v:lng) :bat[:oid,:lng]
address CMDbatSUBcst
comment "Return B - V, overflow causes NIL value";
pattern -(v:wrd,b:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatSUBcstsignal
comment "Return V - B, signal error on overflow";
pattern -(v:wrd,b:bat[:oid,:lng],accum:int) :bat[:oid,:lng]
address CMDbatSUBcstsignal
comment "Return V - B, signal error on overflow, reuse B if ACCUM is set";
pattern sub_noerror(v:wrd,b:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatSUBcst
comment "Return V - B, overflow causes NIL value";

command -(b1:bat[:oid,:wrd],b2:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatSUBsignal
comment "Return B1 - B2, signal error on overflow";
command -(b1:bat[:oid,:wrd],b2:bat[:oid,:flt],accum:int) :bat[:oid,:flt]
address CMDbatSUBsignalaccum
comment "Return B1 - B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command sub_noerror(b1:bat[:oid,:wrd],b2:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatSUB
comment "Return B1 - B2, overflow causes NIL value";
pattern -(b:bat[:oid,:wrd],v:flt) :bat[:oid,:flt]
address CMDbatSUBcstsignal
comment "Return B - V, signal error on overflow";
pattern sub_noerror(b:bat[:oid,:wrd],v:flt) :bat[:oid,:flt]
address CMDbatSUBcst
comment "Return B - V, overflow causes NIL value";
pattern -(v:wrd,b:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatSUBcstsignal
comment "Return V - B, signal error on overflow";
pattern -(v:wrd,b:bat[:oid,:flt],accum:int) :bat[:oid,:flt]
address CMDbatSUBcstsignal
comment "Return V - B, signal error on overflow, reuse B if ACCUM is set";
pattern sub_noerror(v:wrd,b:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatSUBcst
comment "Return V - B, overflow causes NIL value";

command -(b1:bat[:oid,:wrd],b2:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatSUBsignal
comment "Return B1 - B2, signal error on overflow";
command -(b1:bat[:oid,:wrd],b2:bat[:oid,:dbl],accum:int) :bat[:oid,:dbl]
address CMDbatSUBsignalaccum
comment "Return B1 - B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command sub_noerror(b1:bat[:oid,:wrd],b2:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatSUB
comment "Return B1 - B2, overflow causes NIL value";
pattern -(b:bat[:oid,:wrd],v:dbl) :bat[:oid,:dbl]
address CMDbatSUBcstsignal
comment "Return B - V, signal error on overflow";
pattern sub_noerror(b:bat[:oid,:wrd],v:dbl) :bat[:oid,:dbl]
address CMDbatSUBcst
comment "Return B - V, overflow causes NIL value";
pattern -(v:wrd,b:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatSUBcstsignal
comment "Return V - B, signal error on overflow";
pattern -(v:wrd,b:bat[:oid,:dbl],accum:int) :bat[:oid,:dbl]
address CMDbatSUBcstsignal
comment "Return V - B, signal error on overflow, reuse B if ACCUM is set";
pattern sub_noerror(v:wrd,b:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatSUBcst
comment "Return V - B, overflow causes NIL value";

command -(b1:bat[:oid,:lng],b2:bat[:oid,:bte]) :bat[:oid,:lng]
address CMDbatSUBsignal
comment "Return B1 - B2, signal error on overflow";
command -(b1:bat[:oid,:lng],b2:bat[:oid,:bte],accum:int) :bat[:oid,:lng]
address CMDbatSUBsignalaccum
comment "Return B1 - B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command sub_noerror(b1:bat[:oid,:lng],b2:bat[:oid,:bte]) :bat[:oid,:lng]
address CMDbatSUB
comment "Return B1 - B2, overflow causes NIL value";
pattern -(b:bat[:oid,:lng],v:bte) :bat[:oid,:lng]
address CMDbatSUBcstsignal
comment "Return B - V, signal error on overflow";
pattern -(b:bat[:oid,:lng],v:bte,accum:int) :bat[:oid,:lng]
address CMDbatSUBcstsignal
comment "Return B - V, signal error on overflow, reuse B if ACCUM is set";
pattern sub_noerror(b:bat[:oid,:lng],v:bte) :bat[:oid,:lng]
address CMDbatSUBcst
comment "Return B - V, overflow causes NIL value";
pattern -(v:lng,b:bat[:oid,:bte]) :bat[:oid,:lng]
address CMDbatSUBcstsignal
comment "Return V - B, signal error on overflow";
pattern sub_noerror(v:lng,b:bat[:oid,:bte]) :bat[:oid,:lng]
address CMDbatSUBcst
comment "Return V - B, overflow causes NIL value";

command -(b1:bat[:oid,:lng],b2:bat[:oid,:sht]) :bat[:oid,:lng]
address CMDbatSUBsignal
comment "Return B1 - B2, signal error on overflow";
command -(b1:bat[:oid,:lng],b2:bat[:oid,:sht],accum:int) :bat[:oid,:lng]
address CMDbatSUBsignalaccum
comment "Return B1 - B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command sub_noerror(b1:bat[:oid,:lng],b2:bat[:oid,:sht]) :bat[:oid,:lng]
address CMDbatSUB
comment "Return B1 - B2, overflow causes NIL value";
pattern -(b:bat[:oid,:lng],v:sht) :bat[:oid,:lng]
address CMDbatSUBcstsignal
comment "Return B - V, signal error on overflow";
pattern -(b:bat[:oid,:lng],v:sht,accum:int) :bat[:oid,:lng]
address CMDbatSUBcstsignal
comment "Return B - V, signal error on overflow, reuse B if ACCUM is set";
pattern sub_noerror(b:bat[:oid,:lng],v:sht) :bat[:oid,:lng]
address CMDbatSUBcst
comment "Return B - V, overflow causes NIL value";
pattern -(v:lng,b:bat[:oid,:sht]) :bat[:oid,:lng]
address CMDbatSUBcstsignal
comment "Return V - B, signal error on overflow";
pattern sub_noerror(v:lng,b:bat[:oid,:sht]) :bat[:oid,:lng]
address CMDbatSUBcst
comment "Return V - B, overflow causes NIL value";

command -(b1:bat[:oid,:lng],b2:bat[:oid,:int]) :bat[:oid,:lng]
address CMDbatSUBsignal
comment "Return B1 - B2, signal error on overflow";
command -(b1:bat[:oid,:lng],b2:bat[:oid,:int],accum:int) :bat[:oid,:lng]
address CMDbatSUBsignalaccum
comment "Return B1 - B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command sub_noerror(b1:bat[:oid,:lng],b2:bat[:oid,:int]) :bat[:oid,:lng]
address CMDbatSUB
comment "Return B1 - B2, overflow causes NIL value";
pattern -(b:bat[:oid,:lng],v:int) :bat[:oid,:lng]
address CMDbatSUBcstsignal
comment "Return B - V, signal error on overflow";
pattern -(b:bat[:oid,:lng],v:int,accum:int) :bat[:oid,:lng]
address CMDbatSUBcstsignal
comment "Return B - V, signal error on overflow, reuse B if ACCUM is set";
pattern sub_noerror(b:bat[:oid,:lng],v:int) :bat[:oid,:lng]
address CMDbatSUBcst
comment "Return B - V, overflow causes NIL value";
pattern -(v:lng,b:bat[:oid,:int]) :bat[:oid,:lng]
address CMDbatSUBcstsignal
comment "Return V - B, signal error on overflow";
pattern sub_noerror(v:lng,b:bat[:oid,:int]) :bat[:oid,:lng]
address CMDbatSUBcst
comment "Return V - B, overflow causes NIL value";

command -(b1:bat[:oid,:lng],b2:bat[:oid,:wrd]) :bat[:oid,:lng]
address CMDbatSUBsignal
comment "Return B1 - B2, signal error on overflow";
command -(b1:bat[:oid,:lng],b2:bat[:oid,:wrd],accum:int) :bat[:oid,:lng]
address CMDbatSUBsignalaccum
comment "Return B1 - B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command sub_noerror(b1:bat[:oid,:lng],b2:bat[:oid,:wrd]) :bat[:oid,:lng]
address CMDbatSUB
comment "Return B1 - B2, overflow causes NIL value";
pattern -(b:bat[:oid,:lng],v:wrd) :bat[:oid,:lng]
address CMDbatSUBcstsignal
comment "Return B - V, signal error on overflow";
pattern -(b:bat[:oid,:lng],v:wrd,accum:int) :bat[:oid,:lng]
address CMDbatSUBcstsignal
comment "Return B - V, signal error on overflow, reuse B if ACCUM is set";
pattern sub_noerror(b:bat[:oid,:lng],v:wrd) :bat[:oid,:lng]
address CMDbatSUBcst
comment "Return B - V, overflow causes NIL value";
pattern -(v:lng,b:bat[:oid,:wrd]) :bat[:oid,:lng]
address CMDbatSUBcstsignal
comment "Return V - B, signal error on overflow";
pattern sub_noerror(v:lng,b:bat[:oid,:wrd]) :bat[:oid,:lng]
address CMDbatSUBcst
comment "Return V - B, overflow causes NIL value";

command -(b1:bat[:oid,:lng],b2:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatSUBsignal
comment "Return B1 - B2, signal error on overflow";
command -(b1:bat[:oid,:lng],b2:bat[:oid,:lng],accum:int) :bat[:oid,:lng]
address CMDbatSUBsignalaccum
comment "Return B1 - B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command sub_noerror(b1:bat[:oid,:lng],b2:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatSUB
comment "Return B1 - B2, overflow causes NIL value";
pattern -(b:bat[:oid,:lng],v:lng) :bat[:oid,:lng]
address CMDbatSUBcstsignal
comment "Return B - V, signal error on overflow";
pattern -(b:bat[:oid,:lng],v:lng,accum:int) :bat[:oid,:lng]
address CMDbatSUBcstsignal
comment "Return B - V, signal error on overflow, reuse B if ACCUM is set";
pattern sub_noerror(b:bat[:oid,:lng],v:lng) :bat[:oid,:lng]
address CMDbatSUBcst
comment "Return B - V, overflow causes NIL value";
pattern -(v:lng,b:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatSUBcstsignal
comment "Return V - B, signal error on overflow";
pattern -(v:lng,b:bat[:oid,:lng],accum:int) :bat[:oid,:lng]
address CMDbatSUBcstsignal
comment "Return V - B, signal error on overflow, reuse B if ACCUM is set";
pattern sub_noerror(v:lng,b:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatSUBcst
comment "Return V - B, overflow causes NIL value";

command -(b1:bat[:oid,:lng],b2:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatSUBsignal
comment "Return B1 - B2, signal error on overflow";
command -(b1:bat[:oid,:lng],b2:bat[:oid,:flt],accum:int) :bat[:oid,:flt]
address CMDbatSUBsignalaccum
comment "Return B1 - B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command sub_noerror(b1:bat[:oid,:lng],b2:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatSUB
comment "Return B1 - B2, overflow causes NIL value";
pattern -(b:bat[:oid,:lng],v:flt) :bat[:oid,:flt]
address CMDbatSUBcstsignal
comment "Return B - V, signal error on overflow";
pattern sub_noerror(b:bat[:oid,:lng],v:flt) :bat[:oid,:flt]
address CMDbatSUBcst
comment "Return B - V, overflow causes NIL value";
pattern -(v:lng,b:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatSUBcstsignal
comment "Return V - B, signal error on overflow";
pattern -(v:lng,b:bat[:oid,:flt],accum:int) :bat[:oid,:flt]
address CMDbatSUBcstsignal
comment "Return V - B, signal error on overflow, reuse B if ACCUM is set";
pattern sub_noerror(v:lng,b:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatSUBcst
comment "Return V - B, overflow causes NIL value";

command -(b1:bat[:oid,:lng],b2:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatSUBsignal
comment "Return B1 - B2, signal error on overflow";
command -(b1:bat[:oid,:lng],b2:bat[:oid,:dbl],accum:int) :bat[:oid,:dbl]
address CMDbatSUBsignalaccum
comment "Return B1 - B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command sub_noerror(b1:bat[:oid,:lng],b2:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatSUB
comment "Return B1 - B2, overflow causes NIL value";
pattern -(b:bat[:oid,:lng],v:dbl) :bat[:oid,:dbl]
address CMDbatSUBcstsignal
comment "Return B - V, signal error on overflow";
pattern sub_noerror(b:bat[:oid,:lng],v:dbl) :bat[:oid,:dbl]
address CMDbatSUBcst
comment "Return B - V, overflow causes NIL value";
pattern -(v:lng,b:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatSUBcstsignal
comment "Return V - B, signal error on overflow";
pattern -(v:lng,b:bat[:oid,:dbl],accum:int) :bat[:oid,:dbl]
address CMDbatSUBcstsignal
comment "Return V - B, signal error on overflow, reuse B if ACCUM is set";
pattern sub_noerror(v:lng,b:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatSUBcst
comment "Return V - B, overflow causes NIL value";

command -(b1:bat[:oid,:flt],b2:bat[:oid,:bte]) :bat[:oid,:flt]
address CMDbatSUBsignal
comment "Return B1 - B2, signal error on overflow";
command -(b1:bat[:oid,:flt],b2:bat[:oid,:bte],accum:int) :bat[:oid,:flt]
address CMDbatSUBsignalaccum
comment "Return B1 - B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command sub_noerror(b1:bat[:oid,:flt],b2:bat[:oid,:bte]) :bat[:oid,:flt]
address CMDbatSUB
comment "Return B1 - B2, overflow causes NIL value";
pattern -(b:bat[:oid,:flt],v:bte) :bat[:oid,:flt]
address CMDbatSUBcstsignal
comment "Return B - V, signal error on overflow";
pattern -(b:bat[:oid,:flt],v:bte,accum:int) :bat[:oid,:flt]
address CMDbatSUBcstsignal
comment "Return B - V, signal error on overflow, reuse B if ACCUM is set";
pattern sub_noerror(b:bat[:oid,:flt],v:bte) :bat[:oid,:flt]
address CMDbatSUBcst
comment "Return B - V, overflow causes NIL value";
pattern -(v:flt,b:bat[:oid,:bte]) :bat[:oid,:flt]
address CMDbatSUBcstsignal
comment "Return V - B, signal error on overflow";
pattern sub_noerror(v:flt,b:bat[:oid,:bte]) :bat[:oid,:flt]
address CMDbatSUBcst
comment "Return V - B, overflow causes NIL value";

command -(b1:bat[:oid,:flt],b2:bat[:oid,:sht]) :bat[:oid,:flt]
address CMDbatSUBsignal
comment "Return B1 - B2, signal error on overflow";
command -(b1:bat[:oid,:flt],b2:bat[:oid,:sht],accum:int) :bat[:oid,:flt]
address CMDbatSUBsignalaccum
comment "Return B1 - B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command sub_noerror(b1:bat[:oid,:flt],b2:bat[:oid,:sht]) :bat[:oid,:flt]
address CMDbatSUB
comment "Return B1 - B2, overflow causes NIL value";
pattern -(b:bat[:oid,:flt],v:sht) :bat[:oid,:flt]
address CMDbatSUBcstsignal
comment "Return B - V, signal error on overflow";
pattern -(b:bat[:oid,:flt],v:sht,accum:int) :bat[:oid,:flt]
address CMDbatSUBcstsignal
comment "Return B - V, signal error on overflow, reuse B if ACCUM is set";
pattern sub_noerror(b:bat[:oid,:flt],v:sht) :bat[:oid,:flt]
address CMDbatSUBcst
comment "Return B - V, overflow causes NIL value";
pattern -(v:flt,b:bat[:oid,:sht]) :bat[:oid,:flt]
address CMDbatSUBcstsignal
comment "Return V - B, signal error on overflow";
pattern sub_noerror(v:flt,b:bat[:oid,:sht]) :bat[:oid,:flt]
address CMDbatSUBcst
comment "Return V - B, overflow causes NIL value";

command -(b1:bat[:oid,:flt],b2:bat[:oid,:int]) :bat[:oid,:flt]
address CMDbatSUBsignal
comment "Return B1 - B2, signal error on overflow";
command -(b1:bat[:oid,:flt],b2:bat[:oid,:int],accum:int) :bat[:oid,:flt]
address CMDbatSUBsignalaccum
comment "Return B1 - B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command sub_noerror(b1:bat[:oid,:flt],b2:bat[:oid,:int]) :bat[:oid,:flt]
address CMDbatSUB
comment "Return B1 - B2, overflow causes NIL value";
pattern -(b:bat[:oid,:flt],v:int) :bat[:oid,:flt]
address CMDbatSUBcstsignal
comment "Return B - V, signal error on overflow";
pattern -(b:bat[:oid,:flt],v:int,accum:int) :bat[:oid,:flt]
address CMDbatSUBcstsignal
comment "Return B - V, signal error on overflow, reuse B if ACCUM is set";
pattern sub_noerror(b:bat[:oid,:flt],v:int) :bat[:oid,:flt]
address CMDbatSUBcst
comment "Return B - V, overflow causes NIL value";
pattern -(v:flt,b:bat[:oid,:int]) :bat[:oid,:flt]
address CMDbatSUBcstsignal
comment "Return V - B, signal error on overflow";
pattern sub_noerror(v:flt,b:bat[:oid,:int]) :bat[:oid,:flt]
address CMDbatSUBcst
comment "Return V - B, overflow causes NIL value";

command -(b1:bat[:oid,:flt],b2:bat[:oid,:wrd]) :bat[:oid,:flt]
address CMDbatSUBsignal
comment "Return B1 - B2, signal error on overflow";
command -(b1:bat[:oid,:flt],b2:bat[:oid,:wrd],accum:int) :bat[:oid,:flt]
address CMDbatSUBsignalaccum
comment "Return B1 - B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command sub_noerror(b1:bat[:oid,:flt],b2:bat[:oid,:wrd]) :bat[:oid,:flt]
address CMDbatSUB
comment "Return B1 - B2, overflow causes NIL value";
pattern -(b:bat[:oid,:flt],v:wrd) :bat[:oid,:flt]
address CMDbatSUBcstsignal
comment "Return B - V, signal error on overflow";
pattern -(b:bat[:oid,:flt],v:wrd,accum:int) :bat[:oid,:flt]
address CMDbatSUBcstsignal
comment "Return B - V, signal error on overflow, reuse B if ACCUM is set";
pattern sub_noerror(b:bat[:oid,:flt],v:wrd) :bat[:oid,:flt]
address CMDbatSUBcst
comment "Return B - V, overflow causes NIL value";
pattern -(v:flt,b:bat[:oid,:wrd]) :bat[:oid,:flt]
address CMDbatSUBcstsignal
comment "Return V - B, signal error on overflow";
pattern sub_noerror(v:flt,b:bat[:oid,:wrd]) :bat[:oid,:flt]
address CMDbatSUBcst
comment "Return V - B, overflow causes NIL value";

command -(b1:bat[:oid,:flt],b2:bat[:oid,:lng]) :bat[:oid,:flt]
address CMDbatSUBsignal
comment "Return B1 - B2, signal error on overflow";
command -(b1:bat[:oid,:flt],b2:bat[:oid,:lng],accum:int) :bat[:oid,:flt]
address CMDbatSUBsignalaccum
comment "Return B1 - B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command sub_noerror(b1:bat[:oid,:flt],b2:bat[:oid,:lng]) :bat[:oid,:flt]
address CMDbatSUB
comment "Return B1 - B2, overflow causes NIL value";
pattern -(b:bat[:oid,:flt],v:lng) :bat[:oid,:flt]
address CMDbatSUBcstsignal
comment "Return B - V, signal error on overflow";
pattern -(b:bat[:oid,:flt],v:lng,accum:int) :bat[:oid,:flt]
address CMDbatSUBcstsignal
comment "Return B - V, signal error on overflow, reuse B if ACCUM is set";
pattern sub_noerror(b:bat[:oid,:flt],v:lng) :bat[:oid,:flt]
address CMDbatSUBcst
comment "Return B - V, overflow causes NIL value";
pattern -(v:flt,b:bat[:oid,:lng]) :bat[:oid,:flt]
address CMDbatSUBcstsignal
comment "Return V - B, signal error on overflow";
pattern sub_noerror(v:flt,b:bat[:oid,:lng]) :bat[:oid,:flt]
address CMDbatSUBcst
comment "Return V - B, overflow causes NIL value";

command -(b1:bat[:oid,:flt],b2:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatSUBsignal
comment "Return B1 - B2, signal error on overflow";
command -(b1:bat[:oid,:flt],b2:bat[:oid,:flt],accum:int) :bat[:oid,:flt]
address CMDbatSUBsignalaccum
comment "Return B1 - B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command sub_noerror(b1:bat[:oid,:flt],b2:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatSUB
comment "Return B1 - B2, overflow causes NIL value";
pattern -(b:bat[:oid,:flt],v:flt) :bat[:oid,:flt]
address CMDbatSUBcstsignal
comment "Return B - V, signal error on overflow";
pattern -(b:bat[:oid,:flt],v:flt,accum:int) :bat[:oid,:flt]
address CMDbatSUBcstsignal
comment "Return B - V, signal error on overflow, reuse B if ACCUM is set";
pattern sub_noerror(b:bat[:oid,:flt],v:flt) :bat[:oid,:flt]
address CMDbatSUBcst
comment "Return B - V, overflow causes NIL value";
pattern -(v:flt,b:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatSUBcstsignal
comment "Return V - B, signal error on overflow";
pattern -(v:flt,b:bat[:oid,:flt],accum:int) :bat[:oid,:flt]
address CMDbatSUBcstsignal
comment "Return V - B, signal error on overflow, reuse B if ACCUM is set";
pattern sub_noerror(v:flt,b:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatSUBcst
comment "Return V - B, overflow causes NIL value";

command -(b1:bat[:oid,:flt],b2:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatSUBsignal
comment "Return B1 - B2, signal error on overflow";
command -(b1:bat[:oid,:flt],b2:bat[:oid,:dbl],accum:int) :bat[:oid,:dbl]
address CMDbatSUBsignalaccum
comment "Return B1 - B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command sub_noerror(b1:bat[:oid,:flt],b2:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatSUB
comment "Return B1 - B2, overflow causes NIL value";
pattern -(b:bat[:oid,:flt],v:dbl) :bat[:oid,:dbl]
address CMDbatSUBcstsignal
comment "Return B - V, signal error on overflow";
pattern sub_noerror(b:bat[:oid,:flt],v:dbl) :bat[:oid,:dbl]
address CMDbatSUBcst
comment "Return B - V, overflow causes NIL value";
pattern -(v:flt,b:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatSUBcstsignal
comment "Return V - B, signal error on overflow";
pattern -(v:flt,b:bat[:oid,:dbl],accum:int) :bat[:oid,:dbl]
address CMDbatSUBcstsignal
comment "Return V - B, signal error on overflow, reuse B if ACCUM is set";
pattern sub_noerror(v:flt,b:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatSUBcst
comment "Return V - B, overflow causes NIL value";

command -(b1:bat[:oid,:dbl],b2:bat[:oid,:bte]) :bat[:oid,:dbl]
address CMDbatSUBsignal
comment "Return B1 - B2, signal error on overflow";
command -(b1:bat[:oid,:dbl],b2:bat[:oid,:bte],accum:int) :bat[:oid,:dbl]
address CMDbatSUBsignalaccum
comment "Return B1 - B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command sub_noerror(b1:bat[:oid,:dbl],b2:bat[:oid,:bte]) :bat[:oid,:dbl]
address CMDbatSUB
comment "Return B1 - B2, overflow causes NIL value";
pattern -(b:bat[:oid,:dbl],v:bte) :bat[:oid,:dbl]
address CMDbatSUBcstsignal
comment "Return B - V, signal error on overflow";
pattern -(b:bat[:oid,:dbl],v:bte,accum:int) :bat[:oid,:dbl]
address CMDbatSUBcstsignal
comment "Return B - V, signal error on overflow, reuse B if ACCUM is set";
pattern sub_noerror(b:bat[:oid,:dbl],v:bte) :bat[:oid,:dbl]
address CMDbatSUBcst
comment "Return B - V, overflow causes NIL value";
pattern -(v:dbl,b:bat[:oid,:bte]) :bat[:oid,:dbl]
address CMDbatSUBcstsignal
comment "Return V - B, signal error on overflow";
pattern sub_noerror(v:dbl,b:bat[:oid,:bte]) :bat[:oid,:dbl]
address CMDbatSUBcst
comment "Return V - B, overflow causes NIL value";

command -(b1:bat[:oid,:dbl],b2:bat[:oid,:sht]) :bat[:oid,:dbl]
address CMDbatSUBsignal
comment "Return B1 - B2, signal error on overflow";
command -(b1:bat[:oid,:dbl],b2:bat[:oid,:sht],accum:int) :bat[:oid,:dbl]
address CMDbatSUBsignalaccum
comment "Return B1 - B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command sub_noerror(b1:bat[:oid,:dbl],b2:bat[:oid,:sht]) :bat[:oid,:dbl]
address CMDbatSUB
comment "Return B1 - B2, overflow causes NIL value";
pattern -(b:bat[:oid,:dbl],v:sht) :bat[:oid,:dbl]
address CMDbatSUBcstsignal
comment "Return B - V, signal error on overflow";
pattern -(b:bat[:oid,:dbl],v:sht,accum:int) :bat[:oid,:dbl]
address CMDbatSUBcstsignal
comment "Return B - V, signal error on overflow, reuse B if ACCUM is set";
pattern sub_noerror(b:bat[:oid,:dbl],v:sht) :bat[:oid,:dbl]
address CMDbatSUBcst
comment "Return B - V, overflow causes NIL value";
pattern -(v:dbl,b:bat[:oid,:sht]) :bat[:oid,:dbl]
address CMDbatSUBcstsignal
comment "Return V - B, signal error on overflow";
pattern sub_noerror(v:dbl,b:bat[:oid,:sht]) :bat[:oid,:dbl]
address CMDbatSUBcst
comment "Return V - B, overflow causes NIL value";

command -(b1:bat[:oid,:dbl],b2:bat[:oid,:int]) :bat[:oid,:dbl]
address CMDbatSUBsignal
comment "Return B1 - B2, signal error on overflow";
command -(b1:bat[:oid,:dbl],b2:bat[:oid,:int],accum:int) :bat[:oid,:dbl]
address CMDbatSUBsignalaccum
comment "Return B1 - B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command sub_noerror(b1:bat[:oid,:dbl],b2:bat[:oid,:int]) :bat[:oid,:dbl]
address CMDbatSUB
comment "Return B1 - B2, overflow causes NIL value";
pattern -(b:bat[:oid,:dbl],v:int) :bat[:oid,:dbl]
address CMDbatSUBcstsignal
comment "Return B - V, signal error on overflow";
pattern -(b:bat[:oid,:dbl],v:int,accum:int) :bat[:oid,:dbl]
address CMDbatSUBcstsignal
comment "Return B - V, signal error on overflow, reuse B if ACCUM is set";
pattern sub_noerror(b:bat[:oid,:dbl],v:int) :bat[:oid,:dbl]
address CMDbatSUBcst
comment "Return B - V, overflow causes NIL value";
pattern -(v:dbl,b:bat[:oid,:int]) :bat[:oid,:dbl]
address CMDbatSUBcstsignal
comment "Return V - B, signal error on overflow";
pattern sub_noerror(v:dbl,b:bat[:oid,:int]) :bat[:oid,:dbl]
address CMDbatSUBcst
comment "Return V - B, overflow causes NIL value";

command -(b1:bat[:oid,:dbl],b2:bat[:oid,:wrd]) :bat[:oid,:dbl]
address CMDbatSUBsignal
comment "Return B1 - B2, signal error on overflow";
command -(b1:bat[:oid,:dbl],b2:bat[:oid,:wrd],accum:int) :bat[:oid,:dbl]
address CMDbatSUBsignalaccum
comment "Return B1 - B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command sub_noerror(b1:bat[:oid,:dbl],b2:bat[:oid,:wrd]) :bat[:oid,:dbl]
address CMDbatSUB
comment "Return B1 - B2, overflow causes NIL value";
pattern -(b:bat[:oid,:dbl],v:wrd) :bat[:oid,:dbl]
address CMDbatSUBcstsignal
comment "Return B - V, signal error on overflow";
pattern -(b:bat[:oid,:dbl],v:wrd,accum:int) :bat[:oid,:dbl]
address CMDbatSUBcstsignal
comment "Return B - V, signal error on overflow, reuse B if ACCUM is set";
pattern sub_noerror(b:bat[:oid,:dbl],v:wrd) :bat[:oid,:dbl]
address CMDbatSUBcst
comment "Return B - V, overflow causes NIL value";
pattern -(v:dbl,b:bat[:oid,:wrd]) :bat[:oid,:dbl]
address CMDbatSUBcstsignal
comment "Return V - B, signal error on overflow";
pattern sub_noerror(v:dbl,b:bat[:oid,:wrd]) :bat[:oid,:dbl]
address CMDbatSUBcst
comment "Return V - B, overflow causes NIL value";

command -(b1:bat[:oid,:dbl],b2:bat[:oid,:lng]) :bat[:oid,:dbl]
address CMDbatSUBsignal
comment "Return B1 - B2, signal error on overflow";
command -(b1:bat[:oid,:dbl],b2:bat[:oid,:lng],accum:int) :bat[:oid,:dbl]
address CMDbatSUBsignalaccum
comment "Return B1 - B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command sub_noerror(b1:bat[:oid,:dbl],b2:bat[:oid,:lng]) :bat[:oid,:dbl]
address CMDbatSUB
comment "Return B1 - B2, overflow causes NIL value";
pattern -(b:bat[:oid,:dbl],v:lng) :bat[:oid,:dbl]
address CMDbatSUBcstsignal
comment "Return B - V, signal error on overflow";
pattern -(b:bat[:oid,:dbl],v:lng,accum:int) :bat[:oid,:dbl]
address CMDbatSUBcstsignal
comment "Return B - V, signal error on overflow, reuse B if ACCUM is set";
pattern sub_noerror(b:bat[:oid,:dbl],v:lng) :bat[:oid,:dbl]
address CMDbatSUBcst
comment "Return B - V, overflow causes NIL value";
pattern -(v:dbl,b:bat[:oid,:lng]) :bat[:oid,:dbl]
address CMDbatSUBcstsignal
comment "Return V - B, signal error on overflow";
pattern sub_noerror(v:dbl,b:bat[:oid,:lng]) :bat[:oid,:dbl]
address CMDbatSUBcst
comment "Return V - B, overflow causes NIL value";

command -(b1:bat[:oid,:dbl],b2:bat[:oid,:flt]) :bat[:oid,:dbl]
address CMDbatSUBsignal
comment "Return B1 - B2, signal error on overflow";
command -(b1:bat[:oid,:dbl],b2:bat[:oid,:flt],accum:int) :bat[:oid,:dbl]
address CMDbatSUBsignalaccum
comment "Return B1 - B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command sub_noerror(b1:bat[:oid,:dbl],b2:bat[:oid,:flt]) :bat[:oid,:dbl]
address CMDbatSUB
comment "Return B1 - B2, overflow causes NIL value";
pattern -(b:bat[:oid,:dbl],v:flt) :bat[:oid,:dbl]
address CMDbatSUBcstsignal
comment "Return B - V, signal error on overflow";
pattern -(b:bat[:oid,:dbl],v:flt,accum:int) :bat[:oid,:dbl]
address CMDbatSUBcstsignal
comment "Return B - V, signal error on overflow, reuse B if ACCUM is set";
pattern sub_noerror(b:bat[:oid,:dbl],v:flt) :bat[:oid,:dbl]
address CMDbatSUBcst
comment "Return B - V, overflow causes NIL value";
pattern -(v:dbl,b:bat[:oid,:flt]) :bat[:oid,:dbl]
address CMDbatSUBcstsignal
comment "Return V - B, signal error on overflow";
pattern sub_noerror(v:dbl,b:bat[:oid,:flt]) :bat[:oid,:dbl]
address CMDbatSUBcst
comment "Return V - B, overflow causes NIL value";

command -(b1:bat[:oid,:dbl],b2:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatSUBsignal
comment "Return B1 - B2, signal error on overflow";
command -(b1:bat[:oid,:dbl],b2:bat[:oid,:dbl],accum:int) :bat[:oid,:dbl]
address CMDbatSUBsignalaccum
comment "Return B1 - B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command sub_noerror(b1:bat[:oid,:dbl],b2:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatSUB
comment "Return B1 - B2, overflow causes NIL value";
pattern -(b:bat[:oid,:dbl],v:dbl) :bat[:oid,:dbl]
address CMDbatSUBcstsignal
comment "Return B - V, signal error on overflow";
pattern -(b:bat[:oid,:dbl],v:dbl,accum:int) :bat[:oid,:dbl]
address CMDbatSUBcstsignal
comment "Return B - V, signal error on overflow, reuse B if ACCUM is set";
pattern sub_noerror(b:bat[:oid,:dbl],v:dbl) :bat[:oid,:dbl]
address CMDbatSUBcst
comment "Return B - V, overflow causes NIL value";
pattern -(v:dbl,b:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatSUBcstsignal
comment "Return V - B, signal error on overflow";
pattern -(v:dbl,b:bat[:oid,:dbl],accum:int) :bat[:oid,:dbl]
address CMDbatSUBcstsignal
comment "Return V - B, signal error on overflow, reuse B if ACCUM is set";
pattern sub_noerror(v:dbl,b:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatSUBcst
comment "Return V - B, overflow causes NIL value";


command *(b1:bat[:oid,:bte],b2:bat[:oid,:bte]) :bat[:oid,:bte]
address CMDbatMULsignal
comment "Return B1 * B2, signal error on overflow";
command *(b1:bat[:oid,:bte],b2:bat[:oid,:bte],accum:int) :bat[:oid,:bte]
address CMDbatMULsignalaccum
comment "Return B1 * B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command mul_noerror(b1:bat[:oid,:bte],b2:bat[:oid,:bte]) :bat[:oid,:bte]
address CMDbatMUL
comment "Return B1 * B2, overflow causes NIL value";
pattern *(b:bat[:oid,:bte],v:bte) :bat[:oid,:bte]
address CMDbatMULcstsignal
comment "Return B * V, signal error on overflow";
pattern *(b:bat[:oid,:bte],v:bte,accum:int) :bat[:oid,:bte]
address CMDbatMULcstsignal
comment "Return B * V, signal error on overflow, reuse B if ACCUM is set";
pattern mul_noerror(b:bat[:oid,:bte],v:bte) :bat[:oid,:bte]
address CMDbatMULcst
comment "Return B * V, overflow causes NIL value";
pattern *(v:bte,b:bat[:oid,:bte]) :bat[:oid,:bte]
address CMDbatMULcstsignal
comment "Return V * B, signal error on overflow";
pattern *(v:bte,b:bat[:oid,:bte],accum:int) :bat[:oid,:bte]
address CMDbatMULcstsignal
comment "Return V * B, signal error on overflow, reuse B if ACCUM is set";
pattern mul_noerror(v:bte,b:bat[:oid,:bte]) :bat[:oid,:bte]
address CMDbatMULcst
comment "Return V * B, overflow causes NIL value";

command *(b1:bat[:oid,:bte],b2:bat[:oid,:sht]) :bat[:oid,:sht]
address CMDbatMULsignal
comment "Return B1 * B2, signal error on overflow";
command *(b1:bat[:oid,:bte],b2:bat[:oid,:sht],accum:int) :bat[:oid,:sht]
address CMDbatMULsignalaccum
comment "Return B1 * B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command mul_noerror(b1:bat[:oid,:bte],b2:bat[:oid,:sht]) :bat[:oid,:sht]
address CMDbatMUL
comment "Return B1 * B2, overflow causes NIL value";
pattern *(b:bat[:oid,:bte],v:sht) :bat[:oid,:sht]
address CMDbatMULcstsignal
comment "Return B * V, signal error on overflow";
pattern mul_noerror(b:bat[:oid,:bte],v:sht) :bat[:oid,:sht]
address CMDbatMULcst
comment "Return B * V, overflow causes NIL value";
pattern *(v:bte,b:bat[:oid,:sht]) :bat[:oid,:sht]
address CMDbatMULcstsignal
comment "Return V * B, signal error on overflow";
pattern *(v:bte,b:bat[:oid,:sht],accum:int) :bat[:oid,:sht]
address CMDbatMULcstsignal
comment "Return V * B, signal error on overflow, reuse B if ACCUM is set";
pattern mul_noerror(v:bte,b:bat[:oid,:sht]) :bat[:oid,:sht]
address CMDbatMULcst
comment "Return V * B, overflow causes NIL value";

command *(b1:bat[:oid,:bte],b2:bat[:oid,:int]) :bat[:oid,:int]
address CMDbatMULsignal
comment "Return B1 * B2, signal error on overflow";
command *(b1:bat[:oid,:bte],b2:bat[:oid,:int],accum:int) :bat[:oid,:int]
address CMDbatMULsignalaccum
comment "Return B1 * B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command mul_noerror(b1:bat[:oid,:bte],b2:bat[:oid,:int]) :bat[:oid,:int]
address CMDbatMUL
comment "Return B1 * B2, overflow causes NIL value";
pattern *(b:bat[:oid,:bte],v:int) :bat[:oid,:int]
address CMDbatMULcstsignal
comment "Return B * V, signal error on overflow";
pattern mul_noerror(b:bat[:oid,:bte],v:int) :bat[:oid,:int]
address CMDbatMULcst
comment "Return B * V, overflow causes NIL value";
pattern *(v:bte,b:bat[:oid,:int]) :bat[:oid,:int]
address CMDbatMULcstsignal
comment "Return V * B, signal error on overflow";
pattern *(v:bte,b:bat[:oid,:int],accum:int) :bat[:oid,:int]
address CMDbatMULcstsignal
comment "Return V * B, signal error on overflow, reuse B if ACCUM is set";
pattern mul_noerror(v:bte,b:bat[:oid,:int]) :bat[:oid,:int]
address CMDbatMULcst
comment "Return V * B, overflow causes NIL value";

command *(b1:bat[:oid,:bte],b2:bat[:oid,:wrd]) :bat[:oid,:wrd]
address CMDbatMULsignal
comment "Return B1 * B2, signal error on overflow";
command *(b1:bat[:oid,:bte],b2:bat[:oid,:wrd],accum:int) :bat[:oid,:wrd]
address CMDbatMULsignalaccum
comment "Return B1 * B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command mul_noerror(b1:bat[:oid,:bte],b2:bat[:oid,:wrd]) :bat[:oid,:wrd]
address CMDbatMUL
comment "Return B1 * B2, overflow causes NIL value";
pattern *(b:bat[:oid,:bte],v:wrd) :bat[:oid,:wrd]
address CMDbatMULcstsignal
comment "Return B * V, signal error on overflow";
pattern mul_noerror(b:bat[:oid,:bte],v:wrd) :bat[:oid,:wrd]
address CMDbatMULcst
comment "Return B * V, overflow causes NIL value";
pattern *(v:bte,b:bat[:oid,:wrd]) :bat[:oid,:wrd]
address CMDbatMULcstsignal
comment "Return V * B, signal error on overflow";
pattern *(v:bte,b:bat[:oid,:wrd],accum:int) :bat[:oid,:wrd]
address CMDbatMULcstsignal
comment "Return V * B, signal error on overflow, reuse B if ACCUM is set";
pattern mul_noerror(v:bte,b:bat[:oid,:wrd]) :bat[:oid,:wrd]
address CMDbatMULcst
comment "Return V * B, overflow causes NIL value";

command *(b1:bat[:oid,:bte],b2:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatMULsignal
comment "Return B1 * B2, signal error on overflow";
command *(b1:bat[:oid,:bte],b2:bat[:oid,:lng],accum:int) :bat[:oid,:lng]
address CMDbatMULsignalaccum
comment "Return B1 * B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command mul_noerror(b1:bat[:oid,:bte],b2:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatMUL
comment "Return B1 * B2, overflow causes NIL value";
pattern *(b:bat[:oid,:bte],v:lng) :bat[:oid,:lng]
address CMDbatMULcstsignal
comment "Return B * V, signal error on overflow";
pattern mul_noerror(b:bat[:oid,:bte],v:lng) :bat[:oid,:lng]
address CMDbatMULcst
comment "Return B * V, overflow causes NIL value";
pattern *(v:bte,b:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatMULcstsignal
comment "Return V * B, signal error on overflow";
pattern *(v:bte,b:bat[:oid,:lng],accum:int) :bat[:oid,:lng]
address CMDbatMULcstsignal
comment "Return V * B, signal error on overflow, reuse B if ACCUM is set";
pattern mul_noerror(v:bte,b:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatMULcst
comment "Return V * B, overflow causes NIL value";

command *(b1:bat[:oid,:bte],b2:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatMULsignal
comment "Return B1 * B2, signal error on overflow";
command *(b1:bat[:oid,:bte],b2:bat[:oid,:flt],accum:int) :bat[:oid,:flt]
address CMDbatMULsignalaccum
comment "Return B1 * B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command mul_noerror(b1:bat[:oid,:bte],b2:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatMUL
comment "Return B1 * B2, overflow causes NIL value";
pattern *(b:bat[:oid,:bte],v:flt) :bat[:oid,:flt]
address CMDbatMULcstsignal
comment "Return B * V, signal error on overflow";
pattern mul_noerror(b:bat[:oid,:bte],v:flt) :bat[:oid,:flt]
address CMDbatMULcst
comment "Return B * V, overflow causes NIL value";
pattern *(v:bte,b:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatMULcstsignal
comment "Return V * B, signal error on overflow";
pattern *(v:bte,b:bat[:oid,:flt],accum:int) :bat[:oid,:flt]
address CMDbatMULcstsignal
comment "Return V * B, signal error on overflow, reuse B if ACCUM is set";
pattern mul_noerror(v:bte,b:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatMULcst
comment "Return V * B, overflow causes NIL value";

command *(b1:bat[:oid,:bte],b2:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatMULsignal
comment "Return B1 * B2, signal error on overflow";
command *(b1:bat[:oid,:bte],b2:bat[:oid,:dbl],accum:int) :bat[:oid,:dbl]
address CMDbatMULsignalaccum
comment "Return B1 * B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command mul_noerror(b1:bat[:oid,:bte],b2:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatMUL
comment "Return B1 * B2, overflow causes NIL value";
pattern *(b:bat[:oid,:bte],v:dbl) :bat[:oid,:dbl]
address CMDbatMULcstsignal
comment "Return B * V, signal error on overflow";
pattern mul_noerror(b:bat[:oid,:bte],v:dbl) :bat[:oid,:dbl]
address CMDbatMULcst
comment "Return B * V, overflow causes NIL value";
pattern *(v:bte,b:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatMULcstsignal
comment "Return V * B, signal error on overflow";
pattern *(v:bte,b:bat[:oid,:dbl],accum:int) :bat[:oid,:dbl]
address CMDbatMULcstsignal
comment "Return V * B, signal error on overflow, reuse B if ACCUM is set";
pattern mul_noerror(v:bte,b:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatMULcst
comment "Return V * B, overflow causes NIL value";

command *(b1:bat[:oid,:sht],b2:bat[:oid,:bte]) :bat[:oid,:sht]
address CMDbatMULsignal
comment "Return B1 * B2, signal error on overflow";
command *(b1:bat[:oid,:sht],b2:bat[:oid,:bte],accum:int) :bat[:oid,:sht]
address CMDbatMULsignalaccum
comment "Return B1 * B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command mul_noerror(b1:bat[:oid,:sht],b2:bat[:oid,:bte]) :bat[:oid,:sht]
address CMDbatMUL
comment "Return B1 * B2, overflow causes NIL value";
pattern *(b:bat[:oid,:sht],v:bte) :bat[:oid,:sht]
address CMDbatMULcstsignal
comment "Return B * V, signal error on overflow";
pattern *(b:bat[:oid,:sht],v:bte,accum:int) :bat[:oid,:sht]
address CMDbatMULcstsignal
comment "Return B * V, signal error on overflow, reuse B if ACCUM is set";
pattern mul_noerror(b:bat[:oid,:sht],v:bte) :bat[:oid,:sht]
address CMDbatMULcst
comment "Return B * V, overflow causes NIL value";
pattern *(v:sht,b:bat[:oid,:bte]) :bat[:oid,:sht]
address CMDbatMULcstsignal
comment "Return V * B, signal error on overflow";
pattern mul_noerror(v:sht,b:bat[:oid,:bte]) :bat[:oid,:sht]
address CMDbatMULcst
comment "Return V * B, overflow causes NIL value";

command *(b1:bat[:oid,:sht],b2:bat[:oid,:sht]) :bat[:oid,:sht]
address CMDbatMULsignal
comment "Return B1 * B2, signal error on overflow";
command *(b1:bat[:oid,:sht],b2:bat[:oid,:sht],accum:int) :bat[:oid,:sht]
address CMDbatMULsignalaccum
comment "Return B1 * B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command mul_noerror(b1:bat[:oid,:sht],b2:bat[:oid,:sht]) :bat[:oid,:sht]
address CMDbatMUL
comment "Return B1 * B2, overflow causes NIL value";
pattern *(b:bat[:oid,:sht],v:sht) :bat[:oid,:sht]
address CMDbatMULcstsignal
comment "Return B * V, signal error on overflow";
pattern *(b:bat[:oid,:sht],v:sht,accum:int) :bat[:oid,:sht]
address CMDbatMULcstsignal
comment "Return B * V, signal error on overflow, reuse B if ACCUM is set";
pattern mul_noerror(b:bat[:oid,:sht],v:sht) :bat[:oid,:sht]
address CMDbatMULcst
comment "Return B * V, overflow causes NIL value";
pattern *(v:sht,b:bat[:oid,:sht]) :bat[:oid,:sht]
address CMDbatMULcstsignal
comment "Return V * B, signal error on overflow";
pattern *(v:sht,b:bat[:oid,:sht],accum:int) :bat[:oid,:sht]
address CMDbatMULcstsignal
comment "Return V * B, signal error on overflow, reuse B if ACCUM is set";
pattern mul_noerror(v:sht,b:bat[:oid,:sht]) :bat[:oid,:sht]
address CMDbatMULcst
comment "Return V * B, overflow causes NIL value";

command *(b1:bat[:oid,:sht],b2:bat[:oid,:int]) :bat[:oid,:int]
address CMDbatMULsignal
comment "Return B1 * B2, signal error on overflow";
command *(b1:bat[:oid,:sht],b2:bat[:oid,:int],accum:int) :bat[:oid,:int]
address CMDbatMULsignalaccum
comment "Return B1 * B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command mul_noerror(b1:bat[:oid,:sht],b2:bat[:oid,:int]) :bat[:oid,:int]
address CMDbatMUL
comment "Return B1 * B2, overflow causes NIL value";
pattern *(b:bat[:oid,:sht],v:int) :bat[:oid,:int]
address CMDbatMULcstsignal
comment "Return B * V, signal error on overflow";
pattern mul_noerror(b:bat[:oid,:sht],v:int) :bat[:oid,:int]
address CMDbatMULcst
comment "Return B * V, overflow causes NIL value";
pattern *(v:sht,b:bat[:oid,:int]) :bat[:oid,:int]
address CMDbatMULcstsignal
comment "Return V * B, signal error on overflow";
pattern *(v:sht,b:bat[:oid,:int],accum:int) :bat[:oid,:int]
address CMDbatMULcstsignal
comment "Return V * B, signal error on overflow, reuse B if ACCUM is set";
pattern mul_noerror(v:sht,b:bat[:oid,:int]) :bat[:oid,:int]
address CMDbatMULcst
comment "Return V * B, overflow causes NIL value";

command *(b1:bat[:oid,:sht],b2:bat[:oid,:wrd]) :bat[:oid,:wrd]
address CMDbatMULsignal
comment "Return B1 * B2, signal error on overflow";
command *(b1:bat[:oid,:sht],b2:bat[:oid,:wrd],accum:int) :bat[:oid,:wrd]
address CMDbatMULsignalaccum
comment "Return B1 * B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command mul_noerror(b1:bat[:oid,:sht],b2:bat[:oid,:wrd]) :bat[:oid,:wrd]
address CMDbatMUL
comment "Return B1 * B2, overflow causes NIL value";
pattern *(b:bat[:oid,:sht],v:wrd) :bat[:oid,:wrd]
address CMDbatMULcstsignal
comment "Return B * V, signal error on overflow";
pattern mul_noerror(b:bat[:oid,:sht],v:wrd) :bat[:oid,:wrd]
address CMDbatMULcst
comment "Return B * V, overflow causes NIL value";
pattern *(v:sht,b:bat[:oid,:wrd]) :bat[:oid,:wrd]
address CMDbatMULcstsignal
comment "Return V * B, signal error on overflow";
pattern *(v:sht,b:bat[:oid,:wrd],accum:int) :bat[:oid,:wrd]
address CMDbatMULcstsignal
comment "Return V * B, signal error on overflow, reuse B if ACCUM is set";
pattern mul_noerror(v:sht,b:bat[:oid,:wrd]) :bat[:oid,:wrd]
address CMDbatMULcst
comment "Return V * B, overflow causes NIL value";

command *(b1:bat[:oid,:sht],b2:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatMULsignal
comment "Return B1 * B2, signal error on overflow";
command *(b1:bat[:oid,:sht],b2:bat[:oid,:lng],accum:int) :bat[:oid,:lng]
address CMDbatMULsignalaccum
comment "Return B1 * B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command mul_noerror(b1:bat[:oid,:sht],b2:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatMUL
comment "Return B1 * B2, overflow causes NIL value";
pattern *(b:bat[:oid,:sht],v:lng) :bat[:oid,:lng]
address CMDbatMULcstsignal
comment "Return B * V, signal error on overflow";
pattern mul_noerror(b:bat[:oid,:sht],v:lng) :bat[:oid,:lng]
address CMDbatMULcst
comment "Return B * V, overflow causes NIL value";
pattern *(v:sht,b:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatMULcstsignal
comment "Return V * B, signal error on overflow";
pattern *(v:sht,b:bat[:oid,:lng],accum:int) :bat[:oid,:lng]
address CMDbatMULcstsignal
comment "Return V * B, signal error on overflow, reuse B if ACCUM is set";
pattern mul_noerror(v:sht,b:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatMULcst
comment "Return V * B, overflow causes NIL value";

command *(b1:bat[:oid,:sht],b2:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatMULsignal
comment "Return B1 * B2, signal error on overflow";
command *(b1:bat[:oid,:sht],b2:bat[:oid,:flt],accum:int) :bat[:oid,:flt]
address CMDbatMULsignalaccum
comment "Return B1 * B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command mul_noerror(b1:bat[:oid,:sht],b2:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatMUL
comment "Return B1 * B2, overflow causes NIL value";
pattern *(b:bat[:oid,:sht],v:flt) :bat[:oid,:flt]
address CMDbatMULcstsignal
comment "Return B * V, signal error on overflow";
pattern mul_noerror(b:bat[:oid,:sht],v:flt) :bat[:oid,:flt]
address CMDbatMULcst
comment "Return B * V, overflow causes NIL value";
pattern *(v:sht,b:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatMULcstsignal
comment "Return V * B, signal error on overflow";
pattern *(v:sht,b:bat[:oid,:flt],accum:int) :bat[:oid,:flt]
address CMDbatMULcstsignal
comment "Return V * B, signal error on overflow, reuse B if ACCUM is set";
pattern mul_noerror(v:sht,b:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatMULcst
comment "Return V * B, overflow causes NIL value";

command *(b1:bat[:oid,:sht],b2:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatMULsignal
comment "Return B1 * B2, signal error on overflow";
command *(b1:bat[:oid,:sht],b2:bat[:oid,:dbl],accum:int) :bat[:oid,:dbl]
address CMDbatMULsignalaccum
comment "Return B1 * B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command mul_noerror(b1:bat[:oid,:sht],b2:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatMUL
comment "Return B1 * B2, overflow causes NIL value";
pattern *(b:bat[:oid,:sht],v:dbl) :bat[:oid,:dbl]
address CMDbatMULcstsignal
comment "Return B * V, signal error on overflow";
pattern mul_noerror(b:bat[:oid,:sht],v:dbl) :bat[:oid,:dbl]
address CMDbatMULcst
comment "Return B * V, overflow causes NIL value";
pattern *(v:sht,b:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatMULcstsignal
comment "Return V * B, signal error on overflow";
pattern *(v:sht,b:bat[:oid,:dbl],accum:int) :bat[:oid,:dbl]
address CMDbatMULcstsignal
comment "Return V * B, signal error on overflow, reuse B if ACCUM is set";
pattern mul_noerror(v:sht,b:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatMULcst
comment "Return V * B, overflow causes NIL value";

command *(b1:bat[:oid,:int],b2:bat[:oid,:bte]) :bat[:oid,:int]
address CMDbatMULsignal
comment "Return B1 * B2, signal error on overflow";
command *(b1:bat[:oid,:int],b2:bat[:oid,:bte],accum:int) :bat[:oid,:int]
address CMDbatMULsignalaccum
comment "Return B1 * B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command mul_noerror(b1:bat[:oid,:int],b2:bat[:oid,:bte]) :bat[:oid,:int]
address CMDbatMUL
comment "Return B1 * B2, overflow causes NIL value";
pattern *(b:bat[:oid,:int],v:bte) :bat[:oid,:int]
address CMDbatMULcstsignal
comment "Return B * V, signal error on overflow";
pattern *(b:bat[:oid,:int],v:bte,accum:int) :bat[:oid,:int]
address CMDbatMULcstsignal
comment "Return B * V, signal error on overflow, reuse B if ACCUM is set";
pattern mul_noerror(b:bat[:oid,:int],v:bte) :bat[:oid,:int]
address CMDbatMULcst
comment "Return B * V, overflow causes NIL value";
pattern *(v:int,b:bat[:oid,:bte]) :bat[:oid,:int]
address CMDbatMULcstsignal
comment "Return V * B, signal error on overflow";
pattern mul_noerror(v:int,b:bat[:oid,:bte]) :bat[:oid,:int]
address CMDbatMULcst
comment "Return V * B, overflow causes NIL value";

command *(b1:bat[:oid,:int],b2:bat[:oid,:sht]) :bat[:oid,:int]
address CMDbatMULsignal
comment "Return B1 * B2, signal error on overflow";
command *(b1:bat[:oid,:int],b2:bat[:oid,:sht],accum:int) :bat[:oid,:int]
address CMDbatMULsignalaccum
comment "Return B1 * B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command mul_noerror(b1:bat[:oid,:int],b2:bat[:oid,:sht]) :bat[:oid,:int]
address CMDbatMUL
comment "Return B1 * B2, overflow causes NIL value";
pattern *(b:bat[:oid,:int],v:sht) :bat[:oid,:int]
address CMDbatMULcstsignal
comment "Return B * V, signal error on overflow";
pattern *(b:bat[:oid,:int],v:sht,accum:int) :bat[:oid,:int]
address CMDbatMULcstsignal
comment "Return B * V, signal error on overflow, reuse B if ACCUM is set";
pattern mul_noerror(b:bat[:oid,:int],v:sht) :bat[:oid,:int]
address CMDbatMULcst
comment "Return B * V, overflow causes NIL value";
pattern *(v:int,b:bat[:oid,:sht]) :bat[:oid,:int]
address CMDbatMULcstsignal
comment "Return V * B, signal error on overflow";
pattern mul_noerror(v:int,b:bat[:oid,:sht]) :bat[:oid,:int]
address CMDbatMULcst
comment "Return V * B, overflow causes NIL value";

command *(b1:bat[:oid,:int],b2:bat[:oid,:int]) :bat[:oid,:int]
address CMDbatMULsignal
comment "Return B1 * B2, signal error on overflow";
command *(b1:bat[:oid,:int],b2:bat[:oid,:int],accum:int) :bat[:oid,:int]
address CMDbatMULsignalaccum
comment "Return B1 * B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command mul_noerror(b1:bat[:oid,:int],b2:bat[:oid,:int]) :bat[:oid,:int]
address CMDbatMUL
comment "Return B1 * B2, overflow causes NIL value";
pattern *(b:bat[:oid,:int],v:int) :bat[:oid,:int]
address CMDbatMULcstsignal
comment "Return B * V, signal error on overflow";
pattern *(b:bat[:oid,:int],v:int,accum:int) :bat[:oid,:int]
address CMDbatMULcstsignal
comment "Return B * V, signal error on overflow, reuse B if ACCUM is set";
pattern mul_noerror(b:bat[:oid,:int],v:int) :bat[:oid,:int]
address CMDbatMULcst
comment "Return B * V, overflow causes NIL value";
pattern *(v:int,b:bat[:oid,:int]) :bat[:oid,:int]
address CMDbatMULcstsignal
comment "Return V * B, signal error on overflow";
pattern *(v:int,b:bat[:oid,:int],accum:int) :bat[:oid,:int]
address CMDbatMULcstsignal
comment "Return V * B, signal error on overflow, reuse B if ACCUM is set";
pattern mul_noerror(v:int,b:bat[:oid,:int]) :bat[:oid,:int]
address CMDbatMULcst
comment "Return V * B, overflow causes NIL value";

command *(b1:bat[:oid,:int],b2:bat[:oid,:wrd]) :bat[:oid,:wrd]
address CMDbatMULsignal
comment "Return B1 * B2, signal error on overflow";
command *(b1:bat[:oid,:int],b2:bat[:oid,:wrd],accum:int) :bat[:oid,:wrd]
address CMDbatMULsignalaccum
comment "Return B1 * B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command mul_noerror(b1:bat[:oid,:int],b2:bat[:oid,:wrd]) :bat[:oid,:wrd]
address CMDbatMUL
comment "Return B1 * B2, overflow causes NIL value";
pattern *(b:bat[:oid,:int],v:wrd) :bat[:oid,:wrd]
address CMDbatMULcstsignal
comment "Return B * V, signal error on overflow";
pattern mul_noerror(b:bat[:oid,:int],v:wrd) :bat[:oid,:wrd]
address CMDbatMULcst
comment "Return B * V, overflow causes NIL value";
pattern *(v:int,b:bat[:oid,:wrd]) :bat[:oid,:wrd]
address CMDbatMULcstsignal
comment "Return V * B, signal error on overflow";
pattern *(v:int,b:bat[:oid,:wrd],accum:int) :bat[:oid,:wrd]
address CMDbatMULcstsignal
comment "Return V * B, signal error on overflow, reuse B if ACCUM is set";
pattern mul_noerror(v:int,b:bat[:oid,:wrd]) :bat[:oid,:wrd]
address CMDbatMULcst
comment "Return V * B, overflow causes NIL value";

command *(b1:bat[:oid,:int],b2:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatMULsignal
comment "Return B1 * B2, signal error on overflow";
command *(b1:bat[:oid,:int],b2:bat[:oid,:lng],accum:int) :bat[:oid,:lng]
address CMDbatMULsignalaccum
comment "Return B1 * B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command mul_noerror(b1:bat[:oid,:int],b2:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatMUL
comment "Return B1 * B2, overflow causes NIL value";
pattern *(b:bat[:oid,:int],v:lng) :bat[:oid,:lng]
address CMDbatMULcstsignal
comment "Return B * V, signal error on overflow";
pattern mul_noerror(b:bat[:oid,:int],v:lng) :bat[:oid,:lng]
address CMDbatMULcst
comment "Return B * V, overflow causes NIL value";
pattern *(v:int,b:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatMULcstsignal
comment "Return V * B, signal error on overflow";
pattern *(v:int,b:bat[:oid,:lng],accum:int) :bat[:oid,:lng]
address CMDbatMULcstsignal
comment "Return V * B, signal error on overflow, reuse B if ACCUM is set";
pattern mul_noerror(v:int,b:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatMULcst
comment "Return V * B, overflow causes NIL value";

command *(b1:bat[:oid,:int],b2:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatMULsignal
comment "Return B1 * B2, signal error on overflow";
command *(b1:bat[:oid,:int],b2:bat[:oid,:flt],accum:int) :bat[:oid,:flt]
address CMDbatMULsignalaccum
comment "Return B1 * B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command mul_noerror(b1:bat[:oid,:int],b2:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatMUL
comment "Return B1 * B2, overflow causes NIL value";
pattern *(b:bat[:oid,:int],v:flt) :bat[:oid,:flt]
address CMDbatMULcstsignal
comment "Return B * V, signal error on overflow";
pattern mul_noerror(b:bat[:oid,:int],v:flt) :bat[:oid,:flt]
address CMDbatMULcst
comment "Return B * V, overflow causes NIL value";
pattern *(v:int,b:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatMULcstsignal
comment "Return V * B, signal error on overflow";
pattern *(v:int,b:bat[:oid,:flt],accum:int) :bat[:oid,:flt]
address CMDbatMULcstsignal
comment "Return V * B, signal error on overflow, reuse B if ACCUM is set";
pattern mul_noerror(v:int,b:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatMULcst
comment "Return V * B, overflow causes NIL value";

command *(b1:bat[:oid,:int],b2:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatMULsignal
comment "Return B1 * B2, signal error on overflow";
command *(b1:bat[:oid,:int],b2:bat[:oid,:dbl],accum:int) :bat[:oid,:dbl]
address CMDbatMULsignalaccum
comment "Return B1 * B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command mul_noerror(b1:bat[:oid,:int],b2:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatMUL
comment "Return B1 * B2, overflow causes NIL value";
pattern *(b:bat[:oid,:int],v:dbl) :bat[:oid,:dbl]
address CMDbatMULcstsignal
comment "Return B * V, signal error on overflow";
pattern mul_noerror(b:bat[:oid,:int],v:dbl) :bat[:oid,:dbl]
address CMDbatMULcst
comment "Return B * V, overflow causes NIL value";
pattern *(v:int,b:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatMULcstsignal
comment "Return V * B, signal error on overflow";
pattern *(v:int,b:bat[:oid,:dbl],accum:int) :bat[:oid,:dbl]
address CMDbatMULcstsignal
comment "Return V * B, signal error on overflow, reuse B if ACCUM is set";
pattern mul_noerror(v:int,b:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatMULcst
comment "Return V * B, overflow causes NIL value";

command *(b1:bat[:oid,:wrd],b2:bat[:oid,:bte]) :bat[:oid,:wrd]
address CMDbatMULsignal
comment "Return B1 * B2, signal error on overflow";
command *(b1:bat[:oid,:wrd],b2:bat[:oid,:bte],accum:int) :bat[:oid,:wrd]
address CMDbatMULsignalaccum
comment "Return B1 * B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command mul_noerror(b1:bat[:oid,:wrd],b2:bat[:oid,:bte]) :bat[:oid,:wrd]
address CMDbatMUL
comment "Return B1 * B2, overflow causes NIL value";
pattern *(b:bat[:oid,:wrd],v:bte) :bat[:oid,:wrd]
address CMDbatMULcstsignal
comment "Return B * V, signal error on overflow";
pattern *(b:bat[:oid,:wrd],v:bte,accum:int) :bat[:oid,:wrd]
address CMDbatMULcstsignal
comment "Return B * V, signal error on overflow, reuse B if ACCUM is set";
pattern mul_noerror(b:bat[:oid,:wrd],v:bte) :bat[:oid,:wrd]
address CMDbatMULcst
comment "Return B * V, overflow causes NIL value";
pattern *(v:wrd,b:bat[:oid,:bte]) :bat[:oid,:wrd]
address CMDbatMULcstsignal
comment "Return V * B, signal error on overflow";
pattern mul_noerror(v:wrd,b:bat[:oid,:bte]) :bat[:oid,:wrd]
address CMDbatMULcst
comment "Return V * B, overflow causes NIL value";

command *(b1:bat[:oid,:wrd],b2:bat[:oid,:sht]) :bat[:oid,:wrd]
address CMDbatMULsignal
comment "Return B1 * B2, signal error on overflow";
command *(b1:bat[:oid,:wrd],b2:bat[:oid,:sht],accum:int) :bat[:oid,:wrd]
address CMDbatMULsignalaccum
comment "Return B1 * B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command mul_noerror(b1:bat[:oid,:wrd],b2:bat[:oid,:sht]) :bat[:oid,:wrd]
address CMDbatMUL
comment "Return B1 * B2, overflow causes NIL value";
pattern *(b:bat[:oid,:wrd],v:sht) :bat[:oid,:wrd]
address CMDbatMULcstsignal
comment "Return B * V, signal error on overflow";
pattern *(b:bat[:oid,:wrd],v:sht,accum:int) :bat[:oid,:wrd]
address CMDbatMULcstsignal
comment "Return B * V, signal error on overflow, reuse B if ACCUM is set";
pattern mul_noerror(b:bat[:oid,:wrd],v:sht) :bat[:oid,:wrd]
address CMDbatMULcst
comment "Return B * V, overflow causes NIL value";
pattern *(v:wrd,b:bat[:oid,:sht]) :bat[:oid,:wrd]
address CMDbatMULcstsignal
comment "Return V * B, signal error on overflow";
pattern mul_noerror(v:wrd,b:bat[:oid,:sht]) :bat[:oid,:wrd]
address CMDbatMULcst
comment "Return V * B, overflow causes NIL value";

command *(b1:bat[:oid,:wrd],b2:bat[:oid,:int]) :bat[:oid,:wrd]
address CMDbatMULsignal
comment "Return B1 * B2, signal error on overflow";
command *(b1:bat[:oid,:wrd],b2:bat[:oid,:int],accum:int) :bat[:oid,:wrd]
address CMDbatMULsignalaccum
comment "Return B1 * B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command mul_noerror(b1:bat[:oid,:wrd],b2:bat[:oid,:int]) :bat[:oid,:wrd]
address CMDbatMUL
comment "Return B1 * B2, overflow causes NIL value";
pattern *(b:bat[:oid,:wrd],v:int) :bat[:oid,:wrd]
address CMDbatMULcstsignal
comment "Return B * V, signal error on overflow";
pattern *(b:bat[:oid,:wrd],v:int,accum:int) :bat[:oid,:wrd]
address CMDbatMULcstsignal
comment "Return B * V, signal error on overflow, reuse B if ACCUM is set";
pattern mul_noerror(b:bat[:oid,:wrd],v:int) :bat[:oid,:wrd]
address CMDbatMULcst
comment "Return B * V, overflow causes NIL value";
pattern *(v:wrd,b:bat[:oid,:int]) :bat[:oid,:wrd]
address CMDbatMULcstsignal
comment "Return V * B, signal error on overflow";
pattern mul_noerror(v:wrd,b:bat[:oid,:int]) :bat[:oid,:wrd]
address CMDbatMULcst
comment "Return V * B, overflow causes NIL value";

command *(b1:bat[:oid,:wrd],b2:bat[:oid,:wrd]) :bat[:oid,:wrd]
address CMDbatMULsignal
comment "Return B1 * B2, signal error on overflow";
command *(b1:bat[:oid,:wrd],b2:bat[:oid,:wrd],accum:int) :bat[:oid,:wrd]
address CMDbatMULsignalaccum
comment "Return B1 * B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command mul_noerror(b1:bat[:oid,:wrd],b2:bat[:oid,:wrd]) :bat[:oid,:wrd]
address CMDbatMUL
comment "Return B1 * B2, overflow causes NIL value";
pattern *(b:bat[:oid,:wrd],v:wrd) :bat[:oid,:wrd]
address CMDbatMULcstsignal
comment "Return B * V, signal error on overflow";
pattern *(b:bat[:oid,:wrd],v:wrd,accum:int) :bat[:oid,:wrd]
address CMDbatMULcstsignal
comment "Return B * V, signal error on overflow, reuse B if ACCUM is set";
pattern mul_noerror(b:bat[:oid,:wrd],v:wrd) :bat[:oid,:wrd]
address CMDbatMULcst
comment "Return B * V, overflow causes NIL value";
pattern *(v:wrd,b:bat[:oid,:wrd]) :bat[:oid,:wrd]
address CMDbatMULcstsignal
comment "Return V * B, signal error on overflow";
pattern *(v:wrd,b:bat[:oid,:wrd],accum:int) :bat[:oid,:wrd]
address CMDbatMULcstsignal
comment "Return V * B, signal error on overflow, reuse B if ACCUM is set";
pattern mul_noerror(v:wrd,b:bat[:oid,:wrd]) :bat[:oid,:wrd]
address CMDbatMULcst
comment "Return V * B, overflow causes NIL value";

command *(b1:bat[:oid,:wrd],b2:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatMULsignal
comment "Return B1 * B2, signal error on overflow";
command *(b1:bat[:oid,:wrd],b2:bat[:oid,:lng],accum:int) :bat[:oid,:lng]
address CMDbatMULsignalaccum
comment "Return B1 * B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command mul_noerror(b1:bat[:oid,:wrd],b2:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatMUL
comment "Return B1 * B2, overflow causes NIL value";
pattern *(b:bat[:oid,:wrd],v:lng) :bat[:oid,:lng]
address CMDbatMULcstsignal
comment "Return B * V, signal error on overflow";
pattern mul_noerror(b:bat[:oid,:wrd],v:lng) :bat[:oid,:lng]
address CMDbatMULcst
comment "Return B * V, overflow causes NIL value";
pattern *(v:wrd,b:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatMULcstsignal
comment "Return V * B, signal error on overflow";
pattern *(v:wrd,b:bat[:oid,:lng],accum:int) :bat[:oid,:lng]
address CMDbatMULcstsignal
comment "Return V * B, signal error on overflow, reuse B if ACCUM is set";
pattern mul_noerror(v:wrd,b:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatMULcst
comment "Return V * B, overflow causes NIL value";

command *(b1:bat[:oid,:wrd],b2:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatMULsignal
comment "Return B1 * B2, signal error on overflow";
command *(b1:bat[:oid,:wrd],b2:bat[:oid,:flt],accum:int) :bat[:oid,:flt]
address CMDbatMULsignalaccum
comment "Return B1 * B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command mul_noerror(b1:bat[:oid,:wrd],b2:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatMUL
comment "Return B1 * B2, overflow causes NIL value";
pattern *(b:bat[:oid,:wrd],v:flt) :bat[:oid,:flt]
address CMDbatMULcstsignal
comment "Return B * V, signal error on overflow";
pattern mul_noerror(b:bat[:oid,:wrd],v:flt) :bat[:oid,:flt]
address CMDbatMULcst
comment "Return B * V, overflow causes NIL value";
pattern *(v:wrd,b:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatMULcstsignal
comment "Return V * B, signal error on overflow";
pattern *(v:wrd,b:bat[:oid,:flt],accum:int) :bat[:oid,:flt]
address CMDbatMULcstsignal
comment "Return V * B, signal error on overflow, reuse B if ACCUM is set";
pattern mul_noerror(v:wrd,b:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatMULcst
comment "Return V * B, overflow causes NIL value";

command *(b1:bat[:oid,:wrd],b2:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatMULsignal
comment "Return B1 * B2, signal error on overflow";
command *(b1:bat[:oid,:wrd],b2:bat[:oid,:dbl],accum:int) :bat[:oid,:dbl]
address CMDbatMULsignalaccum
comment "Return B1 * B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command mul_noerror(b1:bat[:oid,:wrd],b2:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatMUL
comment "Return B1 * B2, overflow causes NIL value";
pattern *(b:bat[:oid,:wrd],v:dbl) :bat[:oid,:dbl]
address CMDbatMULcstsignal
comment "Return B * V, signal error on overflow";
pattern mul_noerror(b:bat[:oid,:wrd],v:dbl) :bat[:oid,:dbl]
address CMDbatMULcst
comment "Return B * V, overflow causes NIL value";
pattern *(v:wrd,b:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatMULcstsignal
comment "Return V * B, signal error on overflow";
pattern *(v:wrd,b:bat[:oid,:dbl],accum:int) :bat[:oid,:dbl]
address CMDbatMULcstsignal
comment "Return V * B, signal error on overflow, reuse B if ACCUM is set";
pattern mul_noerror(v:wrd,b:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatMULcst
comment "Return V * B, overflow causes NIL value";

command *(b1:bat[:oid,:lng],b2:bat[:oid,:bte]) :bat[:oid,:lng]
address CMDbatMULsignal
comment "Return B1 * B2, signal error on overflow";
command *(b1:bat[:oid,:lng],b2:bat[:oid,:bte],accum:int) :bat[:oid,:lng]
address CMDbatMULsignalaccum
comment "Return B1 * B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command mul_noerror(b1:bat[:oid,:lng],b2:bat[:oid,:bte]) :bat[:oid,:lng]
address CMDbatMUL
comment "Return B1 * B2, overflow causes NIL value";
pattern *(b:bat[:oid,:lng],v:bte) :bat[:oid,:lng]
address CMDbatMULcstsignal
comment "Return B * V, signal error on overflow";
pattern *(b:bat[:oid,:lng],v:bte,accum:int) :bat[:oid,:lng]
address CMDbatMULcstsignal
comment "Return B * V, signal error on overflow, reuse B if ACCUM is set";
pattern mul_noerror(b:bat[:oid,:lng],v:bte) :bat[:oid,:lng]
address CMDbatMULcst
comment "Return B * V, overflow causes NIL value";
pattern *(v:lng,b:bat[:oid,:bte]) :bat[:oid,:lng]
address CMDbatMULcstsignal
comment "Return V * B, signal error on overflow";
pattern mul_noerror(v:lng,b:bat[:oid,:bte]) :bat[:oid,:lng]
address CMDbatMULcst
comment "Return V * B, overflow causes NIL value";

command *(b1:bat[:oid,:lng],b2:bat[:oid,:sht]) :bat[:oid,:lng]
address CMDbatMULsignal
comment "Return B1 * B2, signal error on overflow";
command *(b1:bat[:oid,:lng],b2:bat[:oid,:sht],accum:int) :bat[:oid,:lng]
address CMDbatMULsignalaccum
comment "Return B1 * B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command mul_noerror(b1:bat[:oid,:lng],b2:bat[:oid,:sht]) :bat[:oid,:lng]
address CMDbatMUL
comment "Return B1 * B2, overflow causes NIL value";
pattern *(b:bat[:oid,:lng],v:sht) :bat[:oid,:lng]
address CMDbatMULcstsignal
comment "Return B * V, signal error on overflow";
pattern *(b:bat[:oid,:lng],v:sht,accum:int) :bat[:oid,:lng]
address CMDbatMULcstsignal
comment "Return B * V, signal error on overflow, reuse B if ACCUM is set";
pattern mul_noerror(b:bat[:oid,:lng],v:sht) :bat[:oid,:lng]
address CMDbatMULcst
comment "Return B * V, overflow causes NIL value";
pattern *(v:lng,b:bat[:oid,:sht]) :bat[:oid,:lng]
address CMDbatMULcstsignal
comment "Return V * B, signal error on overflow";
pattern mul_noerror(v:lng,b:bat[:oid,:sht]) :bat[:oid,:lng]
address CMDbatMULcst
comment "Return V * B, overflow causes NIL value";

command *(b1:bat[:oid,:lng],b2:bat[:oid,:int]) :bat[:oid,:lng]
address CMDbatMULsignal
comment "Return B1 * B2, signal error on overflow";
command *(b1:bat[:oid,:lng],b2:bat[:oid,:int],accum:int) :bat[:oid,:lng]
address CMDbatMULsignalaccum
comment "Return B1 * B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command mul_noerror(b1:bat[:oid,:lng],b2:bat[:oid,:int]) :bat[:oid,:lng]
address CMDbatMUL
comment "Return B1 * B2, overflow causes NIL value";
pattern *(b:bat[:oid,:lng],v:int) :bat[:oid,:lng]
address CMDbatMULcstsignal
comment "Return B * V, signal error on overflow";
pattern *(b:bat[:oid,:lng],v:int,accum:int) :bat[:oid,:lng]
address CMDbatMULcstsignal
comment "Return B * V, signal error on overflow, reuse B if ACCUM is set";
pattern mul_noerror(b:bat[:oid,:lng],v:int) :bat[:oid,:lng]
address CMDbatMULcst
comment "Return B * V, overflow causes NIL value";
pattern *(v:lng,b:bat[:oid,:int]) :bat[:oid,:lng]
address CMDbatMULcstsignal
comment "Return V * B, signal error on overflow";
pattern mul_noerror(v:lng,b:bat[:oid,:int]) :bat[:oid,:lng]
address CMDbatMULcst
comment "Return V * B, overflow causes NIL value";

command *(b1:bat[:oid,:lng],b2:bat[:oid,:wrd]) :bat[:oid,:lng]
address CMDbatMULsignal
comment "Return B1 * B2, signal error on overflow";
command *(b1:bat[:oid,:lng],b2:bat[:oid,:wrd],accum:int) :bat[:oid,:lng]
address CMDbatMULsignalaccum
comment "Return B1 * B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command mul_noerror(b1:bat[:oid,:lng],b2:bat[:oid,:wrd]) :bat[:oid,:lng]
address CMDbatMUL
comment "Return B1 * B2, overflow causes NIL value";
pattern *(b:bat[:oid,:lng],v:wrd) :bat[:oid,:lng]
address CMDbatMULcstsignal
comment "Return B * V, signal error on overflow";
pattern *(b:bat[:oid,:lng],v:wrd,accum:int) :bat[:oid,:lng]
address CMDbatMULcstsignal
comment "Return B * V, signal error on overflow, reuse B if ACCUM is set";
pattern mul_noerror(b:bat[:oid,:lng],v:wrd) :bat[:oid,:lng]
address CMDbatMULcst
comment "Return B * V, overflow causes NIL value";
pattern *(v:lng,b:bat[:oid,:wrd]) :bat[:oid,:lng]
address CMDbatMULcstsignal
comment "Return V * B, signal error on overflow";
pattern mul_noerror(v:lng,b:bat[:oid,:wrd]) :bat[:oid,:lng]
address CMDbatMULcst
comment "Return V * B, overflow causes NIL value";

command *(b1:bat[:oid,:lng],b2:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatMULsignal
comment "Return B1 * B2, signal error on overflow";
command *(b1:bat[:oid,:lng],b2:bat[:oid,:lng],accum:int) :bat[:oid,:lng]
address CMDbatMULsignalaccum
comment "Return B1 * B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command mul_noerror(b1:bat[:oid,:lng],b2:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatMUL
comment "Return B1 * B2, overflow causes NIL value";
pattern *(b:bat[:oid,:lng],v:lng) :bat[:oid,:lng]
address CMDbatMULcstsignal
comment "Return B * V, signal error on overflow";
pattern *(b:bat[:oid,:lng],v:lng,accum:int) :bat[:oid,:lng]
address CMDbatMULcstsignal
comment "Return B * V, signal error on overflow, reuse B if ACCUM is set";
pattern mul_noerror(b:bat[:oid,:lng],v:lng) :bat[:oid,:lng]
address CMDbatMULcst
comment "Return B * V, overflow causes NIL value";
pattern *(v:lng,b:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatMULcstsignal
comment "Return V * B, signal error on overflow";
pattern *(v:lng,b:bat[:oid,:lng],accum:int) :bat[:oid,:lng]
address CMDbatMULcstsignal
comment "Return V * B, signal error on overflow, reuse B if ACCUM is set";
pattern mul_noerror(v:lng,b:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatMULcst
comment "Return V * B, overflow causes NIL value";

command *(b1:bat[:oid,:lng],b2:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatMULsignal
comment "Return B1 * B2, signal error on overflow";
command *(b1:bat[:oid,:lng],b2:bat[:oid,:flt],accum:int) :bat[:oid,:flt]
address CMDbatMULsignalaccum
comment "Return B1 * B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command mul_noerror(b1:bat[:oid,:lng],b2:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatMUL
comment "Return B1 * B2, overflow causes NIL value";
pattern *(b:bat[:oid,:lng],v:flt) :bat[:oid,:flt]
address CMDbatMULcstsignal
comment "Return B * V, signal error on overflow";
pattern mul_noerror(b:bat[:oid,:lng],v:flt) :bat[:oid,:flt]
address CMDbatMULcst
comment "Return B * V, overflow causes NIL value";
pattern *(v:lng,b:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatMULcstsignal
comment "Return V * B, signal error on overflow";
pattern *(v:lng,b:bat[:oid,:flt],accum:int) :bat[:oid,:flt]
address CMDbatMULcstsignal
comment "Return V * B, signal error on overflow, reuse B if ACCUM is set";
pattern mul_noerror(v:lng,b:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatMULcst
comment "Return V * B, overflow causes NIL value";

command *(b1:bat[:oid,:lng],b2:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatMULsignal
comment "Return B1 * B2, signal error on overflow";
command *(b1:bat[:oid,:lng],b2:bat[:oid,:dbl],accum:int) :bat[:oid,:dbl]
address CMDbatMULsignalaccum
comment "Return B1 * B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command mul_noerror(b1:bat[:oid,:lng],b2:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatMUL
comment "Return B1 * B2, overflow causes NIL value";
pattern *(b:bat[:oid,:lng],v:dbl) :bat[:oid,:dbl]
address CMDbatMULcstsignal
comment "Return B * V, signal error on overflow";
pattern mul_noerror(b:bat[:oid,:lng],v:dbl) :bat[:oid,:dbl]
address CMDbatMULcst
comment "Return B * V, overflow causes NIL value";
pattern *(v:lng,b:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatMULcstsignal
comment "Return V * B, signal error on overflow";
pattern *(v:lng,b:bat[:oid,:dbl],accum:int) :bat[:oid,:dbl]
address CMDbatMULcstsignal
comment "Return V * B, signal error on overflow, reuse B if ACCUM is set";
pattern mul_noerror(v:lng,b:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatMULcst
comment "Return V * B, overflow causes NIL value";

command *(b1:bat[:oid,:flt],b2:bat[:oid,:bte]) :bat[:oid,:flt]
address CMDbatMULsignal
comment "Return B1 * B2, signal error on overflow";
command *(b1:bat[:oid,:flt],b2:bat[:oid,:bte],accum:int) :bat[:oid,:flt]
address CMDbatMULsignalaccum
comment "Return B1 * B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command mul_noerror(b1:bat[:oid,:flt],b2:bat[:oid,:bte]) :bat[:oid,:flt]
address CMDbatMUL
comment "Return B1 * B2, overflow causes NIL value";
pattern *(b:bat[:oid,:flt],v:bte) :bat[:oid,:flt]
address CMDbatMULcstsignal
comment "Return B * V, signal error on overflow";
pattern *(b:bat[:oid,:flt],v:bte,accum:int) :bat[:oid,:flt]
address CMDbatMULcstsignal
comment "Return B * V, signal error on overflow, reuse B if ACCUM is set";
pattern mul_noerror(b:bat[:oid,:flt],v:bte) :bat[:oid,:flt]
address CMDbatMULcst
comment "Return B * V, overflow causes NIL value";
pattern *(v:flt,b:bat[:oid,:bte]) :bat[:oid,:flt]
address CMDbatMULcstsignal
comment "Return V * B, signal error on overflow";
pattern mul_noerror(v:flt,b:bat[:oid,:bte]) :bat[:oid,:flt]
address CMDbatMULcst
comment "Return V * B, overflow causes NIL value";

command *(b1:bat[:oid,:flt],b2:bat[:oid,:sht]) :bat[:oid,:flt]
address CMDbatMULsignal
comment "Return B1 * B2, signal error on overflow";
command *(b1:bat[:oid,:flt],b2:bat[:oid,:sht],accum:int) :bat[:oid,:flt]
address CMDbatMULsignalaccum
comment "Return B1 * B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command mul_noerror(b1:bat[:oid,:flt],b2:bat[:oid,:sht]) :bat[:oid,:flt]
address CMDbatMUL
comment "Return B1 * B2, overflow causes NIL value";
pattern *(b:bat[:oid,:flt],v:sht) :bat[:oid,:flt]
address CMDbatMULcstsignal
comment "Return B * V, signal error on overflow";
pattern *(b:bat[:oid,:flt],v:sht,accum:int) :bat[:oid,:flt]
address CMDbatMULcstsignal
comment "Return B * V, signal error on overflow, reuse B if ACCUM is set";
pattern mul_noerror(b:bat[:oid,:flt],v:sht) :bat[:oid,:flt]
address CMDbatMULcst
comment "Return B * V, overflow causes NIL value";
pattern *(v:flt,b:bat[:oid,:sht]) :bat[:oid,:flt]
address CMDbatMULcstsignal
comment "Return V * B, signal error on overflow";
pattern mul_noerror(v:flt,b:bat[:oid,:sht]) :bat[:oid,:flt]
address CMDbatMULcst
comment "Return V * B, overflow causes NIL value";

command *(b1:bat[:oid,:flt],b2:bat[:oid,:int]) :bat[:oid,:flt]
address CMDbatMULsignal
comment "Return B1 * B2, signal error on overflow";
command *(b1:bat[:oid,:flt],b2:bat[:oid,:int],accum:int) :bat[:oid,:flt]
address CMDbatMULsignalaccum
comment "Return B1 * B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command mul_noerror(b1:bat[:oid,:flt],b2:bat[:oid,:int]) :bat[:oid,:flt]
address CMDbatMUL
comment "Return B1 * B2, overflow causes NIL value";
pattern *(b:bat[:oid,:flt],v:int) :bat[:oid,:flt]
address CMDbatMULcstsignal
comment "Return B * V, signal error on overflow";
pattern *(b:bat[:oid,:flt],v:int,accum:int) :bat[:oid,:flt]
address CMDbatMULcstsignal
comment "Return B * V, signal error on overflow, reuse B if ACCUM is set";
pattern mul_noerror(b:bat[:oid,:flt],v:int) :bat[:oid,:flt]
address CMDbatMULcst
comment "Return B * V, overflow causes NIL value";
pattern *(v:flt,b:bat[:oid,:int]) :bat[:oid,:flt]
address CMDbatMULcstsignal
comment "Return V * B, signal error on overflow";
pattern mul_noerror(v:flt,b:bat[:oid,:int]) :bat[:oid,:flt]
address CMDbatMULcst
comment "Return V * B, overflow causes NIL value";

command *(b1:bat[:oid,:flt],b2:bat[:oid,:wrd]) :bat[:oid,:flt]
address CMDbatMULsignal
comment "Return B1 * B2, signal error on overflow";
command *(b1:bat[:oid,:flt],b2:bat[:oid,:wrd],accum:int) :bat[:oid,:flt]
address CMDbatMULsignalaccum
comment "Return B1 * B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command mul_noerror(b1:bat[:oid,:flt],b2:bat[:oid,:wrd]) :bat[:oid,:flt]
address CMDbatMUL
comment "Return B1 * B2, overflow causes NIL value";
pattern *(b:bat[:oid,:flt],v:wrd) :bat[:oid,:flt]
address CMDbatMULcstsignal
comment "Return B * V, signal error on overflow";
pattern *(b:bat[:oid,:flt],v:wrd,accum:int) :bat[:oid,:flt]
address CMDbatMULcstsignal
comment "Return B * V, signal error on overflow, reuse B if ACCUM is set";
pattern mul_noerror(b:bat[:oid,:flt],v:wrd) :bat[:oid,:flt]
address CMDbatMULcst
comment "Return B * V, overflow causes NIL value";
pattern *(v:flt,b:bat[:oid,:wrd]) :bat[:oid,:flt]
address CMDbatMULcstsignal
comment "Return V * B, signal error on overflow";
pattern mul_noerror(v:flt,b:bat[:oid,:wrd]) :bat[:oid,:flt]
address CMDbatMULcst
comment "Return V * B, overflow causes NIL value";

command *(b1:bat[:oid,:flt],b2:bat[:oid,:lng]) :bat[:oid,:flt]
address CMDbatMULsignal
comment "Return B1 * B2, signal error on overflow";
command *(b1:bat[:oid,:flt],b2:bat[:oid,:lng],accum:int) :bat[:oid,:flt]
address CMDbatMULsignalaccum
comment "Return B1 * B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command mul_noerror(b1:bat[:oid,:flt],b2:bat[:oid,:lng]) :bat[:oid,:flt]
address CMDbatMUL
comment "Return B1 * B2, overflow causes NIL value";
pattern *(b:bat[:oid,:flt],v:lng) :bat[:oid,:flt]
address CMDbatMULcstsignal
comment "Return B * V, signal error on overflow";
pattern *(b:bat[:oid,:flt],v:lng,accum:int) :bat[:oid,:flt]
address CMDbatMULcstsignal
comment "Return B * V, signal error on overflow, reuse B if ACCUM is set";
pattern mul_noerror(b:bat[:oid,:flt],v:lng) :bat[:oid,:flt]
address CMDbatMULcst
comment "Return B * V, overflow causes NIL value";
pattern *(v:flt,b:bat[:oid,:lng]) :bat[:oid,:flt]
address CMDbatMULcstsignal
comment "Return V * B, signal error on overflow";
pattern mul_noerror(v:flt,b:bat[:oid,:lng]) :bat[:oid,:flt]
address CMDbatMULcst
comment "Return V * B, overflow causes NIL value";

command *(b1:bat[:oid,:flt],b2:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatMULsignal
comment "Return B1 * B2, signal error on overflow";
command *(b1:bat[:oid,:flt],b2:bat[:oid,:flt],accum:int) :bat[:oid,:flt]
address CMDbatMULsignalaccum
comment "Return B1 * B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command mul_noerror(b1:bat[:oid,:flt],b2:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatMUL
comment "Return B1 * B2, overflow causes NIL value";
pattern *(b:bat[:oid,:flt],v:flt) :bat[:oid,:flt]
address CMDbatMULcstsignal
comment "Return B * V, signal error on overflow";
pattern *(b:bat[:oid,:flt],v:flt,accum:int) :bat[:oid,:flt]
address CMDbatMULcstsignal
comment "Return B * V, signal error on overflow, reuse B if ACCUM is set";
pattern mul_noerror(b:bat[:oid,:flt],v:flt) :bat[:oid,:flt]
address CMDbatMULcst
comment "Return B * V, overflow causes NIL value";
pattern *(v:flt,b:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatMULcstsignal
comment "Return V * B, signal error on overflow";
pattern *(v:flt,b:bat[:oid,:flt],accum:int) :bat[:oid,:flt]
address CMDbatMULcstsignal
comment "Return V * B, signal error on overflow, reuse B if ACCUM is set";
pattern mul_noerror(v:flt,b:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatMULcst
comment "Return V * B, overflow causes NIL value";

command *(b1:bat[:oid,:flt],b2:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatMULsignal
comment "Return B1 * B2, signal error on overflow";
command *(b1:bat[:oid,:flt],b2:bat[:oid,:dbl],accum:int) :bat[:oid,:dbl]
address CMDbatMULsignalaccum
comment "Return B1 * B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command mul_noerror(b1:bat[:oid,:flt],b2:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatMUL
comment "Return B1 * B2, overflow causes NIL value";
pattern *(b:bat[:oid,:flt],v:dbl) :bat[:oid,:dbl]
address CMDbatMULcstsignal
comment "Return B * V, signal error on overflow";
pattern mul_noerror(b:bat[:oid,:flt],v:dbl) :bat[:oid,:dbl]
address CMDbatMULcst
comment "Return B * V, overflow causes NIL value";
pattern *(v:flt,b:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatMULcstsignal
comment "Return V * B, signal error on overflow";
pattern *(v:flt,b:bat[:oid,:dbl],accum:int) :bat[:oid,:dbl]
address CMDbatMULcstsignal
comment "Return V * B, signal error on overflow, reuse B if ACCUM is set";
pattern mul_noerror(v:flt,b:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatMULcst
comment "Return V * B, overflow causes NIL value";

command *(b1:bat[:oid,:dbl],b2:bat[:oid,:bte]) :bat[:oid,:dbl]
address CMDbatMULsignal
comment "Return B1 * B2, signal error on overflow";
command *(b1:bat[:oid,:dbl],b2:bat[:oid,:bte],accum:int) :bat[:oid,:dbl]
address CMDbatMULsignalaccum
comment "Return B1 * B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command mul_noerror(b1:bat[:oid,:dbl],b2:bat[:oid,:bte]) :bat[:oid,:dbl]
address CMDbatMUL
comment "Return B1 * B2, overflow causes NIL value";
pattern *(b:bat[:oid,:dbl],v:bte) :bat[:oid,:dbl]
address CMDbatMULcstsignal
comment "Return B * V, signal error on overflow";
pattern *(b:bat[:oid,:dbl],v:bte,accum:int) :bat[:oid,:dbl]
address CMDbatMULcstsignal
comment "Return B * V, signal error on overflow, reuse B if ACCUM is set";
pattern mul_noerror(b:bat[:oid,:dbl],v:bte) :bat[:oid,:dbl]
address CMDbatMULcst
comment "Return B * V, overflow causes NIL value";
pattern *(v:dbl,b:bat[:oid,:bte]) :bat[:oid,:dbl]
address CMDbatMULcstsignal
comment "Return V * B, signal error on overflow";
pattern mul_noerror(v:dbl,b:bat[:oid,:bte]) :bat[:oid,:dbl]
address CMDbatMULcst
comment "Return V * B, overflow causes NIL value";

command *(b1:bat[:oid,:dbl],b2:bat[:oid,:sht]) :bat[:oid,:dbl]
address CMDbatMULsignal
comment "Return B1 * B2, signal error on overflow";
command *(b1:bat[:oid,:dbl],b2:bat[:oid,:sht],accum:int) :bat[:oid,:dbl]
address CMDbatMULsignalaccum
comment "Return B1 * B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command mul_noerror(b1:bat[:oid,:dbl],b2:bat[:oid,:sht]) :bat[:oid,:dbl]
address CMDbatMUL
comment "Return B1 * B2, overflow causes NIL value";
pattern *(b:bat[:oid,:dbl],v:sht) :bat[:oid,:dbl]
address CMDbatMULcstsignal
comment "Return B * V, signal error on overflow";
pattern *(b:bat[:oid,:dbl],v:sht,accum:int) :bat[:oid,:dbl]
address CMDbatMULcstsignal
comment "Return B * V, signal error on overflow, reuse B if ACCUM is set";
pattern mul_noerror(b:bat[:oid,:dbl],v:sht) :bat[:oid,:dbl]
address CMDbatMULcst
comment "Return B * V, overflow causes NIL value";
pattern *(v:dbl,b:bat[:oid,:sht]) :bat[:oid,:dbl]
address CMDbatMULcstsignal
comment "Return V * B, signal error on overflow";
pattern mul_noerror(v:dbl,b:bat[:oid,:sht]) :bat[:oid,:dbl]
address CMDbatMULcst
comment "Return V * B, overflow causes NIL value";

command *(b1:bat[:oid,:dbl],b2:bat[:oid,:int]) :bat[:oid,:dbl]
address CMDbatMULsignal
comment "Return B1 * B2, signal error on overflow";
command *(b1:bat[:oid,:dbl],b2:bat[:oid,:int],accum:int) :bat[:oid,:dbl]
address CMDbatMULsignalaccum
comment "Return B1 * B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command mul_noerror(b1:bat[:oid,:dbl],b2:bat[:oid,:int]) :bat[:oid,:dbl]
address CMDbatMUL
comment "Return B1 * B2, overflow causes NIL value";
pattern *(b:bat[:oid,:dbl],v:int) :bat[:oid,:dbl]
address CMDbatMULcstsignal
comment "Return B * V, signal error on overflow";
pattern *(b:bat[:oid,:dbl],v:int,accum:int) :bat[:oid,:dbl]
address CMDbatMULcstsignal
comment "Return B * V, signal error on overflow, reuse B if ACCUM is set";
pattern mul_noerror(b:bat[:oid,:dbl],v:int) :bat[:oid,:dbl]
address CMDbatMULcst
comment "Return B * V, overflow causes NIL value";
pattern *(v:dbl,b:bat[:oid,:int]) :bat[:oid,:dbl]
address CMDbatMULcstsignal
comment "Return V * B, signal error on overflow";
pattern mul_noerror(v:dbl,b:bat[:oid,:int]) :bat[:oid,:dbl]
address CMDbatMULcst
comment "Return V * B, overflow causes NIL value";

command *(b1:bat[:oid,:dbl],b2:bat[:oid,:wrd]) :bat[:oid,:dbl]
address CMDbatMULsignal
comment "Return B1 * B2, signal error on overflow";
command *(b1:bat[:oid,:dbl],b2:bat[:oid,:wrd],accum:int) :bat[:oid,:dbl]
address CMDbatMULsignalaccum
comment "Return B1 * B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command mul_noerror(b1:bat[:oid,:dbl],b2:bat[:oid,:wrd]) :bat[:oid,:dbl]
address CMDbatMUL
comment "Return B1 * B2, overflow causes NIL value";
pattern *(b:bat[:oid,:dbl],v:wrd) :bat[:oid,:dbl]
address CMDbatMULcstsignal
comment "Return B * V, signal error on overflow";
pattern *(b:bat[:oid,:dbl],v:wrd,accum:int) :bat[:oid,:dbl]
address CMDbatMULcstsignal
comment "Return B * V, signal error on overflow, reuse B if ACCUM is set";
pattern mul_noerror(b:bat[:oid,:dbl],v:wrd) :bat[:oid,:dbl]
address CMDbatMULcst
comment "Return B * V, overflow causes NIL value";
pattern *(v:dbl,b:bat[:oid,:wrd]) :bat[:oid,:dbl]
address CMDbatMULcstsignal
comment "Return V * B, signal error on overflow";
pattern mul_noerror(v:dbl,b:bat[:oid,:wrd]) :bat[:oid,:dbl]
address CMDbatMULcst
comment "Return V * B, overflow causes NIL value";

command *(b1:bat[:oid,:dbl],b2:bat[:oid,:lng]) :bat[:oid,:dbl]
address CMDbatMULsignal
comment "Return B1 * B2, signal error on overflow";
command *(b1:bat[:oid,:dbl],b2:bat[:oid,:lng],accum:int) :bat[:oid,:dbl]
address CMDbatMULsignalaccum
comment "Return B1 * B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command mul_noerror(b1:bat[:oid,:dbl],b2:bat[:oid,:lng]) :bat[:oid,:dbl]
address CMDbatMUL
comment "Return B1 * B2, overflow causes NIL value";
pattern *(b:bat[:oid,:dbl],v:lng) :bat[:oid,:dbl]
address CMDbatMULcstsignal
comment "Return B * V, signal error on overflow";
pattern *(b:bat[:oid,:dbl],v:lng,accum:int) :bat[:oid,:dbl]
address CMDbatMULcstsignal
comment "Return B * V, signal error on overflow, reuse B if ACCUM is set";
pattern mul_noerror(b:bat[:oid,:dbl],v:lng) :bat[:oid,:dbl]
address CMDbatMULcst
comment "Return B * V, overflow causes NIL value";
pattern *(v:dbl,b:bat[:oid,:lng]) :bat[:oid,:dbl]
address CMDbatMULcstsignal
comment "Return V * B, signal error on overflow";
pattern mul_noerror(v:dbl,b:bat[:oid,:lng]) :bat[:oid,:dbl]
address CMDbatMULcst
comment "Return V * B, overflow causes NIL value";

command *(b1:bat[:oid,:dbl],b2:bat[:oid,:flt]) :bat[:oid,:dbl]
address CMDbatMULsignal
comment "Return B1 * B2, signal error on overflow";
command *(b1:bat[:oid,:dbl],b2:bat[:oid,:flt],accum:int) :bat[:oid,:dbl]
address CMDbatMULsignalaccum
comment "Return B1 * B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command mul_noerror(b1:bat[:oid,:dbl],b2:bat[:oid,:flt]) :bat[:oid,:dbl]
address CMDbatMUL
comment "Return B1 * B2, overflow causes NIL value";
pattern *(b:bat[:oid,:dbl],v:flt) :bat[:oid,:dbl]
address CMDbatMULcstsignal
comment "Return B * V, signal error on overflow";
pattern *(b:bat[:oid,:dbl],v:flt,accum:int) :bat[:oid,:dbl]
address CMDbatMULcstsignal
comment "Return B * V, signal error on overflow, reuse B if ACCUM is set";
pattern mul_noerror(b:bat[:oid,:dbl],v:flt) :bat[:oid,:dbl]
address CMDbatMULcst
comment "Return B * V, overflow causes NIL value";
pattern *(v:dbl,b:bat[:oid,:flt]) :bat[:oid,:dbl]
address CMDbatMULcstsignal
comment "Return V * B, signal error on overflow";
pattern mul_noerror(v:dbl,b:bat[:oid,:flt]) :bat[:oid,:dbl]
address CMDbatMULcst
comment "Return V * B, overflow causes NIL value";

command *(b1:bat[:oid,:dbl],b2:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatMULsignal
comment "Return B1 * B2, signal error on overflow";
command *(b1:bat[:oid,:dbl],b2:bat[:oid,:dbl],accum:int) :bat[:oid,:dbl]
address CMDbatMULsignalaccum
comment "Return B1 * B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command mul_noerror(b1:bat[:oid,:dbl],b2:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatMUL
comment "Return B1 * B2, overflow causes NIL value";
pattern *(b:bat[:oid,:dbl],v:dbl) :bat[:oid,:dbl]
address CMDbatMULcstsignal
comment "Return B * V, signal error on overflow";
pattern *(b:bat[:oid,:dbl],v:dbl,accum:int) :bat[:oid,:dbl]
address CMDbatMULcstsignal
comment "Return B * V, signal error on overflow, reuse B if ACCUM is set";
pattern mul_noerror(b:bat[:oid,:dbl],v:dbl) :bat[:oid,:dbl]
address CMDbatMULcst
comment "Return B * V, overflow causes NIL value";
pattern *(v:dbl,b:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatMULcstsignal
comment "Return V * B, signal error on overflow";
pattern *(v:dbl,b:bat[:oid,:dbl],accum:int) :bat[:oid,:dbl]
address CMDbatMULcstsignal
comment "Return V * B, signal error on overflow, reuse B if ACCUM is set";
pattern mul_noerror(v:dbl,b:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatMULcst
comment "Return V * B, overflow causes NIL value";


command /(b1:bat[:oid,:bte],b2:bat[:oid,:bte]) :bat[:oid,:bte]
address CMDbatDIVsignal
comment "Return B1 / B2, signal error on overflow";
command /(b1:bat[:oid,:bte],b2:bat[:oid,:bte],accum:int) :bat[:oid,:bte]
address CMDbatDIVsignalaccum
comment "Return B1 / B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command div_noerror(b1:bat[:oid,:bte],b2:bat[:oid,:bte]) :bat[:oid,:bte]
address CMDbatDIV
comment "Return B1 / B2, overflow causes NIL value";
pattern /(b:bat[:oid,:bte],v:bte) :bat[:oid,:bte]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow";
pattern /(b:bat[:oid,:bte],v:bte,accum:int) :bat[:oid,:bte]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow, reuse B if ACCUM is set";
pattern div_noerror(b:bat[:oid,:bte],v:bte) :bat[:oid,:bte]
address CMDbatDIVcst
comment "Return B / V, overflow causes NIL value";
pattern /(v:bte,b:bat[:oid,:bte]) :bat[:oid,:bte]
address CMDbatDIVcstsignal
comment "Return V / B, signal error on overflow";
pattern /(v:bte,b:bat[:oid,:bte],accum:int) :bat[:oid,:bte]
address CMDbatDIVcstsignal
comment "Return V / B, signal error on overflow, reuse B if ACCUM is set";
pattern div_noerror(v:bte,b:bat[:oid,:bte]) :bat[:oid,:bte]
address CMDbatDIVcst
comment "Return V / B, overflow causes NIL value";

command /(b1:bat[:oid,:bte],b2:bat[:oid,:sht]) :bat[:oid,:bte]
address CMDbatDIVsignal
comment "Return B1 / B2, signal error on overflow";
command /(b1:bat[:oid,:bte],b2:bat[:oid,:sht],accum:int) :bat[:oid,:bte]
address CMDbatDIVsignalaccum
comment "Return B1 / B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command div_noerror(b1:bat[:oid,:bte],b2:bat[:oid,:sht]) :bat[:oid,:bte]
address CMDbatDIV
comment "Return B1 / B2, overflow causes NIL value";
pattern /(b:bat[:oid,:bte],v:sht) :bat[:oid,:bte]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow";
pattern /(b:bat[:oid,:bte],v:sht,accum:int) :bat[:oid,:bte]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow, reuse B if ACCUM is set";
pattern div_noerror(b:bat[:oid,:bte],v:sht) :bat[:oid,:bte]
address CMDbatDIVcst
comment "Return B / V, overflow causes NIL value";
pattern /(v:bte,b:bat[:oid,:sht]) :bat[:oid,:bte]
address CMDbatDIVcstsignal
comment "Return V / B, signal error on overflow";
pattern div_noerror(v:bte,b:bat[:oid,:sht]) :bat[:oid,:bte]
address CMDbatDIVcst
comment "Return V / B, overflow causes NIL value";

command /(b1:bat[:oid,:bte],b2:bat[:oid,:int]) :bat[:oid,:bte]
address CMDbatDIVsignal
comment "Return B1 / B2, signal error on overflow";
command /(b1:bat[:oid,:bte],b2:bat[:oid,:int],accum:int) :bat[:oid,:bte]
address CMDbatDIVsignalaccum
comment "Return B1 / B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command div_noerror(b1:bat[:oid,:bte],b2:bat[:oid,:int]) :bat[:oid,:bte]
address CMDbatDIV
comment "Return B1 / B2, overflow causes NIL value";
pattern /(b:bat[:oid,:bte],v:int) :bat[:oid,:bte]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow";
pattern /(b:bat[:oid,:bte],v:int,accum:int) :bat[:oid,:bte]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow, reuse B if ACCUM is set";
pattern div_noerror(b:bat[:oid,:bte],v:int) :bat[:oid,:bte]
address CMDbatDIVcst
comment "Return B / V, overflow causes NIL value";
pattern /(v:bte,b:bat[:oid,:int]) :bat[:oid,:bte]
address CMDbatDIVcstsignal
comment "Return V / B, signal error on overflow";
pattern div_noerror(v:bte,b:bat[:oid,:int]) :bat[:oid,:bte]
address CMDbatDIVcst
comment "Return V / B, overflow causes NIL value";

command /(b1:bat[:oid,:bte],b2:bat[:oid,:wrd]) :bat[:oid,:bte]
address CMDbatDIVsignal
comment "Return B1 / B2, signal error on overflow";
command /(b1:bat[:oid,:bte],b2:bat[:oid,:wrd],accum:int) :bat[:oid,:bte]
address CMDbatDIVsignalaccum
comment "Return B1 / B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command div_noerror(b1:bat[:oid,:bte],b2:bat[:oid,:wrd]) :bat[:oid,:bte]
address CMDbatDIV
comment "Return B1 / B2, overflow causes NIL value";
pattern /(b:bat[:oid,:bte],v:wrd) :bat[:oid,:bte]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow";
pattern /(b:bat[:oid,:bte],v:wrd,accum:int) :bat[:oid,:bte]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow, reuse B if ACCUM is set";
pattern div_noerror(b:bat[:oid,:bte],v:wrd) :bat[:oid,:bte]
address CMDbatDIVcst
comment "Return B / V, overflow causes NIL value";
pattern /(v:bte,b:bat[:oid,:wrd]) :bat[:oid,:bte]
address CMDbatDIVcstsignal
comment "Return V / B, signal error on overflow";
pattern div_noerror(v:bte,b:bat[:oid,:wrd]) :bat[:oid,:bte]
address CMDbatDIVcst
comment "Return V / B, overflow causes NIL value";

command /(b1:bat[:oid,:bte],b2:bat[:oid,:lng]) :bat[:oid,:bte]
address CMDbatDIVsignal
comment "Return B1 / B2, signal error on overflow";
command /(b1:bat[:oid,:bte],b2:bat[:oid,:lng],accum:int) :bat[:oid,:bte]
address CMDbatDIVsignalaccum
comment "Return B1 / B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command div_noerror(b1:bat[:oid,:bte],b2:bat[:oid,:lng]) :bat[:oid,:bte]
address CMDbatDIV
comment "Return B1 / B2, overflow causes NIL value";
pattern /(b:bat[:oid,:bte],v:lng) :bat[:oid,:bte]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow";
pattern /(b:bat[:oid,:bte],v:lng,accum:int) :bat[:oid,:bte]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow, reuse B if ACCUM is set";
pattern div_noerror(b:bat[:oid,:bte],v:lng) :bat[:oid,:bte]
address CMDbatDIVcst
comment "Return B / V, overflow causes NIL value";
pattern /(v:bte,b:bat[:oid,:lng]) :bat[:oid,:bte]
address CMDbatDIVcstsignal
comment "Return V / B, signal error on overflow";
pattern div_noerror(v:bte,b:bat[:oid,:lng]) :bat[:oid,:bte]
address CMDbatDIVcst
comment "Return V / B, overflow causes NIL value";

command /(b1:bat[:oid,:bte],b2:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatDIVsignal
comment "Return B1 / B2, signal error on overflow";
command /(b1:bat[:oid,:bte],b2:bat[:oid,:flt],accum:int) :bat[:oid,:flt]
address CMDbatDIVsignalaccum
comment "Return B1 / B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command div_noerror(b1:bat[:oid,:bte],b2:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatDIV
comment "Return B1 / B2, overflow causes NIL value";
pattern /(b:bat[:oid,:bte],v:flt) :bat[:oid,:flt]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow";
pattern div_noerror(b:bat[:oid,:bte],v:flt) :bat[:oid,:flt]
address CMDbatDIVcst
comment "Return B / V, overflow causes NIL value";
pattern /(v:bte,b:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatDIVcstsignal
comment "Return V / B, signal error on overflow";
pattern /(v:bte,b:bat[:oid,:flt],accum:int) :bat[:oid,:flt]
address CMDbatDIVcstsignal
comment "Return V / B, signal error on overflow, reuse B if ACCUM is set";
pattern div_noerror(v:bte,b:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatDIVcst
comment "Return V / B, overflow causes NIL value";

command /(b1:bat[:oid,:bte],b2:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatDIVsignal
comment "Return B1 / B2, signal error on overflow";
command /(b1:bat[:oid,:bte],b2:bat[:oid,:dbl],accum:int) :bat[:oid,:dbl]
address CMDbatDIVsignalaccum
comment "Return B1 / B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command div_noerror(b1:bat[:oid,:bte],b2:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatDIV
comment "Return B1 / B2, overflow causes NIL value";
pattern /(b:bat[:oid,:bte],v:dbl) :bat[:oid,:dbl]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow";
pattern div_noerror(b:bat[:oid,:bte],v:dbl) :bat[:oid,:dbl]
address CMDbatDIVcst
comment "Return B / V, overflow causes NIL value";
pattern /(v:bte,b:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatDIVcstsignal
comment "Return V / B, signal error on overflow";
pattern /(v:bte,b:bat[:oid,:dbl],accum:int) :bat[:oid,:dbl]
address CMDbatDIVcstsignal
comment "Return V / B, signal error on overflow, reuse B if ACCUM is set";
pattern div_noerror(v:bte,b:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatDIVcst
comment "Return V / B, overflow causes NIL value";

command /(b1:bat[:oid,:sht],b2:bat[:oid,:bte]) :bat[:oid,:sht]
address CMDbatDIVsignal
comment "Return B1 / B2, signal error on overflow";
command /(b1:bat[:oid,:sht],b2:bat[:oid,:bte],accum:int) :bat[:oid,:sht]
address CMDbatDIVsignalaccum
comment "Return B1 / B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command div_noerror(b1:bat[:oid,:sht],b2:bat[:oid,:bte]) :bat[:oid,:sht]
address CMDbatDIV
comment "Return B1 / B2, overflow causes NIL value";
pattern /(b:bat[:oid,:sht],v:bte) :bat[:oid,:sht]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow";
pattern /(b:bat[:oid,:sht],v:bte,accum:int) :bat[:oid,:sht]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow, reuse B if ACCUM is set";
pattern div_noerror(b:bat[:oid,:sht],v:bte) :bat[:oid,:sht]
address CMDbatDIVcst
comment "Return B / V, overflow causes NIL value";
pattern /(v:sht,b:bat[:oid,:bte]) :bat[:oid,:sht]
address CMDbatDIVcstsignal
comment "Return V / B, signal error on overflow";
pattern div_noerror(v:sht,b:bat[:oid,:bte]) :bat[:oid,:sht]
address CMDbatDIVcst
comment "Return V / B, overflow causes NIL value";

command /(b1:bat[:oid,:sht],b2:bat[:oid,:sht]) :bat[:oid,:sht]
address CMDbatDIVsignal
comment "Return B1 / B2, signal error on overflow";
command /(b1:bat[:oid,:sht],b2:bat[:oid,:sht],accum:int) :bat[:oid,:sht]
address CMDbatDIVsignalaccum
comment "Return B1 / B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command div_noerror(b1:bat[:oid,:sht],b2:bat[:oid,:sht]) :bat[:oid,:sht]
address CMDbatDIV
comment "Return B1 / B2, overflow causes NIL value";
pattern /(b:bat[:oid,:sht],v:sht) :bat[:oid,:sht]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow";
pattern /(b:bat[:oid,:sht],v:sht,accum:int) :bat[:oid,:sht]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow, reuse B if ACCUM is set";
pattern div_noerror(b:bat[:oid,:sht],v:sht) :bat[:oid,:sht]
address CMDbatDIVcst
comment "Return B / V, overflow causes NIL value";
pattern /(v:sht,b:bat[:oid,:sht]) :bat[:oid,:sht]
address CMDbatDIVcstsignal
comment "Return V / B, signal error on overflow";
pattern /(v:sht,b:bat[:oid,:sht],accum:int) :bat[:oid,:sht]
address CMDbatDIVcstsignal
comment "Return V / B, signal error on overflow, reuse B if ACCUM is set";
pattern div_noerror(v:sht,b:bat[:oid,:sht]) :bat[:oid,:sht]
address CMDbatDIVcst
comment "Return V / B, overflow causes NIL value";

command /(b1:bat[:oid,:sht],b2:bat[:oid,:int]) :bat[:oid,:sht]
address CMDbatDIVsignal
comment "Return B1 / B2, signal error on overflow";
command /(b1:bat[:oid,:sht],b2:bat[:oid,:int],accum:int) :bat[:oid,:sht]
address CMDbatDIVsignalaccum
comment "Return B1 / B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command div_noerror(b1:bat[:oid,:sht],b2:bat[:oid,:int]) :bat[:oid,:sht]
address CMDbatDIV
comment "Return B1 / B2, overflow causes NIL value";
pattern /(b:bat[:oid,:sht],v:int) :bat[:oid,:sht]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow";
pattern /(b:bat[:oid,:sht],v:int,accum:int) :bat[:oid,:sht]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow, reuse B if ACCUM is set";
pattern div_noerror(b:bat[:oid,:sht],v:int) :bat[:oid,:sht]
address CMDbatDIVcst
comment "Return B / V, overflow causes NIL value";
pattern /(v:sht,b:bat[:oid,:int]) :bat[:oid,:sht]
address CMDbatDIVcstsignal
comment "Return V / B, signal error on overflow";
pattern div_noerror(v:sht,b:bat[:oid,:int]) :bat[:oid,:sht]
address CMDbatDIVcst
comment "Return V / B, overflow causes NIL value";

command /(b1:bat[:oid,:sht],b2:bat[:oid,:wrd]) :bat[:oid,:sht]
address CMDbatDIVsignal
comment "Return B1 / B2, signal error on overflow";
command /(b1:bat[:oid,:sht],b2:bat[:oid,:wrd],accum:int) :bat[:oid,:sht]
address CMDbatDIVsignalaccum
comment "Return B1 / B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command div_noerror(b1:bat[:oid,:sht],b2:bat[:oid,:wrd]) :bat[:oid,:sht]
address CMDbatDIV
comment "Return B1 / B2, overflow causes NIL value";
pattern /(b:bat[:oid,:sht],v:wrd) :bat[:oid,:sht]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow";
pattern /(b:bat[:oid,:sht],v:wrd,accum:int) :bat[:oid,:sht]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow, reuse B if ACCUM is set";
pattern div_noerror(b:bat[:oid,:sht],v:wrd) :bat[:oid,:sht]
address CMDbatDIVcst
comment "Return B / V, overflow causes NIL value";
pattern /(v:sht,b:bat[:oid,:wrd]) :bat[:oid,:sht]
address CMDbatDIVcstsignal
comment "Return V / B, signal error on overflow";
pattern div_noerror(v:sht,b:bat[:oid,:wrd]) :bat[:oid,:sht]
address CMDbatDIVcst
comment "Return V / B, overflow causes NIL value";

command /(b1:bat[:oid,:sht],b2:bat[:oid,:lng]) :bat[:oid,:sht]
address CMDbatDIVsignal
comment "Return B1 / B2, signal error on overflow";
command /(b1:bat[:oid,:sht],b2:bat[:oid,:lng],accum:int) :bat[:oid,:sht]
address CMDbatDIVsignalaccum
comment "Return B1 / B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command div_noerror(b1:bat[:oid,:sht],b2:bat[:oid,:lng]) :bat[:oid,:sht]
address CMDbatDIV
comment "Return B1 / B2, overflow causes NIL value";
pattern /(b:bat[:oid,:sht],v:lng) :bat[:oid,:sht]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow";
pattern /(b:bat[:oid,:sht],v:lng,accum:int) :bat[:oid,:sht]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow, reuse B if ACCUM is set";
pattern div_noerror(b:bat[:oid,:sht],v:lng) :bat[:oid,:sht]
address CMDbatDIVcst
comment "Return B / V, overflow causes NIL value";
pattern /(v:sht,b:bat[:oid,:lng]) :bat[:oid,:sht]
address CMDbatDIVcstsignal
comment "Return V / B, signal error on overflow";
pattern div_noerror(v:sht,b:bat[:oid,:lng]) :bat[:oid,:sht]
address CMDbatDIVcst
comment "Return V / B, overflow causes NIL value";

command /(b1:bat[:oid,:sht],b2:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatDIVsignal
comment "Return B1 / B2, signal error on overflow";
command /(b1:bat[:oid,:sht],b2:bat[:oid,:flt],accum:int) :bat[:oid,:flt]
address CMDbatDIVsignalaccum
comment "Return B1 / B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command div_noerror(b1:bat[:oid,:sht],b2:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatDIV
comment "Return B1 / B2, overflow causes NIL value";
pattern /(b:bat[:oid,:sht],v:flt) :bat[:oid,:flt]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow";
pattern div_noerror(b:bat[:oid,:sht],v:flt) :bat[:oid,:flt]
address CMDbatDIVcst
comment "Return B / V, overflow causes NIL value";
pattern /(v:sht,b:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatDIVcstsignal
comment "Return V / B, signal error on overflow";
pattern /(v:sht,b:bat[:oid,:flt],accum:int) :bat[:oid,:flt]
address CMDbatDIVcstsignal
comment "Return V / B, signal error on overflow, reuse B if ACCUM is set";
pattern div_noerror(v:sht,b:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatDIVcst
comment "Return V / B, overflow causes NIL value";

command /(b1:bat[:oid,:sht],b2:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatDIVsignal
comment "Return B1 / B2, signal error on overflow";
command /(b1:bat[:oid,:sht],b2:bat[:oid,:dbl],accum:int) :bat[:oid,:dbl]
address CMDbatDIVsignalaccum
comment "Return B1 / B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command div_noerror(b1:bat[:oid,:sht],b2:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatDIV
comment "Return B1 / B2, overflow causes NIL value";
pattern /(b:bat[:oid,:sht],v:dbl) :bat[:oid,:dbl]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow";
pattern div_noerror(b:bat[:oid,:sht],v:dbl) :bat[:oid,:dbl]
address CMDbatDIVcst
comment "Return B / V, overflow causes NIL value";
pattern /(v:sht,b:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatDIVcstsignal
comment "Return V / B, signal error on overflow";
pattern /(v:sht,b:bat[:oid,:dbl],accum:int) :bat[:oid,:dbl]
address CMDbatDIVcstsignal
comment "Return V / B, signal error on overflow, reuse B if ACCUM is set";
pattern div_noerror(v:sht,b:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatDIVcst
comment "Return V / B, overflow causes NIL value";

command /(b1:bat[:oid,:int],b2:bat[:oid,:bte]) :bat[:oid,:int]
address CMDbatDIVsignal
comment "Return B1 / B2, signal error on overflow";
command /(b1:bat[:oid,:int],b2:bat[:oid,:bte],accum:int) :bat[:oid,:int]
address CMDbatDIVsignalaccum
comment "Return B1 / B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command div_noerror(b1:bat[:oid,:int],b2:bat[:oid,:bte]) :bat[:oid,:int]
address CMDbatDIV
comment "Return B1 / B2, overflow causes NIL value";
pattern /(b:bat[:oid,:int],v:bte) :bat[:oid,:int]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow";
pattern /(b:bat[:oid,:int],v:bte,accum:int) :bat[:oid,:int]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow, reuse B if ACCUM is set";
pattern div_noerror(b:bat[:oid,:int],v:bte) :bat[:oid,:int]
address CMDbatDIVcst
comment "Return B / V, overflow causes NIL value";
pattern /(v:int,b:bat[:oid,:bte]) :bat[:oid,:int]
address CMDbatDIVcstsignal
comment "Return V / B, signal error on overflow";
pattern div_noerror(v:int,b:bat[:oid,:bte]) :bat[:oid,:int]
address CMDbatDIVcst
comment "Return V / B, overflow causes NIL value";

command /(b1:bat[:oid,:int],b2:bat[:oid,:sht]) :bat[:oid,:int]
address CMDbatDIVsignal
comment "Return B1 / B2, signal error on overflow";
command /(b1:bat[:oid,:int],b2:bat[:oid,:sht],accum:int) :bat[:oid,:int]
address CMDbatDIVsignalaccum
comment "Return B1 / B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command div_noerror(b1:bat[:oid,:int],b2:bat[:oid,:sht]) :bat[:oid,:int]
address CMDbatDIV
comment "Return B1 / B2, overflow causes NIL value";
pattern /(b:bat[:oid,:int],v:sht) :bat[:oid,:int]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow";
pattern /(b:bat[:oid,:int],v:sht,accum:int) :bat[:oid,:int]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow, reuse B if ACCUM is set";
pattern div_noerror(b:bat[:oid,:int],v:sht) :bat[:oid,:int]
address CMDbatDIVcst
comment "Return B / V, overflow causes NIL value";
pattern /(v:int,b:bat[:oid,:sht]) :bat[:oid,:int]
address CMDbatDIVcstsignal
comment "Return V / B, signal error on overflow";
pattern div_noerror(v:int,b:bat[:oid,:sht]) :bat[:oid,:int]
address CMDbatDIVcst
comment "Return V / B, overflow causes NIL value";

command /(b1:bat[:oid,:int],b2:bat[:oid,:int]) :bat[:oid,:int]
address CMDbatDIVsignal
comment "Return B1 / B2, signal error on overflow";
command /(b1:bat[:oid,:int],b2:bat[:oid,:int],accum:int) :bat[:oid,:int]
address CMDbatDIVsignalaccum
comment "Return B1 / B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command div_noerror(b1:bat[:oid,:int],b2:bat[:oid,:int]) :bat[:oid,:int]
address CMDbatDIV
comment "Return B1 / B2, overflow causes NIL value";
pattern /(b:bat[:oid,:int],v:int) :bat[:oid,:int]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow";
pattern /(b:bat[:oid,:int],v:int,accum:int) :bat[:oid,:int]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow, reuse B if ACCUM is set";
pattern div_noerror(b:bat[:oid,:int],v:int) :bat[:oid,:int]
address CMDbatDIVcst
comment "Return B / V, overflow causes NIL value";
pattern /(v:int,b:bat[:oid,:int]) :bat[:oid,:int]
address CMDbatDIVcstsignal
comment "Return V / B, signal error on overflow";
pattern /(v:int,b:bat[:oid,:int],accum:int) :bat[:oid,:int]
address CMDbatDIVcstsignal
comment "Return V / B, signal error on overflow, reuse B if ACCUM is set";
pattern div_noerror(v:int,b:bat[:oid,:int]) :bat[:oid,:int]
address CMDbatDIVcst
comment "Return V / B, overflow causes NIL value";

command /(b1:bat[:oid,:int],b2:bat[:oid,:wrd]) :bat[:oid,:int]
address CMDbatDIVsignal
comment "Return B1 / B2, signal error on overflow";
command /(b1:bat[:oid,:int],b2:bat[:oid,:wrd],accum:int) :bat[:oid,:int]
address CMDbatDIVsignalaccum
comment "Return B1 / B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command div_noerror(b1:bat[:oid,:int],b2:bat[:oid,:wrd]) :bat[:oid,:int]
address CMDbatDIV
comment "Return B1 / B2, overflow causes NIL value";
pattern /(b:bat[:oid,:int],v:wrd) :bat[:oid,:int]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow";
pattern /(b:bat[:oid,:int],v:wrd,accum:int) :bat[:oid,:int]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow, reuse B if ACCUM is set";
pattern div_noerror(b:bat[:oid,:int],v:wrd) :bat[:oid,:int]
address CMDbatDIVcst
comment "Return B / V, overflow causes NIL value";
pattern /(v:int,b:bat[:oid,:wrd]) :bat[:oid,:int]
address CMDbatDIVcstsignal
comment "Return V / B, signal error on overflow";
pattern div_noerror(v:int,b:bat[:oid,:wrd]) :bat[:oid,:int]
address CMDbatDIVcst
comment "Return V / B, overflow causes NIL value";

command /(b1:bat[:oid,:int],b2:bat[:oid,:lng]) :bat[:oid,:int]
address CMDbatDIVsignal
comment "Return B1 / B2, signal error on overflow";
command /(b1:bat[:oid,:int],b2:bat[:oid,:lng],accum:int) :bat[:oid,:int]
address CMDbatDIVsignalaccum
comment "Return B1 / B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command div_noerror(b1:bat[:oid,:int],b2:bat[:oid,:lng]) :bat[:oid,:int]
address CMDbatDIV
comment "Return B1 / B2, overflow causes NIL value";
pattern /(b:bat[:oid,:int],v:lng) :bat[:oid,:int]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow";
pattern /(b:bat[:oid,:int],v:lng,accum:int) :bat[:oid,:int]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow, reuse B if ACCUM is set";
pattern div_noerror(b:bat[:oid,:int],v:lng) :bat[:oid,:int]
address CMDbatDIVcst
comment "Return B / V, overflow causes NIL value";
pattern /(v:int,b:bat[:oid,:lng]) :bat[:oid,:int]
address CMDbatDIVcstsignal
comment "Return V / B, signal error on overflow";
pattern div_noerror(v:int,b:bat[:oid,:lng]) :bat[:oid,:int]
address CMDbatDIVcst
comment "Return V / B, overflow causes NIL value";

command /(b1:bat[:oid,:int],b2:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatDIVsignal
comment "Return B1 / B2, signal error on overflow";
command /(b1:bat[:oid,:int],b2:bat[:oid,:flt],accum:int) :bat[:oid,:flt]
address CMDbatDIVsignalaccum
comment "Return B1 / B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command div_noerror(b1:bat[:oid,:int],b2:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatDIV
comment "Return B1 / B2, overflow causes NIL value";
pattern /(b:bat[:oid,:int],v:flt) :bat[:oid,:flt]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow";
pattern div_noerror(b:bat[:oid,:int],v:flt) :bat[:oid,:flt]
address CMDbatDIVcst
comment "Return B / V, overflow causes NIL value";
pattern /(v:int,b:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatDIVcstsignal
comment "Return V / B, signal error on overflow";
pattern /(v:int,b:bat[:oid,:flt],accum:int) :bat[:oid,:flt]
address CMDbatDIVcstsignal
comment "Return V / B, signal error on overflow, reuse B if ACCUM is set";
pattern div_noerror(v:int,b:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatDIVcst
comment "Return V / B, overflow causes NIL value";

command /(b1:bat[:oid,:int],b2:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatDIVsignal
comment "Return B1 / B2, signal error on overflow";
command /(b1:bat[:oid,:int],b2:bat[:oid,:dbl],accum:int) :bat[:oid,:dbl]
address CMDbatDIVsignalaccum
comment "Return B1 / B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command div_noerror(b1:bat[:oid,:int],b2:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatDIV
comment "Return B1 / B2, overflow causes NIL value";
pattern /(b:bat[:oid,:int],v:dbl) :bat[:oid,:dbl]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow";
pattern div_noerror(b:bat[:oid,:int],v:dbl) :bat[:oid,:dbl]
address CMDbatDIVcst
comment "Return B / V, overflow causes NIL value";
pattern /(v:int,b:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatDIVcstsignal
comment "Return V / B, signal error on overflow";
pattern /(v:int,b:bat[:oid,:dbl],accum:int) :bat[:oid,:dbl]
address CMDbatDIVcstsignal
comment "Return V / B, signal error on overflow, reuse B if ACCUM is set";
pattern div_noerror(v:int,b:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatDIVcst
comment "Return V / B, overflow causes NIL value";

command /(b1:bat[:oid,:wrd],b2:bat[:oid,:bte]) :bat[:oid,:wrd]
address CMDbatDIVsignal
comment "Return B1 / B2, signal error on overflow";
command /(b1:bat[:oid,:wrd],b2:bat[:oid,:bte],accum:int) :bat[:oid,:wrd]
address CMDbatDIVsignalaccum
comment "Return B1 / B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command div_noerror(b1:bat[:oid,:wrd],b2:bat[:oid,:bte]) :bat[:oid,:wrd]
address CMDbatDIV
comment "Return B1 / B2, overflow causes NIL value";
pattern /(b:bat[:oid,:wrd],v:bte) :bat[:oid,:wrd]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow";
pattern /(b:bat[:oid,:wrd],v:bte,accum:int) :bat[:oid,:wrd]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow, reuse B if ACCUM is set";
pattern div_noerror(b:bat[:oid,:wrd],v:bte) :bat[:oid,:wrd]
address CMDbatDIVcst
comment "Return B / V, overflow causes NIL value";
pattern /(v:wrd,b:bat[:oid,:bte]) :bat[:oid,:wrd]
address CMDbatDIVcstsignal
comment "Return V / B, signal error on overflow";
pattern div_noerror(v:wrd,b:bat[:oid,:bte]) :bat[:oid,:wrd]
address CMDbatDIVcst
comment "Return V / B, overflow causes NIL value";

command /(b1:bat[:oid,:wrd],b2:bat[:oid,:sht]) :bat[:oid,:wrd]
address CMDbatDIVsignal
comment "Return B1 / B2, signal error on overflow";
command /(b1:bat[:oid,:wrd],b2:bat[:oid,:sht],accum:int) :bat[:oid,:wrd]
address CMDbatDIVsignalaccum
comment "Return B1 / B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command div_noerror(b1:bat[:oid,:wrd],b2:bat[:oid,:sht]) :bat[:oid,:wrd]
address CMDbatDIV
comment "Return B1 / B2, overflow causes NIL value";
pattern /(b:bat[:oid,:wrd],v:sht) :bat[:oid,:wrd]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow";
pattern /(b:bat[:oid,:wrd],v:sht,accum:int) :bat[:oid,:wrd]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow, reuse B if ACCUM is set";
pattern div_noerror(b:bat[:oid,:wrd],v:sht) :bat[:oid,:wrd]
address CMDbatDIVcst
comment "Return B / V, overflow causes NIL value";
pattern /(v:wrd,b:bat[:oid,:sht]) :bat[:oid,:wrd]
address CMDbatDIVcstsignal
comment "Return V / B, signal error on overflow";
pattern div_noerror(v:wrd,b:bat[:oid,:sht]) :bat[:oid,:wrd]
address CMDbatDIVcst
comment "Return V / B, overflow causes NIL value";

command /(b1:bat[:oid,:wrd],b2:bat[:oid,:int]) :bat[:oid,:wrd]
address CMDbatDIVsignal
comment "Return B1 / B2, signal error on overflow";
command /(b1:bat[:oid,:wrd],b2:bat[:oid,:int],accum:int) :bat[:oid,:wrd]
address CMDbatDIVsignalaccum
comment "Return B1 / B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command div_noerror(b1:bat[:oid,:wrd],b2:bat[:oid,:int]) :bat[:oid,:wrd]
address CMDbatDIV
comment "Return B1 / B2, overflow causes NIL value";
pattern /(b:bat[:oid,:wrd],v:int) :bat[:oid,:wrd]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow";
pattern /(b:bat[:oid,:wrd],v:int,accum:int) :bat[:oid,:wrd]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow, reuse B if ACCUM is set";
pattern div_noerror(b:bat[:oid,:wrd],v:int) :bat[:oid,:wrd]
address CMDbatDIVcst
comment "Return B / V, overflow causes NIL value";
pattern /(v:wrd,b:bat[:oid,:int]) :bat[:oid,:wrd]
address CMDbatDIVcstsignal
comment "Return V / B, signal error on overflow";
pattern div_noerror(v:wrd,b:bat[:oid,:int]) :bat[:oid,:wrd]
address CMDbatDIVcst
comment "Return V / B, overflow causes NIL value";

command /(b1:bat[:oid,:wrd],b2:bat[:oid,:wrd]) :bat[:oid,:wrd]
address CMDbatDIVsignal
comment "Return B1 / B2, signal error on overflow";
command /(b1:bat[:oid,:wrd],b2:bat[:oid,:wrd],accum:int) :bat[:oid,:wrd]
address CMDbatDIVsignalaccum
comment "Return B1 / B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command div_noerror(b1:bat[:oid,:wrd],b2:bat[:oid,:wrd]) :bat[:oid,:wrd]
address CMDbatDIV
comment "Return B1 / B2, overflow causes NIL value";
pattern /(b:bat[:oid,:wrd],v:wrd) :bat[:oid,:wrd]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow";
pattern /(b:bat[:oid,:wrd],v:wrd,accum:int) :bat[:oid,:wrd]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow, reuse B if ACCUM is set";
pattern div_noerror(b:bat[:oid,:wrd],v:wrd) :bat[:oid,:wrd]
address CMDbatDIVcst
comment "Return B / V, overflow causes NIL value";
pattern /(v:wrd,b:bat[:oid,:wrd]) :bat[:oid,:wrd]
address CMDbatDIVcstsignal
comment "Return V / B, signal error on overflow";
pattern /(v:wrd,b:bat[:oid,:wrd],accum:int) :bat[:oid,:wrd]
address CMDbatDIVcstsignal
comment "Return V / B, signal error on overflow, reuse B if ACCUM is set";
pattern div_noerror(v:wrd,b:bat[:oid,:wrd]) :bat[:oid,:wrd]
address CMDbatDIVcst
comment "Return V / B, overflow causes NIL value";

command /(b1:bat[:oid,:wrd],b2:bat[:oid,:lng]) :bat[:oid,:wrd]
address CMDbatDIVsignal
comment "Return B1 / B2, signal error on overflow";
command /(b1:bat[:oid,:wrd],b2:bat[:oid,:lng],accum:int) :bat[:oid,:wrd]
address CMDbatDIVsignalaccum
comment "Return B1 / B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command div_noerror(b1:bat[:oid,:wrd],b2:bat[:oid,:lng]) :bat[:oid,:wrd]
address CMDbatDIV
comment "Return B1 / B2, overflow causes NIL value";
pattern /(b:bat[:oid,:wrd],v:lng) :bat[:oid,:wrd]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow";
pattern /(b:bat[:oid,:wrd],v:lng,accum:int) :bat[:oid,:wrd]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow, reuse B if ACCUM is set";
pattern div_noerror(b:bat[:oid,:wrd],v:lng) :bat[:oid,:wrd]
address CMDbatDIVcst
comment "Return B / V, overflow causes NIL value";
pattern /(v:wrd,b:bat[:oid,:lng]) :bat[:oid,:wrd]
address CMDbatDIVcstsignal
comment "Return V / B, signal error on overflow";
pattern div_noerror(v:wrd,b:bat[:oid,:lng]) :bat[:oid,:wrd]
address CMDbatDIVcst
comment "Return V / B, overflow causes NIL value";

command /(b1:bat[:oid,:wrd],b2:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatDIVsignal
comment "Return B1 / B2, signal error on overflow";
command /(b1:bat[:oid,:wrd],b2:bat[:oid,:flt],accum:int) :bat[:oid,:flt]
address CMDbatDIVsignalaccum
comment "Return B1 / B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command div_noerror(b1:bat[:oid,:wrd],b2:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatDIV
comment "Return B1 / B2, overflow causes NIL value";
pattern /(b:bat[:oid,:wrd],v:flt) :bat[:oid,:flt]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow";
pattern div_noerror(b:bat[:oid,:wrd],v:flt) :bat[:oid,:flt]
address CMDbatDIVcst
comment "Return B / V, overflow causes NIL value";
pattern /(v:wrd,b:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatDIVcstsignal
comment "Return V / B, signal error on overflow";
pattern /(v:wrd,b:bat[:oid,:flt],accum:int) :bat[:oid,:flt]
address CMDbatDIVcstsignal
comment "Return V / B, signal error on overflow, reuse B if ACCUM is set";
pattern div_noerror(v:wrd,b:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatDIVcst
comment "Return V / B, overflow causes NIL value";

command /(b1:bat[:oid,:wrd],b2:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatDIVsignal
comment "Return B1 / B2, signal error on overflow";
command /(b1:bat[:oid,:wrd],b2:bat[:oid,:dbl],accum:int) :bat[:oid,:dbl]
address CMDbatDIVsignalaccum
comment "Return B1 / B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command div_noerror(b1:bat[:oid,:wrd],b2:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatDIV
comment "Return B1 / B2, overflow causes NIL value";
pattern /(b:bat[:oid,:wrd],v:dbl) :bat[:oid,:dbl]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow";
pattern div_noerror(b:bat[:oid,:wrd],v:dbl) :bat[:oid,:dbl]
address CMDbatDIVcst
comment "Return B / V, overflow causes NIL value";
pattern /(v:wrd,b:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatDIVcstsignal
comment "Return V / B, signal error on overflow";
pattern /(v:wrd,b:bat[:oid,:dbl],accum:int) :bat[:oid,:dbl]
address CMDbatDIVcstsignal
comment "Return V / B, signal error on overflow, reuse B if ACCUM is set";
pattern div_noerror(v:wrd,b:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatDIVcst
comment "Return V / B, overflow causes NIL value";

command /(b1:bat[:oid,:lng],b2:bat[:oid,:bte]) :bat[:oid,:lng]
address CMDbatDIVsignal
comment "Return B1 / B2, signal error on overflow";
command /(b1:bat[:oid,:lng],b2:bat[:oid,:bte],accum:int) :bat[:oid,:lng]
address CMDbatDIVsignalaccum
comment "Return B1 / B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command div_noerror(b1:bat[:oid,:lng],b2:bat[:oid,:bte]) :bat[:oid,:lng]
address CMDbatDIV
comment "Return B1 / B2, overflow causes NIL value";
pattern /(b:bat[:oid,:lng],v:bte) :bat[:oid,:lng]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow";
pattern /(b:bat[:oid,:lng],v:bte,accum:int) :bat[:oid,:lng]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow, reuse B if ACCUM is set";
pattern div_noerror(b:bat[:oid,:lng],v:bte) :bat[:oid,:lng]
address CMDbatDIVcst
comment "Return B / V, overflow causes NIL value";
pattern /(v:lng,b:bat[:oid,:bte]) :bat[:oid,:lng]
address CMDbatDIVcstsignal
comment "Return V / B, signal error on overflow";
pattern div_noerror(v:lng,b:bat[:oid,:bte]) :bat[:oid,:lng]
address CMDbatDIVcst
comment "Return V / B, overflow causes NIL value";

command /(b1:bat[:oid,:lng],b2:bat[:oid,:sht]) :bat[:oid,:lng]
address CMDbatDIVsignal
comment "Return B1 / B2, signal error on overflow";
command /(b1:bat[:oid,:lng],b2:bat[:oid,:sht],accum:int) :bat[:oid,:lng]
address CMDbatDIVsignalaccum
comment "Return B1 / B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command div_noerror(b1:bat[:oid,:lng],b2:bat[:oid,:sht]) :bat[:oid,:lng]
address CMDbatDIV
comment "Return B1 / B2, overflow causes NIL value";
pattern /(b:bat[:oid,:lng],v:sht) :bat[:oid,:lng]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow";
pattern /(b:bat[:oid,:lng],v:sht,accum:int) :bat[:oid,:lng]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow, reuse B if ACCUM is set";
pattern div_noerror(b:bat[:oid,:lng],v:sht) :bat[:oid,:lng]
address CMDbatDIVcst
comment "Return B / V, overflow causes NIL value";
pattern /(v:lng,b:bat[:oid,:sht]) :bat[:oid,:lng]
address CMDbatDIVcstsignal
comment "Return V / B, signal error on overflow";
pattern div_noerror(v:lng,b:bat[:oid,:sht]) :bat[:oid,:lng]
address CMDbatDIVcst
comment "Return V / B, overflow causes NIL value";

command /(b1:bat[:oid,:lng],b2:bat[:oid,:int]) :bat[:oid,:lng]
address CMDbatDIVsignal
comment "Return B1 / B2, signal error on overflow";
command /(b1:bat[:oid,:lng],b2:bat[:oid,:int],accum:int) :bat[:oid,:lng]
address CMDbatDIVsignalaccum
comment "Return B1 / B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command div_noerror(b1:bat[:oid,:lng],b2:bat[:oid,:int]) :bat[:oid,:lng]
address CMDbatDIV
comment "Return B1 / B2, overflow causes NIL value";
pattern /(b:bat[:oid,:lng],v:int) :bat[:oid,:lng]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow";
pattern /(b:bat[:oid,:lng],v:int,accum:int) :bat[:oid,:lng]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow, reuse B if ACCUM is set";
pattern div_noerror(b:bat[:oid,:lng],v:int) :bat[:oid,:lng]
address CMDbatDIVcst
comment "Return B / V, overflow causes NIL value";
pattern /(v:lng,b:bat[:oid,:int]) :bat[:oid,:lng]
address CMDbatDIVcstsignal
comment "Return V / B, signal error on overflow";
pattern div_noerror(v:lng,b:bat[:oid,:int]) :bat[:oid,:lng]
address CMDbatDIVcst
comment "Return V / B, overflow causes NIL value";

command /(b1:bat[:oid,:lng],b2:bat[:oid,:wrd]) :bat[:oid,:lng]
address CMDbatDIVsignal
comment "Return B1 / B2, signal error on overflow";
command /(b1:bat[:oid,:lng],b2:bat[:oid,:wrd],accum:int) :bat[:oid,:lng]
address CMDbatDIVsignalaccum
comment "Return B1 / B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command div_noerror(b1:bat[:oid,:lng],b2:bat[:oid,:wrd]) :bat[:oid,:lng]
address CMDbatDIV
comment "Return B1 / B2, overflow causes NIL value";
pattern /(b:bat[:oid,:lng],v:wrd) :bat[:oid,:lng]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow";
pattern /(b:bat[:oid,:lng],v:wrd,accum:int) :bat[:oid,:lng]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow, reuse B if ACCUM is set";
pattern div_noerror(b:bat[:oid,:lng],v:wrd) :bat[:oid,:lng]
address CMDbatDIVcst
comment "Return B / V, overflow causes NIL value";
pattern /(v:lng,b:bat[:oid,:wrd]) :bat[:oid,:lng]
address CMDbatDIVcstsignal
comment "Return V / B, signal error on overflow";
pattern div_noerror(v:lng,b:bat[:oid,:wrd]) :bat[:oid,:lng]
address CMDbatDIVcst
comment "Return V / B, overflow causes NIL value";

command /(b1:bat[:oid,:lng],b2:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatDIVsignal
comment "Return B1 / B2, signal error on overflow";
command /(b1:bat[:oid,:lng],b2:bat[:oid,:lng],accum:int) :bat[:oid,:lng]
address CMDbatDIVsignalaccum
comment "Return B1 / B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command div_noerror(b1:bat[:oid,:lng],b2:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatDIV
comment "Return B1 / B2, overflow causes NIL value";
pattern /(b:bat[:oid,:lng],v:lng) :bat[:oid,:lng]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow";
pattern /(b:bat[:oid,:lng],v:lng,accum:int) :bat[:oid,:lng]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow, reuse B if ACCUM is set";
pattern div_noerror(b:bat[:oid,:lng],v:lng) :bat[:oid,:lng]
address CMDbatDIVcst
comment "Return B / V, overflow causes NIL value";
pattern /(v:lng,b:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatDIVcstsignal
comment "Return V / B, signal error on overflow";
pattern /(v:lng,b:bat[:oid,:lng],accum:int) :bat[:oid,:lng]
address CMDbatDIVcstsignal
comment "Return V / B, signal error on overflow, reuse B if ACCUM is set";
pattern div_noerror(v:lng,b:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatDIVcst
comment "Return V / B, overflow causes NIL value";

command /(b1:bat[:oid,:lng],b2:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatDIVsignal
comment "Return B1 / B2, signal error on overflow";
command /(b1:bat[:oid,:lng],b2:bat[:oid,:flt],accum:int) :bat[:oid,:flt]
address CMDbatDIVsignalaccum
comment "Return B1 / B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command div_noerror(b1:bat[:oid,:lng],b2:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatDIV
comment "Return B1 / B2, overflow causes NIL value";
pattern /(b:bat[:oid,:lng],v:flt) :bat[:oid,:flt]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow";
pattern div_noerror(b:bat[:oid,:lng],v:flt) :bat[:oid,:flt]
address CMDbatDIVcst
comment "Return B / V, overflow causes NIL value";
pattern /(v:lng,b:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatDIVcstsignal
comment "Return V / B, signal error on overflow";
pattern /(v:lng,b:bat[:oid,:flt],accum:int) :bat[:oid,:flt]
address CMDbatDIVcstsignal
comment "Return V / B, signal error on overflow, reuse B if ACCUM is set";
pattern div_noerror(v:lng,b:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatDIVcst
comment "Return V / B, overflow causes NIL value";

command /(b1:bat[:oid,:lng],b2:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatDIVsignal
comment "Return B1 / B2, signal error on overflow";
command /(b1:bat[:oid,:lng],b2:bat[:oid,:dbl],accum:int) :bat[:oid,:dbl]
address CMDbatDIVsignalaccum
comment "Return B1 / B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command div_noerror(b1:bat[:oid,:lng],b2:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatDIV
comment "Return B1 / B2, overflow causes NIL value";
pattern /(b:bat[:oid,:lng],v:dbl) :bat[:oid,:dbl]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow";
pattern div_noerror(b:bat[:oid,:lng],v:dbl) :bat[:oid,:dbl]
address CMDbatDIVcst
comment "Return B / V, overflow causes NIL value";
pattern /(v:lng,b:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatDIVcstsignal
comment "Return V / B, signal error on overflow";
pattern /(v:lng,b:bat[:oid,:dbl],accum:int) :bat[:oid,:dbl]
address CMDbatDIVcstsignal
comment "Return V / B, signal error on overflow, reuse B if ACCUM is set";
pattern div_noerror(v:lng,b:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatDIVcst
comment "Return V / B, overflow causes NIL value";

command /(b1:bat[:oid,:flt],b2:bat[:oid,:bte]) :bat[:oid,:flt]
address CMDbatDIVsignal
comment "Return B1 / B2, signal error on overflow";
command /(b1:bat[:oid,:flt],b2:bat[:oid,:bte],accum:int) :bat[:oid,:flt]
address CMDbatDIVsignalaccum
comment "Return B1 / B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command div_noerror(b1:bat[:oid,:flt],b2:bat[:oid,:bte]) :bat[:oid,:flt]
address CMDbatDIV
comment "Return B1 / B2, overflow causes NIL value";
pattern /(b:bat[:oid,:flt],v:bte) :bat[:oid,:flt]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow";
pattern /(b:bat[:oid,:flt],v:bte,accum:int) :bat[:oid,:flt]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow, reuse B if ACCUM is set";
pattern div_noerror(b:bat[:oid,:flt],v:bte) :bat[:oid,:flt]
address CMDbatDIVcst
comment "Return B / V, overflow causes NIL value";
pattern /(v:flt,b:bat[:oid,:bte]) :bat[:oid,:flt]
address CMDbatDIVcstsignal
comment "Return V / B, signal error on overflow";
pattern div_noerror(v:flt,b:bat[:oid,:bte]) :bat[:oid,:flt]
address CMDbatDIVcst
comment "Return V / B, overflow causes NIL value";

command /(b1:bat[:oid,:flt],b2:bat[:oid,:sht]) :bat[:oid,:flt]
address CMDbatDIVsignal
comment "Return B1 / B2, signal error on overflow";
command /(b1:bat[:oid,:flt],b2:bat[:oid,:sht],accum:int) :bat[:oid,:flt]
address CMDbatDIVsignalaccum
comment "Return B1 / B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command div_noerror(b1:bat[:oid,:flt],b2:bat[:oid,:sht]) :bat[:oid,:flt]
address CMDbatDIV
comment "Return B1 / B2, overflow causes NIL value";
pattern /(b:bat[:oid,:flt],v:sht) :bat[:oid,:flt]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow";
pattern /(b:bat[:oid,:flt],v:sht,accum:int) :bat[:oid,:flt]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow, reuse B if ACCUM is set";
pattern div_noerror(b:bat[:oid,:flt],v:sht) :bat[:oid,:flt]
address CMDbatDIVcst
comment "Return B / V, overflow causes NIL value";
pattern /(v:flt,b:bat[:oid,:sht]) :bat[:oid,:flt]
address CMDbatDIVcstsignal
comment "Return V / B, signal error on overflow";
pattern div_noerror(v:flt,b:bat[:oid,:sht]) :bat[:oid,:flt]
address CMDbatDIVcst
comment "Return V / B, overflow causes NIL value";

command /(b1:bat[:oid,:flt],b2:bat[:oid,:int]) :bat[:oid,:flt]
address CMDbatDIVsignal
comment "Return B1 / B2, signal error on overflow";
command /(b1:bat[:oid,:flt],b2:bat[:oid,:int],accum:int) :bat[:oid,:flt]
address CMDbatDIVsignalaccum
comment "Return B1 / B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command div_noerror(b1:bat[:oid,:flt],b2:bat[:oid,:int]) :bat[:oid,:flt]
address CMDbatDIV
comment "Return B1 / B2, overflow causes NIL value";
pattern /(b:bat[:oid,:flt],v:int) :bat[:oid,:flt]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow";
pattern /(b:bat[:oid,:flt],v:int,accum:int) :bat[:oid,:flt]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow, reuse B if ACCUM is set";
pattern div_noerror(b:bat[:oid,:flt],v:int) :bat[:oid,:flt]
address CMDbatDIVcst
comment "Return B / V, overflow causes NIL value";
pattern /(v:flt,b:bat[:oid,:int]) :bat[:oid,:flt]
address CMDbatDIVcstsignal
comment "Return V / B, signal error on overflow";
pattern div_noerror(v:flt,b:bat[:oid,:int]) :bat[:oid,:flt]
address CMDbatDIVcst
comment "Return V / B, overflow causes NIL value";

command /(b1:bat[:oid,:flt],b2:bat[:oid,:wrd]) :bat[:oid,:flt]
address CMDbatDIVsignal
comment "Return B1 / B2, signal error on overflow";
command /(b1:bat[:oid,:flt],b2:bat[:oid,:wrd],accum:int) :bat[:oid,:flt]
address CMDbatDIVsignalaccum
comment "Return B1 / B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command div_noerror(b1:bat[:oid,:flt],b2:bat[:oid,:wrd]) :bat[:oid,:flt]
address CMDbatDIV
comment "Return B1 / B2, overflow causes NIL value";
pattern /(b:bat[:oid,:flt],v:wrd) :bat[:oid,:flt]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow";
pattern /(b:bat[:oid,:flt],v:wrd,accum:int) :bat[:oid,:flt]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow, reuse B if ACCUM is set";
pattern div_noerror(b:bat[:oid,:flt],v:wrd) :bat[:oid,:flt]
address CMDbatDIVcst
comment "Return B / V, overflow causes NIL value";
pattern /(v:flt,b:bat[:oid,:wrd]) :bat[:oid,:flt]
address CMDbatDIVcstsignal
comment "Return V / B, signal error on overflow";
pattern div_noerror(v:flt,b:bat[:oid,:wrd]) :bat[:oid,:flt]
address CMDbatDIVcst
comment "Return V / B, overflow causes NIL value";

command /(b1:bat[:oid,:flt],b2:bat[:oid,:lng]) :bat[:oid,:flt]
address CMDbatDIVsignal
comment "Return B1 / B2, signal error on overflow";
command /(b1:bat[:oid,:flt],b2:bat[:oid,:lng],accum:int) :bat[:oid,:flt]
address CMDbatDIVsignalaccum
comment "Return B1 / B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command div_noerror(b1:bat[:oid,:flt],b2:bat[:oid,:lng]) :bat[:oid,:flt]
address CMDbatDIV
comment "Return B1 / B2, overflow causes NIL value";
pattern /(b:bat[:oid,:flt],v:lng) :bat[:oid,:flt]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow";
pattern /(b:bat[:oid,:flt],v:lng,accum:int) :bat[:oid,:flt]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow, reuse B if ACCUM is set";
pattern div_noerror(b:bat[:oid,:flt],v:lng) :bat[:oid,:flt]
address CMDbatDIVcst
comment "Return B / V, overflow causes NIL value";
pattern /(v:flt,b:bat[:oid,:lng]) :bat[:oid,:flt]
address CMDbatDIVcstsignal
comment "Return V / B, signal error on overflow";
pattern div_noerror(v:flt,b:bat[:oid,:lng]) :bat[:oid,:flt]
address CMDbatDIVcst
comment "Return V / B, overflow causes NIL value";

command /(b1:bat[:oid,:flt],b2:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatDIVsignal
comment "Return B1 / B2, signal error on overflow";
command /(b1:bat[:oid,:flt],b2:bat[:oid,:flt],accum:int) :bat[:oid,:flt]
address CMDbatDIVsignalaccum
comment "Return B1 / B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command div_noerror(b1:bat[:oid,:flt],b2:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatDIV
comment "Return B1 / B2, overflow causes NIL value";
pattern /(b:bat[:oid,:flt],v:flt) :bat[:oid,:flt]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow";
pattern /(b:bat[:oid,:flt],v:flt,accum:int) :bat[:oid,:flt]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow, reuse B if ACCUM is set";
pattern div_noerror(b:bat[:oid,:flt],v:flt) :bat[:oid,:flt]
address CMDbatDIVcst
comment "Return B / V, overflow causes NIL value";
pattern /(v:flt,b:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatDIVcstsignal
comment "Return V / B, signal error on overflow";
pattern /(v:flt,b:bat[:oid,:flt],accum:int) :bat[:oid,:flt]
address CMDbatDIVcstsignal
comment "Return V / B, signal error on overflow, reuse B if ACCUM is set";
pattern div_noerror(v:flt,b:bat[:oid,:flt]) :bat[:oid,:flt]
address CMDbatDIVcst
comment "Return V / B, overflow causes NIL value";

command /(b1:bat[:oid,:flt],b2:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatDIVsignal
comment "Return B1 / B2, signal error on overflow";
command /(b1:bat[:oid,:flt],b2:bat[:oid,:dbl],accum:int) :bat[:oid,:dbl]
address CMDbatDIVsignalaccum
comment "Return B1 / B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command div_noerror(b1:bat[:oid,:flt],b2:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatDIV
comment "Return B1 / B2, overflow causes NIL value";
pattern /(b:bat[:oid,:flt],v:dbl) :bat[:oid,:dbl]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow";
pattern div_noerror(b:bat[:oid,:flt],v:dbl) :bat[:oid,:dbl]
address CMDbatDIVcst
comment "Return B / V, overflow causes NIL value";
pattern /(v:flt,b:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatDIVcstsignal
comment "Return V / B, signal error on overflow";
pattern /(v:flt,b:bat[:oid,:dbl],accum:int) :bat[:oid,:dbl]
address CMDbatDIVcstsignal
comment "Return V / B, signal error on overflow, reuse B if ACCUM is set";
pattern div_noerror(v:flt,b:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatDIVcst
comment "Return V / B, overflow causes NIL value";

command /(b1:bat[:oid,:dbl],b2:bat[:oid,:bte]) :bat[:oid,:dbl]
address CMDbatDIVsignal
comment "Return B1 / B2, signal error on overflow";
command /(b1:bat[:oid,:dbl],b2:bat[:oid,:bte],accum:int) :bat[:oid,:dbl]
address CMDbatDIVsignalaccum
comment "Return B1 / B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command div_noerror(b1:bat[:oid,:dbl],b2:bat[:oid,:bte]) :bat[:oid,:dbl]
address CMDbatDIV
comment "Return B1 / B2, overflow causes NIL value";
pattern /(b:bat[:oid,:dbl],v:bte) :bat[:oid,:dbl]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow";
pattern /(b:bat[:oid,:dbl],v:bte,accum:int) :bat[:oid,:dbl]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow, reuse B if ACCUM is set";
pattern div_noerror(b:bat[:oid,:dbl],v:bte) :bat[:oid,:dbl]
address CMDbatDIVcst
comment "Return B / V, overflow causes NIL value";
pattern /(v:dbl,b:bat[:oid,:bte]) :bat[:oid,:dbl]
address CMDbatDIVcstsignal
comment "Return V / B, signal error on overflow";
pattern div_noerror(v:dbl,b:bat[:oid,:bte]) :bat[:oid,:dbl]
address CMDbatDIVcst
comment "Return V / B, overflow causes NIL value";

command /(b1:bat[:oid,:dbl],b2:bat[:oid,:sht]) :bat[:oid,:dbl]
address CMDbatDIVsignal
comment "Return B1 / B2, signal error on overflow";
command /(b1:bat[:oid,:dbl],b2:bat[:oid,:sht],accum:int) :bat[:oid,:dbl]
address CMDbatDIVsignalaccum
comment "Return B1 / B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command div_noerror(b1:bat[:oid,:dbl],b2:bat[:oid,:sht]) :bat[:oid,:dbl]
address CMDbatDIV
comment "Return B1 / B2, overflow causes NIL value";
pattern /(b:bat[:oid,:dbl],v:sht) :bat[:oid,:dbl]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow";
pattern /(b:bat[:oid,:dbl],v:sht,accum:int) :bat[:oid,:dbl]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow, reuse B if ACCUM is set";
pattern div_noerror(b:bat[:oid,:dbl],v:sht) :bat[:oid,:dbl]
address CMDbatDIVcst
comment "Return B / V, overflow causes NIL value";
pattern /(v:dbl,b:bat[:oid,:sht]) :bat[:oid,:dbl]
address CMDbatDIVcstsignal
comment "Return V / B, signal error on overflow";
pattern div_noerror(v:dbl,b:bat[:oid,:sht]) :bat[:oid,:dbl]
address CMDbatDIVcst
comment "Return V / B, overflow causes NIL value";

command /(b1:bat[:oid,:dbl],b2:bat[:oid,:int]) :bat[:oid,:dbl]
address CMDbatDIVsignal
comment "Return B1 / B2, signal error on overflow";
command /(b1:bat[:oid,:dbl],b2:bat[:oid,:int],accum:int) :bat[:oid,:dbl]
address CMDbatDIVsignalaccum
comment "Return B1 / B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command div_noerror(b1:bat[:oid,:dbl],b2:bat[:oid,:int]) :bat[:oid,:dbl]
address CMDbatDIV
comment "Return B1 / B2, overflow causes NIL value";
pattern /(b:bat[:oid,:dbl],v:int) :bat[:oid,:dbl]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow";
pattern /(b:bat[:oid,:dbl],v:int,accum:int) :bat[:oid,:dbl]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow, reuse B if ACCUM is set";
pattern div_noerror(b:bat[:oid,:dbl],v:int) :bat[:oid,:dbl]
address CMDbatDIVcst
comment "Return B / V, overflow causes NIL value";
pattern /(v:dbl,b:bat[:oid,:int]) :bat[:oid,:dbl]
address CMDbatDIVcstsignal
comment "Return V / B, signal error on overflow";
pattern div_noerror(v:dbl,b:bat[:oid,:int]) :bat[:oid,:dbl]
address CMDbatDIVcst
comment "Return V / B, overflow causes NIL value";

command /(b1:bat[:oid,:dbl],b2:bat[:oid,:wrd]) :bat[:oid,:dbl]
address CMDbatDIVsignal
comment "Return B1 / B2, signal error on overflow";
command /(b1:bat[:oid,:dbl],b2:bat[:oid,:wrd],accum:int) :bat[:oid,:dbl]
address CMDbatDIVsignalaccum
comment "Return B1 / B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command div_noerror(b1:bat[:oid,:dbl],b2:bat[:oid,:wrd]) :bat[:oid,:dbl]
address CMDbatDIV
comment "Return B1 / B2, overflow causes NIL value";
pattern /(b:bat[:oid,:dbl],v:wrd) :bat[:oid,:dbl]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow";
pattern /(b:bat[:oid,:dbl],v:wrd,accum:int) :bat[:oid,:dbl]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow, reuse B if ACCUM is set";
pattern div_noerror(b:bat[:oid,:dbl],v:wrd) :bat[:oid,:dbl]
address CMDbatDIVcst
comment "Return B / V, overflow causes NIL value";
pattern /(v:dbl,b:bat[:oid,:wrd]) :bat[:oid,:dbl]
address CMDbatDIVcstsignal
comment "Return V / B, signal error on overflow";
pattern div_noerror(v:dbl,b:bat[:oid,:wrd]) :bat[:oid,:dbl]
address CMDbatDIVcst
comment "Return V / B, overflow causes NIL value";

command /(b1:bat[:oid,:dbl],b2:bat[:oid,:lng]) :bat[:oid,:dbl]
address CMDbatDIVsignal
comment "Return B1 / B2, signal error on overflow";
command /(b1:bat[:oid,:dbl],b2:bat[:oid,:lng],accum:int) :bat[:oid,:dbl]
address CMDbatDIVsignalaccum
comment "Return B1 / B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command div_noerror(b1:bat[:oid,:dbl],b2:bat[:oid,:lng]) :bat[:oid,:dbl]
address CMDbatDIV
comment "Return B1 / B2, overflow causes NIL value";
pattern /(b:bat[:oid,:dbl],v:lng) :bat[:oid,:dbl]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow";
pattern /(b:bat[:oid,:dbl],v:lng,accum:int) :bat[:oid,:dbl]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow, reuse B if ACCUM is set";
pattern div_noerror(b:bat[:oid,:dbl],v:lng) :bat[:oid,:dbl]
address CMDbatDIVcst
comment "Return B / V, overflow causes NIL value";
pattern /(v:dbl,b:bat[:oid,:lng]) :bat[:oid,:dbl]
address CMDbatDIVcstsignal
comment "Return V / B, signal error on overflow";
pattern div_noerror(v:dbl,b:bat[:oid,:lng]) :bat[:oid,:dbl]
address CMDbatDIVcst
comment "Return V / B, overflow causes NIL value";

command /(b1:bat[:oid,:dbl],b2:bat[:oid,:flt]) :bat[:oid,:dbl]
address CMDbatDIVsignal
comment "Return B1 / B2, signal error on overflow";
command /(b1:bat[:oid,:dbl],b2:bat[:oid,:flt],accum:int) :bat[:oid,:dbl]
address CMDbatDIVsignalaccum
comment "Return B1 / B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command div_noerror(b1:bat[:oid,:dbl],b2:bat[:oid,:flt]) :bat[:oid,:dbl]
address CMDbatDIV
comment "Return B1 / B2, overflow causes NIL value";
pattern /(b:bat[:oid,:dbl],v:flt) :bat[:oid,:dbl]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow";
pattern /(b:bat[:oid,:dbl],v:flt,accum:int) :bat[:oid,:dbl]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow, reuse B if ACCUM is set";
pattern div_noerror(b:bat[:oid,:dbl],v:flt) :bat[:oid,:dbl]
address CMDbatDIVcst
comment "Return B / V, overflow causes NIL value";
pattern /(v:dbl,b:bat[:oid,:flt]) :bat[:oid,:dbl]
address CMDbatDIVcstsignal
comment "Return V / B, signal error on overflow";
pattern div_noerror(v:dbl,b:bat[:oid,:flt]) :bat[:oid,:dbl]
address CMDbatDIVcst
comment "Return V / B, overflow causes NIL value";

command /(b1:bat[:oid,:dbl],b2:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatDIVsignal
comment "Return B1 / B2, signal error on overflow";
command /(b1:bat[:oid,:dbl],b2:bat[:oid,:dbl],accum:int) :bat[:oid,:dbl]
address CMDbatDIVsignalaccum
comment "Return B1 / B2, signal error on overflow, reuse B1 or B2 depending on ACCUM";
command div_noerror(b1:bat[:oid,:dbl],b2:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatDIV
comment "Return B1 / B2, overflow causes NIL value";
pattern /(b:bat[:oid,:dbl],v:dbl) :bat[:oid,:dbl]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow";
pattern /(b:bat[:oid,:dbl],v:dbl,accum:int) :bat[:oid,:dbl]
address CMDbatDIVcstsignal
comment "Return B / V, signal error on overflow, reuse B if ACCUM is set";
pattern div_noerror(b:bat[:oid,:dbl],v:dbl) :bat[:oid,:dbl]
address CMDbatDIVcst
comment "Return B / V, overflow causes NIL value";
pattern /(v:dbl,b:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatDIVcstsignal
comment "Return V / B, signal error on overflow";
pattern /(v:dbl,b:bat[:oid,:dbl],accum:int) :bat[:oid,:dbl]
address CMDbatDIVcstsignal
comment "Return V / B, signal error on overflow, reuse B if ACCUM is set";
pattern div_noerror(v:dbl,b:bat[:oid,:dbl]) :bat[:oid,:dbl]
address CMDbatDIVcst
comment "Return V / B, overflow causes NIL value";


command %(b1:bat[:oid,:bte],b2:bat[:oid,:bte]) :bat[:oid,:bte]
address CMDbatMODsignal
comment "Return B1 % B2, signal error on divide by zero";
command %(b1:bat[:oid,:bte],b2:bat[:oid,:bte],accum:int) :bat[:oid,:bte]
address CMDbatMODsignalaccum
comment "Return B1 % B2, signal error on divide by zero, reuse B1 or B2 depending on ACCUM";
command mod_noerror(b1:bat[:oid,:bte],b2:bat[:oid,:bte]) :bat[:oid,:bte]
address CMDbatMOD
comment "Return B1 % B2, divide by zero causes NIL value";
pattern %(b:bat[:oid,:bte],v:bte) :bat[:oid,:bte]
address CMDbatMODcstsignal
comment "Return B % V, signal error on divide by zero";
pattern %(b:bat[:oid,:bte],v:bte,accum:int) :bat[:oid,:bte]
address CMDbatMODcstsignal
comment "Return B % V, signal error on divide by zero, reuse B if ACCUM is set";
pattern mod_noerror(b:bat[:oid,:bte],v:bte) :bat[:oid,:bte]
address CMDbatMODcst
comment "Return B % V, divide by zero causes NIL value";
pattern %(v:bte,b:bat[:oid,:bte]) :bat[:oid,:bte]
address CMDbatMODcstsignal
comment "Return V % B, signal error on divide by zero";
pattern %(v:bte,b:bat[:oid,:bte],accum:int) :bat[:oid,:bte]
address CMDbatMODcstsignal
comment "Return V % B, signal error on divide by zero, reuse B if ACCUM is set";
pattern mod_noerror(v:bte,b:bat[:oid,:bte]) :bat[:oid,:bte]
address CMDbatMODcst
comment "Return V % B, divide by zero causes NIL value";

command %(b1:bat[:oid,:bte],b2:bat[:oid,:sht]) :bat[:oid,:bte]
address CMDbatMODsignal
comment "Return B1 % B2, signal error on divide by zero";
command %(b1:bat[:oid,:bte],b2:bat[:oid,:sht],accum:int) :bat[:oid,:bte]
address CMDbatMODsignalaccum
comment "Return B1 % B2, signal error on divide by zero, reuse B1 or B2 depending on ACCUM";
command mod_noerror(b1:bat[:oid,:bte],b2:bat[:oid,:sht]) :bat[:oid,:bte]
address CMDbatMOD
comment "Return B1 % B2, divide by zero causes NIL value";
pattern %(b:bat[:oid,:bte],v:sht) :bat[:oid,:bte]
address CMDbatMODcstsignal
comment "Return B % V, signal error on divide by zero";
pattern %(b:bat[:oid,:bte],v:sht,accum:int) :bat[:oid,:bte]
address CMDbatMODcstsignal
comment "Return B % V, signal error on divide by zero, reuse B if ACCUM is set";
pattern mod_noerror(b:bat[:oid,:bte],v:sht) :bat[:oid,:bte]
address CMDbatMODcst
comment "Return B % V, divide by zero causes NIL value";
pattern %(v:bte,b:bat[:oid,:sht]) :bat[:oid,:bte]
address CMDbatMODcstsignal
comment "Return V % B, signal error on divide by zero";
pattern mod_noerror(v:bte,b:bat[:oid,:sht]) :bat[:oid,:bte]
address CMDbatMODcst
comment "Return V % B, divide by zero causes NIL value";

command %(b1:bat[:oid,:bte],b2:bat[:oid,:int]) :bat[:oid,:bte]
address CMDbatMODsignal
comment "Return B1 % B2, signal error on divide by zero";
command %(b1:bat[:oid,:bte],b2:bat[:oid,:int],accum:int) :bat[:oid,:bte]
address CMDbatMODsignalaccum
comment "Return B1 % B2, signal error on divide by zero, reuse B1 or B2 depending on ACCUM";
command mod_noerror(b1:bat[:oid,:bte],b2:bat[:oid,:int]) :bat[:oid,:bte]
address CMDbatMOD
comment "Return B1 % B2, divide by zero causes NIL value";
pattern %(b:bat[:oid,:bte],v:int) :bat[:oid,:bte]
address CMDbatMODcstsignal
comment "Return B % V, signal error on divide by zero";
pattern %(b:bat[:oid,:bte],v:int,accum:int) :bat[:oid,:bte]
address CMDbatMODcstsignal
comment "Return B % V, signal error on divide by zero, reuse B if ACCUM is set";
pattern mod_noerror(b:bat[:oid,:bte],v:int) :bat[:oid,:bte]
address CMDbatMODcst
comment "Return B % V, divide by zero causes NIL value";
pattern %(v:bte,b:bat[:oid,:int]) :bat[:oid,:bte]
address CMDbatMODcstsignal
comment "Return V % B, signal error on divide by zero";
pattern mod_noerror(v:bte,b:bat[:oid,:int]) :bat[:oid,:bte]
address CMDbatMODcst
comment "Return V % B, divide by zero causes NIL value";

command %(b1:bat[:oid,:bte],b2:bat[:oid,:wrd]) :bat[:oid,:bte]
address CMDbatMODsignal
comment "Return B1 % B2, signal error on divide by zero";
command %(b1:bat[:oid,:bte],b2:bat[:oid,:wrd],accum:int) :bat[:oid,:bte]
address CMDbatMODsignalaccum
comment "Return B1 % B2, signal error on divide by zero, reuse B1 or B2 depending on ACCUM";
command mod_noerror(b1:bat[:oid,:bte],b2:bat[:oid,:wrd]) :bat[:oid,:bte]
address CMDbatMOD
comment "Return B1 % B2, divide by zero causes NIL value";
pattern %(b:bat[:oid,:bte],v:wrd) :bat[:oid,:bte]
address CMDbatMODcstsignal
comment "Return B % V, signal error on divide by zero";
pattern %(b:bat[:oid,:bte],v:wrd,accum:int) :bat[:oid,:bte]
address CMDbatMODcstsignal
comment "Return B % V, signal error on divide by zero, reuse B if ACCUM is set";
pattern mod_noerror(b:bat[:oid,:bte],v:wrd) :bat[:oid,:bte]
address CMDbatMODcst
comment "Return B % V, divide by zero causes NIL value";
pattern %(v:bte,b:bat[:oid,:wrd]) :bat[:oid,:bte]
address CMDbatMODcstsignal
comment "Return V % B, signal error on divide by zero";
pattern mod_noerror(v:bte,b:bat[:oid,:wrd]) :bat[:oid,:bte]
address CMDbatMODcst
comment "Return V % B, divide by zero causes NIL value";

command %(b1:bat[:oid,:bte],b2:bat[:oid,:lng]) :bat[:oid,:bte]
address CMDbatMODsignal
comment "Return B1 % B2, signal error on divide by zero";
command %(b1:bat[:oid,:bte],b2:bat[:oid,:lng],accum:int) :bat[:oid,:bte]
address CMDbatMODsignalaccum
comment "Return B1 % B2, signal error on divide by zero, reuse B1 or B2 depending on ACCUM";
command mod_noerror(b1:bat[:oid,:bte],b2:bat[:oid,:lng]) :bat[:oid,:bte]
address CMDbatMOD
comment "Return B1 % B2, divide by zero causes NIL value";
pattern %(b:bat[:oid,:bte],v:lng) :bat[:oid,:bte]
address CMDbatMODcstsignal
comment "Return B % V, signal error on divide by zero";
pattern %(b:bat[:oid,:bte],v:lng,accum:int) :bat[:oid,:bte]
address CMDbatMODcstsignal
comment "Return B % V, signal error on divide by zero, reuse B if ACCUM is set";
pattern mod_noerror(b:bat[:oid,:bte],v:lng) :bat[:oid,:bte]
address CMDbatMODcst
comment "Return B % V, divide by zero causes NIL value";
pattern %(v:bte,b:bat[:oid,:lng]) :bat[:oid,:bte]
address CMDbatMODcstsignal
comment "Return V % B, signal error on divide by zero";
pattern mod_noerror(v:bte,b:bat[:oid,:lng]) :bat[:oid,:bte]
address CMDbatMODcst
comment "Return V % B, divide by zero causes NIL value";

command %(b1:bat[:oid,:sht],b2:bat[:oid,:bte]) :bat[:oid,:bte]
address CMDbatMODsignal
comment "Return B1 % B2, signal error on divide by zero";
command %(b1:bat[:oid,:sht],b2:bat[:oid,:bte],accum:int) :bat[:oid,:bte]
address CMDbatMODsignalaccum
comment "Return B1 % B2, signal error on divide by zero, reuse B1 or B2 depending on ACCUM";
command mod_noerror(b1:bat[:oid,:sht],b2:bat[:oid,:bte]) :bat[:oid,:bte]
address CMDbatMOD
comment "Return B1 % B2, divide by zero causes NIL value";
pattern %(b:bat[:oid,:sht],v:bte) :bat[:oid,:bte]
address CMDbatMODcstsignal
comment "Return B % V, signal error on divide by zero";
pattern mod_noerror(b:bat[:oid,:sht],v:bte) :bat[:oid,:bte]
address CMDbatMODcst
comment "Return B % V, divide by zero causes NIL value";
pattern %(v:sht,b:bat[:oid,:bte]) :bat[:oid,:bte]
address CMDbatMODcstsignal
comment "Return V % B, signal error on divide by zero";
pattern %(v:sht,b:bat[:oid,:bte],accum:int) :bat[:oid,:bte]
address CMDbatMODcstsignal
comment "Return V % B, signal error on divide by zero, reuse B if ACCUM is set";
pattern mod_noerror(v:sht,b:bat[:oid,:bte]) :bat[:oid,:bte]
address CMDbatMODcst
comment "Return V % B, divide by zero causes NIL value";

command %(b1:bat[:oid,:sht],b2:bat[:oid,:sht]) :bat[:oid,:sht]
address CMDbatMODsignal
comment "Return B1 % B2, signal error on divide by zero";
command %(b1:bat[:oid,:sht],b2:bat[:oid,:sht],accum:int) :bat[:oid,:sht]
address CMDbatMODsignalaccum
comment "Return B1 % B2, signal error on divide by zero, reuse B1 or B2 depending on ACCUM";
command mod_noerror(b1:bat[:oid,:sht],b2:bat[:oid,:sht]) :bat[:oid,:sht]
address CMDbatMOD
comment "Return B1 % B2, divide by zero causes NIL value";
pattern %(b:bat[:oid,:sht],v:sht) :bat[:oid,:sht]
address CMDbatMODcstsignal
comment "Return B % V, signal error on divide by zero";
pattern %(b:bat[:oid,:sht],v:sht,accum:int) :bat[:oid,:sht]
address CMDbatMODcstsignal
comment "Return B % V, signal error on divide by zero, reuse B if ACCUM is set";
pattern mod_noerror(b:bat[:oid,:sht],v:sht) :bat[:oid,:sht]
address CMDbatMODcst
comment "Return B % V, divide by zero causes NIL value";
pattern %(v:sht,b:bat[:oid,:sht]) :bat[:oid,:sht]
address CMDbatMODcstsignal
comment "Return V % B, signal error on divide by zero";
pattern %(v:sht,b:bat[:oid,:sht],accum:int) :bat[:oid,:sht]
address CMDbatMODcstsignal
comment "Return V % B, signal error on divide by zero, reuse B if ACCUM is set";
pattern mod_noerror(v:sht,b:bat[:oid,:sht]) :bat[:oid,:sht]
address CMDbatMODcst
comment "Return V % B, divide by zero causes NIL value";

command %(b1:bat[:oid,:sht],b2:bat[:oid,:int]) :bat[:oid,:sht]
address CMDbatMODsignal
comment "Return B1 % B2, signal error on divide by zero";
command %(b1:bat[:oid,:sht],b2:bat[:oid,:int],accum:int) :bat[:oid,:sht]
address CMDbatMODsignalaccum
comment "Return B1 % B2, signal error on divide by zero, reuse B1 or B2 depending on ACCUM";
command mod_noerror(b1:bat[:oid,:sht],b2:bat[:oid,:int]) :bat[:oid,:sht]
address CMDbatMOD
comment "Return B1 % B2, divide by zero causes NIL value";
pattern %(b:bat[:oid,:sht],v:int) :bat[:oid,:sht]
address CMDbatMODcstsignal
comment "Return B % V, signal error on divide by zero";
pattern %(b:bat[:oid,:sht],v:int,accum:int) :bat[:oid,:sht]
address CMDbatMODcstsignal
comment "Return B % V, signal error on divide by zero, reuse B if ACCUM is set";
pattern mod_noerror(b:bat[:oid,:sht],v:int) :bat[:oid,:sht]
address CMDbatMODcst
comment "Return B % V, divide by zero causes NIL value";
pattern %(v:sht,b:bat[:oid,:int]) :bat[:oid,:sht]
address CMDbatMODcstsignal
comment "Return V % B, signal error on divide by zero";
pattern mod_noerror(v:sht,b:bat[:oid,:int]) :bat[:oid,:sht]
address CMDbatMODcst
comment "Return V % B, divide by zero causes NIL value";

command %(b1:bat[:oid,:sht],b2:bat[:oid,:wrd]) :bat[:oid,:sht]
address CMDbatMODsignal
comment "Return B1 % B2, signal error on divide by zero";
command %(b1:bat[:oid,:sht],b2:bat[:oid,:wrd],accum:int) :bat[:oid,:sht]
address CMDbatMODsignalaccum
comment "Return B1 % B2, signal error on divide by zero, reuse B1 or B2 depending on ACCUM";
command mod_noerror(b1:bat[:oid,:sht],b2:bat[:oid,:wrd]) :bat[:oid,:sht]
address CMDbatMOD
comment "Return B1 % B2, divide by zero causes NIL value";
pattern %(b:bat[:oid,:sht],v:wrd) :bat[:oid,:sht]
address CMDbatMODcstsignal
comment "Return B % V, signal error on divide by zero";
pattern %(b:bat[:oid,:sht],v:wrd,accum:int) :bat[:oid,:sht]
address CMDbatMODcstsignal
comment "Return B % V, signal error on divide by zero, reuse B if ACCUM is set";
pattern mod_noerror(b:bat[:oid,:sht],v:wrd) :bat[:oid,:sht]
address CMDbatMODcst
comment "Return B % V, divide by zero causes NIL value";
pattern %(v:sht,b:bat[:oid,:wrd]) :bat[:oid,:sht]
address CMDbatMODcstsignal
comment "Return V % B, signal error on divide by zero";
pattern mod_noerror(v:sht,b:bat[:oid,:wrd]) :bat[:oid,:sht]
address CMDbatMODcst
comment "Return V % B, divide by zero causes NIL value";

command %(b1:bat[:oid,:sht],b2:bat[:oid,:lng]) :bat[:oid,:sht]
address CMDbatMODsignal
comment "Return B1 % B2, signal error on divide by zero";
command %(b1:bat[:oid,:sht],b2:bat[:oid,:lng],accum:int) :bat[:oid,:sht]
address CMDbatMODsignalaccum
comment "Return B1 % B2, signal error on divide by zero, reuse B1 or B2 depending on ACCUM";
command mod_noerror(b1:bat[:oid,:sht],b2:bat[:oid,:lng]) :bat[:oid,:sht]
address CMDbatMOD
comment "Return B1 % B2, divide by zero causes NIL value";
pattern %(b:bat[:oid,:sht],v:lng) :bat[:oid,:sht]
address CMDbatMODcstsignal
comment "Return B % V, signal error on divide by zero";
pattern %(b:bat[:oid,:sht],v:lng,accum:int) :bat[:oid,:sht]
address CMDbatMODcstsignal
comment "Return B % V, signal error on divide by zero, reuse B if ACCUM is set";
pattern mod_noerror(b:bat[:oid,:sht],v:lng) :bat[:oid,:sht]
address CMDbatMODcst
comment "Return B % V, divide by zero causes NIL value";
pattern %(v:sht,b:bat[:oid,:lng]) :bat[:oid,:sht]
address CMDbatMODcstsignal
comment "Return V % B, signal error on divide by zero";
pattern mod_noerror(v:sht,b:bat[:oid,:lng]) :bat[:oid,:sht]
address CMDbatMODcst
comment "Return V % B, divide by zero causes NIL value";

command %(b1:bat[:oid,:int],b2:bat[:oid,:bte]) :bat[:oid,:bte]
address CMDbatMODsignal
comment "Return B1 % B2, signal error on divide by zero";
command %(b1:bat[:oid,:int],b2:bat[:oid,:bte],accum:int) :bat[:oid,:bte]
address CMDbatMODsignalaccum
comment "Return B1 % B2, signal error on divide by zero, reuse B1 or B2 depending on ACCUM";
command mod_noerror(b1:bat[:oid,:int],b2:bat[:oid,:bte]) :bat[:oid,:bte]
address CMDbatMOD
comment "Return B1 % B2, divide by zero causes NIL value";
pattern %(b:bat[:oid,:int],v:bte) :bat[:oid,:bte]
address CMDbatMODcstsignal
comment "Return B % V, signal error on divide by zero";
pattern mod_noerror(b:bat[:oid,:int],v:bte) :bat[:oid,:bte]
address CMDbatMODcst
comment "Return B % V, divide by zero causes NIL value";
pattern %(v:int,b:bat[:oid,:bte]) :bat[:oid,:bte]
address CMDbatMODcstsignal
comment "Return V % B, signal error on divide by zero";
pattern %(v:int,b:bat[:oid,:bte],accum:int) :bat[:oid,:bte]
address CMDbatMODcstsignal
comment "Return V % B, signal error on divide by zero, reuse B if ACCUM is set";
pattern mod_noerror(v:int,b:bat[:oid,:bte]) :bat[:oid,:bte]
address CMDbatMODcst
comment "Return V % B, divide by zero causes NIL value";

command %(b1:bat[:oid,:int],b2:bat[:oid,:sht]) :bat[:oid,:sht]
address CMDbatMODsignal
comment "Return B1 % B2, signal error on divide by zero";
command %(b1:bat[:oid,:int],b2:bat[:oid,:sht],accum:int) :bat[:oid,:sht]
address CMDbatMODsignalaccum
comment "Return B1 % B2, signal error on divide by zero, reuse B1 or B2 depending on ACCUM";
command mod_noerror(b1:bat[:oid,:int],b2:bat[:oid,:sht]) :bat[:oid,:sht]
address CMDbatMOD
comment "Return B1 % B2, divide by zero causes NIL value";
pattern %(b:bat[:oid,:int],v:sht) :bat[:oid,:sht]
address CMDbatMODcstsignal
comment "Return B % V, signal error on divide by zero";
pattern mod_noerror(b:bat[:oid,:int],v:sht) :bat[:oid,:sht]
address CMDbatMODcst
comment "Return B % V, divide by zero causes NIL value";
pattern %(v:int,b:bat[:oid,:sht]) :bat[:oid,:sht]
address CMDbatMODcstsignal
comment "Return V % B, signal error on divide by zero";
pattern %(v:int,b:bat[:oid,:sht],accum:int) :bat[:oid,:sht]
address CMDbatMODcstsignal
comment "Return V % B, signal error on divide by zero, reuse B if ACCUM is set";
pattern mod_noerror(v:int,b:bat[:oid,:sht]) :bat[:oid,:sht]
address CMDbatMODcst
comment "Return V % B, divide by zero causes NIL value";

command %(b1:bat[:oid,:int],b2:bat[:oid,:int]) :bat[:oid,:int]
address CMDbatMODsignal
comment "Return B1 % B2, signal error on divide by zero";
command %(b1:bat[:oid,:int],b2:bat[:oid,:int],accum:int) :bat[:oid,:int]
address CMDbatMODsignalaccum
comment "Return B1 % B2, signal error on divide by zero, reuse B1 or B2 depending on ACCUM";
command mod_noerror(b1:bat[:oid,:int],b2:bat[:oid,:int]) :bat[:oid,:int]
address CMDbatMOD
comment "Return B1 % B2, divide by zero causes NIL value";
pattern %(b:bat[:oid,:int],v:int) :bat[:oid,:int]
address CMDbatMODcstsignal
comment "Return B % V, signal error on divide by zero";
pattern %(b:bat[:oid,:int],v:int,accum:int) :bat[:oid,:int]
address CMDbatMODcstsignal
comment "Return B % V, signal error on divide by zero, reuse B if ACCUM is set";
pattern mod_noerror(b:bat[:oid,:int],v:int) :bat[:oid,:int]
address CMDbatMODcst
comment "Return B % V, divide by zero causes NIL value";
pattern %(v:int,b:bat[:oid,:int]) :bat[:oid,:int]
address CMDbatMODcstsignal
comment "Return V % B, signal error on divide by zero";
pattern %(v:int,b:bat[:oid,:int],accum:int) :bat[:oid,:int]
address CMDbatMODcstsignal
comment "Return V % B, signal error on divide by zero, reuse B if ACCUM is set";
pattern mod_noerror(v:int,b:bat[:oid,:int]) :bat[:oid,:int]
address CMDbatMODcst
comment "Return V % B, divide by zero causes NIL value";

command %(b1:bat[:oid,:int],b2:bat[:oid,:wrd]) :bat[:oid,:int]
address CMDbatMODsignal
comment "Return B1 % B2, signal error on divide by zero";
command %(b1:bat[:oid,:int],b2:bat[:oid,:wrd],accum:int) :bat[:oid,:int]
address CMDbatMODsignalaccum
comment "Return B1 % B2, signal error on divide by zero, reuse B1 or B2 depending on ACCUM";
command mod_noerror(b1:bat[:oid,:int],b2:bat[:oid,:wrd]) :bat[:oid,:int]
address CMDbatMOD
comment "Return B1 % B2, divide by zero causes NIL value";
pattern %(b:bat[:oid,:int],v:wrd) :bat[:oid,:int]
address CMDbatMODcstsignal
comment "Return B % V, signal error on divide by zero";
pattern %(b:bat[:oid,:int],v:wrd,accum:int) :bat[:oid,:int]
address CMDbatMODcstsignal
comment "Return B % V, signal error on divide by zero, reuse B if ACCUM is set";
pattern mod_noerror(b:bat[:oid,:int],v:wrd) :bat[:oid,:int]
address CMDbatMODcst
comment "Return B % V, divide by zero causes NIL value";
pattern %(v:int,b:bat[:oid,:wrd]) :bat[:oid,:int]
address CMDbatMODcstsignal
comment "Return V % B, signal error on divide by zero";
pattern mod_noerror(v:int,b:bat[:oid,:wrd]) :bat[:oid,:int]
address CMDbatMODcst
comment "Return V % B, divide by zero causes NIL value";

command %(b1:bat[:oid,:int],b2:bat[:oid,:lng]) :bat[:oid,:int]
address CMDbatMODsignal
comment "Return B1 % B2, signal error on divide by zero";
command %(b1:bat[:oid,:int],b2:bat[:oid,:lng],accum:int) :bat[:oid,:int]
address CMDbatMODsignalaccum
comment "Return B1 % B2, signal error on divide by zero, reuse B1 or B2 depending on ACCUM";
command mod_noerror(b1:bat[:oid,:int],b2:bat[:oid,:lng]) :bat[:oid,:int]
address CMDbatMOD
comment "Return B1 % B2, divide by zero causes NIL value";
pattern %(b:bat[:oid,:int],v:lng) :bat[:oid,:int]
address CMDbatMODcstsignal
comment "Return B % V, signal error on divide by zero";
pattern %(b:bat[:oid,:int],v:lng,accum:int) :bat[:oid,:int]
address CMDbatMODcstsignal
comment "Return B % V, signal error on divide by zero, reuse B if ACCUM is set";
pattern mod_noerror(b:bat[:oid,:int],v:lng) :bat[:oid,:int]
address CMDbatMODcst
comment "Return B % V, divide by zero causes NIL value";
pattern %(v:int,b:bat[:oid,:lng]) :bat[:oid,:int]
address CMDbatMODcstsignal
comment "Return V % B, signal error on divide by zero";
pattern mod_noerror(v:int,b:bat[:oid,:lng]) :bat[:oid,:int]
address CMDbatMODcst
comment "Return V % B, divide by zero causes NIL value";

command %(b1:bat[:oid,:wrd],b2:bat[:oid,:bte]) :bat[:oid,:bte]
address CMDbatMODsignal
comment "Return B1 % B2, signal error on divide by zero";
command %(b1:bat[:oid,:wrd],b2:bat[:oid,:bte],accum:int) :bat[:oid,:bte]
address CMDbatMODsignalaccum
comment "Return B1 % B2, signal error on divide by zero, reuse B1 or B2 depending on ACCUM";
command mod_noerror(b1:bat[:oid,:wrd],b2:bat[:oid,:bte]) :bat[:oid,:bte]
address CMDbatMOD
comment "Return B1 % B2, divide by zero causes NIL value";
pattern %(b:bat[:oid,:wrd],v:bte) :bat[:oid,:bte]
address CMDbatMODcstsignal
comment "Return B % V, signal error on divide by zero";
pattern mod_noerror(b:bat[:oid,:wrd],v:bte) :bat[:oid,:bte]
address CMDbatMODcst
comment "Return B % V, divide by zero causes NIL value";
pattern %(v:wrd,b:bat[:oid,:bte]) :bat[:oid,:bte]
address CMDbatMODcstsignal
comment "Return V % B, signal error on divide by zero";
pattern %(v:wrd,b:bat[:oid,:bte],accum:int) :bat[:oid,:bte]
address CMDbatMODcstsignal
comment "Return V % B, signal error on divide by zero, reuse B if ACCUM is set";
pattern mod_noerror(v:wrd,b:bat[:oid,:bte]) :bat[:oid,:bte]
address CMDbatMODcst
comment "Return V % B, divide by zero causes NIL value";

command %(b1:bat[:oid,:wrd],b2:bat[:oid,:sht]) :bat[:oid,:sht]
address CMDbatMODsignal
comment "Return B1 % B2, signal error on divide by zero";
command %(b1:bat[:oid,:wrd],b2:bat[:oid,:sht],accum:int) :bat[:oid,:sht]
address CMDbatMODsignalaccum
comment "Return B1 % B2, signal error on divide by zero, reuse B1 or B2 depending on ACCUM";
command mod_noerror(b1:bat[:oid,:wrd],b2:bat[:oid,:sht]) :bat[:oid,:sht]
address CMDbatMOD
comment "Return B1 % B2, divide by zero causes NIL value";
pattern %(b:bat[:oid,:wrd],v:sht) :bat[:oid,:sht]
address CMDbatMODcstsignal
comment "Return B % V, signal error on divide by zero";
pattern mod_noerror(b:bat[:oid,:wrd],v:sht) :bat[:oid,:sht]
address CMDbatMODcst
comment "Return B % V, divide by zero causes NIL value";
pattern %(v:wrd,b:bat[:oid,:sht]) :bat[:oid,:sht]
address CMDbatMODcstsignal
comment "Return V % B, signal error on divide by zero";
pattern %(v:wrd,b:bat[:oid,:sht],accum:int) :bat[:oid,:sht]
address CMDbatMODcstsignal
comment "Return V % B, signal error on divide by zero, reuse B if ACCUM is set";
pattern mod_noerror(v:wrd,b:bat[:oid,:sht]) :bat[:oid,:sht]
address CMDbatMODcst
comment "Return V % B, divide by zero causes NIL value";

command %(b1:bat[:oid,:wrd],b2:bat[:oid,:int]) :bat[:oid,:int]
address CMDbatMODsignal
comment "Return B1 % B2, signal error on divide by zero";
command %(b1:bat[:oid,:wrd],b2:bat[:oid,:int],accum:int) :bat[:oid,:int]
address CMDbatMODsignalaccum
comment "Return B1 % B2, signal error on divide by zero, reuse B1 or B2 depending on ACCUM";
command mod_noerror(b1:bat[:oid,:wrd],b2:bat[:oid,:int]) :bat[:oid,:int]
address CMDbatMOD
comment "Return B1 % B2, divide by zero causes NIL value";
pattern %(b:bat[:oid,:wrd],v:int) :bat[:oid,:int]
address CMDbatMODcstsignal
comment "Return B % V, signal error on divide by zero";
pattern mod_noerror(b:bat[:oid,:wrd],v:int) :bat[:oid,:int]
address CMDbatMODcst
comment "Return B % V, divide by zero causes NIL value";
pattern %(v:wrd,b:bat[:oid,:int]) :bat[:oid,:int]
address CMDbatMODcstsignal
comment "Return V % B, signal error on divide by zero";
pattern %(v:wrd,b:bat[:oid,:int],accum:int) :bat[:oid,:int]
address CMDbatMODcstsignal
comment "Return V % B, signal error on divide by zero, reuse B if ACCUM is set";
pattern mod_noerror(v:wrd,b:bat[:oid,:int]) :bat[:oid,:int]
address CMDbatMODcst
comment "Return V % B, divide by zero causes NIL value";

command %(b1:bat[:oid,:wrd],b2:bat[:oid,:wrd]) :bat[:oid,:wrd]
address CMDbatMODsignal
comment "Return B1 % B2, signal error on divide by zero";
command %(b1:bat[:oid,:wrd],b2:bat[:oid,:wrd],accum:int) :bat[:oid,:wrd]
address CMDbatMODsignalaccum
comment "Return B1 % B2, signal error on divide by zero, reuse B1 or B2 depending on ACCUM";
command mod_noerror(b1:bat[:oid,:wrd],b2:bat[:oid,:wrd]) :bat[:oid,:wrd]
address CMDbatMOD
comment "Return B1 % B2, divide by zero causes NIL value";
pattern %(b:bat[:oid,:wrd],v:wrd) :bat[:oid,:wrd]
address CMDbatMODcstsignal
comment "Return B % V, signal error on divide by zero";
pattern %(b:bat[:oid,:wrd],v:wrd,accum:int) :bat[:oid,:wrd]
address CMDbatMODcstsignal
comment "Return B % V, signal error on divide by zero, reuse B if ACCUM is set";
pattern mod_noerror(b:bat[:oid,:wrd],v:wrd) :bat[:oid,:wrd]
address CMDbatMODcst
comment "Return B % V, divide by zero causes NIL value";
pattern %(v:wrd,b:bat[:oid,:wrd]) :bat[:oid,:wrd]
address CMDbatMODcstsignal
comment "Return V % B, signal error on divide by zero";
pattern %(v:wrd,b:bat[:oid,:wrd],accum:int) :bat[:oid,:wrd]
address CMDbatMODcstsignal
comment "Return V % B, signal error on divide by zero, reuse B if ACCUM is set";
pattern mod_noerror(v:wrd,b:bat[:oid,:wrd]) :bat[:oid,:wrd]
address CMDbatMODcst
comment "Return V % B, divide by zero causes NIL value";

command %(b1:bat[:oid,:wrd],b2:bat[:oid,:lng]) :bat[:oid,:wrd]
address CMDbatMODsignal
comment "Return B1 % B2, signal error on divide by zero";
command %(b1:bat[:oid,:wrd],b2:bat[:oid,:lng],accum:int) :bat[:oid,:wrd]
address CMDbatMODsignalaccum
comment "Return B1 % B2, signal error on divide by zero, reuse B1 or B2 depending on ACCUM";
command mod_noerror(b1:bat[:oid,:wrd],b2:bat[:oid,:lng]) :bat[:oid,:wrd]
address CMDbatMOD
comment "Return B1 % B2, divide by zero causes NIL value";
pattern %(b:bat[:oid,:wrd],v:lng) :bat[:oid,:wrd]
address CMDbatMODcstsignal
comment "Return B % V, signal error on divide by zero";
pattern %(b:bat[:oid,:wrd],v:lng,accum:int) :bat[:oid,:wrd]
address CMDbatMODcstsignal
comment "Return B % V, signal error on divide by zero, reuse B if ACCUM is set";
pattern mod_noerror(b:bat[:oid,:wrd],v:lng) :bat[:oid,:wrd]
address CMDbatMODcst
comment "Return B % V, divide by zero causes NIL value";
pattern %(v:wrd,b:bat[:oid,:lng]) :bat[:oid,:wrd]
address CMDbatMODcstsignal
comment "Return V % B, signal error on divide by zero";
pattern mod_noerror(v:wrd,b:bat[:oid,:lng]) :bat[:oid,:wrd]
address CMDbatMODcst
comment "Return V % B, divide by zero causes NIL value";

command %(b1:bat[:oid,:lng],b2:bat[:oid,:bte]) :bat[:oid,:bte]
address CMDbatMODsignal
comment "Return B1 % B2, signal error on divide by zero";
command %(b1:bat[:oid,:lng],b2:bat[:oid,:bte],accum:int) :bat[:oid,:bte]
address CMDbatMODsignalaccum
comment "Return B1 % B2, signal error on divide by zero, reuse B1 or B2 depending on ACCUM";
command mod_noerror(b1:bat[:oid,:lng],b2:bat[:oid,:bte]) :bat[:oid,:bte]
address CMDbatMOD
comment "Return B1 % B2, divide by zero causes NIL value";
pattern %(b:bat[:oid,:lng],v:bte) :bat[:oid,:bte]
address CMDbatMODcstsignal
comment "Return B % V, signal error on divide by zero";
pattern mod_noerror(b:bat[:oid,:lng],v:bte) :bat[:oid,:bte]
address CMDbatMODcst
comment "Return B % V, divide by zero causes NIL value";
pattern %(v:lng,b:bat[:oid,:bte]) :bat[:oid,:bte]
address CMDbatMODcstsignal
comment "Return V % B, signal error on divide by zero";
pattern %(v:lng,b:bat[:oid,:bte],accum:int) :bat[:oid,:bte]
address CMDbatMODcstsignal
comment "Return V % B, signal error on divide by zero, reuse B if ACCUM is set";
pattern mod_noerror(v:lng,b:bat[:oid,:bte]) :bat[:oid,:bte]
address CMDbatMODcst
comment "Return V % B, divide by zero causes NIL value";

command %(b1:bat[:oid,:lng],b2:bat[:oid,:sht]) :bat[:oid,:sht]
address CMDbatMODsignal
comment "Return B1 % B2, signal error on divide by zero";
command %(b1:bat[:oid,:lng],b2:bat[:oid,:sht],accum:int) :bat[:oid,:sht]
address CMDbatMODsignalaccum
comment "Return B1 % B2, signal error on divide by zero, reuse B1 or B2 depending on ACCUM";
command mod_noerror(b1:bat[:oid,:lng],b2:bat[:oid,:sht]) :bat[:oid,:sht]
address CMDbatMOD
comment "Return B1 % B2, divide by zero causes NIL value";
pattern %(b:bat[:oid,:lng],v:sht) :bat[:oid,:sht]
address CMDbatMODcstsignal
comment "Return B % V, signal error on divide by zero";
pattern mod_noerror(b:bat[:oid,:lng],v:sht) :bat[:oid,:sht]
address CMDbatMODcst
comment "Return B % V, divide by zero causes NIL value";
pattern %(v:lng,b:bat[:oid,:sht]) :bat[:oid,:sht]
address CMDbatMODcstsignal
comment "Return V % B, signal error on divide by zero";
pattern %(v:lng,b:bat[:oid,:sht],accum:int) :bat[:oid,:sht]
address CMDbatMODcstsignal
comment "Return V % B, signal error on divide by zero, reuse B if ACCUM is set";
pattern mod_noerror(v:lng,b:bat[:oid,:sht]) :bat[:oid,:sht]
address CMDbatMODcst
comment "Return V % B, divide by zero causes NIL value";

command %(b1:bat[:oid,:lng],b2:bat[:oid,:int]) :bat[:oid,:int]
address CMDbatMODsignal
comment "Return B1 % B2, signal error on divide by zero";
command %(b1:bat[:oid,:lng],b2:bat[:oid,:int],accum:int) :bat[:oid,:int]
address CMDbatMODsignalaccum
comment "Return B1 % B2, signal error on divide by zero, reuse B1 or B2 depending on ACCUM";
command mod_noerror(b1:bat[:oid,:lng],b2:bat[:oid,:int]) :bat[:oid,:int]
address CMDbatMOD
comment "Return B1 % B2, divide by zero causes NIL value";
pattern %(b:bat[:oid,:lng],v:int) :bat[:oid,:int]
address CMDbatMODcstsignal
comment "Return B % V, signal error on divide by zero";
pattern mod_noerror(b:bat[:oid,:lng],v:int) :bat[:oid,:int]
address CMDbatMODcst
comment "Return B % V, divide by zero causes NIL value";
pattern %(v:lng,b:bat[:oid,:int]) :bat[:oid,:int]
address CMDbatMODcstsignal
comment "Return V % B, signal error on divide by zero";
pattern %(v:lng,b:bat[:oid,:int],accum:int) :bat[:oid,:int]
address CMDbatMODcstsignal
comment "Return V % B, signal error on divide by zero, reuse B if ACCUM is set";
pattern mod_noerror(v:lng,b:bat[:oid,:int]) :bat[:oid,:int]
address CMDbatMODcst
comment "Return V % B, divide by zero causes NIL value";

command %(b1:bat[:oid,:lng],b2:bat[:oid,:wrd]) :bat[:oid,:wrd]
address CMDbatMODsignal
comment "Return B1 % B2, signal error on divide by zero";
command %(b1:bat[:oid,:lng],b2:bat[:oid,:wrd],accum:int) :bat[:oid,:wrd]
address CMDbatMODsignalaccum
comment "Return B1 % B2, signal error on divide by zero, reuse B1 or B2 depending on ACCUM";
command mod_noerror(b1:bat[:oid,:lng],b2:bat[:oid,:wrd]) :bat[:oid,:wrd]
address CMDbatMOD
comment "Return B1 % B2, divide by zero causes NIL value";
pattern %(b:bat[:oid,:lng],v:wrd) :bat[:oid,:wrd]
address CMDbatMODcstsignal
comment "Return B % V, signal error on divide by zero";
pattern mod_noerror(b:bat[:oid,:lng],v:wrd) :bat[:oid,:wrd]
address CMDbatMODcst
comment "Return B % V, divide by zero causes NIL value";
pattern %(v:lng,b:bat[:oid,:wrd]) :bat[:oid,:wrd]
address CMDbatMODcstsignal
comment "Return V % B, signal error on divide by zero";
pattern %(v:lng,b:bat[:oid,:wrd],accum:int) :bat[:oid,:wrd]
address CMDbatMODcstsignal
comment "Return V % B, signal error on divide by zero, reuse B if ACCUM is set";
pattern mod_noerror(v:lng,b:bat[:oid,:wrd]) :bat[:oid,:wrd]
address CMDbatMODcst
comment "Return V % B, divide by zero causes NIL value";

command %(b1:bat[:oid,:lng],b2:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatMODsignal
comment "Return B1 % B2, signal error on divide by zero";
command %(b1:bat[:oid,:lng],b2:bat[:oid,:lng],accum:int) :bat[:oid,:lng]
address CMDbatMODsignalaccum
comment "Return B1 % B2, signal error on divide by zero, reuse B1 or B2 depending on ACCUM";
command mod_noerror(b1:bat[:oid,:lng],b2:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatMOD
comment "Return B1 % B2, divide by zero causes NIL value";
pattern %(b:bat[:oid,:lng],v:lng) :bat[:oid,:lng]
address CMDbatMODcstsignal
comment "Return B % V, signal error on divide by zero";
pattern %(b:bat[:oid,:lng],v:lng,accum:int) :bat[:oid,:lng]
address CMDbatMODcstsignal
comment "Return B % V, signal error on divide by zero, reuse B if ACCUM is set";
pattern mod_noerror(b:bat[:oid,:lng],v:lng) :bat[:oid,:lng]
address CMDbatMODcst
comment "Return B % V, divide by zero causes NIL value";
pattern %(v:lng,b:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatMODcstsignal
comment "Return V % B, signal error on divide by zero";
pattern %(v:lng,b:bat[:oid,:lng],accum:int) :bat[:oid,:lng]
address CMDbatMODcstsignal
comment "Return V % B, signal error on divide by zero, reuse B if ACCUM is set";
pattern mod_noerror(v:lng,b:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatMODcst
comment "Return V % B, divide by zero causes NIL value";


command and(b1:bat[:oid,:bit],b2:bat[:oid,:bit]) :bat[:oid,:bit]
address CMDbatAND
comment "Return B1 AND B2";
command and(b1:bat[:oid,:bit],b2:bat[:oid,:bit], accum:int) :bat[:oid,:bit]
address CMDbatANDaccum
comment "Return B1 AND B2";
pattern and(b:bat[:oid,:bit],v:bit) :bat[:oid,:bit]
address CMDbatANDcst
comment "Return B AND V";
pattern and(b:bat[:oid,:bit],v:bit,accum:int) :bat[:oid,:bit]
address CMDbatANDcst
comment "Return B AND V";
pattern and(v:bit,b:bat[:oid,:bit]) :bat[:oid,:bit]
address CMDbatANDcst
comment "Return V AND B";
pattern and(v:bit,b:bat[:oid,:bit],accum:int) :bat[:oid,:bit]
address CMDbatANDcst
comment "Return V AND B";

command and(b1:bat[:oid,:bte],b2:bat[:oid,:bte]) :bat[:oid,:bte]
address CMDbatAND
comment "Return B1 AND B2";
command and(b1:bat[:oid,:bte],b2:bat[:oid,:bte], accum:int) :bat[:oid,:bte]
address CMDbatANDaccum
comment "Return B1 AND B2";
pattern and(b:bat[:oid,:bte],v:bte) :bat[:oid,:bte]
address CMDbatANDcst
comment "Return B AND V";
pattern and(b:bat[:oid,:bte],v:bte,accum:int) :bat[:oid,:bte]
address CMDbatANDcst
comment "Return B AND V";
pattern and(v:bte,b:bat[:oid,:bte]) :bat[:oid,:bte]
address CMDbatANDcst
comment "Return V AND B";
pattern and(v:bte,b:bat[:oid,:bte],accum:int) :bat[:oid,:bte]
address CMDbatANDcst
comment "Return V AND B";

command and(b1:bat[:oid,:sht],b2:bat[:oid,:sht]) :bat[:oid,:sht]
address CMDbatAND
comment "Return B1 AND B2";
command and(b1:bat[:oid,:sht],b2:bat[:oid,:sht], accum:int) :bat[:oid,:sht]
address CMDbatANDaccum
comment "Return B1 AND B2";
pattern and(b:bat[:oid,:sht],v:sht) :bat[:oid,:sht]
address CMDbatANDcst
comment "Return B AND V";
pattern and(b:bat[:oid,:sht],v:sht,accum:int) :bat[:oid,:sht]
address CMDbatANDcst
comment "Return B AND V";
pattern and(v:sht,b:bat[:oid,:sht]) :bat[:oid,:sht]
address CMDbatANDcst
comment "Return V AND B";
pattern and(v:sht,b:bat[:oid,:sht],accum:int) :bat[:oid,:sht]
address CMDbatANDcst
comment "Return V AND B";

command and(b1:bat[:oid,:int],b2:bat[:oid,:int]) :bat[:oid,:int]
address CMDbatAND
comment "Return B1 AND B2";
command and(b1:bat[:oid,:int],b2:bat[:oid,:int], accum:int) :bat[:oid,:int]
address CMDbatANDaccum
comment "Return B1 AND B2";
pattern and(b:bat[:oid,:int],v:int) :bat[:oid,:int]
address CMDbatANDcst
comment "Return B AND V";
pattern and(b:bat[:oid,:int],v:int,accum:int) :bat[:oid,:int]
address CMDbatANDcst
comment "Return B AND V";
pattern and(v:int,b:bat[:oid,:int]) :bat[:oid,:int]
address CMDbatANDcst
comment "Return V AND B";
pattern and(v:int,b:bat[:oid,:int],accum:int) :bat[:oid,:int]
address CMDbatANDcst
comment "Return V AND B";

command and(b1:bat[:oid,:wrd],b2:bat[:oid,:wrd]) :bat[:oid,:wrd]
address CMDbatAND
comment "Return B1 AND B2";
command and(b1:bat[:oid,:wrd],b2:bat[:oid,:wrd], accum:int) :bat[:oid,:wrd]
address CMDbatANDaccum
comment "Return B1 AND B2";
pattern and(b:bat[:oid,:wrd],v:wrd) :bat[:oid,:wrd]
address CMDbatANDcst
comment "Return B AND V";
pattern and(b:bat[:oid,:wrd],v:wrd,accum:int) :bat[:oid,:wrd]
address CMDbatANDcst
comment "Return B AND V";
pattern and(v:wrd,b:bat[:oid,:wrd]) :bat[:oid,:wrd]
address CMDbatANDcst
comment "Return V AND B";
pattern and(v:wrd,b:bat[:oid,:wrd],accum:int) :bat[:oid,:wrd]
address CMDbatANDcst
comment "Return V AND B";

command and(b1:bat[:oid,:lng],b2:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatAND
comment "Return B1 AND B2";
command and(b1:bat[:oid,:lng],b2:bat[:oid,:lng], accum:int) :bat[:oid,:lng]
address CMDbatANDaccum
comment "Return B1 AND B2";
pattern and(b:bat[:oid,:lng],v:lng) :bat[:oid,:lng]
address CMDbatANDcst
comment "Return B AND V";
pattern and(b:bat[:oid,:lng],v:lng,accum:int) :bat[:oid,:lng]
address CMDbatANDcst
comment "Return B AND V";
pattern and(v:lng,b:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatANDcst
comment "Return V AND B";
pattern and(v:lng,b:bat[:oid,:lng],accum:int) :bat[:oid,:lng]
address CMDbatANDcst
comment "Return V AND B";


command or(b1:bat[:oid,:bit],b2:bat[:oid,:bit]) :bat[:oid,:bit]
address CMDbatOR
comment "Return B1 OR B2";
command or(b1:bat[:oid,:bit],b2:bat[:oid,:bit], accum:int) :bat[:oid,:bit]
address CMDbatORaccum
comment "Return B1 OR B2";
pattern or(b:bat[:oid,:bit],v:bit) :bat[:oid,:bit]
address CMDbatORcst
comment "Return B OR V";
pattern or(b:bat[:oid,:bit],v:bit,accum:int) :bat[:oid,:bit]
address CMDbatORcst
comment "Return B OR V";
pattern or(v:bit,b:bat[:oid,:bit]) :bat[:oid,:bit]
address CMDbatORcst
comment "Return V OR B";
pattern or(v:bit,b:bat[:oid,:bit],accum:int) :bat[:oid,:bit]
address CMDbatORcst
comment "Return V OR B";

command or(b1:bat[:oid,:bte],b2:bat[:oid,:bte]) :bat[:oid,:bte]
address CMDbatOR
comment "Return B1 OR B2";
command or(b1:bat[:oid,:bte],b2:bat[:oid,:bte], accum:int) :bat[:oid,:bte]
address CMDbatORaccum
comment "Return B1 OR B2";
pattern or(b:bat[:oid,:bte],v:bte) :bat[:oid,:bte]
address CMDbatORcst
comment "Return B OR V";
pattern or(b:bat[:oid,:bte],v:bte,accum:int) :bat[:oid,:bte]
address CMDbatORcst
comment "Return B OR V";
pattern or(v:bte,b:bat[:oid,:bte]) :bat[:oid,:bte]
address CMDbatORcst
comment "Return V OR B";
pattern or(v:bte,b:bat[:oid,:bte],accum:int) :bat[:oid,:bte]
address CMDbatORcst
comment "Return V OR B";

command or(b1:bat[:oid,:sht],b2:bat[:oid,:sht]) :bat[:oid,:sht]
address CMDbatOR
comment "Return B1 OR B2";
command or(b1:bat[:oid,:sht],b2:bat[:oid,:sht], accum:int) :bat[:oid,:sht]
address CMDbatORaccum
comment "Return B1 OR B2";
pattern or(b:bat[:oid,:sht],v:sht) :bat[:oid,:sht]
address CMDbatORcst
comment "Return B OR V";
pattern or(b:bat[:oid,:sht],v:sht,accum:int) :bat[:oid,:sht]
address CMDbatORcst
comment "Return B OR V";
pattern or(v:sht,b:bat[:oid,:sht]) :bat[:oid,:sht]
address CMDbatORcst
comment "Return V OR B";
pattern or(v:sht,b:bat[:oid,:sht],accum:int) :bat[:oid,:sht]
address CMDbatORcst
comment "Return V OR B";

command or(b1:bat[:oid,:int],b2:bat[:oid,:int]) :bat[:oid,:int]
address CMDbatOR
comment "Return B1 OR B2";
command or(b1:bat[:oid,:int],b2:bat[:oid,:int], accum:int) :bat[:oid,:int]
address CMDbatORaccum
comment "Return B1 OR B2";
pattern or(b:bat[:oid,:int],v:int) :bat[:oid,:int]
address CMDbatORcst
comment "Return B OR V";
pattern or(b:bat[:oid,:int],v:int,accum:int) :bat[:oid,:int]
address CMDbatORcst
comment "Return B OR V";
pattern or(v:int,b:bat[:oid,:int]) :bat[:oid,:int]
address CMDbatORcst
comment "Return V OR B";
pattern or(v:int,b:bat[:oid,:int],accum:int) :bat[:oid,:int]
address CMDbatORcst
comment "Return V OR B";

command or(b1:bat[:oid,:wrd],b2:bat[:oid,:wrd]) :bat[:oid,:wrd]
address CMDbatOR
comment "Return B1 OR B2";
command or(b1:bat[:oid,:wrd],b2:bat[:oid,:wrd], accum:int) :bat[:oid,:wrd]
address CMDbatORaccum
comment "Return B1 OR B2";
pattern or(b:bat[:oid,:wrd],v:wrd) :bat[:oid,:wrd]
address CMDbatORcst
comment "Return B OR V";
pattern or(b:bat[:oid,:wrd],v:wrd,accum:int) :bat[:oid,:wrd]
address CMDbatORcst
comment "Return B OR V";
pattern or(v:wrd,b:bat[:oid,:wrd]) :bat[:oid,:wrd]
address CMDbatORcst
comment "Return V OR B";
pattern or(v:wrd,b:bat[:oid,:wrd],accum:int) :bat[:oid,:wrd]
address CMDbatORcst
comment "Return V OR B";

command or(b1:bat[:oid,:lng],b2:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatOR
comment "Return B1 OR B2";
command or(b1:bat[:oid,:lng],b2:bat[:oid,:lng], accum:int) :bat[:oid,:lng]
address CMDbatORaccum
comment "Return B1 OR B2";
pattern or(b:bat[:oid,:lng],v:lng) :bat[:oid,:lng]
address CMDbatORcst
comment "Return B OR V";
pattern or(b:bat[:oid,:lng],v:lng,accum:int) :bat[:oid,:lng]
address CMDbatORcst
comment "Return B OR V";
pattern or(v:lng,b:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatORcst
comment "Return V OR B";
pattern or(v:lng,b:bat[:oid,:lng],accum:int) :bat[:oid,:lng]
address CMDbatORcst
comment "Return V OR B";


command xor(b1:bat[:oid,:bit],b2:bat[:oid,:bit]) :bat[:oid,:bit]
address CMDbatXOR
comment "Return B1 XOR B2";
command xor(b1:bat[:oid,:bit],b2:bat[:oid,:bit], accum:int) :bat[:oid,:bit]
address CMDbatXORaccum
comment "Return B1 XOR B2";
pattern xor(b:bat[:oid,:bit],v:bit) :bat[:oid,:bit]
address CMDbatXORcst
comment "Return B XOR V";
pattern xor(b:bat[:oid,:bit],v:bit,accum:int) :bat[:oid,:bit]
address CMDbatXORcst
comment "Return B XOR V";
pattern xor(v:bit,b:bat[:oid,:bit]) :bat[:oid,:bit]
address CMDbatXORcst
comment "Return V XOR B";
pattern xor(v:bit,b:bat[:oid,:bit],accum:int) :bat[:oid,:bit]
address CMDbatXORcst
comment "Return V XOR B";

command xor(b1:bat[:oid,:bte],b2:bat[:oid,:bte]) :bat[:oid,:bte]
address CMDbatXOR
comment "Return B1 XOR B2";
command xor(b1:bat[:oid,:bte],b2:bat[:oid,:bte], accum:int) :bat[:oid,:bte]
address CMDbatXORaccum
comment "Return B1 XOR B2";
pattern xor(b:bat[:oid,:bte],v:bte) :bat[:oid,:bte]
address CMDbatXORcst
comment "Return B XOR V";
pattern xor(b:bat[:oid,:bte],v:bte,accum:int) :bat[:oid,:bte]
address CMDbatXORcst
comment "Return B XOR V";
pattern xor(v:bte,b:bat[:oid,:bte]) :bat[:oid,:bte]
address CMDbatXORcst
comment "Return V XOR B";
pattern xor(v:bte,b:bat[:oid,:bte],accum:int) :bat[:oid,:bte]
address CMDbatXORcst
comment "Return V XOR B";

command xor(b1:bat[:oid,:sht],b2:bat[:oid,:sht]) :bat[:oid,:sht]
address CMDbatXOR
comment "Return B1 XOR B2";
command xor(b1:bat[:oid,:sht],b2:bat[:oid,:sht], accum:int) :bat[:oid,:sht]
address CMDbatXORaccum
comment "Return B1 XOR B2";
pattern xor(b:bat[:oid,:sht],v:sht) :bat[:oid,:sht]
address CMDbatXORcst
comment "Return B XOR V";
pattern xor(b:bat[:oid,:sht],v:sht,accum:int) :bat[:oid,:sht]
address CMDbatXORcst
comment "Return B XOR V";
pattern xor(v:sht,b:bat[:oid,:sht]) :bat[:oid,:sht]
address CMDbatXORcst
comment "Return V XOR B";
pattern xor(v:sht,b:bat[:oid,:sht],accum:int) :bat[:oid,:sht]
address CMDbatXORcst
comment "Return V XOR B";

command xor(b1:bat[:oid,:int],b2:bat[:oid,:int]) :bat[:oid,:int]
address CMDbatXOR
comment "Return B1 XOR B2";
command xor(b1:bat[:oid,:int],b2:bat[:oid,:int], accum:int) :bat[:oid,:int]
address CMDbatXORaccum
comment "Return B1 XOR B2";
pattern xor(b:bat[:oid,:int],v:int) :bat[:oid,:int]
address CMDbatXORcst
comment "Return B XOR V";
pattern xor(b:bat[:oid,:int],v:int,accum:int) :bat[:oid,:int]
address CMDbatXORcst
comment "Return B XOR V";
pattern xor(v:int,b:bat[:oid,:int]) :bat[:oid,:int]
address CMDbatXORcst
comment "Return V XOR B";
pattern xor(v:int,b:bat[:oid,:int],accum:int) :bat[:oid,:int]
address CMDbatXORcst
comment "Return V XOR B";

command xor(b1:bat[:oid,:wrd],b2:bat[:oid,:wrd]) :bat[:oid,:wrd]
address CMDbatXOR
comment "Return B1 XOR B2";
command xor(b1:bat[:oid,:wrd],b2:bat[:oid,:wrd], accum:int) :bat[:oid,:wrd]
address CMDbatXORaccum
comment "Return B1 XOR B2";
pattern xor(b:bat[:oid,:wrd],v:wrd) :bat[:oid,:wrd]
address CMDbatXORcst
comment "Return B XOR V";
pattern xor(b:bat[:oid,:wrd],v:wrd,accum:int) :bat[:oid,:wrd]
address CMDbatXORcst
comment "Return B XOR V";
pattern xor(v:wrd,b:bat[:oid,:wrd]) :bat[:oid,:wrd]
address CMDbatXORcst
comment "Return V XOR B";
pattern xor(v:wrd,b:bat[:oid,:wrd],accum:int) :bat[:oid,:wrd]
address CMDbatXORcst
comment "Return V XOR B";

command xor(b1:bat[:oid,:lng],b2:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatXOR
comment "Return B1 XOR B2";
command xor(b1:bat[:oid,:lng],b2:bat[:oid,:lng], accum:int) :bat[:oid,:lng]
address CMDbatXORaccum
comment "Return B1 XOR B2";
pattern xor(b:bat[:oid,:lng],v:lng) :bat[:oid,:lng]
address CMDbatXORcst
comment "Return B XOR V";
pattern xor(b:bat[:oid,:lng],v:lng,accum:int) :bat[:oid,:lng]
address CMDbatXORcst
comment "Return B XOR V";
pattern xor(v:lng,b:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatXORcst
comment "Return V XOR B";
pattern xor(v:lng,b:bat[:oid,:lng],accum:int) :bat[:oid,:lng]
address CMDbatXORcst
comment "Return V XOR B";


command <<(b1:bat[:oid,:bte],b2:bat[:oid,:bte]) :bat[:oid,:bte]
address CMDbatLSHsignal
comment "Return B1 << B2, raise error on out of range second operand";
command <<(b1:bat[:oid,:bte],b2:bat[:oid,:bte],accum:int) :bat[:oid,:bte]
address CMDbatLSHsignalaccum
comment "Return B1 << B2, raise error on out of range second operand, reuse B if ACCUM is set";
command lsh_noerror(b1:bat[:oid,:bte],b2:bat[:oid,:bte]) :bat[:oid,:bte]
address CMDbatLSH
comment "Return B1 << B2, out of range second operand causes NIL value";
pattern <<(b:bat[:oid,:bte],v:bte) :bat[:oid,:bte]
address CMDbatLSHcstsignal
comment "Return B << V, raise error on out of range second operand";
pattern <<(b:bat[:oid,:bte],v:bte,accum:int) :bat[:oid,:bte]
address CMDbatLSHcstsignal
comment "Return B << V, raise error on out of range second operand, reuse B if ACCUM is set";
pattern lsh_noerror(b:bat[:oid,:bte],v:bte) :bat[:oid,:bte]
address CMDbatLSHcst
comment "Return B << V, out of range second operand causes NIL value";
pattern <<(v:bte,b:bat[:oid,:bte]) :bat[:oid,:bte]
address CMDbatLSHcstsignal
comment "Return V << B, raise error on out of range second operand";
pattern lsh_noerror(v:bte,b:bat[:oid,:bte]) :bat[:oid,:bte]
address CMDbatLSHcst
comment "Return V << B, out of range second operand causes NIL value";

command <<(b1:bat[:oid,:bte],b2:bat[:oid,:sht]) :bat[:oid,:bte]
address CMDbatLSHsignal
comment "Return B1 << B2, raise error on out of range second operand";
command <<(b1:bat[:oid,:bte],b2:bat[:oid,:sht],accum:int) :bat[:oid,:bte]
address CMDbatLSHsignalaccum
comment "Return B1 << B2, raise error on out of range second operand, reuse B if ACCUM is set";
command lsh_noerror(b1:bat[:oid,:bte],b2:bat[:oid,:sht]) :bat[:oid,:bte]
address CMDbatLSH
comment "Return B1 << B2, out of range second operand causes NIL value";
pattern <<(b:bat[:oid,:bte],v:sht) :bat[:oid,:bte]
address CMDbatLSHcstsignal
comment "Return B << V, raise error on out of range second operand";
pattern <<(b:bat[:oid,:bte],v:sht,accum:int) :bat[:oid,:bte]
address CMDbatLSHcstsignal
comment "Return B << V, raise error on out of range second operand, reuse B if ACCUM is set";
pattern lsh_noerror(b:bat[:oid,:bte],v:sht) :bat[:oid,:bte]
address CMDbatLSHcst
comment "Return B << V, out of range second operand causes NIL value";
pattern <<(v:bte,b:bat[:oid,:sht]) :bat[:oid,:bte]
address CMDbatLSHcstsignal
comment "Return V << B, raise error on out of range second operand";
pattern lsh_noerror(v:bte,b:bat[:oid,:sht]) :bat[:oid,:bte]
address CMDbatLSHcst
comment "Return V << B, out of range second operand causes NIL value";

command <<(b1:bat[:oid,:bte],b2:bat[:oid,:int]) :bat[:oid,:bte]
address CMDbatLSHsignal
comment "Return B1 << B2, raise error on out of range second operand";
command <<(b1:bat[:oid,:bte],b2:bat[:oid,:int],accum:int) :bat[:oid,:bte]
address CMDbatLSHsignalaccum
comment "Return B1 << B2, raise error on out of range second operand, reuse B if ACCUM is set";
command lsh_noerror(b1:bat[:oid,:bte],b2:bat[:oid,:int]) :bat[:oid,:bte]
address CMDbatLSH
comment "Return B1 << B2, out of range second operand causes NIL value";
pattern <<(b:bat[:oid,:bte],v:int) :bat[:oid,:bte]
address CMDbatLSHcstsignal
comment "Return B << V, raise error on out of range second operand";
pattern <<(b:bat[:oid,:bte],v:int,accum:int) :bat[:oid,:bte]
address CMDbatLSHcstsignal
comment "Return B << V, raise error on out of range second operand, reuse B if ACCUM is set";
pattern lsh_noerror(b:bat[:oid,:bte],v:int) :bat[:oid,:bte]
address CMDbatLSHcst
comment "Return B << V, out of range second operand causes NIL value";
pattern <<(v:bte,b:bat[:oid,:int]) :bat[:oid,:bte]
address CMDbatLSHcstsignal
comment "Return V << B, raise error on out of range second operand";
pattern lsh_noerror(v:bte,b:bat[:oid,:int]) :bat[:oid,:bte]
address CMDbatLSHcst
comment "Return V << B, out of range second operand causes NIL value";

command <<(b1:bat[:oid,:bte],b2:bat[:oid,:wrd]) :bat[:oid,:bte]
address CMDbatLSHsignal
comment "Return B1 << B2, raise error on out of range second operand";
command <<(b1:bat[:oid,:bte],b2:bat[:oid,:wrd],accum:int) :bat[:oid,:bte]
address CMDbatLSHsignalaccum
comment "Return B1 << B2, raise error on out of range second operand, reuse B if ACCUM is set";
command lsh_noerror(b1:bat[:oid,:bte],b2:bat[:oid,:wrd]) :bat[:oid,:bte]
address CMDbatLSH
comment "Return B1 << B2, out of range second operand causes NIL value";
pattern <<(b:bat[:oid,:bte],v:wrd) :bat[:oid,:bte]
address CMDbatLSHcstsignal
comment "Return B << V, raise error on out of range second operand";
pattern <<(b:bat[:oid,:bte],v:wrd,accum:int) :bat[:oid,:bte]
address CMDbatLSHcstsignal
comment "Return B << V, raise error on out of range second operand, reuse B if ACCUM is set";
pattern lsh_noerror(b:bat[:oid,:bte],v:wrd) :bat[:oid,:bte]
address CMDbatLSHcst
comment "Return B << V, out of range second operand causes NIL value";
pattern <<(v:bte,b:bat[:oid,:wrd]) :bat[:oid,:bte]
address CMDbatLSHcstsignal
comment "Return V << B, raise error on out of range second operand";
pattern lsh_noerror(v:bte,b:bat[:oid,:wrd]) :bat[:oid,:bte]
address CMDbatLSHcst
comment "Return V << B, out of range second operand causes NIL value";

command <<(b1:bat[:oid,:bte],b2:bat[:oid,:lng]) :bat[:oid,:bte]
address CMDbatLSHsignal
comment "Return B1 << B2, raise error on out of range second operand";
command <<(b1:bat[:oid,:bte],b2:bat[:oid,:lng],accum:int) :bat[:oid,:bte]
address CMDbatLSHsignalaccum
comment "Return B1 << B2, raise error on out of range second operand, reuse B if ACCUM is set";
command lsh_noerror(b1:bat[:oid,:bte],b2:bat[:oid,:lng]) :bat[:oid,:bte]
address CMDbatLSH
comment "Return B1 << B2, out of range second operand causes NIL value";
pattern <<(b:bat[:oid,:bte],v:lng) :bat[:oid,:bte]
address CMDbatLSHcstsignal
comment "Return B << V, raise error on out of range second operand";
pattern <<(b:bat[:oid,:bte],v:lng,accum:int) :bat[:oid,:bte]
address CMDbatLSHcstsignal
comment "Return B << V, raise error on out of range second operand, reuse B if ACCUM is set";
pattern lsh_noerror(b:bat[:oid,:bte],v:lng) :bat[:oid,:bte]
address CMDbatLSHcst
comment "Return B << V, out of range second operand causes NIL value";
pattern <<(v:bte,b:bat[:oid,:lng]) :bat[:oid,:bte]
address CMDbatLSHcstsignal
comment "Return V << B, raise error on out of range second operand";
pattern lsh_noerror(v:bte,b:bat[:oid,:lng]) :bat[:oid,:bte]
address CMDbatLSHcst
comment "Return V << B, out of range second operand causes NIL value";

command <<(b1:bat[:oid,:sht],b2:bat[:oid,:bte]) :bat[:oid,:sht]
address CMDbatLSHsignal
comment "Return B1 << B2, raise error on out of range second operand";
command <<(b1:bat[:oid,:sht],b2:bat[:oid,:bte],accum:int) :bat[:oid,:sht]
address CMDbatLSHsignalaccum
comment "Return B1 << B2, raise error on out of range second operand, reuse B if ACCUM is set";
command lsh_noerror(b1:bat[:oid,:sht],b2:bat[:oid,:bte]) :bat[:oid,:sht]
address CMDbatLSH
comment "Return B1 << B2, out of range second operand causes NIL value";
pattern <<(b:bat[:oid,:sht],v:bte) :bat[:oid,:sht]
address CMDbatLSHcstsignal
comment "Return B << V, raise error on out of range second operand";
pattern <<(b:bat[:oid,:sht],v:bte,accum:int) :bat[:oid,:sht]
address CMDbatLSHcstsignal
comment "Return B << V, raise error on out of range second operand, reuse B if ACCUM is set";
pattern lsh_noerror(b:bat[:oid,:sht],v:bte) :bat[:oid,:sht]
address CMDbatLSHcst
comment "Return B << V, out of range second operand causes NIL value";
pattern <<(v:sht,b:bat[:oid,:bte]) :bat[:oid,:sht]
address CMDbatLSHcstsignal
comment "Return V << B, raise error on out of range second operand";
pattern lsh_noerror(v:sht,b:bat[:oid,:bte]) :bat[:oid,:sht]
address CMDbatLSHcst
comment "Return V << B, out of range second operand causes NIL value";

command <<(b1:bat[:oid,:sht],b2:bat[:oid,:sht]) :bat[:oid,:sht]
address CMDbatLSHsignal
comment "Return B1 << B2, raise error on out of range second operand";
command <<(b1:bat[:oid,:sht],b2:bat[:oid,:sht],accum:int) :bat[:oid,:sht]
address CMDbatLSHsignalaccum
comment "Return B1 << B2, raise error on out of range second operand, reuse B if ACCUM is set";
command lsh_noerror(b1:bat[:oid,:sht],b2:bat[:oid,:sht]) :bat[:oid,:sht]
address CMDbatLSH
comment "Return B1 << B2, out of range second operand causes NIL value";
pattern <<(b:bat[:oid,:sht],v:sht) :bat[:oid,:sht]
address CMDbatLSHcstsignal
comment "Return B << V, raise error on out of range second operand";
pattern <<(b:bat[:oid,:sht],v:sht,accum:int) :bat[:oid,:sht]
address CMDbatLSHcstsignal
comment "Return B << V, raise error on out of range second operand, reuse B if ACCUM is set";
pattern lsh_noerror(b:bat[:oid,:sht],v:sht) :bat[:oid,:sht]
address CMDbatLSHcst
comment "Return B << V, out of range second operand causes NIL value";
pattern <<(v:sht,b:bat[:oid,:sht]) :bat[:oid,:sht]
address CMDbatLSHcstsignal
comment "Return V << B, raise error on out of range second operand";
pattern lsh_noerror(v:sht,b:bat[:oid,:sht]) :bat[:oid,:sht]
address CMDbatLSHcst
comment "Return V << B, out of range second operand causes NIL value";

command <<(b1:bat[:oid,:sht],b2:bat[:oid,:int]) :bat[:oid,:sht]
address CMDbatLSHsignal
comment "Return B1 << B2, raise error on out of range second operand";
command <<(b1:bat[:oid,:sht],b2:bat[:oid,:int],accum:int) :bat[:oid,:sht]
address CMDbatLSHsignalaccum
comment "Return B1 << B2, raise error on out of range second operand, reuse B if ACCUM is set";
command lsh_noerror(b1:bat[:oid,:sht],b2:bat[:oid,:int]) :bat[:oid,:sht]
address CMDbatLSH
comment "Return B1 << B2, out of range second operand causes NIL value";
pattern <<(b:bat[:oid,:sht],v:int) :bat[:oid,:sht]
address CMDbatLSHcstsignal
comment "Return B << V, raise error on out of range second operand";
pattern <<(b:bat[:oid,:sht],v:int,accum:int) :bat[:oid,:sht]
address CMDbatLSHcstsignal
comment "Return B << V, raise error on out of range second operand, reuse B if ACCUM is set";
pattern lsh_noerror(b:bat[:oid,:sht],v:int) :bat[:oid,:sht]
address CMDbatLSHcst
comment "Return B << V, out of range second operand causes NIL value";
pattern <<(v:sht,b:bat[:oid,:int]) :bat[:oid,:sht]
address CMDbatLSHcstsignal
comment "Return V << B, raise error on out of range second operand";
pattern lsh_noerror(v:sht,b:bat[:oid,:int]) :bat[:oid,:sht]
address CMDbatLSHcst
comment "Return V << B, out of range second operand causes NIL value";

command <<(b1:bat[:oid,:sht],b2:bat[:oid,:wrd]) :bat[:oid,:sht]
address CMDbatLSHsignal
comment "Return B1 << B2, raise error on out of range second operand";
command <<(b1:bat[:oid,:sht],b2:bat[:oid,:wrd],accum:int) :bat[:oid,:sht]
address CMDbatLSHsignalaccum
comment "Return B1 << B2, raise error on out of range second operand, reuse B if ACCUM is set";
command lsh_noerror(b1:bat[:oid,:sht],b2:bat[:oid,:wrd]) :bat[:oid,:sht]
address CMDbatLSH
comment "Return B1 << B2, out of range second operand causes NIL value";
pattern <<(b:bat[:oid,:sht],v:wrd) :bat[:oid,:sht]
address CMDbatLSHcstsignal
comment "Return B << V, raise error on out of range second operand";
pattern <<(b:bat[:oid,:sht],v:wrd,accum:int) :bat[:oid,:sht]
address CMDbatLSHcstsignal
comment "Return B << V, raise error on out of range second operand, reuse B if ACCUM is set";
pattern lsh_noerror(b:bat[:oid,:sht],v:wrd) :bat[:oid,:sht]
address CMDbatLSHcst
comment "Return B << V, out of range second operand causes NIL value";
pattern <<(v:sht,b:bat[:oid,:wrd]) :bat[:oid,:sht]
address CMDbatLSHcstsignal
comment "Return V << B, raise error on out of range second operand";
pattern lsh_noerror(v:sht,b:bat[:oid,:wrd]) :bat[:oid,:sht]
address CMDbatLSHcst
comment "Return V << B, out of range second operand causes NIL value";

command <<(b1:bat[:oid,:sht],b2:bat[:oid,:lng]) :bat[:oid,:sht]
address CMDbatLSHsignal
comment "Return B1 << B2, raise error on out of range second operand";
command <<(b1:bat[:oid,:sht],b2:bat[:oid,:lng],accum:int) :bat[:oid,:sht]
address CMDbatLSHsignalaccum
comment "Return B1 << B2, raise error on out of range second operand, reuse B if ACCUM is set";
command lsh_noerror(b1:bat[:oid,:sht],b2:bat[:oid,:lng]) :bat[:oid,:sht]
address CMDbatLSH
comment "Return B1 << B2, out of range second operand causes NIL value";
pattern <<(b:bat[:oid,:sht],v:lng) :bat[:oid,:sht]
address CMDbatLSHcstsignal
comment "Return B << V, raise error on out of range second operand";
pattern <<(b:bat[:oid,:sht],v:lng,accum:int) :bat[:oid,:sht]
address CMDbatLSHcstsignal
comment "Return B << V, raise error on out of range second operand, reuse B if ACCUM is set";
pattern lsh_noerror(b:bat[:oid,:sht],v:lng) :bat[:oid,:sht]
address CMDbatLSHcst
comment "Return B << V, out of range second operand causes NIL value";
pattern <<(v:sht,b:bat[:oid,:lng]) :bat[:oid,:sht]
address CMDbatLSHcstsignal
comment "Return V << B, raise error on out of range second operand";
pattern lsh_noerror(v:sht,b:bat[:oid,:lng]) :bat[:oid,:sht]
address CMDbatLSHcst
comment "Return V << B, out of range second operand causes NIL value";

command <<(b1:bat[:oid,:int],b2:bat[:oid,:bte]) :bat[:oid,:int]
address CMDbatLSHsignal
comment "Return B1 << B2, raise error on out of range second operand";
command <<(b1:bat[:oid,:int],b2:bat[:oid,:bte],accum:int) :bat[:oid,:int]
address CMDbatLSHsignalaccum
comment "Return B1 << B2, raise error on out of range second operand, reuse B if ACCUM is set";
command lsh_noerror(b1:bat[:oid,:int],b2:bat[:oid,:bte]) :bat[:oid,:int]
address CMDbatLSH
comment "Return B1 << B2, out of range second operand causes NIL value";
pattern <<(b:bat[:oid,:int],v:bte) :bat[:oid,:int]
address CMDbatLSHcstsignal
comment "Return B << V, raise error on out of range second operand";
pattern <<(b:bat[:oid,:int],v:bte,accum:int) :bat[:oid,:int]
address CMDbatLSHcstsignal
comment "Return B << V, raise error on out of range second operand, reuse B if ACCUM is set";
pattern lsh_noerror(b:bat[:oid,:int],v:bte) :bat[:oid,:int]
address CMDbatLSHcst
comment "Return B << V, out of range second operand causes NIL value";
pattern <<(v:int,b:bat[:oid,:bte]) :bat[:oid,:int]
address CMDbatLSHcstsignal
comment "Return V << B, raise error on out of range second operand";
pattern lsh_noerror(v:int,b:bat[:oid,:bte]) :bat[:oid,:int]
address CMDbatLSHcst
comment "Return V << B, out of range second operand causes NIL value";

command <<(b1:bat[:oid,:int],b2:bat[:oid,:sht]) :bat[:oid,:int]
address CMDbatLSHsignal
comment "Return B1 << B2, raise error on out of range second operand";
command <<(b1:bat[:oid,:int],b2:bat[:oid,:sht],accum:int) :bat[:oid,:int]
address CMDbatLSHsignalaccum
comment "Return B1 << B2, raise error on out of range second operand, reuse B if ACCUM is set";
command lsh_noerror(b1:bat[:oid,:int],b2:bat[:oid,:sht]) :bat[:oid,:int]
address CMDbatLSH
comment "Return B1 << B2, out of range second operand causes NIL value";
pattern <<(b:bat[:oid,:int],v:sht) :bat[:oid,:int]
address CMDbatLSHcstsignal
comment "Return B << V, raise error on out of range second operand";
pattern <<(b:bat[:oid,:int],v:sht,accum:int) :bat[:oid,:int]
address CMDbatLSHcstsignal
comment "Return B << V, raise error on out of range second operand, reuse B if ACCUM is set";
pattern lsh_noerror(b:bat[:oid,:int],v:sht) :bat[:oid,:int]
address CMDbatLSHcst
comment "Return B << V, out of range second operand causes NIL value";
pattern <<(v:int,b:bat[:oid,:sht]) :bat[:oid,:int]
address CMDbatLSHcstsignal
comment "Return V << B, raise error on out of range second operand";
pattern lsh_noerror(v:int,b:bat[:oid,:sht]) :bat[:oid,:int]
address CMDbatLSHcst
comment "Return V << B, out of range second operand causes NIL value";

command <<(b1:bat[:oid,:int],b2:bat[:oid,:int]) :bat[:oid,:int]
address CMDbatLSHsignal
comment "Return B1 << B2, raise error on out of range second operand";
command <<(b1:bat[:oid,:int],b2:bat[:oid,:int],accum:int) :bat[:oid,:int]
address CMDbatLSHsignalaccum
comment "Return B1 << B2, raise error on out of range second operand, reuse B if ACCUM is set";
command lsh_noerror(b1:bat[:oid,:int],b2:bat[:oid,:int]) :bat[:oid,:int]
address CMDbatLSH
comment "Return B1 << B2, out of range second operand causes NIL value";
pattern <<(b:bat[:oid,:int],v:int) :bat[:oid,:int]
address CMDbatLSHcstsignal
comment "Return B << V, raise error on out of range second operand";
pattern <<(b:bat[:oid,:int],v:int,accum:int) :bat[:oid,:int]
address CMDbatLSHcstsignal
comment "Return B << V, raise error on out of range second operand, reuse B if ACCUM is set";
pattern lsh_noerror(b:bat[:oid,:int],v:int) :bat[:oid,:int]
address CMDbatLSHcst
comment "Return B << V, out of range second operand causes NIL value";
pattern <<(v:int,b:bat[:oid,:int]) :bat[:oid,:int]
address CMDbatLSHcstsignal
comment "Return V << B, raise error on out of range second operand";
pattern lsh_noerror(v:int,b:bat[:oid,:int]) :bat[:oid,:int]
address CMDbatLSHcst
comment "Return V << B, out of range second operand causes NIL value";

command <<(b1:bat[:oid,:int],b2:bat[:oid,:wrd]) :bat[:oid,:int]
address CMDbatLSHsignal
comment "Return B1 << B2, raise error on out of range second operand";
command <<(b1:bat[:oid,:int],b2:bat[:oid,:wrd],accum:int) :bat[:oid,:int]
address CMDbatLSHsignalaccum
comment "Return B1 << B2, raise error on out of range second operand, reuse B if ACCUM is set";
command lsh_noerror(b1:bat[:oid,:int],b2:bat[:oid,:wrd]) :bat[:oid,:int]
address CMDbatLSH
comment "Return B1 << B2, out of range second operand causes NIL value";
pattern <<(b:bat[:oid,:int],v:wrd) :bat[:oid,:int]
address CMDbatLSHcstsignal
comment "Return B << V, raise error on out of range second operand";
pattern <<(b:bat[:oid,:int],v:wrd,accum:int) :bat[:oid,:int]
address CMDbatLSHcstsignal
comment "Return B << V, raise error on out of range second operand, reuse B if ACCUM is set";
pattern lsh_noerror(b:bat[:oid,:int],v:wrd) :bat[:oid,:int]
address CMDbatLSHcst
comment "Return B << V, out of range second operand causes NIL value";
pattern <<(v:int,b:bat[:oid,:wrd]) :bat[:oid,:int]
address CMDbatLSHcstsignal
comment "Return V << B, raise error on out of range second operand";
pattern lsh_noerror(v:int,b:bat[:oid,:wrd]) :bat[:oid,:int]
address CMDbatLSHcst
comment "Return V << B, out of range second operand causes NIL value";

command <<(b1:bat[:oid,:int],b2:bat[:oid,:lng]) :bat[:oid,:int]
address CMDbatLSHsignal
comment "Return B1 << B2, raise error on out of range second operand";
command <<(b1:bat[:oid,:int],b2:bat[:oid,:lng],accum:int) :bat[:oid,:int]
address CMDbatLSHsignalaccum
comment "Return B1 << B2, raise error on out of range second operand, reuse B if ACCUM is set";
command lsh_noerror(b1:bat[:oid,:int],b2:bat[:oid,:lng]) :bat[:oid,:int]
address CMDbatLSH
comment "Return B1 << B2, out of range second operand causes NIL value";
pattern <<(b:bat[:oid,:int],v:lng) :bat[:oid,:int]
address CMDbatLSHcstsignal
comment "Return B << V, raise error on out of range second operand";
pattern <<(b:bat[:oid,:int],v:lng,accum:int) :bat[:oid,:int]
address CMDbatLSHcstsignal
comment "Return B << V, raise error on out of range second operand, reuse B if ACCUM is set";
pattern lsh_noerror(b:bat[:oid,:int],v:lng) :bat[:oid,:int]
address CMDbatLSHcst
comment "Return B << V, out of range second operand causes NIL value";
pattern <<(v:int,b:bat[:oid,:lng]) :bat[:oid,:int]
address CMDbatLSHcstsignal
comment "Return V << B, raise error on out of range second operand";
pattern lsh_noerror(v:int,b:bat[:oid,:lng]) :bat[:oid,:int]
address CMDbatLSHcst
comment "Return V << B, out of range second operand causes NIL value";

command <<(b1:bat[:oid,:wrd],b2:bat[:oid,:bte]) :bat[:oid,:wrd]
address CMDbatLSHsignal
comment "Return B1 << B2, raise error on out of range second operand";
command <<(b1:bat[:oid,:wrd],b2:bat[:oid,:bte],accum:int) :bat[:oid,:wrd]
address CMDbatLSHsignalaccum
comment "Return B1 << B2, raise error on out of range second operand, reuse B if ACCUM is set";
command lsh_noerror(b1:bat[:oid,:wrd],b2:bat[:oid,:bte]) :bat[:oid,:wrd]
address CMDbatLSH
comment "Return B1 << B2, out of range second operand causes NIL value";
pattern <<(b:bat[:oid,:wrd],v:bte) :bat[:oid,:wrd]
address CMDbatLSHcstsignal
comment "Return B << V, raise error on out of range second operand";
pattern <<(b:bat[:oid,:wrd],v:bte,accum:int) :bat[:oid,:wrd]
address CMDbatLSHcstsignal
comment "Return B << V, raise error on out of range second operand, reuse B if ACCUM is set";
pattern lsh_noerror(b:bat[:oid,:wrd],v:bte) :bat[:oid,:wrd]
address CMDbatLSHcst
comment "Return B << V, out of range second operand causes NIL value";
pattern <<(v:wrd,b:bat[:oid,:bte]) :bat[:oid,:wrd]
address CMDbatLSHcstsignal
comment "Return V << B, raise error on out of range second operand";
pattern lsh_noerror(v:wrd,b:bat[:oid,:bte]) :bat[:oid,:wrd]
address CMDbatLSHcst
comment "Return V << B, out of range second operand causes NIL value";

command <<(b1:bat[:oid,:wrd],b2:bat[:oid,:sht]) :bat[:oid,:wrd]
address CMDbatLSHsignal
comment "Return B1 << B2, raise error on out of range second operand";
command <<(b1:bat[:oid,:wrd],b2:bat[:oid,:sht],accum:int) :bat[:oid,:wrd]
address CMDbatLSHsignalaccum
comment "Return B1 << B2, raise error on out of range second operand, reuse B if ACCUM is set";
command lsh_noerror(b1:bat[:oid,:wrd],b2:bat[:oid,:sht]) :bat[:oid,:wrd]
address CMDbatLSH
comment "Return B1 << B2, out of range second operand causes NIL value";
pattern <<(b:bat[:oid,:wrd],v:sht) :bat[:oid,:wrd]
address CMDbatLSHcstsignal
comment "Return B << V, raise error on out of range second operand";
pattern <<(b:bat[:oid,:wrd],v:sht,accum:int) :bat[:oid,:wrd]
address CMDbatLSHcstsignal
comment "Return B << V, raise error on out of range second operand, reuse B if ACCUM is set";
pattern lsh_noerror(b:bat[:oid,:wrd],v:sht) :bat[:oid,:wrd]
address CMDbatLSHcst
comment "Return B << V, out of range second operand causes NIL value";
pattern <<(v:wrd,b:bat[:oid,:sht]) :bat[:oid,:wrd]
address CMDbatLSHcstsignal
comment "Return V << B, raise error on out of range second operand";
pattern lsh_noerror(v:wrd,b:bat[:oid,:sht]) :bat[:oid,:wrd]
address CMDbatLSHcst
comment "Return V << B, out of range second operand causes NIL value";

command <<(b1:bat[:oid,:wrd],b2:bat[:oid,:int]) :bat[:oid,:wrd]
address CMDbatLSHsignal
comment "Return B1 << B2, raise error on out of range second operand";
command <<(b1:bat[:oid,:wrd],b2:bat[:oid,:int],accum:int) :bat[:oid,:wrd]
address CMDbatLSHsignalaccum
comment "Return B1 << B2, raise error on out of range second operand, reuse B if ACCUM is set";
command lsh_noerror(b1:bat[:oid,:wrd],b2:bat[:oid,:int]) :bat[:oid,:wrd]
address CMDbatLSH
comment "Return B1 << B2, out of range second operand causes NIL value";
pattern <<(b:bat[:oid,:wrd],v:int) :bat[:oid,:wrd]
address CMDbatLSHcstsignal
comment "Return B << V, raise error on out of range second operand";
pattern <<(b:bat[:oid,:wrd],v:int,accum:int) :bat[:oid,:wrd]
address CMDbatLSHcstsignal
comment "Return B << V, raise error on out of range second operand, reuse B if ACCUM is set";
pattern lsh_noerror(b:bat[:oid,:wrd],v:int) :bat[:oid,:wrd]
address CMDbatLSHcst
comment "Return B << V, out of range second operand causes NIL value";
pattern <<(v:wrd,b:bat[:oid,:int]) :bat[:oid,:wrd]
address CMDbatLSHcstsignal
comment "Return V << B, raise error on out of range second operand";
pattern lsh_noerror(v:wrd,b:bat[:oid,:int]) :bat[:oid,:wrd]
address CMDbatLSHcst
comment "Return V << B, out of range second operand causes NIL value";

command <<(b1:bat[:oid,:wrd],b2:bat[:oid,:wrd]) :bat[:oid,:wrd]
address CMDbatLSHsignal
comment "Return B1 << B2, raise error on out of range second operand";
command <<(b1:bat[:oid,:wrd],b2:bat[:oid,:wrd],accum:int) :bat[:oid,:wrd]
address CMDbatLSHsignalaccum
comment "Return B1 << B2, raise error on out of range second operand, reuse B if ACCUM is set";
command lsh_noerror(b1:bat[:oid,:wrd],b2:bat[:oid,:wrd]) :bat[:oid,:wrd]
address CMDbatLSH
comment "Return B1 << B2, out of range second operand causes NIL value";
pattern <<(b:bat[:oid,:wrd],v:wrd) :bat[:oid,:wrd]
address CMDbatLSHcstsignal
comment "Return B << V, raise error on out of range second operand";
pattern <<(b:bat[:oid,:wrd],v:wrd,accum:int) :bat[:oid,:wrd]
address CMDbatLSHcstsignal
comment "Return B << V, raise error on out of range second operand, reuse B if ACCUM is set";
pattern lsh_noerror(b:bat[:oid,:wrd],v:wrd) :bat[:oid,:wrd]
address CMDbatLSHcst
comment "Return B << V, out of range second operand causes NIL value";
pattern <<(v:wrd,b:bat[:oid,:wrd]) :bat[:oid,:wrd]
address CMDbatLSHcstsignal
comment "Return V << B, raise error on out of range second operand";
pattern lsh_noerror(v:wrd,b:bat[:oid,:wrd]) :bat[:oid,:wrd]
address CMDbatLSHcst
comment "Return V << B, out of range second operand causes NIL value";

command <<(b1:bat[:oid,:wrd],b2:bat[:oid,:lng]) :bat[:oid,:wrd]
address CMDbatLSHsignal
comment "Return B1 << B2, raise error on out of range second operand";
command <<(b1:bat[:oid,:wrd],b2:bat[:oid,:lng],accum:int) :bat[:oid,:wrd]
address CMDbatLSHsignalaccum
comment "Return B1 << B2, raise error on out of range second operand, reuse B if ACCUM is set";
command lsh_noerror(b1:bat[:oid,:wrd],b2:bat[:oid,:lng]) :bat[:oid,:wrd]
address CMDbatLSH
comment "Return B1 << B2, out of range second operand causes NIL value";
pattern <<(b:bat[:oid,:wrd],v:lng) :bat[:oid,:wrd]
address CMDbatLSHcstsignal
comment "Return B << V, raise error on out of range second operand";
pattern <<(b:bat[:oid,:wrd],v:lng,accum:int) :bat[:oid,:wrd]
address CMDbatLSHcstsignal
comment "Return B << V, raise error on out of range second operand, reuse B if ACCUM is set";
pattern lsh_noerror(b:bat[:oid,:wrd],v:lng) :bat[:oid,:wrd]
address CMDbatLSHcst
comment "Return B << V, out of range second operand causes NIL value";
pattern <<(v:wrd,b:bat[:oid,:lng]) :bat[:oid,:wrd]
address CMDbatLSHcstsignal
comment "Return V << B, raise error on out of range second operand";
pattern lsh_noerror(v:wrd,b:bat[:oid,:lng]) :bat[:oid,:wrd]
address CMDbatLSHcst
comment "Return V << B, out of range second operand causes NIL value";

command <<(b1:bat[:oid,:lng],b2:bat[:oid,:bte]) :bat[:oid,:lng]
address CMDbatLSHsignal
comment "Return B1 << B2, raise error on out of range second operand";
command <<(b1:bat[:oid,:lng],b2:bat[:oid,:bte],accum:int) :bat[:oid,:lng]
address CMDbatLSHsignalaccum
comment "Return B1 << B2, raise error on out of range second operand, reuse B if ACCUM is set";
command lsh_noerror(b1:bat[:oid,:lng],b2:bat[:oid,:bte]) :bat[:oid,:lng]
address CMDbatLSH
comment "Return B1 << B2, out of range second operand causes NIL value";
pattern <<(b:bat[:oid,:lng],v:bte) :bat[:oid,:lng]
address CMDbatLSHcstsignal
comment "Return B << V, raise error on out of range second operand";
pattern <<(b:bat[:oid,:lng],v:bte,accum:int) :bat[:oid,:lng]
address CMDbatLSHcstsignal
comment "Return B << V, raise error on out of range second operand, reuse B if ACCUM is set";
pattern lsh_noerror(b:bat[:oid,:lng],v:bte) :bat[:oid,:lng]
address CMDbatLSHcst
comment "Return B << V, out of range second operand causes NIL value";
pattern <<(v:lng,b:bat[:oid,:bte]) :bat[:oid,:lng]
address CMDbatLSHcstsignal
comment "Return V << B, raise error on out of range second operand";
pattern lsh_noerror(v:lng,b:bat[:oid,:bte]) :bat[:oid,:lng]
address CMDbatLSHcst
comment "Return V << B, out of range second operand causes NIL value";

command <<(b1:bat[:oid,:lng],b2:bat[:oid,:sht]) :bat[:oid,:lng]
address CMDbatLSHsignal
comment "Return B1 << B2, raise error on out of range second operand";
command <<(b1:bat[:oid,:lng],b2:bat[:oid,:sht],accum:int) :bat[:oid,:lng]
address CMDbatLSHsignalaccum
comment "Return B1 << B2, raise error on out of range second operand, reuse B if ACCUM is set";
command lsh_noerror(b1:bat[:oid,:lng],b2:bat[:oid,:sht]) :bat[:oid,:lng]
address CMDbatLSH
comment "Return B1 << B2, out of range second operand causes NIL value";
pattern <<(b:bat[:oid,:lng],v:sht) :bat[:oid,:lng]
address CMDbatLSHcstsignal
comment "Return B << V, raise error on out of range second operand";
pattern <<(b:bat[:oid,:lng],v:sht,accum:int) :bat[:oid,:lng]
address CMDbatLSHcstsignal
comment "Return B << V, raise error on out of range second operand, reuse B if ACCUM is set";
pattern lsh_noerror(b:bat[:oid,:lng],v:sht) :bat[:oid,:lng]
address CMDbatLSHcst
comment "Return B << V, out of range second operand causes NIL value";
pattern <<(v:lng,b:bat[:oid,:sht]) :bat[:oid,:lng]
address CMDbatLSHcstsignal
comment "Return V << B, raise error on out of range second operand";
pattern lsh_noerror(v:lng,b:bat[:oid,:sht]) :bat[:oid,:lng]
address CMDbatLSHcst
comment "Return V << B, out of range second operand causes NIL value";

command <<(b1:bat[:oid,:lng],b2:bat[:oid,:int]) :bat[:oid,:lng]
address CMDbatLSHsignal
comment "Return B1 << B2, raise error on out of range second operand";
command <<(b1:bat[:oid,:lng],b2:bat[:oid,:int],accum:int) :bat[:oid,:lng]
address CMDbatLSHsignalaccum
comment "Return B1 << B2, raise error on out of range second operand, reuse B if ACCUM is set";
command lsh_noerror(b1:bat[:oid,:lng],b2:bat[:oid,:int]) :bat[:oid,:lng]
address CMDbatLSH
comment "Return B1 << B2, out of range second operand causes NIL value";
pattern <<(b:bat[:oid,:lng],v:int) :bat[:oid,:lng]
address CMDbatLSHcstsignal
comment "Return B << V, raise error on out of range second operand";
pattern <<(b:bat[:oid,:lng],v:int,accum:int) :bat[:oid,:lng]
address CMDbatLSHcstsignal
comment "Return B << V, raise error on out of range second operand, reuse B if ACCUM is set";
pattern lsh_noerror(b:bat[:oid,:lng],v:int) :bat[:oid,:lng]
address CMDbatLSHcst
comment "Return B << V, out of range second operand causes NIL value";
pattern <<(v:lng,b:bat[:oid,:int]) :bat[:oid,:lng]
address CMDbatLSHcstsignal
comment "Return V << B, raise error on out of range second operand";
pattern lsh_noerror(v:lng,b:bat[:oid,:int]) :bat[:oid,:lng]
address CMDbatLSHcst
comment "Return V << B, out of range second operand causes NIL value";

command <<(b1:bat[:oid,:lng],b2:bat[:oid,:wrd]) :bat[:oid,:lng]
address CMDbatLSHsignal
comment "Return B1 << B2, raise error on out of range second operand";
command <<(b1:bat[:oid,:lng],b2:bat[:oid,:wrd],accum:int) :bat[:oid,:lng]
address CMDbatLSHsignalaccum
comment "Return B1 << B2, raise error on out of range second operand, reuse B if ACCUM is set";
command lsh_noerror(b1:bat[:oid,:lng],b2:bat[:oid,:wrd]) :bat[:oid,:lng]
address CMDbatLSH
comment "Return B1 << B2, out of range second operand causes NIL value";
pattern <<(b:bat[:oid,:lng],v:wrd) :bat[:oid,:lng]
address CMDbatLSHcstsignal
comment "Return B << V, raise error on out of range second operand";
pattern <<(b:bat[:oid,:lng],v:wrd,accum:int) :bat[:oid,:lng]
address CMDbatLSHcstsignal
comment "Return B << V, raise error on out of range second operand, reuse B if ACCUM is set";
pattern lsh_noerror(b:bat[:oid,:lng],v:wrd) :bat[:oid,:lng]
address CMDbatLSHcst
comment "Return B << V, out of range second operand causes NIL value";
pattern <<(v:lng,b:bat[:oid,:wrd]) :bat[:oid,:lng]
address CMDbatLSHcstsignal
comment "Return V << B, raise error on out of range second operand";
pattern lsh_noerror(v:lng,b:bat[:oid,:wrd]) :bat[:oid,:lng]
address CMDbatLSHcst
comment "Return V << B, out of range second operand causes NIL value";

command <<(b1:bat[:oid,:lng],b2:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatLSHsignal
comment "Return B1 << B2, raise error on out of range second operand";
command <<(b1:bat[:oid,:lng],b2:bat[:oid,:lng],accum:int) :bat[:oid,:lng]
address CMDbatLSHsignalaccum
comment "Return B1 << B2, raise error on out of range second operand, reuse B if ACCUM is set";
command lsh_noerror(b1:bat[:oid,:lng],b2:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatLSH
comment "Return B1 << B2, out of range second operand causes NIL value";
pattern <<(b:bat[:oid,:lng],v:lng) :bat[:oid,:lng]
address CMDbatLSHcstsignal
comment "Return B << V, raise error on out of range second operand";
pattern <<(b:bat[:oid,:lng],v:lng,accum:int) :bat[:oid,:lng]
address CMDbatLSHcstsignal
comment "Return B << V, raise error on out of range second operand, reuse B if ACCUM is set";
pattern lsh_noerror(b:bat[:oid,:lng],v:lng) :bat[:oid,:lng]
address CMDbatLSHcst
comment "Return B << V, out of range second operand causes NIL value";
pattern <<(v:lng,b:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatLSHcstsignal
comment "Return V << B, raise error on out of range second operand";
pattern lsh_noerror(v:lng,b:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatLSHcst
comment "Return V << B, out of range second operand causes NIL value";


command >>(b1:bat[:oid,:bte],b2:bat[:oid,:bte]) :bat[:oid,:bte]
address CMDbatRSHsignal
comment "Return B1 >> B2, raise error on out of range second operand";
command >>(b1:bat[:oid,:bte],b2:bat[:oid,:bte],accum:int) :bat[:oid,:bte]
address CMDbatRSHsignalaccum
comment "Return B1 >> B2, raise error on out of range second operand, reuse B if ACCUM is set";
command rsh_noerror(b1:bat[:oid,:bte],b2:bat[:oid,:bte]) :bat[:oid,:bte]
address CMDbatRSH
comment "Return B1 >> B2, out of range second operand causes NIL value";
pattern >>(b:bat[:oid,:bte],v:bte) :bat[:oid,:bte]
address CMDbatRSHcstsignal
comment "Return B >> V, raise error on out of range second operand";
pattern >>(b:bat[:oid,:bte],v:bte,accum:int) :bat[:oid,:bte]
address CMDbatRSHcstsignal
comment "Return B >> V, raise error on out of range second operand, reuse B if ACCUM is set";
pattern rsh_noerror(b:bat[:oid,:bte],v:bte) :bat[:oid,:bte]
address CMDbatRSHcst
comment "Return B >> V, out of range second operand causes NIL value";
pattern >>(v:bte,b:bat[:oid,:bte]) :bat[:oid,:bte]
address CMDbatRSHcstsignal
comment "Return V >> B, raise error on out of range second operand";
pattern rsh_noerror(v:bte,b:bat[:oid,:bte]) :bat[:oid,:bte]
address CMDbatRSHcst
comment "Return V >> B, out of range second operand causes NIL value";

command >>(b1:bat[:oid,:bte],b2:bat[:oid,:sht]) :bat[:oid,:bte]
address CMDbatRSHsignal
comment "Return B1 >> B2, raise error on out of range second operand";
command >>(b1:bat[:oid,:bte],b2:bat[:oid,:sht],accum:int) :bat[:oid,:bte]
address CMDbatRSHsignalaccum
comment "Return B1 >> B2, raise error on out of range second operand, reuse B if ACCUM is set";
command rsh_noerror(b1:bat[:oid,:bte],b2:bat[:oid,:sht]) :bat[:oid,:bte]
address CMDbatRSH
comment "Return B1 >> B2, out of range second operand causes NIL value";
pattern >>(b:bat[:oid,:bte],v:sht) :bat[:oid,:bte]
address CMDbatRSHcstsignal
comment "Return B >> V, raise error on out of range second operand";
pattern >>(b:bat[:oid,:bte],v:sht,accum:int) :bat[:oid,:bte]
address CMDbatRSHcstsignal
comment "Return B >> V, raise error on out of range second operand, reuse B if ACCUM is set";
pattern rsh_noerror(b:bat[:oid,:bte],v:sht) :bat[:oid,:bte]
address CMDbatRSHcst
comment "Return B >> V, out of range second operand causes NIL value";
pattern >>(v:bte,b:bat[:oid,:sht]) :bat[:oid,:bte]
address CMDbatRSHcstsignal
comment "Return V >> B, raise error on out of range second operand";
pattern rsh_noerror(v:bte,b:bat[:oid,:sht]) :bat[:oid,:bte]
address CMDbatRSHcst
comment "Return V >> B, out of range second operand causes NIL value";

command >>(b1:bat[:oid,:bte],b2:bat[:oid,:int]) :bat[:oid,:bte]
address CMDbatRSHsignal
comment "Return B1 >> B2, raise error on out of range second operand";
command >>(b1:bat[:oid,:bte],b2:bat[:oid,:int],accum:int) :bat[:oid,:bte]
address CMDbatRSHsignalaccum
comment "Return B1 >> B2, raise error on out of range second operand, reuse B if ACCUM is set";
command rsh_noerror(b1:bat[:oid,:bte],b2:bat[:oid,:int]) :bat[:oid,:bte]
address CMDbatRSH
comment "Return B1 >> B2, out of range second operand causes NIL value";
pattern >>(b:bat[:oid,:bte],v:int) :bat[:oid,:bte]
address CMDbatRSHcstsignal
comment "Return B >> V, raise error on out of range second operand";
pattern >>(b:bat[:oid,:bte],v:int,accum:int) :bat[:oid,:bte]
address CMDbatRSHcstsignal
comment "Return B >> V, raise error on out of range second operand, reuse B if ACCUM is set";
pattern rsh_noerror(b:bat[:oid,:bte],v:int) :bat[:oid,:bte]
address CMDbatRSHcst
comment "Return B >> V, out of range second operand causes NIL value";
pattern >>(v:bte,b:bat[:oid,:int]) :bat[:oid,:bte]
address CMDbatRSHcstsignal
comment "Return V >> B, raise error on out of range second operand";
pattern rsh_noerror(v:bte,b:bat[:oid,:int]) :bat[:oid,:bte]
address CMDbatRSHcst
comment "Return V >> B, out of range second operand causes NIL value";

command >>(b1:bat[:oid,:bte],b2:bat[:oid,:wrd]) :bat[:oid,:bte]
address CMDbatRSHsignal
comment "Return B1 >> B2, raise error on out of range second operand";
command >>(b1:bat[:oid,:bte],b2:bat[:oid,:wrd],accum:int) :bat[:oid,:bte]
address CMDbatRSHsignalaccum
comment "Return B1 >> B2, raise error on out of range second operand, reuse B if ACCUM is set";
command rsh_noerror(b1:bat[:oid,:bte],b2:bat[:oid,:wrd]) :bat[:oid,:bte]
address CMDbatRSH
comment "Return B1 >> B2, out of range second operand causes NIL value";
pattern >>(b:bat[:oid,:bte],v:wrd) :bat[:oid,:bte]
address CMDbatRSHcstsignal
comment "Return B >> V, raise error on out of range second operand";
pattern >>(b:bat[:oid,:bte],v:wrd,accum:int) :bat[:oid,:bte]
address CMDbatRSHcstsignal
comment "Return B >> V, raise error on out of range second operand, reuse B if ACCUM is set";
pattern rsh_noerror(b:bat[:oid,:bte],v:wrd) :bat[:oid,:bte]
address CMDbatRSHcst
comment "Return B >> V, out of range second operand causes NIL value";
pattern >>(v:bte,b:bat[:oid,:wrd]) :bat[:oid,:bte]
address CMDbatRSHcstsignal
comment "Return V >> B, raise error on out of range second operand";
pattern rsh_noerror(v:bte,b:bat[:oid,:wrd]) :bat[:oid,:bte]
address CMDbatRSHcst
comment "Return V >> B, out of range second operand causes NIL value";

command >>(b1:bat[:oid,:bte],b2:bat[:oid,:lng]) :bat[:oid,:bte]
address CMDbatRSHsignal
comment "Return B1 >> B2, raise error on out of range second operand";
command >>(b1:bat[:oid,:bte],b2:bat[:oid,:lng],accum:int) :bat[:oid,:bte]
address CMDbatRSHsignalaccum
comment "Return B1 >> B2, raise error on out of range second operand, reuse B if ACCUM is set";
command rsh_noerror(b1:bat[:oid,:bte],b2:bat[:oid,:lng]) :bat[:oid,:bte]
address CMDbatRSH
comment "Return B1 >> B2, out of range second operand causes NIL value";
pattern >>(b:bat[:oid,:bte],v:lng) :bat[:oid,:bte]
address CMDbatRSHcstsignal
comment "Return B >> V, raise error on out of range second operand";
pattern >>(b:bat[:oid,:bte],v:lng,accum:int) :bat[:oid,:bte]
address CMDbatRSHcstsignal
comment "Return B >> V, raise error on out of range second operand, reuse B if ACCUM is set";
pattern rsh_noerror(b:bat[:oid,:bte],v:lng) :bat[:oid,:bte]
address CMDbatRSHcst
comment "Return B >> V, out of range second operand causes NIL value";
pattern >>(v:bte,b:bat[:oid,:lng]) :bat[:oid,:bte]
address CMDbatRSHcstsignal
comment "Return V >> B, raise error on out of range second operand";
pattern rsh_noerror(v:bte,b:bat[:oid,:lng]) :bat[:oid,:bte]
address CMDbatRSHcst
comment "Return V >> B, out of range second operand causes NIL value";

command >>(b1:bat[:oid,:sht],b2:bat[:oid,:bte]) :bat[:oid,:sht]
address CMDbatRSHsignal
comment "Return B1 >> B2, raise error on out of range second operand";
command >>(b1:bat[:oid,:sht],b2:bat[:oid,:bte],accum:int) :bat[:oid,:sht]
address CMDbatRSHsignalaccum
comment "Return B1 >> B2, raise error on out of range second operand, reuse B if ACCUM is set";
command rsh_noerror(b1:bat[:oid,:sht],b2:bat[:oid,:bte]) :bat[:oid,:sht]
address CMDbatRSH
comment "Return B1 >> B2, out of range second operand causes NIL value";
pattern >>(b:bat[:oid,:sht],v:bte) :bat[:oid,:sht]
address CMDbatRSHcstsignal
comment "Return B >> V, raise error on out of range second operand";
pattern >>(b:bat[:oid,:sht],v:bte,accum:int) :bat[:oid,:sht]
address CMDbatRSHcstsignal
comment "Return B >> V, raise error on out of range second operand, reuse B if ACCUM is set";
pattern rsh_noerror(b:bat[:oid,:sht],v:bte) :bat[:oid,:sht]
address CMDbatRSHcst
comment "Return B >> V, out of range second operand causes NIL value";
pattern >>(v:sht,b:bat[:oid,:bte]) :bat[:oid,:sht]
address CMDbatRSHcstsignal
comment "Return V >> B, raise error on out of range second operand";
pattern rsh_noerror(v:sht,b:bat[:oid,:bte]) :bat[:oid,:sht]
address CMDbatRSHcst
comment "Return V >> B, out of range second operand causes NIL value";

command >>(b1:bat[:oid,:sht],b2:bat[:oid,:sht]) :bat[:oid,:sht]
address CMDbatRSHsignal
comment "Return B1 >> B2, raise error on out of range second operand";
command >>(b1:bat[:oid,:sht],b2:bat[:oid,:sht],accum:int) :bat[:oid,:sht]
address CMDbatRSHsignalaccum
comment "Return B1 >> B2, raise error on out of range second operand, reuse B if ACCUM is set";
command rsh_noerror(b1:bat[:oid,:sht],b2:bat[:oid,:sht]) :bat[:oid,:sht]
address CMDbatRSH
comment "Return B1 >> B2, out of range second operand causes NIL value";
pattern >>(b:bat[:oid,:sht],v:sht) :bat[:oid,:sht]
address CMDbatRSHcstsignal
comment "Return B >> V, raise error on out of range second operand";
pattern >>(b:bat[:oid,:sht],v:sht,accum:int) :bat[:oid,:sht]
address CMDbatRSHcstsignal
comment "Return B >> V, raise error on out of range second operand, reuse B if ACCUM is set";
pattern rsh_noerror(b:bat[:oid,:sht],v:sht) :bat[:oid,:sht]
address CMDbatRSHcst
comment "Return B >> V, out of range second operand causes NIL value";
pattern >>(v:sht,b:bat[:oid,:sht]) :bat[:oid,:sht]
address CMDbatRSHcstsignal
comment "Return V >> B, raise error on out of range second operand";
pattern rsh_noerror(v:sht,b:bat[:oid,:sht]) :bat[:oid,:sht]
address CMDbatRSHcst
comment "Return V >> B, out of range second operand causes NIL value";

command >>(b1:bat[:oid,:sht],b2:bat[:oid,:int]) :bat[:oid,:sht]
address CMDbatRSHsignal
comment "Return B1 >> B2, raise error on out of range second operand";
command >>(b1:bat[:oid,:sht],b2:bat[:oid,:int],accum:int) :bat[:oid,:sht]
address CMDbatRSHsignalaccum
comment "Return B1 >> B2, raise error on out of range second operand, reuse B if ACCUM is set";
command rsh_noerror(b1:bat[:oid,:sht],b2:bat[:oid,:int]) :bat[:oid,:sht]
address CMDbatRSH
comment "Return B1 >> B2, out of range second operand causes NIL value";
pattern >>(b:bat[:oid,:sht],v:int) :bat[:oid,:sht]
address CMDbatRSHcstsignal
comment "Return B >> V, raise error on out of range second operand";
pattern >>(b:bat[:oid,:sht],v:int,accum:int) :bat[:oid,:sht]
address CMDbatRSHcstsignal
comment "Return B >> V, raise error on out of range second operand, reuse B if ACCUM is set";
pattern rsh_noerror(b:bat[:oid,:sht],v:int) :bat[:oid,:sht]
address CMDbatRSHcst
comment "Return B >> V, out of range second operand causes NIL value";
pattern >>(v:sht,b:bat[:oid,:int]) :bat[:oid,:sht]
address CMDbatRSHcstsignal
comment "Return V >> B, raise error on out of range second operand";
pattern rsh_noerror(v:sht,b:bat[:oid,:int]) :bat[:oid,:sht]
address CMDbatRSHcst
comment "Return V >> B, out of range second operand causes NIL value";

command >>(b1:bat[:oid,:sht],b2:bat[:oid,:wrd]) :bat[:oid,:sht]
address CMDbatRSHsignal
comment "Return B1 >> B2, raise error on out of range second operand";
command >>(b1:bat[:oid,:sht],b2:bat[:oid,:wrd],accum:int) :bat[:oid,:sht]
address CMDbatRSHsignalaccum
comment "Return B1 >> B2, raise error on out of range second operand, reuse B if ACCUM is set";
command rsh_noerror(b1:bat[:oid,:sht],b2:bat[:oid,:wrd]) :bat[:oid,:sht]
address CMDbatRSH
comment "Return B1 >> B2, out of range second operand causes NIL value";
pattern >>(b:bat[:oid,:sht],v:wrd) :bat[:oid,:sht]
address CMDbatRSHcstsignal
comment "Return B >> V, raise error on out of range second operand";
pattern >>(b:bat[:oid,:sht],v:wrd,accum:int) :bat[:oid,:sht]
address CMDbatRSHcstsignal
comment "Return B >> V, raise error on out of range second operand, reuse B if ACCUM is set";
pattern rsh_noerror(b:bat[:oid,:sht],v:wrd) :bat[:oid,:sht]
address CMDbatRSHcst
comment "Return B >> V, out of range second operand causes NIL value";
pattern >>(v:sht,b:bat[:oid,:wrd]) :bat[:oid,:sht]
address CMDbatRSHcstsignal
comment "Return V >> B, raise error on out of range second operand";
pattern rsh_noerror(v:sht,b:bat[:oid,:wrd]) :bat[:oid,:sht]
address CMDbatRSHcst
comment "Return V >> B, out of range second operand causes NIL value";

command >>(b1:bat[:oid,:sht],b2:bat[:oid,:lng]) :bat[:oid,:sht]
address CMDbatRSHsignal
comment "Return B1 >> B2, raise error on out of range second operand";
command >>(b1:bat[:oid,:sht],b2:bat[:oid,:lng],accum:int) :bat[:oid,:sht]
address CMDbatRSHsignalaccum
comment "Return B1 >> B2, raise error on out of range second operand, reuse B if ACCUM is set";
command rsh_noerror(b1:bat[:oid,:sht],b2:bat[:oid,:lng]) :bat[:oid,:sht]
address CMDbatRSH
comment "Return B1 >> B2, out of range second operand causes NIL value";
pattern >>(b:bat[:oid,:sht],v:lng) :bat[:oid,:sht]
address CMDbatRSHcstsignal
comment "Return B >> V, raise error on out of range second operand";
pattern >>(b:bat[:oid,:sht],v:lng,accum:int) :bat[:oid,:sht]
address CMDbatRSHcstsignal
comment "Return B >> V, raise error on out of range second operand, reuse B if ACCUM is set";
pattern rsh_noerror(b:bat[:oid,:sht],v:lng) :bat[:oid,:sht]
address CMDbatRSHcst
comment "Return B >> V, out of range second operand causes NIL value";
pattern >>(v:sht,b:bat[:oid,:lng]) :bat[:oid,:sht]
address CMDbatRSHcstsignal
comment "Return V >> B, raise error on out of range second operand";
pattern rsh_noerror(v:sht,b:bat[:oid,:lng]) :bat[:oid,:sht]
address CMDbatRSHcst
comment "Return V >> B, out of range second operand causes NIL value";

command >>(b1:bat[:oid,:int],b2:bat[:oid,:bte]) :bat[:oid,:int]
address CMDbatRSHsignal
comment "Return B1 >> B2, raise error on out of range second operand";
command >>(b1:bat[:oid,:int],b2:bat[:oid,:bte],accum:int) :bat[:oid,:int]
address CMDbatRSHsignalaccum
comment "Return B1 >> B2, raise error on out of range second operand, reuse B if ACCUM is set";
command rsh_noerror(b1:bat[:oid,:int],b2:bat[:oid,:bte]) :bat[:oid,:int]
address CMDbatRSH
comment "Return B1 >> B2, out of range second operand causes NIL value";
pattern >>(b:bat[:oid,:int],v:bte) :bat[:oid,:int]
address CMDbatRSHcstsignal
comment "Return B >> V, raise error on out of range second operand";
pattern >>(b:bat[:oid,:int],v:bte,accum:int) :bat[:oid,:int]
address CMDbatRSHcstsignal
comment "Return B >> V, raise error on out of range second operand, reuse B if ACCUM is set";
pattern rsh_noerror(b:bat[:oid,:int],v:bte) :bat[:oid,:int]
address CMDbatRSHcst
comment "Return B >> V, out of range second operand causes NIL value";
pattern >>(v:int,b:bat[:oid,:bte]) :bat[:oid,:int]
address CMDbatRSHcstsignal
comment "Return V >> B, raise error on out of range second operand";
pattern rsh_noerror(v:int,b:bat[:oid,:bte]) :bat[:oid,:int]
address CMDbatRSHcst
comment "Return V >> B, out of range second operand causes NIL value";

command >>(b1:bat[:oid,:int],b2:bat[:oid,:sht]) :bat[:oid,:int]
address CMDbatRSHsignal
comment "Return B1 >> B2, raise error on out of range second operand";
command >>(b1:bat[:oid,:int],b2:bat[:oid,:sht],accum:int) :bat[:oid,:int]
address CMDbatRSHsignalaccum
comment "Return B1 >> B2, raise error on out of range second operand, reuse B if ACCUM is set";
command rsh_noerror(b1:bat[:oid,:int],b2:bat[:oid,:sht]) :bat[:oid,:int]
address CMDbatRSH
comment "Return B1 >> B2, out of range second operand causes NIL value";
pattern >>(b:bat[:oid,:int],v:sht) :bat[:oid,:int]
address CMDbatRSHcstsignal
comment "Return B >> V, raise error on out of range second operand";
pattern >>(b:bat[:oid,:int],v:sht,accum:int) :bat[:oid,:int]
address CMDbatRSHcstsignal
comment "Return B >> V, raise error on out of range second operand, reuse B if ACCUM is set";
pattern rsh_noerror(b:bat[:oid,:int],v:sht) :bat[:oid,:int]
address CMDbatRSHcst
comment "Return B >> V, out of range second operand causes NIL value";
pattern >>(v:int,b:bat[:oid,:sht]) :bat[:oid,:int]
address CMDbatRSHcstsignal
comment "Return V >> B, raise error on out of range second operand";
pattern rsh_noerror(v:int,b:bat[:oid,:sht]) :bat[:oid,:int]
address CMDbatRSHcst
comment "Return V >> B, out of range second operand causes NIL value";

command >>(b1:bat[:oid,:int],b2:bat[:oid,:int]) :bat[:oid,:int]
address CMDbatRSHsignal
comment "Return B1 >> B2, raise error on out of range second operand";
command >>(b1:bat[:oid,:int],b2:bat[:oid,:int],accum:int) :bat[:oid,:int]
address CMDbatRSHsignalaccum
comment "Return B1 >> B2, raise error on out of range second operand, reuse B if ACCUM is set";
command rsh_noerror(b1:bat[:oid,:int],b2:bat[:oid,:int]) :bat[:oid,:int]
address CMDbatRSH
comment "Return B1 >> B2, out of range second operand causes NIL value";
pattern >>(b:bat[:oid,:int],v:int) :bat[:oid,:int]
address CMDbatRSHcstsignal
comment "Return B >> V, raise error on out of range second operand";
pattern >>(b:bat[:oid,:int],v:int,accum:int) :bat[:oid,:int]
address CMDbatRSHcstsignal
comment "Return B >> V, raise error on out of range second operand, reuse B if ACCUM is set";
pattern rsh_noerror(b:bat[:oid,:int],v:int) :bat[:oid,:int]
address CMDbatRSHcst
comment "Return B >> V, out of range second operand causes NIL value";
pattern >>(v:int,b:bat[:oid,:int]) :bat[:oid,:int]
address CMDbatRSHcstsignal
comment "Return V >> B, raise error on out of range second operand";
pattern rsh_noerror(v:int,b:bat[:oid,:int]) :bat[:oid,:int]
address CMDbatRSHcst
comment "Return V >> B, out of range second operand causes NIL value";

command >>(b1:bat[:oid,:int],b2:bat[:oid,:wrd]) :bat[:oid,:int]
address CMDbatRSHsignal
comment "Return B1 >> B2, raise error on out of range second operand";
command >>(b1:bat[:oid,:int],b2:bat[:oid,:wrd],accum:int) :bat[:oid,:int]
address CMDbatRSHsignalaccum
comment "Return B1 >> B2, raise error on out of range second operand, reuse B if ACCUM is set";
command rsh_noerror(b1:bat[:oid,:int],b2:bat[:oid,:wrd]) :bat[:oid,:int]
address CMDbatRSH
comment "Return B1 >> B2, out of range second operand causes NIL value";
pattern >>(b:bat[:oid,:int],v:wrd) :bat[:oid,:int]
address CMDbatRSHcstsignal
comment "Return B >> V, raise error on out of range second operand";
pattern >>(b:bat[:oid,:int],v:wrd,accum:int) :bat[:oid,:int]
address CMDbatRSHcstsignal
comment "Return B >> V, raise error on out of range second operand, reuse B if ACCUM is set";
pattern rsh_noerror(b:bat[:oid,:int],v:wrd) :bat[:oid,:int]
address CMDbatRSHcst
comment "Return B >> V, out of range second operand causes NIL value";
pattern >>(v:int,b:bat[:oid,:wrd]) :bat[:oid,:int]
address CMDbatRSHcstsignal
comment "Return V >> B, raise error on out of range second operand";
pattern rsh_noerror(v:int,b:bat[:oid,:wrd]) :bat[:oid,:int]
address CMDbatRSHcst
comment "Return V >> B, out of range second operand causes NIL value";

command >>(b1:bat[:oid,:int],b2:bat[:oid,:lng]) :bat[:oid,:int]
address CMDbatRSHsignal
comment "Return B1 >> B2, raise error on out of range second operand";
command >>(b1:bat[:oid,:int],b2:bat[:oid,:lng],accum:int) :bat[:oid,:int]
address CMDbatRSHsignalaccum
comment "Return B1 >> B2, raise error on out of range second operand, reuse B if ACCUM is set";
command rsh_noerror(b1:bat[:oid,:int],b2:bat[:oid,:lng]) :bat[:oid,:int]
address CMDbatRSH
comment "Return B1 >> B2, out of range second operand causes NIL value";
pattern >>(b:bat[:oid,:int],v:lng) :bat[:oid,:int]
address CMDbatRSHcstsignal
comment "Return B >> V, raise error on out of range second operand";
pattern >>(b:bat[:oid,:int],v:lng,accum:int) :bat[:oid,:int]
address CMDbatRSHcstsignal
comment "Return B >> V, raise error on out of range second operand, reuse B if ACCUM is set";
pattern rsh_noerror(b:bat[:oid,:int],v:lng) :bat[:oid,:int]
address CMDbatRSHcst
comment "Return B >> V, out of range second operand causes NIL value";
pattern >>(v:int,b:bat[:oid,:lng]) :bat[:oid,:int]
address CMDbatRSHcstsignal
comment "Return V >> B, raise error on out of range second operand";
pattern rsh_noerror(v:int,b:bat[:oid,:lng]) :bat[:oid,:int]
address CMDbatRSHcst
comment "Return V >> B, out of range second operand causes NIL value";

command >>(b1:bat[:oid,:wrd],b2:bat[:oid,:bte]) :bat[:oid,:wrd]
address CMDbatRSHsignal
comment "Return B1 >> B2, raise error on out of range second operand";
command >>(b1:bat[:oid,:wrd],b2:bat[:oid,:bte],accum:int) :bat[:oid,:wrd]
address CMDbatRSHsignalaccum
comment "Return B1 >> B2, raise error on out of range second operand, reuse B if ACCUM is set";
command rsh_noerror(b1:bat[:oid,:wrd],b2:bat[:oid,:bte]) :bat[:oid,:wrd]
address CMDbatRSH
comment "Return B1 >> B2, out of range second operand causes NIL value";
pattern >>(b:bat[:oid,:wrd],v:bte) :bat[:oid,:wrd]
address CMDbatRSHcstsignal
comment "Return B >> V, raise error on out of range second operand";
pattern >>(b:bat[:oid,:wrd],v:bte,accum:int) :bat[:oid,:wrd]
address CMDbatRSHcstsignal
comment "Return B >> V, raise error on out of range second operand, reuse B if ACCUM is set";
pattern rsh_noerror(b:bat[:oid,:wrd],v:bte) :bat[:oid,:wrd]
address CMDbatRSHcst
comment "Return B >> V, out of range second operand causes NIL value";
pattern >>(v:wrd,b:bat[:oid,:bte]) :bat[:oid,:wrd]
address CMDbatRSHcstsignal
comment "Return V >> B, raise error on out of range second operand";
pattern rsh_noerror(v:wrd,b:bat[:oid,:bte]) :bat[:oid,:wrd]
address CMDbatRSHcst
comment "Return V >> B, out of range second operand causes NIL value";

command >>(b1:bat[:oid,:wrd],b2:bat[:oid,:sht]) :bat[:oid,:wrd]
address CMDbatRSHsignal
comment "Return B1 >> B2, raise error on out of range second operand";
command >>(b1:bat[:oid,:wrd],b2:bat[:oid,:sht],accum:int) :bat[:oid,:wrd]
address CMDbatRSHsignalaccum
comment "Return B1 >> B2, raise error on out of range second operand, reuse B if ACCUM is set";
command rsh_noerror(b1:bat[:oid,:wrd],b2:bat[:oid,:sht]) :bat[:oid,:wrd]
address CMDbatRSH
comment "Return B1 >> B2, out of range second operand causes NIL value";
pattern >>(b:bat[:oid,:wrd],v:sht) :bat[:oid,:wrd]
address CMDbatRSHcstsignal
comment "Return B >> V, raise error on out of range second operand";
pattern >>(b:bat[:oid,:wrd],v:sht,accum:int) :bat[:oid,:wrd]
address CMDbatRSHcstsignal
comment "Return B >> V, raise error on out of range second operand, reuse B if ACCUM is set";
pattern rsh_noerror(b:bat[:oid,:wrd],v:sht) :bat[:oid,:wrd]
address CMDbatRSHcst
comment "Return B >> V, out of range second operand causes NIL value";
pattern >>(v:wrd,b:bat[:oid,:sht]) :bat[:oid,:wrd]
address CMDbatRSHcstsignal
comment "Return V >> B, raise error on out of range second operand";
pattern rsh_noerror(v:wrd,b:bat[:oid,:sht]) :bat[:oid,:wrd]
address CMDbatRSHcst
comment "Return V >> B, out of range second operand causes NIL value";

command >>(b1:bat[:oid,:wrd],b2:bat[:oid,:int]) :bat[:oid,:wrd]
address CMDbatRSHsignal
comment "Return B1 >> B2, raise error on out of range second operand";
command >>(b1:bat[:oid,:wrd],b2:bat[:oid,:int],accum:int) :bat[:oid,:wrd]
address CMDbatRSHsignalaccum
comment "Return B1 >> B2, raise error on out of range second operand, reuse B if ACCUM is set";
command rsh_noerror(b1:bat[:oid,:wrd],b2:bat[:oid,:int]) :bat[:oid,:wrd]
address CMDbatRSH
comment "Return B1 >> B2, out of range second operand causes NIL value";
pattern >>(b:bat[:oid,:wrd],v:int) :bat[:oid,:wrd]
address CMDbatRSHcstsignal
comment "Return B >> V, raise error on out of range second operand";
pattern >>(b:bat[:oid,:wrd],v:int,accum:int) :bat[:oid,:wrd]
address CMDbatRSHcstsignal
comment "Return B >> V, raise error on out of range second operand, reuse B if ACCUM is set";
pattern rsh_noerror(b:bat[:oid,:wrd],v:int) :bat[:oid,:wrd]
address CMDbatRSHcst
comment "Return B >> V, out of range second operand causes NIL value";
pattern >>(v:wrd,b:bat[:oid,:int]) :bat[:oid,:wrd]
address CMDbatRSHcstsignal
comment "Return V >> B, raise error on out of range second operand";
pattern rsh_noerror(v:wrd,b:bat[:oid,:int]) :bat[:oid,:wrd]
address CMDbatRSHcst
comment "Return V >> B, out of range second operand causes NIL value";

command >>(b1:bat[:oid,:wrd],b2:bat[:oid,:wrd]) :bat[:oid,:wrd]
address CMDbatRSHsignal
comment "Return B1 >> B2, raise error on out of range second operand";
command >>(b1:bat[:oid,:wrd],b2:bat[:oid,:wrd],accum:int) :bat[:oid,:wrd]
address CMDbatRSHsignalaccum
comment "Return B1 >> B2, raise error on out of range second operand, reuse B if ACCUM is set";
command rsh_noerror(b1:bat[:oid,:wrd],b2:bat[:oid,:wrd]) :bat[:oid,:wrd]
address CMDbatRSH
comment "Return B1 >> B2, out of range second operand causes NIL value";
pattern >>(b:bat[:oid,:wrd],v:wrd) :bat[:oid,:wrd]
address CMDbatRSHcstsignal
comment "Return B >> V, raise error on out of range second operand";
pattern >>(b:bat[:oid,:wrd],v:wrd,accum:int) :bat[:oid,:wrd]
address CMDbatRSHcstsignal
comment "Return B >> V, raise error on out of range second operand, reuse B if ACCUM is set";
pattern rsh_noerror(b:bat[:oid,:wrd],v:wrd) :bat[:oid,:wrd]
address CMDbatRSHcst
comment "Return B >> V, out of range second operand causes NIL value";
pattern >>(v:wrd,b:bat[:oid,:wrd]) :bat[:oid,:wrd]
address CMDbatRSHcstsignal
comment "Return V >> B, raise error on out of range second operand";
pattern rsh_noerror(v:wrd,b:bat[:oid,:wrd]) :bat[:oid,:wrd]
address CMDbatRSHcst
comment "Return V >> B, out of range second operand causes NIL value";

command >>(b1:bat[:oid,:wrd],b2:bat[:oid,:lng]) :bat[:oid,:wrd]
address CMDbatRSHsignal
comment "Return B1 >> B2, raise error on out of range second operand";
command >>(b1:bat[:oid,:wrd],b2:bat[:oid,:lng],accum:int) :bat[:oid,:wrd]
address CMDbatRSHsignalaccum
comment "Return B1 >> B2, raise error on out of range second operand, reuse B if ACCUM is set";
command rsh_noerror(b1:bat[:oid,:wrd],b2:bat[:oid,:lng]) :bat[:oid,:wrd]
address CMDbatRSH
comment "Return B1 >> B2, out of range second operand causes NIL value";
pattern >>(b:bat[:oid,:wrd],v:lng) :bat[:oid,:wrd]
address CMDbatRSHcstsignal
comment "Return B >> V, raise error on out of range second operand";
pattern >>(b:bat[:oid,:wrd],v:lng,accum:int) :bat[:oid,:wrd]
address CMDbatRSHcstsignal
comment "Return B >> V, raise error on out of range second operand, reuse B if ACCUM is set";
pattern rsh_noerror(b:bat[:oid,:wrd],v:lng) :bat[:oid,:wrd]
address CMDbatRSHcst
comment "Return B >> V, out of range second operand causes NIL value";
pattern >>(v:wrd,b:bat[:oid,:lng]) :bat[:oid,:wrd]
address CMDbatRSHcstsignal
comment "Return V >> B, raise error on out of range second operand";
pattern rsh_noerror(v:wrd,b:bat[:oid,:lng]) :bat[:oid,:wrd]
address CMDbatRSHcst
comment "Return V >> B, out of range second operand causes NIL value";

command >>(b1:bat[:oid,:lng],b2:bat[:oid,:bte]) :bat[:oid,:lng]
address CMDbatRSHsignal
comment "Return B1 >> B2, raise error on out of range second operand";
command >>(b1:bat[:oid,:lng],b2:bat[:oid,:bte],accum:int) :bat[:oid,:lng]
address CMDbatRSHsignalaccum
comment "Return B1 >> B2, raise error on out of range second operand, reuse B if ACCUM is set";
command rsh_noerror(b1:bat[:oid,:lng],b2:bat[:oid,:bte]) :bat[:oid,:lng]
address CMDbatRSH
comment "Return B1 >> B2, out of range second operand causes NIL value";
pattern >>(b:bat[:oid,:lng],v:bte) :bat[:oid,:lng]
address CMDbatRSHcstsignal
comment "Return B >> V, raise error on out of range second operand";
pattern >>(b:bat[:oid,:lng],v:bte,accum:int) :bat[:oid,:lng]
address CMDbatRSHcstsignal
comment "Return B >> V, raise error on out of range second operand, reuse B if ACCUM is set";
pattern rsh_noerror(b:bat[:oid,:lng],v:bte) :bat[:oid,:lng]
address CMDbatRSHcst
comment "Return B >> V, out of range second operand causes NIL value";
pattern >>(v:lng,b:bat[:oid,:bte]) :bat[:oid,:lng]
address CMDbatRSHcstsignal
comment "Return V >> B, raise error on out of range second operand";
pattern rsh_noerror(v:lng,b:bat[:oid,:bte]) :bat[:oid,:lng]
address CMDbatRSHcst
comment "Return V >> B, out of range second operand causes NIL value";

command >>(b1:bat[:oid,:lng],b2:bat[:oid,:sht]) :bat[:oid,:lng]
address CMDbatRSHsignal
comment "Return B1 >> B2, raise error on out of range second operand";
command >>(b1:bat[:oid,:lng],b2:bat[:oid,:sht],accum:int) :bat[:oid,:lng]
address CMDbatRSHsignalaccum
comment "Return B1 >> B2, raise error on out of range second operand, reuse B if ACCUM is set";
command rsh_noerror(b1:bat[:oid,:lng],b2:bat[:oid,:sht]) :bat[:oid,:lng]
address CMDbatRSH
comment "Return B1 >> B2, out of range second operand causes NIL value";
pattern >>(b:bat[:oid,:lng],v:sht) :bat[:oid,:lng]
address CMDbatRSHcstsignal
comment "Return B >> V, raise error on out of range second operand";
pattern >>(b:bat[:oid,:lng],v:sht,accum:int) :bat[:oid,:lng]
address CMDbatRSHcstsignal
comment "Return B >> V, raise error on out of range second operand, reuse B if ACCUM is set";
pattern rsh_noerror(b:bat[:oid,:lng],v:sht) :bat[:oid,:lng]
address CMDbatRSHcst
comment "Return B >> V, out of range second operand causes NIL value";
pattern >>(v:lng,b:bat[:oid,:sht]) :bat[:oid,:lng]
address CMDbatRSHcstsignal
comment "Return V >> B, raise error on out of range second operand";
pattern rsh_noerror(v:lng,b:bat[:oid,:sht]) :bat[:oid,:lng]
address CMDbatRSHcst
comment "Return V >> B, out of range second operand causes NIL value";

command >>(b1:bat[:oid,:lng],b2:bat[:oid,:int]) :bat[:oid,:lng]
address CMDbatRSHsignal
comment "Return B1 >> B2, raise error on out of range second operand";
command >>(b1:bat[:oid,:lng],b2:bat[:oid,:int],accum:int) :bat[:oid,:lng]
address CMDbatRSHsignalaccum
comment "Return B1 >> B2, raise error on out of range second operand, reuse B if ACCUM is set";
command rsh_noerror(b1:bat[:oid,:lng],b2:bat[:oid,:int]) :bat[:oid,:lng]
address CMDbatRSH
comment "Return B1 >> B2, out of range second operand causes NIL value";
pattern >>(b:bat[:oid,:lng],v:int) :bat[:oid,:lng]
address CMDbatRSHcstsignal
comment "Return B >> V, raise error on out of range second operand";
pattern >>(b:bat[:oid,:lng],v:int,accum:int) :bat[:oid,:lng]
address CMDbatRSHcstsignal
comment "Return B >> V, raise error on out of range second operand, reuse B if ACCUM is set";
pattern rsh_noerror(b:bat[:oid,:lng],v:int) :bat[:oid,:lng]
address CMDbatRSHcst
comment "Return B >> V, out of range second operand causes NIL value";
pattern >>(v:lng,b:bat[:oid,:int]) :bat[:oid,:lng]
address CMDbatRSHcstsignal
comment "Return V >> B, raise error on out of range second operand";
pattern rsh_noerror(v:lng,b:bat[:oid,:int]) :bat[:oid,:lng]
address CMDbatRSHcst
comment "Return V >> B, out of range second operand causes NIL value";

command >>(b1:bat[:oid,:lng],b2:bat[:oid,:wrd]) :bat[:oid,:lng]
address CMDbatRSHsignal
comment "Return B1 >> B2, raise error on out of range second operand";
command >>(b1:bat[:oid,:lng],b2:bat[:oid,:wrd],accum:int) :bat[:oid,:lng]
address CMDbatRSHsignalaccum
comment "Return B1 >> B2, raise error on out of range second operand, reuse B if ACCUM is set";
command rsh_noerror(b1:bat[:oid,:lng],b2:bat[:oid,:wrd]) :bat[:oid,:lng]
address CMDbatRSH
comment "Return B1 >> B2, out of range second operand causes NIL value";
pattern >>(b:bat[:oid,:lng],v:wrd) :bat[:oid,:lng]
address CMDbatRSHcstsignal
comment "Return B >> V, raise error on out of range second operand";
pattern >>(b:bat[:oid,:lng],v:wrd,accum:int) :bat[:oid,:lng]
address CMDbatRSHcstsignal
comment "Return B >> V, raise error on out of range second operand, reuse B if ACCUM is set";
pattern rsh_noerror(b:bat[:oid,:lng],v:wrd) :bat[:oid,:lng]
address CMDbatRSHcst
comment "Return B >> V, out of range second operand causes NIL value";
pattern >>(v:lng,b:bat[:oid,:wrd]) :bat[:oid,:lng]
address CMDbatRSHcstsignal
comment "Return V >> B, raise error on out of range second operand";
pattern rsh_noerror(v:lng,b:bat[:oid,:wrd]) :bat[:oid,:lng]
address CMDbatRSHcst
comment "Return V >> B, out of range second operand causes NIL value";

command >>(b1:bat[:oid,:lng],b2:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatRSHsignal
comment "Return B1 >> B2, raise error on out of range second operand";
command >>(b1:bat[:oid,:lng],b2:bat[:oid,:lng],accum:int) :bat[:oid,:lng]
address CMDbatRSHsignalaccum
comment "Return B1 >> B2, raise error on out of range second operand, reuse B if ACCUM is set";
command rsh_noerror(b1:bat[:oid,:lng],b2:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatRSH
comment "Return B1 >> B2, out of range second operand causes NIL value";
pattern >>(b:bat[:oid,:lng],v:lng) :bat[:oid,:lng]
address CMDbatRSHcstsignal
comment "Return B >> V, raise error on out of range second operand";
pattern >>(b:bat[:oid,:lng],v:lng,accum:int) :bat[:oid,:lng]
address CMDbatRSHcstsignal
comment "Return B >> V, raise error on out of range second operand, reuse B if ACCUM is set";
pattern rsh_noerror(b:bat[:oid,:lng],v:lng) :bat[:oid,:lng]
address CMDbatRSHcst
comment "Return B >> V, out of range second operand causes NIL value";
pattern >>(v:lng,b:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatRSHcstsignal
comment "Return V >> B, raise error on out of range second operand";
pattern rsh_noerror(v:lng,b:bat[:oid,:lng]) :bat[:oid,:lng]
address CMDbatRSHcst
comment "Return V >> B, out of range second operand causes NIL value";


command <(b1:bat[:oid,:bit],b2:bat[:oid,:bit]) :bat[:oid,:bit]
address CMDbatLT
comment "Return B1 < B2";
pattern <(b:bat[:oid,:bit],v:bit) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return B < V";
pattern <(v:bit,b:bat[:oid,:bit]) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return V < B";

command <(b1:bat[:oid,:str],b2:bat[:oid,:str]) :bat[:oid,:bit]
address CMDbatLT
comment "Return B1 < B2";
pattern <(b:bat[:oid,:str],v:str) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return B < V";
pattern <(v:str,b:bat[:oid,:str]) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return V < B";

command <(b1:bat[:oid,:oid],b2:bat[:oid,:oid]) :bat[:oid,:bit]
address CMDbatLT
comment "Return B1 < B2";
pattern <(b:bat[:oid,:oid],v:oid) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return B < V";
pattern <(v:oid,b:bat[:oid,:oid]) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return V < B";

command <(b1:bat[:oid,:bte],b2:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatLT
comment "Return B1 < B2";
pattern <(b:bat[:oid,:bte],v:bte) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return B < V";
pattern <(v:bte,b:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return V < B";

command <(b1:bat[:oid,:bte],b2:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatLT
comment "Return B1 < B2";
pattern <(b:bat[:oid,:bte],v:sht) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return B < V";
pattern <(v:bte,b:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return V < B";

command <(b1:bat[:oid,:bte],b2:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatLT
comment "Return B1 < B2";
pattern <(b:bat[:oid,:bte],v:int) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return B < V";
pattern <(v:bte,b:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return V < B";

command <(b1:bat[:oid,:bte],b2:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatLT
comment "Return B1 < B2";
pattern <(b:bat[:oid,:bte],v:wrd) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return B < V";
pattern <(v:bte,b:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return V < B";

command <(b1:bat[:oid,:bte],b2:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatLT
comment "Return B1 < B2";
pattern <(b:bat[:oid,:bte],v:lng) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return B < V";
pattern <(v:bte,b:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return V < B";

command <(b1:bat[:oid,:bte],b2:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatLT
comment "Return B1 < B2";
pattern <(b:bat[:oid,:bte],v:flt) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return B < V";
pattern <(v:bte,b:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return V < B";

command <(b1:bat[:oid,:bte],b2:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatLT
comment "Return B1 < B2";
pattern <(b:bat[:oid,:bte],v:dbl) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return B < V";
pattern <(v:bte,b:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return V < B";

command <(b1:bat[:oid,:sht],b2:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatLT
comment "Return B1 < B2";
pattern <(b:bat[:oid,:sht],v:bte) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return B < V";
pattern <(v:sht,b:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return V < B";

command <(b1:bat[:oid,:sht],b2:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatLT
comment "Return B1 < B2";
pattern <(b:bat[:oid,:sht],v:sht) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return B < V";
pattern <(v:sht,b:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return V < B";

command <(b1:bat[:oid,:sht],b2:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatLT
comment "Return B1 < B2";
pattern <(b:bat[:oid,:sht],v:int) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return B < V";
pattern <(v:sht,b:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return V < B";

command <(b1:bat[:oid,:sht],b2:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatLT
comment "Return B1 < B2";
pattern <(b:bat[:oid,:sht],v:wrd) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return B < V";
pattern <(v:sht,b:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return V < B";

command <(b1:bat[:oid,:sht],b2:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatLT
comment "Return B1 < B2";
pattern <(b:bat[:oid,:sht],v:lng) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return B < V";
pattern <(v:sht,b:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return V < B";

command <(b1:bat[:oid,:sht],b2:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatLT
comment "Return B1 < B2";
pattern <(b:bat[:oid,:sht],v:flt) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return B < V";
pattern <(v:sht,b:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return V < B";

command <(b1:bat[:oid,:sht],b2:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatLT
comment "Return B1 < B2";
pattern <(b:bat[:oid,:sht],v:dbl) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return B < V";
pattern <(v:sht,b:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return V < B";

command <(b1:bat[:oid,:int],b2:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatLT
comment "Return B1 < B2";
pattern <(b:bat[:oid,:int],v:bte) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return B < V";
pattern <(v:int,b:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return V < B";

command <(b1:bat[:oid,:int],b2:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatLT
comment "Return B1 < B2";
pattern <(b:bat[:oid,:int],v:sht) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return B < V";
pattern <(v:int,b:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return V < B";

command <(b1:bat[:oid,:int],b2:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatLT
comment "Return B1 < B2";
pattern <(b:bat[:oid,:int],v:int) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return B < V";
pattern <(v:int,b:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return V < B";

command <(b1:bat[:oid,:int],b2:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatLT
comment "Return B1 < B2";
pattern <(b:bat[:oid,:int],v:wrd) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return B < V";
pattern <(v:int,b:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return V < B";

command <(b1:bat[:oid,:int],b2:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatLT
comment "Return B1 < B2";
pattern <(b:bat[:oid,:int],v:lng) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return B < V";
pattern <(v:int,b:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return V < B";

command <(b1:bat[:oid,:int],b2:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatLT
comment "Return B1 < B2";
pattern <(b:bat[:oid,:int],v:flt) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return B < V";
pattern <(v:int,b:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return V < B";

command <(b1:bat[:oid,:int],b2:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatLT
comment "Return B1 < B2";
pattern <(b:bat[:oid,:int],v:dbl) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return B < V";
pattern <(v:int,b:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return V < B";

command <(b1:bat[:oid,:wrd],b2:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatLT
comment "Return B1 < B2";
pattern <(b:bat[:oid,:wrd],v:bte) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return B < V";
pattern <(v:wrd,b:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return V < B";

command <(b1:bat[:oid,:wrd],b2:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatLT
comment "Return B1 < B2";
pattern <(b:bat[:oid,:wrd],v:sht) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return B < V";
pattern <(v:wrd,b:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return V < B";

command <(b1:bat[:oid,:wrd],b2:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatLT
comment "Return B1 < B2";
pattern <(b:bat[:oid,:wrd],v:int) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return B < V";
pattern <(v:wrd,b:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return V < B";

command <(b1:bat[:oid,:wrd],b2:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatLT
comment "Return B1 < B2";
pattern <(b:bat[:oid,:wrd],v:wrd) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return B < V";
pattern <(v:wrd,b:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return V < B";

command <(b1:bat[:oid,:wrd],b2:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatLT
comment "Return B1 < B2";
pattern <(b:bat[:oid,:wrd],v:lng) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return B < V";
pattern <(v:wrd,b:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return V < B";

command <(b1:bat[:oid,:wrd],b2:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatLT
comment "Return B1 < B2";
pattern <(b:bat[:oid,:wrd],v:flt) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return B < V";
pattern <(v:wrd,b:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return V < B";

command <(b1:bat[:oid,:wrd],b2:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatLT
comment "Return B1 < B2";
pattern <(b:bat[:oid,:wrd],v:dbl) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return B < V";
pattern <(v:wrd,b:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return V < B";

command <(b1:bat[:oid,:lng],b2:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatLT
comment "Return B1 < B2";
pattern <(b:bat[:oid,:lng],v:bte) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return B < V";
pattern <(v:lng,b:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return V < B";

command <(b1:bat[:oid,:lng],b2:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatLT
comment "Return B1 < B2";
pattern <(b:bat[:oid,:lng],v:sht) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return B < V";
pattern <(v:lng,b:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return V < B";

command <(b1:bat[:oid,:lng],b2:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatLT
comment "Return B1 < B2";
pattern <(b:bat[:oid,:lng],v:int) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return B < V";
pattern <(v:lng,b:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return V < B";

command <(b1:bat[:oid,:lng],b2:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatLT
comment "Return B1 < B2";
pattern <(b:bat[:oid,:lng],v:wrd) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return B < V";
pattern <(v:lng,b:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return V < B";

command <(b1:bat[:oid,:lng],b2:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatLT
comment "Return B1 < B2";
pattern <(b:bat[:oid,:lng],v:lng) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return B < V";
pattern <(v:lng,b:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return V < B";

command <(b1:bat[:oid,:lng],b2:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatLT
comment "Return B1 < B2";
pattern <(b:bat[:oid,:lng],v:flt) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return B < V";
pattern <(v:lng,b:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return V < B";

command <(b1:bat[:oid,:lng],b2:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatLT
comment "Return B1 < B2";
pattern <(b:bat[:oid,:lng],v:dbl) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return B < V";
pattern <(v:lng,b:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return V < B";

command <(b1:bat[:oid,:flt],b2:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatLT
comment "Return B1 < B2";
pattern <(b:bat[:oid,:flt],v:bte) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return B < V";
pattern <(v:flt,b:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return V < B";

command <(b1:bat[:oid,:flt],b2:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatLT
comment "Return B1 < B2";
pattern <(b:bat[:oid,:flt],v:sht) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return B < V";
pattern <(v:flt,b:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return V < B";

command <(b1:bat[:oid,:flt],b2:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatLT
comment "Return B1 < B2";
pattern <(b:bat[:oid,:flt],v:int) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return B < V";
pattern <(v:flt,b:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return V < B";

command <(b1:bat[:oid,:flt],b2:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatLT
comment "Return B1 < B2";
pattern <(b:bat[:oid,:flt],v:wrd) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return B < V";
pattern <(v:flt,b:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return V < B";

command <(b1:bat[:oid,:flt],b2:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatLT
comment "Return B1 < B2";
pattern <(b:bat[:oid,:flt],v:lng) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return B < V";
pattern <(v:flt,b:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return V < B";

command <(b1:bat[:oid,:flt],b2:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatLT
comment "Return B1 < B2";
pattern <(b:bat[:oid,:flt],v:flt) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return B < V";
pattern <(v:flt,b:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return V < B";

command <(b1:bat[:oid,:flt],b2:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatLT
comment "Return B1 < B2";
pattern <(b:bat[:oid,:flt],v:dbl) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return B < V";
pattern <(v:flt,b:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return V < B";

command <(b1:bat[:oid,:dbl],b2:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatLT
comment "Return B1 < B2";
pattern <(b:bat[:oid,:dbl],v:bte) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return B < V";
pattern <(v:dbl,b:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return V < B";

command <(b1:bat[:oid,:dbl],b2:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatLT
comment "Return B1 < B2";
pattern <(b:bat[:oid,:dbl],v:sht) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return B < V";
pattern <(v:dbl,b:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return V < B";

command <(b1:bat[:oid,:dbl],b2:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatLT
comment "Return B1 < B2";
pattern <(b:bat[:oid,:dbl],v:int) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return B < V";
pattern <(v:dbl,b:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return V < B";

command <(b1:bat[:oid,:dbl],b2:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatLT
comment "Return B1 < B2";
pattern <(b:bat[:oid,:dbl],v:wrd) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return B < V";
pattern <(v:dbl,b:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return V < B";

command <(b1:bat[:oid,:dbl],b2:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatLT
comment "Return B1 < B2";
pattern <(b:bat[:oid,:dbl],v:lng) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return B < V";
pattern <(v:dbl,b:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return V < B";

command <(b1:bat[:oid,:dbl],b2:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatLT
comment "Return B1 < B2";
pattern <(b:bat[:oid,:dbl],v:flt) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return B < V";
pattern <(v:dbl,b:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return V < B";

command <(b1:bat[:oid,:dbl],b2:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatLT
comment "Return B1 < B2";
pattern <(b:bat[:oid,:dbl],v:dbl) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return B < V";
pattern <(v:dbl,b:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatLTcst
comment "Return V < B";


command <=(b1:bat[:oid,:bit],b2:bat[:oid,:bit]) :bat[:oid,:bit]
address CMDbatLE
comment "Return B1 <= B2";
pattern <=(b:bat[:oid,:bit],v:bit) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return B <= V";
pattern <=(v:bit,b:bat[:oid,:bit]) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return V <= B";

command <=(b1:bat[:oid,:str],b2:bat[:oid,:str]) :bat[:oid,:bit]
address CMDbatLE
comment "Return B1 <= B2";
pattern <=(b:bat[:oid,:str],v:str) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return B <= V";
pattern <=(v:str,b:bat[:oid,:str]) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return V <= B";

command <=(b1:bat[:oid,:oid],b2:bat[:oid,:oid]) :bat[:oid,:bit]
address CMDbatLE
comment "Return B1 <= B2";
pattern <=(b:bat[:oid,:oid],v:oid) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return B <= V";
pattern <=(v:oid,b:bat[:oid,:oid]) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return V <= B";

command <=(b1:bat[:oid,:bte],b2:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatLE
comment "Return B1 <= B2";
pattern <=(b:bat[:oid,:bte],v:bte) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return B <= V";
pattern <=(v:bte,b:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return V <= B";

command <=(b1:bat[:oid,:bte],b2:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatLE
comment "Return B1 <= B2";
pattern <=(b:bat[:oid,:bte],v:sht) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return B <= V";
pattern <=(v:bte,b:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return V <= B";

command <=(b1:bat[:oid,:bte],b2:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatLE
comment "Return B1 <= B2";
pattern <=(b:bat[:oid,:bte],v:int) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return B <= V";
pattern <=(v:bte,b:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return V <= B";

command <=(b1:bat[:oid,:bte],b2:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatLE
comment "Return B1 <= B2";
pattern <=(b:bat[:oid,:bte],v:wrd) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return B <= V";
pattern <=(v:bte,b:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return V <= B";

command <=(b1:bat[:oid,:bte],b2:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatLE
comment "Return B1 <= B2";
pattern <=(b:bat[:oid,:bte],v:lng) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return B <= V";
pattern <=(v:bte,b:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return V <= B";

command <=(b1:bat[:oid,:bte],b2:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatLE
comment "Return B1 <= B2";
pattern <=(b:bat[:oid,:bte],v:flt) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return B <= V";
pattern <=(v:bte,b:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return V <= B";

command <=(b1:bat[:oid,:bte],b2:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatLE
comment "Return B1 <= B2";
pattern <=(b:bat[:oid,:bte],v:dbl) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return B <= V";
pattern <=(v:bte,b:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return V <= B";

command <=(b1:bat[:oid,:sht],b2:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatLE
comment "Return B1 <= B2";
pattern <=(b:bat[:oid,:sht],v:bte) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return B <= V";
pattern <=(v:sht,b:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return V <= B";

command <=(b1:bat[:oid,:sht],b2:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatLE
comment "Return B1 <= B2";
pattern <=(b:bat[:oid,:sht],v:sht) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return B <= V";
pattern <=(v:sht,b:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return V <= B";

command <=(b1:bat[:oid,:sht],b2:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatLE
comment "Return B1 <= B2";
pattern <=(b:bat[:oid,:sht],v:int) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return B <= V";
pattern <=(v:sht,b:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return V <= B";

command <=(b1:bat[:oid,:sht],b2:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatLE
comment "Return B1 <= B2";
pattern <=(b:bat[:oid,:sht],v:wrd) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return B <= V";
pattern <=(v:sht,b:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return V <= B";

command <=(b1:bat[:oid,:sht],b2:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatLE
comment "Return B1 <= B2";
pattern <=(b:bat[:oid,:sht],v:lng) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return B <= V";
pattern <=(v:sht,b:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return V <= B";

command <=(b1:bat[:oid,:sht],b2:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatLE
comment "Return B1 <= B2";
pattern <=(b:bat[:oid,:sht],v:flt) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return B <= V";
pattern <=(v:sht,b:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return V <= B";

command <=(b1:bat[:oid,:sht],b2:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatLE
comment "Return B1 <= B2";
pattern <=(b:bat[:oid,:sht],v:dbl) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return B <= V";
pattern <=(v:sht,b:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return V <= B";

command <=(b1:bat[:oid,:int],b2:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatLE
comment "Return B1 <= B2";
pattern <=(b:bat[:oid,:int],v:bte) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return B <= V";
pattern <=(v:int,b:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return V <= B";

command <=(b1:bat[:oid,:int],b2:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatLE
comment "Return B1 <= B2";
pattern <=(b:bat[:oid,:int],v:sht) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return B <= V";
pattern <=(v:int,b:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return V <= B";

command <=(b1:bat[:oid,:int],b2:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatLE
comment "Return B1 <= B2";
pattern <=(b:bat[:oid,:int],v:int) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return B <= V";
pattern <=(v:int,b:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return V <= B";

command <=(b1:bat[:oid,:int],b2:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatLE
comment "Return B1 <= B2";
pattern <=(b:bat[:oid,:int],v:wrd) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return B <= V";
pattern <=(v:int,b:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return V <= B";

command <=(b1:bat[:oid,:int],b2:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatLE
comment "Return B1 <= B2";
pattern <=(b:bat[:oid,:int],v:lng) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return B <= V";
pattern <=(v:int,b:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return V <= B";

command <=(b1:bat[:oid,:int],b2:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatLE
comment "Return B1 <= B2";
pattern <=(b:bat[:oid,:int],v:flt) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return B <= V";
pattern <=(v:int,b:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return V <= B";

command <=(b1:bat[:oid,:int],b2:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatLE
comment "Return B1 <= B2";
pattern <=(b:bat[:oid,:int],v:dbl) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return B <= V";
pattern <=(v:int,b:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return V <= B";

command <=(b1:bat[:oid,:wrd],b2:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatLE
comment "Return B1 <= B2";
pattern <=(b:bat[:oid,:wrd],v:bte) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return B <= V";
pattern <=(v:wrd,b:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return V <= B";

command <=(b1:bat[:oid,:wrd],b2:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatLE
comment "Return B1 <= B2";
pattern <=(b:bat[:oid,:wrd],v:sht) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return B <= V";
pattern <=(v:wrd,b:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return V <= B";

command <=(b1:bat[:oid,:wrd],b2:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatLE
comment "Return B1 <= B2";
pattern <=(b:bat[:oid,:wrd],v:int) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return B <= V";
pattern <=(v:wrd,b:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return V <= B";

command <=(b1:bat[:oid,:wrd],b2:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatLE
comment "Return B1 <= B2";
pattern <=(b:bat[:oid,:wrd],v:wrd) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return B <= V";
pattern <=(v:wrd,b:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return V <= B";

command <=(b1:bat[:oid,:wrd],b2:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatLE
comment "Return B1 <= B2";
pattern <=(b:bat[:oid,:wrd],v:lng) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return B <= V";
pattern <=(v:wrd,b:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return V <= B";

command <=(b1:bat[:oid,:wrd],b2:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatLE
comment "Return B1 <= B2";
pattern <=(b:bat[:oid,:wrd],v:flt) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return B <= V";
pattern <=(v:wrd,b:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return V <= B";

command <=(b1:bat[:oid,:wrd],b2:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatLE
comment "Return B1 <= B2";
pattern <=(b:bat[:oid,:wrd],v:dbl) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return B <= V";
pattern <=(v:wrd,b:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return V <= B";

command <=(b1:bat[:oid,:lng],b2:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatLE
comment "Return B1 <= B2";
pattern <=(b:bat[:oid,:lng],v:bte) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return B <= V";
pattern <=(v:lng,b:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return V <= B";

command <=(b1:bat[:oid,:lng],b2:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatLE
comment "Return B1 <= B2";
pattern <=(b:bat[:oid,:lng],v:sht) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return B <= V";
pattern <=(v:lng,b:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return V <= B";

command <=(b1:bat[:oid,:lng],b2:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatLE
comment "Return B1 <= B2";
pattern <=(b:bat[:oid,:lng],v:int) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return B <= V";
pattern <=(v:lng,b:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return V <= B";

command <=(b1:bat[:oid,:lng],b2:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatLE
comment "Return B1 <= B2";
pattern <=(b:bat[:oid,:lng],v:wrd) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return B <= V";
pattern <=(v:lng,b:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return V <= B";

command <=(b1:bat[:oid,:lng],b2:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatLE
comment "Return B1 <= B2";
pattern <=(b:bat[:oid,:lng],v:lng) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return B <= V";
pattern <=(v:lng,b:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return V <= B";

command <=(b1:bat[:oid,:lng],b2:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatLE
comment "Return B1 <= B2";
pattern <=(b:bat[:oid,:lng],v:flt) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return B <= V";
pattern <=(v:lng,b:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return V <= B";

command <=(b1:bat[:oid,:lng],b2:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatLE
comment "Return B1 <= B2";
pattern <=(b:bat[:oid,:lng],v:dbl) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return B <= V";
pattern <=(v:lng,b:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return V <= B";

command <=(b1:bat[:oid,:flt],b2:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatLE
comment "Return B1 <= B2";
pattern <=(b:bat[:oid,:flt],v:bte) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return B <= V";
pattern <=(v:flt,b:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return V <= B";

command <=(b1:bat[:oid,:flt],b2:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatLE
comment "Return B1 <= B2";
pattern <=(b:bat[:oid,:flt],v:sht) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return B <= V";
pattern <=(v:flt,b:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return V <= B";

command <=(b1:bat[:oid,:flt],b2:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatLE
comment "Return B1 <= B2";
pattern <=(b:bat[:oid,:flt],v:int) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return B <= V";
pattern <=(v:flt,b:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return V <= B";

command <=(b1:bat[:oid,:flt],b2:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatLE
comment "Return B1 <= B2";
pattern <=(b:bat[:oid,:flt],v:wrd) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return B <= V";
pattern <=(v:flt,b:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return V <= B";

command <=(b1:bat[:oid,:flt],b2:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatLE
comment "Return B1 <= B2";
pattern <=(b:bat[:oid,:flt],v:lng) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return B <= V";
pattern <=(v:flt,b:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return V <= B";

command <=(b1:bat[:oid,:flt],b2:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatLE
comment "Return B1 <= B2";
pattern <=(b:bat[:oid,:flt],v:flt) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return B <= V";
pattern <=(v:flt,b:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return V <= B";

command <=(b1:bat[:oid,:flt],b2:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatLE
comment "Return B1 <= B2";
pattern <=(b:bat[:oid,:flt],v:dbl) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return B <= V";
pattern <=(v:flt,b:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return V <= B";

command <=(b1:bat[:oid,:dbl],b2:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatLE
comment "Return B1 <= B2";
pattern <=(b:bat[:oid,:dbl],v:bte) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return B <= V";
pattern <=(v:dbl,b:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return V <= B";

command <=(b1:bat[:oid,:dbl],b2:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatLE
comment "Return B1 <= B2";
pattern <=(b:bat[:oid,:dbl],v:sht) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return B <= V";
pattern <=(v:dbl,b:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return V <= B";

command <=(b1:bat[:oid,:dbl],b2:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatLE
comment "Return B1 <= B2";
pattern <=(b:bat[:oid,:dbl],v:int) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return B <= V";
pattern <=(v:dbl,b:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return V <= B";

command <=(b1:bat[:oid,:dbl],b2:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatLE
comment "Return B1 <= B2";
pattern <=(b:bat[:oid,:dbl],v:wrd) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return B <= V";
pattern <=(v:dbl,b:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return V <= B";

command <=(b1:bat[:oid,:dbl],b2:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatLE
comment "Return B1 <= B2";
pattern <=(b:bat[:oid,:dbl],v:lng) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return B <= V";
pattern <=(v:dbl,b:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return V <= B";

command <=(b1:bat[:oid,:dbl],b2:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatLE
comment "Return B1 <= B2";
pattern <=(b:bat[:oid,:dbl],v:flt) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return B <= V";
pattern <=(v:dbl,b:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return V <= B";

command <=(b1:bat[:oid,:dbl],b2:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatLE
comment "Return B1 <= B2";
pattern <=(b:bat[:oid,:dbl],v:dbl) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return B <= V";
pattern <=(v:dbl,b:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatLEcst
comment "Return V <= B";


command >(b1:bat[:oid,:bit],b2:bat[:oid,:bit]) :bat[:oid,:bit]
address CMDbatGT
comment "Return B1 > B2";
pattern >(b:bat[:oid,:bit],v:bit) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return B > V";
pattern >(v:bit,b:bat[:oid,:bit]) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return V > B";

command >(b1:bat[:oid,:str],b2:bat[:oid,:str]) :bat[:oid,:bit]
address CMDbatGT
comment "Return B1 > B2";
pattern >(b:bat[:oid,:str],v:str) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return B > V";
pattern >(v:str,b:bat[:oid,:str]) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return V > B";

command >(b1:bat[:oid,:oid],b2:bat[:oid,:oid]) :bat[:oid,:bit]
address CMDbatGT
comment "Return B1 > B2";
pattern >(b:bat[:oid,:oid],v:oid) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return B > V";
pattern >(v:oid,b:bat[:oid,:oid]) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return V > B";

command >(b1:bat[:oid,:bte],b2:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatGT
comment "Return B1 > B2";
pattern >(b:bat[:oid,:bte],v:bte) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return B > V";
pattern >(v:bte,b:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return V > B";

command >(b1:bat[:oid,:bte],b2:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatGT
comment "Return B1 > B2";
pattern >(b:bat[:oid,:bte],v:sht) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return B > V";
pattern >(v:bte,b:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return V > B";

command >(b1:bat[:oid,:bte],b2:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatGT
comment "Return B1 > B2";
pattern >(b:bat[:oid,:bte],v:int) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return B > V";
pattern >(v:bte,b:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return V > B";

command >(b1:bat[:oid,:bte],b2:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatGT
comment "Return B1 > B2";
pattern >(b:bat[:oid,:bte],v:wrd) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return B > V";
pattern >(v:bte,b:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return V > B";

command >(b1:bat[:oid,:bte],b2:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatGT
comment "Return B1 > B2";
pattern >(b:bat[:oid,:bte],v:lng) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return B > V";
pattern >(v:bte,b:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return V > B";

command >(b1:bat[:oid,:bte],b2:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatGT
comment "Return B1 > B2";
pattern >(b:bat[:oid,:bte],v:flt) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return B > V";
pattern >(v:bte,b:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return V > B";

command >(b1:bat[:oid,:bte],b2:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatGT
comment "Return B1 > B2";
pattern >(b:bat[:oid,:bte],v:dbl) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return B > V";
pattern >(v:bte,b:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return V > B";

command >(b1:bat[:oid,:sht],b2:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatGT
comment "Return B1 > B2";
pattern >(b:bat[:oid,:sht],v:bte) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return B > V";
pattern >(v:sht,b:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return V > B";

command >(b1:bat[:oid,:sht],b2:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatGT
comment "Return B1 > B2";
pattern >(b:bat[:oid,:sht],v:sht) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return B > V";
pattern >(v:sht,b:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return V > B";

command >(b1:bat[:oid,:sht],b2:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatGT
comment "Return B1 > B2";
pattern >(b:bat[:oid,:sht],v:int) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return B > V";
pattern >(v:sht,b:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return V > B";

command >(b1:bat[:oid,:sht],b2:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatGT
comment "Return B1 > B2";
pattern >(b:bat[:oid,:sht],v:wrd) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return B > V";
pattern >(v:sht,b:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return V > B";

command >(b1:bat[:oid,:sht],b2:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatGT
comment "Return B1 > B2";
pattern >(b:bat[:oid,:sht],v:lng) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return B > V";
pattern >(v:sht,b:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return V > B";

command >(b1:bat[:oid,:sht],b2:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatGT
comment "Return B1 > B2";
pattern >(b:bat[:oid,:sht],v:flt) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return B > V";
pattern >(v:sht,b:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return V > B";

command >(b1:bat[:oid,:sht],b2:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatGT
comment "Return B1 > B2";
pattern >(b:bat[:oid,:sht],v:dbl) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return B > V";
pattern >(v:sht,b:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return V > B";

command >(b1:bat[:oid,:int],b2:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatGT
comment "Return B1 > B2";
pattern >(b:bat[:oid,:int],v:bte) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return B > V";
pattern >(v:int,b:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return V > B";

command >(b1:bat[:oid,:int],b2:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatGT
comment "Return B1 > B2";
pattern >(b:bat[:oid,:int],v:sht) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return B > V";
pattern >(v:int,b:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return V > B";

command >(b1:bat[:oid,:int],b2:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatGT
comment "Return B1 > B2";
pattern >(b:bat[:oid,:int],v:int) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return B > V";
pattern >(v:int,b:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return V > B";

command >(b1:bat[:oid,:int],b2:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatGT
comment "Return B1 > B2";
pattern >(b:bat[:oid,:int],v:wrd) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return B > V";
pattern >(v:int,b:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return V > B";

command >(b1:bat[:oid,:int],b2:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatGT
comment "Return B1 > B2";
pattern >(b:bat[:oid,:int],v:lng) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return B > V";
pattern >(v:int,b:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return V > B";

command >(b1:bat[:oid,:int],b2:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatGT
comment "Return B1 > B2";
pattern >(b:bat[:oid,:int],v:flt) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return B > V";
pattern >(v:int,b:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return V > B";

command >(b1:bat[:oid,:int],b2:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatGT
comment "Return B1 > B2";
pattern >(b:bat[:oid,:int],v:dbl) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return B > V";
pattern >(v:int,b:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return V > B";

command >(b1:bat[:oid,:wrd],b2:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatGT
comment "Return B1 > B2";
pattern >(b:bat[:oid,:wrd],v:bte) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return B > V";
pattern >(v:wrd,b:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return V > B";

command >(b1:bat[:oid,:wrd],b2:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatGT
comment "Return B1 > B2";
pattern >(b:bat[:oid,:wrd],v:sht) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return B > V";
pattern >(v:wrd,b:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return V > B";

command >(b1:bat[:oid,:wrd],b2:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatGT
comment "Return B1 > B2";
pattern >(b:bat[:oid,:wrd],v:int) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return B > V";
pattern >(v:wrd,b:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return V > B";

command >(b1:bat[:oid,:wrd],b2:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatGT
comment "Return B1 > B2";
pattern >(b:bat[:oid,:wrd],v:wrd) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return B > V";
pattern >(v:wrd,b:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return V > B";

command >(b1:bat[:oid,:wrd],b2:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatGT
comment "Return B1 > B2";
pattern >(b:bat[:oid,:wrd],v:lng) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return B > V";
pattern >(v:wrd,b:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return V > B";

command >(b1:bat[:oid,:wrd],b2:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatGT
comment "Return B1 > B2";
pattern >(b:bat[:oid,:wrd],v:flt) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return B > V";
pattern >(v:wrd,b:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return V > B";

command >(b1:bat[:oid,:wrd],b2:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatGT
comment "Return B1 > B2";
pattern >(b:bat[:oid,:wrd],v:dbl) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return B > V";
pattern >(v:wrd,b:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return V > B";

command >(b1:bat[:oid,:lng],b2:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatGT
comment "Return B1 > B2";
pattern >(b:bat[:oid,:lng],v:bte) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return B > V";
pattern >(v:lng,b:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return V > B";

command >(b1:bat[:oid,:lng],b2:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatGT
comment "Return B1 > B2";
pattern >(b:bat[:oid,:lng],v:sht) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return B > V";
pattern >(v:lng,b:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return V > B";

command >(b1:bat[:oid,:lng],b2:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatGT
comment "Return B1 > B2";
pattern >(b:bat[:oid,:lng],v:int) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return B > V";
pattern >(v:lng,b:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return V > B";

command >(b1:bat[:oid,:lng],b2:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatGT
comment "Return B1 > B2";
pattern >(b:bat[:oid,:lng],v:wrd) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return B > V";
pattern >(v:lng,b:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return V > B";

command >(b1:bat[:oid,:lng],b2:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatGT
comment "Return B1 > B2";
pattern >(b:bat[:oid,:lng],v:lng) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return B > V";
pattern >(v:lng,b:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return V > B";

command >(b1:bat[:oid,:lng],b2:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatGT
comment "Return B1 > B2";
pattern >(b:bat[:oid,:lng],v:flt) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return B > V";
pattern >(v:lng,b:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return V > B";

command >(b1:bat[:oid,:lng],b2:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatGT
comment "Return B1 > B2";
pattern >(b:bat[:oid,:lng],v:dbl) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return B > V";
pattern >(v:lng,b:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return V > B";

command >(b1:bat[:oid,:flt],b2:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatGT
comment "Return B1 > B2";
pattern >(b:bat[:oid,:flt],v:bte) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return B > V";
pattern >(v:flt,b:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return V > B";

command >(b1:bat[:oid,:flt],b2:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatGT
comment "Return B1 > B2";
pattern >(b:bat[:oid,:flt],v:sht) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return B > V";
pattern >(v:flt,b:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return V > B";

command >(b1:bat[:oid,:flt],b2:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatGT
comment "Return B1 > B2";
pattern >(b:bat[:oid,:flt],v:int) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return B > V";
pattern >(v:flt,b:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return V > B";

command >(b1:bat[:oid,:flt],b2:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatGT
comment "Return B1 > B2";
pattern >(b:bat[:oid,:flt],v:wrd) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return B > V";
pattern >(v:flt,b:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return V > B";

command >(b1:bat[:oid,:flt],b2:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatGT
comment "Return B1 > B2";
pattern >(b:bat[:oid,:flt],v:lng) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return B > V";
pattern >(v:flt,b:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return V > B";

command >(b1:bat[:oid,:flt],b2:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatGT
comment "Return B1 > B2";
pattern >(b:bat[:oid,:flt],v:flt) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return B > V";
pattern >(v:flt,b:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return V > B";

command >(b1:bat[:oid,:flt],b2:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatGT
comment "Return B1 > B2";
pattern >(b:bat[:oid,:flt],v:dbl) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return B > V";
pattern >(v:flt,b:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return V > B";

command >(b1:bat[:oid,:dbl],b2:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatGT
comment "Return B1 > B2";
pattern >(b:bat[:oid,:dbl],v:bte) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return B > V";
pattern >(v:dbl,b:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return V > B";

command >(b1:bat[:oid,:dbl],b2:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatGT
comment "Return B1 > B2";
pattern >(b:bat[:oid,:dbl],v:sht) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return B > V";
pattern >(v:dbl,b:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return V > B";

command >(b1:bat[:oid,:dbl],b2:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatGT
comment "Return B1 > B2";
pattern >(b:bat[:oid,:dbl],v:int) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return B > V";
pattern >(v:dbl,b:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return V > B";

command >(b1:bat[:oid,:dbl],b2:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatGT
comment "Return B1 > B2";
pattern >(b:bat[:oid,:dbl],v:wrd) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return B > V";
pattern >(v:dbl,b:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return V > B";

command >(b1:bat[:oid,:dbl],b2:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatGT
comment "Return B1 > B2";
pattern >(b:bat[:oid,:dbl],v:lng) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return B > V";
pattern >(v:dbl,b:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return V > B";

command >(b1:bat[:oid,:dbl],b2:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatGT
comment "Return B1 > B2";
pattern >(b:bat[:oid,:dbl],v:flt) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return B > V";
pattern >(v:dbl,b:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return V > B";

command >(b1:bat[:oid,:dbl],b2:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatGT
comment "Return B1 > B2";
pattern >(b:bat[:oid,:dbl],v:dbl) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return B > V";
pattern >(v:dbl,b:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatGTcst
comment "Return V > B";


command >=(b1:bat[:oid,:bit],b2:bat[:oid,:bit]) :bat[:oid,:bit]
address CMDbatGE
comment "Return B1 >= B2";
pattern >=(b:bat[:oid,:bit],v:bit) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return B >= V";
pattern >=(v:bit,b:bat[:oid,:bit]) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return V >= B";

command >=(b1:bat[:oid,:str],b2:bat[:oid,:str]) :bat[:oid,:bit]
address CMDbatGE
comment "Return B1 >= B2";
pattern >=(b:bat[:oid,:str],v:str) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return B >= V";
pattern >=(v:str,b:bat[:oid,:str]) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return V >= B";

command >=(b1:bat[:oid,:oid],b2:bat[:oid,:oid]) :bat[:oid,:bit]
address CMDbatGE
comment "Return B1 >= B2";
pattern >=(b:bat[:oid,:oid],v:oid) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return B >= V";
pattern >=(v:oid,b:bat[:oid,:oid]) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return V >= B";

command >=(b1:bat[:oid,:bte],b2:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatGE
comment "Return B1 >= B2";
pattern >=(b:bat[:oid,:bte],v:bte) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return B >= V";
pattern >=(v:bte,b:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return V >= B";

command >=(b1:bat[:oid,:bte],b2:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatGE
comment "Return B1 >= B2";
pattern >=(b:bat[:oid,:bte],v:sht) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return B >= V";
pattern >=(v:bte,b:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return V >= B";

command >=(b1:bat[:oid,:bte],b2:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatGE
comment "Return B1 >= B2";
pattern >=(b:bat[:oid,:bte],v:int) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return B >= V";
pattern >=(v:bte,b:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return V >= B";

command >=(b1:bat[:oid,:bte],b2:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatGE
comment "Return B1 >= B2";
pattern >=(b:bat[:oid,:bte],v:wrd) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return B >= V";
pattern >=(v:bte,b:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return V >= B";

command >=(b1:bat[:oid,:bte],b2:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatGE
comment "Return B1 >= B2";
pattern >=(b:bat[:oid,:bte],v:lng) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return B >= V";
pattern >=(v:bte,b:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return V >= B";

command >=(b1:bat[:oid,:bte],b2:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatGE
comment "Return B1 >= B2";
pattern >=(b:bat[:oid,:bte],v:flt) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return B >= V";
pattern >=(v:bte,b:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return V >= B";

command >=(b1:bat[:oid,:bte],b2:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatGE
comment "Return B1 >= B2";
pattern >=(b:bat[:oid,:bte],v:dbl) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return B >= V";
pattern >=(v:bte,b:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return V >= B";

command >=(b1:bat[:oid,:sht],b2:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatGE
comment "Return B1 >= B2";
pattern >=(b:bat[:oid,:sht],v:bte) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return B >= V";
pattern >=(v:sht,b:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return V >= B";

command >=(b1:bat[:oid,:sht],b2:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatGE
comment "Return B1 >= B2";
pattern >=(b:bat[:oid,:sht],v:sht) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return B >= V";
pattern >=(v:sht,b:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return V >= B";

command >=(b1:bat[:oid,:sht],b2:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatGE
comment "Return B1 >= B2";
pattern >=(b:bat[:oid,:sht],v:int) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return B >= V";
pattern >=(v:sht,b:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return V >= B";

command >=(b1:bat[:oid,:sht],b2:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatGE
comment "Return B1 >= B2";
pattern >=(b:bat[:oid,:sht],v:wrd) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return B >= V";
pattern >=(v:sht,b:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return V >= B";

command >=(b1:bat[:oid,:sht],b2:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatGE
comment "Return B1 >= B2";
pattern >=(b:bat[:oid,:sht],v:lng) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return B >= V";
pattern >=(v:sht,b:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return V >= B";

command >=(b1:bat[:oid,:sht],b2:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatGE
comment "Return B1 >= B2";
pattern >=(b:bat[:oid,:sht],v:flt) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return B >= V";
pattern >=(v:sht,b:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return V >= B";

command >=(b1:bat[:oid,:sht],b2:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatGE
comment "Return B1 >= B2";
pattern >=(b:bat[:oid,:sht],v:dbl) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return B >= V";
pattern >=(v:sht,b:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return V >= B";

command >=(b1:bat[:oid,:int],b2:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatGE
comment "Return B1 >= B2";
pattern >=(b:bat[:oid,:int],v:bte) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return B >= V";
pattern >=(v:int,b:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return V >= B";

command >=(b1:bat[:oid,:int],b2:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatGE
comment "Return B1 >= B2";
pattern >=(b:bat[:oid,:int],v:sht) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return B >= V";
pattern >=(v:int,b:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return V >= B";

command >=(b1:bat[:oid,:int],b2:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatGE
comment "Return B1 >= B2";
pattern >=(b:bat[:oid,:int],v:int) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return B >= V";
pattern >=(v:int,b:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return V >= B";

command >=(b1:bat[:oid,:int],b2:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatGE
comment "Return B1 >= B2";
pattern >=(b:bat[:oid,:int],v:wrd) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return B >= V";
pattern >=(v:int,b:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return V >= B";

command >=(b1:bat[:oid,:int],b2:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatGE
comment "Return B1 >= B2";
pattern >=(b:bat[:oid,:int],v:lng) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return B >= V";
pattern >=(v:int,b:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return V >= B";

command >=(b1:bat[:oid,:int],b2:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatGE
comment "Return B1 >= B2";
pattern >=(b:bat[:oid,:int],v:flt) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return B >= V";
pattern >=(v:int,b:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return V >= B";

command >=(b1:bat[:oid,:int],b2:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatGE
comment "Return B1 >= B2";
pattern >=(b:bat[:oid,:int],v:dbl) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return B >= V";
pattern >=(v:int,b:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return V >= B";

command >=(b1:bat[:oid,:wrd],b2:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatGE
comment "Return B1 >= B2";
pattern >=(b:bat[:oid,:wrd],v:bte) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return B >= V";
pattern >=(v:wrd,b:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return V >= B";

command >=(b1:bat[:oid,:wrd],b2:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatGE
comment "Return B1 >= B2";
pattern >=(b:bat[:oid,:wrd],v:sht) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return B >= V";
pattern >=(v:wrd,b:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return V >= B";

command >=(b1:bat[:oid,:wrd],b2:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatGE
comment "Return B1 >= B2";
pattern >=(b:bat[:oid,:wrd],v:int) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return B >= V";
pattern >=(v:wrd,b:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return V >= B";

command >=(b1:bat[:oid,:wrd],b2:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatGE
comment "Return B1 >= B2";
pattern >=(b:bat[:oid,:wrd],v:wrd) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return B >= V";
pattern >=(v:wrd,b:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return V >= B";

command >=(b1:bat[:oid,:wrd],b2:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatGE
comment "Return B1 >= B2";
pattern >=(b:bat[:oid,:wrd],v:lng) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return B >= V";
pattern >=(v:wrd,b:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return V >= B";

command >=(b1:bat[:oid,:wrd],b2:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatGE
comment "Return B1 >= B2";
pattern >=(b:bat[:oid,:wrd],v:flt) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return B >= V";
pattern >=(v:wrd,b:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return V >= B";

command >=(b1:bat[:oid,:wrd],b2:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatGE
comment "Return B1 >= B2";
pattern >=(b:bat[:oid,:wrd],v:dbl) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return B >= V";
pattern >=(v:wrd,b:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return V >= B";

command >=(b1:bat[:oid,:lng],b2:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatGE
comment "Return B1 >= B2";
pattern >=(b:bat[:oid,:lng],v:bte) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return B >= V";
pattern >=(v:lng,b:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return V >= B";

command >=(b1:bat[:oid,:lng],b2:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatGE
comment "Return B1 >= B2";
pattern >=(b:bat[:oid,:lng],v:sht) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return B >= V";
pattern >=(v:lng,b:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return V >= B";

command >=(b1:bat[:oid,:lng],b2:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatGE
comment "Return B1 >= B2";
pattern >=(b:bat[:oid,:lng],v:int) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return B >= V";
pattern >=(v:lng,b:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return V >= B";

command >=(b1:bat[:oid,:lng],b2:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatGE
comment "Return B1 >= B2";
pattern >=(b:bat[:oid,:lng],v:wrd) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return B >= V";
pattern >=(v:lng,b:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return V >= B";

command >=(b1:bat[:oid,:lng],b2:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatGE
comment "Return B1 >= B2";
pattern >=(b:bat[:oid,:lng],v:lng) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return B >= V";
pattern >=(v:lng,b:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return V >= B";

command >=(b1:bat[:oid,:lng],b2:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatGE
comment "Return B1 >= B2";
pattern >=(b:bat[:oid,:lng],v:flt) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return B >= V";
pattern >=(v:lng,b:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return V >= B";

command >=(b1:bat[:oid,:lng],b2:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatGE
comment "Return B1 >= B2";
pattern >=(b:bat[:oid,:lng],v:dbl) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return B >= V";
pattern >=(v:lng,b:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return V >= B";

command >=(b1:bat[:oid,:flt],b2:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatGE
comment "Return B1 >= B2";
pattern >=(b:bat[:oid,:flt],v:bte) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return B >= V";
pattern >=(v:flt,b:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return V >= B";

command >=(b1:bat[:oid,:flt],b2:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatGE
comment "Return B1 >= B2";
pattern >=(b:bat[:oid,:flt],v:sht) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return B >= V";
pattern >=(v:flt,b:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return V >= B";

command >=(b1:bat[:oid,:flt],b2:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatGE
comment "Return B1 >= B2";
pattern >=(b:bat[:oid,:flt],v:int) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return B >= V";
pattern >=(v:flt,b:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return V >= B";

command >=(b1:bat[:oid,:flt],b2:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatGE
comment "Return B1 >= B2";
pattern >=(b:bat[:oid,:flt],v:wrd) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return B >= V";
pattern >=(v:flt,b:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return V >= B";

command >=(b1:bat[:oid,:flt],b2:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatGE
comment "Return B1 >= B2";
pattern >=(b:bat[:oid,:flt],v:lng) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return B >= V";
pattern >=(v:flt,b:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return V >= B";

command >=(b1:bat[:oid,:flt],b2:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatGE
comment "Return B1 >= B2";
pattern >=(b:bat[:oid,:flt],v:flt) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return B >= V";
pattern >=(v:flt,b:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return V >= B";

command >=(b1:bat[:oid,:flt],b2:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatGE
comment "Return B1 >= B2";
pattern >=(b:bat[:oid,:flt],v:dbl) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return B >= V";
pattern >=(v:flt,b:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return V >= B";

command >=(b1:bat[:oid,:dbl],b2:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatGE
comment "Return B1 >= B2";
pattern >=(b:bat[:oid,:dbl],v:bte) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return B >= V";
pattern >=(v:dbl,b:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return V >= B";

command >=(b1:bat[:oid,:dbl],b2:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatGE
comment "Return B1 >= B2";
pattern >=(b:bat[:oid,:dbl],v:sht) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return B >= V";
pattern >=(v:dbl,b:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return V >= B";

command >=(b1:bat[:oid,:dbl],b2:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatGE
comment "Return B1 >= B2";
pattern >=(b:bat[:oid,:dbl],v:int) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return B >= V";
pattern >=(v:dbl,b:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return V >= B";

command >=(b1:bat[:oid,:dbl],b2:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatGE
comment "Return B1 >= B2";
pattern >=(b:bat[:oid,:dbl],v:wrd) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return B >= V";
pattern >=(v:dbl,b:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return V >= B";

command >=(b1:bat[:oid,:dbl],b2:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatGE
comment "Return B1 >= B2";
pattern >=(b:bat[:oid,:dbl],v:lng) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return B >= V";
pattern >=(v:dbl,b:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return V >= B";

command >=(b1:bat[:oid,:dbl],b2:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatGE
comment "Return B1 >= B2";
pattern >=(b:bat[:oid,:dbl],v:flt) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return B >= V";
pattern >=(v:dbl,b:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return V >= B";

command >=(b1:bat[:oid,:dbl],b2:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatGE
comment "Return B1 >= B2";
pattern >=(b:bat[:oid,:dbl],v:dbl) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return B >= V";
pattern >=(v:dbl,b:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatGEcst
comment "Return V >= B";


command ==(b1:bat[:oid,:bit],b2:bat[:oid,:bit]) :bat[:oid,:bit]
address CMDbatEQ
comment "Return B1 == B2";
pattern ==(b:bat[:oid,:bit],v:bit) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return B == V";
pattern ==(v:bit,b:bat[:oid,:bit]) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return V == B";

command ==(b1:bat[:oid,:str],b2:bat[:oid,:str]) :bat[:oid,:bit]
address CMDbatEQ
comment "Return B1 == B2";
pattern ==(b:bat[:oid,:str],v:str) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return B == V";
pattern ==(v:str,b:bat[:oid,:str]) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return V == B";

command ==(b1:bat[:oid,:oid],b2:bat[:oid,:oid]) :bat[:oid,:bit]
address CMDbatEQ
comment "Return B1 == B2";
pattern ==(b:bat[:oid,:oid],v:oid) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return B == V";
pattern ==(v:oid,b:bat[:oid,:oid]) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return V == B";

command ==(b1:bat[:oid,:bte],b2:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatEQ
comment "Return B1 == B2";
pattern ==(b:bat[:oid,:bte],v:bte) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return B == V";
pattern ==(v:bte,b:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return V == B";

command ==(b1:bat[:oid,:bte],b2:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatEQ
comment "Return B1 == B2";
pattern ==(b:bat[:oid,:bte],v:sht) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return B == V";
pattern ==(v:bte,b:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return V == B";

command ==(b1:bat[:oid,:bte],b2:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatEQ
comment "Return B1 == B2";
pattern ==(b:bat[:oid,:bte],v:int) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return B == V";
pattern ==(v:bte,b:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return V == B";

command ==(b1:bat[:oid,:bte],b2:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatEQ
comment "Return B1 == B2";
pattern ==(b:bat[:oid,:bte],v:wrd) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return B == V";
pattern ==(v:bte,b:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return V == B";

command ==(b1:bat[:oid,:bte],b2:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatEQ
comment "Return B1 == B2";
pattern ==(b:bat[:oid,:bte],v:lng) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return B == V";
pattern ==(v:bte,b:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return V == B";

command ==(b1:bat[:oid,:bte],b2:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatEQ
comment "Return B1 == B2";
pattern ==(b:bat[:oid,:bte],v:flt) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return B == V";
pattern ==(v:bte,b:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return V == B";

command ==(b1:bat[:oid,:bte],b2:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatEQ
comment "Return B1 == B2";
pattern ==(b:bat[:oid,:bte],v:dbl) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return B == V";
pattern ==(v:bte,b:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return V == B";

command ==(b1:bat[:oid,:sht],b2:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatEQ
comment "Return B1 == B2";
pattern ==(b:bat[:oid,:sht],v:bte) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return B == V";
pattern ==(v:sht,b:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return V == B";

command ==(b1:bat[:oid,:sht],b2:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatEQ
comment "Return B1 == B2";
pattern ==(b:bat[:oid,:sht],v:sht) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return B == V";
pattern ==(v:sht,b:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return V == B";

command ==(b1:bat[:oid,:sht],b2:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatEQ
comment "Return B1 == B2";
pattern ==(b:bat[:oid,:sht],v:int) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return B == V";
pattern ==(v:sht,b:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return V == B";

command ==(b1:bat[:oid,:sht],b2:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatEQ
comment "Return B1 == B2";
pattern ==(b:bat[:oid,:sht],v:wrd) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return B == V";
pattern ==(v:sht,b:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return V == B";

command ==(b1:bat[:oid,:sht],b2:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatEQ
comment "Return B1 == B2";
pattern ==(b:bat[:oid,:sht],v:lng) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return B == V";
pattern ==(v:sht,b:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return V == B";

command ==(b1:bat[:oid,:sht],b2:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatEQ
comment "Return B1 == B2";
pattern ==(b:bat[:oid,:sht],v:flt) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return B == V";
pattern ==(v:sht,b:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return V == B";

command ==(b1:bat[:oid,:sht],b2:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatEQ
comment "Return B1 == B2";
pattern ==(b:bat[:oid,:sht],v:dbl) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return B == V";
pattern ==(v:sht,b:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return V == B";

command ==(b1:bat[:oid,:int],b2:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatEQ
comment "Return B1 == B2";
pattern ==(b:bat[:oid,:int],v:bte) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return B == V";
pattern ==(v:int,b:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return V == B";

command ==(b1:bat[:oid,:int],b2:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatEQ
comment "Return B1 == B2";
pattern ==(b:bat[:oid,:int],v:sht) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return B == V";
pattern ==(v:int,b:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return V == B";

command ==(b1:bat[:oid,:int],b2:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatEQ
comment "Return B1 == B2";
pattern ==(b:bat[:oid,:int],v:int) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return B == V";
pattern ==(v:int,b:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return V == B";

command ==(b1:bat[:oid,:int],b2:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatEQ
comment "Return B1 == B2";
pattern ==(b:bat[:oid,:int],v:wrd) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return B == V";
pattern ==(v:int,b:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return V == B";

command ==(b1:bat[:oid,:int],b2:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatEQ
comment "Return B1 == B2";
pattern ==(b:bat[:oid,:int],v:lng) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return B == V";
pattern ==(v:int,b:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return V == B";

command ==(b1:bat[:oid,:int],b2:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatEQ
comment "Return B1 == B2";
pattern ==(b:bat[:oid,:int],v:flt) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return B == V";
pattern ==(v:int,b:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return V == B";

command ==(b1:bat[:oid,:int],b2:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatEQ
comment "Return B1 == B2";
pattern ==(b:bat[:oid,:int],v:dbl) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return B == V";
pattern ==(v:int,b:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return V == B";

command ==(b1:bat[:oid,:wrd],b2:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatEQ
comment "Return B1 == B2";
pattern ==(b:bat[:oid,:wrd],v:bte) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return B == V";
pattern ==(v:wrd,b:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return V == B";

command ==(b1:bat[:oid,:wrd],b2:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatEQ
comment "Return B1 == B2";
pattern ==(b:bat[:oid,:wrd],v:sht) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return B == V";
pattern ==(v:wrd,b:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return V == B";

command ==(b1:bat[:oid,:wrd],b2:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatEQ
comment "Return B1 == B2";
pattern ==(b:bat[:oid,:wrd],v:int) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return B == V";
pattern ==(v:wrd,b:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return V == B";

command ==(b1:bat[:oid,:wrd],b2:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatEQ
comment "Return B1 == B2";
pattern ==(b:bat[:oid,:wrd],v:wrd) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return B == V";
pattern ==(v:wrd,b:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return V == B";

command ==(b1:bat[:oid,:wrd],b2:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatEQ
comment "Return B1 == B2";
pattern ==(b:bat[:oid,:wrd],v:lng) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return B == V";
pattern ==(v:wrd,b:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return V == B";

command ==(b1:bat[:oid,:wrd],b2:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatEQ
comment "Return B1 == B2";
pattern ==(b:bat[:oid,:wrd],v:flt) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return B == V";
pattern ==(v:wrd,b:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return V == B";

command ==(b1:bat[:oid,:wrd],b2:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatEQ
comment "Return B1 == B2";
pattern ==(b:bat[:oid,:wrd],v:dbl) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return B == V";
pattern ==(v:wrd,b:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return V == B";

command ==(b1:bat[:oid,:lng],b2:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatEQ
comment "Return B1 == B2";
pattern ==(b:bat[:oid,:lng],v:bte) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return B == V";
pattern ==(v:lng,b:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return V == B";

command ==(b1:bat[:oid,:lng],b2:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatEQ
comment "Return B1 == B2";
pattern ==(b:bat[:oid,:lng],v:sht) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return B == V";
pattern ==(v:lng,b:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return V == B";

command ==(b1:bat[:oid,:lng],b2:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatEQ
comment "Return B1 == B2";
pattern ==(b:bat[:oid,:lng],v:int) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return B == V";
pattern ==(v:lng,b:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return V == B";

command ==(b1:bat[:oid,:lng],b2:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatEQ
comment "Return B1 == B2";
pattern ==(b:bat[:oid,:lng],v:wrd) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return B == V";
pattern ==(v:lng,b:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return V == B";

command ==(b1:bat[:oid,:lng],b2:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatEQ
comment "Return B1 == B2";
pattern ==(b:bat[:oid,:lng],v:lng) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return B == V";
pattern ==(v:lng,b:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return V == B";

command ==(b1:bat[:oid,:lng],b2:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatEQ
comment "Return B1 == B2";
pattern ==(b:bat[:oid,:lng],v:flt) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return B == V";
pattern ==(v:lng,b:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return V == B";

command ==(b1:bat[:oid,:lng],b2:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatEQ
comment "Return B1 == B2";
pattern ==(b:bat[:oid,:lng],v:dbl) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return B == V";
pattern ==(v:lng,b:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return V == B";

command ==(b1:bat[:oid,:flt],b2:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatEQ
comment "Return B1 == B2";
pattern ==(b:bat[:oid,:flt],v:bte) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return B == V";
pattern ==(v:flt,b:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return V == B";

command ==(b1:bat[:oid,:flt],b2:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatEQ
comment "Return B1 == B2";
pattern ==(b:bat[:oid,:flt],v:sht) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return B == V";
pattern ==(v:flt,b:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return V == B";

command ==(b1:bat[:oid,:flt],b2:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatEQ
comment "Return B1 == B2";
pattern ==(b:bat[:oid,:flt],v:int) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return B == V";
pattern ==(v:flt,b:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return V == B";

command ==(b1:bat[:oid,:flt],b2:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatEQ
comment "Return B1 == B2";
pattern ==(b:bat[:oid,:flt],v:wrd) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return B == V";
pattern ==(v:flt,b:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return V == B";

command ==(b1:bat[:oid,:flt],b2:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatEQ
comment "Return B1 == B2";
pattern ==(b:bat[:oid,:flt],v:lng) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return B == V";
pattern ==(v:flt,b:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return V == B";

command ==(b1:bat[:oid,:flt],b2:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatEQ
comment "Return B1 == B2";
pattern ==(b:bat[:oid,:flt],v:flt) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return B == V";
pattern ==(v:flt,b:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return V == B";

command ==(b1:bat[:oid,:flt],b2:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatEQ
comment "Return B1 == B2";
pattern ==(b:bat[:oid,:flt],v:dbl) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return B == V";
pattern ==(v:flt,b:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return V == B";

command ==(b1:bat[:oid,:dbl],b2:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatEQ
comment "Return B1 == B2";
pattern ==(b:bat[:oid,:dbl],v:bte) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return B == V";
pattern ==(v:dbl,b:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return V == B";

command ==(b1:bat[:oid,:dbl],b2:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatEQ
comment "Return B1 == B2";
pattern ==(b:bat[:oid,:dbl],v:sht) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return B == V";
pattern ==(v:dbl,b:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return V == B";

command ==(b1:bat[:oid,:dbl],b2:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatEQ
comment "Return B1 == B2";
pattern ==(b:bat[:oid,:dbl],v:int) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return B == V";
pattern ==(v:dbl,b:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return V == B";

command ==(b1:bat[:oid,:dbl],b2:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatEQ
comment "Return B1 == B2";
pattern ==(b:bat[:oid,:dbl],v:wrd) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return B == V";
pattern ==(v:dbl,b:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return V == B";

command ==(b1:bat[:oid,:dbl],b2:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatEQ
comment "Return B1 == B2";
pattern ==(b:bat[:oid,:dbl],v:lng) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return B == V";
pattern ==(v:dbl,b:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return V == B";

command ==(b1:bat[:oid,:dbl],b2:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatEQ
comment "Return B1 == B2";
pattern ==(b:bat[:oid,:dbl],v:flt) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return B == V";
pattern ==(v:dbl,b:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return V == B";

command ==(b1:bat[:oid,:dbl],b2:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatEQ
comment "Return B1 == B2";
pattern ==(b:bat[:oid,:dbl],v:dbl) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return B == V";
pattern ==(v:dbl,b:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatEQcst
comment "Return V == B";


command !=(b1:bat[:oid,:bit],b2:bat[:oid,:bit]) :bat[:oid,:bit]
address CMDbatNE
comment "Return B1 != B2";
pattern !=(b:bat[:oid,:bit],v:bit) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return B != V";
pattern !=(v:bit,b:bat[:oid,:bit]) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return V != B";

command !=(b1:bat[:oid,:str],b2:bat[:oid,:str]) :bat[:oid,:bit]
address CMDbatNE
comment "Return B1 != B2";
pattern !=(b:bat[:oid,:str],v:str) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return B != V";
pattern !=(v:str,b:bat[:oid,:str]) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return V != B";

command !=(b1:bat[:oid,:oid],b2:bat[:oid,:oid]) :bat[:oid,:bit]
address CMDbatNE
comment "Return B1 != B2";
pattern !=(b:bat[:oid,:oid],v:oid) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return B != V";
pattern !=(v:oid,b:bat[:oid,:oid]) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return V != B";

command !=(b1:bat[:oid,:bte],b2:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatNE
comment "Return B1 != B2";
pattern !=(b:bat[:oid,:bte],v:bte) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return B != V";
pattern !=(v:bte,b:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return V != B";

command !=(b1:bat[:oid,:bte],b2:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatNE
comment "Return B1 != B2";
pattern !=(b:bat[:oid,:bte],v:sht) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return B != V";
pattern !=(v:bte,b:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return V != B";

command !=(b1:bat[:oid,:bte],b2:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatNE
comment "Return B1 != B2";
pattern !=(b:bat[:oid,:bte],v:int) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return B != V";
pattern !=(v:bte,b:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return V != B";

command !=(b1:bat[:oid,:bte],b2:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatNE
comment "Return B1 != B2";
pattern !=(b:bat[:oid,:bte],v:wrd) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return B != V";
pattern !=(v:bte,b:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return V != B";

command !=(b1:bat[:oid,:bte],b2:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatNE
comment "Return B1 != B2";
pattern !=(b:bat[:oid,:bte],v:lng) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return B != V";
pattern !=(v:bte,b:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return V != B";

command !=(b1:bat[:oid,:bte],b2:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatNE
comment "Return B1 != B2";
pattern !=(b:bat[:oid,:bte],v:flt) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return B != V";
pattern !=(v:bte,b:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return V != B";

command !=(b1:bat[:oid,:bte],b2:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatNE
comment "Return B1 != B2";
pattern !=(b:bat[:oid,:bte],v:dbl) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return B != V";
pattern !=(v:bte,b:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return V != B";

command !=(b1:bat[:oid,:sht],b2:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatNE
comment "Return B1 != B2";
pattern !=(b:bat[:oid,:sht],v:bte) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return B != V";
pattern !=(v:sht,b:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return V != B";

command !=(b1:bat[:oid,:sht],b2:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatNE
comment "Return B1 != B2";
pattern !=(b:bat[:oid,:sht],v:sht) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return B != V";
pattern !=(v:sht,b:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return V != B";

command !=(b1:bat[:oid,:sht],b2:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatNE
comment "Return B1 != B2";
pattern !=(b:bat[:oid,:sht],v:int) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return B != V";
pattern !=(v:sht,b:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return V != B";

command !=(b1:bat[:oid,:sht],b2:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatNE
comment "Return B1 != B2";
pattern !=(b:bat[:oid,:sht],v:wrd) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return B != V";
pattern !=(v:sht,b:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return V != B";

command !=(b1:bat[:oid,:sht],b2:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatNE
comment "Return B1 != B2";
pattern !=(b:bat[:oid,:sht],v:lng) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return B != V";
pattern !=(v:sht,b:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return V != B";

command !=(b1:bat[:oid,:sht],b2:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatNE
comment "Return B1 != B2";
pattern !=(b:bat[:oid,:sht],v:flt) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return B != V";
pattern !=(v:sht,b:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return V != B";

command !=(b1:bat[:oid,:sht],b2:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatNE
comment "Return B1 != B2";
pattern !=(b:bat[:oid,:sht],v:dbl) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return B != V";
pattern !=(v:sht,b:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return V != B";

command !=(b1:bat[:oid,:int],b2:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatNE
comment "Return B1 != B2";
pattern !=(b:bat[:oid,:int],v:bte) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return B != V";
pattern !=(v:int,b:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return V != B";

command !=(b1:bat[:oid,:int],b2:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatNE
comment "Return B1 != B2";
pattern !=(b:bat[:oid,:int],v:sht) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return B != V";
pattern !=(v:int,b:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return V != B";

command !=(b1:bat[:oid,:int],b2:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatNE
comment "Return B1 != B2";
pattern !=(b:bat[:oid,:int],v:int) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return B != V";
pattern !=(v:int,b:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return V != B";

command !=(b1:bat[:oid,:int],b2:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatNE
comment "Return B1 != B2";
pattern !=(b:bat[:oid,:int],v:wrd) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return B != V";
pattern !=(v:int,b:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return V != B";

command !=(b1:bat[:oid,:int],b2:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatNE
comment "Return B1 != B2";
pattern !=(b:bat[:oid,:int],v:lng) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return B != V";
pattern !=(v:int,b:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return V != B";

command !=(b1:bat[:oid,:int],b2:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatNE
comment "Return B1 != B2";
pattern !=(b:bat[:oid,:int],v:flt) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return B != V";
pattern !=(v:int,b:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return V != B";

command !=(b1:bat[:oid,:int],b2:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatNE
comment "Return B1 != B2";
pattern !=(b:bat[:oid,:int],v:dbl) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return B != V";
pattern !=(v:int,b:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return V != B";

command !=(b1:bat[:oid,:wrd],b2:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatNE
comment "Return B1 != B2";
pattern !=(b:bat[:oid,:wrd],v:bte) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return B != V";
pattern !=(v:wrd,b:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return V != B";

command !=(b1:bat[:oid,:wrd],b2:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatNE
comment "Return B1 != B2";
pattern !=(b:bat[:oid,:wrd],v:sht) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return B != V";
pattern !=(v:wrd,b:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return V != B";

command !=(b1:bat[:oid,:wrd],b2:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatNE
comment "Return B1 != B2";
pattern !=(b:bat[:oid,:wrd],v:int) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return B != V";
pattern !=(v:wrd,b:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return V != B";

command !=(b1:bat[:oid,:wrd],b2:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatNE
comment "Return B1 != B2";
pattern !=(b:bat[:oid,:wrd],v:wrd) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return B != V";
pattern !=(v:wrd,b:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return V != B";

command !=(b1:bat[:oid,:wrd],b2:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatNE
comment "Return B1 != B2";
pattern !=(b:bat[:oid,:wrd],v:lng) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return B != V";
pattern !=(v:wrd,b:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return V != B";

command !=(b1:bat[:oid,:wrd],b2:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatNE
comment "Return B1 != B2";
pattern !=(b:bat[:oid,:wrd],v:flt) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return B != V";
pattern !=(v:wrd,b:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return V != B";

command !=(b1:bat[:oid,:wrd],b2:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatNE
comment "Return B1 != B2";
pattern !=(b:bat[:oid,:wrd],v:dbl) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return B != V";
pattern !=(v:wrd,b:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return V != B";

command !=(b1:bat[:oid,:lng],b2:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatNE
comment "Return B1 != B2";
pattern !=(b:bat[:oid,:lng],v:bte) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return B != V";
pattern !=(v:lng,b:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return V != B";

command !=(b1:bat[:oid,:lng],b2:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatNE
comment "Return B1 != B2";
pattern !=(b:bat[:oid,:lng],v:sht) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return B != V";
pattern !=(v:lng,b:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return V != B";

command !=(b1:bat[:oid,:lng],b2:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatNE
comment "Return B1 != B2";
pattern !=(b:bat[:oid,:lng],v:int) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return B != V";
pattern !=(v:lng,b:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return V != B";

command !=(b1:bat[:oid,:lng],b2:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatNE
comment "Return B1 != B2";
pattern !=(b:bat[:oid,:lng],v:wrd) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return B != V";
pattern !=(v:lng,b:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return V != B";

command !=(b1:bat[:oid,:lng],b2:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatNE
comment "Return B1 != B2";
pattern !=(b:bat[:oid,:lng],v:lng) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return B != V";
pattern !=(v:lng,b:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return V != B";

command !=(b1:bat[:oid,:lng],b2:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatNE
comment "Return B1 != B2";
pattern !=(b:bat[:oid,:lng],v:flt) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return B != V";
pattern !=(v:lng,b:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return V != B";

command !=(b1:bat[:oid,:lng],b2:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatNE
comment "Return B1 != B2";
pattern !=(b:bat[:oid,:lng],v:dbl) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return B != V";
pattern !=(v:lng,b:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return V != B";

command !=(b1:bat[:oid,:flt],b2:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatNE
comment "Return B1 != B2";
pattern !=(b:bat[:oid,:flt],v:bte) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return B != V";
pattern !=(v:flt,b:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return V != B";

command !=(b1:bat[:oid,:flt],b2:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatNE
comment "Return B1 != B2";
pattern !=(b:bat[:oid,:flt],v:sht) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return B != V";
pattern !=(v:flt,b:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return V != B";

command !=(b1:bat[:oid,:flt],b2:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatNE
comment "Return B1 != B2";
pattern !=(b:bat[:oid,:flt],v:int) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return B != V";
pattern !=(v:flt,b:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return V != B";

command !=(b1:bat[:oid,:flt],b2:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatNE
comment "Return B1 != B2";
pattern !=(b:bat[:oid,:flt],v:wrd) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return B != V";
pattern !=(v:flt,b:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return V != B";

command !=(b1:bat[:oid,:flt],b2:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatNE
comment "Return B1 != B2";
pattern !=(b:bat[:oid,:flt],v:lng) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return B != V";
pattern !=(v:flt,b:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return V != B";

command !=(b1:bat[:oid,:flt],b2:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatNE
comment "Return B1 != B2";
pattern !=(b:bat[:oid,:flt],v:flt) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return B != V";
pattern !=(v:flt,b:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return V != B";

command !=(b1:bat[:oid,:flt],b2:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatNE
comment "Return B1 != B2";
pattern !=(b:bat[:oid,:flt],v:dbl) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return B != V";
pattern !=(v:flt,b:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return V != B";

command !=(b1:bat[:oid,:dbl],b2:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatNE
comment "Return B1 != B2";
pattern !=(b:bat[:oid,:dbl],v:bte) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return B != V";
pattern !=(v:dbl,b:bat[:oid,:bte]) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return V != B";

command !=(b1:bat[:oid,:dbl],b2:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatNE
comment "Return B1 != B2";
pattern !=(b:bat[:oid,:dbl],v:sht) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return B != V";
pattern !=(v:dbl,b:bat[:oid,:sht]) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return V != B";

command !=(b1:bat[:oid,:dbl],b2:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatNE
comment "Return B1 != B2";
pattern !=(b:bat[:oid,:dbl],v:int) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return B != V";
pattern !=(v:dbl,b:bat[:oid,:int]) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return V != B";

command !=(b1:bat[:oid,:dbl],b2:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatNE
comment "Return B1 != B2";
pattern !=(b:bat[:oid,:dbl],v:wrd) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return B != V";
pattern !=(v:dbl,b:bat[:oid,:wrd]) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return V != B";

command !=(b1:bat[:oid,:dbl],b2:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatNE
comment "Return B1 != B2";
pattern !=(b:bat[:oid,:dbl],v:lng) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return B != V";
pattern !=(v:dbl,b:bat[:oid,:lng]) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return V != B";

command !=(b1:bat[:oid,:dbl],b2:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatNE
comment "Return B1 != B2";
pattern !=(b:bat[:oid,:dbl],v:flt) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return B != V";
pattern !=(v:dbl,b:bat[:oid,:flt]) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return V != B";

command !=(b1:bat[:oid,:dbl],b2:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatNE
comment "Return B1 != B2";
pattern !=(b:bat[:oid,:dbl],v:dbl) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return B != V";
pattern !=(v:dbl,b:bat[:oid,:dbl]) :bat[:oid,:bit]
address CMDbatNEcst
comment "Return V != B";


command cmp(b1:bat[:oid,:bit],b2:bat[:oid,:bit]) :bat[:oid,:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2";
pattern cmp(b:bat[:oid,:bit],v:bit) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if B </==/> V";
pattern cmp(v:bit,b:bat[:oid,:bit]) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if V </==/> B";

command cmp(b1:bat[:oid,:str],b2:bat[:oid,:str]) :bat[:oid,:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2";
pattern cmp(b:bat[:oid,:str],v:str) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if B </==/> V";
pattern cmp(v:str,b:bat[:oid,:str]) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if V </==/> B";

command cmp(b1:bat[:oid,:oid],b2:bat[:oid,:oid]) :bat[:oid,:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2";
pattern cmp(b:bat[:oid,:oid],v:oid) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if B </==/> V";
pattern cmp(v:oid,b:bat[:oid,:oid]) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if V </==/> B";

command cmp(b1:bat[:oid,:bte],b2:bat[:oid,:bte]) :bat[:oid,:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2";
pattern cmp(b:bat[:oid,:bte],v:bte) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if B </==/> V";
pattern cmp(v:bte,b:bat[:oid,:bte]) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if V </==/> B";

command cmp(b1:bat[:oid,:bte],b2:bat[:oid,:sht]) :bat[:oid,:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2";
pattern cmp(b:bat[:oid,:bte],v:sht) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if B </==/> V";
pattern cmp(v:bte,b:bat[:oid,:sht]) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if V </==/> B";

command cmp(b1:bat[:oid,:bte],b2:bat[:oid,:int]) :bat[:oid,:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2";
pattern cmp(b:bat[:oid,:bte],v:int) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if B </==/> V";
pattern cmp(v:bte,b:bat[:oid,:int]) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if V </==/> B";

command cmp(b1:bat[:oid,:bte],b2:bat[:oid,:wrd]) :bat[:oid,:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2";
pattern cmp(b:bat[:oid,:bte],v:wrd) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if B </==/> V";
pattern cmp(v:bte,b:bat[:oid,:wrd]) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if V </==/> B";

command cmp(b1:bat[:oid,:bte],b2:bat[:oid,:lng]) :bat[:oid,:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2";
pattern cmp(b:bat[:oid,:bte],v:lng) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if B </==/> V";
pattern cmp(v:bte,b:bat[:oid,:lng]) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if V </==/> B";

command cmp(b1:bat[:oid,:bte],b2:bat[:oid,:flt]) :bat[:oid,:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2";
pattern cmp(b:bat[:oid,:bte],v:flt) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if B </==/> V";
pattern cmp(v:bte,b:bat[:oid,:flt]) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if V </==/> B";

command cmp(b1:bat[:oid,:bte],b2:bat[:oid,:dbl]) :bat[:oid,:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2";
pattern cmp(b:bat[:oid,:bte],v:dbl) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if B </==/> V";
pattern cmp(v:bte,b:bat[:oid,:dbl]) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if V </==/> B";

command cmp(b1:bat[:oid,:sht],b2:bat[:oid,:bte]) :bat[:oid,:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2";
pattern cmp(b:bat[:oid,:sht],v:bte) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if B </==/> V";
pattern cmp(v:sht,b:bat[:oid,:bte]) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if V </==/> B";

command cmp(b1:bat[:oid,:sht],b2:bat[:oid,:sht]) :bat[:oid,:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2";
pattern cmp(b:bat[:oid,:sht],v:sht) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if B </==/> V";
pattern cmp(v:sht,b:bat[:oid,:sht]) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if V </==/> B";

command cmp(b1:bat[:oid,:sht],b2:bat[:oid,:int]) :bat[:oid,:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2";
pattern cmp(b:bat[:oid,:sht],v:int) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if B </==/> V";
pattern cmp(v:sht,b:bat[:oid,:int]) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if V </==/> B";

command cmp(b1:bat[:oid,:sht],b2:bat[:oid,:wrd]) :bat[:oid,:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2";
pattern cmp(b:bat[:oid,:sht],v:wrd) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if B </==/> V";
pattern cmp(v:sht,b:bat[:oid,:wrd]) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if V </==/> B";

command cmp(b1:bat[:oid,:sht],b2:bat[:oid,:lng]) :bat[:oid,:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2";
pattern cmp(b:bat[:oid,:sht],v:lng) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if B </==/> V";
pattern cmp(v:sht,b:bat[:oid,:lng]) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if V </==/> B";

command cmp(b1:bat[:oid,:sht],b2:bat[:oid,:flt]) :bat[:oid,:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2";
pattern cmp(b:bat[:oid,:sht],v:flt) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if B </==/> V";
pattern cmp(v:sht,b:bat[:oid,:flt]) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if V </==/> B";

command cmp(b1:bat[:oid,:sht],b2:bat[:oid,:dbl]) :bat[:oid,:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2";
pattern cmp(b:bat[:oid,:sht],v:dbl) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if B </==/> V";
pattern cmp(v:sht,b:bat[:oid,:dbl]) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if V </==/> B";

command cmp(b1:bat[:oid,:int],b2:bat[:oid,:bte]) :bat[:oid,:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2";
pattern cmp(b:bat[:oid,:int],v:bte) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if B </==/> V";
pattern cmp(v:int,b:bat[:oid,:bte]) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if V </==/> B";

command cmp(b1:bat[:oid,:int],b2:bat[:oid,:sht]) :bat[:oid,:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2";
pattern cmp(b:bat[:oid,:int],v:sht) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if B </==/> V";
pattern cmp(v:int,b:bat[:oid,:sht]) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if V </==/> B";

command cmp(b1:bat[:oid,:int],b2:bat[:oid,:int]) :bat[:oid,:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2";
pattern cmp(b:bat[:oid,:int],v:int) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if B </==/> V";
pattern cmp(v:int,b:bat[:oid,:int]) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if V </==/> B";

command cmp(b1:bat[:oid,:int],b2:bat[:oid,:wrd]) :bat[:oid,:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2";
pattern cmp(b:bat[:oid,:int],v:wrd) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if B </==/> V";
pattern cmp(v:int,b:bat[:oid,:wrd]) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if V </==/> B";

command cmp(b1:bat[:oid,:int],b2:bat[:oid,:lng]) :bat[:oid,:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2";
pattern cmp(b:bat[:oid,:int],v:lng) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if B </==/> V";
pattern cmp(v:int,b:bat[:oid,:lng]) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if V </==/> B";

command cmp(b1:bat[:oid,:int],b2:bat[:oid,:flt]) :bat[:oid,:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2";
pattern cmp(b:bat[:oid,:int],v:flt) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if B </==/> V";
pattern cmp(v:int,b:bat[:oid,:flt]) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if V </==/> B";

command cmp(b1:bat[:oid,:int],b2:bat[:oid,:dbl]) :bat[:oid,:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2";
pattern cmp(b:bat[:oid,:int],v:dbl) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if B </==/> V";
pattern cmp(v:int,b:bat[:oid,:dbl]) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if V </==/> B";

command cmp(b1:bat[:oid,:wrd],b2:bat[:oid,:bte]) :bat[:oid,:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2";
pattern cmp(b:bat[:oid,:wrd],v:bte) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if B </==/> V";
pattern cmp(v:wrd,b:bat[:oid,:bte]) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if V </==/> B";

command cmp(b1:bat[:oid,:wrd],b2:bat[:oid,:sht]) :bat[:oid,:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2";
pattern cmp(b:bat[:oid,:wrd],v:sht) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if B </==/> V";
pattern cmp(v:wrd,b:bat[:oid,:sht]) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if V </==/> B";

command cmp(b1:bat[:oid,:wrd],b2:bat[:oid,:int]) :bat[:oid,:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2";
pattern cmp(b:bat[:oid,:wrd],v:int) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if B </==/> V";
pattern cmp(v:wrd,b:bat[:oid,:int]) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if V </==/> B";

command cmp(b1:bat[:oid,:wrd],b2:bat[:oid,:wrd]) :bat[:oid,:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2";
pattern cmp(b:bat[:oid,:wrd],v:wrd) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if B </==/> V";
pattern cmp(v:wrd,b:bat[:oid,:wrd]) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if V </==/> B";

command cmp(b1:bat[:oid,:wrd],b2:bat[:oid,:lng]) :bat[:oid,:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2";
pattern cmp(b:bat[:oid,:wrd],v:lng) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if B </==/> V";
pattern cmp(v:wrd,b:bat[:oid,:lng]) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if V </==/> B";

command cmp(b1:bat[:oid,:wrd],b2:bat[:oid,:flt]) :bat[:oid,:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2";
pattern cmp(b:bat[:oid,:wrd],v:flt) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if B </==/> V";
pattern cmp(v:wrd,b:bat[:oid,:flt]) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if V </==/> B";

command cmp(b1:bat[:oid,:wrd],b2:bat[:oid,:dbl]) :bat[:oid,:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2";
pattern cmp(b:bat[:oid,:wrd],v:dbl) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if B </==/> V";
pattern cmp(v:wrd,b:bat[:oid,:dbl]) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if V </==/> B";

command cmp(b1:bat[:oid,:lng],b2:bat[:oid,:bte]) :bat[:oid,:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2";
pattern cmp(b:bat[:oid,:lng],v:bte) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if B </==/> V";
pattern cmp(v:lng,b:bat[:oid,:bte]) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if V </==/> B";

command cmp(b1:bat[:oid,:lng],b2:bat[:oid,:sht]) :bat[:oid,:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2";
pattern cmp(b:bat[:oid,:lng],v:sht) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if B </==/> V";
pattern cmp(v:lng,b:bat[:oid,:sht]) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if V </==/> B";

command cmp(b1:bat[:oid,:lng],b2:bat[:oid,:int]) :bat[:oid,:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2";
pattern cmp(b:bat[:oid,:lng],v:int) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if B </==/> V";
pattern cmp(v:lng,b:bat[:oid,:int]) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if V </==/> B";

command cmp(b1:bat[:oid,:lng],b2:bat[:oid,:wrd]) :bat[:oid,:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2";
pattern cmp(b:bat[:oid,:lng],v:wrd) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if B </==/> V";
pattern cmp(v:lng,b:bat[:oid,:wrd]) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if V </==/> B";

command cmp(b1:bat[:oid,:lng],b2:bat[:oid,:lng]) :bat[:oid,:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2";
pattern cmp(b:bat[:oid,:lng],v:lng) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if B </==/> V";
pattern cmp(v:lng,b:bat[:oid,:lng]) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if V </==/> B";

command cmp(b1:bat[:oid,:lng],b2:bat[:oid,:flt]) :bat[:oid,:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2";
pattern cmp(b:bat[:oid,:lng],v:flt) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if B </==/> V";
pattern cmp(v:lng,b:bat[:oid,:flt]) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if V </==/> B";

command cmp(b1:bat[:oid,:lng],b2:bat[:oid,:dbl]) :bat[:oid,:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2";
pattern cmp(b:bat[:oid,:lng],v:dbl) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if B </==/> V";
pattern cmp(v:lng,b:bat[:oid,:dbl]) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if V </==/> B";

command cmp(b1:bat[:oid,:flt],b2:bat[:oid,:bte]) :bat[:oid,:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2";
pattern cmp(b:bat[:oid,:flt],v:bte) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if B </==/> V";
pattern cmp(v:flt,b:bat[:oid,:bte]) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if V </==/> B";

command cmp(b1:bat[:oid,:flt],b2:bat[:oid,:sht]) :bat[:oid,:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2";
pattern cmp(b:bat[:oid,:flt],v:sht) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if B </==/> V";
pattern cmp(v:flt,b:bat[:oid,:sht]) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if V </==/> B";

command cmp(b1:bat[:oid,:flt],b2:bat[:oid,:int]) :bat[:oid,:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2";
pattern cmp(b:bat[:oid,:flt],v:int) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if B </==/> V";
pattern cmp(v:flt,b:bat[:oid,:int]) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if V </==/> B";

command cmp(b1:bat[:oid,:flt],b2:bat[:oid,:wrd]) :bat[:oid,:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2";
pattern cmp(b:bat[:oid,:flt],v:wrd) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if B </==/> V";
pattern cmp(v:flt,b:bat[:oid,:wrd]) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if V </==/> B";

command cmp(b1:bat[:oid,:flt],b2:bat[:oid,:lng]) :bat[:oid,:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2";
pattern cmp(b:bat[:oid,:flt],v:lng) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if B </==/> V";
pattern cmp(v:flt,b:bat[:oid,:lng]) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if V </==/> B";

command cmp(b1:bat[:oid,:flt],b2:bat[:oid,:flt]) :bat[:oid,:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2";
pattern cmp(b:bat[:oid,:flt],v:flt) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if B </==/> V";
pattern cmp(v:flt,b:bat[:oid,:flt]) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if V </==/> B";

command cmp(b1:bat[:oid,:flt],b2:bat[:oid,:dbl]) :bat[:oid,:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2";
pattern cmp(b:bat[:oid,:flt],v:dbl) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if B </==/> V";
pattern cmp(v:flt,b:bat[:oid,:dbl]) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if V </==/> B";

command cmp(b1:bat[:oid,:dbl],b2:bat[:oid,:bte]) :bat[:oid,:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2";
pattern cmp(b:bat[:oid,:dbl],v:bte) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if B </==/> V";
pattern cmp(v:dbl,b:bat[:oid,:bte]) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if V </==/> B";

command cmp(b1:bat[:oid,:dbl],b2:bat[:oid,:sht]) :bat[:oid,:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2";
pattern cmp(b:bat[:oid,:dbl],v:sht) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if B </==/> V";
pattern cmp(v:dbl,b:bat[:oid,:sht]) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if V </==/> B";

command cmp(b1:bat[:oid,:dbl],b2:bat[:oid,:int]) :bat[:oid,:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2";
pattern cmp(b:bat[:oid,:dbl],v:int) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if B </==/> V";
pattern cmp(v:dbl,b:bat[:oid,:int]) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if V </==/> B";

command cmp(b1:bat[:oid,:dbl],b2:bat[:oid,:wrd]) :bat[:oid,:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2";
pattern cmp(b:bat[:oid,:dbl],v:wrd) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if B </==/> V";
pattern cmp(v:dbl,b:bat[:oid,:wrd]) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if V </==/> B";

command cmp(b1:bat[:oid,:dbl],b2:bat[:oid,:lng]) :bat[:oid,:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2";
pattern cmp(b:bat[:oid,:dbl],v:lng) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if B </==/> V";
pattern cmp(v:dbl,b:bat[:oid,:lng]) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if V </==/> B";

command cmp(b1:bat[:oid,:dbl],b2:bat[:oid,:flt]) :bat[:oid,:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2";
pattern cmp(b:bat[:oid,:dbl],v:flt) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if B </==/> V";
pattern cmp(v:dbl,b:bat[:oid,:flt]) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if V </==/> B";

command cmp(b1:bat[:oid,:dbl],b2:bat[:oid,:dbl]) :bat[:oid,:bte]
address CMDbatCMP
comment "Return -1/0/1 if B1 </==/> B2";
pattern cmp(b:bat[:oid,:dbl],v:dbl) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if B </==/> V";
pattern cmp(v:dbl,b:bat[:oid,:dbl]) :bat[:oid,:bte]
address CMDbatCMPcst
comment "Return -1/0/1 if V </==/> B";


pattern between(b:bat[:oid,:bit],lo:bat[:oid,:bit],hi:bat[:oid,:bit]) :bit
address CMDbatBETWEEN
comment "B between LO and HI inclusive, nil border is (minus) infinity";
pattern between(b:bat[:oid,:bit],lo:bat[:oid,:bit],hi:bit) :bit
address CMDbatBETWEENcst
comment "B between LO and HI inclusive, nil border is (minus) infinity";
pattern between(b:bat[:oid,:bit],lo:bit,hi:bat[:oid,:bit]) :bit
address CMDbatBETWEENcst
comment "B between LO and HI inclusive, nil border is (minus) infinity";
pattern between(b:bat[:oid,:bit],lo:bit,hi:bit) :bit
address CMDbatBETWEENcst
comment "B between LO and HI inclusive, nil border is (minus) infinity";

pattern between(b:bat[:oid,:bte],lo:bat[:oid,:bte],hi:bat[:oid,:bte]) :bit
address CMDbatBETWEEN
comment "B between LO and HI inclusive, nil border is (minus) infinity";
pattern between(b:bat[:oid,:bte],lo:bat[:oid,:bte],hi:bte) :bit
address CMDbatBETWEENcst
comment "B between LO and HI inclusive, nil border is (minus) infinity";
pattern between(b:bat[:oid,:bte],lo:bte,hi:bat[:oid,:bte]) :bit
address CMDbatBETWEENcst
comment "B between LO and HI inclusive, nil border is (minus) infinity";
pattern between(b:bat[:oid,:bte],lo:bte,hi:bte) :bit
address CMDbatBETWEENcst
comment "B between LO and HI inclusive, nil border is (minus) infinity";

pattern between(b:bat[:oid,:sht],lo:bat[:oid,:sht],hi:bat[:oid,:sht]) :bit
address CMDbatBETWEEN
comment "B between LO and HI inclusive, nil border is (minus) infinity";
pattern between(b:bat[:oid,:sht],lo:bat[:oid,:sht],hi:sht) :bit
address CMDbatBETWEENcst
comment "B between LO and HI inclusive, nil border is (minus) infinity";
pattern between(b:bat[:oid,:sht],lo:sht,hi:bat[:oid,:sht]) :bit
address CMDbatBETWEENcst
comment "B between LO and HI inclusive, nil border is (minus) infinity";
pattern between(b:bat[:oid,:sht],lo:sht,hi:sht) :bit
address CMDbatBETWEENcst
comment "B between LO and HI inclusive, nil border is (minus) infinity";

pattern between(b:bat[:oid,:int],lo:bat[:oid,:int],hi:bat[:oid,:int]) :bit
address CMDbatBETWEEN
comment "B between LO and HI inclusive, nil border is (minus) infinity";
pattern between(b:bat[:oid,:int],lo:bat[:oid,:int],hi:int) :bit
address CMDbatBETWEENcst
comment "B between LO and HI inclusive, nil border is (minus) infinity";
pattern between(b:bat[:oid,:int],lo:int,hi:bat[:oid,:int]) :bit
address CMDbatBETWEENcst
comment "B between LO and HI inclusive, nil border is (minus) infinity";
pattern between(b:bat[:oid,:int],lo:int,hi:int) :bit
address CMDbatBETWEENcst
comment "B between LO and HI inclusive, nil border is (minus) infinity";

pattern between(b:bat[:oid,:wrd],lo:bat[:oid,:wrd],hi:bat[:oid,:wrd]) :bit
address CMDbatBETWEEN
comment "B between LO and HI inclusive, nil border is (minus) infinity";
pattern between(b:bat[:oid,:wrd],lo:bat[:oid,:wrd],hi:wrd) :bit
address CMDbatBETWEENcst
comment "B between LO and HI inclusive, nil border is (minus) infinity";
pattern between(b:bat[:oid,:wrd],lo:wrd,hi:bat[:oid,:wrd]) :bit
address CMDbatBETWEENcst
comment "B between LO and HI inclusive, nil border is (minus) infinity";
pattern between(b:bat[:oid,:wrd],lo:wrd,hi:wrd) :bit
address CMDbatBETWEENcst
comment "B between LO and HI inclusive, nil border is (minus) infinity";

pattern between(b:bat[:oid,:lng],lo:bat[:oid,:lng],hi:bat[:oid,:lng]) :bit
address CMDbatBETWEEN
comment "B between LO and HI inclusive, nil border is (minus) infinity";
pattern between(b:bat[:oid,:lng],lo:bat[:oid,:lng],hi:lng) :bit
address CMDbatBETWEENcst
comment "B between LO and HI inclusive, nil border is (minus) infinity";
pattern between(b:bat[:oid,:lng],lo:lng,hi:bat[:oid,:lng]) :bit
address CMDbatBETWEENcst
comment "B between LO and HI inclusive, nil border is (minus) infinity";
pattern between(b:bat[:oid,:lng],lo:lng,hi:lng) :bit
address CMDbatBETWEENcst
comment "B between LO and HI inclusive, nil border is (minus) infinity";

pattern between(b:bat[:oid,:flt],lo:bat[:oid,:flt],hi:bat[:oid,:flt]) :bit
address CMDbatBETWEEN
comment "B between LO and HI inclusive, nil border is (minus) infinity";
pattern between(b:bat[:oid,:flt],lo:bat[:oid,:flt],hi:flt) :bit
address CMDbatBETWEENcst
comment "B between LO and HI inclusive, nil border is (minus) infinity";
pattern between(b:bat[:oid,:flt],lo:flt,hi:bat[:oid,:flt]) :bit
address CMDbatBETWEENcst
comment "B between LO and HI inclusive, nil border is (minus) infinity";
pattern between(b:bat[:oid,:flt],lo:flt,hi:flt) :bit
address CMDbatBETWEENcst
comment "B between LO and HI inclusive, nil border is (minus) infinity";

pattern between(b:bat[:oid,:dbl],lo:bat[:oid,:dbl],hi:bat[:oid,:dbl]) :bit
address CMDbatBETWEEN
comment "B between LO and HI inclusive, nil border is (minus) infinity";
pattern between(b:bat[:oid,:dbl],lo:bat[:oid,:dbl],hi:dbl) :bit
address CMDbatBETWEENcst
comment "B between LO and HI inclusive, nil border is (minus) infinity";
pattern between(b:bat[:oid,:dbl],lo:dbl,hi:bat[:oid,:dbl]) :bit
address CMDbatBETWEENcst
comment "B between LO and HI inclusive, nil border is (minus) infinity";
pattern between(b:bat[:oid,:dbl],lo:dbl,hi:dbl) :bit
address CMDbatBETWEENcst
comment "B between LO and HI inclusive, nil border is (minus) infinity";

pattern between(b:bat[:oid,:oid],lo:bat[:oid,:oid],hi:bat[:oid,:oid]) :bit
address CMDbatBETWEEN
comment "B between LO and HI inclusive, nil border is (minus) infinity";
pattern between(b:bat[:oid,:oid],lo:bat[:oid,:oid],hi:oid) :bit
address CMDbatBETWEENcst
comment "B between LO and HI inclusive, nil border is (minus) infinity";
pattern between(b:bat[:oid,:oid],lo:oid,hi:bat[:oid,:oid]) :bit
address CMDbatBETWEENcst
comment "B between LO and HI inclusive, nil border is (minus) infinity";
pattern between(b:bat[:oid,:oid],lo:oid,hi:oid) :bit
address CMDbatBETWEENcst
comment "B between LO and HI inclusive, nil border is (minus) infinity";


command avg(b:bat[:oid,:bte]) :dbl
address CMDcalcavg
comment "average of non-nil values of B";
command avg2(b:bat[:oid,:bte]) (:dbl, :lng)
address CMDcalcavg2
comment "average and number of non-nil values of B";

command avg(b:bat[:oid,:sht]) :dbl
address CMDcalcavg
comment "average of non-nil values of B";
command avg2(b:bat[:oid,:sht]) (:dbl, :lng)
address CMDcalcavg2
comment "average and number of non-nil values of B";

command avg(b:bat[:oid,:int]) :dbl
address CMDcalcavg
comment "average of non-nil values of B";
command avg2(b:bat[:oid,:int]) (:dbl, :lng)
address CMDcalcavg2
comment "average and number of non-nil values of B";

command avg(b:bat[:oid,:wrd]) :dbl
address CMDcalcavg
comment "average of non-nil values of B";
command avg2(b:bat[:oid,:wrd]) (:dbl, :lng)
address CMDcalcavg2
comment "average and number of non-nil values of B";

command avg(b:bat[:oid,:lng]) :dbl
address CMDcalcavg
comment "average of non-nil values of B";
command avg2(b:bat[:oid,:lng]) (:dbl, :lng)
address CMDcalcavg2
comment "average and number of non-nil values of B";

command avg(b:bat[:oid,:flt]) :dbl
address CMDcalcavg
comment "average of non-nil values of B";
command avg2(b:bat[:oid,:flt]) (:dbl, :lng)
address CMDcalcavg2
comment "average and number of non-nil values of B";

command avg(b:bat[:oid,:dbl]) :dbl
address CMDcalcavg
comment "average of non-nil values of B";
command avg2(b:bat[:oid,:dbl]) (:dbl, :lng)
address CMDcalcavg2
comment "average and number of non-nil values of B";

