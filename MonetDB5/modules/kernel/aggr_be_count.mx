@/
The contents of this file are subject to the MonetDB Public License
Version 1.1 (the "License"); you may not use this file except in
compliance with the License. You may obtain a copy of the License at
http://www.monetdb.org/Legal/MonetDBLicense

Software distributed under the License is distributed on an "AS IS"
basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations
under the License.

The Original Code is the MonetDB Database System.

The Initial Developer of the Original Code is CWI.
Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
Copyright August 2008-2012 MonetDB B.V.
All Rights Reserved.
@

@f aggr_be_count

@c
/*
 * @a S. Manegold
 * @v 1.0
 * @+ Aggregates Module
 *
 *
 * @+ Implementation
 * These implementations need just one scan and a simple hash-maintained data
 * structure to compute a group of common aggregates.
 */
#include "monetdb_config.h"
#include <gdk.h>
#include "aggr.h"
#include "aggr_be_count.h"

/*
 * @- Result initialization
 * //	init_result
 * 	@1:	tail-type:	bte/sht/int/wrd/lng/flt/dbl / any / void
 *
 */
@include aggr_ri.mx
@c
/*
 * @- Count
 */
/*	aggrX3_count
		e-void-head	e-oid-head	e-oid-head	e-oid-head
		void-lookup	array-lookup	scan-lookup	hash-lookup

	@1:	0		1		0		0		use cnt-array?
	@2:	0		0		0		1		do BATprepareHash?
	@3:	BUNfndVOID	CHKrange	SCANfndOID	HASHfnd_oid	lookup
	@4:	var		loc		loc		loc		e/bn-head-access

	@5:	"BUNhloc(b,p)"	for  (oid) b-head-type,		b-head access
		"&bhsb; bhsb++" for (void) b-head-type

	@6:	BUNtloc(bn,r)	BUNtloc(bn,r)	&cnt[(*(oid*)h)-min]
								*dst: count in-place or in cnt-array ?
*/
@= aggrX3_count
	ALGODEBUG fprintf(stderr, "#aggrX3_count(@1,@2,@3,@4,@5,@6);\n");
#if @1
	if (range > 0) {
		/* create tmp. cnt array */
		cnt = (wrd*) GDKzalloc(range*sizeof(wrd));
		if (cnt == NULL) {
			GDKerror("aggrX3_count(@1,@2,@3,@4,@5,@6): cnt = GDKzalloc("OIDFMT"*"SZFMT") failed", range, sizeof(wrd));
			BBPreclaim(bn);
			return GDK_FAIL;
		}
	}
#endif
#if @2
	if (BATprepareHash(bn)) {
		GDKerror("aggrX3_count(@1,@2,@3,@4,@5,@6): BATprepareHash(bn) failed");
#if @1
		if (cnt)
			GDKfree(cnt);
#endif
		BBPreclaim(bn);
		return GDK_FAIL;
	}
#endif
	/* scan b, and increment counts in-place or in cnt-array */
	bhsb = b->hseqbase-1;
	btt = b->ttype;
	if (*ignore_nils && !b->T->nonil) {
		b_use |= USE_TAIL;
		switch(ATOMstorage(btt)) {
		case TYPE_bte:
			@:aggrX3_count_loop(@1,@2,@3,@4,@5,@6,if (!simple_EQ(BUNtloc(bi,p),bt_nil,bte)))@
		case TYPE_sht:
			@:aggrX3_count_loop(@1,@2,@3,@4,@5,@6,if (!simple_EQ(BUNtloc(bi,p),bt_nil,sht)))@
		case TYPE_int:
			@:aggrX3_count_loop(@1,@2,@3,@4,@5,@6,if (!simple_EQ(BUNtloc(bi,p),bt_nil,int)))@
		case TYPE_lng:
			@:aggrX3_count_loop(@1,@2,@3,@4,@5,@6,if (!simple_EQ(BUNtloc(bi,p),bt_nil,lng)))@
		case TYPE_flt:
			@:aggrX3_count_loop(@1,@2,@3,@4,@5,@6,if (!simple_EQ(BUNtloc(bi,p),bt_nil,flt)))@
		case TYPE_dbl:
			@:aggrX3_count_loop(@1,@2,@3,@4,@5,@6,if (!simple_EQ(BUNtloc(bi,p),bt_nil,dbl)))@
		default:
			if (b->tvarsized) {
				@:aggrX3_count_loop(@1,@2,@3,@4,@5,@6,if (!atom_EQ(BUNtvar(bi,p),bt_nil,btt)))@
			  } else {
				@:aggrX3_count_loop(@1,@2,@3,@4,@5,@6,if (!atom_EQ(BUNtloc(bi,p),bt_nil,btt)))@
			  }
		}
	} else {
		switch(ATOMstorage(btt)) {
		case TYPE_bte:
			@:aggrX3_count_loop(@1,@2,@3,@4,@5,@6,)@
		case TYPE_sht:
			@:aggrX3_count_loop(@1,@2,@3,@4,@5,@6,)@
		case TYPE_int:
			@:aggrX3_count_loop(@1,@2,@3,@4,@5,@6,)@
		case TYPE_lng:
			@:aggrX3_count_loop(@1,@2,@3,@4,@5,@6,)@
		case TYPE_flt:
			@:aggrX3_count_loop(@1,@2,@3,@4,@5,@6,)@
		case TYPE_dbl:
			@:aggrX3_count_loop(@1,@2,@3,@4,@5,@6,)@
		default:
			if (b->tvarsized) {
				@:aggrX3_count_loop(@1,@2,@3,@4,@5,@6,)@
			} else {
				@:aggrX3_count_loop(@1,@2,@3,@4,@5,@6,)@
			}
		}
	}
#if @1
	if (cnt) {
		/* copy cnt array to final result */
		BATaccessBegin(bn,USE_HEAD|USE_TAIL,MMAP_SEQUENTIAL);
		BATloop(bn, p, q) {
			oid h = (*(oid*) BUNh@4(bni,p)) - min;
			*(wrd*)BUNtloc(bni, p) = cnt[h];
		}
		BATaccessEnd(bn,USE_HEAD|USE_TAIL,MMAP_SEQUENTIAL);
		GDKfree(cnt);
	}
#endif
@
@c
/*	aggrX3_count_loop
	@7:	if (!atom_EQ(BUNt{loc,var}(b,p),bt_nil,btt))		b-tail nil check
		if (!simple_EQ(BUNtloc(b,p),bt_nil,{bte,sht,int,flt,lng,dbl}))
*/
@= aggrX3_count_loop
	ALGODEBUG fprintf(stderr, "#aggrX3_count_loop(@1,@2,@3,@4,@5,@6,@7);\n");
#if @1
	if (!cnt)
#endif
		BATaccessBegin(bn,USE_HEAD|USE_HHASH|USE_TAIL,BAThordered(b)&BAThordered(e)?MMAP_SEQUENTIAL:MMAP_WILLNEED);
	if (b_use)
		BATaccessBegin(b,b_use,MMAP_SEQUENTIAL);
	BATloop(b, p, q) {
		@7 {
			oid *h = (oid*) @5;

			@3(r, bni, h);
			if (r != BUN_NONE) {
				wrd *dst = (wrd*) @6;
				(*dst)++;
			}
		}
	}
	if (b_use)
		BATaccessEnd(b,b_use,MMAP_SEQUENTIAL);
#if @1
	if (!cnt)
#endif
		BATaccessEnd(bn,USE_HEAD|USE_HHASH|USE_TAIL,BAThordered(b)&BAThordered(e)?MMAP_SEQUENTIAL:MMAP_WILLNEED);
	break;
@
@h
int
CMDaggrX3_count(BAT **ret, BAT *b, BAT *e, bit *ignore_nils);
@c
int
CMDaggrX3_count(BAT **ret, BAT *b, BAT *e, bit *ignore_nils)
{
	BATiter bni, bi = bat_iterator(b);
	BAT *bn;
	wrd zero = 0, *cnt = NULL;
	BUN p, q, r;
	oid range;
	oid min, max;
	oid bhsb;
	int b_use = 0;
	int btt;
	ptr bt_nil = ATOMnilptr(b->ttype);

	ALGODEBUG fprintf(stderr, "#CMDaggrX3_count(b=%s,e=%s);\n", 
		BATgetId(b),BATgetId(e));

	if (BAThdense(e) && 
	    BATtdense(e) &&
	    BAThdense(b) && 
	    BATcount(b) == BATcount(e) &&
	    (!ignore_nils || b->T->nonil)) {
		/* simply return counts with one */
		wrd one = 1;
		bn = BATconst(b, TYPE_wrd, &one);
		*ret = bn;
		return GDK_SUCCEED;
	}

 	bn = BATnew(TYPE_void, TYPE_wrd, BATcount(e));
	if( bn == NULL) {
		GDKerror("CMDaggrX3_count(): BATnew() failed");
		return GDK_FAIL;
	}

	/* init: set all counts to zero and calculate min/max oid */
	@:init_result(wrd)@
	bni = bat_iterator(bn);
	range = max - min + 1;

	if (!BAThdense(b))
		b_use |= USE_HEAD;
	/* scan b, and calculate counts */
	if (e->htype == TYPE_void) {
		/* void lookup */
		if (BAThdense(b)) {
			@:aggrX3_count(0,0,BUNfndVOID,var,&bhsb;bhsb++,BUNtloc(bni,r))@
		} else {
			@:aggrX3_count(0,0,BUNfndVOID,var,BUNhloc(bi,p),BUNtloc(bni,r))@
		}
		/* e->htype == TYPE_oid */
	} else if (range <= SMALL_AGGR_MAX) {
		/* array lookup */
		if (BAThdense(b)) {
			@:aggrX3_count(1,0,CHKrange,loc,&bhsb;bhsb++,&cnt[(*(oid*)h)-min])@
		} else {
			@:aggrX3_count(1,0,CHKrange,loc,BUNhloc(bi,p),&cnt[(*(oid*)h)-min])@
		}
	} else if (BATcount(e) <= SCAN_AGGR_MAX) {
		/* scan lookup */
		SCAN_aggr_init;
		if (BAThdense(b)) {
			@:aggrX3_count(0,0,SCANfndOID,loc,&bhsb;bhsb++,BUNtloc(bni,r))@
		} else {
			@:aggrX3_count(0,0,SCANfndOID,loc,BUNhloc(bi,p),BUNtloc(bni,r))@
		}
	} else if (BATtordered(b)&BAThordered(e)) {
		/* merge lookup */
		MERGE_aggr_init;
		if (BAThdense(b)) {
			@:aggrX3_count(0,0,MERGEfndOID,loc,&bhsb;bhsb++,BUNtloc(bni,r))@
		} else {
			@:aggrX3_count(0,0,MERGEfndOID,loc,BUNhloc(bi,p),BUNtloc(bni,r))@
		}
	} else {
		/* hash lookup */
		if (BAThdense(b)) {
			@:aggrX3_count(0,1,HASHfnd_oid,loc,&bhsb;bhsb++,BUNtloc(bni,r))@
		} else {
			@:aggrX3_count(0,1,HASHfnd_oid,loc,BUNhloc(bi,p),BUNtloc(bni,r))@
		}
	}

	*ret = bn;
	return GDK_SUCCEED;
}

@h
/*
 * @- Size
 */
int
CMDaggrX3_size(BAT **ret, BAT *b, BAT *e);
@c
int
CMDaggrX3_size(BAT **ret, BAT *b, BAT *e)
{
	BAT *bn = BATnew(e->htype, TYPE_wrd, BATcount(e));
	BATiter bni = bat_iterator(bn), bi = bat_iterator(b), ei = bat_iterator(e);
	wrd zero = 0;
	BUN p, q, r;

	if( bn == NULL) {
		GDKerror("CMDaggrX3_size(): BATnew() failed");
		return GDK_FAIL;
	}
	/* init: set all sums to zero */
	bn->tsorted = bn->trevsorted = 0;
	bn->hsorted = bn->hrevsorted = 0;
	ALIGNsetH(bn, e);
	BATaccessBegin(e,USE_HEAD,MMAP_SEQUENTIAL);
	BATloop(e, p, q) {
		if (BUNfastins(bn, BUNhead(ei, p), &zero) == NULL) {
			BBPreclaim(bn);
			return GDK_FAIL;
		}
	}
	BATaccessEnd(e,USE_HEAD,MMAP_SEQUENTIAL);
	/* scan b, and add increment totals for true values */
	if (BATprepareHash(bn)) {
		GDKerror("CMDaggrX3_size(): BATprepareHash(bn) failed");
		BBPreclaim(bn);
		return GDK_FAIL;
	}
	BATaccessBegin(b,USE_HEAD|USE_TAIL,MMAP_SEQUENTIAL);
	BATloop(b, p, q) {
		if (*(bit *) BUNtloc(bi, p) == TRUE) {
			oid *h = (oid *) BUNhead(bi, p);

			BUNfndOID(r, bni, h);
			if (r != BUN_NONE) {
				wrd *dst = (wrd *) BUNtloc(bni, r);

				(*dst)++;
			}
		}
	}
	BATaccessEnd(b,USE_HEAD|USE_TAIL,MMAP_SEQUENTIAL);
	*ret = bn;
	return GDK_SUCCEED;
}

