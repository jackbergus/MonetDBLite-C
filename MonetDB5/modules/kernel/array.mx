@/
The contents of this file are subject to the MonetDB Public License
Version 1.1 (the "License"); you may not use this file except in
compliance with the License. You may obtain a copy of the License at
http://www.monetdb.org/Legal/MonetDBLicense

Software distributed under the License is distributed on an "AS IS"
basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations
under the License.

The Original Code is the MonetDB Database System.

The Initial Developer of the Original Code is CWI.
Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
Copyright August 2008-2011 MonetDB B.V.
All Rights Reserved.
@

@f array

@c
/*
 * @a A.R. van Ballegooij
 * @+ Basic array support
 *
 * The array support library constructs the index arrays essential
 * for the Relational Algebra Model language.
 * The grid filler operation assumes that there is enough space.
 * The shift variant multiplies all elements with a constant factor.
 * It is a recurring operation for the RAM front-end and will save
 * an additional copying.
 *
 * The optimization is captured in a contraction macro.
 */
@mal
module array;
@= grid_mdefs
command grid(i:@1,j:@1,k:@1,l:@1) :bat[:oid,:@1] 
address ARRAYgrid_@1
comment  "Generates an index BAT, (grpcount,grpsize,clustersize,offset)";

command grid(i:@1,j:@1,k:@1,l:@1,s:@1) :bat[:oid,:@1] 
address ARRAYgridShift_@1
comment  "Generates an index BAT, (grpcount,grpsize,clustersize,offset)
and shift all elements with a factor s";

command grid(b:bat[:oid,:@1],i:@1,j:@1,k:@1,l:@1) :bat[:oid,:@1] 
address ARRAYgridBAT_@1
comment  "Fills an index BAT, (grpcount,grpsize,clustersize,offset)";

command grid(b:bat[:oid,:@1],i:@1,j:@1,k:@1,l:@1,s:@1) :bat[:oid,:@1] 
address ARRAYgridBATshift_@1
comment  "Fills an index BAT, (grpcount,grpsize,clustersize,offset)
and shift all elemenets with a factor s";

@
@mal
@:grid_mdefs(int)@
@:grid_mdefs(lng)@

command product(b:bat[:any_3,:any_1],c:bat[:any_4,:any_2]):bat[:any_1,:any_2]
address ARRAYproduct
comment "Produce an array product";

command project(b:bat[:oid,:any_1],i:int):bat[:oid,:int]
address ARRAYproject
comment "Fill an array representation with constants ";

# @- Implementation
@include ../mal/prelude.mx
@h

/*============================================================================*/
#ifndef __array_h__
#define __array_h__

#include <gdk.h>
#include <algebra.h>		/* to include BATmin and BATmax */

@= grid_hdefs
#define new_@1_bat(b,s) {(b)=BATnew(TYPE_void,TYPE_@1,(BUN) (s)); \
                         if (b) BATseqbase((b),0);                 }
#define add_@1s(b,n)    {(b)->T->heap.free+=(size_t)(n)*sizeof(@1);\
			                   (b)->batCount+=(BUN)n;\
                         BATkey(BATmirror((b)),0);          \
                         (b)->tsorted = 0;                  }
#define get_@1_ptr(b)   ((@1*)(Tloc(b,BUNfirst((b)))))
@
@h
@:grid_hdefs(int)@
@:grid_hdefs(lng)@

/* The maximum number of dimensions that the print-function can handle... */
#define MAX_ARRAY_DIM 16

#endif
/*============================================================================*/
@c
/*============================================================================*/
#include "monetdb_config.h"
#include "array.h"
#include "gdk.h"
#include <math.h>
#include <time.h>

/*----------------------------------------------------------------------------*/

#ifdef WIN32
#if !defined(LIBMAL) && !defined(LIBATOMS) && !defined(LIBKERNEL) && !defined(LIBMAL) && !defined(LIBOPTIMIZER) && !defined(LIBSCHEDULER) && !defined(LIBMONETDB5)
#define array_export extern __declspec(dllimport)
#else
#define array_export extern __declspec(dllexport)
#endif
#else
#define array_export extern
#endif

array_export str ARRAYproduct(int *ret, int *bid, int *rid);
array_export str ARRAYproject(int *ret, int *bid, int *cst);

@= grid_impl
array_export str ARRAYgrid_@1(@1 *ret, @1 *groups, @1 *groupsize, @1 *clustersize, @1 *offset);
array_export str ARRAYgridShift_@1(@1 *ret, @1 *groups, @1 *groupsize, @1 *clustersize, @1 *offset, @1 *shift);
array_export str ARRAYgridBAT_@1(@1 *ret, @1 *bid, @1 *groups, @1 *groupsize, @1 *clustersize, @1 *offset);
array_export str ARRAYgridBATshift_@1(@1 *ret, @1 *bid, @1 *groups, @1 *groupsize, @1 *clustersize, @1 *offset, @1 *shift);

static int
fillgrid_@1(BAT **out, @1 *groups, @1 *groupsize, @1 *clustersize, @1 *offset, @1 *shift)
{
	register @1 *ptr;
	@1 i = *groups;
	@1 n = *groupsize + *offset;
	@1 r = *clustersize;
	@1 o = *offset;
	@1 s = *shift;

#ifdef EXCESSIVE_DEBUGGING
	fprintf(stderr, "[grid] (%d,%d,%d,%d)", i, n, r, o);
#endif

	ptr = get_@1_ptr(*out);

	while (i--) {
		register @1 ni = o;

		while (ni < n) {
			register @1 ri = r;

			while (ri--)
				(*(ptr ++)) = ni * s;
			ni++;
		}
	}

#ifdef EXCESSIVE_DEBUGGING
	fprintf(stderr, "- done\n");
#endif

	return GDK_SUCCEED;
}

static int
grid_@1(BAT **out, @1 *groups, @1 *groupsize, @1 *clustersize, @1 *offset)
{
	@1 i = *groups;
	@1 n = *groupsize + *offset;
	@1 r = *clustersize;
	@1 o = *offset;
	@1 s = 1;

#ifdef EXCESSIVE_DEBUGGING
	fprintf(stderr, "[grid] (%d,%d,%d,%d)", i, n, r, o);
#endif

	new_@1_bat(*out, (i * (n - o) * r));
	if (out == NULL) {
		GDKerror("grid: cannot create the bat (" @2 " BUNs)\n", (i * (n - o) * r));
		return GDK_FAIL;
	}
	add_@1s(*out, (i * (n - o) * r));
	return fillgrid_@1(out, groups, groupsize, clustersize, offset, &s);
}

static int
gridShift_@1(BAT **out, @1 *groups, @1 *groupsize, @1 *clustersize, @1 *offset, @1 *shift)
{
	@1 i = *groups;
	@1 n = *groupsize + *offset;
	@1 r = *clustersize;
	@1 o = *offset;

#ifdef EXCESSIVE_DEBUGGING
	fprintf(stderr, "[grid] (%d,%d,%d,%d)", i, n, r, o);
#endif

	new_@1_bat(*out, (i * (n - o) * r));
	if (*out == 0)
		return GDK_FAIL;
	add_@1s(*out, (i * (n - o) * r));
	return fillgrid_@1(out, groups, groupsize, clustersize, offset, shift);
}

@
@c
@:grid_impl(int,"%d")@
@:grid_impl(lng,LLFMT)@

/*
 * @+
 * The M5 wrapper code
 */
#include "mal.h"
@= grid_wrapper_impl
str
ARRAYgrid_@1(@1 *ret, @1 *groups, @1 *groupsize, @1 *clustersize, @1 *offset)
{
	BAT *bn;

	if (grid_@1(&bn, groups, groupsize, clustersize, offset) == GDK_FAIL)
		throw(MAL, "array.grid", MAL_MALLOC_FAIL);
	if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ); \
	*ret = bn->batCacheid;
	BBPkeepref((int)*ret);
	return MAL_SUCCEED;
}

str
ARRAYgridShift_@1(@1 *ret, @1 *groups, @1 *groupsize, @1 *clustersize, @1 *offset, @1 *shift)
{
	BAT *bn;

	if (gridShift_@1(&bn, groups, groupsize, clustersize, offset, shift) == GDK_FAIL)
		throw(MAL, "array.grid", MAL_MALLOC_FAIL);
	if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ); \
	*ret = bn->batCacheid;
	BBPkeepref((int)*ret);
	return MAL_SUCCEED;
}

str
ARRAYgridBAT_@1(@1 *ret, @1 *bid, @1 *groups, @1 *groupsize, @1 *clustersize, @1 *offset)
{
	BAT *bn;
	@1 shift = 1;

	if ((bn = BATdescriptor((bat) *bid)) == NULL) {
		throw(MAL, "array.grid", RUNTIME_OBJECT_MISSING);
	}

	if (fillgrid_@1(&bn, groups, groupsize, clustersize, offset, &shift) == GDK_FAIL)
		throw(MAL, "array.grid", MAL_MALLOC_FAIL);
	if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ); \
	*ret = bn->batCacheid;
	BBPkeepref((int)*ret);
	return MAL_SUCCEED;
}

str
ARRAYgridBATshift_@1(@1 *ret, @1 *bid, @1 *groups, @1 *groupsize, @1 *clustersize, @1 *offset, @1 *shift)
{
	BAT *bn;

	if ((bn = BATdescriptor((bat) *bid)) == NULL) {
		throw(MAL, "array.grid", RUNTIME_OBJECT_MISSING);
	}
	if (fillgrid_@1(&bn, groups, groupsize, clustersize, offset, shift) == GDK_FAIL)
		throw(MAL, "array.grid", MAL_MALLOC_FAIL);
	if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ); \
	*ret = bn->batCacheid;
	BBPkeepref((int)*ret);
	return MAL_SUCCEED;
}
@
@c
@:grid_wrapper_impl(int)@
@:grid_wrapper_impl(lng)@

/*
 * @-
 */
@= arraymultiply
array_export str ARRAYmultiply_@1_@2(int *ret, int *bid, int *rid);
str
ARRAYmultiply_@1_@2(int *ret, int *bid, int *rid){
	BAT *bn, *b, *r;
	BUN p,q, s,t;
	@2 val;
	oid o= oid_nil;
	BATiter bi, ri;

	if( (b= BATdescriptor(*bid)) == NULL ){
		 throw(MAL, "array.*", RUNTIME_OBJECT_MISSING);
	}
	if( (r= BATdescriptor(*rid)) == NULL ){
		BBPreleaseref(b->batCacheid);
		 throw(MAL, "array.*", RUNTIME_OBJECT_MISSING);
	}
	bn= BATnew(TYPE_void, TYPE_@2, BATcount(b)*BATcount(r));
	BATseqbase(bn,0);

	bi = bat_iterator(b);
	ri = bat_iterator(r);
	BATloop(b,p,q){
		BATloop(r,s,t){
			val = (*(@1*) BUNtail(bi,p)) * (*(@1*)BUNtail(ri,s));
			BUNfastins(bn,&o,&val);
		}
	}
	bn->T->nonil = b->T->nonil & r->T->nonil;
	if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ); \
	*ret= bn->batCacheid;
	BBPkeepref(*ret);
	BBPreleaseref(b->batCacheid);
	BBPreleaseref(r->batCacheid);
	return MAL_SUCCEED;
}
@
@c
@:arraymultiply(sht,lng)@
@:arraymultiply(sht,int)@
@:arraymultiply(int,int)@
@:arraymultiply(int,lng)@
@:arraymultiply(lng,lng)@

str
ARRAYproduct(int *ret, int *bid, int *rid)
{
	BAT *bn, *b, *r;
	BUN p, q, s, t;
	BATiter bi, ri;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "array.product", RUNTIME_OBJECT_MISSING);
	}
	if ((r = BATdescriptor(*rid)) == NULL) {
		BBPreleaseref(b->batCacheid);
		throw(MAL, "array.product", RUNTIME_OBJECT_MISSING);
	}
	if (BATcount(b) > BATcount(r) || (BATcount(b) % BATcount(r)) != BATcount(b)) {
		BBPreleaseref(b->batCacheid);
		BBPreleaseref(r->batCacheid);
		throw(MAL, "array.product", "Illegal argument bounds");
	}
	bn = BATnew(b->ttype, r->ttype, BATcount(r));

	bi = bat_iterator(b);
	ri = bat_iterator(r);
	BATloop(r, s, t) {
		BATloop(b, p, q) {
			BUNfastins(bn, BUNtail(bi, p), BUNtail(ri, s));
			s++;
		}
		s--;
	}
	/* not sorted at best we have some fixed offset partial sorting */
	bn->hsorted = 0;
	bn->tsorted = 0;
	bn->T->nonil = b->T->nonil & r->T->nonil;
	if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ); \
	*ret = bn->batCacheid;
	BBPkeepref(*ret);
	BBPreleaseref(b->batCacheid);
	BBPreleaseref(r->batCacheid);
	return MAL_SUCCEED;
}

str
ARRAYproject(int *ret, int *bid, int *cst)
{
	BAT *bn, *b;
	int *ptr;
	BUN i;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "array.project", RUNTIME_OBJECT_MISSING);
	}
	new_int_bat(bn, BATcount(b));
	if (bn == 0)
		throw(MAL, "array.project", MAL_MALLOC_FAIL);
	i = BATcount(b);
	add_ints(bn, i); 
	ptr = get_int_ptr(bn);

	while (i-- > 0)
		(*(ptr ++)) = *cst;
	if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ); \
	*ret = bn->batCacheid;
	BBPkeepref(*ret);
	return MAL_SUCCEED;
}


