@/
The contents of this file are subject to the MonetDB Public License
Version 1.1 (the "License"); you may not use this file except in
compliance with the License. You may obtain a copy of the License at
http://www.monetdb.org/Legal/MonetDBLicense

Software distributed under the License is distributed on an "AS IS"
basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations
under the License.

The Original Code is the MonetDB Database System.

The Initial Developer of the Original Code is CWI.
Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
Copyright August 2008-2011 MonetDB B.V.
All Rights Reserved.
@

@f batifthen
@a M.L. Kersten
@+ BAT if-then-else multiplex expressions.
The assembled code for IF-THEN-ELSE multiplex operations.
Again we assume that the BAT arguments are aligned.
@{
@-
@= ifthenGrp
command batcalc.ifthen(b:bat[:oid,:bit], t:bat[:oid,:@1]) :bat[:oid,:@1] 
address CMDifThen_@1
comment "If-then operation to assemble a conditional result ";

command batcalc.ifthen(b:bat[:oid,:bit], v:@1) :bat[:oid,:@1] 
address CMDifThenCst_@1
comment "Ifthen operation to assemble a conditional result ";

command batcalc.ifthenelse(b:bat[:oid,:bit], v:@1, w:@1) :bat[:oid,:@1] 
address CMDifThenElseCst_@1
comment "Ifthen operation to assemble a conditional result ";

command batcalc.ifthenelse(b:bat[:oid,:bit], t:bat[:oid,:@1], 
		e:bat[:oid,:@1]) :bat[:oid,:@1] 
address CMDifThenElse_@1
comment "If-then-else operation to assemble a conditional result ";

command batcalc.ifthenelse(b:bat[:oid,:bit], e:@1, t:bat[:oid,:@1])
	:bat[:oid,:@1] 
address CMDifThenElseCst1_@1
comment "If-then-else operation to assemble a conditional result ";

command batcalc.ifthenelse(b:bat[:oid,:bit], t:bat[:any_1,:@1], e:@1)
	:bat[:oid,:@1] 
address CMDifThenElseCst2_@1
comment "If-then-else operation to assemble a conditional result ";
@mal
	@:ifthenGrp(bit)@
	@:ifthenGrp(chr)@
	@:ifthenGrp(bte)@
	@:ifthenGrp(sht)@
	@:ifthenGrp(int)@
	@:ifthenGrp(lng)@
	@:ifthenGrp(oid)@
	@:ifthenGrp(flt)@
	@:ifthenGrp(dbl)@
	@:ifthenGrp(str)@
@- Implementation
@include kprelude.mx
@h
#ifndef _BATIFTHEN_
#define _BATIFTHEN_
#include "gdk.h"
#include "math.h"
#include "mal_exception.h"

#ifdef WIN32
#if !defined(LIBMAL) && !defined(LIBATOMS) && !defined(LIBKERNEL) && !defined(LIBMAL) && !defined(LIBOPTIMIZER) && !defined(LIBSCHEDULER) && !defined(LIBMONETDB5)
#define batifthen_export extern __declspec(dllimport)
#else
#define batifthen_export extern __declspec(dllexport)
#endif
#else
#define batifthen_export extern
#endif
#endif /* _BATIFTHEN_ */
@-
A general assumption in all cases is the bats are synchronized on their
head column. This is not checked and may be mis-used to deploy the
implementation for shifted window arithmetic as well.
@= chkSize
	if( BATcount(@1) != BATcount(@2) )
	throw(MAL, "batcalc.@3", ILLEGAL_ARGUMENT " Requires bats of identical size");
@= wrapup
    if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ);
    *ret= bn->batCacheid;
    BBPkeepref(*ret);
    BBPreleaseref(b->batCacheid);
    return MAL_SUCCEED;

@= void_wrapup
	if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ);
	if (b->htype != bn->htype) {
		BAT *r = VIEWcreate(b,bn);

		BBPreleaseref(bn->batCacheid);
		bn = r;
	}
	BBPkeepref(*ret = bn->batCacheid);
	BBPreleaseref(b->batCacheid);
	return MAL_SUCCEED;

@- IfThenElse
The conditional multiplex operations .
@-
The constant versions are typed by the parser
String arguments call for an extra type casting. In combination
with type resolution and runtime checks it provides a dense
definitoin.
@= ifthenImpl
batifthen_export str CMDifThen_@1(int *ret, int *bid, int *tid);
str
CMDifThen_@1(int *ret, int *bid, int *tid) 
{
	BATiter bi, tbi;
	BAT *b, *tb, *bn;
	@1 nilval=  (@1) @1_nil, *val;
	BUN p,q;
	bit *t;

	@:getBATdescriptor(bid,b,"batcalc.ifThen")@
	@:getBATdescriptor(tid,tb,"batcalc.ifThen",BBPreleaseref(b->batCacheid))@
	@:chkSize(b,tb,CMDifThen)@
	@:resBAT(@1,"batcalc.ifThen")@

	bi = bat_iterator(b);
	tbi = bat_iterator(tb);
	t = (bit*)Tloc(b,BUNfirst(b));

	BATaccessBegin(b,USE_HEAD, MMAP_SEQUENTIAL);
	BATaccessBegin(tb,USE_TAIL, MMAP_SEQUENTIAL);
	BATloop(b, p, q) {
		if (*t == bit_nil) {
			BUNfastins(bn, BUNhead(bi,p), (ptr) & nilval);
		} else if (*t) {
			val = (@1*) BUNtail(tbi,p);
			BUNfastins(bn, BUNhead(bi,p), val);
		}
		t++;
	}
	BATaccessEnd(tb,USE_TAIL, MMAP_SEQUENTIAL);
	BATaccessEnd(b,USE_HEAD, MMAP_SEQUENTIAL);
	bn->T->nonil = (b->T->nonil && tb->T->nonil);
	BBPreleaseref(tb->batCacheid);
	@:wrapup@
}

batifthen_export str CMDifThenCst_@1(int *ret, int *bid, @1 *tid);
str CMDifThenCst_@1(int *ret, int *bid, @1 *tid)
{
	BATiter bi;
	BAT *b, *bn;
	@1 nilval= (@1) @1_nil;
	BUN p,q;
	bit *t;

	@:getBATdescriptor(bid,b,"batcalc.ifThen")@
	@:resBAT(@1,"batcalc.ifThen")@

	bi = bat_iterator(b);
	t = (bit*)Tloc(b,BUNfirst(b));

	BATaccessBegin(b,USE_HEAD, MMAP_SEQUENTIAL);
	BATloop(b, p, q) {
		if (*t == bit_nil) 
			BUNfastins(bn, BUNhead(bi,p), (ptr) & nilval);
		else if (*t) 
			BUNfastins(bn, BUNhead(bi,p), (ptr) tid);
		t++;
	}
	BATaccessEnd(b,USE_HEAD, MMAP_SEQUENTIAL);
	bn->T->nonil = (b->T->nonil && *tid != nilval);
	@:wrapup@
}

@= ifthenelseImpl
batifthen_export str CMDifThenElseCst_@1(int *ret, int *bid, @1 *tid, @1 *eid);
str CMDifThenElseCst_@1(int *ret, int *bid, @1 *tid, @1 *eid)
{
	BAT *b, *bn;
	@1 nilval= (@1) @1_nil, *dst;
	bit *t;
	BUN cnt, p;

	@:getBATdescriptor(bid,b,"batcalc.ifThenElse")@
	@:voidresultBAT(TYPE_@1,"batcalc.ifThenElse")@
	bn->tsorted = FALSE;
	BATkey(BATmirror(bn), FALSE);

	cnt = BATcount(b);
	t = (bit*)Tloc(b,BUNfirst(b));
	dst = (@1*)Tloc(bn, BUNfirst(bn));

	BATaccessBegin(b,USE_TAIL, MMAP_SEQUENTIAL);
	for (p=0; p<cnt; p++) {
		if (t[p] == bit_nil) 
			dst[p] = nilval;
		else if (t[p]) 
			dst[p] = *tid;
		else
			dst[p] = *eid;
	}
	BATaccessEnd(b,USE_TAIL, MMAP_SEQUENTIAL);
	bn->T->nonil = (b->T->nonil && *tid != nilval && *eid != nilval);
	BATsetcount(bn, p);
	@:void_wrapup@
}

batifthen_export str CMDifThenElse_@1(int *ret, int *bid, int *tid, int *eid);
str
CMDifThenElse_@1(int *ret, int *bid, int *tid, int *eid)
{
	BAT *b, *tb, *eb, *bn;
	@1 nilval= (@1) @1_nil, *dst, *tbv, *ebv;
	bit *t;
	BUN cnt, p;

	@:getBATdescriptor(bid,b,"batcalc.ifThenElse")@
	@:getBATdescriptor(tid,tb,"batcalc.ifThenElse",BBPreleaseref(b->batCacheid);)@
	@:getBATdescriptor(eid,eb,"batcalc.ifThenElse", BBPreleaseref(b->batCacheid); BBPreleaseref(tb->batCacheid);)@
	@:chkSize(b,tb,ifThenElse)@
	@:chkSize(b,eb,ifThenElse)@
	@:voidresultBAT(TYPE_@1,"batcalc.ifThenElse")@
	bn->tsorted = FALSE;
    	BATkey(BATmirror(bn), FALSE);

	cnt = BATcount(b);
	t = (bit*) Tloc(b, BUNfirst(b));
	dst = (@1*)Tloc(bn, BUNfirst(bn));
	tbv = (@1*)Tloc(tb, BUNfirst(tb));
	ebv = (@1*)Tloc(eb, BUNfirst(eb));

	BATaccessBegin(b,USE_TAIL, MMAP_SEQUENTIAL);
	BATaccessBegin(tb,USE_TAIL, MMAP_SEQUENTIAL);
	BATaccessBegin(eb,USE_TAIL, MMAP_SEQUENTIAL);
	for (p=0; p<cnt; p++) {
		if (t[p] == bit_nil) 
			dst[p] = nilval;
		else if (t[p]) 
			dst[p] = tbv[p];
		else
			dst[p] = ebv[p];
	}
	BATaccessEnd(b,USE_TAIL, MMAP_SEQUENTIAL);
	BATaccessEnd(tb,USE_TAIL, MMAP_SEQUENTIAL);
	BATaccessEnd(eb,USE_TAIL, MMAP_SEQUENTIAL);
	bn->T->nonil = (b->T->nonil && tb->T->nonil && eb->T->nonil);
	BATsetcount(bn, p);
	BBPreleaseref(tb->batCacheid);
	BBPreleaseref(eb->batCacheid);
	@:void_wrapup@
}

batifthen_export str CMDifThenElseCst1_@1(int *ret, int *bid, @1 *val, int *eid);
str
CMDifThenElseCst1_@1(int *ret, int *bid, @1 *val, int *eid)
{
	BAT *b, *eb, *bn;
	@1 nilval= (@1) @1_nil, *dst, *ebv;
	bit *t;
	BUN cnt, p;

	@:getBATdescriptor(bid,b,"batcalc.ifThenElse")@
	@:getBATdescriptor(eid,eb,"batcalc.ifThenElse", BBPreleaseref(b->batCacheid);)@
	@:chkSize(b,eb,ifThenElse)@
	@:voidresultBAT(TYPE_@1,"batcalc.ifThenElse")@
	bn->tsorted = FALSE;
    	BATkey(BATmirror(bn), FALSE);

	cnt = BATcount(b);
	t = (bit*) Tloc(b,BUNfirst(b));
	dst = (@1*)Tloc(bn, BUNfirst(bn));
	ebv = (@1*)Tloc(eb, BUNfirst(eb));

	for (p=0; p<cnt; p++) {
		if (t[p] == bit_nil) 
			dst[p] = nilval;
		else if (t[p]) 
			dst[p] = *val;
		else
			dst[p] = ebv[p];
	}
	bn->T->nonil = (b->T->nonil && eb->T->nonil && *val != nilval);
	BATsetcount(bn, p);
	BBPreleaseref(eb->batCacheid);
	@:void_wrapup@
}

batifthen_export str CMDifThenElseCst2_@1(int *ret, int *bid, int *tid, @1 *val);
str
CMDifThenElseCst2_@1(int *ret, int *bid, int *tid, @1 *val)
{
	BAT *b, *tb, *bn;
	@1 nilval= (@1) @1_nil, *dst, *tbv;
	bit *t;
	BUN cnt, p;

	@:getBATdescriptor(bid,b,"batcalc.ifThenElse")@
	@:getBATdescriptor(tid,tb,"batcalc.ifThenElse",BBPreleaseref(b->batCacheid);)@
	@:chkSize(b,tb,ifThenElse)@
	@:voidresultBAT(TYPE_@1,"batcalc.ifThenElse")@
	bn->tsorted = FALSE;
    	BATkey(BATmirror(bn), FALSE);

	cnt = BATcount(b);
	t = (bit*) Tloc(b,BUNfirst(b));
	dst = (@1*)Tloc(bn, BUNfirst(bn));
	tbv = (@1*)Tloc(tb, BUNfirst(tb));
	
	for (p=0; p<cnt; p++) {
		if (t[p] == bit_nil) 
			dst[p] = nilval;
		else if (t[p]) 
			dst[p] = tbv[p];
		else 
			dst[p] = *val;
	}
	bn->T->nonil = (b->T->nonil && tb->T->nonil && *val != nilval);
	BATsetcount(bn, p);
	BBPreleaseref(tb->batCacheid);
	@:void_wrapup@
}
@:ifthenImpl(@1)@
@c
#include "monetdb_config.h"
#include "batifthen.h"

@:ifthenelseImpl(bit)@
@:ifthenelseImpl(chr)@
@:ifthenelseImpl(bte)@
@:ifthenelseImpl(sht)@
@:ifthenelseImpl(int)@
@:ifthenelseImpl(lng)@
@:ifthenelseImpl(flt)@
@:ifthenelseImpl(dbl)@

@= ifthenelseDefault
batifthen_export str CMDifThenElseCst_@1(int *ret, int *bid, @1 *tid, @1 *eid);
str CMDifThenElseCst_@1(int *ret, int *bid, @1 *tid, @1 *eid)
{
	BATiter bi;
	BAT *b, *bn;
	BUN p,q;
	@1 nilval= (@1) @1_nil, *nilptr = &nilval;
	bit *t;

	@:getBATdescriptor(bid,b,"batcalc.ifThenElse")@
	@:resultBAT(@1,"batcalc.ifThenElse")@
	bn->tsorted = FALSE;
    	BATkey(BATmirror(bn), FALSE);

	bi = bat_iterator(b);
	t = (bit*)Tloc(b,BUNfirst(b));

#if @2
	tid = *(@1**)tid;
	eid = *(@1**)eid;
	nilptr = (@1*)nilval;
#endif
	BATaccessBegin(b, USE_HEAD, MMAP_SEQUENTIAL);
	BATloop(b, p, q) {
		if (*t == bit_nil) 
			BUNfastins(bn, BUNhead(bi,p), (ptr)nilptr);
		else if (*t) 
			BUNfastins(bn, BUNhead(bi,p), (ptr) tid);
		else
			BUNfastins(bn, BUNhead(bi,p), (ptr) eid);
		t++;
	}
	BATaccessEnd(b, USE_HEAD, MMAP_SEQUENTIAL);
#if @2
	bn->T->nonil = (b->T->nonil && strcmp((@1)tid,nilval) != 0 && strcmp((@1)eid,nilval) != 0);
#else
	bn->T->nonil = (b->T->nonil && *tid != nilval && *eid != nilval);
#endif
	@:wrapup@
}

batifthen_export str CMDifThenElse_@1(int *ret, int *bid, int *tid, int *eid);
str
CMDifThenElse_@1(int *ret, int *bid, int *tid, int *eid)
{
	BATiter bi, tbi, ebi;
	BAT *b, *tb, *eb, *bn;
	@1 nilval= (@1) @1_nil, *nilptr = &nilval;
	BUN p,q;
	bit *t;

	@:getBATdescriptor(bid,b,"batcalc.ifThenElse")@
	@:getBATdescriptor(tid,tb,"batcalc.ifThenElse",BBPreleaseref(b->batCacheid);)@
	@:getBATdescriptor(eid,eb,"batcalc.ifThenElse", BBPreleaseref(b->batCacheid); BBPreleaseref(tb->batCacheid);)@
	@:chkSize(b,tb,ifThenElse)@
	@:chkSize(b,eb,ifThenElse)@
	@:resultBAT(@1,"batcalc.ifThenElse")@
	bn->tsorted = FALSE;
    	BATkey(BATmirror(bn), FALSE);

	bi = bat_iterator(b);
	tbi = bat_iterator(tb);
	ebi = bat_iterator(eb);

	t = (bit*) Tloc(b, BUNfirst(b));

#if @2
	nilptr = (@1*)nilval;
#endif
	BATaccessBegin(b, USE_HEAD, MMAP_SEQUENTIAL);
	BATaccessBegin(tb, USE_TAIL, MMAP_SEQUENTIAL);
	BATaccessBegin(eb, USE_TAIL, MMAP_SEQUENTIAL);
	BATloop(b, p, q) {
		if (*t == bit_nil) 
			BUNfastins(bn, BUNhead(bi,p), (ptr)nilptr);
		else if (*t) 
			BUNfastins(bn, BUNhead(bi,p), BUNtail(tbi, p));
		else
			BUNfastins(bn, BUNhead(bi,p), BUNtail(ebi, p));
		t++;
	}
	BATaccessEnd(b, USE_HEAD, MMAP_SEQUENTIAL);
	BATaccessEnd(tb, USE_TAIL, MMAP_SEQUENTIAL);
	BATaccessEnd(eb, USE_TAIL, MMAP_SEQUENTIAL);
	bn->T->nonil = (b->T->nonil && tb->T->nonil && eb->T->nonil);
	BBPreleaseref(tb->batCacheid);
	BBPreleaseref(eb->batCacheid);
	@:wrapup@
}

batifthen_export str CMDifThenElseCst1_@1(int *ret, int *bid, @1 *val, int *eid);
str
CMDifThenElseCst1_@1(int *ret, int *bid, @1 *val, int *eid)
{
	BATiter bi, ebi;
	BAT *b, *eb, *bn;
	@1 nilval= (@1) @1_nil, *nilptr = &nilval;
	BUN p,q;
	bit *t;

	@:getBATdescriptor(bid,b,"batcalc.ifThenElse")@
	@:getBATdescriptor(eid,eb,"batcalc.ifThenElse", BBPreleaseref(b->batCacheid);)@
	@:chkSize(b,eb,ifThenElse)@
	@:resultBAT(@1,"batcalc.ifThenElse")@
	bn->tsorted = FALSE;
    	BATkey(BATmirror(bn), FALSE);

	bi = bat_iterator(b);
	ebi = bat_iterator(eb);

	t = (bit*) Tloc(b,BUNfirst(b));

#if @2
	val = *(@1**)val;
	nilptr = (@1*)nilval;
#endif
	BATaccessBegin(b, USE_HEAD, MMAP_SEQUENTIAL);
	BATaccessBegin(eb, USE_TAIL, MMAP_SEQUENTIAL);
	BATloop(b, p, q) {
		if (*t == bit_nil) 
			BUNfastins(bn, BUNhead(bi,p), (ptr)nilptr);
		else if (*t) 
			BUNfastins(bn, BUNhead(bi,p), (ptr) val);
		else
			BUNfastins(bn, BUNhead(bi,p), BUNtail(ebi, p));
		t++;
	}
	BATaccessEnd(b, USE_HEAD, MMAP_SEQUENTIAL);
	BATaccessEnd(eb, USE_TAIL, MMAP_SEQUENTIAL);
#if @2
	bn->T->nonil = (b->T->nonil && eb->T->nonil && strcmp((@1)val,nilval) != 0);
#else
	bn->T->nonil = (b->T->nonil && eb->T->nonil && *val != nilval);
#endif
	BBPreleaseref(eb->batCacheid);
	@:wrapup@
}

batifthen_export str CMDifThenElseCst2_@1(int *ret, int *bid, int *tid, @1 *val);
str
CMDifThenElseCst2_@1(int *ret, int *bid, int *tid, @1 *val)
{
	BATiter bi, tbi;
	BAT *b, *tb, *bn;
	@1 nilval= (@1) @1_nil, *nilptr = &nilval;
	BUN p,q;
	bit *t;

	@:getBATdescriptor(bid,b,"batcalc.ifThenElse")@
	@:getBATdescriptor(tid,tb,"batcalc.ifThenElse",BBPreleaseref(b->batCacheid);)@
	@:chkSize(b,tb,ifThenElse)@
	@:resultBAT(@1,"batcalc.ifThenElse")@
	bn->tsorted = FALSE;
    	BATkey(BATmirror(bn), FALSE);

	bi = bat_iterator(b);
	tbi = bat_iterator(tb);

	t = (bit*) Tloc(b,BUNfirst(b));
	
#if @2
	val = *(@1**)val;
	nilptr = (@1*)nilval;
#endif
	BATaccessBegin(b, USE_HEAD, MMAP_SEQUENTIAL);
	BATaccessBegin(tb, USE_TAIL, MMAP_SEQUENTIAL);
	BATloop(b, p, q) {
		if (*t == bit_nil)
			BUNfastins(bn, BUNhead(bi,p), (ptr)nilptr);
		else if (*t) 
			BUNfastins(bn, BUNhead(bi,p), BUNtail(tbi, p));
		else
			BUNfastins(bn, BUNhead(bi,p), val);
		t++;
	}
	BATaccessEnd(b, USE_HEAD, MMAP_SEQUENTIAL);
	BATaccessEnd(tb, USE_TAIL, MMAP_SEQUENTIAL);
#if @2
	bn->T->nonil = (b->T->nonil && tb->T->nonil && strcmp((@1)val,nilval) != 0);
#else
	bn->T->nonil = (b->T->nonil && tb->T->nonil && *val != nilval);
#endif
	BBPreleaseref(tb->batCacheid);
	@:wrapup@
}
@:ifthenImpl(@1)@
@c
@:ifthenelseDefault(oid,0)@
@:ifthenelseDefault(str,1)@
@}
