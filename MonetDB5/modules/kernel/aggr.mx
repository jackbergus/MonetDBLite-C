@/
The contents of this file are subject to the MonetDB Public License
Version 1.1 (the "License"); you may not use this file except in
compliance with the License. You may obtain a copy of the License at
http://www.monetdb.org/Legal/MonetDBLicense

Software distributed under the License is distributed on an "AS IS"
basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations
under the License.

The Original Code is the MonetDB Database System.

The Initial Developer of the Original Code is CWI.
Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
Copyright August 2008-2012 MonetDB B.V.
All Rights Reserved.
@

@f aggr

@c
/*
 * @a S. Manegold
 * @v 1.0
 * @+ Aggregates Module
 *
 * This module contains some efficient aggregate functions that compute their
 * result in one scan, rather than in the iterative manner of the generic
 * MIL aggregrate implementations.
 *
 * The implementation code is derived from the original 'aggr' module.
 * It uses a complete type-specific code expansion to avoid any type-checking
 * in the inner-most loops.
 * Where feasible, it replaced (expensive) hash-lookup by significantly cheaper positional
 * void-lookups (if the head-column of the group-extend BAT ("e") is "void") or at least by
 * (also positional) array lookups (in case the group-ids span a reasonably small range);
 *
 * In addition to the 2-parameter @{ { } @{ } }(BAT[oid,any::1] b, BAT[oid,any] e)
 * functions, there are now also 3-parameter @{ { } @{ } }(BAT[void,any::1] b,
 * BAT[void,oid] g, BAT[oid,any] e) functions, that require b & g to be
 * head-aligned, and do the fetchjoin(reverse(g),b) on-the-fly;
 *
 * The routines should not be stored in their own module, but
 * added to the 'group' module. This can be achieved by setting
 * the module.
 */
@mal
module aggr;
@= sumprod_signatures
command sum(b:bat[:oid,:@1], e:bat[:oid,:any_1]) :bat[:oid,:@2] 
address AGGRsum2_@2
comment "Sum over grouped tail sum on @1";

command sum(b:bat[:oid,:@1],g:bat[:oid,:oid],e:bat[:oid,:any_1])
		:bat[:oid,:@2]
address AGGRsum3_@2
comment "Grouped tail sum on @1";

command subsum(b:bat[:oid,:@1],g:bat[:oid,:oid],e:bat[:oid,:any_1],skip_nils:int,abort_on_error:int) :bat[:oid,:@2]
address AGGRsubsum_@2
comment "Grouped sum aggregate";

command subsum(b:bat[:oid,:@1],g:bat[:oid,:oid],e:bat[:oid,:any_1],s:bat[:oid,:oid],skip_nils:int,abort_on_error:int) :bat[:oid,:@2]
address AGGRsubsumcand_@2
comment "Grouped sum aggregate with candidates list";

command product(b:bat[:oid,:@1], e:bat[:oid,:any_1]) :bat[:oid,:@2] 
address AGGRprod2_@2
comment "Product over grouped tail product on @1";

command product(b:bat[:oid,:@1],g:bat[:oid,:oid],e:bat[:oid,:any_1])
		:bat[:oid,:@2]
address AGGRprod3_@2
comment "Grouped tail product on @1";

command subprod(b:bat[:oid,:@1],g:bat[:oid,:oid],e:bat[:oid,:any_1],skip_nils:int,abort_on_error:int) :bat[:oid,:@2]
address AGGRsubprod_@2
comment "Grouped product aggregate";

command subprod(b:bat[:oid,:@1],g:bat[:oid,:oid],e:bat[:oid,:any_1],s:bat[:oid,:oid],skip_nils:int,abort_on_error:int) :bat[:oid,:@2]
address AGGRsubprodcand_@2
comment "Grouped product aggregate with candidates list";

@
@mal
@:sumprod_signatures(bte,bte)@
@:sumprod_signatures(bte,sht)@
@:sumprod_signatures(bte,int)@
@:sumprod_signatures(bte,wrd)@
@:sumprod_signatures(bte,lng)@
@:sumprod_signatures(sht,sht)@
@:sumprod_signatures(sht,int)@
@:sumprod_signatures(sht,wrd)@
@:sumprod_signatures(sht,lng)@
@:sumprod_signatures(int,int)@
@:sumprod_signatures(int,wrd)@
@:sumprod_signatures(int,lng)@
@:sumprod_signatures(wrd,wrd)@
@:sumprod_signatures(wrd,lng)@
@:sumprod_signatures(lng,wrd)@
@:sumprod_signatures(lng,lng)@
@:sumprod_signatures(flt,flt)@
@:sumprod_signatures(flt,dbl)@
@:sumprod_signatures(dbl,dbl)@

@= sum_avg_signatures
command avg(b:bat[:oid,:@1], e:bat[:oid,:any_1]) :bat[:oid,:dbl] 
address AGGRavg2_dbl
comment "Grouped tail average on @1";

command avg(b:bat[:oid,:@1], g:bat[:oid,:oid], e:bat[:oid,:any_1]):bat[:oid,:dbl] 
address AGGRavg3_dbl
comment "Grouped tail average on @1";

command subavg(b:bat[:oid,:@1],g:bat[:oid,:oid],e:bat[:oid,:any_1],skip_nils:int,abort_on_error:int) :bat[:oid,:dbl]
address AGGRsubavg_dbl
comment "Grouped avg aggregate";

command subavg(b:bat[:oid,:@1],g:bat[:oid,:oid],e:bat[:oid,:any_1],s:bat[:oid,:oid],skip_nils:int,abort_on_error:int) :bat[:oid,:dbl]
address AGGRsubavgcand_dbl
comment "Grouped avg aggregate with candidates list";

@
@mal
# We may have to extend the signatures to all possible {void,oid} combos
@:sum_avg_signatures(bte)@
@:sum_avg_signatures(sht)@
@:sum_avg_signatures(int)@
@:sum_avg_signatures(wrd)@
@:sum_avg_signatures(lng)@
@:sum_avg_signatures(flt)@
@:sum_avg_signatures(dbl)@

command min(b:bat[:oid,:any_1], e:bat[:oid,:any_2]) :bat[:oid,:any_1] 
address AX3aggrX3_min;

command max(b:bat[:oid,:any_1], e:bat[:oid,:any_2]) :bat[:oid,:any_1] 
address AX3aggrX3_max;

command min(b:bat[:oid,:any_1],g:bat[:oid,:oid],e:bat[:oid,:any_2]):bat[:oid,:any_1]
address AX3aggrX3_min3;

command max(b:bat[:oid,:any_1], g:bat[:oid,:oid], e:bat[:oid,:any_2]) 
		:bat[:oid,:any_1] 
address AX3aggrX3_max3;

command count(b:bat[:oid,:any_1], e:bat[:oid,:any_2], ignorenils:bit)
	:bat[:oid,:wrd] 
address AX3aggrX3_count
comment "Grouped count";

command count(b:bat[:oid,:any_1], g:bat[:oid,:oid], e:bat[:oid,:any_2], 
		nonils:bit) :bat[:void,:wrd] 
address AX3aggrX3_count3;

command size(b:bat[:void,:bit], e:bat[:void,:any_1]) :bat[:void,:wrd] 
address AX3aggrX3_size
comment "Grouped count of true values";

command count(b:bat[:void,:any_1], e:bat[:oid,:any_2]) :bat[:void,:wrd] 
address AX3aggrX3_count2Nils
comment "Grouped count";
command count(b:bat[:void,:any_1], e:bat[:void,:any_2]) :bat[:void,:wrd] 
address AX3aggrX3_count2Nils;

command count_no_nil(b:bat[:oid,:any_1],e:bat[:oid,:any_1]):bat[:oid,:wrd]
address AX3count_no_nil2;

command count(b:bat[:oid,:any_1], g:bat[:oid,:oid], e:bat[:oid,:any_2])
	:bat[:oid,:wrd] 
address AX3aggrX3_count3Nils
comment "Grouped count";

command count_no_nil(b:bat[:oid,:any_1],g:bat[:oid,:oid],e:bat[:oid,:any_2])
	:bat[:oid,:wrd]
address AX3count_no_nil3;

@h
/*
 * @+ Implementation
 * These implementations need just one scan and a simple hash-maintained data
 * structure to compute a group of common aggregates.
 *
 * With group OIDs spanning a range of less than SMALL_AGGR_MAX (the actual
 * number of groups might be even less, in case there are "holes" in the group
 * OID range), we use a simple array as temporary sum/cnt table on order to
 * benefit from positional lookups; with size of sum <= 8 bytes and size of
 * cnt == 4 bytes, we stay below 16 KBytes, i.e., within (almost) any L1 cache.
 */
#define SMALL_AGGR_MAX 1024

/*
 * The macro CHKrange is just for array-lookups, analogously to BUNfndVOID &
 * HASHfnd_oid for void- and hash-lookups, respectively
 */
/* if the test succeeds, we must return something not equal to
   BUN_NONE, but the actual value doesn't matter since it is not
   otherwise used */
#define CHKrange(r, bn, h)	r = (BUN)(*(oid*)(h) >= min && *(oid*)(h) <= max ? 0 : BUN_NONE)

/*
 * In case the group OIDs span a range of more than SMALL_AGGR_MAX,
 * but the number of groups is less than SCAN_AGGR_MAX,
 * we use (backward-) "scan"-lookup (unrolled implementation exploiting
 * fall-through in C's switch statment) instead of hash-lookup,
 * as the latter turned out to be rather expensive ...
 */
#define SCAN_AGGR_MAX 8

#define SCAN_aggr_init \
	oid _h; \
	BUN _j = BATcount(bn); \
	oid *_bnh = (oid*) Hloc(bn, BUNfirst(bn)); \
	BUN _r = BUNfirst(bn);

#define SCANfndOID(r, bn, h)	\
	_h = *(oid*)(h), _j = BATcount(bn.b);         \
	r = BUN_NONE;                                     \
	switch (_j) {                                     \
	case 8: if (_bnh[7] == _h) { r = _r + 7; break; } \
	case 7: if (_bnh[6] == _h) { r = _r + 6; break; } \
	case 6: if (_bnh[5] == _h) { r = _r + 5; break; } \
	case 5: if (_bnh[4] == _h) { r = _r + 4; break; } \
	case 4: if (_bnh[3] == _h) { r = _r + 3; break; } \
	case 3: if (_bnh[2] == _h) { r = _r + 2; break; } \
	case 2: if (_bnh[1] == _h) { r = _r + 1; break; } \
	case 1: if (_bnh[0] == _h) { r = _r + 0; break; } \
	}

/*
 * In case the head of the group extend (e) is sorted, we assume that also the
 * the tail of the group map (g) is "almost" sorted or "mostly ascending" ---
 * or at least clustered such that group IDs in cluster i are smaller than
 * those in cluster i+1; this is the case if the first grouping attribute
 * (column/BAT) is sorted --- and resorted to "local scanning" rather than
 * (inherently random and expensive) hash-lookups.
 * Lacking a suitable and efficient way to detect that the tail of the group
 * map (g) is "almost sorted" or "mostly ascending", we require that the tail
 * of the group map (g) is sorted --- the "local scanning" performs much worse
 * than hash-lookups in case the tail of the group map (g) is in random order.
 */
#define MERGE_aggr_init						\
	BUN _i = 0, _j = BATcount(bn), _r = BUNfirst(bn);	\
	oid _h, *_bnh = (oid*) Hloc(bn, _r);		\
	if (_j > 0)						\
		_j--;

#define MERGEfndOID(r, bn, h)				\
	_h = *(oid*)(h);				\
	r = BUN_NONE;					\
	if (min <= _h && _h <= max ) {			\
		while ( _i < _j && _bnh[_i] < _h)	\
			_i++;				\
		while ( _i > 0 && _bnh[_i] > _h)	\
			_i--;				\
		if (_bnh[_i] == _h)			\
			r = _i + _r;			\
	}

/*
#define _MERGE_aggr_init					\
	BUN _i = 0, _j = BATcount(bn), _r = BUNfirst(bn);	\
	oid _h, *_bnh = (oid*) Hloc(bn, _r);		\
	dbl s = (dbl)_j / (dbl)range;				\
	if (_j > 0)						\
		_j--;

#define _MERGEfndOID(r, bn, h)				\
	_h = *(oid*)(h);				\
	r = BUN_NONE;					\
	if (min <= _h && _h <= max ) {			\
		_i = (BUN)((_h - min) * s);		\
		while ( _i < _j && _bnh[_i] < _h)	\
			_i++;				\
		while ( _i > 0 && _bnh[_i] > _h)	\
			_i--;				\
		if (_bnh[_i] == _h)			\
			r = _i + _r;			\
	}
*/

@c
/*
 * @- Wrapper
 * The remainder is a wrapper around the V4 code base.
 */
#include "monetdb_config.h"
@(
#include <gdk.h>
@)

#include "mal.h"
#include "mal_exception.h"
#include "aggr_be_minmax.h"
#include "aggr_be_count.h"
#include "aggr_bge_minmax.h"
#include "aggr_bge_count.h"

#ifdef WIN32
#if !defined(LIBMAL) && !defined(LIBATOMS) && !defined(LIBKERNEL) && !defined(LIBMAL) && !defined(LIBOPTIMIZER) && !defined(LIBSCHEDULER) && !defined(LIBMONETDB5)
#define aggr_export extern __declspec(dllimport)
#else
#define aggr_export extern __declspec(dllexport)
#endif
#else
#define aggr_export extern
#endif

/*
 * @- "Extremes" (Min & Max)
 */
@= AX3extreme
aggr_export str AX3aggrX3_@1(int *ret, int *bid, int *eid);
str AX3aggrX3_@1(int *ret, int *bid, int *eid){
	BAT *b, *e, *bn;
	if( (b= BATdescriptor(*bid)) == NULL ){
		throw(MAL, "aggr.@1", RUNTIME_OBJECT_MISSING);
	}
	if( (e= BATdescriptor(*eid)) == NULL ){
		BBPreleaseref(b->batCacheid);
		throw(MAL, "aggr.@1", RUNTIME_OBJECT_MISSING);
	}

	if( CMDaggrX3_@1(&bn,b,e) == GDK_SUCCEED){
		if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ); 
		*ret = bn->batCacheid;
		BBPkeepref(*ret);
		BBPreleaseref(b->batCacheid);
		BBPreleaseref(e->batCacheid);
		return MAL_SUCCEED;
	}
	BBPreleaseref(b->batCacheid);
	BBPreleaseref(e->batCacheid);
	throw(MAL, "aggrX3_@1",GDK_EXCEPTION);
}
@
@c
@:AX3extreme(min,<)@
@:AX3extreme(max,>)@

/*
 * @- Count
 */
aggr_export str AX3aggrX3_count(int *retid, int *bid, int *eid, bit *ignore_nils);
str
AX3aggrX3_count(int *retid, int *bid, int *eid, bit *ignore_nils)
{
	BAT *b, *e, *bn;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "aggr.count", RUNTIME_OBJECT_MISSING);
	}
	if ((e = BATdescriptor(*eid)) == NULL) {
		BBPreleaseref(b->batCacheid);
		throw(MAL, "aggr.count", RUNTIME_OBJECT_MISSING);
	}

	if (CMDaggrX3_count(&bn, b, e, ignore_nils) == GDK_SUCCEED) {
		if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ); 
		*retid = bn->batCacheid;
		BBPkeepref(*retid);
		BBPreleaseref(b->batCacheid);
		BBPreleaseref(e->batCacheid);
		return MAL_SUCCEED;
	}
	BBPreleaseref(b->batCacheid);
	BBPreleaseref(e->batCacheid);
	throw(MAL, "aggrX3_count", GDK_EXCEPTION);
}

/*
 * @- Size
 */
aggr_export str AX3aggrX3_size(int *retid, int *bid, int *eid);
str
AX3aggrX3_size(int *retid, int *bid, int *eid)
{
	BAT *b, *e;
	BAT *bn;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "aggr.size", RUNTIME_OBJECT_MISSING);
	}
	if ((e = BATdescriptor(*eid)) == NULL) {
		BBPreleaseref(b->batCacheid);
		throw(MAL, "aggr.size", RUNTIME_OBJECT_MISSING);
	}
	if (CMDaggrX3_size(&bn, b, e) == GDK_SUCCEED) {
		if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ); 
		*retid = bn->batCacheid;
		BBPkeepref(*retid);
		BBPreleaseref(b->batCacheid);
		BBPreleaseref(e->batCacheid);
		return MAL_SUCCEED;
	}
	BBPreleaseref(b->batCacheid);
	BBPreleaseref(e->batCacheid);
	throw(MAL, "aggrX3_size", GDK_EXCEPTION);
}

/*
 * @- Sum & Average & Prod
 */
static str
AGGRgrouped(bat *retval, BAT *b, BAT *g, BAT *e, int tp,
			BAT *(*grpfunc)(BAT *, BAT *, BAT *, BAT *, int, int, int),
			const char *malfunc)
{
	BAT *bn, *t, *map;

	if (b == NULL || g == NULL || e == NULL) {
		if (b)
			BBPreleaseref(b->batCacheid);
		if (g)
			BBPreleaseref(g->batCacheid);
		if (e)
			BBPreleaseref(e->batCacheid);
		throw(MAL, malfunc, RUNTIME_OBJECT_MISSING);
	}
	if (!BAThdense(b) || !BAThdense(g)) {
		/* if b or g don't have a dense head, replace the head with a
		 * dense sequence */
		t = BATjoin(BATmirror(b), g, MIN(BATcount(b), BATcount(g)));
		BBPreleaseref(b->batCacheid);
		BBPreleaseref(g->batCacheid);
		b = BATmirror(BATmark(t, 0));
		g = BATmirror(BATmark(BATmirror(t), 0));
		BBPreleaseref(t->batCacheid);
	}
	if (b->hseqbase != g->hseqbase || BATcount(b) != BATcount(g)) {
		/* b and g are not aligned: align them by creating a view on
		 * one or the other */
		oid min;				/* lowest common oid */
		oid max;				/* highest common oid */
		min = b->hseqbase;
		if (min < g->hseqbase)
			min = g->hseqbase;
		max = b->hseqbase + BATcount(b);
		if (g->hseqbase + BATcount(g) < max)
			max = g->hseqbase + BATcount(g);
		if (b->hseqbase != min || b->hseqbase + BATcount(b) != max) {
			if (min >= max)
				min = max = b->hseqbase;
			t = BATslice(b, BUNfirst(b) + (BUN) (min - b->hseqbase),
						 BUNfirst(b) + (BUN) (max - b->hseqbase));
			BBPreleaseref(b->batCacheid);
			b = t;
		}
		if (g->hseqbase != min || g->hseqbase + BATcount(g) != max) {
			if (min >= max)
				min = max = g->hseqbase;
			t = BATslice(g, BUNfirst(g) + (BUN) (min - g->hseqbase),
						 BUNfirst(g) + (BUN) (max - g->hseqbase));
			BBPreleaseref(g->batCacheid);
			g = t;
		}
	}
	if (!BAThdense(e)) {
		/* if e doesn't have a dense head, renumber the group ids with
		 * a dense sequence at the cost of some left joins */
		map = BATmark(e, 0);	/* [gid,newgid(dense)] */
		BBPreleaseref(e->batCacheid);
		e = BATmirror(map);		/* [newgid(dense),gid] */
		t = BATleftjoin(g, map, BATcount(g)); /* [oid,newgid] */
		BBPreleaseref(g->batCacheid);
		g = t;
	} else {
		map = NULL;
	}
	bn = (*grpfunc)(b, g, e, NULL, tp, 1, 1);
	BBPreleaseref(b->batCacheid);
	BBPreleaseref(g->batCacheid);
	if (map == NULL)			/* if map!=NULL, e is mirror of map */
		BBPreleaseref(e->batCacheid);
	if (bn == NULL) {
		char *errbuf = GDKerrbuf;
		char *s;

		if (map)
			BBPreleaseref(map->batCacheid);

		if (errbuf && *errbuf) {
			if (strncmp(errbuf, "!ERROR: ", 8) == 0)
				errbuf += 8;
			if (strchr(errbuf, '!') == errbuf + 5) {
				s = createException(MAL, malfunc, "%s", errbuf);
			} else if ((s = strchr(errbuf, ':')) != NULL && s[1] == ' ') {
				s = createException(MAL, malfunc, "%s", s + 2);
			} else {
				s = createException(MAL, malfunc, "%s", errbuf);
			}
			*GDKerrbuf = 0;
			return s;
		}
		throw(MAL, malfunc, OPERATION_FAILED);
	}
	if (map) {
		t = BATleftjoin(map, bn, BATcount(bn));
		BBPreleaseref(map->batCacheid);
		BBPreleaseref(bn->batCacheid);
		bn = t;
	}
	*retval = bn->batCacheid;
	BBPkeepref(bn->batCacheid);
	return MAL_SUCCEED;
}

static str
AGGRgrouped3(bat *retval, bat *bid, bat *gid, bat *eid, int tp,
			 BAT *(*grpfunc)(BAT *, BAT *, BAT *, BAT *, int, int, int),
			 const char *malfunc)
{
	BAT *b, *g, *e;

	b = BATdescriptor(*bid);	/* [head,value] */
	g = BATdescriptor(*gid);	/* [head,gid] */
	e = BATdescriptor(*eid);	/* [gid,any] */
	return AGGRgrouped(retval, b, g, e, tp, grpfunc, malfunc);
}

static str
AGGRgrouped2(bat *retval, bat *bid, bat *eid, int tp,
			 BAT *(*grpfunc)(BAT *, BAT *, BAT *, BAT *, int, int, int),
			 const char *malfunc)
{
	BAT *b, *g, *e;

	b = BATdescriptor(*bid);	/* [gid,value] */
	if (b == NULL)
		throw(MAL, "aggr.sum", RUNTIME_OBJECT_MISSING);
	g = BATmirror(BATmark(b, 0)); /* [dense,gid] */
	e = BATmirror(BATmark(BATmirror(b), 0)); /* [dense,value] */
	BBPreleaseref(b->batCacheid);
	b = e;
	e = BATdescriptor(*eid);	/* [gid,any] */
	return AGGRgrouped(retval, b, g, e, tp, grpfunc, malfunc);
}

aggr_export str AGGRsum3_bte(bat *retval, bat *bid, bat *gid, bat *eid);
str
AGGRsum3_bte(bat *retval, bat *bid, bat *gid, bat *eid)
{
	return AGGRgrouped3(retval, bid, gid, eid, TYPE_bte,
						BATgroupsum, "aggr.sum");
}

aggr_export str AGGRsum3_sht(bat *retval, bat *bid, bat *gid, bat *eid);
str
AGGRsum3_sht(bat *retval, bat *bid, bat *gid, bat *eid)
{
	return AGGRgrouped3(retval, bid, gid, eid, TYPE_sht,
						BATgroupsum, "aggr.sum");
}

aggr_export str AGGRsum3_int(bat *retval, bat *bid, bat *gid, bat *eid);
str
AGGRsum3_int(bat *retval, bat *bid, bat *gid, bat *eid)
{
	return AGGRgrouped3(retval, bid, gid, eid, TYPE_int,
						BATgroupsum, "aggr.sum");
}

aggr_export str AGGRsum3_wrd(bat *retval, bat *bid, bat *gid, bat *eid);
str
AGGRsum3_wrd(bat *retval, bat *bid, bat *gid, bat *eid)
{
	return AGGRgrouped3(retval, bid, gid, eid, TYPE_wrd,
						BATgroupsum, "aggr.sum");
}

aggr_export str AGGRsum3_lng(bat *retval, bat *bid, bat *gid, bat *eid);
str
AGGRsum3_lng(bat *retval, bat *bid, bat *gid, bat *eid)
{
	return AGGRgrouped3(retval, bid, gid, eid, TYPE_lng,
						BATgroupsum, "aggr.sum");
}

aggr_export str AGGRsum3_flt(bat *retval, bat *bid, bat *gid, bat *eid);
str
AGGRsum3_flt(bat *retval, bat *bid, bat *gid, bat *eid)
{
	return AGGRgrouped3(retval, bid, gid, eid, TYPE_flt,
						BATgroupsum, "aggr.sum");
}

aggr_export str AGGRsum3_dbl(bat *retval, bat *bid, bat *gid, bat *eid);
str
AGGRsum3_dbl(bat *retval, bat *bid, bat *gid, bat *eid)
{
	return AGGRgrouped3(retval, bid, gid, eid, TYPE_dbl,
						BATgroupsum, "aggr.sum");
}

aggr_export str AGGRsum2_bte(bat *retval, bat *bid, bat *eid);
str
AGGRsum2_bte(bat *retval, bat *bid, bat *eid)
{
	return AGGRgrouped2(retval, bid, eid, TYPE_bte, BATgroupsum, "aggr.sum");
}

aggr_export str AGGRsum2_sht(bat *retval, bat *bid, bat *eid);
str
AGGRsum2_sht(bat *retval, bat *bid, bat *eid)
{
	return AGGRgrouped2(retval, bid, eid, TYPE_sht, BATgroupsum, "aggr.sum");
}

aggr_export str AGGRsum2_int(bat *retval, bat *bid, bat *eid);
str
AGGRsum2_int(bat *retval, bat *bid, bat *eid)
{
	return AGGRgrouped2(retval, bid, eid, TYPE_int, BATgroupsum, "aggr.sum");
}

aggr_export str AGGRsum2_wrd(bat *retval, bat *bid, bat *eid);
str
AGGRsum2_wrd(bat *retval, bat *bid, bat *eid)
{
	return AGGRgrouped2(retval, bid, eid, TYPE_wrd, BATgroupsum, "aggr.sum");
}

aggr_export str AGGRsum2_lng(bat *retval, bat *bid, bat *eid);
str
AGGRsum2_lng(bat *retval, bat *bid, bat *eid)
{
	return AGGRgrouped2(retval, bid, eid, TYPE_lng, BATgroupsum, "aggr.sum");
}

aggr_export str AGGRsum2_flt(bat *retval, bat *bid, bat *eid);
str
AGGRsum2_flt(bat *retval, bat *bid, bat *eid)
{
	return AGGRgrouped2(retval, bid, eid, TYPE_flt, BATgroupsum, "aggr.sum");
}

aggr_export str AGGRsum2_dbl(bat *retval, bat *bid, bat *eid);
str
AGGRsum2_dbl(bat *retval, bat *bid, bat *eid)
{
	return AGGRgrouped2(retval, bid, eid, TYPE_dbl, BATgroupsum, "aggr.sum");
}

aggr_export str AGGRprod3_bte(bat *retval, bat *bid, bat *gid, bat *eid);
str
AGGRprod3_bte(bat *retval, bat *bid, bat *gid, bat *eid)
{
	return AGGRgrouped3(retval, bid, gid, eid, TYPE_bte,
						BATgroupprod, "aggr.prod");
}

aggr_export str AGGRprod3_sht(bat *retval, bat *bid, bat *gid, bat *eid);
str
AGGRprod3_sht(bat *retval, bat *bid, bat *gid, bat *eid)
{
	return AGGRgrouped3(retval, bid, gid, eid, TYPE_sht,
						BATgroupprod, "aggr.prod");
}

aggr_export str AGGRprod3_int(bat *retval, bat *bid, bat *gid, bat *eid);
str
AGGRprod3_int(bat *retval, bat *bid, bat *gid, bat *eid)
{
	return AGGRgrouped3(retval, bid, gid, eid, TYPE_int,
						BATgroupprod, "aggr.prod");
}

aggr_export str AGGRprod3_wrd(bat *retval, bat *bid, bat *gid, bat *eid);
str
AGGRprod3_wrd(bat *retval, bat *bid, bat *gid, bat *eid)
{
	return AGGRgrouped3(retval, bid, gid, eid, TYPE_wrd,
						BATgroupprod, "aggr.prod");
}

aggr_export str AGGRprod3_lng(bat *retval, bat *bid, bat *gid, bat *eid);
str
AGGRprod3_lng(bat *retval, bat *bid, bat *gid, bat *eid)
{
	return AGGRgrouped3(retval, bid, gid, eid, TYPE_lng,
						BATgroupprod, "aggr.prod");
}

aggr_export str AGGRprod3_flt(bat *retval, bat *bid, bat *gid, bat *eid);
str
AGGRprod3_flt(bat *retval, bat *bid, bat *gid, bat *eid)
{
	return AGGRgrouped3(retval, bid, gid, eid, TYPE_flt,
						BATgroupprod, "aggr.prod");
}

aggr_export str AGGRprod3_dbl(bat *retval, bat *bid, bat *gid, bat *eid);
str
AGGRprod3_dbl(bat *retval, bat *bid, bat *gid, bat *eid)
{
	return AGGRgrouped3(retval, bid, gid, eid, TYPE_dbl,
						BATgroupprod, "aggr.prod");
}

aggr_export str AGGRprod2_bte(bat *retval, bat *bid, bat *eid);
str
AGGRprod2_bte(bat *retval, bat *bid, bat *eid)
{
	return AGGRgrouped2(retval, bid, eid, TYPE_bte, BATgroupprod, "aggr.prod");
}

aggr_export str AGGRprod2_sht(bat *retval, bat *bid, bat *eid);
str
AGGRprod2_sht(bat *retval, bat *bid, bat *eid)
{
	return AGGRgrouped2(retval, bid, eid, TYPE_sht, BATgroupprod, "aggr.prod");
}

aggr_export str AGGRprod2_int(bat *retval, bat *bid, bat *eid);
str
AGGRprod2_int(bat *retval, bat *bid, bat *eid)
{
	return AGGRgrouped2(retval, bid, eid, TYPE_int, BATgroupprod, "aggr.prod");
}

aggr_export str AGGRprod2_wrd(bat *retval, bat *bid, bat *eid);
str
AGGRprod2_wrd(bat *retval, bat *bid, bat *eid)
{
	return AGGRgrouped2(retval, bid, eid, TYPE_wrd, BATgroupprod, "aggr.prod");
}

aggr_export str AGGRprod2_lng(bat *retval, bat *bid, bat *eid);
str
AGGRprod2_lng(bat *retval, bat *bid, bat *eid)
{
	return AGGRgrouped2(retval, bid, eid, TYPE_lng, BATgroupprod, "aggr.prod");
}

aggr_export str AGGRprod2_flt(bat *retval, bat *bid, bat *eid);
str
AGGRprod2_flt(bat *retval, bat *bid, bat *eid)
{
	return AGGRgrouped2(retval, bid, eid, TYPE_flt, BATgroupprod, "aggr.prod");
}

aggr_export str AGGRprod2_dbl(bat *retval, bat *bid, bat *eid);
str
AGGRprod2_dbl(bat *retval, bat *bid, bat *eid)
{
	return AGGRgrouped2(retval, bid, eid, TYPE_dbl, BATgroupprod, "aggr.prod");
}

aggr_export str AGGRavg3_dbl(bat *retval, bat *bid, bat *gid, bat *eid);
str
AGGRavg3_dbl(bat *retval, bat *bid, bat *gid, bat *eid)
{
	return AGGRgrouped3(retval, bid, gid, eid, TYPE_dbl,
						BATgroupavg, "aggr.avg");
}

aggr_export str AGGRavg2_dbl(bat *retval, bat *bid, bat *eid);
str
AGGRavg2_dbl(bat *retval, bat *bid, bat *eid)
{
	return AGGRgrouped2(retval, bid, eid, TYPE_dbl, BATgroupavg, "aggr.avg");
}

static str
AGGRsubgrouped(bat *retval, bat *bid, bat *gid, bat *eid, bat *sid,
			   int *skip_nils, int *abort_on_error, int tp,
			   BAT *(*grpfunc)(BAT *, BAT *, BAT *, BAT *, int, int, int),
			   const char *malfunc)
{
	BAT *b, *g, *e, *s, *bn;

	b = BATdescriptor(*bid);
	g = BATdescriptor(*gid);
	e = BATdescriptor(*eid);
	if (b == NULL || g == NULL || e == NULL) {
		if (b)
			BBPreleaseref(b->batCacheid);
		if (g)
			BBPreleaseref(g->batCacheid);
		if (e)
			BBPreleaseref(e->batCacheid);
		throw(MAL, malfunc, RUNTIME_OBJECT_MISSING);
	}
	if (sid) {
		s = BATdescriptor(*sid);
		if (s == NULL) {
			BBPreleaseref(b->batCacheid);
			BBPreleaseref(g->batCacheid);
			BBPreleaseref(e->batCacheid);
			throw(MAL, malfunc, RUNTIME_OBJECT_MISSING);
		}
	} else {
		s = NULL;
	}
	bn = (grpfunc)(b, g, e, s, tp, *skip_nils, *abort_on_error);
	BBPreleaseref(b->batCacheid);
	BBPreleaseref(g->batCacheid);
	BBPreleaseref(e->batCacheid);
	if (s)
		BBPreleaseref(s->batCacheid);
	if (bn == NULL) {
		char *errbuf = GDKerrbuf;
		char *s;

		if (errbuf && *errbuf) {
			if (strncmp(errbuf, "!ERROR: ", 8) == 0)
				errbuf += 8;
			if (strchr(errbuf, '!') == errbuf + 5) {
				s = createException(MAL, malfunc, "%s", errbuf);
			} else if ((s = strchr(errbuf, ':')) != NULL && s[1] == ' ') {
				s = createException(MAL, malfunc, "%s", s + 2);
			} else {
				s = createException(MAL, malfunc, "%s", errbuf);
			}
			*GDKerrbuf = 0;
			return s;
		}
		throw(MAL, malfunc, OPERATION_FAILED);
	}
	*retval = bn->batCacheid;
	BBPkeepref(bn->batCacheid);
	return MAL_SUCCEED;
}

aggr_export str AGGRsubsum_bte(bat *retval, bat *bid, bat *gid, bat *eid, int *skip_nils, int *abort_on_error);
str
AGGRsubsum_bte(bat *retval, bat *bid, bat *gid, bat *eid, int *skip_nils, int *abort_on_error)
{
	return AGGRsubgrouped(retval, bid, gid, eid, NULL, skip_nils,
						  abort_on_error, TYPE_bte, BATgroupsum, "aggr.subsum");
}

aggr_export str AGGRsubsum_sht(bat *retval, bat *bid, bat *gid, bat *eid, int *skip_nils, int *abort_on_error);
str
AGGRsubsum_sht(bat *retval, bat *bid, bat *gid, bat *eid, int *skip_nils, int *abort_on_error)
{
	return AGGRsubgrouped(retval, bid, gid, eid, NULL, skip_nils,
						  abort_on_error, TYPE_sht, BATgroupsum, "aggr.subsum");
}

aggr_export str AGGRsubsum_int(bat *retval, bat *bid, bat *gid, bat *eid, int *skip_nils, int *abort_on_error);
str
AGGRsubsum_int(bat *retval, bat *bid, bat *gid, bat *eid, int *skip_nils, int *abort_on_error)
{
	return AGGRsubgrouped(retval, bid, gid, eid, NULL, skip_nils,
						  abort_on_error, TYPE_int, BATgroupsum, "aggr.subsum");
}

aggr_export str AGGRsubsum_wrd(bat *retval, bat *bid, bat *gid, bat *eid, int *skip_nils, int *abort_on_error);
str
AGGRsubsum_wrd(bat *retval, bat *bid, bat *gid, bat *eid, int *skip_nils, int *abort_on_error)
{
	return AGGRsubgrouped(retval, bid, gid, eid, NULL, skip_nils,
						  abort_on_error, TYPE_wrd, BATgroupsum, "aggr.subsum");
}

aggr_export str AGGRsubsum_lng(bat *retval, bat *bid, bat *gid, bat *eid, int *skip_nils, int *abort_on_error);
str
AGGRsubsum_lng(bat *retval, bat *bid, bat *gid, bat *eid, int *skip_nils, int *abort_on_error)
{
	return AGGRsubgrouped(retval, bid, gid, eid, NULL, skip_nils,
						  abort_on_error, TYPE_lng, BATgroupsum, "aggr.subsum");
}

aggr_export str AGGRsubsum_flt(bat *retval, bat *bid, bat *gid, bat *eid, int *skip_nils, int *abort_on_error);
str
AGGRsubsum_flt(bat *retval, bat *bid, bat *gid, bat *eid, int *skip_nils, int *abort_on_error)
{
	return AGGRsubgrouped(retval, bid, gid, eid, NULL, skip_nils,
						  abort_on_error, TYPE_flt, BATgroupsum, "aggr.subsum");
}

aggr_export str AGGRsubsum_dbl(bat *retval, bat *bid, bat *gid, bat *eid, int *skip_nils, int *abort_on_error);
str
AGGRsubsum_dbl(bat *retval, bat *bid, bat *gid, bat *eid, int *skip_nils, int *abort_on_error)
{
	return AGGRsubgrouped(retval, bid, gid, eid, NULL, skip_nils,
						  abort_on_error, TYPE_dbl, BATgroupsum, "aggr.subsum");
}

aggr_export str AGGRsubsumcand_bte(bat *retval, bat *bid, bat *gid, bat *eid, bat *sid, int *skip_nils, int *abort_on_error);
str
AGGRsubsumcand_bte(bat *retval, bat *bid, bat *gid, bat *eid, bat *sid, int *skip_nils, int *abort_on_error)
{
	return AGGRsubgrouped(retval, bid, gid, eid, sid, skip_nils,
						  abort_on_error, TYPE_bte, BATgroupsum, "aggr.subsum");
}

aggr_export str AGGRsubsumcand_sht(bat *retval, bat *bid, bat *gid, bat *eid, bat *sid, int *skip_nils, int *abort_on_error);
str
AGGRsubsumcand_sht(bat *retval, bat *bid, bat *gid, bat *eid, bat *sid, int *skip_nils, int *abort_on_error)
{
	return AGGRsubgrouped(retval, bid, gid, eid, sid, skip_nils,
						  abort_on_error, TYPE_sht, BATgroupsum, "aggr.subsum");
}

aggr_export str AGGRsubsumcand_int(bat *retval, bat *bid, bat *gid, bat *eid, bat *sid, int *skip_nils, int *abort_on_error);
str
AGGRsubsumcand_int(bat *retval, bat *bid, bat *gid, bat *eid, bat *sid, int *skip_nils, int *abort_on_error)
{
	return AGGRsubgrouped(retval, bid, gid, eid, sid, skip_nils,
						  abort_on_error, TYPE_int, BATgroupsum, "aggr.subsum");
}

aggr_export str AGGRsubsumcand_wrd(bat *retval, bat *bid, bat *gid, bat *eid, bat *sid, int *skip_nils, int *abort_on_error);
str
AGGRsubsumcand_wrd(bat *retval, bat *bid, bat *gid, bat *eid, bat *sid, int *skip_nils, int *abort_on_error)
{
	return AGGRsubgrouped(retval, bid, gid, eid, sid, skip_nils,
						  abort_on_error, TYPE_wrd, BATgroupsum, "aggr.subsum");
}

aggr_export str AGGRsubsumcand_lng(bat *retval, bat *bid, bat *gid, bat *eid, bat *sid, int *skip_nils, int *abort_on_error);
str
AGGRsubsumcand_lng(bat *retval, bat *bid, bat *gid, bat *eid, bat *sid, int *skip_nils, int *abort_on_error)
{
	return AGGRsubgrouped(retval, bid, gid, eid, sid, skip_nils,
						  abort_on_error, TYPE_lng, BATgroupsum, "aggr.subsum");
}

aggr_export str AGGRsubsumcand_flt(bat *retval, bat *bid, bat *gid, bat *eid, bat *sid, int *skip_nils, int *abort_on_error);
str
AGGRsubsumcand_flt(bat *retval, bat *bid, bat *gid, bat *eid, bat *sid, int *skip_nils, int *abort_on_error)
{
	return AGGRsubgrouped(retval, bid, gid, eid, sid, skip_nils,
						  abort_on_error, TYPE_flt, BATgroupsum, "aggr.subsum");
}

aggr_export str AGGRsubsumcand_dbl(bat *retval, bat *bid, bat *gid, bat *eid, bat *sid, int *skip_nils, int *abort_on_error);
str
AGGRsubsumcand_dbl(bat *retval, bat *bid, bat *gid, bat *eid, bat *sid, int *skip_nils, int *abort_on_error)
{
	return AGGRsubgrouped(retval, bid, gid, eid, sid, skip_nils,
						  abort_on_error, TYPE_dbl, BATgroupsum, "aggr.subsum");
}

aggr_export str AGGRsubprod_bte(bat *retval, bat *bid, bat *gid, bat *eid, int *skip_nils, int *abort_on_error);
str
AGGRsubprod_bte(bat *retval, bat *bid, bat *gid, bat *eid, int *skip_nils, int *abort_on_error)
{
	return AGGRsubgrouped(retval, bid, gid, eid, NULL, skip_nils,
						  abort_on_error, TYPE_bte, BATgroupprod, "aggr.subprod");
}

aggr_export str AGGRsubprod_sht(bat *retval, bat *bid, bat *gid, bat *eid, int *skip_nils, int *abort_on_error);
str
AGGRsubprod_sht(bat *retval, bat *bid, bat *gid, bat *eid, int *skip_nils, int *abort_on_error)
{
	return AGGRsubgrouped(retval, bid, gid, eid, NULL, skip_nils,
						  abort_on_error, TYPE_sht, BATgroupprod, "aggr.subprod");
}

aggr_export str AGGRsubprod_int(bat *retval, bat *bid, bat *gid, bat *eid, int *skip_nils, int *abort_on_error);
str
AGGRsubprod_int(bat *retval, bat *bid, bat *gid, bat *eid, int *skip_nils, int *abort_on_error)
{
	return AGGRsubgrouped(retval, bid, gid, eid, NULL, skip_nils,
						  abort_on_error, TYPE_int, BATgroupprod, "aggr.subprod");
}

aggr_export str AGGRsubprod_wrd(bat *retval, bat *bid, bat *gid, bat *eid, int *skip_nils, int *abort_on_error);
str
AGGRsubprod_wrd(bat *retval, bat *bid, bat *gid, bat *eid, int *skip_nils, int *abort_on_error)
{
	return AGGRsubgrouped(retval, bid, gid, eid, NULL, skip_nils,
						  abort_on_error, TYPE_wrd, BATgroupprod, "aggr.subprod");
}

aggr_export str AGGRsubprod_lng(bat *retval, bat *bid, bat *gid, bat *eid, int *skip_nils, int *abort_on_error);
str
AGGRsubprod_lng(bat *retval, bat *bid, bat *gid, bat *eid, int *skip_nils, int *abort_on_error)
{
	return AGGRsubgrouped(retval, bid, gid, eid, NULL, skip_nils,
						  abort_on_error, TYPE_lng, BATgroupprod, "aggr.subprod");
}

aggr_export str AGGRsubprod_flt(bat *retval, bat *bid, bat *gid, bat *eid, int *skip_nils, int *abort_on_error);
str
AGGRsubprod_flt(bat *retval, bat *bid, bat *gid, bat *eid, int *skip_nils, int *abort_on_error)
{
	return AGGRsubgrouped(retval, bid, gid, eid, NULL, skip_nils,
						  abort_on_error, TYPE_flt, BATgroupprod, "aggr.subprod");
}

aggr_export str AGGRsubprod_dbl(bat *retval, bat *bid, bat *gid, bat *eid, int *skip_nils, int *abort_on_error);
str
AGGRsubprod_dbl(bat *retval, bat *bid, bat *gid, bat *eid, int *skip_nils, int *abort_on_error)
{
	return AGGRsubgrouped(retval, bid, gid, eid, NULL, skip_nils,
						  abort_on_error, TYPE_dbl, BATgroupprod, "aggr.subprod");
}

aggr_export str AGGRsubprodcand_bte(bat *retval, bat *bid, bat *gid, bat *eid, bat *sid, int *skip_nils, int *abort_on_error);
str
AGGRsubprodcand_bte(bat *retval, bat *bid, bat *gid, bat *eid, bat *sid, int *skip_nils, int *abort_on_error)
{
	return AGGRsubgrouped(retval, bid, gid, eid, sid, skip_nils,
						  abort_on_error, TYPE_bte, BATgroupprod, "aggr.subprod");
}

aggr_export str AGGRsubprodcand_sht(bat *retval, bat *bid, bat *gid, bat *eid, bat *sid, int *skip_nils, int *abort_on_error);
str
AGGRsubprodcand_sht(bat *retval, bat *bid, bat *gid, bat *eid, bat *sid, int *skip_nils, int *abort_on_error)
{
	return AGGRsubgrouped(retval, bid, gid, eid, sid, skip_nils,
						  abort_on_error, TYPE_sht, BATgroupprod, "aggr.subprod");
}

aggr_export str AGGRsubprodcand_int(bat *retval, bat *bid, bat *gid, bat *eid, bat *sid, int *skip_nils, int *abort_on_error);
str
AGGRsubprodcand_int(bat *retval, bat *bid, bat *gid, bat *eid, bat *sid, int *skip_nils, int *abort_on_error)
{
	return AGGRsubgrouped(retval, bid, gid, eid, sid, skip_nils,
						  abort_on_error, TYPE_int, BATgroupprod, "aggr.subprod");
}

aggr_export str AGGRsubprodcand_wrd(bat *retval, bat *bid, bat *gid, bat *eid, bat *sid, int *skip_nils, int *abort_on_error);
str
AGGRsubprodcand_wrd(bat *retval, bat *bid, bat *gid, bat *eid, bat *sid, int *skip_nils, int *abort_on_error)
{
	return AGGRsubgrouped(retval, bid, gid, eid, sid, skip_nils,
						  abort_on_error, TYPE_wrd, BATgroupprod, "aggr.subprod");
}

aggr_export str AGGRsubprodcand_lng(bat *retval, bat *bid, bat *gid, bat *eid, bat *sid, int *skip_nils, int *abort_on_error);
str
AGGRsubprodcand_lng(bat *retval, bat *bid, bat *gid, bat *eid, bat *sid, int *skip_nils, int *abort_on_error)
{
	return AGGRsubgrouped(retval, bid, gid, eid, sid, skip_nils,
						  abort_on_error, TYPE_lng, BATgroupprod, "aggr.subprod");
}

aggr_export str AGGRsubprodcand_flt(bat *retval, bat *bid, bat *gid, bat *eid, bat *sid, int *skip_nils, int *abort_on_error);
str
AGGRsubprodcand_flt(bat *retval, bat *bid, bat *gid, bat *eid, bat *sid, int *skip_nils, int *abort_on_error)
{
	return AGGRsubgrouped(retval, bid, gid, eid, sid, skip_nils,
						  abort_on_error, TYPE_flt, BATgroupprod, "aggr.subprod");
}

aggr_export str AGGRsubprodcand_dbl(bat *retval, bat *bid, bat *gid, bat *eid, bat *sid, int *skip_nils, int *abort_on_error);
str
AGGRsubprodcand_dbl(bat *retval, bat *bid, bat *gid, bat *eid, bat *sid, int *skip_nils, int *abort_on_error)
{
	return AGGRsubgrouped(retval, bid, gid, eid, sid, skip_nils,
						  abort_on_error, TYPE_dbl, BATgroupprod, "aggr.subprod");
}

aggr_export str AGGRsubavg_dbl(bat *retval, bat *bid, bat *gid, bat *eid, int *skip_nils, int *abort_on_error);
str
AGGRsubavg_dbl(bat *retval, bat *bid, bat *gid, bat *eid, int *skip_nils, int *abort_on_error)
{
	return AGGRsubgrouped(retval, bid, gid, eid, NULL, skip_nils,
						  abort_on_error, TYPE_dbl, BATgroupavg, "aggr.subavg");
}

aggr_export str AGGRsubavgcand_dbl(bat *retval, bat *bid, bat *gid, bat *eid, bat *sid, int *skip_nils, int *abort_on_error);
str
AGGRsubavgcand_dbl(bat *retval, bat *bid, bat *gid, bat *eid, bat *sid, int *skip_nils, int *abort_on_error)
{
	return AGGRsubgrouped(retval, bid, gid, eid, sid, skip_nils,
						  abort_on_error, TYPE_dbl, BATgroupavg, "aggr.subavg");
}

@= AX3extreme3
aggr_export str AX3aggrX3_@13(int *ret,int *bid, int *gid, int *eid);
str AX3aggrX3_@13(int *ret,int *bid, int *gid, int *eid){
	BAT *b,*g,*e, *bn;

	if( (b= BATdescriptor(*bid)) == NULL ){
		throw(MAL, "aggr.@13", RUNTIME_OBJECT_MISSING);
	}
	if( (e= BATdescriptor(*eid)) == NULL ){
		BBPreleaseref(b->batCacheid);
		throw(MAL, "aggr.@13", RUNTIME_OBJECT_MISSING);
	}
	if( (g= BATdescriptor(*gid)) == NULL ){
		BBPreleaseref(e->batCacheid);
		BBPreleaseref(b->batCacheid);
		throw(MAL, "aggr.@13", RUNTIME_OBJECT_MISSING);
	}
	if( CMDaggrX3_@13(&bn,b,g,e) == GDK_SUCCEED){
		if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ); 
		*ret = bn->batCacheid;
		BBPkeepref(*ret);
		BBPreleaseref(b->batCacheid);
		BBPreleaseref(e->batCacheid);
		BBPreleaseref(g->batCacheid);
		return MAL_SUCCEED;
	}
	BBPreleaseref(b->batCacheid);
	BBPreleaseref(e->batCacheid);
	BBPreleaseref(g->batCacheid);
	throw(MAL, "aggrX3_@13",GDK_EXCEPTION);
}
@
@c
/*
 * @- "Extremes" (Min & Max)
 */
@:AX3extreme3(min,<)@
@:AX3extreme3(max,>)@

aggr_export str AX3aggrX3_count3(int *retid, int *bid, int *gid, int *eid, bit *ignore_nils);
str
AX3aggrX3_count3(int *retid, int *bid, int *gid, int *eid, bit *ignore_nils)
{
	BAT *b, *g, *e;
	BAT *bn;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "aggr.count3", RUNTIME_OBJECT_MISSING);
	}
	if ((e = BATdescriptor(*eid)) == NULL) {
		BBPreleaseref(b->batCacheid);
		throw(MAL, "aggr.count3", RUNTIME_OBJECT_MISSING);
	}
	if ((g = BATdescriptor(*gid)) == NULL) {
		BBPreleaseref(e->batCacheid);
		BBPreleaseref(b->batCacheid);
		throw(MAL, "aggr.count3", RUNTIME_OBJECT_MISSING);
	}
	if (CMDaggrX3_count3(&bn, b, g, e, ignore_nils) == GDK_SUCCEED) {
		if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ); 
		*retid = bn->batCacheid;
		BBPkeepref(*retid);
		BBPreleaseref(b->batCacheid);
		BBPreleaseref(e->batCacheid);
		BBPreleaseref(g->batCacheid);
		return MAL_SUCCEED;
	}
	BBPreleaseref(b->batCacheid);
	BBPreleaseref(e->batCacheid);
	BBPreleaseref(g->batCacheid);
	throw(MAL, "aggrX3_count3", GDK_EXCEPTION);
}
/*
 * The remainder contains the few MIL proc translations
 */
aggr_export str AX3aggrX3_count3Nils(int *retid, int *bid, int *gid, int *eid);
str
AX3aggrX3_count3Nils(int *retid, int *bid, int *gid, int *eid)
{
	bit ignore_nils = 0;
	return AX3aggrX3_count3(retid, bid, gid, eid, &ignore_nils);
}

aggr_export str AX3count_no_nil3(int *retid, int *bid, int *gid, int *eid);
str 
AX3count_no_nil3(int *retid, int *bid, int *gid, int *eid)
{
	bit ignore_nils = TRUE;
	return AX3aggrX3_count3(retid, bid, gid, eid, &ignore_nils);
}

aggr_export str AX3aggrX3_count2Nils(int *retid, int *bid, int *eid);
str
AX3aggrX3_count2Nils(int *retid, int *bid, int *eid)
{
	bit ignore_nils = 0;
	return AX3aggrX3_count(retid, bid, eid, &ignore_nils);
}

aggr_export str AX3count_no_nil2(int *retid, int *bid, int *eid);
str
AX3count_no_nil2(int *retid, int *bid, int *eid)
{
	bit ignore_nils = TRUE;
	return AX3aggrX3_count(retid, bid, eid, &ignore_nils);
}
