@/
The contents of this file are subject to the MonetDB Public License
Version 1.1 (the "License"); you may not use this file except in
compliance with the License. You may obtain a copy of the License at
http://www.monetdb.org/Legal/MonetDBLicense

Software distributed under the License is distributed on an "AS IS"
basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations
under the License.

The Original Code is the MonetDB Database System.

The Initial Developer of the Original Code is CWI.
Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
Copyright August 2008-2012 MonetDB B.V.
All Rights Reserved.
@

@f batcalc

@c
/*
 * @a M.L. Kersten
 * @+ BAT calculator
 * Many applications require extension of the basic calculator and
 * mathematic functions to work on BAT arguments. Although the
 * MAL multiplex optimizer contains a command ('optimizer.multiplex')
 * to generate the necessary code, it is often much more efficient to
 * use one of the dedidacted batcalc functions introduced below.
 *
 * The operators supported are limited to the built-in fixed length
 * atoms, because they permit ease of storage of the operation result.
 * Variable sized atoms, especially user defined, may require more
 * administrative activities.
 * Furthermore, the operands involved are assumed to be aligned
 * to assure the fastest possible join evaluation.
 *
 * Optimal processing performance is further obtained when the operators
 * can work as 'accumulators', for then we do not pay the price
 * of space allocation for a new intermediate. It may imply a BATcopy
 * before the accummulator function is being called.
 * A new BAT is of course created when the result of a function does not fit
 * the accumulator.
 *
 * The implementation does not take into account possible overflows
 * caused by the operators. However, the operators respect the NIL
 * semantics and division by zero produces a NIL.
 *
 * In addition to arithmetic and comparison operators, casting and
 * mathematical functions are directly supported.
 *
 * @+ NULL semantics
 * The batcalc arithmetic is already constraint to BATs of equal size.
 * Another improvement is obtained when we do not have to check
 * for NULLs in each and every basic operation +,-,/,* and comparisons.
 * A problem is to propagate the general 'nonil' property, because
 * this depends on the semantics of the operator. Checking the result
 * for a nil value depleats most of the expected gain.
 *
 * Currently only set for the NOT operation and comparisons operators when
 * neither argument has nils.
 */
@mal
module batcalc;

# @+ Basic arithmetic
# The first group of functions provide abstractions over the
# binary operators +,/,-,*, and %. Both on (BAT,BAT) and (BAT,CST)
# operands. We also support the type enlargement and auto coercions,
# because they avoid expensive BAT copying.
#
# The accumulator versions modifies the first argument,
# provided it is a temporary BAT and not a view.
@= calcGrp1
	command @1(b:bat[:oid,:@3], cst:@4) :bat[:oid,:@5] 
	address CMDbat@2cst_@3_@4_@5;

	command @1(cst:@3, b:bat[:oid,:@4]) :bat[:oid,:@5] 
	address CMDcst@2bat_@3_@4_@5;

	command @1(b:bat[:oid,:@3], c:bat[:oid,:@4]) :bat[:oid,:@5] 
	address CMDbat@2_@3_@4_@5
	comment "Binary BAT calculator function with new BAT result";
@
# @-
@= calcGrp2

	command @1(b:bat[:oid,:@3], c:bat[:oid,:@4], aflag:bit, bflag:bit):bat[:oid,:@5]
	address CMDbataccum@2_@3_@4_@5
	comment "Binary BAT calculator function which may re-use store of arguments ";

	command @1(cst:@3, b:bat[:oid,:@4], cflag:bit, bflag:bit):bat[:oid,:@5]
	address CMDbataccum@2cst2_@3_@4_@5
	comment "(BAT,Constant) calculator function which may re-use store of BAT argument";

	command @1(b:bat[:oid,:@3], cst:@4, bflag:bit, cflag:bit) :bat[:oid,:@5]
	address CMDbataccum@2cst_@3_@4_@5
	comment "(BAT,Constant) calculator function which may re-use store of BAT argument";
@
# @-
@= calcGrp3
	@:calcGrp1(@1,@2,@3,@4,@5)@
	@:calcGrp2(@1,@2,@3,@4,@5)@

@
@mal
# @-
# We need instantiations for the accumulator code,
# but should limit modulo functions to integer-based types.
# The calc group contains the operator, the desired result typ, its
# C qualifier and the operands
	@:calcGrp3(%,MOD,bte,bte,bte)@
	@:calcGrp3(%,MOD,sht,sht,sht)@
	@:calcGrp3(%,MOD,int,int,int)@
	@:calcGrp3(%,MOD,wrd,wrd,wrd)@
	@:calcGrp3(%,MOD,lng,lng,lng)@

	@:calcGrp3(xor,XOR,oid,oid,oid)@
	@:calcGrp3(xor,XOR,bte,bte,bte)@
	@:calcGrp3(xor,XOR,sht,sht,sht)@
	@:calcGrp3(xor,XOR,int,int,int)@
	@:calcGrp3(xor,XOR,wrd,wrd,wrd)@
	@:calcGrp3(xor,XOR,lng,lng,lng)@

	@:calcGrp3(and,AND,oid,oid,oid)@
	@:calcGrp3(and,AND,bte,bte,bte)@
	@:calcGrp3(and,AND,sht,sht,sht)@
	@:calcGrp3(and,AND,int,int,int)@
	@:calcGrp3(and,AND,wrd,wrd,wrd)@
	@:calcGrp3(and,AND,lng,lng,lng)@

	@:calcGrp3(or,OR,oid,oid,oid)@
	@:calcGrp3(or,OR,bte,bte,bte)@
	@:calcGrp3(or,OR,sht,sht,sht)@
	@:calcGrp3(or,OR,int,int,int)@
	@:calcGrp3(or,OR,wrd,wrd,wrd)@
	@:calcGrp3(or,OR,lng,lng,lng)@

	@:calcGrp3(<<,LSH,oid,int,oid)@
	@:calcGrp3(<<,LSH,bte,int,bte)@
	@:calcGrp3(<<,LSH,sht,int,sht)@
	@:calcGrp3(<<,LSH,int,int,int)@
	@:calcGrp3(<<,LSH,wrd,int,wrd)@
	@:calcGrp3(<<,LSH,lng,int,lng)@

	@:calcGrp3(>>,RSH,oid,int,oid)@
	@:calcGrp3(>>,RSH,bte,int,bte)@
	@:calcGrp3(>>,RSH,sht,int,sht)@
	@:calcGrp3(>>,RSH,int,int,int)@
	@:calcGrp3(>>,RSH,wrd,int,wrd)@
	@:calcGrp3(>>,RSH,lng,int,lng)@

@= coerceGrp
	@:calcGrp1(@1,@2,bte,bte,lng)@
	@:calcGrp1(@1,@2,bte,sht,lng)@
	@:calcGrp1(@1,@2,bte,int,lng)@
	@:calcGrp1(@1,@2,bte,wrd,lng)@
	@:calcGrp3(@1,@2,bte,lng,lng)@
	@:calcGrp1(@1,@2,sht,bte,lng)@
	@:calcGrp1(@1,@2,sht,sht,lng)@
	@:calcGrp1(@1,@2,sht,int,lng)@
	@:calcGrp1(@1,@2,sht,wrd,lng)@
	@:calcGrp3(@1,@2,sht,lng,lng)@
	@:calcGrp1(@1,@2,int,bte,lng)@
	@:calcGrp1(@1,@2,int,sht,lng)@
	@:calcGrp1(@1,@2,int,int,lng)@
	@:calcGrp1(@1,@2,int,wrd,lng)@
	@:calcGrp3(@1,@2,int,lng,lng)@
	@:calcGrp1(@1,@2,wrd,bte,lng)@
	@:calcGrp1(@1,@2,wrd,sht,lng)@
	@:calcGrp1(@1,@2,wrd,int,lng)@
	@:calcGrp1(@1,@2,wrd,wrd,lng)@
	@:calcGrp3(@1,@2,wrd,lng,lng)@
	@:calcGrp3(@1,@2,lng,bte,lng)@
	@:calcGrp3(@1,@2,lng,sht,lng)@
	@:calcGrp3(@1,@2,lng,int,lng)@
	@:calcGrp3(@1,@2,lng,wrd,lng)@
	@:calcGrp3(@1,@2,lng,lng,lng)@

	@:calcGrp1(@1,@2,bte,bte,wrd)@
	@:calcGrp1(@1,@2,bte,sht,wrd)@
	@:calcGrp1(@1,@2,bte,int,wrd)@
	@:calcGrp3(@1,@2,bte,wrd,wrd)@
	@:calcGrp1(@1,@2,sht,bte,wrd)@
	@:calcGrp1(@1,@2,sht,sht,wrd)@
	@:calcGrp1(@1,@2,sht,int,wrd)@
	@:calcGrp3(@1,@2,sht,wrd,wrd)@
	@:calcGrp1(@1,@2,int,bte,wrd)@
	@:calcGrp1(@1,@2,int,sht,wrd)@
	@:calcGrp1(@1,@2,int,int,wrd)@
	@:calcGrp3(@1,@2,int,wrd,wrd)@
	@:calcGrp3(@1,@2,wrd,bte,wrd)@
	@:calcGrp3(@1,@2,wrd,sht,wrd)@
	@:calcGrp3(@1,@2,wrd,int,wrd)@
	@:calcGrp3(@1,@2,wrd,wrd,wrd)@

	@:calcGrp1(@1,@2,bte,bte,int)@
	@:calcGrp1(@1,@2,bte,sht,int)@
	@:calcGrp3(@1,@2,bte,int,int)@
	@:calcGrp1(@1,@2,sht,bte,int)@
	@:calcGrp1(@1,@2,sht,sht,int)@
	@:calcGrp3(@1,@2,sht,int,int)@
	@:calcGrp3(@1,@2,int,bte,int)@
	@:calcGrp3(@1,@2,int,sht,int)@
	@:calcGrp3(@1,@2,int,int,int)@

	@:calcGrp1(@1,@2,bte,bte,sht)@
	@:calcGrp3(@1,@2,bte,sht,sht)@
	@:calcGrp3(@1,@2,sht,bte,sht)@
	@:calcGrp3(@1,@2,sht,sht,sht)@

	@:calcGrp3(@1,@2,bte,bte,bte)@

	@:calcGrp1(@1,@2,flt,flt,dbl)@
	@:calcGrp3(@1,@2,flt,dbl,dbl)@
	@:calcGrp3(@1,@2,dbl,flt,dbl)@
	@:calcGrp3(@1,@2,dbl,dbl,dbl)@

	@:calcGrp3(@1,@2,flt,flt,flt)@

@
@mal
# @-
	@:coerceGrp(/,DIV)@
	@:coerceGrp(*,MUL)@
	@:coerceGrp(-,SUB)@
	@:coerceGrp(+,ADD)@
	# @-
@= unary
	command -(b:bat[:any_1,:@1]):bat[:any_1,:@1] 
	address CMDunaryMIN
	comment "Unary minus over the tail of the bat";
	
	command --(b:bat[:any_1,:@1]):bat[:any_1,:@1] 
	address CMDunaryMINMIN
	comment "Unary minus over the tail of the bat";

	command ++(b:bat[:any_1,:@1]):bat[:any_1,:@1] 
	address CMDunaryPLUSPLUS
	comment "Unary minus over the tail of the bat";

	command abs(b:bat[:any_1,:@1]):bat[:any_1,:@1] 
	address CMDunaryABS
	comment "Unary abs over the tail of the bat";
@
@mal
# @-
@:unary(bte)@
@:unary(sht)@
@:unary(int)@
@:unary(wrd)@
@:unary(lng)@
@:unary(flt)@
@:unary(dbl)@
# @-
@= unaryISNIL
	command isnil(b:bat[:any_1,:@1]):bat[:any_1,:bit] 
	address CMDunaryISNIL
	comment "Unary check for nil over the tail of the bat";

	command isnil(b:bat[:void,:@1]):bat[:oid,:bit] 
	address CMDunaryISNIL
	comment "Unary check for nil over the tail of the bat";
@
@mal
# @-
@:unaryISNIL(bit)@
@:unaryISNIL(bte)@
@:unaryISNIL(oid)@
@:unaryISNIL(sht)@
@:unaryISNIL(int)@
@:unaryISNIL(wrd)@
@:unaryISNIL(lng)@
@:unaryISNIL(flt)@
@:unaryISNIL(dbl)@
@:unaryISNIL(str)@
# @-
# @+ Comparison routines
# The command signatures are similar to those above, producing a bit result.
@= comparison
	command @1(b:bat[:any_1,:@2], c:bat[:any_1,:@2]) :bat[:any_1,:bit]
	address CMD_@3_@2;
	command @1(a:bat[:any_1,:bit], b:bat[:any_1,:@2], c:bat[:any_1,:@2])
	:bat[:any_1,:bit]
	address CMDaccum_@3_@2;

	command @1(b:bat[:any_1,:@2], cst:@2) :bat[:any_1,:bit]
	address CMD_@3_@2_cst;
	command @1(cst:@2, b:bat[:any_1,:@2]) :bat[:any_1,:bit]
	address CMD_@3_cst_@2;

	command @1(a:bat[:any_1,:bit], b:bat[:any_1,:@2],cst:@2) :bat[:any_1,:bit]
	address CMDaccum_@3_@2_cst;
	command @1(a:bat[:any_1,:bit], cst:@2, b:bat[:any_1,:@2]) :bat[:any_1,:bit]
	address CMDaccum_@3_cst_@2;


@= compareGrp
	@:comparison(>=,@1,GE)@
	@:comparison(<=,@1,LE)@
	@:comparison(>,@1,GT)@
	@:comparison(<,@1,LT)@
	@:comparison(==,@1,EQ)@
	@:comparison(!=,@1,NEQ)@
@
@mal
	@:compareGrp(bit)@
	@:compareGrp(bte)@
	@:compareGrp(sht)@
	@:compareGrp(int)@
	@:compareGrp(wrd)@
	@:compareGrp(lng)@
	@:compareGrp(dbl)@
	@:compareGrp(flt)@
	@:compareGrp(oid)@

	@:comparison(and,bit,AND)@
	@:comparison(or,bit,OR)@

# @+ Boolean operations
# The command signature can mostly be borrowed from the arithmetic.
command not(b:bat[:any_1,:bit]):bat[:any_1,:bit] 
address CMDbitbatNOT
comment "Return a new BAT with the negated tail";

command not(a:bat[:any_1,:bit], b:bat[:any_1,:bit]):bat[:any_1,:bit] 
address CMDbitbataccumNOT
comment "Return a BAT with the negated tail";

# @- Implementation
@include kprelude.mx
@h
#include "gdk.h"
#include "math.h"
#include "mal_exception.h"

#ifdef WIN32
#if !defined(LIBMAL) && !defined(LIBATOMS) && !defined(LIBKERNEL) && !defined(LIBMAL) && !defined(LIBOPTIMIZER) && !defined(LIBSCHEDULER) && !defined(LIBMONETDB5)
#define batcalc_export extern __declspec(dllimport)
#else
#define batcalc_export extern __declspec(dllexport)
#endif
#else
#define batcalc_export extern
#endif

/*
 * @-
 * The accumulator operators are relatively straight forward,
 * when the target BAT is known and we only have to deal with
 * fixed-sized types.
 * @-
 */
@= accum
{
	@4 *o = (@4*)Tloc(bn, BUNfirst(bn));
	@2 *p = (@2*)Tloc(b, BUNfirst(b));
	@2 *q = (@2*)Tloc(b, BUNlast(b));
	@3 *r = (@3*)Tloc(right, BUNfirst(right));

	BATaccessBegin(b, USE_TAIL, MMAP_SEQUENTIAL);
	BATaccessBegin(right, USE_TAIL, MMAP_SEQUENTIAL);
	if (b->T->nonil && right->T->nonil)
		for (; p<q; o++, p++, r++)
			*o = (@4) (*p @1 *r);
	else if (b->T->nonil) {
		for (; p<q; o++, p++, r++){
			/* this code is better as x?nil:y  */
			if(*r == @3_nil) {
				*o = @4_nil;
				bn->T->nonil = 0;
			} else 
				*o = (@4) (*p @1 *r);
		}
	} else if (right->T->nonil)
		for (; p<q; o++, p++, r++){
			/* this code is better as x?nil:y  */
			if(*p == @2_nil ) {
				*o = @4_nil;
				bn->T->nonil = 0;
			} else 
				*o = (@4) (*p @1 *r);
		}
	else
		for (; p<q; o++, p++, r++){
			/* this code is better as x?nil:y  */
			if(*p == @2_nil || *r == @3_nil) {
				*o = @4_nil;
				bn->T->nonil = 0;
			} else 
				*o = (@4) (*p @1 *r);
		}
	BATaccessEnd(right, USE_TAIL, MMAP_SEQUENTIAL);
	BATaccessEnd(b, USE_TAIL, MMAP_SEQUENTIAL);
}
@= accumCst
{
	@4 *o = (@4*)Tloc(bn, BUNfirst(bn)); 
	@2 *p = (@2*)Tloc(b, BUNfirst(b));
	@2 *q = (@2*)Tloc(b, BUNlast(b));
	@3 c  = *(@3*)cst;

	BATaccessBegin(b, USE_TAIL, MMAP_SEQUENTIAL);
	if( c == @3_nil){
		for (;p<q; o++, p++)
			*o = @4_nil;
		bn->T->nonil = 0;
	} else
	if (b->T->nonil)
		for (;p<q; o++, p++)
			*o = *p @1 c;
	else
		for (;p<q; o++, p++) {
			if (*p == @2_nil ) {
				*o = @4_nil;
				bn->T->nonil = 0;
			} else 
				*o = *p @1 c;
		}
	BATaccessEnd(b, USE_TAIL, MMAP_SEQUENTIAL);
}
@= accumCstLeft
{
	@4 *o = (@4*)Tloc(bn, BUNfirst(bn)); 
	@2 c  = *(@2*)cst;
	@3 *p = (@3*)Tloc(b, BUNfirst(b));
	@3 *q = (@3*)Tloc(b, BUNlast(b));

	BATaccessBegin(b, USE_TAIL, MMAP_SEQUENTIAL);
	if (c == @2_nil) {
		for (; p<q; o++, p++)
			*o = @4_nil;
		bn->T->nonil = 0;
	} else
	if (b->T->nonil)
		for (; p<q; o++, p++)
			*o = c @1 *p;
	else
		for (; p<q; o++, p++) {
			if (*p == @3_nil ) {
				*o = @4_nil;
				bn->T->nonil = 0;
			} else 
				*o = c @1 *p;
		}
	BATaccessEnd(b, USE_TAIL, MMAP_SEQUENTIAL);
}
@= accumCstDIV
{
	@4 *o = (@4*)Tloc(bn, BUNfirst(bn)); 
	@2 c  = *(@2*)cst;
	@3 *p = (@3*)Tloc(b, BUNfirst(b));
	@3 *q = (@3*)Tloc(b, BUNlast(b));

	BATaccessBegin(b, USE_TAIL, MMAP_SEQUENTIAL);
	if (c == 0)
		res = createException(ARITH, "batcalc.@1", "Division by zero");
	else 
	if (b->T->nonil)
		for (; p<q; o++, p++){
			if ( *p == 0)
				res = createException(ARITH, "batcalc.@1", "Division by zero");
			else
				*o = c @1 *p;
		}
	else
		for (; p<q; o++, p++) {
			if (*p == @3_nil) {
				*o = @4_nil;
				bn->T->nonil = 0;
			} else if (*p == 0)
				res = createException(ARITH, "batcalc.@1", "Division by zero");
			else
				*o = c @1 *p;
		}
	BATaccessEnd(b, USE_TAIL, MMAP_SEQUENTIAL);
}
@
 * @-
 * A general assumption in all cases is the bats are synchronized on their
 * head column. This is not checked and may be mis-used to deploy the
 * implementation for shifted window arithmetic as well.
@= chkSize
	if( BATcount(@1) != BATcount(@2) )
	throw(MAL, "batcalc.@3", ILLEGAL_ARGUMENT " Requires bats of identical size");
@
 * @-
 * The code block below heavily uses the MX code expansion involved,
 * but in essence the structure is relatively simple.
 * The BAT loops to cover the cases for arithmetic are
 * collected in bataccum<operator>. Initialization of the
 * two primary command structures are dealt with in the CMD* alternatives.
 * The similar code base is produced for dealing with a constant argument.
@= loopImpl
{	
	@5 *o = (@5*)Tloc(bn, BUNfirst(bn));
	@3 *p = (@3*)Tloc(b, BUNfirst(b));
	@3 *q = (@3*)Tloc(b, BUNlast(b));
	@4 *r = (@4*)Tloc(right, BUNfirst(right));

	BATaccessBegin(b, USE_TAIL, MMAP_SEQUENTIAL);
	BATaccessBegin(right, USE_TAIL, MMAP_SEQUENTIAL);
#if CMD_@2 == CMD_DIV
	if (b->T->nonil && right->T->nonil) {
		bn->T->nonil = 1;
		for(; p<q; o++, p++, r++)
			if (*r == 0)
				res = createException(ARITH, "batcalc.@1", "Division by zero");
			else
				*o = (@5)(*p / *r);
	} else if (b->T->nonil ) {
		bn->T->nonil = 1;
		for(; p<q; o++, p++, r++) {
			/* this code is better as x?nil:y  */
			if (*r == @4_nil) {
				*o = @5_nil;
				bn->T->nonil = 0;
			} else if (*r == 0)
				res = createException(ARITH, "batcalc.@1", "Division by zero");
			else 
				*o = (@5)(*p / *r);
		}
	} else if (right->T->nonil ) {
		bn->T->nonil = 1;
		for(; p<q; o++, p++, r++) 
			/* this code is better as x?nil:y  */
			if (*p == @3_nil) {
				*o = @5_nil;
				bn->T->nonil = 0;
			} else if (*r == 0)
				res = createException(ARITH, "batcalc.@1", "Division by zero");
			else
				*o = (@5)(*p / *r);
	} else {
		bn->T->nonil = 1;
		for(; p<q; o++, p++, r++) 
			/* this code is better as x?nil:y  */
			if (*p == @3_nil || *r == @4_nil) {
				*o = @5_nil;
				bn->T->nonil = 0;
			} else if (*r == 0) {
				res = createException(ARITH, "batcalc.@1", "Division by zero");
			} else
				*o = (@5)(*p / *r);
	}
#else
	if (b->T->nonil && right->T->nonil) {
		bn->T->nonil = 1;
		for(; p<q; o++, p++, r++)
			*o = (@5) (*p @1 *r);
	} else if (b->T->nonil ) {
		bn->T->nonil = 1;
		for(; p<q; o++, p++, r++) {
			/* this code is better as x?nil:y  */
			if (*r == @4_nil) {
				*o = @5_nil;
				bn->T->nonil = 0;
			} else
				*o = (@5) (*p @1 *r);
		}
	} else if (right->T->nonil) {
		bn->T->nonil = 1;
		for(; p<q; o++, p++, r++) {
			/* this code is better as x?nil:y  */
			if (*p == @3_nil) {
				*o = @5_nil;
				bn->T->nonil = 0;
			} else
				*o = (@5) (*p @1 *r);
		}
	} else {
		bn->T->nonil = 1;
		for(; p<q; o++, p++, r++) {
			/* this code is better as x?nil:y  */
			if (*p == @3_nil || *r == @4_nil) {
				*o = @5_nil;
				bn->T->nonil = 0;
			} else 
				*o = (@5) (*p @1 *r);
		}
	}
#endif
	BATaccessEnd(b, USE_TAIL, MMAP_SEQUENTIAL);
	BATaccessEnd(right, USE_TAIL, MMAP_SEQUENTIAL);
}
@= arithmeticImpl_1
batcalc_export str CMDbat@2_@3_@4_@5(int *ret, int *l, int *r);
str CMDbat@2_@3_@4_@5(int *ret, int *l, int *r)
{	
	BAT *bn, *b, *right;
	char *res = MAL_SUCCEED;

	@:getBATdescriptor(l,b,"batcalc.@1")@
	@:getBATdescriptor(r,right,"batcalc.@1")@
	@:chkSize(b,right,CMDbat@2)@
	@:voidresultBAT(TYPE_@5,"batcalc.@1")@

	@:loopImpl(@1,@2,@3,@4,@5)@

	BATsetcount(bn, BATcount(b));
	bn->tsorted = 0;
	BATkey(BATmirror(bn),FALSE);

	if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ); 

	if (b->htype != bn->htype) {
		BAT *r = VIEWcreate(b,bn);

		BBPreleaseref(bn->batCacheid);
		bn = r;
	}
	BBPkeepref(*ret = bn->batCacheid);
	BBPreleaseref(b->batCacheid);
	BBPreleaseref(right->batCacheid);
	return res;
}


batcalc_export str CMDbat@2cst_@3_@4_@5(int *ret, int *l, void *cst);
str CMDbat@2cst_@3_@4_@5(int *ret, int *l, void *cst)
{	
	BAT *bn, *b;
	char *res = MAL_SUCCEED;

	@:getBATdescriptor(l,b,"batcalc.@1")@
	@:voidresultBAT(TYPE_@5,"batcalc.@1")@

#if CMD_@2 == CMD_DIV
	if (*(@4*)cst == 0) {
		res = createException(ARITH, "batcalc.@1", "Division by zero");
	} else {
		@:accumCst(@1,@3,@4,@5)@ 
	}
#else
	@:accumCst(@1,@3,@4,@5)@ 
#endif
	BATsetcount(bn, BATcount(b));
	if (@6 & 1) {
		bn->tsorted = BATtordered(b);
	} else
	if (@6 & 4) {
		bn->tsorted = REVERT_SORTED(BATtordered(b));
	} else
	if (@6 & 16) { 
		if (*(@4*)cst < 0)
			bn->tsorted = REVERT_SORTED(BATtordered(b));
		else
			bn->tsorted = BATtordered(b);
	} else {
		bn->tsorted = 0;
	}
	BATkey(BATmirror(bn),FALSE);

	if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ); 

	if (b->htype != bn->htype) {
		BAT *r = VIEWcreate(b,bn);

		BBPreleaseref(bn->batCacheid);
		bn = r;
	}
	BBPkeepref(*ret = bn->batCacheid);
	BBPreleaseref(b->batCacheid);
	return res;
}
batcalc_export str CMDcst@2bat_@3_@4_@5(int *ret, void *cst, int *l);
str CMDcst@2bat_@3_@4_@5(int *ret, void *cst, int *l)
{	
	BAT *bn, *b;
	char *res = MAL_SUCCEED;

	@:getBATdescriptor(l,b,"batcalc.@1")@
	@:voidresultBAT(TYPE_@5,"batcalc.@1")@

#if CMD_@2 == CMD_DIV
	@:accumCstDIV(@1,@3,@4,@5)@ 
#else
	@:accumCstLeft(@1,@3,@4,@5)@ 
#endif
	BATsetcount(bn, BATcount(b));
	if (@6 & 2) {
		bn->tsorted = BATtordered(b);
	} else
	if (@6 & 8) {
		bn->tsorted = REVERT_SORTED(BATtordered(b));
	} else
	if (@6 & 32) { 
		if (*(@4*)cst < 0)
			bn->tsorted = REVERT_SORTED(BATtordered(b));
		else
			bn->tsorted = BATtordered(b);
	} else {
		bn->tsorted = 0;
	}
	BATkey(BATmirror(bn),FALSE);

	if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ); 

	if (b->htype != bn->htype) {
		BAT *r = VIEWcreate(b,bn);

		BBPreleaseref(bn->batCacheid);
		bn = r;
	}
	BBPkeepref(*ret = bn->batCacheid);
	BBPreleaseref(b->batCacheid);
	return res;
}
@
 * @-
@= arithmeticImpl_2
/*
The accumulator variants may re-use the storage of an argument only when it is not shared,
nor being a persistent BAT
*/
batcalc_export str CMDbataccum@2_@3_@4_@5(int *ret, int *l, int *r, bit *lflag, bit *rflag);
str CMDbataccum@2_@3_@4_@5(int *ret, int *l, int *ri, bit *lflag, bit *rflag)
{	
	BAT *bn, *b, *right;
	char *res = MAL_SUCCEED;

	@:getBATdescriptor(l,b,"batcalc.@1")@
	@:getBATdescriptor(ri,right,"batcalc.@1")@

	if( *lflag && !isVIEW(b) && BBP_refs(*l) == 1 && BBP_lrefs(*l) == 1)
		bn = b;
	else if( *rflag && !isVIEW(right) && BBP_refs(*ri) == 1 &&  BBP_lrefs(*ri) == 1)
		bn = right;
	else {
		BBPreleaseref(b->batCacheid);
		BBPreleaseref(right->batCacheid);
		return CMDbat@2_@3_@4_@5(ret,l,ri);
	}

	@:chkSize(bn,b,CMDbataccum@2)@
	@:chkSize(bn,right,CMDbataccum@2)@

	@:loopImpl(@1,@2,@3,@4,@5)@

	bn->tsorted = 0;
	BATkey(BATmirror(bn),FALSE);

	if (b->htype != bn->htype) {
		bn = VIEWcreate(b,bn);
	}

	BBPkeepref(*ret = bn->batCacheid);
	if (b != bn)
		BBPreleaseref(b->batCacheid);
	if (right != bn)
		BBPreleaseref(right->batCacheid);
	return res;
}

batcalc_export str CMDbataccum@2cst_@3_@4_@5(int *ret, int *l, void *cst, bit *lflag, bit *rflag);
str CMDbataccum@2cst_@3_@4_@5(int *ret, int *l, void *cst, bit *lflag, bit *rflag)
{	
	BAT *bn, *b;
	char *res = MAL_SUCCEED;

	(void) rflag;
	@:getBATdescriptor(l,b,"batcalc.@1")@
	if( *lflag && !isVIEW(b) && BBP_refs(*l) == 1 && BBP_lrefs(*l) == 1)
		bn = b;
	else{
		BBPreleaseref(b->batCacheid);
		return CMDbat@2cst_@3_@4_@5(ret,l,cst);
	}

	@:chkSize(bn,b,CMDbataccum@2)@

#if CMD_@2 == CMD_DIV
	if (*(@4*)cst == 0) {
		res = createException(ARITH, "batcalc.@1", "Division by zero");
	} else {
		@:accumCst(@1,@3,@4,@5)@ 
	}
#else
	@:accumCst(@1,@3,@4,@5)@ 
#endif
	if (@6 & 1)
		bn->tsorted = BATtordered(b);
	else
	if (@6 & 4)
		bn->tsorted = REVERT_SORTED(BATtordered(b));
	else
	if (@6 & 16) { 
		if (*(@4*)cst < 0)
			bn->tsorted = REVERT_SORTED(BATtordered(b));
		else
			bn->tsorted = BATtordered(b);
	} else {
		bn->tsorted = 0;
	}
	BATkey(BATmirror(bn),FALSE);

	if (b->htype != bn->htype) {
		bn = VIEWcreate(b,bn);
	}
	BBPkeepref(*ret = bn->batCacheid);
	if (b != bn)
		BBPreleaseref(b->batCacheid);
	return res;
}

batcalc_export str CMDbataccum@2cst2_@3_@4_@5(int *ret, void *cst, int *r, bit *lflag, bit *rflag);
str CMDbataccum@2cst2_@3_@4_@5(int *ret, void *cst, int *r, bit *lflag, bit *rflag)
{	
	BAT *bn, *b;
	char *res = MAL_SUCCEED;

	(void) lflag;
	@:getBATdescriptor(r,b,"batcalc.@1")@
	if( *rflag && !isVIEW(b) && BBP_refs(*r) == 1 && BBP_lrefs(*r) == 1)
		bn = b;
	else {
		BBPreleaseref(b->batCacheid);
		return CMDcst@2bat_@3_@4_@5(ret,cst,r);
	}

	@:chkSize(bn,b,CMDbataccum@2)@

#if CMD_@2 == CMD_DIV
	@:accumCstDIV(@1,@3,@4,@5)@ 
#else
	@:accumCstLeft(@1,@3,@4,@5)@ 
#endif
	if (@6 & 2) {
		bn->tsorted = BATtordered(b);
	} else
	if (@6 & 8) {
		bn->tsorted = REVERT_SORTED(BATtordered(b));
	} else
	if (@6 & 32) { 
		if (*(@4*)cst < 0)
			bn->tsorted = REVERT_SORTED(BATtordered(b));
		else
			bn->tsorted = BATtordered(b);
	} else {
		bn->tsorted = 0;
	}
	BATkey(BATmirror(bn),FALSE);

	if (b->htype != bn->htype) {
		bn = VIEWcreate(b,bn);
	}
	BBPkeepref(*ret = bn->batCacheid);
	if (b != bn)
		BBPreleaseref(b->batCacheid);
	return res;
}
@
 * @-
@= arithmeticImpl_3
	@:arithmeticImpl_1(@1,@2,@3,@4,@5,@6)@
	@:arithmeticImpl_2(@1,@2,@3,@4,@5,@6)@
@
@c
/*
 * @-
 */
#include "monetdb_config.h"
#include "batcalc.h"

/* the normal implementation of an operator is to just stick the
   operator between the operands */
#define calc_abs(s) ((s) > 0 ? (s) : -(s))
/* not used, yet:
#define calc_inv(s) (1/(s))
#define calc_neg(s) (-(s))
#define calc_sign(s) ((s) < 0 ? -1 : (s) == 0 ? 0 : 1)
*/

@= arithGrpImpl
@:arithmeticImpl_1(@1,@2,bte,bte,lng,@3)@
@:arithmeticImpl_1(@1,@2,bte,sht,lng,@3)@
@:arithmeticImpl_1(@1,@2,bte,int,lng,@3)@
@:arithmeticImpl_1(@1,@2,bte,wrd,lng,@3)@
@:arithmeticImpl_3(@1,@2,bte,lng,lng,@3)@
@:arithmeticImpl_1(@1,@2,sht,bte,lng,@3)@
@:arithmeticImpl_1(@1,@2,sht,sht,lng,@3)@
@:arithmeticImpl_1(@1,@2,sht,int,lng,@3)@
@:arithmeticImpl_1(@1,@2,sht,wrd,lng,@3)@
@:arithmeticImpl_3(@1,@2,sht,lng,lng,@3)@
@:arithmeticImpl_1(@1,@2,int,bte,lng,@3)@
@:arithmeticImpl_1(@1,@2,int,sht,lng,@3)@
@:arithmeticImpl_1(@1,@2,int,int,lng,@3)@
@:arithmeticImpl_1(@1,@2,int,wrd,lng,@3)@
@:arithmeticImpl_3(@1,@2,int,lng,lng,@3)@
@:arithmeticImpl_1(@1,@2,wrd,bte,lng,@3)@
@:arithmeticImpl_1(@1,@2,wrd,sht,lng,@3)@
@:arithmeticImpl_1(@1,@2,wrd,int,lng,@3)@
@:arithmeticImpl_1(@1,@2,wrd,wrd,lng,@3)@
@:arithmeticImpl_3(@1,@2,wrd,lng,lng,@3)@
@:arithmeticImpl_3(@1,@2,lng,bte,lng,@3)@
@:arithmeticImpl_3(@1,@2,lng,sht,lng,@3)@
@:arithmeticImpl_3(@1,@2,lng,int,lng,@3)@
@:arithmeticImpl_3(@1,@2,lng,wrd,lng,@3)@
@:arithmeticImpl_3(@1,@2,lng,lng,lng,@3)@

@:arithmeticImpl_1(@1,@2,bte,bte,wrd,@3)@
@:arithmeticImpl_1(@1,@2,bte,sht,wrd,@3)@
@:arithmeticImpl_1(@1,@2,bte,int,wrd,@3)@
@:arithmeticImpl_3(@1,@2,bte,wrd,wrd,@3)@
@:arithmeticImpl_1(@1,@2,sht,bte,wrd,@3)@
@:arithmeticImpl_1(@1,@2,sht,sht,wrd,@3)@
@:arithmeticImpl_1(@1,@2,sht,int,wrd,@3)@
@:arithmeticImpl_3(@1,@2,sht,wrd,wrd,@3)@
@:arithmeticImpl_1(@1,@2,int,bte,wrd,@3)@
@:arithmeticImpl_1(@1,@2,int,sht,wrd,@3)@
@:arithmeticImpl_1(@1,@2,int,int,wrd,@3)@
@:arithmeticImpl_3(@1,@2,int,wrd,wrd,@3)@
@:arithmeticImpl_3(@1,@2,wrd,bte,wrd,@3)@
@:arithmeticImpl_3(@1,@2,wrd,sht,wrd,@3)@
@:arithmeticImpl_3(@1,@2,wrd,int,wrd,@3)@
@:arithmeticImpl_3(@1,@2,wrd,wrd,wrd,@3)@

@:arithmeticImpl_1(@1,@2,bte,bte,int,@3)@
@:arithmeticImpl_1(@1,@2,bte,sht,int,@3)@
@:arithmeticImpl_3(@1,@2,bte,int,int,@3)@
@:arithmeticImpl_1(@1,@2,sht,bte,int,@3)@
@:arithmeticImpl_1(@1,@2,sht,sht,int,@3)@
@:arithmeticImpl_3(@1,@2,sht,int,int,@3)@
@:arithmeticImpl_3(@1,@2,int,bte,int,@3)@
@:arithmeticImpl_3(@1,@2,int,sht,int,@3)@
@:arithmeticImpl_3(@1,@2,int,int,int,@3)@

@:arithmeticImpl_1(@1,@2,bte,bte,sht,@3)@
@:arithmeticImpl_3(@1,@2,bte,sht,sht,@3)@
@:arithmeticImpl_3(@1,@2,sht,bte,sht,@3)@
@:arithmeticImpl_3(@1,@2,sht,sht,sht,@3)@

@:arithmeticImpl_3(@1,@2,bte,bte,bte,@3)@

@:arithmeticImpl_1(@1,@2,flt,flt,dbl,@3)@
@:arithmeticImpl_3(@1,@2,flt,dbl,dbl,@3)@
@:arithmeticImpl_3(@1,@2,dbl,flt,dbl,@3)@
@:arithmeticImpl_3(@1,@2,dbl,dbl,dbl,@3)@

@:arithmeticImpl_3(@1,@2,flt,flt,flt,@3)@

@
@c
/*
@1:   +,   -,   *,   /     basic arithmetic operator symbol
@2:   ADD, SUB, MUL, DIV   basic arithmetic operator name
@3:     (bit pattern)      disable/enable sorting propagation
                            1 propagate as-is on bat,const
                            2 propagate as-is on const,bat
                            4 propagate reverted on bat,const (not required/used!)
                            8 propagate reverted on const,bat
                           16 propagate as-is / reverted on bat,const if const >=0 / <0
                           32 propagate as-is / reverted on const,bat if const >=0 / <0
*/
/* these 4 macros are there to be able to do prepossessor-time conditionals */
#define CMD_DIV 1
#define CMD_MUL 2
#define CMD_SUB 3
#define CMD_ADD 4
@:arithGrpImpl(/,DIV,16)@
@:arithGrpImpl(*,MUL,(16|32))@
@:arithGrpImpl(-,SUB,(1|8))@
@:arithGrpImpl(+,ADD,(1|2))@

@= numeric_funcs
batcalc_export str bataccum@2_@3_@4_@5(BAT *bn, BAT *b, BAT *right);
str bataccum@2_@3_@4_@5(BAT *bn, BAT *b, BAT *right)
{	
	@:accum(@1,@3,@4,@5)@
	BATsetcount(bn, BATcount(b));
	bn->tsorted = 0;
	BATkey(BATmirror(bn),FALSE);

	return MAL_SUCCEED;
}

batcalc_export str CMDbat@2_@3_@4_@5(int *ret, int *l, int *r);
str CMDbat@2_@3_@4_@5(int *ret, int *l, int *r)
{	
	BAT *bn, *b, *right;
	str msg;

	@:getBATdescriptor(l,b,"batcalc.@1")@
	@:getBATdescriptor(r,right,"batcalc.@1")@
	@:chkSize(b,right,CMDbat@2)@
	@:voidresultBAT(TYPE_@5,"batcalc.@1")@

	msg = bataccum@2_@3_@4_@5(bn,b,right);

	if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ); 

	if (b->htype != bn->htype) {
		BAT *r = VIEWcreate(b,bn);

		BBPreleaseref(bn->batCacheid);
		bn = r;
	}
	BBPkeepref(*ret = bn->batCacheid);
	BBPreleaseref(b->batCacheid);
	BBPreleaseref(right->batCacheid);
	return msg;
}

batcalc_export str CMDbataccum@2_@3_@4_@5(int *ret, int *l, int *r, bit *lflag, bit *rflag);
str CMDbataccum@2_@3_@4_@5(int *ret, int *l, int *r, bit *lflag, bit *rflag)
{	
	BAT *bn, *b, *right;
	str msg;

	@:getBATdescriptor(l,b,"batcalc.@1")@
	@:getBATdescriptor(r,right,"batcalc.@1")@

	if( *lflag && !isVIEW(b) && BBP_refs(*l) == 1 && BBP_lrefs(*l) == 1)
		bn = b;
	else if( *rflag && !isVIEW(right) && BBP_refs(*r) == 1 &&  BBP_lrefs(*r) == 1)
		bn = right;
	else{
		BBPreleaseref(b->batCacheid);
		BBPreleaseref(right->batCacheid);
		return CMDbat@2_@3_@4_@5(ret,l,r);
	}

	@:chkSize(bn,b,CMDbataccum@2)@
	@:chkSize(bn,right,CMDbataccum@2)@

	msg = bataccum@2_@3_@4_@5(bn,b,right);

	BBPkeepref(*ret = bn->batCacheid);
	if (b != bn)
		BBPreleaseref(b->batCacheid);
	if (right != bn)
		BBPreleaseref(right->batCacheid);
	return msg;
}

batcalc_export str CMDbat@2cst_@3_@4_@5(int *ret, int *l, void *cst);
str CMDbat@2cst_@3_@4_@5(int *ret, int *l, void *cst)
{	
	BAT *bn, *b;
	char *res = MAL_SUCCEED;

	@:getBATdescriptor(l,b,"batcalc.@1")@
	@:voidresultBAT(b->ttype,"batcalc.@1")@

	@:accumCst(@1,@3,@4,@5)@ 
	BATsetcount(bn, BATcount(b));
	bn->tsorted = 0;
	BATkey(BATmirror(bn),FALSE);

	if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ); 

	if (b->htype != bn->htype) {
		BAT *r = VIEWcreate(b,bn);

		BBPreleaseref(bn->batCacheid);
		bn = r;
	}
	BBPkeepref(*ret = bn->batCacheid);
	BBPreleaseref(b->batCacheid);
	return res;
}

batcalc_export str CMDbataccum@2cst_@3_@4_@5(int *ret, int *l, void *cst, bit *lflag, bit *rflag);
str CMDbataccum@2cst_@3_@4_@5(int *ret, int *l, void *cst, bit *lflag, bit *rflag)
{	
	BAT *bn, *b;

	(void) rflag;
	@:getBATdescriptor(l,b,"batcalc.@1")@
	if( *lflag && !isVIEW(b) && BBP_refs(*l) == 1 && BBP_lrefs(*l) == 1)
		bn = b;
	else {
		BBPreleaseref(b->batCacheid);
		return CMDbat@2cst_@3_@4_@5(ret,l,cst);
	}

	@:chkSize(bn,b,CMDbataccum@2)@

	@:accumCst(@1,@3,@4,@5)@

	bn->tsorted = 0;
	BATkey(BATmirror(bn),FALSE);

	if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ); 

	BBPkeepref(*ret = bn->batCacheid);
	if (b != bn)
		BBPreleaseref(b->batCacheid);
	return MAL_SUCCEED;
}

batcalc_export str CMDcst@2bat_@3_@4_@5(int *ret,void *cst, int *l);
str CMDcst@2bat_@3_@4_@5(int *ret,void *cst, int *l)
{	
	BAT *bn, *b;
	char *res = MAL_SUCCEED;

	@:getBATdescriptor(l,b,"batcalc.@1")@
	@:voidresultBAT(TYPE_@5,"batcalc.@1")@

	@:accumCstLeft(@1,@3,@4,@5)@ 
	BATsetcount(bn, BATcount(b));
	bn->tsorted = 0;
	BATkey(BATmirror(bn),FALSE);

	if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ); 

	if (b->htype != bn->htype) {
		BAT *r = VIEWcreate(b,bn);

		BBPreleaseref(bn->batCacheid);
		bn = r;
	}
	BBPkeepref(*ret = bn->batCacheid);
	BBPreleaseref(b->batCacheid);
	return res;
}

batcalc_export str CMDbataccum@2cst2_@3_@4_@5(int *ret, void *cst, int *r, bit *lflag, bit *rflag);
str CMDbataccum@2cst2_@3_@4_@5(int *ret, void *cst, int *r, bit *lflag, bit *rflag)
{	
	BAT *bn, *b;

	(void) lflag;
	@:getBATdescriptor(r,b,"batcalc.@1")@
	if( *rflag && !isVIEW(b) && BBP_refs(*r) == 1 && BBP_lrefs(*r) == 1)
		bn = b;
	else {
		BBPreleaseref(b->batCacheid);
		return CMDcst@2bat_@3_@4_@5(ret,cst,r);
	}

	@:chkSize(bn,b,CMDbataccum@2)@

	@:accumCstLeft(@1,@3,@4,@5)@

	if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ); 

	BBPkeepref(*ret = bn->batCacheid);
	if (b != bn)
		BBPreleaseref(b->batCacheid);
	return MAL_SUCCEED;
}
@
@c
/*
 * @-  Modulo arithmetic
 * The Modulo function doesn;t work on all types. Therefore we
 * define here the necessary implementations separately by copying
 * the arithmeticImpl block and removing elements not required.
 */
@:numeric_funcs(%,MOD,bte,bte,bte)@
@:numeric_funcs(%,MOD,sht,sht,sht)@
@:numeric_funcs(%,MOD,int,int,int)@
@:numeric_funcs(%,MOD,wrd,wrd,wrd)@
@:numeric_funcs(%,MOD,lng,lng,lng)@

@:numeric_funcs(^,XOR,oid,oid,oid)@
@:numeric_funcs(^,XOR,bte,bte,bte)@
@:numeric_funcs(^,XOR,sht,sht,sht)@
@:numeric_funcs(^,XOR,int,int,int)@
@:numeric_funcs(^,XOR,wrd,wrd,wrd)@
@:numeric_funcs(^,XOR,lng,lng,lng)@

@:numeric_funcs(&,AND,oid,oid,oid)@
@:numeric_funcs(&,AND,bte,bte,bte)@
@:numeric_funcs(&,AND,sht,sht,sht)@
@:numeric_funcs(&,AND,int,int,int)@
@:numeric_funcs(&,AND,wrd,wrd,wrd)@
@:numeric_funcs(&,AND,lng,lng,lng)@

@:numeric_funcs(|,OR,oid,oid,oid)@
@:numeric_funcs(|,OR,bte,bte,bte)@
@:numeric_funcs(|,OR,sht,sht,sht)@
@:numeric_funcs(|,OR,int,int,int)@
@:numeric_funcs(|,OR,wrd,wrd,wrd)@
@:numeric_funcs(|,OR,lng,lng,lng)@

@:numeric_funcs(<<,LSH,oid,int,oid)@
@:numeric_funcs(<<,LSH,bte,int,bte)@
@:numeric_funcs(<<,LSH,sht,int,sht)@
@:numeric_funcs(<<,LSH,int,int,int)@
@:numeric_funcs(<<,LSH,wrd,int,wrd)@
@:numeric_funcs(<<,LSH,lng,int,lng)@

@:numeric_funcs(>>,RSH,oid,int,oid)@
@:numeric_funcs(>>,RSH,bte,int,bte)@
@:numeric_funcs(>>,RSH,sht,int,sht)@
@:numeric_funcs(>>,RSH,int,int,int)@
@:numeric_funcs(>>,RSH,wrd,int,wrd)@
@:numeric_funcs(>>,RSH,lng,int,lng)@

/*
 * @- Implementation of unary operations
 */
@= accumUnary
	{
		@2* p = (@2*)Tloc(b,BUNfirst(b));
		@2 *q = (@2*)Tloc(b,BUNlast(b));
		@2 *o = (@2*)Tloc(bn,BUNfirst(bn));

		BATaccessBegin(b, USE_TAIL, MMAP_SEQUENTIAL);
		if (b->T->nonil)
			for(; p<q; p++, o++)
				*o = @1(*p);
		else
			for(; p<q; p++, o++){
				/* this code is better as x?nil:y  */
				if(*p == @2_nil ) {
					*o = @2_nil;
					bn->T->nonil = 0;
				} else 
					*o = @1(*p);
			}
		BATaccessEnd(b, USE_TAIL, MMAP_SEQUENTIAL);
	}
@
 * @-
 * Unary accummulators are only called indirectly. They cannot
 * always be defined without signature clashes, eg. -(batA,batC).
@= unary_impl
batcalc_export str CMDunary@2(int *ret, int *bid);
str CMDunary@2(int *ret, int *bid)
{
	BAT *b,*bn;
	
	@:getBATdescriptor(bid,b,"batcalc.@1")@
	@:voidresultBAT(b->ttype,"batcalc.@1")@

	switch(BATttype(bn)){
	case TYPE_bte: @:accumUnary(@1,bte)@ break;
	case TYPE_sht: @:accumUnary(@1,sht)@ break;
	case TYPE_int: @:accumUnary(@1,int)@ break;
	case TYPE_wrd: @:accumUnary(@1,wrd)@ break;
	case TYPE_lng: @:accumUnary(@1,lng)@ break;
	case TYPE_flt: @:accumUnary(@1,flt)@ break;
	case TYPE_dbl: @:accumUnary(@1,dbl)@ break;
	default : throw(MAL, "batcalc.@1", ILLEGAL_ARGUMENT " Expected {bte,sht,int,wrd,lng,flt,dbl}");
	}
	BATsetcount(bn, BATcount(b));
	bn->tsorted = 0;
	BATkey(BATmirror(bn),FALSE);

	if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ); 

	if (b->htype != bn->htype) {
		BAT *r = VIEWcreate(b,bn);

		BBPreleaseref(bn->batCacheid);
		bn = r;
	}
	BBPkeepref(*ret = bn->batCacheid);
	BBPreleaseref(b->batCacheid);
	return MAL_SUCCEED;
}
@
@c
@:unary_impl(-,MIN)@
@:unary_impl(--,MINMIN)@
@:unary_impl(++,PLUSPLUS)@
@:unary_impl(calc_abs,ABS)@

@= accumUnaryISNIL
{
	@1 *p = (@1*)Tloc(b,BUNfirst(b)); 
	@1 *q = (@1*)Tloc(b,BUNlast(b)); 
	BATaccessBegin(b, USE_TAIL, MMAP_SEQUENTIAL);
	if (b->T->nonil){
		for(; p<q; p++, o++ )
			*o = FALSE;
	} else 
		for(; p<q; p++, o++ )
			*o = (*p == @1_nil);
	BATaccessEnd(b, USE_TAIL, MMAP_SEQUENTIAL);
}
@
@c
batcalc_export str CMDunaryISNIL(int *ret, int *bid);
str CMDunaryISNIL(int *ret, int *bid)
{
	BAT *b,*bn;
	bit *o;
	
	@:getBATdescriptor(bid,b,"batcalc.isnil")@
	@:voidresultBAT(TYPE_bit,"batcalc.isnil")@

	o = (bit*)Tloc(bn,BUNfirst(bn)); 
	switch(BATttype(b)){
	case TYPE_bit: @:accumUnaryISNIL(bit)@ break;
	case TYPE_bte: @:accumUnaryISNIL(bte)@ break;
	case TYPE_oid: @:accumUnaryISNIL(oid)@ break;
	case TYPE_sht: @:accumUnaryISNIL(sht)@ break;
	case TYPE_int: @:accumUnaryISNIL(int)@ break;
	case TYPE_wrd: @:accumUnaryISNIL(wrd)@ break;
	case TYPE_lng: @:accumUnaryISNIL(lng)@ break;
	case TYPE_flt: @:accumUnaryISNIL(flt)@ break;
	case TYPE_dbl: @:accumUnaryISNIL(dbl)@ break;
	case TYPE_str: {
			BATiter bi = bat_iterator(b);
			BUN p,q;

			BATaccessBegin(b, USE_TAIL, MMAP_SEQUENTIAL);
			if (b->T->nonil){
				BATloop(b, p, q)
					*o++ = FALSE;
			} else
				BATloop(b, p, q) {
					str t = (str) BUNtail(bi,p);
					*o = strcmp(t, str_nil) == 0;
					o++;
				}
			BATaccessEnd(b, USE_TAIL, MMAP_SEQUENTIAL);
		} break;
	default : throw(MAL, "batcalc.isnil", ILLEGAL_ARGUMENT " Expected {oid,bit,bte,sht,int,wrd,lng,flt,dbl,str}");
	}
	BATsetcount(bn, BATcount(b));
	bn->tsorted = 0;
	BATkey(BATmirror(bn),FALSE);

	if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ); 

	if (b->htype != bn->htype) {
		BAT *r = VIEWcreate(b,bn);

		BBPreleaseref(bn->batCacheid);
		bn = r;
	}
	BBPkeepref(*ret = bn->batCacheid);
	BBPreleaseref(b->batCacheid);
	return MAL_SUCCEED;
}

/*
 * @- Comparison operator implementation
 * The structure of this code is copied from the arithmetic scheme.
 */
@= baselineCode
batcalc_export str CMD_@2_@3(int *ret, int *l, int *r);
str CMD_@2_@3(int *ret, int *l, int *r)
{	
	BAT *bn, *b, *right;
	@3 *p, *q, *t;
	bit *o;

	@:getBATdescriptor(l,b,"batcalc.@1")@
	@:getBATdescriptor(r,right,"batcalc.@1", BBPreleaseref(b->batCacheid);)@
	@:chkSize(b,right,batcalc.@1)@
	@:voidresultBAT(TYPE_bit,"batcalc.@1")@

	o = (bit*)Tloc(bn,BUNfirst(bn));
	p = (@3*)Tloc(b,BUNfirst(b));
	q = (@3*)Tloc(b,BUNlast(b));
	t = (@3*)Tloc(right,BUNfirst(right));
		
	BATaccessBegin(b, USE_TAIL, MMAP_SEQUENTIAL);
	BATaccessBegin(right, USE_TAIL, MMAP_SEQUENTIAL);
	if (b->T->nonil && right->T->nonil) {
		for (;p<q; p++, t++, o++)
			*o = (*p @1 *t);
	} else if (b->T->nonil) {
		for (;p<q; p++, t++, o++) {
			if (*t == @3_nil) {
#if OPERATOR_@2 == OPERATOR_OR
				if (*p)
					*o = 1;
				else
#endif
#if OPERATOR_@2 == OPERATOR_AND
				if (!*p)
					*o = 0;
				else
#endif
				{
					*o = bit_nil;
					bn->T->nonil = 0;
				}
			} else 
				*o = (*p @1 *t);
		}
	} else if (right->T->nonil)
		for (;p<q; p++, t++, o++) {
			if (*p == @3_nil) {
#if OPERATOR_@2 == OPERATOR_OR
				if (*t)
					*o = 1;
				else
#endif
#if OPERATOR_@2 == OPERATOR_AND
				if (!*t)
					*o = 0;
				else
#endif
				{
					*o = bit_nil;
					bn->T->nonil = 0;
				}
			} else 
				*o = (*p @1 *t);
		}
	else
		for (;p<q; p++, t++, o++) {
			if (*p == @3_nil) {
#if OPERATOR_@2 == OPERATOR_OR
				if (*t != @3_nil && *t)
					*o = 1;
				else
#endif
#if OPERATOR_@2 == OPERATOR_AND
				if (*t != @3_nil && !*t)
					*o = 0;
				else
#endif
				{
					*o = bit_nil;
					bn->T->nonil = 0;
				}
			} else if (*t == @3_nil) {
#if OPERATOR_@2 == OPERATOR_OR
				if (*p)
					*o = 1;
				else
#endif
#if OPERATOR_@2 == OPERATOR_AND
				if (!*p)
					*o = 0;
				else
#endif
				{
					*o = bit_nil;
					bn->T->nonil = 0;
				}
			} else
				*o = *p @1 *t;
		}

	BATaccessEnd(right, USE_TAIL, MMAP_SEQUENTIAL);
	BATaccessEnd(b, USE_TAIL, MMAP_SEQUENTIAL);
	BATsetcount(bn, BATcount(b));
	bn->tsorted = 0;
	BATkey(BATmirror(bn),FALSE);

	if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ); 

	if (b->htype != bn->htype) {
		BAT *rview = VIEWcreate(b,bn);

		BBPreleaseref(bn->batCacheid);
		bn = rview;
	}
	BBPkeepref(*ret= bn->batCacheid);
	BBPreleaseref(b->batCacheid);
	BBPreleaseref(right->batCacheid);
	return MAL_SUCCEED;
}

batcalc_export str CMDaccum_@2_@3(int *ret, int *d, int *l, int *r);
str CMDaccum_@2_@3(int *ret, int *d, int *l, int *r)
{	
	BAT *bn, *b, *right;
	@3 *p, *q, *t;
	bit *o;

	@:getBATdescriptor(l,b,"batcalc.@1")@
	@:getBATdescriptor(r,right,"batcalc.@1", BBPreleaseref(b->batCacheid);)@
	@:getBATdescriptor(d,bn,"batcalc.@1", BBPreleaseref(b->batCacheid);BBPreleaseref(right->batCacheid);)@
	@:chkSize(bn,b,batcalc.@1)@
	@:chkSize(bn,right,batcalc.@1)@

	o = (bit*)Tloc(bn,BUNfirst(bn));
	p = (@3*)Tloc(b,BUNfirst(b));
	q = (@3*)Tloc(b,BUNlast(b));
	t = (@3*)Tloc(right,BUNfirst(right));
		
	BATaccessBegin(b, USE_TAIL, MMAP_SEQUENTIAL);
	BATaccessBegin(right, USE_TAIL, MMAP_SEQUENTIAL);
	if (b->T->nonil && right->T->nonil) {
		for (;p<q; p++, t++, o++)
			*o = (*p @1 *t);
	} else if (b->T->nonil) {
		for (;p<q; p++, t++, o++) {
			if (*t == @3_nil) {
#if OPERATOR_@2 == OPERATOR_OR
				if (*p)
					*o = 1;
				else
#endif
#if OPERATOR_@2 == OPERATOR_AND
				if (!*p)
					*o = 0;
				else
#endif
				{
					*o = bit_nil;
					bn->T->nonil = 0;
				}
			} else 
				*o = (*p @1 *t);
		}
	} else if (right->T->nonil)
		for (;p<q; p++, t++, o++) {
			if (*p == @3_nil) {
#if OPERATOR_@2 == OPERATOR_OR
				if (*t)
					*o = 1;
				else
#endif
#if OPERATOR_@2 == OPERATOR_AND
				if (!*t)
					*o = 0;
				else
#endif
				{
					*o = bit_nil;
					bn->T->nonil = 0;
				}
			} else 
				*o = (*p @1 *t);
		}
	else
		for (;p<q; p++, t++, o++) {
			if (*p == @3_nil) {
#if OPERATOR_@2 == OPERATOR_OR
				if (*t != @3_nil && *t)
					*o = 1;
				else
#endif
#if OPERATOR_@2 == OPERATOR_AND
				if (*t != @3_nil && !*t)
					*o = 0;
				else
#endif
				{
					*o = bit_nil;
					bn->T->nonil = 0;
				}
			} else if (*t == @3_nil) {
#if OPERATOR_@2 == OPERATOR_OR
				if (*p)
					*o = 1;
				else
#endif
#if OPERATOR_@2 == OPERATOR_AND
				if (!*p)
					*o = 0;
				else
#endif
				{
					*o = bit_nil;
					bn->T->nonil = 0;
				}
			} else 
				*o = (*p @1 *t);
		}
	BATaccessEnd(right, USE_TAIL, MMAP_SEQUENTIAL);
	BATaccessEnd(b, USE_TAIL, MMAP_SEQUENTIAL);

	BATsetcount(bn, BATcount(b));
	bn->tsorted = 0;
	BATkey(BATmirror(bn),FALSE);

	BBPkeepref(*ret= bn->batCacheid);
	BBPreleaseref(b->batCacheid);
	BBPreleaseref(right->batCacheid);
	return MAL_SUCCEED;
}
@= baselineCstCode
batcalc_export str CMD_@2_@3_cst(int *ret, int *l, @3 *cst);
str CMD_@2_@3_cst(int *ret, int *l, @3 *cst)
{	
	BAT *bn, *b;
	@3 *p, *q;
	bit *o;

	@:getBATdescriptor(l,b,"batcalc.@1")@
	@:voidresultBAT(TYPE_bit,"batcalc.@1")@

	o = (bit*)Tloc(bn,BUNfirst(bn));
	p = (@3*)Tloc(b,BUNfirst(b));
	q = (@3*)Tloc(b,BUNlast(b));
	BATaccessBegin(b, USE_TAIL, MMAP_SEQUENTIAL);
		
	if (*cst == @3_nil) {
#if OPERATOR_@2 == OPERATOR_OR
		for (;p<q; p++, o++)
			if (*p != @3_nil && *p)
				*o = 1;
			else {
				*o = bit_nil;
				bn->T->nonil = 0;
			}
#else
#if OPERATOR_@2 == OPERATOR_AND
		for (;p<q; p++, o++)
			if (*p != @3_nil && !*p)
				*o = 0;
			else {
				*o = bit_nil;
				bn->T->nonil = 0;
			}
#else
		bn->T->nonil = 0;
		for (;p<q; p++, o++) 
			*o = bit_nil;
#endif
#endif
	} else if (b->T->nonil )
		for (;p<q; p++, o++)
			*o = (*p @1 *cst);
	else
		for (;p<q; p++, o++) {
			if( *p == @3_nil ) {
#if OPERATOR_@2 == OPERATOR_OR
				if (*cst)
					*o = 1;
				else
#endif
#if OPERATOR_@2 == OPERATOR_AND
				if (!*cst)
					*o = 0;
				else
#endif
				{
					*o = bit_nil;
					bn->T->nonil = 0;
				}
			} else 
				*o = (*p @1 *cst);
		}
	BATaccessEnd(b, USE_TAIL, MMAP_SEQUENTIAL);

	BATsetcount(bn, BATcount(b));
	bn->tsorted = 0;
	BATkey(BATmirror(bn),FALSE);

	if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ);

	if (b->htype != bn->htype) {
		BAT *r = VIEWcreate(b,bn);

		BBPreleaseref(bn->batCacheid);
		bn = r;
	}
	BBPkeepref(*ret= bn->batCacheid);
	BBPreleaseref(b->batCacheid);
	return MAL_SUCCEED;
}
batcalc_export str CMD_@4_cst_@3(int *ret, @3 *cst, int *l);
str CMD_@4_cst_@3(int *ret, @3 *cst, int *l) 
{
	return CMD_@2_@3_cst(ret,l,cst);
}

batcalc_export str CMDaccum_@2_@3_cst(int *ret, int *r, int *l, @3 *cst);
str CMDaccum_@2_@3_cst(int *ret, int *r, int *l, @3 *cst)
{	
	BAT *bn, *b;
	@3 *p, *q;
	bit *o;

	@:getBATdescriptor(r,bn,"batcalc.@1")@
	@:getBATdescriptor(l,b,"batcalc.@1", BBPreleaseref(bn->batCacheid);)@
	@:chkSize(bn,b,batcalc.@1)@

	o = (bit*)Tloc(bn,BUNfirst(bn));
	p = (@3*)Tloc(b,BUNfirst(b));
	q = (@3*)Tloc(b,BUNlast(b));
		
	BATaccessBegin(b, USE_TAIL, MMAP_SEQUENTIAL);
	if (*cst == @3_nil) {
#if OPERATOR_@2 == OPERATOR_OR
		bn->T->nonil = 1;
		for (;p<q; p++, o++)
			if (*p != @3_nil && *p)
				*o = 1;
			else {
				*o = bit_nil;
				bn->T->nonil = 0;
			}
#else
#if OPERATOR_@2 == OPERATOR_AND
		bn->T->nonil = 1;
		for (;p<q; p++, o++)
			if (*p != @3_nil && !*p)
				*o = 0;
			else {
				*o = bit_nil;
				bn->T->nonil = 0;
			}
#else
		bn->T->nonil = 0;
		for (;p<q; p++, o++) 
			*o = bit_nil;
#endif
#endif
	} else if (b->T->nonil )
		for (;p<q; p++, o++)
			*o = (*p @1 *cst);
	else
		for (;p<q; p++, o++) {
			if( *p == @3_nil ) {
#if OPERATOR_@2 == OPERATOR_OR
				if (*cst)
					*o = 1;
				else
#endif
#if OPERATOR_@2 == OPERATOR_AND
				if (!*cst)
					*o = 0;
				else
#endif
				{
					*o = bit_nil;
					bn->T->nonil = 0;
				}
			} else 
				*o = (*p @1 *cst);
		}
	BATaccessEnd(b, USE_TAIL, MMAP_SEQUENTIAL);

	bn->tsorted = 0;
	BATkey(BATmirror(bn),FALSE);

	BBPkeepref(*ret= bn->batCacheid);
	BBPreleaseref(b->batCacheid);
	return MAL_SUCCEED;
}
batcalc_export str CMDaccum_@4_cst_@3(int *ret, int *r, @3 *cst, int *l);
str CMDaccum_@4_cst_@3(int *ret, int *r, @3 *cst, int *l)
{
	return CMDaccum_@2_@3_cst(ret, r, l, cst);
}

@
 * @-
@= operatorImpl
	@:baselineCode(@1,@2,bit)@
	@:baselineCode(@1,@2,bte)@
	@:baselineCode(@1,@2,sht)@
	@:baselineCode(@1,@2,int)@
	@:baselineCode(@1,@2,wrd)@
	@:baselineCode(@1,@2,lng)@
	@:baselineCode(@1,@2,dbl)@
	@:baselineCode(@1,@2,flt)@
	@:baselineCode(@1,@2,oid)@
@= operatorCstImpl
	@:baselineCstCode(@1,@2,bit,@3)@
	@:baselineCstCode(@1,@2,bte,@3)@
	@:baselineCstCode(@1,@2,sht,@3)@
	@:baselineCstCode(@1,@2,int,@3)@
	@:baselineCstCode(@1,@2,wrd,@3)@
	@:baselineCstCode(@1,@2,lng,@3)@
	@:baselineCstCode(@1,@2,dbl,@3)@
	@:baselineCstCode(@1,@2,flt,@3)@
	@:baselineCstCode(@1,@2,oid,@3)@
@
@c
/* these 8 macros are there to be able to do prepossessor-time conditionals */
#define OPERATOR_GE 0
#define OPERATOR_LE 1
#define OPERATOR_GT 2
#define OPERATOR_LT 3
#define OPERATOR_EQ 4
#define OPERATOR_NEQ 5
#define OPERATOR_AND 6
#define OPERATOR_OR 7

@:operatorImpl(>=,GE)@
@:operatorImpl(<=,LE)@
@:operatorImpl(>,GT)@
@:operatorImpl(<,LT)@
@:operatorImpl(==,EQ)@
@:operatorImpl(!=,NEQ)@
@:baselineCode(&&,AND,bit)@
@:baselineCode(||,OR,bit)@

@:operatorCstImpl(>=,GE,LE)@
@:operatorCstImpl(<,LT,GT)@
@:operatorCstImpl(>,GT,LT)@
@:operatorCstImpl(<=,LE,GE)@
@:operatorCstImpl(==,EQ,EQ)@
@:operatorCstImpl(!=,NEQ,NEQ)@
@:baselineCstCode(&&,AND,bit,AND)@
@:baselineCstCode(||,OR,bit,OR)@

batcalc_export str CMDbitbataccumNOT(int *ret, int *d, int *l);
str
CMDbitbataccumNOT(int *ret, int *d, int *l)
{
	BAT *bn, *b;
	bit *p, *q, *o;

	@:getBATdescriptor(d,bn,"batcalc.not")@
	@:getBATdescriptor(l,b,"batcalc.not",BBPreleaseref(bn->batCacheid);)@
	@:chkSize(bn,b,batcalc.not)@

	p = (bit*) Tloc(bn,BUNfirst(bn));
	q = (bit*) Tloc(bn,BUNlast(bn));
	o = (bit*) Tloc(b,BUNfirst(b));

	BATaccessBegin(b, USE_TAIL, MMAP_SEQUENTIAL);
	if (b->T->nonil) {
		for (;p<q; p++, o++)
			*p = ! *o;
	} else
	for (;p<q; p++, o++) {
		if (*o == bit_nil) {
			*p = bit_nil;
			bn->T->nonil = 0;
		} else 
			*p = ! *o;
	}
	BATaccessEnd(b, USE_TAIL, MMAP_SEQUENTIAL);

	bn->tsorted = 0;
	BATkey(BATmirror(bn),FALSE);

	BBPkeepref(*ret= bn->batCacheid);
	BBPreleaseref(b->batCacheid);
	return MAL_SUCCEED;
}

batcalc_export str CMDbitbatNOT(int *ret, int *bid);
str
CMDbitbatNOT(int *ret, int *bid)
{
	BAT *bn, *b;
	bit *p, *q, *o;

	@:getBATdescriptor(bid,b,"batcalc.not")@
	@:voidresultBAT(TYPE_bit,"batcalc.not")@

	o = (bit*) Tloc(bn,BUNfirst(bn));
	p = (bit*) Tloc(b,BUNfirst(b));
	q = (bit*) Tloc(b,BUNlast(b));

	BATaccessBegin(b, USE_TAIL, MMAP_SEQUENTIAL);
	if (b->T->nonil) {
		for (;p<q; p++, o++)
			*o = ! *p;
	} else
		for (;p<q; p++, o++) {
			if (*p == bit_nil) {
				*o = bit_nil;
				bn->T->nonil = 0;
			} else 
				*o = ! *p;
		}
	BATaccessEnd(b, USE_TAIL, MMAP_SEQUENTIAL);

	BATsetcount(bn, BATcount(b));
	bn->tsorted = 0;
	BATkey(BATmirror(bn),FALSE);

	if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ);

	if (b->htype != bn->htype) {
		BAT *r = VIEWcreate(b,bn);

		BBPreleaseref(bn->batCacheid);
		bn = r;
	}

	BBPkeepref(*ret = bn->batCacheid);
	BBPreleaseref(b->batCacheid);
	return MAL_SUCCEED;
}
