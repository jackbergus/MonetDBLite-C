@/
The contents of this file are subject to the MonetDB Public License
Version 1.1 (the "License"); you may not use this file except in
compliance with the License. You may obtain a copy of the License at
http://www.monetdb.org/Legal/MonetDBLicense

Software distributed under the License is distributed on an "AS IS"
basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations
under the License.

The Original Code is the MonetDB Database System.

The Initial Developer of the Original Code is CWI.
Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
Copyright August 2008-2011 MonetDB B.V.
All Rights Reserved.
@

@f run_tarantula
@a M. Kersten
@+ Tarantula scheduling
To make the tarantula work, the scheduler needs a list of databases
to play with. This list it gets from Merovingian by resolving
all with the property 'shared=tarantula' (set by monetdb).
The default is to use the local database as a target.
@{
@mal
pattern tarantula.register(node:int,fname:str...):void
address TARregister
comment "Register mal functions at server indexed by node.";

pattern tarantula.getBid(node:int,fname:str...)(:int...)
address TARbidding
comment "Obtain a bid for mal functions at server indexed by node.";

pattern tarantula.schedule(cost:int...)(:int...)
address TARschedule
comment "Derive the list of nodes to run the legs";

command tarantula.connect(dbname:int):str
address TARconnect
comment "Returns the connection to the server dbname.";

@h
#ifndef _RUN_TAR
#define _RUN_TAR
#include "mal.h"
#include "mal_instruction.h"
#include "mal_client.h"

#define OPTDEBUGtarantula  if ( optDebug & ((lng)1 <<DEBUG_OPT_TARANTULA) )


#ifdef WIN32
#if !defined(LIBMAL) && !defined(LIBATOMS) && !defined(LIBKERNEL) && !defined(LIBMAL) && !defined(LIBOPTIMIZER) && !defined(LIBSCHEDULER) && !defined(LIBMONETDB5)
#define tarantula_export extern __declspec(dllimport)
#else
#define tarantula_export extern __declspec(dllexport)
#endif
#else
#define tarantula_export extern
#endif

tarantula_export str TARrun(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
tarantula_export str TARregister(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
tarantula_export str TARbidding(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
tarantula_export str TARschedule(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
tarantula_export str TARconnect(str *c, int *dbid);

#endif /* MAL_RUN_TAR */

@+ Scheduling implementation
The discovery phase consists of establishing connections with
the (remote) database servers.
@c
#include "monetdb_config.h"
#include "mal_interpreter.h"
#include "mat.h"
#include "run_tarantula.h"
#include "opt_tarantula.h"
#include <mapi.h>
#include "remote.h"
#include "mal_sabaoth.h"

bte optimizationTarget = 1; 
/*sht bidStrategy = 1; 
#define BID_TRANS	1
#define BID_COVER	2
*/
@-
Establish a connection and keep the handle for re-use
@c
str
TARconnect(str *c, int *dbid)
{
	str msg = MAL_SUCCEED, msql="msql";
	str uri;

	*c = NULL;
	if ( *dbid < 0 || *dbid >= MAXSITES)
		throw(MAL, "tarantula.connect", "Illegal server %d", *dbid);
	uri = peers[*dbid].uri;
	if ( uri == 0  || *uri == 0)
		return MAL_SUCCEED; /* silently ignore it */
	
	if ( peers[*dbid].conn == NULL ) {
		msg = RMTconnectScen(&peers[*dbid].conn, &peers[*dbid].uri, &peers[*dbid].usr, &peers[*dbid].pwd, &msql);
		if ( msg )
			return msg;
	}

	*c = GDKstrdup(peers[*dbid].conn);
	return msg;
}
@-
We first register the leg code at all peers and keep a list of those already sent.
@c
static int
TARfind(int i, str qry){
	Registry r;
	for ( r= peers[i].nxt; r; r= r->nxt)
	if ( strcmp(qry, r->fcn)==0)
		return 1;
	return 0;
}
@-
Discover available workers and register leg code on them
@c
str TARregister(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	int p,j;
	str conn, fname, dburi, msg = MAL_SUCCEED;

	(void) cntxt;
	(void) mb;
	if (tarantulaLocal)
		return MAL_SUCCEED;
	dburi = peers[*(int*)getArgReference(stk,pci,1)].uri;
	if ( dburi == NULL) 
		return MAL_SUCCEED; /* ignore registration as a particular node */

#ifdef DEBUG_RUN_TAR
		stream_printf(cntxt->fdout,"connect to  uri %s\n", dburi);
#else
			(void)cntxt;
#endif
	msg = TARconnect(&conn, (int*) getArgReference(stk,pci,1));
	if ( conn == NULL)
		return MAL_SUCCEED;	/* silently ignore */
	if ( msg )
		return msg;
	p =	TARgetPeer(dburi);
	if ( p < 0 )
		throw(MAL,"tarantula.register",PROGRAM_NYI);

	for( j=2; j< pci->argc; j++)
	{
		fname = *(str*)getArgReference(stk,pci,j);

		if( !TARfind(p, fname) ){
			msg = RMTregisterInternal(cntxt, conn, tarantulaRef, fname);

#ifdef DEBUG_RUN_TAR
			stream_printf(cntxt->fdout,"tarantula.%s registered at site %s\n", fname,dburi);
			stream_printf(cntxt->fdout,"reply: %s\n",msg?msg:"ok");
#endif
			if ( msg == MAL_SUCCEED){
				Registry r= (Registry) GDKzalloc(sizeof(struct REGMAL));
				r->fcn = GDKstrdup(fname);
				r->nxt = peers[p].nxt;
				peers[p].nxt = r;
			}
		}
	}
	return msg;
}

str
TARbidding(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
    int *res = (int*) getArgReference(stk,pci,0);
    int k;
	str msg = MAL_SUCCEED;

	(void) mb;
#ifdef DEBUG_RUN_TAR
	stream_printf(cntxt->fdout,"Start bidding on node %d: ",*(int*) getArgReference(stk,pci,pci->retc);
#else
			(void) cntxt;
#endif
	if ( tarantulaLocal ) { /* skip bidding for local execution */
		for (k = 0; k < pci->retc ; k++){
			res = (int*) getArgReference(stk,pci,k);
			*res = 1;
#ifdef DEBUG_RUN_TAR
			stream_printf(cntxt->fdout,"%d, ",*res);
#endif
		}
	}
#ifdef DEBUG_RUN_TAR
	stream_printf(cntxt->fdout,"\n");
#endif
    return msg;

}

static lng
putJob(int t, int tcnt, lng **bid, bte *busy, bte **rsch)
{
	int k,r;
	bte *cur=NULL;
	char fl = 0;
	lng c=0, rc, maxc=0;
	
	cur = (bte*) GDKzalloc(sizeof(bte) * tcnt);

	for (k = 0; k < tcnt; k++){
		if (busy[k]) continue;
		if ( bid[t][k] < 0 ) continue; /* bid<0 => I don't want to participate */
		busy[k] = 1;
		if (t < tcnt - 1){
			rc = putJob(t+1,tcnt,bid,busy,&cur);
			switch (optimizationTarget){
			case 1:	/* maximize the total */
				c = rc + bid[t][k];
				break;
			case 2:	/* makespan */
				c = (rc > bid[t][k])? rc: bid[t][k];
				break;
			}
		}
		else {
			c = bid[t][k];
		}
	
		if (fl) {
			if (c > maxc){
				(*rsch)[t] = k;
				maxc = c;
				for (r = t+1; r < tcnt; r++)
					(*rsch)[r] = cur[r];
			}
		}
		else {
			(*rsch)[t] = k;
			maxc = c;
			for (r = t+1; r < tcnt; r++)
				(*rsch)[r] = cur[r];
			fl = 1;
		}
		busy[k] = 0;
	}

	GDKfree(cur);
	return maxc;
}


str
TARschedule(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	int nodes, offset, i, j, k, idx;
	str msg = MAL_SUCCEED;
	lng **bid=NULL;	
	bte *sch=NULL, *busy;

	(void) mb;
	(void) cntxt;

	/* get number of legs */
	offset = pci->retc;
	nodes = (pci->argc - pci->retc)/ TARnrpeers ;
	if ( pci->argc % pci->retc )
		throw(MAL,"tarantula.schedule","incompatibe argumentlist");
#ifdef DEBUG_RUN_TAR
	stream_printf(cntxt->fdout,"schedule %s\n",offset);
#endif
	bid = (lng**) GDKzalloc(sizeof(lng*) * nodes);
	sch = (bte*) GDKzalloc(sizeof(bte) * nodes);
	busy = (bte*) GDKzalloc(sizeof(bte) * nodes);

	for ( j = 0; j < nodes; j++){
		bid[j] = (lng*) GDKzalloc(sizeof(lng) * nodes);
	}
	for ( i = pci->retc; i < pci->argc; i++) {
		j = (int) (i-offset) / pci->retc;
		k = (int) (i-offset) % pci->retc;
		bid[j][k] = *(lng*) getArgReference(stk,pci,i);
	}

	/* compute schedule */
	if ( 0 ) /* Optimal */	
		putJob(0,pci->retc,bid,busy,&sch);
	else /*	Round Robin */
	for ( j = 0; j < pci->retc; j++)
		sch[j] = j;
		
	/* set returned schedule variables */
	idx = 0;
	for ( j = 0; j < nodes; j++)
		for ( k = 0; k < nodes; k++){
			if ( sch[j] == k) {
				*(int*) getArgReference(stk,pci,idx++) = k;
				break;
			}
	}

	for ( j= 0; j < nodes; j++)
		GDKfree(bid[j]);
	GDKfree(bid);
	GDKfree(sch);
	GDKfree(busy);
	return msg;
}

@-
static str
TARdisconnect()
{
	int i, ret;
	str msg = MAL_SUCCEED;

	for ( i=0; i< TARnrpeers; i++)
		if ( peers[i].active && peers[i].conn != NULL ) {
		msg = RMTdisconnect(&ret,&peers[i].conn);
		GDKfree(peers[i].conn);
		peers[i].conn = NULL;
	}
	return msg;
}
@}
