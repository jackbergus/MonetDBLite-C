@/
The contents of this file are subject to the MonetDB Public License
Version 1.1 (the "License"); you may not use this file except in
compliance with the License. You may obtain a copy of the License at
http://www.monetdb.org/Legal/MonetDBLicense

Software distributed under the License is distributed on an "AS IS"
basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations
under the License.

The Original Code is the MonetDB Database System.

The Initial Developer of the Original Code is CWI.
Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
Copyright August 2008-2011 MonetDB B.V.
All Rights Reserved.
@

@f crackers_sortmerge
@a Martin Kersten, Stratos Idreos, Stefan Manegold
@d March 2006 - July 2007
@* Select Operators for Incremental sort merge


@+ Interface


@- Type expansion

@= TypeSwitch
@:@1(int,simple,,int)@
@


@- Header file

@h
#ifndef _CRACKERS_SORTMERGE_H_
#define _CRACKERS_SORTMERGE_H_

/* Exported signatures */
@:TypeSwitch(SelectFunctions_decl)@

#endif /* _CRACKERS_SORTMERGE_H */
@


@- Exported signatures

@= SelectFunctions_decl
crackers_export str CRKselectSortMerge_@1(int *vid, int *bid, @1 *low, @1 *hgh, bit *inclusiveLow, bit *inclusiveHgh, int *mode, bit *rounding, int *sliceSize);
crackers_export str CRKPartitionedSort_@1(int *vid, int *bid, int *mode);
crackers_export str CRKExternalSort_@1(int *vid, int *bid, int *psliceSize);
@


@{
@+ Implementation


@- C file

@c
#include "monetdb_config.h"
#include "algebra.h"
#include "crackers.h"

/* Local support functions and macros */
@:TypeSwitch(SortMergeOperations)@

/* Exported functions */
@:TypeSwitch(SelectFunctions_impl)@
@


@- Exported functions

@= SelectFunctions_impl
str
CRKselectSortMerge_@1(int *vid, int *bid, @1 *low, @1 *hgh, bit *inclusiveLow, bit *inclusiveHgh, int *mode, bit *rounding, int *sliceSize){		
	if (@2_EQ(low,ATOMnilptr(TYPE_@1),@3@1))
		throw(MAL,"selectsm","only double bounded selectsare currently supported");
	else if (@2_EQ(hgh,ATOMnilptr(TYPE_@1),@3@1))
		throw(MAL,"selectsm","only double bounded selectsare currently supported");
	else
		return SelectSortMergeBounds_@1(vid, bid, low, hgh, inclusiveLow, inclusiveHgh, mode,rounding,sliceSize);
}
@


@- Local support functions and macros

@= NwayMergeSort
	QNodesSize=0;
	current=head;
	while(current!=NULL){
		current->start=0;
		current->tuples=BATcount(current->slice);
		QNodes[QNodesSize++]=current;
		current=current->next;
	}

	/*N-way merge*/
	rh = (oid*)Hloc(br,BUNfirst(br));
	rt = (@1 *)Tloc(br,BUNfirst(br));
	if (*mode==1){
		@:LoopMerge(@1,@2,@3,head)@	
	}else
	if (*mode==3){
		@:PQMerge(@1)@
	}
@

@= MergeExtSort

	QNodesSize=0;
	current=head;
	while(current!=NULL){
		oid nextBatch;
		if ((current->run = BATdescriptor(current->batId)) == NULL)
			throw(MAL, "crackers.sortmerge", "Cannot access descriptor");
		if (BATmadvise(current->run, BUF_SEQUENTIAL, BUF_SEQUENTIAL, BUF_SEQUENTIAL, BUF_SEQUENTIAL) != 0)  
			throw(MAL, "crackers.sortmerge", "Madvice failed");
		nextBatch=bucketSize>(BATcount(current->run)-current->merged)?BATcount(current->run)-current->merged:bucketSize;
		current->slice=BATslice(current->run,current->merged+1,current->merged+1+nextBatch);		
		current->start=0;
		current->tuples=BATcount(current->slice);
		current->merged=current->tuples;
		QNodes[QNodesSize++]=current;
		current=current->next;
	}

{
	PQ_state pq;
	PQ_Index heapsize = QNodesSize;
	PQ_Key const range = 1<<26;
	size_t size = PQ_RequiredSpace (heapsize, 0);
	char * space = malloc (size);
	int resIndex;
	int deferred;
	oid *sh;
	@1 *st;
	oid mergeTuples;

	rh = (oid*)Hloc(br,BUNfirst(br));
	rt = (@1 *)Tloc(br,BUNfirst(br));

	/* We use the value "as is" as PQ_Key for PQ_push();
	 * PQ_Key is defined as unsigned int;
	 * hence, we can (for now) only allow <= 4 byte integer types, here.
	 *
	 * TODO:
	 * Either fix the implementation to indeed (correctly) support all types,
	 * or omit the PQMerge inplementation for all non-supported types.
	 */
#if SIZEOF_WRD == SIZEOF_INT
#define MAX_4_BYTE_INT_TYPE TYPE_wrd
#else
#if SIZEOF_OID == SIZEOF_INT
#define MAX_4_BYTE_INT_TYPE TYPE_oid
#else
#define MAX_4_BYTE_INT_TYPE TYPE_int
#endif
#endif
	if (TYPE_@1 <= TYPE_void || TYPE_@1 > MAX_4_BYTE_INT_TYPE)
		throw(MAL, "crackers.sortmerge", "Type not supported by PQMerge");

	PQ_PriorityQueue (& pq, "merge", space, size, heapsize, range, 0, 0, NULL, NULL);
	
	/*QNodes is an array of pointers to a simple struct 
	that contains info on the slices with qualifying values*/

	/*put all first values in the queue*/
	for(j=0;j<QNodesSize;j++){
		st=(@1  *)Tloc(QNodes[j]->slice,BUNfirst(QNodes[j]->slice)+QNodes[j]->start); 
		PQ_push (& pq, j, (PQ_Key)*st, 0, NULL);
	}

	/*pop the smallest and push the next one from the same slice*/
	mergeTuples=totalTuples-QNodesSize;
	for(i=0;i<mergeTuples;i++){
		resIndex = PQ_pop (& pq, & deferred, NULL);
		sh=(oid *)Hloc(QNodes[resIndex]->slice,BUNfirst(QNodes[resIndex]->slice)+QNodes[resIndex]->start);
		st=(@1  *)Tloc(QNodes[resIndex]->slice,BUNfirst(QNodes[resIndex]->slice)+QNodes[resIndex]->start);
		
		*rh=*sh;
		*rt=*st;
		rh++;rt++;
		QNodes[resIndex]->start++;
		QNodes[resIndex]->tuples--;
		
		if (QNodes[resIndex]->tuples>0){
			st++;	
			PQ_push (& pq, resIndex, (PQ_Key)*st, 0, NULL);
		}else {
			BBPunfix(QNodes[resIndex]->slice->batCacheid);
			if (QNodes[resIndex]->merged >= BATcount(QNodes[resIndex]->run)){ 
				i--;
				QNodesSize--;
				BBPunfix(QNodes[resIndex]->run->batCacheid);
			/*		BBPreleaseref(QNodes[resIndex]->run->batCacheid);*/
			}else{
				oid nextBatch=bucketSize>(BATcount(QNodes[resIndex]->run)-QNodes[resIndex]->merged)?BATcount(QNodes[resIndex]->run)-QNodes[resIndex]->merged:bucketSize;
				QNodes[resIndex]->slice=BATslice(QNodes[resIndex]->run,QNodes[resIndex]->merged+1,QNodes[resIndex]->merged+1+nextBatch);		
				QNodes[resIndex]->start=0;
				QNodes[resIndex]->tuples=nextBatch;	
				QNodes[resIndex]->merged+=nextBatch;

				st=(@1  *)Tloc(QNodes[resIndex]->slice,BUNfirst(QNodes[resIndex]->slice)+QNodes[resIndex]->start);
				PQ_push (& pq, resIndex, (PQ_Key)*st, 0, NULL);
			}		
		}	
	}

	/*pop all remaining values*/
	for(j=0;j<QNodesSize;j++){
		resIndex = PQ_pop (& pq, & deferred, NULL);
		sh=(oid *)Hloc(QNodes[resIndex]->slice,BUNfirst(QNodes[resIndex]->slice)+QNodes[resIndex]->start);
		st=(@1  *)Tloc(QNodes[resIndex]->slice,BUNfirst(QNodes[resIndex]->slice)+QNodes[resIndex]->start);
		
		*rh=*sh;
		*rt=*st;
		rh++;rt++;
		QNodes[resIndex]->start++;
		QNodes[resIndex]->tuples--;
		/*
		if (QNodes[resIndex]->tuples==0){
			BBPunfix(QNodes[resIndex]->slice->batCacheid);
			BBPunfix(QNodes[resIndex]->run->batCacheid);
			BBPreleaseref(QNodes[resIndex]->run->batCacheid);
		}
		*/
	}
}
@

@= NwayMerge
	if (!gotSlices){
		/* Take the slices */
		current=CrackerIndex[m].smNode;
		while(current!=NULL){
			BAT *slice=BATdescriptor(current->batId);
			if (BATmadvise(slice, BUF_SEQUENTIAL, BUF_SEQUENTIAL, BUF_SEQUENTIAL, BUF_SEQUENTIAL) != 0)  
				throw(MAL, "crackers.sortmerge", "Madvice failed");
			if (slice==NULL)
				throw(MAL, "crackers.sortmerge", "Cannot access slice");
			current->slice=slice;
			current=current->next;
		}
		gotSlices=TRUE;
	}
	current=CrackerIndex[m].smNode;
	totalTuples=totalLowerTuples=0;
	QNodesSize=0;
	while(current!=NULL){
		/* binary search to find the position of the lowest requested value in the current slice */
		l  = SORTfndfirst_@4(current->slice,@5);
		lt = (@1*)Tloc(current->slice,l);
		t0 = (@1*)Tloc(current->slice,BUNfirst(current->slice));
		lastValue = (@1*)Tloc(current->slice, BUNlast(current->slice));

		/* no qualifying values */
		if (lt == lastValue){
			current->tuples=0;
			totalLowerTuples+=BATcount(current->slice);
			current=current->next;
			continue;
		}

		if (@2_EQ(lt,@5,@3@1) && @7 == FALSE){
			while (lt < lastValue && @2_EQ(lt,@5,@3@1))
				lt ++;
		} 
				
		if (lt == lastValue){
			current->tuples=0;
			totalLowerTuples+=BATcount(current->slice);
			current=current->next;
			continue;
		}

		if ( @2_GT(lt,@6,@3@1) || (@2_EQ(lt,@6,@3@1) && @8==FALSE) ){
			current->tuples=0;
			totalLowerTuples+=(oid) (lt-t0);
			current=current->next;
			continue;
		}

		current->start= (oid) (lt-t0);	
	
		totalLowerTuples+=current->start;
		QNodes[QNodesSize++]=current;
		current=current->next;
	}

	/*N-way merge*/
	rh = (oid*)Hloc(br,BUNfirst(br)+totalLowerTuples);
	rt = (@1 *)Tloc(br,BUNfirst(br)+totalLowerTuples);
	if (*mode==2){
		tempTime=GDKusec();
		@:CopyMerge(@1,@2,@3,@4,@5,@6,@7,@8)@
		MergeTime+=GDKusec()-tempTime;
	}else
	if (*mode==3){
		lng tempTime1=GDKusec();
		@:PQMergeAM(@1,@2,@3,@4,@5,@6,@7,@8)@
		MergeTime+=GDKusec()-tempTime1;
	}
@

@= PQMergeAM
{
	PQ_state pq;
	PQ_Index heapsize = QNodesSize;
	PQ_Key const range = 1<<26;
	size_t size = PQ_RequiredSpace (heapsize, 0);
	char * space = malloc (size);
	int resIndex;
	int deferred;
	@1 *st;
	oid QNodesSizeTemp=QNodesSize;
	

	/* We use the value "as is" as PQ_Key for PQ_push();
	 * PQ_Key is defined as unsigned int;
	 * hence, we can (for now) only allow <= 4 byte integer types, here.
	 *
	 * TODO:
	 * Either fix the implementation to indeed (correctly) support all types,
	 * or omit the PQMerge inplementation for all non-supported types.
	 */
#if SIZEOF_WRD == SIZEOF_INT
#define MAX_4_BYTE_INT_TYPE TYPE_wrd
#else
#if SIZEOF_OID == SIZEOF_INT
#define MAX_4_BYTE_INT_TYPE TYPE_oid
#else
#define MAX_4_BYTE_INT_TYPE TYPE_int
#endif
#endif
	if (TYPE_@1 <= TYPE_void || TYPE_@1 > MAX_4_BYTE_INT_TYPE)
		throw(MAL, "crackers.sortmerge", "Type not supported by PQMerge");

	PQ_PriorityQueue (& pq, "merge", space, size, heapsize, range, 0, 0, NULL, NULL);
	
	/*QNodes is an array of pointers to a simple struct 
	that contains info on the slices with qualifying values*/

	/*put all first values in the queue*/
	for(j=0;j<QNodesSize;j++){
		st=(@1  *)Tloc(QNodes[j]->slice,BUNfirst(QNodes[j]->slice)+QNodes[j]->start); 
		PQ_push (& pq, j, (PQ_Key)*st, 0, NULL);
		QNodes[j]->tuples=QNodes[j]->start;
	}

	/*pop the smallest and push the next one from the same slice*/
	while(QNodesSizeTemp>0){
		resIndex = PQ_pop (& pq, & deferred, NULL);

		st=(@1  *)Tloc(QNodes[resIndex]->slice,BUNfirst(QNodes[resIndex]->slice)+QNodes[resIndex]->tuples);
		*rh=*(oid *)Hloc(QNodes[resIndex]->slice,BUNfirst(QNodes[resIndex]->slice)+QNodes[resIndex]->tuples);
		*rt=*st;

		rh++;rt++;

		QNodes[resIndex]->tuples++;
		
		st++;	
		lastValue = (@1*)Tloc(QNodes[resIndex]->slice, BUNlast(QNodes[resIndex]->slice));
		if(st < lastValue && (@2_LT(st,@6,@3@1) || (@2_EQ(st,@6,@3@1) && @8==TRUE))){
			PQ_push (& pq, resIndex, (PQ_Key)*st, 0, NULL);
		}
		else 
			QNodesSizeTemp--;
	}
	for(j=0;j<QNodesSize;j++){
		QNodes[j]->merged+=QNodes[j]->tuples-QNodes[j]->start;
		totalTuples+=QNodes[j]->tuples-QNodes[j]->start;
	}
	free(space);
}
@

@= PQMerge
{
	PQ_state pq;
	PQ_Index heapsize = QNodesSize;
	PQ_Key const range = 1<<26;
	size_t size = PQ_RequiredSpace (heapsize, 0);
	char * space = malloc (size);
	int resIndex;
	int deferred;
	oid *sh;
	@1 *st;
	oid mergeTuples;

	/* We use the value "as is" as PQ_Key for PQ_push();
	 * PQ_Key is defined as unsigned int;
	 * hence, we can (for now) only allow <= 4 byte integer types, here.
	 *
	 * TODO:
	 * Either fix the implementation to indeed (correctly) support all types,
	 * or omit the PQMerge inplementation for all non-supported types.
	 */
#if SIZEOF_WRD == SIZEOF_INT
#define MAX_4_BYTE_INT_TYPE TYPE_wrd
#else
#if SIZEOF_OID == SIZEOF_INT
#define MAX_4_BYTE_INT_TYPE TYPE_oid
#else
#define MAX_4_BYTE_INT_TYPE TYPE_int
#endif
#endif
	if (TYPE_@1 <= TYPE_void || TYPE_@1 > MAX_4_BYTE_INT_TYPE)
		throw(MAL, "crackers.sortmerge", "Type not supported by PQMerge");

	PQ_PriorityQueue (& pq, "merge", space, size, heapsize, range, 0, 0, NULL, NULL);
	
	/*QNodes is an array of pointers to a simple struct 
	that contains info on the slices with qualifying values*/

	/*put all first values in the queue*/
	for(j=0;j<QNodesSize;j++){
		st=(@1  *)Tloc(QNodes[j]->slice,BUNfirst(QNodes[j]->slice)+QNodes[j]->start); 
		PQ_push (& pq, j, (PQ_Key)*st, 0, NULL);
	}

	/*pop the smallest and push the next one from the same slice*/
	mergeTuples=totalTuples-QNodesSize;
	for(i=0;i<mergeTuples;i++){
		resIndex = PQ_pop (& pq, & deferred, NULL);
		sh=(oid *)Hloc(QNodes[resIndex]->slice,BUNfirst(QNodes[resIndex]->slice)+QNodes[resIndex]->start);
		st=(@1  *)Tloc(QNodes[resIndex]->slice,BUNfirst(QNodes[resIndex]->slice)+QNodes[resIndex]->start);
		
		*rh=*sh;
		*rt=*st;
		rh++;rt++;
		QNodes[resIndex]->start++;
		QNodes[resIndex]->tuples--;
		
		if (QNodes[resIndex]->tuples>0){
			st++;	
			PQ_push (& pq, resIndex, (PQ_Key)*st, 0, NULL);
		}else {
			i--;
			QNodesSize--;
		}	
	}

	/*pop all remaining values*/
	for(j=0;j<QNodesSize;j++){
		resIndex = PQ_pop (& pq, & deferred, NULL);
		sh=(oid *)Hloc(QNodes[resIndex]->slice,BUNfirst(QNodes[resIndex]->slice)+QNodes[resIndex]->start);
		st=(@1  *)Tloc(QNodes[resIndex]->slice,BUNfirst(QNodes[resIndex]->slice)+QNodes[resIndex]->start);
		
		*rh=*sh;
		*rt=*st;
		rh++;rt++;
		QNodes[resIndex]->start++;
		QNodes[resIndex]->tuples--;
	}
}
@

@= CopyMerge
	for(j=0;j<QNodesSize;j++){
		oid tup=0,k=0;
		current=QNodes[j];
		sh=(oid *)Hloc(current->slice,BUNfirst(current->slice)+current->start);
		st=(@1  *)Tloc(current->slice,BUNfirst(current->slice)+current->start); 
		lastValue = (@1*)Tloc(current->slice, BUNlast(current->slice));
		
		/*The first tuple from each run qualifies; no need to check*/
		*rt=*st;
		rt++;	
		st++;
		tup++;
		while(st < lastValue && (@2_LT(st,@6,@3@1) || (@2_EQ(st,@6,@3@1) && @8==TRUE))){
			*rt=*st;
			rt++;	
			st++;
			tup++;
		}
		for(;k<tup;k++){
			*rh=*sh;
			rh++;
			sh++;
		}
		current->merged +=tup;
		totalTuples+=tup;
	}
	br=BATmirror(br);
        GDKqsort(Hloc(br,BUNfirst(br)+totalLowerTuples), Tloc(br,BUNfirst(br)+totalLowerTuples), (br->H->vheap)?br->H->vheap->base:NULL, totalTuples, Hsize(br), Tsize(br), br->htype);
	br=BATmirror(br);

@

@= LoopMerge
	for(i=0;i<totalTuples;i++){
		merge=NULL;	
	
		current=@4;
		while(current!=NULL){
			if (current->tuples>0){
				tt=(@1 *)Tloc(current->slice,BUNfirst(current->slice)+current->start);			
				if (merge==NULL)
					merge=current;
				else{
					@1 *small=(@1 *)Tloc(merge->slice,BUNfirst(merge->slice)+merge->start);
					if (@2_LT(tt,small,@3@1))
						merge=current;
				}
			}
			current=current->next;
		}

		if (merge==NULL)
			throw(MAL,"crackers sort merge","Unexpected error while merging");

		*rh=*(oid *)Hloc(merge->slice,BUNfirst(merge->slice)+merge->start);
		*rt=*(@1  *)Tloc(merge->slice,BUNfirst(merge->slice)+merge->start);
		rh++;rt++;
		merge->start++;
		merge->tuples--;
	}
@

@= BinarySearchBounds
	/* binary search to find the position of the lowest requested value in the current slice */
	l  = SORTfndfirst_@4(slice,@5);
	lt = (@1*)Tloc(slice,l);
	t0 = (@1*)Tloc(slice,BUNfirst(slice));
	lastValue = (@1*)Tloc(slice, BUNlast(slice));
	notFound=FALSE;

	/* no qualifying values */
	if (lt == lastValue)
		notFound=TRUE;

	if (!notFound){
		if (@2_EQ(lt,@5,@3@1) && *@7 == FALSE){
			while (lt < lastValue && @2_EQ(lt,@5,@3@1))
				lt ++;
		} 
				
		if (lt == lastValue)
			notFound=TRUE;
	}

	if (!notFound){
		if ( @2_GT(lt,@6,@3@1) || (@2_EQ(lt,@6,@3@1) && @8==FALSE) )
			notFound=TRUE;
	}

	if (!notFound){
		start= (oid) (lt-t0);	
		
		/* binary search to find the position of the highest requested value */
		l = SORTfndfirst_@4(slice, @6);
		lt = (@1*)Tloc(slice,l);
		if (lt < lastValue){
			if (@2_EQ(lt,@6,@3@1) && *@8 == TRUE){	
				while (lt < lastValue && @2_EQ(lt,@6,@3@1))
					lt ++;
				lt--;
			} else
			if (@2_EQ(lt,@6,@3@1) && *@8 == FALSE)
				lt --;
			else
			if ( @2_GT(lt,@6,@3@1) )
				lt --;
		}

		if (lt == lastValue) lt--;
		end = ((oid) (lt-t0))+1+start;

		if (start>0){
			lowResultNode=addCrackerIndex_@1(m,low,*inclusiveLow,curPos+start,c);
			if (lowResultNode!=NULL){
				lowResultNode->sliceSize=curNode->sliceSize-start-1;
				lowResultNode->contiguousArea=0;
				curNode->sliceSize-=lowResultNode->sliceSize;
				curNode=lowResultNode; /*for next check to work*/
			}
		}
		if (end<nexPos){
			lowResultNode=addCrackerIndex_@1(m,low,*inclusiveLow,curPos+end,c);
			if (lowResultNode!=NULL){
				lowResultNode->sliceSize=curNode->sliceSize-(end-start)-1;
				lowResultNode->contiguousArea=0;
				curNode->sliceSize-=lowResultNode->sliceSize;
			}
		}
	}
	if (notFound)
		start=end=0;
@

@= BinarySearchHgh
	/* binary search to find the position of the lowest requested value in the current slice */
	t0 = (@1*)Tloc(slice,BUNfirst(slice));
	lastValue = (@1*)Tloc(slice, BUNlast(slice));
	notFound=FALSE;

	/* binary search to find the position of the highest requested value */
	l = SORTfndfirst_@4(slice, @5);
	lt = (@1*)Tloc(slice,l);
	if (lt < lastValue) {
		lt = (@1*)Tloc(slice,l);

		if (@2_EQ(lt,@5,@3@1) && *@6 == TRUE){	
			while (lt < lastValue && @2_EQ(lt,@5,@3@1))
				lt ++;
			lt--;
		} else
		if (@2_EQ(lt,@5,@3@1) && *@6 == FALSE)
			lt --;
		else
		if ( @2_GT(lt,@5,@3@1) )
			lt --;
		
		if (lt == lastValue) lt--;
		end = (oid) (lt-t0)+1;
		if (end<nexPos){
			hghResultNode=addCrackerIndex_@1(m,hgh,*inclusiveHgh,curPos+end,c);
			if (hghResultNode!=NULL){
				hghResultNode->sliceSize=curNode->sliceSize-end-1;
				hghResultNode->contiguousArea=0;
				curNode->sliceSize-=hghResultNode->sliceSize;
			}
		}
	}
	else
		end=0;
@

@= BinarySearchLow
	/* binary search to find the position of the lowest requested value in the current slice */
	l  = SORTfndfirst_@4(slice,@5);
	lt = (@1*)Tloc(slice,l);
	t0 = (@1*)Tloc(slice,BUNfirst(slice));
	lastValue = (@1*)Tloc(slice, BUNlast(slice));
	notFound=FALSE;

	/* no qualifying values */
	if (lt == lastValue)
		notFound=TRUE;

	if (!notFound){
		if (@2_EQ(lt,@5,@3@1) && *@6 == FALSE){
			while (lt < lastValue && @2_EQ(lt,@5,@3@1))
				lt ++;
		} 
				
		if (lt == lastValue)
			notFound=TRUE;
	}

	if (notFound)
		start=BATcount(slice);
	else{
		start= (oid) (lt-t0);	
		if (start>0){
			lowResultNode=addCrackerIndex_@1(m,low,*inclusiveLow,curPos+start,c);
			if (lowResultNode!=NULL){
				lowResultNode->sliceSize=curNode->sliceSize-start-1;
				lowResultNode->contiguousArea=0;
				curNode->sliceSize-=lowResultNode->sliceSize;
			}
		}
	}
@

@= FullMerge
	@:NwayMerge(@1,@2,@3,@4,low,hgh,*inclusiveLow,*inclusiveHgh)@

	vl=totalLowerTuples;
	vh=totalLowerTuples+totalTuples-1;
	totalmergedTuples+=totalTuples;
	if (vl>0) _vl=vl-1; else _vl=vl;		
	lowResultNode=addCrackerIndex_@1(m,low,*inclusiveLow,_vl,c);
	if (lowResultNode==NULL)
		if (curNode!=NULL)
			lowResultNode=curNode;
	if(lowResultNode!=NULL){
		lowResultNode->sliceSize=vh-_vl;
		lowResultNode->contiguousArea=0;
	}
	hghResultNode=addCrackerIndex_@1(m,hgh,HBound,vh,c);
	if (hghResultNode==NULL){
		if (nexNode!=NULL)
			hghResultNode=nexNode;
	}
	else{
		hghResultNode->sliceSize=0;
		hghResultNode->contiguousArea=0;
	}
	resStart=totalLowerTuples;
	resEnd=resStart+totalTuples;
@

@= MergeMid
	nexNodeInclusive=nexNode->inclusive?FALSE:TRUE;
	@:NwayMerge(@1,@2,@3,@4,curValue,nexValue,curNode->inclusive,nexNodeInclusive)@
	curNode->sliceSize=totalTuples;
	totalmergedTuples+=totalTuples;
@

@= MergeHgh
	@:NwayMerge(@1,@2,@3,@4,curValue,hgh,curNode->inclusive,*inclusiveHgh)@
	curNode->sliceSize=totalTuples;
	totalmergedTuples+=totalTuples;
	hghResultNode=addCrackerIndex_@1(m,hgh,HBound,curPos+totalTuples-1,c);
	if (hghResultNode==NULL){
		if (nexNode!=NULL)
			hghResultNode=nexNode;
	}
	else{
		hghResultNode->sliceSize=0;
		hghResultNode->contiguousArea=0;
	}
@

@= MergeLow1
	nexNodeInclusive=curNode->inclusive?FALSE:TRUE;
	@:NwayMerge(@1,@2,@3,@4,low,curValue,*inclusiveLow,nexNodeInclusive)@
	totalmergedTuples+=totalTuples;
	vl=totalLowerTuples-1;
	if (vl>0) _vl=vl-1; else _vl=vl;		
	lowResultNode=addCrackerIndex_@1(m,low,*inclusiveLow,vl,c);
	if (lowResultNode==NULL)
		if (curNode!=NULL)
			lowResultNode=curNode;
	if(lowResultNode!=NULL){
		lowResultNode->sliceSize=totalTuples;
		lowResultNode->contiguousArea=0;
		curNode=lowResultNode;/*need to initialize for nextpiece macro*/
	}
@
@= MergeLow2
	nexNodeInclusive=nexNode->inclusive?FALSE:TRUE;
	@:NwayMerge(@1,@2,@3,@4,low,nexValue,*inclusiveLow,nexNodeInclusive)@
	totalmergedTuples+=totalTuples;
	vl=totalLowerTuples-1;
	if (vl>0) _vl=vl-1; else _vl=vl;		
	lowResultNode=addCrackerIndex_@1(m,low,*inclusiveLow,vl,c);
	if(lowResultNode!=NULL){
		lowResultNode->sliceSize=totalTuples;
		lowResultNode->contiguousArea=0;
	}
@

@= NextPiece

	notFound=TRUE;
	/*jump over contiguous already merged pieces*/
	if (nodeHgh2!=NULL){
		if (curNode->contiguousArea >=(*(oid*)Hloc(c,base + nodeHgh2->position))){
			curNode=nodeLow2;
			nexNode=nodeHgh2;
			notFound=FALSE;
		}
	}

	if(notFound){
		curNode=nexNode;
		nexNode=nexNode->nextValue;
	}
	if(nexNode!=NULL){
		nexTuple = base + nexNode->position;
		nexValue = (@1 *)Tloc(c, nexTuple);
		nexPos   = *(oid*)Hloc(c, nexTuple);
	}
	curTuple = base + curNode->position;
	curValue = (@1 *)Tloc(c, curTuple);
	curPos   = *(oid*)Hloc(c, curTuple)+1;
@

@= printVarTypes
{
	str MyBuf = NULL;
	int MyBufLen = 0;
	(void)(*BATatoms[TYPE_@1].atomToStr) (&MyBuf, &MyBufLen, (ptr)(&@2));
	printf("%s @3 \n", MyBuf);
	GDKfree(MyBuf);
}
@

@= RangeSelectBody
	/*MODE: 1=Nway merge.2=copy+inplace sort.3=priority queue*/
	BAT *b,*bo,*br,*c,*view,*slice;
	int  m;
	oid sliceSize,i;
	struct sortMergeNode *current,*previous,*tmp;
	bit HBound;
	oid vl=0, vh=0,_vl=0;
	@1 *lt, *lastValue, *t0;
	BUN l;
	oid totalTuples,totalLowerTuples;
	@1  *rt;
	oid *rh;
	oid *sh;
	@1  *st;
	struct sortMergeNode *QNodes[1000000];
	int QNodesSize=0;
	struct Node *curNode=NULL,*nexNode=NULL,*lowResultNode=NULL,*hghResultNode=NULL;
	BUN curTuple,nexTuple,base;
	oid curPos,nexPos;
	bit notFound,nexNodeInclusive,gotSlices=FALSE;
	oid start,end, resStart,resEnd;
	@1 *curValue, *nexValue;
	oid totalmergedTuples=0;
	int j;
	
	lng MergeTime=0,tempTime, pqTime=0;

	int thgh;
	@1 *low,*hgh;

	low=GDKmalloc(sizeof(@1));
	hgh=GDKmalloc(sizeof(@1));
	*low=0;
	*hgh=0;

	if(*rounding){
		/*
		Rounding by ignoring the width of the query range
		int tlow;
		unsigned int i,j;
		j=(sizeof(@1) * 8 - 1);
		i = 1<<(sizeof(@1) * 8 - 1);
		while (i > 0) {
			if (*plow & i)
				break;
			i >>= 1;
			j--;
		}
		tlow = 1 << j;
		j=(sizeof(@1) * 8 - 1);
		i = 1<<(sizeof(@1) * 8 - 1);
		while (i > 0) {
			if (*phgh & i)
				break;
			i >>= 1;
			j--;
		}
		thgh = 1 << (j+1);
		*low=tlow;
		*hgh=thgh;
		printf("Rounding:\n");
		@:printVarTypes(@1,*plow,plow)@
		@:printVarTypes(@1,*low,low)@
		@:printVarTypes(@1,*phgh,phgh)@
		@:printVarTypes(@1,*hgh,hgh)@
		*/

		/*Round the range of the requested width*/
		unsigned int i,j;
		int width=*phgh-*plow;
		j=(sizeof(@1) * 8 - 1);
		i = 1<<(sizeof(@1) * 8 - 1);
		while (i > 0) {
			if (width & i)
				break;
			i >>= 1;
			j--;
		}
		thgh = 1 << (j+1);
		*low=*plow;
		*hgh=*low+thgh;
	}else{
		*low=*plow;
		*hgh=*phgh;
	}	

	if (@2_GT(low,hgh,@3@1))
		throw(MAL, "crackers.sortmerge", "illegal range");
	
	if (*inclusiveHgh == TRUE) HBound = FALSE;
	else	HBound = TRUE; 				

	m = existsCrackerIndex(*bid);

	/* if this is the first time we select something from this bat,
	   we have to create the replica column, slice it and sort the slices. 
           We also create the result column where the result values are merged */
	if (m == -1){
		oid endSlice,startSlice;
		lng timeSlice=0,timeCopy=0,timeHead=0,timeSort=0,t1;
		if ((bo = BATdescriptor(*bid)) == NULL)
			throw(MAL, "crackers.sortmerge", "Cannot access descriptor");

		br=BATnew(TYPE_oid, bo->ttype,BATcount(bo));
		br->hsorted = FALSE;
		br->tsorted = FALSE;
		br->hdense = FALSE;
		br->tdense = FALSE;
		BATkey(BATmirror(br),FALSE);
		br->batRestricted= BAT_READ;
		BATmode(br,PERSISTENT);
		BATsetcount(br,BATcount(bo));

		m = newCrackerIndex_@1(*bid,br->batCacheid);

		/*slicing*/
		/*This is assuming 4 byte ints + 8 byte oids per value and a cache of 4MB*/
		/*sliceSize=300000;*/
		sliceSize=(oid)*psliceSize;
		

		/*sort the slices*/
		current=NULL;
		startSlice=0;
		endSlice=sliceSize>BATcount(bo)?BATcount(bo):sliceSize;
		while (1){
			struct sortMergeNode *smNode;
			t1=GDKusec();
			slice=BATslice(bo, startSlice, endSlice);
			timeSlice+=GDKusec()-t1;
			t1=GDKusec();
			b = BATcopy(slice, bo->htype, bo->ttype, TRUE);
			timeCopy+=GDKusec()-t1;
			BBPunfix(slice->batCacheid);
			t1=GDKusec();
			if ( bo->htype == TYPE_void)
				b = BATmaterializeh(b);
			timeHead+=GDKusec()-t1;
			b->hsorted = FALSE;
			b->tsorted = FALSE;
			b->hdense = FALSE;
			b->tdense = FALSE;
			BATkey(BATmirror(b),FALSE);
			b->batRestricted= BAT_WRITE;
			t1=GDKusec();
			BATmirror(BATorder(BATmirror(b)));
			timeSort+=GDKusec()-t1;

			if (BATmmap(b, STORE_MMAP, STORE_MMAP, STORE_MMAP, STORE_MMAP, 0) != 0)
				throw(MAL, "crackers.sortmerge", "Cannot mmap BAT");
			smNode=(struct sortMergeNode *)GDKmalloc(sizeof(struct sortMergeNode));
			smNode->batId=b->batCacheid;
			smNode->next=NULL;
			smNode->merged=0;
			
			if (CrackerIndex[m].smNode==NULL){
				CrackerIndex[m].smNode=smNode;
				current=CrackerIndex[m].smNode;
			}
			else{	
				current->next = smNode;
				current=smNode;
			}
			
			BBPkeepref(b->batCacheid);

			if (endSlice==BATcount(bo))
				break;
			startSlice=endSlice;
			endSlice=endSlice+sliceSize>BATcount(bo)?BATcount(bo):endSlice+sliceSize;
		}
		
		BBPincref(br->batCacheid,TRUE);
		BBPunfix(bo->batCacheid);
		/* Take the tree of the result bat */
		if ((c = BATdescriptor(CrackerIndex[m].cid)) == NULL)
			throw(MAL, "crackers.sortmerge", "Cannot access tree");
		base      = BUNfirst(c);
		t1=GDKusec();
		@:FullMerge(@1,@2,@3,@4)@
		printf("\n Merging %lld \n",GDKusec()-t1);
		printf("\n Slicing %lld \n",timeSlice);
		printf("\n Copying %lld \n",timeCopy);
		printf("\n Headmake %lld \n",timeHead);
		printf("\n Ordering %lld \n",timeSort);
		goto done;
	}

	/* Take the tree of the result bat */
	if ((c = BATdescriptor(CrackerIndex[m].cid)) == NULL)
		throw(MAL, "crackers.sortmerge", "Cannot access tree");

	base      = BUNfirst(c);

	/* Take the result bat */
	if ((br = BATdescriptor(CrackerIndex[m].cbid)) == NULL)
		throw(MAL, "crackers.sortmerge", "Cannot access merge column");


	/*Empty merge column*/
	if (CrackerIndex[m].Tree==NULL){
		@:FullMerge(@1,@2,@3,@4)@
	}
	/*otherwise merge only the missing parts*/
	else{
		struct Node *nodeLow1=NULL,*nodeHgh1=NULL, *nodeLow2=NULL,*nodeHgh2=NULL;


		GetLowNodes_@1(*low, *inclusiveLow, CrackerIndex[m].Tree, c, BUNfirst(c), &nodeLow1, &nodeHgh1, NULL, NULL);
		GetHghNodes_@1(*hgh, *inclusiveHgh, CrackerIndex[m].Tree, c, BUNfirst(c), &nodeLow2, &nodeHgh2, NULL, NULL);

		/*If the range falls outside existing areas we need a full merge*/
		if ((nodeLow1==NULL && nodeLow2==NULL) || (nodeHgh1==NULL && nodeHgh2==NULL)){
			if (nodeLow1!=NULL) curNode=nodeLow1;
			if (nodeHgh2!=NULL) nexNode=nodeHgh2;
			@:FullMerge(@1,@2,@3,@4)@
			goto done;
		}


		/*Low is either outside or inside the existing area*/
		if (nodeLow1==NULL){
			curNode  = nodeHgh1;
			curTuple = base + curNode->position;
			curValue = (@1 *)Tloc(c, curTuple);
			curPos   = *(oid*)Hloc(c, curTuple)+1;
			@:MergeLow1(@1,@2,@3,@4)@
			resStart=totalLowerTuples;
			nexNode  = curNode->nextValue; 
			nexTuple = base + nexNode->position;
			nexValue = (@1 *)Tloc(c, nexTuple);
			nexPos   = *(oid*)Hloc(c, nexTuple);
		}else{
			curNode  = nodeLow1;
			curTuple = base + curNode->position;
			curValue = (@1 *)Tloc(c, curTuple);
			curPos   = *(oid*)Hloc(c, curTuple)+1;
			nexNode  = curNode->nextValue; 
			nexTuple = base + nexNode->position;
			nexValue = (@1 *)Tloc(c, nexTuple);
			nexPos   = *(oid*)Hloc(c, nexTuple);

			while((@2_EQ(nexValue,low,@3@1 ))||(@2_LT(nexValue,low,@3@1))){
				@:NextPiece(@1)@
			}

			/*Everything falls within one piece*/
			if ((@2_EQ(nexValue,hgh,@3@1) && *inclusiveHgh == FALSE)||(@2_GT(nexValue,hgh,@3@1))){
				/*Piece is merged. We only need to binary search this area*/
				if(curNode->sliceSize>0){
					slice=BATslice(br, curPos, nexPos+1);
					@:BinarySearchBounds(@1,@2,@3,@4,low,hgh,inclusiveLow,inclusiveHgh)@
					resStart=curPos+start;resEnd=curPos+end;
					lowResultNode=curNode;
					hghResultNode=nexNode;
					BBPunfix(slice->batCacheid);
				}else{
					@:FullMerge(@1,@2,@3,@4)@  /*TODO this might need to be a mergemid*/
				}
				goto done;
			}

			/*Otherwise only low bound is here*/
			if(curNode->sliceSize>0){
				if (@2_EQ(curValue,low,@3@1) && *inclusiveLow ==curNode->inclusive){
					resStart=curPos;
				}
				else{	
					slice=BATslice(br, curPos, nexPos+1);
					@:BinarySearchLow(@1,@2,@3,@4,low,inclusiveLow)@
					resStart=curPos+start;
					BBPunfix(slice->batCacheid);
				}
				lowResultNode=curNode;
			}else{
				@:MergeLow2(@1,@2,@3,@4)@ 
				resStart=totalLowerTuples;
				lowResultNode=curNode;
			}
		}
		@:NextPiece(@1)@
		/*Traverse remaining pieces to fill in missing areas*/
		while(nexNode!=NULL){
			if ((@2_EQ(nexValue,hgh,@3@1) && *inclusiveHgh == TRUE)||(@2_LT(nexValue,hgh,@3@1))){
				if(curNode->sliceSize==0){
					@:MergeMid(@1,@2,@3,@4)@
				}
			}else{
				/*This is the last one. High falls in this piece.*/
				if(curNode->sliceSize>0){
					/*exact hit*/
					if (@2_EQ(nexValue,hgh,@3@1))
						resEnd=curPos+curNode->sliceSize;
					else{
						slice=BATslice(br, curPos, nexPos+1);
						@:BinarySearchHgh(@1,@2,@3,@4,hgh,inclusiveHgh)@
						resEnd=curPos+end;
						BBPunfix(slice->batCacheid);
					}
					hghResultNode=nexNode;
				}else{
					@:MergeHgh(@1,@2,@3,@4)@
					resEnd=curPos+totalTuples;
				}
				goto done;
			}
			@:NextPiece(@1)@
		}
		
		/*Hgh falls into an empty area in the end*/
		@:MergeHgh(@1,@2,@3,@4)@
		resEnd=curPos+totalTuples;
	}

	done:;
	if (lowResultNode!=NULL && hghResultNode!=NULL){
		curPos=*(oid*)Hloc(c, base + hghResultNode->position);
		if (lowResultNode->contiguousArea < curPos)
			lowResultNode->contiguousArea = curPos;
	}else
		printf("\n Missed case! \n");

	printf("Merged "OIDFMT" tuples \n",totalmergedTuples);	
	if (*rounding){
		BAT *temp=BATslice(br,resStart, resEnd);
		temp->hsorted = FALSE;
		temp->tsorted = TRUE;
		BATkey(BATmirror(temp),FALSE);
		temp->batRestricted= BAT_READ;
		
		ALGuselectInclusive(vid,&temp->batCacheid,plow,phgh,inclusiveLow,inclusiveHgh);
		if ((view = BATdescriptor(*vid)) == NULL)
			throw(MAL, "crackers.sortmerge", "Cannot access merge column");
		BBPunfix(temp->batCacheid);
		printf("result size is " BUNFMT " with rounding \n", BATcount(view));
		BBPunfix(view->batCacheid);
	}else{
		view = BATslice(br,resStart, resEnd);
		printf("result size is " BUNFMT "\n", BATcount(view));
		*vid = view->batCacheid;
		BBPkeepref(*vid);
	}



	/*unfix all slices and drop those that have no more unmerged tuples*/
	i=0;
	if (gotSlices){
		current=CrackerIndex[m].smNode;
		previous=NULL;
		while(current!=NULL){
			if (current->merged==BATcount(current->slice)){
				BBPunfix(current->batId);
				BBPdecref(current->batId,TRUE);	
				tmp=current;
				current=current->next;
				if (previous==NULL)
					CrackerIndex[m].smNode=current;
				else
					previous->next=current;
				GDKfree(tmp);
			}else{
				/*throw away this slice and introduce a smaller ones that do not contain the merged tuples
					DOES NOT WORK CORRECTLY YET
				oid start=0,end=0;
				if (current->merged==0){
					BBPunfix(current->batId);
					current=current->next;
					i++;
					continue;
				}
				if (*mode==2){
					start=current->start;
					end=start+current->merged;
				}else
				if (*mode==3){
					end=current->start;
					start=current->start-current->merged;
				}
			
				if (start>0){
					BAT *b1,*b2;
					struct sortMergeNode *tempNode,*smNode;
					b1=BATslice(current->slice,0,start);
					b2=BATslice(current->slice,end,BATcount(current->slice));


					printf("\n\n remove slices details: "BUNFMT" "BUNFMT" "BUNFMT" "OIDFMT" "OIDFMT" \n",BATcount(current->slice),BATcount(b1),BATcount(b2),current->merged,BATcount(b1)+BATcount(b2)+current->merged);

					BBPunfix(current->batId);
					BBPdecref(current->batId,TRUE);	
					current->merged=0;
					current->batId=b1->batCacheid;

					smNode=(struct sortMergeNode *)GDKmalloc(sizeof(struct sortMergeNode));
					smNode->batId=b2->batCacheid;
					smNode->next=current->next;
					smNode->merged=0;

					tempNode=current->next;
					current->next=smNode;
					current=tempNode;
					BBPkeepref(b1->batCacheid);
					BBPkeepref(b2->batCacheid);
				}else{
					BAT *b1;
					b1=BATslice(current->slice,end,BATcount(current->slice));
					BBPunfix(current->batId);
					BBPdecref(current->batId,TRUE);	
					current->merged=0;
					current->batId=b1->batCacheid;
					BBPkeepref(b1->batCacheid);
				}


			*/
				BBPunfix(current->batId);
				current=current->next;
				i++;
			}
		}
	}

	printf("MergeTime %lld \n",MergeTime);
	printf("   pqTime %lld \n",pqTime);

	/*printf("Live slices are "OIDFMT" \n",i);*/
	BBPunfix(br->batCacheid);
	BBPunfix(c->batCacheid);
	return MAL_SUCCEED;
@

@= SortBody
	/*MODE  1=Nway merge.2=copy+inplace sort.3=priority queue.4=one step copy+sort*/
	BAT *b,*bo,*br;
	oid sliceSize,i;
	struct sortMergeNode *current,*merge,*head=NULL;
	@1  *rt,*tt;
	oid *rh;
	oid endSlice,startSlice;
	oid totalTuples;
	struct sortMergeNode *QNodes[1000000];
	int QNodesSize=0;
	int j;
	
	
	if ((bo = BATdescriptor(*bid)) == NULL)
		throw(MAL, "crackers.sortmerge", "Cannot access descriptor");

	br=BATnew(TYPE_oid, bo->ttype,BATcount(bo));
	BATsetcount(br,BATcount(bo));

	/*slicing*/
	/*This is assuming 4 byte ints + 8 byte oids per value and a cache of 4MB*/
	sliceSize=2730;

	/*sort the slices*/
	current=NULL;
	startSlice=0;
	endSlice=sliceSize>BATcount(bo)?BATcount(bo):sliceSize;

	/*for copy+inplace sort*/
	if (*mode==4){
		rh = (oid*)Hloc(br,BUNfirst(br));
		rt = (@1 *)Tloc(br,BUNfirst(br));
		while (1){
			BAT *slice=BATslice(bo, startSlice, endSlice);
			@1  *st=(@1*)Tloc(slice,BUNfirst(slice)); 
			oid curTuples=endSlice-startSlice;
			
			memcpy(rt,st,curTuples*sizeof(@1));
			rt+=curTuples;

			for(i=startSlice;i<endSlice;i++){
				*rh=i;
				rh++;
			}

			br=BATmirror(br);
			GDKqsort(Hloc(br,BUNfirst(br)+startSlice), Tloc(br,BUNfirst(br)+startSlice), (br->H->vheap)?br->H->vheap->base:NULL, endSlice-startSlice, Hsize(br), Tsize(br), br->htype);
			br=BATmirror(br);

			BBPunfix(slice->batCacheid);
			if (endSlice==BATcount(bo))
				break;
			startSlice=endSlice;
			endSlice=endSlice+sliceSize>BATcount(bo)?BATcount(bo):endSlice+sliceSize;
		}	
		br->hsorted = FALSE;
		br->tsorted = FALSE;
		br->hdense =  FALSE;
		br->tdense =  FALSE;
		BATmirror(BATorder(BATmirror(br)));
		br->batRestricted= BAT_READ;
		*vid = br->batCacheid;
		BBPkeepref(*vid);
		BBPunfix(bo->batCacheid);
		return MAL_SUCCEED;
	}

	while (1){
		struct sortMergeNode *smNode;
		BAT *slice=BATslice(bo, startSlice, endSlice);
		b = BATcopy(slice, bo->htype, bo->ttype, TRUE);
		if ( bo->htype == TYPE_void)
			b = BATmaterializeh(b);
		b->hsorted = FALSE;
		b->tsorted = FALSE;
		b->hdense = FALSE;
		b->tdense = FALSE;
		BATkey(BATmirror(b),FALSE);
		BATmode(b,PERSISTENT);
		b->batRestricted= BAT_WRITE;
		BATmirror(BATorder(BATmirror(b)));

		smNode=(struct sortMergeNode *)GDKmalloc(sizeof(struct sortMergeNode));
		smNode->batId=b->batCacheid;
		smNode->slice=b;
		smNode->next=NULL;
		
		if (head==NULL){
			head=smNode;
			current=head;
		}
		else{	
			current->next = smNode;
			current=smNode;
		}
		
		BBPunfix(slice->batCacheid);

		if (endSlice==BATcount(bo))
			break;
		startSlice=endSlice;
		endSlice=endSlice+sliceSize>BATcount(bo)?BATcount(bo):endSlice+sliceSize;
	}
	totalTuples=BATcount(br);
	
	@:NwayMergeSort(@1,@2,@3,@4)@

	br->hsorted = FALSE;
	br->tsorted = TRUE;
	br->hdense =  TRUE;
	br->tdense =  TRUE;
	BATkey(BATmirror(br),FALSE);
	BATmode(br,PERSISTENT);
	br->batRestricted= BAT_READ;
	*vid = br->batCacheid;
	BBPkeepref(*vid);

	/*unfix all slices*/
	current=head;
	while(current!=NULL){
		BBPunfix(current->slice->batCacheid);
		current=current->next;
	}
	BBPunfix(bo->batCacheid);
	return MAL_SUCCEED;
@

@= ExtSortBody
	BAT *b,*bo,*br;
	oid sliceSize,i;
	struct sortMergeNode *current,*head=NULL;
	@1  *rt;
	oid *rh;
	oid endSlice,startSlice;
	oid totalTuples;
	struct sortMergeNode *QNodes[1000000];
	int QNodesSize=0;
	int j;
	oid tupleSize,memoryForMerging,bucketSize;
	lng timeStart=GDKusec();
	
	
	if ((bo = BATdescriptor(*bid)) == NULL)
		throw(MAL, "crackers.sortmerge", "Cannot access descriptor");

	/*slicing*/
	sliceSize=*psliceSize;
	tupleSize=12;
	memoryForMerging=1024*1024*1024;
	bucketSize= ((memoryForMerging/tupleSize)) / (BATcount(bo)/sliceSize);
	bucketSize=bucketSize>sliceSize?sliceSize:bucketSize;
	printf("use buckets of "OIDFMT" tuples\n ",bucketSize);

	/*sort the slices*/
	current=NULL;
	startSlice=0;
	endSlice=sliceSize>BATcount(bo)?BATcount(bo):sliceSize;

	while (1){
		struct sortMergeNode *smNode;
		BAT *slice=BATslice(bo, startSlice, endSlice);
		b = BATcopy(slice, bo->htype, bo->ttype, TRUE);
		BBPunfix(slice->batCacheid);
		if ( bo->htype == TYPE_void)
			b = BATmaterializeh(b);
		b->hsorted = FALSE;
		b->tsorted = FALSE;
		b->hdense = FALSE;
		b->tdense = FALSE;
		BATkey(BATmirror(b),FALSE);
		b->batRestricted= BAT_WRITE;
		BATmirror(BATorder(BATmirror(b)));

		if (BATmmap(b, STORE_MMAP, STORE_MMAP, STORE_MMAP, STORE_MMAP, 0) != 0)
			throw(MAL, "crackers.sortmerge", "Cannot mmap BAT");

		smNode=(struct sortMergeNode *)GDKmalloc(sizeof(struct sortMergeNode));
		smNode->batId=b->batCacheid;
		smNode->next=NULL;
		smNode->merged=0;
		
		if (head==NULL){
			head=smNode;
			current=head;
		}
		else{	
			current->next = smNode;
			current=smNode;
		}
		
 	/*	if (BATmadvise(b, BUF_DONTNEED, BUF_DONTNEED, BUF_DONTNEED, BUF_DONTNEED) != 0)
			throw(MAL, "crackers.sortmerge", "Madvice failed");
	
		if ((b = BATsave(b)) == NULL) 
			throw(MAL, "crackers.sortmerge", "BATsave failed");
		BBPcold(b->batCacheid);*/
		/*BATmode(b,PERSISTENT);*/
		BBPkeepref(b->batCacheid);

		if (endSlice==BATcount(bo))
			break;
		startSlice=endSlice;
		endSlice=endSlice+sliceSize>BATcount(bo)?BATcount(bo):endSlice+sliceSize;
	}
	
	br=BATnew(TYPE_oid, bo->ttype,BATcount(bo));
	BATsetcount(br,BATcount(bo));
	totalTuples=BATcount(br);
	BBPunfix(bo->batCacheid);
	
	printf("sorting phase %lld \n",GDKusec()-timeStart);

	@:MergeExtSort(@1,@2,@3,@4)@

	br->hsorted = FALSE;
	br->tsorted = TRUE;
	br->hdense =  TRUE;
	br->tdense =  TRUE;
	BATkey(BATmirror(br),FALSE);
	BATmode(br,PERSISTENT);
	br->batRestricted= BAT_READ;
	*vid = br->batCacheid;
	BBPkeepref(*vid);

	return MAL_SUCCEED;
@


@= SortMergeOperations
static str
SelectSortMergeBounds_@1(int *vid, int *bid, @1 *plow, @1 *phgh, bit *inclusiveLow, bit *inclusiveHgh, int *mode, bit *rounding, int *psliceSize){	
	@:RangeSelectBody(@1,@2,@3,@4,)@
}

str
CRKPartitionedSort_@1(int *vid, int *bid, int *mode){	
	@:SortBody(@1,@2,@3,@4,)@
}

str
CRKExternalSort_@1(int *vid, int *bid, int *psliceSize){	
	@:ExtSortBody(@1,@2,@3,@4,)@
}
@

@}

