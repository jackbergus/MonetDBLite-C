@/
The contents of this file are subject to the MonetDB Public License
Version 1.1 (the "License"); you may not use this file except in
compliance with the License. You may obtain a copy of the License at
http://www.monetdb.org/Legal/MonetDBLicense

Software distributed under the License is distributed on an "AS IS"
basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations
under the License.

The Original Code is the MonetDB Database System.

The Initial Developer of the Original Code is CWI.
Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
Copyright August 2008-2011 MonetDB B.V.
All Rights Reserved.
@

@c
/*
 * @f crackers_validation
 * @a Martin Kersten, Stratos Idreos, Stefan Manegold
 * @d March 2006 - July 2007
 * @* Cracker Validation
 *
 *
 * @+ Interface
 *
 *
 * @- Type expansion
 */
@= TypeSwitch
@:@1(chr,simple,,@2)@
@:@1(sht,simple,,@2)@
@:@1(int,simple,,@2)@
@:@1(lng,simple,,@2)@
@:@1(flt,simple,,@2)@
@:@1(dbl,simple,,@2)@
@:@1(date,atom,TYPE_,@2)@
@
@h
/*
 * @- Header file
 */
#ifndef _CRACKERS_VALIDATION_H_
#define _CRACKERS_VALIDATION_H_

/* Exported signatures */
@:TypeSwitch(validate_operations_decl,Unordered)@
@:TypeSwitch(validate_operations_decl,Ordered)@
@:TypeSwitch(verifyIndex_decl,)@

#endif /* _CRACKERS_VALIDATION_H */
/*
 * @- Exported signatures
 */
@= validate_operations_decl
crackers_export str CRKcrack@4Zero_validate_@1 (bit *res, int *bid, @1 *_mid);
crackers_export str CRKcrack@4One_validate_@1 (int *res, int *bid, @1 *_mid);
crackers_export str CRKcrack@4Two_validate_@1 (bit *res, int *bid, @1 *_low, @1 *_hgh);
crackers_export str CRKcrack@4Three_validate_@1 (bit *res, int *bid, @1 *_low, @1 *_hgh);
@
@= verifyIndex_decl
crackers_export str CRKverifyCrackerIndex_@1(int *k, int *bid);
@
@c
/*
 * @+ Implementation
 *
 *
 * @- C file
 */
#include "monetdb_config.h"
#include "crackers.h"

/* Exported functions */
@:TypeSwitch(validate_operations_impl,Unordered)@
@:TypeSwitch(validate_operations_impl,Ordered)@
@:TypeSwitch(verifyIndex_impl,)@
/*
 * @- Exported functions
 */
@= validate_operations_impl
str
CRKcrack@4Zero_validate_@1 (bit *res, int *bid, @1 *_mid){
	@1 mid=*_mid;
	@:validate_init_1(@1,z)@

	@:validate_check_1(@1,1,<=,mid,@4)@
	@:validate_check_1(@1,2,> ,mid,@4)@

	@:validate_end(@1,z,\
		printf("|b|="BUNFMT" ; |tail<=%f|="BUNFMT", |tail>%f|="BUNFMT" !\n",\
		       count[0], (dbl)mid, count[1], (dbl)mid, count[2]);\
	)@
}

str
CRKcrack@4One_validate_@1 (int *res, int *bid, @1 *_mid){
	@1 mid=*_mid;
	@:validate_init_1(@1,)@

	@:validate_check_1(@1,1,< ,mid,@4)@
	@:validate_check_1(@1,2,==,mid,@4)@
	@:validate_check_1(@1,3,> ,mid,@4)@
	
	@:validate_end(@1,,\
		printf("|b|="BUNFMT" ; |tail<%f|="BUNFMT", |tail==%f|="BUNFMT", |tail>%f|="BUNFMT" !\n",\
		       count[0], (dbl)mid, count[1], (dbl)mid, count[2], (dbl)mid, count[3]);\
	)@
}

str
CRKcrack@4Two_validate_@1 (bit *res, int *bid, @1 *_low, @1 *_hgh){
	@1 low=*_low, hgh=*_hgh;
	@:validate_init_1(@1,)@
	@:validate_init_2(@1,)@

	@:validate_check_1(@1,1,< ,low,@4)@
	@:validate_check_1(@1,2,==,low,@4)@
	@:validate_check_2(@1,3,> ,low,< ,hgh,@4)@
	@:validate_check_1(@1,4,==,hgh,@4)@
	@:validate_check_1(@1,5,> ,hgh,@4)@

	@:validate_end(@1,,\
		printf("|b|="BUNFMT" ; |tail<%f|="BUNFMT", |tail==%f|="BUNFMT", |%f<tail<%f|="BUNFMT", |tail==%f|="BUNFMT", |tail>%f|="BUNFMT" !\n",\
		       count[0], (dbl)low, count[1], (dbl)low, count[2], (dbl)low, (dbl)hgh, count[3], (dbl)hgh, count[4], (dbl)hgh, count[5]);\
	)@
}

str
CRKcrack@4Three_validate_@1 (bit *res, int *bid, @1 *_low, @1 *_hgh){
	@1 low=*_low, hgh=*_hgh;
	@:validate_init_1(@1,z)@
	@:validate_init_2(@1,z)@

	@:validate_check_1(@1,1,<=,low,@4)@
	@:validate_check_1(@1,2,<=,hgh,@4)@
	@:validate_check_1(@1,3,> ,hgh,@4)@

	@:validate_end(@1,z,\
		printf("|b|="BUNFMT" ; |tail<=%f|="BUNFMT", |%f<tail<=%f|="BUNFMT", |tail>%f|="BUNFMT" !\n",\
		       count[0], (dbl)low, count[1], (dbl)low, (dbl)hgh, count[2], (dbl)hgh, count[3]);\
	)@
}
@
@= verifyIndex_impl
str
CRKverifyCrackerIndex_@1(int *k, int *bid){
        BAT *c, *b;
	int position = -1;
	BUN idxFirst, crkFirst, cur;
	@1 *crkt, *idxt, *crkLast, *bnd;
	oid *idxh;
	struct Node * hghIndexNode;
	bit prevIncl;
	@1 prevVal;
	int tuples=0, indexEntries=0;
	int i;

	(void) k;		

	for (i = 0; i < maxCrackMap; i++)
                if (CrackerIndex[i].bid == *bid){
                        position = i;
			break;	
		}

	if ((c = BATdescriptor(CrackerIndex[position].cid)) == NULL)
		throw(MAL, "crackers.mergeInsertions_@1", "Cannot access cracker index");
	if ((b = BATdescriptor(CrackerIndex[position].cbid)) == NULL){
		BBPunfix(c->batCacheid);
		throw(MAL, "crackers.mergeInsertions_@1", "Cannot access cracker BAT");
	}
	
	idxFirst = BUNfirst(c);
	crkFirst = BUNfirst(b);
	crkLast  = (@1*)Tloc(b, BUNlast(b));
	crkt     = (@1*)Tloc(b, BUNfirst(b));

	hghIndexNode = findNodeH_@1(*(@1*)crkt, TRUE, CrackerIndex[position].Tree, c, idxFirst, NULL);
	if (hghIndexNode == NULL){
		BBPunfix(c->batCacheid);
        	BBPunfix(b->batCacheid);
        	return MAL_SUCCEED;
	}

	indexEntries++;
	cur = idxFirst + hghIndexNode->position;
	idxh = (oid*)Hloc(c, cur);
	idxt = (@1 *)Tloc(c, cur);
	bnd  = (@1 *)Tloc(b, crkFirst + (*idxh - hghIndexNode->hols));

	if (crkt > bnd)
		printf("\n Error: cracker index and column are not aligned. Checked %d tuples and %d index entries \n reader pointer is beyond index...", tuples, indexEntries);
	while(crkt <= bnd){

		if (@2_LT(crkt,idxt,@3@1) ||(@2_EQ(crkt,idxt,@3@1) && hghIndexNode->inclusive == FALSE)){
			crkt++;
			tuples++;
		} else {
			printf("\n Error: cracker index and column are not aligned. Checked %d tuples and %d index entries \n", tuples, indexEntries);
			BBPunfix(c->batCacheid);
			BBPunfix(b->batCacheid);
			return MAL_SUCCEED;
		}
	}
	crkt+=hghIndexNode->hols;

	prevVal  = *idxt;
	prevIncl = hghIndexNode->inclusive;

	while (crkt < crkLast){
		if ((hghIndexNode = findNodeH_@1(*crkt, TRUE, CrackerIndex[position].Tree, c, idxFirst, NULL)) == NULL)
			break;
		indexEntries++;
		cur = idxFirst + hghIndexNode->position;
		idxh = (oid*)Hloc(c, cur);
		idxt = (@1 *)Tloc(c, cur);
		bnd  = (@1 *)Tloc(b, crkFirst + (*idxh - hghIndexNode->hols));

		if (crkt > bnd){
			printf("\n Error: cracker index and column are not aligned. Checked %d tuples and %d index entries \n reader pointer is beyond index...", tuples, indexEntries);
				BBPunfix(c->batCacheid);
				BBPunfix(b->batCacheid);
				return MAL_SUCCEED;
		}
		while(crkt <= bnd){

			if ( (@2_LT(crkt,idxt,@3@1) ||(@2_EQ(crkt,idxt,@3@1) && hghIndexNode->inclusive == FALSE)) &&
			     (@2_GT(crkt,&prevVal,@3@1) ||(@2_EQ(crkt,&prevVal,@3@1) && prevIncl == TRUE)) ){
				crkt++;
				tuples++;
			} else {
			printf("\n Error: cracker index and column are not aligned. Checked %d tuples and %d index entries \n", tuples, indexEntries);
				BBPunfix(c->batCacheid);
				BBPunfix(b->batCacheid);
				return MAL_SUCCEED;
			}
		}
		crkt+=hghIndexNode->hols;
		prevVal  = *idxt;
		prevIncl = hghIndexNode->inclusive;
	}
	
	if (hghIndexNode == NULL){
		while(crkt < crkLast){
                        if (@2_GT(crkt,&prevVal,@3@1) ||(@2_EQ(crkt,&prevVal,@3@1) && prevIncl == TRUE)){
                                crkt++;
				tuples++;
			} else {
			printf("\n Error: cracker index and column are not aligned. Checked %d tuples and %d index entries \n", tuples, indexEntries);
                                BBPunfix(c->batCacheid);
                                BBPunfix(b->batCacheid);
                                return MAL_SUCCEED;
                        }
		}
	}
	
	BBPunfix(c->batCacheid);
        BBPunfix(b->batCacheid);
	return MAL_SUCCEED;
}
@
 * @- Local support functions and macros
@= validate_init_1
	BAT *b,*c,*w;
	BUN fst_bn, lst_bn, bn;
	BUN count[6] = {0,0,0,0,0,0};

	/* initialization */
	*res = FALSE;
	if ((b = BATdescriptor(*bid)) == NULL) 
		throw(MAL, "crackers.@2crack_validate", "Cannot access descriptor");

	fst_bn = BUNfirst(b);
	lst_bn = BUNlast(b);
	bn = fst_bn;
@
@= validate_init_2
	if (low > hgh) {
		BBPunfix(b->batCacheid);
		throw(MAL, "crackers.@2crack_validate", "illegal range");
	}
@
@= validate_checkUnordered
        while (bn < lst_bn @2 @3 ) {
                bn ++;
                count[@1]++;
        }
@
@= validate_checkOrdered
{	oid hd = 0;
	while (bn < lst_bn && hd <= *(oid*)Hloc(b, bn) @2 @3 ) {
		hd = *(oid*)Hloc(b, bn);
		bn ++;
		count[@1]++;
	}	
}
@
@= validate_check_1
	@:validate_check@5(@2, && *(@1*)Tloc(b, bn) @3 @4 )@
@
@= validate_check_2
	@:validate_check@7(@2, && *(@1*)Tloc(b, bn) @3 @4 , && *(@1*)Tloc(b, bn) @5 @6 )@
@
@= validate_end
	count[0] = BATcount(b);
	if (bn < lst_bn) {
		@3;
		c = BATslice(b, fst_bn, bn); 
		w = BATslice(b, bn, lst_bn);
		printf("correct:\n");
		BATprint(c);
		printf("wrong:\n");
		BATprint(w);
		BBPunfix(w->batCacheid);
		BBPunfix(c->batCacheid);
		BBPunfix(b->batCacheid);
		throw(MAL, "crackers.@2crack_validate", "Invalid crack");
	}
	assert(bn == lst_bn);
	assert(count[0] == count[1] + count[2] + count[3] + count[4] + count[5]);
	BBPunfix(b->batCacheid);
	*res = TRUE;
	return MAL_SUCCEED;
@
