@/
The contents of this file are subject to the MonetDB Public License
Version 1.1 (the "License"); you may not use this file except in
compliance with the License. You may obtain a copy of the License at
http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html

Software distributed under the License is distributed on an "AS IS"
basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations
under the License.

The Original Code is the MonetDB Database System.

The Initial Developer of the Original Code is CWI.
Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
Copyright August 2008-2011 MonetDB B.V.
All Rights Reserved.
@

@f crackers_core_unordered
@a Martin Kersten, Stratos Idreos, Stefan Manegold
@d March 2006 - July 2007
@* Core Cracking (unordered)


@+ Interface
 

@- Type expansion

@= TypeSwitch
@:@1(chr,simple,,@2)@
@:@1(sht,simple,,@2)@
@:@1(int,simple,,@2)@
@:@1(lng,simple,,@2)@
@:@1(flt,simple,,@2)@
@:@1(dbl,simple,,@2)@
@:@1(date,atom,TYPE_,@2)@
@

@= TypeSwitch_2
@:@1(int,,simple,,int,@2)@
@:@1(dbl,,simple,,dbl,@2)@
@:@1(date,,atom,TYPE_,loc,@2)@
@

@= TypeSwitch_4
/* TODO: add the rest of the type combinations once code is stable */
@:@1(int,lng,simple,,,@2)@
@:@1(int,int,simple,,,@2)@
@:@1(int,date,simple,,,@2)@
@:@1(int,oid,simple,,,@2)@
@:@1(dbl,date,simple,,,@2)@
@:@1(dbl,int,simple,,,@2)@
@:@1(dbl,dbl,simple,,,@2)@

@:@1(date,int,atom,TYPE_,,@2)@
@:@1(date,lng,atom,TYPE_,,@2)@
@:@1(date,dbl,atom,TYPE_,,@2)@
@:@1(date,date,atom,TYPE_,,@2)@
@

@= TypeSwitch_5
/* TODO: add the rest of the type combinations once code is stable */
@:@1(int,int,simple,,,@2)@
@:@1(int,date,simple,,,@2)@
@:@1(int,oid,simple,,,@2)@
@:@1(dbl,date,simple,,,@2)@
@:@1(dbl,int,simple,,,@2)@
@:@1(dbl,dbl,simple,,,@2)@
@

@- Header file

@h
#ifndef _CRACKERS_CORE_UNORDERED_H_
#define _CRACKERS_CORE_UNORDERED_H_

#ifdef LIBCRACKERS
/* Signatures shared within the crackers module/library */
@:TypeSwitch(operations,_decl)@
@:TypeSwitch_4(operationsSideways,_decl)@
@:TypeSwitch_5(operationsSidewaysSample,_decl)@
@:TypeSwitch_2(operationsSideways_str,_decl)@
#endif

/* Exported signatures */
@:TypeSwitch(CoreUnorderedFunctions_decl,)@

#endif /* _CRACKERS_CORE_UNORDERED_H */
@


@- Exported signatures

@= CoreUnorderedFunctions_decl
crackers_export str CRKcrackUnorderedZero_@1 (int *res, int *bid, @1 *mid);
crackers_export str CRKcrackUnorderedThree_@1 (int *res, int *bid, @1 *low, @1 *hgh);
@


@- Signatures shared within the crackers module/library

@= operations
@:crackInTwoUnorderedPieces@4(@1,LE,LE,GT,@2,@3)@
@:crackInTwoUnorderedPieces@4(@1,RE,LT,GE,@2,@3)@
@:crackInThreeUnorderedPieces@4(@1,LO,RE,LE,GT,LE,GT,@2,@3)@
@:crackInThreeUnorderedPieces@4(@1,LE,RE,LT,GE,LE,GT,@2,@3)@
@:crackInThreeUnorderedPieces@4(@1,LO,RO,LE,GT,LT,GE,@2,@3)@
@:crackInThreeUnorderedPieces@4(@1,LE,RO,LT,GE,LT,GE,@2,@3)@
@

@= crackInTwoUnorderedPieces_decl
str CRKcrackUnorderedZero_@2_@1( BAT *b, @1 mval, oid first, oid last, oid *pos);
str CRKcrackUnorderedZero2_@2_@1( BAT *b, @1 mval, oid first, oid last, oid *pos, int indexPosition, BAT * index);
@

@= crackInThreeUnorderedPieces_decl
str CRKcrackUnorderedThree_@2_@3_@1( BAT *b, @1 low, @1 hgh, oid first, oid last, oid *posl, oid *posh);
str CRKcrackUnorderedThree2_@2_@3_@1( BAT *b, @1 low, @1 hgh, oid first, oid last, oid *posl, oid *posh);
str CRKcrackUnorderedThreeCopy_@2_@3_@1( BAT *b, @1 low, @1 hgh, oid first, oid last, oid *posl, oid *posh, BAT *bc);
str CRKcrackUnorderedThreeHybrid_@2_@3_@1( BAT *slice, @1 low, @1 hgh, oid *posl, oid *posh, BAT *partition, BAT *result, oid resoffset);
@

@= operationsSideways
@:crackInTwoUnorderedPiecesSideways@6(@1,@2,LE,LE,GT,@3,@4)@
@:crackInTwoUnorderedPiecesSideways@6(@1,@2,RE,LT,GE,@3,@4)@
@:crackInThreeUnorderedPiecesSideways@6(@1,@2,LO,RE,LE,GT,LE,GT,@3,@4)@
@:crackInThreeUnorderedPiecesSideways@6(@1,@2,LE,RE,LT,GE,LE,GT,@3,@4)@
@:crackInThreeUnorderedPiecesSideways@6(@1,@2,LO,RO,LE,GT,LT,GE,@3,@4)@
@:crackInThreeUnorderedPiecesSideways@6(@1,@2,LE,RO,LT,GE,LT,GE,@3,@4)@
@

@= operationsSidewaysSample
@:crackInTwoUnorderedPiecesSidewaysSample@6(@1,@2,LE,LE,GT,@3,@4)@
@:crackInTwoUnorderedPiecesSidewaysSample@6(@1,@2,RE,LT,GE,@3,@4)@
@

@= operationsSideways_str
@:crackInTwoUnorderedPiecesSideways_str@6(@1,,LE,LE,GT,@3,@4)@
@:crackInTwoUnorderedPiecesSideways_str@6(@1,,RE,LT,GE,@3,@4)@
@:crackInThreeUnorderedPiecesSideways_str@6(@1,,LO,RE,LE,GT,LE,GT,@3,@4)@
@:crackInThreeUnorderedPiecesSideways_str@6(@1,,LE,RE,LT,GE,LE,GT,@3,@4)@
@:crackInThreeUnorderedPiecesSideways_str@6(@1,,LO,RO,LE,GT,LT,GE,@3,@4)@
@:crackInThreeUnorderedPiecesSideways_str@6(@1,,LE,RO,LT,GE,LT,GE,@3,@4)@
@

@= crackInTwoUnorderedPiecesSideways_decl
str CRKcrackUnorderedZeroSideways_@3_@1_@2( BAT *b, @1 mval, oid first, oid last, oid *pos);
@

@= crackInTwoUnorderedPiecesSidewaysSample_decl
str CRKcrackUnorderedZeroSidewaysSample_@3_@1_@2( BAT *b, @1 *mid, oid first, oid last, oid *pos, lng *pieceSize, bit sample);
@

@= crackInTwoUnorderedPiecesSideways_str_decl
str CRKcrackUnorderedZeroSideways_@3_@1_str( BAT *b, @1 mval, oid first, oid last, oid *pos);
@

@= crackInThreeUnorderedPiecesSideways_decl
str CRKcrackUnorderedThreeSideways_@3_@4_@1_@2( BAT *b, @1 low, @1 hgh, oid first, oid last, oid *posl, oid *posh);
@

@= crackInThreeUnorderedPiecesSideways_str_decl
str CRKcrackUnorderedThreeSideways_@3_@4_@1_str( BAT *b, @1 low, @1 hgh, oid first, oid last, oid *posl, oid *posh);
@

@{
@+ Implementation


@- C file

@c
#include "monetdb_config.h"
#include "crackers.h"

/* Functions shared within the crackers module/library */
@:TypeSwitch(operations,_impl)@
@:TypeSwitch_4(operationsSideways,_impl)@
@:TypeSwitch_5(operationsSidewaysSample,_impl)@
@:TypeSwitch_2(operationsSideways_str,_impl)@

/* Exported functions */
@:TypeSwitch(CoreUnorderedFunctions_impl,)@
@


@- Exported functions

@= CoreUnorderedFunctions_impl
str
CRKcrackUnorderedZero_@1 (int *res, int *bid, @1 *mid){
        BAT *b;
        str msg;
	oid pos;

        if ((b = BATdescriptor(*bid)) == NULL)
                throw(MAL, "crackers.crack_zeroUnordered", "Cannot access descriptor");

        /* set bounds for the iterator */
       /* if( sizeof(struct SCRATCH{ oid hdummy; @1 tdummy; } ) != BUNsize(b) )
                throw(MAL, "crackers.crack_zeroUnordered", "Need more clever mapping ");
	*/
        msg = CRKcrackUnorderedZero_LE_@1( b, *mid,(BUN) 0, BATcount(b)-1, &pos);

        BBPkeepref(b->batCacheid);
        *res = *bid;
        return msg;
}

str
CRKcrackUnorderedThree_@1 (int *res, int *bid, @1 *low, @1 *hgh){
        BAT *b;
        str msg;
	oid posl, posh;

        if (*(@1 *) low > *(@1 *) hgh)
                throw(MAL, "crackers.crack_threeUnordered", "illegal range");
        if ((b = BATdescriptor(*bid)) == NULL)
                throw(MAL, "crackers.crack_threeUnordered", "Cannot access descriptor");

        /* set bounds for the iterator */
        /*if( sizeof(struct SCRATCH{ oid hdummy; @1 tdummy; } ) != BUNsize(b) )
                throw(MAL, "crackers.crack_threeUnordered", "Need more clever mapping ");
	*/
        msg = CRKcrackUnorderedThree_LO_RE_@1( b, *low, *hgh, 0, BATcount(b)-1,&posl, &posh);

        BBPkeepref(b->batCacheid);
        *res = *bid;
        return msg;
}
@


@- Functions shared within the crackers module/library

@= crackInTwoUnorderedPieces_impl
str
CRKcrackUnorderedZero_@2_@1( BAT *b, @1 mval, BUN first, BUN last, oid *pos){
        @1  *ft, *lt, *t0;
	oid *fh, *lh;
        oid hdummy;
        @1 tdummy;
	

        /* set bounds for the iterator */
        t0 = (@1 *)Tloc(b, BUNfirst(b));
        ft = (@1 *)Tloc(b, BUNfirst(b) + first);
        lt = (@1 *)Tloc(b, BUNfirst(b) + last);
        fh = (oid*)Hloc(b, BUNfirst(b) + first);
        lh = (oid*)Hloc(b, BUNfirst(b) + last);

        while(ft<lt) {
                if (@5_@3(ft, &mval,@6@1)){
                        ft++; fh++;
		}
                else {
                        while( @5_@4(lt, &mval,@6@1) && lt>ft){
                                lt--; lh--;
			}
                        @:shuffle(@1,ft,lt,fh,lh)@
                        lt--;lh--;
                        ft++;fh++;
                }
        }

	if (lt == ft) {
		if (@5_@4(lt, &mval,@6@1)){
			if (lt==t0) 
				*pos = (oid) BUNfirst(b);
			else	
				*pos = (oid) (lt - t0) - 1; /*works for empty left piece also*/
		}
		else{
			*pos = (oid) (lt - t0); 
			if (*pos==last) /*empty right piece*/
				*pos = *pos + 1;
		}
	}
	else{
		if (lt > t0)
			*pos = (oid) (lt - t0);
		else
			*pos = (oid) BUNfirst(b);
	}		
		
        return MAL_SUCCEED;
}

str
CRKcrackUnorderedZero2_@2_@1( BAT *b, @1 mval, BUN first, BUN last, oid *pos, int indexPosition, BAT *index){
        @1  *ft, *lt, *t0, *sample, *leftBoundt, *rightBoundt;
	oid *fh, *lh, *leftBoundh, *rightBoundh;
        oid hdummy;
        @1 tdummy;

	oid sizeBAT, sizePiece;
	@1 mid;

	sizeBAT   = BATcount(b);
	sizePiece = last - first;

	/* if the to be processed tuples are not a significant part of 
		the BAT the perform a simple crack */
	if (sizePiece < sizeBAT/10)
		return CRKcrackUnorderedZero_@2_@1( b, mval, first, last, pos);

	printf("\n perform organic crack \n");

        /* set bounds for the iterator */
        t0 = (@1 *)Tloc(b, BUNfirst(b));
        leftBoundt  = ft = (@1 *)Tloc(b, BUNfirst(b) + first);
        rightBoundt = lt = (@1 *)Tloc(b, BUNfirst(b) + last);
        leftBoundh  = fh = (oid*)Hloc(b, BUNfirst(b) + first);
        rightBoundh = lh = (oid*)Hloc(b, BUNfirst(b) + last);

	sample = ft + 10;
	mid=*ft;ft++;
	for (;ft<sample;ft++)
		mid+=*ft;
	mid = mid/10;
        ft = (@1 *)Tloc(b, BUNfirst(b) + first);
		
        while(ft<lt) {
		if (@5_@3(ft, &mval,@6@1)){
			if (*ft < mid){
				leftBoundt++;
				leftBoundh++;
				if (ft>leftBoundt){ 
					@:shuffle(@1,ft,leftBoundt,fh,leftBoundh)@
				}
			} 

			ft++; fh++;
		}
                else {
                        while( @5_@4(lt, &mval,@6@1) && lt>ft){
				if (*lt >= mid){
					rightBoundt--;
					rightBoundh--;
					if (lt<rightBoundt){ 
						@:shuffle(@1,lt,rightBoundt,lh,rightBoundh)@
					}
				} 

                                lt--; lh--;
			}
                        @:shuffle(@1,ft,lt,fh,lh)@

			if (*ft < mid){
				leftBoundt++;
				leftBoundh++;
				if (ft>leftBoundt){ 
					@:shuffle(@1,ft,leftBoundt,fh,leftBoundh)@
				}
			} 
			if (*lt >= mid){
				rightBoundt--;
				rightBoundh--;
				if (lt<rightBoundt){ 
					@:shuffle(@1,lt,rightBoundt,lh,rightBoundh)@
				}
			} 

                        lt--;lh--;
                        ft++;fh++;
                }
        }


	if (ft > leftBoundt){
		addCrackerIndex_@1(indexPosition, &mid,  TRUE, (oid) (leftBoundt-t0), index);
	}
	if (lt < rightBoundt){
		addCrackerIndex_@1(indexPosition, &mid, TRUE,  (oid) (rightBoundt-t0)-1, index);
	}
	if (lt == ft) {
		if (@5_@4(lt, &mval,@6@1)){
			if (lt==t0) 
				*pos = (oid) BUNfirst(b);
			else	
				*pos = (oid) (lt - t0) - 1; /*works for empty left piece also*/
		}
		else{
			*pos = (oid) (lt - t0); 
			if (*pos==last) /*empty right piece*/
				*pos = *pos + 1;
		}
	}
	else{
		if (lt > t0)
			*pos = (oid) (lt - t0);
		else
			*pos = (oid) BUNfirst(b);
	}		
	
        return MAL_SUCCEED;
}
@

@= crackInThreeUnorderedPieces_impl
str
CRKcrackUnorderedThree_@2_@3_@1( BAT *b, @1 low, @1 hgh, oid first, oid last, oid *posl, oid *posh){
        @1  *ft, *lt, *tmax, *t0;
	oid *fh, *lh, *hmax;
        oid hdummy;
        @1 tdummy;
	BUN firstBUN;

        /* set bounds for the iterator */
	firstBUN = BUNfirst(b);
        t0   = (@1*)Tloc(b, firstBUN);
        ft   = (@1*)Tloc(b, firstBUN + first);
        tmax = (@1 *)Tloc(b, firstBUN + last);
        fh   = (oid*)Hloc(b, firstBUN + first);
        hmax = (oid*)Hloc(b, firstBUN + last);
        while( @8_@7(tmax, &hgh,@9@1) && tmax>ft){
                tmax--;hmax--;
	}

	if (tmax == ft){
		if (@8_@7(tmax, &hgh,@9@1)){ /*left and middle are empty*/
			*posl =  1;
			*posh = -1;
		}
		else if (@8_@5(tmax, &low,@9@1))  /*result is one bun*/
			*posl = *posh = (oid) (tmax-t0);
		else{
			*posl = (oid) (tmax-t0) - 1; 
			*posh = (oid) (tmax-t0); 
		}
		return MAL_SUCCEED;
	}

        lt = tmax;lh=hmax;
        while( @8_@5(lt, &low,@9@1) && lt>ft){
                /* move all high values into their final place */
                if( @8_@7(lt, &hgh,@9@1)){
                        @:shuffle(@1,lt,tmax,lh,hmax)@
                        tmax--;hmax--;
                }
                lt--;lh--;
        }
	if (lt == ft){/*left piece is empty*/
		if (@8_@7(lt, &hgh,@9@1)){
			@:shuffle(@1,lt,tmax,lh,hmax)@
			*posl = (oid) (lt-t0);
		}
		else if (@8_@5(lt, &low,@9@1))
			*posl = (oid) (lt-t0);
		else
			*posl = (oid) (lt-t0) + 1;
		*posh = (oid) (tmax-t0);
		return MAL_SUCCEED;
	}
        /* lt point to the first <=low, all values >hg are beyond tmax */

        /* perform Zero crack first */
        while(ft<=lt) {
                if (@8_@4(ft, &low,@9@1)){
                        ft++;fh++;
		}
                else {
                        @:shuffle(@1,ft,lt,fh,lh)@
                        while( @8_@5(lt, &low,@9@1) && lt>ft){
                                if(@8_@7(lt, &hgh,@9@1) ){
                                        @:shuffle(@1,lt,tmax,lh,hmax)@
                                        tmax--;hmax--;
                                }
                                lt--;lh--;
                        }
                }
        }
	if (ft ==  (@1*)Tloc(b, firstBUN +last+1)){ /*right and middle are empty*/
		*posl = -1;
		*posh = -1;
		return MAL_SUCCEED;
	}	
	if (tmax == lt){ /*then middle piece is empty*/
		*posl = (oid) (lt - t0) + 1;
		*posh = (oid) (tmax - t0);
		return MAL_SUCCEED;
	}
	*posl = (oid) (ft - t0);
	*posh = (oid) (tmax - t0);

	return MAL_SUCCEED;
}

str
CRKcrackUnorderedThree2_@2_@3_@1( BAT *b, @1 low, @1 hgh, oid first, oid last, oid *posl, oid *posh){
        @1  *ft, *lt, *tmax, *t0;
	oid *fh, *lh, *hmax;
        oid hdummy;
        @1 tdummy;
	BUN firstBUN;

        /* set bounds for the iterator */
	firstBUN = BUNfirst(b);
        t0   = (@1*)Tloc(b, firstBUN);
        ft   = (@1*)Tloc(b, firstBUN + first);
        tmax = (@1 *)Tloc(b, firstBUN + last);
        fh   = (oid*)Hloc(b, firstBUN + first);
        hmax = (oid*)Hloc(b, firstBUN + last);
        while( @8_@7(tmax, &hgh,@9@1) && tmax>ft){
                tmax--;hmax--;
	}

	if (tmax == ft){
		if (@8_@7(tmax, &hgh,@9@1)){ /*left and middle are empty*/
			*posl =  1;
			*posh = -1;
		}
		else if (@8_@5(tmax, &low,@9@1))  /*result is one bun*/
			*posl = *posh = (oid) (tmax-t0);
		else{
			*posl = (oid) (tmax-t0) - 1; 
			*posh = (oid) (tmax-t0); 
		}
		return MAL_SUCCEED;
	}

        lt = tmax;lh=hmax;
        while( @8_@5(lt, &low,@9@1) && lt>ft){
                /* move all high values into their final place */
                if( @8_@7(lt, &hgh,@9@1)){
                        @:shuffle(@1,lt,tmax,lh,hmax)@
                        tmax--;hmax--;
                }
                lt--;lh--;
        }
	if (lt == ft){/*left piece is empty*/
		if (@8_@7(lt, &hgh,@9@1)){
			@:shuffle(@1,lt,tmax,lh,hmax)@
			*posl = (oid) (lt-t0);
		}
		else if (@8_@5(lt, &low,@9@1))
			*posl = (oid) (lt-t0);
		else
			*posl = (oid) (lt-t0) + 1;
		*posh = (oid) (tmax-t0);
		return MAL_SUCCEED;
	}
        /* lt point to the first <=low, all values >hg are beyond tmax */

        /* perform Zero crack first */
        while(ft<=lt) {
                if (@8_@4(ft, &low,@9@1)){
                        ft++;fh++;
		}
                else {
                        @:shuffle(@1,ft,lt,fh,lh)@
                        while( @8_@5(lt, &low,@9@1) && lt>ft){
                                if(@8_@7(lt, &hgh,@9@1) ){
                                        @:shuffle(@1,lt,tmax,lh,hmax)@
                                        tmax--;hmax--;
                                }
                                lt--;lh--;
                        }
                }
        }
	if (ft ==  (@1*)Tloc(b, firstBUN +last+1)){ /*right and middle are empty*/
		*posl = -1;
		*posh = -1;
		return MAL_SUCCEED;
	}	
	if (tmax == lt){ /*then middle piece is empty*/
		*posl = (oid) (lt - t0) + 1;
		*posh = (oid) (tmax - t0);
		return MAL_SUCCEED;
	}
	*posl = (oid) (ft - t0);
	*posh = (oid) (tmax - t0);

	return MAL_SUCCEED;
}

str
CRKcrackUnorderedThreeCopy_@2_@3_@1( BAT *b, @1 low, @1 hgh, oid first, oid last, oid *posl, oid *posh, BAT *bc){

        @1  *ft, *lt, *tmax, *t0;
	oid fh, lh, hmax; /*hold actual  oid values in this version*/
	BUN firstBUN;

        @1  *ft2, *lt2, *tmax2; 
	oid *fh2, *lh2, *hmax2;
	BUN firstBUN2;

        oid hdummy;
        @1 tdummy;
	

        /* set bounds for the iterator */
	firstBUN = BUNfirst(b);
        t0   = (@1*)Tloc(b, firstBUN);
        ft   = (@1*)Tloc(b, firstBUN + first);
        tmax = (@1 *)Tloc(b, firstBUN + last);
        fh   = first;
        hmax = last;

	firstBUN2 = BUNfirst(bc);
        ft2   = (@1*)Tloc(bc, firstBUN2 + first);
        tmax2 = (@1 *)Tloc(bc, firstBUN2 + last);
        fh2   = (oid*)Hloc(bc, firstBUN2 + first);
        hmax2 = (oid*)Hloc(bc, firstBUN2 + last);
	
        while( @8_@7(tmax, &hgh,@9@1) && tmax>ft){
		*tmax2=*tmax;
		*hmax2=hmax;
                tmax--;hmax--;
                tmax2--;hmax2--;
	}

	if (tmax == ft){
		if (@8_@7(tmax, &hgh,@9@1)){ /*left and middle are empty*/
			*posl =  1;
			*posh = -1;
		}
		else if (@8_@5(tmax, &low,@9@1))  /*result is one bun*/
			*posl = *posh = (oid) (tmax-t0);
		else{
			*posl = (oid) (tmax-t0) - 1; 
			*posh = (oid) (tmax-t0); 
		}
		return MAL_SUCCEED;
	}

        lt  = tmax;  lh  = hmax;
        lt2 = tmax2; lh2 = hmax2;
        while( @8_@5(lt, &low,@9@1) && lt>ft){
                /* move all high values into their final place */
                if( @8_@7(lt, &hgh,@9@1)){
                        @:shuffle2(@1,lt,tmax,lh,hmax,lt2,tmax2,lh2,hmax2)@
                        tmax--;hmax--;
                        tmax2--;hmax2--;
                }else{
			*lt2=*lt;
			*lh2=lh;
		}	
                lt--; lh--;
                lt2--;lh2--;
        }
	if (lt == ft){/*left piece is empty*/
		if (@8_@7(lt, &hgh,@9@1)){
			@:shuffle2(@1,lt,tmax,lh,hmax,lt2,tmax2,lh2,hmax2)@
			*posl = (oid) (lt-t0);
		}
		else if (@8_@5(lt, &low,@9@1))
			*posl = (oid) (lt-t0);
		else
			*posl = (oid) (lt-t0) + 1;
		*posh = (oid) (tmax-t0);
		return MAL_SUCCEED;
	}
        /* lt point to the first <=low, all values >hg are beyond tmax */

        /* perform Zero crack first */
	*ft2=*ft;
	*fh2=fh;
        while(ft<=lt) {
                if (@8_@4(ft2, &low,@9@1)){
                        ft++; fh++;
                        ft2++;fh2++;
			if(ft<=lt){
				*ft2=*ft;
				*fh2=fh;
			}
		}
                else {
			*lt2=*ft2;
			*lh2=*fh2;
			*ft2=*lt;
			*fh2=lh;
                        if(@8_@5(lt2, &low,@9@1) && lt>ft){
                                if(@8_@7(lt2, &hgh,@9@1) ){
					@:shuffle(@1,lt2,tmax2,lh2,hmax2)@
                                        tmax--; hmax--;
                                        tmax2--;hmax2--;
                                }
                                lt--; lh--;
                                lt2--;lh2--;
                        }
                        while( @8_@5(lt, &low,@9@1) && lt>ft){
                                if(@8_@7(lt, &hgh,@9@1) ){
					*lt2=*tmax2;
					*lh2=*hmax2;
					*tmax2=*lt;
					*hmax2=lh;
                                        tmax--; hmax--;
                                        tmax2--;hmax2--;
                                }else{
					*lt2=*lt;
					*lh2=lh;
				}
                                lt--; lh--;
                                lt2--;lh2--;
                        }
                }
        }
	if (ft ==  (@1*)Tloc(bc, firstBUN +last+1)){ /*right and middle are empty*/
		*posl = -1;
		*posh = -1;
		return MAL_SUCCEED;
	}	
	if (tmax == lt){ /*then middle piece is empty*/
		*posl = (oid) (lt - t0) + 1;
		*posh = (oid) (tmax - t0);
		return MAL_SUCCEED;
	}
	*posl = (oid) (ft - t0);
	*posh = (oid) (tmax - t0);

	return MAL_SUCCEED;
}

str
CRKcrackUnorderedThreeHybrid_@2_@3_@1( BAT *slice, @1 low, @1 hgh, oid *posl, oid *posh, BAT *partition, BAT *result, oid resoffset){

        @1  *ft, *tmax, *t0;
	oid fh; 
	BUN firstBUN;

        @1  *ft2, *tmax2; 
	oid *fh2, *hmax2;
	BUN firstBUN2;
	@1 *last;

	@1 *rest=(@1 *)Tloc(result,BUNfirst(result)+resoffset);	
	oid *resh=(oid*)Hloc(result,BUNfirst(result)+resoffset);	

        /* set bounds for the iterator */
	firstBUN = BUNfirst(slice);
        ft   = (@1*)Tloc(slice, firstBUN);
        tmax = (@1 *)Tloc(slice, firstBUN + BATcount(slice)-1);
        fh   = (oid)0;
	last = tmax+1;

	firstBUN2 = BUNfirst(partition);
        t0    = (@1 *)Tloc(partition, firstBUN2);
        ft2   = (@1 *)Tloc(partition, firstBUN2);
        tmax2 = (@1 *)Tloc(partition, firstBUN2 + BATcount(partition)-1);
        fh2   = (oid*)Hloc(partition, firstBUN2);
        hmax2 = (oid*)Hloc(partition, firstBUN2 + BATcount(partition)-1);
	
	while (ft<last){
		if (@8_@7(ft, &hgh,@9@1)){
			*(@1*)tmax2=*(@1*)ft;
	                *(oid*)hmax2=(oid)fh;
			tmax2--;hmax2--;
		}else 
		if (@8_@5(ft, &low,@9@1)){
			*(@1*)rest=*(@1*)ft;
	                *(oid*)resh=(oid)fh;
			rest++;resh++;
		}else{
			*(@1*)ft2=*(@1*)ft;
	                *(oid*)fh2=(oid)fh;
			ft2++;fh2++;
		}
	
		ft++;
		fh++;
	}

	if (ft2>t0) ft2--;
	*posl = (oid) (ft2 - t0);
	*posh = (oid) (tmax2 - t0);

	return MAL_SUCCEED;
}
@


@- Local support functions and macros

@= shuffle
        tdummy = *@2;
        *@2 = *@3;
        *@3 = tdummy;

        hdummy = *@4;
        *@4 = *@5;
        *@5 = hdummy;
@

@= shuffle2
        *@7 = *@2;
        *@6 = *@3;

        *@9 = @4;
        *@8 = @5;
@

@= shuffleSideways
	hdummy = *(@1*) @3;
	*(@1*) @3= *(@1*) @4;
        *(@1*) @4= hdummy;

	tdummy= *(@2*) @5;
        *(@2*) @5= *(@2*) @6;
        *(@2*) @6 = (@2)tdummy;
@= shuffleSidewaysStr
	hdummy = *(@1*) @2;
	*(@1*) @2= *(@1*) @3;
        *(@1*) @3= hdummy;

	switch (b->T->width) {
	case 1:
		tdummy= (var_t)*(unsigned char*) @4;
		*(unsigned char*) @4= *(unsigned char*) @5;
		*(unsigned char*) @5 = (unsigned char)tdummy;
		break;
	case 2:
		tdummy= (var_t)*(unsigned short*) @4;
		*(unsigned short*) @4= *(unsigned short*) @5;
		*(unsigned short*) @5 = (unsigned short)tdummy;
		break;
#if SIZEOF_VAR_T == 8
	case 4:
		tdummy= (var_t)*(unsigned int*) @4;
		*(unsigned int*) @4= *(unsigned int*) @5;
		*(unsigned int*) @5 = (unsigned int)tdummy;
		break;
#endif
	default:
		tdummy= *(var_t*) @4;
		*(var_t*) @4= *(var_t*) @5;
		*(var_t*) @5 = tdummy;
		break;
	}
@

@= printVarTypes
{
/* @1: the type; e.g., chr bte sht int oid wrd flt dbl lng str */
	str MyBuf = NULL;
	int MyBufLen = 0;
	(void)(*BATatoms[TYPE_@1].atomToStr) (&MyBuf, &MyBufLen, (ptr)(&@2));
	printf("%s \n", MyBuf);
	GDKfree(MyBuf);
}
@

@= crackInTwoUnorderedPiecesSideways_impl
str
CRKcrackUnorderedZeroSideways_@3_@1_@2( BAT *b, @1 mval, BUN first, BUN last, oid *pos){
        @1 *vm, *vl, *h0;
        @2 *vmt, *vlt;
        @1 hdummy;
        @2 tdummy;
	BUN firstBUN;
        /* set bounds for the iterator */

	firstBUN = BUNfirst(b);
        h0  = (@1*)Hloc(b, firstBUN);
        vm  = (@1*)Hloc(b, firstBUN+first);
        vl  = (@1*)Hloc(b, firstBUN+last );
        vmt = (@2*)Tloc(b, firstBUN+first);
        vlt = (@2*)Tloc(b, firstBUN+last );

        while(vm<vl) {
                if (@6_@4(vm, &mval,@7@1)){
                        vm  ++; 
			vmt ++;
		}
                else {
                        while( @6_@5(vl, &mval,@7@1) && vl>vm){
                                vl  --; 
				vlt --;
			}
                        @:shuffleSideways(@1,@2,vm,vl,vmt,vlt)@
                        vl  --;
			vlt --;
                        vm  ++;
			vmt ++;
                }
        }

	if (vl == vm) {
		if (@6_@5(vl, &mval,@7@1))
			*pos = (oid) (vl - h0) - 1; /*works for empty left piece also*/
		else{
			*pos = (oid) (vl - h0);
			if (*pos==last) /*empty right piece*/
				*pos = *pos+(oid)1;
		}
	}
	else
		*pos = (oid) (vl - h0);
		
        return MAL_SUCCEED;
}
@

@= crackInTwoUnorderedPiecesSidewaysSample_impl

str
CRKcrackUnorderedZeroSidewaysSample_@3_@1_@2( BAT *b, @1 *mid, BUN first, BUN last, oid *pos, lng *pieceSize, bit sample){
        @1 *vm, *vl, *h0;
        @2 *vmt, *vlt;
        @1 hdummy;
        @2 tdummy;
	BUN firstBUN;

	int sampleSize;		
	@1 mval;
	@1 mval1;
	@1 *stopSampling;

        /* set bounds for the iterator */
	firstBUN = BUNfirst(b);
        h0  = (@1*)Hloc(b, firstBUN);
        vm  = (@1*)Hloc(b, firstBUN+first);
        vl  = (@1*)Hloc(b, firstBUN+last );
        vmt = (@2*)Tloc(b, firstBUN+first);
        vlt = (@2*)Tloc(b, firstBUN+last );

	(void)pieceSize;
	/*Sample*/
	if (sample){
		sampleSize = 100;

		stopSampling = vm + sampleSize;
		mval1 = *vm;
		vm++;
		for(;vm < stopSampling;vm++){
			mval1 += *vm;
		}

		stopSampling = vl - sampleSize;
		for(;vl > stopSampling;vl--){
			mval1 += *vl;
		}

		*mid = mval1/((@1)(sampleSize*2));

		vm  = (@1*)Hloc(b, firstBUN+first);
		vl  = (@1*)Hloc(b, firstBUN+last );
	}
	
	mval=*mid;
        while(vm<vl) {
                if (@6_@4(vm, &mval,@7@1)){
                        vm  ++; 
			vmt ++;
		}
                else {
                        while( @6_@5(vl, &mval,@7@1) && vl>vm){
                                vl  --; 
				vlt --;
			}
                        @:shuffleSideways(@1,@2,vm,vl,vmt,vlt)@
                        vl  --;
			vlt --;
                        vm  ++;
			vmt ++;
                }
        }

	if (vl == vm) {
		if (@6_@5(vl, &mval,@7@1))
			*pos = (oid) (vl - h0) - 1; /*works for empty left piece also*/
		else{
			*pos = (oid) (vl - h0);
			if (*pos==last) /*empty right piece*/
				*pos = *pos+(oid)1;
		}
	}
	else
		*pos = (oid) (vl - h0);
		
        return MAL_SUCCEED;
}
@

@= crackInThreeUnorderedPiecesSideways_impl
str
CRKcrackUnorderedThreeSideways_@3_@4_@1_@2( BAT *b, @1 low, @1 hgh, BUN first, BUN last, oid *posl, oid *posh){
        @1 *vm, *vl, *hmax, *h0;
        @2 *vmt, *vlt, *hmaxt;
        @1 hdummy;
        @2 tdummy;
	BUN firstBUN;

        /* set bounds for the iterator */
	firstBUN = BUNfirst(b);
        h0    = (@1*)Hloc(b, firstBUN);

        vm    = (@1*)Hloc(b, firstBUN+first);
        hmax  = (@1*)Hloc(b, firstBUN+last);
        vmt   = (@2*)Tloc(b, firstBUN+first);
        hmaxt = (@2*)Tloc(b, firstBUN+last);
        while( @9_@8(hmax, &hgh,@[10]@1) && hmax>vm){
                hmax--; hmaxt--;
	}

	if (hmax == vm){
		if (@9_@8(hmax, &hgh,@[10]@1)){ /*left and middle are empty*/
			*posl =  1;
			*posh =  0;/*-1;*/
		}
		else if (@9_@6(hmax, &low,@[10]@1))  /*result is one bun*/
			*posl = *posh = (oid) (hmax - h0);
		else{
			*posl = (oid) (hmax - h0) + (oid)1;
			*posh = (oid) (hmax - h0);
		}
		return MAL_SUCCEED;
	}

        vl = hmax; vlt = hmaxt;
        while( @9_@6(vl, &low,@[10]@1) && vl>vm){
                /* move all high values into their final place */
                if( @9_@8(vl, &hgh,@[10]@1)){
                        @:shuffleSideways(@1,@2,vl,hmax,vlt,hmaxt)@
                        hmax--;hmaxt--;
                }
                vl--; vlt--;
        }
	if (vl == vm){ /* Left piece is empty */
		if (@9_@8(vl, &hgh,@[10]@1)){
			@:shuffleSideways(@1,@2,vl,hmax,vlt,hmaxt)@
                        hmax--;hmaxt--;
			*posl = (oid) (vl - h0);
		}
		else if (@9_@6(vl, &low,@[10]@1))
			*posl = (oid) (vl - h0);
		else
			*posl = (oid) (vl - h0) + (oid)1;
		*posh = (oid) (hmax - h0);
		return MAL_SUCCEED;
	}
        /* vl point to the first <=low, all values >hg are beyond hmax */

        /* perform Zero crack first */
        while(vm<=vl) {
                if (@9_@5(vm, &low,@[10]@1)){
                        vm ++; vmt ++;
                } else {
                        @:shuffleSideways(@1,@2,vm,vl,vmt,vlt)@
                        while( @9_@6(vl, &low,@[10]@1) && vl>vm){
                                if(@9_@8(vl, &hgh,@[10]@1) ){
                                        @:shuffleSideways(@1,@2,vl,hmax,vlt,hmaxt)@
                                        hmax--; hmaxt--;
                                }
                                vl --; vlt --;
                        }
                }
        }
	if (vm == (@1*)Hloc(b,firstBUN+last+1)){ /* Right and middle are empty */
		*posl = (oid)-1;
		*posh = (oid)-1;
		return MAL_SUCCEED;
	}	
	if (hmax == vl){ /* Middle piece is empty */
		*posl = (oid) (vl - h0)  + (oid)1;
		*posh = (oid) (hmax - h0);
		return MAL_SUCCEED;
	}
	*posl = (oid) (vm - h0);
	*posh = (oid) (hmax - h0);

	return MAL_SUCCEED;
}
@


@= crackInTwoUnorderedPiecesSideways_str_impl
str
CRKcrackUnorderedZeroSideways_@3_@1_str( BAT *b, @1 mval, BUN first, BUN last, oid *pos){
        @1 *vm, *vl, *h0;
        char *vmt, *vlt;
        @1 hdummy;
        var_t tdummy;
	BUN firstBUN;
        /* set bounds for the iterator */

	firstBUN = BUNfirst(b);
        h0  = (@1*)Hloc(b, firstBUN);
        vm  = (@1*)Hloc(b, firstBUN+first);
        vl  = (@1*)Hloc(b, firstBUN+last );
        vmt = (char*)Tloc(b, firstBUN+first);
        vlt = (char*)Tloc(b, firstBUN+last );

        while(vm<vl) {
                if (@6_@4(vm, &mval,@7@1)){
                        vm  ++; 
			vmt += b->T->width;
		}
                else {
                        while( @6_@5(vl, &mval,@7@1) && vl>vm){
                                vl  --; 
				vlt -= b->T->width;
			}
                        @:shuffleSidewaysStr(@1,vm,vl,vmt,vlt)@
                        vl  --;
			vlt -= b->T->width;
                        vm  ++;
			vmt += b->T->width;
                }
        }

	if (vl == vm) {
		if (@6_@5(vl, &mval,@7@1))
			*pos = (oid) (vl - h0) - 1; /*works for empty left piece also*/
		else{
			*pos = (oid) (vl - h0);
			if (*pos==last) /*empty right piece*/
				*pos = *pos+(oid)1;
		}
	}
	else
		*pos = (oid) (vl - h0);
		
        return MAL_SUCCEED;
}
@

@= crackInThreeUnorderedPiecesSideways_str_impl
str
CRKcrackUnorderedThreeSideways_@3_@4_@1_str( BAT *b, @1 low, @1 hgh, BUN first, BUN last, oid *posl, oid *posh){
        @1 *vm, *vl, *hmax, *h0;
        char *vmt, *vlt, *hmaxt;
        @1 hdummy;
        var_t tdummy;
	BUN firstBUN;

        /* set bounds for the iterator */
	firstBUN = BUNfirst(b);
        h0    = (@1*)Hloc(b, firstBUN);

        vm    = (@1*)Hloc(b, firstBUN+first);
        hmax  = (@1*)Hloc(b, firstBUN+last);
        vmt   = (char*)Tloc(b, firstBUN+first);
        hmaxt = (char*)Tloc(b, firstBUN+last);
        while( @9_@8(hmax, &hgh,@[10]@1) && hmax>vm){
                hmax--; hmaxt-=b->T->width;
	}

	if (hmax == vm){
		if (@9_@8(hmax, &hgh,@[10]@1)){ /*left and middle are empty*/
			*posl =  1;
			*posh =  0;/*-1;*/
		}
		else if (@9_@6(hmax, &low,@[10]@1))  /*result is one bun*/
			*posl = *posh = (oid) (hmax - h0);
		else{
			*posl = (oid) (hmax - h0) + (oid)1;
			*posh = (oid) (hmax - h0);
		}
		return MAL_SUCCEED;
	}

        vl = hmax; vlt = hmaxt;
        while( @9_@6(vl, &low,@[10]@1) && vl>vm){
                /* move all high values into their final place */
                if( @9_@8(vl, &hgh,@[10]@1)){
                        @:shuffleSidewaysStr(@1,vl,hmax,vlt,hmaxt)@
                        hmax--;hmaxt-=b->T->width;
                }
                vl--; vlt-=b->T->width;
        }
	if (vl == vm){ /* Left piece is empty */
		if (@9_@8(vl, &hgh,@[10]@1)){
			@:shuffleSidewaysStr(@1,vl,hmax,vlt,hmaxt)@
			*posl = (oid) (vl - h0);
		}
		else if (@9_@6(vl, &low,@[10]@1))
			*posl = (oid) (vl - h0);
		else
			*posl = (oid) (vl - h0) + (oid)1;
		*posh = (oid) (hmax - h0);
		return MAL_SUCCEED;
	}
        /* vl point to the first <=low, all values >hg are beyond hmax */

        /* perform Zero crack first */
        while(vm<=vl) {
                if (@9_@5(vm, &low,@[10]@1)){
                        vm ++; vmt += b->T->width;
                } else {
                        @:shuffleSidewaysStr(@1,vm,vl,vmt,vlt)@
                        while( @9_@6(vl, &low,@[10]@1) && vl>vm){
                                if(@9_@8(vl, &hgh,@[10]@1) ){
                                        @:shuffleSidewaysStr(@1,vl,hmax,vlt,hmaxt)@
                                        hmax--; hmaxt-=b->T->width;
                                }
                                vl --; vlt -= b->T->width;
                        }
                }
        }
	if (vm == (@1*)Hloc(b,firstBUN+last+1)){ /* Right and middle are empty */
		*posl = 0;/*-1;*/
		*posh = 0;/*-1;*/
		return MAL_SUCCEED;
	}	
	if (hmax == vl){ /* Middle piece is empty */
		*posl = (oid) (vl - h0)  + (oid)1;
		*posh = (oid) (hmax - h0);
		return MAL_SUCCEED;
	}
	*posl = (oid) (vm - h0);
	*posh = (oid) (hmax - h0);

	return MAL_SUCCEED;
}
@

@}
