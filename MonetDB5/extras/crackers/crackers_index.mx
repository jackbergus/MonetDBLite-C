@/
The contents of this file are subject to the MonetDB Public License
Version 1.1 (the "License"); you may not use this file except in
compliance with the License. You may obtain a copy of the License at
http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html

Software distributed under the License is distributed on an "AS IS"
basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations
under the License.

The Original Code is the MonetDB Database System.

The Initial Developer of the Original Code is CWI.
Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
Copyright August 2008-2011 MonetDB B.V.
All Rights Reserved.
@

@f crackers_index
@a Martin Kersten, Stratos Idreos, Stefan Manegold
@d March 2006 - July 2007
@* Cracker index


@+ Interface
 

@- Type expansion

@= TypeSwitch
@:@1(chr,simple,)@
@:@1(sht,simple,)@
@:@1(int,simple,)@
@:@1(lng,simple,)@
@:@1(flt,simple,)@
@:@1(dbl,simple,)@
@:@1(date,atom,TYPE_)@
@


@- Header file

@h
#ifndef _CRACKERS_INDEX_H_
#define _CRACKERS_INDEX_H_

#ifdef LIBCRACKERS
/* Type definitions shared within the crackers module/library */

/* used to keep track of the bats that use a given map set within a query
   With this information we can improve the alignment procedure of incremental sideways cracking
   by avoiding alignment operations not necessary for the current query 
   All bats required for the current query are kept in these nodes as a list in the CrackerIndexNode of the cracker bat
  of the head of the used map set */

struct referencesNodeFM{
	int 		batId;
	int 		tailBatId;
	struct referencesNodeFM *next;
};

struct referencesNode{
	int 		batId;
	oid 		cursor;
	struct referencesNode *next;
};
typedef struct referencesNode refNode; 

struct sortMergeNode{
	int 		batId; /*id of the slice*/
	int		index; /*position on the index */
	struct sortMergeNode *next;

	/*Temp variables*/
	BAT		*run;   /*full run*/
	BAT		*slice;/*the slice*/
	BAT		*tree; /*the slice*/
	oid		tuples;/*qualifying tuples*/
	oid		start;/*first qualifying tuple*/
	oid		merged;
};


/* This node is used for the AVL trees built withing the core cracking algorithms 
   It is  a more lightweight one than struct Node */
struct NodeSimple{
        struct NodeSimple  	*left;
        struct NodeSimple  	*right;
        int	      		height;
	bit	      		deleted; 
	struct NodeSimple  	*previous;
	bit 	      		isPreviousSmaller;	
	bit	      		head;

        oid	      		position;		/* The position in the BAT of the current value */

};

struct Node{
	/* Tree related */
        struct Node  	*left;
        struct Node  	*right;
        int	      	height;
	bit	      	head;

	/* Information stored at this node */
        oid	      	position;		/* The position in the BAT of the index where the bounds are stored */
	bit 	      	inclusive;	  
	bit	      	deleted;		/* If true then this node is deleted and can be reused */
        struct Node  	*previous;
	bit 	      	isPreviousSmaller;	
	oid	      	hols; 		  	/* # of hols before this piece */
        struct Node  	*nextValue;		/* the node holding the next higher value */

	oid		indexPosition;		/*This is stored normally in the index bat. Due to GDK2 it might be more efficient to keep it here */

	/* Joins */	
	int 	      	slice;		  	/* A view between the position of this index entry and the next one
						   Keeping views around allows us to reuse hash tables built for a view for joins */	

	/* Info needed for incremental maps */
	int 		pieceBAT;		/* The BAT id of the  map for this piece */
	bit		localBound;		/* TRUE if this bound exists only in this piece. FALSE if it exists in the cracker BAT too */
	bit 		first;			/* TRUE if this is the first bound in this piece. FALSE if it is the last. 
							Valid only if localBound=FALSE */
	oid 		indexLocal;		/* Local crack positions */

	 /* Used in the storage management procedure*/ 
	struct Node     *nextPiece;		/*  It identifies the next piece, i.e., the next first node in the map*/
	lng 		creationTimestamp;
	lng 		accesses;
	lng		dropped;
	oid 		tuples;

	/* Used on the cracker BAT side in the case of incremental maps */
	struct referencesNode *references;	/* maps that use this piece */
	int 		tape;			/* Tape holding previous cracks, (value,inclusive) */

	/* For joins */
	BAT *partition;				/*Storing partitions we are about to join. Used when joining an intemediate result*/

	/*for merging techniques*/
	oid sliceSize;		
	oid contiguousArea;
};

typedef struct {
			/* Core cracking */
	int 		bid;   		/* The base BAT */
	int 		cbid;   	/* The cracker column/BAT i.e., the copy on which we actually crack */

	int 		cid;   		/* The cracker index for BAT */
	struct Node 	*Tree; 		/* The AVL-tree part of the cracker index */

			/* Updates */
	int 		iid;   		/* The pending insertions column */
	int 		did;   		/* The pending deletions column */

	bit		reCreate;	/* Indicates whether we need to recreate the index if we chose to forget it */

	sht		mergeInsertions;/* Indicates wether there are insertions to merge -->  -1 no insertions,
												0 complete merge,
												1 gradually,
												2 ripple */
	sht		mergeDeletions; /* Indicates wether there are insertions to merge -->  -1 no insertions,
												0 complete merge,
												1 gradually,
												2 ripple */
	bit 		deleteNodes;    /* If set true, merging operations will delete nodes 
					   form the cracker index if this makes things easier */

			/* Sideways cracking */
	int 		pbid; 		/* The cracker map. Together with the bid, they uniquely identify 
				           a cracker map when pid is -1 then chid stores the cracker 
                                           tape for all the cracker maps where bid is head 
				           hiid is a [bit,bit] BAT that stores inclusive information 
					   for each bound stored in chid */

	oid 		nextCrack;	/* Points to the next cracking operation that should be applied 
                                           in this map to sync it */
	int 		chid;
	int 		hiid;

	lng 		pieces; 	/* number of physical pieces in the column. For now maintained only for sideways cracking  */

	struct referencesNode *references;
	lng 		creationTimestamp;
	lng 		accesses;
	lng		dropped;
	oid 		tuples;

	/* for sort merge techniques */
	struct sortMergeNode *smNode;

} CrackerIndexNode;

/* for storage management */
struct mapNode{
        int             tailBatId;	  
        struct mapNode  *nextMap;
        struct Node     *nextPiece;
};

struct mapSetNode{
        int             batId;
        struct mapNode  *nextMap;
        struct mapSetNode *nextMapSet;
};

struct storageManagement{
	oid totalTuples;	
	oid threshold;
	bit setThreshold;
	struct mapSetNode *nextMapSet;	/* the list of map set nodes are holding info on map sets based on mapSetNode->batId
					   Each map set node has a list of mapNodes for each map that exists in this map set
					   Each mapNode has a list of Nodes linking directly to the cracker indices of the respective maps
					   Each Node is the FIRST node of a piece in a map*/

	struct referencesNodeFM *references; /* used in the case of full maps to hold the maps used in the current query */
	int temp;
};
/*-------------------------------------------------------*/

/* Signatures shared within the crackers module/library */
@:IndexSharedFunctions_decl_0@
@:TypeSwitch(IndexSharedFunctions_decl_1)@

#endif

/* Exported signatures */
@:IndexExport_decl@

#endif /* _CRACKERS_INDEX_H */
@


@- Exported signatures

@= IndexExport_decl
crackers_export str CRKprintCrackerIndexBATpart(int *k, int *bid);
crackers_export str CRKprintAVLTree_int(int *k, int *bid);
crackers_export str CRKprintCrackerBAT(int *k, int *bid);
crackers_export str CRKgetCrackerBAT(int *vid, int *bid);
@


@- Signatures shared within the crackers module/library

@= IndexSharedFunctions_decl_0
int existsCrackerIndex(int bid);
@

@= IndexSharedFunctions_decl_1
/* CreateNewIndex */
int newCrackerIndex_@1(int bid, int cbid);
int newCrackerIndexSlice_@1(int bid, int cbid,int IndexSize);
void reCreateMap_@1(int position);

/* InsertIndexElements */
struct Node * addCrackerIndex_@1(int m, @1 *value, bit inclusive, oid index, BAT * b);
struct Node * addCrackerIndexIncrementalSideways_@1(int m, @1 value, bit inclusive, oid indexLocal, oid index, BAT * b, bit localBound, bit first, int pieceBAT);
@


@{
@+ Implementation


@- C file

@c
#include "monetdb_config.h"
#include "crackers.h"

/* Functions shared within the crackers module/library */
@:IndexSharedFunctions_impl_0@
@:TypeSwitch(IndexSharedFunctions_impl_1)@

/* Exported functions */
@:IndexExport_impl@
@


@- Exported functions

@= IndexExport_impl
str
CRKprintCrackerIndexBATpart(int *k, int *bid){
	int i = existsCrackerIndex(*bid);

	(void)k;

	if (i == -1)
		fprintf(stderr, " the crack index does not exist \n");
	BATprint(BATdescriptor(CrackerIndex[i].cid));

	return MAL_SUCCEED;
}

str
CRKprintAVLTree_int(int *k, int *bid){
	BAT *c;
	int position;
	BUN idxFirst;

	(void) k;

	position = existsCrackerIndex(*bid);
        if (position == -1)
                fprintf(stderr, " the crack index does not exist \n");

	if ((c = BATdescriptor(CrackerIndex[position].cid)) == NULL)
                throw(MAL, "crackers.CRKprintAVLTree_int", "Cannot access cracker index");

        idxFirst = BUNfirst(c);
	printAVLTree(CrackerIndex[position].Tree, c, idxFirst);

	BBPunfix(c->batCacheid);

	return MAL_SUCCEED;
}

str
CRKprintCrackerBAT(int *k, int *bid){
	int i = existsCrackerIndex(*bid);

	(void)k;

	if (i == -1)
		fprintf(stderr, " the crack index does not exist \n");
	BATprint(BATdescriptor(CrackerIndex[i].cbid));

	return MAL_SUCCEED;
}

str
CRKgetCrackerBAT(int *vid, int *bid){
        int i = existsCrackerIndex(*bid);
        if (i == -1)
                fprintf(stderr, " the cracker index does not exist \n");
        if (CrackerIndex[i].cbid > 0){
		*vid = CrackerIndex[i].cbid;
		BBPincref(*vid,TRUE);
	}
	else
		*vid = 0;

        return MAL_SUCCEED;
}
@


@- Functions shared within the crackers module/library

@= IndexSharedFunctions_impl_0
int
existsCrackerIndex(int bid){
	int i;
	
	for (i = 0; i < maxCrackMap; i++)
		if (CrackerIndex[i].bid == bid)
			return i;
	return -1;
}
@

@= IndexSharedFunctions_impl_1
/* CreateNewIndex */
int
newCrackerIndex_@1(int bid, int cbid){
	int i, j, freemap = -1, units = 100;
        BAT *b;

        for (i = 0; i < maxCrackMap; i++){
                if (CrackerIndex[i].bid == -1){
                        freemap = i;
                        break;
                }
        }

        if (freemap == -1){
                if (i == maxCrackMap) {
                        CrackerIndexNode *x;

                        if (maxCrackMap > 0)
                                units = (int) (1.2 * maxCrackMap);
                        x = (CrackerIndexNode *) GDKmalloc(sizeof(CrackerIndexNode) * units);
                        memset(x, 0, sizeof(CrackerIndexNode) * units);
                        if (CrackerIndex) {
                                fprintf(stderr, "reallocate index \n");
                                memcpy(x, CrackerIndex, sizeof(CrackerIndexNode) * i);
                                GDKfree(CrackerIndex);
                        }
                        CrackerIndex = x;

                        /* mark the new slots as empty */
                        for(j=maxCrackMap; j<units;j++){
                                CrackerIndex[j].bid = -1;
                        }
                        maxCrackMap = units;
                }
        }

	CrackerIndex[i].chid = -1;
	CrackerIndex[i].hiid = -1;
	CrackerIndex[i].pbid = -1;
	CrackerIndex[i].bid = bid;
	CrackerIndex[i].cbid = cbid;
	b = BATnew(TYPE_oid, TYPE_@1, IndexEntries);	/* TODO: size */
	BBPkeepref(b->batCacheid);
	CrackerIndex[i].cid = b->batCacheid;
	CrackerIndex[i].iid = -1;
	CrackerIndex[i].did = -1;
	CrackerIndex[i].mergeInsertions = -1;
	CrackerIndex[i].reCreate = 0;
	CrackerIndex[i].Tree = NULL;
	CrackerIndex[i].references = NULL;
	CrackerIndex[i].deleteNodes = FALSE;
	CrackerIndex[i].mergeDeletions = -1;
	CrackerIndex[i].smNode = NULL;
	return i;
}

/*for sliced cracking*/
int
newCrackerIndexSlice_@1(int bid, int cbid, int IndexSize){
	int i, j, freemap = -1, units = 500000;
        BAT *b;

        for (i = 0; i < maxCrackMap; i++){
                if (CrackerIndex[i].bid == -1){
                        freemap = i;
                        break;
                }
        }

        if (freemap == -1){
                if (i == maxCrackMap) {
                        CrackerIndexNode *x;

                        if (maxCrackMap > 0)
                                units = (int) (1.2 * maxCrackMap);
                        x = (CrackerIndexNode *) GDKmalloc(sizeof(CrackerIndexNode) * units);
                        /*memset(x, 0, sizeof(CrackerIndexNode) * units);*/
                        if (CrackerIndex) {
                                fprintf(stderr, "reallocate index \n");
                                memcpy(x, CrackerIndex, sizeof(CrackerIndexNode) * i);
                                GDKfree(CrackerIndex);
                        }
                        CrackerIndex = x;

                        /* mark the new slots as empty */
                        for(j=maxCrackMap; j<units;j++){
                                CrackerIndex[j].bid = -1;
                        }
                        maxCrackMap = units;
                }
        }

	CrackerIndex[i].chid = -1;
	CrackerIndex[i].hiid = -1;
	CrackerIndex[i].pbid = -1;
	CrackerIndex[i].bid = bid;
	CrackerIndex[i].cbid = cbid;
	b = BATnew(TYPE_oid, TYPE_@1, IndexSize);
	BBPkeepref(b->batCacheid);
	CrackerIndex[i].cid = b->batCacheid;
	CrackerIndex[i].iid = -1;
	CrackerIndex[i].did = -1;
	CrackerIndex[i].mergeInsertions = -1;
	CrackerIndex[i].reCreate = 0;
	CrackerIndex[i].Tree = NULL;
	CrackerIndex[i].references = NULL;
	CrackerIndex[i].deleteNodes = FALSE;
	CrackerIndex[i].mergeDeletions = -1;
	CrackerIndex[i].smNode = NULL;
	return i;
}

void
reCreateMap_@1(int position){
	BAT *b;

	b = BATnew(TYPE_oid, TYPE_@1, IndexEntries);	/* TODO: size */
	BBPkeepref(b->batCacheid);
	CrackerIndex[position].cid = b->batCacheid;
	CrackerIndex[position].reCreate = 0;
	
	return;
}


/* InsertIndexElements */
struct Node *
addCrackerIndex_@1(int m, @1 *value, bit inclusive, oid index, BAT * b){
	BUN base;
	oid *ph;
	@1  *pt;
	struct Node *newNode=NULL, *prev=NULL, *res=NULL, *temp=NULL;
	oid count;
	int viewId;

	ph = (oid*)Hloc(b, BUNlast(b));
	pt = (@1 *)Tloc(b, BUNlast(b));

	count = BATcount(b);
        if (count == (oid)0){
                @:insertIndexElement(@1, (oid*)Hloc(b, BUNfirst(b)), (@1*)Tloc(b, BUNfirst(b)), index, *value)@
		CrackerIndex[m].Tree = (struct Node *)GDKmalloc(sizeof(struct Node));
                CrackerIndex[m].Tree->position = (oid)0;
                CrackerIndex[m].Tree->inclusive = inclusive;
                CrackerIndex[m].Tree->height = 0;
                CrackerIndex[m].Tree->left = NULL;
                CrackerIndex[m].Tree->right = NULL;		
                CrackerIndex[m].Tree->head = TRUE;	
                CrackerIndex[m].Tree->deleted = FALSE;	
                CrackerIndex[m].Tree->previous = NULL;	
                CrackerIndex[m].Tree->hols = (oid)0;	
                CrackerIndex[m].Tree->slice = -1;	

                CrackerIndex[m].Tree->nextValue = NULL;	
		CrackerIndex[m].Tree->indexPosition = index; 
			
		CrackerIndex[m].pieces++;
                return CrackerIndex[m].Tree;
        }

	base = BUNfirst(b);
	res = InsertTree_@1(m, count, *value, inclusive, index, CrackerIndex[m].Tree, b, base, &newNode);
	if (newNode==NULL){
		mnstr_printf(GDKout,"\n Inserting into the Tree failed: possibly node existed already or a malloc failed \n");
		return NULL;
	}
	CrackerIndex[m].pieces++;
	prev = findPreviousPieceWalkingBack(newNode);
	if (prev!= NULL) prev->nextValue = newNode;
	newNode->nextValue = findNextPiece(newNode);
	newNode->indexPosition = index;
        if ( res != NULL ) {
		/* use a new BUN only if we cannot reuse a previously deleted one */
		@:insertIndexElement(@1, ph, pt, index, *value)@
		/* remove hash table since cracking has destroyed tuple positioning */
		if (prev != NULL){
			if (prev->slice != -1){
				viewId = prev->slice;
				BBPdecref(prev->slice,TRUE);
				prev->slice = -1; 

				/* if there are more pieces included in this hash table remove these pieces too
				   in the future we should more clever reuse by allowing partially correct hash tables to be reused	   
				*/
				temp = findPreviousPieceWalkingBack(prev);	
				while(temp!=NULL){
					if (temp->slice == viewId)
						temp->slice = -1;
					else
						break;
					temp = findPreviousPieceWalkingBack(temp);	
				}
				
				temp = newNode->nextValue;
				while(temp!=NULL){
					if (temp->slice == viewId)
						temp->slice = -1;
					else
						break;
					temp = temp->nextValue;				
				}
			}
		}
	}
	return newNode;
}

struct Node *
addCrackerIndexIncrementalSideways_@1(int m, @1 value, bit inclusive, oid indexLocal, oid index, BAT * b, bit localBound, bit first, int pieceBAT){
	BUN base;
	oid *ph;
	@1  *pt;
	struct Node *newNode=NULL, *prev=NULL;
	oid count;

	ph = (oid*)Hloc(b, BUNlast(b));
	pt = (@1 *)Tloc(b, BUNlast(b));

	count = BATcount(b);
        if (count == 0){
                @:insertIndexElement(@1, (oid*)Hloc(b, BUNfirst(b)), (@1*)Tloc(b, BUNfirst(b)), index, value)@
		CrackerIndex[m].Tree = (struct Node *)GDKmalloc(sizeof(struct Node));
                CrackerIndex[m].Tree->position = 0;
                CrackerIndex[m].Tree->inclusive = inclusive;
                CrackerIndex[m].Tree->height = 0;
                CrackerIndex[m].Tree->left = NULL;
                CrackerIndex[m].Tree->right = NULL;		
                CrackerIndex[m].Tree->head = TRUE;	
                CrackerIndex[m].Tree->deleted = FALSE;	
                CrackerIndex[m].Tree->previous = NULL;	
                CrackerIndex[m].Tree->hols = 0;	
                CrackerIndex[m].Tree->slice = -1;	
                CrackerIndex[m].Tree->localBound = localBound;	
                CrackerIndex[m].Tree->first = first;	
                CrackerIndex[m].Tree->pieceBAT = pieceBAT;	
                CrackerIndex[m].Tree->tape = -1;	
                CrackerIndex[m].Tree->indexLocal = indexLocal;	
                CrackerIndex[m].Tree->references = NULL;	
                CrackerIndex[m].Tree->nextPiece = NULL;	
                CrackerIndex[m].Tree->nextValue = NULL;	
		CrackerIndex[m].Tree->indexPosition = index; 

                return CrackerIndex[m].Tree;
        }

	base = BUNfirst(b);
	InsertTreeIncrementalSideways_@1(m, count, value, inclusive, index, indexLocal, CrackerIndex[m].Tree, b, base, &newNode,localBound, first, pieceBAT);
        if ( newNode != NULL ) {
		/* use a new BUN only if we cannot reuse a previously deleted one */
		@:insertIndexElement(@1, ph, pt, index, value)@
		/* remove hash table since cracking has destroyed tuple posititioning */
		prev = findPreviousPieceWalkingBack(newNode);
		if (prev!= NULL) prev->nextValue = newNode;
		newNode->nextValue = findNextPiece(newNode);
		newNode->indexPosition = index;
		if (prev != NULL){
			if (prev->slice != -1){
				BBPdecref(prev->slice,TRUE);
				prev->slice = -1; 
			}
		}
	}
	return newNode;
}
@


@- Local support functions and macros

@= insertIndexElement
	*@2 = @4;	
	*@3 = @5;	
	count++;
	BATsetcount(b,count);
@

@}
