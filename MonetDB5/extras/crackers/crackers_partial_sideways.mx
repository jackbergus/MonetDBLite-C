@/
The contents of this file are subject to the MonetDB Public License
Version 1.1 (the "License"); you may not use this file except in
compliance with the License. You may obtain a copy of the License at
http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html

Software distributed under the License is distributed on an "AS IS"
basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations
under the License.

The Original Code is the MonetDB Database System.

The Initial Developer of the Original Code is CWI.
Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
Copyright August 2008-2011 MonetDB B.V.
All Rights Reserved.
@

@f crackers_partial_sideways
@a Martin Kersten, Stratos Idreos, Stefan Manegold
@d March 2006 - July 2008
@* Partial Sideways Cracking


@+ Interface


@- Type expansion

@= TypeSwitch_2
@:@1(int,,simple,,int,@2)@
@:@1(dbl,,simple,,dbl,@2)@
@:@1(date,,atom,TYPE_,loc,@2)@
@

@= TypeSwitch_3
/* TODO: add the rest of the type combinations once code is stable */
@:@1(int,int,simple,,,@2)@
@:@1(int,str,simple,,,@2)@
@:@1(int,date,atom,TYPE_,,@2)@
@:@1(dbl,date,atom,TYPE_,,@2)@
@:@1(dbl,str,atom,TYPE_,,@2)@
@:@1(dbl,int,simple,,,@2)@
@:@1(dbl,dbl,simple,,,@2)@

@:@1(date,int,atom,TYPE_,,@2)@
@:@1(date,str,atom,TYPE_,,@2)@
@:@1(date,lng,atom,TYPE_,,@2)@
@:@1(date,dbl,atom,TYPE_,,@2)@
@:@1(date,date,atom,TYPE_,,@2)@
@

@- Header file
 
@h
#ifndef _CRACKERS_PARTIAL_SIDEWAYS_H_
#define _CRACKERS_PARTIAL_SIDEWAYS_H_

#ifdef LIBCRACKERS
/* Signatures shared within the crackers module/library */
@:TypeSwitch_2(IncSidewaysSharedFunctions_decl_2)@
#endif

/* Exported signatures */
@:IncSidewaysFunctions_decl_0@
@:TypeSwitch_3(IncSidewaysFunctions_decl_3)@

#endif /* _CRACKERS_PARTIAL_SIDEWAYS_H */
@

@- Signatures shared within the crackers module/library


@= IncSidewaysSharedFunctions_decl_2
str AddToTapeIncrementalSideways_@1(struct Node *node, @1 value, bit inclusive);
@


@- Exported signatures
 
@= IncSidewaysFunctions_decl_0
crackers_export str CRKaddReference(int* res, int *bid, int *pbid);
crackers_export str CRKclearReferences(int* res, int *bid);
@

@= IncSidewaysFunctions_decl_3
crackers_export str CRKselectBoundsIncrementalSideways_@1_@2(int *vid, int *bid, int *pbid, @1 *low, @1 *hgh, bit *inclusiveLow, bit *inclusiveHgh, @2 *low2, @2 *hgh2, bit *inclusiveLow2, bit *inclusiveHgh2);
crackers_export str CRKselectBoundsTailIncrementalSideways_@1_@2(int *vid, int *bid, int *pbid, @1 *low, @1 *hgh, bit *inclusiveLow, bit *inclusiveHgh);
crackers_export str CRKjoinSelectIncrementalSideways_@1_@2(int *res, int *bid, int *pbid, int *pivot, @1 *low1, @1 *hgh1, bit *inclusiveLow1, bit *inclusiveHgh1, @2 *low, @2 *hgh, bit *inclusiveLow, bit *inclusiveHgh);
crackers_export str CRKProjectIncrementalSideways_@1_@2(int *res, int *bid, int *pbid, int *pivot, @1 *low1, @1 *hgh1, bit *inclusiveLow1, bit *inclusiveHgh1);
crackers_export str CRKMaxTailIncrementalSideways_@1_@2(int *res, int *bid, int *pbid, @1 *low1, @1 *hgh1, bit *inclusiveLow1, bit *inclusiveHgh1);
@


@{
@+ Implementation

 
@- C file

@c
#include "monetdb_config.h"
#include "crackers.h"
#include "crackers_partial_sideways.h"

/* Local support functions and macros */
@:pieceReferencesManagement@
@:TypeSwitch_2(DroppingPieces,)@
@:TypeSwitch_3(SyncOperation,)@
@:TypeSwitch_3(PieceMaps,)@
@:TypeSwitch_2(TapeOperations,)@
@:TypeSwitch_3(crackOperationsIncSideways,)@

/* Functions shared within the crackers module/library */

/* Exported functions */
@:TypeSwitch_3(IncSidewaysFunctions_impl_3)@
@

@- Exported functions


@= IncSidewaysFunctions_impl_3
/* return bit vector of the conjuction */
str
CRKselectBoundsIncrementalSideways_@1_@2(int *vid, int *bid, int *pbid, @1 *low, @1 *hgh, bit *inclusiveLow, bit *inclusiveHgh, @2 *low2, @2 *hgh2, bit *inclusiveLow2, bit *inclusiveHgh2){
	if (@3_EQ(low,ATOMnilptr(TYPE_@1),@4@1))
       		throw(MAL, "crackers.CRKtselectBoundIncrementalsSideways_@1_@2", "case not handled");
	else if (@3_EQ(hgh,ATOMnilptr(TYPE_@1),@4@1))
        	throw(MAL, "crackers.CRKtselectBoundsIncrementalSideways_@1_@2", "case not handled");
	else
		return CRKRangeIncrementalSideways_@1_@2(vid, bid, pbid, low, hgh, inclusiveLow, inclusiveHgh, low2, hgh2, inclusiveLow2, inclusiveHgh2);
}

/* Get directly the qualifying tail tuples */
str
CRKselectBoundsTailIncrementalSideways_@1_@2(int *vid, int *bid, int *pbid, @1 *low, @1 *hgh, bit *inclusiveLow, bit *inclusiveHgh){
	if (@3_EQ(low,ATOMnilptr(TYPE_@1),@4@1))
       		throw(MAL, "crackers.CRKtselectBoundIncrementalsSideways_@1_@2", "case not handled");
	else if (@3_EQ(hgh,ATOMnilptr(TYPE_@1),@4@1))
        	throw(MAL, "crackers.CRKtselectBoundsIncrementalSideways_@1_@2", "case not handled");
	else
		return CRKRangeTailIncrementalSideways_@1_@2(vid, bid, pbid, low, hgh, inclusiveLow, inclusiveHgh);
}


str                     
CRKjoinSelectIncrementalSideways_@1_@2(int *res, int *bid, int *pbid, int *pivot, @1 *low1, @1 *hgh1, bit *inclusiveLow1, bit *inclusiveHgh1, @2 *low, @2 *hgh, bit *inclusiveLow, bit *inclusiveHgh){               
        if (@3_EQ(low1,ATOMnilptr(TYPE_@1),@4@1))
       		throw(MAL, "crackers.CRKjoinSelectIncrementalSideways_@1_@2", "case not handled");
        else if (@3_EQ(hgh1,ATOMnilptr(TYPE_@1),@4@1))
       		throw(MAL, "crackers.CRKjoinSelectIncrementalSideways_@1_@2", "case not handled");
        else
               	return JoinSelectRangeIncrementalSideways_@1_@2(res, bid, pbid, pivot, low1, hgh1, inclusiveLow1, inclusiveHgh1, low, hgh, inclusiveLow, inclusiveHgh);
}

str                     
CRKProjectIncrementalSideways_@1_@2(int *res, int *bid, int *pbid, int *pivot, @1 *low1, @1 *hgh1, bit *inclusiveLow1, bit *inclusiveHgh1){               
        if (@3_EQ(low1,ATOMnilptr(TYPE_@1),@4@1))
       		throw(MAL, "crackers.CRKProjectIncrementalSideways_@1_@2", "case not handled");
        else if (@3_EQ(hgh1,ATOMnilptr(TYPE_@1),@4@1))
       		throw(MAL, "crackers.CRKProjectIncrementalSideways_@1_@2", "case not handled");
        else
               	return ProjectIncrementalSideways_@1_@2(res, bid, pbid, pivot, low1, hgh1, inclusiveLow1, inclusiveHgh1);
}

str                     
CRKMaxTailIncrementalSideways_@1_@2(int *res, int *bid, int *pbid, @1 *low1, @1 *hgh1, bit *inclusiveLow1, bit *inclusiveHgh1){               
        if (@3_EQ(low1,ATOMnilptr(TYPE_@1),@4@1))
       		throw(MAL, "crackers.CRKMaxTailncrementalSideways_@1_@2", "case not handled");
        else if (@3_EQ(hgh1,ATOMnilptr(TYPE_@1),@4@1))
       		throw(MAL, "crackers.CRKMaxTailIncrementalSideways_@1_@2", "case not handled");
        else
               	return MaxTailIncrementalSideways_@1_@2(res, bid, pbid, low1, hgh1, inclusiveLow1, inclusiveHgh1);
}
@


@- Local support functions and macros

@= pieceReferencesManagement
void
newReference(int m, int batid){
	struct referencesNode *newNode, *cur;

	newNode = (refNode*) GDKmalloc(sizeof(refNode));
	newNode->batId = batid;
	newNode->cursor = 0;
	newNode->next = NULL;

	if (CrackerIndex[m].references == NULL){
		CrackerIndex[m].references = newNode;
	}else{
		cur = CrackerIndex[m].references;
		while (cur->next != NULL){
			cur = cur->next;
		}
		cur->next = newNode;
	}
	return;
}

str
CRKaddReference(int* res, int *bid, int *pbid){
	int m;
	(void)res;

	m = existsCrackerIndex(*bid);
	if (m>=0){
		newReference(m,*pbid);
	}

	return MAL_SUCCEED;
}

str
CRKclearReferences(int* res, int *bid){
	int m;
	struct referencesNode *cur,*nodeToFree;
	(void)res;

	m = existsCrackerIndex(*bid);

	if (m>=0){
		if (CrackerIndex[m].references == NULL)
			return MAL_SUCCEED;	
		cur = CrackerIndex[m].references;
		while (cur->next != NULL){
			nodeToFree = cur;
			cur = cur->next;
			GDKfree(nodeToFree);
		}
		GDKfree(cur);
		CrackerIndex[m].references = NULL;
	}

	return MAL_SUCCEED;
}

void 
registerMapReference(struct Node *CBnode, int batId){
	struct referencesNode *newNode, *cur;

        newNode = (refNode*) GDKmalloc(sizeof(refNode));
        newNode->batId = batId;
        newNode->cursor = 0;
        newNode->next = NULL;

        if (CBnode->references == NULL){
                CBnode->references = newNode;
        }else{
                cur = CBnode->references;
                while (cur->next != NULL){
                        cur = cur->next;
		}
                cur->next = newNode;
        }
        return;
}

void 
clearMapReference(struct Node *CBnode, int batId){
	struct referencesNode *prev, *cur;
/*	struct Node *temp;*/


        if (CBnode->references == NULL){
                return;
        }else{
		if ( CBnode->references->next == NULL){
			if (CBnode->references->batId == batId){

/*
				temp = findPreviousPieceWalkingBack(CBnode);
			        if (temp == NULL)
			                CBnode->deleted = TRUE;
			        else
			        if (!(temp->localBound == TRUE && temp->first == FALSE))
			                CBnode->first   = FALSE;
			        else
			                CBnode->deleted = TRUE;

				temp = findNextPiece(CBnode);
				if (temp == NULL)
					printf("\n\n LAST is NULL \n\n");
					
				if (temp->first == FALSE)
					temp->deleted = TRUE;
*/				
				if (CBnode->tape >0)
					BBPdecref(CBnode->tape, TRUE);
				CBnode->tape = -1;

				GDKfree(CBnode->references);
				CBnode->references = NULL;
				return;
			}
printf("\n\n Trying to remove a piece that is not registered \n\n");
		}
                cur  = CBnode->references;
		prev = NULL;
                while (cur->next != NULL){
			if (cur->batId == batId){
				if (cur->next == NULL) 
					prev->next = NULL;
				else{
					if (prev == NULL)
						CBnode->references = cur->next;
					else
						prev->next = cur->next;
				}
				GDKfree(cur);
				return;			
			}
			prev = cur;
                        cur  = cur->next;
		}
        }
        return;
}

oid getTapeCursor(struct Node *CBnode, int batId){
	struct referencesNode *cur;

	cur = CBnode->references;
	while(cur != NULL){
		if (cur->batId == batId){
			return cur->cursor;
		}
		cur=cur->next;
	}		

	return 0;
} 

oid getMaxTapeCursorForRefsInCurrentQuery(struct Node *CBnode, int m){
	struct referencesNode *cur;
	oid max = 0, curCursor;

	cur = CrackerIndex[m].references;
	while (cur != NULL){
		curCursor = getTapeCursor(CBnode, cur->batId);

		if (curCursor > max)
			max = curCursor;
		cur = cur->next;
	}
	return max;
}

void increaseLocalCursor(struct Node *CBnode, int batId, oid increase){
	struct referencesNode *cur;

        cur = CBnode->references;
        while(cur != NULL){
                if (cur->batId == batId){
                        cur->cursor += increase;
			return;
		}
                cur=cur->next; 
        }         
}

bit isThisMapUsedInCurrentQuery(int CBindex, int batId, int tailBatId){
	struct referencesNode *cur;
	
	if (CrackerIndex[CBindex].bid != batId)
		return FALSE;

	cur = CrackerIndex[CBindex].references;
	while (cur != NULL){
		if (cur->batId == tailBatId)
			return TRUE;
		cur = cur->next;
	}
	return FALSE;
}

void 
registerPieceForStorageManagement(int batId, int tailBatId, struct Node * localFirst, oid tuples){
	struct mapSetNode *curMapSet, *prevMapSet, *newMapSet;	
	struct mapNode *curMap, *newMap, *prevMap;

	localFirst->creationTimestamp = GDKusec(); 
	localFirst->tuples   = tuples;
	localFirst->accesses = 1;
	localFirst->dropped  = 0;

	StorageInfo->totalTuples += tuples;

	prevMapSet = NULL;
	curMapSet  = StorageInfo->nextMapSet;
	while( curMapSet != NULL){
		if (curMapSet->batId == batId){
			prevMap = NULL;
			curMap  = curMapSet->nextMap;	
			while(curMap != NULL){
				if (curMap->tailBatId == tailBatId){
					/* put the new piece in the beginning of the pieces list */
					if (curMap->nextPiece == NULL){
						curMap->nextPiece = localFirst;
			                        localFirst->nextPiece = NULL;
						return;
					}
					localFirst->nextPiece = curMap->nextPiece;
					curMap->nextPiece = localFirst;
					return;
				}
				prevMap = curMap;
				curMap	= curMap->nextMap;
			}
		
			/* although the map set exists, there are no registered pieces for this map so make a new entry */
			newMap = (struct mapNode *)GDKmalloc(sizeof(struct mapNode));
		        newMap->tailBatId = tailBatId;
		        newMap->nextMap = NULL; 
		        newMap->nextPiece = localFirst;        
		        localFirst->nextPiece = NULL;

			if (curMapSet->nextMap == NULL)
				curMapSet->nextMap = newMap;
			else
				prevMap->nextMap = newMap;
			return;
		}
		prevMapSet = curMapSet;
		curMapSet  = curMapSet->nextMapSet; 
	}

	/* if no pieces in this map set are previously registered then make a new entry for the map set and the map */
	newMapSet = (struct mapSetNode *)GDKmalloc(sizeof(struct mapSetNode));
	newMapSet->batId = batId;
	newMapSet->nextMapSet = NULL;

	newMap = (struct mapNode *)GDKmalloc(sizeof(struct mapNode));
	newMap->tailBatId = tailBatId;
	newMap->nextMap = NULL;
	newMap->nextPiece = localFirst;		
	localFirst->nextPiece = NULL;

	newMapSet->nextMap = newMap;

	if (StorageInfo->nextMapSet == NULL)
		StorageInfo->nextMapSet = newMapSet;
	else
		prevMapSet->nextMapSet = newMapSet;
}

struct Node *
getTheLeastUsedMapPiece(int CBindex, int *batId, int *tailBatId){
	struct mapSetNode *curMapSet;	
	struct mapNode *curMap;
	struct Node *curPiece, *res = NULL;
	lng accesses = 0;

	curMapSet  = StorageInfo->nextMapSet;
	while( curMapSet != NULL){

		if (curMapSet->nextMap != NULL){
			curMap  = curMapSet->nextMap;	
			while(curMap != NULL){

				/*----------------------------------------------------------------------*/
				/*  do not drop a piece from one of the maps used in the current query  */
				if (isThisMapUsedInCurrentQuery(CBindex, curMapSet->batId, curMap->tailBatId)){
					curMap  = curMap->nextMap;
					continue;
				}
				/*----------------------------------------------------------------------*/

				curPiece = curMap->nextPiece;
				while(curPiece != NULL){

					/*---------------------------------------------------*/
					/* get the piece with the smaller number of accesses */
					if (accesses == 0){
						accesses   = curPiece->accesses;
						res 	   = curPiece;
						*batId 	   = curMapSet->batId;
						*tailBatId = curMap->tailBatId;
					}
					else if (curPiece->accesses < accesses){
						accesses = curPiece->accesses;
						res = curPiece;
						*batId 	   = curMapSet->batId;
						*tailBatId = curMap->tailBatId;
					}
					/*----------------------------------------------------*/

					curPiece = curPiece->nextPiece;
				}
				curMap	= curMap->nextMap;
			}
		}
		curMapSet  = curMapSet->nextMapSet; 
	}
	return res;
}

void printStorageInfo(){
	struct mapSetNode *curMapSet;	
	struct mapNode *curMap;
	struct Node *curPiece;

	printf("\n\nSTORAGE INFO\n\n");
	curMapSet  = StorageInfo->nextMapSet;
	while( curMapSet != NULL){
		printf("\n MAP SET of %d \n  Maps are: \n ", curMapSet->batId);
		if (curMapSet->nextMap != NULL){
			curMap  = curMapSet->nextMap;	
			while(curMap != NULL){

			printf("     MAP: %d  with pieces: \n", curMap->tailBatId);

				curPiece = curMap->nextPiece;
				while(curPiece != NULL){
			printf("          Piece: %d \n", curPiece->pieceBAT);
					curPiece = curPiece->nextPiece;
				}
				curMap	= curMap->nextMap;
			}
		}
		curMapSet  = curMapSet->nextMapSet; 
	}
	printf("\n\n");
}

void
removePieceFromStorageInfo(int batId, int tailBatId, int pieceId){
	struct mapSetNode *curMapSet, *prevMapSet;	
	struct mapNode *curMap, *prevMap;
	struct Node *curPiece, *prevPiece;

	prevMapSet = NULL;
	curMapSet  = StorageInfo->nextMapSet;
	while( curMapSet != NULL){
		if (curMapSet->batId == batId){
			prevMap = NULL;
			curMap  = curMapSet->nextMap;	
			while(curMap != NULL){
				if (curMap->tailBatId == tailBatId){
					prevPiece = NULL;
					curPiece  = curMap->nextPiece;
					while(curPiece != NULL){
						if (curPiece->pieceBAT == pieceId){

							StorageInfo->totalTuples -= curPiece->tuples;

							if (curPiece->nextPiece == NULL){
								if (prevPiece == NULL){
									if (curMap->nextMap == NULL){
										GDKfree(curMap);
										if (prevMap == NULL){
											if (curMapSet->nextMapSet == NULL){
												GDKfree(curMapSet);
												if (prevMapSet == NULL){
													StorageInfo->nextMapSet = NULL;	
												}else
													prevMapSet->nextMapSet = NULL;
												return;
											}
											if (prevMapSet == NULL)
												StorageInfo->nextMapSet = curMapSet->nextMapSet;
											else
												prevMapSet->nextMapSet = curMapSet->nextMapSet;		
											GDKfree(curMapSet);
                                                                                        return;
											
										}else
											prevMap->nextMap = NULL;
										return;
									}	
									if (prevMap == NULL)
										curMapSet->nextMap = curMap->nextMap;
									else
										prevMap->nextMap = curMap->nextMap;
									GDKfree(curMap);
                                                                        return;
								}else
									prevPiece->nextPiece = NULL;
								return;
							}
							if (prevPiece == NULL)
								curMap->nextPiece = curPiece->nextPiece;
							else
								prevPiece->nextPiece = curPiece->nextPiece;

							curPiece->nextPiece = NULL;
							return;
						}
						prevPiece = curPiece;
						curPiece  = curPiece->nextPiece;
					}
				}
				prevMap = curMap;
				curMap	= curMap->nextMap;
			}
		
		}
		prevMapSet = curMapSet;
		curMapSet  = curMapSet->nextMapSet; 
	}
}

void
removePieceFromAVLtree(struct Node *localFirst){
	struct Node *temp;
	
	/* if there is a piece attached to this one then mark the current node as a LAST node 
	   otherwise simply mark it as deleted, similarly to the middle nodes */
	temp = findPreviousPieceWalkingBack(localFirst);
	if (temp == NULL)
		localFirst->deleted = TRUE;
	else
	if (!(temp->localBound == FALSE && temp->first == FALSE)){ 
		localFirst->first   = FALSE;
		localFirst->pieceBAT = temp->pieceBAT; 
	}else
		localFirst->deleted = TRUE;


	/* mark all the middle piece as deleted */
	temp =findNextPiece(localFirst);
	while (temp->localBound == TRUE){
		temp->deleted = TRUE;
		temp = findNextPiece(temp);
	}

	/* now temp points to the last node in this piece 
	   If a new piece starts from here let is be as it is
	   otherwise delete this one too */
	if (temp->first == FALSE)
		temp->deleted = TRUE;
}
@

@= PieceMaps

BAT * 
createPieceMap_@1_@2(BAT * crackerBAT, BAT *tailBAT, struct Node *nodeLow, struct Node *nodeHgh, int CBindex){
	BAT *pieceMap;
	@1 *mapHead, *crackerBATTail ;
	oid *crackerBATHead;
	BUN tailBATFirst; 
	@2 *mapTail;
	oid size;
	oid pos1,pos2;
	oid i;

	if (nodeLow == NULL)
		return NULL;
	if (nodeHgh == NULL)
		return NULL;

	if (nodeLow->indexLocal == 0) pos1 = 0;
	else pos1 = nodeLow->indexLocal + 1;
	pos2 = nodeHgh->indexLocal; 

	size = (pos2-pos1)+1;
        pieceMap = BATnew(crackerBAT->ttype, tailBAT->ttype, size);

	tailBATFirst = BUNfirst(tailBAT);
	mapHead = (@1*)Hloc(pieceMap, BUNfirst(pieceMap));
	mapTail = (@2*)Tloc(pieceMap, BUNfirst(pieceMap));
	crackerBATHead = (oid*)Hloc(crackerBAT, BUNfirst(crackerBAT)+pos1);
	crackerBATTail = (@1 *)Tloc(crackerBAT, BUNfirst(crackerBAT)+pos1);

	for(i=0;i<size;i++){
		*mapHead = *crackerBATTail;
		*mapTail = *(@2*)Tloc(tailBAT, tailBATFirst + *crackerBATHead);

		mapHead ++; 
		mapTail ++; 
		crackerBATHead ++;
		crackerBATTail ++;
	}	

        BATsetcount(pieceMap,size);

        BATkey(BATmirror(pieceMap),FALSE);
        pieceMap->batRestricted= BAT_READ;
        BATmode(pieceMap,PERSISTENT);

	if (StorageInfo->setThreshold == TRUE){

		/* remove pieces until we have enough space left for the new one */
		while (StorageInfo->totalTuples + size > StorageInfo->threshold){
			struct Node *localFirstNodeOfPieceToRemove = NULL;
			int batId=0, tailBatId=0;
			localFirstNodeOfPieceToRemove = getTheLeastUsedMapPiece(CBindex, &batId, &tailBatId); 
			if (localFirstNodeOfPieceToRemove == NULL)
				 printf("\n crackers.createPieceMap Unexpected case: Could not find a piece to remove \n ");
			else
				dropPiece_@1(batId, tailBatId, localFirstNodeOfPieceToRemove);
		}
	}

	registerMapReference(nodeLow,tailBAT->batCacheid);
	return pieceMap;	
}


@= DroppingPieces
str 
dropPiece_@1(int batId, int tailBatId, struct Node *localFirst){
	int CBindex, Lindex;
	BAT *ci, *li, *piece;
	struct Node *CBnodeFirst=NULL, *CBnodeLast=NULL;
	bit found = FALSE;

	removePieceFromStorageInfo(batId, tailBatId, localFirst->pieceBAT);

	/* Find the corresponding CB node and remove the piece reference for this map */
	CBindex = existsCrackerIndexSideways(batId,-1);
        if ((ci = BATdescriptor(CrackerIndex[CBindex].cid)) == NULL)
                throw(MAL, "crackers.dropPiece", "Cannot access crack index");
	Lindex = existsCrackerIndexSideways(batId, tailBatId);
        if ((li = BATdescriptor(CrackerIndex[Lindex].cid)) == NULL)
                throw(MAL, "crackers.dropPiece", "Cannot access crack index");

        found = GetLowNodes_@1(*(@1*)Tloc(li, BUNfirst(li)+localFirst->position), localFirst->inclusive, CrackerIndex[CBindex].Tree, ci, BUNfirst(ci), &CBnodeFirst, &CBnodeLast, NULL, NULL);

	BBPunfix (ci->batCacheid);	
	BBPunfix (li->batCacheid);	

	if (CBnodeFirst == NULL)
		throw(MAL, "crackers.dropPiece", "Could not find correct CB node. I fot a NULL node");

	if (CBnodeFirst->first ==FALSE)
		throw(MAL, "crackers.dropPiece", "Could not find correct CB node. I fot a LAST node");
	if (found == 0)
		throw(MAL, "crackers.dropPiece", "Could not find CB node");

	clearMapReference(CBnodeFirst, tailBatId);

	/* remove the actual bat holding the map piece */
        if ((piece = BATdescriptor(localFirst->pieceBAT)) == NULL)
                throw(MAL, "crackers.dropPiece", "Cannot access crack index");
	BATmode(piece, TRANSIENT);	
	BBPunfix(localFirst->pieceBAT);
	BBPdecref(localFirst->pieceBAT, TRUE);
	
	removePieceFromAVLtree(localFirst);

	return MAL_SUCCEED;
}
@

@= crkTwoRTree
	if (@4==NULL) cl2=0;
        else cl2 = @4->indexLocal;
        if (@5==NULL) ch2=BATcount(@3)-1;
        else if (@5->localBound == FALSE) ch2=BATcount(@3)-1;
        else ch2 = @5->indexLocal;
        if (cl2>0) cl2+=1;
        /*CRACK in two pieces cl2-ch2 using <incHgh bound*/
        if (*inclusiveHgh == TRUE)
                CRKcrackUnorderedZero_LE_@1(@3,*hgh, cl2, ch2,&vh);
        else
                CRKcrackUnorderedZero_RE_@1(@3,*hgh, cl2, ch2,&vh);

        /*check for gaps*/
        if (vh < cl2)
                /*then the left piece is empty*/
                gapH = -1;
        if (vh > ch2){
                /*then the right piece is empty*/
                gapH = -1;
                vh--;
        }
@

@= crkTwoLTree
	if (@4==NULL) cl1=0;
        else cl1 = @4->indexLocal;
        if (@5==NULL) ch1=BATcount(@3)-1;
        else if (@5->localBound == FALSE) ch1=BATcount(@3)-1;
        else ch1 = @5->indexLocal;
        if (cl1>0) cl1+=1;
        /*CRACK in two pieces cl1-ch1 using >incLow bound*/
        if (*inclusiveLow == TRUE)
                CRKcrackUnorderedZero_RE_@1(@3,*low, cl1, ch1,&vl);
        else
                CRKcrackUnorderedZero_LE_@1(@3,*low, cl1, ch1,&vl);
        if (vl < cl1){
                /*then the left piece is empty*/
                gapL = -1;
        }
        if (vl > ch1){
                /*then the right piece is empty*/
                vl--;
                gapL = -1;
        }
        vl++; /* We need to take next position because the crack function always returns the last bun of the left piece.
                Instead we want the first bun of the right piece*/
@

@= crkThreeTree
        if (*inclusiveLow == TRUE && *inclusiveHgh == TRUE)
                CRKcrackUnorderedThree_LE_RE_@1(b,*low,*hgh, @3, @4, &vl, &vh);
        if (*inclusiveLow == TRUE && *inclusiveHgh == FALSE)
                CRKcrackUnorderedThree_LE_RO_@1(b,*low,*hgh, @3, @4, &vl, &vh);
        if (*inclusiveLow == FALSE && *inclusiveHgh == TRUE)
                CRKcrackUnorderedThree_LO_RE_@1(b,*low,*hgh, @3, @4, &vl, &vh);
        if (*inclusiveLow == FALSE && *inclusiveHgh == FALSE)
                CRKcrackUnorderedThree_LO_RO_@1(b,*low,*hgh, @3, @4, &vl, &vh);

        /*if (vl != -1 && vh != -1)*/
                if (vl>0) _vl=vl-1; else _vl=vl;
	   	nodeLow1 = addCrackerIndexIncrementalSideways_@1(m, *low, *inclusiveLow, _vl, _vl, c, TRUE, TRUE, -1);
        	nodeHgh1 = addCrackerIndexIncrementalSideways_@1(m, *hgh, HBound, vh, vh, c, TRUE, FALSE, -1);
        
@
@= crkThreeTreeIncrementalSideways
        if (*inclusiveLow == TRUE && *inclusiveHgh == TRUE)
                CRKcrackUnorderedThreeSideways_LE_RE_@1_@2(@5,*low,*hgh, @3, @4, &vl, &vh);
        if (*inclusiveLow == TRUE && *inclusiveHgh == FALSE)
                CRKcrackUnorderedThreeSideways_LE_RO_@1_@2(@5,*low,*hgh, @3, @4, &vl, &vh);
        if (*inclusiveLow == FALSE && *inclusiveHgh == TRUE)
                CRKcrackUnorderedThreeSideways_LO_RE_@1_@2(@5,*low,*hgh, @3, @4, &vl, &vh);
        if (*inclusiveLow == FALSE && *inclusiveHgh == FALSE)
                CRKcrackUnorderedThreeSideways_LO_RO_@1_@2(@5,*low,*hgh, @3, @4, &vl, &vh);
@

@= crkTwoRTreeIncrementalSideways
	if (@4==NULL) cl2=0;
        else cl2 = @4->indexLocal;
        if (@5==NULL) ch2=BATcount(@3)-1;
        else if (@5->localBound == FALSE) ch2=BATcount(@3)-1;
        else ch2 = @5->indexLocal;
        if (cl2>0) cl2+=1;
        /*CRACK in two pieces cl2-ch2 using <incHgh bound*/
        if (*inclusiveHgh == TRUE)
                CRKcrackUnorderedZeroSideways_LE_@1_@2(@3,*hgh, cl2, ch2,&vh);
        else
                CRKcrackUnorderedZeroSideways_RE_@1_@2(@3,*hgh, cl2, ch2,&vh);

        /*check for gaps*/
        if (vh < cl2)
                /*then the left piece is empty*/
                gapH = -1;
        if (vh > ch2){
                /*then the right piece is empty*/
                gapH = -1;
                vh--;
        }
@

@= crkTwoLTreeIncrementalSideways
	if (@4==NULL) cl1=0;
        else cl1 = @4->indexLocal;
        if (@5==NULL) ch1=BATcount(@3)-1;
        else if (@5->localBound == FALSE) ch1=BATcount(@3)-1;
        else ch1 = @5->indexLocal;
        if (cl1>0) cl1+=1;

        /*CRACK in two pieces cl1-ch1 using >incLow bound*/
        if (*inclusiveLow == TRUE)
                CRKcrackUnorderedZeroSideways_RE_@1_@2(@3,*low, cl1, ch1,&vl);
        else
                CRKcrackUnorderedZeroSideways_LE_@1_@2(@3,*low, cl1, ch1,&vl);
        if (vl < cl1){
                /*then the left piece is empty*/
                gapL = -1;
        }
        if (vl > ch1){
                /*then the right piece is empty*/
                vl--;
                gapL = -1;
        }
        vl++; /* We need to take next position because the crack function always returns the last bun of the left piece.
                Instead we want the first bun of the right piece*/
@

@= crkTwoLTreeIncrementalSideways2
	if (@4==NULL) cl1=0;
        else cl1 = @4->indexLocal;
        if (@5==NULL) ch1=BATcount(@3)-1;
        else if (@5->localBound == FALSE) ch1=BATcount(@3)-1;
        else ch1 = @5->indexLocal;
        if (cl1>0) cl1+=1;

        /*CRACK in two pieces cl1-ch1 using >incLow bound*/
        if (inclusiveLow == TRUE)
                CRKcrackUnorderedZeroSideways_RE_@1_@2(@3,low, cl1, ch1,&vl);
        else
                CRKcrackUnorderedZeroSideways_LE_@1_@2(@3,low, cl1, ch1,&vl);
        if (vl < cl1){
                /*then the left piece is empty*/
                gapL = -1;
        }
        if (vl > ch1){
                /*then the right piece is empty*/
                vl--;
                gapL = -1;
        }
        vl++; /* We need to take next position because the crack function always returns the last bun of the left piece.
                Instead we want the first bun of the right piece*/
@

@= SyncOperation
lng
SyncPiece_@1_@2(int m, BAT * b, struct Node * cur, int CBindex, int tailBatId, bit force){
	BAT *h,*c;
	@1 *hhead;
	bit *htail;
	oid syncs;
	oid size;
	struct Node *localNodeLow1=NULL, *localNodeHgh1=NULL;

        oid vl=0, _vl;
        oid cl1, ch1, base ;
        bit foundLow=0;
        int gapL = 1;
	bit inclusiveLow;
	@1 low;
	oid j;
	oid cursor;

	if (cur->tape==-1)
		return 0;

        if ((h = BATdescriptor(cur->tape)) == NULL) 
		return -1;

	/* check if the current pair is already synced */	
	cursor = getTapeCursor(cur,tailBatId);

	if (force)
		size = BATcount(h);
	else
		size = getMaxTapeCursorForRefsInCurrentQuery(cur,CBindex);

	if (cursor >= size){
		BBPunfix(h->batCacheid);
		return 0;
	}
	 /* Take the index of the bat */
        if ((c = BATdescriptor(CrackerIndex[m].cid)) == NULL)
		return -1;

	syncs = size - cursor;

	hhead = (@1*)Hloc(h, BUNfirst(h)+cursor);
	htail = (bit*)Tloc(h, BUNfirst(h)+cursor);

	base = cur->indexLocal;
	for (j=0; j<syncs; j++){
		low 	     = *hhead;
                inclusiveLow = *htail;
		
		if (cursor != 0) /* if the first time the cursor is 0 then just go on with cracking */
        	        foundLow = GetLowNodes_@1(low, inclusiveLow, CrackerIndex[m].Tree, c, BUNfirst(c), &localNodeLow1, &localNodeHgh1, NULL,NULL);      
		else cursor++;

                if (foundLow == 0){
                	@:crkTwoLTreeIncrementalSideways2(@1,@2,b,localNodeLow1,localNodeHgh1)@
                        if (vl>0) _vl=vl-1; else _vl=vl;
                        if (gapL>0) addCrackerIndexIncrementalSideways_@1(m,low,inclusiveLow,_vl,_vl+base+1,c,TRUE,FALSE,b->batCacheid);
                }

		hhead ++;
		htail ++;
	}		
	
	increaseLocalCursor(cur,tailBatId,syncs);

	BBPunfix(h->batCacheid);
	BBPunfix(c->batCacheid);
	return syncs;
}
@

@= TapeOperations
str
AddToTapeIncrementalSideways_@1(struct Node *node, @1 value, bit inclusive){
	BAT *h,*tape = NULL;
	bit madeNewTape=FALSE;

	if (node->tape == -1)
		madeNewTape = TRUE;
	else
	if ((tape = BATdescriptor(node->tape)) == NULL) 
                throw(MAL, "crackers.sync", "Cannot access descriptor");

	h = BATnew(TYPE_@1,TYPE_bit,1); 
        *(@1 *)Hloc(h, BUNfirst(h)) = value;
        *(bit*)Tloc(h, BUNfirst(h)) = inclusive;
        BATsetcount(h, 1);
	
	if (madeNewTape==FALSE){
		BATins(tape,h,TRUE);
		BBPunfix(h->batCacheid);
		BBPunfix(tape->batCacheid);
	}
	else{ 
		BATmode(h,PERSISTENT);
		h->batRestricted= BAT_WRITE;

		node->tape = h->batCacheid;
	        BBPkeepref(h->batCacheid);
	}
        return MAL_SUCCEED;
}
@

@= CreateCrackerBAT
{
		BAT *bo;
                oid sizeB;
                @1  *ctail, *ntail;
		oid *nhead;
		oid j;
                if ((bo = BATdescriptor(*bid)) == NULL)
                        throw(MAL, "crackers.crackRange", "Cannot access descriptor");

                sizeB = BATcount(bo);
		b = BATnew(TYPE_oid, bo->ttype, sizeB);

                nhead = (oid*)Hloc(b,  BUNfirst(b));
                ntail = (@1*)Tloc(b,  BUNfirst(b));
                ctail = (@1*)Tloc(bo, BUNfirst(bo));
                for(j=0;j<sizeB;j++){
                        *nhead = (oid)j;
                        *ntail = *ctail;
                        nhead++;
                        ntail++;
                        ctail++;
                }

                b->hsorted = FALSE;
                b->tsorted = FALSE;
                b->hdense = FALSE;
                b->tdense = FALSE;
                /*BATkey(b,TRUE);*/
                BATkey(BATmirror(b),FALSE);
                b->batRestricted= BAT_READ;
                BATmode(b,PERSISTENT);
	
        	BATsetcount(b, sizeB);

		c = BATnew(TYPE_oid, TYPE_@1, IndexEntries);	/* TODO: size */
                m = newCrackerIndexSideways_@1(*bid, b->batCacheid,-1, c->batCacheid);

                bo->batRestricted= BAT_READ;
                BBPunfix(bo->batCacheid);

	if (StorageInfo == NULL){
		StorageInfo = (struct storageManagement *)GDKmalloc(sizeof(struct storageManagement));
		StorageInfo->nextMapSet = NULL;
		StorageInfo->totalTuples = 0;
		StorageInfo->threshold = 0;
		StorageInfo->setThreshold = FALSE;
	}

}
@

@= EnrichMaxTailResultIncrementalSideways
	size+=@5;
	if (pairt==NULL)	
		throw(MAL,"pcrack", "Unexpected error during max. Empty input.");
	if (BATcount(p) == 0){
		*maxt = *pairt;
		j = 1;
	        BATsetcount(p, 1);
	}else
		j = 0;
	
        for (j = j; j<@5; j++){
		if (@3_GT(pairt,maxt,@4@2))
			*maxt = *pairt;	
		pairt  ++;
	}
	if(piece==NULL)
		throw(MAL,"pcrack", "Unexpected error. Cur piece is NULL.");
	if (newPiece)
		BBPkeepref(piece->batCacheid);		
	else
		BBPunfix(piece->batCacheid);		
	newPiece = FALSE;
@

@= analyzeTailConjunction
 
        for (j = 0; j<@6; j++){
                if (@2_@4(pairt,low2,@3@1) && @2_@5(pairt,hgh2,@3@1))
                        *pivott = (bit)TRUE;
                else
                        *pivott = (bit)FALSE;

                pairt  ++;
                pivott ++;
        }
@	

@= EnrichConjunctiveResultIncrementalSideways

	size+=@5;

	if (*inclusiveLow2==TRUE && *inclusiveHgh2==TRUE){
		@:analyzeTailConjunction(@2,@3,@4,GE,LE,@5)@	
	}
	if (*inclusiveLow2==FALSE && *inclusiveHgh2==TRUE){
		@:analyzeTailConjunction(@2,@3,@4,GT,LE,@5)@	
	}
	if (*inclusiveLow2==TRUE && *inclusiveHgh2==FALSE){
		@:analyzeTailConjunction(@2,@3,@4,GE,LT,@5)@	
	}
	if (*inclusiveLow2==FALSE && *inclusiveHgh2==FALSE){
		@:analyzeTailConjunction(@2,@3,@4,GT,LT,@5)@	
	}
	if(piece==NULL)
		throw(MAL,"pcrack", "Unexpected error. Cur piece is NULL.");
	if (newPiece)
		BBPkeepref(piece->batCacheid);		
	else
		BBPunfix(piece->batCacheid);		
	newPiece = FALSE;
@

@= analyzeTailConjunctionPivot
 
        for (j = 0; j<@6; j++){
		if (*pivott == (bit)TRUE){
	                if ((@2_@4(pairt,low2,@3@1) && @2_@5(pairt,hgh2,@3@1)) == FALSE){
        	                *pivott = (bit)FALSE;
			}
		}
                pairt  ++;
                pivott ++;
        }
@	

@= EnrichConjunctivePivotResultIncrementalSideways

	size+=@5;

	if (*inclusiveLow2==TRUE && *inclusiveHgh2==TRUE){
		@:analyzeTailConjunctionPivot(@2,@3,@4,GE,LE,@5)@	
	}
	if (*inclusiveLow2==FALSE && *inclusiveHgh2==TRUE){
		@:analyzeTailConjunctionPivot(@2,@3,@4,GT,LE,@5)@	
	}
	if (*inclusiveLow2==TRUE && *inclusiveHgh2==FALSE){
		@:analyzeTailConjunctionPivot(@2,@3,@4,GE,LT,@5)@	
	}
	if (*inclusiveLow2==FALSE && *inclusiveHgh2==FALSE){
		@:analyzeTailConjunctionPivot(@2,@3,@4,GT,LT,@5)@	
	}

	if(piece==NULL)
		throw(MAL,"pcrack", "Unexpected error. Cur piece is NULL.");
	if (newPiece)
		BBPkeepref(piece->batCacheid);		
	else
		BBPunfix(piece->batCacheid);		
	newPiece = FALSE;
@

@= EnrichProjectionResultIncrementalSideways

	size+=@5;
	for (j = 0; j<@5; j++){
		*(@2*)pivott = *(@2*)pairt;
	 	pairt  ++;
                pivott ++;

	} 
	if(piece==NULL)
		throw(MAL,"pcrack", "Unexpected error in projection. Cur piece is NULL.");
	if (newPiece)
		BBPkeepref(piece->batCacheid);		
	else
		BBPunfix(piece->batCacheid);		
	newPiece = FALSE;
@

@= EnrichProjectionPivotResultIncrementalSideways
	for (j = 0; j<@5; j++){
		if (*pivott == (bit)TRUE){
			*rest = *pairt;
			size++;
			rest ++;
		}
	 	pairt  ++;
                pivott ++;

	} 
	if(piece==NULL)
		throw(MAL,"pcrack", "Unexpected error. Cur piece is NULL.");
	if (newPiece)
		BBPkeepref(piece->batCacheid);		
	else
		BBPunfix(piece->batCacheid);		
	newPiece = FALSE;
@

@= analyzeTailDisjunction
 
        for (j = 0; j<vl; j++){
                if (@2_@4(pairt,low2,@3@1) && @2_@5(pairt,hgh2,@3@1))
                        *pivott = (bit)TRUE;
                else
                        *pivott = (bit)FALSE;

                pairt  ++;
                pivott ++;
        }
	
        for (j = vl; j<=vh; j++){
                *pivott = (bit)TRUE;

                pairt  ++;
                pivott ++;
        }

	for (j = vh+1; j<size; j++){
                if (@2_@4(pairt,low2,@3@1) && @2_@5(pairt,hgh2,@3@1))
                        *pivott = (bit)TRUE;
                else
                        *pivott = (bit)FALSE;

                pairt  ++;
                pivott ++;
        }
@

@= CrackPieceb
		if (crkTwoLTree || crkThreeTree ){
			if (crkTwoLTree){
				@:crkTwoLTreeIncrementalSideways(@1,@2,piece,localNodeLow1,localNodeHgh1)@
			}
			if (vl>0)_vl=vl-1; else _vl=vl;
                        if (gapL>0)  addCrackerIndexIncrementalSideways_@1(h,*low,*inclusiveLow,_vl,_vl+base+1,cm,TRUE,FALSE,piece->batCacheid);
			AddToTapeIncrementalSideways_@1(nodeLow1, *low, *inclusiveLow);
			increaseLocalCursor(nodeLow1,*pbid,2);
		}
		if( crkTwoRTree || crkThreeTree){
			if (crkTwoRTree){
				@:crkTwoRTreeIncrementalSideways(@1,@2,piece,localNodeLow2,localNodeHgh2)@
			}
			if (gapH>0)  addCrackerIndexIncrementalSideways_@1(h,*hgh,HBound,vh,vh+base+1,cm,TRUE,FALSE,piece->batCacheid);
			AddToTapeIncrementalSideways_@1(nodeLow1, *hgh, HBound);
			increaseLocalCursor(nodeLow1,*pbid,1);
		}	
@

@= CrackPiece
	crkTwoLTree = crkTwoRTree = crkThreeTree = FALSE;
	if (localNodeLow1==NULL) cl1=0;
	else cl1 = localNodeLow1->indexLocal;
        if (localNodeHgh1==NULL) ch1=BATcount(piece)-1;
        else if (localNodeHgh1->localBound == FALSE) ch1=BATcount(piece)-1;
        else ch1 = localNodeHgh1->indexLocal;
        if (cl1>0) cl1+=1;
	if (localNodeLow2==NULL) cl2=0;
        else cl2 = localNodeLow2->indexLocal;
        if (localNodeHgh2==NULL) ch2=BATcount(piece)-1;
        else if (localNodeHgh2->localBound == FALSE) ch2=BATcount(piece)-1;
        else ch2 = localNodeHgh2->indexLocal;
        if (cl2>0) cl2+=1;
        /* If one or both of the selection bounds were not found, then we have to crack */
	if (foundLow == 0 && foundHgh == 0){                         
		if (cl1 == cl2){
			@:crkThreeTreeIncrementalSideways(@1,@2,cl1,ch2,piece)@
			crkThreeTree = TRUE;
		} else 
			crkTwoLTree = crkTwoRTree = TRUE;
		@:CrackPieceb(@1,@2)@
	} else
	if (foundLow == 0){
		crkTwoLTree = TRUE;
		vh = ch2;
		@:CrackPieceb(@1,@2)@
	} else
	if (foundHgh == 0){
		crkTwoRTree = TRUE;
		vl = cl1;
		@:CrackPieceb(@1,@2)@
        } else {
                vl = cl1;
                vh = ch2;
        }

@

@= SyncAndCrackBasedonFirstBound
                syncs=SyncPiece_@1_@2(h, piece, nodeLow1, m, *pbid, FALSE);
		if (syncs<0)
			throw(MAL,"pcrack", "Failed to access cracker index or tape during syncing.");

		foundLow = GetLowNodes_@1(*low, *inclusiveLow, CrackerIndex[h].Tree, cm, BUNfirst(cm), &localNodeLow1, &localNodeHgh1, NULL, NULL);

        	if (foundLow == 0){
			syncs=SyncPiece_@1_@2(h, piece, nodeLow1, m, *pbid, TRUE);
			if (syncs<0)
				throw(MAL,"pcrack", "Failed to access cracker index or tape during syncing.");
                	if (syncs>0)
        			foundLow = GetLowNodes_@1(*low, *inclusiveLow, CrackerIndex[h].Tree, cm, BUNfirst(cm), &localNodeLow1, &localNodeHgh1, NULL, NULL);
		}
		foundHgh = 1;
		base = nodeLow1->indexLocal;
		CrackPiece = SyncAndCrackBasedonFirstBound = TRUE;
@

@= SyncAndCrackBasedonFirstBoundLastPart
        	pairt = (@2*)Tloc(piece, BUNfirst(piece)+vl);
		tuplesToAnalyze = BATcount(piece) - vl;
		SyncAndCrackBasedonFirstBound = CrackPiece = FALSE;
@

@= SyncAndCrackBasedonLastBound
		syncs=SyncPiece_@1_@2(h, piece, nodeLow1, m, *pbid, FALSE);
		if (syncs<0)
			throw(MAL,"pcrack", "Failed to access cracker index or tape during syncing.");

		/* if the high bound falls in here we crack this piece */
		if ( (*(@1*)Tloc(c, BUNfirst(c)+nodeHgh1->position)) > *hgh || 
			((*(@1*)Tloc(c, BUNfirst(c)+nodeHgh1->position)) == *hgh && 
								nodeHgh1->inclusive == HBound) ){
			foundHgh = GetHghNodes_@1(*hgh, *inclusiveHgh, CrackerIndex[h].Tree, cm, BUNfirst(cm), &localNodeLow2, &localNodeHgh2, NULL, NULL);

        		if (foundHgh == 0){
				syncs = SyncPiece_@1_@2(h, piece, nodeLow1, m, *pbid, TRUE);
				if (syncs<0)
					throw(MAL,"pcrack", "Failed to access cracker index or tape during syncing.");
		                if (syncs > 0)
	        			foundHgh = GetHghNodes_@1(*hgh, *inclusiveHgh, CrackerIndex[h].Tree, cm, BUNfirst(cm), &localNodeLow2, &localNodeHgh2, NULL, NULL);
			}

			foundLow = 1;
			base = nodeLow1->indexLocal;
			CrackPiece = SyncAndCrackBasedonLastBound =  TRUE;
			done = TRUE;
		}else{
			tuplesToAnalyze = BATcount(piece);
        		pairt = (@2*)Tloc(piece, BUNfirst(piece));
		}
@

@= SyncAndCrackBasedonLastBoundLastPart
		tuplesToAnalyze = vh + 1;
        	pairt = (@2*)Tloc(piece, BUNfirst(piece));
		SyncAndCrackBasedonLastBound =  CrackPiece = FALSE;
@

@= SyncAndCrackBasedonBothBounds
		syncs=SyncPiece_@1_@2(h, piece, nodeLow1, m, *pbid, FALSE);
		if (syncs<0)
			throw(MAL,"pcrack", "Failed to access cracker index or tape during syncing.");

		/* get the new node after the sync */
        	foundLow = GetLowNodes_@1(*low, *inclusiveLow, CrackerIndex[h].Tree, cm, BUNfirst(cm), &localNodeLow1, &localNodeHgh1, NULL, NULL);
		foundHgh = GetHghNodes_@1(*hgh, *inclusiveHgh, CrackerIndex[h].Tree, cm, BUNfirst(cm), &localNodeLow2, &localNodeHgh2, NULL, NULL);

		if (foundLow == 0 || foundHgh == 0){
			syncs=SyncPiece_@1_@2(h, piece, nodeLow1, m, *pbid, TRUE);
			if (syncs<0)
				throw(MAL,"pcrack", "Failed to access cracker index or tape during syncing.");
		        if (syncs > 0 ){
	        		foundLow = GetLowNodes_@1(*low, *inclusiveLow, CrackerIndex[h].Tree, cm, BUNfirst(cm), &localNodeLow1, &localNodeHgh1, NULL, NULL);
				foundHgh = GetHghNodes_@1(*hgh, *inclusiveHgh, CrackerIndex[h].Tree, cm, BUNfirst(cm), &localNodeLow2, &localNodeHgh2, NULL, NULL);
			}
		}
		base = nodeLow1->indexLocal;
		CrackPiece = SyncAndCrackBasedonBothBounds = TRUE;
@

@= SyncAndCrackBasedonBothBoundsLastPart
		tuplesToAnalyze = vh-vl+1;
                pairt = (@2*)Tloc(piece, BUNfirst(piece)+vl);
		CrackPiece = SyncAndCrackBasedonBothBounds = FALSE;
@

@= makeNewMapPiece1
		/*printStorageInfo(); can be used to what is in the Storage management structure */
			piece = createPieceMap_@1_@2(b, tailBAT, nodeLow1, nodeHgh1, m);
			if (piece==NULL)
				throw(MAL,"pcracking","Failed to create map piece");
			newPiece = TRUE;
			
	   		localFirst = addCrackerIndexIncrementalSideways_@1(h, *(@1*)Tloc(c, BUNfirst(c)+nodeLow1->position), nodeLow1->inclusive, 0, nodeLow1->indexLocal, cm, FALSE, TRUE, piece->batCacheid);
	        	curPieceNodeLast = addCrackerIndexIncrementalSideways_@1(h, *(@1*)Tloc(c, BUNfirst(c)+nodeHgh1->position), nodeHgh1->inclusive, BATcount(piece)-1, nodeHgh1->indexLocal, cm, FALSE, FALSE, piece->batCacheid);
			registerPieceForStorageManagement(*bid, *pbid, localFirst, nodeHgh1->indexLocal - nodeLow1->indexLocal);
@

@= makeNewMapPiece2
			piece = createPieceMap_@1_@2(b, tailBAT, nodeLow1, nodeHgh1, m);
			if (piece==NULL)
				throw(MAL,"pcracking","Failed to create map piece");
			newPiece = TRUE;
			localNodeLow1->first = TRUE;
			localNodeLow1->indexLocal = 0;
			localNodeLow1->pieceBAT = piece->batCacheid;

	        	localNodeHgh1 = addCrackerIndexIncrementalSideways_@1(h, *(@1*)Tloc(c, BUNfirst(c)+nodeHgh1->position), nodeHgh1->inclusive, BATcount(piece)-1, nodeHgh1->indexLocal, cm, FALSE, FALSE, piece->batCacheid);
			registerPieceForStorageManagement(*bid, *pbid, localNodeLow1, nodeHgh1->indexLocal - nodeLow1->indexLocal);
@

@= FirstBoundWithinAnExistingArea
		foundLow = GetLowNodes_@1(*low, *inclusiveLow, CrackerIndex[m].Tree, c, BUNfirst(c), &nodeLow1, &nodeHgh1, NULL, NULL);
		if ( (nodeLow1 == NULL) || 
		     (nodeLow1 != NULL && nodeLow1->first == FALSE) ){
			/* No existing piece for this area. Thus we have the freedom to crack it */
			if ( nodeLow1 != NULL && nodeLow1->first == FALSE && foundLow != 0)
				nodeLow1->first = TRUE;
			else{ 
				@:crkTwoLTree(@1,@2,b,nodeLow1,nodeHgh1)@
				if (vl>0) _vl=vl-1; else _vl=vl;
				if (gapL>0) nodeLow1 = addCrackerIndexIncrementalSideways_@1(m,*low,*inclusiveLow,_vl,_vl,c,TRUE,TRUE,-1);
			}
			@:makeNewMapPiece1(@1,@2)@

			tuplesToAnalyze = BATcount(piece);
        		pairt = (@2*)Tloc(piece, BUNfirst(piece));
		}else
		if (nodeLow1->first == TRUE){
			/* A previous query has already created a piece for this area */
			@:makeNewMapPiece1(@1,@2)@
			@:SyncAndCrackBasedonFirstBound(@1,@2)@
		}
                curCBatNodeLast = nodeHgh1;
@

@= LastBoundWithinAnExistingArea
		if (nodeLow1->first == TRUE){
			@:makeNewMapPiece2(@1,@2)@
			@:SyncAndCrackBasedonLastBound(@1,@2)@
		}else{
		   /* No previous piece here.
		   If the whole area is relevant simply make a new piece out of it
		   Otherwise crack the area and fetch only the relevant part */
				
			nodeLow1->first = TRUE;
			if ( (*(@1*)Tloc(c, BUNfirst(c)+nodeHgh1->position)) > *hgh || 
				((*(@1*)Tloc(c, BUNfirst(c)+nodeHgh1->position)) == *hgh && 
								nodeHgh1->inclusive == HBound) ){
				foundHgh = GetLowNodes_@1(*hgh, *inclusiveHgh, CrackerIndex[m].Tree, c, BUNfirst(c), &nodeLow1, &nodeHgh1, NULL, NULL);
				if (foundHgh==0){
					@:crkTwoRTree(@1,@2,b,nodeLow1,nodeHgh1)@
					if (gapH>0) nodeHgh1 = addCrackerIndexIncrementalSideways_@1(m,*hgh,HBound,vh,vh,c,TRUE,FALSE,-1);
				}
				done = TRUE;
			}
				
			@:makeNewMapPiece2(@1,@2)@
			tuplesToAnalyze = BATcount(piece);
			pairt = (@2*)Tloc(piece, BUNfirst(piece));
		}
@

@= BothBoundsWithinAnExistingArea
		foundLow = GetLowNodes_@1(*low, *inclusiveLow, CrackerIndex[m].Tree, c, BUNfirst(c), &nodeLow1, &nodeHgh1, NULL, NULL);
		foundHgh = GetHghNodes_@1(*hgh, *inclusiveHgh, CrackerIndex[m].Tree, c, BUNfirst(c), &nodeLow2, &nodeHgh2, NULL, NULL);

		crkTwoLTree = crkTwoRTree = crkThreeTree = FALSE;
		if (nodeLow1 == NULL && nodeLow2 == NULL) {
			if (foundHgh != 0)
				crkTwoLTree = TRUE;
			else{
                		posl = 0;
				if (nodeHgh1==NULL)
					throw(MAL,"pcrack", "Unexpected error. High node is NULL.");
			        posh = nodeHgh1->indexLocal;
				crkThreeTree = TRUE;
			}	
			done = TRUE;	
		}else
		if (nodeHgh1 == NULL && nodeHgh2 == NULL) {
			if (nodeLow1==NULL)
				throw(MAL,"pcrack", "Unexpected error. Low node is NULL.");
			if (foundLow != 0){
				nodeLow1->first = TRUE;
				crkTwoRTree = TRUE;
			}else{
                		posl = nodeLow1->indexLocal+1;
			        posh = BATcount(b)-1;
				crkThreeTree = TRUE;
			}	
			done = TRUE;	
		}else
		if (nodeLow1 == NULL)
			crkTwoLTree = TRUE;
		else	
		/* A previous query has already created a piece for this area */
		if (nodeLow1->first == TRUE){
			if (nodeHgh1==NULL)
				throw(MAL,"pcrack", "Unexpected error. High node is NULL.");

			@:makeNewMapPiece1(@1,@2)@

			/* if both in the new piece */
                	if ( (*(@1*)Tloc(c, BUNfirst(c)+nodeHgh1->position)) > *hgh ||
                        ((*(@1*)Tloc(c, BUNfirst(c)+nodeHgh1->position)) == *hgh && nodeHgh1->inclusive == HBound) ){
				@:SyncAndCrackBasedonBothBounds(@1,@2)@
				done = TRUE;	
			}else{
				@:SyncAndCrackBasedonFirstBound(@1,@2)@
			}
		}else {
			/* No existing piece for this area. Thus we have the freedom to crack it */

			/* Both in the same area */
			if (nodeLow1->indexLocal == nodeLow2->indexLocal){
			
				if (foundLow != 0 && foundHgh !=0)
					nodeLow1->first = TRUE;
				else 
				if (foundLow == 0 && foundHgh ==0){	
					if (nodeHgh1==NULL)
						throw(MAL,"pcrack", "Unexpected error. High node is NULL.");
                			posl = nodeLow1->indexLocal+1;
			                posh = nodeHgh1->indexLocal;
					crkThreeTree = TRUE;
				}
				else 
				if (foundLow != 0){
					nodeLow1->first = TRUE;
					crkTwoRTree = TRUE;
				}
				else
					crkTwoLTree = TRUE;
					
				done = TRUE;	
			}else{
				if (foundLow != 0)
        	                        nodeLow1->first = TRUE;
	                        else
					crkTwoLTree = TRUE;
			}
		}


		/* expand in the end to keep c code minimum */
		if (crkTwoLTree || crkTwoRTree || crkThreeTree){
			if (crkTwoLTree){
				@:crkTwoLTree(@1,@2,b,nodeLow1,nodeHgh1)@
				if (vl>0) _vl=vl-1; else _vl=vl;
				if (gapL>0) nodeLow1 = addCrackerIndexIncrementalSideways_@1(m,*low,*inclusiveLow,_vl,_vl,c,TRUE,TRUE,-1);
			}else 
			if (crkTwoRTree){
				@:crkTwoRTree(@1,@2,b,nodeLow1,nodeHgh1)@
				if (gapH>0) nodeHgh1 = addCrackerIndexIncrementalSideways_@1(m,*hgh,HBound,vh,vh,c,TRUE,FALSE,-1);
			}else
			if (crkThreeTree){
				@:crkThreeTree(@1,@2,posl,posh)@
			}
			@:makeNewMapPiece1(@1,@2)@

			tuplesToAnalyze = BATcount(piece);
			pairt = (@2*)Tloc(piece, BUNfirst(piece));
		}

		curCBatNodeLast = nodeHgh1;
@

@= IncrementalCrackingBasicBodyA
        BAT *b=NULL, *c=NULL, *cm=NULL, *tailBAT=NULL, *piece=NULL;
        int  m, h;
        oid vl=0, vh=0, posl=0, posh=0;
	struct Node *localNodeLow1=NULL,*localNodeLow2=NULL,*localNodeHgh1=NULL,*localNodeHgh2=NULL, 
			*nodeLow1=NULL,*nodeHgh1=NULL, *nodeLow2=NULL,*nodeHgh2=NULL, *localFirst=NULL; 
	struct Node *curCBatNodeLast=NULL, *curPieceNodeLast=NULL;
	oid cl1=0, ch1=0, cl2=0, ch2=0;
        oid _vl=0;
        int gapL = 1, gapH = 1;
        bit HBound, foundLow=0, foundHgh=0, done=FALSE;
        BAT *p;     
        bit *pivott;        
	oid size=0;
	@2 *pairt=NULL;
	oid j=0, tuplesToAnalyze=0, base=0;
	bit newMapSet = FALSE;
	bit newMap = FALSE;
	bit newPiece = FALSE;
	bit BothBoundsWithinAnExistingArea = FALSE;
	bit FirstBoundWithinAnExistingArea = FALSE;
	bit LastBoundWithinAnExistingArea = FALSE;
	bit AnalyzeRemainingPiece	  = FALSE;
	bit crkTwoLTree, crkTwoRTree, crkThreeTree;	
	bit CrackPiece = FALSE, SyncAndCrackBasedonFirstBound = FALSE, SyncAndCrackBasedonBothBounds = FALSE, SyncAndCrackBasedonLastBound = FALSE;
	lng syncs=0;

        if (@3_GT(low,hgh,@4@1))
                throw(MAL, "crackers.crack", "illegal range");


        if ((tailBAT = BATdescriptor(*pbid)) == NULL)
	        throw(MAL, "crackers.crackRange", "Cannot access crack index");
@

@= IncrementalCrackingBasicBodyB

	pivott = (bit*)Tloc(p, BUNfirst(p));

        if (*inclusiveHgh == TRUE) HBound = FALSE;
        else    HBound = TRUE;

	/* Get the cracker bat */
        m = existsCrackerIndexSideways(*bid,-1);

        /* If the cracker bat does not exist, then this is the first operation on this map set
	   We will create the cracker bat and the appropriate map 
	   This first select will be done by cracking the whole cracker BAT */
        if (m == -1){
		newMapSet = TRUE;
		newMap = TRUE;
		@:CreateCrackerBAT(@1)@		

                posl = BUNfirst(b);
                posh = BUNlast(b)-1;
                @:crkThreeTree(@1,@2,posl,posh)@
		
		cm = BATnew(TYPE_oid, TYPE_@1, IndexEntries);
                h = newCrackerIndexSideways_@1(*bid, -1, *pbid, cm->batCacheid);

		@:makeNewMapPiece1(@1,@2)@

		tuplesToAnalyze = BATcount(piece);
        	pairt = (@2*)Tloc(piece, BUNfirst(piece));
		AnalyzeRemainingPiece = TRUE;
		done = TRUE;
		goto end;
        }

	/* Get the map */
        h = existsCrackerIndexSideways(*bid, *pbid);
	if (h == -1){
		newMap = TRUE;
		cm = BATnew(TYPE_oid, TYPE_@1, IndexEntries);	
                h  = newCrackerIndexSideways_@1(*bid, -1, *pbid, cm->batCacheid);
	}
	
	/* If the map does not exist then we need to create the map, sync it and crack it
	   We have to fetch from the cracker bat all the pieces that are relevant with the current query q
	   Then we need to sync these pieces and crack based on q */

	/* If the map exists then we need to fetch any missing pieces necessary for the current query,
	   sync all relevant pieces and crack */
        
        /* Take the index of the cracker BAT */
        if ((c = BATdescriptor(CrackerIndex[m].cid)) == NULL)
                throw(MAL, "crackers.crackRange", "Cannot access crack index");
        
        /* Take the index of the cracker map */
	if (cm == NULL) /* if h was -1 then we get a new map */	
        if ((cm = BATdescriptor(CrackerIndex[h].cid)) == NULL)
                throw(MAL, "crackers.crackRange", "Cannot access crack index");
        
        /* Take the cracker BAT */
        if ((b = BATdescriptor(CrackerIndex[m].cbid)) == NULL)
                throw(MAL, "crackers.crackRange", "Cannot access crack index");

        /* find out where in the index the low falls */
        foundLow = GetLowNodes_@1(*low, *inclusiveLow, CrackerIndex[h].Tree, cm, BUNfirst(cm), &localNodeLow1, &localNodeHgh1, NULL, NULL);
        
        /* find out where in the index the high falls */        
	foundHgh = GetHghNodes_@1(*hgh, *inclusiveHgh, CrackerIndex[h].Tree, cm, BUNfirst(cm), &localNodeLow2, &localNodeHgh2, NULL, NULL);

	/*If this map is new but previous maps existed in this map set then CrackerIndex[h].Tree=NULL 
	  Then the above calls set all localNodes* to NULL*/

	if (localNodeLow1 != NULL && localNodeHgh1 != NULL && localNodeLow2 != NULL && localNodeHgh2 != NULL){
		/* The whole result falls within a single existing piece of the map */       
		if ((localNodeLow1->pieceBAT == localNodeLow2->pieceBAT  && 
				localNodeLow1->pieceBAT == localNodeHgh1->pieceBAT &&
					localNodeLow1->pieceBAT == localNodeHgh2->pieceBAT) ||

	   	    ( (localNodeLow1->pieceBAT == localNodeLow2->pieceBAT) && 
			(localNodeHgh2->first == TRUE) &&
			!(localNodeLow1->localBound == FALSE && localNodeLow1->first == FALSE) &&
			!(localNodeLow2->localBound == FALSE && localNodeLow2->first == FALSE)) ){ 
			
        		GetLowNodes_@1(*low, *inclusiveLow, CrackerIndex[m].Tree, c, BUNfirst(c), &nodeLow1, &nodeHgh1, NULL, NULL);		

			if ((piece = BATdescriptor(localNodeLow1->pieceBAT)) == NULL)
	                	throw(MAL, "crackers.crackRange", "Cannot access crack index");
			
			/* register this piece access */
			localFirst = getPreviousNonLocalNode(localNodeLow1);
			localFirst->accesses+=1;	

			@:SyncAndCrackBasedonBothBounds(@1,@2)@	
			AnalyzeRemainingPiece = TRUE;
			done = TRUE;
			goto end;
		}
	} 

	if (localNodeLow1 != NULL && localNodeHgh1 != NULL){
		/* First bound falls within an existing piece. We are going to sync and crack this piece */
		if ( (localNodeLow1->pieceBAT == localNodeHgh1->pieceBAT) ||  
		     (localNodeHgh1->localBound == FALSE && 
			!(localNodeLow1->localBound == FALSE && localNodeLow1->first == FALSE)) ){

                	GetLowNodes_@1(*low, *inclusiveLow, CrackerIndex[m].Tree, c, BUNfirst(c), &nodeLow1, &nodeHgh1, NULL, NULL);

	                if ((piece = BATdescriptor(localNodeLow1->pieceBAT)) == NULL)
        	                throw(MAL, "crackers.crackRange", "Cannot access crack index");

			/* register this piece access */
			localFirst = getPreviousNonLocalNode(localNodeLow1);
			localFirst->accesses+=1;	

			@:SyncAndCrackBasedonFirstBound(@1,@2)@
			AnalyzeRemainingPiece = TRUE;
	
			curCBatNodeLast  = nodeHgh1;
			curPieceNodeLast = getNextNonLocalNode(localNodeHgh1);
		} else 
		if (localNodeLow1->localBound == FALSE && localNodeLow1->first == FALSE){
			if (localNodeLow2==NULL)	
				throw(MAL,"pcrack", "Unexpected error. Low node is NULL.");
			if (*(oid*)Hloc(cm,BUNfirst(cm)+localNodeLow1->position) == *(oid*)Hloc(cm,BUNfirst(cm)+localNodeLow2->position))
				/* Both bounds fall within a non materialized area of the map */
				BothBoundsWithinAnExistingArea=TRUE;
			else
				/* The first bound falls within a non materialized area of the map */
				FirstBoundWithinAnExistingArea=TRUE;	
		}
	}

	/*NULL checks*/
	/*low1 && low2 are null -> both bounds fall within the non materialized area in the beggining of the map*/
	/*hgh1 && hgh2 are null -> both bounds fall within the non materialized area in the end of the map*/
	/*only first bound in the non materialized area in the beggining of the map*/
	if ( (localNodeLow1 == NULL && localNodeHgh1 == NULL && localNodeLow2 == NULL && localNodeHgh2 == NULL) ||
	     (localNodeLow1 == NULL && localNodeLow2 == NULL) ||
	     (localNodeHgh1 == NULL && localNodeHgh2 == NULL) )
		BothBoundsWithinAnExistingArea=TRUE;
	else
	if (localNodeLow1 == NULL)
		/*only first bound in the first piece*/
		FirstBoundWithinAnExistingArea=TRUE;	
	
	/* expand this code only once to avoid code explotion */
	if (BothBoundsWithinAnExistingArea){
		AnalyzeRemainingPiece = TRUE;
		@:BothBoundsWithinAnExistingArea(@1,@2,@3,@4,@5)@	
	} else
	if (FirstBoundWithinAnExistingArea){
		AnalyzeRemainingPiece = TRUE;
		@:FirstBoundWithinAnExistingArea(@1,@2,@3,@4,@5)@	
	}

	end:;

	/* expand this code only once to avoid code explotion */
	if (CrackPiece){
		@:CrackPiece(@1,@2)@
		if (SyncAndCrackBasedonFirstBound){
			@:SyncAndCrackBasedonFirstBoundLastPart(@1,@2)@
		}
		if (SyncAndCrackBasedonBothBounds){
			@:SyncAndCrackBasedonBothBoundsLastPart(@1,@2)@
		}
	}
	
	/* expand this code only once to avoid code explotion */
	if (AnalyzeRemainingPiece){
		@:Enrich@5ResultIncrementalSideways(@1,@2,@3,@4,tuplesToAnalyze)@
	}

	/* Now we go through the middle area and fetch any missing pieces. 
	   Each piece in this area needs to be synced if necessary and enrich the result
	   If the hgh bound falls in a piece then we also have to crack it */
	while(done == FALSE){
		if (curPieceNodeLast==NULL || curCBatNodeLast ==NULL)
			throw(MAL,"pcrack", "Unexpected error. Low node is NULL.");

		LastBoundWithinAnExistingArea = FALSE;
		localNodeLow1 = curPieceNodeLast;
		localNodeHgh1 = getNextNonLocalNode(findNextPiece(localNodeLow1));
		nodeLow1      = curCBatNodeLast;
		nodeHgh1      = findNextPiece(nodeLow1);

			
		if (localNodeHgh1==NULL){
			if (nodeHgh1 == NULL){
                                nodeLow1->first = TRUE;
                                @:crkTwoRTree(@1,@2,b,nodeLow1,nodeHgh1)@
                                if (gapH>0) nodeHgh1 = addCrackerIndexIncrementalSideways_@1(m,*hgh,HBound,vh,vh,c,TRUE,FALSE,-1);
                                @:makeNewMapPiece1(@1,@2)@

                                tuplesToAnalyze = BATcount(piece);
                                pairt = (@2*)Tloc(piece, BUNfirst(piece));
                                done=TRUE;
			}else
				LastBoundWithinAnExistingArea = TRUE;
		}else
		/* An already fetched piece starts from here */
		if (localNodeLow1->first == TRUE){
                	if ((piece = BATdescriptor(localNodeLow1->pieceBAT)) == NULL)
                        	throw(MAL, "crackers.crackRange", "Cannot access crack index");

			/* register this piece access */
			localNodeLow1->accesses+=1;	
		
			@:SyncAndCrackBasedonLastBound(@1,@2)@
		}else 
			LastBoundWithinAnExistingArea = TRUE;
		

		if (LastBoundWithinAnExistingArea){
			@:LastBoundWithinAnExistingArea(@1,@2,@3,@4,@5)@
		}

		if (CrackPiece){
			@:CrackPiece(@1,@2)@
			if (SyncAndCrackBasedonFirstBound){
				@:SyncAndCrackBasedonFirstBoundLastPart(@1,@2)@
			}
			if (SyncAndCrackBasedonBothBounds){
				@:SyncAndCrackBasedonBothBoundsLastPart(@1,@2)@
			}
			if (SyncAndCrackBasedonLastBound){
				@:SyncAndCrackBasedonLastBoundLastPart(@1,@2)@
			}
		}

		@:Enrich@5ResultIncrementalSideways(@1,@2,@3,@4,tuplesToAnalyze)@

		curCBatNodeLast  = nodeHgh1;
		curPieceNodeLast = localNodeHgh1;
	}


	if (newMap)
	        BBPkeepref(cm->batCacheid);
	else
        	BBPunfix(cm->batCacheid);

	if (newMapSet){
	        BBPkeepref(c->batCacheid);
	        BBPkeepref(b->batCacheid);
	}else{
		BBPunfix(c->batCacheid);
		BBPunfix(b->batCacheid);
	}
			
	BBPunfix(tailBAT->batCacheid);		
@

@= crackOperationsIncSideways
static str
CRKRangeIncrementalSideways_@1_@2(int *vid, int *bid, int *pbid, @1 *low, @1 *hgh, bit *inclusiveLow, bit *inclusiveHgh, @2 *low2, @2 *hgh2, bit *inclusiveLow2, bit *inclusiveHgh2){

	@:IncrementalCrackingBasicBodyA(@1,@2,@3,@4,Conjunctive)@	

        p = BATnew(TYPE_void,TYPE_bit,BATcount(tailBAT));

	@:IncrementalCrackingBasicBodyB(@1,@2,@3,@4,Conjunctive)@	

        BATsetcount(p, size);
	
        p->hsorted = FALSE;
        p->tsorted = FALSE;
        p->hdense = FALSE;
        p->tdense = FALSE;

        BBPkeepref(p->batCacheid);
        *vid = p->batCacheid;
        return MAL_SUCCEED;
}

static str
CRKRangeTailIncrementalSideways_@1_@2(int *vid, int *bid, int *pbid, @1 *low, @1 *hgh, bit *inclusiveLow, bit *inclusiveHgh){

	@:IncrementalCrackingBasicBodyA(@1,@2,@3,@4,Projection)@	

        p = BATnew(TYPE_void,TYPE_@2,BATcount(tailBAT));

	@:IncrementalCrackingBasicBodyB(@1,@2,@3,@4,Projection)@	

        BATsetcount(p, size);
	
        p->hsorted = FALSE;
        p->tsorted = FALSE;
        p->hdense = FALSE;
        p->tdense = FALSE;

        BBPkeepref(p->batCacheid);
        *vid = p->batCacheid;
        return MAL_SUCCEED;
}

static str
JoinSelectRangeIncrementalSideways_@1_@2(int *vid, int *bid, int *pbid, int *pivotid, @1 *low, @1 *hgh, bit *inclusiveLow, bit *inclusiveHgh, @2 *low2, @2 *hgh2, bit *inclusiveLow2, bit *inclusiveHgh2){

	@:IncrementalCrackingBasicBodyA(@1,@2,@3,@4,ConjunctivePivot)@	

	if ((p = BATdescriptor(*pivotid)) == NULL) 
                throw(MAL, "crackers.JoinSelectRangeIncrementalSideways", "Cannot access pivot");

	@:IncrementalCrackingBasicBodyB(@1,@2,@3,@4,ConjunctivePivot)@	

        BBPunfix(p->batCacheid);
        *vid = p->batCacheid;
        return MAL_SUCCEED;
}

static str
ProjectIncrementalSideways_@1_@2(int *vid, int *bid, int *pbid, int *pivotid, @1 *low, @1 *hgh, bit *inclusiveLow, bit *inclusiveHgh){

	BAT *res;
	@2 *rest;

	@:IncrementalCrackingBasicBodyA(@1,@2,@3,@4,ProjectionPivot)@	

	if ((p = BATdescriptor(*pivotid)) == NULL) 
                throw(MAL, "crackers.ProjectIncrementalSideways", "Cannot access pivot");
   
	res = BATnew(TYPE_void,TYPE_@2,BATcount(p));
	rest = (@2*)Tloc(res,BUNfirst(res));

	@:IncrementalCrackingBasicBodyB(@1,@2,@3,@4,ProjectionPivot)@	

        BATsetcount(res, size);
        res->hsorted = FALSE;
        res->tsorted = FALSE;
        res->hdense = FALSE;
        res->tdense = FALSE;
        BBPkeepref(res->batCacheid);
        *vid = res->batCacheid;

        BBPunfix(p->batCacheid);

        return MAL_SUCCEED;
}

static str
MaxTailIncrementalSideways_@1_@2(int *vid, int *bid, int *pbid, @1 *low, @1 *hgh, bit *inclusiveLow, bit *inclusiveHgh){

	@2 *maxt;
	@:IncrementalCrackingBasicBodyA(@1,@2,@3,@4,MaxTail)@	

	p = BATnew(TYPE_void,TYPE_@2,1);

	maxt = (@2*)Tloc(p, BUNfirst(p));

	@:IncrementalCrackingBasicBodyB(@1,@2,@3,@4,MaxTail)@	
	(void)pivott;

        p->hsorted = FALSE;
        p->tsorted = FALSE;
        p->hdense = FALSE;
        p->tdense = FALSE;

        BBPkeepref(p->batCacheid);
        *vid = p->batCacheid;

        return MAL_SUCCEED;
}
@

@}
