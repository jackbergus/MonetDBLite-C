# [ 1, 2, 3 ] -> transform {"value":$};
# [ 1, 2, 3 ] | as $ -> transform: '{"value":%s}' , $ => <result>


include json;

x := json.shred("[ 1, 2, 3 ]");
x1 := json.bind_kind(x);
x2 := json.bind_array(x);
ta := algebra.selectH(x1, 0@0);
o0 := algebra.semijoin(x2, ta);
o2 := bat.reverse(o0);
o3 := bat.mirror(o2);
o1 := algebra.fetchjoin(o3, x1);
# semantic: plain usage of array value ($)
x3 := json.bind_int(x);
o4 := algebra.semijoin(x3, o1);
# o4 holds the values for $ to be used in tuple reconstruction

# construct result by creating a new array
# let's assume for the moment we would parse the json_fragment and get a
# tree representation which also supports arithmetic and functions
# it means we have knowledge on how to construct the parts
#y := json.new();  # all but an empty array
#y := json.append("{ value: x }"); # add to end of outermost array

# observation:
# adding an entry to the outermost array (or any array/object) is as
# simple as adding to the array table with the right parent oid
# (outermost array should be 0@0)

x11 := bat.new(:oid,:chr); # kind
x12 := bat.new(:oid,:oid); # array
x13 := bat.new(:oid,:oid); # object
x14 := bat.new(:oid,:lng); # int
x15 := bat.new(:oid,:str); # name

n0 := 0@0;
bat.insert(x11, n0, 'a');
r0 := bat.reverse(x11);

# insert the values
n := aggr.max(r0);
n1 := n + 1:oid;
o5 := algebra.markH(o1, n1);
x11 := bat.insert(x11, o5);
o6 := algebra.markH(o4, n1);
x14 := bat.insert(x14, o6);

# for each value, an object is constructed (semantic)
n := aggr.max(r0);
n2 := n + 1:oid;
o7 := algebra.markH(o1, n2);
o8 := algebra.project(o7, 'o');
x11 := bat.insert(x11, o8);
x17 := bat.reverse(o8);
x18 := algebra.project(n0, x17);
x12 := bat.insert(x12, x18);
o9 := bat.mirror(o5);
o10 := algebra.markH(o9);
o12 := algebra.markT(o8);
o13 := algebra.join(o12, o10);
x13 := bat.insert(x13, o13);
o14 := algebra.project(o5, 0@0);
o15 := bat.new(:oid,:str);
o15 := bat.insert(o15, 0@0, "value"); # argument
o16 := algebra.join(o14, o15);
x15 := bat.insert(x15, o16);

# construct result by putting everything together
x10 := json.construct(x11, nil:bat, x14, nil:bat, x12, x13, x15);

out := io.stdout();
json.print(out, x);
json.print(out, x10);
