# [ {id:1, dept:1, income:12000},{id:2, dept:1, income:13000} ] -> filter $.dept == 1;
# [ {id:1, dept:1, income:12000},{id:2, dept:1, income:13000} ] as $ -> filter: $.dept == 1 => <result>
# j_json( [ {id:1, dept:1, income:12000},{id:2, dept:1, income:13000} ] ) j_filter( j_var( $ ) , j_pred( j_var( $. j_var( dept ) ) , == , 1 ) ) j_output()


include json;

# j_json( [ {id:1, dept:1, income:12000},{id:2, dept:2, income:13000} ] ) = x0
(x1,x2,x3,x4,x5,x6,x7) := json.shred("[ {\"id\":1, \"dept\":1, \"income\":12000},{\"id\":2, \"dept\":2, \"income\":13000} ]");

# j_var( $ ) over x0
o9 := algebra.selectH(x1, 0@0);
o0 := algebra.semijoin(x5, o9);
o2 := bat.reverse(o0);
o1 := algebra.semijoin(x1, o2);

# j_var( $. j_var( dept ) -- deref must be object
# (usage of var should be semantic check)
o4 := algebra.select(o1, 'o');
v0 := algebra.semijoin(x6, o4);
v1 := bat.reverse(v0);
n0 := algebra.semijoin(x7, v1);
n1 := algebra.uselect(n0, "dept");
n2 := algebra.semijoin(v1, n1);
v2 := bat.reverse(n2);  # ids from elems that have matching "dept"

# j_pred( n1 , == , 1 )
# semantic: we request 1 (int), so only look in integers, probably too
# limited
i0 := algebra.semijoin(x3, n1);
i1 := algebra.uselect(i0, 1:lng);  # argument
n3 := algebra.semijoin(v1, i1);
v3 := bat.reverse(n3);  # ids from elems that have matching "dept == 1"

# j_filter( o1 , i1 ) = x9
# filter operates on object here, so can simply remove all objects that
# don't match from the array
o5 := bat.reverse(o0);
o6 := algebra.kdifference(o5, v3);
o7 := bat.reverse(o6);
o8 := algebra.difference(x5, o7);
# construct result by replacing the original x5 with o8
x5 := o8;

# j_output()
out := io.stdout();
json.print(out, x1,x2,x3,x4,x5,x6,x7);
