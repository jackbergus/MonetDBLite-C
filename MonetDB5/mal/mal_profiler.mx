@/
The contents of this file are subject to the MonetDB Public License
Version 1.1 (the "License"); you may not use this file except in
compliance with the License. You may obtain a copy of the License at
http://www.monetdb.org/Legal/MonetDBLicense

Software distributed under the License is distributed on an "AS IS"
basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations
under the License.

The Original Code is the MonetDB Database System.

The Initial Developer of the Original Code is CWI.
Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
Copyright August 2008-2011 MonetDB B.V.
All Rights Reserved.
@

@c
/*
 * @a M. Kersten
 * @v 0.0
 * @* The MAL Profiler
 * A key issue in the road towards a high performance implementation
 * is to understand where resources are being spent. This information
 * can be obtained using different tools and at different levels of
 * abstraction.
 * A coarse grain insight for a particular application can be obtained
 * using injection of the necessary performance
 * capturing statements in the instruction sequence.
 * Fine-grain, platform specific information can be obtained using
 * existing profilers, like valgrind (http://www.valgrind.org),
 * or hardware performance counters.
 *
 * The MAL profiler collects detailed performance information, such
 * as cpu, memory and statement information. It is optionally extended
 * with IO activity, which is needed for coarse grain profiling only,
 * and estimated bytes read/written by an instruction.
 *
 * The execution profiler is supported by hooks in the MAL interpreter.
 * The default strategy is to ship an event record immediately over a stream
 * to a separate performance monitor, formatted as a tuple.
 * An alternative strategy is preparation for off-line performance analysis.
 *
 * Reflective performance analysis is supported by an event cache,
 * the event log becomes available as a series of BATs.
 * @menu
 * * Event Filtering ::
 * * Event Caching::
 * @end menu
 *
 * @node Event Filtering, Event Caching, The MAL Profiler, The MAL Profiler
 * @+ Event Filtering
 * The profiler supports selective retrieval of performance information by
 * tagging the instructions of interest. This means that a profiler
 * call has a global effect,
 * all concurrent users are affected by the performance overhead.
 * Therefore, it is of primary interest to single user sessions.
 *
 * The example below illustrates how the different performance
 * counter groups are activated, instructions are filtered for
 * tracking, and where the profile information is retained for
 * a posteriori analysis.
 * @example
 * #profiler.activate("event");
 * #profiler.activate("pc");
 * profiler.activate("time,ticks");
 * profiler.activate("stmt");
 * #profiler.activate("type");
 * #profiler.activate("cpu");
 * #profiler.activate("memory");
 * #profiler.activate("reads");
 * #profiler.activate("writes");
 * #profiler.activate("obytes");
 * #profiler.activate("wbytes");
 * #profiler.activate("user");
 * profiler.setFilter("*","insert");
 * profiler.setFilter("*","print");
 *
 * profiler.openStream("/tmp/MonetDBevents");
 * profiler.start();
 * b:= bbp.new(:int,:int);
 * bat.insert(b,1,15);
 * bat.insert(b,2,4);
 * bat.insert(b,3,9);
 * io.print(b);
 * profiler.stop();
 * profiler.closeStream();
 * @end example
 *
 * In this example, we are interested in all functions name @sc{insert} and @sc{print}.
 * A wildcard can be used to signify any name, e.g.
 * no constraints are put on the module in which the operations
 * are defined.
 * Several profiler components are ignored, shown by commenting
 * out the code line.
 *
 * Execution of the sample leads to the creation of a file with
 * the following content. The ticks are measured in micro-seconds.
 *
 * @verbatim
 * # time, ticks,  stmt  # name
 * [ "15:17:56",   12,   "_27 := bat.insert(<tmp_15>{3},1,15);" ]
 * [ "15:17:56",   2,    "_30 := bat.insert(<tmp_15>{3},2,4);"  ]
 * [ "15:17:56",   2,    "_33 := bat.insert(<tmp_15>{3},3,9);"  ]
 * [ "15:17:56",   245,  "_36 := io.print(<tmp_15>{3});",   ]
 * @end verbatim
 *
 * @node Event Caching, The MAL Modules, Event Filtering, The MAL Profiler
 * @+ Event Caching
 * Aside from shipping events to a separate process, the profiler
 * can keep the events in a local @sc{bat} group.
 * It is the default when no target file has been opened
 * to collect the information.
 *
 * Ofcourse, every measurement scheme does not come for free and may
 * even obscure performance measurements obtained through e.g. valgrind.
 * The separate event caches can be accessed using the
 * operator @sc{profiler.getTrace}(@emph{name}).
 * The current implementation only supports
 * access to @sc{time},@sc{ticks},@sc{pc},@sc{stmt}.
 * The event cache can be cleared with @sc{profiler.clearTrace()}.
 *
 * Consider the following MAL program snippet:
 * @example
 * profiler.setAll();
 * profiler.start();
 * b:= bbp.new(:int,:int);
 * bat.insert(b,1,15);
 * io.print(b);
 * profiler.stop();
 * s:= profiler.getTrace("stmt");
 * t:= profiler.getTrace("ticks");
 * io.print(s,t);
 * @end example
 * The performance result of the program execution becomes:
 * @verbatim
 * #---------------------------------------------------------#
 * # h     t                                       t         # name
 * # int   str                                     int       # type
 * #---------------------------------------------------------#
 * [ 1,      "b := bbp.new(0,0);",                   51      ]
 * [ 2,      "$6 := bat.insert(<tmp_22>,1,15);",     16      ]
 * [ 3,      "$9 := io.print(<tmp_22>);",            189     ]
 * @end verbatim
 *
 * @+ Monitoring Variables
 * The easiest scheme to obtain performance data is to
 * retrieve the performance properties of an instruction
 * directly after it has been executed using getEvent().
 * It reads the profiling stack maintained, provided you
 * have started monitoring.
 * @example
 * profiler setFilter(b);
 * profiler.start();
 * ....
 * b:= algebra.select(a,0 1000); # some expensive operation
 * (clk, memread, memwrite):= profiler.getEvent();
 * ...
 * profiler.stop();
 * @end example
 * @+ SQL table wrapper
 * The SQL frontend can access the profiler.
 * @verbatim
 * create function tracelog()
 * 	returns table (
 * 		event integer,      -- event counter
 * 		clk varchar(20),    -- wallclock, no mtime in kernel
 * 		pc varchar(50),     -- module.function[nr]
 * 		thread int,         -- thread identifier
 * 		"user" int,         -- client identifier
 * 		ticks integer,      -- time in microseconds
 * 		reads integer,      -- number of blocks read
 * 		writes integer,     -- number of blocks written
 * 		rbytes integer,     -- amount of bytes touched
 * 		wbytes integer,     -- amount of bytes written
 * 		type string,        -- return types
 * 		stmt string         -- actual statement executed
 * 	)
 * 	external name sql.dump_trace;
 * @end verbatim
 * @-
 *
 * @+ Security
 * Profiling the system is a security leak. Cached plans
 * are currently marked for profiling and not yet made private
 * for the user session. Furthermore, all events are assembled
 * in a global performance trace table. This means that concurrent
 * users can tap what is going on in the system.
 *
 * Dealing with it is major effort affecting both the kernel
 * and the upper layers. For the time being, access to the
 * data is considered priority over the leak.
 */
@h
#ifndef _MAL_PROFILER_H
#define _MAL_PROFILER_H

#include "mal_client.h"

#ifdef HAVE_SYS_TIMES_H
# include <sys/times.h>
#endif

#if defined(SOLARIS) && defined(OSVER) && OSVER < 560
# include "/usr/ucbinclude/sys/rusage.h"
# include "/usr/ucbinclude/sys/resource.h"
#endif

#ifdef HAVE_SYS_RESOURCE_H
# include <sys/resource.h>
typedef struct rusage Rusage;
#endif

typedef struct tms Tms;
typedef struct Mallinfo Mallinfo;

/*
 * @- Recycler statistics per client
 */
typedef struct RECSTAT {
	int statements;   /* total number of statements executed */
	int recycled;     /* total number of statements recycled */
	int recycled0;    /* recycled statements per query */
	lng time0;        /* time per query */
	int curQ;         /* index of current query in Qry Patterns array*/
	int recent;       /* the most recent entry in RP touched by current query */
	int recycleMiss;  /* DBG:count of misses due to cache eviction */
	int recycleRem;   /* DBG:count of removed entries */
	lng ccCalls;      /* Number of calls to cleanCache */
	lng ccInstr;      /* Number of instructions evicted by eviction policy*/
	lng crdInstr;     /* Number of instructions not admited in RP by CRD */
	int trans;        /* Number of data transfer instructions */
	lng transKB;      /* Size in KB of transferred data */
	int recTrans;     /* Number of recycled data transfer instructions */
	lng recTransKB;   /* Size in KB of recycled transferred data */
	int RPadded0;     /* Number of instructions added to RP per query */
	int RPreset0;     /* Number of instructions evicted from RP by reset() due to updates*/
} *RecPtr, RecStat;

mal_export str activateCounter(str name);
mal_export str deactivateCounter(str name);
mal_export str openProfilerStream(stream *fd);
mal_export str closeProfilerStream(void);

mal_export void initProfiler(MalBlkPtr mb);
mal_export void profilerEvent(int idx, MalBlkPtr mb, MalStkPtr stk, int pc, str status);
mal_export str setLogFile(stream *fd, Module cntxt, str fname);
mal_export str setLogStream(Module cntxt, str host, int port);
mal_export str setLogStreamStream(Module cntxt, stream *s);
mal_export str setStartPoint(Module cntxt, str mod, str fcn);
mal_export str setEndPoint(Module cntxt, str mod, str fcn);

mal_export int profilerAvailable(void);
mal_export str startProfiling(void);
mal_export str stopProfiling(void);
mal_export str cleanupProfiler(void);

mal_export int instrFilter(InstrPtr pci, str mod, str fcn);
mal_export void setFilter(Module cntxt, str mod, str fcn);
mal_export void setFilterOnBlock(MalBlkPtr mb, str mod, str fcn);
mal_export void clrFilter(Module cntxt, str mod, str fcn);
mal_export void setFilterVariable(MalBlkPtr mb, int i);
mal_export void clrFilterVariable(MalBlkPtr mb, int i);

mal_export void MPresetProfiler(stream *fdout);

mal_export int malProfileMode;

mal_export void clearTrace(void);
mal_export BAT *getTrace(str ev);
mal_export int getTraceType(str nme);
mal_export void TRACEtable(BAT **r);

mal_export lng getDiskSpace(void);
mal_export lng getDiskReads(void);
mal_export lng getDiskWrites(void);
mal_export lng getUserTime(void);
mal_export lng getSystemTime(void);
mal_export void _initTrace(void);

#endif
@c
/*
 * @+ Performance tracing
 * The interpreter comes with several variables to hold performance
 * related data.
 * Every MAL instruction record is extended with two fields: counter and timer.
 * The counter is incremented each time the instruction is taken into
 * execution. Upon return, the timer is incremented with the microseconds
 * spent.
 * In addition to the default performance data collection,
 * the user can request performance events to be collected on a statement
 * basis. Care should be taken, because it leads to a large trace file,
 * unless the results are directly passed to a performance monitor
 * front-end for filtering and summarization.
 *
 * The performance monitor has exclusive access to the event file, which
 * avoid concurrency conflicts amongst clients. It avoid cluthered
 * event records on the event stream. Since this event stream is owned
 * by a client, we should ensure that the profiler is automatically be
 * reset once the owner leaves. The routine profilerReset() handles the case.
 */
#include "monetdb_config.h"
#include "mal_function.h"
#include "mal_profiler.h"
#include "mal_debugger.h"

static stream *eventstream = 0;

static int offlineProfiling = FALSE;
static int cachedProfiling = FALSE;
static str myname = 0;

int
profilerAvailable(void)
{
	return 1;
}
static void offlineProfilerEvent(int idx, MalBlkPtr mb, MalStkPtr stk, int pc,str status);
static void cachedProfilerEvent(int idx, MalBlkPtr mb, MalStkPtr stk, int pc);
static int initTrace(void);

int malProfileMode = 0;     /* global flag to indicate profiling mode */
static int profileAll = 0;  /* all instructions should be profiled */
static int delayswitch = 0; /* to wait before sending the profile info */

#define PROFevent   0
#define PROFtime    1
#define PROFthread  2
#define PROFpc      3
#define PROFoper    4
#define PROFticks   5
#define PROFcpu     6
#define PROFmemory  7
#define PROFreads   8
#define PROFwrites  9
#define PROFrbytes  10
#define PROFwbytes  11
#define PROFstmt    12
#define PROFaggr    13
#define PROFprocess 14
#define PROFuser    15
#define PROFstart   16
#define PROFtype    17

static struct {
	str name;		/* which logical counter is needed */
	int status;		/* trace it or not */
} profileCounter[] = {
	/*  0 */  { "event", 0},
	/*  1 */  { "time", 0},
	/*  2 */  { "thread", 0},
	/*  3 */  { "pc", 0},
	/*  4 */  { "operation", 0},
	/*  5 */  { "ticks", 0},
	/*  6 */  { "cpu", 0},
	/*  7 */  { "memory", 0},
	/*  8 */  { "reads", 0},
	/*  9 */  { "writes", 0},
	/*  10 */  { "rbytes", 0},
	/*  11 */  { "wbytes", 0},
	/*  12 */  { "stmt", 0},
	/*  13 */  { "aggregate", 0},
	/*  14 */  { "process", 0},
	/*  15 */  { "user", 0},
	/*  16 */  { "start", 0},
	/*  17 */  { "type", 0},
	/*  18 */  { 0, 0}
};

/*
 * @-
 * The counters can be set individually.
 */
@= setCounter
	int i;
	for (i = 0; profileCounter[i].name; i++)
		if (strcmp(profileCounter[i].name, name) == 0) {
			profileCounter[i].status = @1;
			return 0;
		}
	throw(MAL, "@2", RUNTIME_OBJECT_UNDEFINED ":%s", name);
@
@c
str
activateCounter(str name)
{
	@:setCounter(1, activateCounter)@
}

str
deactivateCounter(str name)
{
	@:setCounter(0, deactivateCounter)@
}

/*
 * @-
 * The parameter of getEventStream is the return value of the enclosing function:
 * 	profilerEvent:  none/void
 * 	setStartPoint:  a str
 * 	setEndPoint:    a str
 */
@= getEventStream
	mal_set_lock(mal_profileLock, "profileLock");
	if (eventstream == NULL) {
		mal_unset_lock(mal_profileLock, "profileLock");
		return @1;
	}
@
@c
/*
 * @+ Offline processing
 * The offline processing structure is the easiest. We merely have to
 * produce a correct tuple format for the front-end.
 */
#define log(X, Y) if (eventstream) if (mnstr_printf(eventstream, X, Y) < 0) \
		{ closeProfilerStream(); }
#define log0(X) if (eventstream) if (mnstr_printf(eventstream, X) < 0)	\
		{ closeProfilerStream(); }
#define log2(X, Y, Z) if (eventstream) if (mnstr_printf(eventstream, X, Y, Z) < 0) \
		{ closeProfilerStream(); }
#define flushLog() if (eventstream) mnstr_flush(eventstream);

/*
 * @- Event dispatching
 * The profiler strategy is encapsulated here
 * Note that the profiler itself should lead to event generations.
 */
void
profilerEvent(int idx, MalBlkPtr mb, MalStkPtr stk, int pc, str status)
{
	if (mb->profiler == NULL) return;
	if (profileCounter[PROFstart].status == 0 && mb->profiler[pc].ticks == 0)
		return;
	if (myname == 0)
		myname = putName("profiler", 8);
	if (getModuleId(getInstrPtr(mb, pc)) == myname)
		return;
	if (offlineProfiling)
		offlineProfilerEvent(idx, mb, stk, pc,status);
	if (cachedProfiling)
		cachedProfilerEvent(idx, mb, stk, pc);
}

static void
offlineProfilerHeader(void)
{
	@:getEventStream()@   /* profilerEvent -> void */
	log0("# ");
	if (profileCounter[PROFevent].status) {
		log0("event,\tstatus,\t");
	}
	if (profileCounter[PROFtime].status) {
		log0("time,\t");
	}
	if (profileCounter[PROFthread].status) {
		log0("thread,\t");
	}
	if (profileCounter[PROFpc].status) {
		log0("function,\tpc,\t");
	}
	if (profileCounter[PROFoper].status) {
		log0("operation,\t");
	}
	if (profileCounter[PROFticks].status) {
		log0("usec,\t");
	}
	if (profileCounter[PROFcpu].status) {
		log0("utime,\t");
		log0("cutime,\t");
		log0("stime,\t");
		log0("cstime,\t");
	}

	if (profileCounter[PROFmemory].status) {
		log0("maxrss,\t");
		log0("arena,\t");
		log0("ordblks,\t");
		log0("smblks,\t");
		log0("hblkhd,\t");
		log0("hblks,\t");
		log0("fsmblks,\t");
		log0("uordblks,\t");
	}
	if (profileCounter[PROFreads].status)
		log0("blk reads,\t");
	if (profileCounter[PROFwrites].status)
		log0("blk writes,\t");
	if (profileCounter[PROFprocess].status) {
		log0("pg reclaim,\t");
		log0("pg faults,\t");
		log0("swaps,\t");
		log0("ctxt switch,\t");
		log0("inv switch,\t");
	}
	if (profileCounter[PROFrbytes].status)
		log0("rbytes,\t");
	if (profileCounter[PROFwbytes].status)
		log0("wbytes,\t");
	if (profileCounter[PROFaggr].status)
		log0("count,\t totalticks,\t");
	if (profileCounter[PROFstmt].status)
		log0("stmt,\t");
	if (profileCounter[PROFtype].status)
		log0("types,\t");
	if (profileCounter[PROFuser].status)
		log0("user,\t");
	log0("# name\n");
	flushLog();
	mal_unset_lock(mal_profileLock, "profileLock");
}

void
offlineProfilerEvent(int idx, MalBlkPtr mb, MalStkPtr stk, int pc, str status)
{
	static struct Mallinfo prevMalloc;
	InstrPtr pci = getInstrPtr(mb, pc);

#ifdef HAVE_SYS_RESOURCE_H
	static struct rusage prevUsage;
	struct rusage infoUsage;
#endif
	static int eventcounter;
#ifdef HAVE_TIMES
	struct tms newTms;
#endif
	struct Mallinfo infoMalloc;
	str stmt, c;

	if (delayswitch > 0) {
		/* first call to profiled */
		offlineProfilerHeader();
		delayswitch--;
	}
	@:getEventStream()@   /* profilerEvent -> void */
	if (delayswitch == 0) {
		delayswitch = -1;
	}
	if (!profileAll && mb->profiler[pc].trace == FALSE) {
		mal_unset_lock(mal_profileLock, "profileLock");
		return;
	}
#ifdef HAVE_TIMES
	times(&newTms);
#endif
	infoMalloc = MT_mallinfo();
#ifdef HAVE_SYS_RESOURCE_H
	getrusage(RUSAGE_SELF, &infoUsage);
#endif

	/* make basic profile event tuple  */
	log0("[ ");
	if (profileCounter[PROFevent].status) {
		log("%d,\t", eventcounter);
		log("\"%s\",\t", status);
	}
	if (profileCounter[PROFtime].status) {
		char *tbuf, *c;

		/* without this cast, compilation on Windows fails with
		 * argument of type "long *" is incompatible with parameter of type "const time_t={__time64_t={__int64}} *"
		 */
		time_t clock = (time_t) mb->profiler[pc].clock.tv_sec;
		tbuf = ctime(&clock);
		if (tbuf) {
			c = strchr(tbuf, '\n');
			if (c) {
				c[-5] = 0;
			}
			tbuf[10] = '"';
			log("%s", tbuf + 10);
			log(".%06d\",\t", (int)mb->profiler[pc].clock.tv_usec);
		} else
			log("%s,\t", "nil");
	}
	if (profileCounter[PROFthread].status) {
		log(" %d,\t", THRgettid());
	}
	if (profileCounter[PROFpc].status) {
		str mod = "";
		str fcn = "";

		if (stk->blk) {
			mod = getModuleId(getInstrPtr(stk->blk, 0));
			fcn = getFunctionId(getInstrPtr(stk->blk, 0));
		}
		log2("\"%s.%s\",\t", mod, fcn);
		log("%d,\t", getPC(mb, pci));
	}
	if (profileCounter[PROFoper].status) {
		if (getModuleId(pci) && getFunctionId(pci)) {
			log2("\"%s.%s\",\t",
				getModuleId(pci), getFunctionId(pci));
		} else
			log("\"%s\",\t", operatorName(pci->token));
	}
	if (profileCounter[PROFticks].status) {
		log(LLFMT ",\t", mb->profiler[pc].ticks);
	}
#ifdef HAVE_TIMES
	if (profileCounter[PROFcpu].status && delayswitch < 0) {
		log("%ld,\t", (long) (newTms.tms_utime - mb->profiler[pc].timer.tms_utime));
		log("%ld,\t", (long) (newTms.tms_cutime - mb->profiler[pc].timer.tms_cutime));
		log("%ld,\t", (long) (newTms.tms_stime - mb->profiler[pc].timer.tms_stime));
		log("%ld,\t", (long) (newTms.tms_cstime - mb->profiler[pc].timer.tms_cstime));
	}
#endif

	if (profileCounter[PROFmemory].status && delayswitch < 0) {
#ifdef HAVE_SYS_RESOURCE_H
		log("%ld,\t", infoUsage.ru_maxrss);
#endif
		log(SZFMT ",\t", (size_t)(infoMalloc.arena - prevMalloc.arena));
		log(SZFMT ",\t", (size_t)(infoMalloc.ordblks - prevMalloc.ordblks));
		log(SZFMT ",\t", (size_t)(infoMalloc.smblks - prevMalloc.smblks));
		log(SZFMT ",\t", (size_t)(infoMalloc.hblkhd - prevMalloc.hblkhd));
		log(SZFMT ",\t", (size_t)(infoMalloc.hblks - prevMalloc.hblks));
		log(SZFMT ",\t", (size_t)(infoMalloc.fsmblks - prevMalloc.fsmblks));
		log(SZFMT ",\t", (size_t)(infoMalloc.uordblks - prevMalloc.uordblks));
		prevMalloc = infoMalloc;
	}
#ifdef HAVE_SYS_RESOURCE_H
	if ((profileCounter[PROFreads].status ||
		 profileCounter[PROFwrites].status) && delayswitch < 0) {
		log("%ld,\t", infoUsage.ru_inblock - prevUsage.ru_inblock);
		log("%ld,\t", infoUsage.ru_oublock - prevUsage.ru_oublock);
		prevUsage = infoUsage;
	}
	if (profileCounter[PROFprocess].status && delayswitch < 0) {
		log("%ld,\t", infoUsage.ru_minflt - prevUsage.ru_minflt);
		log("%ld,\t", infoUsage.ru_majflt - prevUsage.ru_majflt);
		log("%ld,\t", infoUsage.ru_nswap - prevUsage.ru_nswap);
		log("%ld,\t", infoUsage.ru_nvcsw - prevUsage.ru_nvcsw);
		log("%ld,\t", infoUsage.ru_nivcsw - prevUsage.ru_nivcsw);
		prevUsage = infoUsage;
	}
#endif
	if (profileCounter[PROFrbytes].status)
		log(LLFMT ",\t", mb->profiler[pc].rbytes);
	if (profileCounter[PROFwbytes].status)
		log(LLFMT ",\t", mb->profiler[pc].wbytes);

	if (profileCounter[PROFaggr].status)
		log2("%d,\t" LLFMT ",\t", mb->profiler[pc].counter, mb->profiler[pc].totalticks);

	if (profileCounter[PROFstmt].status) {
		/* generate actual call statement */
		str stmtq;
		stmt = instruction2str(mb, stk, pci, LIST_MAL_DEBUG);
		c = stmt;

		while (c && *c && isspace((int)*c))
			c++;
		stmtq = mal_quote(c, strlen(c));
		if (stmtq != NULL) {
			log(" \"%s\",\t", stmtq);
			GDKfree(stmtq);
		} else log0(" ,\t");
		GDKfree(stmt);
	}
	if (profileCounter[PROFtype].status) {
		char abuf[BUFSIZ], *tpe;
		int i, j;
		abuf[0] = 0;
		for (i = 0; i < pci->retc; i++)
			if (getArgType(mb, pci, i) != TYPE_void) {
				j = (int)strlen(abuf);
				tpe = getTypeName(getArgType(mb, pci, i));
				snprintf(abuf + j, BUFSIZ - j, "%s:%s%s", getVarName(mb, getArg(pci, i)), tpe, (i < pci->retc - 1 ? ", " : ""));
				GDKfree(tpe);
			}
		log("\"%s\",\t", abuf);
	}
	if (profileCounter[PROFuser].status) {
		log(" %d", idx);
	}
	log0(" ]\n");
	eventcounter++;
	flushLog();
	mal_unset_lock(mal_profileLock, "profileLock");
}
/*
 * @+ Postprocessing events
 * The events may be sent for offline processing through a
 * stream, including "stdout".
 */
str
setLogFile(stream *fd, Module mod, str fname)
{
	(void)mod;      /* still unused */
	mal_set_lock(mal_profileLock, "profileLock");
	if (eventstream )
		throw(IO, "mal.profiler", "Log file already set");
	if (strcmp(fname, "console") == 0)
		eventstream = mal_clients[0].fdout;
	else if (strcmp(fname, "stdout") == 0)
		eventstream = fd;
	else
		eventstream = open_wastream(fname);
	if (eventstream == NULL) {
		throw(IO, "mal.profiler", RUNTIME_STREAM_FAILED);
	}
	mal_unset_lock(mal_profileLock, "profileLock");
	return MAL_SUCCEED;
}

str
setLogStream(Module cntxt, str host, int port)
{
	(void)cntxt;        /* still unused */
	mal_set_lock(mal_profileLock, "profileLock");
	if ((eventstream = udp_wastream(host, port, "profileStream")) == NULL)
		throw(IO, "mal.profiler", RUNTIME_STREAM_FAILED);
	eventstream = wbstream(eventstream, BUFSIZ);
	mal_unset_lock(mal_profileLock, "profileLock");
	return MAL_SUCCEED;
}

str
setLogStreamStream(Module cntxt, stream *s)
{
	(void)cntxt;        /* still unused */
	mal_set_lock(mal_profileLock, "profileLock");
	if ((eventstream = s) == NULL)
		throw(ILLARG, "mal.profiler", "stream must not be NULL");
	eventstream = wbstream(eventstream, BUFSIZ);
	mal_unset_lock(mal_profileLock, "profileLock");
	return MAL_SUCCEED;
}

str
openProfilerStream(stream *fd)
{
	malProfileMode = TRUE;
	eventstream = fd;
	delayswitch = 1;    /* avoid an incomplete initial profile event */
	return MAL_SUCCEED;
}

str
closeProfilerStream(void)
{
	if (eventstream) {
		(void)mnstr_close(eventstream);
		(void)mnstr_destroy(eventstream);
	}
	eventstream = NULL;
	malProfileMode = FALSE;
	return MAL_SUCCEED;
}

str
setStartPoint(Module cntxt, str mod, str fcn)
{
	(void)cntxt;
	(void)mod;
	(void)fcn;      /* still unused */
	@:getEventStream(MAL_SUCCEED /*? or MAL_? ? */)@
	mnstr_printf(GDKout, "# start point not set\n");
	flushLog();
	mal_unset_lock(mal_profileLock, "profileLock");
	return MAL_SUCCEED;
}

str
setEndPoint(Module cntxt, str mod, str fcn)
{
	(void)cntxt;
	(void)mod;
	(void)fcn;      /* still unused */
	@:getEventStream(MAL_SUCCEED /*? or MAL_? ? */)@
	mnstr_printf(GDKout, "# end point not set\n");
	flushLog();
	mal_unset_lock(mal_profileLock, "profileLock");
	return MAL_SUCCEED;
}

/*
 * @-
 * When you receive the message to start profiling, we
 * should wait for the next instruction the stream
 * is initiated. This is controlled by a delay-switch
 */
static int TRACE_init = 0;
str
startProfiling(void)
{
	mal_set_lock(mal_profileLock, "profileLock");
	if (eventstream != NULL) {
		offlineProfiling = TRUE;
		delayswitch = 1;
	} else
		cachedProfiling = TRUE;
	if (TRACE_init == 0)
		_initTrace();
	malProfileMode = TRUE;
	mal_unset_lock(mal_profileLock, "profileLock");
	return MAL_SUCCEED;
}

str
stopProfiling(void)
{
	malProfileMode = FALSE;
	offlineProfiling = FALSE;
	cachedProfiling = FALSE;
	closeProfilerStream();
	return MAL_SUCCEED;
}

/*
 * @-
 * The resetProfiler is called when the owner of the event stream
 * leaves the scene. (Unclear if parallelism may cause errors)
 */
void
MPresetProfiler(stream *fdout)
{
	if (fdout != eventstream)
		return;
	mal_set_lock(mal_profileLock, "profileLock");
	eventstream = 0;
	mal_unset_lock(mal_profileLock, "profileLock");
}

/*
 * @-
 * Performance tracing is triggered on an instruction basis
 * or a the global flag 'profileAll' being set.
 * Calling setFilter(M,F) switches the performance tracing
 * bit in the instruction record. The routine clrFilter
 * clears all performance bits.
 *
 * The routines rely on waking their way through the
 * instructions space from a given context. This has been
 * abstracted away.
 */
int
instrFilter(InstrPtr pci, str mod, str fcn)
{
	if (pci && getFunctionId(pci) && fcn && mod &&
			(*fcn == '*' || fcn == getFunctionId(pci)) &&
			(*mod == '*' || mod == getModuleId(pci)))
		return 1;
	return 0;
}

/*
 * @-
 * The last filter values are saved as replacement for missing
 * arguments. It can be used to set the profile bits for modules
 * that has not been checked yet, e.g created on the fly.
 */
static str modFilter[32], fcnFilter[32];
static int topFilter;

void
setFilterOnBlock(MalBlkPtr mb, str mod, str fcn)
{
	int cnt, k, i;
	InstrPtr p;

	initProfiler(mb);
	for (k = 0; k < mb->stop; k++) {
		p = getInstrPtr(mb, k);
		cnt = 0;
		for (i = 0; i < topFilter; i++)
			cnt += instrFilter(p, modFilter[i], fcnFilter[i]);
		mb->profiler[k].trace = profileAll || cnt ||
								(mod && fcn && instrFilter(p, mod, fcn));
	}
}

void
setFilter(Module cntxt, str mod, str fcn)
{
	int j;
	Module s = cntxt;
	Symbol t;
	str matchall = "*";

	(void)cntxt;
	if (mod == NULL)
		mod = matchall;
	if (fcn == NULL)
		fcn = matchall;
	profileAll = strcmp(mod, "*") == 0 && strcmp(fcn, "*") == 0;

	mal_set_lock(mal_profileLock, "profileLock");
	if (mod && fcn && topFilter < 32) {
		modFilter[topFilter] = putName(mod, strlen(mod));
		fcnFilter[topFilter++] = putName(fcn, strlen(fcn));
	}
	while (s != NULL) {
		if (s->subscope)
			for (j = 0; j < MAXSCOPE; j++)
				if (s->subscope[j]) {
					for (t = s->subscope[j]; t != NULL; t = t->peer) {
						if (t->def)
							setFilterOnBlock(t->def, mod, fcn);
					}
				}
		s = s->outer;
	}
	mal_unset_lock(mal_profileLock, "profileLock");
}

/*
 * @-
 * Watch out. The profiling bits are only set for the shared modules and
 * the private main(). The profiler setFilter should explicitly be called in
 * each separate top level routine.
 */
void
clrFilter(Module cntxt, str mod, str fcn)
{
	int j, k;
	Module s = cntxt;
	Symbol t;
	MalBlkPtr mb;

	(void)mod;
	(void)fcn;      /* still unused */

	mal_set_lock(mal_profileLock, "profileLock");
	for (j = 0; j < topFilter; j++) {
		modFilter[j] = NULL;
		fcnFilter[j] = NULL;
	}
	topFilter = 0;
	profileAll = FALSE;
	while (s != NULL) {
		if (s->subscope)
			for (j = 0; j < MAXSCOPE; j++)
				if (s->subscope[j]) {
					for (t = s->subscope[j]; t != NULL; t = t->peer) {
						if (t->def && (mb = t->def)->profiler)
							for (k = 0; k < t->def->stop; k++)
								if (instrFilter(getInstrPtr(t->def, k), mod, fcn)) {
									mb->profiler[k].trace = FALSE;
								}
					}
				}
		s = s->outer;
	}
	mal_unset_lock(mal_profileLock, "profileLock");
}
/*
 * @-
 * The instructions to be monitored can also be identified
 * using a variable. Any instruction that references it
 * is traced. Beware, this operation should be executed
 * in the context of the function to avoid loosing
 * track due to optimizers re-assigning names.
 */
void
setFilterVariable(MalBlkPtr mb, int arg)
{
	int i, k;
	InstrPtr p;

	for (i = 0; i < mb->stop; i++) {
		p = getInstrPtr(mb, i);
		for (k = 0; k < p->argc; k++)
			if (getArg(p, k) == arg) {
				initProfiler(mb);
				mb->profiler[i].trace = TRUE;
			}
	}
}

void
clrFilterVariable(MalBlkPtr mb, int arg)
{
	int i, k;
	InstrPtr p;

	for (i = 0; i < mb->stop; i++) {
		p = getInstrPtr(mb, i);
		for (k = 0; k < p->argc; k++)
			if (getArg(p, k) == arg) {
				mb->profiler[i].trace = FALSE;
			}
	}
}

/*
 * @+ Offline tracing
 * The events being captured are stored in separate BATs.
 * They are made persistent to accumate information over
 * multiple sessions. This means it has to be explicitly reset
 * to avoid disc overflow using profiler.reset().
 *
 * All properties identified below are maintained, because this allows
 * for easy integration with SQL.
 */
static int TRACE_event = 0;
static BAT *TRACE_id_event = 0;
static BAT *TRACE_id_time = 0;
static BAT *TRACE_id_ticks = 0;
static BAT *TRACE_id_pc = 0;
static BAT *TRACE_id_stmt = 0;
static BAT *TRACE_id_type = 0;
static BAT *TRACE_id_rbytes = 0;
static BAT *TRACE_id_wbytes = 0;
static BAT *TRACE_id_reads = 0;
static BAT *TRACE_id_writes = 0;
static BAT *TRACE_id_thread = 0;
static BAT *TRACE_id_user = 0;

void
TRACEtable(BAT **r)
{
	if (initTrace())
		return ;
	mal_set_lock(mal_profileLock, "profileLock");
	r[0] = TRACE_id_event;
	r[1] = TRACE_id_time;
	r[2] = TRACE_id_pc;
	r[3] = TRACE_id_thread;
	r[4] = TRACE_id_user;
	r[5] = TRACE_id_ticks;
	r[6] = TRACE_id_reads;
	r[7] = TRACE_id_writes;
	r[8] = TRACE_id_rbytes;
	r[9] = TRACE_id_wbytes;
	r[10] = TRACE_id_type;
	r[11] = TRACE_id_stmt;
	mal_unset_lock(mal_profileLock, "profileLock");
}

static BAT *
TRACEcreate(str hnme, str tnme, int tt)
{
	BAT *b;
	char buf[128];

	snprintf(buf, 128, "trace_%s_%s", hnme, tnme);
	b = BATdescriptor(BBPindex(buf));
	if (b) {
		if (b->htype == TYPE_int)
			/* old code */
			BBPreclaim(b);
		else
			return b;
	}

	b = BATnew(TYPE_void, tt, 1 << 16);
	if (b == NULL)
		return NULL;

	BATseqbase(b, 0);
	BATkey(b, TRUE);
	BBPrename(b->batCacheid, buf);
	BATmode(b, PERSISTENT);
	BATcommit(b);
	return b;
}


#define CLEANUPprofile(X)  if (X) { BBPdecref((X)->batCacheid, TRUE); (X)->batPersistence = TRANSIENT; } (X) = NULL;

static void
_cleanupProfiler(void)
{
	CLEANUPprofile(TRACE_id_event);
	CLEANUPprofile(TRACE_id_time);
	CLEANUPprofile(TRACE_id_pc);
	CLEANUPprofile(TRACE_id_stmt);
	CLEANUPprofile(TRACE_id_type);
	CLEANUPprofile(TRACE_id_rbytes);
	CLEANUPprofile(TRACE_id_wbytes);
	CLEANUPprofile(TRACE_id_reads);
	CLEANUPprofile(TRACE_id_writes);
	CLEANUPprofile(TRACE_id_thread);
	CLEANUPprofile(TRACE_id_user);
	TRACE_init = 0;
}

void
_initTrace(void)
{
	TRACE_id_event = TRACEcreate("id", "event", TYPE_int);
	TRACE_id_time = TRACEcreate("id", "time", TYPE_str);
	TRACE_id_ticks = TRACEcreate("id", "ticks", TYPE_lng);
	TRACE_id_pc = TRACEcreate("id", "pc", TYPE_str);
	TRACE_id_stmt = TRACEcreate("id", "stmt", TYPE_str);
	TRACE_id_type = TRACEcreate("id", "type", TYPE_str);
	TRACE_id_rbytes = TRACEcreate("id", "rbytes", TYPE_lng);
	TRACE_id_wbytes = TRACEcreate("id", "wbytes", TYPE_lng);
	TRACE_id_reads = TRACEcreate("id", "read", TYPE_lng);
	TRACE_id_writes = TRACEcreate("id", "write", TYPE_lng);
	TRACE_id_thread = TRACEcreate("id", "thread", TYPE_int);
	TRACE_id_user = TRACEcreate("id", "user", TYPE_int);
	if (TRACE_id_event == NULL ||
		TRACE_id_time == NULL ||
		TRACE_id_ticks == NULL ||
		TRACE_id_pc == NULL ||
		TRACE_id_stmt == NULL ||
		TRACE_id_type == NULL ||
		TRACE_id_rbytes == NULL ||
		TRACE_id_wbytes == NULL ||
		TRACE_id_reads == NULL ||
		TRACE_id_writes == NULL ||
		TRACE_id_thread == NULL ||
		TRACE_id_user == NULL
		) {
		_cleanupProfiler();
	} else {
		TRACE_init = 1;
	}
}

int
initTrace(void)
{
	if (TRACE_init)
		return 0;       /* already initialized */
	mal_set_lock(mal_contextLock, "profileLock");
	_initTrace();
	mal_unset_lock(mal_contextLock, "profileLock");
	return TRACE_init ? 0 : -1;
}

str
cleanupProfiler(void)
{
	mal_set_lock(mal_contextLock, "cleanup");
	_cleanupProfiler();
	mal_unset_lock(mal_contextLock, "cleanup");
	return MAL_SUCCEED;
}

void
clearTrace(void)
{
	if (TRACE_init == 0)
		return;     /* not initialized */
	mal_set_lock(mal_contextLock, "cleanup");
	/* drop all trace tables */
	BBPclear(TRACE_id_event->batCacheid);
	BBPclear(TRACE_id_time->batCacheid);
	BBPclear(TRACE_id_ticks->batCacheid);
	BBPclear(TRACE_id_pc->batCacheid);
	BBPclear(TRACE_id_stmt->batCacheid);
	BBPclear(TRACE_id_type->batCacheid);
	BBPclear(TRACE_id_thread->batCacheid);
	BBPclear(TRACE_id_user->batCacheid);
	BBPclear(TRACE_id_reads->batCacheid);
	BBPclear(TRACE_id_writes->batCacheid);
	TRACE_init = 0;
	_initTrace();
	mal_unset_lock(mal_contextLock, "cleanup");
}

BAT *
getTrace(str nme)
{
	if (TRACE_init == 0)
		return NULL;
	if (strcmp(nme, "event") == 0)
		return TRACE_id_event;
	if (strcmp(nme, "time") == 0)
		return TRACE_id_time;
	if (strcmp(nme, "ticks") == 0)
		return TRACE_id_ticks;
	if (strcmp(nme, "pc") == 0)
		return TRACE_id_pc;
	if (strcmp(nme, "thread") == 0)
		return TRACE_id_thread;
	if (strcmp(nme, "user") == 0)
		return TRACE_id_user;
	if (strcmp(nme, "stmt") == 0)
		return TRACE_id_stmt;
	if (strcmp(nme, "type") == 0)
		return TRACE_id_type;
	if (strcmp(nme, "rbytes") == 0)
		return TRACE_id_rbytes;
	if (strcmp(nme, "wbytes") == 0)
		return TRACE_id_wbytes;
	if (strcmp(nme, "reads") == 0)
		return TRACE_id_reads;
	if (strcmp(nme, "writes") == 0)
		return TRACE_id_writes;
	return NULL;
}

int
getTraceType(str nme)
{
	if (initTrace())
		return TYPE_any;
	if (strcmp(nme, "time") == 0)
		return newBatType(TYPE_void, TYPE_str);
	if (strcmp(nme, "ticks") == 0)
		return newBatType(TYPE_void, TYPE_lng);
	if (strcmp(nme, "pc") == 0)
		return newBatType(TYPE_void, TYPE_str);
	if (strcmp(nme, "thread") == 0)
		return newBatType(TYPE_void, TYPE_int);
	if (strcmp(nme, "stmt") == 0)
		return newBatType(TYPE_void, TYPE_str);
	if (strcmp(nme, "rbytes") == 0)
		return newBatType(TYPE_void, TYPE_lng);
	if (strcmp(nme, "wbytes") == 0)
		return newBatType(TYPE_void, TYPE_lng);
	if (strcmp(nme, "reads") == 0 || strcmp(nme, "writes") == 0)
		return newBatType(TYPE_void, TYPE_lng);
	return TYPE_any;
}

void
cachedProfilerEvent(int idx, MalBlkPtr mb, MalStkPtr stk, int pc)
{
	/* static struct Mallinfo prevMalloc; */
	static int eventcounter = 0;
	char buf[1024];
	int tid = (int)THRgettid();
	lng v = 0;

#ifdef HAVE_TIMES
	struct tms newTms;
#endif

	/* struct Mallinfo infoMalloc; */
#ifdef HAVE_SYS_RESOURCE_H
	struct rusage infoUsage;
	static struct rusage prevUsage;
#endif
	str stmt, c;
	InstrPtr pci = getInstrPtr(mb, pc);

	if (delayswitch > 0) {
		/* first call to profiled */
		delayswitch--;
		return;
	}
	if (delayswitch == 0) {
		delayswitch = -1;
	}
	if (!(profileAll || mb->profiler[pc].trace))
		return;
#ifdef HAVE_TIMES
	times(&newTms);
#endif
	/* infoMalloc = MT_mallinfo(); */
#ifdef HAVE_SYS_RESOURCE_H
	getrusage(RUSAGE_SELF, &infoUsage);
#endif
	mal_set_lock(mal_profileLock, "profileLock");
	if (initTrace() || TRACE_init == 0) {
		mal_unset_lock(mal_profileLock, "profileLock");
		return;
	}

	/* update the Trace tables */
	snprintf(buf, 1024, "%s.%s[%d]",
		getModuleId(getInstrPtr(mb, 0)),
		getFunctionId(getInstrPtr(mb, 0)), getPC(mb, pci));
	TRACE_id_pc = BUNappend(TRACE_id_pc, buf, FALSE);

	TRACE_id_thread = BUNappend(TRACE_id_thread, &tid, FALSE);

	TRACE_id_user = BUNappend(TRACE_id_user, &idx, FALSE);

	TRACE_id_event = BUNappend(TRACE_id_event, &TRACE_event, FALSE);
	TRACE_event++;

	{
		char *tbuf, *c;

		/* without this cast, compilation on Windows fails with
		 * argument of type "long *" is incompatible with parameter of type "const time_t={__time64_t={__int64}} *"
		 */
		time_t clock = (time_t) mb->profiler[pc].clock.tv_sec;
		tbuf = ctime(&clock);
		c = strchr(tbuf, '\n');
		if (c)
			snprintf(c-5, 6, ".%03d", (int)mb->profiler[pc].clock.tv_usec / 1000);
		TRACE_id_time = BUNappend(TRACE_id_time, tbuf, FALSE);
	}

	TRACE_id_ticks = BUNappend(TRACE_id_ticks, &mb->profiler[pc].ticks, FALSE);

	/* generate actual call statement */
	stmt = instruction2str(mb, stk, pci, LIST_MAL_DEBUG);
	c = stmt;

	while (c && *c && (isspace((int)*c) || *c == '!'))
		c++;
	TRACE_id_stmt = BUNappend(TRACE_id_stmt, c, FALSE);

	{
		char abuf[BUFSIZ], *tpe;
		int i, j;
		abuf[0] = 0;
		for (i = 0; i < pci->retc; i++)
			if (getArgType(mb, pci, i) != TYPE_void) {
				j = (int)strlen(abuf);
				tpe = getTypeName(getArgType(mb, pci, i));
				snprintf(abuf + j, BUFSIZ - j, "%s:%s%s", getVarName(mb, getArg(pci, i)), tpe, (i < pci->retc - 1 ? ", " : ""));
				GDKfree(tpe);
			}
		TRACE_id_type = BUNappend(TRACE_id_type, &abuf, FALSE);
	}
	if (stmt) GDKfree(stmt);

/* The remainder requires their own BATs
 #ifdef HAVE_TIMES
	if( profileCounter[PROFcpu].status ){
		log("%d,\t", newTms.tms_utime - mb->profiler[pc].timer.tms_utime);
		log("%d,\t", newTms.tms_cutime - mb->profiler[pc].timer.tms_cutime);
		log("%d,\t", newTms.tms_stime - mb->profiler[pc].timer.tms_stime);
		log("%d,\t", newTms.tms_cstime - mb->profiler[pc].timer.tms_cstime);
	}
 #endif

	if( profileCounter[PROFmemory].status ){
 #ifdef HAVE_SYS_RESOURCE_H
		log("%d,\t",infoUsage.ru_maxrss);
 #endif
		log("%d,\t", infoMalloc.arena-prevMalloc.arena);
		log("%d,\t", infoMalloc.ordblks-prevMalloc.ordblks);
		log("%d,\t", infoMalloc.smblks-prevMalloc.smblks);
		log("%d,\t", infoMalloc.hblkhd-prevMalloc.hblkhd);
		log("%d,\t", infoMalloc.hblks-prevMalloc.hblks);
		log("%d,\t", infoMalloc.fsmblks-prevMalloc.fsmblks);
		log("%d,\t", infoMalloc.uordblks-prevMalloc.uordblks);
		prevMalloc = infoMalloc;
	}
 */
#ifdef HAVE_SYS_RESOURCE_H
	v = infoUsage.ru_inblock - prevUsage.ru_inblock;
	TRACE_id_reads = BUNappend(TRACE_id_reads, &v, FALSE);
	v = infoUsage.ru_oublock - prevUsage.ru_oublock;
	TRACE_id_writes = BUNappend(TRACE_id_writes, &v, FALSE);
	prevUsage = infoUsage;
#else
	TRACE_id_reads = BUNappend(TRACE_id_reads, &v, FALSE);
	TRACE_id_writes = BUNappend(TRACE_id_writes, &v, FALSE);
#endif

/*
	if( profileCounter[PROFprocess].status ){
		log("%d,\t", infoUsage.ru_minflt- prevUsage.ru_minflt);
		log("%d,\t", infoUsage.ru_majflt- prevUsage.ru_majflt);
		log("%d,\t", infoUsage.ru_nswap- prevUsage.ru_nswap);
		log("%d,\t", infoUsage.ru_nvcsw- prevUsage.ru_nvcsw);
		log("%d,\t", infoUsage.ru_nivcsw- prevUsage.ru_nivcsw);
		prevUsage = infoUsage;
	}
 #endif
 */
	TRACE_id_rbytes = BUNappend(TRACE_id_rbytes, &mb->profiler[pc].rbytes, FALSE);
	TRACE_id_wbytes = BUNappend(TRACE_id_wbytes, &mb->profiler[pc].wbytes, FALSE);

	eventcounter++;
	flushLog();
	mal_unset_lock(mal_profileLock, "profileLock");
}
/*
 * @-
 * The profile vector is added to the MAL block the first time we
 * have to safe monitor information.
 */
void initProfiler(MalBlkPtr mb)
{
	if (mb->profiler) return;
	initTrace();
	mb->profiler = (ProfPtr)GDKzalloc(mb->ssize * sizeof(ProfRecord));
}

lng
getDiskWrites(void)
{
#ifdef HAVE_SYS_RESOURCE_H
	struct rusage infoUsage;
	getrusage(RUSAGE_SELF, &infoUsage);
	return infoUsage.ru_oublock;
#else
	return 0;
#endif
}

lng
getDiskReads(void)
{
#ifdef HAVE_SYS_RESOURCE_H
	struct rusage infoUsage;
	getrusage(RUSAGE_SELF, &infoUsage);
	return infoUsage.ru_inblock;
#else
	return 0;
#endif
}

lng
getUserTime(void)
{
#ifdef HAVE_TIMES
	struct tms newTms;
	times(&newTms);
	return newTms.tms_utime;
#else
	return 0;
#endif
}

lng
getSystemTime(void)
{
#ifdef HAVE_TIMES
	struct tms newTms;
	times(&newTms);
	return newTms.tms_stime;
#else
	return 0;
#endif
}

lng
getDiskSpace(void)
{
	BAT *b;
	int i;
	lng size = 0;

	for (i = 1; i < BBPsize; i++)
		if (BBP_logical(i) && (BBP_refs(i) || BBP_lrefs(i))) {
			b = BATdescriptor(i);
			if (b) {
				size += sizeof(BAT);
				if (!isVIEW(b)) {
					BUN cnt = BATcount(b);

					size += headsize(b, cnt);
					size += tailsize(b, cnt);
					/* the upperbound is used for the heaps */
					if (b->H->vheap)
						size += b->H->vheap->size;
					if (b->T->vheap)
						size += b->T->vheap->size;
					if (b->H->hash)
						size += sizeof(BUN) * cnt;
					if (b->T->hash)
						size += sizeof(BUN) * cnt;
				}
				BBPunfix(i);
			}
		}
	return size;
}
