@/
The contents of this file are subject to the MonetDB Public License
Version 1.1 (the "License"); you may not use this file except in
compliance with the License. You may obtain a copy of the License at
http://www.monetdb.org/Legal/MonetDBLicense

Software distributed under the License is distributed on an "AS IS"
basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations
under the License.

The Original Code is the MonetDB Database System.

The Initial Developer of the Original Code is CWI.
Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
Copyright August 2008-2012 MonetDB B.V.
All Rights Reserved.
@

@c
/*
 * @a M. Kersten
 * @v 1.0
 * @* MonetDB Assembly Language (MAL)
 */
@h
#ifndef _MAL_INSTR_H
#define _MAL_INSTR_H

#include "mal_type.h"
#include "mal_stack.h"
#include "mal_properties.h"

#define isaSignature(P)  ((P)->token >=COMMANDsymbol)

#ifdef HAVE_SYS_TIMES_H
# include <sys/times.h>
#endif

#define DEBUG_MAL_INSTR
/* #define DEBUG_REDUCE */
#define MAXARG 4		/* BEWARE the code depends on this knowledge */
#define STMT_INCREMENT 32
#define MAL_VAR_WINDOW  32
#define MAXVARS 32
#define MAXLISTING 64*1024

typedef struct SYMDEF {
	struct SYMDEF *peer;	/* where to look next */
	struct SYMDEF *skip;	/* skip to next different symbol */
	str name;
	int kind;
	struct MALBLK *def;	/* the details of the MAL fcn */
} *Symbol, SymRecord;

typedef struct VARRECORD {
	str name;		/* argname or lexical value repr */
	malType type;		/* internal type signature */
	int flags;		/* see below, reserve some space */
	int tmpindex;		/* temporary variable */
	ValRecord value;
	int eolife;			/* pc index when it should be garbage collected */
	int propc, maxprop;	/* proc count and max number of properties */
	int prps[];		/* property array */
} *VarPtr, VarRecord;

/* Variable properties */
#define VAR_CONSTANT 	1
#define VAR_TYPEVAR	2
#define VAR_FIXTYPE	4
#define VAR_UDFTYPE	8
#define VAR_CLEANUP	16
#define VAR_INIT	32
#define VAR_USED	64
#define VAR_DISABLED	128 /* used for comments and scheduler */

/* type check status is kept around to improve type checking efficiency */
#define TYPE_ERROR      -1
#define TYPE_UNKNOWN     0
#define TYPE_RESOLVED    2

#define GARBAGECONTROL   3

#define VARARGS 1	/* deal with variable arguments */
#define VARRETS 2

/* all functions return a string */

typedef struct {
	bit token;		/* instruction type */
	bit barrier;		/* flow of control modifier takes:
				   BARRIER, LEAVE, REDO, EXIT, CATCH, RAISE*/
	bit typechk;		/* type check status */
	bit gc;			/* garbage control flags */
	bit polymorphic;	/* complex type analysis */
	bit varargs;		/* variable number of arguments */
	int recycle;	/* <0 or index into recycle cache */
	int jump;		/* controlflow program counter */
	MALfcn fcn;		/* resolved function address */
	struct MALBLK *blk;	/* resolved MAL function address */
	str modname;		/* module context */
	str fcnname;		/* function name */
	int argc, retc, maxarg;	/* total and result argument count */
	int argv[];		/* at least a few entries */
} *InstrPtr, InstrRecord;

/*
For performance analysis we keep track of the number of calls
and the total time spent while executing the instruction.
(See mal_profiler.mx)
The performance structures are separately administered, because
they are only used in limited curcumstances.
*/
typedef struct PERF {
#ifdef HAVE_TIMES
	struct tms timer;	/* timing information */
#endif
	struct timeval clock;	/* clock */
	lng clk;		/* microseconds clock */
	lng ticks;		/* micro seconds spent */
	int counter;	/* accumulate statistics */
	lng totalticks;	
	bit trace;		/* facilitate filter-based profiling */
	lng rbytes;		/* bytes read by an instruction */
	lng wbytes;		/* bytes written by an instruction */
} *ProfPtr, ProfRecord;

typedef struct MALBLK {
	str binding;		/* related C-function */
	str help;		/* supportive commentary */
	struct MALBLK *alternative;
	int vtop;		/* next free slot */
	int vsize;		/* size of variable arena */
	VarRecord **var;	/* Variable table */
	int stop;		/* next free slot */
	int ssize;		/* byte size of arena */
	InstrPtr *stmt;		/* Instruction location */
	int ptop;		/* next free slot */
	int psize;		/* byte size of arena */
	MalProp *prps;		/* property table */
	int errors;		/* left over errors */
	int typefixed;		/* no undetermined instruction */
	int flowfixed;		/* all flow instructions are fixed */
	ProfPtr profiler;
	struct MALBLK *history;/* of optimizer actions */
	int keephistory;	/* do we need the history at all */
	str marker;			/* history points are marked for backtracking */
	int maxarg;			/* keep track on the maximal arguments used */
	ptr replica;		/* for the replicator tests */
	sht recycle;		/* execution subject to recycler control */
	lng recid;			/* ID given by recycler optimizer */
	lng legid;
	sht trap;			/* call debugger when called */
} *MalBlkPtr, MalBlkRecord;

/*
Allocation of space assumes a rather exotic number of arguments.
Access to module and function name are cast in macros to prepare
for separate name space management.
*/
#define getModuleId(P)     (P)->modname
#define setModuleId(P,S)    (P)->modname= S
#define setModuleScope(P,S) {(P)->modname= (S)==NULL?NULL: (S)->name;}

#define getFunctionId(P)       (P)->fcnname
#define setFunctionId(P,S)  (P)->fcnname= S
#define garbageControl(P)   ((P)->gc & GARBAGECONTROL)

#define getInstrPtr(M,I)    (M)->stmt[I]
#define getSignature(S)     getInstrPtr((S)->def,0)
#define isMain(M)			((getInstrPtr(M,0))->fcnname== putName("main",4))
#define getFcnName(M)       getFunctionId(getInstrPtr(M,0))
#define getArgCount(M)      getInstrPtr(M,0)->argc
#define getModName(M)       getModuleId(getInstrPtr(M,0))
#define getPrgSize(M)       (M)->stop

#define getVar(M,I)     (M)->var[I]
#define getVarTmp(M,I)      (M)->var[I]->tmpindex
#define isTmpVar(M,I)   	((M)->var[I]->tmpindex)
#define getVarType(M,I)     ((M)->var[I]->type)
#define getVarGDKType(M,I)      getGDKType((M)->var[I]->type)
#define ignoreVar(M,I)		((M)->var[I]->type == TYPE_ptr? 1: 0)
/*
 * @-
 */
@= varProperty
#define clrVar@1(M,I)       ((M)->var[I]->flags &= ~VAR_@2)
#define setVar@1(M,I)       ((M)->var[I]->flags |= VAR_@2)
#define isVar@1(M,I)        ((M)->var[I]->flags & VAR_@2)
@
@h
@:varProperty(Fixed,FIXTYPE)@
@:varProperty(Cleanup,CLEANUP)@
@:varProperty(Used,USED)@
@:varProperty(Init,INIT)@
@:varProperty(Disabled,DISABLED)@
@:varProperty(Typedef,TYPEVAR)@
@:varProperty(UDFtype,UDFTYPE)@
@:varProperty(Constant,CONSTANT)@

#define getVarConstant(M,I) ((M)->var[I]->value)
#define getVarValue(M,I) 	VALget(&(M)->var[I]->value)

#define getDestVar(P)   (P)->argv[0]
#define setDestVar(P,X)   (P)->argv[0]  =X
#define setDestType(M,P,V)  setVarType((M),getDestVar(P),V)
#define getDestType(M,P)    destinationType((M),(P))
#define getArg(P,I) (P)->argv[I]
#define setArg(P,I,R) (P)->argv[I]= R
#define getArgName(M,P,I)   getVarName((M),(P)->argv[I])
#define getArgType(M,P,I)   getVarType((M),(P)->argv[I])
#define getArgGDKType(M,P,I)      getVarGDKType((M),(P)->argv[I])

#define getEndOfLife(X,Y)  (X)->var[Y]->eolife

mal_export InstrPtr newInstruction(MalBlkPtr mb, int kind);
mal_export InstrPtr copyInstruction(InstrPtr p);
mal_export void oldmoveInstruction(InstrPtr dst, InstrPtr src);
mal_export void clrInstruction(InstrPtr p);
mal_export void freeInstruction(InstrPtr p);
mal_export void clrFunction(InstrPtr p);
mal_export Symbol newSymbol(str nme, int kind);
mal_export void freeSymbol(Symbol s);
mal_export void freeSymbolList(Symbol s);
mal_export void printSignature(stream *fd, Symbol s, int flg);
mal_export int getGDKType(int tpe);

mal_export MalBlkPtr newMalBlk(int maxvars, int maxstmts);
mal_export void resetMalBlk(MalBlkPtr mb, int stop);
mal_export int newMalBlkStmt(MalBlkPtr mb, int maxstmts);
mal_export void prepareMalBlk(MalBlkPtr mb, str s);
mal_export void freeMalBlk(MalBlkPtr mb);
mal_export MalBlkPtr copyMalBlk(MalBlkPtr mb);
mal_export void addtoMalBlkHistory(MalBlkPtr mb,str marker);
mal_export void showMalBlkHistory(MalBlkPtr mb);
mal_export MalBlkPtr getMalBlkHistory(MalBlkPtr mb,int idx);
mal_export MalBlkPtr gotoMalBlkMarker(MalBlkPtr mb, str marker);
mal_export MalBlkPtr getMalBlkMarker(MalBlkPtr mb, str marker);
mal_export void expandMalBlk(MalBlkPtr mb, int lines);
mal_export void trimMalBlk(MalBlkPtr mb);
mal_export void trimMalVariables(MalBlkPtr mb);
mal_export void trimMalVariables_(MalBlkPtr mb, bit *used, MalStkPtr glb);
mal_export void moveInstruction(MalBlkPtr mb, int pc, int target);
mal_export void insertInstruction(MalBlkPtr mb, InstrPtr p, int pc);
mal_export void removeInstruction(MalBlkPtr mb, InstrPtr p);
mal_export void removeInstructionBlock(MalBlkPtr mb, int pc, int cnt);
mal_export str operatorName(int i);

mal_export int findVariable(MalBlkPtr mb, str name);
mal_export int findTmpVariable(MalBlkPtr mb, int type);
mal_export int findVariableLength(MalBlkPtr mb, str name, int len);
mal_export malType getType(MalBlkPtr mb, str nme);
mal_export str getArgDefault(MalBlkPtr mb, InstrPtr p, int idx);
mal_export str getVarName(MalBlkPtr mb, int i);
mal_export str getRefName(MalBlkPtr mb, int i);
mal_export int newVariable(MalBlkPtr mb, str name, malType type);
mal_export int cloneVariable(MalBlkPtr dst, MalBlkPtr src, int varid);
mal_export void renameVariable(MalBlkPtr mb, int i, str name);
mal_export void resetVarName(MalBlkPtr mb, int i);
mal_export void copyVariable(MalBlkPtr dst, VarPtr v);
mal_export void removeVariable(MalBlkPtr mb, int varid);
mal_export int newTmpVariable(MalBlkPtr mb, malType type);
mal_export int newTmpSink(MalBlkPtr mb, malType type);
mal_export int newTypeVariable(MalBlkPtr mb, malType type);
mal_export void delVariable(MalBlkPtr mb, int varid);
mal_export void freeVariable(MalBlkPtr mb, int varid);
mal_export void clearVariable(MalBlkPtr mb, int varid);
mal_export int cpyConstant(MalBlkPtr mb, VarPtr vr);
mal_export int defConstant(MalBlkPtr mb, int type, ValPtr cst);
mal_export int fndConstant(MalBlkPtr mb, ValPtr cst,int depth);
mal_export str convertConstant(malType type, ValPtr vr);

mal_export int newProperty(MalBlkPtr mb);
#define varSetProperty(mb, var, name, opname, cst) \
	varSetProp(mb, var, PropertyIndex(name), PropertyOperator(opname), cst)
mal_export void varSetProp(MalBlkPtr mb, int var, int prop, int op, ValPtr cst);
mal_export str  varGetPropStr( MalBlkPtr mb, int var );
mal_export VarPtr varGetProp(MalBlkPtr mb, int var, int prop);

mal_export void pushInstruction(MalBlkPtr mb, InstrPtr p);
mal_export InstrPtr pushArgument(MalBlkPtr mb, InstrPtr p, int varid);
mal_export InstrPtr setArgument(MalBlkPtr mb, InstrPtr p, int idx, int varid);
mal_export InstrPtr pushReturn(MalBlkPtr mb, InstrPtr p, int varid);
mal_export InstrPtr pushArgumentId(MalBlkPtr mb, InstrPtr p, str name);
mal_export void delArgument(InstrPtr p, int varid);
mal_export void setVarType(MalBlkPtr mb, int i, int tpe);
mal_export void clrAllTypes(MalBlkPtr mb);
mal_export void setArgType(MalBlkPtr mb, InstrPtr p, int i, int tpe);
mal_export void setReturnArgument(InstrPtr p, int varid);
mal_export malType destinationType(MalBlkPtr mb, InstrPtr p);
mal_export void setPolymorphic(InstrPtr p, int tpe, int force);
mal_export str fcnClass(InstrPtr p);
mal_export str fcnDefinition(MalBlkPtr mb, InstrPtr p, str s, int flg, str base, size_t len);
mal_export void printInstruction(stream *fd, MalBlkPtr mb, MalStkPtr stk, InstrPtr p, int flg);
mal_export str instructionCall(MalBlkPtr mb, InstrPtr p, str s, str base, size_t len);
mal_export void promptInstruction(stream *fd, MalBlkPtr mb, MalStkPtr stk, InstrPtr p, int flg);
mal_export str instruction2str(MalBlkPtr mb, MalStkPtr stl, InstrPtr p, int hidden);
mal_export str function2str(MalBlkPtr mb, int flg);
mal_export void pushEndInstruction(MalBlkPtr mb);	/* used in src/mal/mal_parser.c */
/* Utility macros to inspect an instruction */
#define functionStart(X) ((X)->token == FUNCTIONsymbol || \
              (X)->token == COMMANDsymbol || \
              (X)->token == FACTORYsymbol )
#define patternStart(X)  ((X)->token == PATTERNsymbol)
#define functionExit(X)  ((X)->token == ENDsymbol)

#define blockStart(X)   ((X)->barrier && (((X)->barrier == BARRIERsymbol || \
             (X)->barrier == CATCHsymbol )))
#define blockExit(X) (X)->barrier == EXITsymbol
#define blockCntrl(X) ( (X)->barrier== LEAVEsymbol ||  \
             (X)->barrier== REDOsymbol || (X)->barrier== RETURNsymbol )
#define isLinearFlow(X)  !(blockStart(X) || blockExit(X) || \
				(X)->barrier== LEAVEsymbol ||  (X)->barrier== REDOsymbol )

mal_export void strBeforeCall(ValPtr v, ValPtr bak);
mal_export void strAfterCall(ValPtr v, ValPtr bak);
mal_export void batBeforeCall(ValPtr v, ValPtr bak);
mal_export void batAfterCall(ValPtr v, ValPtr bak);
#endif /*  _MAL_INSTR_H */
@c
#include "monetdb_config.h"
#include "mal_instruction.h"
#include "mal_function.h"	/* for getPC() */
#include "mal_utils.h"
#include "mal_exception.h"

Symbol
newSymbol(str nme, int kind)
{
	Symbol cur;

	if (nme == NULL) {
		GDKerror("@1:unexpected name (=null)\n");
		return NULL;
	}
	cur = (Symbol) GDKzalloc(sizeof(SymRecord));
	if (cur == NULL) {
		GDKerror("newSymbol:"MAL_MALLOC_FAIL);
		return NULL;
	}
	cur->name = putName(nme,strlen(nme));
	cur->kind = kind;
	cur->peer = NULL;
	cur->def = newMalBlk(MAXVARS, STMT_INCREMENT);
	return cur;
}

void
freeSymbol(Symbol s)
{
	if (s == NULL)
		return;
	if (s->def) {
		freeMalBlk(s->def);
		s->def = NULL;
	}
	GDKfree(s);
}

void
freeSymbolList(Symbol s)
{
	Symbol t = s;

	while (s) {
		t = s->peer;
		s->peer = NULL;
		freeSymbol(s);
		s = t;
	}
}

int
newMalBlkStmt(MalBlkPtr mb, int maxstmts)
{
	InstrPtr *p;

	p = (InstrPtr *) GDKzalloc(sizeof(InstrPtr) * maxstmts);
	if (p == NULL){
		GDKerror("newMalBlk:"MAL_MALLOC_FAIL);
		return -1;	
	}
	mb->stmt = p;
	mb->stop = 0;
	mb->ssize = maxstmts;
	if( mb->profiler){
		GDKfree(mb->profiler);
		mb->profiler = (ProfPtr) GDKzalloc( (mb->ssize + STMT_INCREMENT)*sizeof(ProfRecord));
		assert(mb->profiler);
	}
	return 0;
}

MalBlkPtr
newMalBlk(int maxvars, int maxstmts)
{
	MalBlkPtr mb;
	VarPtr *v;

	v = (VarPtr *) GDKzalloc(sizeof(VarPtr) * maxvars);
	if (v == NULL){
		GDKerror("newMalBlk:"MAL_MALLOC_FAIL);
		return NULL;
	}
	mb = (MalBlkPtr) GDKmalloc(sizeof(MalBlkRecord));
	if (mb == NULL){
		GDKerror("newMalBlk:"MAL_MALLOC_FAIL);
		return NULL;
	}

	mb->var = v;

	mb->vtop = 0;
	mb->vsize = maxvars;
	mb->help = mb->binding = NULL;
	mb->errors = 0;
	mb->alternative = NULL;
	mb->history = NULL;
	mb->keephistory = 0;
	mb->marker = 0;
	mb->maxarg = MAXARG; /* the minimum for each instruction */
	mb->typefixed = 0;
	mb->flowfixed = 0;
	mb->profiler = NULL;
	mb->ptop = mb->psize = 0;
	mb->prps = NULL;
	mb->replica = NULL;
	mb->recycle = 0;
	mb->recid = 0;
	mb->trap = 0;
	if ( newMalBlkStmt(mb, maxstmts) < 0)
		return NULL;
	return mb;
}

/*
The resetMalBlk code removes instructions, but without freeing
the space. This way the structure is prepared for re-use
*/
void
resetMalBlk(MalBlkPtr mb, int stop)
{
	mb->stop = stop;
}

/*
The freeMalBlk code is quite defensive. It is used to localize an
illegal re-use of a MAL blk.
*/
void
freeMalBlk(MalBlkPtr mb)
{
	int i;

	for (i = 0; i < mb->ssize; i++) 
		if (mb->stmt[i]){
			freeInstruction(mb->stmt[i]);
			mb->stmt[i] = NULL;
		}
	mb->stop = 0;
	for (i = 0; i < mb->vsize; i++)
		if (mb->var[i]){
			freeVariable(mb, i);
			mb->var[i] = 0;
		}
	mb->vtop = 0;
	GDKfree(mb->stmt);
	mb->stmt = 0;
	GDKfree(mb->var);
	mb->var = 0;
	if (mb->prps)
		GDKfree(mb->prps);
	mb->ptop = mb->psize = 0;
	mb->prps = NULL;

	if( mb->history)
		freeMalBlk(mb->history);
	if (mb->binding)
		GDKfree(mb->binding);
	mb->binding = 0;
	if (mb->help)
		GDKfree(mb->help);
	mb->help = 0;
	if (mb->profiler)
		GDKfree(mb->profiler);
	mb->profiler = NULL;
	GDKfree(mb);
}

/*
The routine below should assure that all referenced structures
are private. The copying is memory conservative.
*/
MalBlkPtr
copyMalBlk(MalBlkPtr old)
{
	MalBlkPtr mb;
	int i;

	mb = (MalBlkPtr) GDKzalloc(sizeof(MalBlkRecord));
	if (mb == NULL) {
		GDKerror("newMalBlk:"MAL_MALLOC_FAIL);
		return NULL;
	}
	mb->alternative = old->alternative;
	mb->history = NULL;
	mb->keephistory= old->keephistory;
	mb->marker = 0;
	mb->var = (VarPtr *) GDKzalloc(sizeof(VarPtr) * old->vsize);

	if (mb->var == NULL){
		GDKfree(mb);
		GDKerror("newMalBlk:"MAL_MALLOC_FAIL);
		return NULL;
	}
	mb->vsize = old->vsize;

	mb->vtop = 0;
	for (i = 0; i < old->vtop; i++) {
		copyVariable(mb, getVar(old, i));
		mb->vtop++;
	}

	mb->stmt = (InstrPtr *) GDKzalloc(sizeof(InstrPtr) * old->ssize);

	if (mb->stmt == NULL){
		GDKfree(mb->var);
		GDKfree(mb);
		GDKerror("newMalBlk:"MAL_MALLOC_FAIL);
		return NULL;
	}

	mb->stop = old->stop;
	mb->ssize = old->ssize;
	assert(old->stop < old->ssize);
	for (i = 0; i < old->stop; i++)
		mb->stmt[i] = copyInstruction(old->stmt[i]);

	mb->help = old->help ? GDKstrdup(old->help) : NULL;
	mb->binding = old->binding ? GDKstrdup(old->binding) : NULL;
	mb->errors = old->errors;
	mb->typefixed = old->typefixed;
	mb->flowfixed = old->flowfixed;
	mb->recycle = old->recycle;
	mb->recid = old->recid;
	mb->trap = old->trap;
	mb->replica = old->replica;
	mb->maxarg= old->maxarg;
	mb->profiler = NULL;

	mb->ptop = mb->psize = 0;
	mb->prps = NULL;
	if (old->prps) {
		mb->prps = (MalProp*) GDKzalloc(old->psize * sizeof(MalProp));
		mb->psize = old->psize;
		mb->ptop = old->ptop;
		for (i=0; i<old->ptop; i++)
			mb->prps[i] = old->prps[i]; 
	}
	return mb;
}

void
addtoMalBlkHistory(MalBlkPtr mb, str marker){
	MalBlkPtr cpy,h;
	if( mb->keephistory){
		cpy= copyMalBlk(mb);
		if ( cpy == NULL)
			return ; /* ignore history */
		cpy->history= NULL;
		mb->marker= GDKstrdup(marker);
		if( mb->history== NULL)
			mb->history= cpy;
		else{
			for( h= mb; h->history; h= h->history)
				;
			h->history= cpy;
		}
	}
}

MalBlkPtr
getMalBlkHistory(MalBlkPtr mb, int idx){
	MalBlkPtr h=mb;
	while( h && idx-- >= 0)
		h= h->history;
	return h?h:mb;
}
/*
You can retrieve the history by its marker as well.
*/
MalBlkPtr
getMalBlkMarker(MalBlkPtr mb, str marker){
	MalBlkPtr h=mb;
	while( h && h->marker && strcmp(h->marker,marker))
		h= h->history;
	return h?h:mb;
}
/*
You can roll back the history to a specific marker.
A NULL is returned when the marker can not be found.
*/
MalBlkPtr
gotoMalBlkMarker(MalBlkPtr mb, str marker){
	MalBlkPtr h=mb,g;
	while(h && h->marker && strcmp(h->marker,marker))
		h= h->history;
	if( h == NULL)
		return NULL; /* marker not found */
	while( h && h->marker && strcmp(h->marker,marker)){
		g= h;
		h= h->history;
		g->history=0;
		freeMalBlk(g);
	}
	return h;
}
/*
The MalBlk structures potentially consume a lot a of space, because it
is not possible to precisely estimate the default sizes of the var and stmt
components. The routines below provide a mechanism to handle the issue.
The expandMalBlk routine takes the number of new-lines as a parameter
and guesses the size of variable and statement table.

Experience shows that trimming leads to memory fragmentation (140K lost
after server init) and is therefore turned off.
*/
static void
trimexpand(MalBlkPtr mb, int varsize, int stmtsize)
{
	VarRecord **v;
	InstrPtr *stmt;
	int len,i;

	assert(varsize > 0 && stmtsize > 0);
	len = sizeof(ValPtr) * (mb->vtop + varsize);
	v = (VarRecord **) GDKzalloc(len);
	if (v == NULL)
		return;
	len = sizeof(InstrPtr) * (mb->ssize + stmtsize);
	stmt = (InstrPtr *) GDKzalloc(len);
	if ( stmt == NULL)
		return;

	memcpy((str) v, (str) mb->var, sizeof(ValPtr) * mb->vtop);

	for (i=mb->vtop; i< mb->vsize; i++) 
		if (mb->var[i])
			freeVariable(mb,i);
	if (mb->var)
		GDKfree(mb->var);
	mb->var = v;
	mb->vsize = mb->vtop + varsize;

	memcpy((str) stmt, (str) mb->stmt, sizeof(InstrPtr) * mb->stop);
	for (i=mb->stop; i< mb->ssize; i++) {
		if (mb->stmt[i]) {
			freeInstruction(mb->stmt[i]);
			mb->stmt[i] = NULL;
		}
	}
	GDKfree(mb->stmt);
	mb->stmt = stmt;

	mb->ssize = mb->ssize + stmtsize;
	if (mb->profiler) {
		GDKfree(mb->profiler);
		mb->profiler = 0;
	}
}
void
expandMalBlk(MalBlkPtr mb, int lines)
{
	int newlines = (int) (lines * 1.1);

	if (newlines > mb->ssize || newlines > mb->vsize)
		trimexpand(mb, newlines, newlines);
}

void
trimMalBlk(MalBlkPtr mb)
{
	(void) mb;		/* fool the compiler */
	/* printf("safe %d %ld\n", mb->vtop, (mb->vsize-mb->vtop)*sizeof(VarPtr));
	   trimexpand(mb, mb->vsize, mb->ssize); */
}

/*
Before compiling a large string, it makes sense to allocate approximately
enough space to keep the intermediate code. Otherwise, we end up with a
repeated extend on the MAL block, which really consumes a lot of memcpy
resources.
The average MAL string length could been derived from the
test cases. An error in the estimate is more expensive than
just counting the lines.

The MAL blocks act as instruction pools.
Using a resetMALblock makes the instructions available.
*/

void
prepareMalBlk(MalBlkPtr mb, str s)
{
	int cnt = STMT_INCREMENT;

	while(s){
		s= strchr(s,'\n');
		if(s) { s++; cnt++;}
	}
	expandMalBlk(mb, cnt);
}

InstrPtr
newInstruction(MalBlkPtr mb, int kind)
{
	InstrPtr p = NULL;

	if (mb && mb->stop <mb->ssize) {
		p = mb->stmt[mb->stop];

		if (p && p->maxarg < MAXARG) {
			assert(0);
			p = NULL;
		}
		mb->stmt[mb->stop] = NULL;
	}
	if (p == NULL) {
		p = GDKzalloc(MAXARG * sizeof(p->argv[0]) + sizeof(InstrRecord));
		if (p == NULL)
			return NULL;
		p->maxarg = MAXARG;
	}
	p->typechk = TYPE_UNKNOWN;
	setModuleId(p, NULL);
	setFunctionId(p, NULL);
	p->fcn = NULL;
	p->blk = NULL;
	p->polymorphic = 0;
	p->varargs = 0;
	p->recycle = 0;
	p->argc = 1;
	p->retc = 1;
	p->argv[0] = -1;	/* watch out for direct use in variable table */
/*
Flow of control instructions are always marked as an assignment
with modifier
*/
	switch (kind) {
	case BARRIERsymbol:
	case REDOsymbol:
	case LEAVEsymbol:
	case EXITsymbol:
	case RETURNsymbol:
	case YIELDsymbol:
	case CATCHsymbol:
	case RAISEsymbol:
		p->token = ASSIGNsymbol;
		p->barrier = kind;
		break;
	default:
		p->token = kind;
		p->barrier = 0;
	}
	p->gc = 0;
	p->jump = 0;
	return p;
}

/*
Copying an instruction is space conservative.
*/

InstrPtr
copyInstruction(InstrPtr p)
{
	InstrPtr new;
	new = (InstrPtr) GDKmalloc(sizeof(InstrRecord) + p->maxarg * sizeof(p->maxarg));
	assert(new);
	if (new)
		oldmoveInstruction(new, p);
	return new;
}

void
clrFunction(InstrPtr p)
{
	p->token = ASSIGNsymbol;
	p->fcn = 0;
	p->blk = 0;
	p->typechk= TYPE_UNKNOWN;
	setModuleId(p, NULL);
	setFunctionId(p, NULL);
}

void
clrInstruction(InstrPtr p)
{
	clrFunction(p);
	memset((char *) p, 0, sizeof(InstrRecord) + p->maxarg * sizeof(p->argv[0]));
}

void
freeInstruction(InstrPtr p)
{
	assert(p != 0);
	GDKfree(p);
}

/*
Moving instructions around calls for care, because all dependent
information should also be updated.
*/
void
oldmoveInstruction(InstrPtr new, InstrPtr p)
{
	int space;

	space = sizeof(InstrRecord) + p->maxarg * sizeof(p->argv[0]);
	memcpy((char *) new, (char *) p, space);
	setFunctionId(new, getFunctionId(p));
	setModuleId(new, getModuleId(p));
}

/*
Query optimizers walk their way through a MAL program block.
They require some primitives to move instructions around and
to remove superflous instructions.
The removal is based on the assumption that indeed the instruction
belonged to the block.
*/
void
removeInstruction(MalBlkPtr mb, InstrPtr p)
{
	int i;

	for (i = 0; i < mb->stop - 1; i++)
		if (mb->stmt[i] == p)
			break;

	if (i == mb->stop)
		return;

	for (; i < mb->stop - 1; i++){
		mb->stmt[i] = mb->stmt[i + 1];
		if (mb->profiler)
			mb->profiler[i]= mb->profiler[i + 1];
	}
	mb->stop--;
	assert(i==mb->stop);

	/* move statement after stop */
	mb->stmt[i] = p;
}

void
removeInstructionBlock(MalBlkPtr mb, int pc, int cnt)
{
	int i;
	InstrPtr p;

	for (i = pc; i < pc + cnt; i++) {
		p = getInstrPtr(mb, i);
		freeInstruction(p);
	}

	for (i = pc; i < mb->stop - cnt; i++)
		mb->stmt[i] = mb->stmt[i + cnt];

	mb->stop -= cnt;
	for (; i < mb->stop; i++)
		mb->stmt[i] = 0;
}

void
moveInstruction(MalBlkPtr mb, int pc, int target)
{
	InstrPtr p;
	int i;

	p = getInstrPtr(mb, pc);
	if (pc > target) {
		for (i = pc; i > target; i--)
			mb->stmt[i] = mb->stmt[i - 1];
		mb->stmt[i] = p;
	} else {
		for (i = target; i > pc; i--)
			mb->stmt[i] = mb->stmt[i - 1];
		mb->stmt[i] = p;
	}
}
void
insertInstruction(MalBlkPtr mb, InstrPtr p, int pc)
{
	pushInstruction(mb, p);	/* to ensure room */
	moveInstruction(mb, mb->stop - 1, pc);
}

/*
Beware that the first argument of a signature is reserved for the function
return type , which should be equal to the destination variable type.

VarRecords are allocated on the variable stack.
Their index is returned for future reference.

Use the information that a variable is at least one character
wide and terminated by a null-byte.
This means that we can speed up search when the variables
differ in the first two characters

Furthermore, temporary variables are already assigned to a specific
position in the variable table. This information can only be used
under the assumption that the code base is not modified on the
fly. Then the expensive search is started anyway.
It also means that input which does not comply with the intended
location of a temporary variable should be flagged as an error.
*/
@= chkTemporary
    if( isTmpName(name)){
		int j;
        i= atol(name+ (*name == TMPMARKER? 1:2));
        /* quick test validity*/
        if( i< mb->vtop && isTmpVar(mb,i) && getVarTmp(mb,i) == i)
            return i;
		for(j=0; j< mb->vtop; j++)
			if( getVarTmp(mb,j)== i && isTmpVar(mb,j)) return j;
        return -1;
    }
@
@c
/*
Temporary names are not materialized as strings unless necessary.
*/
inline str
getVarName(MalBlkPtr mb, int i)
{
	str nme;
	char buf[PATHLENGTH];

	nme = mb->var[i]->name;

	if (nme == 0) {
		snprintf(buf, PATHLENGTH, "%c%d", TMPMARKER, mb->var[i]->tmpindex);
		nme = mb->var[i]->name = GDKstrdup(buf);
	}
	return nme;
}

inline void
resetVarName(MalBlkPtr mb, int i){
	str nme;
	char buf[PATHLENGTH];

	nme = mb->var[i]->name;
	if( mb->var[i]->tmpindex && nme){
		GDKfree(nme);
		nme= 0;
	}

	if (nme == 0) {
		snprintf(buf, PATHLENGTH, "%c%d", TMPMARKER, mb->var[i]->tmpindex);
		mb->var[i]->name = GDKstrdup(buf);
	} 
}

inline str
getRefName(MalBlkPtr mb, int i)
{
	str nme;
	char buf[PATHLENGTH];

	nme = mb->var[i]->name;

	if (nme == 0) {
		snprintf(buf, PATHLENGTH, "%c%d", REFMARKER, mb->var[i]->tmpindex);
		nme = mb->var[i]->name = GDKstrdup(buf);
	}
	return nme;
}

int
findVariable(MalBlkPtr mb, str name)
{
	int i;

	@:chkTemporary@
	if (name == NULL)
		return -1;
	for (i = mb->vtop - 1; i >= 0; i--)
		if (!isTmpVar(mb, i) && idcmp(name, getVarName(mb, i)) == 0)
			return i;
	return -1;
}

int
findTmpVariable(MalBlkPtr mb, int type)
{
	int i;

	for (i = 0; i < mb->vtop; i++)
		if (isTmpVar(mb, i) && getVarType(mb, i) == type)
			return i;
	return -1;
}

/*
The second version of findVariable assumes you have not
yet allocated a private structure. This is particularly
usefull during parsing, because most variables are already
defined. This way we safe GDKmalloc/GDKfree.
*/
int
findVariableLength(MalBlkPtr mb, str name, int len)
{
	int i;
	int j;

	for (i = mb->vtop - 1; i >= 0; i--)
		if (mb->var[i] && mb->var[i]->name && !isTmpVar(mb, i)) {
			str s = mb->var[i]->name;

			j = 0;
			if (s)
				for (j = 0; j < len; j++)
					if (name[j] != s[j])
						break;
			if (j == len && s && s[j] == 0)
				return i;
		}
	/* most variables are not temporary */
	@:chkTemporary@
	return -1;
}

/*
Note that getType also checks for type names directly.
They have preference over variable names.
*/
malType
getType(MalBlkPtr mb, str nme)
{
	int i;

	i = findVariable(mb, nme);
	if (i < 0)
		return getTypeIndex(nme, -1, TYPE_any);
	return getVarType(mb, i);
}

str
getArgDefault(MalBlkPtr mb, InstrPtr p, int idx)
{
	ValPtr v = &getVarConstant(mb, getArg(p, idx));

	if (v->vtype == TYPE_str)
		return v->val.sval;
	return NULL;
}

/*
All variables are implicitly declared upon their first assignment.

Lexical constants require some care. They typically appear as arguments
in operator/function calls. To simplify program analysis later on,
we stick to the situation that function/operator arguments are always
references to by variables.

Reserved words
Although MAL has been designed as a minimal language, several
identifiers are not eligible as variables. The encoding below
is geared at simple and speed.
*/
#if 0
int
isReserved(str nme)
{
	switch (*nme) {
	case 'A':
	case 'a':
		if (idcmp("atom", nme) == 0)
			return 1;
		break;
	case 'B':
	case 'b':
		if (idcmp("barrier", nme) == 0)
			return 1;
		break;
	case 'C':
	case 'c':
		if (idcmp("command", nme) == 0)
			return 1;
		break;
	case 'E':
	case 'e':
		if (idcmp("exit", nme) == 0)
			return 1;
		if (idcmp("end", nme) == 0)
			return 1;
		break;
	case 'F':
	case 'f':
		if (idcmp("false", nme) == 0)
			return 1;
		if (idcmp("function", nme) == 0)
			return 1;
		if (idcmp("factory", nme) == 0)
			return 1;
		break;
	case 'I':
	case 'i':
		if (idcmp("include", nme) == 0)
			return 1;
		break;
	case 'M':
	case 'm':
		if (idcmp("module", nme) == 0)
			return 1;
		if (idcmp("macro", nme) == 0)
			return 1;
		break;
	case 'O':
	case 'o':
		if (idcmp("orcam", nme) == 0)
			return 1;
		break;
	case 'P':
	case 'p':
		if (idcmp("pattern", nme) == 0)
			return 1;
		break;
	case 'T':
	case 't':
		if (idcmp("thread", nme) == 0)
			return 1;
		if (idcmp("true", nme) == 0)
			return 1;
		break;
	}
	return 0;
}
#endif

/*
Beware, the symbol table structure assumes that it is relatively
cheap to perform a linear search to a variable or constant.
*/

@= makeVarSpace
	if (mb->vtop >= mb->vsize){
		VarPtr *new;
		int s= mb->vtop + MAXVARS;

		new= (VarPtr *) GDKzalloc(s * sizeof(VarPtr));
		/*printf("generate new variable block %d\n",s);*/
		if( new== NULL ){
				mb->errors++;
				showScriptException(mb,0,MAL,"newMalBlk:no storage left\n");
				return mb->vtop;
		}
		memcpy((char*)new, (char*)mb->var, sizeof(VarPtr) * mb->vtop);
		GDKfree(mb->var);
		mb->vsize= s;
		mb->var= new;
	}
@
@c
int
newVariable(MalBlkPtr mb, str name, malType type)
{
	int n;

	if (name == NULL)
		return -1;
	@:makeVarSpace@
	if (isTmpName(name)) {
		int i = atol(name+ (*name == TMPMARKER? 1:2));

		/* test validity */
		if (i > mb->vtop) {
			showScriptException(mb,0,MAL,
				"newVariable:variable %s mis-aligned\n", name);
			mb->errors++;
		} else if (i < mb->vtop ) {
			showScriptException(mb,0,MAL,
				"'%s' overwrites %s\n", name, getVarName(mb, i));
			mb->errors++;
		}
	}
	n = mb->vtop;
	if (getVar(mb, n) == NULL)
		getVar(mb, n) = (VarPtr) GDKzalloc(sizeof(VarRecord) + MAXARG * sizeof(int));
	mb->var[n]->name = name;
	mb->var[n]->propc = 0;
	mb->var[n]->maxprop = MAXARG;

	setVarType(mb, n, type);
	clrVarFixed(mb, n);
	clrVarUsed(mb, n);
	clrVarInit(mb, n);
	clrVarDisabled(mb, n);
	clrVarUDFtype(mb, n);
	clrVarConstant(mb, n);
	clrVarCleanup(mb, n);
	mb->vtop++;
	return n;
}
/*
Simplified cloning without property propagation.
*/
int
cloneVariable(MalBlkPtr tm, MalBlkPtr mb, int x)
{
	int res;
	if ( isVarConstant(mb,x))
		res = cpyConstant(tm, getVar(mb,x));
	else
	if ( isTmpVar(mb,x))
		res = newTmpVariable(tm, getVarType(mb,x));
	else
		res = newVariable(tm,GDKstrdup(getVarName(mb,x)), getVarType(mb,x));
	if (isVarFixed(mb, x) )
		setVarFixed(tm,res);
	if (isVarUsed(mb, x) )
		setVarUsed(tm, res);
	if (isVarInit(mb, x) )
		setVarInit(tm, res);
	if (isVarDisabled(mb, x) )
		setVarDisabled(tm,res);
	if (isVarUDFtype(mb, x) )
		setVarUDFtype(tm, res);
	if (isVarCleanup(mb, x) )
		setVarCleanup(tm,res);
	return res;
}

void
renameVariable(MalBlkPtr mb, int id, str name)
{
	VarPtr v;
	assert(id >=0 && id <mb->vtop);
	v = getVar(mb, id);

	if (v->name)
		GDKfree(v->name);
	v->name = name;
	v->tmpindex = 0;
}

int
newTmpVariable(MalBlkPtr mb, malType type)
{
	int n;

	@:makeVarSpace@
	n = mb->vtop;
	if (getVar(mb, n) == NULL)
		getVar(mb, n) = (VarPtr) GDKzalloc(sizeof(VarRecord) + MAXARG * sizeof(int));
	getVarTmp(mb, n) = n;
	setVarType(mb, n, type);
	mb->var[n]->propc = 0;
	mb->var[n]->maxprop = MAXARG;
	mb->vtop++;
	return n;
}

int
newTmpSink(MalBlkPtr mb, malType type)
{
	int n;

	n = type == TYPE_any ? -1 : findTmpVariable(mb, type);
	if (n >= 0)
		return n;
	return newTmpVariable(mb, type);
}

int
newTypeVariable(MalBlkPtr mb, malType type)
{
	int n;

	n = type == TYPE_any ? -1 : findTmpVariable(mb, type);
	if (n > 0 && isVarTypedef(mb, n))
		return n;
	n = newTmpVariable(mb, type);
	setVarTypedef(mb, n);
	return n;
}

void
delVariable(MalBlkPtr mb, int varid)
{
	if (varid == mb->vtop - 1) {
		GDKfree(getVar(mb, varid));
		getVar(mb, varid) = 0;
		mb->vtop--;
	}
}
void
copyVariable(MalBlkPtr dst, VarPtr v)
{
	int i;
	VarPtr w;

	assert(v->propc <= v->maxprop);
	w = (VarPtr) GDKzalloc(sizeof(VarRecord) + v->maxprop * sizeof(int));
	w->name = v->name ? GDKstrdup(v->name) : 0;
	w->type = v->type;
	w->flags = v->flags;
	w->tmpindex = v->tmpindex;
	w->propc = v->propc;
	w->maxprop = v->maxprop;
	for (i=0; i<v->propc; i++)
		w->prps[i] = v->prps[i];

	VALcopy(&w->value, &v->value);
	dst->var[dst->vtop] = w;
}

/*
Beware, removing a variable
calls for a re-numbering of the variable indices used in the
program block. Assuming all new variables are appended only, we
merely have to take care of variable deletions.
*/
void
removeVariable(MalBlkPtr mb, int varid)
{
	int i, j;
	InstrPtr p;

	for (i = 0; i < mb->stop; i++) {
		p = getInstrPtr(mb, i);
		for (j = 0; j < p->argc; j++)
			if (p->argv[j] > varid)
				p->argv[j]--;
	}
	/* remove the variable from the symbol table */
	freeVariable(mb, varid);
	for (i = varid; i < mb->vtop - 1; i++)
		mb->var[i] = mb->var[i + 1];

	mb->vtop--;
}

void
clearVariable(MalBlkPtr mb, int varid)
{
	VarPtr v;

	v = getVar(mb, varid);
	if (v == 0)
		return;
	if (v->name)
		GDKfree(v->name);
	if (isVarConstant(mb,varid) || isVarDisabled(mb, varid))
		VALclear(&v->value);
	v->name = 0;
	v->type = 0;
	v->flags = 0;
	v->tmpindex = 0;
	v->propc = 0;
	v->eolife = 0;
}

void
freeVariable(MalBlkPtr mb, int varid)
{
	VarPtr v;

	v = getVar(mb, varid);
	clearVariable(mb, varid);
	GDKfree(v);
	getVar(mb, varid) = NULL;
}

/*
A special action is to reduce the variable space by removing
all that do not contribute.
Beware that properties are represented as variables as well.
They must be retained and the references must be corrected
after the stack has been reduced.
*/
void
trimMalVariables_(MalBlkPtr mb, bit *used, MalStkPtr glb)
{
	int *vars, cnt = 0, i, j;
	InstrPtr q;

	vars= (int *) GDKzalloc(mb->vtop * sizeof(int));
	if (vars == NULL)
		return;					/* forget it if we run out of memory */

	/* build the alias table */
	for (i = 0; i < mb->vtop; i++) {
		if (used[i] == 0){
			if ( glb && isVarConstant(mb,i) )
				VALclear(&glb->stk[i]);
			freeVariable(mb, i);
			continue;
		}

		/* valgrind finds a leak when we move these variable 
		   record pointers around. */
		if (i>cnt) {
			/* remap temporary variables */
			VarRecord *t = mb->var[cnt];
			if (isTmpVar(mb,i))
				getVarTmp(mb,i) = cnt;
			mb->var[cnt] = mb->var[i];
			mb->var[i] = t;
			resetVarName(mb,cnt);
		}
		vars[i] = cnt;
		if (glb && i != cnt){
			glb->stk[cnt]= glb->stk[i];
			VALempty(&glb->stk[i]);
		}
		cnt++;
	}
#ifdef DEBUG_REDUCE
	mnstr_printf(GDKout, "Variable reduction %d -> %d\n", mb->vtop, cnt);
	for(i=0; i<mb->vtop;i++)
		mnstr_printf(GDKout,"map %d->%d\n",i, vars[i]);
#endif

	/* remap all variable references to their new position. */
	if (cnt < mb->vtop) {
		for (i = 0; i < mb->stop; i++) {
			q = getInstrPtr(mb, i);
			for (j = 0; j < q->argc; j++)
				getArg(q, j) = vars[getArg(q, j)];
		}
		for( i=0; i< mb->ptop; i++){
			MalProp *p= mb->prps+i;

			if (p->var)
				p->var = vars[p->var];
		}
	}
#ifdef DEBUG_REDUCE
	mnstr_printf(GDKout, "After reduction \n");
	printFunction(GDKout,mb,0,0);
#endif
	GDKfree(vars);
	mb->vtop = cnt;
}
void
trimMalVariables(MalBlkPtr mb){
	bit *used;
	int i, j;
	InstrPtr q;

	used= (bit *) GDKzalloc(mb->vtop);

	/* build the use table */
	for(i=0; i<mb->stop; i++){
		q= getInstrPtr(mb,i);

		for(j=0; j<q->argc; j++)
			used[getArg(q,j)] = 1;
	}
	for (i=0; i<mb->ptop; i++) {
		if (mb->prps[i].var)
			used[mb->prps[i].var] = 1;
	}
	trimMalVariables_(mb, used, 0);
	GDKfree(used);
}

/* MAL constants
Constants are stored in the symbol table and referenced
by a variable identifier.
This means that per MAL instruction, we may end up with
MAXARG entries in the symbol table. This may lead to long
searches for variables.
An optimization strategy deployed in the current
implementation is to look around for
a similar (constant) definition and to reuse its identifier.
This avoids an exploding symbol table with a lot
of temporary variables (as in tst400cHuge)

But then the question becomes how far to search?
Searching through all variables is only useful when the list remains short
or when the constant-variable-name is easily derivable from its literal
value and a hash-based index leads you quickly to it.

For the time being, we use a MAL system parameter, MAL_VAR_WINDOW,
to indicate the number of symbol table entries to consider.
Setting it to >= MAXARG will at least capture repeated use of a constant
within a single function call or repeated use within a small block
of code.

The final step is to prepare a GDK value record, from which
the internal representation can be obtained during
MAL interpretation.

The constant values are linked together to improve searching them.
This start of the constant list is kept in the MalBlk.

Conversion of a constant to another type is limited to
well-known coercion rules. Errors are reported and the
nil value is set.
*/
/**
 * Converts the constant in vr to the MAL type type.  Conversion is done
 * in the vr struct.
 */
str
convertConstant(int type, ValPtr vr)
{
	if( vr->vtype == type)
		return MAL_SUCCEED;
	if( vr->vtype == TYPE_str){
		int ll = 0;
		ptr d = NULL;

		ATOMfromstr(type, &d, &ll, vr->val.sval);
		if (d == NULL ) {
			VALinit(vr, type, ATOMnilptr(type));
			throw(SYNTAX, "convertConstant", "parse error in '%s'", vr->val.sval);
		}
		if ( strncmp(vr->val.sval,"nil",3)!= 0 &&
                ATOMcmp(type, vr, ATOMnilptr(type)) ==0){
			GDKfree(d);
			VALinit(vr, type, ATOMnilptr(type));
			throw(SYNTAX, "convertConstant", "parse error in '%s'", vr->val.sval);
		}
		VALset(vr, type, d);
		if (ATOMextern(type) == 0)
			GDKfree(d);
		if ( vr->vtype != type)
			throw(SYNTAX, "convertConstant", "coercion failed in '%s'", vr->val.sval);
	}
	
	if (type== TYPE_bat ||isaBatType(type)){
		/* BAT variables can only be set to nil */
		vr->vtype = type;
		vr->val.bval = 0;
		return MAL_SUCCEED;
	}
	switch (ATOMstorage(type)) {
	case TYPE_any:
	/* In case *DEBUG*_MAL_INSTR is not defined and assertions are disabled,
	 * this will fall-through to the type cases below, rather than triggering an exception.
	 * Is this correct/intended like this??
	 */
#ifdef DEBUG_MAL_INSTR
		throw(SYNTAX, "convertConstant", "missing type");
#else
		assert(0);
#endif
	case TYPE_bit:
	case TYPE_chr:
	case TYPE_sht:
	case TYPE_int:
	case TYPE_void:
	case TYPE_oid:
	case TYPE_flt:
	case TYPE_dbl:
	case TYPE_wrd:
	case TYPE_lng:
		VALconvert(type,vr);
		if ( vr->vtype != type)
			throw(SYNTAX, "convertConstant", "coercion failed");
		return MAL_SUCCEED;
	case TYPE_str:
		{ str w=0;
		  if( vr->vtype == TYPE_void || ATOMcmp(vr->vtype, ATOMnilptr(vr->vtype), VALptr(vr)) == 0){
			vr->vtype = type;
			vr->val.sval = GDKstrdup(str_nil);
			vr->len = (int) strlen(vr->val.sval);
			return MAL_SUCCEED;
		  }
		  if( vr->vtype == TYPE_chr){
			w= GDKstrdup("a");
			*w = vr->val.cval[0];
		  } else
			ATOMformat(vr->vtype, VALptr(vr), &w);
			assert(w != NULL);
			vr->vtype= TYPE_str;
			vr->len = (int)strlen(w);
			vr->val.sval= w;
		  /* VALset(vr, type, w); does not use TYPE-str */
		}
		if ( vr->vtype != type)
			throw(SYNTAX, "convertConstant", "coercion failed");
		return MAL_SUCCEED;

	case TYPE_bat:
		/* BAT variables can only be set to nil */
		vr->vtype = type;
		vr->val.bval = 0;
		return MAL_SUCCEED;
	case TYPE_ptr:
		/* all coercions should be avoided to protect against memory probing */
		if (vr->vtype == TYPE_void) {
			vr->vtype = type;
			vr->val.pval = 0;
			return MAL_SUCCEED;
		}
		/*
		if (ATOMcmp(vr->vtype, ATOMnilptr(vr->vtype), VALptr(vr)) == 0) {
			vr->vtype = type;
			vr->val.pval = 0;
			return MAL_SUCCEED;
		}
		if (vr->vtype == TYPE_int) {
			char buf[BUFSIZ];
			int ll = 0;
			ptr d = NULL;

			snprintf(buf, BUFSIZ, "%d", vr->val.ival);
			(*BATatoms[type].atomFromStr) (buf, &ll, &d);
			if( d==0 ){
				VALinit(vr, type, BATatoms[type].atomNull);
				throw(SYNTAX, "convertConstant", "conversion error");
			}
			VALset(vr, type, d);
			if (ATOMextern(type) == 0 )
				GDKfree(d);
		}
		*/
		if ( vr->vtype != type)
			throw(SYNTAX, "convertConstant", "pointer conversion error");
		return MAL_SUCCEED;
/*
Extended types are always represented as string literals
and converted to the internal storage structure.
Beware that the typeFromStr routines generate storage space
for the new value. This should be garbage collected at the
end.
*/
	default:{
		int ll = 0;
		ptr d = NULL;

		if( isaBatType(type)){
			VALinit(vr, TYPE_bat, ATOMnilptr(TYPE_bat));
			break;
		}
		/* see if an atomFromStr() function is available */
		if (BATatoms[type].atomFromStr == 0)
			throw(SYNTAX, "convertConstant", "no conversion operator defined");

		/* if the value we're converting from is nil, the to
		 * convert to value will also be nil */
		if (ATOMcmp(vr->vtype, ATOMnilptr(vr->vtype), VALptr(vr)) == 0) {
			VALinit(vr, type, ATOMnilptr(type));
			vr->vtype = type;
			break;
		}

		/* if what we're converting from is not a string */
		if (vr->vtype != TYPE_str) {
			/* an extern type */
			str w = 0;

			/* dump the non-string atom as string in w */
			ATOMformat(vr->vtype, VALptr(vr), &w);
			/* and try to parse it from string as the desired type */
			ATOMfromstr(type, &d, &ll, w);
			if (d == 0) {
				VALinit(vr, type, ATOMnilptr(type));
				GDKfree(w);
				throw(SYNTAX, "convertConstant", "conversion error");
			}
			memset((char*)vr, 0, sizeof(*vr));
			VALset(vr, type, d);
			if (ATOMextern(type) == 0)
				GDKfree(d);
			GDKfree(w);
		} else { /* what we're converting from is a string */
			ATOMfromstr(type, &d, &ll, vr->val.sval);
			if (d == NULL) {
				VALinit(vr, type, ATOMnilptr(type));
				throw(SYNTAX, "convertConstant", "conversion error");
			}
			VALset(vr, type, d);
			if (ATOMextern(type) == 0)
				GDKfree(d);
		}
	}
	}
	if (vr->vtype != type)
		throw(SYNTAX, "convertConstant", "conversion error");
	return MAL_SUCCEED;
}

int
fndConstant(MalBlkPtr mb, ValPtr cst, int depth)
{
	int i, k;
	ptr p = VALget(cst);

	k = mb->vtop - depth;
	if (k < 0)
		k = 0;
	for (i = mb->vtop - 1; i >= k; i--) {
		VarPtr v = getVar(mb, i);

		if (v && isVarConstant(mb,i) &&
			v->type == cst->vtype && p &&
			ATOMcmp(cst->vtype, VALget(&v->value), p) == 0)
			return i;
	}
	return -1;
}

int
cpyConstant(MalBlkPtr mb, VarPtr vr)
{
	int i;
	ValRecord cst;

	VALcopy(&cst, &vr->value);

	i = defConstant(mb, vr->type, &cst);
	return i;
}

int
defConstant(MalBlkPtr mb, int type, ValPtr cst )
{
	int k;
	ValPtr vr;
	str msg;

	if (isaBatType(type) && cst->vtype == TYPE_void){
		cst->vtype = TYPE_bat;
		cst->val.bval = 0;
	} else
	if (cst->vtype != type && !isaBatType(type) && !isPolyType(type)){
		ValRecord vr = *cst;
		int otype = cst->vtype;
		assert(type != TYPE_any);  /* help Coverity */
		msg= convertConstant(type, cst);
		if (msg) {
			str ft,tt;

			/* free old value */
			ft= getTypeName(otype);
			tt= getTypeName(type);
			showException(SYNTAX, "defConstant", "constant coercion error from %s to %s", ft,tt);
			GDKfree(ft);
			GDKfree(tt);
			mb->errors++;
			GDKfree(msg);
		} else {
			assert(cst->vtype== type);
		}
		VALclear(&vr);
	}
	k= fndConstant(mb,cst,MAL_VAR_WINDOW);
	if( k >= 0 ) {
		/* protect against leaks coming from constant reuse */
		if (ATOMextern(type) && cst->val.pval)
			VALclear(cst);
		return k;
	}
	k = newTmpVariable(mb, type);
	setVarConstant(mb, k);
	setVarFixed(mb, k);
	if (type == TYPE_str ||
		(type >= 0 && type < TYPE_any && BATatoms[type].atomDestroy))
		setVarCleanup(mb, k);
	else clrVarCleanup(mb, k);
	vr = &getVarConstant(mb, k);
	*vr = *cst;
	return k;
}

/* Argument handling
The number of arguments for procedures is currently limited.
Furthermore, we should assure that no variable is referenced
before being assigned.
Failure to obey should mark the instruction as type-error.
*/
InstrPtr
pushArgument(MalBlkPtr mb, InstrPtr p, int varid)
{
	if (p->argc + 1 == p->maxarg) {
		InstrPtr pn;
		int pc = 0,pclimit;
		int space = p->maxarg * sizeof(p->argv[0]) + sizeof(InstrRecord);
		pn = GDKmalloc(space + MAXARG * sizeof(p->maxarg));
		if (pn == NULL){
			/* this is almost deadly, we abort by not extending
			   the instruction, which leads to detection of errors
			   later in the pipeline. 
			*/
			return p;
		}
		memcpy((char *) pn, (char *) p, space);
		pn->maxarg += MAXARG;
		/* instructions are either created in isolation or
		   are stored on the program instruction stack already.
		   In the latter case, we may have to adjust their reference.
		   It does not make sense to locate it on the complete stack,
		   because this would jeopardise long MAL program.

		   The alternative to this hack is to change the code in many places
		   and educate the programmer to not forget updating the stmtblock
		   after pushing the arguments. In sql_gencode this alone would be
		   >100 places and in the optimizers > 30. In almost all cases
	       the instructions have few parameters.
		 */
		pclimit= mb->stop-8;
		pclimit= pclimit<0? 0: pclimit;
		for(pc= mb->stop-1; pc >= pclimit; pc--)
		if( mb->stmt[pc]== p){
			mb->stmt[pc] = pn;
			break;
		}
		/* we have to keep track on the maximal arguments/block
		  because it is needed by the interpreter */
		if( mb->maxarg < pn->maxarg)
			mb->maxarg= pn->maxarg;
		GDKfree(p);
		p = pn;
	}
	p->argv[p->argc++] = varid;
	return p;
}

InstrPtr
setArgument(MalBlkPtr mb, InstrPtr p, int idx, int varid)
{
	int i;

	p = pushArgument(mb, p, varid);	/* make space */
	for (i = p->argc - 1; i > idx; i--)
		getArg(p, i) = getArg(p, i - 1);
	getArg(p, i) = varid;
	return p;
}

InstrPtr
pushReturn(MalBlkPtr mb, InstrPtr p, int varid)
{
	if (p->retc == 1 && p->argv[0] == -1) {
		p->argv[0] = varid;
		return p;
	}
	p =setArgument(mb,p,p->retc,varid);
	p->retc++;
	return p;
}

/*
Store the information of a destination variable in the signature structure of
each instruction. This code is largely equivalent to pushArgument,
but it is more efficient in searching and collecting the information.
TODO
*/
InstrPtr
pushArgumentId(MalBlkPtr mb, InstrPtr p, str name)
{
	int v;

	v = findVariable(mb, name);
	if (v < 0)
		v = newVariable(mb, name, getTypeIndex(name, -1, TYPE_any));
	else
		GDKfree(name);
	return pushArgument(mb, p, v);
}

/*
The alternative is to remove arguments from an instruction record.
This is typically part of instruction constructions.
*/
void
delArgument(InstrPtr p, int idx)
{
	int i;

	for (i = idx; i < p->argc - 1; i++)
		p->argv[i] = p->argv[i + 1];
	p->argc--;
	if (idx < p->retc)
		p->retc--;
}

int
getGDKType(int tpe){
	return tpe <= TYPE_str ? tpe : (tpe == TYPE_any ? TYPE_void : findGDKtype(tpe));
}

void
setVarType(MalBlkPtr mb, int i, int tpe)
{
	VarPtr v;
	v = mb->var[i];

	v->type = tpe;
}

/*
Cleaning a variable type by setting it to TYPE_any
possibly invalidates all other type derivations in the program.
Beware of the exception variables. They are globally known.
*/
void
clrAllTypes(MalBlkPtr mb)
{
	int i;
	InstrPtr p;

	p= getInstrPtr(mb,0);

	for(i=p->argc; i<mb->vtop; i++)
	if( !isVarUDFtype(mb,i) &&
		isVarUsed(mb,i) &&
		!isVarTypedef(mb,i) &&
		!isVarConstant(mb,i) && 
		!isExceptionVariable(mb->var[i]->name)){
			setVarType(mb,i,TYPE_any);
			clrVarCleanup(mb,i);
			clrVarFixed(mb,i);
	}
	for(i=1; i<mb->stop-1; i++){
		p= getInstrPtr(mb,i);
		p->typechk= TYPE_UNKNOWN;
		p->fcn= 0;
		p->blk= NULL;

		switch(p->token){
		default:
			p->token= ASSIGNsymbol;
		case RAISEsymbol:
		case CATCHsymbol:
		case RETURNsymbol:
		case LEAVEsymbol:
		case YIELDsymbol:
		case EXITsymbol:
		case NOOPsymbol:
			break;
		case ENDsymbol:
			return;
		}
	}
}

void
setArgType(MalBlkPtr mb, InstrPtr p, int i, int tpe)
{
	assert (p->argv[i] < mb->vsize);
	mb->var[getArg(p, i)]->type = tpe;
}

void
setReturnArgument(InstrPtr p, int i)
{
	setDestVar(p, i);
}

malType
destinationType(MalBlkPtr mb, InstrPtr p)
{
	if (p->argc > 0)
		return getVarType(mb, getDestVar(p));
	return TYPE_any;
}

/*
For polymorphic instructions we should keep around the
maximal index to later allocate sufficient space
for type resolutions maps.
Beware, that we only consider the instruction polymorphic
if it has an index or belongs to the signature.
In other cases it merely has to be filled.
*/
inline void
setPolymorphic(InstrPtr p, int tpe, int force)
{
	int c1 = 0, c2 = 0;

	if (force == FALSE && tpe == TYPE_any)
		return;
	if (isaBatType(tpe)) {
		if (getHeadIndex(tpe) > 0)
			c1 = getHeadIndex(tpe);
		else if (getHeadType(tpe) == TYPE_any)
			c1 = 1;
	}
	if (getTailIndex(tpe) > 0)
		c2 = getTailIndex(tpe);
	else if (getTailType(tpe) == TYPE_any)
		c2 = 1;
	c1 = c1 > c2 ? c1 : c2;
	if (c1 > 0 && c1 >= p->polymorphic)
		p->polymorphic = c1 + 1;

}

/*
Instructions are simply appended to a MAL block.
It is also the place to collect information to speed-up use later on.
*/
void
pushInstruction(MalBlkPtr mb, InstrPtr p)
{
	int i;

	i = mb->stop;
	if (i + 1 >= mb->ssize) {
		int space = (mb->ssize + STMT_INCREMENT) * sizeof(InstrPtr);
		InstrPtr *newblk = (InstrPtr *) GDKzalloc(space);

		if (newblk == NULL) {
			mb->errors++;
			showException(MAL, "pushInstruction", "out of memory (requested: %d bytes)", space);
			return;
		}
		memcpy(newblk, mb->stmt, mb->ssize * sizeof(InstrPtr));

		/* also extend the storage space for the profiler */
		/* left to the environment */
		if( mb->profiler){
			ProfPtr old = mb->profiler;
			int osize = mb->ssize;
			mb->profiler = (ProfPtr) GDKzalloc( (mb->ssize + STMT_INCREMENT)*sizeof(ProfRecord));
			assert(mb->profiler);
			memcpy((char*) mb->profiler, (char*) old, sizeof(ProfRecord)*osize);
			GDKfree(old);
		}
		mb->ssize += STMT_INCREMENT;
		GDKfree(mb->stmt);
		mb->stmt = newblk;
	}
/*
If the destination variable has not been set, introduce a temporary
variable to hold the result instead.
*/
/*
	if (p->argv[0] < 0)
		p->argv[0] = newTmpVariable(mb, TYPE_any);
*/
	assert(p->argc == 0 || p->argv[0]>=0);
	if (mb->stmt[i]) {
		/* if( getModuleId(mb->stmt[i] ) )
		   printf("Garbage collect statement %s.%s\n",
		   getModuleId(mb->stmt[i]), getFunctionId(mb->stmt[i])); */
		freeInstruction(mb->stmt[i]);
	}
	mb->stmt[i] = p;

	mb->stop++;
}

/*
The END instruction has an optional name, which is only checked
during parsing;
*/
void
pushEndInstruction(MalBlkPtr mb)
{
	InstrPtr p;

	p = newInstruction(mb, ENDsymbol);
	p->argc = 0;
	p->retc = 0;
	p->argv[0] = 0;
	pushInstruction(mb, p);
}

/* Reverse programming
Since MAL programs can be created on the fly by linked-in query
compilers, or transformed by optimizers, it becomes
mandatory to be able to produce textual correct MAL programs
from its internal representation.

No guarantee is given to produce the exact input for a reversed
MAL program, except that the output can be fed back for
interpretation. Provided, the code did not produce an error.

The hiddenInstruction operator assumes a sufficiently large block
to leave information on the signature behind.

The protection against overflow is not tight.
*/
#define advance(X,B,L)  assert(X< B+L); while(*(X) && B+L>X)(X)++;

str
instructionCall(MalBlkPtr mb, InstrPtr p, str s, str base, size_t len)
{
	int i, closing = 0;
	str tpe;
	if (p->retc > 1) {
		*s++ = '(';
		*s = 0;
	}
	for (i = 0; i <= p->argc; i++) {
		if (i == p->retc) {
			if (i > 1 && p->retc > 1) {
				*s++ = ')';
				*s = 0;
			}
			if (p->blk && p->blk->binding) {
				snprintf(s, (len - (s - base)), " := %s(", p->blk->binding);
				closing = 1;
			} else if (getFunctionId(p)) {
				snprintf(s, (len - (s - base)), " := %s.%s(", getModuleId(p), getFunctionId(p));
				closing = 1;
			} else if (p->argc > p->retc)
				sprintf(s, " := ");
			advance(s, base, len);
		}
		if (i < p->argc && p->argv[i] >= 0) {
			str nme;
			char nmebuf[PATHLENGTH];

			tpe = getTypeName(getArgType(mb, p, i));
			if (isTmpVar(mb, getArg(p, i)) || isVarTypedef(mb, getArg(p, i))) {
				snprintf(nmebuf, PATHLENGTH, "%c%d", TMPMARKER, getVarTmp(mb, getArg(p, i)));
				nme = nmebuf;
			} else
				nme = getArgName(mb, p, i);
			snprintf(s, (len - (s - base)), "%s:%s", (nme ? nme : "nil"), tpe);
			advance(s, base, len);
			if (i != p->retc - 1 && i < p->argc - 1)
				sprintf(s, ", ");

			GDKfree(tpe);
			advance(s, base, len);
		}
	}
	if (closing)
		*s++ = ')';
	*s = 0;
	return s;
}

static str
hiddenInstructionArgs(MalBlkPtr mb, InstrPtr p, str s, str start, int flg, str base, size_t len)
{
	int i;

	i= (int)(s-start);
	while (i++< 40) *s++= ' ';	/* to give a better look to most programs */
	*s = 0;
	snprintf(s, (len-(s-base)), "#%3d ", getPC(mb, p));
	advance(s,base,len);
	if (p->token == REMsymbol )
		return s;
	s = instructionCall(mb,p,s, base, len);
/*
The instruction is complemented with simple flags to ease debugging.
To limit the impact on test output, we only display them when they
are set.

D = debug the function call
U = types not yet resolved
P = polymorphic instruction
G = subject to garbage control
R = subject to recycler control
J = jump towards other statement
*/
	if (flg & LIST_MAL_STMT){
		*s++ =' ';
		*s++ ='{';
		switch( p->typechk){
		case TYPE_UNKNOWN:
			*s++ ='U'; break;
		case TYPE_RESOLVED:
			/* implicit *s++ =' '; */ break;
		}
		if ( mb->trap && mb->stmt[0] == p)
			*s++ ='D';
		if (p->polymorphic)
			*s++ ='P';
		if (p->gc)
			*s++ ='G';
		if (p->recycle)
			*s++ ='R';
		if (p->jump){
			sprintf(s, "J%d", p->jump);
			advance(s,base,len);
		}
		if( *(s-1) != '{')
			*s++ ='}';
		else s--;
		*s=0;
	}
	advance(s,base,len);
	return s;
}

/*
It receives the space to store the definition
The MAL profiler dumps some performance data at the
beginning of each line.
*/

@= showParam
        tpe= getTypeName(getArgType(mb,p,i));
	if (flg & LIST_MAL_PROPS)
		pstring = varGetPropStr(mb, getArg(p,i));
	else pstring = 0;
	advance(t,base,len);
	snprintf(t,(len-(t-base)),"%s%s", (*getArgName(mb,p,i) == TMPMARKER?"X":""), getArgName(mb, p, i));
	advance(t,base,len);
	snprintf(t,(len-(t-base)),":%s%s",tpe, (pstring?pstring:""));
	advance(t,base,len);
	if( i<p->@1-1) sprintf(t,",");
	if(pstring) { GDKfree(pstring); pstring=0;}
	GDKfree(tpe);
@
@c
str
fcnClass(InstrPtr p)
{
	return operatorName(p->token);
}

str
fcnDefinition(MalBlkPtr mb, InstrPtr p, str s, int flg, str base, size_t len)
{
	int i;
	str t, tpe, pstring= NULL;

	t = s;
	snprintf(t,(len-(t-base)), "%s%s ", (flg ? "" : "#"), fcnClass(p));

	advance(t,base,len);
	if (getModuleId(p))
		snprintf(t,(len-(t-base)), "%s.", getModuleId(p));
	else
		snprintf(t,(len-(t-base)),"user.");
	advance(t,base,len);

	pstring = varGetPropStr(mb, getArg(p,0));
	if( pstring ) {
		snprintf(t,(len-(t-base)),"%s%s(", getFunctionId(p),pstring);
		GDKfree(pstring);
	} else 
		snprintf(t,(len-(t-base)),"%s(", getFunctionId(p));
	for (i = p->retc; i < p->argc; i++) {
		@:showParam(argc)@
	}

	advance(t,base,len);
	if (p->varargs & VARARGS)
		sprintf(t, "...");
	advance(t,base,len);
	if (p->retc == 1) {
		tpe = getTypeName(getArgType(mb, p, 0));
		snprintf(t,(len-(t-base)),"):%s", tpe);
		advance(t,base,len);
		if (p->varargs & VARRETS)
			sprintf(t, "...");
		GDKfree(tpe);
		advance(t,base,len);
	} else {
		sprintf(t, ") (");
		t += 3;
		for (i = 0; i < p->retc; i++) {
		@:showParam(retc)@}
		if (p->varargs & VARRETS)
			sprintf(t, "...");
		advance(t,base,len);
		*t++ = ')';
	}
	if (mb->binding)
		snprintf(t,(len-(t-base))," address %s;", mb->binding);
	else
		sprintf(t, ";");
	if (flg & LIST_MAL_DETAIL) {
		advance(t,base,len);
		hiddenInstructionArgs(mb, p, t,s, flg,base,len);
	}
	return s;
}

str
operatorName(int i)
{
	switch (i) {
	case ASSIGNsymbol:
		return ":=";
	case BARRIERsymbol:
		return "barrier";
	case REDOsymbol:
		return "redo";
	case LEAVEsymbol:
		return "leave";
	case EXITsymbol:
		return "exit";
	case RETURNsymbol:
		return "return";
	case YIELDsymbol:
		return "yield";
	case CATCHsymbol:
		return "catch";
	case RAISEsymbol:
		return "raise";
	case ENDsymbol:
		return "end";
	case FUNCTIONsymbol:
		return "function";
	case FACTORYsymbol:
		return "factory";
	case COMMANDsymbol:
		return "command";
	case PATTERNsymbol:
		return "pattern";
	}
	return "Undefined";
}

@= showVariableProperties
{
	if ( flg & LIST_MAL_TYPE ){
		str tpe = getTypeName(getVarType(mb, getArg(p, i)));
		snprintf(t,(len-(t-base)), ":%s ", tpe);
		GDKfree(tpe);
		advance(t,base,len);
	} else
		if ( flg & (LIST_MAL_UDF | LIST_MAL_STMT | LIST_MAL_VALUE)  && i < p->retc) {
		if ( isVarUDFtype(mb, getArg(p, i))) {
			str tpe = getTypeName(getVarType(mb, getArg(p, i)));
			snprintf(t,(len-(t-base)), ":%s ", tpe);
			GDKfree(tpe);
			advance(t,base,len);
		} 
	}
	if (flg & LIST_MAL_PROPS ){
		pstring = varGetPropStr(mb, getArg(p, i));
		if (pstring){
			snprintf(t,(len-(t-base)),"%s", pstring);
			advance(t,base,len);
			GDKfree(pstring);
		}
	}
}
@
@c

str
instruction2str(MalBlkPtr mb, MalStkPtr stk,  InstrPtr p, int flg)
{
	int i, tab = 4;
	str base, s, t;
	size_t len=  (mb->stop < 1000? 1000: mb->stop) * 128 /* max realistic line length estimate */;
	int low, high;
	char nmebuf[PATHLENGTH];
	str pstring = NULL;
	str cv = NULL;

	base = s = GDKmalloc(len);
	if ( s == NULL)
		return s;
	if (flg) {
		if( p->token<0){
			s[0] = '#';
			s[1] = 0;
			t = s+1;
		}else{
			s[0] = 0;
			t = s;
		}
	} else {
		s[0] = '#';
		if (p->typechk == TYPE_UNKNOWN) {
			s[1] = '!';	/* error */
			s[2] = 0;
			t = s + 2;
		} else {
			s[1] = 0;
			t = s + 1;
		}
	}
	if (flg & LIST_MAL_LNR){
		snprintf(t,len-1,"#%3d ",getPC(mb,p));
		advance(t,base,len);
	}
	if (p->argc > 0 && isTmpVar(mb, getArg(p, 0))) {
		if (isVarUsed(mb, getDestVar(p))) {
			snprintf(nmebuf, PATHLENGTH, "%c%d", TMPMARKER, getVarTmp(mb, getArg(p, 0)));
		} else
			nmebuf[0] = 0;
	} 
	advance(t,base,len);
	if (p->token == REMsymbol) {
		/* do nothing */
	} else if (p->barrier) {
		if (p->barrier == LEAVEsymbol || 
			p->barrier == REDOsymbol || 
			p->barrier == RETURNsymbol || 
			p->barrier == YIELDsymbol || 
			p->barrier == RAISEsymbol) {
    			for(;tab>0;tab--) 
				*t++= ' ';
    			*t= 0;
    			advance(t,base,len);
		}
		snprintf(t,(len-(t-base)), "%s ", operatorName(p->barrier));
		advance(t,base,len);
	} else if (!functionStart(p) && !functionExit(p) && flg!=LIST_MAL_CALL) {
    		for(;tab>0;tab--) 
			*t++= ' ';
    		*t= 0;
    		advance(t,base,len);
	}
	switch (p->token<0?-p->token:p->token) {
	case FCNcall:
	case FACcall:
	case PATcall:
	case CMDcall:
	case ASSIGNsymbol :
		for (i = 0; i < p->retc; i++)
			if (!getVarTmp(mb, getArg(p, i)) || isVarUsed(mb, getArg(p, i)) || isVarUDFtype(mb,getArg(p,i)))
				break;

		if (i == p->retc)
			break;

		/* display multi-assignment */
		if (p->retc > 1)
			*t++ = '(';

		for (i = 0; i < p->retc; i++) {
			if (flg & LIST_MAL_STMT) {
				snprintf(t,(len-(t-base)),"%s%s", (*getArgName(mb,p,i) == TMPMARKER?"X":""), getArgName(mb, p, i));
				advance(t,base,len);
				@:showVariableProperties@
			}

			if (stk && (flg & LIST_MAL_VALUE) && isaBatType(getArgType(mb,p,i))) {
				BAT *d = 0;
				cv = NULL;
				VALformat(&cv, &stk->stk[getArg(p, i)]);
				if ( cv && strlen(cv) > len - (t - s)) {
					char *ns = (char *) GDKmalloc(len = strlen(cv) + len + 5);
					*t = 0;
					strcpy(ns, s);
					t = ns + (t - s);
					GDKfree(s);
					s = ns;
				}
				if ( cv && strcmp(cv,"nil") ){
					strcat(t, "=");
					strcat(t, cv);
					advance(t,base,len);
					if (cv)
						GDKfree(cv);
					d= BBPquickdesc(ABS(stk->stk[getArg(p,i)].val.ival),TRUE);
					if( d){
						snprintf(t,(len-(t-base)),"[" BUNFMT "]", BATcount(d));
						advance(t,base,len);
					}
				} else strcat(t, "=nil");
			}
			if (i < p->retc - 1)
				*t++ = ',';
		}
		if (p->retc > 1)
			*t++ = ')';

		if (p->argc > p->retc || getFunctionId(p)) {
			sprintf(t, " := ");
			t += 4;
		}
		*t = 0;
		break;
	case ENDsymbol:
		snprintf(t,(len-(t-base)), "end %s", getFunctionId(getInstrPtr(mb, 0)));
		advance(t,base,len);
		break;
	case COMMANDsymbol:
	case FUNCTIONsymbol:
	case FACTORYsymbol:
	case PATTERNsymbol:
		if (flg & LIST_MAL_VALUE) {
			snprintf(t,(len-(t-base)), "%s ", operatorName(p->token));
			advance(t,base,len);
			break;
		}
		return fcnDefinition(mb, p, s, flg, base, len);
	case REMsymbol:
	case NOOPsymbol:
		if(getVar(mb, getArg(p, 0))->value.val.sval) 
			snprintf(t,(len-(t-base)), "#%s ", getVar(mb, getArg(p, 0))->value.val.sval);
		else
			snprintf(t, (len-(t-base)), "# ");
		break;
	default:
		snprintf(t,  (len-(t-base))," unknown symbol ?%d? ", p->token);
	}
	advance(t,base,len);
	low = p->retc;
	high = p->argc;
	if (getModuleId(p))
		snprintf(t,  (len-(t-base)),"%s.", getModuleId(p));
	advance(t,base,len);
	if (getFunctionId(p)) {
		snprintf(t, (len-(t-base)), "%s(", getFunctionId(p));
	} else if (p->argc > p->retc + 1)
		snprintf(t, (len-(t-base)), "(");
	advance(t,base,len);

	for (i = low; i < high; i++) {
		advance(t,base,len);
		if (i >low){
			snprintf(t, (len-(t-base)), ",");
			advance(t,base,len);
		}
		if (i + 1 == high && p->varargs & VARARGS) {
			snprintf(t, (len-(t-base)), "...");
			advance(t,base,len);
			break;
		}
		/* show the value if availabe */
		if ( (isVarConstant(mb, getArg(p, i)) || stk) && !isVarTypedef(mb,getArg(p,i)) ){

			if (stk && flg & LIST_MAL_VALUE){
				if ( !isVarConstant(mb, getArg(p,i)) && flg & LIST_MAL_ARG)
					snprintf(t,(len-(t-base)),"%s%s", (*getArgName(mb,p,i)== TMPMARKER?"X":""), getArgName(mb, p, i));
				advance(t,base,len);
				if( getTailType(getArgType(mb,p,i)) > TYPE_str )
				{ 	char *ct;
					VALformat(&cv, &stk->stk[getArg(p, i)]);
					ct= (char*) GDKmalloc(1024+strlen(cv));
					if (isVarUDFtype(mb, getArg(p, i)) ) {
						if ( strcmp(cv,"nil") == 0)
							snprintf(ct, 1024+strlen(cv), "=%s", cv);
						else
							snprintf(ct, 1024+strlen(cv), "=\"%s\"", cv);
					} else
					if ( strcmp(cv,"nil") == 0)
						snprintf(ct, 1024+strlen(cv), "=%s:%s", cv, getTypeName(getTailType(getArgType(mb,p,i))));
					else
						snprintf(ct, 1024+strlen(cv), "=\"%s\":%s", cv, getTypeName(getTailType(getArgType(mb,p,i))));
					if( cv) GDKfree(cv);
					cv= ct;
				} else
					VALformat(&cv, &stk->stk[getArg(p, i)]);
			} else {
				if( getTailType(getArgType(mb,p,i)) > TYPE_str )
				{ char *ct=cv;
					VALformat(&cv, &getVar(mb, getArg(p, i))->value);
					ct= (char*) GDKmalloc(1024+strlen(cv));
					if (isVarUDFtype(mb, getArg(p, i)) ) {
						if ( strcmp(cv,"nil") == 0)
							snprintf(ct, 1024+strlen(cv), "%s", cv);
						else
							snprintf(ct, 1024+strlen(cv), "\"%s\"", cv);
					} else
					if ( strcmp(cv,"nil") == 0)
						snprintf(ct, 1024+strlen(cv), "%s:%s", cv, getTypeName(getTailType(getArgType(mb,p,i))));
					else
						snprintf(ct, 1024+strlen(cv), "\"%s\":%s", cv, getTypeName(getTailType(getArgType(mb,p,i))));
					if( cv) GDKfree(cv);
					cv= ct;
				} else
					VALformat(&cv, &getVar(mb, getArg(p, i))->value);
			}
			if ( cv && strlen(cv) > len - (t - s)) {
				char *ns = (char *) GDKmalloc(len = strlen(cv) + len + 5);

				*t = 0;
				strcpy(ns, s);
				t = ns + (t - s);
				GDKfree(s);
				s = ns;
			}
			if ( cv )  {
				if ( !isVarConstant(mb, getArg(p, i)) )
					strcat(t,"=");
				strcat(t, cv);
			}
			
			advance(t,base,len);
			if ( (cv && strlen(cv)==0) || isVarUDFtype(mb, getArg(p, i)) ||
				isAmbiguousType(getArgType(mb,p,i)) ){
				str tpe = getTypeName(getVarType(mb, getArg(p, i)));
				snprintf(t,(len-(t-base)), ":%s", tpe);
				GDKfree(tpe);
				advance(t,base,len);
			}
			if (cv)
				GDKfree(cv);
			if( flg & LIST_MAL_VALUE && isaBatType(getVarType(mb,getArg(p,i)) ) ){
				BAT *d = 0;
				if (stk && stk->stk[getArg(p,i)].vtype== TYPE_bat){
					d= BBPquickdesc(ABS(stk->stk[getArg(p,i)].val.ival),TRUE);
				} else
					d= BBPquickdesc(ABS(getVarConstant(mb,getArg(p,i)).val.ival),TRUE);
				if( d){
					snprintf(t,(len-(t-base)),"[" BUNFMT "]", BATcount(d));
					advance(t,base,len);
				}
			}
		} else {
			if( ! isVarTypedef(mb,getArg(p,i))  ){
				snprintf(t,(len-(t-base)),"%s%s", (*getArgName(mb,p,i) == TMPMARKER?"X":""), getArgName(mb, p, i));
				advance(t,base,len);
				@:showVariableProperties@
			} else {
				str tpe = getTypeName(getVarType(mb, getArg(p, i)));
				snprintf(t,(len-(t-base)), ":%s", tpe);
				GDKfree(tpe);
				advance(t,base,len);
				if (flg & LIST_MAL_PROPS){
					pstring = varGetPropStr(mb, getArg(p, i));
					if (pstring){
						snprintf(t,(len-(t-base)),"%s", pstring);
						advance(t,base,len);
						GDKfree(pstring);
					}
				}
			} 
		} 
	} 
	if (getFunctionId(p) || p->argc > p->retc + 1)
		snprintf(t,(len-(t-base)), ")");
	advance(t,base,len);
	if (p->token != REMsymbol){
		snprintf(t,(len-(t-base)), ";");
		advance(t,base,len);
		if (flg & LIST_MAL_DETAIL) {
			advance(t,base,len);
			t = hiddenInstructionArgs(mb, p, t,s, flg,base,len);
		}
	}
	/* we may accidentally overwrite */
	if (t > s + len)
		GDKfatal("instruction2str:");
	return s;
}

str
function2str(MalBlkPtr mb, int flg)
{
	str ps, *txt;
	int i, *len, totlen = 0;

	txt = GDKmalloc(sizeof(str) * mb->stop);
	len = GDKmalloc(sizeof(int) * mb->stop);
	for (i = 0; i < mb->stop; i++) {
		txt[i] = instruction2str(mb, 0, getInstrPtr(mb, i), flg);
		if ( txt[i])
			totlen += len[i] = (int)strlen(txt[i]);
	}
	ps = GDKmalloc(totlen + mb->stop + 1);
	totlen = 0;
	for (i = 0; i < mb->stop; i++) 
	if( txt[i]){
		strncpy(ps + totlen, txt[i], len[i]);
		ps[totlen + len[i]] = '\n';
		ps[totlen + len[i] + 1] = 0;
		totlen += len[i] + 1;
		GDKfree(txt[i]);
	}
	GDKfree(len);
	GDKfree(txt);
	return ps;
}

void
promptInstruction(stream *fd, MalBlkPtr mb, MalStkPtr stk, InstrPtr p, int flg)
{
	str ps;

	if (fd == 0)
		return;
	ps = instruction2str(mb, stk, p, flg);
	/* ps[strlen(ps)-1] = 0; remove '\n' */
	if ( ps ){
		mnstr_printf(fd, "%s%s", (flg & LIST_MAPI ? "=" : ""), ps);
		GDKfree(ps);
	}
}

void
printInstruction(stream *fd, MalBlkPtr mb, MalStkPtr stk, InstrPtr p, int flg)
{
	promptInstruction(fd, mb, stk, p, flg);
	mnstr_printf(fd, "\n");
}

void
printSignature(stream *fd, Symbol s, int flg)
{
	InstrPtr p;
	str txt;

	if ( s->def == 0 ){
		mnstr_printf(fd, "missing definition of %s\n", s->name);
		return;
	}
	txt = GDKzalloc(MAXLISTING); /* some slack for large blocks */
	p = getSignature(s);
	(void) fcnDefinition(s->def, p, txt, flg, txt, MAXLISTING);
	mnstr_printf(fd, "%s\n", txt);
	GDKfree(txt);
}

/*
For clarity we show the last optimizer applied
also as the last of the list, although it is
linked with mb.
*/
void showMalBlkHistory(MalBlkPtr mb)
{
	MalBlkPtr m=mb;
	InstrPtr p,sig;
	int j=0;
	str msg;

	sig = getInstrPtr(mb,0);
	m= m->history;
	while(m){
		p= getInstrPtr(m,m->stop-1);
		if( p->token == REMsymbol){
			msg= instruction2str(m, 0, p, FALSE);
			if (msg ) {
				mnstr_printf(GDKout,"%s.%s[%2d] %s\n", 
					getModuleId(sig), getFunctionId(sig),j++,msg+3);
				GDKfree(msg);
			}
		} 
		m= m->history;
	}
	p=getInstrPtr(mb,mb->stop-1);
	if( p->token == REMsymbol){
		msg= instruction2str(mb, 0, p, FALSE);
		if (msg) {
			mnstr_printf(GDKout,"%s.%s[%2d] %s\n", 
				getModuleId(sig), getFunctionId(sig),j++,msg+3);
				GDKfree(msg);
		}
		} 
}

int
newProperty(MalBlkPtr mb) 
{
	if (mb->ptop >= mb->psize){
		mb->psize += MAXVARS;
		mb->prps = (MalProp*) GDKrealloc(mb->prps, mb->psize * sizeof(MalProp));
		if (mb->prps == NULL) {
			mb->errors++;
			return -1;
		}
	}
	return mb->ptop++;
}

void
varSetProp(MalBlkPtr mb, int var, int prop, int op, ValPtr cst)
{
	VarPtr v = getVar(mb, var), vnew;
	int i, propid = -1, reset = 0, size;

	for(i=0; i<v->propc; i++){
		MalProp *p = mb->prps+v->prps[i];

		if (p->idx == prop) {
			propid = v->prps[i]; 
			reset = 1;
			break;
		}
	}
	if (propid < 0 && (propid = newProperty(mb)) < 0) { 
		assert(0);
		showScriptException(mb, 0, MAL, "varSetProp: no storage left\n");
	}

	mb->prps[propid].var = 0;
	if (cst != NULL) {
		mb->prps[propid].var = defConstant(mb, cst->vtype, cst);
		/* beware, property constants should not be garbage collected */
		setVarUsed(mb,mb->prps[propid].var);
	}
	mb->prps[propid].idx = prop;
	mb->prps[propid].op = op;

	/* here we need to add the new property to the variable */
	assert(v->propc <= v->maxprop);
	if (!reset) {
		if (v->propc == v->maxprop) {
			size = sizeof(VarRecord) + v->maxprop * sizeof(int);
        		vnew = (VarPtr) GDKzalloc(size + MAXARG * sizeof(int));
			memcpy((char*) vnew, (char*) v, size);
			vnew->maxprop += MAXARG;
			mb->var[var] = vnew;
			GDKfree(v);
			v = getVar(mb, var);
		}
		v->prps[v->propc++] = propid;
	}
	assert(v->propc <= v->maxprop);
}

str
varGetPropStr( MalBlkPtr mb, int var )
{
	char buf[BUFSIZ], *s = buf;
	VarPtr v = getVar(mb, var);
	int i, first = 1;

	if (v->propc == 0)
		return NULL;

	*s++ = '{';
	for(i=0; i<v->propc; i++){
		char *t = NULL;
		MalProp *p = mb->prps+v->prps[i];
		char *nme = PropertyName(p->idx);

		if (!first) {
			*s++ = ',';
			*s++ = ' ';
		}
		if (p->var) {
			VarPtr v = getVar(mb, p->var);
			char *op = PropertyOperatorString((prop_op_t)p->op); 
	
			ATOMformat(v->type, VALget(&v->value), &t);
			switch(v->type) {
			case TYPE_oid:
				sprintf(s, "%s%s%s:oid", nme, op, t);
				break;
			case TYPE_lng:
				sprintf(s, "%s%s%s:lng", nme, op, t);
				break;
			case TYPE_sht:
				sprintf(s, "%s%s%s:sht", nme, op, t);
				break;
			default:
				sprintf(s, "%s%s%s", nme, op, t);
			}
			if (t)
				GDKfree(t);
		} else {
			sprintf(s, "%s", nme);
		}
		while (*s)
			s++;
		first = 0;
	}
	*s++ = '}';
	*s = 0;
	return GDKstrdup(buf);
}

static VarRecord varTrue;

VarPtr
varGetProp( MalBlkPtr mb, int var, int prop )
{
	VarPtr v;
	int i;

	if ( mb->prps == NULL || var < 0)
		return NULL;
	v = getVar(mb, var);
	for(i=0; i<v->propc; i++){
		MalProp *p = mb->prps+v->prps[i];

		if (p->idx == prop) {
			if (p->var) {
				return getVar(mb, p->var);
			} else {
				bit t = TRUE;
				VALset(&varTrue.value, TYPE_bit, &t);
				varTrue.type = TYPE_bit;
				return &varTrue;
			}
		}
	}
	return NULL;
}
