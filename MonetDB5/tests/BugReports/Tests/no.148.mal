# Monet Mil to Mal compiler
# Copyright (c) 2001-2004, CWI. All rights reserved.

#Predefined code segment
#The compiler can not guarantee an accurate compilation,
#because MIL unlike MAL is a dynamically typed language.
#A few guidelines to maximize usefullness.
#- make the type of variables explicit, in particular 'nil'
#- upon advice of M2m to remap identifiers, change it in your program directly
#use the "mil_schema" for additional support routines
#	io.print("# >Number:         148\n");
#	io.print("# >Category:       Module_xtables\n");
#	io.print("# >Synopsis:       table() call fails in xtable.mil\n");
#	io.print("# >Confidential:   no\n");
#	io.print("# >Severity:       serious\n");
#	io.print("# >Priority:       medium\n");
#	io.print("# >Responsible:    mk (Martin Kersten)\n");
#	io.print("# >State:          open\n");
#	io.print("# >Class:          sw-bug\n");
#	io.print("# >Submitter-Id:   unknown\n");
#	io.print("# >Arrival-Date:   Wed Mar 11 14:28:45 1998\n");
#	io.print("# >Originator:     manegold@cwi.nl\n");
#	io.print("# >Organization:\n");
#	io.print("# CWI\n");
#	io.print("# >Release:        980101\n");
#	io.print("# >Environment:\n");
#	io.print("# any\n");
#	io.print("# >Description:\n");
#	io.print("# 'table(histo, $(3..))` in 'proc xtable_print`  in\n");
#	io.print("# 'xtables.mil` (also available as test 'plain/xtables/`)\n");
#	io.print("# ends up in an endless loop in the macro 'matchloop`\n");
#	io.print("# (src/gdk/gdk_relop.mx) as soon as the first tuple is \n");
#	io.print("# printed. 'matchloop` is called as \n");
#	io.print("# 'matchloop(hloc,OID,_oid)` in line 1054 of \n");
#	io.print("# 'src/gdk/gdk_relop.mx`.\n");
#	io.print("# \n");
#	io.print("# maybe, this is no bug in module xtables, but somewhere \n");
#	io.print("# else, but as it seems to occur only here, I submit \n");
#	io.print("# this as an xtables bug report.\n");
#	io.print("# \n");
#	io.print("# as soon as I got some time, I will try to do some more \n");
#	io.print("# debugging.\n");
#	io.print("# \n");
#	io.print("# \tstefan\n");
#	io.print("# \n");
#	io.print("# ================\n");
#	io.print("# Output\n");
#	io.print("# ----------------\n");
#	io.print("# [...]\n");
#	io.print("# \n");
#	io.print("# #You are system administrator (adm)!\n");
#	io.print("# \n");
#	io.print("# #line 437 \"modules/plain/xtables.mx\"\n");
#	io.print("# setoid(oid(20000000));\n");
#	io.print("# module(xtables);\n");
#	io.print("# \n");
#	io.print("# # First some procs for convenience:\n");
#	io.print("# # - xtable_print(group[oid,oid], str, attr1[oid,a1], attr2[oid,a2], ...)\n");
#	io.print("# #       print group count table \n");
#	io.print("# # - xtable_realloc(bat, capacity):  bat\n");
#	io.print("# #       allocate more memory and return a copy of a bat\n");
#	io.print("# # - xtable_test(str title, bat x, bat y, bat z)\n");
#	io.print("# #        major test script on xtable functionality\n");
#	io.print("# \n");
#	io.print("# proc xtable_print() : void { \n");
#	io.print("#         var histo := $1.histogram;\n");
#	io.print("#         histo.rename(\"count\");\n");
#	io.print("#         printf(\"\\n# %s (ct: %d elts, %d groups, %d bytes)\\n\",\n");
#	io.print("#                 $2, $1.count, histo.count, $1.batsize);\n");
#	io.print("#         table(histo, $(3..));\n");
#	io.print("# }\n");
#	io.print("# \n");
#	io.print("# proc xtable_realloc(bat b, int cap) : bat { \n");
#	io.print("#         bn := bbp.new(b.htype, b.ttype, bat);\n");
#	io.print("#         if (b.htype = void) bn.seqbase(b.reverse.fetch(0));\n");
#	io.print("#         if (b.ttype = void) bn.seqbase(b.fetch(0));\n");
#	io.print("#         bn.insert(b);\n");
#	io.print("#         return bn;\n");
#	io.print("# }\n");
#	io.print("# \n");
#	io.print("# proc xtable_test(str title, bat x, bat y, bat z) : bat {\n");
#	io.print("#     printf(\"# xtable_test: %s grouping (%d tuples, %d bytes)\\n\\n\",\n");
#	io.print("#                 title, x.count, x.batsize + y.batsize + z.batsize);\n");
#	io.print("#     x.rename(\"x\"); y.rename(\"y\"); z.rename(\"z\");\n");
#	io.print("# \n");
#	io.print("#     bat.print(x.slice(0,7),y,z);\n");
#	io.print("#     printf(\"synced(x,y) := %s\\n\", synced(x,y).str);\n");
#	io.print("#     printf(\"synced(x,z) := %s\\n\", synced(x,z).str);\n");
#	io.print("# \n");
#	io.print("#     var x1 := CTgroup(x);\n");
#	io.print("#     x1.xtable_print(\"CT(x)\", x);\n");
#	io.print("# \n");
#	io.print("#     var x1y := CTgroup(x1,y);\n");
#	io.print("#     x1y.xtable_print(\"CT(x,y)\", x, y);\n");
#	io.print("# \n");
#	io.print("#     var v :=  y.uselect(dbl(2.0),dbl(3.0));\n");
#	io.print("#     var xvy := CTsubgroup(x1,y,v);\n");
#	io.print("#     xvy.xtable_print(\"CT(x,y|v)\", x, y);\n");
#	io.print("# \n");
#	io.print("#     var x1yz := CTgroup(x1y,z);\n");
#	io.print("#     x1yz.xtable_print(\"CT(x,y,z)\", x, y, z);\n");
#	io.print("# }\n");
#	io.print("# \n");
#	io.print("# x := bbp.new(oid,chr);\n");
#	io.print("# x.insert(1@0,'a');\n");
#	io.print("# x.insert(2@0,'a');\n");
#	io.print("# x.insert(3@0,'b');\n");
#	io.print("# x.insert(4@0,'b');\n");
#	io.print("# x.insert(5@0,'b');\n");
#	io.print("# x.insert(6@0,'b');\n");
#	io.print("# x.insert(7@0,'c');\n");
#	io.print("# x.insert(8@0,'c');\n");
#	io.print("# \n");
#	io.print("# y:= bbp.new(oid,dbl);\n");
#	io.print("# y.insert(1@0,dbl(1.0));\n");
#	io.print("# y.insert(2@0,dbl(3.0));\n");
#	io.print("# y.insert(3@0,dbl(2.0));\n");
#	io.print("# y.insert(4@0,dbl(2.0));\n");
#	io.print("# y.insert(5@0,dbl(2.0));\n");
#	io.print("# y.insert(6@0,dbl(3.0));\n");
#	io.print("# y.insert(7@0,dbl(1.0));\n");
#	io.print("# y.insert(8@0,dbl(1.0));\n");
#	io.print("# \n");
#	io.print("# z:= bbp.new(oid,str);\n");
#	io.print("# z.insert(1@0,\"c\");\n");
#	io.print("# z.insert(2@0,\"a\");\n");
#	io.print("# z.insert(3@0,\"b\");\n");
#	io.print("# z.insert(4@0,\"c\");\n");
#	io.print("# z.insert(5@0,\"a\");\n");
#	io.print("# z.insert(6@0,\"a\");\n");
#	io.print("# z.insert(7@0,\"c\");\n");
#	io.print("# z.insert(8@0,\"a\");\n");
#	io.print("# \n");
#	io.print("# xtable_test(\"small hash\", x, y, z);\n");
#	io.print("# # xtable_test: small hash grouping (8 tuples, 8660 bytes)\n");
#	io.print("# \n");
#	io.print("# #-----------------------------------------#\n");
#	io.print("# # oid   | tmp_30| y             | z       #\n");
#	io.print("# #-----------------------------------------#\n");
#	io.print("# [ 1@0,    'a',    1.000000,       \"c\"     ]\n");
#	io.print("# [ 2@0,    'a',    3.000000,       \"a\"     ]\n");
#	io.print("# [ 3@0,    'b',    2.000000,       \"b\"     ]\n");
#	io.print("# [ 4@0,    'b',    2.000000,       \"c\"     ]\n");
#	io.print("# [ 5@0,    'b',    2.000000,       \"a\"     ]\n");
#	io.print("# [ 6@0,    'b',    3.000000,       \"a\"     ]\n");
#	io.print("# [ 7@0,    'c',    1.000000,       \"c\"     ]\n");
#	io.print("# [ 8@0,    'c',    1.000000,       \"a\"     ]\n");
#	io.print("# synced(x,y) := false\n");
#	io.print("# synced(x,z) := false\n");
#	io.print("# \n");
#	io.print("# # CT(x) (ct: 8 elts, 3 groups, 1096 bytes)\n");
#	io.print("# #-----------------#\n");
#	io.print("# # count | x       #\n");
#	io.print("# #-----------------#\n");
#	io.print("# [ 2,      'a'     ]\n");
#	io.print("# \n");
#	io.print("# ================\n");
#	io.print("#line 450 \"modules/plain/xtables.mx\"\n");
	aa_a := calc.oid(20000000);
	ba_a := setoid(aa_a);
#	io.print("# First some procs for convenience: \n");
#	io.print("# - xtable_print(group[oid,oid], str, attr1[oid,a1], attr2[oid,a2], ...)\n");
#	io.print("# \tprint group count table \n");
#	io.print("# - xtable_realloc(bat, capacity):  bat\n");
#	io.print("#\tallocate more memory and return a copy of a bat\n");
#	io.print("# - xtable_test(str title, bat x, bat y, bat z)\n");
#	io.print("#\t major test script on xtable functionality\n");
#	io.print("proc xtable_print(..any..) : void {");
function xtable_print(,xtable_print:any$1...):void;
#	io.print("        var histo := $1.histogram();");
	ca_a := mil.getVarTemp($1);
	histo := histogram(ca_a);
#	io.print("                $2, $1.count(), histo.count(), $1.batsize());");
	da_a := mil.getVarTemp($2);
	ea_a := mil.getVarTemp($1);
	fa_a := aggr.count(ea_a);
	ga_a := aggr.count(histo);
	ha_a := mil.getVarTemp($1);
	ia_a := bat.bbpBatSize(ha_a);
	ja_a := printf("\n# %s (ct: %d elts, %d groups, %d bytes)\n",da_a,fa_a,ga_a,ia_a);
#	io.print("        table(histo.col_name(\"count\"), $(3..));");
	ka_a := bat.setColumn(histo,"count");
	la_a := mil.getVarTempRange(3);
	ma_a := table(ka_a,la_a);
end xtable_print;
#	io.print("proc xtable_realloc(bat b,int cap) : bat {");
function xtable_realloc(b:bat[:any_1,:any_2], cap:int):bat[:any_3,:any_4];
#	io.print("        var inf := b.info();");
	inf := info(b);
#	io.print("        var ht := monet_atomtbl.find(inf.find(\"head\"));");
	monet_atomtbl:= mil.take("monet_atomtbl");
	na_a := algebra.find(inf,"head");
	ht := algebra.find(monet_atomtbl,na_a);
#	io.print("        var tt := monet_atomtbl.find(inf.find(\"tail\"));");
	oa_a := algebra.find(inf,"tail");
	tt := algebra.find(monet_atomtbl,oa_a);
#	io.print("        var bn := bbp.new(ht, tt, cap);");
	bn := bbp.new(ht,tt,cap);
#	io.print("        bn.insert(b);");
	pa_a := bat.insert(bn,b);
#	io.print("        if (ht = void) bn.seqbase(b.reverse().fetch(0));");
barrier	qa_a := ==(ht,nil:oid);
	ra_a := bat.reverse(b);
	sa_a := fetch(ra_a,0);
#	io.print("        if (tt = void) bn.seqbase(b.fetch(0));");
exit	qa_a;
barrier	ua_a := ==(tt,nil:oid);
	va_a := fetch(b,0);
#	io.print("        return bn;");
exit	ua_a;
	return xa_a :=bn;
end xtable_realloc;
#	io.print("proc xtable_test(str title, bat x, bat y, bat z) : void {");
function xtable_test(title:str, x:bat[:any_1,:any_2], y:bat[:any_3,:any_4], z:bat[:any_5,:any_6]):void;
#	io.print("                title, x.count(), x.batsize() + y.batsize() + z.batsize());");
	ya_a := aggr.count(x);
	ab_a := bat.bbpBatSize(y);
	bb_a := bat.bbpBatSize(z);
	cb_a := bat.bbpBatSize(x);
	db_a := +(ab_a,bb_a);
	eb_a := +(cb_a,db_a);
	fb_a := printf("# xtable_test: %s grouping (%d tuples, %d bytes)\n\n",title,ya_a,eb_a);
#	io.print("    x.col_name(\"x\"); y.col_name(\"y\"); z.col_name(\"z\");");
	gb_a := bat.setColumn(x,"x");
	hb_a := bat.setColumn(y,"y");
	ib_a := bat.setColumn(z,"z");
#	io.print("    bat.print(x.slice(0,7),y,z);");
	jb_a := slice(x,0,7);
	kb_a := bat.print(jb_a,y,z);
#	io.print("    printf(\"synced(x,y) := %s\\n\", synced(x,y).str());");
	lb_a := isSynced(x,y);
	mb_a := str(lb_a);
	nb_a := printf("synced(x,y) := %s\n",mb_a);
#	io.print("    printf(\"synced(x,z) := %s\\n\", synced(x,z).str());");
	ob_a := isSynced(x,z);
	pb_a := str(ob_a);
	qb_a := printf("synced(x,z) := %s\n",pb_a);
#	io.print("    var x1 := CTgroup(x);");
	x1 := group(x);
#	io.print("    x1.xtable_print(\"CT(x)\", x);");
	rb_a := xtable_print(x1,"CT(x)",x);
#	io.print("    var x1y := CTgroup(x1,y);");
	x1y := group(x1,y);
#	io.print("    x1y.xtable_print(\"CT(x,y)\", x, y);");
	sb_a := xtable_print(x1y,"CT(x,y)",x,y);
#	io.print("    var v :=  y.uselect(dbl(2.0),dbl(3.0));");
	tb_a := dbl(2.0);
	ub_a := dbl(3.0);
	v := uselect(y,tb_a,ub_a);
#	io.print("    var xvy := CTsubgroup(x1,y,v);");
	xvy := CTsubgroup(x1,y,v);
#	io.print("    xvy.xtable_print(\"CT(x,y|v)\", x, y);");
	vb_a := xtable_print(xvy,"CT(x,y|v)",x,y);
#	io.print("    var x1yz := CTgroup(x1y,z);");
	x1yz := group(x1y,z);
#	io.print("    x1yz.xtable_print(\"CT(x,y,z)\", x, y, z);");
	wb_a := xtable_print(x1yz,"CT(x,y,z)",x,y,z);
end xtable_test;
#	io.print("var x := bbp.new(oid,chr);");
	x := bbp.new(nil:oid,nil:chr);
#	io.print("x.insert(1@0,'a');");
	xb_a := bat.insert(x,1@0,'a');
#	io.print("x.insert(2@0,'a');");
	yb_a := bat.insert(x,2@0,'a');
#	io.print("x.insert(3@0,'b');");
	ac_a := bat.insert(x,3@0,'b');
#	io.print("x.insert(4@0,'b');");
	bc_a := bat.insert(x,4@0,'b');
#	io.print("x.insert(5@0,'b');");
	cc_a := bat.insert(x,5@0,'b');
#	io.print("x.insert(6@0,'b');");
	dc_a := bat.insert(x,6@0,'b');
#	io.print("x.insert(7@0,'c');");
	ec_a := bat.insert(x,7@0,'c');
#	io.print("x.insert(8@0,'c');");
	fc_a := bat.insert(x,8@0,'c');
#	io.print("var y:= bbp.new(oid,dbl);");
	y := bbp.new(nil:oid,nil:dbl);
#	io.print("y.insert(1@0,dbl(1.0));");
	gc_a := dbl(1.0);
	hc_a := bat.insert(y,1@0,gc_a);
#	io.print("y.insert(2@0,dbl(3.0));");
	ic_a := dbl(3.0);
	jc_a := bat.insert(y,2@0,ic_a);
#	io.print("y.insert(3@0,dbl(2.0));");
	kc_a := dbl(2.0);
	lc_a := bat.insert(y,3@0,kc_a);
#	io.print("y.insert(4@0,dbl(2.0));");
	mc_a := dbl(2.0);
	nc_a := bat.insert(y,4@0,mc_a);
#	io.print("y.insert(5@0,dbl(2.0));");
	oc_a := dbl(2.0);
	pc_a := bat.insert(y,5@0,oc_a);
#	io.print("y.insert(6@0,dbl(3.0));");
	qc_a := dbl(3.0);
	rc_a := bat.insert(y,6@0,qc_a);
#	io.print("y.insert(7@0,dbl(1.0));");
	sc_a := dbl(1.0);
	tc_a := bat.insert(y,7@0,sc_a);
#	io.print("y.insert(8@0,dbl(1.0));");
	uc_a := dbl(1.0);
	vc_a := bat.insert(y,8@0,uc_a);
#	io.print("var z:= bbp.new(oid,str);");
	z := bbp.new(nil:oid,nil:str);
#	io.print("z.insert(1@0,\"c\");");
	wc_a := bat.insert(z,1@0,"c");
#	io.print("z.insert(2@0,\"a\");");
	xc_a := bat.insert(z,2@0,"a");
#	io.print("z.insert(3@0,\"b\");");
	yc_a := bat.insert(z,3@0,"b");
#	io.print("z.insert(4@0,\"c\");");
	ad_a := bat.insert(z,4@0,"c");
#	io.print("z.insert(5@0,\"a\");");
	bd_a := bat.insert(z,5@0,"a");
#	io.print("z.insert(6@0,\"a\");");
	cd_a := bat.insert(z,6@0,"a");
#	io.print("z.insert(7@0,\"c\");");
	dd_a := bat.insert(z,7@0,"c");
#	io.print("z.insert(8@0,\"a\");");
	ed_a := bat.insert(z,8@0,"a");
#	io.print("xtable_test(\"small hash\", x, y, z);");
	fd_a := xtable_test("small hash",x,y,z);
#	io.print("# create vectorized versions\n");
	gd_a := bat.reverse(x);
	hd_a := project(gd_a);
	id_a := bat.reverse(hd_a);
	x := copy(id_a);
#	io.print("y := y.reverse().project().reverse().copy();");
	jd_a := bat.reverse(y);
	kd_a := project(jd_a);
	ld_a := bat.reverse(kd_a);
	y := copy(ld_a);
#	io.print("z := z.reverse().project().reverse().copy();");
	md_a := bat.reverse(z);
	nd_a := project(md_a);
	od_a := bat.reverse(nd_a);
	z := copy(od_a);
#	io.print("# activate voids\n");
#	io.print("y.seqbase(1@0);");
#	io.print("z.seqbase(1@0);");
#	io.print("xtable_test(\"small vectorized\", x, y, z);");
	sd_a := xtable_test("small vectorized",x,y,z);
#	io.print("# deactivate voids\n");
	td_a := calc.oid(nil);
#	io.print("y.seqbase(oid(nil));");
	vd_a := calc.oid(nil);
#	io.print("z.seqbase(oid(nil));");
	xd_a := calc.oid(nil);
#	io.print("print(\"growing tables from 8 to 512k elements...\");");
	ae_a := bat.print("growing tables from 8 to 512k elements...");
#	io.print("x := x.xtable_realloc(512*1024);");
	be_a := *(512,1024);
	x := xtable_realloc(x,be_a);
#	io.print("y := y.xtable_realloc(512*1024);");
	ce_a := *(512,1024);
	y := xtable_realloc(y,ce_a);
#	io.print("z := z.xtable_realloc(512*1024);");
	de_a := *(512,1024);
	z := xtable_realloc(z,de_a);
#	io.print("var i := 17;");
	i := 17;
#	io.print("while((i := i - 1) > 0) {");
barrier	ee_a := true;
	i := -(i,1);
barrier	fe_a := >(i,0);
#	io.print("        x.insert(x.copy());");
	ge_a := copy(x);
	he_a := bat.insert(x,ge_a);
#	io.print("        y.insert(y.copy());");
	ie_a := copy(y);
	je_a := bat.insert(y,ie_a);
#	io.print("        z.insert(z.copy());");
	ke_a := copy(z);
	le_a := bat.insert(z,ke_a);
#	io.print("        bat.print(x.count());");
	me_a := aggr.count(x);
	ne_a := bat.print(me_a);
#	io.print("}");
redo	ee_a;
exit	fe_a;
exit	ee_a;
#	io.print("print(\"done!\");");
	oe_a := bat.print("done!");
#	io.print("# materialize the oids again\n");
	pe_a := calc.oid(1);
	qe_a := bat.reverse(x);
	re_a := mark(qe_a,pe_a);
	se_a := multiplex.tactics("oid",re_a);
	x := bat.reverse(se_a);
#	io.print("y := [oid](y.reverse().mark(oid(1))).reverse();");
	te_a := calc.oid(1);
	ue_a := bat.reverse(y);
	ve_a := mark(ue_a,te_a);
	we_a := multiplex.tactics("oid",ve_a);
	y := bat.reverse(we_a);
#	io.print("z := [oid](z.reverse().mark(oid(1))).reverse();");
	xe_a := calc.oid(1);
	ye_a := bat.reverse(z);
	af_a := mark(ye_a,xe_a);
	bf_a := multiplex.tactics("oid",af_a);
	z := bat.reverse(bf_a);
#	io.print("y.access(BAT_WRITE);");
	BAT_WRITE:= mil.take("BAT_WRITE");
	cf_a := access(y,BAT_WRITE);
#	io.print("z.access(BAT_WRITE);");
	df_a := access(z,BAT_WRITE);
#	io.print("y.insert(0@0,dbl(nil));");
	ef_a := calc.dbl(nil);
	ff_a := bat.insert(y,0@0,ef_a);
#	io.print("z.insert(0@0,str(nil));");
	gf_a := calc.str(nil);
	hf_a := bat.insert(z,0@0,gf_a);
#	io.print("y.delete(0@0);");
	if_a := algebra.delete(y,0@0);
#	io.print("z.delete(0@0);");
	jf_a := algebra.delete(z,0@0);
#	io.print("xtable_test(\"big hash\", x, y, z);");
	kf_a := xtable_test("big hash",x,y,z);
#	io.print("# let the Mserver find out that the head columns are equal\n");
	lf_a := mirror(x);
	y := algebra.join(lf_a,y);
#	io.print("z := x.mirror().join(z);");
	mf_a := mirror(x);
	z := algebra.join(mf_a,z);
#	io.print("xtable_test(\"big synced\", x, y, z);");
	nf_a := xtable_test("big synced",x,y,z);
#	io.print("# activate voids\n");
	of_a := bat.reverse(x);
	pf_a := mark(of_a,1@0);
	x := bat.reverse(pf_a);
#	io.print("y := y.reverse().mark(1@0).reverse();");
	qf_a := bat.reverse(y);
	rf_a := mark(qf_a,1@0);
	y := bat.reverse(rf_a);
#	io.print("z := z.reverse().mark(1@0).reverse();");
	sf_a := bat.reverse(z);
	tf_a := mark(sf_a,1@0);
	z := bat.reverse(tf_a);
#	io.print("xtable_test(\"big vectorized\", x, y, z);");
	uf_a := xtable_test("big vectorized",x,y,z);
#	io.print("# try out the histosum\n");
#	io.print("#z:= histogram(x1yz);\n");
#	io.print("#z2:= y.CTgroup();\n");
#	io.print("#print(z2);\n");
#	io.print("#z3:= z2.CThistosum(z);\n");
#	io.print("#print(z3);\n");
#	io.print("quit();");
	vf_a := clients.quit();
#	io.print("# try out the histosum\n");
#	io.print("#z:= histogram(x1yz);\n");
#	io.print("#z2:= y.CTgroup();\n");
#	io.print("#print(z2);\n");
#	io.print("#z3:= z2.CThistosum(z);\n");
#	io.print("#print(z3);\n");
#	io.print("#line 638 \"modules/plain/xtables.mx\"\n");
#Identifer 'synced' mapped to 'isSynced'
#Identifer 'col_name' mapped to 'bat.setColumn'
#Identifer 'seqbase' mapped to 'bat.setSequenceBase'
#Identifer 'batsize' mapped to 'bat.bbpBatSize'
#Identifer 'CTgroup' mapped to 'group'
