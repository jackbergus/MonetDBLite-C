# Monet Mil to Mal compiler
# Copyright (c) 2001-2004, CWI. All rights reserved.

#Predefined code segment
#The compiler can not guarantee an accurate compilation,
#because MIL unlike MAL is a dynamically typed language.
#A few guidelines to maximize usefullness.
#- make the type of variables explicit, in particular 'nil'
#- upon advice of M2m to remap identifiers, change it in your program directly
#use the "mil_schema" for additional support routines
	mil.line("# the following implementation paths in the standard pump implementation exist:\n");
	mil.line("#\n");
	mil.line("# proc_sort()ed\n");
	mil.line("# proc_hash\n");
	mil.line("# packed_sort()ed\n");
	mil.line("# packed_hash\n");
	mil.line("# direct_sort()ed_chr\n");
	mil.line("# direct_sort()ed_sht\n");
	mil.line("# direct_sort()ed_int\n");
	mil.line("# direct_sort()ed_void\n");
	mil.line("# direct_hash_chr\n");
	mil.line("# direct_hash_sht\n");
	mil.line("# direct_hash_int\n");
	mil.line("# direct_idx_chr\n");
	mil.line("# direct_idx_sht\n");
	mil.line("# direct_idx_int\n");
	mil.line("#\n");
	mil.line("# this script intends to test them all.\n");
	mil.line("var b_int := bat(int,str).insert(1,\"1\").insert(2,\"2\").insert(1,\"1\");");
	aa_a := new(nil:int,nil:str);
	ba_a := insert(aa_a,1,"1");
	ca_a := insert(ba_a,2,"2");
	b_int := insert(ca_a,1,"1");
	mil.line("b_int.insert(3,\"3\").insert(4,\"4\").insert(5,\"5\").insert(6,\"6\");");
	da_a := insert(b_int,3,"3");
	ea_a := insert(da_a,4,"4");
	fa_a := insert(ea_a,5,"5");
	ga_a := insert(fa_a,6,"6");
	mil.line("b_int.insert(3,\"3\").insert(4,\"4\").insert(5,\"5\").insert(6,\"6\");");
	ha_a := insert(b_int,3,"3");
	ia_a := insert(ha_a,4,"4");
	ja_a := insert(ia_a,5,"5");
	ka_a := insert(ja_a,6,"6");
	mil.line("var b_sht := [sht](b_int.reverse()).reverse();");
	la_a := reverse(b_int);
	ma_a := multiplex.tactics("sht",la_a);
	b_sht := reverse(ma_a);
	mil.line("var b_chr := [chr](b_int.reverse()).reverse();");
	na_a := reverse(b_int);
	oa_a := multiplex.tactics("chr",na_a);
	b_chr := reverse(oa_a);
	mil.line("var b_str := [str](b_int.reverse()).reverse();");
	pa_a := reverse(b_int);
	qa_a := multiplex.tactics("str",pa_a);
	b_str := reverse(qa_a);
	mil.line("var v_oid := bat(void,str).insert(nil,\"1\").insert(nil,\"2\").insert(nil,\"3\");");
	ra_a := new(nil:void,nil:str);
	sa_a := insert(ra_a,nil,"1");
	ta_a := insert(sa_a,nil,"2");
	v_oid := insert(ta_a,nil,"3");
	mil.line("v_oid.insert(nil,\"4\").insert(nil,\"5\").insert(nil,\"6\").seqbase(1@0);");
	ua_a := insert(v_oid,nil,"4");
	va_a := insert(ua_a,nil,"5");
	wa_a := insert(va_a,nil,"6");
	xa_a := bat.setSequenceBase(wa_a,1@0);
	mil.line("var e_int := bat(int,void).insert(1,nil).insert(3,nil).insert(4,nil).insert(5,nil);");
	ya_a := new(nil:int,nil:void);
	ab_a := insert(ya_a,1,nil);
	bb_a := insert(ab_a,3,nil);
	cb_a := insert(bb_a,4,nil);
	e_int := insert(cb_a,5,nil);
	mil.line("e_int.insert(6,nil).insert(7,nil).insert(8,nil).col_name(\"e_int\");");
	db_a := insert(e_int,6,nil);
	eb_a := insert(db_a,7,nil);
	fb_a := insert(eb_a,8,nil);
	gb_a := bat.setColumn(fb_a,"e_int");
	mil.line("var e_sht := [sht](e_int.reverse()).reverse().col_name(\"e_sht\");");
	hb_a := reverse(e_int);
	ib_a := multiplex.tactics("sht",hb_a);
	jb_a := reverse(ib_a);
	e_sht := bat.setColumn(jb_a,"e_sht");
	mil.line("var e_chr := [chr](e_int.reverse()).reverse().col_name(\"e_chr\");");
	kb_a := reverse(e_int);
	lb_a := multiplex.tactics("chr",kb_a);
	mb_a := reverse(lb_a);
	e_chr := bat.setColumn(mb_a,"e_chr");
	mil.line("var e_str := [str](e_int.reverse()).reverse().col_name(\"e_str\");");
	nb_a := reverse(e_int);
	ob_a := multiplex.tactics("str",nb_a);
	pb_a := reverse(ob_a);
	e_str := bat.setColumn(pb_a,"e_str");
	mil.line("var e_oid := [oid](e_int.reverse()).reverse().col_name(\"e_oid\");");
	qb_a := reverse(e_int);
	rb_a := multiplex.tactics("oid",qb_a);
	sb_a := reverse(rb_a);
	e_oid := bat.setColumn(sb_a,"e_oid");
	mil.line("var tests := bat(bat,bat);");
	tests := new(:bat[:any$1,:any$2],:bat[:any$3,:any$4]);
	mil.line("tests.insert(b_int.col_name(\"b_int\"), e_int);");
	tb_a := bat.setColumn(b_int,"b_int");
	ub_a := insert(tests,tb_a,e_int);
	mil.line("tests.insert(b_sht.col_name(\"b_sht\"), e_sht);");
	vb_a := bat.setColumn(b_sht,"b_sht");
	wb_a := insert(tests,vb_a,e_sht);
	mil.line("tests.insert(b_chr.col_name(\"b_chr\"), e_chr);");
	xb_a := bat.setColumn(b_chr,"b_chr");
	yb_a := insert(tests,xb_a,e_chr);
	mil.line("tests.insert(b_str.col_name(\"b_str\"), e_str);");
	ac_a := bat.setColumn(b_str,"b_str");
	bc_a := insert(tests,ac_a,e_str);
	mil.line("tests.insert(v_oid.col_name(\"v_oid\"), e_oid);");
	cc_a := bat.setColumn(v_oid,"v_oid");
	dc_a := insert(tests,cc_a,e_oid);
	mil.line("tests.insert(b_int.sort().col_name(\"s_int\"), e_int);");
	ec_a := sort(b_int);
	fc_a := bat.setColumn(ec_a,"s_int");
	gc_a := insert(tests,fc_a,e_int);
	mil.line("tests.insert(b_sht.sort().col_name(\"s_sht\"), e_sht);");
	hc_a := sort(b_sht);
	ic_a := bat.setColumn(hc_a,"s_sht");
	jc_a := insert(tests,ic_a,e_sht);
	mil.line("tests.insert(b_chr.sort().col_name(\"s_chr\"), e_chr);");
	kc_a := sort(b_chr);
	lc_a := bat.setColumn(kc_a,"s_chr");
	mc_a := insert(tests,lc_a,e_chr);
	mil.line("tests.insert(b_str.sort().col_name(\"s_str\"), e_str);");
	nc_a := sort(b_str);
	oc_a := bat.setColumn(nc_a,"s_str");
	pc_a := insert(tests,oc_a,e_str);
	mil.line("proc idx(bat[any,any] b) : bat {");
function idx(b:bat[:any$1,:any$2]):bat[:any$3,:any$4];
	mil.line("\tb.accbuild(\"index\");");
	qc_a := accbuild(b,"index");
	mil.line("\treturn b;");
	return rc_a :=b;
end idx;
	mil.line("tests.insert(b_int.copy().idx().col_name(\"i_int\"), e_int);");
	sc_a := copy(b_int);
	tc_a := idx(sc_a);
	uc_a := bat.setColumn(tc_a,"i_int");
	vc_a := insert(tests,uc_a,e_int);
	mil.line("tests.insert(b_sht.copy().idx().col_name(\"i_sht\"), e_sht);");
	wc_a := copy(b_sht);
	xc_a := idx(wc_a);
	yc_a := bat.setColumn(xc_a,"i_sht");
	ad_a := insert(tests,yc_a,e_sht);
	mil.line("tests.insert(b_chr.copy().idx().col_name(\"i_chr\"), e_chr);");
	bd_a := copy(b_chr);
	cd_a := idx(bd_a);
	dd_a := bat.setColumn(cd_a,"i_chr");
	ed_a := insert(tests,dd_a,e_chr);
	mil.line("tests.insert(b_str.copy().idx().col_name(\"i_str\"), e_str);");
	fd_a := copy(b_str);
	gd_a := idx(fd_a);
	hd_a := bat.setColumn(gd_a,"i_str");
	id_a := insert(tests,hd_a,e_str);
	mil.line("proc ku(bat[any,any] b) : bat[any,any] {");
function ku(b:bat[:any$1,:any$2]):bat[:any$3,:any$4];
	mil.line("\treturn kunique(b);");
	return jd_a :=kunique(b);
end ku;
	mil.line("proc mstr(int i) : str {");
function mstr(i:int):str;
	mil.line("\tif (isnil(i)) {");
barrier	kd_a := isnil(i);
	mil.line("\t\treturn \"nil\";");
	return ld_a :="nil";
	mil.line("\treturn str(i);");
exit	kd_a;
	return md_a :=str(i);
end mstr;
	mil.line("proc mset_print(bat[any,bat] m) :void {");
function mset_print(m:bat[:any$1,:bat]):void;
	mil.line("    m@batloop() {");
barrier	(nd_a,nd_aH,nd_aT) := newIterator(m);
	mil.line("        var h := $h;");
	h := nd_aH;
	mil.line("        var t := $t;");
	t := nd_aT;
	mil.line("        t@batloop() {");
barrier	(od_a,od_aH,od_aT) := newIterator(t);
	mil.line("            printf(\"\\t%s\\t%s\\n\", mstr(int(h)), mstr(int($t)));");
	pd_a := int(h);
	qd_a := mstr(pd_a);
	rd_a := int(od_aT);
	sd_a := mstr(rd_a);
	td_a := printf("\t%s\t%s\n",qd_a,sd_a);
redo	(od_a,od_aH,od_aT) := hasMoreElements(t);
exit	(od_a,od_aH,od_aT) ;
redo	(nd_a,nd_aH,nd_aT) := hasMoreElements(m);
exit	(nd_a,nd_aH,nd_aT) ;
end mset_print;
	mil.line("proc set_print(bat[any,any] b) :void {");
function set_print(b:bat[:any$1,:any$2]):void;
	mil.line("    b@batloop() {");
barrier	(ud_a,ud_aH,ud_aT) := newIterator(b);
	mil.line("        printf(\"\\t%s\\t%s\\n\", mstr(int($h)), mstr(int($t)));");
	vd_a := int(ud_aH);
	wd_a := mstr(vd_a);
	xd_a := int(ud_aT);
	yd_a := mstr(xd_a);
	ae_a := printf("\t%s\t%s\n",wd_a,yd_a);
redo	(ud_a,ud_aH,ud_aT) := hasMoreElements(b);
exit	(ud_a,ud_aH,ud_aT) ;
end set_print;
	mil.line("# start testing, switch mask that tells us which implementation is actually used\n");
	be_a := setDebug(131072);
	mil.line("tests@batloop() {");
barrier	(ce_a,ce_aH,ce_aT) := newIterator(tests);
	mil.line("\tprintf(\"\\n# test proc {kunique}(%s)\\n\", $h.bbpname());");
	de_a := getName(ce_aH);
	ee_a := printf("\n# test proc {kunique}(%s)\n",de_a);
	mil.line("\t{ku}($h).mset_print();");
	fe_a := group.ku(ce_aH);
	ge_a := mset_print(fe_a);
redo	(ce_a,ce_aH,ce_aT) := hasMoreElements(tests);
exit	(ce_a,ce_aH,ce_aT) ;
	mil.line("tests@batloop() {");
barrier	(he_a,he_aH,he_aT) := newIterator(tests);
	mil.line("\tprintf(\"\\n# test proc {kunique}(%s,%s)\\n\", $h.bbpname(), $t.bbpname());");
	ie_a := getName(he_aH);
	je_a := getName(he_aT);
	ke_a := printf("\n# test proc {kunique}(%s,%s)\n",ie_a,je_a);
	mil.line("\t{ku}($h,$t).mset_print();");
	le_a := group.ku(he_aH,he_aT);
	me_a := mset_print(le_a);
redo	(he_a,he_aH,he_aT) := hasMoreElements(tests);
exit	(he_a,he_aH,he_aT) ;
	mil.line("tests@batloop() {");
barrier	(ne_a,ne_aH,ne_aT) := newIterator(tests);
	mil.line("\tprintf(\"\\n# test packed {kunique}(%s)\\n\", $h.bbpname());");
	oe_a := getName(ne_aH);
	pe_a := printf("\n# test packed {kunique}(%s)\n",oe_a);
	mil.line("\t{kunique}($h).mset_print();");
	qe_a := group.kunique(ne_aH);
	re_a := mset_print(qe_a);
redo	(ne_a,ne_aH,ne_aT) := hasMoreElements(tests);
exit	(ne_a,ne_aH,ne_aT) ;
	mil.line("tests@batloop() {");
barrier	(se_a,se_aH,se_aT) := newIterator(tests);
	mil.line("\tprintf(\"\\n# test packed {max}(%s,%s)\\n\", $h.bbpname(), $t.bbpname());");
	te_a := getName(se_aH);
	ue_a := getName(se_aT);
	ve_a := printf("\n# test packed {max}(%s,%s)\n",te_a,ue_a);
	mil.line("\t{max}($h,$t).set_print();");
	we_a := group.max(se_aH,se_aT);
	xe_a := set_print(we_a);
redo	(se_a,se_aH,se_aT) := hasMoreElements(tests);
exit	(se_a,se_aH,se_aT) ;
	mil.line("tests@batloop() {");
barrier	(ye_a,ye_aH,ye_aT) := newIterator(tests);
	mil.line("\tprintf(\"\\n# test direct {max}(%s)\\n\", $h.bbpname());");
	af_a := getName(ye_aH);
	bf_a := printf("\n# test direct {max}(%s)\n",af_a);
	mil.line("\t{max}([int]($h)).set_print();");
	cf_a := multiplex.tactics("int",ye_aH);
	df_a := group.max(cf_a);
	ef_a := set_print(df_a);
redo	(ye_a,ye_aH,ye_aT) := hasMoreElements(tests);
exit	(ye_a,ye_aH,ye_aT) ;
	mil.line("tests@batloop() {");
barrier	(ff_a,ff_aH,ff_aT) := newIterator(tests);
	mil.line("\tprintf(\"\\n# test direct {max}(%s,%s)\\n\", $h.bbpname(), $t.bbpname());");
	gf_a := getName(ff_aH);
	hf_a := getName(ff_aT);
	if_a := printf("\n# test direct {max}(%s,%s)\n",gf_a,hf_a);
	mil.line("\t{max}([int]($h),$t).set_print();");
	jf_a := multiplex.tactics("int",ff_aH);
	kf_a := group.max(jf_a,ff_aT);
	lf_a := set_print(kf_a);
redo	(ff_a,ff_aH,ff_aT) := hasMoreElements(tests);
exit	(ff_a,ff_aH,ff_aT) ;
	mil.line("quit();");
	mf_a := quit();
#Identifer 'col_name' mapped to 'bat.setColumn'
#Identifer 'seqbase' mapped to 'bat.setSequenceBase'
#Identifer 'bbpname' mapped to 'getName'
#Identifer 'debugmask' mapped to 'setDebug'
