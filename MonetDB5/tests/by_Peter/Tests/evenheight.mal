# Monet Mil to Mal compiler
# Copyright (c) 2001-2004, CWI. All rights reserved.

#Predefined code segment
#The compiler can not guarantee an accurate compilation,
#because MIL unlike MAL is a dynamically typed language.
#A few guidelines to maximize usefullness.
#- make the type of variables explicit, in particular 'nil'
#- upon advice of M2m to remap identifiers, change it in your program directly
#use the "mil_schema" for additional support routines
	mil.line("# The main procedure is evenheight(bat_param,nranges) \n");
	mil.line("# it produces a new bat with an even-height remapping of tail-values.\n");
	mil.line("# this computes the weighed midpoint of a range 'low'..'high'\n");
	mil.line("# the weights are taken from the sorted histogram 'hst' \n");
	mil.line("#\n");
function compute_mid(hst:bat[:any$1,:any$2], low:any$3, high:any$4):void;
	mil.line("    var members := hst.reverse().select(low,high);");
	aa_a := reverse(hst);
	members := select(aa_a,low,high);
	mil.line("    var weighed := new(int, members.ttype(), members.count());");
	ba_a := getTailType(members);
	ca_a := count(members);
	weighed := new(nil:int,ba_a,ca_a);
	mil.line("    var mid := nil.cast(hst.htype());");
	da_a := getHeadType(hst);
	mid := cast(nil,da_a);
	mil.line("    var cum := 0;");
	cum := 0;
	mil.line("    members@batloop() {");
barrier	(ea_a,ea_aH,ea_aT) := newIterator(members);
	mil.line("        cum := cum + $h;");
	cum := +(cum,ea_aH);
	mil.line("        weighed.insert(cum, $t);");
	fa_a := insert(weighed,cum,ea_aT);
redo	(ea_a,ea_aH,ea_aT) := hasMoreElements(members);
exit	(ea_a,ea_aH,ea_aT) ;
	mil.line("    weighed@batloop() {");
barrier	(ga_a,ga_aH,ga_aT) := newIterator(weighed);
	mil.line("        mid := $t;");
	mid := ga_aT;
	mil.line("        if ($h >= (cum / 2)) break;");
	ha_a := /(cum,2);
barrier	ia_a := >=(ga_aH,ha_a);
leave	ga_a;
	mil.line("    }");
exit	ia_a;
redo	(ga_a,ga_aH,ga_aT) := hasMoreElements(weighed);
exit	(ga_a,ga_aH,ga_aT) ;
	mil.line("    return mid;");
	return ja_a :=mid;
end compute_mid;
	mil.line("# we construct an equal-height partitioning range for the tail columns\n");
	mil.line("# of a bat. This partitioning range is represented by a new 'range-bat'.\n");
	mil.line("# Each BUN in the range-bat represents 1 range. Its tail contains the maximum \n");
	mil.line("# range value (tails are sorted); its head contains the representative value.\n");
	mil.line("#\n");
	mil.line("# The below proc constructs such a range-bat iteratively using\n");
	mil.line("# a histogram. This algorithms dynamically adapts the ideal \n");
	mil.line("# group-size 'ideal' to obtain a nicely balanced result.\n");
	mil.line("#\n");
function range_bat(b:bat[:any$1,:any$2], n:int):bat[:any$3,:any$4];
	mil.line("    var      histo := b.histogram().sort(); # sort it!");
	ka_a := histogram(b);
	histo := sort(ka_a);
	mil.line("# sort it!\n");
	la_a := getTailType(b);
	ma_a := getTailType(b);
	na_a := *(n,4);
	oa_a := /(na_a,3);
	ranges := new(la_a,ma_a,oa_a);
	mil.line("    var    cursize := 0;");
	cursize := 0;
	mil.line("    var items_left := b.count();");
	items_left := count(b);
	mil.line("    histo@batloop() {");
barrier	(pa_a,pa_aH,pa_aT) := newIterator(histo);
	mil.line("        var idealsize := items_left/n;");
	idealsize := /(items_left,n);
	mil.line("        if (cursize = 0) {");
barrier	qa_a := ==(cursize,0);
	mil.line("            first_h := $h; # the lowest element of the range");
	first_h := pa_aH;
	mil.line("# the lowest element of the range\n");
	mil.line("        cursize := cursize + $t;");
exit	qa_a;
	cursize := +(cursize,pa_aT);
	mil.line("        if (cursize >= idealsize) {");
barrier	ra_a := >=(cursize,idealsize);
	mil.line("# ok, we must create a new group\n");
	sa_a := -(cursize,idealsize);
	ta_a := -(cursize,pa_aT);
	ua_a := -(idealsize,ta_a);
barrier	va_a := <=(sa_a,ua_a);
	mil.line("                items_left := items_left - cursize;");
	items_left := -(items_left,cursize);
	mil.line("\t             mid_h := histo.compute_mid(first_h, $h);");
	mid_h := compute_mid(histo,first_h,pa_aH);
	mil.line("                    last_h := $h;");
	last_h := pa_aH;
	mil.line("                   cursize := 0;");
	cursize := 0;
	mil.line("            } else {");
exit	va_a;
barrier	wa_a := not(va_a);
	mil.line("# group would be too large with the current\n");
	mil.line("# element in it. Keep the current for the next grp.\n");
	mil.line("#\n");
	xa_a := -(cursize,pa_aT);
	items_left := -(items_left,xa_a);
	mil.line("\t             mid_h := histo.compute_mid(first_h, last_h);");
	mid_h := compute_mid(histo,first_h,last_h);
	mil.line("                   first_h := $h;");
	first_h := pa_aH;
	mil.line("                   cursize := $t;");
	cursize := pa_aT;
exit	wa_a;
	mil.line("# insert the new group description\n");
	ya_a := insert(ranges,mid_h,last_h);
	mil.line("            n := n - 1;");
	n := -(n,1);
	mil.line("        last_h := $h;");
exit	ra_a;
	last_h := pa_aH;
redo	(pa_a,pa_aH,pa_aT) := hasMoreElements(histo);
exit	(pa_a,pa_aH,pa_aT) ;
	mil.line("    return ranges;");
	return ab_a :=ranges;
end range_bat;
	mil.line("# use the range-bat to convert one value to its representative value.\n");
function convert_val(v:any$1, rng:any$2):any$3;
	mil.line("        rng@batloop() {");
barrier	(bb_a,bb_aH,bb_aT) := newIterator(rng);
	mil.line("\t\tif ($t >= v) return $h;");
barrier	cb_a := >=(bb_aT,v);
	return db_a :=bb_aH;
	mil.line("\t}");
exit	cb_a;
redo	(bb_a,bb_aH,bb_aT) := hasMoreElements(rng);
exit	(bb_a,bb_aH,bb_aT) ;
	mil.line("        return nil.cast(v.type());");
	eb_a := type(v);
	return fb_a :=cast(nil,eb_a);
end convert_val;
	mil.line("# OVERALL USEABLE PROC\n");
function evenheight(b:bat[:any$1,:any$2], n:int):bat[:any$3,:any$4];
	mil.line("        var rng := range_bat(b, n);");
	rng := range_bat(b,n);
	mil.line("        print(rng); # print the range (for debugging purposes)");
	gb_a := print(rng);
	mil.line("# print the range (for debugging purposes)\n");
	return hb_a :=multiplex.tactics("convert_val",b,rng);
end evenheight;
	mil.line("# TESTING\n");
	mil.line("var TheSize := 1000;");
	TheSize := 1000;
	mil.line("var def_tpe := new(int,int);");
	def_tpe := new(nil:int,nil:int);
	mil.line("var i := 0;");
	i := 0;
	mil.line("while (i<TheSize) { def_tpe.insert(i,rand()); i:+=1; }");
barrier	ib_a := true;
barrier	jb_a := <(i,TheSize);
	kb_a := rand();
	lb_a := insert(def_tpe,i,kb_a);
	mb_a := +(i,1);
redo	ib_a;
exit	jb_a;
exit	ib_a;
	mil.line("var a := [str](def_tpe.mark(100000@0)).reverse().mirror();");
	nb_a := mark(def_tpe,100000@0);
	ob_a := multiplex.tactics("str",nb_a);
	pb_a := reverse(ob_a);
	a := mirror(pb_a);
	mil.line("var b := a.range_bat(10);");
	b := range_bat(a,10);
	mil.line("var c := [int](b.reverse().mirror());");
	qb_a := reverse(b);
	rb_a := mirror(qb_a);
	c := multiplex.tactics("int",rb_a);
	mil.line("var d := [int](b.reverse());");
	sb_a := reverse(b);
	d := multiplex.tactics("int",sb_a);
	mil.line("print([-](c,d),b.reverse());");
	tb_a := multiplex.tactics("-",c,d);
	ub_a := reverse(b);
	vb_a := print(tb_a,ub_a);
	mil.line("var aa := a.evenheight(9);");
	aa := evenheight(a,9);
	mil.line("var z1 := new(int,int);");
	z1 := new(nil:int,nil:int);
	mil.line("var z2 := new(int,int);");
	z2 := new(nil:int,nil:int);
	mil.line("i := 0;");
	i := 0;
	mil.line("while (i<TheSize) { z1.insert(i,rand()); z2.insert(i,i); i:+=1; }");
barrier	wb_a := true;
barrier	xb_a := <(i,TheSize);
	yb_a := rand();
	ac_a := insert(z1,i,yb_a);
	bc_a := insert(z2,i,i);
	cc_a := +(i,1);
redo	wb_a;
exit	xb_a;
exit	wb_a;
	mil.line("printf(\"#~BeginVariableOutput~#\\n\"); var z1z:=z1.evenheight(8); printf(\"#~EndVariableOutput~#\\n\");");
	dc_a := printf("#~BeginVariableOutput~#\n");
	z1z := evenheight(z1,8);
	ec_a := printf("#~EndVariableOutput~#\n");
	mil.line("var z2z:=z2.evenheight(8);");
	z2z := evenheight(z2,8);
	mil.line("quit();");
	fc_a := quit();
#Identifer 'htype' mapped to 'getHeadType'
#Identifer 'ttype' mapped to 'getTailType'
