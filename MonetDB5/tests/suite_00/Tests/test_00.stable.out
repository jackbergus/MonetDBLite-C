stdout of test 'test_00` in directory 'tests/suite_00` itself:


# 11:45:02 >  
# 11:45:02 >   mserver5 "--config=/ufs/mk/monet5/Linux/etc/monetdb5.conf" --debug=10 --set "monet_mod_path=/ufs/mk/monet5//Linux/lib/MonetDB5:/ufs/mk/monet5//Linux/lib/MonetDB5/lib:/ufs/mk/monet5//Linux/lib/MonetDB5/bin" --set "gdk_dbfarm=/ufs/mk/monet5//Linux/var/MonetDB5/dbfarm" --set "sql_logdir=/ufs/mk/monet5//Linux/var/MonetDB5/sql_logs"  --set mapi_open=true --set xrpc_open=true --set mapi_port=34848 --set xrpc_port=46218 --set monet_prompt= --trace --dbname=mTests_tests_suite_00  test_00.mal
# 11:45:02 >  

!WARNING: GDKlockHome: ignoring empty or invalid .gdk_lock.
!WARNING: BBPdir: initializing BBP.
# MonetDB server v5.3.0, based on kernel v1.21.0
# Serving database 'mTests_tests_suite_00'
# Compiled for x86_64-redhat-linux-gnu/64bit with 64bit OIDs dynamically linked
# Copyright (c) 1993-2007 CWI, all rights reserved
# Visit http://monetdb.cwi.nl/ for further information
# Listening for connection requests on mapi:monetdb://gio.ins.cwi.nl:34848/
## Monet Mil to Mal compiler
## Copyright (c) 2001-2004, CWI. All rights reserved.
#
##Predefined code segment
##The compiler can not guarantee an accurate compilation,
##because MIL unlike MAL is a dynamically typed language.
##A few guidelines to maximize usefullness.
##- make the type of variables explicit, in particular 'nil'
##- upon advice of M2m to remap identifiers, change it in your program directly
##use the "mil_schema" for additional support routines
##	io.print("setoid(oid(20000000));");
#	aa_a := calc.oid(20000000);
#	ba_a := calc.setoid(aa_a);
##	io.print("#test basic functionality of the BAT library.\n");
##	io.print("#focussed on integers\n");
##	io.print("#it includes bat.insertions,deletions,selections, and algebra.joins.\n");
##	io.print("var b:= new(int,int);");
#	b := bat.new(nil:int,nil:int);
##	io.print("#b.roles(\"head\",\"tail\"); roles was removed from the kernel ops\n");
#	ca_a := io.printf("#~BeginVariableOutput~#\n");
#	da_a := bat.info(b);
#	ea_a := io.print(da_a);
#	fa_a := io.printf("#~EndVariableOutput~#\n");
##	io.print("b.insert(1,15);");
#	ga_a := bat.insert(b,1,15);
##	io.print("b.insert(2,4);");
#	ha_a := bat.insert(b,2,4);
##	io.print("b.insert(3,int(nil));");
#	ia_a := calc.int(nil);
#	ja_a := bat.insert(b,3,ia_a);
##	io.print("b.insert(4,16);");
#	ka_a := bat.insert(b,4,16);
##	io.print("b.insert(5,25);");
#	la_a := bat.insert(b,5,25);
##	io.print("b.insert(6,36);");
#	ma_a := bat.insert(b,6,36);
##	io.print("b.insert(7,49);");
#	na_a := bat.insert(b,7,49);
##	io.print("b.insert(8,64);");
#	oa_a := bat.insert(b,8,64);
##	io.print("b.insert(9,int(nil));");
#	pa_a := calc.int(nil);
#	qa_a := bat.insert(b,9,pa_a);
##	io.print("b.insert(int(nil),int(nil));");
#	ra_a := calc.int(nil);
#	sa_a := calc.int(nil);
#	ta_a := bat.insert(b,ra_a,sa_a);
##	io.print("b.insert(int(nil),81);");
#	ua_a := calc.int(nil);
#	va_a := bat.insert(b,ua_a,81);
##	io.print("b.print();");
#	wa_a := io.print(b);
##	io.print("# Testing simple retrievals\n");
#	xa_a := algebra.find(b,1);
#	ya_a := io.print(xa_a);
##	io.print("b.find(4).print();");
#	ab_a := algebra.find(b,4);
#	bb_a := io.print(ab_a);
##	io.print("b.find(int(nil)).print();");
#	cb_a := calc. int(nil);
#	db_a := algebra.find(b,cb_a);
#	eb_a := io.print(db_a);
##	io.print("# This should cause an error\n");
##ignore	fb_a := find(b,10);
##ignore	gb_a := io.print(fb_a);
##	io.print("# Can we delete them and re-insert them later on\n");
#	hb_a := bat.delete(b,4,16);
##	io.print("b.delete(1,15);");
#	ib_a := bat.delete(b,1,15);
##	io.print("b.delete(int(nil),81);");
#	jb_a := calc. int(nil);
#	kb_a := bat.delete(b,jb_a,81);
##	io.print("b.print();");
#	lb_a := io.print(b);
##	io.print("b.insert(4,16);");
#	mb_a := bat.insert(b,4,16);
##	io.print("b.insert(int(nil),81);");
#	nb_a := calc.int(nil);
#	ob_a := bat.insert(b,nb_a,81);
##	io.print("b.insert(1,15);");
#	pb_a := bat.insert(b,1,15);
##	io.print("b.count().print();");
#	qb_a := aggr.count(b);
#	rb_a := io.print(qb_a);
##	io.print("b.print();");
#	sb_a := io.print(b);
##	io.print("# Lets cut out a few sections\n");
#	tb_a := algebra.select(b,25,64);
#	ub_a := io.print(tb_a);
##	io.print("b.select(4,15).print();");
#	vb_a := algebra.select(b,4,15);
#	wb_a := io.print(vb_a);
##	io.print("b.select(4,4).print();");
#	xb_a := algebra.select(b,4,4);
#	yb_a := io.print(xb_a);
##	io.print("# This should cause an error\n");
#	ac_a := algebra.select(b,4,3);
#	bc_a := io.print(ac_a);
##	io.print("b.select(81,int(nil)).print();");
#	cc_a := calc.int(nil);
#	dc_a := algebra.select(b,81,cc_a);
#	ec_a := io.print(dc_a);
##	io.print("b.select(int(nil),int(nil)).print();");
#	fc_a := calc.int(nil);
#	gc_a := calc.int(nil);
#	hc_a := algebra.select(b,fc_a,gc_a);
#	ic_a := io.print(hc_a);
##	io.print("# A 2-dimensional cut\n");
#	bn := algebra.fragment(b,1,5,4,15);
#	jc_a := io.print(bn);
##	io.print("b.fragment(1,5,16,int(nil)).print();");
#	kc_a := calc.int(nil);
#	lc_a := algebra.fragment(b,1,5,16,kc_a);
#	mc_a := io.print(lc_a);
##	io.print("b.fragment(1,int(nil),16,int(nil)).print();");
#	nc_a := calc.int(nil);
#	oc_a := calc.int(nil);
#	pc_a := algebra.fragment(b,1,nc_a,16,oc_a);
#	qc_a := io.print(pc_a);
##	io.print("b.fragment(int(nil),int(nil),16,int(nil)).print();");
#	rc_a := calc.int(nil);
#	sc_a := calc.int(nil);
#	tc_a := calc.int(nil);
#	uc_a := algebra.fragment(b,rc_a,sc_a,16,tc_a);
#	vc_a := io.print(uc_a);
##	io.print("bn:= b.join(bn.reverse());");
#	wc_a := bat.reverse(bn);
#	bn := algebra.join(b,wc_a);
##	io.print("bn.print();");
#	xc_a := io.print(bn);
##	io.print("bn:= b.semijoin(bn.reverse());");
#	yc_a := bat.reverse(bn);
#	bn := algebra.semijoin(b,yc_a);
##	io.print("bn.print();");
#	ad_a := io.print(bn);
##	io.print("# band algebra.join experiment\n");
#	c := algebra.copy(b);
##	io.print("bandjoin(b,c,4,4).print();");
#	bd_a := algebra.bandjoin(b,c,4,4);
#	cd_a := io.print(bd_a);
##	io.print("#and theta algebra.joins\?\n");
#	LT:= -1;
#	dd_a := calc.lng(nil);
#	ed_a := algebra.thetajoin(b,c,LT,dd_a);
#	fd_a := io.print(ed_a);
##	io.print("quit();");
#	gd_a := clients.quit();
#
function user.main():void;              #  0 main:void {G}
# Monet Mil to Mal compiler 
# Copyright (c) 2001-2004, CWI. All rights reserved. 
#Predefined code segment 
#The compiler can not guarantee an accurate compilation, 
#because MIL unlike MAL is a dynamically typed language. 
#A few guidelines to maximize usefullness. 
#- make the type of variables explicit, in particular 'nil' 
#- upon advice of M2m to remap identifiers, change it in your program directly 
#use the "mil_schema" for additional support routines 
#	io.print("setoid(oid(20000000));"); 
    aa_a := calc.oid(20000000);         # 11 aa_a:oid := CALCint2oid(_12:int) 
    ba_a := calc.setoid(aa_a);          # 12 ba_a:oid := CALCsetoidInc(aa_a:oid) 
#	io.print("#test basic functionality of the BAT library.\n"); 
#	io.print("#focussed on integers\n"); 
#	io.print("#it includes bat.insertions,deletions,selections, and algebra.joins.\n"); 
#	io.print("var b:= new(int,int);"); 
    b := bat.new(nil:int,nil:int);      # 17 b:bat[:int,:int] := CMDBATnew(_19:int, _19:int) {G}
#	io.print("#b.roles(\"head\",\"tail\"); roles was removed from the kernel ops\n"); 
    ca_a := io.printf("#~BeginVariableOutput~#\n");# 19 ca_a:void := IOprint_str(_22:str) 
    da_a := bat.info(b);                # 20 da_a:bat[:str,:str] := BKCinfo(b:bat[:int,:int]) {G}
    ea_a := io.print(da_a);             # 21 ea_a:void := IOprint_val(da_a:bat[:str,:str]) 
    fa_a := io.printf("#~EndVariableOutput~#\n");# 22 fa_a:void := IOprint_str(_26:str) 
#	io.print("b.insert(1,15);"); 
    ga_a := bat.insert(b,1,15);         # 24 ga_a:void := BKCinsert_bun(b:bat[:int,:int], _29:int, _30:int) 
#	io.print("b.insert(2,4);"); 
    ha_a := bat.insert(b,2,4);          # 26 ha_a:void := BKCinsert_bun(b:bat[:int,:int], _33:int, _34:int) 
#	io.print("b.insert(3,int(nil));"); 
    ia_a := calc.int(nil:void);         # 28 ia_a:int := CALCnil2int(_37:void) 
    ja_a := bat.insert(b,3,ia_a);       # 29 ja_a:void := BKCinsert_bun(b:bat[:int,:int], _39:int, ia_a:int) 
#	io.print("b.insert(4,16);"); 
    ka_a := bat.insert(b,4,16);         # 31 ka_a:void := BKCinsert_bun(b:bat[:int,:int], _34:int, _42:int) 
#	io.print("b.insert(5,25);"); 
    la_a := bat.insert(b,5,25);         # 33 la_a:void := BKCinsert_bun(b:bat[:int,:int], _45:int, _46:int) 
#	io.print("b.insert(6,36);"); 
    ma_a := bat.insert(b,6,36);         # 35 ma_a:void := BKCinsert_bun(b:bat[:int,:int], _49:int, _50:int) 
#	io.print("b.insert(7,49);"); 
    na_a := bat.insert(b,7,49);         # 37 na_a:void := BKCinsert_bun(b:bat[:int,:int], _53:int, _54:int) 
#	io.print("b.insert(8,64);"); 
    oa_a := bat.insert(b,8,64);         # 39 oa_a:void := BKCinsert_bun(b:bat[:int,:int], _57:int, _58:int) 
#	io.print("b.insert(9,int(nil));"); 
    pa_a := calc.int(nil:void);         # 41 pa_a:int := CALCnil2int(_37:void) 
    qa_a := bat.insert(b,9,pa_a);       # 42 qa_a:void := BKCinsert_bun(b:bat[:int,:int], _62:int, pa_a:int) 
#	io.print("b.insert(int(nil),int(nil));"); 
    ra_a := calc.int(nil:void);         # 44 ra_a:int := CALCnil2int(_37:void) 
    sa_a := calc.int(nil:void);         # 45 sa_a:int := CALCnil2int(_37:void) 
    ta_a := bat.insert(b,ra_a,sa_a);    # 46 ta_a:void := BKCinsert_bun(b:bat[:int,:int], ra_a:int, sa_a:int) 
#	io.print("b.insert(int(nil),81);"); 
    ua_a := calc.int(nil:void);         # 48 ua_a:int := CALCnil2int(_37:void) 
    va_a := bat.insert(b,ua_a,81);      # 49 va_a:void := BKCinsert_bun(b:bat[:int,:int], ua_a:int, _70:int) 
#	io.print("b.print();"); 
    wa_a := io.print(b);                # 51 wa_a:void := IOprint_val(b:bat[:int,:int]) 
#	io.print("# Testing simple retrievals\n"); 
    xa_a := algebra.find(b,1);          # 53 xa_a:int := ALGfind(b:bat[:int,:int], _75:int) 
    ya_a := io.print(xa_a);             # 54 ya_a:void := IOprint_val(xa_a:int) 
#	io.print("b.find(4).print();"); 
    ab_a := algebra.find(b,4);          # 56 ab_a:int := ALGfind(b:bat[:int,:int], _79:int) 
    bb_a := io.print(ab_a);             # 57 bb_a:void := IOprint_val(ab_a:int) 
#	io.print("b.find(int(nil)).print();"); 
    cb_a := calc.int(nil:void);         # 59 cb_a:int := CALCnil2int(_83:void) 
    db_a := algebra.find(b,cb_a);       # 60 db_a:int := ALGfind(b:bat[:int,:int], cb_a:int) 
    eb_a := io.print(db_a);             # 61 eb_a:void := IOprint_val(db_a:int) 
#	io.print("# This should cause an error\n"); 
#ignore	fb_a := find(b,10); 
#ignore	gb_a := io.print(fb_a); 
#	io.print("# Can we delete them and re-insert them later on\n"); 
    hb_a := bat.delete(b,4,16);         # 66 hb_a:void := BKCdelete_bun(b:bat[:int,:int], _79:int, _91:int) 
#	io.print("b.delete(1,15);"); 
    ib_a := bat.delete(b,1,15);         # 68 ib_a:void := BKCdelete_bun(b:bat[:int,:int], _75:int, _94:int) 
#	io.print("b.delete(int(nil),81);"); 
    jb_a := calc.int(nil:void);         # 70 jb_a:int := CALCnil2int(_83:void) 
    kb_a := bat.delete(b,jb_a,81);      # 71 kb_a:void := BKCdelete_bun(b:bat[:int,:int], jb_a:int, _70:int) 
#	io.print("b.print();"); 
    lb_a := io.print(b);                # 73 lb_a:void := IOprint_val(b:bat[:int,:int]) 
#	io.print("b.insert(4,16);"); 
    mb_a := bat.insert(b,4,16);         # 75 mb_a:void := BKCinsert_bun(b:bat[:int,:int], _79:int, _91:int) 
#	io.print("b.insert(int(nil),81);"); 
    nb_a := calc.int(nil:void);         # 77 nb_a:int := CALCnil2int(_83:void) 
    ob_a := bat.insert(b,nb_a,81);      # 78 ob_a:void := BKCinsert_bun(b:bat[:int,:int], nb_a:int, _105:int) 
#	io.print("b.insert(1,15);"); 
    pb_a := bat.insert(b,1,15);         # 80 pb_a:void := BKCinsert_bun(b:bat[:int,:int], _108:int, _94:int) 
#	io.print("b.count().print();"); 
    qb_a := aggr.count(b);              # 82 qb_a:int := ALGcount_bat(b:bat[:int,:int]) 
    rb_a := io.print(qb_a);             # 83 rb_a:void := IOprint_val(qb_a:int) 
#	io.print("b.print();"); 
    sb_a := io.print(b);                # 85 sb_a:void := IOprint_val(b:bat[:int,:int]) 
#	io.print("# Lets cut out a few sections\n"); 
    tb_a := algebra.select(b,25,64);    # 87 tb_a:bat[:int,:int] := ALGselect(b:bat[:int,:int], _116:int, _117:int) {G}
    ub_a := io.print(tb_a);             # 88 ub_a:void := IOprint_val(tb_a:bat[:int,:int]) 
#	io.print("b.select(4,15).print();"); 
    vb_a := algebra.select(b,4,15);     # 90 vb_a:bat[:int,:int] := ALGselect(b:bat[:int,:int], _121:int, _94:int) {G}
    wb_a := io.print(vb_a);             # 91 wb_a:void := IOprint_val(vb_a:bat[:int,:int]) 
#	io.print("b.select(4,4).print();"); 
    xb_a := algebra.select(b,4,4);      # 93 xb_a:bat[:int,:int] := ALGselect(b:bat[:int,:int], _121:int, _121:int) {G}
    yb_a := io.print(xb_a);             # 94 yb_a:void := IOprint_val(xb_a:bat[:int,:int]) 
#	io.print("# This should cause an error\n"); 
    ac_a := algebra.select(b,4,3);      # 96 ac_a:bat[:int,:int] := ALGselect(b:bat[:int,:int], _121:int, _128:int) {G}
    bc_a := io.print(ac_a);             # 97 bc_a:void := IOprint_val(ac_a:bat[:int,:int]) 
#	io.print("b.select(81,int(nil)).print();"); 
    cc_a := calc.int(nil:void);         # 99 cc_a:int := CALCnil2int(_132:void) 
    dc_a := algebra.select(b,81,cc_a);  #100 dc_a:bat[:int,:int] := ALGselect(b:bat[:int,:int], _105:int, cc_a:int) {G}
    ec_a := io.print(dc_a);             #101 ec_a:void := IOprint_val(dc_a:bat[:int,:int]) 
#	io.print("b.select(int(nil),int(nil)).print();"); 
    fc_a := calc.int(nil:void);         #103 fc_a:int := CALCnil2int(_132:void) 
    gc_a := calc.int(nil:void);         #104 gc_a:int := CALCnil2int(_132:void) 
    hc_a := algebra.select(b,fc_a,gc_a);#105 hc_a:bat[:int,:int] := ALGselect(b:bat[:int,:int], fc_a:int, gc_a:int) {G}
    ic_a := io.print(hc_a);             #106 ic_a:void := IOprint_val(hc_a:bat[:int,:int]) 
#	io.print("# A 2-dimensional cut\n"); 
    bn := algebra.fragment(b,1,5,4,15); #108 bn:bat[:int,:int] := ALGfragment(b:bat[:int,:int], _142:int, _143:int, _121:int, _144:int) {G}
    jc_a := io.print(bn);               #109 jc_a:void := IOprint_val(bn:bat[:int,:int]) 
#	io.print("b.fragment(1,5,16,int(nil)).print();"); 
    kc_a := calc.int(nil:void);         #111 kc_a:int := CALCnil2int(_132:void) 
    lc_a := algebra.fragment(b,1,5,16,kc_a);#112 lc_a:bat[:int,:int] := ALGfragment(b:bat[:int,:int], _142:int, _143:int, _149:int, kc_a:int) {G}
    mc_a := io.print(lc_a);             #113 mc_a:void := IOprint_val(lc_a:bat[:int,:int]) 
#	io.print("b.fragment(1,int(nil),16,int(nil)).print();"); 
    nc_a := calc.int(nil:void);         #115 nc_a:int := CALCnil2int(_132:void) 
    oc_a := calc.int(nil:void);         #116 oc_a:int := CALCnil2int(_132:void) 
    pc_a := algebra.fragment(b,1,nc_a,16,oc_a);#117 pc_a:bat[:int,:int] := ALGfragment(b:bat[:int,:int], _142:int, nc_a:int, _149:int, oc_a:int) {G}
    qc_a := io.print(pc_a);             #118 qc_a:void := IOprint_val(pc_a:bat[:int,:int]) 
#	io.print("b.fragment(int(nil),int(nil),16,int(nil)).print();"); 
    rc_a := calc.int(nil:void);         #120 rc_a:int := CALCnil2int(_132:void) 
    sc_a := calc.int(nil:void);         #121 sc_a:int := CALCnil2int(_132:void) 
    tc_a := calc.int(nil:void);         #122 tc_a:int := CALCnil2int(_132:void) 
    uc_a := algebra.fragment(b,rc_a,sc_a,16,tc_a);#123 uc_a:bat[:int,:int] := ALGfragment(b:bat[:int,:int], rc_a:int, sc_a:int, _149:int, tc_a:int) {G}
    vc_a := io.print(uc_a);             #124 vc_a:void := IOprint_val(uc_a:bat[:int,:int]) 
#	io.print("bn:= b.join(bn.reverse());"); 
    wc_a := bat.reverse(bn);            #126 wc_a:bat[:int,:int] := BKCreverse(bn:bat[:int,:int]) {G}
    bn := algebra.join(b,wc_a);         #127 bn:bat[:int,:int] := ALGjoin(b:bat[:int,:int], wc_a:bat[:int,:int]) {G}
#	io.print("bn.print();"); 
    xc_a := io.print(bn);               #129 xc_a:void := IOprint_val(bn:bat[:int,:int]) 
#	io.print("bn:= b.semijoin(bn.reverse());"); 
    yc_a := bat.reverse(bn);            #131 yc_a:bat[:int,:int] := BKCreverse(bn:bat[:int,:int]) {G}
    bn := algebra.semijoin(b,yc_a);     #132 bn:bat[:int,:int] := ALGsemijoin(b:bat[:int,:int], yc_a:bat[:int,:int]) {G}
#	io.print("bn.print();"); 
    ad_a := io.print(bn);               #134 ad_a:void := IOprint_val(bn:bat[:int,:int]) 
#	io.print("# band algebra.join experiment\n"); 
    c := algebra.copy(b);               #136 c:bat[:int,:int] := ALGcopy(b:bat[:int,:int]) {G}
#	io.print("bandjoin(b,c,4,4).print();"); 
    bd_a := algebra.bandjoin(b,c,4,4);  #138 bd_a:bat[:int,:int] := ALGbandjoin_default(b:bat[:int,:int], c:bat[:int,:int], _174:int, _174:int) {G}
    cd_a := io.print(bd_a);             #139 cd_a:void := IOprint_val(bd_a:bat[:int,:int]) 
#	io.print("#and theta algebra.joins\?\n"); 
    LT := -1;                           #141 LT:int := _178:int 
    dd_a := calc.lng(nil:void);         #142 dd_a:lng := CALCnil2lng(_180:void) 
    ed_a := algebra.thetajoin(b,c,LT,dd_a);#143 ed_a:bat[:int,:int] := ALGthetajoinEstimate(b:bat[:int,:int], c:bat[:int,:int], LT:int, dd_a:lng) {G}
    fd_a := io.print(ed_a);             #144 fd_a:void := IOprint_val(ed_a:bat[:int,:int]) 
#	io.print("quit();"); 
    gd_a := clients.quit();             #146 gd_a:void 
end main;                               #147  
#~BeginVariableOutput~#
#-----------------------------------------#
# h			t		  # name
# str			str		  # type
#-----------------------------------------#
[ "version",		  "25106"	  ]
[ "batId",		  "tmp_10"	  ]
[ "batCacheid",		  "8"		  ]
[ "hparentid",		  "0"		  ]
[ "tparentid",		  "0"		  ]
[ "batSharecnt",	  "0"		  ]
[ "head",		  "int"		  ]
[ "tail",		  "int"		  ]
[ "batPersistence",	  "transient"	  ]
[ "batRestricted",	  "updatable"	  ]
[ "batRefcnt",		  "1"		  ]
[ "batLRefcnt",		  "1"		  ]
[ "batDirty",		  "dirty"	  ]
[ "batSet",		  "0"		  ]
[ "hsorted",		  "65"		  ]
[ "hident",		  "h"		  ]
[ "hdense",		  "0"		  ]
[ "hseqbase",		  "0@0"		  ]
[ "hkey",		  "0"		  ]
[ "hvarsized",		  "0"		  ]
[ "halign",		  "20000000"	  ]
[ "hnosorted",		  "0"		  ]
[ "hnosorted_rev",	  "0"		  ]
[ "hnodense",		  "0"		  ]
[ "hnokey[0]",		  "0"		  ]
[ "hnokey[1]",		  "0"		  ]
[ "tident",		  "t"		  ]
[ "tdense",		  "0"		  ]
[ "tseqbase",		  "0@0"		  ]
[ "tsorted",		  "65"		  ]
[ "tkey",		  "0"		  ]
[ "tvarsized",		  "0"		  ]
[ "talign",		  "20000001"	  ]
[ "tnosorted",		  "0"		  ]
[ "tnosorted_rev",	  "0"		  ]
[ "tnodense",		  "0"		  ]
[ "tnokey[0]",		  "0"		  ]
[ "tnokey[1]",		  "0"		  ]
[ "batInserted",	  "0"		  ]
[ "batDeleted",		  "0"		  ]
[ "batFirst",		  "0"		  ]
[ "htop",		  "0"		  ]
[ "ttop",		  "0"		  ]
[ "batStamp",		  "8"		  ]
[ "lastUsed",		  "158"		  ]
[ "curStamp",		  "9"		  ]
[ "batCopiedtodisk",	  "0"		  ]
[ "batDirtydesc",	  "dirty"	  ]
[ "H->heap.dirty",	  "clean"	  ]
[ "T->heap.dirty",	  "clean"	  ]
[ "head.free",		  "0"		  ]
[ "head.size",		  "1024"	  ]
[ "head.maxsize",	  "1024"	  ]
[ "head.storage",	  "malloced"	  ]
[ "head.filename",	  "10.head"	  ]
[ "tail.free",		  "0"		  ]
[ "tail.size",		  "1024"	  ]
[ "tail.maxsize",	  "1024"	  ]
[ "tail.storage",	  "malloced"	  ]
[ "tail.filename",	  "10.tail"	  ]
[ "H->vheap->dirty",	  "clean"	  ]
[ "T->vheap->dirty",	  "clean"	  ]
#~EndVariableOutput~#
#-----------------#
# h	t	  # name
# int	int	  # type
#-----------------#
[ 1,	  15	  ]
[ 2,	  4	  ]
[ 3,	  nil	  ]
[ 4,	  16	  ]
[ 5,	  25	  ]
[ 6,	  36	  ]
[ 7,	  49	  ]
[ 8,	  64	  ]
[ 9,	  nil	  ]
[ nil,	  nil	  ]
[ nil,	  81	  ]
[ 15 ]
[ 16 ]
[ 81 ]
#-----------------#
# h	t	  # name
# int	int	  # type
#-----------------#
[ nil,	  nil	  ]
[ 2,	  4	  ]
[ 3,	  nil	  ]
[ 9,	  nil	  ]
[ 5,	  25	  ]
[ 6,	  36	  ]
[ 7,	  49	  ]
[ 8,	  64	  ]
[ 11 ]
#-----------------#
# h	t	  # name
# int	int	  # type
#-----------------#
[ nil,	  nil	  ]
[ 2,	  4	  ]
[ 3,	  nil	  ]
[ 9,	  nil	  ]
[ 5,	  25	  ]
[ 6,	  36	  ]
[ 7,	  49	  ]
[ 8,	  64	  ]
[ 4,	  16	  ]
[ nil,	  81	  ]
[ 1,	  15	  ]
#-----------------#
# h	t	  # name
# int	int	  # type
#-----------------#
[ 5,	  25	  ]
[ 6,	  36	  ]
[ 7,	  49	  ]
[ 8,	  64	  ]
#-----------------#
# h	t	  # name
# int	int	  # type
#-----------------#
[ 2,	  4	  ]
[ 1,	  15	  ]
#-----------------#
# h	t	  # name
# int	int	  # type
#-----------------#
[ 2,	  4	  ]
#-----------------#
# h	t	  # name
# int	int	  # type
#-----------------#
#-----------------#
# h	t	  # name
# int	int	  # type
#-----------------#
[ nil,	  81	  ]
#-----------------#
# h	t	  # name
# int	int	  # type
#-----------------#
[ 2,	  4	  ]
[ 5,	  25	  ]
[ 6,	  36	  ]
[ 7,	  49	  ]
[ 8,	  64	  ]
[ 4,	  16	  ]
[ nil,	  81	  ]
[ 1,	  15	  ]
#-----------------#
# h	t	  # name
# int	int	  # type
#-----------------#
[ 2,	  4	  ]
[ 1,	  15	  ]
#-----------------#
# h	t	  # name
# int	int	  # type
#-----------------#
[ 5,	  25	  ]
[ 4,	  16	  ]
#-----------------#
# h	t	  # name
# int	int	  # type
#-----------------#
[ 5,	  25	  ]
[ 6,	  36	  ]
[ 7,	  49	  ]
[ 8,	  64	  ]
[ 4,	  16	  ]
#-----------------#
# h	t	  # name
# int	int	  # type
#-----------------#
[ 5,	  25	  ]
[ 6,	  36	  ]
[ 7,	  49	  ]
[ 8,	  64	  ]
[ 4,	  16	  ]
[ nil,	  81	  ]
#-----------------#
# h	t	  # name
# int	int	  # type
#-----------------#
[ 2,	  2	  ]
[ 1,	  1	  ]
#-----------------#
# h	t	  # name
# int	int	  # type
#-----------------#
[ 2,	  4	  ]
[ 1,	  15	  ]
#-----------------#
# h	t	  # name
# int	int	  # type
#-----------------#
[ 2,	  4	  ]
[ 2,	  nil	  ]
[ 2,	  25	  ]
[ 2,	  36	  ]
[ 2,	  49	  ]
[ 2,	  64	  ]
[ 2,	  16	  ]
[ 2,	  15	  ]
#-----------------#
# h	t	  # name
# int	int	  # type
#-----------------#
[ 2,	  nil	  ]
[ 2,	  25	  ]
[ 2,	  36	  ]
[ 2,	  49	  ]
[ 2,	  64	  ]

# 11:45:02 >  
# 11:45:02 >  Done.
# 11:45:02 >  

