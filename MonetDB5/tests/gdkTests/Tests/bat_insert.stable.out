stdout of test 'bat_insert` in directory 'tests/gdkTests` itself:


# 20:34:11 >  
# 20:34:11 >  Mtimeout -timeout 60 mserver5 "--config=/ufs/mk/monet5/Linux/etc/MonetDB5.conf" --debug=10 --set "monet_mod_path=/ufs/mk/monet5/Linux/lib/MonetDB5:/ufs/mk/opensource/MonetDB/Linux/lib/MonetDB" --set "gdk_dbfarm=/ufs/mk/monet5/Linux/var/MonetDB5/dbfarm" --set "sql_logdir=/ufs/mk/monet5/Linux/var/MonetDB5/dblogs" --set mapi_port=38345 --set monet_prompt= --trace --dbname=mTests_tests_gdkTests  bat_insert.mal < /dev/null
# 20:34:11 >  

# MonetDB Server v4.99.19
# Copyright (c) 1993-2006 CWI, all rights reserved
# Compiled for x86_64-redhat-linux-gnu/64bit with 64bit OIDs dynamically linked
# config:/ufs/mk/monet5/Linux/etc/MonetDB5.conf
# dbfarm:/ufs/mk/monet5/Linux/var/MonetDB5/dbfarm
# dbname:mTests_tests_gdkTests
# Visit http://monetdb.cwi.nl/ for further information
#function check_cap(b:bat[:any_1,:any_2]) :void;
#	inserted := aggr.count(b);
#	d:= bat.getDelta(b);
#	d1 := aggr.count(d);
#	deleted := calc.lng(d1);
#	cap := bat.getCapacity(b);
#	overflow := inserted + deleted;
#	overflow := overflow - cap;
#barrier errors:= overflow > 0:lng;
#		io.printf("!ERROR: wrote %d BUNs beyond capacity\n",overflow);
#exit errors;
#end check_cap;
function user.check_cap(b:bat[:any_1,:any_2]):void;#  0 check_cap:void := user.check_cap(b:bat[:any_1,:any_2]) {PG}
    inserted := aggr.count(b);          #  1 inserted:int := ALGcount_bat(b:bat[:any_1,:any_2]) {P}
    d := bat.getDelta(b);               #  2 d:bat[:any,:any] := BKCgetDelta(b:bat[:any_1,:any_2]) {PG}
    d1 := aggr.count(d);                #  3 d1:int := ALGcount_bat(d:bat[:any,:any]) 
    deleted := calc.lng(d1);            #  4 deleted:lng := CALCint2lng(d1:int) 
    cap := bat.getCapacity(b);          #  5 cap:lng := BKCgetCapacity(b:bat[:any_1,:any_2]) {P}
    overflow := calc.+(inserted,deleted);#  6 overflow:lng := CALCbinaryADDintlng(inserted:int, deleted:lng) 
    overflow := calc.-(overflow,cap);   #  7 overflow:lng := CALCbinarySUBlnglng(overflow:lng, cap:lng) 
barrier errors := calc.>(overflow,0:lng);#  8 errors:bit := CALCcompGTlnglng(overflow:lng, _9:lng) {J10}
    io.printf("!ERROR: wrote %d BUNs beyond capacity\n",overflow);#  9 _10:void := IOprint_formatted_lng(_11:str, overflow:lng) 
exit errors;                            # 10 errors:bit 
end check_cap;	# 11  
#
#b := bat.new(:oid,:oid);
#bat.setName(b,"b");
#bat.setPersistent(b,true);
#
#cap := bat.getCapacity(b);
#cap := cap/4;
#ci  := calc.int(cap);
#ci := ci+ 1;
#
#i := ci * 3;
#barrier go:= i>0;
#	o:= calc.oid(i);
#	bat.insert(b,o,o);
#	i:= i -1;
#	redo go:= i>0;
#exit go;
#
#transaction.commit();
#
#i := ci * 2;
#barrier go:= i>0;
#	o:= calc.oid(i);
#	bat.delete(b,o);
#	i:= i -1;
#	redo go:= i>0;
#exit go;
#
#c := bat.new(:oid,:oid);
#i := ci * 2;
#barrier go:= i>0;
#	o:= calc.oid(i);
#	bat.insert(c,o,o);
#	i:= i -1;
#	redo go:= i>0;
#exit go;
#
#bat.insert(b,c);
#check_cap(b);
#
#bat.setPersistent(b,false);
#
#transaction.commit();
#
#clients.quit();
#
function user.main():void;              #  0 main:void := user.main() {G}
    o := nil:oid;                       #  1 o:oid := _2:oid 
    b := bat.new(:oid,:oid);            #  2 b:bat[:oid,:oid] := CMDBATnew(_4:oid, _5:oid) {G}
    bat.setName(b,"b");                 #  3 _6:void := BKCsetName(b:bat[:oid,:oid], _7:str) 
    bat.setPersistent(b,true);          #  4 _8:void := BKCpersists(b:bat[:oid,:oid], _9:bit) 
    cap := bat.getCapacity(b);          #  5 cap:lng := BKCgetCapacity(b:bat[:oid,:oid]) 
    cap := calc./(cap,4);               #  6 cap:lng := CALCbinarycheckDIVlngint(cap:lng, _11:int) 
    ci := calc.int(cap);                #  7 ci:int := CALClng2int(cap:lng) 
    ci := calc.+(ci,1);                 #  8 ci:int := CALCbinaryADDintint(ci:int, _13:int) 
    i := calc.*(ci,3);                  #  9 i:int := CALCbinaryMULintint(ci:int, _15:int) 
barrier go := calc.>(i,0);              # 10 go:bit := CALCcompGTintint(i:int, _17:int) {J15}
    o := calc.oid(i);                   # 11 o:oid := CALCint2oid(i:int) 
    bat.insert(b,o,o);                  # 12 _18:void := BKCinsert_bun(b:bat[:oid,:oid], o:oid, o:oid) 
    i := calc.-(i,1);                   # 13 i:int := CALCbinarySUBintint(i:int, _13:int) 
    redo go := calc.>(i,0);             # 14 go:bit := CALCcompGTintint(i:int, _17:int) {J11}
exit go;                                # 15 go:bit 
    transaction.commit();               # 16 _19:bit := TRNglobal_commit() 
    i := calc.*(ci,2);                  # 17 i:int := CALCbinaryMULintint(ci:int, _20:int) 
barrier go := calc.>(i,0);              # 18 go:bit := CALCcompGTintint(i:int, _17:int) {J23}
    o := calc.oid(i);                   # 19 o:oid := CALCint2oid(i:int) 
    bat.delete(b,o);                    # 20 _21:void := BKCdelete(b:bat[:oid,:oid], o:oid) 
    i := calc.-(i,1);                   # 21 i:int := CALCbinarySUBintint(i:int, _13:int) 
    redo go := calc.>(i,0);             # 22 go:bit := CALCcompGTintint(i:int, _17:int) {J19}
exit go;                                # 23 go:bit 
    c := bat.new(:oid,:oid);            # 24 c:bat[:oid,:oid] := CMDBATnew(_23:oid, _24:oid) {G}
    i := calc.*(ci,2);                  # 25 i:int := CALCbinaryMULintint(ci:int, _20:int) 
barrier go := calc.>(i,0);              # 26 go:bit := CALCcompGTintint(i:int, _17:int) {J31}
    o := calc.oid(i);                   # 27 o:oid := CALCint2oid(i:int) 
    bat.insert(c,o,o);                  # 28 _25:void := BKCinsert_bun(c:bat[:oid,:oid], o:oid, o:oid) 
    i := calc.-(i,1);                   # 29 i:int := CALCbinarySUBintint(i:int, _13:int) 
    redo go := calc.>(i,0);             # 30 go:bit := CALCcompGTintint(i:int, _17:int) {J27}
exit go;                                # 31 go:bit 
    bat.insert(b,c);                    # 32 _26:void := BKCinsert_bat(b:bat[:oid,:oid], c:bat[:oid,:oid]) 
    user.check_cap(b);                  # 33 _27:void := user.check_cap(b:bat[:oid,:oid]) 
    bat.setPersistent(b,false);         # 34 _28:void := BKCpersists(b:bat[:oid,:oid], _29:bit) 
    transaction.commit();               # 35 _30:bit := TRNglobal_commit() 
    clients.quit();                     # 36 _31:void := CLTquit() 
end main;	# 37  

# 20:34:11 >  
# 20:34:11 >  Done.
# 20:34:11 >  

