# The test triggers the binsearch implementation of BATmultijoin,
# which is chosen in two situations:
#   1. smallest bat is not sorted, but the larger is, and the count of the 
#      larger is not "too" small.
#   2. all bats are sorted on head, but the larger is *much* larger.

function Nseq(N:int):bat[:oid,:int];
	seq:= bat.new(:oid,:int);
	i:= 0;
barrier go:= true;
	bat.append(seq,i);
	i:= i+1;
	redo go:= i<N;
exit go;
	return seq;
end Nseq;

# first create example with l.count() < 4*r.count()
# r should not be sorted, or a different impl will be chosen.
a:= user.Nseq(3);
ar:= bat.reverse(a);
ap:= algebra.project(ar,0:oid);
ao:= algebra.project(ar,1:oid);
u := algebra.union(ap,ao);
l := bat.reverse(u);
io.print(l);

b:= user.Nseq(3);
br:= bat.reverse(b);
bp:= algebra.project(br,2:oid);
bpr:= bat.reverse(bp);
l2:= algebra.union(l,bpr);
io.print(l2);

r:= bat.new(:oid,:int);
bat.append(r, 1);
bat.append(r, 2);
bat.append(r, 3);

z:bat[:oid,:int]:= mal.multiplex("calc","+",l2,r);
c:= aggr.count(z);
io.print(c);

# the other case when binsearch is chosen, is if r is sorted,
# but l.count() > 40*r.count():
n81 := user.Nseq(81);
n81r:= bat.reverse(n81);
n81p:= algebra.project(n81r,0:oid);
nr:= bat.reverse(n81p);
rs:= algebra.sort(r);
z:bat[:oid,:int]:= mal.multiplex("calc","+",nr,rs);
c:= aggr.count(z);
io.print(c);

#[+](Nseq(81).reverse().project(oid(0)).reverse(),r.sort()).count().print();

clients.quit();
