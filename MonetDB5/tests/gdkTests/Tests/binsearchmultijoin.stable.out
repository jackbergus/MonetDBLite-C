stdout of test 'binsearchmultijoin` in directory 'tests/gdkTests` itself:


# 21:39:53 >  
# 21:39:53 >  Mtimeout -timeout 60 mserver5 "--config=/ufs/mk/monet5/Linux/etc/MonetDB5.conf" --debug=10 --set "monet_mod_path=/ufs/mk/monet5/Linux/lib/MonetDB5:/ufs/mk/opensource/MonetDB/Linux/lib/MonetDB" --set "gdk_dbfarm=/ufs/mk/monet5/Linux/var/MonetDB5/dbfarm" --set "sql_logdir=/ufs/mk/monet5/Linux/var/MonetDB5/dblogs" --set mapi_port=34446 --set monet_prompt= --trace --dbname=mTests_tests_gdkTests  binsearchmultijoin.mal < /dev/null
# 21:39:53 >  

# MonetDB Server v4.99.19
# Copyright (c) 1993-2006 CWI, all rights reserved
# Compiled for x86_64-redhat-linux-gnu/64bit with 64bit OIDs dynamically linked
# config:/ufs/mk/monet5/Linux/etc/MonetDB5.conf
# dbfarm:/ufs/mk/monet5/Linux/var/MonetDB5/dbfarm
# dbname:mTests_tests_gdkTests
# Visit http://monetdb.cwi.nl/ for further information
# Listening for connection requests on mapi:monetdb://eir.ins.cwi.nl:30579/
function user.Nseq(N:int):bat[:oid,:int];
    seq := bat.new(:oid,:int);
    i := 0;
barrier go := true;
    bat.append(seq,i);
    i := calc.+(i,1);
    redo go := calc.<(i,N);
exit go;
    return Nseq := seq;
end Nseq;
function user.main():void;
# The test triggers the binsearch implementation of BATmultijoin, 
# which is chosen in two situations: 
#   1. smallest bat is not sorted, but the larger is, and the count of the  
#      larger is not "too" small. 
#   2. all bats are sorted on head, but the larger is *much* larger. 
# first create example with l.count() < 4*r.count() 
# r should not be sorted, or a different impl will be chosen. 
    a := user.Nseq(3);
    ar := bat.reverse(a);
    ap := algebra.project(ar,0@0:oid);
    ao := algebra.project(ar,1@0:oid);
    u := algebra.union(ap,ao);
    l := bat.reverse(u);
    io.print(l);
    b := user.Nseq(3);
    br := bat.reverse(b);
    bp := algebra.project(br,2@0:oid);
    bpr := bat.reverse(bp);
    l2 := algebra.union(l,bpr);
    r := bat.new(:oid,:int);
    bat.insert(r,1@0:oid,1);
    bat.insert(r,0@0:oid,2);
    bat.insert(r,2@0:oid,3);
    X_48 := bat.new(nil:oid,nil:int);
barrier (X_52,X_53,X_54) := bat.newIterator(l2);
    X_56 := algebra.find(r,X_53);
    X_58 := calc.+(X_54,X_56);
    bat.insert(X_48,X_53,X_58);
    redo (X_52,X_53,X_54) := bat.hasMoreElements(l2);
exit (X_52,X_53,X_54);
    z:bat[:oid,:int]  := X_48;
    c := aggr.count(z);
    io.print(c);
# the other case when binsearch is chosen, is if r is sorted, 
# but l.count() > 40*r.count(): 
    n81 := user.Nseq(81);
    n81r := bat.reverse(n81);
    n81p := algebra.project(n81r,0@0:oid);
    nr := bat.reverse(n81p);
    rs := algebra.sort(r);
    X_63 := bat.new(nil:oid,nil:int);
barrier (X_65,X_66,X_67) := bat.newIterator(nr);
    X_69 := algebra.find(rs,X_66);
    X_71 := calc.+(X_67,X_69);
    bat.insert(X_63,X_66,X_71);
    redo (X_65,X_66,X_67) := bat.hasMoreElements(nr);
exit (X_65,X_66,X_67);
    z:bat[:oid,:int]  := X_63;
    c := aggr.count(z);
    io.print(c);
#[+](Nseq(81).reverse().project(oid(0)).reverse(),r.sort()).count().print(); 
    clients.quit();
end main;
#-----------------#
# t	h	  # name
# oid	int	  # type
#-----------------#
[ 0@0,	  0	  ]
[ 0@0,	  1	  ]
[ 0@0,	  2	  ]
[ 1@0,	  0	  ]
[ 1@0,	  1	  ]
[ 1@0,	  2	  ]
[ 9 ]
[ 81 ]

# 21:39:53 >  
# 21:39:53 >  Done.
# 21:39:53 >  

