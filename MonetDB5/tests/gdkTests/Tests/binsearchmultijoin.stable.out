stdout of test 'binsearchmultijoin` in directory 'tests/gdkTests` itself:


# 21:39:53 >  
# 21:39:53 >  Mtimeout -timeout 60 mserver5 "--config=/ufs/mk/monet5/Linux/etc/MonetDB5.conf" --debug=10 --set "monet_mod_path=/ufs/mk/monet5/Linux/lib/MonetDB5:/ufs/mk/opensource/MonetDB/Linux/lib/MonetDB" --set "gdk_dbfarm=/ufs/mk/monet5/Linux/var/MonetDB5/dbfarm" --set "sql_logdir=/ufs/mk/monet5/Linux/var/MonetDB5/dblogs" --set mapi_port=34446 --set monet_prompt= --trace --dbname=mTests_tests_gdkTests  binsearchmultijoin.mal < /dev/null
# 21:39:53 >  

# MonetDB Server v4.99.19
# Copyright (c) 1993-2006 CWI, all rights reserved
# Compiled for x86_64-redhat-linux-gnu/64bit with 64bit OIDs dynamically linked
# config:/ufs/mk/monet5/Linux/etc/MonetDB5.conf
# dbfarm:/ufs/mk/monet5/Linux/var/MonetDB5/dbfarm
# dbname:mTests_tests_gdkTests
# Visit http://monetdb.cwi.nl/ for further information
## The test triggers the binsearch implementation of BATmultijoin,
## which is chosen in two situations:
##   1. smallest bat is not sorted, but the larger is, and the count of the 
##      larger is not "too" small.
##   2. all bats are sorted on head, but the larger is *much* larger.
#
#function Nseq(N:int):bat[:void,:int];
#	seq:= bat.new(:void,:int);
#	bat.setSequenceBase(seq,0@0);
#	i:= 0;
#barrier go:= true;
#	bat.append(seq,i);
#	i:= i+1;
#	redo go:= i<N;
#exit go;
#	return seq;
#end Nseq;
function user.Nseq(N:int):bat[:oid,:int];#  0 Nseq:bat[:oid,:int] := user.Nseq(N:int) {G}
    seq := bat.new(:oid,:int);          #  1 seq:bat[:oid,:int] := CMDBATnew(_3:oid, _4:int) {G}
    i := 0;                             #  2 i:int := _6:int 
barrier go := true;                     #  3 go:bit := _8:bit {J7}
    bat.append(seq,i);                  #  4 _9:bat[:int,:any] := BKCappend_val_wrap(seq:bat[:oid,:int], i:int) {G}
    i := calc.+(i,1);                   #  5 i:int := CALCbinaryADDintint(i:int, _10:int) 
    redo go := calc.<(i,N);             #  6 go:bit := CALCcompLTintint(i:int, N:int) {J4}
exit go;                                #  7 go:bit 
    return Nseq := seq;                 #  8 Nseq:bat[:oid,:int] := seq:bat[:oid,:int] {G}
end Nseq;	# 9  
#
## first create example with l.count() < 4*r.count()
## r should not be sorted, or a different impl will be chosen.
#a:= user.Nseq(3);
#ar:= bat.reverse(a);
#ap:= algebra.project(ar,0:oid);
#ao:= algebra.project(ar,1:oid);
#u := algebra.union(ap,ao);
#l := bat.reverse(u);
#io.print(l);
#
#b:= user.Nseq(3);
#br:= bat.reverse(b);
#bp:= algebra.project(br,2:oid);
#bpr:= bat.reverse(bp);
#l2:= algebra.union(l,bpr);
#
#r:= bat.new(:oid,:int);
#bat.insert(r, 1:oid,1);
#bat.insert(r, 0:oid,2);
#
#z:bat[:oid,:int]:= optimizer.multiplex("calc.+",l2,r);
#c:= aggr.count(z);
#io.print(c);
#
## the other case when binsearch is chosen, is if r is sorted,
## but l.count() > 40*r.count():
#n81 := user.Nseq(81);
#n81r:= bat.reverse(n81);
#n81p:= algebra.project(n81r,0:oid);
#nr:= bat.reverse(n81p);
#rs:= algebra.sort(r);
#z:bat[:oid,:int]:= optimizer.multiplex("calc.+",nr,rs);
#c:= aggr.count(z);
#io.print(c);
#
##[+](Nseq(81).reverse().project(oid(0)).reverse(),r.sort()).count().print();
#
#clients.quit();
#
function user.main():void;              #  0 main:void := user.main() {G}
# The test triggers the binsearch implementation of BATmultijoin, 
# which is chosen in two situations: 
#   1. smallest bat is not sorted, but the larger is, and the count of the  
#      larger is not "too" small. 
#   2. all bats are sorted on head, but the larger is *much* larger. 
# first create example with l.count() < 4*r.count() 
# r should not be sorted, or a different impl will be chosen. 
    a := user.Nseq(3);                  #  8 a:bat[:oid,:int] := user.Nseq(_9:int) {G}
    ar := bat.reverse(a);               #  9 ar:bat[:int,:oid] := BKCreverse(a:bat[:oid,:int]) {G}
    ap := algebra.project(ar,0@0:oid);  # 10 ap:bat[:int,:oid] := ALGprojectCst(ar:bat[:int,:oid], _12:oid) {G}
    ao := algebra.project(ar,1@0:oid);  # 11 ao:bat[:int,:oid] := ALGprojectCst(ar:bat[:int,:oid], _14:oid) {G}
    u := algebra.union(ap,ao);          # 12 u:bat[:int,:oid] := ALGsunion(ap:bat[:int,:oid], ao:bat[:int,:oid]) {G}
    l := bat.reverse(u);                # 13 l:bat[:oid,:int] := BKCreverse(u:bat[:int,:oid]) {G}
    io.print(l);                        # 14 _17:void := IOprint_val(l:bat[:oid,:int]) 
    b := user.Nseq(3);                  # 15 b:bat[:oid,:int] := user.Nseq(_9:int) {G}
    br := bat.reverse(b);               # 16 br:bat[:int,:oid] := BKCreverse(b:bat[:oid,:int]) {G}
    bp := algebra.project(br,2@0:oid);  # 17 bp:bat[:int,:oid] := ALGprojectCst(br:bat[:int,:oid], _21:oid) {G}
    bpr := bat.reverse(bp);             # 18 bpr:bat[:oid,:int] := BKCreverse(bp:bat[:int,:oid]) {G}
    l2 := algebra.union(l,bpr);         # 19 l2:bat[:oid,:int] := ALGsunion(l:bat[:oid,:int], bpr:bat[:oid,:int]) {G}
    r := bat.new(:oid,:int);            # 20 r:bat[:oid,:int] := CMDBATnew(_25:oid, _26:int) {G}
    bat.insert(r,1@0:oid,1);            # 21 _27:bat[:oid,:int] := BKCinsert_bun(r:bat[:oid,:int], _14:oid, _28:int) {G}
    bat.insert(r,0@0:oid,2);            # 22 _29:bat[:oid,:int] := BKCinsert_bun(r:bat[:oid,:int], _12:oid, _30:int) {G}
    bat.insert(r,2@0:oid,3);            # 23 _31:bat[:oid,:int] := BKCinsert_bun(r:bat[:oid,:int], _21:oid, _9:int) {G}
    _48 := bat.new(nil:oid,nil:int);    # 24 _48:bat[:oid,:int] := CMDBATnew(_49:oid, _50:int) {G}
barrier (_52,_53,_54) := bat.newIterator(l2);# 25 (_52:lng, _53:oid, _54:int) := CHPbunIterator(l2:bat[:oid,:int]) {J30}
    _56 := algebra.find(r,_53);         # 26 _56:int := ALGfind(r:bat[:oid,:int], _53:oid) 
    _58 := calc.+(_54,_56);             # 27 _58:int := CALCbinaryADDintint(_54:int, _56:int) 
    bat.insert(_48,_53,_58);            # 28 _59:bat[:oid,:int] := BKCinsert_bun(_48:bat[:oid,:int], _53:oid, _58:int) {G}
    redo (_52,_53,_54) := bat.hasMoreElements(l2);# 29 (_52:lng, _53:oid, _54:int) := CHPbunHasMoreElements(l2:bat[:oid,:int]) {J26}
exit (_52,_53,_54);                     # 30 (_52:lng, _53:oid, _54:int) 
    z:bat[:oid,:int]  := _48;           # 31 z:bat[:oid,:int] := _48:bat[:oid,:int] {G}
    c := aggr.count(z);                 # 32 c:int := ALGcount_bat(z:bat[:oid,:int]) 
    io.print(c);                        # 33 _36:void := IOprint_val(c:int) 
# the other case when binsearch is chosen, is if r is sorted, 
# but l.count() > 40*r.count(): 
    n81 := user.Nseq(81);               # 36 n81:bat[:oid,:int] := user.Nseq(_40:int) {G}
    n81r := bat.reverse(n81);           # 37 n81r:bat[:int,:oid] := BKCreverse(n81:bat[:oid,:int]) {G}
    n81p := algebra.project(n81r,0@0:oid);# 38 n81p:bat[:int,:oid] := ALGprojectCst(n81r:bat[:int,:oid], _12:oid) {G}
    nr := bat.reverse(n81p);            # 39 nr:bat[:oid,:int] := BKCreverse(n81p:bat[:int,:oid]) {G}
    rs := algebra.sort(r);              # 40 rs:bat[:oid,:int] := ALGhsort(r:bat[:oid,:int]) {G}
    _63 := bat.new(nil:oid,nil:int);    # 41 _63:bat[:oid,:int] := CMDBATnew(_49:oid, _50:int) {G}
barrier (_65,_66,_67) := bat.newIterator(nr);# 42 (_65:lng, _66:oid, _67:int) := CHPbunIterator(nr:bat[:oid,:int]) {J47}
    _69 := algebra.find(rs,_66);        # 43 _69:int := ALGfind(rs:bat[:oid,:int], _66:oid) 
    _71 := calc.+(_67,_69);             # 44 _71:int := CALCbinaryADDintint(_67:int, _69:int) 
    bat.insert(_63,_66,_71);            # 45 _72:bat[:oid,:int] := BKCinsert_bun(_63:bat[:oid,:int], _66:oid, _71:int) {G}
    redo (_65,_66,_67) := bat.hasMoreElements(nr);# 46 (_65:lng, _66:oid, _67:int) := CHPbunHasMoreElements(nr:bat[:oid,:int]) {J43}
exit (_65,_66,_67);                     # 47 (_65:lng, _66:oid, _67:int) 
    z:bat[:oid,:int]  := _63;           # 48 z:bat[:oid,:int] := _63:bat[:oid,:int] {G}
    c := aggr.count(z);                 # 49 c:int := ALGcount_bat(z:bat[:oid,:int]) 
    io.print(c);                        # 50 _45:void := IOprint_val(c:int) 
#[+](Nseq(81).reverse().project(oid(0)).reverse(),r.sort()).count().print(); 
    clients.quit();                     # 52 _47:void := CLTquit() 
end main;                               # 53  
#-----------------#
# t	h	  # name
# oid	int	  # type
#-----------------#
[ 0@0,	  0	  ]
[ 0@0,	  1	  ]
[ 0@0,	  2	  ]
[ 1@0,	  0	  ]
[ 1@0,	  1	  ]
[ 1@0,	  2	  ]
[ 9 ]
[ 81 ]

# 21:39:53 >  
# 21:39:53 >  Done.
# 21:39:53 >  

