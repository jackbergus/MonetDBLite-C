stdout of test 'binsearchmultijoin` in directory 'tests/gdkTests` itself:


# 21:39:53 >  
# 21:39:53 >  Mtimeout -timeout 60 mserver5 "--config=/ufs/mk/monet5/Linux/etc/MonetDB5.conf" --debug=10 --set "monet_mod_path=/ufs/mk/monet5/Linux/lib/MonetDB5:/ufs/mk/opensource/MonetDB/Linux/lib/MonetDB" --set "gdk_dbfarm=/ufs/mk/monet5/Linux/var/MonetDB5/dbfarm" --set "sql_logdir=/ufs/mk/monet5/Linux/var/MonetDB5/dblogs" --set mapi_port=34446 --set monet_prompt= --trace --dbname=mTests_tests_gdkTests  binsearchmultijoin.mal < /dev/null
# 21:39:53 >  

# MonetDB Server v4.99.19
# Copyright (c) 1993-2006 CWI, all rights reserved
# Compiled for x86_64-redhat-linux-gnu/64bit with 64bit OIDs dynamically linked
# config:/ufs/mk/monet5/Linux/etc/MonetDB5.conf
# dbfarm:/ufs/mk/monet5/Linux/var/MonetDB5/dbfarm
# dbname:mTests_tests_gdkTests
# Visit http://monetdb.cwi.nl/ for further information
## The test triggers the binsearch implementation of BATmultijoin,
## which is chosen in two situations:
##   1. smallest bat is not sorted, but the larger is, and the count of the 
##      larger is not "too" small.
##   2. all bats are sorted on head, but the larger is *much* larger.
#
#function Nseq(N:int):bat[:void,:int];
#	seq:= bat.new(:void,:int);
#	bat.setSequenceBase(seq,0@0);
#	i:= 0;
#barrier go:= true;
#	bat.append(seq,i);
#	i:= i+1;
#	redo go:= i<N;
#exit go;
#	return seq;
#end Nseq;
function user.Nseq(N:int):bat[:void,:int];	# 0  (Nseq:bat[:void,:int])<-(N:int)
    seq := bat.new(:void,:int);	# 1 CMDBATnew (seq:bat[:void,:int])<-(_3:void)(_4:int)
    bat.setSequenceBase(seq,0@0);	# 2 BKCsetSequenceBase (_5:bat[:void,:int])<-(seq:bat[:void,:int])(_6:oid)
    i := 0;	# 3  (i:int)<-(_8:int)
barrier go := true;	# 4  (go:bit)<-(_10:bit) jump 8
    bat.append(seq,i);	# 5 BKCappend_val_wrap (_11:void)<-(seq:bat[:void,:int])(i:int)
    i := calc.+(i,1);	# 6 CALCbinaryADDintint (i:int)<-(i:int)(_12:int)
    redo go := calc.<(i,N);	# 7 CALCcompLTintint (go:bit)<-(i:int)(N:int) jump 5
exit go;	# 8  (go:bit)
    return seq;	# 9  (seq:bat[:void,:int])
end Nseq;	# 10  
#
## first create example with l.count() < 4*r.count()
## r should not be sorted, or a different impl will be chosen.
#a:= user.Nseq(3);
#ar:= bat.reverse(a);
#ap:= algebra.project(ar,0:oid);
#ao:= algebra.project(ar,1:oid);
#u := algebra.union(ap,ao);
#l := bat.reverse(u);
#io.print(l);
#
#b:= user.Nseq(3);
#br:= bat.reverse(b);
#bp:= algebra.project(br,2:oid);
#bpr:= bat.reverse(bp);
#l2:= algebra.union(l,bpr);
#
#r:= bat.new(:oid,:int);
#bat.insert(r, 1:oid,1);
#bat.insert(r, 0:oid,2);
#
#z:bat[:oid,:int]:= optimizer.multiplex("calc.+",l2,r);
#c:= aggr.count(z);
#io.print(c);
#
## the other case when binsearch is chosen, is if r is sorted,
## but l.count() > 40*r.count():
#n81 := user.Nseq(81);
#n81r:= bat.reverse(n81);
#n81p:= algebra.project(n81r,0:oid);
#nr:= bat.reverse(n81p);
#rs:= algebra.sort(r);
#z:bat[:oid,:int]:= optimizer.multiplex("calc.+",nr,rs);
#c:= aggr.count(z);
#io.print(c);
#
##[+](Nseq(81).reverse().project(oid(0)).reverse(),r.sort()).count().print();
#
#clients.quit();
#
function user.main():void;	# 0  (main:void)
# The test triggers the binsearch implementation of BATmultijoin, 	# 1  (_1:str)
# which is chosen in two situations: 	# 2  (_2:str)
#   1. smallest bat is not sorted, but the larger is, and the count of the  	# 3  (_3:str)
#      larger is not "too" small. 	# 4  (_4:str)
#   2. all bats are sorted on head, but the larger is *much* larger. 	# 5  (_5:str)
# first create example with l.count() < 4*r.count() 	# 6  (_6:str)
# r should not be sorted, or a different impl will be chosen. 	# 7  (_7:str)
    a := user.Nseq(3);	# 8  (a:bat[:void,:int])<-(_9:int)
    ar := bat.reverse(a);	# 9 BKCreverse (ar:bat[:int,:void])<-(a:bat[:void,:int])
    ap := algebra.project(ar,0@0:oid);	# 10 CMDBBPproject (ap:bat[:int,:oid])<-(ar:bat[:int,:void])(_12:oid)
    ao := algebra.project(ar,1@0:oid);	# 11 CMDBBPproject (ao:bat[:int,:oid])<-(ar:bat[:int,:void])(_14:oid)
    u := algebra.union(ap,ao);	# 12 ALGsunion (u:bat[:int,:oid])<-(ap:bat[:int,:oid])(ao:bat[:int,:oid])
    l := bat.reverse(u);	# 13 BKCreverse (l:bat[:oid,:int])<-(u:bat[:int,:oid])
    io.print(l);	# 14 IOprint_val (_17:int)<-(l:bat[:oid,:int])
    b := user.Nseq(3);	# 15  (b:bat[:void,:int])<-(_9:int)
    br := bat.reverse(b);	# 16 BKCreverse (br:bat[:int,:void])<-(b:bat[:void,:int])
    bp := algebra.project(br,2@0:oid);	# 17 CMDBBPproject (bp:bat[:int,:oid])<-(br:bat[:int,:void])(_21:oid)
    bpr := bat.reverse(bp);	# 18 BKCreverse (bpr:bat[:oid,:int])<-(bp:bat[:int,:oid])
    l2 := algebra.union(l,bpr);	# 19 ALGsunion (l2:bat[:oid,:int])<-(l:bat[:oid,:int])(bpr:bat[:oid,:int])
    r := bat.new(:oid,:int);	# 20 CMDBATnew (r:bat[:oid,:int])<-(_25:oid)(_26:int)
    bat.insert(r,1@0:oid,1);	# 21 BKCinsert_bun (_27:void)<-(r:bat[:oid,:int])(_14:oid)(_28:int)
    bat.insert(r,0@0:oid,2);	# 22 BKCinsert_bun (_29:void)<-(r:bat[:oid,:int])(_12:oid)(_30:int)
    _46 := bat.new(nil:oid,nil:int);	# 23 CMDBATnew (_46:bat[:oid,:int])<-(_47:oid)(_48:int)
barrier (_50,_51,_52):= bat.newIterator(l2);	# 24 CHPbunIterator (_50:lng)(_51:oid)(_52:int)<-(l2:bat[:oid,:int]) jump 32
    _54 := algebra.find(r,_51);	# 25 ALGfind (_54:int)<-(r:bat[:oid,:int])(_51:oid)
    _56 := calc.+(_52,_54);	# 26 CALCbinaryADDintint (_56:int)<-(_52:int)(_54:int)
    bat.insert(_46,_51,_56);	# 27 BKCinsert_bun (_57:void)<-(_46:bat[:oid,:int])(_51:oid)(_56:int)
    redo (_50,_51,_52):= bat.hasMoreElements(l2);	# 28 CHPbunHasMoreElements (_50:lng)(_51:oid)(_52:int)<-(l2:bat[:oid,:int]) jump 25
catch MALexception:str ;	# 29  (MALexception:str) jump 31
    redo (_50,_51,_52):= bat.hasMoreElements(l2);	# 30 CHPbunHasMoreElements (_50:lng)(_51:oid)(_52:int)<-(l2:bat[:oid,:int]) jump 25
exit MALexception:str ;	# 31  (MALexception:str)
exit (_50,_51,_52);	# 32  (_50:lng)(_51:oid)(_52:int)
    z:bat[:oid,:int]  := _46;	# 33  (z:bat[:oid,:int])<-(_46:bat[:oid,:int])
    c := aggr.count(z);	# 34 ALGcount_bat (c:int)<-(z:bat[:oid,:int])
    io.print(c);	# 35 IOprint_val (_34:int)<-(c:int)
# the other case when binsearch is chosen, is if r is sorted, 	# 36  (_35:str)
# but l.count() > 40*r.count(): 	# 37  (_36:str)
    n81 := user.Nseq(81);	# 38  (n81:bat[:void,:int])<-(_38:int)
    n81r := bat.reverse(n81);	# 39 BKCreverse (n81r:bat[:int,:void])<-(n81:bat[:void,:int])
    n81p := algebra.project(n81r,0@0:oid);	# 40 CMDBBPproject (n81p:bat[:int,:oid])<-(n81r:bat[:int,:void])(_12:oid)
    nr := bat.reverse(n81p);	# 41 BKCreverse (nr:bat[:oid,:int])<-(n81p:bat[:int,:oid])
    rs := algebra.sort(r);	# 42 ALGhsort (rs:bat[:oid,:int])<-(r:bat[:oid,:int])
    _63 := bat.new(nil:oid,nil:int);	# 43 CMDBATnew (_63:bat[:oid,:int])<-(_47:oid)(_48:int)
barrier (_65,_66,_67):= bat.newIterator(nr);	# 44 CHPbunIterator (_65:lng)(_66:oid)(_67:int)<-(nr:bat[:oid,:int]) jump 52
    _69 := algebra.find(rs,_66);	# 45 ALGfind (_69:int)<-(rs:bat[:oid,:int])(_66:oid)
    _71 := calc.+(_67,_69);	# 46 CALCbinaryADDintint (_71:int)<-(_67:int)(_69:int)
    bat.insert(_63,_66,_71);	# 47 BKCinsert_bun (_72:void)<-(_63:bat[:oid,:int])(_66:oid)(_71:int)
    redo (_65,_66,_67):= bat.hasMoreElements(nr);	# 48 CHPbunHasMoreElements (_65:lng)(_66:oid)(_67:int)<-(nr:bat[:oid,:int]) jump 45
catch MALexception:str ;	# 49  (MALexception:str) jump 51
    redo (_65,_66,_67):= bat.hasMoreElements(nr);	# 50 CHPbunHasMoreElements (_65:lng)(_66:oid)(_67:int)<-(nr:bat[:oid,:int]) jump 45
exit MALexception:str ;	# 51  (MALexception:str)
exit (_65,_66,_67);	# 52  (_65:lng)(_66:oid)(_67:int)
    z:bat[:oid,:int]  := _63;	# 53  (z:bat[:oid,:int])<-(_63:bat[:oid,:int])
    c := aggr.count(z);	# 54 ALGcount_bat (c:int)<-(z:bat[:oid,:int])
    io.print(c);	# 55 IOprint_val (_43:int)<-(c:int)
#[+](Nseq(81).reverse().project(oid(0)).reverse(),r.sort()).count().print(); 	# 56  (_44:str)
    clients.quit();	# 57 CLTquitDefault (_45:void)
end main;	# 58  
#-----------------#
# t	h	  # name
# oid	int	  # type
#-----------------#
[ 0@0,	  0	  ]
[ 0@0,	  1	  ]
[ 0@0,	  2	  ]
[ 1@0,	  0	  ]
[ 1@0,	  1	  ]
[ 1@0,	  2	  ]
[ 6 ]
[ 81 ]

# 21:39:53 >  
# 21:39:53 >  Done.
# 21:39:53 >  

