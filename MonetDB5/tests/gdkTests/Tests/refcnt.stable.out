stdout of test 'refcnt` in directory 'tests/gdkTests` itself:


# 20:39:36 >  
# 20:39:36 >  Mtimeout -timeout 60 mserver5 "--config=/ufs/mk/monet5/Linux/etc/MonetDB5.conf" --debug=10 --set "monet_mod_path=/ufs/mk/monet5/Linux/lib/MonetDB5:/ufs/mk/opensource/MonetDB/Linux/lib/MonetDB" --set "gdk_dbfarm=/ufs/mk/monet5/Linux/var/MonetDB5/dbfarm" --set "sql_logdir=/ufs/mk/monet5/Linux/var/MonetDB5/dblogs" --set mapi_port=36290 --set monet_prompt= --trace --dbname=mTests_tests_gdkTests  refcnt.mal < /dev/null
# 20:39:36 >  

# MonetDB Server v4.99.19
# Copyright (c) 1993-2006 CWI, all rights reserved
# Compiled for x86_64-redhat-linux-gnu/64bit with 64bit OIDs dynamically linked
# config:/ufs/mk/monet5/Linux/etc/MonetDB5.conf
# dbfarm:/ufs/mk/monet5/Linux/var/MonetDB5/dbfarm
# dbname:mTests_tests_gdkTests
# Visit http://monetdb.cwi.nl/ for further information
#function tmp():void;
#	d:= bbp.getRefCount();
#	dl:=bbp.getLRefCount();
#	dn:= bbp.getNames();
#	io.print(dn,d,dl);
#end tmp;
function user.tmp():void;	# 0  (tmp:void)
    d := bbp.getRefCount();	# 1 CMDbbpRefCount (d:bat[:int,:int])
    dl := bbp.getLRefCount();	# 2 CMDbbpLRefCount (dl:bat[:int,:int])
    dn := bbp.getNames();	# 3 CMDbbpNames (dn:bat[:int,:str])
#io.print(dn,d,dl); 	# 4  (_4:str)
end tmp;	# 5  
#
##NOTE: the reference counter of bat(name) is during insertion
##      into bat(b) correctly increased
##PROC addBAT(bat b,str name) : void {
##	VAR add := new(int,int);
##	add.rename(name);
##	b.insert(name,add);
##}
#function addBAT(b:bat[:str,:bat],name:str):void;
#	add:= bat.new(:int,:int);
#	bat.setName(add,name);
#	i:= calc.bat(add);
#	bat.insert(b,name,i);
#end addBAT;
function user.addBAT(b:bat[:str,:BAT],name:str):void;	# 0  (addBAT:void)<-(b:bat[:str,:BAT])(name:str)
    add := bat.new(:int,:int);	# 1 CMDBATnew (add:bat[:int,:int])<-(_4:int)(_4:int)
    bat.setName(add,name);	# 2 BKCsetName (_5:void)<-(add:bat[:int,:int])(name:str)
    bat.insert(b,name,add);	# 3 BKCinsert_bun (_6:void)<-(b:bat[:str,:BAT])(name:str)(add:bat[:int,:int])
end addBAT;	# 4  
##
###BUG: bat(name) will not be deleted in the garbage collection
###     because the delete doesn't decrease the reference counter
##PROC delBAT(bat b,str name) : void {
##	b.delete(name);
##}
#function delBAT(b:bat[:any_1,:any_2],name:str):void;
#	bat.delete(b,name);
#end delBAT;
function user.delBAT(b:bat[:any_1,:any_2],name:str):void;	# 0  (delBAT:void)<-(b:bat[:any_1,:any_2])(name:str)
    bat.delete(b,name);	# 1 BKCdelete (_3:void)<-(b:bat[:any_1,:any_2])(name:str)
end delBAT;	# 2  
##
##PROC createBAT(str name) : bat[int,int] {
##	VAR res := new(int,int);
##	res.rename(name);
##	RETURN res;
##}
##NOTE we can not return  (yet) a (:bat,:bat[:int,:int])
##into a multiplex. This means that the BATs created
## are immediately garbage collected when leaving the
##function. A hack would be to provide explicit incref/decref
#function createBAT(name:str):bat;
#	res:= bat.new(:int,:int);
#	bat.setName(res,name);	
#	i:= calc.bat(res);
#	return i;
#end createBAT;
function user.createBAT(name:str):BAT;	# 0  (createBAT:BAT)<-(name:str)
    res := bat.new(:int,:int);	# 1 CMDBATnew (res:bat[:int,:int])<-(_3:int)(_3:int)
    bat.setName(res,name);	# 2 BKCsetName (_4:void)<-(res:bat[:int,:int])(name:str)
    i := calc.getBATidentifier(res);	# 3 CALCbat2batid (i:BAT)<-(res:bat[:int,:int])
    return createBAT := i;	# 4  (createBAT:BAT)<-(i:BAT)
end createBAT;	# 5  
##
##tmp();
#user.tmp();
##
##{
##
##VAR top := new(str,bat);
##top.rename("top");
#top := bat.new(:str,:bat);
#bat.setName(top,"top");
#
##
##addBAT(top,"one");
##addBAT(top,"two");
#user.addBAT(top,"one");
#user.tmp();
#user.addBAT(top,"two");
##tmp();
#user.tmp();
##
##delBAT(top,"one");
#user.delBAT(top,"one");
#io.print("one droppped");
##tmp();
#user.tmp();
##
##VAR i := new(oid,str);
#m:= bat.new(:oid,:str);
##i.insert(oid(10),"ten");
#bat.insert(m,10:oid,"ten");
##i.insert(oid(20),"twenty");
#bat.insert(m,20:oid,"twenty");
##VAR res := [createBAT](i);
#io.print("do multiplex");
#r:bat[:oid,:bat]:= optimizer.multiplex("user.createBAT",m);
#io.print(r);
##tmp();
#io.print("done multiplex");
#user.tmp();
##
##top := nil;
##res := nil;
##
##}
##
###BUGS:
## in M5 this bug does not appear, because there is one reference
## returned from createBAT.
###- bat("one") still exists, due to not decreasing the reference counter
###  at the delete from bat("top")
###- bat("ten") and bat("twenty") still exist, due to creation during multiplex
###  operation (?)
## moreover, due to multiplex code inlining the reference count of "twenty" is 2
## instead of the initial expected 1.
##tmp();
##quit();
#clients.quit();
#
function user.main():void;	# 0  (main:void)
#NOTE: the reference counter of bat(name) is during insertion 	# 1  (_1:str)
#      into bat(b) correctly increased 	# 2  (_2:str)
#PROC addBAT(bat b,str name) : void { 	# 3  (_3:str)
#	VAR add := new(int,int); 	# 4  (_4:str)
#	add.rename(name); 	# 5  (_5:str)
#	b.insert(name,add); 	# 6  (_6:str)
#} 	# 7  (_7:str)
##BUG: bat(name) will not be deleted in the garbage collection 	# 8  (_8:str)
##     because the delete doesn't decrease the reference counter 	# 9  (_9:str)
#PROC delBAT(bat b,str name) : void { 	# 10  (_10:str)
#	b.delete(name); 	# 11  (_11:str)
#} 	# 12  (_7:str)
#PROC createBAT(str name) : bat[int,int] { 	# 13  (_12:str)
#	VAR res := new(int,int); 	# 14  (_13:str)
#	res.rename(name); 	# 15  (_14:str)
#	RETURN res; 	# 16  (_15:str)
#} 	# 17  (_7:str)
#NOTE we can not return  (yet) a (:bat,:bat[:int,:int]) 	# 18  (_16:str)
#into a multiplex. This means that the BATs created 	# 19  (_17:str)
# are immediately garbage collected when leaving the 	# 20  (_18:str)
#function. A hack would be to provide explicit incref/decref 	# 21  (_19:str)
#tmp(); 	# 22  (_20:str)
    user.tmp();	# 23  (_21:void)
#{ 	# 24  (_22:str)
#VAR top := new(str,bat); 	# 25  (_23:str)
#top.rename("top"); 	# 26  (_24:str)
    top := bat.new(:str,:BAT);	# 27 CMDBATnew (top:bat[:str,:BAT])<-(_26:str)(_27:BAT)
    bat.setName(top,"top");	# 28 BKCsetName (_28:void)<-(top:bat[:str,:BAT])(_29:str)
#addBAT(top,"one"); 	# 29  (_30:str)
#addBAT(top,"two"); 	# 30  (_31:str)
    user.addBAT(top,"one");	# 31  (_32:void)<-(top:bat[:str,:BAT])(_33:str)
    user.tmp();	# 32  (_34:void)
    user.addBAT(top,"two");	# 33  (_35:void)<-(top:bat[:str,:BAT])(_36:str)
#tmp(); 	# 34  (_20:str)
    user.tmp();	# 35  (_37:void)
#delBAT(top,"one"); 	# 36  (_38:str)
    user.delBAT(top,"one");	# 37  (_39:void)<-(top:bat[:str,:BAT])(_33:str)
    io.print("one droppped");	# 38 IOprint_val (_40:void)<-(_41:str)
#tmp(); 	# 39  (_20:str)
    user.tmp();	# 40  (_42:void)
#VAR i := new(oid,str); 	# 41  (_43:str)
    m := bat.new(:oid,:str);	# 42 CMDBATnew (m:bat[:oid,:str])<-(_45:oid)(_46:str)
#i.insert(oid(10),"ten"); 	# 43  (_47:str)
    bat.insert(m,10@0:oid,"ten");	# 44 BKCinsert_bun (_48:void)<-(m:bat[:oid,:str])(_49:oid)(_50:str)
#i.insert(oid(20),"twenty"); 	# 45  (_51:str)
    bat.insert(m,20@0:oid,"twenty");	# 46 BKCinsert_bun (_52:void)<-(m:bat[:oid,:str])(_53:oid)(_54:str)
#VAR res := [createBAT](i); 	# 47  (_55:str)
    io.print("do multiplex");	# 48 IOprint_val (_56:void)<-(_57:str)
    _79 := bat.new(nil:oid,nil:BAT);	# 49 CMDBATnew (_79:bat[:oid,:BAT])<-(_80:oid)(_81:BAT)
barrier (_83,_84,_85):= bat.newIterator(m);	# 50 CHPbunIterator (_83:lng)(_84:oid)(_85:str)<-(m:bat[:oid,:str]) jump 57
    _87 := user.createBAT(_85);	# 51  (_87:BAT)<-(_85:str)
    bat.insert(_79,_84,_87);	# 52 BKCinsert_bun (_88:void)<-(_79:bat[:oid,:BAT])(_84:oid)(_87:BAT)
    redo (_83,_84,_85):= bat.hasMoreElements(m);	# 53 CHPbunHasMoreElements (_83:lng)(_84:oid)(_85:str)<-(m:bat[:oid,:str]) jump 51
catch MALException:str ;	# 54  (MALException:str) jump 56
    redo (_83,_84,_85):= bat.hasMoreElements(m);	# 55 CHPbunHasMoreElements (_83:lng)(_84:oid)(_85:str)<-(m:bat[:oid,:str]) jump 51
exit MALException:str ;	# 56  (MALException:str)
exit (_83,_84,_85);	# 57  (_83:lng)(_84:oid)(_85:str)
    r:bat[:oid,:BAT]  := _79;	# 58  (r:bat[:oid,:BAT])<-(_79:bat[:oid,:BAT])
    io.print(r);	# 59 IOprint_val (_61:void)<-(r:bat[:oid,:BAT])
#tmp(); 	# 60  (_62:str)
    io.print("done multiplex");	# 61 IOprint_val (_63:void)<-(_64:str)
#top := nil; 	# 62  (_65:str)
#res := nil; 	# 63  (_66:str)
#} 	# 64  (_67:str)
##BUGS: 	# 65  (_68:str)
# in M5 this bug does not appear, because there is one reference 	# 66  (_69:str)
# returned from createBAT. 	# 67  (_70:str)
##- bat("one") still exists, due to not decreasing the reference counter 	# 68  (_71:str)
##  at the delete from bat("top") 	# 69  (_72:str)
##- bat("ten") and bat("twenty") still exist, due to creation during multiplex 	# 70  (_73:str)
##  operation (?) 	# 71  (_74:str)
# moreover, due to multiplex code inlining the reference count of "twenty" is 2 	# 72  (_75:str)
# instead of the initial expected 1. 	# 73  (_76:str)
#tmp(); 	# 74  (_62:str)
#quit(); 	# 75  (_77:str)
    clients.quit();	# 76 CLTquit (_78:void)
end main;	# 77  
[ "one droppped" ]
[ "do multiplex" ]
#-------------------------#
# h	t		  # name
# oid	BAT		  # type
#-------------------------#
[ 10@0,	  <ten>		  ]
[ 20@0,	  <twenty>	  ]
[ "done multiplex" ]

# 20:39:37 >  
# 20:39:37 >  Done.
# 20:39:37 >  

