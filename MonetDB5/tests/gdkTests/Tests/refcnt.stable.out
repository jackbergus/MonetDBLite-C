stdout of test 'refcnt` in directory 'tests/gdkTests` itself:


# 20:39:36 >  
# 20:39:36 >  Mtimeout -timeout 60 mserver5 "--config=/ufs/mk/monet5/Linux/etc/MonetDB5.conf" --debug=10 --set "monet_mod_path=/ufs/mk/monet5/Linux/lib/MonetDB5:/ufs/mk/opensource/MonetDB/Linux/lib/MonetDB" --set "gdk_dbfarm=/ufs/mk/monet5/Linux/var/MonetDB5/dbfarm" --set "sql_logdir=/ufs/mk/monet5/Linux/var/MonetDB5/dblogs" --set mapi_port=36290 --set monet_prompt= --trace --dbname=mTests_tests_gdkTests  refcnt.mal < /dev/null
# 20:39:36 >  

# MonetDB Server v4.99.19
# Copyright (c) 1993-2006 CWI, all rights reserved
# Compiled for x86_64-redhat-linux-gnu/64bit with 64bit OIDs dynamically linked
# config:/ufs/mk/monet5/Linux/etc/MonetDB5.conf
# dbfarm:/ufs/mk/monet5/Linux/var/MonetDB5/dbfarm
# dbname:mTests_tests_gdkTests
# Visit http://monetdb.cwi.nl/ for further information
#function tmp():void;
#	d:= bbp.getRefCount();
#	dl:=bbp.getLRefCount();
#	dn:= bbp.getNames();
#	io.print(dn,d,dl);
#end tmp;
function user.tmp():void;               #  0 tmp:void := user.tmp() {G}
    d := bbp.getRefCount();             #  1 d:bat[:int,:int] := CMDbbpRefCount() {G}
    dl := bbp.getLRefCount();           #  2 dl:bat[:int,:int] := CMDbbpLRefCount() {G}
    dn := bbp.getNames();               #  3 dn:bat[:int,:str] := CMDbbpNames() {G}
#io.print(dn,d,dl); 
end tmp;	# 5  
#
##NOTE: the reference counter of bat(name) is during insertion
##      into bat(b) correctly increased
##PROC addBAT(bat b,str name) : void {
##	VAR add := new(int,int);
##	add.rename(name);
##	b.insert(name,add);
##}
#function addBAT(b:bat[:str,:bat],name:str):void;
#	add:= bat.new(:int,:int);
#	bat.setName(add,name);
#	i:= calc.bat(add);
#	bat.insert(b,name,i);
#end addBAT;
function user.addBAT(b:bat[:str,:BAT],name:str):void;#  0 addBAT:void := user.addBAT(b:bat[:str,:BAT], name:str) {G}
    add := bat.new(:int,:int);          #  1 add:bat[:int,:int] := CMDBATnew(_4:int, _4:int) {G}
    bat.setName(add,name);              #  2 _5:void := BKCsetName(add:bat[:int,:int], name:str) 
    bat.insert(b,name,add);             #  3 _6:void := BKCinsert_bun(b:bat[:str,:BAT], name:str, add:bat[:int,:int]) 
end addBAT;	# 4  
##
###BUG: bat(name) will not be deleted in the garbage collection
###     because the delete doesn't decrease the reference counter
##PROC delBAT(bat b,str name) : void {
##	b.delete(name);
##}
#function delBAT(b:bat[:any_1,:any_2],name:str):void;
#	bat.delete(b,name);
#end delBAT;
function user.delBAT(b:bat[:any_1,:any_2],name:str):void;#  0 delBAT:void := user.delBAT(b:bat[:any_1,:any_2], name:str) {PG}
    bat.delete(b,name);                 #  1 _3:void := BKCdelete(b:bat[:any_1,:any_2], name:str) {P}
end delBAT;	# 2  
##
##PROC createBAT(str name) : bat[int,int] {
##	VAR res := new(int,int);
##	res.rename(name);
##	RETURN res;
##}
##NOTE we can not return  (yet) a (:bat,:bat[:int,:int])
##into a multiplex. This means that the BATs created
## are immediately garbage collected when leaving the
##function. A hack would be to provide explicit incref/decref
#function createBAT(name:str):bat;
#	res:= bat.new(:int,:int);
#	bat.setName(res,name);	
#	i:= calc.bat(res);
#	return i;
#end createBAT;
function user.createBAT(name:str):BAT;  #  0 createBAT:BAT := user.createBAT(name:str) {G}
    res := bat.new(:int,:int);          #  1 res:bat[:int,:int] := CMDBATnew(_3:int, _3:int) {G}
    bat.setName(res,name);              #  2 _4:void := BKCsetName(res:bat[:int,:int], name:str) 
    i := calc.getBATidentifier(res);    #  3 i:BAT := CALCbat2batid(res:bat[:int,:int]) {G}
    return createBAT := i;              #  4 createBAT:BAT := i:BAT {G}
end createBAT;	# 5  
##
##tmp();
#user.tmp();
##
##{
##
##VAR top := new(str,bat);
##top.rename("top");
#top := bat.new(:str,:bat);
#bat.setName(top,"top");
#
##
##addBAT(top,"one");
##addBAT(top,"two");
#user.addBAT(top,"one");
#user.tmp();
#user.addBAT(top,"two");
##tmp();
#user.tmp();
##
##delBAT(top,"one");
#user.delBAT(top,"one");
#io.print("one droppped");
##tmp();
#user.tmp();
##
##VAR i := new(oid,str);
#m:= bat.new(:oid,:str);
##i.insert(oid(10),"ten");
#bat.insert(m,10:oid,"ten");
##i.insert(oid(20),"twenty");
#bat.insert(m,20:oid,"twenty");
##VAR res := [createBAT](i);
#io.print("do multiplex");
#r:bat[:oid,:bat]:= optimizer.multiplex("user.createBAT",m);
#io.print(r);
##tmp();
#io.print("done multiplex");
#user.tmp();
##
##top := nil;
##res := nil;
##
##}
##
###BUGS:
## in M5 this bug does not appear, because there is one reference
## returned from createBAT.
###- bat("one") still exists, due to not decreasing the reference counter
###  at the delete from bat("top")
###- bat("ten") and bat("twenty") still exist, due to creation during multiplex
###  operation (?)
## moreover, due to multiplex code inlining the reference count of "twenty" is 2
## instead of the initial expected 1.
##tmp();
##quit();
#clients.quit();
#
function user.main():void;              #  0 main:void := user.main() {G}
#NOTE: the reference counter of bat(name) is during insertion 
#      into bat(b) correctly increased 
#PROC addBAT(bat b,str name) : void { 
#	VAR add := new(int,int); 
#	add.rename(name); 
#	b.insert(name,add); 
#} 
##BUG: bat(name) will not be deleted in the garbage collection 
##     because the delete doesn't decrease the reference counter 
#PROC delBAT(bat b,str name) : void { 
#	b.delete(name); 
#} 
#PROC createBAT(str name) : bat[int,int] { 
#	VAR res := new(int,int); 
#	res.rename(name); 
#	RETURN res; 
#} 
#NOTE we can not return  (yet) a (:bat,:bat[:int,:int]) 
#into a multiplex. This means that the BATs created 
# are immediately garbage collected when leaving the 
#function. A hack would be to provide explicit incref/decref 
#tmp(); 
    user.tmp();                         # 23 _23:void := user.tmp() 
#{ 
#VAR top := new(str,bat); 
#top.rename("top"); 
    top := bat.new(:str,:BAT);          # 27 top:bat[:str,:BAT] := CMDBATnew(_28:str, _29:BAT) {G}
    bat.setName(top,"top");             # 28 _30:void := BKCsetName(top:bat[:str,:BAT], _31:str) 
#addBAT(top,"one"); 
#addBAT(top,"two"); 
    user.addBAT(top,"one");             # 31 _34:void := user.addBAT(top:bat[:str,:BAT], _35:str) 
    user.tmp();                         # 32 _36:void := user.tmp() 
    user.addBAT(top,"two");             # 33 _37:void := user.addBAT(top:bat[:str,:BAT], _38:str) 
#tmp(); 
    user.tmp();                         # 35 _40:void := user.tmp() 
#delBAT(top,"one"); 
    user.delBAT(top,"one");             # 37 _42:void := user.delBAT(top:bat[:str,:BAT], _35:str) 
    io.print("one droppped");           # 38 _43:void := IOprint_val(_44:str) 
#tmp(); 
    user.tmp();                         # 40 _46:void := user.tmp() 
#VAR i := new(oid,str); 
    m := bat.new(:oid,:str);            # 42 m:bat[:oid,:str] := CMDBATnew(_49:oid, _50:str) {G}
#i.insert(oid(10),"ten"); 
    bat.insert(m,10@0:oid,"ten");       # 44 _52:void := BKCinsert_bun(m:bat[:oid,:str], _53:oid, _54:str) 
#i.insert(oid(20),"twenty"); 
    bat.insert(m,20@0:oid,"twenty");    # 46 _56:void := BKCinsert_bun(m:bat[:oid,:str], _57:oid, _58:str) 
#VAR res := [createBAT](i); 
    io.print("do multiplex");           # 48 _60:void := IOprint_val(_61:str) 
    _84 := bat.new(nil:oid,nil:BAT);    # 49 _84:bat[:oid,:BAT] := CMDBATnew(_85:oid, _86:BAT) {G}
barrier (_88,_89,_90):= bat.newIterator(m);# 50 (_88:lng, _89:oid, _90:str) := CHPbunIterator(m:bat[:oid,:str]) {GJ57}
    _92 := user.createBAT(_90);         # 51 _92:BAT := user.createBAT(_90:str) {G}
    bat.insert(_84,_89,_92);            # 52 _93:void := BKCinsert_bun(_84:bat[:oid,:BAT], _89:oid, _92:BAT) 
    redo (_88,_89,_90):= bat.hasMoreElements(m);# 53 (_88:lng, _89:oid, _90:str) := CHPbunHasMoreElements(m:bat[:oid,:str]) {GJ51}
catch MALException:str ;                # 54 MALException:str {J56}
    redo (_88,_89,_90):= bat.hasMoreElements(m);# 55 (_88:lng, _89:oid, _90:str) := CHPbunHasMoreElements(m:bat[:oid,:str]) {GJ51}
exit MALException:str ;                 # 56 MALException:str 
exit (_88,_89,_90);                     # 57 (_88:lng, _89:oid, _90:str) 
    r:bat[:oid,:BAT]  := _84;           # 58 r:bat[:oid,:BAT] := _84:bat[:oid,:BAT] {G}
    io.print(r);                        # 59 _65:void := IOprint_val(r:bat[:oid,:BAT]) 
#tmp(); 
    io.print("done multiplex");         # 61 _67:void := IOprint_val(_68:str) 
#top := nil; 
#res := nil; 
#} 
##BUGS: 
# in M5 this bug does not appear, because there is one reference 
# returned from createBAT. 
##- bat("one") still exists, due to not decreasing the reference counter 
##  at the delete from bat("top") 
##- bat("ten") and bat("twenty") still exist, due to creation during multiplex 
##  operation (?) 
# moreover, due to multiplex code inlining the reference count of "twenty" is 2 
# instead of the initial expected 1. 
#tmp(); 
#quit(); 
    clients.quit();                     # 76 _83:void := CLTquit() 
end main;	# 77  
[ "one droppped" ]
[ "do multiplex" ]
#-------------------------#
# h	t		  # name
# oid	BAT		  # type
#-------------------------#
[ 10@0,	  <ten>		  ]
[ 20@0,	  <twenty>	  ]
[ "done multiplex" ]

# 20:39:37 >  
# 20:39:37 >  Done.
# 20:39:37 >  

