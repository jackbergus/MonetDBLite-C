stdout of test 'refcnt` in directory 'tests/gdkTests` itself:


# 20:39:36 >  
# 20:39:36 >  Mtimeout -timeout 60 mserver5 "--config=/ufs/mk/monet5/Linux/etc/MonetDB5.conf" --debug=10 --set "monet_mod_path=/ufs/mk/monet5/Linux/lib/MonetDB5:/ufs/mk/opensource/MonetDB/Linux/lib/MonetDB" --set "gdk_dbfarm=/ufs/mk/monet5/Linux/var/MonetDB5/dbfarm" --set "sql_logdir=/ufs/mk/monet5/Linux/var/MonetDB5/dblogs" --set mapi_port=36290 --set monet_prompt= --trace --dbname=mTests_tests_gdkTests  refcnt.mal < /dev/null
# 20:39:36 >  

# MonetDB Server v4.99.19
# Copyright (c) 1993-2006 CWI, all rights reserved
# Compiled for x86_64-redhat-linux-gnu/64bit with 64bit OIDs dynamically linked
# config:/ufs/mk/monet5/Linux/etc/MonetDB5.conf
# dbfarm:/ufs/mk/monet5/Linux/var/MonetDB5/dbfarm
# dbname:mTests_tests_gdkTests
# Visit http://monetdb.cwi.nl/ for further information
# Listening for connection requests on mapi:monetdb://eir.ins.cwi.nl:30579/
function user.tmp():void;
    d := bbp.getRefCount();
    dl := bbp.getLRefCount();
    dn := bbp.getNames();
#io.print(dn,d,dl); 
end tmp;
function user.addBAT(b:bat[:str,:BAT],name:str):void;
    add := bat.new(:int,:int);
    bat.setName(add,name);
    bat.insert(b,name,add);
end addBAT;
function user.delBAT(b:bat[:any_1,:any_2],name:str):void;
    bat.delete(b,name);
end delBAT;
function user.createBAT(name:str):BAT;
    res := bat.new(:int,:int);
    bat.setName(res,name);
    i := calc.getBATidentifier(res);
    return createBAT := i;
end createBAT;
function user.main():void;
#NOTE: the reference counter of bat(name) is during insertion 
#      into bat(b) correctly increased 
#PROC addBAT(bat b,str name) : void { 
#	VAR add := new(int,int); 
#	add.rename(name); 
#	b.insert(name,add); 
#} 
##BUG: bat(name) will not be deleted in the garbage collection 
##     because the delete doesn't decrease the reference counter 
#PROC delBAT(bat b,str name) : void { 
#	b.delete(name); 
#} 
#PROC createBAT(str name) : bat[int,int] { 
#	VAR res := new(int,int); 
#	res.rename(name); 
#	RETURN res; 
#} 
#NOTE we can not return  (yet) a (:bat,:bat[:int,:int]) 
#into a multiplex. This means that the BATs created 
# are immediately garbage collected when leaving the 
#function. A hack would be to provide explicit incref/decref 
#tmp(); 
    user.tmp();
#{ 
#VAR top := new(str,bat); 
#top.rename("top"); 
    top := bat.new(:str,:BAT);
    bat.setName(top,"top");
#addBAT(top,"one"); 
#addBAT(top,"two"); 
    user.addBAT(top,"one");
    user.tmp();
    user.addBAT(top,"two");
#tmp(); 
    user.tmp();
#delBAT(top,"one"); 
    user.delBAT(top,"one");
    io.print("one droppped");
#tmp(); 
    user.tmp();
#VAR i := new(oid,str); 
    m := bat.new(:oid,:str);
#i.insert(oid(10),"ten"); 
    bat.insert(m,10@0:oid,"ten");
#i.insert(oid(20),"twenty"); 
    bat.insert(m,20@0:oid,"twenty");
#VAR res := [createBAT](i); 
    io.print("do multiplex");
    _84 := bat.new(nil:oid,nil:BAT);
barrier (_88,_89,_90) := bat.newIterator(m);
    _92 := user.createBAT(_90);
    bat.insert(_84,_89,_92);
    redo (_88,_89,_90) := bat.hasMoreElements(m);
exit (_88,_89,_90);
    r := _84;
    io.print(r);
#tmp(); 
    io.print("done multiplex");
#top := nil; 
#res := nil; 
#} 
##BUGS: 
# in M5 this bug does not appear, because there is one reference 
# returned from createBAT. 
##- bat("one") still exists, due to not decreasing the reference counter 
##  at the delete from bat("top") 
##- bat("ten") and bat("twenty") still exist, due to creation during multiplex 
##  operation (?) 
# moreover, due to multiplex code inlining the reference count of "twenty" is 2 
# instead of the initial expected 1. 
#tmp(); 
#quit(); 
    clients.quit();
end main;
[ "one droppped" ]
[ "do multiplex" ]
#-------------------------#
# h	t		  # name
# oid	BAT		  # type
#-------------------------#
[ 10@0,	  <ten>		  ]
[ 20@0,	  <twenty>	  ]
[ "done multiplex" ]

# 20:39:37 >  
# 20:39:37 >  Done.
# 20:39:37 >  

