stdout of test 'ID.605953` in directory 'tests/BugsViaSourgeforce` itself:


# 07:27:17 >  
# 07:27:17 >  Mtimeout -timeout 60 mserver5 "--config=/ufs/mk/monet5/Linux/etc/MonetDB5.conf" --debug=10 --set "monet_mod_path=/ufs/mk/monet5/Linux/lib/MonetDB5:/ufs/mk/opensource/MonetDB/Linux/lib/MonetDB" --set "gdk_dbfarm=/ufs/mk/monet5/Linux/var/MonetDB5/dbfarm" --set "sql_logdir=/ufs/mk/monet5/Linux/var/MonetDB5/dblogs" --set mapi_port=35545 --set monet_prompt= --trace --dbname=mTests_tests_BugsViaSourgeforce  ID.605953.mal < /dev/null
# 07:27:17 >  

# MonetDB server v5.7.0, based on kernel v1.25.0
# Serving database 'mTests_tests_BugsViaSourgeforce', using 4 threads
# Compiled for x86_64-unknown-linux-gnu/64bit with 64bit OIDs dynamically linked
# Copyright (c) 1993-July 2008 CWI.
# Copyright (c) August 2008- MonetDB B.V., all rights reserved
# Visit http://monetdb.cwi.nl/ for further information
## Monet Mil to Mal compiler
##include mil;
## Copyright (c) 2001-2004, CWI. All rights reserved.
#
##Predefined code segment
##The compiler can not guarantee an accurate compilation,
##because MIL unlike MAL is a dynamically typed language.
##A few guidelines to maximize usefullness.
##- make the type of variables explicit, in particular 'nil'
##- upon advice of M2m to remap identifiers, change it in your program directly
##use the "mil_schema" for additional support routines
#	t := bat.new(nil:oid,nil:str);
#	aa_a := calc.oid(0);
#	ba_a := bat.insert(t,aa_a,"a");
#	ca_a := calc.oid(1);
#	da_a := bat.insert(t,ca_a,"b");
#	ea_a := calc.oid(2);
#	fa_a := bat.insert(t,ea_a,"c");
#	ga_a := calc.oid(3);
#	ha_a := bat.insert(t,ga_a,"d");
#	ia_a := calc.oid(4);
#	ja_a := bat.insert(t,ia_a,"e");
#	ka_a := calc.oid(5);
#	la_a := bat.insert(t,ka_a,"f");
#	ma_a := calc.oid(6);
#	na_a := bat.insert(t,ma_a,"g");
#	oa_a := calc.oid(7);
#	pa_a := bat.insert(t,oa_a,"h");
#	qa_a := algebra.markT(t,nil:oid);
#	ra_a := io.print(t);
#	t2 := bat.new(nil:void,nil:str);
#	sa_a := calc.oid(0);
#	ta_a := bat.setSequenceBase(t2,sa_a);
#	ua_a := calc.oid(0);
#	va_a := bat.insert(t2,ua_a,"a");
#	wa_a := calc.oid(1);
#	xa_a := bat.insert(t2,wa_a,"b");
#	ya_a := calc.oid(2);
#	ab_a := bat.insert(t2,ya_a,"c");
#	bb_a := calc.oid(3);
#	cb_a := bat.insert(t2,bb_a,"d");
#	db_a := calc.oid(4);
#	eb_a := bat.insert(t2,db_a,"e");
#	fb_a := calc.oid(5);
#	gb_a := bat.insert(t2,fb_a,"f");
#	hb_a := calc.oid(6);
#	ib_a := bat.insert(t2,hb_a,"g");
#	jb_a := calc.oid(7);
#	kb_a := bat.insert(t2,jb_a,"h");
#	lb_a := algebra.markT(t2,nil:oid);
#	mb_a := io.print(lb_a);
##Identifer 'seqbase' mapped to 'bat.setSequenceBase'
#
function user.main():void;              #  0 main:void := user.main() {G}
# Monet Mil to Mal compiler 
# Copyright (c) 2001-2004, CWI. All rights reserved. 
#Predefined code segment 
#The compiler can not guarantee an accurate compilation, 
#because MIL unlike MAL is a dynamically typed language. 
#A few guidelines to maximize usefullness. 
#- make the type of variables explicit, in particular 'nil' 
#- upon advice of M2m to remap identifiers, change it in your program directly 
#use the "mil_schema" for additional support routines 
    t := bat.new(nil:oid,nil:str);      # 10 t:bat[:oid,:str] := CMDBATnew(_11:oid, _12:str) {G}
    aa_a := calc.oid(0);                # 11 aa_a:oid := CALCint2oid(_14:int) 
    ba_a := bat.insert(t,aa_a,"a");     # 12 ba_a:bat[:oid,:str] := BKCinsert_bun(t:bat[:oid,:str], aa_a:oid, _16:str) {G}
    ca_a := calc.oid(1);                # 13 ca_a:oid := CALCint2oid(_18:int) 
    da_a := bat.insert(t,ca_a,"b");     # 14 da_a:bat[:oid,:str] := BKCinsert_bun(t:bat[:oid,:str], ca_a:oid, _20:str) {G}
    ea_a := calc.oid(2);                # 15 ea_a:oid := CALCint2oid(_22:int) 
    fa_a := bat.insert(t,ea_a,"c");     # 16 fa_a:bat[:oid,:str] := BKCinsert_bun(t:bat[:oid,:str], ea_a:oid, _24:str) {G}
    ga_a := calc.oid(3);                # 17 ga_a:oid := CALCint2oid(_26:int) 
    ha_a := bat.insert(t,ga_a,"d");     # 18 ha_a:bat[:oid,:str] := BKCinsert_bun(t:bat[:oid,:str], ga_a:oid, _28:str) {G}
    ia_a := calc.oid(4);                # 19 ia_a:oid := CALCint2oid(_30:int) 
    ja_a := bat.insert(t,ia_a,"e");     # 20 ja_a:bat[:oid,:str] := BKCinsert_bun(t:bat[:oid,:str], ia_a:oid, _32:str) {G}
    ka_a := calc.oid(5);                # 21 ka_a:oid := CALCint2oid(_34:int) 
    la_a := bat.insert(t,ka_a,"f");     # 22 la_a:bat[:oid,:str] := BKCinsert_bun(t:bat[:oid,:str], ka_a:oid, _36:str) {G}
    ma_a := calc.oid(6);                # 23 ma_a:oid := CALCint2oid(_38:int) 
    na_a := bat.insert(t,ma_a,"g");     # 24 na_a:bat[:oid,:str] := BKCinsert_bun(t:bat[:oid,:str], ma_a:oid, _40:str) {G}
    oa_a := calc.oid(7);                # 25 oa_a:oid := CALCint2oid(_42:int) 
    pa_a := bat.insert(t,oa_a,"h");     # 26 pa_a:bat[:oid,:str] := BKCinsert_bun(t:bat[:oid,:str], oa_a:oid, _44:str) {G}
    qa_a := algebra.markT(t,nil:oid);   # 27 qa_a:bat[:oid,:oid] := ALGtmark(t:bat[:oid,:str], _46:oid) {G}
    ra_a := io.print(t);                # 28 ra_a:void := IOprint_val(t:bat[:oid,:str]) 
    t2 := bat.new(nil:void,nil:str);    # 29 t2:bat[:void,:str] := CMDBATnew(_49:void, _50:str) {G}
    ua_a := nil:void;                   # 30 ua_a:void := _49:void {G}
    va_a := bat.insert(t2,ua_a,"a");    # 31 va_a:bat[:void,:str] := BKCinsert_bun(t2:bat[:void,:str], ua_a:void, _53:str) {G}
    wa_a := nil:void;                   # 32 wa_a:void := _49:void {G}
    xa_a := bat.insert(t2,wa_a,"b");    # 33 xa_a:bat[:void,:str] := BKCinsert_bun(t2:bat[:void,:str], wa_a:void, _56:str) {G}
    ya_a := nil:void;                   # 34 ya_a:void := _49:void {G}
    ab_a := bat.insert(t2,ya_a,"c");    # 35 ab_a:bat[:void,:str] := BKCinsert_bun(t2:bat[:void,:str], ya_a:void, _59:str) {G}
    bb_a := nil:void;                   # 36 bb_a:void := _49:void {G}
    cb_a := bat.insert(t2,bb_a,"d");    # 37 cb_a:bat[:void,:str] := BKCinsert_bun(t2:bat[:void,:str], bb_a:void, _62:str) {G}
    db_a := nil:void;                   # 38 db_a:void := _49:void {G}
    eb_a := bat.insert(t2,db_a,"e");    # 39 eb_a:bat[:void,:str] := BKCinsert_bun(t2:bat[:void,:str], db_a:void, _65:str) {G}
    fb_a := nil:void;                   # 40 fb_a:void := _49:void {G}
    gb_a := bat.insert(t2,fb_a,"f");    # 41 gb_a:bat[:void,:str] := BKCinsert_bun(t2:bat[:void,:str], fb_a:void, _36:str) {G}
    hb_a := nil:void;                   # 42 hb_a:void := _49:void {G}
    ib_a := bat.insert(t2,hb_a,"g");    # 43 ib_a:bat[:void,:str] := BKCinsert_bun(t2:bat[:void,:str], hb_a:void, _40:str) {G}
    jb_a := nil:void;                   # 44 jb_a:void := _49:void {G}
    kb_a := bat.insert(t2,jb_a,"h");    # 45 kb_a:bat[:void,:str] := BKCinsert_bun(t2:bat[:void,:str], jb_a:void, _44:str) {G}
    lb_a := algebra.markT(t2,nil:oid);  # 46 lb_a:bat[:void,:oid] := ALGtmark(t2:bat[:void,:str], _46:oid) {G}
    mb_a := io.print(lb_a);             # 47 mb_a:void := IOprint_val(lb_a:bat[:void,:oid]) 
#Identifer 'seqbase' mapped to 'bat.setSequenceBase' 
end main;	# 49  
#-----------------#
# h	t	  # name
# oid	str	  # type
#-----------------#
[ 0@0,	  "a"	  ]
[ 1@0,	  "b"	  ]
[ 2@0,	  "c"	  ]
[ 3@0,	  "d"	  ]
[ 4@0,	  "e"	  ]
[ 5@0,	  "f"	  ]
[ 6@0,	  "g"	  ]
[ 7@0,	  "h"	  ]
#-----------------#
# h	t	  # name
# void	void	  # type
#-----------------#
[ nil,	  nil	  ]
[ nil,	  nil	  ]
[ nil,	  nil	  ]
[ nil,	  nil	  ]
[ nil,	  nil	  ]
[ nil,	  nil	  ]
[ nil,	  nil	  ]
[ nil,	  nil	  ]

# 07:27:17 >  
# 07:27:17 >  Done.
# 07:27:17 >  

