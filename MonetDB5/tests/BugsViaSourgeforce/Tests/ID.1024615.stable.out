stdout of test 'ID.1024615` in directory 'tests/BugsViaSourgeforce` itself:


# 07:27:18 >  
# 07:27:18 >  Mtimeout -timeout 60 mserver5 "--config=/ufs/mk/monet5/Linux/etc/MonetDB5.conf" --debug=10 --set "monet_mod_path=/ufs/mk/monet5/Linux/lib/MonetDB5:/ufs/mk/opensource/MonetDB/Linux/lib/MonetDB" --set "gdk_dbfarm=/ufs/mk/monet5/Linux/var/MonetDB5/dbfarm" --set "sql_logdir=/ufs/mk/monet5/Linux/var/MonetDB5/dblogs" --set mapi_port=35545 --set monet_prompt= --trace --dbname=mTests_tests_BugsViaSourgeforce  ID.1024615.mal < /dev/null
# 07:27:18 >  

# MonetDB Server v4.99.19
# Copyright (c) 1993-2006 CWI, all rights reserved
# Compiled for x86_64-redhat-linux-gnu/64bit with 64bit OIDs dynamically linked
# config:/ufs/mk/monet5/Linux/etc/MonetDB5.conf
# dbfarm:/ufs/mk/monet5/Linux/var/MonetDB5/dbfarm
# dbname:mTests_tests_BugsViaSourgeforce
# Visit http://monetdb.cwi.nl/ for further information
## Monet Mil to Mal compiler
##include mil;
## Copyright (c) 2001-2004, CWI. All rights reserved.
#
##Predefined code segment
##The compiler can not guarantee an accurate compilation,
##because MIL unlike MAL is a dynamically typed language.
##A few guidelines to maximize usefullness.
##- make the type of variables explicit, in particular 'nil'
##- upon advice of M2m to remap identifiers, change it in your program directly
##use the "mil_schema" for additional support routines
##	mil.line("var b1 := bat(oid,str);");
#	b1 := bat.new(nil:oid,nil:str);
##	mil.line("b1.reverse().sort().reverse().print();");
#	aa_a := bat.reverse(b1);
#	ba_a := algebra.sort(aa_a);
#	ca_a := bat.reverse(ba_a);
#	da_a := io.print(ca_a);
##	mil.line("b1.access(BAT_WRITE);");
#	BAT_WRITE:= mil.take("BAT_WRITE");
#	ea_a := bat.setWriteMode(b1);
##	mil.line("b1.reverse().sort().reverse().print();");
#	fa_a := bat.reverse(b1);
#	ga_a := algebra.sort(fa_a);
#	ha_a := bat.reverse(ga_a);
#	ia_a := io.print(ha_a);
##	mil.line("var b2 := bat(void,str);");
#	b2 := bat.new(nil:void,nil:str);
##	mil.line("b2.seqbase(oid(10));");
#	ja_a := calc.oid(10);
#	ka_a := bat.setSequenceBase(b2,ja_a);
##	mil.line("b2.reverse().sort().reverse().print();");
#	la_a := bat.reverse(b2);
#	ma_a := algebra.sort(la_a);
#	na_a := bat.reverse(ma_a);
#	oa_a := io.print(na_a);
##	mil.line("b2.access(BAT_WRITE);");
#	pa_a := bat.setWriteMode(b2);
##	mil.line("b2.reverse().sort().reverse().print();");
#	qa_a := bat.reverse(b2);
#	ra_a := algebra.sort(qa_a);
#	sa_a := bat.reverse(ra_a);
#	ta_a := io.print(sa_a);
##	mil.line("var b3 := mirror(b2);");
#	b3 := bat.mirror(b2);
##	mil.line("b3.print();");
#	ua_a := io.print(b3);
##	mil.line("var b4 := b3.reverse().join(b2);");
#	va_a := bat.reverse(b3);
#	b4 := algebra.join(va_a,b2);
##	mil.line("b4.print();");
#	wa_a := io.print(b4);
##	mil.line("# next line produced an incorrect error \n");
##	mil.line("# ERROR: CMDsort: returned BAT has unexpected head.\n");
#	xa_a := bat.reverse(b4);
#	ya_a := algebra.sort(xa_a);
#	ab_a := bat.reverse(ya_a);
#	bb_a := io.print(ab_a);
##	mil.line("#mini mil example\n");
##	mil.line("var b2 := bat(void,str);");
#	b2 := bat.new(nil:void,nil:str);
##	mil.line("b2.seqbase(oid(10));");
#	cb_a := calc.oid(10);
#	db_a := bat.setSequenceBase(b2,cb_a);
##	mil.line("var b3 := mirror(b2);");
#	b3 := bat.mirror(b2);
##	mil.line("var b4 := b3.reverse().join(b2);");
#	eb_a := bat.reverse(b3);
#	b4 := algebra.join(eb_a,b2);
##	mil.line("# next line produced an incorrect error \n");
##	mil.line("# ERROR: CMDsort: returned BAT has unexpected head.\n");
#	fb_a := bat.reverse(b4);
#	gb_a := algebra.sort(fb_a);
#	hb_a := bat.reverse(gb_a);
#	ib_a := io.print(hb_a);
##Identifer 'seqbase' mapped to 'bat.setSequenceBase'
#
!TypeException:user.main[18]:'mil.take' undefined in: BAT_WRITE:any := mil.take(_21:str)
function user.main():void;              #  0 main:void := user.main() {G}
# Monet Mil to Mal compiler 
# Copyright (c) 2001-2004, CWI. All rights reserved. 
#Predefined code segment 
#The compiler can not guarantee an accurate compilation, 
#because MIL unlike MAL is a dynamically typed language. 
#A few guidelines to maximize usefullness. 
#- make the type of variables explicit, in particular 'nil' 
#- upon advice of M2m to remap identifiers, change it in your program directly 
#use the "mil_schema" for additional support routines 
#	io.print("var b1 := bat(oid,str);"); 
    b1 := bat.new(nil:oid,nil:str);     # 11 b1:bat[:oid,:str] := CMDBATnew(_12:oid, _13:str) {G}
#	io.print("b1.reverse().sort().reverse().print();"); 
    aa_a := bat.reverse(b1);            # 13 aa_a:bat[:str,:oid] := BKCreverse(b1:bat[:oid,:str]) {G}
    ba_a := algebra.sort(aa_a);         # 14 ba_a:bat[:str,:oid] := ALGhsort(aa_a:bat[:str,:oid]) {G}
    ca_a := bat.reverse(ba_a);          # 15 ca_a:bat[:oid,:str] := BKCreverse(ba_a:bat[:str,:oid]) {G}
    da_a := io.print(ca_a);             # 16 da_a:void := IOprint_val(ca_a:bat[:oid,:str]) 
#	io.print("b1.access(BAT_WRITE);"); 
    BAT_WRITE := mil.take("BAT_WRITE"); # 18 BAT_WRITE:any := mil.take(_21:str) {U}
    ea_a := bat.setWriteMode(b1);       # 19 ea_a:bat[:oid,:str] := BKCsetWriteMode(b1:bat[:oid,:str]) {G}
#	io.print("b1.reverse().sort().reverse().print();"); 
    fa_a := bat.reverse(b1);            # 21 fa_a:bat[:str,:oid] := BKCreverse(b1:bat[:oid,:str]) {G}
    ga_a := algebra.sort(fa_a);         # 22 ga_a:bat[:str,:oid] := ALGhsort(fa_a:bat[:str,:oid]) {G}
    ha_a := bat.reverse(ga_a);          # 23 ha_a:bat[:oid,:str] := BKCreverse(ga_a:bat[:str,:oid]) {G}
    ia_a := io.print(ha_a);             # 24 ia_a:void := IOprint_val(ha_a:bat[:oid,:str]) 
#	io.print("var b2 := bat(void,str);"); 
    b2 := bat.new(nil:oid,nil:str);     # 26 b2:bat[:oid,:str] := CMDBATnew(_12:oid, _13:str) {G}
#	io.print("b2.seqbase(oid(10));"); 
    ja_a := calc.oid(10);               # 28 ja_a:oid := CALCint2oid(_32:int) 
#	io.print("b2.reverse().sort().reverse().print();"); 
    la_a := bat.reverse(b2);            # 30 la_a:bat[:str,:oid] := BKCreverse(b2:bat[:oid,:str]) {G}
    ma_a := algebra.sort(la_a);         # 31 ma_a:bat[:str,:oid] := ALGhsort(la_a:bat[:str,:oid]) {G}
    na_a := bat.reverse(ma_a);          # 32 na_a:bat[:oid,:str] := BKCreverse(ma_a:bat[:str,:oid]) {G}
    oa_a := io.print(na_a);             # 33 oa_a:void := IOprint_val(na_a:bat[:oid,:str]) 
#	io.print("b2.access(BAT_WRITE);"); 
    pa_a := bat.setWriteMode(b2);       # 35 pa_a:bat[:oid,:str] := BKCsetWriteMode(b2:bat[:oid,:str]) {G}
#	io.print("b2.reverse().sort().reverse().print();"); 
    qa_a := bat.reverse(b2);            # 37 qa_a:bat[:str,:oid] := BKCreverse(b2:bat[:oid,:str]) {G}
    ra_a := algebra.sort(qa_a);         # 38 ra_a:bat[:str,:oid] := ALGhsort(qa_a:bat[:str,:oid]) {G}
    sa_a := bat.reverse(ra_a);          # 39 sa_a:bat[:oid,:str] := BKCreverse(ra_a:bat[:str,:oid]) {G}
    ta_a := io.print(sa_a);             # 40 ta_a:void := IOprint_val(sa_a:bat[:oid,:str]) 
#	io.print("var b3 := mirror(b2);"); 
    b3 := bat.mirror(b2);               # 42 b3:bat[:oid,:oid] := BKCmirror(b2:bat[:oid,:str]) {G}
#	io.print("b3.print();"); 
    ua_a := io.print(b3);               # 44 ua_a:void := IOprint_val(b3:bat[:oid,:oid]) 
#	io.print("var b4 := b3.reverse().join(b2);"); 
    va_a := bat.reverse(b3);            # 46 va_a:bat[:oid,:oid] := BKCreverse(b3:bat[:oid,:oid]) {G}
    b4 := algebra.join(va_a,b2);        # 47 b4:bat[:oid,:str] := ALGjoin(va_a:bat[:oid,:oid], b2:bat[:oid,:str]) {G}
#	io.print("b4.print();"); 
    wa_a := io.print(b4);               # 49 wa_a:void := IOprint_val(b4:bat[:oid,:str]) 
#	io.print("# next line produced an incorrect error \n"); 
#	io.print("# ERROR: CMDsort: returned BAT has unexpected head.\n"); 
    xa_a := bat.reverse(b4);            # 52 xa_a:bat[:str,:oid] := BKCreverse(b4:bat[:oid,:str]) {G}
    ya_a := algebra.sort(xa_a);         # 53 ya_a:bat[:str,:oid] := ALGhsort(xa_a:bat[:str,:oid]) {G}
    ab_a := bat.reverse(ya_a);          # 54 ab_a:bat[:oid,:str] := BKCreverse(ya_a:bat[:str,:oid]) {G}
    bb_a := io.print(ab_a);             # 55 bb_a:void := IOprint_val(ab_a:bat[:oid,:str]) 
#	io.print("#mini mil example\n"); 
#	io.print("var b2 := bat(void,str);"); 
    b2 := bat.new(nil:oid,nil:str);     # 58 b2:bat[:oid,:str] := CMDBATnew(_62:oid, _63:str) {G}
#	io.print("b2.seqbase(oid(10));"); 
#	io.print("var b3 := mirror(b2);"); 
    b3 := bat.mirror(b2);               # 61 b3:bat[:oid,:oid] := BKCmirror(b2:bat[:oid,:str]) {G}
#	io.print("var b4 := b3.reverse().join(b2);"); 
    eb_a := bat.reverse(b3);            # 63 eb_a:bat[:oid,:oid] := BKCreverse(b3:bat[:oid,:oid]) {G}
    b4 := algebra.join(eb_a,b2);        # 64 b4:bat[:oid,:str] := ALGjoin(eb_a:bat[:oid,:oid], b2:bat[:oid,:str]) {G}
#	io.print("# next line produced an incorrect error \n"); 
#	io.print("# ERROR: CMDsort: returned BAT has unexpected head.\n"); 
    fb_a := bat.reverse(b4);            # 67 fb_a:bat[:str,:oid] := BKCreverse(b4:bat[:oid,:str]) {G}
    gb_a := algebra.sort(fb_a);         # 68 gb_a:bat[:str,:oid] := ALGhsort(fb_a:bat[:str,:oid]) {G}
    hb_a := bat.reverse(gb_a);          # 69 hb_a:bat[:oid,:str] := BKCreverse(gb_a:bat[:str,:oid]) {G}
    ib_a := io.print(hb_a);             # 70 ib_a:void := IOprint_val(hb_a:bat[:oid,:str]) 
end main;	# 71  

# 07:27:18 >  
# 07:27:18 >  Done.
# 07:27:18 >  

