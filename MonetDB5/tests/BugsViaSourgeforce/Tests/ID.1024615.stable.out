stdout of test 'ID.1024615` in directory 'tests/BugsViaSourgeforce` itself:


# 07:27:18 >  
# 07:27:18 >  Mtimeout -timeout 60 mserver5 "--config=/ufs/mk/monet5/Linux/etc/MonetDB5.conf" --debug=10 --set "monet_mod_path=/ufs/mk/monet5/Linux/lib/MonetDB5:/ufs/mk/opensource/MonetDB/Linux/lib/MonetDB" --set "gdk_dbfarm=/ufs/mk/monet5/Linux/var/MonetDB5/dbfarm" --set "sql_logdir=/ufs/mk/monet5/Linux/var/MonetDB5/dblogs" --set mapi_port=35545 --set monet_prompt= --trace --dbname=mTests_tests_BugsViaSourgeforce  ID.1024615.mal < /dev/null
# 07:27:18 >  

# MonetDB Server v4.99.19
# Copyright (c) 1993-2006 CWI, all rights reserved
# Compiled for x86_64-redhat-linux-gnu/64bit with 64bit OIDs dynamically linked
# config:/ufs/mk/monet5/Linux/etc/MonetDB5.conf
# dbfarm:/ufs/mk/monet5/Linux/var/MonetDB5/dbfarm
# dbname:mTests_tests_BugsViaSourgeforce
# Visit http://monetdb.cwi.nl/ for further information
## Monet Mil to Mal compiler
##include mil;
## Copyright (c) 2001-2004, CWI. All rights reserved.
#
##Predefined code segment
##The compiler can not guarantee an accurate compilation,
##because MIL unlike MAL is a dynamically typed language.
##A few guidelines to maximize usefullness.
##- make the type of variables explicit, in particular 'nil'
##- upon advice of M2m to remap identifiers, change it in your program directly
##use the "mil_schema" for additional support routines
##	mil.line("var b1 := bat(oid,str);");
#	b1 := bat.new(nil:oid,nil:str);
##	mil.line("b1.reverse().sort().reverse().print();");
#	aa_a := bat.reverse(b1);
#	ba_a := algebra.sort(aa_a);
#	ca_a := bat.reverse(ba_a);
#	da_a := io.print(ca_a);
##	mil.line("b1.access(BAT_WRITE);");
#	BAT_WRITE:= mil.take("BAT_WRITE");
#	ea_a := bat.setWriteMode(b1);
##	mil.line("b1.reverse().sort().reverse().print();");
#	fa_a := bat.reverse(b1);
#	ga_a := algebra.sort(fa_a);
#	ha_a := bat.reverse(ga_a);
#	ia_a := io.print(ha_a);
##	mil.line("var b2 := bat(void,str);");
#	b2 := bat.new(nil:void,nil:str);
##	mil.line("b2.seqbase(oid(10));");
#	ja_a := calc.oid(10);
#	ka_a := bat.setSequenceBase(b2,ja_a);
##	mil.line("b2.reverse().sort().reverse().print();");
#	la_a := bat.reverse(b2);
#	ma_a := algebra.sort(la_a);
#	na_a := bat.reverse(ma_a);
#	oa_a := io.print(na_a);
##	mil.line("b2.access(BAT_WRITE);");
#	pa_a := bat.setWriteMode(b2);
##	mil.line("b2.reverse().sort().reverse().print();");
#	qa_a := bat.reverse(b2);
#	ra_a := algebra.sort(qa_a);
#	sa_a := bat.reverse(ra_a);
#	ta_a := io.print(sa_a);
##	mil.line("var b3 := mirror(b2);");
#	b3 := bat.mirror(b2);
##	mil.line("b3.print();");
#	ua_a := io.print(b3);
##	mil.line("var b4 := b3.reverse().join(b2);");
#	va_a := bat.reverse(b3);
#	b4 := algebra.join(va_a,b2);
##	mil.line("b4.print();");
#	wa_a := io.print(b4);
##	mil.line("# next line produced an incorrect error \n");
##	mil.line("# ERROR: CMDsort: returned BAT has unexpected head.\n");
#	xa_a := bat.reverse(b4);
#	ya_a := algebra.sort(xa_a);
#	ab_a := bat.reverse(ya_a);
#	bb_a := io.print(ab_a);
##	mil.line("#mini mil example\n");
##	mil.line("var b2 := bat(void,str);");
#	b2 := bat.new(nil:void,nil:str);
##	mil.line("b2.seqbase(oid(10));");
#	cb_a := calc.oid(10);
#	db_a := bat.setSequenceBase(b2,cb_a);
##	mil.line("var b3 := mirror(b2);");
#	b3 := bat.mirror(b2);
##	mil.line("var b4 := b3.reverse().join(b2);");
#	eb_a := bat.reverse(b3);
#	b4 := algebra.join(eb_a,b2);
##	mil.line("# next line produced an incorrect error \n");
##	mil.line("# ERROR: CMDsort: returned BAT has unexpected head.\n");
#	fb_a := bat.reverse(b4);
#	gb_a := algebra.sort(fb_a);
#	hb_a := bat.reverse(gb_a);
#	ib_a := io.print(hb_a);
##Identifer 'seqbase' mapped to 'bat.setSequenceBase'
#
!ERROR: TypeException: user.main[18]: 'mil.take' undefined in: BAT_WRITE:any := mil.take(_21:str)
function user.main():void;	# 0  (main:void)
# Monet Mil to Mal compiler 	# 1  (_1:str)
# Copyright (c) 2001-2004, CWI. All rights reserved. 	# 2  (_2:str)
#Predefined code segment 	# 3  (_3:str)
#The compiler can not guarantee an accurate compilation, 	# 4  (_4:str)
#because MIL unlike MAL is a dynamically typed language. 	# 5  (_5:str)
#A few guidelines to maximize usefullness. 	# 6  (_6:str)
#- make the type of variables explicit, in particular 'nil' 	# 7  (_7:str)
#- upon advice of M2m to remap identifiers, change it in your program directly 	# 8  (_8:str)
#use the "mil_schema" for additional support routines 	# 9  (_9:str)
#	io.print("var b1 := bat(oid,str);"); 	# 10  (_10:str)
    b1 := bat.new(nil:oid,nil:str);	# 11 CMDBATnew (b1:bat[:oid,:str])<-(_12:oid)(_13:str)
#	io.print("b1.reverse().sort().reverse().print();"); 	# 12  (_14:str)
    aa_a := bat.reverse(b1);	# 13 BKCreverse (aa_a:bat[:str,:oid])<-(b1:bat[:oid,:str])
    ba_a := algebra.sort(aa_a);	# 14 ALGhsort (ba_a:bat[:str,:oid])<-(aa_a:bat[:str,:oid])
    ca_a := bat.reverse(ba_a);	# 15 BKCreverse (ca_a:bat[:oid,:str])<-(ba_a:bat[:str,:oid])
    da_a := io.print(ca_a);	# 16 IOprint_val (da_a:void)<-(ca_a:bat[:oid,:str])
#	io.print("b1.access(BAT_WRITE);"); 	# 17  (_19:str)
    BAT_WRITE := mil.take("BAT_WRITE");	# 18  unknown (BAT_WRITE:any)<-(_21:str)
    ea_a := bat.setWriteMode(b1);	# 19 BKCsetWriteMode (ea_a:bat[:oid,:str])<-(b1:bat[:oid,:str])
#	io.print("b1.reverse().sort().reverse().print();"); 	# 20  (_14:str)
    fa_a := bat.reverse(b1);	# 21 BKCreverse (fa_a:bat[:str,:oid])<-(b1:bat[:oid,:str])
    ga_a := algebra.sort(fa_a);	# 22 ALGhsort (ga_a:bat[:str,:oid])<-(fa_a:bat[:str,:oid])
    ha_a := bat.reverse(ga_a);	# 23 BKCreverse (ha_a:bat[:oid,:str])<-(ga_a:bat[:str,:oid])
    ia_a := io.print(ha_a);	# 24 IOprint_val (ia_a:void)<-(ha_a:bat[:oid,:str])
#	io.print("var b2 := bat(void,str);"); 	# 25  (_27:str)
    b2 := bat.new(nil:void,nil:str);	# 26 CMDBATnew (b2:bat[:void,:str])<-(_29:void)(_13:str)
#	io.print("b2.seqbase(oid(10));"); 	# 27  (_30:str)
    ja_a := calc.oid(10);	# 28 CALCint2oid (ja_a:oid)<-(_32:int)
    ka_a := bat.setSequenceBase(b2,ja_a);	# 29 BKCsetSequenceBase (ka_a:bat[:void,:str])<-(b2:bat[:void,:str])(ja_a:oid)
#	io.print("b2.reverse().sort().reverse().print();"); 	# 30  (_34:str)
    la_a := bat.reverse(b2);	# 31 BKCreverse (la_a:bat[:str,:void])<-(b2:bat[:void,:str])
    ma_a := algebra.sort(la_a);	# 32 ALGhsort (ma_a:bat[:str,:void])<-(la_a:bat[:str,:void])
    na_a := bat.reverse(ma_a);	# 33 BKCreverse (na_a:bat[:void,:str])<-(ma_a:bat[:str,:void])
    oa_a := io.print(na_a);	# 34 IOprint_val (oa_a:void)<-(na_a:bat[:void,:str])
#	io.print("b2.access(BAT_WRITE);"); 	# 35  (_39:str)
    pa_a := bat.setWriteMode(b2);	# 36 BKCsetWriteMode (pa_a:bat[:void,:str])<-(b2:bat[:void,:str])
#	io.print("b2.reverse().sort().reverse().print();"); 	# 37  (_34:str)
    qa_a := bat.reverse(b2);	# 38 BKCreverse (qa_a:bat[:str,:void])<-(b2:bat[:void,:str])
    ra_a := algebra.sort(qa_a);	# 39 ALGhsort (ra_a:bat[:str,:void])<-(qa_a:bat[:str,:void])
    sa_a := bat.reverse(ra_a);	# 40 BKCreverse (sa_a:bat[:void,:str])<-(ra_a:bat[:str,:void])
    ta_a := io.print(sa_a);	# 41 IOprint_val (ta_a:void)<-(sa_a:bat[:void,:str])
#	io.print("var b3 := mirror(b2);"); 	# 42  (_45:str)
    b3 := bat.mirror(b2);	# 43 BKCmirror (b3:bat[:void,:void])<-(b2:bat[:void,:str])
#	io.print("b3.print();"); 	# 44  (_47:str)
    ua_a := io.print(b3);	# 45 IOprint_val (ua_a:void)<-(b3:bat[:void,:void])
#	io.print("var b4 := b3.reverse().join(b2);"); 	# 46  (_49:str)
    va_a := bat.reverse(b3);	# 47 BKCreverse (va_a:bat[:void,:void])<-(b3:bat[:void,:void])
    b4 := algebra.join(va_a,b2);	# 48 ALGjoin (b4:bat[:void,:str])<-(va_a:bat[:void,:void])(b2:bat[:void,:str])
#	io.print("b4.print();"); 	# 49  (_52:str)
    wa_a := io.print(b4);	# 50 IOprint_val (wa_a:void)<-(b4:bat[:void,:str])
#	io.print("# next line produced an incorrect error \n"); 	# 51  (_54:str)
#	io.print("# ERROR: CMDsort: returned BAT has unexpected head.\n"); 	# 52  (_55:str)
    xa_a := bat.reverse(b4);	# 53 BKCreverse (xa_a:bat[:str,:void])<-(b4:bat[:void,:str])
    ya_a := algebra.sort(xa_a);	# 54 ALGhsort (ya_a:bat[:str,:void])<-(xa_a:bat[:str,:void])
    ab_a := bat.reverse(ya_a);	# 55 BKCreverse (ab_a:bat[:void,:str])<-(ya_a:bat[:str,:void])
    bb_a := io.print(ab_a);	# 56 IOprint_val (bb_a:void)<-(ab_a:bat[:void,:str])
#	io.print("#mini mil example\n"); 	# 57  (_60:str)
#	io.print("var b2 := bat(void,str);"); 	# 58  (_27:str)
    b2 := bat.new(nil:void,nil:str);	# 59 CMDBATnew (b2:bat[:void,:str])<-(_29:void)(_61:str)
#	io.print("b2.seqbase(oid(10));"); 	# 60  (_30:str)
    cb_a := calc.oid(10);	# 61 CALCint2oid (cb_a:oid)<-(_32:int)
    db_a := bat.setSequenceBase(b2,cb_a);	# 62 BKCsetSequenceBase (db_a:bat[:void,:str])<-(b2:bat[:void,:str])(cb_a:oid)
#	io.print("var b3 := mirror(b2);"); 	# 63  (_45:str)
    b3 := bat.mirror(b2);	# 64 BKCmirror (b3:bat[:void,:void])<-(b2:bat[:void,:str])
#	io.print("var b4 := b3.reverse().join(b2);"); 	# 65  (_49:str)
    eb_a := bat.reverse(b3);	# 66 BKCreverse (eb_a:bat[:void,:void])<-(b3:bat[:void,:void])
    b4 := algebra.join(eb_a,b2);	# 67 ALGjoin (b4:bat[:void,:str])<-(eb_a:bat[:void,:void])(b2:bat[:void,:str])
#	io.print("# next line produced an incorrect error \n"); 	# 68  (_54:str)
#	io.print("# ERROR: CMDsort: returned BAT has unexpected head.\n"); 	# 69  (_55:str)
    fb_a := bat.reverse(b4);	# 70 BKCreverse (fb_a:bat[:str,:void])<-(b4:bat[:void,:str])
    gb_a := algebra.sort(fb_a);	# 71 ALGhsort (gb_a:bat[:str,:void])<-(fb_a:bat[:str,:void])
    hb_a := bat.reverse(gb_a);	# 72 BKCreverse (hb_a:bat[:void,:str])<-(gb_a:bat[:str,:void])
    ib_a := io.print(hb_a);	# 73 IOprint_val (ib_a:void)<-(hb_a:bat[:void,:str])
#Identifer 'seqbase' mapped to 'bat.setSequenceBase' 	# 74  (_69:str)
end main;	# 75  

# 07:27:18 >  
# 07:27:18 >  Done.
# 07:27:18 >  

