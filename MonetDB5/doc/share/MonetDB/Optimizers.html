<html lang="en">
<head>
<title>Optimizers - Untitled</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="Untitled">
<meta name="generator" content="makeinfo 4.8">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="Optimizer-landscape.html#Optimizer-landscape" title="Optimizer landscape">
<link rel="prev" href="Optimizer-landscape.html#Optimizer-landscape" title="Optimizer landscape">
<link rel="next" href="Optimizer-Dependencies.html#Optimizer-Dependencies" title="Optimizer Dependencies">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
This file documents the MonetDB Version 5.0 Reference Manual

Last updated: June 5, 2006

     Copyright (C) 2000-2006 CWI

     Permission is granted to make and distribute verbatim
     copies of this manual provided the copyright notice and
     this permission notice are preserved on all copies.-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
body { 
    margin: 0px;
    padding: 0px;
}
a,a:visited {
	color: #336633;
}
a:hover {
	color: #003300;
}

p,body {
    font-family: Verdana, Arial, Helvetica, sans-serif;
    text-align: justify;
    font-size: 10pt;
}

h1 {
    font-family: Verdana, Arial, Helvetica, sans-serif;
    font-size: 14pt;
    font-style: bold;
	text-align: left;
}

td,th {
    font-family: Verdana, Arial, Helvetica, sans-serif;
    font-size: 10pt;
}

div.banner {
	padding: 5px 0px 0px 5px; 
}

div.banner img {
	border: 0px;
	text-decoration: none;
}

div.topmenu {
	margin-top: -20px;
	margin-left: 166px;
	padding: 8px 5px 5px 5px;
	font-size: 8pt;
	background-color: #A9CC99;
}

div.topmenu-bottom {
	margin-top: -4px;
	margin-left: 166px;
	padding: 2px 5px;
	background-color: #BCD2ED; 
}

div.topmenu a {
	padding: 4px 5px 1px 5px;
	text-decoration: none; 
}

div.topmenu a:focus {
	background-color: #6699CC; 
}

div.topmenu a:hover {
	background-color: #5662A0; 
}

/*
span.current {
}
*/

div.topmenu span.current a {
	color: #000000;
	background-color: #BCD2ED; 
}

/* this should be inherited IMHO, but it doesn't so we just redefine it */
div.topmenu span.current a:hover {
	color: #336633;
	background-color: #BCD2ED; 
}

/*
span.submenu {
}
*/

div.topmenu span.submenu a {
	background-color: #CBEEBB;
}

/* this should be inherited IMHO, but it doesn't so we just redefine it */
div.topmenu span.submenu a:hover {
	background-color: #9FB0DB; 
}

div.topmenu span.button {
	margin: 0px 0px 0px 10px;
}

div.topmenu span.button a {
	padding: 5px 6px 1px 6px;
	color: #333333;
	background-color: #FFAC37;
}

div.topmenu span.button a:hover {
	color: #FFFFFF;
}

div.content {
	padding: 5px;
	margin-left: 166px;
	margin-right: 12%;
}

div.header {
	padding: 5px;
	margin-left: 166px;
	margin-right: 12%;
}


div.sidebar-a {
	float: left;
	width: 156px;
	padding: 5px;
	font-size: 8pt;
}

div.sidebar-b { 
	float: right;
	width: 146px;
	margin: 0px 0px 0px 5px;
	padding: 5px;
	font-size: 8pt;
}

div.footer-a {
	float: left;
	width: 156px;
	margin: 5px 0px 0px 0px;
	padding: 5px;
	font-size: 7pt;
	background-color: #CBEEBB;
}

div.footer-a a {
	margin: 5px;
	text-decoration: none; 
}

div.footer-b {
	margin: 5px 0px 0px 0px;
	padding: 5px;
	background-color: #A9CC99;
	font-size: 7pt;
}

div.footer-b a {
	margin: 5px;
	padding: 2px 3px;
	text-decoration: none; 
}
div.footer-b a:focus {
	background-color: #6699CC; 
}
div.footer-b a:hover {
	color: #FFFFFF;
	background-color: #5662A0; 
}
div.footer-b img {
	border: 0px;
	vertical-align: bottom;
	text-decoration: none; 
}

div.news {
	border: 1px solid #666699;
	background-color: #E7E7E7; 
	margin: 3px 0px;
	padding: 5px 5px 5px 5px;
}

div.news li {
	list-style: square;
}

div.submenu-b {
	border: 1px solid #666699;
	background-color: #CBEEBB;
	margin: 3px 0px;
	padding: 5px 5px 5px 5px;
}

div.submenu-b a {
	text-decoration: none; 
	display: block;
	padding: 1px 2px;
	color: #000000;
	background-color: #A9CC99;
}

div.submenu-b a:hover {
	background-color: #BCD2ED; 
}

div.submenu-b ul {
	padding: 1px 0px 1px 0px;
	margin: 0px;
}

div.submenu-b li {
	list-style: none;
	padding: 1px 0px 0px 6px;
}

div.submenu {
	border: 1px solid #666699;
	background-color: #9FB0DB; 
	margin: 3px 0px;
	padding: 5px 5px 5px 5px;
}

div.submenu a {
	text-decoration: none; 
	display: block;
	padding: 1px 2px;
	_width: 100%;
}

div.submenu ul {
	padding: 1px 0px 1px 0px;
	margin: 0px;
}

div.submenu li {
	list-style: none;
	padding: 1px 0px 0px 6px;
}

div.submenu span.submenu a {
	color: #000000;
	background-color: #BCD2ED; 
}

/* this should be inherited IMHO, but it doesn't so we just redefine it */
div.submenu span.submenu a:hover {
	background-color: #A9CC99;
}

div.submenu span.current a {
	background-color: #CBEEBB;
}

/* this should be inherited IMHO, but it doesn't so we just redefine it */
div.submenu span.current a:hover {
	background-color: #CBEEBB;
}

pre.code {
	border: 1px solid Black;
	padding: 4px;
	font-family: monospace;
}
.authors {
	font-size: smaller;
	font-style: italic;
}
--></style>
</head>
<body>
<div class="node">
<p>
<a name="Optimizers"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="Optimizer-Dependencies.html#Optimizer-Dependencies">Optimizer Dependencies</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="Optimizer-landscape.html#Optimizer-landscape">Optimizer landscape</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="Optimizer-landscape.html#Optimizer-landscape">Optimizer landscape</a>
<hr>
</div>

<h3 class="section">12.1 Optimizers</h3>

<p>A query optimizer is often a large and complex piece of code, which
enumerates alternative evaluation plans from which 'the best' plan
is selected for evaluation. Limited progress has been made sofar to
decompose the optimizer into (orthogonal) components, because it is
a common believe in research that a holistic view on the problem is
a prerequisite to find the best plan. 
Conversely, commercial optimizers use a cost-model driven approach, which
explores part of the space using a limited (up to 300) rewriting rules.

   <p>Our hypothesis is that query optimization should be realized with
a collection of query optimizer transformers (QOT),
each dedicated to a specific task. 
Furthermore, they are assembled in scenarios to support specific application
domains or achieve a desired behavior. Such scenarios are selected on a
session basis, a query basis, or dynamically at
runtime; they are part of the query plan.

   <p>The query transformer list below is under consideration for development. 
For each we consider its goal, approach, and expected impact. 
Moreover, the minimal prerequisites identify the essential optimizers that
should have done their work already. For example, it doesn;t make sense
to perform a static evaluation unless you have already propagated the
constants using Alias Removal.

   <p><em>Scalar expressions (SXoptimizer)</em>
Goal: to remove scalar expressions which need be evaluated once during the
query lifetime. 
Rationale: static expressions appear
when variables used denote literal constants (e.g. 1+1),
when catalog information can be merged with the plan (e.g. max(B.salary)),
when session variables are used which are initialized once (e.g. user()). 
Early evaluation aids subsequent optimization. 
Approach: inspect all instructions to locate static expressions. 
Whether they should be removed depends on the expected re-use,
which in most cases call for an explicit request upon query registration
to do so. The result of a static evaluation provides a ground for AR. 
Impact: relevant for stored queries (MAL functions)
Prereq: AR, CX

   <p><em>Relational Expression Optimizer (RXoptimizer)</em>
Goal: to evaluate a relational plan using properties of BATs,
such as being empty or forming an aligned group. 
These optimizations assume that the code generator can detect properties
while compiling e.g. an SQL query. 
Impact: high
Prereq:

   <p><em>Alias Removal (ARoptimizer)</em>
Goal: to reduce the number of  variables referenceing the same value,
thereby reducing the analysis complexity. 
Rationale: query transformations often result in replacing
the right-hand side expression with a result variable. This pollutes the
code block with simple assignments e.g. V:=T. Within the descendant flow the
occurrence of V could be replaced by T, provided V is never assigned a new
value. 
Approach: literal constants within a MAL block are already recognized and
replaced by a single variable. 
Impact: medium

   <p><em>Common Expression Optimizer (CXoptimizer)</em>
Goal: to reduce the amount of work by avoiding calculation of the same
operation twice. 
Rationale: to simplify code generation for front-ends, they do not have
to remember the subexpressions already evaluated. It is much easier to
detect at the MAL level. 
Approach: simply walk through the instruction sequence and locate identical
patterns.  (Enhance is with semantic equivalent instructions)
Impact: High
Prereq: AR

   <p><em>Access Mode Optimizer (AMoptimizer)</em>
Goal: the default access mode for BATs is readonly. 
When updates are needed, it is switched to WriteMode,
which needs to be done only once. 
Approach: remove duplicate calls
Impact: low

   <p><em>Dead Code Removal (DCoptimizer)</em>
Goal: to remove all instructions whose result is not used
Rationale: due to sloppy coding or alternative execution paths
dead code may appear. Als XML Pathfinder is expected to produce
a large number of simple assignments. 
Approach: Every instruction should produce a value used somewhere else. 
Impact: low

   <p><em>Heuristic Rule Rewrites (HRoptimizer)</em>
Goal: to reduce the volume as quick as possible. 
Rationale: most queries are focussed on a small part of the database. 
To avoid carrying too many intermediates, the selection should be performed as
early as possible in the process. This assumes that selectivity factors are
known upfront, which in turn depends on histogram of the value distribution. 
Approach: locate selections and push them back/forth through the flow graph. 
Impact: high

   <p><em>Join Path Optimizer (JPoptimizer)</em>
Goal: to reduce the volume produced by a join sequence
Rationale: join paths are potentially expensive operations. Ideally the join
path is evaluated starting at the smallest component, so as to reduce the
size of the intermediate results. 
Approach: to successfully reduce the volume we need to estimate their processing
cost. This calls for statistics over the value distribution, in particular,
correlation histograms. If statistics are not available upfront, we have to
restore to an incremental algorithm, which decides on the steps using the
size of the relations. 
Impact: high

   <p><em>Operator Sort (OSoptimizer)</em>
Goal: to sort the dataflow graph in such a way as to reduce the
cost, or to assure locality of access for operands. 
Rationale: A simple optimizer is to order the instructions for
execution by permutation of the query components
Approach:
Impact:

   <p><em>Singleton Set (SSoptimizer)</em>
Goal: to replace sets that are known to produce precisely
one tuple. 
Rationale: Singleton sets can be represented by value pairs in the
MAL program, which reduces to a scalar expression. 
Approach: Identify a set variable for replacement. 
Impact:

   <p><em>Result Cacher (RCoptimizer)</em>
Goal: to reduce the processing cost by keeping track of expensive to
compute intermediate results
Rationale:
Approach: result caching becomes active after an instruction has been
evaluated. The result can be cached as long as its underlying operands
remain unchanged. Result caching can be made transparent to the user, but
affects the other QOTs
Impact: high

   <p><em>Vector Execution (VEoptimizer)</em>
Goal: to rewrite a query to use a cache-optimal vector implementation
Rationale: processing in the cache is by far the best you can get. 
However, the operands may far exceed the cache size and should be broken
into pieces followed by a staged execution of the fragments involved. 
Approach: replace the query plan with fragment streamers
Impact:

   <p><em>Staged Execution (SEoptimizer)</em>
Goal: to split a query plan into a number of steps, such that the first
response set is delivered as quickly as possible. The remainder is only
produced upon request. 
Rationale: interactive queries call for quick response and an indication
of the processing time involved to run it too completion. 
Approach: staged execution can be realized using a fragmentation scheme
over the database, e.g. each table is replaced by a union of fragments. 
This fragmentation could be determined upfront by the user or is derived
from the query and database statistics. 
impact: high

   <p><em>Code Parallizer (CPoptimizer)</em>
Goal: to exploit parallel IO and cpu processing in both SMP and MPP settings. 
Rationale: throwing more resources to solve a complex query helps, provided
it is easy to determine that parallel processing recovers the administrative
overhead
Approach: every flow path segment can be handled by an independent process thread. 
Impact: high

   <p><em>Query Evaluation Maps (QEMoptimizer)</em>
Goal: to avoid touching any tuple that is not relevant for answering a query. 
Rationale: the majority of work in solving a query is to disgard tuples of
no interest and to find correlated tuples through join conditions. Ideally,
the database learns these properties over time and re-organizes (or builts
a map) to replace disgarding by map lookup. 
Approach: piggyback selection and joins as database fragmentation instructions
Impact: high

   <p><em>MAL Compiler (MCcompiler) (tactics)</em>
Goal: to avoid interpretation of functional expressions
Rationale: interpretation of arithmetic expressions with an interpreter
is always expensive. Replacing a complex arithmetic expressin with a
simple dynamically compiled C-functions often pays off. Especially for
cached (MAL) queries
Approach:
Impact: high

   <p><em>Dynamic Query Scheduler (DQscheduler) (tactics)</em>
Goal: to organize the work in a way so as to optimize resource usage
Rationale: straight interpretation of a query plan may not lead to the best
use of the underlying resources. For example, the content of the runtime
cache may provide an opportunity to safe time by accessing a cached source
Approach: query scheduling is the last step before a relation algebra interpreter
takes over control. The scheduling step involves a re-ordering of the
instructions within the boundaries imposed by the flow graph. 
impact: medium

   <p><em>Aggregate Groups (AGoptimizer)</em>
Goal: to reduce the cost of computing aggregate expressions over times
Rationale: many of our applications call for calculation of aggregates
over dynamically defined groupings. They call for lengtly scans and it pays
to piggyback all aggregate calculates, leaving their result in the cache for
later consumption (eg the optimizers)
Approach:
Impact: High

   <p><em>Data Cube optimizer (DCoptimizer)</em>
Goal: to recognize data cube operations
Rationale:
Approach:
Impact:

   <p><em>Demand Driven Interpreter (DDoptimizer) (tactics)</em>
Goal: to use the best interpreter and libraries geared at the task at hand
Rationale: Interpretation of a query plan can be based on different
computational models. A demand driven interpretation starts at the intended
output and 'walks' backward through the flow graph to collect the pieces,
possibly in a pipelined fashion. (Vulcano model)
Approach: merely calls for a different implementation of the core operators
Impact: high

   <p><em>Iterator Strength Reduction (SRoptimizer)</em>
Goal: to reduce the cost of iterator execution by moving instructions
out of the loop. 
Rationale: although iteration at the MAL level should be avoided due to
the inherent low performance compared to built-in operators, it is not
forbidden. In that case we should confine the iterator block to the minimal
work needed. 
Approach: inspect the flowgraph for each iterator and move instructions around. 
Impact: low

   <p><em>Accumulator Evaliations (AEoptimizer)</em>
Goal: to replace operators with cheaper ones. 
Rationale: based on the actual state of the computation and the richness of
the supporting libraries there may exists alternative routes to solve a query. 
Approach: Operator rewriting depends on properties. No general technique. 
The first implementation looks at calculator expressions such as they
appear frequently in the RAM compiler. 
Impact: high
Prerequisite: should be called after CXoptimizer to avoid clashes.

   <p><em>Code Inliner (CIoptimizer)</em>
Goal: to reduce the calling depth of the interpreter and to obtain
a better starting point for code squeezing
Rationale: substitution of code blocks (or macro expansion) leads to
longer linear code sequences. This provides opportunities for squeezing. 
Moreover, at runtime building and managing a stackframe is rather expensive. 
This should be avoided for functions called repeatedly. 
Approach: called explicity to inline a module (or symbol)
Impact: medium

   <p><em>Code Outliner (COoptimizer)</em>
Goal: to reduce the program size by replacing a group with a single
instruction
Rationale: inverse macro expansion leads to
shorter linear code sequences. This provides opportunities for less interpreter
overhead, and to optimize complex, but repetative instruction sequences
with a single hardwired call
Approach: called explicitly to outline a module (or symbol)
Impact: medium

   <p><em>Garbage Collector (GCoptimizer)</em>
Goal: to release resources as quickly as possible
Rationale: BATs referenced from a MAL program keep resources locked. 
Approach: In cooperation with a resource scheduler we should identify those
that can be released quickly. It requires a forced gargabe collection call
at the end of the BAT's lifespan. 
Impact: large

   <p><em>Foreign Key replacements (FKoptimizer)</em>
Goal: to improve multi-attribute joins over foreign key constraints
Rationale: the code produced by the SQL frontend involves foreign key
constraints, which provides many opportunities for speedy code. 
Impact: large

   </body></html>

