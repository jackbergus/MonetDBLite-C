@section Prepared Queries.
In the new release of MonetDB/XQuery, support for 
@url{http://www.w3.org/TR/xquery-semantics/#id-query-prolog,modules}
has been added. Modules help XQuery users to structure their query code, 
but are also the instrument for MonetDB/XQuery to implement @strong{canned queries}.

@subsection XQuery Modules

The below shows a simple example of an XQuery module @code{test.xq},
that just defines a single function @code{countDescendants("uri")}:

@verbatim
  module namespace test = "http://monetdb.cwi.nl/XQuery/Documentation/Language/Modules/";
  
  declare function test:countDescendants($doc as xs:string) as xs:integer
  {
    count(doc($doc)//*)
  };
@end verbatim

You may type @code{import module} inside an XQuery query, 
after which you can use the functions (and variables) defined in it:

@verbatim
  import module namespace test = "http://monetdb.cwi.nl/XQuery/Documentation/Language/Modules/"
                              at "http://monetdb.cwi.nl/XQuery/Documentation/Language/Modules/test.xq";
  test:countDescendants("http://monetdb.cwi.nl/xmark/auctions.xml")
@end verbatim

which basically does the same as the ad-hoc @url{q.xq,query},
namely counting how many nodes the @url{../../../Benchmark/,XMark}
document has:

@verbatim
  count(doc("http://monetdb.cwi.nl/xmark/auctions.xml")//*)
@end verbatim

@strong{Warning:} while highly similar, the module feature as implemented
by MonetDB/XQuery deviates in the following respects from the 
@url{http://www.w3.org/TR/xquery-semantics/#id-query-prolog,XQuery formal semantics}:
@itemize
@item You @emph{must} give a location hint in the "import module" statement.
     Each file hinted there will be loaded as a module. It has to
     match the namespace given in the "import module" statement,
     though.

@item Modules cannot see variables declared in other modules,
     regardless if they imported the module theirselves or not.
     A module is not allowed, though, to override variable
     declarations of other modules (conforming to the specs).

@item Modules will see functions defined in other modules. They are
     not allowed to override them, though.

@item All modules and the main query share the same type definitions.
     So modules will see XML Schema definitions imported by the main
     query. (see also below for XML Schema import)

@item Pathfinder does allow cyclic importing of modules, regardless
     of their namespace.

@item The XQuery specifications state that two module import
     statements that use the same target namespace should produce an
     error. This is not the case in MonetDB/XQuery: the module will be
     loaded once, but its functions and variables will be available
     under both namespace identifiers.
@end itemize


@subsection Prepared Queries using Functions from Modules

In SQL databases, interfaces like ODBC or JDBC allow to prepare @strong{prepared queries}
for faster execution of frequently used query patterns. For example, web-sites powered 
by a database usually generate a @strong{fixed} set of queries to that database; each page 
fires off the same (set of) queries, possibly though with different parameters 
(that contain e.g. a customer identity or cookie). SQL systems can @strong{prepare} for 
such prepared queries in advance, such that when a web-page is served out and the query 
result is needed quick, only the actual parameters need to be fed (@strong{bound}) into
a ready-to-run query (saving query parsing and optimization time, which is unavoidable
for ad-hoc queries).

Such prepared queries can be seen as a queries whose result is a function of a number 
of parameters.  MonetDB/XQuery takes this definition literally in its implementation 
of prepared queries:

@strong{prepared query = XQuery function}

XQuery modules allow
to define XQuery functions (and variables, but that's beside the point now). So:
@itemize
@item if a XQuery consists of only a function call, and  
@item that function is defined not inside the query itself, but inside a module (so there's 
     an @code{import module} statement preceding the function call), and
@item the query parameters are simple constants (atomic values of type
@code{xs:integer}, @code{xs:decimal}, @code{xs:double}, 
or @code{xs:string})
@end itemize
then MonetDB/XQuery will execute this query much faster, making use
of a @strong{prepared query plan}.

To put the caching mechanism to the test, first import the XMark document
into the database by typing in the MonetDB console:

@verbatim
  mil&gt; shred_doc("http://monetdb.cwi.nl/xmark/auctions.xml",
                 "http://monetdb.cwi.nl/xmark/auctions.xml");
@end verbatim

then run the queries @url{q.xq,q.xq} (standard), @url{m.xq,m.xq} (function from module)
while monitoring elapsed time:

@verbatim
  $ MapiClient -lx -T q.xq
  1729
  
  Trans      18.000 msec
  Shred       0.000 msec
  Query       5.000 msec
  Print       0.000 msec
  Timer      24.436 msec
  
  $ MapiClient -lx -T m.xq
  1729
  
  Trans       0.000 msec
  Shred       0.000 msec
  Query       2.000 msec
  Print       0.000 msec
  Timer       2.778 msec
@end verbatim

We see that the latter "prepared" query (that uses a function defined in a module) performs 
almost @strong{ten times} faster than the ad-hoc query! The translation time
has completely disappeared for the prepared query @code{m.xq}
and the query execution also improved by a factor of two.

This performance trend was confirmed on the @url{_ROOTDIR_/XQuery/Benchmark/,XMark}
benchmark.  We developed 
@url{_ROOTDIR_/XQuery/Benchmark/xmark/mod/,prepared queries} for the
benchmark, which produced a factor 10 (small 116KB documents)
to 2 (larger 10MB documents) performance increase over the ad-hoc 
benchmark queries. Obviously, complex queries or queries
on huge (>=GB) documents, which take many seconds to run anyway, 
do not benefit from prepared query mechanism  (but neither are hindered by it).

As a general rule, the benefit of canned queries is larger for short-running 
than for long-running queries, because for short-running queries the XQuery
translation and optimization time weighs in more heavily. We especially
recommend the use of canned queries when MonetDB/XQuery is used to power
web-sites.
