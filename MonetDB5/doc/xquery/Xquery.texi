MonetDB/XQuery supports a wide range of the built-in functions described in
the <a href='http://www.w3.org/'>W3C</a> specifications. Here is a list of
functions that MonetDB/XQuery currently supports. Some functions are not yet
implemented, while others probably won't be implemented in the near future.</p>


@multitable @columnfractions 0.2 0.8
@item yes
@tab @strong{Order
Awareness}<br/>MonetDB/XQuery correctly implements document and sequence
orders, as well as node identity. 
@item yes
@tab @strong{XPath Location Steps}
@item
@tab
MonetDB/XQuery implements
XQuery's @emph{full axis feature}, i.e., we support all 12 XPath axes. Note,
however, that we do not support node tests on @emph{type annotations} as
introduced with newer XQuery drafts.

@item yes
@tab @strong{FLWOR clauses}<br/>We support
FLWOR clauses with full generality and arbitrary nesting, including positional
variables. @item yes
@tab @strong{Arithmetics,
Logics, Conditionals}
We support arithmetics, logics (@code{and},
@code{or}), and conditionals (@code{some}/@code{every},
@code{if-then-else}).

@item partly 
@tab @strong{Node Construction}
We fully support element, attribute, and text constructors, at arbitrary nesting
depth. We have not implemented document, comment and processing-instruction
constructors, yet.
@item yes 
@tab @strong{Namespaces}
MonetDB/XQuery fully supports namespaces.

@item yes
@tab @strong{Schema Import}
MonetDB/XQuery implements the @emph{Schema Import} feature.
This is not well tested, though. 

@item partly 
@tab @strong{Module Import}
MonetDB/XQuery implements the @emph{Module Import} feature,
however its handling of recursive module imports is non-standard.
Most importantly, the W3C formal semantics specify that if a query (or a module) 
imports a module, only the variables and functions directly defined by that 
module will become visible to it. In MonetDB/XQuery, though, @strong{all} namespaces, 
variables and functions that were imported by that module, will become visible.
Thus MonetDB/XQuery may encounter clashes (leading to errors), e.g. in namespace
identifiers, or funtion signature or variable names, that should not occur according
to the formal semantics.

@item partly 
@tab @strong{XQuery Built-In Functions}
We support a large
set of built-in functions, as listed in our <a href='../Functions'>Function
Library</a>. We currently do @emph{not} support functions that involve
specific collation orders, as well as functions that involve date/time
conversions.

@item yes
@tab @strong{User-Defined Functions}
MonetDB/XQuery correctly deals with user-defined functions,
with or without recursion. Current development efforts will lead to an even
more efficient implementation that completely eliminates function call
overhead. 
@item partly 
@tab @strong{Simple Types}
We currently support the XQuery simple types <tt>xs:integer</tt>,
<tt>xs:decimal</tt>, <tt>xs:double</tt>, <tt>xs:string</tt>, and
<tt>xs:boolean</tt>. Note that we currently implement <tt>xs:decimal</tt> as a
floating point number which may lead to rounding errors.

@item yes
@tab @strong{Static Typing}
MonetDB/XQuery supports the @emph{Static Typing} feature. (For
experts: we actually support @emph{structural} typing here, using Antimirov's
algorithm.) 
@item no
@tab @strong{Dynamic Typing}
Our implementation of XQuery's @code{typeswitch} clause is
still very limited. We currently allow type tests that can be decided at
compile time, and tests for @emph{atomic} types. Note that the lack of
dynamic typing may also limit XQuery's casting functionalities.

@item no
@tab @strong{Validation}<br/>MonetDB/XQuery
does not yet support validation, though work is underway to close that
gap. 
@end multitable
