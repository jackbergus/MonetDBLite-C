#!/bin/bash

# mkmonetweb - creates a MonetDB website look from texi generated sources
#
# The main work done in this script is creating an index of all the
# pages in order to generate a menu out of them.  For this to work,
# first dependency indices for parent and child steps have to be
# generated.  The first is provided by the html output of makeinfo, the
# latter has to be derived, which takes a fair amount of CPU cycles.
#
# Fabian Groffen <fabian@cwi.nl> - 2006-07-19
#  added support for multiple "manuals"
# Fabian Groffen <fabian@cwi.nl> - 2006-07-10
#  hardcode top level node name to be called "Documentation"
# Fabian Groffen <fabian@cwi.nl> - 2006-07-03
#  menu generation is now based on a "template" file which should
#  contain _M5_MANUAL_HOOK_START_ and _M5_MANUAL_HOOK_END_ markers.
#  This allows the generated menu to be embedded into another.  A
#  title.txt is now generated with titles from the index.html file.
# Fabian Groffen <fabian@cwi.nl> - 2006-06-30
#  initial version


# Creates an index over the files containing parent, prev and next
# steps, plus a title
# @ create_index_scan
create_index_scan() {
	rm ${indexfile}.scan >& /dev/null
	for file in ${dir}/doc/share/tmp/${mtype}/MonetDB/*.html;
	do
		for type in up prev next;
		do
			tmp=`grep -m1 '<link rel="'${type}'"' "$file" | \
				egrep -o 'href="[^#"]+' | \
				cut -c 7-`
			# cheat some to get a tree with a root
			if [ "$type" = "up" ];
			then
				if [ "$tmp" = "../index.html" ];
				then
					tmp=""
				elif [ -z "$tmp" ];
				then
					tmp="index.html"
				fi
			fi
			echo "`basename "${file}"`:$type=${tmp}" >> ${indexfile}.scan
		done
		tmp=`egrep -m1 '<title>.*</title>' "$file" | \
			sed -e 's:^<title>::' \
				-e 's: - MonetDB.* Reference Manual</title>$::' \
				-e 's:</title>$::'`
		[ "`basename ${file}`" = "index.html" ] && tmp="Documentation"
		echo "`basename "${file}"`:title=${tmp}" >> ${indexfile}.scan
	done
}

# Creates the children index by recursively traversing the tree of
# files
# @ create_index_traverse
create_index_traverse() {
	rm ${indexfile}.children >& /dev/null
	create_index_scan
	do_traverse "index.html" "o"
}

# Recursive helper function to create the children index
# @ do_traverse parentfile parentdepth
do_traverse() {
	local c=`generate_children $1`
	echo "$1:$2=$c" >> ${indexfile}.children
	for child in $c;
	do
		do_traverse $child "$2+"
	done
}

# Cleans up the given string by removing overdone spaces which confuse
# for instance the -z operation of `test`
# @ do_cleanup string
do_cleanup() {
	local c=""
	for m in $*;
	do
		c="$c $m"
	done
	echo $c | cut -c1-
}

# Returns all children for the given page in the right order
# @ generate_children file
generate_children() {
	local c=`egrep "up=$1\$" ${indexfile}.scan | cut -d':' -f1 | xargs echo`
	local s=""
	local p=$1
	# now order the children appropriately by traversing the (sub) tree
	# and copying the child over when found
	while [ ! -z "$p" ];
	do
		p=`get_entry $p next`
		for m in $c;
		do
			if [ "$m" = "$p" ];
			then
				s="$s $m"
				# remove entry from original children list for performance
				c=${c/$m/}
				break
			fi
		done
	done

	c=`do_cleanup $c`

	[ ! -z "$c" ] && echo "orphans: $c" > /dev/stderr
	echo $s
}

# Sequential Scan operator for a point query :)
# Luckily our OS has FileSystem cache
# @ get_entry file {up,prev,next}
get_entry() {
	egrep -m1 "^$1:$2=" ${indexfile}.scan | cut -d'=' -f2
}

# Returns the parent for the given page
# @ get_parent file
get_parent() {
	get_entry $1 up
}

# Returns the children for the given page
# @ get_children file
get_children() {
	do_cleanup `egrep -m1 "^$1:o[\+]*=" ${indexfile}.children | \
		cut -d'=' -f2`
}

# Returns the depth of the given page
# @ get_depth file
get_depth() {
	do_cleanup `egrep -m1 "^$1:o[\+]*=" ${indexfile}.children | \
		cut -d':' -f2 | \
		cut -d'=' -f1`
}

# Copies over all html files and inserts the general layout.  In
# particular the menu for each page is inserted, which requires the
# scan and children indices.
# @ transform_files targetdir monetwebroot
transform_files() {
	if [ -z "$1" ] || [ -z "$2" ] | [ -z "$3" ];
	then
		echo "usage: transform_files: targetdir monetwebroot menuprefixfile" > /dev/stderr
		echo "   targetdir: where to store the generated files" > /dev/stderr
		echo "   monetwebroot: where to fetch the index.html template file from" > /dev/stderr
		echo "   menuprefixfile: template file which should include _M5_MANUAL_HOOK_START_ and _M5_MANUAL_HOOK_END_ markers" > /dev/stderr
		exit -1
	fi

	mkdir -p "$1" >& /dev/null
	for file in ${dir}/doc/share/tmp/${mtype}/MonetDB/*.html;
	do
		f=`basename $file`
		local title=`get_entry $f title`
		local menu=`generate_menu $f "" "" true $3`

		# remove target file if already exists before we start
		rm -f "$1/$f" >& /dev/null
		
		# We use awk here, because with sed we would have to ultimately
		# escape the replacement content...
		awk \
			-v title="$title" \
			-v menu="$menu" \
			'
		BEGIN { doprint = 1; }
		/<div class="header">/,/<\/div>/ { doprint = 0; }
		{
			gsub(/_SUBMENU_/, menu, $0);
			gsub(/<!--#include virtual="_ROOTDIR_\/_SUBDIR_\/title.shtml" -->/,
				title, $0);
			gsub(/<!--#include virtual="_ROOTDIR_\/_TOPMENU_\/topmenu.shtml" -->/,
				"<!--#include virtual=\"_ROOTDIR_/topmenu.shtml\" -->", $0);
			if (/<!--#include virtual="_ROOTDIR_\/_SUBDIR_\/content.shtml" -->/) {
				exit;
			}
			if (doprint == 1) {
				print $0;
			}
			doprint = 1;
		}
		' "$2/index.html" > "$1/$f"
		# extract the real content, and store it
		awk '
		BEGIN { doprint = 1; }
		/<div class="node">/,/<\/div>/ { doprint = 0; }
		/<body>/,/<\/body>/ { if (doprint == 1) { print $0; } doprint =	1; }
		' $file | tail -n+2 | head -n-1 >> "$1/$f"
		# We use awk again to put back the rest of the page
		awk \
			-v title="$title" \
			-v menu="$menu" \
			'
		/<div class="header">/,/<\/div>/ { doprint = 0; }
		/<!--#include virtual="_ROOTDIR_\/_SUBDIR_\/content.shtml" -->/,EOF {
			gsub(/_SUBMENU_/, menu, $0);
			gsub(/<!--#include virtual="_ROOTDIR_\/_SUBDIR_\/title.shtml" -->/,
				title, $0);
			gsub(/<!--#include virtual="_ROOTDIR_\/_TOPMENU_\/topmenu.shtml" -->/,
				"<!--#include virtual=\"_ROOTDIR_/topmenu.shtml\" -->", $0);
			if (doprint == 1) {
				print $0;
			}
			doprint = 1;
		}
		' "$2/index.html" >> "$1/$f"
	done

	# Finally write title.txt with the right content
	rm -f "$1/title.txt" >& /dev/null
	local title="`get_entry index.html title`"
	echo $title >> "$1/title.txt"
	echo $title >> "$1/title.txt"
}

# Generates the menu for the given file.  The menu is recursively
# generated starting from the desired level, then traversing up to the
# root, expanding all levels on that route.  The given template file
# is processed such that _M5_MANUAL_HOOK_ is replaced with menu code.
# @ generate_menu file child code selected templatefile
generate_menu() {
	local title="`get_entry $1 title`"
	local code=""

	[ -z "$4" ] && code=${code}"<li><span class=\"submenu\">"
	[ -z "$4" ] || code=${code}"<li><span class=\"current\">"
	code=${code}"<a href=\"$1\" title=\"$title\">$title</a>"
	code=${code}"</span>"

	local c=`get_children $1`
	[ -z "$c" ] || code=${code}"<ul>"
	for m in $c;
	do
		if [ "$m" = "$2" ];
		then
			code=${code}"$3"
			continue
		else
			title="`get_entry $m title`"
			code=${code}"<li><span class=\"submenu\">"
			code=${code}"<a href=\"$m\" title=\"$title\">$title</a>"
			code=${code}"</span></li>"
		fi
	done
	[ -z "$c" ] || code=${code}"</ul>"

	code=${code}"</li>"

	local p=`get_parent $1`
	if [ ! -z "$p" ];
	then
		generate_menu $p $1 "$code" "" $5
	else
		awk -v menu="$code" '
		BEGIN {
			doprint = 1;
			hasprintedmenu = 0;
		}
		/_M5_MANUAL_HOOK_START_/,/_M5_MANUAL_HOOK_END_/ {
			doprint = 0;
			if (hasprintedmenu == 0) {
				print menu;
				hasprintedmenu = 1;
			}
		}
		{
			if (doprint) {
				print $0;
			}
			doprint = 1;	
		}' "$5"
	fi
}

if [ -z "$3" ];
then
	echo "$0: please tell me that to do (yes, just read the script)" > /dev/stderr
	exit -1
fi

dir=$1
mtype=$2
indexfile=${dir}/doc/share/tmp/${mtype}/monetwebmenu.index

case $3 in
	scan)
		create_index_scan
	;;
	traverse)
		create_index_traverse
	;;
	transform)
		transform_files $4 $5 $6
	;;
	*)
		echo "I have no clue what $3 is supposed to do!" > /dev/stderr
		exit -1
	;;
esac

# vim:set ts=4 sw=4 noexpandtab:
