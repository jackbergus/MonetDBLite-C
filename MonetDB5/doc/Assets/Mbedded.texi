@chapter Embedded MonetDB
The Embedded MonetDB version is optimized for running on small board computers
as a database back-end for a single client.
It is of particular interest if you need database functionality within
a limited application setting, e.g a self-contained database distributed
as part of the application.
Within this context, much of the code to facilitate and protect
concurrent use of the kernel can be disabled. For example,
the communication overhead of client-server TCP-IP interaction is removed.
Moreover, locking of critical resources in the kernel is not needed anymore,
which results in significant performance improvements.

The approach taken is to wrap a server such that the interaction
between client code and server can still follow the Mapi protocol.
It leads to a C-program with calls to the Mapi library routines,
which provides some protection against havoq behaviour.
From a programming view, it differs from a client-server application in
the startup and (implicit) termination.

You normally only have to change the call @code{mapi_connect()} into
@code{embedded_sql()} (or @code{embedded_mal()}). It requires an
optional argument list to refine the environment variables used by the server.
In combination with the header file @code{embeddedclient.h}
it provides the basis to compile and link the program.

@c The primary host language is C. Embedded versions for other languages are under development.

The behavior of an embedded SQL program can be simulated with
a server started as follows:
@example
mserver5 --set embedded=yes --dbinit="include sql;" &
@end example

As a result, the server starts in 'daemon' mode,
loads the SQL support library, and waits for a connection.
Only one connection is permitted.

@menu
* A Simple Example::
* Configuration Parameters::
* Embedded Limitations::
@end menu

@node A Simple Example, Configuration Parameters, Embedded MonetDB, Embedded MonetDB
@section Mbedded Example
A minimalistic embedded application is shown below. It creates
a temporary table in the database, fills it, and retrieves the
records for some statistics gathering.

The key operation is @code{embedded_sql()} which takes an optional
environment argument list. Upon success of this call, there
will be a separate server thread running in the same user space to handle
the database requests. A short-circuit interaction is established
between the application and the kernel using in memory buffers.

The body of the program consists of the Mapi calls you have
already seen (@pxref{The Mapi Library}). It terminates with a call
to @code{mapi_disconnect()} which lets the MonetDB thread
gracefully die.

The tight coupling of application and kernel code also carries some
dangers.
Many of the MonetDB data structures can be directly accessed,
or calls to the kernel routines are possible.
It is highly advised to stick to the Mapi interaction protocol.
It gives a little more protection against malicious behavior
or unintended side-effects.

@example
@verbatim
#include <embeddedclient.h>

#define die(dbh,hdl) (hdl?mapi_explain_result(hdl,stderr):      \
              dbh?mapi_explain(dbh,stderr):         \
                  fprintf(stderr,"command failed\n"),   \
              exit(-1))

#define close_handle(X,Y) if (mapi_close_handle(X) != MOK) die(X, Y);

int
main()
{
    Mapi dbh;
    MapiHdl hdl = NULL;
    int i;

    dbh= embedded_sql(NULL,0);
    if (dbh == NULL || mapi_error(dbh))
        die(dbh, hdl);

    /* switch off autocommit */
    if (mapi_setAutocommit(dbh, 0) != MOK || mapi_error(dbh))
        die(dbh,NULL);

    if ((hdl = mapi_query(dbh, "create table emp"
				" (name varchar(20),age int)")) == NULL || mapi_error(dbh))
        die(dbh, hdl);
    close_handle(dbh,hdl);

    for(i=0; i< 1000; i++) {
        char query[100];
        snprintf(query, 100, "insert into emp values('user%d', %d)", i, i % 82);
        if ((hdl = mapi_query(dbh, query)) == NULL || mapi_error(dbh))
            die(dbh, hdl);
        close_handle(dbh,hdl);
    }

    if ((hdl = mapi_query(dbh, "select * from emp")) == NULL || mapi_error(dbh))
        die(dbh, hdl);

    i=0;
    while (mapi_fetch_row(hdl))  {
        char *age = mapi_fetch_field(hdl, 1);
        i= i+ atoi(age);
    }
    if (mapi_error(dbh))
        die(dbh, hdl);
    close_handle(dbh,hdl);
    printf("The footprint is %d Mb \n",i);

    mapi_disconnect(dbh);
    return 0;
}
@end verbatim
@end example

The embedded MonetDB engine is available as the
library @code{libembedded_sql.a} (and @code{libembedded_mal.a})
to be linked with a C-program.
Provided the programming environment have been initialized properly, it
suffices to prepare the embedded application using
@example
gcc myprog.c -o myprog `monetdb5-config --cflags --libs`
@end example

You might also write a Makefile to build the program as follows.[todo]
@example
@verbatim
CC= gcc
INCLUDE=`monetdb5-config --cflags`
LIBS=`monetdb5-config --libs`
myprog: myprog.o
	${CC} myprog.o -o myprog ${LIBS}
myprog.o : myprog.c
	${CC} -c ${INCLUDE} myprog.c

clean: myprog.o
	rm -f myprog myprog.o
@end verbatim
@end example

@node Configuration Parameters , Embedded Limitations, A Simple Example , Embedded MonetDB
The configuration parameters for the server are read from its default
location in the file system. In an embedded setting this location may
not be accessible.
It requires calls to @code{embedded_option()} before you asks for the
instantiation of the server code itself.
The code snippet below illustrate how our example
is given hardwired knowledge on the desired settings:
@example
@verbatim
main(){
...
	Mbedded_option("dbfarm",".");
	Mbedded_option("dbname","demo");
	Mbedded_option("user","guest");
	Mbedded_option("password","anonymous");
...
	Mbedded_sql(NULL,0);
@end verbatim
@end example
For an overview of the system configuration parameters see XYZ.

