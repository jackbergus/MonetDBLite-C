@section Embedded MonetDB
The Embedded MonetDB version is optimized for running on small board computers
as a database back-end for a single client.
It is of particular interest if you need database functionality within 
a limited application setting, e.g a self-contained database distributed
as part of the application.
Within this context, much of the code to facilitate and protect
concurrent use of the kernel can be disabled. For example, 
the communication overhead of client-server TCP-IP interaction is removed.
Moreover, locking of critical resources in the kernel is not needed anymore, 
which results in significant performance improvements. 

The programming application interface for embedded MonetDB applications is
the same as for non-embedded applications. 
It consists of a C-program with calls to the Mapi library routines.
It only differs in the way the program is started and terminates. 

You normally only have to change the call @code{mapi_connect()} into
@code{mapi_embedded()} and the call to @code{mapi_disconnect()} into
@code{map_embedded_exit()}. In combination with the header file @code{Mbedded.h}
it provides the basis to compile and link the program against 
@code{libMbedded.a}

@c The primary host language is C. Embedded versions for other languages are under development.

The embedded version can also be used as a Mserver instance
to limit access to a single client only.
The server should then be started as follows:
@example
 Mserver --set gdk_embedded=yes --dbinit="<initialization>" &
@end example

It will start the server in 'daemon' mode and executes the
initialization code string. This typically involves loading
a language support module and starting its scenario.
Following, only one client is allowed access to the server at the time.

@menu
* A Simple Example::
* Configuration Parameters::
* Embedded MonetDB Limitations::
@end menu

@node A Simple Example, Configuration Parameters, Embedded MonetDB, Embedded MonetDB
@subsection Mbedded Example
A minimalistic embedded application is shown below. It creates
a temporary table in the database, fills it, and retrieves the
records for some statistics gathering.

The key operation is @code{mapi_embedded()} which takes a user name,
a password and a language indicator. Upon success of this call, there
will be a separate thread running in the same user space to handle
the database requests. A short-circuit interaction is established
between the application and the kernel using in memory buffers.

The body of the program consists of the Mapi calls you have
already seen (@pxref{The Mapi Library}). It terminates with a call
to @code{mapi_embedded_exit()} which lets the MonetDB thread
gracefully die. 

The tight coupling of application and kernel code also carries some
dangers. 
Many of the MonetDB data structures can be directly accessed, 
or calls to the kernel routines are possible. 
It is highly advised to stick to the Mapi interaction protocol. 
It gives a little more protection against malicious behavior
or unintended side-effects.

@example
@verbatim
#include <Mbedded.h>

#define die(dbh,hdl) (hdl?mapi_explain_result(hdl,stderr):      \
              dbh?mapi_explain(dbh,stderr):         \
                  fprintf(stderr,"command failed\n"),   \
              exit(-1))

#define close_handle(X,Y) if (mapi_close_handle(X) != MOK) die(X, Y);

int
main()
{
    Mapi dbh;
    MapiHdl hdl = NULL;
    int i;

    dbh= mapi_embedded("monetdb", "monetdb", "sql");
    if (dbh == NULL || mapi_error(dbh))
        die(dbh, hdl);

    /* switch off autocommit */
    if (mapi_setAutocommit(dbh, 0) != MOK || mapi_error(dbh))
        die(dbh,NULL);

    if ((hdl = mapi_query(dbh, "create table emp"
				" (name varchar(20),age int)")) == NULL || mapi_error(dbh))
        die(dbh, hdl);
    close_handle(dbh,hdl);

    for(i=0; i< 1000; i++) {
        char query[100];
        snprintf(query, 100, "insert into emp values('user%d', %d)", i, i % 82);
        if ((hdl = mapi_query(dbh, query)) == NULL || mapi_error(dbh))
            die(dbh, hdl);
        close_handle(dbh,hdl);
    }

    if ((hdl = mapi_query(dbh, "select * from emp")) == NULL || mapi_error(dbh))
        die(dbh, hdl);

    i=0;
    while (mapi_fetch_row(hdl))  {
        char *age = mapi_fetch_field(hdl, 1);
        i= i+ atoi(age);
    }
    if (mapi_error(dbh))
        die(dbh, hdl);
    close_handle(dbh,hdl);
    printf("The footprint is %d Mb \n",i);

    mapi_embedded_exit(dbh);
    return 0;
}
@end verbatim
@end example

The Embedded MonetDB is made available as the library @code{libMbedded.a}
to be linked with the application code, a C-program.
Provided the Mapi programming environment have been set properly, it
suffices to prepare the embedded application using
@example
gcc myprog.c -o myprog -lMbedded -lm -lz
@end example

You might also write a Makefile to build the program as follows.
@example
@verbatim
CC= gcc
PREFIX=${MONET5_PREFIX}
INCLUDE= -I${PREFIX}
LIBS= -l${PREFIX}/lib/libMbedded.a -lm -lz -lstreams ...
myprog: myprog.o
	${CC} myprog.o -o myprog ${LIBS}
myprog.o : myprog.c 
	${CC} -c ${INCLUDES} myprog.c 

clean: myprog.o
	rm -f myprog myprog.o
@end verbatim
@end example

@node Configuration Parameters , Embedded MonetDB Limitations, A Simple Example , Embedded MonetDB
The configuration parameters for the server are read from its default
location in the file system. In an embedded setting this location may
not be accessible.
It requires calls to @code{mapi_option()} before you asks for the
instantiation of the server code itself.
The code snippet below illustrate how our example
is given hardwired knowledge on the desired settings:
@example
@verbatim
main(){
...
	mapi_option("welcome","false");
	mapi_option("gdk_dbfarm","/tmp/dbfarm");
	mapi_option("sql_prompt","sql>");
...
	mapi_embedded("monetdb","monetdb","sql");
@end verbatim
@end example
For an overview of the system configuration parameters see XYZ.

@node Embedded MonetDB Limitations , MonetDB Assembler Language, Configuration Parameters, Embedded MonetDB
@subsection Limitations for Embedded MonetDB

In embedded applications the memory footprint is a factor of concern.
The raw footprint as delivered by the Unix @code{size} command is often used.
It is, however, also easily misleading, because the footprint of
depends on both the hot-set code segments and buffered database partitions.
Therefore it makes sense to experiment with a minimal, but functionally
complete application to decide if the resources limitations are obeyed.

The minimal footprint of MonetDB is about 15 Mb (+ ca 4Mb for SQL).
After module loading the space quickly grows to about 60Mb.
@emph{This footprint should be reduced.}

A better frame of reference for embedded applications is our sample
program, which is a simple, yet complete embedded application inspired by an
MP3 player. The table below illustrates some basic properties 
on different embedded SQL platforms.

@multitable @columnfractions 0.2 0.2 0.2 0.2 0.2
@item 
@tab Mbedded
@tab SQLite
@tab MySQL
@tab PostgreSQL
@item Prepare time
@item Max memory
@item CPU time
@end multitable
The @code{Prepare time} denotes the compilation and link time on
a state-of-the-art PC.

The embedded application world calls for many, highly specialized
enhancements. It is often well worth the effort to carve out the
functionality needed from the MonetDB software packages. The easiest
solution to limit the functionality and reduce resource consumption
is to reduce the modules loaded. This requires patches to the
startup scripts.

The benefit of an embedded database application also comes with limitations.
The one and foremost limitation of embedded MonetDB is that the first 
application accessing the database effectively locks out any other concurrent 
use.
Even in those situations where concurrent applications merely read the database,
or create privately held tables.

