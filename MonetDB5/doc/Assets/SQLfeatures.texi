@section MonetDB/SQL Features 
The SQL Implementation implementation is based on the SQL-99 standard. 
It is built incrementally over time to cope with the effort
required to realize all features. Priority is given to those
features relevant to our research and upon request from our valued
partners.

The plethora of SQL implementations also show that the standard
alone is hardly sufficient. All database systems have extended
or twisted the language definition to satisfy the needs of their
customer, to support legacy, and to better tap into the functionality
offered by their kernel implementations. 
MonetDB/SQL is bound to follow this path too. The kernel imposes
limitations on the features that can and cannot be realized.
The are summarized in @ref{Development Roadmap}.

In the context of programming support, we provide a few
primitives to simplify debugging of SQL programs. They are described
separately. The list below provides a synopsis of the SQL features
supported in the released version.

@menu
* Feature List::
* SET Statement::
* EXPLAIN Statement::
* DEBUG Statement::
* TRACE Statement::
* Optimizer Control::
* Overlaying the BAT storage::
@end menu

@node Feature List, SET Statement, MonetDB/SQL Features, MonetDB/SQL Features
@subsection SQL-99 Feature list
In this section we give an itemized list of the SQL-99 features
supported in the current release.
@itemize @bullet
@item 
Primary and foreign key integrity enforcement.
@item
Subqueries are fully supported.
@item
Table expression @code{union} and @code{intersection}.
@item
Table views for query processing only.
@item
Binding SQL functions with to externally supplied routines.
@item
Auto-increment keys (SQL 2003).
@end itemize


@node SET Statement, EXPLAIN Statement, Feature List, MonetDB/SQL Features
@subsection DECLARE Statement
The user can declare local variables to hold scalar values.
@example
DECLARE myvar integer;
SET myvar=21;
@end example
This area requires further extension to make it more usefull.

@subsection SET Statement
MonetDB/SQL comes with a limited variable scheme.
Globel, session based variables can be set using the
construct:
@example
SET <variable>=<string>
SET <variable>=<boolean>
SET <variable>=<int>
@end example
Their type is inherited from the literal value supplied.
The SQL engine comes with a limited set of environment variables
to control its behavior.
@itemize @bullet
@item
The @code{debug} variable takes an integer and sets the server global
debug flag. (See MonetDB documentation) It also activates the
debugger when the query is being executed.
@item
The @code{explain} variable takes a string value and when set 
to 'plan' shows the MAL plan before it is being executed.
When set to 'trace' it produces the execution trace information
for each query.
When set to 'profile', it keep track of the SQL global performance
in a table called @code{profile}.
@end itemize

By default all remaining variables are stored as strings and
any type analysis is up to the user. The can be freely used by the
SQL programmer for inclusion in his queries. [TODO, a little more
flexibilty would mean a lot]

The variables and their type definition are assembled in a system table
called 'sessions'. Its default content is shown below:
@example
>select * from sessions;
#---------------------------------------------------------------------#
# t                     t                   t               t         # name
# str                   str                 str             int       # type
#---------------------------------------------------------------------#
[ "debug",                "0",                "int",          0       ]
[ "explain",              "",                 "varchar",      0       ]
[ "current_schema",       "sys",              "varchar",      1       ]
[ "current_user",         "monetdb",          "varchar",      1       ]
[ "current_role",         "monetdb",          "varchar",      0       ]
[ "current_timezone",     "0",                "sec_interval", 0       ]
[ "cache",                "true",             "boolean",      0       ]
[ "trace",                "false",            "boolean",      0       ]
[ "optimizer",            "sql.optimizer();", "varchar",      0       ]
@end example

@node EXPLAIN Statement, DEBUG Statement, SET Statement, MonetDB/SQL Features
@subsection EXPLAIN Statement
The intermediate code produced by the SQL Implementation compiler can be made 
visible using the @code{explain} statement modifier. 
It gives a detailed description of the actions taken to produce the
answer. The example below illustrates what you can expect when a
simple query is pre-pended by the @code{explain} modifier.
Although the details of this program are better understood
when you have read the Chapter on MAL @ref{MonetDB Assembler Language}
the global structure is easy to explain.

@verbatim
>select count(*) from tables;
[ 27 ]
>explain select count(*) from tables;
#factory sql_cache.s1_0():bit;
#    _2:bat[:void,:int]  := sql.bind("sys","ptables","id",0);
#    _8:bat[:void,:int]  := sql.bind("sys","ptables","id",1);
#    _11 := bat.setWriteMode(_8);
#    _15:bat[:oid,:int]  := sql.bind("sys","ptables","id",3);
#    _18 := bat.setWriteMode(_15);
#    _24:bat[:void,:oid]  := sql.bind_dbat("sys","ptables",0);
#    _39:bat[:void,:int]  := sql.bind("sys","ttables","id",0);
#    _45:bat[:void,:oid]  := sql.bind_dbat("sys","ttables",0);
#barrier _90 := true;
#    _13 := algebra.kunion(_2,_11);
#    _20 := algebra.kdifference(_13,_18);
#    _22 := algebra.kunion(_20,_18);
#    _26 := bat.reverse(_24);
#    _28 := algebra.kdifference(_22,_26);
#    _33 := algebra.markT(_28,0@0);
#    _35 := bat.reverse(_33);
#    _37 := algebra.join(_35,_22);
#    _47 := bat.reverse(_45);
#    _49 := algebra.kdifference(_39,_47);
#    _53 := algebra.markT(_49,0@0);
#    _55 := bat.reverse(_53);
#    _57 := algebra.join(_55,_39);
#    _59 := bat.setWriteMode(_37);
#    bat.append(_59,_57);
#    _65 := algebra.markT(_59,0@0);
#    _67 := bat.reverse(_65);
#    _69 := algebra.join(_67,_59);
#    _74 := algebra.markT(_69,0@0);
#    _76 := bat.reverse(_74);
#    _78 := algebra.join(_76,_69);
#    _80 := aggr.count(_78);
#    sql.exportValue(1,"sys.tables","count_id","int",32,0,6,_80);
#    yield _90;
#    redo _90;
#exit _90;
#end s1_0;
@end verbatim

The SQL compiler keeps a limited cache of queries.
Each query is looked up in this cache based on an expression pattern 
match where the constants may take on different values.
If it doesn't exist, the query is converted into 
a @emph{factory} code block and stored in the module @code{sqlcache}. 
It consists of a prelude section, which locates
the tables of interest in the SQL catalogs.
The block between @code{barrier} and @code{yield} is the actual code
executed upon each call of this function. It is a large collection
of relational algebra operators, whose execution semantics depend
on the actual MAL engine. The @code{factory} ensures that only this part
is called when the query is executed repetitively.

The call to the cached function is included in the function @code{main},
which is the only piece of code produced if the query is used more than once.
The query cache disappears when the server is brought to a halt. 

When/how is the cache cleared? Can you list elements in the
cache directly, e.g @code{explain;} or @code{explain sqlcache} or @code{explain sqlcache.sql0;}

@node DEBUG Statement, TRACE Statement, EXPLAIN Statement, MonetDB/SQL Features
@subsection DEBUG Statement

The SQL statements are translated into MAL programs, which
are optimized and stored away in an @code{sql_cache} module.
The generated code can be debugged with the MAL debugger.
It provides a simple mechanism to trace the execution, hunting
for possible errors and detect performance bottlenecks
(@ref{Runtime Inspection}).

The example below, illustrates the start of such a session:
@verbatim
>debug select count(*) from tables;
#    mdb.start()
mdb>next
#    sql_cache.s1_0()
mdb>next
#    _2:bat[:void,:int]  := sql.bind(_3="sys", _4="ptables", _5="id", _6=0)
mdb>next
#    _8:bat[:void,:int]  := sql.bind(_3="sys", _4="ptables", _5="id", _9=1)
mdb>
@end verbatim

@node TRACE Statement, Optimizer Control, DEBUG Statement, MonetDB/SQL Features
@subsection TRACE Statement
Inspection of the execution time of the query plan uses the debugger
facilities to time each request. The statement below illustrates
the @code{trace} statement modifier to obtain a first glimpse
on the expensive components of the query plan.

@verbatim
>trace select count(*) from tables;
#     7 usec#    mdb.setTimer(_2=true)
#    10 usec#    _2:bat[:void,:int]  := sql.bind(_3="sys", _4="ptables", _5="id", _6=0)
#     6 usec#    _8:bat[:void,:int]  := sql.bind(_3="sys", _4="ptables", _5="id", _9=1)
#    12 usec#    _11 := bat.setWriteMode(_8=<tmp_1255>bat[:void,:int]{0})
#     5 usec#    _15:bat[:oid,:int]  := sql.bind(_3="sys", _4="ptables", _5="id", _16=3)
#     3 usec#    _18 := bat.setWriteMode(_15=<tmp_1256>bat[:oid,:int]{0})
#     5 usec#    _24:bat[:void,:oid]  := sql.bind_dbat(_3="sys", _4="ptables", _6=0)
#     6 usec#    _39:bat[:void,:int]  := sql.bind(_40="sys", _41="ttables", _42="id", _43=0)
#     5 usec#    _45:bat[:void,:oid]  := sql.bind_dbat(_40="sys", _41="ttables", _43=0)
#    23 usec#    _13 := algebra.kunion(_2=<tmp_27>bat[:void,:int]{32}, _11=<tmp_1255>bat[:void,:int]{0})
#    19 usec#    _20 := algebra.kdifference(_13=<tmp_2141>bat[:void,:int]{32}, _18=<tmp_1256>bat[:oid,:int]{0})
#     7 usec#    _22 := algebra.kunion(_20=<tmp_2142>bat[:oid,:int]{32}, _18=<tmp_1256>bat[:oid,:int]{0})
#     8 usec#    _26 := bat.reverse(_24=<tmp_1254>bat[:void,:oid]{0})
#     5 usec#    _28 := algebra.kdifference(_22=<tmp_2143>bat[:oid,:int]{32}, _26=<~tmp_1254>bat[:oid,:void]{0})
#    16 usec#    _33 := algebra.markT(_28=<tmp_2144>bat[:oid,:int]{32}, _31=0@0)
#     4 usec#    _35 := bat.reverse(_33=<tmp_2145>bat[:oid,:void]{32})
#    47 usec#    _37 := algebra.join(_35=<~tmp_2145>bat[:void,:oid]{32}, _22=<tmp_2143>bat[:oid,:int]{32})
#     4 usec#    _47 := bat.reverse(_45=<tmp_1455>bat[:void,:oid]{0})
#     6 usec#    _49 := algebra.kdifference(_39=<tmp_1456>bat[:void,:int]{0}, _47=<~tmp_1455>bat[:oid,:void]{0})
#     5 usec#    _53 := algebra.markT(_49=<tmp_2146>bat[:oid,:int]{0}, _31=0@0)
#     4 usec#    _55 := bat.reverse(_53=<tmp_2150>bat[:oid,:void]{0})
#     8 usec#    _57 := algebra.join(_55=<~tmp_2150>bat[:void,:oid]{0}, _39=<tmp_1456>bat[:void,:int]{0})
#    26 usec#    _59 := bat.setWriteMode(_37=<tmp_2147>bat[:void,:int]{32})
#     9 usec#    bat.append(_59=<tmp_2147>bat[:void,:int]{32}, _57=<tmp_2151>bat[:void,:int]{0})
#    14 usec#    _65 := algebra.markT(_59=<tmp_2147>bat[:void,:int]{32}, _31=0@0)
#     4 usec#    _67 := bat.reverse(_65=<tmp_2153>bat[:oid,:void]{32})
#    11 usec#    _69 := algebra.join(_67=<~tmp_2153>bat[:void,:oid]{32}, _59=<tmp_2147>bat[:void,:int]{32})
#     5 usec#    _74 := algebra.markT(_69=<tmp_2154>bat[:void,:int]{32}, _72=0@0)
#     3 usec#    _76 := bat.reverse(_74=<tmp_2152>bat[:oid,:void]{32})
#    10 usec#    _78 := algebra.join(_76=<~tmp_2152>bat[:void,:oid]{32}, _69=<tmp_2154>bat[:void,:int]{32})
#     4 usec#    _80 := aggr.count(_78=<tmp_2156>bat[:void,:int]{32})
&1 0 1 1 1
# sys.tables # table_name
# count_id # name
# int # type
# 2 # length
[ 32    ]
#    36 usec#    sql.exportValue(_83=1, _84="sys.tables", _85="count_id", _86="int", _87=32, _88=0, _89=6, _80=32)
#   911 usec#    sql_cache.s0_0()

@end verbatim

@node Optimizer Control, Overlaying the BAT storage, TRACE Statement,  MonetDB/SQL Features
@section Optimizer Control
The code produced by MonetDB/SQL is massaged by several code optimizers
to arrive at the best possible plan for evaluation.
However, for development purposes and the rare case that more control
is needed, the SQL session variable @code{optimizer} can be set
to a list of optimizers to identify the steps needed. 

@example
>set optimizer='commonExpressionRemoval,garbageCollector';
>select optimizer;
#-----------------------------------------------#
# t                                             # name
# str                                           # type
#-----------------------------------------------#
[ "commonExpressionRemoval,garbageCollector"    ]
@end example

The optimizers available, in various stages of maturity, are:
commonExpressionRemoval")@
@multitable @columnfractions .2 .8
@item aliasRemoval
@tab Remove alias assignments
@item deadCodeRemoval
@tab Remove all code not leading to used results
@item garbageCollector
@tab
@item partitionedQuery
@tab
@item expressionAccumulation
@tab
@item factorize
@tab
@item strengthReduction
@tab
@item emptySet
@tab
@item singleton
@tab
@item peephole
@tab
@item costEstimation
@tab
@item multitable
@tab
@item generators
@tab
@item reduce
@tab
@item coercions
@tab
@item remoteQueries
@tab
@end multitable 


The final result the optimizer steps become visible using the @code{explain}
statement modifier.  Alternatively, the @code{debug} statement modifier
in combination with the 'o' command provides access to the intermediate
optimizer results.

@node Overlaying the BAT storage,XQuery, Optimizer Control,  MonetDB/SQL Features
@section Overlaying the BAT storage
The SQL implementation exploits many facilities of the underlying
MonetDB kernel. Most notably, its efficient column-wise storage
scheme with associated algebraic primitives.
However, this kernel can also be programmed directly using the
MonetDB Assembler Language (MAL), which provides a much richer
set of operators then strictly necessary for a correct implementation
and execution of SQL

Although the BATs used for SQL storage can be manipulated directly
at the MAL layer, it is strongly discouraged. For, SQL uses a
rather complex administration to realise transaction safety.
Working at the MAL layer directly could easily compromise
the integrity of the system as a whole.

However, there are cases where access to a collection of BATs from
the SQL environment can be handy. For example, to inspect some
of the system tables maintained in the kernel.
This functionality is realised using an variation of the @code{view
statement}. It is best illustrated with a short example.

First, create in MonetDB the BATs of interest. Only void-BATs are allowed
and the user should guarantee that they are aligned.
@example
a:=bat.new(:void,:int);
b:=bat.new(:void,:str);
bat.setSequenceBase(a,0@@0);
bat.setSequenceBase(b,0@@0);
bat.setPersistent(a);
bat.setPersistent(b);
bat.setName(a,"age");
bat.setName(b,"name");
@end example
These BATs can be filled with attribute values, but make sure
that all BATs are given an equal number of tuples.
To conclude, commit the database to disk, whereafter the BATs
become available to SQL, once you restart Mserver/SQL.
@example
bat.append(a, 32);
bat.append(b, "John");
bat.append(a, 31);
bat.append(b, "Mary");
transaction.commit(a,b);
@end example
The BATs are made visible for read-only access using the a column
specification. As it normally expects identifiers, we have to use
double quotes instead.
@example
CREATE VIEW friends ("age","name") AS BATS;
@end example
At this point the content of the BATs can be queried
using ordinary SQL queries. Updates are prohibited.
