@section MonetDB/SQL Features 
The SQL Implementation implementation is based on the SQL-99 standard. 
It is built incrementally over time to cope with the effort
required to realize all features. Priority is given to those
features relevant to our research and upon request from our valued
partners.

The plethora of SQL implementations also show that the standard
alone is hardly sufficient. All database systems have extended
or twisted the language definition to satisfy the needs of their
customer, to support legacy, and to better tap into the functionality
offered by their kernel implementations. 
MonetDB/SQL is bound to follow this path too. The kernel imposes
limitations on the features that can and cannot be realized.
The are summarized in @ref{Development Roadmap}.

In the context of programming support, we provide a few
primitives to simplify debugging of SQL programs. They are described
separately. The list below provides a synopsis of the SQL features
supported in the released version.

@menu
* Feature List::
* SET Statement::
* EXPLAIN Statement::
* DEBUG Statement::
* Optimizer Control::
* Overlaying the BAT storage::
@end menu

@node Feature List, SET Statement, MonetDB/SQL Features, MonetDB/SQL Features
@subsection SQL-99 Feature list
In this section we give an itemized list of the SQL-99 features
supported in the current release.
@itemize @bullet
@item 
Primary and foreign key integrity enforcement.
@item
Subqueries are fully supported.
@item
Table expression @code{union} and @code{intersection}.
@item
Table views for query processing only.
@item
Binding SQL functions with to externally supplied routines.
@item
Auto-increment keys (SQL 2003).
@end itemize


@node SET Statement, EXPLAIN Statement, Feature List, MonetDB/SQL Features
@subsection SET Statement

MonetDB/SQL comes with a limited variable scheme.
Globel, session based variables can be introduced using the
construct:
@example
SET <variable>=<string>
SET <variable>=<boolean>
SET <variable>=<int>
@end example
Their type is inherited from the literal value supplied.
The SQL engine comes with a limited set of environment variables
to control its behavior.
@itemize @bullet
@item
The @code{debug} variable takes an integer and sets the server global
debug flag. (See MonetDB documentation) It also activates the
debugger when the query is being executed.
@item
The @code{explain} variable currently takes the values 'plan' or
'performance'. The 'plan' qualifier produces a relational table with
the plan derived for execution using the applicable back end and
optimizer schemes. The 'performance' qualifier produces a performance
trace of the SQL queries for post analysis. It is available in
the system table called @code{history}. Omission of either qualifier merely
results in a straight execution of the query.
@item

The @code{auto_commit} variable takes a boolean and controls automatic commit
after a successful SQL execution, or conversely an automatic rollback.

@item
The @code{reply_size} limits the number of tuples sent to the front end.
[It is unclear how the remainder can be obtained within the SQL language
framework. The reply_size should be replaced by the @code{limit} language
construct]

@item
The @code{history} variable is a boolean flag which leads to 
capturing execution information of any SQL query in a table for post-analysis.
@end itemize

By default all remaining variables are stored as strings and
any type analysis is up to the user. The can be freely used by the
SQL programmer for inclusion in his queries. [TODO, a little more
flexibilty would mean a lot]

The variables and their type definition are assembled in a system table
called 'sessions'. Its default content is shown below:
@example
>select * from sessions;
#---------------------------------------------------------------------#
# t                     t                   t               t         # name
# str                   str                 str             int       # type
#---------------------------------------------------------------------#
[ "debug",                "0",                "int",          0       ]
[ "reply_size",           "-1",               "int",          0       ]
[ "explain",              "",                 "varchar",      0       ]
[ "auto_commit",          "false",            "boolean",      0       ]
[ "current_schema",       "sys",              "varchar",      1       ]
[ "current_user",         "monetdb",          "varchar",      1       ]
[ "current_role",         "monetdb",          "varchar",      0       ]
[ "current_timezone",     "0",                "sec_interval", 0       ]
[ "optimizer",            "yes",              "varchar",      0       ]
@end example

@node EXPLAIN Statement, DEBUG Statement, SET Statement, MonetDB/SQL Features
@subsection EXPLAIN Statement
The intermediate code produced by the SQL Implementation compiler can be made 
visible using the @code{explain} statement modifier. 
It gives a detailed description of the actions taken to produce the
answer. The example below illustrates what you can expect when a
simple query is pre-pended by the @code{explain} modifier.
Although the details of this program are better understood
when you have read the Chapter on MAL @ref{MonetDB Assembler Language}
the global structure is easy to explain.

@verbatim
>select count(*) from tables;
[ 27 ]
>explain select count(*) from tables;
#factory sql_cache.s1_0():bit;
#    _2:bat[:void,:int]  := sql.bind("sys","ptables","id",0);
#    _8:bat[:void,:int]  := sql.bind("sys","ptables","id",1);
#    _11 := bat.setWriteMode(_8);
#    _15:bat[:oid,:int]  := sql.bind("sys","ptables","id",3);
#    _18 := bat.setWriteMode(_15);
#    _24:bat[:void,:oid]  := sql.bind_dbat("sys","ptables",0);
#    _39:bat[:void,:int]  := sql.bind("sys","ttables","id",0);
#    _45:bat[:void,:oid]  := sql.bind_dbat("sys","ttables",0);
#barrier _90 := true;
#    _13 := algebra.kunion(_2,_11);
#    _20 := algebra.kdifference(_13,_18);
#    _22 := algebra.kunion(_20,_18);
#    _26 := bat.reverse(_24);
#    _28 := algebra.kdifference(_22,_26);
#    _33 := algebra.markT(_28,0@0);
#    _35 := bat.reverse(_33);
#    _37 := algebra.join(_35,_22);
#    _47 := bat.reverse(_45);
#    _49 := algebra.kdifference(_39,_47);
#    _53 := algebra.markT(_49,0@0);
#    _55 := bat.reverse(_53);
#    _57 := algebra.join(_55,_39);
#    _59 := bat.setWriteMode(_37);
#    bat.append(_59,_57);
#    _65 := algebra.markT(_59,0@0);
#    _67 := bat.reverse(_65);
#    _69 := algebra.join(_67,_59);
#    _74 := algebra.markT(_69,0@0);
#    _76 := bat.reverse(_74);
#    _78 := algebra.join(_76,_69);
#    _80 := aggr.count(_78);
#    sql.exportValue(1,"sys.tables","count_id","int",32,0,6,_80);
#    yield _90;
#    redo _90;
#exit _90;
#end s1_0;
@end verbatim

The SQL compiler keeps a limited cache of queries.
Each query is looked up in this cache based on an expression pattern 
match where the constants may take on different values.
If it doesn;t exist, the query is converted into 
a @emph{factory} code block and stored in the module @code{sqlcache}. 
It consists of a prelude section, which locates
the tables of interest in the SQL catalogs.
The block between @code{barrier} and @code{yield} is the actual code
executed upon each call of this function. It is a large collection
of relational algebra operators, whose execution semantics depend
on the actual MAL engine. The @code{factory} ensures that only this part
is called when the query is executed repetitively.

The call to the cached function is included in the function @code{main},
which is the only piece of code produced if the query is used more than once.
The query cache disappears when the server is brought to a halt. 

When/how is the cache cleared? Can you list elements in the
cache directly, e.g @code{explain;} or @code{explain sqlcache} or @code{explain sqlcache.sql0;}

@node DEBUG Statement, Optimizer Control, EXPLAIN Statement, MonetDB/SQL Features
@subsection DEBUG Statement

The SQL statements are translated into MAL programs, which
are optimized and stored away in an @code{sql_cache} module.
The generated code can be debugged with the MAL debugger.
It provides a simple mechanism to trace the execution, hunting
for possible errors and detect performance bottlenecks
(@ref{Runtime Inspection}).

The example below, illustrates how you can easily obtain a quick 
overview of the cost components of the query using the debugger timer
flag and @code{continuation} command for the debugger.

[ERROR: the 'start transaction' is needed now]
@verbatim
>start transaction;
&4 f
>debug select count(*) from tables;
#mdb #    mdb.start();
mdb>next
#mdb #    sql_cache.s0_0();
mdb>timer
mdb>continue
#    13 usec#    _2:bat[:void,:int]  := sql.bind(_3="sys", _4="ptables", _5="id", _6=0)
#     2 usec#    _8:bat[:void,:int]  := sql.bind(_3="sys", _4="ptables", _5="id", _9=1)
#     3 usec#    _11 := bat.setWriteMode(_8=<tmp_515>)
#     2 usec#    _15:bat[:oid,:int]  := sql.bind(_3="sys", _4="ptables", _5="id", _16=3)
#     1 usec#    _18 := bat.setWriteMode(_15=<tmp_516>)
#     2 usec#    _24:bat[:void,:oid]  := sql.bind_dbat(_3="sys", _4="ptables", _6=0)
#     4 usec#    _39:bat[:void,:int]  := sql.bind(_40="sys", _41="ttables", _42="id", _43=0)
#     1 usec#    _45:bat[:void,:oid]  := sql.bind_dbat(_40="sys", _41="ttables", _43=0)
#    17 usec#    _13 := algebra.kunion(_2=<tmp_26>, _11=<tmp_515>)
#     7 usec#    _20 := algebra.kdifference(_13=<tmp_1372>, _18=<tmp_516>)
#     3 usec#    _22 := algebra.kunion(_20=<tmp_1374>, _18=<tmp_516>)
#     1 usec#    _26 := bat.reverse(_24=<tmp_514>)
#     3 usec#    _28 := algebra.kdifference(_22=<tmp_1375>, _26=<~tmp_514>)
#     4 usec#    _33 := algebra.markT(_28=<tmp_1376>, _31=0@0)
#     0 usec#    _35 := bat.reverse(_33=<tmp_1377>)
#    22 usec#    _37 := algebra.join(_35=<~tmp_1377>, _22=<tmp_1375>)
#     1 usec#    _47 := bat.reverse(_45=<tmp_731>)
#     4 usec#    _49 := algebra.kdifference(_39=<tmp_732>, _47=<~tmp_731>)
#     2 usec#    _53 := algebra.markT(_49=<tmp_1400>, _31=0@0)
#     0 usec#    _55 := bat.reverse(_53=<tmp_1402>)
#     4 usec#    _57 := algebra.join(_55=<~tmp_1402>, _39=<tmp_732>)
#    12 usec#    _59 := bat.setWriteMode(_37=<tmp_1401>)
#     2 usec#    bat.append(_59=<tmp_1401>, _57=<tmp_1403>)
#     8 usec#    _65 := algebra.markT(_59=<tmp_1401>, _31=0@0)
#     0 usec#    _67 := bat.reverse(_65=<tmp_1405>)
#     9 usec#    _69 := algebra.join(_67=<~tmp_1405>, _59=<tmp_1401>)
#     2 usec#    _74 := algebra.markT(_69=<tmp_1406>, _72=0@0)
#     1 usec#    _76 := bat.reverse(_74=<tmp_1404>)
#     7 usec#    _78 := algebra.join(_76=<~tmp_1404>, _69=<tmp_1406>)
#     1 usec#    _80 := aggr.count(_78=<tmp_1410>)
&1 0 1 1 1
# sys.tables # table_name
# count_id # name
# int # type
# 2 # length
[ 27    ]
#    20 usec#    sql.exportValue(_83=1, _84="sys.tables", _85="count_id", _86="int", _87=32, _88=0, _89=6, _80=27)
#     2 usec#    sql_cache.s3_0()
>
@end verbatim

@node Optimizer Control, Overlaying the BAT storage, DEBUG Statement,  MonetDB/SQL Features
@section Optimizer Control
The code produced by MonetDB/SQL is massaged by several code optimizers
to arrive at the best possible plan for evaluation.
However, for development purposes and the rare case that more control
is needed, the SQL session variable @code{optimizer} can be set
to a MAL instruction list to identify the optimizer steps needed. [todo]

@example
>select optimizer;
#--------------------#
# t                  # name
# str                # type
#--------------------#
[ "optimizer.sql();" ]
>set optimizer="optimizer.factorize();";
>explain select 1;
@end example

The final result the optimizer steps become visible using the @code{explain}
statement modifier. Alternatively, the optimizer script line may include
a call to @code{optimizer.showPlan();}.

@node Overlaying the BAT storage,XQuery, Optimizer Control,  MonetDB/SQL Features
@section Overlaying the BAT storage
The SQL implementation exploits many facilities of the underlying
MonetDB kernel. Most notably, its efficient column-wise storage
scheme with associated algebraic primitives.
However, this kernel can also be programmed directly using the
MonetDB Assembler Language (MAL), which provides a much richer
set of operators then strictly necessary for a correct implementation
and execution of SQL

Although the BATs used for SQL storage can be manipulated directly
at the MAL layer, it is strongly discouraged. For, SQL uses a
rather complex administration to realise transaction safety.
Working at the MAL layer directly could easily compromise
the integrity of the system as a whole.

However, there are cases where access to a collection of BATs from
the SQL environment can be handy. For example, to inspect some
of the system tables maintained in the kernel.
This functionality is realised using an variation of the @code{view
statement}. It is best illustrated with a short example.

First, create in MonetDB the BATs of interest. Only void-BATs are allowed
and the user should guarantee that they are aligned.
@example
a:=bat.new(:void,:int);
b:=bat.new(:void,:str);
bat.setSequenceBase(a,0@@0);
bat.setSequenceBase(b,0@@0);
bat.setPersistent(a);
bat.setPersistent(b);
bat.setName(a,"age");
bat.setName(b,"name");
@end example
These BATs can be filled with attribute values, but make sure
that all BATs are given an equal number of tuples.
To conclude, commit the database to disk, whereafter the BATs
become available to SQL, once you restart Mserver/SQL.
@example
bat.append(a, 32);
bat.append(b, "John");
bat.append(a, 31);
bat.append(b, "Mary");
transaction.commit(a,b);
@end example
The BATs are made visible for read-only access using the a column
specification. As it normally expects identifiers, we have to use
double quotes instead.
@example
CREATE VIEW friends ("age","name") AS BATS;
@end example
At this point the content of the BATs can be queried
using ordinary SQL queries. Updates are prohibited.
