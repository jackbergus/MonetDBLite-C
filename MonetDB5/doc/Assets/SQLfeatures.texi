@section Runtime Features 
The MonetDB SQL implementation provides a few
primitives to simplify profiling and debugging of SQL queries.
They are described separately. 

@menu
* Session Variables ::
* EXPLAIN Statement::
* PROFILE Statement::
* DEBUG Statement::
* TRACE Statement::
* Optimizer Control::
* Overlaying BATs::
@end menu

@node Session Variables, EXPLAIN Statement, Runtime Features, Runtime Features
@subsection Session Variables 
MonetDB/SQL supports session variables declared by the user. 
They are indistinguishable from table and column names
and can be used anywhere a literal constant is allowed.

@example
sql>DECLARE high integer;
sql>DECLARE n varchar(256);
sql>SET high=4000;
[ 1     ]
sql>SET n='monetdb';
[ 1     ]
sql>SELECT count(*) from tables where id > high;
# sys.tables # table_name
# count_id # name
# int # type
# 2 # length
[ 30    ]
@end example
The SQL variables are stored in the global temporary table @code{sessions}.
The initial state is something like:
@example
>select * from sessions;
#---------------------------------------------------------------------#
# t                     t                   t               t         # name
# str                   str                 str             int       # type
#---------------------------------------------------------------------#
[ "current_schema",       "sys",              "varchar",      1       ]
[ "current_user",         "monetdb",          "varchar",      1       ]
[ "current_role",         "monetdb",          "varchar",      0       ]
[ "current_timezone",     "0",                "sec_interval", 0       ]
[ "cache",                "true",             "boolean",      0       ]
[ "profile",              "false",            "boolean",      0       ]
[ "optimizer",            "on",               "varchar",      0       ]
[ "trace",                "false",            "boolean",      0       ]
@end example

@itemize @bullet
@item
The @code{debug} variable takes an integer and sets the server global
debug flag (See MonetDB configuration documentation file). 
It also activates the debugger when the query is being executed.
@item
The @code{profile} variable takes a boolean and when set collects
execution statistics on the SQL queries executed in the table @code{profile}.
@item
The @code{trace} variable takes a boolean and when set lists
the execution timing of all MAL instructions to solve the SQL query.
@item
The @code{cache} variable takes a boolean and when set
SQL uses a query cache to speed up subsequent calls to identical
(up to constants) queries.
@item
The @code{optimizer} variable takes a string. It controls the
query optimizers, see @ref{SQL}.
@end itemize

@node EXPLAIN Statement, PROFILE Statement, Session Variables, Runtime Features
@subsection EXPLAIN Statement
The intermediate code produced by the SQL compiler can be made 
visible using the @code{explain} statement modifier. 
It gives a detailed description of the actions taken to produce the
answer. The example below illustrates what you can expect when a
simple query is pre-pended by the @code{explain} modifier.
@ifset SQLmanual
Although the details of this program are better understood
when you have read the MonetDB Version 5 Reference Manual,
the global structure is easy to explain.
@include Assets/warning.texi
@end ifset
@ifset M5manual
Although the details of this program are better understood
when you have read the Chapter on @ref{MAL}, 
the global structure is easy to explain.
@end ifset

@verbatim
>select count(*) from tables;
[ 27 ]
>explain select count(*) from tables;
#factory sql_cache.s1_0():bit;
#    _2:bat[:void,:int]  := sql.bind("sys","ptables","id",0);
#    _8:bat[:void,:int]  := sql.bind("sys","ptables","id",1);
#    _11 := bat.setWriteMode(_8);
#    _15:bat[:oid,:int]  := sql.bind("sys","ptables","id",3);
#    _18 := bat.setWriteMode(_15);
#    _24:bat[:void,:oid]  := sql.bind_dbat("sys","ptables",0);
#    _39:bat[:void,:int]  := sql.bind("sys","ttables","id",0);
#    _45:bat[:void,:oid]  := sql.bind_dbat("sys","ttables",0);
#barrier _90 := true;
#    _13 := algebra.kunion(_2,_11);
#    _20 := algebra.kdifference(_13,_18);
#    _22 := algebra.kunion(_20,_18);
#    _26 := bat.reverse(_24);
#    _28 := algebra.kdifference(_22,_26);
#    _33 := algebra.markT(_28,0@0);
#    _35 := bat.reverse(_33);
#    _37 := algebra.join(_35,_22);
#    _47 := bat.reverse(_45);
#    _49 := algebra.kdifference(_39,_47);
#    _53 := algebra.markT(_49,0@0);
#    _55 := bat.reverse(_53);
#    _57 := algebra.join(_55,_39);
#    _59 := bat.setWriteMode(_37);
#    bat.append(_59,_57);
#    _65 := algebra.markT(_59,0@0);
#    _67 := bat.reverse(_65);
#    _69 := algebra.join(_67,_59);
#    _74 := algebra.markT(_69,0@0);
#    _76 := bat.reverse(_74);
#    _78 := algebra.join(_76,_69);
#    _80 := aggr.count(_78);
#    sql.exportValue(1,"sys.tables","count_id","int",32,0,6,_80);
#    yield _90;
#    redo _90;
#exit _90;
#end s1_0;
@end verbatim

The SQL compiler keeps a limited cache of queries.
Each query is looked up in this cache based on an expression pattern 
match where the constants may take on different values.
If it doesn't exist, the query is converted into 
a @emph{factory} code block and stored in the module @code{sqlcache}. 
It consists of a prelude section, which locates
the tables of interest in the SQL catalogs.
The block between @code{barrier} and @code{yield} is the actual code
executed upon each call of this function. It is a large collection
of relational algebra operators, whose execution semantics depend
on the actual MAL engine. The @code{factory} ensures that only this part
is called when the query is executed repetitively.

The call to the cached function is included in the function @code{main},
which is the only piece of code produced if the query is used more than once.
The query cache disappears when the server is brought to a halt. 

@node PROFILE Statement, DEBUG Statement, EXPLAIN Statement, Runtime Features
@subsection PROFILE Statement
The SQL implementation comes with a simple profiler to learn about
the expensive queries.
The profiler is controlled by the boolean session variable @code{profile}.
The snippet below illustrates its use:
@verbatim
> set profile= true;
  ...
> select * from profile
&1 0 3 7 3
# tmp.profile,  tmp.profile,    tmp.profile,    tmp.profile,    tmp.profile,
tmp.profile,    tmp.profile # table_name
# start,    query,  parse,  optimize,   exec,   total,  user # name
# timestamp,    varchar,    int,    int,    int,    int,    varchar # type
# 26,   28, 3,  3,  3,  3,  7 # length
[ 2006-07-12 21:52:49.000000,   "select count(*) from tables;", 596,    159,
200,    955,    "monetdb"   ]
[ 2006-07-12 21:52:51.000000,   "select 2;",    114,    57, 17, 188,    "monetdb
"   ]
[ 2006-07-12 21:53:00.000000,   "select sum(id) from tables;",  522,    176,
137,    835,    "monetdb"   ]
>
@end verbatim
It illustrates the wall clock time the query was started, the
query itself, followed by the timing obtained for the parser, the
optimizer, the execution phase and the total execution time (in microseconds).
The final column indicates the user responsible for this request.

@node DEBUG Statement, TRACE Statement, PROFILE Statement, Runtime Features
@subsection DEBUG Statement

@include Assets/warning.texi
The SQL statements are translated into MAL programs, which
are optimized and stored away in an @code{sql_cache} module.
The generated code can be debugged with the MAL debugger.
@ifset M5manual
It provides a simple mechanism to trace the execution, hunting
for possible errors and detect performance bottlenecks
(@ref{Runtime Inspection}).
@end ifset

The example below illustrates the start of such a session:
@verbatim
>debug select count(*) from tables;
#    mdb.start()
mdb>next
#    sql_cache.s1_0()
mdb>next
#    _2:bat[:void,:int]  := sql.bind(_3="sys", _4="ptables", _5="id", _6=0)
mdb>next
#    _8:bat[:void,:int]  := sql.bind(_3="sys", _4="ptables", _5="id", _9=1)
mdb> ...
@end verbatim

@node TRACE Statement, Optimizer Control, DEBUG Statement, Runtime Features
@subsection TRACE Statement
Inspection of the execution time of the query plan uses the debugger
facilities to time each request. The example below illustrates
the @code{trace} statement modifier to obtain a first glimpse
on the expensive components of the query plan.

@include Assets/warning.texi
@verbatim
>trace select count(*) from tables;
#     7 usec#    mdb.setTimer(_2=true)
#    10 usec#    _2:bat[:void,:int]  := sql.bind(_3="sys", _4="ptables", _5="id", _6=0)
#     6 usec#    _8:bat[:void,:int]  := sql.bind(_3="sys", _4="ptables", _5="id", _9=1)
#    12 usec#    _11 := bat.setWriteMode(_8=<tmp_1255>bat[:void,:int]{0})
#     5 usec#    _15:bat[:oid,:int]  := sql.bind(_3="sys", _4="ptables", _5="id", _16=3)
#     3 usec#    _18 := bat.setWriteMode(_15=<tmp_1256>bat[:oid,:int]{0})
#     5 usec#    _24:bat[:void,:oid]  := sql.bind_dbat(_3="sys", _4="ptables", _6=0)
#     6 usec#    _39:bat[:void,:int]  := sql.bind(_40="sys", _41="ttables", _42="id", _43=0)
#     5 usec#    _45:bat[:void,:oid]  := sql.bind_dbat(_40="sys", _41="ttables", _43=0)
#    23 usec#    _13 := algebra.kunion(_2=<tmp_27>bat[:void,:int]{32}, _11=<tmp_1255>bat[:void,:int]{0})
#    19 usec#    _20 := algebra.kdifference(_13=<tmp_2141>bat[:void,:int]{32}, _18=<tmp_1256>bat[:oid,:int]{0})
#     7 usec#    _22 := algebra.kunion(_20=<tmp_2142>bat[:oid,:int]{32}, _18=<tmp_1256>bat[:oid,:int]{0})
#     8 usec#    _26 := bat.reverse(_24=<tmp_1254>bat[:void,:oid]{0})
#     5 usec#    _28 := algebra.kdifference(_22=<tmp_2143>bat[:oid,:int]{32}, _26=<~tmp_1254>bat[:oid,:void]{0})
#    16 usec#    _33 := algebra.markT(_28=<tmp_2144>bat[:oid,:int]{32}, _31=0@0)
#     4 usec#    _35 := bat.reverse(_33=<tmp_2145>bat[:oid,:void]{32})
#    47 usec#    _37 := algebra.join(_35=<~tmp_2145>bat[:void,:oid]{32}, _22=<tmp_2143>bat[:oid,:int]{32})
#     4 usec#    _47 := bat.reverse(_45=<tmp_1455>bat[:void,:oid]{0})
#     6 usec#    _49 := algebra.kdifference(_39=<tmp_1456>bat[:void,:int]{0}, _47=<~tmp_1455>bat[:oid,:void]{0})
#     5 usec#    _53 := algebra.markT(_49=<tmp_2146>bat[:oid,:int]{0}, _31=0@0)
#     4 usec#    _55 := bat.reverse(_53=<tmp_2150>bat[:oid,:void]{0})
#     8 usec#    _57 := algebra.join(_55=<~tmp_2150>bat[:void,:oid]{0}, _39=<tmp_1456>bat[:void,:int]{0})
#    26 usec#    _59 := bat.setWriteMode(_37=<tmp_2147>bat[:void,:int]{32})
#     9 usec#    bat.append(_59=<tmp_2147>bat[:void,:int]{32}, _57=<tmp_2151>bat[:void,:int]{0})
#    14 usec#    _65 := algebra.markT(_59=<tmp_2147>bat[:void,:int]{32}, _31=0@0)
#     4 usec#    _67 := bat.reverse(_65=<tmp_2153>bat[:oid,:void]{32})
#    11 usec#    _69 := algebra.join(_67=<~tmp_2153>bat[:void,:oid]{32}, _59=<tmp_2147>bat[:void,:int]{32})
#     5 usec#    _74 := algebra.markT(_69=<tmp_2154>bat[:void,:int]{32}, _72=0@0)
#     3 usec#    _76 := bat.reverse(_74=<tmp_2152>bat[:oid,:void]{32})
#    10 usec#    _78 := algebra.join(_76=<~tmp_2152>bat[:void,:oid]{32}, _69=<tmp_2154>bat[:void,:int]{32})
#     4 usec#    _80 := aggr.count(_78=<tmp_2156>bat[:void,:int]{32})
&1 0 1 1 1
# sys.tables # table_name
# count_id # name
# int # type
# 2 # length
[ 32    ]
#    36 usec#    sql.exportValue(_83=1, _84="sys.tables", _85="count_id", _86="int", _87=32, _88=0, _89=6, _80=32)
#   911 usec#    sql_cache.s0_0()
@end verbatim

@node Optimizer Control, Overlaying BATs, TRACE Statement,  Runtime Features
@subsection Optimizer Control
The code produced by MonetDB/SQL is massaged by several code optimizers
to arrive at the best possible plan for evaluation.
However, for development purposes and the rare case that more control
is needed, the SQL session variable @code{optimizer} can be set
to a list of optimizers to identify the steps needed. 

@include Assets/warning.texi
@example
>set optimizer='commonExpressionRemoval,garbageCollector';
>select optimizer;
#-----------------------------------------------#
# t                                             # name
# str                                           # type
#-----------------------------------------------#
[ "commonExpressionRemoval,garbageCollector"    ]
@end example

The optimizers available to work with in the SQL context,
in various stages of maturity, are:
@multitable @columnfractions .2 .8
@item aliasRemoval
@tab Remove alias assignments
@item deadCodeRemoval
@tab Remove all code not leading to used results
@item garbageCollector
@tab Injects calls to the garbage collector to free up space.
@item expressionAccumulation
@tab Looks after arithmetic expressions, turning them into accumulator
expressions
@item factorize
@tab Produce a factory from a function
@item peephole
@tab
@item costEstimation
@tab
@item reduce
@tab Reduces the stack space claimed by variables
@item coercions
@tab Performs static coercions
@end multitable 

The final result of the optimizer steps become visible using the @code{explain}
statement modifier.  Alternatively, the @code{debug} statement modifier
in combination with the 'o' command provides access to the intermediate
optimizer results.
