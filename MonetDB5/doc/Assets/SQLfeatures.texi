@section MonetDB/SQL Features 
The SQL Implementation implementation is based on the SQL-99 standard. 
It is built incrementally over time to cope with the effort
required to realize all features. Priority is given to those
features relevant to our research and upon request from our valued
partners.

The plethora of SQL implementations also show that the standard
alone is hardly sufficient. All database systems have extended
or twisted the language definition to satisfy the needs of their
customer, to support legacy, and to better tap into the functionality
offered by their kernel implementations. 
MonetDB/SQL is bound to follow this path too. The kernel imposes
limitations on the features that can and cannot be realized.
The are summarized in @ref{Development Roadmap}.

In the context of programming support, we provide a few
primitives to simplify debugging of SQL programs. They are described
separately. The list below provides a synopsis of the SQL features
supported in the released version.

@menu
* Session Variables ::
* EXPLAIN Statement::
* DEBUG Statement::
* TRACE Statement::
* Optimizer Control::
* Overlaying the BAT storage::
@end menu

@node Session Variables, EXPLAIN Statement, MonetDB/SQL Features, MonetDB/SQL Features
@subsection Session Variables 
MonetDB/SQL supports session variables declared by the user. 
They are indistinguishable from table and column names
and can be used anywhere a literal constant is allowed.

@example
sql>DECLARE high integer;
sql>DECLARE n varchar(256);
sql>SET high=4000;
[ 1     ]
sql>SET n='monetdb';
[ 1     ]
sql>SELECT count(*) from tables where id > high;
# sys.tables # table_name
# count_id # name
# int # type
# 2 # length
[ 30    ]
@end example
The SQL variables are stored in the global temporary table @code{sessions}.
The initial state is something like:
@example
>select * from sessions;
#---------------------------------------------------------------------#
# t                     t                   t               t         # name
# str                   str                 str             int       # type
#---------------------------------------------------------------------#
[ "current_schema",       "sys",              "varchar",      1       ]
[ "current_user",         "monetdb",          "varchar",      1       ]
[ "current_role",         "monetdb",          "varchar",      0       ]
[ "current_timezone",     "0",                "sec_interval", 0       ]
[ "cache",                "true",             "boolean",      0       ]
[ "profile",              "false",            "boolean",      0       ]
[ "optimizer",            "on",               "varchar",      0       ]
[ "trace",                "false",            "boolean",      0       ]
@end example
The table is shared? private?

@itemize @bullet
@item
The @code{debug} variable takes an integer and sets the server global
debug flag (See MonetDB configuration documentation file). 
It also activates the debugger when the query is being executed.
@item
The @code{profile} variable takes a boolean and when set collects
execution statistics on the SQL queries executed in the table @code{profile}.
@item
The @code{trace} variable takes a boolean and when set lists
the execution timing of all MAL instructions to solve the SQL query.
@item
The @code{cache} variable takes a boolean and when set
SQL uses a query cache to speed up subsequent calls to identical
(up to constants) queries.
@item
The @code{optimizer} variable takes a string. It controls the
quer optimizers, See @ref{SQL}.
@end itemize

@node EXPLAIN Statement, DEBUG Statement, Session Variables, MonetDB/SQL Features
@subsection EXPLAIN Statement
The intermediate code produced by the SQL Implementation compiler can be made 
visible using the @code{explain} statement modifier. 
It gives a detailed description of the actions taken to produce the
answer. The example below illustrates what you can expect when a
simple query is pre-pended by the @code{explain} modifier.
Although the details of this program are better understood
when you have read the Chapter on @ref{MAL} 
the global structure is easy to explain.

@verbatim
>select count(*) from tables;
[ 27 ]
>explain select count(*) from tables;
#factory sql_cache.s1_0():bit;
#    _2:bat[:void,:int]  := sql.bind("sys","ptables","id",0);
#    _8:bat[:void,:int]  := sql.bind("sys","ptables","id",1);
#    _11 := bat.setWriteMode(_8);
#    _15:bat[:oid,:int]  := sql.bind("sys","ptables","id",3);
#    _18 := bat.setWriteMode(_15);
#    _24:bat[:void,:oid]  := sql.bind_dbat("sys","ptables",0);
#    _39:bat[:void,:int]  := sql.bind("sys","ttables","id",0);
#    _45:bat[:void,:oid]  := sql.bind_dbat("sys","ttables",0);
#barrier _90 := true;
#    _13 := algebra.kunion(_2,_11);
#    _20 := algebra.kdifference(_13,_18);
#    _22 := algebra.kunion(_20,_18);
#    _26 := bat.reverse(_24);
#    _28 := algebra.kdifference(_22,_26);
#    _33 := algebra.markT(_28,0@0);
#    _35 := bat.reverse(_33);
#    _37 := algebra.join(_35,_22);
#    _47 := bat.reverse(_45);
#    _49 := algebra.kdifference(_39,_47);
#    _53 := algebra.markT(_49,0@0);
#    _55 := bat.reverse(_53);
#    _57 := algebra.join(_55,_39);
#    _59 := bat.setWriteMode(_37);
#    bat.append(_59,_57);
#    _65 := algebra.markT(_59,0@0);
#    _67 := bat.reverse(_65);
#    _69 := algebra.join(_67,_59);
#    _74 := algebra.markT(_69,0@0);
#    _76 := bat.reverse(_74);
#    _78 := algebra.join(_76,_69);
#    _80 := aggr.count(_78);
#    sql.exportValue(1,"sys.tables","count_id","int",32,0,6,_80);
#    yield _90;
#    redo _90;
#exit _90;
#end s1_0;
@end verbatim

The SQL compiler keeps a limited cache of queries.
Each query is looked up in this cache based on an expression pattern 
match where the constants may take on different values.
If it doesn't exist, the query is converted into 
a @emph{factory} code block and stored in the module @code{sqlcache}. 
It consists of a prelude section, which locates
the tables of interest in the SQL catalogs.
The block between @code{barrier} and @code{yield} is the actual code
executed upon each call of this function. It is a large collection
of relational algebra operators, whose execution semantics depend
on the actual MAL engine. The @code{factory} ensures that only this part
is called when the query is executed repetitively.

The call to the cached function is included in the function @code{main},
which is the only piece of code produced if the query is used more than once.
The query cache disappears when the server is brought to a halt. 

@node DEBUG Statement, TRACE Statement, EXPLAIN Statement, MonetDB/SQL Features
@subsection DEBUG Statement

The SQL statements are translated into MAL programs, which
are optimized and stored away in an @code{sql_cache} module.
The generated code can be debugged with the MAL debugger.
It provides a simple mechanism to trace the execution, hunting
for possible errors and detect performance bottlenecks
(@ref{Runtime Inspection}).

The example below, illustrates the start of such a session:
@verbatim
>debug select count(*) from tables;
#    mdb.start()
mdb>next
#    sql_cache.s1_0()
mdb>next
#    _2:bat[:void,:int]  := sql.bind(_3="sys", _4="ptables", _5="id", _6=0)
mdb>next
#    _8:bat[:void,:int]  := sql.bind(_3="sys", _4="ptables", _5="id", _9=1)
mdb> ...
@end verbatim

@node TRACE Statement, Optimizer Control, DEBUG Statement, MonetDB/SQL Features
@subsection TRACE Statement
Inspection of the execution time of the query plan uses the debugger
facilities to time each request. The statement below illustrates
the @code{trace} statement modifier to obtain a first glimpse
on the expensive components of the query plan.

@verbatim
>trace select count(*) from tables;
#     7 usec#    mdb.setTimer(_2=true)
#    10 usec#    _2:bat[:void,:int]  := sql.bind(_3="sys", _4="ptables", _5="id", _6=0)
#     6 usec#    _8:bat[:void,:int]  := sql.bind(_3="sys", _4="ptables", _5="id", _9=1)
#    12 usec#    _11 := bat.setWriteMode(_8=<tmp_1255>bat[:void,:int]{0})
#     5 usec#    _15:bat[:oid,:int]  := sql.bind(_3="sys", _4="ptables", _5="id", _16=3)
#     3 usec#    _18 := bat.setWriteMode(_15=<tmp_1256>bat[:oid,:int]{0})
#     5 usec#    _24:bat[:void,:oid]  := sql.bind_dbat(_3="sys", _4="ptables", _6=0)
#     6 usec#    _39:bat[:void,:int]  := sql.bind(_40="sys", _41="ttables", _42="id", _43=0)
#     5 usec#    _45:bat[:void,:oid]  := sql.bind_dbat(_40="sys", _41="ttables", _43=0)
#    23 usec#    _13 := algebra.kunion(_2=<tmp_27>bat[:void,:int]{32}, _11=<tmp_1255>bat[:void,:int]{0})
#    19 usec#    _20 := algebra.kdifference(_13=<tmp_2141>bat[:void,:int]{32}, _18=<tmp_1256>bat[:oid,:int]{0})
#     7 usec#    _22 := algebra.kunion(_20=<tmp_2142>bat[:oid,:int]{32}, _18=<tmp_1256>bat[:oid,:int]{0})
#     8 usec#    _26 := bat.reverse(_24=<tmp_1254>bat[:void,:oid]{0})
#     5 usec#    _28 := algebra.kdifference(_22=<tmp_2143>bat[:oid,:int]{32}, _26=<~tmp_1254>bat[:oid,:void]{0})
#    16 usec#    _33 := algebra.markT(_28=<tmp_2144>bat[:oid,:int]{32}, _31=0@0)
#     4 usec#    _35 := bat.reverse(_33=<tmp_2145>bat[:oid,:void]{32})
#    47 usec#    _37 := algebra.join(_35=<~tmp_2145>bat[:void,:oid]{32}, _22=<tmp_2143>bat[:oid,:int]{32})
#     4 usec#    _47 := bat.reverse(_45=<tmp_1455>bat[:void,:oid]{0})
#     6 usec#    _49 := algebra.kdifference(_39=<tmp_1456>bat[:void,:int]{0}, _47=<~tmp_1455>bat[:oid,:void]{0})
#     5 usec#    _53 := algebra.markT(_49=<tmp_2146>bat[:oid,:int]{0}, _31=0@0)
#     4 usec#    _55 := bat.reverse(_53=<tmp_2150>bat[:oid,:void]{0})
#     8 usec#    _57 := algebra.join(_55=<~tmp_2150>bat[:void,:oid]{0}, _39=<tmp_1456>bat[:void,:int]{0})
#    26 usec#    _59 := bat.setWriteMode(_37=<tmp_2147>bat[:void,:int]{32})
#     9 usec#    bat.append(_59=<tmp_2147>bat[:void,:int]{32}, _57=<tmp_2151>bat[:void,:int]{0})
#    14 usec#    _65 := algebra.markT(_59=<tmp_2147>bat[:void,:int]{32}, _31=0@0)
#     4 usec#    _67 := bat.reverse(_65=<tmp_2153>bat[:oid,:void]{32})
#    11 usec#    _69 := algebra.join(_67=<~tmp_2153>bat[:void,:oid]{32}, _59=<tmp_2147>bat[:void,:int]{32})
#     5 usec#    _74 := algebra.markT(_69=<tmp_2154>bat[:void,:int]{32}, _72=0@0)
#     3 usec#    _76 := bat.reverse(_74=<tmp_2152>bat[:oid,:void]{32})
#    10 usec#    _78 := algebra.join(_76=<~tmp_2152>bat[:void,:oid]{32}, _69=<tmp_2154>bat[:void,:int]{32})
#     4 usec#    _80 := aggr.count(_78=<tmp_2156>bat[:void,:int]{32})
&1 0 1 1 1
# sys.tables # table_name
# count_id # name
# int # type
# 2 # length
[ 32    ]
#    36 usec#    sql.exportValue(_83=1, _84="sys.tables", _85="count_id", _86="int", _87=32, _88=0, _89=6, _80=32)
#   911 usec#    sql_cache.s0_0()
@end verbatim

@node Optimizer Control, Overlaying the BAT storage, TRACE Statement,  MonetDB/SQL Features
@section Optimizer Control
The code produced by MonetDB/SQL is massaged by several code optimizers
to arrive at the best possible plan for evaluation.
However, for development purposes and the rare case that more control
is needed, the SQL session variable @code{optimizer} can be set
to a list of optimizers to identify the steps needed. 

@example
>set optimizer='commonExpressionRemoval,garbageCollector';
>select optimizer;
#-----------------------------------------------#
# t                                             # name
# str                                           # type
#-----------------------------------------------#
[ "commonExpressionRemoval,garbageCollector"    ]
@end example

The optimizers available to work with in the SQL context,
in various stages of maturity, are:
@multitable @columnfractions .2 .8
@item aliasRemoval
@tab Remove alias assignments
@item deadCodeRemoval
@tab Remove all code not leading to used results
@item garbageCollector
@tab Injects calls to the garbage collector to free up space.
@item expressionAccumulation
@tab Looks after aritmetic expressions, turning them into accumulator
expressions
@item factorize
@tab Produce a factory from a function
@item peephole
@tab
@item costEstimation
@tab
@item reduce
@tab Reduces the stack space claimed by variables
@item coercions
@tab Performs static coercions
@end multitable 

The final result the optimizer steps become visible using the @code{explain}
statement modifier.  Alternatively, the @code{debug} statement modifier
in combination with the 'o' command provides access to the intermediate
optimizer results.

@node Overlaying the BAT storage,XQuery, Optimizer Control,  MonetDB/SQL Features
@section Overlaying the BAT storage
The SQL implementation exploits many facilities of the underlying
MonetDB kernel. Most notably, its efficient column-wise storage
scheme with associated algebraic primitives.
However, this kernel can also be programmed directly using the
MonetDB Assembler Language (MAL), which provides a much richer
set of operators then strictly necessary for a correct implementation
and execution of SQL

Although the BATs used for SQL storage can be manipulated directly
at the MAL layer, it is strongly discouraged. For, SQL uses a
rather complex administration to realise transaction safety.
Working at the MAL layer directly could easily compromise
the integrity of the system as a whole.

However, there are cases where access to a collection of BATs from
the SQL environment can be handy. For example, to inspect some
of the system tables maintained in the kernel.
This functionality is realised using an variation of the @code{view
statement}. It is best illustrated with a short example.

First, create in MonetDB the BATs of interest. Only void-BATs are allowed
and the user should guarantee that they are aligned.
@example
a:=bat.new(:void,:int);
b:=bat.new(:void,:str);
bat.setSequenceBase(a,0@@0);
bat.setSequenceBase(b,0@@0);
bat.setPersistent(a);
bat.setPersistent(b);
bat.setName(a,"age");
bat.setName(b,"name");
@end example
These BATs can be filled with attribute values, but make sure
that all BATs are given an equal number of tuples.
To conclude, commit the database to disk, whereafter the BATs
become available to SQL, once you restart Mserver/SQL.
@example
bat.append(a, 32);
bat.append(b, "John");
bat.append(a, 31);
bat.append(b, "Mary");
transaction.commit(a,b);
@end example
The BATs are made visible for read-only access using the a column
specification. As it normally expects identifiers, we have to use
double quotes instead.
@example
CREATE VIEW friends ("age","name") AS BATS;
@end example
At this point the content of the BATs can be queried
using ordinary SQL queries. Updates are prohibited.
