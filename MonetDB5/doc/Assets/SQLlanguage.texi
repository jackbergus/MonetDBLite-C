@section SQL Language 
The MonetDB/SQL language follows the SQL-2003 specification. This section
introduces the language components supported in the current and upcoming
releases.

@menu
* SQL Preface::
* SQL Data Definition ::
* SQL Data Types::
* SQL Data Manipulation ::
* SQL Schema Definition::
* SQL Users:: 
* SQL Transactions ::
@end menu

@node SQL Preface, SQL Data Definition, SQL Language, SQL Language
Todo explain notation espesialy the extra bits.

+ extra syntax
- 2003 syntax but not supported

Currently we have partial support for SQL-2003. Features are added when 
(enough) users express their interest in these.

@itemize @bullet
@item 
Cursors, because the underlying engine is not based on record iterators.
@item Triggers
They will be supported in a future release.
@item 
Asserts
They will be supported in a future release.
@item 
Domains
@item 
Collate 
@item 
Character sets
@item 
SQL User Defined Types 
@end itemize

@node SQL Data Definition, SQL Data Types, SQL Preface, SQL Language

@subsection Create TABLE

@verbatim
The CREATE table statement follows the 2003 syntax, ie 

	CREATE [ <table scope> ] TABLE 
		<table name> 
		<table contents source>
		[ ON COMMIT <table commit action> ROWS ]
		+[ ON COMMIT DROP ]

	<table scope> ::= <global or local> TEMPORARY

	<global or local> ::= GLOBAL | LOCAL

	<table commit action> ::= PRESERVE | DELETE

The parser currently supports the full <table scope> specifier, but the 
implementation is limited to LOCAL TEMPORARY tables 
(ie the tables are only visable in the clients session) and 
on COMMIT we 'DROP' these temporaries. 

<table contents source> ::=
		<table element list>
	-|	OF <path-resolved user-defined type name> [ <subtable clause> ] [ <table element list> ]
	-|	<as subquery clause>

<table element list> ::= ( <table element> [ { , <table element> }... ] )

<table element> ::=
		<column definition>
	|	<table constraint definition>
	|	<like clause>
	-|	<self-referencing column specification>
	|	<column options>

-<self-referencing column specification> ::= REF IS <self-referencing column name> <reference generation>

-<reference generation> ::= SYSTEM GENERATED | USER GENERATED | DERIVED

-<self-referencing column name> ::= <column name>

<column options> ::= <column name> WITH OPTIONS <column option list>

<column option list> ::= [ -<scope clause> ] [ <default clause> ] [ <column constraint definition>... ]

-<subtable clause> ::= UNDER <supertable clause>

-<supertable clause> ::= <supertable name>

-<supertable name> ::= <table name>

@node create table like 
<like clause> ::= LIKE <table name> [ <like options> ]

-<like options> ::= <identity option> | <column default option>

It is posible to create a table which looks like an existing table. This 
can be done using the create table like statement. Currently there is no
support for additional options. A work around is to use the alter
statement to change options.

-<identity option> ::= INCLUDING IDENTITY | EXCLUDING IDENTITY

-<column default option> ::= INCLUDING DEFAULTS | EXCLUDING DEFAULTS

-<as subquery clause> ::= [ ( <column name list> ) ] AS <subquery> <with or without data>

-<with or without data> ::= WITH NO DATA | WITH DATA
	
@node columns


<column definition> ::=
                <column name> [ <data type> | -<domain name> ] [ -<reference scope check> ]
                [ <default clause> | <identity column specification> | -<generation clause> ]
                [ <column constraint definition>... ] [ -<collate clause> ]

@node Identity column
SQL 2003 added identity columns, which are columns for which the values are
coming from a sequenc generator. Besides the SQL 2003 syntax also the 
syntax from mysql (auto_increment) and postgress (serial data type) are 
supported.

<identity column specification> ::=
                GENERATED { ALWAYS | BY DEFAULT } AS IDENTITY
                [ ( <common sequence generator options> ) ]
	+| 	auto_increment

-<generation clause> ::= <generation rule> AS <generation expression>

-<generation rule> ::= GENERATED ALWAYS

-<generation expression> ::= ( <value expression> )

@node Default values
%--p
%Specify the default for a column, domain, or attribute.
%--/p
% as domain/attribute are currently not support default values are only 
% important for columns

To make insert statements easier a default value can associated with
each column. Besides literal values, temporal and sequence functions 
can be used as default value. Value of these functions at insert time will
be used. 

<default clause> ::= DEFAULT <default option>

<default option> ::=
                <literal>
        |       <datetime value function>
        |       USER
        |       CURRENT_USER
        |       CURRENT_ROLE
        |       SESSION_USER
        |       NULL
	+|	NEXT VALUE FOR <sequence name>
@end verbatim

@node Column and Table Constraints 
Column and Table constraints are supported. Besides the simple NOT NULL check
also UNIQUE, PRIMARY and FOREIGN keys are supported. The limitation stems from
the missing triggers, ie we currently check constraints directly on insert, 
update and delete. The NULL matching on foreign keys is limited to the SIMPLE
MATCH type (NULL values statisfy the constraint). The FULL and PARTIAL MATCH
types are not supported. The referential action is currently limited to 
RESTRICT, ie an update fails if a other columns have references to it. 

<column constraint definition> ::= [ <constraint name definition> ] <column constraint> [ <constraint characteristics> ]

<column constraint> ::=
                NOT NULL
        |       <unique specification>
        |       <references specification>
        -|       <check constraint definition>

% we need to update to the new 2003 syntax soon...

<reference scope check> ::= REFERENCES ARE [ NOT ] CHECKED [ ON DELETE <reference scope check action> ]

<reference scope check action> ::= <referential action>

--h3 11.6 <table constraint definition> (p543)
--/h3

--p 
Specify an integrity constraint.
--/p

<table constraint definition> ::= [ <constraint name definition> ] <table constraint> [ <constraint characteristics> ]

<table constraint> ::=
		<unique constraint definition>
	|	<referential constraint definition>
	|	<check constraint definition>


<unique constraint definition> ::=
		<unique specification> ( <unique column list> )
	-|	UNIQUE ( VALUE )

<unique specification> ::= UNIQUE | PRIMARY KEY

<unique column list> ::= <column name list>

--h3 11.8 <referential constraint definition> (p547)
--/h3

--p 
Specify a referential constraint.
--/p

<referential constraint definition> ::= FOREIGN KEY ( <referencing columns> ) <references specification>

<references specification> ::= REFERENCES <referenced table and columns> [ MATCH <match type> ] [ <referential triggered action> ]

<match type> ::= FULL | PARTIAL | SIMPLE

<referencing columns> ::= <reference column list>

<referenced table and columns> ::= <table name> [ <left paren> <reference column list> <right paren> ]

<reference column list> ::= <column name list>

<referential triggered action> ::= <update rule> [ <delete rule> ] | <delete rule> [ <update rule> ]

<update rule> ::= ON UPDATE <referential action>

<delete rule> ::= ON DELETE <referential action>

<referential action> ::= CASCADE | SET NULL | SET DEFAULT | RESTRICT | NO ACTION

--h3 11.9 <check constraint definition> (p567)
--/h3

--p 
Specify a condition for the SQL-data.
--/p

<check constraint definition> ::= CHECK <left paren> <search condition> <right paren>

--h3 11.10 <alter table statement> (p569)
--/h3

@node SQL Data Types, SQL Data Manipulation, SQL Data Definition, SQL Language
@subsection SQL Data Types

@node SQL Data Manipulation, SQL Schema Definition, SQL Data Types, SQL Language
@subsection SQL Data Manipulation

@node SQL Schema Definition, SQL Users, SQL Data Manipulation, SQL Language
@subsection SQL Schema Definition

@node SQL Users, SQL Transactions, SQL Schema Definition, SQL Language
@subsection SQL Users

@node SQL Transactions, MonetDB/SQL Features , SQL Users, SQL Language
@subsection SQL Transactions

For example an auto increment column can be created using the following
column specification:
	col_name integer default NEXT VALUE FOR sequence_name
