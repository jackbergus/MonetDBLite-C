@section SQL Language 
The MonetDB/SQL language follows the SQL-2003 specification. This section
introduces the language components supported in the current and upcoming
releases.

@menu
* SQL Preface::
* SQL Data Definition ::
* SQL Data Types::
* SQL Data Manipulation ::
* SQL Schema Definition::
* SQL Users:: 
* SQL Transactions::
@end menu

@node SQL Preface, SQL Data Definition, SQL Language , SQL Language
@subsection SQL Preface
We use the following notation to explain the supported variation SQL.
The SQL syntax is summarized in extended BNF. Alternative constructs 
are seperated by | and grouped by parenthesis. Optional parts are 
marked with square brackets. A repetition is marked with either '+' 
or '*' to indicate at least once and many times, respectively.
Lexical tokens are illustrated in capitals.

Sometimes MonetDB/SQL supports extra syntax this is identified by a
'+' before the clause. Unfortunately, we do not support the full
SQL 2003 jet and this is specified by a '-' before the clause. 

Currently we have partial support for SQL-2003. Features are added when 
(enough) users express their interest in these.

@itemize @bullet
@item 
Cursors, because the underlying engine is not based on record iterators.
@item Triggers
They will be supported in a future release.
@item 
Asserts
They will be supported in a future release.
@item 
Domains
@item 
Collate 
@item 
Character sets
@item 
SQL User Defined Types 
@end itemize

@node SQL Data Definition, SQL Data Types, SQL Preface, SQL Language

@subsection SQL Data Definition
@subsubsection Create TABLE

The parser currently supports the full <table scope> specifier, but the 
implementation is limited to LOCAL TEMPORARY tables 
(ie the tables are only visable in the clients session) and 
on COMMIT we 'DROP' these temporaries. 


@verbatim
The CREATE table statement follows the 2003 syntax, ie 

	CREATE [ <table scope> ] TABLE 
		<table name> 
		<table contents source>
		[ ON COMMIT <table commit action> ROWS ]
		+[ ON COMMIT DROP ]

	<table scope> ::= <global or local> TEMPORARY

	<global or local> ::= GLOBAL | LOCAL

	<table commit action> ::= PRESERVE | DELETE

<table contents source> ::=
		<table element list>
	-|	OF <path-resolved user-defined type name> [ <subtable clause> ] [ <table element list> ]
	-|	<as subquery clause>

<table element list> ::= ( <table element> [ { , <table element> }... ] )

<table element> ::=
		<column definition>
	|	<table constraint definition>
	|	<like clause>
	-|	<self-referencing column specification>
	|	<column options>

-<self-referencing column specification> ::= REF IS <self-referencing column name> <reference generation>

-<reference generation> ::= SYSTEM GENERATED | USER GENERATED | DERIVED

-<self-referencing column name> ::= <column name>

<column options> ::= <column name> WITH OPTIONS <column option list>

<column option list> ::= [ -<scope clause> ] [ <default clause> ] [ <column constraint definition>... ]

-<subtable clause> ::= UNDER <supertable clause>

-<supertable clause> ::= <supertable name>

-<supertable name> ::= <table name>
@end verbatim

@subsubsection create table like 

It is posible to create a table which looks like an existing table. This 
can be done using the create table like statement. Currently there is no
support for additional options. A work around is to use the alter
statement to change options.

@verbatim
<like clause> ::= LIKE <table name> [ <like options> ]

-<like options> ::= <identity option> | <column default option>

-<identity option> ::= INCLUDING IDENTITY | EXCLUDING IDENTITY

-<column default option> ::= INCLUDING DEFAULTS | EXCLUDING DEFAULTS

-<as subquery clause> ::= [ ( <column name list> ) ] AS <subquery> <with or without data>

-<with or without data> ::= WITH NO DATA | WITH DATA
@end verbatim
	
@subsubsection columns

@verbatim
<column definition> ::=
                <column name> [ <data type> | -<domain name> ] [ -<reference scope check> ]
                [ <default clause> | <identity column specification> | -<generation clause> ]
                [ <column constraint definition>... ] [ -<collate clause> ]
@end verbatim

@subsubsection Identity column
SQL 2003 added identity columns, which are columns for which the values are
coming from a sequenc generator. Besides the SQL 2003 syntax also the 
syntax from mysql (auto_increment) and postgress (serial data type) are 
supported.

@verbatim
<identity column specification> ::=
                GENERATED { ALWAYS | BY DEFAULT } AS IDENTITY
                [ ( <common sequence generator options> ) ]
	+| 	auto_increment

-<generation clause> ::= <generation rule> AS <generation expression>

-<generation rule> ::= GENERATED ALWAYS

-<generation expression> ::= ( <value expression> )
@end verbatim

@subsubsection Default values
@c --p
@c Specify the default for a column, domain, or attribute.
@c --/p
@c  as domain/attribute are currently not support default values are only 
@c  important for columns

To make insert statements easier a default value can associated with
each column. Besides literal values, temporal and sequence functions 
can be used as default value. Value of these functions at insert time will
be used. 

@verbatim
<default clause> ::= DEFAULT <default option>

<default option> ::=
                <literal>
        |       <datetime value function>
        |       USER
        |       CURRENT_USER
        |       CURRENT_ROLE
        |       SESSION_USER
        |       NULL
	+|	NEXT VALUE FOR <sequence name>
@end verbatim

For example an auto increment column can be created using the following
column specification:
	col_name integer default NEXT VALUE FOR sequence_name

@subsubsection Column and Table Constraints 
Column and Table constraints are supported. Besides the simple NOT NULL check
also UNIQUE, PRIMARY and FOREIGN keys are supported. The limitation stems from
the missing triggers, ie we currently check constraints directly on insert, 
update and delete. The NULL matching on foreign keys is limited to the SIMPLE
MATCH type (NULL values statisfy the constraint). The FULL and PARTIAL MATCH
types are not supported. The referential action is currently limited to 
RESTRICT, ie an update fails if a other columns have references to it. 

@verbatim
<column constraint definition> ::= [ <constraint name definition> ] <column constraint> [ <constraint characteristics> ]

<column constraint> ::=
                NOT NULL
        |       <unique specification>
        |       <references specification>
        -|       <check constraint definition>

@c  we need to update to the new 2003 syntax soon...

<reference scope check> ::= REFERENCES ARE [ NOT ] CHECKED [ ON DELETE <reference scope check action> ]

<reference scope check action> ::= <referential action>

--h3 11.6 <table constraint definition> (p543)
--/h3

--p 
Specify an integrity constraint.
--/p

<table constraint definition> ::= [ <constraint name definition> ] <table constraint> [ <constraint characteristics> ]

<table constraint> ::=
		<unique constraint definition>
	|	<referential constraint definition>
	|	<check constraint definition>


<unique constraint definition> ::=
		<unique specification> ( <unique column list> )
	-|	UNIQUE ( VALUE )

<unique specification> ::= UNIQUE | PRIMARY KEY

<unique column list> ::= <column name list>

--h3 11.8 <referential constraint definition> (p547)
--/h3

--p 
Specify a referential constraint.
--/p

<referential constraint definition> ::= FOREIGN KEY ( <referencing columns> ) <references specification>

<references specification> ::= REFERENCES <referenced table and columns> [ MATCH <match type> ] [ <referential triggered action> ]

<match type> ::= FULL | PARTIAL | SIMPLE

<referencing columns> ::= <reference column list>

<referenced table and columns> ::= <table name> [ ( <reference column list> ) ]

<reference column list> ::= <column name list>

<referential triggered action> ::= <update rule> [ <delete rule> ] | <delete rule> [ <update rule> ]

<update rule> ::= ON UPDATE <referential action>

<delete rule> ::= ON DELETE <referential action>

<referential action> ::= CASCADE | SET NULL | SET DEFAULT | RESTRICT | NO ACTION

--h3 11.9 <check constraint definition> (p567)
--/h3

--p 
Specify a condition for the SQL-data.
--/p

<check constraint definition> ::= CHECK ( <search condition> )

@end verbatim
@subsubsection CREATE VIEW

@verbatim
<view definition> ::=
                CREATE -[ RECURSIVE ] VIEW <table name> <view specification> AS <query expression>
                [ WITH -[ <levels clause> ] CHECK OPTION ]

<view specification> ::= <regular view specification> | <referenceable view specification>

<regular view specification> ::= [ ( <view column list> ) ]

-<referenceable view specification> ::= OF <path-resolved user-defined type name> [ <subview clause> ] [ <view element list> ]

-<subview clause> ::= UNDER <table name>

<view element list> ::= ( <view element> [ { , <view element> }... ] )

<view element> ::= <self-referencing column specification> | <view column option>

<view column option> ::= <column name> WITH OPTIONS -<scope clause>

<levels clause> ::= CASCADED | LOCAL

<view column list> ::= <column name list>

@end verbatim


@node SQL Data Types, SQL Data Manipulation, SQL Data Definition, SQL Language
@subsection SQL Data Types
MonetDB/SQL supports the following list of types. 

@multitable {VARCHAR (L) | CHARACTER VARYING (L) :} {special 64 bit integer (sequence generator)}
@c @item SQLSTATE ?			@tab
@item CHAR[ACTER] (L) 
@tab character string with length L
@item VARCHAR (L) | CHARACTER VARYING (L)
@tab string with atmost length L
@item CLOB | CHARACTER LARGE OBJECT	
@item BLOB | BINARY LARGE OBJECT	
@item DECIMAL(P,S) | NUMERIC(P,S)	
@item SMALLINT				
@tab 16 bit integer
@item INT				
@tab 32 bit integer
@item BIGINT				
@tab 64 bit integer
@item serial				
@tab special 64 bit integer (sequence generator) 
@item REAL				
@tab 32 bit floating point
@item DOUBLE [PRECISION]		
@tab 64 bit floating point
@item BOO[LEAN]
@item DATE
@item TIME(T)
@item TIMESTAMP(T)
@item INTERVAL(Q)
@c @item user-defined type
@c @item REF				@tab char, with length N 
@c @item ROW
@c @item ARRAY
@c @item MULTISET
@end multitable

@node SQL Data Manipulation, SQL Schema Definition, SQL Data Types, SQL Language
@subsection SQL Data Manipulation

@node SQL Schema Definition, SQL Users, SQL Data Manipulation, SQL Language
@subsection SQL Schema Definition

@node SQL Users, SQL Transactions, SQL Schema Definition, SQL Language
@subsection SQL Users

@node SQL Transactions, MonetDB/SQL Features, SQL Users, SQL Language
@subsection SQL Transactions
