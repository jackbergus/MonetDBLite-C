@section SQL Language 
The MonetDB/SQL language follows the SQL-2003 specification. This section
introduces the language components supported in the current and upcoming
releases.

@menu
* SQL Preface::
* SQL Comments ::
* SQL Data Definition ::
* SQL Data Types::
* SQL Data Manipulation ::
* SQL Schema Definition::
* SQL Users:: 
* SQL Transactions::
@end menu

@node SQL Preface, SQL Comments, SQL Language , SQL Language
@subsection SQL Preface
We use the following notation to explain the supported variation SQL.
The SQL syntax is summarized in extended BNF. Alternative constructs 
are separated by | and grouped by parentheses. Optional parts are 
marked with square brackets. A repetition is marked with either '+' 
or '*' to indicate at least once and many times, respectively.
Lexical tokens are illustrated in capitals.

Sometimes MonetDB/SQL supports extra syntax that is identified by a
'+' before the clause. Unfortunately, we do not support the full
SQL 2003 yet and this is specified by a '-' before the clause. 
If next to the '-' a '<' and version number are given the feature is supported
in the older releases.

Currently we have partial support for SQL-2003. Features are added when 
(enough) users express their interest in these. Some of the currently not supported features are:

@itemize @bullet
@item 
Cursors, because the underlying engine is not based on record iterators.
@item Triggers
They will be supported in a future release.
@item 
Asserts
They will be supported in a future release.
@item 
Domains
@item 
Collate 
@item 
Character sets
@item 
SQL User Defined Types 
@end itemize

@node SQL Comments, SQL Data Definition, SQL Preface, SQL Language

@subsection SQL Comments
Comments can be added to query scripts for documentation purposes.
MonetDB/SQL supports two forms of comments. Any text beginning with '- -'
and up to the end of line is ignored. Furthermore, C-style comments
can be injected in a SQL query where a language token is expected.
@example
sql>-- this is comment
sql>select /* ignore this */ 3;
# . # table_name
# single_value # name
# smallint # type
# 1 # length
[ 3     ]
@end example

@node SQL Data Definition, SQL Data Types, SQL Comments, SQL Language
@subsection SQL Data Definition
@subsubsection Create Table

The parser currently supports the full <table scope> specifier, but the 
implementation is limited to LOCAL TEMPORARY tables 
(i.e. the tables are only visible in the clients session) and 
on COMMIT we 'DROP' these temporaries. 

The CREATE table statement follows the SQL-2003 syntax: 

@verbatim
	CREATE [ <table scope> ] TABLE 
		<table name> 
		<table contents source>
		[ ON COMMIT <table commit action> ROWS ]
		+[ ON COMMIT DROP ]

	<table scope> ::= <global or local> TEMPORARY

	<global or local> ::= GLOBAL | LOCAL

	<table commit action> ::= PRESERVE | DELETE

<table contents source> ::=
		<table element list>
	-|	OF <path-resolved user-defined type name> [ <subtable clause> ] [ <table element list> ]
	-<3.0|	<as subquery clause>

<table element list> ::= ( <table element> [ { , <table element> }... ] )

<table element> ::=
		<column definition>
	|	<table constraint definition>
	|	<like clause>
	-|	<self-referencing column specification>
	|	<column options>

-<self-referencing column specification> ::= REF IS <self-referencing column name> <reference generation>

-<reference generation> ::= SYSTEM GENERATED | USER GENERATED | DERIVED

-<self-referencing column name> ::= <column name>

<column options> ::= <column name> WITH OPTIONS <column option list>

<column option list> ::= [ -<scope clause> ] [ <default clause> ] [ <column constraint definition>... ]

-<subtable clause> ::= UNDER <supertable clause>

-<supertable clause> ::= <supertable name>

-<supertable name> ::= <table name>
@end verbatim

@subsubsection Create Table Like 

It is posible to create a table which looks like an existing table. This 
can be done using the create table like statement. Currently there is no
support for additional options. A work around is to use the alter
statement to change the options.

@verbatim
<like clause> ::= LIKE <table name> [ <like options> ]

-<like options> ::= <identity option> | <column default option>

-<identity option> ::= INCLUDING IDENTITY | EXCLUDING IDENTITY

-<column default option> ::= INCLUDING DEFAULTS | EXCLUDING DEFAULTS
@end verbatim

@subsubsection Create Table AS Subquery
As of version 3.0 support is added for table construction based on subqueries.

@verbatim
-<3.0	<as subquery clause> ::= [ ( <column name list> ) ] AS <subquery> <with or without data>

-<3.0	<with or without data> ::= WITH NO DATA | WITH DATA
@end verbatim
	
@subsubsection Columns

@verbatim
<column definition> ::=
                <column name> [ <data type> | -<domain name> ] [ -<reference scope check> ]
                [ <default clause> | <identity column specification> | -<generation clause> ]
                [ <column constraint definition>... ] [ -<collate clause> ]
@end verbatim

@subsubsection Identity Column
SQL-2003 added identity columns, which are columns for which the values are
coming from a sequence generator. Besides the SQL-2003 standard the 
syntax from MySql (auto_increment) and Postgress (serial data type) are also
supported.

@verbatim
<identity column specification> ::=
                GENERATED { ALWAYS | BY DEFAULT } AS IDENTITY
                [ ( <common sequence generator options> ) ]
	+| 	auto_increment

-<generation clause> ::= <generation rule> AS <generation expression>

-<generation rule> ::= GENERATED ALWAYS

-<generation expression> ::= ( <value expression> )
@end verbatim

@subsubsection Default values
@c --p
@c Specify the default for a column, domain, or attribute.
@c --/p
@c  as domain/attribute are currently not support default values are only 
@c  important for columns

To make insert statements easier a default value can be associated with
each column. Besides literal values, temporal and sequence functions 
can be used as default values. The value of these functions at insert time will
be used. 
@c todo explain that our DEFAULT is more powerfull (like postgress), ie 
@c support any function not just temporal and sequence related

@verbatim
<default clause> ::= DEFAULT <default option>

<default option> ::=
                <literal>
        |       <datetime value function>
        |       USER
        |       CURRENT_USER
        |       CURRENT_ROLE
        |       SESSION_USER
        |       NULL
	+|	NEXT VALUE FOR <sequence name>
@end verbatim

For example an auto increment column can be created using the following
column specification:
	col_name integer default NEXT VALUE FOR sequence_name

@subsubsection Column and Table Constraints 
Column and Table constraints are supported. Besides the simple NOT NULL check
also UNIQUE, PRIMARY and FOREIGN keys are supported. The limitation stems from
the missing triggers, ie we currently check constraints directly on insert, 
update and delete. The NULL matching on foreign keys is limited to the SIMPLE
MATCH type (NULL values statisfy the constraint). The FULL and PARTIAL MATCH
types are not supported. The referential action is currently limited to 
RESTRICT, ie an update fails if other columns have references to it. 

@verbatim
<column constraint definition> ::= [ <constraint name definition> ]
               <column constraint> [ <constraint characteristics> ]

<column constraint> ::=
                NOT NULL
        |       <unique specification>
        |       <references specification>
        -|       <check constraint definition>

@c  we need to update to the new 2003 syntax soon...

<reference scope check> ::= REFERENCES ARE [ NOT ] CHECKED [ ON DELETE <reference scope check action> ]

<reference scope check action> ::= <referential action>

--h3 11.6 <table constraint definition> (p543)
--/h3

--p 
Specify an integrity constraint.
--/p

<table constraint definition> ::= [ <constraint name definition> ] <table constraint> [ <constraint characteristics> ]

<table constraint> ::=
		<unique constraint definition>
	|	<referential constraint definition>
	|	<check constraint definition>


<unique constraint definition> ::=
		<unique specification> ( <unique column list> )
	-|	UNIQUE ( VALUE )

<unique specification> ::= UNIQUE | PRIMARY KEY

<unique column list> ::= <column name list>

--h3 11.8 <referential constraint definition> (p547)
--/h3

--p 
Specify a referential constraint.
--/p

<referential constraint definition> ::= FOREIGN KEY ( <referencing columns> ) <references specification>

<references specification> ::= REFERENCES <referenced table and columns> [ MATCH <match type> ] [ <referential triggered action> ]

<match type> ::= FULL | PARTIAL | SIMPLE

<referencing columns> ::= <reference column list>

<referenced table and columns> ::= <table name> [ ( <reference column list> ) ]

<reference column list> ::= <column name list>

<referential triggered action> ::= <update rule> [ <delete rule> ] | <delete rule> [ <update rule> ]

<update rule> ::= ON UPDATE <referential action>

<delete rule> ::= ON DELETE <referential action>

<referential action> ::= CASCADE | SET NULL | SET DEFAULT | RESTRICT | NO ACTION

<check constraint definition> ::= CHECK ( <search condition> )

@subsubsection ALTER TABLE

<alter table statement> ::= ALTER TABLE <table name> <alter table action>

<alter table action> ::=
		<add column definition>
	|	<alter column definition>
	|	<drop column definition>
	|	<add table constraint definition>
	|	<drop table constraint definition>

@subsubsection ADD column

<add column definition> ::= ADD [ COLUMN ] <column definition>

@subsubsection ALTER column

<alter column definition> ::= ALTER [ COLUMN ] <column name> <alter column action>
<alter column action> ::=
		<set column default clause>
	|	<drop column default clause>
	|	<add column scope clause>
	|	<drop column scope clause>
	|	<alter identity column specification>

<set column default clause> ::= SET <default clause>
<drop column default clause> ::= DROP DEFAULT
-<add column scope clause> ::= ADD <scope clause>
-<drop column scope clause> ::= DROP SCOPE <drop behavior>

<alter identity column specification> ::= <alter identity column option>...

<alter identity column option> ::=
		<alter sequence generator restart option>
	|	SET <basic sequence generator option>

<drop column definition> ::= DROP [ COLUMN ] <column name> <drop behavior>

@subsubsection ADD constraint
<add table constraint definition> ::= ADD <table constraint definition>
<drop table constraint definition> ::= DROP CONSTRAINT <constraint name> <drop behavior>

@subsubsection DROP table
<drop table statement> ::= DROP TABLE <table name> <drop behavior>


@end verbatim
@subsubsection CREATE VIEW
Regular view specifications are supported. However, recursive views and 
referenceable views are not supported. Next to this 2003 feature we support 
creating a view on top of a set of bats. In this case the query expression is
replaced by the keyword BATS, and the bats are found based on the
view specification. As this feature requires indepth knowledge of 
the system it is only open to the ADMIN_ROLE. 

@verbatim
<view definition> ::=
                CREATE -[ RECURSIVE ] VIEW <table name> <view specification> AS <view query expression>
                [ WITH -[ <levels clause> ] CHECK OPTION ]

<view query expression> ::=
	<query expression>
 +|	BATS

<view specification> ::= <regular view specification> | <referenceable view specification>

<regular view specification> ::= [ ( <view column list> ) ]

-<referenceable view specification> ::= OF <path-resolved user-defined type name> [ <subview clause> ] [ <view element list> ]

-<subview clause> ::= UNDER <table name>

<view element list> ::= ( <view element> [ { , <view element> }... ] )

<view element> ::= <self-referencing column specification> | <view column option>

<view column option> ::= <column name> WITH OPTIONS -<scope clause>

<levels clause> ::= CASCADED | LOCAL

<view column list> ::= <column name list>

@end verbatim

@node SQL Data Types, SQL Data Manipulation, SQL Data Definition, SQL Language
@subsection SQL Data Types
MonetDB/SQL supports the following list of types. 

@multitable {VARCHAR (L) | CHARACTER VARYING (L) :} {special 64 bit integer (sequence generator)}
@c @item SQLSTATE ?			@tab
@item CHAR[ACTER] (L) 
@tab character string with length L
@item VARCHAR (L) | CHARACTER VARYING (L)
@tab string with atmost length L
@item CLOB | CHARACTER LARGE OBJECT	
@item BLOB | BINARY LARGE OBJECT	
@item DECIMAL(P,S) | NUMERIC(P,S)	
@item SMALLINT				
@tab 16 bit integer
@item INT				
@tab 32 bit integer
@item BIGINT				
@tab 64 bit integer
@item serial				
@tab special 64 bit integer (sequence generator) 
@item REAL				
@tab 32 bit floating point
@item DOUBLE [PRECISION]		
@tab 64 bit floating point
@item BOO[LEAN]
@item DATE
@item TIME(T)
@item TIMESTAMP(T)
@item INTERVAL(Q)
@c @item user-defined type
@c @item REF				@tab char, with length N 
@c @item ROW
@c @item ARRAY
@c @item MULTISET
@end multitable

@node SQL Data Manipulation, SQL Schema Definition, SQL Data Types, SQL Language
@subsection SQL Data Manipulation

@node SQL Schema Definition, SQL Users, SQL Data Manipulation, SQL Language
@subsection SQL Schema Definition

@node SQL Users, SQL Transactions, SQL Schema Definition, SQL Language
@subsection SQL Users

@node SQL Transactions, MonetDB/SQL Features, SQL Users, SQL Language
@subsection SQL Transactions
