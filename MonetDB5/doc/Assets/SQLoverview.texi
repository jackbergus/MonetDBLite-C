@chapter SQL

The de facto language for database applications is SQL.  It evolved
through several phases of standardization to the version currently
known as SQL-2003.
The SQL standard provides an ideal language framework,
in terms of standardization committee viewpoints.  It is, however,
hardly met by any of the existing (commercial) implementations.
This is largely due to legacy of old software and backward compatibility
requirements from their client base.  See for instance
@url{http://www.dbazine.com/gulutzan3.shtml,this}
on-line article on SQL standards.

The MonetDB database system was originally developed as a database back-end
kernel with its own, low-level algebraic interface and scripting language.
The development of a SQL front end has been purposely postponed to the point
where the kernel code base was sufficiently mature and field tested in
large, mission critical applications in the financial sector.

In 2002 the first version of the SQL front end emerged.
This late development made it possible to immediately start from the SQL'99
definition. As soon as the SQL'03 specifications became available, its content
was taken as the primary frame of reference.
The SQL development strategy is driven by immediate needs of the
user base, such that less-frequently used features end up low on
the development stack.

The purpose of this chapter is to give a quick introduction on the SQL
front end, its limitations, and the way to use it.  Throughout this document
proficiency in elementary use of SQL is assumed.
If you are new to this world then pick up any of the
introduction books and study it carefully.
The SQL Implementation front-end is based on the SQL-99 standard,
which is covered in many text books e.g.
@emph{J. Melton and A.R. Simon}, SQL:1999 Understanding
Relational Language Components, ISBN 1558604561.

The architecture is based on a separate compiler module, which translates 
SQL statements into MAL. In this process common optimization heuristics,
specific to relational algebra are performed.

The SQL module can be downloaded from the
@url{http://sourceforge.net/project/showfiles.php?group_id=56967,download} 
section at SourceForge. It is already included in the Windows installers.

There are bindings for SQL with JDBC, ODBC, PHP and C, 
(see @ref{User Interfaces}) to integrate seamlessly in existing 
developments environments.
Client utilities like @ref{Aqua Data Studio} and @ref{iSQL-Viewer}
work flawlessly with the MonetDB SQL implementation and make 
your experience with even better! 

The remainder of this chapter provides a short tutorial to get
going with MonetDB/SQL. A synopsis of the language features 
provides a quick intro on the scope of the current implementation
and the short list for functional enhancements planned.
The programming support sections illustrate some of the advanced
features to analyse and your SQL code.
@menu
* Getting Started with SQL::
* The VOC Tutorial::
* SQL Feature Overview::
@menu
* SQL Feature List::
* SET Statement::
* EXPLAIN Statement::
* DEBUG Statement::
@end menu
* Optimizer Control::
* Overlaying the BAT storage::
* SQL Implementation Roadmap ::
@end menu

@node Getting Started with SQL, The VOC Tutorial, SQL, SQL
@section Getting Started with MonetDB/SQL
Working with SQL requires installation of the MonetDB server 
and SQL compiler module. 
See the section @ref{Download and Installation} to get the version
for your platform.

The first step is to start the database backend, following
the steps in @ref{Start and Stop the Server} or illustrated below.
Once it runs, the easiest is to use a textual SQL client
to explore its functionality.

Under Windows, this client is already configured to directly contact
the running server. For Linux users we illustrate the actions taken
behind the scene. Packaging the command line actions in shell scripts is
straightforward.

The first action on Linux is to start the database server.
The command shown below includes a server
initialization string, which loads the SQL
module and starts to listen to the default MonetDB port for SQL connections.
It also indicates the server to run in the background.
@example
shell> Mserver --set monet-daemon=yes --dbinit="include sql;mapi.listen(45123);"
# Monet Database Server V4.99.19
# Copyright (c) 1993-2005, CWI. All rights reserved.
# Compiled for x86_64-redhat-linux-gnu/64bit with 32bit OIDs; dynamically linked.
# config:/ufs/mk/monet5/Linux/etc/MonetDB5.conf
# dbfarm:/ufs/mk/monet5/Linux/var/MonetDB5/dbfarm
# dbname:demo
# Visit http://monetdb.cwi.nl/ for further information.
#Ready to accept connections on gio.ins.cwi.nl:45123
shell>
@end example

This reply evidently depends on your installation procedure and
configuration parameters.

The interaction with the server subsequently takes place through
either a textual or graphical user interface. (See @ref{User Interfaces}).
For our explorations of SQL we use the generic MapiClient, which
is started as follows:

@example
shell> MapiClient -lsql -p45123
sql>
@end example
The client runs with the default user id @code{monetdb}.
It is ready for our first experiments.

@node The VOC Tutorial, SQL Feature Overview, Getting Started with SQL, SQL
@section The VOC tutorial
Exploring the wealth of functionality offered by MonetDB is best
started using a toy database.  An example of such database is the VOC data
set that provides a peephole view into the administrative
system of a multi-national company, 
the @emph{Vereenigde geoctrooieerde Oostindische
Compagnie} (VOC for short - The (Dutch) East Indian Company).

The VOC was granted a monopoly on the trade in the East Indies on March 20, 1602
by the representatives of the provinces of the Dutch republic.
Attached to this monopoly was the duty to fight the enemies of the Republic and
prevent other European nations to enter the East India trade.
During its history of over 200 years, the VOC became the largest company of its kind,
trading spices like nutmeg, cloves, cinnamon, pepper, and other consumer
products like tea, silk and Chinese porcelain.
Her factories or trade centers were world famous: Desjima in Japan,
Mokha in Yemen, Surat in Persia and of course Batavia,
the Company's headquarters on Java.

The history of the VOC is an active area of research and
a focal point for multi-country heritage projects, 
e.g. @url{http://www.tanap.net/content/voc/organization/organization_intro.htm, TANAP},
which includes a short historic overview of the VOC written by
world expert on the topic F. Gaastra.
The archives of the VOC are spread around the world, but a large
contingent still resides in the @url{ http://www.nationaalarchief.nl/,National Archive<},
The Hague.
The archives comprise over 25 million historical records.
Much of which has not (yet) been digitized.

The MonetDB/SQL tutorial is based on the material published in the book
J.R. Bruijn, F.S. Gaastra and I. Schaar, @emph{Dutch-Asiatic Shipping in the 17th
and 18th Centuries}, which gives an account of the trips made to the East
and ships returned safely (or wrecked on the way).  A total of 8000 records
are provided.  They include information about ship name and type, captain,
the arrival/departure of harbors along the route, personnel accounts,
and anecdotal information.

@subsection Acquiring and loading the VOC data set
The VOC data set can be downloaded from
@url{http://monetdb.cwi.nl/Assets/,the MonetDB Assets site}
as a gzipped file with SQL statements.
After the zipfile has been extracted, the file should be loaded into MonetDB
via either the Java based @ref{JdbcClient} utility, or the @ref{MapiClient}
C-program.
Alternatively, the URL to the VOC data file can be supplied to the
@ref{JdbcClient} utility, which then directly reads from the URL.

Before you load the VOC data set, it is advised to first add a different user
with its own schema to the MonetDB database.
We illustrate this process using the textual SQL client.
Make sure the MonetDB server has been started, then start the SQL client.
Under Linux you will see something like this:

@verbatim
Welcome to the MonetDB interactive JDBC terminal!
Database: MonetDB 4.9.3
Driver: MonetDB Native Driver 1.2 (Blunt-SR1)
Type \q to quit, \h for a list of available commands
auto commit mode: on
monetdb> CREATE USER "voc" WITH PASSWORD 'voc' NAME 'VOC Explorer' SCHEMA "sys";
Operation successful
monetdb> CREATE SCHEMA "voc" AUTHORIZATION "voc";
Operation successful
monetdb> ALTER USER "voc" SET SCHEMA "voc";
monetdb>\q
@end verbatim

@subsection Exploring the VOC data set
@subsection Background 

@node SQL Feature Overview, SQL Feature List, The VOC Tutorial, SQL
@section SQL Features 
The SQL Implementation implementation is based on the SQL-99 standard. 
It is built incrementally over time to cope with the effort
required to realize all features. Priority is given to those
features relevant to our research and upon request from our valued
partners.

The plethora of SQL implementations also show that the standard
alone is hardly sufficient. All database systems have extended
or twisted the language definition to satisfy the needs of their
customer, to support legacy, and to better tap into the functionality
offered by their kernel implementations. 
MonetDB/SQL is bound to follow this path too. The kernel imposes
limitations on the features that can and cannot be realized.
The are summarized in @ref{SQL Implementation Roadmap}.

In the context of programming support, we provide a few
primitives to simplify debugging of SQL programs. They are described
separately. The list below provides a synopsis of the SQL features
supported in the released version.

@node SQL Feature List, SET Statement, SQL Feature Overview, SQL
@subsection SQL-99 Feature list
In this section we give an itemized list of the SQL-99 features
supported in the current release.
@itemize
@item 
Primary and foreign key integrity enforcement.
@item
Subqueries are fully supported.
@item
Table expression @code{union} and @code{intersection}.
@item
Table views for query processing only.
@item
Binding SQL functions with to externally supplied routines.
@item
Auto-increment keys (SQL 2003).
@end itemize


@node SET Statement, EXPLAIN Statement, SQL Feature List, SQL
@subsection SET Statement

MonetDB/SQL comes with a limited variable scheme.
Globel, session based variables can be introduced using the
construct:
@example
SET <variable>=<string>
SET <variable>=<boolean>
SET <variable>=<int>
@end example
Their type is inherited from the literal value supplied.
The SQL engine comes with a limited set of environment variables
to control its behavior.
@itemize
@item
The @code{debug} variable takes an integer and sets the Mserver global
debug flag. (See MonetDB documentation) It also activates the
debugger when the query is being executed.
@item
The @code{explain} variable currently takes the values 'plan' or
'performance'. The 'plan' qualifier produces a relational table with
the plan derived for execution using the applicable back end and
optimizer schemes. The 'performance' qualifier produces a performance
trace of the SQL queries for post analysis. It is available in
the system table called @code{history}. Omission of either qualifier merely
results in a straight execution of the query.
@item

The @code{auto_commit} variable takes a boolean and controls automatic commit
after a successful SQL execution, or conversely an automatic rollback.

@item
The @code{reply_size} limits the number of tuples sent to the front end.
[It is unclear how the remainder can be obtained within the SQL language
framework. The reply_size should be replaced by the @code{limit} language
construct]

@item
The @code{history} variable is a boolean flag which leads to 
capturing execution information of any SQL query in a table for post-analysis.
@end itemize

By default all remaining variables are stored as strings and
any type analysis is up to the user. The can be freely used by the
SQL programmer for inclusion in his queries. [TODO, a little more
flexibilty would mean a lot]

The variables and their type definition are assembled in a system table
called 'sessions'. Its default content is shown below:
@example
>select * from sessions;
#---------------------------------------------------------------------#
# t                     t                   t               t         # name
# str                   str                 str             int       # type
#---------------------------------------------------------------------#
[ "debug",                "0",                "int",          0       ]
[ "reply_size",           "-1",               "int",          0       ]
[ "explain",              "",                 "varchar",      0       ]
[ "auto_commit",          "false",            "boolean",      0       ]
[ "current_schema",       "sys",              "varchar",      1       ]
[ "current_user",         "monetdb",          "varchar",      1       ]
[ "current_role",         "monetdb",          "varchar",      0       ]
[ "current_timezone",     "0",                "sec_interval", 0       ]
[ "optimizer",            "yes",              "varchar",      0       ]
@end example

@node EXPLAIN Statement, DEBUG Statement, SET Statement, SQL
@subsection EXPLAIN Statement
The intermediate code produced by the SQL Implementation compiler can be made 
visible using the @code{explain} statement modifier. 
It gives a detailed description of the actions taken to produce the
answer. The example below illustrates what you can expect when a
simple query is pre-pended by the @code{explain} modifier.
Although the details of this program are better understood
when you have read the Chapter on MAL @ref{MonetDB Assembler Language}
the global structure is easy to explain.

@verbatim
>select count(*) from tables;
[ 23 ]
>explain select count(*) from tables;
#function user.main():int;
#    sql_cache.sql1();
#end main;
#factory sql_cache.sql1():any;
#    _1{count=0} := sql.bind("sys","ptables","id",0);
#    _6{count=0} := sql.bind_dbat("sys","ptables",0);
#    _14{count=0} := sql.bind("sys","ttables","id",0);
#    _16{count=0} := sql.bind_dbat("sys","ttables",0);
#barrier always := true;
#    _7 := bat.reverse(_6{count=0});
#    _8 := algebra.kdiff(_1{count=0},_7);
#    _11 := algebra.markT(_8,0@0);
#    _12 := bat.reverse(_11);
#    _13 := algebra.join(_12,_1{count=0});
#    _17 := bat.reverse(_16{count=0});
#    _18 := algebra.kdiff(_14{count=0},_17);
#    _20 := algebra.markT(_18,0@0);
#    _21 := bat.reverse(_20);
#    _22 := algebra.join(_21,_14{count=0});
#    _23 := bat.append(_13,_22);
#    _25 := algebra.markT(_23,0@0);
#    _26 := bat.reverse(_25);
#    _27 := algebra.join(_26,_23);
#    _29 := algebra.markT(_27,0@0);
#    _30 := bat.reverse(_29);
#    _31 := algebra.join(_30,_27);
#    _32 := aggr.count(_31);
#    sql.column(_32,"count_id","int",32,0);
#    sql.output(0,_32);
#    yield always;
#    redo always;
#exit always;
#end sql1;
@end verbatim

The SQL compiler keeps a limited cache of queries.
Each query is looked up in this cache based on an expression pattern 
match where the constants may take on different values.
If it doesn;t exist, the query is converted into 
a @emph{factory} code block and stored in the module @code{sqlcache}. 
It consists of a prelude section, which locates
the tables of interest in the SQL catalogs.
The block between @code{barrier} and @code{yield} is the actual code
executed upon each call of this function. It is a large collection
of relational algebra operators, whose execution semantics depend
on the actual MAL engine. The @code{factory} ensures that only this part
is called when the query is executed repetitively.

The call to the cached function is included in the function @code{main},
which is the only piece of code produced if the query is used more than once.
The query cache disappears when the server is brought to a halt. 

When/how is the cache cleared? Can you list elements in the
cache directly, e.g @code{explain;} or @code{explain sqlcache} or @code{explain sqlcache.sql0;}

@node DEBUG Statement, Optimizer Control, EXPLAIN Statement, SQL
@subsection DEBUG Statement

The SQL statements are translated into MAL programs, which
are optimized and stored away in an @code{sql_cache} module.
The generated code can be debugged with the MAL debugger.
It provides a simple mechanism to trace the execution, hunting
for possible errors and detect performance bottlenecks
(@ref{Runtime Inspection}).

The example below, illustrates how you can easily obtain a quick 
overview of the cost components of the query using the debugger timer
flag and @code{continuation} command for the debugger.

@verbatim
>debug select * from tables;
#mdb #    mdb.start();
mdb>next
#mdb #    sql_cache.sql0();
mdb>timer
mdb>continue
#    19 usec#    _1{count=0} := sql.bind(_2="sys", _3="ptables", _4="id", _5=0)
#     3 usec#    _6{count=0} := sql.bind_dbat(_2="sys", _3="ptables", _5=0)
#     3 usec#    _14{count=0} := sql.bind(_2="sys", _15="ttables", _4="id", _5=0)
#     1 usec#    _16{count=0} := sql.bind_dbat(_2="sys", _15="ttables", _5=0)
#     2 usec#    _7 := bat.reverse(_6=<tmp_340>)
#    19 usec#    _8 := algebra.kdiff(_1=<tmp_476>, _7=<~tmp_340>)
#     5 usec#    _11 := algebra.markT(_8=<tmp_267>, _10=0@0)
#     1 usec#    _12 := bat.reverse(_11=<tmp_272>)
#    23 usec#    _13 := algebra.join(_12=<~tmp_272>, _1=<tmp_476>)
#     0 usec#    _17 := bat.reverse(_16=<tmp_26>)
#     4 usec#    _18 := algebra.kdiff(_14=<tmp_154>, _17=<~tmp_26>)
#     3 usec#    _20 := algebra.markT(_18=<tmp_273>, _10=0@0)
#     1 usec#    _21 := bat.reverse(_20=<tmp_275>)
#     4 usec#    _22 := algebra.join(_21=<~tmp_275>, _14=<tmp_154>)
#     3 usec#    _23 := bat.append(_13=<tmp_274>, _22=<tmp_276>)
#     8 usec#    _25 := algebra.markT(_23=<tmp_274>, _10=0@0)
#     1 usec#    _26 := bat.reverse(_25=<tmp_300>)
#     8 usec#    _27 := algebra.join(_26=<~tmp_300>, _23=<tmp_274>)
#     3 usec#    _29 := algebra.markT(_27=<tmp_301>, _10=0@0)
#     1 usec#    _30 := bat.reverse(_29=<tmp_277>)
#    12 usec#    _31 := algebra.join(_30=<~tmp_277>, _27=<tmp_301>)
#     1 usec#    _32 := aggr.count(_31=<tmp_304>)
#     1 usec#    sql.column(_32=23, _34="count_id", _35="int", _36=32, _5=0)
[ 23 ]
#    18 usec#    sql.output(_38=0, _32=23)
#     2 usec#    sql_cache.sql2()
>
@end verbatim

@node Optimizer Control, Overlaying the BAT storage, DEBUG Statement,  SQL
@section Optimizer Control
The code produced by MonetDB/SQL is massaged by several code optimizers
to arrive at the best possible plan for evaluation.
However, for development purposes and the rare case that more control
is needed, the SQL session variable @code{optimizer} can be set
to a MAL instruction list to identify the optimizer steps needed. [todo]

@example
>select optimizer;
#--------------------#
# t                  # name
# str                # type
#--------------------#
[ "optimizer.sql();" ]
>set optimizer="optimizer.factorize();";
>explain select 1;
@end example

The final result the optimizer steps become visible using the @code{explain}
statement modifier. Alternatively, the optimizer script line may include
a call to @code{optimizer.showPlan();}.

@node Overlaying the BAT storage,SQL Implementation Roadmap, Optimizer Control,  SQL
@section Overlaying the BAT storage
The SQL implementation exploits many facilities of the underlying
MonetDB kernel. Most notably, its efficient column-wise storage
scheme with associated algebraic primitives.
However, this kernel can also be programmed directly using the
MonetDB Assembler Language (MAL), which provides a much richer
set of operators then strictly necessary for a correct implementation
and execution of SQL

Although the BATs used for SQL storage can be manipulated directly
at the MAL layer, it is strongly discouraged. For, SQL uses a
rather complex administration to realise transaction safety.
Working at the MAL layer directly could easily compromise
the integrity of the system as a whole.

However, there are cases where access to a collection of BATs from
the SQL environment can be handy. For example, to inspect some
of the system tables maintained in the kernel.
This functionality is realised using an variation of the @code{view
statement}. It is best illustrated with a short example.

First, create in MonetDB the BATs of interest. Only void-BATs are allowed
and the user should guarantee that they are aligned.
@example
a:=bbp.new(:void,:int);
b:=bbp.new(:void,:str);
bat.setSequenceBase(a);
bat.setSequenceBase(b);
bat.setPersistent(a);
bat.setPersistent(b);
bat.setName(a,"age");
bat.setName(b,"name");
@end example
These BATs can be filled with attribute values, but make sure
that all BATs are given an equal number of tuples.
To conclude, commit the database to disk, whereafter the BATs
become available to SQL, once you restart Mserver/SQL.
@example
bat.insert(a,nil, 32);
bat.insert(b,nil, "John");
bat.insert(a,nil, 31);
bat.insert(b,nil, "Mary");
bbp.commit();
@end example
The BATs are made visible for read-only access using the a column
specification. As it normally expects identifiers, we have to use
double quotes instead.
@example
CREATE VIEW friends ("age","name") AS BATS;
@end example
At this point the content of the BATs can be queried
using ordinary SQL queries. Updates are prohibited.

@node SQL Implementation Roadmap, XQuery, Overlaying the BAT storage,  SQL
@section SQL Implementation Roadmap
In this section we summarize the SQL features scheduled for implementation
and those that won;t be supported in the foreseeable future.
A precise timeline can not be given. It depends too much on the
available resources and urgency.

Our current assessment of the features planned for upcoming releases,
in order of priority, are:
@itemize
@item
Text retrieval support.
@item 
Stored SQL procedures.
@item
Support for multi-media objects.
@item
General column and table constraint enforcement.
@item
Internationalization of the character sets.
@item
Full outer-join queries.
@item
Triggers.
@end itemize

@subsection Features that won;t make it.
The database backend architecture prohibits easy implementation of
several SQL-99 features. Those on the list below are not expected to
be supported.
@itemize
@item
Cursor based processing, because the execution engine is not based
on the iterator model deployed in other engines. A simulation of the
cursor based scheme would be utterly expensive from a performance
point of view.
@item
Multi-level transaction isolation levels. Coarse grain isolation is
provided using table level locks.
@end itemize
