@chapter SQL

The de facto language for database applications is SQL.  It evolved
through several phases of standardization to the version currently
known as SQL-2003.
The SQL standard provides an ideal language framework,
in terms of standardization committee viewpoints.  It is, however,
hardly met by any of the existing (commercial) implementations.
This is largely due to legacy of old software and backward compatibility
requirements from their client base.  See for instance
@url{http://www.dbazine.com/gulutzan3.shtml,this}
on-line article on SQL standards.

The MonetDB database system was originally developed as a database back-end
kernel with its own, low-level algebraic interface and scripting language.
The development of a SQL front end has been purposely postponed to the point
where the kernel code base was sufficiently mature and field tested in
large, mission critical applications in the financial sector.

In 2002 the first version of the SQL front end emerged.
This late development made it possible to immediately start from the SQL'99
definition. As soon as the SQL'03 specifications became available, its content
was taken as the primary frame of reference.
The SQL development strategy is driven by immediate needs of the
user base, such that less-frequently used features end up low on
the development stack.

The purpose of this chapter is to give a quick introduction on the SQL
front end, its limitations, and the way to use it.  Throughout this document
proficiency in elementary use of SQL is assumed.
If you are new to this world then pick up any of the
introduction books and study it carefully.
The SQL Implementation front-end is based on the SQL-99 standard,
which is covered in many text books e.g.
@emph{J. Melton and A.R. Simon}, SQL:1999 Understanding
Relational Language Components, ISBN 1558604561.

The architecture is based on a separate compiler module, which translates 
SQL statements into MAL. In this process common optimization heuristics,
specific to relational algebra are performed.
There are bindings for SQL with JDBC, ODBC, PHP and C, 
(see @ref{User Interfaces}) to integrate seamlessly in existing 
developments environments.
Client utilities like @ref{Aqua Data Studio} and @ref{iSQL-Viewer}
work flawlessly with the MonetDB SQL implementation and make 
your experience with even better! 

The remainder of this chapter provides a short tutorial to get
going with MonetDB/SQL. A synopsis of the language features 
provides a quick intro on the scope of the current implementation
and the short list for functional enhancements planned.
The programming support sections illustrate some of the advanced
features to analyse and your SQL code.
@menu
* Getting Started with SQL::
* The VOC Tutorial::
* SQL Feature Overview::
@menu
* SQL Feature List::
* SET Statement::
* EXPLAIN Statement::
* DEBUG Statement::
@end menu
* Optimizer Control::
* Overlaying the BAT storage::
@end menu

@node Getting Started with SQL, The VOC Tutorial, SQL, SQL
@section Getting Started with MonetDB/SQL
Working with SQL requires installation of the MonetDB server 
and SQL compiler module.  It can be downloaded from the
@url{http://sourceforge.net/project/showfiles.php?group_id=56967,download} 
section at SourceForge. It is already included in the Windows installers.

The first step is to start the database backend following
the steps in @ref{Start and Stop the Server} or illustrated below.
Once it runs, you can choose between a textual interface or
one of the graphical user interfaces (See @ref{User Interfaces}).
The easiest to start with is a textual SQL client.
Under Windows, this client is already configured to directly contact
the running server. For Linux users we illustrate the actions taken
behind the scene. 

The first action on Linux is to start the database server as described
in @ref{Start and Stop the Server}.

@example
shell> monetdb --start --dbname=voc 
# Monet Database Server V4.99.19
# Copyright (c) 1993-2006, CWI. All rights reserved.
# Compiled for x86_64-redhat-linux-gnu/64bit with 32bit OIDs; dynamically linked.
# config:/ufs/mk/monet5/Linux/etc/MonetDB5.conf
# dbfarm:/ufs/mk/monet5/Linux/var/MonetDB5/dbfarm
# dbname:demo
# Visit http://monetdb.cwi.nl/ for further information.
#Ready to accept connections on gio.ins.cwi.nl:45123
shell>
@end example

This reply evidently depends on your installation procedure and
configuration parameters.

The next step is to connect to the server with a textual client.
Two such clients are included in the distribution: MapiClient and
JdbcClient.

The former is the native, C-implementation of the MonetDB client interface.
It is a no-frills and fast interface geared at developers. 
The @code{jdbcclient} uses a standardized database interaction protocol.
If you are familiar with JDBC-based applications, or intend to 
build those, this interface may be your prime choice.
The @code{jdbcclient} utility is illustrated:
@example
shell> JdbcClient -umonetdb
password: ********
Welcome to the MonetDB interactive JDBC terminal!
Database: MonetDB 4.99.19
Driver: MonetDB Native Driver 1.2 (Blunt+ 20051226)
Type \q to quit, \h for a list of available commands
auto commit mode: on
monetdb->
@end example
The location of the jar file is taken from the MonetDB 
installation directory. Its location can be added to your
CLASSPATH environment variable for ease of localization.

The world of SQL is now available to the user:
@example
monetdb-> SELECT 'Hello SQL, here I come' AS "message";
+------------------------+
| message                |
+========================+
| Hello SQL, here I come |
+------------------------+
1 row

monetdb->
@end example

The alternative interface is MapiClient with its Spartan rendering scheme:
@example
shell> MapiClient -lsql 
sql>SELECT 'Hello SQL, here I come' AS "message";
#  # table_name
# message # name
# char # type
# 22 # length
[ "Hello SQL, here I come"      ]
sql>
@end example

In a clean setup, either client program should run without problems.
If you haven't managed to contact the database server either way,
backtrack your steps. Is the server running? (use @code{monetdb --status})
More arguments may be needed if the server lives on
a different machine or the client does not have access to the
MonetDB configuration file to access the defaults. See @ref{JdbcClient}
or @ref{MapiClient} for details.


@node The VOC Tutorial, SQL Feature Overview, Getting Started with SQL, SQL
@section The VOC tutorial
Exploring the wealth of functionality offered by MonetDB is best
started using a toy database.  An example of such database is the VOC data
set that provides a peephole view into the administrative
system of a multi-national company, 
the @emph{Vereenigde geoctrooieerde Oostindische
Compagnie} (VOC for short - The (Dutch) East Indian Company).

The VOC was granted a monopoly on the trade in the East Indies on March 20, 1602
by the representatives of the provinces of the Dutch republic.
Attached to this monopoly was the duty to fight the enemies of the Republic and
prevent other European nations to enter the East India trade.
During its history of over 200 years, the VOC became the largest company of its kind,
trading spices like nutmeg, cloves, cinnamon, pepper, and other consumer
products like tea, silk and Chinese porcelain.
Her factories or trade centers were world famous: Desjima in Japan,
Mokha in Yemen, Surat in Persia and of course Batavia,
the Company's headquarters on Java.

The history of the VOC is an active area of research and
a focal point for multi-country heritage projects, 
e.g. @url{http://www.tanap.net/content/voc/organization/organization_intro.htm, TANAP},
which includes a short historic overview of the VOC written by
world expert on the topic F. Gaastra.
The archives of the VOC are spread around the world, but a large
contingent still resides in the @url{ http://www.nationaalarchief.nl/,National Archive<},
The Hague.
The archives comprise over 25 million historical records.
Much of which has not (yet) been digitized.

The MonetDB/SQL tutorial is based on the material published in the book
J.R. Bruijn, F.S. Gaastra and I. Schaar, @emph{Dutch-Asiatic Shipping in the 17th
and 18th Centuries}, which gives an account of the trips made to the East
and ships returned safely (or wrecked on the way).  A total of 8000 records
are provided.  They include information about ship name and type, captain,
the arrival/departure of harbors along the route, personnel accounts,
and anecdotal information.

@subsection Acquiring and loading the VOC data set
The VOC data set can be downloaded from
@url{http://monetdb.cwi.nl/Assets/VOC/voc_dump.sql.gz,the MonetDB Assets site}
as a gzipped file with SQL statements.
After the zipfile has been extracted, the file should be loaded into MonetDB
via either the Java based @ref{JdbcClient} utility, or the @ref{MapiClient}
C-program.
Alternatively, the URL to the VOC data file can be supplied to the
@ref{JdbcClient} utility, which then directly reads from the URL.

Before you load the VOC data set, it is advised to first add a different user
with its own schema to the MonetDB database.
We illustrate this process using the textual SQL client.
Make sure the MonetDB server has been started, then start the SQL client.
Under Linux you will see something like this:

@example
shell> JdbcClient -uvoc
password: ***
Welcome to the MonetDB interactive JDBC terminal!
Database: MonetDB 4.99.19
Driver: MonetDB Native Driver 1.2 (Blunt+ 20051226)
Type \q to quit, \h for a list of available commands
auto commit mode: on
voc> CREATE USER "voc" WITH PASSWORD 'voc' NAME 'VOC Explorer' SCHEMA "sys";
Operation successful
voc> CREATE SCHEMA "voc" AUTHORIZATION "voc";
Operation successful
voc> ALTER USER "voc" SET SCHEMA "voc";
voc>\q
@end example
In the remainder of the tutorial you can no log onto the server
as user @code{voc}.

The tutorial database can be initialized using either @code{JdbcClient} and
@code{MapiClient} as follows, provided the sql-dump file has already been
downloaded:
@example
shell> JdbcClient -uvoc -f voc_dump.sql -Xbatching=400
password: ***
shell> JdbcClient -uvoc -f http://monetdb.cwi.nl/Assets/VOC/voc_dump.sql.gz -Xbatching=400
password:***
shell>MapiClient -lsql -uvoc <voc_dump.sql
@end example
The argument @code{Xbatching} instructs the JDBC client to batch instructions
before shipping them to the server. Loading the database takes a few
seconds on a state-of-the-art machine.

@subsection Exploring the VOC data set
The @code{JdbcClient} contains a @emph{describe} operator, 
denoted by @code{\d} to inspect the
definition of the database schema and its tables.
This functionality is not available in @code{MapiClient}. 
@example
monetdb-> \d
TABLE   sys.craftsmen
TABLE   sys.impotenten
TABLE   sys.invoices
TABLE   sys.passengers
TABLE   sys.seafarers
TABLE   sys.soldiers
TABLE   sys.total
TABLE   sys.voyages
@end example
The set consists of 8 tables, which are all bound to each other using 
FOREIGN KEY relationships. The voyages table is considered to be the 
main table, which all others reference to. Every table, except invoices 
has a PRIMARY KEY defined over the columns number and number_sup. 
Since the invoices table holds zero or more invoices per voyage 
(identified by number, number_sub) a PRIMARY KEY constraint is 
not possible. Details of the tables are readily available.
@example
voc-> \d sys.soldiers
CREATE TABLE "sys"."soldiers" (
        "number"               int      NOT NULL,
        "number_sup"           char(1)  NOT NULL,
        "trip"                 int ,
        "trip_sup"             char(1),
        "onboard_at_departure" int ,
        "death_at_cape"        int ,
        "left_at_cape"         int ,
        "onboard_at_cape"      int ,
        "death_during_voyage"  int ,
        "onboard_at_arrival"   int ,
        CONSTRAINT "soldiers_number_number_sup_pkey" PRIMARY KEY ("number", "number_sup"),
        CONSTRAINT "soldiers_number_number_sup_fkey" FOREIGN KEY ("number", "number_sup") REFERENCES "sys"."voyages" ("number", "number_sup")
);
voc->
@end example
The tables craftsmen, importenten, passengers, seafarers, and soldiers 
all share the same columns. We can define a VIEW that combines them all 
into one big table, to make them easier to access.
@example
voc-> CREATE VIEW onboard_people AS
voc-> SELECT * FROM (
voc-(    SELECT 'craftsmen' AS type, craftsmen.* FROM craftsmen
voc-(    UNION ALL
voc-(    SELECT 'impotenten' AS type, impotenten.* FROM impotenten
voc-(    UNION ALL
voc-(    SELECT 'passengers' AS type, passengers.* FROM passengers
voc-(    UNION ALL
voc-(    SELECT 'seafarers' AS type, seafarers.* FROM seafarers
voc-(    UNION ALL
voc-(    SELECT 'soldiers' AS type, soldiers.* FROM soldiers
voc-(    UNION ALL
voc-(    SELECT 'total' AS type, total.* FROM total
voc-( ) AS onboard_people_table;
Operation successful
@end example
The new view will show up and we can just use it as a normal table, 
to for instance calculate the number of records for each group of people:
@example
voc-> SELECT type, COUNT(*) AS total FROM onboard_people GROUP BY type ORDER BY type;
+------------+----------+
| type       | total    |
+============+==========+
| craftsmen  | 2349     |
| impotenten | 938      |
| passengers | 2813     |
| seafarers  | 4468     |
| soldiers   | 4177     |
| total      | 2454     |
+------------+----------+
5 rows
 
voc-> select count(*) from impotenten;
+--------------+
| count_number |
+==============+
| 938          |
+--------------+
1 row
@end example
It is possible to play with the set in many ways, to find out several 
things that took place during the voyages of the ships, or the money 
that was earned. A few examples are shown below.
@example
voc-> SELECT COUNT(*) FROM voyages WHERE particulars LIKE '%_recked%';
+--------------+
| count_number |
+==============+
| 358          |
+--------------+
1 row
 
voc-> SELECT chamber, CAST(AVG(invoice) AS integer) AS average
voc-> FROM invoices
voc-> WHERE invoice IS NOT NULL
voc-> GROUP BY chamber
voc-> ORDER BY average DESC;
+---------+----------+
| chamber | average  |
+=========+==========+
| A       | 282996   |
| Z       | 259300   |
| H       | 150182   |
| R       | 149628   |
| D       | 149522   |
| E       | 149518   |
| <NULL>  | 83309    |
+---------+----------+
7 rows
 
voc-> CREATE VIEW extended_onboard AS SELECT number, number_sup, trip, trip_sup, onboard_at_departure, death_at_cape, left_at_cape, onboard_at_cape, death_during_voyage, onboard_at_arrival, death_during_voyage - left_at_cape AS death_at_arrival FROM onboard_people;
Operation successful
@end example
@subsection Historical background
Please take the time to experiment with the VOC data. For your convenience,
we give here a short histororical background and interpretation of what
to find in this database.
The introduction given below is an OCR version from the book: J.R. Bruijn, F.S. Gaastra and I. Schaar, Dutch-Asiatic Shipping in the 17th and 18th Centuries

This book presents tables which give a virtually complete survey of the 
direct shipping between the Netherlands and Asia between 1595-1795. 
This period contains, first, the voyages of the so-called Voorcompagnieëand, 
hence, those for and under control of the Vereenigde Oostindische Compagnie 
(VOC). The survey ends in 1795.
That year saw an end of the regular sailings of the VOC between the 
Netherlands and Asia, since, following the Batavian revolution in January, 
the Netherlands became involved in war with England. The last outward voyage 
left on 26 December 1794. After news of the changed situation in the 
Netherlands was received in Asia, the last homeward voyage took place in 
the spring of 1795. The VOC itself was disbanded in 1798.

In total 66 voyages of the voorcompagnieëare listed, one more than the 
traditionally accepted number. The reconnaissance ship, POSTILJON, from the 
fleet of Mahu and De Cordes, that was collected en route is given its 
own number (0022). Since the attempt of the Australische Compagnie to 
circumvent the monopoly of the VOC can be considered as a continuation of 
the voorcompagnieëthe voyage of Schouten and Le Maire is also 
listed (0196-0197).
For the rest, exclusively the outward and homeward voyages of the VOC 
are mentioned in the tables. Of those there were in total 4722 outward and 
3359 homeward. The administration of the company was strictly followed, 
so that, for example, the voyage of Hudson in 1609 (0133) is listed, but 
not that of Roggeveen in 1721-1722.
Voyages of East Indiamen that were driven off course, and arrived for 
instance in Surinam, or those which went no further than the Cape are 
mentioned, as opposed to those of warships of the five Admiralties which, 
from 1783, were sent to Asia to protect the fleets and possessions of the VOC.

The sources of the journeys consist primarily of the archives of the VOC 
in the Algemeen Rijksarchief in The Hague. They are, on the one hand, 
the so-called 'Uitloopboeken' and ship registers, and, on the other, 
the 'Overgekomen Brieven en Papieren' (OBP's). The latter contain the 
regular reports on the arrival and departure of ships in Batavia and other 
Asiatic harbors. In addition, the 'Overgekomen Brieven van de Kaap de 
Goede Hoop' and some other, more dispersed sources must be mentioned.
The data on the voyages of the voorcompagnieëderive above all from 
ources published by the Linschoten Vereeniging.

In volume I, the principal sources are described extensively and the 
origin of the information on each voyage is given. In addition, that 
volume contains an introduction on the organization of the VOC's shipping, 
which also includes an analysis and summary of the data presented in the 
tables. Various other supplementary information, such as the value of the 
export from the Netherlands, only available by year, is also published
there.
The tables follow closely the material presented in the major sources 
('Uitloopboeken' en OBP's). Since these sources are not uniform over a 
period of almost two centuries, the level of completeness of the information 
given for each voyage also varies.

@emph{Homeward voyage}
During the compilation of the tables it became necessary in a few cases to 
add an A to some numbers. This occurred 5 times, in the following places: 
5022, 5980, 5987, 6246 and 6649. Similarly in three cases a number had 
to be left open. The following numbers have not been used: 4605, 5027 and 8215.
The voyage number is followed by a figure which shows whether the ship is 
making its first, second or subsequent voyage. The outward and homeward 
voyages are counted separately. The first voyage from the Netherlands and 
the subsequent homeward voyages are both shown by a `1'. Occasionally a 
ship was built or acquired in Asia. The first outward voyage of such a 
ship is considered as its second voyage.

@emph{Ship's name}
A uniform spelling has been chosen for the numerous variants given in 
the sources. In alphabetical ordering and in the index, the most relevant 
word was chosen. Thus the WAPEN VAN, HOORN (0243) is given under HOORN, 
the HOF NIET ALTIJD ZOMER (2380) under ZOMER and the VROUWE REBECCA 
JACOBA (3668) under REBECCA. It should be noted that especially in the 
seventeenth century ships' names were frequently provided with additions 
which were not used in a consistent fashion. The AMSTERDAM (0431) was 
sometimes called NIEUWAMSTERDAM, the WITTE OLIFANT (0533), the OLIFANT. 
The most frequent name is given in the tables. In the eighteenth century, 
especially, ships' names were frequently changed, or they used each 
other's names. This is always mentioned under the heading Particulars and 
in the index.

@emph{Master's name}
Similarly, a uniform spelling has been chosen for the name of the master, 
generally schipper, but in the eighteenth century also a kapitein or 
kapiteinluitenant. The index is arranged by surname or patronymic.

@emph{Tonnage}
The volume of the ships is given in metric tons. The sources give the 
figures in lasten (1 last = 2 tons). After 1636, however, information in 
lasten is no longer of any value, as, for fiscal reasons, the VOC's 
figures were kept artificially low. From then on the volume has been 
calculated on the basis of the measurements of the ships, according to 
a simple formula (volume in lasten = length x breadth x depth in 
Amsterdam feet, divided by 200; 1 ft. = 28,3 cm). The results of this 
calculation have been doubled and are given in the tables. This method and 
the problems regarding the assessment of the ships' volume is described 
in Volume I. In a number of cases where inconsistent information was found, 
both calculations are given, thus e.g. 600/850.

@emph{Type of ship}
Occasionally, in those cases where this is mentioned in the sources, 
the type of the ship is given in the same column as the tonnage. 
In general, the most frequent type of ship, the retourschip (East Indiaman) 
is not mentioned in the sources. Therefore, where the type of ship is not 
mentioned, it may often be assumed that an East Indiaman is meant. 
The various other types - hoeker, kat, pinas, jacht, fluit, paketboot - 
are given in Dutch.

@emph{Built}
The year given in this column refers to the year in which the ship was built.
If the ship was hired or bought by the VOC, then this is mentioned in the
column, together with the year in which the transaction occurred.

@emph{Yard}
The place is given where the ship was built. The chambers of the VOC had 
their own yard. 'A' refers to Amsterdam, 'Z' to Zeeland, 'D' to Delft, 
'R' to Rotterdam, 'H' to Hoorn, and 'E' to Enkhuizen. 
When a ship was hired or bought by the VOC, the letter indicates the 
chamber that was responsible for the transaction.
The ships of the voorcompagnieëdid not belong to a chamber. In these cases, 
A' indicates that a ship was built at an Amsterdam yard. The chambers also 
had no part in the buying or building of ships by the Hoge Regering in 
Batavia. In these cases the place of building or purchase in Asia is given.

@emph{Chamber}
With the outward voyages, this column gives the chamber which equipped the 
ship; with the homeward, the chamber to which the ship was addressed. 
There is no entry in this column for ships organized by the voorcompagnieë

@emph{Departure}

Under this heading is given the date and place of departure from Europe, 
Asia or the Cape of Good Hope. A date like 03-02-1645 refers to 3 February 1645.
Where sailings from the Republic are concerned, the date given refers to 
the departure from the roads. Amsterdam, Hoorn and Enkhuizen ships generally 
left from Texel roads, Zeeland ships from the Wielingen or the roads of 
Rammekens, and Rotterdam and Delft ships from Goeree. Sometimes, ships were 
forced by storms or damage to return to the roads for a time or they sought 
shelter in one of the estuaries on the coast of Holland or Zeeland. Where 
possible, this is mentioned under the heading Particulars. In general the 
first date of departure is given in the tables, but in some cases, a later 
date has been chosen, in deference to the sources.

As for leaving Batavia, departure from the roads of the town was decisive, 
and not, as is frequently described in the Company papers, the reaching of 
the `open sea' after passing the Sunda Strait. Where departures from other 
Asian ports are concerned in general only the Company establishment from which 
the ship sailed is given. Thus Ceylon is mentioned in the columns, but it 
can be assumed that most ships left from the Bay of Galle, at the southern 
point of the island. China is given for ships which left from Canton, and 
the date refers to departure from the roads at Whampoa. Bengal is given for 
ships which left from the anchorage in the Ganges close to the 
VOC-establishment at Hughly.

@emph{Call at Cape}
The data in this column give the arrival at (above) and the departure (below)
from the Cape of Good Hope. In general no distinction is made between Table 
Bay and False Bay. Mention is made, when given in the sources, of ships 
which put in to the more northerly Saldanha and St. Helena Bays. When a 
ship sailed past the Cape, this is denoted by `no call'. When it is not 
known whether the ship stopped at the Cape at all - especially frequent 
before the foundation of the refreshment station there in 1652 - the column 
is left blank.

@emph{Arrival}
The third column contains the date and place of arrival in Asia, Europe or, 
when that was the destination of the journey, at the Cape of Good Hope.
The place of arrival is given in the same manner as that of departure, though, 
in addition to the estuaries mentioned above, ships sometimes arrived in the 
Netherlands via the Vlie or at Delfzijl. The place of arrival in Asia 
refers to the establishment reached, unless the sources specify the actual 
port.

@emph{On board}
It is possible to differentiate the number of those on board into various 
categories. For the outward journey, these are seafarers, soldiers, craftsmen, 
and passengers. The craftsmen are those who were employed to perform some 
particular service in Asia, and are thus not part of the crew as such.
'Passengers' is in fact a residual category, including high officials of 
the Company, including ministers of religion with their wives and servants,
but also slaves and stowaways. Whenever such a differentiation is not possible,
which is especially the case in the early years, a figure for the total is 
given. Italics are used for this, or when the figures refer to more than one 
category. Only those categories are mentioned which were on board. 
Therefore, when one category is mentioned, this implies that the others 
were not represented on board.

The sources for the return voyages are of a different kind and normally far 
less complete. They are totally absent for the journey between the Cape and 
the Netherlands. However, another category must be mentioned, namely the 
impotenten, who for various reasons were released from active service for 
the VOC and sent back to Europe. With regard to many voyages the sources 
only give the number of passengers and impotenten, and not the number of 
sailors and soldiers. Obviously, the absence of figures under these headings 
does not imply that there were none on board.

Information on the outward voyages is divided into six columns:
@enumerate
@item onboard_at_departure 	
The number on board at departure
@item death_at_cape 	
The number dying between the Netherlands and the Cape. Frequently this figure refers to all the categories together, even when the other information is available per category. In such cases this figure is printed in italics.
@item left_at_cape 	
The number who leave the ship at the Cape.
@item onboard_at_cape 	
The number who come on board at the Cape.
@item death_during_voyage 	
The number dying on the whole voyage. Subtraction of III from V gives the number dying between the Cape and Asia.
@item onboard_at_arrival 	
The number on board on arrival in Asia.
@end enumerate

Three columns are given for the homeward voyages:
@enumerate
@item onboard_at_departure 	
The number on board at departure
@item death_at_cape 	
The number dying en route to the Cape
@item left_at_cape 	
The number who went from board at the Cape
@end enumerate
The figures in the various columns are taken from different sources which are 
not always consistent with each other. Therefore the figures on changes in 
the number of those on board during the voyages do not always tally with 
those on the size of the crew at departure and arrival.

@emph{Invoice value}
For the return voyages, the total value of the ship's cargo, according to the 
invoice made up in Batavia or some other establishment, is given, as is the 
chamber for which the cargo was destined. Generally, this was for the chamber 
under whose jurisdiction the ship sailed, but occasionally a proportion of 
the cargo was for one or more of the other chambers.

@emph{Particulars}
Under the last heading details deriving from the basic sources are given.
They are generally incidental and as such not to be placed in one of the 
preceding columns. Because the sources are not the same across the whole 
period, and at times less complete, the extent and sort of material under 
this heading could not be consistent.

In so far as it is available, information deals with the ports of call on 
the journey, with the details of changes in the composition of the crew 
and with the eventual fate of the ship. For the return voyage, the name of 
the fleet-commander is generally given, and, after his name, the number of 
the ship he was on. Finally, where necessary, differences in data between 
various sources are indicated. Occasionally, particulars from a published 
source are added.

@emph{Corresponding number}
This number, placed at the far right of the tables, denotes the next 
homeward voyage of the ship in volume II (naturally absent when the ship 
remains in Asia), or, in volume III, for homeward voyages, the number of 
the ship's previous outward voyage. In those cases where the ship was 
acquired in Asia, no corresponding number is given for the first homeward 
voyage from Asia.

Due to the long duration of the preparation of these two volumes there 
are some inconsistencies in the text of the particulars and in the use 
of language. 
@node SQL Feature Overview, SQL Feature List, The VOC Tutorial, SQL
@section SQL Features 
The SQL Implementation implementation is based on the SQL-99 standard. 
It is built incrementally over time to cope with the effort
required to realize all features. Priority is given to those
features relevant to our research and upon request from our valued
partners.

The plethora of SQL implementations also show that the standard
alone is hardly sufficient. All database systems have extended
or twisted the language definition to satisfy the needs of their
customer, to support legacy, and to better tap into the functionality
offered by their kernel implementations. 
MonetDB/SQL is bound to follow this path too. The kernel imposes
limitations on the features that can and cannot be realized.
The are summarized in @ref{Development Roadmap}.

In the context of programming support, we provide a few
primitives to simplify debugging of SQL programs. They are described
separately. The list below provides a synopsis of the SQL features
supported in the released version.

@node SQL Feature List, SET Statement, SQL Feature Overview, SQL
@subsection SQL-99 Feature list
In this section we give an itemized list of the SQL-99 features
supported in the current release.
@itemize
@item 
Primary and foreign key integrity enforcement.
@item
Subqueries are fully supported.
@item
Table expression @code{union} and @code{intersection}.
@item
Table views for query processing only.
@item
Binding SQL functions with to externally supplied routines.
@item
Auto-increment keys (SQL 2003).
@end itemize


@node SET Statement, EXPLAIN Statement, SQL Feature List, SQL
@subsection SET Statement

MonetDB/SQL comes with a limited variable scheme.
Globel, session based variables can be introduced using the
construct:
@example
SET <variable>=<string>
SET <variable>=<boolean>
SET <variable>=<int>
@end example
Their type is inherited from the literal value supplied.
The SQL engine comes with a limited set of environment variables
to control its behavior.
@itemize
@item
The @code{debug} variable takes an integer and sets the server global
debug flag. (See MonetDB documentation) It also activates the
debugger when the query is being executed.
@item
The @code{explain} variable currently takes the values 'plan' or
'performance'. The 'plan' qualifier produces a relational table with
the plan derived for execution using the applicable back end and
optimizer schemes. The 'performance' qualifier produces a performance
trace of the SQL queries for post analysis. It is available in
the system table called @code{history}. Omission of either qualifier merely
results in a straight execution of the query.
@item

The @code{auto_commit} variable takes a boolean and controls automatic commit
after a successful SQL execution, or conversely an automatic rollback.

@item
The @code{reply_size} limits the number of tuples sent to the front end.
[It is unclear how the remainder can be obtained within the SQL language
framework. The reply_size should be replaced by the @code{limit} language
construct]

@item
The @code{history} variable is a boolean flag which leads to 
capturing execution information of any SQL query in a table for post-analysis.
@end itemize

By default all remaining variables are stored as strings and
any type analysis is up to the user. The can be freely used by the
SQL programmer for inclusion in his queries. [TODO, a little more
flexibilty would mean a lot]

The variables and their type definition are assembled in a system table
called 'sessions'. Its default content is shown below:
@example
>select * from sessions;
#---------------------------------------------------------------------#
# t                     t                   t               t         # name
# str                   str                 str             int       # type
#---------------------------------------------------------------------#
[ "debug",                "0",                "int",          0       ]
[ "reply_size",           "-1",               "int",          0       ]
[ "explain",              "",                 "varchar",      0       ]
[ "auto_commit",          "false",            "boolean",      0       ]
[ "current_schema",       "sys",              "varchar",      1       ]
[ "current_user",         "monetdb",          "varchar",      1       ]
[ "current_role",         "monetdb",          "varchar",      0       ]
[ "current_timezone",     "0",                "sec_interval", 0       ]
[ "optimizer",            "yes",              "varchar",      0       ]
@end example

@node EXPLAIN Statement, DEBUG Statement, SET Statement, SQL
@subsection EXPLAIN Statement
The intermediate code produced by the SQL Implementation compiler can be made 
visible using the @code{explain} statement modifier. 
It gives a detailed description of the actions taken to produce the
answer. The example below illustrates what you can expect when a
simple query is pre-pended by the @code{explain} modifier.
Although the details of this program are better understood
when you have read the Chapter on MAL @ref{MonetDB Assembler Language}
the global structure is easy to explain.

@verbatim
>select count(*) from tables;
[ 23 ]
>explain select count(*) from tables;
#function user.main():int;
#    sql_cache.sql1();
#end main;
#factory sql_cache.sql1():any;
#    _1{count=0} := sql.bind("sys","ptables","id",0);
#    _6{count=0} := sql.bind_dbat("sys","ptables",0);
#    _14{count=0} := sql.bind("sys","ttables","id",0);
#    _16{count=0} := sql.bind_dbat("sys","ttables",0);
#barrier always := true;
#    _7 := bat.reverse(_6{count=0});
#    _8 := algebra.kdiff(_1{count=0},_7);
#    _11 := algebra.markT(_8,0@0);
#    _12 := bat.reverse(_11);
#    _13 := algebra.join(_12,_1{count=0});
#    _17 := bat.reverse(_16{count=0});
#    _18 := algebra.kdiff(_14{count=0},_17);
#    _20 := algebra.markT(_18,0@0);
#    _21 := bat.reverse(_20);
#    _22 := algebra.join(_21,_14{count=0});
#    _23 := bat.append(_13,_22);
#    _25 := algebra.markT(_23,0@0);
#    _26 := bat.reverse(_25);
#    _27 := algebra.join(_26,_23);
#    _29 := algebra.markT(_27,0@0);
#    _30 := bat.reverse(_29);
#    _31 := algebra.join(_30,_27);
#    _32 := aggr.count(_31);
#    sql.column(_32,"count_id","int",32,0);
#    sql.output(0,_32);
#    yield always;
#    redo always;
#exit always;
#end sql1;
@end verbatim

The SQL compiler keeps a limited cache of queries.
Each query is looked up in this cache based on an expression pattern 
match where the constants may take on different values.
If it doesn;t exist, the query is converted into 
a @emph{factory} code block and stored in the module @code{sqlcache}. 
It consists of a prelude section, which locates
the tables of interest in the SQL catalogs.
The block between @code{barrier} and @code{yield} is the actual code
executed upon each call of this function. It is a large collection
of relational algebra operators, whose execution semantics depend
on the actual MAL engine. The @code{factory} ensures that only this part
is called when the query is executed repetitively.

The call to the cached function is included in the function @code{main},
which is the only piece of code produced if the query is used more than once.
The query cache disappears when the server is brought to a halt. 

When/how is the cache cleared? Can you list elements in the
cache directly, e.g @code{explain;} or @code{explain sqlcache} or @code{explain sqlcache.sql0;}

@node DEBUG Statement, Optimizer Control, EXPLAIN Statement, SQL
@subsection DEBUG Statement

The SQL statements are translated into MAL programs, which
are optimized and stored away in an @code{sql_cache} module.
The generated code can be debugged with the MAL debugger.
It provides a simple mechanism to trace the execution, hunting
for possible errors and detect performance bottlenecks
(@ref{Runtime Inspection}).

The example below, illustrates how you can easily obtain a quick 
overview of the cost components of the query using the debugger timer
flag and @code{continuation} command for the debugger.

@verbatim
>debug select * from tables;
#mdb #    mdb.start();
mdb>next
#mdb #    sql_cache.sql0();
mdb>timer
mdb>continue
#    19 usec#    _1{count=0} := sql.bind(_2="sys", _3="ptables", _4="id", _5=0)
#     3 usec#    _6{count=0} := sql.bind_dbat(_2="sys", _3="ptables", _5=0)
#     3 usec#    _14{count=0} := sql.bind(_2="sys", _15="ttables", _4="id", _5=0)
#     1 usec#    _16{count=0} := sql.bind_dbat(_2="sys", _15="ttables", _5=0)
#     2 usec#    _7 := bat.reverse(_6=<tmp_340>)
#    19 usec#    _8 := algebra.kdiff(_1=<tmp_476>, _7=<~tmp_340>)
#     5 usec#    _11 := algebra.markT(_8=<tmp_267>, _10=0@0)
#     1 usec#    _12 := bat.reverse(_11=<tmp_272>)
#    23 usec#    _13 := algebra.join(_12=<~tmp_272>, _1=<tmp_476>)
#     0 usec#    _17 := bat.reverse(_16=<tmp_26>)
#     4 usec#    _18 := algebra.kdiff(_14=<tmp_154>, _17=<~tmp_26>)
#     3 usec#    _20 := algebra.markT(_18=<tmp_273>, _10=0@0)
#     1 usec#    _21 := bat.reverse(_20=<tmp_275>)
#     4 usec#    _22 := algebra.join(_21=<~tmp_275>, _14=<tmp_154>)
#     3 usec#    _23 := bat.append(_13=<tmp_274>, _22=<tmp_276>)
#     8 usec#    _25 := algebra.markT(_23=<tmp_274>, _10=0@0)
#     1 usec#    _26 := bat.reverse(_25=<tmp_300>)
#     8 usec#    _27 := algebra.join(_26=<~tmp_300>, _23=<tmp_274>)
#     3 usec#    _29 := algebra.markT(_27=<tmp_301>, _10=0@0)
#     1 usec#    _30 := bat.reverse(_29=<tmp_277>)
#    12 usec#    _31 := algebra.join(_30=<~tmp_277>, _27=<tmp_301>)
#     1 usec#    _32 := aggr.count(_31=<tmp_304>)
#     1 usec#    sql.column(_32=23, _34="count_id", _35="int", _36=32, _5=0)
[ 23 ]
#    18 usec#    sql.output(_38=0, _32=23)
#     2 usec#    sql_cache.sql2()
>
@end verbatim

@node Optimizer Control, Overlaying the BAT storage, DEBUG Statement,  SQL
@section Optimizer Control
The code produced by MonetDB/SQL is massaged by several code optimizers
to arrive at the best possible plan for evaluation.
However, for development purposes and the rare case that more control
is needed, the SQL session variable @code{optimizer} can be set
to a MAL instruction list to identify the optimizer steps needed. [todo]

@example
>select optimizer;
#--------------------#
# t                  # name
# str                # type
#--------------------#
[ "optimizer.sql();" ]
>set optimizer="optimizer.factorize();";
>explain select 1;
@end example

The final result the optimizer steps become visible using the @code{explain}
statement modifier. Alternatively, the optimizer script line may include
a call to @code{optimizer.showPlan();}.

@node Overlaying the BAT storage,XQuery, Optimizer Control,  SQL
@section Overlaying the BAT storage
The SQL implementation exploits many facilities of the underlying
MonetDB kernel. Most notably, its efficient column-wise storage
scheme with associated algebraic primitives.
However, this kernel can also be programmed directly using the
MonetDB Assembler Language (MAL), which provides a much richer
set of operators then strictly necessary for a correct implementation
and execution of SQL

Although the BATs used for SQL storage can be manipulated directly
at the MAL layer, it is strongly discouraged. For, SQL uses a
rather complex administration to realise transaction safety.
Working at the MAL layer directly could easily compromise
the integrity of the system as a whole.

However, there are cases where access to a collection of BATs from
the SQL environment can be handy. For example, to inspect some
of the system tables maintained in the kernel.
This functionality is realised using an variation of the @code{view
statement}. It is best illustrated with a short example.

First, create in MonetDB the BATs of interest. Only void-BATs are allowed
and the user should guarantee that they are aligned.
@example
a:=bat.new(:void,:int);
b:=bat.new(:void,:str);
bat.setSequenceBase(a,0@@0);
bat.setSequenceBase(b,0@@0);
bat.setPersistent(a);
bat.setPersistent(b);
bat.setName(a,"age");
bat.setName(b,"name");
@end example
These BATs can be filled with attribute values, but make sure
that all BATs are given an equal number of tuples.
To conclude, commit the database to disk, whereafter the BATs
become available to SQL, once you restart Mserver/SQL.
@example
bat.insert(a,nil, 32);
bat.insert(b,nil, "John");
bat.insert(a,nil, 31);
bat.insert(b,nil, "Mary");
transaction.commit(a,b);
@end example
The BATs are made visible for read-only access using the a column
specification. As it normally expects identifiers, we have to use
double quotes instead.
@example
CREATE VIEW friends ("age","name") AS BATS;
@end example
At this point the content of the BATs can be queried
using ordinary SQL queries. Updates are prohibited.
