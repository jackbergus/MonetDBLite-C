@chapter SQL

The de facto language for database applications is SQL.  It evolved
through several phases of standardization to the version currently
known as SQL-2003.
The SQL standard provides an ideal language framework,
in terms of standardization committee viewpoints.  It is, however,
hardly met by any of the existing (commercial) implementations.
This is largely due to software legacy and backward compatibility
requirements from their client base.  See for instance
@url{http://www.dbazine.com/gulutzan3.shtml,this}
on-line article on SQL standards.

The MonetDB database system was originally developed as a database back-end
kernel with its own, low-level algebraic interface and scripting language.
The development of a SQL front end has been purposely postponed to the point
where the kernel code base was sufficiently mature and field tested in
large, mission critical applications in the financial sector.

In 2002 the first version of the SQL front end emerged.
This late development made it possible to immediately start from the SQL'99
definition. As soon as the SQL'03 specifications became available, its content
was taken as the primary frame of reference.
The SQL development strategy is driven by immediate needs of the
user base, so that less-frequently used features end up low on
the development stack.

The purpose of this chapter is to give a quick introduction on the SQL
front end, its limitations, and the way to use it.  Throughout this document
proficiency in elementary use of SQL is assumed.
If you are new to this world then pick up any of the
introduction books and study it carefully.
The SQL Implementation front-end is based on the SQL-99 standard,
which is covered in many text books e.g.
@emph{J. Melton and A.R. Simon}, SQL:1999 Understanding
Relational Language Components, ISBN 1558604561.

The architecture is based on a separate compiler module, which translates
SQL statements into MAL. In this process common optimization heuristics,
specific to the relational algebra are performed.
There are bindings for SQL with e.g. JDBC, PHP and C,
(see @ref{Programming Interfaces}) to integrate seamlessly in existing
developments environments.
Client utilities like @ref{Aqua Data Studio},
@ref{DbVisualizer} and @ref{iSQL-Viewer}
work flawlessly with the MonetDB SQL implementation and make
your experience with it even better!

The remainder of this chapter provides a short tutorial to get
going with MonetDB/SQL. A synopsis of the language features
provides a quick intro on the scope of the current implementation
and the short list for functional enhancements planned.
The programming support sections illustrate some of the advanced
features to analyse your SQL code.
@menu
* Getting Started with SQL::
* The VOC Tutorial::
* SQL Language ::
* MonetDB/SQL Features::
@end menu

@node Getting Started with SQL, The VOC Tutorial, SQL, SQL
@section Getting Started with MonetDB/SQL
Working with SQL requires installation of the MonetDB server
and SQL compiler module.  It can be downloaded from the
@url{http://sourceforge.net/project/showfiles.php?group_id=56967,download}
section at SourceForge. It is already included in the Windows installers.

The first step is to start the database back-end following
the steps in @ref{Start and Stop the Server} or illustrated below.
Once it runs, you can choose between a textual interface or
one of the graphical user interfaces.
The easiest to start with is a textual SQL client.
Under Windows, this client is already configured to directly contact
the running server using @code{mjclient}.
For Linux users we illustrate the actions taken behind the scene.

The first action on Linux is to start the database server as described
in @ref{Start and Stop the Server}.

@example
shell> monetdb --start --dbname=voc
Starting database server 'voc'... ok
shell>
@end example
Failures to start the server are reported in the
database log, which you can view using the commands
@example
monetdb --log
monetdb --log --dbname=voc
@end example
The next step is to connect to the server with a textual client.
Two such clients are included in the distribution: @code{mclient} and
@code{mjclient}.

The former is the native, C-implementation of the MonetDB client interface.
It is a no-frills and fast interface geared at developers.
The @code{mjclient} is a Java implementation and it
uses a standardized database interaction protocol.
If you are familiar with JDBC-based applications, or intend to
build those, this interface may be your prime choice.
The @code{mjclient} utility is illustrated:
@example
shell> mjclient --database=voc --user=monetdb
password: *******
Welcome to the MonetDB interactive JDBC terminal!
Database: MonetDB 4.99.19
Driver: MonetDB Native Driver 1.3 (Spur_pre1 20060112)
Type \q to quit, \h for a list of available commands
auto commit mode: on
monetdb->
@end example
The default password for the user @emph{monetdb} is @emph{monetdb}.
The location of the jar file is taken from the MonetDB
installation directory.  @code{mjclient} reads settings from
the @code{~/.monetdb} file (in property=value format) for ease of use.

The world of SQL is now available to the user:
@example
monetdb-> SELECT 'Hello SQL, here I come' AS "message";
+------------------------+
| message                |
+========================+
| Hello SQL, here I come |
+------------------------+
1 row
monetdb->
@end example

The alternative interface is @code{mclient} with its Spartan rendering scheme:
@example
shell> mclient -lsql
sql>SELECT 'Hello SQL, here I come' AS "message";
# . # table_name
# message # name
# char # type
# 22 # length
[ "Hello SQL, here I come"      ]
sql>
@end example

In a clean setup, either client program should run without problems.
If you haven't managed to contact the database server either way,
backtrack your steps. Is the server running? (use @code{monetdb --status})
More arguments may be needed if the server lives on
a different machine or the client does not have access to the
MonetDB configuration file to access the defaults, see @ref{Client Interfaces}
for details.
