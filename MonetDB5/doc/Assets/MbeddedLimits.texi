@section Limitations for Embedded MonetDB

In embedded applications the memory footprint is a factor of concern.
The raw footprint as delivered by the Unix @code{size} command is often used.
It is, however, also easily misleading, because the footprint
depends on both the code segments and buffered database partitions in use.
Therefore it makes sense to experiment with a minimal, but functionally
complete application to decide if the resources limitations are obeyed.

The minimal static footprint of MonetDB is about 16 Mb (+ ca 4Mb for SQL).
After module loading the space quickly grows to about 60Mb.
@emph{This footprint should be reduced.}

@c A better frame of reference for embedded applications is our sample
@c program, which is a simple, yet complete embedded application inspired by an
@c MP3 player. The table below illustrates some basic properties
@c on different embedded SQL platforms.
@c 
@c @multitable @columnfractions 0.2 0.2 0.2 0.2 0.2
@c @item
@c @tab Mbedded
@c @tab SQLite
@c @tab MySQL
@c @tab PostgreSQL
@c @item Prepare time
@c @item Max memory
@c @item CPU time
@c @end multitable
@c The @code{Prepare time} denotes the compilation and link time on
@c a state-of-the-art PC.

The embedded application world calls for many, highly specialized
enhancements. It is often well worth the effort to carve out the
functionality needed from the MonetDB software packages. The easiest
solution to limit the functionality and reduce resource consumption
is to reduce the modules loaded. This requires patches to the
startup scripts.

The benefit of an embedded database application also comes with limitations.
The one and foremost limitation of embedded MonetDB is that the first
application accessing the database effectively locks out any other concurrent
use.
Even in those situations where concurrent applications merely read the database,
or create privately held tables.

