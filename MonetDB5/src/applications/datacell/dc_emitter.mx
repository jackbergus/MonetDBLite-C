@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2006 CWI.
@' All Rights Reserved.

@f dc_emitter
@a M.L. Kersten
@+ Emitter control

An emitter controls the interaction with external devices
and delivers event tuples for processing. It is implemented as
a separate thread of control, which accepts connections
from remote users and issues an acknowledgement using
a hardwired authorization scheme.

The events are collected in two tables. The private
table is used to store the events in progress of being sent over
the communication channel. 

The public table is controlled by a pump query when tuples
are handed over to be shipped.
The benefit of this approach is that the query and
channel manager do not have to regulate their activities
using expensive locking. It is only required at the moment
the private buffer is empty and needs fillings from the public one.

The content of the private table is fully controlled by the
emitter thread. The default policy is to discard
all tuples from the binary as soon as
have been sent to the clients.

The protocol of interaction should be refined to cover
both unilateral emissions, multi-casts and safe delivery.
They are expected to emerge as refinements of the current
basic protocol.

Tuples can be silently droppped when their timeout
expires. This is piggybacked on the transfer of tuples
to the private table and when we run into resource
problems.
@mal

command datacell.getEmitterStatus(nme:str)
address DCgetEmitterStatus
comment "Display the actual state of a emitter.";

command datacell.bindEmitter(sname:str,pname:str) 
		(public:bat[:void,:any_1],private:bat[:void,:any_1])
address DCbindEmitter
comment "Provide private access to a column.";

command datacell.bindEmitterTuple(sname:str,pname:str) 
		(head:any_1,tail:any_2)
address DCbindEmitterTuple
comment "Extract a single tuple from the public bats.";

command datacell.bindEmitter(sname:str,pname:str) :bat[:void,:any_1]
address DCbindEmitterPublic
comment "Provide private access to a public version of a column.";

@{
@- Implementation
The implementation is based on the assumption that 
the sensor produces information for a designated collection
of BATs. A separate process is created for each sensor to receive
and analyse the data. 

@h
#ifndef _DC_EMITTER_DEF
#define _DC_EMITTER_DEF

/* #define DEBUG_DC_EMITTER */

#include "datacell.h"
#include "dc_receptor.h"

dc_export str DCstartDelivery(DCpump p, stream *bs);
dc_export str DClistenEmitter(DCpump p, str *Usockfile);
dc_export str DCspeakThread(SensorInfo sensor);
dc_export void DCreleaseEmitter(DCpump p);

#endif /* _DC_EMITTER_DEF */
@c
#include "dc_emitter.h"

#ifndef DC_H
#define DC_H

#define NEW_ARRAY( type, size )	(type*)GDKmalloc((size)*sizeof(type))
#define STREQ(a, b) 		(strcmp(a, b)==0)

#endif /* DC_H */

#include "mal.h"

#include <stream.h>		/* for stream */

#ifdef HAVE_SYS_SOCKET_H
# include <sys/socket.h>
#endif
#ifdef HAVE_SYS_UN_H
#include <sys/un.h>
#endif

#define SOCKPTR struct sockaddr *
#if HAVE_SOCKLEN_T
#define SOCKLEN socklen_t
#else
#define SOCKLEN int
#endif

#ifdef HAVE_OPENSSL
#include <openssl/ssl.h>
#include <openssl/err.h>
#endif

#include "mtime.h"

static int usock = -1;

#define MAXemitters 5

static DCpump channel;		/* insecure channel between threads! */
mal_export str DCgetEmitterStatus(int *ret);
mal_export str DCbindEmitter(int *retpublic, int *retprivate, str *name, str *cname);
mal_export str DCbindEmitterTuple(int *retpublic, int *retprivate, str *name, str *cname);
mal_export str DCbindEmitterPublic(int *retpublic, str *name, str *cname);
mal_export str DClistenEmitter(DCpump p, str *Usockfile);
mal_export str DCstartDelivery(DCpump p, stream *bs);
mal_export str DCspeakThread(SensorInfo sensor);

str
DCgetEmitterStatus(int *ret)
{
	BAT *bn = DCcontainer(TYPE_int, pumplimit);
	DCpump p;
	oid o = oid_nil;

	for (p = pumps; p < pumps + pumplimit; p++)
		if (p->name && p->kind == EMITTER) {
			BUNins(bn, &o, &p->status,FALSE);
		}
	BBPincref(*ret = bn->batCacheid, TRUE);
	BBPunfix(*ret);
	return MAL_SUCCEED;
}

@-
Gaining access to a column also sets the lock to avoid interference
of other pumps.
Emitter public bats are locked to avoid interference with the
delivery thread.
@c
void
DCreleaseEmitter(DCpump p)
{
	if (p->lock)
		mal_unset_lock(p->lock, "datacell.release");
}

str
DCbindEmitter(int *retpublic, int *retprivate, str *name, str *cname)
{
	DCpump p;
	int i;

	p = DClocatePump(*name);
	if (p == 0)
		return throwMessage("datacell.bindEmitter", "unknown emitter");
	if (p->kind != EMITTER)
		return throwMessage("datacell.bindEmitter", "unknown emitter");
	for (i = 0; i < p->cols; i++)
		if (strcmp(p->columns[i], *cname) == 0) {
			mal_set_lock(p->lock, "datacellIsolate");

			if (p->usedby && p->usedby != p - pumps) {
				mal_unset_lock(p->lock, "datacellIsolate");

				return throwMessage("datacell.isolate", "Pump still in use\n");
			}

			BBPincref(*retpublic = p->public[i]->batCacheid, TRUE);
			BBPincref(*retprivate = p->private[i]->batCacheid, TRUE);
			p->usedby = p - pumps;
			mal_unset_lock(p->lock, "datacellIsolate");
			break;
		}
	return MAL_SUCCEED;
}

@-
It is also possible to pick up a single tuple from the public part.
@c
str
DCbindEmitterTuple(int *retpublic, int *retprivate, str *name, str *cname)
{
	DCpump p;
	int i;

	p = DClocatePump(*name);
	if (p == 0)
		return throwMessage("datacell.bindEmitter", "unknown emitter");
	if (p->kind != EMITTER)
		return throwMessage("datacell.bindEmitter", "unknown emitter");
	for (i = 0; i < p->cols; i++)
		if (strcmp(p->columns[i], *cname) == 0) {
			mal_set_lock(p->lock, "datacellIsolate");

			if (p->usedby && p->usedby != p - pumps) {
				mal_unset_lock(p->lock, "datacellIsolate");

				return throwMessage("datacell.isolate", "Pump still in use\n");
			}

			BBPincref(*retpublic = p->public[i]->batCacheid, TRUE);
			BBPincref(*retprivate = p->private[i]->batCacheid, TRUE);
			p->usedby = p - pumps;
			mal_unset_lock(p->lock, "datacellIsolate");
			break;
		}
	return MAL_SUCCEED;
}

str
DCbindEmitterPublic(int *retpublic, str *name, str *cname)
{
	DCpump p;
	int i;

	p = DClocatePump(*name);
	if (p == 0)
		return throwMessage("datacell.bindEmitter", "unknown emitter");
	if (p->kind != EMITTER)
		return throwMessage("datacell.bindEmitter", "unknown emitter");
	for (i = 0; i < p->cols; i++)
		if (strcmp(p->columns[i], *cname) == 0) {
			mal_set_lock(p->lock, "datacellIsolate");

			if (p->usedby && p->usedby != p - pumps) {
				mal_unset_lock(p->lock, "datacellIsolate");

				return throwMessage("datacell.isolate", "Pump still in use\n");
			}
			p->usedby = p - pumps;
			mal_unset_lock(p->lock, "datacellIsolate");
			BBPincref(*retpublic = p->public[i]->batCacheid, TRUE);
			break;
		}
	return MAL_SUCCEED;
}

@-
The process thread for a channel should differentiate between
receptor/emitter and active/passive communication.
@c
str
DClistenEmitter(DCpump p, str *Usockfile)
{
	struct sockaddr_in server;
	int sock = -1;
	SensorInfo sensor = GDKmalloc(sizeof(SensorInfo));

#ifdef HAVE_SYS_UN_H
	struct sockaddr_un userver;
#endif
	SOCKLEN length = 0;
	int on = 1;
	int i = 0;
	int pid, *pidp = &pid;
	char *usockfile, host[512];

	channel = p;
	if (Usockfile == NULL || *Usockfile == 0 || strcmp(*Usockfile, str_nil) == 0)
		usockfile = NULL;
	else {
#ifdef HAVE_SYS_UN_H
		usockfile = GDKstrdup(*Usockfile);
#else
		usockfile = NULL;
		GDKwarning("DClistenEmitter: Unix domain sockets are not supported\n");
#endif
	}

	if (p->port <= 0 && usockfile == NULL)
		return throwMessage("datacell.listen", "no port or socket file specified\n");

	if (p->port > 0) {
		sock = socket(AF_INET, SOCK_STREAM, 0);
		if (sock < 0)
			return throwMessage("datacell.listen", "creation of stream socket failed\n");
@-
Set server port and allow network connections from any workstation.
Bind the socket to the server port.
The port id should be obtained from the Homes file.
@c
		server.sin_family = AF_INET;
		server.sin_addr.s_addr = INADDR_ANY;
		server.sin_port = htons((unsigned short) ((p->port) & 0xFFFF));
		for (i = 0; i < 8; i++)
			server.sin_zero[i] = 0;

		setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, (char *) &on, sizeof on);

		length = (SOCKLEN) sizeof(server);
		if (bind(sock, (SOCKPTR) & server, length) < 0)
			return throwMessage("datacell.listen", "binding to stream socket failed\n");
@-
Get the new information for the server socket and start listening.
@c
		if (getsockname(sock, (SOCKPTR) & server, &length) < 0)
			return throwMessage("datacell.listen", "Failed getting socket name\n");
		listen(sock, MAXemitters);
	}
	(void)usock;
#ifdef HAVE_SYS_UN_H
	if (usockfile) {
		usock = socket(AF_UNIX, SOCK_STREAM, 0);
		if (usock < 0) {
			unlink(usockfile);
			return throwMessage("datacell.listen", "creation of Unix socket failed\n");
		}
		userver.sun_family = AF_UNIX;
		strncpy(userver.sun_path, usockfile, sizeof(userver.sun_path));

		length = (SOCKLEN) sizeof(userver);
		if (bind(usock, (SOCKPTR) & userver, length) < 0) {
			unlink(usockfile);
			return throwMessage("datacell.listen", "binding to Unix socket file failed\n");
		}
		listen(usock, MAXemitters);
	}
#endif

#ifdef DEBUG_DC_EMITTER
	THRprintf(GDKerr, "DClisten:Network started at %d\n", p->port);
#endif
	sensor->socket = sock;

	p->status = 1;
	if (MT_create_thread((MT_Id *) pidp, (void (*)(void *)) DCspeakThread, sensor) < 0) {
		return throwMessage("datacell.listen", "starting thread failed");
	}
#ifdef HAVE_SYS_UN_H
	if (usockfile)
		unlink(usockfile);
#endif
	if (p->host == 0)
		gethostname(host, (int) 512);
	else
		strcpy(host, p->host);
#ifdef DEBUG_DC_EMITTER
	{
		char msg[512];

		snprintf(msg, (int) 512, "#Ready to write sensor data to connection %s:%d\n", host, p->port);
		stream_printf(GDKout, "%s", msg);
	}
#endif
	return MAL_SUCCEED;
}

@+ Event delivery
The current implementation taps into the ASCII io writer,
which means we are producing MonetDB tuple format descriptions.
As soon as the tuples are written, the BATs are cleared and
the emitter has to await new ones to arrive in the public part.
Failure to write the tuples keep them around for a next pick up.
The drain property can be used to move the content to a log table.
@c
str
DCstartDelivery(DCpump p, stream *bs)
{
	int i;
	BAT *b;
	size_t cnt;

	(void) p;
	(void) bs;

#ifdef DEBUG_DC_EMITTER
	stream_printf(GDKout, "#Start emitter %s %d columns\n", p->name, p->cols);
#endif
	do {
		if ((cnt = BATcount(p->private[0]))) {
#ifdef DEBUG_DC_EMITTER
			stream_printf(GDKout, "send tuples %d\n", cnt);
#endif
			BATmultiprintf(bs, p->cols + 1, p->private, 0, 0, 0);
			if (stream_errnr(bs))
				 break;

			p->received += cnt;
			p->calls++;
			if (p->drain) {
				/* save the information sent out */
			}
			for (i = 0; i < p->cols; i++)
				BATclear(p->private[i]);
		}
		if ((cnt = BATcount(p->public[p->cols - 1]))) {
#ifdef DEBUG_DC_EMITTER
			stream_printf(GDKout, "grab new tuples %d\n", cnt);
#endif
			/* new tuples have arrived */
			mal_set_lock(p->lock, "datacellIsolate");

#ifdef DEBUG_DC_EMITTER
			stream_printf(GDKout, "got them tuples %d\n", cnt);
#endif
			for (i = 0; i < p->cols; i++) {
				b = p->public[i];
				p->public[i] = p->private[i];
				p->private[i] = b;
			}
			mal_unset_lock(p->lock, "datacellIsolate");
		} else if (p->delay) {
			MT_sleep_ms(p->delay);
		}
	} while (!stream_errnr(bs));

#ifdef DEBUG_DC_EMITTER
	stream_printf(GDKerr, "#DCstartDelivery:channel writing finished\n");
	stream_printf(GDKerr, "#DCstartDelivery:error= %d\n", stream_errnr(bs));
#endif
	stream_close(bs);

	return MAL_SUCCEED;
}
@-
The listen thread operation now simply opens the connection
and passed control to the event delivery
@c

str
DCspeakThread(SensorInfo sensor)
{
	char *msg = 0;
	stream *fromServer;

#ifdef DEBUG_DC_EMITTER
	stream_printf(GDKerr, "#Write thread started\n");
#endif
	do {
		int retval;
		struct timeval tv;
		fd_set fds;
		int msgsock;
		int sock = sensor->socket;

		FD_ZERO(&fds);
		if (sock >= 0)
			FD_SET(sock, &fds);
#ifdef HAVE_SYS_UN_H
		if (usock >= 0)
			FD_SET(usock, &fds);
#endif
		/* Wait up to 0.5 seconds. */
		tv.tv_sec = 0;
		tv.tv_usec = 500;

		/* temporarily use msgsock to record the larger of sock and usock */
		msgsock = sock;
#ifdef HAVE_SYS_UN_H
		if (usock > sock)
			msgsock = usock;
#endif
		retval = select(msgsock + 1, &fds, NULL, NULL, &tv);
		if (retval == 0) {
			/* nothing interesting has happened */
			MT_sleep_ms(100);
			continue;
		}
		if (retval < 0) {
			if (MT_geterrno() != EINTR) {
				msg = "select failed\n";
				goto emittererror;
			}
			continue;
		}
		if (sock >= 0 && FD_ISSET(sock, &fds)) {
			if ((msgsock = accept(sock, (SOCKPTR) 0, (SOCKLEN *) 0)) < 0) {
				if (MT_geterrno() != EINTR) {
					msg = "accept failed\n";
					goto emittererror;
				}
				continue;
			}
#ifdef HAVE_SYS_UN_H
		} else if (usock >= 0 && FD_ISSET(usock, &fds)) {
			if ((msgsock = accept(usock, (SOCKPTR) 0, (SOCKLEN *) 0)) < 0) {
				if (MT_geterrno() != EINTR) {
					msg = "accept failed\n";
					goto emittererror;
				}
				continue;
			}
#endif
		} else
			continue;
#ifdef DEBUG_DC_EMITTER
		stream_printf(GDKerr, "#emitter connection request:accepted\n");
#endif
		fromServer = block_stream(socket_wstream(msgsock, "Emitter output"));

		if (fromServer == 0 || stream_errnr(fromServer)) {
			GDKsyserror("#DCspeak:fromServer problems\n");
			continue;
		}
#ifdef DEBUG_DC_EMITTER
		stream_printf(GDKerr, "#DCspeak:channel accepted %d\n", msgsock);
#endif
		msg = DCstartDelivery(channel, fromServer);
	} while (msg == MAL_SUCCEED);
      emittererror:
#ifdef DEBUG_DC_EMITTER
	stream_printf(GDKout, "Connection failed: %s\n", msg);
#endif
	return throwMessage("datacell.listen", msg);
}
@}
