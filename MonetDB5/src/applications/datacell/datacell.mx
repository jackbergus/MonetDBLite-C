@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2005 CWI.
@' All Rights Reserved.
@f datacell
@a M.L. Kersten
@+ MonetDB DataCell
The datacell (DC) module is an application module designed to
collect events from streams over an IP and to store them in a
container for archiving, processing and delivery.

The DC module was inspired by the toy-story and e-health setting at Philips
and the astronomers reading out their devices causing massive simple
insert statements to be fired at a database backend. The target is to
bring MonetDB closer to this sensor application field, which communicate
through a network or WIFI devices that aren;t energy limited.
A concrete instance would be a disk-based access point that receives 
connections and handles the events directly.
The recordings are received int tuple load format, i.e. ASCII strings, and
stored in a MonetDB database as groups of BATs for
subsequent filtering, cleaning, and querying.

It is matched with a web-application, called Monet's DataCell,
which provides a low entry point for casual users to explore
this facility. 

The implementation is centered around a small container catalogue,
which describes the events record structure.
It is complemented with separate tables for 'receptors',
'emitters', and 'nucleus'. The receptors contains the properties
to manage the event input streams, the emitters the delivery part.
The nucleus contains SQL and MAL descriptors to convert
the database periodically.

Listening to a sensor is explicitly activated and leads to a
dedicated processing thread handling the update request.
All events are tagged with the receiving time and those
to that left the system are archived as well.

It should be possible to control the capacity of the event containers 
and describe follow-up actions.
Furthermore, the remote access facility of MonetDB should be used
to move the completed event containers to an archive store or
backend server with sufficient capabilities for post-processing.

@mal
include sql;

module pumps; # will contain the pump queries
module datacell;

pattern open():void
address DCopen
comment "Initialize the datacell and activate the data pumps";
pattern close():void
address DCclose
comment "Shutdown the datacell";
pattern destroy():void
address DCdestroy
comment "Destroy the datacell cataloques";

command receptor(sname:str, host:str, port:int)
address DCreceptor
comment "Define the properties of a single receptor pump and link
        it with a port.";

command nucleus(name:str)
address DCnucleus
comment "Define a nucleus pump container ";

command emitter(sname:str, host:str, port:int)
address DCemitter
comment "Define the properties of a single emitter pump and link
        it with a port.";

pattern define(name:str, cname:str, val:any):void
address DCdefine
comment "Describes a column for a pump";


command setTimeWindow(sname:str, delay:int, timeout:int)
address DCsetTimeWindow
comment "Update the preferred time window for pump cycles";

command drop(name:str) :void
address DCdrop
comment "Release a pump ";

command take(name:str,cname:str):bat[:void,:any]
address DCtake
comment "Return the BAT with collected sensor input";

command keep(nme:str, dst:bat[:any$1,:any$2],src:bat[:any$1,:any$2])
		:bat[:any$1,:any$2]
address DCkeep
comment "Overload append to synchronize with emitter semantics";

command keep(nme:str, dst:bat[:any$1,:any$2],src:any$2)
		:bat[:any$1,:any$2]
address DCkeepTuple
comment "Overload append to synchronize with emitter semantics";
@-
The inspection routines below are heaviliy influenced
by the requirements of the DataCell web applications.
@mal
command getReceptors():bat[:void,:str]
address DCgetReceptors
comment "Retrieve the names of all receptors";

command getNucleus():bat[:void,:str]
address DCgetNucleus
comment "Retrieve the names of all nuclei containers";

command getEmitters():bat[:void,:str]
address DCgetEmitters
comment "Retrieve the names of all receptors";

command getSource(name:str):bat[:void,:str]
address DCgetSource
comment "Retrieve the names of all dependent transformations";

command getSink(name:str):bat[:void,:str]
address DCgetSink
comment "Retrieve the names of all dependent transformations";

command getProperties(cname:str):bat[:str,:str]
address DCgetProperties
comment "Retrieve the static properties of a pump";

command getDynamicProperties(cname:str):bat[:str,:str]
address DCgetDynamicProperties
comment "Retrieve the dynamic properties of a container";

command getPumps():bat[:str,:str]
address DCgetPumps
comment "Retrieve the names of all pumps";

command getQueries():bat[:str,:str]
address DCgetQueries
comment "Retrieve the pump queries";

command getReceptorHost():bat[:void,:str]
address DCgetReceptorHost
comment "Retrieve the receptor hosts";

command getPort(nme:str):int
address DCgetPort
comment "Retrieve the port";

command getHost(nme:str):str
address DCgetHost
comment "Retrieve the host";

command getTimeout(nme:str):int
address DCgetTimeout
comment "Retrieve the timeout";

command getDocumentation(nme:str):str
address DCgetDocumentation
comment "Retrieve the documentation url";

command getQuery(nme:str):str
address DCgetQuery
comment "Retrieve the query text";

command putDocumentation(nme:str,txt:str):void
address DCputDocumentation
comment "Save the description for a unit";

command getPicture(nme:str):str
address DCgetPicture
comment "Retrieve the picture";

command putPicture(nme:str,txt:str):void
address DCputPicture
comment "Save the picture for a unit";

command getReceptorPorts(nme:str):bat[:void,:int]
address DCgetReceptorPorts
comment "Retrieve the receptor ports";

command getEmitterPorts(nme:str):bat[:void,:int]
address DCgetEmitterPorts
comment "Retrieve the receptor ports";

command getStatus():bat[:void,:int]
address DCgetStatus
comment "Retrieve the status of all";

command getLog(nme:str):bat[:timestamp,:str]
address DCgetLog
comment "Retrieve the activity log for a unit";

command commit(fname:str):lng
address DCsaveCatalogue
comment "Save a text file to reload the catalogue";

command dump()
address DCdumpCatalogue
comment "Display the datacell cataloque";

command showContainer(cname:str, first:int, last:int):void
address DCshowContainer
comment "Show a page of the (reverse ordered) container";

include dc_compiler;
include dc_receptor;
include dc_emitter;
include dc_scheduler;
@- Implementation
The implementation is based on the assumption that 
the sensor produces information for a designated collection
of BATs. A separate process is created for each sensor to receive
and analyse the data. 

@h
#ifndef _DATACELL_DEF
#define _DATACELL_DEF

/* #define DEBUG_DATACELL */

#define MAXEVENTFIELDS 256

#include "mal.h"
#include "mal_client.h"
#include "mal_interpreter.h"
#include "../modules/mal/tablet.h"
#include "mal_exception.h"
#include "mtime.h"

typedef enum { RECEPTOR, NUCLEUS, EMITTER } DATACELLKIND;

typedef struct DC_PUMP {
	DATACELLKIND kind;
	str name;		/* pump name */
	int cols;		/* actual number of colums */
	int cap;		/* n-ary capacity */
	str host;		/* for receport and emitters */
	int port;

	MT_Lock lock;		/* to use it privately */
	int usedby;		/* points to the pump claiming the public part */
	str *columns;		/* column names */
	int *types;		/* their internal type */
	BAT **private;		/* bat ids for the connection point */
	BAT **public;		/* work bats to process */
	str *source;		/* source connections for the pump */
	str *sink;		/* target connections for the pump */

	str lang;		/* query language */
	str query;		/* pump query */
	str *mal;		/* mal functions for execution */
	MalBlkPtr *malblk;	/* corresponding blocks */
	str drain;		/* drain query plan */
	str maldrain;		/* mal functions to implement the drain */

	str documentation, picture;

	int delay;		/* in milliseconds */
	int timeout;		/* in milliseconds */

	/* scheduling properties here */
	int scheduler;		/* which queue to use */
	int status;		/* scheduling status */
	int pending;		/* events received for processing */
	int received;		/* total received/sent events since start */
	timestamp start;	/* first event time stamp */
	lng ticks;		/* ticks spent in receiving data */
	int calls;		/* number of batch reads */
} *DCpump, DCpumpRecord;

#ifdef _MSC_VER
#ifndef LIBDATACELL
#define dc_export extern __declspec(dllimport)
#else
#define dc_export extern __declspec(dllexport)
#endif
#else
#define dc_export extern
#endif

dc_export DCpump DCnewPump();
dc_export ptr isReceptor(str name);
dc_export ptr isEmitter(str name);
dc_export DCpump DClocatePump(str nme);
dc_export BAT *DCcontainer(int tpe, int cap);
dc_export void DCstamp(DCpump p);

dc_export DCpump pumps;
dc_export int pumpindex, pumplimit;
#endif /* _DATACELL_DEF */
@-
The datacell module uses a global known dictionary to keep track
of the datacell and its properties. This way it becomes easy
to restart sensor input collection between sessions.
Furthermore, the BATs can be made accessible from the SQL frontend.
@c
#include "datacell.h"

char *cellKind[] = { "receptor", "nucleus", "emitter", "pump" };

@-
The pump containers are actually simple relational tables.
The first implementation was focussed on storing everything
in BATs. This leads to an explosion of code and is less
efficient, because related information has to be
reconstructed using joins.
In the second phase, the code is transformed into
a traditional linked datastructure, while the BAT
views can be used to make it visible at the MAL layer
for inspection.

To simplify our life, all dynamic tables are equal in size
as described by the capacity.
@c

DCpump pumps;
int pumpindex, pumplimit;

DCpump
DCnewPump()
{
	DCpump c;

	for (c = pumps; c < pumps + pumplimit; c++)
		if (c->name == 0)
			break;

	if (c == pumps + pumplimit) {
		GDKfatal("out of pumpt descriptors\n");
		return 0;
	}
	c->name = 0;
	c->cols = 0;
	c->cap = MAXPARAMS;
	/* leaks, later */
	c->columns = (str *) GDKmalloc(c->cap * sizeof(str));
	memset((char *) c->columns, 0, c->cap * sizeof(str));
	c->types = (int *) GDKmalloc(c->cap * sizeof(int));
	memset((char *) c->types, 0, c->cap * sizeof(int));
	c->private = (BAT **) GDKmalloc(c->cap * sizeof(BAT *));
	memset((char *) c->private, 0, c->cap * sizeof(BAT *));
	c->public = (BAT **) GDKmalloc(c->cap * sizeof(BAT *));
	memset((char *) c->public, 0, c->cap * sizeof(BAT *));
	c->source = (str *) GDKmalloc(c->cap * sizeof(str));
	memset((char *) c->source, 0, c->cap * sizeof(str));
	c->sink = (str *) GDKmalloc(c->cap * sizeof(str));
	memset((char *) c->sink, 0, c->cap * sizeof(str));
	c->mal = (str *) GDKmalloc(c->cap * sizeof(str));
	memset((char *) c->mal, 0, c->cap * sizeof(str));
	c->malblk = (MalBlkPtr *) GDKmalloc(c->cap * sizeof(MalBlkPtr));
	memset((char *) c->malblk, 0, c->cap * sizeof(MalBlkPtr));
	c->query = NULL;
	c->documentation = NULL;
	c->picture = NULL;
	c->usedby = 0;
	c->status = -1;		/* no thread yet */
	c->lock = MT_create_lock();

	pumpindex++;
	return c;
}

void
DCdisplayPump(DCpump p)
{
	str nme;
	int i;

	switch (p->kind) {
	case RECEPTOR:
		nme = "receptor";
		break;
	case EMITTER:
		nme = "emmitter";
		break;
	case NUCLEUS:
		nme = "nucleus";
		break;
	default:
		nme = "unknown";
	}
	stream_printf(GDKout, "%s %s (", nme, p->name);
	for (i = 0; i < p->cap && p->columns[i]; i++)
		stream_printf(GDKout, "%c %s %s", (i ? ',' : ' '), p->columns[i], getTypeName(p->types[i]));
	stream_printf(GDKout, ");\n");
}

@-
Serialization of the internal data structure uses the BAT structures
of MonetDB. This way can also provide easy access by simply serialization
followed by read-only access to the BAT structures.
@c
str
DCsaveCatalogue(int *ret, str *backup)
{
	stream *s = open_wastream(*backup);
	DCpump p;
	int j;

	(void) ret;
	mal_set_lock(mal_contextLock, "datacell");
	/* create a text file for reloading using MAL */

	for (p = pumps; p < pumps + pumpindex; p++)
		if (p->name) {
			if (p->kind == RECEPTOR)
				stream_printf(s, "datacell.receptor(\"%s\",\"%s\",\"%s\",%d);\n", p->name, p->name, p->host, p->port);
			if (p->kind == EMITTER)
				stream_printf(s, "datacell.emitter(\"%s\",\"%s\",\"%s\",%d);\n", p->name, p->name, p->host, p->port);
			for (j = 0; p->columns[j]; j++) {
				stream_printf(s, "datacell.define(\"%s\",\"%s\",:%s);\n", p->name, p->columns[j], getTypeName(p->types[j]));
			}

		}
	/* create a new set of BATs to keep the DataCell catalogue around */
	mal_unset_lock(mal_contextLock, "datacell");
	return MAL_SUCCEED;
}

str
DCloadCatalogue(int *ret, str *backup)
{
	(void) ret;
	(void) backup;
	/* just re-run the backup file */
	return MAL_SUCCEED;
}

DCpump
DClocatePump(str nme)
{
	DCpump p;

	for (p = pumps; p < pumps + pumpindex; p++)
		if (p->name && strcmp(p->name, nme) == 0)
			return p;
	return NULL;
}

#define DCtemplate "datacell_%s_%s"
static BAT *
DCcreate(str hnme, str tnme, int tt, int cap)
{
	BAT *b;
	char buf[128];

	snprintf(buf, 128, DCtemplate, hnme, tnme);
	b = BATdescriptor(BBPindex(buf));
	if (b)
		BATdestroy(b);

	b = BATnew(TYPE_void, tt, cap);
	BATseqbase(b, 0);
	if (b == NULL)
		GDKfatal("sensor.create:could not allocate.");

	BATkey(b, TRUE);
	BBPrename(b->batCacheid, buf);
	BATmode(b, PERSISTENT);
	BATcommit(b);
#ifdef DEBUG_DATACELL
	stream_printf(GDKout, "#created %s\n", buf);
#endif
	return b;
}

void
DCinit()
{
	mal_set_lock(mal_contextLock, "datacell");
	pumps = (DCpump) GDKmalloc(128 * sizeof(DCpumpRecord));
	memset((char *) pumps, 0, 128 * sizeof(DCpumpRecord));
	pumpindex = 0;
	pumplimit = 128;
	mal_unset_lock(mal_contextLock, "datacell");
}

@-
Dropping a connection point implies dropping also its container.
@c
str
DCdropPump(str sname)
{
	DCpump p = DClocatePump(sname);
	int i;
	str backup = ".datacell.mal";

	if (p == NULL)
		return throwMessage("datacell.drop", "Could not locate pump");

#ifdef DEBUG_DATACELL
	stream_printf(GDKout, "#drop connection %s\n", sname);
#endif
	GDKfree(p->name);	/* mark as free */
	/* release the BATs */
	for (i = 0; i < p->cols; i++) {
		BBPdecref(p->private[i]->batCacheid, TRUE);
		BBPunfix(p->private[i]->batCacheid);
		p->private[i] = 0;
		BBPdecref(p->public[i]->batCacheid, TRUE);
		BBPunfix(p->public[i]->batCacheid);
		p->public[i] = 0;
	}
	DCsaveCatalogue(&i, &backup);
	return MAL_SUCCEED;
}

str
DCdumpCatalogue(int *ret)
{
	DCpump p;

	(void) ret;

	for (p = pumps; p < pumps + pumpindex; p++)
		if (p->name)
			DCdisplayPump(p);
	return MAL_SUCCEED;
}

str
DCshowContainer(int *ret, str *cname, int *first, int *last)
{
	DCpump p;

	(void) ret;
	(void) first;
	(void) last;
	p = DClocatePump(*cname);
	if (p == 0)
		return throwMessage("datacell.showContainer", "Pump not found");
	BATmultiprintf(GDKout, p->cols + 1, p->public, 1, 0, 1);
	/* BATmultiprintf(GDKout,p->cols+1,p->private,1,0,1); */
	return MAL_SUCCEED;
}

@- Module initializaton
The content of this box my only be changed by the Administrator.
@= authorize
	/* if( !isAuthorized("Admin"))
		return throwMessage("datacell.@1","unauthorized access to 'datacell' box");*/
@c

int
isAuthorized(str nme)
{
	Client c;

	if (nme == 0)
		return 1;
	c = getClient();
	return idcmp(c->user, nme) == 0;
}

@- Operator implementation
@c
str
DCopen(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	static int opened = FALSE;

	(void) mb;
	(void) stk;
	(void) pci;		/* fool compiler */

	/* load the catalogue  and activate the system */
	if (!opened) {
		DCinit();
		opened = TRUE;
	}
	return MAL_SUCCEED;
}

str
DCclose(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	(void) mb;
	(void) stk;
	(void) pci;		/* fool compiler */
	/* shutdown the system */
	return MAL_SUCCEED;
}


str
DCdestroy(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	DCpump p;

	(void) mb;
	(void) stk;
	(void) pci;
#ifdef DEBUG_DATACELL
	stream_printf(GDKout, "#About to destroy all pumps \n");
#endif
	for (p = pumps; p < pumps + pumplimit; p++)
		if (p->name)
			DCdropPump(p->name);
	DCinit();
	return MAL_SUCCEED;
}

int
isColumnDefined(str name, str cname)
{
	DCpump p;
	int i;

	p = DClocatePump(name);
	if (p == 0)
		return FALSE;
	for (i = 0; i < p->cap && p->columns[i]; i++)
		if (strcmp(p->columns[i], cname) == 0)
			return TRUE;
	return FALSE;
}

BAT *
DCcontainer(int tpe, int cap)
{
	BAT *bn;
	char buf[128], *tname;

	bn = BATnew(TYPE_void, tpe, cap);
	if (bn == NULL)
		return 0;

	tname = getTypeName(tpe);
	snprintf(buf, 128, DCtemplate, "void", tname);
	GDKfree(tname);

	BATseqbase(bn, 0);
	BATkey(bn, TRUE);
	BBPrename(bn->batCacheid, buf);
	BATmode(bn, PERSISTENT);
	BATcommit(bn);
	return bn;
}

void
DCstamp(DCpump p)
{
	if (p->cols == 0) {
		p->columns[0] = GDKstrdup("stamp");
		p->types[0] = getTypeIndex("timestamp", 9, TYPE_int);
		p->private[0] = DCcontainer(p->types[0], 256);
		p->public[0] = DCcontainer(p->types[0], 256);
		p->cols++;
	}
}
str
DCdefine(MalBlkPtr mb, MalStkPtr stk, InstrPtr pc)
{
	DCpump p;
	int tpe, i;
	str name, cname;

	name = (str) getArgValue(stk, pc, 1);
	cname = (str) getArgValue(stk, pc, 2);
	tpe = getArgType(mb, pc, 3);

	p = DClocatePump(name);
	if (p == 0)
		return throwMessage("datacell.define", "Pump not found");
	if (strcmp(cname, "stamp") == 0)
		return throwMessage("datacell.define", "reserved identifier");

	/* check for duplicates */
	for (i = 0; i < p->cols; i++)
		if (strcmp(p->columns[i], cname) == 0)
			return throwMessage("datacell.define", "Column already defined");

	DCstamp(p);

	if (p->cols < p->cap) {
		p->columns[p->cols] = GDKstrdup(cname);
		p->types[p->cols] = tpe;
		p->private[p->cols] = DCcontainer(tpe, 256);
		p->public[p->cols++] = DCcontainer(tpe, 256);
	} else
		return throwMessage("datacell.define", "out of column space");
	return MAL_SUCCEED;
}

ptr
isTransform(str name)
{
	DCpump p;

	p = DClocatePump(name);
	return (p && p->query) ? p : 0;
}

ptr
isReceptor(str name)
{
	DCpump p;

	p = DClocatePump(name);
	return (p && p->kind == RECEPTOR) ? p : 0;
}

ptr
isEmitter(str name)
{
	DCpump p;

	p = DClocatePump(name);
	return (p && p->kind == EMITTER) ? p : 0;
}

ptr
isNucleus(str name)
{
	DCpump p;

	p = DClocatePump(name);
	return (p && p->kind == NUCLEUS) ? p : 0;
}

str
DCnucleus(int *ret, str *name)
{
	DCpump p;

	(void) ret;

	if (DClocatePump(*name))
		return throwMessage("datacell.nucleus", "pump defined twice");
	p = DCnewPump();
	p->kind = NUCLEUS;
	p->name = GDKstrdup(*name);
	return MAL_SUCCEED;
}

str
DCreceptor(int *ret, str *name, str *host, int *port)
{
	DCpump p;

	(void) ret;

	if (DClocatePump(*name))
		return throwMessage("datacell.receptor", "pump defined twice");
	p = DCnewPump();
	p->kind = RECEPTOR;
	p->name = GDKstrdup(*name);
	p->host = GDKstrdup(*host);
	p->port = *port;
	return MAL_SUCCEED;
}

str
DCemitter(int *ret, str *name, str *host, int *port)
{
	DCpump p;

	(void) ret;

	if (DClocatePump(*name))
		return throwMessage("datacell.receptor", "pump defined twice");
	p = DCnewPump();
	p->kind = EMITTER;
	p->name = GDKstrdup(*name);
	p->host = GDKstrdup(*host);
	p->port = *port;
	return MAL_SUCCEED;
}

@-
The take() operation returns a view on a container.
@c
str
DCtake(int *ret, str *cname, str *pname)
{
	(void) ret;
	(void) cname;
	(void) pname;
	return throwException(MALEXCEPTION, "datacell.take", "Not implemented");
}

@-
Releasing a receptor/emitter means turning off the capturing of events.
@c
str
DCstop(int *ret, str sname)
{
	DCpump p;

	(void) ret;
#ifdef DEBUG_DATACELL
	stream_printf(GDKout, "#release event stream %s\n", *sname);
#endif
	p = DClocatePump(sname);
	if (p == 0)
		return throwException(MALEXCEPTION, "datacell.release", "pump not defined");
	p->status = 0;
	return MAL_SUCCEED;
}

str
DCstopAll(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	(void) mb;
	(void) stk;
	(void) pci;		/* fool compiler */
	return MAL_SUCCEED;
}

str
DCdrop(int *ret, str *name)
{
	(void) ret;
	return DCdropPump(*name);
}

str
DCgetKind(int *bid, int kind)
{
	BAT *bn = DCcontainer(TYPE_str, pumplimit);
	DCpump p;
	oid o = oid_nil;

	for (p = pumps; p < pumps + pumplimit; p++)
		if (p->name && p->kind == kind) {
			BUNins(bn, &o, p->name);
		}
	BBPincref(*bid = bn->batCacheid, TRUE);
	BBPunfix(*bid);
	return MAL_SUCCEED;
}

str
DCgetReceptors(int *bid)
{
	return DCgetKind(bid, RECEPTOR);
}

str
DCgetNucleus(int *bid)
{
	return DCgetKind(bid, NUCLEUS);
}

str
DCgetEmitters(int *bid)
{
	return DCgetKind(bid, EMITTER);
}

str
DCgetPumps(int *bid)
{
	BAT *bn = BATnew(TYPE_str, TYPE_str, pumplimit);
	DCpump p;

	for (p = pumps; p < pumps + pumpindex; p++)
		if (p->name)
			BUNins(bn, cellKind[p->kind], p->name);
	BBPincref(*bid = bn->batCacheid, TRUE);
	BBPunfix(*bid);
	return MAL_SUCCEED;
}

str
DCgetQueries(int *bid)
{
	BAT *bn = BATnew(TYPE_str, TYPE_str, pumplimit);
	DCpump p;

	for (p = pumps; p < pumps + pumpindex; p++)
		if (p->name)
			BUNins(bn, p->name, p->query ? p->query : "");
	BBPincref(*bid = bn->batCacheid, TRUE);
	BBPunfix(*bid);
	return MAL_SUCCEED;
}

str
DCgetSource(int *bid, str *name)
{
	DCpump p;
	BAT *bn;
	int i;
	oid o = oid_nil;

	p = DClocatePump(*name);
	if (p == NULL)
		return throwMessage("datacell.getSource", "Cannot find pump");
	bn = DCcontainer(TYPE_str, pumplimit);
	for (i = 0; i < p->cap && p->source[i]; i++)
		BUNins(bn, &o, p->source[i]);
	BBPincref(*bid = bn->batCacheid, TRUE);
	BBPunfix(*bid);
	return MAL_SUCCEED;
}

str
DCgetSink(int *bid, str *name)
{
	DCpump p;
	BAT *bn;
	int i;
	oid o = oid_nil;

	p = DClocatePump(*name);
	if (p == NULL)
		return throwMessage("datacell.getSource", "Cannot find pump");
	bn = DCcontainer(TYPE_str, pumplimit);
	for (i = 0; i < p->cap && p->sink[i]; i++)
		BUNins(bn, &o, p->sink[i]);
	BBPincref(*bid = bn->batCacheid, TRUE);
	BBPunfix(*bid);
	return MAL_SUCCEED;
}

str
DCgetProperties(int *bid, str *name)
{
	DCpump p;
	BAT *bn;
	str tname;
	int i;

	p = DClocatePump(*name);
	if (p == NULL)
		return throwMessage("datacell.getProperties", "Cannot find pump");
	bn = BATnew(TYPE_str, TYPE_str, 256);
	if (bn == NULL)
		return throwMessage("datacell.getProperties", "Cannot create container");
	for (i = 0; i < p->cols; i++) {
		tname = getTypeName(p->types[i]);
		BUNins(bn, p->columns[i], tname);
		GDKfree(tname);
	}
	BBPincref(*bid = bn->batCacheid, TRUE);
	return MAL_SUCCEED;
}

str
DCgetDynamicProperties(int *bid, str *name)
{
	DCpump p;
	BAT *bn;
	char buf[128];

	/* lng v; */
	timestamp ts;

	p = DClocatePump(*name);
	if (p == NULL)
		return throwMessage("datacell.getProperties", "Cannot find pump");
	bn = BATnew(TYPE_str, TYPE_str, 256);
	if (bn == NULL)
		return throwMessage("datacell.getDynamicProperties", "Cannot create container");

	if (p->host) {
		BUNins(bn, "host", p->host);
		snprintf(buf, 128, "%d", p->port);
		BUNins(bn, "port", buf);
	}

	if (p->delay) {
		snprintf(buf, 128, "%d", p->delay);
		BUNins(bn, "delay", buf);
	}
	if (p->timeout) {
		snprintf(buf, 128, "%d", p->timeout);
		BUNins(bn, "timeout", buf);
	}
	snprintf(buf, 128, "%d", p->status);
	BUNins(bn, "status", buf);
	if (p->pending) {
		snprintf(buf, 128, "%d", p->pending);
		BUNins(bn, "pending", buf);
	}
	/* locate first and list timestamp in private */
	if (BATcount(p->private[0]) > 0) {
		str msg1 = GDKmalloc(128);
		str msg2 = GDKmalloc(128);
		int len = 128;

		ts = *(timestamp *) BUNtail(p->private[0], BUNfirst(p->private[0]));
		timestamp_tostr(&msg1, &len, &ts);
		ts = *(timestamp *) BUNtail(p->private[0], BUNptr(p->private[0], BATcount(p->private[0]) - 1));
		timestamp_tostr(&msg2, &len, &ts);
		if (strncmp(msg1, msg2, 10) == 0) {
			BUNins(bn, "first", msg1 + 10);
			BUNins(bn, "last", msg2 + 10);
		} else {
			BUNins(bn, "first", msg1);
			BUNins(bn, "last", msg2);
		}
		GDKfree(msg1);
		GDKfree(msg2);
	}
	if (p->status >= 0) {
		snprintf(buf, 128, "%d", p->received);
		if (p->kind == RECEPTOR)
			BUNins(bn, "received", buf);
		else
			BUNins(bn, "sent", buf);
		snprintf(buf, 128, "%d", p->calls);
		if (p->kind == NUCLEUS)
			BUNins(bn, "runs", buf);
		else
			BUNins(bn, "batches", buf);
		if (p->ticks > 0) {
			double rate = (p->received + 0.0) / (p->ticks / 1000.0);

			if (rate * 1000 >= 1)
				snprintf(buf, 128, "%4.2f/sec", rate * 1000.0);
			else
				snprintf(buf, 128, "%4.2f/ms", rate);
			BUNins(bn, "rate", buf);
		}
	}

	BBPincref(*bid = bn->batCacheid, TRUE);
	return MAL_SUCCEED;
}

str
DCgetLog(int *bid)
{
	(void) bid;
	return throwMessage("datacell.getLog", "nyi\n");
}

int
getPort(str name)
{
#ifdef DEBUG_DATACELL
	stream_printf(GDKout, "#Find port of %s\n", name);
#endif
	DCpump p;

	p = DClocatePump(name);
	if (p && (p->kind == RECEPTOR || p->kind == EMITTER))
		return p->port;
	return -1;
}

str
DCgetPort(int *ret, str *nme)
{
	*ret = getPort(*nme);
	return MAL_SUCCEED;
}

int
getTimeout(str name)
{
	DCpump p;

#ifdef DEBUG_DATACELL
	stream_printf(GDKout, "#Find timeout of %s\n", name);
#endif
	p = DClocatePump(name);
	if (p && (p->kind == RECEPTOR || p->kind == EMITTER))
		return p->timeout;
	return -1;
}

str
DCsetTimeWindow(int *ret, str *name, int *delay, int *timeout)
{
	DCpump p;

	(void) ret;
	p = DClocatePump(*name);
	if (p && !(p->kind == RECEPTOR || p->kind == EMITTER))
		return throwMessage("datacell.setTimeWindow", "connection required");
	p->delay = *delay;
	p->timeout = *timeout;
	return MAL_SUCCEED;
}

str
DCgetTimeout(int *ret, str *nme)
{
	*ret = getTimeout(*nme);
	return MAL_SUCCEED;
}

str
DCgetPorts(int *ret, int kind)
{
	BAT *bn = DCcontainer(TYPE_int, pumplimit);
	DCpump p;
	oid o = oid_nil;

	for (p = pumps; p < pumps + pumplimit; p++)
		if (p->name && p->kind == kind) {
			BUNins(bn, &o, &p->port);
		}
	BBPincref(*ret = bn->batCacheid, TRUE);
	BBPunfix(*ret);
	return MAL_SUCCEED;
}

str
DCgetEmitterPorts(int *ret)
{
	return DCgetPorts(ret, EMITTER);
}

str
DCgetReceptorPorts(int *ret)
{
	return DCgetPorts(ret, RECEPTOR);
}

str
getHost(str name)
{
	DCpump p;

	p = DClocatePump(name);
	if (p && (p->kind == RECEPTOR || p->kind == EMITTER))
		return p->host;
	return 0;
}

str
DCgetHost(str *ret, str *name)
{
	str n = 0;

	if (strlen(*name) > 0)
		n = getHost(*name);
	if (n == 0)
		return throwMessage("datacell.getHost", "Host not defined");
	*ret = GDKstrdup(n);
	return MAL_SUCCEED;
}

str
DCgetDocumentation(str *ret, str *name)
{
	DCpump p;

	p = DClocatePump(*name);
	if (p && (p->kind == RECEPTOR || p->kind == EMITTER || p->kind == NUCLEUS) && p->documentation) {
		*ret = GDKstrdup(p->documentation);
	} else
		*ret = GDKstrdup("");
	return MAL_SUCCEED;
}

str
DCgetQuery(str *ret, str *name)
{
	DCpump p;

	p = DClocatePump(*name);
	if (p && p->query) {
		*ret = GDKstrdup(p->query);
	} else
		*ret = GDKstrdup("");
	return MAL_SUCCEED;
}

str
DCputDocumentation(int *ret, str *name, str *txt)
{
	DCpump p;

	(void) ret;
	p = DClocatePump(*name);
	if (p && (p->kind == RECEPTOR || p->kind == EMITTER || p->kind == NUCLEUS)) {
		p->documentation = GDKstrdup(*txt);
		return MAL_SUCCEED;
	}
	return throwMessage("datacell.putDocumentation", "Description not defined");
}

str
DCgetPicture(str *ret, str *name)
{
	DCpump p;

	p = DClocatePump(*name);
	if (p && (p->kind == RECEPTOR || p->kind == EMITTER || p->kind == NUCLEUS) && p->picture) {
		*ret = GDKstrdup(p->picture);
		return MAL_SUCCEED;
	}
	return throwMessage("datacell.getPicture", "Picture not defined");
}

str
DCputPicture(int *ret, str *name, str *txt)
{
	DCpump p;

	(void) ret;
	p = DClocatePump(*name);
	if (p && (p->kind == RECEPTOR || p->kind == EMITTER || p->kind == NUCLEUS)) {
		p->picture = GDKstrdup(*txt);
		return MAL_SUCCEED;
	}
	return throwMessage("datacell.putPicture", "Pump not defined");
}


str
DCgetHosts(int *ret, int kind)
{
	BAT *bn = DCcontainer(TYPE_str, pumplimit);
	DCpump p;
	oid o = oid_nil;

	for (p = pumps; p < pumps + pumplimit; p++)
		if (p->name && p->kind == kind) {
			BUNins(bn, &o, p->host);
		}
	BBPincref(*ret = bn->batCacheid, TRUE);
	BBPunfix(*ret);
	return MAL_SUCCEED;
}

str
DCgetEmitterHost(int *ret)
{
	return DCgetHosts(ret, EMITTER);
}

str
DCgetReceptorHost(int *ret)
{
	return DCgetHosts(ret, RECEPTOR);
}

str
DCgetStatus(int *ret)
{
	BAT *bn = DCcontainer(TYPE_int, pumplimit);
	DCpump p;
	oid o = oid_nil;

	for (p = pumps; p < pumps + pumpindex; p++)
		if (p->name) {
			BUNins(bn, &o, &p->status);
		}
	BBPincref(*ret = bn->batCacheid, TRUE);
	BBPunfix(*ret);
	return MAL_SUCCEED;
}

int
setStatus(str name, int status)
{
	DCpump p;

	p = DClocatePump(name);
	if (p)
		p->status = status;
	return 0;
}

@-
Before you start updating the emitter public part it should be locked.
It is released explicitedly.
@c
#include "bat.h"

str
DCkeep(int *ret, str *name, int *dst, int *src)
{
	DCpump p;
	str msg;

	p = DClocatePump(*name);
	if (p == 0 || p->kind != EMITTER)
		return throwMessage("datacell.append", "Pump lost");
	/* mal_set_lock(p->lock,"datacell.append"); */
	msg = (str) BKCbat_append_void_bat_wrap(ret, dst, src);
	/* mal_unset_lock(p->lock,"datacell.append"); */
	return msg;
}

str
DCkeepTuple(int *ret, str *name, int *dst, void *src)
{
	DCpump p;
	str msg;

	p = DClocatePump(*name);
	if (p == 0 || p->kind != EMITTER)
		return throwMessage("datacell.append", "Pump lost");
	/* mal_set_lock(p->lock,"datacell.append"); */
	msg = (str) BKCbat_append_val_wrap(ret, dst, src);
	/* mal_unset_lock(p->lock,"datacell.append"); */
	return msg;
}

@}
