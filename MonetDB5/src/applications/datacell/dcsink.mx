@* The streamSink program

This program collects the events from a DataCell emitter .
The controlling parameters are the host (-h), the port id (-p).
Reading the events from the DataCell can be delayed (-D)
a number of milliseconds.
@f dcsink
@c
#include "mal_config.h"
#include <gdk.h>

#ifdef HAVE_UNISTD_H
# include <unistd.h>
#endif
#include  <stdio.h>
#ifdef HAVE_PWD_H
#include  <pwd.h>
#endif
#include  <sys/types.h>

#ifdef HAVE_SYS_SOCKET_H
# include <sys/socket.h>
#endif
#ifdef NATIVE_WIN32
# include <winsock.h>
#endif
#ifdef HAVE_SYS_UN_H
#include <sys/un.h>
#endif

#include  <signal.h>
#include  <string.h>
#include  <memory.h>

#if TIME_WITH_SYS_TIME
# include <sys/time.h>
# include <time.h>
#else
# if HAVE_SYS_TIME_H
#  include <sys/time.h>
# else
#  include <time.h>
# endif
#endif

#include <stream.h>		/* for stream */

#define MAXBUFFER 1024

stream *fromServer;

char *
connect_to_server(char *hostname, int port)
{
	struct sockaddr_in server;

#ifdef HAVE_SYS_UN_H
	/* struct sockaddr_un userver; */
#endif
	struct sockaddr *serv;
	size_t servsize;
	int s;

#ifdef HAVE_SYS_UN_H
	/* if (
	   hostname && hostname[0] == '/') {
	   if (strlen(hostname) >= sizeof(userver.sun_path)) {
	   return "path name too long";
	   }
	   userver.sun_family = AF_UNIX;
	   strncpy(userver.sun_path, hostname, sizeof(userver.sun_path));
	   serv = (struct sockaddr *) &userver;
	   servsize = sizeof(userver);
	   } else
	 */
#endif
	{
		struct hostent *hp;

		hp = gethostbyname(hostname);
		if (hp == NULL) {
			return "gethostbyname failed";
		}
		memset(&server, 0, sizeof(server));
		memcpy(&server.sin_addr, hp->h_addr, hp->h_length);
		server.sin_family = hp->h_addrtype;
		server.sin_port = htons((unsigned short) (port & 0xFFFF));
		serv = (struct sockaddr *) &server;
		servsize = sizeof(server);
	}

	s = socket(serv->sa_family, SOCK_STREAM, IPPROTO_TCP);
	if (s < 0) {
		return "Open socket failed";
	}

	if (connect(s, serv, servsize) < 0) {
#ifdef NATIVE_WIN32
		fprintf(stderr, "!ERROR reconnect: connect: error %d\n", WSAGetLastError());
#else
		perror("!ERROR reconnect: connect");
#endif
		return "Setup connection failed";
	}
	fromServer = block_stream(socket_rstream(s, "sensorDump "));
	if ((fromServer) == NULL || stream_errnr(fromServer)) {
		return "stream closed";
	}

	return NULL;
}

void
usage()
{
	printf("sensorDump -h <host> -p <port>  -d <delay>\n");
	printf("-h host name, default localhost\n");
	printf("-p port id, default 50000\n");
	printf("-d delay in milliseconds, default 0\n");
	exit(-1);
}

int
main(int argc, char **argv)
{
	int i;
	char *err;
	char *host = "localhost";
	int port = 50000;
	int delay = -1, tries = 10;
	time_t t;
	char buf[4 * BLOCK];
	bstream *bs;

	if (argc == 1)
		usage();

	for (i = 1; i < argc; i++)
		switch (argv[i][1]) {
		case 'h':
			host = argv[++i];
			break;
		case 'p':
			port = strtol(argv[++i], 0, 0);
			break;
		case 'd':
			delay = strtol(argv[++i], 0, 0);
			break;
		case '?':
			usage();
			return (-1);
		default:
			printf("Unknown option %s\n", argv[i]);
			return -1;
		}
	printf("sensorDump -h %s -p %d -d %d\n", host, port, delay);
	if ((err = connect_to_server(host, port))) {
		printf("FATAL:%s\n", err);
		return -1;
	}

	bs = bstream_create(fromServer, 4 * BLOCK);

	do {
		stream_read(bs->s, buf, 4 * BLOCK, 1);

		if (buf[0]) {
			time(&t);
			printf("#%s%s\n", ctime(&t), buf);
			bs->pos = 0;
			bs->len = 0;
			bs->eof = 0;

			buf[0] = 0;
		} else {
			MT_sleep_ms(1000);
			tries--;
		}
	} while (tries >= 0 && !stream_errnr(bs->s));
	if (stream_errnr(bs->s))
		 printf("%s: READ ERROR\n", ctime(&t));

	return 0;
}
