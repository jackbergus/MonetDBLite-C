@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2007 CWI.
@' All Rights Reserved.

@f stethoscope
@a Martin Kersten
@v 1.0
@+ The Stethoscope
The MonetDB kernel carries a profiler infrastructure, which
can be precisely controlled through a MAL program. 
Often, however, inclusion of profiling statements in a proram
is an afterthought.

The program @code{stethoscope} addresses this situation by providing
a simple application that can attach itself to a running
server and extracts the profiler events from concurrent running queries.

The arguments to @code{stethoscope} are the profiler properties to be traced
and the applicable filter expressions. For example,
@example
stethoscope -t bat.insert algebra.join
@end example
tracks the usec ticks of two specific MAL instructions.
A synopsis of the calling conventions:
@verbatim
	stethoscope [options] +[efoTtcmibds] {<mod>.<fcn>}
	-d | --dbname=<database_name>
	-u | --user=<user>
	-P | --password=<password>
	-p | --port=<portnr>
	-h | --host=<hostname>

    e =event
    f =function 
    o =operation called
    T =time
    t =ticks
    c =cpu statistics
    m =memory resources
    i =io resources
    b =bytes read/written
    d =diskspace needed
    s =statement
@end verbatim

Ideally, the stream of events should be piped into a
2D graphical tool, like xosview (Linux).

@{
@c
#include "mal_config.h"
#include "monet_options.h"
#include <gdk.h>
#include <Mapi.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>


static struct {
	char tag;
    char *ptag;       /* which profiler counter is needed */
    char *name;       /* which logical counter is needed */
    int status;     /* trace it or not */
} profileCounter[] = {
    /*  6  */  {'e', "event", "event id", 0},
    /*  5  */  {'f', "pc", "function", 0},
    /*  5  */  {'f', "pc", "pc", 0},
    /*  5  */  {'o', "operation","operation", 0},
    /*  0  */  {'T', "time", "time stamp", 0},
    /*  1  */  {'t', "ticks", "usec ticks", 1},
    /*  2  */  {'c', "cpu", "utime", 0},
    /*  2  */  {'c', "cpu", "cutime", 0},
    /*  2  */  {'c', "cpu", "stime", 0},
    /*  2  */  {'c', "cpu", "cstime", 0},
    /*  3  */  {'m', "memory", "arena", 0},
    /*  3  */  {'m', "memory", "ordblks", 0},
    /*  3  */  {'m', "memory", "smblks", 0},
    /*  3  */  {'m', "memory", "hblkhd", 0},
    /*  3  */  {'m', "memory", "hblks", 0},
    /*  3  */  {'m', "memory", "fsmblks", 0},
    /*  3  */  {'m', "memory", "uordblks", 0},
    /*  4  */  {'i', "io","pg reclaim", 0},
    /*  4  */  {'i', "io","pg faults", 0},
    /*  4  */  {'i', "io","swaps", 0},
    /*  4  */  {'i', "io","blk reads", 0},
    /*  4  */  {'i', "io","blk writes", 0},
    /*  4  */  {'i', "io","ctxt switch", 0},
    /*  4  */  {'i', "io","inv switch", 0},
    /*  8  */  {'b', "bytes", "rdbytes", 0},
    /*  9  */  {'b', "bytes", "wrbytes", 0},
    /*  10 */  {'d', "disk", "diskspace", 0},
    /*  7  */  {'s', "statement", "statement", 2},
    /*  11 */  {0, 0,  0, 0}
};

static Mapi dbh;
static MapiHdl hdl = NULL;

#define die(dbh,hdl) (hdl?mapi_explain_query(hdl,stderr):		\
						   dbh?mapi_explain(dbh,stderr):			\
							   fprintf(stderr,"command failed\n"),	\
					   exit(-1))

#define doQ(X) \
	if ((hdl = mapi_query(dbh, X)) == NULL || mapi_error(dbh) != MOK) \
		die(dbh, hdl);

void
usage(){
	fprintf(stderr,"stethoscope [options] +[Ttcmipesrwd] {<mod>.<fcn>}\n");
	fprintf(stderr,"-d | --dbname=<database_name>\n");
	fprintf(stderr,"-u | --user=<user>\n");
	fprintf(stderr,"-P | --password=<password>\n");
	fprintf(stderr,"-p | --port=<portnr>\n");
	fprintf(stderr,"-h | --host=<hostname>\n");

	fprintf(stderr,"    e =event\n");
	fprintf(stderr,"    f =function \n");
	fprintf(stderr,"    o =operation called\n");
	fprintf(stderr,"    T =time\n");
	fprintf(stderr,"    t =ticks\n");
	fprintf(stderr,"    c =cpu statistics\n");
	fprintf(stderr,"    m =memory resources\n");
	fprintf(stderr,"    i =io resources\n");
	fprintf(stderr,"    b =bytes read/written\n");
	fprintf(stderr,"    d =diskspace needed\n");
	fprintf(stderr,"    s =statement\n");
}
@-
Any signal should be captured and turned into a graceful
termination of the profiling session.
@c
void
stopListening(int i){
	(void) i;
	signal(i, SIG_IGN);
	doQ("profiler.setNone();");
	doQ("profiler.stop();");
	doQ("profiler.closeStream();");
	exit(0);
}

void setCounter(char *nme){
	int i,k=1;
	
	printf("update fields;%s\n",nme);
	for(i=0; profileCounter[i].tag; i++)
		profileCounter[i].status=0;

	for( ; *nme; nme++)
	for(i=0; profileCounter[i].tag; i++)
		if( profileCounter[i].tag == *nme)
			profileCounter[i].status= k++;
}
char *
getFieldName(int k){
	int i;
	for(i=0; profileCounter[i].tag; i++)
		if( profileCounter[i].status== k)
			return profileCounter[i].name;
	return "unknown";
}

int main(int argc, char **argv)
{
	int a=1,i=1;
	char * response, *error;
	char buffer[1024];
	char *mod, *fcn;
	char *host="localhost";
	int	portnr= 50000;
	char *dbname= NULL;
	char *user= "monetdb";
	char *passwrd= "monetdb";

    static struct option long_options[13] = {
        {"dbname", 1, 0, 'd'},
        {"user", 1, 0, 'u'},
        {"passwrd", 1, 0, 'P'},
        {"port", 1, 0, 'p'},
        {"host", 1, 0, 'h'},
        {"help", 1, 0, '?'},
        {0, 0, 0, 0}
    };
	for(;;){
		int option_index=0;
		int c=  getopt_long(argc, argv, "d:u:P:p:?:h:",
                    long_options, &option_index);
		if( c == -1)
			break;
		switch(c){
		case 'd':
			if (strcmp(long_options[option_index].name, "dbname") == 0) {
				dbname= optarg;
				break;
			}
		case 'u':
			if (strcmp(long_options[option_index].name, "user") == 0) {
				user= optarg;
				break;
			}
		case 'P':
			if (strcmp(long_options[option_index].name, "passwrd") == 0) {
				passwrd= optarg;
				break;
			}
		case 'p':
			if (strcmp(long_options[option_index].name, "port") == 0) {
				portnr= atol(optarg);
				break;
			}
		case 'h':
			if (strcmp(long_options[option_index].name, "host") == 0) {
				passwrd= optarg;
				break;
			}
		default:
			usage();
			exit(0);
		}
	}

	a= optind;
	if(argc>1 && argv[a][0]=='+'){
		if( argv[a][1]=='?'){
			usage();
			exit(0);
		} else
			setCounter(argv[a++]+1);
	}

	signal(SIGABRT, stopListening);
	signal(SIGPIPE, stopListening);
	signal(SIGHUP, stopListening);
	signal(SIGTERM, stopListening);
	signal(SIGKILL, stopListening);
	signal(SIGINT, stopListening);

	/* set up the profiler */

	dbh = mapi_connect(host, portnr, user, passwrd, "mal", NULL);
	if (mapi_error(dbh))
		die(dbh, hdl);
	/* mapi_trace(dbh,1);*/

	/* set counters */
	for(i=0; profileCounter[i].tag; i++){
		snprintf(buffer,1024,"profiler.activate(\"%s\");",
			profileCounter[i].ptag);
		if( profileCounter[i].status){
			doQ(buffer);
		}
	}

	/* Set Filters */
	doQ("profiler.openStream(\"stdout\");");
	if(a== argc) {
		doQ("profiler.setAll();");
	} else
	for(; a <argc; a++){
		char *c;
		c= strchr(argv[a],'.');
		if(  c ){
			mod= argv[a];
			fcn= c+1;
			*c=0;
		} else {
			fcn= argv[a];
			mod= "*";
		}
		snprintf(buffer,1024, "profiler.setFilter(\"%s\",\"%s\");",mod,fcn);
		printf("%s\n",buffer);
		doQ(buffer);
	}
	doQ("profiler.start();");

	for(; mapi_error(dbh) == MOK ; ){
		while ( (response= mapi_fetch_line(hdl)) ) {
			printf("%s\n",response);
		}
		if( (error = mapi_result_error(hdl)) != NULL){
			mapi_explain_result(hdl,stderr);
			break;
		}
		MT_sleep_ms(20);	/* 20 milliseconds seems enough */
		doQ("");
	} 
	if (mapi_error(dbh) != MOK)
		die(dbh, hdl);
	mapi_close_handle(hdl);
	if (mapi_error(dbh) != MOK)
		die(dbh, hdl);
	mapi_destroy(dbh);

	return 0;
}

@}
