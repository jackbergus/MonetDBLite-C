@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
@' Copyright August 2008-2009 MonetDB B.V.
@' All Rights Reserved.

@f stethoscope
@a Martin Kersten
@v 1.0
@+ The Stethoscope
The performance profiler infrastructure provides
precisely control through annotation of a MAL program. 
Often, however, inclusion of profiling statements is an afterthought.

The program @code{stethoscope} addresses this situation by providing
a simple application that can attach itself to a running
server and extracts the profiler events from concurrent running queries.

The arguments to @code{stethoscope} are the profiler properties to be traced
and the applicable filter expressions. For example,
@example
stethoscope -t bat.insert algebra.join
@end example
tracks the microsecond ticks of two specific MAL instructions.
A synopsis of the calling conventions:
@verbatim
	stethoscope [options] +[aefoTtcmibds] @{<mod>.<fcn> @}
	-d | --dbname=<database_name>
	-u | --user=<user>
	-P | --password=<password>
	-p | --port=<portnr>
	-g | --gnuplot=<boolean>
	-h | --host=<hostname>

Event selector:
	a =aggregates
    e =event
    f =function 
    o =operation called
    T =time
    t =ticks
    c =cpu statistics
    m =memory resources
    i =io resources
    b =bytes read/written
    d =diskspace needed
    s =statement
	p =pgfaults,cntxtswitches
@end verbatim

Ideally, the stream of events should be piped into a
2D graphical tool, like xosview (Linux).
A short term solution is to generate a gnuplot script
to display the numerics organized as time lines.
With a backup of the event lists give you all the
information needed for a descent post-mortem analysis.

A convenient way to watch most of the SQL interaction
you may use the command:
stethoscope  +tis algebra.* bat.* group.* sql.* aggr.*
@{
@c
#include "mal_config.h"
#include "monet_options.h"
#include <gdk.h>
#include <mapilib/Mapi.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>

#ifndef HAVE_GETOPT_LONG
#  include "monet_getopt.h"
#else
# ifdef HAVE_GETOPT_H
#  include "getopt.h"
# endif
#endif


static struct {
	char tag;
    char *ptag;       /* which profiler counter is needed */
    char *name;       /* which logical counter is needed */
    int status;     /* trace it or not */
} profileCounter[] = {
    /*  0  */  {'a', "aggregate", "total count", 0},
    /*  1  */  {'a', "aggregate", "total ticks", 0},
    /*  2  */  {'e', "event", "event id", 0},
    /*  3  */  {'f', "pc", "function", 0},
    /*  4  */  {'f', "pc", "pc", 0},
    /*  5  */  {'o', "operation","operation", 0},
    /*  6  */  {'T', "time", "time stamp", 0},
    /*  7  */  {'t', "ticks", "usec ticks", 1},
    /*  8  */  {'c', "cpu", "utime", 0},
    /*  9  */  {'c', "cpu", "cutime", 0},
    /*  0  */  {'c', "cpu", "stime", 0},
    /*  1  */  {'c', "cpu", "cstime", 0},
    /*  1  */  {'c', "cpu", "thread", 0},
    /*  2  */  {'m', "memory", "arena", 0},
    /*  3  */  {'m', "memory", "ordblks", 0},
    /*  4  */  {'m', "memory", "smblks", 0},
    /*  5  */  {'m', "memory", "hblkhd", 0},
    /*  6  */  {'m', "memory", "hblks", 0},
    /*  7  */  {'m', "memory", "fsmblks", 0},
    /*  8  */  {'m', "memory", "uordblks", 0},
    /*  9  */  {'i', "io","blk reads", 0},
    /*  0  */  {'i', "io","blk writes", 0},
    /*  1  */  {'b', "bytes", "rdbytes", 0},
    /*  2  */  {'b', "bytes", "wrbytes", 0},
    /*  3  */  {'d', "disk", "diskspace", 0},
    /*  4  */  {'s', "statement", "statement", 2},
    /*  5  */  {'p', "process","pg reclaim", 0},
    /*  6  */  {'p', "process","pg faults", 0},
    /*  7  */  {'p', "process","swaps", 0},
    /*  8  */  {'p', "process","ctxt switch", 0},
    /*  9  */  {'p', "process","inv switch", 0},
    /*  0  */  {0, 0,  0, 0}
};

static Mapi dbh;
static MapiHdl hdl = NULL;

#define die(dbh,hdl) (hdl?mapi_explain_query(hdl,stderr):		\
						   dbh?mapi_explain(dbh,stderr):			\
							   fprintf(stderr,"command failed\n"),	\
					   exit(-1))

#define doQ(X) \
	if ((hdl = mapi_query(dbh, X)) == NULL || mapi_error(dbh) != MOK) \
		die(dbh, hdl);

void
usage(){
	fprintf(stderr,"stethoscope [options] +[Ttcmipesrwd] {<mod>.<fcn>}\n");
	fprintf(stderr,"-d | --dbname=<database_name>\n");
	fprintf(stderr,"-u | --user=<user>\n");
	fprintf(stderr,"-P | --password=<password>\n");
	fprintf(stderr,"-p | --port=<portnr>\n");
	fprintf(stderr,"-h | --host=<hostname>\n");
	fprintf(stderr,"-g | --gnuplot\n");

	fprintf(stderr,"The trace options:\n");
	fprintf(stderr,"    a =aggregates\n");
	fprintf(stderr,"    e =event\n");
	fprintf(stderr,"    f =function \n");
	fprintf(stderr,"    o =operation called\n");
	fprintf(stderr,"    T =time\n");
	fprintf(stderr,"    t =ticks\n");
	fprintf(stderr,"    c =cpu statistics\n");
	fprintf(stderr,"    m =memory resources\n");
	fprintf(stderr,"    i =io resources\n");
	fprintf(stderr,"    b =bytes read/written\n");
	fprintf(stderr,"    d =diskspace needed\n");
	fprintf(stderr,"    s =statement\n");
	fprintf(stderr,"    p =pg faults, cntxt switches\n");
}
@-
Any signal should be captured and turned into a graceful
termination of the profiling session.
@c
void
stopListening(int i){
	(void) i;
	signal(i, SIG_IGN);
	doQ("profiler.setNone();");
	doQ("profiler.stop();");
	doQ("profiler.closeStream();");
	exit(0);
}

void setCounter(char *nme){
	int i,k=1;
	
	for(i=0; profileCounter[i].tag; i++)
		profileCounter[i].status=0;

	for( ; *nme; nme++)
	for(i=0; profileCounter[i].tag; i++)
		if( profileCounter[i].tag == *nme)
			profileCounter[i].status= k++;
}
char *
getFieldName(int k){
	int i;
	for(i=0; profileCounter[i].tag; i++)
		if( profileCounter[i].status== k)
			return profileCounter[i].name;
	return "unknown";
}

void
plottemplate(int * colind, int n){
	FILE *pl,*pld;
	double sz= 1.0/n;
	int i;

	pl= fopen("stet.gp","w");
	fprintf(pl,"load \"stet_dyn.gp\"\n");
	fprintf(pl,"pause 1\nreread \n");
	fclose(pl); 
/*	pld= fopen("stet_dyn_tmpl.gp","w");*/
	pld= fopen("stet_dyn.gp","w");
	fprintf(pld,"set multiplot\n\n");
	for(i=0;i<n;i++){
		fprintf(pld,"set size 1.0, 1.0 \nset origin 0.0, 0.0 \n");
		fprintf(pld,"set size 1.0,%4.2f\n",sz);
		fprintf(pld,"set origin 0.0,%4.2f\n",1-(i+1)*sz);
		fprintf(pld,"set ylabel \"%s\"\n", profileCounter[colind[i]].name);
		fprintf(pld,"unset key\n");
		fprintf(pld,"plot \"stet_cur.dat\" using 1:%d with boxes fs solid 0.7\n\n",i+2);
	}
	fprintf(pld,"\nunset multiplot"); 
	
	fclose(pld); 

	}



int main(int argc, char **argv)
{
	int a=1,i=1,ln=1;
	char * response, *x;
	char buf[BUFSIZ];
	char *mod, *fcn;
	char *host="localhost";
	int	portnr= 50000;
	char *dbname= NULL;
	char *user= "monetdb";
	char *password= "monetdb";
	FILE *d;
	char cmd[100];
	int colind[30],colcnt=0;
	stream *s;
	int gnuplot=FALSE;

    static struct option long_options[8] = {
        {"dbname", 1, 0, 'd'},
        {"user", 1, 0, 'u'},
        {"password", 1, 0, 'P'},
        {"port", 1, 0, 'p'},
        {"host", 0, 0, 'h'},
        {"help", 0, 0, '?'},
        {"gnuplot", 1, 0, 'g'},
        {0, 0, 0, 0}
    };
	for(;;){
		int option_index=0;
		int c=  getopt_long(argc, argv, "d:u:P:p:?:h:g",
                    long_options, &option_index);
		if( c == -1)
			break;
		switch(c){
		case 'd':
			dbname= optarg;
			break;
		case 'u':
			user= optarg;
			break;
		case 'P':
			password= optarg;
			break;
		case 'p':
			portnr= atol(optarg);
			break;
		case 'g':
			gnuplot= TRUE;
			break;
		case 'h':
			if (strcmp(long_options[option_index].name, "help") == 0) {
				printf("help\n");
			}
			if (strcmp(long_options[option_index].name, "host") == 0) {
				host= optarg;
				break;
			}
		default:
			usage();
			exit(0);
		}
	}

	a= optind;
	if(argc>1 && a<argc && argv[a][0]=='+'){
		setCounter(argv[a]+1);
		a++;
	}

	signal(SIGABRT, stopListening);
#ifdef SIGPIPE
	signal(SIGPIPE, stopListening);
#endif
#ifdef SIGHUP
	signal(SIGHUP, stopListening);
#endif
	signal(SIGTERM, stopListening);
	signal(SIGINT, stopListening);

	/* set up the profiler */

	dbh = mapi_connect(host, portnr, user, password, "mal", dbname);
	if (mapi_error(dbh))
		die(dbh, hdl);
	/* mapi_trace(dbh,1);*/
	printf("#connection with server for '%s' established\n",dbname);

	/* set counters */
	for(i=0; profileCounter[i].tag; i++){
		/* deactivate any left over counter first */
		snprintf(buf,BUFSIZ,"profiler.deactivate(\"%s\");",
			profileCounter[i].ptag);
		doQ(buf);
		snprintf(buf,BUFSIZ,"profiler.activate(\"%s\");",
			profileCounter[i].ptag);
		if( profileCounter[i].status){
			doQ(buf);
			colind[colcnt++]=i;
		}
	}

/*	printf("Column index \n");
	for(j=0;j<colcnt;j++)
		printf("%d\t",colind[j]);
	printf("\n");  */
	
	/* Set Filters */
	snprintf(buf,BUFSIZ,"profiler.openStream(\"%s\", %d);", host, portnr);
	doQ(buf);

	if ((s = udp_rastream(host, portnr, "profileStream")) == NULL)
		perror("stream failed\n");
	doQ("profiler.setNone();");

	if(a== argc) {
		doQ("profiler.setAll();");
	} else
	for(; a <argc; a++){
		char *c;
		c= strchr(argv[a],'.');
		if(  c ){
			mod= argv[a];
			if( mod==c) mod="*";
			fcn= c+1;
			if( *fcn == 0) fcn="*";
			*c=0;
		} else {
			fcn= argv[a];
			mod= "*";
		}
		snprintf(buf,BUFSIZ, "profiler.setFilter(\"%s\",\"%s\");",mod,fcn);
		printf("%s\n",buf);
		doQ(buf);
	}
	doQ("profiler.start();");

	if(gnuplot)
		plottemplate(colind,colcnt);

	printf("#ready to receive events\n");
	while( stream_read(s, buf, 1, BUFSIZ) ) {
		char *e;
		response = buf;
		while((e=strchr(response,'\n')) != NULL) {
			*e = 0;
			printf("%s\n", response);
			x=strchr(response,'[');
			if (gnuplot && x){
				d= fopen("stet.dat","a+");
				fprintf(d,"%d\t",ln++);
				for(;*x!='\0';x++)
					if( *x == '"') break; /* stop at first string */
					else
					if (strchr("[],\"",*x)==NULL)
						fprintf(d,"%c",*x);
				fprintf(d,"\n");
				fclose(d);
				
			/* update plot file */
						
				if (ln > 20)
					sprintf(cmd,"sed '1, %d d' stet.dat > stet_cur.dat",ln-20);
				else 
					sprintf(cmd,"cp stet.dat stet_cur.dat");
			/*	printf("%s \n",cmd);*/
				if (system(cmd) != 0)
					fprintf(stderr, "command `%s' failed\n", cmd);
			}
			response = e+1;
		}
	} 

	doQ("profiler.closeStream();");
	if (mapi_error(dbh) != MOK)
		die(dbh, hdl);
	mapi_close_handle(hdl);
	if (mapi_error(dbh) != MOK)
		die(dbh, hdl);
	mapi_destroy(dbh);

	return 0;
}

@}
