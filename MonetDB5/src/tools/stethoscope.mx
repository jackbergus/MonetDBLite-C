@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2007 CWI.
@' All Rights Reserved.

@f stethoscope
@a Martin Kersten
@v 1.0
@+ The Stethoscope
The MonetDB kernel carries a profiler infrastructure, which
can be precisely controlled through a MAL program. 
Often, however, inclusion of profiling statements in a proram
is an after thought.

The program @code{stethoscope} addresses this situation by providing
a simple application that can attach itself to a running
server and extracts the profiler events from concurrent running queries.

The arguments to @code{stethoscope} are the profiler properties to be traced
and the applicable filter expressions. For example,
@example
stethoscope -t bat.insert algebra.join
@end example
tracks the usec ticks of two specific MAL instructions.
A synopsis of the calling conventions:
@verbatim
	stethoscope [options] +[Ttcmipesrwd] {<mod>.<fcn>}
	-d | --dbname=<database_name>
	-u | --user=<user>
	-P | --password=<password>
	-p | --port=<portnr>
	-h | --host=<hostname>

    T =time
    t =ticks
    c =cpu
    m =memory
    i =io
    p =pc
    e =event
    s =statement
    r =rdbytes
    w =wrbytes
    d =diskspace
@end verbatim

Ideally, the stream of events should be piped into a
2D graphical tool, like xosview (Linux).

@{
@c
#include "mal_config.h"
#include "monet_options.h"
#include <Mapi.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>


static struct {
	char tag;
    char *name;       /* which logical counter is needed */
    int status;     /* trace it or not */
} profileCounter[] = {
    /*  0  */  {'T', "time", 0},
    /*  1  */  {'t', "ticks", 1},
    /*  2  */  {'c', "cpu", 0},
    /*  3  */  {'m', "memory", 0},
    /*  4  */  {'i', "io", 0},
    /*  5  */  {'p', "pc", 0},
    /*  6  */  {'e', "event", 0},
    /*  7  */  {'s', "statement", 2},
    /*  8  */  {'r', "rdbytes", 3},
    /*  9  */  {'w', "wrbytes", 4},
    /*  10 */  {'d', "diskspace", 0},
    /*  11 */  {0,  0, 0}
};

static Mapi dbh;
static MapiHdl hdl = NULL;

#define die(dbh,hdl) (hdl?mapi_explain_query(hdl,stderr):		\
						   dbh?mapi_explain(dbh,stderr):			\
							   fprintf(stderr,"command failed\n"),	\
					   exit(-1))

#define doQ(X) \
	if ((hdl = mapi_query(dbh, X)) == NULL || mapi_error(dbh) != MOK) \
		die(dbh, hdl);

void
usage(){
	fprintf(stderr,"stethoscope [options] +[Ttcmipesrwd] {<mod>.<fcn>}\n");
	fprintf(stderr,"-d | --dbname=<database_name>\n");
	fprintf(stderr,"-u | --user=<user>\n");
	fprintf(stderr,"-P | --password=<password>\n");
	fprintf(stderr,"-p | --port=<portnr>\n");
	fprintf(stderr,"-h | --host=<hostname>\n");

    fprintf(stderr,"T -time\n");
    fprintf(stderr,"t -ticks\n");
    fprintf(stderr,"c -cpu\n");
    fprintf(stderr,"m -memory\n");
    fprintf(stderr,"i -io\n");
    fprintf(stderr,"p -pc\n");
    fprintf(stderr,"e -event\n");
    fprintf(stderr,"s -statement\n");
    fprintf(stderr,"r -rdbytes\n");
    fprintf(stderr,"w -wrbytes\n");
    fprintf(stderr,"d -diskspace\n");
}
@-
Any signal should be captured and turned into a graceful
termination of the profiling session.
@c
void
stopListening(int i){
	(void) i;
	fprintf(stderr,"SHUTTING DOWN\n");
	fflush(stderr);
	signal(i, SIG_IGN);
	doQ("profiler.setNone();");
	doQ("profiler.stop();");
	doQ("profiler.closeStream();");
	sleep(1);
	exit(0);
}

void setCounter(char *nme){
	int i,k=1;
	
	printf("update fields;%s\n",nme);
	for(i=0; profileCounter[i].tag; i++)
		profileCounter[i].status=0;

	for( ; *nme; nme++)
	for(i=0; profileCounter[i].tag; i++)
		if( profileCounter[i].tag == *nme)
			profileCounter[i].status= k++;
}
char *
getFieldName(int k){
	int i;
	for(i=0; profileCounter[i].tag; i++)
		if( profileCounter[i].status== k)
			return profileCounter[i].name;
	return "unknown";
}

int main(int argc, char **argv)
{
	int a=1,i=1;
	char * response, *error;
	char buffer[1024];
	char *mod, *fcn;
	char *host="localhost";
	int	portnr= 50000;
	char *dbname= NULL;
	char *user= "monetdb";
	char *passwrd= "monetdb";

    static struct option long_options[13] = {
        {"dbname", 1, 0, 'd'},
        {"user", 1, 0, 'u'},
        {"passwrd", 1, 0, 'P'},
        {"port", 1, 0, 'p'},
        {"host", 1, 0, 'h'},
        {0, 0, 0, 0}
    };
	for(;;){
		int option_index=0;
		int c=  getopt_long(argc, argv, "d:u:P:p:h:",
                    long_options, &option_index);
		if( c == -1)
			break;
		switch(c){
		case 'd':
			if (strcmp(long_options[option_index].name, "dbname") == 0) {
				dbname= optarg;
				break;
			}
		case 'u':
			if (strcmp(long_options[option_index].name, "user") == 0) {
				user= optarg;
				break;
			}
		case 'P':
			if (strcmp(long_options[option_index].name, "passwrd") == 0) {
				passwrd= optarg;
				break;
			}
		case 'p':
			if (strcmp(long_options[option_index].name, "port") == 0) {
				portnr= atol(optarg);
				break;
			}
		case 'h':
			if (strcmp(long_options[option_index].name, "host") == 0) {
				passwrd= optarg;
				break;
			}
		default:
			usage();
		}
	}

	a= optind;
	if(argc>1 && argv[a][0]=='+'){
		if( argv[a][1]=='?'){
			usage();
			exit(0);
		} else
			setCounter(argv[a++]+1);
	}

	signal(SIGABRT, stopListening);
	signal(SIGPIPE, stopListening);
	signal(SIGHUP, stopListening);
	signal(SIGTERM, stopListening);
	signal(SIGKILL, stopListening);
	signal(SIGINT, stopListening);

	/* set up the profiler */

	dbh = mapi_connect(host, portnr, user, passwrd, "mal", NULL);
	if (mapi_error(dbh))
		die(dbh, hdl);
	/* mapi_trace(dbh,1);*/

	/* set counters */
	for(i=0; profileCounter[i].tag; i++){
		snprintf(buffer,1024,"profiler.activate(\"%s\");",
			profileCounter[i].name);
		if( profileCounter[i].status){
			doQ(buffer);
		}
	}

	/* Set Filters */
	doQ("profiler.openStream(\"stdout\");");
	if(a== argc) {
		doQ("profiler.setAll();");
	} else
	for(; a <argc; a++){
		char *c;
		c= strchr(argv[a],'.');
		if(  c ){
			mod= argv[a];
			fcn= c+1;
			*c=0;
		} else {
			fcn= argv[a];
			mod= "*";
		}
		snprintf(buffer,1024, "profiler.setFilter(\"%s\",\"%s\");",mod,fcn);
		printf("%s\n",buffer);
		doQ(buffer);
	}
	doQ("profiler.start();");

	for(; mapi_error(dbh) == MOK ; ){
		while ( (response= mapi_fetch_line(hdl)) ) {
			printf("%s\n",response);
		}
/*
		while ( mapi_fetch_row(hdl) ) {
			k= mapi_get_field_count(hdl);
			for(i=0; i<k; i++){
				response= mapi_fetch_field(hdl,i);
				printf("%s:%s\n", getFieldName(i), response);
			}
			printf("\n");
		}
*/
		if( (error = mapi_result_error(hdl)) != NULL){
			mapi_explain_result(hdl,stderr);
			break;
		}
		sleep(1);
		doQ("");
	} 
	if (mapi_error(dbh) != MOK)
		die(dbh, hdl);
	mapi_close_handle(hdl);
	if (mapi_error(dbh) != MOK)
		die(dbh, hdl);
	mapi_destroy(dbh);

	return 0;
}

@}
