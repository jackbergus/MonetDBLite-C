@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2007 CWI.
@' All Rights Reserved.

@f stethoscope
@a Martin Kersten
@v 1.0
@+ The Stethoscope
The MonetDB kernel carries a profiler infrastructure, which
can be precisely controlled through a MAL program. 
Often, however, inclusion of profiling statements in a proram
is an afterthought.

The program @code{stethoscope} addresses this situation by providing
a simple application that can attach itself to a running
server and extracts the profiler events from concurrent running queries.

The arguments to @code{stethoscope} are the profiler properties to be traced
and the applicable filter expressions. For example,
@example
stethoscope -t bat.insert algebra.join
@end example
tracks the usec ticks of two specific MAL instructions.
A synopsis of the calling conventions:
@verbatim
	stethoscope [options] +[aefoTtcmibds] {<mod>.<fcn>}
	-d | --dbname=<database_name>
	-u | --user=<user>
	-P | --password=<password>
	-p | --port=<portnr>
	-g | --gnuplot=<boolean>
	-h | --host=<hostname>

Debug selector:
	--threads
	--memory
	--properties
	--io
	--transaction
	--modules
	--algorithms
	--estimates
	--xproperties
	--debug=<bitmask>

Event selector:
	a =aggregates
    e =event
    f =function 
    o =operation called
    T =time
    t =ticks
    c =cpu statistics
    m =memory resources
    i =io resources
    b =bytes read/written
    d =diskspace needed
    s =statement
@end verbatim

Ideally, the stream of events should be piped into a
2D graphical tool, like xosview (Linux).
A short term solution is to generate a gnuplot script
to display the numerics organized as time lines.
With a backup of the event lists give you all the
information needed for a descent post-mortem analysis.

@{
@c
#include "mal_config.h"
#include "monet_options.h"
#include <gdk.h>
#include <Mapi.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>
#include <stream.h>


static struct {
	char tag;
    char *ptag;       /* which profiler counter is needed */
    char *name;       /* which logical counter is needed */
    int status;     /* trace it or not */
} profileCounter[] = {
    /*  0  */  {'a', "aggregate", "total count", 0},
    /*  1  */  {'a', "aggregate", "total ticks", 0},
    /*  2  */  {'e', "event", "event id", 0},
    /*  3  */  {'f', "pc", "function", 0},
    /*  4  */  {'f', "pc", "pc", 0},
    /*  5  */  {'o', "operation","operation", 0},
    /*  6  */  {'T', "time", "time stamp", 0},
    /*  7  */  {'t', "ticks", "usec ticks", 1},
    /*  8  */  {'c', "cpu", "utime", 0},
    /*  9  */  {'c', "cpu", "cutime", 0},
    /*  0  */  {'c', "cpu", "stime", 0},
    /*  1  */  {'c', "cpu", "cstime", 0},
    /*  2  */  {'m', "memory", "arena", 0},
    /*  3  */  {'m', "memory", "ordblks", 0},
    /*  4  */  {'m', "memory", "smblks", 0},
    /*  5  */  {'m', "memory", "hblkhd", 0},
    /*  6  */  {'m', "memory", "hblks", 0},
    /*  7  */  {'m', "memory", "fsmblks", 0},
    /*  8  */  {'m', "memory", "uordblks", 0},
    /*  9  */  {'i', "io","pg reclaim", 0},
    /*  0  */  {'i', "io","pg faults", 0},
    /*  1  */  {'i', "io","swaps", 0},
    /*  2  */  {'i', "io","blk reads", 0},
    /*  3  */  {'i', "io","blk writes", 0},
    /*  4  */  {'i', "io","ctxt switch", 0},
    /*  5  */  {'i', "io","inv switch", 0},
    /*  6  */  {'b', "bytes", "rdbytes", 0},
    /*  7  */  {'b', "bytes", "wrbytes", 0},
    /*  8  */  {'d', "disk", "diskspace", 0},
    /*  9  */  {'s', "statement", "statement", 2},
    /*  0  */  {0, 0,  0, 0}
};

@-
The debug flags available in M5 are a subset of those mentioned
in the monetdb configuration file.
A few are made available for ease of use
@c
#define GRPthreads ((1) | (1<<8))
#define GRPmemory ((1<<2) | (1<<25))
#define GRPproperties ((1<<1) | (1<<3) | (1<<5) | (1<<23) | (1<<24))
#define GRPio ((1<<4) | (1<<12))
#define GRPtransaction ((1<<9) | (1<<10) | (1<<13))
#define GRPmodules ((1<<11) | (1<<14))
#define GRPalgorithms ((1<<22) )
#define GRPestimates ((1<<23))
#define GRPxproperties ((1<<24))

@-
These definitions were based on:
static struct{
	int bitmask, flag;
	char *title;
} debugmap[]={
	{ 0,  0, ""},
	{ 1,  1, "thread-specific debug output"},
	{ 2,  2, "property enforcing on new BATs"},
	{ 4,  3, "memory allocation"},
	{ 8,  4, "property checking on all values: tells about wrongly set propertie"},
	{ 16,  5, "major IO activity"},
	{ 32,  6, "BAT handling"},
	{ 64,  7, "MIL parser debugging"},
	{ 128,  8, "Thread management"},
	{ 256,  9, "Event management"},
	{ 512, 10, "Transaction management"},
	{ 1024, 11, "Locks and Triggers"},
	{ 2048, 12, "Dynamic loading"},
	{ 4096, 13, "BBP Performance"},
	{ 8192, 14, "Delta debugging"},
	{ 16384, 15, "Module loading"},
	{ 32768, 16, "Yacc specific error messages"},
	{ 65536, 17, "tcpip"},
	{ 131072, 18, "monet_multiplex: setaggr debugging"},
	{ 262144, 19, ""},
	{ 524288, 20, ""},
	{ 1048576, 21, ""},
	{ 2097152, 22, "show join/select algorithm chosen"},
	{ 4194304, 23, "result size estimates (for join,select)"},
	{ 8388608, 24, "extended property checking: tells also about not set properties"},
	{ 0, 0, 0}
};
@c

static Mapi dbh;
static MapiHdl hdl = NULL;

#define die(dbh,hdl) (hdl?mapi_explain_query(hdl,stderr):		\
						   dbh?mapi_explain(dbh,stderr):			\
							   fprintf(stderr,"command failed\n"),	\
					   exit(-1))

#define doQ(X) \
	if ((hdl = mapi_query(dbh, X)) == NULL || mapi_error(dbh) != MOK) \
		die(dbh, hdl);

void
usage(){
	fprintf(stderr,"stethoscope [options] +[Ttcmipesrwd] {<mod>.<fcn>}\n");
	fprintf(stderr,"-d | --dbname=<database_name>\n");
	fprintf(stderr,"-u | --user=<user>\n");
	fprintf(stderr,"-P | --password=<password>\n");
	fprintf(stderr,"-p | --port=<portnr>\n");
	fprintf(stderr,"-h | --host=<hostname>\n");
	fprintf(stderr,"-g | --gnuplot\n");

	fprintf(stderr,"The debug options:\n");
	fprintf(stderr," --threads\n");
	fprintf(stderr," --memory\n");
	fprintf(stderr," --properties\n");
	fprintf(stderr," --io\n");
	fprintf(stderr," --transaction\n");
	fprintf(stderr," --modules\n");
	fprintf(stderr," --algorithms\n");
	fprintf(stderr," --estimates\n");
	fprintf(stderr," --xproperties\n");
	fprintf(stderr," --debug=<bitmask>\n");

	fprintf(stderr,"The trace options:\n");
	fprintf(stderr,"    a =aggregates\n");
	fprintf(stderr,"    e =event\n");
	fprintf(stderr,"    f =function \n");
	fprintf(stderr,"    o =operation called\n");
	fprintf(stderr,"    T =time\n");
	fprintf(stderr,"    t =ticks\n");
	fprintf(stderr,"    c =cpu statistics\n");
	fprintf(stderr,"    m =memory resources\n");
	fprintf(stderr,"    i =io resources\n");
	fprintf(stderr,"    b =bytes read/written\n");
	fprintf(stderr,"    d =diskspace needed\n");
	fprintf(stderr,"    s =statement\n");
@-
The debug options are taken from the monetdb configuration file
and only includes those relevant for M5. The have been reorganized
to have clearer topic groups, mapping them to the required bits
in the startup.
We should also make the SQL debugger flags accessible
@c

}
@-
Any signal should be captured and turned into a graceful
termination of the profiling session.
@c
void
stopListening(int i){
	(void) i;
	signal(i, SIG_IGN);
	doQ("profiler.setNone();");
	doQ("profiler.stop();");
	doQ("profiler.closeStream();");
	exit(0);
}

void setCounter(char *nme){
	int i,k=1;
	
	for(i=0; profileCounter[i].tag; i++)
		profileCounter[i].status=0;

	for( ; *nme; nme++)
	for(i=0; profileCounter[i].tag; i++)
		if( profileCounter[i].tag == *nme)
			profileCounter[i].status= k++;
}
char *
getFieldName(int k){
	int i;
	for(i=0; profileCounter[i].tag; i++)
		if( profileCounter[i].status== k)
			return profileCounter[i].name;
	return "unknown";
}

void
plottemplate(int * colind, int n){
	FILE *pl,*pld;
	float sz= 1.0/n;
	int i;

	pl= fopen("stet.gp","w");
	fprintf(pl,"load \"stet_dyn.gp\"\n");
	fprintf(pl,"pause 1\nreread \n");
	fclose(pl); 
/*	pld= fopen("stet_dyn_tmpl.gp","w");*/
	pld= fopen("stet_dyn.gp","w");
	fprintf(pld,"set multiplot\n\n");
	for(i=0;i<n;i++){
		fprintf(pld,"set size 1.0, 1.0 \nset origin 0.0, 0.0 \n");
		fprintf(pld,"set size 1.0,%4.2f\n",sz);
		fprintf(pld,"set origin 0.0,%4.2f\n",1-(i+1)*sz);
		fprintf(pld,"set ylabel \"%s\"\n", profileCounter[colind[i]].name);
		fprintf(pld,"unset key\n");
		fprintf(pld,"plot \"stet_cur.dat\" using 1:%d with boxes fs solid 0.7\n\n",i+2);
	}
	fprintf(pld,"\nunset multiplot"); 
	
	fclose(pld); 

	}



int main(int argc, char **argv)
{
	int a=1,i=1,ln=1;
	char * response, *x;
	char buf[BUFSIZ];
	char *mod, *fcn;
	char *host="localhost";
	int	portnr= 50000;
	char *dbname= NULL;
	char *user= "monetdb";
	char *password= "monetdb";
	FILE *d;
	char cmd[100];
	int colind[30],colcnt=0;
	stream *s;
	int gnuplot=FALSE;
	int debug=0;

    static struct option long_options[18] = {
        {"dbname", 1, 0, 'd'},
        {"user", 1, 0, 'u'},
        {"password", 1, 0, 'P'},
        {"port", 1, 0, 'p'},
        {"host", 0, 0, 'h'},
        {"help", 1, 0, '?'},
        {"gnuplot", 1, 0, 'g'},
		{"threads",0,0,'t'},
		{"memory",0,0,'m'},
		{"properties",0,0,'p'},
		{"io",0,0,'i'},
		{"transaction",0,0,'t'},
		{"modules",0,0,'m'},
		{"algorithms",0,0,'a'},
		{"estimates",0,0,'e'},
		{"xproperties",0,0,'x'},
		{"debug",1,0,'d'},
        {0, 0, 0, 0}
    };
	for(;;){
		int option_index=0;
		int c=  getopt_long(argc, argv, "d:u:P:p:?:h:t:m:i:a:e:x",
                    long_options, &option_index);
		if( c == -1)
			break;
		switch(c){
		case 'd':
			if (strcmp(long_options[option_index].name, "debug") == 0) {
				debug |= atol(optarg);
				break;
			}
			if (strcmp(long_options[option_index].name, "dbname") == 0) {
				dbname= optarg;
				break;
			}
		case 'u':
			if (strcmp(long_options[option_index].name, "user") == 0) {
				user= optarg;
				break;
			}
		case 'P':
			if (strcmp(long_options[option_index].name, "password") == 0) {
				password= optarg;
				break;
			}
		case 'p':
			if (strcmp(long_options[option_index].name, "port") == 0) {
				portnr= atol(optarg);
				break;
			}
			if (strcmp(long_options[option_index].name, "properties") == 0) {
				debug |=GRPproperties;
				break;
			}
		case 'a':
			if (strcmp(long_options[option_index].name, "algorithms") == 0) {
				debug|= GRPalgorithms;
				break;
			}
		case 'x':
			if (strcmp(long_options[option_index].name, "xproperties") == 0) {
				debug|= GRPxproperties;
				break;
			}
		case 'e':
			if (strcmp(long_options[option_index].name, "estimates") == 0) {
				debug|= GRPestimates;
				break;
			}
		case 'i':
			if (strcmp(long_options[option_index].name, "io") == 0) {
				debug|= GRPio;
				break;
			}
		case 'g':
			if (strcmp(long_options[option_index].name, "gnuplot") == 0) {
				gnuplot= TRUE;
				break;
			}
		case 'm':
			if (strcmp(long_options[option_index].name, "memory") == 0) {
				debug|= GRPmemory;
				break;
			}
			if (strcmp(long_options[option_index].name, "modules") == 0) {
				debug|= GRPmodules;
				break;
			}
		case 't':
			if (strcmp(long_options[option_index].name, "threads") == 0) {
				debug|= GRPthreads;
				break;
			}
		case 'h':
			if (strcmp(long_options[option_index].name, "help") == 0) {
				printf("help\n");
			}
			if (strcmp(long_options[option_index].name, "host") == 0) {
				host= optarg;
				break;
			}
		default:
			usage();
			exit(0);
		}
	}

	a= optind;
	if(argc>1 && a<argc && argv[a][0]=='+'){
		setCounter(argv[a]+1);
		a++;
	}

	signal(SIGABRT, stopListening);
#ifdef SIGPIPE
	signal(SIGPIPE, stopListening);
#endif
#ifdef SIGHUP
	signal(SIGHUP, stopListening);
#endif
	signal(SIGTERM, stopListening);
	signal(SIGINT, stopListening);

	/* set up the profiler */

	dbh = mapi_connect(host, portnr, user, password, "mal", dbname);
	if (mapi_error(dbh))
		die(dbh, hdl);
	/* mapi_trace(dbh,1);*/

	/* set debugging flag in server */
	if( debug){
		printf("mdb.setDebug(%d);\n",debug);
		snprintf(buf,BUFSIZ,"mdb.setDebug(%d);",debug);
		doQ(buf);
	}

	/* set counters */
	for(i=0; profileCounter[i].tag; i++){
		/* deactivate any left over counter first */
		snprintf(buf,BUFSIZ,"profiler.deactivate(\"%s\");",
			profileCounter[i].ptag);
		doQ(buf);
		snprintf(buf,BUFSIZ,"profiler.activate(\"%s\");",
			profileCounter[i].ptag);
		if( profileCounter[i].status){
			doQ(buf);
			colind[colcnt++]=i;
		}
	}

/*	printf("Column index \n");
	for(j=0;j<colcnt;j++)
		printf("%d\t",colind[j]);
	printf("\n");  */
	
	/* Set Filters */
	snprintf(buf,BUFSIZ,"profiler.openStream(\"%s\", %d);", host, portnr);
	doQ(buf);

	if ((s = udp_rastream(host, portnr, "profileStream")) == NULL)
		perror("stream failed\n");

	if(a== argc) {
		doQ("profiler.setAll();");
	} else
	for(; a <argc; a++){
		char *c;
		c= strchr(argv[a],'.');
		if(  c ){
			mod= argv[a];
			if( mod==c) mod="*";
			fcn= c+1;
			if( *fcn == 0) fcn="*";
			*c=0;
		} else {
			fcn= argv[a];
			mod= "*";
		}
		snprintf(buf,BUFSIZ, "profiler.setFilter(\"%s\",\"%s\");",mod,fcn);
		printf("%s\n",buf);
		doQ(buf);
	}
	doQ("profiler.start();");

	if(gnuplot)
		plottemplate(colind,colcnt);

	while( stream_read(s, buf, 1, BUFSIZ) ) {
		char *e;
		response = buf;
		while((e=strchr(response,'\n')) != NULL) {
			*e = 0;
			printf("%s\n", response);
			x=strchr(response,'[');
			if (gnuplot && x){
				d= fopen("stet.dat","a+");
				fprintf(d,"%d\t",ln++);
				for(;*x!='\0';x++)
					if( *x == '"') break; /* stop at first string */
					else
					if (strchr("[],\"",*x)==NULL)
						fprintf(d,"%c",*x);
				fprintf(d,"\n");
				fclose(d);
				
			/* update plot file */
						
				if (ln > 20)
					sprintf(cmd,"sed '1, %d d' stet.dat > stet_cur.dat",ln-20);
				else 
					sprintf(cmd,"cp stet.dat stet_cur.dat");
			/*	printf("%s \n",cmd);*/
				system(cmd); 
			}
			response = e+1;
		}
	} 

	doQ("profiler.closeStream();");
	if (mapi_error(dbh) != MOK)
		die(dbh, hdl);
	mapi_close_handle(hdl);
	if (mapi_error(dbh) != MOK)
		die(dbh, hdl);
	mapi_destroy(dbh);

	return 0;
}

@}
