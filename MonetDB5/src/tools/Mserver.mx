
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2005 CWI.
@' All Rights Reserved.

@f Mserver
@a M.L. Kersten, P. Boncz, Niels Nes, Stefan Manegold, Sjoerd Mullender
@v 5.0
@* The Monet Server
@T
The {\tt Mserver} is the Monet server. It is started by the database
administrator.  The console is primarilly meant to further initialize
the server, such as starting internet listeners.

@+ Manual Page
@T
The Mserver is a multithreaded program. There is one system thread, and for
each service, e.g. a client session or transaction service,
there is one worker thread.
As a default, the Mserver also starts the internet listener thread,
on the port number specified in the parameter file.

@- Usage
@verbatim
Mserver { [ --dbname <db-name> ] 
          [ --dbfarm <dbfarm> ]
          [ --dbinit <stmt> ]
		  [ -c | --config <config-file> ]
          [ -d | --gdk_debug [value]
		  [ --set [option=value] set option can be given multiple times
                                    to override verious options
        } [ <mal-script> ]
@end verbatim

Since the console has no command-line history nor file name completion,
you are recommended to use the Mclient program for interactive sessions instead.

The Mserver options have the following meaning:
@table @code
@item --dbname <db-name>
	open the database <db-name>.
@item --config <config-file>
	where to find the environment settings
@item --dbinit <stmt>
        execute the statement first.
@end itemize

@{
@+ Implementation
@h
#ifndef _MONET_GLOBAL_H_
#define _MONET_GLOBAL_H_
#include "mal_config.h"
#include "monet_options.h"
#include "mal.h"
#include "mal_session.h"
#include "mal_import.h"
#include "mal_client.h"
#include "mal_function.h"

/* #define MONET_GLOBAL_DEBUG */
#endif /* _MONET_GLOBAL_H_ */
@c
#include "Mserver.h"
#include "mal.h"

#ifdef _CRTDBG_MAP_ALLOC
/* Windows only:
   our definition of new and delete clashes with the one if
   _CRTDBG_MAP_ALLOC is defined.
*/
#undef _CRTDBG_MAP_ALLOC
#endif

@-
The architecture is setup to handle multiple streams of requests.
The first thread started represents the server. It reads from standard input
and writes to standard input. This is also a way to recognize the server
actions. 
To start the server in the background one should use the argument -background.
This closes standard input. Direct execution in the background may cause
the server to hang in stdio for input from the terminal.
@ 
The server thread started remains in existence until all other threads die.
The server is stopped by cntrl-D or receiving the quit command.
@

@c
static int malloc_init = 1;
/* NEEDED? */
#if defined(_MSC_VER) && defined(__cplusplus)
#include <eh.h>
void
Mserver_abort()
{
	fprintf(stderr, "\n! Mserver_abort() was called by terminate(). !\n");
	fflush(stderr);
	MT_global_exit(0);
}
#endif

void
usage(char *prog)
{
	fprintf(stderr, "usage: %s [options] [script]\n", prog);
	fprintf(stderr, "    --dbname=<database_name> \n");
	fprintf(stderr, "    --dbfarm=<database_directory> \n");
	fprintf(stderr, "    --help for more options \n");
	exit(0);
}
void
usage2(char *prog)
{
	fprintf(stderr, "usage: %s [options] [script]\n", prog);
	fprintf(stderr, "    --dbname=<database_name> \n");
	fprintf(stderr, "    --dbfarm=<directory> \n");
	fprintf(stderr, "    --dbinit=<stmt>           Server prepare statement\n");
	fprintf(stderr, "    --config=<config_file> \n");
	fprintf(stderr, "    --debug=<number>          trace server actions[0]\n");
	fprintf(stderr, "    --daemon=yes|no           run in background [no]\n");
	fprintf(stderr, "    --set <option>=<value>    set environment value\n");
	fprintf(stderr, "    --help                    this list of options \n");
	exit(0);
}

@-
A welcoming message is displayed to inform the user about recent
changes. 
@c
void
monet_hello(opt *set, int setlen)
{
#ifdef STATIC
	char *linkinfo = "statically";
#else
	char *linkinfo = "dynamically";
#endif
	char *msg = mo_find_option(set, setlen, "monet_welcome");

	if (msg && strcmp(msg, "yes") == 0) {
		printf("# Monet Database Server V%s\n", GDKgetenv("gdk_version"));
		printf("# Copyright (c) 1993-2005, CWI. ");
		printf("All rights reserved.\n");
		printf("# Compiled for %s/" SZFMT "bit with " SZFMT "bit OIDs; %s linked.\n", HOST, (size_t) (sizeof(ptr) * 8), (size_t) (sizeof(oid) * 8), linkinfo);
		printf("# config:%s\n", GDKgetenv("config"));
		printf("# dbfarm:%s\n", GDKgetenv("gdk_dbfarm"));
		printf("# dbname:%s\n", GDKgetenv("gdk_dbname"));
		printf("# Visit http://monetdb.cwi.nl/ for further information.\n");
	}
}

str
absolute_path(str s)
{
	if (!MT_path_absolute(s)) {
		str ret = (str) GDKmalloc(strlen(s) + strlen(monet_cwd) + 2);

		sprintf(ret, "%s%c%s", monet_cwd, DIR_SEP, s);
		return ret;
	}
	return GDKstrdup(s);
}

@-
The options obtained during initialization should be maintained as
a global structure for other components to extract information.
@c
#define BSIZE 8192

void
monet_init(opt *set, int setlen)
{
	char *p;
	opt *n = (opt *) malloc(setlen * sizeof(opt));
	int i, j, nlen = 0;

	char buf[BSIZE];
	char *dbname = mo_find_option(set, setlen, "gdk_dbname");
	char *dbfarmval = mo_find_option(set, setlen, "gdk_dbfarm");
	char *alloc_map = mo_find_option(set, setlen, "gdk_alloc_map");

	if (n == NULL || dbname == NULL || dbfarmval == NULL || alloc_map == NULL) {
		fprintf(stderr, "Error, no database name or directory\n");
		if (n)
			free(n);
		return;
	}

	if(strlen(dbfarmval) >= BSIZE)
			GDKfatal("monet_init: buffer overflow\n");
	strcpy(buf, dbfarmval);
	mo_substitute(set, setlen, buf);

	if ((p = GDKgetenv("gdk_debug")))
		GDKdebug = strtol(p, NULL, 10);

	/* determine Monet's kernel settings */
	if (!GDKinit(dbname, buf,  strcasecmp(alloc_map, "yes") == 0) ) {
		free(n);
		return;
	}

@-
Find duplicate entries in the property list and move
them to the front. Actually, this should be done in
monet_options.mx.in
@c
	for (i = 0; i < setlen; i++) {
		int done = 0;

		for (j = 0; j < nlen; j++) {
			if (strcmp(n[j].name, set[i].name) == 0) {
				if (n[j].kind < set[i].kind) {
					n[j] = set[i];
				}
				done = 1;
				break;
			}
		}
		if (!done) {
			n[nlen] = set[i];
			nlen++;
		}
	}
	for (i = 0; i < nlen; i++) {
		if(strlen(n[i].value) >= BSIZE)
				GDKfatal("monet_init: buffer overflow\n");
		strncpy(buf, n[i].value, sizeof(buf));
		mo_substitute(n, nlen, buf);
		GDKsetenv(n[i].name, buf);
	}
	free(n);

	if ((p = GDKgetenv("gdk_mem_bigsize"))) {
		GDK_mem_bigsize = strtol(p, NULL, 10);
		if (GDK_mem_bigsize > GDK_mem_maxsize)
			GDK_mem_bigsize = GDK_mem_maxsize/2;

	}
	if ((p = GDKgetenv("gdk_vm_minsize"))){
		GDK_vm_minsize = strtol(p, NULL, 10);
		if (GDK_vm_minsize > GDK_mem_maxsize)
			GDK_vm_minsize = GDK_mem_maxsize/2;
	}

	if (GDKgetenv_isyes("gdk_embedded") || GDKgetenv_isyes("embedded")) {
		GDKembedded = 1;
	}

    if (GDKgetenv_isyes("monet_daemon") || GDKgetenv_isyes("daemon")) {
        monet_daemon = 1;
#ifdef HAVE_SETSID
        setsid();
#endif
    }


	monet_hello(set, setlen);
	/* you don;t need the commandline arguments anymore */
	mo_free_options(set, setlen);
}

int
main(int argc, char **av)
{
	char *prog = *av;
	opt *set = NULL;
	int i, debug = 0, setlen = 0, listing = 0;
	str dbinit = NULL;

	static struct option long_options[10] = {
		{"config", 1, 0, 'c'},
		{"dbname", 1, 0, 0},
		{"dbfarm", 1, 0, 0},
		{"dbinit", 1, 0, 0},
		{"debug", 2, 0, 'd'},
		{"help", 2, 0, 'h'},
		{"help", 0, 0, '?'},
		{"set", 1, 0, 's'},
		{"trace", 0, 0, 't'},
		{0, 0, 0, 0}
	};

@-
We give malloc advice here. Main goal: prevent fragmentation.
We do this by declaring everything below 2K as 'small'. These
values will be drawn from a fixed pools of 400K.
A grain size of 128 bytes is used to keep overhead low.

We do this by declaring everything below 2K as 'small'. These
values will be drawn from a fixed pools of 400K.
A grain size of 128 bytes is used to keep overhead low.
Trivial remark: for dynamically linked executables the mallopt
capabilities depend on the malloc implementation used at run time.

Unlike V4 we ignore the alloc_map advice, which leads to a much
faster system start.
@= mallopt
	if (malloc_init) {
/* for (Red Hat) Linux (6.2) unused and ignored at least as of glibc-2.1.3-15 */
/* for (Red Hat) Linux (8) used at least as of glibc-2.2.93-5 */
            if (mallopt(M_MXFAST, 192)) {
                fprintf(stderr, "!monet: mallopt(M_MXFAST,192) fails.\n");
            }
#ifdef M_BLKSZ
            if (mallopt(M_BLKSZ, 8*1024)) {
                fprintf(stderr, "!monet: mallopt(M_BLKSZ,8*1024) fails.\n");
            }
#endif
        }
	malloc_init=0;
@c

#if defined(_MSC_VER) && defined(__cplusplus)
	set_terminate(Mserver_abort);
#endif
/* should be looked into
        if (setlocale(LC_CTYPE, "") == NULL){
                GDKfatal( "cannot set locale\n");
        }
*/

#ifdef HAVE_MALLOPT
	@:mallopt@
#else
	(void) malloc_init;	/* still unused */
#endif

	if (getcwd(monet_cwd, PATHLENGTH - 1) == NULL) {
		perror("pwd");
		GDKfatal("monet_init: could not determine current directory\n");
	}

	if (!(setlen = mo_builtin_settings(&set)))
		usage(prog);

	setlen = mo_add_option(&set, setlen, opt_config, "prefix", MONETDBPREFIX);
	setlen = mo_add_option(&set, setlen, opt_config, "config", MONETDBCONFIG);

	for(;;) {
		int option_index = 0;

		int c = getopt_long(argc, av, "c:d:t::?s:",
				    long_options, &option_index);

		if (c == -1)
			break;

		switch (c) {
		case 0:
			if (strcmp(long_options[option_index].name, "dbname") == 0) {
				setlen = mo_add_option(&set, setlen, opt_cmdline, "gdk_dbname", optarg);
				break;
			}
			if (strcmp(long_options[option_index].name, "dbfarm") == 0) {
				setlen = mo_add_option(&set, setlen, opt_cmdline, "gdk_dbfarm", optarg);
				break;
			}
			if (strcmp(long_options[option_index].name, "dbinit") == 0) {
				if (dbinit)
					fprintf(stderr, "#warning: ignoring multiple --dbinit argument\n");
				else
					dbinit = optarg;
				break;
			}
			usage(prog);
			break;
		case 'c':
			setlen = mo_add_option(&set, setlen, opt_cmdline, "config", optarg);
			break;
		case 'd':
			debug = 1;

			if (optarg) {
				setlen = mo_add_option(&set, setlen, opt_cmdline, "gdk_debug", optarg);
			}
			break;
		case 's':{
			/* should add option to a list */
			char *tmp = strchr(optarg, '=');

			if (tmp) {
				*tmp = '\0';
				setlen = mo_add_option(&set, setlen, opt_cmdline, optarg, tmp + 1);
			} else {
				fprintf(stderr, "ERROR: wrong format %s\n", optarg);
			}
		}
			break;
		case 't':	/* trace option, currently ignored */
			fprintf(stderr, "#warning: trace option not yet supported\n");
			break;
		case 'h':
			if(strcmp(long_options[option_index].name, "help") == 0) {
				usage2(prog);
				break;
			}
		case '?':
			usage(prog);
		default:
			fprintf(stderr, "ERROR: getopt returned character code 0%o ??\n", c);
			usage(prog);
		}
	}

	if (!(setlen = mo_system_config(&set, setlen)))
		usage(prog);

	i = 0;
	monet_script = (str *) GDKmalloc(sizeof(str) * (argc + 1));
	monet_script[i] = NULL;
	while (optind < argc) {
		monet_script[i] = absolute_path(av[optind]);
		monet_script[i + 1] = NULL;
		optind++;
		i++;
	}

	if (debug)
		mo_print_options(set, setlen);
#ifdef MONET_GLOBAL_DEBUG
	else
		mo_print_options(set, setlen);
#endif
	monet_init(set, setlen);
	if (mal_init())
		return 0;

@-
Time to execute the script files. Start with the init command[todo]
@c
	initClientPrg(mal_clients, "main");
	if (dbinit) {
		str input = GDKstrdup(dbinit);

		callString(mal_clients, input, listing);
		GDKfree(input);
	}
	if (GDKgetenv("mal_listing"))
		sscanf(GDKgetenv("mal_listing"), "%d", &listing);

	for (i = 0; monet_script[i]; i++) {
		malInclude(mal_clients, monet_script[i], 0, listing);
		GDKfree(monet_script[i]);
		monet_script[i] = 0;
	}

	GDKfree(monet_script);
	if( monet_daemon){
		while(1) 
			sleep(5);
	} else
		serveClient(mal_clients);
	mal_exit(mal_clients);
	return 0;
}
@}
