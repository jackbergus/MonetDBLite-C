@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2007 CWI.
@' All Rights Reserved.

@f monetdb
@a Fabian Groffen
@v 1.0
@* MonetDB Database Administrator's Toolkit
A group of MonetDB servers in a dbfarm are under control of the
Merovingian, which by itself does not allow any user interaction.
The monetdb utility is designed to be the interface for the DBA to the
dbfarm.  Creating or deleting databases next to retrieving status
information about them are the primary goals of this tool.

@h
#define TOOLKIT_VERSION   "0.1"

@c
#include "mal_config.h" /* MONETDBCONFIG, MONETDBPREFIX */
#include "monetdb.h"
#include "mal_sabaoth.h"
#include <stdlib.h> /* exit */
#include <stdarg.h>	/* variadic stuff */
#include <stdio.h> /* fprintf */
#include <string.h> /* strdup, strerror */
#include <sys/stat.h> /* mkdir */
#include <sys/types.h> /* mkdir */
#include <alloca.h>
#include <errno.h>

typedef char* err;

#define freeErr(X) free(X)
#define getErrMsg(X) X
#define NO_ERR (err)0

static str
replacePrefix(str s)
{
	str p;
	str buf;

	/* unfortunately we have to replace occurences of ${prefix} with
	 * MONETDBPREFIX, which is medieval in this language */
	p = strstr(s, "${prefix}");
	if (p != NULL) {
		buf = malloc(sizeof(char) * (strlen(s) + strlen(MONETDBPREFIX) + 1));
		memcpy(buf, s, p - s);
		memcpy(buf + (p - s), MONETDBPREFIX, strlen(MONETDBPREFIX));
		memcpy(buf + (p - s) + strlen(MONETDBPREFIX), s + (p - s) + 9, strlen(s) - 9 - (p - s) + 1);
		return(buf);
	} else {
		return(strdup(s));
	}
}

static void
command_help(int argc, char *argv[])
{
	if (argc != 2) {
		printf("Usage: monetdb command [command-options-and-arguments]\n");
		printf("  where command is one of:\n");
		printf("    status, create, destroy, help, version\n");
		printf("  use the help command to get help for a particular command\n");
	} else if (strcmp(argv[1], "status") == 0) {
		printf("Usage: monetdb status [-als] [database ...]\n");
		printf("  Shows the state of a given database as known to the\n");
		printf("  Sabaoth system.  Various options control what information\n");
		printf("  is displayed.\n");
		printf("Options:\n");
		printf("  -a  list status of all databases\n");
		printf("  -l  use long listing\n");
		printf("  -s  use short one-line listing\n");
	} else if (strcmp(argv[1], "create") == 0) {
		printf("Usage: monetdb create database\n");
		printf("  Initialises a new database in the Sabaoth system.  A\n");
		printf("  database created with this command makes it available\n");
		printf("  to Merovingian.\n");
	} else if (strcmp(argv[1], "destroy") == 0) {
		printf("Usage: monetdb destroy [-f] database\n");
		printf("  Removes the given database, including all its data and\n");
		printf("  logfiles.  Once destroy has completed, all data is lost.\n");
		printf("  Be careful when using this command.\n");
		printf("Options:\n");
		printf("  -f  do not ask for confirmation, destroy right away\n");
	} else if (strcmp(argv[1], "help") == 0) {
		printf("Yeah, help on help, how desparate can you be? ;)");
	} else if (strcmp(argv[1], "version") == 0) {
		printf("Usage: monetdb version\n");
		printf("  prints the version of the monetdb toolkit\n");
	} else {
		printf("help: unknown command: %s\n", argv[1]);
	}
}

static void
command_version()
{
	printf("MonetDB Toolkit, v%s\n", TOOLKIT_VERSION);
}

static void
command_status(int argc, char *argv[])
{
	(void)argc;
	(void)argv;
	printf("status: not yet implemented\n");
}

static void
command_create(int argc, char *argv[], char *dbfarm)
{
	if (argc == 1 || argc >= 3) {
		/* print help message for this command */
		command_help(argc, &argv[-1]);
	} else if (argc == 2) {
		sabdb *stats;
		err e;
		/* the argument is the database to create, see what Sabaoth can
		 * tell us about it */
		if ((e = SABAOTHgetStatus(&stats, argv[1])) != MAL_SUCCEED) {
			fprintf(stderr, "create: internal error: %s\n", e);
			GDKfree(e);
			exit(2);
		}

		if (stats == NULL) {
			char path[8096];
			/* Sabaoth doesn't know, green light for us! */
			snprintf(path, 8095, "%s/%s", dbfarm, argv[1]);
			path[8095] = '\0';
			if (mkdir(path, 0755) == -1) {
				fprintf(stderr, "create: unable to create %s: %s\n",
						argv[1], strerror(errno));
				exit(1);
			}
			printf("successfully created database %s\n", argv[1]);
		} else {
			SABAOTHfreeStatus(&stats);
			fprintf(stderr, "create: database %s already exists\n", argv[1]);
			exit(1);
		}
	}
}

static void
command_destroy(int argc, char *argv[], char *dbfarm)
{
	(void)argc;
	(void)argv;
	(void)dbfarm;
	printf("destroy: not yet implemented\n");
}


int
main(int argc, char *argv[])
{
	str conf = MONETDBCONFIG;
	str dbfarm;
	str p;
	FILE *cnf = NULL;
	char buf[1024];

	/* hunt for the config file, and read it */
	snprintf(buf, 1023, "%s%s", MONETDBPREFIX, conf + 9);
	cnf = fopen(buf, "r");
	if (cnf == NULL) {
		fprintf(stderr, "cannot open config file %s\n", buf);
		exit(1);
	}

	dbfarm = NULL;
	while (fgets(buf, 1024, cnf) != NULL) {
		/* eliminate fgets' newline */
		buf[strlen(buf) - 1] = '\0';
		if (*buf && strncmp(buf, "gdk_dbfarm=", 11) == 0) {
			p = strchr(buf, '=');
			dbfarm = replacePrefix(++p);
		}
	}

	fclose(cnf);

	if (dbfarm == NULL) {
		fprintf(stderr, "%s: cannot find dbfarm via config file\n", argv[0]);
		exit(2);
	}

	/* Start handling the arguments.
	 * monetdb command [options] [database [...]]
	 */
	if (argc <= 1) {
		command_help(0, NULL);
	} else if (strcmp(argv[1], "status") == 0) {
		command_status(argc - 1, &argv[1]);
	} else if (strcmp(argv[1], "create") == 0) {
		command_create(argc - 1, &argv[1], dbfarm);
	} else if (strcmp(argv[1], "destroy") == 0) {
		command_destroy(argc - 1, &argv[1], dbfarm);
	} else if (strcmp(argv[1], "help") == 0 || strcmp(argv[1], "-h") == 0) {
		command_help(argc - 1, &argv[1]);
	} else if (strcmp(argv[1], "version") == 0 || strcmp(argv[1], "-v") == 0) {
		command_version();
	} else {
		fprintf(stderr, "%s: unknown command: %s\n", argv[0], argv[1]);
		command_help(0, NULL);
	}

	return(0);
}

/* vim:set ts=4 sw=4 noexpandtab: */
