@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2007 CWI.
@' All Rights Reserved.

@f monetdb
@a Fabian Groffen
@v 1.0
@* MonetDB Database Administrator's Toolkit
A group of MonetDB servers in a dbfarm are under control of the
Merovingian, which by itself does not allow any user interaction.
The monetdb utility is designed to be the interface for the DBA to the
dbfarm.  Creating or deleting databases next to retrieving status
information about them are the primary goals of this tool.

@h
#define TOOLKIT_VERSION   "0.1"

@c
#include "mal_config.h" /* MONETDBCONFIG, MONETDBPREFIX */
#include "monetdb.h"
#include "mal_sabaoth.h"
#include <stdlib.h> /* exit */
#include <stdarg.h>	/* variadic stuff */
#include <stdio.h> /* fprintf */
#include <string.h> /* strdup, strerror */
#include <sys/stat.h> /* mkdir, stat */
#include <sys/types.h> /* mkdir, readdir */
#include <dirent.h> /* readdir */
#include <unistd.h> /* stat, rmdir, unlink */
#include <time.h> /* strftime */
#include <alloca.h>
#include <errno.h>

typedef char* err;

#define freeErr(X) free(X)
#define getErrMsg(X) X
#define NO_ERR (err)0

static str
replacePrefix(str s)
{
	str p;
	str buf;

	/* unfortunately we have to replace occurences of ${prefix} with
	 * MONETDBPREFIX, which is medieval in this language */
	p = strstr(s, "${prefix}");
	if (p != NULL) {
		buf = malloc(sizeof(char) * (strlen(s) + strlen(MONETDBPREFIX) + 1));
		memcpy(buf, s, p - s);
		memcpy(buf + (p - s), MONETDBPREFIX, strlen(MONETDBPREFIX));
		memcpy(buf + (p - s) + strlen(MONETDBPREFIX), s + (p - s) + 9, strlen(s) - 9 - (p - s) + 1);
		return(buf);
	} else {
		return(strdup(s));
	}
}

static void
command_help(int argc, char *argv[])
{
	if (argc != 2) {
		printf("Usage: monetdb command [command-options-and-arguments]\n");
		printf("  where command is one of:\n");
		printf("    status, create, destroy, help, version\n");
		printf("  use the help command to get help for a particular command\n");
	} else if (strcmp(argv[1], "status") == 0) {
		printf("Usage: monetdb status [-als] [database ...]\n");
		printf("  Shows the state of a given database as known to the\n");
		printf("  Sabaoth system.  Various options control what information\n");
		printf("  is displayed.\n");
		printf("Options:\n");
		printf("  -a  list status of all databases\n");
		printf("  -l  use long listing\n");
		printf("  -s  use short one-line listing\n");
	} else if (strcmp(argv[1], "create") == 0) {
		printf("Usage: monetdb create database\n");
		printf("  Initialises a new database in the Sabaoth system.  A\n");
		printf("  database created with this command makes it available\n");
		printf("  to Merovingian.\n");
	} else if (strcmp(argv[1], "destroy") == 0) {
		printf("Usage: monetdb destroy [-f] database\n");
		printf("  Removes the given database, including all its data and\n");
		printf("  logfiles.  Once destroy has completed, all data is lost.\n");
		printf("  Be careful when using this command.\n");
		printf("Options:\n");
		printf("  -f  do not ask for confirmation, destroy right away\n");
	} else if (strcmp(argv[1], "help") == 0) {
		printf("Yeah , help on help, how desparate can you be? ;)");
	} else if (strcmp(argv[1], "version") == 0) {
		printf("Usage: monetdb version\n");
		printf("  prints the version of the monetdb toolkit\n");
	} else {
		printf("help: unknown command: %s\n", argv[1]);
	}
}

static void
command_version()
{
	printf("MonetDB Toolkit v%s\n", TOOLKIT_VERSION);
}

static void
printStatus(sabdb *stats, int mode)
{
	if (mode == 1) {
		/* short one-line mode */
		char *state;
		char avg[8];
		char *crash;
		sabuplog uplog;
		str e;

		switch (stats->state) {
			case SABdbRunning:
				state = "running";
			break;
			case SABdbCrashed:
				state = "crashed";
			break;
			case SABdbInactive:
				state = "stopped";
			break;
			default:
				state = "unknown";
			break;
		}

		if ((e = SABAOTHgetUplogInfo(&uplog, stats->dbname)) != MAL_SUCCEED) {
			fprintf(stderr, "status: internal error: %s\n", e);
			GDKfree(e);
			return;
		}
		if (uplog.avguptime > 1 * 60 * 60 * 24) {
			snprintf(avg, 8, "%6dd", (int)(uplog.avguptime / (1 * 60 * 60 * 24)));
		} else if (uplog.avguptime > 1 * 60 * 60) {
			snprintf(avg, 8, "%6dh", (int)(uplog.avguptime / (1 * 60 * 60)));
		} else if (uplog.avguptime > 1 * 60) {
			snprintf(avg, 8, "%6dm", (int)(uplog.avguptime / (1 * 60)));
		} else {
			snprintf(avg, 8, "%6ds", (int)(uplog.avguptime));
		}

		if (uplog.lastcrash == -1) {
			crash = "no crash";
		} else {
			struct tm *t;
			crash = alloca(sizeof(char) * 20);
			t = localtime(&uplog.lastcrash);
			strftime(crash, 20, "%Y-%m-%d %H:%M:%S", t);
		}

		/* demo | running | avguptime | start | stop | crash | lastcrash */
		printf("%-10s  %s %s  %4d %4d  %4d %s\n",
				stats->dbname,
				state, avg,
				uplog.startcntr, uplog.stopcntr,
				uplog.crashcntr, crash);
	} else if (mode == 2) {
		/* long mode */
	} else {
		/* this is the default, also for modes that are added but we
		 * don't understand */
		printf("%s\n", stats->dbname);
	}
}

static void
command_status(int argc, char *argv[])
{
	int doall;
	int mode = 0;  /* 0=normal, 1=short, 2=long */
	int i;
	char *p;
	str e;
	sabdb *stats;

	if (argc == 1) {
		/* print help message for this command */
		command_help(2, &argv[-1]);
		exit(1);
	} else if (argc == 0) {
		exit(2);
	}

	/* time to collect some option flags */
	for (i = 1; i < argc; i++) {
		if (argv[i][0] == '-') {
			for (p = argv[i] + 1; *p != '\0'; p++) {
				switch (*p) {
					case 'a':
						doall = 1;
					break;
					case 's':
						mode = 1;
					break;
					case 'l':
						mode = 2;
					break;
					case '-':
						if (p[1] == '\0') {
							i = argc;
							break;
						}
					default:
						fprintf(stderr, "status: unknown option: -%c\n", *p);
						command_help(2, &argv[-1]);
						exit(1);
					break;
				}
			}
			/* make this option no longer available, for easy use
			 * lateron */
			argv[i] = NULL;
		}
	}

	if (doall == 1) {
		sabdb *orig;
		/* don't even look at the arguments, because we are instructed
		 * to list all known databases */
		if ((e = SABAOTHgetStatus(&stats, NULL)) != MAL_SUCCEED) {
			fprintf(stderr, "status: internal error: %s\n", e);
			GDKfree(e);
			exit(2);
		}
	
		orig = stats;
		while (stats != NULL) {
			printStatus(stats, mode);
			stats = stats->next;
		}

		if (orig != NULL)
			SABAOTHfreeStatus(&orig);
		return;
	}

	for (i = 1; i < argc; i++) {
		if (argv[i] != NULL) {
			if ((e = SABAOTHgetStatus(&stats, argv[i])) != MAL_SUCCEED) {
				fprintf(stderr, "status: internal error: %s\n", e);
				GDKfree(e);
				exit(2);
			}

			if (stats == NULL) {
				fprintf(stderr, "status: no such database: %s\n", argv[i]);
			} else {
				printStatus(stats, mode);
				SABAOTHfreeStatus(&stats);
			}
		}
	}
}

static void
command_create(int argc, char *argv[], char *dbfarm)
{
	if (argc == 1 || argc >= 3) {
		/* print help message for this command */
		command_help(2, &argv[-1]);
		exit(1);
	} else if (argc == 2) {
		sabdb *stats;
		err e;
		/* the argument is the database to create, see what Sabaoth can
		 * tell us about it */
		if ((e = SABAOTHgetStatus(&stats, argv[1])) != MAL_SUCCEED) {
			fprintf(stderr, "create: internal error: %s\n", e);
			GDKfree(e);
			exit(2);
		}

		if (stats == NULL) {
			char path[8096];
			FILE *f;
			/* Sabaoth doesn't know, green light for us! */
			snprintf(path, 8095, "%s/%s", dbfarm, argv[1]);
			path[8095] = '\0';
			if (mkdir(path, 0755) == -1) {
				fprintf(stderr, "create: unable to create %s: %s\n",
						argv[1], strerror(errno));
				exit(1);
			}
			/* without an .uplog file, Merovingian won't work */
			snprintf(path, 8095, "%s/%s/.uplog", dbfarm, argv[1]);
			fclose(fopen(path, "w"));
			/* avoid GDK from making fugly complaints */
			snprintf(path, 8095, "%s/%s/.gdk_lock", dbfarm, argv[1]);
			f = fopen(path, "w");
			/* to all insanity, .gdk_lock is "valid" if it contains a
			 * ':', which it does by pure coincidence of a time having a
			 * ':' in there twice... */
			fwrite("bla:", 4, 1, f);
			fclose(f);
			printf("successfully created database %s\n", argv[1]);
		} else {
			SABAOTHfreeStatus(&stats);
			fprintf(stderr, "create: database %s already exists\n", argv[1]);
			exit(1);
		}
	}
}

/* recursive helper function to delete a directory */
static err
deletedir(char *dir)
{
	DIR *d;
	struct dirent *e;
	struct stat s;
	str buf = alloca(sizeof(char) * (PATHLENGTH + 1));
	str data = alloca(sizeof(char) * 8096);
	str path = alloca(sizeof(char) * (PATHLENGTH + 1));

	buf[PATHLENGTH] = '\0';
	d = opendir(dir);
	if (d == NULL) {
		snprintf(data, 8095, "unable to open directory %s: %s",
				dir, strerror(errno));
		return(strdup(data));
	}
	while ((e = readdir(d)) != NULL) {
		snprintf(path, PATHLENGTH, "%s/%s", dir, e->d_name);
		if (stat(path, &s) == -1) {
			snprintf(data, 8095, "unable to stat file %s: %s",
					path, strerror(errno));
			closedir(d);
			return(strdup(data));
		}

		if (S_ISREG(s.st_mode) || S_ISLNK(s.st_mode)) {
			if (unlink(path) == -1) {
				snprintf(data, 8095, "unable to unlink file %s: %s",
						path, strerror(errno));
				closedir(d);
				return(strdup(data));
			}
		} else if (S_ISDIR(s.st_mode)) {
			err er;
			/* recurse, ignore . and .. */
			if (strcmp(e->d_name, ".") != 0 &&
					strcmp(e->d_name, "..") != 0 &&
					(er = deletedir(path)) != NO_ERR)
			{
				closedir(d);
				return(er);
			}
		} else {
			/* fifos, block, char devices etc, we don't do */
			snprintf(data, 8095, "not a regular file: %s", path);
			closedir(d);
			return(strdup(data));
		}
	}
	closedir(d);
	if (rmdir(dir) == -1) {
		snprintf(data, 8095, "unable to remove directory %s: %s",
				dir, strerror(errno));
		return(strdup(data));
	}

	return(NO_ERR);
}

static void
command_destroy(int argc, char *argv[], char *dbfarm)
{
	if (argc == 1 || argc >= 4) {
		/* print help message for this command */
		command_help(argc + 1, &argv[-1]);
		exit(1);
	} else if (argc >= 2) {
		sabdb *stats;
		err e;
		char *dbname;
		int force;

		if (argc == 2) {
			force = 0;
			if (strcmp(argv[1], "-f") == 0) {
				command_help(argc + 1, &argv[-1]);
				exit(1);
			}
			dbname = argv[1];
		} else {
			if (strcmp(argv[1], "-f") == 0) {
				force = 1;
				/* we accept -f -f, stupid user who uses it */
				dbname = argv[2];
			} else if (strcmp(argv[2], "-f") == 0) {
				force = 1;
				dbname = argv[1];
			} else {
				command_help(argc + 1, &argv[-1]);
				exit(1);
			}
		}

		/* the argument is the database to destroy, see what Sabaoth can
		 * tell us about it */
		if ((e = SABAOTHgetStatus(&stats, dbname)) != MAL_SUCCEED) {
			fprintf(stderr, "destroy: internal error: %s\n", e);
			GDKfree(e);
			exit(2);
		}

		if (stats != NULL) {
			char path[8096];
			err e;

			if (stats->state == SABdbRunning) {
				fprintf(stderr, "destroy: database %s is still running, "
						"stop database first", dbname);
				SABAOTHfreeStatus(&stats);
				exit(1);
			}
			SABAOTHfreeStatus(&stats);

			if (force == 0) {
				printf("you are about to remove database %s\n", dbname);
				printf("ALL data in this database will get lost, "
						"are you sure? [y/N] ");
				scanf("%c", path);
				if (path[0] == 'y' || path[0] == 'Y') {
					/* do it! */
				} else {
					printf("battle control terminated\n");
					exit(0);
				}
			}

			snprintf(path, 8095, "%s/%s", dbfarm, dbname);
			path[8095] = '\0';
			/* annoyingly we have to delete file by file, and
			 * directories recursively... */
			if ((e = deletedir(path)) != NULL) {
				fprintf(stderr, "destroy: failed to destroy %s: %s\n",
						argv[1], e);
				free(e);
				exit(1);
			}
			printf("successfully destroyed database %s\n", dbname);
		} else {
			fprintf(stderr, "destroy: no such database: %s\n", dbname);
			exit(1);
		}
	}
}


int
main(int argc, char *argv[])
{
	str conf = MONETDBCONFIG;
	str dbfarm;
	str p;
	FILE *cnf = NULL;
	char buf[1024];

	/* hunt for the config file, and read it */
	snprintf(buf, 1023, "%s%s", MONETDBPREFIX, conf + 9);
	cnf = fopen(buf, "r");
	if (cnf == NULL) {
		fprintf(stderr, "cannot open config file %s\n", buf);
		exit(1);
	}

	dbfarm = NULL;
	while (fgets(buf, 1024, cnf) != NULL) {
		/* eliminate fgets' newline */
		buf[strlen(buf) - 1] = '\0';
		if (*buf && strncmp(buf, "gdk_dbfarm=", 11) == 0) {
			p = strchr(buf, '=');
			dbfarm = replacePrefix(++p);
		}
	}

	fclose(cnf);

	if (dbfarm == NULL) {
		fprintf(stderr, "%s: cannot find dbfarm via config file\n", argv[0]);
		exit(2);
	}

	/* initialise Sabaoth so it knows where to look */
	SABAOTHinit(dbfarm, NULL);

	/* Start handling the arguments.
	 * monetdb command [options] [database [...]]
	 */
	if (argc <= 1) {
		command_help(0, NULL);
	} else if (strcmp(argv[1], "status") == 0) {
		command_status(argc - 1, &argv[1]);
	} else if (strcmp(argv[1], "create") == 0) {
		command_create(argc - 1, &argv[1], dbfarm);
	} else if (strcmp(argv[1], "destroy") == 0) {
		command_destroy(argc - 1, &argv[1], dbfarm);
	} else if (strcmp(argv[1], "help") == 0 || strcmp(argv[1], "-h") == 0) {
		command_help(argc - 1, &argv[1]);
	} else if (strcmp(argv[1], "version") == 0 || strcmp(argv[1], "-v") == 0) {
		command_version();
	} else {
		fprintf(stderr, "%s: unknown command: %s\n", argv[0], argv[1]);
		command_help(0, NULL);
	}

	return(0);
}

/* vim:set ts=4 sw=4 noexpandtab: */
