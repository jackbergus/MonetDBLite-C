@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2007 CWI.
@' All Rights Reserved.

@f monetdb
@a Fabian Groffen
@v 1.0
@* MonetDB Database Administrator's Toolkit
A group of MonetDB servers in a dbfarm are under control of the
Merovingian, which by itself does not allow any user interaction.
The monetdb utility is designed to be the interface for the DBA to the
dbfarm.  Creating or deleting databases next to retrieving status
information about them are the primary goals of this tool.

@h
#define TOOLKIT_VERSION   "0.2"

@c
#include "mal_config.h" /* MONETDBCONFIG, MONETDBPREFIX */
#include "monetdb.h"
#include "mal_sabaoth.h"
#include <stdlib.h> /* exit */
#include <stdarg.h>	/* variadic stuff */
#include <stdio.h> /* fprintf */
#include <string.h> /* strerror */
#include <sys/stat.h> /* mkdir, stat */
#include <sys/types.h> /* mkdir, readdir */
#include <dirent.h> /* readdir */
#include <unistd.h> /* stat, rmdir, unlink */
#include <time.h> /* strftime */
#include <alloca.h>
#include <errno.h>

typedef char* err;

#define freeErr(X) GDKfree(X)
#define getErrMsg(X) X
#define NO_ERR (err)0

static str dbfarm = NULL;
static int mero_running = 0;

static str
replacePrefix(str s)
{
	str p;
	str buf;

	/* unfortunately we have to replace occurences of ${prefix} with
	 * MONETDBPREFIX, which is medieval in this language */
	p = strstr(s, "${prefix}");
	if (p != NULL) {
		buf = GDKmalloc(sizeof(char) * (strlen(s) + strlen(MONETDBPREFIX) + 1));
		memcpy(buf, s, p - s);
		memcpy(buf + (p - s), MONETDBPREFIX, strlen(MONETDBPREFIX));
		memcpy(buf + (p - s) + strlen(MONETDBPREFIX), s + (p - s) + 9, strlen(s) - 9 - (p - s) + 1);
		return(buf);
	} else {
		return(GDKstrdup(s));
	}
}

static void
command_help(int argc, char *argv[])
{
	if (argc != 2) {
		printf("Usage: monetdb command [command-options-and-arguments]\n");
		printf("  where command is one of:\n");
		printf("    create, destroy, lock, release\n");
		printf("    status, start, stop, kill\n");
		printf("    help, version\n");
		printf("  use the help command to get help for a particular command\n");
	} else if (strcmp(argv[1], "create") == 0) {
		printf("Usage: monetdb create [-l] database\n");
		printf("  Initialises a new database in the MonetDB Server.  A\n");
		printf("  database created with this command makes it available\n");
		printf("  for use.\n");
		printf("Options:\n");
		printf("  -l  put the database in maintenance mode after creation\n");
	} else if (strcmp(argv[1], "destroy") == 0) {
		printf("Usage: monetdb destroy [-f] database\n");
		printf("  Removes the given database, including all its data and\n");
		printf("  logfiles.  Once destroy has completed, all data is lost.\n");
		printf("  Be careful when using this command.\n");
		printf("Options:\n");
		printf("  -f  do not ask for confirmation, destroy right away\n");
	} else if (strcmp(argv[1], "lock") == 0) {
		printf("Usage: monetdb lock database\n");
		printf("  Puts the given database in maintenance mode.  A database\n");
		printf("  under maintenance can only be connected to by the DBA.\n");
		printf("  A database which is under maintenance is not started\n");
		printf("  automatically.  Use the \"release\" command to bring\n");
		printf("  the database back for normal usage.\n");
	} else if (strcmp(argv[1], "release") == 0) {
		printf("Usage: monetdb release database\n");
		printf("  Brings back a database from maintenance mode.  A released\n");
		printf("  database is available again for normal use.  Use the\n");
		printf("  \"lock\" command to take a database under maintenance.\n");
	} else if (strcmp(argv[1], "status") == 0) {
		printf("Usage: monetdb status [-als] [database ...]\n");
		printf("  Shows the state of a given database.  Various options\n");
		printf("  control what information is displayed.\n");
		printf("Options:\n");
		printf("  -a  list status of all databases\n");
		printf("  -l  use long listing\n");
		printf("  -s  use short one-line listing\n");
	} else if (strcmp(argv[1], "start") == 0) {
		printf("Usage: monetdb start [-a] [database ...]\n");
		printf("  Starts the given database, if the MonetDB Database Server\n");
		printf("  is running.\n");
	} else if (strcmp(argv[1], "stop") == 0) {
		printf("Usage: monetdb stop [-a] [database ...]\n");
		printf("  Stops the given database, if the MonetDB Database Server\n");
		printf("  is running.\n");
	} else if (strcmp(argv[1], "kill") == 0) {
		printf("Usage: monetdb kill [-a] [database ...]\n");
		printf("  Kills the given database, if the MonetDB Database Server\n");
		printf("  is running.  Note: killing a database should only be done\n");
		printf("  as last resort to stop a database.  A database being\n");
		printf("  killed may end up with data loss.\n");
	} else if (strcmp(argv[1], "help") == 0) {
		printf("Yeah , help on help, how desparate can you be? ;)\n");
	} else if (strcmp(argv[1], "version") == 0) {
		printf("Usage: monetdb version\n");
		printf("  prints the version of this monetdb utility\n");
	} else {
		printf("help: unknown command: %s\n", argv[1]);
	}
}

static void
command_version()
{
	printf("MonetDB Database Server Toolkit v%s\n", TOOLKIT_VERSION);
}

static void
secondsToString(char *buf, time_t t, int printlong)
{
	time_t p;
	size_t i = 0;

	p = 1 * 60 * 60 * 24;
	if (t > p) {
		i += sprintf(buf, "%dd", (int)(t / p));
		t -= (t / p) * p;
		if (printlong == 0)
			return;
		buf[i++] = ' ';
	}
	p = 1 * 60 * 60;
	if (t > p) {
		i += sprintf(buf + i, "%dh", (int)(t / p));
		t -= (t / p) * p;
		if (printlong == 0)
			return;
		buf[i++] = ' ';
	}
	p = 1 * 60;
	if (t > p) {
		i += sprintf(buf + i, "%dm", (int)(t / p));
		t -= (t / p) * p;
		if (printlong == 0)
			return;
		buf[i++] = ' ';
	}

	/* t must be < 60 */
	sprintf(buf + i, "%ds", (int)(t));
}

static void
printStatus(sabdb *stats, int mode)
{
	sabuplog uplog;
	str e;

	if ((e = SABAOTHgetUplogInfo(&uplog, stats)) != MAL_SUCCEED) {
		fprintf(stderr, "status: internal error: %s\n", e);
		GDKfree(e);
		return;
	}

	if (mode == 1) {
		/* short one-line mode */
		char *state;
		char avg[8];
		char *crash;

		switch (stats->state) {
			case SABdbRunning:
				state = "running";
			break;
			case SABdbCrashed:
				state = "crashed";
			break;
			case SABdbInactive:
				state = "stopped";
			break;
			default:
				state = "unknown";
			break;
		}
		/* override if locked for brevity */
		if (stats->locked == 1)
			state = "mainten";

		secondsToString(avg, uplog.avguptime, 0);

		if (uplog.lastcrash == -1) {
			crash = "no crash";
		} else {
			struct tm *t;
			crash = alloca(sizeof(char) * 20);
			t = localtime(&uplog.lastcrash);
			strftime(crash, 20, "%Y-%m-%d %H:%M:%S", t);
		}

		/* demo | running | avguptime | start | stop | crash | lastcrash */
		printf("%-10s  %s %7s  %4d %4d  %4d %s\n",
				stats->dbname,
				state, avg,
				uplog.startcntr, uplog.stopcntr,
				uplog.crashcntr, crash);
	} else if (mode == 2) {
		/* long mode */
		char *state;
		sablist *entry;
		char up[32];
		struct tm *t;

		switch (stats->state) {
			case SABdbRunning:
				state = "running";
			break;
			case SABdbCrashed:
				state = "crashed";
			break;
			case SABdbInactive:
				state = "stopped";
			break;
			default:
				state = "unknown";
			break;
		}

		printf("%s:\n", stats->dbname);
		printf("  location: %s\n", stats->path);
		printf("  database name: %s\n", stats->dbname);
		printf("  state: %s\n", state);
		printf("  under maintenance: %s\n", stats->locked == 1 ? "yes" : "no");
		entry = stats->scens;
		printf("  available scenarios:");
		if (entry == NULL) {
			printf(" (none)");
		} else while (entry != NULL) {
			printf(" %s", entry->val);
			entry = entry->next;
		}
		printf("\n");
		entry = stats->conns;
		printf("  listening connections:");
		if (entry == NULL) {
			printf(" (none)");
		} else while (entry != NULL) {
			printf(" %s", entry->val);
			entry = entry->next;
		}
		printf("\n");
		printf("  start count: %d\n  stop count: %d\n  crash count: %d\n",
				uplog.startcntr, uplog.stopcntr, uplog.crashcntr);
		if (stats->state == SABdbRunning) {
			secondsToString(up, time(NULL) - uplog.laststart, 1);
			printf("  current uptime: %s\n", up);
		}
		secondsToString(up, uplog.avguptime, 1);
		printf("  average uptime: %s\n", up);
		secondsToString(up, uplog.maxuptime, 1);
		printf("  maximum uptime: %s\n", up);
		secondsToString(up, uplog.minuptime, 1);
		printf("  minimum uptime: %s\n", up);
		if (uplog.lastcrash != -1) {
			t = localtime(&uplog.lastcrash);
			strftime(up, 32, "%Y-%m-%d %H:%M:%S", t);
		} else {
			sprintf(up, "(unknown)");
		}
		printf("  last crash: %s\n", up);
		if (uplog.laststart != -1) {
			t = localtime(&uplog.laststart);
			strftime(up, 32, "%Y-%m-%d %H:%M:%S", t);
		} else {
			sprintf(up, "(unknown)");
		}
		printf("  last start: %s\n", up);
		printf("  average of crashes in the last start attempt: %d\n",
				uplog.crashavg1);
		printf("  average of crashes in the last 10 start attempts: %.2f\n",
				uplog.crashavg10);
		printf("  average of crashes in the last 30 start attempts: %.2f\n",
				uplog.crashavg30);
	} else {
		/* this is the default, also for modes that are added but we
		 * don't understand (yet) */
		char buf[64];
		char min[8], avg[8], max[8];
		struct tm *t;
		/* dbname, status -- since, crash averages */

		switch (stats->state) {
			case SABdbRunning: {
				char up[32];
				t = localtime(&uplog.laststart);
				strftime(buf, 64, "up since %Y-%m-%d %H:%M:%S, ", t);
				secondsToString(up, time(NULL) - uplog.laststart, 1);
				strcat(buf, up);
			} break;
			case SABdbCrashed:
				t = localtime(&uplog.lastcrash);
				strftime(buf, 64, "crashed on %Y-%m-%d %H:%M:%S", t);
			break;
			case SABdbInactive:
				snprintf(buf, 64, "not running");
			break;
			default:
				snprintf(buf, 64, "unknown");
			break;
		}
		if (stats->locked == 1)
			strcat(buf, ", under maintenance");
		printf("database %s, %s\n", stats->dbname, buf);
		printf("  crash average: %d.00 %.2f %.2f (over 1, 15, 30 starts) "
				"in total %d crashes\n",
				uplog.crashavg1, uplog.crashavg10, uplog.crashavg30,
				uplog.crashcntr);
		secondsToString(min, uplog.minuptime, 0);
		secondsToString(avg, uplog.avguptime, 0);
		secondsToString(max, uplog.maxuptime, 0);
		printf("  uptime stats (min/avg/max): %s/%s/%s over %d runs\n",
				min, avg, max, uplog.stopcntr);
	}
}

static void
command_status(int argc, char *argv[])
{
	int doall = 0;
	int mode = 0;  /* 0=normal, 1=short, 2=long */
	int i;
	char *p;
	str e;
	sabdb *stats;

	if (argc == 1) {
		/* print help message for this command */
		command_help(2, &argv[-1]);
		exit(1);
	} else if (argc == 0) {
		exit(2);
	}

	/* time to collect some option flags */
	for (i = 1; i < argc; i++) {
		if (argv[i][0] == '-') {
			for (p = argv[i] + 1; *p != '\0'; p++) {
				switch (*p) {
					case 'a':
						doall = 1;
					break;
					case 's':
						mode = 1;
					break;
					case 'l':
						mode = 2;
					break;
					case '-':
						if (p[1] == '\0') {
							i = argc;
							break;
						}
					default:
						fprintf(stderr, "status: unknown option: -%c\n", *p);
						command_help(2, &argv[-1]);
						exit(1);
					break;
				}
			}
			/* make this option no longer available, for easy use
			 * lateron */
			argv[i] = NULL;
		}
	}

	if (mode == 1) {
		/* print header for short mode */
		/* demo | running | avguptime | start | stop | crash | lastcrash */
		printf("   name      state  avgutme  strt stop  crsh crashdate\n");
	}

	if (doall == 1) {
		sabdb *orig;
		/* don't even look at the arguments, because we are instructed
		 * to list all known databases */
		if ((e = SABAOTHgetStatus(&stats, NULL)) != MAL_SUCCEED) {
			fprintf(stderr, "status: internal error: %s\n", e);
			GDKfree(e);
			exit(2);
		}
	
		orig = stats;
		while (stats != NULL) {
			printStatus(stats, mode);
			stats = stats->next;
		}

		if (orig != NULL)
			SABAOTHfreeStatus(&orig);
		return;
	}

	for (i = 1; i < argc; i++) {
		if (argv[i] != NULL) {
			if ((e = SABAOTHgetStatus(&stats, argv[i])) != MAL_SUCCEED) {
				fprintf(stderr, "status: internal error: %s\n", e);
				GDKfree(e);
				exit(2);
			}

			if (stats == NULL) {
				fprintf(stderr, "status: no such database: %s\n", argv[i]);
			} else {
				printStatus(stats, mode);
				SABAOTHfreeStatus(&stats);
			}
		}
	}
}

typedef enum {
	START = 0,
	STOP,
	KILL
} merocom;

static void
command_merocom(int argc, char *argv[], char *dbfarm, merocom mode)
{
	int doall = 0;
	char path[8096];
	FILE *f;
	char buf[256];
	int i;
	err e;
	sabdb *stats;
	char *type = NULL;

	snprintf(path, 8095, "%s/.merovingian_control", dbfarm);
	path[8095] = '\0';

	switch (mode) {
		case START:
			type = "start";
		break;
		case STOP:
			type = "stop";
		break;
		case KILL:
			type = "kill";
		break;
	}

	if (argc == 1) {
		/* print help message for this command */
		command_help(2, &argv[-1]);
		exit(1);
	} else if (argc == 0) {
		exit(2);
	}

	/* time to collect some option flags */
	for (i = 1; i < argc; i++) {
		if (argv[i][0] == '-') {
			if (strcmp(&argv[i][1], "a") == 0) {
				doall = 1;
			} else if (strcmp(&argv[i][1], "-") == 0) {
				i = argc;
			} else {
				fprintf(stderr, "%s: unknown option: -%c\n", type, argv[i][1]);
				command_help(2, &argv[-1]);
				exit(1);
			}
			/* make this option no longer available, for easy use
			 * lateron */
			argv[i] = NULL;
		}
	}

	/* if Merovingian isn't running, there's not much we can do */
	if (mero_running == 0) {
		fprintf(stderr, "%s: cannot perform: MonetDB Database Server "
				"(merovingian) is not running\n", type);
		exit(1);
	}

	if ((f = fopen(path, "w")) == NULL) {
		fprintf(stderr, "%s: cannot write command: %s\n",
				type, strerror(errno));
		exit(2);
	}

	if (doall == 1) {
		sabdb *orig;
		/* don't even look at the arguments, because we are instructed
		 * to work on all known databases */
		if ((e = SABAOTHgetStatus(&stats, NULL)) != MAL_SUCCEED) {
			fprintf(stderr, "%s: internal error: %s\n", type, e);
			GDKfree(e);
			exit(2);
		}
	
		orig = stats;
		while (stats != NULL &&
				(((mode == STOP || mode == KILL)
				  && stats->state == SABdbRunning) ||
				(mode == START && stats->state != SABdbRunning)))
		{
			snprintf(buf, 256, "%s %s\n", stats->dbname, type);
			fputs(buf, f);
			stats = stats->next;
		}

		fflush(f);
		fclose(f);

		if (orig != NULL)
			SABAOTHfreeStatus(&orig);
		return;
	}

	for (i = 1; i < argc; i++) {
		if (argv[i] != NULL) {
			if ((e = SABAOTHgetStatus(&stats, argv[i])) != MAL_SUCCEED) {
				fprintf(stderr, "%s: internal error: %s\n", type, e);
				GDKfree(e);
				exit(2);
			}

			if (stats == NULL) {
				fprintf(stderr, "%s: no such database: %s\n", type, argv[i]);
			} else {
				if ((mode == STOP || mode == KILL) &&
						stats->state != SABdbRunning)
				{
					printf("%s: database is not running: %s\n", type, argv[i]);
				} else if (mode == START && stats->state == SABdbRunning) {
					printf("%s: database is already running: %s\n",
							type, argv[1]);
				} else {
					snprintf(buf, 256, "%s %s\n", stats->dbname, type);
					fputs(buf, f);
				}

				SABAOTHfreeStatus(&stats);
			}
		}
	}

	fflush(f);
	fclose(f);
}

static void
command_create(int argc, char *argv[], char *dbfarm)
{
	if (argc == 1 || argc >= 4) {
		/* print help message for this command */
		command_help(2, &argv[-1]);
		exit(1);
	} else if (argc == 2 || argc == 3) {
		sabdb *stats;
		err e;
		char *dbname;
		int maintenance = 0;

		if (strcmp(argv[1], "-l") == 0) {
			if (argc == 2) {
				command_help(2, &argv[-1]);
				exit(1);
			}
			maintenance = 1;
			dbname = argv[2];
		} else if (argc == 3 && strcmp(argv[2], "-l") == 0) {
			maintenance = 1;
			dbname = argv[1];
		} else if (argc == 2) {
			dbname = argv[1];
		} else {
			command_help(2, &argv[-1]);
			exit(1);
		}

		/* the argument is the database to create, see what Sabaoth can
		 * tell us about it */
		if ((e = SABAOTHgetStatus(&stats, dbname)) != MAL_SUCCEED) {
			fprintf(stderr, "create: internal error: %s\n", e);
			GDKfree(e);
			exit(2);
		}

		if (stats == NULL) {
			char path[8096];
			FILE *f;
			/* Sabaoth doesn't know, green light for us! */
			snprintf(path, 8095, "%s/%s", dbfarm, dbname);
			path[8095] = '\0';
			if (mkdir(path, 0755) == -1) {
				fprintf(stderr, "create: unable to create %s: %s\n",
						argv[1], strerror(errno));
				exit(1);
			}
			/* if we should put this database in maintenance, make sure
			 * no race condition ever can happen, by putting it into
			 * maintenance before it even exists for Merovingian */
			if (maintenance == 1) {
				snprintf(path, 8095, "%s/%s/.maintenance", dbfarm, dbname);
				fclose(fopen(path, "w"));
			}
			/* without an .uplog file, Merovingian won't work */
			snprintf(path, 8095, "%s/%s/.uplog", dbfarm, dbname);
			fclose(fopen(path, "w"));
			/* avoid GDK from making fugly complaints */
			snprintf(path, 8095, "%s/%s/.gdk_lock", dbfarm, dbname);
			f = fopen(path, "w");
			/* to all insanity, .gdk_lock is "valid" if it contains a
			 * ':', which it does by pure coincidence of a time having a
			 * ':' in there twice... */
			fwrite("bla:", 4, 1, f);
			fclose(f);
			printf("successfully created database %s%s\n", dbname,
					(maintenance == 1 ? " in maintenance mode" : ""));
		} else {
			SABAOTHfreeStatus(&stats);
			fprintf(stderr, "create: database %s already exists\n", dbname);
			exit(1);
		}
	}
}

/* recursive helper function to delete a directory */
static err
deletedir(char *dir)
{
	DIR *d;
	struct dirent *e;
	struct stat s;
	str buf = alloca(sizeof(char) * (PATHLENGTH + 1));
	str data = alloca(sizeof(char) * 8096);
	str path = alloca(sizeof(char) * (PATHLENGTH + 1));

	buf[PATHLENGTH] = '\0';
	d = opendir(dir);
	if (d == NULL) {
		snprintf(data, 8095, "unable to open directory %s: %s",
				dir, strerror(errno));
		return(GDKstrdup(data));
	}
	while ((e = readdir(d)) != NULL) {
		snprintf(path, PATHLENGTH, "%s/%s", dir, e->d_name);
		if (stat(path, &s) == -1) {
			snprintf(data, 8095, "unable to stat file %s: %s",
					path, strerror(errno));
			closedir(d);
			return(GDKstrdup(data));
		}

		if (S_ISREG(s.st_mode) || S_ISLNK(s.st_mode)) {
			if (unlink(path) == -1) {
				snprintf(data, 8095, "unable to unlink file %s: %s",
						path, strerror(errno));
				closedir(d);
				return(GDKstrdup(data));
			}
		} else if (S_ISDIR(s.st_mode)) {
			err er;
			/* recurse, ignore . and .. */
			if (strcmp(e->d_name, ".") != 0 &&
					strcmp(e->d_name, "..") != 0 &&
					(er = deletedir(path)) != NO_ERR)
			{
				closedir(d);
				return(er);
			}
		} else {
			/* fifos, block, char devices etc, we don't do */
			snprintf(data, 8095, "not a regular file: %s", path);
			closedir(d);
			return(GDKstrdup(data));
		}
	}
	closedir(d);
	if (rmdir(dir) == -1) {
		snprintf(data, 8095, "unable to remove directory %s: %s",
				dir, strerror(errno));
		return(GDKstrdup(data));
	}

	return(NO_ERR);
}

static void
command_destroy(int argc, char *argv[])
{
	if (argc == 1 || argc >= 4) {
		/* print help message for this command */
		command_help(argc + 1, &argv[-1]);
		exit(1);
	} else if (argc >= 2) {
		sabdb *stats;
		err e;
		char *dbname;
		int force;

		if (argc == 2) {
			force = 0;
			if (strcmp(argv[1], "-f") == 0) {
				command_help(argc + 1, &argv[-1]);
				exit(1);
			}
			dbname = argv[1];
		} else {
			if (strcmp(argv[1], "-f") == 0) {
				force = 1;
				/* we accept -f -f, stupid user who uses it */
				dbname = argv[2];
			} else if (strcmp(argv[2], "-f") == 0) {
				force = 1;
				dbname = argv[1];
			} else {
				command_help(argc + 1, &argv[-1]);
				exit(1);
			}
		}

		/* the argument is the database to destroy, see what Sabaoth can
		 * tell us about it */
		if ((e = SABAOTHgetStatus(&stats, dbname)) != MAL_SUCCEED) {
			fprintf(stderr, "destroy: internal error: %s\n", e);
			GDKfree(e);
			exit(2);
		}

		if (stats != NULL) {
			err e;

			if (stats->state == SABdbRunning) {
				fprintf(stderr, "destroy: database %s is still running, "
						"stop database first\n", dbname);
				SABAOTHfreeStatus(&stats);
				exit(1);
			}
			if (stats->locked == 1) {
				fprintf(stderr, "destroy: database %s is under maintenance"
						", release database first\n", dbname);
				SABAOTHfreeStatus(&stats);
				exit(1);
			}

			if (force == 0) {
				char answ;
				printf("you are about to remove database %s\n", dbname);
				printf("ALL data in this database will get lost, "
						"are you sure? [y/N] ");
				scanf("%c", &answ);
				if (answ == 'y' || answ == 'Y') {
					/* do it! */
				} else {
					printf("battle control terminated\n");
					exit(0);
				}
			}

			/* annoyingly we have to delete file by file, and
			 * directories recursively... */
			if ((e = deletedir(stats->path)) != NULL) {
				fprintf(stderr, "destroy: failed to destroy %s: %s\n",
						argv[1], e);
				GDKfree(e);
				exit(1);
			}
			SABAOTHfreeStatus(&stats);
			printf("successfully destroyed database %s\n", dbname);
		} else {
			fprintf(stderr, "destroy: no such database: %s\n", dbname);
			exit(1);
		}
	}
}

static void
command_lock(int argc, char *argv[])
{
	if (argc == 1 || argc > 2) {
		/* print help message for this command */
		command_help(argc + 1, &argv[-1]);
		exit(1);
	} else if (argc == 2) {
		sabdb *stats;
		err e;
		char *dbname = argv[1];

		/* the argument is the database to take under maintenance, see
		 * what Sabaoth can tell us about it */
		if ((e = SABAOTHgetStatus(&stats, dbname)) != MAL_SUCCEED) {
			fprintf(stderr, "lock: internal error: %s\n", e);
			GDKfree(e);
			exit(2);
		}

		if (stats != NULL) {
			char path[8096];

			if (stats->locked == 1) {
				fprintf(stderr, "lock: database %s already is "
						"under maintenance\n", dbname);
				SABAOTHfreeStatus(&stats);
				exit(1);
			}

			/* put this database in maintenance mode */
			snprintf(path, 8095, "%s/.maintenance", stats->path);
			fclose(fopen(path, "w"));
			printf("database %s is now under maintenance\n", dbname);
			SABAOTHfreeStatus(&stats);
		} else {
			fprintf(stderr, "lock: no such database %s\n", dbname);
			exit(1);
		}
	}
}

static void
command_release(int argc, char *argv[])
{
	if (argc == 1 || argc > 2) {
		/* print help message for this command */
		command_help(argc + 1, &argv[-1]);
		exit(1);
	} else if (argc == 2) {
		sabdb *stats;
		err e;
		char *dbname = argv[1];

		/* the argument is the database to take under maintenance, see
		 * what Sabaoth can tell us about it */
		if ((e = SABAOTHgetStatus(&stats, dbname)) != MAL_SUCCEED) {
			fprintf(stderr, "release: internal error: %s\n", e);
			GDKfree(e);
			exit(2);
		}

		if (stats != NULL) {
			char path[8096];

			if (stats->locked != 1) {
				fprintf(stderr, "release: database %s is not "
						"under maintenance\n", dbname);
				SABAOTHfreeStatus(&stats);
				exit(1);
			}

			/* put this database in maintenance mode */
			snprintf(path, 8095, "%s/.maintenance", stats->path);
			if (unlink(path) != 0) {
				fprintf(stderr, "failed to take database %s out of maintenance"
						" mode: %s\n", dbname, strerror(errno));
				SABAOTHfreeStatus(&stats);
				exit(1);
			}
			printf("database %s has been taken out of maintenance mode\n",
					dbname);
			SABAOTHfreeStatus(&stats);
		} else {
			fprintf(stderr, "release: no such database %s\n", dbname);
			exit(1);
		}
	}
}


int
main(int argc, char *argv[])
{
	str conf = MONETDBCONFIG;
	str p;
	FILE *cnf = NULL;
	char buf[1024];
	int fd;

	/* hunt for the config file, and read it */
	snprintf(buf, 1023, "%s%s", MONETDBPREFIX, conf + 9);
	cnf = fopen(buf, "r");
	if (cnf == NULL) {
		fprintf(stderr, "cannot open config file %s\n", buf);
		exit(1);
	}

	while (fgets(buf, 1024, cnf) != NULL) {
		/* eliminate fgets' newline */
		buf[strlen(buf) - 1] = '\0';
		if (*buf && strncmp(buf, "gdk_dbfarm=", 11) == 0) {
			p = strchr(buf, '=');
			dbfarm = replacePrefix(++p);
		}
	}

	fclose(cnf);

	if (dbfarm == NULL) {
		fprintf(stderr, "%s: cannot find dbfarm via config file\n", argv[0]);
		exit(2);
	}

	mero_running = 1;
	snprintf(buf, 1024, "%s/.merovingian_lock", dbfarm);
	fd = MT_lockf(buf, F_TLOCK, 4, 1);
	if (fd >= 0 || fd == -2) {
		if (fd >= 0)
			close(fd);
		/* locking succeed or locking was impossible */
		fprintf(stderr, "warning: MonetDB Database Server is not running\n");
		mero_running = 0;
	}

	/* initialise Sabaoth so it knows where to look */
	SABAOTHinit(dbfarm, NULL);

	/* Start handling the arguments.
	 * monetdb command [options] [database [...]]
	 */
	if (argc <= 1) {
		command_help(0, NULL);
	} else if (strcmp(argv[1], "create") == 0) {
		command_create(argc - 1, &argv[1], dbfarm);
	} else if (strcmp(argv[1], "destroy") == 0) {
		command_destroy(argc - 1, &argv[1]);
	} else if (strcmp(argv[1], "lock") == 0) {
		command_lock(argc - 1, &argv[1]);
	} else if (strcmp(argv[1], "release") == 0) {
		command_release(argc - 1, &argv[1]);
	} else if (strcmp(argv[1], "status") == 0) {
		command_status(argc - 1, &argv[1]);
	} else if (strcmp(argv[1], "start") == 0) {
		command_merocom(argc - 1, &argv[1], dbfarm, START);
	} else if (strcmp(argv[1], "stop") == 0) {
		command_merocom(argc - 1, &argv[1], dbfarm, STOP);
	} else if (strcmp(argv[1], "kill") == 0) {
		command_merocom(argc - 1, &argv[1], dbfarm, KILL);
	} else if (strcmp(argv[1], "help") == 0 || strcmp(argv[1], "-h") == 0) {
		command_help(argc - 1, &argv[1]);
	} else if (strcmp(argv[1], "version") == 0 || strcmp(argv[1], "-v") == 0) {
		command_version();
	} else {
		fprintf(stderr, "%s: unknown command: %s\n", argv[0], argv[1]);
		command_help(0, NULL);
	}

	return(0);
}

/* vim:set ts=4 sw=4 noexpandtab: */
