@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2007 CWI.
@' All Rights Reserved.

@f merovingian
@a Fabian Groffen
@v 1.0
@* The MonetDB keeper
The role of the Merovingian within the MonetDB suite is to act as a
smart proxy, with capabilities to start Mservers when necessary.

Since some people appear to have troubles pronouncing or remembering its
name, one can also refer to the Merovingian, as Mero, Merov or Nebula.
While the latter one has nothing to do with the former, it is provided
as convenience for those who keep on having technical problems with
pronouncing the former.  In any case, people having difficulties here
should watch the Matrix once more.

Most of the Merovingian's decisions are based on information provided by
Sabaoth.  Sabaoth is a file-system based administration shared between
all Mservers in the same farm on a local machine.  It keeps track of how
Mservers can be reached, with which scenarios, and what the crashcounter
of each server is.

The Merovingian will fork off an Mserver whenever a client requests a
database which is not running yet.  The forked Mserver is detached from
the Merovingian, such that the Mserver can live on, even if the
Merovingian is restarted (or dies).  Sabaoth will deal with the
Merovingian finding the Mservers already running, or forked.

Forking off an Mserver isn't done unconditionally.  The crashlog
information maintained by Sabaoth for a given database is consulted
before each fork.  While Sabaoth itself will make sure that the Mserver
logs a warning upon restart after a crash, Merovingian will refuse to
start an Mserver if it has crashed a number of times during a recent
period.  The Merovingian will log such refusals as well as return this
as error to the connecting client.

@h
#define MEROV_VERSION	"0.1"
#define MEROV_PORT		50000

@c
#include "mal_config.h"
#include "merovingian.h"
#include "mal_sabaoth.h"
#include <stream_socket.h>
#include <stdlib.h> /* exit */
#include <stdarg.h>	/* variadic stuff */
#include <stdio.h> /* fprintf */
#include <sys/types.h>
#ifdef HAVE_SYS_SOCKET_H
#include <sys/socket.h>
#endif
#ifdef HAVE_SYS_UN_H
#include <sys/un.h>
#endif
#ifdef HAVE_NETDB_H
# include <netdb.h>
# include <netinet/in.h>
#endif
#include <unistd.h>
#include <string.h> /* strdup, strerror */
#include <alloca.h>
#include <errno.h>
#ifdef _MSC_VER
#include <process.h>

#define snprintf _snprintf
#define vsnprintf _vsnprintf
#endif

#define SOCKPTR struct sockaddr *
#if HAVE_SOCKLEN_T
#define SOCKLEN socklen_t
#else
#define SOCKLEN int
#endif

typedef char* err;

#define freeErr(X) free(X)
#define getErrMsg(X) X
#define NO_ERR (err)0

static str _merovingian_mserver = NULL;

/**
 * Tries to log the given string and formatting parameter stuff.  This
 * function may decide how to log it, e.g. syslog, it's own logfile or
 * stderr.
 *
 * Currently this method just spits everything it gets to stderr.
 */
static void
merlog(str fmt, ...)
{
	va_list ap;
	char message[4096];
	int len;

	va_start(ap, fmt);

	len = snprintf(message, 4095, "[merovingian]:" LLFMT " ",
			(long long int)getpid());
	len += vsnprintf(message + len, 4095 - len, fmt, ap);
	message[len] = '\0';

	/* trim trailing newlines */
	while (len > 0 && message[--len] == '\n')
		message[len] = '\0';

	fprintf(stderr, "%s\n", message);

	va_end(ap);
}

/**
 * Creates a new error, allocated with malloc.  The error should be
 * freed using freeErr().
 */
static str
newErr(str fmt, ...)
{
	va_list ap;
	char message[4096];
	str ret;
	int len;

	va_start(ap, fmt);

	len = vsnprintf(message, 4095, fmt, ap);
	message[len] = '\0';

	va_end(ap);

	ret = malloc(sizeof(char) * (len + 1));
	memcpy(ret, message, len + 1);
	return(ret);
}

/**
 * Fork an Mserver and detach.  The forked Mserver is not a child of
 * this process any more after this function.  Hence, no client pid is
 * maintained or returned.  Before forking off, Sabaoth is consulted to
 * see if forking makes sense, or whether it is necessary at all, or
 * forbidden by restart policy. (TODO)
 */
static err
forkMserver(str database, sabdb** stats)
{
#ifdef NATIVE_WIN32
	intptr_t rv = 0;
	/*rv = _spawnv(_P_DETACH, ...); FIXME */ (void) database;
	if (rv == -1) {
		/* forking failed somehow */
		return(newErr(strerror(errno)));
	}
	return(NO_ERR);
#else
	pid_t pid;
	str er;

	er = SABAOTHgetStatus(stats, database);
	if (er != MAL_SUCCEED) {
		err e = newErr("%s", er);
		GDKfree(er);
		*stats = NULL;
		return(e);
	}

	if (*stats == NULL)
		return(newErr("no such database: %s", database));

	/* Since we ask for a specific database, it should be either there
	 * or not there.  Since we checked the latter case above, it should
	 * just be there, and be the right one.  There also shouldn't be
	 * more than one entries in the list, so we assume we have the right
	 * one here. */

	switch ((*stats)->state) {
		case SABdbRunning:
			merlog("database %s already running", database);
			return(NO_ERR);
		break;
		case SABdbCrashed:
			merlog("database %s has crashed, attempting restart", database);
		break;
		case SABdbInactive:
			merlog("starting database %s", database);
		break;
		default:
			return(newErr("unknown state: %d", (*stats)->state));
	}

	pid = fork();
	if (pid == 0) {
		/* child: refork again, such that this child can die, and the
		 * childchild becomes an orphan which init cares for */
		pid = fork();
		if (pid == 0) {
			/* ok, now exec that mserver we want */
			str dbname = alloca(sizeof(char) * 512);
			snprintf(dbname, 511, "--dbname=%s", database);
			merlog("executing %s for database %s",
					_merovingian_mserver, dbname);
			execl(_merovingian_mserver, _merovingian_mserver,
					"--set", "daemon=yes",
					dbname,
					"--dbinit=include sql;", /* yes, this IS correct */
					(char *)NULL);
			/* if the exec returns, it is because of a failure */
			merlog("executing failed: %s", strerror(errno));
			exit(1);
		} else if (pid > 0) {
			/* we are the parent of the childchild, so let's die */
			exit(0);
		} else {
			/* bleh... forking failed :( nothing we can do but log */
			merlog("forking sub-child failed, no mserver spawned!");
			exit(1);
		}
	} else if (pid > 0) {
		/* parent: fine, we're done */
		return(NO_ERR);
	}
	/* forking failed somehow */
	return(newErr(strerror(errno)));
#endif
}

err
handleClient(int sock)
{
	stream *fdin, *fout;
	bstream *fin;
	str buf = alloca(sizeof(char) * 8096);
	char *user = NULL, *algo = NULL, *passwd = NULL, *lang = NULL;
	char *database = NULL, *s;
	sabdb *top = NULL;
	sabdb *stat = NULL;

	fdin = block_stream(socket_rastream(sock, "read"));
	fout = block_stream(socket_wastream(sock, "write"));

	if (!fdin || !fout) {
		return(newErr("inputstream or outputstream problems"));
	}

	/* note that we claim to speak proto 8 here */
	stream_printf(fout, "%s:merovingian:8:%s:%s",
			"void",  /* some bs */
			"plain", /* FIXME: don't do difficult things for now */
#ifdef WORDS_BIGENDIAN
			"BIG"
#else
			"LIT"
#endif
			);
	stream_flush(fout);
	/* get response */
	stream_read_block(fdin, buf, 8095, 1);

	fin = bstream_create(fdin, 128 * 8096);
	fin->eof = 1;

	/* decode BIG/LIT:user:{cypher}passwordchal:lang:database: line */

	user = buf;
	/* byte order */
	s = strchr(user, ':');
	if (s) {
		*s = 0;
		stream_set_byteorder(fin->s, strcmp(user, "BIG") == 0);
		user = s + 1;
	} else {
		err e = newErr("client challenge error: %s", buf);
		stream_printf(fout, "!incomplete challenge '%s'\n", user);
		stream_flush(fout);
		stream_close(fout);
		stream_close(fdin);
		return(e);
	}

	/* passwd */
	s = strchr(user, ':');
	if (s) {
		*s = 0;
		passwd = s + 1;
		/* decode algorithm, i.e. {plain}mypasswordchallenge */
		if (*passwd != '{') {
			err e = newErr("client challenge error: %s", buf);
			stream_printf(fout, "!invalid password entry\n");
			stream_flush(fout);
			stream_close(fout);
			stream_close(fdin);
			return(e);
		}
		algo = passwd + 1;
		s = strchr(algo, '}');
		if (!s) {
			err e = newErr("client challenge error: %s", buf);
			stream_printf(fout, "!invalid password entry\n");
			stream_flush(fout);
			stream_close(fout);
			stream_close(fdin);
			return(e);
		}
		*s = 0;
		passwd = s + 1;
	} else {
		err e = newErr("client challenge error: %s", buf);
		stream_printf(fout, "!incomplete challenge '%s'\n", user);
		stream_flush(fout);
		stream_close(fout);
		stream_close(fdin);
		return(e);
	}

	/* lang */
	s = strchr(passwd, ':');
	if (s) {
		*s = 0;
		lang = s + 1;
	} else {
		err e = newErr("client challenge error: %s", buf);
		stream_printf(fout, "!incomplete challenge, missing language\n");
		stream_flush(fout);
		stream_close(fout);
		stream_close(fdin);
		return(e);
	}

	/* database */
	s = strchr(lang, ':');
	if (s) {
		*s = 0;
		database = s + 1;
		/* we can have stuff following, make it void */
		s = strchr(database, ':');
		if (s)
			*s = 0;
	}

	if (*database == '\0') {
		/* send a redirect to the "default" database, since we don't
		 * know what "default" is, we can't do much more than
		 * redirecting to the first database which appears to be online. */
		str er = SABAOTHgetStatus(&top, NULL);
		if (er != MAL_SUCCEED) {
			err e = newErr(er);
			GDKfree(er);
			stream_printf(fout, "!internal error, please try again later\n");
			stream_flush(fout);
			stream_close(fout);
			stream_close(fdin);
			return(e);
		}
		stat = top;
		while (stat != NULL) {
			if (stat->state == SABdbRunning) {
				break;
			}
		}
		if (stat == NULL) {
			SABAOTHfreeStatus(&top);
			stream_printf(fout, "!no database running, and no database specified\n");
			stream_flush(fout);
			stream_close(fout);
			stream_close(fdin);
			return(newErr("no database running, and no database specified"));
		}
	} else {
		err e = forkMserver(database, &top);
		if (e != NO_ERR) {
			stream_printf(fout, "!internal error while starting a new mserver\n");
			stream_flush(fout);
			stream_close(fout);
			stream_close(fdin);
			return(e);
		}
		stat = top;
	}

	/* need to send a redirect */
	if (stat->conns == NULL || stat->conns->val == NULL) {
		err e = newErr("database %s does not allow connections", stat->dbname);
		stream_printf(fout, "!database %s does not allow connections\n", stat->dbname);
		stream_flush(fout);
		stream_close(fout);
		stream_close(fdin);
		SABAOTHfreeStatus(&top);
		return(e);
	}

	merlog("redirecting client for database %s to %s", stat->dbname, stat->conns->val);

	stream_printf(fout, "^%s%s\n",
			stat->conns->val, stat->dbname);
	/* flush redirect and return */
	stream_flush(fout);
	stream_close(fout);
	stream_close(fdin);

	SABAOTHfreeStatus(&top);
	return(NO_ERR);
}

err
acceptConnections(unsigned short port)
{
	struct sockaddr_in server;
	int sock = -1;

	socklen_t length = 0;
	int on = 1;
	int i = 0;
	unsigned short origport = port;
	char host[512];
	str msg;

	sock = socket(AF_INET, SOCK_STREAM, 0);
	if (sock < 0)
		return(newErr("creation of stream socket failed: %s",
					strerror(errno)));

	/* In auto-sensing mode, start at the default */
	if (origport == 0)
		port = MEROV_PORT;

	setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, (char *) &on, sizeof on);

	server.sin_family = AF_INET;
	server.sin_addr.s_addr = htonl(INADDR_ANY);
	for (i = 0; i < 8; i++)
		server.sin_zero[i] = 0;
	length = (socklen_t) sizeof(server);

	do {
		server.sin_port = htons((unsigned short) ((port) & 0xFFFF));
		if (bind(sock, (SOCKPTR) &server, length) < 0) {
			if (
#ifdef EADDRINUSE
errno == EADDRINUSE &&
#else 
#ifdef WSAEADDRINUSE 
errno == WSAEADDRINUSE &&
#endif
#endif
				origport == 0 && port < 60000) {
				port++;
				continue;
			}
			return(newErr("binding to stream socket port %d failed: %s",
					origport, strerror(errno)));
		} else {
			break;
		}
	} while (1);

	if (getsockname(sock, (SOCKPTR) &server, &length) < 0)
		return(newErr("failed getting socket name: %s",
				strerror(errno)));
	/* keep queue of 5 */
	listen(sock, 5);

	gethostname(host, (int) 512);
	merlog("listening for connections on %s:%d", host, port);

	do {
		int retval;
		struct timeval tv;
		fd_set fds;
		int msgsock;
		err e;

		FD_ZERO(&fds);
		if (sock >= 0)
			FD_SET(sock, &fds);

		/* Wait up to 0.5 seconds. */
		tv.tv_sec = 0;
		tv.tv_usec = 500;

		retval = select(sock + 1, &fds, NULL, NULL, &tv);
		if (retval == 0) {
			/* nothing interesting has happened */
			continue;
		}
		if (retval < 0) {
			if (errno != EINTR) {
				msg = "select failed";
				goto error;
			}
			continue;
		}
		if (sock >= 0 && FD_ISSET(sock, &fds)) {
			if ((msgsock = accept(sock, (SOCKPTR) 0, (socklen_t *) 0)) < 0) {
				if (errno != EINTR) {
					msg = "accept failed";
					goto error;
				}
				continue;
			}
		} else
			continue;
		/* TODO: maybe do this in a thread */
		e = handleClient(msgsock);
		if (e != NO_ERR) {
			merlog("client error: %s", e);
			freeErr(e);
		}
	} while (1);

error:
	return(newErr("accept connection: %s", msg));
}

int
main(int argc, char *argv[])
{
	err e;
	int argp;
	str conf = MONETDBCONFIG;
	str p;
	FILE *cnf = NULL;
	char buf[1024];
	sabdb* stats = NULL;

	merlog("Merovingian %s starting ...", MEROV_VERSION);

	snprintf(buf, 1023, "%s/bin/mserver5", MONETDBPREFIX);
	_merovingian_mserver = strdup(buf);

	snprintf(buf, 1023, "%s%s", MONETDBPREFIX, conf + 9);
	cnf = fopen(buf, "r");
	if (cnf == NULL) {
		merlog("cannot open config file %s", buf);
		exit(1);
	}

	conf = NULL;
	while (fgets(buf, 1023, cnf) != 0) {
		if (*buf && strncmp(buf, "gdk_dbfarm=", 11) == 0) {
			p = strchr(buf, '=');
			conf = strdup(++p);
			break;
		}
	}

	fclose(cnf);

	if (conf == NULL) {
		merlog("cannot find dbfarm via config file");
		exit(1);
	}

	/* unfortunately we have to replace occurences of ${prefix} with
	 * MONETDBPREFIX, which is medieval in this language */
	p = strstr(conf, "${prefix}");
	if (p != NULL) {
		memcpy(buf, conf, p - conf);
		memcpy(buf + (p - conf), MONETDBPREFIX, strlen(MONETDBPREFIX));
		memcpy(buf + (p - conf) + strlen(MONETDBPREFIX), conf + (p - conf) + 9, strlen(conf) - 9 - (p - conf) + 1);
		free(conf);
		conf = strdup(buf);
	}

	merlog("monitoring dbfarm %s", conf);

	SABAOTHinit(conf, NULL);
	free(conf);

	for (argp = 1; argp < argc; argp++) {
		e = forkMserver(argv[argp], &stats);
		if (e != NO_ERR) {
			merlog("failed to fork mserver: %s", e);
			freeErr(e);
		}
		if (stats != NULL)
			SABAOTHfreeStatus(&stats);
	}

	/* handle external connections main loop */
	e = acceptConnections(MEROV_PORT);

	if (e != NO_ERR) {
		merlog("%s", e);
		freeErr(e);
		return(1);
	}

	free(_merovingian_mserver);
	return(0);
}

/* vim:set ts=4 sw=4 noexpandtab: */
