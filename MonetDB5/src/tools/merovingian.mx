@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2007 CWI.
@' All Rights Reserved.

@f merovingian
@a Fabian Groffen
@v 1.0
@* The MonetDB keeper
The role of the Merovingian within the MonetDB suite is to act as a
smart proxy, with capabilities to start Mservers when necessary.

Since some people appear to have troubles pronouncing or remembering its
name, one can also refer to the Merovingian, as Mero, Merov or Nebula.
While the latter one has nothing to do with the former, it is provided
as convenience for those who keep on having technical problems with
pronouncing the former.  In any case, people having difficulties here
should watch the Matrix once more.

Most of the Merovingian's decisions are based on information provided by
Sabaoth.  Sabaoth is a file-system based administration shared between
all Mservers in the same farm on a local machine.  It keeps track of how
Mservers can be reached, with which scenarios, and what the crashcounter
of each server is.

The Merovingian will fork off an Mserver whenever a client requests a
database which is not running yet.  The forked Mserver is detached from
the Merovingian, such that the Mserver can live on, even if the
Merovingian is restarted (or dies).  Sabaoth will deal with the
Merovingian finding the Mservers already running, or forked.

Forking off an Mserver isn't done unconditionally.  The crashlog
information maintained by Sabaoth for a given database is consulted
before each fork.  While Sabaoth itself will make sure that the Mserver
logs a warning upon restart after a crash, Merovingian will refuse to
start an Mserver if it has crashed a number of times during a recent
period.  The Merovingian will log such refusals as well as return this
as error to the connecting client.

@h
#define MEROV_VERSION	"0.2"
#define MEROV_PORT		50000

@c
#include "mal_config.h"
#include "merovingian.h"
#include "mal_sabaoth.h"
#include <stream_socket.h>
#include <stdlib.h> /* exit */
#include <stdarg.h>	/* variadic stuff */
#include <stdio.h> /* fprintf */
#include <sys/types.h>
#ifdef HAVE_SYS_SOCKET_H
#include <sys/socket.h>
#endif
#ifdef HAVE_SYS_UN_H
#include <sys/un.h>
#endif
#ifdef HAVE_NETDB_H
#include <netdb.h>
#include <netinet/in.h>
#endif
#ifdef HAVE_FCNTL_H
#include <fcntl.h>
#endif
#include <unistd.h>
#include <string.h> /* strdup, strerror */
#include <alloca.h>
#include <errno.h>
#ifdef _MSC_VER
#include <process.h>

#define snprintf _snprintf
#define vsnprintf _vsnprintf
#endif

#define SOCKPTR struct sockaddr *
#if HAVE_SOCKLEN_T
#define SOCKLEN socklen_t
#else
#define SOCKLEN int
#endif

typedef char* err;

#define freeErr(X) free(X)
#define getErrMsg(X) X
#define NO_ERR (err)0

static str _merovingian_mserver = NULL;

typedef struct _dpair {
	FILE* fout;
	FILE* ferr;
	pid_t pid;
	char name[24];
	struct _dpair* next;
}* dpair;

static void
logListener(void *p)
{
	dpair d = (dpair)p;
	dpair w;
	FILE *fout, *ferr;
	char buf[8096];

	/* the first entry in the list of d is where our output should go to */
	fout = d->fout;
	ferr = d->ferr;

	/* skip the first entry, we don't care about it in the normal loop */
	d = d->next;

	do {
		w = d;
		while (w != NULL) {
			if (fgets(buf, 8096, w->fout) != NULL) {
				fprintf(fout, "MSG %s[" LLFMT "]: %s",
						w->name, (long long int)w->pid, buf);
			}
			if (fgets(buf, 8096, w->ferr) != NULL) {
				fprintf(ferr, "ERR %s[" LLFMT "]: %s",
						w->name, (long long int)w->pid, buf);
			}
			w = w->next;
		}
		fflush(fout);
		fflush(ferr);
		/* wait a tenth of a second */
		MT_sleep_ms(10);
	} while (1);
}

/**
 * Logs the given string and formatting parameter stuff by writing it to
 * stdout.
 */
static void
merlog(str fmt, ...)
{
	va_list ap;
	char message[4096];
	int len;

	va_start(ap, fmt);

	len = vsnprintf(message, 4095, fmt, ap);
	message[len] = '\0';

	/* trim trailing newlines */
	while (len > 0 && message[--len] == '\n')
		message[len] = '\0';

	fprintf(stdout, "%s\n", message);
	/* flush the stream, it seems that for some reason this is necessary */
	fflush(stdout);

	va_end(ap);
}

/**
 * Creates a new error, allocated with malloc.  The error should be
 * freed using freeErr().
 */
static str
newErr(str fmt, ...)
{
	va_list ap;
	char message[4096];
	str ret;
	int len;

	va_start(ap, fmt);

	len = vsnprintf(message, 4095, fmt, ap);
	message[len] = '\0';

	va_end(ap);

	ret = malloc(sizeof(char) * (len + 1));
	memcpy(ret, message, len + 1);
	return(ret);
}

/**
 * Fork an Mserver and detach.  The forked Mserver is not a child of
 * this process any more after this function.  Hence, no client pid is
 * maintained or returned.  Before forking off, Sabaoth is consulted to
 * see if forking makes sense, or whether it is necessary at all, or
 * forbidden by restart policy. (TODO)
 */
static err
forkMserver(str database, sabdb** stats, dpair dp)
{
#ifdef NATIVE_WIN32
	intptr_t rv = 0;
	/*rv = _spawnv(_P_DETACH, ...); FIXME */ (void) database;
	if (rv == -1) {
		/* forking failed somehow */
		return(newErr(strerror(errno)));
	}
	return(NO_ERR);
#else
	pid_t pid;
	str er;
	int pfdo[2];
	int pfde[2];

	er = SABAOTHgetStatus(stats, database);
	if (er != MAL_SUCCEED) {
		err e = newErr("%s", er);
		GDKfree(er);
		*stats = NULL;
		return(e);
	}

	if (*stats == NULL)
		return(newErr("no such database: %s", database));

	/* Since we ask for a specific database, it should be either there
	 * or not there.  Since we checked the latter case above, it should
	 * just be there, and be the right one.  There also shouldn't be
	 * more than one entries in the list, so we assume we have the right
	 * one here. */

	switch ((*stats)->state) {
		case SABdbRunning:
			merlog("database %s already running", database);
			return(NO_ERR);
		break;
		case SABdbCrashed:
			merlog("database %s has crashed, attempting restart", database);
		break;
		case SABdbInactive:
			merlog("starting database %s", database);
		break;
		default:
			return(newErr("unknown state: %d", (*stats)->state));
	}

	/* create the pipes (filedescriptors) now, such that we and the
	 * child have the same descriptor set */
	if (pipe(pfdo) == -1)
		return(newErr("unable to create pipe: %s", strerror(errno)));
	if (pipe(pfde) == -1)
		return(newErr("unable to create pipe: %s", strerror(errno)));

	pid = fork();
	if (pid == 0) {
		str dbname = alloca(sizeof(char) * 512);

		/* redirect stdout and stderr to a new pair of fds for
		 * logging help */
		close(pfdo[0]);
		dup2(pfdo[1], 1);
		close(pfdo[1]);

		close(pfde[0]);
		dup2(pfde[1], 2);
		close(pfde[1]);

		/* we don't use stdin, neither should mserver ... */
		close(0);

		/* ok, now exec that mserver we want */
		snprintf(dbname, 511, "--dbname=%s", database);
		merlog("executing %s for database %s",
				_merovingian_mserver, dbname);
		execl(_merovingian_mserver, _merovingian_mserver,
				"--set", "daemon=yes",
				dbname,
				"--dbinit=include sql;", /* yes, this IS correct */
				(char *)NULL);
		/* if the exec returns, it is because of a failure */
		fprintf(stderr, "executing failed: %s\n", strerror(errno));
		exit(1);
	} else if (pid > 0) {
		int i;

		/* parent: fine, let's add the pipes for this child */
		while (dp->next != NULL)
			dp = dp->next;
		dp = dp->next = malloc(sizeof(struct _dpair));
		dp->fout = fdopen(pfdo[0], "r");
		fcntl(pfdo[0], F_SETFL, O_NONBLOCK);
		close(pfdo[1]);
		dp->ferr = fdopen(pfde[0], "r");
		fcntl(pfde[0], F_SETFL, O_NONBLOCK);
		close(pfde[1]);
		dp->next = NULL;
		dp->pid = pid;
		snprintf(dp->name, 23, "%s", "mserver5");

		/* wait for the child to open up a communication channel */
		for (i = 0; i < 20; i++) {	/* wait up to 10 seconds */
			/* stats cannot be NULL, as we don't allow starting not
			 * existing databases */
			SABAOTHfreeStatus(stats);
			er = SABAOTHgetStatus(stats, database);
			if (er != MAL_SUCCEED) {
				/* since the client mserver lives its own life anyway,
				 * it's not really a problem we exit here */
				err e = newErr("%s", er);
				GDKfree(er);
				*stats = NULL;
				return(e);
			}
			if ((*stats)->state == SABdbRunning &&
					(*stats)->conns != NULL &&
					(*stats)->conns->val != NULL)
			{
				break;
			}
			MT_sleep_ms(500);
		}
		if (i > 20) {
			/* we've never found a connection */
			switch ((*stats)->state) {
				case SABdbRunning:
					return(newErr(
								"timeout when waiting for database '%s' to "
								"open up a communication channel", database));
				case SABdbCrashed:
					return(newErr(
								"database '%s' has crashed after starting, "
								"manual intervention needed", database));
				case SABdbInactive:
					return(newErr(
								"database '%s' appears to cleanly shut down "
								"itself after starting", database));
				default:
					return(newErr("unknown state: %d", (*stats)->state));
			}
		}

		return(NO_ERR);
	}
	/* forking failed somehow, cleanup the pipes */
	close(pfdo[0]);
	close(pfdo[1]);
	close(pfde[0]);
	close(pfde[1]);
	return(newErr(strerror(errno)));
#endif
}

err
handleClient(int sock, dpair dp)
{
	stream *fdin, *fout;
	bstream *fin;
	str buf = alloca(sizeof(char) * 8096);
	char *user = NULL, *algo = NULL, *passwd = NULL, *lang = NULL;
	char *database = NULL, *s;
	sabdb *top = NULL;
	sabdb *stat = NULL;

	fdin = block_stream(socket_rastream(sock, "read"));
	fout = block_stream(socket_wastream(sock, "write"));

	if (!fdin || !fout) {
		return(newErr("inputstream or outputstream problems"));
	}

	/* note that we claim to speak proto 8 here */
	stream_printf(fout, "%s:merovingian:8:%s:%s",
			"void",  /* some bs */
			"plain", /* FIXME: don't do difficult things for now */
#ifdef WORDS_BIGENDIAN
			"BIG"
#else
			"LIT"
#endif
			);
	stream_flush(fout);
	/* get response */
	stream_read_block(fdin, buf, 8095, 1);

	fin = bstream_create(fdin, 128 * 8096);
	fin->eof = 1;

	/* decode BIG/LIT:user:{cypher}passwordchal:lang:database: line */

	user = buf;
	/* byte order */
	s = strchr(user, ':');
	if (s) {
		*s = 0;
		stream_set_byteorder(fin->s, strcmp(user, "BIG") == 0);
		user = s + 1;
	} else {
		err e = newErr("client challenge error: %s", buf);
		stream_printf(fout, "!incomplete challenge '%s'\n", user);
		stream_flush(fout);
		stream_close(fout);
		stream_close(fdin);
		return(e);
	}

	/* passwd */
	s = strchr(user, ':');
	if (s) {
		*s = 0;
		passwd = s + 1;
		/* decode algorithm, i.e. {plain}mypasswordchallenge */
		if (*passwd != '{') {
			err e = newErr("client challenge error: %s", buf);
			stream_printf(fout, "!invalid password entry\n");
			stream_flush(fout);
			stream_close(fout);
			stream_close(fdin);
			return(e);
		}
		algo = passwd + 1;
		s = strchr(algo, '}');
		if (!s) {
			err e = newErr("client challenge error: %s", buf);
			stream_printf(fout, "!invalid password entry\n");
			stream_flush(fout);
			stream_close(fout);
			stream_close(fdin);
			return(e);
		}
		*s = 0;
		passwd = s + 1;
	} else {
		err e = newErr("client challenge error: %s", buf);
		stream_printf(fout, "!incomplete challenge '%s'\n", user);
		stream_flush(fout);
		stream_close(fout);
		stream_close(fdin);
		return(e);
	}

	/* lang */
	s = strchr(passwd, ':');
	if (s) {
		*s = 0;
		lang = s + 1;
	} else {
		err e = newErr("client challenge error: %s", buf);
		stream_printf(fout, "!incomplete challenge, missing language\n");
		stream_flush(fout);
		stream_close(fout);
		stream_close(fdin);
		return(e);
	}

	/* database */
	s = strchr(lang, ':');
	if (s) {
		*s = 0;
		database = s + 1;
		/* we can have stuff following, make it void */
		s = strchr(database, ':');
		if (s)
			*s = 0;
	}

	if (*database == '\0') {
		/* send a redirect to the "default" database, since we don't
		 * know what "default" is, we can't do much more than
		 * redirecting to the first database which appears to be online. */
		str er = SABAOTHgetStatus(&top, NULL);
		if (er != MAL_SUCCEED) {
			err e = newErr(er);
			GDKfree(er);
			stream_printf(fout, "!internal error, please try again later\n");
			stream_flush(fout);
			stream_close(fout);
			stream_close(fdin);
			return(e);
		}
		stat = top;
		while (stat != NULL) {
			if (stat->state == SABdbRunning) {
				break;
			}
			stat = stat->next;
		}
		if (stat == NULL) {
			SABAOTHfreeStatus(&top);
			stream_printf(fout, "!no database running, and no database specified\n");
			stream_flush(fout);
			stream_close(fout);
			stream_close(fdin);
			return(newErr("no database running, and no database specified"));
		}
	} else {
		err e = forkMserver(database, &top, dp);
		if (e != NO_ERR) {
			if (top == NULL) {
				stream_printf(fout, "!no such database '%s', please create it first\n", database);
			} else {
				stream_printf(fout, "!internal error while starting a new mserver\n");
			}
			stream_flush(fout);
			stream_close(fout);
			stream_close(fdin);
			return(e);
		}
		stat = top;
	}

	/* need to send a redirect */
	if (stat->conns == NULL || stat->conns->val == NULL) {
		err e = newErr("database %s does not allow connections", stat->dbname);
		stream_printf(fout, "!database %s does not allow connections\n", stat->dbname);
		stream_flush(fout);
		stream_close(fout);
		stream_close(fdin);
		SABAOTHfreeStatus(&top);
		return(e);
	}

	merlog("redirecting client for database %s to %s",
			stat->dbname, stat->conns->val);

	stream_printf(fout, "^%s%s\n",
			stat->conns->val, stat->dbname);
	/* flush redirect and return */
	stream_flush(fout);
	stream_close(fout);
	stream_close(fdin);

	SABAOTHfreeStatus(&top);
	return(NO_ERR);
}

err
acceptConnections(unsigned short port, dpair dp)
{
	struct sockaddr_in server;
	int sock = -1;

	socklen_t length = 0;
	int on = 1;
	int i = 0;
	unsigned short origport = port;
	char host[512];
	str msg;

	sock = socket(AF_INET, SOCK_STREAM, 0);
	if (sock < 0)
		return(newErr("creation of stream socket failed: %s",
					strerror(errno)));

	/* In auto-sensing mode, start at the default */
	if (origport == 0)
		port = MEROV_PORT;

	setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, (char *) &on, sizeof on);

	server.sin_family = AF_INET;
	server.sin_addr.s_addr = htonl(INADDR_ANY);
	for (i = 0; i < 8; i++)
		server.sin_zero[i] = 0;
	length = (socklen_t) sizeof(server);

	do {
		server.sin_port = htons((unsigned short) ((port) & 0xFFFF));
		if (bind(sock, (SOCKPTR) &server, length) < 0) {
			if (
#ifdef EADDRINUSE
errno == EADDRINUSE &&
#else 
#ifdef WSAEADDRINUSE 
errno == WSAEADDRINUSE &&
#endif
#endif
				origport == 0 && port < 60000) {
				port++;
				continue;
			}
			return(newErr("binding to stream socket port %d failed: %s",
					origport, strerror(errno)));
		} else {
			break;
		}
	} while (1);

	if (getsockname(sock, (SOCKPTR) &server, &length) < 0)
		return(newErr("failed getting socket name: %s",
				strerror(errno)));
	/* keep queue of 5 */
	listen(sock, 5);

	gethostname(host, (int) 512);
	merlog("listening for connections on %s:%d", host, port);

	do {
		int retval;
		struct timeval tv;
		fd_set fds;
		int msgsock;
		err e;

		FD_ZERO(&fds);
		if (sock >= 0)
			FD_SET(sock, &fds);

		/* Wait up to 0.5 seconds. */
		tv.tv_sec = 0;
		tv.tv_usec = 500;

		retval = select(sock + 1, &fds, NULL, NULL, &tv);
		if (retval == 0) {
			/* nothing interesting has happened */
			continue;
		}
		if (retval < 0) {
			if (errno != EINTR) {
				msg = "select failed";
				goto error;
			}
			continue;
		}
		if (sock >= 0 && FD_ISSET(sock, &fds)) {
			if ((msgsock = accept(sock, (SOCKPTR) 0, (socklen_t *) 0)) < 0) {
				if (errno != EINTR) {
					msg = "accept failed";
					goto error;
				}
				continue;
			}
		} else
			continue;
		/* TODO: maybe do this in a thread */
		e = handleClient(msgsock, dp);
		if (e != NO_ERR) {
			fprintf(stderr, "client error: %s\n", getErrMsg(e));
			freeErr(e);
		}
	} while (1);

error:
	return(newErr("accept connection: %s", msg));
}

static str
replacePrefix(str s)
{
	str p;
	str buf;

	/* unfortunately we have to replace occurences of ${prefix} with
	 * MONETDBPREFIX, which is medieval in this language */
	p = strstr(s, "${prefix}");
	if (p != NULL) {
		buf = malloc(sizeof(char) * (strlen(s) + strlen(MONETDBPREFIX) + 1));
		memcpy(buf, s, p - s);
		memcpy(buf + (p - s), MONETDBPREFIX, strlen(MONETDBPREFIX));
		memcpy(buf + (p - s) + strlen(MONETDBPREFIX), s + (p - s) + 9, strlen(s) - 9 - (p - s) + 1);
		return(strdup(buf));
	} else {
		return(strdup(s));
	}
}

int
main(int argc, char *argv[])
{
	err e;
	int argp;
	str conf = MONETDBCONFIG;
	str dbfarm, msglog, errlog;
	str p;
	FILE *cnf = NULL;
	char buf[1024];
	sabdb* stats = NULL;
	MT_Id tid;
	dpair d, q = alloca(sizeof(struct _dpair));
	int pfd[2];

	/* hunt for the config file, and read it */
	snprintf(buf, 1023, "%s/bin/mserver5", MONETDBPREFIX);
	_merovingian_mserver = alloca(sizeof(char) * (strlen(buf) + 1));
	memcpy(_merovingian_mserver, buf, strlen(buf) + 1);

	snprintf(buf, 1023, "%s%s", MONETDBPREFIX, conf + 9);
	cnf = fopen(buf, "r");
	if (cnf == NULL) {
		fprintf(stderr, "cannot open config file %s\n", buf);
		exit(1);
	}

	dbfarm = NULL;
	msglog = NULL;
	errlog = NULL;
	while (fgets(buf, 1024, cnf) != NULL) {
		/* eliminate fgets' newline */
		buf[strlen(buf) - 1] = '\0';
		if (*buf && strncmp(buf, "gdk_dbfarm=", 11) == 0) {
			p = strchr(buf, '=');
			dbfarm = replacePrefix(++p);
		} else if (*buf && strncmp(buf, "mero_msglog=", 12) == 0) {
			p = strchr(buf, '=');
			msglog = replacePrefix(++p);
		} else if (*buf && strncmp(buf, "mero_errlog=", 12) == 0) {
			p = strchr(buf, '=');
			errlog = replacePrefix(++p);
		}
	}

	fclose(cnf);

	if (dbfarm == NULL) {
		fprintf(stderr, "cannot find dbfarm via config file\n");
		exit(1);
	}

	/* where should our msg output go to? */
	if (msglog == NULL) {
		/* stdout, save it */
		argp = dup(1);
		q->fout = fdopen(argp, "w");
	} else {
		/* write to the given file */
		q->fout = fopen(msglog, "a");
		if (q->fout == NULL) {
			fprintf(stderr, "unable to open '%s': %s\n",
					msglog, strerror(errno));
			exit(1);
		}
	}
	free(msglog);

	/* where should our err output go to? */
	if (errlog == NULL) {
		/* stderr, save it */
		argp = dup(2);
		q->ferr = fdopen(argp, "w");
	} else {
		/* write to the given file */
		if (strcmp(msglog, errlog) == 0) {
			q->ferr = q->fout;
		} else {
			q->ferr = fopen(errlog, "a");
			if (q->ferr == NULL) {
				fprintf(stderr, "unable to open '%s': %s\n",
						errlog, strerror(errno));
				exit(1);
			}
		}
	}
	free(errlog);

	/* store the structure */
	q->pid = 0;
	snprintf(q->name, 23, "output");
	d = q->next = alloca(sizeof(struct _dpair));

	/* redirect stdout */
	if (pipe(pfd) == -1) {
		fprintf(stderr, "%s: unable to create pipe: %s\n",
				argv[0], strerror(errno));
		return(1);
	}
	d->fout = fdopen(pfd[0], "r");
	fcntl(pfd[0], F_SETFL, O_NONBLOCK);
	dup2(pfd[1], 1);
	close(pfd[1]);

	/* redirect stderr */
	if (pipe(pfd) == -1) {
		fprintf(stderr, "%s: unable to create pipe: %s\n",
				argv[0], strerror(errno));
		return(1);
	}
	d->ferr = fdopen(pfd[0], "r");
	fcntl(pfd[0], F_SETFL, O_NONBLOCK);
	dup2(pfd[1], 2);
	close(pfd[1]);

	d->next = NULL;
	d->pid = getpid();
	snprintf(d->name, 23, "%s", "merovingian");

	if (MT_create_thread(&tid, logListener, (void *)q) < 0) {
		fprintf(q->ferr, "%s: unable to create logthread, exiting\n", argv[0]);
		return(1);
	}

	merlog("Merovingian %s starting ...", MEROV_VERSION);
	merlog("monitoring dbfarm %s", dbfarm);

	SABAOTHinit(dbfarm, NULL);
	free(dbfarm);

	for (argp = 1; argp < argc; argp++) {
		e = forkMserver(argv[argp], &stats, d);
		if (e != NO_ERR) {
			fprintf(stderr, "failed to fork mserver: %s\n", getErrMsg(e));
			freeErr(e);
		}
		if (stats != NULL)
			SABAOTHfreeStatus(&stats);
	}

	/* handle external connections main loop */
	e = acceptConnections(MEROV_PORT, d);

	if (e != NO_ERR) {
		fprintf(stderr, "%s\n", e);
		freeErr(e);
		return(1);
	}

	free(_merovingian_mserver);
	return(0);
}

/* vim:set ts=4 sw=4 noexpandtab: */
