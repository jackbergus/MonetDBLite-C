@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2006 CWI.
@' All Rights Reserved.

@f merovingian
@a Fabian Groffen
@v 1.0
@* The MonetDB keeper
The role of the Merovingian within the MonetDB suite is to act as a
smart proxy, with capabilities to start Mservers when necessary.

Since some people appear to have troubles pronouncing or remembering its
name, one can also refer to the Merovingian, as Mero, Merov or Nebula.
While the latter one has nothing to do with the former, it is provided
as convenience for those who keep on having technical problems with
pronouncing the former.

Most of the Merovingian's decisions are based on information provided by
Sabaoth.  Sabaoth is a file-system based administration shared between
all Mservers in the same farm on a local machine.  It keeps track of how
Mservers can be reached, with which scenarios, and what the crashcounter
of each server is.

The Merovingian will fork off an Mserver whenever a client requests a
database which is not running yet.  The forked Mserver is detached from
the Merovingian, such that the Mserver can live on, even if the
Merovingian is restarted (or dies).  Sabaoth will deal with the
Merovingian finding the Mservers already running, or forked.

Forking off an Mserver isn't done unconditionally.  The crashlog
information maintained by Sabaoth for a given database is consulted
before each fork.  While Sabaoth itself will make sure that the Mserver
logs a warning upon restart after a crash, Merovingian will refuse to
start an Mserver if it has crashed a number of times during a recent
period.  The Merovingian will log such refusals as well as return this
as error to the connecting client.

@h
#define MEROV_VERSION "0.1 (pre-release)"

@c
#include "merovingian.h"
/*#include "mal_sabaoth.h"*/
#include <stdlib.h> /* exit */
#include <stdarg.h>	/* variadic stuff */
#include <stdio.h> /* fprintf */
#include <sys/types.h>
#include <unistd.h>
#include <string.h> /* strdup, strerror */
#include <errno.h>

typedef char* str;
typedef char* err;

#define freeErr(X) free(X)
#define getErrMsg(X) X
#define NO_ERR (err)0

static size_t _merovingian_log_cnt = 0;

/**
 * Tries to log the given string and formatting parameter stuff.  This
 * function may decide how to log it, e.g. syslog, it's own logfile or
 * stderr.
 *
 * Currently this method just spits everything it gets to stderr.
 */
static void
merlog(str fmt, ...)
{
	va_list ap;
	char message[4096];
	int len;

	va_start(ap, fmt);

	len = snprintf(message, 4095, "[merovingian]:%lld ", (long long int)_merovingian_log_cnt++);
	len += vsnprintf(message + len, 4095 - len, fmt, ap);
	message[len] = '\0';

	/* trim trailing newlines */
	while (len > 0 && message[--len] == '\n')
		message[len] = '\0';

	fprintf(stderr, "%s\n", message);

	va_end(ap);
}

static str
newErr(str fmt, ...)
{
	va_list ap;
	char message[4096];
	str ret;
	int len;

	va_start(ap, fmt);

	len = vsnprintf(message, 4095, fmt, ap);
	message[len] = '\0';

	va_end(ap);

	ret = malloc(sizeof(char) * (len + 1));
	memcpy(ret, message, len + 1);
	return(ret);
}

/**
 * Fork an Mserver and detach.  The forked Mserver is not a child of
 * this process any more after this function.  Hence, no client pid is
 * maintained or returned.
 */
static err
forkMserver(str database)
{
	pid_t pid;

	pid = fork();
	if (pid == 0) {
		/* child: refork again, such that this child can die, and the
		 * childchild becomes an orphan which init cares for */
		pid = fork();
		if (pid == 0) {
			/* ok, now exec that Mserver we want */
			/*execv(.... mserver --dbname=%s, databse);  FIXME */
			merlog("todo: %s", database);
			return(NO_ERR);
		} else if (pid > 0) {
			/* we are the parent of the childchild, so let's die */
			exit(0);
		} else {
			/* bleh... forking failed :( nothing we can do but log */
			merlog("Forking sub-child failed, no Mserver spawned!");
			exit(1);
		}
	} else if (pid > 0) {
		/* parent: fine, we're done */
		return(NO_ERR);
	} else {
		/* forking failed somehow */
		return(newErr(strerror(errno)));
	}
}

int main(int argc, char *argv[]) {
	merlog("Merovingian %s starting ...", MEROV_VERSION);

	if (argc > 1) {
		forkMserver(argv[1]);
	}
}

/* vim:set ts=4 sw=4 noexpandtab: */
