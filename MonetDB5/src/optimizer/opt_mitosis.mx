@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
@' Copyright August 2008-2009 MonetDB B.V.
@' All Rights Reserved.

@f opt_mitosis
@a M. Kersten
@- Mitosis
The SQL plans are produced without knowledge of possible 
benefits of parallel execution. It is the task of the mitosis
optimizer to detect interesting cases and prepare the plan 
where a large table is broken into identical pieces.

There are two main directions to consider for mitosis.
The first concerns parallel execution on a single machine using all the cores
available. The second concerns using an MPP solution, where
part of the plan is executed at remote sites.

The former problem is addressed here. 
It inspects the plan for SQL bind statements and localises
the largest table involved. This table becomes the target
for cheap partitioning based on the OID ranges.
The pieces are conceptually glued together using a MAT structure
and the mergetable optimizer expands the plan to be run.
The effect of this step can be a sizeable MAL program.

To avoid a program based on too small pieces,
we issue a low-water mark. Its value should be
preferrably dynamically identified. Experiments will tell
us hopefully in the future.

This optimizer should be called early in the
optimizer pipeline, before the mergetable optimizer.
@{
@mal
pattern optimizer.mitosis():str
address OPTmitosis;
pattern optimizer.mitosis(mod:str, fcn:str):str
address OPTmitosis
comment "Modify the plan to exploit parallel processing on multiple cores";

@h
#ifndef _OPT_MITOSIS_
#define _OPT_MITOSIS_
#include "opt_prelude.h"
#include "opt_support.h"

/*#define _DEBUG_OPT_MITOSIS*/
#define PARTITION_THRESHOLD (BUN) GDKnr_threads

@c
#include "mal_config.h"
#include "opt_mitosis.h"
#include "mal_interpreter.h"

static int
OPTmitosisImplementation(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	int i, j, k, limit, estimate=0, tpe, pieces=1;
	str schema=0, table=0;
	VarRecord low,hgh;
	oid slice;
	BUN r=0,rowcnt=0;	/* table should be sizeable to consider parallel execution*/
	InstrPtr q,*old;
	VarPtr v;
	int *parts=0;

	(void)cntxt;
	(void) stk;
	
	/* locate the largest table */
	for (i=1; i< mb->stop; i++){
		q= getInstrPtr(mb,i);
		if (getModuleId(q)!= sqlRef || 
				!(getFunctionId(q)==bindRef ||
				  getFunctionId(q)==bindidxRef ))
			continue;
@-
The SQL optimizer already collects the counts of the
base table and passes them on as a row property.
@c
		v= varGetProp(mb, getArg(q,0), rowsProp);
		if (v && v->value.val.lval >= 0
#if SIZEOF_BUN <= SIZEOF_INT
		    && v->value.val.lval <= BUN_MAX
#endif
		   )
			r= (BUN) v->value.val.lval;
			if (r >= rowcnt && r > PARTITION_THRESHOLD){
				schema = getVarConstant(mb, getArg(q,1)).val.sval;
				table = getVarConstant(mb, getArg(q,2)).val.sval;
				rowcnt = r;
				estimate++;
				r = 0;
			}
		}
@-
The number of pieces should be based on the footprint of the queryplan,
such that preferrably it can be handled without swapping intermediates.
For the time being we just go for small pieces compared to memory
spread evenly over the threads and the common type.
@c
	r= (BUN) (GDKmem_inuse() /2/sizeof(oid)/GDKnr_threads); /* how much fits  */
	if (rowcnt >r )
		pieces = (int) (rowcnt /r+1);
	if (pieces < GDKnr_threads && rowcnt >PARTITION_THRESHOLD)
		pieces = GDKnr_threads;
	if (pieces >128)
		pieces = 128; /* cut off potential plan explosion */

	if (schema == 0 || (size_t) rowcnt < (size_t) pieces || pieces <=1)
		return 0;
	OPTDEBUG
		stream_printf(cntxt->fdout,"#opt_mitosis: target is %s.%s "
			"on %d threads %d pieces\n",
			schema,table,GDKnr_threads,pieces);
#ifdef _DEBUG_OPT_MITOSIS
		printFunction(cntxt->fdout,mb,0,LIST_MAL_ALL);
#endif

	/* inject the MAT versions for the largest table */
	parts= (int*) GDKmalloc(sizeof(int)* pieces);

	old = mb->stmt;
	limit= mb->stop;
	newMalBlkStmt(mb,mb->ssize + 2* estimate);
	estimate=0;

	for(i=0;i<limit;i++){
		p= old[i];
		if (getModuleId(p)!= sqlRef || 
		  !(getFunctionId(p)==bindRef || getFunctionId(p)==bindidxRef)){
			pushInstruction(mb,p);
			continue;
		}
		/* don't split inserts or updates */
		if (getVarConstant(mb, getArg(p,4)).val.ival == 1 ||
		    getVarConstant(mb, getArg(p,4)).val.ival == 2) {
			pushInstruction(mb,p);
			continue;
		}
		
		if (strcmp(schema, getVarConstant(mb, getArg(p,1)).val.sval) ||
		    strcmp(table, getVarConstant(mb, getArg(p,2)).val.sval) ){
			pushInstruction(mb,p);
			continue;
		}
		k= getArg(p,0);
		getArg(p,0)= newTmpVariable(mb, tpe=getArgType(mb,p,0));
		setVarUsed(mb,getArg(p,0));
		pushInstruction(mb,p);

		q= newStmt(mb,batRef,partitionRef);
		q->argc=0;
		slice= (BUN) (rowcnt/pieces);
		hgh.value.vtype= low.value.vtype= TYPE_oid;
		low.value.val.oval= 0;
		for(j=0; j < pieces; j++){
			if (j+1 < pieces)
				hgh.value.val.oval= low.value.val.oval+slice;
			else
				hgh.value.val.oval= (oid) rowcnt;

			parts[j]= newTmpVariable(mb,tpe);
			setVarUsed(mb,parts[j]);
			q= pushArgument(mb,q, parts[j]);
			if (getFunctionId(p) == binddbatRef) {
				varSetProp(mb, getArg(q,j), PropertyIndex("tlb"), op_gte, (ptr) &low.value);
				varSetProp(mb, getArg(q,j), PropertyIndex("tub"), op_lt, (ptr) &hgh.value);
			} else {
				varSetProp(mb, getArg(q,j), PropertyIndex("hlb"), op_gte, (ptr) &low.value);
				varSetProp(mb, getArg(q,j), PropertyIndex("hub"), op_lt, (ptr) &hgh.value);
			}
			low.value.val.oval += slice;
		}
		q->retc= q->argc;
		q= pushArgument(mb,q, getArg(p,0));

		p= newStmt(mb,matRef,newRef);
		getArg(p,0)=k;
		setVarUDFtype(mb,k);
		for(j=0; j<GDKnr_threads; j++)
			p= pushArgument(mb,p,parts[j]);
	}
#ifdef _DEBUG_OPT_MITOSIS
	printFunction(cntxt->fdout,mb,0,LIST_MAL_ALL);
#endif
	GDKfree(parts);
	return 1;
}
@include optimizerWrapper.mx
@h
@:exportOptimizer(mitosis)@
#endif
@c
#include "opt_statistics.h"
@:wrapOptimizer(mitosis,OPT_CHECK_ALL)@
@}
