@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
@' Copyright August 2008-2010 MonetDB B.V.
@' All Rights Reserved.

@f opt_mitosis
@a M. Kersten
@- Mitosis
The SQL plans are produced without knowledge of possible 
benefits of parallel execution. It is the task of the mitosis
optimizer to detect interesting cases and prepare the plan 
where a large table is broken into pieces.

There are two main directions to consider for mitosis.
The first concerns parallel execution on a single machine using all the cores
available. The second concerns using an MPP solution, where
part of the plan is executed at remote sites.

The former problem is addressed here. 
It inspects the plan for SQL bind statements and localises
the largest table involved. This table becomes the target
for cheap partitioning based on the OID ranges.
The pieces are conceptually glued together using a MAT structure
and the mergetable optimizer expands the plan to be run.
The effect of this step can be a sizeable MAL program.

To avoid a program based on too small pieces,
we issue a low-water mark. Its value should be
preferrably dynamically identified. Experiments will tell
us hopefully in the future.

This optimizer should be called early in the
optimizer pipeline, before the mergetable optimizer.
@{
@mal
pattern optimizer.mitosis():str
address OPTmitosis;
pattern optimizer.mitosis(mod:str, fcn:str):str
address OPTmitosis
comment "Modify the plan to exploit parallel processing on multiple cores";

@h
#ifndef _OPT_MITOSIS_
#define _OPT_MITOSIS_
#include "opt_prelude.h"
#include "opt_support.h"

@c
#include "mal_config.h"
#include "opt_mitosis.h"
#include "opt_octopus.h"
#include "mal_interpreter.h"

/* #define _DEBUG_OPT_MITOSIS*/
#define PARTITION_THRESHOLD (BUN) GDKnr_threads	/* should be increased in production version */

static int
OPTmitosisImplementation(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	int i, j, k, limit, estimate=0, tpe, pieces=1;
	str schema=0, table=0;
	VarRecord low,hgh;
	oid slice;
	BUN r=0,rowcnt=0;	/* table should be sizeable to consider parallel execution*/
	InstrPtr q,*old, target= 0, matq;
	VarPtr v;
	size_t typewidth= 3 *sizeof(TYPE_oid); /* 2 arguments and a result */

	(void)cntxt;
	(void) stk;
	
	/* locate the largest non-partitioned table */
	for (i=1; i< mb->stop; i++){
		q= getInstrPtr(mb,i);
		if (getModuleId(q)!= sqlRef || getFunctionId(q)!=bindRef )
			continue;
		/* don't split insert or update BATs */
		if (getVarConstant(mb, getArg(q,5)).val.ival != 0 )
			continue;
		if( q->argc > 6 )
			continue; /* already partitioned */
@-
The SQL optimizer already collects the counts of the
base table and passes them on as a row property.
All pieces for a single subplan should ideally fit together.
@c
		v= varGetProp(mb, getArg(q,0), rowsProp);
		if (v && v->value.val.lval >= 0
#if SIZEOF_BUN <= SIZEOF_INT
		    && v->value.val.lval <= BUN_MAX
#endif
		   )
			r= (BUN) v->value.val.lval;
			if (r >= rowcnt && r > PARTITION_THRESHOLD){
				rowcnt = r;
				target = q;
				estimate++;
				r = 0;
			}
		}
	if (target == 0)
		return 0;
@-
The number of pieces should be based on the footprint of the queryplan,
such that preferrably it can be handled without swapping intermediates.
For the time being we just go for small pieces compared to memory detected upon start.
A fictive rowcount is derived based on TYPE_lng, such that all pieces
would fit into memory conveniently for processing. We attempt to use
at least all threads.
Experience shows that the pieces should not be too small.
To keep the threads working, we create more pieces then threads.

The pieces to be used may be overruled by the octopus optimizer.
@c
	if ( (i = OPTlegAdviceInternal(mb,stk,p)) )
		pieces = i;
	else {
		r= (BUN) (monet_memory /typewidth/GDKnr_threads); /* how much fits  */
		if (rowcnt > r )
			pieces = (int) (rowcnt /r+1);
		if (pieces < GDKnr_threads )
			pieces = GDKnr_threads;
		if (pieces > 256)
			pieces = 256; /* cut off potential plan explosion */

		if ( (size_t) rowcnt < (size_t) pieces || pieces <=1)
			return 0;
	}
	OPTDEBUG
		stream_printf(cntxt->fdout,"#opt_mitosis: target is %s.%s "
			" with " BUNFMT " rows into " BUNFMT " rows/piece %d threads %d pieces\n",
				getVarConstant(mb, getArg(target,2)).val.sval,
				getVarConstant(mb, getArg(target,3)).val.sval,
				rowcnt, r, GDKnr_threads,pieces);
#ifdef _DEBUG_OPT_MITOSIS
		printFunction(cntxt->fdout,mb,0,LIST_MAL_ALL);
#endif

	old = mb->stmt;
	limit= mb->stop;
	if ( newMalBlkStmt(mb,mb->ssize + 2* estimate) < 0 )
		return 0;
	estimate=0;

	schema = getVarConstant(mb, getArg(target,2)).val.sval;
	table = getVarConstant(mb, getArg(target,3)).val.sval;
	for(i=0;i<limit;i++){
		p= old[i];

		if (getModuleId(p)!= sqlRef || 
			!(getFunctionId(p)==bindRef ||
			  getFunctionId(p)==bindidxRef )){
			pushInstruction(mb,p);
			continue;
		}
		/* don't split insert or update BATs */
		if (getVarConstant(mb, getArg(p,5)).val.ival != 0 ){
			pushInstruction(mb,p);
			continue;
		}
		/* Don't split the (index) bat if we already have identified a range */
		/* This will happen if we inline separately optimized routines */
		if ( p->argc != 6 ){
			pushInstruction(mb,p);
			continue;
		}
		if (strcmp(schema, getVarConstant(mb, getArg(p,2)).val.sval) ||
		    strcmp(table, getVarConstant(mb, getArg(p,3)).val.sval)){
			pushInstruction(mb,p);
			continue;
		}
		/* we keep the original bind operation, because it allows
			for easy undo when the mergtable can not do something
		*/
		pushInstruction(mb,p);
		
		slice= (BUN) (rowcnt/pieces);
		hgh.value.vtype= low.value.vtype= TYPE_oid;
		low.value.val.oval= 0;
		tpe = getVarType(mb,getArg(p,0));

		matq= newInstruction(NULL,ASSIGNsymbol);
		setModuleId(matq,matRef);
		setFunctionId(matq,newRef);
		getArg(matq,0)= getArg(p,0);

		for(j=0; j < pieces; j++){
			q= copyInstruction(p);
			q= pushOid(mb,q,low.value.val.oval);
			if (j+1 < pieces){
				hgh.value.val.oval= low.value.val.oval+slice;
				q= pushOid(mb,q,hgh.value.val.oval);
			} else
				q= pushNil(mb,q, TYPE_oid);

			k= getArg(q,0)= newTmpVariable(mb,tpe);
			setVarUDFtype(mb,k);
			setVarUsed(mb,k);
			if (getFunctionId(p) == binddbatRef) {
				varSetProp(mb, k, PropertyIndex("tlb"), op_gte, (ptr) &low.value);
				varSetProp(mb, k, PropertyIndex("tub"), op_lt, (ptr) &hgh.value);
			} else {
				varSetProp(mb, k, PropertyIndex("hlb"), op_gte, (ptr) &low.value);
				varSetProp(mb, k, PropertyIndex("hub"), op_lt, (ptr) &hgh.value);
			}
			low.value.val.oval += slice;
			pushInstruction(mb,q);
			matq= pushArgument(mb,matq,k);
		}
		pushInstruction(mb,matq);
	}
#ifdef _DEBUG_OPT_MITOSIS
	stream_printf(cntxt->fdout,"DONE MITOSIS\n");
	printFunction(cntxt->fdout,mb,0,LIST_MAL_STMT);
#endif
	return 1;
}
@include optimizerWrapper.mx
@h
@:exportOptimizer(mitosis)@
#endif
@c
#include "opt_statistics.h"
@:wrapOptimizer(mitosis,OPT_CHECK_ALL)@
@}
