@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2008 CWI.
@' All Rights Reserved.

@f opt_mitosis
@a M. Kersten
@- Mitosis
The SQL plans are produced without knowledge of possible 
benefits of parallel execution. It is the task of the mitosis
optimizer to detect interesting cases and prepare the plan 
where a large table is broken into identical pieces.

There are two main direction to consider for mitosis.
The first concerns parallel execution on a single machine using all the cores
available. The second concerns using an MPP solution, where
part of the plan is executed at remote sites.

The former problem is addressed here. 
It inspects the plan for SQL bind statements and localises
the largest table involved. This table becomes the target
for cheap partitioning based on the OID ranges.
The pieces are conceptually glued together using a MAT structure
and the mergetable optimizer expands the plan to be run.
The effect of this step can be a sizeable MAL program.

To avoid a program based on too small pieces,
we issue a low-water mark. Its value should be
preferrably dynamically identified. Experiments will tell
us hopefully in the future.

This optimizer should be called early in the
optimizer pipeline, before the mergetable optimizer.
@{
@mal
pattern optimizer.mitosis():str
address OPTmitosis;
pattern optimizer.mitosis(mod:str, fcn:str):str
address OPTmitosis
comment "Modify the plan to exploit parallel processing on multiple cores";

@h
#ifndef _OPT_MITOSIS_
#define _OPT_MITOSIS_
#include "opt_prelude.h"
#include "opt_support.h"

/*#define _DEBUG_OPT_MITOSIS*/

@c
#include "mal_config.h"
#include "opt_mitosis.h"
#include "mal_interpreter.h"

static int
OPTmitosisImplementation(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	int i,j,k, limit, estimate=0, tpe;
	str schema=0, table=0;
	VarRecord low,hgh;
	oid slice;
	BUN r=0,rowcnt=0;	/* table should be sizeable to consider parallel execution*/
	InstrPtr q,*old;
	VarPtr v;
	int *parts= (int*) alloca(sizeof(int)* GDKnr_threads);

	(void)cntxt;
	(void) stk;
	
	if (GDKnr_threads <= 1)
		return 0;

	/* locate the largest table */
	for (i=1; i< mb->stop; i++){
		q= getInstrPtr(mb,i);
		if (getModuleId(q)!= sqlRef || 
				!(getFunctionId(q)==bindRef ||
				  getFunctionId(q)==bindidxRef ))
			continue;
		v= varGetProp(mb, getArg(q,0), rowsProp);
		if (v && v->value.val.lval >= 0
#if SIZEOF_BUN <= SIZEOF_INT
		    && v->value.val.lval <= BUN_MAX
#endif
		   )
			r= (BUN) v->value.val.lval;
		if (r >= rowcnt){
			schema = getVarConstant(mb, getArg(q,1)).val.sval;
			table = getVarConstant(mb, getArg(q,2)).val.sval;
			rowcnt = r;
			estimate++;
			r = 0;
		}
	}

	if (schema == 0 || (size_t) rowcnt < (size_t) GDKnr_threads)
		return 0;
#ifdef _DEBUG_OPT_MITOSIS
	stream_printf(cntxt->fdout,"opt_mitosis: target is %s.%s on %d threads\n",
		schema,table,GDKnr_threads);
		printFunction(cntxt->fdout,mb,0,LIST_MAL_DEBUG);
#endif
	/* inject the MAT versions for the largest table */

	old = mb->stmt;
	limit= mb->stop;
	newMalBlkStmt(mb,mb->ssize + 2* estimate);
	estimate=0;

	for(i=0;i<limit;i++){
		p= old[i];
		if (getModuleId(p)!= sqlRef || 
				!(getFunctionId(p)==bindRef ||
				  getFunctionId(p)==bindidxRef )){
			pushInstruction(mb,p);
			continue;
		}
		/* don't split inserts */
		if (getVarConstant(mb, getArg(p,4)).val.ival == 1){
			pushInstruction(mb,p);
			continue;
		}
		
		if (strcmp(schema, getVarConstant(mb, getArg(p,1)).val.sval) ||
			strcmp(table, getVarConstant(mb, getArg(p,2)).val.sval) ){
			pushInstruction(mb,p);
			continue;
		}
		k= getArg(p,0);
		getArg(p,0)= newTmpVariable(mb, tpe=getArgType(mb,p,0));
		setVarUsed(mb,getArg(p,0));
		pushInstruction(mb,p);

		q= newStmt(mb,batRef,partitionRef);
		q->argc=0;
		slice= (BUN) (rowcnt/GDKnr_threads);
		hgh.value.vtype= low.value.vtype= TYPE_oid;
		low.value.val.oval= 0;
		for(j=0;j<GDKnr_threads;j++){
			if (j+1<GDKnr_threads)
				hgh.value.val.oval= low.value.val.oval+slice;
			else
				hgh.value.val.oval= (oid) rowcnt;

			parts[j]= newTmpVariable(mb,tpe);
			setVarUsed(mb,parts[j]);
			q= pushArgument(mb,q, parts[j]);
			if (getFunctionId(p) == binddbatRef) {
				varSetProp(mb, getArg(q,j), PropertyIndex("tlb"), op_gte, (ptr) &low.value);
				varSetProp(mb, getArg(q,j), PropertyIndex("tub"), op_lt, (ptr) &hgh.value);
			} else {
				varSetProp(mb, getArg(q,j), PropertyIndex("hlb"), op_gte, (ptr) &low.value);
				varSetProp(mb, getArg(q,j), PropertyIndex("hub"), op_lt, (ptr) &hgh.value);
			}
			low.value.val.oval += slice;
		}
		q->retc= q->argc;
		q= pushArgument(mb,q, getArg(p,0));

		p= newStmt(mb,matRef,"new");
		getArg(p,0)=k;
		for(j=0; j<GDKnr_threads; j++)
			p= pushArgument(mb,p,parts[j]);
	}
#ifdef _DEBUG_OPT_MITOSIS
	printFunction(cntxt->fdout,mb,0,LIST_MAL_DEBUG);
#endif
	return 1;
}
@include optimizerWrapper.mx
@h
@:exportOptimizer(mitosis)@
#endif
@c
#include "opt_statistics.h"
@:wrapOptimizer(mitosis,OPT_CHECK_ALL)@
@}
