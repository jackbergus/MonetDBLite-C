@/
The contents of this file are subject to the MonetDB Public License
Version 1.1 (the "License"); you may not use this file except in
compliance with the License. You may obtain a copy of the License at
http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html

Software distributed under the License is distributed on an "AS IS"
basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations
under the License.

The Original Code is the MonetDB Database System.

The Initial Developer of the Original Code is CWI.
Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
Copyright August 2008-2010 MonetDB B.V.
All Rights Reserved.
@

@f opt_mitosis
@a M. Kersten
@- Mitosis
The SQL plans are produced without knowledge of possible 
benefits of parallel execution. It is the task of the mitosis
optimizer to detect interesting cases and prepare the plan 
where a large table is broken into pieces.

There are two main directions to consider for mitosis.
The first concerns parallel execution on a single machine using all the cores
available. The second concerns using an MPP solution, where
part of the plan is executed at remote sites.

The former problem is addressed here. 
It inspects the plan for SQL bind statements and localises
the largest table involved. This table becomes the target
for cheap partitioning based on the OID ranges.
The pieces are conceptually glued together using a MAT structure
and the mergetable optimizer expands the plan to be run.
The effect of this step can be a sizeable MAL program.

To avoid a program based on too small pieces,
we issue a low-water mark. Its value should be
preferrably dynamically identified. Experiments will tell
us hopefully in the future.

This optimizer should be called early in the
optimizer pipeline, before the mergetable optimizer.
@{
@mal
pattern optimizer.mitosis():str
address OPTmitosis;
pattern optimizer.mitosis(mod:str, fcn:str):str
address OPTmitosis
comment "Modify the plan to exploit parallel processing on multiple cores";

@h
#ifndef _OPT_MITOSIS_
#define _OPT_MITOSIS_
#include "opt_prelude.h"
#include "opt_support.h"

#define MAXSLICES 256		/* to be refined */
#define MINPARTCNT 100000	/* minimal record count per partition */
@:exportOptimizer(mitosis)@
#define OPTDEBUGmitosis  if ( optDebug & ((lng)1 <<DEBUG_OPT_MITOSIS) )
#endif
@c
#include "mal_config.h"
#include "opt_mitosis.h"
#include "opt_octopus.h"
#include "mal_interpreter.h"

#define PARTITION_THRESHOLD (wrd) GDKnr_threads	/* should be increased in production version */

static int eligible(MalBlkPtr mb )
{
	InstrPtr p;
	int i;
	for (i=1; i< mb->stop; i++){
		p = getInstrPtr(mb,i);
		if ( getModuleId(p) == sqlRef && getFunctionId(p) == assertRef &&
			p->argc > 2 && getArgType(mb,p,2) == TYPE_str &&
			isVarConstant(mb,getArg(p,2)) &&
			getVarConstant(mb, getArg(p,2)).val.sval != NULL &&
			strstr(getVarConstant(mb, getArg(p,2)).val.sval, "PRIMARY KEY constraint") )
		return 0;
	}
	return 1;
}

static int
OPTmitosisImplementation(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	int i, j, k, limit, estimate=0, tpe, pieces=1;
	str schema=0, table=0;
	VarRecord low,hgh;
	oid slice;
	wrd r = 0, rowcnt=0;	/* table should be sizeable to consider parallel execution*/
	InstrPtr q,*old, target= 0, matq;
	size_t typewidth= 3 *sizeof(lng); /* 2 arguments and a result */

	(void)cntxt;
	(void) stk;
	if ( !eligible(mb))
		return 0;
	
	/* locate the largest non-partitioned table */
	for (i=1; i< mb->stop; i++){
		q= getInstrPtr(mb,i);
		if (getModuleId(q)!= sqlRef || getFunctionId(q)!=bindRef )
			continue;
		/* don't split insert or update BATs */
		if (getVarConstant(mb, getArg(q,5)).val.ival != 0 )
			continue;
		if( q->argc > 6 )
			continue; /* already partitioned */
@-
The SQL optimizer already collects the counts of the
base table and passes them on as a row property.
All pieces for a single subplan should ideally fit together.
@c
		r = getVarRows(mb, getArg(q, 0));
		if (r >= 0 && r >= rowcnt && r > PARTITION_THRESHOLD){
			rowcnt = r;
			target = q;
			estimate++;
			r = 0;
		}
	}
	if (target == 0)
		return 0;
@-
The number of pieces should be based on the footprint of the queryplan,
such that preferrably it can be handled without swapping intermediates.
For the time being we just go for small pieces compared to memory detected upon start.
A fictive rowcount is derived based on TYPE_lng, such that all pieces
would fit into memory conveniently for processing. We attempt to use
at least all threads.
Experience shows that the pieces should not be too small.
To keep the threads working, we create more pieces than threads.

The pieces to be used may be overruled by the octopus optimizer.
@c
	if ( (i = OPTlegAdviceInternal(mb,stk,p)) > 0 )
		pieces = i;
	else {
		/* ensure that GDKnr_threads partitions fit into main memory */
		r = (BUN) (monet_memory / typewidth / GDKnr_threads);
		if (rowcnt > r)
			pieces = MAX ( (int)(rowcnt / r + 1) , GDKnr_threads );
		else
		/* exploit parallelism, but ensure minimal partition size to limit overhead */
		if (rowcnt > MINPARTCNT)
			pieces = MIN ( (int)(rowcnt / MINPARTCNT) , GDKnr_threads );
		/* when testing, split also small BATs, but avoid empty pieces */
		FORCEMITODEBUG
			if (pieces < GDKnr_threads)
				pieces = MIN ( GDKnr_threads , (int)rowcnt );
		/* prevent plan explosion */
		if (pieces > MAXSLICES)
			pieces = MAXSLICES;

		if (pieces <= 1)
			return 0;
	}
	OPTDEBUGmitosis
		mnstr_printf(cntxt->fdout,"#opt_mitosis: target is %s.%s "
			" with " BUNFMT " rows into " BUNFMT " rows/piece %d threads %d pieces\n",
				getVarConstant(mb, getArg(target,2)).val.sval,
				getVarConstant(mb, getArg(target,3)).val.sval,
				rowcnt, r, GDKnr_threads,pieces);

	old = mb->stmt;
	limit= mb->stop;
	if ( newMalBlkStmt(mb,mb->ssize + 2* estimate) < 0 )
		return 0;
	estimate=0;

	schema = getVarConstant(mb, getArg(target,2)).val.sval;
	table = getVarConstant(mb, getArg(target,3)).val.sval;
	for(i=0;i<limit;i++){
		p= old[i];

		if (getModuleId(p)!= sqlRef || 
			!(getFunctionId(p)==bindRef ||
			  getFunctionId(p)==bindidxRef )){
			pushInstruction(mb,p);
			continue;
		}
		/* don't split insert or update BATs */
		if (getVarConstant(mb, getArg(p,5)).val.ival != 0 ){
			pushInstruction(mb,p);
			continue;
		}
		/* Don't split the (index) bat if we already have identified a range */
		/* This will happen if we inline separately optimized routines */
		if ( p->argc != 6 ){
			pushInstruction(mb,p);
			continue;
		}
		if (strcmp(schema, getVarConstant(mb, getArg(p,2)).val.sval) ||
		    strcmp(table, getVarConstant(mb, getArg(p,3)).val.sval)){
			pushInstruction(mb,p);
			continue;
		}
		/* we keep the original bind operation, because it allows
			for easy undo when the mergtable can not do something
		*/
		pushInstruction(mb,p);
		
		slice= (BUN) (rowcnt/pieces);
		hgh.value.vtype= low.value.vtype= TYPE_oid;
		low.value.val.oval= 0;
		tpe = getVarType(mb,getArg(p,0));

		matq= newInstruction(NULL,ASSIGNsymbol);
		setModuleId(matq,matRef);
		setFunctionId(matq,newRef);
		getArg(matq,0)= getArg(p,0);

		for(j=0; j < pieces; j++){
			q= copyInstruction(p);
			q= pushOid(mb,q,low.value.val.oval);
			if (j+1 < pieces){
				hgh.value.val.oval= low.value.val.oval+slice;
				q= pushOid(mb,q,hgh.value.val.oval);
			} else
				q= pushNil(mb,q, TYPE_oid);

			k= getArg(q,0)= newTmpVariable(mb,tpe);
			setVarUDFtype(mb,k);
			setVarUsed(mb,k);
			if (getFunctionId(p) == binddbatRef) {
				varSetProp(mb, k, PropertyIndex("tlb"), op_gte, (ptr) &low.value);
				varSetProp(mb, k, PropertyIndex("tub"), op_lt, (ptr) &hgh.value);
			} else {
				varSetProp(mb, k, PropertyIndex("hlb"), op_gte, (ptr) &low.value);
				varSetProp(mb, k, PropertyIndex("hub"), op_lt, (ptr) &hgh.value);
			}
			low.value.val.oval += slice;
			pushInstruction(mb,q);
			matq= pushArgument(mb,matq,k);
		}
		pushInstruction(mb,matq);
	}
	return 1;
}
@include optimizerWrapper.mx
@c
#include "opt_statistics.h"
@:wrapOptimizer(mitosis,OPT_CHECK_ALL)@
@}
