@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
@' Copyright August 2008-2009 MonetDB B.V.
@' All Rights Reserved.

@f opt_replicator
@- Database replication
The replicator optimizer supports distribution of the 
updates on an SQL database to be distributed over multiple
destination databases.
It initiates the code to prepare simple MAL-log files.

Further details are given in the replicator module code.
@{
@mal
pattern optimizer.replicator():str
address OPTreplicator;
pattern optimizer.replicator(mod:str, fcn:str):str
address OPTreplicator
comment "Replication optimizer";
@h
#ifndef _OPT_REPLICATOR_
#define _OPT_REPLICATOR_
#include "opt_prelude.h"
#include "opt_support.h"
#include "mal_interpreter.h"
#include "mal_instruction.h"

/* #define DEBUG_REPLICATOR      trace its behavior */

@c
#include "mal_config.h"
#include "opt_prelude.h"
#include "opt_replicator.h"

static int 
OPTreplicatorImplementation(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	int i, tag, limit, slimit, actions= 0;
	InstrPtr q, p=0, *old= mb->stmt;

	(void) pci;
	(void) stk;		/* to fool compilers */
	(void) cntxt;

	limit= mb->stop;
	slimit = mb->ssize;
	newMalBlkStmt(mb, mb->ssize * 1.2); /* a new statement stack */

	pushInstruction(mb, old[0]);
	p= newStmt(mb, replicatorRef, openRef);
	tag = getArg(p,0);

	for (i = 1; i < limit - 1; i++){
		p= old[i];
		pushInstruction(mb, p);
		if (getModuleId(p)==sqlRef &&  isaBatType(getArgType(mb,p,1)) &&
			(getFunctionId(p) == appendRef || getFunctionId(p) == deleteRef) ){
			q= copyInstruction(p);
			setModuleId(q, replicatorRef);
			pushInstruction(mb,q);
			pushArgument(mb,q,tag);
			actions++;
		} 
	}

	q = newStmt(mb, replicatorRef, closeRef);
	pushArgument(mb,q,tag);
	pushInstruction(mb, old[i]);

	for(; i<slimit; i++)
		if( old[i])
			freeInstruction(old[i]);
	GDKfree(old);
	return actions;
}
@include optimizerWrapper.mx
@h
@:exportOptimizer(replicator)@
#endif
@c
#include "opt_statistics.h"
@:wrapOptimizer(replicator,OPT_CHECK_ALL)@
@}
