@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2008 CWI.
@' All Rights Reserved.

@f opt_replicator
@- The replicator
The replicator is an optimizer and runtime support
module to re-use operation results against persistent columns.
It is developed primarilly for the SQL front-end.

The following patterns are the target:
@verbatim
_3:bat[:oid,:bte]  := sql.bind(_4="sky", _5="photoobjall", _6="mode", _7=0) ]
_9 := algebra.uselect(_3=<tmp_30445>bat[:oid,:bte]{200276}, _8=1) ]

_20:bat[:oid,:lng]  := sql.bind(_4="sky", _5="photoobjall", _21="fieldid", _7=0) ]
_22 := algebra.joinPath(_19=<~tmp_33363>bat[:oid,:oid]{57328}, _12=<~tmp_33364>bat[:oid,:oid]{149491}, _20=<tmp_31311>bat[:oid,:lng]{200276}) ]

@end verbatim

The replicator comes with a few controlling operators
to experiment with its effect in concrete settings.
@{
@mal
pattern optimizer.replicator():str
address OPTreplicator;
pattern optimizer.replicator(mod:str, fcn:str):str
address OPTreplicator
comment "Replicator code injection";

module replicator;


pattern replicator.bind(sname:str,tname:str,cname:str,access:int):bat[:oid,:any_1]
address REPbind
comment "The overloaded bind operator for replicated operations";

pattern replicator.select(b:bat[:any_1,:any_2],value:any_2):bat[:any_1,:any_2]
address REPselect
comment "The overloaded select operator for replicated operations";

pattern replicator.select(b:bat[:any_1,:any_2],low:any_2,hgh:any_2):bat[:any_1,:any_2]
address REPselect
comment "The overloaded select operator for replicated operations";

pattern replicator.select(b:bat[:any_1,:any_2],low:any_2,hgh:any_2,li:bit,hi:bit):bat[:any_1,:any_2]
address REPselect
comment "The overloaded select operator for replicated operations";

pattern replicator.uselect(b:bat[:any_1,:any_2],value:any_2):bat[:any_1,:oid ]
address REPuselect
comment "The overloaded uselect operator for replicated operations";

pattern replicator.uselect(b:bat[:any_1,:any_2],low:any_2,hgh:any_2):bat[:any_1,:oid]
address REPuselect
comment "The overloaded uselect operator for replicated operations";

pattern replicator.uselect(b:bat[:any_1,:any_2],low:any_2,high:any_2,li:bit,hi:bit):bat[:any_1,:oid] 
address REPuselect
comment "The overloaded uselect operator for replicated operations";

pattern replicator.markT(b:bat[:any_1,:any_2],base:oid):bat[:any_1,:oid] 
address REPmarkT
comment "The overloaded markT operator for intermediates reuse";

pattern replicator.reverse(b:bat[:any_1,:any_2]):bat[:any_2,:any_1]
address REPreverse
comment "The overloaded reverse operator for intermediates reuse";

pattern replicator.join(left:bat[:any_1,:any_2],right:bat[:any_2,:any_3]):bat[:any_1,:any_3]
address REPjoin
comment "The overloaded join operator for intermediates reuse";

pattern replicator.semijoin(left:bat[:any_1,:any_2],right:bat[:any_1,:any]):bat[:any_1,:any_2] 
address REPsemijoin
comment "The overloaded semijoin operator for intermediates reuse";


pattern replicator.start():void
address REPstart
comment "Initialize replica record of executed MAL block";

command replicator.stop():void
address REPstop
comment "Cleans replica bookkeeping";

@mal

command replicator.dump():void
address REPdump
comment "Dump summary of replica table for potential re-use benefits";

command replicator.setRetainPolicy(p:sht):void
address REPsetRetain
comment "Set replica retainment policy";

command replicator.setReusePolicy(p:sht):void
address REPsetReuse
comment "Set replica reuse policy";

command replicator.setCachePolicy(p:sht):void
address REPsetCache
comment "Set replica cache policy";


@h
#ifndef _OPT_REPLICATOR_
#define _OPT_REPLICATOR_
#include "opt_prelude.h"
#include "opt_support.h"
#include "mal_interpreter.h"


opt_export str REPbind(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
opt_export str REPselect(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
opt_export str REPuselect(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
opt_export str REPmarkT(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
opt_export str REPreverse(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
opt_export str REPjoin(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
opt_export str REPsemijoin(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
opt_export str REPdump(int *ret);
opt_export str REPstart(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
opt_export str REPstop(void);
opt_export str REPsetRetain(int *ret, sht *p);
opt_export str REPsetReuse(int *ret, sht *p);
opt_export str REPsetCache(int *ret, sht *p);

typedef str (*sqlbind_fptr)(int *bid, str *sname, str *tname, str *cname, int *access);
typedef struct _sql_functions {
	sqlbind_fptr sqlbind;
} sql_functions;

opt_export sql_functions sqlf;

/* #define DEBUG_OPT_REPLICATOR  */
@-
@c
#include "mal_config.h"
#include "opt_replicator.h"
#define getVarVal(M,i) VALget(&(M)->var[i]->value)
#define isResStored(M,i) isVarStored(M, getArg(M->stmt[i],0))

/* repl. bookkeeping for current query execution */
typedef struct REPLICAREC {
	int ver;		/* version of replica table */
	int * vmap;		/* map of exec. variables to replica name space */
 } *Replica, ReplicaRec;

typedef struct STAT {
	lng ticks;		/* micro seconds spent */
	lng reuse;		/* number of uses */
	lng cnt;		/* result size in tuples */
} *StatPtr, StatRec;


sql_functions sqlf;

static MalBlkPtr repl = NULL;
static int replver = 0;  /* version of replica table */
static int replref = 0;  /* queries currently using repl */
static StatPtr replstat = NULL;  /* statistics for stored intermediates */

/*static int replnr = 0;  number of replicas */
static sht retain = 0;  /* replica retainment policy
			0: baseline, keeps stat, no retain, no reuse
			1: infinite case, retain all
			2: cost-based, retain if beneficial */
static sht reuse = 0;	/* replica reuse policy
			0: baseline, keeps stat, no retain, no reuse
			1: reuse smallest covering
			2: reuse closest covering */
static sht rcache = 0;  /* replica cache management policy
			0: baseline, do nothing
			1: throw LRU
			2: cost-based, throw least beneficial */


static void assureSpace()
{
	StatPtr olds;
	int sz;
	if ( repl == NULL){
		repl = newMalBlk(1000, 1000);
		initProfiler(repl);
		replstat = (StatPtr)GDKzalloc(sizeof(StatRec)* 1000);
	} else 		/* sync the repl stat */
		if(repl->vtop + 1>= repl->vsize){
			olds = replstat;
			sz = repl->vtop + MAXVARS;
			replstat = (StatPtr)GDKzalloc(sizeof(StatRec)* sz);
			memcpy(replstat,olds,repl->vtop * sizeof(StatRec));
			GDKfree(olds);
		}
}

int* getMap(MalStkPtr s)
{
	if( s->blk->replica )
		return (((ReplicaRec*)s->blk->replica)->vmap);
	else return NULL;
}

str
REPstart(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	Replica r;
	int i, vc;

	(void) mb;
	(void) pci;
	vc = stk->blk->vtop;
	r = (Replica) stk->blk->replica;
	if( r == NULL) {	/* first execution */
		r = (Replica) GDKzalloc(sizeof(ReplicaRec));
		r->ver = replver;
		r->vmap = (int*)GDKmalloc(sizeof(int)* vc);
		for(i=0; i<vc; i++)
			r->vmap[i] = -1;
		stk->blk->replica = (ptr) r;
	} else
	if( r->ver != replver) { /* replicaRec based on old repl */       
		GDKfree(r->vmap);	/* reinit var. map */
		r->ver = replver;
		r->vmap = (int*)GDKmalloc(sizeof(int)* vc);
		for(i=0; i<vc; i++)
			r->vmap[i] = -1;
	}
	replref++;
	return MAL_SUCCEED;
}


str REPstop(void)
{
	replref--;
	return MAL_SUCCEED;
}


str
REPdump(int *ret)
{
	(void) ret;
/*	stream_printf(GDKout,"Number of replicas %d\n",replnr);*/
	printFunction(GDKout,repl, LIST_MAL_ALL);

	return MAL_SUCCEED;
}


str
REPsetRetain(int *ret, sht *p)
{
	(void) ret;
	retain = *p;
	return MAL_SUCCEED;
}

str
REPsetReuse(int *ret, sht *p)
{
	(void) ret;
	reuse = *p;
	return MAL_SUCCEED;
}

str
REPsetCache(int *ret, sht *p)
{
	(void) ret;
	rcache = *p;
	return MAL_SUCCEED;
}

static int
OPTreplicatorImplementation(MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	int i, actions=0;
	InstrPtr *old, q;
	int limit,slimit, no_pr, rprof = 0, rs =0;
	sht *rep ;

	(void) stk;
		 /* vars bound to replicator commands */
	rep = (sht*) alloca(sizeof(sht)* mb->vtop);
	memset((char*) rep, 0, sizeof(sht)* mb->vtop);

	no_pr = (mb->profiler == NULL? 1:0);
	old= mb->stmt;
	limit= mb->stop;
	slimit= mb->ssize;
	newMalBlkStmt(mb,mb->ssize);

	for (i = 0; i<limit; i++){
		p= old[i];
		if( (getModuleId(p)== sqlRef && getFunctionId(p)==bindRef) ){
			if(no_pr && rprof ==0){
				q = newStmt(mb,"profile","start");	
				rprof = 1;
			}
			if(rs == 0){
				q = newStmt(mb,"replicator","start");	
				rs = 1;
			}
			setModuleId(p,replicatorRef);
			pushInstruction(mb,p);
			rep[getArg(p,0)] = 1;
		} else
		if( getModuleId(p)== algebraRef && 
			( getFunctionId(p) == uselectRef ||
			  getFunctionId(p) == selectRef) &&
			 rep[getArg(p,1)]){
 				setModuleId(p,replicatorRef);
				pushInstruction(mb,p);
				rep[getArg(p,0)] = 1;
		} else
		if( getModuleId(p)== algebraRef && 
			getFunctionId(p) == markTRef &&
			rep[getArg(p,1)] &&
			isVarConstant(mb,getArg(p,2))){
				setModuleId(p,replicatorRef);
				pushInstruction(mb,p);
				rep[getArg(p,0)] = 1;
		} else
		if( getModuleId(p)== batRef && 
			getFunctionId(p) == reverseRef &&
			rep[getArg(p,1)]){
				setModuleId(p,replicatorRef);
				pushInstruction(mb,p);
				rep[getArg(p,0)] = 1;
		} else
		if( getModuleId(p)== algebraRef && 
			getFunctionId(p) == semijoinRef &&
			rep[getArg(p,1)] &&
			rep[getArg(p,2)]){
 				setModuleId(p,replicatorRef);
				pushInstruction(mb,p);
				rep[getArg(p,0)] = 1;
		} else
		if( getModuleId(p)== algebraRef && 
			getFunctionId(p) == joinRef &&
			rep[getArg(p,1)] &&
			rep[getArg(p,2)]){
 				setModuleId(p,replicatorRef);
				pushInstruction(mb,p);
				rep[getArg(p,0)] = 1;
		} else {	
		 	if((getModuleId(p)== sqlRef && 
				getFunctionId(p)==resultSetRef) ||
				p->token == ENDsymbol){
				if( rs == 1){
					q = newStmt(mb,"replicator","stop");	
					rs = 0;
				}
				if (no_pr && rprof == 1){
					q = newStmt(mb,"profiler","stop");	
					rprof = 0;
				}
			}
			pushInstruction(mb,p);
		}
	}

	for(; i<slimit; i++)
	if(old[i])
		freeInstruction(old[i]);
	GDKfree(old);
	return actions;
}
@include optimizerWrapper.mx
@h
@:exportOptimizer(replicator)@
#endif
opt_export str ALGreplicator(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
@c
#include "opt_statistics.h"
#include "../kernel/algebra.h"
@:wrapOptimizer(replicator,OPT_CHECK_ALL)@


@-
The overloaded algebra operator simply calls the
underlying implementation and collects statistics on the
cost.
@c

static int newReplica(MalStkPtr s, InstrPtr p, bit keep)
{
	int i, j, k, c, bid, r; 
	ValPtr v, v1;
	InstrPtr p1;
	
	assureSpace();
	p1 = copyInstruction(p);
	for(i = 0; i< p->argc; i++){
		j = p->argv[i];
	        v = &s->stk[j];
		c = fndConstant(repl, v);
		if ( c < 0 ){ 
			v1 = VALnew();
        	        VALcopy(v1,v);
			c = defConstant(repl, v1->vtype, v1);
		}
	 	setArg(p1,i,c);
	
		if ((i > 0) ||
		    ((i == 0) && keep)){
			setVarStored(repl,c); 
			if (v->vtype == TYPE_bat){
				bid = *(int*)VALget(v);
				BBPincref(bid,TRUE);
			}
		} else clrVarStored(repl,c); 
	}
	k = repl->stop;
	pushInstruction(repl,p1);
	r = getDestVar(p1);
	if (s->blk->profiler)
		replstat[r].ticks = s->blk->profiler[k].ticks;
	return k;
}

/* compare values in ValRecords, return 0 on equal */
int
VALcmp(ValPtr p, ValPtr q)
{

	int (*cmp) (ptr, ptr);
	int tpe;
	ptr nilptr, pp, pq;

	if( p ==0 || q == 0 ) return  -1;
	if( (tpe = p ->vtype) != q->vtype ) return  -1;

	cmp = BATatoms[tpe].atomCmp;
	nilptr = ATOMnilptr(tpe);
	pp = VALget(p);
	pq = VALget(q);
	if(((*cmp)(pp, nilptr)==0) && ((*cmp)(pq, nilptr)==0)) return 0; /* eq nil val */
	if(((*cmp)(pp, nilptr)==0) || ((*cmp)(pq, nilptr)==0)) return -1;
	return ((*cmp)(pp, pq));

}

/* check for replica of instruction p in repl table */
int
findReplica(MalStkPtr s,InstrPtr p)
{
	int i, j, idx, dif = 0;
	int *vmap;
	InstrPtr *st, q;
	ValPtr pa, qa;
	
	if (repl == NULL) return -1;
	vmap = getMap(s);
	if( vmap == NULL)
		GDKerror("Variable map not initialized\n");
	st = repl->stmt;
	for (i = 0; i < repl->stop; i++){
		q = st[i];
		if((p->argc != q->argc) ||
		   (getFunctionId(p) != getFunctionId(q)))
			continue;
		else{	
			dif = 0;
			for (j = 1; j < p->argc; j++){
				idx = p->argv[j];
				if( vmap[idx] >=0 ){ /* symbol comp */
					if( vmap[idx] != getArg(q,j)){
						dif = 1;
						break;
					}
				} else {	/* value comp */		
					pa = &s->stk[idx];
					qa = &getVar(repl,getArg(q,j))->value;
					if( VALcmp(pa,qa) ){
						dif = 1;
						break;
					}
				}
			}
			if( dif == 0 ) return i;
		}
	}
	
	return -1;

}

str
REPbind(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	int *ret, *acc, ri, rv, *vmap;
	str msg;
	str *sname, *tname, *cname;

	(void) mb;
	ret= (int*) getArgReference(stk, pci,0);
	sname = (str*) getArgReference(stk, pci,1);
	tname = (str*) getArgReference(stk, pci,2);
	cname = (str*) getArgReference(stk, pci,3);
	acc = (int*) getArgReference(stk, pci,4);

	if( sqlf.sqlbind == NULL)
		throw(MAL, "REPbind", "sqlbind not set");
		/* always execute cheap bind */
	msg = sqlf.sqlbind(ret, sname, tname, cname, acc);
		/*  res var mapping */
	rv = getArg(pci,0); 
	vmap = getMap(stk);
	if( vmap == NULL)
		throw(MAL, "REPbind", "Variable map not initialized");
	if( vmap[rv] < 0 ){ /*res var not mapped*/
		ri = findReplica(stk,pci); /* replica instr */
		if( ri < 0 ) 
			ri = newReplica(stk,pci,FALSE);
		vmap[rv] = getArg(repl->stmt[ri],0);
	}

	return msg;
}

static 
str REPselectImpl(int *ret, BAT *b, ptr low, ptr hgh, bit li, bit hi, 
		 bit tl, MalStkPtr s, InstrPtr p)
{
	BAT *bn;
	lng cnt = -1;
	int ri, rr, rv;
	int * vmap;

  	rv = getArg(p,0); 
	vmap = getMap(s);
	if( vmap == NULL)
		throw(MAL, "REPbind", "Variable map not initialized");

	if( vmap[rv] < 0 ){ 		/*res var not mapped*/
		ri = findReplica(s,p); 	/* replica instr */
		if(ri >= 0 && isResStored(repl,ri)){		/*reuse */ 
			rr = getArg(repl->stmt[ri],0);
			*ret = *(int *)getVarVal(repl,rr);
			BBPincref(*ret,TRUE);
			replstat[rr].reuse++;  
		} else { /* compute */
			bn = BAT_select_(b, low, hgh, li, hi, tl, FALSE);
	        	if (bn) {
       		        	if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ);
	        	       	*ret = bn->batCacheid;
				cnt= BATcount(bn);
                		BBPkeepref(*ret);
	        	}
       			else throw(MAL, "REPselectImpl", "GDKerror");
			if( ri < 0 ){	/* add replica item */
				ri = newReplica(s,p,TRUE);
				rr = getArg(repl->stmt[ri],0);
				replstat[rr].cnt = cnt;
			}
			else rr = getArg(repl->stmt[ri],0);
		} 
			/* set mapping after first exec */
		vmap[rv] = rr;
	}
	else {		/* check and reuse mapped var*/
		rr = vmap[rv];
		if( isVarStored(repl,rr) ){		/*reuse */ 
			*ret = *(int *)getVarVal(repl,rr);
			BBPincref(*ret,TRUE);
			replstat[rr].reuse++;  
		}
		else {	/* recompute */
			bn = BAT_select_(b, low, hgh, li, hi, tl, FALSE);
	        	if (bn) {
       		        	if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ);
	        	       	*ret = bn->batCacheid;
                		BBPkeepref(*ret);
	        	}
       			else throw(MAL, "REPselectImpl", "GDKerror");
		}
	}

	return MAL_SUCCEED;
}

static str
REPselect_wrap(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci, int uselect)
{
	int *ret, *bid, tpe;
	ptr low, hgh;
	bit t=TRUE,*li=&t,*hi=&t;
	BAT *b;
	sht argcnt = pci->argc;

	(void) mb;
	ret= (int*) getArgReference(stk, pci,0);
	bid= (int*) getArgReference(stk, pci,1);
	low= (ptr) getArgReference(stk, pci,2);
	if( argcnt >= 4)
                hgh = (ptr) getArgReference(stk,pci,3);
        else hgh = low;

	if( argcnt > 4){
		li= (bit*) getArgReference(stk, pci,4);
		hi= (bit*) getArgReference(stk, pci,5);
	}
	
	if ((b = BATdescriptor(*bid)) == NULL) {
                throw(MAL, uselect ? "REPuselect" : "REPselect", "Cannot access descriptor");
        }
	
	tpe= ATOMstorage(b->T->type);
        if( tpe == TYPE_str || tpe > TYPE_str ){
                if(low== 0 || *(str*)low==0) low = (str)str_nil;
                        else low = *(str *)low;
                if(hgh== 0 || *(str*)hgh==0) hgh = (str)str_nil;
                        else hgh = *(str *)hgh;
        }


	REPselectImpl(ret, b, low, hgh, *li, *hi, uselect ? FALSE : TRUE, stk, pci);
	BBPreleaseref(b->batCacheid);
	return MAL_SUCCEED;
}


str
REPselect(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	return REPselect_wrap(mb, stk, pci, 0);
}

str
REPuselect(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	return REPselect_wrap(mb, stk, pci, 1);
}





str
REPmarkT(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	int *ret, *bid, ri, rv, rr, *vmap;
	oid *base;
	str msg = MAL_SUCCEED;

	(void) mb;
	ret= (int*) getArgReference(stk, pci,0);
	bid= (int*) getArgReference(stk, pci,1);
	base= (oid*) getArgReference(stk, pci,2);

	rv = getArg(pci,0); 
	vmap = getMap(stk);
	if( vmap == NULL)
		throw(MAL, "REPbind", "Variable map not initialized");
	if( vmap[rv] < 0 ){ /*res var not mapped*/
		ri = findReplica(stk,pci); /* replica instr */
		if( ri < 0 ){
			msg = ALGtmark(ret, bid, base); 
			ri = newReplica(stk,pci,FALSE);
		} else {
			rr = getArg(repl->stmt[ri],0);
			if( isVarStored(repl,rr) )
				msg = ALGtmark(ret, bid, base);
			else {			/*reuse */ 
				*ret = *(int *)getVarVal(repl,rr);
				BBPincref(*ret,TRUE);
				replstat[rr].reuse++; 
			} 
		}	
		vmap[rv] = getArg(repl->stmt[ri],0); /*1st exec always maps */
	} else{
		rr = vmap[rv];
		if( isVarStored(repl,rr) ){		/*reuse */ 
			*ret = *(int *)getVarVal(repl,rr);
			BBPincref(*ret,TRUE);
			replstat[rr].reuse++;  
		}
		else 	/* recompute */
			msg = ALGtmark(ret, bid, base);
	}

	return msg;
}

str
REPreverse(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{

	int *ret, *bid;
	lng clk = 0;
	BAT *b, *bn = NULL;

	(void) mb;
	ret= (int*) getArgReference(stk, pci,0);
	bid= (int*) getArgReference(stk, pci,1);

        if ((b = BATdescriptor(*bid)) == NULL) {
                throw(MAL, "bat.reverse", "Cannot access descriptor");
        }

	clk = GDKusec();
	bn = BATmirror(b);
	clk = GDKusec()-clk;

        if (bn) {
                *ret = bn->batCacheid;
                BBPkeepref(bn->batCacheid);
        } else
		throw(MAL, "bat.reverse", "GDKerror");

	newReplica(stk,pci,FALSE);
	return MAL_SUCCEED;

}

str
REPjoin(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{

	int *ret, *lid, *rid;
	lng clk = 0;
	str msg;

	(void) mb;
	ret = (int*) getArgReference(stk, pci,0);
	lid = (int*) getArgReference(stk, pci,1);
	rid = (int*) getArgReference(stk, pci,2);
	
	clk = GDKusec();
	msg = ALGjoin(ret, lid, rid);
	clk = GDKusec()-clk;

	newReplica(stk,pci,TRUE);
	return msg;
}

str
REPsemijoin(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{

	int *ret, *lid, *rid;
	lng clk = 0;
	str msg;

	(void) mb;
	ret = (int*) getArgReference(stk, pci,0);
	lid = (int*) getArgReference(stk, pci,1);
	rid = (int*) getArgReference(stk, pci,2);
	
	clk = GDKusec();
	msg = ALGsemijoin(ret, lid, rid);
	clk = GDKusec()-clk;

	newReplica(stk,pci,TRUE);
	return msg;
}


@}
