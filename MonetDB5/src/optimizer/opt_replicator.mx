@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2008 CWI.
@' All Rights Reserved.

@f opt_replicator
@- The replicator
The replicator is an optimizer and runtime support
module to re-use operation results against persistent columns.
It is developed primarilly for the SQL front-end.

The following patterns are the target:
@verbatim
_3:bat[:oid,:bte]  := sql.bind(_4="sky", _5="photoobjall", _6="mode", _7=0) ]
_9 := algebra.uselect(_3=<tmp_30445>bat[:oid,:bte]{200276}, _8=1) ]

_20:bat[:oid,:lng]  := sql.bind(_4="sky", _5="photoobjall", _21="fieldid", _7=0) ]
_22 := algebra.joinPath(_19=<~tmp_33363>bat[:oid,:oid]{57328}, _12=<~tmp_33364>bat[:oid,:oid]{149491}, _20=<tmp_31311>bat[:oid,:lng]{200276}) ]

@end verbatim

The replicator comes with a few controlling operators
to experiment with its effect in concrete settings.
@{
@mal
pattern optimizer.replicator():str
address OPTreplicator;
pattern optimizer.replicator(mod:str, fcn:str):str
address OPTreplicator
comment "Replicator code injection";

module replicator;
pattern replicator.prelude(dst:bat[:any,:any]):void
address REPprelude
comment "Prepare for re-using an intermediate result.";

pattern replicator.select(dst:bat[:any_1,:any_2],low:any_2,hgh:any_2):bat[:any_1,:any_2]
address REPselect
comment "The overloaded select operator for replicated operations";
pattern replicator.uselect(dst:bat[:any_1,:any_2],low:any_2,hgh:any_2):bat[:any_1,:any_2]
address REPuselect
comment "The overloaded uselect operator for replicated operations";

command init():void
address REPinit
comment "Initialize replica table"

command dump():void
address REPdump
comment "Dump summary of replica table for potential re-use benefits"

@h
#ifndef _OPT_REPLICATOR_
#define _OPT_REPLICATOR_
#include "opt_prelude.h"
#include "opt_support.h"
#include "mal_interpreter.h"

opt_export str REPselect(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
opt_export str REPuselect(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
opt_export str REPprelude(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);

opt_export str REPinit(void);
opt_export str REPdump(void);

/* #define DEBUG_OPT_REPLICATOR  */
@-
@c
#include "mal_config.h"
#include "opt_replicator.h"

typedef struct REPLICAREC {
        bat srcbid, resbid;                /* partition BAT, back into BBP */

        ValRecord low,hgh; /* selected tail range */
        bit li, hi; 	/* inclusive bits */
        size_t cnt;     /* how many tuples */
	dbl cost;	/* how much time was spent to produce */
	MalBlkPtr malblk; /* mal instruction block*/
} *Replica, ReplicaRec;

static Replica repltable = NULL;
static int replsz = 0;  /* alloc. mem */
static int replnr = 0;	/* number of replicas */

static void assureSpace(){
	if ( replsz == 0){
		replsz = 16;
		repltable = (ReplicaRec*)GDKzalloc((replsz)*sizeof(ReplicaRec));
	}
	else if( replnr == replsz){
		replsz <<=1;
		repltable = (ReplicaRec*) GDKrealloc((void*)repltable,
				 sizeof(ReplicaRec) * replsz);
	}
}

str
REPinit(){
	str msg= MAL_SUCCEED;

        if ( repltable != NULL){
		GDKfree(repltable);
                replsz = replnr = 0;
        }
	assureSpace();
	return msg;
}


static int
OPTreplicatorImplementation(MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	int i, actions=0;
	int *pc;
	InstrPtr q,*old;
	int limit,slimit;

	(void) stk;
	pc= (int*) alloca(sizeof(int)* mb->vtop); /* to find last assignment */
	memset((char*) pc, 0, sizeof(int)* mb->vtop);

	old= mb->stmt;
	limit= mb->stop;
	slimit= mb->ssize;
	newMalBlkStmt(mb,mb->ssize);

	for (i = 0; i<limit; i++){
		p= old[i];
		if( (getModuleId(p)== sqlRef && getFunctionId(p)==bindRef) )
			pc[getArg(p,0)]= i;
		if( getModuleId(p)== algebraRef && 
			( getFunctionId(p) == uselectRef ||
			  getFunctionId(p) == selectRef
			) && pc[getArg(p,1)]){
				q=copyInstruction(getInstrPtr(mb,pc[getArg(p,1)]));
				setModuleId(q,replicatorRef);
				setFunctionId(q,preludeRef);
				q= pushArgument(mb,q,getArg(p,1));
				pushInstruction(mb,q);
				setModuleId(p,replicatorRef);
				pushInstruction(mb,p);
		} else
			pushInstruction(mb,p);
	}
	for(; i<slimit; i++)
	if(old[i])
		freeInstruction(old[i]);
	GDKfree(old);
	return actions;
}
@include optimizerWrapper.mx
@h
@:exportOptimizer(replicator)@
#endif
opt_export str ALGreplicator(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
@c
#include "opt_statistics.h"
#include "../kernel/algebra.h"
@:wrapOptimizer(replicator,OPT_CHECK_ALL)@

str
REPuselect(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	(void) mb;
	(void) stk;
	(void) pci;
	throw(MAL,"replicator.uselect","nyi");
}
str
REPprelude(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	(void) mb;
	(void) stk;
	(void) pci;
	return MAL_SUCCEED;
}
@-
The overloaded algebra operator simply calles the
underlying implementation and collects statistics on the
cost.
@c
str
REPselect(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	int *ret, *bid;
	ptr low,hgh;
	bit t=TRUE,*li=&t,*hi=&t;
	BAT *b;
	lng cnt,clk;
	Replica r;
	str msg= MAL_SUCCEED;
	
	(void) mb;
	ret= (int*) getArgReference(stk, pci,0);
	bid= (int*) getArgReference(stk, pci,1);
	low= (ptr) getArgReference(stk, pci,2);
	hgh= (ptr) getArgReference(stk, pci,3);
	if( pci->argc==6){
		li= (bit*) getArgReference(stk, pci,4);
		hi= (bit*) getArgReference(stk, pci,5);
	}
	
	clk= GDKusec();
	msg= ALGselectInclusive(ret, bid, low,hgh,li,hi);
	clk= GDKusec()-clk;

	/* time for the decision */
	if ( (b=BATdescriptor(*ret)) == NULL)
		throw(MAL,"replicator.select","can not access BAT");
	cnt= BATcount(b);
	/* keep stat */
	assureSpace();
	r = repltable + replnr;
	r->srcbid = *bid;
	r->resbid = *ret;
	VALset(&r->low,b->ttype,(ValPtr) low);
	VALset(&r->hgh,b->ttype,(ValPtr) hgh);
	r->li = *li;
	r->hi = *hi; 
	r->cnt = cnt;
	r->cost = clk;
	replnr++;
	BBPunfix(b->batCacheid);

	return msg;
}
@}
