@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2008 CWI.
@' All Rights Reserved.

@f opt_replicator
@- The replicator
The replicator is an optimizer and runtime support
module to re-use operation results against persistent columns.
It is developed primarilly for the SQL front-end.

The following patterns are the target:
@verbatim
_3:bat[:oid,:bte]  := sql.bind(_4="sky", _5="photoobjall", _6="mode", _7=0) ]
_9 := algebra.uselect(_3=<tmp_30445>bat[:oid,:bte]{200276}, _8=1) ]

_20:bat[:oid,:lng]  := sql.bind(_4="sky", _5="photoobjall", _21="fieldid", _7=0) ]
_22 := algebra.joinPath(_19=<~tmp_33363>bat[:oid,:oid]{57328}, _12=<~tmp_33364>bat[:oid,:oid]{149491}, _20=<tmp_31311>bat[:oid,:lng]{200276}) ]

@end verbatim

The replicator comes with a few controlling operators
to experiment with its effect in concrete settings.
@{
@mal
pattern optimizer.replicator():str
address OPTreplicator;
pattern optimizer.replicator(mod:str, fcn:str):str
address OPTreplicator
comment "Replicator code injection";

module replicator;

pattern replicator.select(b:bat[:any_1,:any_2],value:any_2,sname:str,tname:str,cname:str):bat[:any_1,:any_2]
address REPselect
comment "The overloaded select operator for replicated operations";

pattern replicator.select(b:bat[:any_1,:any_2],low:any_2,hgh:any_2,sname:str,tname:str,cname:str):bat[:any_1,:any_2]
address REPselect
comment "The overloaded select operator for replicated operations";

pattern replicator.select(b:bat[:any_1,:any_2],low:any_2,hgh:any_2,li:bit,hi:bit,sname:str,tname:str,cname:str):bat[:any_1,:any_2]
address REPselect
comment "The overloaded select operator for replicated operations";

pattern replicator.uselect(b:bat[:any_1,:any_2],value:any_2,sname:str,tname:str,cname:str):bat[:any_1,:oid ]
address REPuselect
comment "The overloaded uselect operator for replicated operations";

pattern replicator.uselect(b:bat[:any_1,:any_2],low:any_2,hgh:any_2,sname:str,tname:str,cname:str):bat[:any_1,:oid]
address REPuselect
comment "The overloaded uselect operator for replicated operations";

pattern replicator.uselect(b:bat[:any_1,:any_2],low:any_2,high:any_2,li:bit,hi:bit,sname:str,tname:str,cname:str):bat[:any_1,:oid] 
address REPuselect
comment "The overloaded uselect operator for replicated operations";

command replicator.init():void
address REPinit
comment "Initialize replica table";

command replicator.dump():void
address REPdump
comment "Dump summary of replica table for potential re-use benefits";

@h
#ifndef _OPT_REPLICATOR_
#define _OPT_REPLICATOR_
#include "opt_prelude.h"
#include "opt_support.h"
#include "mal_interpreter.h"

opt_export str REPselect(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
opt_export str REPuselect(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
opt_export str REPinit(void);
opt_export str REPdump(int *ret);

/* #define DEBUG_OPT_REPLICATOR  */
@-
@c
#include "mal_config.h"
#include "opt_replicator.h"

typedef struct REPLICAREC {
	str sname, tname, cname;	/* source BAT schema, table, column */
        bat resbid;		/* intermediate result BAT */

        ValRecord low,hgh;	/* selected tail range */
        bit li, hi;		/* inclusive bits */
        size_t cnt;     	/* how many tuples */
	dbl cost;		/* how much time was spent to produce */
	int ucnteq,ucntsub;	/* usage counts equality and subset */
	MalBlkPtr malblk;	/* mal instruction block*/
} *Replica, ReplicaRec;

static Replica repltable = NULL;
static int replsz = 0;  /* alloc. mem */
static int replnr = 0;	/* number of replicas */

static void assureSpace(){
	if ( replsz == 0){
		replsz = 16;
		repltable = (ReplicaRec*)GDKzalloc((replsz)*sizeof(ReplicaRec));
	}
	else if( replnr == replsz){
		replsz <<=1;
		repltable = (ReplicaRec*) GDKrealloc((void*)repltable,
				 sizeof(ReplicaRec) * replsz);
	}
}

str
REPinit(){
	str msg= MAL_SUCCEED;

        if ( repltable != NULL){
		GDKfree(repltable);
                replsz = replnr = 0;
        }
	assureSpace();
	return msg;
}

static void printReplica(stream *f, int i){

	Replica r = repltable+i;
	if (r==NULL) GDKerror("Empty replica element");
	stream_printf(f,"Source BAT: %s, %s, %s\n", r->sname, r->tname, r->cname);
	stream_printf(f,"Selection ["); VALprint(f,&r->low);
	stream_printf(f,":"); VALprint(f,&r->hgh);
	stream_printf(f,"] inclusive [%d,%d]\n", r->li,r->hi);
	stream_printf(f,"Cnt %d cost %f \n", r->cnt,r->cost);
	stream_printf(f,"Usage: equality %d, subset %d \n", r->ucnteq,r->ucntsub);
}

str
REPdump(int *ret)
{
	int i;
	(void) ret;
	stream_printf(GDKout,"Number of replicas %d\n",replnr);
	for( i=0; i<replnr; i++)
		printReplica(GDKout, i);
	return MAL_SUCCEED;
}

static int
OPTreplicatorImplementation(MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	int i, actions=0;
	InstrPtr *old;
	int limit,slimit;
	sht v,v1;
	sht *ps, *pt, *pc ;

	(void) stk;
	ps= (sht*) alloca(sizeof(sht)* mb->vtop); /* bind schema */
	memset((char*) ps, 0, sizeof(sht)* mb->vtop);
	pt= (sht*) alloca(sizeof(sht)* mb->vtop); /* bind table */
	memset((char*) pt, 0, sizeof(sht)* mb->vtop);
	pc= (sht*) alloca(sizeof(sht)* mb->vtop); /* bind column */
	memset((char*) pc, 0, sizeof(sht)* mb->vtop);

	old= mb->stmt;
	limit= mb->stop;
	slimit= mb->ssize;
	newMalBlkStmt(mb,mb->ssize);

	for (i = 0; i<limit; i++){
		p= old[i];
		if( (getModuleId(p)== sqlRef && getFunctionId(p)==bindRef) ){
			v = getArg(p,0); /* bound var */
			ps[v]= getArg(p,1);
			pt[v]= getArg(p,2);
			pc[v]= getArg(p,3); 
		}
		if( getModuleId(p)== algebraRef && 
			( getFunctionId(p) == uselectRef ||
			  getFunctionId(p) == selectRef
			) && pc[getArg(p,1)]){
				v1 = getArg(p,1);
				p= pushArgument(mb,p,ps[v1]);
				p= pushArgument(mb,p,pt[v1]);
				p= pushArgument(mb,p,pc[v1]); 
				setModuleId(p,replicatorRef);
				pushInstruction(mb,p);
		} else
			pushInstruction(mb,p);
	}
	for(; i<slimit; i++)
	if(old[i])
		freeInstruction(old[i]);
	GDKfree(old);
	return actions;
}
@include optimizerWrapper.mx
@h
@:exportOptimizer(replicator)@
#endif
opt_export str ALGreplicator(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
@c
#include "opt_statistics.h"
#include "../kernel/algebra.h"
@:wrapOptimizer(replicator,OPT_CHECK_ALL)@

str
REPuselect(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	int *ret, *bid;
	ptr low,hgh;
	bit t=TRUE,*li=&t,*hi=&t;
	BAT *b,*bn;
	lng cnt,clk;
	Replica r;
	sht argcnt = pci->argc;
	
	(void) mb;
	ret= (int*) getArgReference(stk, pci,0);
	bid= (int*) getArgReference(stk, pci,1);
	low= (ptr) getArgReference(stk, pci,2);
	if( argcnt>=7)
		hgh= (ptr) getArgReference(stk, pci,3);
	if( argcnt==9){
		li= (bit*) getArgReference(stk, pci,4);
		hi= (bit*) getArgReference(stk, pci,5);
	}
	
	
	if ((b = BATdescriptor(*bid)) == NULL) {
                throw(MAL, "REPuselect", "Cannot access descriptor");
        }
	
	{int _tpe= ATOMstorage(b->ttype);
	 if( _tpe == TYPE_str || _tpe > TYPE_str ){
	 	if(low== 0 || *(str*)low==0) low = (str)str_nil;
			else low = *(str *)low;
		if(hgh== 0 || *(str*)hgh==0) hgh = (str)str_nil;
			else hgh = *(str *)hgh;
	}}

	clk= GDKusec();
	bn = BAT_select_(b, low, hgh, *li, *hi, FALSE, FALSE);
	clk= GDKusec()-clk;

        BBPreleaseref(b->batCacheid);
        if (bn) {
                if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ);
                *ret = bn->batCacheid;
                BBPincref(bn->batCacheid,TRUE);
        }
        else throw(MAL, "REPuselect", "GDKerror");

	/* decide about replica */
	/* Currently just keep stat */

	cnt= BATcount(bn);
	assureSpace();
	r = repltable + replnr;
	r->resbid = *ret;
	r->sname = GDKstrdup((str) getArgReference(stk, pci,argcnt-3));
	r->tname = GDKstrdup((str) getArgReference(stk, pci,argcnt-2));
	r->cname = GDKstrdup((str) getArgReference(stk, pci,argcnt-1));

	VALset(&r->low,b->ttype,(ValPtr) low);
	VALset(&r->hgh,b->ttype,(ValPtr) hgh);
	r->li = *li;
	r->hi = *hi; 
	r->cnt = cnt;
	r->cost = clk;
	replnr++;
	BBPkeepref(*ret);

	return MAL_SUCCEED;
}


@-
The overloaded algebra operator simply calles the
underlying implementation and collects statistics on the
cost.
@c
str
REPselect(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	int *ret, *bid;
	ptr low,hgh;
	bit t=TRUE,*li=&t,*hi=&t;
	BAT *b,*bn;
	lng cnt,clk;
	Replica r;
	sht argcnt = pci->argc;

	
	(void) mb;
	ret= (int*) getArgReference(stk, pci,0);
	bid= (int*) getArgReference(stk, pci,1);
	low= (ptr) getArgReference(stk, pci,2);
	if( argcnt>=7)
		hgh= (ptr) getArgReference(stk, pci,3);
	if( argcnt==9){
		li= (bit*) getArgReference(stk, pci,4);
		hi= (bit*) getArgReference(stk, pci,5);
	}
	
	
	if ((b = BATdescriptor(*bid)) == NULL) {
                throw(MAL, "REPselect", "Cannot access descriptor");
        }
	
	{int _tpe= ATOMstorage(b->ttype);
	 if( _tpe == TYPE_str || _tpe > TYPE_str ){
	 	if(low== 0 || *(str*)low==0) low = (str)str_nil;
			else low = *(str *)low;
		if(hgh== 0 || *(str*)hgh==0) hgh = (str)str_nil;
			else hgh = *(str *)hgh;
	}}

	clk= GDKusec();
	bn = BAT_select_(b, low, hgh, *li, *hi, TRUE, FALSE);
	clk= GDKusec()-clk;

        BBPreleaseref(b->batCacheid);
        if (bn) {
                if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ);
                *ret = bn->batCacheid;
                BBPincref(bn->batCacheid,TRUE);
        }
        else throw(MAL, "REPselect", "GDKerror");

	/* decide about replica */
	/* Currently just keep stat */

	cnt= BATcount(bn);
	assureSpace();
	r = repltable + replnr;
	r->resbid = *ret;
	r->sname = GDKstrdup((str) getArgReference(stk, pci,argcnt-3));
	r->tname = GDKstrdup((str) getArgReference(stk, pci,argcnt-2));
	r->cname = GDKstrdup((str) getArgReference(stk, pci,argcnt-1));

	VALset(&r->low,b->ttype,(ValPtr) low);
	VALset(&r->hgh,b->ttype,(ValPtr) hgh);
	r->li = *li;
	r->hi = *hi; 
	r->cnt = cnt;
	r->cost = clk;
	replnr++;
	BBPkeepref(*ret);

	return MAL_SUCCEED;
}
@}
