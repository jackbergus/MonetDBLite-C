@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
@' Copyright August 2008-2009 MonetDB B.V.
@' All Rights Reserved.

@f opt_replicator
@- Database replication
The replicator optimizer supports distribution of the 
updates on an SQL database to be distributed over multiple
destination databases.
The databases can be running on one system, or widely apart,
as long as they are being managed by a Merovingian process.

Further details are given in the replicator module code.
@{
@mal
pattern optimizer.replicator():str
address OPTreplicator;
pattern optimizer.replicator(mod:str, fcn:str):str
address OPTreplicator
comment "Replication optimizer";
@h
#ifndef _OPT_REPLICATOR_
#define _OPT_REPLICATOR_
#include "opt_prelude.h"
#include "opt_support.h"
#include "mal_interpreter.h"
#include "mal_instruction.h"
#include "mal_function.h"

/* #define DEBUG_REPLICATOR      trace its behavior */

@c
#include "mal_config.h"
#include "opt_replicator.h"

static int 
OPTreplicatorImplementation(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	int clt, x, i, j, version, limit, slimit;
	InstrPtr w, q, p=0, *old= mb->stmt;
	str dbname= GDKgetenv("gdk_dbname");
	char nme[IDLENGTH] = {"rmtobj"};
	int rmtobj= getTypeIndex(nme,6,TYPE_str);

	(void) pci;
	(void) stk;		/* to fool compilers */

	(void) cntxt;

	limit= mb->stop;
	slimit = mb->ssize;
	newMalBlkStmt(mb, mb->ssize); /* a new statement stack */

	pushInstruction(mb, old[0]);
	
	/* open connection with master*/
	p= newStmt(mb,remoteRef,putName("create",6));
	p= pushStr(mb,p,dbname);
	p= pushStr(mb,p,"localhost");
	p= pushInt(mb,p, atoi(GDKgetenv("mapi_port")));
	p= pushStr(mb,p,dbname);
	p= pushStr(mb,p,"monetdb");
	p= pushStr(mb,p,"monetdb");
	/* ignore duplicate connection error */
	p= newCatchStmt(mb,"MALException");
	p= newExitStmt(mb,"MALException");
	
	p= newStmt(mb,replicatorRef,putName("setVersion",10));
	pushLng(mb,p,0);

	/* x:= remote.put(clientindex) a connection error now becomes fatal */
	p= newStmt(mb,remoteRef,putRef);
	setArgType(mb,p,0,rmtobj);
	clt= getArg(p,0);
	p= pushStr(mb,p,dbname);
	pushInt(mb,p,cntxt->idx);

	/* id:rmtobj:= remote.exec("mastername","sql","getVersion");*/
	p= newStmt(mb,remoteRef,execRef);
	p= pushStr(mb,p,dbname);
	p= pushStr(mb,p,sqlRef);
	p= pushStr(mb,p,"getVersion");
	pushArgument(mb,p,clt);
	i= getArg(p,0);

	/* version:lng := remote.get("master",id);*/
	p= newStmt(mb,remoteRef,getRef);
	p= pushStr(mb,p,dbname);
	p= pushArgument(mb,p,i);
	setArgType(mb,p,0,TYPE_lng);
	version = getArg(p,0);

	for (i = 1; i < limit; i++){
		p= old[i];
		if (getModuleId(p)==sqlRef &&
			(getFunctionId(p) == bindRef ||
			 getFunctionId(p) == binddbatRef) ){
			x = getArg(p,0);
			w= newInstruction(mb,ASSIGNsymbol);
			getArg(w,0)= newTmpVariable(mb,TYPE_any);
			setModuleId(w, remoteRef);
			setFunctionId(w, execRef);
			w= pushStr(mb,w,dbname);
			w= pushStr(mb,w,getModuleId(p));
			w= pushStr(mb,w,getFunctionId(p));

			pushArgument(mb,w,clt);
			for ( j=p->retc; j<p->argc; j++){
				q= newStmt(mb,remoteRef,putRef);
				q= pushStr(mb,q,dbname);
				q= pushArgument(mb,q,getArg(p,j));
				w= pushArgument(mb,w,getArg(q,0));
				setArgType(mb,q,0,rmtobj);
			}

			q= newStmt(mb,remoteRef,putRef);
			q= pushStr(mb,q,dbname);
			q= pushArgument(mb,q,version);
			w= pushArgument(mb,w,getArg(q,0));

			q= newStmt(mb,remoteRef,putRef);
			q= pushStr(mb,q,dbname);
			q= pushLng(mb,q,0);
			w= pushArgument(mb,w,getArg(q,0));

			pushInstruction(mb, w);

			q = newStmt(mb,remoteRef,getRef);
			q = pushStr(mb,q,dbname);
			pushArgument(mb,q,getArg(w,0));
			getArg(q,0)= x;
			freeInstruction(p);
		} else
			pushInstruction(mb, p);
	}

	for(; i<slimit; i++)
		if( old[i])
			freeInstruction(old[i]);
	GDKfree(old);
	return 1;
}
@include optimizerWrapper.mx
@h
@:exportOptimizer(replicator)@
#endif
@c
#include "opt_statistics.h"
@:wrapOptimizer(replicator,OPT_CHECK_ALL)@
@}
