@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2008 CWI.
@' All Rights Reserved.

@f opt_replicator
@- The replicator
The replicator is an optimizer and runtime support
module to re-use operation results against persistent columns.
It is developed primarilly for the SQL front-end.

The following patterns are the target:
@verbatim
_3:bat[:oid,:bte]  := sql.bind(_4="sky", _5="photoobjall", _6="mode", _7=0) ]
_9 := algebra.uselect(_3=<tmp_30445>bat[:oid,:bte]{200276}, _8=1) ]

_20:bat[:oid,:lng]  := sql.bind(_4="sky", _5="photoobjall", _21="fieldid", _7=0) ]
_22 := algebra.joinPath(_19=<~tmp_33363>bat[:oid,:oid]{57328}, _12=<~tmp_33364>bat[:oid,:oid]{149491}, _20=<tmp_31311>bat[:oid,:lng]{200276}) ]

@end verbatim

The replicator comes with a few controlling operators
to experiment with its effect in concrete settings.
@{
@mal
pattern optimizer.replicator():str
address OPTreplicator;
pattern optimizer.replicator(mod:str, fcn:str):str
address OPTreplicator
comment "Replicator code injection";

module replicator;

pattern replicator.select(b:bat[:any_1,:any_2],value:any_2,sname:str,tname:str,cname:str):bat[:any_1,:any_2]
address REPselect
comment "The overloaded select operator for replicated operations";

pattern replicator.select(b:bat[:any_1,:any_2],low:any_2,hgh:any_2,sname:str,tname:str,cname:str):bat[:any_1,:any_2]
address REPselect
comment "The overloaded select operator for replicated operations";

pattern replicator.select(b:bat[:any_1,:any_2],low:any_2,hgh:any_2,li:bit,hi:bit,sname:str,tname:str,cname:str):bat[:any_1,:any_2]
address REPselect
comment "The overloaded select operator for replicated operations";

pattern replicator.uselect(b:bat[:any_1,:any_2],value:any_2,sname:str,tname:str,cname:str):bat[:any_1,:oid ]
address REPuselect
comment "The overloaded uselect operator for replicated operations";

pattern replicator.uselect(b:bat[:any_1,:any_2],low:any_2,hgh:any_2,sname:str,tname:str,cname:str):bat[:any_1,:oid]
address REPuselect
comment "The overloaded uselect operator for replicated operations";

pattern replicator.uselect(b:bat[:any_1,:any_2],low:any_2,high:any_2,li:bit,hi:bit,sname:str,tname:str,cname:str):bat[:any_1,:oid] 
address REPuselect
comment "The overloaded uselect operator for replicated operations";

command replicator.init():void
address REPinit
comment "Initialize replica table";

command replicator.dump():void
address REPdump
comment "Dump summary of replica table for potential re-use benefits";

command replicator.stat():void
address REPstat
comment "Estimate of potential replica benefit";

command replicator.setRetainPolicy(p:sht):void
address REPsetRetain
comment "Set replica retainment policy";

command replicator.setReusePolicy(p:sht):void
address REPsetReuse
comment "Set replica reuse policy";

command replicator.setCachePolicy(p:sht):void
address REPsetCache
comment "Set replica cache policy";



@h
#ifndef _OPT_REPLICATOR_
#define _OPT_REPLICATOR_
#include "opt_prelude.h"
#include "opt_support.h"
#include "mal_interpreter.h"

opt_export str REPselect(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
opt_export str REPuselect(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
opt_export str REPinit(void);
opt_export str REPdump(int *ret);
opt_export str REPstat(int *ret);
opt_export str REPsetRetain(int *ret, sht *p);
opt_export str REPsetReuse(int *ret, sht *p);
opt_export str REPsetCache(int *ret, sht *p);

/* #define DEBUG_OPT_REPLICATOR  */
@-
@c
#include "mal_config.h"
#include "opt_replicator.h"

typedef struct REPLICAREC {
	str sname, tname, cname;	/* source BAT schema, table, column */
        bat resbid;		/* intermediate result BAT */
	int tpe;		
	bit tail;		/* does result include tail */

        ValRecord low,hgh;	/* selected tail range */
        bit li, hi;		/* inclusive bits */
        size_t cnt;     	/* how many tuples */
	dbl cost;		/* how much time was spent to produce */
	int ucnteq,ucntsub;	/* usage counts equality and subset */
	MalBlkPtr malblk;	/* mal instruction block*/
} *Replica, ReplicaRec;

static Replica repltable = NULL;
static int replsz = 0;  /* alloc. mem */
static int replnr = 0;	/* number of replicas */
static sht retain = 0;  /* replica retainment policy
			0: baseline, keeps stat, no retain, no reuse
			1: infinite case, retain all
			2: cost-based, retain if beneficial */
static sht reuse = 0;	/* replica reuse policy
			0: baseline, keeps stat, no retain, no reuse
			1: reuse smallest covering
			2: reuse closest covering */
static sht rcache = 0;  /* replica cache management policy
			0: baseline, do nothing
			1: throw LRU
			2: cost-based, throw least beneficial */


static void assureSpace(){
	if ( replsz == 0){
		replsz = 16;
		repltable = (ReplicaRec*)GDKzalloc((replsz)*sizeof(ReplicaRec));
	}
	else if( replnr == replsz){
		replsz <<=1;
		repltable = (ReplicaRec*) GDKrealloc((void*)repltable,
				 sizeof(ReplicaRec) * replsz);
	}
}

str
REPinit(){
	str msg= MAL_SUCCEED;

        if ( repltable != NULL){
		GDKfree(repltable);
                replsz = replnr = 0;
        }
	assureSpace();
	return msg;
}

static void printReplica(stream *f, int i){

	Replica r = repltable+i;
	if (r==NULL) GDKerror("Empty replica element");
	stream_printf(f,"%s\t%s\t%s\t", r->sname, r->tname, r->cname);
	VALprint(f,&r->low);
	stream_printf(f,":"); VALprint(f,&r->hgh);
	stream_printf(f,"\t[%d:%d]\t", r->li,r->hi);
	stream_printf(f,"%d\t%8.2f ms\t", r->cnt,r->cost/1000.0);
	stream_printf(f,"%d:%d\n", r->ucnteq,r->ucntsub);
}

str
REPdump(int *ret)
{
	int i;
	(void) ret;
	stream_printf(GDKout,"Number of replicas %d\n",replnr);
	stream_printf(GDKout,"Schema\tTable\t\tColumn\tLow : High\t[LI : HI]\tCnt\tCost\tEq : Sub\n");
	for( i=0; i<replnr; i++)
		printReplica(GDKout, i);
	return MAL_SUCCEED;
}

str
REPstat(int *ret)
{
	int i;
	dbl ben = 0;
	(void) ret;
	stream_printf(GDKout,"Number of replicas %d\n",replnr);
	for( i=0; i<replnr; i++){
		if( repltable[i].ucnteq>0 )
			ben+= repltable[i].ucnteq * repltable[i].cost;
		if( repltable[i].ucntsub>0 ) /* approx benefit of subset reuse */
			ben+= repltable[i].ucnteq * repltable[i].cost * 0.5;
	}
	stream_printf(GDKout,"Potential benefit from %d replicas %10.2f ms\n",replnr,ben/1000.0);
	return MAL_SUCCEED;
}

str
REPsetRetain(int *ret, sht *p)
{
	(void) ret;
	retain = *p;
	return MAL_SUCCEED;
}

str
REPsetReuse(int *ret, sht *p)
{
	(void) ret;
	reuse = *p;
	return MAL_SUCCEED;
}

str
REPsetCache(int *ret, sht *p)
{
	(void) ret;
	rcache = *p;
	return MAL_SUCCEED;
}

static int
OPTreplicatorImplementation(MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	int i, actions=0, si;
	InstrPtr *old;
	int limit,slimit;
	sht v,v1;
	sht *ps, *pt, *pc ;
	ValPtr sv;


	(void) stk;
	ps= (sht*) alloca(sizeof(sht)* mb->vtop); /* bind schema */
	memset((char*) ps, 0, sizeof(sht)* mb->vtop);
	pt= (sht*) alloca(sizeof(sht)* mb->vtop); /* bind table */
	memset((char*) pt, 0, sizeof(sht)* mb->vtop);
	pc= (sht*) alloca(sizeof(sht)* mb->vtop); /* bind column */
	memset((char*) pc, 0, sizeof(sht)* mb->vtop);

	old= mb->stmt;
	limit= mb->stop;
	slimit= mb->ssize;
	newMalBlkStmt(mb,mb->ssize);

	for (i = 0; i<limit; i++){
		p= old[i];
		if( (getModuleId(p)== sqlRef && getFunctionId(p)==bindRef) ){
			v = getArg(p,0); /* bound var */
			ps[v]= getArg(p,1);
			pt[v]= getArg(p,2);
			pc[v]= getArg(p,3); 
		}
		if( getModuleId(p)== algebraRef && 
			( getFunctionId(p) == uselectRef ||
			  getFunctionId(p) == selectRef
			) && pc[getArg(p,1)]){
				v1 = getArg(p,1);
				sv = VALnew();
                                VALcopy(sv,&getVar(mb,ps[v1])->value);
                                si = defConstant(mb, TYPE_str, sv);
				p= pushArgument(mb,p,si);

				p= pushArgument(mb,p,pt[v1]);
                                p= pushArgument(mb,p,pc[v1]);

 
				setModuleId(p,replicatorRef);
				pushInstruction(mb,p);
		} else
			pushInstruction(mb,p);
	}
	for(; i<slimit; i++)
	if(old[i])
		freeInstruction(old[i]);
	GDKfree(old);
	return actions;
}
@include optimizerWrapper.mx
@h
@:exportOptimizer(replicator)@
#endif
opt_export str ALGreplicator(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
@c
#include "opt_statistics.h"
#include "../kernel/algebra.h"
@:wrapOptimizer(replicator,OPT_CHECK_ALL)@


static int findReplica( str sname, str tname, str cname, int tpe, bit tail,
	ptr low, ptr hgh, bit li, bit hi, sht * ov)
{
	Replica r;
	int (*cmp) (ptr, ptr);
	ptr nilptr, plow, phgh;
	int i, minr = -1;
	size_t minc = (size_t) GDK_lng_max;
	bit leq, lsub, heq, hsub;
	int rs[replnr], ri=0; /* subset replicas */

	cmp= BATatoms[tpe].atomCmp;
	nilptr = ATOMnilptr(tpe);


	for (i=0; i<replnr; i++){
		r = repltable + i;
			/* check compatibility */
		if( (strcmp(cname,r->cname)!=0) ||
			(strcmp(tname,r->tname)!=0) ||
			(strcmp(sname,r->sname)!=0) )
			continue;
		if (tail && !r->tail) continue;
		if (tpe != r->tpe) continue;

			/* check overlap */
		leq = lsub = heq = hsub = FALSE;
		plow = VALget(&r->low);
		phgh = VALget(&r->hgh);
		if( ((*cmp)(low, plow) == 0) && (li == r->li) ) leq = TRUE;
		else if( ((*cmp)(plow, nilptr)==0) ||
			 ((*cmp)(low, plow) > 0) ||
			 (((*cmp)(low, plow) == 0) && !li && r->li) ) lsub = TRUE;

		if( ((*cmp)(hgh, phgh) == 0) && (hi == r->hi) ) heq = TRUE;
		else if( ((*cmp)(phgh, nilptr)==0) ||
			 ((*cmp)(hgh, phgh) < 0) ||
			 (((*cmp)(hgh, phgh) == 0) && !hi && r->hi) ) hsub = TRUE;

		if (leq && heq) { /* equal replica exists */
			*ov = 0;
			return i;
		} else
		if ( (leq || lsub ) && (heq || hsub) ){ /* query is a subset of the replica */
			rs[ri] = i; ri++;
		}
	}


	if( ri ==0){ /* no replica overlaps with query */
		*ov = -1;
		return -1;
	} else {	/* search min replica overlaping with query */
		for( i=0; i<ri; i++){
			r = repltable + rs[i];
			if( r->cnt < minc){
				minc = r->cnt;
				minr = rs[i];
			}
		}
		*ov = 1;
		return minr;
	}

}



@-
The overloaded algebra operator simply calles the
underlying implementation and collects statistics on the
cost.
@c

static Replica newReplica(str sname, str tname, str cname, int tpe, bit tl)
{
	Replica r;
	
	assureSpace();
	r = repltable + replnr++;
	r->sname = GDKstrdup(sname);
	r->tname = GDKstrdup(tname);
	r->cname = GDKstrdup(cname);
	r->tail = tl;
	r->tpe =tpe;
	return r;
}

static void setReplicaRange(Replica r, int tpe, ptr low, ptr hgh, bit li, bit hi)
{
	if(r != NULL){
		if( tpe < TYPE_str){
		        VALset(&r->low,tpe, low);
			VALset(&r->hgh,tpe, hgh);
		} else
		if( tpe == TYPE_str){ 
			VALset(&r->low,tpe, GDKstrdup(low));
			VALset(&r->hgh,tpe, GDKstrdup(hgh));
		} 
		r->li = li;
		r->hi = hi;
	}
} 


static 
str REPselectImpl(int *ret, BAT *b, ptr low, ptr hgh, bit li, bit hi, 
		str sname, str tname, str cname, bit tl)
{
	int tpe, rr;
	BAT *bn, *br;
	lng cnt=0, clk = 0;
	Replica r;
	sht ov;

	tpe= ATOMstorage(b->T->type);

	/* replica match */
        rr = findReplica(sname,tname,cname,tpe,tl, low, hgh, li, hi, &ov);

	/* execute selection if needed */
	if((retain == 0) || 	/* normal execution + keep stat */
	   ((retain == 1) && (ov < 0))){	/* no overlap in exist. repl. */
		clk = GDKusec();
		bn = BAT_select_(b, low, hgh, li, hi, tl, FALSE);
		clk = GDKusec()-clk;

                if (bn) {
        	        if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ);
                	*ret = bn->batCacheid;
			cnt= BATcount(bn);
	                BBPkeepref(*ret);
	        }
        	else throw(MAL, "REPselectImpl", "GDKerror");

	} else 
	if ((retain == 1) && (ov > 0)){	/* exec. over subset repl. */ 
                r = repltable + rr;
       	        r->ucntsub++;

               	if ((br = BATdescriptor(r->resbid)) == NULL) {
                       	throw(MAL, "REPselectImpl", "Cannot access replica descriptor");
                }
       	        clk= GDKusec();
               	bn = BAT_select_(br, low, hgh, li, hi, tl, FALSE);
                clk= GDKusec()-clk;

       	        BBPreleaseref(br->batCacheid);
		if (bn) {
                       	if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ);
                        *ret = bn->batCacheid;
			cnt = BATcount(bn);
       	                BBPkeepref(*ret);
               	}
                else throw(MAL, "REPselectImpl", "GDKerror");
	}

	if( cnt == 0 ) /* don't store empty intermediates */
		return MAL_SUCCEED;
		/* update replica table */
	if( ov < 0 ){			/* new intermed. -> new entry */
		r = newReplica(sname,tname,cname,tpe,tl);
		setReplicaRange(r,tpe,low,hgh,li,hi);
		r->cnt = cnt;
		r->cost = clk;
		r->ucnteq = r->ucntsub = 0;
		if( retain == 1){
	                r->resbid = *ret;
			BBPincref(*ret,TRUE);
		}
	} else
	if(ov == 0 ){		/* equality, reuse replica rr*/
		r = repltable + rr;
		r->ucnteq++;
		if( retain == 1 ){  
        		*ret = r->resbid;
                	BBPincref(*ret,TRUE);
		}
	} else {  	/* reuse replica rr to shrink selection,
			 make new entry for the result*/
		r = newReplica(sname,tname,cname,tpe,tl);
		setReplicaRange(r,tpe,low,hgh,li,hi);
		r->cnt = cnt;
		r->cost = clk;
		r->ucnteq = r->ucntsub = 0;
		if( retain == 1){
	         	r->resbid = *ret;
			BBPincref(*ret,TRUE);
		}
	}
	return MAL_SUCCEED;
}

static str
REPselect_wrap(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci, int uselect)
{
	int *ret, *bid, tpe;
	ptr low, hgh;
	bit t=TRUE,*li=&t,*hi=&t;
	BAT *b;
	sht argcnt = pci->argc;
	str sname, tname, cname;

	(void) mb;
	ret= (int*) getArgReference(stk, pci,0);
	bid= (int*) getArgReference(stk, pci,1);
	low= (ptr) getArgReference(stk, pci,2);
	if( argcnt >= 7)
                hgh = (ptr) getArgReference(stk,pci,3);
        else hgh = low;

	if( argcnt==9){
		li= (bit*) getArgReference(stk, pci,4);
		hi= (bit*) getArgReference(stk, pci,5);
	}
	
	if ((b = BATdescriptor(*bid)) == NULL) {
                throw(MAL, uselect ? "REPuselect" : "REPselect", "Cannot access descriptor");
        }
	
	tpe= ATOMstorage(b->T->type);
        if( tpe == TYPE_str || tpe > TYPE_str ){
                if(low== 0 || *(str*)low==0) low = (str)str_nil;
                        else low = *(str *)low;
                if(hgh== 0 || *(str*)hgh==0) hgh = (str)str_nil;
                        else hgh = *(str *)hgh;
        }

	sname = *(str *) getArgReference(stk, pci,argcnt-3);
	tname = *(str *) getArgReference(stk, pci,argcnt-2);
	cname = *(str *) getArgReference(stk, pci,argcnt-1);
	
	REPselectImpl(ret, b, low, hgh, *li, *hi, sname,tname,cname, uselect ? FALSE : TRUE);
	BBPreleaseref(b->batCacheid);
	return MAL_SUCCEED;
}


str
REPselect(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	return REPselect_wrap(mb, stk, pci, 0);
}

str
REPuselect(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	return REPselect_wrap(mb, stk, pci, 1);
}

@}
