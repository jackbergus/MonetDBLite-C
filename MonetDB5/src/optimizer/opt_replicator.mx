@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2008 CWI.
@' All Rights Reserved.

@f opt_replicator
@- The replicator
Query optimization and processing in off-the-shelf database systems is often
still focus on individual queries. The queries are analysed in isolation
and ran against a kernel regardless opportunities offered by concurrent or
previous invocations.

This approach is far from optimal and two directions to improve
are explored: materialized views and (partial) result-set reuse.
Materialized views are derived from query logs. They represent
common sub-queries, whose materializaion and storage improves
subsequent processing time.
Re-use of (partial) results is used in those cases where a
zoomin-in or navigational application is at stake.

The Recycler module extends it with a the middle out approach.
It exploits the materialize-all-intermediate approach MonetDB
by deciding to keep hold on them as long as deemed benificial.

The approach taken is to modify the MAL program, such that
a small group of instructions is replaced by an overloaded
version. Instructions become subject to the Recycler if
at least one of its arguments is BAT and all others are
either constants or variables already known in the Recycler.

Upon execution, the Recycler routines first check for
an up to date result to be picked up at no cost.
Otherwise. it evaluates the instruction and calls upon
policy functions to decide if it is worthwhile to
keep.

The Recycler is developed primarilly for the SQL front-end,
where we expect significant improvements for running the
large SkyServer queries.

The following patterns are the target:
@verbatim
_3:bat[:oid,:bte]  := sql.bind(_4="sky", _5="photoobjall", _6="mode", _7=0) ]
_9 := algebra.uselect(_3=<tmp_30445>bat[:oid,:bte]{200276}, _8=1) ]

_20:bat[:oid,:lng]  := sql.bind(_4="sky", _5="photoobjall", _21="fieldid", _7=0) ]
_22 := algebra.joinPath(_19=<~tmp_33363>bat[:oid,:oid]{57328}, _12=<~tmp_33364>bat[:oid,:oid]{149491}, _20=<tmp_31311>bat[:oid,:lng]{200276}) ]

@end verbatim

The Recycler comes with a few controlling operators
to experiment with its effect in concrete settings.
@{
@mal
pattern optimizer.replicator():str
address OPTreplicator;
pattern optimizer.replicator(mod:str, fcn:str):str
address OPTreplicator
comment "Replicator code injection";

@-
The number of overloaded instructions is kept to a minimum.
Actually, the Recycler should be a variation of the interpreter
which inspects the variable table for alternative results.
[hmm todo]
@mal
module replicator;


pattern replicator.bind(sname:str,tname:str,cname:str,access:int):bat[:oid,:any_1]
address REPbind
comment "The overloaded bind operator for replicated operations";

pattern replicator.bind_idxbat(sname:str,tname:str,iname:str,access:int):bat[:oid,:any_1]
address REPbindidx
comment "The overloaded bind index bat operator for replicated operations";

pattern replicator.select(b:bat[:any_1,:any_2],value:any_2):bat[:any_1,:any_2]
address REPselect
comment "The overloaded select operator for replicated operations";

pattern replicator.select(b:bat[:any_1,:any_2],low:any_2,hgh:any_2):bat[:any_1,:any_2]
address REPselect
comment "The overloaded select operator for replicated operations";

pattern replicator.select(b:bat[:any_1,:any_2],low:any_2,hgh:any_2,li:bit,hi:bit):bat[:any_1,:any_2]
address REPselect
comment "The overloaded select operator for replicated operations";

pattern replicator.uselect(b:bat[:any_1,:any_2],value:any_2):bat[:any_1,:oid ]
address REPuselect
comment "The overloaded uselect operator for replicated operations";

pattern replicator.uselect(b:bat[:any_1,:any_2],low:any_2,hgh:any_2):bat[:any_1,:oid]
address REPuselect
comment "The overloaded uselect operator for replicated operations";

pattern replicator.uselect(b:bat[:any_1,:any_2],low:any_2,high:any_2,li:bit,hi:bit):bat[:any_1,:oid] 
address REPuselect
comment "The overloaded uselect operator for replicated operations";

pattern replicator.markT(b:bat[:any_1,:any_2],base:oid):bat[:any_1,:oid] 
address REPmarkT
comment "The overloaded markT operator for intermediates reuse";

pattern replicator.reverse(b:bat[:any_1,:any_2]):bat[:any_2,:any_1]
address REPreverse
comment "The overloaded reverse operator for intermediates reuse";

pattern replicator.join(left:bat[:any_1,:any_2],right:bat[:any_2,:any_3]):bat[:any_1,:any_3]
address REPjoin
comment "The overloaded join operator for intermediates reuse";

pattern replicator.semijoin(left:bat[:any_1,:any_2],right:bat[:any_1,:any]):bat[:any_1,:any_2] 
address REPsemijoin
comment "The overloaded semijoin operator for intermediates reuse";


pattern replicator.start():void
address REPstart
comment "Initialize replica record of executed MAL block";

command replicator.stop():void
address REPstop
comment "Cleans replica bookkeeping";

@mal

command replicator.dump():void
address REPdump
comment "Dump summary of replica table for potential re-use benefits";

command replicator.setRetainPolicy(p:sht):void
address REPsetRetain
comment "Set replica retainment policy";

command replicator.setReusePolicy(p:sht):void
address REPsetReuse
comment "Set replica reuse policy";

command replicator.setCachePolicy(p:sht):void
address REPsetCache
comment "Set replica cache policy";


@h
#ifndef _OPT_REPLICATOR_
#define _OPT_REPLICATOR_
/*#define _DEBUG_REPLICATOR_*/
#include "mal.h"
#include "opt_prelude.h"
#include "opt_support.h"
#include "mal_interpreter.h"
#include "mal_profiler.h"



opt_export str REPbind(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
opt_export str REPbindidx(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
opt_export str REPselect(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
opt_export str REPuselect(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
opt_export str REPmarkT(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
opt_export str REPreverse(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
opt_export str REPjoin(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
opt_export str REPsemijoin(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
opt_export str REPdump(int *ret);
opt_export str REPstart(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
opt_export str REPstop(void);
opt_export str REPsetRetain(int *ret, sht *p);
opt_export str REPsetReuse(int *ret, sht *p);
opt_export str REPsetCache(int *ret, sht *p);

typedef str (*sqlbind_fptr)(int *bid, str *sname, str *tname, str *cname, int *access);
typedef struct _sql_functions {
	sqlbind_fptr sqlbind;
	sqlbind_fptr sqlbind_idx;
} sql_functions;

opt_export sql_functions sqlf;


@-
@c
#include "mal_config.h"
#include "opt_replicator.h"
#define isResStored(M,i) isVarKept(M, getArg(M->stmt[i],0))

/* repl. bookkeeping for current query execution */
typedef struct REPLICAREC {
	int ver;		/* version of replica table */
	int * vmap;		/* map of exec. variables to replica name space */
 } *Replica, ReplicaRec;

typedef struct STAT {
	lng ticks;		/* micro seconds spent */
	lng reuse;		/* number of uses */
	lng cnt;		/* result size in tuples */
	int instr; 	/*instruction where is return var */
} *StatPtr, StatRec;


sql_functions sqlf;

static MalBlkPtr repl = NULL;
static int replver = 0;  /* version of replica table */
static int replref = 0;  /* queries currently using repl */
static StatPtr replstat = NULL;  /* statistics for stored intermediates */
static int use_profiler = 0;

/*static int replnr = 0;  number of replicas */
static sht retain = 0;  /* replica retainment policy
			0: baseline, keeps stat, no retain, no reuse
			1: infinite case, retain all
			2: cost-based, retain if beneficial */
static sht reuse = 0;	/* replica reuse policy
			0: baseline, keeps stat, no retain, no reuse
			1: reuse smallest covering
			2: reuse closest covering */
static sht rcache = 0;  /* replica cache management policy
			0: baseline, do nothing
			1: throw LRU
			2: cost-based, throw least beneficial */


static void assureSpace()
{
	StatPtr olds;
	int sz;
	if ( repl == NULL){
		repl = newMalBlk(1000, 1000);
		replstat = (StatPtr)GDKzalloc(sizeof(StatRec)* 1000);
	} else 		/* sync the repl stat */
		if(repl->vtop + 1>= repl->vsize){
			olds = replstat;
			sz = repl->vtop + MAXVARS;
			replstat = (StatPtr)GDKzalloc(sizeof(StatRec)* sz);
			memcpy(replstat,olds,repl->vtop * sizeof(StatRec));
			GDKfree(olds);
		}
}

int* getMap(MalStkPtr s)
{
	Replica r;
	int i, vc;

	r = (Replica) s->blk->replica;
	vc = s->blk->vtop;
	if( r == NULL) {	/* first execution */
		r = (Replica) GDKzalloc(sizeof(ReplicaRec));
		r->ver = replver;
		r->vmap = (int*)GDKmalloc(sizeof(int)* vc);
		for(i=0; i<vc; i++)
			r->vmap[i] = -1;
		s->blk->replica = (ptr) r;
	} else
	if( r->ver != replver) { /* first execution after change of repl */       
		r->ver = replver;
		for(i=0; i<vc; i++)		/* reinit var. map */
			r->vmap[i] = -1;
	}	

	if( s->blk->replica )
		return (((Replica)s->blk->replica)->vmap);
	else return NULL;
}

str
REPstart(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{

	(void) mb;
	(void) pci;

	getMap(stk);
	replref++;
	return MAL_SUCCEED;
}


str REPstop(void)
{
	replref--;
	return MAL_SUCCEED;
}


str
REPdump(int *ret)
{
	str ps;
	InstrPtr p;
	int i, r;
	Client cntxt= MCgetClient();

	(void) ret;
	if ( repl != NULL){
		stream_printf(cntxt->fdout,"Ticks  Cnt  Reuse\tInstr\n");
		for (i = 0; i < repl->stop; i++){
			p = getInstrPtr(repl, i);
			r = getDestVar(p);
     			ps = instruction2str(repl,p, LIST_MAL_ALL);

			if( isVarKept(repl,r))
		        	stream_printf(cntxt->fdout,"%5.2f  %d  %d\t", replstat[r].ticks, replstat[r].cnt,replstat[r].reuse);
			else stream_printf(cntxt->fdout,"Not stored   \t");
			stream_printf(cntxt->fdout,"%s\n", ps);
	        	GDKfree(ps);
		}
		stream_printf(cntxt->fdout,"Replicator entries %d\n", repl->stop);
	}
	return MAL_SUCCEED;
}


str
REPsetRetain(int *ret, sht *p)
{
	(void) ret;
	retain = *p;
	(void)retain;
	return MAL_SUCCEED;
}

str
REPsetReuse(int *ret, sht *p)
{
	(void) ret;
	reuse = *p;
	(void)reuse;
	return MAL_SUCCEED;
}

str
REPsetCache(int *ret, sht *p)
{
	(void) ret;
	rcache = *p;
	(void)rcache;
	return MAL_SUCCEED;
}

static int
OPTreplicatorImplementation(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	int i, actions=0;
	InstrPtr *old;
	int limit,slimit, no_pr, rprof = 0, rs =0;
	sht *rep ;

	(void) cntxt;
	(void) stk;
	 /* vars bound to replicator commands */
	rep = (sht*) alloca(sizeof(sht)* mb->vtop);
	memset((char*) rep, 0, sizeof(sht)* mb->vtop);

	no_pr = (mb->profiler == NULL? 1:0);
	old= mb->stmt;
	limit= mb->stop;
	slimit= mb->ssize;
	newMalBlkStmt(mb,mb->ssize);

	for (i = 0; i<limit; i++){
		p= old[i];
		if( getModuleId(p)== sqlRef &&
			((getFunctionId(p)== bindRef) ||
			(getFunctionId(p)== bindidxRef)) ){
			if(no_pr && rprof ==0 && use_profiler){
				InstrPtr q;
				q = newStmt(mb,"profiler","start");
				setDestType(mb,q,TYPE_void);
				rprof = 1;
			}
			if(rs == 0){
				InstrPtr q;
				q = newStmt(mb,"replicator","start");
				setDestType(mb,q,TYPE_void);
			        rs = 1;
			}
			setModuleId(p,replicatorRef);
			pushInstruction(mb,p);
			rep[getArg(p,0)] = 1;
		} else
		if( getModuleId(p)== algebraRef && 
			( getFunctionId(p) == uselectRef ||
			  getFunctionId(p) == selectRef) &&
			 rep[getArg(p,1)]){
 				setModuleId(p,replicatorRef);
				pushInstruction(mb,p);
				rep[getArg(p,0)] = 1;
		} else
		if( getModuleId(p)== algebraRef && 
			getFunctionId(p) == markTRef &&
			rep[getArg(p,1)] &&
			isVarConstant(mb,getArg(p,2))){
				setModuleId(p,replicatorRef);
				pushInstruction(mb,p);
				rep[getArg(p,0)] = 1;
		} else
		if( getModuleId(p)== batRef && 
			getFunctionId(p) == reverseRef &&
			rep[getArg(p,1)]){
				setModuleId(p,replicatorRef);
				pushInstruction(mb,p);
				rep[getArg(p,0)] = 1;
		} else
		if( getModuleId(p)== algebraRef && 
			getFunctionId(p) == semijoinRef &&
			rep[getArg(p,1)] &&
			rep[getArg(p,2)]){
 				setModuleId(p,replicatorRef);
				pushInstruction(mb,p);
				rep[getArg(p,0)] = 1;
		} else
		if( getModuleId(p)== algebraRef && 
			getFunctionId(p) == joinRef &&
			rep[getArg(p,1)] &&
			rep[getArg(p,2)]){
 				setModuleId(p,replicatorRef);
				pushInstruction(mb,p);
				rep[getArg(p,0)] = 1;
		} else	/* avoid multiple starts of replicator due to inlining */
		if( getModuleId(p)== replicatorRef && 
			( getFunctionId(p) == startRef ||
			  getFunctionId(p) == stopRef)){
 				if( rs == 1) freeInstruction(p);
				else {  pushInstruction(mb,p);
					rs = 1;
				}
		} else	/* avoid multiple starts of profiler due to inlining */
		if( getModuleId(p)== profilerRef && 
			( getFunctionId(p) == startRef ||
			  getFunctionId(p) == stopRef)){
 				freeInstruction(p);
		} else {	
		 	if((getModuleId(p)== sqlRef && 
				getFunctionId(p)==resultSetRef) ||
				p->token == ENDsymbol){
				if( rs == 1){
					InstrPtr q;
					q = newStmt(mb,"replicator","stop");
					setDestType(mb,q,TYPE_void);	
					rs = 0;
				}
				if (no_pr && rprof == 1 && use_profiler){
					InstrPtr q;
					q = newStmt(mb,"profiler","stop");
					setDestType(mb,q,TYPE_void);
					rprof = 0;
				}
			}
			pushInstruction(mb,p);
		}
	}

	for(; i<slimit; i++)
	if(old[i])
		freeInstruction(old[i]);
	GDKfree(old);
	return actions;
}
@include optimizerWrapper.mx
@h
@:exportOptimizer(replicator)@
#endif
opt_export str ALGreplicator(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
@c
#include "opt_statistics.h"
#include "../kernel/algebra.h"
@:wrapOptimizer(replicator,OPT_CHECK_ALL)@


@-
The overloaded algebra operator simply calls the
underlying implementation and collects statistics on the
cost.
@c

static int newReplica(MalStkPtr s, InstrPtr p, bit keep)
{
	int i, j, k, c, bid, r; 
	ValPtr v, v1;
	InstrPtr p1;
	
	assureSpace();
	p1 = copyInstruction(p);
	for(i = 0; i< p->argc; i++){
		j = p->argv[i];
		v = &s->stk[j];
		c = fndConstant(repl, v);
		if ( c < 0 ){ 
			v1 = VALnew();
        	        VALcopy(v1,v);
			c = defConstant(repl, v1->vtype, v1);
		}
	 	setArg(p1,i,c);
	
		if ((i > 0) ||
		    ((i == 0) && keep)){
		
			if (v->vtype == TYPE_bat){
				bid = *(int*)VALget(v);
				BBPincref(bid,TRUE);
			}
		}
	}
	k = repl->stop;
	pushInstruction(repl,p1);
	r = getDestVar(p1);
	replstat[r].instr = k;
	if ( keep )
		setVarKept(repl,r); 
	else clrVarKept(repl,r); 
	if (s->blk->profiler)
		replstat[r].ticks = s->blk->profiler[getPC(s->blk,p)].ticks;
#ifdef _DEBUG_REPLICATOR_
        stream_printf(GDKout,"newReplica: %s\n",
		instruction2str(repl,p1, LIST_MAL_ALL));
#endif

	return k;
}

/* check for replica of instruction p in repl table */
int
findReplica(MalStkPtr s,InstrPtr p)
{
	int i, j, idx;
	int *vmap;
	InstrPtr q;
	
	if (repl == NULL) return -1;
	vmap = getMap(s);
	if( vmap == NULL)
		GDKerror("Variable map not initialized\n");
	for (i = 0; i < repl->stop; i++){
		q = getInstrPtr(repl,i);
		if((p->argc != q->argc) ||
		   (getFunctionId(p) != getFunctionId(q)))
			continue;
	
		for (j = p->retc; j < p->argc; j++){
			idx = getArg(p,j);
			if( vmap[idx] >=0 ){ /* symbol comp */
				if( vmap[idx] != getArg(q,j))
					goto notfound;
			} else 
			if( VALcmp(&s->stk[idx], &getVar(repl,getArg(q,j))->value) )
				goto notfound;
		}
		/* found a match */
		return i;

		notfound: continue;
	}
	return -1;

}


/*checks instruction p against repl. instruction q */
int
checkReplica(MalStkPtr s, InstrPtr p)
{	
	int j, idx;
	int *vmap;

	idx = getArg(p,0); 
	vmap = getMap(s);
	if( vmap[idx] >= 0 ){
		InstrPtr q = getInstrPtr(repl,replstat[vmap[idx]].instr);
		for (j = p->retc; j < p->argc; j++){
			idx = getArg(p,j);
			if( vmap[idx] >=0 ){ /* symbol comp */
				if( vmap[idx] != getArg(q,j))
				goto notfound;
			}  
			if( VALcmp(&s->stk[idx], &getVarConstant(repl,getArg(q,j))))
				goto notfound;
		}
		/* found a match */
		return 1;
	}
	notfound: return 0;
}

str
REPbind_wrap(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci, int idx)
{
	int *ret, *acc, ri, rv, *vmap;
	str msg;
	str *sname, *tname, *cname;

	(void) mb;
	ret= (int*) getArgReference(stk, pci,0);
	sname = (str*) getArgReference(stk, pci,1);
	tname = (str*) getArgReference(stk, pci,2);
	cname = (str*) getArgReference(stk, pci,3);
	acc = (int*) getArgReference(stk, pci,4);

	if(( sqlf.sqlbind == NULL) || ( sqlf.sqlbind_idx == NULL))
		throw(MAL, "REPbind_wrap", "sqlbind not set");
		/* always execute cheap bind */
	if( idx == 0 )
		msg = sqlf.sqlbind(ret, sname, tname, cname, acc);
	else
		msg = sqlf.sqlbind_idx(ret, sname, tname, cname, acc);

		/*  res var mapping */
	rv = getArg(pci,0); 
	vmap = getMap(stk);
	if( vmap[rv] < 0 ){ /*res var not mapped*/
		ri = findReplica(stk,pci); /* replica instr */
		if( ri < 0 ) 
			ri = newReplica(stk,pci,FALSE);
		vmap[rv] = getArg(repl->stmt[ri],0);
	}

	return msg;
}


str
REPbind(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	return REPbind_wrap(mb, stk, pci, 0);
}

str
REPbindidx(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	return REPbind_wrap(mb, stk, pci, 1);
}


static 
str REPselectImpl(int *ret, BAT *b, ptr low, ptr hgh, bit li, bit hi, 
		 bit tl, MalStkPtr s, InstrPtr p)
{
	BAT *bn;
	lng cnt = -1;
	int ri, rr, rv;
	int * vmap;

  	rv = getArg(p,0); 
	vmap = getMap(s);

	if( checkReplica(s,p) == 0)
		vmap[rv] = -1;
	
	if( vmap[rv] < 0 ){ 		/*res var not mapped*/
		ri = findReplica(s,p); 	/* replica instr */
		if(ri >= 0 && isResStored(repl,ri)){		/*reuse */ 
			rr = getArg(repl->stmt[ri],0);
			*ret = *(int *)getVarValue(repl,rr);
			BBPincref(*ret,TRUE);
			replstat[rr].reuse++;  
		} else { /* compute */
			if (tl)
				bn = BATselect_(b, low, hgh, li, hi);
			else
				bn = BATuselect_(b, low, hgh, li, hi);
	        	if (bn) {
       		        	if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ);
	        	       	*ret = bn->batCacheid;
				cnt= BATcount(bn);
                		BBPkeepref(*ret);
	        	}
       			else throw(MAL, "REPselectImpl", "GDKerror");
			if( ri < 0 ){	/* add replica item */
				ri = newReplica(s,p,TRUE);
				rr = getArg(repl->stmt[ri],0);
				replstat[rr].cnt = cnt;
			}
			else rr = getArg(repl->stmt[ri],0);
		} 
			/* set mapping after first exec */
		vmap[rv] = rr;
	}
	else {		/* check and reuse mapped var*/
		rr = vmap[rv];
		if( isVarKept(repl,rr) ){		/*reuse */ 
			*ret = *(int *)getVarValue(repl,rr);
			BBPincref(*ret,TRUE);
			replstat[rr].reuse++;  
		}
		else {	/* recompute */
			if (tl)
				bn = BATselect_(b, low, hgh, li, hi);
			else
				bn = BATuselect_(b, low, hgh, li, hi);
	        	if (bn) {
       		        	if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ);
	        	       	*ret = bn->batCacheid;
                		BBPkeepref(*ret);
	        	}
       			else throw(MAL, "REPselectImpl", "GDKerror");
		}
	}

	return MAL_SUCCEED;
}

static str
REPselect_wrap(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci, int uselect)
{
	int *ret, *bid, tpe;
	ptr low, hgh;
	bit t=TRUE,*li=&t,*hi=&t;
	BAT *b;
	sht argcnt = pci->argc;

	(void) mb;
	ret= (int*) getArgReference(stk, pci,0);
	bid= (int*) getArgReference(stk, pci,1);
	low= (ptr) getArgReference(stk, pci,2);
	if( argcnt >= 4)
                hgh = (ptr) getArgReference(stk,pci,3);
        else hgh = low;

	if( argcnt > 4){
		li= (bit*) getArgReference(stk, pci,4);
		hi= (bit*) getArgReference(stk, pci,5);
	}
	
	if ((b = BATdescriptor(*bid)) == NULL) {
                throw(MAL, uselect ? "REPuselect" : "REPselect", "Cannot access descriptor");
        }
	
	tpe= ATOMstorage(b->T->type);
        if( tpe == TYPE_str || tpe > TYPE_str ){
                if(low== 0 || *(str*)low==0) low = (str)str_nil;
                        else low = *(str *)low;
                if(hgh== 0 || *(str*)hgh==0) hgh = (str)str_nil;
                        else hgh = *(str *)hgh;
        }


	REPselectImpl(ret, b, low, hgh, *li, *hi, uselect ? FALSE : TRUE, stk, pci);
	BBPreleaseref(b->batCacheid);
	return MAL_SUCCEED;
}


str
REPselect(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	return REPselect_wrap(mb, stk, pci, 0);
}

str
REPuselect(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	return REPselect_wrap(mb, stk, pci, 1);
}





str
REPmarkT(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	int *ret, *bid, ri, rv, rr, *vmap;
	oid *base;
	str msg = MAL_SUCCEED;

	(void) mb;
	ret= (int*) getArgReference(stk, pci,0);
	bid= (int*) getArgReference(stk, pci,1);
	base= (oid*) getArgReference(stk, pci,2);

	rv = getArg(pci,0); 
	vmap = getMap(stk);

	if( checkReplica(stk,pci) == 0)
		vmap[rv] = -1;

	if( vmap[rv] < 0 ){ /*res var not mapped*/
		ri = findReplica(stk,pci); /* replica instr */
		if( ri < 0 ){
			msg = ALGtmark(ret, bid, base); 
			ri = newReplica(stk,pci,FALSE);
		} else {
			rr = getArg(repl->stmt[ri],0);
			if( isVarKept(repl,rr) )
				msg = ALGtmark(ret, bid, base);
			else {			/*reuse */ 
				*ret = *(int *)getVarValue(repl,rr);
				BBPincref(*ret,TRUE);
				replstat[rr].reuse++; 
			} 
		}	
		vmap[rv] = getArg(repl->stmt[ri],0); /*1st exec always maps */
	} else{
		rr = vmap[rv];
		if( isVarKept(repl,rr) ){		/*reuse */ 
			*ret = *(int *)getVarValue(repl,rr);
			BBPincref(*ret,TRUE);
			replstat[rr].reuse++;  
		}
		else 	/* recompute */
			msg = ALGtmark(ret, bid, base);
	}

	return msg;
}

str
REPreverse(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{

	int *ret, *bid, ri, rv, rr, *vmap;
	BAT *b, *bn = NULL;

	(void) mb;
	ret= (int*) getArgReference(stk, pci,0);
	bid= (int*) getArgReference(stk, pci,1);

	rv = getArg(pci,0); 
	vmap = getMap(stk);

	if( checkReplica(stk,pci) == 0)
		vmap[rv] = -1;

	if( vmap[rv] < 0 ){ 		/*res var not mapped*/
		ri = findReplica(stk,pci); 	/* replica instr */
		if(ri >= 0 && isResStored(repl,ri)){		/*reuse */ 
			rr = getArg(repl->stmt[ri],0);
			*ret = *(int *)getVarValue(repl,rr);
			BBPincref(*ret,TRUE);
			replstat[rr].reuse++;  
		} else { 			/* compute */
			if ((b = BATdescriptor(*bid)) == NULL) {
        	        throw(MAL, "bat.reverse", "Cannot access descriptor");
		        }
			bn = BATmirror(b);
		        if (bn) {
	                	*ret = bn->batCacheid;
		                BBPkeepref(bn->batCacheid);
		        } else
			throw(MAL, "REPreverse", "GDKerror");

			if( ri < 0 ){	/* add replica item */
				ri = newReplica(stk,pci,FALSE);
				rr = getArg(repl->stmt[ri],0);
			}
			else rr = getArg(repl->stmt[ri],0);
		} 
			/* set mapping after first exec */
		vmap[rv] = rr;
	}
	else {		/* check and reuse mapped var*/
		rr = vmap[rv];
		if( isVarKept(repl,rr) ){		/*reuse */ 
			*ret = *(int *)getVarValue(repl,rr);
			BBPincref(*ret,TRUE);
			replstat[rr].reuse++;  
		}
		else {				/* recompute */
			if ((b = BATdescriptor(*bid)) == NULL) {
        	        	throw(MAL, "bat.reverse", "Cannot access descriptor");
		        }
			bn = BATmirror(b);
		        if (bn) {
	                	*ret = bn->batCacheid;
		                BBPkeepref(bn->batCacheid);
		        } else
			throw(MAL, "REPreverse", "GDKerror");
		}
	}

/* TODO reuse branch of code can be dropped if we are sure that we never store and reuse reverse results ??*/  
	return MAL_SUCCEED;

}

str
REPjoin(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{

	int *ret, *lid, *rid;
	int ri, rv, rr, *vmap, cnt = 0;
	str msg = MAL_SUCCEED;

	(void) mb;
	ret = (int*) getArgReference(stk, pci,0);
	lid = (int*) getArgReference(stk, pci,1);
	rid = (int*) getArgReference(stk, pci,2);

	rv = getArg(pci,0); 
	vmap = getMap(stk);

	if( checkReplica(stk,pci) == 0)
		vmap[rv] = -1;
	
	if( vmap[rv] < 0 ){ 		/*res var not mapped*/
		ri = findReplica(stk,pci); 	/* replica instr */
		if(ri >= 0 && isResStored(repl,ri)){		/*reuse */ 
			rr = getArg(repl->stmt[ri],0);
			*ret = *(int *)getVarValue(repl,rr);
			BBPincref(*ret,TRUE);
			replstat[rr].reuse++;  
		} else { /* compute */
			msg = ALGjoin(ret, lid, rid);
			if( msg == MAL_SUCCEED )
				ALGcount_bat(&cnt, ret);
			if( ri < 0 ){	/* add replica item */
				ri = newReplica(stk,pci,TRUE);
				rr = getArg(repl->stmt[ri],0);
				replstat[rr].cnt = cnt;
			}
			else rr = getArg(repl->stmt[ri],0);
		} 
			/* set mapping after first exec */
		vmap[rv] = rr;
	}
	else {		/* check and reuse mapped var*/
		rr = vmap[rv];
		if( isVarKept(repl,rr) ){		/*reuse */ 
			*ret = *(int *)getVarValue(repl,rr);
			BBPincref(*ret,TRUE);
			replstat[rr].reuse++;  
		}
		else {	/* recompute */
			msg = ALGjoin(ret, lid, rid);	
		}
	}

	return msg;
}

str
REPsemijoin(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{

	int *ret, *lid, *rid;
	int ri, rv, rr, *vmap, cnt = 0;
	str msg = MAL_SUCCEED;

	(void) mb;
	ret = (int*) getArgReference(stk, pci,0);
	lid = (int*) getArgReference(stk, pci,1);
	rid = (int*) getArgReference(stk, pci,2);
	
	rv = getArg(pci,0); 
	vmap = getMap(stk);

	if( checkReplica(stk,pci) == 0)
		vmap[rv] = -1;
	
	if( vmap[rv] < 0 ){ 		/*res var not mapped*/
		ri = findReplica(stk,pci); 	/* replica instr */
		if(ri >= 0 && isResStored(repl,ri)){		/*reuse */ 
			rr = getArg(repl->stmt[ri],0);
			*ret = *(int *)getVarValue(repl,rr);
			BBPincref(*ret,TRUE);
			replstat[rr].reuse++;  
		} else { /* compute */
			msg = ALGsemijoin(ret, lid, rid);
			if( msg == MAL_SUCCEED )
				ALGcount_bat(&cnt, ret);
			if( ri < 0 ){	/* add replica item */
				ri = newReplica(stk,pci,TRUE);
				rr = getArg(repl->stmt[ri],0);
				replstat[rr].cnt = cnt;
			}
			else rr = getArg(repl->stmt[ri],0);
		} 
			/* set mapping after first exec */
		vmap[rv] = rr;
	}
	else {		/* check and reuse mapped var*/
		rr = vmap[rv];
		if( isVarKept(repl,rr) ){		/*reuse */ 
			*ret = *(int *)getVarValue(repl,rr);
			BBPincref(*ret,TRUE);
			replstat[rr].reuse++;  
		}
		else {	/* recompute */
			msg = ALGsemijoin(ret, lid, rid);	
		}
	}
	return msg;
}


@}
