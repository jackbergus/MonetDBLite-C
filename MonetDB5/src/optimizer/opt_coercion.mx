@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2006 CWI.
@' All Rights Reserved.

@f opt_coercion
@-
@- Coercion Removal
@{
@mal
pattern optimizer.coercions():str
address OPTcoercion;
pattern optimizer.coercions(mod:str, fcn:str):str
address OPTcoercion
comment "Handle simple type coercions";

@-
The key decision is to find the next statement that
changes the candidate. 
Beware that parameters could be changed as part of a call.
They are marked as unsafe.
@h
#ifndef _OPT_COERCION_
#define _OPT_COERCION_
#include "opt_prelude.h"
#include "mal_interpreter.h"
#include "opt_support.h"

/* #define DEBUG_OPT_REDUCE     show partial result */

#endif
@c
#include "opt_coercion.h"

static int
coercionOptimizerStep(MalBlkPtr mb, int i, InstrPtr p)
{
	int t, a, b;

	a = getArg(p, 0);
	b = getArg(p, 1);
	t = getVarType(mb, b);
	if( getVarType(mb,a) != t) return 0;
	if (strcmp(getFunctionId(p), ATOMname(t)) == 0) {
		removeInstruction(mb, p);
		replaceAlias(mb, i, mb->stop, a, b);
		return 1;
	}
	if (strcmp(getFunctionId(p), "int") == 0 && t == TYPE_int) {
		removeInstruction(mb, p);
		replaceAlias(mb, i, mb->stop, a, b);
		return 1;
	}
	if (strcmp(getFunctionId(p), "str") == 0 && t == TYPE_str) {
		removeInstruction(mb, p);
		replaceAlias(mb, i, mb->stop, a, b);
		return 1;
	}
	if (strcmp(getFunctionId(p), "oid") == 0 && t == TYPE_oid) {
		removeInstruction(mb, p);
		replaceAlias(mb, i, mb->stop, a, b);
		return 1;
	}
	if (strcmp(getFunctionId(p), "lng") == 0 && t == TYPE_lng) {
		removeInstruction(mb, p);
		replaceAlias(mb, i, mb->stop, a, b);
		return 1;
	}
	if (strcmp(getFunctionId(p), "sht") == 0 && t == TYPE_sht) {
		removeInstruction(mb, p);
		replaceAlias(mb, i, mb->stop, a, b);
		return 1;
	}
	if (strcmp(getFunctionId(p), "bit") == 0 && t == TYPE_bit) {
		removeInstruction(mb, p);
		replaceAlias(mb, i, mb->stop, a, b);
		return 1;
	}
	if (strcmp(getFunctionId(p), "dbl") == 0 && t == TYPE_dbl) {
		removeInstruction(mb, p);
		replaceAlias(mb, i, mb->stop, a, b);
		return 1;
	}
	if (strcmp(getFunctionId(p), "flt") == 0 && t == TYPE_flt) {
		removeInstruction(mb, p);
		replaceAlias(mb, i, mb->stop, a, b);
		return 1;
	}
	return 0;
}
static int
OPTcoercionImplementation(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	int i, k;
	InstrPtr p;
	int actions = 0;
	str calcRef= putName("calc",4);

	(void) pci;
	(void) stk;		/* to fool compilers */

	for (i = 1; i < mb->stop; i++) {
		p = getInstrPtr(mb, i);
		if (getModuleId(p) == NULL)
			continue;
		if (getModuleId(p)==calcRef && p->argc == 2) {
			k= coercionOptimizerStep(mb, i, p);
			actions += k;
			if( k) i--;
		}
	}
@-
This optimizer affects the flow, but not the type and declaration
structure
	optimizerCheckFlow(mb, "mal.coercionOptimizer", actions, GDKusec() - clk);
@c
	return actions;
}
@include optimizerWrapper.mx
@h
@:exportOptimizer(coercion)@
@c
@:wrapOptimizer(coercion)@
@}
