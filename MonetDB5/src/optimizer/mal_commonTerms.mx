@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2006 CWI.
@' All Rights Reserved.

@f mal_commonTerms
@a M. Kersten
@{
@mal
pattern optimizer.commonTerms():str
address QOTCToptimizer;
pattern optimizer.commonTerms(mod:any_1, fcn:any_2):str
address QOTCToptimizer
comment "Common sub-expression optimizer"
@h
#ifndef _MAL_STRENGTHREDUCTION_
#define _MAL_STRENGTHREDUCTION_
#include "mal_optimizer.h"

/* #define DEBUG_MAL_OPTIMIZER     show partial result */

opt_export str CToptimizer(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);

#endif
@c
#include "mal_commonTerms.h"
#include "mal_interpreter.h"	/* for showErrors() */
#include "mal_prelude.h"
@}
@-
@node Common Terms, Constant Expressions, Function Inliners,   Toolkit
@- Common Subexpression Elimination
Common subexpression elimination merely involves a scan through the 
program block to detect re-curring statements.
The key problem to be addressed is to make sure that the parameters involved
in the repeatative instruction are invariant. 

The analysis of @code{optimizer.commonTerms()}
is rather crude. All functions with possible side-effects on
their arguments should have been marked as 'unsafe'.
Their use within a MAL block breaks the dataflow graph for all 
objects involved (BATs, everything kept in boxes).
@-
The common subexpression optimizer locates backwards the identical 
instructions. 
It stops as soon as it has found an identical one. Before we can replace the 
expression with the variable(s) of the previous one, we should assure that
we haven;t passed a safety barrier.

@verbatim
    b:= bat.new(:int,:int);
    c:= bat.new(:int,:int);
    d:= algebra.select(b,0,100);
    e:= algebra.select(b,0,100);
    k1:= 24;
    k2:= 27;
    l:= k1+k2;
    l2:= k1+k2;
    l3:= l2+k1;
    optimizer.commonTerms();
@end verbatim
is translated into the code block where the first two instructions 
are not common, because they have side effects.
@verbatim
    b := bat.new(:int,:int);
    c := bat.new(:int,:int);
    d := algebra.select(b,0,100);
    e := d;
    l := calc.+(24,27);
    l3 := calc.+(l,24);
@end verbatim
@{
The current implementation is rather expensive nested-loop algorithm,
which does not perform well for large MAL blocks.
The search can be improved significantly by prefiltering.
For, equality of instruction implies that
all variables have been used before in a similar context.

Note, we skip the first instruction because it signifies the signature.
The last instruction signifies the end.

Before we look for common terms, we had to be assured
that all constants are already aligned.
@c
static 
void CTconstant(MalBlkPtr mb){
	int i,j;
	int *cst,*alias,top=0;
	InstrPtr p;

	cst= (int*) alloca(mb->vtop *sizeof(int));
	alias= (int*) alloca(mb->vtop *sizeof(int));

	for(i = 0; i< mb->vtop; i++)
	if( isConstant(mb,i) ){
		alias[i]= i;
		for(j=0; j<top; j++)
		if( getVarType(mb,i) == getVarType(mb,cst[j]) &&
			ATOMcmp(getVarType(mb,i),
				 VALget(&getVar(mb,i)->value),
				 VALget(&getVar(mb,cst[j])->value)) == 0){
			/* printf("found %d == %d\n",i, cst[j]);*/
			alias[i]= cst[j];
			break;
		}
		cst[top++]= i;
	}
	for( i=0; i< mb->stop; i++){
		p= getInstrPtr(mb,i);
		for(j=p->retc; j < p->argc; j++)
		if( isConstant(mb, getArg(p,j)) )
			getArg(p,j) = alias[getArg(p,j)];
	}
}
str
CToptimizer(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	int i, j, k, last;
	InstrPtr p, q;
	int actions = 0;
	int filter[1024];
	lng c;
	lng clk = GDKusec();

	(void) stk;
	if( mb->errors) {
		/* remove the CToptimizer request */
		if (pci)
			removeInstruction(mb, pci);
		return MAL_SUCCEED;
	}
	CTconstant(mb);
	memset((void*) filter, 0, 1024 * sizeof(int));
	setLifespan(mb);
	for (i = 1; i < mb->stop - 1; i++) {
		p = getInstrPtr(mb, i);
		c = p->argc;
		for(j=p->retc; j<p->argc; j++){
			c *= 4;
			if( !isConstant(mb,getArg(p,j)) )
				c += getArg(p,j);
		}
		
		if (filter[c & 1023] && p->retc != p->argc){
			last=1;
			for( j = p->retc; j<p->argc; j++)
			if( getVar(mb,getArg(p,j))->beginLifespan > last )
				last =getVar(mb,getArg(p,j))->beginLifespan;
			for (j = i - 1; j >= last; j--) {
				if (safetyBarrier(p, q = getInstrPtr(mb, j)))
					goto nxtCommonSubExpression;
#ifdef DEBUG_MAL_OPTIMIZER
				printInstruction(GDKout, mb, q, LIST_MAL_INSTR);
				printInstruction(GDKout, mb, p, LIST_MAL_INSTR);
				printf("%d, %d  %d %d ", i, j, 
					hasSameSignature(p, q), 
					hasSameArguments(mb, p, q));
				printf(" :%d %d %d %d\n", 
					!isUpdated(mb, i), 
					!hasCommonResults(p, q), 
					!hasSideEffects(p, TRUE),
					!hasSideEffects(q, TRUE));

#endif
				if (hasSameSignature(p, q) && 
					hasSameArguments(mb, p, q) && 
					!isUpdated(mb, i) && 
					!hasCommonResults(p, q) && 
					!hasSideEffects(p, TRUE) &&
					allTargetsVisible(mb,j,i) 
					) {
#ifdef DEBUG_MAL_OPTIMIZER
					if (MCgetClient()->debugOptimizer) {
						stream_printf(GDKout, "Found a common expression " "%d <-> %d\n", j, i);
						printInstruction(GDKout, mb, q, LIST_MAL_ALL);
						printInstruction(GDKout, mb, p, LIST_MAL_ALL);
					}
#endif
					clrFunction(p);
					p->token = ASSIGNsymbol;
					p->argc = p->retc + q->retc;
					for (k = 0; k < q->retc; k++)
						p->argv[p->retc + k] = q->argv[k];
#ifdef DEBUG_MAL_OPTIMIZER
					if (MCgetClient()->debugOptimizer) {
						stream_printf(GDKout, "common expression");
						printInstruction(GDKout, mb, p, LIST_MAL_ALL);
					}
#endif
					i = ARoptimizerStep(mb,i);
					actions++;
					goto nxtCommonSubExpression;
				}
			}
		}
		nxtCommonSubExpression:
			filter[c & 1023]= 1;
	}
	/* remove the CToptimizer request */
	if (pci)
		removeInstruction(mb, pci);
	optimizerCheck(mb, "mal.commonTerms", actions, GDKusec() - clk);
	return MAL_SUCCEED;
}

@- Optimizer code wrapper
@c
mal_export str QOTCToptimizer(MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
str QOTCToptimizer(MalBlkPtr mb, MalStkPtr stk, InstrPtr p){
	str	modnme;
	str	fcnnme;
	Module  scope=NULL;
	Symbol s= NULL;
	Client c= MCgetClient();

	/* handle the empty argument list */
	if( p->argc== 1){
		/* setLifespan(mb); they should do it themselves*/
		optimizerInit();
		CToptimizer(mb, stk, p);
		return MAL_SUCCEED;
	}
	if( stk != 0){
		modnme= (str)getArgValue(stk,p,1);
		fcnnme= (str)getArgValue(stk,p,2);
	} else {
		modnme= getArgDefault(mb,p,1);
		fcnnme= getArgDefault(mb,p,2);
	}
	scope = findModule(c->nspace,putName(modnme,strlen(modnme)) );
	if( scope)
		s= findSymbolInModule(scope,putName(fcnnme,strlen(fcnnme)));

	if( s == NULL) {
		char buf[1024];
		snprintf(buf,1024, "Could not find %s.%s\n",modnme,fcnnme);
		return throwMessage("commonTerms.optimizer",buf);
	}
	
	if( s->def->errors == 0){
		optimizerInit();
		CToptimizer(s->def,0,0);
	}
	if( p) 
		removeInstruction(mb, p);
	return MAL_SUCCEED;
}
@}
