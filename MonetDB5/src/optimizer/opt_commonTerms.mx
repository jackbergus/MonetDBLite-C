@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
@' Copyright August 2008-2009 MonetDB B.V.
@' All Rights Reserved.

@f opt_commonTerms
@a M. Kersten
@{
@mal
pattern optimizer.commonTerms():str
address OPTcommonTerms;
pattern optimizer.commonTerms(mod:any_1, fcn:any_2):str
address OPTcommonTerms
comment "Common sub-expression optimizer"
@h
#ifndef _OPT_COMMONTERMS_
#define _OPT_COMMONTERMS_
#include "opt_prelude.h"
#include "opt_support.h"

/* #define DEBUG_OPT_COMMONTERMS            show partial result */
/* #define DEBUG_OPT_COMMONTERMS_MORE       show detailed result */

@c
#include "mal_config.h"
#include "opt_commonTerms.h"
#include "mal_exception.h"
@}
@- Common Subexpression Elimination
Common subexpression elimination merely involves a scan through the 
program block to detect re-curring statements.
The key problem to be addressed is to make sure that the parameters involved
in the repeatative instruction are invariant. 

The analysis of @sc{optimizer.commonTerms()}
is rather crude. All functions with possible side-effects on
their arguments should have been marked as 'unsafe'.
Their use within a MAL block breaks the dataflow graph for all 
objects involved (BATs, everything kept in boxes).
@-
The common subexpression optimizer locates backwards the identical 
instructions. 
It stops as soon as it has found an identical one. Before we can replace the 
expression with the variable(s) of the previous one, we should assure that
we haven;t passed a non-empty barrier block.

@verbatim
    b:= bat.new(:int,:int);
    c:= bat.new(:int,:int);
    d:= algebra.select(b,0,100);
    e:= algebra.select(b,0,100);
    k1:= 24;
    k2:= 27;
    l:= k1+k2;
    l2:= k1+k2;
    l3:= l2+k1;
    optimizer.commonTerms();
@end verbatim
is translated into the code block where the first two instructions 
are not common, because they have side effects.
@verbatim
    b := bat.new(:int,:int);
    c := bat.new(:int,:int);
    d := algebra.select(b,0,100);
    e := d;
    l := calc.+(24,27);
    l3 := calc.+(l,24);
@end verbatim
@{
The current implementation is rather expensive nested-loop algorithm,
which does not perform well for large MAL blocks.
The search is improved significantly by prefiltering on the
function name and not searching beyond the last assignment to
the arguments.

The common term removal creates opportunities for alias removal,
which in turn could lead to common terms to be detected.
This is encoded as a call to the respective optimizers.

Note, we skip the first instruction because it always signifies the signature.
The last instruction signifies the end.

Pathological case require alias removal also to find dependents.
@verbatim
a:= e();
b:= e();
c:= f(a);
d:= f(b);
@end verbatim
@c
static int
OPTcommonTermsImplementation(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	int i, j, k, barrier= 0, last;
	InstrPtr p, q;
	int actions = 0;
	int limit, slimit;
	int *alias;
	InstrPtr *old;
	int *lastassigned;

	(void) cntxt;
	(void) stk;
	(void) pci;
	lastassigned = (int*) GDKzalloc(sizeof(int) * mb->vtop);
	if ( lastassigned == NULL)
		return 0;
	alias = (int*) GDKmalloc(sizeof(int) * mb->vtop);
	if ( alias == NULL){
		GDKfree(lastassigned);
		return 0;
	}
	for ( k=0;k<mb->vtop; k++)
		alias[k]=k;

#ifdef DEBUG_OPT_COMMONTERMS
	stream_printf(cntxt->fdout,"START COMMONTERMS\n");
	printFunction(cntxt->fdout, mb, 0, LIST_MAL_STMT);
#endif
	old = mb->stmt;
	limit = mb->stop;
	slimit = mb->ssize;
	if ( newMalBlkStmt(mb, mb->ssize) < 0){
		GDKfree(alias);
		GDKfree(lastassigned);
		return 0; 
	}

	for ( i = 0; i < limit; i++) {
		p = old[i];

		for ( k = 0; k < p->argc; k++)
			getArg(p,k) = alias[getArg(p,k)];

		if ( hasSideEffects(p, TRUE) )
			for ( k = p->retc; k < p->argc; k++)
				lastassigned[getArg(p,k)] = i;
@-
We have to also look for first 'assignments' of constant arguments.
@c
			for ( k = p->retc; k < p->argc; k++)
				if ( isVarConstant(mb,getArg(p,k)) && lastassigned[getArg(p,k)] == 0 )
					lastassigned[getArg(p,k)]=i;

		for ( k = 0; k < p->retc; k++)
			lastassigned[getArg(p,k)]=i;
@-
We look back in the code base to determine a candidate for
replacement. We don't have to look further back then the last
relevant assignment.
@c
		last=  0;
		for (j = p->retc; j<p->argc; j++)
			if (lastassigned[getArg(p,j)]> last)
				last= lastassigned[getArg(p,j)];

		pushInstruction(mb,p);
@-
Any non-empty barrier block signals the end of this optimizer,
the impact of the block can affect the common code.
@c
		barrier |= (p->barrier== BARRIERsymbol || p->barrier== CATCHsymbol) && old[i+1]->barrier!=EXITsymbol;
@-
Also block further optimization when you have seen an assert().
This works particularly for SQL, because it is not easy to track
the BAT identifier aliases to look for updates. The sql.assert
at least tells us that an update is planned.
Like all optimizer decisions, it is safe to stop.
@c
		barrier |= getFunctionId(p) == assertRef;
		if (p->token == ENDsymbol){
			/* wrap up the remainder */
			for(i++; i<limit; i++)
				if( old[i])
					pushInstruction(mb,old[i]);
			break;
		}
		if (p->token == NOOPsymbol || p->token == ASSIGNsymbol || barrier || p->retc == p->argc) {
			continue;
		}

		for (j = i - 1; j >= last; j--) 
			if ( (q=getInstrPtr(mb,j))->fcn == p->fcn && !hasSideEffects(q, TRUE)){
#ifdef DEBUG_OPT_COMMONTERMS_MORE
				stream_printf(cntxt->fdout,"CANDIDATE %d, %d  %d %d lookback %d ", i, j, 
					hasSameSignature(mb, p, q), 
					hasSameArguments(mb, p, q), last);
				printInstruction(cntxt->fdout, mb, 0, q, LIST_MAL_ALL);
				printInstruction(cntxt->fdout, mb, 0, p, LIST_MAL_ALL);
				stream_printf(cntxt->fdout," :%d %d=%d %d %d %d %d %d\n", 
					q->token != ASSIGNsymbol ,
					lastassigned[getArg(q,0)],i,
					!hasCommonResults(p, q), 
					!hasSideEffects(q, TRUE),
					isLinearFlow(q),
					isLinearFlow(p));
#endif
				if (safetyBarrier(p, q) ){
#ifdef DEBUG_OPT_COMMONTERMS_MORE
					stream_printf(cntxt->fdout,"safetybarrier reached\n");
#endif
					break;
				}
@-
Simple assignments are not replaced either. They should be
handled by the alias removal part. All arguments should
be assigned their value before instruction p.
@c
				if (hasSameSignature(mb, p, q) && 
					hasSameArguments(mb, p, q) && 
					!hasCommonResults(p, q) && 
					isLinearFlow(p) &&
					isLinearFlow(q)  
				   ) {
#ifdef DEBUG_OPT_COMMONTERMS
					stream_printf(cntxt->fdout, "Found a common expression " 
							"%d <-> %d\n", j, i);
					printInstruction(cntxt->fdout, mb, 0, q, LIST_MAL_ALL);
#endif
					clrFunction(p);
					p->argc = p->retc;
					for (k = 0; k < q->retc; k++){
						lastassigned[getArg(p,k)] = lastassigned[getArg(q,k)];
						alias[getArg(p,k)] = alias[getArg(q,k)];
						p= pushArgument(mb,p, alias[getArg(q,k)]);
					}
#ifdef DEBUG_OPT_COMMONTERMS
					stream_printf(cntxt->fdout, "COMMON MODIFIED EXPRESSION\n");
					printInstruction(cntxt->fdout, mb, 0, p, LIST_MAL_ALL);
#endif
					actions++;
					break; /* end of search */
				}
			}
	}
#ifdef DEBUG_OPT_COMMONTERMS
	stream_printf(cntxt->fdout, "MODIFIED PLAN %d\n",mb->errors);
	printFunction(cntxt->fdout, mb, 0, LIST_MAL_STMT);
#endif
	for(; i<slimit; i++)
		if( old[i])
			freeInstruction(old[i]);
	GDKfree(old);
	GDKfree(alias);
	GDKfree(lastassigned);
	OPTDEBUG
		if (actions)
			stream_printf(cntxt->fdout,"#opt_commonTerms: %d statements catched\n",actions);
	return actions;
}

@include optimizerWrapper.mx
@h
@:exportOptimizer(commonTerms)@
#endif
@c
#include "opt_statistics.h"
@:wrapOptimizer(commonTerms,OPT_CHECK_ALL)@
@}
