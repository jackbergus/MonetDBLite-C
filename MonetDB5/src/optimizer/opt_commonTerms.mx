@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
@' Copyright August 2008-2009 MonetDB B.V.
@' All Rights Reserved.

@f opt_commonTerms
@a M. Kersten
@{
@mal
pattern optimizer.commonTerms():str
address OPTcommonTerms;
pattern optimizer.commonTerms(mod:any_1, fcn:any_2):str
address OPTcommonTerms
comment "Common sub-expression optimizer"
@h
#ifndef _OPT_COMMONTERMS_
#define _OPT_COMMONTERMS_
#include "opt_prelude.h"
#include "opt_support.h"

/* #define DEBUG_OPT_COMMONTERMS         show partial result */

@c
#include "mal_config.h"
#include "opt_commonTerms.h"
#include "mal_exception.h"
@}
@- Common Subexpression Elimination
Common subexpression elimination merely involves a scan through the 
program block to detect re-curring statements.
The key problem to be addressed is to make sure that the parameters involved
in the repeatative instruction are invariant. 

The analysis of @sc{optimizer.commonTerms()}
is rather crude. All functions with possible side-effects on
their arguments should have been marked as 'unsafe'.
Their use within a MAL block breaks the dataflow graph for all 
objects involved (BATs, everything kept in boxes).
@-
The common subexpression optimizer locates backwards the identical 
instructions. 
It stops as soon as it has found an identical one. Before we can replace the 
expression with the variable(s) of the previous one, we should assure that
we haven;t passed a non-empty barrier block.

@verbatim
    b:= bat.new(:int,:int);
    c:= bat.new(:int,:int);
    d:= algebra.select(b,0,100);
    e:= algebra.select(b,0,100);
    k1:= 24;
    k2:= 27;
    l:= k1+k2;
    l2:= k1+k2;
    l3:= l2+k1;
    optimizer.commonTerms();
@end verbatim
is translated into the code block where the first two instructions 
are not common, because they have side effects.
@verbatim
    b := bat.new(:int,:int);
    c := bat.new(:int,:int);
    d := algebra.select(b,0,100);
    e := d;
    l := calc.+(24,27);
    l3 := calc.+(l,24);
@end verbatim
@{
The current implementation is rather expensive nested-loop algorithm,
which does not perform well for large MAL blocks.
The search is improved significantly by prefiltering on the
function name and not searching beyond the last assignment to
the arguments.

We should also immediately perform alias removal, because it
creates opportunities for additional rewrites.

Note, we skip the first instruction because it signifies the signature.
The last instruction signifies the end.
@c
static int
OPTcommonTermsImplementation(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	int i, j, k, barrier= 0, last;
	InstrPtr p, q;
	int actions = 0;
	MALfcn *mask;
	int limit, slimit;
	InstrPtr *old;
	int *lastassigned;
	Lifespan span= newLifespan(mb);

	int *alias= (int*) alloca(sizeof(int)* mb->vtop);

	for(i=0; i<mb->vtop; i++) 
		alias[i]=i;
	(void) cntxt;
	(void) stk;
	(void) pci;
	mask= (MALfcn *) alloca(mb->stop * sizeof(MALfcn));
	lastassigned = (int*) alloca(sizeof(int) * mb->vtop);
	memset((void*) lastassigned, 0, mb->vtop * sizeof(int));


#ifdef DEBUG_OPT_COMMONTERMS
	stream_printf(cntxt->fdout,"START COMMONTERMS\n");
	printFunction(cntxt->fdout, mb, 0, LIST_MAL_STMT);
#endif
	setLifespan(mb,span);
	old = mb->stmt;
	limit = mb->stop;
	slimit = mb->ssize;
	newMalBlkStmt(mb, mb->ssize); /* a new statement stack */
	for ( i = 0; i < limit; i++) {
		p = old[i];
		if ( hasSideEffects(p, TRUE) )
		for ( k = p->retc; k < p->argc; k++)
			lastassigned[getArg(p,k)] = i;
@-
We have to also look for first 'assignments' of constant arguments.
@c
		for ( k = p->retc; k < p->argc; k++)
		if ( isVarConstant(mb,getArg(p,k)) && lastassigned[getArg(p,k)] == 0 )
			lastassigned[getArg(p,k)]=i;

		for ( k = 0; k < p->retc; k++)
			lastassigned[getArg(p,k)]=i;
		mask[i]= p->fcn;
		pushInstruction(mb,p);
@-
A non-empty barrier block signals the end of this optimizer,
the impact of the block can affect the common code.
@c
		barrier |= (p->barrier== BARRIERsymbol || p->barrier== CATCHsymbol) &&
				old[i+1]->barrier!=EXITsymbol;
@-
Also block further optimization when you have seen an assert().
This works particularly for SQL, because it is not easy to track
the BAT identifier aliases to look for updates. The sql.assert
at least tells us that an update is planned.
Like all optimizer decisions, it is safe to stop.
@c
		barrier |= getFunctionId(p) == assertRef;
		if (p->token == ENDsymbol){
			if (actions)
				(void) newStmt(mb,optimizerRef, putName("aliases",7));
			/* wrap up the remainder */
			for(i++; i<limit; i++)
			if( old[i])
				pushInstruction(mb,old[i]);
			break;
		}
@-
First recognize simple assignments for alias removal
and apply alias propagation, before considering a match.
@c
		if( p->token == ASSIGNsymbol &&
			barrier == FALSE &&
			p->argc == 2 &&
			getLastUpdate(span,getArg(p,0)) == i &&
			getBeginLifespan(span,getArg(p,0)) == i &&
			getLastUpdate(span,getArg(p,1)) <= i ){
				alias[getArg(p,0)] = alias[getArg(p,1)];
				lastassigned[getArg(p,0)] = lastassigned[getArg(p,1)];
				continue;
		} 
		if (p->token == NOOPsymbol || p->token == ASSIGNsymbol || 
			barrier || p->retc == p->argc) {
			for(j=0; j<p->argc; j++)
				getArg(p,j) = alias[getArg(p,j)];
			continue;
		}
@-
We look back in the code base to determine a candidate for
replacement. We don't have to look further back then the last
relevant assignment. 
@c
		last= lastassigned[getArg(p,p->retc)];
		for (j = p->retc+1; j<p->argc; j++)
			if (lastassigned[getArg(p,j)]> last)
				last= lastassigned[getArg(p,j)];

		/* prepare for inclusion in the new block */
		for(j=0; j<p->argc; j++)
			getArg(p,j) = alias[getArg(p,j)];

		for (j = i - 1; j >= last && j>0; j--) 
		if ( mask[j]== p->fcn){
			 q = getInstrPtr(mb,j);
#ifdef DEBUG_OPT_COMMONTERMS
			printInstruction(cntxt->fdout, mb, 0, q, LIST_MAL_ALL);
			printInstruction(cntxt->fdout, mb, 0, p, LIST_MAL_ALL);
#endif
			if (safetyBarrier(p, q) )
				break;
#ifdef DEBUG_OPT_COMMONTERMS
			stream_printf(cntxt->fdout,"CANDIDATE %d, %d  %d %d lookback %d ", i, j, 
				hasSameSignature(mb, p, q), 
				hasSameArguments(mb, p, q), last);
			stream_printf(cntxt->fdout," :%d %d=%d %d %d %d %d %d\n", 
				q->token != ASSIGNsymbol ,
				getLastUpdate(span, getArg(p,0)),i,
				!hasCommonResults(p, q), 
				!hasSideEffects(q, TRUE),
				isLinearFlow(q),
				isLinearFlow(p),
				allTargetsVisible(mb,span,j,i-1));

#endif
@-
Simple assignments are not replaced either. They should be
handled by the alias removal part
@c
			if (hasSameSignature(mb, p, q) && 
				hasSameArguments(mb, p, q) && 
				getLastUpdate(span, getArg(p,0)) <= i &&
				!hasCommonResults(p, q) && 
				!hasSideEffects(p, TRUE) &&
				isLinearFlow(p) &&
				isLinearFlow(q) &&
				allTargetsVisible(mb,span,j,i-1) 
				) {
#ifdef DEBUG_OPT_COMMONTERMS
				stream_printf(cntxt->fdout, "Found a common expression " 
					"%d <-> %d\n", j, i);
				printInstruction(cntxt->fdout, mb, 0, q, LIST_MAL_ALL);
#endif
				clrFunction(p);
				p->token = ASSIGNsymbol;
				p->argc = p->retc + q->retc;
				for (k = 0; k < q->retc; k++)
					p->argv[p->retc + k] =  q->argv[k];
#ifdef DEBUG_OPT_COMMONTERMS
				stream_printf(cntxt->fdout, "COMMON MODIFIED EXPRESSION\n");
				printInstruction(cntxt->fdout, mb, 0, p, LIST_MAL_ALL);
#endif
				actions++;
				break; /* end of search */
			}
		}
	}
#ifdef DEBUG_OPT_COMMONTERMS
	chkProgram(cntxt->nspace,mb);
	stream_printf(cntxt->fdout, "MODIFIED PLAN %d\n",mb->errors);
	printFunction(cntxt->fdout, mb, 0, LIST_MAL_STMT);
#endif
	for(; i<slimit; i++)
	if( old[i])
		freeInstruction(old[i]);
	GDKfree(old);
	GDKfree(span);
	return actions;
}

@include optimizerWrapper.mx
@h
@:exportOptimizer(commonTerms)@
#endif
@c
#include "opt_statistics.h"
@:wrapOptimizer(commonTerms,OPT_CHECK_ALL)@
@}
