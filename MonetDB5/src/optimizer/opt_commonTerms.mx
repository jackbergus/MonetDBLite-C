@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
@' Copyright August 2008- MonetDB B.V.
@' All Rights Reserved.

@f opt_commonTerms
@a M. Kersten
@{
@mal
pattern optimizer.commonTerms():str
address OPTcommonTerms;
pattern optimizer.commonTerms(mod:any_1, fcn:any_2):str
address OPTcommonTerms
comment "Common sub-expression optimizer"
@h
#ifndef _OPT_COMMONTERMS_
#define _OPT_COMMONTERMS_
#include "opt_prelude.h"
#include "opt_support.h"

#define DEBUG_OPT_COMMONTERMS        /* show partial result */

@c
#include "mal_config.h"
#include "opt_commonTerms.h"
#include "mal_exception.h"
@}
@- Common Subexpression Elimination
Common subexpression elimination merely involves a scan through the 
program block to detect re-curring statements.
The key problem to be addressed is to make sure that the parameters involved
in the repeatative instruction are invariant. 

The analysis of @sc{optimizer.commonTerms()}
is rather crude. All functions with possible side-effects on
their arguments should have been marked as 'unsafe'.
Their use within a MAL block breaks the dataflow graph for all 
objects involved (BATs, everything kept in boxes).
@-
The common subexpression optimizer locates backwards the identical 
instructions. 
It stops as soon as it has found an identical one. Before we can replace the 
expression with the variable(s) of the previous one, we should assure that
we haven;t passed a safety barrier.

@verbatim
    b:= bat.new(:int,:int);
    c:= bat.new(:int,:int);
    d:= algebra.select(b,0,100);
    e:= algebra.select(b,0,100);
    k1:= 24;
    k2:= 27;
    l:= k1+k2;
    l2:= k1+k2;
    l3:= l2+k1;
    optimizer.commonTerms();
@end verbatim
is translated into the code block where the first two instructions 
are not common, because they have side effects.
@verbatim
    b := bat.new(:int,:int);
    c := bat.new(:int,:int);
    d := algebra.select(b,0,100);
    e := d;
    l := calc.+(24,27);
    l3 := calc.+(l,24);
@end verbatim
@{
The current implementation is rather expensive nested-loop algorithm,
which does not perform well for large MAL blocks.
The search is improved significantly by prefiltering on the
function name and not searching beyond the last assignment to
the arguments.

We should also immediately perform alias removal, because it
creates opportunities for additional rewrites.

Note, we skip the first instruction because it signifies the signature.
The last instruction signifies the end.
@c
static int
OPTcommonTermsImplementation(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	int i, j, k, barrier=0, last, n=1;
	InstrPtr p, q;
	int actions = 0;
	MALfcn *mask;
	int *alias,limit, slimit;
	InstrPtr *old;
	int *lastassigned;
	Lifespan span= newLifespan(mb);

	(void) cntxt;
	(void) stk;
	(void) pci;
	mask= (MALfcn *) alloca(mb->stop * sizeof(MALfcn));
	lastassigned = (int*) alloca(sizeof(int) * mb->vtop);
	memset((void*) lastassigned, 0, mb->vtop * sizeof(int));

	alias= (int*) alloca(sizeof(int)* mb->vtop);
	for(i=0; i<mb->vtop; i++) 
		alias[i]=i;

#ifdef DEBUG_OPT_COMMONTERMS
	stream_printf(cntxt->fdout,"START COMMONTERMS\n");
#endif
	setLifespan(mb,span);
	old = mb->stmt;
	limit = mb->stop;
	slimit = mb->ssize;
	newMalBlkStmt(mb, mb->ssize); /* a new statement stack */
	for ( n= i = 0; i < limit; i++) {
		p = old[i];
		if ( hasSideEffects(p, TRUE) )
		for ( k = p->retc; k < p->argc; k++)
			lastassigned[getArg(p,k)]=i;
		for ( k = 0; k < p->retc; k++)
			lastassigned[getArg(p,k)]=i;
		mask[n]= p->fcn;
		pushInstruction(mb,p);
		if(p->barrier)
			barrier= getArg(p,0); /* at least one barrier block */
		n++;
		if (p->token == ENDsymbol){
			/* wrap up the remainder */
			for(i++; i<limit; i++)
			if( old[i])
				pushInstruction(mb,old[i]);
			break;
		}
		if (p->token == NOOPsymbol || barrier) 
			continue;
@-
First recognize simple assignments for alias removal
and apply alias propagation, before considering a match.
@c
		if( p->token == ASSIGNsymbol &&
			barrier== 0 &&
			p->argc == 2 &&
			/* type compatible to be added */
			getArgType(mb,p,0)== getArgType(mb,p,1) &&
			getLastUpdate(span,getArg(p,0)) == i &&
			getBeginLifespan(span,getArg(p,0)) == i &&
			getLastUpdate(span,getArg(p,1)) <= i ){
					alias[getArg(p,0)] = alias[getArg(p,1)];
					lastassigned[getArg(p,0)] = lastassigned[getArg(p,1)];
					freeInstruction(p);
					mb->stop--;
					mb->stmt[mb->stop]=0;
					n--;
					continue;
			} 
		for(j=0; j<p->argc; j++)
			getArg(p,j) = alias[getArg(p,j)];
		if (p->retc != p->argc){
@-
We look back in the code base to determine a candidate for
replacement. We don't have to look further back then the last
relevant assignment. Beware, we may miss opportunities due to
multiple occurrences of the same constant in the symbol table.
@c
			last= lastassigned[getArg(p,p->retc)];
			for (j = p->retc+1; j<p->argc; j++)
				if (lastassigned[getArg(p,j)]> last)
					last= lastassigned[getArg(p,j)];

			for (j = (n-1) - 1; j >= last-(i-(n-1)) && j>0; j--) 
			if (mask[j] == p->fcn ){
				if (safetyBarrier(p, q = getInstrPtr(mb, j)))
					break;
#ifdef DEBUG_OPT_COMMONTERMS_1
				printInstruction(cntxt->fdout, mb, 0, q, LIST_MAL_ALL);
				printInstruction(cntxt->fdout, mb, 0, p, LIST_MAL_ALL);
				stream_printf(cntxt->fdout,"%d, %d  %d %d ", i, j, 
					hasSameSignature(mb, p, q), 
					hasSameArguments(mb, p, q));
				stream_printf(cntxt->fdout," :%d %d %d %d %d\n", 
					!hasCommonResults(p, q), 
					!hasSideEffects(p, TRUE),
					!hasSideEffects(q, TRUE),
					isLinearFlow(q),
					isLinearFlow(p));

#endif
@-
Simple assignments are not replaced either. They should be
handled by the alias removal part
@c
				if (q->token != ASSIGNsymbol && 
					hasSameSignature(mb, p, q) && 
					hasSameArguments(mb, p, q) && 
					getLastUpdate(span, getArg(p,0)) <= i &&
					!hasCommonResults(p, q) && 
					!hasSideEffects(p, TRUE) &&
					isLinearFlow(p) &&
					isLinearFlow(q) &&
					allTargetsVisible(mb,span,j,n-1) 
					) {
#ifdef DEBUG_OPT_COMMONTERMS
					stream_printf(cntxt->fdout, "Found a common expression " 
						"%d <-> %d\n", j, i);
					printInstruction(cntxt->fdout, mb, 0, q, LIST_MAL_ALL);
#endif
					clrFunction(p);
					p->token = ASSIGNsymbol;
					p->argc = p->retc + q->retc;
					for (k = 0; k < q->retc; k++)
						p->argv[p->retc + k] =  q->argv[k];
#ifdef DEBUG_OPT_COMMONTERMS
					stream_printf(cntxt->fdout, "COMMON MODIFIED EXPRESSION\n");
					printInstruction(cntxt->fdout, mb, 0, p, LIST_MAL_ALL);
#endif
					actions++;
					if( p->argc== 2 &&
						getLastUpdate(span,getArg(p,0)) == i &&
						getBeginLifespan(span,getArg(p,0)) == i &&
						getLastUpdate(span,getArg(p,1)) < i){
							alias[getArg(p,0)]= alias[getArg(p,1)];
							freeInstruction(p);
							mb->stop--;
							mb->stmt[mb->stop]=0;
							n--;
					}
					j= 0; /* end of search */
				}
			}
		}
	}
	for(; i<slimit; i++)
	if( old[i])
		freeInstruction(old[i]);
	GDKfree(old);
	GDKfree(span);
	return actions;
}

@include optimizerWrapper.mx
@h
@:exportOptimizer(commonTerms)@
#endif
@c
#include "opt_statistics.h"
@:wrapOptimizer(commonTerms,OPT_CHECK_ALL)@
@}
