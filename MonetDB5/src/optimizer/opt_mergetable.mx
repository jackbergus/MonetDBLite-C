@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2007 CWI.
@' All Rights Reserved.

@f opt_mergetable
@a M. Kersten
@- Merge Tables 
A merge association table (MAT) descriptor defines an ordered collection 
of type compatible BATs, whose union represents a single (virtual) BAT.
The MAT may represent a partitioned BAT (see BPM), but could also 
be an arbitrary collection of temporary BATs within a program fragment.

The MAT definition lives within the scope of a single block.
The MAT optimizer simply expands the plan to
deal with its components on an instruction basis.
Only when a blocking operator is encounted, the underlying BAT is materialized.

The MAT object can not be passed as an argument to any function
without first being materialized. Simply because
the MAT is not known by the type system and none of the lower
level operations is aware of their existence.

In the first approach of the MAT optimizer we assume that the 
first BAT in the MAT sequence is used as an accumulator.
Furthermore, no semantic knowledge is used to reduce the
possible superflous (semi)joins. Instead, we limit expansion
to a single argument. 
This is changed at a later stage when a cost-based evaluation
be decide differently.

To illustrate, consider:
@example
	m0:= bat.new(:oid,:int);
	m1:= bat.new(:oid,:int);
	m2:= bat.new(:oid,:int);
	b := mat.new(m0,m1,m2);
	s := algebra.select(b,1,3);
	i := algebra.count(s);
	io.print(s);
	io.print(i);
	c0 := bat.new(:int,:int);
	c1 := bat.new(:int,:int);
	c := mat.new(c0,c1);
	j := algebra.join(b,s);
	io.print(j);
@end example

The selection and aggregate operations can simply be rewritten using a MAT:
@example
	_33 := algebra.select(m0,1,3);
	_34 := algebra.select(m1,1,3);
	_35 := algebra.select(m2,1,3);
    s := mat.new(_33,_34,_35);
    i := 0:int;
    _36 := aggr.count(_33);
    i := calc.+(i,_36);
    _37 := aggr.count(_34);
    i := calc.+(i,_37);
    _38 := aggr.count(_35);
    i := calc.+(i,_38);
    io.print(i);
@end example

The print operation does not have MAT semantics yet.
It requires a function that does not produce the header
with each call.
Instead, we can also pack the elements before printing.
@example
    s := mat.pack(_33,_34,_35);
    io.print(s);
@end example
For the join we have to generate all possible combinations,
not knowing anything about the properties of the components.
The current heuristic is to limit expansion to a single
argument. This leads to 
@example
    b := mat.pack(m0,m1,m2);
    _39 := algebra.join(b,c0);
    _40 := algebra.join(b,c1);
    j := mat.new(_39,_40);
@end example

The drawback of the scheme is the potential explosion in MAL statements.
A challenge of the optimizer is to find the minimum by inspection of
the properties of the MAT elements. For example, it might attempt
to partially pack elements before proceding. This would be a runtime
scheduling decision.

Alternative, the system could use MAT iterators to avoid it.
At the cost of more complex program analysis afterwards.

@example
	ji:= bat.new(:oid,:int);
barrier b:= mat.newIterator(m0,m1,m2);
barrier c:= mat.newIterator(c0,c1);
	ji := algebra.join(b,c);
	bat.insert(j,ji);
	redo c:= mat.newIterator(c0,c1);
	redo b:= mat.newIterator(m0,m1,m2);
exit c;
exit b;
@end example

@{
Also consider the MAT as a variable property. This is needed
to pass a MAT as an argument to functions. If the function does
not accept a MAT, the argument should be packed, otherwise
we can simply let it pass.

We have to add routines to deal with duplicate elimination.
Moreover, the other optimizers should become aware of the MAT
operations. The operations mat.new() and mat.range() can be
removed as a last step in the optimizer. It is now handy for
debugging.
@mal
pattern optimizer.mergetable():str
address OPTmergetable;
pattern optimizer.mergetable(mod:str, fcn:str):str
address OPTmergetable
comment "Resolve the multi-table definitions";
@h
#ifndef _MAL_MERGETABLE_
#define _MAL_MERGETABLE_
#include "opt_prelude.h"
#include "opt_support.h"
#include "mal_interpreter.h"
#include "mal_builder.h"

/*#define DEBUG_OPT_MERGETABLE     show partial result */
@c
#include "mal_config.h"
#include "opt_mergetable.h"
#include "bpm.h"

static int
isMATalias(int idx, int mvar[], int top){
	int i;
	for(i =0; i<top; i++)
		if( mvar[i]== idx) return i;
	return -1;
}

INLINE static int
mat_add(InstrPtr *mat, int *mvar, int mtop, InstrPtr q) 
{
	mat[mtop] = q;
	mvar[mtop] = getArg(q,0);
	return mtop+1;
}

static InstrPtr
mat_join(MalBlkPtr mb, InstrPtr p, InstrPtr *mat, int m, int n)
{
	int tpe = getArgType(mb,p,0);
	int k;
	InstrPtr r = newInstruction(mb, ASSIGNsymbol);

	setModuleId(r,matRef);
	setFunctionId(r,newRef);
	getArg(r,0) = getArg(p,0);
	
	for(k=1; k<mat[m]->argc; k++) {
		InstrPtr q = copyInstruction(p);
		getArg(q,0) = newTmpVariable(mb, tpe);
		getArg(q,1) = getArg(mat[m],k);
		getArg(q,2) = getArg(mat[n],k);
		pushInstruction(mb,q);

		/* add result to mat */
		r = pushArgument(mb,r,getArg(q,0));
	}
	freeInstruction(p);
	pushInstruction(mb, r);
	return r;
}

static InstrPtr
mat_group(InstrPtr *ext, MalBlkPtr mb, InstrPtr p, InstrPtr *mat, int m, int n, int o)
{
	int tp0 = getArgType(mb,p,0);
	int tp1 = getArgType(mb,p,1);
	int k;
	InstrPtr r0 = newInstruction(mb, ASSIGNsymbol);
	InstrPtr r1 = newInstruction(mb, ASSIGNsymbol);

	setModuleId(r0,matRef);
	setFunctionId(r0,newRef);
	getArg(r0,0) = getArg(p,0);

	setModuleId(r1,matRef);
	setFunctionId(r1,newRef);
	getArg(r1,0) = getArg(p,1);
	
	for(k=1; k<mat[m]->argc; k++) {
		InstrPtr q = copyInstruction(p);
		getArg(q,0) = newTmpVariable(mb, tp0);
		getArg(q,1) = newTmpVariable(mb, tp1);
		getArg(q,2) = getArg(mat[m],k);
		if (n)
			getArg(q,3) = getArg(mat[n],k);
		if (o)
			getArg(q,4) = getArg(mat[o],k);
		pushInstruction(mb,q);

		/* add result to mat */
		r0 = pushArgument(mb,r0,getArg(q,0));
		r1 = pushArgument(mb,r1,getArg(q,1));
	}
	freeInstruction(p);
	pushInstruction(mb, r0);
	pushInstruction(mb, r1);
	*ext = r1;
	return r0;
}

/* todo make general re-name func function */
static InstrPtr
mat_union(MalBlkPtr mb, InstrPtr p, InstrPtr *mat, int m)
{
	int k;
	InstrPtr r = newInstruction(mb, ASSIGNsymbol);

	setModuleId(r,matRef);
	setFunctionId(r,newRef);
	getArg(r,0) = getArg(p,0);
	
	for(k=1; k<mat[m]->argc; k++) {
		r = pushArgument(mb, r, getArg(mat[m],k));
	}
	r = pushArgument(mb, r, getArg(p,2));
	freeInstruction(p);
	pushInstruction(mb, r);
	return r;
}

static InstrPtr
mat_mark(MalBlkPtr mb, InstrPtr p, InstrPtr *mat, int m)
{
	int tpe = getArgType(mb,p,0);
	int k,o = newTmpVariable(mb,TYPE_oid);
	InstrPtr q, r = newInstruction(mb, ASSIGNsymbol);
	
	getArg(r,0) = o;
	/* get the mark base id */
	r = pushArgument(mb, r, getArg(p, 2));
	pushInstruction(mb, r);
	
	r = newInstruction(mb, ASSIGNsymbol);
	setModuleId(r,matRef);
	setFunctionId(r,newRef);
	getArg(r,0) = getArg(p,0);
	
	for(k=1; k<mat[m]->argc; k++) {
		q = copyInstruction(p);
		getArg(q,0) = newTmpVariable(mb, tpe);
		getArg(q,1) = getArg(mat[m],k);
		getArg(q,2) = o;
		pushInstruction(mb,q);

		/* add result to mat */
		r = pushArgument(mb,r,getArg(q,0));

		/* increment oid */
		if (k < mat[m]->argc-1) {
			InstrPtr ca, c, bc = newInstruction(mb, ASSIGNsymbol);
			
			/* bc = bat.count */
			setModuleId(bc, aggrRef);
			setFunctionId(bc, countRef);
			getArg(bc, 0) = newTmpVariable(mb, TYPE_int);
			bc = pushArgument(mb, bc, getArg(mat[m],k));
			pushInstruction(mb, bc);

			/* convert int to oid */
			c = newInstruction(mb, ASSIGNsymbol);
			setModuleId(c, calcRef);
			setFunctionId(c, oidRef);
			getArg(c, 0) = newTmpVariable(mb, TYPE_oid);
			c = pushArgument(mb, c, getArg(bc,0));
			pushInstruction(mb, c);

			/* ca = calc.add */
			ca = newInstruction(mb, ASSIGNsymbol);
			setModuleId(ca, calcRef);
			setFunctionId(ca, plusRef);
			getArg(ca, 0) = o;
			ca = pushArgument(mb, ca, o);
			ca = pushArgument(mb, ca, getArg(c, 0));
			pushInstruction(mb, ca);
		}
	}
	freeInstruction(p);
	pushInstruction(mb, r);
	return r;
}
@-
Packing the BATs into a single one is handled here
Note that MATs can be defined recursively.
@c
static InstrPtr 
MATpackAll(MalBlkPtr mb, InstrPtr  r, int m, InstrPtr *mat, int *mvar, int *mtop){
	int j,l,k;
	if( mat[m]->argc-mat[m]->retc ==1){
		/* simple assignment is sufficient */
		r = newInstruction(mb, ASSIGNsymbol);
		getArg(r,0)= getArg(mat[m],0);
		getArg(r,1)= getArg(mat[m],1);
	} else{
		if (r == NULL){
			r = newInstruction(mb, ASSIGNsymbol);
			setModuleId(r,matRef);
			setFunctionId(r,packRef);
			getArg(r,0) = getArg(mat[m],0);
		}
		for(l=mat[m]->retc; l< mat[m]->argc; l++){
			k= isMATalias( getArg(mat[m],l),mvar,*mtop);
			if( k< 0)
				r= pushArgument(mb,r, getArg(mat[m],l));
			else
				r= MATpackAll(mb,r, k, mat,mvar,mtop);
		}
	}
	for(j=m; j < *mtop-1; j++){
		mat[j]= mat[j+1];
		mvar[j]= mvar[j+1];
	}
	*mtop = *mtop-1; 
	pushInstruction(mb,r);
	return r;
}

static void 
MATcollect(int m, InstrPtr *mat, int *mvar, int mtop, int *newvar, int *n){
	int i,j,k;
	for(i= mat[m]->retc; i<mat[m]->argc; i++)
		if( (j= isMATalias( getArg(mat[m],i), mvar, mtop)) >= 0){
			for(k=0; k<mtop; k++)
			if( mvar[k]== j)
				MATcollect(k,mat,mvar,mtop,newvar,n);
		} else { newvar[*n]=  getArg(mat[m],i); *n = *n+1;}
}

static int
MATcount(InstrPtr p, int *mvar, int mtop){
	int j,cnt=0;
	for(j=p->retc; j<p->argc; j++)
	if(  isMATalias(getArg(p,j),mvar,mtop) >= 0) {
		cnt++;
	}
	return cnt;
}

typedef struct hrange {
	oid l,h;
	char used;
} hrange;

static int
OPTmergetableImplementation(MalBlkPtr mb, MalStkPtr stk, InstrPtr p) 
{
	InstrPtr *old=0, q, r, *mat;
	int oldtop, fm, i, k, m, mtop=0, *mvar, tpe;
	int size, match, actions=0;
	hrange *hr; 

#ifdef DEBUG_OPT_MERGETABLE
	stream_printf(GDKout,"Start MAT optimizer\n");
#endif
	old = mb->stmt;
	oldtop= mb->stop;
	size = (mb->stop * 1.2 < mb->ssize)? mb->ssize:(int)(mb->stop * 1.2);
	mb->stmt = (InstrPtr *) GDKzalloc(size * sizeof(InstrPtr));
	mb->ssize = size;
	mb->stop = 0;
	hr = (hrange *) GDKzalloc(mb->vsize * sizeof(hrange));

	/* the number of MATs is limited to the variable stack*/
	mat = (InstrPtr*) alloca(mb->vtop * sizeof(InstrPtr));
	memset((char*) mat, 0, mb->vtop * sizeof(InstrPtr));
	mvar = (int*) alloca(mb->vtop * sizeof(int));
	memset((char*) mvar, 0, mb->vtop * sizeof(int));

	for( i=0; i<oldtop; i++){
		int n = 0, o = 0;
		p = old[i];
		if (getModuleId(p)== matRef && 
		   (getFunctionId(p)==newRef || getFunctionId(p)==packRef)) {
			mat[mtop] = p;
			mvar[mtop] = getArg(p,0);
			mtop++;
			pushInstruction(mb,p);
			continue;
		}
		if (getModuleId(p)== matRef && getFunctionId(p) == hrangeRef) {
			hrange *h = &hr[getArg(p,1)];
			h->used = 1;
			h->l = getConstant(mb, getArg(p,2)).val.oval;
			h->h = getConstant(mb, getArg(p,3)).val.oval;
			continue;
		}
@-
If the instruction does not contain MAT references it can simply be added.
Otherwise we have to decide on either packing them or replacement.
@c
		match= MATcount(p,mvar,mtop);
		if (match == 0) {
			pushInstruction(mb,p);
#ifdef DEBUG_OPT_MERGETABLE
			stream_printf(GDKout,"simply move\n");
			printInstruction(GDKout,mb,p,0);
#endif
			continue;
		}
@- 
First we handle horizontal aligned mats. This information is passed using
mat.hrange(b,x,y). So if this is available, we can simplify batcalc operations
and for fetch joins we can use this information to do per part joins only.
@c
		if (match == 2) {
			if (getModuleId(p) == algebraRef &&
			    getFunctionId(p) == joinRef &&
				(m=isMATalias(getArg(p,1),mvar,mtop)) >= 0 &&
				(n=isMATalias(getArg(p,2),mvar,mtop)) >= 0 &&
				mat[m]->argc == mat[n]->argc ) {
				/* todo match the hranges */
				mtop= mat_add(mat, mvar, mtop, mat_join(mb, p, mat, m, n));
				actions++;
				continue;
			}	
		}
@- 
Now we handle group.new (and derive) statements
@c
		if (getModuleId(p) == groupRef && 
		   ((match == 1 && getFunctionId(p) == newRef &&
		   ((m=isMATalias(getArg(p,2),mvar,mtop)) >= 0)) ||
		   (match == 3 && getFunctionId(p) == deriveRef &&
		   ((m=isMATalias(getArg(p,2),mvar,mtop)) >= 0) &&
		   ((n=isMATalias(getArg(p,3),mvar,mtop)) >= 0) &&
		   ((o=isMATalias(getArg(p,4),mvar,mtop)) >= 0)))) {
			InstrPtr ext, grp;
		
			printf("%s %d %d %d\n", getFunctionId(p), m, n, o);
			grp = mat_group(&ext, mb, p, mat, m, n, o);
			mtop= mat_add(mat, mvar, mtop, grp);
			mtop= mat_add(mat, mvar, mtop, ext);
			actions++;
			continue;
		}
@-
Pack MAT arguments, except one, to limit plan explosion.
The preferred partitioned one is the first argment as it
often reflects a base table.
Look at the depth of the MAT definition to limit the explosion.
@c
		for( fm= p->argc-1; fm>p->retc ; fm--)
			if ((m=isMATalias(getArg(p,fm),mvar,mtop)) >= 0)
				break;

		for( k=fm-1; match > 1 && k >= p->retc ; k--) {
			if ((m=isMATalias(getArg(p,k),mvar,mtop)) >= 0) {
#ifdef DEBUG_OPT_MERGETABLE
				stream_printf(GDKout,"Pack k=%d\n",k);
				printInstruction(GDKout,mb,p,0);
#endif
				r= MATpackAll(mb, NULL, m, mat, mvar, &mtop);
				getArg(p,k) = getArg(r,0);
				match--;
			}
		}
@-
From here we have to differentiate between the operations.
Their semantics should be respected while producing code.
@-
The insertions are sent to the first component of the MAT.
Selection of the proper component based on e.g. range descriptors is for
later.

CAVEAT. The MATs that represent partitions in SQL can not
be packed to facilitate updates. We assume the first
partition is dominant. 
@c
		if (((getModuleId(p)== batRef && 
		     (getFunctionId(p)== insertRef ||
		      getFunctionId(p)== appendRef)) ||
		     (getModuleId(p) == algebraRef &&
		      getFunctionId(p)== kunionRef)) &&
			(m=isMATalias(getArg(p,1),mvar,mtop)) >= 0) {
			/* bat.insert(mat,b or val) 
			   bat.append()
			   bat.kunion()
				-> mat.union(mat, b or val) */
			mtop= mat_add(mat, mvar, mtop, mat_union(mb, p, mat, m));
			actions++;
			continue;
		} 
@-
The mark operators are a special case of apply on parts as we need too
correct the mark base oid's 
@c
		if (getModuleId(p)== algebraRef && 
		    (getFunctionId(p) == markTRef ||
		     getFunctionId(p) == markHRef) &&
			(m=isMATalias(getArg(p,1),mvar,mtop)) >= 0) {
			mtop= mat_add(mat, mvar, mtop, mat_mark(mb, p, mat, m));
			actions++;
			continue;
		}
@-
The delete operator is a good example where the
action does not produce multiple results, but requires
an accumulation implementation.
@-
A similar situation occurs in delete operations 
using partitioned input.
@c

		if((getModuleId(p) == batRef && getFunctionId(p) == deleteRef) 
		    && fm == 2 && (m=isMATalias(getArg(p,fm),mvar,mtop)) >= 0) {
#ifdef DEBUG_OPT_MERGETABLE
			stream_printf(GDKout,"delete resolution fm=%d\n",fm);
			printInstruction(GDKout,mb,p,0);
#endif
			tpe= getVarType(mb,getArg(p,0));
			for(k=1; k< mat[m]->argc; k++){
				q= copyInstruction(p);
				if( k == mat[m]->argc-1) {
					getArg(q,0)= getArg(p,0);
				} else {
					getArg(q,0) = newTmpVariable(mb, tpe);
					getArg(p,1)= getArg(q,0);
				}
				getArg(q,fm) = getArg(mat[m],k);
				pushInstruction(mb,q);
#ifdef DEBUG_OPT_MERGETABLE
				printInstruction(GDKout,mb,q,0);
#endif
			}
			freeInstruction(p);
			continue;
		}
@-
Not all instructions can be replaced by the sequence. We have to
group them and check for them individually.
@c
		if( isFragmentGroup(p) && 
			(m=isMATalias(getArg(p,fm),mvar,mtop)) >= 0){
#ifdef DEBUG_OPT_MERGETABLE
			stream_printf(GDKout,"isFragment resolution fm=%d\n",fm);
			printInstruction(GDKout,mb,p,0);
#endif
			if (isaBatType(getVarType(mb,getArg(p,0)))){
				r = newInstruction(mb, ASSIGNsymbol);
				setModuleId(r,matRef);
				setFunctionId(r,newRef);
				getArg(r,0) = getArg(p,0);
				tpe = getArgType(mb,p,0);
			} else {
				tpe = TYPE_any;
				r = 0;
			}

			for(k=1; k<mat[m]->argc; k++) {
				q = copyInstruction(p);
				getArg(q,0) = newTmpVariable(mb, tpe);
				getArg(q,fm) = getArg(mat[m],k);
				pushInstruction(mb,q);
				if (r)
					r = pushArgument(mb,r,getArg(q,0));
			}
			freeInstruction(p);
			actions++;
			if(r){
				mat[mtop] = r;
				mvar[mtop] = getArg(r,0);
				mtop++;
				/* pushInstruction(mb,r); */
			}
#ifdef DEBUG_OPT_MERGETABLE
			stream_printf(GDKout,"Fragment result \n");
			if(r) printInstruction(GDKout,mb,r,0);
#endif
			continue;
		} 
@-
Aggregate handling is a prime target for optimization.
The simple cases are dealt with first.
Handle the rewrite v:=aggr.count(b) and sum()
And the min/max is as easy
@c
		if( getModuleId(p)==aggrRef && 
			( getFunctionId(p)== countRef || 
			( getFunctionId(p)== minRef && p->argc==2) ||
			( getFunctionId(p)== maxRef && p->argc==2) ||
			( getFunctionId(p)== sumRef && p->argc==2)) &&
			(m=isMATalias(getArg(p,fm),mvar,mtop)) >= 0){
#ifdef DEBUG_OPT_MERGETABLE
			stream_printf(GDKout,"count/sum \n");
			printInstruction(GDKout,mb,p,0);
#endif
			r = newInstruction(mb,ASSIGNsymbol);
			getArg(r,0)= getArg(p,0);
			if( getFunctionId(p)== minRef || getFunctionId(p)==maxRef)
				r= pushNil(mb,r,getVarType(mb,getArg(p,0)));
			else
				r= pushZero(mb,r,getVarType(mb,getArg(p,0)));
			pushInstruction(mb,r);
			for(k=1; k< mat[m]->argc; k++){
				int v= newTmpVariable(mb,TYPE_int);
				q= newInstruction(mb,ASSIGNsymbol);
				setModuleId(q,aggrRef);
				setFunctionId(q,getFunctionId(p));
				getArg(q,0)= v;
				q= pushArgument(mb,q,getArg(mat[m],k));
				pushInstruction(mb,q);

				q= newInstruction(mb,ASSIGNsymbol);
				setModuleId(q,calcRef);
				if( getFunctionId(p)== minRef || getFunctionId(p)==maxRef)
					setFunctionId(q,getFunctionId(p));
				else
					setFunctionId(q,plusRef);
				getArg(q,0)= getArg(r,0);
				q= pushArgument(mb,q,getArg(r,0));
				q= pushArgument(mb,q,v);
				pushInstruction(mb,q);
#ifdef DEBUG_OPT_MERGETABLE
				printInstruction(GDKout,mb,q,0);
#endif
			}
			continue;
		} 
@-
All other instructions should be checked for remaining MAT dependencies.
It require the MAT to be materialized. 
@c
		for( k= p->retc; k<p->argc; k++)
		if(	(m=isMATalias(getArg(p,k),mvar,mtop)) >= 0){
#ifdef DEBUG_OPT_MERGETABLE
			stream_printf(GDKout,"pack resolution \n");
			printInstruction(GDKout,mb,p,0);
#endif
			r= MATpackAll(mb, NULL, m, mat, mvar, &mtop);
			actions++;
			break;
		}
#ifdef DEBUG_OPT_MERGETABLE
			stream_printf(GDKout,"last option\n");
			printInstruction(GDKout,mb,p,0);
#endif
		pushInstruction(mb,p);
	}
	GDKfree(hr);
	GDKfree(old);
@-
As a final optimization, we could remove the mal.new definitions,
because they are not needed for the execution.
For the time being, they are no-ops.
@c
	(void) stk; 
#ifdef DEBUG_OPT_MERGETABLE
	stream_printf(GDKout,"Result of multi table optimizer\n");
	optimizerCheck(mb,"merge test",1,0,0);
	printFunction(GDKout, mb, LIST_MAL_ALL);
#endif

	return actions;
}
@include optimizerWrapper.mx
@h
@:exportOptimizer(mergetable)@
#endif
@c
#include "opt_statistics.h"
@:wrapOptimizer(mergetable,OPT_CHECK_ALL)@
@}
