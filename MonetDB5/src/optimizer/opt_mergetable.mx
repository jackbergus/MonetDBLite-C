@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2008 CWI.
@' All Rights Reserved.

@f opt_mergetable
@a M. Kersten, N. Nes
@- Merge Tables 
A merge association table (MAT) descriptor defines an ordered collection 
of type compatible BATs, whose union represents a single (virtual) BAT.
The MAT may represent a partitioned BAT (see BPM), but could also 
be an arbitrary collection of temporary BATs within a program fragment.

The MAT definition lives within the scope of a single block.
The MAT optimizer simply expands the plan to
deal with its components on an instruction basis.
Only when a blocking operator is encounted, the underlying BAT is materialized.

The MAT object can not be passed as an argument to any function
without first being materialized. Simply because
the MAT is not known by the type system and none of the lower
level operations is aware of their existence.

In the first approach of the MAT optimizer we assume that the 
first BAT in the MAT sequence is used as an accumulator.
Furthermore, no semantic knowledge is used to reduce the
possible superflous (semi)joins. Instead, we limit expansion
to a single argument. 
This is changed at a later stage when a cost-based evaluation
be decide differently.

To illustrate, consider:
@example
	m0:= bat.new(:oid,:int);
	m1:= bat.new(:oid,:int);
	m2:= bat.new(:oid,:int);
	b := mat.new(m0,m1,m2);
	s := algebra.select(b,1,3);
	i := algebra.count(s);
	io.print(s);
	io.print(i);
	c0 := bat.new(:int,:int);
	c1 := bat.new(:int,:int);
	c := mat.new(c0,c1);
	j := algebra.join(b,s);
	io.print(j);
@end example

The selection and aggregate operations can simply be rewritten using a MAT:
@example
	_33 := algebra.select(m0,1,3);
	_34 := algebra.select(m1,1,3);
	_35 := algebra.select(m2,1,3);
    s := mat.new(_33,_34,_35);
    i := 0:int;
    _36 := aggr.count(_33);
    i := calc.+(i,_36);
    _37 := aggr.count(_34);
    i := calc.+(i,_37);
    _38 := aggr.count(_35);
    i := calc.+(i,_38);
    io.print(i);
@end example

The print operation does not have MAT semantics yet.
It requires a function that does not produce the header
with each call.
Instead, we can also pack the elements before printing.
@example
    s := mat.pack(_33,_34,_35);
    io.print(s);
@end example
For the join we have to generate all possible combinations,
not knowing anything about the properties of the components.
The current heuristic is to limit expansion to a single
argument. This leads to 
@example
    b := mat.pack(m0,m1,m2);
    _39 := algebra.join(b,c0);
    _40 := algebra.join(b,c1);
    j := mat.new(_39,_40);
@end example

The drawback of the scheme is the potential explosion in MAL statements.
A challenge of the optimizer is to find the minimum by inspection of
the properties of the MAT elements. For example, it might attempt
to partially pack elements before proceding. This would be a runtime
scheduling decision.

Alternative, the system could use MAT iterators to avoid it.
At the cost of more complex program analysis afterwards.

@example
	ji:= bat.new(:oid,:int);
barrier b:= mat.newIterator(m0,m1,m2);
barrier c:= mat.newIterator(c0,c1);
	ji := algebra.join(b,c);
	bat.insert(j,ji);
	redo c:= mat.newIterator(c0,c1);
	redo b:= mat.newIterator(m0,m1,m2);
exit c;
exit b;
@end example

@{
Also consider the MAT as a variable property. This is needed
to pass a MAT as an argument to functions. If the function does
not accept a MAT, the argument should be packed, otherwise
we can simply let it pass.

We have to add routines to deal with duplicate elimination.
Moreover, the other optimizers should become aware of the MAT
operations. The operations mat.new() and mat.range() can be
removed as a last step in the optimizer. It is now handy for
debugging.
@mal
pattern optimizer.mergetable():str
address OPTmergetable;
pattern optimizer.mergetable(mod:str, fcn:str):str
address OPTmergetable
comment "Resolve the multi-table definitions";
@h
#ifndef _MAL_MERGETABLE_
#define _MAL_MERGETABLE_
#include "opt_prelude.h"
#include "opt_support.h"
#include "mal_interpreter.h"
#include "mal_builder.h"

#define DEBUG_OPT_MERGETABLE     /* show partial result */
@c
#include "mal_config.h"
#include "opt_mergetable.h"
#include "bpm.h"

typedef enum mat_type {
	mat_none = 0,
	mat_grp = 1,
	mat_hist = 2,
	mat_ext = 3
} mat_type;

typedef struct mat {
	InstrPtr mi;	/* mat instruction */
	InstrPtr mm;	/* mat merge statement (needed for group by's) */
	int mv;		/* mat variable */
	int rm;		/* related mat (multiple outputs hurt here) */
	mat_type type;	/* type of operation */
} mat_t;

int overlap( MalBlkPtr mb, int lv, int rv)
{
	VarPtr llb = varGetProp(mb, lv, tlbProp); 
	VarPtr lub = varGetProp(mb, lv, tubProp); 
	VarPtr rlb = varGetProp(mb, rv, hlbProp); 
	VarPtr rub = varGetProp(mb, rv, hubProp); 

	if (!llb || !rlb) {
		/* unknown lower bound ie overlap */
		return 1;
	}
	/* perfect match */
	if (lub->value.val.lval == rub->value.val.lval &&
	    llb->value.val.lval == rlb->value.val.lval) 
		return 1;

	if ((rub->value.val.lval != (lng)oid_nil && 
	      rub->value.val.lval <= llb->value.val.lval) || 
 	     (lub->value.val.lval != (lng)oid_nil &&
	      lub->value.val.lval <= rlb->value.val.lval))
		return 0;

	if ((rub->value.val.lval == (lng)oid_nil && 
	     rlb->value.val.lval > lub->value.val.lval) || 
	    (lub->value.val.lval == (lng)oid_nil &&
	     llb->value.val.lval > rub->value.val.lval)) {
                return 0;

		return 0;
	}
	return 1;
}

int Hoverlap( MalBlkPtr mb, int lv, int rv)
{
	VarPtr llb = varGetProp(mb, lv, hlbProp); 
	VarPtr lub = varGetProp(mb, lv, hubProp); 
	VarPtr rlb = varGetProp(mb, rv, hlbProp); 
	VarPtr rub = varGetProp(mb, rv, hubProp); 
	if (!llb || !rlb) {
		/* unknown ie overlap */
		return 1;
	}
	/* perfect match */
	if (lub->value.val.lval == rub->value.val.lval &&
	    llb->value.val.lval == rlb->value.val.lval) 
		return 1;

	if ((rub->value.val.lval != (lng)oid_nil && 
	      rub->value.val.lval <= llb->value.val.lval) || 
 	     (lub->value.val.lval != (lng)oid_nil &&
	      lub->value.val.lval <= rlb->value.val.lval))
		return 0;

	if ((rub->value.val.lval == (lng)oid_nil && 
	      rlb->value.val.lval > lub->value.val.lval) || 
 	     (lub->value.val.lval == (lng)oid_nil &&
	      llb->value.val.lval > rub->value.val.lval)) {
		return 0;
	}
	return 1;
}


static void
propagateMarkProp(MalBlkPtr mb, InstrPtr q, int ivar, oid l, oid h)
{
	int ovar = getArg(q, 0);
	VarPtr hlb = varGetProp(mb, ivar, hlbProp);
	VarPtr hub = varGetProp(mb, ivar, hubProp);
	VarPtr tlb = varGetProp(mb, ivar, tlbProp);
	VarPtr tub = varGetProp(mb, ivar, tubProp);
	ValRecord v;

	if (getFunctionId(q) == markHRef) {
		if (tlb) varSetProp(mb, ovar, tlbProp, op_gte, &tlb->value);
		if (tub) varSetProp(mb, ovar, tubProp, op_lt, &tub->value);
		varSetProp(mb, ovar, hlbProp, op_gte, VALset(&v, TYPE_oid, &l));
		varSetProp(mb, ovar, hubProp, op_lt, VALset(&v, TYPE_oid, &h));
	} else { /* markTRef */
		if (hlb) varSetProp(mb, ovar, hlbProp, op_gte, &hlb->value);
		if (hub) varSetProp(mb, ovar, hubProp, op_lt, &hub->value);
		varSetProp(mb, ovar, tlbProp, op_gte, VALset(&v, TYPE_oid, &l));
		varSetProp(mb, ovar, tubProp, op_lt, VALset(&v, TYPE_oid, &h));
	}
}

static void
propagateBinProp(MalBlkPtr mb, InstrPtr q, int ivarl, int ivarr)
{
	int ovar = getArg(q, 0);

	if (getFunctionId(q) == joinRef) {
		VarPtr hlb = varGetProp(mb, ivarl, hlbProp);
		VarPtr hub = varGetProp(mb, ivarl, hubProp);
		VarPtr tlb = varGetProp(mb, ivarr, tlbProp);
		VarPtr tub = varGetProp(mb, ivarr, tubProp);

		if (hlb) varSetProp(mb, ovar, hlbProp, op_gte, &hlb->value);
		if (hub) varSetProp(mb, ovar, hubProp, op_lt, &hub->value);
		if (tlb) varSetProp(mb, ovar, tlbProp, op_gte, &tlb->value);
		if (tub) varSetProp(mb, ovar, tubProp, op_lt, &tub->value);
	} else if (getFunctionId(q) == kunionRef) {
		/* max ?? */
		VarPtr hlb = varGetProp(mb, ivarl, hlbProp);
		VarPtr hub = varGetProp(mb, ivarr, hubProp);
		VarPtr tlb = varGetProp(mb, ivarl, tlbProp);
		VarPtr tub = varGetProp(mb, ivarr, tubProp);

		if (hlb) varSetProp(mb, ovar, hlbProp, op_gte, &hlb->value);
		if (hub) varSetProp(mb, ovar, hubProp, op_lt, &hub->value);
		if (tlb) varSetProp(mb, ovar, tlbProp, op_gte, &tlb->value);
		if (tub) varSetProp(mb, ovar, tubProp, op_lt, &tub->value);
	}
}

static void
propagateProp(MalBlkPtr mb, InstrPtr q, int ivar)
{
	int ovar = getArg(q, 0);
	VarPtr hlb = varGetProp(mb, ivar, hlbProp);
	VarPtr hub = varGetProp(mb, ivar, hubProp);
	VarPtr tlb = varGetProp(mb, ivar, tlbProp);
	VarPtr tub = varGetProp(mb, ivar, tubProp);

	if (getFunctionId(q) == reverseRef) {
		if (hlb) varSetProp(mb, ovar, tlbProp, op_gte, &hlb->value);
		if (hub) varSetProp(mb, ovar, tubProp, op_lt, &hub->value);
		if (tlb) varSetProp(mb, ovar, hlbProp, op_gte, &tlb->value);
		if (tub) varSetProp(mb, ovar, hubProp, op_lt, &tub->value);
	} else if (getFunctionId(q) == mirrorRef || 
		   (getModuleId(q) == groupRef && (
		     getFunctionId(q) == newRef ||
		     getFunctionId(q) == deriveRef))) {
		if (hlb) varSetProp(mb, ovar, hlbProp, op_gte, &hlb->value);
		if (hub) varSetProp(mb, ovar, hubProp, op_lt, &hub->value);
		if (hlb) varSetProp(mb, ovar, tlbProp, op_gte, &hlb->value);
		if (hub) varSetProp(mb, ovar, tubProp, op_lt, &hub->value);
	} else if (isFragmentGroup(q) || getModuleId(q) == mkeyRef) {
		if (hlb) varSetProp(mb, ovar, hlbProp, op_gte, &hlb->value);
		if (hub) varSetProp(mb, ovar, hubProp, op_lt, &hub->value);
		if (tlb) varSetProp(mb, ovar, tlbProp, op_gte, &tlb->value);
		if (tub) varSetProp(mb, ovar, tubProp, op_lt, &tub->value);
	}
}

static int
isMATalias(int idx, mat_t *mat, int top){
	int i;
	for(i =0; i<top; i++)
		if( mat[i].mv == idx) 
			return i;
	return -1;
}

@-
Packing the BATs into a single one is handled here
Note that MATs can be defined recursively.
@c
static InstrPtr 
MATpackAll(MalBlkPtr mb, InstrPtr  r, mat_t *mat, int m, int *mtop)
{
	int j,l,k;

	if( mat[m].mi->argc-mat[m].mi->retc == 1){
		/* simple assignment is sufficient */
		r = newInstruction(mb, ASSIGNsymbol);
		getArg(r,0) = getArg(mat[m].mi,0);
		getArg(r,1) = getArg(mat[m].mi,1);
		/* dirty hack */
		r->retc = 1;
		r->argc = 2;
	} else {
		if (r == NULL){
			r = newInstruction(mb, ASSIGNsymbol);
			setModuleId(r,matRef);
			setFunctionId(r,packRef);
			getArg(r,0) = getArg(mat[m].mi,0);
		}
		for(l=mat[m].mi->retc; l< mat[m].mi->argc; l++){
			k= isMATalias( getArg(mat[m].mi,l), mat, *mtop);
			if( k< 0)
				r= pushArgument(mb,r, getArg(mat[m].mi,l));
			else
				r= MATpackAll(mb, r, mat, k, mtop);
		}
	}
	for(j=m; j < *mtop-1; j++)
		mat[j] = mat[j+1];
	*mtop = *mtop-1; 
	pushInstruction(mb,r);
	return r;
}


INLINE static int
mat_add(mat_t *mat, int mtop, MalBlkPtr mb, InstrPtr q, mat_type type) 
{
	assert(q->argc > 1);
	mat[mtop].mi = q;
	mat[mtop].mv = getArg(q,0);
	mat[mtop].type = type;
	(void)mb;
	//pushInstruction(mb, q);
	return mtop+1;
}

int
mat_fanout(mat_t *mat, int m, int n, MalBlkPtr mb, int isjoin) 
{
	int cnt = 0;
	int k,j;

	for(k=1; k<mat[m].mi->argc; k++) {
		for(j=1; j<mat[n].mi->argc; j++) {
			if (isjoin && overlap(mb, getArg(mat[m].mi,k), getArg(mat[n].mi,j))) {
				cnt++;
			} else if (!isjoin && Hoverlap(mb, getArg(mat[m].mi,k), getArg(mat[n].mi,j))) {
				cnt++;
			}
		}
	}
	return cnt;
}

/* mat_apply1 handles both apply and reduce cases */
static InstrPtr
mat_apply1(MalBlkPtr mb, InstrPtr p, mat_t *mat, int m, int var, int reuse)
{
	int tpe, k, inout = 0, bvar = (var==2)?1:2;
	InstrPtr r = NULL;

	if (getFunctionId(p) == joinRef)
		assert(0);

	assert(reuse == 0);
	(void)reuse;
	if (var == 2 && 
	    getModuleId(p) == algebraRef &&
	    (getFunctionId(p) == semijoinRef || 
 	     getFunctionId(p) == kdifferenceRef)) { 
		tpe = getArgType(mb,p,0);
		/* use results as inputs */
		inout = 1;
	} else if (isaBatType(getVarType(mb,getArg(p,0)))){
		r = newInstruction(mb, ASSIGNsymbol);
		setModuleId(r,matRef);
		setFunctionId(r,newRef);
		getArg(r,0) = getArg(p,0);
		tpe = getArgType(mb,p,0);
	} else {
		assert(0);
		tpe = TYPE_any;
	}

	for(k=1; k<mat[m].mi->argc; k++) {
		int used = 0;
		if (inout || p->argc == 2 ||
		    /* join + overlap */
		    /* or calc + hoverlap */
		    ((getFunctionId(p) == joinRef &&
                    overlap(mb, getArg(mat[m].mi,k), getArg(p, bvar)))  ||
		    (getFunctionId(p) != joinRef &&
                    Hoverlap(mb, getArg(mat[m].mi,k), getArg(p, bvar))))) {
			InstrPtr q = copyInstruction(p);

			getArg(q,var) = getArg(mat[m].mi,k);
			if (!inout)
				getArg(q,0) = newTmpVariable(mb, tpe);
			if (inout)
				inout = getArg(q,0);
			if (inout && k > 1) 
				getArg(q,1) = inout; 
			if (inout && k == 1)
				propagateProp(mb, q, getArg(p,1));
			else if (!inout)
				propagateProp(mb, q, getArg(mat[m].mi, k));
			pushInstruction(mb,q);
			if (r)
				r = pushArgument(mb,r,getArg(q,0));
			used = 1;
		}
		if (!used && 
		   (getFunctionId(p) == kdifferenceRef ||
		    getFunctionId(p) == kunionRef)) 
			r = pushArgument(mb, r, getArg(mat[m].mi, k));
	}
	if (r)
		assert(r->argc > 1);
	freeInstruction(p);
	return r;
}

static InstrPtr
mat_apply2(MalBlkPtr mb, InstrPtr p, mat_t *mat, int *mtop, int a1, int a2, int a3, int reuse)
{
	int tpe = getArgType(mb,p,0);
	int k,j,m,n,Am,An;
	InstrPtr r = newInstruction(mb, ASSIGNsymbol);

	if (reuse) {
		if (a1 == a2) { 
			a2 = -1;
			reuse = 2;
		}
		if (a1 == a3) {
			a3 = -1;
			reuse = 3;
		}
	}

	m = (a1>=0)?a1:a2;
	n = (a3>=0)?a3:a2;
	Am = (a1>=0)?1:2;
	An = (a3>=0)?3:2;

	if (mat_fanout(mat, m, n, mb, 0) > 
		2*mat[m].mi->argc + 2*mat[n].mi->argc) { 
		(void)MATpackAll(mb, NULL, mat, m, mtop);
		(void)MATpackAll(mb, NULL, mat, n, mtop);
		/* keep old instruction */
		pushInstruction(mb,p);
		return NULL;
	}
	setModuleId(r,matRef);
	setFunctionId(r,newRef);
	getArg(r,0) = getArg(p,0);

	for(j=1; j<mat[m].mi->argc; j++) {
		int used = 0;
		int vm = getArg(mat[m].mi, j);
		for(k=1; k<mat[n].mi->argc; k++) {
			int vn = getArg(mat[n].mi, k);
			if (Hoverlap(mb, vm, vn)) {
				InstrPtr q = copyInstruction(p);
				if (!reuse)
					getArg(q,0) = newTmpVariable(mb, tpe);
				else
					getArg(q,0) = vm;
				getArg(q,Am) = vm;
				getArg(q,An) = vn;
				if (reuse) 
					getArg(q,reuse) = vm;
				pushInstruction(mb,q);

				if (!reuse)
					propagateProp(mb, q, vm);
				if (!reuse && 
				    getFunctionId(q) == kunionRef) 
					propagateBinProp(mb, q, vm, vn);

				/* add result to mat */
				r = pushArgument(mb,r,getArg(q,0));
				used = 1;
			}
		}
		if (!used && 
		   (getFunctionId(p) == kdifferenceRef ||
		    getFunctionId(p) == kunionRef)) 
			r = pushArgument(mb, r, vm);
	}
	if (r)
		assert(r->argc > 1);
	freeInstruction(p);
	return r;
}

static InstrPtr
mat_apply3(MalBlkPtr mb, InstrPtr p, mat_t *mat, int a1, int a2, int a3, int reuse)
{
	int tpe = getArgType(mb,p,0);
	int k,j,i;
	InstrPtr r = newInstruction(mb, ASSIGNsymbol);

	setModuleId(r,matRef);
	setFunctionId(r,newRef);
	getArg(r,0) = getArg(p,0);

	for(i=1; i<mat[a1].mi->argc; i++) {
		int vi = getArg(mat[a1].mi, i);
		for(j=1; j<mat[a2].mi->argc; j++) {
			int vj = getArg(mat[a2].mi, j);
			if (Hoverlap(mb, vi, vj)) {
				for(k=1; k<mat[a3].mi->argc; k++) {
					int vk = getArg(mat[a3].mi, k);
					if (Hoverlap(mb, vi, vk)) {
						InstrPtr q = copyInstruction(p);
						if (!reuse) 
							getArg(q,0) = newTmpVariable(mb, tpe);
						else
							getArg(q,0) = vi;
				
						getArg(q,1) = vi;
						getArg(q,2) = vj;
						getArg(q,3) = vk;
						pushInstruction(mb,q);
						if (!reuse)
							propagateProp(mb, q, vi);
	
						/* add result to mat */
						r = pushArgument(mb,r,getArg(q,0));
					}
				}
			}
		}
	}
	if (r)
		assert(r->argc > 1);
	freeInstruction(p);
	return r;
}

static InstrPtr
mat_apply(MalBlkPtr mb, InstrPtr p, mat_t *mat, int *mtop, int a1, int a2, int a3, int reuse) 
{
	if (a1>=0 && a2<0 && a3<0)
		return mat_apply1(mb, p, mat, a1, 1, reuse);
	if (a1<0 && a2>=0 && a3<0)
		return mat_apply1(mb, p, mat, a2, 2, reuse);
	if (a1<0 && a2<0 && a3>=0)
		return mat_apply1(mb, p, mat, a3, 3, reuse);

	if (a1<0 || a2<0 || a3<0 || (a1 == a2) || (a1 == a3))
		return mat_apply2(mb, p, mat, mtop, a1, a2, a3, reuse);

	return mat_apply3(mb, p, mat, a1, a2, a3, reuse);
}


/* join, also handles the case that mat[m].mm is set, ie that we
   have the extend available.
*/
static InstrPtr
mat_join(MalBlkPtr mb, InstrPtr p, mat_t *mat, int m, int n)
{
	int tpe = getArgType(mb,p,0);
	int j,k;
	InstrPtr r = newInstruction(mb, ASSIGNsymbol);

	setModuleId(r,matRef);
	setFunctionId(r,newRef);
	getArg(r,0) = getArg(p,0);
	
	assert(m>=0 || n>=0);
	if (m >= 0 && mat[m].mm) {
		if (n<0) {
			InstrPtr q = copyInstruction(p);

			getArg(q,0) = newTmpVariable(mb, tpe);
			getArg(q,1) = getArg(mat[m].mm,0);
			assert(getArg(q,0) < mb->vtop);
			assert(getArg(q,1) < mb->vtop);
			assert(getArg(q,2) < mb->vtop);
			pushInstruction(mb,q);

			/* add result to mat */
			r = pushArgument(mb,r,getArg(q,0));
		} else {
			for (j=1; j<mat[n].mi->argc; j++) {
				InstrPtr q = copyInstruction(p);

				getArg(q,0) = newTmpVariable(mb, tpe);
				getArg(q,1) = getArg(mat[m].mm,0);
				getArg(q,2) = getArg(mat[n].mi,j);
				assert(getArg(q,0) < mb->vtop);
				assert(getArg(q,1) < mb->vtop);
				assert(getArg(q,2) < mb->vtop);
				pushInstruction(mb,q);
				//propagateBinProp(mb, q, getArg(mat[m].mm, 0), getArg(mat[n].mi, k));

				/* add result to mat */
				r = pushArgument(mb,r,getArg(q,0));
			}
		}
	} else {
		if (m >= 0 && n >= 0) {
		    for(k=1; k<mat[m].mi->argc; k++) {
			for (j=1; j<mat[n].mi->argc; j++) {
				if (overlap(mb, getArg(mat[m].mi, k), getArg(mat[n].mi, j))){
					InstrPtr q = copyInstruction(p);

					getArg(q,0) = newTmpVariable(mb, tpe);
					getArg(q,1) = getArg(mat[m].mi,k);
					getArg(q,2) = getArg(mat[n].mi,j);
					assert(getArg(q,0) < mb->vtop);
					assert(getArg(q,1) < mb->vtop);
					assert(getArg(q,2) < mb->vtop);
					pushInstruction(mb,q);
					propagateBinProp(mb, q, getArg(mat[m].mi, k), getArg(mat[n].mi, j));
	
					/* add result to mat */
					r = pushArgument(mb,r,getArg(q,0));
				}
			}
		    }
		} else {
		    int mv = (m>=0)?m:n;
		    int av = (m>=0)?1:2;
		    int bv = (m>=0)?2:1;

		    if (bv == 2) {
		    	for(k=1; k<mat[mv].mi->argc; k++) {
		 	    if (overlap(mb, getArg(mat[mv].mi, k), getArg(p, bv))){
				InstrPtr q = copyInstruction(p);

				getArg(q,0) = newTmpVariable(mb, tpe);
				getArg(q,av) = getArg(mat[mv].mi, k);
				assert(getArg(q,0) < mb->vtop);
				assert(getArg(q,1) < mb->vtop);
				assert(getArg(q,2) < mb->vtop);
				pushInstruction(mb,q);
				propagateBinProp(mb, q, getArg(mat[mv].mi, k), getArg(q, bv));
				/* add result to mat */
				r = pushArgument(mb,r,getArg(q,0));
			    }
			}
		    } else {
		    	for(k=1; k<mat[mv].mi->argc; k++) {
		 	    if (overlap(mb, getArg(p, bv), getArg(mat[mv].mi, k))){
				InstrPtr q = copyInstruction(p);

				getArg(q,0) = newTmpVariable(mb, tpe);
				getArg(q,av) = getArg(mat[mv].mi, k);
				assert(getArg(q,0) < mb->vtop);
				assert(getArg(q,1) < mb->vtop);
				assert(getArg(q,2) < mb->vtop);
				pushInstruction(mb,q);
				propagateBinProp(mb, q, getArg(q, bv), getArg(mat[mv].mi, k));
				/* add result to mat */
				r = pushArgument(mb,r,getArg(q,0));
			    }
			}
		    }
		}
	}
	if (r)
		assert(r->argc > 1);
	freeInstruction(p);
	return r;
}

static int
resultof(MalBlkPtr mb, int var, int topstmt)
{
	int i;

	while(--topstmt > 0) {
		InstrPtr p = mb->stmt[topstmt];
		for(i=0;i<p->retc; i++)
			if (p->argv[i] == var)
				return topstmt;
	}
	return 0;
}

/* later we should set the Lifespan parts of a variable in the mat_group
   function
 */

static int
group_chain_list_length(MalBlkPtr mb, int var, int topstmt)
{
	int cnt = 0;
	while(var) {
		int s = resultof(mb, var, topstmt);
		InstrPtr p = mb->stmt[s];

		var = 0;
		if (s == 0)
			return 0;
		if (getModuleId(p) == groupRef && getFunctionId(p) == deriveRef)
			var = getArg(p, 3);
		cnt++;
	}
	return cnt;
}

static void
group_attrs(int *attrs, MalBlkPtr mb, int var, int ext )
{
	int cnt = 0;
	while(var) {
		int s = resultof(mb, var, mb->stop);
		InstrPtr q, p = mb->stmt[s];
		int attr = 0;

		assert(s!=0);
		var = 0;
		if (getModuleId(p) == groupRef && 
	 	    getFunctionId(p) == deriveRef){
			var = getArg(p, 3);
			attr = getArg(p, 4);
		} else if (getModuleId(p) == groupRef && 
			   getFunctionId(p) == newRef){
			attr = getArg(p, 2);
		} else {
			assert(0);
		}
		/* ext.join(attr); */
		q = newInstruction(mb, ASSIGNsymbol);
		setModuleId(q, algebraRef);
		setFunctionId(q, joinRef);
		getArg(q, 0) = newTmpVariable(mb, getVarType(mb,attr));
		q = pushArgument(mb, q, ext);
		q = pushArgument(mb, q, attr);
		pushInstruction(mb, q);
		attrs[cnt] = getDestVar(q);
		cnt++;
	}
}

static char *
aggr_phase2(char *aggr)
{
	if (aggr == countRef /* || aggr == count_no_nilRef */)
		return sumRef;
	/* min/max/sum are fine */
	return aggr;
}

/* Group partial groupings */
static InstrPtr
mat_pack_group_(MalBlkPtr mb, mat_t *mat, int g, int ext)
{
	int cnt = group_chain_list_length(mb, getArg(mat[g].mi, 1), mb->stop);
	int *attrs = alloca(cnt * sizeof(int) * mat[ext].mi->argc), k, i;
	InstrPtr cur = NULL;

	for(k=1; k<mat[ext].mi->argc; k++) 
		group_attrs(attrs+k*cnt, mb, getArg(mat[g].mi, k), getArg(mat[ext].mi, k));
	for(i=cnt-1; i>=0; i--) {
		/* pack, group (or derive) */
		InstrPtr pck = newInstruction(mb, ASSIGNsymbol);
		InstrPtr grp = newInstruction(mb, ASSIGNsymbol);

		setModuleId(grp,groupRef);
		setFunctionId(grp, newRef);
		
		setModuleId(pck,matRef);
		setFunctionId(pck,packRef);
		getArg(pck,0) = newTmpVariable(mb, getVarType(mb, attrs[cnt+i]));
		for(k=1; k<mat[g].mi->argc; k++) 
			pck = pushArgument(mb, pck, attrs[k*cnt+i]);
		pushInstruction(mb, pck);

		getArg(grp,0) = newTmpVariable(mb, newBatType(TYPE_oid,TYPE_int));
		grp = pushReturn(mb, grp, newTmpVariable(mb, newBatType(TYPE_oid,TYPE_oid)));
		if (cur) {
			setFunctionId(grp, deriveRef);
			grp = pushArgument(mb, grp, getArg(cur, 0));
			grp = pushArgument(mb, grp, getArg(cur, 1));
		}
		grp = pushArgument(mb, grp, getArg(pck, 0));
		pushInstruction(mb, grp);
		cur = grp;
	}
assert(cur);
	return cur;
}

static InstrPtr
bat_mirror(MalBlkPtr mb, InstrPtr p )
{
	InstrPtr bm = newInstruction(mb, ASSIGNsymbol);
	int tpe = getHeadType(getArgType(mb, p, 0)); 
	
	setModuleId(bm, batRef);
	setFunctionId(bm, mirrorRef);

	getArg(bm,0) = newTmpVariable(mb, newBatType(tpe,tpe));
	bm = pushArgument(mb, bm, getArg(p, 0));
	pushInstruction(mb, bm);
	propagateProp(mb, bm, getArg(p, 0));
	return bm;
}

static InstrPtr
mat_pack_group(MalBlkPtr mb, mat_t *mat, int g, int ext)
{
	InstrPtr pgrp = mat[g].mm;

	if (!pgrp)
		pgrp = mat_pack_group_(mb, mat, g, ext);
	if (!mat[ext].mm) {
		mat[ext].mm = pgrp;	
		if (mat[ext].type == mat_ext)
			mat[ext].mm = bat_mirror(mb, pgrp);	
	}
	mat[g].mm = pgrp;	/* (arg1) grp */
	return pgrp;
}

static void
mat_aggr(MalBlkPtr mb, InstrPtr p, mat_t *mat, int m)
{
	int tp = getArgType(mb,p,0), k;
	InstrPtr r = newInstruction(mb,ASSIGNsymbol), q;
	int isSum = (getFunctionId(p) == sumRef); 

	getArg(r,0) = getArg(p,0);
	if (getFunctionId(p) == minRef || getFunctionId(p) == maxRef)
		r = pushNil(mb, r, tp);
	else
		r = pushZero(mb, r, tp);
	pushInstruction(mb,r);
	for(k=1; k< mat[m].mi->argc; k++){
		int v = newTmpVariable(mb, tp);

		q = newInstruction(mb,ASSIGNsymbol);
		setModuleId(q,aggrRef);
		setFunctionId(q,getFunctionId(p));
		getArg(q,0) = v;
		q = pushArgument(mb,q,getArg(mat[m].mi,k));
		pushInstruction(mb,q);
		/* for now we fallback to the old sum(empty) == 0 semantics */
		if (isSum)
			pushBit(mb, q, FALSE);

		q = newInstruction(mb,ASSIGNsymbol);
		setModuleId(q,calcRef);
		if (getFunctionId(p) == minRef || getFunctionId(p) == maxRef)
			setFunctionId(q,getFunctionId(p));
		else
			setFunctionId(q, plusRef);
		getArg(q,0) = getArg(r,0);
		//q = pushArgument(mb, q, getArg(r,0));
		q = pushArgument(mb, q, v);
		pushInstruction(mb, q);
	}
}

static void
mat_group_aggr(MalBlkPtr mb, InstrPtr p, mat_t *mat, int m, int g, int ext)
{
	int tp = getArgType(mb,p,0), k;
	char *aggr2 = aggr_phase2(getFunctionId(p));
	InstrPtr ai1 = newInstruction(mb, ASSIGNsymbol), ai2, cur = NULL;

	setModuleId(ai1,matRef);
	setFunctionId(ai1,packRef);
	getArg(ai1,0) = newTmpVariable(mb, tp);

assert(mat[m].mi->argc == mat[g].mi->argc);
assert(mat[g].mi->argc == mat[ext].mi->argc);
	for(k=1; k<mat[m].mi->argc; k++) {
		InstrPtr q = copyInstruction(p);
		getArg(q,0) = newTmpVariable(mb, tp);
		getArg(q,1) = getArg(mat[m].mi,k);
		getArg(q,2) = getArg(mat[g].mi,k);
		getArg(q,3) = getArg(mat[ext].mi,k);
		pushInstruction(mb,q);

		/* pack the into a bat */
		ai1 = pushArgument(mb,ai1,getArg(q,0));
	}
	pushInstruction(mb, ai1);

 	ai2 = newInstruction(mb, ASSIGNsymbol);
	setModuleId(ai2, aggrRef);
	setFunctionId(ai2, aggr2);
	getArg(ai2,0) = getArg(p,0);

	cur = mat_pack_group(mb, mat, g, ext);
	ai2 = pushArgument(mb, ai2, getArg(ai1, 0));
	ai2 = pushArgument(mb, ai2, getArg(cur, 1));
	ai2 = pushArgument(mb, ai2, getArg(cur, 0));
	pushInstruction(mb, ai2);
	freeInstruction(p);
}

static InstrPtr
mat_group_new(InstrPtr *ext, MalBlkPtr mb, InstrPtr p, mat_t *mat, int m)
{
	int tp0 = getArgType(mb,p,0);
	int tp1 = getArgType(mb,p,1);
	int k;
	InstrPtr r0 = newInstruction(mb, ASSIGNsymbol);
	InstrPtr r1 = newInstruction(mb, ASSIGNsymbol);

	setModuleId(r0,matRef);
	setFunctionId(r0,newRef);
	getArg(r0,0) = getArg(p,0);

	setModuleId(r1,matRef);
	setFunctionId(r1,newRef);
	getArg(r1,0) = getArg(p,1);
	
	for(k=1; k<mat[m].mi->argc; k++) {
		InstrPtr q = copyInstruction(p);
		getArg(q,0) = newTmpVariable(mb, tp0);
		getArg(q,1) = newTmpVariable(mb, tp1);
		getArg(q,2) = getArg(mat[m].mi,k);
		pushInstruction(mb,q);
		propagateProp(mb, q, getArg(mat[m].mi, k));

		/* add result to mat */
		r0 = pushArgument(mb,r0,getArg(q,0));
		r1 = pushArgument(mb,r1,getArg(q,1));
	}
	freeInstruction(p);
	*ext = r0;
	return r1;
}

static InstrPtr
mat_group_derive(InstrPtr *exti, MalBlkPtr mb, InstrPtr p, mat_t *mat, int ext, int grp, int attr)
{
	int tp0 = getArgType(mb,p,0);
	int tp1 = getArgType(mb,p,1);
	int i,k;
	InstrPtr r0 = newInstruction(mb, ASSIGNsymbol);
	InstrPtr r1 = newInstruction(mb, ASSIGNsymbol);

	setModuleId(r0,matRef);
	setFunctionId(r0,newRef);
	getArg(r0,0) = getArg(p,0);

	setModuleId(r1,matRef);
	setFunctionId(r1,newRef);
	getArg(r1,0) = getArg(p,1);
	
	/* we need overlapping ranges */
	for(i=1; i<mat[ext].mi->argc; i++) {
	    for(k=1; k<mat[attr].mi->argc; k++) {
 	   	if (Hoverlap(mb, getArg(mat[ext].mi, i), getArg(mat[attr].mi, k))){
			InstrPtr q = copyInstruction(p);
			getArg(q,0) = newTmpVariable(mb, tp0);
			getArg(q,1) = newTmpVariable(mb, tp1);
			getArg(q,2) = getArg(mat[ext].mi,i);
			getArg(q,3) = getArg(mat[grp].mi,i);
			getArg(q,4) = getArg(mat[attr].mi,k);
			pushInstruction(mb,q);
			propagateProp(mb, q, getArg(mat[ext].mi, i));
	
			/* add result to mat */
			r0 = pushArgument(mb,r0,getArg(q,0));
			r1 = pushArgument(mb,r1,getArg(q,1));
		}
	    }
	}
	freeInstruction(p);
	*exti = r0;
	return r1;
}

static InstrPtr
mat_union(MalBlkPtr mb, InstrPtr p, mat_t *mat, int m, int n)
{
	int k;
	InstrPtr r = newInstruction(mb, ASSIGNsymbol);

	setModuleId(r,matRef);
	setFunctionId(r,newRef);
	getArg(r,0) = getArg(p,0);
	
	if (m >= 0) {
		for(k=1; k<mat[m].mi->argc; k++) 
			r = pushArgument(mb, r, getArg(mat[m].mi,k));
	} else {
		r = pushArgument(mb, r, getArg(p,1));
	}
	if (n >= 0) {
		for(k=1; k<mat[n].mi->argc; k++) 
			r = pushArgument(mb, r, getArg(mat[n].mi,k));
	} else {
		r = pushArgument(mb, r, getArg(p,2));
	}
	freeInstruction(p);
	return r;
}

static InstrPtr
mat_mark(MalBlkPtr mb, InstrPtr p, mat_t *mat, int m)
{
	int tpe = getArgType(mb,p,0);
	int k,o = newTmpVariable(mb,TYPE_oid);
	InstrPtr q, r = newInstruction(mb, ASSIGNsymbol);
	oid cur = 0;
	
	getArg(r,0) = o;
	/* get the mark base id */
	r = pushArgument(mb, r, getArg(p, 2));
	pushInstruction(mb, r);
	
	r = newInstruction(mb, ASSIGNsymbol);
	setModuleId(r,matRef);
	setFunctionId(r,newRef);
	getArg(r,0) = getArg(p,0);
	
	for(k=1; k<mat[m].mi->argc; k++) {
		q = copyInstruction(p);
		getArg(q,0) = newTmpVariable(mb, tpe);
		getArg(q,1) = getArg(mat[m].mi,k);
		getArg(q,2) = o;
		pushInstruction(mb,q);

		propagateMarkProp(mb, q, getArg(mat[m].mi, k), cur, cur+1);
		cur++;

		/* add result to mat */
		r = pushArgument(mb,r,getArg(q,0));

		/* increment oid */
		if (k < mat[m].mi->argc-1) {
			InstrPtr ca, c, bc = newInstruction(mb, ASSIGNsymbol);
			
			/* bc = bat.count */
			setModuleId(bc, aggrRef);
			setFunctionId(bc, countRef);
			getArg(bc, 0) = newTmpVariable(mb, TYPE_int);
			bc = pushArgument(mb, bc, getArg(mat[m].mi,k));
			pushInstruction(mb, bc);

			/* convert int to oid */
			c = newInstruction(mb, ASSIGNsymbol);
			setModuleId(c, calcRef);
			setFunctionId(c, oidRef);
			getArg(c, 0) = newTmpVariable(mb, TYPE_oid);
			c = pushArgument(mb, c, getArg(bc,0));
			pushInstruction(mb, c);

			/* ca = calc.add */
			ca = newInstruction(mb, ASSIGNsymbol);
			setModuleId(ca, calcRef);
			setFunctionId(ca, plusRef);
			getArg(ca, 0) = o;
			ca = pushArgument(mb, ca, o);
			ca = pushArgument(mb, ca, getArg(c, 0));
			pushInstruction(mb, ca);
		}
	}
	freeInstruction(p);
	return r;
}
#if 0
static void 
MATcollect(int m, mat_t *mat, int mtop, int *newvar, int *n){
	int i,j,k;
	for(i= mat[m].mi->retc; i<mat[m].mi->argc; i++) {
		if( (j= isMATalias( getArg(mat[m].mi,i), mat, mtop)) >= 0) {
			for(k=0; k<mtop; k++)
				if (mat[k].mv == j)
					MATcollect(k, mat, mtop, newvar, n);
		} else { 
			newvar[*n] = getArg(mat[m].mi,i); 
			*n = *n+1;
		}
	}
}
#endif

static int
MATcount(InstrPtr p, mat_t *mat, int mtop)
{
	int j,cnt=0;
	for(j=p->retc; j<p->argc; j++)
		if (isMATalias(getArg(p,j), mat, mtop) >= 0) 
			cnt++;
	return cnt;
}

static int
OPTmergetableImplementation(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p) 
{
	InstrPtr *old=0, q, r;
	mat_t *mat;
	int oldtop, fm, i, k, m, mtop=0, tpe, slimit;
	int size, match, actions=0;

#ifdef DEBUG_OPT_MERGETABLE
	stream_printf(cntxt->fdout,"Start MAT optimizer\n");
#else
	(void) cntxt;
#endif
	old = mb->stmt;
	oldtop= mb->stop;
	slimit = mb->ssize;
	size = (mb->stop * 1.2 < mb->ssize)? mb->ssize:(int)(mb->stop * 1.2);
	mb->stmt = (InstrPtr *) GDKzalloc(size * sizeof(InstrPtr));
	mb->ssize = size;
	mb->stop = 0;

	/* the number of MATs is limited to the variable stack*/
	mat = (mat_t*) alloca(mb->vtop * sizeof(mat_t));
	memset((char*) mat, 0, mb->vtop * sizeof(mat_t));

	for( i=0; i<oldtop; i++){
		int n = -1, o = -1;

		p = old[i];
		if (getModuleId(p) == matRef && 
		   (getFunctionId(p) == newRef || getFunctionId(p) == packRef)){
			mtop = mat_add(mat, mtop, mb, p, mat_none);
			continue;
		}
@-
If the instruction does not contain MAT references it can simply be added.
Otherwise we have to decide on either packing them or replacement.
@c
		if ((match = MATcount(p, mat, mtop)) == 0) {
			if (p->argc >= 2) {
				if (getFunctionId(p) == markHRef|| 
				    getFunctionId(p) == markTRef) {
					propagateMarkProp(mb, p, getArg(p,1), 0, 1);
				} else if (getFunctionId(p) == joinRef|| 
				    getFunctionId(p) == kunionRef) {
					propagateBinProp(mb, p, getArg(p,1), getArg(p,2));
				} else {
					propagateProp(mb, p, getArg(p,1));
				}
			}
			pushInstruction(mb,p);
			continue;
		}
@-
Sometimes mats are reused (ie input mats are used as the output). Such
statements can allways be done by iterating over the parts.
@c
		if (match > 0 && (m=isMATalias(getArg(p,0), mat, mtop)) >= 0) {
			int x = -1;
			if (match > 1) {
				n = isMATalias(getArg(p,1), mat, mtop);
				o = isMATalias(getArg(p,2), mat, mtop);
				x = isMATalias(getArg(p,3), mat, mtop);
				assert(m==n);
			}
			mat_apply(mb, p, mat, &mtop, m, o, x, 1); 
			actions++;
			continue;
		}
@- 
Here we handle horizontal aligned mats. This information is passed using
the properties hlb <= x < hub. 
So if this is available, we can simplify 
batcalc operations and for fetch joins we can use this information to do 
per part joins only.

Also we should translate the mirror().join() (a groupby attribute) into
UNION(mirror().join()).
@c

		if (match > 0 &&
		    getModuleId(p) == algebraRef && 
		    getFunctionId(p) == joinRef) {
			InstrPtr j;

		   	m = isMATalias(getArg(p,1), mat, mtop);
		   	n = isMATalias(getArg(p,2), mat, mtop);
			j = mat_join(mb, p, mat, m, n);
			mtop = mat_add(mat, mtop, mb, j, mat_none);
		    	if (m >= 0 && mat[m].type == mat_ext) 
				(void)MATpackAll(mb, NULL, mat, mtop-1, &mtop); 
			actions++;
			continue;
		}
		/* all batcalc and mkey operations assume aligned bats */
		if (match >= 1 && (getModuleId(p) == batcalcRef || 
		    getModuleId(p) == batstrRef ||
		    getModuleId(p) == mkeyRef ||
		    (getModuleId(p) == algebraRef && 
		     (getFunctionId(p) == semijoinRef ||
		      getFunctionId(p) == kdifferenceRef ||
		      (getFunctionId(p) == kunionRef && match == 2))))) { 
			InstrPtr bc;

			m = isMATalias(getArg(p,1), mat, mtop);
			if (p->argc >= 3)
		 		n = isMATalias(getArg(p,2), mat, mtop);
			if (p->argc >= 4)
		 		o = isMATalias(getArg(p,3), mat, mtop);
			if ((bc = mat_apply(mb, p, mat, &mtop, m, n, o, 0)) != NULL)
				mtop = mat_add(mat, mtop, mb, bc, mat_none );
			actions++;
			continue;
		}
@- 
Now we handle group, derive and aggregation statements. 
@c
		if (match == 1 && getModuleId(p) == groupRef && 
		    getFunctionId(p) == newRef && 
	 	   ((m=isMATalias(getArg(p,2), mat, mtop)) >= 0)) {
			InstrPtr ext, grp;
		
			grp = mat_group_new(&ext, mb, p, mat, m);
			mtop = mat_add(mat, mtop, mb, grp, mat_grp);
			mtop = mat_add(mat, mtop, mb, ext, mat_hist);
			/* here we keep that ext and grp are related */
			mat[mtop-1].rm = mtop-2;
			mat[mtop-2].rm = mtop-1;
			actions++;
			continue;
		}
		if (match == 3 && getModuleId(p) == groupRef && 
		    getFunctionId(p) == deriveRef &&
		   ((m=isMATalias(getArg(p,2), mat, mtop)) >= 0) &&
		   ((n=isMATalias(getArg(p,3), mat, mtop)) >= 0) &&
		   ((o=isMATalias(getArg(p,4), mat, mtop)) >= 0)) {
			InstrPtr ext, grp;
		
			grp = mat_group_derive(&ext, mb, p, mat, m, n, o);
			mtop = mat_add(mat, mtop, mb, grp, mat_grp);
			mtop = mat_add(mat, mtop, mb, ext, mat_hist);
			/* here we keep that ext and grp are related */
			mat[mtop-1].rm = mtop-2;
			mat[mtop-2].rm = mtop-1;
			actions++;
			continue;
		}
		if (match == 3 && getModuleId(p) == aggrRef && p->argc == 4 &&
		   (getFunctionId(p) == countRef ||
		    getFunctionId(p) == minRef ||
		    getFunctionId(p) == maxRef ||
		    getFunctionId(p) == sumRef) &&
		   ((m=isMATalias(getArg(p,1), mat, mtop)) >= 0) &&
		   ((n=isMATalias(getArg(p,2), mat, mtop)) >= 0) &&
		   ((o=isMATalias(getArg(p,3), mat, mtop)) >= 0)) {
			mat_group_aggr(mb, p, mat, m, n, o);
			actions++;
			continue;
		}
@-
Pack MAT arguments, except one, to limit plan explosion.
The preferred partitioned one is the first argment as it
often reflects a base table.
Look at the depth of the MAT definition to limit the explosion.
@c
		for( fm= p->argc-1; fm>p->retc ; fm--)
			if ((m=isMATalias(getArg(p,fm), mat, mtop)) >= 0)
				break;

		for( k=fm-1; match > 1 && k >= p->retc ; k--) {
			if ((m=isMATalias(getArg(p,k), mat, mtop)) >= 0) {
				r= MATpackAll(mb, NULL, mat, m, &mtop);
				getArg(p,k) = getArg(r,0);
				match--;
			}
		}
@-
From here we have to differentiate between the operations.
Their semantics should be respected while producing code.
@-
The insertions are sent to the first component of the MAT.
Selection of the proper component based on e.g. range descriptors is for
later.

CAVEAT. The MATs that represent partitions in SQL can not
be packed to facilitate updates. We assume the first
partition is dominant. 
@c
		if (match &&
		    (
		   /*(getModuleId(p)== batRef && 
		     (getFunctionId(p)== insertRef ||
		      getFunctionId(p)== appendRef)) ||*/
		     (getModuleId(p) == algebraRef &&
		      getFunctionId(p)== kunionRef))) {
			/* bat.insert(mat,b or val) 
			   bat.append()
			   bat.kunion()
			-> mat.union(mat, b or val) */
			InstrPtr u;

			m = isMATalias(getArg(p,1), mat, mtop);
			n = isMATalias(getArg(p,2), mat, mtop);
			u = mat_union(mb, p, mat, m, n);
			mtop = mat_add(mat, mtop, mb, u, mat_none);
			actions++;
			continue;
		} 
@-
The mark operators are a special case of apply on parts as we need too
correct the mark base oid's 
@c
		if (match && 
		    getModuleId(p) == algebraRef && 
		    (getFunctionId(p) == markTRef ||
		     getFunctionId(p) == markHRef)) { 
			InstrPtr mark;

			m = isMATalias(getArg(p,1), mat, mtop);
 			mark = mat_mark(mb, p, mat, m);
			mtop = mat_add(mat, mtop, mb, mark, mat_none);
			actions++;
			continue;
		}
@-
The delete operator is a good example where the
action does not produce multiple results, but requires
an accumulation implementation.
@-
A similar situation occurs in delete operations 
using partitioned input.
@c

		if((getModuleId(p) == batRef && getFunctionId(p) == deleteRef) 
		    && fm == 2 && (m=isMATalias(getArg(p,fm), mat, mtop)) >= 0){
			tpe= getVarType(mb,getArg(p,0));
			for(k=1; k< mat[m].mi->argc; k++){
				q= copyInstruction(p);
				if( k == mat[m].mi->argc-1) {
					getArg(q,0)= getArg(p,0);
				} else {
					getArg(q,0) = newTmpVariable(mb, tpe);
					getArg(p,1)= getArg(q,0);
				}
				getArg(q,fm) = getArg(mat[m].mi,k);
				pushInstruction(mb,q);
			}
			freeInstruction(p);
			continue;
		}
@-
Not all instructions can be replaced by the sequence. We have to
group them and check for them individually.
@c
		if (isFragmentGroup(p) && 
		   (m=isMATalias(getArg(p,fm), mat, mtop)) >= 0){
			int pack_mirror = 0;
			InstrPtr r;

			if (getFunctionId(p) == mirrorRef && 
	    			mat[m].type == mat_hist) 
				pack_mirror = 1;
			if ((r = mat_apply1(mb, p, mat, m, fm, 0)) != NULL)
				mtop = mat_add(mat, mtop, mb, r, mat_none);
			/* packed group should include the mirror statement */
			if (pack_mirror) {
				mat[mtop-1].type = mat_ext;
				mat_pack_group(mb, mat, mat[m].rm, mtop-1);
			}
			actions++;
			continue;
		} 
@-
Aggregate handling is a prime target for optimization.
The simple cases are dealt with first.
Handle the rewrite v:=aggr.count(b) and sum()
And the min/max is as easy
@c
		if( getModuleId(p)==aggrRef && 
			(getFunctionId(p)== countRef || 
			(getFunctionId(p)== minRef && p->argc==2) ||
			(getFunctionId(p)== maxRef && p->argc==2) ||
			(getFunctionId(p)== sumRef && p->argc==2)) &&
			(m=isMATalias(getArg(p,fm), mat, mtop)) >= 0){
			mat_aggr(mb, p, mat, m);
			actions++;
			continue;
		} 
@-
All other instructions should be checked for remaining MAT dependencies.
It requires MAT materialization. 
@c
		for (k = p->retc; k<p->argc; k++) {
			if((m=isMATalias(getArg(p,k), mat, mtop)) >= 0){
				r= MATpackAll(mb, NULL, mat, m, &mtop);
				actions++;
				break;
			}
		}
		pushInstruction(mb,p);
		if (p->argc >= 2)
			propagateProp(mb, p, getArg(p,1));
	}
	for(; i<slimit; i++)
	if( old[i])
		freeInstruction(old[i]);
	GDKfree(old);
@-
As a final optimization, we could remove the mal.new definitions,
because they are not needed for the execution.
For the time being, they are no-ops.
@c
	(void) stk; 
#ifdef DEBUG_OPT_MERGETABLE
	stream_printf(cntxt->fdout,"Result of multi table optimizer\n");
	optimizerCheck(cntxt,mb,"merge test",1,0,0);
	printFunction(cntxt->fdout, mb, LIST_MAL_ALL| LIST_MAL_PROPS);
#endif

	return actions;
}
@include optimizerWrapper.mx
@h
@:exportOptimizer(mergetable)@
#endif
@c
#include "opt_statistics.h"
@:wrapOptimizer(mergetable,OPT_CHECK_ALL)@
@}
