@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
@' Copyright August 2008-2010 MonetDB B.V.
@' All Rights Reserved.

@f opt_derivepath
@- Group derive paths
The routine @sc{optimizer.derivepaths()}
walks through the program looking for grouping operations
and cascades them into a single multiple group paths.
To illustrate, consider
@verbatim
	(ext1,grp1) := group.new(b);
	(ext2,grp2) := group.derive(ext1,grp1, c);
	(ext3,grp3) := group.done(ext2,grp2, d);
@end verbatim
The result becomes.
@verbatim
	(ext3,grp3) := group.derivepath(b,c,d);
@end verbatim

The implementation of this operator can freely re-order the BATs 
for reduced intermediate results or as a basis for parallel scanning
all BATs involved to derive their group id.

The collection can be extended to immediately aim for group counting
or summation, avoiding the materialisation of the group id table.
@mal
pattern optimizer.derivePath():str
address OPTderivePath;
pattern optimizer.derivePath(mod:str, fcn:str):str
address OPTderivePath
comment "Join path constructor";

pattern group.derivePath(l:bat[:oid,:any]...)(grp:bat[:oid,:any],ext:bat[:oid,:any])
address ALGderivePath
comment "Derive a group index.";

pattern group.deriveCount(l:bat[:oid,:any]...):bat[:oid,:wrd]
address ALGderiveCount
comment "Derive a group count.";

pattern group.deriveSum(s:bat[:oid,:int],l:bat[:oid,:any]...):bat[:oid,:int]
address ALGderiveSum
comment "Derive a group sum.";
pattern group.deriveSum(s:bat[:oid,:lng],l:bat[:oid,:any]...):bat[:oid,:lng]
address ALGderiveSum
comment "Derive a group sum.";
pattern group.deriveSum(s:bat[:oid,:flt],l:bat[:oid,:any]...):bat[:oid,:flt]
address ALGderiveSum
comment "Derive a group sum.";
pattern group.deriveSum(s:bat[:oid,:dbl],l:bat[:oid,:any]...):bat[:oid,:dbl]
address ALGderiveSum
comment "Derive a group sum.";
@{
@h
#ifndef _OPT_DERIVEPATH_
#define _OPT_DERIVEPATH_
#include "opt_prelude.h"
#include "opt_support.h"
#include "mal_interpreter.h"

#define DEBUG_OPT_DERIVEPATH  /**/
opt_export str ALGderivePath(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
opt_export str ALGderiveCount(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
opt_export str ALGderiveSum(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
@c
#include "mal_config.h"
#include "opt_derivepath.h"
#include "group.h"

static int
OPTderivePathImplementation(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	int i, actions=0;
	int *pc;
	InstrPtr q;
	InstrPtr *old;
	int limit,slimit;
    Lifespan span;



	(void) cntxt;
	(void) stk;
    span= setLifespan(mb);
    if( span == NULL)
        return 0;
	if (varGetProp(mb, getArg(mb->stmt[0], 0), inlineProp) != NULL)
		return 0;

	/* beware, new variables and instructions are introduced */
	pc= (int*) GDKzalloc(sizeof(int)* mb->vtop * 2); /* to find last assignment */
	if ( pc == NULL)
		return 0;

	old= mb->stmt;
	limit= mb->stop;
	slimit= mb->ssize;
	if ( newMalBlkStmt(mb,mb->ssize) <0)
		return 0;

	for (i = 0; i<limit; i++){
		p= old[i];
		if (getModuleId(p) == groupRef && p->argc == 3 && getFunctionId(p) == newRef ){
				setFunctionId(p,derivePathRef);
				pc[getArg(p,0)] = i;
				pc[getArg(p,1)] = i;
				actions++;
#ifdef DEBUG_OPT_DERIVEPATH 
				stream_printf(cntxt->fdout,"new derivePath instruction\n");
				printInstruction(cntxt->fdout,mb, 0, p, LIST_MAL_ALL);
#endif
		}
		if (getModuleId(p) == groupRef && p->argc == 5 && (getFunctionId(p) == deriveRef || getFunctionId(p) == doneRef)){
@-
Try to expand its argument list with what we have found so far.
This creates a series of derive paths, many of which will be removed during deadcode elimination.
@c
			if (pc[getArg(p,2)] && pc[getArg(p,2)]== pc[getArg(p,3)]){
				q= copyInstruction(getInstrPtr(mb,pc[getArg(p,2)]));
				q= pushArgument(mb,q, getArg(p,4));
				getArg(q,0) = getArg(p,0);
				getArg(q,1) = getArg(p,1);
				pc[getArg(q,0)] = i;
				pc[getArg(q,1)] = i;
				freeInstruction(p);
				p= q;
#ifdef DEBUG_OPT_DERIVEPATH 
				stream_printf(cntxt->fdout,"new derivePath instruction extension\n");
				printInstruction(cntxt->fdout,mb, 0, p, LIST_MAL_ALL);
#endif
			}
		} 
		pushInstruction(mb,p);
	}
	for(; i<slimit; i++)
	if(old[i])
		freeInstruction(old[i]);
	GDKfree(old);
	GDKfree(pc);
	OPTDEBUG
	if ( actions)
		stream_printf(cntxt->fdout,"#opt_derivepath: %d statements glued\n",actions);
	return actions;
}
@include optimizerWrapper.mx
@h
@:exportOptimizer(derivePath,OPT_CHECK_ALL)@
#endif
opt_export str ALGderivePath(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
@c
#include "opt_statistics.h"
@:wrapOptimizer(derivePath,OPT_CHECK_ALL)@
@-
The derive path optimizer takes a derivation sequence and attempts to minimize the intermediate result.
The choice depends on a good estimate of intermediate results using properties.
For the time being, we use a simplistic model, based on the assumption that most joins are foreign key joins anyway.
@c
typedef struct{
	int *arg;
	BAT *b;
} Elm;
str
ALGderivePath(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	int *grp = (int*) getArgReference(stk,pci,0);
	int *ext = (int*) getArgReference(stk,pci,1);
	Elm *path = (Elm *) GDKzalloc(pci->argc * sizeof(Elm));
	int i, newgrp, newext;
	str msg = MAL_SUCCEED;

	if ( path == NULL)
		throw(MAL,"group.derivePath",MAL_MALLOC_FAIL);
	/* collect the properties (histograms) for all columns */
	for ( i = 2; i < pci->argc; i++){
		path[i].arg = (int*) getArgReference(stk,pci,i);
	}
	/* determine an optimal order for derivation by reshuffling */

	msg = GRPgroup(grp, ext, path[2].arg);
	for ( i=3; msg == MAL_SUCCEED && i < pci->argc; i++){
		msg = GRPderive(&newgrp, &newext, grp, ext, path[i].arg);
		if ( msg == MAL_SUCCEED){
			BBPreleaseref(*grp);
			BBPreleaseref(*ext);
			*grp = newgrp;
			*ext = newext;
		}
	}
	/* remove the histograms */
	for ( i = 2; i < pci->argc; i++){
	}
	GDKfree(path);
	(void) cntxt;
	(void) mb;
	return msg;
}

str
ALGderiveCount(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	(void) cntxt;
	(void) mb;
	(void) stk;
	(void) pci;
	throw(MAL,"group.deriveCount",PROGRAM_NYI);
}

str
ALGderiveSum(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	(void) cntxt;
	(void) mb;
	(void) stk;
	(void) pci;
	throw(MAL,"group.deriveSum",PROGRAM_NYI);
}

@}
