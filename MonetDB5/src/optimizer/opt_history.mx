@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
@' Copyright August 2008-2009 MonetDB B.V.
@' All Rights Reserved.

@f opt_history
@- SQL History 
Collection of runtime statistics on SQL queries 
is handy for post-session analysis. To accomplish
this, the very last step of the optimization consists
of injection of performance gathering statements.
This way we ensure that no code shuffling optimizer has effect.

The interface is based on two MAL signatures defined in
the SQL runtime environment. A dummy version is included
here to ensure we can debug the code without SQL frontend.


create table queryHistory(
    id wrd primary key,
    defined timestamp,  -- when entered into the cache
    ipnumber string,    -- origin of the request
    name string,        -- database user name
    query string,
    parse bigint,       -- time in usec
    optimize bigint     -- time in usec
);

create table History(
	id wrd references queryHistory(id), -- references query plan
    called timestamp,   -- time the first statement was executed
    arguments string,
    xtime bigint,       -- time from the first statement until result export
    rtime bigint,       -- time to ship the result to the client
    foot bigint,        -- footprint for all bats in the plan
    xsize bigint,       -- storage size of intermediates created
    tuples bigint,      -- number of tuples in the result set
    inblock bigint,     -- number of physical blocks read
    oublock bigint,     -- number of physical blocks written
)
@{
The keepquery is defined to trigger an expection the first
time you use the history without initialization.
The keepcall can be used to check for initialization of the cache.
@mal
module sql;
function keepquery{unsafe}(qid:int,qry:str,parse:lng,optimize:lng):void;
	raise SQLexception:= "SQL history script should be run first";
end keepquery;

#function keepcall{unsafe}(qid:int, call:timestamp,arg:str,elap:lng,inblock:lng,oublock:lng):void;
#	raise SQLexception:= "SQL history script should be run first";
#end keepcall;

function queryId{unsafe}(qid:int):void;
end queryId;

pattern forgetPrevious():void
address OPTforgetPrevious
comment "invalidate the previous instruction from future execution";

pattern optimizer.history():str
address OPThistory;
pattern optimizer.history(mod:str, fcn:str):str
address OPThistory
comment "Collect SQL query statistics";

@h
#ifndef _OPT_QUERYHISTORY_
#define _OPT_QUERYHISTORY_

#include "mal_config.h"
#include "opt_prelude.h"
#include "opt_support.h"
#include "mal_interpreter.h"
#include "mal_instruction.h"
#include "mal_function.h"

opt_export str OPTforgetPrevious(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
/* #define _DEBUG_OPT_QUERYHISTORY_      trace its behavior */
@-
Prepare the call to the history manager.
@= arguments
	q = newStmt(mb,"sql","argRecord");
	for ( argc=1; argc < old[0]->argc; argc++)
		q = pushArgument(mb, q, getArg(old[0],argc));
	arg= getArg(q,0)= newVariable(mb,GDKstrdup("args"),TYPE_str);
@-
@= initCounter
	q = newStmt(mb,"@2","@3");
	@1= getArg(q,0)= newVariable(mb,GDKstrdup("@1"),TYPE_@4);
@= zeroCounter
	q = newAssignment(mb);
	q = push@2(mb,q,0);
	@1= getArg(q,0)= newVariable(mb,GDKstrdup("@1"),TYPE_@3);
@= initCounters
	@:initCounter(ctime,mtime,current_timestamp,any)@
	@:arguments@
	@:zeroCounter(memory,Lng,lng)@
	@:zeroCounter(tuples,Wrd,wrd)@
	q->argc--;
	pushWrd(mb,q,1);
	@:initCounter(inblock,profiler,getDiskReads,lng)@
	@:initCounter(oublock,profiler,getDiskWrites,lng)@
	@:initCounter(xtime,alarm,usec,lng)@
@-
A tricky piece of code. We invalidate an instruction
based on the return variable.
@c
#include "opt_history.h"

str 
OPTforgetPrevious(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	int pc;
	(void) cntxt;
	(void) stk;
	pc= getPC(mb,pci);
	assert ( pc > 0 && pc < mb->stop);
	mb->stmt[pc-1]->token = REMsymbol;
	return MAL_SUCCEED;
}

static int 
OPThistoryImplementation(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	int i, limit,slimit;
	InstrPtr p = 0, *old= mb->stmt, q,r;
	int argc, inblock, oublock, arg, ctime;
	int xtime=0, rtime = 0, foot=0, memory, tuples=0;
	int returnseen = 0;
	InstrPtr keepQuery = NULL;


	(void) pci;
	(void) stk;		/* to fool compilers */

#ifdef _DEBUG_OPT_QUERYHISTORY_
	stream_printf(cntxt->fdout,"ENTERING HISTORY OPTIMIZER CODE \n");
	printFunction(cntxt->fdout,mb,0,LIST_MAL_ALL);
#else
	(void) cntxt;
#endif
	/* gather information */
	for (i = 1; i < mb->stop; i++) {
		p = getInstrPtr(mb,i);
		if ( getModuleId(p)== userRef && idcmp(getFunctionId(p),"keepquery")==0){
			keepQuery= p;
			getVarConstant(mb,getArg(p,4)).val.lval = 
				GDKusec()-getVarConstant(mb,getArg(p,4)).val.lval ;
		}
	}
	if ( keepQuery == NULL)
		/* nothing to do */
		return 0;

	limit= mb->stop;
	slimit= mb->ssize;
	newMalBlkStmt(mb, 2 * mb->ssize); /* a new statement stack */

	pushInstruction(mb, old[0]);
	/* run the keepQuery operation once only */
	pushInstruction(mb, q = copyInstruction(keepQuery));
	q->token = ASSIGNsymbol;
	q = newStmt(mb,sqlRef,"forgetPrevious");

	/* collect the statistics */
	@:initCounters@

	for (i = 1; i < limit; i++) {
		p= old[i];
		
		if ( getModuleId(p)==sqlRef && 
			(idcmp(getFunctionId(p),"exportValue")==0 ||
			 idcmp(getFunctionId(p),"exportResult")==0  ) ){
			@:update(xtime,alarm,usec,-)@
			@:initCounter(rtime,alarm,usec,lng)@
			pushInstruction(mb,p);
			continue;
		}	
		if (getModuleId(p)==sqlRef && idcmp(getFunctionId(p),"resultSet")==0 ){
			@:initCounter(tuples,aggr,count,wrd)@
			q= pushArgument(mb,q, getArg(p,3));
		}
		if ( p->token== ENDsymbol || p->barrier == RETURNsymbol || p->barrier == YIELDsymbol){
			if (rtime ){
				@:update(rtime,alarm,usec,-)@
			} else {
				@:zeroCounter(rtime,Lng,lng)@
			}
			if (returnseen && p->token == ENDsymbol) {
				pushInstruction(mb,p);
				continue;
			}
			returnseen++;
@-
@= update
			q = newStmt(mb,"@2","@3");
			r = newStmt(mb,"calc","@4");
			r = pushArgument(mb,r, getArg(q,0));
			r = pushArgument(mb,r, @1);
			getArg(r,0)=@1;
@c
			@:initCounter(foot,profiler,getFootprint,lng)@
			@:initCounter(memory,profiler,getMemory,lng)@
			@:update(oublock,profiler,getDiskWrites,-)@
			@:update(inblock,profiler,getDiskReads,-)@

			q = newStmt(mb,"user","keepcall");
			q = pushArgument(mb, q, getArg(keepQuery,1)); /* query identifier */
			q = pushArgument(mb, q, ctime); /* arguments */
			q = pushArgument(mb, q, arg);   /* arguments */
			q = pushArgument(mb, q, xtime); 
			q = pushArgument(mb, q, rtime); 
			q = pushArgument(mb, q, foot); 
			q = pushArgument(mb, q, memory); 
			q = pushArgument(mb, q, tuples); 
			q = pushArgument(mb, q, inblock);/* inblock */
			q = pushArgument(mb, q, oublock);/* oublock */
			pushInstruction(mb,p);
			continue;
		}

		pushInstruction(mb,p);
		if (p->barrier == YIELDsymbol){
			/* the factory yield may return */
			@:initCounters@
		}
	}

#ifdef _DEBUG_OPT_QUERYHISTORY_
	stream_printf(cntxt->fdout,"LEAVING QUERYHISTORY CODE INJECTION\n");
	printFunction(cntxt->fdout,mb,0,LIST_MAL_ALL);
#endif
	for( ; i<slimit; i++)
	if(old[i])
		freeInstruction(old[i]);
	GDKfree(old);
	OPTDEBUG
		stream_printf(cntxt->fdout,"#opt_history: code added\n");
	return 1;
}
@include optimizerWrapper.mx
@h
@:exportOptimizer(history)@
#endif
@c
#include "opt_statistics.h"
@:wrapOptimizer(history,OPT_CHECK_ALL)@
@}
