@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2005 CWI.
@' All Rights Reserved.

@f mal_singleton
@a M. Kersten
@-
@node Singleton Set Replacement, Peephole Optimization, Empty Set Reduction,  Optimizer toolkit
@+ Singleton Set Reduction
Application semantics and precise cost analysis may
identify the result of an operation to produce a BAT with
a single element. Such variables can be tagged with the
property @code{singleton}, whereafter the operation
@code{optimizer.singleton()} derives an MAL program
using a symbolic evaluation as far as possible.

During its evaluation, more singleton sets can be created, 
leading to a ripple effect through the code.
A non-optimizable instruction leads to
a construction of a new table with the single instance.

@verbatim
    b:= bat.new(:int,:int);
    bat.insert(b,1,2);
    c{singleton}:= algebra.select(b,0,4);
    d:= algebra.markH(c);
    io.print(d);
    optimizer.singleton();
@end verbatim
is translated by into the code block
@verbatim
    b := bat.new(:int,:int);
    bat.insert(b,1,2);
    c{singleton} := algebra.select(b,0,4);
    ($15,$16):= bat.unpack(c{singleton});
    d := bat.pack(nil,$16);
    io.print(d);
@end verbatim
@{
@h
#ifndef _MAL_SINGLETON_
#define _MAL_SINGLETON_
#include "mal_optimizer.h"

/* #define DEBUG_MAL_SINGLETON     show partial result */

opt_export str SToptimizer(MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
opt_export str STevaluate(MalBlkPtr mb, int cnt, int *vars);
#endif
@c
#include "mal_singleton.h"
#include "mal_interpreter.h"	/* for showErrors() */
#include "mal_builder.h"
#include "mal_namespace.h"

@-
When we run into an instruction that can not be optimized,
we have to rebuild the singleton set as an ordinary BAT.
@c
typedef struct {
	int vidx;
	int hidx;
	int htpe;
	int tidx;
	int ttpe;
	int packed;
} STtuple;

void
STrebuildSet(MalBlkPtr mb, int sidx, int hidx, int tidx)
{
	InstrPtr p;
	int tpe;

	p = newStmt(mb, putName("bat", 3), putName("new", 3));
	p->argv[0] = sidx;
	tpe = getVarType(mb, hidx);
	if (tpe == TYPE_oid)
		tpe = TYPE_void;
	pushArgument(mb, p, newTmpVariable(mb, tpe));
	tpe = getVarType(mb, tidx);
	pushArgument(mb, p, newTmpVariable(mb, tpe));
	pushInt(mb, p, 1);

	p = newStmt(mb, putName("bat", 3), putName("insert", 3));
	pushArgument(mb, p, sidx);
	pushArgument(mb, p, hidx);
	pushArgument(mb, p, tidx);
}

int
STalias(int idx, int top, STtuple * tuples)
{
	int i;

	for (i = 0; i < top; i++)
		if (tuples[i].vidx == idx)
			return i;
	return -1;
}

int
STnewTuple(MalBlkPtr mb, int vidx, int *top, STtuple * tuples)
{
	tuples[*top].packed = 1;
	tuples[*top].vidx = vidx;
	tuples[*top].htpe = getHeadType(getVarType(mb, vidx));
	tuples[*top].hidx = newTmpVariable(mb, tuples[*top].htpe);
	setVarUsed(mb, tuples[*top].hidx, TRUE);
	setVarInitialized(mb, tuples[*top].hidx);
	tuples[*top].ttpe = getTailType(getVarType(mb, vidx));
	tuples[*top].tidx = newTmpVariable(mb, tuples[*top].ttpe);
	setVarUsed(mb, tuples[*top].tidx, TRUE);
	setVarInitialized(mb, tuples[*top].tidx);
	*top = *top + 1;
	return *top - 1;
}

void
STunpack(MalBlkPtr mb, int varid, STtuple * tuples)
{
	InstrPtr p = 0;

	if (tuples[varid].packed == 0)
		return;

	p = newFcnCall(mb, putName("bat", 3), putName("unpack", 6));
	getArg(p, 0) = tuples[varid].hidx;
	setArgument(mb, p, 1, tuples[varid].tidx);
	p->retc++;
	pushArgument(mb, p, tuples[varid].vidx);
	tuples[varid].packed = 0;
}

void
STpack(MalBlkPtr mb, int varid, STtuple * tuples)
{
	InstrPtr p = 0;

	p = newFcnCall(mb, putName("bat", 3), putName("pack", 4));
	getArg(p, 0) = tuples[varid].vidx;
	p->retc = 1;
	p->argc = 1;
	pushArgument(mb, p, tuples[varid].hidx);
	pushArgument(mb, p, tuples[varid].tidx);
}

str
STevaluate(MalBlkPtr mb, int cnt, int *vars)
{
	lng clk = GDKusec();
	int i, j = 0, k, limit, doAR = 0;
	InstrPtr p;
	InstrPtr *old;
	STtuple *tuples;
	int top = 0;

	if( mb->errors) 
		return MAL_SUCCEED;
	tuples = alloca(mb->stop * sizeof(STtuple));
	limit = mb->stop;
	old = mb->stmt;

@-
Prepare the list of tuple aliases using allocation of
variables on the stack.
@c
	for (i = 0; i < cnt; i++)
		STnewTuple(mb, vars[i], &top, tuples);
#ifdef DEBUG_MAL_SINGLETON
	stream_printf(GDKout, "START SINGLETON OPTIMIZER %d:", cnt);
	for (i = 0; i < top; i++)
		stream_printf(GDKout, "[%d,%d,%d] ", vars[i], tuples[i].hidx, tuples[i].tidx);
	stream_printf(GDKout, "\n");
	printFunction(GDKout, mb, LIST_MAL_ALL);
	stream_printf(GDKout, "START OPTIMIZER ");
#endif
	newMalBlkStmt(mb, mb->stop);

	for (i = 0; i < limit; i++) {
		p = old[i];
		/* decode operations */
		if (getName("bat", 3) == moduleId(p)) {
			if (getName("reverse", 7) == functionId(p) && (k = STalias(getArg(p, 1), top, tuples) >= 0)) {
				/* revert the tuple if it was already unpacked */
				if (tuples[k].packed == 0) {
					int h = tuples[k].hidx;

					tuples[k].hidx = tuples[k].vidx;
					tuples[k].tidx = h;
					h = tuples[k].htpe;
					tuples[k].htpe = tuples[k].ttpe;
					tuples[k].ttpe = h;
				}
			} else
				goto STrepack;
		} else if (getName("io", 2) == moduleId(p)) {
			if (getName("print", 5) == functionId(p) && p->argc == 3 && (k = STalias(getArg(p, 1), top, tuples)) >= 0) {
				if (tuples[k].packed == 0) {
					getArg(p, 1) = tuples[k].hidx;
					pushArgument(mb, p, tuples[k].tidx);
				} else
					goto STrepack;
			} else
				goto STrepack;
		} else if (getName("algebra", 7) == moduleId(p)) {
			if (getName("markH", 5) == functionId(p) && (k = STalias(getArg(p, 1), top, tuples)) >= 0) {
				STunpack(mb, k, tuples);
				setModuleId(p, NULL);
				setFunctionId(p, NULL);
				p->retc = p->argc = 2;
				pushVoid(mb, p);
				if (tuples[k].htpe == TYPE_void) {
					tuples[k].htpe = TYPE_oid;
					getVarType(mb, tuples[k].hidx) = TYPE_oid;
				}
				pushArgument(mb, p, tuples[k].hidx);
				k = STnewTuple(mb, getArg(p, 0), &top, tuples);
				tuples[k].packed = 0;
				p->argv[0] = tuples[k].hidx;
				p->argv[1] = tuples[k].tidx;
				p->token = ASSIGNsymbol;
				p->fcn = NULL;
				doAR++;
			} else if (getName("markT", 5) == functionId(p) && (k = STalias(getArg(p, 1), top, tuples)) >= 0) {
				STunpack(mb, k, tuples);
				setModuleId(p, NULL);
				setFunctionId(p, NULL);
				p->retc = p->argc = 2;
				pushArgument(mb, p, tuples[k].tidx);
				pushVoid(mb, p);
				k = STnewTuple(mb, getArg(p, 0), &top, tuples);
				tuples[k].packed = 0;
				p->argv[0] = tuples[k].hidx;
				p->argv[1] = tuples[k].tidx;
				p->token = ASSIGNsymbol;
				p->fcn = NULL;
				doAR++;
			} else if (getName("join", 4) == functionId(p)) {
				int k1 = STalias(getArg(p, 1), top, tuples);
				int k2 = STalias(getArg(p, 2), top, tuples);

				if (k1 >= 0 && k2 >= 0) {
					if (tuples[k2].htpe == TYPE_void && tuples[k1].htpe == TYPE_void) {
						STunpack(mb, k1, tuples);
						STunpack(mb, k2, tuples);
						printf("MERGE VOID JOIN \n");
						setModuleId(p, NULL);
						setFunctionId(p, NULL);
						STnewTuple(mb, getArg(p, 0), &top, tuples);
						p->argc = 0;
						pushReturn(mb, p, tuples[top - 1].hidx);
						pushReturn(mb, p, tuples[top - 1].tidx);
						p->retc = 2;
						pushArgument(mb, p, tuples[k1].hidx);
						pushArgument(mb, p, tuples[k2].tidx);
						p->token = ASSIGNsymbol;
						p->fcn = NULL;
					}
				} else if (k1 >= 0) {
					goto STrepack;
				} else if (k2 >= 0) {
					goto STrepack;
				} else
					goto STrepack;
				/* just push instruction */
			} else
/*
				getName("kunion",6)== functionId(p) ||
				getName("join",4)== functionId(p) ||
				getName("fetchjoin",9)== functionId(p) ||
				getName("mergejoin",9)== functionId(p) ||
				getName("indexjoin",9)== functionId(p) ||
				getName("hashjoin",8)== functionId(p) ||
				getName("cartesianproduct",16)== functionId(p) ||
				getName("union",5)== functionId(p) )
*/
			if (getName("count", 5) == functionId(p) && (k = STalias(getArg(p, 1), top, tuples)) >= 0) {
				STunpack(mb, k, tuples);
				/* count propagation */
				setModuleId(p, NULL);
				setFunctionId(p, NULL);
				p->argc = 1;
				p->token = ASSIGNsymbol;
				pushArgument(mb, p, newConstant(mb, TYPE_lng, GDKstrdup("1"), FALSE));
			} else {
			      STrepack:
				/* pack everything you need */
				for (j = 0; j < p->argc; j++)
					if ((k = STalias(getArg(p, j), top, tuples)) >= 0 && tuples[k].packed == 0)
						STpack(mb, k, tuples);
			}
		} else if (getName("datacell", 8) == moduleId(p)) {
			if (getName("bindReceptor", 12) && (k = STalias(getArg(p, 0), top, tuples)) >= 0) {
				setFunctionId(p, putName("bindReceptorTuple", 17));
				getArg(p, 0) = tuples[k].hidx;
				setArgument(mb, p, 1, tuples[k].tidx);
				p->retc++;
				tuples[k].packed = 0;
			} else if (getName("keep", 4) && p->argc >= 3 && (k = STalias(getArg(p, 3), top, tuples)) >= 0) {
				getArg(p, 3) = tuples[k].tidx;
			}
		} else {
			/* check for any target alias */
			for (j = 0; j < p->retc; j++)
				for (k = 0; k < top; k++)
					if (getArg(p, j) == tuples[k].vidx) {
						getArg(p, j) = tuples[k].hidx;
						setArgument(mb, p, j + 1, tuples[k].tidx);
						p->retc++;
					}
		}
		pushInstruction(mb, p);
	}
	if (doAR) {
#ifdef DEBUG_MAL_SINGLETON
		printf("MID STAGE doAR=%d\n", doAR);
		printFunction(GDKout, mb, LIST_MAL_ALL);
		for (i = 0; i < top; i++)
			stream_printf(GDKout, "[%d,%d:%s,%d:%s] ", tuples[i].vidx, tuples[i].hidx, getTypeName(tuples[i].htpe), tuples[i].tidx, getTypeName(tuples[i].ttpe));
		stream_printf(GDKout, "\n");
#endif
		ARoptimizer(mb, 0, 0);
	}
	GDKfree(old);

	optimizerCheck(mb, "mal.emptyset", 1, GDKusec() - clk);
#ifdef DEBUG_MAL_SINGLETON
	printf("FINAL STAGE SINGLETON errors=%d\n", mb->errors);
	printFunction(GDKout, mb, LIST_MAL_ALL);
#endif
	return MAL_SUCCEED;
}

str
SToptimizer(MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	int *vars;
	int cnt = 0, i, j;

	vars = (int *) alloca(mb->vtop);

	removeInstruction(mb, p);
	for (i = 1; i < mb->stop; i++) {
		p = getInstrPtr(mb, i);
		for (j = 0; j < p->retc; j++)
			if (fndProperty(getVarProperties(mb, getArg(p, j)), "singleton")) {
				vars[cnt++] = getArg(p, j);
			}
	}
	STevaluate(mb, cnt, vars);
	(void) stk;
	return MAL_SUCCEED;
}
