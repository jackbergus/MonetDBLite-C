@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2007 CWI.
@' All Rights Reserved.

@f opt_joinselect
@a S. Idreos
The combination of joins and selects is effective in the 
context of cracker optimizations.
@mal
pattern optimizer.joinselect():str
address OPTjoinselect;
pattern optimizer.joinselect(mod:str, fcn:str):str
address OPTjoinselect
comment "Replace select with join select";
@h
#ifndef _MAL_JOINSEL
#define _MAL_JOINSEL
#include "opt_prelude.h"
#include "opt_support.h"

/*#define DEBUG_OPT_JOINSEL    show partial result*/ 

#define match2(X,M,F) ( (X) && getFunctionId(X) && getFunctionId(X)==F && \
        getModuleId(X) && getModuleId(X)==M)
#define match3(X,M) (getModuleId(X) && getModuleId(X)==M) 

@c
#include "mal_config.h"
#include "opt_joinselect.h"
#include "mal_interpreter.h"	/* for showErrors() */
#include "mal_exception.h"

static int
OPTjoinselectImplementation(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	InstrPtr p, *old, qs, qi, qu, qd, r, d, k;
	int i, limit, attr;
	int start = -1;
	int *scr_s, *scr_i, *scr_u, *scr_d;
	int *ps, *pi, *pu, *pd;
	int scr_size = 10; 
	int xx = sizeof(int);
	int pivot = -1;

#ifdef DEBUG_OPT_JOINSEL
	stream_printf(GDKout, "Joinselect optimizer started\n");
#endif

	ps= scr_s = (int*) alloca(scr_size * sizeof(int));
	pi= scr_i = (int*) alloca(scr_size * sizeof(int));
	pu= scr_u = (int*) alloca(scr_size * sizeof(int));
	pd= scr_d = (int*) alloca(scr_size * sizeof(int));

	(void) stk;
	(void) pci;
	setLifespan(mb);
	limit = mb->stop;
	old = mb->stmt;

	newMalBlkStmt(mb, mb->stop);
	
	/* The first loop identifies all the select calls and keeps a reference 
		to the operations.
	  Also the end of the selection part is found where the pivot is made.	 
	  All operations before the first select call are added to the new plan	*/
	for (i = 0; i < limit; i++) {
		p = old[i];

		if (match2(p, algebraRef, uselectRef)){
			if (start == -1) 
				start = i;

			if(fndArgProperty(mb,p,1,"stable")){
				*(int*)ps = i;
				ps += xx;
			}
			if(fndArgProperty(mb,p,1,"insertions")){
				*(int*)pi = i;
				pi += xx;
			}
			if(fndArgProperty(mb,p,1,"updates")){
				*(int*)pu = i;
				pu += xx;
			}
		}
		
		if (match2(p, batRef, reverseRef)){
			if(fndArgProperty(mb,p,1,"deletes")){
					*(int*)pd = i;
					pd += xx;
			}
		}
	
		if (match2(p, sqlRef, bindRef)){
			switch( getVar(mb,getArg(p,4))->value.val.ival ){
			case 0:
				setArgProperty(mb,p,0,"stable","=", TYPE_int, &i);
				break;
			case 1:
				setArgProperty(mb,p,0,"insertions","=", TYPE_int, &i);
				break;
			case 3:
				setArgProperty(mb,p,0,"updates","=", TYPE_int, &i);
			}
		}
		if (match2(p, sqlRef, binddbatRef))
			setArgProperty(mb,p,0,"deletes","=", TYPE_int, &i);

		if (match2(p, batRef, setWriteModeRef)){ 
				if(fndArgProperty(mb,p,1,"stable"))
						setArgProperty(mb,p,0,"stable","=", TYPE_int, &i);
				if(fndArgProperty(mb,p,1,"insertions"))
						setArgProperty(mb,p,0,"insertions","=", TYPE_int, &i);
				if(fndArgProperty(mb,p,1,"updates"))
						setArgProperty(mb,p,0,"updates","=", TYPE_int, &i);
			}

		if (match2(p, algebraRef, markTRef)){
			pivot = i;
			break;
		}
		
		if (start == -1)
			pushInstruction(mb, p);
	}

	/*Nothing to optimize*/
	if (start== -1) goto end;

	/*if not more than one attributes in the where clause then keep the same plan*/
	attr = (ps -scr_s)/xx;
	if (attr <= 1){
		for (i = start; i < limit; i++) 
			pushInstruction(mb, old[i]);
		goto end;
	}

	/*The following loop transfers all calc operations in the beggining of the selections part*/
	for (i = start; i < pivot; i++) {
		p = old[i];
		if (match3(p, calcRef))
			pushInstruction(mb, p);
	}	

	/*join select on the stable bats */
	ps = scr_s;
	qs = old[*(int*)ps];
	pushInstruction(mb, qs);
	i = 1;		
	while(i<attr){
		p=qs;
		ps+=xx; 
		qs = old[*(int*)ps];
		setModuleId(qs, putName("crackers", 8));
       		setFunctionId(qs, putName("joinuselect", 11));
       		pushArgument(mb, qs, getArg(p, 0));
		pushInstruction(mb, qs);
		i++;	
	}

	/*join select on the insertions bats */
	pi = scr_i;
	qi = old[*(int*)pi];
	pushInstruction(mb, qi);
	i = 1;		
	while(i<attr){
		p=qi;
		pi+=xx; 
		qi = old[*(int*)pi];
		setModuleId(qi, putName("crackers", 8));
       		setFunctionId(qi, putName("joinuselect", 11));
       		pushArgument(mb, qi, getArg(p, 0));
		pushInstruction(mb, qi);
		i++;	
	}

	/*union the result of the join select on the stable bats with the join select on the insertions bat*/
	r = newInstruction(mb,ASSIGNsymbol);
	getArg(r,0) = newTmpVariable(mb, newBatType(TYPE_void, TYPE_void));
	setModuleId(r, putName("algebra", 7));
        setFunctionId(r, putName("kunion", 6));        
        pushArgument(mb, r, getArg(qs, 0));
        pushArgument(mb, r, getArg(qi, 0));
	pushInstruction(mb, r);


/*	d = newInstruction(mb,ASSIGNsymbol);
        getArg(d,0) = newTmpVariable(mb, newBatType(TYPE_oid, TYPE_void));
        setModuleId(d, putName("bat", 3));
        setFunctionId(d, putName("reverse", 7));
        pushArgument(mb, d, getArg(r, 0));
        pushInstruction(mb, d);
	r=d;
*/

	/*remove updated buns*/
	i = 1;		
	pu = scr_u;
	while(i<=attr){
		d = old[*(int*)pu];
		k = newInstruction(mb,ASSIGNsymbol);
		getArg(k,0) = newTmpVariable(mb, newBatType(TYPE_oid, TYPE_void));
		setModuleId(k, putName("algebra", 7));
       		setFunctionId(k, putName("kdifference", 11));
       		pushArgument(mb, k, getArg(r, 0));
       		pushArgument(mb, k, getArg(d, 1));
		pushInstruction(mb, k);
		pu+=xx;
		r = k; 
		i++;	
	}

	/*join select on the updated bats*/
	pu = scr_u;
	qu = old[*(int*)pu];
	pushInstruction(mb, qu);
	i = 1;		
	while(i<attr){
		p=qu;
		pu+=xx; 
		qu = old[*(int*)pu];
		setModuleId(qu, putName("crackers", 8));
       		setFunctionId(qu, putName("joinuselect", 11));
       		pushArgument(mb, qu, getArg(p, 0));
		pushInstruction(mb, qu);
		i++;	
	}

	/*union with the updates*/
	p = newInstruction(mb,ASSIGNsymbol);
	getArg(p,0) = newTmpVariable(mb, getArgType(mb,r,0));
	setModuleId(p, putName("algebra", 7));
        setFunctionId(p, putName("kunion", 6));        
        pushArgument(mb, p, getArg(r, 0));
        pushArgument(mb, p, getArg(qu, 0));
	pushInstruction(mb, p);

	/*remove any bun that is deleted*/
	pd = scr_d;
	i = 1;		
	while(i<=attr){
		qd = old[*(int*)pd];
		pushInstruction(mb, qd); /*this is the reverse operation*/
		k = newInstruction(mb,ASSIGNsymbol);
		getArg(k,0) = newTmpVariable(mb, newBatType(TYPE_oid, TYPE_void));
		setModuleId(k, putName("algebra", 7));
       		setFunctionId(k, putName("kdifference", 11));
       		pushArgument(mb, k, getArg(p, 0));
       		pushArgument(mb, k, getArg(qd, 0));
		pushInstruction(mb, k);
		pd += xx;
		p = k; 
		i++;	
	}

	/*now just append the remaining instructions. Only set the pivot to the correct variable*/	
	r = old[pivot];
	getArg(r,1) = getArg(p,0);
	pushInstruction(mb, r) ;

	for (i = pivot+1; i < limit; i++) {
                p = old[i];
                pushInstruction(mb, p);
        }       

end:

	GDKfree(old);
#ifdef DEBUG_OPT_JOINSEL
	printFunction(GDKout, mb, LIST_MAL_ALL);
#endif
	return 1;
}
@include optimizerWrapper.mx
@h
@:exportOptimizer(joinselect)@
#endif
@c
@:wrapOptimizer(joinselect,OPT_CHECK_ALL)@
@}
