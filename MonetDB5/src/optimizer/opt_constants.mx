@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
@' Copyright August 2008-2009 MonetDB B.V.
@' All Rights Reserved.

@f opt_constants
@- Constant Duplicate Removal
The compilers may generate an abundance of constants on
the stack. This simple optimizer re-organizes the variable table
such that all constants are moved to the beginning of the
symbol table, right after the signature variables.
This makes it easier to search for duplicates and alias
their variables.
Furthermore, it makes it easier to find common terms.

@{
@mal
pattern optimizer.constants():str
address OPTconstants;
pattern optimizer.constants(mod:str, fcn:str):str
address OPTconstants
comment "Duplicate constant removal optimizer";
@-
@h
#ifndef _OPT_CONSTANTS_
#define _OPT_CONSTANTS_
#include "opt_prelude.h"
#include "opt_support.h"
#include "mal_exception.h"

/* #define DEBUG_OPT_CONSTANTS       show partial result */

@-
We have to keep an alias table to reorganize the program
after the variable stack has changed.
@c
#include "mal_config.h"
#include "opt_constants.h"

static int
OPTconstantsImplementation(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	int i,k=1, n=0, fnd=0, actions=0;
	int *alias, *index;
	VarPtr x,y, *cst;

	alias= (int*) alloca(sizeof(int) * mb->vtop);
	cst= (VarPtr*) alloca(sizeof(VarPtr) * mb->vtop);
	index= (int*)alloca(sizeof(int) * mb->vtop);

	(void) stk;
	(void) cntxt;

	for (i=0; i< getInstrPtr(mb,0)->argc; i++)
		alias[i]=i;
	for (; i< mb->vtop; i++)
		if ( isVarConstant(mb,i) ){
			x= getVar(mb,i); fnd = 0;
			for( k= n-1; k>=0; k--){
				y= cst[k];
				if ( x->type == y->type &&
					ATOMcmp(x->type, VALget(&x->value), VALget(&y->value)) == 0){
#ifdef DEBUG_OPT_CONSTANTS 
	stream_printf(cntxt->fdout,"matching elements %d %d\n", i,k);
#endif
					/* re-use a constant */
					alias[i]= index[k];
					fnd=1;
					break;
				}
			}
			if ( fnd == 0){
#ifdef DEBUG_OPT_CONSTANTS 
				stream_printf(cntxt->fdout,"swith elements %d %d\n", i,n);
#else
				(void) cntxt;
#endif
				cst[n]= x;
				index[n]= i;
				alias[i]= index[n];
				n++;
			} 
		} else
			alias[i]=i;

#ifdef DEBUG_OPT_CONSTANTS 
	for( i=0;i < mb->vtop;i++)
	stream_printf(cntxt->fdout,"map %d %d\n",i, alias[i]);
#endif

	for (i = 0; i < mb->stop; i++){
		p= getInstrPtr(mb,i);
		for (k=0; k < p->argc; k++)
			getArg(p,k) = alias[getArg(p,k)];
	}
	return actions;
}
@include optimizerWrapper.mx
@h
@:exportOptimizer(constants)@
#endif
@c
#include "opt_statistics.h"
@:wrapOptimizer(constants,OPT_CHECK_ALL)@
@}
