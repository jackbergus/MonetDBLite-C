@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2006 CWI.
@' All Rights Reserved.

@f opt_joinPath
@-
@node Join Path , , , Toolkit
@- Join Path Optimization
The routine @code{optimizer.joinPath()}
walks through the program looking for join operations
and cascades them into multiple join paths.
@verbatim
	a:= bat.new(:void,:oid);
	b:= bat.new(:oid,:oid);
	c:= bat.new(:oid,:str);
	j1:= algebra.join(a,b);
	j2:= algebra.join(j1,c);
	j3:= algebra.join(b,b);
	j4:= algebra.join(b,j3);
@end verbatim
The result includes the expanded join expressions.
The deadcode optimizer should take care of superflous
paths.
@verbatim
	a:= bat.new(:void,:oid);
	j1:= algebra.join(a,b);
	j2:= algebra.joinPath(a,b,c);
	j3:= algebra.join(b,b);
	j4:= algebra.joinPath(b,b,b);
@end verbatim
@{
@mal
pattern optimizer.joinPath():str
address OPTjoinPath;
pattern optimizer.joinPath(mod:str, fcn:str):str
address OPTjoinPath
comment "Join path constructor";
pattern algebra.joinPath(l:bat[:any,:any]...):bat[:any,:any]
address ALGjoinPath
comment "internal routine to handle join paths.
	The type analysis is rather tricky.";
@h
#ifndef _OPT_JOINPATH_
#define _OPT_JOINPATH_
#include "opt_prelude.h"
#include "opt_support.h"
#include "mal_interpreter.h"

/* #define DEBUG_OPT_JOINPATH */
#endif
@-
@c
#include "opt_joinPath.h"

static int
OPTjoinPathImplementation(MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	int i,j,k, actions=0;
	int *pc, *used;
	str joinPathRef = putName("joinPath",8);
	InstrPtr q,r;

	(void) stk;
	pc= (int*) alloca(sizeof(int)* mb->vtop); /* to find last assignment */
	memset((char*) pc, 0, sizeof(int)* mb->vtop);
	used= (int*) alloca(sizeof(int)* mb->vtop); /* to find last assignment */
	memset((char*) used, 0, sizeof(int)* mb->vtop);

	for (i = 1; i < mb->stop; i++){
		p= getInstrPtr(mb,i);
		for(j=0; j< p->retc; j++)
			pc[getArg(p,j)]= i;
		if( getModuleId(p)== algebraRef && getFunctionId(p)== joinRef ){
@-
Try to expand each of its argument list
@c
			q= copyInstruction(p);
			q->argc=1;
			for(j=p->retc; j<p->argc; j++)
			if( pc[getArg(p,j)] && used[getArg(p,j)]==0 ){
				r= getInstrPtr(mb,pc[getArg(p,j)]);
#ifdef DEBUG_OPT_JOINPATH 
				stream_printf(GDKout,"expand with \n");
				printInstruction(GDKout,mb, r, LIST_MAL_ALL);
#endif
				if(  getModuleId(r)== algebraRef && 
					( getFunctionId(r)== joinRef  || getFunctionId(r)== joinPathRef) ){
					for(k= r->retc; k<r->argc; k++)
						pushArgument(mb,q,getArg(r,k));
				} else
						pushArgument(mb,q,getArg(p,j));
			}
#ifdef DEBUG_OPT_JOINPATH 
			stream_printf(GDKout,"new joinPath instruction\n");
			printInstruction(GDKout,mb, q, LIST_MAL_ALL);
#endif
			if(q->argc<= p->argc){
				/* no change */
				freeInstruction(q);
			} else {
				setFunctionId(q,joinPathRef);
				getInstrPtr(mb,i)=q;
				freeInstruction(p);
				p=q;
				actions++;
			}
		}
		/* remember its latest use */
		for(j=p->retc; j<p->argc; j++)
			used[getArg(p,j)]= i;
	}
	return actions;
}
@include optimizerWrapper.mx
@h
@:exportOptimizer(joinPath)@
opt_export str ALGjoinPath(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
@c
@:wrapOptimizer(joinPath,OPT_CHECK_ALL)@
@-
The join path optimizer takes a join sequence and
attempts to minimize the intermediate result.
The choice depends on a good estimate of intermediate
results.
For the time being, we use a simplistic model, based
on the assumption that most joins are foreign key joins anyway.
@c
size_t
ALGjoinEstimate(BAT *l, BAT *r)
{
	size_t lc, rc;

	lc = BATcount(l);
	rc = BATcount(r);
	if( l->ttype== TYPE_void )
		return rc;
	if( r->htype== TYPE_void )
		return lc;
	return MIN(lc, rc);
}
@-
The join path type analysis should also be done at run time,
because the expressive power of MAL is insufficient to
enforce a proper join type list.
@c
str
ALGjoinPath(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	BAT *joins[MAXARG], *b = 0;
	size_t estimate, e;
	int top, i, j, ret = 0, *bid;

	(void) mb;
	(void) ret;
	top = 0;
	for (i = pci->retc; i < pci->argc; i++) {
		bid = (int *) getArgReference(stk, pci, i);
#ifdef OPTIMIZER_DEBUG
		printf("bid %d\n", *bid);
#endif
		if ((b = BATdescriptor(*bid)) == NULL) {
			for( --top; top>=0; top--)
				BBPreleaseref(joins[top]->batCacheid);
			return throwMessage("algebra.joinPath", "Cannot access descriptor");
		}

		joins[top++] = b;
	}
	/* solve the join by pairing the smallest first */
	while (top > 2) {
		j = 0;
		estimate = ALGjoinEstimate(joins[0],joins[1]);
		for (i = 1; i < top - 1; i++) {
			e = ALGjoinEstimate(joins[i], joins[i + 1]);
			if (e < estimate) {
				estimate = e;
				j = i;
			}
		}
#ifdef OPTIMIZER_DEBUG
		printf("join %d and %d\n", joins[j]->batCacheid, joins[j + 1]->batCacheid);
#endif
		b = BATjoin(joins[j], joins[j + 1], estimate);
		BBPreleaseref(joins[j]->batCacheid);
		BBPreleaseref(joins[j + 1]->batCacheid);
		joins[j] = b;
		for (i = j + 1; i < top; i++)
			joins[i] = joins[i + 1];
		top--;
	}
#ifdef OPTIMIZER_DEBUG
	printf("join %d and %d\n", joins[0]->batCacheid, joins[1]->batCacheid);
#endif
	estimate = BATcount(joins[0]);
	b = BATjoin(joins[0], joins[1], estimate);
	BBPreleaseref(joins[0]->batCacheid);
	BBPreleaseref(joins[1]->batCacheid);

	BBPkeepref(b->batCacheid);
	*(int *) getArgReference(stk, pci, 0) = b->batCacheid;
	return NULL;
}
@}
