@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
@' Copyright August 2008-2010 MonetDB B.V.
@' All Rights Reserved.

@f opt_joinpath
@- Join Paths
The routine @sc{optimizer.joinPath()}
walks through the program looking for join operations
and cascades them into multiple join paths.
To illustrate, consider
@verbatim
	a:= bat.new(:oid,:oid);
	b:= bat.new(:oid,:oid);
	c:= bat.new(:oid,:str);
	j1:= algebra.join(a,b);
	j2:= algebra.join(j1,c);
	j3:= algebra.join(b,b);
	j4:= algebra.join(b,j3);
@end verbatim
The optimizer will first replace all arguments
by their join sequence. The underlying instructions
are left behind for the deadcode optimizer to be
removed.
@verbatim
	a:= bat.new(:oid,:oid);
	j1:= algebra.join(a,b);
	j2:= algebra.joinPath(a,b,c);
	j3:= algebra.join(b,b);
	j4:= algebra.joinPath(b,b,b);
@end verbatim
The same operation is applied to sequences of leftjoin
operations.

In principle, the joinpaths may contain common
subpaths, whose materialization would improve performance.
The SQL front-end produces often produces
snippets of the following structure
@verbatim
    t1:= algebra.join(b,c);
    z1:= algebra.join(a,t1);
	...
    t2:= algebra.join(b,d);
    z2:= algebra.join(a,t2);
@end verbatim
The joinpath would merge them into
@verbatim
    z1:= algebra.joinPath(a,b,c);
	...
    z2:= algebra.joinPath(a,b,d);
@end verbatim
which are handle by a heuristic looking
at the first two argments and re-uses
a materialized join.
@verbatim
    _13:= algebra.join(a,b);
    z1:= algebra.join(_13,c);
	...
    z2:= algebra.join(_13,d);
@end verbatim
An alternative is to make recognition
of the common re-useable paths an
integral part of the joinPath body.

@verbatim
    x3:= algebra.join(a,b);
	r3:= bat.reverse(x3);
	j1:= join(c,r3);
@end verbatim
@verbatim
	rb:= bat.reverse(b);
	ra:= bat.reverse(a);
	j1:= algebra.joinpath(c,rb,ra);
@end verbatim

As a final step in the speed up of the joinpath
we consider clustering large operands if that
is expected to improve IO behavior.
@{
@mal
pattern optimizer.joinPath():str
address OPTjoinPath;
pattern optimizer.joinPath(mod:str, fcn:str):str
address OPTjoinPath
comment "Join path constructor";

pattern algebra.joinPath(l:bat[:any,:any]...):bat[:any,:any]
address ALGjoinPath
comment "internal routine to handle join paths.
	The type analysis is rather tricky.";

pattern algebra.leftjoinPath(l:bat[:any,:any]...):bat[:any,:any]
address ALGjoinPath
comment "internal routine to handle join paths.
	The type analysis is rather tricky.";

pattern algebra.semijoinPath(l:bat[:any,:any]...):bat[:any,:any]
address ALGjoinPath
comment "internal routine to handle join paths.
	The type analysis is rather tricky.";
@h
#ifndef _OPT_JOINPATH_
#define _OPT_JOINPATH_
#include "opt_prelude.h"
#include "opt_support.h"
#include "mal_interpreter.h"

/* #define DEBUG_OPT_JOINPATH  */
@-
Post-optimization. After the join path has been constructed
we factor out common header subpaths. This heuristic is to
remove any pair which is used more then once.
The heuristics is sufficient for the code produced by SQL frontend.
The alternative is to search for all possible subpaths
and materialize them.
@c
#include "mal_config.h"
#include "opt_joinpath.h"
#include "cluster.h"

static int
OPTjoinPathPrefix(Client cntxt, MalBlkPtr mb)
{
	int i,j,k,cnt,top=0;
	str joinPathRef = putName("joinPath",8);
	str leftjoinPathRef = putName("leftjoinPath",12);
	str semijoinPathRef = putName("semijoinPath",12);
	InstrPtr q,p,*old, *paths;
	int limit, *used;

	(void) cntxt;
	paths = (InstrPtr *) GDKmalloc(sizeof(InstrPtr) * mb->stop);
	if ( paths== NULL)
		return 0;

	limit= mb->stop;
	for(i=0; i< limit; i++)
	if ( getFunctionId(mb->stmt[i])== joinPathRef || getFunctionId(mb->stmt[i])== leftjoinPathRef || getFunctionId(mb->stmt[i]) == semijoinRef)
		paths[top++] = mb->stmt[i];

	/* let's trim the paths first , because they are incrementally added */
	k=1;
	for (i=1;i<top; ){
		if (paths[i]->argv[1] == paths[k-1]->argv[1]){
			i++;
			continue;
		}
		if (paths[i]->argv[2] == paths[k-1]->argv[1]){
			i++;
			continue;
		}
		paths[k++]= paths[i++];
	}
	top=k;

	/* determine the joinpaths whose header should be replaced, because
	   it occurs multiple times */
	for( k=i=0; i<top; i++){
		cnt =0;
		for ( j=i+1; j<top; j++)
		if ( getArg(paths[i], 1) == getArg(paths[j],1) &&
			getArg(paths[i], 2) == getArg(paths[j],2) )
			cnt++;
		if ( cnt >= 1)
			paths[k++] = paths[i];
	}
	top = k;
	used = (int*) GDKzalloc(sizeof(int) * top);
	if ( used == NULL){
		GDKfree(paths);
		return 0;
	}

#ifdef DEBUG_OPT_JOINPATH 
	stream_printf(cntxt->fdout,"start of header compression\n");
	for( i =0; i<top; i++)
		printInstruction(cntxt->fdout,mb, 0, paths[i],0);
	printFunction(cntxt->fdout,mb,0,0);
#endif

	/* now replace the joinpaths that have a common head */
	old= mb->stmt;
	limit= mb->stop;
	if ( newMalBlkStmt(mb,mb->ssize) < 0){
		GDKfree(paths);
		return 0;
	}

	for (i = 0; i<limit; i++){
		p= old[i];
		if( getModuleId(p)== algebraRef && (getFunctionId(p)== joinPathRef || getFunctionId(p)== leftjoinPathRef || getFunctionId(p) == semijoinPathRef)){
			for(j=0;j<top;j++)
			if ( getArg(p, 1) == getArg(paths[j],1) &&
				getArg(p, 2) == getArg(paths[j],2) ){
				if (used[j] == 0){
					/* reform joinpath */
					q= copyInstruction(paths[j]);
					setFunctionId(q,joinRef);
					q->argc=3;
					used[j] = getArg(q,0) = newTmpVariable(mb, TYPE_any);
					pushInstruction(mb,q);
				}
				/* replace the header by the factored out pair */
				getArg(p,1)= used[j];
				delArgument(p,2);
				if (p->argc == 3)
					setFunctionId(p, joinRef);
				break;
			}
		}
		pushInstruction(mb,p);
	}
	
#ifdef DEBUG_OPT_JOINPATH 
	printFunction(cntxt->fdout,mb,0,0);
#endif
	GDKfree(old);
	GDKfree(paths);
	GDKfree(used);
	return 0;
}
@-
@c
static int
OPTjoinPathImplementation(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	int i,j,k, actions=0;
	int *pc;
	str joinPathRef = putName("joinPath",8);
	str leftjoinPathRef = putName("leftjoinPath",12);
	str semijoinPathRef = putName("semijoinPath",12);
	InstrPtr q,r;
	InstrPtr *old;
	int limit,slimit;

	(void) cntxt;
	(void) stk;
	if (varGetProp(mb, getArg(mb->stmt[0], 0), inlineProp) != NULL)
		return 0;

	old= mb->stmt;
	limit= mb->stop;
	slimit= mb->ssize;
	newMalBlkStmt(mb,mb->ssize);

	/* beware, new variables and instructions are introduced */
	pc= (int*) GDKzalloc(sizeof(int)* mb->vtop * 2); /* to find last assignment */
	if (pc == NULL)
		return 0;
	for (i = 0; i<limit; i++){
		p= old[i];
		if( getModuleId(p)== algebraRef && (getFunctionId(p)== joinRef || getFunctionId(p) == leftjoinRef || getFunctionId(p) == semijoinRef)){
@-
Try to expand its argument list with what we have found so far.
This creates a series of join paths, many of which will be removed during deadcode elimination.
@c
			q= copyInstruction(p);
			q->argc=1;
			for(j=p->retc; j<p->argc; j++){
				r= getInstrPtr(mb,pc[getArg(p,j)]);
				assert(r);
#ifdef DEBUG_OPT_JOINPATH 
				stream_printf(cntxt->fdout,"expand list \n");
				printInstruction(cntxt->fdout,mb, 0, p, LIST_MAL_ALL);
				printInstruction(cntxt->fdout,mb, 0, q, LIST_MAL_ALL);
#endif
				if ( getFunctionId(p) == joinRef){
					if( r &&  getModuleId(r)== algebraRef && 
						( getFunctionId(r)== joinRef  || getFunctionId(r)== joinPathRef) ){
						for(k= r->retc; k<r->argc; k++) 
							q = pushArgument(mb,q,getArg(r,k));
					} else 
						q = pushArgument(mb,q,getArg(p,j));
				} else 
				if ( getFunctionId(p) == leftjoinRef){
					if( r &&  getModuleId(r)== algebraRef && 
						( getFunctionId(r)== leftjoinRef  || getFunctionId(r)== leftjoinPathRef) ){
						for(k= r->retc; k<r->argc; k++) 
							q = pushArgument(mb,q,getArg(r,k));
					} else 
						q = pushArgument(mb,q,getArg(p,j));
				} else
				if ( getFunctionId(p) == semijoinRef){
					if( r &&  getModuleId(r)== algebraRef && 
						( getFunctionId(r)== semijoinRef  || getFunctionId(r)== semijoinPathRef) ){
						for(k= r->retc; k<r->argc; k++) 
							q = pushArgument(mb,q,getArg(r,k));
					} else 
						q = pushArgument(mb,q,getArg(p,j));
				}
			}
#ifdef DEBUG_OPT_JOINPATH 
			stream_printf(cntxt->fdout,"new [left]joinPath instruction\n");
			printInstruction(cntxt->fdout,mb, 0, q, LIST_MAL_ALL);
#endif
			if(q->argc<= p->argc){
				/* no change */
				freeInstruction(q);
				goto wrapup;
			}
@-
Final type check.
@c
			for(j=1; j<q->argc-1; j++)
			if( getTailType(getArgType(mb,q,j)) != getHeadType(getArgType(mb,q,j+1)) &&
			!( getTailType(getArgType(mb,q,j))== TYPE_oid  &&
				getHeadType(getArgType(mb,q,j))== TYPE_void) &&
			!( getTailType(getArgType(mb,q,j))== TYPE_void &&
				getHeadType(getArgType(mb,q,j))== TYPE_oid)
			 ){
				freeInstruction(q);
				goto wrapup;
			}

			if ( q->argc > 3  &&  getFunctionId(q) == joinRef)
				setFunctionId(q,joinPathRef);
			else
			if ( q->argc > 3  &&  getFunctionId(q) == leftjoinRef)
				setFunctionId(q,leftjoinPathRef);
			else
			if ( q->argc > 2  &&  getFunctionId(q) == semijoinRef)
				setFunctionId(q,semijoinPathRef);
			p= q;
			actions++;
		} 
	wrapup:
		pushInstruction(mb,p);
		for(j=0; j< p->retc; j++)
			pc[getArg(p,j)]= mb->stop-1;
	}
	for(; i<slimit; i++)
	if(old[i])
		freeInstruction(old[i]);
	/* perform the second phase */
	if (actions )
		OPTjoinPathPrefix(cntxt, mb);
	GDKfree(old);
	GDKfree(pc);
	OPTDEBUG
	if ( actions)
		stream_printf(cntxt->fdout,"#opt_joinpath: %d statements glued\n",actions);
	return actions;
}
@include optimizerWrapper.mx
@h
@:exportOptimizer(joinPath)@
#endif
opt_export str ALGjoinPath(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
@c
#include "opt_statistics.h"
@:wrapOptimizer(joinPath,OPT_CHECK_ALL)@
@-
The join path optimizer takes a join sequence and
attempts to minimize the intermediate result.
The choice depends on a good estimate of intermediate
results using properties.
For the time being, we use a simplistic model, based
on the assumption that most joins are foreign key joins anyway.

We use a sample based approach for sizeable  tables.
The model is derived from the select statement. However, we did not succeed.
The code is now commented for future improvement.

Final conclusion from this exercise is:
The difference between the join input size and the join output size is not 
the correct (or unique) metric which should be used to decide which order 
should be used in the joinPath. 
A SMALL_OPERAND is preferrable set to those cases where the table
fits in the cache. This depends on the cache size and operand type.
For the time being we limit ourself to a default of 1Kelements
@c
/*#define SAMPLE_THRESHOLD_lOG 17*/
#define SMALL_OPERAND	1024
#define CLUSTER_THRESHOLD	(1<<21) /* 2M */
BUN
ALGjoinCost(Client cntxt, BAT *l, BAT *r, int flag)
{
	BUN lc, rc;
#if 0
	BUN lsize,rsize;
	BAT *lsample, *rsample, *j; 
#endif

	lc = BATcount(l);
	rc = BATcount(r);
#if 0	
	/* The sampling method */
	if(flag < 2 && ( lc > 100000 || rc > 100000)){
		lsize= MIN(lc/100, (1<<SAMPLE_THRESHOLD_lOG)/3);
		lsample= BATsample(l,lsize);
		BBPreclaim(lsample);
		rsize= MIN(rc/100, (1<<SAMPLE_THRESHOLD_lOG)/3);
		rsample= BATsample(r,rsize);
		BBPreclaim(rsample);
		j= BATjoin(l,r, MAX(lsize,rsize));
		lsize= BATcount(j);
		BBPreclaim(j);
		return lsize;
	}
#endif
	/* dump properties to align decisions with the kernel */
	OPTDEBUG{
		stream_printf(cntxt->fdout,"#orderedvoidfetchjoin ? %d\n",
			BAThvoid(l) && !BATtvoid(l) && !BATtdense(l) );
	}
	/* estimate the maximal, because the determines work */
	/* avoid materialization of views to early */
    /* merge joins are by far the cheapest */
	if ( flag == 0 ){
		/* leftjoin issues */
		if (l->tsorted || r->hsorted )
			return MIN(lc,rc);
		if (l->tdense )
			return lc;
	}
	if ( isVIEW(l) && lc > rc )
		return lc;
	if( l->tsorted || r->hsorted)
		return MIN(lc,rc);
	/* foreign key joins are common */
	if( l->ttype== TYPE_oid  || r->htype == TYPE_oid || r->htype== TYPE_void)
		return MAX(lc,rc);
	if (l->tkey || r->hkey)
		return MAX(lc,rc);
	/* if either operand is very small, we should use that one */
	if (rc < SMALL_OPERAND )
		return rc;
	if (lc < SMALL_OPERAND )
		return lc;
	if (lc * rc >= BUN_MAX)
		return BUN_MAX;
	return lc * rc;
}
@-
The join path type analysis should also be done at run time,
because the expressive power of MAL is insufficient to
enforce a proper join type list.
The current  costmodel is rather limited. It takes as default
the order presented and catches a few more cases that do not
lead to materialization of large views. This solved the earlier
problem noticable on TPC-H that join order was producing slower
results. Now, on TPCH-H, all queries run equal or better.
about 12 out of 84 joinpaths are improved with more then 10%.
(affecting Q2, Q5, Q7, Q8,Q11,Q13)
@h
opt_export BAT * ALGjoinPathBody(Client cntxt, int top, BAT **joins, int flag);
@c
BAT *
ALGjoinPathBody(Client cntxt, int top, BAT **joins, int flag)
{
	BAT *b;
	BUN estimate, e;
	int i, j, k;
	int *postpone= (int*) GDKzalloc(sizeof(int) *top);
	int postponed=0;

	/* solve the join by pairing the smallest first */
	while (top > 1) {
		j = 0;
		estimate = ALGjoinCost(cntxt,joins[0],joins[1],flag);
#ifdef DEBUG_OPT_JOINPATH
		stream_printf(cntxt->fdout,"#joinPath estimate join(%d,%d) %d\n", joins[0]->batCacheid, 
			joins[1]->batCacheid,(int)estimate);
#else
	(void) cntxt;
#endif
		for (i = 1; i < top - 1; i++) {
			e = ALGjoinCost(cntxt,joins[i], joins[i + 1],flag);
#ifdef DEBUG_OPT_JOINPATH
		stream_printf(cntxt->fdout,"#joinPath estimate join(%d,%d) %d\n", joins[i]->batCacheid, 
			joins[i+1]->batCacheid,(int)e);
#endif
			if (e < estimate &&  ( !(postpone[i] && postpone[i+1]) || postponed<top)) {
				estimate = e;
				j = i;
			}
		}
@-
BEWARE. you may not use a size estimation, because it
may fire a BATproperty check in a few cases.
In case a join fails, we may try another order first before 
abandoning the task.
@c
		switch(flag){
		case 0:
			b = BATleftjoin(joins[j], joins[j + 1], BUN_NONE);
			break;
		case 1:
			b = BATjoin(joins[j], joins[j + 1], BUN_NONE);
			break;
		case 2:
			b = BATsemijoin(joins[j], joins[j + 1]);
		}
		if (b==NULL){
			postpone[j] = TRUE;
			postpone[j+1] = TRUE;
			postponed = 0;
			for( k=0; k<top; k++)
				postponed += postpone[k]== TRUE;
			if ( postponed == top){
				GDKfree(postpone);
				return NULL;
			}
			/* clear the GDKerrors and retry */
			if( cntxt->errbuf )
				cntxt->errbuf[0]=0;
			continue;
		} else {
			/* reset the postponed joins */
			for( k=0; k<top; k++)
				postpone[k]=FALSE;
			postponed = 0;
		}
#ifdef DEBUG_OPT_JOINPATH
		stream_printf(cntxt->fdout, "#joinPath %d:= join(%d,%d)\n", 
			b->batCacheid, joins[j]->batCacheid, joins[j + 1]->batCacheid);
#endif
		BBPdecref(joins[j]->batCacheid, FALSE);
		BBPdecref(joins[j+1]->batCacheid, FALSE);
        	if (!(b->batDirty&2)) b = BATsetaccess(b, BAT_READ);
		joins[j] = b;
		top--;
		for (i = j + 1; i < top; i++)
			joins[i] = joins[i + 1];
	}
	GDKfree(postpone);
	b = joins[0];
	if (b && !(b->batDirty&2)) b = BATsetaccess(b, BAT_READ);
	return b;
}

str
ALGjoinPath(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	int i,*bid,top=0;
	int *r = (int*) getArgReference(stk, pci, 0);
	BAT *b, **joins = (BAT**)GDKmalloc(pci->argc*sizeof(BAT*)); 
	str joinPathRef = putName("joinPath",8);
	str leftjoinPathRef = putName("leftjoinPath",12);

	if ( joins == NULL)
		throw(MAL, "algebra.joinPath", MAL_MALLOC_FAIL);
	(void)mb;
	for (i = pci->retc; i < pci->argc; i++) {
		bid = (int *) getArgReference(stk, pci, i);
		if ((b = BATdescriptor(*bid)) == NULL) {
			for( --top; top>=0; top--)
				BBPreleaseref(joins[top]->batCacheid);
			GDKfree(joins);
			throw(MAL, "algebra.joinPath", INTERNAL_BAT_ACCESS);
		}
		joins[top++] = b;
	}
	b= ALGjoinPathBody(cntxt,top,joins, (getFunctionId(pci)== joinPathRef?1: (getFunctionId(pci) == leftjoinPathRef? 0:2)));
	GDKfree(joins);
	if ( b)
		BBPkeepref( *r = b->batCacheid);
	else
		throw(MAL, "algebra.joinPath", INTERNAL_OBJ_CREATE);
	return MAL_SUCCEED;
}
@}
