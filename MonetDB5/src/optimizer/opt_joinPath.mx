@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2008 CWI.
@' All Rights Reserved.

@f opt_joinpath
@- Join Paths
The routine @sc{optimizer.joinPath()}
walks through the program looking for join operations
and cascades them into multiple join paths.
To illustrate, consider
@verbatim
	a:= bat.new(:oid,:oid);
	b:= bat.new(:oid,:oid);
	c:= bat.new(:oid,:str);
	j1:= algebra.join(a,b);
	j2:= algebra.join(j1,c);
	j3:= algebra.join(b,b);
	j4:= algebra.join(b,j3);
@end verbatim
The optimizer will first replace all arguments
by their join sequence. The underlying instructions
are left behind for the deadcode optimizer to be
removed.
@verbatim
	a:= bat.new(:oid,:oid);
	j1:= algebra.join(a,b);
	j2:= algebra.joinPath(a,b,c);
	j3:= algebra.join(b,b);
	j4:= algebra.joinPath(b,b,b);
@end verbatim
In principle, the joinpaths may contain common
subpaths, whose materialization would improve
performance.
The SQL front-end produces often produces
snippets of the following structure
@verbatim
    t1:= algebra.join(b,c);
    z1:= algebra.join(a,t1);
	...
    t2:= algebra.join(b,d);
    z2:= algebra.join(a,t2);
@end verbatim
The joinpath would merge them into
@verbatim
    z1:= algebra.joinPath(a,b,c);
	...
    z2:= algebra.joinPath(a,b,d);
@end verbatim
which are handle by a heuristic looking
at the first two argments and re-uses
a materialized join.
@verbatim
    _13:= algebra.join(a,b);
    z1:= algebra.joinPath(_13,c);
	...
    z2:= algebra.joinPath(_13,d);
@end verbatim
An alternative is to make recognition
of the common re-useable paths an
integral part of the joinPath body.
@{
@mal
pattern optimizer.joinPath():str
address OPTjoinPath;
pattern optimizer.joinPath(mod:str, fcn:str):str
address OPTjoinPath
comment "Join path constructor";
pattern algebra.joinPath(l:bat[:any,:any]...):bat[:any,:any]
address ALGjoinPath
comment "internal routine to handle join paths.
	The type analysis is rather tricky.";
@h
#ifndef _OPT_JOINPATH_
#define _OPT_JOINPATH_
#include "opt_prelude.h"
#include "opt_support.h"
#include "mal_interpreter.h"

/* #define DEBUG_OPT_JOINPATH  */
@-
@c
#include "mal_config.h"
#include "opt_joinpath.h"

static int
OPTjoinPathImplementation(MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	int i,j,k, actions=0;
	int *pc, *used;
	str joinPathRef = putName("joinPath",8);
	InstrPtr q,r;
	InstrPtr *old;
	int limit,slimit;

	(void) stk;
	if (varGetProp(mb, getArg(mb->stmt[0], 0), inlineProp) != NULL)
		return 0;

	old= mb->stmt;
	limit= mb->stop;
	slimit= mb->ssize;
	newMalBlkStmt(mb,mb->ssize);

	/* beware, new variables and instructions are introduced */
	pc= (int*) GDKmalloc(sizeof(int)* mb->vtop * 2); /* to find last assignment */
	memset((char*) pc, 0, sizeof(int)* mb->vtop *2);

	/* calculate how often each variable is used ,
	   we are only expanding when a variable is used once. */
	used= (int*) GDKmalloc(sizeof(int)* mb->vtop * 2); /* beware, new variables are introduced */
	memset((char*) used, 0, sizeof(int)* mb->vtop * 2);

	for (i = 0; i<limit; i++){
		p= old[i];
		for(j=p->retc; j< p->argc; j++)
			used[getArg(p,j)]++;
	}

	for (i = 0; i<limit; i++){
		p= old[i];
		if( getModuleId(p)== algebraRef && getFunctionId(p)== joinRef ){
@-
Try to expand its argument list
@c
			q= copyInstruction(p);
			q->argc=1;
			for(j=p->retc; j<p->argc; j++){
				r= getInstrPtr(mb,pc[getArg(p,j)]);
				assert(r);
#ifdef DEBUG_OPT_JOINPATH 
				stream_printf(GDKout,"expand list \n");
				printInstruction(GDKout,mb, p, LIST_MAL_ALL);
				printInstruction(GDKout,mb, q, LIST_MAL_ALL);
				if(r)
				printInstruction(GDKout,mb, r, LIST_MAL_ALL);
#endif
				if( r &&  getModuleId(r)== algebraRef && 
					( getFunctionId(r)== joinRef  || getFunctionId(r)== joinPathRef) ){
					for(k= r->retc; k<r->argc; k++)
						q = pushArgument(mb,q,getArg(r,k));
				} else 
					q = pushArgument(mb,q,getArg(p,j));
			}
#ifdef DEBUG_OPT_JOINPATH 
			stream_printf(GDKout,"new joinPath instruction\n");
			printInstruction(GDKout,mb, q, LIST_MAL_ALL);
#endif
			if(q->argc<= p->argc){
				/* no change */
				freeInstruction(q);
				goto wrapup;
			}
@-
Final type check.
@c
			for(j=1; j<q->argc-1; j++)
			if( getTailType(getArgType(mb,q,j)) != getHeadType(getArgType(mb,q,j+1)) &&
			!( getTailType(getArgType(mb,q,j))== TYPE_oid  &&
				getHeadType(getArgType(mb,q,j))== TYPE_void) &&
			!( getTailType(getArgType(mb,q,j))== TYPE_void &&
				getHeadType(getArgType(mb,q,j))== TYPE_oid)
			 ){
				freeInstruction(q);
				goto wrapup;
			}
@-
Post-optimization. After the join path has been constructed
it should factor out common subpaths. The heuristic is to
remove any pair if its variables are used often.
The heuristics is sufficient for the code produced by SQL frontend
@c
			for(k=1; k< q->argc-1; k++)
			if ( used[getArg(q,k)] > 1 && used[getArg(q,k+1)] > 1){
				r= copyInstruction(q);
				getArg(r,1)= getArg(q,k);
				getArg(r,2)= getArg(q,k+1);
				r->argc=3;
				getArg(r,0)= newTmpVariable(mb,TYPE_any);
				getArg(q,k)= getArg(r,0);
				delArgument(q,k+1);
				pushInstruction(mb,r);
				for(j=0; j< r->retc; j++)
					pc[getArg(r,j)]= mb->stop-1;
				k--;
#ifdef DEBUG_OPT_JOINPATH 
				stream_printf(GDKout,"heuristic joinPath rule\n");
				printInstruction(GDKout,mb, r, LIST_MAL_ALL);
				printInstruction(GDKout,mb, q, LIST_MAL_ALL);
#endif
			}

			if ( q->argc > 3)
				setFunctionId(q,joinPathRef);
			p= q;
			actions++;
		} 
	wrapup:
		pushInstruction(mb,p);
		for(j=0; j< p->retc; j++)
			pc[getArg(p,j)]= mb->stop-1;
	}
	for(; i<slimit; i++)
	if(old[i])
		freeInstruction(old[i]);
	GDKfree(old);
	GDKfree(pc);
	GDKfree(used);
	return actions;
}
@include optimizerWrapper.mx
@h
@:exportOptimizer(joinPath)@
#endif
opt_export str ALGjoinPath(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
@c
#include "opt_statistics.h"
@:wrapOptimizer(joinPath,OPT_CHECK_ALL)@
@-
The join path optimizer takes a join sequence and
attempts to minimize the intermediate result.
The choice depends on a good estimate of intermediate
results.
For the time being, we use a simplistic model, based
on the assumption that most joins are foreign key joins anyway.
@c
size_t
ALGjoinCost(BAT *l, BAT *r)
{
	size_t lc, rc;

	lc = BATcount(l);
	rc = BATcount(r);
	if( l->ttype== TYPE_oid || r->htype== TYPE_oid )
		return MIN(lc,rc);
	return lc * rc;
}
@-
The join path type analysis should also be done at run time,
because the expressive power of MAL is insufficient to
enforce a proper join type list.
@h
opt_export BAT * ALGjoinPathBody(int top, BAT **joins);
@c
BAT *
ALGjoinPathBody(int top, BAT **joins)
{
	BAT *b;
	size_t estimate, e;
	int i, j;

	/* solve the join by pairing the smallest first */
	while (top > 2) {
		j = 0;
		estimate = ALGjoinCost(joins[0],joins[1]);
#ifdef DEBUG_OPT_JOINPATH
		printf("estimate join(%d,%d) %d\n", joins[0]->batCacheid, 
			joins[1]->batCacheid,(int)estimate);
#endif
		for (i = 1; i < top - 1; i++) {
			e = ALGjoinCost(joins[i], joins[i + 1]);
#ifdef DEBUG_OPT_JOINPATH
		printf("estimate join(%d,%d) %d\n", joins[i]->batCacheid, 
			joins[i+1]->batCacheid,(int)e);
#endif
			if (e < estimate) {
				estimate = e;
				j = i;
			}
		}
@-
BEWARE. you may not use a size estimation, because it
may fire a BATproperty check in a few cases.
@c
		b = BATjoin(joins[j], joins[j + 1], oid_nil);
#ifdef DEBUG_OPT_JOINPATH
		printf("%d:= join(%d,%d)\n", 
			b->batCacheid, joins[j]->batCacheid, joins[j + 1]->batCacheid);
#endif
		assert(b);
		BBPdecref(joins[j]->batCacheid, FALSE);
		BBPdecref(joins[j+1]->batCacheid, FALSE);
		joins[j] = b;
		top--;
		for (i = j + 1; i < top; i++)
			joins[i] = joins[i + 1];
	}
#ifdef DEBUG_OPT_JOINPATH
	printf("final join %d and %d\n", joins[0]->batCacheid, joins[1]->batCacheid);
#endif
	b = BATjoin(joins[0], joins[1], oid_nil);
	BBPdecref(joins[0]->batCacheid, FALSE);
	BBPdecref(joins[1]->batCacheid, FALSE);
	assert(b);
	return b;
}

str
ALGjoinPath(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	int i,*bid,top=0;
	BAT *b, **joins = (BAT**)alloca(pci->argc*sizeof(BAT*)); 

	(void)mb;
#ifdef DEBUG_OPT_JOINPATH
		printInstruction(GDKout,mb,pci,LIST_MAL_ALL);
#endif
	for (i = pci->retc; i < pci->argc; i++) {
		bid = (int *) getArgReference(stk, pci, i);
#ifdef DEBUG_OPT_JOINPATH
		printf("bid %d\n", *bid);
#endif
		if ((b = BATdescriptor(*bid)) == NULL) {
			for( --top; top>=0; top--)
				BBPreleaseref(joins[top]->batCacheid);
			throw(MAL, "algebra.joinPath", "Cannot access descriptor");
		}

		joins[top++] = b;
	}
	b= ALGjoinPathBody(top,joins);
	BBPkeepref(b->batCacheid);
	*(int *) getArgReference(stk, pci, 0) = b->batCacheid;
	return MAL_SUCCEED;
}
@}
