@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
@' Copyright August 2008-2009 MonetDB B.V.
@' All Rights Reserved.

@f opt_reorder
@- The dataflow reorder
MAL programs are largely logical descriptions of an execution plan.
After the mitosis and mergetable optimizers we have a large program, which when
executed as is, does not necessarily benefit from the locality
of data and operations. The problem is that the execution plan is
a DAG for which a topological order should be found that
minimizes the life time of variables and maximizes parallel execution. 
This is an NP hard optimization problem. Therefore, we have
to rely on an affordable heuristic steps.

The reorder optimizer transfers the breath-first plans of 
the mergetable into a depth-first traversal.
This increases cohesion for parallel execution.
It is performed by basic block that ends in a side-effect
bearing instruction. 
Simply walking backward and pulling out subplans is then
the way to go. This step could be optimized somewhat
by giving preference to variables that are too far
away in the plan from their source. It is however not
explored.

The secondary approach is to pull instructions to the
head of the plan if the dataflow such permits.
If you are not careful, you will end up with
the breathfirst plan again.

This track is abandonded in favor of a combination
of octopus and recycler on a single platform.
@{
@mal
pattern optimizer.reorder():str
address OPTreorder;
pattern optimizer.reorder(mod:str, fcn:str):str
address OPTreorder
comment "Reorder by dataflow dependencies";

@h
#ifndef _OPT_REORDER_
#define _OPT_REORDER_
#include "opt_prelude.h"
#include "opt_support.h"

/* #define DEBUG_OPT_REORDER  */
/* #define DEBUG_OPT_REORDER_DETAILS */
@c
#include "mal_config.h"
#include "opt_reorder.h"
#include "mal_instruction.h"
#include "mal_interpreter.h"

@-
Collect the statement dependencies in a table first
This can be done in linear time in size of the program.
@c
typedef struct{
	int cnt;
	int stmt[];
} *Node, NodeRecord;

static Node *
OPTdependencies(Client cntxt, MalBlkPtr mb){
	Node *list = (Node *) GDKzalloc(sizeof(Node) * mb->stop);
	int *var = (int*) GDKzalloc(sizeof(int) * mb->vtop);
	int i,j;
	InstrPtr p;
	
	if (list == NULL || var == NULL){
		if (list ) GDKfree(list);
		if (var) GDKfree(var);
		return NULL;
	}

	for ( i=0; i< mb->stop; i++){
		p= getInstrPtr(mb,i);
		list[i]= (Node) GDKzalloc(sizeof(NodeRecord)+sizeof(int)*p->maxarg);
		list[i]->cnt= p->argc;
		for( j=p->retc; j<p->argc; j++)
			list[i]->stmt[j]= var[getArg(p,j)];
		/* where it was assigned last */
		for( j=0; j<p->retc; j++){
			var[getArg(p,j)]= i;
		}
	}
#ifdef DEBUG_OPT_REORDER_DETAILS
	stream_printf(cntxt->fdout,"DEPENDENCY TABLE\n");
	for(i=0;i<mb->stop; i++)
	if( list[i]->cnt){
		stream_printf(cntxt->fdout,"[%d]",i);
		for(j=p->retc; j< list[i]->cnt; j++)
			stream_printf(cntxt->fdout," %d",list[i]->stmt[j]);
		stream_printf(cntxt->fdout,"\n");
	}
#else
	(void) cntxt;
#endif
	GDKfree(var);
	return list;
}
@-
The reorder works as follows. We take each basic block
recognized in the first phase and perform a restructuring
based on variable uses. Instructions are pulled closer
to the instruction that enables all its variables.
For efficiency we need a quick way to find out where variables
are being used.
@c
typedef struct USEREC{
	struct USEREC *lnk;
	int pc;
} *UsePtr, UseRecord;

static int
anchorPoint(MalBlkPtr mb, InstrPtr p, Lifespan span){
	int i, f= mb->ssize;
	for( i= p->retc; i<p->argc; i++)
	if ( getBeginLifespan( getArg(p,i),span) < f)
		f= getBeginLifespan(getArg(p,i),span);
	return f;
}
	
static void
OPTpull(Client cntxt, MalBlkPtr mb, int pc, UsePtr u, UsePtr *var, InstrPtr *old, Lifespan span){
	InstrPtr p;
	if (u->lnk)
		OPTpull(cntxt, mb, pc, u->lnk, var, old,span);
	if (old[u->pc] && anchorPoint(mb,old[u->pc],span) < pc){
#ifdef DEBUG_OPT_REORDER
		stream_printf(cntxt->fdout,"pull [%d] %d",u->pc,anchorPoint(mb, old[u->pc], span));
		printInstruction(cntxt->fdout,mb,0,old[u->pc],LIST_MAL_STMT);
#endif
		pushInstruction(mb, p =old[u->pc]);
		old[u->pc] =0;
		/* try to move all related instructions.
		if would lead again to breathfirst code
		so only recursion
		for (j=0; j< p->retc; j++)
			OPTpull(cntxt, mb, pc, var[getArg(p,0)],var,old,span);
		*/
	}
}
@-
Currently all instructions are subject to be pulled forward, but
this is not always necessary. Especially, check instruction can
stay where they are initially allocated.
Moreover, we should be careful not to reconstruct the breathfirst
representation again. Therefore we pull up only single strands.
@c
static void
OPTreshuffle(Client cntxt, MalBlkPtr mb, int first, int last, Lifespan span){
	UsePtr *var = (UsePtr*) GDKzalloc(sizeof(UseRecord) * mb->vtop);
	UsePtr u;
	int i,j;
	InstrPtr p, *old;
	
#ifdef DEBUG_OPT_REORDER_DETAILS
	stream_printf(cntxt->fdout,"RESHUFFLE %d - %d\nUSE TABLE\n",first,last);
#endif
	for ( i=first; i< last; i++){
		p= getInstrPtr(mb,i);
		for( j=0; j<p->argc; j++)
		if( !isVarConstant(mb,getArg(p,j)) ){
			u = (UsePtr) GDKzalloc(sizeof(UseRecord));
			u->pc= i;
			u->lnk= var[getArg(p,j)];
			var[getArg(p,j)]= u;
		}
	}
#ifdef DEBUG_OPT_REORDER
	for(i=0;i<mb->vtop; i++)
	if( var[i] ){
		stream_printf(cntxt->fdout,"[%d] %d",i,getBeginLifespan(span,i));
		for( u= var[i]; u != NULL; u = u->lnk){
			stream_printf(cntxt->fdout," %d",u->pc);
			printInstruction(cntxt->fdout,mb,0,mb->stmt[u->pc],LIST_MAL_STMT);
		}
	}
#else
	(void) cntxt;
#endif
	old = (InstrPtr*) GDKzalloc(sizeof(InstrPtr)* mb->stop);
	for ( i=first; i< last; i++){
		old[i] = mb->stmt[i];
		mb->stmt[i]=0;
	}
	mb->stop = first;

	/* start reshuffle */
	for ( i=first; i< last; i++)
	if( old[i]) {
#ifdef DEBUG_OPT_REORDER
		stream_printf(cntxt->fdout,"start [%d] %d",i, anchorPoint(mb, p, span));
		printInstruction(cntxt->fdout,mb,0,old[i],LIST_MAL_STMT);
#endif
		pushInstruction(mb,p = old[i]);
		old[i]= 0;
		/* try to pull related instructions of a single target */
		/* otherwise it becomes a breathfirst again */
		/* repetative calls may cure this */
		/* for (j=0; j< p->retc; j++)*/
			OPTpull(cntxt, mb, i,var[getArg(p,0)],var,old,span);
	}
#ifdef DEBUG_OPT_REORDER
	stream_printf(cntxt->fdout,"REORDER BASIC BLOCK\n");
	for ( i=first; i< last; i++)
		printInstruction(cntxt->fdout,mb,0,getInstrPtr(mb,i),LIST_MAL_STMT);
#endif
	/* garbage collect */
	for( i=0; i< mb->vtop; i++)
	for( u=var[i]; u!= NULL; u=var[i]){
		var[i]= u->lnk;
		GDKfree(u);
	}
	GDKfree(var);
	GDKfree(old);
}

static void
OPTremoveDep(Node *list, int lim){
	int i;
	for( i=0; i< lim; i++)
	if( list[i])
		GDKfree(list[i]);
	GDKfree(list);
}

static void
OPTdepthfirst(Client cntxt, MalBlkPtr mb, int pc, InstrPtr old[], Node dep[])
{
	int i;
	InstrPtr p;

	p= old[pc];
	old[pc] = 0;
	if( p == NULL)
		return;
	for (i= p->retc; i< p->argc; i++)
		OPTdepthfirst(cntxt, mb,dep[pc]->stmt[i], old, dep);
#ifdef DEBUG_OPT_REORDER
			stream_printf(cntxt->fdout,"dump[%d]:",pc);
			printInstruction(cntxt->fdout,mb,0,p,LIST_MAL_STMT);
#endif
	pushInstruction(mb, p);
}

static int
OPTreorderImplementation(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	int i,j, start;
	InstrPtr *old;
	int limit;
	Node *dep;
	Lifespan span;

	(void) cntxt;
	(void) stk;
#ifdef DEBUG_OPT_REORDER
	stream_printf(cntxt->fdout,"REORDER\n");
	printFunction(cntxt->fdout, mb,0, LIST_MAL_STMT);
#endif
	dep = OPTdependencies(cntxt,mb);
	limit= mb->stop;
	old = mb->stmt;
	newMalBlkStmt(mb, mb->ssize); /* some marge */
	pushInstruction(mb,old[0]);
	old[0]=0;

	start=1;
	for( i=1; i<limit; i++){
		p= old[i];
		if( p->token == ENDsymbol)
			break;
		if( hasSideEffects(p,TRUE)  || p->barrier ){
			OPTdepthfirst(cntxt, mb, i, old, dep);
			/* remove last instruction and keep for later */
			p= mb->stmt[mb->stop-1];
			mb->stmt[mb->stop-1]=0;
			mb->stop--;
			/* collect all seen sofar by backward grouping */
			/* since p has side-effects, we should secure all seen sofar */
			for(j=i-1; j>=start;j--) {
#ifdef DEBUG_OPT_REORDER
			if( old[j]){
				stream_printf(cntxt->fdout,"leftover: %d",start+1);
				printInstruction(cntxt->fdout,mb,0,old[j],LIST_MAL_STMT);
			}
#endif
				OPTdepthfirst(cntxt, mb, j, old, dep);
			}
			pushInstruction(mb,p);
			span= setLifespan(mb);
			if ( 0) /* don't use it for the time being */
				OPTreshuffle(cntxt,mb,start,i,span);
			GDKfree(span);
			span = 0;
			start = i+1;
		}
	}
	for(i=0; i<limit; i++)
		if (old[i])
			pushInstruction(mb,old[i]);
	OPTremoveDep(dep, limit);
	GDKfree(old);
#ifdef DEBUG_OPT_REORDER
	stream_printf(cntxt->fdout,"REORDER DONE\n");
	printFunction(cntxt->fdout, mb,0,  LIST_MAL_STMT);
#endif
	return 1;
}
@include optimizerWrapper.mx
@h
@:exportOptimizer(reorder)@
#endif
@c
#include "opt_statistics.h"

@:wrapOptimizer(reorder,OPT_CHECK_ALL)@
@}
