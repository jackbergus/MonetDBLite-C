@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
@' Copyright August 2008-2010 MonetDB B.V.
@' All Rights Reserved.

@f opt_reorder
@- The dataflow reorder
MAL programs are largely logical descriptions of an execution plan.
After the mitosis and mergetable optimizers we have a large program, which when
executed as is, does not necessarily benefit from the locality
of data and operations. The problem is that the execution plan is
a DAG for which a topological order should be found that
minimizes the life time of variables and maximizes parallel execution. 
This is an NP hard optimization problem. Therefore, we have
to rely on an affordable heuristic steps.

The reorder optimizer transfers the breath-first plans of 
the mergetable into a depth-first traversal.
This increases cohesion for parallel execution.
It is performed by basic block that ends in a side-effect
bearing instruction. 
Simply walking backward and pulling out subplans is then
the way to go. This step could be optimized somewhat
by giving preference to variables that are too far
away in the plan from their source. It is however not
explored.

The secondary approach is to pull instructions to the
head of the plan if the dataflow such permits.
If you are not careful, you will end up with
the breathfirst plan again.
This track is abandonded in favor of a combination
of octopus and recycler on a single platform.

Beware, variables can be assigned a value multiple times.
The order this implies should be respected.

Hidden dependencies occur als with e.g. sql.assert() calls.
Reordering them may easily lead to an assertion violation.
Therefore, reordering should be limited to basic blocks without
side-effects.
@{
@mal
pattern optimizer.reorder():str
address OPTreorder;
pattern optimizer.reorder(mod:str, fcn:str):str
address OPTreorder
comment "Reorder by dataflow dependencies";

@h
#ifndef _OPT_REORDER_
#define _OPT_REORDER_
#include "opt_prelude.h"
#include "opt_support.h"

/* #define DEBUG_OPT_REORDER  */
/* #define DEBUG_OPT_REORDER_DETAILS */
@c
#include "mal_config.h"
#include "opt_reorder.h"
#include "mal_instruction.h"
#include "mal_interpreter.h"

@-
Collect the statement dependencies in a table first
This can be done in linear time in size of the program.
@c
typedef struct{
	int cnt;
	int stmt[];
} *Node, NodeRecord;

static Node *
OPTdependencies(Client cntxt, MalBlkPtr mb){
	Node *list = (Node *) GDKzalloc(sizeof(Node) * mb->stop);
	int *var = (int*) GDKzalloc(sizeof(int) * mb->vtop);
	int i,j;
	InstrPtr p;
	
	if (list == NULL || var == NULL){
		if (list ) GDKfree(list);
		if (var) GDKfree(var);
		return NULL;
	}

	for ( i=0; i< mb->stop; i++){
		p= getInstrPtr(mb,i);
		list[i]= (Node) GDKzalloc(sizeof(NodeRecord) + sizeof(int) * p->maxarg);
		if (list[i] == NULL){
			for (i--; i>=0; i--)
				GDKfree(list[i]);
			GDKfree(list);
			GDKfree(var);
			return 0;
		}
		list[i]->cnt= p->argc;
		for( j=p->retc; j<p->argc; j++)
			list[i]->stmt[j]= var[getArg(p,j)];
		/* keep the assignment order */
		for( j= 0; j < p->retc; j++)
		if ( var[ getArg(p,j)] )
			list[i]->stmt[j] = var [getArg(p,j)];
		/* remember the last assignment  */
		for( j=0; j<p->retc; j++)
			var[getArg(p,j)]= i;
		/* and also remember when it was last used 
		for( j=p->retc; j<p->argc; j++)
			var[getArg(p,j)]= i;
		*/
	}
#ifdef DEBUG_OPT_REORDER_DETAILS
	stream_printf(cntxt->fdout,"DEPENDENCY TABLE\n");
	for(i=0;i<mb->stop; i++)
	if( list[i]->cnt){
		stream_printf(cntxt->fdout,"[%d]",i);
		for(j=p->retc; j< list[i]->cnt; j++)
			stream_printf(cntxt->fdout," %d",list[i]->stmt[j]);
		stream_printf(cntxt->fdout,"\n");
	}
#else
	(void) cntxt;
#endif
	GDKfree(var);
	return list;
}

static void
OPTremoveDep(Node *list, int lim){
	int i;
	for( i=0; i< lim; i++)
	if( list[i])
		GDKfree(list[i]);
	GDKfree(list);
}

static void
OPTdepthfirst(Client cntxt, MalBlkPtr mb, int pc, InstrPtr old[], Node dep[])
{
	int i;
	InstrPtr p;

	p= old[pc];
	old[pc] = 0;
	if( p == NULL)
		return;
	for (i= 0; i< p->argc; i++)
		OPTdepthfirst(cntxt, mb,dep[pc]->stmt[i], old, dep);
#ifdef DEBUG_OPT_REORDER
			stream_printf(cntxt->fdout,"dump[%d]:",pc);
			printInstruction(cntxt->fdout,mb,0,p,LIST_MAL_STMT);
#endif
	pushInstruction(mb, p);
}

static int
OPTreorderImplementation(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	int i,j, start;
	InstrPtr *old;
	int limit;
	Node *dep;

	(void) cntxt;
	(void) stk;
#ifdef DEBUG_OPT_REORDER
	stream_printf(cntxt->fdout,"REORDER\n");
	printFunction(cntxt->fdout, mb,0, LIST_MAL_STMT);
#endif
	dep = OPTdependencies(cntxt,mb);
	limit= mb->stop;
	old = mb->stmt;
	if ( newMalBlkStmt(mb, mb->ssize) < 0)
		return 0;
	
	pushInstruction(mb,old[0]);
	old[0]=0;
	for( i=1; i<limit; i++)
	if ( getModuleId(old[i]) == datacyclotronRef && getFunctionId(old[i]) == bindRef){
		pushInstruction(mb,old[i]);
		old[i] = 0;
	}

	start=1;
	for( i=1; i<limit; i++){
		p= old[i];
		if ( p == 0)
			continue;
		if( p->token == ENDsymbol)
			break;
		if( hasSideEffects(p,TRUE) || isUpdateInstruction(p)  || isUnsafeFunction(p) || p->barrier ){
			OPTdepthfirst(cntxt, mb, i, old, dep);
			/* remove last instruction and keep for later */
			p= mb->stmt[mb->stop-1];
			mb->stmt[mb->stop-1]=0;
			mb->stop--;
			/* collect all seen sofar by backward grouping */
			/* since p has side-effects, we should secure all seen sofar */
			for(j=i-1; j>=start;j--) {
#ifdef DEBUG_OPT_REORDER
			if( old[j]){
				stream_printf(cntxt->fdout,"leftover: %d",start+1);
				printInstruction(cntxt->fdout,mb,0,old[j],LIST_MAL_STMT);
			}
#endif
				OPTdepthfirst(cntxt, mb, j, old, dep);
			}
			pushInstruction(mb,p);
			start = i+1;
		}
	}
	for(i=0; i<limit; i++)
		if (old[i])
			pushInstruction(mb,old[i]);
	OPTremoveDep(dep, limit);
	GDKfree(old);
#ifdef DEBUG_OPT_REORDER
	stream_printf(cntxt->fdout,"REORDER DONE\n");
	printFunction(cntxt->fdout, mb,0,  LIST_MAL_STMT);
#endif
	return 1;
}
@include optimizerWrapper.mx
@h
@:exportOptimizer(reorder)@
#endif
@c
#include "opt_statistics.h"

@:wrapOptimizer(reorder,OPT_CHECK_ALL)@
@}
