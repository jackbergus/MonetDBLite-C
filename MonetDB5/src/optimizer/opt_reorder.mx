@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
@' Copyright August 2008-2009 MonetDB B.V.
@' All Rights Reserved.

@f opt_reorder
@- The dataflow reorder
MAL programs are largely logical descriptions of an execution plan.
After the mitosis and mergetable optimizers we have a large program, which when
executed as is, does not benefit from the locality
of data and operations. The breath-first traversal of all independent
plans should be turned into a depth-first traversal.

The approach here is to reorder the complete program.
It is performed by basic block that ends in a side-effect
bearing instruction. 
Simply walking backward and pulling out subplans is then
the way to go.
@{
@mal
pattern optimizer.reorder():str
address OPTreorder;
pattern optimizer.reorder(mod:str, fcn:str):str
address OPTreorder
comment "Reorder by dataflow dependencies";

@h
#ifndef _OPT_REORDER_
#define _OPT_REORDER_
#include "opt_prelude.h"
#include "opt_support.h"

/* #define DEBUG_OPT_REORDER  */
@c
#include "mal_config.h"
#include "opt_reorder.h"
#include "mal_instruction.h"
#include "mal_interpreter.h"

@-
Collect the statement dependencies in a table first
This can be done in linear time in size of the program.
@c
typedef struct{
	int cnt;
	int stmt[];
} *Node, NodeRecord;

static Node *
OPTdependencies(Client cntxt, MalBlkPtr mb){
	Node *list = (Node *) GDKzalloc(sizeof(Node) * mb->stop);
	int *var = (int*) GDKzalloc(sizeof(int) * mb->vtop);
	int i,j;
	InstrPtr p;
	
	if (list == NULL || var == NULL){
		if (list ) GDKfree(list);
		if (var) GDKfree(var);
		return NULL;
	}

	for ( i=0; i< mb->stop; i++){
		p= getInstrPtr(mb,i);
		list[i]= (Node) GDKzalloc(sizeof(NodeRecord)+sizeof(int)*p->maxarg);
		list[i]->cnt= p->argc;
		for( j=p->retc; j<p->argc; j++)
			list[i]->stmt[j]= var[getArg(p,j)];
		/* where it was assigned last */
		for( j=0; j<p->retc; j++){
			var[getArg(p,j)]= i;
		}
	}
#ifdef DEBUG_OPT_REORDER
	stream_printf(cntxt->fdout,"DEPENDENCY TABLE\n");
	for(i=0;i<mb->stop; i++){
		stream_printf(cntxt->fdout,"[%d]",i);
		for(j=p->retc; j< list[i]->cnt; j++)
			stream_printf(cntxt->fdout," %d",list[i]->stmt[j]);
		stream_printf(cntxt->fdout,"\n");
	}
#else
	(void) cntxt;
#endif
	GDKfree(var);
	return list;
}

static void
OPTremoveDep(Node *list, int lim){
	int i;
	for( i=0; i< lim; i++)
	if( list[i])
		GDKfree(list[i]);
	GDKfree(list);
}

static void
OPTdepthfirst(Client cntxt, MalBlkPtr mb, int pc, InstrPtr old[], Node dep[])
{
	int i;
	InstrPtr p;

	p= old[pc];
	old[pc] = 0;
	if( p == NULL)
		return;
	for (i= p->retc; i< p->argc; i++)
		OPTdepthfirst(cntxt, mb,dep[pc]->stmt[i], old, dep);
#ifdef DEBUG_OPT_REORDER
			stream_printf(cntxt->fdout,"dump[%d]:",pc);
			printInstruction(cntxt->fdout,mb,0,p,LIST_MAL_STMT);
#endif
	pushInstruction(mb, p);
}

static int
OPTreorderImplementation(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	int i,j, start;
	InstrPtr *old;
	int limit;
	Node *dep;

	(void) cntxt;
	(void) stk;
#ifdef DEBUG_OPT_REORDER
	stream_printf(cntxt->fdout,"REORDER\n");
	printFunction(cntxt->fdout, mb,0, LIST_MAL_STMT);
#endif
	dep = OPTdependencies(cntxt,mb);
	limit= mb->stop;
	old = mb->stmt;
	newMalBlkStmt(mb, mb->ssize); /* some marge */
	pushInstruction(mb,old[0]);
	old[0]=0;

	start=1;
	for( i=1; i<limit; i++){
		p= old[i];
		if( p->token == ENDsymbol)
			break;
		if( hasSideEffects(p,TRUE)  || p->barrier ){
#ifdef DEBUG_OPT_REORDER
			stream_printf(cntxt->fdout,"apply[%d]:",i);
			printInstruction(cntxt->fdout,mb,0,p,LIST_MAL_STMT);
#endif
			OPTdepthfirst(cntxt, mb, i, old, dep);
			/* remove last instruction and keep for later */
			p= mb->stmt[mb->stop-1];
			mb->stmt[mb->stop-1]=0;
			mb->stop--;
			/* collect all seen sofar by backward grouping */
			/* since p has side-effects, we should secure all seen sofar */
			for(j=i-1; j>=start;j--) {
#ifdef DEBUG_OPT_REORDER
			stream_printf(cntxt->fdout,"leftover: %d",start+1);
			if( old[j])
				printInstruction(cntxt->fdout,mb,0,old[j],LIST_MAL_STMT);
#endif
				OPTdepthfirst(cntxt, mb, j, old, dep);
			}
			pushInstruction(mb,p);
			old[i]= 0;
			start = i+1;
		}
	}
	for(i=0; i<limit; i++)
		if (old[i])
			pushInstruction(mb,old[i]);
	OPTremoveDep(dep, limit);
	GDKfree(old);
#ifdef DEBUG_OPT_REORDER
	stream_printf(cntxt->fdout,"REORDER DONE\n");
	printFunction(cntxt->fdout, mb,0,  LIST_MAL_STMT);
#endif
	return 1;
}
@include optimizerWrapper.mx
@h
@:exportOptimizer(reorder)@
#endif
@c
#include "opt_statistics.h"

@:wrapOptimizer(reorder,OPT_CHECK_ALL)@
@}
