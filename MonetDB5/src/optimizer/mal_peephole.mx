@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2006 CWI.
@' All Rights Reserved.

@f mal_peephole
@a M. Kersten
@-
@node Peephole Optimization, Multiplex Compiler,  Singleton Sets, Optimizer Toolkit
@- Peephole optimization
Recursive descend query compilers easily miss opportunities
for better code generation, because limited context is retained
or lookahead available. The peephole optimizer is
built around such recurring patterns and compensates
for the compilers 'mistakes'.
The collection of peephole patterns should grow over time and
front-end specific variations are foreseen.
@{
@mal
pattern optimizer.peephole():str
address QOTPHoptimizer;
pattern optimizer.peephole(mod:str, fcn:str):str
address QOTPHoptimizer
comment "Perform local rewrites";
@h
#ifndef _MAL_PEEPHOLE_
#define _MAL_PEEPHOLE_
#include "mal_optimizer.h"

/* #define DEBUG_MAL_PEEPHOLE     show partial result */

opt_export str PHoptimizer(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);

#define match(X,M,F) ( (X) && getFunctionId(X) && strcmp(getFunctionId(X),F)==0 && \
	getModuleId(X) && strcmp(getModuleId(X),M)==0)
#endif

@c
#include "mal_prelude.h"
#include "mal_peephole.h"
#include "mal_namespace.h"
#include "mal_interpreter.h"	/* for showErrors() */
@}
@- 
The SQL frontend heavily relies on a pivot table, which
is a generated oid sequence. Unfortunately, this
is not seen and the pattern '$i := calc.oid(0@@0); $j:= algebra.markT($k,$i);'
occurs often. This can be replaced with '$j:= algebra.markT($k)';

Another example of a 2-way instruction sequence produced is then
'$j:= algebra.markT($k); $l:= bat.reverse($j);',
which can be replaced by '$l:= algebra.markH($k);'.

The reverse-reverse operation also falls into this category.
Reversal pairs may result from the processing scheme of a front-end compiler
or from a side-effect from other optimization steps. Such reversal pairs should
be removed as quickly as possible, so as to reduce the complexity of finding
alternative optimization opportunities.
As in all cases we should ensure that the intermediates dropped are not
used for other purposes as well.

@verbatim
	r:bat[:int,:int]:= bat.new(:int,:int);
	o:= calc.oid(0@0);
	z:= algebra.markT(r,o);
	rr:= bat.reverse(z);
	s := bat.reverse(r);
	t := bat.reverse(s);
	io.print(t);
	optimizer.peephole();
@end verbatim
which is translated by the peephole optimizer into:
@verbatim
	r:bat[:int,:int] := bat.new(:int,:int);
	rr := algebra.markH(r);
	io.print(r);
@end verbatim
@{
The type of a variable may have to be reset when you change
the program structure.
@c
str
PHoptimizer(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	InstrPtr p, q, r, *old;
	int i, limit, doit, aropt = 0;
	lng clk = GDKusec();

	if( mb->errors) 
		return MAL_SUCCEED;
#ifdef DEBUG_MAL_PEEPHOLE
	stream_printf(GDKout, "Peephole optimizer started\n");
#endif
	(void) stk;
	(void) pci;
	do {
		doit = 0;
		aropt = 0;
		setLifespan(mb);
		limit = mb->stop;
		old = mb->stmt;

		newMalBlkStmt(mb, mb->stop);
		for (i = 0; i < limit; i++) {
			p = old[i];
			q = i < limit - 1 ? old[i + 1] : 0;
			if (getVar(mb, getArg(p, 0))->endLifespan == i + 1 && 
				match(p, "calc", "oid") && 
				isConstant(mb, getArg(p, 1)) && 
				getVar(mb,getArg(p,1))->value.val.oval == 0){
				if (match(q, "algebra", "markT") || 
					match(q, "algebra", "markH")) {
#ifdef DEBUG_MAL_PEEPHOLE
					printf("PEEPHOLE 0\n");
					printInstruction(GDKout, mb, p, LIST_MAL_ALL);
					printInstruction(GDKout, mb, q, LIST_MAL_ALL);
#endif
					freeInstruction(p);
					q->argc--;
					pushInstruction(mb, q);
					i++;
					doit++;
				}
/* INVALID FOR THE TIME
			} else if (getVar(mb, getArg(p, 0))->endLifespan == i + 1 && 
						match(p, "algebra", "markT") && 
						match(q, batRef, reverseRef)
			) {
#ifdef DEBUG_MAL_PEEPHOLE
				printf("PEEPHOLE 1\n");
				printInstruction(GDKout, mb, p, LIST_MAL_ALL);
				printInstruction(GDKout, mb, q, LIST_MAL_ALL);
#endif

				getArg(q, 1) = getArg(p, 1);
				setModuleId(q, putName("algebra", 7));
				setFunctionId(q, putName("markH", 5));
				pushInstruction(mb, q);
				freeInstruction(p);
				i++;
				doit++;
			} else if (q && match(p, "algebra", "markH") && match(q, "algebra", "join")
			) {
#ifdef DEBUG_MAL_PEEPHOLE
				printf("PEEPHOLE markH-join\n");
				printInstruction(GDKout, mb, p, LIST_MAL_ALL);
				printInstruction(GDKout, mb, q, LIST_MAL_ALL);
#endif
				if (getArg(p, 1) == getArg(q, 2)) {
					r = newInstruction(mb,ASSIGNsymbol);
					getArg(r, 0) = getArg(q, 0);
					pushArgument(mb, r, getArg(q, 2));
					freeInstruction(q);
					pushInstruction(mb, p);
					pushInstruction(mb, r);
					i++;
					doit++;
					aropt++;
				} else
					pushInstruction(mb, p);
*/
			} else if (q && match(p, batRef, reverseRef) && 
						match(q, batRef, reverseRef) && 
						getArg(p, 0) == getArg(q, 1) && 
						getVar(mb, getArg(p, 0))->endLifespan == i + 1) {
#ifdef DEBUG_MAL_PEEPHOLE
				printf("PEEPHOLE reverse-reverse\n");
				printInstruction(GDKout, mb, p, LIST_MAL_ALL);
				printInstruction(GDKout, mb, q, LIST_MAL_ALL);
#endif
				r = newInstruction(mb,ASSIGNsymbol);
				getArg(r, 0) = getArg(q, 0);
				pushArgument(mb, r, getArg(p, 1));
				freeInstruction(p);
				freeInstruction(q);
				pushInstruction(mb, r);
				i++;
				aropt++;
				doit++;
			} else if (match(p, "optimizer", "peephole"))
				freeInstruction(p);
			else
				pushInstruction(mb, p);
		}
		GDKfree(old);
		if (aropt) {
			chkProgram(MCgetClient()->nspace, mb);
			setLifespan(mb);
			ARoptimizer(mb, 0, 0);
		}
#ifdef DEBUG_MAL_PEEPHOLE
		if (doit) {
			stream_printf(GDKout, "PEEPHOLE %d\n", doit);
			printFunction(GDKout, mb, LIST_MAL_ALL);
		}
#endif
	} while (doit);
#ifdef DEBUG_MAL_PEEPHOLE
	printFunction(GDKout, mb, LIST_MAL_ALL);
#endif
	optimizerCheck(mb, "mal.peephole", 1, GDKusec() - clk);
	return MAL_SUCCEED;
}

@- Optimizer code wrapper
@c
mal_export str QOTPHoptimizer(MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
str QOTPHoptimizer(MalBlkPtr mb, MalStkPtr stk, InstrPtr p){
	str	modnme;
	str	fcnnme;
	Module  scope=NULL;
	Symbol s= NULL;
	Client c= MCgetClient();
	lng clk= GDKusec();

	/* handle the empty argument list */
	if( p->argc== 1){
		/* setLifespan(mb); they should do it themselves*/
		optimizerInit();
		PHoptimizer(mb, stk, p);
		return MAL_SUCCEED;
	}
	if( stk != 0){
		modnme= (str)getArgValue(stk,p,1);
		fcnnme= (str)getArgValue(stk,p,2);
	} else {
		modnme= getArgDefault(mb,p,1);
		fcnnme= getArgDefault(mb,p,2);
	}
	scope = findModule(c->nspace,putName(modnme,strlen(modnme)) );
	if( scope)
		s= findSymbolInModule(scope,putName(fcnnme,strlen(fcnnme)));

	if( s == NULL) {
		char buf[1024];
		snprintf(buf,1024, "Could not find %s.%s\n",modnme,fcnnme);
		return throwMessage("optimizer.peephole",buf);
	}
	
	if( s->def->errors == 0){
		optimizerInit();
		PHoptimizer(s->def,0,0);
		optimizerCheck(s->def,"peephole",1,GDKusec()-clk);
	}
	removeInstruction(mb, p);
	return MAL_SUCCEED;
}
@}
