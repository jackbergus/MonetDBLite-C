@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
@' Copyright August 2008-2010 MonetDB B.V.
@' All Rights Reserved.

@f opt_recycler
@- The recycler
Query optimization and processing in off-the-shelf database systems is often
still focused on individual queries. The queries are analyzed in isolation
and ran against a kernel regardless opportunities offered by concurrent or
previous invocations.

This approach is far from optimal and two directions to improve
are explored: materialized views and (partial) result-set reuse.
Materialized views are derived from query logs. They represent
common sub-queries, whose materialization improves
subsequent processing times.
Re-use of (partial) results is used in those cases where a
zooming-in or navigational application is at stake.

The Recycler optimizer and module extends this with a middle out approach.
They exploit the materialize-all-intermediate approach of MonetDB
by deciding to keep a hold on them as long as deemed beneficial.

The approach taken is to mark the instructions in a MAL program
using the recycler optimizer call, such that their result is retained
in a global recycle cache hardwired in the MAL interpreter.
Instructions become subject to the Recycler if
at least one of its arguments is a BAT and all others are
either constants or variables already known in the Recycler.

Upon execution, the recycler is called from the inner loop
of the MAL interpreter to first check for
an up-to-date result to be picked up at no cost.
Otherwise, it evaluates the instruction and calls upon
policy functions to decide if it is worthwhile to keep.

The Recycler comes with a few policy controlling operators
to experiment with its effect in concrete settings.
The retain policy controls when to keep results around,
the reuse policy looks after exact duplicate instructions
or uses semantical knowledge on MAL instructions to detect
potential reuse gain (e.g. reuse select results).
And finally, the cache policy looks after the storage space for the 
intermediate result pool.
The details are described in the recycle module.

@mal
pattern optimizer.recycle():str
address OPTrecycle;
pattern optimizer.recycle(mod:str, fcn:str):str
address OPTrecycle
comment "Replicator code injection";

@{
@-
The number of overloaded instructions is kept to a minimum.
@h
#ifndef _OPT_RECYCLER_
#define _OPT_RECYCLER_
#include "opt_prelude.h"
#include "opt_support.h"
#include "mal_recycle.h"

/* #define DEBUG_OPT_RECYCLER */
@-
The variables are all checked for being eligible as a variable
subject to recycling control. A variable may only be assigned
a value once. The function is a sql.bind(-,-,-,0) or all arguments
are already recycle enabled or constant.

The arguments of the function cannot be recycled.
They change with each call. This does not mean
that the instructions using them can not be a
target of recycling.

Just looking at a kept result target is not good enough.
You have to sure that the arguments are also the same.
This rules out function arguments.

The recycler is targeted towards a query only database.
The best effect is obtained for a single-user mode (sql_debug=32 )
when the delta-bats are not processed which allows longer instruction
chains to be recycled.
Update statements are not recycled. They trigger cleaning of 
the recycle cache at the end of the query. Only intermediates
derived from the updated columns are invalidated.
Separate update instructions in queries, such as bat.append implementing 'OR',
are monitored and also trigger cleaning the cache.
@c
#include "mal_config.h"
#include "opt_recycler.h"
#include "mal_instruction.h"

static int
OPTrecycleImplementation(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	int i, j, cnt, actions = 0;
	Lifespan span;
	InstrPtr *old, q;
	int limit, updstmt = 0;
	char *recycled;
	short app_sc = -1,app_tbl = -1;

	(void) cntxt;
	(void) stk;
	/* watch out, instructions may introduce new variables */
	limit= mb->stop;
	old = mb->stmt;

	for (i = 1; i<limit; i++) {
		p = old[i];
		if (getModuleId(p)==sqlRef &&
            (getFunctionId(p) == affectedRowsRef ||
              getFunctionId(p) == exportOperationRef ||
              getFunctionId(p) == appendRef ||
              getFunctionId(p) == updateRef ||
              getFunctionId(p) == deleteRef) )
			updstmt = 1;
	}

	span = setLifespan(mb);
	if ( span == NULL)
		return 0;

	recycled= GDKzalloc(sizeof(char)*mb->vtop*2);
	if ( recycled == NULL)
		return 0;
	if ( newMalBlkStmt(mb, mb->ssize) < 0){
		GDKfree(recycled);
		return 0;
	}
	pushInstruction(mb,old[0]);

	/* create a handle for recycler */
	q= newFcnCall(mb,"recycle","prelude");
	for (i = 1; i<limit; i++) {
		p = old[i];
		if (hasSideEffects(p,TRUE) || isUnsafeFunction(p)){
			if( getModuleId(p)== recycleRef ){ /*don't inline recycle instr. */
				freeInstruction(p);
				continue;
			}
			pushInstruction(mb,p);
				/*  update instructions are not recycled but monitored*/
			if( isUpdateInstruction(p)){
				if (getModuleId(p) == batRef &&
					(getArgType(mb,p,1)==TYPE_bat
					|| isaBatType(getArgType(mb, p,1)))){
					recycled[getArg(p,1)]= 0;
					q= newFcnCall(mb,"recycle","reset");
					pushArgument(mb,q, getArg(p,1));
					actions++;
				}
				if (getModuleId(p) == sqlRef){
					if (getFunctionId(p) == appendRef){
						app_sc = getArg(p,1);
						app_tbl = getArg(p,2);
					} else {
						q= newFcnCall(mb,"recycle","reset");
						pushArgument(mb,q, getArg(p,1));
						pushArgument(mb,q, getArg(p,2));
						if (getFunctionId(p) == updateRef)
							pushArgument(mb,q, getArg(p,3));
					}
					actions++;
				}
			}
			continue;
		}
		if (p->barrier  && p->token != CMDcall){
			/* never save a barrier unless it is a command and side-effect free */
			pushInstruction(mb,p);
			continue;
		}

		if( p->token== ENDsymbol){
			if ( updstmt && app_sc >= 0 ){
					q= newFcnCall(mb,"recycle","reset");
					pushArgument(mb,q, app_sc);
					pushArgument(mb,q, app_tbl);
			}
			(void) newFcnCall(mb,"recycle","epilogue");
			pushInstruction(mb,p);
			continue;
		} 

		/* don't change instructions in update statements */
		if( updstmt){
			pushInstruction(mb,p);
			continue;
		} 

		/* skip simple assignments */
		if( p->token == ASSIGNsymbol){
			pushInstruction(mb,p);
			continue;
		} 

		/* general rule: all arguments are constants or recycled */
		cnt = 0;
		for (j=p->retc; j<p->argc; j++)
			if(recycled[getArg(p,j)] || isVarConstant(mb, getArg(p,j)) )
				cnt++;
		if (cnt == p->argc-p->retc) {
#ifdef DEBUG_OPT_RECYCLER  
			stream_printf(cntxt->fdout,"recycle instruction\n");
			printInstruction(cntxt->fdout,mb, 0, p,LIST_MAL_ALL);
#endif
			actions ++;
			p->recycle = REC_MAX_INTEREST; /* this instruction is to be monitored */
			for (j= 0; j < p->retc; j++)
				if (getLastUpdate(span, getArg(p,j)) == i)
					recycled[getArg(p,j)] = 1;
		}
@-
The expected gain is largest if we can re-use selections
on the base tables in SQL. These, however, are marked as
uselect() calls, which only produce the oid head.
For cheap types we preselect using select() and re-map uselect() back 
over this temporary.
For the time being for all possible selects encountered
are marked for re-use.

@c
		/* take care of semantic driven recyling */
		/* for selections check the bat argument only
		the range is often template parameter*/
		if(( getFunctionId(p)== selectRef || 
		     getFunctionId(p)== antiuselectRef ||
		     getFunctionId(p)== likeselectRef ||
		     getFunctionId(p)== putName("like",4) || 
	         getFunctionId(p)== thetaselectRef ) &&
	      	 recycled[getArg(p,1)] ){
			p->recycle = REC_MAX_INTEREST;
			actions ++;
			if (getLastUpdate(span, getArg(p,0)) == i)
				recycled[getArg(p,0)] = 1;
		}
		if( ( getFunctionId(p) == uselectRef || getFunctionId(p) == thetauselectRef)
			&& recycled[getArg(p,1)]) {
			if (!ATOMvarsized( getGDKType( getArgType(mb,p,2)))) { 
				q = copyInstruction(p);
				getArg(q,0)= newTmpVariable(mb,TYPE_any); 
				if ( getFunctionId(p) == uselectRef )
					setFunctionId(q, selectRef); 
				else setFunctionId(q, thetaselectRef); 
				q->recycle = REC_MAX_INTEREST;
				recycled[getArg(q,0)] = 1;
				pushInstruction(mb,q);
				getArg(p,1) = getArg(q,0);
				setFunctionId(p,projectRef);
				p->argc = 2;
			}
			p->recycle = REC_MAX_INTEREST;
			actions ++; 
			if (getLastUpdate(span, getArg(p,0)) == i)
				recycled[getArg(p,0)] = 1;
		}

		if(getModuleId(p) == pcreRef) {
			if (( getFunctionId(p)== selectRef && recycled[getArg(p,2)]) ||  
			    ( getFunctionId(p)== uselectRef && recycled[getArg(p,2)])){
				p->recycle = REC_MAX_INTEREST;
				actions ++;
				if (getLastUpdate(span, getArg(p,0)) == i)
				recycled[getArg(p,0)] = 1;
			} 
			else if( getFunctionId(p)== likeuselectRef && recycled[getArg(p,1)]) {
				q = copyInstruction(p);
				getArg(q,0)= newTmpVariable(mb,TYPE_any); 
				setFunctionId(q, likeselectRef);
				q->recycle = REC_MAX_INTEREST;
				recycled[getArg(q,0)] = 1;
				pushInstruction(mb,q);
				getArg(p,1) = getArg(q,0);
				setFunctionId(p,projectRef);
				setModuleId(p,algebraRef);
				p->argc = 2;
				p->recycle = REC_MAX_INTEREST;
				actions ++; 
				if (getLastUpdate(span, getArg(p,0)) == i)
					recycled[getArg(p,0)] = 1;
			} 
		}


@-
The sql.bind instructions should be handled carefully
The delete and update BATs should not be recycled,
because they may lead to view dependencies that later interfere
with the transaction commits.
@c
		if (getModuleId(p)== sqlRef && 
			(((getFunctionId(p)==bindRef || getFunctionId(p) == putName("bind_idxbat",11)) && 
				getVarConstant(mb, getArg(p,4)).val.ival != 0) ||
				getFunctionId(p)== binddbatRef) ) {
				recycled[getArg(p,0)]=0;
				p->recycle = REC_NO_INTEREST; /* this instruction is not monitored */
			}

		if (getModuleId(p) == octopusRef && 
			 getFunctionId(p) == bindRef ) {
				recycled[getArg(p,0)] = 1;
				p->recycle = REC_MAX_INTEREST; 
		}

		pushInstruction(mb,p);
	}
	GDKfree(span);
	GDKfree(old);
	GDKfree(recycled);
	mb->recycle = actions > 0;
	return actions;
}
@include optimizerWrapper.mx
@h
@:exportOptimizer(recycle)@
#endif
@c
#include "opt_statistics.h"
@:wrapOptimizer(recycle,OPT_CHECK_TYPES)@

@}
