@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2008 CWI.
@' All Rights Reserved.

@f opt_recycler
@- The recycler
Query optimization and processing in off-the-shelf database systems is often
still focussed on individual queries. The queries are analysed in isolation
and ran against a kernel regardless opportunities offered by concurrent or
previous invocations.

This approach is far from optimal and two directions to improve
are explored: materialized views and (partial) result-set reuse.
Materialized views are derived from query logs. They represent
common sub-queries, whose materialization improves
subsequent processing times.
Re-use of (partial) results is used in those cases where a
zooming-in or navigational application is at stake.

The Recycler optimizer and module extends this with a middle out approach.
They exploits the materialize-all-intermediate approach of MonetDB
by deciding to keep a hold on them as long as deemed benificial.

The approach taken is to mark the instructions in a MAL program
using the recycler optimizer call, such that their result is retained
in a global recycle cache hardwired in the MAL interpreter.
Instructions become subject to the Recycler if
at least one of its arguments is a BAT and all others are
either constants or variables already known in the Recycler.

Upon execution, the recycler is called from the innerloop
of the MAL interpreter to first check for
an up-to-date result to be picked up at no cost.
Otherwise, it evaluates the instruction and calls upon
policy functions to decide if it is worthwhile to keep.

The Recycler comes with a few policy controlling operators
to experiment with its effect in concrete settings.
The retain policy controls when to keep results around,o
the reuse policy looks after exact duplicate instructions
or uses semantic knowledge on MAL instructions to detect
potential reuse gain (e.g. reuse select results).
And finally, the cache policy looks after the storage space for the 
intermediate result pool.
The details are described in the recycle module.
@{
@mal
pattern optimizer.recycle():str
address OPTrecycle;
pattern optimizer.recycle(mod:str, fcn:str):str
address OPTrecycle
comment "Replicator code injection";

@-
The number of overloaded instructions is kept to a minimum.
@h
#ifndef _OPT_RECYCLER_
#define _OPT_RECYCLER_
#include "opt_prelude.h"
#include "opt_support.h"

/* #define DEBUG_OPT_RECYCLER */
@-
The variables are all checked for being eligible as a variable
subject to recycling control. A variable my only be assigned
a value once. The function is a sql.bind(-,-,-,0) or all arguments
are already recycle enabled or constant.

The arguments of the function can not be recycled.
They change with each called. This does not mean
that the instructions using them can not be a
target of recycling.

Just looking at a kept result target is not good enough.
You have to sure that the arguments are also the same.
This outrules function arguments.

The recycler is targeted towards a query only database.
Any update statement invalidates the recycle cache at
the end of the query. Moreover, it does not perform
any cach lookup.
@c
#include "mal_config.h"
#include "opt_recycler.h"
#include "mal_instruction.h"

static int
OPTrecycleImplementation(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	int i, j, cnt, actions=0, update=0;
	Lifespan span;
	InstrPtr *old, q;
	int limit, updstmt = 0;
	char *recycled;
	short app_sc=-1,app_tbl =-1;

	(void) cntxt;
	(void) stk;
	/* watch out, instructions may introduce new variables */
	limit= mb->stop;
	old = mb->stmt;

	for (i = 1; i<limit; i++) {
		p = old[i];
		if( getFunctionId(p) == affectedRowsRef && getModuleId(p)==sqlRef)
			updstmt = 1;
	}

	recycled= GDKzalloc(sizeof(char)*mb->vtop*2);
	span= newLifespan(mb);
	setLifespan(mb,span);
	newMalBlkStmt(mb, mb->ssize);
	pushInstruction(mb,old[0]);

	/* create a handle for recycler */
	q= newFcnCall(mb,"recycle","prelude");
	for (i = 1; i<limit; i++) {
		p = old[i];
		if (hasSideEffects(p,TRUE) || isUnsafeFunction(p)){
			if( getModuleId(p)== recycleRef ){ /*don't inline recycle instr. */
				freeInstruction(p);
				continue;
			}
			pushInstruction(mb,p);
				/*  update instructions are not recycled but monitored*/
			if( isUpdateInstruction(p)){
				if (getModuleId(p) == batRef &&
					(getArgType(mb,p,1)==TYPE_bat
					|| isaBatType(getArgType(mb, p,1)))){
					recycled[getArg(p,1)]= 0;
					q= newFcnCall(mb,"recycle","reset");
					pushArgument(mb,q, getArg(p,1));
					update++;
				}
				if (getModuleId(p) == sqlRef){
					if (getFunctionId(p) == appendRef){
						app_sc = getArg(p,1);
						app_tbl = getArg(p,2);
					} else {
						q= newFcnCall(mb,"recycle","reset");
						pushArgument(mb,q, getArg(p,1));
						pushArgument(mb,q, getArg(p,2));
						if (getFunctionId(p) == updateRef)
							pushArgument(mb,q, getArg(p,3));
					}
					update++;
				}
			}
			continue;
		}
		if (p->barrier  && p->token != CMDcall){
			/* never save a barrier unless it is a command and side-effect free */
			pushInstruction(mb,p);
			continue;
		}

		if (updstmt){
			if( p->token== ENDsymbol){
				if ( app_sc >= 0 ){
					q= newFcnCall(mb,"recycle","reset");
					pushArgument(mb,q, app_sc);
					pushArgument(mb,q, app_tbl);
				}
				(void) newFcnCall(mb,"recycle","epilogue");
			}
			pushInstruction(mb,p);
			continue;
		} 


		cnt = 0;
		for (j=p->retc; j<p->argc; j++)
			if(recycled[getArg(p,j)] || isVarConstant(mb, getArg(p,j)) )
				cnt++;
		if (cnt == p->argc-p->retc) {
#ifdef DEBUG_OPT_RECYCLER  
			stream_printf(cntxt->fdout,"recycle instruction\n");
			printInstruction(cntxt->fdout,mb, 0, p,LIST_MAL_ALL);
#endif
			actions ++;
			p->recycle = -1; /* this instruction is to be monitored */
			for (j= 0; j < p->retc; j++)
				if (getLastUpdate(span, getArg(p,j)) == i)
					recycled[getArg(p,j)] = 1;
		}
@-
The expected gain is largest if we can re-use selections
on the base tables in SQL. These, however, are marked as
uselect() calls, which only produces the oid head.
For cheap types we preselect using select() and re-map uselect() back 
over this temporary.
For the time being for all possible selects encountered
are marked for re-use.

@c
		/* take care of semantic driven recyling */
		if(( getFunctionId(p)== selectRef || 
		     getFunctionId(p)== antiuselectRef ||
		     getFunctionId(p)== putName("like",4) || 
		     getFunctionId(p)== putName("like_uselect",12) ||
             getFunctionId(p)== putName("thetaselect",11) ||
             getFunctionId(p)== putName("thetauselect",12) ) &&
	      	    recycled[getArg(p,1)] ){
			p->recycle = -1;
			if (getLastUpdate(span, getArg(p,0)) == i)
				recycled[getArg(p,0)] = 1;
		}
		if( getFunctionId(p)== uselectRef && recycled[getArg(p,1)]) {
			if (!ATOMvarsized( getGDKType( getArgType(mb,p,2)))) { 
				q = copyInstruction(p);
				getArg(q,0)= newTmpVariable(mb,TYPE_any); 
				setFunctionId(q, selectRef); 
				q->recycle = -1;
				recycled[getArg(q,0)] = 1;
				pushInstruction(mb,q);
				getArg(p,1) = getArg(q,0);
				setFunctionId(p,markTRef);
				p->argc = 2;
			}
			p->recycle = -1; 
			if (getLastUpdate(span, getArg(p,0)) == i)
				recycled[getArg(p,0)] = 1;
		}

		if(getModuleId(p) == pcreRef) {
			if (( getFunctionId(p)== selectRef && recycled[getArg(p,2)]) ||  
			    ( getFunctionId(p)== uselectRef && recycled[getArg(p,2)])){
				p->recycle = -1;
				if (getLastUpdate(span, getArg(p,0)) == i)
				recycled[getArg(p,0)] = 1;
			}
		}
@-
The sql.bind instructions should be handled carefully
The delete and update BATs should not be recycled,
because they may lead to view dependencies that later interfere
with the transaction commits.
@c
		if (getModuleId(p)== sqlRef && 
			((	getFunctionId(p)==bindRef && 
				getVarConstant(mb, getArg(p,4)).val.ival != 0) ||
			getFunctionId(p)== binddbatRef) ) {
				recycled[getArg(p,0)]=0;
				p->recycle = 0; /* this instruction is not monitored */
			}

		if( p->token== ENDsymbol){
			(void) newFcnCall(mb,"recycle","epilogue");
		}
		pushInstruction(mb,p);
	}
	if (actions && update==0)
		mb->version = -1;	/* will trigger the recycler runtime support */
	GDKfree(span);
	GDKfree(old);
	GDKfree(recycled);
	return actions;
}
@include optimizerWrapper.mx
@h
@:exportOptimizer(recycle)@
#endif
@c
#include "opt_statistics.h"
@:wrapOptimizer(recycle,OPT_CHECK_TYPES)@
@}
