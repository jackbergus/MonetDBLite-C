@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
@' Copyright August 2008-2009 MonetDB B.V.
@' All Rights Reserved.

@f opt_prejoin
@- Prejoin heuristics
In out of memory situations the algorithms to implement e.g. joins
are sup-optimal and should use a pre-sorting on the tail.
There are several ways to inject this code into the kernel,
e.g. replace the join by the radix joins.

The simple solution chosen here is post-patch the MAL programs
with the potentional blocking cluster operations.
@{
@mal
pattern optimizer.prejoin():str
address OPTprejoin;
pattern optimizer.prejoin(mod:str, fcn:str):str
address OPTprejoin
comment "Dead code optimizer";
command algebra.prejoin(a:bat[:oid,:oid],b:bat[:oid,:any_1])(c:bat[:oid,:oid],d:bat[:oid,:any_1])
address ALGprejoin
comment "Recluster the table to reduce random access behavior.";
@h
#ifndef _OPT_PREJOIN_
#define _OPT_PREJOIN_
#include "mal.h"
#include "opt_prelude.h"
#include "opt_support.h"
#include "mal_interpreter.h"
#include "mal_instruction.h"
#include "mal_function.h"

/* #define DEBUG_OPT_PREJOIN      trace its behavior */

@c
#include "mal_config.h"
#include "opt_prejoin.h"
#include "math.h"
@-
The prejoin implementation should only become active if we
expect that we may end up with an IO access for each
possible lookup.
@c
str
ALGprejoin(int *rl, int *rr, int *l, int *r){
	BAT *bl,*br,*bn;
	BUN lpages, rpages;

	*rl = *rr = 0;
	if( (bl= BATdescriptor(*l)) == NULL ){
		throw(MAL, "algebra.prejoin", "Cannot access descriptor");
	}
	if( (br= BATdescriptor(*r)) == NULL ){
		BBPreleaseref(bl->batCacheid);
		throw(MAL, "algebra.prejoin", "Cannot access descriptor");
	}
	lpages= (bl->H->heap.size + bl->T->heap.size)/MT_pagesize();
	rpages= (br->H->heap.size + br->T->heap.size)/MT_pagesize();

	if( bl->batPersistence != TRANSIENT || 	/* no change in persistent */
		BATtordered(bl) ||		/* ordered tails are fine */
		bl->batSharecnt ||		/* avoid dependent views */
		rpages + lpages <= GDKmem_inuse()/MT_pagesize()  ||	/* small operands are ok*/
		BATcount(bl) < 2* rpages * log(rpages)){
		BBPkeepref(*rl = bl->batCacheid);
		BBPkeepref(*rr = br->batCacheid);
		return MAL_SUCCEED;
	}
	ALGODEBUG{
	stream_printf(GDKout,"Prejoin tuples=" BUNFMT "pages" BUNFMT "," BUNFMT"\n",
		BATcount(bl), lpages, rpages);
	}
	bn= BATmirror(BATsort(BATmirror(bl)));
	BBPkeepref(*rr = br->batCacheid);
	BBPkeepref(*rl = bn->batCacheid);
	BBPreleaseref(bl->batCacheid);
	return MAL_SUCCEED;
}

static int 
OPTprejoinImplementation(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	int i, limit;
	InstrPtr q, p=0, *old= mb->stmt;
	int actions = 0;

	(void) pci;
	(void) stk;		/* to fool compilers */

#ifdef DEBUG_OPT_PREJOIN
	stream_printf(cntxt->fdout,"ENTERING prejoin injection\n");
	printFunction(cntxt->fdout,mb,0,LIST_MAL_ALL);
#else
	(void) cntxt;
#endif

	limit= mb->stop;
	newMalBlkStmt(mb, mb->ssize); /* a new statement stack */

	pushInstruction(mb, old[0]);
	for (i = 1; i < limit; i++) {
		p= old[i];
		if( getModuleId(p)== algebraRef && getFunctionId(p)== joinRef &&
			getHeadType(getArgType(mb,p,1)) == TYPE_oid  &&
			getTailType(getArgType(mb,p,1)) == TYPE_oid ){
			q= newStmt(mb,algebraRef, "prejoin");
			setArgType(mb,q,0,getArgType(mb,p,1));
			q= pushArgument(mb,q,newTmpVariable(mb, getArgType(mb,p,2)));
			q->retc++;
			q= pushArgument(mb,q,getArg(p,1));
			q= pushArgument(mb,q,getArg(p,2));
			getArg(p,1)= getArg(q,0);
			getArg(p,2)= getArg(q,1);
			actions++;
		} 
		pushInstruction(mb,p);
	}
	/* we may have uncovered new use-less operations */
	OPTDEBUG
	if ( actions)
		stream_printf(cntxt->fdout,"#opt_prejoin: %d statements removed\n",
			actions);
	chkProgram(cntxt->nspace,mb);
#ifdef DEBUG_OPT_PREJOIN
	stream_printf(cntxt->fdout,"LEAVING prejoin code injection\n");
	printFunction(cntxt->fdout,mb,0,LIST_MAL_ALL);
#endif
	GDKfree(old);
	return actions;
}
@include optimizerWrapper.mx
@h
@:exportOptimizer(prejoin)@
#endif
@c
#include "opt_statistics.h"
@:wrapOptimizer(prejoin,OPT_CHECK_ALL)@
@}
