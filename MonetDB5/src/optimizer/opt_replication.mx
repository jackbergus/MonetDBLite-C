@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
@' Copyright August 2008-2009 MonetDB B.V.
@' All Rights Reserved.

@f opt_replication
@- Database replication
The replication optimizer supports distribution of the 
updates on an SQL database to be distributed over multiple
destination databases.
It initiates the code to prepare simple MAL-log files.

Further details are given in the replication module code.
@{
@mal
pattern optimizer.replication():str
address OPTreplication;
pattern optimizer.replication(mod:str, fcn:str):str
address OPTreplication
comment "Replication optimizer";
@h
#ifndef _OPT_REPLICATOR_
#define _OPT_REPLICATOR_
#include "opt_prelude.h"
#include "opt_support.h"
#include "mal_interpreter.h"
#include "mal_instruction.h"

/* #define DEBUG_REPLICATOR      trace its behavior */

@c
#include "mal_config.h"
#include "opt_prelude.h"
#include "opt_replication.h"

static int 
OPTreplicationImplementation(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	int i, tag, limit, slimit, actions= 0;
	InstrPtr q, p=0, *old= mb->stmt;

	(void) pci;
	(void) stk;		/* to fool compilers */
	(void) cntxt;

	if ( !GDKgetenv_isyes("replication_master") )
		return 0;
	limit= mb->stop;
	slimit = mb->ssize;
	newMalBlkStmt(mb, mb->ssize * 1.2); /* a new statement stack */

	pushInstruction(mb, old[0]);
	p= newStmt(mb, putName("master",6), openRef);
	tag = getArg(p,0);

	for (i = 1; i < limit ; i++){
		p= old[i];
		if ( p->token == ENDsymbol)
			break;
		pushInstruction(mb, p);
		/* full size BAT append */
		if (getModuleId(p)==sqlRef &&  
			getFunctionId(p) == appendRef &&
			isaBatType(getArgType(mb,p,4)) ){
			q= copyInstruction(p);
			clrFunction(q);
			setModuleId(q, putName("master",6));
			setFunctionId(q, appendRef);
			pushInstruction(mb,q);
			pushArgument(mb,q,tag);
			actions++;
		} else 
		/* single value insert */
		if (getModuleId(p)==sqlRef &&  
			getFunctionId(p) == appendRef  ){
			q= copyInstruction(p);
			clrFunction(q);
			setModuleId(q, putName("master",6));
			setFunctionId(q, appendRef);
			pushInstruction(mb,q);
			pushArgument(mb,q,tag);
			actions++;
		} 
		/* delete stuff */
		if (getModuleId(p)==sqlRef &&  
			getFunctionId(p) == deleteRef) {
			q= copyInstruction(p);
			clrFunction(q);
			setModuleId(q, putName("master",6));
			setFunctionId(q, deleteRef);
			pushInstruction(mb,q);
			pushArgument(mb,q,tag);
			actions++;
		} 
	}

	if ( actions) {
		q = newStmt(mb, putName("master",6), closeRef);
		pushArgument(mb,q,tag);
	}
	for (; i < limit ; i++)
		pushInstruction(mb, old[i]);

	for(; i<slimit; i++)
		if( old[i])
			freeInstruction(old[i]);
	GDKfree(old);
	return actions;
}
@include optimizerWrapper.mx
@h
@:exportOptimizer(replication)@
#endif
@c
#include "opt_statistics.h"
@:wrapOptimizer(replication,OPT_CHECK_ALL)@
@}
