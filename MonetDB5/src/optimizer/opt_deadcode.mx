@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2008 CWI.
@' All Rights Reserved.

@f opt_deadcode
@- Dead Code Removal
Dead code fragments are recognized by assignments to variables
whose value is not consumed any more. 
It can be detected  by marking all variables used as 
arguments as being relevant. 
In parallel, we built a list of instructions that should appear 
in the final result.
The new code block is than built in one scan, discarding the
superflous instructions.

Instructions that produce side effects to the environment, 
e.g., printing and BAT updates, should be taken into account. 
Such (possibly recursive) functions should be marked with a property 
(@sc{unsafe}). For now we recognize a few important ones
Likewise, instructions marked as control flow instructions should be retained.

An illustrative example is the following MAL snippet:
@verbatim
	V7 := bat.new(:oid,:int);
	V10 := bat.new(:int,:oid);
	V16 := algebra.markH(V7);
	V17 := algebra.join(V16,V7);
	V19 := bat.new(:oid,:int);
	V22 := bat.new(:oid,:int);
	V23 := algebra.join(V16,V22);
	io.print("done");
	optimizer.deadCodeRemoval();
@end verbatim
The dead code removal trims this program to the following short block:
@verbatim
	io.print("done");
@end verbatim

A refinement of the dead code comes from using arguments
that ceased to exist due to actions taken by an optimizer.
For example, in the snippet below the @sc{pushranges} optimizer
may conclude that variable V31 becomes empty and simply
injects a 'dead' variable by dropping the assignment statement.
This makes other code dead as well.
@example
	V30 := algebra.select( V7, 10,100);
	V31 := algebra.select(V30,-1,5);
	V32 := aggr.sum(V31);
	io.print(V32);
@end example
[implementation pending]
@{
@mal
pattern optimizer.deadcode():str
address OPTdeadcode;
pattern optimizer.deadcode(mod:str, fcn:str):str
address OPTdeadcode
comment "Dead code optimizer";
@h
#ifndef _OPT_DEADCODE_
#define _OPT_DEADCODE_
#include "opt_prelude.h"
#include "opt_support.h"
#include "mal_interpreter.h"
#include "mal_instruction.h"
#include "mal_function.h"

/* #define DEBUG_OPT_DEAD      trace its behavior */

@c
#include "mal_config.h"
#include "opt_deadcode.h"

static int 
OPTdeadcodeImplementation(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	int i, k, se,limit, slimit;
	InstrPtr p=0, *old= mb->stmt;
	int actions = 0;

	(void) pci;
	(void) stk;		/* to fool compilers */

	if (varGetProp(mb, getArg(mb->stmt[0], 0), inlineProp) != NULL)
		return 0;

#ifdef DEBUG_OPT_DEAD
	stream_printf(GDKout,"ENTERING DEAD CODE ELIMINATION\n");
	printFunction(GDKout,mb,LIST_MAL_ALL);
#endif

	clrDeclarations(mb);
	chkDeclarations(mb);
	limit= mb->stop;
	slimit = mb->ssize;
	newMalBlkStmt(mb, mb->ssize); /* a new statement stack */

	pushInstruction(mb, old[0]);
	for (i = 1; i < limit; i++) {
		p= old[i];

		se = p->token == ENDsymbol;
		if( se){
			pushInstruction(mb,p);
			for(i++; i<limit; i++)
			if(old[i])
				pushInstruction(mb,old[i]);
			break;
		}
		if( p->token != NOOPsymbol)
		for (k = 0; k < p->retc; k++)
			if( isVarUsed(mb,getArg(p,k)) ){
				se++;
				break;
			} 

		if( getModuleId(p)== sqlRef && getFunctionId(p)== assertRef &&
			isVarConstant(mb,getArg(p,1)) && getVarConstant(mb,getArg(p,1)).val.ival==0){
			freeInstruction(p);
			actions++;
		} else
		if (se || hasSideEffects(p, FALSE) || !isLinearFlow(p) || isProcedure(mb,p) )
			pushInstruction(mb,p);
		else {
			freeInstruction(p);
			actions++;
		}
	}
	/* we may have uncovered new use-less operations */
	if (actions) 
		actions += OPTdeadcodeImplementation(mb, stk, pci);
#ifdef DEBUG_OPT_DEAD
	stream_printf(GDKout,"LEAVING DEAD CODE ELIMINATION\n");
	printFunction(GDKout,mb,LIST_MAL_ALL);
#endif
	for(; i<slimit; i++)
		if( old[i])
			freeInstruction(old[i]);
	GDKfree(old);
	return actions;
}
@include optimizerWrapper.mx
@h
@:exportOptimizer(deadcode)@
#endif
@c
#include "opt_statistics.h"
@:wrapOptimizer(deadcode,OPT_CHECK_ALL)@
@}
