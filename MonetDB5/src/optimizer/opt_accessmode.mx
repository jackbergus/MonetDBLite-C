@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2007 CWI.
@' All Rights Reserved.

@f opt_accessmode
@a M. Kersten
@-
@- Access mode optimization
The routine @sc{optimizer.accessmode()} reduces the number of mode changes of
variables to a minimum. Especially setting a BAT to write mode is expensive,
because it often implies creation of a private copy first.

A full implementation is delayed until really needed.
@{
@mal
pattern optimizer.accessmode():str
address OPTaccessmode;
pattern optimizer.accessmode(mod:str, fcn:str):str
address OPTaccessmode
comment "Reduce the number of mode changes.";

@h
#ifndef _MAL_MODES_
#define _MAL_MODES_
#include "opt_prelude.h"
#include "opt_support.h"

/* #define DEBUG_OPT_MODES     show partial result */

#endif
@-
The implementation strategy is currently quite simple.
We make a scan to identify all setWriteModes and see if
they are later indeed to target of a function with side
effects.
We should also remember the BATs that are already been set
writable, to avoid subsequent calls.[todo]
In a second pass we can then remove/keep them upon need.
@c
#include "mal_config.h"
#include "opt_accessmode.h"
#include "mal_interpreter.h"

static int
OPTaccessmodeImplementation(MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	int i, j, k;
	int actions = 0;
	InstrPtr *candidate;
	int *writeable;
	int top=0;
	(void) stk;

	candidate= (InstrPtr*) alloca(sizeof(InstrPtr) * mb->stop);
	writeable= (int*) alloca(sizeof(int) * mb->vtop);
	memset((char *)writeable,0, sizeof(int)*mb->vtop);

	for(i=0; i<mb->stop; i++){
		p= getInstrPtr(mb,i);
		if( getFunctionId(p)== setWriteModeRef && getModuleId(p)== batRef ){
			if( writeable[getArg(p,1)] ){
				writeable[getArg(p,0)]= writeable[getArg(p,1)];
				p->token= ASSIGNsymbol;
				setModuleId(p,NULL);
				setFunctionId(p,NULL);
				p->argc=2;
			} else{
				candidate[top++] = p;
				writeable[getArg(p,0)]= getArg(p,0);
			}
		} else
		if( getModuleId(p)== batRef &&
			( getFunctionId(p) == insertRef ||
			  getFunctionId(p) == deleteRef ||
			  getFunctionId(p) == appendRef ) ){
				for(j=k=0; j<top;j++)
				if( getArg(p,1) != getArg(candidate[j],0) )
					candidate[k++]= candidate[j];
				top= k;
		}
	}
	/* now remove all candidates */
	for( j=0; j<top; j++){
		p= candidate[j];
		/* turn it into an alias */
		setModuleId(p,NULL);
		setFunctionId(p,NULL);
		p->token= ASSIGNsymbol;
		p->argc= 2;
		p->fcn= NULL;
		actions++;
	} 
#ifdef DEBUG_OPT_MODES
	stream_printf(GDKout,"OPTIMIZE MODES\n");
	printFunction(GDKout,mb,LIST_MAL_ALL);
#endif
	return actions;
}
@include optimizerWrapper.mx
@h
@:exportOptimizer(accessmode)@
@c
@:wrapOptimizer(accessmode,OPT_CHECK_ALL)@
@}
