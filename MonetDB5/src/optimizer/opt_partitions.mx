@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2007 CWI.
@' All Rights Reserved.

@f opt_partitions
@a M. Kersten
@- BAT Partitions
Limitations on the addressing space in older PCs and the need
for distributed storage makes that BATs ideally should be 
looked upon as a union of smaller BATs which are processed
within the (memory) resource limitations given.

The @sc{partition()} optimizer with the supportive 
bat partition library @code{bpm}
addresses the issue with an adaptive database segmentation algorithm.
It is designed incrementally with a the focus 
on supporting the SQL front-end. In particularly, the
operators considered is a limited subset of MAL. Occurrence
of an operator outside this set terminates the optimizer
activities.

The operation @sc{optimizer.partitions()} hunts for bindings
of SQL column BATs and prepare code for using partitioned
versions instead.

A walk through of a simplified SQL query plan is shown below.
The first time a column is used, the partition optimizer
checks its properties and marking it for iterative evalation
or expansion using a merge table approach.
The decision is based on the number of partitions involved.
[to be decided]

@verbatim
function user.qry():void;
	b:bat[:oid,:int]:= sql.bind("sys","voyages","captain",0,0);
	t:= algebra.select(b,nil:int,100);
	io.print(t);
	optimizer.partitions();
end qry;
@end verbatim
The query is transformed into a plan that is valid only for one run.
For example, assume we have two partitions only. Then the plan
can be rewritten into:
@example
function user.qry{runonce} ():void
	b:bat[:oid,:int]:= sql.bind("sys","voyages","captain",0,0);
	bm:= bpm.take("sys_voyages_captain")
	(b0,b1):= bpm.getPartitions(bm);
	mbm:= mat.new(b0,b1);
	t:= algebra.select(mbm,nil:int,100);
	io.print(t);
end qry;
@end example
The translation ignored the boundaries for the partitions,
which might be handy for symbolic optimization.
Furthermore, it can prune one partition as not being relevant.
@example
function user.qry{runonce} ():void
	b:bat[:oid,:int]:= sql.bind("sys","voyages","captain",0,0);
	bm:= bpm.take("sys_voyages_captain")
	b0:= bpm.getPartition(bm,0);
	t:= algebra.select(b0,0,100);
	io.print(t);
end qry;
@{
@mal
pattern optimizer.partitions():str
address OPTpartitions;
pattern optimizer.partitions(mod:str, fcn:str):str
address OPTpartitions
comment "Experiment with partitioned databases";
@h
#ifndef _OPT_PARTITIONED_
#define _OPT_PARTITIONED_
#include "opt_prelude.h"
#include "opt_support.h"

#define DEBUG_OPT_PARTITIONED	/* show partial result */
#endif
@c
#include "mal_config.h"
#include "opt_partitions.h"
#include "mal_interpreter.h"	/* for showErrors() */

extern int OPTvalidFlowNetwork(MalBlkPtr mb, int *first, int *last, int varid);
@-
The first implementation takes a query block and replaces the first
bat variable with its partitions equivalent.
The external references should be adjusted to permit working
your way through the complete graph incrementally.
They denote an inclusive range.
A copy of the program block is made by default. This could be
optimized away later.
@c
static str
OPTreplacement(MalBlkPtr mb, int *first, int *last, int varid)
{
	InstrPtr *old, p;
	int i, limit, actions = 0;
	int idx = -1, bid = -1;
	int pcf, pcl;
	lng clk= GDKusec();

	setLifespan(mb);
	old = mb->stmt;

	limit = mb->stop;
	newMalBlkStmt(mb, limit + 10);
#ifdef DEBUG_OPT_PARTITIONED
	stream_printf(GDKout, "variable replacement '%s'", getVarName(mb, varid));
	stream_printf(GDKout, " instructions %d-%d ", *first, *last);
	stream_printf(GDKout, " lifespan %d-%d\n", mb->var[varid]->beginLifespan, mb->var[varid]->endLifespan);
#endif
	/* copy prelude into place */
	for (i = 0; i < *first; i++)
		pushInstruction(mb, old[i]);

	actions++;
	/* barrier (idx,bid):= bpm.newIterator(var); */
	p = newInstruction(mb,ASSIGNsymbol);
	setModuleId(p, putName("bpm", 10));
	setFunctionId(p, putName("newIterator", 11));
	p->barrier = BARRIERsymbol;
	idx = newTmpVariable(mb, TYPE_int);
	pushReturn(mb, p, idx);
	bid = newTmpVariable(mb, getVarType(mb, varid));
	pushReturn(mb, p, bid);
	pushArgument(mb, p, varid);
	pushInstruction(mb, p);

	pcf = mb->stop;
	for (i = *first; i <= *last; i++)
		pushInstruction(mb, old[i]);
	pcl = mb->stop;
@-
Before we finalize, we should also check all operations for being applicable 
to partitions as well. Where necessary they should be replaced by an
accumulated version.
@c
	/* finalize the loop */
	/* redo (idx,bid):= bpm.hasMoreElements(var); */
	p = newInstruction(mb,REDOsymbol);
	setModuleId(p, putName("bpm", 10));
	setFunctionId(p, putName("hasMoreElements", 15));
	pushReturn(mb, p, idx);
	pushReturn(mb, p, bid);
	pushArgument(mb, p, varid);
	pushInstruction(mb, p);
	/* exit (idx,bid) */
	p = newInstruction(mb,EXITsymbol);
	pushReturn(mb, p, idx);
	pushReturn(mb, p, bid);
	pushInstruction(mb, p);

	*first = mb->stop;
	/* copy the rest of the program back into place */
	for (; i < limit; i++)
		pushInstruction(mb, old[i]);
	GDKfree(old);
	*last = mb->stop - 1;

	/* now replace variable with the alias bid */
	if (bid != -1)
		replaceAlias(mb, pcf, pcl, varid, bid);
	/* and have to check the baked program */
	optimizerCheck(mb,"partitions",1,GDKusec()-clk,OPT_CHECK_ALL);
	return MAL_SUCCEED;
}
@-
Not all BATs call for iterator expansion. Unfortunately
we can not check this always at compile time, because
we need the actual BAT identifier.  Therefor the user should
supply the variable instead.
We
@c
static str
OPTneedsExpansion(MalBlkPtr mb, int varid)
{
	int tpe;
	int first, last;
	str msg = 0;

	tpe = getVarType(mb, varid);
	if (isaBatType(tpe) && getHeadType(tpe) == TYPE_oid) {
		first = 1;
		last = mb->stop - 2;
		printf("start first=%d last=%d \n", first, last);
		for (; first < mb->stop && last < mb->stop;) {
			if (OPTvalidFlowNetwork(mb, &first, &last, varid)) {
				printf("replace first=%d last=%d \n", first, last);
				msg = OPTreplacement(mb, &first, &last, varid);
				if (msg)
					return msg;
			} else {
				first = last;
				last = mb->stop - 1;
			}
			printf("first=%d last=%d \n", first, last);
		}
	}
	return MAL_SUCCEED;
}

@-
Calling the optimizer from the MAL context is currently
focussed on replacing the BAT arguments only.
@c
static int
OPTpartitionsImplementation(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	int i;
	InstrPtr p;

	(void) stk;
	(void) pci;

	p = getInstrPtr(mb, 0);
	for (i = p->retc; i < p->argc; i++) {
		OPTneedsExpansion(mb, p->argv[i]);
	}
	return 0; /* optimizer administration alread handled */
}

@}
@-
The translation of a MAL block into a multi-iterator only works if
the network flow is simple, i.e there exists a 'single' sink, 
or all the information is compressed
into variables that are passed back to the caller as a single value,
or is sent non-interupted to the output channels.
The bottom-line is to avoid expansion.
An assignment to the target is not allowed [to be checked separately]
@{
The validFlowNetwork searches the next basic block to
be considered as safe to expand. It first skips to the
next instruction that uses the variable mentioned.
@c
int
OPTvalidFlowNetwork(MalBlkPtr mb, int *first, int *last, int varid)
{
	int i, k = 0, iocount = 0;
	InstrPtr p;

	for (i = *first; i <= *last; i++) {
		p = getInstrPtr(mb, i);
		for (k = 0; k < p->retc; k++)
			if (getArg(p, k) == varid) {
				*first = i + 1;
				return 0;
			}
		for (k = p->retc; k < p->argc; k++)
			if (getArg(p, k) == varid)
				break;
		if (k < p->argc)
			break;
		if (i == *last) {
			*last = mb->stop;
			return 0;
		}
	}
	*first = i;
	for (; i <= *last; i++) {
		p = getInstrPtr(mb, i);
		if (getFunctionId(p) && strncmp(getFunctionId(p), "print", 5) == 0)
			iocount++;
		else if (p->barrier)
			iocount++;
		else if (p->token == ENDsymbol)
			iocount++;
		if (iocount > 1) {
			*last = i - 1;
			return TRUE;
		}
	}
	return iocount > 0;
}

@include optimizerWrapper.mx
@h
@:exportOptimizer(partitions)@
@c
@:wrapOptimizer(partitions,OPT_CHECK_ALL)@
@}
