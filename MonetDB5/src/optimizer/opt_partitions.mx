@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2007 CWI.
@' All Rights Reserved.

@f opt_partitions
@a M. Kersten
@- BAT Partitions
Limitations on the addressing space in older PCs and the need
for distributed storage makes that BATs ideally should be 
looked upon as a union of smaller BATs which are processed
within the (memory) resource limitations given.

The @sc{partition()} optimizer with the supportive 
bat partition library @code{bpm}
addresses the issue with an adaptive database segmentation algorithm.
It is designed incrementally with a focus 
on supporting the SQL front-end. In particularly, the
operators considered is a limited subset of MAL. Occurrence
of an operator outside this set terminates the optimizer
activities.

The operation @sc{optimizer.partitions()} hunts for bindings
of SQL column BATs and prepare code for using partitioned
versions instead.

A walk through of a simplified SQL query plan is shown below.
@verbatim
function user.qry():void;
	b:bat[:oid,:int]:= sql.bind("sys","voyages","captain",0,0);
	t:= algebra.select(b,nil:int,100);
	io.print(t);
	optimizer.partitions();
end qry;
@end verbatim
[OBSOLETE]
The query is transformed into a plan that is valid only for one run.
For example, assume we have two partitions only. Then the plan
can be rewritten into:
@example
function user.qry{runonce} ():void
	b:bat[:oid,:int]:= sql.bind("sys","voyages","captain",0,0);
	b0:bat[:oid,:int]:= bpm.take("sys_voyages_captain",0);
	b1:bat[:oid,:int]:= bpm.take("sys_voyages_captain",1);
	mbm:= mat.new(b0,b1);
	t:= algebra.select(mbm,nil:int,100);
	io.print(t);
end qry;
@end example
The translation ignored the boundaries for the partitions,
which might be handy for symbolic optimization.
One way to make this known is with a (dummy) select operation,
i.e. its execution is cheap.
@example
function user.qry{runonce} ():void
	b:bat[:oid,:int]:= sql.bind("sys","voyages","captain",0,0);
	bm:bat[:oid,:int]:= bpm.take("sys_voyages_captain")
	b0:= bpm.getPartition(bm,0);
	b1:= bpm.select(b0, 500,1000);
	t:= algebra.select(b1,0,100);
	io.print(t);
end qry;
@end example
This code can be optimized away using the range-optimizer.
@{
@mal
pattern optimizer.partitions():str
address OPTpartitions;
pattern optimizer.partitions(mod:str, fcn:str):str
address OPTpartitions
comment "Experiment with partitioned databases";
@h
#ifndef _OPT_PARTITIONED_
#define _OPT_PARTITIONED_
#include "opt_prelude.h"
#include "opt_support.h"

/*#define DEBUG_OPT_PARTITIONED	show partial result */
#endif
@c
#include "mal_config.h"
#include "opt_partitions.h"
#include "mallist.h"
#include "mal_interpreter.h"	/* for showErrors() */

@-
Calling the optimizer from the MAL context currently
assumes that all sql.bind operations references partitioned BATs.
We mark the segments derived from a single partitioned bat group.
This continues until we find a blocking operator
that requires the results of multiple threads.
Then we have to close the iterator block and gather the results.
@c
static int localVar(MalBlkPtr mb, char *prefix, int idx, int tpe){
	char name[256];
	snprintf(name,256,"%s%d",prefix,idx);

	idx=findVariable(mb,name);
	if( idx >= 0) return idx;
	return newVariable(mb,GDKstrdup(name),tpe);
}

static int
OPTpartitionProperties(MalBlkPtr mb)
{
	int i,j,k,done,limit, grp= 1;
	InstrPtr *old,p, mat[256];
	int tmp[256];
	int lastsegment=0;

	limit= mb->stop;
	old = mb->stmt;
	newMalBlkStmt(mb,limit);

	for(i=0;i< limit; i++){
		p=old[i];
		if( getFunctionId(p)== bindRef && getModuleId(p)==sqlRef){
			/* test the BPM catalog */

			setArgProperty(mb, p,0,"segment","=",TYPE_int,&grp);
			mat[grp] = p;
			tmp[grp] = getArg(p,0);
			grp++;
			pushInstruction(mb,p);
			lastsegment=0;
			continue;
		}
		if( getModuleId(p)== constraintsRef){
			/* this BAT can be ignored */
			j= -1;
			setArgProperty(mb, p,1,"segment","=",TYPE_int,&j);
			pushInstruction(mb,p);
			continue;
		}
		/* find competing fragmentation groups */
		done=0;
		if( isFragmentGroup(p) ){
			for(j=p->retc; j<p->argc; j++)
			if( isPropertyDefined(getProps(mb,getArg(p,j)),"segment")){
				k= *(int*) getPropertyValue(getProps(mb,getArg(p,j)),
									"segment");
				if( tmp[k] == getArg(p,j) )
					tmp[k]= getArg(p,0);
				done++;
			}
			if( done == 0) {
				pushInstruction(mb,p);
				continue;
			}
			if( done>1 )
				done= grp;
			else done =k;
			/* mark all result variables to belong to the same segment */
			for(j=0; j<p->retc; j++){
			if( isaBatType(getVarType(mb, getArg(p,j))) )
				setArgProperty(mb, p,j,"segment","=",TYPE_int,&done);
			}
			pushInstruction(mb,p);
			lastsegment=0;
			continue;
		} 
@-
We have encountered a non-fragment statement. It is assigned to its
own segment.
@c
		if( lastsegment==0)
			lastsegment= ++grp;
		/* mark all result variables to belong to the same segment */
		for(j=0; j<p->retc; j++){
			setArgProperty(mb, p,j,"segment","=",TYPE_int,&lastsegment);
		}
		pushInstruction(mb,p);
	}
#ifdef DEBUG_OPT_PARTITIONED
	setLifespan(mb);
	chkProgram(MCgetClient()->nspace,mb);
	stream_printf(GDKout,"#partition properties\n");
	printFunction(GDKout,mb,LIST_MAL_PROPS);
#endif
	return grp;
}
@-
The naive strategy is to produce a nested iterator block,
which terminates at the resultSet.
@-
Wrap a sequence of MAL instructions with an iterators
to accumulate the result.
@c
static void
OPTpartitionStrategy(MalBlkPtr mb, int last)
{
	int list=0,i,j,limit,lastsegment=0;
	InstrPtr *old,p,q,anchor=NULL;
	int *seg;
	int *alias= (int*) alloca(sizeof(int)*mb->vtop*2);
	char name[1024];
	int TYPE_list= ATOMindex("list");

	memset((char*) alias, 0, sizeof(int)*mb->vtop*2);

	limit= mb->stop;
	old = mb->stmt;
	newMalBlkStmt(mb,limit);

	pushInstruction(mb,old[0]); /* signature */
	for(i=1;i< limit; i++){
		p= old[i];
@-
Skip the instructions that are not affected by partitions
@c
		if( getModuleId(p)== constraintsRef ||
			getModuleId(p)== calcRef){
			pushInstruction(mb,p);
			continue;
		}
		if( getFunctionId(p)== bindRef && getModuleId(p)== sqlRef){
			pushInstruction(mb,p);

			seg= (int*) getPropertyValue(getProps(mb,getArg(p,0)), "segment");
			if( seg && *seg == -1){
				continue;
			}

			/* hdl:= bpm.take(name) */
			q = newStmt(mb,"bpm","take");
			q->argv[0]=
				localVar(mb,"bpm",getArg(p,0), getVarType(mb, getArg(p,0)));
			freezeVarType(mb,q->argv[0]);
			alias[getArg(p,0)]= getArg(q,0);
			snprintf(name,1024,"%s_%s_%s",
				getVarConstant(mb, getArg(p,1)).val.sval,
				getVarConstant(mb, getArg(p,2)).val.sval,
				getVarConstant(mb, getArg(p,3)).val.sval );
			pushStr(mb, q,name);
			continue;
		}
@-
All result variables belong to the same segment, provided
that we do not re-use them 
@c
		seg= (int*) getPropertyValue(getProps(mb,getArg(p,0)), "segment");
		if( seg== 0 ){
			pushInstruction(mb,p);
			continue;
		}
@-
Wrapup the last segment first
@c
		if(seg && *seg!=lastsegment && anchor){
			if( anchor)
			for(j=0; j< old[i-1]->retc; j++){
				q = newStmt(mb,"list","append");
				pushArgument(mb,q,list);
				pushArgument(mb,q,getArg(old[i-1],j));
				alias[getArg(old[i-1],j)]=list;
			}
			for(j=anchor->argc-1; j>=anchor->retc; j--){
				int tpe= getVarType(mb,alias[getArg(anchor,j)]);
				if( tpe != TYPE_list && !isaBatType(tpe))
					continue;
				if(getVarType(mb,alias[getArg(anchor,j)]) == TYPE_list)
					q = newStmt(mb,"list","hasMoreElements");
				else
					q = newStmt(mb,"bpm","hasMoreElements");
				q->barrier= REDOsymbol;
				q->argv[0]= getArg(anchor,j);
				pushArgument(mb, q, alias[getArg(anchor,j)]);
			}

			for(j=anchor->argc-1; j>=anchor->retc; j--){
				int tpe= getVarType(mb,alias[getArg(anchor,j)]);
				if( tpe != TYPE_list && !isaBatType(tpe))
					continue;
				q = newInstruction(mb,EXITsymbol);
				q->barrier= EXITsymbol;
				q->argv[0]= getArg(anchor,j);
				pushInstruction(mb,q);
			}
			anchor=NULL;
		}
		
		if( seg && *seg==last)
		for(j= p->retc; j<p->argc; j++)
		if( alias[getArg(p,j)]!= getArg(p,j) && 
			getVarType(mb,alias[getArg(p,j)]) == TYPE_list){
			q = newStmt(mb,"list","glue");
			q->argv[0]= getArg(p,j);
			pushArgument(mb,q,alias[getArg(p,j)]);
			alias[getArg(p,j)]= getArg(p,j);
			anchor= NULL;
		}
		if( *seg <0 ){
			pushInstruction(mb,p);
			continue;
		}
@-
Create the lists needed for all target variables
and generator the iterators.
@c
		if(*seg!=lastsegment && *seg != last){
			for(j=0; j<p->retc; j++){
				q = newStmt(mb,"list","new");
				list= q->argv[0]=localVar(mb,"L",getArg(p,j), TYPE_list);
				alias[getArg(p,j)]= getArg(q,0);
			}
			for(j=p->retc; j<p->argc; j++){
				int tpe= getVarType(mb,alias[getArg(p,j)]);
				if( tpe != TYPE_list && !isaBatType(tpe))
					continue;
				if(tpe == TYPE_list)
					q = newStmt(mb,"list","newIterator");
				else
					q = newStmt(mb,"bpm","newIterator");
				q->barrier= BARRIERsymbol;
				q->argv[0]= getArg(p,j);
				pushArgument(mb, q, alias[getArg(p,j)]);
			}
			anchor=p;
		}
		lastsegment= *seg;
		pushInstruction(mb,p);
	}
}
static int
OPTpartitionsImplementation(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	lng clk= GDKusec();
	int last;
	(void) stk;
	(void) pci;
	last= OPTpartitionProperties(mb);
	OPTpartitionStrategy(mb,last);
	optimizerCheck(mb,"partitions",1,GDKusec()-clk,OPT_CHECK_ALL);
#ifdef DEBUG_OPT_PARTITIONED
	stream_printf(GDKout,"partition optimizer Strategy\n");
	printFunction(GDKout,mb,0);
#endif
	return 1;
}
@}
@-
The translation of a MAL block into a multi-iterator only works if
the network flow is simple, i.e there exists a 'single' sink, 
or all the information is compressed
into variables that are passed back to the caller as a single value,
or is sent non-interupted to the output channels.
The bottom-line is to avoid expansion.
An assignment to the target is not allowed [to be checked separately]

@include optimizerWrapper.mx
@h
@:exportOptimizer(partitions)@
@c
@:wrapOptimizer(partitions,OPT_CHECK_ALL)@
@}
