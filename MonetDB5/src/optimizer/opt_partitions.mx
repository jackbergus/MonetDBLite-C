@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2007 CWI.
@' All Rights Reserved.

@f opt_partitions
@a M. Kersten
@- BAT Partitions
Limitations on the addressing space in older PCs and the need
for distributed storage makes that BATs ideally should be 
looked upon as a union of smaller BATs which are processed
within the (memory) resource limitations given.

The @sc{partition()} optimizer with the supportive 
bat partition library @code{bpm}
addresses the issue with an adaptive database segmentation algorithm.
It is designed incrementally with a focus 
on supporting the SQL front-end. In particularly, the
operators considered is a limited subset of MAL. Occurrence
of an operator outside this set terminates the optimizer
activities.

The operation @sc{optimizer.partitions()} hunts for bindings
of SQL column BATs and prepare code for using partitioned
versions instead.

A walk through of a simplified SQL query plan is shown below.
@verbatim
function user.qry():void;
	b:bat[:oid,:int]:= sql.bind("sys","voyages","captain",0,0);
	t:= algebra.select(b,nil:int,100);
	io.print(t);
	optimizer.partitions();
end qry;
@end verbatim
[OBSOLETE]
The query is transformed into a plan that is valid only for one run.
For example, assume we have two partitions only. Then the plan
can be rewritten into:
@example
function user.qry{runonce} ():void
	b:bat[:oid,:int]:= sql.bind("sys","voyages","captain",0,0);
	b0:bat[:oid,:int]:= bpm.take("sys_voyages_captain",0);
	b1:bat[:oid,:int]:= bpm.take("sys_voyages_captain",1);
	mbm:= mat.new(b0,b1);
	t:= algebra.select(mbm,nil:int,100);
	io.print(t);
end qry;
@end example
The translation ignored the boundaries for the partitions,
which might be handy for symbolic optimization.
One way to make this known is with a (dummy) select operation,
i.e. its execution is cheap.
@example
function user.qry{runonce} ():void
	b:bat[:oid,:int]:= sql.bind("sys","voyages","captain",0,0);
	bm:bat[:oid,:int]:= bpm.take("sys_voyages_captain")
	b0:= bpm.getPartition(bm,0);
	b1:= bpm.select(b0, 500,1000);
	t:= algebra.select(b1,0,100);
	io.print(t);
end qry;
@end example
This code can be optimized away using the range-optimizer.
@{
@mal
pattern optimizer.partitions():str
address OPTpartitions;
pattern optimizer.partitions(mod:str, fcn:str):str
address OPTpartitions
comment "Experiment with partitioned databases";
@h
#ifndef _OPT_PARTITIONED_
#define _OPT_PARTITIONED_
#include "opt_prelude.h"
#include "opt_support.h"

/* #define DEBUG_OPT_PARTITIONED	show partial result */
@c
#include "mal_config.h"
#include "opt_partitions.h"
#include "mal_interpreter.h"	/* for showErrors() */

@-
Calling the optimizer from the MAL context currently
assumes that all sql.bind operations references partitioned BATs.
We mark the segments derived from a single partitioned bat group.
This continues until we find a blocking operator
that requires the results of multiple threads.
Then we have to close the iterator block and gather the results.
@c
static int localVar(MalBlkPtr mb, char *prefix, int idx, int tpe){
	char name[256];
	snprintf(name,256,"%s%d",prefix,idx);

	idx=findVariable(mb,name);
	if( idx >= 0) return idx;
	return newVariable(mb,GDKstrdup(name),tpe);
}

static void setSegment(MalBlkPtr mb, InstrPtr p, int grp){
	int j;
	for(j=0; j<p->retc; j++){
		setArgProperty(mb, p,j,"segment","=",TYPE_int,&grp);
	}
}

static int
OPTpartitionProperties(MalBlkPtr mb)
{
	int i,j,k,done, lastsegment=0,grp= 1;
	InstrPtr p;
	int *used= (int*) alloca(sizeof(int)*mb->vtop);

	memset((char*) used, 0, sizeof(int)*mb->vtop);
	for(i=0;i<mb->stop; i++){
		p= getInstrPtr(mb,i);
		for(j=p->retc; j<p->argc;j++)
			used[getArg(p,j)]++;
	}

	for(i=0;i< mb->stop; i++){
		p=getInstrPtr(mb,i);
		if( getFunctionId(p)== bindRef && getModuleId(p)==sqlRef){
			/* test the BPM catalog */
			setArgProperty(mb, p,0,"segment","=",TYPE_int,&grp);
			grp++;
			continue;
		}
		if( getModuleId(p)== constraintsRef){
			/* this BAT can be ignored */
			j= -1;
			setArgProperty(mb, p,1,"segment","=",TYPE_int,&j);
			grp++;
			continue;
		}
		/* find plan segments, a linear trail of single target instructions */
		/* mark all result variables to belong to the same segment */
		setSegment(mb,p,grp);

		done=0;
		if( isFragmentGroup(p) && !hasSideEffects(p,TRUE) ){
			for(j=p->retc; j<p->argc; j++)
			if( isPropertyDefined(getProps(mb,getArg(p,j)),"segment")){
				k= *(int*) getPropertyValue(getProps(mb,getArg(p,j)),
									"segment");
				if(done==0)
					done=k;
				if( done!= k)
					goto newgroup;
				if( used[getArg(p,j)]>1)
					goto newgroup;
			}
			if( p->retc==1)
				goto nxtgroup;
		newgroup:
			++grp;
			setSegment(mb,p,grp);
			lastsegment=0;
		} else
		if( !isFragmentGroup(p) ){
			if( lastsegment==0 || 
				getModuleId(p)== batcalcRef ||
				getModuleId(p)== aggrRef)
				lastsegment= ++grp;
			setSegment(mb,p,grp);
		} 
nxtgroup: ;
	}
#ifdef DEBUG_OPT_PARTITIONED
	setLifespan(mb);
	chkProgram(MCgetClient()->nspace,mb);
	stream_printf(GDKout,"#partition properties\n");
	printFunction(GDKout,mb,LIST_MAL_PROPS);
#endif
	return grp;
}
@-
The naive strategy is to produce a nested iterator block,
which terminates at the resultSet.
@-
Wrap a sequence of MAL instructions with an iterators
to accumulate the result.
@c
static void
OPTpartitionStrategy(MalBlkPtr mb, int last)
{
	int i,j,limit,lastsegment=0;
	InstrPtr *old,p,q,anchor=NULL;
	InstrPtr *listanchor= (InstrPtr*) alloca(sizeof(InstrPtr)*mb->vtop);
	int *seg;
	int *alias= (int*) alloca(sizeof(int)*mb->vtop*2);
	int *bpm= (int*) alloca(sizeof(int)*mb->vtop*2);
	char name[1024];

	memset((char*) alias, 0, sizeof(int)*mb->vtop*2);
	memset((char*) bpm, 0, sizeof(int)*mb->vtop*2);
	memset((char*) listanchor, 0, sizeof(InstrPtr)*mb->vtop);

	limit= mb->stop;
	old = mb->stmt;
	newMalBlkStmt(mb,limit);

	pushInstruction(mb,old[0]); /* signature */
	for(i=1;i< limit; i++){
		p= old[i];
@-
Skip the instructions that are not affected by partitions
@c
		if( getModuleId(p)== constraintsRef ||
			getModuleId(p)== calcRef){
			pushInstruction(mb,p);
			continue;
		}
		if( getFunctionId(p)== bindRef && getModuleId(p)== sqlRef){
			pushInstruction(mb,p);

			seg= (int*) getPropertyValue(getProps(mb,getArg(p,0)), "segment");
			if( seg && *seg == -1){
				continue;
			}

			/* hdl:= bpm.take(name) */
			q = newStmt(mb,"bpm","take");
			q->argv[0]=
				localVar(mb,"bpm",getArg(p,0), getVarType(mb, getArg(p,0)));
			freezeVarType(mb,q->argv[0]);
			alias[getArg(p,0)]= getArg(q,0);
			bpm[getArg(p,0)] = 1;
			snprintf(name,1024,"%s_%s_%s",
				getConstant(mb, getArg(p,1)).val.sval,
				getConstant(mb, getArg(p,2)).val.sval,
				getConstant(mb, getArg(p,3)).val.sval );
			pushStr(mb, q,name);
			continue;
		}
@-
All result variables belong to the same segment, provided
that we do not re-use them 
@c
		seg= (int*) getPropertyValue(getProps(mb,getArg(p,0)), "segment");
		if( seg== 0 ){
			pushInstruction(mb,p);
			continue;
		}
@-
Wrapup the last segment first
@c
		if(seg && *seg!=lastsegment && anchor){
			if( anchor)
			for(j=0; j< old[i-1]->retc; j++){
				int tpe;
				q = newStmt(mb,"bpm","addPartition");
				pushArgument(mb,q,getArg(listanchor[j],0));
				pushArgument(mb,q,getArg(old[i-1],j));
				alias[getArg(old[i-1],j)]=getArg(listanchor[j],0);
				tpe= getArgType(mb,old[i-1],j);
				pushArgument(mb,listanchor[j],newTypeVariable(mb,getHeadType(tpe)));
				pushArgument(mb,listanchor[j],newTypeVariable(mb,getTailType(tpe)));
			}
			for(j=anchor->argc-1; j>= anchor->retc; j--)
			if( isaBatType(getArgType(mb,anchor,j)) ){
				q = newStmt(mb, bpmRef, "hasMoreElements");
				q->barrier= REDOsymbol;
				q->argv[0]= getArg(anchor,j);
				pushArgument(mb, q, 
					(alias[getArg(anchor,j)]?alias[getArg(anchor,j)]:getArg(anchor,j)) );
			}

			for(j=anchor->argc-1; j>=anchor->retc; j--)
			if( isaBatType(getArgType(mb,anchor,j)) ){
				q = newInstruction(mb,EXITsymbol);
				q->barrier= EXITsymbol;
				q->argv[0]= getArg(anchor,j);
				pushInstruction(mb,q);
			}
			anchor=NULL;
		}
@-
Blocking operations, such as sorting, aggregation, and
the aligned bat calculations require more care.
@c
		/* remap specific instructions to list versions */
		if( getModuleId(p)==aggrRef  &&
		    getFunctionId(p)== countRef &&
			alias[getArg(p,1)]!= getArg(p,1)  ){
			getModuleId(p)= bpmRef;
			pushInstruction(mb,p);
			if( alias[getArg(p,1)])
				getArg(p,1)= alias[getArg(p,1)];
			continue;
		}
		if( getFunctionId(p) == sortTailRef || 
			getFunctionId(p) ==sortReverseTailRef ||
			getModuleId(p) == aggrRef){
			q = newStmt(mb,"bpm","glue");
			pushArgument(mb,q,alias[getArg(p,1)]);
			p->argv[1]= getArg(q,0);
			alias[getArg(p,0)]= getArg(p,0);
			pushInstruction(mb,p);
			continue;
		}
@-
Batcalc operations all work on the assumption that the
heads are sorted on the heads(oid). If the operands come from
different partitions sequences, we have to take special
care in the iterator.
@c
		if( getModuleId(p)== batcalcRef){
			InstrPtr qa;
			int tpe = getArgType(mb,p,0);
			listanchor[0]= q = newStmt(mb,"bpm","new");
			pushArgument(mb,listanchor[0],newTypeVariable(mb,getHeadType(tpe)));
			pushArgument(mb,listanchor[0],newTypeVariable(mb,getTailType(tpe)));
			
			q = newStmt(mb,"bpm","newIterator");
			q->barrier= BARRIERsymbol;
			for(j=p->retc+1; j<p->argc; j++)
				pushReturn(mb,q,newTmpVariable(mb, TYPE_any));
			for(j=p->retc; j<p->argc; j++)
				pushArgument(mb,q, alias[getArg(p,j)]);

			alias[getArg(p,0)]= getArg(listanchor[0],0);
			for(j=p->retc; j<p->argc; j++)
				getArg(p,j)= getArg(q,j- p->retc);
			pushInstruction(mb,p);

			qa = newStmt(mb,"bpm","addPartition");
			pushArgument(mb,qa,getArg(listanchor[0],0));
			pushArgument(mb,qa,getArg(p,0));

			qa = newStmt(mb, bpmRef, "hasMoreElements");
			qa->barrier= REDOsymbol;
			getArg(qa,0)= getArg(q,0);
			for(j=1;j<q->retc; j++)
				pushReturn(mb,qa,getArg(q,j));
			for(j=q->retc;j<q->argc; j++)
				pushArgument(mb,qa,getArg(q,j));

			qa= newInstruction(mb, EXITsymbol);
			qa->barrier= EXITsymbol;
			getArg(qa,0)= getArg(q,0);
			for(j=1;j<q->retc; j++)
				pushReturn(mb,qa,getArg(q,j));
			pushInstruction(mb,qa);
			continue;
		}
@-
In the last segment we have to glue things together.
@c
		if( seg && *seg==last){
			for(j= p->retc; j<p->argc; j++)
			if( (alias[getArg(p,j)] && alias[getArg(p,j)]!= getArg(p,j)) ){
				q = newStmt(mb,"bpm","glue");
				q->argv[0]= getArg(p,j);
				pushArgument(mb,q,alias[getArg(p,j)]);
				alias[getArg(p,j)]= getArg(p,j);
				anchor= NULL;
			}
		}
		if( *seg <0){
			for(j= p->retc; j<p->argc; j++)
			if( alias[getArg(p,j)] )
				getArg(p,j)= alias[getArg(p,j)];
			pushInstruction(mb,p);
			continue;
		}
@-
Create the lists needed for all target variables
and generator the iterators.
Currently assume a single one.
@c
		if(*seg!=lastsegment && *seg != last){
			for(j=0; j<p->retc; j++){
				listanchor[j]= q = newStmt(mb,"bpm","new");
				alias[getArg(p,j)]= getArg(q,0);
			}
			for(j=p->retc; j<p->argc; j++)
			if( isaBatType(getArgType(mb,p,j)) ){
				q = newStmt(mb, bpmRef, "newIterator");
				q->barrier= BARRIERsymbol;
				q->argv[0]= getArg(p,j);
				pushArgument(mb, q, 
					(alias[getArg(p,j)]?alias[getArg(p,j)]:getArg(p,j)) );
			}
			anchor=p;
		}
		lastsegment= *seg;
		pushInstruction(mb,p);
	}
}
static int
OPTpartitionsImplementation(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	lng clk= GDKusec();
	int last;
	(void) stk;
	(void) pci;
	last= OPTpartitionProperties(mb);
	OPTpartitionStrategy(mb,last);
	optimizerCheck(mb,"partitions",1,GDKusec()-clk,OPT_CHECK_ALL);
#ifdef DEBUG_OPT_PARTITIONED
	stream_printf(GDKout,"partition optimizer Strategy\n");
	printFunction(GDKout,mb,0);
#endif
	return 1;
}

@-
The translation of a MAL block into a multi-iterator only works if
the network flow is simple, i.e there exists a 'single' sink, 
or all the information is compressed
into variables that are passed back to the caller as a single value,
or is sent non-interupted to the output channels.
The bottom-line is to avoid expansion.
An assignment to the target is not allowed [to be checked separately]

@include optimizerWrapper.mx
@h
@:exportOptimizer(partitions)@
#endif
@c
#include "opt_statistics.h"
@:wrapOptimizer(partitions,OPT_CHECK_ALL)@
@}
