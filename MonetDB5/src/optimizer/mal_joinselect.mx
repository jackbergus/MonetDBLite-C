@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2006 CWI.
@' All Rights Reserved.

@f mal_joinselect
@a S. Idreos
The combination of joins and selects is effective in the 
context of cracker optimizations.
@mal
pattern optimizer.joinselect():str
address QOTJSoptimizer;
pattern optimizer.joinselect(mod:str, fcn:str):str
address QOTJSoptimizer
comment "Replace select with join select";
@h
#ifndef _MAL_JOINSEL
#define _MAL_JOINSEL
#include "mal_optimizer.h"

/*#define DEBUG_MAL_JOINSEL    show partial result*/ 

opt_export str JSoptimizer(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);

#define match(X,M,F) ( (X) && getFunctionId(X) && strcmp(getFunctionId(X),F)==0 && \
	getModuleId(X) && strcmp(getModuleId(X),M)==0)
#define match2(X,M,F) ( (X) && getFunctionId(X) && getFunctionId(X)==F && \
        getModuleId(X) && getModuleId(X)==M)
#define match3(X,M) (getModuleId(X) && getModuleId(X)==M) 

#endif

@c
#include "mal_prelude.h"
#include "mal_joinselect.h"
#include "mal_namespace.h"
#include "mal_interpreter.h"	/* for showErrors() */

str
JSoptimizer(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	InstrPtr p, *old, qs, qi, qu, qd, r, d, k;// qu, qi, r, d,  *old;
	int i, limit, attr;
	lng clk = GDKusec();
	int start = -1;
	int *scr_s, *scr_i, *scr_u, *scr_d;
	int *ps, *pi, *pu, *pd;
	int scr_size = 10; 
	int xx = sizeof(int);
	int pivot = -1;

	if( mb->errors) 
		return MAL_SUCCEED;

#ifdef DEBUG_MAL_JOINSEL
	stream_printf(GDKout, "Joinselect optimizer started\n");
#endif

	scr_s = (int*) GDKmalloc(scr_size * sizeof(int));
	scr_i = (int*) GDKmalloc(scr_size * sizeof(int));
	scr_u = (int*) GDKmalloc(scr_size * sizeof(int));
	scr_d = (int*) GDKmalloc(scr_size * sizeof(int));
	ps = scr_s;
	pi = scr_i;
	pu = scr_u;
	pd = scr_d;

	(void) stk;
	(void) pci;
	setLifespan(mb);
	limit = mb->stop;
	old = mb->stmt;

	newMalBlkStmt(mb, mb->stop);
	
	/*The first loop identifies all the select calls and keeps a reference to the operations.
	  Also the end of the selection part is found where the pivot is made.	 
	  All operations before the first select call are added to the new plan	*/
	for (i = 0; i < limit; i++) {
		p = old[i];

		if (match2(p, algebraRef, uselectRef)){
			if (start == -1) 
				start = i;

                        if(fndProperty(mb->var[getArg(p,1)]->props,"stable")){
				*(int*)ps = i;
				ps += xx;
			}
                        if(fndProperty(mb->var[getArg(p,1)]->props,"insertions")){
				*(int*)pi = i;
				pi += xx;
			}
                        if(fndProperty(mb->var[getArg(p,1)]->props,"updates")){
				*(int*)pu = i;
				pu += xx;
			}
		}
		
		if (match2(p, batRef, reverseRef)){
			if(fndProperty(mb->var[getArg(p,1)]->props,"deletes")){
                                *(int*)pd = i;
                                pd += xx;
                        }
		}
	
		if (match2(p, sqlRef, bindRef)){
			if (mb->var[getArg(p,0)]->props == 0)
                                mb->var[getArg(p,0)]->props = newPropertySet();

			if (mb->var[getArg(p,4)]->value.val.ival == 0 )	
                        	setProperty(mb->var[getArg(p,0)]->props,"stable","=", TYPE_int, &i);
			if (mb->var[getArg(p,4)]->value.val.ival == 1 )	
                        	setProperty(mb->var[getArg(p,0)]->props,"insertions","=", TYPE_int, &i);
			if (mb->var[getArg(p,4)]->value.val.ival == 3 )	
                        	setProperty(mb->var[getArg(p,0)]->props,"updates","=", TYPE_int, &i);
		}
		if (match2(p, sqlRef, bind_dbatRef)){
                        if (mb->var[getArg(p,0)]->props == 0)
                                mb->var[getArg(p,0)]->props = newPropertySet();
			setProperty(mb->var[getArg(p,0)]->props,"deletes","=", TYPE_int, &i);
		}
		if (match2(p, batRef, setWriteModeRef)){ 

                        if (mb->var[getArg(p,0)]->props == 0)
                        	mb->var[getArg(p,0)]->props = newPropertySet();

                        if(fndProperty(mb->var[getArg(p,1)]->props,"stable"))
                                setProperty(mb->var[getArg(p,0)]->props,"stable","=", TYPE_int, &i);
                        if(fndProperty(mb->var[getArg(p,1)]->props,"insertions"))
                                setProperty(mb->var[getArg(p,0)]->props,"insertions","=", TYPE_int, &i);
                        if(fndProperty(mb->var[getArg(p,1)]->props,"updates"))
                                setProperty(mb->var[getArg(p,0)]->props,"updates","=", TYPE_int, &i);
                }
		
		if (match2(p, algebraRef, markTRef)){
			pivot = i;
			break;
			
		}
		
		if (start == -1)
			pushInstruction(mb, p);
	
	}

	/*Nothing to optimize*/
	if (start==-1) goto end;

	/*if not more than one attributes in the where clause then keep the same plan*/
	attr = (ps -scr_s)/xx;
	if (attr <= 1){
		for (i = start; i < limit; i++) 
			pushInstruction(mb, old[i]);
		goto end;
	}

	/*The following loop transfers all calc operations in the beggining of the selections part*/
	for (i = start; i < pivot; i++) {
		p = old[i];
		if (match3(p, calcRef))
			pushInstruction(mb, p);
	}	

	/*join select on the stable bats */
	ps = scr_s;
	qs = old[*(int*)ps];
	pushInstruction(mb, qs);
	i = 1;		
	while(i<attr){
		p=qs;
		ps+=xx; 
		qs = old[*(int*)ps];
		setModuleId(qs, putName("crackers", 8));
       		setFunctionId(qs, putName("joinuselect", 11));
       		pushArgument(mb, qs, getArg(p, 0));
		pushInstruction(mb, qs);
		i++;	
	}

	/*join select on the insertions bats */
	pi = scr_i;
	qi = old[*(int*)pi];
	pushInstruction(mb, qi);
	i = 1;		
	while(i<attr){
		p=qi;
		pi+=xx; 
		qi = old[*(int*)pi];
		setModuleId(qi, putName("crackers", 8));
       		setFunctionId(qi, putName("joinuselect", 11));
       		pushArgument(mb, qi, getArg(p, 0));
		pushInstruction(mb, qi);
		i++;	
	}

	/*union the result of the join select on the stable bats with the join select on the insertions bat*/
	r = newInstruction(mb,ASSIGNsymbol);
	getArg(r,0) = newTmpVariable(mb, newBatType(TYPE_void, TYPE_void));
	setModuleId(r, putName("algebra", 7));
        setFunctionId(r, putName("kunion", 6));        
        pushArgument(mb, r, getArg(qs, 0));
        pushArgument(mb, r, getArg(qi, 0));
	pushInstruction(mb, r);


/*	d = newInstruction(mb,ASSIGNsymbol);
        getArg(d,0) = newTmpVariable(mb, newBatType(TYPE_oid, TYPE_void));
        setModuleId(d, putName("bat", 3));
        setFunctionId(d, putName("reverse", 7));
        pushArgument(mb, d, getArg(r, 0));
        pushInstruction(mb, d);
	r=d;
*/

	/*remove updated buns*/
	i = 1;		
	pu = scr_u;
	while(i<=attr){
		d = old[*(int*)pu];
		k = newInstruction(mb,ASSIGNsymbol);
		getArg(k,0) = newTmpVariable(mb, newBatType(TYPE_oid, TYPE_void));
		setModuleId(k, putName("algebra", 7));
       		setFunctionId(k, putName("kdifference", 11));
       		pushArgument(mb, k, getArg(r, 0));
       		pushArgument(mb, k, getArg(d, 1));
		pushInstruction(mb, k);
		pu+=xx;
		r = k; 
		i++;	
	}

	/*join select on the updated bats*/
	pu = scr_u;
	qu = old[*(int*)pu];
	pushInstruction(mb, qu);
	i = 1;		
	while(i<attr){
		p=qu;
		pu+=xx; 
		qu = old[*(int*)pu];
		setModuleId(qu, putName("crackers", 8));
       		setFunctionId(qu, putName("joinuselect", 11));
       		pushArgument(mb, qu, getArg(p, 0));
		pushInstruction(mb, qu);
		i++;	
	}

	/*union with the updates*/
	p = newInstruction(mb,ASSIGNsymbol);
	getArg(p,0) = newTmpVariable(mb, getArgType(mb,r,0));
	setModuleId(p, putName("algebra", 7));
        setFunctionId(p, putName("kunion", 6));        
        pushArgument(mb, p, getArg(r, 0));
        pushArgument(mb, p, getArg(qu, 0));
	pushInstruction(mb, p);

	/*remove any bun that is deleted*/
	pd = scr_d;
	i = 1;		
	while(i<=attr){
		qd = old[*(int*)pd];
		pushInstruction(mb, qd); /*this is the reverse operation*/
		k = newInstruction(mb,ASSIGNsymbol);
		getArg(k,0) = newTmpVariable(mb, newBatType(TYPE_oid, TYPE_void));
		setModuleId(k, putName("algebra", 7));
       		setFunctionId(k, putName("kdifference", 11));
       		pushArgument(mb, k, getArg(p, 0));
       		pushArgument(mb, k, getArg(qd, 0));
		pushInstruction(mb, k);
		pd += xx;
		p = k; 
		i++;	
	}

	/*now just append the remaining instructions. Only set the pivot to the correct variable*/	
	r = old[pivot];
	getArg(r,1) = getArg(p,0);
	pushInstruction(mb, r) ;

	for (i = pivot+1; i < limit; i++) {
                p = old[i];
                pushInstruction(mb, p);
        }       

end:

	GDKfree(old);
	GDKfree(scr_s);
	GDKfree(scr_i);
	GDKfree(scr_u);
	GDKfree(scr_d);

#ifdef DEBUG_MAL_JOINSEL
	printFunction(GDKout, mb, LIST_MAL_ALL);
#endif
	optimizerCheck(mb, "mal.joinselect", 1, GDKusec() - clk);
	return MAL_SUCCEED;
}

@- Optimizer code wrapper
@c
mal_export str QOTJSoptimizer(MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
str QOTJSoptimizer(MalBlkPtr mb, MalStkPtr stk, InstrPtr p){
	str	modnme;
	str	fcnnme;
	Module  scope=NULL;
	Symbol s= NULL;
	Client c= MCgetClient();
	lng clk= GDKusec();

	/* handle the empty argument list */
	if( p->argc== 1){
		optimizerInit();
		JSoptimizer(mb, stk, p);
		return MAL_SUCCEED;
	}
	if( stk != 0){
		modnme= (str)getArgValue(stk,p,1);
		fcnnme= (str)getArgValue(stk,p,2);
	} else {
		modnme= getArgDefault(mb,p,1);
		fcnnme= getArgDefault(mb,p,2);
	}
	scope = findModule(c->nspace,putName(modnme,strlen(modnme)) );
	if( scope)
		s= findSymbolInModule(scope,putName(fcnnme,strlen(fcnnme)));

	if( s == NULL) {
		char buf[1024];
		snprintf(buf,1024, "Could not find %s.%s\n",modnme,fcnnme);
		return throwMessage("joinselect.optimizer",buf);
	}
	
	if( s->def->errors == 0){
		optimizerInit();
		JSoptimizer(s->def,0,0);
		optimizerCheck(s->def,"joinselect",1,GDKusec()-clk);
	}
	removeInstruction(mb, p);
	return MAL_SUCCEED;
}
@}
