@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2005 CWI.
@' All Rights Reserved.

@f mal_reduce
@a M. Kersten
@-
@node Variable Stack Reduction, Program Debugging, Costmodels, Optimizer toolkit
@+ Variable Stack Reduction
The compilers producing MAL may generate an abundance of temporary variables
to hold the result of expressions. This leads to a polution of the
runtime stack space, because space should be allocated and garbage
collection tests should be performed.

The routine @code{optimizer.reduce()} reduces the number of scratch
variables to a minimum. All scratch variables of the same underlying
type share a storage space. 
The result of this optimizer can be seen using the MonetDB debugger,
which marks unused variables explicitly.
Experience with the SQL front-end shows, that this optimization
step easily reduces the stack consumption by over 10\%.

This optimizer needs further testing. Especially late type
binding of operations case problems, e.g. sql.bind
Furthermore, the other optimizers should be careful in setting
the isused property, or this property can again be easily derived.
@{
@h
#ifndef _MAL_REDUCE_
#define _MAL_REDUCE_
#include "mal_optimizer.h"

opt_export str MRoptimizer(MalBlkPtr mb, MalStkPtr stk, InstrPtr p);

/* #define DEBUG_MAL_REDUCE     show partial result */

#endif
@c
#include "mal_reduce.h"

str
MRoptimizer(MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	int *vars;
	int cnt = 0, i, j;
	vars = (int *) alloca(mb->vtop * sizeof(int));

	chkFlow(mb);

	/* build the alias table */
	for (i = 0; i < mb->vtop; i++) {
		if (!mb->var[i]->isused && !mb->var[i]->isudftype && !isConstant(mb, i) && getVarType(mb, i) != TYPE_any) {
			for (j = i - 1; j >= 0; j--)
				if (mb->var[j] && !mb->var[j]->isused && getVarType(mb, i) == getVarType(mb, j)) {
					freeVariable(mb, i);
					vars[i] = j;
					goto nxtReduce;
				}
		}
		vars[i] = i;
		cnt++;
	      nxtReduce:;
	}
#ifdef DEBUG_MAL_REDUCE
	stream_printf(GDKOUT, "Reduction %d -> %d\n", mb->vtop, cnt);
#endif

	/* remap all variable references to their new position. */
	/*removeInstruction(mb,p); */
	for (i = 1; i < mb->stop; i++) {
		p = getInstrPtr(mb, i);
		for (j = 0; j < p->argc; j++)
			getArg(p, j) = vars[getArg(p, j)];
	}
	for (i = j = 0; i < mb->vtop; i++)
		if (mb->var[i])
			mb->var[j++] = mb->var[i];

	mb->vtop = j;
	(void) stk;
	return MAL_SUCCEED;
}

@}
