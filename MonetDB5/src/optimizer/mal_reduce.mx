@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2006 CWI.
@' All Rights Reserved.

@f mal_reduce
@a M. Kersten
@-
@node Variable Stack Reduction, Query Execution Plans, Costmodels, Optimizer toolkit
@- Variable Stack Reduction
The compilers producing MAL may generate an abundance of temporary variables
to hold the result of expressions. This leads to a polution of the
runtime stack space, because space should be allocated and garbage
collection tests should be performed.

The routine @code{optimizer.reduce()} reduces the number of scratch
variables to a minimum. All scratch variables of the same underlying
type share the storage space. 
The result of this optimizer can be seen using the MonetDB debugger,
which marks unused variables explicitly.
Experience with the SQL front-end shows, that this optimization
step easily reduces the stack consumption by over 20\%.

This optimizer needs further testing. 
Furthermore, the other optimizers should be careful in setting
the isused property, or this property can again be easily derived.
@{
@mal
pattern optimizer.reduce():str
address QOTMRoptimizer;
pattern optimizer.reduce(mod:str, fcn:str):str
address QOTMRoptimizer
comment "Reduce the stack space claims";

@h
#ifndef _MAL_REDUCE_
#define _MAL_REDUCE_
#include "mal_prelude.h"
#include "mal_optimizer.h"

opt_export str MRoptimizer(MalBlkPtr mb, MalStkPtr stk, InstrPtr p);

/* #define DEBUG_MAL_REDUCE     show partial result */

#endif
@c
#include "mal_reduce.h"
#include "mal_interpreter.h"

str
MRoptimizer(MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	int *vars, *used;
	int cnt = 0, i, j;
	InstrPtr q;
	int actions = 0;
	lng clk = GDKusec();

	vars = (int *) alloca(mb->vtop * sizeof(int));
	used= (int *) alloca(mb->vtop * sizeof(int));
	for( i=0; i< mb->vtop; i++)
		vars[i]= used[i]=0;

	/* build the use table */
	for(i=0; i<mb->stop; i++){
		q= getInstrPtr(mb,i);
		for(j= 0; j<q->argc; j++)
			used[getArg(q,j)]= 1;
	}
	/* build the alias table */
	for (i = 0; i < mb->vtop; i++) {
		if ( used[i]==0 ){
			clearVariable(mb, i);
			continue;
		}
		if (i>cnt) {
			/* remap temporary variables */
			if (isTmpVar(mb,i))
				getVarTmp(mb,i) = cnt;
			mb->var[cnt] = mb->var[i];
			mb->var[i] = NULL;
		}
		vars[i] = cnt;
		cnt++;
	}
	actions = mb->vtop - cnt;
#ifdef DEBUG_MAL_REDUCE
	stream_printf(GDKout, "Reduction %d -> %d\n", mb->vtop, cnt);
#endif

	/* remap all variable references to their new position. */
	if (actions) {
		for (i = 1; i < mb->stop; i++) {
			q = getInstrPtr(mb, i);
			for (j = 0; j < q->argc; j++)
				getArg(q, j) = vars[getArg(q, j)];
		}
	}
	mb->vtop = cnt;
	(void)stk;
	if(p)
		removeInstruction(mb,p); 
	optimizerCheck(mb, "mal.reduce", actions, GDKusec() - clk);
	return MAL_SUCCEED;
}

@- Optimizer code wrapper
@c
mal_export str QOTMRoptimizer(MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
str QOTMRoptimizer(MalBlkPtr mb, MalStkPtr stk, InstrPtr p){
	str	modnme;
	str	fcnnme;
	Module  scope=NULL;
	Symbol s= NULL;
	Client c= MCgetClient();
	lng clk= GDKusec();

	/* handle the empty argument list */
	if( p->argc== 1){
		/* setLifespan(mb); they should do it themselves*/
		optimizerInit();
		MRoptimizer(mb, stk, p);
		return MAL_SUCCEED;
	}
	if( stk != 0){
		modnme= (str)getArgValue(stk,p,1);
		fcnnme= (str)getArgValue(stk,p,2);
	} else {
		modnme= getArgDefault(mb,p,1);
		fcnnme= getArgDefault(mb,p,2);
	}
	scope = findModule(c->nspace,putName(modnme,strlen(modnme)) );
	if( scope)
		s= findSymbolInModule(scope,putName(fcnnme,strlen(fcnnme)));

	if( s == NULL) {
		char buf[1024];
		snprintf(buf,1024, "Could not find %s.%s\n",modnme,fcnnme);
		return throwMessage("optimizer.reduce",buf);
	}
	
	if( s->def->errors == 0){
		optimizerInit();
		MRoptimizer(s->def,0,0);
		optimizerCheck(s->def,"reduce",1,GDKusec()-clk);
	}
	removeInstruction(mb, p);
	return MAL_SUCCEED;
}
@}
