@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBGicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2005 CWI.
@' All Rights Reserved.

@f mal_generators
@a M. Kersten
@-
@node Partitioned Databases, Strength Reduction, Multi-Association Tables, Optimizer toolkit
@+ Iterator query processing
Limitations on the addressing space in older PCs and the need
for distributed storage makes that BATs ideally should be 
looked upon as a union of smaller BATs which are processed
within the (memory) resource limitations given.

The operation @code{optimizer.generators} takes mat.new definitions
and encapsulate them in iterator blocks, thereby minimizing the
MAL program footprint.

The optimizer is designed incrementally. The focus is
on supporting the SQL front-end. In particularly, the
operators considered is a limited subset of MAL. Occurrence
of an operator outside this set terminates the loop.

The general strategy is to select a portion of the workflow
related to a variable and encapsulate it with
an iterator over the BAT partitions. In doing so, we replace
operators with their incremental counter part, alike the
MAT optimizer.

A snippet of the partitioning optimizer is shown below. It assumes
that the MAT @code{a0} consists of the components @code{a1,a2,a3}.
A subsequent call of the partition optimizer will replace
the print command with an iterator.
@verbatim

function qry(a:bat[:void,:any_1]
	b:bat[void,:int]:= mat.iterator("Sales2005")
	i:= algebra.count(b);
    io.print(i);
end qry;
optimizer.generators("user","qry");
@end verbatim
The query is transformed into the following version.
@verbatim
function user.qry(a:bat[:void,:any_1]{mat}):void;
	b:bat[void,:int]:= mat.iterator("Sales2005")
	_7:= 0;
barrier _6:= mat.newIterator("Sales2005");
	_8:= aggr.count(_t);
	_7:= _7+ _8;
    redo _6:= mat.hasMoreElements(a);
exit _6;
    io.print(_7);
end qry;
@end verbatim
@{
@+ Implementation
The implementation is somewhat complicated by the fact that MAL
programs contains (implicit) flow of control. This calls for
a two stage machine, where we are copying all instructions into place
until we encounter a generator. Then we recursively reorganize
the plan until this generator and its dependencies are exhausted
or a packing operation is required before proceeding.

The safe line is that at any time we can glue together the
BAT partitions to form a single BAT, but this may come at a
rather substancial price.

To minimize the impact of the generators, we first move
them as close as possible to their first use case.
We also mark the end of the generator scope, based on the
instructions seen.
@h
#ifndef _MAL_BATLOOPS_
#define _MAL_BATLOOPS_
#include "mal_optimizer.h"
#include "mal_builder.h"
#include "pbm.h"

opt_export str BGoptimizer(MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
/* #define DEBUG_MAL_BATLOOPS     show partial result */

#endif
@c
#include "mal_generators.h"
#include "mal_prelude.h"

static int
isPBMalias(int idx, int mvar[], int top){
	int i;
	for(i =0; i<top; i++)
		if( mvar[i]== idx) return i;
	return -1;
}
@-
Packing the BATs into a single one is handled here
@c
InstrPtr BGexitLoop(MalBlkPtr mb, InstrPtr  r, int m, InstrPtr *mat, int *mvar, int mtop){
	int l,k;
	for(l=mat[m]->retc; l< mat[m]->argc; l++){
		k= isPBMalias( getArg(mat[m],l),mvar,mtop);
		if( k< 0)
			r= pushArgument(mb,r, getArg(mat[m],l));
		else
			r= BGexitLoop(mb,r, k, mat,mvar,mtop);
	}
	return r;
}
static void BGcloseLoop(MalBlkPtr mb, int m, InstrPtr *stmt ){
	InstrPtr r;
	r = newInstruction(mb, ASSIGNsymbol);
	r->barrier= REDOsymbol;
	setModuleId(r, moduleId(stmt[m]));
	setFunctionId(r,putName("hasMoreElements",15));
	getArg(r,0)= getArg(stmt[m],0);
	pushArgument(mb,r,getArg(stmt[m],1));
	pushInstruction(mb,r);
	setVarInitialized(mb,getArg(r,0));
	setVarUsed(mb,getArg(r,1),TRUE);

	r = newInstruction(mb, ASSIGNsymbol);
	r->barrier= EXITsymbol;
	getArg(r,0)= getArg(stmt[m],0);
	pushInstruction(mb,r);

}
@-
Reorder the MAL program to minimize the generator scopes
and to mark the end of the generator.
An early user supplied pbm.finish() overrules the hardwired
decisions. A too late finish() should be flagged as an error.
@c
void BGcloseGenerator(MalBlkPtr mb, InstrPtr p){
	InstrPtr r;
	r = copyInstruction(p);
	setModuleId(r, pbmRef);
	setFunctionId(r,finishRef);
	pushInstruction(mb,r);
}

#define CHKbound() if( gtop == 128){ \
				mb->errors++; \
				GDKerror("Too many generators"); \
				return found; }

int BGreorder(MalBlkPtr mb){
	int i,j,k, oldtop, found=0, gvar[128], gopen[128],gtop=0;
	InstrPtr p, *old, stmt[128];
	old = mb->stmt;
	oldtop= mb->stop;
	mb->stmt = (InstrPtr *) GDKmalloc(mb->ssize  * sizeof(InstrPtr));
	memset((char*)mb->stmt, 0, mb->ssize * sizeof(InstrPtr));
	mb->stop=0;

	for(i=0;i<oldtop; i++){
		p= old[i];
		if( moduleId(p)== pbmRef && functionId(p)==generatorRef){
			gopen[gtop]=0;
			stmt[gtop]= p;
			gvar[gtop++]= getArg(p,0);
			found++;
			CHKbound();
			continue;
		}

		for(j=p->retc; j< p->argc; j++)
		for(k=0;k<gtop;k++)
		if( getArg(p,j)== gvar[k] && gopen[k]==0){
@-
Re-open the iterator, which means we have to duplicate
it on the stack for proper use. The old iterator
is marked invalied (gopen[i]= -1)
@c
			gopen[k]= -1;
			pushInstruction(mb, copyInstruction(stmt[k]));
			gopen[gtop]=1;
			stmt[gtop]= stmt[k];
			gvar[gtop++]= gvar[k];
			CHKbound();
		}
@-
Closing a generator implicitly closes all opened after it as well
@c
		if( moduleId(p)== pbmRef && functionId(p)==finishRef){
			for(k=0;k<gtop;k++)
			if( getArg(p,1)== gvar[k] ) break;
			
			for(j= gtop-1; j>=k; j--)
			if( gopen[j]== 1) {
				BGcloseGenerator(mb, stmt[j]);
				gopen[j]=0;
			}
			continue;
		}
		if( p->barrier || p->token== ENDsymbol ||
			isUnsafeFunction(p) || isUnsafeInstruction(p)){
			for(j=gtop-1; j>=0; j--)
			if( gopen[j] ==1){
				BGcloseGenerator(mb,stmt[j]);
				gopen[j]=0;
			}
		}
		pushInstruction(mb,p);
	}
#ifdef DEBUG_MAL_BATLOOPS     
	stream_printf(GDKout,"Result of reorder\n");
	printFunction(GDKout,mb,LIST_MAL_INSTR);
#endif
	GDKfree(old);
	return found;
}
@-
We remember all instructions that should be moved outside the loop
At some point they have to included.
@c
static void BGcopyKeep(MalBlkPtr mb, int keep, InstrPtr *old){
	int i;
	for(i=0;i<keep; i++)
	pushInstruction(mb,old[i]);
}
@-
The key administration is to keep track of the outstanding
iterator blocks and whether a variable represents a PBAT result.
The table mloop contains the PC of the corresponding iterator.
@c
str
BGoptimizer(MalBlkPtr mb, MalStkPtr stk, InstrPtr p){
	InstrPtr *old=0, q,r, stmt[256];
	int oldtop,keep=0,i,j,k,m=0;
	int mtop=0, mvar[256], mloop[256],tpe;
	int size,match,actions=0;
	lng clk = GDKusec();
#ifdef DEBUG_MAL_BATLOOPS     
	stream_printf(GDKout,"Start generators optimizer\n");
	printFunction(GDKout, mb, 0);
#endif
	optInit();

	if(p)
		removeInstruction(mb,p);

	actions= BGreorder(mb);

	old = mb->stmt;
	oldtop= mb->stop;
	size = (mb->stop *1.2 < mb->ssize)? mb->ssize: mb->stop *1.2;
	mb->stmt = (InstrPtr *) GDKmalloc(size  * sizeof(InstrPtr));
	memset((char*)mb->stmt, 0, size * sizeof(InstrPtr));
	mb->ssize = size ;
	mb->stop = keep;


	for( i=0; i<oldtop-1; i++){
		p= old[i];
@-
Deal with iterator requests aimed at partitioned BATs
@c
		if( (moduleId(p)== pbmRef && functionId(p)== generatorRef)  &&
			p->argc== 2 && getVarType(mb,getArg(p,1))== TYPE_str){
			stmt[mtop]= p;
			mvar[mtop] = getArg(p,0);
			mloop[mtop] = mb->stop;
			mtop++;

			r = copyInstruction(p);
			r->barrier= BARRIERsymbol;
			setFunctionId(r,putName("newIterator",11));
			setVarInitialized(mb,getArg(p,0));
			pushInstruction(mb,r);
			continue;
		}
@-
Termination of the generator scope involves gathering all
remaining pieces for later use.
@c
		if( moduleId(p)== pbmRef && functionId(p)== finishRef ){
			r = copyInstruction(p);
			r->barrier= REDOsymbol;
			setFunctionId(r,putName("hasMoreElements",15));
			pushInstruction(mb,r);

			r = copyInstruction(p);
			r->barrier= EXITsymbol;
			moduleId(r)= NULL;
			functionId(r) = NULL;
			r->fcn = NULL;
			r->argc=1;
			pushInstruction(mb,r);
			/* invalidate loop */\
			for(m=0;m<mtop; m++)
			if( mloop[m]>=0 && mvar[m]== getArg(r,0)){
				mloop[m]= -1;
				break;
			}
			continue;
		}
			
@-
Any side-effect operator should be either postponed or terminates
the generator.
It is up to the strength reduction to move instructions safely out of
the loop.
Otherwise we have to decide on either packing them or replacement.
@c
		match=0;
		for(j=p->retc; j<p->argc; j++)
		if(  isPBMalias(getArg(p,j),mvar,mtop) >= 0) {
			m=i; match++;
		}
		if( match== 0 && !isUnsafeFunction(p) &&
			!isUnsafeInstruction(p) ){
			pushInstruction(mb,p);
			continue;
		}
@-
Left with an instruction with at most one MAT we can replace it.
Not all instructions can be replaced by the sequence. We have to
group them and check for them individually.
At first we look for the first argument. Others are dealt with
through the default case.
@c
		if(( (moduleId(p)== algebraRef && functionId(p)== selectRef) ||
			(moduleId(p)== algebraRef && functionId(p)==uselectRef) ||
			(moduleId(p)== algebraRef && functionId(p)==likeselectRef) ||
			(moduleId(p)== batRef && functionId(p)==reverseRef) ||
			(moduleId(p)== batRef && functionId(p)==mirrorRef) ||
			(moduleId(p)== algebraRef && functionId(p)==markTRef) ||
			(moduleId(p)== algebraRef && functionId(p)==kdifferenceRef) ||
			(moduleId(p)== algebraRef && functionId(p)== joinRef) ||
			(moduleId(p)== algebraRef && functionId(p)== semijoinRef) ||
			(moduleId(p)== batRef && functionId(p)== setAccessRef) ||
			(moduleId(p)== batRef && functionId(p)== appendRef)  ||
			(moduleId(p)== batRef && functionId(p)== deleteRef)  ||
			moduleId(p)== calcRef 
		)  && (m=isPBMalias(getArg(p,1),mvar,mtop)) >= 0){
			r = newInstruction(mb, ASSIGNsymbol);
			setModuleId(r,matRef);
			setFunctionId(r,newRef);
			getArg(r,0)= getArg(p,0);
			pushArgument(mb,r,getArg(p,0));
			pushInstruction(mb,p);
			
			mvar[mtop] = getArg(r,0);
			stmt[mtop++]= r;
			actions++;
			continue;
		} 
@-
The MAT argument could also occur as the second one.
@c
		if( moduleId(p)==algebraRef && functionId(p)== joinRef &&
			(m=isPBMalias(getArg(p,2),mvar,mtop)) >= 0){
			r = newInstruction(mb, ASSIGNsymbol);
			setModuleId(r,matRef);
			setFunctionId(r,newRef);
			getArg(r,0)= getArg(p,1);
			r= pushArgument(mb,r,getArg(p,1));
			pushInstruction(mb,p);
			
			mvar[mtop] = getArg(r,0);
			stmt[mtop++]= r;
			pushInstruction(mb,r);
			actions++;
			continue;
		} 
@-
Handle the rewrite v:=aggr.count(b) and sum()
In this case we have to include an initialization statement before the
generator.
@c
		if( ((moduleId(p)==aggrRef && functionId(p)== countRef) || 
			(moduleId(p)==aggrRef && functionId(p)==sumRef && p->argc==2)) &&
			(m=isPBMalias(getArg(p,1),mvar,mtop)) >= 0){
			r = newInstruction(mb,ASSIGNsymbol);
			getArg(r,0)= getArg(p,0);
			pushInt(mb,r,0);
			pushInstruction(mb,r);
			for(k=1; k< stmt[m]->argc; k++){
				int v= newTmpVariable(mb,TYPE_int);
				q= newInstruction(mb,ASSIGNsymbol);
				setModuleId(q,aggrRef);
				setFunctionId(q,functionId(p));
				getArg(q,0)= v;
				setVarUsed(mb,v,TRUE);
				setVarInitialized(mb,v);
				q= pushArgument(mb,q,getArg(stmt[m],k));
				pushInstruction(mb,q);

				q= newInstruction(mb,ASSIGNsymbol);
				setModuleId(q,calcRef);
				setFunctionId(q,plusRef);
				getArg(q,0)= getArg(r,0);
				q= pushArgument(mb,q,getArg(r,0));
				q= pushArgument(mb,q,v);
				pushInstruction(mb,q);
			}
			continue;
		} 
@-
And the min/max is as easy
@c
		if( ((moduleId(p)==aggrRef && functionId(p)== maxRef) || 
			(moduleId(p)==aggrRef && functionId(p)==minRef )) &&
			p->argc==3 &&
			(m=isPBMalias(getArg(p,1),mvar,mtop)) >= 0){
			r = newInstruction(mb,ASSIGNsymbol);
			getArg(r,0)= getArg(p,0);
			pushNil(mb,r,getArgType(mb,p,0));
			pushInstruction(mb,r);
			for(k=1; k< stmt[m]->argc; k++){
				int v= newTmpVariable(mb,TYPE_int);
				q= newInstruction(mb,ASSIGNsymbol);
				setModuleId(q,aggrRef);
				setFunctionId(q,functionId(p));
				getArg(q,0)= v;
				setVarUsed(mb,v,TRUE);
				setVarInitialized(mb,v);
				q= pushArgument(mb,q,getArg(stmt[m],k));
				pushInstruction(mb,q);

				q= newInstruction(mb,ASSIGNsymbol);
				setModuleId(q,calcRef);
				setFunctionId(q,plusRef);
				getArg(q,0)= getArg(r,0);
				q= pushArgument(mb,q,getArg(r,0));
				q= pushArgument(mb,q,v);
				pushInstruction(mb,q);
			}
			continue;
		} 
@-
All other instructions should be checked for dependencies.
Printing BAT information streams towards the user, to it can be
retained inside the loop. All other use is considered once-only
and the instruction should be moved outside the loop.
Moreover, it then terminates the block in which it was used.
@c
MATdefault:
		if( moduleId(p)== ioRef && functionId(p)==printRef){
			pushInstruction(mb,p);
			continue;
		}
@-
Any unsafe function or instruction should be postponed to
after the iterator block. It require the PBAT to be materialized. 
@c
		for( k= p->retc; k<p->argc; k++)
		if(	(m=isPBMalias(getArg(p,k),mvar,mtop)) >= 0){
#ifdef DEBUG_MAL_BATLOOPS     
			stream_printf(GDKout,"Dependency resolution k=%d\n",k);
			printInstruction(GDKout,mb,p,0);
#endif
			r = newInstruction(mb, ASSIGNsymbol);
			setModuleId(r,matRef);
			setFunctionId(r,packRef);
			getArg(r,0)= getArg(stmt[m],0);
			r= BGexitLoop(mb, r, m, stmt, mvar, mtop);
			if(	!( moduleId(p) == matRef && functionId(p)== newRef) )
				pushInstruction(mb,r);
			else freeInstruction(r);

			for(j=m; j<mtop-1; j++){
				stmt[j]= stmt[j+1];
				mvar[j]= mvar[j+1];
			}
			mtop--; 
			actions++;
			break;
		}

		pushInstruction(mb,p);
	}
@-
At this stage we should close any open generators.
@c
	for(i=mtop; i>=0; i--)
	if( mloop[i]>0){
		BGcloseLoop(mb,i,stmt);
	}
	BGcopyKeep(mb, keep, old);
	pushInstruction(mb,old[oldtop-1]);
	GDKfree(old);
@-
As a final optimization, we could remove the mal.new definitions,
because they are not needed for the execution.
For the time being, they are no-ops.
@c
	(void) stk; 
	optimizerCheck(mb, "optimizer.generators", actions, GDKusec() - clk);
#ifdef DEBUG_MAL_BATLOOPS     
	stream_printf(GDKout,"Result of generators optimizer\n");
	printFunction(GDKout, mb, 0);
#endif

	return MAL_SUCCEED;
}
@}
