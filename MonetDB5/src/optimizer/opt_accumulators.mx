@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2006 CWI.
@' All Rights Reserved.

@f opt_accumulators
@-
@node Accumulator Evaluations, Heuristic Rewrite Rules, Dead Code Removal, Toolkit
@- Accumulator Evaluations
Bulk arithmetic calculations are pretty expensive,
because new @code{BAT}s are created for each expression. 
This memory hunger can be reduced
by detecting opportunities for accummulator processing, i.e.
where a (temporary) variable is overwritten.
For example, consider the program snippet
@example
	t3:= batcalc.*(64,t2);
	t4:= batcalc,+(t1,t3);
	optimizer.accumulators();
@end example
If variable t2 is not used any further in
the program block, we can re-use its storage space
and propagate its alias through the remainder of the code.
@example
	batcalc.*(t2,64,t2);
	t4:= batcalc.+(t2,t1,t2);
@end example
The implementation is straight forward. It only deals with the
arithmetic operations available in @code{batcalc} right now.
This set will be gradually be extended.
The key decision is to determine whether we may overwrite
any of the arguments. We assume this is permissible if the argument
was produced by an operator from the @code{algebra, algebra2, group, aggr}
modules.
@{
@mal
pattern optimizer.accumulators():str
address OPTaccumulators;
pattern optimizer.accumulators(mod:str, fcn:str):str
address OPTaccumulators
comment "Replace calculations with accumulator model";
@h
#ifndef _OPT_ACCUMULATORS_
#define _OPT_ACCUMULATORS_
#include "opt_prelude.h"
#include "opt_support.h"
#include "mal_interpreter.h"

/* #define DEBUG_OPT_REDUCE     show partial result */

#endif

@c
#include "opt_accumulators.h"

static int
OPTvalidInstruction(InstrPtr p){
	if (getModuleId(p)== batcalcRef )
		return strcmp(getFunctionId(p),"init") != 0;
	if (getModuleId(p) && strcmp(getModuleId(p), "array") == 0)
			return strcmp(getFunctionId(p),"grid") != 0;
	if (getModuleId(p)== batcalcRef)
		return 0;
	return 0;
}

static int
OPTaccumulatorsImplementation(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	int i, a, b, valid;
	InstrPtr p;
	Client cntxt = MCgetClient();
	Module scope = cntxt->nspace;
	char *olderr;
	int errlen, actions = 0;
	int olderrnr = mb->errors;

	(void) pci;
	(void) stk;		/* to fool compilers */
	setLifespan(mb);
@-
Safe the errors encountered sofar. They have to be reset
at the end of the optimization attempt.
@c
	errlen = strlen(cntxt->errbuf) + 1;
	olderr = alloca(errlen);
	if (errlen)
		strncpy(olderr, cntxt->errbuf, errlen);
	if (errlen)
		strncpy(cntxt->errbuf, olderr, errlen);

	for (i = 1; i < mb->stop; i++) {
		VarPtr v;

		p = getInstrPtr(mb, i);
		if (getModuleId(p) == NULL)
			continue;
		if( !OPTvalidInstruction(p) ) continue;

		if (p->argc == 3) {
			/* binary/unary operation, check first argument */
			v = getVar(mb, a = getArg(p, 1));
			b = getArg(p, 0);
			if( getLastUpdate(mb,b) != i) continue;
			valid= getEndLifespan(mb,a) <= i;

#ifdef DEBUG_OPT_OPTIMIZER
			stream_printf(GDKout, "Found accumulation candidate ");
			stream_printf(GDKout, "%d: %d(%d,%d) valid=%d isaBat=%d \n", 
				i, b,a,getArg(p,2), valid, isaBatType(v->type));
			printInstruction(GDKout, mb, p, LIST_MAL_ALL);
#endif
			if (isaBatType(v->type) && valid){
				pushArgument(mb, p, getArg(p,2));
				setArg(p,2,getArg(p,1));
				setArg(p,1,a);
				setArg(p,0,newTmpVariable(mb,TYPE_any));

				mb->errors = 0;
				typeChecker(scope, mb, p, TRUE);
				if (p->typechk == TYPE_UNKNOWN) {
					/* reset instruction */
					mb->errors= olderrnr;
					setArg(p,0,getArg(p,1));
					setArg(p,1,getArg(p,2));
					setArg(p,2,a);
					p->argc--;
					typeChecker(scope, mb, p, TRUE);
				} else if (a != b)
					replaceAlias(mb, i + 1, mb->stop, b, a);
#ifdef DEBUG_OPT_OPTIMIZER
				printInstruction(GDKout, mb, p, LIST_MAL_ALL);
#endif
				actions++;
				continue;
			}
			/* continue with binary version */
			v = getVar(mb, a = getArg(p, 2));
			valid= getEndLifespan(mb,a) <= i;
#ifdef DEBUG_OPT_OPTIMIZER
			stream_printf(GDKout, "%d: %d(%d,%d) valid=%d isaBat=%d \n", 
				i, b,getArg(p,1),a, valid, isaBatType(v->type));
#endif
			if (isaBatType(v->type) && valid){
				pushArgument(mb, p, getArg(p,2));
				setArg(p,2,getArg(p,1));
				setArg(p,1,a);
				setArg(p,0,newTmpVariable(mb,TYPE_any));

				mb->errors = 0;
				typeChecker(scope, mb, p, TRUE);
				if (p->typechk == TYPE_UNKNOWN) {
					/* reset instruction */
					mb->errors = olderrnr;
					setArg(p,0,getArg(p,1));
					setArg(p,1,getArg(p,2));
					setArg(p,2,a);
					p->argc--;
					typeChecker(scope, mb, p, TRUE);
				} else if (a != b)
					replaceAlias(mb, i + 1, mb->stop, b, a);
#ifdef DEBUG_OPT_OPTIMIZER
				printInstruction(GDKout, mb, p, LIST_MAL_ALL);
#endif
				actions++;
				continue;
			}
		} else if (p->argc == 2) {
			/* binary/unary operation, check first argument  and return type */
			v = getVar(mb, a = getArg(p, 1));
			b = getArg(p, 0);
			if( getLastUpdate(mb,b) != i) continue;
			valid= getEndLifespan(mb,a) <= i;

			if (isaBatType(v->type)  && valid){
#ifdef DEBUG_OPT_OPTIMIZER
				stream_printf(GDKout, "Found unary accumulation candidate\n");
				printInstruction(GDKout, mb, p, LIST_MAL_ALL);
#endif
				pushArgument(mb, p, a);
				setArg(p,1,getArg(p,0));
				setArg(p,0,newTmpVariable(mb,TYPE_any));

				mb->errors = 0;
				typeChecker(scope, mb, p, TRUE);
				if (p->typechk == TYPE_UNKNOWN) {
					/* reset instruction */
					mb->errors = olderrnr;
					setArg(p,0,getArg(p,1));
					setArg(p,1,getArg(p,2));
					p->argc--;
					typeChecker(scope, mb, p, TRUE);
				} else if (a != b)
					replaceAlias(mb, i + 1, mb->stop, b, a);
				actions++;
			}
		}
	}
	if (errlen)
		strncpy(cntxt->errbuf, olderr, errlen);
	return actions;
}

@include optimizerWrapper.mx
@h
@:exportOptimizer(accumulators)@
@c
@:wrapOptimizer(accumulators,OPT_CHECK_ALL)@
@}
