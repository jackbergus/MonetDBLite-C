@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2006 CWI.
@' All Rights Reserved.

@f opt_accumulators
@-
@node Accumulator Evaluations, Heuristic Rewrite Rules, Dead Code Removal, Toolkit
@- Accumulator Evaluations
Bulk arithmetic calculations are pretty expensive,
because new @code{BAT}s are created for each expression. 
This memory hunger can be reduced
by detecting opportunities for accummulator processing, i.e.
where a (temporary) variable is overwritten.
For example, consider the program snippet
@example
	t3:= batcalc.*(64,t2);
	t4:= batcalc,+(t1,t3);
	optimizer.accumulators();
@end example
If variable t2 is not used any further in
the program block, we can re-use its storage space
and propagate its alias through the remainder of the code.
@example
	batcalc.*(t2,64,t2);
	t4:= batcalc.+(t2,t1,t2);
@end example
The implementation is straight forward. It only deals with the
arithmetic operations available in @code{batcalc} right now.
This set will be gradually be extended.
The key decision is to determine whether we may overwrite
any of the arguments. We assume this is permissible if the argument
was produced by an operator from the @code{algebra, algebra2, group, aggr}
modules.
@{
@mal
pattern optimizer.accumulators():str
address OPTaccumulators;
pattern optimizer.accumulators(mod:str, fcn:str):str
address OPTaccumulators
comment "Replace calculations with accumulator model";
@h
#ifndef _OPT_ACCUMULATORS_
#define _OPT_ACCUMULATORS_
#include "opt_prelude.h"
#include "opt_support.h"
#include "mal_interpreter.h"

/* #define DEBUG_OPT_REDUCE     show partial result */

#endif

@-
While we progress through the program, we should
also built the alias file to propagate the
accumulator names.
@c
#include "opt_accumulators.h"

static int
OPTaccumulatorsImplementation(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	int i,j, a, b, valid;
	InstrPtr p,q;
	Client cntxt = MCgetClient();
	Module scope = cntxt->nspace;
	char *olderr;
	int errlen, actions = 0;
	int olderrnr = mb->errors;
	int *alias;

	(void) pci;
	(void) stk;		/* to fool compilers */
	setLifespan(mb);
	alias= (int*) alloca(sizeof(int)*mb->vtop);
	memset(alias,0, sizeof(int)* mb->vtop);
@-
Safe the errors encountered sofar. They have to be reset
at the end of the optimization attempt.
@= patchInstruction
	mb->errors = 0;
	typeChecker(scope, mb, p, TRUE);
	if (p->typechk == TYPE_UNKNOWN) {
		/* reset instruction */
		mb->errors= olderrnr;
		getInstrPtr(mb,i)= q;
		freeInstruction(p);
	} 
	actions++;
	#ifdef DEBUG_OPT_OPTIMIZER
					printInstruction(GDKout, mb, p, LIST_MAL_ALL);
	#endif
	goto remAlias;
@-
@c
	errlen = strlen(cntxt->errbuf) + 1;
	olderr = alloca(errlen);
	if (errlen)
		strncpy(olderr, cntxt->errbuf, errlen);
	if (errlen)
		strncpy(cntxt->errbuf, olderr, errlen);

	p= getInstrPtr(mb,0);
	for(j=0; j<p->argc;j++)
		alias[getArg(p,j)]= getArg(p,j);

	for (i = 1; i < mb->stop; i++) {
		VarPtr v;
		p = getInstrPtr(mb, i);
@-
First remap all variables upon need
@c
		for(j=p->retc; j<p->argc; j++)
		if( alias[getArg(p,j)] )
			getArg(p,j)= alias[getArg(p,j)];

		if( getModuleId(p) != batcalcRef ) 
			goto remAlias;

		if (p->retc==1  && p->argc == 3) {
			/* binary/unary operation, check first argument */
			b = getArg(p, 0);
			if( getLastUpdate(mb,b) != i) 
				goto remAlias;
			v = getVar(mb, a = getArg(p, 1));
			valid= getEndLifespan(mb,a) <= i;

#ifdef DEBUG_OPT_OPTIMIZER
			stream_printf(GDKout, "Found accumulation candidate ");
			stream_printf(GDKout, "%d: %d(%d,%d) valid=%d isaBat=%d \n", 
				i, b,a,getArg(p,2), valid, isaBatType(v->type));
			printInstruction(GDKout, mb, p, LIST_MAL_ALL);
#endif
			if (isaBatType(v->type) && valid){
				q= copyInstruction(p);
				pushArgument(mb, p, getArg(p,2));
				setArg(p,2,getArg(p,1));
				setArg(p,1,a);
				setArg(p,0,newTmpVariable(mb,TYPE_any));
#ifdef DEBUG_OPT_OPTIMIZER
				printInstruction(GDKout, mb, p, LIST_MAL_ALL);
#endif

				@:patchInstruction(setArg(p,2,a))@
			}
			/* continue with binary version looking at second argument */
			v = getVar(mb, a = getArg(p, 2));
			valid= getEndLifespan(mb,a) <= i;
#ifdef DEBUG_OPT_OPTIMIZER
			stream_printf(GDKout, "%d: %d(%d,%d) valid=%d isaBat=%d \n", 
				i, b,getArg(p,1),a, valid, isaBatType(v->type));
#endif
			if (isaBatType(v->type) && valid){
				q= copyInstruction(p);
				pushArgument(mb, p, getArg(p,2));
				setArg(p,2,getArg(p,1));
				setArg(p,1,a);
				setArg(p,0,newTmpVariable(mb,TYPE_any));

				@:patchInstruction(setArg(p,2,a))@
			}
		} else if (p->retc==1 && p->argc == 2) {
			/* unary operation, check first argument  and return type */
			v = getVar(mb, a = getArg(p, 1));
			b = getArg(p, 0);
			if( getLastUpdate(mb,b) != i) goto remAlias;
			valid= getEndLifespan(mb,a) <= i;

			if (isaBatType(v->type)  && valid){
#ifdef DEBUG_OPT_OPTIMIZER
				stream_printf(GDKout, "Found unary accumulation candidate\n");
				printInstruction(GDKout, mb, p, LIST_MAL_ALL);
#endif
				q= copyInstruction(p);
				pushArgument(mb, p, a);
				setArg(p,1,getArg(p,0));
				setArg(p,0,newTmpVariable(mb,TYPE_any));

				@:patchInstruction((void) a)@
			}
		} else {
		remAlias:
			for(j=0;j< p->retc; j++)
			if( alias[getArg(p,j)] == 0)
				alias[getArg(p,j)]= getArg(p,j);
		}
	}
	if (errlen)
		strncpy(cntxt->errbuf, olderr, errlen);
	return actions;
}

@include optimizerWrapper.mx
@h
@:exportOptimizer(accumulators)@
@c
@:wrapOptimizer(accumulators,OPT_CHECK_ALL)@
@}
