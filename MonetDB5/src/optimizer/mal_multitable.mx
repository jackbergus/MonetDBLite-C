@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2005 CWI.
@' All Rights Reserved.

@f mal_multitable
@a M. Kersten
@+ Multi Association Tables
A Multi Association Table (MAT) is an ordered collection of BATs,
whose union represents a single (virtual) BAT.

A front-end can produce code for the virtual BAT
and leave it to the MAT optimizer to expand the plan to
deal with its components on an individual basis.
Only when a blocking or aggregate operator is encounted,
the underlying BAT is materialized.

The optimizer contains several rules to avoid reconstruction,
because it is often expensive.

In the first approach of the optimizer we assume that the 
last BAT in the MAT sequence is used as an accumulator.
Furthermore, no semantic knowledge is used to reduce the

To illustrate, consider 
@example
    m0:= bat.new(:void,:int);
	m1:= bat.new(:void,:int);
	m2:= bat.new(:void,:int);
	b := mat.new(m0,m1,m2);
	s := algebra.select(b,1,3);
	i := algebra.count(s);
	io.print(s);
	io.print(i);
	c0 := bat.new(:int,:int);
	c1 := bat.new(:int,:int);
	c := mat.new(c0,c1);
	j := algebra.join(b,s);
	io.print(j);
@end example

The selection operation can simply be rewritten into a MAT.
@example
	s0 := algebra.select(m0,1,3);
	s1 := algebra.select(m0,1,3);
	s2 := algebra.select(m0,1,3);
	s  := mat.new(s0,s1,s2);
@end example

The subsequent print operation causes a little problem,
because the print operation generates a header and
multiple prints are seen as different result sets.
This can be circumented with an overloaded print version
in the mat module.
@example
	mat.print(s);
@end example
The aggregation could be directly expanded in terms of
known MAL operations.
@example
	i0 := algebra.count(s0);
	i1 := algebra.count(s1);
	i2 := algebra.count(s2);
	 i := i0+i1;
	 i := i + i2;
@end example
For the join we have to generate all possible combinations,
not knowing anything about the properties of the components.
@example
	m0c0 := algebra.join(m0,c0);
	m1c0 := algebra.join(m1,c0);
	m2c0 := algebra.join(m2,c0);
	m0c1 := algebra.join(m0,c0);
	m1c1 := algebra.join(m1,c0);
	m2c1 := algebra.join(m2,c0);
    j := mat.new(m0c0,m1c0,m2c0,m0c1,m1c1,m1c2);
@end example

The drawback of this scheme is the explosion in MAL statements.
It is choosen as a basis for experimentation, but in a fullblown
system we would use iterators to avoid it.
@{
@h
#ifndef _MAL_MERGETABLE_
#define _MAL_MERGETABLE_
#include "mal_optimizer.h"
#include "mal_builder.h"

opt_export str MToptimizer(MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
/* #define DEBUG_MAL_MERGETABLE     show partial result */

#endif
@c
#include "mal_multitable.h"

static str matRef;
static str packRef;
static str newRef;
static str batRef;
static str selectRef;
static str joinRef;
static str aggrRef;
static str packRef;
static str printRef;
static str countRef;
static str markTRef;
static str algebraRef;
static str plusRef;
static str calcRef;
static str insertRef;
static str appendRef;
static str deleteRef;
static str setAccessRef;
static str reverseRef;
static str kdifferenceRef;

static void MTinit(){
	if(matRef == NULL){
		matRef = putName("mat",3);
		packRef = putName("pack",4);
		newRef = putName("new",3);
		batRef = putName("bat",3);
		reverseRef = putName("reverse",7);
		selectRef = putName("select",6);
		joinRef = putName("join",4);
		aggrRef = putName("aggr",4);
		printRef = putName("print",5);
		countRef = putName("count",5);
		markTRef = putName("markT",5);
		packRef = putName("pack",4);
		calcRef = putName("calc",4);
		plusRef = putName("+",1);
		algebraRef = putName("algebra",7);
		insertRef = putName("insert",6);
		appendRef = putName("append",6);
		deleteRef = putName("delete",6);
		setAccessRef = putName("setAccess",9);
		kdifferenceRef= putName("kdifference",11);
	}
}

static int
isMATalias(int idx, int mvar[], int top){
	int i;
	for(i =0; i<top; i++)
		if( mvar[i]== idx) return i;
	return -1;
}

str
MToptimizer(MalBlkPtr mb, MalStkPtr stk, InstrPtr p){
	InstrPtr *old=0, q,r, mat[256];
	int oldtop,i,j,k,l,m,mtop=0, mvar[256],tpe;
	int size,match,actions=0;
	lng clk = GDKusec();
#ifdef DEBUG_MAL_MERGETABLE     
	stream_printf(GDKout,"Start MAT optimizer\n");
	printFunction(GDKout, mb, 0);
#endif
	MTinit();

	if(p)
		removeInstruction(mb,p);

@-
First phase, collect the known MAT definitions in a stack.
@c
	for( i=0; i<mb->stop; i++){
		p= getInstrPtr(mb,i);
		if( moduleId(p)== matRef && functionId(p) == newRef){
			if( mtop == 256) {
				break;
			}
			mvar[mtop] = getArg(p,0);
			mat[mtop++]= p;
		} 
	}
@-
Now repeatedly pick one of the MATs and replaces it occurrences
with the exploded version.
Beware that we assume for the time being that MAT is used at most
once in an instruction.
@c
	for( m=0; m< mtop; m++){
		old = mb->stmt;
		oldtop= mb->stop;
#ifdef DEBUG_MAL_MERGETABLE     
	for(i=0;i<mtop;i++)
		printInstruction(GDKout,mb,mat[i],LIST_MAL_INSTR);
	stream_printf(GDKout,"MAT handles variable %d \n",m);
	printFunction(GDKout,mb,LIST_MAL_INSTR);
#endif
		
		size = (mb->stop *1.2 < mb->ssize)? mb->ssize: mb->stop *1.2;
		mb->stmt = (InstrPtr *) GDKmalloc(size  * sizeof(InstrPtr));
		memset((char*)mb->stmt, 0, size * sizeof(InstrPtr));
		mb->ssize = size ;
		mb->stop = 0;


		for( i=0; i<oldtop; i++){
			p= old[i];
@-
Beware that we assume for the time being that MAT is used at most
once in an instruction.
@c
			match=0;
			for(j=p->retc; j<p->argc; j++)
			if( getArg(p,j)== mvar[m]) match++;
			if( match== 0 ){
				pushInstruction(mb,p);
				continue;
			}
			if( match>1 )
				return throwMessage("mal.multitable","Too many MAT dependencies");

@-
Not all instructions can be replaced by the sequence. We have to
group them and check for them individually.
At first we look for the first argument. Others are dealt with
through the default case.
@c
			if(( (moduleId(p)== algebraRef && functionId(p)== selectRef) ||
				(moduleId(p)== batRef && functionId(p)==reverseRef) ||
				(moduleId(p)== batRef && functionId(p)==reverseRef) ||
				(moduleId(p)== algebraRef && functionId(p)==markTRef) ||
				(moduleId(p)== algebraRef && functionId(p)==kdifferenceRef) ||
			    (moduleId(p)== algebraRef && functionId(p)== joinRef) ||
				(moduleId(p)== batRef && functionId(p)== setAccessRef) ||
			    (moduleId(p)== batRef && functionId(p)== appendRef)  ||
			    (moduleId(p)== batRef && functionId(p)== deleteRef) 
			)  && mvar[m] == getArg(p,1)){
				r = newInstruction(mb, ASSIGNsymbol);
				setModuleId(r,matRef);
				setFunctionId(r,newRef);
				getArg(r,0)= getArg(p,0);
				tpe= getArgType(mb,p,0);
				for(k=1; k< mat[m]->argc; k++){
					if( k<mat[m]->argc-1 &&  (
						functionId(p)== insertRef ||
						functionId(p)== appendRef ))
						continue;
					q= copyInstruction(p);
					getArg(q,1) = getArg(mat[m],k);
					getArg(q,0) = newTmpVariable(mb, tpe);
					pushInstruction(mb,q);
					setVarInitialized(mb,getArg(q,0));
					r= pushArgument(mb,r,getArg(q,0));
					setVarUsed(mb,getArg(q,0),TRUE);
				}
				if( functionId(p)== insertRef ||
					functionId(p)== appendRef ||
					functionId(p)== deleteRef )
						match=1;
				else {
					match =0;
					for(j=0;j<mtop; j++)
						if( mvar[j]== getArg(p,0)) match++;
					if( match == 0){
						mvar[mtop] = getArg(p,0);
						mat[mtop++]= r;
						pushInstruction(mb,r);
					}
				}
				if( match)
					freeInstruction(r);
				actions++;
				continue;
			} 
@-
The insertions are sent to the last component of the MAT.
Selection of the proper componetn based on range descriptors will follow.
@c
			if(moduleId(p)== batRef && functionId(p)== insertRef &&
			   mvar[m] == getArg(p,1)){
				getArg(p,1) = getArg(mat[m],mat[m]->argc-1);
				pushInstruction(mb,p);
				continue;
			} 
	/*
			if( functionId(p)== printRef){
			} else
	*/
@-
You don't have to pack MATs into MATs. It suffice to change their
definition
@c
/*
			if( (moduleId(p)== matRef && functionId(p)==newRef) ||
				(moduleId(p)== matRef && functionId(p)==packRef) 
				){
				match=0;
				for(j=1; j<p->argc; j++)
					if( isMATalias(getArg(p,j),mvar,mtop)>=0) match++;
				if( match == 0)
					continue;
				r = newInstruction(mb, ASSIGNsymbol);
				setModuleId(r,matRef);
				setFunctionId(r,functionId(p));
				getArg(r,0)= getArg(p,0);
				for( j=1; j<p->argc; j++)
					if( isMATalias(getArg(p,j),mvar,mtop)<0) 
						r= pushArgument(mb,r,getArg(p,j));
					else {
						for(k=0; k<mtop; k++)
						if( mvar[k] == getArg(p,j))
						for(l=1; l<mat[k]->argc; l++)
							r= pushArgument(mb,r, getArg(mat[k],l));
				}
stream_printf(GDKout,"update def\n");
printInstruction(GDKout,mb,p,LIST_MAL_INSTR);
printInstruction(GDKout,mb,r,LIST_MAL_INSTR);
				pushInstruction(mb,r);
				continue;
			}
*/
@-
The MAT argument could also occur as the second one.
@c
			if( moduleId(p)==algebraRef && functionId(p)== joinRef &&
				mvar[m]== getArg(p,2)){
				r = newInstruction(mb, ASSIGNsymbol);
				setModuleId(r,matRef);
				setFunctionId(r,newRef);
				getArg(r,0)= getArg(p,0);
				tpe= getArgType(mb,p,0);

				for(k=1; k< mat[m]->argc; k++){
					q= copyInstruction(p);
					getArg(q,2) = getArg(mat[m],k);
					getArg(q,0) = newTmpVariable(mb, tpe);
					pushInstruction(mb,q);
					setVarInitialized(mb,getArg(q,0));
					r= pushArgument(mb,r,getArg(q,0));
					setVarUsed(mb,getArg(q,0),TRUE);
				}
				match =0;
				for(j=0;j<mtop; j++)
				if( mvar[j]== getArg(p,0)) match++;
				if( match == 0){
					mvar[mtop] = getArg(p,0);
					mat[mtop++]= r;
					pushInstruction(mb,r);
				}
				actions++;
				continue;
			} 
@-
Handle the rewrite v:=aggr.count(b)
@c
			if( moduleId(p)==aggrRef && functionId(p)== countRef &&
				mvar[m] == getArg(p,1)){
				r = newInstruction(mb,ASSIGNsymbol);
				getArg(r,0)= getArg(p,0);
				pushInt(mb,r,0);
				pushInstruction(mb,r);
				for(k=1; k< mat[m]->argc; k++){
					int v= newTmpVariable(mb,TYPE_int);
					q= newInstruction(mb,ASSIGNsymbol);
					setModuleId(q,aggrRef);
					setFunctionId(q,countRef);
					getArg(q,0)= v;
					setVarUsed(mb,v,TRUE);
					setVarInitialized(mb,v);
					q= pushArgument(mb,q,getArg(mat[m],k));
					pushInstruction(mb,q);

					q= newInstruction(mb,ASSIGNsymbol);
					setModuleId(q,calcRef);
					setFunctionId(q,plusRef);
					getArg(q,0)= getArg(r,0);
					q= pushArgument(mb,q,getArg(r,0));
					q= pushArgument(mb,q,v);
					pushInstruction(mb,q);
				}
				continue;
			} 
@-
All other instructions should be checked for a MAT dependency.
It require the MAT to be materialized. We drop the MAT
afterwards for further consideration.
@c
MATdefault:
			for( k= p->retc; k<p->argc; k++)
			if( mvar[m] == getArg(p,k) ){
#ifdef DEBUG_MAL_MERGETABLE     
				stream_printf(GDKout,"Dependency resolution k=%d\n",k);
				printInstruction(GDKout,mb,p,0);
				printInstruction(GDKout,mb,mat[j],0);
#endif
				r = newInstruction(mb, ASSIGNsymbol);
				setModuleId(r,matRef);
				setFunctionId(r,packRef);
				getArg(r,0)= getArg(mat[m],0);
				for(l=mat[m]->retc; l< mat[m]->argc; l++){
					r= pushArgument(mb,r, getArg(mat[m],l));
				}
				pushInstruction(mb,r);

				for(j=m; j<mtop-1; j++){
					mat[j]= mat[j+1];
					mvar[j]= mvar[j+1];
				}
				mtop--; m--;
				actions++;
				break;
			}

			pushInstruction(mb,p);
		}
		GDKfree(old);
	}
@-
As a final optimization, we could remove the mal.new definitions,
because they are not needed for the execution.
For the time being, they are no-ops.
@c
	(void) stk; 
	optimizerCheck(mb, "optimizer.multitable", actions, GDKusec() - clk);
#ifdef DEBUG_MAL_MERGETABLE     
	stream_printf(GDKout,"Result of multi table optimizer\n");
	printFunction(GDKout, mb, 0);
#endif

	return MAL_SUCCEED;
}
@}
