@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
@' Copyright August 2008-2009 MonetDB B.V.
@' All Rights Reserved.

@f opt_dictionary
@- The dictionary optimizer
Datawarehouse applications are organized as star-schemas, where dimension
tables factor out common recurring bits-and-pieces. For example, 
the list of US states, cities, regions, etc..
To get the most compact and still performance wise fast datawarehouse,
a DBA should analyse the database and repeatedly finetune the decisions
towards a compact star schema.

The dictionary optimizer is meant to alleviate this task by maintaining
dictionaries for organizing static data sets and replace their database
valued by references into the index. For example, a string column
with all US states can be replaced by a tinyint column with indices
into the dictionary table.

The MonetDB approach is to mimick this behavior using straightforward
dictionary encodings.
The optimizer maintains a list of dictionaries, represented by a persistent
catalog BAT.

An example of the optimizer is shown below, which uses a selection
on one dictionary compressed column to collect values of
the second one without materializing the original table.
@verbatim
  a:bat[:oid,:str]:= sql.bind("sys","tab","col",0);
  d:bat[:oid,:int]  := sql.bind("sys","tab","col",1);
  x := algebra.kdifference(b,d);
  e:bat[:oid,:int]  := sql.bind("sys","tab","col",2);
  y := algebra.kunion(x,e);
  c := algebra.select(y,0,2);
  io.print(c);
@end verbatim
and replaces it based on the catalog knowledge
that the base table is organised as dictionary 
@verbatim
    (_14:bat[:oid,:bte] ,_15:bat[:bte,:int] ) := dictionary.bind("sys/tab/col/0");
    d:bat[:oid,:int]  := sql.bind("sys","tab","col",1);
    (_17,_18) := dictionary.expand(_14,_15,d);
    _19 := dictionary.encode(_18,d);    
    _20 := algebra.kdifference(_14,_19);
    e:bat[:oid,:int]  := sql.bind("sys","tab","col",2);
    (_21,_22) := dictionary.expand(_20,_15,e);
    _23 := dictionary.encode(_22,e);    
    _24 := algebra.kunion(_20,_23);     
    _25 := algebra.select(_15,0,2);     
    c := algebra.join(_24,_25);         
    io.print(c);                        
@end verbatim
The insertion/update deltas may lead to possible updates of the dictionary value list,
which is taken care of by expand(). It returns a fresh local dictionary pair;
it can not be found in the persistent dictionary catalog.
The next step is to encode the list of tuples to be included in the index itself using encode().
The remainder reflects a common SQL block, such that the selection is executed against
the compressed table. Only when needed in the print(), it will be expanded to include
the OIDs needed.

The source BAT remains in existence, but will be emptied. This way we can always
migrate the dictionary back into the persistent table without disturbing
the SQL catalog.
Ultimately, the optimizer should detect opportunities for replacement of columns
automatically.

Pushing the dictionary information through the plan is organized around a subset
of the MAL operators. As soon as we find any other instruction, the dictionary
is expanded to its normal BAT for further processing.

@-
The key challenge is to determine when to move a BAT into its dictionary format.
Two situations come to mind. First, during bulk copying we can start with
the dictionary compression.
Alternatively, we attempt dictionary compression as part of query processing.
Selections over non-compressed base tables are time-consuming,
they drag them into memory, and thus a good moment to perform a test.
The first approach is to take action when the base table memory footprint
is significant.
@{
@mal
module dictionary;

command bind(nme:str) (idx:bat[:oid,:any_1], val:bat[:any_1,:any_2])
address DICTbind
comment "Localise the dictionary";

command new(nme:str,b:bat[:any_1,:any_2]) 
address DICTnew
comment "Add a new dictionary table";

command drop(nme:str)
address DICTdrop
comment "Remove the dictionary entry";

command expand(idx:bat[:oid,:any_1], val:bat[:any_1,:any_2], b:bat[:oid,:any_2]) (ridx:bat[:oid,:any_1], rval:bat[:any_1,:any_2])
address DICTexpand
comment "Extend the dictionary with the values in b. This may trigger a partial recompilation of the MAL program when the storage type :any_1
is not sufficient anymore.";

command encode(val:bat[:any_1,:any_2], b:bat[:oid,:any_2]):bat[:oid,:any_1]
address DICTencode
comment "Use the dictionary to encode a table b.";

command compress{unsafe}(s:str, b:bat[:any_1,:any_2]) 
address DICTcompress
comment "Try to replace a table by its dictionary equivalent.";

pattern optimizer.dictionary():str
address OPTdictionary;
pattern optimizer.dictionary(mod:str, fcn:str):str
address OPTdictionary
comment "Capitalize dictionary encodings ";

@h
#ifndef _OPT_DICTIONARY_
#define _OPT_DICTIONARY_
#include "opt_prelude.h"
#include "opt_support.h"

#define DEBUG_OPT_DICTIONARY 
opt_export str DICTbind(int *idx, int *val, str * nme);
opt_export str DICTexpand(int *ridx, int *rval, int *idx, int *val, int *bid);
opt_export str DICTencode(int *ridx, int *val, int *bid);
opt_export str DICTcompress(int *ret, str *nme, int *bid);
opt_export str DICTnew(int *idx, str *nme, int *bid);
opt_export str DICTdrop(int *ret, str *nme);

@c
#include "mal_config.h"
#include "opt_prelude.h"
#include "opt_dictionary.h"
#include "mal_instruction.h"
#include "mal_interpreter.h"

static BAT *dictIndex, *dictValue;

static int DICTinit(void);

static int 
DICTfind(int *idx, int *val, str nme)
{
	BUN p;
	BATiter bidx = bat_iterator(dictIndex);
	BATiter bval = bat_iterator(dictValue);
	p = BUNfnd(BATmirror(dictIndex), (ptr) nme);
	if ( p != BUN_NONE ){
		*idx = *(int*) BUNhead(bidx, p);
		*val = *(int*) BUNhead(bval, BUNfnd(BATmirror(dictValue), (ptr) nme ) );
		return 0;
	}
	return -1;
}

int
OPTdictionaryImplementation(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	int vlim, i,j, actions=0;
	int *idx, *val;
	InstrPtr *old,q, qq;
	int x, v, limit;
	BUN p;
	char buf[BUFSIZ];
	str *names;
	BAT *bi, *bv;
	str dictionaryRef = putName("dictionary",10);

	(void) cntxt;
	(void) stk;
	(void) pci;
	DICTinit();
	limit = mb->stop;
	old = mb->stmt;
	
    if ( newMalBlkStmt(mb, mb->ssize) < 0)
        return 0;
	vlim = mb->vtop;
	names = (str *) GDKzalloc(vlim * sizeof(str*));
	if ( names == 0)
		return 0;

	idx = (int*) GDKzalloc(mb->vtop * sizeof(int));
	val = (int*) GDKzalloc(mb->vtop * sizeof(int));
	for (i=0; i< limit; i++){
        q= old[i];

		/* replace the BAT if a dictionary exists */
		buf[0]= 0;
		if ( getModuleId(q) == sqlRef && getFunctionId(q) == bindRef)
			snprintf(buf,BUFSIZ,"%s/%s/%s/%d", 
				getVarConstant(mb,getArg(q,1)).val.sval, getVarConstant(mb, getArg(q,2)).val.sval,
				getVarConstant(mb,getArg(q,3)).val.sval, getVarConstant(mb, getArg(q,4)).val.ival);
		else
		if ( getModuleId(q) == sqlRef && getFunctionId(q) == binddbatRef)
			snprintf(buf,BUFSIZ,"%s/%s/%s", 
				getVarConstant(mb,getArg(q,1)).val.sval, getVarConstant(mb,getArg(q,2)).val.sval, getVarConstant(mb,getArg(q,3)).val.sval);
		else
		if ( getModuleId(q) == sqlRef && getFunctionId(q) == bindidxRef)
			snprintf(buf,BUFSIZ,"%s/%s/%s", 
				getVarConstant(mb, getArg(q,1)).val.sval, getVarConstant(mb, getArg(q,2)).val.sval, getVarConstant(mb,getArg(q,3)).val.sval);

		if ( buf[0] ){
			BATiter bidx = bat_iterator(dictIndex);
			BATiter bval = bat_iterator(dictValue);

			names[getArg(q,0)]= (str) GDKstrdup(buf);
			p = BUNfnd(BATmirror(dictIndex), (ptr) buf);
			if ( p != BUN_NONE ){
				x = *(int*) BUNhead(bidx, p);
				v = *(int*) BUNhead(bval, BUNfnd(BATmirror(dictValue), (ptr) buf ) );
#ifdef DEBUG_OPT_DICTIONARY 
				stream_printf(GDKout, "#Located a dictionary %s ? %s %d %d\n",buf, (p?"ok":"no"), x,v);
#endif
				/* replace the sql.bind */
				bi = BATdescriptor(x);
				if ( bi == NULL){
					GDKfree(idx);
					GDKfree(val);
					return 0;
				}
				bv = BATdescriptor(v);
				if ( bv == NULL){
					BBPreleaseref(bi->batCacheid);
					GDKfree(idx);
					GDKfree(val);
					return 0;
				}
				/* construct: (bi:bat[:oid,:type], bv:bat[:type,:any2]):= dictionary.bind(name); */
				qq = newStmt(mb,"dictionary",bindRef);
				qq = pushArgument(mb,qq, newTmpVariable(mb,newBatType(bi->ttype,bv->ttype)));
				qq->retc++;
				qq = pushStr(mb,qq,buf);
				setVarType(mb, getArg(qq,0), newBatType(TYPE_oid,bi->ttype));
				setVarUDFtype(mb, getArg(qq,0));
				setVarUDFtype(mb, getArg(qq,1));
				/* let's remember them */
				idx[getArg(q,0)] = getArg(qq,0);
				val[getArg(q,0)] = getArg(qq,1);
				actions++;
				continue;
			}
			pushInstruction(mb,q);
		} else {
@-
We have to re-cast each instruction based on a possible dictionary 
representation of an argument. For some operators we may postpone
reconstruction and introduce a new dictionary pair.
@c
			if (  getModuleId(q) == algebraRef ){
				if ( (getFunctionId(q) == selectRef ||
					 getFunctionId(q) == uselectRef ||
					 getFunctionId(q) == thetaselectRef ||
					 getFunctionId(q) == thetauselectRef ) ){
					if ( idx[getArg(q,1)] && val[getArg(q,1)] ){
						j = getArg(q,0);
						idx[j] = idx[getArg(q,1)];
						getArg(q,1) = val[getArg(q,1)];
						getArg(q,0)= newTmpVariable(mb, getVarType(mb,getArg(q,1)));
						val[j] = getArg(q,0);
						pushInstruction(mb,q);
#ifdef DEBUG_OPT_DICTIONARY 
							stream_printf(GDKout,"dictionary %d %s -> %d %d\n", j, getVarName(mb,j), idx[j],val[j]);
#endif
					} else
					if ( names[getArg(q,0)] ) {
						pushInstruction(mb,q);
						qq = newStmt(mb, dictionaryRef, putName("compress",8));
						qq = pushStr(mb,qq,buf);
						pushArgument(mb,qq, getArg(q,1));
					}
					actions++;
					continue;
				}
				if ( getFunctionId(q) == kdifferenceRef  ||
					 getFunctionId(q) == kunionRef ){
@-
The arguments can be singular or both ref to a dictionary pair.
We deal with the most prominent case provided by SQL only. 
@c
					if ( (idx[getArg(q,1)] || val[getArg(q,1)]) && idx[getArg(q,2)] == 0){
						/* (aidxnew,avalnew) := dictionary.expand(aidx,aval,b) */

						qq= newStmt(mb,dictionaryRef,"expand");
						setVarType(mb, getArg(qq,0), getVarType(mb,idx[getArg(q,1)]));
						qq= pushArgument(mb,qq,newTmpVariable(mb, getVarType(mb,val[getArg(q,1)])) );
						qq->retc++;
						qq = pushArgument(mb,qq, idx[getArg(q,1)]);
						qq = pushArgument(mb,qq, val[getArg(q,1)]);
						qq = pushArgument(mb,qq, getArg(q,2));

						j = getArg(q,0);
						idx[j] = getArg(qq,0);
						val[j] = getArg(qq,1);
						actions++;
						/* bidx := dictionary.encode(aval,b) */
						qq = newStmt(mb,"dictionary","encode");
						qq = pushArgument(mb,qq, val[j]);
						qq = pushArgument(mb,qq, getArg(q,2));

						pushInstruction(mb,q);
						getArg(q,1) = idx[j];
						getArg(q,0)= newTmpVariable(mb, getVarType(mb,getArg(q,1)));
						idx[j] = getArg(q,0);
						getArg(q,2) = getArg(qq,0);
#ifdef DEBUG_OPT_DICTIONARY 
						stream_printf(GDKout,"dictionary %d %s -> %d %d\n", j, getVarName(mb,j), idx[j],val[j]);
#endif
						continue;
					}
				}
@-
Marking the dictionary pair idx(oid,bte) and val(bte,int) can be realised by performing
a semijoin on idx followed by the markT. The value is of no interested.
@c
				if ( getFunctionId(q) == markTRef && (idx[getArg(q,1)] || val[getArg(q,1)]) ){
					qq= newStmt(mb,batRef,reverseRef);
					qq= pushArgument(mb, qq, idx[getArg(q,1)]);
					j = getArg(qq,0);

					qq= newStmt(mb,algebraRef,semijoinRef);
					qq= pushArgument(mb, qq, j);
					qq= pushArgument(mb, qq, val[getArg(q,1)]);
					j = getArg(qq,0);

					qq= newStmt(mb,batRef,reverseRef);
					qq= pushArgument(mb, qq, j);
					actions++;
					getArg(q,1) = getArg(qq,0);
					pushInstruction(mb,q);
					continue;
				}
@-
Combination of the next column with the pivot table.
@c
				if ( getFunctionId(q) == leftjoinRef && (idx[getArg(q,2)] || val[getArg(q,2)]) ){
					j = getArg(q,0);
					val[j] = val[getArg(q,2)];
					getArg(q,2) = idx[getArg(q,2)];
					idx[j] = newTmpVariable(mb, newBatType(getHeadType(getVarType(mb,getArg(q,1))), getTailType(getVarType(mb,getArg(q,2)))) );
					pushInstruction(mb,q);
					getArg(q,0) = idx[j];
					continue;
				}
			} 
			/* default cases call for source reconstruction */
			for (j = q->retc; j < q->argc; j++)
			if ( idx[getArg(q,j)] || val[getArg(q,j)]){
				/* recast void to type needed for the join */
				qq= newStmt(mb,algebraRef,joinRef);
				getArg(qq,0) = getArg(q,j);
				setVarType(mb,getArg(qq,0), newBatType(getHeadType(getVarType(mb,idx[getArg(q,j)])), getTailType(getVarType(mb,val[getArg(q,j)]))));
				qq= pushArgument(mb,qq,idx[getArg(q,j)]);
				qq= pushArgument(mb,qq,val[getArg(q,j)]);
				idx[getArg(q,j)] = 0;
				val[getArg(q,j)] = 0;
			}
			pushInstruction(mb,q);
		}
	}
#ifdef DEBUG_OPT_DICTIONARY 
	printFunction(cntxt->fdout,mb,0,LIST_MAL_ALL);
#endif
	for ( i = 0; i<vlim; i++)
	if ( names[i])
		GDKfree(names[i]);
	GDKfree(idx);
	GDKfree(val);
	return actions;
}
@-
@include optimizerWrapper.mx
@h
@:exportOptimizer(dictionary)@
#endif
@c
#include "opt_statistics.h"

@:wrapOptimizer(dictionary,OPT_CHECK_ALL)@
@-
Dictionary implementation.
@c

void 
DICTcommit(BAT *b1, BAT *b2)
{
	BAT *bl = BATnew(TYPE_void, TYPE_str, 10);
	BATseqbase(bl,0);
	BUNappend(bl, BBPname(b1->batCacheid), FALSE);
	BUNappend(bl, BBPname(b2->batCacheid), FALSE);
	TMsubcommit(bl);
	BBPreclaim(bl);
}

int
DICTinit(void)
{
    BAT *b, *bn;
	if ( dictIndex == NULL){
		mal_set_lock(mal_contextLock, "dictionary");
		if ( dictIndex ){
			/* parallel initialization action */
			mal_unset_lock(mal_contextLock, "dictionary");
			return 0;
		}
		b = BATdescriptor(BBPindex("dictIndex"));
		if (b) {
			bn = BATdescriptor(BBPindex("dictValue"));
			if (bn ){
				dictIndex = b;
				dictValue = bn;
			} else
				BBPreleaseref(b->batCacheid);
			mal_unset_lock(mal_contextLock, "dictionary");
			return 0;
		}

		b = BATnew(TYPE_int,TYPE_str, 255);
		if (b == NULL) {
			mal_unset_lock(mal_contextLock, "dictionary");
			return -1;
		}
		bn = BATnew(TYPE_int, TYPE_str, 255);
		if (bn == NULL) {
			BBPreleaseref(b->batCacheid);
			mal_unset_lock(mal_contextLock, "dictionary");
			return -1;
		}

		BATkey(b, TRUE);
		BBPrename(b->batCacheid, "dictIndex");
		BATmode(b, PERSISTENT);
		BBPkeepref(b->batCacheid);
		dictIndex = b;

		BATkey(bn, TRUE);
		BBPrename(bn->batCacheid, "dictValue");
		BATmode(bn, PERSISTENT);
		BBPkeepref(bn->batCacheid);
		dictValue = bn;
		mal_unset_lock(mal_contextLock, "dictionary");
		DICTcommit(dictIndex,dictValue);
	}
    return 0;
}

str DICTbind(int *idx, int *val, str * nme)
{
	*idx = *val = 0;
	if( DICTinit() )
		throw(MAL,"dictionary.bind","No catalog table");
	if ( DICTfind(idx, val, *nme) )
		throw(MAL,"dictionary.bind","Not found in catalog table");
#ifdef DEBUG_OPT_DICTIONARY 
	stream_printf(GDKout,"#dictionary.bind %d %d\n",*idx, *val);
#endif
	return MAL_SUCCEED;
}

static int
DICTtype(size_t cnt){
	if ( cnt < 256 )
		return TYPE_bte;
	if ( cnt < 1<<15 )
		return TYPE_sht;
	if ( cnt < (size_t) 1<<31 )
		return TYPE_int;
	return TYPE_lng;
}
str DICTnew(int *ret, str *nme, int *bid)
{
	int idx,val, typ;
	size_t cnt;
	BAT *b, *bo, *bx, *bv;
	BATiter bi, bii;
	BUN p,q;

	if( DICTinit() )
		throw(MAL,"dictionary.new","No catalog table");
	if ( DICTfind(&idx,&val,*nme) == 0)
		throw(MAL,"dictionary.new", "duplicate entry");
	b = (BAT *) BATdescriptor(*bid);
    if (b == 0)
        /* Simple ignore the binding if you can;t find the bat */
        throw(MAL, "dict.new", RUNTIME_OBJECT_MISSING);

	bo= BATkunique(b);
	if ( bo == NULL){
		BBPreleaseref(b->batCacheid);
		throw(MAL,"dict.new","Can not access unique list");
	}
	BATorder(bo);
	
	cnt = BATcount(bo);
	typ= DICTtype(cnt);
	if( typ == TYPE_lng){
		/* don't create a dictionary */
		BBPreleaseref(b->batCacheid);
		BBPreleaseref(bo->batCacheid);
		return MAL_SUCCEED;
	}
	bx =  BATnew(TYPE_void, typ, BATcount(b));
	BATseqbase(bx,0);
	bv =  BATnew(typ, b->ttype, BATcount(b));
	/* create the dictionary representation */
@=
Factor out the index construction by type
@= encode
	{	@1 *v;
		ptr w;
		/* complete the index table */
		bi = bat_iterator(b);
		bii = bat_iterator(bv);
		v = (@1*) Tloc(bx, BUNfirst(bx));
		BATloop(b,p,q){
			w= BUNtail(bi,p);
			*v++ = *(@1*) BUNhead(bii,BUNfnd(BATmirror(bv), w));
		}
	}
@= define
	{	@1 o;
		/* complete value table */
		bi = bat_iterator(@2);
		o = 0;
		BATloop(@2,p,q){
			bunfastins(bv, &o, BUNtail(bi,p));
			o++;
		}
	}
@= mkindex
	@:define(@1,@2)@
	@:encode(@1,@2)@
	break;
@c
	switch(typ){
	case TYPE_bte: @:mkindex(bte,bo)@
	case TYPE_sht: @:mkindex(sht,bo)@
	case TYPE_int: @:mkindex(int,bo)@
	}
	BATsetcount(bx, BATcount(b));
	if (!(bx->batDirty&2)) bx = BATsetaccess(bx, BAT_READ);

	bv->tsorted = bo->tsorted;
	bv->tdense = bo->tdense;
	if (!(bv->batDirty&2)) bv = BATsetaccess(bv, BAT_READ);
	BUNins(dictIndex,&bx->batCacheid, *nme, FALSE);
	BUNins(dictValue,&bv->batCacheid, *nme, FALSE);
	BATmode(bx, PERSISTENT);
	BATmode(bv, PERSISTENT);
	BBPkeepref(bx->batCacheid);
	BBPkeepref(bv->batCacheid);
	BBPreleaseref(*bid);
	BBPreleaseref(bo->batCacheid);
	DICTcommit(bx,bv);
	DICTcommit(dictIndex,dictValue);
	/* now the original BAT can be cleared */
	BATclear(b);
#ifdef DEBUG_OPT_DICTIONARY 
	stream_printf(GDKout,"#dictionary.new  %d->%d %d\n",typ,bx->batCacheid, bv->batCacheid);
#endif
	(void) ret;
	return MAL_SUCCEED;
bunins_failed:
	BBPreleaseref(bx->batCacheid);
	BBPreleaseref(bv->batCacheid);
	BBPreleaseref(bo->batCacheid);
	BBPreleaseref(*bid);
	throw(MAL, "dictionary.new", OPERATION_FAILED " During bulk operation");
}

@-
Extending a dictionary could lead to overflow of the reference type.
This means, we end up with larger idx tables.
This should trigger a partial re-compilation of the MAL program.
@c
str 
DICTexpand(int *ridx, int *rval, int *idx, int *val, int *bid)
{
	BAT *bx, *bv, *b, *bn, *rv;
	BATiter bi, bii;
	BUN p,q;

	b = (BAT *) BATdescriptor(*bid);
    if (b == 0)
        throw(MAL,"dictionary.expand",RUNTIME_OBJECT_MISSING);
	bx = (BAT *) BATdescriptor(*idx);
    if (bx == 0){
		BBPreleaseref(b->batCacheid);
        throw(MAL,"dictionary.expand",RUNTIME_OBJECT_MISSING);
	}
	bv = (BAT *) BATdescriptor(*val);
    if (bv == 0){
		BBPreleaseref(b->batCacheid);
		BBPreleaseref(bx->batCacheid);
        throw(MAL,"dictionary.expand",RUNTIME_OBJECT_MISSING);
	}

	/* check how many new elements should be added to the val */
	bn = BATsemijoin(BATmirror(b), BATmirror(bv));
#ifdef DEBUG_OPT_DICTIONARY 
	stream_printf(GDKout,"#dictionary.expand " SZFMT " " SZFMT " " SZFMT "\n", 
		BATcount(bv), BATcount(b), BATcount(bn));
#endif
	rv = bv;
	bv= BATcopy(bv, DICTtype(BATcount(bv) + BATcount(bn)), bv->ttype,TRUE);
	BBPreleaseref(bn->batCacheid);
	BBPreleaseref(rv->batCacheid);
	if (bv == NULL){
		BBPreleaseref(b->batCacheid);
		BBPreleaseref(bx->batCacheid);
        throw(MAL,"dictionary.expand",RUNTIME_OBJECT_MISSING);
	}

	rv = bx;
	bx= BATcopy(bx, bx->htype, bx->ttype,TRUE);
	if (bx == NULL)
        throw(MAL,"dictionary.expand",RUNTIME_OBJECT_MISSING);
	BBPreleaseref(rv->batCacheid);

	switch(bv->htype){
	case TYPE_bte: @:mkindex(bte,b)@
	case TYPE_sht: @:mkindex(sht,b)@
	case TYPE_int: @:mkindex(int,b)@
	}
	
	BBPkeepref(*ridx = bx->batCacheid);
	BBPkeepref(*rval = bv->batCacheid);
	return MAL_SUCCEED;
bunins_failed:
	BBPreleaseref(bx->batCacheid);
	BBPreleaseref(bv->batCacheid);
	throw(MAL, "dictionary.new", OPERATION_FAILED " During bulk operation");
}
@-
Use a value table to encode the BAT.
@c
str 
DICTencode(int *ridx, int *vid, int *bid)
{
	BAT *b, *bv, *bx;
	BATiter bi, bii;
	BUN p,q;

	b= (BAT *) BATdescriptor(*bid);
    if (b == 0)
        throw(MAL,"dictionary.expand",RUNTIME_OBJECT_MISSING);
	bv= (BAT *) BATdescriptor(*vid);
    if (bv == 0){
		BBPreleaseref(b->batCacheid);
        throw(MAL,"dictionary.expand",RUNTIME_OBJECT_MISSING);
	}

	bx = BATnew(TYPE_void, bv->htype, BATcount(b));
	switch(bv->htype){
	case TYPE_bte: @:encode(bte)@
	case TYPE_sht: @:encode(sht)@
	case TYPE_int: @:encode(int)@
	}
	BBPkeepref(*ridx= bx->batCacheid);
	BBPreleaseref(b->batCacheid);
	BBPreleaseref(bv->batCacheid);
	return MAL_SUCCEED;
}

str DICTcompress(int *ret, str *nme, int *bid)
{
	BAT *b, *bs = 0, *bh = 0;
	double ratio;

	b = (BAT *) BATdescriptor(*bid);
    if (b == 0)
        throw(MAL,"dictionary.convert",RUNTIME_OBJECT_MISSING);
	/* conversion is only relevant for larger tables */
	/* determine the memory footprint */

	/* alternatively, we sample the table */
	bs= BATsample(b, (size_t) 1000);
	if ( bs )
		bh= BAThistogram(bs);
	if ( bs && bh )
		ratio = (double) BATcount(bh) / (double) BATcount(bs);
#ifdef DEBUG_OPT_DICTIONARY 
	if ( bs && bh )
		stream_printf(GDKout,"dictionary.convert sample " SZFMT " " SZFMT" %f\n", BATcount(bs), BATcount(bh),ratio);
#endif
	BBPreleaseref(b->batCacheid);
	if ( bs)
		BBPreleaseref(bs->batCacheid);
	if ( bh)
		BBPreleaseref(bh->batCacheid);
	return DICTnew(ret,nme,bid);
}

str DICTdrop(int *ret, str *nme)
{
	if( DICTinit() )
		throw(MAL,"dictionary.drop","No catalog table");
	(void) ret;
	(void) nme;
	throw(MAL,"dictionary.drop", PROGRAM_NYI);
}
@}
