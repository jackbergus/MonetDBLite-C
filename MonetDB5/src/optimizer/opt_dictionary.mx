@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
@' Copyright August 2008-2009 MonetDB B.V.
@' All Rights Reserved.

@f opt_dictionary
@- The dictionary optimizer
Datawarehouse applications are organized as star-schemas, where dimension
tables factor out common recurring bits-and-pieces. For example, 
the list of US states, cities, regions, etc..
To get the most compact and still performance wise fast datawarehouse,
a DBA should analyse the database and repeatedly finetune the decisions
towards a compact star schema.

The dictionary optimizer is meant to alleviate this task by maintaining
dictionaries for organizing static data sets and replace their database
valued by references into the index. For example, a string column
with all US states can be replaced by a tinyint column with indices
into the dictionary table.

The MonetDB approach is to mimick this behavior using straightforward
dictionary encodings.
The optimizer maintains a list of dictionaries, represented by a persistent
catalog BAT.

An example of the optimizer is shown below, which uses a selection
on one dictionary compressed column to collect values of
the second one without materializing the original table.
@verbatim
  a:bat[:oid,:str]:= sql.bind("sys","tab","col",0);
  d:bat[:oid,:int]  := sql.bind("sys","tab","col",1);
  x := algebra.kdifference(b,d);
  e:bat[:oid,:int]  := sql.bind("sys","tab","col",2);
  y := algebra.kunion(x,e);
  c := algebra.select(y,0,2);
  io.print(c);
@end verbatim
and replaces it based on the catalog knowledge
that the base table is organised as dictionary 
@verbatim
    (_14:bat[:oid,:bte] ,_15:bat[:bte,:int] ) := dictionary.bind("sys/tab/col/0");
    d:bat[:oid,:int]  := sql.bind("sys","tab","col",1);
    _18 := dictionary.expand(_15,d);
    _19 := dictionary.encode(_18,d);    
    _20 := algebra.kdifference(_14,_19);
    e:bat[:oid,:int]  := sql.bind("sys","tab","col",2);
    _22 := dictionary.expand(_15,e);
    _23 := dictionary.encode(_22,e);    
    _24 := algebra.kunion(_20,_23);     
    _25 := algebra.select(_15,0,2);     
    c := algebra.join(_24,_25);         
    io.print(c);                        
@end verbatim
The insertion/update deltas may lead to possible updates of the dictionary value list,
which is taken care of by expand(). It returns a fresh local dictionary pair;
it can not be found in the persistent dictionary catalog.
The next step is to encode the list of tuples to be included in the index itself using encode().
The remainder reflects a common SQL block, such that the selection is executed against
the compressed table. Only when needed in the print(), it will be expanded to include
the OIDs needed.

The source BAT remains in existence, but will be emptied. This way we can always
migrate the dictionary back into the persistent table without disturbing the BAT catalog.
Ultimately, the optimizer should detect opportunities for replacement of columns
automatically.

Pushing the dictionary information through the plan is organized around a subset
of the MAL operators. As soon as we find any other instruction, the dictionary
is expanded to its normal BAT for further processing.

@-
The key challenge is to determine when to move a BAT into its dictionary format.
Two situations come to mind. First, during bulk copying we can start with
the dictionary compression.
Alternatively, we attempt dictionary compression as part of query processing.
Selections over non-compressed base tables are time-consuming,
they drag them into memory, and thus a good moment to perform a test.
The first approach is to take action when the base table memory footprint
is significant.

The implementation is somewhat simplified by the fact that we already
know that the plan is semantically correct before the optimizer
starts its work.
@{
@mal
module dictionary;

command bind(nme:str) (idx:bat[:oid,:any_1], val:bat[:any_1,:any_2])
address DICTbind
comment "Localise the dictionary";

command expand(val:bat[:any_1,:any_2], b:bat[:oid,:any_2]):bat[:any_1,:any_2]
address DICTexpand
comment "Extend the dictionary with the values in b. This may trigger a partial recompilation of the MAL program when the storage type :any_1
is not sufficient anymore.";

command encode(val:bat[:any_1,:any_2], b:bat[:oid,:any_2]):bat[:oid,:any_1]
address DICTencode
comment "Use the dictionary to encode a table b.";

pattern compress{unsafe}(s:str, b:bat[:any_1,:any_2]) 
address DICTcompress
comment "Try to replace a table by its dictionary equivalent.";

command decompress{unsafe}(nme:str)
address DICTdecompress
comment "Remove the dictionary entry";

command group(idx:bat[:oid,:any_1], val:bat[:any_1,:any_2]) :bat[:oid,:any_2]
address DICTgroupid
comment "Obtain a representative oid per value from the index";

pattern optimizer.dictionary():str
address OPTdictionary;
pattern optimizer.dictionary(mod:str, fcn:str):str
address OPTdictionary
comment "Capitalize dictionary encodings ";

@h
#ifndef _OPT_DICTIONARY_
#define _OPT_DICTIONARY_
#include "opt_prelude.h"
#include "opt_support.h"

/* #define DEBUG_OPT_DICTIONARY  */
opt_export str DICTbind(int *idx, int *val, str * nme);
opt_export str DICTexpand(int *rval, int *val, int *bid);
opt_export str DICTencode(int *ridx, int *val, int *bid);
opt_export str DICTcompress(int *idx, str *nme, int *bid);
opt_export str DICTdecompress(int *ret, str *nme);
opt_export str DICTgroupid(int *ret, int *idx, int *val);

@c
#include "mal_config.h"
#include "opt_prelude.h"
#include "opt_dictionary.h"
#include "mal_instruction.h"
#include "mal_interpreter.h"

#define isDiction(X) (idx[X] && val[X])

static BAT *dictIndex, *dictValue, *dictBase;

static int DICTinit(void);

static int 
DICTfind(int *idx, int *val, int *base, str nme)
{
	BUN p;
	BATiter bidx = bat_iterator(dictIndex);
	BATiter bval = bat_iterator(dictValue);
	BATiter bbase = bat_iterator(dictBase);
	p = BUNfnd(BATmirror(dictIndex), (ptr) nme);
	if ( p != BUN_NONE ){
		*idx = *(int*) BUNhead(bidx, p);
		*val = *(int*) BUNhead(bval, BUNfnd(BATmirror(dictValue), (ptr) nme ) );
		*base = *(int*) BUNhead(bbase, BUNfnd(BATmirror(dictBase), (ptr) nme ) );
		return 0;
	}
	return -1;
}

int
OPTdictionaryImplementation(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	int i,j, actions=0;
	int *idx, *val;
	InstrPtr *old,q, qq;
	int x, v, limit;
	BUN p;
	char buf[BUFSIZ];
	BAT *bi, *bv;
	str dictionaryRef = putName("dictionary",10);

	(void) cntxt;
	(void) stk;
	(void) pci;
	DICTinit();
	limit = mb->stop;
	old = mb->stmt;
	
    if ( newMalBlkStmt(mb, mb->ssize) < 0)
        return 0;

	idx = (int*) GDKzalloc(mb->vtop * sizeof(int));
	if ( idx == 0)
		return 0;
	val = (int*) GDKzalloc(mb->vtop * sizeof(int));
	if ( val == 0) {
		GDKfree(idx);
		return 0;
	}
	for (i=0; i< limit; i++){
        q= old[i];

		/* replace the BAT if a dictionary exists */
		buf[0]= 0;
		if ( getModuleId(q) == sqlRef && getFunctionId(q) == bindRef)
			snprintf(buf,BUFSIZ,"%s/%s/%s/%d", 
				getVarConstant(mb,getArg(q,1)).val.sval, getVarConstant(mb, getArg(q,2)).val.sval,
				getVarConstant(mb,getArg(q,3)).val.sval, getVarConstant(mb, getArg(q,4)).val.ival);
@-
The dbat is not part of the dictionary encoding. It should be dealt with in the context
of OID sizes. The same holds for idx bats.
@c

		if ( buf[0] ){
			BATiter bidx = bat_iterator(dictIndex);
			BATiter bval = bat_iterator(dictValue);

			p = BUNfnd(BATmirror(dictIndex), (ptr) buf);
			if ( p != BUN_NONE ){
				x = *(int*) BUNhead(bidx, p);
				v = *(int*) BUNhead(bval, BUNfnd(BATmirror(dictValue), (ptr) buf ) );
#ifdef DEBUG_OPT_DICTIONARY 
				stream_printf(GDKout, "#Located a dictionary %s ? %s %d %d\n",buf, (p?"ok":"no"), x,v);
#endif
				/* replace the sql.bind */
				bi = BATdescriptor(x);
				if ( bi == NULL){
					GDKfree(idx);
					GDKfree(val);
					return 0;
				}
				bv = BATdescriptor(v);
				if ( bv == NULL){
					BBPreleaseref(bi->batCacheid);
					GDKfree(idx);
					GDKfree(val);
					return 0;
				}
				/* construct: (bi:bat[:oid,:type], bv:bat[:type,:any2]):= dictionary.bind(name); */
				qq = newStmt(mb,"dictionary",bindRef);
				qq = pushArgument(mb,qq, newTmpVariable(mb,newBatType(bi->ttype,bv->ttype)));
				qq->retc++;
				qq = pushStr(mb,qq,buf);
				setVarType(mb, getArg(qq,0), newBatType(TYPE_oid,bi->ttype));
				setVarUDFtype(mb, getArg(qq,0));
				setVarUDFtype(mb, getArg(qq,1));
				/* let's remember them */
				idx[getArg(q,0)] = getArg(qq,0);
				val[getArg(q,0)] = getArg(qq,1);
				actions++;
				continue;
			} else  
				pushInstruction(mb,q);
@-
The trigger to convert tables is postponed.
For all 0-kind binds we will try to create a dictionary pair.
This means it becomes visible at the next query, then it
is also the right moment to zap the base table itself.
Moreover, we have to invalidate the plan when a new
dictionary element has been added since its construction.
Recompilation is then necessary, and preferably done automatically.
			if ( getModuleId(q) == sqlRef && getFunctionId(q) == bindRef && getVarConstant(mb,getArg(q,4)).val.ival == 0 ){
				int one=1;
				pushInstruction(mb,q);
				qq = newStmt(mb, dictionaryRef, putName("compress",8));
				qq = pushStr(mb,qq,buf);
				varSetProp(mb, getArg(getInstrPtr(mb,0), 0), runonceProp, op_eq, (ptr) &one);
				pushArgument(mb,qq, getArg(q,0));
			} else
				pushInstruction(mb,q);
@c
		} else {
@-
We have to re-cast each instruction based on a possible dictionary 
representation of an argument. For some operators we may postpone
reconstruction and introduce a new dictionary pair.
@c
			if (  getModuleId(q) == algebraRef ){
				if ( getFunctionId(q) == selectRef ||
					 getFunctionId(q) == thetaselectRef ){
					if ( isDiction(getArg(q,1)) ) {
						j = getArg(q,0);
						idx[j] = idx[getArg(q,1)];
						getArg(q,1) = val[getArg(q,1)];
						getArg(q,0)= newTmpVariable(mb, getVarType(mb,getArg(q,1)));
						val[j] = getArg(q,0);
						pushInstruction(mb,q);
#ifdef DEBUG_OPT_DICTIONARY 
						stream_printf(GDKout,"dictionary %d %s -> %d %d\n", j, getVarName(mb,j), idx[j],val[j]);
#endif
					} else
						pushInstruction(mb,q);
					actions++;
					continue;
				}
				if ( getFunctionId(q) == uselectRef  ||
					 getFunctionId(q) == thetauselectRef  ){
					if ( isDiction(getArg(q,1)) ) {
						/* case : r:bat[:oid,:void] := algebra.uselect(dict,arg) */
						/* become: k:= algebra.select(val,arg) ; v:= join(idx,k); r:= algebra.project(v);  */
						setFunctionId(q, (getFunctionId(q)== uselectRef?selectRef:putName("thetaselect",11)));
						pushInstruction(mb,q);
						j = getArg(q,0);
						getArg(q,0)= newTmpVariable(mb, getVarType(mb,val[getArg(q,1)]));

						qq= newStmt(mb, algebraRef,joinRef);
						qq= pushArgument(mb,qq, idx[getArg(q,1)]);
						qq= pushArgument(mb,qq, getArg(q,0));
						getArg(q,1) = val[getArg(q,1)];

						q = newStmt(mb, algebraRef, projectRef);
						getArg(q,0) = j;
						qq= pushArgument(mb,q, getArg(qq,0));
					} else
						pushInstruction(mb,q);
					actions++;
					continue;
				}
@-
The arguments can be singular or both ref to a dictionary pair.
We deal with the most prominent case provided by SQL only. 
@c
				if ( getFunctionId(q) == kdifferenceRef   && isDiction(getArg(q,1)) && ! isDiction(getArg(q,2))){
					j = getArg(q,0);
					val[j] = val[getArg(q,1)];
					getArg(q,1) = idx[getArg(q,1)];
					getArg(q,0)= newTmpVariable(mb, getVarType(mb,getArg(q,1)));
					idx[j] = getArg(q,0);
					pushInstruction(mb,q);
					continue;
				} 
@-
The kunion requires that both operands have the same signature.
This means we have to possibly expand the encoding table and derive an encoding for the 2nd argument.
@c
				if ( getFunctionId(q) == kunionRef && isDiction(getArg(q,1))   && ! isDiction(getArg(q,2))){
					actions++;
					if( getVarType(mb,idx[getArg(q,2)]) == getArgType(mb,q,1)  ){
						j = getArg(q,0);
						val[j] = val[getArg(q,1)];
						getArg(q,1) = idx[getArg(q,1)];
						getArg(q,0)= newTmpVariable(mb, getVarType(mb,getArg(q,1)));
						idx[j] = getArg(q,0);
						pushInstruction(mb,q);
						continue;
					}
					/* case: kunion(idx:bat[:oid,:bte], b:bat[:oid,:str] */
					/* avalnew := dictionary.expand(aval,b) */

					qq= newStmt(mb,dictionaryRef,"expand");
					setVarType(mb, getArg(qq,0), getVarType(mb,val[getArg(q,1)]));
					qq = pushArgument(mb,qq, val[getArg(q,1)]);
					qq = pushArgument(mb,qq, getArg(q,2));
					j = getArg(q,0);
					val[j] = getArg(qq,0);

					/* bidx := dictionary.encode(aval,b) */
					qq = newStmt(mb,"dictionary","encode");
					qq = pushArgument(mb,qq, val[j]);
					qq = pushArgument(mb,qq, getArg(q,2));

					pushInstruction(mb,q);
					getArg(q,1) = idx[getArg(q,1)];
					getArg(q,2) = getArg(qq,0);
					getArg(q,0)= newTmpVariable(mb, getVarType(mb,getArg(q,1)));
					idx[j] = getArg(q,0);
#ifdef DEBUG_OPT_DICTIONARY 
					stream_printf(GDKout,"dictionary %d %s -> %d %d\n", j, getVarName(mb,j), idx[j],val[j]);
#endif
					continue;
				}
@-
Marking the dictionary pair idx(oid,bte) and val(bte,int) can be realised by performing
a semijoin on idx followed by the markT. The value is of no interested.
@c
				if ( getFunctionId(q) == markTRef && isDiction(getArg(q,1)) ) {
					qq= newStmt(mb,batRef,reverseRef);
					qq= pushArgument(mb, qq, idx[getArg(q,1)]);
					j = getArg(qq,0);

					qq= newStmt(mb,algebraRef,semijoinRef);
					qq= pushArgument(mb, qq, j);
					qq= pushArgument(mb, qq, val[getArg(q,1)]);
					j = getArg(qq,0);

					qq= newStmt(mb,batRef,reverseRef);
					qq= pushArgument(mb, qq, j);
					actions++;
					getArg(q,1) = getArg(qq,0);
					pushInstruction(mb,q);
					continue;
				}
@-
Combination of the next column with the pivot table.
@c
				if ( getFunctionId(q) == semijoinRef && isDiction(getArg(q,1))  && !isDiction(getArg(q,2)) ) {
					j = getArg(q,0);
					val[j] = val[getArg(q,1)];
					getArg(q,1) = idx[getArg(q,1)];
					getArg(q,0) = newTmpVariable(mb, getVarType(mb,getArg(q,1)));
					idx[j] = getArg(q,0);
					pushInstruction(mb,q);
					continue;
				}
@-
In the leftjoin you can carry along the value encoding.
@c
				if ( getFunctionId(q) == leftjoinRef && isDiction(getArg(q,2)) ) {
					j = getArg(q,0);
					val[j] = val[getArg(q,2)];
					getArg(q,2) = idx[getArg(q,2)];
					idx[j] = newTmpVariable(mb, newBatType(getHeadType(getVarType(mb,getArg(q,1))), getTailType(getVarType(mb,getArg(q,2)))) );
					pushInstruction(mb,q);
					getArg(q,0) = idx[j];
					continue;
				}
@-
Projections are easy. We simply drop the encoding table.
@c
				if ( getFunctionId(q) == projectRef && isDiction(getArg(q,1))   && q->argc==2) {
					val[j = getArg(q,0)] = val[getArg(q,1)];
					getArg(q,1) = idx[getArg(q,1)];
					getArg(q,0) = newTmpVariable(mb, getVarType(mb,getArg(q,1)));
					idx[j] = getArg(q,0);
					pushInstruction(mb,q);
					continue;
				}
			} 
@-
The aggregation group is more involved, because we use the expensive OID scheme to
administer the groups. This calls for a modification of the encoding table.
case : (ext,grp):= group.new((idx,val)),
gives: (ext,grp) := group.new(idx); val:= dictionary.group(idx,val)
We have to remember the grouping only.
Derived paths are similar to the group new.
@c
			if (  getModuleId(q) == groupRef ){
				if ( getFunctionId(q) == newRef && isDiction(getArg(q,2))   ) {
					j = getArg(q,0);
					qq = newStmt(mb,dictionaryRef,groupRef);
					pushArgument(mb,qq, idx[getArg(q,2)]);
					pushArgument(mb,qq, val[getArg(q,2)]);
					val[j] = getArg(qq,0);

					getArg(q,2) = idx[getArg(q,2)];
					idx[j] = getArg(q,0);
					pushInstruction(mb,q);
					actions++;
					continue;
				}
				if ( getFunctionId(q) == deriveRef && isDiction(getArg(q,4))   ) {
					j = getArg(q,0);
					qq = newStmt(mb,dictionaryRef,groupRef);
					pushArgument(mb,qq, idx[getArg(q,4)]);
					pushArgument(mb,qq, val[getArg(q,4)]);
					val[j] = getArg(qq,0);

					getArg(q,4) = idx[getArg(q,4)];
					idx[j] = getArg(q,0);
					pushInstruction(mb,q);
					actions++;
					continue;
				}
			}
			/* default cases call for source reconstruction */
			for (j = q->retc; j < q->argc; j++)
			if ( isDiction(getArg(q,j)) ){
				/* recast void to type needed for the join */
				qq= newStmt(mb,algebraRef,joinRef);
				getArg(qq,0) = getArg(q,j);
				setVarType(mb,getArg(qq,0), newBatType(getHeadType(getVarType(mb,idx[getArg(q,j)])), getTailType(getVarType(mb,val[getArg(q,j)]))));
				qq= pushArgument(mb,qq,idx[getArg(q,j)]);
				qq= pushArgument(mb,qq,val[getArg(q,j)]);
				idx[getArg(q,j)] = 0;
				val[getArg(q,j)] = 0;
			}
			pushInstruction(mb,q);
		}
	}
#ifdef DEBUG_OPT_DICTIONARY 
	if (actions)
		printFunction(cntxt->fdout,mb,0,LIST_MAL_ALL);
#endif
	GDKfree(idx);
	GDKfree(val);
	return actions;
}
@-
@include optimizerWrapper.mx
@h
@:exportOptimizer(dictionary)@
#endif
@c
#include "opt_statistics.h"

@:wrapOptimizer(dictionary,OPT_CHECK_ALL)@
@-
Dictionary implementation.
@c

void 
DICTcommit(BAT *b1, BAT *b2, BAT *b3, BAT *b4 )
{
	BAT *bl = BATnew(TYPE_void, TYPE_str, 10);
	BATseqbase(bl,0);
	if (b1)
		BUNappend(bl, BBPname(b1->batCacheid), FALSE);
	if (b2)
		BUNappend(bl, BBPname(b2->batCacheid), FALSE);
	if (b3)
		BUNappend(bl, BBPname(b3->batCacheid), FALSE);
	if (b4)
		BUNappend(bl, BBPname(b4->batCacheid), FALSE);
	TMsubcommit(bl);
	BBPreclaim(bl);
}

int
DICTinit(void)
{
    BAT *b, *bn, *bs;
	if ( dictIndex == NULL){
		mal_set_lock(mal_contextLock, "dictionary");
		if ( dictIndex ){
			/* parallel initialization action */
			mal_unset_lock(mal_contextLock, "dictionary");
			return 0;
		}
		b = BATdescriptor(BBPindex("dictIndex"));
		if (b) {
			bn = BATdescriptor(BBPindex("dictValue"));
			if (bn ){
				bs = BATdescriptor(BBPindex("dictBase"));
				if ( bs ) {
					dictIndex = b;
					dictValue = bn;
					dictBase = bs;
				}
			} else
				BBPreleaseref(b->batCacheid);
			mal_unset_lock(mal_contextLock, "dictionary");
			return 0;
		}

		b = BATnew(TYPE_int,TYPE_str, 255);
		if (b == NULL) {
			mal_unset_lock(mal_contextLock, "dictionary");
			return -1;
		}
		bn = BATnew(TYPE_int, TYPE_str, 255);
		if (bn == NULL) {
			BBPreleaseref(b->batCacheid);
			mal_unset_lock(mal_contextLock, "dictionary");
			return -1;
		}
		bs = BATnew(TYPE_int, TYPE_str, 255);
		if (bs == NULL) {
			BBPreleaseref(b->batCacheid);
			BBPreleaseref(bn->batCacheid);
			mal_unset_lock(mal_contextLock, "dictionary");
			return -1;
		}

		BATkey(b, TRUE);
		BBPrename(b->batCacheid, "dictIndex");
		BATmode(b, PERSISTENT);
		BBPkeepref(b->batCacheid);
		dictIndex = b;

		BATkey(bn, TRUE);
		BBPrename(bn->batCacheid, "dictValue");
		BATmode(bn, PERSISTENT);
		BBPkeepref(bn->batCacheid);
		dictValue = bn;

		BATkey(bs, TRUE);
		BBPrename(bs->batCacheid, "dictBase");
		BATmode(bs, PERSISTENT);
		BBPkeepref(bs->batCacheid);
		dictBase = bs;
		mal_unset_lock(mal_contextLock, "dictionary");
		DICTcommit(dictIndex,dictValue, dictBase,0);
	}
    return 0;
}

str DICTbind(int *idx, int *val, str * nme)
{
	int base = 0;
	*idx = *val = 0;
	if( DICTinit() )
		throw(MAL,"dictionary.bind","No catalog table");
	if ( DICTfind(idx, val, &base, *nme) )
		throw(MAL,"dictionary.bind","Not found in catalog table");
	BBPkeepref(*idx);
	BBPkeepref(*val);
	(void) base;
#ifdef DEBUG_OPT_DICTIONARY 
	stream_printf(GDKout,"#dictionary.bind %d %d\n",*idx, *val);
#endif
	return MAL_SUCCEED;
}

static int
DICTtype(size_t cnt){
	if ( cnt < 256 )
		return TYPE_bte;
	if ( cnt < 1<<15 )
		return TYPE_sht;
	if ( cnt < (size_t) 1<<31 )
		return TYPE_int;
	return TYPE_lng;
}

str DICTcompress(int *ret, str *nme, int *bid)
{
	int idx,val,base, typ;
	size_t cnt;
	BAT *b, *bo, *bx = 0, *bv = 0, *bs, *bh =0;
	BATiter bi;
	BUN p,q;
	double ratio = 0.0;

	if( DICTinit() )
		throw(MAL,"dictionary.new","No catalog table");
	if ( DICTfind(&idx,&val, &base, *nme) == 0)
		throw(MAL,"dictionary.new", "duplicate entry");
	(void)base;
	b = (BAT *) BATdescriptor(*bid);
    if (b == 0)
        /* Simple ignore the binding if you can;t find the bat */
        throw(MAL, "dict.new", RUNTIME_OBJECT_MISSING);

	/* compression is only relevant for larger tables */
	if ( BATcount(b) < (size_t) 10000)
		return MAL_SUCCEED; 
	/* or determine its memory footprint */

	/* alternatively, we sample the table */
	bs= BATsample(b, (size_t) 1000);
	if ( bs )
		bh= BAThistogram(bs);
	if ( bs && bh  && BATcount(bs) > 0)
		ratio = (double) BATcount(bh) / (double) BATcount(bs);
	/* only look at sufficient duplicates */
	if ( ratio > 0.8 ){
		BBPreleaseref(b->batCacheid);
		if ( bs) BBPreleaseref(bs->batCacheid);
		if ( bh) BBPreleaseref(bh->batCacheid);
		return MAL_SUCCEED;
	}
#ifdef DEBUG_OPT_DICTIONARY 
	if ( bs && bh )
		stream_printf(GDKout,"#dictionary.compress sample " SZFMT " " SZFMT" %f %f\n", BATcount(bs), BATcount(bh),ratio, ratio * BATcount(b));
#endif
	if ( bs) BBPreleaseref(bs->batCacheid);
	if ( bh) BBPreleaseref(bh->batCacheid);

	bo= BAThistogram(b); /* BATkunique(BATmirror(b));*/
	if ( bo == NULL){
		BBPreleaseref(b->batCacheid);
		throw(MAL,"dict.new","Can not access unique list");
	}
	bo = BATmirror(bo);
	
	cnt = BATcount(bo);
	typ= DICTtype(cnt);
	if( typ == TYPE_lng || typ == b->ttype){
		/* don't create a new dictionary */
#ifdef DEBUG_OPT_DICTIONARY 
	stream_printf(GDKout,"#dictionary.new %s not compressed\n",*nme);
#endif
		BBPreleaseref(b->batCacheid);
		BBPreleaseref(bo->batCacheid);
		return MAL_SUCCEED;
	}
#ifdef DEBUG_OPT_DICTIONARY 
	stream_printf(GDKout,"#dictionary.new %s compressed from type %s to %s " SZFMT" elm\n", *nme, getTypeName(b->ttype), getTypeName(typ), cnt);
#endif
	bv =  BATnew(typ, b->ttype, BATcount(b));
	/* create the dictionary representation */
@=
Factor out the index construction by type
@= mkindex
	{	@1 o;
		/* complete encoding table */
		bi = bat_iterator(@2);
		o = (@1) @3;
		BATloop(@2,p,q){
			bunfastins(bv, &o, BUNtail(bi,p));
			o++;
		}
	} break;
@c
	switch(typ){
	case TYPE_bte: @:mkindex(bte,bo,0)@
	case TYPE_sht: @:mkindex(sht,bo,0)@
	case TYPE_int: @:mkindex(int,bo,0)@
	}
	BATpropcheck(bv, BATPROPS_QUICK);
	bv->hsorted = GDK_SORTED;
	bx = BATjoin(b,BATmirror(bv), BUN_NONE);
#ifdef DEBUG_OPT_DICTIONARY 
	stream_printf(GDKout,"#dictionary.new values table " SZFMT " \n", BATcount(bv));
#endif

	if (!(bx->batDirty&2)) bx = BATsetaccess(bx, BAT_READ);
	if (!(bv->batDirty&2)) bv = BATsetaccess(bv, BAT_READ);
	BUNins(dictIndex,&bx->batCacheid, *nme, FALSE);
	BUNins(dictValue,&bv->batCacheid, *nme, FALSE);
	BUNins(dictBase,&b->batCacheid, *nme, FALSE);
	BATmode(bx, PERSISTENT);
	BATmode(bv, PERSISTENT);
	BBPkeepref(bx->batCacheid);
	BBPkeepref(bv->batCacheid);
	BBPreleaseref(*bid);
	BBPreleaseref(bo->batCacheid);
	DICTcommit(bx,bv, dictIndex,dictValue);
	/* now the original BAT can be cleared */
	BATclear(b);
#ifdef DEBUG_OPT_DICTIONARY 
	stream_printf(GDKout,"#dictionary.new  %d->%d %d\n",typ,bx->batCacheid, bv->batCacheid);
#endif
	(void) ret;
	return MAL_SUCCEED;
bunins_failed:
	if (bx) BBPreleaseref(bx->batCacheid);
	if (bv) BBPreleaseref(bv->batCacheid);
	BBPreleaseref(*bid);
	BBPreleaseref(bo->batCacheid);
	throw(MAL,"dictionary.compress","failed");
}

@-
Extending a dictionary could lead to overflow of the reference type.
This means, we end up with larger idx tables.
This should trigger a partial re-compilation of the MAL program.
@c
str 
DICTexpand(int *rval, int *val, int *bid)
{
	BAT *bv, *b, *bn, *rv;
	BATiter bi;
	BUN p,q;

	b = (BAT *) BATdescriptor(*bid);
	rv = (BAT *) BATdescriptor(*val);
    if (rv == 0 || b == 0 ){
		if ( b  ) BBPreleaseref(b->batCacheid);
		if ( rv ) BBPreleaseref(rv->batCacheid);
        throw(MAL,"dictionary.expand",RUNTIME_OBJECT_MISSING);
	}

	/* check how many new elements should be added to the encoding table */
	bn = BATsemijoin(BATmirror(b), BATmirror(rv));
#ifdef DEBUG_OPT_DICTIONARY 
	stream_printf(GDKout,"#dictionary.expand %d %d %d\n",*idx, *val,*bid);
	stream_printf(GDKout,"#dictionary.expand " SZFMT " " SZFMT " " SZFMT "\n", 
		BATcount(rv), BATcount(b), BATcount(bn));
#endif
	if ( BATcount(bn) == 0){
		BBPreleaseref(bn->batCacheid);
		BBPreleaseref(b->batCacheid);
		BBPkeepref(*rval= rv->batCacheid);
		return MAL_SUCCEED;
	}
	bv= BATcopy(rv, DICTtype(BATcount(rv) + BATcount(bn)), rv->ttype,FALSE);
	BBPreleaseref(bn->batCacheid);
	BBPreleaseref(rv->batCacheid);
@= mkindex2
	{	@1 o;
		bi = bat_iterator(@2);
		o = (@1) BATcount(bv);
		BATloop(@2,p,q){
			BUNins(bv, &o, BUNtail(bi,p), FALSE);
			o++;
		}
#ifdef DEBUG_OPT_DICTIONARY 
	stream_printf(GDKout,"#dictionary.new values in encoding table" SZFMT " \n", BATcount(bv));
#endif
	} break;
@c
	switch(bv->htype){
	case TYPE_bte: @:mkindex2(bte,b)@
	case TYPE_sht: @:mkindex2(sht,b)@
	case TYPE_int: @:mkindex2(int,b)@
	}
	BATpropcheck(bv, BATPROPS_QUICK);

	BBPreleaseref(b->batCacheid);
	BBPkeepref(*rval = bv->batCacheid);
	return MAL_SUCCEED;
}
@-
Use a value table to encode the BAT.
@c
str 
DICTencode(int *ridx, int *vid, int *bid)
{
	BAT *b, *bv, *bx;

	b= (BAT *) BATdescriptor(*bid);
    if (b == 0)
        throw(MAL,"dictionary.expand",RUNTIME_OBJECT_MISSING);
	bv= (BAT *) BATdescriptor(*vid);
    if (bv == 0){
		BBPreleaseref(b->batCacheid);
        throw(MAL,"dictionary.expand",RUNTIME_OBJECT_MISSING);
	}
#ifdef DEBUG_OPT_DICTIONARY 
	stream_printf(GDKout,"#dictionary.encode %d %d\n",*vid,*bid);
#endif

	bx = BATjoin(b,BATmirror(bv), BUN_NONE);
#ifdef DEBUG_OPT_DICTIONARY 
	stream_printf(GDKout,"#dictionary.encode index in encoding table" SZFMT " \n", BATcount(bx));
#endif
	BBPkeepref(*ridx= bx->batCacheid);
	BBPreleaseref(b->batCacheid);
	BBPreleaseref(bv->batCacheid);
	return MAL_SUCCEED;
}

str DICTdecompress(int *ret, str *nme)
{
	int idx = 0, val= 0, base = 0;
	BAT *bx, *bv, *bs, *b;
	BUN p;

	if( DICTinit() )
		throw(MAL,"dictionary.decompress","No catalog table");
#ifdef DEBUG_OPT_DICTIONARY 
	stream_printf(GDKout,"#dictionary.decompress %s\n",*nme);
#endif
	if ( DICTfind(&idx,&val,&base,*nme) == 0)
		return MAL_SUCCEED;
	bx= (BAT *) BATdescriptor(idx);
    if (bx == 0)
        throw(MAL,"dictionary.compress",RUNTIME_OBJECT_MISSING);
	bv= (BAT *) BATdescriptor(val);
    if (bv == 0){
		BBPreleaseref(bx->batCacheid);
        throw(MAL,"dictionary.compress",RUNTIME_OBJECT_MISSING);
	}
	bs= (BAT *) BATdescriptor(base);
    if (bs == 0){
		BBPreleaseref(bv->batCacheid);
		BBPreleaseref(bx->batCacheid);
        throw(MAL,"dictionary.compress",RUNTIME_OBJECT_MISSING);
	}
	mal_set_lock(mal_contextLock, "dictionary");
	b = BATjoin(bx,bv,BUN_NONE);
	BATappend(bs,b,TRUE);
	BBPreleaseref(b->batCacheid);

	/* remove the element from the dictionary catalog */
	p = BUNfnd(BATmirror(dictIndex), (ptr) nme);
	if ( p != BUN_NONE ){
		BUNdelete(bx, p, TRUE);
		BUNdelete(bv, BUNfnd(BATmirror(dictValue), (ptr) nme ) , TRUE);
		BUNdelete(bs, BUNfnd(BATmirror(dictBase), (ptr) nme ) , TRUE);
	}
	BBPreleaseref(bv->batCacheid); BBPreleaseref(bx->batCacheid);
	BBPreleaseref(bs->batCacheid);
	mal_unset_lock(mal_contextLock, "dictionary");
	(void) ret;
	return MAL_SUCCEED;
}
@= map
	{	@1 v;
		oid o;
		BATloop(bv,p,q){
			v = *(@1*) BUNhead(bvi,p);
			o = *(oid*) BUNhead(bii,BUNfnd( BATmirror(bi),&v));
			BUNins(b, &o, BUNtail(bvi,p), FALSE);
		}
#ifdef DEBUG_OPT_DICTIONARY 
	stream_printf(GDKout,"#dictionary.new values in encoding table" SZFMT " \n", BATcount(bv));
#endif
	} break;
@c

opt_export str DICTgroupid(int *ret, int *idx, int *val)
{
	BAT *bi, *bv, *b;
	BATiter bii,bvi;
	BUN p,q;

	bi= (BAT *) BATdescriptor(*idx);
    if (bi == 0)
        throw(MAL,"dictionary.map",RUNTIME_OBJECT_MISSING);
	bv= (BAT *) BATdescriptor(*val);
    if (bv == 0){
		BBPreleaseref(bi->batCacheid);
        throw(MAL,"dictionary.map",RUNTIME_OBJECT_MISSING);
	}
	b = BATnew(TYPE_oid,bv->ttype, BATcount(bv));
	bii = bat_iterator(bi);
	bvi = bat_iterator(bv);
	switch ( bv->htype){
	case TYPE_bte: @:map(bte)@
	case TYPE_sht: @:map(sht)@
	case TYPE_int: @:map(int)@
	}

	BBPreleaseref(bi->batCacheid);
	BBPreleaseref(bv->batCacheid);
	BBPkeepref(*ret = b->batCacheid);
	return MAL_SUCCEED;
}
@}
