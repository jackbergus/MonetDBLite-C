@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2005 CWI.
@' All Rights Reserved.

@f mal_costmodel
@a M. L. Kersten
@-
@node Costmodels, Variable Stack Reduction, Strength Reduction, Optimizer toolkit
@+ The MAL costmodel
Cost models form the basis for many optimization decisions.
The cost parameters are typically the size of the (intermediate)
results and response time. Alternatively, they are running
aggregates, e.g. max memory and total execution time,
obtained from a simulated run.
The current implementation contains a framework and example for
building your own cost-based optimized.

The @code{optimizer.costEstimation()} works its way through a 
MAL program in search for
relational operators and estimates their result size. 
The operations taken into account are @{reverse, select, join, mark,
uselect, kdifference,cross@}
The estimated size is left behind as property @code{RMcost},
to avoid overwriting information produced by the front-end compiler.
@verbatim
    r{count=100} := bat.new(:void,:int);
    s{count=1000}:= bat.new(:void,:int);
    rs:= algebra.select(s,1,1);
    rr:= bat.reverse(r);
    j:= algebra.join(rs,rr);
    optimizer.costEstimation();
@end verbatim
changes the properties of the instructions as follows:
@verbatim
    r{RMcost=100,count=100} := bat.new(:void,:int);
    s{RMcost=1000,count=1000} := bat.new(:void,:int);
    rs{RMcost=500} := algebra.select(s{RMcost=1000,count=1000},1,1);
    rr{RMcost=100} := bat.reverse(r{RMcost=100,count=100});
    j{RMcost=100} := algebra.join(rs{RMcost=500},rr{RMcost=100});
@end verbatim

The cost estimation does not use any statistics on the actual
data distribution yet. It just applies a few heuristic cost
estimators.
@{
@+ Implementation section
@h
#ifndef _MAL_COSTMODEL_H_
#define _MAL_COSTMODEL_H_

#define DEBUG_MAL_COSTMODEL

#include "mal.h"
#include <math.h>
#include "mal_macro.h"
#include "mal_interpreter.h"
#include "mal_client.h"
#include "mal_namespace.h"
#include "mal_optimizer.h"
#include "mal_prelude.h"

#define getProps(Y) mb->var[Y]->props

opt_export void RMcalculator(MalBlkPtr mb);
opt_export str RMoptimizer(MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
opt_export int getCost(MalBlkPtr mb, int varid);
#endif /* _MAL_COSTMODEL_H_ */
@-
@c
#include "mal_costmodel.h"

static void
fixPropertySet(MalBlkPtr mb, int dst)
{
	if (mb->var[dst]->props == 0)
		mb->var[dst]->props = newPropertySet();
}
static void
RMcpyProperty(MalBlkPtr mb, str srcnme, int src, str dstnme, int dst)
{
	Property pr;

	if (getProps(src) == NULL)
		return;

	pr = fndProperty(getProps(src), srcnme);
	if (pr) {
		fixPropertySet(mb, dst);
		setProperty(getProps(dst), dstnme, "=", pr->val.vtype, VALptr(&pr->val));
	}
}

#define getVarCost(Y) (fndProperty(mb->var[Y]->props,"RMcost")?\
		(int*) getPropertyValue(mb->var[Y]->props,"RMcost"):\
		(int*)getPropertyValue(mb->var[Y]->props,"count") )

@-
The cost formula are repetative
@= newCost
		c1 = getVarCost(getArg(p,@1));
		if( c1 == NULL) continue;
		k= @2;
		fixPropertySet(mb, getArg(p,0));
		setProperty(getProps(getArg(p,0)),"RMcost", "=", TYPE_int, &k);
@= newCost2
		c1 = getVarCost(getArg(p,@1));
		c2 = getVarCost(getArg(p,@2));
		if( c1 == NULL) continue;
		if( c2 == NULL) continue;
		k= (@3);
		fixPropertySet(mb, getArg(p,0));
		setProperty(getProps(getArg(p,0)),"RMcost","=", TYPE_int, &k);
@c
void
RMcalculator(MalBlkPtr mb)
{
	int i, j, *c, *c1, *c2, k;
	InstrPtr p;

	for (i = 0; i < mb->stop; i++) {
		p = getInstrPtr(mb, i);
		if (moduleId(p)==algebraRef) {
			if (functionId(p) && idcmp(functionName(p), "markRef") == 0) {
				@:newCost(1, *c1)@
			} else if (functionId(p)== kdifferenceRef) {
				@:newCost2(1, 2, *c1 - *c2 < 0 ? 0 : *c1 - *c2)@
			} else if (functionId(p)==joinRef ) {
				@:newCost2(1, 2, *c1 < *c2 ? *c1 : *c2)@
			} else if (functionId(p)== selectRef) {
				@:newCost(1, *c1 > 100 ? *c1 / 2 : *c1)@
			} else if (functionId(p)==uselectRef) {
				@:newCost(1, *c1 > 100 ? *c1 / 2 : *c1)@
			} else if (functionId(p)== crossRef) {
				@:newCost2(1, 2, (log((double) *c1) + log((double) *c2) > log(INT_MAX) ? INT_MAX : *c1 * *c2))@
			} else if (functionId(p) && idcmp(functionName(p), "tunique") == 0) {
				@:newCost(1, *c1 < 50 ? *c1 : *c1 / 10)@
			} else if (functionId(p)==sortRef || 
						idcmp(functionName(p), "sort_reverse") == 0) {
				@:newCost(1, *c1)@
			}

		} else if (moduleId(p)==batRef) {
			if (functionId(p) == reverseRef) {
				@:newCost(1, *c1)@
			} else if (functionId(p)==mirrorRef) {
				@:newCost(1, *c1)@
			}
		} else if (moduleId(p)==groupRef) {
			if (functionId(p) ==newRef) {
				@:newCost(1, *c1 / 10)@
			} else {
				@:newCost(1, *c1)@
			}
		} else if (moduleId(p) && idcmp(moduleName(p), "multiplex") == 0) {
			if (functionId(p) && idcmp(functionName(p), "script") == 0) {
				if (getVarCost(getArg(p, 1))) {
					@:newCost(1, *c1)@
				} else {
					@:newCost(2, *c1)@
				}
			}
		} else if (moduleId(p)== aggrRef) {
			if (functionId(p) ==sumRef || 
				functionId(p) ==minRef || 
				functionId(p) ==maxRef || 
				functionId(p) ==avgRef) {
				@:newCost(2, *c1)@
			}
		} else {
			/* propagate count to RMcost */
			for (j = 0; j < p->retc; j++) {
				if ((c = (int *) getVarCost(p->argv[j])))
					setProperty(getProps(p->argv[j]), "RMcost", "=", TYPE_int, c);
			}
		}
	}
}
str
RMoptimizer(MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	lng clk = GDKusec();

	(void) stk;
	if (p)
		removeInstruction(mb, p);
	if( mb->errors) 
		return MAL_SUCCEED;
	RMcalculator(mb);
	optimizerCheck(mb, "mal.costEstimation", 1, GDKusec() - clk);
	return MAL_SUCCEED;
}

@-
The cost will be used in many places to make decisions.
Access should be fast.
@c
int
getCost(MalBlkPtr mb, int varid)
{
	int c;

	c = *(getVarCost(varid));
	return c;
}

@}
