@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2006 CWI.
@' All Rights Reserved.

@f mal_costmodel
@a M. L. Kersten
@-
@node Costmodels, Variable Stack Reduction, Strength Reduction, Optimizer toolkit
@- The MAL costmodel
Cost models form the basis for many optimization decisions.
The cost parameters are typically the size of the (intermediate)
results and response time. Alternatively, they are running
aggregates, e.g. max memory and total execution time,
obtained from a simulated run.
The current implementation contains a framework and example for
building your own cost-based optimized.

The @code{optimizer.costEstimation()} works its way through a 
MAL program in search for
relational operators and estimates their result size. 
The operations taken into account are @{reverse, select, join, mark,
uselect, kdifference,cross@}
The estimated size is left behind as property @code{RMcost},
to avoid overwriting information produced by the front-end compiler.
@verbatim
    r{count=100} := bat.new(:void,:int);
    s{count=1000}:= bat.new(:void,:int);
    rs:= algebra.select(s,1,1);
    rr:= bat.reverse(r);
    j:= algebra.join(rs,rr);
    optimizer.costModel();
@end verbatim
changes the properties of the instructions as follows:
@verbatim
    r{RMcost=100,count=100} := bat.new(:void,:int);
    s{RMcost=1000,count=1000} := bat.new(:void,:int);
    rs{RMcost=500} := algebra.select(s{RMcost=1000,count=1000},1,1);
    rr{RMcost=100} := bat.reverse(r{RMcost=100,count=100});
    j{RMcost=100} := algebra.join(rs{RMcost=500},rr{RMcost=100});
@end verbatim

The cost estimation does not use any statistics on the actual
data distribution yet. It just applies a few heuristic cost
estimators.
@{
@+ Implementation section
@mal
pattern costModel():str
address QOTRMoptimizer;
pattern costModel(mod:str, fcn:str):str
address QOTRMoptimizer
comment "Estimate the cost of a relational expression";
@h
#ifndef _MAL_COSTMODEL_H_
#define _MAL_COSTMODEL_H_

#define DEBUG_MAL_COSTMODEL

#include "mal.h"
#include <math.h>
#include "mal_macro.h"
#include "mal_interpreter.h"
#include "mal_client.h"
#include "mal_namespace.h"
#include "mal_optimizer.h"
#include "mal_prelude.h"

#define getProps(Y) mb->var[Y]->props

opt_export void RMcalculator(MalBlkPtr mb);
opt_export str RMoptimizer(MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
opt_export int getCost(MalBlkPtr mb, int varid);
#endif /* _MAL_COSTMODEL_H_ */
@-
@c
#include "mal_costmodel.h"

static void
fixPropertySet(MalBlkPtr mb, int dst)
{
	if (mb->var[dst]->props == 0)
		mb->var[dst]->props = newPropertySet();
}
#define getVarCost(Y) (fndProperty(mb->var[Y]->props,"RMcost")?\
		(int*) getPropertyValue(mb->var[Y]->props,"RMcost"):\
		(int*)getPropertyValue(mb->var[Y]->props,"count") )

@-
The cost formula are repetative
@= newCost
		c1 = getVarCost(getArg(p,@1));
		if( c1 == NULL) continue;
		k= @2;
		fixPropertySet(mb, getArg(p,0));
		setProperty(getProps(getArg(p,0)),"RMcost", "=", TYPE_int, &k);
@= newCost2
		c1 = getVarCost(getArg(p,@1));
		c2 = getVarCost(getArg(p,@2));
		if( c1 == NULL) continue;
		if( c2 == NULL) continue;
		k= (@3);
		fixPropertySet(mb, getArg(p,0));
		setProperty(getProps(getArg(p,0)),"RMcost","=", TYPE_int, &k);
@c
void
RMcalculator(MalBlkPtr mb)
{
	int i, j, *c, *c1, *c2, k;
	InstrPtr p;

	for (i = 0; i < mb->stop; i++) {
		p = getInstrPtr(mb, i);
		if (getModuleId(p)==algebraRef) {
			if (getFunctionId(p) && idcmp(getFunctionId(p), "markRef") == 0) {
				@:newCost(1, *c1)@
			} else if (getFunctionId(p)== kdifferenceRef) {
				@:newCost2(1, 2, *c1 - *c2 < 0 ? 0 : *c1 - *c2)@
			} else if (getFunctionId(p)==joinRef ) {
				@:newCost2(1, 2, *c1 < *c2 ? *c1 : *c2)@
			} else if (getFunctionId(p)== selectRef) {
				@:newCost(1, *c1 > 100 ? *c1 / 2 : *c1)@
			} else if (getFunctionId(p)==uselectRef) {
				@:newCost(1, *c1 > 100 ? *c1 / 2 : *c1)@
			} else if (getFunctionId(p)== crossRef) {
				@:newCost2(1, 2, (log((double) *c1) + log((double) *c2) > log(INT_MAX) ? INT_MAX : *c1 * *c2))@
			} else if (getFunctionId(p) && idcmp(getFunctionId(p), "tunique") == 0) {
				@:newCost(1, *c1 < 50 ? *c1 : *c1 / 10)@
			} else if (getFunctionId(p)==sortRef || 
						idcmp(getFunctionId(p), "sort_reverse") == 0) {
				@:newCost(1, *c1)@
			}

		} else if (getModuleId(p)==batRef) {
			if (getFunctionId(p) == reverseRef) {
				@:newCost(1, *c1)@
			} else if (getFunctionId(p)==mirrorRef) {
				@:newCost(1, *c1)@
			}
		} else if (getModuleId(p)==groupRef) {
			if (getFunctionId(p) ==newRef) {
				@:newCost(1, *c1 / 10)@
			} else {
				@:newCost(1, *c1)@
			}
		} else if (getModuleId(p) && idcmp(getModuleId(p), "multiplex") == 0) {
			if (getFunctionId(p) && idcmp(getFunctionId(p), "script") == 0) {
				if (getVarCost(getArg(p, 1))) {
					@:newCost(1, *c1)@
				} else {
					@:newCost(2, *c1)@
				}
			}
		} else if (getModuleId(p)== aggrRef) {
			if (getFunctionId(p) ==sumRef || 
				getFunctionId(p) ==minRef || 
				getFunctionId(p) ==maxRef || 
				getFunctionId(p) ==avgRef) {
				@:newCost(2, *c1)@
			}
		} else {
			/* propagate count to RMcost */
			for (j = 0; j < p->retc; j++) {
				if ((c = (int *) getVarCost(p->argv[j])))
					setProperty(getProps(p->argv[j]), "RMcost", "=", TYPE_int, c);
			}
		}
	}
}
str
RMoptimizer(MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	lng clk = GDKusec();

	(void) stk;
	if (p)
		removeInstruction(mb, p);
	if( mb->errors) 
		return MAL_SUCCEED;
	RMcalculator(mb);
	optimizerCheck(mb, "mal.costEstimation", 1, GDKusec() - clk);
	return MAL_SUCCEED;
}

@-
The cost will be used in many places to make decisions.
Access should be fast.
@c
int
getCost(MalBlkPtr mb, int varid)
{
	int c;

	c = *(getVarCost(varid));
	return c;
}

@- Optimizer code wrapper
@c
mal_export str QOTRMoptimizer(MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
str QOTRMoptimizer(MalBlkPtr mb, MalStkPtr stk, InstrPtr p){
	str	modnme;
	str	fcnnme;
	Module  scope=NULL;
	Symbol s= NULL;
	Client c= MCgetClient();
	lng clk= GDKusec();

	/* handle the empty argument list */
	if( p->argc== 1){
		/* setLifespan(mb); they should do it themselves*/
		optimizerInit();
		RMoptimizer(mb, stk, p);
		return MAL_SUCCEED;
	}
	if( stk != 0){
		modnme= (str)getArgValue(stk,p,1);
		fcnnme= (str)getArgValue(stk,p,2);
	} else {
		modnme= getArgDefault(mb,p,1);
		fcnnme= getArgDefault(mb,p,2);
	}
	scope = findModule(c->nspace,putName(modnme,strlen(modnme)) );
	if( scope)
		s= findSymbolInModule(scope,putName(fcnnme,strlen(fcnnme)));

	if( s == NULL) {
		char buf[1024];
		snprintf(buf,1024, "Could not find %s.%s\n",modnme,fcnnme);
		return throwMessage("optimizer.costModel",buf);
	}
	
	if( s->def->errors == 0){
		optimizerInit();
		RMoptimizer(s->def,0,0);
		optimizerCheck(s->def,"costModel",1,GDKusec()-clk);
	}
	removeInstruction(mb, p);
	return MAL_SUCCEED;
}
@}
