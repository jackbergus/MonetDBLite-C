@/
The contents of this file are subject to the MonetDB Public License
Version 1.1 (the "License"); you may not use this file except in
compliance with the License. You may obtain a copy of the License at
http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html

Software distributed under the License is distributed on an "AS IS"
basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations
under the License.

The Original Code is the MonetDB Database System.

The Initial Developer of the Original Code is CWI.
Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
Copyright August 2008-2010 MonetDB B.V.
All Rights Reserved.
@

@f opt_tarantula
@a M. Kersten
@- Multileg creatures
Query execution can be improved significantly using distributed processing.
Traditionally, this encompasses fragmentation and allocation of the base
tables over multiple sites and query plans that include on the fly transport
of intermediate results.

Breaking the database into pieces itself is a well-studied area.
Most approaches consider the workload and search for a good split
of the base tables, such that the workload performance improves.

The Tarantula optimizer, like the Octopus optimizer, use the
output of the mitosis+mergetable optimizer and produces the
actual plans for parallel execution.
They both break a single table into pieces
based on the head and propagate the effect through the plan.

The tarantula untangles the resulting plan into a controlling head
function and a series of plans, one for each leg to execute concurrently.
The allocation of subplan to leg depends on the same bidding scheme
as the Octopus.

The Tarantula optimizer differs from the Octopus optimizer in performing
a recursive divide and conquer method to deal with blocking operations.
Furthermore, we assume that the persistent store is shared amongst
the node, which means that fragments of the tables can be directly accessed.

A snippet of an tarantula plan with two legs is shown.
The main part of the query becomes a three step procedure of
1) remote registration of subplans, 2) obtaining bids and schedule design
and 3) execute the subplans.
@verbatim
function reg_qry_0():void;
barrier _2 := language.dataflow();
	tarantula.register(0,"qry_0","qry_1");
	tarantula.register(1,"qry_0","qry_1");
exit _2;
end reg_qry;

function bid_qry()(:int,:int,:int,:int);
barrier _9 := language.dataflow();
	(_4,_5) := tarantula.getBid(0,"qry_0","qry_1");
	(_6,_7) := tarantula.getBid(1,"qry_0","qry_1");
exit _9;
end bid_qry;

function run_qry(node_0:int,node_1:int):bat[:oid,:int]
barrier _100:= scheduler.tarantula(10);
    _87 := tarantula.exec_qry(node_0,"leg0");
    _88 := tarantula.exec_qry(node_1,"leg1");
exit (_100,version);
    _15 := mat.pack(_87,_88);
	return run_qry := _15;
end run_qry;

function user.qry():void;
	_3 := reg_qry_0();
	(_4,_5,_6,_7):= bid_qry_0(_3);
    (node0,node1) := scheduler.makeSchedule_0(2,_4,_5,_6,_7);
	_15 := tarantula.run_qry(node0,node1);
    _16 := sql.resultSet(1,1,_15);
    sql.rsColumn(_16,"sys.squida","bid","int",32,0,_15);
    _21 := io.stdout();
    sql.exportResult(_21,_16);
end qry;
@end verbatim
The nodes addressed by the tarentula are indices into a global catalog.
The number of subplans is derived by the Mitosis as the number of pieces to consider.
The tarantula may register the subplans to more nodes than pieces.

@verbatim
function tarantula.exec_qry(node:str,fcn:str):bat[:oid,:int];
	conn:= remote.connect(node,"monetdb","monetdb");
	r:= remote.exec(conn,"tarantula",fcn);
	b:bat[:oid,:int]:= remote.get(conn,r);
	return b;
end exec_qry;
@end verbatim

@verbatim
function tarantula.qry_0(version:int):bat[:oid,:int];
    _53:bat[:oid,:int] := attach.bind("file://export/scratch/mk/dbfarm/demo/bat/01/001");
	_54 := algebra.slice(_53,0@0,25@0);
    _63:bat[:oid,:int] := attach.bind("file://export/scratch/mk/dbfarm/demo/bat/01/002");
	_64 := algebra.slice(_63,0@0,25@0);
    _72 := algebra.kdifference(_54,_64);
    _78 := algebra.kunion(_72,_64);
    _13:bat[:oid,:oid]  := attach.bind("file://export/scratch/mk/dbfarm/demo/bat/01/003");
    _14 := bat.reverse(_13);
    _85 := algebra.kdifference(_78,_14);
	return qry_0 := _85;
end tarantula.qry_0;

function tarantula.qry_1(version:int):bat[:oid,:int];
	... use second slice ...
end tarantula.qry_1;

@end verbatim

[Stability]
We assume that during a session, workers once started will remain alive.
No fault tolerance techniques are included.

[Recycling]
The legs contain registered functions and possible partial results in its recycler pool.
In the first implementation we assume a read-only database, where all workers are
restarted when changes to the underlying database affect the recycler pool.
Alternative, the head can clear the recycler pool explicitly upon such state change.

[Shared disk]
For a leg to work it needs access to its storage layer, which is a NAS.
It is encapsulated in the operation attach.bind("path",tuplecount).

This approach is different from the Octopus, where the head is
the sole control over the persistent data. 

[Naming]
The legs received from the tarantula should be ensured
not to clash with those already known. Therefore, we simply
tag them by orginating site.

[Caveats]
Any update invalidates the request to distributed processing.
In the same line, multi-statement SQL transactions and
updates to global variables are ignored. 

Global variables are tricky, because they are part of the
session context. To make it work, we need to be able to perform
an upcall to that context (=dangerous).
The solution is that any variable context should be
passed through a relation.
@{
@mal
module tarantula; 
pattern optimizer.tarantula():str
address OPTtarantula;
pattern optimizer.tarantula(mod:str, fcn:str):str
address OPTtarantula
comment "Map-execute-reduce parallelism optimizer";

pattern tarantula.register(node:int,fname:str...):void
address TARregister
comment "Register mal functions at server indexed by node.";

pattern tarantula.getBid(node:int,fname:str...)(:int...)
address TARgetBid
comment "Obtain a bid for mal functions at server indexed by node.";

@h
#ifndef _TAR_OCTOPUS_
#define _TAR_OCTOPUS_
#include "opt_prelude.h"
#include "opt_support.h"

#ifdef WIN32
#ifndef LIBOPTIMIZER
#define opt_export extern __declspec(dllimport)
#else
#define opt_export extern __declspec(dllexport)
#endif
#else
#define opt_export extern
#endif

opt_export str TARregister(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
opt_export str TARgetBid(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p);

@:exportOptimizer(tarantula)@

#define OPTDEBUGtarantula  if ( optDebug & ((lng)1 <<DEBUG_OPT_TARANTULA) )

#endif
@c
#include "mal_config.h"
#include "opt_tarantula.h"
#include "opt_deadcode.h"
#include "mal_interpreter.h"	/* for showErrors() */
#include "mal_builder.h"
#include "mal_sabaoth.h"
@-
The algorithm consists of several steps. The first one
replaces the original query and creates the leg functions.
In the second phase the should be registered at the different sites.

The key observation is that whenever we encounter a mat.pack,
there is a need to bring information together for inspection.
It indicates a blocking operation.
Therefore, we recursively break a plan by looking for the
pack instructions and collect all dependent instructions.
The original block is trimmed as far as needed.
@c
static sht bidStrategy = 1;

static int
TARinitcode(Client cntxt, MalBlkPtr mb){
	InstrPtr p;
	str s;
	str l = NULL;

	(void) cntxt;

	/* _x := remote.connect(uri,"monetdb","monetdb","msql"); */
	p = newStmt(mb, remoteRef,connectRef);
	s = GDKgetenv("merovingian_uri");
	if (s == NULL) /* aparently not under Merovingian control, fall back to local only */
		SABAOTHgetLocalConnection(&l);
	p= pushStr(mb,p, s == NULL ? l : s);
	p= pushStr(mb,p,"monetdb");
	p= pushStr(mb,p,"monetdb");
	p= pushStr(mb,p,"msql");
	if (l)
		GDKfree(l);
	return getArg(p,0);
}

@-
Be prepared to catch errors from the remote site.
You should catch them, otherwise the session is not closed.
Beware, exceptions should be catched and thrown after the
connection has been closed.
@c
static void
TARexitcode(MalBlkPtr mb, int conn, int varid)
{
	InstrPtr p;

	newCatchStmt(mb, "ANYexception");
	p = newStmt(mb, remoteRef, disconnectRef);
	pushArgument(mb, p, conn);
	newRaiseStmt(mb, "ANYexception");	/* pass to caller */
	newExitStmt(mb, "ANYexception");

	p = newStmt(mb, remoteRef, disconnectRef);
	pushArgument(mb, p, conn);
	p = newAssignment(mb);
	getArg(p, 0) = getArg(getInstrPtr(mb, 0), 0);
	pushArgument(mb, p, varid);
	p->barrier = RETURNsymbol;
	pushEndInstruction(mb);
	p = newStmt(mb, optimizerRef, putName("aliases", 7));
	p = pushStr(mb, p, tarantulaRef);
	p = pushStr(mb, p, getFunctionId(getInstrPtr(mb, 0)));
}
@-
The TARmakeleg walks through the MAL block and extracts the dependent structure for
execution. Note that information van be recomputed in all legs. Possibly doing duplicate work.
@c
static MalBlkPtr 
TARmakeleg(Client cntxt, MalBlkPtr mb, InstrPtr *old, int pc, int idx)
{
	MalBlkPtr tm = NULL;
	InstrPtr p = NULL;
	int varid, i, j, top=0, fnd;
	char buf[BUFSIZ];
	InstrPtr *list = (InstrPtr*) GDKzalloc(sizeof(InstrPtr) * mb->ssize);
	char *needed= (char*) GDKzalloc(mb->vtop);
	int *alias= (int*) GDKzalloc(mb->vtop * sizeof(int));
	Symbol s;

	assert(old[pc]->fcnname == packRef);

	varid = getArg(old[pc],idx);
	needed[varid] = 1;
	OPTDEBUGtarantula {
		stream_printf(cntxt->fdout,"#create leg for %d %d %d\n",pc,idx, varid);
	}

@-
Find the instructions needed. Beware pack operations
already have been handled and produce their target.
@c
	for (i = pc-1; i > 0; i--){
		p = old[i];

		fnd = 0;
		if ( p->barrier ){
			for (j = 0; j < p->argc; j++)
				needed[getArg(p,j)]= 1;
			fnd = 1;
		}
		for (j = 0; j < p->retc; j++)
			fnd += needed[getArg(p,j)];
		if ( fnd) {
			for (j = 0; j < p->argc; j++)
				needed[getArg(p,j)]= 1;
			list[top++] = p;
		}
	}

	/* create the Leg function signature */
	snprintf(buf,BUFSIZ,"%s_%d", getFunctionId(getInstrPtr(mb,0)), idx);
	putName(buf,strlen(buf));

	s= newFunction(tarantulaRef, buf, FUNCTIONsymbol);
	insertSymbol(findModule(cntxt->nspace,tarantulaRef),s);
	tm= s->def;

	for (top--; top >= 0; top--){
		p = copyInstruction(list[top]);
		for (i= 0; i< p->argc; i++){
			int a= getArg(list[top],i);
			if (alias[a]==0) 
				alias[a] = cloneVariable(tm,mb,a);
			getArg(p,i) = alias[a];
		}
		if (getModuleId(p) == sqlRef &&
			( getFunctionId(p) == bindRef ||
			  getFunctionId(p) == bindidxRef)){
			setModuleId(p, attachRef);
			setVarUDFtype(tm,getArg(p,0));
			setArgType(tm,p,0, getArgType(mb,list[top],0));
			/* construct the path */
		} 
		if (getModuleId(p) == sqlRef && getFunctionId(p) == binddbatRef ){
			setModuleId(p, tarantulaRef);
			setVarUDFtype(tm,getArg(p,0));
			setArgType(tm,p,0, getArgType(mb,list[top],0));
			/* construct the path */
		} 
		pushInstruction(tm, p);
	}

	p = newAssignment(tm);
	p->barrier = RETURNsymbol;
	p = pushArgument(tm,p,alias[varid]);
	getArg(p,0) = getArg(getInstrPtr(tm,0),0);
	pushEndInstruction(tm);
	clrDeclarations(tm);

	OPTDEBUGtarantula 
		printFunction(cntxt->fdout, tm, 0, LIST_MAL_STMT);
	GDKfree(list);
	GDKfree(alias);
	GDKfree(needed);
	return tm;
}

static int
TARmakeRegistration(Client cntxt, MalBlkPtr mb, InstrPtr *old, int pc, int nodes)
{
	Symbol s;
	MalBlkPtr tm;
	InstrPtr p;
	char buf[BUFSIZ];
	int i,n;
	str name;

	snprintf(buf,BUFSIZ,"reg_%s_%d", name = getFunctionId(getInstrPtr(mb,0)), getArg(old[pc],0));
	s= newFunction(tarantulaRef, buf, FUNCTIONsymbol);
	insertSymbol(findModule(cntxt->nspace,tarantulaRef),s);
	tm= s->def;
	for ( n= 0; n < nodes; n++){
		p= newStmt(tm,tarantulaRef,registerRef);
		p= pushInt(tm, p,n);
		for( i=old[pc]->retc; i< old[pc]->argc; i++){
			snprintf(buf,BUFSIZ,"%s_%i",name,i);
			p = pushStr(tm,p,buf);
		}
	}
	pushEndInstruction(tm);

	p = newStmt(mb,tarantulaRef,buf);
	return getArg(p,0);
}

static int
TARmakeBidding(Client cntxt, MalBlkPtr mb, InstrPtr *old, int pc, int nodes)
{
	Symbol s;
	MalBlkPtr tm;
	InstrPtr p,r,sig;
	char buf[BUFSIZ];
	int i,n;
	str name;

	snprintf(buf,BUFSIZ,"bid_%s_%d", name = getFunctionId(getInstrPtr(mb,0)), getArg(old[pc],0));
	s= newFunction(tarantulaRef, buf, FUNCTIONsymbol);
	insertSymbol(findModule(cntxt->nspace,tarantulaRef),s);
	tm= s->def;
	sig = getInstrPtr(tm,0);
	r= newInstruction(NULL,ASSIGNsymbol);
	r->barrier = RETURNsymbol;
	for( i=old[pc]->retc; i< old[pc]->argc; i++){
		sig= pushReturn(tm, sig, n = newTmpVariable(tm,TYPE_int));
		r = pushReturn(tm,r,n);
	}

	for ( n= 0; n < nodes; n++){
		p= newStmt(tm,tarantulaRef,registerRef);
		p= pushInt(tm, p,n);
		for( i=old[pc]->retc; i< old[pc]->argc; i++){
			snprintf(buf,BUFSIZ,"%s_%i",name,i);
			p = pushStr(tm,p,buf);
			p = pushReturn(tm,p, getArg(sig, i - old[pc]->retc));
		}
	}
	pushInstruction(tm,r);
	pushEndInstruction(tm);

	p = newStmt(mb,tarantulaRef,buf);
	return getArg(p,0);
}
@-
The tarantula is only permitted for read only queries.
The first blocking mat.pack determines the scope of the tarantula optimizer.
@c
static int
TAReligible(MalBlkPtr mb){
	int i, target = -1;
	InstrPtr p;

	//if ( varGetProp(mb, getArg(getInstrPtr(mb,0),0), PropertyIndex("autoCommit")) != NULL )
		//return -1;
	for (i = 1; i < mb->stop; i++){
		p = getInstrPtr(mb,i);
		
		if( getModuleId(p)== matRef && getFunctionId(p)== packRef && target == -1)
			target = i;
		if( getModuleId(p)== sqlRef ){
			if (getFunctionId(p)== appendRef || getFunctionId(p)== deleteRef )
				return -1;
			if ( strcmp(getFunctionId(p),"getVariable")==0 )
				return -1;
			if (strcmp(getFunctionId(p),"setVariable")==0 )
				return -1;
		}
	}
	return target;
}
@-
The core of the optimizer. It will repeatedly optimize the program given until all
blocking operations have been handled.
@c
static int
OPTtarantulaImplementation(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	InstrPtr q, p, sig, *old, r;
	int last=0, i, j, limit, actions=0, arg[1024];
	int tn=0, maxlegs= MAL_MAXCLIENTS -2;	/* should be relaxed */
	MalBlkPtr *leg, sm = NULL, tmb;
	Symbol s2;
	int nodes = 4;/* default */
	int version,v2;
	int k,l, rexit, bs, tcnt=0;
	char buf[BUFSIZ];
	ValRecord cst;
	int *wnm=NULL,*tnm=NULL;	/* array indices to var table where workers and leg names are stored */
	int **bid=NULL;				/* array index to bid variables */
	int **sch=NULL, **res=NULL;	/* array index to schedule variables and results */

	if( cntxt == 0){
		/* confuscate */
		TARinitcode(cntxt, mb);
		TARexitcode( mb,0,0);
	}
	if ( TAReligible(mb) < 0 )
		return 0;
@-
All tarantula leg code is collected in a separate module
to ease future distribution and scheduling.
The optimizer works by looking only to the mat.pack statement.

It recursively calls the optimizer used to create multiple versions, which,
when scheduled correctly, would not lead to duplicate work.
@c
	(void) fixModule(cntxt->nspace,tarantulaRef);

	leg= (MalBlkPtr *) GDKmalloc(sizeof(MalBlkPtr) * maxlegs);
	if ( leg == NULL)
		return 0;

	limit = mb->stop;
	old = mb->stmt;

	if ( newMalBlkStmt(mb, mb->ssize) < 0){
		GDKfree(leg);
		return 0;
	}
	pushInstruction(mb, old[0]);

	sig= old[0];
	for (i = 1; i < limit; i++) {
		p = old[i];
		if ( p == pci){
			freeInstruction(pci);
			old[i]= 0;
			continue;
		}
		if( getModuleId(p)== matRef && getFunctionId(p)== packRef) {
			InstrPtr qq, mp;
			int conn,dbvar,qvar,schvar, resType, mpArgType;

			TARmakeRegistration(cntxt,mb,old,i,nodes);
			TARmakeBidding(cntxt,mb,old,i,nodes);
			//TARmakeExecution(cntxt,mb,old,i);

			tcnt = p->argc - p->retc;
			resType = getVarType(mb, getArg(p,0));

			/* prepare the execution dispatcher procedure */
			snprintf(buf,BUFSIZ,"x_%s", getFunctionId(getInstrPtr(mb,0)));
			s2= newFunction(tarantulaRef, putName(buf,strlen(buf)), FUNCTIONsymbol);
			sm= s2->def;
			q= getInstrPtr(sm,0);
			mpArgType = getArgType(mb,p,1);
			setArgType(sm,q,0,mpArgType);
			schvar = newVariable(sm,GDKstrdup("scheduled"),TYPE_bte);
			dbvar= newVariable(sm,GDKstrdup("dbname"),TYPE_str);
			qvar = newVariable(sm,GDKstrdup("query"),TYPE_str);
			version= newVariable(sm,GDKstrdup("version"),TYPE_int);
			q= pushArgument(sm,q,schvar);
			q= pushArgument(sm,q,dbvar);
			q= pushArgument(sm,q,qvar);
			q= pushArgument(sm,q,version);
			/* just add all arguments for the moment */
			for (j=sig->retc; j < sig->argc; j++){
				int aj= cloneVariable(sm,mb,getArg(sig,j));
				q = pushArgument(sm,q,aj);
			}

			/* create the leg, modifying the current plan */
			/* initialize the result variables */
			q= newAssignment(mb);
			getArg(q,0)= getArg(p,0);
			q= pushNil(mb,q, resType);

			/* Generate register block */
			r = newStmt2(mb,schedulerRef,registerRef);
			r->barrier = BARRIERsymbol;
			setArgType(mb,r,0, TYPE_bit);
			rexit = getArg(r,0);

			/* generate string constants holding worker and leg names */
			cst.vtype = TYPE_str;
			
			wnm = (int*) GDKzalloc(sizeof(int) * tcnt);
			tnm = (int*) GDKzalloc(sizeof(int) * tcnt);
			bid = (int**) GDKzalloc(sizeof(int*) * tcnt);
			sch = (int**) GDKzalloc(sizeof(int*) * tcnt);
			res = (int**) GDKzalloc(sizeof(int*) * tcnt);
			for ( j= 0; j < tcnt; j++){
				snprintf(buf,BUFSIZ,"worker_%d",j); 
				cst.val.sval= GDKstrdup(buf);
				cst.len= (int) strlen(cst.val.sval);
				wnm[j] = defConstant(mb, TYPE_str, &cst);
	
				snprintf(buf,BUFSIZ,"leg_"LLFMT"_%d", mb->legid,p->argv[j+1]); 
				cst.val.sval= GDKstrdup(buf);
				cst.len= (int) strlen(cst.val.sval);
				tnm[j] = defConstant(mb, TYPE_str, &cst);

				bid[j] = (int*) GDKzalloc(sizeof(int) * tcnt);
				sch[j] = (int*) GDKzalloc(sizeof(int) * tcnt);
				res[j] = (int*) GDKzalloc(sizeof(int) * tcnt);

			}
			
			for ( j= 0; j < tcnt; j++)
				for ( k= 0; k < tcnt; k++){
					r = newFcnCall(mb,tarantulaRef, registerRef);
					r = pushArgument(mb,r,wnm[k]);
					r = pushArgument(mb,r,tnm[j]);
			}

			r = newAssignment(mb);
			r->barrier= EXITsymbol;
			getArg(r,0) = rexit;

			/* Generate bidding block */
			for ( j = 0; j < tcnt; j++)
				for ( k = 0; k < tcnt; k++){
					r = newAssignment(mb);
					setArgType(mb,r,0,TYPE_lng);
					pushLng(mb,r,(lng)-1);
					bid[j][k] = getArg(r,0);
			}
			r = newStmt2(mb,schedulerRef,putName("bidding",7));
			r->barrier = BARRIERsymbol;
			setArgType(mb,r,0, TYPE_bit);
			rexit = getArg(r,0);

			cst.vtype = TYPE_sht;
			cst.val.shval = bidStrategy;
			bs = defConstant(mb, TYPE_sht, &cst);
			for ( j = 0; j < tcnt; j++)
				for ( k = 0; k < tcnt; k++){
					r = newStmt2(mb,tarantulaRef, putName("getBid",6));
					r = pushArgument(mb,r,wnm[k]);
					r = pushArgument(mb,r,tnm[j]);
					r = pushArgument(mb,r,bs);
		/*			setArgType(mb,r,0,TYPE_lng);*/
					setVarUDFtype(mb,getArg(r,0));
					getArg(r,0) = bid[j][k];
			}

			r = newAssignment(mb);
			r->barrier= EXITsymbol;
			getArg(r,0) = rexit;

			/* Generate call to bid scheduling */
			r = newStmt2(mb, schedulerRef, putName("makeSchedule", 12));
			setArgType(mb, r, 0, TYPE_bte);
			sch[0][0] = getArg(r, 0);
			setVarUDFtype(mb, getArg(r, 0));
			for (j = 0; j < tcnt; j++)
				for (k = 0; k < tcnt; k++)
					if (j || k) {
						sch[j][k] = newTmpVariable(mb, TYPE_bte);
						r = pushArgument(mb, r, sch[j][k]);
					}
			r->retc = tcnt * tcnt;
			r = pushInt(mb, r, tcnt);
			for (j = 0; j < tcnt; j++)
				for (k = 0; k < tcnt; k++)
					r = pushArgument(mb, r, bid[j][k]);

			/* Execution block */
			/* Initialize result variables */
			for (j = 0; j < tcnt; j++)
				for (k = 0; k < tcnt; k++) {
					if (isaBatType(mpArgType)) {
						r = newFcnCall(mb, batRef, newRef);
						r = pushType(mb, r, getHeadType(mpArgType));
						r = pushType(mb, r, getTailType(mpArgType));
					} else {
						r = newAssignment(mb);
						r = pushNil(mb, r, mpArgType);
					}
					setArgType(mb, r, 0, mpArgType);
					res[j][k] = getArg(r, 0);
				}

			/* barrier (go,version):= scheduler.tarantula(timeout); */
			qq = q = newStmt(mb, schedulerRef, tarantulaRef);
			setArgType(mb, q, 0, TYPE_bit);
			v2 = newVariable(mb, GDKstrdup("version"), TYPE_int);
			pushArgument(mb, q, v2);
			q->retc = 2;
			q = pushInt(mb, q, 10);
			q->barrier = BARRIERsymbol;

			for (j = p->retc; j < p->argc; j++)
				leg[tn++] = TARmakeleg(cntxt, mb, old, i, j);

			/* exit c; */
			q = newAssignment(mb);
			q->barrier = EXITsymbol;
			getArg(q, 0) = getArg(qq, 0);
			getArg(q, 1) = v2;
			q->retc = 2;
			q->argc = 2;

/*			pushInstruction(mb,p); */

			/* create new mat.pack() instruction */
			mp = newFcnCall(mb,matRef,packRef);
			getArg(mp,0) = getArg(p,0);
			for ( k = getPC(mb,qq) + 1; k < getPC(mb,q); k++) {
				mp = pushArgument(mb,mp,getArg(getInstrPtr(mb,k),0)); 
			}
/*			freeInstruction(p); */

			/* finalize the exec function (mal block sm) */

			if (isaBatType(mpArgType)) {                /* exec_qry:= bat.new(:htp,:ttp); */
				q = newFcnCall(sm, batRef, newRef);
				q = pushType(sm, q, getHeadType(mpArgType));
				q = pushType(sm, q, getTailType(mpArgType));
			}else  {                        /* exec_qry:= nil:tp; */
				q = newAssignment(sm);
				q = pushNil(sm, q, mpArgType);
			}
			getArg(q, 0) = getArg(getInstrPtr(sm, 0), 0);
	
			/* barrier cond:= calc.>(i,0); */
			r = newFcnCall(sm,calcRef,putName(">",1));
			r->barrier = BARRIERsymbol;
			rexit = getArg(r,0);  
			setArgType(sm,r,0,TYPE_bit);
			r = pushArgument(sm,r,schvar);
			r = pushBte(sm,r,0);

			q = newStmt(sm, tarantulaRef,connectRef);
			conn= getArg(q,0);
			q = pushArgument(sm, q, dbvar);
/*			q= pushStr(sm,q,"monetdb");
			q= pushStr(sm,q,"monetdb");
			q= pushStr(sm,q,"msql"); */

			/* v:= remote.put(conn,version) */
			q= newFcnCall(sm,remoteRef,putRef);
			q= pushArgument(sm,q,conn);
			q= pushArgument(sm,q,version);
			version= getArg(q,0);

			/* get addition arguments needed in a leg */
			assert(sig->argc <1024);
			for (j= sig->retc; j<  sig->argc; j++){
				l= newTmpVariable(sm,TYPE_str);
				q= newFcnCall(sm,remoteRef,putRef);
				arg[j]= getArg(q,0)= l;
				pushArgument(sm,q, conn);
				pushArgument(sm,q,findVariable(sm,getArgName(mb,sig,j)));
			}

			/* k:= remote.put(conn,kvar) */
			q= newFcnCall(sm,remoteRef,putRef);
			q= pushArgument(sm,q,conn);
			q= pushArgument(sm,q, getArg(getInstrPtr(sm,0),0));
			setVarUDFtype(sm,getArg(q,q->argc-1));
			k= getArg(q,0);

			/* k:= remote.exec(conn,tarantula,qry,version....) */
			q= newFcnCall(sm,remoteRef,execRef);
			getArg(q,0)= k;
			q= pushArgument(sm,q,conn);
			q= pushStr(sm,q,tarantulaRef);
			q= pushArgument(sm,q,qvar);
			q= pushArgument(sm,q,version);
			/* deal with all arguments !*/
			for (j=sig->retc; j < sig->argc; j++)
				q = pushArgument(sm,q,arg[j]);


			/* l:=remote.get(conn,k) */
			q= newFcnCall(sm,remoteRef,getRef);
			q= pushArgument(sm,q,conn);
			q= pushArgument(sm,q,k);
			l= getArg(q,0);
			setVarType(sm,l, getArgType(sm,getInstrPtr(sm,0),0));
			setVarUDFtype(sm,l);

			/* catch and propagate errors */
			newCatchStmt(sm, "ANYexception");
/*			q = newStmt(sm, remoteRef,disconnectRef);
			pushArgument(sm,q,conn); */
			newRaiseStmt(sm,"ANYexception");
			newExitStmt(sm, "ANYexception");

			/* close connection 
			q = newStmt(sm, remoteRef,disconnectRef);
			pushArgument(sm,q,conn); */

			/* exec_qry:= l; */
			q= newAssignment(sm);
			getArg(q,0)= getArg(getInstrPtr(sm,0),0);
			pushArgument(sm,q,l);

			r = newAssignment(sm);
			r->barrier= EXITsymbol;
			getArg(r,0) = rexit;

			/* return exec_qry; */
			q= newAssignment(sm);
			q->barrier= RETURNsymbol;
			getArg(q,0)= getArg(getInstrPtr(sm,0),0);

			pushEndInstruction(sm);
			insertSymbol(findModule(cntxt->nspace,tarantulaRef),s2);
			clrDeclarations(sm);
			chkProgram(cntxt->nspace,sm);
			actions++;
			continue;
		} 
		pushInstruction(mb,p);
		if (p->token == ENDsymbol){
			last= i;
			break;
		}
	}
	
@-
Keep the remaining optimizers in the main program.
The leg code should be optimized by the remaining optimizers too.
@c
	for (j = last + 1; j < limit; j++)
		if (old[j])
			pushInstruction(mb, old[j]);

	for (j = last + 1; j < limit; j++)
		for (i = 0; i < tn; i++)
			if (old[j] && old[j]->token != REMsymbol) {
				tmb = leg[i];
				if (getModuleId(old[j]) == optimizerRef &&
						getFunctionId(old[j]) == putName("reduce", 6)) {
					q = newStmt(tmb, optimizerRef, putName("recycle", 7));
					q = pushStr(tmb, q, tarantulaRef);
					q = pushStr(tmb, q, getFunctionId(getInstrPtr(tmb, 0)));
				}
				q = newStmt(tmb, getModuleId(old[j]), getFunctionId(old[j]));
				q = pushStr(tmb, q, tarantulaRef);
				q = pushStr(tmb, q, getFunctionId(getInstrPtr(tmb, 0)));
			}
	for (i = 0; i < tn; i++) {
		clrDeclarations(leg[i]);
		chkProgram(cntxt->nspace, leg[i]);
/*		optimizeMALBlock(cntxt,leg[i]); */
		if (leg[i]->errors)
			mb->errors++;
	}
	chkDeclarations(mb);
		chkProgram(cntxt->nspace,mb);  
	OPTDEBUGtarantula
	if (actions) {
		stream_printf(cntxt->fdout, "DONE tarantula \n");
		printFunction(cntxt->fdout, mb, 0, LIST_MAL_STMT);
		printFunction(cntxt->fdout, sm, 0, LIST_MAL_STMT);
		for (i=0; i<tn; i++){
			chkDeclarations(leg[i]);
			chkFlow(leg[i]);
			printFunction(cntxt->fdout, leg[i], 0, LIST_MAL_STMT);
		}
	}
/*	printFunction(cntxt->fdout, mb, 0, LIST_MAL_STMT);
	printFunction(cntxt->fdout, sm, 0, LIST_MAL_STMT);

	for (i=0; i<tn; i++)
		printFunction(GDKout, leg[i], 0, LIST_MAL_STMT);
*/
	GDKfree(wnm);
	GDKfree(tnm);
	for ( j= 0; j < tcnt; j++){
		GDKfree(bid[j]);
		GDKfree(sch[j]);
		GDKfree(res[j]);
	}
	GDKfree(bid);
	GDKfree(sch);
	GDKfree(res);
	GDKfree(old);
	GDKfree(leg);
	(void) stk;
	return actions;
}
@include optimizerWrapper.mx
@c
#include "opt_statistics.h"
@:wrapOptimizer(tarantula,OPT_CHECK_ALL)@
@c
str
TARregister(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	(void) cntxt;
	(void) mb;
	(void) stk;
	(void) p;
	return MAL_SUCCEED;
}
str
TARgetBid(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	(void) cntxt;
	(void) mb;
	(void) stk;
	(void) p;
	return MAL_SUCCEED;
}
@}
