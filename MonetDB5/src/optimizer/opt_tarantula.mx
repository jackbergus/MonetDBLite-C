@/
The contents of this file are subject to the MonetDB Public License
Version 1.1 (the "License"); you may not use this file except in
compliance with the License. You may obtain a copy of the License at
http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html

Software distributed under the License is distributed on an "AS IS"
basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations
under the License.

The Original Code is the MonetDB Database System.

The Initial Developer of the Original Code is CWI.
Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
Copyright August 2008-2010 MonetDB B.V.
All Rights Reserved.
@

@f opt_tarantula
@a M. Kersten
@- Multileg creatures
Query execution can be improved significantly using distributed processing.
Traditionally, this encompasses fragmentation and allocation of the base
tables over multiple sites and query plans that include on the fly transport
of intermediate results.

Breaking the database into pieces itself is a well-studied area.
Most approaches consider the workload and search for a good split
of the base tables, such that the workload performance improves.

The Tarantula optimizer, like the Octopus optimizer, use the
output of the mitosis+mergetable optimizer and produces the
actual plans for parallel execution.
They both break a single, large fact-table into pieces
based on the head and propagate the effect through the plan.

The tarantula untangles the resulting plan into a controlling head
function and a series of plans, one for each leg to execute concurrently.
The allocation of a subplan to leg depends on a bidding scheme. 
Bidding can not depend on BAT arguments, because that would cause 
significant communication overhead. Scalar values could be used and
would function well in terms of using the recycler to get involved into
precise bidding. 

The Tarantula optimizer differs from the Octopus optimizer in performing
a recursive divide and conquer method to deal with blocking operations.
Furthermore, we assume that the persistent store is shared amongst
the node, which means that fragments of the tables can be directly accessed.

A snippet of an tarantula plan with two legs is shown.
The main part of the query becomes a three step procedure of
1) remote registration of subplans, 2) obtaining bids and schedule design
and 3) execute the subplans.
Each plan does not contain duplicate node ids.
@verbatim
function reg_qry_0():int;
	tarantula.register(0,"qry_0","qry_1");
	tarantula.register(1,"qry_0","qry_1");
	return 0;
end reg_qry;

function bid_qry_0(hdl:int)(leg0:int,leg1:int,leg2:int,leg3:int);
	(_4,_5) := tarantula.getBid(0,"qry_0","qry_1");
	(_6,_7) := tarantula.getBid(1,"qry_0","qry_1");
    return (leg0,leg1,leg2,leg3) := scheduler.schedule_0(_4,_5,_6,_7);
end bid_qry;

function run_qry(node_0:int,node_1:int):bat[:oid,:int]
    _87 := tarantula.execute(node_0,"leg0");
    _88 := tarantula.execute(node_1,"leg1");
    _15 := mat.pack(_87,_88);
	return run_qry := _15;
end run_qry;

function user.qry():void;
	_3 := reg_qry_0();
	(_4,_5,_6,_7):= bid_qry_0(_3);
	_15 := tarantula.run_qry(_4,_5,_6,_7);
    _16 := sql.resultSet(1,1,_15);
    sql.rsColumn(_16,"sys.squida","bid","int",32,0,_15);
    _21 := io.stdout();
    sql.exportResult(_21,_16);
end qry;
@end verbatim
The nodes addressed by the tarentula are indices into a global catalog.
The number of subplans is derived by the Mitosis as the number of pieces to consider.
The tarantula may register the subplans to more nodes than pieces.

@verbatim
function tarantula.exec_qry_0(node:str,fcn:str):bat[:oid,:int];
	conn:= remote.connect(node,"monetdb","monetdb");
	r:= remote.exec(conn,"tarantula",fcn);
	b:bat[:oid,:int]:= remote.get(conn,r);
	return b;
end exec_qry;
@end verbatim

@verbatim
function tarantula.qry_0(version:int):bat[:oid,:int];
    _53:bat[:oid,:int] := attach.bind("file://export/scratch/mk/dbfarm/demo/bat/01/001");
	_54 := algebra.slice(_53,0@0,25@0);
    _63:bat[:oid,:int] := attach.bind("file://export/scratch/mk/dbfarm/demo/bat/01/002");
	_64 := algebra.slice(_63,0@0,25@0);
    _72 := algebra.kdifference(_54,_64);
    _78 := algebra.kunion(_72,_64);
    _13:bat[:oid,:oid]  := attach.bind("file://export/scratch/mk/dbfarm/demo/bat/01/003");
    _14 := bat.reverse(_13);
    _85 := algebra.kdifference(_78,_14);
	return qry_0 := _85;
end tarantula.qry_0;

function tarantula.qry_1(version:int):bat[:oid,:int];
	... use second slice ...
end tarantula.qry_1;

@end verbatim

[Stability]
We assume that during a session, workers once started will remain alive.
No fault tolerance techniques are included.

[Recycling]
The legs contain registered functions and possible partial results in its recycler pool.
In the first implementation we assume a read-only database, where all workers are
restarted when changes to the underlying database affect the recycler pool.
Alternative, the head can clear the recycler pool explicitly upon such state change.

[Shared disk]
For a leg to work it needs access to its storage layer, which is a NAS.
It is encapsulated in the operation attach.bind("path",tuplecount).

The code generation for the legs currently relies on a conceptual full replication of
the database over the servers. The next version should use the attach() functionality
or use the datacylcotron to access portions.

These approaches are different from the Octopus, where the head is
the sole control over the persistent data. 

[Naming]
The legs received from the tarantula should be ensured
not to clash with those already known. Therefore, we simply
tag them by orginating site.

[Caveats]
Any update invalidates the request to distributed processing.
In the same line, multi-statement SQL transactions and
updates to global variables are ignored. 

Global variables are tricky, because they are part of the
session context. To make it work, we need to be able to perform
an upcall to that context (=dangerous).
The solution is that any variable context should be
passed through a relation.
@{
@mal
module tarantula; 
pattern optimizer.tarantula():str
address OPTtarantula;
pattern optimizer.tarantula(mod:str, fcn:str):str
address OPTtarantula
comment "Map-execute-reduce parallelism optimizer";

@h
#ifndef _TAR_OCTOPUS_
#define _TAR_OCTOPUS_
#include "opt_prelude.h"
#include "opt_support.h"

#ifdef WIN32
#ifndef LIBOPTIMIZER
#define opt_export extern __declspec(dllimport)
#else
#define opt_export extern __declspec(dllexport)
#endif
#else
#define opt_export extern
#endif

typedef struct REGMAL{
    str fcn;
    struct REGMAL *nxt;
} *Registry;

typedef struct {
    str uri;
    str usr;
    str pwd;
    Registry nxt; /* list of registered mal functions */
    bte active;
    str conn;
    int inuse;
} Peer;

opt_export int TARgetPeer(str uri);

#define MINLEGSIZE 5	/* number of MAL instructions to consider for a leg */
#define MAXSITES 2048   /* should become dynamic at some point */
Peer peers[MAXSITES];    /* registry of peer servers */
int TARnrpeers=0;
bte tarantulaLocal=0;

@:exportOptimizer(tarantula)@

#define OPTDEBUGtarantula  if ( optDebug & ((lng)1 <<DEBUG_OPT_TARANTULA) )

#endif
@c
#include "mal_config.h"
#include "opt_tarantula.h"
#include "opt_deadcode.h"
#include "mal_interpreter.h"	/* for showErrors() */
#include "mal_builder.h"
#include <mapilib/Mapi.h>
#include "remote.h"
#include "mal_sabaoth.h"
@-
The algorithm consists of several steps. The first one
replaces the original query and creates the leg functions.
In the second phase the should be registered at the different sites.

The key observation is that whenever we encounter a mat.pack,
there is a need to bring information together for inspection.
It indicates a blocking operation.
Therefore, we recursively break a plan by looking for the
pack instructions and collect all dependent instructions.
The original block is trimmed as far as needed.
@c
static int
TARinitcode(Client cntxt, MalBlkPtr mb){
	InstrPtr p;
	str s;
	str l = NULL;

	(void) cntxt;

	/* _x := remote.connect(uri,"monetdb","monetdb","msql"); */
	p = newStmt(mb, remoteRef,connectRef);
	s = GDKgetenv("merovingian_uri");
	if (s == NULL) /* aparently not under Merovingian control, fall back to local only */
		SABAOTHgetLocalConnection(&l);
	p= pushStr(mb,p, s == NULL ? l : s);
	p= pushStr(mb,p,"monetdb");
	p= pushStr(mb,p,"monetdb");
	p= pushStr(mb,p,"msql");
	if (l)
		GDKfree(l);
	return getArg(p,0);
}

@-
Be prepared to catch errors from the remote site.
You should catch them, otherwise the session is not closed.
Beware, exceptions should be catched and thrown after the
connection has been closed.
@c
static void
TARexitcode(MalBlkPtr mb, int conn, int varid)
{
	InstrPtr p;

	newCatchStmt(mb, "ANYexception");
	p = newStmt(mb, remoteRef, disconnectRef);
	pushArgument(mb, p, conn);
	newRaiseStmt(mb, "ANYexception");	/* pass to caller */
	newExitStmt(mb, "ANYexception");

	p = newStmt(mb, remoteRef, disconnectRef);
	pushArgument(mb, p, conn);
	p = newAssignment(mb);
	getArg(p, 0) = getArg(getInstrPtr(mb, 0), 0);
	pushArgument(mb, p, varid);
	p->barrier = RETURNsymbol;
	pushEndInstruction(mb);
	p = newStmt(mb, optimizerRef, putName("aliases", 7));
	p = pushStr(mb, p, tarantulaRef);
	p = pushStr(mb, p, getFunctionId(getInstrPtr(mb, 0)));
}

static int
TARfindPeer(str uri)
{
	int i;
	for (i=0; i<TARnrpeers; i++){
		if ( strcmp(uri, peers[i].uri) == 0 ){
			return i;
		}
	}
	return -1;
}

/* Look for and add a peer with uri in the registry.  Return index in registry */
int
TARgetPeer(str uri)
{
	int i;

	i = TARfindPeer(uri);
	if ( i >=0 ) {
		peers[i].active = 1;
		return i;
	}
	if ( TARnrpeers == MAXSITES)
		return -1;
	i = TARnrpeers;
	peers[i].usr = GDKstrdup("monetdb");
	peers[i].uri = GDKstrdup(uri);
	peers[i].pwd = GDKstrdup("monetdb");
	peers[i].active = 1;
	peers[i].nxt = NULL;
	peers[i].inuse = 0;		
	TARnrpeers++;
	return i;
}

/* Clean function registry of non-active peers */

void TARcleanFunReg(int i)
{	
	Registry r, q;
	mal_set_lock(mal_contextLock,"tarantula.cleanFunReg");
	r = peers[i].nxt;
	peers[i].nxt = NULL;
	mal_unset_lock(mal_contextLock,"tarantula.cleanFunReg");
	while ( r ) {
			q = r->nxt;
			GDKfree(r->fcn);
			GDKfree(r);
			r = q;
	}
}

str
TARdiscover(Client cntxt)
{
	bat bid = 0;
	BAT *b;
	BUN p,q;
	str msg = MAL_SUCCEED;
	BATiter bi;
	char buf[BUFSIZ]= "*/tarantula", *s= buf;
	int i, nrworkers = 0;

	tarantulaLocal = 0;

	/* we have a new list of candidate peers */
	for (i=0; i<TARnrpeers; i++)
		peers[i].active = 0;

	msg = RMTresolve(&bid,&s);
	if ( msg == MAL_SUCCEED) {
		b = BATdescriptor(bid);
		if ( b != NULL && BATcount(b) > 0 ) {
			bi = bat_iterator(b);
			BATloop(b,p,q){
				str t= (str) BUNtail(bi,p);
				nrworkers += TARgetPeer(t) >= 0; 
			}
		}
		BBPreleaseref(bid);
	} else
		GDKfree(msg);

	if ( !nrworkers  ) {
	 	/* there is a last resort, local execution */
		SABAOTHgetLocalConnection(&s);
	
		nrworkers += TARgetPeer(s) >= 0;
		tarantulaLocal = 1;
	}

#ifdef DEBUG_RUN_TAR
	mnstr_printf(cntxt->fdout,"Active peers discovered %d\n",nrworkers);
	for (i=0; i<TARnrpeers; i++)
	if ( peers[i].uri )
		mnstr_printf(cntxt->fdout,"%s\n", peers[i].uri);
#else
		(void) cntxt;
#endif

	for (i=0; i<TARnrpeers; i++)
		if ( !peers[i].active )
			TARcleanFunReg(i);

	return MAL_SUCCEED;
}
@-
The TARmakeleg walks through the MAL block and extracts the dependent structure for
execution. Note that information van be recomputed in all legs. Possibly doing duplicate work.
Keep track of the variables that will be used outside the leg. They have to be exported.
Likewise, look for variables that are produced by other legs and will become input parameters.
@c
static MalBlkPtr 
TARmakeleg(Client cntxt, MalBlkPtr mb, InstrPtr *old, int pc, int idx, Lifespan span, int *map)
{
	MalBlkPtr tm = NULL;
	InstrPtr p = NULL, sig;
	int i, j, top=0, fnd, block = 0;
	char buf[BUFSIZ];
	InstrPtr *list = (InstrPtr*) GDKzalloc(sizeof(InstrPtr) * mb->ssize);
	char *needed= (char*) GDKzalloc(mb->vtop);
	int *alias= (int*) GDKzalloc(mb->vtop * sizeof(int));
	int itop = 0, *input = ( int*) GDKzalloc(mb->vtop * sizeof(int));
	int otop = 0, *output = ( int*) GDKzalloc(mb->vtop * sizeof(int));
	Symbol s;

	assert(old[pc]->fcnname == packRef);

	OPTDEBUGtarantula {
		mnstr_printf(cntxt->fdout,"#create leg for %d %d %d\n",pc,idx -old[pc]->retc, getArg(old[pc],idx));
	}
@-
Find the instructions needed. Beware pack operations
already have been handled and produce their target.
Build the variable admin table.
@c
	needed[getArg(old[pc],idx)]=1;
	output[otop++]= getArg(old[pc],idx);
	for ( j = old[0]->retc; j< old[0]->argc; j++)
		input[itop++]= getArg(old[0],j);
	for (i = pc-1; i > 0; i--){
		p = old[i];

		fnd = 0;
		switch( p->barrier ){
		case EXITsymbol: block++; break;
		case CATCHsymbol: block--; break;
		case BARRIERsymbol: block--; break;
		}
		if ( block ){
			for (j = 0; j < p->argc; j++)
				needed[getArg(p,j)]= 1;
			fnd = 1;
		}
		for (j = 0; j < p->retc; j++)
			fnd += needed[getArg(p,j)];
		if ( fnd) { /* instruction is needed */
			for (j = 0; j < p->argc; j++){
				assert(getArg(p,j) >=0);
				needed[getArg(p,j)]= 1;
				if ( getEndLifespan(span, getArg(p,j)) > pc)
					output[otop++]= getArg(p,j);
				if ( map[getArg(p,j)] != getArg(p,j) )
					input[itop++] = getArg(p,j);
			}
			list[top++] = p;
		}
	}
@-
The leg should have enough instructions to warrant a distributed execution. This should involve
a careful analysis of the instructions assembled. For the time being, we only allow for a leg 
if at least a sql.bind operation belongs to the list and the leg has a minimimal number of statements.
@c
	fnd = 0;
	for( i=0; i<top; i++) {
	 fnd += getModuleId(list[i]) == sqlRef && getFunctionId(list[i]) == bindRef;
	 fnd += getModuleId(list[i]) == sqlRef && getFunctionId(list[i]) == bindidxRef;
	 fnd += getModuleId(list[i]) == sqlRef && getFunctionId(list[i]) == binddbatRef;
	}

	if ( top - fnd <= MINLEGSIZE) {
		GDKfree(list);
		GDKfree(alias);
		GDKfree(needed);
		GDKfree(input);
		GDKfree(output);
		return 0;
	}
@-
Create the leg function.
@c
	snprintf(buf,BUFSIZ,"%s_%d_%d", getFunctionId(getInstrPtr(mb,0)), getArg(old[pc],0), idx-old[pc]->retc);
	putName(buf,strlen(buf));

	s= newFunction(tarantulaRef, putName(buf,strlen(buf)), FUNCTIONsymbol);
	insertSymbol(findModule(cntxt->nspace,tarantulaRef),s);
	tm= s->def;
	sig= getInstrPtr(tm,0);
	setVarType(tm,getArg(sig,0), getArgType(mb,old[pc],idx));
	setVarUDFtype(tm,getArg(sig,0));

	/* add the return variables */
	for ( i = 1; i< otop; i++){
		alias[output[i]] = cloneVariable(tm,mb,output[i]);
		sig = pushReturn(tm, sig, alias[output[i]]);
		setVarUDFtype(tm,getArg(sig,i));
	}
	/* add the arguments from the query template */
	for ( i = 0; i< itop; i++){
		alias[input[i]] = cloneVariable(tm,mb,input[i]);
		sig = pushArgument(tm, sig, alias[input[i]]);
	}

	/* include the necessary functions */
	for (top--; top >= 0; top--){
		p = copyInstruction(list[top]);
		for (i= 0; i< p->argc; i++){
			int a= getArg(p,i);
			if (alias[a]==0) 
				alias[a] = cloneVariable(tm,mb,a);
			getArg(p,i) = alias[a];
		}
		pushInstruction(tm, p);
	}

	/* return all variables of interest */
	p = newAssignment(tm);
	p->barrier = RETURNsymbol;
	p->retc= 0;
	p->argc= 0;
	for ( i = 0; i < sig->retc; i++)
		p = pushReturn(tm,p, getArg(sig,i));
	for ( i = 0; i < otop; i++)
		p = pushArgument(tm,p, alias[output[i]]);
	pushEndInstruction(tm);
	clrDeclarations(tm);
	chkProgram(cntxt->nspace,tm);
	if ( tm->errors )
		mb->errors++;

	GDKfree(list);
	GDKfree(alias);
	GDKfree(needed);
	GDKfree(input);
	GDKfree(output);
	return tm;
}

static void
TARmakeRegistration(Client cntxt, MalBlkPtr mb, InstrPtr *old, int pc, int nodes)
{
	Symbol s;
	MalBlkPtr tm;
	InstrPtr p,sig;
	char fcn[BUFSIZ];
	char buf[BUFSIZ];
	int i,n,k=0;
	str name;

	snprintf(fcn,BUFSIZ,"reg_%s_%d", name = getFunctionId(getInstrPtr(mb,0)), getArg(old[pc],0));
	s= newFunction(tarantulaRef, putName(fcn,strlen(fcn)), FUNCTIONsymbol);
	insertSymbol(findModule(cntxt->nspace,tarantulaRef),s);
	tm= s->def;
	sig = getInstrPtr(tm,0);

	setVarType(tm, getArg(getInstrPtr(tm,0),0), TYPE_int);
	for ( n= 0; n < nodes; n++, k = 0){
		p= newStmt(tm,tarantulaRef,registerRef);
		p= pushInt(tm, p,n);
		for( i=old[pc]->retc; i< old[pc]->argc; i++){
			snprintf(buf,BUFSIZ,"%s_%d_%d",name,getArg(old[pc],0), k++);
			p = pushStr(tm,p,buf);
		}
	}

	p= newAssignment(tm);
	getArg(p,0) = getArg(sig,0);
	p = pushInt(tm,p,0);
	p->barrier = RETURNsymbol;
	pushEndInstruction(tm);
	clrDeclarations(tm);
	chkProgram(cntxt->nspace,tm);
	OPTDEBUGtarantula
		printFunction(cntxt->fdout, tm, 0, LIST_MAL_STMT | LIST_MAPI);
}

@-
Ask the participants for a bid and perform the node selection for the legs.
@c
static void
TARmakeBidding(Client cntxt, MalBlkPtr mb, InstrPtr *old, int pc, int nodes)
{
	Symbol s;
	MalBlkPtr tm;
	InstrPtr p,r,sig;
	char buf[BUFSIZ], fcn[BUFSIZ];
	int i, n, tmp, k=0;
	str name, getBidRef= putName("getBid",6);

	snprintf(fcn,BUFSIZ,"bid_%s_%d", name = getFunctionId(getInstrPtr(mb,0)), getArg(old[pc],0));
	s= newFunction(tarantulaRef, putName(fcn,strlen(fcn)), FUNCTIONsymbol);
	insertSymbol(findModule(cntxt->nspace,tarantulaRef),s);
	tm= s->def;

	sig = getInstrPtr(tm,0);
	getArg(sig,0)= -1;
	r= newInstruction(NULL,ASSIGNsymbol);
	setModuleId(r,tarantulaRef);
	setFunctionId(r,putName("schedule",8));
	r->barrier = RETURNsymbol;
	/* return the node id for subplan execution */
	for (k= 0; k < nodes; k++){
		snprintf(buf,BUFSIZ,"node%d",k++);
		sig= pushReturn(tm, sig, n = newVariable(tm, GDKstrdup(buf),TYPE_int));
		r = pushReturn(tm,r,n);
	}
	sig = pushArgument(tm, sig, newTmpVariable(tm,TYPE_int));

	for (n= 0; n < nodes; n++){
		p= newInstruction(tm,ASSIGNsymbol);
		setModuleId(p, tarantulaRef);
		setFunctionId(p, getBidRef);
		p= pushInt(tm, p,n);
		for(k=0, i=old[pc]->retc; i< old[pc]->argc; k++, i++){
			snprintf(buf,BUFSIZ,"%s_%d_%d",name,getArg(old[pc],0),k);
			p = pushStr(tm,p,buf);
			p = pushReturn(tm, p, tmp = newTmpVariable(tm,TYPE_int));
			r = pushArgument(tm,r,tmp);
		}
		pushInstruction(tm,p);
	}
	pushInstruction(tm,r);
	pushEndInstruction(tm);
	clrDeclarations(tm);
	chkProgram(cntxt->nspace,tm);
	OPTDEBUGtarantula
		printFunction(cntxt->fdout, tm, 0, LIST_MAL_STMT | LIST_MAPI);
}
@-
The executor gets node assignments for each of the legs and
performs a remote operation on the subplan. The results are 
assembled using a pack and returned to the caller.
@c
static void
TARmakeExecution(Client cntxt, MalBlkPtr mb, InstrPtr *old, int pc, MalBlkPtr leg)
{
	Symbol s;
	MalBlkPtr tm;
	char fcn[BUFSIZ];
	InstrPtr lsig,sig, r, q;
	int conn,j,l;
	int arg[1024];

	/* generate stubb code for the remote execution */
	snprintf(fcn,BUFSIZ,"rmt_%s_%d", getFunctionId(getInstrPtr(mb,0)), getArg(old[pc],0));
	s= newFunction(tarantulaRef, putName(fcn,strlen(fcn)), FUNCTIONsymbol);
	insertSymbol(findModule(cntxt->nspace,tarantulaRef),s);
	tm= s->def;
	sig = getInstrPtr(tm,0);

	/* add the return values */
	lsig= getInstrPtr(leg,0);
	setVarType(tm, getArg(sig,0), getVarType(leg,getArg(lsig,0)));
	for ( j=1;j < lsig->retc; j++)
		sig= pushReturn(tm, sig, cloneVariable(tm, leg, getArg(lsig,j)));

	/* get the input arguments */
	sig = pushArgument(tm,sig,newVariable(tm,GDKstrdup("node"),TYPE_int));
	sig = pushArgument(tm,sig,newVariable(tm,GDKstrdup("fcn"),TYPE_str));
	/* copy the query arguments */
	for ( j=lsig->retc; j < lsig->argc; j++)
		sig= pushArgument(tm, sig, cloneVariable(tm, leg, getArg(lsig,j)));


	/* conn := tarantula.connect(node); */
	q = newStmt(tm, tarantulaRef,connectRef);
	conn= getArg(q,0);
	q = pushArgument(tm, q, getArg(sig,1));

	/* get addition arguments needed in a leg */
	/* k:= remote.put(conn,kvar) */
	for (j= 0; j < sig->argc; j++)
	if ( j != sig->retc && j != sig->retc+1 ){
		q= newFcnCall(tm,remoteRef,putRef);
		setVarType(tm, getArg(q,0), TYPE_str);
		setVarUDFtype(tm, getArg(q,0));
		q= pushArgument(tm,q,conn);
		q= pushArgument(tm,q,getArg(sig,j));
		arg[j]= getArg(q,0);
	}

	/* (k1,...kn):= remote.exec(conn,tarantula,qry,version....) */
	q= newFcnCall(tm,remoteRef,execRef);
	q->retc=  q->argc= 0;
	for (j=0; j < sig->retc; j++)
		q = pushReturn(tm,q,arg[j]);
	q= pushArgument(tm,q,conn);
	q= pushStr(tm,q,tarantulaRef);
	q= pushArgument(tm,q,getArg(sig,sig->retc+1));
	/* deal with all arguments ! */
	for (j=sig->retc+2; j < sig->argc; j++)
		q = pushArgument(tm,q,arg[j]);


	/* return exec_qry; */
	r= newInstruction(tm, ASSIGNsymbol);
	r->barrier= RETURNsymbol;
	r->retc= r->argc= 0;
	for ( j=0; j< sig->retc; j++)
		r= pushReturn(tm,r, getArg(sig,j));

	/* l:=remote.get(conn,k) */
	for ( j=0; j< sig->retc; j++){
		q= newFcnCall(tm,remoteRef,getRef);
		q= pushArgument(tm,q,conn);
		q= pushArgument(tm,q,arg[j]);
		l= getArg(q,0);
		setVarType(tm,l, getArgType(tm,sig,j));
		setVarUDFtype(tm, l);
		r= pushArgument(tm,r,l);
	}

	/* catch and propagate errors */
	newCatchStmt(tm, "ANYexception");
	/* q = newStmt(tm, remoteRef,disconnectRef);
	pushArgument(tm, q, conn); */
	newRaiseStmt(tm,"ANYexception");
	newExitStmt(tm, "ANYexception");

	/* close connection 
	q = newStmt(tm, remoteRef, disconnectRef);
	pushArgument(tm,q,conn); */

	pushInstruction(tm,r);

	pushEndInstruction(tm);
	clrDeclarations(tm);
	chkProgram(cntxt->nspace,tm);
	OPTDEBUGtarantula
		printFunction(cntxt->fdout, tm, 0, LIST_MAL_STMT | LIST_MAPI);
}
@-
The legs of the tarantula can be executed in parallel.
Watch out, the arguments should occupy the head of the stack.
@c
static void
TARmakeRun(Client cntxt, MalBlkPtr mb, InstrPtr *old, int pc, int nodes, int legs, MalBlkPtr leg)
{
	Symbol s;
	MalBlkPtr tm;
	char buf[BUFSIZ], fcn[BUFSIZ];
	InstrPtr lsig, sig, r, p,q;
	int j,k,l,x=0;

	snprintf(fcn,BUFSIZ,"exe_%s_%d", getFunctionId(getInstrPtr(mb,0)), getArg(old[pc],0));
	s= newFunction(tarantulaRef, putName(fcn,strlen(fcn)), FUNCTIONsymbol);
	insertSymbol(findModule(cntxt->nspace,tarantulaRef),s);
	tm= s->def;

	sig = getInstrPtr(tm,0);
	lsig= getInstrPtr(leg,0);
	/* the result is a mat.pack whose type comes from mb */
	setVarType(tm,getArg(sig,0), getArgType(mb,old[pc],0));

	/* include the remaining return variables */
	for ( j=1;j < lsig->retc; j++)
		sig= pushReturn(tm, sig, cloneVariable(tm, leg, getArg(lsig,j)));

	/* add the execution nodes */
	for( k=0 ; k<nodes; k++){
		snprintf(buf,BUFSIZ,"node%d",k++);
		sig= pushArgument(tm, sig, newVariable(tm, GDKstrdup(buf), TYPE_int));
	}
	/* input arguments */
	for( j =lsig->retc; j<lsig->argc; j++){
		int a= getArg(lsig,j);
		sig = pushArgument(tm, sig, cloneVariable(tm,leg,a));
	}

	/* initialize the return variables */
	r= newAssignment(tm);
	getArg(r,0)= getArg(sig,0);
	pushNil(tm,r,getArgType(tm,sig,0));
	for ( j=1;j < lsig->retc; j++){
		r= newAssignment(tm);
		getArg(r,0)= getArg(lsig,j);
		pushNil(tm,r,getArgType(tm,lsig,j));
	}

	if ( tarantulaLocal == 0){
		q= newFcnCall(tm,languageRef,dataflowRef);
		q->barrier= BARRIERsymbol;
		x = getArg(q,0);
		setVarType(tm,x,TYPE_int);
	}

	snprintf(fcn,BUFSIZ,"rmt_%s_%d", getFunctionId(getInstrPtr(mb,0)), getArg(old[pc],0));
	r= newInstruction(tm,ASSIGNsymbol);
	setModuleId(r,matRef);
	setFunctionId(r,packRef);
	for( l=k=0; l<legs; l++, k=(k+1)%nodes){
		p = newStmt(tm,tarantulaRef,GDKstrdup(fcn));
		p = pushArgument(tm,p, getArg(sig, k + sig->retc));
		snprintf(buf,BUFSIZ,"%s_%d_%d",getFunctionId(getInstrPtr(mb,0)), getArg(old[pc],0), l);
		p = pushStr(tm, p, buf);
		setVarType(tm,getArg(p,0), getArgType(mb,old[pc],k+old[pc]->retc));
		setVarUDFtype(tm,getArg(p,0));
		/* add the arguments from the query template */
		for( j =sig->retc+nodes; j<sig->argc; j++)
			p = pushArgument(tm, p, getArg(sig,j));
		r= pushArgument(tm,r, getArg(p,0));
	}

	k =getArg(r,0)= getArg(sig,0);
	pushInstruction(tm,r);

	if ( tarantulaLocal == 0){
		q= newAssignment(tm);
		q->barrier = EXITsymbol;
		getArg(q,0)= x;
	}

	r= newInstruction(tm,ASSIGNsymbol);
	r->barrier = RETURNsymbol;
	getArg(r,0)= getArg(sig,0);
	/* r = pushArgument(tm,r,k);*/
	pushInstruction(tm,r);

	pushEndInstruction(tm);
	clrDeclarations(tm);
	chkProgram(cntxt->nspace,tm);
	OPTDEBUGtarantula
		printFunction(cntxt->fdout, tm, 0, LIST_MAL_STMT | LIST_MAPI);

}
@-
The tarantula is only permitted for read only queries.
The first blocking mat.pack determines the scope of the tarantula optimizer.
@c
static int
TAReligible(MalBlkPtr mb){
	int i, target = -1;
	InstrPtr p;

	/* if ( varGetProp(mb, getArg(getInstrPtr(mb,0),0), PropertyIndex("autoCommit")) != NULL )
		return -1; */
	for (i = 1; i < mb->stop; i++){
		p = getInstrPtr(mb,i);
		
		if( getModuleId(p)== sqlRef ){
			if (getFunctionId(p)== appendRef || getFunctionId(p)== deleteRef )
				return -1;
			if ( strcmp(getFunctionId(p),"getVariable")==0 )
				return -1;
			if (strcmp(getFunctionId(p),"setVariable")==0 )
				return -1;
		}
		if (p->token == ENDsymbol)
			target= i;
	}
	return target;
}
@-
The core of the optimizer. It will repeatedly optimize the program given until all
blocking operations have been handled.
@c
static int
OPTtarantulaImplementation(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	InstrPtr q, p, sig, *old;
	int last=0, i, j, k, limit, actions=0;
	int tn=0;
	MalBlkPtr *leg;
	char fcn[BUFSIZ];
	Lifespan span;
	int *map;

	if( cntxt == 0){
		/* confuscate, delay for later activation */
		TARinitcode(cntxt, mb);
		TARexitcode( mb,0,0);
	}
	if ( ( last = TAReligible(mb)) < 0 )
		return 0;
    mal_set_lock(mal_contextLock,"tarantula.register");
    if ( TARnrpeers == 0 )
        TARdiscover(cntxt);
    mal_unset_lock(mal_contextLock,"tarantula.register");
@-
Test the use of the variables and show them.
Debugging code
{
	int *alias= (int*) GDKzalloc(mb->vtop * sizeof(int));
	old = mb->stmt;
	for (i = 1; i < mb->stop; i++){
		p = old[i];
		for( j = p->retc; j< p->argc; j++)
			alias[getArg(p,j)]++;
	}
	for(i=0;i<mb->vtop;i++)
	if ( alias[i]>1)
		mnstr_printf(cntxt->fdout,"%s %d\n",getVarName(mb,i),alias[i]);
	GDKfree(alias);
}
@-
All tarantula leg code is collected in a separate module
to ease future distribution and scheduling.
The optimizer works by looking only to the mat.pack statement.

It recursively calls the optimizer used to create multiple versions, which,
when scheduled correctly, would not lead to duplicate work.
@c
	(void) fixModule(cntxt->nspace,tarantulaRef);

	leg= (MalBlkPtr *) GDKmalloc(sizeof(MalBlkPtr) * mb->stop);
	if ( leg == NULL)
		return 0;

	limit = mb->stop;
	old = mb->stmt;

	if ( newMalBlkStmt(mb, mb->ssize) < 0){
		GDKfree(leg);
		return 0;
	}
	pushInstruction(mb, old[0]);

	span = newLifespan(mb);
	map= (int*) GDKzalloc(mb->vtop * sizeof(int));
	for ( i = 0; i < mb->vtop; i++)
		map[i] = i;

	sig= old[0];
	for (i = 1; i < limit; i++) {
		p = old[i];
		if ( p == pci){
			freeInstruction(pci);
			old[i]= 0;
			continue;
		}
		if( getModuleId(p)== matRef && getFunctionId(p)== packRef) {
			for (tn =0, j = p->retc; j < p->argc; j++) {
				leg[tn] = TARmakeleg(cntxt, mb, old, i, j,span,map);
				if ( leg[tn] == 0)
					goto wrapup;
				tn++;
			}
			TARmakeRegistration(cntxt,mb,old,i,TARnrpeers);
			TARmakeBidding(cntxt,mb,old,i,TARnrpeers);
			TARmakeExecution(cntxt,mb,old,i,leg[0]);
			TARmakeRun(cntxt,mb,old,i,TARnrpeers,tn,leg[0]);

			/* update masterplan */
			snprintf(fcn,BUFSIZ,"reg_%s_%d", getFunctionId(getInstrPtr(mb,0)), getArg(old[i],0));
			p= newStmt(mb, tarantulaRef, putName(fcn,strlen(fcn)));
			setVarType(mb, getArg(p,0), TYPE_int);

			snprintf(fcn,BUFSIZ,"bid_%s_%d", getFunctionId(getInstrPtr(mb,0)), getArg(old[i],0));
			q = newInstruction(mb,ASSIGNsymbol);
			setModuleId(q,tarantulaRef);
			setFunctionId(q, putName(fcn,strlen(fcn)));
			for( k=0; k<TARnrpeers; k++)
				q= pushReturn(mb, q, newTmpVariable(mb,TYPE_int));
			q = pushArgument(mb,q,getArg(p,0));
			pushInstruction(mb,q);

			snprintf(fcn,BUFSIZ,"exe_%s_%d", getFunctionId(getInstrPtr(mb,0)), getArg(old[i],0));
			p = newStmt(mb,tarantulaRef, putName(fcn,strlen(fcn)));
			for( k=0; k<TARnrpeers; k++)
				p= pushArgument(mb, p, getArg(q, k++));
			for ( k= sig->retc; k< sig->argc; k++)
				p= pushArgument(mb, p, getArg(sig, k));
			
			getArg(p,0) = getArg(old[i],0);
			actions++;
			for (j = last + 1; j < limit; j++)
				for (k = 0; k < tn; k++)
					if (old[j] && old[j]->token != REMsymbol)
						q =newStmt(leg[k], getModuleId(old[j]), getFunctionId(old[j]));
			OPTDEBUGtarantula for (k = 0; k < tn; k++)
				printFunction(cntxt->fdout, leg[k], 0, LIST_MAL_STMT | LIST_MAPI);
			continue;
		} 
		wrapup:
		for ( j=0; j< p->argc; j++)
			getArg(p,j)= map[getArg(p,j)];
		pushInstruction(mb,p);
		if (p->token == ENDsymbol){
			last= i;
			break;
		}
	}
	
@-
Keep the remaining optimizers in the main program.
The leg code should be optimized by the remaining optimizers too.
@c
	for (j = last + 1; j < limit; j++)
		if (old[j])
			pushInstruction(mb, old[j]);

	GDKfree(old);
	GDKfree(leg);
	GDKfree(map);
	(void) stk;
	return actions;
}
@include optimizerWrapper.mx
@c
#include "opt_statistics.h"
@:wrapOptimizer(tarantula,OPT_CHECK_ALL)@
@}
