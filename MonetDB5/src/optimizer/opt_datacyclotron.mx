@/
The contents of this file are subject to the MonetDB Public License
Version 1.1 (the "License"); you may not use this file except in
compliance with the License. You may obtain a copy of the License at
http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html

Software distributed under the License is distributed on an "AS IS"
basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations
under the License.

The Original Code is the MonetDB Database System.

The Initial Developer of the Original Code is CWI.
Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
Copyright August 2008-2010 MonetDB B.V.
All Rights Reserved.
@

@f opt_datacyclotron
@- The data cyclotron 

@mal
module datacyclotron;

pattern optimizer.datacyclotron():str
address OPTdatacyclotron;
pattern optimizer.datacyclotron(mod:str, fcn:str):str
address OPTdatacyclotron
comment "Datacyclotron code injection";


pattern addReg(sch:str, tab:str, col:str, acc:int, f_bun:int, l_bun:int):int
address addRegWrap
comment "Add a regist for partition";

pattern bind(schema:str, table:str, column:str, access:int, partition:int, fbun:int, lbun:int):int
address DCYbindWrap
comment "Request a bat";

pattern pin(req_id:int):bat[:any_1,:any_3]
address DCYpinWrap
comment "Pin a request for a query";

pattern unpin(req_id:int):void
address DCYunpinWrap
comment "UnPin a request for a query";


@-

The number of overloaded instructions is kept to a minimum.
@h
#ifndef _OPT_DATACYCLOTRON_
#define _OPT_DATACYCLOTRON_

#include "opt_prelude.h"
#include "opt_support.h"
#include "mal_interpreter.h"

/*#define DEBUG_DATACYCLOTRON_OPT*/
#define BIND_DATACYCLOTRON_OPT

#define SCHEMA_LENG     32 
#define TABLE_LENG      32 
#define COLUMN_LENG     32 
#define DCYPARTITIONS	200

typedef struct DCYCATALOG {
	char    schema[SCHEMA_LENG],
                table[TABLE_LENG],
                column[COLUMN_LENG];
	int 	access;
	int 	partitions;
	int 	*f_bun;
	int 	*l_bun;
	
	struct DCYCATALOG *next;
}DCYcatalog;

DCYcatalog *catalog;

opt_export DCYcatalog* addRegist( str sch, str tab, str col, int acc, int f_bun, int l_bun );
opt_export DCYcatalog* findRegist( str sch, str tab, str col, int acc);
opt_export DCYcatalog* removePartRegist( str sch, str tab, str col, int acc, int part);
opt_export int dropRegist( str sch, str tab, str col, int acc );
opt_export str printRegists(void);

@-
@c
#include "mal_config.h"
#include "opt_datacyclotron.h"
#include "mal_instruction.h"

str
addRegWrap (Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pc) {
	int *res = (int*) getArgReference(stk,pc,0);
	str *sch = (str*) getArgReference(stk,pc,1);
	str *tab = (str*) getArgReference(stk,pc,2);
	str *col = (str*) getArgReference(stk,pc,3);
	int acc = *(int*) getArgReference(stk,pc,4);
	int f_b = *(int*) getArgReference(stk,pc,5);
	int l_b = *(int*) getArgReference(stk,pc,6);

	(void) res;
	(void) cntxt;
	(void) mb;

	addRegist(*sch, *tab, *col, acc, f_b, l_b);

	return MAL_SUCCEED;
}

str
printRegists(void) {
	DCYcatalog *reg = NULL;
	int chunks = 0, parts = 0;
	char *res = NULL;

	reg = catalog;
	
	while(reg) {
		chunks++;
		parts += reg->partitions;
                reg = reg->next;
        }

	sprintf(res, "The catalog for the datacyclotron optimizer contains %d chunks and %d partitions.\n", chunks, parts);	

#ifdef DEBUG_DATACYCLOTRON_OPT
	printf("%s\n", res);
#endif

	return res;		
}

DCYcatalog*
addRegist( str sch, str tab, str col, int acc, int f_bun, int l_bun ) {
	DCYcatalog *reg = NULL;

	if (!(reg = findRegist(sch, tab, col, acc))) {
		reg = GDKmalloc(sizeof(DCYcatalog));
		strcpy(reg->schema, sch);
		strcpy(reg->table, tab);
		strcpy(reg->column, col);
		reg->access = acc;
		reg->partitions = 0;
		reg->next = catalog;
		catalog = reg;

		reg->f_bun = GDKmalloc(DCYPARTITIONS*sizeof(int));
		reg->l_bun = GDKmalloc(DCYPARTITIONS*sizeof(int));
	}

	if ( reg->partitions && !(reg->partitions%DCYPARTITIONS) ) {
		reg->f_bun = GDKrealloc(reg->f_bun, (reg->partitions + DCYPARTITIONS) *sizeof(int));
		reg->l_bun = GDKrealloc(reg->l_bun, (reg->partitions + DCYPARTITIONS) *sizeof(int));
	}

	reg->f_bun[reg->partitions] = f_bun;
	reg->l_bun[reg->partitions] = l_bun;
	reg->partitions++;

	return reg;		
}

DCYcatalog*
removePartRegist( str sch, str tab, str col, int acc, int part) {
	int i = 0;
	DCYcatalog *reg = NULL;

	if (!(reg = findRegist(sch, tab, col, acc))) 
		return NULL;

	for (i = part; i < (reg->partitions-1); i++) {
		reg->f_bun[i] = reg->f_bun[i+1];
		reg->l_bun[i] = reg->l_bun[i+1];
	}

	reg->partitions--;

	return reg;		
}

int
dropRegist( str sch, str tab, str col, int acc ) {
	DCYcatalog *reg = NULL, *prev_reg = NULL;

	reg = catalog;
	
	while(reg && !(
                (strcmp(reg->schema, sch) == 0) &&
                (strcmp(reg->table, tab) == 0) &&
                (strcmp(reg->column, col) == 0) &&
                reg->access == acc
        )) {
		prev_reg = reg;
                reg = reg->next;
        }

	if (prev_reg)
		prev_reg->next = reg->next;
	else
		catalog = reg->next;
	if (reg->f_bun)
		GDKfree(reg->f_bun);
	if (reg->l_bun)
		GDKfree(reg->l_bun);
	GDKfree(reg);

	return 1;		
}

DCYcatalog*
findRegist( str sch, str tab, str col, int acc) {
	DCYcatalog *reg = NULL;

	reg = catalog;
	
	while(reg && !(
                (strcmp(reg->schema, sch) == 0) &&
                (strcmp(reg->table, tab) == 0) &&
                (strcmp(reg->column, col) == 0) &&
                reg->access == acc
        )) {
                reg = reg->next;
        }

	return reg;		
}

static int
OPTdatacyclotronImplementation(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	int i, actions=0, k = 0, z= 0, j = 0;
	DCYcatalog **regs, *reg = NULL;
	VarRecord low,hgh;
	InstrPtr *old, new, matq;
	int limit;
	int (*newArg)[1000];
	char *used= (char*) GDKzalloc((mb->vtop+1000) *sizeof(char));

#ifdef BIND_DATACYCLOTRON_OPT
	int *tpes= (int*) GDKmalloc((mb->vtop+1000) *sizeof(int));
#endif

#ifdef DEBUG_DATACYCLOTRON_OPT
	stream_printf(cntxt->fdout,"ENTERING DATA CYCLOTRON \n");
    printFunction(cntxt->fdout,mb,0,LIST_MAL_ALL);
#endif

	newArg = GDKmalloc(sizeof(*newArg) * (mb->vtop+1000));

	if ( (used == NULL) && (newArg == NULL))
		return 0;
	(void) stk;
	(void) cntxt;

	regs = (DCYcatalog **) GDKmalloc(sizeof(*regs) * (mb->vtop+1000));
	limit= mb->stop;
	old = mb->stmt;
	newMalBlkStmt(mb, mb->ssize);
	pushInstruction(mb,old[0]);

	for (i = 1; i<limit; i++) {
		p = old[i];
		if (getModuleId(p)== sqlRef && (getFunctionId(p) == bindRef) ) {

			/*Check if the BAT is a datacyclotron BAT*/
			str sch      = getVarConstant(mb, getArg(p,2)).val.sval;
			str tab      = getVarConstant(mb, getArg(p,3)).val.sval;
			str col      = getVarConstant(mb, getArg(p,4)).val.sval;
			int acc      = getVarConstant(mb, getArg(p,5)).val.ival;

			regs[getArg(p,0)] = findRegist(sch, tab, col, acc);

			if (regs[getArg(p,0)]) {
				int tpe = TYPE_int;
				reg = regs[getArg(p,0)];
#ifndef BIND_DATACYCLOTRON_OPT
				tpe = getArgType(mb,p,0);
				matq= newInstruction(NULL,ASSIGNsymbol);
				setModuleId(matq,matRef);
				setFunctionId(matq,newRef);
				clrFunction(matq);
				getArg(matq,0)= getArg(p,0);
				hgh.value.vtype= low.value.vtype= TYPE_oid;
#else
				tpes[getArg(p,0)] = getArgType(mb,p,0);
#endif

				for (k = 0; k < reg->partitions; k++ ) {
					new = newInstruction(NULL,ASSIGNsymbol);
					setModuleId(new,datacyclotronRef);
#ifdef BIND_DATACYCLOTRON_OPT
					setFunctionId(new,bindRef);
					getArg(new,0) = newTmpVariable(mb, tpe);
#else
					setFunctionId(new,copyRef);
					new = pushArgument(mb, new, newTmpVariable(mb,TYPE_int));
					new->retc++;
					getArg(new,0) = newTmpVariable(mb, tpe);
					getArg(new,1) = newTmpVariable(mb, TYPE_int);
#endif

					new = pushStr(mb,new,reg->schema);
					new = pushStr(mb,new,reg->table);
					new = pushStr(mb,new,reg->column);
					new = pushInt(mb,new,reg->access);
					new = pushInt(mb,new,k);
					new = pushInt(mb,new,reg->f_bun[k]);
					new = pushInt(mb,new,reg->l_bun[k]);
					pushInstruction(mb,new);
					used[getArg(p,0)] = 1;
#ifdef BIND_DATACYCLOTRON_OPT
					newArg[getArg(p,0)][k] = getArg(new,0);
				}
#else
					newArg[getArg(p,0)][k] = getArg(new,1);

					low.value.val.oval= reg->f_bun[k];
					hgh.value.val.oval= reg->l_bun[k];
					z = getArg(new, 0);

					varSetProp(mb, z, PropertyIndex("hlb"), op_gte, (ptr) &low.value);
					varSetProp(mb, z, PropertyIndex("hub"), op_lt, (ptr) &hgh.value);
					matq= pushArgument(mb,matq,z);
				}
				pushInstruction(mb,matq);
#endif
			} else 
					pushInstruction(mb,p);
				
			actions++;
		} else { 
#ifdef BIND_DATACYCLOTRON_OPT
			for (j = p->retc; j<p->argc; j++) 
				if ( used[getArg(p,j)] == 1 ) {
					used[getArg(p,j)] = 2;
					reg = regs[getArg(p,j)];
					matq= newInstruction(NULL,ASSIGNsymbol);
					setModuleId(matq,matRef);
					setFunctionId(matq,newRef);
					clrFunction(matq);
					getArg(matq,0)= getArg(p,j);
					hgh.value.vtype= low.value.vtype= TYPE_oid;

					for (k = 0; k < reg->partitions; k++ ) {
						new = newInstruction(NULL,ASSIGNsymbol);
						setModuleId(new,datacyclotronRef);
						setFunctionId(new,pinRef);

						getArg(new,0) = newTmpVariable(mb, tpes[getArg(p,j)]);
						setVarUDFtype(mb,getArg(new,0));

						pushArgument(mb,new,newArg[getArg(p,j)][k]);
						pushInstruction(mb,new);
						low.value.val.oval= reg->f_bun[k];
						hgh.value.val.oval= reg->l_bun[k];
						z = getArg(new, 0);

						varSetProp(mb, z, PropertyIndex("hlb"), op_gte, (ptr) &low.value);
						varSetProp(mb, z, PropertyIndex("hub"), op_lt, (ptr) &hgh.value);
						matq= pushArgument(mb,matq,z);
					}
					pushInstruction(mb,matq);
				}
#endif
			if (functionExit(p))
				for (j = 0; j< mb->vtop; j++) 
#ifdef BIND_DATACYCLOTRON_OPT
					if ( used[j] == 2) {
#else
					if ( used[j] == 1) {
#endif
						reg = regs[j];
						for (k = 0; k < reg->partitions; k++ ) {
							new= newStmt(mb,"datacyclotron","unpin");
							pushArgument(mb,new,newArg[j][k]);

						}
					}
			pushInstruction(mb,p);
		}
		
	}

#ifdef DEBUG_DATACYCLOTRON_OPT
	stream_printf(cntxt->fdout,"LEAVING DATA CYCLOTRON \n");
	chkProgram(cntxt->nspace,mb);
    printFunction(cntxt->fdout,mb,0,LIST_MAL_ALL);
#endif
#ifdef BIND_DATACYCLOTRON_OPT
	GDKfree(tpes);
#endif
	GDKfree(used);
	GDKfree(newArg);
	GDKfree(regs);
	GDKfree(old);

#ifdef DEBUG_DATACYCLOTRON_OPT
	clrDeclarations(mb);
	chkTypes(cntxt->nspace,mb,TRUE);
	printFunction(cntxt->fdout,mb, 0,LIST_MAL_ALL);
#endif
	return actions;
}
@include optimizerWrapper.mx
@h
@:exportOptimizer(datacyclotron)@
@c
#include "opt_statistics.h"
@:wrapOptimizer(datacyclotron,OPT_CHECK_ALL)@
@- The DataCyclotron Wrapper
@h
opt_export str DCbind(int *ret, str *sch, str *tab, str *col, int *kind, int *part, int *fbun, int *lbun);
@c
str
DCYbindWrap(int *ret, str *sch, str *tab, str *col, int *kind, int *part, int *fbun, int *lbun){
	(void) ret;
	(void) sch;
	(void) tab;
	(void) col;
	(void) kind;
	(void) part;
	(void) fbun;
	(void) lbun;
	throw(MAL,"datacyclotron.bind",PROGRAM_NYI);
}

@h
opt_export str DCpin(int *ret, int *bid);
@c
str
DCYpinWrap(int *ret, int *bid){
	(void) ret;
	(void) bid;
	throw(MAL,"datacyclotron.pin",PROGRAM_NYI);
}

@h
opt_export str DCunpin(int *ret, int *bid);
@c
str
DCYunpinWrap(int *ret, int *bid){
	(void) ret;
	(void) bid;
	throw(MAL,"datacyclotron.unpin",PROGRAM_NYI);
}

@h
opt_export str DCcopy(int *ret_bat, int *ret_id, str *sch, str *tab, str *col, int *kind, int *part, int *fbun, int *lbun);
@c
str
DCYcopyWrap(int *ret_bat, int *ret_id, str *sch, str *tab, str *col, int *kind, int *part, int *fbun, int *lbun){
	(void) ret_id;
	(void) ret_bat;
	(void) sch;
	(void) tab;
	(void) col;
	(void) kind;
	(void) part;
	(void) fbun;
	(void) lbun;
	throw(MAL,"datacyclotron.copy",PROGRAM_NYI);
}

@h
#endif
