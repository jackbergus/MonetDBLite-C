@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
@' Copyright August 2008-2009 MonetDB B.V.
@' All Rights Reserved.

@f opt_datacyclotron
@- The data cyclotron 

@mal
module datacyclotron;

pattern optimizer.datacyclotron():str
address OPTdatacyclotron;
pattern optimizer.datacyclotron(mod:str, fcn:str):str
address OPTdatacyclotron
comment "Datacyclotron code injection";

command copy(schema:str, tab:str, col:str, kind:int, part:int, fbun:int, lbun:int):bat[:any_1,:any_2]
address DCcopy
comment "Inform the DataCyclotron about the intended access";

command bind(schema:str, tab:str, col:str, kind:int):bat[:any_1,:any_2]
address DCbind
comment "Inform the DataCyclotron about the intended access";

command pin(b:bat[:any_1,:any_2]):bat[:any_1,:any_2]
address DCpin
comment "Inform the DataCyclotron about a pin request";

command unpin(b:bat[:any_1,:any_2])
address DCunpin
comment "Inform the DataCyclotron about a pin request";
@-
The number of overloaded instructions is kept to a minimum.
@h
#ifndef _OPT_DATACYCLOTRON_
#define _OPT_DATACYCLOTRON_

#include "opt_prelude.h"
#include "opt_support.h"
#include "mal_interpreter.h"

/* #define DEBUG_DATACYCLOTRON_OPT */
/* #define BIND_DATACYCLOTRON_OPT */

#define SCHEMA_LENG     32 
#define TABLE_LENG      32 
#define COLUMN_LENG     32 

typedef struct DCYCATALOG {
	char    schema[SCHEMA_LENG],
                table[TABLE_LENG],
                column[COLUMN_LENG];
	int 	access;
	int 	partitions;
	int 	f_bun[200];
	int 	l_bun[200];
	
	struct DCYCATALOG *next;
}DCYcatalog;

DCYcatalog *catalog;

opt_export DCYcatalog* addRegist( str sch, str tab, str col, int acc, int f_bun, int l_bun );
opt_export DCYcatalog* findRegist( str sch, str tab, str col, int acc);
opt_export DCYcatalog* removePartRegist( str sch, str tab, str col, int acc, int part);
opt_export int dropRegist( str sch, str tab, str col, int acc );
opt_export str printRegists(void);

@-
@c
#include "mal_config.h"
#include "opt_datacyclotron.h"
#include "mal_instruction.h"

str
printRegists(void) {
	DCYcatalog *reg = NULL;
	int chunks = 0, parts = 0;
	char *res = NULL;

	reg = catalog;
	
	while(reg) {
		chunks++;
		parts += reg->partitions;
                reg = reg->next;
        }

	sprintf(res, "The catalog for the datacyclotron optimizer contains %d chunks and %d partitions.\n", chunks, parts);	

#ifdef DEBUG_DATACYCLOTRON_OPT
	printf("%s\n", res);
#endif

	return res;		
}

DCYcatalog*
addRegist( str sch, str tab, str col, int acc, int f_bun, int l_bun ) {
	DCYcatalog *reg = NULL;

	if (!(reg = findRegist(sch, tab, col, acc))) {
		reg = GDKmalloc(sizeof(DCYcatalog));
		strcpy(reg->schema, sch);
		strcpy(reg->table, tab);
		strcpy(reg->column, col);
		reg->access = acc;
		reg->partitions = 0;
		reg->next = catalog;
		catalog = reg;
	}

	reg->f_bun[reg->partitions] = f_bun;
	reg->l_bun[reg->partitions] = l_bun;
	reg->partitions++;

	return reg;		
}

DCYcatalog*
removePartRegist( str sch, str tab, str col, int acc, int part) {
	int i = 0;
	DCYcatalog *reg = NULL;

	if (!(reg = findRegist(sch, tab, col, acc))) 
		return NULL;

	for (i = part; i < (reg->partitions-1); i++) {
		reg->f_bun[i] = reg->f_bun[i+1];
		reg->l_bun[i] = reg->l_bun[i+1];
	}

	reg->partitions--;

	return reg;		
}

int
dropRegist( str sch, str tab, str col, int acc ) {
	DCYcatalog *reg = NULL, *prev_reg = NULL;

	reg = catalog;
	
	while(reg && !(
                (strcmp(reg->schema, sch) == 0) &&
                (strcmp(reg->table, tab) == 0) &&
                (strcmp(reg->column, col) == 0) &&
                reg->access == acc
        )) {
		prev_reg = reg;
                reg = reg->next;
        }

	if (prev_reg)
		prev_reg->next = reg->next;
	else
		catalog = reg->next;

	GDKfree(reg);

	return 1;		
}

DCYcatalog*
findRegist( str sch, str tab, str col, int acc) {
	DCYcatalog *reg = NULL;

	reg = catalog;
	
	while(reg && !(
                (strcmp(reg->schema, sch) == 0) &&
                (strcmp(reg->table, tab) == 0) &&
                (strcmp(reg->column, col) == 0) &&
                reg->access == acc
        )) {
                reg = reg->next;
        }

	return reg;		
}

static int
OPTdatacyclotronImplementation(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	int i, actions=0, k = 0;
	DCYcatalog *reg;
	InstrPtr *old;
	char *used= (char*) GDKzalloc(mb->vtop *sizeof(char));
	int limit;
#ifdef BIND_DATAFLOW_OPT
	InstrPtr q;
	int j;
#endif

	(void) cntxt;
	if ( used == NULL)
		return 0;
	limit= mb->stop;
	old = mb->stmt;
	newMalBlkStmt(mb, mb->ssize);
	pushInstruction(mb,old[0]);

	for (i = 1; i<limit; i++) {
		p = old[i];
		if (getModuleId(p)== sqlRef && 
				(getFunctionId(p) == bindRef || 
				 getFunctionId(p) == putName("bind_idxbat",11) ||
				 getFunctionId(p) == binddbatRef) ) {

			/*Check if the BAT is a datacyclotron BAT*/
			str *sch      = (str*) getArgReference(stk,p,1);
		        str *tab      = (str*) getArgReference(stk,p,2);
		        str *col      = (str*) getArgReference(stk,p,3);
		        int *acc      = (int*) getArgReference(stk,p,4);

			reg = findRegist(*sch, *tab, *col, *acc);

			setModuleId(p,putName("datacyclotron",13));
			for (k = 0; k < reg->partitions; k++ ) {
#ifdef BIND_DATAFLOW_OPT
			setFunctionId(p, putName("bind",4));
#else
			setFunctionId(p, putName("copy",4));
#endif
			p = pushInt(mb,p,reg->partitions);
			p = pushInt(mb,p,reg->f_bun[k]);
			p = pushInt(mb,p,reg->l_bun[k]);

			}
			used[getArg(p,0)] = 1;
			actions++;
		}
#ifdef BIND_DATAFLOW_OPT
		for (j = p->retc; j<p->argc; j++)
			if ( used[getArg(p,j)] == 1 ){
				used[getArg(p,j)] = 2;
				q= newStmt(mb,"datacyclotron","pin");
				pushArgument(mb,q,getArg(p,j));
				getArg(p,j)= getArg(q,0);
			}

		if (functionExit(p))
			for (j = 0; j< mb->vtop; j++)
				if ( used[j] == 2){
					q= newStmt(mb,"datacyclotron","unpin");
					pushArgument(mb,q,j);
				}
#endif
		pushInstruction(mb,p);
	}
	GDKfree(old);
	return actions;
}

@include optimizerWrapper.mx
@h
@:exportOptimizer(datacyclotron)@
@c
#include "opt_statistics.h"
@:wrapOptimizer(datacyclotron,OPT_CHECK_ALL)@
@- The DataCyclotron Wrapper
@h
opt_export str DCrequest(int *ret, str *sch, str *tab, str *col, int *kind);
@c
str
DCbind(int *ret, str *sch, str *tab, str *col, int *kind){
	(void) ret;
	(void) sch;
	(void) tab;
	(void) col;
	(void) kind;
	throw(MAL,"datacyclotron.bind",PROGRAM_NYI);
}

@h
opt_export str DCpin(int *ret, int *bid);
@c
str
DCpin(int *ret, int *bid){
	(void) ret;
	(void) bid;
	throw(MAL,"datacyclotron.pin",PROGRAM_NYI);
}

@h
opt_export str DCunpin(int *ret, int *bid);
@c
str
DCunpin(int *ret, int *bid){
	(void) ret;
	(void) bid;
	throw(MAL,"datacyclotron.unpin",PROGRAM_NYI);
}

@h
opt_export str DCcopy(int *ret, str *sch, str *tab, str *col, int *kind, int *part, int *fbun, int *lbun);
@c
str
DCcopy(int *ret, str *sch, str *tab, str *col, int *kind, int *part, int *fbun, int *lbun){
	(void) ret;
	(void) sch;
	(void) tab;
	(void) col;
	(void) kind;
	(void) part;
	(void) fbun;
	(void) lbun;
	throw(MAL,"datacyclotron.copy",PROGRAM_NYI);
}

@h
#endif
