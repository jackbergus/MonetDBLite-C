@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
@' Copyright August 2008-2009 MonetDB B.V.
@' All Rights Reserved.

@f opt_datacyclotron
@- The data cyclotron 

@mal
module datacyclotron;

pattern optimizer.datacyclotron():str
address OPTdatacyclotron;
pattern optimizer.datacyclotron(mod:str, fcn:str):str
address OPTdatacyclotron
comment "Datacyclotron code injection";

@-
The number of overloaded instructions is kept to a minimum.
@h
#ifndef _OPT_DATACYCLOTRON_
#define _OPT_DATACYCLOTRON_

#include "opt_prelude.h"
#include "opt_support.h"
#include "mal_interpreter.h"

/* #define DEBUG_DATACYCLOTRON_OPT */
/* #define BIND_DATACYCLOTRON_OPT */

#define SCHEMA_LENG     32 
#define TABLE_LENG      32 
#define COLUMN_LENG     32 

typedef struct DCYCATALOG {
	char    schema[SCHEMA_LENG],
                table[TABLE_LENG],
                column[COLUMN_LENG];
	int 	access;
	int 	partitions;
	int 	f_bun[200];
	int 	l_bun[200];
	
	struct DCYCATALOG *next;
}DCYcatalog;

DCYcatalog *catalog;

opt_export DCYcatalog* addRegist( str sch, str tab, str col, int acc, int f_bun, int l_bun );
opt_export DCYcatalog* findRegist( str sch, str tab, str col, int acc);
opt_export DCYcatalog* removePartRegist( str sch, str tab, str col, int acc, int part);
opt_export int dropRegist( str sch, str tab, str col, int acc );
opt_export str printRegists(void);

@-
@c
#include "mal_config.h"
#include "opt_datacyclotron.h"
#include "mal_instruction.h"

str
printRegists(void) {
	DCYcatalog *reg = NULL;
	int chunks = 0, parts = 0;
	char *res = NULL;

	reg = catalog;
	
	while(reg) {
		chunks++;
		parts += reg->partitions;
                reg = reg->next;
        }

	sprintf(res, "The catalog for the datacyclotron optimizer contains %d chunks and %d partitions.\n", chunks, parts);	

#ifdef DEBUG_DATACYCLOTRON_OPT
	printf("%s\n", res);
#endif

	return res;		
}

DCYcatalog*
addRegist( str sch, str tab, str col, int acc, int f_bun, int l_bun ) {
	DCYcatalog *reg = NULL;

	if (!(reg = findRegist(sch, tab, col, acc))) {
		reg = GDKmalloc(sizeof(DCYcatalog));
		strcpy(reg->schema, sch);
		strcpy(reg->table, tab);
		strcpy(reg->column, col);
		reg->access = acc;
		reg->partitions = 0;
		reg->next = catalog;
		catalog = reg;
	}

	reg->f_bun[reg->partitions] = f_bun;
	reg->l_bun[reg->partitions] = l_bun;
	reg->partitions++;

	return reg;		
}

DCYcatalog*
removePartRegist( str sch, str tab, str col, int acc, int part) {
	int i = 0;
	DCYcatalog *reg = NULL;

	if (!(reg = findRegist(sch, tab, col, acc))) 
		return NULL;

	for (i = part; i < (reg->partitions-1); i++) {
		reg->f_bun[i] = reg->f_bun[i+1];
		reg->l_bun[i] = reg->l_bun[i+1];
	}

	reg->partitions--;

	return reg;		
}

int
dropRegist( str sch, str tab, str col, int acc ) {
	DCYcatalog *reg = NULL, *prev_reg = NULL;

	reg = catalog;
	
	while(reg && !(
                (strcmp(reg->schema, sch) == 0) &&
                (strcmp(reg->table, tab) == 0) &&
                (strcmp(reg->column, col) == 0) &&
                reg->access == acc
        )) {
		prev_reg = reg;
                reg = reg->next;
        }

	if (prev_reg)
		prev_reg->next = reg->next;
	else
		catalog = reg->next;

	GDKfree(reg);

	return 1;		
}

DCYcatalog*
findRegist( str sch, str tab, str col, int acc) {
	DCYcatalog *reg = NULL;

	reg = catalog;
	
	while(reg && !(
                (strcmp(reg->schema, sch) == 0) &&
                (strcmp(reg->table, tab) == 0) &&
                (strcmp(reg->column, col) == 0) &&
                reg->access == acc
        )) {
                reg = reg->next;
        }

	return reg;		
}

static int
OPTdatacyclotronImplementation(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	int i, actions=0, k = 0, z= 0;
	DCYcatalog *reg;
	VarRecord low,hgh;
	InstrPtr *old, new, matq;
	char *used= (char*) GDKzalloc(mb->vtop *sizeof(char));
	int limit;
#ifdef BIND_DATAFLOW_OPT
	InstrPtr q;
	int j;
#endif
	(void) stk;

	if ( used == NULL)
		return 0;
	(void) cntxt;
	if ( used == NULL)
		return 0;
	limit= mb->stop;
	old = mb->stmt;
	if ( newMalBlkStmt(mb, mb->ssize) < 0){
		GDKfree(used);
		return 0;
	}
	pushInstruction(mb,old[0]);

	for (i = 1; i<limit; i++) {
		p = old[i];
		if (getModuleId(p)== sqlRef && (getFunctionId(p) == bindRef) ) {

			/*Check if the BAT is a datacyclotron BAT*/
			str sch      = getVarConstant(mb, getArg(p,1)).val.sval;
			str tab      = getVarConstant(mb, getArg(p,2)).val.sval;
			str col      = getVarConstant(mb, getArg(p,3)).val.sval;
			int acc      = getVarConstant(mb, getArg(p,4)).val.ival;

			reg = findRegist(sch, tab, col, acc);

			if (reg) {
				int tpe = getArgType(mb,p,0);

				matq= newInstruction(NULL,ASSIGNsymbol);
				setModuleId(matq,matRef);
				setFunctionId(matq,newRef);
				getArg(matq,0)= getArg(p,0);
				hgh.value.vtype= low.value.vtype= TYPE_oid;

				for (k = 0; k < reg->partitions; k++ ) {
					new = newInstruction(NULL,ASSIGNsymbol);
					setModuleId(new,datacyclotronRef);
#ifdef BIND_DATAFLOW_OPT
					setFunctionId(new,bindRef);
#else
					setFunctionId(new,copyRef);
#endif
					getArg(new,0) = newTmpVariable(mb, tpe);

					new = pushStr(mb,new,reg->schema);
					new = pushStr(mb,new,reg->table);
					new = pushStr(mb,new,reg->column);
					new = pushInt(mb,new,reg->access);
					new = pushInt(mb,new,k);
					new = pushInt(mb,new,reg->f_bun[k]);
					new = pushInt(mb,new,reg->l_bun[k]);
					pushInstruction(mb,new);


					low.value.val.oval= reg->f_bun[k];
					hgh.value.val.oval= reg->l_bun[k];
					z = getArg(new, 0);

					varSetProp(mb, z, PropertyIndex("hlb"), op_gte, (ptr) &low.value);
					varSetProp(mb, z, PropertyIndex("hub"), op_lt, (ptr) &hgh.value);
					matq= pushArgument(mb,matq,z);
				}
				pushInstruction(mb,matq);
				used[getArg(p,0)] = 1;
			} else 
					pushInstruction(mb,p);
				
			actions++;
		} else { 
#ifdef BIND_DATAFLOW_OPT
			for (j = p->retc; j<p->argc; j++)
				if ( used[getArg(p,j)] == 1 ){
					used[getArg(p,j)] = 2;
					q= newStmt(mb,"datacyclotron","pin");
					pushArgument(mb,q,getArg(p,j));
					getArg(p,j)= getArg(q,0);
				}

			if (functionExit(p))
				for (j = 0; j< mb->vtop; j++)
					if ( used[j] == 2){
						q= newStmt(mb,"datacyclotron","unpin");
						pushArgument(mb,q,j);
					}
#endif
			pushInstruction(mb,p);
		}
		
	}
	GDKfree(old);
	return actions;
}
@include optimizerWrapper.mx
@h
@:exportOptimizer(datacyclotron)@
#endif
@c
#include "opt_statistics.h"
@:wrapOptimizer(datacyclotron,OPT_CHECK_ALL)@
@}
