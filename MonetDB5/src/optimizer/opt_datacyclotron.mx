@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
@' Copyright August 2008-2009 MonetDB B.V.
@' All Rights Reserved.

@f opt_datacyclotron
@- The data cyclotron 

@mal
module datacyclotron;

pattern optimizer.datacyclotron():str
address OPTdatacyclotron;
pattern optimizer.datacyclotron(mod:str, fcn:str):str
address OPTdatacyclotron
comment "Datacyclotron code injection";

@-

The number of overloaded instructions is kept to a minimum.
@h
#ifndef _OPT_DATACYCLOTRON_
#define _OPT_DATACYCLOTRON_

#include "opt_prelude.h"
#include "opt_support.h"
#include "mal_interpreter.h"

/* #define DEBUG_DATACYCLOTRON_OPT */
/* #define BIND_DATACYCLOTRON_OPT */

#define SCHEMA_LENG     32 
#define TABLE_LENG      32 
#define COLUMN_LENG     32 

typedef struct DCYCATALOG {
	char    schema[SCHEMA_LENG],
                table[TABLE_LENG],
                column[COLUMN_LENG];
	int 	access;
	int 	partitions;
	int 	f_bun[200];
	int 	l_bun[200];
	
	struct DCYCATALOG *next;
}DCYcatalog;

DCYcatalog *catalog;

opt_export DCYcatalog* addRegist( str sch, str tab, str col, int acc, int f_bun, int l_bun );
opt_export DCYcatalog* findRegist( str sch, str tab, str col, int acc);
opt_export DCYcatalog* removePartRegist( str sch, str tab, str col, int acc, int part);
opt_export int dropRegist( str sch, str tab, str col, int acc );
opt_export str printRegists(void);

@-
@c
#include "mal_config.h"
#include "opt_datacyclotron.h"
#include "mal_instruction.h"

str
printRegists(void) {
	DCYcatalog *reg = NULL;
	int chunks = 0, parts = 0;
	char *res = NULL;

	reg = catalog;
	
	while(reg) {
		chunks++;
		parts += reg->partitions;
                reg = reg->next;
        }

	sprintf(res, "The catalog for the datacyclotron optimizer contains %d chunks and %d partitions.\n", chunks, parts);	

#ifdef DEBUG_DATACYCLOTRON_OPT
	printf("%s\n", res);
#endif

	return res;		
}

DCYcatalog*
addRegist( str sch, str tab, str col, int acc, int f_bun, int l_bun ) {
	DCYcatalog *reg = NULL;

	if (!(reg = findRegist(sch, tab, col, acc))) {
		reg = GDKmalloc(sizeof(DCYcatalog));
		strcpy(reg->schema, sch);
		strcpy(reg->table, tab);
		strcpy(reg->column, col);
		reg->access = acc;
		reg->partitions = 0;
		reg->next = catalog;
		catalog = reg;
	}

	reg->f_bun[reg->partitions] = f_bun;
	reg->l_bun[reg->partitions] = l_bun;
	reg->partitions++;

	return reg;		
}

DCYcatalog*
removePartRegist( str sch, str tab, str col, int acc, int part) {
	int i = 0;
	DCYcatalog *reg = NULL;

	if (!(reg = findRegist(sch, tab, col, acc))) 
		return NULL;

	for (i = part; i < (reg->partitions-1); i++) {
		reg->f_bun[i] = reg->f_bun[i+1];
		reg->l_bun[i] = reg->l_bun[i+1];
	}

	reg->partitions--;

	return reg;		
}

int
dropRegist( str sch, str tab, str col, int acc ) {
	DCYcatalog *reg = NULL, *prev_reg = NULL;

	reg = catalog;
	
	while(reg && !(
                (strcmp(reg->schema, sch) == 0) &&
                (strcmp(reg->table, tab) == 0) &&
                (strcmp(reg->column, col) == 0) &&
                reg->access == acc
        )) {
		prev_reg = reg;
                reg = reg->next;
        }

	if (prev_reg)
		prev_reg->next = reg->next;
	else
		catalog = reg->next;

	GDKfree(reg);

	return 1;		
}

DCYcatalog*
findRegist( str sch, str tab, str col, int acc) {
	DCYcatalog *reg = NULL;

	reg = catalog;
	
	while(reg && !(
                (strcmp(reg->schema, sch) == 0) &&
                (strcmp(reg->table, tab) == 0) &&
                (strcmp(reg->column, col) == 0) &&
                reg->access == acc
        )) {
                reg = reg->next;
        }

	return reg;		
}

static int
OPTdatacyclotronImplementation(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	int i, actions=0, k = 0, z= 0;
	DCYcatalog **regs, *reg = NULL;
	VarRecord low,hgh;
	InstrPtr *old, new, matq;
	int limit;
#ifdef BIND_DATACYCLOTRON_OPT
	InstrPtr new_pin, new_unpin;
	int j;
	char *used= (char*) GDKzalloc(mb->vtop *sizeof(char));
	char *newArg = (char*) GDKzalloc(mb->vtop *sizeof(char));
	char *oldArg= (char*) GDKzalloc(mb->vtop *sizeof(char));
	int *tpes= (int*) GDKzalloc(mb->vtop *sizeof(int));

	if ( (used == NULL) && (newArg == NULL))
		return 0;
#endif
	regs = (DCYcatalog**) GDKzalloc(mb->vtop *sizeof(DCYcatalog*));
	(void) stk;
	(void) cntxt;

	limit= mb->stop;
	old = mb->stmt;
	if ( newMalBlkStmt(mb, mb->ssize) < 0){
#ifdef BIND_DATACYCLOTRON_OPT
		GDKfree(used);
		GDKfree(newArg);
		GDKfree(oldArg);
		GDKfree(tpes);
#endif
		GDKfree(regs);
		return 0;
	}
	pushInstruction(mb,old[0]);

	for (i = 1; i<limit; i++) {
		p = old[i];
		if (getModuleId(p)== sqlRef && (getFunctionId(p) == bindRef) ) {

			/*Check if the BAT is a datacyclotron BAT*/
			str sch      = getVarConstant(mb, getArg(p,1)).val.sval;
			str tab      = getVarConstant(mb, getArg(p,2)).val.sval;
			str col      = getVarConstant(mb, getArg(p,3)).val.sval;
			int acc      = getVarConstant(mb, getArg(p,4)).val.ival;

			regs[getArg(p,0)] = findRegist(sch, tab, col, acc);

			if (regs[getArg(p,0)]) {
				int tpe = TYPE_int;
				reg = regs[getArg(p,0)];
#ifdef BIND_DATACYCLOTRON_OPT
				tpes[getArg(p,0)] = getArgType(mb,p,0);

#else
				tpe = getArgType(mb,p,0);

				matq= newInstruction(NULL,ASSIGNsymbol);
				setModuleId(matq,matRef);
				setFunctionId(matq,newRef);
				getArg(matq,0)= getArg(p,0);
				hgh.value.vtype= low.value.vtype= TYPE_oid;
#endif

				for (k = 0; k < reg->partitions; k++ ) {
					new = newInstruction(NULL,ASSIGNsymbol);
					setModuleId(new,datacyclotronRef);
#ifdef BIND_DATACYCLOTRON_OPT
					setFunctionId(new,bindRef);
#else
					setFunctionId(new,copyRef);
#endif
					getArg(new,0) = newTmpVariable(mb, tpe);

					new = pushStr(mb,new,reg->schema);
					new = pushStr(mb,new,reg->table);
					new = pushStr(mb,new,reg->column);
					new = pushInt(mb,new,reg->access);
					new = pushInt(mb,new,k);
					new = pushInt(mb,new,reg->f_bun[k]);
					new = pushInt(mb,new,reg->l_bun[k]);
					pushInstruction(mb,new);
#ifdef BIND_DATACYCLOTRON_OPT
					used[getArg(p,0)] = 1;
					if (!k)
						newArg[getArg(p,0)] = getArg(new,0);
					oldArg[getArg(p,0)] = getArg(p,0);

				}
#else

					low.value.val.oval= reg->f_bun[k];
					hgh.value.val.oval= reg->l_bun[k];
					z = getArg(new, 0);

					varSetProp(mb, z, PropertyIndex("hlb"), op_gte, (ptr) &low.value);
					varSetProp(mb, z, PropertyIndex("hub"), op_lt, (ptr) &hgh.value);
					matq= pushArgument(mb,matq,z);
				}
				pushInstruction(mb,matq);
#endif
			} else 
				pushInstruction(mb,p);
				
			actions++;
		} else { 
#ifdef BIND_DATACYCLOTRON_OPT
			for (j = p->retc; j<p->argc; j++) 
				if ( used[j] == 1 ) {
					used[j] = 2;
					reg = regs[j];
					matq= newInstruction(NULL,ASSIGNsymbol);
					setModuleId(matq,matRef);
					setFunctionId(matq,newRef);
					getArg(matq,0)= oldArg[j];
					hgh.value.vtype= low.value.vtype= TYPE_oid;

					for (k = 0; k < reg->partitions; k++ ) {
						new_pin = newInstruction(NULL,ASSIGNsymbol);
						setModuleId(new_pin,datacyclotronRef);
						setFunctionId(new_pin,pinRef);

						getArg(new_pin,0) = newTmpVariable(mb, tpes[j]);

						pushArgument(mb,new_pin,newArg[j+k]);
						pushInstruction(mb,new_pin);
						low.value.val.oval= reg->f_bun[k];
						hgh.value.val.oval= reg->l_bun[k];
						z = getArg(new_pin, 0);

						varSetProp(mb, z, PropertyIndex("hlb"), op_gte, (ptr) &low.value);
						varSetProp(mb, z, PropertyIndex("hub"), op_lt, (ptr) &hgh.value);
						matq= pushArgument(mb,matq,z);
					}
					pushInstruction(mb,matq);
				}

			if (functionExit(p))
				for (j = 0; j< mb->vtop; j++) 
					if ( used[j] == 2) {
						reg = regs[j];
						for (k = 0; k < reg->partitions; k++ ) {
							new_unpin = newInstruction(NULL,ASSIGNsymbol);
							setModuleId(new_unpin,datacyclotronRef);
							setFunctionId(new_unpin,unpinRef);

							getArg(new_unpin,0) = newTmpVariable(mb, TYPE_int);
							pushArgument(mb,new_unpin,newArg[j+k]);
							pushInstruction(mb,new_unpin);
						}
					}
#endif
			pushInstruction(mb,p);
		}
		
	}
	GDKfree(old);
#ifdef BIND_DATACYCLOTRON_OPT
	GDKfree(used);
	GDKfree(newArg);
	GDKfree(oldArg);
	GDKfree(tpes);
#endif
	GDKfree(regs);

	return actions;
}

@include optimizerWrapper.mx
@h
@:exportOptimizer(datacyclotron)@
@c
#include "opt_statistics.h"
@:wrapOptimizer(datacyclotron,OPT_CHECK_ALL)@
@- The DataCyclotron Wrapper
@h
opt_export str DCbind(int *ret, str *sch, str *tab, str *col, int *kind, int *part, int *fbun, int *lbun);
@c
str
DCbind(int *ret, str *sch, str *tab, str *col, int *kind, int *part, int *fbun, int *lbun){
	(void) ret;
	(void) sch;
	(void) tab;
	(void) col;
	(void) kind;
	(void) part;
	(void) fbun;
	(void) lbun;
	throw(MAL,"datacyclotron.bind",PROGRAM_NYI);
}

@h
opt_export str DCpin(int *ret, int *bid);
@c
str
DCpin(int *ret, int *bid){
	(void) ret;
	(void) bid;
	throw(MAL,"datacyclotron.pin",PROGRAM_NYI);
}

@h
opt_export str DCunpin(int *ret, int *bid);
@c
str
DCunpin(int *ret, int *bid){
	(void) ret;
	(void) bid;
	throw(MAL,"datacyclotron.unpin",PROGRAM_NYI);
}

@h
opt_export str DCcopy(int *ret, str *sch, str *tab, str *col, int *kind, int *part, int *fbun, int *lbun);
@c
str
DCcopy(int *ret, str *sch, str *tab, str *col, int *kind, int *part, int *fbun, int *lbun){
	(void) ret;
	(void) sch;
	(void) tab;
	(void) col;
	(void) kind;
	(void) part;
	(void) fbun;
	(void) lbun;
	throw(MAL,"datacyclotron.copy",PROGRAM_NYI);
}

@h
#endif
