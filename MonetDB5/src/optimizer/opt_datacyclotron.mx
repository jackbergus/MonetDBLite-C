@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
@' Copyright August 2008-2009 MonetDB B.V.
@' All Rights Reserved.

@f opt_datacyclotron
@- The data cyclotron 

@mal
module datacyclotron;

pattern optimizer.datacyclotron():str
address OPTdatacyclotron;
pattern optimizer.datacyclotron(mod:str, fcn:str):str
address OPTdatacyclotron
comment "Datacyclotron code injection";

command request(schema:str, tab:str, col:str, kind:int):bat[:any_1,:any_2]
address DCrequest
comment "Inform the DataCyclotron about the intended access";
command pin(b:bat[:any_1,:any_2]):bat[:any_1,:any_2]
address DCpin
comment "Inform the DataCyclotron about a pin request";
command unpin(b:bat[:any_1,:any_2])
address DCunpin
comment "Inform the DataCyclotron about a pin request";
@-
The number of overloaded instructions is kept to a minimum.
@h
#ifndef _OPT_DATACYCLOTRON_
#define _OPT_DATACYCLOTRON_
#include "opt_prelude.h"
#include "opt_support.h"
#include "mal_recycle.h"

/* #define DEBUG_OPT_DATACYCLOTRON */
@-
@c
#include "mal_config.h"
#include "opt_datacyclotron.h"
#include "mal_instruction.h"

static int
OPTdatacyclotronImplementation(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	int i, j, actions=0;
	InstrPtr *old, q;
	char *used= (char*) GDKzalloc(mb->vtop *sizeof(char));
	int limit;

	(void) cntxt;
	(void) stk;
	if ( used == NULL)
		return 0;
	limit= mb->stop;
	old = mb->stmt;
	newMalBlkStmt(mb, mb->ssize);
	pushInstruction(mb,old[0]);

	for (i = 1; i<limit; i++) {
		p = old[i];
		if (getModuleId(p)== sqlRef && 
			(getFunctionId(p) == bindRef || 
			 getFunctionId(p) == putName("bind_idxbat",11) ||
			 getFunctionId(p) == binddbatRef) ) {
				setModuleId(p,putName("datacyclotron",13));
				setFunctionId(p, putName("request",7));
				used[getArg(p,0)] = 1;
				actions++;
			}
		for (j = p->retc; j<p->argc; j++)
		if ( used[getArg(p,j)] == 1 ){
			used[getArg(p,j)] = 2;
			q= newStmt(mb,"datacyclotron","pin");
			pushArgument(mb,q,getArg(p,j));
			getArg(p,j)= getArg(q,0);
		}
		if (functionExit(p))
		for (j = 0; j< mb->vtop; j++)
		if ( used[j] == 2){
			q= newStmt(mb,"datacyclotron","unpin");
			pushArgument(mb,q,j);
		}
		pushInstruction(mb,p);
	}
	GDKfree(old);
	return actions;
}
@include optimizerWrapper.mx
@h
@:exportOptimizer(datacyclotron)@
#endif
@c
#include "opt_statistics.h"
@:wrapOptimizer(datacyclotron,OPT_CHECK_ALL)@
@- The DataCyclotron Wrapper
@c
str
DCrequest(int *ret, str *sch, str *tab, str *col, int *kind){
	(void) ret;
	(void) sch;
	(void) tab;
	(void) col;
	(void) kind;
	throw(MAL,"datacyclotron.request","nyi");
}

str
DCpin(int *ret, int *bid){
	(void) ret;
	(void) bid;
	throw(MAL,"datacyclotron.pin","nyi");
}


str
DCunpin(int *ret, int *bid){
	(void) ret;
	(void) bid;
	throw(MAL,"datacyclotron.unpin","nyi");
}

