@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
@' Copyright August 2008-2009 MonetDB B.V.
@' All Rights Reserved.

@f opt_octopus
@a M. Kersten
@- Map-reduce processing
Query execution can be improved significantly using distributed processing.
Traditionally, this encompasses fragmentation and allocation of the base
tables over multiple sites and query plans that include on the fly transport
of intermediate results.

Breaking the database into pieces itself is a well-studied area.
Most approaches consider the workload and search for a good split
of the base tables, such that the workload performance improves.

In the Octopus we focus on SQL for map-reduce processing.
The first approach is to capitalize upon the metosis and
mergetable optimizers. They break the table into pieces
based on the head and propagate the effect through the plan.
Breaking the table depends on the number of sites to play with,
which can be obtained dynamically from the merovingian.

The octopus untangles the resulting plan into a controlling head function,
which controls the actions, and specific plans for each tentacle.
The octopus is called just after the mergetable optimizer.

For this experiment we assume that all sites have a replica
or can access a shared version of the database.

To make the structure work, we need asynchronous execution of
the individual legs.

A snippet of an octopus with two legs is shown below 

@verbatim
function user.s1_0():void;
    _87 := octopus.exec("siteA","user","leg1");
    _88 := octopus.exec("siteB","user","leg2");
    _15 := octopus.pack(_87,_88);
    _16 := sql.resultSet(1,1,_15);
    sql.rsColumn(_16,"sys.squida","bid","int",32,0,_15);
    _21 := io.stdout();
    sql.exportResult(_21,_16);
end s1_0;
function user.leg1():void;
    _52 := sql.bind("sys","squida","bid",0);
    (_54,_56) := bat.partition(_52);
    _62 := sql.bind("sys","squida","bid",2);
    (_64,_65) := bat.partition(_62);
    _72 := algebra.kdifference(_54,_64);
    _78 := algebra.kunion(_72,_64);
    _13:bat[:oid,:oid]  := sql.bind_dbat("sys","squida",1);
    _14 := bat.reverse(_13);
    _85 := algebra.kdifference(_78,_14);
    return leg1:= _85;
end leg1;
function user.leg2():void;
    _52 := sql.bind("sys","squida","bid",0);
    (_54,_56) := bat.partition(_52);
    _62 := sql.bind("sys","squida","bid",2);
    (_64,_65) := bat.partition(_62);
    _72 := algebra.kdifference(_56,_65);
    _78 := algebra.kunion(_72,_65);
    _13:bat[:oid,:oid]  := sql.bind_dbat("sys","squida",1);
    _14 := bat.reverse(_13);
    _85 := algebra.kdifference(_78,_14);
    return leg2:= _85;
end leg1;

@end verbatim

The octopus interferes with the recycler as follows.
Let the octopus head be C and two tentacles A and B.
Then at C we can built a list of recycled instructions, which
need not be executed twice. Inclusing remote requests.
However, in that case we should be
sure that the recycler cache at A,B, and C are synchronized.
This can be guaranteed if all remote sites are under control of C
solely and the protocols for eviction are serialzed.
An option is to explicitly evict remote instructions, but 
an implicit is more elegant. [Work todo]
@{
@mal
module octopus; 
pattern optimizer.octopus():str
address OPToctopus;
pattern optimizer.octopus(mod:str, fcn:str):str
address OPToctopus
comment "Map-execute-reduce parallelism optimizer";
@h
#ifndef _OPT_OCTOPUS_
#define _OPT_OCTOPUS_
#include "opt_prelude.h"
#include "opt_support.h"

/* #define DEBUG_OPT_OCTOPUS       show partial result */

@c
#include "mal_config.h"
#include "opt_octopus.h"
#include "mal_interpreter.h"	/* for showErrors() */
#include "mal_builder.h"
@-
The algorithm consists of several steps. The first one
replaces the original query and creates the tentacle
functions. In the second phase the should be registered
at the different sites.

The key observation is that whenever we encouter a mat.pack,
there is a need to bring information together for inspection.
Therefore, we recursively break a plan by looking for the
pack instructions and collect all dependent instructions.
The original block is trimmed as far as needed.
@c
static MalBlkPtr 
OPTtentacle(Client cntxt,  MalBlkPtr mb, int start, int varid){
	MalBlkPtr tm= NULL;
	InstrPtr p, q, anchor= NULL;
	int i,j,top=0, fnd;
	char buf[BUFSIZ];
	InstrPtr *list = (InstrPtr*) GDKzalloc(sizeof(InstrPtr) * mb->ssize);
	char *needed= (char*) GDKzalloc(mb->vtop);
	str name= NULL;
	Symbol s;
	int fd,port;

	/* check for running merovingian */
	snprintf(buf, BUFSIZ, "%s/.merovingian_lock", GDKgetenv("gdk_dbfarm"));
	if ( GDKgetenv("mero_port") && (fd = MT_lockf(buf, F_TLOCK, 4, 1)> 0)){
		close(fd);
		port = atoi(GDKgetenv("mero_port"));
	} else
		port = atoi(GDKgetenv("mapi_port")?GDKgetenv("mapi_port"):"localhost");

#ifdef DEBUG_OPT_OCTOPUS
	stream_printf(cntxt->fdout,"create tentacle for %d\n",varid);
#endif

	/* locate the last assignment for varid */
	for (i = start; i > 0; i--){
		p= getInstrPtr(mb,i);
		fnd =0;
		for (j=0; j<p->retc; j++)
			fnd+= getArg(p,j) == varid;
		if ( fnd){
			snprintf(buf,BUFSIZ,"tentacle_%s_%d", 
				getFunctionId(getInstrPtr(mb,0)),varid);
			name =  putName(buf,strlen(buf));
			q= newFcnCall(mb,octopusRef, name);
			getArg(q,0)= varid;
			needed[varid]= 1;
			anchor= p;
			break;
		}
	}
	assert( name);

	for (; i > 0; i--){
		p= getInstrPtr(mb,i);
		fnd = 0;
		for (j = 0; j < p->retc; j++)
			fnd += needed[getArg(p,j)];
		if ( fnd) {
			for (j = p->retc; j < p->argc; j++)
				needed[getArg(p,j)]= 1;
			list[top++] = p;
		}
	}
	/* create the tentacle procedure */
	s= (Symbol) GDKzalloc(sizeof(SymRecord));
	s->name= name;
	s->kind=FUNCTIONsymbol;
	s->def= tm= copyMalBlk(mb);	/* get the symbol table for free */
	q= getInstrPtr(tm,0);		/* and re-use the signature */
	q->argc= 1;
	tm->var[0]->name= GDKstrdup(name);	
	setArgType(tm, q, 0, getVarType(mb,varid));
	tm->stop =1;
	setModuleId(q,octopusRef);
	setFunctionId(q, name);

	for (top--; top >= 0; top--)
		pushInstruction(tm, copyInstruction(list[top]));
	q= newAssignment(tm);
	getArg(q,0) = getArg(getInstrPtr(tm,0), 0);
	pushArgument(tm,q,varid);
	q->barrier= RETURNsymbol;
	pushEndInstruction(tm);
	q= newFcnCall(tm,optimizerRef,replicatorRef);
	insertSymbol(findModule(cntxt->nspace,octopusRef),s);
#ifdef DEBUG_OPT_OCTOPUS
	printFunction(cntxt->fdout,tm,0,LIST_MAL_STMT);
#endif
	GDKfree(list);
	GDKfree(needed);
	return tm;
}
@-
@c
static int
OPToctopusImplementation(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	InstrPtr q, p, *old;
	int last=0, x, y, i, j, limit, slimit, actions=0;
	int tn=0, maxtn=32;
	MalBlkPtr *tentacle= (MalBlkPtr *) alloca(sizeof(MalBlkPtr) * maxtn);


#ifdef DEBUG_OPT_OCTOPUS
	stream_printf(cntxt->fdout, "#Octopus optimizer started\n");
	printFunction(cntxt->fdout, mb, 0, LIST_MAL_STMT);
#else
	(void) cntxt;
#endif
	(void) stk;
	(void) pci;
@-
All octopus tentacle code is collected in a separate module
to ease future distribution and scheduling.
@c
	(void) fixModule(cntxt->nspace,octopusRef);

	limit = mb->stop;
	slimit = mb->ssize;
	old = mb->stmt;

	newMalBlkStmt(mb, mb->ssize);
	pushInstruction(mb, old[0]);

	for (i = 1; i < limit; i++) {
		p = old[i];

		if( (getModuleId(p)== matRef && getFunctionId(p)== packRef)){
			/* create the tentacle, modifying the current plan */
			/* barrier go:= scheduler.octopus(); */
			q= newStmt(mb,schedulerRef,octopusRef);
			setArgType(mb,q,0, TYPE_bit);
			x= getArg(q,0);
			q->barrier = BARRIERsymbol;

			for ( j= p->retc; j<p->argc; j++)
				tentacle[tn++] =  OPTtentacle(cntxt,mb,mb->stop-1,getArg(p,j));

			/* exit c; */
			q= newAssignment(mb);
			q->retc=1;
			q->barrier= EXITsymbol;
			getArg(q,0)= x;

			/* modified pack instruction */
			p= pushInt(mb,p,10);
			y= getArg(p,p->argc-1);
			p= pushInt(mb,p,10);
			for (j=p->argc-1;j>p->retc-1; j--)
				getArg(p,j)= getArg(p,j-2);
			getArg(p,p->retc)= x;
			getArg(p,p->retc+1)= y;
			setModuleId(p,schedulerRef);
			pushInstruction(mb,p);
			actions++;
			continue;
		} 
		pushInstruction(mb,p);
		if (p->token == ENDsymbol)
			last= mb->stop;
	}
	GDKfree(old);
#ifdef DEBUG_OPT_OCTOPUS
	if (actions) {
		stream_printf(cntxt->fdout, "#octopus\n");
		printFunction(cntxt->fdout, mb, 0, LIST_MAL_STMT);
	}
#endif
@-
The tentacle code should be optimized by the remaining optimizers.
@c
	for (j=last; j< limit; j++)
	for (i=0; i<tn; i++)
		pushInstruction(tentacle[i], copyInstruction(getInstrPtr(mb,j)));
	for (i=0; i<tn; i++){
		chkProgram(cntxt->nspace, tentacle[i]);
#ifdef DEBUG_OPT_OCTOPUS
		printFunction(cntxt->fdout, tentacle[i], 0, LIST_MAL_STMT);
#endif
		optimizeMALBlock(cntxt,tentacle[i]);
		if ( tentacle[i]->errors ) {
			showException(MAL,"optimizer.octopus","failed to compile");
			mb->errors++;
		}
	}
	
	return actions;
}
@include optimizerWrapper.mx
@h
@:exportOptimizer(octopus)@
#endif
@c
#include "opt_statistics.h"
@:wrapOptimizer(octopus,OPT_CHECK_ALL)@
@}
