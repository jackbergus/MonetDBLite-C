@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
@' Copyright August 2008-2009 MonetDB B.V.
@' All Rights Reserved.

@f opt_octopus
@a M. Kersten
@- Map-reduce processing
Query execution can be improved significantly using distributed processing.
Traditionally, this encompasses fragmentation and allocation of the base
tables over multiple sites and query plans that include on the fly transport
of intermediate results.

Breaking the database into pieces itself is a well-studied area.
Most approaches consider the workload and search for a good split
of the base tables, such that the workload performance improves.

In the Octopus we focus on SQL for map-reduce processing.
The first approach is to capitalize upon the metosis and
mergetable optimizers. They break the table into pieces
based on the head and propagate the effect through the plan.
Breaking the table depends on the number of sites to play with,
which can be obtained dynamically from the merovingian.

The octopus untangles the resulting plan into a controlling function
and a plan for each tentacle.
The octopus is to be called after the mergetable optimizer.

A snippet of an octopus plan with two tentacles is shown below 

@verbatim
function octopus.exec_qry(srv:str,fcn:str, ver:int):bat[:oid,:int];
	conn:= remote.connect(srv,"monetdb","monetdb");
	v:= remote.put(conn,ver);
	r:= remote.exec(conn,"octopus",fcn,v);
	b:bat[:oid,:int]:= remote.get(conn,r);
	return b;
end exec_qry;
function octopus.leg0(version:int):bat[:oid,:int];
	conn:= remote.connect("demo","monetdb","monetdb");
    _54:bat[:oid,:int] := octopus.bind(conn,"sys","squida","bid",0,0@0,25@0,version);
    _64:bat[:oid,:int] := octopus.bind(conn,"sys","squida","bid",2,0@0,25@0,version);
    _72 := algebra.kdifference(_54,_64);
    _78 := algebra.kunion(_72,_64);
    _13:bat[:oid,:oid]  := octopus.bind_dbat(conn,"sys","squida",1,version);
    _14 := bat.reverse(_13);
    _85 := algebra.kdifference(_78,_14);
    return leg0:= _85;
end octopus.leg0;
function octopus.leg1( version:int):bat[:oid,:int];
	conn:= remote.connect("demo","monetdb","monetdb");
    _56:bat[:oid,:int] := octopus.bind(conn,"sys","squida","bid",0,version,2,1);
    _65:bat[:oid,:int] := octopus.bind(conn,"sys","squida","bid",2,version,2,1);
    _72 := algebra.kdifference(_56,_65);
    _78 := algebra.kunion(_72,_65);
    _13:bat[:oid,:oid]  := octopus.bind_dbat(conn,"sys","squida",1,version);
    _14 := bat.reverse(_13);
    _85 := algebra.kdifference(_78,_14);
    return leg1= _85;
end octopus.leg1;

function user.qry():void;
barrier (_100,version:int):= scheduler.octopus(10);
    _87 := octopus.exec_qry("tbd","leg0",version);
    _88 := octopus.exec_qry("tbd","leg1",version);
exit (_100,version);
    _15 := mat.pack(_87,_88);
    _16 := sql.resultSet(1,1,_15);
    sql.rsColumn(_16,"sys.squida","bid","int",32,0,_15);
    _21 := io.stdout();
    sql.exportResult(_21,_16);
end qry;
@end verbatim

[versioning]
The argument to the tentacle is the expected version of the database
to be used and optional arguments for the query.

[partition access]
For a tentacle to work it needs access to its storage layer.
It is encapsulated in the operation octopus.bind(Conn,S,T,C,V,P,I),
which performs an upcall to the octopus Conn to deliver 
the Ith piece of the column S.T.C partitioned into P pieces 
matching version V.

Ideally, the interaction with the head is restricted
to calling for a handle to access the partition from
its source directly. 
In a shared disk setup, we merely ensure that a
possibly cached version is not out of date.
The last resort is to deliver the partition by the
octopus using a remote BAT copy.
Doing so would effectively implement
a kind of distributed disk system. The current state of
affairs allows for a track where even a low level 
ftp- call would suffice to obtain the complete BAT
from anywhere, or we can provide a NAS functionality
over the database store that delivers the partitions
of interest.

The octopus upcalls for delivering the partitions should
be encapsulated into a function to shield all possible
remote access operations. It is a function registered
by the SQL front-end.

[recycling]
The version argument passed during the tentacle call
is used to enforce synchronisation of the recycler caches
between the octopus and its tentacles.
If the version does not change between calls, the
recylcer will simply step over the bind() calls,
reusing with it already have instead.
If for local resource management decisions the cache
is cleared, then it will automatically trigger a
re-execution of the bind().

[Naming]
The tentacles received from the octopus should be ensured
not to clash with those already known. Therefore, we simply
tag them by orginating site.

[Caveats]
Updates on the persistent tables are not handled yet. They should
lead to an upcall to the head for inclusion. Any update invalidates
the request to distributed processing.
In the same line, multi-statement SQL transactions including
updates should be ignored. Perhaps we should limit it to
autocommit situations only. [todo]
@{
@mal
module octopus; 
pattern optimizer.octopus():str
address OPToctopus;
pattern optimizer.octopus(mod:str, fcn:str):str
address OPToctopus
comment "Map-execute-reduce parallelism optimizer";
@h
#ifndef _OPT_OCTOPUS_
#define _OPT_OCTOPUS_
#include "opt_prelude.h"
#include "opt_support.h"

/* #define DEBUG_OPT_OCTOPUS            show partial result */

@c
#include "mal_config.h"
#include "opt_octopus.h"
#include "opt_deadcode.h"
#include "mal_interpreter.h"	/* for showErrors() */
#include "mal_builder.h"
@-
The algorithm consists of several steps. The first one
replaces the original query and creates the tentacle
functions. In the second phase the should be registered
at the different sites.

The key observation is that whenever we encouter a mat.pack,
there is a need to bring information together for inspection.
Therefore, we recursively break a plan by looking for the
pack instructions and collect all dependent instructions.
The original block is trimmed as far as needed.
@c
static int
OCTinitcode(Client cntxt, MalBlkPtr mb){
	InstrPtr p;
	(void) cntxt;
	p = newStmt(mb, remoteRef,connectRef);
    p= pushStr(mb,p, GDKgetenv("gdk_dbname"));
    p= pushStr(mb,p,"monetdb");
    p= pushStr(mb,p,"monetdb");
    p= pushStr(mb,p,"msql");
	return getArg(p,0);
}

@-
Be prepared to catch errors from the remote site.
You should catch them, otherwise the session is not closed.
Beware, exceptions should be catched and thrown after the
connection has been closed.
@c
static void
OCTexitcode(MalBlkPtr mb, int conn,int varid){
	InstrPtr p;

	newCatchStmt(mb, "ANYexception");
	p = newStmt(mb, remoteRef,disconnectRef);
    pushArgument(mb,p,conn);
	newRaiseStmt(mb,"ANYexception");
	newExitStmt(mb, "ANYexception");

	p = newStmt(mb, remoteRef,disconnectRef);
    pushArgument(mb,p,conn);
	p= newAssignment(mb);
	getArg(p,0) = getArg(getInstrPtr(mb,0), 0);
	pushArgument(mb,p,varid);
	p->barrier= RETURNsymbol;
	pushEndInstruction(mb);
	newStmt(mb,optimizerRef,putName("aliases",7));
	newStmt(mb,optimizerRef,putName("deadcode",8));
}

static MalBlkPtr 
OPTtentacle(Client cntxt,  MalBlkPtr mb, InstrPtr sig, InstrPtr pci, int start, int idx, int v2){
	MalBlkPtr tm = NULL;
	InstrPtr p = NULL, q;
	int varid= pci->argv[idx],i,j,top=0, fnd,tbd;
	char buf[BUFSIZ];
	InstrPtr *list = (InstrPtr*) GDKzalloc(sizeof(InstrPtr) * mb->ssize);
	char *needed= (char*) GDKzalloc(mb->vtop);
	int *alias= (int*) GDKzalloc(mb->vtop * sizeof(int));
	str name= NULL, name2= NULL;
	Symbol s;
	ValRecord cst;
	int conn=0;

	if (list == NULL || needed == NULL){
		if ( list ) GDKfree(list);
		if ( needed) GDKfree(needed);
		if ( alias) GDKfree(alias);
		return 0;
	}
#ifdef DEBUG_OPT_OCTOPUS
	stream_printf(cntxt->fdout,"#create tentacle for %d %d %d\n",start,idx,varid);
	printInstruction(cntxt->fdout,mb,0,pci,0);
#else
	(void) cntxt;
#endif

	/* locate the last assignment for varid */
	fnd = -1;
	for (i = start; i > 0; i--){
		p= getInstrPtr(mb,i);
		for (j=0; j<p->retc; j++)
			if ( getArg(p,j) == varid){
				fnd= j;
				goto foundit;
			}
	}
foundit:
	if ( p == NULL) {
		if ( list ) GDKfree(list);
		if ( needed) GDKfree(needed);
		if ( alias) GDKfree(alias);
		return 0;	/* bail out, internal error */
	}

	for (j = 0; j < p->argc; j++)
		needed[getArg(p,j)]= 1;
	/* find the instructions needed */
	for (; i > 0; i--){
		p= getInstrPtr(mb,i);
		fnd = 0;
		if ( p->barrier){
			for (j = 0; j < p->retc; j++)
				needed[getArg(p,j)]= 1;
			fnd = 1;
		}
		for (j = 0; j < p->retc; j++)
			fnd += needed[getArg(p,j)];
		if ( fnd) {
			for (j = 0; j < p->argc; j++)
				needed[getArg(p,j)]= 1;
			list[top++] = p;
		}
	}
#ifdef DEBUG_OPT_OCTOPUS
	stream_printf(cntxt->fdout,"List of instructions\n");
	for(i=top-1;i>=0;i--)
		printInstruction(cntxt->fdout,mb,0,list[i], LIST_MAL_STMT);
#endif

	snprintf(buf,BUFSIZ,"tentacle_%s_%d", 
		getFunctionId(getInstrPtr(mb,0)),varid);
	name =  putName(buf,strlen(buf));

	snprintf(buf,BUFSIZ,"exec_%s", 
		getFunctionId(getInstrPtr(mb,0)));
	name2 =  putName(buf,strlen(buf));

	q= newFcnCall(mb,octopusRef, name2);
	setArgType(mb,q,0,getVarType(mb,varid));
	setVarUDFtype(mb,getArg(q,0));
	cst.vtype = TYPE_str;
	cst.val.sval= GDKstrdup("tbd");
	cst.len= (int) strlen(cst.val.sval);
	tbd = defConstant(mb, TYPE_str, &cst);
	q= pushArgument(mb,q,tbd);
	q= pushStr(mb,q,name);
	q= pushArgument(mb,q,v2);
	needed[varid]= 1;
	for (j= sig->retc; j <  sig->argc; j++)
		q = pushArgument(mb,q,getArg(sig, j));
	getArg(pci,idx) = getArg(q,0);

	/* create the tentacle procedure */
	s= newFunction(octopusRef,name,FUNCTIONsymbol);
	tm= s->def;
	tm->keephistory= mb->keephistory;
	p= getInstrPtr(tm,0);
	for(i=q->retc+2; i<q->argc; i++){
		alias[getArg(q,i)] = cloneVariable(tm,mb,getArg(q,i));
		p= pushArgument(tm,p, alias[getArg(q,i)]);
	}
	setVarType(tm,getArg(p,0),getVarType(mb,varid));

	conn= OCTinitcode(cntxt, tm);
	for (top--; top >= 0; top--){
		p = copyInstruction(list[top]);
		for (i= 0; i< p->argc; i++){
			int a= getArg(list[top],i);
			if (alias[a]==0) 
				alias[a] = cloneVariable(tm,mb,a);
			getArg(p,i) = alias[a];
		}
		if (getModuleId(p) == sqlRef &&
			( getFunctionId(p) == bindRef ||
			  getFunctionId(p) == bindidxRef)){
			setModuleId(p, octopusRef);
			setVarUDFtype(tm,getArg(p,0));
			setArgType(tm,p,0, getArgType(mb,list[top],0));
			p= setArgument(tm,p,1,conn);
			p = pushArgument(tm, p, getArg(getInstrPtr(tm,0),1));
		} 
		if (getModuleId(p) == sqlRef && getFunctionId(p) == binddbatRef ){
			setModuleId(p, octopusRef);
			setVarUDFtype(tm,getArg(p,0));
			setArgType(tm,p,0, getArgType(mb,list[top],0));
			p= setArgument(tm,p,1,conn);
			p = pushArgument(tm, p, getArg(getInstrPtr(tm,0),1));
		} 
		pushInstruction(tm, p);
	}

	varid = alias[varid];
	OCTexitcode(tm, conn,varid);
	clrDeclarations(tm);

#ifdef DEBUG_OPT_OCTOPUS
	stream_printf(cntxt->fdout, "TENTACLE octopus \n");
	printFunction(cntxt->fdout, tm, 0, LIST_MAL_STMT);
#endif
	insertSymbol(findModule(cntxt->nspace,octopusRef),s);
	GDKfree(list);
	GDKfree(alias);
	GDKfree(needed);
	return tm;
}

static int
OPToctopusImplementation(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	InstrPtr q, p, sig, *old;
	int last=0, i, j, limit, actions=0, arg[1024];
	int tn=0, maxtn= MAL_MAXCLIENTS -2;	/* should be relaxed */
	MalBlkPtr *tentacle= (MalBlkPtr *) GDKmalloc(sizeof(MalBlkPtr) * maxtn),sm = NULL;
	Symbol s2;
	int target=0, update=0;
	int version,v2;
	int k,l;
	char buf[BUFSIZ];


	if ( tentacle == NULL)
		return 0;
#ifdef DEBUG_OPT_OCTOPUS
	stream_printf(cntxt->fdout, "#Octopus optimizer called\n");
	printFunction(cntxt->fdout, mb, 0, LIST_MAL_STMT);
#else
	(void) cntxt;
#endif
	(void) stk;
@-
All octopus tentacle code is collected in a separate module
to ease future distribution and scheduling.
The optimizer works by looking only to the mat.pack statement.

The experiment is to only look at the last pack statement,
as this creates the largest subplans and avoids an explosion
in threads.
A recursive call op the optimizer can be used to create more tentacles, which,
when scheduled correctly, would not lead to duplicate work.
@c
	(void) fixModule(cntxt->nspace,octopusRef);

	limit = mb->stop;
	old = mb->stmt;

	for (i = 1; i < limit; i++){
		p = old[i];
		if( (getModuleId(p)== matRef && getFunctionId(p)== packRef) )
			target = i;
		if( (getModuleId(p)== sqlRef && getFunctionId(p)== appendRef) )
			update = 1;
		if( (getModuleId(p)== sqlRef && getFunctionId(p)== deleteRef) )
			update = 1;
	}
	/* we do not  support yet update operations in the octopus */
	if ( update )
		return 0;

	newMalBlkStmt(mb, mb->ssize);
	pushInstruction(mb, old[0]);

	sig= old[0];
	for (i = 1; i < limit; i++) {
		p = old[i];
		if ( p == pci){
			freeInstruction(pci);
			old[i]= 0;
			continue;
		}
		if( (getModuleId(p)== matRef && getFunctionId(p)== packRef) && 
			i == target && tn + p->argc - p->retc < maxtn){
			InstrPtr qq;
			int conn,dbvar,qvar;

			/* prepare the exec_ procedure */
			snprintf(buf,BUFSIZ,"exec_%s", getFunctionId(getInstrPtr(mb,0)));
			s2= newFunction(octopusRef, putName(buf,strlen(buf)), FUNCTIONsymbol);
			sm= s2->def;
			q= getInstrPtr(sm,0);
			setArgType(sm,q,0,getArgType(mb,p,1));
			dbvar= newVariable(sm,GDKstrdup("dbname"),TYPE_str);
			qvar = newVariable(sm,GDKstrdup("query"),TYPE_str);
			version= newVariable(sm,GDKstrdup("version"),TYPE_int);
			q= pushArgument(sm,q,dbvar);
			q= pushArgument(sm,q,qvar);
			q= pushArgument(sm,q,version);
			/* just add all arguments for the moment */
			for (j=sig->retc; j < sig->argc; j++){
				int aj= cloneVariable(sm,mb,getArg(sig,j));
				q = pushArgument(sm,q,aj);
			}

			/* create the tentacle, modifying the current plan */
			/* initialize the result variables */
			q= newAssignment(mb);
			getArg(q,0)= getArg(p,0);
			q= pushNil(mb,q, getVarType(mb, getArg(p,0)));

			/* barrier (go,version):= scheduler.octopus(timeout); */
			qq= q= newStmt(mb,schedulerRef,octopusRef);
			setArgType(mb,q,0, TYPE_bit);
			v2= newVariable(mb,GDKstrdup("version"),TYPE_int);
			pushArgument(mb,q, v2);
			q->retc = 2;
			q= pushInt(mb,q,10);
			q->barrier = BARRIERsymbol;

			for ( j= p->retc; j<p->argc; j++)
				tentacle[tn++] =  OPTtentacle(cntxt,mb,sig,p,mb->stop-1,j,v2);

			pushInstruction(mb,p);

			/* exit c; */
			q= newAssignment(mb);
			q->barrier= EXITsymbol;
			getArg(q,0)= getArg(qq,0);
			getArg(q,1)= v2;
			q->retc=2;
			q->argc=2;

			/* now finalize the exec operation */
			q = newStmt(sm, remoteRef,connectRef);
			conn= getArg(q,0);
			q = pushArgument(sm, q, dbvar);
			q= pushStr(sm,q,"monetdb");
			q= pushStr(sm,q,"monetdb");
			q= pushStr(sm,q,"msql");

			/* v:= remote.put(version) */
			q= newFcnCall(sm,remoteRef,putRef);
			q= pushArgument(sm,q,conn);
			q= pushArgument(sm,q,version);
			version= getArg(q,0);

			/* get addition arguments needed in a tentacle */
			assert(sig->argc <1024);
			for (j= sig->retc; j<  sig->argc; j++){
				l= newTmpVariable(sm,TYPE_str);
				q= newFcnCall(sm,remoteRef,putRef);
				arg[j]= getArg(q,0)= l;
				pushArgument(sm,q, conn);
				pushArgument(sm,q,findVariable(sm,getArgName(mb,sig,j)));
			}

			/* k:= remote.put(conn,kvar) */
			q= newFcnCall(sm,remoteRef,putRef);
			q= pushArgument(sm,q,conn);
			q= pushArgument(sm,q, getArg(getInstrPtr(sm,0),0));
			setVarUDFtype(sm,getArg(q,q->argc-1));
			k= getArg(q,0);

			/* k:= remote.exec(conn,octopus,qry,version....) */
			q= newFcnCall(sm,remoteRef,execRef);
			getArg(q,0)= k;
			q= pushArgument(sm,q,conn);
			q= pushStr(sm,q,octopusRef);
			q= pushArgument(sm,q,qvar);
			q= pushArgument(sm,q,version);
			/* deal with all arguments !*/
			for (j=sig->retc; j < sig->argc; j++)
				q = pushArgument(sm,q,arg[j]);


			/* l:=remote.get(conn,k) */
			q= newFcnCall(sm,remoteRef,getRef);
			q= pushArgument(sm,q,conn);
			q= pushArgument(sm,q,k);
			l= getArg(q,0);
			setVarType(sm,l, getArgType(sm,getInstrPtr(sm,0),0));
			setVarUDFtype(sm,l);

			/* catch and propagate errors */
			newCatchStmt(sm, "ANYexception");
			q = newStmt(sm, remoteRef,disconnectRef);
			pushArgument(sm,q,conn);
			newRaiseStmt(sm,"ANYexception");
			newExitStmt(sm, "ANYexception");

			/* close connection */
			q = newStmt(sm, remoteRef,disconnectRef);
			pushArgument(sm,q,conn);

			/* return exec_qry:= l; */
			q= newAssignment(sm);
			q->barrier= RETURNsymbol;
			getArg(q,0)= getArg(getInstrPtr(sm,0),0);
			pushArgument(sm,q,l);

			pushEndInstruction(sm);
			insertSymbol(findModule(cntxt->nspace,octopusRef),s2);
			clrDeclarations(sm);
			chkProgram(cntxt->nspace,sm);
			actions++;
			continue;
		} 
		pushInstruction(mb,p);
		if (p->token == ENDsymbol){
			last= i;
			break;
		}
	}
	
@-
Keep the remaining optimizers in the main program.
The tentacle code should be optimized by the remaining optimizers too.
@c
	for (j=last+1; j< limit; j++)
	if (old[j] )
		pushInstruction(mb, old[j]);

	for (j=last+1; j< limit; j++)
	for (i=0; i<tn; i++)
	if ( old[j] && old[j]->token != REMsymbol)
		newStmt(tentacle[i], getModuleId(old[j]),getFunctionId(old[j]));
	
	for (i=0; i<tn; i++){
		clrDeclarations(tentacle[i]);
		chkProgram(cntxt->nspace,tentacle[i]);
		optimizeMALBlock(cntxt,tentacle[i]);
		if ( tentacle[i]->errors ) {
			showException(MAL,"optimizer.octopus","failed to compile");
			mb->errors++;
		}
	}
#ifdef DEBUG_OPT_OCTOPUS
	if (actions) {
		stream_printf(cntxt->fdout, "DONE octopus \n");
		printFunction(cntxt->fdout, mb, 0, LIST_MAL_STMT);
		printFunction(cntxt->fdout, sm, 0, LIST_MAL_STMT);
		for (i=0; i<tn; i++)
			printFunction(cntxt->fdout, tentacle[i], 0, LIST_MAL_STMT);
	}
#endif
	GDKfree(old);
	GDKfree(tentacle);
	return actions;
}
@include optimizerWrapper.mx
@h
@:exportOptimizer(octopus)@
#endif
@c
#include "opt_statistics.h"
@:wrapOptimizer(octopus,OPT_CHECK_ALL)@
@}
