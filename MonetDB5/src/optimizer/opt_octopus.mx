@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
@' Copyright August 2008-2009 MonetDB B.V.
@' All Rights Reserved.

@f opt_octopus
@a M. Kersten
@- Map-reduce processing
Query execution can be improved significantly using distributed processing.
Traditionally, this encompasses fragmentation and allocation of the base
tables over multiple sites and query plans that include on the fly transport
of intermediate results.

Breaking the database into pieces itself is a well-studied area.
Most approaches consider the workload and search for a good split
of the base tables, such that the workload performance improves.

In the Octopus we focus on SQL for map-reduce processing.
The first approach is to capitalize upon the metosis and
mergetable optimizers. They break the table into pieces
based on the head and propagate the effect through the plan.
Breaking the table depends on the number of sites to play with,
which can be obtained dynamically from the merovingian.

The octopus untangles the resulting plan into a controlling function
and a plan for each tentacle.
The octopus is to be called after the mergetable optimizer.

A snippet of an octopus plan with two tentacles is shown below 

@verbatim
function octopus.exec_qry(srv:str,fcn:str, ver:int):bat[:oid,:int];
	conn:= remote.connect(srv,"monetdb","monetdb");
	v:= remote.put(conn,ver);
	r:= remote.exec(conn,"octopus",fcn,v);
	b:bat[:oid,:int]:= remote.get(conn,r);
	return b;
end exec_qry;
function octopus.leg0(version:int):bat[:oid,:int];
	conn:= remote.connect("demo","monetdb","monetdb");
    _54:bat[:oid,:int] := octopus.bind(conn,"sys","squida","bid",0,version,2,0);
    _64:bat[:oid,:int] := octopus.bind(conn,"sys","squida","bid",2,version,2,0);
    _72 := algebra.kdifference(_54,_64);
    _78 := algebra.kunion(_72,_64);
    _13:bat[:oid,:oid]  := octopus.bind_dbat(conn,"sys","squida",1,version,2,1);
    _14 := bat.reverse(_13);
    _85 := algebra.kdifference(_78,_14);
    return leg0:= _85;
end octopus.leg0;
function octopus.leg1( version:int):bat[:oid,:int];
	conn:= remote.connect("demo","monetdb","monetdb");
    _56:bat[:oid,:int] := octopus.bind(conn,"sys","squida","bid",0,version,2,1);
    _65:bat[:oid,:int] := octopus.bind(conn,"sys","squida","bid",2,version,2,1);
    _72 := algebra.kdifference(_56,_65);
    _78 := algebra.kunion(_72,_65);
    _13:bat[:oid,:oid]  := octopus.bind_dbat(conn,"sys","squida",1,version,2,1);
    _14 := bat.reverse(_13);
    _85 := algebra.kdifference(_78,_14);
    return leg1= _85;
end octopus.leg1;

function user.qry():void;
barrier (_100,version:int):= scheduler.octopus(10);
    _87 := octopus.exec_qry("tbd","leg0",version);
    _88 := octopus.exec_qry("tbd","leg1",version);
exit (_100,version);
    _15 := mat.pack(_87,_88);
    _16 := sql.resultSet(1,1,_15);
    sql.rsColumn(_16,"sys.squida","bid","int",32,0,_15);
    _21 := io.stdout();
    sql.exportResult(_21,_16);
end qry;
@end verbatim

[versioning]
The argument to the tentacle is the expected version of the database
to be used and optional arguments for the query.

[partition access]
For a tentacle to work it needs access to its storage layer.
It is encapsulated in the operation octopus.bind(Conn,S,T,C,V,P,I),
which performs an upcall to the octopus Conn to deliver 
the Ith piece of the column S.T.C partitioned into P pieces 
matching version V.

Ideally, the interaction with the head is restricted
to calling for a handle to access the partition from
its source directly. 
In a shared disk setup, we merely ensure that a
possibly cached version is not out of date.
The last resort is to deliver the partition by the
octopus using a remote BAT copy.
Doing so would effectively implement
a kind of distributed disk system. The current state of
affairs allows for a track where even a low level 
ftp- call would suffice to obtain the complete BAT
from anywhere, or we can provide a NAS functionality
over the database store that delivers the partitions
of interest.

The octopus upcalls for delivering the partitions should
be encapsulated into a function to shield all possible
remote access operations. It is a function registered
by the SQL front-end.

[recycling]
The version argument passed during the tentacle call
is used to enforce synchronisation of the recycler caches
between the octopus and its tentacles.
If the version does not change between calls, the
recylcer will simply step over the bind() calls,
reusing with it already have instead.
If for local resource management decisions the cache
is cleared, then it will automatically trigger a
re-execution of the bind().

[Naming]
The tentacles received from the octopus should be ensured
not to clash with those already known. Therefore, we simply
tag them by orginating site.
@{
@mal
module octopus; 
pattern optimizer.octopus():str
address OPToctopus;
pattern optimizer.octopus(mod:str, fcn:str):str
address OPToctopus
comment "Map-execute-reduce parallelism optimizer";
@h
#ifndef _OPT_OCTOPUS_
#define _OPT_OCTOPUS_
#include "opt_prelude.h"
#include "opt_support.h"

#define DEBUG_OPT_OCTOPUS          /* show partial result */

@c
#include "mal_config.h"
#include "opt_octopus.h"
#include "opt_deadcode.h"
#include "mal_interpreter.h"	/* for showErrors() */
#include "mal_builder.h"
@-
The algorithm consists of several steps. The first one
replaces the original query and creates the tentacle
functions. In the second phase the should be registered
at the different sites.

The key observation is that whenever we encouter a mat.pack,
there is a need to bring information together for inspection.
Therefore, we recursively break a plan by looking for the
pack instructions and collect all dependent instructions.
The original block is trimmed as far as needed.
@c
static int
OCTinitcode(Client cntxt, MalBlkPtr mb){
	InstrPtr p;
	(void) cntxt;
	p = newStmt(mb, remoteRef,connectRef);
    p= pushStr(mb,p, GDKgetenv("gdk_dbname"));
    p= pushStr(mb,p,"monetdb");
    p= pushStr(mb,p,"monetdb");
	return getArg(p,0);
}

static void
OCTexitcode(MalBlkPtr mb, int conn,int varid){
	InstrPtr p;
	p = newStmt(mb, remoteRef,disconnectRef);
    pushArgument(mb,p,conn);
	p= newAssignment(mb);
	getArg(p,0) = getArg(getInstrPtr(mb,0), 0);
	pushArgument(mb,p,varid);
	p->barrier= RETURNsymbol;
	pushEndInstruction(mb);
	newStmt(mb,optimizerRef,putName("aliases",7));
	newStmt(mb,optimizerRef,putName("deadcode",8));
}

static MalBlkPtr 
OPTtentacle(Client cntxt,  MalBlkPtr mb, InstrPtr pci, int start, int idx, int v2){
	MalBlkPtr tm= NULL;
	InstrPtr p, q,anchor=NULL;
	int varid= pci->argv[idx],i,j,top=0, fnd,tbd;
	char buf[BUFSIZ];
	InstrPtr *list = (InstrPtr*) GDKzalloc(sizeof(InstrPtr) * mb->ssize);
	char *needed= (char*) GDKzalloc(mb->vtop);
	str name= NULL, name2= NULL;
	Symbol s;
	ValRecord cst;
	int pieces=pci->argc-1, part=idx, conn=0;

	if (list == NULL || needed == NULL){
		if ( list ) GDKfree(list);
		if ( needed) GDKfree(needed);
		return 0;
	}
#ifdef DEBUG_OPT_OCTOPUS
	stream_printf(cntxt->fdout,"#create tentacle for %d\n",varid);
	printInstruction(cntxt->fdout,mb,0,pci,0);
#else
	(void) cntxt;
#endif

	/* locate the last assignment for varid */
	fnd = -1;
	for (i = start; i > 0; i--){
		p= getInstrPtr(mb,i);
		for (j=0; j<p->retc; j++)
			if ( getArg(p,j) == varid){
				fnd= j;
				goto foundit;
			}
	}
	assert(fnd >= 0);
foundit:
	snprintf(buf,BUFSIZ,"tentacle_%s_%d", 
		getFunctionId(getInstrPtr(mb,0)),varid);
	name =  putName(buf,strlen(buf));
	snprintf(buf,BUFSIZ,"exec_%s", 
		getFunctionId(getInstrPtr(mb,0)));
	name2 =  putName(buf,strlen(buf));
	q= newFcnCall(mb,octopusRef, name2);
	setArgType(mb,q,0,getVarType(mb,varid));
	cst.vtype = TYPE_str;
	cst.val.sval= GDKstrdup("tbd");
	cst.len= (int) strlen(cst.val.sval);
	tbd = defConstant(mb, TYPE_str, &cst);
	q= pushArgument(mb,q,tbd);
	q= pushStr(mb,q,name);
	q= pushArgument(mb,q,v2);
	needed[varid]= 1;
	anchor = q;
	getArg(pci,idx) = getArg(q,0);
#ifdef DEBUG_OPT_OCTOPUS
if (name == 0){
		stream_printf(cntxt->fdout,"OCTOPUS ASSERT var %s\n", getVarName(mb,varid));
		printFunction(cntxt->fdout,mb,0,0);
	}
#endif
	assert( name);

	/* find the instructions needed */
	for (; i > 0; i--){
		p= getInstrPtr(mb,i);
		fnd = 0;
		if ( p->barrier){
			for (j = 0; j < p->retc; j++)
				needed[getArg(p,j)]= 1;
			fnd = 1;
		}
		for (j = 0; j < p->retc; j++)
			fnd += needed[getArg(p,j)];
		if ( fnd) {
			for (j = p->retc; j < p->argc; j++)
				needed[getArg(p,j)]= 1;
			list[top++] = p;
		}
	}
	/* we need the arguments as well */
	p= getInstrPtr(mb,0);
	for(i=p->retc; i<p->argc; i++)
	if (needed[getArg(p,i)])
		anchor= pushArgument(mb,anchor,getArg(p,i));
	/* create the tentacle procedure */
	s= (Symbol) GDKzalloc(sizeof(SymRecord));
	s->name= name;
	s->kind=FUNCTIONsymbol;
	s->def= tm= copyMalBlk(mb);	/* get the symbol table for free */

	/* recast the signature */
	p= getInstrPtr(tm,0);
	setModuleId(p,octopusRef);
	setFunctionId(p,name);
	tm->var[0]->name= name;
	setArgType(tm,p,0,getVarType(tm,varid));
	p->argc=p->retc=1;
	for(j=anchor->retc+2; j<anchor->argc; j++)
		p= pushArgument(tm,p,getArg(anchor,j));

	tm->stop =1;
	conn= OCTinitcode(cntxt, tm);
	for (top--; top >= 0; top--){
		p = copyInstruction(list[top]);
		if (getModuleId(p) == sqlRef &&
			( getFunctionId(p) == bindRef ||
			  getFunctionId(p) == binddbatRef ||
			  getFunctionId(p) == bindidxRef)){
			setModuleId(p, octopusRef);
			p= setArgument(tm,p,1,conn);
			p = pushArgument(tm, p, getArg(getInstrPtr(tm,0),1));
			p= pushInt(tm,p,pieces);
			p= pushInt(tm,p,part);
			/* adjust the corresponding partition */
			q = getInstrPtr(tm, tm->stop-1);
			if ( getFunctionId(q) == partitionRef){
				getArg(q,0)= getArg(q,idx-1); /* indx comes from packref */
				getArg(q,1)= getArg(q,q->retc);
				clrFunction(q);
				q->retc=1;
				q->argc=2;
				q->token = ASSIGNsymbol;
			}
		} 
		pushInstruction(tm, p);
	}

	OCTexitcode(tm, conn,varid);

	insertSymbol(findModule(cntxt->nspace,octopusRef),s);
#ifdef DEBUG_OPT_OCTOPUS
	printFunction(cntxt->fdout,tm,0,LIST_MAL_STMT);
#endif
	GDKfree(list);
	GDKfree(needed);
	return tm;
}

static int
OPToctopusImplementation(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	InstrPtr q, p, *old;
	int last=0, i, j, limit, actions=0;
	int tn=0, maxtn= MAL_MAXCLIENTS -2;	/* should be relaxed */
	MalBlkPtr *tentacle= (MalBlkPtr *) GDKmalloc(sizeof(MalBlkPtr) * maxtn),sm = NULL;
	Symbol s2;
	int target=0;
	int version,v2;
	int k,l;
	char buf[BUFSIZ];


	if ( tentacle == NULL)
		return 0;
#ifdef DEBUG_OPT_OCTOPUS
	stream_printf(cntxt->fdout, "#Octopus optimizer started\n");
#else
	(void) cntxt;
#endif
	(void) stk;
	(void) pci;
@-
All octopus tentacle code is collected in a separate module
to ease future distribution and scheduling.
The optimizer works by looking only to the mat.pack statement.

The experiment is to only look at the last pack statement,
as this creates the largest subplans and avoids an explosion
in threads.
A recursive call op the optimizer can be used to create more tentacles, which,
when scheduled correctly, would not lead to duplicate work.
@c
	(void) fixModule(cntxt->nspace,octopusRef);

	limit = mb->stop;
	old = mb->stmt;

	newMalBlkStmt(mb, mb->ssize);
	pushInstruction(mb, old[0]);

	for (i = 1; i < limit; i++){
		p = old[i];
		if( (getModuleId(p)== matRef && getFunctionId(p)== packRef) )
			target = i;
	}

	for (i = 1; i < limit; i++) {
		p = old[i];
		if( (getModuleId(p)== matRef && getFunctionId(p)== packRef) && 
			i == target && tn + p->argc - p->retc < maxtn){
			InstrPtr qq;
			int conn,dbvar,qvar;

			/* prepare the exec_ procedure */
			snprintf(buf,BUFSIZ,"exec_%s", getFunctionId(getInstrPtr(mb,0)));
			s2= newFunction(octopusRef, putName(buf,strlen(buf)), FUNCTIONsymbol);
			sm= s2->def;
			q= getInstrPtr(sm,0);
			setArgType(sm,q,0,getArgType(mb,p,0));
			dbvar= newVariable(sm,GDKstrdup("dbname"),TYPE_str);
			qvar = newVariable(sm,GDKstrdup("query"),TYPE_str);
			version= newVariable(sm,GDKstrdup("version"),TYPE_int);
			q= pushArgument(sm,q,dbvar);
			q= pushArgument(sm,q,qvar);
			q= pushArgument(sm,q,version);

			/* create the tentacle, modifying the current plan */
			/* initialize the result variables */
			q= newAssignment(mb);
			getArg(q,0)= getArg(p,0);
			q= pushNil(mb,q, getVarType(mb, getArg(p,0)));

			/* barrier (go,version):= scheduler.octopus(timeout); */
			qq= q= newStmt(mb,schedulerRef,octopusRef);
			setArgType(mb,q,0, TYPE_bit);
			v2= newVariable(mb,GDKstrdup("version"),TYPE_int);
			pushArgument(mb,q, v2);
			q->retc = 2;
			q= pushInt(mb,q,10);
			q->barrier = BARRIERsymbol;

			for ( j= p->retc; j<p->argc; j++)
				tentacle[tn++] =  OPTtentacle(cntxt,mb,p,mb->stop-1,j,v2);

			pushInstruction(mb,p);

			/* exit c; */
			q= newAssignment(mb);
			q->barrier= EXITsymbol;
			getArg(q,0)= getArg(qq,0);
			getArg(q,1)= v2;
			q->retc=2;
			q->argc=2;

			/* now finalize the exec operation */
			q = newStmt(sm, remoteRef,connectRef);
			conn= getArg(q,0);
			q = pushArgument(sm, q, dbvar);
			q= pushStr(sm,q,"monetdb");
			q= pushStr(sm,q,"monetdb");

			/* v:= remote.put(version) */
			q= newFcnCall(sm,remoteRef,putRef);
			q= pushArgument(sm,q,conn);
			q= pushArgument(sm,q,version);
			version= getArg(q,0);

			/* get addition arguments needed in a tentacle */
			p= getInstrPtr(tentacle[0],0);
			for (j=p->retc+1; j< p->argc; j++){
				snprintf(buf,BUFSIZ,"a_%d",j);
				k= newVariable(sm, GDKstrdup(buf),getArgType(mb,p,j));
				pushArgument(sm,getInstrPtr(sm,0),k);
				l= newTmpVariable(sm,getArgType(mb,p,j));
				q= newFcnCall(sm,remoteRef,putRef);
				getArg(q,0)= l;
				pushArgument(sm,q, getArg(getInstrPtr(sm,0),1));
				pushArgument(sm,q,k);
			}

			/* k:= remote.exec(conn,octopus,qry,version....) */
			q= newFcnCall(sm,remoteRef,execRef);
			k= getArg(q,0);
			q= pushArgument(sm,q,conn);
			q= pushStr(sm,q,octopusRef);
			q= pushArgument(sm,q,qvar);
			q= pushArgument(sm,q,version);

			/* l:=remote.get(conn,k) */
			q= newFcnCall(sm,remoteRef,getRef);
			q= pushArgument(sm,q,conn);
			q= pushArgument(sm,q,k);
			l= getArg(q,0);
			setVarType(sm,l, getArgType(sm,getInstrPtr(sm,0),0));
			setVarUDFtype(sm,l);

			/* return exec_qry:= l; */
			q= newAssignment(sm);
			q->barrier= RETURNsymbol;
			getArg(q,0)= getArg(getInstrPtr(sm,0),0);
			pushArgument(sm,q,l);

			pushEndInstruction(sm);
			chkProgram(cntxt->nspace,sm);
			insertSymbol(findModule(cntxt->nspace,octopusRef),s2);
#ifdef DEBUG_OPT_OCTOPUS
			stream_printf(cntxt->fdout, "#exec_qry\n");
			printFunction(cntxt->fdout,sm,0,LIST_MAL_STMT);
#endif
			actions++;
			continue;
		} 
		pushInstruction(mb,p);
		if (p->token == ENDsymbol){
			/* the octopus leaves a lot of deadcode, which we don't
			   want to optimize */
			(void) newStmt(mb,optimizerRef,putName("deadcode",8));
			last= i;
		}
	}
	
@-
The tentacle code should be optimized by the remaining optimizers.
@c
	for (j=last+1; j< limit; j++)
	for (i=0; i<tn; i++)
		pushInstruction(tentacle[i], copyInstruction(old[j]));
	for (i=0; i<tn; i++){
		chkProgram(cntxt->nspace, tentacle[i]);
		optimizeMALBlock(cntxt,tentacle[i]);
#ifdef DEBUG_OPT_OCTOPUS
		stream_printf(cntxt->fdout, "NEXT octopus tentacle check\n");
		printFunction(cntxt->fdout, tentacle[i], 0, LIST_MAL_STMT);
#endif
		if ( tentacle[i]->errors ) {
			showException(MAL,"optimizer.octopus","failed to compile");
			mb->errors++;
		}
	}
#ifdef DEBUG_OPT_OCTOPUS
	if (actions) {
		chkProgram(cntxt->nspace, mb);
		optimizeMALBlock(cntxt,mb);
		stream_printf(cntxt->fdout, "DONE octopus \n");
		printFunction(cntxt->fdout, mb, 0, LIST_MAL_STMT);
		printFunction(cntxt->fdout, sm, 0, LIST_MAL_STMT);
		printFunction(cntxt->fdout, tentacle[0], 0, LIST_MAL_STMT);
	}
#endif
	GDKfree(old);
	GDKfree(tentacle);
	return actions;
}
@include optimizerWrapper.mx
@h
@:exportOptimizer(octopus)@
#endif
@c
#include "opt_statistics.h"
@:wrapOptimizer(octopus,OPT_CHECK_ALL)@
@}
