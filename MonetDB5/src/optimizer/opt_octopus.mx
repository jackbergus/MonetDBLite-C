@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
@' Copyright August 2008-2010 MonetDB B.V.
@' All Rights Reserved.

@f opt_octopus
@a M. Kersten
@- Map-reduce processing
Query execution can be improved significantly using distributed processing.
Traditionally, this encompasses fragmentation and allocation of the base
tables over multiple sites and query plans that include on the fly transport
of intermediate results.

Breaking the database into pieces itself is a well-studied area.
Most approaches consider the workload and search for a good split
of the base tables, such that the workload performance improves.

In the Octopus we focus on SQL for map-reduce processing.
The first approach is to capitalize upon the metosis and
mergetable optimizers. They break the table into pieces
based on the head and propagate the effect through the plan.
Breaking the table depends on the number of sites to play with,
which can be obtained dynamically from the merovingian.

The octopus untangles the resulting plan into a controlling function
and a plan for each tentacle.
The octopus is to be called after the mergetable optimizer.

A snippet of an octopus plan with two tentacles is shown below 

@verbatim
function octopus.exec_qry(srv:str,fcn:str, ver:int):bat[:oid,:int];
	conn:= remote.connect(srv,"monetdb","monetdb");
	v:= remote.put(conn,ver);
	r:= remote.exec(conn,"octopus",fcn,v);
	b:bat[:oid,:int]:= remote.get(conn,r);
catch REMOTEexception;
	octopus.reschedule(srv);
exit REMOTEexception;
	return b;
end exec_qry;
function octopus.leg0(version:int):bat[:oid,:int];
	conn:= remote.connect("demo","monetdb","monetdb");
    _54:bat[:oid,:int] := octopus.bind(conn,"sys","squida","bid",0,0@0,25@0,version);
    _64:bat[:oid,:int] := octopus.bind(conn,"sys","squida","bid",2,0@0,25@0,version);
    _72 := algebra.kdifference(_54,_64);
    _78 := algebra.kunion(_72,_64);
    _13:bat[:oid,:oid]  := octopus.bind_dbat(conn,"sys","squida",1,version);
    _14 := bat.reverse(_13);
    _85 := algebra.kdifference(_78,_14);
    return leg0:= _85;
end octopus.leg0;
function octopus.leg1( version:int):bat[:oid,:int];
	conn:= remote.connect("demo","monetdb","monetdb");
    _56:bat[:oid,:int] := octopus.bind(conn,"sys","squida","bid",0,version,2,1);
    _65:bat[:oid,:int] := octopus.bind(conn,"sys","squida","bid",2,version,2,1);
    _72 := algebra.kdifference(_56,_65);
    _78 := algebra.kunion(_72,_65);
    _13:bat[:oid,:oid]  := octopus.bind_dbat(conn,"sys","squida",1,version);
    _14 := bat.reverse(_13);
    _85 := algebra.kdifference(_78,_14);
    return leg1= _85;
end octopus.leg1;

function user.qry():void;
barrier (_100,version:int):= scheduler.octopus(10);
    _87 := octopus.exec_qry("tbd","leg0",version);
    _88 := octopus.exec_qry("tbd","leg1",version);
exit (_100,version);
    _15 := mat.pack(_87,_88);
    _16 := sql.resultSet(1,1,_15);
    sql.rsColumn(_16,"sys.squida","bid","int",32,0,_15);
    _21 := io.stdout();
    sql.exportResult(_21,_16);
end qry;
@end verbatim

[versioning]
The argument to the tentacle is the expected version of the database
to be used and optional arguments for the query.

[partition access]
For a tentacle to work it needs access to its storage layer.
It is encapsulated in the operation octopus.bind(Conn,S,T,C,V,P,I),
which performs an upcall to the octopus Conn to deliver 
the Ith piece of the column S.T.C partitioned into P pieces 
matching version V.

Ideally, the interaction with the head is restricted
to calling for a handle to access the partition from
its source directly. 
In a shared disk setup, we merely ensure that a
possibly cached version is not out of date.
The last resort is to deliver the partition by the
octopus using a remote BAT copy.
Doing so would effectively implement
a kind of distributed disk system. The current state of
affairs allows for a track where even a low level 
ftp- call would suffice to obtain the complete BAT
from anywhere, or we can provide a NAS functionality
over the database store that delivers the partitions
of interest.

The octopus upcalls for delivering the partitions should
be encapsulated into a function to shield all possible
remote access operations. It is a function registered
by the SQL front-end.

[recycling]
The version argument passed during the tentacle call
is used to enforce synchronisation of the recycler caches
between the octopus and its tentacles.
If the version does not change between calls, the
recylcer will simply step over the bind() calls,
reusing with it already have instead.
If for local resource management decisions the cache
is cleared, then it will automatically trigger a
re-execution of the bind().

[Naming]
The tentacles received from the octopus should be ensured
not to clash with those already known. Therefore, we simply
tag them by orginating site.

[Caveats]
Updates on the persistent tables are not handled yet. They should
lead to an upcall to the head for inclusion. Any update invalidates
the request to distributed processing.
In the same line, multi-statement SQL transactions and
updates to global variables are ignored. 

Global variables are tricky, because they are part of the
session context. To make it work, we need to be able to perform
an upcall to that context (=dangerous).
The solution is that any variable context should be
passed through a relation.
@{
@mal
module octopus; 
pattern optimizer.octopus():str
address OPToctopus;
pattern optimizer.octopus(mod:str, fcn:str):str
address OPToctopus
comment "Map-execute-reduce parallelism optimizer";

pattern legAdvice(mod:str, fcn:str):int
address OPTlegAdvice
comment "Derive the number of legs to be used for query function";
@h
#ifndef _OPT_OCTOPUS_
#define _OPT_OCTOPUS_
#include "opt_prelude.h"
#include "opt_support.h"

/*#define DEBUG_OPT_OCTOPUS         show partial result */

opt_export str OPTlegAdvice(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
opt_export int OPTlegAdviceInternal(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
@c
#include "mal_config.h"
#include "opt_octopus.h"
#include "opt_deadcode.h"
#include "mal_interpreter.h"	/* for showErrors() */
#include "mal_builder.h"
#include "mal_sabaoth.h"
@-
The algorithm consists of several steps. The first one
replaces the original query and creates the tentacle
functions. In the second phase the should be registered
at the different sites.

The key observation is that whenever we encouter a mat.pack,
there is a need to bring information together for inspection.
Therefore, we recursively break a plan by looking for the
pack instructions and collect all dependent instructions.
The original block is trimmed as far as needed.
@c
static lng octopusSeq = 0;
sht bidStrategy = 1;

static int
OCTinitcode(Client cntxt, MalBlkPtr mb){
	InstrPtr p;
	str s;
	str l = NULL;

	(void) cntxt;

	p = newStmt(mb, remoteRef,connectRef);
	s = GDKgetenv("merovingian_uri");
	if (s == NULL) /* aparently not under Merovingian control, fall back to local only */
		SABAOTHgetLocalConnection(&l);
	p= pushStr(mb,p, s == NULL ? l : s);
	p= pushStr(mb,p,"monetdb");
	p= pushStr(mb,p,"monetdb");
	p= pushStr(mb,p,"msql");
	if (l)
		GDKfree(l);
	return getArg(p,0);
}

@-
Be prepared to catch errors from the remote site.
You should catch them, otherwise the session is not closed.
Beware, exceptions should be catched and thrown after the
connection has been closed.
@c
static void
OCTexitcode(MalBlkPtr mb, int conn,int varid){
	InstrPtr p;

	newCatchStmt(mb, "ANYexception");
	p = newStmt(mb, remoteRef,disconnectRef);
    pushArgument(mb,p,conn);
	newRaiseStmt(mb,"ANYexception");
	newExitStmt(mb, "ANYexception");

	p = newStmt(mb, remoteRef,disconnectRef);
    pushArgument(mb,p,conn);
	p= newAssignment(mb);
	getArg(p,0) = getArg(getInstrPtr(mb,0), 0);
	pushArgument(mb,p,varid);
	p->barrier= RETURNsymbol;
	pushEndInstruction(mb);
	newStmt(mb,optimizerRef,putName("aliases",7));
	newStmt(mb,optimizerRef,putName("deadcode",8));
}

static MalBlkPtr 
OPTtentacle(Client cntxt,  MalBlkPtr mb, InstrPtr *old, InstrPtr pci, int start, int idx, int v2,
int tcnt, int *wnm, int *tnm, int **sch){
	MalBlkPtr tm = NULL;
	InstrPtr p = NULL, q, sig = old[0];
	int varid= pci->argv[idx],i,j,top=0, fnd, k;
	char buf[BUFSIZ];
	InstrPtr *list = (InstrPtr*) GDKzalloc(sizeof(InstrPtr) * mb->ssize);
	char *needed= (char*) GDKzalloc(mb->vtop);
	int *alias= (int*) GDKzalloc(mb->vtop * sizeof(int));
	str name= NULL, name2= NULL;
	Symbol s;
/*	ValRecord cst; */
	int conn=0, tidx=idx-1;

	/* check if the head is properly administered for Octopus */
	SABAOTHgetLocalConnection(&name);

	if ( name == NULL || *name == 0 || list == NULL || needed == NULL){
		if ( list ) GDKfree(list);
		if ( needed) GDKfree(needed);
		if ( alias) GDKfree(alias);
		if ( name) GDKfree(name);
		return 0;
	}

#ifdef DEBUG_OPT_OCTOPUS
	stream_printf(cntxt->fdout,"#create tentacle for %d %d %d\n",start,idx,varid);
	printInstruction(cntxt->fdout,mb,0,pci,0);
#else
	(void) cntxt;
#endif

	/* locate the last assignment for varid */
	fnd = -1;
	for (i = start; i > 0; i--){
/*		p= getInstrPtr(mb,i); */
		p = old[i];
		for (j=0; j<p->retc; j++)
			if ( getArg(p,j) == varid){
				fnd= j;
				goto foundit;
			}
	}
foundit:
	if ( p == NULL) {
		if ( list ) GDKfree(list);
		if ( needed) GDKfree(needed);
		if ( alias) GDKfree(alias);
		return 0;	/* bail out, internal error */
	}

	for (j = 0; j < p->argc; j++)
		needed[getArg(p,j)]= 1;
@-
Find the instructions needed. Beware pack operations
already have been handled and produce their target.
@c
	for (; i > 0; i--){
/*		p= getInstrPtr(mb,i); */
		p = old[i];
		fnd = 0;
		if ( p->barrier ){
			for (j = 0; j < p->argc; j++)
				needed[getArg(p,j)]= 1;
			fnd = 1;
		}
		for (j = 0; j < p->retc; j++)
			fnd += needed[getArg(p,j)];
		if ( fnd) {
			for (j = 0; j < p->argc; j++)
				needed[getArg(p,j)]= 1;
			list[top++] = p;
		}
	}

/*	snprintf(buf,BUFSIZ,"tentacle_%s_%d", 
		getFunctionId(getInstrPtr(mb,0)),varid); 

	snprintf(buf,BUFSIZ,"tentacle_"LLFMT"_%d", mb->octid,varid); */
	name = (str) getVarValue(mb, tnm[tidx]);
	putName(name,strlen(name));

	snprintf(buf,BUFSIZ,"exec_"LLFMT, mb->octid);
	name2 =  putName(buf,strlen(buf));

/*	cst.vtype = TYPE_str;
	snprintf(buf,BUFSIZ,"tbd_%d",varid); 
	cst.val.sval= GDKstrdup(buf);
	cst.len= (int) strlen(cst.val.sval);
	tbd = defConstant(mb, TYPE_str, &cst); */

/* generate tentacle CALLS: every tentacle is called once on each worker: tcnt times */
	for ( k = 0; k < tcnt; k++ ){
		q= newStmt2(mb,octopusRef, name2);
		setArgType(mb,q,0,getVarType(mb,varid));
		setVarUDFtype(mb,getArg(q,0));
		q= pushArgument(mb,q,sch[k][tidx]);
		q= pushArgument(mb,q,wnm[k]);
		q= pushArgument(mb,q,tnm[tidx]);
		q= pushArgument(mb,q,v2);
		needed[varid]= 1;
		for (j= sig->retc; j <  sig->argc; j++)
			q = pushArgument(mb,q,getArg(sig, j));
	}
	
	/* create the TENTACLE procedure */
	s= newFunction(octopusRef,name,FUNCTIONsymbol);
	tm= s->def;
	tm->keephistory= mb->keephistory;
	p= getInstrPtr(tm,0);
	for(i=q->retc+3; i<q->argc; i++){
		alias[getArg(q,i)] = cloneVariable(tm,mb,getArg(q,i));
		p= pushArgument(tm,p, alias[getArg(q,i)]);
	}
	setVarType(tm,getArg(p,0),getVarType(mb,varid));

	conn= OCTinitcode(cntxt, tm);
	for (top--; top >= 0; top--){
		p = copyInstruction(list[top]);
		for (i= 0; i< p->argc; i++){
			int a= getArg(list[top],i);
			if (alias[a]==0) 
				alias[a] = cloneVariable(tm,mb,a);
			getArg(p,i) = alias[a];
		}
		if (getModuleId(p) == sqlRef &&
			strcmp(getFunctionId(p), "getVariable") == 0
		){
			getModuleId(p) = octopusRef;
			p= setArgument(tm,p,1,conn);
			setVarUDFtype(tm,getArg(p,0));
		} else
		if (getModuleId(p) == sqlRef &&
			( getFunctionId(p) == bindRef ||
			  getFunctionId(p) == bindidxRef)){
			setModuleId(p, octopusRef);
			setVarUDFtype(tm,getArg(p,0));
			setArgType(tm,p,0, getArgType(mb,list[top],0));
			p= setArgument(tm,p,1,conn);
			p = pushArgument(tm, p, getArg(getInstrPtr(tm,0),1));
		} 
		if (getModuleId(p) == sqlRef && getFunctionId(p) == binddbatRef ){
			setModuleId(p, octopusRef);
			setVarUDFtype(tm,getArg(p,0));
			setArgType(tm,p,0, getArgType(mb,list[top],0));
			p= setArgument(tm,p,1,conn);
			p = pushArgument(tm, p, getArg(getInstrPtr(tm,0),1));
		} 
		pushInstruction(tm, p);
	}

	varid = alias[varid];
	OCTexitcode(tm, conn,varid);
	clrDeclarations(tm);

#ifdef DEBUG_OPT_OCTOPUS
	stream_printf(cntxt->fdout, "TENTACLE octopus \n");
	chkDeclarations(tm);
	printFunction(cntxt->fdout, tm, 0, LIST_MAL_STMT);
#endif
	insertSymbol(findModule(cntxt->nspace,octopusRef),s);
	GDKfree(list);
	GDKfree(alias);
	GDKfree(needed);
	return tm;
}

static int
OPToctopusImplementation(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	InstrPtr q, p, sig, *old, r;
	int last=0, i, j, limit, actions=0, arg[1024];
	int tn=0, maxtn= MAL_MAXCLIENTS -2;	/* should be relaxed */
	MalBlkPtr *tentacle= (MalBlkPtr *) GDKmalloc(sizeof(MalBlkPtr) * maxtn),sm = NULL, tmb;
	Symbol s2;
	int target= -1, update=0, autocommit=0;
	int version,v2;
	int k,l, rexit, bs, tcnt;
	char buf[BUFSIZ];
	ValRecord cst;
	int *wnm,*tnm;	/* array indices to var table where workers and tentacle names are stored */
	int **bid;		/* array index to bids variables */
	int **sch;		/* array index to schedule variables */
	static str registerRef = 0;

	if ( tentacle == NULL)
		return 0;
#ifdef DEBUG_OPT_OCTOPUS
	stream_printf(cntxt->fdout, "#Octopus optimizer called\n");
	printFunction(cntxt->fdout, mb, 0, LIST_MAL_STMT);
#else
	(void) cntxt;
#endif
	(void) stk;
@-
All octopus tentacle code is collected in a separate module
to ease future distribution and scheduling.
The optimizer works by looking only to the mat.pack statement.

The experiment is to only look at the last pack statement,
as this creates the largest subplans and avoids an explosion
in threads.
A recursive call op the optimizer can be used to create more tentacles, which,
when scheduled correctly, would not lead to duplicate work.
@c
	(void) fixModule(cntxt->nspace,octopusRef);

	if (registerRef == 0)
		registerRef = putName("register",8);
	limit = mb->stop;
	old = mb->stmt;

	autocommit = varGetProp(mb, getArg(old[0],0), PropertyIndex("autoCommit")) != NULL;
	for (i = 1; i < limit; i++){
		p = old[i];
		
		if( getModuleId(p)== matRef && getFunctionId(p)== packRef)
			target = i;
		if( getModuleId(p)== sqlRef ){
			update |= getFunctionId(p)== appendRef || getFunctionId(p)== deleteRef;
			update |= strcmp(getFunctionId(p),"getVariable")==0;
			update |= strcmp(getFunctionId(p),"setVariable")==0;
		}
	}
	/* we do not  support yet update operations in the octopus */
	if ( target == -1 || update || autocommit==0 ) {
		GDKfree(tentacle);
		return 0;
	}

	if ( newMalBlkStmt(mb, mb->ssize) < 0){
		GDKfree(tentacle);
		return 0;
	}
	pushInstruction(mb, old[0]);
	mb->octid = octopusSeq++;

	sig= old[0];
	for (i = 1; i < limit; i++) {
		p = old[i];
		if ( p == pci){
			freeInstruction(pci);
			old[i]= 0;
			continue;
		}
		if( (getModuleId(p)== matRef && getFunctionId(p)== packRef) && 
			i == target && tn + p->argc - p->retc < maxtn){
			InstrPtr qq, mp;
			int conn,dbvar,qvar,schvar;

			tcnt = p->argc - p->retc;
			/* prepare the exec_ procedure */
			snprintf(buf,BUFSIZ,"exec_"LLFMT, mb->octid);
			s2= newFunction(octopusRef, putName(buf,strlen(buf)), FUNCTIONsymbol);
			sm= s2->def;
			q= getInstrPtr(sm,0);
			setArgType(sm,q,0,getArgType(mb,p,1));
			schvar = newVariable(sm,GDKstrdup("scheduled"),TYPE_bte);
			dbvar= newVariable(sm,GDKstrdup("dbname"),TYPE_str);
			qvar = newVariable(sm,GDKstrdup("query"),TYPE_str);
			version= newVariable(sm,GDKstrdup("version"),TYPE_int);
			q= pushArgument(sm,q,schvar);
			q= pushArgument(sm,q,dbvar);
			q= pushArgument(sm,q,qvar);
			q= pushArgument(sm,q,version);
			/* just add all arguments for the moment */
			for (j=sig->retc; j < sig->argc; j++){
				int aj= cloneVariable(sm,mb,getArg(sig,j));
				q = pushArgument(sm,q,aj);
			}

			/* create the tentacle, modifying the current plan */
			/* initialize the result variables */
			q= newAssignment(mb);
			getArg(q,0)= getArg(p,0);
			q= pushNil(mb,q, getVarType(mb, getArg(p,0)));

			/* Generate register block */
			r = newStmt2(mb,schedulerRef,registerRef);
			r->barrier = BARRIERsymbol;
			setArgType(mb,r,0, TYPE_bit);
			rexit = getArg(r,0);

			/* generate string constants holding worker and tentacle names */
			cst.vtype = TYPE_str;
			
			wnm = (int*) GDKzalloc(sizeof(int) * tcnt);
			tnm = (int*) GDKzalloc(sizeof(int) * tcnt);
			bid = (int**) GDKzalloc(sizeof(int*) * tcnt);
			sch = (int**) GDKzalloc(sizeof(int*) * tcnt);
			for ( j= 0; j < tcnt; j++){
				snprintf(buf,BUFSIZ,"worker_%d",j); 
				cst.val.sval= GDKstrdup(buf);
				cst.len= (int) strlen(cst.val.sval);
				wnm[j] = defConstant(mb, TYPE_str, &cst);
	
				snprintf(buf,BUFSIZ,"tentacle_"LLFMT"_%d", mb->octid,p->argv[j]); 
				cst.val.sval= GDKstrdup(buf);
				cst.len= (int) strlen(cst.val.sval);
				tnm[j] = defConstant(mb, TYPE_str, &cst);

				bid[j] = (int*) GDKzalloc(sizeof(int) * tcnt);
				sch[j] = (int*) GDKzalloc(sizeof(int) * tcnt);
			}
			
			for ( j= 0; j < tcnt; j++)
				for ( k= 0; k < tcnt; k++){
					r = newFcnCall(mb,octopusRef, registerRef);
					r = pushArgument(mb,r,wnm[k]);
					r = pushArgument(mb,r,tnm[j]);
			}

			r = newAssignment(mb);
			r->barrier= EXITsymbol;
			getArg(r,0) = rexit;

			/* Generate bidding block */
			for ( j = 0; j < tcnt; j++)
				for ( k = 0; k < tcnt; k++){
					r = newAssignment(mb);
					setArgType(mb,r,0,TYPE_lng);
					pushLng(mb,r,(lng)-1);
					bid[k][j] = getArg(r,0);
			}
			r = newStmt2(mb,languageRef,dataflowRef);
			r->barrier = BARRIERsymbol;
			setArgType(mb,r,0, TYPE_int);
			rexit = getArg(r,0);

			cst.vtype = TYPE_sht;
			cst.val.shval = bidStrategy;
			bs = defConstant(mb, TYPE_sht, &cst);
			for ( j = 0; j < tcnt; j++)
				for ( k = 0; k < tcnt; k++){
					r = newStmt2(mb,octopusRef, putName("getBid",6));
					r = pushArgument(mb,r,wnm[k]);
					r = pushArgument(mb,r,tnm[j]);
					r = pushArgument(mb,r,bs);
		/*			setArgType(mb,r,0,TYPE_lng);*/
					setVarUDFtype(mb,getArg(r,0));
					getArg(r,0) = bid[k][j];
			}

			r = newAssignment(mb);
			r->barrier= EXITsymbol;
			getArg(r,0) = rexit;

			/* Generate call to bid scheduling */
			r = newStmt2(mb, schedulerRef, putName("makeSchedule",12));
			setArgType(mb,r,0, TYPE_bte);
			setVarUDFtype(mb,getArg(r,0));
			for ( k = 0; k < tcnt; k++)
				for ( j= 0; j < tcnt; j++){
					sch[k][j] = newTmpVariable(mb, TYPE_bte);
					r = pushArgument(mb,r,sch[k][j]);
			}
			r->retc = tcnt * tcnt +1;
			r = pushInt(mb,r,tcnt);
			for ( k = 0; k < tcnt; k++)
				for ( j= 0; j < tcnt; j++)
					r = pushArgument(mb,r,bid[k][j]);

			/* Execution block */

			/* barrier (go,version):= scheduler.octopus(timeout); */
			qq= q= newStmt(mb,schedulerRef,octopusRef);
			setArgType(mb,q,0, TYPE_bit);
			v2= newVariable(mb,GDKstrdup("version"),TYPE_int);
			pushArgument(mb,q, v2);
			q->retc = 2;
			q= pushInt(mb,q,10);
			q->barrier = BARRIERsymbol;

			for ( j= p->retc; j<p->argc; j++)
				tentacle[tn++] = OPTtentacle(cntxt,mb,old,p,i-1,j,v2,tcnt,wnm,tnm,sch);

/*			pushInstruction(mb,p); */

			/* create new mat.pack() instruction */
			mp = newFcnCall(mb,matRef,packRef);
			getArg(mp,0) = getArg(p,0);
			for ( k = getPC(mb,qq) + 1; k < getPC(mb,mp); k++) {
				mp = pushArgument(mb,mp,getArg(getInstrPtr(mb,k),0)); 
			}
/*			freeInstruction(p); */

			/* exit c; */
			q= newAssignment(mb);
			q->barrier= EXITsymbol;
			getArg(q,0)= getArg(qq,0);
			getArg(q,1)= v2;
			q->retc=2;
			q->argc=2;

			/* now finalize the exec operation */

			/* exec_qry:= nil; */
			q = newAssignment(sm);
			getArg(q,0) = getArg(getInstrPtr(sm,0),0);
			q = pushNil(sm,q,getArgType(sm,q,0));
			
			/* barrier cond:= calc.>(i,0); */
			r = newFcnCall(sm,calcRef,putName(">",1));
			r->barrier = BARRIERsymbol;
			rexit = getArg(r,0);  
			setArgType(sm,r,0,TYPE_bit);
			r = pushArgument(sm,r,schvar);
			r = pushBte(sm,r,0);

			q = newStmt(sm, remoteRef,connectRef);
			conn= getArg(q,0);
			q = pushArgument(sm, q, dbvar);
			q= pushStr(sm,q,"monetdb");
			q= pushStr(sm,q,"monetdb");
			q= pushStr(sm,q,"msql");

			/* v:= remote.put(version) */
			q= newFcnCall(sm,remoteRef,putRef);
			q= pushArgument(sm,q,conn);
			q= pushArgument(sm,q,version);
			version= getArg(q,0);

			/* get addition arguments needed in a tentacle */
			assert(sig->argc <1024);
			for (j= sig->retc; j<  sig->argc; j++){
				l= newTmpVariable(sm,TYPE_str);
				q= newFcnCall(sm,remoteRef,putRef);
				arg[j]= getArg(q,0)= l;
				pushArgument(sm,q, conn);
				pushArgument(sm,q,findVariable(sm,getArgName(mb,sig,j)));
			}

			/* k:= remote.put(conn,kvar) */
			q= newFcnCall(sm,remoteRef,putRef);
			q= pushArgument(sm,q,conn);
			q= pushArgument(sm,q, getArg(getInstrPtr(sm,0),0));
			setVarUDFtype(sm,getArg(q,q->argc-1));
			k= getArg(q,0);

			/* k:= remote.exec(conn,octopus,qry,version....) */
			q= newFcnCall(sm,remoteRef,execRef);
			getArg(q,0)= k;
			q= pushArgument(sm,q,conn);
			q= pushStr(sm,q,octopusRef);
			q= pushArgument(sm,q,qvar);
			q= pushArgument(sm,q,version);
			/* deal with all arguments !*/
			for (j=sig->retc; j < sig->argc; j++)
				q = pushArgument(sm,q,arg[j]);


			/* l:=remote.get(conn,k) */
			q= newFcnCall(sm,remoteRef,getRef);
			q= pushArgument(sm,q,conn);
			q= pushArgument(sm,q,k);
			l= getArg(q,0);
			setVarType(sm,l, getArgType(sm,getInstrPtr(sm,0),0));
			setVarUDFtype(sm,l);

			/* catch and propagate errors */
			newCatchStmt(sm, "ANYexception");
			q = newStmt(sm, remoteRef,disconnectRef);
			pushArgument(sm,q,conn);
			newRaiseStmt(sm,"ANYexception");
			newExitStmt(sm, "ANYexception");

			/* close connection */
			q = newStmt(sm, remoteRef,disconnectRef);
			pushArgument(sm,q,conn);

			/* exec_qry:= l; */
			q= newAssignment(sm);
			getArg(q,0)= getArg(getInstrPtr(sm,0),0);
			pushArgument(sm,q,l);

			r = newAssignment(sm);
			r->barrier= EXITsymbol;
			getArg(r,0) = rexit;

			/* return exec_qry; */
			q= newAssignment(sm);
			q->barrier= RETURNsymbol;
			getArg(q,0)= getArg(getInstrPtr(sm,0),0);

			pushEndInstruction(sm);
			insertSymbol(findModule(cntxt->nspace,octopusRef),s2);
			clrDeclarations(sm);
			chkProgram(cntxt->nspace,sm);
			actions++;
			continue;
		} 
		pushInstruction(mb,p);
		if (p->token == ENDsymbol){
			last= i;
			break;
		}
	}
	
@-
Keep the remaining optimizers in the main program.
The tentacle code should be optimized by the remaining optimizers too.
@c
	for (j=last+1; j< limit; j++)
	if (old[j] )
		pushInstruction(mb, old[j]);

	for (j=last+1; j< limit; j++)
	for (i=0; i<tn; i++)
	if ( old[j] && old[j]->token != REMsymbol){
		tmb = tentacle[i];
		if ( getModuleId(old[j]) == optimizerRef && 
			getFunctionId(old[j]) == putName("reduce",6) ) {
				q = newStmt(tmb, optimizerRef,putName("recycle",7));
                q = pushStr(tmb, q, octopusRef);
                q = pushStr(tmb, q, getFunctionId(getInstrPtr(tmb,0)));
		}
		q = newStmt(tmb, getModuleId(old[j]),getFunctionId(old[j]));
		q = pushStr(tmb, q, octopusRef);
		q = pushStr(tmb, q, getFunctionId(getInstrPtr(tmb,0)));
	}
	for (i=0; i<tn; i++){
		clrDeclarations(tentacle[i]);
		chkProgram(cntxt->nspace,tentacle[i]);
/*		optimizeMALBlock(cntxt,tentacle[i]); */
		if ( tentacle[i]->errors ) 
			mb->errors++;
	}
		chkDeclarations(mb);
/*		chkProgram(cntxt->nspace,mb);  */
#ifdef DEBUG_OPT_OCTOPUS
	if (actions) {
		stream_printf(cntxt->fdout, "DONE octopus \n");
		printFunction(cntxt->fdout, mb, 0, LIST_MAL_STMT);
		printFunction(cntxt->fdout, sm, 0, LIST_MAL_STMT);
		for (i=0; i<tn; i++){
			chkDeclarations(tentacle[i]);
			chkFlow(tentacle[i]);
			printFunction(cntxt->fdout, tentacle[i], 0, LIST_MAL_STMT);
		}
	}
#endif
/*
	for (i=0; i<tn; i++)
		printFunction(GDKout, tentacle[i], 0, LIST_MAL_STMT);
*/
	GDKfree(wnm);
	GDKfree(tnm);
	for ( j= 0; j < tcnt; j++){
		GDKfree(bid[j]);
		GDKfree(sch[j]);
	}
	GDKfree(bid);
	GDKfree(sch);
	GDKfree(old);
	GDKfree(tentacle);
	return actions;
}
@include optimizerWrapper.mx
@h
@:exportOptimizer(octopus)@
#endif
@c
#include "opt_statistics.h"
@:wrapOptimizer(octopus,OPT_CHECK_ALL)@
@-
The remainder contains the octopus support routines.
The legAdvice function has to negotiate with merovingian to
determine the number of legs to use for a specific query plan.
This may involve the size and structure of the database tables 
accessed as well.
@c
int 
OPTlegAdviceInternal(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{

	(void) mb;
	(void) stk;
	(void) pci;
	return GDKnr_threads;
}

str 
OPTlegAdvice(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	int *ret = (int*) getArgReference(stk,pci,0);

	(void) cntxt;
	*ret = OPTlegAdviceInternal(mb,stk,pci);
	return MAL_SUCCEED;
}
@}
