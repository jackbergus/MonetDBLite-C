@/
The contents of this file are subject to the MonetDB Public License
Version 1.1 (the "License"); you may not use this file except in
compliance with the License. You may obtain a copy of the License at
http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html

Software distributed under the License is distributed on an "AS IS"
basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations
under the License.

The Original Code is the MonetDB Database System.

The Initial Developer of the Original Code is CWI.
Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
Copyright August 2008-2010 MonetDB B.V.
All Rights Reserved.
@

@f opt_dataflow
@- The dataflow optimizer
MAL programs are largely logical descriptions of an execution plan.
At least as it concerns side-effect free operations.
For these sub-plans the order of execution needs not to be a priori
fixed and a dataflow driven evaluation is possible. Even using multiple
cores to work their way through the dataflow graph.

The dataflow optimizer analyses the code and wraps all instructions
eligible for dataflow driven execution with a guarded block.
Ofcourse, this is only necessary if you can upfront determine there are 
multiple threads of execution possible.

Upon execution, the interpreter instantiates multiple threads based on
an the number of processor cores available.  Subsequently,
the eligible instructions are queued and consumed by the interpreter
threads.

Dataflow blocks may not be nested. Therefore, any dataflow block produced for
inlined code is removed first.

Initial experiments on e.g. the RDF benchmark showed a speed up of
20\% on average, with a peak of a factor 2 for individual queries.
The main reason for this limited gain stems from the little 
opportunities for parallel execution in the SQL code plans
@{
@mal
pattern optimizer.dataflow():str
address OPTdataflow;
pattern optimizer.dataflow(mod:str, fcn:str):str
address OPTdataflow
comment "Dataflow bracket code injection";

@h
#ifndef _OPT_DATAFLOW_
#define _OPT_DATAFLOW_
#include "opt_prelude.h"
#include "opt_support.h"

#define OPTDEBUGdataflow  if ( optDebug & (1 <<DEBUG_OPT_DATAFLOW) )

@-
The statemens are all checked for being eligible for dataflow.
@= flowblock
	/* close old flow block */
	if (flowblock){
		if (entries > 1){
			q= newFcnCall(mb,languageRef,dataflowRef);
			q->barrier= BARRIERsymbol;
			getArg(q,0)= flowblock;
			/* dataflow blocks are transparent, because they are always
			   executed, either sequentially or in parallell */
			varSetProperty(mb, getArg(q,0), "transparent",0,0);
		}
		for( j=start ; j<i; j++)
			if (old[j])
				pushInstruction(mb,old[j]);
		if (entries>1){
			q= newAssignment(mb);
			q->barrier= EXITsymbol;
			getArg(q,0) = flowblock;
		}
		entries = 0;
		flowblock = 0;
		actions++;
	}
@c
#include "mal_config.h"
#include "opt_dataflow.h"
#include "mal_instruction.h"
#include "mal_interpreter.h"

static int
dflowAssignTest(Lifespan span, InstrPtr p, int i)
{
	int j;
	/* flow blocks should be closed (and not opened) when we reach a point
	   where a variable is assigned that is not the last
	*/
	for(j=0; j<p->retc; j++)
		if (getLastUpdate(span, getArg(p,j)) != i)
			return 1;
	return 0;
}

static int
OPTdataflowImplementation(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	int i,j, cnt, start=1,entries=0, actions=0;
	int flowblock= 0, dumbcopy=0;
	InstrPtr *old, q;
	int limit, slimit;
	Lifespan span;

	/* don't use dataflow on single processor systems */
	if (GDKnr_threads <= 1)
		return 0;

	(void) cntxt;
	(void) stk;
	/* inlined functions will get their dataflow control later */
	if ( varGetProp(mb, getArg(getInstrPtr(mb,0),0),inlineProp)!= NULL) 
		return 0;
	span= setLifespan(mb);
	if( span == NULL)
		return 0;
	limit= mb->stop;
	slimit= mb->ssize;
	old = mb->stmt;
	if ( newMalBlkStmt(mb, mb->ssize+20) <0 ){
		GDKfree(span);
		return 0;
	}
	pushInstruction(mb,old[0]);

	/* remove the inlined dataflow barriers */
	for (i = 1; i<limit; i++) {
		p = old[i];

		if (!flowblock && blockStart(p) && 
		    getFunctionId(p) == dataflowRef){
			flowblock = getArg(p,0);
			freeInstruction(p);
			old[i] = NULL;
		} else if (flowblock && blockExit(p) && getArg(p,0) == flowblock) {
			flowblock = 0;
			freeInstruction(p);
			old[i] = NULL;
		}
	}

	/* inject new dataflow barriers */
	for (i = 1; i<limit; i++) {
		p = old[i];

		if (p == NULL)
			continue;

		if (p->token == ENDsymbol)
			break;
		if (hasSideEffects(p,TRUE) || isUnsafeFunction(p) || blockCntrl(p) || (!dumbcopy && blockExit(p)) || dflowAssignTest(span,p,i) ){
			@:flowblock@
			pushInstruction(mb,p);
			continue;
		}

		if (blockStart(p)){
			dumbcopy++;
			if (dumbcopy == 1)
				@:flowblock@
		}
		if (blockExit(p)) {
			assert(flowblock == 0);
			dumbcopy--;
			pushInstruction(mb,p);
			continue;
		}
		if (dumbcopy) {
			assert(flowblock == 0);
			pushInstruction(mb,p);
			continue;
		}
		if (flowblock == 0){
			flowblock = newTmpVariable(mb,TYPE_int);
			entries = 0;
			start = i;
		}
		/* check if the instruction can start a flow */
		/* this should be a function call with multiple arguments */
		cnt = 0;
		if (getFunctionId(p))
			for(j=p->retc; j<p->argc; j++)
				if (getLastUpdate(span, getArg(p,j)) <= start)
					cnt++;
		if (cnt && dflowAssignTest(span,p,i))
			cnt = 0;

		if (cnt && cnt == p->argc-p->retc)
			entries++;
	}
	if (flowblock){
		for( j=start ; j<i; j++){
			if (old[j] == NULL)
				continue;
			pushInstruction(mb,old[j]);
		}
	}
	/* take the remainder as is */
	for (; i<limit; i++) 
		if (old[i])
			pushInstruction(mb,old[i]);
	for (; i<slimit; i++) 
		if (old[i])
			freeInstruction(old[i]);
	GDKfree(old);
	GDKfree(span);
	DEBUGoptimizers
		mnstr_printf(cntxt->fdout,"#opt_dataflow: %d flow blocks created\n",actions);
	return actions;
}
@include optimizerWrapper.mx
@h
@:exportOptimizer(dataflow)@
#endif
@c
#include "opt_statistics.h"

@:wrapOptimizer(dataflow,OPT_CHECK_ALL)@
@}
