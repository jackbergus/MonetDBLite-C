@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
@' Copyright August 2008-2009 MonetDB B.V.
@' All Rights Reserved.

@f opt_dataflow
@- The dataflow optimizer
MAL programs are largely logical descriptions of an execution plan.
At least as it concerns side-effect free operations.
For these sub-plans the order of execution needs not to be a priori
fixed and a dataflow driven evaluation is possible. Even using multiple
cores to work their way through the dataflow graph.

The dataflow optimizer analyses the code and wraps all instructions
eligible for dataflow driven execution with a guarded block.
Ofcourse, this is only necessary if you can upfront determine there are 
multiple threads of execution possible.

Upon execution, the interpreter instantiates multiple threads based on
an the number of processor cores available.  Subsequently,
the eligible instructions are queued and consumed by the interpreter
threads.

Dataflow blocks may not be nested. Therefore, any dataflow block produced for
inlined code is removed first.

Initial experiments on e.g. the RDF benchmark showed a speed up of
20\% on average, with a peak of a factor 2 for individual queries.
The main reason for this limited gain stems from the little 
opportunities for parallel execution in the SQL code plans
@{
@mal
pattern optimizer.dataflow():str
address OPTdataflow;
pattern optimizer.dataflow(mod:str, fcn:str):str
address OPTdataflow
comment "Dataflow bracket code injection";

@h
#ifndef _OPT_DATAFLOW_
#define _OPT_DATAFLOW_
#include "opt_prelude.h"
#include "opt_support.h"

/* #define DEBUG_OPT_DATAFLOW */
@-
The statemens are all checked for being eligible for dataflow.
@= flowblock
	/* close old flow block */
	if (flowblock){
		if (entries > 1){
			q= newFcnCall(mb,languageRef,dataflowRef);
			q->barrier= BARRIERsymbol;
			getArg(q,0)= flowblock;
			setVarUsed(mb,flowblock);
		}
		for( j=start ; j<i; j++){
			if (old[j] == NULL)
				continue;
			pushInstruction(mb,old[j]);
		}
		if (entries>1){
			q= newAssignment(mb);
			q->barrier= EXITsymbol;
			getArg(q,0) = flowblock;
		}
		entries = 0;
		flowblock = 0;
		actions++;
	}
@c
@c
#include "mal_config.h"
#include "opt_dataflow.h"
#include "mal_instruction.h"
#include "mal_interpreter.h"

static int
OPTdataflowImplementation(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	int i,j, cnt, start=1,entries=0, actions=0;
	int flowblock= 0, dumbcopy=0;
	InstrPtr *old, q;
	int limit;
	Lifespan span;

	/* don't use dataflow on single processor systems */
	if (GDKnr_threads <= 1)
		return 0;

	(void) cntxt;
	(void) stk;
 	span = newLifespan(mb);
	setLifespan(mb,span);
#ifdef DEBUG_DATAFLOW_OPT
	printFunction(GDKstdout, mb,0, LIST_MAL_ALL);
#endif
	limit= mb->stop;
	old = mb->stmt;
	newMalBlkStmt(mb, mb->ssize+20); /* some marge */
	pushInstruction(mb,old[0]);

	initProfiler(mb);
	/* remove the inlined dataflow barriers */
	for (i = 1; i<limit; i++) {
		p = old[i];

		if (!flowblock && blockStart(p) && 
		    getFunctionId(p) == dataflowRef){
			flowblock = getArg(p,0);
			freeInstruction(p);
			old[i] = NULL;
		}

		if (flowblock && blockExit(p) && getArg(p,0) == flowblock) {
			flowblock = 0;
			freeInstruction(p);
			old[i] = NULL;
		}
	}
	for (i = 1; i<limit; i++) {
		p = old[i];

		if (p == NULL)
			continue;
		if (hasSideEffects(p,TRUE) || isUnsafeFunction(p)
		   || blockCntrl(p) || (!dumbcopy && blockExit(p))){
			@:flowblock@
			pushInstruction(mb,p);
			continue;
		}

		if (blockStart(p)){
			dumbcopy++;
			if (dumbcopy == 1)
				@:flowblock@
		}
		if (blockExit(p)) {
			assert(flowblock == 0);
			dumbcopy--;
			pushInstruction(mb,p);
			continue;
		}
		if (dumbcopy) {
			assert(flowblock == 0);
			pushInstruction(mb,p);
			continue;
		}
		if (flowblock == 0){
			flowblock = newTmpVariable(mb,TYPE_int);
			entries = 0;
			start = i;
		}
		/* check if the instruction can start a flow */
		/* this should be a function call with multiple arguments */
		cnt = 0;
		if (getFunctionId(p))
			for(j=p->retc; j<p->argc; j++)
				if (getLastUpdate(span, getArg(p,j)) <= start)
					cnt++;
		if (cnt && cnt == p->argc-p->retc)
			entries++;
	}
	GDKfree(old);
	GDKfree(span);
#ifdef DEBUG_DATAFLOW_OPT
	printFunction(GDKstdout, mb, LIST_MAL_ALL);
#endif
	OPTDEBUG
	if(actions)
		stream_printf(cntxt->fdout,"#opt_dataflow: %d flow blocks created\n",actions);
	return actions;
}
@include optimizerWrapper.mx
@h
@:exportOptimizer(dataflow)@
#endif
@c
#include "opt_statistics.h"

@:wrapOptimizer(dataflow,OPT_CHECK_ALL)@
@}
