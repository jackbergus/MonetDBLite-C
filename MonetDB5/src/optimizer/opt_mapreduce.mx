@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
@' Copyright August 2008-2010 MonetDB B.V.
@' All Rights Reserved.

@f opt_mapreduce
@a M. Kersten, F. Groffen
@- Map-Reduce
The Map-Reduce infrastructure requires a little optimizer to turn
an arbitrary query into a plan to be executed on the elements of the Cloud.

In the first implementation we don't optimize the plan against the mapping scheme.
We simply assume that the complete query can be executed and that only the
result sets should be assembled.

[OUTOFDATE]

Consider part of the query plan for 'select * from tables'
@verbatim
function user.s0_0{autoCommit=true}():void;
    _23:bat[:oid,:sht]  := sql.bind("sys","_tables","type",1);
    _24:bat[:oid,:oid]  := sql.bind_dbat("sys","_tables",1);
    _25 := bat.reverse(_24);
...
    _96:bat[:oid,:bte]  := bat.new(nil:oid,nil:bte);
    _98 := bat.append(_96,_95,true);
    _96:bat[:oid,:bte]  := nil:BAT;
    _99 := bat.append(_98,_93,true);
    _100 := sql.resultSet(8,1,_33);
    sql.rsColumn(_100,".tables","id","int",32,0,_33);
    sql.rsColumn(_100,".tables","name","varchar",1024,0,_44);
    sql.rsColumn(_100,".tables","schema_id","int",32,0,_54);
    sql.rsColumn(_100,".tables","query","varchar",2048,0,_64);
    sql.rsColumn(_100,".tables","type","smallint",16,0,_70);
    sql.rsColumn(_100,".tables","system","boolean",1,0,_81);
    sql.rsColumn(_100,".tables","commit_action","smallint",16,0,_91);
    sql.rsColumn(_100,".tables","temporary","tinyint",8,0,_99);
    _121 := io.stdout();
    sql.exportResult(_121,_100);
end s0_0;
@end verbatim
This plan is turned into two routines. One to be executed
on the individual nodes and one to assemble the results.
@verbatim
function user.s0_0mp() (s0_0:void,X61:bat[:oid,:int],X85:bat[:oid,:str],X109:bat[:oid,:int],X134:bat[:oid,:str],X142:bat[:oid,:sht],X168:bat[:oid,:bit],X191:bat[:oid,:sht],X201:bat[:oid,:bte]);
    _23:bat[:oid,:sht]  := sql.bind("sys","_tables","type",1);
    _24:bat[:oid,:oid]  := sql.bind_dbat("sys","_tables",1);
    _25 := bat.reverse(_24);
...
    _96:bat[:oid,:bte]  := bat.new(nil:oid,nil:bte);
    _98 := bat.append(_96,_95,true);
    _96:bat[:oid,:bte]  := nil:BAT;
    _99 := bat.append(_98,_93,true);
    return (s0_0,X61,X85,X109,X134,X142,X168,X191,X201);
end s0_0mp;
function user.s0_0():void;
    s0_0 := nil:void;
    X61 := nil:bat[:oid,:int];
    X85 := nil:bat[:oid,:str];
    X109 := nil:bat[:oid,:int];
    X134 := nil:bat[:oid,:str];
    X142 := nil:bat[:oid,:sht];
    X168 := nil:bat[:oid,:bit];
    X191 := nil:bat[:oid,:sht];
    X201 := nil:bat[:oid,:bte];
barrier _250 := language.dataflow();
    (_253,_254,_255,_256,_257,_258,_259,_260,_261) := mapreduce.exec(0,"user","s0_0mp");
    (_263,_264,_265,_266,_267,_268,_269,_270,_271) := mapreduce.exec(1,"user","s0_0mp");
    (_273,_274,_275,_276,_277,_278,_279,_280,_281) := mapreduce.exec(2,"user","s0_0mp");
    X61 := mat.pack(_254,_264,_274);
    X85 := mat.pack(_255,_265,_275);
    X109 := mat.pack(_256,_266,_276);
    X134 := mat.pack(_257,_267,_277);
    X142 := mat.pack(_258,_268,_278);
    X168 := mat.pack(_259,_269,_279);
    X191 := mat.pack(_260,_270,_280);
    X201 := mat.pack(_261,_271,_281);
exit _250;
    X202 := sql.resultSet(8,1,X61);
    sql.rsColumn(X202,".tables","id","int",32,0,X61);
    sql.rsColumn(X202,".tables","name","varchar",1024,0,X85);
    sql.rsColumn(X202,".tables","schema_id","int",32,0,X109);
    sql.rsColumn(X202,".tables","query","varchar",2048,0,X134);
    sql.rsColumn(X202,".tables","type","smallint",16,0,X142);
    sql.rsColumn(X202,".tables","system","boolean",1,0,X168);
    sql.rsColumn(X202,".tables","commit_action","smallint",16,0,X191);
    sql.rsColumn(X202,".tables","temporary","tinyint",8,0,X201);
    X232 := io.stdout();
    sql.exportResult(X232,X202);
end s0_0;
function mapreduce.exec_3(conn:str, mod:str, fcn:str):any_1...;
	remote.register(conn, mod, fcn);
	(X201,X202,X203) := remote.exec(conn, mod, fcn);
	Y201 := remote.get(conn, X201);
	Y202 := remote.get(conn, X202);
	Y203 := remote.get(conn, X203);
	return (Y201,Y202,Y203);
end exec;
@end verbatim
The code can be considered a refinement of the Octopus.
@{
@mal
pattern optimizer.mapreduce():str
address OPTmapreduce;
pattern optimizer.mapreduce(mod:str, fcn:str):str
address OPTmapreduce
comment "Modify the plan to exploit parallel processing on multiple cores using map-reduce";

module mapreduce;
pattern exec(conn:str, mod:str, fcn:str):any_1...
address MRexec
comment "Execute the function on a MR node. Upon failure use backup.";
@h
#ifndef _OPT_MAPREDUCE_
#define _OPT_MAPREDUCE_
#include "opt_prelude.h"
#include "opt_support.h"

opt_export str MRexec(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
@c
#include "mal_config.h"
#include "opt_mapreduce.h"
#include "mal_interpreter.h"
#include "remote.h"

/* #define _DEBUG_OPT_MAPREDUCE*/

@-
The work distribution assumes that we know at compile time
the number of nodes participating in the cloud setting.
It calls the map-reduce executor to produce a result
possible with the aid of a replica.
@c

typedef struct _mapnode {
	str uri;
	str user;
	str pass;
} mapnode;

#define MAXNODES 256
static mapnode mapnodes[MAXNODES];

static int
MRcloudSize()
{
	str msg;
	bat bid = 0;
	BAT *b;
	BUN p, q;
	BATiter bi;
	int mapcount = 0;
	/* FIXME: poolname should be configurable */
	str s = "*/testpool/node/*";
	
	msg = RMTresolve(&bid, &s);
	if (msg != MAL_SUCCEED) {
		if (msg != M5OutOfMemory)
			GDKfree(msg);
		return(0);
	}

	b = BATdescriptor(bid);
	if (b == NULL)
		return(0);

	bi = bat_iterator(b);
	BATloop(b, p, q) {
		str t = (str)BUNtail(bi, p);

		if (mapcount == MAXNODES)
			break;

		mapnodes[mapcount].uri = GDKstrdup(t);
		mapnodes[mapcount].user = GDKstrdup("monetdb");
		mapnodes[mapcount].pass = GDKstrdup("monetdb");
		mapcount++;
	}
	BBPreleaseref(bid);

	if (GDKnr_threads < mapcount)
		GDKnr_threads = mapcount;

	return(mapcount);
}

enum coltype {
	NONE,
	cBAT,
	VAL,
	COUNT,
	SUM,
	MIN,
	MAX,
	AVG
};

typedef struct _mapcol {
	enum coltype type;
	int val1;
	int val1type;
	int val2;
	int val2type;
	int val3;
	int val3type;
	struct _mapcol *next;
} mapcol;

static void
MRdistributework(Client cntxt, MalBlkPtr mb, mapcol *col, InstrPtr sig)
{
	InstrPtr o, p, *packs;
	int i, n, j, q, barrier, v, retc;
	int *gets, *w;
	mapcol *lcol;
	(void)cntxt;

	n = MRcloudSize(); /* FIXME: free */

	assert(n);
	assert(col);

	retc = 0;
	for (lcol = col; lcol != NULL; lcol = lcol->next)
		retc += lcol->type == AVG ? 2 : 1;

	assert(retc);

	packs = (InstrPtr *)alloca(retc * sizeof(InstrPtr));
	gets = (int *)alloca(n * retc * sizeof(int));
	w = (int *)alloca(retc * sizeof(int));

	for (lcol = col, j = 0; lcol != NULL; lcol = lcol->next, j++) {
		if (lcol->type == cBAT) {
#ifdef MAT_MERGE_TABLE_IS_WORKING_PROPERLY
			/* x := mat.pack(...) */
			packs[j] = p = newInstruction(mb, ASSIGNsymbol);
			setModuleId(p, matRef);
			setFunctionId(p, packRef);
			getArg(p, 0) = lcol->val1;

			/* make return variable for mat.pack known upfront */
			p = newFcnCall(mb, batRef, newRef);
			p = pushType(mb, p, getHeadType(lcol->val1type));
			p = pushType(mb, p, getTailType(lcol->val1type));
			getArg(p, 0) = lcol->val1;
#else /* it's not, do it manually */
			packs[j] = p = newFcnCall(mb, batRef, newRef);
			p = pushType(mb, p, getHeadType(lcol->val1type));
			p = pushType(mb, p, getTailType(lcol->val1type));
			getArg(p, 0) = lcol->val1;
#endif
		} else if (lcol->type == AVG) {
			/* basically 2 times the code below */
			packs[j++] = p = newFcnCall(mb, batRef, newRef);
			p = pushType(mb, p, TYPE_void);
			p = pushType(mb, p, lcol->val2type);
			packs[j] = p = newFcnCall(mb, batRef, newRef);
			p = pushType(mb, p, TYPE_void);
			p = pushType(mb, p, lcol->val3type);

			p = newAssignment(mb);
			p = pushNil(mb, p, lcol->val2type);
			setArgType(mb, p, 0, lcol->val2type);
			getArg(p, 0) = lcol->val2;
			p = newAssignment(mb);
			p = pushNil(mb, p, lcol->val3type);
			setArgType(mb, p, 0, lcol->val3type);
			getArg(p, 0) = lcol->val3;
		} else {
			/* it took me some time to figure out that mat doesn't
			 * properly support operations performed on a pack of
			 * values, so just create a bat containing the values */
			packs[j] = p = newFcnCall(mb, batRef, newRef);
			p = pushType(mb, p, TYPE_void);
			p = pushType(mb, p, lcol->val1type);

			/* this will hold the final result */
			p = newAssignment(mb);
			p = pushNil(mb, p, lcol->val1type);
			setArgType(mb, p, 0, lcol->val1type);
			getArg(p, 0) = lcol->val1;
		}

		/* same for all sub results that we push into the mat.pack as
		 * arguments at the same time */
		for (i = 0; i < n; i++) {
			if (lcol->type == cBAT) {
				p = newFcnCall(mb, batRef, newRef);
				p = pushType(mb, p, getHeadType(lcol->val1type));
				p = pushType(mb, p, getTailType(lcol->val1type));
				setArgType(mb, p, 0, lcol->val1type);
				gets[(i * retc) + j] = getArg(p, 0);
#ifdef MAT_MERGE_TABLE_IS_WORKING_PROPERLY
				packs[j] = pushArgument(mb, packs[j], getArg(p, 0));
#endif
			} else if (lcol->type == AVG) {
				/* 2x code from else case */
				p = newAssignment(mb);
				p = pushNil(mb, p, lcol->val2type);
				setArgType(mb, p, 0, lcol->val2type);
				gets[(i * retc) + j - 1] = getArg(p, 0);
				p = newAssignment(mb);
				p = pushNil(mb, p, lcol->val3type);
				setArgType(mb, p, 0, lcol->val3type);
				gets[(i * retc) + j] = getArg(p, 0);
			} else {
				p = newAssignment(mb);
				p = pushNil(mb, p, lcol->val1type);
				setArgType(mb, p, 0, lcol->val1type);
				gets[(i * retc) + j] = getArg(p, 0);
			}
		}
	}

	/* barrier language.dataflow */
	p = newInstruction(mb, ASSIGNsymbol);
	setModuleId(p, languageRef);
	setFunctionId(p, dataflowRef);
	p->barrier = BARRIERsymbol;
	barrier = getArg(p, 0) = newTmpVariable(mb, TYPE_int);
	pushInstruction(mb, p);

	for (i = 0; i < n; i++) {
		/* q := remote.connect("uri", "user", "pass"); */
		p = newStmt(mb, remoteRef, connectRef);
		p = pushStr(mb, p, mapnodes[i].uri);
		p = pushStr(mb, p, mapnodes[i].user);
		p = pushStr(mb, p, mapnodes[i].pass);
		p = pushStr(mb, p, "msql");
		q = getArg(p, 0);

		/* remote.register(q, "mod", "fcn"); */
		p = newStmt(mb, remoteRef, putName("register", 8));
		p = pushArgument(mb, p, q);
		p = pushStr(mb, p, getModuleId(sig));
		p = pushStr(mb, p, getFunctionId(sig));

		/* (x1, x2, ..., xn) := remote.exec(q, "mod", "fcn"); */
		p = newInstruction(mb, ASSIGNsymbol);
		setModuleId(p, remoteRef);
		setFunctionId(p, execRef);
		p = pushArgument(mb, p, q);
		p = pushStr(mb, p, getModuleId(sig));
		p = pushStr(mb, p, getFunctionId(sig));
		for (j = 0; j < retc; j++) {
			/* x1 := remote.put(q, :type) */
			o = newFcnCall(mb, remoteRef, putRef);
			o = pushArgument(mb, o, q);
			o = pushArgument(mb, o, gets[(i * retc) + j]);
			v = getArg(o, 0);
			p = pushReturn(mb, p, v);
			w[j] = v;
		}
		pushInstruction(mb, p);

		/* y1 := remote.get(q, x1); */
		for (j = 0; j < retc; j++) {
			p = newFcnCall(mb, remoteRef, getRef);
			p = pushArgument(mb, p, q);
			p = pushArgument(mb, p, w[j]);
			getArg(p, 0) = gets[(i * retc) + j];
#ifdef MAT_MERGE_TABLE_IS_WORKING_PROPERLY
			/* in case we work around mat.pack, insert the value in the bat */
			if (!isaBatType(getArgType(mb, sig, j))) { /* too lazy to do it based on cols */
				/* bat.insert(b, y1) */
				p = newFcnCall(mb, batRef, insertRef);
				p = pushArgument(mb, p, getArg(packs[j], 0));
				p = pushNil(mb, p, TYPE_void);
				p = pushArgument(mb, p, gets[(i * retc) + j]);
			}
#endif
			/* bat.insert(b, y1) */
			p = newFcnCall(mb, batRef, insertRef);
			p = pushArgument(mb, p, getArg(packs[j], 0));
			if (!isaBatType(getArgType(mb, sig, j)))
				p = pushNil(mb, p, TYPE_void);
			p = pushArgument(mb, p, gets[(i * retc) + j]);
		}

		/* remote.disconnect(q); */
		p = newStmt(mb, remoteRef, disconnectRef);
		p = pushArgument(mb, p, q);
	}

	/* end of dataflow barrier */
	p = newInstruction(mb, ASSIGNsymbol);
	p->barrier = EXITsymbol;
	getArg(p, 0) = barrier;
	pushInstruction(mb, p);

	/* perform the correct actions for aggregates */
	for (lcol = col, j = 0; lcol != NULL; lcol = lcol->next, j++) {
		switch (lcol->type) {
			case cBAT:
#ifdef MAT_MERGE_TABLE_IS_WORKING_PROPERLY
				pushInstruction(mb, packs[j]);
#else
				p = newFcnCall(mb, algebraRef, markHRef);
				p = pushArgument(mb, p, getArg(packs[j], 0));
				getArg(p, 0) = lcol->val1;
#endif
			break;
			case AVG:
				p = newFcnCall(mb, aggrRef, sumRef);
				p = pushArgument(mb, p, getArg(packs[j], 0));
				getArg(p, 0) = lcol->val2;
				j++;
				p = newFcnCall(mb, aggrRef, sumRef);
				p = pushArgument(mb, p, getArg(packs[j], 0));
				getArg(p, 0) = lcol->val3;
				/* val1 := calc./(val2, val3); */
				p = newFcnCall(mb, calcRef, divRef);
				p = pushArgument(mb, p, lcol->val2);
				p = pushArgument(mb, p, lcol->val3);
				getArg(p, 0) = lcol->val1;
			break;
			case COUNT:
				p = newFcnCall(mb, aggrRef, sumRef);
				p = pushArgument(mb, p, getArg(packs[j], 0));
				getArg(p, 0) = lcol->val1;
			break;
			case MAX:
				p = newFcnCall(mb, aggrRef, maxRef);
				p = pushArgument(mb, p, getArg(packs[j], 0));
				getArg(p, 0) = lcol->val1;
			break;
			case MIN:
				p = newFcnCall(mb, aggrRef, minRef);
				p = pushArgument(mb, p, getArg(packs[j], 0));
				getArg(p, 0) = lcol->val1;
			break;
			case SUM:
				p = newFcnCall(mb, aggrRef, sumRef);
				p = pushArgument(mb, p, getArg(packs[j], 0));
				getArg(p, 0) = lcol->val1;
			break;
			default:
				assert(0);
		}
	}

#ifdef _DEBUG_OPT_MAPREDUCE
	chkProgram(cntxt->nspace, mb);
	printFunction(cntxt->fdout, mb, 0, LIST_MAL_STMT);
#endif
}

enum copymode { FREE, STICK, SINGLE_DUP, DUP };

static int
OPTmapreduceImplementation(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pc)
{
	int i, limit;
	enum copymode copy;
	InstrPtr p, *old, *orig, ret, sig;
	MalBlkPtr mc;
	char nme[IDLENGTH];
	Symbol new;
	mapcol *col, *lastcol;

	(void)stk;
	(void)pc;

#ifdef _DEBUG_OPT_MAPREDUCE
	printFunction(cntxt->fdout, mb, 0, LIST_MAL_ALL);
#endif

	/* For now we assume that the default ritual of the SQL compiler is
	 * as follows:
	 *   sql.bind(xx, 0)
	 *   sql.bind(xx, 2)
	 *   kdiff
	 *   kunion
	 *   sql.bind(xx, 1)
	 *   kunion
	 *   sql.bind_dbat(xx, 1)
	 *   reverse
	 *   final := kdifference()
	 * This means we can spot the bind_dbat, and predict the
	 * reverse/kdifference to know the bare minimum map-reducable input.
	 * Any plan should work from that point on.  Anything further pushed
	 * into the map plan is an optimisation. */

	col = lastcol = NULL;

	mc = copyMalBlk(mb); /* for the map-program */
	old = mc->stmt;
	orig = mb->stmt;
	limit = mc->stop;

	snprintf(nme, IDLENGTH, "%smp", getFunctionId(getInstrPtr(mb, 0)));

	/* zap */
	if (newMalBlkStmt(mc, mc->ssize) < 0)
		return 0;
	if (newMalBlkStmt(mb, mb->ssize) < 0)
		return 0;

	new = newFunction(userRef, putName(nme, strlen(nme)), FUNCTIONsymbol);
	sig = copyInstruction(getInstrPtr(new->def, 0));
	freeMalBlk(new->def);
	new->def = mc;
	mc->keephistory = mb->keephistory;
	pushInstruction(mc, sig);

	/* We do a two-phase scan over the original plan to get a MAP and
	 * REDUCE program.  We cannot do it in a single scan, because
	 * sql.bind patterns (for columns) are possibly scattered over the
	 * full plan.  We need them all first to determine the signature and
	 * return correctly. */
	copy = FREE;
	for (i = 0; i < limit; i++) { /* phase 1 */
		p = old[i];

		if (getModuleId(p) == sqlRef) {
			if (getFunctionId(p) == mvcRef) {
				/* sql.mvc(): we need this statement everywhere */
				copy = SINGLE_DUP;
			} else if (getFunctionId(p) == bindRef) {
				/* start of sql.bind, kdiff, kunion, etc. sequence */
				copy = STICK;
			} else if (getFunctionId(p) == binddbatRef) {
				/* start tracking ... actually no, just blindly assume :) */
				pushInstruction(mc, p);
				freeInstruction(orig[i]);
				orig[i] = NULL;
				i++; /* bat.reverse */
				pushInstruction(mc, old[i]);
				freeInstruction(orig[i]);
				orig[i] = NULL;
				i++; /* algebra.kdifference */
				p = old[i];
				pushInstruction(mc, p);
				freeInstruction(orig[i]);
				orig[i] = NULL;
				/* this is a column reference, keep it */
				if (lastcol == NULL) {
					col = lastcol = alloca(sizeof(mapcol));
					/* this is the first one, leave a marker */
					orig[i] = (InstrPtr)1; /* should leave some symbol */
				} else {
					lastcol = lastcol->next = alloca(sizeof(mapcol));
				}
				lastcol->val1 = getArg(p, 0);
				lastcol->val1type = getArgType(mc, p, 0);
				lastcol->type =
					isaBatType(getArgType(mc, p, 0)) ? cBAT : VAL;
				lastcol->next = NULL;
				/* the rest is a reduce plan, but we need to inject a
				 * return still if there isn't another column following */
				copy = FREE;
				continue;
			}
		}

		/* terminate ASAP here, we finish in 2nd phase */
		if (p->token == ENDsymbol)
			break;

		switch (copy) {
			case FREE:
				freeInstruction(p);
			break;
			case SINGLE_DUP:
				copy = FREE;
				pushInstruction(mc, p);
			break;
			case STICK:
				pushInstruction(mc, p);
				freeInstruction(orig[i]);
				orig[i] = NULL;
			break;
			case DUP:
				assert(0); /* make GCC happy */
			break;
		}
	}

	copy = STICK;
	for (i = 0; i < limit; i++) { /* phase 2 */
		p = orig[i];
		if (p == NULL)
			continue;

		if (p == (InstrPtr)1) {
			/* this is the moment the first sql.bind occurred
			 * fix the return types and calling signature of the map
			 * program, inject a return instruction */
			getArg(sig, 0) = -1; /* get rid of default retval */
			ret = newInstruction(mc, ASSIGNsymbol);
			ret->barrier = RETURNsymbol;
			getArg(ret, 0) = -1; /* get rid of default retval */
			for (lastcol = col; lastcol != NULL; lastcol = lastcol->next)
			{	
				if (lastcol->type == AVG) {
					sig = pushReturn(mc, sig, lastcol->val2);
					ret = pushReturn(mc, ret, lastcol->val2);
					sig = pushReturn(mc, sig, lastcol->val3);
					ret = pushReturn(mc, ret, lastcol->val3);
				} else {
					sig = pushReturn(mc, sig, lastcol->val1);
					ret = pushReturn(mc, ret, lastcol->val1);
				}
			}
			pushInstruction(mc, ret);
			MRdistributework(cntxt, mb, col, sig);
			continue;
		}

		/* terminate both map and reduce functions properly */
		if (p->token == ENDsymbol)
			copy = DUP;

		switch (copy) {
			case STICK:
				pushInstruction(mb, p);
			break;
			case DUP:
				pushInstruction(mc, old[i]);
				pushInstruction(mb, p);
			break;
			case NONE:
			case SINGLE_DUP:
				assert(0); /* make GCC happy */
			break;
		}
	}

#ifdef _DEBUG_OPT_MAPREDUCE
	stream_printf(cntxt->fdout, "MAP program\n");
	chkProgram(cntxt->nspace, mc);
	printFunction(cntxt->fdout, mc, 0, LIST_MAL_STMT);

	stream_printf(cntxt->fdout, "REDUCE program\n");
	chkProgram(cntxt->nspace, mb);
	printFunction(cntxt->fdout, mb, 0, LIST_MAL_STMT);
#endif

	GDKfree(old);
	GDKfree(orig);

	insertSymbol(findModule(cntxt->nspace, userRef), new);
	return 1;
}

@include optimizerWrapper.mx
@h
@:exportOptimizer(mapreduce)@
#endif
@c
#include "opt_statistics.h"
@:wrapOptimizer(mapreduce,OPT_CHECK_ALL)@

@-
The runtime support for the map-reduce depends on the facilities provided
by the remote module and merovingian. It should register the plan remotely,
execute it and remove it at some point.
[code can be taken from octopus]
@c
str
MRexec(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	(void)mb;
	(void)stk;
	(void)pci;
	return MAL_SUCCEED;
}
@}
