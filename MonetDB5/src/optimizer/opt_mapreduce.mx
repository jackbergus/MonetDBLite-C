@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
@' Copyright August 2008-2010 MonetDB B.V.
@' All Rights Reserved.

@f opt_mapreduce
@a F. Groffen, M. Kersten
@- Map-Reduce
The Map-Reduce infrastructure requires a little optimizer to turn
an arbitrary query into a plan to be executed on the elements of the Cloud.
Each cloud consists of a series of named servers, managed by Merovingian
with the pattern "*/Cloudname/node/*".

Determining the clould is an expensive operation and for the time being
performed each time when a query is compiled.

In the first implementation we don't optimize the plan against the mapping scheme.
We simply assume that the complete query can be executed and that only the
result sets should be assembled.

[OUTOFDATE]

Consider part of the query plan for 'select * from tables'
@verbatim
function user.s0_0{autoCommit=true}():void;
    _23:bat[:oid,:sht]  := sql.bind("sys","_tables","type",1);
    _24:bat[:oid,:oid]  := sql.bind_dbat("sys","_tables",1);
    _25 := bat.reverse(_24);
...
    _96:bat[:oid,:bte]  := bat.new(nil:oid,nil:bte);
    _98 := bat.append(_96,_95,true);
    _96:bat[:oid,:bte]  := nil:BAT;
    _99 := bat.append(_98,_93,true);
    _100 := sql.resultSet(8,1,_33);
    sql.rsColumn(_100,".tables","id","int",32,0,_33);
    sql.rsColumn(_100,".tables","name","varchar",1024,0,_44);
    sql.rsColumn(_100,".tables","schema_id","int",32,0,_54);
    sql.rsColumn(_100,".tables","query","varchar",2048,0,_64);
    sql.rsColumn(_100,".tables","type","smallint",16,0,_70);
    sql.rsColumn(_100,".tables","system","boolean",1,0,_81);
    sql.rsColumn(_100,".tables","commit_action","smallint",16,0,_91);
    sql.rsColumn(_100,".tables","temporary","tinyint",8,0,_99);
    _121 := io.stdout();
    sql.exportResult(_121,_100);
end s0_0;
@end verbatim
This plan is turned into two routines. One to be executed
on the individual nodes and one to assemble the results.
@verbatim
function user.s0_0mp() (s0_0:void,X61:bat[:oid,:int],X85:bat[:oid,:str],X109:bat[:oid,:int],X134:bat[:oid,:str],X142:bat[:oid,:sht],X168:bat[:oid,:bit],X191:bat[:oid,:sht],X201:bat[:oid,:bte]);
    _23:bat[:oid,:sht]  := sql.bind("sys","_tables","type",1);
    _24:bat[:oid,:oid]  := sql.bind_dbat("sys","_tables",1);
    _25 := bat.reverse(_24);
...
    _96:bat[:oid,:bte]  := bat.new(nil:oid,nil:bte);
    _98 := bat.append(_96,_95,true);
    _96:bat[:oid,:bte]  := nil:BAT;
    _99 := bat.append(_98,_93,true);
    return (s0_0,X61,X85,X109,X134,X142,X168,X191,X201);
end s0_0mp;
function user.s0_0():void;
    s0_0 := nil:void;
    X61 := nil:bat[:oid,:int];
    X85 := nil:bat[:oid,:str];
    X109 := nil:bat[:oid,:int];
    X134 := nil:bat[:oid,:str];
    X142 := nil:bat[:oid,:sht];
    X168 := nil:bat[:oid,:bit];
    X191 := nil:bat[:oid,:sht];
    X201 := nil:bat[:oid,:bte];
    (_253,_254,_255,_256,_257,_258,_259,_260,_261) := mapreduce.exec(0,"user","s0_0mp");
    (_263,_264,_265,_266,_267,_268,_269,_270,_271) := mapreduce.exec(1,"user","s0_0mp");
    (_273,_274,_275,_276,_277,_278,_279,_280,_281) := mapreduce.exec(2,"user","s0_0mp");
    X61 := mat.pack(_254,_264,_274);
    X85 := mat.pack(_255,_265,_275);
    X109 := mat.pack(_256,_266,_276);
    X134 := mat.pack(_257,_267,_277);
    X142 := mat.pack(_258,_268,_278);
    X168 := mat.pack(_259,_269,_279);
    X191 := mat.pack(_260,_270,_280);
    X201 := mat.pack(_261,_271,_281);
exit _250;
    X202 := sql.resultSet(8,1,X61);
    sql.rsColumn(X202,".tables","id","int",32,0,X61);
    sql.rsColumn(X202,".tables","name","varchar",1024,0,X85);
    sql.rsColumn(X202,".tables","schema_id","int",32,0,X109);
    sql.rsColumn(X202,".tables","query","varchar",2048,0,X134);
    sql.rsColumn(X202,".tables","type","smallint",16,0,X142);
    sql.rsColumn(X202,".tables","system","boolean",1,0,X168);
    sql.rsColumn(X202,".tables","commit_action","smallint",16,0,X191);
    sql.rsColumn(X202,".tables","temporary","tinyint",8,0,X201);
    X232 := io.stdout();
    sql.exportResult(X232,X202);
end s0_0;
function mapreduce.exec_3(conn:str, mod:str, fcn:str):any_1...;
	remote.register(conn, mod, fcn);
	(X201,X202,X203) := remote.exec(conn, mod, fcn);
	Y201 := remote.get(conn, X201);
	Y202 := remote.get(conn, X202);
	Y203 := remote.get(conn, X203);
	return (Y201,Y202,Y203);
end exec;
@end verbatim
@{
The code can be considered a refinement of the Octopus.
The mal primitives are meant for debugging.
@mal
pattern optimizer.mapreduce():str
address OPTmapreduce;
pattern optimizer.mapreduce(mod:str, fcn:str):str
address OPTmapreduce
comment "Modify the plan to exploit parallel processing on multiple systems using map-reduce";

module mapreduce;
command getCloud(nme:str):bat[:oid,:str]
address MRgetCloud
comment "Localize the elements of a named cloud";
@h
#ifndef _OPT_MAPREDUCE_
#define _OPT_MAPREDUCE_
#include "opt_prelude.h"
#include "opt_support.h"

opt_export str MRexec(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
opt_export str MRgetCloud(int *ret, str *nme);
@c
#include "mal_config.h"
#include "opt_mapreduce.h"
#include "mal_interpreter.h"
#include "remote.h"

@-
The work distribution assumes that we know at compile time
the number of nodes participating in the cloud setting.
It calls the map-reduce executor to produce a result
possible with the aid of a replica.
The mapnode is an auxilary structure.
@c

typedef struct _mapnode {
	str uri;
	str user;
	str pass;
} mapnode;

static mapnode *mapnodes;
static BAT *cloud;

static void
MRcleanCloud()
{
	int i;

	mal_set_lock(mal_contextLock,"mapreduce");
	for (i = 0; mapnodes[i].uri; i++) {
		if (mapnodes[i].uri != NULL)
			GDKfree(mapnodes[i].uri);
		if (mapnodes[i].user != NULL)
			GDKfree(mapnodes[i].user);
		if (mapnodes[i].pass != NULL)
			GDKfree(mapnodes[i].pass);
		mapnodes[i].uri = mapnodes[i].user = mapnodes[i].pass = 0;
	}
	if ( cloud)
		BBPreleaseref(cloud->batCacheid);
	cloud = 0;
	mal_unset_lock(mal_contextLock,"mapreduce");
}

str
MRgetCloud(int *ret, str *mrcluster)
{
	str msg;
	BUN p, q;
	BATiter bi;
	char nodes[BUFSIZ];
	char *n = nodes;
	int mapcount = 0;

	snprintf(nodes, sizeof(nodes), "*/%s/node/*", *mrcluster);
	
	msg = RMTresolve(ret, &n);
	if (msg ) 
		return msg;

	if ( cloud )
		/* cleanup remains of previous call */
		MRcleanCloud();
	
	mal_set_lock(mal_contextLock,"mapreduce");
	cloud = BATdescriptor(*ret); /* should succeed */
	BBPkeepref(*ret);	/* keep if during the session */

	mapnodes = (mapnode*) GDKzalloc(sizeof(mapnode) * (BATcount(cloud) +1));
	if ( mapnodes == 0){
		BBPreleaseref(*ret);
		throw(MAL,"mapreduce.getCloud", MAL_MALLOC_FAIL);
	}

	bi = bat_iterator(cloud);
	BATloop(cloud, p, q) {
		str t = (str)BUNtail(bi, p);
		mapnodes[mapcount].uri = GDKstrdup(t);
		mapnodes[mapcount].user = GDKstrdup("monetdb");
		mapnodes[mapcount].pass = GDKstrdup("monetdb");
		mapcount++;
	}
	if (GDKnr_threads < (int) BATcount(cloud))
		GDKnr_threads = (int) BATcount(cloud);

	mal_unset_lock(mal_contextLock,"mapreduce");
	BBPkeepref(*ret);	/* give it to the called */

	return MAL_SUCCEED;
}

static int
MRcloudSize(str mrcluster)
{
	str msg;
	int bid;

	msg = MRgetCloud(&bid, &mrcluster);
	if ( msg ){
		GDKfree(msg); /* bad programming */
		return 0;
	}
	return (int) BATcount(cloud);
}



typedef struct _mapcol {
	int val1;
	int val1type;
	int val2;
	int val2type;
	int val3;
	int val3type;
	struct _mapcol *next;
} mapcol;

static void
MRdistributework(
		Client cntxt,
		MalBlkPtr mb,
		mapcol *col,
		InstrPtr sig,
		str mrcluster)
{
	InstrPtr o, p, *packs;
	int i, n, j, q, v, retc;
	int *gets, *w;
	mapcol *lcol;
	(void)cntxt;

	n = MRcloudSize(mrcluster);

	assert(n);
	assert(col);

	retc = 0;
	for (lcol = col; lcol != NULL; lcol = lcol->next)
		retc++;

	assert(retc);

	packs = (InstrPtr *)alloca(retc * sizeof(InstrPtr));
	gets = (int *)alloca(n * retc * sizeof(int));
	w = (int *)alloca(retc * sizeof(int));

	for (lcol = col, j = 0; lcol != NULL; lcol = lcol->next, j++) {
		packs[j] = p = newFcnCall(mb, batRef, newRef);
		p = pushType(mb, p, getHeadType(lcol->val1type));
		p = pushType(mb, p, getTailType(lcol->val1type));
		getArg(p, 0) = lcol->val1;

		/* same for all sub results that we push into the mat.pack as
		 * arguments at the same time */
		for (i = 0; i < n; i++) {
			p = newFcnCall(mb, batRef, newRef);
			p = pushType(mb, p, getHeadType(lcol->val1type));
			p = pushType(mb, p, getTailType(lcol->val1type));
			setArgType(mb, p, 0, lcol->val1type);
			gets[(i * retc) + j] = getArg(p, 0);
		}
	}

	for (i = 0; i < n; i++) {
		/* q := remote.connect("uri", "user", "pass"); */
		p = newStmt(mb, remoteRef, connectRef);
		p = pushStr(mb, p, mapnodes[i].uri);
		p = pushStr(mb, p, mapnodes[i].user);
		p = pushStr(mb, p, mapnodes[i].pass);
		p = pushStr(mb, p, "msql");
		q = getArg(p, 0);

		/* remote.register(q, "mod", "fcn"); */
		p = newStmt(mb, remoteRef, putName("register", 8));
		p = pushArgument(mb, p, q);
		p = pushStr(mb, p, getModuleId(sig));
		p = pushStr(mb, p, getFunctionId(sig));

		/* (x1, x2, ..., xn) := remote.exec(q, "mod", "fcn"); */
		p = newInstruction(mb, ASSIGNsymbol);
		setModuleId(p, remoteRef);
		setFunctionId(p, execRef);
		p = pushArgument(mb, p, q);
		p = pushStr(mb, p, getModuleId(sig));
		p = pushStr(mb, p, getFunctionId(sig));
		for (j = 0; j < retc; j++) {
			/* x1 := remote.put(q, :type) */
			o = newFcnCall(mb, remoteRef, putRef);
			o = pushArgument(mb, o, q);
			o = pushArgument(mb, o, gets[(i * retc) + j]);
			v = getArg(o, 0);
			p = pushReturn(mb, p, v);
			w[j] = v;
		}
		pushInstruction(mb, p);

		/* y1 := remote.get(q, x1); */
		for (j = 0; j < retc; j++) {
			p = newFcnCall(mb, remoteRef, getRef);
			p = pushArgument(mb, p, q);
			p = pushArgument(mb, p, w[j]);
			getArg(p, 0) = gets[(i * retc) + j];
		}

		/* remote.disconnect(q); */
		p = newStmt(mb, remoteRef, disconnectRef);
		p = pushArgument(mb, p, q);
	}

	/* delayed bat.inserts for easily creating an deterministic flow */
	for (lcol = col, j = 0; lcol != NULL; lcol = lcol->next, j++) {
		q = getArg(packs[j], 0);
		/* p := bat.insert(b, y1) */
		for (i = 0; i < n; i++) {
			p = newStmt(mb, batRef, insertRef);
			p = pushArgument(mb, p, q);
			if (!isaBatType(lcol->val1type))
				p = pushNil(mb, p, TYPE_void);
			p = pushArgument(mb, p, gets[(i * retc) + j]);
			q = getArg(p, 0);
		}
		/* markH all result bats such that further operations don't get
		 * confused by possible duplicate ids */
		p = newFcnCall(mb, algebraRef, markHRef);
		p = pushArgument(mb, p, q);
		getArg(p, 0) = lcol->val1;
	}

#if defined(_DEBUG_OPT_MAPREDUCE) && _DEBUG_OPT_MAPREDUCE == 0
	chkProgram(cntxt->nspace, mb);
	printFunction(cntxt->fdout, mb, 0, LIST_MAL_STMT);
#endif

	MRcleanCloud();
}

enum copymode { cNONE, FREE, STICK, SINGLE, SINGLE_DUP, DUP, LEAVE };

struct stack {
	int *stack;   /* array of ints */
	size_t len;   /* max capacity of alloced array stack */
	size_t cur;   /* current pointer */
};

static inline void
trackstack_push(struct stack *stk, int val)
{
	if (stk->stack == NULL) {
		stk->len = 10;
		stk->cur = 0;
		stk->stack = GDKmalloc(sizeof(int) * stk->len);
	} else if (stk->cur == stk->len) {
		stk->len *= 2;
		stk->stack = GDKrealloc(stk->stack, sizeof(int) * stk->len);
	}

	assert(stk->stack);

	stk->stack[stk->cur++] = val;
}

static inline char
trackstack_isempty(struct stack *stk)
{
	return(stk->stack == NULL || stk->cur == 0);
}

static inline char
trackstack_contains(struct stack *stk, int val)
{
	size_t tsci;

	if (trackstack_isempty(stk))
		return(0);

	for (tsci = stk->cur; tsci > 0; tsci--) {
		if (stk->stack[tsci - 1] == val)
			return(1);
	}
	return(0);
}

static inline void
trackstack_destroy(struct stack *stk)
{
	if (!trackstack_isempty(stk)) {
		GDKfree(stk->stack);
		stk->stack = NULL;
	}
}

static int
OPTmapreduceImplementation(
		Client cntxt,
		MalBlkPtr mb,
		MalStkPtr stk,
		InstrPtr pc)
{
	int i, j, limit;
	int lastUnion = -1;
	enum copymode copy;
	InstrPtr p, *old, *orig, ret, sig;
	MalBlkPtr mc;
	char nme[IDLENGTH];
	char mrcluster[BUFSIZ];
	Symbol new;
	mapcol *col, *lastcol;
	struct stack tracker = { NULL, 0, 0 };
	char hadBinds = 0;

	(void)stk; /* useless, is NULL */
	(void)pc;

#if defined(_DEBUG_OPT_MAPREDUCE) && _DEBUG_OPT_MAPREDUCE == 0
	printFunction(cntxt->fdout, mb, 0, LIST_MAL_ALL);
#endif

	/* For now we assume that the default ritual of the SQL compiler is
	 * as follows:
	 *   sql.bind(xx, 0)
	 *   sql.bind(xx, 2)
	 *   kdiff
	 *   kunion
	 *   sql.bind(xx, 1)
	 *   kunion
	 *   sql.bind_dbat(xx, 1)
	 *   reverse
	 *   final := kdifference()
	 * This means we can spot the bind_dbat, and predict the
	 * reverse/kdifference to know the bare minimum map-reducable input.
	 * Any plan should work from that point on.  Anything further pushed
	 * into the map plan is an optimisation. */

	col = lastcol = NULL;

	mc = copyMalBlk(mb); /* for the map-program */
	old = mc->stmt;
	orig = mb->stmt;
	limit = mc->stop;

	snprintf(nme, IDLENGTH, "%smap", getFunctionId(getInstrPtr(mb, 0)));

	/* zap */
	if (newMalBlkStmt(mc, mc->ssize) < 0){
		return 0;
	}
	if (newMalBlkStmt(mb, mb->ssize) < 0){
		freeMalBlk(mc);
		return 0;
	}

	new = newFunction(userRef, putName(nme, strlen(nme)), FUNCTIONsymbol);
	sig = copyInstruction(getInstrPtr(new->def, 0));
	freeMalBlk(new->def);
	new->def = mc;
	mc->keephistory = mb->keephistory;
	pushInstruction(mc, sig);

	/* We do a two-phase scan over the original plan to get a MAP and
	 * REDUCE program.  We cannot do it in a single scan, because
	 * sql.bind patterns (for columns) are possibly scattered over the
	 * full plan.  We need them all first to determine the signature and
	 * return correctly. */
	copy = FREE; /* free original copied signature */
	mrcluster[0] = '\0';
	for (i = 0; i < limit; i++) { /* phase 1 */
		p = old[i];

		if (getModuleId(p) == sqlRef) {
			if (getFunctionId(p) == mvcRef) {
				/* sql.mvc(): we need this statement everywhere */
				copy = SINGLE_DUP;
			} else if (getFunctionId(p) == bindRef) {
				if (*(int *)VALget(&getVar(mc, getArg(p, 5))->value) == 0) {
					str schema = VALget(&getVar(mc, getArg(p, 2))->value);
					/* check if this is a column from a mapreduce schema (mr_*) */
					if (strncmp(schema, "mr_", 3) != 0)
						break;

					/* and that we don't mix 'n' match mapreduce schemas */
					if (mrcluster[0] == '\0') {
						snprintf(mrcluster, sizeof(mrcluster),
								"%s", schema + 3);
					} else if (strcmp(mrcluster, schema + 3) != 0) {
						break;
					}

					hadBinds = 1;
				}

				/* start of sql.bind, kdiff, kunion, etc. sequence */
				trackstack_push(&tracker, getArg(p, 0));
				copy = SINGLE;
			} else if (getFunctionId(p) == binddbatRef) {
				trackstack_push(&tracker, getArg(p, 0));
				copy = SINGLE;
			} else {
				copy = LEAVE;
			}
		}

		/* move over statement that depend (indirectly) on the sql.bind
		 * calls */
		if (!trackstack_isempty(&tracker))
		for (j = p->retc; j < p->argc; j++) {
			if (trackstack_contains(&tracker, getArg(p, j))) {
				if (getModuleId(p) == algebraRef) {
					if (getFunctionId(p) == kunionRef) {
						/* store last seen kunion instruction for
						 * comparison with kdifference later */
						lastUnion = getArg(p, 0);
					} else if (getFunctionId(p) == kdifferenceRef) {
						/* a kdifference after a kunion results in the
						 * final column result */
						if (getArg(p, 1) == lastUnion) {
							/* this is a column reference, keep it */
							if (lastcol == NULL) {
								col = lastcol = alloca(sizeof(mapcol));
								/* this is the first one, leave a marker */
								freeInstruction(orig[i]);
								/* FIXME: should leave some symbol */
								orig[i] = (InstrPtr)1;
								pushInstruction(mc, p);
								copy = LEAVE;
							} else {
								lastcol = lastcol->next =
									alloca(sizeof(mapcol));
								copy = SINGLE;
							}
							lastcol->val1 = getArg(p, 0);
							lastcol->val1type = getArgType(mc, p, 0);
							lastcol->next = NULL;
							newComment(mc, "= sql column bat");
							/* break to avoid tracking the return */
							break;
							/* TODO: we should do a forward search for
							 * calc./ and then track the dependencies
							 * backwards to see if we end up with this
							 * column, if so, this will be a AVG, and
							 * hence we have to set two returns for this
							 * column */
						}
					}
				}

				/* track all returns */
				for (j = 0; j < p->retc; j++)
					trackstack_push(&tracker, getArg(p, j));

				copy = SINGLE;
				break;
			}
		}

		/* terminate ASAP here, we finish in 2nd phase */
		if (p->token == ENDsymbol)
			break;

		switch (copy) {
			case FREE:
				freeInstruction(p);
				old[i] = NULL;
			break;
			case LEAVE:
				/* make GCC happy */
			break;
			case SINGLE_DUP:
				copy = FREE;
				pushInstruction(mc, p);
			break;
			case SINGLE:
				copy = LEAVE;
				pushInstruction(mc, p);
				orig[i]->token = NOOPsymbol;
			break;
			case STICK:
			case DUP:
			case cNONE:
				assert(0); /* make GCC happy */
			break;
		}
	}
	trackstack_destroy(&tracker);

	if (hadBinds == 0) {
		GDKfree(mb->stmt);
		mb->stmt = orig;
		mb->stop = limit;
		GDKfree(old);
		freeSymbol(new);
		return 0;
	}

	copy = STICK;
	for (i = 0; i < limit; i++) { /* phase 2 */
		p = orig[i];

		if (p == (InstrPtr)1) {
			newComment(mb, "{ map");
			/* this is the moment the first sql.bind occurred, set the
			 * calling signature of the map program */
			getArg(sig, 0) = -1; /* get rid of default retval */
			for (lastcol = col; lastcol != NULL; lastcol = lastcol->next)
				mc->stmt[0] = sig = pushReturn(mc, sig, lastcol->val1);
			MRdistributework(cntxt, mb, col, sig, mrcluster);
			newComment(mb, "} map");
			/* bogus instruction to be able to set to NOOP */
			orig[i] = newInstruction(mb, ASSIGNsymbol);
			setModuleId(orig[i], ioRef);
			setFunctionId(orig[i], printRef);
			orig[i] = pushReturn(mb, orig[i], 0);
			orig[i] = pushArgument(mb, orig[i], 0);
			orig[i]->token = NOOPsymbol;
			continue;
		}

		if (getModuleId(p) == algebraRef && (
					getFunctionId(p) == sortTailRef ||
					getFunctionId(p) == sortReverseTailRef ||
					getFunctionId(p) == sliceRef))
		{
			/* simple ORDER BY [DESC] or LIMIT/OFFSET */
			for (lastcol = col; lastcol != NULL; lastcol = lastcol->next) {	
				if (getArg(p, 1) == lastcol->val1) {
					copy = SINGLE_DUP;
					newComment(mc, "ORDER BY [DESC] or LIMIT/OFFSET");
					newComment(mb, "ORDER BY [DESC] or LIMIT/OFFSET");
					/* fix return */
					lastcol->val1 = getArg(old[i], 0);
					break;
				}
			}
		} else if (getModuleId(p) == aggrRef && (
					getFunctionId(p) == maxRef ||
					getFunctionId(p) == minRef))
		{
			/* MAX/MIN aggregation, we cannot return a single val, since
			 * we already fixed the signature, so create a container BAT */
			for (lastcol = col; lastcol != NULL; lastcol = lastcol->next) {	
				if (getArg(p, 1) == lastcol->val1) {
					newComment(mc, "MAX/MIN");
					newComment(mb, "MAX/MIN");
					/* basically perform a MAX over all MAXes */
					pushInstruction(mc, old[i]);
					lastcol->val2 = getArg(old[i], 0);
					/* BAT for return */
					p = newFcnCall(mc, batRef, newRef);
					p = pushType(mc, p, getHeadType(lastcol->val1type));
					p = pushType(mc, p, getTailType(lastcol->val1type));
					lastcol->val3 = getArg(p, 0);
					/* bat.insert */
					p = newFcnCall(mc, batRef, insertRef);
					p = pushArgument(mc, p, lastcol->val3);
					p = pushNil(mc, p, getHeadType(lastcol->val1type));
					p = pushArgument(mc, p, lastcol->val2);
					/* fix return */
					lastcol->val1 = lastcol->val3;
					/* we already DUP_SINGLE'd */
					copy = STICK;
					p = orig[i];
					break;
				}
			}
		} else if (getModuleId(p) == batRef && getFunctionId(p) == mirrorRef) {
			/* prepare for a count(*) where the aggr.count is leaded by
			 * a bat.mirror */
			if (getModuleId(orig[i + 1]) == aggrRef &&
						getFunctionId(orig[i + 1]) == countRef &&
						getArg(p, 0) == getArg(orig[i + 1], 1))
			{
				newComment(mc, "COUNT(*)");
				pushInstruction(mc, old[i]);
				copy = cNONE;
				/* NOTE: rest is handled in case below */
			}
		} else if (getModuleId(p) == aggrRef && (
					getFunctionId(p) == countRef ||
					getFunctionId(p) == sumRef))
		{
			/* COUNT/SUM, push down, replace with SUM in REDUCE program,
			 * fix up the return type */
			if (getFunctionId(p) == countRef) {
				/* The aggr.count will be prepended by a bat.mirror if
				 * it came from a SELECT COUNT(*) ... */
				if (getModuleId(orig[i - 1]) == batRef &&
							getFunctionId(orig[i - 1]) == mirrorRef &&
							getArg(orig[i - 1], 0) == getArg(p, 1))
						getArg(p, 1) = getArg(orig[i - 1], 1);
			}
			for (lastcol = col; lastcol != NULL; lastcol = lastcol->next) {	
				if (getArg(p, 1) == lastcol->val1) {
					newComment(mc, "COUNT/SUM");
					newComment(mb, "COUNT/SUM");
					pushInstruction(mc, old[i]);
					lastcol->val2 = getArg(old[i], 0);
					/* BAT for return */
					p = newFcnCall(mc, batRef, newRef);
					p = pushType(mc, p, getHeadType(lastcol->val1type));
					p = pushType(mc, p, getArgType(mc, old[i], 0));
					setArgType(mc, p, 0,
							newBatType(getHeadType(lastcol->val1type),
								getArgType(mc, old[i], 0)));
					lastcol->val3 = getArg(p, 0);
					lastcol->val3type = getArgType(mc, p, 0);
					/* bat.insert */
					p = newFcnCall(mc, batRef, insertRef);
					p = pushArgument(mc, p, lastcol->val3);
					p = pushNil(mc, p, getHeadType(lastcol->val1type));
					p = pushArgument(mc, p, lastcol->val2);
					lastcol->val3 = getArg(p, 0);

					/* propagate type change */
					for (j = 0; j < sig->retc; j++) {
						if (getArg(sig, j) == lastcol->val1) {
							/* we have to fix all pre-registered BATs
							 * that are necessary to avoid "undefined"
							 * errors, can't do better than scan
							 * backwards and pick up what we need to fix */
							int k;
							int q = lastcol->val1;
							p = NULL;
							for (k = mb->stop - 1; k >= 0; k--) {
								p = mb->stmt[k];
								/* First find algebra.markH for the
								 * target BAT, then traverse through the
								 * chained bat.insert calls. */
								if (getModuleId(p) == algebraRef &&
										getFunctionId(p) == markHRef &&
										getArg(p, 0) == q)
								{
									q = getArg(p, 1);
									continue;
								}

								if (getModuleId(p) == batRef &&
										getFunctionId(p) == insertRef &&
										getArg(p, 0) == q)
								{
#define FINDANDFIXBATNEW(X, Y) { \
	int s; \
	InstrPtr pt; \
	for (s = 0; s < mb->stop; s++) { \
		pt = mb->stmt[s]; \
		if (getArg(pt, 0) == getArg(X, Y) && \
				getModuleId(pt) == batRef && \
				getFunctionId(pt) == newRef) \
		{ \
			setArgType(mb, pt, 2, getTailType(lastcol->val3type)); \
			setArgType(mb, pt, 0, lastcol->val3type); \
			break; \
		} \
	} \
}
									FINDANDFIXBATNEW(p, 2);
									setArgType(mb, p, 0, lastcol->val3type);
									q = getArg(p, 1);
								}
							}
							FINDANDFIXBATNEW(sig, j);
							/* fix return and sig in one go the same time */
							getArg(sig, j) = lastcol->val1 = lastcol->val3;
							break;
						}
					}
					/* now make a SUM on the REDUCE side */
					p = newFcnCall(mb, aggrRef, sumRef);
					p = pushArgument(mb, p, getArg(orig[i], 1));
					getArg(p, 0) = getArg(orig[i], 0);
					/* we injected an alternative instruction */
					copy = cNONE;
					break;
				}
			}
		}

		/* terminate both map and reduce functions properly */
		if (p->token == ENDsymbol) {
			/* make sure the return comes at the end, as we may have
			 * added some stuff to the MAP program in this phase,
			 * changing the actual return variable */
			ret = newInstruction(mc, ASSIGNsymbol);
			ret->barrier = RETURNsymbol;
			if (col == NULL) {
				getArg(ret, 0) = newTmpVariable(mc, TYPE_void);
			} else for (lastcol = col; lastcol != NULL; lastcol = lastcol->next) {	
				ret = pushReturn(mc, ret, lastcol->val1);
			}
			pushInstruction(mc, ret);
			copy = DUP;
		}

		switch (copy) {
			case STICK:
				pushInstruction(mb, p);
			break;
			case SINGLE_DUP:
				copy = STICK;
			case DUP:
				pushInstruction(mc, old[i]);
				pushInstruction(mb, p);
			break;
			case cNONE:
				copy = STICK;
			break;
			case SINGLE:
			case FREE:
			case LEAVE:
				assert(0); /* make GCC happy */
			break;
		}
	}

#if defined(_DEBUG_OPT_MAPREDUCE) && _DEBUG_OPT_MAPREDUCE == 10
	stream_printf(cntxt->fdout, "MAP program\n");
	chkProgram(cntxt->nspace, mc);
	printFunction(cntxt->fdout, mc, 0, LIST_MAL_STMT);

	stream_printf(cntxt->fdout, "REDUCE program\n");
	chkProgram(cntxt->nspace, mb);
	printFunction(cntxt->fdout, mb, 0, LIST_MAL_STMT);
#endif

	GDKfree(old);
	GDKfree(orig);

	insertSymbol(findModule(cntxt->nspace, userRef), new);
	return 1;
}

@include optimizerWrapper.mx
@h
@:exportOptimizer(mapreduce)@
#endif
@c
#include "opt_statistics.h"
@:wrapOptimizer(mapreduce,OPT_CHECK_ALL)@

@}
