@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2006 CWI.
@' All Rights Reserved.

@f opt_costModel
@a M. L. Kersten
@-
@node Costmodels, Variable Stack Reduction, Strength Reduction, Toolkit
@- The costmodel approach
Cost models form the basis for many optimization decisions.
The cost parameters are typically the size of the (intermediate)
results and response time. Alternatively, they are running
aggregates, e.g. max memory and total execution time,
obtained from a simulated run.
The current implementation contains a framework and example for
building your own cost-based optimized.

The @code{optimizer.costEstimation()} works its way through a 
MAL program in search for
relational operators and estimates their result size. 
The operations taken into account are @{reverse, select, join, mark,
uselect, kdifference,cross@}
The estimated size is left behind as property @code{RMcost},
to avoid overwriting information produced by the front-end compiler.
@verbatim
    r{count=100} := bat.new(:void,:int);
    s{count=1000}:= bat.new(:void,:int);
    rs:= algebra.select(s,1,1);
    rr:= bat.reverse(r);
    j:= algebra.join(rs,rr);
    optimizer.costModel();
@end verbatim
changes the properties of the instructions as follows:
@verbatim
    r{RMcost=100,count=100} := bat.new(:void,:int);
    s{RMcost=1000,count=1000} := bat.new(:void,:int);
    rs{RMcost=500} := algebra.select(s{RMcost=1000,count=1000},1,1);
    rr{RMcost=100} := bat.reverse(r{RMcost=100,count=100});
    j{RMcost=100} := algebra.join(rs{RMcost=500},rr{RMcost=100});
@end verbatim

The cost estimation does not use any statistics on the actual
data distribution yet. It just applies a few heuristic cost
estimators.
@{
@+ Implementation section
@mal
pattern optimizer.costModel():str
address OPTcostModel;
pattern optimizer.costModel(mod:str, fcn:str):str
address OPTcostModel
comment "Estimate the cost of a relational expression";
@h
#ifndef _OPT_COSTMODEL_H_
#define _OPT_COSTMODEL_H_

#define DEBUG_OPT_COSTMODEL

#include "mal.h"
#include <math.h>
#include "mal_interpreter.h"
#include "opt_support.h"
#include "opt_prelude.h"

#define getProps(Y) mb->var[Y]->props

#endif /* _OPT_COSTMODEL_H_ */
@-
@c
#include "opt_costModel.h"

static void
fixPropertySet(MalBlkPtr mb, int dst)
{
	if (mb->var[dst]->props == 0)
		mb->var[dst]->props = newPropertySet();
}
#define getVarCost(Y) (fndProperty(mb->var[Y]->props,"RMcost")?\
		(int*) getPropertyValue(mb->var[Y]->props,"RMcost"):\
		(int*)getPropertyValue(mb->var[Y]->props,"count") )

@-
The cost formula are repetative
@= newCost
		c1 = getVarCost(getArg(p,@1));
		if( c1 == NULL) continue;
		k= @2;
		fixPropertySet(mb, getArg(p,0));
		setProperty(getProps(getArg(p,0)),"RMcost", "=", TYPE_int, &k);
@= newCost2
		c1 = getVarCost(getArg(p,@1));
		c2 = getVarCost(getArg(p,@2));
		if( c1 == NULL) continue;
		if( c2 == NULL) continue;
		k= (@3);
		fixPropertySet(mb, getArg(p,0));
		setProperty(getProps(getArg(p,0)),"RMcost","=", TYPE_int, &k);
@-
The cost will be used in many places to make decisions.
Access should be fast.
@c
static int
OPTgetCost(MalBlkPtr mb, int varid)
{
	int c;

	c = *(getVarCost(varid));
	return c;
}
static int
OPTcostModelImplementation(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	int i, j, *c, *c1, *c2, k;
	InstrPtr p;
	(void) stk;
	(void) pci;

	for (i = 0; i < mb->stop; i++) {
		p = getInstrPtr(mb, i);
		if (getModuleId(p)==algebraRef) {
			if (getFunctionId(p) && idcmp(getFunctionId(p), "markRef") == 0) {
				@:newCost(1, *c1)@
			} else if (getFunctionId(p)== kdifferenceRef) {
				@:newCost2(1, 2, *c1 - *c2 < 0 ? 0 : *c1 - *c2)@
			} else if (getFunctionId(p)==joinRef ) {
				@:newCost2(1, 2, *c1 < *c2 ? *c1 : *c2)@
			} else if (getFunctionId(p)== selectRef) {
				@:newCost(1, *c1 > 100 ? *c1 / 2 : *c1)@
			} else if (getFunctionId(p)==uselectRef) {
				@:newCost(1, *c1 > 100 ? *c1 / 2 : *c1)@
			} else if (getFunctionId(p)== crossRef) {
				@:newCost2(1, 2, (log((double) *c1) + log((double) *c2) > log(INT_MAX) ? INT_MAX : *c1 * *c2))@
			} else if (getFunctionId(p) && idcmp(getFunctionId(p), "tunique") == 0) {
				@:newCost(1, *c1 < 50 ? *c1 : *c1 / 10)@
			} else if (getFunctionId(p)==sortRef || 
						idcmp(getFunctionId(p), "sort_reverse") == 0) {
				@:newCost(1, *c1)@
			}

		} else if (getModuleId(p)==batRef) {
			if (getFunctionId(p) == reverseRef) {
				@:newCost(1, *c1)@
			} else if (getFunctionId(p)==mirrorRef) {
				@:newCost(1, *c1)@
			}
		} else if (getModuleId(p)==groupRef) {
			if (getFunctionId(p) ==newRef) {
				@:newCost(1, *c1 / 10)@
			} else {
				@:newCost(1, *c1)@
			}
		} else if (getModuleId(p) && idcmp(getModuleId(p), "multiplex") == 0) {
			if (getFunctionId(p) && idcmp(getFunctionId(p), "script") == 0) {
				if (getVarCost(getArg(p, 1))) {
					@:newCost(1, *c1)@
				} else {
					@:newCost(2, *c1)@
				}
			}
		} else if (getModuleId(p)== aggrRef) {
			if (getFunctionId(p) ==sumRef || 
				getFunctionId(p) ==minRef || 
				getFunctionId(p) ==maxRef || 
				getFunctionId(p) ==avgRef) {
				@:newCost(2, *c1)@
			}
		} else {
			/* propagate count to RMcost */
			for (j = 0; j < p->retc; j++) {
				if ((c = (int *) getVarCost(p->argv[j])))
					setProperty(getProps(p->argv[j]), "RMcost", "=", TYPE_int, c);
			}
		}
	}
	return 1;
}
@include optimizerWrapper.mx
@h
@:exportOptimizer(costModel)@
@c
@:wrapOptimizer(costModel,OPT_CHECK_ALL)@
@}
