stdout of test 'partitions00` in directory 'src/optimizer` itself:


# 09:48:29 >  
# 09:48:29 >  Mtimeout -timeout 60 mserver5 "--config=/ufs/mk/monet5/Linux/etc/monetdb5.conf" --debug=10 --set "monet_mod_path=/ufs/mk/monet5//Linux/lib/MonetDB5:/ufs/mk/monet5//Linux/lib/MonetDB5/lib:/ufs/mk/monet5//Linux/lib/MonetDB5/bin" --set "gdk_dbfarm=/ufs/mk/monet5//Linux/var/MonetDB5/dbfarm" --set "sql_logdir=/ufs/mk/monet5//Linux/var/MonetDB5/sql_logs" --set "xquery_logdir=/ufs/mk/monet5//Linux/var/MonetDB5/xquery_logs" --set mapi_port=36708 --set xrpc_port=48585 --set monet_prompt= --trace --dbname=mTests_src_optimizer  partitions00.mal
# 09:48:29 >  

# MonetDB Server v5.0.0_beta2_1
# Copyright (c) 1993-2007 CWI, all rights reserved
# Compiled for x86_64-redhat-linux-gnu/64bit with 64bit OIDs dynamically linked
# dbname:mTests_src_optimizer
# Visit http://monetdb.cwi.nl/ for further information
##testing the BAT partition manager
## use a fake sql library
#module sql;
#pattern bind(s:str,t:str,i:str,flag:int):bat[:oid,:int]
pattern sql.bind(s:str,t:str,i:str,flag:int):bat[:oid,:int] address MDBdummy;#  0 bind:bat[:oid,:int] := sql.bind(s:str, t:str, i:str, flag:int) {G}
#pattern rsColumn(b:any...):void
pattern sql.rsColumn(b:any...):void address MDBdummy;#  0 rsColumn:void := sql.rsColumn(b:any) {P}
#pattern resultSet(b:any...):void
pattern sql.resultSet(b:any...):void address MDBdummy;#  0 resultSet:void := sql.resultSet(b:any) {P}
#pattern exportResult(b:any...):void
pattern sql.exportResult(b:any...):void address MDBdummy;#  0 exportResult:void := sql.exportResult(b:any) {P}
#
#function user.query();
#    t1:bat[:oid,:int]:= sql.bind("sys","t","i",0);
#    t11:= algebra.markT(t1,0@0);
#    t12:= bat.reverse(t11);
#    t13:= algebra.join(t12,t1);
#    t14 := sql.resultSet(1,1,t13);
#    sql.rsColumn(t14,"sys.t","i","int",32,0,t13);
#    sql.exportResult(t14,"");
#end query;
function sql.query():void;              #  0 query:void := sql.query() {G}
    t1:bat[:oid,:int]  := sql.bind("sys","t","i",1);#  1 t1:bat[:oid,:int] := MDBdummy(_2:str, _3:str, _4:str, _5:int) {G}
    t11 := algebra.markT(t1,0@0);       #  2 t11:bat[:oid,:oid] := ALGtmark(t1:bat[:oid,:int], _7:oid) {G}
    t12 := bat.reverse(t11);            #  3 t12:bat[:oid,:oid] := BKCreverse(t11:bat[:oid,:oid]) {G}
    t13 := algebra.join(t12,t1);        #  4 t13:bat[:oid,:int] := ALGjoin(t12:bat[:oid,:oid], t1:bat[:oid,:int]) {G}
    t14 := sql.resultSet(1,1,t13);      #  5 t14:void := MDBdummy(_5:int, _5:int, t13:bat[:oid,:int]) 
    sql.rsColumn(t14,"sys.t","i","int",32,0,t13);#  6 _11:void := MDBdummy(t14:void, _12:str, _4:str, _13:str, _14:int, _15:int, t13:bat[:oid,:int]) 
    sql.exportResult(t14,"");           #  7 _16:void := MDBdummy(t14:void, _17:str) 
end query;	# 8  
#optimizer.partitions("user","query");
#
function user.main():void;              #  0 main:void := user.main() {G}
#testing the BAT partition manager 
# use a fake sql library 
    mdb.list("sql","query");            #  3 _6:void := MDBlist3(_4:str, _5:str) 
end main;	# 4  
function sql.query():void;              #  0 query:void := sql.query() {G}
    t1 := sql.bind("sys","t","i",1);    #  1 t1:bat[:oid,:int] := MDBdummy(_2:str, _3:str, _4:str, _5:int) {G}
    bpm1 := bpm.unfold(t1);             #  2 bpm1:bat[:oid,:int] := BPMunfold(t1:bat[:oid,:int]) {G}
    _20 := bpm.new(:oid,:oid);          #  3 _20:bat[:oid,:oid] := BPMnew(_21:oid, _22:oid) {G}
    t11 := nil:bat[:oid,:oid];          #  4 t11:bat[:oid,:oid] := _24:bat[:oid,:oid] {G}
barrier t1 := bpm.newIterator(bpm1);    #  5 t1:bat[:oid,:int] := BPMnewIterator(bpm1:bat[:oid,:int]) {GJ9}
    t11 := algebra.markT(t1,0@0);       #  6 t11:bat[:oid,:oid] := ALGtmark(t1:bat[:oid,:int], _7:oid) {G}
    bpm.addPartition(_20,t11);          #  7 _26:void := BPMaddPartition(_20:bat[:oid,:oid], t11:bat[:oid,:oid]) 
    redo t1 := bpm.hasMoreElements(bpm1);#  8 t1:bat[:oid,:int] := BPMhasMoreElements(bpm1:bat[:oid,:int]) {GJ6}
exit t1;                                #  9 t1:bat[:oid,:int] 
    _28 := bpm.new(:oid,:oid);          # 10 _28:bat[:oid,:oid] := BPMnew(_29:oid, _30:oid) {G}
    t12 := nil:bat[:oid,:oid];          # 11 t12:bat[:oid,:oid] := _32:bat[:oid,:oid] {G}
barrier t11 := bpm.newIterator(_20);    # 12 t11:bat[:oid,:oid] := BPMnewIterator(_20:bat[:oid,:oid]) {GJ16}
    t12 := bat.reverse(t11);            # 13 t12:bat[:oid,:oid] := BKCreverse(t11:bat[:oid,:oid]) {G}
    bpm.addPartition(_28,t12);          # 14 _34:void := BPMaddPartition(_28:bat[:oid,:oid], t12:bat[:oid,:oid]) 
    redo t11 := bpm.hasMoreElements(_20);# 15 t11:bat[:oid,:oid] := BPMhasMoreElements(_20:bat[:oid,:oid]) {GJ13}
exit t11;                               # 16 t11:bat[:oid,:oid] 
    _36 := bpm.new(:oid,:int);          # 17 _36:bat[:oid,:int] := BPMnew(_37:oid, _38:int) {G}
    t13 := nil:bat[:oid,:int];          # 18 t13:bat[:oid,:int] := _40:bat[:oid,:int] {G}
barrier t12 := bpm.newIterator(_28);    # 19 t12:bat[:oid,:oid] := BPMnewIterator(_28:bat[:oid,:oid]) {GJ26}
barrier t1 := bpm.newIterator(bpm1);    # 20 t1:bat[:oid,:int] := BPMnewIterator(bpm1:bat[:oid,:int]) {GJ25}
    t13 := algebra.join(t12,t1);        # 21 t13:bat[:oid,:int] := ALGjoin(t12:bat[:oid,:oid], t1:bat[:oid,:int]) {G}
    bpm.addPartition(_36,t13);          # 22 _43:void := BPMaddPartition(_36:bat[:oid,:int], t13:bat[:oid,:int]) 
    redo t1 := bpm.hasMoreElements(bpm1);# 23 t1:bat[:oid,:int] := BPMhasMoreElements(bpm1:bat[:oid,:int]) {GJ21}
    redo t12 := bpm.hasMoreElements(_28);# 24 t12:bat[:oid,:oid] := BPMhasMoreElements(_28:bat[:oid,:oid]) {GJ20}
exit t1;                                # 25 t1:bat[:oid,:int] 
exit t12;                               # 26 t12:bat[:oid,:oid] 
    t13 := bpm.fold(_36);               # 27 t13:bat[:oid,:int] := BPMfold(_36:bat[:oid,:int]) {G}
    t14 := sql.resultSet(1,1,t13);      # 28 t14:void := MDBdummy(_5:int, _5:int, t13:bat[:oid,:int]) 
    sql.rsColumn(t14,"sys.t","i","int",32,0,t13);# 29 _11:void := MDBdummy(t14:void, _12:str, _4:str, _13:str, _14:int, _15:int, t13:bat[:oid,:int]) 
    sql.exportResult(t14,"");           # 30 _16:void := MDBdummy(t14:void, _17:str) 
catch SQLexception;                     # 31 SQLexception:str {J36}
    bpm.garbage(bpm1);                  # 32 _49:void := BPMgarbage(bpm1:bat[:oid,:int]) 
    bpm.garbage(_20);                   # 33 _50:void := BPMgarbage(_20:bat[:oid,:oid]) 
    bpm.garbage(_28);                   # 34 _51:void := BPMgarbage(_28:bat[:oid,:oid]) 
    raise SQLexception;                 # 35 SQLexception:str 
exit SQLexception;                      # 36 SQLexception:str 
    bpm.garbage(bpm1);                  # 37 _54:void := BPMgarbage(bpm1:bat[:oid,:int]) 
    bpm.garbage(_20);                   # 38 _55:void := BPMgarbage(_20:bat[:oid,:oid]) 
    bpm.garbage(_28);                   # 39 _56:void := BPMgarbage(_28:bat[:oid,:oid]) 
end query;                              # 40  

# 09:48:30 >  
# 09:48:30 >  Done.
# 09:48:30 >  

