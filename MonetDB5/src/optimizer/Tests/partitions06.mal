#testing the BAT partition manager
# use a fake sql library
# see how you handle an aggregation
module sql;
pattern bind(s:str,t:str,i:str,flag:int):bat[:oid,:int]
address MDBdummy;
pattern rsColumn(b:any...):void
address MDBdummy;
pattern resultSet(b:any...):void
address MDBdummy;
pattern exportResult(b:any...):void
address MDBdummy;
pattern exportValue(b:any...):void
address MDBdummy;

# select i+j+i from t where i<2;

function query(A0:sht):void;
    x1:bat[:oid,:int]{notnil=true,rows=1:lng,bid=769}  := sql.bind("sys","t","i",0);
    x10:bat[:oid,:int]{notnil=true,rows=0:lng,bid=765}  := sql.bind("sys","t","i",1);
    constraints.emptySet(x10);
    x12:bat[:oid,:int]{notnil=true,rows=0:lng,bid=771}  := sql.bind("sys","t","i",2);
    constraints.emptySet(x12);
    x17:bat[:oid,:int]{notnil=true,rows=1:lng,bid=772}  := sql.bind("sys","t","j",1);
    x7{rows=1:lng} := algebra.uselect(x1,nil:int,2,false,false);
    x14{rows=1:lng} := algebra.markT(x7,0@0);
    x15{rows=1:lng} := bat.reverse(x14);
    x16{rows=1:lng} := algebra.join(x15,x1);
    x19{rows=1:lng} := algebra.join(x15,x17);
    x33 := algebra.reuse(x19);
    x20:bat[:oid,:int]{rows=1:lng}  := batcalc.+(x33,x16,x19);
    x20:bat[:oid,:int]{rows=1:lng}  := batcalc.+(x20,x20,x16);
    x21 := sql.resultSet(1,1,x20);
    sql.rsColumn(x21,"sys.","sqlxaddxsqlxaddxi","int",32,0,x20);
    sql.exportResult(x21,"");
end query;
optimizer.partitions("sql","query");
mdb.list("sql","query");
