stdout of test 'partitions07` in directory 'src/optimizer` itself:


# 09:41:13 >  
# 09:41:13 >  Mtimeout -timeout 60 mserver5 "--config=/ufs/mk/monet5/Linux/etc/monetdb5.conf" --debug=10 --set "monet_mod_path=/ufs/mk/monet5//Linux/lib/MonetDB5:/ufs/mk/monet5//Linux/lib/MonetDB5/lib:/ufs/mk/monet5//Linux/lib/MonetDB5/bin" --set "gdk_dbfarm=/ufs/mk/monet5//Linux/var/MonetDB5/dbfarm" --set "sql_logdir=/ufs/mk/monet5//Linux/var/MonetDB5/sql_logs" --set "xquery_logdir=/ufs/mk/monet5//Linux/var/MonetDB5/xquery_logs" --set mapi_port=36568 --set xrpc_port=42864 --set monet_prompt= --trace --dbname=mTests_src_optimizer  partitions07.mal
# 09:41:13 >  

# MonetDB Server v5.0.0_beta2_1
# Copyright (c) 1993-2007 CWI, all rights reserved
# Compiled for x86_64-redhat-linux-gnu/64bit with 64bit OIDs dynamically linked
# dbname:mTests_src_optimizer
# Visit http://monetdb.cwi.nl/ for further information
# Listening for connection requests on mapi:monetdb://eir.ins.cwi.nl:32348/
pattern sql.bind(s:str,t:str,i:str,flag:int):bat[:oid,:int] address MDBdummy;
pattern sql.rsColumn(b:any...):void address MDBdummy;
pattern sql.resultSet(b:any...):void address MDBdummy;
pattern sql.exportResult(b:any...):void address MDBdummy;
pattern sql.exportValue(b:any...):void address MDBdummy;
function sql.query(A0:sht):void;
    x1:bat[:oid,:int]  := sql.bind("sys","t","i",0);
    x6:bat[:oid,:int]  := sql.bind("sys","t","i",1);
    constraints.emptySet(x6);
    x8:bat[:oid,:int]  := sql.bind("sys","t","i",2);
    constraints.emptySet(x8);
    x11 := algebra.markT(x1,0@0);
    x12 := bat.reverse(x11);
    x13 := algebra.join(x12,x1);
    x14 := batcalc.flt(x13);
    x31 := bat.new(nil:oid,nil:flt);
barrier (x35,x36,x37) := bat.newIterator(x14);
    x39 := mmath.sin(x37);
    bat.insert(x31,x36,x39);
    redo (x35,x36,x37) := bat.hasMoreElements(x14);
catch MALException:str ;
    redo (x35,x36,x37) := bat.hasMoreElements(x14);
exit MALException:str ;
exit (x35,x36,x37);
    x15:bat[:oid,:flt]  := x31;
    x18 := sql.resultSet(1,1,x15);
    sql.rsColumn(x18,"sys.","sinxi","real",24,0,x15);
    sql.exportResult(x18,"");
end query;
function user.main():void;
#testing the BAT partition manager 
# use a fake sql library 
# see how you handle an aggregation 
#explain select sin(i) from t; 
    mdb.List("sql","query");
end main;
function sql.query(A0:sht):void;        #  0 query:void := sql.query(A0:sht) {G}
    x1:bat[:oid,:int] {notnil=true,rows=1:lng,bid=769} := sql.bind("sys","t","i",0);#  1 x1:bat[:oid,:int] := MDBdummy(_6:str, _7:str, _8:str, _9:int) {G}
    x6:bat[:oid,:int] {notnil=true,rows=0:lng,bid=1435} := sql.bind("sys","t","i",1);#  2 x6:bat[:oid,:int] := MDBdummy(_6:str, _7:str, _8:str, _13:int) {G}
    bpm10:bat[:oid,:int]  := bpm.unfold(x6{notnil=true,rows=0:lng,bid=1435});#  3 bpm10:bat[:oid,:int] := BPMunfold(x6:bat[:oid,:int]) {G}
    bpm.emptySet(bpm10);                #  4 _14:void := BPMemptySet(bpm10:bat[:oid,:int]) {G}
    x8:bat[:oid,:int] {notnil=true,rows=0:lng,bid=1436} := sql.bind("sys","t","i",2);#  5 x8:bat[:oid,:int] := MDBdummy(_6:str, _7:str, _8:str, _17:int) {G}
    bpm15:bat[:oid,:int]  := bpm.unfold(x8{notnil=true,rows=0:lng,bid=1436});#  6 bpm15:bat[:oid,:int] := BPMunfold(x8:bat[:oid,:int]) {G}
    bpm.emptySet(bpm15);                #  7 _18:void := BPMemptySet(bpm15:bat[:oid,:int]) {G}
    x11{rows=1:lng} := algebra.markT(x1{notnil=true,rows=1:lng,bid=769},0@0);#  8 x11:bat[:oid,:oid] := ALGtmark(x1:bat[:oid,:int], _20:oid) {G}
    x12{rows=1:lng} := bat.reverse(x11{rows=1:lng});#  9 x12:bat[:oid,:oid] := BKCreverse(x11:bat[:oid,:oid]) {G}
    x13{rows=1:lng} := algebra.join(x12{rows=1:lng},x1{notnil=true,rows=1:lng,bid=769});# 10 x13:bat[:oid,:int] := ALGjoin(x12:bat[:oid,:oid], x1:bat[:oid,:int]) {G}
    x14{rows=1:lng} := batcalc.flt(x13{rows=1:lng});# 11 x14:bat[:oid,:flt] := batint_2_flt(x13:bat[:oid,:int]) {G}
    x31 := bat.new(nil:oid,nil:flt);    # 12 x31:bat[:oid,:flt] := CMDBATnew(_25:oid, _26:flt) {G}
barrier (x35,x36,x37) := bat.newIterator(x14{rows=1:lng});# 13 (x35:lng, x36:oid, x37:flt) := CHPbunIterator(x14:bat[:oid,:flt]) {GJ20}
    x39 := mmath.sin(x37);              # 14 x39:flt := MATHunary_SINflt(x37:flt) 
    bat.insert(x31,x36,x39);            # 15 _31:bat[:oid,:flt] := BKCinsert_bun(x31:bat[:oid,:flt], x36:oid, x39:flt) {G}
    redo (x35,x36,x37) := bat.hasMoreElements(x14{rows=1:lng});# 16 (x35:lng, x36:oid, x37:flt) := CHPbunHasMoreElements(x14:bat[:oid,:flt]) {GJ14}
catch MALException:str ;                # 17 MALException:str {J19}
    redo (x35,x36,x37) := bat.hasMoreElements(x14{rows=1:lng});# 18 (x35:lng, x36:oid, x37:flt) := CHPbunHasMoreElements(x14:bat[:oid,:flt]) {GJ14}
exit MALException:str ;                 # 19 MALException:str 
exit (x35,x36,x37);                     # 20 (x35:lng, x36:oid, x37:flt) 
    x15:bat[:oid,:flt]  := x31;         # 21 x15:bat[:oid,:flt] := x31:bat[:oid,:flt] {G}
    x18 := sql.resultSet(1,1,x15);      # 22 x18:void := MDBdummy(_13:int, _13:int, x15:bat[:oid,:flt]) {G}
    sql.rsColumn(x18,"sys.","sinxi","real",24,0,x15);# 23 _35:void := MDBdummy(x18:void, _36:str, _37:str, _38:str, _39:int, _9:int, x15:bat[:oid,:flt]) {G}
    sql.exportResult(x18,"");           # 24 _40:void := MDBdummy(x18:void, _41:str) {G}
catch SQLexception;                     # 25 SQLexception:str {J29}
    bpm.garbage(bpm10);                 # 26 _48:void := BPMgarbage(bpm10:bat[:oid,:int]) {G}
    bpm.garbage(bpm15);                 # 27 _49:void := BPMgarbage(bpm15:bat[:oid,:int]) {G}
    raise SQLexception;                 # 28 SQLexception:str 
exit SQLexception;                      # 29 SQLexception:str 
    bpm.garbage(bpm10);                 # 30 _52:void := BPMgarbage(bpm10:bat[:oid,:int]) {G}
    bpm.garbage(bpm15);                 # 31 _53:void := BPMgarbage(bpm15:bat[:oid,:int]) {G}
end query;                              # 32  

# 09:41:13 >  
# 09:41:13 >  Done.
# 09:41:13 >  

