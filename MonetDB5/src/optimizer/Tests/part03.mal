#testing the partition optimizer

a1:= bat.new(:oid,:int);
bat.insert(a1,0@0,0);
a2:= bat.new(:oid,:int);
bat.insert(a2,10@0,0);
a3:= bat.new(:oid,:int);
bat.insert(a3,20@0,0);
b1:= bat.new(:oid,:int);
bat.insert(b1,0@0,0);
b2:= bat.new(:oid,:int);
bat.insert(b2,10@0,0);
b3:= bat.new(:oid,:int);
bat.insert(b3,20@0,0);

barrier (go,i):= language.newRange(1);
	bat.append(a1,i);
	bat.append(a2,i);
	bat.append(a3,i);
	bat.append(b1,i);
	bat.append(b2,i);
	bat.append(b3,i);
	redo (go,i):= language.nextElement(1,10);
exit (go,i);
#print(a1);
#print(a2);
#print(a3);


# add it to the BAT partition table
partitions.deposit(a1);
partitions.deposit(a1,a2);
partitions.deposit(a1,a3);
partitions.deposit(b1);
partitions.deposit(b1,b2);
partitions.deposit(b1,b3);
partitions.dump();

# this query is already tricky because there are
# two sinks. A naive translation will produce
# a double nested loop
function qry(a:bat[:oid,:int], b:bat[:oid,:int]);
	io.print("experiment 3");
	c:= algebra.select(a,0,10);
	j:= algebra.select(c,0,5);
	io.print(j);
end qry;

optimizer.partitionedQuery("user","qry");
mdb.list("user","qry");
io.print("run experiment");
user.qry(a1,b1);
