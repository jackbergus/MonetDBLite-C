#testing the BAT partition manager
# use a fake sql library
# see how you handle an aggregation
module sql;
pattern bind(s:str,t:str,i:str,flag:int):bat[:oid,:int]
address MDBdummy;
pattern rsColumn(b:any...):void
address MDBdummy;
pattern resultSet(b:any...):void
address MDBdummy;
pattern exportResult(b:any...):void
address MDBdummy;
pattern exportValue(b:any...):void
address MDBdummy;

#select count(*) from x
function query(A0:sht):void;
    x1:bat[:oid,:int]{notnil=true,rows=0,bid=765}  := sql.bind("sys","x","i",0);
    x6:bat[:oid,:int]{notnil=true,rows=0,bid=769}  := sql.bind("sys","x","i",1);
    constraints.emptySet(x6);
    x8:bat[:oid,:int]{notnil=true,rows=0,bid=771}  := sql.bind("sys","x","i",2);
    constraints.emptySet(x8);
    x11{rows=0} := algebra.markT(x1,0@0);
    x12{rows=0} := bat.reverse(x11);
    x13{rows=1} := aggr.count(x12);
    sql.exportValue(1,"sys.","countx","int",32,0,6,x13,"");
end query;
optimizer.partitions("sql","query");
mdb.list("sql","query");
