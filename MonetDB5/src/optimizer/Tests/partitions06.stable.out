stdout of test 'partitions06` in directory 'src/optimizer` itself:


# 09:41:12 >  
# 09:41:12 >  Mtimeout -timeout 60 mserver5 "--config=/ufs/mk/monet5/Linux/etc/monetdb5.conf" --debug=10 --set "monet_mod_path=/ufs/mk/monet5//Linux/lib/MonetDB5:/ufs/mk/monet5//Linux/lib/MonetDB5/lib:/ufs/mk/monet5//Linux/lib/MonetDB5/bin" --set "gdk_dbfarm=/ufs/mk/monet5//Linux/var/MonetDB5/dbfarm" --set "sql_logdir=/ufs/mk/monet5//Linux/var/MonetDB5/sql_logs" --set "xquery_logdir=/ufs/mk/monet5//Linux/var/MonetDB5/xquery_logs" --set mapi_port=36568 --set xrpc_port=42864 --set monet_prompt= --trace --dbname=mTests_src_optimizer  partitions06.mal
# 09:41:12 >  

# MonetDB Server v5.0.0_beta2_1
# Copyright (c) 1993-2007 CWI, all rights reserved
# Compiled for x86_64-redhat-linux-gnu/64bit with 64bit OIDs dynamically linked
# dbname:mTests_src_optimizer
# Visit http://monetdb.cwi.nl/ for further information
##testing the BAT partition manager
## use a fake sql library
## see how you handle an aggregation
#module sql;
#pattern bind(s:str,t:str,i:str,flag:int):bat[:oid,:int]
pattern sql.bind(s:str,t:str,i:str,flag:int):bat[:oid,:int] address MDBdummy;	# 0  (bind:bat[:oid,:int])<-(s:str)(t:str)(i:str)(flag:int)
#pattern rsColumn(b:any...):void
pattern sql.rsColumn(b:any...):void address MDBdummy;	# 0  (rsColumn:void)<-(b:any)
#pattern resultSet(b:any...):void
pattern sql.resultSet(b:any...):void address MDBdummy;	# 0  (resultSet:void)<-(b:any)
#pattern exportResult(b:any...):void
pattern sql.exportResult(b:any...):void address MDBdummy;	# 0  (exportResult:void)<-(b:any)
#pattern exportValue(b:any...):void
pattern sql.exportValue(b:any...):void address MDBdummy;	# 0  (exportValue:void)<-(b:any)
#
## select i+j+i from t where i<2;
#
#function query(A0:sht):void;
#    x1:bat[:oid,:int]{notnil=true,rows=1:lng,bid=769}  := sql.bind("sys","t","i",0);
#    x10:bat[:oid,:int]{notnil=true,rows=0:lng,bid=765}  := sql.bind("sys","t","i",1);
#    constraints.emptySet(x10);
#    x12:bat[:oid,:int]{notnil=true,rows=0:lng,bid=771}  := sql.bind("sys","t","i",2);
#    constraints.emptySet(x12);
#    x17:bat[:oid,:int]{notnil=true,rows=1:lng,bid=772}  := sql.bind("sys","t","j",0);
#    x7{rows=1:lng} := algebra.uselect(x1,nil:int,2,false,false);
#    x14{rows=1:lng} := algebra.markT(x7,0@0);
#    x15{rows=1:lng} := bat.reverse(x14);
#    x16{rows=1:lng} := algebra.join(x15,x1);
#    x19{rows=1:lng} := algebra.join(x15,x17);
#    x33 := algebra.reuse(x19);
#    x20:bat[:oid,:int]{rows=1:lng}  := batcalc.+(x33,x16,x19);
#    x20:bat[:oid,:int]{rows=1:lng}  := batcalc.+(x20,x20,x16);
#    x21 := sql.resultSet(1,1,x20);
#    sql.rsColumn(x21,"sys.","sqlxaddxsqlxaddxi","int",32,0,x20);
#    sql.exportResult(x21,"");
#end query;
function sql.query(A0:sht):void;	# 0  (query:void)<-(A0:sht)
    x1:bat[:oid,:int]{bid=769,rows=1:lng,notnil=true}  := sql.bind("sys","t","i",0);	# 1 MDBdummy (x1:bat[:oid,:int])<-(_3:str)(_4:str)(_5:str)(_6:int)
    x10:bat[:oid,:int]{bid=765,rows=0:lng,notnil=true}  := sql.bind("sys","t","i",1);	# 2 MDBdummy (x10:bat[:oid,:int])<-(_3:str)(_4:str)(_5:str)(_8:int)
    constraints.emptySet(x10);	# 3 CemptySet (_9:void)<-(x10:bat[:oid,:int])
    x12:bat[:oid,:int]{bid=771,rows=0:lng,notnil=true}  := sql.bind("sys","t","i",2);	# 4 MDBdummy (x12:bat[:oid,:int])<-(_3:str)(_4:str)(_5:str)(_11:int)
    constraints.emptySet(x12);	# 5 CemptySet (_12:void)<-(x12:bat[:oid,:int])
    x17:bat[:oid,:int]{bid=772,rows=1:lng,notnil=true}  := sql.bind("sys","t","j",0);	# 6 MDBdummy (x17:bat[:oid,:int])<-(_3:str)(_4:str)(_14:str)(_6:int)
    x7{rows=1:lng} := algebra.uselect(x1,nil:int,2,false,false);	# 7 ALGuselectInclusive (x7:bat[:oid,:oid])<-(x1:bat[:oid,:int])(_16:int)(_11:int)(_17:bit)(_17:bit)
    x14{rows=1:lng} := algebra.markT(x7,0@0);	# 8 ALGtmark (x14:bat[:oid,:oid])<-(x7:bat[:oid,:oid])(_19:oid)
    x15{rows=1:lng} := bat.reverse(x14);	# 9 BKCreverse (x15:bat[:oid,:oid])<-(x14:bat[:oid,:oid])
    x16{rows=1:lng} := algebra.join(x15,x1);	# 10 ALGjoin (x16:bat[:oid,:int])<-(x15:bat[:oid,:oid])(x1:bat[:oid,:int])
    x19{rows=1:lng} := algebra.join(x15,x17);	# 11 ALGjoin (x19:bat[:oid,:int])<-(x15:bat[:oid,:oid])(x17:bat[:oid,:int])
    x33 := algebra.reuse(x19);	# 12 ALGreuse (x33:bat[:oid,:int])<-(x19:bat[:oid,:int])
    x20:bat[:oid,:int]{rows=1:lng}  := batcalc.+(x33,x16,x19);	# 13 CMDbataccumADD_int_int_int (x20:bat[:oid,:int])<-(x33:bat[:oid,:int])(x16:bat[:oid,:int])(x19:bat[:oid,:int])
    x20:bat[:oid,:int]{rows=1:lng}  := batcalc.+(x20,x20,x16);	# 14 CMDbataccumADD_int_int_int (x20:bat[:oid,:int])<-(x20:bat[:oid,:int])(x20:bat[:oid,:int])(x16:bat[:oid,:int])
    x21 := sql.resultSet(1,1,x20);	# 15 MDBdummy (x21:void)<-(_8:int)(_8:int)(x20:bat[:oid,:int])
    sql.rsColumn(x21,"sys.","sqlxaddxsqlxaddxi","int",32,0,x20);	# 16 MDBdummy (_26:void)<-(x21:void)(_27:str)(_28:str)(_29:str)(_30:int)(_6:int)(x20:bat[:oid,:int])
    sql.exportResult(x21,"");	# 17 MDBdummy (_31:void)<-(x21:void)(_32:str)
end query;	# 18  
#optimizer.partitions("sql","query");
#mdb.list("sql","query");
#
function user.main():void;	# 0  (main:void)
#testing the BAT partition manager 	# 1  (_1:str)
# use a fake sql library 	# 2  (_2:str)
# see how you handle an aggregation 	# 3  (_3:str)
# select i+j+i from t where i<2; 	# 4  (_4:str)
    mdb.list("sql","query");	# 5 MDBlist3 (_8:void)<-(_6:str)(_7:str)
end main;	# 6  
function sql.query{segment=2}(A0:sht):void;
    x1:bat[:oid,:int]{segment=2,bid=769,rows=1:lng,notnil=true}  := sql.bind("sys","t","i",0);
    bpm2:bat[:oid,:int]  := bpm.take("sys_t_i");
    x10:bat[:oid,:int]{segment=-1,bid=765,rows=0:lng,notnil=true}  := sql.bind("sys","t","i",1);
    constraints.emptySet(x10);
    x12:bat[:oid,:int]{segment=-1,bid=771,rows=0:lng,notnil=true}  := sql.bind("sys","t","i",2);
    constraints.emptySet(x12);
    x17:bat[:oid,:int]{segment=7,bid=772,rows=1:lng,notnil=true}  := sql.bind("sys","t","j",0);
    bpm13:bat[:oid,:int]  := bpm.take("sys_t_j");
    _39 := bpm.new(:oid,:oid);
barrier x1:bat[:oid,:int]{segment=2,bid=769,rows=1:lng,notnil=true}  := bpm.newIterator(bpm2);
    x7{segment=9,rows=1:lng} := algebra.uselect(x1,nil:int,2,false,false);
    x14{segment=9,rows=1:lng} := algebra.markT(x7,0@0);
    x15{segment=9,rows=1:lng} := bat.reverse(x14);
    bpm.addPartition(_39,x15);
    redo x1:bat[:oid,:int]{segment=2,bid=769,rows=1:lng,notnil=true}  := bpm.hasMoreElements(bpm2);
exit x1:bat[:oid,:int]{segment=2,bid=769,rows=1:lng,notnil=true} ;
    _45 := bpm.new(:oid,:int);
barrier x15{segment=9,rows=1:lng} := bpm.newIterator(_39);
barrier x1:bat[:oid,:int]{segment=2,bid=769,rows=1:lng,notnil=true}  := bpm.newIterator(bpm2);
    x16{segment=10,rows=1:lng} := algebra.join(x15,x1);
    bpm.addPartition(_45,x16);
    redo x1:bat[:oid,:int]{segment=2,bid=769,rows=1:lng,notnil=true}  := bpm.hasMoreElements(bpm2);
    redo x15{segment=9,rows=1:lng} := bpm.hasMoreElements(_39);
exit x1:bat[:oid,:int]{segment=2,bid=769,rows=1:lng,notnil=true} ;
exit x15{segment=9,rows=1:lng};
    _53 := bpm.new(:oid,:int);
barrier x15{segment=9,rows=1:lng} := bpm.newIterator(_39);
barrier x17:bat[:oid,:int]{segment=7,bid=772,rows=1:lng,notnil=true}  := bpm.newIterator(bpm13);
    x19{segment=11,rows=1:lng} := algebra.join(x15,x17);
    bpm.addPartition(_53,x19);
    redo x17:bat[:oid,:int]{segment=7,bid=772,rows=1:lng,notnil=true}  := bpm.hasMoreElements(bpm13);
    redo x15{segment=9,rows=1:lng} := bpm.hasMoreElements(_39);
exit x17:bat[:oid,:int]{segment=7,bid=772,rows=1:lng,notnil=true} ;
exit x15{segment=9,rows=1:lng};
    _61 := bpm.new(:oid,:int);
barrier x19{segment=11,rows=1:lng} := bpm.newIterator(_53);
    x33{segment=12} := algebra.reuse(x19);
    bpm.addPartition(_61,x33);
    redo x19{segment=11,rows=1:lng} := bpm.hasMoreElements(_53);
exit x19{segment=11,rows=1:lng};
    _67 := bpm.new(:oid,:int);
barrier (_70,_71,_72):= bpm.newIterator(_61,_45,_53);
    x20:bat[:oid,:int]{segment=14,rows=1:lng}  := batcalc.+(_70,_71,_72);
    bpm.addPartition(_67,x20);
    redo (_70,_71,_72):= bpm.hasMoreElements(_61,_45,_53);
exit (_70,_71,_72);
    _75 := bpm.new(:oid,:int);
barrier (_78,_79,_80):= bpm.newIterator(_67,_67,_45);
    x20:bat[:oid,:int]{segment=14,rows=1:lng}  := batcalc.+(_78,_79,_80);
    bpm.addPartition(_75,x20);
    redo (_78,_79,_80):= bpm.hasMoreElements(_67,_67,_45);
exit (_78,_79,_80);
    x20:bat[:oid,:int]{segment=14,rows=1:lng}  := bpm.glue(_75);
    x21{segment=14} := sql.resultSet(1,1,x20);
    sql.rsColumn(x21,"sys.","sqlxaddxsqlxaddxi","int",32,0,x20);
    sql.exportResult(x21,"");
end query;

# 09:41:13 >  
# 09:41:13 >  Done.
# 09:41:13 >  

