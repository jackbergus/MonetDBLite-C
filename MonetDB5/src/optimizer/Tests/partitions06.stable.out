stdout of test 'partitions06` in directory 'src/optimizer` itself:


# 09:41:12 >  
# 09:41:12 >  Mtimeout -timeout 60 mserver5 "--config=/ufs/mk/monet5/Linux/etc/monetdb5.conf" --debug=10 --set "monet_mod_path=/ufs/mk/monet5//Linux/lib/MonetDB5:/ufs/mk/monet5//Linux/lib/MonetDB5/lib:/ufs/mk/monet5//Linux/lib/MonetDB5/bin" --set "gdk_dbfarm=/ufs/mk/monet5//Linux/var/MonetDB5/dbfarm" --set "sql_logdir=/ufs/mk/monet5//Linux/var/MonetDB5/sql_logs" --set "xquery_logdir=/ufs/mk/monet5//Linux/var/MonetDB5/xquery_logs" --set mapi_port=36568 --set xrpc_port=42864 --set monet_prompt= --trace --dbname=mTests_src_optimizer  partitions06.mal
# 09:41:12 >  

# MonetDB Server v5.0.0_beta2_1
# Copyright (c) 1993-2007 CWI, all rights reserved
# Compiled for x86_64-redhat-linux-gnu/64bit with 64bit OIDs dynamically linked
# dbname:mTests_src_optimizer
# Visit http://monetdb.cwi.nl/ for further information
##testing the BAT partition manager
## use a fake sql library
## see how you handle an aggregation
#module sql;
#pattern bind(s:str,t:str,i:str,flag:int):bat[:oid,:int]
pattern sql.bind(s:str,t:str,i:str,flag:int):bat[:oid,:int] address MDBdummy;#  0 bind:bat[:oid,:int] := sql.bind(s:str, t:str, i:str, flag:int) {G}
#pattern rsColumn(b:any...):void
pattern sql.rsColumn(b:any...):void address MDBdummy;#  0 rsColumn:void := sql.rsColumn(b:any) {P}
#pattern resultSet(b:any...):void
pattern sql.resultSet(b:any...):void address MDBdummy;#  0 resultSet:void := sql.resultSet(b:any) {P}
#pattern exportResult(b:any...):void
pattern sql.exportResult(b:any...):void address MDBdummy;#  0 exportResult:void := sql.exportResult(b:any) {P}
#pattern exportValue(b:any...):void
pattern sql.exportValue(b:any...):void address MDBdummy;#  0 exportValue:void := sql.exportValue(b:any) {P}
#
## select i+j+i from t where i<2;
#
#function query(A0:sht):void;
#    x1:bat[:oid,:int]{notnil=true,rows=1:lng,bid=769}  := sql.bind("sys","t","i",0);
#    x10:bat[:oid,:int]{notnil=true,rows=0:lng,bid=765}  := sql.bind("sys","t","i",1);
#    constraints.emptySet(x10);
#    x12:bat[:oid,:int]{notnil=true,rows=0:lng,bid=771}  := sql.bind("sys","t","i",2);
#    constraints.emptySet(x12);
#    x17:bat[:oid,:int]{notnil=true,rows=1:lng,bid=772}  := sql.bind("sys","t","j",0);
#    x7{rows=1:lng} := algebra.uselect(x1,nil:int,2,false,false);
#    x14{rows=1:lng} := algebra.markT(x7,0@0);
#    x15{rows=1:lng} := bat.reverse(x14);
#    x16{rows=1:lng} := algebra.join(x15,x1);
#    x19{rows=1:lng} := algebra.join(x15,x17);
#    x33 := algebra.reuse(x19);
#    x20:bat[:oid,:int]{rows=1:lng}  := batcalc.+(x33,x16,x19);
#    x20:bat[:oid,:int]{rows=1:lng}  := batcalc.+(x20,x20,x16);
#    x21 := sql.resultSet(1,1,x20);
#    sql.rsColumn(x21,"sys.","sqlxaddxsqlxaddxi","int",32,0,x20);
#    sql.exportResult(x21,"");
#end query;
function sql.query(A0:sht):void;        #  0 query:void := sql.query(A0:sht) {G}
    x1:bat[:oid,:int] {notnil=true,rows=1:lng,bid=769} := sql.bind("sys","t","i",0);#  1 x1:bat[:oid,:int] := MDBdummy(_6:str, _7:str, _8:str, _9:int) {G}
    x10:bat[:oid,:int] {notnil=true,rows=0:lng,bid=765} := sql.bind("sys","t","i",1);#  2 x10:bat[:oid,:int] := MDBdummy(_6:str, _7:str, _8:str, _13:int) {G}
    constraints.emptySet(x10{notnil=true,rows=0:lng,bid=765});#  3 _14:void := CemptySet(x10:bat[:oid,:int]) 
    x12:bat[:oid,:int] {notnil=true,rows=0:lng,bid=771} := sql.bind("sys","t","i",2);#  4 x12:bat[:oid,:int] := MDBdummy(_6:str, _7:str, _8:str, _17:int) {G}
    constraints.emptySet(x12{notnil=true,rows=0:lng,bid=771});#  5 _18:void := CemptySet(x12:bat[:oid,:int]) 
    x17:bat[:oid,:int] {notnil=true,rows=1:lng,bid=772} := sql.bind("sys","t","j",1);#  6 x17:bat[:oid,:int] := MDBdummy(_6:str, _7:str, _21:str, _13:int) {G}
    x7{rows=1:lng} := algebra.uselect(x1{notnil=true,rows=1:lng,bid=769},nil:int,2,false,false);#  7 x7:bat[:oid,:oid] := ALGuselectInclusive(x1:bat[:oid,:int], _23:int, _17:int, _24:bit, _24:bit) {G}
    x14{rows=1:lng} := algebra.markT(x7{rows=1:lng},0@0);#  8 x14:bat[:oid,:oid] := ALGtmark(x7:bat[:oid,:oid], _26:oid) {G}
    x15{rows=1:lng} := bat.reverse(x14{rows=1:lng});#  9 x15:bat[:oid,:oid] := BKCreverse(x14:bat[:oid,:oid]) {G}
    x16{rows=1:lng} := algebra.join(x15{rows=1:lng},x1{notnil=true,rows=1:lng,bid=769});# 10 x16:bat[:oid,:int] := ALGjoin(x15:bat[:oid,:oid], x1:bat[:oid,:int]) {G}
    x19{rows=1:lng} := algebra.join(x15{rows=1:lng},x17{notnil=true,rows=1:lng,bid=772});# 11 x19:bat[:oid,:int] := ALGjoin(x15:bat[:oid,:oid], x17:bat[:oid,:int]) {G}
    x33 := algebra.reuse(x19{rows=1:lng});# 12 x33:bat[:oid,:int] := ALGreuse(x19:bat[:oid,:int]) {G}
    x20:bat[:oid,:int] {rows=1:lng} := batcalc.+(x33,x16{rows=1:lng},x19{rows=1:lng});# 13 x20:bat[:oid,:int] := CMDbataccumADD_int_int_int(x33:bat[:oid,:int], x16:bat[:oid,:int], x19:bat[:oid,:int]) {G}
    x20:bat[:oid,:int] {rows=1:lng} := batcalc.+(x20{rows=1:lng},x20{rows=1:lng},x16{rows=1:lng});# 14 x20:bat[:oid,:int] := CMDbataccumADD_int_int_int(x20:bat[:oid,:int], x20:bat[:oid,:int], x16:bat[:oid,:int]) {G}
    x21 := sql.resultSet(1,1,x20{rows=1:lng});# 15 x21:void := MDBdummy(_13:int, _13:int, x20:bat[:oid,:int]) 
    sql.rsColumn(x21,"sys.","sqlxaddxsqlxaddxi","int",32,0,x20{rows=1:lng});# 16 _33:void := MDBdummy(x21:void, _34:str, _35:str, _36:str, _37:int, _9:int, x20:bat[:oid,:int]) 
    sql.exportResult(x21,"");           # 17 _38:void := MDBdummy(x21:void, _39:str) 
end query;	# 18  
#optimizer.partitions("sql","query");
#mdb.list("sql","query");
#
function user.main():void;              #  0 main:void := user.main() {G}
#testing the BAT partition manager 
# use a fake sql library 
# see how you handle an aggregation 
# select i+j+i from t where i<2; 
    mdb.list("sql","query");            #  5 _8:void := MDBlist3(_6:str, _7:str) 
end main;	# 6  
function sql.query(A0:sht):void;        #  0 query:void := sql.query(A0:sht) {G}
    x1{notnil=true,rows=1:lng,bid=769} := sql.bind("sys","t","i",0);#  1 x1:bat[:oid,:int] := MDBdummy(_6:str, _7:str, _8:str, _9:int) {G}
    x10{notnil=true,rows=0:lng,bid=765} := sql.bind("sys","t","i",1);#  2 x10:bat[:oid,:int] := MDBdummy(_6:str, _7:str, _8:str, _13:int) {G}
    bpm10 := bpm.unfold(x10{notnil=true,rows=0:lng,bid=765});#  3 bpm10:bat[:oid,:int] := BPMunfold(x10:bat[:oid,:int]) {G}
    bpm.emptySet(bpm10);                #  4 _14:void := BPMemptySet(bpm10:bat[:oid,:int]) 
    x12{notnil=true,rows=0:lng,bid=771} := sql.bind("sys","t","i",2);#  5 x12:bat[:oid,:int] := MDBdummy(_6:str, _7:str, _8:str, _17:int) {G}
    bpm15 := bpm.unfold(x12{notnil=true,rows=0:lng,bid=771});#  6 bpm15:bat[:oid,:int] := BPMunfold(x12:bat[:oid,:int]) {G}
    bpm.emptySet(bpm15);                #  7 _18:void := BPMemptySet(bpm15:bat[:oid,:int]) 
    x17{notnil=true,rows=1:lng,bid=772} := sql.bind("sys","t","j",1);#  8 x17:bat[:oid,:int] := MDBdummy(_6:str, _7:str, _21:str, _13:int) {G}
    bpm19 := bpm.unfold(x17{notnil=true,rows=1:lng,bid=772});#  9 bpm19:bat[:oid,:int] := BPMunfold(x17:bat[:oid,:int]) {G}
    x7{rows=1:lng} := algebra.uselect(x1{notnil=true,rows=1:lng,bid=769},nil:int,2,false,false);# 10 x7:bat[:oid,:oid] := ALGuselectInclusive(x1:bat[:oid,:int], _23:int, _17:int, _24:bit, _24:bit) {G}
    x14{rows=1:lng} := algebra.markT(x7{rows=1:lng},0@0);# 11 x14:bat[:oid,:oid] := ALGtmark(x7:bat[:oid,:oid], _26:oid) {G}
    x15{rows=1:lng} := bat.reverse(x14{rows=1:lng});# 12 x15:bat[:oid,:oid] := BKCreverse(x14:bat[:oid,:oid]) {G}
    x16{rows=1:lng} := algebra.join(x15{rows=1:lng},x1{notnil=true,rows=1:lng,bid=769});# 13 x16:bat[:oid,:int] := ALGjoin(x15:bat[:oid,:oid], x1:bat[:oid,:int]) {G}
    _46 := bpm.new(:oid,:int);          # 14 _46:bat[:oid,:int] := BPMnew(_47:oid, _48:int) {G}
    x19{rows=1:lng} := nil:bat[:oid,:int];# 15 x19:bat[:oid,:int] := _50:bat[:oid,:int] {G}
barrier x17{notnil=true,rows=1:lng,bid=772} := bpm.newIterator(bpm19);# 16 x17:bat[:oid,:int] := BPMnewIterator(bpm19:bat[:oid,:int]) {GJ20}
    x19{rows=1:lng} := algebra.join(x15{rows=1:lng},x17{notnil=true,rows=1:lng,bid=772});# 17 x19:bat[:oid,:int] := ALGjoin(x15:bat[:oid,:oid], x17:bat[:oid,:int]) {G}
    bpm.addPartition(_46,x19{rows=1:lng});# 18 _52:void := BPMaddPartition(_46:bat[:oid,:int], x19:bat[:oid,:int]) 
    redo x17{notnil=true,rows=1:lng,bid=772} := bpm.hasMoreElements(bpm19);# 19 x17:bat[:oid,:int] := BPMhasMoreElements(bpm19:bat[:oid,:int]) {GJ17}
exit x17{notnil=true,rows=1:lng,bid=772};# 20 x17:bat[:oid,:int] 
    x19{rows=1:lng} := bpm.fold(_46);   # 21 x19:bat[:oid,:int] := BPMfold(_46:bat[:oid,:int]) {G}
    x33 := algebra.reuse(x19{rows=1:lng});# 22 x33:bat[:oid,:int] := ALGreuse(x19:bat[:oid,:int]) {G}
    x20{rows=1:lng} := batcalc.+(x33,x16{rows=1:lng},x19{rows=1:lng});# 23 x20:bat[:oid,:int] := CMDbataccumADD_int_int_int(x33:bat[:oid,:int], x16:bat[:oid,:int], x19:bat[:oid,:int]) {G}
    x20{rows=1:lng} := batcalc.+(x20{rows=1:lng},x20{rows=1:lng},x16{rows=1:lng});# 24 x20:bat[:oid,:int] := CMDbataccumADD_int_int_int(x20:bat[:oid,:int], x20:bat[:oid,:int], x16:bat[:oid,:int]) {G}
    x21 := sql.resultSet(1,1,x20{rows=1:lng});# 25 x21:void := MDBdummy(_13:int, _13:int, x20:bat[:oid,:int]) 
    sql.rsColumn(x21,"sys.","sqlxaddxsqlxaddxi","int",32,0,x20{rows=1:lng});# 26 _33:void := MDBdummy(x21:void, _34:str, _35:str, _36:str, _37:int, _9:int, x20:bat[:oid,:int]) 
    sql.exportResult(x21,"");           # 27 _38:void := MDBdummy(x21:void, _39:str) 
catch SQLexception;                     # 28 SQLexception:str {J33}
    bpm.garbage(bpm10);                 # 29 _57:void := BPMgarbage(bpm10:bat[:oid,:int]) 
    bpm.garbage(bpm15);                 # 30 _58:void := BPMgarbage(bpm15:bat[:oid,:int]) 
    bpm.garbage(bpm19);                 # 31 _59:void := BPMgarbage(bpm19:bat[:oid,:int]) 
    raise SQLexception;                 # 32 SQLexception:str 
exit SQLexception;                      # 33 SQLexception:str 
    bpm.garbage(bpm10);                 # 34 _62:void := BPMgarbage(bpm10:bat[:oid,:int]) 
    bpm.garbage(bpm15);                 # 35 _63:void := BPMgarbage(bpm15:bat[:oid,:int]) 
    bpm.garbage(bpm19);                 # 36 _64:void := BPMgarbage(bpm19:bat[:oid,:int]) 
end query;                              # 37  

# 09:41:13 >  
# 09:41:13 >  Done.
# 09:41:13 >  

