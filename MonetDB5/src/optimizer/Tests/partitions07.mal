#testing the BAT partition manager
# use a fake sql library
# see how you handle an aggregation
module sql;
pattern bind(s:str,t:str,i:str,flag:int):bat[:oid,:int]
address MDBdummy;
pattern rsColumn(b:any...):void
address MDBdummy;
pattern resultSet(b:any...):void
address MDBdummy;
pattern exportResult(b:any...):void
address MDBdummy;
pattern exportValue(b:any...):void
address MDBdummy;

#explain select sin(i) from t;

function query(A0:sht):void;
    x1:bat[:oid,:int]{notnil=true,rows=1:lng,bid=769}  := sql.bind("sys","t","i",0);
    x6:bat[:oid,:int]{notnil=true,rows=0:lng,bid=1435}  := sql.bind("sys","t","i",1);
    constraints.emptySet(x6);
    x8:bat[:oid,:int]{notnil=true,rows=0:lng,bid=1436}  := sql.bind("sys","t","i",2);
    constraints.emptySet(x8);
    x11{rows=1:lng} := algebra.markT(x1,0@0);
    x12{rows=1:lng} := bat.reverse(x11);
    x13{rows=1:lng} := algebra.join(x12,x1);
    x14{rows=1:lng} := batcalc.flt(x13);
    x31 := bat.new(nil:oid,nil:flt);
barrier (x35,x36,x37):= bat.newIterator(x14);
    x39 := mmath.sin(x37);
    bat.insert(x31,x36,x39);
    redo (x35,x36,x37):= bat.hasMoreElements(x14);
catch MALException:str ;
    redo (x35,x36,x37):= bat.hasMoreElements(x14);
exit MALException:str ;
exit (x35,x36,x37);
    x15:bat[:oid,:flt]  := x31;
    x18 := sql.resultSet(1,1,x15);
    sql.rsColumn(x18,"sys.","sinxi","real",24,0,x15);
    sql.exportResult(x18,"");
end query;
optimizer.partitions("sql","query");
mdb.list("sql","query");
