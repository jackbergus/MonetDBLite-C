stdout of test 'partitions02` in directory 'src/optimizer` itself:


# 22:44:54 >  
# 22:44:54 >  Mtimeout -timeout 60 mserver5 "--config=/ufs/mk/monet5/Linux/etc/monetdb5.conf" --debug=10 --set "monet_mod_path=/ufs/mk/monet5//Linux/lib/MonetDB5:/ufs/mk/monet5//Linux/lib/MonetDB5/lib:/ufs/mk/monet5//Linux/lib/MonetDB5/bin" --set "gdk_dbfarm=/ufs/mk/monet5//Linux/var/MonetDB5/dbfarm" --set "sql_logdir=/ufs/mk/monet5//Linux/var/MonetDB5/sql_logs" --set "xquery_logdir=/ufs/mk/monet5//Linux/var/MonetDB5/xquery_logs" --set mapi_port=39818 --set xrpc_port=40069 --set monet_prompt= --trace --dbname=mTests_src_optimizer  partitions02.mal
# 22:44:54 >  

# MonetDB Server v5.0.0_beta2_1
# Copyright (c) 1993-2007 CWI, all rights reserved
# Compiled for x86_64-redhat-linux-gnu/64bit with 64bit OIDs dynamically linked
# dbname:mTests_src_optimizer
# Visit http://monetdb.cwi.nl/ for further information
##testing the BAT partition manager
## use a fake sql library
## see how you handle an aggregation
#module sql;
#pattern bind(s:str,t:str,i:str,flag:int):bat[:oid,:int]
pattern sql.bind(s:str,t:str,i:str,flag:int):bat[:oid,:int] address MDBdummy;#  0 bind:bat[:oid,:int] := sql.bind(s:str, t:str, i:str, flag:int) {G}
#pattern rsColumn(b:any...):void
pattern sql.rsColumn(b:any...):void address MDBdummy;#  0 rsColumn:void := sql.rsColumn(b:any) {P}
#pattern resultSet(b:any...):void
pattern sql.resultSet(b:any...):void address MDBdummy;#  0 resultSet:void := sql.resultSet(b:any) {P}
#pattern exportResult(b:any...):void
pattern sql.exportResult(b:any...):void address MDBdummy;#  0 exportResult:void := sql.exportResult(b:any) {P}
#pattern exportValue(b:any...):void
pattern sql.exportValue(b:any...):void address MDBdummy;#  0 exportValue:void := sql.exportValue(b:any) {P}
#
##select count(*) from x
#function query(A0:sht):void;
#    x1:bat[:oid,:int]{notnil=true,rows=0,bid=765}  := sql.bind("sys","x","i",0);
#    x6:bat[:oid,:int]{notnil=true,rows=0,bid=769}  := sql.bind("sys","x","i",1);
#    constraints.emptySet(x6);
#    x8:bat[:oid,:int]{notnil=true,rows=0,bid=771}  := sql.bind("sys","x","i",2);
#    constraints.emptySet(x8);
#    x11{rows=0} := algebra.markT(x1,0@0);
#    x12{rows=0} := bat.reverse(x11);
#    x13{rows=1} := aggr.count(x12);
#    sql.exportValue(1,"sys.","countx","int",32,0,6,x13,"");
#end query;
function sql.query(A0:sht):void;        #  0 query:void := sql.query(A0:sht) {G}
    x1:bat[:oid,:int] {notnil=true,rows=0,bid=765} := sql.bind("sys","x","i",0);#  1 x1:bat[:oid,:int] := MDBdummy(_6:str, _7:str, _8:str, _4:int) {G}
    x6:bat[:oid,:int] {notnil=true,rows=0,bid=769} := sql.bind("sys","x","i",1);#  2 x6:bat[:oid,:int] := MDBdummy(_6:str, _7:str, _8:str, _11:int) {G}
    constraints.emptySet(x6{notnil=true,rows=0,bid=769});#  3 _12:void := CemptySet(x6:bat[:oid,:int]) 
    x8:bat[:oid,:int] {notnil=true,rows=0,bid=771} := sql.bind("sys","x","i",2);#  4 x8:bat[:oid,:int] := MDBdummy(_6:str, _7:str, _8:str, _15:int) {G}
    constraints.emptySet(x8{notnil=true,rows=0,bid=771});#  5 _16:void := CemptySet(x8:bat[:oid,:int]) 
    x11{rows=0} := algebra.markT(x1{notnil=true,rows=0,bid=765},0@0);#  6 x11:bat[:oid,:oid] := ALGtmark(x1:bat[:oid,:int], _18:oid) {G}
    x12{rows=0} := bat.reverse(x11{rows=0});#  7 x12:bat[:oid,:oid] := BKCreverse(x11:bat[:oid,:oid]) {G}
    x13{rows=1} := aggr.count(x12{rows=0});#  8 x13:lng := ALGcount_bat(x12:bat[:oid,:oid]) 
    sql.exportValue(1,"sys.","countx","int",32,0,6,x13{rows=1},"");#  9 _21:void := MDBdummy(_11:int, _22:str, _23:str, _24:str, _25:int, _4:int, _26:int, x13:lng, _27:str) 
end query;	# 10  
#optimizer.partitions("sql","query");
#mdb.list("sql","query");
#
function user.main():void;              #  0 main:void := user.main() {G}
#testing the BAT partition manager 
# use a fake sql library 
# see how you handle an aggregation 
#select count(*) from x 
    mdb.list("sql","query");            #  5 _8:void := MDBlist3(_6:str, _7:str) 
end main;	# 6  
function sql.query(A0:sht):void;        #  0 query:void := sql.query(A0:sht) {G}
    x1:bat[:oid,:int] {notnil=true,rows=0,bid=765} := sql.bind("sys","x","i",0);#  1 x1:bat[:oid,:int] := MDBdummy(_6:str, _7:str, _8:str, _4:int) {G}
    x6:bat[:oid,:int] {notnil=true,rows=0,bid=769} := sql.bind("sys","x","i",1);#  2 x6:bat[:oid,:int] := MDBdummy(_6:str, _7:str, _8:str, _11:int) {G}
    bpm9:bat[:oid,:int]  := bpm.unfold(x6{notnil=true,rows=0,bid=769});#  3 bpm9:bat[:oid,:int] := BPMunfold(x6:bat[:oid,:int]) {G}
    bpm.emptySet(bpm9);                 #  4 _12:void := BPMemptySet(bpm9:bat[:oid,:int]) 
    x8:bat[:oid,:int] {notnil=true,rows=0,bid=771} := sql.bind("sys","x","i",2);#  5 x8:bat[:oid,:int] := MDBdummy(_6:str, _7:str, _8:str, _15:int) {G}
    bpm13:bat[:oid,:int]  := bpm.unfold(x8{notnil=true,rows=0,bid=771});#  6 bpm13:bat[:oid,:int] := BPMunfold(x8:bat[:oid,:int]) {G}
    bpm.emptySet(bpm13);                #  7 _16:void := BPMemptySet(bpm13:bat[:oid,:int]) 
    x11{rows=0} := algebra.markT(x1{notnil=true,rows=0,bid=765},0@0);#  8 x11:bat[:oid,:oid] := ALGtmark(x1:bat[:oid,:int], _18:oid) {G}
    x12{rows=0} := bat.reverse(x11{rows=0});#  9 x12:bat[:oid,:oid] := BKCreverse(x11:bat[:oid,:oid]) {G}
    x13{rows=1} := aggr.count(x12{rows=0});# 10 x13:lng := ALGcount_bat(x12:bat[:oid,:oid]) 
    sql.exportValue(1,"sys.","countx","int",32,0,6,x13{rows=1},"");# 11 _21:void := MDBdummy(_11:int, _22:str, _23:str, _24:str, _25:int, _4:int, _26:int, x13:lng, _27:str) 
catch SQLexception;                     # 12 SQLexception:str {J16}
    bpm.garbage(bpm9);                  # 13 _34:void := BPMgarbage(bpm9:bat[:oid,:int]) 
    bpm.garbage(bpm13);                 # 14 _35:void := BPMgarbage(bpm13:bat[:oid,:int]) 
    raise SQLexception;                 # 15 SQLexception:str 
exit SQLexception;                      # 16 SQLexception:str 
    bpm.garbage(bpm9);                  # 17 _38:void := BPMgarbage(bpm9:bat[:oid,:int]) 
    bpm.garbage(bpm13);                 # 18 _39:void := BPMgarbage(bpm13:bat[:oid,:int]) 
end query;                              # 19  

# 22:44:54 >  
# 22:44:54 >  Done.
# 22:44:54 >  

