@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2005 CWI.
@' All Rights Reserved.
@' 

@f mal_multiplex
@a M. Kersten
@-
@node Multiplex Compiler, Garbage Collector,  Peephole Optimization, Optimizer toolkit
@+ Multiplex Compilation
The MonetDB operator multiplex concept has been pivotal to
easily apply any scalar function to elements in a containers.
Any operator @code{cmd} came with its multiplex variant [@code{cmd}].
Given the signature @code{cmd(T1,..,Tn) : Tr}, it could be
applied also as
@code{[CMD](bat[:any_1,:T1],...,bat[any_1,Tn]) :bat[any_1,Tr]}.

The semantics of the multiplex is to perform the
natural join on all bat-valued parameters, and to execute the 
CMD for each combination of matching tuples. All results are 
collected in a result BAT. 
All but one argument may be replaced by a scalar value.

The generic solution to the multiplex operators is to translate
them to a MAL loop. A snippet of its behaviour:
@verbatim
    b:= bbp.new(:int,:int);
    bat.insert(b,1,1);
    c:bat[:int,:int]:= optimizer.multiplex("calc.+",b,1);
@end verbatim
The current implementation requires the target type to be mentioned
explicitly. The result of the optimizer is:
@verbatim
    b := bbp.new(:int,:int);
    bat.insert(b,1,1);
    _8 := bbp.new(:int,:int);
barrier (_11,_12,_13):= chopper.newIterator(b);
    _15 := calc.+(_13,1);
    bat.insert(_8,_12,_15);
catch MALexception;
exit MALexception;
    redo (_11,_12,_13):= chopper.hasMoreElements(b);
exit (_11,_12,_13);
    c := _8;
@end verbatim

@-
[WARNING] the semantics does not align precisely with M4.
For, in search for efficient
operators we assume aligned BATs and the script version does
not deal with duplicates in the head of the bats.
[/WARNING]
@{
@h
#ifndef _OPT_MULTIPLEX_H_
#define _OPT_MULTIPLEX_H_
#include "mal.h"
#include "mal_builder.h"
#include "optimizer.h"

opt_export str OPTexpandMultiplex(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
#endif /* _OPT_MULTIPLEX_H_ */

@+ Code generation
The MAL block is replaced by a new one, with the multiplex
code in place.
The subsequent call to the typechecker ensures we end up with
a valid program.
@c
#include "mal_multiplex.h"
#include "mal_interpreter.h"
#include "mal_optimizer.h"

@-
The generic solution to the multiplex operators is to translate
them to a MAL loop. 
The call optimizer.multiplex(CMD,A1,...An) introduces the following code
structure:

@verbatim
	resB:= bbp.new(A1);
barrier (mloop,h,t):= chopper.newIterator(A1);
	$1:= bat.find(A1,h);
	$2:= A2;	# in case of constant?
	...
	cr:= mod.CMD($1,...,$n);
	bat.insert(resB,h,cr);
	redo (mloop,h,t):= chopper.hasMoreElements(A1);
end mloop;
@end verbatim

The algorithm consists of two phases: phase one deals with
collecting the relevant information, phase two is the actual
code construction.
@= malInstr
	q= newInstruction(EXITsymbol);
	pushReturn(mb,q,@2);
	pushInstruction(mb,q);
@c
str
OPTexpandMultiplex(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	int i, k, mloop, resB, iter, cr;
	int hvar, tvar;
	str newFcn = (str) getVarLiteral(mb, getArg(pci, 1));
	str mod = newFcn, fcn;
	str msg = MAL_SUCCEED;
	int alias[MAXARG];
	char buf[128];
	InstrPtr q;

	(void) stk;
	strcpy(buf, newFcn);
	if (newFcn && (fcn = strchr(buf, '.'))) {
		mod = buf;
		*fcn = 0;
		fcn++;
	} else {
		mod = "unknownModule";
		fcn = buf;
	}
	/* search the iterator bat */
	iter = getArg(pci, 2);

	for (i = 2; i < pci->argc; i++)
		if (isaBatType(getArgType(mb, pci, i))) {
			iter = getArg(pci, i);

			break;
		}
#ifdef DEBUG_OPT_MULTIPLEX
	printf("calling the optimize multiplex script routine\n");
	printf("multiplex against operator %s \n", s);
#endif
@-
Beware, the operator constant (arg=1) is passed along as well,
because in the end we issue a recursive function call that should
find the actual arguments at the proper place of the callee.
@c
	/* resB := new(refBat) */
	q = newFcnCall(mb, "bbp", "new");
	resB = getArg(q, 0);
	if (isAnyExpression(getArgType(mb, pci, 0)))
		msg = throwMessage("optimizer.multiplex", "Target type is missing");
	pushArgument(mb, q, newTypeVariable(mb, getHeadType(getArgType(mb, pci, 0))));
	pushArgument(mb, q, newTypeVariable(mb, getTailType(getArgType(mb, pci, 0))));
	setVarUsed(mb, resB, TRUE);
	setVarInitialized(mb, resB);

	/* barrier (mloop,h,r):= newIterator(refBat); */
	q = newFcnCall(mb, "chopper", "newIterator");
	q->barrier = BARRIERsymbol;
	getArg(q, 0) = mloop = newTmpVariable(mb, TYPE_lng);
	setVarUsed(mb, mloop, TRUE);
	setVarInitialized(mb, mloop);
	hvar = newTmpVariable(mb, TYPE_any);
	setVarUsed(mb, hvar, TRUE);
	setVarInitialized(mb, hvar);
	pushReturn(mb, q, hvar);
	tvar = newTmpVariable(mb, TYPE_any);
	pushReturn(mb, q, tvar);
	setVarUsed(mb, tvar, TRUE);
	setVarInitialized(mb, tvar);
	pushArgument(mb, q, iter);

	/* $1:= bat.find(Ai,h) or constant */
	alias[2] = tvar;

	for (i = 3; i < pci->argc; i++)
		if (isaBatType(getArgType(mb, pci, i))) {
			q = newFcnCall(mb, "algebra", "find");
			alias[i] = newTmpVariable(mb, getTailType(getArgType(mb, pci, i)));
			setVarUsed(mb, alias[i], TRUE);
			setVarInitialized(mb, alias[i]);
			getArg(q, 0) = alias[i];
			pushArgument(mb, q, getArg(pci, i));
			pushArgument(mb, q, hvar);
		}

	/* cr:= mod.CMD($1,...,$n); */
	q = newFcnCall(mb, mod, fcn);
	cr = getArg(q, 0) = newTmpVariable(mb, TYPE_any);
	setVarUsed(mb, cr, TRUE);
	setVarInitialized(mb, cr);

	for (i = 2; i < pci->argc; i++)
		if (isaBatType(getArgType(mb, pci, i))) {
			pushArgument(mb, q, alias[i]);
		} else {
			q = pushArgument(mb, q, getArg(pci, i));
		}

	/* insert(resB,h,cr); */
	q = newFcnCall(mb, "bat", "insert");
	setVarUsed(mb, resB, TRUE);
	setVarInitialized(mb, resB);
	pushArgument(mb, q, resB);
	pushArgument(mb, q, hvar);
	pushArgument(mb, q, cr);

/* catch   MALexception and ignore them  and replace value with nil*/
	q = newInstruction(CATCHsymbol);
	k = newVariable(mb, GDKstrdup("MALexception"), TYPE_str);
	pushReturn(mb, q, k);
	setVarUsed(mb, k, TRUE);
	setVarInitialized(mb, k);
	pushInstruction(mb, q);
	@:malInstr(EXIT, k)@


/* redo (mloop,h,r):= hasMoreElements(refBat); */
	q = newFcnCall(mb, "chopper", "hasMoreElements");
	q->barrier = REDOsymbol;
	getArg(q, 0) = mloop;
	pushReturn(mb, q, hvar);
	pushReturn(mb, q, tvar);
	pushArgument(mb, q, iter);

	q = newAssignment(mb);
	q->barrier = EXITsymbol;
	getArg(q, 0) = mloop;
	pushReturn(mb, q, hvar);
	pushReturn(mb, q, tvar);

	q = newAssignment(mb);
	getArg(q, 0) = getArg(pci, 0);
	setVarUsed(mb, getArg(q, 0), TRUE);
	setVarInitialized(mb, getArg(q, 0));
	pushArgument(mb, q, resB);
	return msg;
}

@}
