@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2006 CWI.
@' All Rights Reserved.

@f opt_aliases
@-
@node Alias Removal, Dead Code Removal, Toolkit, Toolkit
@- Alias Removal
The routine @code{optimizer.aliasRemoval()}
walks through the program looking for simple
assignment statements, e.g. V:=W. It replaces all subsequent
occurrences of V by W, provided V is assigned a value once and
W does not change in the remainder of the code.
Special care should be taken for iterator blocks as illustrated in
the case below:
@verbatim
	i:=0;
	b:= "done";
barrier go:= true;
	c:=i+1;
	d:="step";
	v:=d;
	io.print(v);
	i:=c;
redo go:= i<2;
exit go;
	io.print(b);
	optimizer.aliasRemoval();
@end verbatim
The constant strings are propagated to the @code{print()} routine, while
the initial assigment @code{i:=0} should be retained. The code block becomes:
@verbatim
	i:=0;
barrier go:= true;
	c:=i+1;
	io.print("step");
	i:=c;
redo go:= i<2;
exit go;
	io.print("done");
@end verbatim
@{
@mal
pattern optimizer.aliases():str
address OPTaliases;
pattern optimizer.aliases(mod:str, fcn:str):str
address OPTaliases
comment "Alias removal optimizer";
@-
The key decision is to find the next statement that
changes the candidate. 
Beware that parameters could be changed as part of a call.
They are marked as unsafe.
@h
#ifndef _OPT_ALIASES_
#define _OPT_ALIASES_
#include "opt_prelude.h"
#include "opt_support.h"
#include "mal_interpreter.h"

/* #define DEBUG_OPT_REDUCE     show partial result */

opt_export int OPTaliasStep(MalBlkPtr mb, int pc);
#endif
@c

@c
#include "opt_aliases.h"
@c
static int
OPTnxtAssignment(MalBlkPtr mb, int pc, int varid)
{
	int i, k, blkcount = 0, used = 0;
	InstrPtr q;

	for (i = pc; i < mb->stop && isAlife(mb, varid, i); i++) {
		q = getInstrPtr(mb, i);
		for (k = 0; k < q->retc; k++)
			if (q->argv[k] == varid)
				goto ARfound;
		for (; k < q->argc; k++)
			if (q->argv[k] == varid) {
				used++;
				if (!isInvariant(mb, pc, i, varid))
					goto ARfound;
			}
		if (blockStart(q))
			blkcount++;
		if (blockExit(q))
			blkcount--;
		if (blockCntrl(q))
			blkcount--;
		if (blkcount < 0)
			break;	/* it is part of a block */
		if (blockCntrl(q))
			blkcount++;
	}
	  ARfound:
	if (blkcount || !used)
		return pc - 1;
	return i;
}

@-
When you propagate an alias through the program, the properties
maintained should also be updated. In particular, the lifespan
of the alias changes as part of the move.

Alias removal is targeted at simple assignments only,
because MAL does not allow for nested expressions.
Instructions changing the flow of control should also be ignored.
In all other cases the target variables are potential candidates
for alias removal.
@c
int
OPTaliasStep(MalBlkPtr mb, int pc)
{
	int k, kn = 0;
	InstrPtr p;

	p = getInstrPtr(mb, pc);
	if (p == 0 || getModuleId(p) || getFunctionId(p))
		return pc;
	if (p->token != ASSIGNsymbol)
		return pc;
	if (blockStart(p) || blockExit(p) || blockCntrl(p))
		return pc;

	/* trap identity assignments */
	if( getArg(p,0)== getArg(p,1) && p->argc == 2) 
		kn = p->retc;
	else
	for (k = 0; k < p->retc; k++) {
		int m;

		m = OPTnxtAssignment(mb, pc + 1, p->argv[k]);
		if (m != pc) {
			replaceAlias(mb, pc + 1, m, p->argv[k], p->argv[p->retc + k]);
			kn++;
#ifdef DEBUG_OPT_OPTIMIZER
			stream_printf(GDKout, "Delete alias assignment\n");
			printInstruction(GDKout, mb, p, LIST_MAL_ALL);
#endif
		}
	}
	/* delete the instruction if all targets have been replaced */
	if (kn == p->retc && kn) {
		/* all target variables pushed through */
		removeInstruction(mb, p);
		setLifespan(mb);
		return pc - 1;
	}
	return pc;
}

static int
OPTaliasesImplementation
(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	int i, oldstop;

	(void) stk;
#ifdef DEBUG_OPT_OPTIMIZER
	stream_printf(GDKout, "start alias removal\n");
	printFunction(GDKout, mb, LIST_MAL_ALL);
#endif
	setLifespan(mb);
	oldstop= mb->stop;
	for (i = 1; i < mb->stop; i++)
		i = OPTaliasStep(mb, i);
	return oldstop-mb->stop-(pci?1:0);
}
@include optimizerWrapper.mx
@h
@:exportOptimizer(aliases)@
@c
@:wrapOptimizer(aliases,OPT_CHECK_ALL)@
@}
