@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2006 CWI.
@' All Rights Reserved.

@f opt_aliases
@- Alias Removal
The routine @sc{optimizer.aliasRemoval()}
walks through the program looking for simple
assignment statements, e.g. V:=W. It replaces all subsequent
occurrences of V by W, provided V is assigned a value once and
W does not change in the remainder of the code.
Special care should be taken for iterator blocks as illustrated in
the case below:
@verbatim
	i:=0;
	b:= "done";
barrier go:= true;
	c:=i+1;
	d:="step";
	v:=d;
	io.print(v);
	i:=c;
redo go:= i<2;
exit go;
	io.print(b);
	optimizer.aliasRemoval();
@end verbatim
The constant strings are propagated to the @sc{print()} routine, while
the initial assigment @sc{i:=0} should be retained. The code block becomes:
@verbatim
	i:=0;
barrier go:= true;
	c:=i+1;
	io.print("step");
	i:=c;
redo go:= i<2;
exit go;
	io.print("done");
@end verbatim
@{
@mal
pattern optimizer.aliases():str
address OPTaliases;
pattern optimizer.aliases(mod:str, fcn:str):str
address OPTaliases
comment "Alias removal optimizer";
@-
The key decision is to find the next statement that
changes the candidate. 
Beware that parameters could be changed as part of a call.
They are marked as unsafe.
@h
#ifndef _OPT_ALIASES_
#define _OPT_ALIASES_
#include "opt_prelude.h"
#include "opt_support.h"
#include "mal_interpreter.h"

/* #define DEBUG_OPT_ALIASES      show partial result */

opt_export int OPTaliasStep(MalBlkPtr mb, int pc);
#endif
@-
When you propagate an alias through the program, the properties
maintained should also be updated. In particular, the lifespan
of the alias changes as part of the move.

Alias removal is targeted at simple assignments only,
because MAL does not allow for nested expressions.
Instructions changing the flow of control should also be ignored.
In all other cases the target variables are potential candidates
for alias removal.
@-
The new aliasremoval code performs a single scan through the
code. We are currently only interested in simple V:=W
expressions.
@c
#include "opt_aliases.h"
static int
OPTisAlias(InstrPtr p){
	if( p->token == ASSIGNsymbol &&
		p->barrier == 0 && 
		p->argc == 2)
		return TRUE;
	return FALSE;
}

static void
OPTremap(InstrPtr p, int *alias){
	int i;
	for(i=0;i<p->argc; i++)
		getArg(p,i)= alias[getArg(p,i)];
}

static int
OPTaliasesImplementation(MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	int i,k=1, limit, actions=0;
	int *alias;

	(void) stk;
	alias= (int*) alloca(sizeof(int)* mb->vtop);
	for(i=0; i<mb->vtop; i++) alias[i]=i;

	setLifespan(mb);
	limit= mb->stop;
	for (i = 1; i < limit; i++){
		p= getInstrPtr(mb,i);
		mb->stmt[k++]= p;
		if( OPTisAlias(p)){
			if( p->argc ==2 && getLastUpdate(mb,getArg(p,0)) == i  &&
				getBeginLifespan(mb,getArg(p,0)) == i  &&
				getLastUpdate(mb,getArg(p,1)) < i ){
				alias[getArg(p,0)]= alias[getArg(p,1)];
				freeInstruction(p);
				actions++;
				k--;
			} else
				OPTremap(p,alias);
		} else
			OPTremap(p,alias);
	}
	for(i=k; i<limit; i++)
		mb->stmt[i]= NULL;
	mb->stop= k;
	return actions;
}
@include optimizerWrapper.mx
@h
@:exportOptimizer(aliases)@
@c
@:wrapOptimizer(aliases,OPT_CHECK_ALL)@
@}
