@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2007 CWI.
@' All Rights Reserved.

@f opt_remap
@- Remapping functions.
Sometimes functions used by front-end should be re-routed
towards their proper module of interest.
A good example are is the
multiplex instruction, which can be implemented in several ways.
The bottom line implementation is the iterator produced
in @code{mal.multiplex}. Often, however, there are
already highly tuned multiplex implementations. 
They have to be located amongst the modules.

The mapping policy adhired to in the libraries is to store the
multiplex variants for module M in batM.

An illustrative example is the following MAL snippet:
@verbatim
	V1 := bat.new(:oid,:int);
	V2 := remap.multiplex("calc","+",V1,1);
	optimizer.remap();
@end verbatim
The remap optimizer trims this program to the following short block:
@verbatim
	V1 := bat.new(:oid,:int);
	V2 := batcalc.+(V1,1);
@end verbatim
@{
@mal
pattern optimizer.remap():str
address OPTremap;
pattern optimizer.remap(mod:str, fcn:str):str
address OPTremap
comment "Remapping function calls to a their multiplex variant";
@-
Use a dummy signature to catch the function calls of interest.
@mal
module mal;
pattern mal.multiplex(a:any...):any
address OPTremapMultiplex;
@h
#ifndef _OPT_REMAP_
#define _OPT_REMAP_

#include "opt_prelude.h"
#include "opt_support.h"
#include "mal_interpreter.h"
#include "mal_instruction.h"
#include "mal_function.h"
#include "mal_exception.h"

/* #define DEBUG_OPT_REMAP       trace its behavior */

opt_export str OPTremapMultiplex(MalBlkPtr mb, MalStkPtr stk, InstrPtr p);

@-
The first attempt of the multiple optimizer is to locate
a properly typed multi-plexed implementation.
The policy is to search for bat<mod>.<fcn> before going
into the iterator code generation.
@c
#include "mal_config.h"
#include "opt_remap.h"

static int
OPTremapDirect(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci, Module scope){
	str mod,fcn;
	char buf[1024];
	int i;
	InstrPtr p;

	(void) stk;
	mod = VALget(&getVar(mb, getArg(pci, 1))->value);
	fcn = VALget(&getVar(mb, getArg(pci, 2))->value);

	if(strncmp(mod,"bat",3)==0)
		return 0;
#ifdef DEBUG_OPT_REMAP
	stream_printf(GDKout,"found a candidate %s.%s\n",mod,fcn);
#endif
	snprintf(buf,1024,"bat%s",mod);
	p= newInstruction(mb,ASSIGNsymbol);
	setModuleId(p,putName(buf, strlen(buf)));
	setFunctionId(p,putName(fcn, strlen(fcn)));

	for(i=0; i<pci->retc; i++)
		getArg(p,0)= getArg(pci,i);
	p->retc= p->argc= pci->retc;
	for(i= pci->retc+2; i<pci->argc; i++)
		pushArgument(mb,p,getArg(pci,i));
#ifdef DEBUG_OPT_REMAP
	printInstruction(GDKout,mb,p,LIST_MAL_ALL);
#endif
	/* now see if we can resolve the instruction */
	typeChecker(scope,mb,p,TRUE);
	if( p->typechk== TYPE_UNKNOWN) {
		freeInstruction(p);
		return 0;
	}
	pushInstruction(mb,p);
#ifdef DEBUG_OPT_REMAP
	stream_printf(GDKout,"success\n");
#endif
	return 1;
}

@-
The comparison multiplex operations with a constant head may be supported
by reverse of the operation.
@c
static struct{
	char *src, *dst;
	int len;
}OperatorMap[]={
{"<", ">",1},
{">", "<",1},
{">=", "<=",2},
{"<=", ">=",2},
{"==", "==",2},
{"!=", "!=",2},
{0,0,0}};

static int
OPTremapSwitched(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci, Module scope){
	char *fcn;
	int r,i;
	(void) stk;
	(void) scope;

	if( getModuleId(pci)!= malRef &&
	    getFunctionId(pci) != multiplexRef &&
	    !isConstant(mb,getArg(pci,1)) &&
	    !isConstant(mb,getArg(pci,2)) &&
	    !isConstant(mb,getArg(pci,4)) &&
		pci->argc != 5) 
			return 0;
	fcn = VALget(&getVar(mb, getArg(pci, 2))->value);
	for(i=0;OperatorMap[i].src;i++)
	if( strcmp(fcn,OperatorMap[i].src)==0){
		/* found a candidate for a switch */
		getConstant(mb, getArg(pci, 2)).val.sval = putName(OperatorMap[i].dst,OperatorMap[i].len);
		getConstant(mb, getArg(pci, 2)).len = OperatorMap[i].len;
		r= getArg(pci,3); getArg(pci,3)=getArg(pci,4);getArg(pci,4)=r;
		r= OPTremapDirect(mb, stk, pci, scope);

		/* always restore the allocated function name */
		getConstant(mb, getArg(pci, 2)).val.sval= fcn;
		getConstant(mb, getArg(pci, 2)).len= strlen(fcn);

		if (r) return 1;

		/* restore the arguments */
		r= getArg(pci,3); getArg(pci,3)=getArg(pci,4);getArg(pci,4)=r;
	}
	return 0;
}
static int
OPTremapImplementation(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{

	InstrPtr *old, p;
	int i, limit, doit= 0;
	Client cntxt = MCgetClient();
	Module scope = cntxt->nspace;

	(void) pci;
	old = mb->stmt;
	limit = mb->stop;
	newMalBlkStmt(mb, mb->stop);

	for (i = 0; i < limit; i++) {
		p = old[i];
		if ( getModuleId(p) == malRef && 
			getFunctionId(p) == multiplexRef) {
			if(	OPTremapDirect(mb, stk, p, scope) ||
				OPTremapSwitched(mb, stk, p, scope)){
				freeInstruction(p); 
				doit++;
			} else {
				pushInstruction(mb, p);
			}
		} else
			pushInstruction(mb, p);
	}
	GDKfree(old);
	return doit;
}

str
OPTremapMultiplex(MalBlkPtr mb, MalStkPtr stk, InstrPtr p){
	(void) mb;
	(void)stk;
	(void) p;
#ifdef DEBUG_OPT_REMAP
	printInstruction(GDKout,mb,p,LIST_MAL_ALL);
#endif
	throw(MAL,"opt.remap","no implementation present");
}
@include optimizerWrapper.mx
@h
@:exportOptimizer(remap)@
#endif
@c
#include "opt_statistics.h"
@:wrapOptimizer(remap,OPT_CHECK_ALL)@
@}
