@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
@' Copyright August 2008-2009 MonetDB B.V.
@' All Rights Reserved.

@f run_octopus
@a M. Kersten
@+ Octopus scheduling
The octopus modules enable compute cloud based processing of SQL queries.
The optimizer splits a plan managed by the mitosis and mergetable into
independent functions by backtracking the instruction flow starting
at the aggregation points.
This leads to a series of MAL functions with possibly quite some
instruction overlap when run at a single node, 
which will not be a problem when the recycler is active.

The octopus scheduler takes over control of a MAL execution by
re-directing requests to multiple sites. If there are no sites known,
then the code is executed linearly as is.

The scheduler runs all tentacles asynchronously if possible.
To make our live easier, we assume that all tentacles are
grouped together in a guarded block as follows:

@verbatim
barrier (parallel,version):= scheduler.octopus(timeout);
a:= octopus.exec_qry(sitename,fcnname,version);
...
b:= octopus.exec_qry(sitename,fcnname,version);
z:= mat.pack(a,...,b);
exit (parallel,version);
@end verbatim

This way the scope of the instructions can be easily deduced.
Moreover, the underlying data flow execution facility can
be used to schedule and initiate interaction with remote sites.
The octopus scheduler merely ensures that there are enough
work threads available.

To make the octopus work, the scheduler needs a list of databases
to play with.
For the time being this consists of all the database discovered
using Merovingian and ending with the phrase 'sea'.
The default is to use the local database as a target.
@{
@mal
pattern scheduler.octopus(t:int)(:bit,version:int)
address OCTOPUSrun
comment "Run the program block in parallel, but don't wait longer then t seconds. Also fix a consistent database version.";
@h
#ifndef _RUN_OCTOPUS
#define _RUN_OCTOPUS
#include "mal.h"
#include "mal_instruction.h"
#include "mal_client.h"

#define DEBUG_RUN_OCTOPUS 		/* to trace processing */

#ifdef WIN32
#ifndef LIBRUN_OCTOPUS
#define octopus_export extern __declspec(dllimport)
#else
#define octopus_export extern __declspec(dllexport)
#endif
#else
#define octopus_export extern
#endif

octopus_export str OCTOPUSrun(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
#endif /* MAL_RUN_OCTOPUS */

@+ Octopus scheduling implementation
The discovery phase consists of establishing connections with
the (remote) database servers.
@c
#include "mal_config.h"
#include "mal_interpreter.h"
#include "mat.h"
#include "run_octopus.h"
#include "optimizer.h"
#include <mapilib/Mapi.h>
#include "remote.h"

typedef struct REGMAL{
	str fcn;
	struct REGMAL *nxt;
} *Registry;

typedef struct {
	str name;
	str usr;
	str pwd;
	Registry nxt;	/* list of registered queries */
} Sea;

#define MAXSITES 2048	/* should become dynamic at some point */
static Sea sea[MAXSITES];
static int nrsea = 0;

static str
OCTOPUSdiscover(Client cntxt){
	bat b1 = 0, b2 = 0;
	BAT *l1, *l2;
	BUN p,q;
	str msg = MAL_SUCCEED;
	BATiter bi;

	sea[nrsea].usr = GDKstrdup("monetdb");
	sea[nrsea].pwd = GDKstrdup("monetdb");
	sea[nrsea++].name= GDKstrdup(GDKgetenv("gdk_dbname"));
	/* determine if sites are reachable */
	msg = RMTgetList(&b1,&b2);
	if ( msg != MAL_SUCCEED)
		return msg;
	l1 = BATdescriptor(b1);
	if ( l1 == NULL)
		throw(MAL,"octopus.discover","No database list available");
	l2 = BATdescriptor(b2);
	if ( l2 == NULL){
		BBPreleaseref(b1);
		throw(MAL,"octopus.discover","No database list available");
	}
	/* add the databases to the working set */
	bi= bat_iterator(l1);
	BATloop(l1,p,q){
		str t= (str) BUNtail(bi,p);

		if (nrsea ==MAXSITES) break;
		if (strlen(t) >= 3 && strcmp("sea", t+strlen(t)-3) == 0){
			sea[nrsea].usr = GDKstrdup("monetdb");
			sea[nrsea].pwd = GDKstrdup("monetdb");
			sea[nrsea++].name= GDKstrdup(t);
#ifdef DEBUG_RUN_OCTOPUS
		stream_printf(cntxt->fdout,"Found site %s\n",t);
#else
		(void) cntxt;
#endif
		}
	}
#ifdef DEBUG_RUN_OCTOPUS
		stream_printf(cntxt->fdout,"Seas %d\n",nrsea);
#endif
	BBPreleaseref(b1);
	BBPreleaseref(b2);
	return MAL_SUCCEED;
}

@-
We first register the tentacle at all sites and keep
a list of those already sent.
@c
static int
OCTOPUSfind(Sea s, str qry){
	Registry r;
	for ( r= s.nxt; r; r= r->nxt)
	if ( strcmp(qry, r->fcn)==0)
		return 1;
	return 0;
}

@-
The functions called by the octopus.exec_qry are to be
registered at all sites. We assume for the time being
that all instructions registered are unique.
@c
static str
OCTOPUSregister(Client cntxt, MalBlkPtr mb, InstrPtr p)
{
	int i;
	str conn, fname, msg = MAL_SUCCEED;

	fname = getVarConstant(mb,getArg(p,2)).val.sval;
	for ( i= 0; i< nrsea; i++){
		msg= RMTconnect(&conn, &sea[i].name, &sea[i].usr, &sea[i].pwd);
		if (msg ){
			stream_printf(cntxt->fdout,"!%s\n",msg);
			GDKfree(msg);
			msg = NULL;
			continue;
		}
		if( !OCTOPUSfind(sea[i], fname) ){
			msg = RMTregisterInternal(cntxt, conn, octopusRef, fname);

#ifdef DEBUG_RUN_OCTOPUS
			stream_printf(cntxt->fdout,"octopus.%s registered at site %s\n",
				fname,sea[i].name);
			stream_printf(cntxt->fdout,"reply: %s\n",msg?msg:"ok");
#else
			(void) cntxt;
#endif
			if ( msg == MAL_SUCCEED){
				Registry r= (Registry) GDKzalloc(sizeof(struct REGMAL));
				r->fcn = GDKstrdup(getFunctionId(p));
				r->nxt = sea[i].nxt;
				sea[i].nxt = r;
			}
		}
	}
	GDKfree(conn);
	return msg;
}
@-
The work division looks at the system opportunities and
replaces the target site in all instructions.
The first policy is to simply perform round robin.
The more advanced way is to negotiat with the remote sites.
@c
static str
OCTOPUSworkdivision(Client cntxt, MalBlkPtr mb, MalStkPtr stk, int pc)
{
	static int rr=0,i;
	str msg = MAL_SUCCEED;
	InstrPtr p;
	ValPtr cst;

	for (; pc< mb->stop; pc++){
		if ( nrsea >1 && rr == 0) rr++; /* ignore default */
		p= getInstrPtr(mb,pc);
		if ( p->barrier == EXITsymbol || getFunctionId(p)== packRef)
			break;
		i = getArg(p,1);
		assert( isVarConstant(mb, i) && getVarType(mb,i)== TYPE_str);
		cst = &getVarConstant(mb, i);
		if( cst->val.sval )
			GDKfree(cst->val.sval);
		cst->val.sval= GDKstrdup(sea[rr].name);
		cst->len = strlen(cst->val.sval);
		garbageElement(cntxt, &stk->stk[i]);
		VALcopy(&stk->stk[i], cst);
#ifdef DEBUG_RUN_OCTOPUS
		stream_printf(cntxt->fdout,"octopus site selected %s\n",sea[rr].name);
		printInstruction(cntxt->fdout,mb,0,p,LIST_MAL_STMT);
#else
		(void) cntxt;
#endif
		rr= (rr+1) % nrsea;
	}
	return msg;
}
@-
The scheduler runs all tentacles asynchronously.
We should be careful in accessing a site that runs out
of clients or any failure. It may cause the system to
wait forever.

The version argument indicates the tentacles
if it is time to refresh their caches. 
It should be obtained from the recycler where we
know when updates have been taken place.
@c
str
OCTOPUSrun(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	bit *res = (bit*) getArgReference(stk,pci,0);
	int *version = (int*) getArgReference(stk,pci,1);
	int j, start, stop, threadcnt=0;
	InstrPtr p;
	str msg = MAL_SUCCEED;
	*res = 1;	/* execute the block */
	*version = 0;

	msg= OCTOPUSdiscover(cntxt);
	if ( msg )
		return msg; 

	start= getPC(mb,pci) + 1;
	for (j= start; j<mb->stop ; j++){
		p= getInstrPtr(mb,j);
		if ( p->barrier == EXITsymbol  || getFunctionId(p)== packRef)
			break;
		if (nrsea > 1) {
			msg= OCTOPUSregister(cntxt,mb,p);
			if ( msg && strstr(msg,"Function already defined remotely")==0 )
				return msg;
			threadcnt++;
		}
	}
	stop =j;

	msg= OCTOPUSworkdivision(cntxt,mb,stk,start);
	if ( msg )
		return msg;

	/* if necessary increase the worker set */
	/* DFLOWworkers(threadcnt); */
	(void) threadcnt;
	return runMALdataflow(cntxt,mb,start,stop,stk,0,pci);
}
@}
