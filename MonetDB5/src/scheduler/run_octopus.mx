@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
@' Copyright August 2008-2009 MonetDB B.V.
@' All Rights Reserved.

@f run_octopus
@a M. Kersten
@+ Octopus scheduling
The octopus modules enable compute cloud based processing of SQL queries.
The optimizer splits a plan managed by the mitosis and mergetable into
independent functions by backtracking the instruction flow starting
at the aggregation points.
This leads to a series of MAL functions with possibly quite some
instruction overlap when run at a single node, 
which will not be a problem when the recycler is active.

The octopus scheduler takes over control of a MAL execution by
re-directing requests to multiple sites. If there are no sites known,
then the code is executed linearly as is.

The scheduler runs all tentacles asynchronously if possible.
To make our live easier, we assume that all tentacles are
grouped together in a guarded block as follows:

@verbatim
barrier (parallel,version):= scheduler.octopus(timeout);
a:= octopus.tentacle_1(sitename,fcnname,version);
...
b:= octopus.tentacle_n(sitename,fcnname,version);
exit (parallel,version);
z:= mat.pack(a,...,b);
@end verbatim

This way the MAL flow of control simplifies skipping to the end
when parallel execution has been enacted and serial execution
simply requires opening the guarded block.

Allowing MAL instructions inbetween complicates our work,
because it would mean that we have to do a flow analysis.

To make this work the scheduler needs a list of databases to play with.
For the time being this consists of all the database known
and ending with the phrase 'sea'.
This list is obtained through the remote module using the
support of Merovingian. The default is to use the local
database as a target.
@{
@mal
pattern scheduler.octopus(t:int)(:bit,version:int)
address OCTOPUSrun
comment "Run the program block in parallel, but don't wait longer then t seconds. Also fix a consistent database version.";
@h
#ifndef _RUN_OCTOPUS
#define _RUN_OCTOPUS
#include "mal.h"
#include "mal_instruction.h"
#include "mal_client.h"

#define DEBUG_RUN_OCTOPUS 		/* to trace processing */

#ifdef WIN32
#ifndef LIBRUN_OCTOPUS
#define octopus_export extern __declspec(dllimport)
#else
#define octopus_export extern __declspec(dllexport)
#endif
#else
#define octopus_export extern
#endif

octopus_export str OCTOPUSrun(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
#endif /* MAL_RUN_OCTOPUS */

@+ Octopus scheduling implementation
The discovery phase consists of establishing connections with
the (remote) database servers.
@c
#include "mal_config.h"
#include "mal_interpreter.h"
#include "mat.h"
#include "run_octopus.h"
#include "optimizer.h"
#include <mapilib/Mapi.h>
#include "remote.h"
#include "alarm.h"

typedef struct REGMAL{
	str fcn;
	struct REGMAL *nxt;
} *Registry;

typedef struct {
	str name;
	str usr;
	str pwd;
	Registry nxt;	/* list of registered queries */
} Sea;

#define MAXSITES 2048	/* should become dynamic at some point */
static Sea sea[MAXSITES];
static int nrsea = 0;

static str
OCTOPUSdiscover(Client cntxt){
	bat b1 = 0, b2 = 0;
	BAT *l1, *l2;
	BUN p,q;
	str msg = MAL_SUCCEED;
	BATiter bi;

	sea[nrsea].usr = GDKstrdup("monetdb");
	sea[nrsea].pwd = GDKstrdup("monetdb");
	sea[nrsea++].name= GDKstrdup(GDKgetenv("gdk_dbname"));
	/* determine if sites are reachable */
	msg = RMTgetList(&b1,&b2);
	if ( msg != MAL_SUCCEED)
		return msg;
	l1 = BATdescriptor(b1);
	if ( l1 == NULL)
		throw(MAL,"octopus.discover","No database list available");
	l2 = BATdescriptor(b2);
	if ( l2 == NULL){
		BBPreleaseref(b1);
		throw(MAL,"octopus.discover","No database list available");
	}
	/* add the databases to the working set */
	bi= bat_iterator(l1);
	BATloop(l1,p,q){
		str t= (str) BUNtail(bi,p);

		if (nrsea ==MAXSITES) break;
		if (strlen(t) >= 3 && strcmp("sea", t+strlen(t)-3) == 0){
			sea[nrsea].usr = GDKstrdup("monetdb");
			sea[nrsea].pwd = GDKstrdup("monetdb");
			sea[nrsea++].name= GDKstrdup(t);
#ifdef DEBUG_RUN_OCTOPUS
		stream_printf(cntxt->fdout,"Found site %s\n",t);
#else
		(void) cntxt;
#endif
		}
	}
#ifdef DEBUG_RUN_OCTOPUS
		stream_printf(cntxt->fdout,"Seas %d\n",nrsea);
#endif
	BBPreleaseref(b1);
	BBPreleaseref(b2);
	return MAL_SUCCEED;
}

@-
We first register the tentacle at all sites and keep
a list of those already sent.
@c
static int
OCTOPUSfind(Sea s, str qry){
	Registry r;
	for ( r= s.nxt; r; r= r->nxt)
	if ( strcmp(qry, r->fcn)==0)
		return 1;
	return 0;
}

@-
The functions called by the octopus.exec_qry are to be
registered at all sites.
@c
static str
OCTOPUSregister(Client cntxt, MalBlkPtr mb, InstrPtr p)
{
	int i;
	str conn, fname, msg = MAL_SUCCEED;

	fname = getVarConstant(mb,getArg(p,2)).val.sval;
	for ( i= 0; i< nrsea; i++){
		msg= RMTconnect(&conn, &sea[i].name, &sea[i].usr, &sea[i].pwd);
		if (msg ){
			stream_printf(cntxt->fdout,"!%s\n",msg);
			GDKfree(msg);
			msg = NULL;
			continue;
		}
		if( !OCTOPUSfind(sea[i], fname) ){
			msg = RMTregisterInternal(cntxt, conn, octopusRef, fname);

#ifdef DEBUG_RUN_OCTOPUS
			stream_printf(cntxt->fdout,"octopus.%s registered at site %s\n",
				fname,sea[i].name);
			stream_printf(cntxt->fdout,"reply: %s\n",msg?msg:"ok");
#else
			(void) cntxt;
#endif
			if ( msg == MAL_SUCCEED){
				Registry r= (Registry) GDKzalloc(sizeof(struct REGMAL));
				r->fcn = GDKstrdup(getFunctionId(p));
				r->nxt = sea[i].nxt;
				sea[i].nxt = r;
			}
		}
	}
	GDKfree(conn);
	return msg;
}
@-
The work division looks at the system opportunities and
replaces the target site in all instructions.
The first policy is to simply perform round robin.
The more advanced way is to negotiat with the remote sites.
@c
static str
OCTOPUSworkdivision(Client cntxt, MalBlkPtr mb, int pc)
{
	static int rr=0;
	str msg = MAL_SUCCEED;
	InstrPtr p;
	ValPtr cst;

	for (; pc< mb->stop; pc++){
		if ( nrsea >1 && rr == 0) rr++; /* ignore default */
		p= getInstrPtr(mb,pc);
		if ( p->barrier == EXITsymbol)
			break;
		assert( isVarConstant(mb, getArg(p,1)) );
		cst = &getVarConstant(mb, getArg(p,1));
		if( cst->val.sval)
			GDKfree(cst->val.sval);
		cst->val.sval= GDKstrdup(sea[rr].name);
		cst->len = strlen(cst->val.sval);
#ifdef DEBUG_RUN_OCTOPUS
		stream_printf(cntxt->fdout,"octopus site selected %s\n",sea[rr].name);
		printInstruction(cntxt->fdout,mb,0,p,LIST_MAL_STMT);
#else
		(void) cntxt;
#endif
		rr= (rr+1) % nrsea;
	}
	return msg;
}
@-
The scheduler runs all tentacles asynchronously.
The rigid structure makes it possible to wait for the
threads to end their work. We simple set them to nil
and wait for the assignments to have been completed.
The the sole remainder is the timeout, which could be
part of the scheduler arguments.

We should be careful in accessing a site that runs out
of clients or any failure. It may cause the scheduler to
wait forever.

The database version should indicate to the tentacles
if it is time to refresh their caches. 
It should be obtained from the recycler where we
know when updates have been taken place.
@c
str
OCTOPUSrun(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	int *res = (int*) getArgReference(stk,p,0);
	int *version = (int*) getArgReference(stk,p,1);
	int timeout = *(int*) getArgReference(stk,p,2);
	int j,fnd, i = getPC(mb,p), threadcnt=0;
	str msg = MAL_SUCCEED;
	*res = 0;	/* skip the block */

	*version = 0;

	if ( (msg= OCTOPUSdiscover(cntxt))  ){
#ifdef DEBUG_RUN_OCTOPUS
		stream_printf(cntxt->fdout,"#Run in local serial mode\n");
#endif
		*res = 1;
		return msg; 
	}
@-
Register the tentacle functions at all sites.
@c
	if (nrsea > 1) {
		for (j= i+1; j<mb->stop ; j++){
			p= getInstrPtr(mb,j);
			if ( p->barrier == EXITsymbol )
				break;
			msg= OCTOPUSregister(cntxt,mb,p);
			if ( msg )
				return msg;
		}
	}
	msg= OCTOPUSworkdivision(cntxt,mb,i+1);
	if ( msg )
		return msg;

	/* do the actual parallel work */
	for (i++; i<mb->stop && msg == MAL_SUCCEED; i++){
		p= getInstrPtr(mb,i);
		if ( p->barrier == EXITsymbol ){
			/* collect the results */
			do{
				fnd = 0;
				for( j=3; j<p->argc; j++)
					fnd += stk->stk[getArg(p,j)].val.bval > 0;
#ifdef DEBUG_RUN_OCTOPUS
				stream_printf(cntxt->fdout,"await answer, seen %d\n",fnd);
#endif
				MT_sleep_ms(1000);
				timeout--;
			} while ( fnd < threadcnt && timeout > 0 );
			if (timeout <= 0)
				throw(MAL,"scheduler.octopus","Execution time out");
			break;
		}
		if ( getModuleId(p) != octopusRef)
			throw(MAL,"scheduler.octopus","tentacle expected");
#ifdef DEBUG_RUN_OCTOPUS
		stream_printf(cntxt->fdout,"#Start a new thread\n");
#else
	(void) cntxt;
#endif
		msg =runMALprocess(cntxt,mb,stk, getPC(mb,p), getPC(mb,p)+1);
		threadcnt++;
	}
	return msg; 
}
@}
