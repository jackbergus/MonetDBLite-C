stdout of test 'memo01` in directory 'src/scheduler` itself:


# 22:56:36 >  
# 22:56:36 >  Mtimeout -timeout 60 mserver5 "--config=/ufs/mk/monet5/Linux/etc/monetdb5.conf" --debug=10 --set "monet_mod_path=/ufs/mk/monet5//Linux/lib/MonetDB5:/ufs/mk/monet5//Linux/lib/MonetDB5/lib:/ufs/mk/monet5//Linux/lib/MonetDB5/bin" --set "gdk_dbfarm=/ufs/mk/monet5//Linux/var/MonetDB5/dbfarm" --set "sql_logdir=/ufs/mk/monet5//Linux/var/MonetDB5/sql_logs" --set "xquery_logdir=/ufs/mk/monet5//Linux/var/MonetDB5/xquery_logs" --set mapi_port=35791 --set xrpc_port=47149 --set monet_prompt= --trace --dbname=mTests_src_scheduler  memo01.mal < /dev/null
# 22:56:36 >  

# MonetDB Server v5.0.0_beta2_1
# Copyright (c) 1993-2007 CWI, all rights reserved
# Compiled for x86_64-redhat-linux-gnu/64bit with 64bit OIDs dynamically linked
# dbname:mTests_src_scheduler
# Visit http://monetdb.cwi.nl/ for further information
## The first memo driven execution
## use local cost functions, which leads to a hill-climber
## Use the backward scheduling.
#
#	A:= bat.new(:int,:int);
#	bat.insert(A,1,1);
#	B:= algebra.copy(A);
#	bat.setWriteMode(B);
#	bat.insert(B,2,2);
#	C:= algebra.copy(B);
#	bat.setWriteMode(C);
#	bat.insert(C,3,3);
#	D:= algebra.copy(C);
#	bat.setWriteMode(D);
#	bat.insert(D,3,3);
#
#	Acost:= aggr.count(A);
#	Bcost:= aggr.count(B);
#	Ccost:= aggr.count(C);
#	Dcost:= aggr.count(D);
#	T1cost:= Acost+Bcost; 
#	T2cost:= Bcost+Ccost;
#	T3cost:= Ccost+Dcost;
#
#	scheduler.choice();
#
#	T1:= algebra.join(A,B);
#	T1cost:= aggr.count(T1);
#	T2:= algebra.join(B,C);
#	T2cost:= aggr.count(T2);
#	T3:= algebra.join(C,D);
#	T3cost:= aggr.count(T3);
#
#	scheduler.choice(T1cost,T1, T2cost,T2, T3cost,T3);
#
#	T4cost:=T1cost+Ccost; 
#	T5cost:=Acost+T2cost; 
#	T6cost:=T2cost+Dcost;
#	T7cost:=Bcost+T3cost;
#	T8cost:=Ccost+Dcost; 
#
#	T4:= algebra.join(T1,C);
#	T4cost:= aggr.count(T4);
#	T5:= algebra.join(A,T2);
#	T5cost:= aggr.count(T5);
#	T6:= algebra.join(T2,D);
#	T6cost:= aggr.count(T6);
#	T7:= algebra.join(B,T3);
#	T7cost:= aggr.count(T7);
#	T8:= algebra.join(C,D);
#	T8cost:= aggr.count(T8);
#
#	scheduler.choice(T4cost,T4,T5cost,T5,T6cost,T6,T7cost,T7,T8cost,T8);
#
#	T9cost:=T2cost+Dcost;  
#	T10cost:=T5cost+Dcost;  
#	T11cost:= Acost+T6cost;
#	T12cost:= Acost+T7cost;
#	T13cost:= T1cost+T8cost;
#
#	T9:= algebra.join(T4,D);
#	T10:= algebra.join(T5,D);
#	T11:= algebra.join(A,T6);
#	T12:= algebra.join(A,T7);
#	T13:= algebra.join(T1,T8);
#
#	scheduler.choice(T9cost,T9,T10cost,T10,T11cost,T11,T12cost,T12,T13cost,T13);
#	answer:= scheduler.pick(T9,T10,T11,T12,T13);
#	io.print(answer);
#
function user.main():void;	# 0  (main:void)
# The first memo driven execution 	# 1  (_1:str)
# use local cost functions, which leads to a hill-climber 	# 2  (_2:str)
# Use the backward scheduling. 	# 3  (_3:str)
    A := bat.new(:int,:int);	# 4 CMDBATnew (A:bat[:int,:int])<-(_5:int)(_5:int)
    bat.insert(A,1,1);	# 5 BKCinsert_bun (_6:void)<-(A:bat[:int,:int])(_7:int)(_7:int)
    B := algebra.copy(A);	# 6 ALGcopy (B:bat[:int,:int])<-(A:bat[:int,:int])
    bat.setWriteMode(B);	# 7 BKCsetWriteMode (_9:bat[:int,:int])<-(B:bat[:int,:int])
    bat.insert(B,2,2);	# 8 BKCinsert_bun (_10:void)<-(B:bat[:int,:int])(_11:int)(_11:int)
    C := algebra.copy(B);	# 9 ALGcopy (C:bat[:int,:int])<-(B:bat[:int,:int])
    bat.setWriteMode(C);	# 10 BKCsetWriteMode (_13:bat[:int,:int])<-(C:bat[:int,:int])
    bat.insert(C,3,3);	# 11 BKCinsert_bun (_14:void)<-(C:bat[:int,:int])(_15:int)(_15:int)
    D := algebra.copy(C);	# 12 ALGcopy (D:bat[:int,:int])<-(C:bat[:int,:int])
    bat.setWriteMode(D);	# 13 BKCsetWriteMode (_17:bat[:int,:int])<-(D:bat[:int,:int])
    bat.insert(D,3,3);	# 14 BKCinsert_bun (_18:void)<-(D:bat[:int,:int])(_15:int)(_15:int)
    Acost := aggr.count(A);	# 15 ALGcount_bat (Acost:int)<-(A:bat[:int,:int])
    Bcost := aggr.count(B);	# 16 ALGcount_bat (Bcost:int)<-(B:bat[:int,:int])
    Ccost := aggr.count(C);	# 17 ALGcount_bat (Ccost:int)<-(C:bat[:int,:int])
    Dcost := aggr.count(D);	# 18 ALGcount_bat (Dcost:int)<-(D:bat[:int,:int])
    T1cost := calc.+(Acost,Bcost);	# 19 CALCbinaryADDintint (T1cost:int)<-(Acost:int)(Bcost:int)
    T2cost := calc.+(Bcost,Ccost);	# 20 CALCbinaryADDintint (T2cost:int)<-(Bcost:int)(Ccost:int)
    T3cost := calc.+(Ccost,Dcost);	# 21 CALCbinaryADDintint (T3cost:int)<-(Ccost:int)(Dcost:int)
    scheduler.choice();	# 22 RUNchoice (_26:void)
    T1 := algebra.join(A,B);	# 23 ALGjoin (T1:bat[:int,:int])<-(A:bat[:int,:int])(B:bat[:int,:int])
    T1cost := aggr.count(T1);	# 24 ALGcount_bat (T1cost:int)<-(T1:bat[:int,:int])
    T2 := algebra.join(B,C);	# 25 ALGjoin (T2:bat[:int,:int])<-(B:bat[:int,:int])(C:bat[:int,:int])
    T2cost := aggr.count(T2);	# 26 ALGcount_bat (T2cost:int)<-(T2:bat[:int,:int])
    T3 := algebra.join(C,D);	# 27 ALGjoin (T3:bat[:int,:int])<-(C:bat[:int,:int])(D:bat[:int,:int])
    T3cost := aggr.count(T3);	# 28 ALGcount_bat (T3cost:int)<-(T3:bat[:int,:int])
    scheduler.choice(T1cost,T1,T2cost,T2,T3cost,T3);	# 29 RUNchoice (_30:void)<-(T1cost:int)(T1:bat[:int,:int])(T2cost:int)(T2:bat[:int,:int])(T3cost:int)(T3:bat[:int,:int])
    T4cost := calc.+(T1cost,Ccost);	# 30 CALCbinaryADDintint (T4cost:int)<-(T1cost:int)(Ccost:int)
    T5cost := calc.+(Acost,T2cost);	# 31 CALCbinaryADDintint (T5cost:int)<-(Acost:int)(T2cost:int)
    T6cost := calc.+(T2cost,Dcost);	# 32 CALCbinaryADDintint (T6cost:int)<-(T2cost:int)(Dcost:int)
    T7cost := calc.+(Bcost,T3cost);	# 33 CALCbinaryADDintint (T7cost:int)<-(Bcost:int)(T3cost:int)
    T8cost := calc.+(Ccost,Dcost);	# 34 CALCbinaryADDintint (T8cost:int)<-(Ccost:int)(Dcost:int)
    T4 := algebra.join(T1,C);	# 35 ALGjoin (T4:bat[:int,:int])<-(T1:bat[:int,:int])(C:bat[:int,:int])
    T4cost := aggr.count(T4);	# 36 ALGcount_bat (T4cost:int)<-(T4:bat[:int,:int])
    T5 := algebra.join(A,T2);	# 37 ALGjoin (T5:bat[:int,:int])<-(A:bat[:int,:int])(T2:bat[:int,:int])
    T5cost := aggr.count(T5);	# 38 ALGcount_bat (T5cost:int)<-(T5:bat[:int,:int])
    T6 := algebra.join(T2,D);	# 39 ALGjoin (T6:bat[:int,:int])<-(T2:bat[:int,:int])(D:bat[:int,:int])
    T6cost := aggr.count(T6);	# 40 ALGcount_bat (T6cost:int)<-(T6:bat[:int,:int])
    T7 := algebra.join(B,T3);	# 41 ALGjoin (T7:bat[:int,:int])<-(B:bat[:int,:int])(T3:bat[:int,:int])
    T7cost := aggr.count(T7);	# 42 ALGcount_bat (T7cost:int)<-(T7:bat[:int,:int])
    T8 := algebra.join(C,D);	# 43 ALGjoin (T8:bat[:int,:int])<-(C:bat[:int,:int])(D:bat[:int,:int])
    T8cost := aggr.count(T8);	# 44 ALGcount_bat (T8cost:int)<-(T8:bat[:int,:int])
    scheduler.choice(T4cost,T4,T5cost,T5,T6cost,T6,T7cost,T7,T8cost,T8);	# 45 RUNchoice (_41:void)<-(T4cost:int)(T4:bat[:int,:int])(T5cost:int)(T5:bat[:int,:int])(T6cost:int)(T6:bat[:int,:int])(T7cost:int)(T7:bat[:int,:int])(T8cost:int)(T8:bat[:int,:int])
    T9cost := calc.+(T2cost,Dcost);	# 46 CALCbinaryADDintint (T9cost:int)<-(T2cost:int)(Dcost:int)
    T10cost := calc.+(T5cost,Dcost);	# 47 CALCbinaryADDintint (T10cost:int)<-(T5cost:int)(Dcost:int)
    T11cost := calc.+(Acost,T6cost);	# 48 CALCbinaryADDintint (T11cost:int)<-(Acost:int)(T6cost:int)
    T12cost := calc.+(Acost,T7cost);	# 49 CALCbinaryADDintint (T12cost:int)<-(Acost:int)(T7cost:int)
    T13cost := calc.+(T1cost,T8cost);	# 50 CALCbinaryADDintint (T13cost:int)<-(T1cost:int)(T8cost:int)
    T9 := algebra.join(T4,D);	# 51 ALGjoin (T9:bat[:int,:int])<-(T4:bat[:int,:int])(D:bat[:int,:int])
    T10 := algebra.join(T5,D);	# 52 ALGjoin (T10:bat[:int,:int])<-(T5:bat[:int,:int])(D:bat[:int,:int])
    T11 := algebra.join(A,T6);	# 53 ALGjoin (T11:bat[:int,:int])<-(A:bat[:int,:int])(T6:bat[:int,:int])
    T12 := algebra.join(A,T7);	# 54 ALGjoin (T12:bat[:int,:int])<-(A:bat[:int,:int])(T7:bat[:int,:int])
    T13 := algebra.join(T1,T8);	# 55 ALGjoin (T13:bat[:int,:int])<-(T1:bat[:int,:int])(T8:bat[:int,:int])
    scheduler.choice(T9cost,T9,T10cost,T10,T11cost,T11,T12cost,T12,T13cost,T13);	# 56 RUNchoice (_52:void)<-(T9cost:int)(T9:bat[:int,:int])(T10cost:int)(T10:bat[:int,:int])(T11cost:int)(T11:bat[:int,:int])(T12cost:int)(T12:bat[:int,:int])(T13cost:int)(T13:bat[:int,:int])
    answer := scheduler.pick(T9,T10,T11,T12,T13);	# 57 RUNpickResult (answer:bat[:int,:int])<-(T9:bat[:int,:int])(T10:bat[:int,:int])(T11:bat[:int,:int])(T12:bat[:int,:int])(T13:bat[:int,:int])
    io.print(answer);	# 58 IOprint_val (_54:void)<-(answer:bat[:int,:int])
end main;	# 59  
#-----------------#
# h	t	  # name
# int	int	  # type
#-----------------#
[ 1,	  1	  ]

# 22:56:36 >  
# 22:56:36 >  Done.
# 22:56:36 >  

