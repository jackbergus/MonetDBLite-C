stdout of test 'memo01` in directory 'src/scheduler` itself:


# 22:56:36 >  
# 22:56:36 >  Mtimeout -timeout 60 mserver5 "--config=/ufs/mk/monet5/Linux/etc/monetdb5.conf" --debug=10 --set "monet_mod_path=/ufs/mk/monet5//Linux/lib/MonetDB5:/ufs/mk/monet5//Linux/lib/MonetDB5/lib:/ufs/mk/monet5//Linux/lib/MonetDB5/bin" --set "gdk_dbfarm=/ufs/mk/monet5//Linux/var/MonetDB5/dbfarm" --set "sql_logdir=/ufs/mk/monet5//Linux/var/MonetDB5/sql_logs" --set "xquery_logdir=/ufs/mk/monet5//Linux/var/MonetDB5/xquery_logs" --set mapi_port=35791 --set xrpc_port=47149 --set monet_prompt= --trace --dbname=mTests_src_scheduler  memo01.mal < /dev/null
# 22:56:36 >  

# MonetDB Server v5.0.0_beta2_1
# Copyright (c) 1993-2007 CWI, all rights reserved
# Compiled for x86_64-redhat-linux-gnu/64bit with 64bit OIDs dynamically linked
# dbname:mTests_src_scheduler
# Visit http://monetdb.cwi.nl/ for further information
## The first memo driven execution
## use local cost functions, which leads to a hill-climber
## Use the backward scheduling.
#
#	A:= bat.new(:int,:int);
#	bat.insert(A,1,1);
#	B:= algebra.copy(A);
#	bat.setWriteMode(B);
#	bat.insert(B,2,2);
#	C:= algebra.copy(B);
#	bat.setWriteMode(C);
#	bat.insert(C,3,3);
#	D:= algebra.copy(C);
#	bat.setWriteMode(D);
#	bat.insert(D,3,3);
#
#	Acost:= aggr.count(A);
#	Bcost:= aggr.count(B);
#	Ccost:= aggr.count(C);
#	Dcost:= aggr.count(D);
#	T1cost:= Acost+Bcost; 
#	T2cost:= Bcost+Ccost;
#	T3cost:= Ccost+Dcost;
#
#	scheduler.choice();
#
#	T1:= algebra.join(A,B);
#	T1cost:= aggr.count(T1);
#	T2:= algebra.join(B,C);
#	T2cost:= aggr.count(T2);
#	T3:= algebra.join(C,D);
#	T3cost:= aggr.count(T3);
#
#	scheduler.choice(T1cost,T1, T2cost,T2, T3cost,T3);
#
#	T4cost:=T1cost+Ccost; 
#	T5cost:=Acost+T2cost; 
#	T6cost:=T2cost+Dcost;
#	T7cost:=Bcost+T3cost;
#	T8cost:=Ccost+Dcost; 
#
#	T4:= algebra.join(T1,C);
#	T4cost:= aggr.count(T4);
#	T5:= algebra.join(A,T2);
#	T5cost:= aggr.count(T5);
#	T6:= algebra.join(T2,D);
#	T6cost:= aggr.count(T6);
#	T7:= algebra.join(B,T3);
#	T7cost:= aggr.count(T7);
#	T8:= algebra.join(C,D);
#	T8cost:= aggr.count(T8);
#
#	scheduler.choice(T4cost,T4,T5cost,T5,T6cost,T6,T7cost,T7,T8cost,T8);
#
#	T9cost:=T2cost+Dcost;  
#	T10cost:=T5cost+Dcost;  
#	T11cost:= Acost+T6cost;
#	T12cost:= Acost+T7cost;
#	T13cost:= T1cost+T8cost;
#
#	T9:= algebra.join(T4,D);
#	T10:= algebra.join(T5,D);
#	T11:= algebra.join(A,T6);
#	T12:= algebra.join(A,T7);
#	T13:= algebra.join(T1,T8);
#
#	scheduler.choice(T9cost,T9,T10cost,T10,T11cost,T11,T12cost,T12,T13cost,T13);
#	answer:= scheduler.pick(T9,T10,T11,T12,T13);
#	io.print(answer);
#
function user.main():void;              #  0 main:void := user.main() {G}
# The first memo driven execution 
# use local cost functions, which leads to a hill-climber 
# Use the backward scheduling. 
    A := bat.new(:int,:int);            #  4 A:bat[:int,:int] := CMDBATnew(_5:int, _5:int) {G}
    bat.insert(A,1,1);                  #  5 _6:bat[:int,:int] := BKCinsert_bun(A:bat[:int,:int], _7:int, _7:int) {G}
    B := algebra.copy(A);               #  6 B:bat[:int,:int] := ALGcopy(A:bat[:int,:int]) {G}
    bat.setWriteMode(B);                #  7 _9:bat[:int,:int] := BKCsetWriteMode(B:bat[:int,:int]) {G}
    bat.insert(B,2,2);                  #  8 _10:bat[:int,:int] := BKCinsert_bun(B:bat[:int,:int], _11:int, _11:int) {G}
    C := algebra.copy(B);               #  9 C:bat[:int,:int] := ALGcopy(B:bat[:int,:int]) {G}
    bat.setWriteMode(C);                # 10 _13:bat[:int,:int] := BKCsetWriteMode(C:bat[:int,:int]) {G}
    bat.insert(C,3,3);                  # 11 _14:bat[:int,:int] := BKCinsert_bun(C:bat[:int,:int], _15:int, _15:int) {G}
    D := algebra.copy(C);               # 12 D:bat[:int,:int] := ALGcopy(C:bat[:int,:int]) {G}
    bat.setWriteMode(D);                # 13 _17:bat[:int,:int] := BKCsetWriteMode(D:bat[:int,:int]) {G}
    bat.insert(D,3,3);                  # 14 _18:bat[:int,:int] := BKCinsert_bun(D:bat[:int,:int], _15:int, _15:int) {G}
    Acost := aggr.count(A);             # 15 Acost:int := ALGcount_bat(A:bat[:int,:int]) 
    Bcost := aggr.count(B);             # 16 Bcost:int := ALGcount_bat(B:bat[:int,:int]) 
    Ccost := aggr.count(C);             # 17 Ccost:int := ALGcount_bat(C:bat[:int,:int]) 
    Dcost := aggr.count(D);             # 18 Dcost:int := ALGcount_bat(D:bat[:int,:int]) 
    T1cost := calc.+(Acost,Bcost);      # 19 T1cost:int := CALCbinaryADDintint(Acost:int, Bcost:int) 
    T2cost := calc.+(Bcost,Ccost);      # 20 T2cost:int := CALCbinaryADDintint(Bcost:int, Ccost:int) 
    T3cost := calc.+(Ccost,Dcost);      # 21 T3cost:int := CALCbinaryADDintint(Ccost:int, Dcost:int) 
    io.printf("choicepoint 1\n");       # 22 _26:void := IOprint_str(_27:str) 
    scheduler.choice();                 # 23 _28:void := RUNchoice() 
    T1 := algebra.join(A,B);            # 24 T1:bat[:int,:int] := ALGjoin(A:bat[:int,:int], B:bat[:int,:int]) {G}
    T1cost := aggr.count(T1);           # 25 T1cost:int := ALGcount_bat(T1:bat[:int,:int]) 
    T2 := algebra.join(B,C);            # 26 T2:bat[:int,:int] := ALGjoin(B:bat[:int,:int], C:bat[:int,:int]) {G}
    T2cost := aggr.count(T2);           # 27 T2cost:int := ALGcount_bat(T2:bat[:int,:int]) 
    T3 := algebra.join(C,D);            # 28 T3:bat[:int,:int] := ALGjoin(C:bat[:int,:int], D:bat[:int,:int]) {G}
    T3cost := aggr.count(T3);           # 29 T3cost:int := ALGcount_bat(T3:bat[:int,:int]) 
    io.printf("choicepoint 2\n");       # 30 _32:void := IOprint_str(_33:str) 
    scheduler.choice(T1cost,T1,T2cost,T2,T3cost,T3);# 31 _34:void := RUNchoice(T1cost:int, T1:bat[:int,:int], T2cost:int, T2:bat[:int,:int], T3cost:int, T3:bat[:int,:int]) 
    T4cost := calc.+(T1cost,Ccost);     # 32 T4cost:int := CALCbinaryADDintint(T1cost:int, Ccost:int) 
    T5cost := calc.+(Acost,T2cost);     # 33 T5cost:int := CALCbinaryADDintint(Acost:int, T2cost:int) 
    T6cost := calc.+(T2cost,Dcost);     # 34 T6cost:int := CALCbinaryADDintint(T2cost:int, Dcost:int) 
    T7cost := calc.+(Bcost,T3cost);     # 35 T7cost:int := CALCbinaryADDintint(Bcost:int, T3cost:int) 
    T8cost := calc.+(Ccost,Dcost);      # 36 T8cost:int := CALCbinaryADDintint(Ccost:int, Dcost:int) 
    T4 := algebra.join(T1,C);           # 37 T4:bat[:int,:int] := ALGjoin(T1:bat[:int,:int], C:bat[:int,:int]) {G}
    T4cost := aggr.count(T4);           # 38 T4cost:int := ALGcount_bat(T4:bat[:int,:int]) 
    T5 := algebra.join(A,T2);           # 39 T5:bat[:int,:int] := ALGjoin(A:bat[:int,:int], T2:bat[:int,:int]) {G}
    T5cost := aggr.count(T5);           # 40 T5cost:int := ALGcount_bat(T5:bat[:int,:int]) 
    T6 := algebra.join(T2,D);           # 41 T6:bat[:int,:int] := ALGjoin(T2:bat[:int,:int], D:bat[:int,:int]) {G}
    T6cost := aggr.count(T6);           # 42 T6cost:int := ALGcount_bat(T6:bat[:int,:int]) 
    T7 := algebra.join(B,T3);           # 43 T7:bat[:int,:int] := ALGjoin(B:bat[:int,:int], T3:bat[:int,:int]) {G}
    T7cost := aggr.count(T7);           # 44 T7cost:int := ALGcount_bat(T7:bat[:int,:int]) 
    T8 := algebra.join(C,D);            # 45 T8:bat[:int,:int] := ALGjoin(C:bat[:int,:int], D:bat[:int,:int]) {G}
    T8cost := aggr.count(T8);           # 46 T8cost:int := ALGcount_bat(T8:bat[:int,:int]) 
    io.printf("choicepoint 3\n");       # 47 _45:void := IOprint_str(_46:str) 
    scheduler.choice(T4cost,T4,T5cost,T5,T6cost,T6,T7cost,T7,T8cost,T8);# 48 _47:void := RUNchoice(T4cost:int, T4:bat[:int,:int], T5cost:int, T5:bat[:int,:int], T6cost:int, T6:bat[:int,:int], T7cost:int, T7:bat[:int,:int], T8cost:int, T8:bat[:int,:int]) 
    T9cost := calc.+(T2cost,Dcost);     # 49 T9cost:int := CALCbinaryADDintint(T2cost:int, Dcost:int) 
    T10cost := calc.+(T5cost,Dcost);    # 50 T10cost:int := CALCbinaryADDintint(T5cost:int, Dcost:int) 
    T11cost := calc.+(Acost,T6cost);    # 51 T11cost:int := CALCbinaryADDintint(Acost:int, T6cost:int) 
    T12cost := calc.+(Acost,T7cost);    # 52 T12cost:int := CALCbinaryADDintint(Acost:int, T7cost:int) 
    T13cost := calc.+(T1cost,T8cost);   # 53 T13cost:int := CALCbinaryADDintint(T1cost:int, T8cost:int) 
    T9 := algebra.join(T4,D);           # 54 T9:bat[:int,:int] := ALGjoin(T4:bat[:int,:int], D:bat[:int,:int]) {G}
    T10 := algebra.join(T5,D);          # 55 T10:bat[:int,:int] := ALGjoin(T5:bat[:int,:int], D:bat[:int,:int]) {G}
    T11 := algebra.join(A,T6);          # 56 T11:bat[:int,:int] := ALGjoin(A:bat[:int,:int], T6:bat[:int,:int]) {G}
    T12 := algebra.join(A,T7);          # 57 T12:bat[:int,:int] := ALGjoin(A:bat[:int,:int], T7:bat[:int,:int]) {G}
    T13 := algebra.join(T1,T8);         # 58 T13:bat[:int,:int] := ALGjoin(T1:bat[:int,:int], T8:bat[:int,:int]) {G}
    io.printf("choicepoint 4\n");       # 59 _58:void := IOprint_str(_59:str) 
    scheduler.choice(T9cost,T9,T10cost,T10,T11cost,T11,T12cost,T12,T13cost,T13);# 60 _60:void := RUNchoice(T9cost:int, T9:bat[:int,:int], T10cost:int, T10:bat[:int,:int], T11cost:int, T11:bat[:int,:int], T12cost:int, T12:bat[:int,:int], T13cost:int, T13:bat[:int,:int]) 
    answer := scheduler.pick(T9,T10,T11,T12,T13);# 61 answer:bat[:int,:int] := RUNpickResult(T9:bat[:int,:int], T10:bat[:int,:int], T11:bat[:int,:int], T12:bat[:int,:int], T13:bat[:int,:int]) {G}
    io.print(answer);                   # 62 _62:void := IOprint_val(answer:bat[:int,:int]) 
end main;	# 63  
choicepoint 1
choicepoint 2
choicepoint 3
choicepoint 4
#-----------------#
# h	t	  # name
# int	int	  # type
#-----------------#
[ 1,	  1	  ]

# 22:56:36 >  
# 22:56:36 >  Done.
# 22:56:36 >  

