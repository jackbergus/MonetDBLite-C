stdout of test 'memo00` in directory 'src/scheduler` itself:


# 17:54:34 >  
# 17:54:34 >  Mtimeout -timeout 60 mserver5 "--config=/ufs/mk/monet5/Linux/etc/monetdb5.conf" --debug=10 --set "monet_mod_path=/ufs/mk/monet5//Linux/lib/MonetDB5:/ufs/mk/monet5//Linux/lib/MonetDB5/lib:/ufs/mk/monet5//Linux/lib/MonetDB5/bin" --set "gdk_dbfarm=/ufs/mk/monet5//Linux/var/MonetDB5/dbfarm" --set "sql_logdir=/ufs/mk/monet5//Linux/var/MonetDB5/sql_logs" --set "xquery_logdir=/ufs/mk/monet5//Linux/var/MonetDB5/xquery_logs" --set mapi_port=30814 --set xrpc_port=44300 --set monet_prompt= --trace --dbname=mTests_src_scheduler  memo00.mal < /dev/null
# 17:54:34 >  

# MonetDB Server v5.0.0_beta2_1
# Copyright (c) 1993-2007 CWI, all rights reserved
# Compiled for x86_64-redhat-linux-gnu/64bit with 64bit OIDs dynamically linked
# dbname:mTests_src_scheduler
# Visit http://monetdb.cwi.nl/ for further information
## The first memo driven execution
## use local cost functions, which leads to a hill-climber
#
#	A:= bat.new(:int,:int);
#	bat.insert(A,1,1);
#	B:= algebra.copy(A);
#	bat.setWriteMode(B);
#	bat.insert(B,2,2);
#	C:= algebra.copy(B);
#	bat.setWriteMode(C);
#	bat.insert(C,3,3);
#	D:= algebra.copy(C);
#	bat.setWriteMode(D);
#	bat.insert(D,3,3);
#
#	Acost:= aggr.count(A);
#	Bcost:= aggr.count(B);
#	Ccost:= aggr.count(C);
#	Dcost:= aggr.count(D);
#	T1cost:= Acost+Bcost; T1:bat[:int,:int]:=nil;
#	T2cost:= Bcost+Ccost; T2:bat[:int,:int]:=nil;
#	T3cost:= Ccost+Dcost; T3:bat[:int,:int]:=nil;
#	scheduler.choice(T1cost,T1, T2cost,T2, T3cost,T3);
#
#	T1:= algebra.join(A,B);
#	T1cost:= aggr.count(T1);
#	T2:= algebra.join(B,C);
#	T2cost:= aggr.count(T2);
#	T3:= algebra.join(C,D);
#	T3cost:= aggr.count(T3);
#
#	T4cost:=T1cost+Ccost; T4:bat[:int,:int]:=nil;
#	T5cost:=Acost+T2cost; T5:bat[:int,:int]:=nil;
#	T6cost:=T2cost+Dcost; T6:bat[:int,:int]:=nil;
#	T7cost:=Bcost+T3cost; T7:bat[:int,:int]:=nil;
#	T8cost:=Ccost+Dcost; T8:bat[:int,:int]:=nil;
#	scheduler.choice(T4cost,T4,T5cost,T5,T6cost,T6,T7cost,T7,T8cost,T8);
#
#	T4:= algebra.join(T1,C);
#	T4cost:= aggr.count(T4);
#	T5:= algebra.join(A,T2);
#	T5cost:= aggr.count(T5);
#	T6:= algebra.join(T2,D);
#	T6cost:= aggr.count(T6);
#	T7:= algebra.join(B,T3);
#	T7cost:= aggr.count(T7);
#	T8:= algebra.join(C,D);
#	T8cost:= aggr.count(T8);
#
#	T9cost:=T2cost+Dcost;  T9:bat[:int,:int]:=nil;
#	T10cost:=T5cost+Dcost;  T10:bat[:int,:int]:=nil;
#	T11cost:= Acost+T6cost;  T11:bat[:int,:int]:=nil;
#	T12cost:= Acost+T7cost;  T12:bat[:int,:int]:=nil;
#	T13cost:= T1cost+T8cost;  T13:bat[:int,:int]:=nil;
#
#	scheduler.choice(T9cost,T9,T10cost,T10,T11cost,T11,T12cost,T12,T13cost,T13);
#	T9:= algebra.join(T4,D);
#	T10:= algebra.join(T5,D);
#	T11:= algebra.join(A,T6);
#	T12:= algebra.join(A,T7);
#	T13:= algebra.join(T1,T8);
#	answer:= scheduler.pick(T9,T10,T11,T12,T13);
#	io.print(answer);
#
function user.main():void;	# 0  (main:void)
# The first memo driven execution 	# 1  (_1:str)
# use local cost functions, which leads to a hill-climber 	# 2  (_2:str)
    A := bat.new(:int,:int);	# 3 CMDBATnew (A:bat[:int,:int])<-(_4:int)(_4:int)
    bat.insert(A,1,1);	# 4 BKCinsert_bun (_5:void)<-(A:bat[:int,:int])(_6:int)(_6:int)
    B := algebra.copy(A);	# 5 ALGcopy (B:bat[:int,:int])<-(A:bat[:int,:int])
    bat.setWriteMode(B);	# 6 BKCsetWriteMode (_8:bat[:int,:int])<-(B:bat[:int,:int])
    bat.insert(B,2,2);	# 7 BKCinsert_bun (_9:void)<-(B:bat[:int,:int])(_10:int)(_10:int)
    C := algebra.copy(B);	# 8 ALGcopy (C:bat[:int,:int])<-(B:bat[:int,:int])
    bat.setWriteMode(C);	# 9 BKCsetWriteMode (_12:bat[:int,:int])<-(C:bat[:int,:int])
    bat.insert(C,3,3);	# 10 BKCinsert_bun (_13:void)<-(C:bat[:int,:int])(_14:int)(_14:int)
    D := algebra.copy(C);	# 11 ALGcopy (D:bat[:int,:int])<-(C:bat[:int,:int])
    bat.setWriteMode(D);	# 12 BKCsetWriteMode (_16:bat[:int,:int])<-(D:bat[:int,:int])
    bat.insert(D,3,3);	# 13 BKCinsert_bun (_17:void)<-(D:bat[:int,:int])(_14:int)(_14:int)
    Acost := aggr.count(A);	# 14 ALGcount_bat (Acost:int)<-(A:bat[:int,:int])
    Bcost := aggr.count(B);	# 15 ALGcount_bat (Bcost:int)<-(B:bat[:int,:int])
    Ccost := aggr.count(C);	# 16 ALGcount_bat (Ccost:int)<-(C:bat[:int,:int])
    Dcost := aggr.count(D);	# 17 ALGcount_bat (Dcost:int)<-(D:bat[:int,:int])
    T1cost := calc.+(Acost,Bcost);	# 18 CALCbinaryADDintint (T1cost:int)<-(Acost:int)(Bcost:int)
    T1:bat[:int,:int]  := nil;	# 19  (T1:bat[:int,:int])<-(_54:BAT)
    T2cost := calc.+(Bcost,Ccost);	# 20 CALCbinaryADDintint (T2cost:int)<-(Bcost:int)(Ccost:int)
    T2:bat[:int,:int]  := nil;	# 21  (T2:bat[:int,:int])<-(_54:BAT)
    T3cost := calc.+(Ccost,Dcost);	# 22 CALCbinaryADDintint (T3cost:int)<-(Ccost:int)(Dcost:int)
    T3:bat[:int,:int]  := nil;	# 23  (T3:bat[:int,:int])<-(_54:BAT)
    scheduler.choice(T1cost,T1,T2cost,T2,T3cost,T3);	# 24 RUNchoice (_29:void)<-(T1cost:int)(T1:bat[:int,:int])(T2cost:int)(T2:bat[:int,:int])(T3cost:int)(T3:bat[:int,:int])
    T1:bat[:int,:int]  := algebra.join(A,B);	# 25 ALGjoin (T1:bat[:int,:int])<-(A:bat[:int,:int])(B:bat[:int,:int])
    T1cost := aggr.count(T1);	# 26 ALGcount_bat (T1cost:int)<-(T1:bat[:int,:int])
    T2:bat[:int,:int]  := algebra.join(B,C);	# 27 ALGjoin (T2:bat[:int,:int])<-(B:bat[:int,:int])(C:bat[:int,:int])
    T2cost := aggr.count(T2);	# 28 ALGcount_bat (T2cost:int)<-(T2:bat[:int,:int])
    T3:bat[:int,:int]  := algebra.join(C,D);	# 29 ALGjoin (T3:bat[:int,:int])<-(C:bat[:int,:int])(D:bat[:int,:int])
    T3cost := aggr.count(T3);	# 30 ALGcount_bat (T3cost:int)<-(T3:bat[:int,:int])
    T4cost := calc.+(T1cost,Ccost);	# 31 CALCbinaryADDintint (T4cost:int)<-(T1cost:int)(Ccost:int)
    T4:bat[:int,:int]  := nil;	# 32  (T4:bat[:int,:int])<-(_54:BAT)
    T5cost := calc.+(Acost,T2cost);	# 33 CALCbinaryADDintint (T5cost:int)<-(Acost:int)(T2cost:int)
    T5:bat[:int,:int]  := nil;	# 34  (T5:bat[:int,:int])<-(_54:BAT)
    T6cost := calc.+(T2cost,Dcost);	# 35 CALCbinaryADDintint (T6cost:int)<-(T2cost:int)(Dcost:int)
    T6:bat[:int,:int]  := nil;	# 36  (T6:bat[:int,:int])<-(_54:BAT)
    T7cost := calc.+(Bcost,T3cost);	# 37 CALCbinaryADDintint (T7cost:int)<-(Bcost:int)(T3cost:int)
    T7:bat[:int,:int]  := nil;	# 38  (T7:bat[:int,:int])<-(_54:BAT)
    T8cost := calc.+(Ccost,Dcost);	# 39 CALCbinaryADDintint (T8cost:int)<-(Ccost:int)(Dcost:int)
    T8:bat[:int,:int]  := nil;	# 40  (T8:bat[:int,:int])<-(_54:BAT)
    scheduler.choice(T4cost,T4,T5cost,T5,T6cost,T6,T7cost,T7,T8cost,T8);	# 41 RUNchoice (_40:void)<-(T4cost:int)(T4:bat[:int,:int])(T5cost:int)(T5:bat[:int,:int])(T6cost:int)(T6:bat[:int,:int])(T7cost:int)(T7:bat[:int,:int])(T8cost:int)(T8:bat[:int,:int])
    T4:bat[:int,:int]  := algebra.join(T1,C);	# 42 ALGjoin (T4:bat[:int,:int])<-(T1:bat[:int,:int])(C:bat[:int,:int])
    T4cost := aggr.count(T4);	# 43 ALGcount_bat (T4cost:int)<-(T4:bat[:int,:int])
    T5:bat[:int,:int]  := algebra.join(A,T2);	# 44 ALGjoin (T5:bat[:int,:int])<-(A:bat[:int,:int])(T2:bat[:int,:int])
    T5cost := aggr.count(T5);	# 45 ALGcount_bat (T5cost:int)<-(T5:bat[:int,:int])
    T6:bat[:int,:int]  := algebra.join(T2,D);	# 46 ALGjoin (T6:bat[:int,:int])<-(T2:bat[:int,:int])(D:bat[:int,:int])
    T6cost := aggr.count(T6);	# 47 ALGcount_bat (T6cost:int)<-(T6:bat[:int,:int])
    T7:bat[:int,:int]  := algebra.join(B,T3);	# 48 ALGjoin (T7:bat[:int,:int])<-(B:bat[:int,:int])(T3:bat[:int,:int])
    T7cost := aggr.count(T7);	# 49 ALGcount_bat (T7cost:int)<-(T7:bat[:int,:int])
    T8:bat[:int,:int]  := algebra.join(C,D);	# 50 ALGjoin (T8:bat[:int,:int])<-(C:bat[:int,:int])(D:bat[:int,:int])
    T8cost := aggr.count(T8);	# 51 ALGcount_bat (T8cost:int)<-(T8:bat[:int,:int])
    T9cost := calc.+(T2cost,Dcost);	# 52 CALCbinaryADDintint (T9cost:int)<-(T2cost:int)(Dcost:int)
    T9:bat[:int,:int]  := nil;	# 53  (T9:bat[:int,:int])<-(_54:BAT)
    T10cost := calc.+(T5cost,Dcost);	# 54 CALCbinaryADDintint (T10cost:int)<-(T5cost:int)(Dcost:int)
    T10:bat[:int,:int]  := nil;	# 55  (T10:bat[:int,:int])<-(_54:BAT)
    T11cost := calc.+(Acost,T6cost);	# 56 CALCbinaryADDintint (T11cost:int)<-(Acost:int)(T6cost:int)
    T11:bat[:int,:int]  := nil;	# 57  (T11:bat[:int,:int])<-(_54:BAT)
    T12cost := calc.+(Acost,T7cost);	# 58 CALCbinaryADDintint (T12cost:int)<-(Acost:int)(T7cost:int)
    T12:bat[:int,:int]  := nil;	# 59  (T12:bat[:int,:int])<-(_54:BAT)
    T13cost := calc.+(T1cost,T8cost);	# 60 CALCbinaryADDintint (T13cost:int)<-(T1cost:int)(T8cost:int)
    T13:bat[:int,:int]  := nil;	# 61  (T13:bat[:int,:int])<-(_54:BAT)
    scheduler.choice(T9cost,T9,T10cost,T10,T11cost,T11,T12cost,T12,T13cost,T13);	# 62 RUNchoice (_51:void)<-(T9cost:int)(T9:bat[:int,:int])(T10cost:int)(T10:bat[:int,:int])(T11cost:int)(T11:bat[:int,:int])(T12cost:int)(T12:bat[:int,:int])(T13cost:int)(T13:bat[:int,:int])
    T9:bat[:int,:int]  := algebra.join(T4,D);	# 63 ALGjoin (T9:bat[:int,:int])<-(T4:bat[:int,:int])(D:bat[:int,:int])
    T10:bat[:int,:int]  := algebra.join(T5,D);	# 64 ALGjoin (T10:bat[:int,:int])<-(T5:bat[:int,:int])(D:bat[:int,:int])
    T11:bat[:int,:int]  := algebra.join(A,T6);	# 65 ALGjoin (T11:bat[:int,:int])<-(A:bat[:int,:int])(T6:bat[:int,:int])
    T12:bat[:int,:int]  := algebra.join(A,T7);	# 66 ALGjoin (T12:bat[:int,:int])<-(A:bat[:int,:int])(T7:bat[:int,:int])
    T13:bat[:int,:int]  := algebra.join(T1,T8);	# 67 ALGjoin (T13:bat[:int,:int])<-(T1:bat[:int,:int])(T8:bat[:int,:int])
    answer := scheduler.pick(T9,T10,T11,T12,T13);	# 68 RUNpickResult (answer:bat[:int,:int])<-(T9:bat[:int,:int])(T10:bat[:int,:int])(T11:bat[:int,:int])(T12:bat[:int,:int])(T13:bat[:int,:int])
    io.print(answer);	# 69 IOprint_val (_53:void)<-(answer:bat[:int,:int])
end main;	# 70  
#cost choice selected T1 3
function user.main():void;
# The first memo driven execution 
# use local cost functions, which leads to a hill-climber 
    A := bat.new(:int,:int);
    bat.insert(A,1,1);
    B := algebra.copy(A);
    bat.setWriteMode(B);
    bat.insert(B,2,2);
    C := algebra.copy(B);
    bat.setWriteMode(C);
    bat.insert(C,3,3);
    D := algebra.copy(C);
    bat.setWriteMode(D);
    bat.insert(D,3,3);
    Acost := aggr.count(A);
    Bcost := aggr.count(B);
    Ccost := aggr.count(C);
    Dcost := aggr.count(D);
    T1cost := calc.+(Acost,Bcost);
    T1:bat[:int,:int]  := nil;
    T2cost := calc.+(Bcost,Ccost);
    T2:bat[:int,:int]  := nil;
    T3cost := calc.+(Ccost,Dcost);
    T3:bat[:int,:int]  := nil;
    scheduler.choice(T1cost,T1,T2cost,T2,T3cost,T3);
    T1:bat[:int,:int]  := algebra.join(A,B);
    T1cost := aggr.count(T1);
#    T2:bat[:int,:int]  := algebra.join(B,C);
#    T2cost := aggr.count(T2);
#    T3:bat[:int,:int]  := algebra.join(C,D);
#    T3cost := aggr.count(T3);
    T4cost := calc.+(T1cost,Ccost);
    T4:bat[:int,:int]  := nil;
#    T5cost := calc.+(Acost,T2cost);
    T5:bat[:int,:int]  := nil;
#    T6cost := calc.+(T2cost,Dcost);
    T6:bat[:int,:int]  := nil;
#    T7cost := calc.+(Bcost,T3cost);
    T7:bat[:int,:int]  := nil;
    T8cost := calc.+(Ccost,Dcost);
    T8:bat[:int,:int]  := nil;
    scheduler.choice(T4cost,T4,T5cost,T5,T6cost,T6,T7cost,T7,T8cost,T8);
    T4:bat[:int,:int]  := algebra.join(T1,C);
    T4cost := aggr.count(T4);
#    T5:bat[:int,:int]  := algebra.join(A,T2);
#    T5cost := aggr.count(T5);
#    T6:bat[:int,:int]  := algebra.join(T2,D);
#    T6cost := aggr.count(T6);
#    T7:bat[:int,:int]  := algebra.join(B,T3);
#    T7cost := aggr.count(T7);
    T8:bat[:int,:int]  := algebra.join(C,D);
    T8cost := aggr.count(T8);
#    T9cost := calc.+(T2cost,Dcost);
    T9:bat[:int,:int]  := nil;
#    T10cost := calc.+(T5cost,Dcost);
    T10:bat[:int,:int]  := nil;
#    T11cost := calc.+(Acost,T6cost);
    T11:bat[:int,:int]  := nil;
#    T12cost := calc.+(Acost,T7cost);
    T12:bat[:int,:int]  := nil;
    T13cost := calc.+(T1cost,T8cost);
    T13:bat[:int,:int]  := nil;
    scheduler.choice(T9cost,T9,T10cost,T10,T11cost,T11,T12cost,T12,T13cost,T13);
    T9:bat[:int,:int]  := algebra.join(T4,D);
#    T10:bat[:int,:int]  := algebra.join(T5,D);
#    T11:bat[:int,:int]  := algebra.join(A,T6);
#    T12:bat[:int,:int]  := algebra.join(A,T7);
    T13:bat[:int,:int]  := algebra.join(T1,T8);
    answer := scheduler.pick(T9,T10,T11,T12,T13);
    io.print(answer);
end main;
#cost choice selected T4 4
function user.main():void;
# The first memo driven execution 
# use local cost functions, which leads to a hill-climber 
    A := bat.new(:int,:int);
    bat.insert(A,1,1);
    B := algebra.copy(A);
    bat.setWriteMode(B);
    bat.insert(B,2,2);
    C := algebra.copy(B);
    bat.setWriteMode(C);
    bat.insert(C,3,3);
    D := algebra.copy(C);
    bat.setWriteMode(D);
    bat.insert(D,3,3);
    Acost := aggr.count(A);
    Bcost := aggr.count(B);
    Ccost := aggr.count(C);
    Dcost := aggr.count(D);
    T1cost := calc.+(Acost,Bcost);
    T1:bat[:int,:int]  := nil;
    T2cost := calc.+(Bcost,Ccost);
    T2:bat[:int,:int]  := nil;
    T3cost := calc.+(Ccost,Dcost);
    T3:bat[:int,:int]  := nil;
    scheduler.choice(T1cost,T1,T2cost,T2,T3cost,T3);
    T1:bat[:int,:int]  := algebra.join(A,B);
    T1cost := aggr.count(T1);
#    T2:bat[:int,:int]  := algebra.join(B,C);
#    T2cost := aggr.count(T2);
#    T3:bat[:int,:int]  := algebra.join(C,D);
#    T3cost := aggr.count(T3);
    T4cost := calc.+(T1cost,Ccost);
    T4:bat[:int,:int]  := nil;
#    T5cost := calc.+(Acost,T2cost);
    T5:bat[:int,:int]  := nil;
#    T6cost := calc.+(T2cost,Dcost);
    T6:bat[:int,:int]  := nil;
#    T7cost := calc.+(Bcost,T3cost);
    T7:bat[:int,:int]  := nil;
    T8cost := calc.+(Ccost,Dcost);
    T8:bat[:int,:int]  := nil;
    scheduler.choice(T4cost,T4,T5cost,T5,T6cost,T6,T7cost,T7,T8cost,T8);
    T4:bat[:int,:int]  := algebra.join(T1,C);
    T4cost := aggr.count(T4);
#    T5:bat[:int,:int]  := algebra.join(A,T2);
#    T5cost := aggr.count(T5);
#    T6:bat[:int,:int]  := algebra.join(T2,D);
#    T6cost := aggr.count(T6);
#    T7:bat[:int,:int]  := algebra.join(B,T3);
#    T7cost := aggr.count(T7);
#    T8:bat[:int,:int]  := algebra.join(C,D);
#    T8cost := aggr.count(T8);
#    T9cost := calc.+(T2cost,Dcost);
    T9:bat[:int,:int]  := nil;
#    T10cost := calc.+(T5cost,Dcost);
#    T10:bat[:int,:int]  := nil;
#    T11cost := calc.+(Acost,T6cost);
#    T11:bat[:int,:int]  := nil;
#    T12cost := calc.+(Acost,T7cost);
#    T12:bat[:int,:int]  := nil;
#    T13cost := calc.+(T1cost,T8cost);
    T13:bat[:int,:int]  := nil;
    scheduler.choice(T9cost,T9,T10cost,T10,T11cost,T11,T12cost,T12,T13cost,T13);
    T9:bat[:int,:int]  := algebra.join(T4,D);
#    T10:bat[:int,:int]  := algebra.join(T5,D);
#    T11:bat[:int,:int]  := algebra.join(A,T6);
#    T12:bat[:int,:int]  := algebra.join(A,T7);
#    T13:bat[:int,:int]  := algebra.join(T1,T8);
    answer := scheduler.pick(T9,T10,T11,T12,T13);
    io.print(answer);
end main;
#cost choice selected T9 0
function user.main():void;
# The first memo driven execution 
# use local cost functions, which leads to a hill-climber 
    A := bat.new(:int,:int);
    bat.insert(A,1,1);
    B := algebra.copy(A);
    bat.setWriteMode(B);
    bat.insert(B,2,2);
    C := algebra.copy(B);
    bat.setWriteMode(C);
    bat.insert(C,3,3);
    D := algebra.copy(C);
    bat.setWriteMode(D);
    bat.insert(D,3,3);
    Acost := aggr.count(A);
    Bcost := aggr.count(B);
    Ccost := aggr.count(C);
    Dcost := aggr.count(D);
    T1cost := calc.+(Acost,Bcost);
    T1:bat[:int,:int]  := nil;
    T2cost := calc.+(Bcost,Ccost);
    T2:bat[:int,:int]  := nil;
    T3cost := calc.+(Ccost,Dcost);
    T3:bat[:int,:int]  := nil;
    scheduler.choice(T1cost,T1,T2cost,T2,T3cost,T3);
    T1:bat[:int,:int]  := algebra.join(A,B);
    T1cost := aggr.count(T1);
#    T2:bat[:int,:int]  := algebra.join(B,C);
#    T2cost := aggr.count(T2);
#    T3:bat[:int,:int]  := algebra.join(C,D);
#    T3cost := aggr.count(T3);
    T4cost := calc.+(T1cost,Ccost);
    T4:bat[:int,:int]  := nil;
#    T5cost := calc.+(Acost,T2cost);
    T5:bat[:int,:int]  := nil;
#    T6cost := calc.+(T2cost,Dcost);
    T6:bat[:int,:int]  := nil;
#    T7cost := calc.+(Bcost,T3cost);
    T7:bat[:int,:int]  := nil;
    T8cost := calc.+(Ccost,Dcost);
    T8:bat[:int,:int]  := nil;
    scheduler.choice(T4cost,T4,T5cost,T5,T6cost,T6,T7cost,T7,T8cost,T8);
    T4:bat[:int,:int]  := algebra.join(T1,C);
    T4cost := aggr.count(T4);
#    T5:bat[:int,:int]  := algebra.join(A,T2);
#    T5cost := aggr.count(T5);
#    T6:bat[:int,:int]  := algebra.join(T2,D);
#    T6cost := aggr.count(T6);
#    T7:bat[:int,:int]  := algebra.join(B,T3);
#    T7cost := aggr.count(T7);
#    T8:bat[:int,:int]  := algebra.join(C,D);
#    T8cost := aggr.count(T8);
#    T9cost := calc.+(T2cost,Dcost);
    T9:bat[:int,:int]  := nil;
#    T10cost := calc.+(T5cost,Dcost);
#    T10:bat[:int,:int]  := nil;
#    T11cost := calc.+(Acost,T6cost);
#    T11:bat[:int,:int]  := nil;
#    T12cost := calc.+(Acost,T7cost);
#    T12:bat[:int,:int]  := nil;
#    T13cost := calc.+(T1cost,T8cost);
    T13:bat[:int,:int]  := nil;
    scheduler.choice(T9cost,T9,T10cost,T10,T11cost,T11,T12cost,T12,T13cost,T13);
    T9:bat[:int,:int]  := algebra.join(T4,D);
#    T10:bat[:int,:int]  := algebra.join(T5,D);
#    T11:bat[:int,:int]  := algebra.join(A,T6);
#    T12:bat[:int,:int]  := algebra.join(A,T7);
#    T13:bat[:int,:int]  := algebra.join(T1,T8);
    answer := scheduler.pick(T9,T10,T11,T12,T13);
    io.print(answer);
end main;
#-----------------#
# h	t	  # name
# int	int	  # type
#-----------------#
[ 1,	  1	  ]

# 17:54:34 >  
# 17:54:34 >  Done.
# 17:54:34 >  

