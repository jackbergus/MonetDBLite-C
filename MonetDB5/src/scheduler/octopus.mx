@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
@' Copyright August 2008- MonetDB B.V.
@' All Rights Reserved.

@f octopus
@a M. Kersten
@+ Octopus scheduling
The octopus modules enable compute cloud based processing of SQL queries.
The optimizer splits a plan managed by the mitosis and mergetable into
independent functions by backtracking the instruction flow.
This leads to a series of MAL functions with possibly quite some
instruction overlap (which will not be a problem when the recycler is active).

The octopus scheduler takes over control of a MAL execution by
re-directing requests to multiple sites. If there are no sites around,
then the code is executed linearly as is.

To make this work the scheduler needs a list of applicable sites that
hold a replica of the database. For the time being, this is an
explicitly named list administered here.

The scheduler runs all tentacles asynchronously.
To make our live easier, we assume that all tentacles are
grouped together in a guarded block as follows:

@verbatim
barrier parallel:= scheduler.octopus();
a:= octopus.tentacle_1();
...
b:= octopus.tentacle_n();
exit parallel;
scheduler.pack(parallel, timeout, a,...,b);
@end verbatim

This way the MAL flow of control simplifies skipping to the end.

Allowing MAL instructions inbetween complicates our work,
because it would mean that we have to do a flow analysis.

When the octopus scheduling is called, we check the connection with
the remote site. If it is down, it is re-activated using Merovingian.

@{
@mal
pattern scheduler.octopus():bit
address OCTOPUSrun
comment "Run the program over a service cloud";

pattern scheduler.pack(par:bit, t:int, b:bat[:any_1,:any_2]...):void
address OCTOPUSpack
comment "Materialize the MAT into a BAT, but don't wait longer then t seconds";

pattern scheduler.addSite(dbnme:str, usr:str, pw:str)
address OCTOPUSaddSite
comment "Add a new site to the known list ";
@h
#ifndef _RUN_OCTOPUS
#define _RUN_OCTOPUS
#include "mal.h"
#include "mal_instruction.h"
#include "mal_client.h"

#define DEBUG_RUN_OCTOPUS

#ifdef WIN32
#ifndef LIBMAL_OCTOPUS
#define octopus_export extern __declspec(dllimport)
#else
#define octopus_export extern __declspec(dllexport)
#endif
#else
#define octopus_export extern
#endif

octopus_export str OCTOPUSrun(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
octopus_export str OCTOPUSaddSite(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
octopus_export str OCTOPUSpack(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
#endif /* MAL_RUN_OCTOPUS */

@+ Octopus scheduling implementation
The discovery phase consists of establishing connections with
the (remote) database servers.
@c
#include "mal_config.h"
#include "mal_interpreter.h"
#include "mat.h"
#include "octopus.h"
#include "optimizer.h"
#include "alarm.h"

static int
RUNdiscover(){
	return 1;
}

str
OCTOPUSaddSite(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	str *dbnme = (str*) getArgReference(stk,pci,1);
	str *usr = (str*) getArgReference(stk,pci,2);
	str *pw = (str*) getArgReference(stk,pci,3);

	(void) mb;
#ifdef DEBUG_RUN_OCTOPUS
	stream_printf(cntxt->fdout,"addSite %s %s %s\n", *dbnme, *usr, *pw);
#endif
	return MAL_SUCCEED;
}
@-
The scheduler runs all tentacles asynchronously.
The rigid structure makes it possible to wait for the
threads to end their work. We simple set them to nil
and wait for the assignments to have been completed.
The the sole remainder is the timeout, which could be
part of the scheduler arguments.
@c
str
OCTOPUSrun(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	int *res = (int*) getArgReference(stk,p,0);
	int i = getPC(mb,p);
	*res = 0;	/* skip the block */

	if ( RUNdiscover() == 0 )
		return MAL_SUCCEED; 
	/* do the actual parallel work */
	for (i++; i<mb->stop; i++){
		p= getInstrPtr(mb,i);
		if ( p->barrier == EXITsymbol )
			break;
		if ( getModuleId(p) != octopusRef)
			throw(MAL,"scheduler.octopus","octopus tentacle expected");
#ifdef DEBUG_RUN_OCTOPUS
		stream_printf(cntxt->fdout,"#Start a new thread\n");
#else
	(void) cntxt;
#endif
		runMALprocess(cntxt,mb,stk,p);
	}
	return MAL_SUCCEED; 
}
@-
The critical part is to wait for all the tentacles to
return their status.
@c
str
OCTOPUSpack(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	int serial = *(int*) getArgReference(stk,p,1);
	int timeout = *(int*) getArgReference(stk,p,2);
	int i,fnd;
	(void) mb;

#ifdef DEBUG_RUN_OCTOPUS
	stream_printf(cntxt->fdout,"schedule.pack %d %d\n", serial, timeout);
#else
	(void) cntxt;
#endif
	if ( serial == 0)
	do{
		fnd = 0;
		for( i=3; i<p->argc; i++)
			fnd += stk->stk[getArg(p,i)].val.bval > 0;
#ifdef DEBUG_RUN_OCTOPUS
		stream_printf(cntxt->fdout,"await answer, seen %d\n",fnd);
#endif
		MT_sleep_ms(1000);
	} while ( fnd < p->argc-3 && timeout > 0 );
	return MATpackInternal(stk,p,3);  /* ignore results and timeout */
}
@}
