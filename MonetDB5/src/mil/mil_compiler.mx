@a M. L. Kersten
@v 2.0
@+ MIL migration path
@T
MonetDB comes with a well-established programming language, called MIL
(Monet Interface Language). A large collection of MIL programs exists,
which ideally should run without problems on the MonetDB version 5 Kernel.
Unfortunately, life isn;t that easy. 
MIL was designed as a half-backed scripting language with
dynamic typing, variable re-use with different types,
little support for debugging, and permissive syntax.
Furthermore, the compiler was intimately bound with the
runtime system, e.g. an identifier was immediately resolved
against the modules being loaded and variables being known.
This was necessary to resolve their context dependent interpretation.

In version 5.0 a cleanup of MIL has taken place which strikes
a balance between forcing users to migrate to MAL and
to continue using their MIL code base. 
It is realized with a minimalistic compiler, which produces
MAL code for a large fragment of the MIL language. It is implemented
as an off-line compiler; there is no information on the runtime
status. In particular, it means there is no knowledge on
pre-existing variables, type names, procedures, etc..

With a little care most MIL programs can be compiled
and run against the new kernel. 
The Monet version 4 test suites and predefined MIL proc's
have been used to define the language boundary to be supported.

In writing MIL code, the following rules should be kept obeyed:
\begin{verbatim}
\item do not change the type of variables within their scope.
\item do not use type identifiers as ordinary variables
\item make the type of a 'nil' value explicity, e.g.  nil -> int(nil).
\item {\sc while},  {\sc for}, and {\sc if} use sequential blocks
and no single statements, e.g. if(A)B ->if(A)\{B\}.
\end{verbatim}
@{
@+ Implementation notes
The parser produced is not thread safe, which means that parsing
is encapsulated in a critical section. On single cpu systems this
does not cause too much performance degration, on multi-cpu systems
it may affect throughput when many users issue short (simple) commands.
The quantitative effect is yet unknown.
This parser assumes availability of a complete MIL block upfront
as a string to be parsed. 

The compiler has built-in knowledge of the types of Monet 4 and will
silently replace them with a type identifier. Likewise, an procedure
identifier mapping table is used to ease migration to the new setting.

The compiler can be used in both offline mode and as part of the
MIL scenario. Defining the macro M2Moffline produces MAL code
on standard output. Otherwise, the MAL code is directly produced
in memory for direct optimization and execution.
@}
@-
@T
Aside from syntax restrictions imposed, several command
signatures and command names have been changed.
They have to translated partly by hand.

For example, the BAT update routines do not return
their target variable. This means you can not cascade a series
of calls, e.g. the MIL 4 statement 
\begin{verbatim}
 a.select(1,2).access(BAT_WRITE).rename("C");
 b.insert(0,1).insert(1,2);
\end{verbatim}
should be split into multiple steps as follows:
\begin{verbatim}
 a.select(1,2); a.access(BAT_WRITE); a.rename("C");
 b.insert(0,1); b.insert(1,2);
\end{verbatim}

A major rewrite of the MIL program is required when
it inspects the runtime environment.
@{
@- The lexical analyzer
The lexical analyzer is generated using Flex, the preferred tool in Monet.

The implementation of the lexical analyzer is straightforward:
the input is taken from a client message buffer. It is assumed that
this buffer contains the complete MIL structure to be parsed.
This input buffer may be screwed up in the process, which implies
that front-ends may have to make a copy first.

The lexical analyzer and parser are prefixed with "mil", which ensures that
other language analyzers can safely be added
(provided they run not inparallel). The lexical analyzer should
not maintain a linenumber. This aspect is made explicit in the rules
any way.

The lexical analyser returns simple triples to the parser.
They include the token identifier, the Monet type-id, and a string
representation.

WARNING. This paper performs a single linear scan over the mil code
and immediately produces strings for output. A better solution would have been
to build a parsetree followed by a recursive descend code generation phase.
@h
#ifndef _MIL_PARSER_H
#define _MIL_PARSER_H

#define M2Moffline 

#include "gdk.h"

typedef struct YYSRECORD{
	int	token, tpe, len;
	char * 	val;
 } yystype, *yystypeptr;

#define YYERROR_VERBOSE
#define YYSTYPE yystype
extern YYSTYPE yylval;
#define GDKerror(M) 	printf("%s",M) 
#define mapOp(X) (*(X) == '[')
#define setOp(X) (*(X) == '{')
extern char *getOperator(char *nme);

extern const char *yylexname(int Y);
extern void mil_parseError(str msg);
extern void mil_flushbuffer();
extern str mil_lastline();
extern long mil_position();
extern int mil_skipcomment();
extern int str_escaped();
extern int mil_getch();
extern int yylex();
extern char *newName();
extern str getLastHead();
extern str getLastTail();
extern char *emitExpr(char *msg);
extern char *emitPathCode(str l, str r);
extern str glue(str l, str r);
extern str mapfcn(str n);
extern int ismapped(str n);
extern void showmappings();

extern int constantdeclaration;

typedef struct IDS{
        str nme;
        struct IDS *peer;
} *Ids;
extern Ids ids;

extern void resetIds(Ids prev);
extern void pushIterator(str nme);
extern void newId(str nme);
extern void popIterator();
extern void pushBlock(str nme);
extern void popBlock();
extern str getLastIterator();
extern char *bindFcn(str nme);
extern char *bindId(str nme);
extern char *mapi_quote(const char *msg, int size);
extern void mil_push(str s);

extern int trace_code;
#define rem	if(comment){ if(trace_code)printf("\tmil.line(\"%s\");\n",mapi_quote(comment,strlen(comment))); else printf("#%s\n",comment); comment=0;}

extern char *comment;
#endif /* _MIL_PARSER_H */
@l
/*
%option noyylineno
%option never-interactive
%option nomain
*/

D       [0-9]
O       [0-7]
L       [_a-zA-Z]
E       [Ee][-+]?{D}+
S       [\t\n ]*
P       [-!\$%\^\*+|?<>=/\\]
IDENT	{L}({L}|{D})*
OPER	{P}+
%{

#include "mil_compiler.h"
@-
The Bison parser generator will produce the table with token names
needed for tracing the parser.
@l
#include "mil_compiler.tab.h"

#define YY_NEVER_INTERACTIVE	1 /* workaround to flex bug */
#define YY_USE_PROTOS	  	/* make sure ANSI-C prototyes are used */

#define RETURN(Y)       { /* printf("\n%s %s\n", yylexname(Y), yytext); */\
                          return Y; }


#define YY_INPUT(buf,result,max_size)   { int c = mil_getch();\
                           result = (c==0) ? YY_NULL: (buf[0] = (char)c,1);}
#define Symbol(X)       { Vector(X,TYPE_void,0,0); }
#define Vector(X,Y,V,L)	{ yylval.token= X;	\
			yylval.tpe  = Y;	\
			if( V != 0 ) \
			yylval.val = GDKstrdup(V);  	\
			yylval.len = L;	\
			RETURN (X); }
%}

%%
"#".*"\n"                   { 
				if(trace_code)
				printf("\tmil.line(\"%s\");\n",
					mapi_quote(yytext,strlen(yytext))); 
				comment =0;
				return yylex();}
("nil"|"NIL")^({L}|{P})         { Vector(TOK_CONSTANT, TYPE_void, "nil", 3);   }
("proc"|"PROC")       { Symbol(TOK_PROCDEF);                                  }
("undef"|"UNDEF")     { Symbol(TOK_UNDEF);                                    }
("return"|"RETURN")   { Symbol(TOK_RETURN);                                   }
("break"|"BREAK")     { Symbol(TOK_BREAK);                                    }
("while"|"WHILE")     { Symbol(TOK_WHILE);                                    }
("if"|"IF")           { Symbol(TOK_IF);                                       }
("else"|"ELSE")       { Symbol(TOK_ELSE);                                     }
("false"|"FALSE")     { Vector(TOK_CONSTANT, TYPE_bit, "false", 1);        }
("var"|"VAR")         { Symbol(TOK_VAR);                                      }
("const"|"CONST")     { constantdeclaration = 1; Symbol(TOK_CONST);}
("true"|"TRUE")       { Vector(TOK_CONSTANT, TYPE_bit, "true", 1);        }
("module"|"MODULE")   { Symbol(TOK_MODULE);				     }
("any"|"ANY")         { Vector(TOK_ANY, TYPE_int,  "-1", 2);               }
("bat"|"BAT")         { Vector(TOK_BAT,TYPE_bat,"bat",0);		      }
"$("                  { Symbol(TOK_VARTEMP);                                  }
".."                  { Symbol(TOK_RANGETEMP);                                }
"::"                  { Symbol(TOK_ANYNUM);                                   }
("$h"|"$H"|"$head"|"$HEAD") { Vector(TOK_ITERTEMP, TYPE_str, getLastHead(), 1);         }
("$t"|"$T"|"$tail"|"$TAIL") { Vector(TOK_ITERTEMP, TYPE_str, getLastTail(), 1);         }
"$"{D}+               { Vector(TOK_TEMPLATE,TYPE_int,yytext,yyleng);       }
("[:=]")	|
("[:"{OPER}"=]")	|
("[:"{IDENT}"=]")	|
("["{IDENT}"]")	|
("["{OPER}"]")	| 
("{:=}") 	| 
("{"{OPER}"}")	|
("{"{IDENT}"}")	| 
({IDENT})	      { yytext[yyleng]=0; Vector(TOK_IDENT, TYPE_str, yytext,yyleng);	      }
":"[-+*%^|&/]"="	{
			Vector(TOK_OPERATOR3, TYPE_str, yytext,yyleng); 
		}
[-+*%^|&/]"="	{
			Vector(TOK_OPERATOR2, TYPE_str, yytext,yyleng); 
		}
(":"{IDENT}"=")	|
(":"{OPER}"=")	{	yytext[yyleng]=0;
			Vector(TOK_OPERATOR, TYPE_str, yytext,yyleng); 
		}
{OPER}+		{	yytext[yyleng]=0;
			if( yyleng==1 && yytext[0]=='='){
				yytext[1]='=';
				yytext[2]=0;
				yyleng++;
				Vector(TOK_OPERATOR, TYPE_str, yytext,yyleng); 
			} else {
				Vector(TOK_OPERATOR, TYPE_str, yytext,yyleng); 
			}
		}
({OPER}"=")	{	yytext[yyleng]=0;
			Vector(TOK_OPERATOR, TYPE_str, yytext,yyleng); 
		}
":="                  { Symbol(TOK_ASSIGNMENT);                               }
"(*"                  { Symbol(TOK_DEREF);                                    }
"[*"                  { Symbol(TOK_SETOP);                                    }
"{*"                  { Symbol(TOK_SETAGGR);                                  }
("-")?{D}+"LL"        { Vector(TOK_CONSTANT, TYPE_lng, yytext, yyleng);}
("-")?{D}+            { Vector(TOK_CONSTANT, TYPE_int, yytext, yyleng);}
{D}+"@"{D}+           { Vector(TOK_CONSTANT, TYPE_oid, yytext, yyleng);         }
("-")?{D}+"."{D}+({E})?"LL" |
("-")?"."{D}+({E})?"LL"     |
("-")?{D}+{E}"LL"     { Vector(TOK_CONSTANT, TYPE_dbl,  yytext, yyleng);         }
("-")?{D}+"."{D}+({E})? |
("-")?"."{D}+({E})?     |
("-")?{D}+{E}         { Vector(TOK_CONSTANT, TYPE_flt,  yytext, yyleng);         }
"'"\\0{O}({O})?({O})?"'" {Vector(TOK_CONSTANT, TYPE_chr, yytext, yyleng);        }
\"[^\n"]*\"		{
			yytext[yyleng]=0;
			if( str_escaped(yytext)){
					unput('"');
					yymore(); 
                        } else {
                                Vector(TOK_CONSTANT, TYPE_str, yytext, yyleng);
			}					                     }
\'[^\n']*\'            { 
                        if (yytext[yyleng-2] != '\\') {
                                Vector(TOK_CONSTANT, TYPE_chr, yytext, yyleng);
                        } else {
				unput('\'');
                                yymore(); 
                        }                                                     }
"@"                   { Symbol(TOK_ITERATION);                                }
"@"{S}"["                   { Symbol(TOK_ITERATION_PAR);               }
"{|"                  { Symbol(TOK_PARBLOCK);                                 }
"|}"                  { Symbol(TOK_PAREND);                                   }
{S}                   ;
.                     { Symbol(*yytext);                                      }
%%
int mil_skipcomment() { 
	char c; 
	while ((c=input()) && (c != '\n')); 
	return yylex();
}
int str_escaped(char *s){
	int quoted = 0;
	for(; s && *s; s++){
		quoted=  *s== '\\';
		if( quoted) s++;
	}
	return quoted;
}
int yywrap(){ return 1;}

void mil_flushbuffer() {
        YY_FLUSH_BUFFER;
}
str glue(str l, str r){
	str t;
	t= (str) GDKmalloc(strlen(l)+strlen(r)+1);
	t[0]=0;
	strcpy(t,l);
	strcat(t,r);
	return t;
}
@
@- Input management
The parser reads its input from a string buffer space, organized as a
stack to permit easy escapes to "included" MIL programs (module inits).
After parsing the string buffer space is freed by the parser as well.

[These variables should be local to a parsing thread.]
@c
#include "mil_compiler.h"

typedef struct _strstack_t {
	str buf, cptr, prevline, nxtline;
	int listing;		
	struct _strstack_t *up;
} strstack;

static strstack  *mil_stack = NULL;

void mil_push(str s) {
	strstack *sp = (strstack*) GDKmalloc(sizeof(strstack));
	sp->listing = 1;
	sp->cptr = sp->nxtline= sp->prevline = sp->buf = s;  
	sp->up = mil_stack;
	mil_stack = sp;
}


int mil_pop() {
	strstack *sp = mil_stack;
	if (mil_stack) {
		mil_stack = sp->up;
		GDKfree(sp->buf);
		GDKfree(sp);
		return 1;
	}
	return 0;
}

@-
The next character is retrieved from the string pool
using the routine mil_getch. The position of the last
newline is retained to gain quick access.
Beware, we first produce the comment line before attempting
the parse.
@c
char *comment;
int mil_getch() {
        char ch, *s = NULL;
	int i=0;
	ch = *mil_stack->cptr;

        if (ch == '\n' || (ch && mil_stack->cptr == mil_stack->buf) ){
#ifdef M2Moffline
		for(s= mil_stack->nxtline; s && *s && *s!='\n'; s++)
			i++;
                if (mil_stack->listing && trace_code!=0) { 
			comment= (char*) GDKmalloc(i+1);
			strncpy(comment,mil_stack->nxtline,i);
			comment[i]=0;
                }
		mil_stack->prevline= mil_stack->nxtline;
		if( s && *s)
			mil_stack->nxtline = s+1;
                else 	mil_stack->nxtline = s;
#else
	TODO
#endif
        } 
        if (ch) mil_stack->cptr++;
        return ch;
}

@-
For error reporting we have to find the start of the previous line,
which, ofcourse, is easy.
@c
str mil_lastline(){ 
	if( mil_stack->prevline )
		return mil_stack->prevline;
	if( mil_stack->nxtline == 0) 
		return mil_stack->buf;
	return mil_stack->nxtline; 
}
long mil_position()
{
	if( mil_stack->prevline )
	return (long)(mil_stack->cptr)- (long)mil_stack->prevline;
	return (long)(mil_stack->cptr)- (long)mil_stack->buf;
}
@-
Long strings are in this version easier to handle, because the input is
already concatenated by the front-end. This means that a string literal may not
extend beyond end-of-line.
REWORKED

@+ The Parser
Unlike Monet V4.3 the client is responsible to collect the
input for parsing in a single string before calling the parser.
Once the input is available parsing runs in a critial section for
a single client thread.

@c
int mil_parse(/*str buf, int listing*//*Stefan: unused!*/){
	return 0;
}

#define MAXDEPTH 64
str iterators[MAXDEPTH];
int itop=0;
str block[MAXDEPTH];
int btop=0;

void pushBlock(str nme){
	if( btop== MAXDEPTH){
		GDKfatal("FATAL: block depth exceeded\n");
	}
	block[btop]= GDKstrdup(nme);
	btop++;
}
void popBlock(){
	if(btop==0){
#ifdef M2Moffline
		printf("\n");
#endif
		GDKerror("#ERROR: no block id on stack\n");
		return;
	}
	btop--;
	if(block[btop]){
		GDKfree(block[btop]);
		block[btop]=0;
	}
}

str getLast(char c){
	char buf[IDLENGTH];
	if(itop==0){
#ifdef M2Moffline
		printf("\n");
#endif
		printf("#ERROR: no iterator '%c' on stack\n",c);
		return GDKstrdup("unknown");
	}
	sprintf(buf,"%s%c",iterators[itop-1],c);
	return GDKstrdup(buf);
}
str getLastHead(){ return getLast('H');}
str getLastTail(){ return getLast('T');}

@+ Symbol table
For Monet V 5 there is no automatic resolution of identifiers to
outer or named scopes. Such variables are explicitly bound by a
function take(str nme).
For the M2m compiler this means we have to keep track on the identifiers
introduced in a block and issue a bind operation before using them.
Variables that are introduced at the LHS of an assignment
need not be bound through the BAT binding operation.
@c
Ids ids;

void resetIds(Ids prev) {
        while(ids && prev != ids){
                ids =prev->peer;
                GDKfree(prev);
        }
}

extern int fndId(str nme);

@-
MIL variable may refer to globals, constants, parameterless functions,
 and persistent BATs. These cases are handled by a pattern in the MIL interpreter,
except for the built-in types, which are expected to exist.
Typename should be replaced by the MAL type identifier.
@c
extern str typeNames[];

str bindId(str nme){
	int i, fnd= 0;
	for( i=0; typeNames[i]; i++)
	if( strcmp(typeNames[i],nme)==0){ 
		str n= GDKmalloc(strlen(nme)+5);
		strcpy(n,"nil:");
		strcpy(n+4,nme);
		nme= n;
		fnd++; 
		break;
	}
	if( ismapped(nme)) return nme;
	if( strcmp(nme,"nil")==0){
		return nme;
	}
	if( *nme =='$') {
		return nme;
	}
	if( (nme[4]=='T' || nme[4]=='H') && nme[2]=='_') return nme;
	if( strcmp(nme,"quit") ==0){ 
#ifdef M2Moffline
		rem; printf("\tquit();\n"); 
#else
	TODO
#endif
		return nme;
	}

	if(fnd==0 &&  fndId(nme) == 0 && constantdeclaration==0){
#ifdef M2Moffline
		rem printf("\t%s:= mil.take(\"%s\");\n",nme,nme);
#else
	TODO
#endif
	}
	return nme;
}

char *bindFcn(str nme){
	char buffer[1024];

	switch(*nme){
	case '[':
		nme[strlen(nme)-1]=0;
		sprintf(buffer,"mil.multiplex(\"%s\",", mapfcn(nme+1));
		break;
	case '{':
		nme[strlen(nme)-1]=0;
		sprintf(buffer,"group.%s(", mapfcn(nme+1));
		break;
	case '(':
		nme[strlen(nme)-1]=0;
		sprintf(buffer,"mil.inplace(\"%s\",", mapfcn(nme+1));
		break;
	default: if(strchr(nme,'(') ) return nme;
		sprintf(buffer,"%s(",nme);
	}
	return GDKstrdup(buffer);
}
str emitPathCode(str l, str r) {
	char stmt[1024], *s, *arg=0;
	char op[1024];
	/* move the result of the function into the second call */
	l = emitExpr(l);
	strcpy(op,r);
	if(strncmp(r,"multiplex.tactics",17)==0){
		s= strchr(op,',');
		if(s) {
			arg = strchr(r,',')+1;
			*s =0;
		} else {
			s= strchr(op,')') ; *s =',';
			*(s+1) =0;
			arg = strchr(r,')');
		}
		if( *arg != ')' )
			sprintf(stmt,"%s,%s,%s", op,l,arg);
		else sprintf(stmt,"%s,%s%s", op,l,arg);
	} else {
		arg = strchr(r,'(')+1;
		s = strchr(op,'(');
		*s =0;
		if( *arg != ')' )
			sprintf(stmt,"%s(%s,%s", op,l,arg);
		else sprintf(stmt,"%s(%s)", op,l);
	}
	return GDKstrdup(stmt);
}
char *emitExpr(char *msg){
	if(*msg !='\'' && *msg!='"' && strchr(msg,'(') ){
		char *nme= newName();
#ifdef M2Moffline
		rem;printf("\t%s := %s;\n",nme,msg);
#else
	TODO
#endif
		return nme;
	} 
	return msg;
}
char *emitExpr0(char *msg){
	if( strchr(msg,'(')){
#ifdef M2Moffline
		rem; printf("\t%s;\n",msg);
#else
	TODO
#endif
		return GDKstrdup("XXXX");
	}
	if(*msg !='\'' && *msg!='"' && strchr(msg,'(') ){
		char *nme= newName();
#ifdef M2Moffline
		rem;printf("\t%s := %s;\n",nme,msg);
#else
	TODO
#endif
		return nme;
	} 
	return msg;
}
@-
Handling comments is tricky due to the large number of reduce/reduce
conflicts. They spoil the structure of the function signature.
Therefore, we switch to a situation that a command it remembered
and output when the lhs variable is shown.
@c
@+ The Bison Grammar
The grammatica should be context free.
@y
%token_table

%{
#include "mil_compiler.h"

#undef yyerror
#define yyerror(X)      { mil_parseError(X);  }

#define YYPRINT(file,tpe,val)	mil_print(file, /*tpe,*//*Stefan: unused!*/ ,val)
int yydebug = 1;
int constantdeclaration = 0;
void debugParser(int i){ yydebug=i; }


yystype accum;
extern char *comment;
extern int trace_code;
#define rem	if(comment){ if(trace_code)printf("\tmil.line(\"%s\");\n",mapi_quote(comment,strlen(comment))); else printf("#%s\n",comment); comment=0;}
%}

%token TOK_ITERTEMP TOK_TEMPLATE TOK_VARTEMP TOK_RANGETEMP
%token TOK_CONSTANT TOK_ASSIGNMENT TOK_PARBLOCK
%token TOK_PAREND TOK_IDENT TOK_IF TOK_WHILE
%token TOK_BREAK TOK_RETURN TOK_VAR 
%token TOK_CONST TOK_BAT
%token TOK_OPERATOR TOK_OPERATOR2 TOK_OPERATOR3
%token TOK_SETOP TOK_SETAGGR TOK_PROCDEF
%token TOK_STRING TOK_ITERATION TOK_ITERATION_PAR TOK_ELSE
%token TOK_MODULE 
%token TOK_ANY TOK_UNDEF TOK_DEREF TOK_ANYNUM

%left TOK_ITERATION
%left TOK_OPERATOR TOK_OPERATOR2 TOK_OPERATOR3
%left TOK_ASSIGNMENT 
%left ':'
%%
program:
        MIL_session 
    |   error ';' { yyerrok; yyclearin; return 1; }
    |   /* empty */ ;

MIL_session:
        session
    |   MIL_session session
    ;

session:
        proc_definition {resetIds(ids);}
    |   TOK_MODULE '(' module_list ')' ';'
    |   statement
    ;

statement_seq:
        /* empty */
    |   statement_list
    ;

statement_list:
        statement
    |   statement_list statement
    ;

statement:
        stmt { constantdeclaration = 0;}
    ;

stmt: ';'
    |   varidents ';' { constantdeclaration = 0; }
    |   expression ';'
    |   expression TOK_ITERATION_PAR expression ']' iterator
	{ char local[100],local2[100];
	  $2.val= newName();
	  sprintf(local,"(%s,%sH,%sT) := newIterator(%s)",
			$2.val,$2.val,$2.val,$4.val);
	  sprintf(local2,"(%s,%sH,%sT) := hasMoreElements(%s)",
			$2.val,$2.val,$2.val,$4.val);
	  pushIterator($2.val);
	  $4.val= GDKstrdup(local2);
#ifdef M2Moffline
	rem; printf("barrier\t%s;\n", local);
#else
	TODO
#endif
	  sprintf(local,"%sH",$2.val); newId(GDKstrdup(local));
	  sprintf(local,"%sT",$2.val); newId(GDKstrdup(local));
	}
	stmt
	{
#ifdef M2Moffline
	  char *c;
	  printf("redo\t%s;\n", $4.val);
	  c= strchr($4.val,':');
	  if(c) *c=0;
	  *(c+1)=0;
	  printf("exit\t%s;\n",$4.val);
#else
	TODO
#endif
	  popIterator();
	}
    |   expression TOK_ITERATION iterator
	{ char local[100], local2[100];
	  $2.val= newName();
	  pushIterator($2.val);
	  sprintf(local,"(%s,%sH,%sT) := newIterator(%s)",
			$2.val,$2.val,$2.val,$1.val);
	  sprintf(local2,"(%s,%sH,%sT) := hasMoreElements(%s)",
			$2.val,$2.val,$2.val,$1.val);
	$1.val= GDKstrdup(local2);
#ifdef M2Moffline
	rem; printf("barrier\t%s;\n",local);
#else
	TODO
#endif
	  sprintf(local,"%sH",$2.val); newId(GDKstrdup(local));
	  sprintf(local,"%sT",$2.val); newId(GDKstrdup(local));
	}
	stmt
	{
#ifdef M2Moffline
	  char *c;
	  printf("redo\t%s;\n", $1.val);
	  c= strchr($1.val,':');
	  if(c) *c=0;
	  printf("exit\t%s;\n",$1.val);
#else
	TODO
#endif
	  popIterator();
	}
    |   blk_expression
    |   TOK_RETURN ret_value ';'
	{
#ifdef M2Moffline
	rem; printf("\treturn %s :=%s;\n",newName(), $2.val);
#else
	TODO
#endif
	}
	/* expression in the while block could be compound !! */
    |   whilestmt '(' 
	{ $2.val= newName();
#ifdef M2Moffline
	rem; printf("barrier\t%s := true;\n",$1.val);
#else
	TODO
#endif
	  pushBlock($1.val);
	}
	 term ')' 
	{
#ifdef M2Moffline
	rem; printf("barrier\t%s := %s;\n",$2.val,$4.val); 
#else
	TODO
#endif
	  pushBlock($2.val);
	}
	sequential_block
	{ 
#ifdef M2Moffline
	 	rem; printf("redo\t%s;\n", $1.val);
#else
	TODO
#endif
		  popBlock();
#ifdef M2Moffline
		 rem; printf("exit\t%s;\n",$2.val);
#else
	TODO
#endif
		  popBlock();
#ifdef M2Moffline
		  rem; printf("exit\t%s;\n",$1.val);
		popIterator();
#else
	TODO
#endif
	}

    |   ifhead stmt
	{
#ifdef M2Moffline
		rem; printf("exit\t%s;\n",$1.val); 
#else
	TODO
#endif
		popBlock();
	}
    |   ifhead stmt TOK_ELSE 
	{ 
#ifdef M2Moffline
	  rem; printf("exit\t%s;\n",$1.val); 
#else
	TODO
#endif
	  popBlock();
	  $3.val= newName();
	  pushBlock($3.val);
#ifdef M2Moffline
	rem; printf("barrier\t%s := not(%s);\n",$3.val,$1.val);
#else
	TODO
#endif
	}
	stmt
	{
#ifdef M2Moffline
	  printf("exit\t%s;\n",$3.val); 
#else
	TODO
#endif
	  popBlock();
	}
    |   TOK_BREAK ';'
	{ 
	  printf("leave\t%s;\n",getLastIterator()); 
	} ;

ifhead: TOK_IF '(' term ')'
	{ $1.val = newName();
#ifdef M2Moffline
	rem; printf("barrier\t%s := %s;\n",$1.val,$3.val);
#else
	TODO
#endif
	  pushBlock($1.val);
	  $$=$1;
	}
    ;

whilestmt:
	TOK_WHILE
	{ $$.val= newName(); pushIterator($$.val);}
    ;

iterator :
	tok_ident '(' ')'
    |	tok_ident '(' tok_ident ')'
    |	tok_ident
    ;
        
ret_value:
        term
    |   /* empty */
	{ $$.val= GDKstrdup("nil");}
    ;

sequential_block:
        '{' statement_seq '}'
    ;

parallel_block:
        TOK_PARBLOCK 
	{ $1.val= newName(); 
#ifdef M2Moffline
	rem;    printf("thread\t%s;\n",$1.val);
#else
	TODO
#endif
	}
	statement_seq TOK_PAREND
	{ 
#ifdef M2Moffline
	   printf("exit\t%s;\n",$1.val);
#else
	TODO
#endif
	}
    ;


proc_definition:
        TOK_PROCDEF proc_name '(' proc_header 
	{
		$$.val = (str) ids;
	}
	sequential_block
	{ 
#ifdef M2Moffline
	  printf("end %s;\n",$2.val); 
#else
	TODO
#endif
	}
    |   TOK_PROCDEF tok_ident ';'
    |   TOK_UNDEF tok_ident';'
    ;


proc_name:
        tok_ident
	{
		switch($1.val[0]){
		case '[':
			$1.val[strlen($1.val)-1]=0;
#ifdef M2Moffline
		rem; 	printf("function multiplex(\"%s\",", $1.val+1);
#else
	TODO
#endif
			$1.val= GDKstrdup("multiplex");
			break;
		case '{':
			$1.val[strlen($1.val)-1]=0;
#ifdef M2Moffline
			rem; printf("function group.%s(", $1.val+1);
#else
	TODO
#endif
			$1.val= GDKstrdup("group");
			break;
		case '(':
			$1.val[strlen($1.val)-1]=0;
#ifdef M2Moffline
			rem; printf("function %s_inplace(", $1.val+1);
#else
	TODO
#endif
			$1.val= GDKstrdup("inplace");
			break;
		default: 
#ifdef M2Moffline
			rem; printf("function %s(",$1.val);
#else
	TODO
#endif
		}
		$$=$1;
	}
    |   TOK_CONSTANT
	{ 
	  if( $1.tpe == TYPE_str){
#ifdef M2Moffline
	rem; 	printf("function %s(",$1.val); 
#else
	TODO
#endif
	  } else mil_parseError("Operator name not a string literal");
	  $$=$1;}
    |   TOK_OPERATOR
	{ 
#ifdef M2Moffline
		rem; printf("function %s(",$1.val);
#else
	TODO
#endif
		
	$$=$1;} 
;

proc_header:
         mel_header ret_type
	| ret_type;
	
ret_type: ')' ':' mel_type
	{ 
#ifdef M2Moffline
	  printf("):%s;\n",$3.val);
#else
	TODO
#endif
	}
    |     ')' 
	{ 
#ifdef M2Moffline
	  printf("):void;\n");
#else
	TODO
#endif
	}
    ;

mel_header:
        mel_params ',' mel_range
    |   mel_params 
    |   mel_range
    ;

mel_range:
        TOK_RANGETEMP mel_type TOK_RANGETEMP
	{ newId($1.val); 
#ifdef M2Moffline
	  printf(",%s:%s...",$1.val,$2.val);
#else
	TODO
#endif
	}
    ;

mel_params:
        mel_type tok_ident
	{newId($2.val); 
#ifdef M2Moffline
	  printf("%s:%s",$2.val,$1.val);
#else
	TODO
#endif
	}
    |	tok_ident
	{newId($1.val); 
#ifdef M2Moffline
	  printf("%s:any",$1.val);
#else
	TODO
#endif
	}
    |   mel_params ',' mel_type tok_ident
	{newId($4.val); 
#ifdef M2Moffline
	  printf(", %s:%s",$4.val,$3.val);
#else
	TODO
#endif
	}
    |   mel_params ',' tok_ident
	{newId($3.val); 
#ifdef M2Moffline
	  printf("%s:any",$3.val);
#else
	TODO
#endif
	}
    ;

mel_type:
        tok_ident 
    |   TOK_BAT '[' mel_atom ',' mel_atom ']'
	{ char buf[PATHLENGTH];
	  sprintf(buf,"bat[:%s,:%s]",$3.val,$5.val);
	  $$.val= GDKstrdup(buf);
	}
    |   TOK_BAT 
	{ char buf[PATHLENGTH];
	  sprintf(buf,"bat[:any,:any]");
	  $$.val= GDKstrdup(buf);
	}
    |   mel_any
    ;

mel_atom:
        tok_ident
    | 	TOK_BAT
    |   mel_any
    ;

mel_any:
        TOK_ANY TOK_ANYNUM type_var
	{ char buf[PATHLENGTH];
	  sprintf(buf,"any$%s",$3.val);
	  $$.val= GDKstrdup(buf);
	}
    |   TOK_ANY
	{ $$.val = GDKstrdup("any");
	  /* printf("\n# ERROR: 'any' types should be bound to a type variable\n"); */
	}
    ;

type_var: TOK_CONSTANT
	{
	  if(strlen($1.val)>1){
	  GDKerror("ERROR:type variable should be chosen from [0-9a-zA-Z]\n");
	  }
	}
    ;

blk_expression:
        sequential_block
    |   parallel_block
    ;

expression:
    constant term 
	{ $$.val = emitExpr($2.val); }
    |   constant template TOK_ASSIGNMENT term
	{ newId($2.val); 
#ifdef M2Moffline
	rem; printf("\t%s := %s;\n", $2.val, $4.val); 
#else
	TODO
#endif
	  $$=$2;}
    |   constant tok_ident TOK_ASSIGNMENT term
	{ newId($2.val); 
#ifdef M2Moffline
	rem; printf("\t%s := %s;\n", $2.val, $4.val); 
#else
	TODO
#endif
	  $$=$2;}
    ;

constant: TOK_CONST
	| /* empty */
    ;
	
term :
	factor
    |	factor TOK_OPERATOR2 term	/* deal with += and friends */
	{ char stmt[1024];
	  $1.val = emitExpr($1.val);
	  $3.val = emitExpr($3.val);
	  sprintf(stmt,"%c(%s,%s)", $2.val[0],$1.val,$3.val);
	  $$.val=GDKstrdup(stmt);
	}
    |	factor TOK_OPERATOR3 term	/* deal with :+= and friends */
	{ char stmt[1024];
	  $1.val = emitExpr($1.val);
	  $3.val = emitExpr($3.val);
	  sprintf(stmt,"%c(%s,%s)", $2.val[1],$1.val,$3.val);
	  $$.val=GDKstrdup(stmt);
	}
    |	factor TOK_OPERATOR term
	{ char stmt[1024];
	  $1.val = emitExpr($1.val);
	  $3.val = emitExpr($3.val);
	  sprintf(stmt,"%s%s,%s)", bindFcn($2.val),$1.val,$3.val);
	  $$.val=GDKstrdup(stmt);
	}
    |	TOK_OPERATOR term
	{ char stmt[1024];
	  $2.val = emitExpr($2.val);
	  sprintf(stmt,"%s%s)", bindFcn($1.val),$2.val);
	  $$.val=GDKstrdup(stmt);
	}
    |	factor tok_ident term
	{ char stmt[1024];
	  $1.val = emitExpr($1.val);
	  $3.val = emitExpr($3.val);
	  sprintf(stmt,"%s%s,%s)", bindFcn($2.val),$1.val,$3.val);
	  $$.val=GDKstrdup(stmt);
	}
    ;

variable_reference:
        template  {$$= $1;}
    |  	tok_ident { $$=$1;} ;

template:
        TOK_TEMPLATE
	{ char *nme = newName();
#ifdef M2Moffline
	rem; printf("\t%s := mil.getVarTemp(%s);\n",nme,$1.val);
	$$.val =nme;
#else
	TODO
#endif
	}
    |   TOK_ITERTEMP
    |   TOK_VARTEMP expression ')'
	{ char *nme= newName();
#ifdef M2Moffline
	rem; printf("\t%s := mil.getVarTemp(%s);\n",nme,$2.val);
#else
	TODO
#endif
	  $$.val= nme;
	}
    |   TOK_VARTEMP expression TOK_RANGETEMP ')'
	{ char *nme= newName();
#ifdef M2Moffline
	rem; printf("\t%s := mil.getVarTempRange(%s);\n",nme,$2.val);
#else
	TODO
#endif
	  $$.val= nme;
	}
    ;


factor: factor1  |TOK_CONSTANT
	;
factor1:
       TOK_STRING
    |   TOK_BAT {$1.val=":bat[:any,:any]"; $$=$1;}
    |   fcn_path
    |  	variable_reference
	{$1.val= bindId($1.val); $$=$1;}
    | 	fcn_call
    |   '(' expression ')' { $$= $2;}
    ;

/* propagate info correctly!! */

fcn_path: 
	fcn_target '.' fcn_call
	{$$.val = emitPathCode($1.val,$3.val); }
    |	fcn_call '.' fcn_call
	{$$.val = emitPathCode($1.val,$3.val); }
    |	fcn_path  '.' fcn_call
	{$$.val = emitPathCode($1.val,$3.val); }
    ;


fcn_call:
    	fcn_hdr '(' ')'
	{ char stmt[1024];
	  sprintf(stmt,"%s)", bindFcn($1.val));
	  $$.val = GDKstrdup(stmt);}
     |	fcn_hdr '(' expr_list ')'
	{ char stmt[1024];
	  char op[1024];
	  strcpy(op,bindFcn($1.val));
	  if( strchr(op,'('))
		  sprintf(stmt,"%s%s)", op,$3.val);
	  else sprintf(stmt,"%s(%s)", op,$3.val);
	  $$.val = GDKstrdup(stmt); }
    ;

fcn_hdr: 
       TOK_DEREF factor1 ')'  
	{ char stmt[1024];
	  $2.val =emitExpr($2.val);
	  sprintf(stmt,"mil.deref(%s,",$2.val);
	  $$.val= GDKstrdup(stmt);
	}
    |  TOK_SETOP factor1 ']' 
	{ char stmt[1024];
	  $2.val =emitExpr($2.val);
	  sprintf(stmt,"mil.multiplex_deref(%s,",$2.val);
	  $$.val= GDKstrdup(stmt);
	}
    |  TOK_SETAGGR factor1 '}'
	{ char stmt[1024];
	  $2.val =emitExpr($2.val);
	  sprintf(stmt,"mil.group_deref(%s,",$2.val);
	  $$.val= GDKstrdup(stmt);
	}
    |  TOK_BAT
	{ 
	  $$.val="new";
	}
    |  TOK_OPERATOR 
	{ $$.val= bindFcn($1.val); }
    |  tok_ident	
	{ $$= $1; }
    ;
 
fcn_target : 
  	'(' expression ')'  {$$.val= $2.val;}
   |	variable_reference  {$1.val= bindId($1.val); $$=$1;}
    ;

expr_list:
     	expression
	{$$.val = emitExpr($1.val);}
    |	expr_list ',' expression
	{
	if(strlen($3.val)>0)
	 $$.val= emitExpr( glue(glue($1.val,","),$3.val));
	else $$.val=$1.val;
	}
    ;

module_list:
      modident
	/* {printf("use \"kernel/%s\";\n",$1.val);}*/
    | module_list ',' modident
	/* {printf("use \"kernel/%s\";\n",$3.val);}*/
    ;

modident:
        TOK_CONSTANT
    |   tok_ident
    |   TOK_BAT
    ;

varidents:
        TOK_VAR ident_decl
    |   varidents ',' ident_decl
    ;

ident_decl:
        tok_ident 
	{newId($1.val); }
    |   tok_ident TOK_ASSIGNMENT term
 	{newId($1.val); 
#ifdef M2Moffline
	rem; printf("\t%s := %s;\n",$1.val,$3.val); 
#else
	TODO
#endif
	}
	;
tok_ident: TOK_IDENT
	  { $$.val= mapfcn($1.val); }
    ;
%%

@-
Display the error information for the current client.
An arrow and state number is printed at the "appropriate" place. 
If no lookahead character is a used and the next character is a newline,
we should also copy the input .
@y
void mil_parseError(str msg){
        static char buf[1024];
        char *s=buf, *t, *l = mil_lastline();
        long i = strlen(GDKERROR);
	strcpy(buf,GDKERROR); s+= i;

        mil_flushbuffer(); /* flush the lexer's buffer */

        *s++ = '"';
        for(t=l; *t && *t!='\n'; t++) {
                /* accidental %s directives in the lastline can
                   crash the vfsprintf later => escape them */
                if (*t == '%') *s++ = '%';
                *s++ = *t;
        }
        *s++ = '"'; *s++ = '\n';

	/* produce the position marker*/
        for(*s++ = '!'; i > 0; i--) *s++ = ' ';
	i = mil_position();
        for(; i > 0; i--) {
                *s++ = (*l != '\t')?' ':'\t';
        }
        *s++ = '^'; *s++ = '\n'; *s = 0;
        if (msg) {
                sprintf(s, "! %s.\n", msg);
        } else {
                sprintf(s, "! "); s += 2;
                if (*s == 0) sprintf(s,"can't help you here, sorry.\n");
        }
        GDKerror(buf);
}

static void mil_print(FILE *f, /*int tpe,*//*Stefan: unused!*/ YYSTYPE v)
{
	if( v.len >0) fprintf(f," %s ", v.val);
}
const char *yylexname(int Y)           
{ 	
	(void) yytoknum; /* fool  compiler Darwin*/
	if (Y >= TOK_ITERTEMP && Y <= TOK_ANYNUM) {
		return yytname[Y-TOK_ITERTEMP];
	} 
	return "char";
}
@+ Utilities
Generation of the Mal code block requires
@c

char *getOperator(char *nme){
	int l = strlen(nme);
	str n= GDKmalloc(strlen(nme));
	strncpy(n,nme+1,l-2);
	n[l-1] = 0;
	return n;
}
#define PLACEHOLDER     '?'

char *
mapi_quote(const char *msg, int size)
{
	char *s = malloc(strlen(msg) * 2 + 1);	/* we absolutely don't need more than this (until we start producing octal escapes */
	char *t = s;

	/* the condition is tricky: if initially size < 0, we must
	   continue until a NULL byte, else, size gives the number of
	   bytes to be copied */
	while (size < 0 ? *msg : size > 0) {
		if (size > 0)
			size--;
		switch (*msg) {
		case '"':	/* added for mil-parser */
			*t++ = '\\';
			*t++ = '"';
			break;
		case '\n':
			*t++ = '\\';
			*t++ = 'n';
			break;
		case '\t':
			*t++ = '\\';
			*t++ = 't';
			break;
		case PLACEHOLDER:
			*t++ = '\\';
			*t++ = PLACEHOLDER;
			break;
		case '\\':
			*t++ = '\\';
			*t++ = '\\';
			break;
		case '\0':
			*t++ = '\\';
			*t++ = '0';
			break;
		default:
			*t++ = *msg;
			break;
		}
		msg++;
		/* also deal with binaries */
	}
	*t = 0;
	return s;
}
@}
