@a M.L. Kersten
@v 1.0
@* Standalone MIL compiler

This program is an off-line compiler for mil programs developed on
pre-Version 5. The approach taken is to be able to compile mil
programs as they appear in the modules, without too many facilities
for the interpreter.

Input is obtained from a file argument.

The underlying parser is to be included in a Mapi-mil front-end or
the applications at a later stage.

@c
#include "mal_config.h"
#include "mal.h"
#include "mal_parser.h"
#include "monet_options.h"
#include "mil.h"
#include "mil_compiler.h"
#include "mil_parser.h"	/* for mil_push() */

void prelude();
void advice();
void mil_code_prelude();

#define MAXSCRIPT 64
extern void showmappings();
extern int yyparse();
extern void mil_push(str s);
str	mil_script[MAXSCRIPT];
char	mil_cwd[PATHLENGTH];
int	trace_code= 0;

void usage(){
	printf("usage:M2m <file.mil>\n");
	exit(-1);
}
@-
A welcoming message is displayed to inform the user about recent
changes. 
@c
str absolute_path(str s) {
        if (!MT_path_absolute(s)) {
                str ret = (str)GDKmalloc(strlen(s) + strlen(mil_cwd) + 2);
                sprintf(ret, "%s%c%s", mil_cwd, DIR_SEP, s);
                return ret;
        }
        return GDKstrdup(s);
}

int main(int argc,char ** av)
{
	/* Stefan: "buf" wasn't initialized, so I set it to NULL.
	 * It is initialized eventually initialized after the line
	 * "The files are processed as one big program", 
         * however, that's too late for "case 'c'" in the 
	 * option-checking "while(1)" loop ...
	 */
        char *buf = NULL, *ptr;
        opt *set = NULL;
        int i,debug = 0, setlen = 0;
	int k,len,totlen;
	char *dbname, *dbfarmval, dbfarm[BUFSIZ];

	static struct option long_options[8] =
             {
               {"config", 1, 0, (int) 'c'},
               {"dbname", 1, 0, 0},
               {"dbfarm", 1, 0, 0},
               {"debug", 2, 0, (int) 'd'},
               {"help", 0, 0, (int) '?'},
               {"trace-code", 1, 0, (int) 't'},
               {"set", 1, 0, (int) 's'},
               {0, 0, 0, 0}
             };

        if (getcwd(mil_cwd, PATHLENGTH-1)  == NULL ){
                perror("pwd");
                GDKfatal("mil_init: could not determine current directory\n");
        }

	if (!(setlen = mo_builtin_settings(&set)) )
		usage();

	setlen = mo_add_option( &set, setlen, 
				opt_config, "prefix", MONETDBPREFIX );
	setlen = mo_add_option( &set, setlen, 
				opt_config, "config", MONETDBCONFIG );

	while(1){
		int option_index = 0;

		int c = getopt_long( argc, av, "c:d::?s:", 
				long_options, &option_index);

		if (c == -1)
			break;

		switch (c){
		case 0:
			if (strcmp(long_options[option_index].name, 
						"dbname") == 0){
				setlen = mo_add_option( &set, setlen, 
					opt_cmdline, "gdk_dbname", optarg );
				break;
			}
			if (strcmp(long_options[option_index].name, 
						"dbfarm") == 0){
				setlen = mo_add_option( &set, setlen, 
					opt_cmdline, "gdk_dbfarm", optarg );
				break;
			}
			usage();
			break;
		case 'c':
			if( *optarg!='/' && *optarg !='.') {
                                snprintf(buf,BUFSIZ,"%s/%s",mil_cwd,optarg);
				setlen = mo_add_option( &set, setlen, 
					opt_cmdline, "config", buf );
                        } else { 
				setlen = mo_add_option( &set, setlen, 
					opt_cmdline, "config", optarg );
			}
			break;
		case 'd':
			debug=1;
			if (optarg){ 
				setlen = mo_add_option( &set, setlen, 
					opt_cmdline, "gdk_debug", optarg );
			}
			break;
		case 't': {
			/* generate MIL trace code */
			if( optarg) trace_code = atoi(optarg);
			} break;
		case 's': {
			/* should add option to a list */
			char *tmp = strchr(optarg, '=');

			if (tmp){
				*tmp = '\0';
				setlen = mo_add_option( &set, setlen, 
					opt_cmdline, optarg, tmp+1 );
			} else {
				fprintf(stderr, "ERROR: wrong format %s\n", 
					optarg);
			}
		 } break;
		case '?':
			usage();
		default:
			fprintf( stderr, 
			    "ERROR: getopt returned character code 0%o ??\n",c);
			usage();
		}
	}

	if (!(setlen = mo_system_config(&set, setlen)))
		usage();

	i = 0;
	mil_script[i] = NULL;
	while(optind < argc){
		mil_script[i] = absolute_path(av[optind]);
		mil_script[i+1] = NULL;
		optind++;
		i++;
	}

	if (debug)
		mo_print_options(set, setlen);
#ifdef MSERVER_DEBUG
	else	mo_print_options(set,setlen);
#endif
	dbname = mo_find_option(set, setlen, "gdk_dbname");
	dbfarmval = mo_find_option(set, setlen, "gdk_dbfarm");
        strcpy(dbfarm, dbfarmval );
        mo_substitute(set, setlen, dbfarm);

	/* not needed? if (!GDKinit(dbname, dbfarm,0)) return 1;  ERROR? */
	(void) dbname;
@-
The files are processed as one big program
@c
	i=0;
	len = totlen = 8*8192;
	ptr = buf= (char*) GDKmalloc(totlen);
	for(k=0;mil_script[k]!= 0; k++) {
		FILE *fd;
		char fname[PATHLENGTH];

		snprintf(fname,PATHLENGTH,"%s",mil_script[k]);
		fd = fopen(fname,"rb");
		if (fd == 0) {
			printf("mil: could not open file: %s\n", fname);
			exit (-1);
		}

		while((i+=fread(ptr, 1, len , fd)) == totlen) {
			len = totlen; totlen *= 2;
			ptr = GDKmalloc(totlen);
			memcpy(ptr, buf, len);
			GDKfree(buf);
			buf = ptr; ptr += len;
		}
		fclose(fd);
		buf[i] = 0;
	}
	prelude();
	mil_push(buf);	
	yyparse();
	showmappings();
	mo_free_options(set,setlen);

	return 0;
}

void prelude(){
        printf("# Monet Mil to Mal compiler\n");
        printf("# Copyright (c) 2001-2005, CWI. ");
        printf("All rights reserved.\n");
	printf("\n#Predefined code segment\n");
	advice();
	mil_code_prelude();
}
/* The compiler does not compile everything */
char *hlp[]={
"The compiler can not guarantee an accurate compilation,",
"because MIL unlike MAL is a dynamically typed language.",
"A few guidelines to maximize usefullness.",
"- make the type of variables explicit, in particular 'nil'",
"- upon advice of M2m to remap identifiers, change it in your program directly",
0
};
void advice(){
	int i;
	for(i=0; hlp[i]; i++) printf("#%s\n",hlp[i]);
}
char *code[]={
"include mil",
"include mil_system_procs;",
"include mil_algebra_procs",
0
};
void mil_code_prelude(){
	int i;
	for(i=0; code[i]; i++) printf("%s\n",code[i]);
}
