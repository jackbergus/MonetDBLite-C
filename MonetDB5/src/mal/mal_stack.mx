@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
@' Copyright August 2008-2010 MonetDB B.V.
@' All Rights Reserved.

@f mal_stack
@a M. L. Kersten
@-
@node Stack Management, The MAL Optimizer, Garbage Collection, The MAL Interpreter
@+ MAL runtime stack
The runtime context of a MAL procedure is allocated on the runtime stack
of the corresponding interpreter.
Access to the elements in the stack are through index offsets,
determined during MAL procedure parsing.

The scope administration for MAL procedures is
decoupled from their actual runtime behavior. This means we are
more relaxed on space allocation, because the size is determined
by the number of MAL procedure definitions instead of the runtime
calling behavior. (See mal_interpreter for details on value stack
management)

The variable names and types are kept in the stack to ease debugging.
The underlying string value need not be garbage collected.
Runtime storage for variables are allocated on the stack of the
interpreter thread. The physical stack is often limited in size,
which calls for safeguarding their value and garbage collection before returning.
A malicious procedure or implementation will lead to memory leakage.

A system command (linked C-routine) may be interested in extending the
stack. This is precluded, because it could interfere with the recursive
calling sequence of procedures. To accommodate the (rare) case, the routine
should issue an exception to be handled by the interpreter before retrying.
All other errors are turned into an exception, followed by continuing
at the exception handling block of the MAL procedure.

@{
The interpreter should be protected against physical stack overflow.
The solution chosen is to maintain an incremental depth size.
Once it exceeds a threshold, we call upon the kernel to
ensure we are still within safe bounds.
@h
#ifndef _MAL_STACK_H_
#define _MAL_STACK_H_
#include "mal.h"
#include "gdk.h"
#include "gdk_system.h"

#ifdef HAVE_SYS_TIMES_H
#include <sys/times.h>
#endif

#define STACKINCR   128
#define MAXGLOBALS  4 * STACKINCR
#define MAXSHARES   8

typedef struct MALSTK {
	int stksize;
	int stktop;
	int stkbot;			/* the first variable to be initialized */
	int stkdepth;		/* to protect against runtime stack overflow */
	int calldepth;		/* to protect against runtime stack overflow */
	short keepAlive;	/* do not garbage collect when set */
	short garbageCollect; /* stack needs garbage collection */
	MT_Lock stklock;	/* used for parallel processing */
@-
It is handy to administer the timing in the stack frame
for use in profiling and recylcing instructions.
@h
#ifdef HAVE_TIMES
    struct tms timer;   /* timing information */
#endif
	struct timeval clock;		/* seconds + microsecs since epoch */
	lng clk;			/* micro seconds */
	char cmd;		/* debugger communication */
	int pcup;		/* saved pc upon a recursive all */
	struct MALSTK *up;	/* stack trace list */
	struct MALBLK *blk;	/* associated definition */
	ValRecord stk[1];
} MalStack, *MalStkPtr;

#define stackSize(CNT) (sizeof(ValRecord)*(CNT) + sizeof(MalStack))
#define newStack(S,CNT) S= (MalStkPtr) alloca(stackSize(CNT));\
		(S)->stksize=CNT;


mal_export MalStkPtr newGlobalStack(int size);
mal_export MalStkPtr reallocStack(MalStkPtr s, int cnt);
mal_export MalStkPtr reallocGlobalStack(MalStkPtr s, int cnt);
mal_export void freeStack(MalStkPtr stk);
mal_export void clearStack(MalStkPtr s);
mal_export void chkStack(MalStkPtr stk, int i);	/* used in src/mal/mal_box.c */

#define VARfreeze(X)    if(X){X->frozen=TRUE;}
#define VARfixate(X)    if(X){X->constant=TRUE;}

#define getStkRecord(S,P,I) &(S)->stk[(P)->argv[I]]
#define getStkValue(S,P,I)  ( getStkType(S,P,I)== TYPE_str? \
					getStkRecord(S,P,I)->val.sval :\
					getStkRecord(S,P,I)->val.pval )
#define getStkType(S,P,I)   (S)->stk[(P)->argv[I]].vtype
#define setStkType(S,P,I,T) (S)->stk[(P)->argv[I]].vtype = T
#endif /* _MAL_STACK_H_ */
@-
The clearStack operation throws away any space occupied by variables
Freeing the stack itself is automatic upon return from the interpreter
context. Since the stack is allocated and zeroed on the calling stack,
it may happen that entries are never set to a real value.
This can be recognized by the vtype component
@c
#include "mal_config.h"
#include "mal_stack.h"

/* #define DEBUG_MAL_STACK*/

MalStkPtr
newGlobalStack(int size)
{
	MalStkPtr s;

	s = (MalStkPtr) GDKzalloc(stackSize(size) + sizeof(MalStack));
	if (s == NULL)
		GDKfatal("newGlobalStack:can not obtain memory\n");
	s->stksize = size;
	return s;
}

MalStkPtr
reallocGlobalStack(MalStkPtr old, int cnt)
{
	int k;
	MalStkPtr s;

	if (old->stksize > cnt)
		return old;
	k = ((cnt / STACKINCR) + 1) * STACKINCR;
	s = newGlobalStack(k);
	memcpy(s, old, stackSize(old->stksize));
	s->stksize = k;
	GDKfree(old);
	return s;
}

MalStkPtr
reallocStack(MalStkPtr s, int cnt)
{
	int k;
	MalStkPtr old = s;

	if (s->stksize > cnt)
		return s;
	k = ((cnt / STACKINCR) + 1) * STACKINCR;
	s = (MalStkPtr) alloca(stackSize(k));
	memset((char *) s, 0, stackSize(k));
	memcpy(s, old, stackSize(old->stksize));
	s->stksize = k;
	/* cannot gdk free, alloca data */
	assert(0);
	GDKfree(old);
	return s;
}

@-
When you add a value to the stack, you should ensure that
there is space left. It should only be used for global
stack frames, because the others are allocated in the
runtime stack.
@c
void
chkStack(MalStkPtr stk, int i)
{
	if (stk->stksize <= i) {
		reallocStack(stk, STACKINCR);
	}
}
void
freeStack(MalStkPtr stk)
{
	clearStack(stk);
	GDKfree(stk);
}

void
clearStack(MalStkPtr s)
{
	ValPtr v;
	int i = s->stktop;

	for (v = s->stk; i >= 0; i--, v++)
		if (ATOMextern(v->vtype) && v->val.pval) {
			GDKfree(v->val.pval);
			v->val.pval = NULL;
		}
	s->stkbot = 0;
}

@}
