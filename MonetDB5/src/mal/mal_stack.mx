@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2006 CWI.
@' All Rights Reserved.

@f mal_stack
@a M. L. Kersten

@+ MAL runtime stack
The runtime context of a MAL procedure is allocated on the runtime stack
of the corresponding interpreter.
Access to the elements in the stack are through index offsets,
determined during MAL procedure parsing.
This method has been proven highy efficient compared to using 
individual GDKmalloci calls.

Unlike Monet Version 4, the scope administration for MAL procedures is
decoupled from their actual runtime behavior. This means we are
more relaxed on space allocation, because the size is determined
by the number of MAL procedure definitions instead of the runtime
calling behavior. (See mal_interpreter for details on value stack
management)

The variable names and types are kept in the stack to ease debugging.
The underlying string value need not be garbage collected.

The interpreter should be protected against physical stack overflow.
The solution chosen is to maintain an incremental depth size.
Once it exceeds a threshold, we call upon the kernel to
ensure we are still within safe bounds.
@{
@h
#ifndef _MAL_STACK_H_
#define _MAL_STACK_H_
#include "mal.h"
#include "gdk.h"
#include "gdk_system.h"

#define STACKINCR   128
#define MAXGLOBALS  4 * STACKINCR
#define MAXSHARES   2

typedef struct MALSTK {
	int stksize;
	int stktop;
	lng stkdepth;		/* to protect against overflow */
	short keepAlive;	/* do not garbage collect when set */
	short garbageCollect; /* stack needs garbage collection */
	MT_Lock stklock;	/* used for parallel processing */
	int shares;			/* number of processes locked onto this stack */
	int childs[MAXSHARES]; /* not used */
	char cmd;		/* debugger communication */
	int pcup;		/* saved pc upon a recursive all */
	struct MALSTK *up;	/* stack trace list */
	struct MALSTK *down;	/* stack trace list */
	struct MALBLK *blk;	/* associated definition */
	ValRecord stk[1];
} MalStack, *MalStkPtr;

#define stackSize(CNT) (sizeof(ValRecord)*(CNT) + sizeof(MalStack))
#define newStack(S,CNT) S= (MalStkPtr) alloca(stackSize(CNT));\
		(S)->stksize=CNT;


mal_export MalStkPtr newGlobalStack(int size);
mal_export MalStkPtr reallocStack(MalStkPtr s, int cnt);
mal_export MalStkPtr reallocGlobalStack(MalStkPtr s, int cnt);
mal_export void freeStack(MalStkPtr stk);
mal_export void chkStack(MalStkPtr stk, int i);	/* used in src/mal/mal_box.c */

#define VARfreeze(X)    if(X){X->frozen=TRUE;}
#define VARfixate(X)    if(X){X->constant=TRUE;}

#define getStkRecord(S,P,I) &(S)->stk[(P)->argv[I]]
#define getStkValue(S,P,I)  ( getStkType(S,P,I)== TYPE_str? \
					getStkRecord(S,P,I)->val.sval :\
					getStkRecord(S,P,I)->val.pval )
#define getStkType(S,P,I)   (S)->stk[(P)->argv[I]].vtype
#define setStkType(S,P,I,T) (S)->stk[(P)->argv[I]].vtype = T
#endif /* _MAL_STACK_H_ */
@-
The clearStack operation throws away any space occupied by variables
Freeing the stack itself is automatic upon return from the interpreter
context. Since the stack is allocated and zeroed on the calling stack,
it may happen that entries are never set to a real value.
This can be recognized by the vtype component
@c
#include "mal_stack.h"

MalStkPtr
newGlobalStack(int size)
{
	MalStkPtr s;

	s = (MalStkPtr) GDKmalloc(stackSize(size) + sizeof(MalStack));
	if (s == NULL)
		GDKfatal("newGlobalStack:can not obtain memory\n");
	memset((char *) s, 0, stackSize(size) + sizeof(MalStack));
	s->stksize = size;
	return s;
}

MalStkPtr
reallocGlobalStack(MalStkPtr old, int cnt)
{
	int k;
	MalStkPtr s;

	if (old->stksize > cnt)
		return old;
	k = ((cnt / STACKINCR) + 1) * STACKINCR;
	s = newGlobalStack(k);
	memcpy(s, old, stackSize(old->stksize));
	s->stksize = k;
	GDKfree(old);
	return s;
}

MalStkPtr
reallocStack(MalStkPtr s, int cnt)
{
	int k;
	MalStkPtr old = s;

	if (s->stksize > cnt)
		return s;
	k = ((cnt / STACKINCR) + 1) * STACKINCR;
	s = (MalStkPtr) alloca(stackSize(k));
	memset((char *) s, 0, stackSize(k));
	memcpy(s, old, stackSize(old->stksize));
	s->stksize = k;
	/* cannot gdk free, alloca data */
	assert(0);
	GDKfree(old);
	return s;
}

@-
When you add a value to the stack, you should ensure that
there is space left. It should only be used for global
stack frames, because the others are allocated in the
runtime stack.
@c
void
chkStack(MalStkPtr stk, int i)
{
	if (stk->stksize <= i) {
		reallocStack(stk, STACKINCR);
	}
}
void
freeStack(MalStkPtr stk)
{
	GDKfree(stk);
}

void
clearStack(MalStkPtr s)
{
	ValPtr v;
	int i = s->stktop;

	for (v = s->stk; i >= 0; i--, v++)
		if (ATOMextern(v->vtype) && v->val.pval) {
			stream_printf(GDKout, "freeing %s\n", v->val.sval);
			GDKfree(v->val.pval);
		}
}

@}
