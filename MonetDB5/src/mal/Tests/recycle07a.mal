# Test of CREDIT cache policy in limited cache (7 lines, 1 is always taken by fake 0)
# Evicts the leaf instruction with smallest credit= cnt * cost
# The recent, non reused instructions are protected from eviction

function user.bind(s:str,t:str,c:str,i:int):bat[:oid,:int];
b:= bat.new(:oid,:int);
barrier (go,i):= language.newRange(0:int);
	bat.append(b,i);
	redo (go,i):= language.nextElement(1:int,1000:int);
exit (go,i);
return bind:=b;
end bind;

function qry(low:int, hgh:int);
	b:= user.bind("schema","table","column",0);
	s1:= algebra.select(b,low,hgh);
	m0:= algebra.markT(s1, 0@0);
end qry;

recycle.setRetainPolicy(1);
recycle.setReusePolicy(1);
recycle.setCachePolicy(2,7);
optimizer.recycle("user","qry");

io.print("start");
qry(100,250);
qry(100,250);
qry(700,710);
recycle.dump();
# The next query should evict markT leaf ( #3). The other leaf markT (#5) is cheaper,
# but fresh and not reused(cnt=1), thus protected from eviciton.
qry(400,700);
recycle.dump();
