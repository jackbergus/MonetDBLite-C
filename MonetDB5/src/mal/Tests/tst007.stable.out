stdout of test 'tst007` in directory 'src/mal` itself:


# 07:58:34 >  
# 07:58:34 >  Mtimeout -timeout 60 Mserver "--config=/ufs/mk/monet5/Linux/etc/MonetDB5.conf" --debug=10 --set "monet_mod_path=/ufs/mk/monet5/Linux/lib/MonetDB5:/ufs/mk/opensource/MonetDB/Linux/lib/MonetDB" --set "gdk_dbfarm=/ufs/mk/monet5/Linux/var/MonetDB5/dbfarm" --set "sql_logdir=/ufs/mk/monet5/Linux/var/MonetDB5/log" --set mapi_port=42158 --set sql_port=55708 --set monet_prompt= --trace "--config=/ufs/mk/monet5/src/mal/Tests/All.conf" --dbname=mTests_src_mal  tst007.mal </dev/null
# 07:58:34 >  

# Monet Database Server V4.99.19
# Copyright (c) 1993-2004, CWI. All rights reserved.
# Compiled for i686-redhat-linux-gnu/32bit; dynamically linked.
# config:/ufs/mk/monet5/Linux/etc/MonetDB5.conf
# dbfarm:/ufs/mk/monet5/Linux/var/MonetDB5/dbfarm
# dbname:mTests_src_mal
# Visit http://monetdb.cwi.nl/ for further information.
## A collection of forloops, which should not execute
#barrier	H := batoperatie;
#	Tail:= bat.fetch(b,H);
#	#body
#redo 	H;
#exit	H;
#
#
## de andere loops zijn eenvoudig. 'goto' is altijd beperkt tot
## 'randen' van het blok. (redo L, leave L)
## een while loop
#barrier L := bat.hasMoreElements(b);
#	H:= bat.head(b);
#	v:= bat.nextElement(b);
#redo	L;
#exit	L;
#	
##een do-while loop
#	entry:= true;
#barrier M:= entry_or_exittest;
#	entry:= false;
#	# rest
#redo	M;
#exit	M;
#
##een for-loop 
#	i:= 1;
#barrier N:= i<10;
#	#body
#	i:=i+1;
#redo	N;
#exit	N;
#
#
## de if-then en if-then-else constructies
#
#barrier	FT:= booleanexpr;
#	# thenpart
#exit	FT;
#
#barrier	FTE:= booleanexpr;
#	# thenpart
#exit	FTE;
#barrier FS:= not(FTE);
#	#elsepart
#exit	FS;
#
#end foo;
!TypeException:user.foo[2]:'algebra.fetch' undefined in: Tail:any := algebra.fetch(b:any, H:any)
!TypeException:user.foo[9]:'chop.hasMoreElements' undefined in: L:any := chop.hasMoreElements(b:any)
!TypeException:user.foo[10]:'chop.head' undefined in: H:any := chop.head(b:any)
!TypeException:user.foo[11]:'chop.nextElement' undefined in: v:any := chop.nextElement(b:any)
!TypeException:user.foo[35]:'batcalc.not' undefined in: FS:any := batcalc.not(FTE:any)
!TypeException:user.foo[1]:barrier 'H' should be of type bit, str or number
!TypeException:user.foo[9]:barrier 'L' should be of type bit, str or number
!TypeException:user.foo[16]:barrier 'M' should be of type bit, str or number
!TypeException:user.foo[29]:barrier 'FT' should be of type bit, str or number
!TypeException:user.foo[32]:barrier 'FTE' should be of type bit, str or number
!TypeException:user.foo[35]:barrier 'FS' should be of type bit, str or number
!TypeException:user.foo[1]:'batoperatie' may not be used before being initialized
!TypeException:user.foo[2]:'b' may not be used before being initialized
!TypeException:user.foo[9]:'b' may not be used before being initialized
!TypeException:user.foo[16]:'entry_or_exittest' may not be used before being initialized
!TypeException:user.foo[29]:'booleanexpr' may not be used before being initialized
function user.foo():void;               #  0 foo:void 
barrier H := batoperatie;               #  1 H:any := batoperatie:any {J5}
    Tail := algebra.fetch(b,H);         #  2 Tail:any := algebra.fetch(b:any, H:any) {U}
#body                                   #  3 
    redo H;                             #  4 H:any {J2}
exit H;                                 #  5 H:any 
# de andere loops zijn eenvoudig. 'goto' is altijd beperkt tot #  6 
# 'randen' van het blok. (redo L, leave L) #  7 
# een while loop                        #  8 
barrier L := chop.hasMoreElements(b);   #  9 L:any := chop.hasMoreElements(b:any) {UJ13}
    H := chop.head(b);                  # 10 H:any := chop.head(b:any) {U}
    v := chop.nextElement(b);           # 11 v:any := chop.nextElement(b:any) {U}
    redo L;                             # 12 L:any {J10}
exit L;                                 # 13 L:any 
#een do-while loop 
    entry := true;                      # 15 entry:bit := _13:bit 
barrier M := entry_or_exittest;         # 16 M:any := entry_or_exittest:any {J20}
    entry := false;                     # 17 entry:bit := _16:bit 
# rest 
    redo M;                             # 19 M:any {J17}
exit M;                                 # 20 M:any 
#een for-loop  
    i := 1;                             # 22 i:int := _20:int 
barrier N := calc.<(i,10);              # 23 N:bit := CALCcompLTintint(i:int, _22:int) {J27}
#body 
    i := calc.+(i,1);                   # 25 i:int := CALCbinaryADDintint(i:int, _20:int) 
    redo N;                             # 26 N:bit {J24}
exit N;                                 # 27 N:bit 
# de if-then en if-then-else constructies 
barrier FT := booleanexpr;              # 29 FT:any := booleanexpr:any {J31}
# thenpart 
exit FT;                                # 31 FT:any 
barrier FTE := booleanexpr;             # 32 FTE:any := booleanexpr:any {J34}
# thenpart 
exit FTE;                               # 34 FTE:any 
barrier FS := batcalc.not(FTE);         # 35 FS:any := batcalc.not(FTE:any) {UJ37}
#elsepart                               # 36 
exit FS;                                # 37 FS:any 
end foo;	# 38  
#
function user.main():void;              #  0 main:void 
# A collection of forloops, which should not execute 
end main;	# 2  

# 07:58:34 >  
# 07:58:34 >  Done.
# 07:58:34 >  

