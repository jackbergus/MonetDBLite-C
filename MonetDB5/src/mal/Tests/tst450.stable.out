stdout of test 'tst450` in directory 'src/mal` itself:


# 22:19:31 >  
# 22:19:31 >  Mtimeout -timeout 60 Mserver "--config=/ufs/mk/monet5/src/mal/Tests/All.conf" --debug=10 --set "monet_mod_path=/ufs/mk/monet5/Linux/lib/MonetDB5:/ufs/mk/opensource/MonetDB/Linux/lib/MonetDB" --set "gdk_dbfarm=/ufs/mk/opensource/MonetDB/Linux/var/MonetDB5/dbfarm" --set "sql_logdir=/ufs/mk/opensource/MonetDB/Linux/var/MonetDB5/log" --set mapi_port=30312 --set sql_port=44446 --set xquery_port=54810 --set monet_prompt= --trace "--config=/ufs/mk/monet5/src/mal/Tests/All.conf" --dbname=mTests_src_mal  tst450.mal </dev/null
# 22:19:31 >  

# Monet Database Server V4.99.19
# Copyright (c) 1993-2005, CWI. All rights reserved.
# Compiled for x86_64-redhat-linux-gnu/64bit with 64bit OIDs; dynamically linked.
# config:/ufs/mk/monet5/src/mal/Tests/All.conf
# dbfarm:/ufs/mk/opensource/MonetDB/Linux/var/MonetDB5/dbfarm
# dbname:mTests_src_mal
# Visit http://monetdb.cwi.nl/ for further information.
##testing the inspect module for help information
#
#a:= inspect.getAtomNames();	io.print(a);
#m:= inspect.getModule();	mr:= bat.reverse(m);
#m1:= algebra.kunique(mr);   m1r:= bat.reverse(m1); io.print(m1r);
#stmt:= inspect.getDefinition("algebra","select");
#sig:= inspect.getSignature("algebra","select");
#
#n:= manual.help("algebra","insert"); io.print(n);
#d:= inspect.getDefinition("inspect","dir"); io.print(d);
#
function user.main():void;	# 0  (main:void)
#testing the inspect module for help information 	# 1  (_2:str)
    a := inspect.getAtomNames();	# 2 INSPECTatom_names (a:bat[:int,:str])
    io.print(a);	# 3 IOprint_val (_3:int)<-(a:bat[:int,:str])
    m := inspect.getModule();	# 4 INSPECTgetAllModules (m:bat[:void,:str])
    mr := bat.reverse(m);	# 5 BKCreverse (mr:bat[:str,:void])<-(m:bat[:void,:str])
    m1 := algebra.kunique(mr);	# 6 ALGkunique (m1:bat[:str,:void])<-(mr:bat[:str,:void])
    m1r := bat.reverse(m1);	# 7 BKCreverse (m1r:bat[:void,:str])<-(m1:bat[:str,:void])
    io.print(m1r);	# 8 IOprint_val (_8:int)<-(m1r:bat[:void,:str])
    stmt := inspect.getDefinition("algebra","select");	# 9 INSPECTgetDefinition (stmt:bat[:str,:str])<-(_10:str)(_11:str)
    sig := inspect.getSignature("algebra","select");	# 10 INSPECTgetSignature (sig:bat[:str,:str])<-(_10:str)(_11:str)
    n := manual.search("insert");	# 11 MANUALsearch (n:void)<-(_14:str)
    io.print(n);	# 12 IOprint_val (_15:int)<-(n:void)
    d := inspect.getDefinition("inspect","dir");	# 13 INSPECTgetDefinition (d:bat[:str,:str])<-(_17:str)(_18:str)
    io.print(d);	# 14 IOprint_val (_19:int)<-(d:bat[:str,:str])
end main;	# 15  
#-------------------------#
# view	atom		  # name
# int	str		  # type
#-------------------------#
[ 0,	  "void"	  ]
[ 1,	  "bit"		  ]
[ 2,	  "chr"		  ]
[ 3,	  "sht"		  ]
[ 4,	  "BAT"		  ]
[ 5,	  "int"		  ]
[ 6,	  "oid"		  ]
[ 7,	  "ptr"		  ]
[ 8,	  "flt"		  ]
[ 9,	  "dbl"		  ]
[ 10,	  "lng"		  ]
[ 11,	  "str"		  ]
[ 12,	  "lock"	  ]
[ 13,	  "sema"	  ]
[ 14,	  "stream"	  ]
[ 15,	  "bstream"	  ]
[ 16,	  "blob"	  ]
[ 17,	  "sqlblob"	  ]
[ 18,	  "color"	  ]
[ 19,	  "url"		  ]
[ 20,	  "date"	  ]
[ 21,	  "daytime"	  ]
[ 22,	  "timestamp"	  ]
[ 23,	  "tzone"	  ]
[ 24,	  "rule"	  ]
[ 25,	  "pcre"	  ]
[ 26,	  "mapentry"	  ]
[ 27,	  "idxentry"	  ]
#-------------------------#
# t	h		  # name
# oid	str		  # type
#-------------------------#
[ 0@0,	  "user"	  ]
[ 2@0,	  "partitions"	  ]
[ 31@0,	  "transaction"	  ]
[ 39@0,	  "chop"	  ]
[ 47@0,	  "optimizer"	  ]
[ 96@0,	  "mat"		  ]
[ 102@0,  "statistics"	  ]
[ 129@0,  "profiler"	  ]
[ 151@0,  "mal"		  ]
[ 175@0,  "inspect"	  ]
[ 193@0,  "manual"	  ]
[ 202@0,  "pbm"		  ]
[ 232@0,  "box"		  ]
[ 243@0,  "bbp"		  ]
[ 277@0,  "const"	  ]
[ 291@0,  "factory"	  ]
[ 299@0,  "io"		  ]
[ 325@0,  "tablet"	  ]
[ 355@0,  "clients"	  ]
[ 375@0,  "batcolor"	  ]
[ 391@0,  "batstr"	  ]
[ 426@0,  "batcalc"	  ]
[ 1225@0, "batmath"	  ]
[ 1260@0, "mkey"	  ]
[ 1271@0, "pqueue"	  ]
[ 1352@0, "mapi"	  ]
[ 1363@0, "array"	  ]
[ 1374@0, "group"	  ]
[ 1408@0, "status"	  ]
[ 1423@0, "calc"	  ]
[ 1936@0, "algebra"	  ]
[ 2032@0, "aggr"	  ]
[ 2177@0, "pcre"	  ]
[ 2198@0, "bat"		  ]
[ 2296@0, "date"	  ]
[ 2307@0, "daytime"	  ]
[ 2317@0, "timestamp"	  ]
[ 2330@0, "tzone"	  ]
[ 2335@0, "rule"	  ]
[ 2340@0, "mtime"	  ]
[ 2437@0, "url"		  ]
[ 2458@0, "str"		  ]
[ 2497@0, "color"	  ]
[ 2518@0, "blob"	  ]
[ 2534@0, "sqlblob"	  ]
[ 2536@0, "stream"	  ]
[ 2553@0, "bstream"	  ]
[ 2556@0, "mmath"	  ]
[ 2598@0, "alarm"	  ]
[ 2607@0, "sema"	  ]
[ 2611@0, "lock"	  ]
[ 2617@0, "unix"	  ]
[ 2619@0, "mdb"		  ]
[ 2639@0, "crackers"	  ]
command bat.insert(b:bat[:void,:BAT],z:bat[:any_1,:any_2]):void address BKCinsert_void_bun;
#Insert a value in a 'void' bat

command bat.insert(b:bat[:any_1,:BAT],v:any_1,z:bat[:any_3,:any_4]):void address BKCinsert_bun;
command bat.insert(b:bat[:void,:any_1],v:any_1):void address BKCinsert_void_bun;
#Insert a value in a 'void' bat

command bat.insert(b:bat[:oid,:str],h:oid,t:str):void address BKCinsert_bun_oid_str;
command bat.insert(b:bat[:void,:str],h:oid,t:str):void address BKCinsert_bun_oid_str;
command bat.insert(b:bat[:void,:any_2],h:oid,t:any_2):void address BKCinsert_bun_oid_any;
command bat.insert(b:bat[:oid,:any_2],h:oid,t:any_2):void address BKCinsert_bun_oid_any;
command bat.insert(b:bat[:int,:int],h:int,t:int):void address BKCinsert_bun_int_int;
command bat.insert(b:bat[:any_1,:any_2],h:any_1,t:any_2):void address BKCinsert_bun;
#Insert one BUN[h,t] in a BAT.

command bat.insert(b:bat[:any_1,:any_2],src:bat[:any_1,:any_2]):void address BKCinsert_bat;
#Insert all BUNs of the second BAT into the first.

command bat.insert(b:bat[:oid,:any_2],src:bat[:void,:any_2]):void address BKCinsert_bat;
#Insert all BUNs of the second BAT into the first. This case 
#should be removed, because it is a hack for SQL

command bat.insert(b:bat[:void,:any_2],src:bat[:oid,:any_2]):void address BKCinsert_bat;
#Insert all BUNs of the second BAT into the first. This case 
#should be removed, because it is a hack for SQL

command bat.insert(b:bat[:any_1,:oid],src:bat[:any_1,:void]):void address BKCinsert_bat;
#Insert all BUNs of the second BAT into the first. This case 
#should be removed, because it is a hack for SQL

command bat.setSet(b:bat[:any_1,:any_2],mode:bit):bat[:any_1,:any_2] address BKCsetSet;
#Sets the 'set' property on this BAT to 'mode'. In 'set' mode, 
#the kernel will silently block insertions that cause a duplicate 
#BUN [head,tail] entries in the BAT.  KNOWN BUG:when 'set' is set 
#to TRUE, this function does not automatically eliminate duplicates. 
#Use b := b.sunique; Returns the BAT itself.

command bat.setKey(b:bat[:any_1,:any_2],mode:bit):bat[:any_1,:any_2] address BKCsetkey;
#Sets the 'key' property of the head column to 'mode'. In 'key' mode, 
#the kernel will silently block insertions that cause a duplicate 
#entries in the head column. KNOWN BUG:when 'key' is set to TRUE, this 
#function does not automatically eliminate duplicates. 
#Use b := b.kunique;

command io.import(b:bat[:any_1,:any_2],filepath:str):bit address IOimport;
#Import a BAT from an ASCII dump. The new tuples are *inserted* into the
#parameter BAT. You have to create it! Its signature must match the dump,
#else parsing errors will occur and FALSE is returned.

command partitions.insert(b:bat[:void,:any_1],p:bat[:void,:any_1]):bat[:void,:any_1] address BPTinsertBAT;
#Add a BAT as a partition to the end of the list.

command partitions.insert(b:bat[:void,:any_1],t:any_1):bat[:void,:any_1] address BPTinsert_void_bun;
#Add a tuple to the last partition

command partitions.insert(b:bat[:void,:any_1],h:void,t:any_1):bat[:void,:any_1] address BPTinsert;
#Add a tuple to the last partition

command str.insert(s:str,start:int,l:int,s2:str):str address STRinsert;
#Insert a string into another

command transaction.alpha(b:bat[:any_1,:any_2]):bat[:any_1,:any_2] address TRNtrans_alpha;
#List insertions since last commit.

[ nil ]
#-----------------#
# view	fcn	  # name
# int	str	  # type
#-----------------#

# 22:19:31 >  
# 22:19:31 >  Done.
# 22:19:31 >  

