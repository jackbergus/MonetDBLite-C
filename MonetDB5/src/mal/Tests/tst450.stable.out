stdout of test 'tst450` in directory 'src/mal` itself:


# 22:19:31 >  
# 22:19:31 >  Mtimeout -timeout 60 Mserver "--config=/ufs/mk/monet5/src/mal/Tests/All.conf" --debug=10 --set "monet_mod_path=/ufs/mk/monet5/Linux/lib/MonetDB5:/ufs/mk/opensource/MonetDB/Linux/lib/MonetDB" --set "gdk_dbfarm=/ufs/mk/opensource/MonetDB/Linux/var/MonetDB5/dbfarm" --set "sql_logdir=/ufs/mk/opensource/MonetDB/Linux/var/MonetDB5/log" --set mapi_port=30312 --set sql_port=44446 --set xquery_port=54810 --set monet_prompt= --trace "--config=/ufs/mk/monet5/src/mal/Tests/All.conf" --dbname=mTests_src_mal  tst450.mal </dev/null
# 22:19:31 >  

# Monet Database Server V4.99.19
# Copyright (c) 1993-2005, CWI. All rights reserved.
# Compiled for x86_64-redhat-linux-gnu/64bit with 64bit OIDs; dynamically linked.
# config:/ufs/mk/monet5/src/mal/Tests/All.conf
# dbfarm:/ufs/mk/opensource/MonetDB/Linux/var/MonetDB5/dbfarm
# dbname:mTests_src_mal
# Visit http://monetdb.cwi.nl/ for further information.
##testing the inspect module for help information
#
#a:= inspect.getAtomNames();	io.print(a);
#m:= inspect.getModule();	mr:= bat.reverse(m);
#m1:= algebra.kunique(mr);   m1r:= bat.reverse(m1); io.print(m1r);
#stmt:= inspect.getDefinition("algebra","select");
#sig:= inspect.getSignature("algebra","select");
#
#n:= manual.help("algebra","insert"); io.print(n);
#d:= inspect.getDefinition("inspect","dir"); io.print(d);
#
function user.main():void;              #  0 main:void := user.main() {G}
#testing the inspect module for help information 
    a := inspect.getAtomNames();        #  2 a:bat[:int,:str] := INSPECTatom_names() {G}
    io.print(a);                        #  3 _3:void := IOprint_val(a:bat[:int,:str]) 
    m := inspect.getModule();           #  4 m:bat[:oid,:str] := INSPECTgetAllModules() {G}
    mr := bat.reverse(m);               #  5 mr:bat[:str,:oid] := BKCreverse(m:bat[:oid,:str]) {G}
    m1 := algebra.kunique(mr);          #  6 m1:bat[:str,:oid] := ALGkunique(mr:bat[:str,:oid]) {G}
    z := algebra.project(m1);           #  7 z:bat[:str,:oid] := ALGprojectNIL(m1:bat[:str,:oid]) {G}
    zs := algebra.sortHT(z);            #  8 zs:bat[:str,:oid] := ALGhtsort(z:bat[:str,:oid]) {G}
    io.print(zs);                       #  9 _9:void := IOprint_val(zs:bat[:str,:oid]) 
    stmt := inspect.getDefinition("algebra","select");# 10 stmt:bat[:str,:str] := INSPECTgetDefinition(_11:str, _12:str) {G}
    sig := inspect.getSignature("algebra","select");# 11 sig:bat[:str,:str] := INSPECTgetSignature(_11:str, _12:str) {G}
    n := manual.search("insert");       # 12 n:void := MANUALsearch(_15:str) 
    io.print(n);                        # 13 _16:void := IOprint_val(n:void) 
end main;	# 14  
#-------------------------#
# view	atom		  # name
# int	str		  # type
#-------------------------#
[ 0,	  "void"	  ]
[ 1,	  "bit"		  ]
[ 2,	  "chr"		  ]
[ 3,	  "bte"		  ]
[ 4,	  "sht"		  ]
[ 5,	  "BAT"		  ]
[ 6,	  "int"		  ]
[ 7,	  "oid"		  ]
[ 8,	  "wrd"		  ]
[ 9,	  "ptr"		  ]
[ 10,	  "flt"		  ]
[ 11,	  "dbl"		  ]
[ 12,	  "lng"		  ]
[ 13,	  "str"		  ]
[ 14,	  "lock"	  ]
[ 15,	  "sema"	  ]
[ 16,	  "streams"	  ]
[ 17,	  "bstream"	  ]
[ 18,	  "blob"	  ]
[ 19,	  "sqlblob"	  ]
[ 20,	  "color"	  ]
[ 21,	  "url"		  ]
[ 22,	  "date"	  ]
[ 23,	  "daytime"	  ]
[ 24,	  "timestamp"	  ]
[ 25,	  "timezone"	  ]
[ 26,	  "zrule"	  ]
[ 27,	  "inet"	  ]
[ 28,	  "pcre"	  ]
[ 29,	  "xml"		  ]
[ 30,	  "mapentry"	  ]
#-------------------------#
# t	h		  # name
# oid	str		  # type
#-------------------------#
[ "aggr",	  nil	  ]
[ "alarm",	  nil	  ]
[ "algebra",	  nil	  ]
[ "array",	  nil	  ]
[ "bat",	  nil	  ]
[ "batcalc",	  nil	  ]
[ "batcolor",	  nil	  ]
[ "batmath",	  nil	  ]
[ "batmtime",	  nil	  ]
[ "batstr",	  nil	  ]
[ "bbp",	  nil	  ]
[ "blob",	  nil	  ]
[ "box",	  nil	  ]
[ "bpm",	  nil	  ]
[ "bstream",	  nil	  ]
[ "calc",	  nil	  ]
[ "clients",	  nil	  ]
[ "color",	  nil	  ]
[ "const",	  nil	  ]
[ "constraints",  nil	  ]
[ "crackers",	  nil	  ]
[ "date",	  nil	  ]
[ "daytime",	  nil	  ]
[ "factory",	  nil	  ]
[ "group",	  nil	  ]
[ "inet",	  nil	  ]
[ "inspect",	  nil	  ]
[ "io",		  nil	  ]
[ "language",	  nil	  ]
[ "lock",	  nil	  ]
[ "mal",	  nil	  ]
[ "manual",	  nil	  ]
[ "mapi",	  nil	  ]
[ "mat",	  nil	  ]
[ "mdb",	  nil	  ]
[ "mkey",	  nil	  ]
[ "mmath",	  nil	  ]
[ "mtime",	  nil	  ]
[ "optimizer",	  nil	  ]
[ "pcre",	  nil	  ]
[ "pqueue",	  nil	  ]
[ "profiler",	  nil	  ]
[ "recycle",	  nil	  ]
[ "scheduler",	  nil	  ]
[ "sema",	  nil	  ]
[ "sqlblob",	  nil	  ]
[ "statistics",	  nil	  ]
[ "status",	  nil	  ]
[ "str",	  nil	  ]
[ "streams",	  nil	  ]
[ "tablet",	  nil	  ]
[ "timestamp",	  nil	  ]
[ "timezone",	  nil	  ]
[ "transaction",  nil	  ]
[ "txtsim",	  nil	  ]
[ "unix",	  nil	  ]
[ "url",	  nil	  ]
[ "user",	  nil	  ]
[ "xml",	  nil	  ]
[ "zrule",	  nil	  ]
command bat.insert(b:bat[:any_1,:any_2],h:any_1,t:any_2,force:bit):void address BKCinsert_bun_force;
#Insert one BUN[h,t] in a BAT.

command bat.insert(b:bat[:any_1,:any_2],h:any_1,t:any_2):void address BKCinsert_bun;
#Insert one BUN[h,t] in a BAT.

command bat.insert(b:bat[:any_1,:any_2],src:bat[:any_1,:any_2],force:bit):void address BKCinsert_bat_force;
#Insert all BUNs of the second BAT into the first.

command bat.insert(b:bat[:any_1,:any_2],src:bat[:any_1,:any_2]):void address BKCinsert_bat;
#Insert all BUNs of the second BAT into the first.

command bat.setSet(b:bat[:any_1,:any_2],mode:bit):bat[:any_1,:any_2] address BKCsetSet;
#Sets the 'set' property on this BAT to 'mode'. In 'set' mode, 
#the kernel will silently block insertions that cause a duplicate 
#BUN [head,tail] entries in the BAT.  KNOWN BUG:when 'set' is set 
#to TRUE, this function does not automatically eliminate duplicates. 
#Use b := b.sunique; Returns the BAT itself.

command bat.setKey(b:bat[:any_1,:any_2],mode:bit):bat[:any_1,:any_2] address BKCsetkey;
#Sets the 'key' property of the head column to 'mode'. In 'key' mode, 
#the kernel will silently block insertions that cause a duplicate 
#entries in the head column. KNOWN BUG:when 'key' is set to TRUE, this 
#function does not automatically eliminate duplicates. 
#Use b := b.kunique;

command bpm.insert(pb:bat[:any_1,:any_2],b:bat[:any_1,:any_2]):void address BPMinsert;
#Insert elements into the BAT partitions.

command crackers.insert(b:bat[:oid,:dbl],bp:bat[:oid,:dbl],c:bat[:dbl,:dbl]):void address CRKinsert;
#Keep the insertions BAT separatelly and merge in the future on demand with the Ripple

command crackers.insert(b:bat[:oid,:dbl],bp:bat[:oid,:int],c:bat[:dbl,:int]):void address CRKinsert;
#Keep the insertions BAT separatelly and merge in the future on demand with the Ripple

command crackers.insert(b:bat[:oid,:dbl],bp:bat[:oid,:str],c:bat[:dbl,:str]):void address CRKinsert;
#Keep the insertions BAT separatelly and merge in the future on demand with the Ripple

command crackers.insert(b:bat[:oid,:int],bp:bat[:oid,:str],c:bat[:int,:str]):void address CRKinsert;
#Keep the insertions BAT separatelly and merge in the future on demand with the Ripple

command crackers.insert(b:bat[:oid,:date],bp:bat[:oid,:str],c:bat[:date,:str]):void address CRKinsert;
#Keep the insertions BAT separatelly and merge in the future on demand with the Ripple

command crackers.insert(b:bat[:oid,:date],bp:bat[:oid,:dbl],c:bat[:date,:dbl]):void address CRKinsert;
#Keep the insertions BAT separatelly and merge in the future on demand with the Ripple

command crackers.insert(b:bat[:oid,:date],bp:bat[:oid,:lng],c:bat[:date,:lng]):void address CRKinsert;
#Keep the insertions BAT separatelly and merge in the future on demand with the Ripple

command crackers.insert(b:bat[:oid,:date],bp:bat[:oid,:date],c:bat[:date,:date]):void address CRKinsert;
#Keep the insertions BAT separatelly and merge in the future on demand with the Ripple

command crackers.insert(b:bat[:oid,:date],bp:bat[:oid,:int],c:bat[:date,:int]):void address CRKinsert;
#Keep the insertions BAT separatelly and merge in the future on demand with the Ripple

command crackers.insert(b:bat[:oid,:int],bp:bat[:oid,:date],c:bat[:int,:date]):void address CRKinsert;
#Keep the insertions BAT separatelly and merge in the future on demand with the Ripple

command crackers.insert(b:bat[:oid,:int],bp:bat[:oid,:int],c:bat[:int,:int]):void address CRKinsert;
#Keep the insertions BAT separatelly and merge in the future on demand with the Ripple

command crackers.insertionsBOnNeedGraduallyRipple(b:bat[:any_1,:date],c:bat[:any_1,:date]):void address CRKmergeInsertionsB_OnNeedGraduallyRipple;
#Keep the insertions BAT separatelly and merge only what is needed 
#using the ripple strategy if a relevant query arrives in the future

command crackers.insertionsBOnNeedGradually(b:bat[:any_1,:date],c:bat[:any_1,:date]):void address CRKmergeInsertionsB_OnNeedGradually;
#Keep the insertions BAT separatelly and merge only what is 
#needed if a relevant query arrives in the future

command crackers.insertionsBOnNeed(b:bat[:any_1,:date],c:bat[:any_1,:date]):void address CRKmergeInsertionsB_OnNeed;
#Keep the insertions BAT separatelly and do a complete merge 
#only if a relevant query arrives in the future

command crackers.insertionsForget(b:bat[:any_1,:date],c:bat[:any_1,:date]):void address CRKmergeInsertions_Forget;
#Append c to the cracked BAT of b and completelly forget the cracker index

command crackers.insertionsBForce(b:bat[:any_1,:date],c:bat[:any_1,:date]):void address CRKmergeInsertionsB_Force_date;
#Merge the insertions BAT with the cracker bat and update the cracker index

command crackers.insertionsPartiallyForget(b:bat[:any_1,:date],c:bat[:any_1,:date]):void address CRKmergeInsertions_PartiallyForget_date;
#Append c to the cracked BAT of b and partially forget 
#the cracker index, i.e., forget only what is affected

command crackers.insertionsBOnNeedGraduallyRipple(b:bat[:any_1,:dbl],c:bat[:any_1,:dbl]):void address CRKmergeInsertionsB_OnNeedGraduallyRipple;
#Keep the insertions BAT separatelly and merge only what is needed 
#using the ripple strategy if a relevant query arrives in the future

command crackers.insertionsBOnNeedGradually(b:bat[:any_1,:dbl],c:bat[:any_1,:dbl]):void address CRKmergeInsertionsB_OnNeedGradually;
#Keep the insertions BAT separatelly and merge only what is 
#needed if a relevant query arrives in the future

command crackers.insertionsBOnNeed(b:bat[:any_1,:dbl],c:bat[:any_1,:dbl]):void address CRKmergeInsertionsB_OnNeed;
#Keep the insertions BAT separatelly and do a complete merge 
#only if a relevant query arrives in the future

command crackers.insertionsForget(b:bat[:any_1,:dbl],c:bat[:any_1,:dbl]):void address CRKmergeInsertions_Forget;
#Append c to the cracked BAT of b and completelly forget the cracker index

command crackers.insertionsBForce(b:bat[:any_1,:dbl],c:bat[:any_1,:dbl]):void address CRKmergeInsertionsB_Force_dbl;
#Merge the insertions BAT with the cracker bat and update the cracker index

command crackers.insertionsPartiallyForget(b:bat[:any_1,:dbl],c:bat[:any_1,:dbl]):void address CRKmergeInsertions_PartiallyForget_dbl;
#Append c to the cracked BAT of b and partially forget 
#the cracker index, i.e., forget only what is affected

command crackers.insertionsBOnNeedGraduallyRipple(b:bat[:any_1,:flt],c:bat[:any_1,:flt]):void address CRKmergeInsertionsB_OnNeedGraduallyRipple;
#Keep the insertions BAT separatelly and merge only what is needed 
#using the ripple strategy if a relevant query arrives in the future

command crackers.insertionsBOnNeedGradually(b:bat[:any_1,:flt],c:bat[:any_1,:flt]):void address CRKmergeInsertionsB_OnNeedGradually;
#Keep the insertions BAT separatelly and merge only what is 
#needed if a relevant query arrives in the future

command crackers.insertionsBOnNeed(b:bat[:any_1,:flt],c:bat[:any_1,:flt]):void address CRKmergeInsertionsB_OnNeed;
#Keep the insertions BAT separatelly and do a complete merge 
#only if a relevant query arrives in the future

command crackers.insertionsForget(b:bat[:any_1,:flt],c:bat[:any_1,:flt]):void address CRKmergeInsertions_Forget;
#Append c to the cracked BAT of b and completelly forget the cracker index

command crackers.insertionsBForce(b:bat[:any_1,:flt],c:bat[:any_1,:flt]):void address CRKmergeInsertionsB_Force_flt;
#Merge the insertions BAT with the cracker bat and update the cracker index

command crackers.insertionsPartiallyForget(b:bat[:any_1,:flt],c:bat[:any_1,:flt]):void address CRKmergeInsertions_PartiallyForget_flt;
#Append c to the cracked BAT of b and partially forget 
#the cracker index, i.e., forget only what is affected

command crackers.insertionsBOnNeedGraduallyRipple(b:bat[:any_1,:lng],c:bat[:any_1,:lng]):void address CRKmergeInsertionsB_OnNeedGraduallyRipple;
#Keep the insertions BAT separatelly and merge only what is needed 
#using the ripple strategy if a relevant query arrives in the future

command crackers.insertionsBOnNeedGradually(b:bat[:any_1,:lng],c:bat[:any_1,:lng]):void address CRKmergeInsertionsB_OnNeedGradually;
#Keep the insertions BAT separatelly and merge only what is 
#needed if a relevant query arrives in the future

command crackers.insertionsBOnNeed(b:bat[:any_1,:lng],c:bat[:any_1,:lng]):void address CRKmergeInsertionsB_OnNeed;
#Keep the insertions BAT separatelly and do a complete merge 
#only if a relevant query arrives in the future

command crackers.insertionsForget(b:bat[:any_1,:lng],c:bat[:any_1,:lng]):void address CRKmergeInsertions_Forget;
#Append c to the cracked BAT of b and completelly forget the cracker index

command crackers.insertionsBForce(b:bat[:any_1,:lng],c:bat[:any_1,:lng]):void address CRKmergeInsertionsB_Force_lng;
#Merge the insertions BAT with the cracker bat and update the cracker index

command crackers.insertionsPartiallyForget(b:bat[:any_1,:lng],c:bat[:any_1,:lng]):void address CRKmergeInsertions_PartiallyForget_lng;
#Append c to the cracked BAT of b and partially forget 
#the cracker index, i.e., forget only what is affected

command crackers.insertionsBOnNeedGraduallyRipple(b:bat[:any_1,:int],c:bat[:any_1,:int]):void address CRKmergeInsertionsB_OnNeedGraduallyRipple;
#Keep the insertions BAT separatelly and merge only what is needed 
#using the ripple strategy if a relevant query arrives in the future

command crackers.insertionsBOnNeedGradually(b:bat[:any_1,:int],c:bat[:any_1,:int]):void address CRKmergeInsertionsB_OnNeedGradually;
#Keep the insertions BAT separatelly and merge only what is 
#needed if a relevant query arrives in the future

command crackers.insertionsBOnNeed(b:bat[:any_1,:int],c:bat[:any_1,:int]):void address CRKmergeInsertionsB_OnNeed;
#Keep the insertions BAT separatelly and do a complete merge 
#only if a relevant query arrives in the future

command crackers.insertionsForget(b:bat[:any_1,:int],c:bat[:any_1,:int]):void address CRKmergeInsertions_Forget;
#Append c to the cracked BAT of b and completelly forget the cracker index

command crackers.insertionsBForce(b:bat[:any_1,:int],c:bat[:any_1,:int]):void address CRKmergeInsertionsB_Force_int;
#Merge the insertions BAT with the cracker bat and update the cracker index

command crackers.insertionsPartiallyForget(b:bat[:any_1,:int],c:bat[:any_1,:int]):void address CRKmergeInsertions_PartiallyForget_int;
#Append c to the cracked BAT of b and partially forget 
#the cracker index, i.e., forget only what is affected

command crackers.insertionsBOnNeedGraduallyRipple(b:bat[:any_1,:sht],c:bat[:any_1,:sht]):void address CRKmergeInsertionsB_OnNeedGraduallyRipple;
#Keep the insertions BAT separatelly and merge only what is needed 
#using the ripple strategy if a relevant query arrives in the future

command crackers.insertionsBOnNeedGradually(b:bat[:any_1,:sht],c:bat[:any_1,:sht]):void address CRKmergeInsertionsB_OnNeedGradually;
#Keep the insertions BAT separatelly and merge only what is 
#needed if a relevant query arrives in the future

command crackers.insertionsBOnNeed(b:bat[:any_1,:sht],c:bat[:any_1,:sht]):void address CRKmergeInsertionsB_OnNeed;
#Keep the insertions BAT separatelly and do a complete merge 
#only if a relevant query arrives in the future

command crackers.insertionsForget(b:bat[:any_1,:sht],c:bat[:any_1,:sht]):void address CRKmergeInsertions_Forget;
#Append c to the cracked BAT of b and completelly forget the cracker index

command crackers.insertionsBForce(b:bat[:any_1,:sht],c:bat[:any_1,:sht]):void address CRKmergeInsertionsB_Force_sht;
#Merge the insertions BAT with the cracker bat and update the cracker index

command crackers.insertionsPartiallyForget(b:bat[:any_1,:sht],c:bat[:any_1,:sht]):void address CRKmergeInsertions_PartiallyForget_sht;
#Append c to the cracked BAT of b and partially forget 
#the cracker index, i.e., forget only what is affected

command crackers.insertionsBOnNeedGraduallyRipple(b:bat[:any_1,:chr],c:bat[:any_1,:chr]):void address CRKmergeInsertionsB_OnNeedGraduallyRipple;
#Keep the insertions BAT separatelly and merge only what is needed 
#using the ripple strategy if a relevant query arrives in the future

command crackers.insertionsBOnNeedGradually(b:bat[:any_1,:chr],c:bat[:any_1,:chr]):void address CRKmergeInsertionsB_OnNeedGradually;
#Keep the insertions BAT separatelly and merge only what is 
#needed if a relevant query arrives in the future

command crackers.insertionsBOnNeed(b:bat[:any_1,:chr],c:bat[:any_1,:chr]):void address CRKmergeInsertionsB_OnNeed;
#Keep the insertions BAT separatelly and do a complete merge 
#only if a relevant query arrives in the future

command crackers.insertionsForget(b:bat[:any_1,:chr],c:bat[:any_1,:chr]):void address CRKmergeInsertions_Forget;
#Append c to the cracked BAT of b and completelly forget the cracker index

command crackers.insertionsBForce(b:bat[:any_1,:chr],c:bat[:any_1,:chr]):void address CRKmergeInsertionsB_Force_chr;
#Merge the insertions BAT with the cracker bat and update the cracker index

command crackers.insertionsPartiallyForget(b:bat[:any_1,:chr],c:bat[:any_1,:chr]):void address CRKmergeInsertions_PartiallyForget_chr;
#Append c to the cracked BAT of b and partially forget 
#the cracker index, i.e., forget only what is affected

command crackers.printPendingInsertions(b:bat[:oid,:dbl],bp:bat[:oid,:dbl]):void address CRKprintPendingInsertions;
#Print the pending insertions

command crackers.printPendingInsertions(b:bat[:oid,:dbl],bp:bat[:oid,:int]):void address CRKprintPendingInsertions;
#Print the pending insertions

command crackers.printPendingInsertions(b:bat[:oid,:dbl],bp:bat[:oid,:str]):void address CRKprintPendingInsertions;
#Print the pending insertions

command crackers.printPendingInsertions(b:bat[:oid,:int],bp:bat[:oid,:str]):void address CRKprintPendingInsertions;
#Print the pending insertions

command crackers.printPendingInsertions(b:bat[:oid,:date],bp:bat[:oid,:str]):void address CRKprintPendingInsertions;
#Print the pending insertions

command crackers.printPendingInsertions(b:bat[:oid,:date],bp:bat[:oid,:dbl]):void address CRKprintPendingInsertions;
#Print the pending insertions

command crackers.printPendingInsertions(b:bat[:oid,:date],bp:bat[:oid,:lng]):void address CRKprintPendingInsertions;
#Print the pending insertions

command crackers.printPendingInsertions(b:bat[:oid,:date],bp:bat[:oid,:date]):void address CRKprintPendingInsertions;
#Print the pending insertions

command crackers.printPendingInsertions(b:bat[:oid,:date],bp:bat[:oid,:int]):void address CRKprintPendingInsertions;
#Print the pending insertions

command crackers.printPendingInsertions(b:bat[:oid,:int],bp:bat[:oid,:date]):void address CRKprintPendingInsertions;
#Print the pending insertions

command crackers.printPendingInsertions(b:bat[:oid,:int],bp:bat[:oid,:int]):void address CRKprintPendingInsertions;
#Print the pending insertions

command crackers.printCrackerInsertions(b:bat[:any_1,:date]):void address CRKprintCrackerInsertions;
#Print the pending insertions of the cracker BAT of b

command crackers.printCrackerInsertions(b:bat[:any_1,:dbl]):void address CRKprintCrackerInsertions;
#Print the pending insertions of the cracker BAT of b

command crackers.printCrackerInsertions(b:bat[:any_1,:flt]):void address CRKprintCrackerInsertions;
#Print the pending insertions of the cracker BAT of b

command crackers.printCrackerInsertions(b:bat[:any_1,:lng]):void address CRKprintCrackerInsertions;
#Print the pending insertions of the cracker BAT of b

command crackers.printCrackerInsertions(b:bat[:any_1,:int]):void address CRKprintCrackerInsertions;
#Print the pending insertions of the cracker BAT of b

command crackers.printCrackerInsertions(b:bat[:any_1,:sht]):void address CRKprintCrackerInsertions;
#Print the pending insertions of the cracker BAT of b

command crackers.printCrackerInsertions(b:bat[:any_1,:chr]):void address CRKprintCrackerInsertions;
#Print the pending insertions of the cracker BAT of b

command crackers.sizePendingInsertions(b:bat[:oid,:dbl],bp:bat[:oid,:dbl]):void address CRKsizePendingInsertions;
#Get the size of the pending insertions for this map

command crackers.sizePendingInsertions(b:bat[:oid,:dbl],bp:bat[:oid,:int]):void address CRKsizePendingInsertions;
#Get the size of the pending insertions for this map

command crackers.sizePendingInsertions(b:bat[:oid,:dbl],bp:bat[:oid,:str]):void address CRKsizePendingInsertions;
#Get the size of the pending insertions for this map

command crackers.sizePendingInsertions(b:bat[:oid,:int],bp:bat[:oid,:str]):void address CRKsizePendingInsertions;
#Get the size of the pending insertions for this map

command crackers.sizePendingInsertions(b:bat[:oid,:date],bp:bat[:oid,:str]):void address CRKsizePendingInsertions;
#Get the size of the pending insertions for this map

command crackers.sizePendingInsertions(b:bat[:oid,:date],bp:bat[:oid,:dbl]):void address CRKsizePendingInsertions;
#Get the size of the pending insertions for this map

command crackers.sizePendingInsertions(b:bat[:oid,:date],bp:bat[:oid,:lng]):void address CRKsizePendingInsertions;
#Get the size of the pending insertions for this map

command crackers.sizePendingInsertions(b:bat[:oid,:date],bp:bat[:oid,:date]):void address CRKsizePendingInsertions;
#Get the size of the pending insertions for this map

command crackers.sizePendingInsertions(b:bat[:oid,:date],bp:bat[:oid,:int]):void address CRKsizePendingInsertions;
#Get the size of the pending insertions for this map

command crackers.sizePendingInsertions(b:bat[:oid,:int],bp:bat[:oid,:date]):void address CRKsizePendingInsertions;
#Get the size of the pending insertions for this map

command crackers.sizePendingInsertions(b:bat[:oid,:int],bp:bat[:oid,:int]):void address CRKsizePendingInsertions;
#Get the size of the pending insertions for this map

command crackers.sizeCrackerInsertions(b:bat[:any_1,:date]):void address CRKsizeCrackerInsertions;
#Get the size of the pending insertions of the cracker BAT of b

command crackers.sizeCrackerInsertions(b:bat[:any_1,:dbl]):void address CRKsizeCrackerInsertions;
#Get the size of the pending insertions of the cracker BAT of b

command crackers.sizeCrackerInsertions(b:bat[:any_1,:flt]):void address CRKsizeCrackerInsertions;
#Get the size of the pending insertions of the cracker BAT of b

command crackers.sizeCrackerInsertions(b:bat[:any_1,:lng]):void address CRKsizeCrackerInsertions;
#Get the size of the pending insertions of the cracker BAT of b

command crackers.sizeCrackerInsertions(b:bat[:any_1,:int]):void address CRKsizeCrackerInsertions;
#Get the size of the pending insertions of the cracker BAT of b

command crackers.sizeCrackerInsertions(b:bat[:any_1,:sht]):void address CRKsizeCrackerInsertions;
#Get the size of the pending insertions of the cracker BAT of b

command crackers.sizeCrackerInsertions(b:bat[:any_1,:chr]):void address CRKsizeCrackerInsertions;
#Get the size of the pending insertions of the cracker BAT of b

command io.import(b:bat[:any_1,:any_2],filepath:str):bat[:any_1,:any_2] address IOimport;
#Import a BAT from an ASCII dump. The new tuples are *inserted* into the
#parameter BAT. You have to create it! Its signature must match the dump,
#else parsing errors will occur and FALSE is returned.

command str.insert(s:str,start:int,l:int,s2:str):str address STRinsert;
#Insert a string into another

command transaction.alpha(b:bat[:any_1,:any_2]):bat[:any_1,:any_2] address TRNtrans_alpha;
#List insertions since last commit.

[ nil ]
#-----------------#
# view	fcn	  # name
# int	str	  # type
#-----------------#

# 22:19:31 >  
# 22:19:31 >  Done.
# 22:19:31 >  

