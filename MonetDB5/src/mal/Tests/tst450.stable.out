stdout of test 'tst450` in directory 'src/mal` itself:


# 22:19:31 >  
# 22:19:31 >  Mtimeout -timeout 60 Mserver "--config=/ufs/mk/monet5/src/mal/Tests/All.conf" --debug=10 --set "monet_mod_path=/ufs/mk/monet5/Linux/lib/MonetDB5:/ufs/mk/opensource/MonetDB/Linux/lib/MonetDB" --set "gdk_dbfarm=/ufs/mk/opensource/MonetDB/Linux/var/MonetDB5/dbfarm" --set "sql_logdir=/ufs/mk/opensource/MonetDB/Linux/var/MonetDB5/log" --set mapi_port=30312 --set sql_port=44446 --set xquery_port=54810 --set monet_prompt= --trace "--config=/ufs/mk/monet5/src/mal/Tests/All.conf" --dbname=mTests_src_mal  tst450.mal </dev/null
# 22:19:31 >  

# Monet Database Server V4.99.19
# Copyright (c) 1993-2005, CWI. All rights reserved.
# Compiled for x86_64-redhat-linux-gnu/64bit with 64bit OIDs; dynamically linked.
# config:/ufs/mk/monet5/src/mal/Tests/All.conf
# dbfarm:/ufs/mk/opensource/MonetDB/Linux/var/MonetDB5/dbfarm
# dbname:mTests_src_mal
# Visit http://monetdb.cwi.nl/ for further information.
##testing the inspect module for help information
#
#a:= inspect.getAtomNames();	io.print(a);
#m:= inspect.getModule();	mr:= bat.reverse(m);
#m1:= algebra.kunique(mr);   m1r:= bat.reverse(m1); io.print(m1r);
#stmt:= inspect.getDefinition("algebra","select");
#sig:= inspect.getSignature("algebra","select");
#
#n:= manual.help("algebra","insert"); io.print(n);
#d:= inspect.getDefinition("inspect","dir"); io.print(d);
#
function user.main():void;	# 0  (main:void)
#testing the inspect module for help information 	# 1  (_2:str)
    a := inspect.getAtomNames();	# 2 INSPECTatom_names (a:bat[:int,:str])
    io.print(a);	# 3 IOprint_val (_3:int)<-(a:bat[:int,:str])
    m := inspect.getModule();	# 4 INSPECTgetAllModules (m:bat[:void,:str])
    mr := bat.reverse(m);	# 5 BKCreverse (mr:bat[:str,:void])<-(m:bat[:void,:str])
    m1 := algebra.kunique(mr);	# 6 ALGkunique (m1:bat[:str,:void])<-(mr:bat[:str,:void])
    m1r := bat.reverse(m1);	# 7 BKCreverse (m1r:bat[:void,:str])<-(m1:bat[:str,:void])
    io.print(m1r);	# 8 IOprint_val (_8:int)<-(m1r:bat[:void,:str])
    stmt := inspect.getDefinition("algebra","select");	# 9 INSPECTgetDefinition (stmt:bat[:str,:str])<-(_10:str)(_11:str)
    sig := inspect.getSignature("algebra","select");	# 10 INSPECTgetSignature (sig:bat[:str,:str])<-(_10:str)(_11:str)
    n := manual.search("insert");	# 11 MANUALsearch (n:void)<-(_14:str)
    io.print(n);	# 12 IOprint_val (_15:int)<-(n:void)
    d := inspect.getDefinition("inspect","dir");	# 13 INSPECTgetDefinition (d:bat[:str,:str])<-(_17:str)(_18:str)
    io.print(d);	# 14 IOprint_val (_19:int)<-(d:bat[:str,:str])
end main;	# 15  
#-------------------------#
# view	atom		  # name
# int	str		  # type
#-------------------------#
[ 0,	  "void"	  ]
[ 1,	  "bit"		  ]
[ 2,	  "chr"		  ]
[ 3,	  "sht"		  ]
[ 4,	  "BAT"		  ]
[ 5,	  "int"		  ]
[ 6,	  "oid"		  ]
[ 7,	  "ptr"		  ]
[ 8,	  "flt"		  ]
[ 9,	  "dbl"		  ]
[ 10,	  "lng"		  ]
[ 11,	  "str"		  ]
[ 12,	  "lock"	  ]
[ 13,	  "sema"	  ]
[ 14,	  "streams"	  ]
[ 15,	  "bstream"	  ]
[ 16,	  "blob"	  ]
[ 17,	  "sqlblob"	  ]
[ 18,	  "color"	  ]
[ 19,	  "url"		  ]
[ 20,	  "date"	  ]
[ 21,	  "daytime"	  ]
[ 22,	  "timestamp"	  ]
[ 23,	  "tzone"	  ]
[ 24,	  "zrule"	  ]
[ 25,	  "inet"	  ]
[ 26,	  "pcre"	  ]
[ 27,	  "mapentry"	  ]
[ 28,	  "idxentry"	  ]
#-------------------------#
# t	h		  # name
# oid	str		  # type
#-------------------------#
[ 0@0,	  "user"	  ]
[ 2@0,	  "partitions"	  ]
[ 31@0,	  "transaction"	  ]
[ 39@0,	  "chopper"	  ]
[ 47@0,	  "optimizer"	  ]
[ 96@0,	  "mat"		  ]
[ 102@0,  "statistics"	  ]
[ 129@0,  "profiler"	  ]
[ 151@0,  "mserver"	  ]
[ 191@0,  "language"	  ]
[ 215@0,  "inspect"	  ]
[ 235@0,  "manual"	  ]
[ 244@0,  "pbm"		  ]
[ 274@0,  "box"		  ]
[ 285@0,  "bbp"		  ]
[ 319@0,  "const"	  ]
[ 333@0,  "factory"	  ]
[ 341@0,  "io"		  ]
[ 367@0,  "tablet"	  ]
[ 397@0,  "clients"	  ]
[ 415@0,  "batcolor"	  ]
[ 431@0,  "batstr"	  ]
[ 466@0,  "batcalc"	  ]
[ 1265@0, "batmath"	  ]
[ 1300@0, "mkey"	  ]
[ 1311@0, "pqueue"	  ]
[ 1392@0, "array"	  ]
[ 1403@0, "group"	  ]
[ 1437@0, "status"	  ]
[ 1452@0, "calc"	  ]
[ 1965@0, "algebra"	  ]
[ 2061@0, "aggr"	  ]
[ 2206@0, "pcre"	  ]
[ 2227@0, "bat"		  ]
[ 2325@0, "inet"	  ]
[ 2348@0, "date"	  ]
[ 2359@0, "daytime"	  ]
[ 2369@0, "timestamp"	  ]
[ 2382@0, "tzone"	  ]
[ 2387@0, "zrule"	  ]
[ 2392@0, "mtime"	  ]
[ 2489@0, "url"		  ]
[ 2510@0, "str"		  ]
[ 2549@0, "color"	  ]
[ 2570@0, "blob"	  ]
[ 2586@0, "sqlblob"	  ]
[ 2588@0, "streams"	  ]
[ 2605@0, "bstream"	  ]
[ 2608@0, "mmath"	  ]
[ 2650@0, "alarm"	  ]
[ 2659@0, "sema"	  ]
[ 2663@0, "lock"	  ]
[ 2669@0, "unix"	  ]
[ 2671@0, "mdb"		  ]
[ 2691@0, "crackers"	  ]
command bat.insert(b:bat[:void,:BAT],z:bat[:any_1,:any_2]):void address BKCinsert_void_bun;
#Insert a value in a 'void' bat

command bat.insert(b:bat[:any_1,:BAT],v:any_1,z:bat[:any_3,:any_4]):void address BKCinsert_bun;
command bat.insert(b:bat[:void,:any_1],v:any_1):void address BKCinsert_void_bun;
#Insert a value in a 'void' bat

command bat.insert(b:bat[:oid,:str],h:oid,t:str):void address BKCinsert_bun_oid_str;
command bat.insert(b:bat[:void,:str],h:oid,t:str):void address BKCinsert_bun_oid_str;
command bat.insert(b:bat[:void,:any_2],h:oid,t:any_2):void address BKCinsert_bun_oid_any;
command bat.insert(b:bat[:oid,:any_2],h:oid,t:any_2):void address BKCinsert_bun_oid_any;
command bat.insert(b:bat[:int,:int],h:int,t:int):void address BKCinsert_bun_int_int;
command bat.insert(b:bat[:any_1,:any_2],h:any_1,t:any_2):void address BKCinsert_bun;
#Insert one BUN[h,t] in a BAT.

command bat.insert(b:bat[:any_1,:any_2],src:bat[:any_1,:any_2]):void address BKCinsert_bat;
#Insert all BUNs of the second BAT into the first.

command bat.insert(b:bat[:oid,:any_2],src:bat[:void,:any_2]):void address BKCinsert_bat;
#Insert all BUNs of the second BAT into the first. This case 
#should be removed, because it is a hack for SQL

command bat.insert(b:bat[:void,:any_2],src:bat[:oid,:any_2]):void address BKCinsert_bat;
#Insert all BUNs of the second BAT into the first. This case 
#should be removed, because it is a hack for SQL

command bat.insert(b:bat[:any_1,:oid],src:bat[:any_1,:void]):void address BKCinsert_bat;
#Insert all BUNs of the second BAT into the first. This case 
#should be removed, because it is a hack for SQL

command bat.setSet(b:bat[:any_1,:any_2],mode:bit):bat[:any_1,:any_2] address BKCsetSet;
#Sets the 'set' property on this BAT to 'mode'. In 'set' mode, 
#the kernel will silently block insertions that cause a duplicate 
#BUN [head,tail] entries in the BAT.  KNOWN BUG:when 'set' is set 
#to TRUE, this function does not automatically eliminate duplicates. 
#Use b := b.sunique; Returns the BAT itself.

command bat.setKey(b:bat[:any_1,:any_2],mode:bit):bat[:any_1,:any_2] address BKCsetkey;
#Sets the 'key' property of the head column to 'mode'. In 'key' mode, 
#the kernel will silently block insertions that cause a duplicate 
#entries in the head column. KNOWN BUG:when 'key' is set to TRUE, this 
#function does not automatically eliminate duplicates. 
#Use b := b.kunique;

command io.import(b:bat[:any_1,:any_2],filepath:str):bit address IOimport;
#Import a BAT from an ASCII dump. The new tuples are *inserted* into the
#parameter BAT. You have to create it! Its signature must match the dump,
#else parsing errors will occur and FALSE is returned.

command partitions.insert(b:bat[:void,:any_1],p:bat[:void,:any_1]):bat[:void,:any_1] address BPTinsertBAT;
#Add a BAT as a partition to the end of the list.

command partitions.insert(b:bat[:void,:any_1],t:any_1):bat[:void,:any_1] address BPTinsert_void_bun;
#Add a tuple to the last partition

command partitions.insert(b:bat[:void,:any_1],h:void,t:any_1):bat[:void,:any_1] address BPTinsert;
#Add a tuple to the last partition

command str.insert(s:str,start:int,l:int,s2:str):str address STRinsert;
#Insert a string into another

command transaction.alpha(b:bat[:any_1,:any_2]):bat[:any_1,:any_2] address TRNtrans_alpha;
#List insertions since last commit.

[ nil ]
#-----------------#
# view	fcn	  # name
# int	str	  # type
#-----------------#

# 22:19:31 >  
# 22:19:31 >  Done.
# 22:19:31 >  

