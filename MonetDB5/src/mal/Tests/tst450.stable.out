stdout of test 'tst450` in directory 'src/mal` itself:


# 22:19:31 >  
# 22:19:31 >  Mtimeout -timeout 60 Mserver "--config=/ufs/mk/monet5/src/mal/Tests/All.conf" --debug=10 --set "monet_mod_path=/ufs/mk/monet5/Linux/lib/MonetDB5:/ufs/mk/opensource/MonetDB/Linux/lib/MonetDB" --set "gdk_dbfarm=/ufs/mk/opensource/MonetDB/Linux/var/MonetDB5/dbfarm" --set "sql_logdir=/ufs/mk/opensource/MonetDB/Linux/var/MonetDB5/log" --set mapi_port=30312 --set sql_port=44446 --set xquery_port=54810 --set monet_prompt= --trace "--config=/ufs/mk/monet5/src/mal/Tests/All.conf" --dbname=mTests_src_mal  tst450.mal </dev/null
# 22:19:31 >  

# Monet Database Server V4.99.19
# Copyright (c) 1993-2005, CWI. All rights reserved.
# Compiled for x86_64-redhat-linux-gnu/64bit with 64bit OIDs; dynamically linked.
# config:/ufs/mk/monet5/src/mal/Tests/All.conf
# dbfarm:/ufs/mk/opensource/MonetDB/Linux/var/MonetDB5/dbfarm
# dbname:mTests_src_mal
# Visit http://monetdb.cwi.nl/ for further information.
##testing the inspect module for help information
#
#a:= inspect.getAtomNames();	io.print(a);
#m:= inspect.getModule();	mr:= bat.reverse(m);
#m1:= algebra.kunique(mr);   m1r:= bat.reverse(m1); io.print(m1r);
#stmt:= inspect.getDefinition("algebra","select");
#sig:= inspect.getSignature("algebra","select");
#
#n:= manual.help("algebra","insert"); io.print(n);
#d:= inspect.getDefinition("inspect","dir"); io.print(d);
#
function user.main():void;	# 0  (main:void)
#testing the inspect module for help information 	# 1  (_2:str)
    a := inspect.getAtomNames();	# 2 INSPECTatom_names (a:bat[:int,:str])
    io.print(a);	# 3 IOprint_val (_3:int)<-(a:bat[:int,:str])
    m := inspect.getModule();	# 4 INSPECTgetAllModules (m:bat[:void,:str])
    mr := bat.reverse(m);	# 5 BKCreverse (mr:bat[:str,:void])<-(m:bat[:void,:str])
    m1 := algebra.kunique(mr);	# 6 ALGkunique (m1:bat[:str,:void])<-(mr:bat[:str,:void])
    m1r := bat.reverse(m1);	# 7 BKCreverse (m1r:bat[:void,:str])<-(m1:bat[:str,:void])
    io.print(m1r);	# 8 IOprint_val (_8:int)<-(m1r:bat[:void,:str])
    stmt := inspect.getDefinition("algebra","select");	# 9 INSPECTgetDefinition (stmt:bat[:str,:str])<-(_10:str)(_11:str)
    sig := inspect.getSignature("algebra","select");	# 10 INSPECTgetSignature (sig:bat[:str,:str])<-(_10:str)(_11:str)
    n := manual.search("insert");	# 11 MANUALsearch (n:void)<-(_14:str)
    io.print(n);	# 12 IOprint_val (_15:int)<-(n:void)
    d := inspect.getDefinition("inspect","dir");	# 13 INSPECTgetDefinition (d:bat[:str,:str])<-(_17:str)(_18:str)
    io.print(d);	# 14 IOprint_val (_19:int)<-(d:bat[:str,:str])
end main;	# 15  
#-------------------------#
# view	atom		  # name
# int	str		  # type
#-------------------------#
[ 0,	  "void"	  ]
[ 1,	  "bit"		  ]
[ 2,	  "chr"		  ]
[ 3,	  "sht"		  ]
[ 4,	  "BAT"		  ]
[ 5,	  "int"		  ]
[ 6,	  "oid"		  ]
[ 7,	  "ptr"		  ]
[ 8,	  "flt"		  ]
[ 9,	  "dbl"		  ]
[ 10,	  "lng"		  ]
[ 11,	  "str"		  ]
[ 12,	  "lock"	  ]
[ 13,	  "sema"	  ]
[ 14,	  "stream"	  ]
[ 15,	  "bstream"	  ]
[ 16,	  "blob"	  ]
[ 17,	  "sqlblob"	  ]
[ 18,	  "color"	  ]
[ 19,	  "url"		  ]
[ 20,	  "date"	  ]
[ 21,	  "daytime"	  ]
[ 22,	  "timestamp"	  ]
[ 23,	  "tzone"	  ]
[ 24,	  "rule"	  ]
[ 25,	  "pcre"	  ]
[ 26,	  "mapentry"	  ]
[ 27,	  "idxentry"	  ]
#-------------------------#
# t	h		  # name
# oid	str		  # type
#-------------------------#
[ 0@0,	  "user"	  ]
[ 2@0,	  "partitions"	  ]
[ 31@0,	  "transaction"	  ]
[ 39@0,	  "chop"	  ]
[ 47@0,	  "optimizer"	  ]
[ 94@0,	  "mat"		  ]
[ 100@0,  "statistics"	  ]
[ 127@0,  "profiler"	  ]
[ 149@0,  "mal"		  ]
[ 173@0,  "inspect"	  ]
[ 191@0,  "manual"	  ]
[ 200@0,  "pbm"		  ]
[ 230@0,  "box"		  ]
[ 241@0,  "bbp"		  ]
[ 275@0,  "const"	  ]
[ 289@0,  "factory"	  ]
[ 297@0,  "io"		  ]
[ 323@0,  "tablet"	  ]
[ 353@0,  "clients"	  ]
[ 373@0,  "batcolor"	  ]
[ 389@0,  "batstr"	  ]
[ 424@0,  "batcalc"	  ]
[ 1223@0, "batmath"	  ]
[ 1258@0, "mkey"	  ]
[ 1269@0, "pqueue"	  ]
[ 1350@0, "mapi"	  ]
[ 1361@0, "array"	  ]
[ 1372@0, "group"	  ]
[ 1406@0, "status"	  ]
[ 1421@0, "calc"	  ]
[ 1934@0, "algebra"	  ]
[ 2030@0, "aggr"	  ]
[ 2175@0, "pcre"	  ]
[ 2196@0, "bat"		  ]
[ 2294@0, "date"	  ]
[ 2305@0, "daytime"	  ]
[ 2315@0, "timestamp"	  ]
[ 2328@0, "tzone"	  ]
[ 2333@0, "rule"	  ]
[ 2338@0, "mtime"	  ]
[ 2435@0, "url"		  ]
[ 2456@0, "str"		  ]
[ 2495@0, "color"	  ]
[ 2516@0, "blob"	  ]
[ 2532@0, "sqlblob"	  ]
[ 2534@0, "stream"	  ]
[ 2551@0, "bstream"	  ]
[ 2554@0, "mmath"	  ]
[ 2596@0, "alarm"	  ]
[ 2605@0, "sema"	  ]
[ 2609@0, "lock"	  ]
[ 2615@0, "unix"	  ]
[ 2617@0, "mdb"		  ]
[ 2637@0, "crackers"	  ]
command bat.insert(b:bat[:void,:BAT],z:bat[:any_1,:any_2]):void address BKCinsert_void_bun;\n#Insert a value in a 'void' bat
command bat.insert(b:bat[:any_1,:BAT],v:any_1,z:bat[:any_3,:any_4]):void address BKCinsert_bun;
command bat.insert(b:bat[:void,:any_1],v:any_1):void address BKCinsert_void_bun;\n#Insert a value in a 'void' bat
command bat.insert(b:bat[:oid,:str],h:oid,t:str):void address BKCinsert_bun_oid_str;
command bat.insert(b:bat[:void,:str],h:oid,t:str):void address BKCinsert_bun_oid_str;
command bat.insert(b:bat[:void,:any_2],h:oid,t:any_2):void address BKCinsert_bun_oid_any;
command bat.insert(b:bat[:oid,:any_2],h:oid,t:any_2):void address BKCinsert_bun_oid_any;
command bat.insert(b:bat[:int,:int],h:int,t:int):void address BKCinsert_bun_int_int;
command bat.insert(b:bat[:any_1,:any_2],h:any_1,t:any_2):void address BKCinsert_bun;\n#Insert one BUN[h,t] in a BAT.
command bat.insert(b:bat[:any_1,:any_2],src:bat[:any_1,:any_2]):void address BKCinsert_bat;\n#Insert all BUNs of the second BAT into the first.
command bat.insert(b:bat[:oid,:any_2],src:bat[:void,:any_2]):void address BKCinsert_bat;\n#Insert all BUNs of the second BAT into the first. This case \n#should be removed, because it is a hack for SQL
command bat.insert(b:bat[:void,:any_2],src:bat[:oid,:any_2]):void address BKCinsert_bat;\n#Insert all BUNs of the second BAT into the first. This case \n#should be removed, because it is a hack for SQL
command bat.insert(b:bat[:any_1,:oid],src:bat[:any_1,:void]):void address BKCinsert_bat;\n#Insert all BUNs of the second BAT into the first. This case \n#should be removed, because it is a hack for SQL
command bat.setSet(b:bat[:any_1,:any_2],mode:bit):bat[:any_1,:any_2] address BKCsetSet;\n#Sets the 'set' property on this BAT to 'mode'. In 'set' mode, \n#the kernel will silently block insertions that cause a duplicate \n#BUN [head,tail] entries in the BAT.  KNOWN BUG:when 'set' is set \n#to TRUE, this function does not automatically eliminate duplicates. \n#Use b := b.sunique; Returns the BAT itself.
command bat.setKey(b:bat[:any_1,:any_2],mode:bit):bat[:any_1,:any_2] address BKCsetkey;\n#Sets the 'key' property of the head column to 'mode'. In 'key' mode, \n#the kernel will silently block insertions that cause a duplicate \n#entries in the head column. KNOWN BUG:when 'key' is set to TRUE, this \n#function does not automatically eliminate duplicates. \n#Use b := b.kunique;
command io.import(b:bat[:any_1,:any_2],filepath:str):bit address IOimport;\n#Import a BAT from an ASCII dump. The new tuples are *inserted* into the\n#parameter BAT. You have to create it! Its signature must match the dump,\n#else parsing errors will occur and FALSE is returned.
command partitions.insert(b:bat[:void,:any_1],p:bat[:void,:any_1]):bat[:void,:any_1] address BPTinsertBAT;\n#Add a BAT as a partition to the end of the list.
command partitions.insert(b:bat[:void,:any_1],t:any_1):bat[:void,:any_1] address BPTinsert_void_bun;\n#Add a tuple to the last partition
command partitions.insert(b:bat[:void,:any_1],h:void,t:any_1):bat[:void,:any_1] address BPTinsert;\n#Add a tuple to the last partition
command str.insert(s:str,start:int,l:int,s2:str):str address STRinsert;\n#Insert a string into another
command transaction.alpha(b:bat[:any_1,:any_2]):bat[:any_1,:any_2] address TRNtrans_alpha;\n#List insertions since last commit.
[ nil ]
#-----------------#
# view	fcn	  # name
# int	str	  # type
#-----------------#

# 22:19:31 >  
# 22:19:31 >  Done.
# 22:19:31 >  

