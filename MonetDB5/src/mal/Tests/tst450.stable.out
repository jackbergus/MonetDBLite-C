stdout of test 'tst450` in directory 'src/mal` itself:


# 22:19:31 >  
# 22:19:31 >  Mtimeout -timeout 60 Mserver "--config=/ufs/mk/monet5/src/mal/Tests/All.conf" --debug=10 --set "monet_mod_path=/ufs/mk/monet5/Linux/lib/MonetDB5:/ufs/mk/opensource/MonetDB/Linux/lib/MonetDB" --set "gdk_dbfarm=/ufs/mk/opensource/MonetDB/Linux/var/MonetDB5/dbfarm" --set "sql_logdir=/ufs/mk/opensource/MonetDB/Linux/var/MonetDB5/log" --set mapi_port=30312 --set sql_port=44446 --set xquery_port=54810 --set monet_prompt= --trace "--config=/ufs/mk/monet5/src/mal/Tests/All.conf" --dbname=mTests_src_mal  tst450.mal </dev/null
# 22:19:31 >  

# Monet Database Server V4.99.19
# Copyright (c) 1993-2005, CWI. All rights reserved.
# Compiled for x86_64-redhat-linux-gnu/64bit with 64bit OIDs; dynamically linked.
# config:/ufs/mk/monet5/src/mal/Tests/All.conf
# dbfarm:/ufs/mk/opensource/MonetDB/Linux/var/MonetDB5/dbfarm
# dbname:mTests_src_mal
# Visit http://monetdb.cwi.nl/ for further information.
##testing the inspect module for help information
#
#a:= inspect.getAtomNames();	io.print(a);
#m:= inspect.getModule();	mr:= bat.reverse(m);
#m1:= algebra.kunique(mr);   m1r:= bat.reverse(m1); io.print(m1r);
#stmt:= inspect.getDefinition("algebra","select");
#sig:= inspect.getSignature("algebra","select");
#
#n:= manual.help("algebra","insert"); io.print(n);
#d:= inspect.getDefinition("inspect","dir"); io.print(d);
#
function user.main():void;	# 0  (main:void)
#testing the inspect module for help information 	# 1  (_2:str)
    a := inspect.getAtomNames();	# 2 INSPECTatom_names (a:bat[:int,:str])
    io.print(a);	# 3 IOprint_val (_3:void)<-(a:bat[:int,:str])
    m := inspect.getModule();	# 4 INSPECTgetAllModules (m:bat[:oid,:str])
    mr := bat.reverse(m);	# 5 BKCreverse (mr:bat[:str,:oid])<-(m:bat[:oid,:str])
    m1 := algebra.kunique(mr);	# 6 ALGkunique (m1:bat[:str,:oid])<-(mr:bat[:str,:oid])
    z := algebra.project(m1);	# 7 ALGprojectNIL (z:bat[:str,:oid])<-(m1:bat[:str,:oid])
    zs := algebra.sortHT(z);	# 8 ALGhtsort (zs:bat[:str,:oid])<-(z:bat[:str,:oid])
    io.print(zs);	# 9 IOprint_val (_9:void)<-(zs:bat[:str,:oid])
    stmt := inspect.getDefinition("algebra","select");	# 10 INSPECTgetDefinition (stmt:bat[:str,:str])<-(_11:str)(_12:str)
    sig := inspect.getSignature("algebra","select");	# 11 INSPECTgetSignature (sig:bat[:str,:str])<-(_11:str)(_12:str)
    n := manual.search("insert");	# 12 MANUALsearch (n:void)<-(_15:str)
    io.print(n);	# 13 IOprint_val (_16:void)<-(n:void)
end main;	# 14  
#-------------------------#
# view	atom		  # name
# int	str		  # type
#-------------------------#
[ 0,	  "void"	  ]
[ 1,	  "bit"		  ]
[ 2,	  "chr"		  ]
[ 3,	  "bte"		  ]
[ 4,	  "sht"		  ]
[ 5,	  "BAT"		  ]
[ 6,	  "int"		  ]
[ 7,	  "oid"		  ]
[ 8,	  "wrd"		  ]
[ 9,	  "ptr"		  ]
[ 10,	  "flt"		  ]
[ 11,	  "dbl"		  ]
[ 12,	  "lng"		  ]
[ 13,	  "str"		  ]
[ 14,	  "lock"	  ]
[ 15,	  "sema"	  ]
[ 16,	  "streams"	  ]
[ 17,	  "bstream"	  ]
[ 18,	  "pcre"	  ]
[ 19,	  "blob"	  ]
[ 20,	  "sqlblob"	  ]
[ 21,	  "color"	  ]
[ 22,	  "url"		  ]
[ 23,	  "date"	  ]
[ 24,	  "daytime"	  ]
[ 25,	  "timestamp"	  ]
[ 26,	  "timezone"	  ]
[ 27,	  "zrule"	  ]
[ 28,	  "inet"	  ]
[ 29,	  "mapentry"	  ]
[ 30,	  "idxentry"	  ]
#-------------------------#
# t	h		  # name
# oid	str		  # type
#-------------------------#
[ "aggr",	  nil	  ]
[ "alarm",	  nil	  ]
[ "algebra",	  nil	  ]
[ "array",	  nil	  ]
[ "bat",	  nil	  ]
[ "batcalc",	  nil	  ]
[ "batcolor",	  nil	  ]
[ "batmath",	  nil	  ]
[ "batmtime",	  nil	  ]
[ "bbp",	  nil	  ]
[ "blob",	  nil	  ]
[ "box",	  nil	  ]
[ "bpm",	  nil	  ]
[ "bstream",	  nil	  ]
[ "calc",	  nil	  ]
[ "clients",	  nil	  ]
[ "color",	  nil	  ]
[ "const",	  nil	  ]
[ "constraints",  nil	  ]
[ "crackers",	  nil	  ]
[ "date",	  nil	  ]
[ "daytime",	  nil	  ]
[ "factory",	  nil	  ]
[ "group",	  nil	  ]
[ "inet",	  nil	  ]
[ "inspect",	  nil	  ]
[ "io",		  nil	  ]
[ "language",	  nil	  ]
[ "lock",	  nil	  ]
[ "mal",	  nil	  ]
[ "manual",	  nil	  ]
[ "mat",	  nil	  ]
[ "mdb",	  nil	  ]
[ "mkey",	  nil	  ]
[ "mmath",	  nil	  ]
[ "mserver",	  nil	  ]
[ "mtime",	  nil	  ]
[ "optimizer",	  nil	  ]
[ "pbm",	  nil	  ]
[ "pcre",	  nil	  ]
[ "pqueue",	  nil	  ]
[ "profiler",	  nil	  ]
[ "scheduler",	  nil	  ]
[ "sema",	  nil	  ]
[ "sqlblob",	  nil	  ]
[ "statistics",	  nil	  ]
[ "status",	  nil	  ]
[ "str",	  nil	  ]
[ "streams",	  nil	  ]
[ "tablet",	  nil	  ]
[ "timestamp",	  nil	  ]
[ "timezone",	  nil	  ]
[ "transaction",  nil	  ]
[ "unix",	  nil	  ]
[ "url",	  nil	  ]
[ "user",	  nil	  ]
[ "zrule",	  nil	  ]
command bat.insert(b:bat[:any_1,:any_2],h:any_1,t:any_2,force:bit):void address BKCinsert_bun_force;
#Insert one BUN[h,t] in a BAT.

command bat.insert(b:bat[:any_1,:any_2],h:any_1,t:any_2):void address BKCinsert_bun;
#Insert one BUN[h,t] in a BAT.

command bat.insert(b:bat[:any_1,:any_2],src:bat[:any_1,:any_2],force:bit):void address BKCinsert_bat_force;
#Insert all BUNs of the second BAT into the first.

command bat.insert(b:bat[:any_1,:any_2],src:bat[:any_1,:any_2]):void address BKCinsert_bat;
#Insert all BUNs of the second BAT into the first.

command bat.setSet(b:bat[:any_1,:any_2],mode:bit):bat[:any_1,:any_2] address BKCsetSet;
#Sets the 'set' property on this BAT to 'mode'. In 'set' mode, 
#the kernel will silently block insertions that cause a duplicate 
#BUN [head,tail] entries in the BAT.  KNOWN BUG:when 'set' is set 
#to TRUE, this function does not automatically eliminate duplicates. 
#Use b := b.sunique; Returns the BAT itself.

command bat.setKey(b:bat[:any_1,:any_2],mode:bit):bat[:any_1,:any_2] address BKCsetkey;
#Sets the 'key' property of the head column to 'mode'. In 'key' mode, 
#the kernel will silently block insertions that cause a duplicate 
#entries in the head column. KNOWN BUG:when 'key' is set to TRUE, this 
#function does not automatically eliminate duplicates. 
#Use b := b.kunique;

command bpm.insert(pb:bat[:any_1,:any_2],b:bat[:any_1,:any_2]):void address BPMinsert;
#Insert elements into the BAT partitions

command crackers.insertionsBOnNeedGraduallyRipple(b:bat[:any_1,:date],c:bat[:any_1,:date]):void address CRKmergeInsertionsB_OnNeedGraduallyRipple;
#Keep the insertions bat separatelly and merge only what is needed using the ripple strategy if a relevant query arrives in the future

command crackers.insertionsOnNeedGraduallyRipple(b:bat[:any_1,:date],c:bat[:any_1,:date],deleteNodes:bit):void address CRKmergeInsertions_OnNeedGraduallyRipple;
#Keep the insertions bat separatelly and merge only what is needed using the ripple strategy if a relevant query arrives in the future

command crackers.insertionsBOnNeedGradually(b:bat[:any_1,:date],c:bat[:any_1,:date]):void address CRKmergeInsertionsB_OnNeedGradually;
#Keep the insertions bat separatelly and merge only what is needed if a relevant query arrives in the future

command crackers.insertionsOnNeedGradually(b:bat[:any_1,:date],c:bat[:any_1,:date],deleteNodes:bit):void address CRKmergeInsertions_OnNeedGradually;
#Keep the insertions bat separatelly and merge only what is needed if a relevant query arrives in the future

command crackers.insertionsBOnNeed(b:bat[:any_1,:date],c:bat[:any_1,:date]):void address CRKmergeInsertionsB_OnNeed;
#Keep the insertions bat separatelly and do a complete merge only if a relevant query arrives in the future

command crackers.insertionsOnNeed(b:bat[:any_1,:date],c:bat[:any_1,:date],deleteNodes:bit):void address CRKmergeInsertions_OnNeed;
#Keep the insertions bat separatelly and do a complete merge only if a relevant query arrives in the future

command crackers.insertionsBForce(b:bat[:any_1,:date],c:bat[:any_1,:date]):void address CRKmergeInsertionsB_Force_date;
#Merge the insertions bat with the cracker bat and update the cracker index

command crackers.insertionsForce(b:bat[:any_1,:date],c:bat[:any_1,:date],deleteNodes:bit):void address CRKmergeInsertions_Force_date;
#Merge the insertions bat with the cracker bat and update the cracker index

command crackers.insertionsPartiallyForget(b:bat[:any_1,:date],c:bat[:any_1,:date]):void address CRKmergeInsertions_PartiallyForget_date;
#Append c to the cracked bat of b and partially forget the cracker index, i.e., forget only what is affected

command crackers.insertionsForget(b:bat[:any_1,:date],c:bat[:any_1,:date]):void address CRKmergeInsertions_Forget;
#Append c to the cracked bat of b and completelly forget the cracker index

command crackers.insertionsBOnNeedGraduallyRipple(b:bat[:any_1,:dbl],c:bat[:any_1,:dbl]):void address CRKmergeInsertionsB_OnNeedGraduallyRipple;
#Keep the insertions bat separatelly and merge only what is needed using the ripple strategy if a relevant query arrives in the future

command crackers.insertionsOnNeedGraduallyRipple(b:bat[:any_1,:dbl],c:bat[:any_1,:dbl],deleteNodes:bit):void address CRKmergeInsertions_OnNeedGraduallyRipple;
#Keep the insertions bat separatelly and merge only what is needed using the ripple strategy if a relevant query arrives in the future

command crackers.insertionsBOnNeedGradually(b:bat[:any_1,:dbl],c:bat[:any_1,:dbl]):void address CRKmergeInsertionsB_OnNeedGradually;
#Keep the insertions bat separatelly and merge only what is needed if a relevant query arrives in the future

command crackers.insertionsOnNeedGradually(b:bat[:any_1,:dbl],c:bat[:any_1,:dbl],deleteNodes:bit):void address CRKmergeInsertions_OnNeedGradually;
#Keep the insertions bat separatelly and merge only what is needed if a relevant query arrives in the future

command crackers.insertionsBOnNeed(b:bat[:any_1,:dbl],c:bat[:any_1,:dbl]):void address CRKmergeInsertionsB_OnNeed;
#Keep the insertions bat separatelly and do a complete merge only if a relevant query arrives in the future

command crackers.insertionsOnNeed(b:bat[:any_1,:dbl],c:bat[:any_1,:dbl],deleteNodes:bit):void address CRKmergeInsertions_OnNeed;
#Keep the insertions bat separatelly and do a complete merge only if a relevant query arrives in the future

command crackers.insertionsBForce(b:bat[:any_1,:dbl],c:bat[:any_1,:dbl]):void address CRKmergeInsertionsB_Force_dbl;
#Merge the insertions bat with the cracker bat and update the cracker index

command crackers.insertionsForce(b:bat[:any_1,:dbl],c:bat[:any_1,:dbl],deleteNodes:bit):void address CRKmergeInsertions_Force_dbl;
#Merge the insertions bat with the cracker bat and update the cracker index

command crackers.insertionsPartiallyForget(b:bat[:any_1,:dbl],c:bat[:any_1,:dbl]):void address CRKmergeInsertions_PartiallyForget_dbl;
#Append c to the cracked bat of b and partially forget the cracker index, i.e., forget only what is affected

command crackers.insertionsForget(b:bat[:any_1,:dbl],c:bat[:any_1,:dbl]):void address CRKmergeInsertions_Forget;
#Append c to the cracked bat of b and completelly forget the cracker index

command crackers.insertionsBOnNeedGraduallyRipple(b:bat[:any_1,:flt],c:bat[:any_1,:flt]):void address CRKmergeInsertionsB_OnNeedGraduallyRipple;
#Keep the insertions bat separatelly and merge only what is needed using the ripple strategy if a relevant query arrives in the future

command crackers.insertionsOnNeedGraduallyRipple(b:bat[:any_1,:flt],c:bat[:any_1,:flt],deleteNodes:bit):void address CRKmergeInsertions_OnNeedGraduallyRipple;
#Keep the insertions bat separatelly and merge only what is needed using the ripple strategy if a relevant query arrives in the future

command crackers.insertionsBOnNeedGradually(b:bat[:any_1,:flt],c:bat[:any_1,:flt]):void address CRKmergeInsertionsB_OnNeedGradually;
#Keep the insertions bat separatelly and merge only what is needed if a relevant query arrives in the future

command crackers.insertionsOnNeedGradually(b:bat[:any_1,:flt],c:bat[:any_1,:flt],deleteNodes:bit):void address CRKmergeInsertions_OnNeedGradually;
#Keep the insertions bat separatelly and merge only what is needed if a relevant query arrives in the future

command crackers.insertionsBOnNeed(b:bat[:any_1,:flt],c:bat[:any_1,:flt]):void address CRKmergeInsertionsB_OnNeed;
#Keep the insertions bat separatelly and do a complete merge only if a relevant query arrives in the future

command crackers.insertionsOnNeed(b:bat[:any_1,:flt],c:bat[:any_1,:flt],deleteNodes:bit):void address CRKmergeInsertions_OnNeed;
#Keep the insertions bat separatelly and do a complete merge only if a relevant query arrives in the future

command crackers.insertionsBForce(b:bat[:any_1,:flt],c:bat[:any_1,:flt]):void address CRKmergeInsertionsB_Force_flt;
#Merge the insertions bat with the cracker bat and update the cracker index

command crackers.insertionsForce(b:bat[:any_1,:flt],c:bat[:any_1,:flt],deleteNodes:bit):void address CRKmergeInsertions_Force_flt;
#Merge the insertions bat with the cracker bat and update the cracker index

command crackers.insertionsPartiallyForget(b:bat[:any_1,:flt],c:bat[:any_1,:flt]):void address CRKmergeInsertions_PartiallyForget_flt;
#Append c to the cracked bat of b and partially forget the cracker index, i.e., forget only what is affected

command crackers.insertionsForget(b:bat[:any_1,:flt],c:bat[:any_1,:flt]):void address CRKmergeInsertions_Forget;
#Append c to the cracked bat of b and completelly forget the cracker index

command crackers.insertionsBOnNeedGraduallyRipple(b:bat[:any_1,:lng],c:bat[:any_1,:lng]):void address CRKmergeInsertionsB_OnNeedGraduallyRipple;
#Keep the insertions bat separatelly and merge only what is needed using the ripple strategy if a relevant query arrives in the future

command crackers.insertionsOnNeedGraduallyRipple(b:bat[:any_1,:lng],c:bat[:any_1,:lng],deleteNodes:bit):void address CRKmergeInsertions_OnNeedGraduallyRipple;
#Keep the insertions bat separatelly and merge only what is needed using the ripple strategy if a relevant query arrives in the future

command crackers.insertionsBOnNeedGradually(b:bat[:any_1,:lng],c:bat[:any_1,:lng]):void address CRKmergeInsertionsB_OnNeedGradually;
#Keep the insertions bat separatelly and merge only what is needed if a relevant query arrives in the future

command crackers.insertionsOnNeedGradually(b:bat[:any_1,:lng],c:bat[:any_1,:lng],deleteNodes:bit):void address CRKmergeInsertions_OnNeedGradually;
#Keep the insertions bat separatelly and merge only what is needed if a relevant query arrives in the future

command crackers.insertionsBOnNeed(b:bat[:any_1,:lng],c:bat[:any_1,:lng]):void address CRKmergeInsertionsB_OnNeed;
#Keep the insertions bat separatelly and do a complete merge only if a relevant query arrives in the future

command crackers.insertionsOnNeed(b:bat[:any_1,:lng],c:bat[:any_1,:lng],deleteNodes:bit):void address CRKmergeInsertions_OnNeed;
#Keep the insertions bat separatelly and do a complete merge only if a relevant query arrives in the future

command crackers.insertionsBForce(b:bat[:any_1,:lng],c:bat[:any_1,:lng]):void address CRKmergeInsertionsB_Force_lng;
#Merge the insertions bat with the cracker bat and update the cracker index

command crackers.insertionsForce(b:bat[:any_1,:lng],c:bat[:any_1,:lng],deleteNodes:bit):void address CRKmergeInsertions_Force_lng;
#Merge the insertions bat with the cracker bat and update the cracker index

command crackers.insertionsPartiallyForget(b:bat[:any_1,:lng],c:bat[:any_1,:lng]):void address CRKmergeInsertions_PartiallyForget_lng;
#Append c to the cracked bat of b and partially forget the cracker index, i.e., forget only what is affected

command crackers.insertionsForget(b:bat[:any_1,:lng],c:bat[:any_1,:lng]):void address CRKmergeInsertions_Forget;
#Append c to the cracked bat of b and completelly forget the cracker index

command crackers.insertionsBOnNeedGraduallyRipple(b:bat[:any_1,:int],c:bat[:any_1,:int]):void address CRKmergeInsertionsB_OnNeedGraduallyRipple;
#Keep the insertions bat separatelly and merge only what is needed using the ripple strategy if a relevant query arrives in the future

command crackers.insertionsOnNeedGraduallyRipple(b:bat[:any_1,:int],c:bat[:any_1,:int],deleteNodes:bit):void address CRKmergeInsertions_OnNeedGraduallyRipple;
#Keep the insertions bat separatelly and merge only what is needed using the ripple strategy if a relevant query arrives in the future

command crackers.insertionsBOnNeedGradually(b:bat[:any_1,:int],c:bat[:any_1,:int]):void address CRKmergeInsertionsB_OnNeedGradually;
#Keep the insertions bat separatelly and merge only what is needed if a relevant query arrives in the future

command crackers.insertionsOnNeedGradually(b:bat[:any_1,:int],c:bat[:any_1,:int],deleteNodes:bit):void address CRKmergeInsertions_OnNeedGradually;
#Keep the insertions bat separatelly and merge only what is needed if a relevant query arrives in the future

command crackers.insertionsBOnNeed(b:bat[:any_1,:int],c:bat[:any_1,:int]):void address CRKmergeInsertionsB_OnNeed;
#Keep the insertions bat separatelly and do a complete merge only if a relevant query arrives in the future

command crackers.insertionsOnNeed(b:bat[:any_1,:int],c:bat[:any_1,:int],deleteNodes:bit):void address CRKmergeInsertions_OnNeed;
#Keep the insertions bat separatelly and do a complete merge only if a relevant query arrives in the future

command crackers.insertionsBForce(b:bat[:any_1,:int],c:bat[:any_1,:int]):void address CRKmergeInsertionsB_Force_int;
#Merge the insertions bat with the cracker bat and update the cracker index

command crackers.insertionsForce(b:bat[:any_1,:int],c:bat[:any_1,:int],deleteNodes:bit):void address CRKmergeInsertions_Force_int;
#Merge the insertions bat with the cracker bat and update the cracker index

command crackers.insertionsPartiallyForget(b:bat[:any_1,:int],c:bat[:any_1,:int]):void address CRKmergeInsertions_PartiallyForget_int;
#Append c to the cracked bat of b and partially forget the cracker index, i.e., forget only what is affected

command crackers.insertionsForget(b:bat[:any_1,:int],c:bat[:any_1,:int]):void address CRKmergeInsertions_Forget;
#Append c to the cracked bat of b and completelly forget the cracker index

command crackers.insertionsBOnNeedGraduallyRipple(b:bat[:any_1,:sht],c:bat[:any_1,:sht]):void address CRKmergeInsertionsB_OnNeedGraduallyRipple;
#Keep the insertions bat separatelly and merge only what is needed using the ripple strategy if a relevant query arrives in the future

command crackers.insertionsOnNeedGraduallyRipple(b:bat[:any_1,:sht],c:bat[:any_1,:sht],deleteNodes:bit):void address CRKmergeInsertions_OnNeedGraduallyRipple;
#Keep the insertions bat separatelly and merge only what is needed using the ripple strategy if a relevant query arrives in the future

command crackers.insertionsBOnNeedGradually(b:bat[:any_1,:sht],c:bat[:any_1,:sht]):void address CRKmergeInsertionsB_OnNeedGradually;
#Keep the insertions bat separatelly and merge only what is needed if a relevant query arrives in the future

command crackers.insertionsOnNeedGradually(b:bat[:any_1,:sht],c:bat[:any_1,:sht],deleteNodes:bit):void address CRKmergeInsertions_OnNeedGradually;
#Keep the insertions bat separatelly and merge only what is needed if a relevant query arrives in the future

command crackers.insertionsBOnNeed(b:bat[:any_1,:sht],c:bat[:any_1,:sht]):void address CRKmergeInsertionsB_OnNeed;
#Keep the insertions bat separatelly and do a complete merge only if a relevant query arrives in the future

command crackers.insertionsOnNeed(b:bat[:any_1,:sht],c:bat[:any_1,:sht],deleteNodes:bit):void address CRKmergeInsertions_OnNeed;
#Keep the insertions bat separatelly and do a complete merge only if a relevant query arrives in the future

command crackers.insertionsBForce(b:bat[:any_1,:sht],c:bat[:any_1,:sht]):void address CRKmergeInsertionsB_Force_sht;
#Merge the insertions bat with the cracker bat and update the cracker index

command crackers.insertionsForce(b:bat[:any_1,:sht],c:bat[:any_1,:sht],deleteNodes:bit):void address CRKmergeInsertions_Force_sht;
#Merge the insertions bat with the cracker bat and update the cracker index

command crackers.insertionsPartiallyForget(b:bat[:any_1,:sht],c:bat[:any_1,:sht]):void address CRKmergeInsertions_PartiallyForget_sht;
#Append c to the cracked bat of b and partially forget the cracker index, i.e., forget only what is affected

command crackers.insertionsForget(b:bat[:any_1,:sht],c:bat[:any_1,:sht]):void address CRKmergeInsertions_Forget;
#Append c to the cracked bat of b and completelly forget the cracker index

command crackers.insertionsBOnNeedGraduallyRipple(b:bat[:any_1,:chr],c:bat[:any_1,:chr]):void address CRKmergeInsertionsB_OnNeedGraduallyRipple;
#Keep the insertions bat separatelly and merge only what is needed using the ripple strategy if a relevant query arrives in the future

command crackers.insertionsOnNeedGraduallyRipple(b:bat[:any_1,:chr],c:bat[:any_1,:chr],deleteNodes:bit):void address CRKmergeInsertions_OnNeedGraduallyRipple;
#Keep the insertions bat separatelly and merge only what is needed using the ripple strategy if a relevant query arrives in the future

command crackers.insertionsBOnNeedGradually(b:bat[:any_1,:chr],c:bat[:any_1,:chr]):void address CRKmergeInsertionsB_OnNeedGradually;
#Keep the insertions bat separatelly and merge only what is needed if a relevant query arrives in the future

command crackers.insertionsOnNeedGradually(b:bat[:any_1,:chr],c:bat[:any_1,:chr],deleteNodes:bit):void address CRKmergeInsertions_OnNeedGradually;
#Keep the insertions bat separatelly and merge only what is needed if a relevant query arrives in the future

command crackers.insertionsBOnNeed(b:bat[:any_1,:chr],c:bat[:any_1,:chr]):void address CRKmergeInsertionsB_OnNeed;
#Keep the insertions bat separatelly and do a complete merge only if a relevant query arrives in the future

command crackers.insertionsOnNeed(b:bat[:any_1,:chr],c:bat[:any_1,:chr],deleteNodes:bit):void address CRKmergeInsertions_OnNeed;
#Keep the insertions bat separatelly and do a complete merge only if a relevant query arrives in the future

command crackers.insertionsBForce(b:bat[:any_1,:chr],c:bat[:any_1,:chr]):void address CRKmergeInsertionsB_Force_chr;
#Merge the insertions bat with the cracker bat and update the cracker index

command crackers.insertionsForce(b:bat[:any_1,:chr],c:bat[:any_1,:chr],deleteNodes:bit):void address CRKmergeInsertions_Force_chr;
#Merge the insertions bat with the cracker bat and update the cracker index

command crackers.insertionsPartiallyForget(b:bat[:any_1,:chr],c:bat[:any_1,:chr]):void address CRKmergeInsertions_PartiallyForget_chr;
#Append c to the cracked bat of b and partially forget the cracker index, i.e., forget only what is affected

command crackers.insertionsForget(b:bat[:any_1,:chr],c:bat[:any_1,:chr]):void address CRKmergeInsertions_Forget;
#Append c to the cracked bat of b and completelly forget the cracker index

command crackers.printCrackerInsertions(b:bat[:any_1,:date]):void address CRKprintCrackerInsertions;
#Print the pending insertions of the cracker BAT of b

command crackers.printCrackerInsertions(b:bat[:any_1,:dbl]):void address CRKprintCrackerInsertions;
#Print the pending insertions of the cracker BAT of b

command crackers.printCrackerInsertions(b:bat[:any_1,:flt]):void address CRKprintCrackerInsertions;
#Print the pending insertions of the cracker BAT of b

command crackers.printCrackerInsertions(b:bat[:any_1,:lng]):void address CRKprintCrackerInsertions;
#Print the pending insertions of the cracker BAT of b

command crackers.printCrackerInsertions(b:bat[:any_1,:int]):void address CRKprintCrackerInsertions;
#Print the pending insertions of the cracker BAT of b

command crackers.printCrackerInsertions(b:bat[:any_1,:sht]):void address CRKprintCrackerInsertions;
#Print the pending insertions of the cracker BAT of b

command crackers.printCrackerInsertions(b:bat[:any_1,:chr]):void address CRKprintCrackerInsertions;
#Print the pending insertions of the cracker BAT of b

command crackers.sizeCrackerInsertions(b:bat[:any_1,:date]):void address CRKsizeCrackerInsertions;
#Get the size of the pending insertions of the cracker BAT of b

command crackers.sizeCrackerInsertions(b:bat[:any_1,:dbl]):void address CRKsizeCrackerInsertions;
#Get the size of the pending insertions of the cracker BAT of b

command crackers.sizeCrackerInsertions(b:bat[:any_1,:flt]):void address CRKsizeCrackerInsertions;
#Get the size of the pending insertions of the cracker BAT of b

command crackers.sizeCrackerInsertions(b:bat[:any_1,:lng]):void address CRKsizeCrackerInsertions;
#Get the size of the pending insertions of the cracker BAT of b

command crackers.sizeCrackerInsertions(b:bat[:any_1,:int]):void address CRKsizeCrackerInsertions;
#Get the size of the pending insertions of the cracker BAT of b

command crackers.sizeCrackerInsertions(b:bat[:any_1,:sht]):void address CRKsizeCrackerInsertions;
#Get the size of the pending insertions of the cracker BAT of b

command crackers.sizeCrackerInsertions(b:bat[:any_1,:chr]):void address CRKsizeCrackerInsertions;
#Get the size of the pending insertions of the cracker BAT of b

command io.import(b:bat[:any_1,:any_2],filepath:str):bat[:any_1,:any_2] address IOimport;
#Import a BAT from an ASCII dump. The new tuples are *inserted* into the
#parameter BAT. You have to create it! Its signature must match the dump,
#else parsing errors will occur and FALSE is returned.

command str.insert(s:str,start:int,l:int,s2:str):str address STRinsert;
#Insert a string into another

command transaction.alpha(b:bat[:any_1,:any_2]):bat[:any_1,:any_2] address TRNtrans_alpha;
#List insertions since last commit.

[ nil ]
#-----------------#
# view	fcn	  # name
# int	str	  # type
#-----------------#

# 22:19:31 >  
# 22:19:31 >  Done.
# 22:19:31 >  

