# the OOM join experiment
# M= number elements in left, N= number elements in right
# S= sample exchange size

N:= 1000000000:int;
M:= 1000000000:int;
S:= 1000:int;

t0:= alarm.usec();
lbase:= bat.new(:oid,:int);
barrier (go,i):= language.newRange(0:int);
	k:= mmath.rand();
	o:= calc.oid(i);
	bat.insert(lbase,o,k);
	redo (go,i):= language.nextElement(1:int,M);
exit (go,i);
rbase:= bat.new(:oid,:int);
barrier (go,i):= language.newRange(0:int);
	k:= mmath.rand();
	o:= calc.oid(i);
	bat.insert(rbase,o,k);
	redo (go,i):= language.nextElement(1:int,N);
exit (go,i);
barrier (go,i):= language.newRange(0:int);
	k:= mmath.rand();
	k:= k % N;
	z:= algebra.fetch(rbase,k);
	bat.append(lbase,z);
	redo (go,i):= language.nextElement(1:int,S);
exit (go,i);
barrier (go,i):= language.newRange(0:int);
	k:= mmath.rand();
	k:= k % M;
	z:= algebra.fetch(lbase,k);
	bat.append(rbase,z);
	redo (go,i):= language.nextElement(1:int,S);
exit (go,i);
t1:= alarm.usec();
d0:= t1-t0;
io.printf("#loop %d\n",d0);
t0:= alarm.usec();

cnt:= aggr.count(lbase);
io.printf("#left:  %d\n",cnt);
cnt:= aggr.count(rbase);
io.printf("#right: %d\n",cnt);

#mdb.setTrace(true);

#get fresh copies for both experiments
t0:= alarm.usec();
lb2:= algebra.copy(lbase);
rb2:= algebra.copy(rbase);
t1:= alarm.usec();
d0:= t1-t0;
io.printf("#copy %d\n",d0);
# the heart of the matter
t0:= alarm.usec();
w := algebra.blkjoin(lb2,rr2);
t1:= alarm.usec();
d0:= t1-t0;
d1:= d0;
io.printf("#blkjoin %d\n",d0);
cnt:= aggr.count(w);
io.print(cnt);

#get fresh copies for both experiments
t0:= alarm.usec();
lb2:= algebra.copy(lbase);
rb2:= algebra.copy(rbase);
t1:= alarm.usec();
d0:= t1-t0;
io.printf("#copy %d\n",d0);
rr2:= bat.reverse(rb2);
# the heart of the matter
t0:= alarm.usec();
w := algebra.blkjoinStM(lb2,rr2);
t1:= alarm.usec();
d0:= t1-t0;
d1:= d0;
io.printf("#blkjoinStM %d\n",d0);
cnt:= aggr.count(w);
io.print(cnt);
