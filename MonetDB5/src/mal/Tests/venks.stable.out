stdout of test 'venks` in directory 'src/mal` itself:


# 20:15:09 >  
# 20:15:09 >  Mtimeout -timeout 60  mserver5 "--config=/ufs/mk/monet5/Linux/etc/monetdb5.conf" --debug=10 --set "monet_mod_path=/ufs/mk/monet5//Linux/lib/MonetDB5:/ufs/mk/monet5//Linux/lib/MonetDB5/lib:/ufs/mk/monet5//Linux/lib/MonetDB5/bin" --set "gdk_dbfarm=/ufs/mk/monet5//dbfarm" --set "sql_logdir=/ufs/mk/monet5//dblogs/logs/sql" --set "xquery_logdir=/ufs/mk/monet5//Linux/var/MonetDB5/xquery_logs" --set mapi_open=true --set mapi_port=36566 --set xrpc_port=41437 --set monet_prompt= --trace --dbname=mTests_src_mal  venks.mal
# 20:15:09 >  

# MonetDB Server v5.1.0
# Copyright (c) 1993-2007 CWI, all rights reserved
# Compiled for x86_64-redhat-linux-gnu/64bit with 64bit OIDs dynamically linked
# dbname:mTests_src_mal
# Visit http://monetdb.cwi.nl/ for further information
## test an expensive kintersect
## it illustrates weakness of the kintersect routine.
#
#t0:= alarm.usec();
#large:= bat.new(:oid,:sht);
#barrier (go,i):= language.newRange(0:lng);
#	k:= mmath.rand();
#	l:= calc.sht(k);
#	bat.append(large,l);
#	redo (go,i):= language.nextElement(1:lng,1000000:lng);
#exit (go,i);
#
#small:= bat.new(:oid,:sht);
##m:= aggr.min(b);
#m:= mmath.rand();
#l:= calc.sht(m);
#bat.insert(small,1@0,l);
##m:= aggr.max(b);
#m:= mmath.rand();
#l:= calc.sht(m);
#bat.insert(small,4@0,l);
##disturb order
#m:= mmath.rand();
#l:= calc.sht(m);
#bat.insert(small,3@0,l);
#
#largeR:= bat.reverse(large);
#smallR:= bat.reverse(small);
#
#t0:= alarm.usec();
#sj:= algebra.kintersect(largeR,smallR);
#t1:= alarm.usec();
#d0:= t1-t0;
#io.printf("#kintersect(largeRev,smallRev) %d\n",d0);
#v:= aggr.count(sj);
#io.printf("#count %d\n",v);
##io.print(sj);
#
#t0:= alarm.usec();
#j:= algebra.join(large,smallR);
#t1:= alarm.usec();
#d0:= t1-t0;
#io.printf("#join(large,smallRev) %d\n",d0);
#v:= aggr.count(j);
#io.printf("#count %d\n",v);
##io.print(j);
#
#t0:= alarm.usec();
#sj2:= algebra.kintersect(smallR,largeR);
#t1:= alarm.usec();
#d0:= t1-t0;
#io.printf("#kintersect(smallRev,largeRev) %d\n",d0);
#v:= aggr.count(sj2);
#io.printf("#count %d\n",v);
##io.print(sj2);
#
#t0:= alarm.usec();
#j:= algebra.join(small,smallR);
#t1:= alarm.usec();
#d0:= t1-t0;
#io.printf("#join(small,largeRev) %d\n",d0);
#v:= aggr.count(j);
#io.printf("#count %d\n",v);
##io.print(j);
#
function user.main():void;              #  0 main:void := user.main() {G}
# test an expensive kintersect 
# it illustrates weakness of the kintersect routine. 
    t0 := alarm.usec();                 #  3 t0:lng := ALARMusec() 
    l := 0:sht;                         #  4 l:sht := _5:sht 
    large := bat.new(:oid,:sht);        #  5 large:bat[:oid,:sht] := CMDBATnew(_7:oid, _8:sht) {G}
barrier (go,i) := language.newRange(0:lng);#  6 (go:bit, i:lng) := RNGnewRange_lng(_11:lng) {J11}
    k := mmath.rand();                  #  7 k:int := MATHrandint() 
    l := calc.sht(k);                   #  8 l:sht := CALCint2sht(k:int) 
    bat.append(large,l);                #  9 _13:bat[:sht,:any] := BKCappend_val_wrap(large:bat[:oid,:sht], l:sht) {G}
    redo (go,i) := language.nextElement(1:lng,1000000:lng);# 10 (go:bit, i:lng) := RNGnextElement_lng(_14:lng, _15:lng) {J7}
exit (go,i);                            # 11 (go:bit, i:lng) 
    small := bat.new(:oid,:sht);        # 12 small:bat[:oid,:sht] := CMDBATnew(_7:oid, _17:sht) {G}
#m:= aggr.min(b); 
    m := mmath.rand();                  # 14 m:int := MATHrandint() 
    l := calc.sht(m);                   # 15 l:sht := CALCint2sht(m:int) 
    bat.insert(small,1@0,l);            # 16 _20:bat[:oid,:sht] := BKCinsert_bun(small:bat[:oid,:sht], _21:oid, l:sht) {G}
#m:= aggr.max(b); 
    m := mmath.rand();                  # 18 m:int := MATHrandint() 
    l := calc.sht(m);                   # 19 l:sht := CALCint2sht(m:int) 
    bat.insert(small,4@0,l);            # 20 _23:bat[:oid,:sht] := BKCinsert_bun(small:bat[:oid,:sht], _24:oid, l:sht) {G}
#disturb order 
    m := mmath.rand();                  # 22 m:int := MATHrandint() 
    l := calc.sht(m);                   # 23 l:sht := CALCint2sht(m:int) 
    bat.insert(small,3@0,l);            # 24 _26:bat[:oid,:sht] := BKCinsert_bun(small:bat[:oid,:sht], _27:oid, l:sht) {G}
    largeR := bat.reverse(large);       # 25 largeR:bat[:sht,:oid] := BKCreverse(large:bat[:oid,:sht]) {G}
    smallR := bat.reverse(small);       # 26 smallR:bat[:sht,:oid] := BKCreverse(small:bat[:oid,:sht]) {G}
    t0 := alarm.usec();                 # 27 t0:lng := ALARMusec() 
    sj := algebra.kintersect(largeR,smallR);# 28 sj:bat[:sht,:oid] := ALGsemijoin(largeR:bat[:sht,:oid], smallR:bat[:sht,:oid]) {G}
    t1 := alarm.usec();                 # 29 t1:lng := ALARMusec() 
    d0 := calc.-(t1,t0);                # 30 d0:lng := CALCbinarySUBlnglng(t1:lng, t0:lng) 
    io.printf("#kintersect(largeRev,smallRev) %d\n",d0);# 31 _33:void := IOprint_formatted_lng(_34:str, d0:lng) 
    v := aggr.count(sj);                # 32 v:int := ALGcount_bat(sj:bat[:sht,:oid]) 
    io.printf("#count %d\n",v);         # 33 _36:void := IOprint_formatted_int(_37:str, v:int) 
#io.print(sj); 
    t0 := alarm.usec();                 # 35 t0:lng := ALARMusec() 
    j := algebra.join(large,smallR);    # 36 j:bat[:oid,:oid] := ALGjoin(large:bat[:oid,:sht], smallR:bat[:sht,:oid]) {G}
    t1 := alarm.usec();                 # 37 t1:lng := ALARMusec() 
    d0 := calc.-(t1,t0);                # 38 d0:lng := CALCbinarySUBlnglng(t1:lng, t0:lng) 
    io.printf("#join(large,smallRev) %d\n",d0);# 39 _40:void := IOprint_formatted_lng(_41:str, d0:lng) 
    v := aggr.count(j);                 # 40 v:int := ALGcount_bat(j:bat[:oid,:oid]) 
    io.printf("#count %d\n",v);         # 41 _42:void := IOprint_formatted_int(_37:str, v:int) 
#io.print(j); 
    t0 := alarm.usec();                 # 43 t0:lng := ALARMusec() 
    sj2 := algebra.kintersect(smallR,largeR);# 44 sj2:bat[:sht,:oid] := ALGsemijoin(smallR:bat[:sht,:oid], largeR:bat[:sht,:oid]) {G}
    t1 := alarm.usec();                 # 45 t1:lng := ALARMusec() 
    d0 := calc.-(t1,t0);                # 46 d0:lng := CALCbinarySUBlnglng(t1:lng, t0:lng) 
    io.printf("#kintersect(smallRev,largeRev) %d\n",d0);# 47 _45:void := IOprint_formatted_lng(_46:str, d0:lng) 
    v := aggr.count(sj2);               # 48 v:int := ALGcount_bat(sj2:bat[:sht,:oid]) 
    io.printf("#count %d\n",v);         # 49 _47:void := IOprint_formatted_int(_37:str, v:int) 
#io.print(sj2); 
    t0 := alarm.usec();                 # 51 t0:lng := ALARMusec() 
    j := algebra.join(small,smallR);    # 52 j:bat[:oid,:oid] := ALGjoin(small:bat[:oid,:sht], smallR:bat[:sht,:oid]) {G}
    t1 := alarm.usec();                 # 53 t1:lng := ALARMusec() 
    d0 := calc.-(t1,t0);                # 54 d0:lng := CALCbinarySUBlnglng(t1:lng, t0:lng) 
    io.printf("#join(small,largeRev) %d\n",d0);# 55 _49:void := IOprint_formatted_lng(_50:str, d0:lng) 
    v := aggr.count(j);                 # 56 v:int := ALGcount_bat(j:bat[:oid,:oid]) 
    io.printf("#count %d\n",v);         # 57 _51:void := IOprint_formatted_int(_37:str, v:int) 
#io.print(j); 
end main;	# 59  
#kintersect(largeRev,smallRev) 16600
#count 41
#join(large,smallRev) 34077
#count 41
#kintersect(smallRev,largeRev) 32
#count 3
#join(small,largeRev) 33
#count 3

# 20:15:10 >  
# 20:15:10 >  Done.
# 20:15:10 >  

