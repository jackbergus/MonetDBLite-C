stdout of test 'tst901b` in directory 'src/mal` itself:


# 07:48:36 >  
# 07:48:36 >  Mtimeout -timeout 60 mserver5 "--config=/ufs/mk/monet5/Linux/etc/monetdb5.conf" --debug=10 --set "monet_mod_path=/ufs/mk/monet5//Linux/lib/MonetDB5:/ufs/mk/monet5//Linux/lib/MonetDB5/lib:/ufs/mk/monet5//Linux/lib/MonetDB5/bin" --set "gdk_dbfarm=/ufs/mk/monet5//Linux/var/MonetDB5/dbfarm" --set "sql_logdir=/ufs/mk/monet5//Linux/var/MonetDB5/sql_logs" --set "xquery_logdir=/ufs/mk/monet5//Linux/var/MonetDB5/xquery_logs" --set mapi_port=36666 --set xrpc_port=40130 --set monet_prompt= --trace --dbname=mTests_src_mal  tst901b.mal
# 07:48:36 >  

# MonetDB Server v5.0.0_beta2_1
# Copyright (c) 1993-2007 CWI, all rights reserved
# Compiled for x86_64-redhat-linux-gnu/64bit with 64bit OIDs dynamically linked
# dbname:mTests_src_mal
# Visit http://monetdb.cwi.nl/ for further information
## what is the overhead of MAL in multiplex situations
## using a BATloop !! This is 40x slower as the V4.3 multiplex implementation
##profiler.setAll();
##profiler.setLogFile("/tmp/MonetProfile.xml");
#b:= bat.new(:oid,:lng);
#t0:= alarm.usec();
#barrier (v,i):= language.newRange(0:lng);
#	o:= calc.oid(i);
#	bat.insert(b,o,i);
#	redo (v,i):= language.nextElement(1:lng,1000000:lng);
#exit (v,i);
#t1:= alarm.usec();
#c:= algebra.copy(b);
#t2:= alarm.usec();
#d:= bat.new(:oid,:lng);
#barrier (mloop,h,t):= bat.newIterator(b);
#        zz:= algebra.find(b,h);
#        z:= algebra.find(c,h);
#	cr:= zz+z;
#	bat.insert(d,h,cr);
#catch GDKerror:str;
#	leave mloop;
#exit GDKerror;
#	redo (mloop,h,t):= bat.hasMoreElements(b);
#exit (mloop,h,t);
#t3:= alarm.usec();
##CMD000(b,b);
#t4:= alarm.usec();
#d1:= t1-t0;
#d2:= t3-t2;
#d3:= t4-t3;
#cnt:= aggr.count(d);
#io.printf("cnt %d ",cnt);
#io.printf("make %d ",d1);
#io.printf("multiplex %d\n",d2);
#io.printf("compiled multiplex %d\n",d3);
##profiler.stop();
#
function user.main():void;              #  0 main:void {G}
# what is the overhead of MAL in multiplex situations 
# using a BATloop !! This is 40x slower as the V4.3 multiplex implementation 
#profiler.setAll(); 
#profiler.setLogFile("/tmp/MonetProfile.xml"); 
    b := bat.new(:oid,:lng);            #  5 b:bat[:oid,:lng] := CMDBATnew(_6:oid, _7:lng) {G}
    t0 := alarm.usec();                 #  6 t0:lng 
barrier (v,i):= language.newRange(0:lng);#  7 (v:bit, i:lng) := RNGnewRange_lng(_11:lng) {J11}
    o := calc.oid(i);                   #  8 o:oid := CALClng2oid(i:lng) 
    bat.insert(b,o,i);                  #  9 _13:void := BKCinsert_bun(b:bat[:oid,:lng], o:oid, i:lng) 
    redo (v,i):= language.nextElement(1:lng,1000000:lng);# 10 (v:bit, i:lng) := RNGnextElement_lng(_14:lng, _15:lng) {J8}
exit (v,i);                             # 11 (v:bit, i:lng 
    t1 := alarm.usec();                 # 12 t1:lng 
    c := algebra.copy(b);               # 13 c:bat[:oid,:lng] := ALGcopy(b:bat[:oid,:lng]) {G}
    t2 := alarm.usec();                 # 14 t2:lng 
    d := bat.new(:oid,:lng);            # 15 d:bat[:oid,:lng] := CMDBATnew(_6:oid, _7:lng) {G}
barrier (mloop,h,t):= bat.newIterator(b);# 16 (mloop:lng, h:oid, t:lng) := CHPbunIterator(b:bat[:oid,:lng]) {J25}
    zz := algebra.find(b,h);            # 17 zz:lng := ALGfind(b:bat[:oid,:lng], h:oid) 
    z := algebra.find(c,h);             # 18 z:lng := ALGfind(c:bat[:oid,:lng], h:oid) 
    cr := calc.+(zz,z);                 # 19 cr:lng := CALCbinaryADDlnglng(zz:lng, z:lng) 
    bat.insert(d,h,cr);                 # 20 _26:void := BKCinsert_bun(d:bat[:oid,:lng], h:oid, cr:lng) 
catch GDKerror:str ;                    # 21 GDKerror:str {J23}
    leave mloop;                        # 22 mloop:lng {J25}
exit GDKerror:str ;                     # 23 GDKerror:str 
    redo (mloop,h,t):= bat.hasMoreElements(b);# 24 (mloop:lng, h:oid, t:lng) := CHPbunHasMoreElements(b:bat[:oid,:lng]) {J17}
exit (mloop,h,t);                       # 25 (mloop:lng, h:oid, t:lng 
    t3 := alarm.usec();                 # 26 t3:lng 
#CMD000(b,b); 
    t4 := alarm.usec();                 # 28 t4:lng 
    d1 := calc.-(t1,t0);                # 29 d1:lng := CALCbinarySUBlnglng(t1:lng, t0:lng) 
    d2 := calc.-(t3,t2);                # 30 d2:lng := CALCbinarySUBlnglng(t3:lng, t2:lng) 
    d3 := calc.-(t4,t3);                # 31 d3:lng := CALCbinarySUBlnglng(t4:lng, t3:lng) 
    cnt := aggr.count(d);               # 32 cnt:int := ALGcount_bat(d:bat[:oid,:lng]) 
    io.printf("#cnt %d ",cnt);          # 33 _35:void := IOprint_formatted_int(_36:str, cnt:int) 
    io.printf("#make %d ",d1);          # 34 _37:void := IOprint_formatted_lng(_38:str, d1:lng) 
    io.printf("#multiplex %d\n",d2);    # 35 _39:void := IOprint_formatted_lng(_40:str, d2:lng) 
    io.printf("#compiled multiplex %d\n",d3);# 36 _41:void := IOprint_formatted_lng(_42:str, d3:lng) 
#profiler.stop(); 
end main;	# 38  
#cnt 1000000 #make 782279 #multiplex 1936981
#compiled multiplex 4

# 07:48:39 >  
# 07:48:39 >  Done.
# 07:48:39 >  

