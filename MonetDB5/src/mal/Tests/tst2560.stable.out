stdout of test 'tst2560` in directory 'src/mal` itself:


# 11:22:26 >  
# 11:22:26 >  Mtimeout -timeout 60 mserver5 "--config=/ufs/mk/monet5/Linux/etc/MonetDB5.conf" --debug=10 --set "monet_mod_path=/ufs/mk/monet5/Linux/lib/MonetDB5:/ufs/mk/opensource/MonetDB/Linux/lib/MonetDB" --set "gdk_dbfarm=/ufs/mk/monet5/Linux/var/MonetDB5/dbfarm" --set "sql_logdir=/ufs/mk/monet5/Linux/var/MonetDB5/dblogs" --set mapi_port=31608 --set monet_prompt= --trace --dbname=mTests_src_mal  tst2560.mal < /dev/null
# 11:22:26 >  

# MonetDB Server v4.99.19
# Copyright (c) 1993-2006 CWI, all rights reserved
# Compiled for x86_64-redhat-linux-gnu/64bit with 64bit OIDs dynamically linked
# config:/ufs/mk/monet5/Linux/etc/MonetDB5.conf
# dbfarm:/ufs/mk/monet5/Linux/var/MonetDB5/dbfarm
# dbname:mTests_src_mal
# Visit http://monetdb.cwi.nl/ for further information
##materialized views example
#r:= bat.new(:void,:int);
#bat.setSequenceBase(r,0@0);
#bat.setRole(r,"emp","age");
#bat.append(r,1);
#bat.append(r,2);
#bat.append(r,3);
#io.print(r);
#s:= bat.new(:void,:str);
#bat.setSequenceBase(s,0@0);
#bat.setRole(s,"emp","name");
#bat.append(s,"A");
#bat.append(s,"B");
#bat.append(s,"C");
#io.print(s);
#
#factory view1(l:int,h:int):bat[:void,:str];
#a:bat[:void,:int] := bbp.bind("emp","age");
#b:bat[:void,:str] := bbp.bind("emp","name");
#barrier always:= true;
#	lOld:= l;
#	hOld:= h;
#	io.print("recalc");
#	c := algebra.select(a,l,h);
#	d := algebra.semijoin(b,c);
#	barrier available:=true;
#		yield d;
#		leave available:= lOld != l;
#		leave available:= hOld != h;
#		io.print("reuse");
#		redo available:=true;
#	exit available;
#	redo always;
#exit always;
#end view1;
factory user.view1(l:int,h:int):bat[:oid,:str];	# 0  (view1:bat[:oid,:str])<-(l:int)(h:int)
    a:bat[:void,:int]  := bbp.find("emp","age");	# 1 CMDbbpfind2 (a:bat[:void,:int])<-(_4:str)(_5:str)
    b:bat[:void,:str]  := bbp.find("emp","name");	# 2 CMDbbpfind2 (b:bat[:void,:str])<-(_4:str)(_7:str)
barrier always := true;	# 3  (always:bit)<-(_9:bit) jump 17
    lOld := l;	# 4  (lOld:int)<-(l:int)
    hOld := h;	# 5  (hOld:int)<-(h:int)
    io.print("recalc");	# 6 IOprint_val (_12:void)<-(_13:str)
    c := algebra.select(a,l,h);	# 7 ALGselect (c:bat[:oid,:int])<-(a:bat[:void,:int])(l:int)(h:int)
    d := algebra.semijoin(b,c);	# 8 ALGsemijoin (d:bat[:oid,:str])<-(b:bat[:void,:str])(c:bat[:oid,:int])
barrier available := true;	# 9  (available:bit)<-(_9:bit) jump 15
    yield d;	# 10  (d:bat[:oid,:str])
    leave available := calc.!=(lOld,l);	# 11 CALCcompNEQintint (available:bit)<-(lOld:int)(l:int) jump 15
    leave available := calc.!=(hOld,h);	# 12 CALCcompNEQintint (available:bit)<-(hOld:int)(h:int) jump 15
    io.print("reuse");	# 13 IOprint_val (_17:void)<-(_18:str)
    redo available := true;	# 14  (available:bit)<-(_9:bit) jump 10
exit available;	# 15  (available:bit)
    redo always;	# 16  (always:bit) jump 4
exit always;	# 17  (always:bit)
end view1;	# 18  
#
#e:= user.view1(0,2);
#io.print(e);
#e:= user.view1(0,2);
#io.print(e);
#e:= user.view1(0,4);
#io.print(e);
#
#
function user.main():void;	# 0  (main:void)
#materialized views example 	# 1  (_1:str)
    r := bat.new(:void,:int);	# 2 CMDBATnew (r:bat[:void,:int])<-(_3:void)(_4:int)
    bat.setSequenceBase(r,0@0);	# 3 BKCsetSequenceBase (_5:bat[:void,:int])<-(r:bat[:void,:int])(_6:oid)
    bat.setRole(r,"emp","age");	# 4 BKCsetRole (_7:void)<-(r:bat[:void,:int])(_8:str)(_9:str)
    bat.append(r,1);	# 5 BKCappend_val_wrap (_10:void)<-(r:bat[:void,:int])(_11:int)
    bat.append(r,2);	# 6 BKCappend_val_wrap (_12:void)<-(r:bat[:void,:int])(_13:int)
    bat.append(r,3);	# 7 BKCappend_val_wrap (_14:void)<-(r:bat[:void,:int])(_15:int)
    io.print(r);	# 8 IOprint_val (_16:void)<-(r:bat[:void,:int])
    s := bat.new(:void,:str);	# 9 CMDBATnew (s:bat[:void,:str])<-(_3:void)(_18:str)
    bat.setSequenceBase(s,0@0);	# 10 BKCsetSequenceBase (_19:bat[:void,:str])<-(s:bat[:void,:str])(_6:oid)
    bat.setRole(s,"emp","name");	# 11 BKCsetRole (_20:void)<-(s:bat[:void,:str])(_8:str)(_21:str)
    bat.append(s,"A");	# 12 BKCappend_val_wrap (_22:void)<-(s:bat[:void,:str])(_23:str)
    bat.append(s,"B");	# 13 BKCappend_val_wrap (_24:void)<-(s:bat[:void,:str])(_25:str)
    bat.append(s,"C");	# 14 BKCappend_val_wrap (_26:void)<-(s:bat[:void,:str])(_27:str)
    io.print(s);	# 15 IOprint_val (_28:void)<-(s:bat[:void,:str])
    e := user.view1(0,2);	# 16  (e:bat[:oid,:str])<-(_30:int)(_13:int)
    io.print(e);	# 17 IOprint_val (_31:void)<-(e:bat[:oid,:str])
    e := user.view1(0,2);	# 18  (e:bat[:oid,:str])<-(_30:int)(_13:int)
    io.print(e);	# 19 IOprint_val (_32:void)<-(e:bat[:oid,:str])
    e := user.view1(0,4);	# 20  (e:bat[:oid,:str])<-(_30:int)(_33:int)
    io.print(e);	# 21 IOprint_val (_34:void)<-(e:bat[:oid,:str])
end main;	# 22  
#-----------------#
# emp	age	  # name
# void	int	  # type
#-----------------#
[ 0@0,	  1	  ]
[ 1@0,	  2	  ]
[ 2@0,	  3	  ]
#-----------------#
# emp	name	  # name
# void	str	  # type
#-----------------#
[ 0@0,	  "A"	  ]
[ 1@0,	  "B"	  ]
[ 2@0,	  "C"	  ]
[ "recalc" ]
#-----------------#
# t	h	  # name
# void	str	  # type
#-----------------#
[ 0@0,	  "A"	  ]
[ 1@0,	  "B"	  ]
[ "reuse" ]
#-----------------#
# t	h	  # name
# void	str	  # type
#-----------------#
[ 0@0,	  "A"	  ]
[ 1@0,	  "B"	  ]
[ "recalc" ]
#-----------------#
# h	t	  # name
# void	str	  # type
#-----------------#
[ 0@0,	  "A"	  ]
[ 1@0,	  "B"	  ]
[ 2@0,	  "C"	  ]

# 11:22:26 >  
# 11:22:26 >  Done.
# 11:22:26 >  

