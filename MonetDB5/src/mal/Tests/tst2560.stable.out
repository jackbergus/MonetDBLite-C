stdout of test 'tst2560` in directory 'src/mal` itself:


# 11:22:26 >  
# 11:22:26 >  Mtimeout -timeout 60 mserver5 "--config=/ufs/mk/monet5/Linux/etc/MonetDB5.conf" --debug=10 --set "monet_mod_path=/ufs/mk/monet5/Linux/lib/MonetDB5:/ufs/mk/opensource/MonetDB/Linux/lib/MonetDB" --set "gdk_dbfarm=/ufs/mk/monet5/Linux/var/MonetDB5/dbfarm" --set "sql_logdir=/ufs/mk/monet5/Linux/var/MonetDB5/dblogs" --set mapi_port=31608 --set monet_prompt= --trace --dbname=mTests_src_mal  tst2560.mal < /dev/null
# 11:22:26 >  

# MonetDB Server v4.99.19
# Copyright (c) 1993-2006 CWI, all rights reserved
# Compiled for x86_64-redhat-linux-gnu/64bit with 64bit OIDs dynamically linked
# config:/ufs/mk/monet5/Linux/etc/MonetDB5.conf
# dbfarm:/ufs/mk/monet5/Linux/var/MonetDB5/dbfarm
# dbname:mTests_src_mal
# Visit http://monetdb.cwi.nl/ for further information
##materialized views example
#r:= bat.new(:void,:int);
#bat.setSequenceBase(r,0@0);
#bat.setRole(r,"emp","age");
#bat.append(r,1);
#bat.append(r,2);
#bat.append(r,3);
#io.print(r);
#s:= bat.new(:void,:str);
#bat.setSequenceBase(s,0@0);
#bat.setRole(s,"emp","name");
#bat.append(s,"A");
#bat.append(s,"B");
#bat.append(s,"C");
#io.print(s);
#
#factory view1(l:int,h:int):bat[:void,:str];
#a:bat[:void,:int] := bbp.bind("emp","age");
#b:bat[:void,:str] := bbp.bind("emp","name");
#barrier always:= true;
#	lOld:= l;
#	hOld:= h;
#	io.print("recalc");
#	c := algebra.select(a,l,h);
#	d := algebra.semijoin(b,c);
#	barrier available:=true;
#		yield d;
#		leave available:= lOld != l;
#		leave available:= hOld != h;
#		io.print("reuse");
#		redo available:=true;
#	exit available;
#	redo always;
#exit always;
#end view1;
factory user.view1(l:int,h:int):bat[:oid,:str];#  0 view1:bat[:oid,:str] := user.view1(l:int, h:int) {G}
    a:bat[:oid,:int]  := bbp.bind("emp","age");#  1 a:bat[:oid,:int] := CMDbbpbind2(_4:str, _5:str) {G}
    b:bat[:oid,:str]  := bbp.bind("emp","name");#  2 b:bat[:oid,:str] := CMDbbpbind2(_4:str, _7:str) {G}
barrier always := true;                 #  3 always:bit := _9:bit {J17}
    lOld := l;                          #  4 lOld:int := l:int 
    hOld := h;                          #  5 hOld:int := h:int 
    io.print("recalc");                 #  6 _12:void := IOprint_val(_13:str) 
    c := algebra.select(a,l,h);         #  7 c:bat[:oid,:int] := ALGselect(a:bat[:oid,:int], l:int, h:int) {G}
    d := algebra.semijoin(b,c);         #  8 d:bat[:oid,:str] := ALGsemijoin(b:bat[:oid,:str], c:bat[:oid,:int]) {G}
barrier available := true;              #  9 available:bit := _9:bit {J15}
    yield view1 := d;                   # 10 view1:bat[:oid,:str] := d:bat[:oid,:str] {G}
    leave available := calc.!=(lOld,l); # 11 available:bit := CALCcompNEQintint(lOld:int, l:int) {J15}
    leave available := calc.!=(hOld,h); # 12 available:bit := CALCcompNEQintint(hOld:int, h:int) {J15}
    io.print("reuse");                  # 13 _17:void := IOprint_val(_18:str) 
    redo available := true;             # 14 available:bit := _9:bit {J10}
exit available;                         # 15 available:bit 
    redo always;                        # 16 always:bit {J4}
exit always;                            # 17 always:bit 
end view1;	# 18  
#
#e:= user.view1(0,2);
#io.print(e);
#e:= user.view1(0,2);
#io.print(e);
#e:= user.view1(0,4);
#io.print(e);
#
#
function user.main():void;              #  0 main:void {G}
#materialized views example 
    r := bat.new(:oid,:int);            #  2 r:bat[:oid,:int] := CMDBATnew(_3:oid, _4:int) {G}
    bat.setRole(r,"emp","age");         #  3 _5:void := BKCsetRole(r:bat[:oid,:int], _6:str, _7:str) 
    bat.append(r,1);                    #  4 _8:void := BKCappend_val_wrap(r:bat[:oid,:int], _9:int) 
    bat.append(r,2);                    #  5 _10:void := BKCappend_val_wrap(r:bat[:oid,:int], _11:int) 
    bat.append(r,3);                    #  6 _12:void := BKCappend_val_wrap(r:bat[:oid,:int], _13:int) 
    io.print(r);                        #  7 _14:void := IOprint_val(r:bat[:oid,:int]) 
    s := bat.new(:oid,:str);            #  8 s:bat[:oid,:str] := CMDBATnew(_3:oid, _16:str) {G}
    bat.setRole(s,"emp","name");        #  9 _17:void := BKCsetRole(s:bat[:oid,:str], _6:str, _18:str) 
    bat.append(s,"A");                  # 10 _19:void := BKCappend_val_wrap(s:bat[:oid,:str], _20:str) 
    bat.append(s,"B");                  # 11 _21:void := BKCappend_val_wrap(s:bat[:oid,:str], _22:str) 
    bat.append(s,"C");                  # 12 _23:void := BKCappend_val_wrap(s:bat[:oid,:str], _24:str) 
    io.print(s);                        # 13 _25:void := IOprint_val(s:bat[:oid,:str]) 
    e := user.view1(0,2);               # 14 e:bat[:oid,:str] := user.view1(_27:int, _11:int) {G}
    io.print(e);                        # 15 _28:void := IOprint_val(e:bat[:oid,:str]) 
    e := user.view1(0,2);               # 16 e:bat[:oid,:str] := user.view1(_27:int, _11:int) {G}
    io.print(e);                        # 17 _29:void := IOprint_val(e:bat[:oid,:str]) 
    e := user.view1(0,4);               # 18 e:bat[:oid,:str] := user.view1(_27:int, _30:int) {G}
    io.print(e);                        # 19 _31:void := IOprint_val(e:bat[:oid,:str]) 
end main;	# 20  
#-----------------#
# emp	age	  # name
# void	int	  # type
#-----------------#
[ 0@0,	  1	  ]
[ 1@0,	  2	  ]
[ 2@0,	  3	  ]
#-----------------#
# emp	name	  # name
# void	str	  # type
#-----------------#
[ 0@0,	  "A"	  ]
[ 1@0,	  "B"	  ]
[ 2@0,	  "C"	  ]
[ "recalc" ]
#-----------------#
# t	h	  # name
# void	str	  # type
#-----------------#
[ 0@0,	  "A"	  ]
[ 1@0,	  "B"	  ]
[ "reuse" ]
#-----------------#
# t	h	  # name
# void	str	  # type
#-----------------#
[ 0@0,	  "A"	  ]
[ 1@0,	  "B"	  ]
[ "recalc" ]
#-----------------#
# h	t	  # name
# void	str	  # type
#-----------------#
[ 0@0,	  "A"	  ]
[ 1@0,	  "B"	  ]
[ 2@0,	  "C"	  ]


# 11:22:26 >  
# 11:22:26 >  Done.
# 11:22:26 >  

