# analyse the overhead of chopping a table
# the multiplex code blocks.

factory getChunk(b:bat[:void,:lng], size:lng)(bb:bit,c:bat[:void,:lng]);
    (chk,c):= chop.newChunkIterator(b,size);
    bf:= true; # change in bb to crash
barrier allways:= chk>0;
    yield (bb,c):= (true,c);
    (chk,c):= chop.hasMoreChunks(b,size);
    redo allways:= chk>0;
exit allways;
    io.printf("#factory done\n");
    return (bb,c):= (false,c);
end getChunk;

function choptest(b:bat[:void,:lng], size:lng, base:lng);
    t0:= alarm.usec();
    barrier (tst,c):= user.getChunk(b,size);
        t:= algebra.select(c, 256000:lng,266000:lng);
        redo (tst,c):= user.getChunk(b,size);
    exit (tst,c);
    t1:= alarm.usec();
    d0:= t1-t0;
    io.printf("#chopped at %d",size);
    io.printf(" %d",d0);
    d0:= d0-base;
    io.printf(" %d ",d0);
    i:= 1000000:lng/size;
    if:= calc.flt(i);
    df:= calc.flt(d0);
    f:= df/if;
    io.printf(" at %f usec\n",f);
end choptest;

b:= bat.new(:void,:lng);
barrier (go,i):= mal.newRange(0:lng);
	k:= mmath.rand();
	l:= calc.lng(k);
	bat.insert(b,nil,l);
	redo (go,i):= mal.nextElement(1:lng,1000000:lng);
exit (go,i);
t0:= alarm.usec();
barrier doit:= true;
    t:= algebra.select(b, 256000:lng,266000:lng);
exit doit;
t1:= alarm.usec();
base:= t1-t0;
io.printf("#select direct %d usec\n",base);

user.choptest(b,100000:lng,base);
user.choptest(b,10000:lng,base);
user.choptest(b,1000:lng,base);
user.choptest(b,100:lng,base);
