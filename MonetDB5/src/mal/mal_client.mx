@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2007 CWI.
@' All Rights Reserved.

@a M. L. Kersten
@v 5.0
@-
Clients gain access to the Monet server through a internet connection
or through its server console.
Access through the internet requires a client program at the
source, which addresses the default port of a running server.
The functionality of the server console is limited.
It is a bare bone textual interface for expert use.

@ifset M5manual
At the server side, each client is represented by a session record with the
current status, such as name, file descriptors, namespace, and local stack.
Each client session has a dedicated thread of control, which limits
the number of concurrent users to the thread management facilities of the
underlying operating system. A large client base should be supported using
a single server-side client thread, geared at providing
a particular service.

The number of clients permitted concurrent access is 
a compile time option. The console is the first and is always present.
It reads from standard input and writes to standard output.
@end ifset

Client sessions remain in existence until the corresponding
communication channels break or its retention timer expires
The administrator and owner of a sesssion
can manipulate the timeout with a system call.

@ifset sqlmanual
There are many user-friendly tools to interact with a SQL database server.
A few based on the JDBC library of MonetDB are included for reference only.
@end ifset
@{
Client records are linked into a hierarchy, where the top record
denotes the context of the Monet administrator. The next layer
is formed by a database administrator and the third layer contains
user sessions.
This hierachy is used to share and constrain resources, such
as global variables or references to catalogue information.
During parallel execution additional layers may be constructed.
[This feature needs more implementation support]
@}

@{
The routines defined below provide management of the client
administration. Routines dealing with serviceing requests
are located in mal\_startup.
@h
#ifndef _MAL_CLIENT_H_
#define _MAL_CLIENT_H_
#define bitset int

/* #define MAL_CLIENT_DEBUG */

#include "mal_resolve.h"
#include "mal_profiler.h"
#include "mal.h"

#define MAL_MAXCLIENTS  32
#define CONSOLE     0
#define isAdministrator(X) (X==mal_clients)

#define FREECLIENT  0
#define FINISHING   1   
#define CLAIMED     2
#define AWAITING    4

#define TIMEOUT     (5*60)  /* seconds */
#define PROCESSTIMEOUT  2   /* seconds */

#ifdef HAVE_SYS_RESOURCE_H
# include <sys/resource.h>
#endif

@-
The prompt structure is designed to simplify recognition
of the language framework for interaction. For direct console
access it is a short printable ascii string. For access through
an API we assume the prompt is an ascii string surrounded by a \001
character. This simplifies recognition.
The information between the prompt brackets can be used to
pass the mode to the front-end. Moreover, the prompt can be
dropped if a single stream of information is expected from the
server(See mal_profiler.mx).
@-
The user can request server-side compilation as part of the 
initialization string. See the documentation on Scenarios.
@h
typedef struct CLIENT_INPUT {
	bstream             *fdin;
	int                 yycur;		
	int                 listing;
	char                *prompt;
	struct CLIENT_INPUT *next;    
} ClientInput;

typedef struct CLIENT {
	int idx;        /* entry in mal_clients */
	oid user;       /* user id in the auth administration */
	int sessionkey; /* NOTUSED ANYMORE */
	int permission; /* access mode */
@-
The actions for a client is separated into several stages: parsing,
strategic optimization, tactial optimization, and execution. 
The routines to handle them are obtained once the scenario is choosen.
Each stage carries a state descriptor, but they share the IO state
description. A backup structure is provided
to temporarily switch to another scenario. Propagation of the state
information should be dealt with separately.[TODO]
@h
	str     scenario;  /* scenario management references */
	str     oldscenario;
	str     srcFile;	/* NULL for stdin, or file name */
	void    *state[7], *oldstate[7];
	MALfcn  phase[7], oldphase[7];
	char    itrace;     /* trace execution using interactive mdb */
	short   debugOptimizer,debugScheduler;
@-
For program debugging we need information on the timer and memory
usage patterns.
@h
	sht		flags;	/* resource tracing flags */
	lng     timer;  /* trace time in usec */

#define timerFlag	1
#define memoryFlag	2
#define ioFlag	4
#define flowFlag	8
@-
@}
@-
@{
Session structures are currently not saved over network failures.
Future releases may support a re-connect facility.  [TODO]
@h
	time_t      login;  
	time_t      logout;
	time_t      delay;
@-
Communication channels for the interconnect are stored here.
It is perfectly legal to have a client without input stream.
It will simple terminate after consuming the input buffer.
The monitor file descriptor can be set to trace the input received
from a particular client. This facility is used by Mapi to trace
the interaction on the system console (sysmon). 
@h
	bstream  *fdin;
	bstream	 *console;	/* always available for reading */
	int      yycur;		/* the scanners current position */
	ClientInput *bak;   /* used for recursive script and string execution */
	stream   *fdout;    /* streams from and to user. */

	str output; 	/* output buffer */
	str prompt;         /* acknowledge prompt */
	int promptlength;
@-
In interactive mode, reading one line at a time, we should be
aware of parsing compound structures, such as functions and
barrier blocks. The level of nesting is maintained in blkmode,
which is reset to zero upon encountering an end instruction,
or the closing bracket has been detected. Once the complete
structure has been parsed the program can be checked and executed.
Nesting is indicated using a '+' before the prompt.
@h
	int blkmode;        /* control block parsing */
@-
Keeping track of instructions executed is a valueable tool for
script processing and debugging. 
Its default value is defined in the MonetDB configuration file.
It can be changed at runtime for individual clients using
the operation @sc{clients.listing}(@emph{mask}).
A listing bit controls the level of detail to be generated during
program execution tracing. The lowest level (1) simply dumps the input,
(2) also demonstrates the MAL internal structur (4) adds the 
type information
@h
	bitset  listing;        
@-
The MAL debugger uses the client record to keep track of
any pervasive debugger command. For detailed information
on the debugger features.
@{
@h
	bitset debug;
	stream  *sysmon;        /* trace interaction */
	stream  *journal;
	str  history;			/* where to keep console history */
	short mode;           /* FREECLIENT..BLOCKED */
	str cwd;            /* working directory of client */
@-
Client records are organized into a two-level dependency
tree, where children may be created to deal with parallel processing
activities. Each client runs in its own process thread. Its identity
is retained here for access by others (=father).
@h
	Thread      mythread;
	size_t		mypid;
	str     	errbuf;     /* location of GDK exceptions */
	struct CLIENT   *father;    
@-
Each client has a private entry point into the namespace and
object space (the global variables).
Moreover, the parser needs some administration variables
to keep track of critical elements.
@h
	Module      nspace;     /* private scope resolution list */
	Symbol      curprg;     /* focus of parser */
	Symbol      backup;     /* save parsing context */
	MalStkPtr   glb;        /* global variable stack */
} *Client, ClientRec;

mal_export ClientRec mal_clients[MAL_MAXCLIENTS+1];

mal_export Client   MCgetClient   (void);
mal_export Client   MCinitClient(oid user, bstream *fin, stream *fout);
mal_export void     MCinitClientThread(Client c);
mal_export void     MCcloseClient    (Client c);
mal_export Client   MCforkClient     (Client c);
mal_export void     MCkillClient     (Client c, int timeout);
mal_export int		MCcountClients(void);
mal_export int      MCreadClient  (Client c);
mal_export str      MCstopClient(Client c, oid which);
mal_export str      MCstopClientIndex(Client c, int id);
mal_export void 	MCshutdown(Client c, int timeout);
mal_export void     MCcleanupClients(void);
mal_export void     MCtraceAllClients(int flag);
mal_export void     MCtraceClient(oid which, int flag);

mal_export bstream *MCgetConsole(Client c);
mal_export void     MCpushClientInput(Client c, bstream *new_input, int listing, char *prompt);
mal_export void     MCpopClientInput(Client c);

#endif /* _MAL_CLIENT_H_ */
@-
@}

A client record is initialized upon acceptance of a connection.
The client runs in his own thread of control until it finds a
soft-termination request mode (FINISHING) or its IO file
descriptors are closed. The latter generates an IO error, which
leads to a safe termination.

The system administrator client runs in the primary thread of
control to simplify debugging with external debuggers.

A new Client structure can only be requested if the 'adm'
user is available, because it guarantees a way to deliver
any error message.
Searching a free client record is encapsulated in
a critical section to hand them out one-at-a-time.
Marking them as being claimed avoids any interference from parallel
actions to obtain client records.

@{
@c
#include "mal_config.h"
#include "mal_client.h"
#include "mal_readline.h"
#include "mal_import.h"
#include "mal_parser.h"
#include "mal_namespace.h"

/* This should be in src/mal/mal.h, as the function is implemented in 
 * src/mal/mal.c; however, it cannot, as "Client" isn't known there ... |-( 
 * For now, we move the prototype here, as it it only used here.
 * Maybe, we should concider also moving the implementation here...

int streamClient(Client c, str prompt);
int bstreamClient(Client c, str prompt);
 */

static void     freeClient  (Client c);

ClientRec   mal_clients[MAL_MAXCLIENTS+1];

void THRsuspend(Thread h){
	(void) h;
	/* printf("suspend Thread %d %d\n", h->tid, (int) h->pid);*/
}
void THRawake(Thread h){
	(void) h;
	/* printf("awake Thread %d %d\n", h->tid, (int) h->pid);*/
}

bstream *MCgetConsole(Client c){
	ClientInput *x;
	if( c->bak == 0) return c->fdin;
	x= c->bak;
	while(x->next) x= x->next;
	return x->fdin;
	/* return c->console;*/
}
void MCpushClientInput(Client c, bstream *new_input, int listing, char *prompt)
{
	ClientInput *x = (ClientInput*)GDKmalloc(sizeof(ClientInput));
	x->fdin = c->fdin;
	x->yycur = c->yycur;
	x->listing = c->listing;
	x->prompt = c->prompt;
	x->next = c->bak;
	c->bak = x;
	c->fdin = new_input;
	c->listing = listing;
	c->prompt = GDKstrdup(prompt);
	c->promptlength = strlen(c->prompt);
	c->yycur = 0;
}

void MCpopClientInput(Client c)
{
	ClientInput *x = c->bak;
	if (c->fdin) {
		/* missing protection against closing stdin stream */
		(void) stream_close(c->fdin->s);
		(void) stream_destroy(c->fdin->s);
		(void) bstream_destroy(c->fdin);
	}
	GDKfree(c->prompt);
	c->fdin = x->fdin;
	c->yycur = x->yycur;
	c->listing = x->listing;
	c->prompt = x->prompt;
	c->promptlength = strlen(c->prompt);
	c->bak = x->next;
	GDKfree(x);
}

Client MCnewClient(){
	Client  c;
	if( mal_clients[CONSOLE].user)
		GDKprotect();
	mal_set_lock(mal_contextLock, "newClient");
	if( mal_clients[CONSOLE].user &&
			mal_clients[CONSOLE].mode == FINISHING){
		showException(MAL,"newClient", "system shutdown in progress");
		mal_unset_lock(mal_contextLock, "newClient");
		return NULL;
	}
	for(c = mal_clients; c < mal_clients+MAL_MAXCLIENTS; c++) {
		if (c->mode == FREECLIENT) {
			c->mode= CLAIMED;
			break;
		}
	}
	mal_unset_lock(mal_contextLock, "newClient");

	if (c == mal_clients+MAL_MAXCLIENTS) {
		GDKfatal("Out of client slots\n");
		return NULL;
	}
	c->idx= c - mal_clients;
#ifdef MAL_CLIENT_DEBUG
	printf("New client created %d\n",c-mal_clients);
#endif
	return c;
}
@-
You can always retrieve a client record using the thread identifier,
because we maintain a 1-1 mapping between client and thread of control.
Therefore, we don't need locks either.
If the number of clients becomes too large, we have to change the 
allocation and lookup scheme.
@c
Client MCgetClient()
{
	Client c;
	size_t pid= MT_getpid();
	Thread tid;

	for(c = mal_clients+1; c < mal_clients+MAL_MAXCLIENTS; c++) 
		if( c->mypid == pid) return c;
	if( mal_clients->mypid== pid) return mal_clients;

	tid= THRget(THRgettid());
	for(c = mal_clients; c < mal_clients+MAL_MAXCLIENTS; c++) 
		if( c->mythread == tid) return c;

	for(c = mal_clients; c < mal_clients+MAL_MAXCLIENTS; c++) 
		if( c->mythread) stream_printf(c->fdout,"client %d\n",c->mythread);
	showException(MAL, "getClient", "unexpected call to getClient %d", tid);
	return NULL;
}

Client MCinitClient(oid user, bstream *fin, stream *fout) {
	Client c;
	str prompt;

	if ((c = MCnewClient()) == NULL)
		return NULL;

	c->user = user; 
	c->scenario = NULL;
	c->oldscenario = NULL;
	c->srcFile = NULL;
	c->sessionkey = 0;
	c->blkmode = 0;

	c->fdin = fin ? fin : bstream_create(GDKin,0);
	c->console = c->fdin;
	c->yycur = 0;
	c->bak = NULL;

	c->listing = 0;
	c->fdout = fout ? fout : GDKstdout;
	c->sysmon = mal_clients[0].sysmon ? mal_clients[0].fdout : 0;
	c->journal = NULL;
	c->history = 0;
@-
The output buffer is currently not used. Beware to garbage
collect the buffer when in use.
@c
	c->output = 0;
	if(c->nspace==0)
		c->nspace = newModule(NULL, putName("guest",5));
	c->curprg = c->backup = 0;
	c->glb = 0;

	c->father = NULL;
	c->login = time(0); c->delay= TIMEOUT;
	c->logout= c->login+c->delay;
	c->mode = AWAITING;
	c->itrace = 0;
	c->debugOptimizer = c->debugScheduler= 0;
	c->timer = 0;
	c->errbuf = 0;

	c->cwd= GDKstrdup(monet_cwd);
	prompt = !fin? GDKgetenv("monet_prompt"): PROMPT1;
	c->prompt= GDKstrdup(prompt);
	c->promptlength= strlen(prompt);
	if( isAdministrator(c)) MCinitClientThread(c);
	return c;
}
@-
The administrator should be initialized to enable
interpretation of the command line arguments, before
it starts serviceing statements
@c
void MCinitClientThread(Client c)
{
	Thread t;
	char cname[11 + 1];
/*	still unsafe, race conditions, garbage left over??
	if( c->mythread){
		t= c->mythread;
	} else
*/
		snprintf(cname, 11, SZFMT, (size_t)(c->user));
		cname[11] = '\0';
		c->mythread = t=  THRnew(c->mypid=MT_getpid(),cname);
	c->errbuf = GDKerrbuf;
	if (c->errbuf == NULL) {
		GDKsetbuf( GDKmalloc(GDKMAXERRLEN));
		c->errbuf = GDKerrbuf;
	}
	c->errbuf[0]=0;
@-
The GDK thread administration should be set to reflect use of
the proper IO descriptors.
@c
	if ( t==0) {
		showException(MAL, "initClientThread", "Failed to initialize client");
		MPresetProfiler(c->fdout);
		assert(c->bak==NULL);
		if( c->fdin){
			/* missing protection against closing stdin stream */
			(void) stream_close(c->fdin->s);
			(void) stream_destroy(c->fdin->s);
			(void) bstream_destroy(c->fdin);
		}
		if( c->fdout && c->fdout != GDKstdout) {
			(void) stream_close(c->fdout);
			(void) stream_destroy(c->fdout);
		}
		/* if( c->socket) close(c->socket);*/
		return ;
	}
	t->data[1] = c->fdin;
	t->data[0] = c->fdout;
} 
@- Client decendants
Forking is a relatively cheap way to create a new client.
The new client record shares the IO descriptors.
To avoid interference, we limit children to only produce 
output by closing the input-side.

If the father itself is a temporary client, let 
the new child depend on the grandfather.
@c
Client MCforkClient(Client father){
	Client son = NULL;
	if( father == NULL) return NULL;
	if (father->father != NULL) father = father->father;
	if ((son = MCinitClient(father->user, father->fdin, father->fdout))) {
		son->fdin= NULL;
		son->bak= NULL;
		son->yycur=0;
		son->father = father;
		son->scenario = father->scenario;
		son->prompt = GDKstrdup(father->prompt);
		son->promptlength= strlen(father->prompt);
		/* reuse the scopes wherever possible */
		son->nspace->name= GDKstrdup("Client-child");
		son->nspace->outer = mal_scope;
	}
	return son;
}

@-

When a client needs to be terminated then the file descriptors for
its input/output are simply closed. 
This leads to a graceful degradation, but may take some time
when the client is busy.
A more forcefull method is to kill the client thread, but this
may leave locks and semaphores in an undesirable state.

The routine freeClient ends a single client session,
but through side effects of sharing IO descriptors,
also its children. Conversely, a child can not close a parent.
@{
@c
void freeClient(Client c)
{
	c->mode = FINISHING;

	/* epilogue actions have been done already */
	if (c->father == NULL) { /* normal client */
		if( c->fdout && c->fdout != GDKstdout){
			MPresetProfiler(c->fdout);
			(void) stream_close(c->fdout);
			(void) stream_destroy(c->fdout);
		}
		assert(c->bak==NULL);
		if(c->fdin){
			/* missing protection against closing stdin stream */
			(void) stream_close(c->fdin->s);
			(void) stream_destroy(c->fdin->s);
			(void) bstream_destroy(c->fdin);
		}
		c->fdout = NULL;
		c->fdin= NULL;
	} 
	/* forked client also */

	/* scope list and curprg can not be removed, 
	   because the client may reside in a
	   quit() command. Therefore the scopelist is re-used.
	if( c->curprg ) {
		freeSymbol(c->curprg); 
		c->curprg=0;
	}
	if( c->nspace) {
		freeModule(c->nspace);
		c->nspace=0;
	}
	   */
	/* re-use output buffer */
	c->scenario = NULL;
	if(c->prompt) GDKfree(c->prompt); c->prompt = NULL;
	if(c->cwd) GDKfree(c->cwd); c->cwd = NULL;
	c->promptlength=-1;
	if(c->errbuf){
		GDKsetbuf(0);
		GDKfree(c->errbuf);
		c->errbuf=0;
	}
	c->father = 0;
	c->login = c->delay = c->logout = 0;
@-
The threads may not be removed, but should become dormant
@c
	THRdel(c->mythread);
	c->mythread= 0;
	c->mypid= 0;
	/* THRsuspend(c->mythread); still unsafe */
	c->user = oid_nil;
	c->mode = FREECLIENT;
}

@-
If a client disappears from the scene (eof on stream), we should
terminate all its children. This is in principle a forcefull action,
because the children may be ignoring the primary IO streams.
(Instead they may be blocked in an infinite loop)

Special care should be taken by closing the 'adm' thread.
It is permitted to leave only when it is the sole user of the system.

Furthermore, once we enter closeClient, the process in which it is
raised has already lost its file descriptors.
@c
void MCcloseClient(Client c) {
	Client k;

#ifdef MAL_DEBUG_CLIENT
	printf("closeClient %d %d\n",c-mal_clients,c->user);
#endif
	/* kill living background clients */
	for (k = mal_clients; k < mal_clients+MAL_MAXCLIENTS; k++) {
		if ((k->mode > FINISHING) && (k->father == c)) 
			MCkillClient(k, PROCESSTIMEOUT);
	}

	/* free resources of a single thread */
	if( !isAdministrator(c)) {
		freeClient(c);
		return;
	} 

	/* adm is set to disallow new clients entering */
	mal_clients[CONSOLE].mode= FINISHING;

	for (k = mal_clients+1; k < mal_clients+MAL_MAXCLIENTS; k++) 
		if ((k->mode > FINISHING) ){
			showException(MAL,"closeClient", "client '%d' is still active", k->user);
			MCkillClient(k, PROCESSTIMEOUT);
		}
	MCkillClient(CONSOLE, PROCESSTIMEOUT);
	mal_exit();
}
@-
Shutting down a server should be limited to console operations
and authorized remote admin calls.
@c
void MCshutdown(Client c, int timeout){
	Client k;

	for (k = mal_clients; k < mal_clients+MAL_MAXCLIENTS; k++) {
		if ((k->mode > FINISHING) && (k != c)) 
			MCkillClient(k,timeout);
	}
	MCkillClient(c,timeout);
}

@-
Killing a (child) client is a delicate action, because the state of
the client is unknown. The current solution is to issue
a soft-termination request first by setting its mode flag. 
The client main interpreter loop should look at it upon each
cycle and terminate.

After the PROCESSTIMEOUT delay the thread is forcefully killed,
assuming it was either waiting for a lock, or external
event in any way.

The current code is not correct. It should selectively kill
a pthread, rather waiting for them to finish the request being
handled.  Since they may be waiting for IO this can take a
very long time, since we have access to the file descriptor it may
work by closing them.
@c 
void MCkillClient(Client c, int timeout) {
	if (c && c->user != oid_nil ) {

#ifdef MAL_DEBUG_CLIENT
		printf("killClient %d\n", c - mal_clients);
#endif	/* MAL_DEBUG_CLIENT */

		/* GDKwarning("killClient:forcing client to stop ...\n");*/
		/* the process may hang upon gaining access to the file descriptors */ 
		c->mode = FINISHING;
		MPresetProfiler(c->fdout);
		if (c == mal_clients) {
			/* die the hard way */
			c->curprg->def->stop = 0;
		} else if (c->mythread) {
			(void) stream_close(c->fdout);
			(void) stream_destroy(c->fdout);
			c->fdout = NULL;
			(void) stream_close(c->fdin->s);
			(void) stream_destroy(c->fdin->s);
			(void) bstream_destroy(c->fdin);
			c->fdin = NULL;
			assert(c->bak == NULL);
			/* GDKwarning("killClient:about to kill process ...\n");*/
			MT_sleep_ms(1000 * timeout);
			MT_kill_thread(c->mythread->pid);
			MT_sleep_ms(1000 * timeout);
			/*GDKwarning("killClient:process killed\n");*/
		}
	}
} 

@-
At the end of the server session all remaining structured are
explicitly released to simplify detection of memory leakage problems.
@c
void MCcleanupClients(){
	Client c;
	for(c = mal_clients; c < mal_clients+MAL_MAXCLIENTS; c++) {
		/* if( c->nspace){ freeModuleList(c->nspace); c->nspace=0;}*/
		if( c->cwd){ 
			GDKfree(c->cwd); 
			c->cwd = NULL;
		}
		if( c->prompt){ 
			GDKfree(c->prompt); 
			c->prompt = NULL;
		}
		c->user = oid_nil;
		assert(c->bak==NULL);
		if( c->fdin){
			(void) stream_close(c->fdin->s);
			(void) stream_destroy(c->fdin->s); 
			(void) bstream_destroy(c->fdin);
			c->fdin= NULL;
		}
		if( c->fdout && c->fdout != GDKstdout){
			MPresetProfiler(c->fdout);
			(void) stream_destroy(c->fdout); 
			c->fdout= NULL;
		}
	}
}
@-
An internet connection may be terminated from the server console.
And killing the administrator this way is prohibited.
@c
str MCstopClientIndex(Client c, int id)
{
	if( ! isAdministrator(c))
		throw(PERMD, "stop","Only permitted from server console");
	if( id<=0 || id>=MAL_MAXCLIENTS || mal_clients[id].mode==FREECLIENT)
		throw(MAL, "stop","Illegal client index");
	MCkillClient(mal_clients+id, PROCESSTIMEOUT);
	return MAL_SUCCEED;
}
str MCstopClient(Client c, oid which){
	if( ! isAdministrator(c))
		throw(PERMD, "stop","Only permitted from server console");

	mal_set_lock(mal_contextLock, "stopClient");
	for(c = mal_clients; c < mal_clients+MAL_MAXCLIENTS; c++) {
		if (c->mode > FREECLIENT && c->user == which) {
			MCkillClient(c, PROCESSTIMEOUT);
			mal_unset_lock(mal_contextLock, "stopClient");
			return MAL_SUCCEED;
		}
	}
	mal_unset_lock(mal_contextLock, "stopClient");
	throw(ILLARG, "stop","Illegal client name");
}
@-
In embedded mode there can be at most one console client and one 
Mapi connection. Moreover, the Mapi connection should disable the administrator
console.
@c
int MCcountClients(){
	int cnt=0;
	Client c;
	for(c = mal_clients; c < mal_clients+MAL_MAXCLIENTS; c++) 
		if (c->mode != FREECLIENT) cnt++;
	return cnt;
}
int MCrunEmbedded(Client c){
	(void) c;
	/* to be defined */
	return 0;
}
@-
@}
@+ Spying on clients
During system monitoring with multiple clients active it is
often hard to detect who or what is causing a system degradation. 
Therefore a spying scheme for the system administrator is
available. He can enable tracing interactions from the internet connections
to the system console.
@{
@= sysTrace
	if( c->sysmon){
		stream_printf(c->sysmon,"#[%d]",c->user);
		stream_printf(c->sysmon, @1);
		stream_printf(c->sysmon,"\n");
	}
@-
@c
void MCtraceClient(oid which, int flag){
	Client c;
	for(c = mal_clients; c < mal_clients+MAL_MAXCLIENTS; c++) 
		if( c->user == which ){
#ifdef MAL_CLIENT_DEBUG
			printf("trace client %d\n",c-mal_clients);
#endif
			if( flag) c->sysmon= mal_clients[0].fdout;
			else c->sysmon= NULL;
		}
}
void MCtraceAllClients(int flag){
	Client c;
	for(c = mal_clients; c < mal_clients+MAL_MAXCLIENTS; c++) 
		if( c->user != oid_nil ){
			if( flag) c->sysmon= mal_clients[0].fdout;
			else c->sysmon= NULL;
		}
}
@}
@+ Client input
Input to be processed is collected in a Client specific buffer.
It is filled by reading information from a stream, a terminal,
or by scheduling strings constructed internally. 
The latter involves removing any escape character needed to 
manipulate the string within the kernel.
The buffer space is automatically expanded to accommodate new 
information and the read pointers are adjusted.
@-
The input is read from a (blocked) stream and stored in the client record
input buffer. The storage area grows automatically upon need.
The origin of the input stream depends on the connectivity mode.

Most interactions should be regulated through the Mclient
front-end. This will also take care of buffering a request before
submission. This avoids a significant number of network interactions.

@{
@-
Each operation received from a front-end consists of at least one line.
To simplify misaligned communication with front-ends, we use different
prompts structures. [think, can we avoid acks]

@-
The default action is to read information from an ascii-stream
one line at a time. This is the preferred mode for reading
from terminal.
@-
The next statement block is to be read. Send a prompt to warn
the front-end to issue the request.
@= sendPrompt
	if(c->promptlength>=0) { 
		if (!isa_block_stream(c->fdout))
			stream_write(c->fdout,c->prompt,c->promptlength,1); 
		stream_flush(c->fdout);
	}
@c

int MCreadClient(Client c){
	bstream *in = c->fdin;

#ifdef MAL_CLIENT_DEBUG
	printf("# streamClient %d\n",c->user);
#endif

	while (in->pos < in->len && 
			(isspace((int)(in->buf[in->pos])) ||
			 in->buf[in->pos] == ';' || !in->buf[in->pos]))
		in->pos++;

	if (in->pos >= in->len) {
		ssize_t rd, sum = 0;
		assert(in->pos == in->len);

		if (in->eof || !isa_block_stream(in->s)) {
			@:sendPrompt@
			in->eof = 0;
		}
		while ((rd = bstream_next(in)) > 0 && !in->eof) {
			sum += rd;
			if (!in->mode)/* read one line at a time in line mode */
				break;
		}
		if (sum == 0 && in->eof && isa_block_stream(in->s)) {
			/* we hadn't seen the EOF before, so just try again
			   (this time with prompt) */
			return MCreadClient(c);
		}
#ifdef MAL_CLIENT_DEBUG
		printf("# simple stream received:");
#endif
	}
	if (in->pos >= in->len) {
		/* end of stream reached */
		if (c->bak) {
			MCpopClientInput(c);
			if( c->fdin == NULL)
				return 0;
			return MCreadClient(c);
		}
		return 0;
	}
	if( *CURRENT(c) == '<'){
		bstream *fdin;
		str nme= GDKstrdup(CURRENT(c)+1);
		str err;

		nme[strlen(CURRENT(c)+1)]=0;
		printf("# loading from file `%s`\n",nme);
		if ((err = malLoadScript(nme,&fdin)) != MAL_SUCCEED) {
			fprintf(stderr, "!%s\n", err);
			GDKfree(err);
			return 0;
		}
		GDKfree(nme);
		MCpushClientInput(c, fdin, c->listing, c->prompt);
		in->pos= in->len;
		return MCreadClient(c);
	} else 
	if( *CURRENT(c) == '?'){
		showHelp(c->nspace, CURRENT(c)+1, c->fdout);
		in->pos= in->len;
		return MCreadClient(c);
	} else {
#ifdef MAL_CLIENT_DEBUG
		printf("#finished\n");
#endif
		@:sysTrace(CURRENT(c))@
	}
	return 1;
}
@}
