@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
@' Copyright August 2008- MonetDB B.V.
@' All Rights Reserved.

@a M. Ivanova, M. Kersten, N. Nes
@f mal_recycle
@- The Recycler
Query optimization and processing in off-the-shelf database systems is often
still focussed on individual queries. The queries are analysed in isolation
and ran against a kernel regardless opportunities offered by concurrent or
previous invocations.

This approach is far from optimal and two directions to improve
are explored: materialized views and (partial) result-set reuse.
Materialized views are derived from query logs. They represent
common sub-queries, whose materialization improves
subsequent processing times.
Re-use of (partial) results is used in those cases where a
zooming-in or navigational application is at stake.

The Recycler module extends it with a middle out approach.
It exploits the materialize-all-intermediate approach of MonetDB
by deciding to keep a hold on them as long as deemed benificial.

The approach taken is to mark the instructions in a MAL program
using an optimizer call, such that their result is retained 
in a global recycle cache. A reference into the cache makes
is used to access the latest known version quickly.

Upon execution, the Recycler first checks for
an up to date result to be picked up at no cost,
other than matching the arguments.
Otherwise, it evaluates the instruction and calls upon
policy functions to decide if it is worthwhile to
keep.

The Recycler comes with a few policy controlling operators
to experiment with its effect in concrete settings.

Caveats:
Updates in general should immediately invalidate the cache lines depending on the updated Bats. These are all instructions directly operating on the updates, as well as all instructions consuming the result of the first.
@{
@-
The Recycler is a variation of the interpreter
which inspects the variable table for alternative results.

@h
#ifndef _MAL_RECYCLE_
#define _MAL_RECYCLE_

#include "mal.h"
#include "mal_exception.h"
#include "mal_instruction.h"
#include "mal_client.h"


/*
#define _DEBUG_RECYCLE_
#define _DEBUG_RECYCLE_REUSE
#define _DEBUG_CACHE_
*/

@-
We need some hard limits to not run out of datastructure
spaces.
@h
#define RU 1024 /* recycle unit in bytes */
#define GIGA (lng)(1024*1024*1024)

#define HARDLIMIT_VAR 100000		/* maximum variables to watch */
#define HARDLIMIT_STMT 20000		/* roughly 5/line needed */
#define HARDLIMIT_MEM 8 * (GIGA/RU)     /* avoid memory overflow */

mal_export int retainPolicy;
#define RETAIN_NONE	0
#define RETAIN_ALL 	1
#define RETAIN_CAT	2
#define RETAIN_INTEREST	3
#define RETAIN_ADAPT	4

#define REC_NO_INTEREST 0
#define REC_MAX_INTEREST 5
#define REC_MIN_INTEREST 1

mal_export lng recycleTime;		
mal_export lng recycleSearchTime;
mal_export lng recycleVolume;

mal_export int reusePolicy;
#define REUSE_NONE	0
#define REUSE_COVER	1
#define REUSE_EXACT	2

mal_export int rcachePolicy;
#define RCACHE_ALL		0
#define RCACHE_LRU		1
#define RCACHE_CREDIT 	2
#define RCACHE_CAT 	3

mal_export int recycleCacheLimit;
mal_export lng recycleMemory;	/* Units of memory permitted */
mal_export lng recyclerUsedMemory;
mal_export MT_Lock recycleLock;
mal_export MalBlkPtr recycleBlk;
mal_export double recycleAlpha;
mal_export double recycleFresh;
mal_export lng time0; /*start time of query */


mal_export int statements;	/* total number of statements executed */
mal_export int recycled;	/* total number of statements recycled */
mal_export int retained;	/* total number of statements retained */
mal_export int monitorRecycler;
mal_export int recycleRecent;

mal_export int recycleMiss;
mal_export int recycleRem;

@- Statistics about query patterns
@h
typedef struct QRYSTAT {
	str name;
	int calls; /* number of calls */
	int greuse; /* number of global reuse */
	int lreuse; /* number of local reuse in current execution only */
	MalBlkPtr mb; /* the largest number of reused instr. */
} QryStat, *QryStatPtr;

typedef struct QRYPATTERN {
	int cnt; /* number of query patterns */
	int sz;  /* storage capacity */
	QryStatPtr *ptrn; /* patterns */
} QryPat, *QryPatPtr;

mal_export QryPatPtr recycleQPat;
mal_export int recycleCurQ;

mal_export void RECYCLEinit(void);
mal_export int RECYCLEentry(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
mal_export void RECYCLEexit(Client cntxt,MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
mal_export void RECYCLEreset(Client cntxt,MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
mal_export void RECYCLEshutdown(Client cntxt);
mal_export int RECYCLEinterest(MalBlkPtr mb,InstrPtr p);
mal_export int RECYCLEnewQryStat(QryPatPtr qp, str nm, MalBlkPtr mb);
mal_export void RECYCLEinitQPat(int sz);
mal_export bte RECYCLEgetQryCat(int qidx);
mal_export bit isBindInstr(InstrPtr p);
#endif
@-
@c
#include "mal_config.h"
#include "mal_recycle.h"
#include "mal_exception.h"
#include "mal_interpreter.h"
#include "mal_function.h"
#include "mal_client.h"

MT_Lock recycleLock ;
MalBlkPtr recycleBlk = NULL;

static void RECYCLEexitImpl(Client cntxt,MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
@-
The retention policies currently implemented are:
RETAIN_ALL, where all results are in retained until
the hard resource limits are reached.
RETAIN_CAT, uses semantics of query category to decide about retainment.
If a query has been already executed several times (>3) and none of its
instructions have been reused, it is not kept in the cache.
RETAIN_ADAPT is an adaptive scheme, which monitors the cost
of scanning the recycler pool to derive the time high-water mark.
@c
int retainPolicy = RETAIN_ALL;  /* recycle retainment policy
			RETAIN_NONE: baseline, keeps stat, no retain, no reuse
			RETAIN_ALL: infinite case, retain all
			RETAIN_TIME: time-based semantics, retain if beneficial 
			RETAIN_SIZE: size cost model 
			RETAIN_VOL: volumetric cost model (time x size )
			RETAIN_ADAP: adaptive temporal */
lng recycleTime = 0;
lng recycleSearchTime = 0;	/* cache search time in ms*/
lng recycleVolume = 0;

int recycleMiss = 0;
int recycleRem = 0;


@-
REUSE_EXACT only looks at precisely matching instructions.
REUSE_COVER exploits potentional overlap in range selects
to reduce the amount of scanning.
@c
int reusePolicy = REUSE_NONE;	/* recycle reuse policy
			REUSE_NONE: baseline, keeps stat, no retain, no reuse
			REUSE_COVER: reuse smallest select covering 
			REUSE_EXACT: exact covering  */

@-
The recycler pool behaves as a cache and we may want to
limit its resource requirements. Either in terms of
a simple LRU scheme, which monitors touching the 
cache for update. The alternative is RCACHE_CREDIT,
which uses the volumetric cost in combination with their
reuse count to retain expensive instructions as long as possible.
The last policy keeps an eye on the total memory use of the
intermediates stored in the recycle pool.
If we run low on memory, we either deploy the LRU or
CREDIT algorithm to determine the victims.
@c
int rcachePolicy = RCACHE_LRU;  /* recycle cache management policy
			RCACHE_ALL: baseline, do nothing
			RCACHE_LRU: throw LRU by setting the limit
			RCACHE_CREDIT: credit-based LRU scheme
			RCACHE_MEMLRU: reduce the storage overhead 
			RCACHE_MEMCRD: reduce the storage overhead */
int recycleCacheLimit=0; /* No limit by default */
lng recycleMemory=0;	/* Units of memory permitted */
lng time0 = 0; /*start time of query */

@-
The profiler record is re-used to store recycler information.
The clk is used by the LRU scheme, counter is the number of
times this pattern was used, ticks is the clock ticks
used to produce the result. ibytes+obytes depict the storage
size of operands and result arguments.

The cost function is a weighted balance between cpu and
storage cost. Often there is a direct relationship,
@c
double recycleAlpha = 0.5;
double recycleFresh = 0.95; /* fresh instructions are protected from deletion */

#define recycleCost(X) recycleAlpha * recycleBlk->profiler[X].ticks/10.0 + (1-recycleAlpha)* (recycleBlk->profiler[X].ibytes+recycleBlk->profiler[X].obytes)/1000.0
#define recycleW(X)  ((recycleBlk->profiler[X].counter + 2) * (0.05 + (sht)recycleBlk->profiler[X].trace) / 3.0)
#define recycleCrd(X) (recycleCost(X)) * (recycleW(X))
#define recycleCrdCPU(X) (recycleBlk->profiler[X].ticks) * (recycleW(X))
#define getSrcMalBlk(p) recycleQPat->ptrn[(p)->recycle]->mb
#define setIPtr(q,i,cst,c) {	VALset(&cst,TYPE_int,&i);\
				c = defConstant(recycleBlk,TYPE_int, &cst); \
				q = pushArgument(recycleBlk,q,c); \
				setVarUsed(recycleBlk,c); }
#define getIPtr(p,r,j,pc) {	j = p->argv[p->argc-1];\
				pc = *(int*)getVarValue(recycleBlk,j); \
				r = getInstrPtr(getSrcMalBlk(p), pc); }


#ifdef _DEBUG_CACHE_
#define recycleSize recycleBlk->stop-recycleRem
#else
#define recycleSize recycleBlk->stop
#endif

@- Monitoring the Recycler
@c
lng recyclerUsedMemory = 0;
int statements = 0;	/* total number of statements executed */
int recycled = 0;	/* total number of statements recycled */
int retained = 0;	/* total number of statements retained */
int monitorRecycler = 0; /* 1: print cache stat after each RECYCLEnew call */
			 /* 2: print cache stat at the end of query */
int recycleRecent;     /* the most recent entry in cache touched by current query execution */

QryPatPtr recycleQPat = NULL;
int recycleCurQ = -1;    

void RECYCLEinitQPat(int sz)
{
	if (recycleQPat == NULL) {
		recycleQPat = (QryPatPtr) GDKzalloc(sizeof(QryPat));
		recycleQPat->ptrn = (QryStatPtr *) GDKzalloc(sz * sizeof(QryStatPtr));
		recycleQPat->sz = sz;
	}
}

static void extendQPat(QryPatPtr qp)
{
	int s, i;
	QryStatPtr *old = qp->ptrn;

	s = qp->sz * 2;
	qp->ptrn = (QryStatPtr *) GDKzalloc(s * sizeof(QryStatPtr));
	for( i=0; i< qp->cnt; i++)
		qp->ptrn[i] = old[i];
	qp->sz = s;
	GDKfree(old);
}

static int findQryStat(QryPatPtr qp, str nm)
{
	int i;
		
	for(i = 0; i< qp->cnt; i++)
		if (strcmp(qp->ptrn[i]->name, nm) == 0)
			return i;
	return -1;
}

int RECYCLEnewQryStat(QryPatPtr qp, str nm, MalBlkPtr mb)
{
	int idx;
	QryStatPtr qstat;
	
	if ((idx = findQryStat(qp,nm)) >= 0)
		qp->ptrn[idx]->calls++;
	else {
		qstat = (QryStatPtr) GDKzalloc(sizeof(QryStat));
		qstat->name = GDKstrdup(nm);
		qstat->calls = 1;
		qstat->mb = mb;
		if (qp->cnt == qp->sz) 
			extendQPat(qp);
		idx = qp->cnt++;
		qp->ptrn[idx] = qstat;
	}
	return idx;
}

static void updateQryStat(int qidx, bit gluse)
{	
	QryStatPtr qs;
	
	if (qidx >= recycleQPat->cnt){
		fprintf(stderr, "Query pattern %d does not exist\n",qidx);
		return;
	}		
	qs = recycleQPat->ptrn[qidx];
	if (gluse) 
		qs->greuse++;
	else qs->lreuse++;
}

@- Query categorization
Category 0: undefined, not enough statistics
Category 1: query with globally reused instructions (among different query invocations )
Category 2: query with only locally reused instructions (inside a single invocation )
Category 3: query without any reused instructions
For the purpose of query categorization binds are not considered as a commonality
@c
bte RECYCLEgetQryCat(int qidx)
{
	QryStatPtr qs;

	if (qidx <0 || qidx >= recycleQPat->cnt){
		fprintf(stderr, "Query pattern %d does not exist\n",qidx);
		return -1;
	}
	qs = recycleQPat->ptrn[qidx];
	if (qs->calls < 4) return 0;
	else if (qs->greuse >0) return 1;
	else if (qs->lreuse >0 ) return 2;
	else return 3;
}

static bte getInstrCat(InstrPtr p)
{
	return RECYCLEgetQryCat(p->recycle);
}

@-
The Recycle catalog is a global structure, which should be
protected with locks when updated.
The recycle statistics can be kept in the performance table
associated with the recycle MAL block without problems, because 
the block is never executed.
@c
static void RECYCLEspace()
{
	if (recycleBlk == NULL) {
		recycleBlk = newMalBlk(MAXVARS, STMT_INCREMENT);
		recycleBlk->profiler = (ProfPtr) GDKzalloc(
			recycleBlk->ssize*sizeof(ProfRecord));
	}
}

void RECYCLEinit(void){
	MT_init_lock(recycleLock,"recycleLock");
}

@-
The cache of recycled instructions can be kept low.
Once the cache is filled, we have to drop instructions
and associated variables. At the same time we should
invalidate the cache version, such that others can
re-synchronize.

For the recycle cache LRU scheme we mis-use a field in
the performance record.

Removal of instructions should be done with care.
First, there may be references kept around to 
variables in the recycle cache. They should be
invalidated.
Second, for each (BAT) variable removed, we
should also remove the dependent instructions.
@c
static void
RECYCLEgarbagecollect(MalBlkPtr mb, InstrPtr q, bte *used){
	int j;
	ValPtr v;

	for(j=0; j< q->argc; j++){
		v= &getVarConstant(mb,getArg(q,j));
		if(getArgType(mb,q,j)==TYPE_bat || isaBatType(getArgType(mb, q,j)) ){
			if( v->val.bval ){
				BBPdecref(ABS(v->val.bval), TRUE);
				if (!BBP_lrefs(v->val.bval)){ 
					v->vtype= TYPE_int;
					v->val.ival= 0; 
				}
			}
		}
		if( v->vtype == TYPE_str && used[getArg(q,j)]<=1) {
			if(v->val.sval) {
				GDKfree(v->val.sval);
				v->val.sval = NULL;
			}
			v->len = 0;
		}
	}
}

int chooseVictims(int *lvs, int ltop, lng wr)
{
	dbl *wcrd, maxwc, tmp, ci_crd, tot_crd;
	int l, newtop, mpos, tmpl, ci = 0;
	lng w, totmem = 0, targmem, smem;

#ifdef _DEBUG_CACHE_
        Client cntxt= MCgetClient();
#endif

	wcrd = (dbl *)alloca(sizeof(dbl)*ltop);
	memset(wcrd,0, sizeof(dbl)*ltop);
	for (l = 0; l < ltop; l++){
		w = recycleBlk->profiler[lvs[l]].obytes;
		wcrd[l] = w? recycleCrdCPU(lvs[l]) / w :0;
		totmem +=w; 
	} 
	if (totmem <= wr) /* all leaves need to be dropped */
		return ltop;

	/* reorder instructions on increasing weighted credit */
	/* knapsack: find a set with biggest wcrd fitting in totmem-wr.
	 They are most benefitial and can be saved from dropping */ 

	targmem = totmem - wr; /*sack volume */
	smem = 0; tot_crd = 0;
	for(newtop =ltop; newtop>0; newtop--){
		maxwc = 0; mpos = newtop-1;
		for(l = 0; l<newtop; l++){
			if ((lng) recycleBlk->profiler[lvs[l]].obytes > targmem - smem)
				wcrd[l] = -1;
			if (maxwc <= wcrd[l]){
				maxwc = wcrd[l];
				mpos = l;
			}
		}
		if ( maxwc ){
			smem += recycleBlk->profiler[lvs[mpos]].obytes;
			tmpl = lvs[mpos];
			lvs[mpos] = lvs[newtop-1];
			lvs[newtop-1] = tmpl;
			tmp = wcrd[mpos];
			wcrd[mpos] = wcrd[newtop-1];
			wcrd[newtop-1] = tmp;
			tot_crd += recycleCrdCPU(tmpl);
#ifdef _DEBUG_CACHE_
		        stream_printf(cntxt->fdout,"Don't drop instruction %d, credit %f\n" , tmpl,tmp);
#endif
		}
		else break;
	}
	ci_crd = 0;             /* find the critical item */
        for (l = 0; l < ltop; l++)
                if (recycleBlk->profiler[lvs[l]].obytes <= targmem &&
                        recycleCrdCPU(lvs[l]) > ci_crd){
                        ci = l;
                        ci_crd = recycleCrdCPU(lvs[l]);
        }

	if ( ci_crd > tot_crd ) { /* save the critical item instead */
		newtop = ltop - 1;
		tmpl = lvs[ci];
		lvs[ci] = lvs[newtop];
		lvs[newtop] = tmpl;
#ifdef _DEBUG_CACHE_
		stream_printf(cntxt->fdout,"Don't drop critical item : instruction %d, credit %f\n" ,tmpl,ci_crd);
#endif
	}
	return newtop;

}


static void RECYCLEcleanCache(lng wr0){
	int j,i,l,ltop,v,vtop;
	InstrPtr p,r;
	InstrPtr *old;
	bit  *lmask, *dmask;
	int k, *lvs, *vm;
	int limit, mem, idx, pc;
	int cont, reserve;
	lng wr;
	lng oldclk;
	dbl mincrd, crd;
	bte maxcat, cat, *used;
	lng memLimit = recycleMemory?recycleMemory:HARDLIMIT_MEM;
#ifdef _DEBUG_CACHE_
	Client cntxt= MCgetClient();
#endif

	if (!recycleBlk) 
		return;

newpass:
	cont = 0;	
	wr = wr0;
	used = (bte*)GDKzalloc(recycleBlk->vtop);

	/* set all used variables */
	for (i = 0; i < recycleBlk->stop; i++){
		p = recycleBlk->stmt[i];
#ifdef _DEBUG_CACHE_
                if ( p->token != NOOPsymbol )
#endif
		for( j = p->retc ; j< p->argc; j++)
			if (used[getArg(p,j)]<2)  used[getArg(p,j)]++;
	}

	/* find the leaves, ignore the most recent instruction */

	lmask = (bit*)GDKzalloc(recycleBlk->stop);
	ltop = 0; reserve = 0;
	for (i = 0; i < recycleBlk->stop; i++){
		p = recycleBlk->stmt[i];
#ifdef _DEBUG_CACHE_
                if ( p->token == NOOPsymbol ) continue;
#endif
		for( j = 0; j < p->retc ; j++)
			if (used[getArg(p,j)]) goto skip;
		if (i == recycleRecent){
			reserve = i;
			continue;
		}
		lmask[i] = 1;
		ltop++;
		skip:;
	}


	if (ltop == 0 ){  /* ensure at least 1 entry to evict */
		if (reserve){
			lmask[reserve] = 1;
			ltop++;
		}
		else {	GDKfree(lmask);
			return;
		}
	}
	lvs = (int *)GDKzalloc(sizeof(int)*ltop);
	l = 0;
	for (i = 0; i < recycleBlk->stop; i++)
		if (lmask[i]) lvs[l++] = i;
	GDKfree(lmask);

	/* find the oldest */
	oldclk = recycleBlk->profiler[lvs[0]].clk;
	idx = 0;
	for (l = 0; l < ltop; l++){
		k = lvs[l];
		if( recycleBlk->profiler[k].clk < oldclk){ 
			oldclk = recycleBlk->profiler[k].clk;
			idx = l;
		}
	}

	/* protect leaves from current query invocation */

	if ((rcachePolicy == RCACHE_CREDIT || rcachePolicy == RCACHE_CAT ) &&
		oldclk < time0) {	

#ifdef _DEBUG_CACHE_
			stream_printf(cntxt->fdout,"Fresh-protected "LLFMT"\n", time0);
      			stream_printf(cntxt->fdout,"All leaves:");
			for (l = 0; l < ltop; l++)
                		stream_printf(cntxt->fdout,"%3d("LLFMT") \t",
	                		lvs[l],recycleBlk->profiler[lvs[l]].clk);
			stream_printf(cntxt->fdout,"\n");
#endif			
		l = 0;
		for (j = 0; j < ltop; j++){
			if (recycleBlk->profiler[lvs[j]].clk < time0) 
				lvs[l++] = lvs[j];
		}
		ltop = l;
	}


#ifdef _DEBUG_CACHE_
        stream_printf(cntxt->fdout,"RECYCLEcleanCache: policy=%d mem="LLFMT" usedmem="LLFMT"\n",
                rcachePolicy,recycleMemory,recyclerUsedMemory);
	stream_printf(cntxt->fdout,"Target memory "LLFMT"KB Available "LLFMT"KB\n", wr,memLimit-recyclerUsedMemory);
        stream_printf(cntxt->fdout,"Candidates for eviction (# LRU\tTicks\tI\tO\tCnt\tWgt\tCrd)\n");
	for (l = 0; l < ltop; l++)
        	stream_printf(cntxt->fdout,"%3d "LLFMT"\t"LLFMT"\t"LLFMT"\t"LLFMT"\t%d\t%4.2f\t%5.3f\n",
                	lvs[l],recycleBlk->profiler[lvs[l]].clk,
	                recycleBlk->profiler[lvs[l]].ticks,
        	        recycleBlk->profiler[lvs[l]].ibytes,
                	recycleBlk->profiler[lvs[l]].obytes,
	                recycleBlk->profiler[lvs[l]].counter,
        	        recycleW(lvs[l]),
                	recycleCrd(lvs[l]));
#endif

	/* find entries to evict */
	mem = recyclerUsedMemory + wr > memLimit;
	vm = (int *)GDKzalloc(sizeof(int)*ltop);
	vtop = 0;

	if (!mem){	 /* evict 1 entry */
		switch(rcachePolicy){
			case RCACHE_ALL:
			case RCACHE_LRU:
				vm[vtop++] = lvs[idx];
				break;
			case RCACHE_CAT:
				maxcat = getInstrCat(getInstrPtr(recycleBlk,lvs[0]));
				idx = 0;
				for (l = 1; l < ltop; l++){
					cat = getInstrCat(getInstrPtr(recycleBlk,lvs[l]));
					if( cat > maxcat) {
						maxcat = cat;
						idx = l;
					}
				}
				if (maxcat >= 2) {
					vm[vtop++] = lvs[idx];
					break;
				}
				/* else max category is 1 or 0, all leaves are pot. reused:
				continue with credit policy to choose the cheapest to evict */

			case RCACHE_CREDIT:
				mincrd = recycleCrd(lvs[0]);
				idx = 0;
				for (l = 1; l < ltop; l++){
					k = lvs[l];
					crd = recycleCrd(k);
					if( crd < mincrd) {
						mincrd = crd;
						idx = l;
					}
				}
				vm[vtop++] = lvs[idx];
			}
	}	/* evict 1 entry */

	else { /* evict several to get enough mem */
		switch(rcachePolicy){
			case RCACHE_ALL:
			case RCACHE_LRU:
				vm[vtop++] = lvs[idx];
				wr -= recycleBlk->profiler[lvs[idx]].obytes;
				lvs[idx] = lvs[--ltop];
				while( ltop>0 && recyclerUsedMemory + wr > memLimit){
					idx = 0;
					oldclk = recycleBlk->profiler[lvs[0]].clk;
					for (l = 1; l < ltop; l++){
						k = lvs[l];
						if( recycleBlk->profiler[k].clk < oldclk){ 
							oldclk = recycleBlk->profiler[k].clk;
							idx = l;
						}
					}
					vm[vtop++] = lvs[idx];
					wr -= recycleBlk->profiler[lvs[idx]].obytes;
					lvs[idx] = lvs[--ltop];
				}
				break;

			case RCACHE_CAT:
				l = 0;
				while( l<ltop && recyclerUsedMemory + wr > memLimit){
					while( l<ltop && getInstrCat(getInstrPtr(recycleBlk,lvs[l])) < 2)
						l++;
					if ( l<ltop ) {
						vm[vtop++] = lvs[l];
						wr -= recycleBlk->profiler[lvs[l]].obytes;
						l++;
					}
				}
				/* if leaves from category 2 and 3 exist but are not sufficient 
				for wr memory, we start a new pass instead of evicting cat 0 and 1 */
	
				 if ( vtop )
					break;
				/* else all leaves are category 1 or 0, i.e. pot. reused:
				continue with credit policy to choose the cheapest to evict */

			case RCACHE_CREDIT:
				vtop = chooseVictims(lvs, ltop, recyclerUsedMemory + wr - memLimit);
				for (v = 0; v < vtop; v++){
					vm[v] = lvs[v];
					wr -= recycleBlk->profiler[lvs[v]].obytes;
				}
				break;
		}
	}

	/* check if a new pass of cache cleaning is needed */
	if (recyclerUsedMemory + wr > memLimit)
		cont = 1;

#ifdef _DEBUG_CACHE_
	stream_printf(cntxt->fdout,"\nEvicted %d instruction(s) \n ",vtop);
	for(v=0; v<vtop;v++){
		stream_printf(cntxt->fdout,"%d\t",vm[v]);
		printInstruction(cntxt->fdout,recycleBlk,0,recycleBlk->stmt[vm[v]], LIST_MAL_ALL);
	}
#endif

	GDKfree(lvs);
	/* drop victims in one pass */
	dmask = (bit *)GDKzalloc(recycleBlk->stop);
	for (v = 0; v < vtop; v++)
		dmask[vm[v]] = 1;
	GDKfree(vm);
	
#ifdef _DEBUG_CACHE_
	/* instructions are marked with NOOPsymbol in debug mode */
	(void) old;
	(void) limit;
	for (i = 0; i < recycleBlk->stop ; i++){
                p = getInstrPtr(recycleBlk,i);
                if( dmask[i] ) {
                        recyclerUsedMemory -= recycleBlk->profiler[i].obytes;
                        p->token = NOOPsymbol;
			recycleRem ++;
			if ( recycleBlk->profiler[i].counter >1) {
                                getIPtr(p,r,j,pc);
                                if (r && r->recycle <REC_MAX_INTEREST)
                                        r->recycle++;
                        }

                }
	}

#else
	old = recycleBlk->stmt;
	limit = recycleBlk->stop;
	newMalBlkStmt(recycleBlk,recycleBlk->ssize);

	k = 0;
	for (i = 0; i < limit ; i++){
		p = old[i];
		if( dmask[i] ) {
			RECYCLEgarbagecollect(recycleBlk,p,used);
			recyclerUsedMemory -= recycleBlk->profiler[i].obytes;
			if ( recycleBlk->profiler[i].counter >1) {
				getIPtr(p,r,j,pc);
				if (r && r->recycle <REC_MAX_INTEREST)
					r->recycle++;
			}
			freeInstruction(p);
		}
		else {
			pushInstruction(recycleBlk,p);
			recycleBlk->profiler[k++]= recycleBlk->profiler[i];
		}
	}

	GDKfree(old);
	GDKfree(used);
	/* remove all un-used variables as well */
	trimMalVariables(recycleBlk);
#endif
	GDKfree(dmask);
	if (cont) goto newpass;
}

@-
To avoid a polution of the recycle cache, we do not store any
intruction for which there is not function/command/pattern implementation.
Likewise, we avoid all simple constant assigments.
@c
int
RECYCLEinterest(MalBlkPtr mb, InstrPtr p){
	(void) mb;
	if (p->recycle == REC_NO_INTEREST || p->token== ASSIGNsymbol ) 
		return 0;
	return getFunctionId(p) != NULL;
}


bit 
isBindInstr(InstrPtr p)
{
	return (getModuleId(p)==getName("sql",3) &&
		(getName("bind",4)== getFunctionId(p) ||
		 getName("bind_idxbat",11) == getFunctionId(p)));
				
}

#ifdef _DEBUG_CACHE_
static void
RECYCLEsync(InstrPtr p)
{
        int i, j, k;
        InstrPtr q;
	ValPtr pa, qa;

        for (i=0; i<recycleBlk->stop; i++) {
                q = getInstrPtr(recycleBlk,i);
		if ( q->token != NOOPsymbol ) continue;
                if ((getFunctionId(p) != getFunctionId(q)) ||
			(p->argc != q->argc) ||
			(getModuleId(p) != getModuleId(q)))
                        continue;
                for (j=p->retc; j<p->argc; j++)
                        if( VALcmp( &getVarConstant(recycleBlk,getArg(p,j)),
				 &getVarConstant(recycleBlk,getArg(q,j))))
                                break;
                if (j == p->argc) {
			for(k=0; k< p->retc; k++){ 
				pa = &getVarConstant(recycleBlk,getArg(p,k));
		                qa = &getVarConstant(recycleBlk,getArg(q,k));
				if (qa->vtype == TYPE_bat)
		                        BBPdecref( *(int*)VALget(qa), TRUE);
				VALcopy(qa,pa);
				if (qa->vtype == TYPE_bat)
                                        BBPincref( *(int*)VALget(qa), TRUE);
			}
		}
	}
}
#endif

static void 
RECYCLEnew(Client cntxt, MalBlkPtr mb, MalStkPtr s, InstrPtr p, lng rd, lng wr)
{
	int i, j, c;
	ValRecord *v;
	ValRecord cst;
	InstrPtr q;
	lng memLimit;
	lng cacheLimit;
	
	RECYCLEspace();
	cacheLimit = recycleCacheLimit?recycleCacheLimit:HARDLIMIT_STMT;
	if ( recycleSize >= cacheLimit)
		return ; /* no more caching */
	memLimit = recycleMemory?recycleMemory:HARDLIMIT_MEM;
	if ( recyclerUsedMemory + wr > memLimit)
		return ; /* no more caching */
		
#ifdef _DEBUG_RECYCLE_
	stream_printf(cntxt->fdout,"RECYCLE keep ");
	printTraceCall( cntxt->fdout,mb, s, getPC(mb,p),LIST_MAL_ALL);
	stream_printf(cntxt->fdout,"Tolls %d\n",p->recycle);
#else
	(void) cntxt;
	(void) mb;
#endif
@-
The instruction is copied and the variables are
all assigned to the symbol table. This means the
link with their source disappears. We can later only
compare by value.
@c
	q = copyInstruction(p);
	for (i = 0; i< p->argc; i++) {
		j= getArg(p,i);
		v = &s->stk[j];
		VALcopy(&cst,v);
		c = fndConstant(recycleBlk, &cst, recycleBlk->vtop);
#ifdef _DEBUG_RECYCLE_
		printf("CONSTANT %s %d\n", getVarName(mb,j), c);
#endif
		if (c<0)
			c = defConstant(recycleBlk, v->vtype, &cst);
		if (v->vtype == TYPE_bat)
			BBPincref( *(int*)VALget(v), TRUE);
		setVarUsed(recycleBlk,c);
	 	setArg(q,i,c);
	}
#ifdef _DEBUG_RECYCLE_
	stream_printf(cntxt->fdout,"RECYCLE kept ");
	printInstruction( cntxt->fdout,recycleBlk, 0, q,LIST_MAL_ALL);
#endif
	if (p->recycle > REC_MIN_INTEREST)
		p->recycle--;
	i = getPC(mb,p);
	setIPtr(q,i,cst,c);
	q->recycle = recycleCurQ; 
		/* use the field to refer to the query-owner index in the query pattern table */
	pushInstruction(recycleBlk,q);
	i = recycleBlk->stop-1;
	recycleBlk->profiler[i].clk = GDKusec();
	recycleBlk->profiler[i].counter =1;
	recycleBlk->profiler[i].ticks = GDKusec()-s->clk;
	recycleBlk->profiler[i].ibytes = rd;
	recycleBlk->profiler[i].obytes = wr;
	recyclerUsedMemory += wr;
	if (monitorRecycler == 1 ) 
		fprintf(stderr, 
			"#memory="LLFMT", stop=%d, recycled=%d, retained=%d executed=%d \n",
			recyclerUsedMemory, recycleBlk->stop,
			recycled, retained, statements);
	retained++;
	recycleRecent = i;

#ifdef _DEBUG_CACHE_
	RECYCLEsync(q);
#endif	
}

@-
The generic wrappers for accessing the recycled instructions.
Before the interpreter loop is allowed to execute the instruction
we check the recycle table for available variables.

Searching for useful recycle instructions is the real challenge.
There are two major approaches. The first approach is to search
for an identical operation as the target under investigation and
reuse its result if possible.
The second approach uses the semantics of operations and 
replaces the arguments of the target to make it cheaper to execute.
For example, a previous result of a scan may be used instead
or it can be small compared to the target.

We should avoid adding the same operation twice, which
means it should be easy to find them in the first place.
Furthermore, we should only search for instructions if
we are dealing with a function call.
@c
static int
RECYCLEfind(Client cntxt, MalBlkPtr mb, MalStkPtr s, InstrPtr p)
{
	int i, j;
	InstrPtr q;
	lng clk = GDKusec();

	(void) mb;
	if( recycleBlk == 0)
		return -1;

#ifdef _DEBUG_RECYCLE_
	stream_printf(cntxt->fdout,"search\n");
	printInstruction(cntxt->fdout,mb,0,p, LIST_MAL_ALL);
#else 
	(void) cntxt;
#endif
	for (i=0; i<recycleBlk->stop; i++) {
		q = getInstrPtr(recycleBlk,i);
		if (
			(getFunctionId(p) != getFunctionId(q)) ||
			(p->argc != q->argc-1) ||
		   (getModuleId(p) != getModuleId(q)))
			continue;
		for (j=p->retc; j<p->argc; j++)
			if( VALcmp( &s->stk[getArg(p,j)], &getVarConstant(recycleBlk,getArg(q,j))))
				break;
		if (j == p->argc)
#ifdef _DEBUG_CACHE_
        		if ( q->token != NOOPsymbol )
#endif
			return i;
	}
#ifdef _DEBUG_RECYCLE_
	stream_printf(cntxt->fdout,"not found\n");
#endif
	recycleSearchTime = GDKusec()-clk;
	return -1;
}


#define boundcheck(flag,a) ((flag)?a<=0:a<0)
/* check if instruction p at the stack is a subset selection of the RP instruction q */

static int 
selectSubset(InstrPtr p, InstrPtr q, MalStkPtr s)
{
	int lcomp, rcomp, cover=0;
	bit li, hi, lip, hip;

	lcomp = VALcmp(&getVar(recycleBlk,getArg(q,2))->value,
			&s->stk[getArg(p,2)]);
	if ( p->argc == 3)
		rcomp = VALcmp( &s->stk[getArg(p,2)], 
			&getVar(recycleBlk,getArg(q,3))->value);
	else 
		rcomp = VALcmp( &s->stk[getArg(p,3)], 
			&getVar(recycleBlk,getArg(q,3))->value);
	switch (q->argc-1) {
		case 4:	cover = lcomp <=0 && rcomp <=0;
			break;
		case 6:
			li = *(bit*)getVarValue(recycleBlk,getArg(q,4));
			hi = *(bit*)getVarValue(recycleBlk,getArg(q,5));
			if (p->argc <=4)
				cover = boundcheck(li,lcomp) && boundcheck(hi,rcomp);
			else {
				lip = *(bit*)VALget(&s->stk[getArg(p,4)]);
				hip = *(bit*)VALget(&s->stk[getArg(p,5)]);
				cover = boundcheck(li || ~lip,lcomp) && boundcheck(hi || ~hip,rcomp);
			}
	}

	return cover;
}


static int
RECYCLEreuse(Client cntxt, MalBlkPtr mb, MalStkPtr s, InstrPtr p)
{
	int i, j, ridx, idx, pc = -1, evicted=0;
	bat bid= -1, nbid= -1;
	InstrPtr q, r;
	static str selectRef;
	bit gluse = FALSE;
	
	if (selectRef == 0) 
		selectRef= getName("select",6);

	if( recycleBlk == 0 || reusePolicy == 0)
		return -1;

	for (i = 0; i < recycleBlk->stop; i++){
		q = getInstrPtr(recycleBlk,i);

		if ((getFunctionId(p) != getFunctionId(q)) ||
		    (getModuleId(p) != getModuleId(q)))
			continue;

		switch(reusePolicy){
		case REUSE_NONE:
			/* 0: baseline, no reuse */
			break;
		case REUSE_COVER:
			/* 1: reuse smallest range covering */
			ridx= getArg(q,1);
			idx= getArg(p,1);
			if (q->argc-1 > 3 && getFunctionId(p) == selectRef &&
			    getVarConstant(recycleBlk, ridx).val.bval == s->stk[idx].val.bval &&
				BATatoms[getArgType(recycleBlk,q,2)].linear )

			{	
				/* Time to check for the inclusion constraint */
				if (selectSubset(p,q,s)){
					BAT *b1, *b2;
					nbid = getVarConstant(recycleBlk, getArg(q,0)).val.bval; 
					if( bid == -1){
						bid = nbid;
						pc = i;
#ifdef _DEBUG_RECYCLE_
	b1 = BBPquickdesc(bid, FALSE);
	stream_printf(cntxt->fdout,"counts A %d -> " BUNFMT " \n", bid, BATcount(b1));
#endif
					} else {
						b1 = BBPquickdesc(bid, FALSE);
						b2 = BBPquickdesc(nbid, FALSE);

#ifdef _DEBUG_RECYCLE_
	stream_printf(cntxt->fdout,"counts B %d -> " BUNFMT " %d -> " BUNFMT "\n", 
		bid, BATcount(b1), nbid, BATcount(b2));
#endif
						if (BATcount(b1) > BATcount(b2)){
							bid = nbid;
							pc = i;
						}
					}
#ifdef _DEBUG_RECYCLE_
	stream_printf(cntxt->fdout,"Inclusive range bid=%d ", bid);
	printInstruction(cntxt->fdout,recycleBlk,0,q, LIST_MAL_ALL);
#endif
				}
			}
		case REUSE_EXACT:
			/* 2: exact covering */
			if (p->argc > q->argc-1) continue;
			for (j = p->retc; j < p->argc; j++)
				if (VALcmp(&s->stk[getArg(p,j)], &getVarConstant(recycleBlk,getArg(q,j))))
					goto notfound;
#ifdef _DEBUG_CACHE_
		        if ( q->token == NOOPsymbol ){
                		evicted = 1;
				stream_printf(cntxt->fdout,"Miss of evicted instruction %d\n",i);
	                	goto notfound;
        		}
#endif
			
			/* found an exact match */
			/* get the results on the stack */
			for( j=0; j<p->retc; j++){
				VALcopy(&s->stk[getArg(p,j)],
					&getVarConstant(recycleBlk,getArg(q,j)) );
				if (s->stk[getArg(p,j)].vtype == TYPE_bat)
					BBPincref( s->stk[getArg(p,j)].val.bval , TRUE);
			}
			recycleBlk->profiler[i].counter++;
			if ( recycleBlk->profiler[i].clk < time0 )
		                gluse = recycleBlk->profiler[i].trace = TRUE;
			else { /*local use - return the toll */
                                getIPtr(q,r,j,pc);
                                if (r && r->recycle <REC_MAX_INTEREST)
                                        r->recycle++;
                        }
			recycleBlk->profiler[i].clk = GDKusec();
			recycled++;
			if (!isBindInstr(q)) updateQryStat(q->recycle,gluse);
			recycleRecent = i;
			return i;
			notfound: 
				continue;
		}
	}
@-
We have a candidate table from which we can draw a subsection.
We execute it in place and safe the result upon need.
@c
	if (bid >=0) {
		int k;
		i= getPC(mb,p);
#ifdef _DEBUG_RECYCLE_REUSE
	stream_printf(cntxt->fdout,"RECYCLEreuse subselect ");
	printInstruction(cntxt->fdout, recycleBlk, 0,getInstrPtr(recycleBlk,pc), LIST_MAL_ALL);

	stream_printf(cntxt->fdout,">>>");
	printTraceCall(cntxt->fdout, mb, s,i, LIST_MAL_ALL);
#endif
	        nbid = s->stk[getArg(p,1)].val.bval;
		s->stk[getArg(p,1)].val.bval = bid;
		BBPincref(bid, TRUE);
		/* make sure the garbage collector is not called */
		j=s->keepAlive ;
		s->keepAlive= TRUE;
		k= p->recycle;
		p->recycle= 0;
		(void) reenterMAL(cntxt,mb,i,i+1,s,0,0);
		p->recycle= k;
		/* restore the situation */
		s->keepAlive= j;
		s->stk[getArg(p,1)].val.bval = nbid;
		BBPdecref(bid, TRUE);
	        recycled++;
	        recycleBlk->profiler[pc].counter++;
        	if ( recycleBlk->profiler[pc].clk < time0 )
	            gluse = recycleBlk->profiler[pc].trace = TRUE;
		updateQryStat(getInstrPtr(recycleBlk,pc)->recycle,gluse);
	        recycleBlk->profiler[pc].clk = GDKusec();
		RECYCLEexit(cntxt, mb, s, p);
		return pc;
	}
#ifdef _DEBUG_CACHE_
	if ( evicted ) recycleMiss++;
#else
	(void) evicted;
#endif
	return pc;
}

int 
RECYCLEentry(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	int i=0;

	stk->clk= GDKusec();
	statements++;
	if ( recycleBlk == NULL )
		return 0;
    if ( !RECYCLEinterest(mb,p) )  /* don't scan RP for non-monitored instructions */
        return 0;
	i = RECYCLEreuse(cntxt,mb,stk,p) >= 0;
#ifdef _DEBUG_RECYCLE_
        stream_printf(cntxt->fdout,"Reuse %d for ",i);
        printInstruction(cntxt->fdout,mb,0,p, LIST_MAL_ALL);
#endif
	return i;
}

@-
The 'exit' instruction is called after the interpreter loop
itself and has to decide on the results obtained.
This is the place where we should call recycle optimization routines( admission policies).
It can use the timing information gathered from the previous call,
which is stored in the stack frame to avoid concurrency problems.
@c
void
RECYCLEexitImpl(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p){
	lng memLimit;
	lng cacheLimit;
	lng rd = getVolume(stk,p, 1)/ RU +1;
	lng wr = getVolume(stk,p, 0)/ RU +1;
	ValRecord *v;

	memLimit = recycleMemory?recycleMemory:HARDLIMIT_MEM;
	cacheLimit = recycleCacheLimit?recycleCacheLimit:HARDLIMIT_STMT;

	v = &stk->stk[getArg(p,0)]; /* don't count memory for persistent bats */
	if ((v->vtype == TYPE_bat) && (BBP_status( *(int*)VALget(v)) & BBPPERSISTENT))
		wr = 0;

	if ( wr > memLimit)
		return;
	if (recycleBlk){
		if ( recyclerUsedMemory +  wr > memLimit ||
	    		recycleSize >= cacheLimit )
			RECYCLEcleanCache(wr);
	}
	if ( RECYCLEinterest(mb,p))
	switch(retainPolicy) {
	case RETAIN_NONE:
		/* RETAIN_NONE: baseline, keeps stat, no retain, no reuse */
		break;
	case RETAIN_ALL:
		/* RETAIN_ALL: infinite case, retain all new instructions */
		if (RECYCLEfind(cntxt,mb,stk,p)<0 )
			(void) RECYCLEnew(cntxt,mb, stk, p, rd, wr);
		break;
	case RETAIN_CAT:
		/* RETAIN_CAT: query-category-based semantics, retain if evidences for reuse inside the same query*/
		if (RECYCLEgetQryCat(recycleCurQ)<3 && RECYCLEfind(cntxt,mb,stk,p)< 0)
			(void) RECYCLEnew(cntxt,mb, stk, p, rd, wr);
		break;
	case RETAIN_INTEREST:
		/* RETAIN_INTEREST: refinement per instruction, retain if evidences for previous reuse */
		if (p->recycle > REC_MIN_INTEREST && RECYCLEfind(cntxt,mb,stk,p)< 0)
			(void) RECYCLEnew(cntxt,mb, stk, p, rd, wr);
		break;
	case RETAIN_ADAPT:
		/* RETAIN_ADAPT: searching the cache may take too long? */
		if ( RECYCLEfind(cntxt,mb,stk,p)< 0){
			if (recycleSearchTime > recycleTime)
				RECYCLEcleanCache(wr);
			RECYCLEnew(cntxt,mb, stk, p, rd, wr);
		}
	}
}

void
RECYCLEexit(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p){
	mal_set_lock(recycleLock,"recycle");
	RECYCLEexitImpl(cntxt,mb,stk,p);
	mal_unset_lock(recycleLock,"recycle");
}

@-
At the end of session we should remove all
knowledge from the recycle cache.
@c
void
RECYCLEshutdown(Client cntxt){
	MalBlkPtr mb= recycleBlk;
	int i;
	bte *used;
	
	if( recycleBlk == NULL)
		return ;

#ifdef _DEBUG_RECYCLE_
	stream_printf(cntxt->fdout,"RECYCLE shutdown\n");
	printFunction(cntxt->fdout, recycleBlk,0,0);
	printStack(cntxt->fdout,mb,0);
#else
	(void) cntxt;
#endif

	used = (bte*)GDKzalloc(recycleBlk->vtop);
	mal_set_lock(recycleLock,"recycle");
	recycleBlk= NULL;
	recycled = statements = 0;
	recycleSearchTime = 0;
	recyclerUsedMemory = 0;
#ifdef _DEBUG_CACHE_
	recycleMiss = 0;
	recycleRem = 0;
#endif
	mal_unset_lock(recycleLock,"recycle");
	for (i=mb->stop-1; i>=0; i--)
		RECYCLEgarbagecollect(mb, getInstrPtr(mb,i),used);
	freeMalBlk(mb);
	GDKfree(used);
}

@-
Evict a bat from recycle cache, for instance if an update on it 
has been detected. 
@c
static void 
RECYCLEevict(Client cntxt, bat *bats, int btop){
	int i,j,k,pc,top = 0;
	int action = 1, upd = 0;
	int *dropped;
	InstrPtr p,r;
	bte *used;

	if( recycleBlk == NULL)
		return;

#ifdef _DEBUG_RECYCLE_ 
	stream_printf(cntxt->fdout,"RECYCLE evict\n");
	printFunction(cntxt->fdout, recycleBlk, 0,0);
#else
	(void) cntxt;
#endif

	dropped = (int *) GDKzalloc(sizeof(int)*recycleBlk->vtop);
	used = (bte*)GDKzalloc(recycleBlk->vtop);
	for( i=0; i<btop; i++)
		dropped[top++] = bats[i];
	for (i = 0; i < recycleBlk->stop; i++){
		p = recycleBlk->stmt[i];
#ifdef _DEBUG_CACHE_
                if ( p->token != NOOPsymbol )
#endif
		for( j = 0 ; j< p->argc; j++)
			if (used[getArg(p,j)]<2)  used[getArg(p,j)]++;
	}
	while (action){
		action= 0;
		for (i=0; i<recycleBlk->stop; i++){
			p = getInstrPtr(recycleBlk,i);
#ifdef _DEBUG_CACHE_
                        if ( p->token == NOOPsymbol ) continue;                    
#endif
			for (j=p->retc; j<p->argc; j++)
				if(getArgType(recycleBlk,p,j)==TYPE_bat || 
					isaBatType(getArgType(recycleBlk, p,j)) ){
					int nbid = getVarConstant(recycleBlk, getArg(p,j)).val.bval; 
					if (nbid == 0) continue;
					for (k=0; k<top; k++)
						if (dropped[k]== nbid)
							break;
					if (k < top) break;
			}
			if (j<p->argc){  /* delete instruction dependent on updated bat */
				for (j=0;j<p->retc; j++)  /* mark result bats as dropped */
				if(getArgType(recycleBlk,p,j)==TYPE_bat || 
					isaBatType(getArgType(recycleBlk, p,j)) )
					dropped[top++]= getVarConstant(recycleBlk, getArg(p,j)).val.bval; 
#ifdef _DEBUG_CACHE_
		        /* instructions are marked with NOOPsymbol in debug mode */
                        	recyclerUsedMemory -= recycleBlk->profiler[i].obytes;
	                        p->token = NOOPsymbol;
				recycleRem ++;
				if ( recycleBlk->profiler[i].counter >1) {
                                        getIPtr(p,r,j,pc);
                                        if (r && r->recycle <REC_MAX_INTEREST)
                                                r->recycle++;
                                }

#else
				RECYCLEgarbagecollect(recycleBlk, p, used);
				recyclerUsedMemory -= recycleBlk->profiler[i].obytes;
				if ( recycleBlk->profiler[i].counter >1) {
					getIPtr(p,r,j,pc);
					if (r && r->recycle <REC_MAX_INTEREST)
						r->recycle++;
				}
				removeInstruction(recycleBlk, p);
#endif
@-
we assume that the variables defined are only used later on in the recycle
cache. This can be enforced by never re-sorting it. Under this condition
we only have to make one step back in the look.
@c
				i--;
				action++;
				continue;
			}
		}
		if (action) upd++;
	}
	GDKfree(dropped);
	GDKfree(used);
	if (upd){
#ifndef _DEBUG_CACHE_
		trimMalVariables(recycleBlk);
#endif
	}
}

@-
Once we encounter an update we check and clean the recycle cache from 
instructions dependent on the updated bat.
@c
void RECYCLEreset(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	int i,j, btop=0;
	int *b;
	ValRecord *v;
	InstrPtr q;


#ifdef _DEBUG_RECYCLE_
	stream_printf(cntxt->fdout,"RECYCLE reset\n");
#else
	(void) cntxt;
#endif
	if( recycleBlk == NULL)
		return;
	b = (int *)GDKzalloc(sizeof(int)*recycleBlk->stop);

	if (p->argc == 2){
		if(getArgType(mb,p,1)==TYPE_bat || 
			isaBatType(getArgType(mb, p,1)) ){
 			v = &stk->stk[getArg(p,1)];
			if(v->vtype == TYPE_bat && v->val.bval )
				b[btop++] = v->val.bval;
		}

	} else if (p->argc > 2) {
		for (i=0; i<recycleBlk->stop; i++) {
			q = getInstrPtr(recycleBlk,i);
#ifdef _DEBUG_CACHE_
                        if ( q->token == NOOPsymbol ) continue;
#endif
			if (getName("bind",4)== getFunctionId(q) && getModuleId(q)==getName("sql",3)){
				for (j=p->retc; j<p->argc; j++)
					if( VALcmp( &stk->stk[getArg(p,j)], &getVarConstant(recycleBlk,getArg(q,j))))
					break;
				if (j == p->argc){
					v = &getVarConstant(recycleBlk,getArg(q,0));
					if( v->val.bval )
						b[btop++] = v->val.bval;
				}
			}
		}
	}
	if (btop){
		mal_set_lock(recycleLock,"recycle");
	        RECYCLEevict(cntxt,b,btop);
		mal_unset_lock(recycleLock,"recycle");
	}
	GDKfree(b);
}
@}
