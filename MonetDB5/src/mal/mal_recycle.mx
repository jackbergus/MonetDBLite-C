@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2008 CWI.
@' All Rights Reserved.

@a M. Ivanova, M. Kersten, N. Nes
@f mal_recycle
@- The Recycler
Query optimization and processing in off-the-shelf database systems is often
still focussed on individual queries. The queries are analysed in isolation
and ran against a kernel regardless opportunities offered by concurrent or
previous invocations.

This approach is far from optimal and two directions to improve
are explored: materialized views and (partial) result-set reuse.
Materialized views are derived from query logs. They represent
common sub-queries, whose materialization improves
subsequent processing times.
Re-use of (partial) results is used in those cases where a
zooming-in or navigational application is at stake.

The Recycler module extends it with a middle out approach.
It exploits the materialize-all-intermediate approach of MonetDB
by deciding to keep a hold on them as long as deemed benificial.

The approach taken is to mark the variables in a MAL program
using an optimizer call, such that their result is retained 
in a global recycle cache.
Instructions become subject to the Recycler if
at least one of its arguments is a BAT and all others are
either constants or variables already known in the Recycler.

Upon execution, the Recycler first checks for
an up to date result to be picked up at no cost.
Otherwise, it evaluates the instruction and calls upon
policy functions to decide if it is worthwhile to
keep.

The Recycler comes with a few policy controlling operators
to experiment with its effect in concrete settings.

@{
@-
The Recycler should be a variation of the interpreter
which inspects the variable table for alternative results.

@h
#ifndef _MAL_RECYCLE_
#define _MAL_RECYCLE_

#include "mal.h"
#include "mal_exception.h"
#include "mal_instruction.h"

/* #define _DEBUG_RECYCLE_
#define _DEBUG_RECYCLE_REUSE*/
@-
We need some hard limits to not run out of datastructure
spaces.
@h
#define RU 1024 /* recycle unit in bytes */
#define GIGA (lng)(1024*1024*1024)

#define HARDLIMIT_VAR 25000
#define HARDLIMIT_STMT 4000		/* roughly 5/line needed */
#define HARDLIMIT_MEM 8 * (GIGA/RU)     /* avoid memory overflow */

mal_export int recycleVersion;  /* version of recycle table */
mal_export int retainPolicy;
#define RETAIN_NONE	0
#define RETAIN_ALL 	1
#define RETAIN_TIME	2
#define RETAIN_SIZE	3
#define RETAIN_VOL	4
#define RETAIN_ADAPT	5

mal_export int recycleTime;		
mal_export int recycleVolume;

mal_export int reusePolicy;
#define REUSE_NONE	0
#define REUSE_COVER	1
#define REUSE_EXACT	2

mal_export int rcachePolicy;
#define RCACHE_ALL		0
#define RCACHE_LRU		1
#define RCACHE_CREDIT 	2
#define RCACHE_MEMLRU 	3
#define RCACHE_MEMCRD 	4

mal_export int monitorRecycler;

mal_export int recycleClaim;
mal_export int recycleCacheLimit;
mal_export lng recycleMemory;	/* Units of memory permitted */
mal_export MT_Lock recycleLock;
mal_export MalBlkPtr recycleBlk;
mal_export double recycleAlpha;

mal_export int statements;	/* total number of statemetns executed */
mal_export int recycled;	/* total number of statements recycled */
mal_export int savedTime;	/* sum of all recycled clk's */
mal_export int monitorRecycler;

mal_export void RECYCLEversion(MalBlkPtr mb);
mal_export int RECYCLEentry(MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
mal_export void RECYCLEexit(MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
mal_export void RECYCLEshutdown(void);
#endif
@-
@c
#include "mal_config.h"
#include "mal_recycle.h"
#include "mal_exception.h"
#include "mal_interpreter.h"
#include "mal_function.h"

MT_Lock recycleLock ;
int recycleVersion = 0;  /* version of recycle table */
MalBlkPtr recycleBlk = NULL;

@-
The retention policies currently implemented are:
RETAIN_ALL, where all results are in principle retained.
RETAIN_TIME, uses a highwater mark defined by the user.
All results whose time to produce are lower then the
highwater mark are dropped without further consideration.
RETAIN_SIZE, is similar and takes the volume (in RU units)
as a decision.
RETAIN_VOL is a volumetric model, which balances time and
volume using a user defined parameter RETAIN_ALPHA.
RETAIN_ADAP is an adaptive scheme, which monitors the cost
of scanning the recycler pool to derive the time high-water mark.
@c
int retainPolicy = RETAIN_ALL;  /* recycle retainment policy
			RETAIN_NONE: baseline, keeps stat, no retain, no reuse
			RETAIN_ALL: infinite case, retain all
			RETAIN_TIME: time-based semantics, retain if beneficial 
			RETAIN_SIZE: size cost model 
			RETAIN_VOL: volumetric cost model (time x size )
			RETAIN_ADAP: adaptive temporal */
int recycleTime = 0;	
int recycleVolume = 0;

@-
RETAIN_EXACT only looks at precisely matching instructions.
RETAIN_COVER exploits potentional overlap in range selects
to reduce the amount of scanning.
@c
int reusePolicy = REUSE_COVER;	/* recycle reuse policy
			REUSE_NONE: baseline, keeps stat, no retain, no reuse
			REUSE_COVER: reuse smallest select covering 
			REUSE_EXACT: exact covering  */

@-
The recycler pool behaves as a cache and we may want to
limit its resource requirements. Either in terms of
a simple LRU scheme, which monitors touching the 
cache for update. The alternative is RCACHE_CREDIT,
which uses the volumetric cost in combination with their
reuse count to retain expensive instructions as long as possible.
The last policy keeps an eye on the total memory use of the
intermediates stored in the recycle pool.
If we run low on memory, we either deploy the LRU or
CREDIT algorithm to determine the victims.
@c
int rcachePolicy = RCACHE_LRU;  /* recycle cache management policy
			RCACHE_ALL: baseline, do nothing
			RCACHE_LRU: throw LRU by setting the limit
			RCACHE_CREDIT: credit-based LRU scheme
			RCACHE_MEMLRU: reduce the storage overhead 
			RCACHE_MEMCRD: reduce the storage overhead */
int recycleCacheLimit= 1000;
int recycleClaim=0;	/* avoid stale tables by letting users mark it */
lng recycleMemory=0;	/* Units of memory permitted */
@-
The profiler record is re-used to store recycler information.
The clk is used by the LRU scheme, counter is the number of
times this pattern was used, ticks is the clock ticks
used to produce the result. ibytes+obytes depict the storage
size of operands and result arguments.

The cost function is a weighted balance between cpu and
storage cost. Often there is a direct relationship,
@c
double recycleAlpha = 0.5;

#define recycleCost(X) recycleAlpha * recycleBlk->profiler[X].ticks + (1-recycleAlpha)* (recycleBlk->profiler[X].ibytes+recycleBlk->profiler[X].obytes)

@- Monitoring the Recycler
@c
lng recyclerUsedMemory = 0;
int statements = 0;	/* total number of statemetns executed */
int recycled = 0;	/* total number of statements recycled */
int savedTime = 0;	/* sum of all recycled clk's */
int monitorRecycler = 0;

@-
The Recycle catalog is a global structure, which should be
protected with locks when updated.
The recycle statistics can be kept in the performance table
associated with the recycle MAL block without problems, because 
the block is never executed.
@c
static void RECYCLEspace()
{
	if (recycleBlk == NULL) {
		recycleBlk = newMalBlk(MAXVARS, STMT_INCREMENT);
		recycleBlk->profiler = (ProfPtr) GDKzalloc(
			recycleBlk->ssize*sizeof(ProfRecord));
	}
}

void RECYCLEversion(MalBlkPtr mb)
{
	int i;

	if( mb->version != recycleVersion) { 
		mal_set_lock(recycleLock,"recycle");
		/* all re-used variables are dropped */
		for(i=0; i<mb->vtop; i++)		/* reinit recycle */
			clrVarKept(mb,i);
		mb->version = recycleVersion;
		mal_unset_lock(recycleLock,"recycle");
	}	
}
@-
The cache of recycled instructions can be kept low.
Once the cache is filled, we have to drop instructions
and associated variables. At the same time we should
invalidate the cache version, such that others can
re-synchronize.

For the recycle cache LRU scheme we mis-use a field in
the performance record.

Removal of instructions should be done with care.
First, there may be references kept around to 
variables in the recycle cache. They should be
invalidated.
Second, for each (BAT) variable removed, we
should also remove the dependent instructions.
@c
static void RECYCLEremove(int pc){
	int k,j,i;
	InstrPtr p;
	InstrPtr *old;
	int limit;
	char *used;

	old = recycleBlk->stmt;
	limit = recycleBlk->stop;
	newMalBlkStmt(recycleBlk,recycleBlk->ssize);

	used= alloca(recycleBlk->vtop);
	memset(used,0, recycleBlk->vtop);

	/* set all used variables */
	for (i = 0; i < pc; i++){
		p= old[i];
		pushInstruction(recycleBlk,p);
		for( j = 0 ; j< p->argc; j++)
			used[getArg(p,j)] = 1;
	}

	/* ditch the selected one */
#ifdef _DEBUG_RECYCLE_
	stream_printf(GDKout,"RECYCLEremove %d \n",i);
	printInstruction(GDKout,recycleBlk, old[i], LIST_MAL_ALL);
#endif
	freeInstruction(old[i]);
	k= i;

	/* propagate the droppings */
	for (i ++; i < limit; i++){
		p= old[i];
		for( j = p->retc; j< p->argc; j++)
		if( used[getArg(p,j)] ==0){
#ifdef _DEBUG_RECYCLE_
			stream_printf(GDKout,"RECYCLEremove %d \n",i);
#endif
			freeInstruction(old[i]);
			goto skip;
		}
		pushInstruction(recycleBlk,p);
		recycleBlk->profiler[k++]= recycleBlk->profiler[i];
		/* the instruction args are safed */
		for( j = 0 ; j< p->argc; j++)
			used[getArg(p,j)] = 1;
	skip:;
	}
}

static lng lruclock=0;
static void 
RECYCLEcache(int target, int wr)
{
	int i, victim = 0, mem, size;
	InstrPtr pc;

	if (!recycleBlk) 
		return;
	mem = (recycleMemory && recyclerUsedMemory + wr > recycleMemory);
	size = (recycleCacheLimit && recycleBlk->stop + (target>0) > recycleCacheLimit);
	if (!mem && !size)
		return;

	if (target>=0)
		recycleBlk->profiler[target].clk= ++lruclock; /* most recently used */

	for(i=0; i< recycleBlk->stop; i++)
	if (i != target){
		switch(rcachePolicy){
		case RCACHE_LRU:
			if( recycleBlk->profiler[victim].clk >recycleBlk->profiler[i].clk)
				victim = i;
			break;
		case RCACHE_CREDIT:
			if (recycleBlk->profiler[victim].counter * recycleCost(victim) > recycleBlk->profiler[i].counter * recycleCost(i))
					victim = i;
			break;
		case RCACHE_MEMLRU:
			if (mem && recycleBlk->profiler[victim].clk >recycleBlk->profiler[i].clk)
				victim = i;
			break;
		case RCACHE_MEMCRD:
			if(mem && recycleBlk->profiler[victim].counter * recycleCost(victim) > recycleBlk->profiler[i].counter * recycleCost(i) )
				victim = i;
		}
	}

	if (victim!= target && (mem || (size && recycleClaim <= 1)) ){
#ifdef _DEBUG_RECYCLE_
		stream_printf(GDKout,"RECYCLE cache, remove %d \n",victim);
#endif
		mal_set_lock(recycleLock,"recycle");
		pc = getInstrPtr(recycleBlk,victim);
		for (i=0; i< pc->argc; i++)
			if( isaBatType(getVarType(recycleBlk, getArg(pc,i))))
				BBPdecref(getVarConstant(recycleBlk,i).val.bval,TRUE);
		recyclerUsedMemory -= recycleBlk->profiler[victim].obytes;
		RECYCLEremove(victim);
		trimMalVariables(recycleBlk);
		if (monitorRecycler)
			fprintf(stderr, 
				"#memory=%lld, stop=%d, recycled=%d(%d), saved=%d\n",
				recyclerUsedMemory, recycleBlk->stop,
				recycled, statements, savedTime);
		recycleVersion++;
		mal_unset_lock(recycleLock,"recycle");
	}
}

static int 
RECYCLEnew(MalBlkPtr mb, MalStkPtr s, InstrPtr p, int rd, int wr)
{
	int i, j, c;
	ValRecord *v;
	ValRecord cst;
	InstrPtr q;
	
	RECYCLEspace();
	if (recycleCacheLimit && recycleCacheLimit < recycleBlk->stop)
		return -1; /* no more caching */
	if (recycleBlk->vtop >= HARDLIMIT_VAR ||
	    recycleBlk->stop >= HARDLIMIT_STMT ||
	    recycleMemory > HARDLIMIT_MEM)
		return -1; /* no more caching */

	if( p->argc <=1 )	/* add more */
		return -1;
#ifdef _DEBUG_RECYCLE_
	stream_printf(GDKout,"RECYCLE new instruction \n");
	printInstruction(GDKout,mb,p,LIST_MAL_ALL);
#endif
	q = copyInstruction(p);
	for (i = 0; i< p->argc; i++) {
		j= getArg(p,i);
		v = &s->stk[j];
		VALcopy(&cst,v);
		c = defConstant(recycleBlk, v->vtype, &cst);
		if (v->vtype == TYPE_bat)
			BBPincref( *(int*)VALget(v), TRUE);
	 	setArg(q,i,c);
		if (i < p->retc) {
			mb->var[j]->recycle = c;
			if (isVarRecycled(mb, j)) 
				setVarKept(mb, j);
			setVarUsed(recycleBlk,c);
		}
	}
	i= recycleBlk->stop;
	pushInstruction(recycleBlk,q);
	recycleBlk->profiler[i].clk =0;
	recycleBlk->profiler[i].counter =1;
	recycleBlk->profiler[i].ticks = GDKusec()-s->clk;
	recycleBlk->profiler[i].ibytes = rd;
	recycleBlk->profiler[i].obytes = wr;
	recyclerUsedMemory += wr;
	if (monitorRecycler) 
		fprintf(stderr, 
			"#memory=%lld, stop=%d, recycled=%d(%d), saved=%d\n",
			recyclerUsedMemory, recycleBlk->stop,
			recycled, statements, savedTime);
#ifdef _DEBUG_RECYCLE_
	stream_printf(GDKout,"RECYCLE catalog \n");
	printFunction(GDKout,recycleBlk,LIST_MAL_ALL);
#endif
	return i;
}

@-
Searching for useful recycle instructions is the real challenge.
There are two major approaches. The first approach is to search
for an identical operation as the target under investigation and
reuse its result if possible.
The second approach uses the semantics of operations and 
replaces the arguments of the target to make it cheaper to execute.
For example, a previous result of a scan may be used instead
or it can be small compared to the target.

We should avoid adding the same operation twice, which
means it should be easy to find them in the first place.
@c
static int
RECYCLEfind(MalBlkPtr mb, MalStkPtr s, InstrPtr p)
{
	int i, j;
	InstrPtr q;

	(void) mb;
	if( recycleBlk == 0)
		return 0;

	for (i=0; i<recycleBlk->stop; i++) {
		q = getInstrPtr(recycleBlk,i);
		if ((p->argc != q->argc) ||
		   (getFunctionId(p) != getFunctionId(q)) ||
		   (getModuleId(p) != getModuleId(q)))
			continue;
		for (j=p->retc; j<p->argc; j++)
			if( VALcmp( &s->stk[getArg(p,j)], &getVar(recycleBlk,getArg(q,j))->value))
				break;
		if (j == q->argc)
			return i;
	}

#ifdef _DEBUG_RECYCLE_
		stream_printf(GDKout,"RECYCLEfind %d\n",i);
	printInstruction(GDKout, mb,p, LIST_MAL_ALL);
#endif
	return 0;
}

static int
RECYCLEreuse(MalBlkPtr mb, MalStkPtr s, InstrPtr p)
{
	int i, j, nbid, bid = -1, ridx, idx, pc = -1;
	InstrPtr q;
	static str selectRef;
	
	if (selectRef == 0) 
		selectRef= getName("select",6);

#ifdef _DEBUG_RECYCLE_REUSE
	stream_printf(GDKout,"RECYCLEreuse(_%d=%s.%s) policy %d recycleBlk %d\n",
		p->argv[0], getModuleId(p), getFunctionId(p), 
		reusePolicy, recycleBlk==0);
#endif
	if( recycleBlk == 0 || reusePolicy == 0)
		return -1;

	for (i = 0; i < recycleBlk->stop; i++){
		q = getInstrPtr(recycleBlk,i);
		if ((p->argc != q->argc) ||
		    (getFunctionId(p) != getFunctionId(q)) ||
		    (getModuleId(p) != getModuleId(q)))
			continue;

		switch(reusePolicy){
		case REUSE_NONE:
			/* 0: baseline, no reuse */
			break;
		case REUSE_COVER:
			/* 1: reuse smallest range covering */
			ridx= getArg(q,1);
			idx= getArg(p,1);
			if (q->argc == p->argc &&
			    getFunctionId(p) == selectRef   &&
			    getVarConstant(recycleBlk, ridx).val.bval == s->stk[idx].val.bval)
			{	
				/* Time to check for the inclusion constraint */
				int leftbound = VALcmp( &s->stk[getArg(p,2)], 
								&getVar(recycleBlk,getArg(q,2))->value) >=0;
				int rightbound = p->argc == 3 || 
						VALcmp( &s->stk[getArg(p,3)], 
								&getVar(recycleBlk,getArg(q,3))->value) <=0;

				if (p->argc == 6){
						/* inclusion bounds */
						leftbound &= VALcmp( &s->stk[getArg(p,4)], 
								&getVar(recycleBlk,getArg(q,4))->value)==0;
						rightbound &= VALcmp( &s->stk[getArg(p,5)], 
								&getVar(recycleBlk,getArg(q,5))->value)==0;
				}
				if (leftbound && rightbound){
					BAT *b1, *b2;
					nbid = getVarConstant(recycleBlk, getArg(q,0)).val.bval; 
					if( bid == -1){
						bid = nbid;
						pc = i;
#ifdef _DEBUG_RECYCLE_
	b1 = BBPquickdesc(bid, FALSE);
	stream_printf(GDKout,"counts A %d -> %d \n", bid, (int)BATcount(b1));
#endif
					} else {
						b1 = BBPquickdesc(bid, FALSE);
						b2 = BBPquickdesc(nbid, FALSE);

#ifdef _DEBUG_RECYCLE_
	stream_printf(GDKout,"counts B %d -> %d %d -> %d\n", 
		bid, (int)BATcount(b1), nbid, (int)BATcount(b2));
#endif
						if (BATcount(b1) > BATcount(b2)){
							bid = nbid;
							pc = i;
						}
					}
#ifdef _DEBUG_RECYCLE_
	stream_printf(GDKout,"Inclusive range bid=%d\n", bid);
	printInstruction(GDKout,recycleBlk,q, LIST_MAL_ALL);
#endif
				}
			}
		case REUSE_EXACT:
			/* 2: exact covering */
			for (j = p->retc; j < p->argc; j++){
				if ( VALcmp(&s->stk[getArg(p,j)], &getVarConstant(recycleBlk,getArg(q,j))))
					goto notfound;
			}
			/* found an exact match */
			/* get the results on the stack */
			for( j=0; j<q->retc; j++){
				VALcopy(&s->stk[getArg(p,j)],
					&getVarConstant(recycleBlk,getArg(q,j)) );
				if (s->stk[getArg(p,j)].vtype == TYPE_bat)
					BBPincref( s->stk[getArg(p,j)].val.bval , TRUE);
				getVar(mb,getArg(p,j))->recycle = getArg(q,j);
			}
			recycleBlk->profiler[i].counter++;
			savedTime += recycleBlk->profiler[i].ticks;
			return i;
			notfound: 
#ifdef _DEBUG_RECYCLE_REUSE
	stream_printf(GDKout,"RECYCLEreuse exact failed\n");
	printInstruction(GDKout, mb, q, LIST_MAL_ALL);
#endif
				continue;
		}
	}
@-
We have a candidate table from which we can draw a subsection.
We execute it in place and safe the result upon need.
@c
	if (bid >=0) {
		i= getPC(mb,p);
#ifdef _DEBUG_RECYCLE_REUSE
	stream_printf(GDKout,"RECYCLEreuse subselect %d\n",pc);
#endif
		s->stk[getArg(p,1)].val.bval = bid;
		BBPincref(bid, TRUE);
		/* make sure the garbage collector is not called */
		j=s->keepAlive ;
		s->keepAlive= TRUE;
		(void) reenterMAL(MCgetClient(),mb,i,i+1,s,0,0);
		/* RECYCLEexit(mb, s, p); */
		/* restore the situation */
		s->keepAlive= j;
		s->stk[getArg(p,1)].val.bval = nbid;
		BBPincref(nbid, TRUE);
		savedTime += recycleBlk->profiler[pc].ticks;
		recycleBlk->profiler[pc].counter++;
		return i;
	}
	return pc;
}
@-
The generic wrappers for accessing the recycle variables.
Before the interpreter loop is allowed to execute the instruction
we check the recycle table for available variables.

TODO remove the need for VAR_RECYCLE!
No, there is a distinction to keep a variable and actually doing it.
A variable marked RECYCLE and not KEPT, calls for a re-evaluation.
A few cases should be distinguished. Target variables that have not
been marked as VAR_RECYCLE are skipped. 

For those marked VAR_KEPT we are done after copying the value
onto the stack and return success.

Just looking at a kept result target is not good enough.
You have to sure that the arguments are also the same.
This outrules function arguments.
@c
int 
RECYCLEentry(MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	int i, cnt=0;
	ValPtr lhs,rhs;

	for(i=0;i< p->retc; i++) {
		if (isVarKept(mb, getArg(p,i)) && isVarRecycled(mb, getArg(p,i)) ){
			cnt++;
#ifdef _DEBUG_RECYCLE_
	stream_printf(GDKout,"RECYCLEentry found %d -> %d\n",getArg(p,i),
		mb->var[getArg(p,i)]->recycle);
	printInstruction(GDKout,mb,p, LIST_MAL_ALL);
#endif
			lhs= &stk->stk[getArg(p,i)];
			rhs= &getVarConstant(recycleBlk, mb->var[getArg(p,i)]->recycle);
			VALcopy(lhs,rhs);
			if( lhs->vtype == TYPE_bat)
				BBPincref(lhs->val.br.id, TRUE);
		} 
	}

	if (cnt != p->retc && (i = RECYCLEreuse(mb,stk,p)) >= 0 )
		cnt = p->retc;
	stk->clk= GDKusec();
	if ((recycleCacheLimit || recycleMemory) && i>=0)
		RECYCLEcache(i, 0);
	statements++;
	recycled += cnt==p->retc;
	return cnt == p->retc;
}

@-
The 'exit' instruction is called after the interpreter loop
itself and has to decide on the results obtaint.
This is the place where we should call recycle optimization routines.
It can use the timing information gathered from the previous call,
which is stored in the stack frame to avoid concurrency problems.
@c
void
RECYCLEexit(MalBlkPtr mb, MalStkPtr stk, InstrPtr p){
	static int exitLoop=0;
	lng clk = 0;
	int rd = getVolume(stk,p, 1)/ RU;
	int wr = getVolume(stk,p, 0)/ RU;

#ifdef _DEBUG_RECYCLE_
	stream_printf(GDKout,"RECYCLEexit policy %d \n",retainPolicy);
#endif
	clk= GDKusec()-stk->clk;

	while ((recycleMemory && recyclerUsedMemory + wr > recycleMemory))
		RECYCLEcache(-1, wr);
	switch(retainPolicy) {
	case RETAIN_NONE:
		/* RETAIN_NONE: baseline, keeps stat, no retain, no reuse */
		break;
	case RETAIN_ALL:
		/* RETAIN_ALL: infinite case, retain all new instructions */
		if (!RECYCLEfind(mb,stk,p) )
			(void) RECYCLEnew(mb, stk, p, rd, wr);
		break;
	case RETAIN_TIME:
		/* RETAIN_TIME: time-based semantics, retain if beneficial */
		if (clk > ABS(recycleTime) && !RECYCLEfind(mb,stk,p))
			(void) RECYCLEnew(mb, stk, p, rd, wr);
		break;
	case RETAIN_SIZE:
	{
		/* RETAIN_SIZE: size cost model */
		if (recycleVolume && !RECYCLEfind(mb,stk,p)){
			if (rd+wr > recycleVolume){
				(void) RECYCLEnew(mb, stk, p, rd, wr);
#ifdef _DEBUG_RECYCLE_
				stream_printf(GDKout,"RECYCLEexit size %d \n",rd+wr);
#endif
			}
		}
	}
	case RETAIN_VOL:
	{
		/* RETAIN_VOL: volumetric cost model (time x size )*/
		if (recycleVolume && !RECYCLEfind(mb,stk,p)){
			if (recycleAlpha *(rd+wr) + (1-recycleAlpha)* clk > recycleVolume * recycleTime){
				(void) RECYCLEnew(mb, stk, p, rd, wr);
#ifdef _DEBUG_RECYCLE_
				stream_printf(GDKout,"RECYCLEexit volume %d \n",(rd+wr)*clk);
#endif
			}
		}
	}
	case RETAIN_ADAPT:
		/* RETAIN_ADAPT: adaptive temporal */
		if (clk > recycleTime && !RECYCLEfind(mb,stk,p))
			(void) RECYCLEnew(mb, stk, p, rd, wr);
		/* adapt the time watermark based on observed behavior */
		if (recycleTime < 0 && (exitLoop++ % 99)== 0){
			clk= GDKusec();
			(void) RECYCLEfind(mb,stk,p);
			clk= GDKusec()-clk;
			if( clk > recycleTime){
#ifdef _DEBUG_RECYCLE_
				stream_printf(GDKout,"RECYCLEretain time %d adjusted\n", recycleTime);
#endif
				recycleTime = clk;
			}
		}
	}
}
@-
At the end of the session we should remove all
intermediate results forcefully. This only amounts
to resetting the reference counts of the persistent
tables, because all others are garbage collected automatically.
To simplify the code, we just drop all BAT reference counts by one.
@c
void
RECYCLEshutdown(void){
	InstrPtr q;
	int i,j;
	MalBlkPtr mb;
	
	if( recycleBlk == NULL)
		return ;

	mal_set_lock(recycleLock,"recycle");
	mb= recycleBlk;
	recycleBlk= NULL;
	mal_unset_lock(recycleLock,"recycle");

	for(i=0; i< mb->stop; i++){
		q= getInstrPtr(mb,i);
		for(j=0; j< q->argc; j++)
		if (isVarConstant(mb,getArg(q,j)) ){
			if( isaBatType(getArgType(mb, q,j)) )
				BBPdecref(getVarConstant(mb,getArg(q,j)).val.bval, TRUE);
		}
	}
	freeMalBlk(mb);
}
@}
