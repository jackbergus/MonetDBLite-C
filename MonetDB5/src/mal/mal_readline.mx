@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2005 CWI.
@' All Rights Reserved.
@-
@{
Add readline functionality to the MAL console.
This means that the user has history access and some other
features to assemble a command before it is being interpreted.
@h
#ifndef READLINETOOLS_H_INCLUDED
#define READLINETOOLS_H_INCLUDED

#include "mal_client.h"
mal_export int readConsole(Client cntxt);

#endif /* READLINETOOLS_H_INCLUDED */
@c
#include "mal.h"
#undef PATHLENGTH
#include "mal_client.h"
#include "mal_scenario.h"

#ifdef HAVE_LIBREADLINE

#include <readline/readline.h>
#include <readline/history.h>
#include "mal_readline.h"

void init_readline(void);
void deinit_readline(void);
rl_completion_func_t *suspend_completion(void);
void continue_completion(rl_completion_func_t * func);

#ifdef HAVE_STRINGS_H
#include <strings.h>		/* for strncasecmp */
#endif


static const char *mal_commands[] = {
	"address",
	"atom",
	"barrier",
	"catch",
	"command",
	"comment",
	"exit",
	"end",
	"function",
	"factory",
	"leave",
	"pattern",
	"module",
	"raise",
	"redo",
	0,
};

static char *
mal_command_generator(const char *text, int state)
{

	static int index, len;
	const char *name;

	if (!state) {
		index = 0;
		len = strlen(text);
	}


	while ((name = mal_commands[index++])) {
#ifdef HAVE_STRNCASECMP
		if (strncasecmp(name, text, len) == 0)
#else
		if (strncmp(name, text, len) == 0)
#endif
			return strdup(name);
	}
	return NULL;
}

static char **
mal_completion(const char *text, int start, int end)
{
	(void) start;
	(void) end;

	/* FIXME: Nice, context-sensitive completion strategy should go here */
	return rl_completion_matches(text, mal_command_generator);
}

rl_completion_func_t *
suspend_completion(void)
{
	rl_completion_func_t *func = rl_attempted_completion_function;

	rl_attempted_completion_function = NULL;
	return func;
}

void
continue_completion(rl_completion_func_t * func)
{
	rl_attempted_completion_function = func;
}

void
init_readline(void)
{
	str history = getClient()->history;

	/* Allow conditional parsing of the ~/.inputrc file. */
	rl_readline_name = "MonetDB";
	/* Tell the completer that we want to try our own completion before std completion (filename) kicks in. */
	rl_attempted_completion_function = mal_completion;
	read_history(history);
}

void
deinit_readline(void)
{
	str history = getClient()->history;
	if (history) {
		write_history(history);
	}
}

@-
@c
#ifndef S_ISCHR
#define S_ISCHR(m)  (((m) & S_IFMT) == S_IFCHR)
#endif

#ifdef HAVE_TERMIOS_H
#include <termios.h>
#endif

static void
showCommands(void)
{
    printf("?\t - show this message\n");
    printf("!\t - show the history\n");
    printf("<file\t - read input from file\n");
    printf(">file\t - save response in file\n");
    printf(">\t - response to terminal\n");
    printf("cd\t - change directory\n");
    printf("\\q\t- terminate session\n");
}

static int initReadline;

static char *
getConsoleInput(const char *prompt, int linemode, int exit_on_error)
{
	char *line = NULL;
	char *buf = NULL;
	size_t length;
	Client c;
	(void) exit_on_error;
	(void) linemode;

	do {
		if (prompt) {
			/* rl_completion_func_t *func = NULL;*/

			if (buf)
				free(buf);
			buf = readline(prompt);
			/* add a newline to the end since that makes
			   further processing easier */
			if (buf) {
				add_history(buf);
				length = strlen(buf);
				buf = realloc(buf, length + 2);
				buf[length++] = '\n';
				buf[length] = 0;
			}
			line = buf;
		} else
			line = fgets(buf, BUFSIZ, stdin);
		
		if (line == NULL) {
			/* end of file */
			return 0;
		} else
			length = strlen(line);

		if (length > 0 ) {
			/* test for special commands */
			while (length > 0 &&
			       (*line & ~0x7F) == 0 &&
			       isspace((int) *line)) {
				line++;
				length--;
			}
			/* in the switch, use continue if the line was
			   processed, use break to send to parser */
			switch (*line) {
			case '\0':
				/* empty line */
				break;
			case '\\':
				switch (line[1]) {
				case 'q':
					free(buf);
					return 0;
				default:
					break;
				}
				line= NULL;
				break;
			case '<':
				/* read commands from file */
				if (line[length - 1] == '\n')
					line[--length] = 0;
				if (line[length - 1] == '\r')
					line[--length] = 0;
				/* doFile(mid, line + 1, 0);*/
				line= NULL;
				continue;
			case '>':
				/* redirect output to file */
				line++;
				length--;
				if (line[length - 1] == '\n')
					line[--length] = 0;
				if (line[length - 1] == '\r')
					line[--length] = 0;

				c = getClient();
				if (c->fdout != GDKout && c->fdout != GDKerr)
					stream_close(c->fdout);
				if (length == 0 || strcmp(line, "stdout") == 0)
					c->fdout = GDKout;
				else if (strcmp(line, "stderr") == 0)
					c->fdout = GDKerr;
				else if ((c->fdout = open_wastream(line)) == NULL) {
					c->fdout = GDKout;
					stream_printf(GDKerr, "Cannot open %s\n", line);
				} 
				line = NULL;
				continue;
			case 'c':	/* cd command? */
				if (line[1] == 'd' &&
				    (line[2] & ~0x7F) == 0 &&
				    isspace((int) line[2])) {
					if (line[length - 1] == '\n')
						line[--length] = 0;
					if (line[length - 1] == '\r')
						line[--length] = 0;
					if (chdir(line + 3) < 0)
						perror(line);
					line = NULL;
					continue;
				}
				break;
			case '!':
				{ char *nl;
				  Client c= getClient();
				  int i;
					if(line[1]=='\n') {
						for(i=0; i< history_length; i++){
							nl= history_get(i)? history_get(i)->line:0;
							if( nl)
							stream_printf(c->fdout, "%d %s\n", i, nl);
						}
						line = NULL;
					} else
					if( history_expand(line,&nl) ==1  ) {
						stream_printf(c->fdout,"#%s",nl);
						line= nl;
					} else line= NULL;
				}
				continue;
			case '?':
				showCommands();
				line= NULL;
				continue;
			}
		}
	} while (line == NULL);
	return line;
}
int 
readConsole(Client cntxt){
	/* execute from stdin */
	struct stat statb;
	char *buf;

	if( cntxt->promptlength == 0)
		return -1;
	if( cntxt->fdin->s == cntxt->console->s){
		if ( !(fstat(fileno(stdin), &statb) == 0 && S_ISCHR(statb.st_mode))  )
			return -1;
	}

	/* read lines and move string to client buffer. */
	if( initReadline ==0){
		init_readline();
		using_history();
		stifle_history(1000);
		initReadline =1 ;
	}
	buf= getConsoleInput(cntxt->prompt, 0, 1);
	if( buf) {
		int len= strlen(buf);
		if( len >= cntxt->fdin->len) {
			free(cntxt->fdin->buf);
			cntxt->fdin->buf = malloc(len+2);
			cntxt->fdin->len = len+2;
		} 
		strcpy(cntxt->fdin->buf, buf);
		cntxt->fdin->pos = 0;
		return 1;
	} else {
		cntxt->fdin->eof = 1;
		if( initReadline ){
			deinit_readline();
			initReadline= 0;
		}
	}
	return -1;
}

#else

int 
readConsole(Client cntxt){
	return -1;
}
#endif /* HAVE_LIBREADLINE */
@}
