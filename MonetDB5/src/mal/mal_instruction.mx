@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2007 CWI.
@' All Rights Reserved.

@a M. Kersten
@v 1.0
@* MonetDB Assembly Language (MAL)
The primary textual interface to the Monetdb kernel
is a simple, assembly-like language, called MAL. 
The language reflects the virtual machine architecture around the
kernel libraries and has been designed for speed of parsing,
ease of analysis, and ease of target compilation by query compilers.
The language is not meant as a primary programming language,
or scripting language. Such use is even discouraged.

Furthermore, a MAL program is considered a specification
of intended computation and data flow behavior. It should be
understood that its actual evaluation depends on the execution
paradigm choosen in the scenario. The program blocks can both
be interpreted as ordered sequences of assembler instructions,
or as a representation of a data-flow graph that should be resolved
in a dataflow driven manner.
The language syntax uses a functional style definition of actions and
mark those that affect the flow explicitly.
Flow of control keywords identify a point to chance
the interpretation paradigm and denote a synchronization point.

MAL is the target language for query compilers, such as the
SQL and XQuery front-ends. 
Even simple SQL queries generate a long sequence of MAL instructions.
They represent both the administrative actions to ensure binding and transaction
control, the flow dependencies to produce the query result,
and the steps needed to prepare the result set for delivery to
the front-end.

Only when the algebraic structure is too limited (e.g. updates),
or the database back-end lacks feasible builtin bulk operators,
one has to rely on more detailed flow of control primitives.
But even in that case, the basic blocks to be processed
by a MAL back-end are considered large, e.g. tens of simple
bulk assignment instructions.

The remainder of this chapter provide a concise overview of the
language features and illustrative examples.
@menu
* MAL Literals::
* MAL Variables::
* MAL Instructions::
* MAL Flow-of-control::
* MAL Functions::
* MAL Factories::
* MAL Type System::
* Boxed variables::
* Property Management::
@end menu


@node MAL Literals, MAL Variables, MAL Reference,MAL Reference
@+ MAL Literals 
Literals in MAL follow the lexical conventions of the programming
language C.
A default type is attached, e.g. the literal 1 is typed
as an @sc{int} value.
Likewise, the literal 3.14 is typed @sc{flt} rather than @sc{dbl}.

A literal can be coerced to another type by tagging it with a type
classifier, provided a coercion operation is defined.
For example, @sc{1:lng} marks the literal as of type @sc{lng}.
and @sc{"1999-12-10":date} creates a @sc{date} literal.

MonetDB comes with the hardwired types @sc{bit, bte, chr, wrd, sht, int, lng, oid, flt, 
dbl, str} and @sc{bat}, the bat identifier.
The kernel code has been optimized to deal with these types efficiently,
i.e. without unnecessary function call overheads
In addition,  the system supports
temporal types @sc{date, daytime, time, timestamp, timezone},
extensions to deal with IPv4 addresses and URLs using @sc{inet, url},
and several types to interact more closely with the 
kernel @sc{lock, semphore}.
This list can be extended with user defined types.

@node MAL Variables, MAL Instructions, MAL Literals, MAL Reference
@+ MAL Variables
Variables are denoted by identifers and
implicitly defined upon first use. They take
on a type through a type classifier or inherit it from
the context in which they are first used, see @xref{MAL Type System}. 

Variables are organized into two classes, starting with and without
an underscore. The latter are reserved as MAL parser tempoaries, 
whose name aligns with an entry in the symbol table.
In general they can not be used in MAL programs, but they may become
visible in MAL program listings or during debugging.

@node MAL Instructions, MAL Flow-of-control, MAL Variables, MAL Reference
@+ Instructions
A MAL instruction has purposely a simple format. 
It is syntactically represented by an assignment, where
an expression (function call) delivers results to multiple target variables. 
The assignment patterns recognized are illustrated below.
@example
(t1,..,t32) := module.fcn(a1,..,a32);
t1 := module.fcn(a1,..,a32);
t1 := v1 operator v2;
t1 := literal;
(t1,..,tn) := (a1,..,an);
@end example

Operators are grouped into user defined modules.
Ommission of the module name is interpreter as the @sc{user} module.

Simple binary arithmetic operations are merely provided as a short-hand,
e.g. the expression @sc{t:=2+2} is converted directly 
into @sc{t:= calc.+(2,2)}.

Target variables are optional. The compiler introduces temporary 
variables to hold the result of the expression upon need. 
They won't show up when you list the MAL program unless it
is used elsewhere.

For parsing simplicity, each instruction fits on a single line.
Comments start with a sharp '#' and continues to the end of the line.
They are retained in the internal code representation to ease
debugging of compiler generated MAL programs.

The data structure to represent a MAL block is kept simple.
It carries a sequence of MAL statements and a symbol table.
The MAL instruction record is a code byte string overlaid with the
instruction pattern, which contains references into the symbol tables
and administrative data for the interpreter. 

This method leads to a large allocated block, which can be easily freed.
Variable- and statement- block together describe the
static part of a MAL procedure. It carries enough 
information to produce a listing and to aid symbolic debugging.

@node MAL Flow-of-control, MAL Functions, MAL Instructions, MAL Reference
@+ MAL Flow-of-control
The flow of control within a MAL program block can be changed by
tagging a statement with either @sc{return}, @sc{yield},
@sc{barrier}, @sc{catch}, @sc{leave}, @sc{redo}, or @sc{exit}.

The flow modifiers @sc{return} and @sc{yield} mark the end
of a call and return one or more results to the calling environment.
The @sc{return} and @sc{yield} are followed by a target list
or an assignment, which is executed first.

The @sc{barrier} (@sc{catch}) and @sc{exit} pair mark a
guarded statement block. They may be nested to form a proper
hierarchy identified by their primary target variable,
also called the control variable.

The @sc{leave} and @sc{redo} are conditional flow modifiers.
The control variable is used after the assignment statement has
been evaluated to decide on the flow-of-control action to be taken.
Built-in controls exists for booleans and numeric values.
The barrier block is opened when the control variable holds
true, when its numeric value >= 0, or when it is a non-empty
string. The @sc{nil} value blocks entry in all cases.

Once inside the barrier you have an option to prematurely
@sc{leave} it at the exit statement
or to @sc{redo} interpretation just after the corresponding
barrier statement. Much like 'break' and 'continue' statements
in the programming language C.
The action is taken when the condition is met.

The @sc{exit} marks the exit for a block. Its optional assignment
can be used to re-initialize the barrier control variables
or wrap-up any related administration.

The barrier blocks can be properly nested to form
a hierarchy of basic blocks.
The control flow within and between blocks is
simple enough to deal with during an optimizer stage.
The @sc{redo} and @sc{leave} statements mark
the partial end of a block. Statements within these
blocks can be re-arranged according to the data-flow
dependencies. The order of partial blocks can not
be changed that easily. It depends on the mutual
exclusion of the data flows within each partial block.

Common guarded blocks in imperative languages are
the for-loop and if-then-else constructs.
They can be simulated as follows.

Consider the statement @sc{for(i=1;i<10;i++) print(i)}.
The (optimized) MAL block to implement this becomes:
@example
     i:= 1;
barrier B:= i<10;
     io.print(i);
     i:= i+1;
redo B:= i<10;
exit B;
@end example

Translation of the statement @sc{if(i<1) print("ok"); else print("wrong");}
becomes:
@example
    i:=1;
barrier ifpart:= i<1;
    io.print("ok");
exit ifpart;
barrier elsepart:= i>=1;
    io.print("wrong");
exit elsepart;
@end example

Note that both guarded blocks can be interchanged without
affecting the outcome. Moreover, neither block would
have been entered if the variable happens to be assigned @sc{nil}.

The primitives are sufficient to model a wide variety of iterators,
whose pattern look like:
@example
barrier i:= M.newIterator(T);
    elm:= M.getElement(T,i);
    ...
    leave i:= M.noMoreElements(T);
    ...
    redo i:= M.hasMoreElements(T);
exit i:= M.exitIterator(T);
@end example
The semantics obeyed by the iterator implementations is as follows.
The redo expression updates the target variable @emph{ i} and control
proceeds at the first statement after the barrier when the
barrier is opened by @emph{ i}. If the barrier could not be
re-opened, execution proceeds with the first statement after
the redo.
Likewise, the leave control statement skips to the exit
when the control variable @emph{ i} shows a closed barrier block.
Otherwise, it continues with the next instruction.
Note, in both failed cases the control variable is
possibly changed.

A recurring situation is to iterate over the elements in
a BAT. This is supported by an iterator implementation for BATs
as follows:
@example
barrier (idx,hd,tl):= bat.newIterator(B);
    ...
    redo (idx,hd,tl):= bat.hasMoreElements(B);
exit (ids,hd,tl);
@end example
Where idx is an integer to denote the row in the BAT,
hd and tl denote values of the current element.
@{
@+ The MAL instruction records
The data structure to represent a MAL block is kept simple.
It carries a sequence of MAL statements and a variable table.
Each instruction contains references to elements in the
symbol table.

The MAL instruction is a code byte string overlaid with the
instruction pattern. This method leads to a large
allocated block, which can be easily freed, and
pattern makes it possible to accommodate a variable argument list.

Variable- and stmt- block together describe the
static part of a MAL procedure. It carries carry enough
information to produce
a listing and to aid symbolic debugging.

Ideally, the listing of a MAL program is identical to the source.
This costs some space, but will improve readability and permits
instruction sequences generated internally also to be kept
around as ASCII text for later inclusion.

WARNING. The way we lay out the instructions means that
you can prepare only one instruction at a time, because you don't
know how many arguments may be needed upfront.
[TODO, rather then breaking the original input into pieces,
it would be worthwhile to keep track of location of the
instruction in the source.]
@h
#ifndef _MAL_INSTR_H
#define _MAL_INSTR_H

#include "mal_type.h"
#include "mal_stack.h"
#include "mal_properties.h"

#define isaSignature(P)  ((P)->token >=COMMANDsymbol)

#ifdef MALprofiler
#ifdef HAVE_SYS_TIMES_H
# include <sys/times.h>
#endif
#endif

#define DEBUG_MAL_INSTR
#define MAXARG 9
#define STMT_INCREMENT 32
#define STMT_MAXIMUM  1<<16
#define MAXVARS 32

typedef struct SYMDEF {
	struct SYMDEF *peer;	/* where to look next */
	struct SYMDEF *skip;	/* skip to next different symbol */
	str name;
	int kind;
	struct MALBLK *def;	/* the details of the MAL fcn */
} *Symbol, SymRecord;

typedef struct VARRECORD {
	str name;		/* argname or lexical value repr */
	malType type;		/* internal type signature */
	int gdktype;		/* for backend */
	bit isaconstant;	/* value cannot change */
	bit isatypevar;		/* denotes a type variable */
	bit fixtype;		/* the type has been fixed */
	bit isudftype;		/* type defined in program */
	bit cleanup;		/* remove upon function return */
	bit isused;		/* in-out argument to function */
	int tmpindex;		/* temporary variable */
	short scope;		/* block id where it is declared */
	short depth;		/* ... depth in nesting */
	short beginLifespan, endLifespan, lastUpdate;	/* for optimizers */
	PropertySet props;	/* private list of (name,value) pairs */
	ValRecord value;
} *VarPtr, VarRecord;

/* type check status is kept around to improve type checking efficiency */
#define TYPE_ERROR      -1
#define TYPE_UNKNOWN            0
#define TYPE_DYNAMIC            1
#define TYPE_BIND           2
#define TYPE_RESOLVED              4

#define QUICKCLEANUP 1
#define GARBAGECONTROL 2

#define VARARGS 1	/* deal with variable arguments */
#define VARRETS 2

/* all functions return a string */
typedef str (*MALfcn) ();

typedef struct {
	bit token;		/* instruction type */
	bit barrier;		/* flow of control modifier takes:
				   BARRIER, LEAVE, REDO, EXIT, CATCH, RAISE*/
	bit typechk;		/* type check status */
	bit gc;			/* garbage control flags */
	bit polymorphic;	/* complex type analysis */
	bit varargs;		/* variable number of arguments or targets */
	MALfcn fcn;		/* resolved function address */
	struct MALBLK *blk;	/* resolved MAL function address */
	int jump;		/* controlflow program counter */
@-
The MAL instruction representation. The strings should not be garbage collected
upon destruction of the definition. They are part of the global namespace.
@h
	str modname;		/* module context */
	str fcnname;		/* function name */
	short argc, retc, maxarg;	/* total and result argument count */
	short argv[1];		/* at least one entry */
} *InstrPtr, InstrRecord;

@-
For performance analysis we keep track of the number of calls
and the total time spent while executing the instruction.
(See mal_profiler.mx)
The performance structures are separately administered, because
they are only used in limited curcumstances.
@h
typedef struct PERF {
#ifdef HAVE_TIMES
	struct tms timer;	/* timing information */
#endif
	time_t clock;		/* clock */
	lng clk;		/* microseconds clock */
	long counter;
	long ticks;		/* micro seconds spent */
	bit trace;		/* facilitate filter-based profiling */
	int	ibytes;		/* bytes read by an instruction */
	int obytes;		/* bytes written by an instruction */
} *ProfPtr, ProfRecord;

typedef struct MALBLK {
	str binding;		/* related C-function */
	str help;		/* supportive commentary */
	PropertySet props;	/* private */
	struct MALBLK *alternative;
	int vtop;		/* next free slot */
	int vsize;		/* size of variable arena */
	VarRecord **var;	/* Variable table */
	int stop;		/* next free slot */
	int ssize;		/* byte size of arena */
	InstrPtr *stmt;		/* Instruction location */
	int errors;		/* left over errors */
	int typefixed;		/* no undetermined instruction */
	int flowfixed;		/* all flow instructions are fixed */
	ProfPtr profiler;
	struct MALBLK *history;/* of optimizer actions */
} *MalBlkPtr, MalBlkRecord;

@-
Allocation of space assumes a rather exotic number of arguments.
Access to module and function name are cast in macros to prepare
for separate name space management.
@h
#define getModuleId(P)     (P)->modname
#define setModuleId(P,S)    (P)->modname= S
#define setModuleScope(P,S) {(P)->modname= (S)==NULL?NULL: (S)->name;}

#define getFunctionId(P)       (P)->fcnname
#define setFunctionId(P,S)  (P)->fcnname= S
#define garbageControl(P)   ((P)->gc & GARBAGECONTROL)
#define needsCleanup(P)   ((P)->gc & QUICKCLEANUP)

#define getInstrPtr(M,I)    (M)->stmt[I]
#define getSignature(S)     getInstrPtr((S)->def,0)
#define getFcnName(M)       getFunctionId(getInstrPtr(M,0))
#define getArgCount(M)      getInstrPtr(M,0)->argc
#define getModName(M)       getModuleId(getInstrPtr(M,0))
#define getPrgSize(M)       (M)->stop

#define getVar(M,I)     (M)->var[I]
#define getVarTmp(M,I)      (M)->var[I]->tmpindex
#define isConstant(M,I) ((M)->var[I]->isaconstant)
#define isTypeVar(M,I)  ((M)->var[I]->isatypevar)
#define isTmpVar(M,I)   (!(M)->var[I]->name || *(M)->var[I]->name == TMPMARKER)
#define getVarScope(M,I)   ((M)->var[I]->scope)
#define getVarProperties(M,I)   ((M)->var[I]->props)

#define getVarDepth(M,I)   ((M)->var[I]->depth)
#define isFixed(M,I)        ((M)->var[I]->fixtype)
#define freezeVarType(M,I) getVar(M,I)->isudftype = 1;
#define setFixed(M,I)       ((M)->var[I]->fixtype= 1)
#define setVarCleanup(M,I)     ((M)->var[I]->cleanup)
#define isVarGarbage(M,I)     ((M)->var[I]->cleanup)
#define setVarUsed(M,I,V)		((M)->var[I]->isused= V)
#define isVarUsed(M,I)		((M)->var[I]->isused)
#define getVarConstant(M,I)     ((M)->var[I]->value)
#define getVarType(M,I)     ((M)->var[I]->type)
#define getVarGDKType(M,I)      ((M)->var[I]->gdktype)

#define getLastUpdate(M,I)	((M)->var[I]->lastUpdate)
#define getEndLifespan(M,I)	((M)->var[I]->endLifespan)
#define getBeginLifespan(M,I)	((M)->var[I]->beginLifespan)

#define getDestVar(P)   (P)->argv[0]
#define setDestVar(P,X)   (P)->argv[0]  =X
#define setDestType(M,P,V)  setVarType((M),getDestVar(P),V)
#define getDestType(M,P)    destinationType((M),(P))
#define getArg(P,I) (P)->argv[I]
#define setArg(P,I,R) (P)->argv[I]= R
#define getArgName(M,P,I)   getVarName((M),(P)->argv[I])
#define getArgType(M,P,I)   getVarType((M),(P)->argv[I])

mal_export InstrPtr newInstruction(MalBlkPtr mb, int kind);
mal_export InstrPtr copyInstruction(InstrPtr p);
mal_export void oldmoveInstruction(InstrPtr dst, InstrPtr src);
mal_export void clrInstruction(InstrPtr p);
mal_export void freeInstruction(InstrPtr p);
mal_export void clrFunction(InstrPtr p);
mal_export Symbol newSymbol(str nme, int kind);
mal_export void freeSymbol(Symbol s);
mal_export void freeSymbolList(Symbol s);
mal_export void printSignature(stream *fd, Symbol s, int flg);

mal_export MalBlkPtr newMalBlk(int maxvars, int maxstmts);
mal_export void resetMalBlk(MalBlkPtr mb, int stop);
mal_export void newMalBlkStmt(MalBlkPtr mb, int maxstmts);
mal_export void prepareMalBlk(MalBlkPtr mb, str s);
mal_export void freeMalBlk(MalBlkPtr mb);
mal_export MalBlkPtr copyMalBlk(MalBlkPtr);
mal_export void addtoMalBlkHistory(MalBlkPtr mb);
mal_export void showMalBlkHistory(MalBlkPtr mb);
mal_export MalBlkPtr getMalBlkHistory(MalBlkPtr mb,int idx);
mal_export void expandMalBlk(MalBlkPtr mb, int lines);
mal_export void trimMalBlk(MalBlkPtr mb);
mal_export void moveInstruction(MalBlkPtr mb, int pc, int target);
mal_export void insertInstruction(MalBlkPtr mb, InstrPtr p, int pc);
mal_export void removeInstruction(MalBlkPtr mb, InstrPtr p);
mal_export void removeInstructionBlock(MalBlkPtr mb, int pc, int cnt);
mal_export str operatorName(int i);

mal_export int findVariable(MalBlkPtr mb, str name);
mal_export int findTmpVariable(MalBlkPtr mb, int type);
mal_export int findVariableLength(MalBlkPtr mb, str name, int len);
mal_export malType getType(MalBlkPtr mb, str nme);
mal_export str getArgDefault(MalBlkPtr mb, InstrPtr p, int idx);
mal_export str getVarName(MalBlkPtr mb, int i);
mal_export str getRefName(MalBlkPtr mb, int i);
mal_export int newVariable(MalBlkPtr mb, str name, malType type);
mal_export void renameVariable(MalBlkPtr mb, int i, str name);
mal_export void resetVarName(MalBlkPtr mb, int i);
mal_export void copyVariable(MalBlkPtr dst, MalBlkPtr src, VarPtr v);
mal_export void removeVariable(MalBlkPtr mb, int varid);
mal_export int newTmpVariable(MalBlkPtr mb, malType type);
mal_export int newTmpSink(MalBlkPtr mb, malType type);
mal_export int newTypeVariable(MalBlkPtr mb, malType type);
mal_export void delVariable(MalBlkPtr mb, int varid);
mal_export void freeVariable(MalBlkPtr mb, int varid);
mal_export void clearVariable(MalBlkPtr mb, int varid);
mal_export int cpyConstant(MalBlkPtr mb, VarPtr vr);
mal_export int defConstant(MalBlkPtr mb, int type, ValPtr cst);
mal_export int fndConstant(MalBlkPtr mb, ValPtr cst);
mal_export int convertConstant(malType type, ValPtr vr);

mal_export void pushInstruction(MalBlkPtr mb, InstrPtr p);
mal_export InstrPtr pushArgument(MalBlkPtr mb, InstrPtr p, int varid);
mal_export InstrPtr setArgument(MalBlkPtr mb, InstrPtr p, int idx, int varid);
mal_export InstrPtr pushReturn(MalBlkPtr mb, InstrPtr p, int varid);
mal_export InstrPtr pushArgumentId(MalBlkPtr mb, InstrPtr p, str name);
mal_export void delArgument(InstrPtr p, int varid);
mal_export void setVarType(MalBlkPtr mb, int i, int tpe);
mal_export void clrAllTypes(MalBlkPtr mb);
mal_export void setArgType(MalBlkPtr mb, InstrPtr p, int i, int tpe);
mal_export void setReturnArgument(InstrPtr p, int varid);
mal_export malType destinationType(MalBlkPtr mb, InstrPtr p);
mal_export void setPolymorphic(InstrPtr p, int tpe, int force);
mal_export void setVarProperty(MalBlkPtr mb, int i, str name, str op, ValPtr cst);
mal_export str fcnClass(InstrPtr p);
mal_export str fcnDefinition(MalBlkPtr mb, InstrPtr p, str s, int flg);
mal_export void printInstruction(stream *fd, MalBlkPtr mb, InstrPtr p, int flg);
mal_export str recognizedCall(MalBlkPtr mb, InstrPtr p, str s);
mal_export void promptInstruction(stream *fd, MalBlkPtr mb, InstrPtr p, int flg);
mal_export str instruction2str(MalBlkPtr mb, InstrPtr p, int hidden);
mal_export str function2str(MalBlkPtr mb, int flg);
mal_export void pushEndInstruction(MalBlkPtr mb);	/* used in src/mal/mal_parser.c */
/* Utility macros to inspect an instruction */
#define functionStart(X) ((X)->token == FUNCTIONsymbol || \
              (X)->token == COMMANDsymbol || \
              (X)->token == FACTORYsymbol )
#define functionExit(X)  ((X)->token == ENDsymbol)

#define blockStart(X)   ((X)->barrier && (((X)->barrier == BARRIERsymbol || \
             (X)->barrier == CATCHsymbol )))
#define blockExit(X) (X)->barrier == EXITsymbol
#define blockCntrl(X) ( (X)->barrier== LEAVEsymbol ||  \
             (X)->barrier== REDOsymbol || (X)->barrier== RETURNsymbol )

mal_export void strBeforeCall(ValPtr v, ValPtr bak);
mal_export void strAfterCall(ValPtr v, ValPtr bak);
mal_export void batBeforeCall(ValPtr v, ValPtr bak);
mal_export void batAfterCall(ValPtr v, ValPtr bak);
#endif /*  _MAL_INSTR_H */
@c
#include "mal_config.h"
#include "mal_instruction.h"
#include "mal_function.h"	/* for getPC() */
#include "mal_utils.h"
#include "mal_exception.h"

Symbol
newSymbol(str nme, int kind)
{
	Symbol cur;

	if (nme == NULL) {
		GDKfatal("@1:unexpected name (=null)\n");
	}
	cur = (Symbol) GDKzalloc(sizeof(SymRecord));
	if (cur == NULL) {
		GDKfatal("@1: cannot initialize scope\n");
	}
	cur->name = nme;
	cur->kind = kind;
	cur->peer = NULL;
	cur->def = newMalBlk(MAXVARS, STMT_INCREMENT);
	return cur;
}

void
freeSymbol(Symbol s)
{
	if (s == NULL)
		return;
	if (s->def) {
		freeMalBlk(s->def);
		s->def = NULL;
	}
	GDKfree(s);
}

void
freeSymbolList(Symbol s)
{
	Symbol t = s;

	while (s) {
		t = s->peer;
		s->peer = NULL;
		freeSymbol(s);
		s = t;
	}
}

void
newMalBlkStmt(MalBlkPtr mb, int maxstmts)
{
	InstrPtr *p;

	p = (InstrPtr *) GDKzalloc(sizeof(InstrPtr) * maxstmts);
	if (p == NULL)
		GDKfatal("newMalBlk:could not get instruction storage\n");
	mb->stmt = p;

	mb->stop = 0;
	mb->ssize = maxstmts;
}

MalBlkPtr
newMalBlk(int maxvars, int maxstmts)
{
	MalBlkPtr mb;
	VarPtr *v;

	v = (VarPtr *) GDKzalloc(sizeof(VarPtr) * maxvars);
	if (v == NULL)
		GDKfatal("newMalBlk:could not get variable storage\n");
	mb = (MalBlkPtr) GDKmalloc(sizeof(MalBlkRecord));
	if (mb == NULL)
		GDKfatal("newMalBlk:could not get storage\n");
	newMalBlkStmt(mb, maxstmts);

	mb->var = v;

	mb->vtop = 0;
	mb->vsize = maxvars;
	mb->help = mb->binding = NULL;
	mb->errors = 0;
	mb->props = NULL;
	mb->alternative = NULL;
	mb->history = NULL;
	mb->typefixed = 0;
	mb->flowfixed = 0;
	mb->profiler = NULL;
	return mb;
}

@-
The resetMalBlk code removes instructions, but without freeing
the space. This way the structure is prepared for re-use
@c
void
resetMalBlk(MalBlkPtr mb, int stop)
{
	mb->stop = stop;
}

@-
The freeMalBlk code is quite defensive. It is used to localize an
illegal re-use of a MAL blk.
@c
void
freeMalBlk(MalBlkPtr mb)
{
	int i;

	for (i = 0; i < mb->stop; i++) {
		freeInstruction(getInstrPtr(mb, i));
		mb->stmt[i] = NULL;
	}
	mb->stop = 0;
	for (i = 0; i < mb->vtop; i++)
		freeVariable(mb, i);
	mb->vtop = 0;
	GDKfree(mb->stmt);
	mb->stmt = 0;
	GDKfree(mb->var);
	mb->var = 0;

	if( mb->history)
		freeMalBlk(mb->history);
	if (mb->binding)
		GDKfree(mb->binding);
	mb->binding = 0;
	if (mb->help)
		GDKfree(mb->help);
	mb->help = 0;
	if (mb->props)
		GDKfree(mb->props);
	mb->props = NULL;
	if (mb->profiler)
		GDKfree(mb->profiler);
	mb->profiler = NULL;
	GDKfree(mb);
}

@-
The routine below should assure that all referenced structures
are private. The copying is memory conservative.
@c
MalBlkPtr
copyMalBlk(MalBlkPtr old)
{
	MalBlkPtr mb;
	int i;

	mb = (MalBlkPtr) GDKzalloc(sizeof(MalBlkRecord));
	if (mb == NULL)
		GDKfatal("newMalBlk:could not get storage\n");
	mb->props = old->props;
	mb->alternative = old->alternative;
	mb->history = NULL;
	mb->var = (VarPtr *) GDKmalloc(sizeof(VarPtr) * old->vsize);

	if (mb->var == NULL)
		GDKfatal("newMalBlk:could not get variable storage\n");
	mb->vsize = old->vsize;
	memcpy((char *) mb->var, old->var, sizeof(VarPtr) * old->vsize);

	mb->vtop = 0;
	for (i = 0; i < old->vtop; i++) {
		copyVariable(mb, old, getVar(old, i));
		mb->vtop++;
	}

	mb->stmt = (InstrPtr *) GDKzalloc(sizeof(InstrPtr) * old->ssize);

	if (mb->stmt == NULL)
		GDKfatal("newMalBlk:could not get instruction storage\n");

	mb->stop = old->stop;
	mb->ssize = old->ssize;
	assert(old->stop < old->ssize);
	for (i = 0; i < old->stop; i++)
		mb->stmt[i] = copyInstruction(old->stmt[i]);

	mb->help = old->help ? GDKstrdup(old->help) : NULL;
	mb->binding = old->binding ? GDKstrdup(old->binding) : NULL;
	mb->errors = old->errors;
	mb->typefixed = old->typefixed;
	mb->flowfixed = old->flowfixed;
	/* copy the properties as well */
	if (mb->props)
		mb->props = cpyPropertySet(old->props);
	mb->profiler = NULL;
	return mb;
}

void
addtoMalBlkHistory(MalBlkPtr mb){
	MalBlkPtr cpy;
	cpy= copyMalBlk(mb);
	cpy->alternative= NULL;
	cpy->history= mb->history;
	mb->history= cpy;
}
MalBlkPtr
getMalBlkHistory(MalBlkPtr mb, int idx){
	while( mb && idx-- > 0)
		mb= mb->history;
	return mb;
}
@-
The MalBlk structures potentially consume a lot a of space, because it
is not possible to precisely estimate the default sizes of the var and stmt
components. The routines below provide a mechanism to handle the issue.
The expandMalBlk routine takes the number of new-lines as a parameter
and guesses the size of variable and statement table.

Experience shows that trimming leads to memory fragmentation (140K lost
after server init) and is therefore turned off.
@c
void
trimexpand(MalBlkPtr mb, int varsize, int stmtsize)
{
	VarRecord **v;
	InstrPtr *stmt;
	int len;

	assert(varsize > 0 && stmtsize > 0);
	len = sizeof(ValPtr) * (mb->vtop + varsize);
	v = (VarRecord **) GDKzalloc(len);
	if (v == NULL)
		GDKfatal("newMalBlk:could not get variable storage\n");

	memcpy((str) v, (str) mb->var, sizeof(ValPtr) * mb->vtop);

	if (mb->var)
		GDKfree(mb->var);
	mb->var = v;

	mb->vsize = mb->vtop + varsize;

	len = sizeof(InstrPtr) * (mb->ssize + stmtsize);
	stmt = (InstrPtr *) GDKzalloc(len);

	if (stmt == NULL)
		GDKfatal("newMalBlk:could not get instruction storage\n");
	memcpy((str) stmt, (str) mb->stmt, sizeof(InstrPtr) * mb->stop);
	GDKfree(mb->stmt);
	mb->stmt = stmt;

	mb->ssize = mb->ssize + stmtsize;
	if (mb->profiler) {
		GDKfree(mb->profiler);
		mb->profiler = 0;
	}
}
void
expandMalBlk(MalBlkPtr mb, int lines)
{
	int newlines = (int) (lines * 1.1);

	if (newlines > mb->ssize || newlines > mb->vsize)
		trimexpand(mb, newlines, newlines);
}

void
trimMalBlk(MalBlkPtr mb)
{
	(void) mb;		/* fool the compiler */
	/* printf("safe %d %d\n",mb->vtop, (mb->vsize-mb->vtop)*sizeof(VarPtr));
	   trimexpand(mb,0); */
}

@-
Before compiling a large string, it makes sense to allocate approximately
enough space to keep the intermediate code. Otherwise, we end up with a
repeated extend on the MAL block, which really consumes a lot of memcpy
resources.
The average MAL string length could been derived from the
test cases. An error in the estimate is more expensive than
just counting the lines.

The MAL blocks act as instruction pools.
Using a resetMALblock makes the instructions available.
@c

void
prepareMalBlk(MalBlkPtr mb, str s)
{
	int cnt = 0;

	while(s){
		s= strchr(s,'\n');
		if(s) { s++; cnt++;}
	}
	expandMalBlk(mb, cnt);
}

InstrPtr
newInstruction(MalBlkPtr mb, int kind)
{
	InstrPtr p = NULL;
	int space;

	if (mb && mb->stop <mb->ssize) {
		p = mb->stmt[mb->stop];

		if (p && p->maxarg < MAXARG)
			p = NULL;
		mb->stmt[mb->stop] = NULL;
	}
	if (p == NULL) {
		space = (MAXARG - 1) * sizeof(int) + sizeof(InstrRecord);
		p = GDKmalloc(space);
		p->maxarg = MAXARG;
	}
	p->typechk = TYPE_UNKNOWN;
	setModuleId(p, NULL);
	setFunctionId(p, NULL);
	p->fcn = NULL;
	p->blk = NULL;
	p->polymorphic = 0;
	p->varargs = 0;
	p->argc = 1;
	p->retc = 1;
	p->argv[0] = -1;	/* watch out for direct use in variable table */
@-
Flow of control instructions are always marked as an assignment
with modifier
@c
	switch (kind) {
	case BARRIERsymbol:
	case REDOsymbol:
	case LEAVEsymbol:
	case EXITsymbol:
	case RETURNsymbol:
	case YIELDsymbol:
	case CATCHsymbol:
	case RAISEsymbol:
		p->token = ASSIGNsymbol;
		p->barrier = kind;
		break;
	default:
		p->token = kind;
		p->barrier = 0;
	}
	p->gc = 0;
	p->jump = 0;
	return p;
}

@- 
Copying an instruction is space conservative.
@c

InstrPtr
copyInstruction(InstrPtr p)
{
	InstrPtr new;
	new = (InstrPtr) GDKmalloc(sizeof(InstrRecord) + sizeof(int) * p->maxarg - 1);
	oldmoveInstruction(new, p);
	return new;
}

void
clrFunction(InstrPtr p)
{
	p->fcn = 0;
	setModuleId(p, NULL);
	setFunctionId(p, NULL);
}

void
clrInstruction(InstrPtr p)
{
	clrFunction(p);
	memset((char *) p, 0, sizeof(InstrRecord) + (p->argc - 1) * sizeof(int));
}

void
freeInstruction(InstrPtr p)
{
	assert(p != 0);
	GDKfree(p);
}

@-
Moving instructions around calls for care, because all dependent
information should also be updated.
@c
void
oldmoveInstruction(InstrPtr new, InstrPtr p)
{
	int space;

	space = sizeof(InstrRecord) + sizeof(int) * p->argc;
	memcpy((char *) new, (char *) p, space);
	setFunctionId(new, getFunctionId(p));
	setModuleId(new, getModuleId(p));
}

@-
Query optimizers walk their way through a MAL program block.
They require some primitives to move instructions around and
to remove superflous instructions.
The removal is based on the assumption that indeed the instruction
belonged to the block.
@c
void
removeInstruction(MalBlkPtr mb, InstrPtr p)
{
	int i;

	for (i = 0; i < mb->stop - 1; i++)
		if (mb->stmt[i] == p)
			break;

	if (i == mb->stop)
		return;

	for (; i < mb->stop - 1; i++)
		mb->stmt[i] = mb->stmt[i + 1];

	mb->stop--;
	mb->stmt[i] = p;

	/* freeInstruction(p); */
}

void
removeInstructionBlock(MalBlkPtr mb, int pc, int cnt)
{
	int i;
	InstrPtr p;

	for (i = pc; i < pc + cnt; i++) {
		p = getInstrPtr(mb, i);
		freeInstruction(p);
	}

	for (i = pc; i < mb->stop - cnt; i++)
		mb->stmt[i] = mb->stmt[i + cnt];

	mb->stop -= cnt;
	for (; i < mb->stop; i++)
		mb->stmt[i] = 0;
}

void
moveInstruction(MalBlkPtr mb, int pc, int target)
{
	InstrPtr p;
	int i;

	p = getInstrPtr(mb, pc);
	if (pc > target) {
		for (i = pc; i > target; i--)
			mb->stmt[i] = mb->stmt[i - 1];
		mb->stmt[i] = p;
	} else {
		for (i = target; i > pc; i--)
			mb->stmt[i] = mb->stmt[i - 1];
		mb->stmt[i] = p;
	}
}
void
insertInstruction(MalBlkPtr mb, InstrPtr p, int pc)
{
	pushInstruction(mb, p);	/* to ensure room */
	moveInstruction(mb, mb->stop - 1, pc);
}

@-
Beware that the first argument of a signature is reserved for the function
return type , which should be equal to the destination variable type.

VarRecords are allocated on the variable stack.
Their index is returned for future reference.
@-
Use the information that a variable is at least one character
wide and terminated by a null-byte.
This means that we can speed up search when the variables
differ in the first two characters

Furthermore, temporary variables are already assigned to a specific
position in the variable table. This information can only be used
under the assumption that the code base is not modified on the
fly. Then the expensive search is started anyway.
It also means that input which does not comply with the intended
location of a temporary variable should be flagged as an error.
@= chkTemporary
    if( isTmpName(name)){
		int j;
        i= atol(name+1);
        /* quick test validity*/
        if( i< mb->vtop && isTmpVar(mb,i) && getVarTmp(mb,i) == i)
            return i;
		for(j=0; j< mb->vtop; j++)
			if( getVarTmp(mb,j)== i && isTmpVar(mb,j)) return j;
        return -1;
    }
@-
Temporary names are not materialized as strings unless necessary.
@c
INLINE str
getVarName(MalBlkPtr mb, int i)
{
	str nme;
	char buf[PATHLENGTH];

	nme = mb->var[i]->name;

	if (nme == 0) {
		snprintf(buf, PATHLENGTH, "%c%d", TMPMARKER, mb->var[i]->tmpindex);
		nme = mb->var[i]->name = GDKstrdup(buf);
	}
	return nme;
}

INLINE void
resetVarName(MalBlkPtr mb, int i){
	str nme;
	char buf[PATHLENGTH];

	nme = mb->var[i]->name;
	if( mb->var[i]->tmpindex && nme){
		GDKfree(nme);
		nme= 0;
	}

	if (nme == 0) {
		snprintf(buf, PATHLENGTH, "%c%d", TMPMARKER, mb->var[i]->tmpindex);
		mb->var[i]->name = GDKstrdup(buf);
	} 
}

INLINE str
getRefName(MalBlkPtr mb, int i)
{
	str nme;
	char buf[PATHLENGTH];

	nme = mb->var[i]->name;

	if (nme == 0) {
		snprintf(buf, PATHLENGTH, "%c%d", REFMARKER, mb->var[i]->tmpindex);
		nme = mb->var[i]->name = GDKstrdup(buf);
	}
	return nme;
}

@c
int
findVariable(MalBlkPtr mb, str name)
{
	int i;

	@:chkTemporary@
	if (name == NULL)
		return -1;
	for (i = mb->vtop - 1; i >= 0; i--)
		if (!isTmpVar(mb, i) && idcmp(name, getVarName(mb, i)) == 0)
			return i;
	return -1;
}

int
findTmpVariable(MalBlkPtr mb, int type)
{
	int i;

	for (i = 0; i < mb->vtop; i++)
		if (isTmpVar(mb, i) && getVarType(mb, i) == type)
			return i;
	return -1;
}

@-
The second version of findVariable assumes you have not
yet allocated a private structure. This is particularly
usefull during parsing, because most variables are already
defined. This way we safe GDKmalloc/GDKfree.
@c
int
findVariableLength(MalBlkPtr mb, str name, int len)
{
	int i;
	int j;

	for (i = mb->vtop - 1; i >= 0; i--)
		if (mb->var[i]->name && !isTmpVar(mb, i)) {
			str s = mb->var[i]->name;

			j = 0;
			if (s)
				for (j = 0; j < len; j++)
					if (name[j] != s[j])
						break;
			if (j == len && s && s[j] == 0)
				return i;
		}
	/* most variables are not temporary */
	@:chkTemporary@
	return -1;
}

@-
Note that getType also checks for type names directly.
They have preference over variable names.
@c
malType
getType(MalBlkPtr mb, str nme)
{
	int i;

	i = findVariable(mb, nme);
	if (i < 0)
		return getTypeIndex(nme, -1, TYPE_any);
	if (i >= 0)
		return getVarType(mb, i);
	return TYPE_any;
}

str
getArgDefault(MalBlkPtr mb, InstrPtr p, int idx)
{
	ValPtr v = &getVarConstant(mb, getArg(p, idx));

	if (v->vtype == TYPE_str)
		return v->val.sval;
	return NULL;
}

@-
All variables are implicitly declared upon their first assignment.

Lexical constants require some care. They typically appear as arguments
in operator/function calls. To simplify program analysis later on,
we stick to the situation that function/operator arguments are always
references to by variables.
@- Reserved words
Although MAL has been designed as a minimal language, several
identifiers are not eligible as variables. The encoding below
is geared at simple and speed.
@c
int
isReserved(str nme)
{
	switch (*nme) {
	case 'A':
	case 'a':
		if (idcmp("atom", nme) == 0)
			return 1;
		break;
	case 'B':
	case 'b':
		if (idcmp("barrier", nme) == 0)
			return 1;
		break;
	case 'C':
	case 'c':
		if (idcmp("command", nme) == 0)
			return 1;
		break;
	case 'E':
	case 'e':
		if (idcmp("exit", nme) == 0)
			return 1;
		if (idcmp("end", nme) == 0)
			return 1;
		break;
	case 'F':
	case 'f':
		if (idcmp("false", nme) == 0)
			return 1;
		if (idcmp("function", nme) == 0)
			return 1;
		if (idcmp("factory", nme) == 0)
			return 1;
		break;
	case 'I':
	case 'i':
		if (idcmp("include", nme) == 0)
			return 1;
		break;
	case 'M':
	case 'm':
		if (idcmp("module", nme) == 0)
			return 1;
		if (idcmp("macro", nme) == 0)
			return 1;
		break;
	case 'O':
	case 'o':
		if (idcmp("orcam", nme) == 0)
			return 1;
		break;
	case 'P':
	case 'p':
		if (idcmp("pattern", nme) == 0)
			return 1;
		break;
	case 'T':
	case 't':
		if (idcmp("thread", nme) == 0)
			return 1;
		if (idcmp("true", nme) == 0)
			return 1;
		break;
	}
	return 0;
}

@-
Beware, the symbol table structure assumes that it is relatively
cheap to perform a linear search to a variable or constant.

@= makeVarSpace
	if( mb->vtop >= (1<<15)-2 ){
		mb->vtop = (1<<15)-2 ;
		GDKerror("newVariable: too many variables\n");
	} else
	if( mb->vtop >= mb->vsize){
		VarPtr *new;
        int s= mb->vtop + MAXVARS;

		if (mb->vtop >mb->vsize)
			GDKfatal("newVariable:variable administration\n");

        new= (VarPtr *) GDKzalloc(s * sizeof(VarPtr));
        /*printf("generate new variable block %d\n",s);*/
        if( new== NULL ){
            mb->errors++;
            showScriptException(mb,0,MAL,"newMalBlk:no storage left\n");
            return mb->vtop;
        }
        memcpy((char*)new, (char*)mb->var, sizeof(VarPtr) * mb->vtop);
        GDKfree((str)mb->var);
        mb->vsize= s;
        mb->var= new;
        mb->var[mb->vtop-1]->gdktype= TYPE_void;
    }
@c
int
newVariable(MalBlkPtr mb, str name, malType type)
{
	int n;

	@:makeVarSpace@
	if (isTmpName(name)) {
		int i = atol(name + 1);

		/* test validity */
		if (i > mb->vtop) {
			showScriptException(mb,0,MAL,
				"newVariable:variable %s mis-aligned\n", name);
			mb->errors++;
		} else if (i < mb->vtop ) {
			showScriptException(mb,0,MAL,
				"'%s' overwrites %s\n", name, getVarName(mb, i));
			mb->errors++;
		}
	}
	n = mb->vtop;
	getVar(mb, n) = (VarPtr) GDKzalloc(sizeof(VarRecord));
	mb->var[n]->name = name;
	mb->var[n]->props = NULL;

	setVarType(mb, n, type);
	isConstant(mb, n) = 0;
	setVarCleanup(mb, n) = FALSE;
	getVar(mb, n)->isudftype = 0;
	getVar(mb, n)->isused = 0;
	mb->vtop++;
	return n;
}

void
renameVariable(MalBlkPtr mb, int id, str name)
{
	VarPtr v;
	assert(id >=0 && id <mb->vtop);
	v = getVar(mb, id);

	if (v->name)
		GDKfree(v->name);
	v->name = name;
	v->tmpindex = 0;
}

@+ MAL variables
Temporary target variable act as sinks in the data flow graph.
In this case, an optimizer can group them by underlying type and this way
reduce the symbol table size significantly.

MAL variables are internally represented by their index into
the variable stack. Their default textual representation is '_'<digits>.
Temporary names  are recognized by the parser and an error is
produced if it does not satisfy this condition.

Sharing of the temporary is only permitted if the type
is a priory known and not TYPE_any.
@c
int
newTmpVariable(MalBlkPtr mb, malType type)
{
	int n;

	@:makeVarSpace@
	n = mb->vtop;
	if (getVar(mb, n) == NULL)
		getVar(mb, n) = (VarPtr) GDKzalloc(sizeof(VarRecord));
/* already captured by memset
    mb->var[n]->name = 0;
    mb->var[n]->props = NULL;
    isConstant(mb,n) = 0;
    setVarCleanup(mb,n) = FALSE;
	getVar(mb,n)->isudftype= 0;
	getVar(mb,n)->isused= 0;
*/
	getVarTmp(mb, n) = n;
	setVarType(mb, n, type);
	mb->vtop++;
	return n;
}

int
newTmpSink(MalBlkPtr mb, malType type)
{
	int n;

	n = type == TYPE_any ? -1 : findTmpVariable(mb, type);
	if (n >= 0)
		return n;
	return newTmpVariable(mb, type);
}

int
newTypeVariable(MalBlkPtr mb, malType type)
{
	int n;

	n = type == TYPE_any ? -1 : findTmpVariable(mb, type);
	if (n > 0 && isTypeVar(mb, n))
		return n;
	n = newTmpVariable(mb, type);
	isTypeVar(mb, n) = TRUE;
	return n;
}

void
delVariable(MalBlkPtr mb, int varid)
{
	if (varid == mb->vtop - 1) {
		GDKfree(getVar(mb, varid));
		getVar(mb, varid) = 0;
		mb->vtop--;
	}
}
void
copyVariable(MalBlkPtr dst, MalBlkPtr src, VarPtr v)
{
	VarPtr w;

	(void) src;		/* fool the compiler */
	w = (VarPtr) GDKzalloc(sizeof(VarRecord));
	w->name = v->name ? GDKstrdup(v->name) : 0;
	w->type = v->type;
	w->gdktype = v->gdktype;
	w->cleanup = v->cleanup;
	w->fixtype = v->fixtype;
	w->isudftype = v->isudftype;
	w->isused = v->isused;
	w->isaconstant = v->isaconstant;
	w->isatypevar = v->isatypevar;
	w->tmpindex = v->tmpindex;
	w->depth = v->depth;
	w->scope = v->scope;

	VALcopy(&w->value, &v->value);
	dst->var[dst->vtop] = w;
	if( v->props )
		w->props = cpyPropertySet(v->props);
}

@-
Beware, removing a variable
calls for a re-numbering of the variable indices used in the
program block. Assuming all new variables are appended only, we
merely have to take care of variable deletions.
@c
void
removeVariable(MalBlkPtr mb, int varid)
{
	int i, j;
	InstrPtr p;

	for (i = 0; i < mb->stop; i++) {
		p = getInstrPtr(mb, i);
		for (j = 0; j < p->argc; j++)
			if (p->argv[j] > varid)
				p->argv[j]--;
	}
	/* remove the variable from the symbol table */
	freeVariable(mb, varid);
	for (i = varid; i < mb->vtop - 1; i++)
		mb->var[i] = mb->var[i + 1];

	mb->vtop--;
}

void
clearVariable(MalBlkPtr mb, int varid)
{
	VarPtr v;

	v = getVar(mb, varid);
	if (v == 0)
		return;
	if (v->name)
		GDKfree(v->name);
	if (v->isaconstant)
		VALclear(&v->value);
	if (v->props)
		freePropertySet(v->props);
	v->props= NULL;
	v->name = 0;
	v->type = 0;
	v->gdktype = 0;
	v->cleanup = 0;
	v->fixtype = 0;
	v->isudftype = 0;
	v->isused = 0;
	v->isaconstant = 0;
	v->isatypevar = 0;
	v->tmpindex = 0;
	v->depth = 0;
	v->scope = 0;

	/* the above version is faster memset((char*)v, 0, sizeof(VarRecord)); */
}

void
freeVariable(MalBlkPtr mb, int varid)
{
	VarPtr v;

	v = getVar(mb, varid);
	clearVariable(mb, varid);
	GDKfree(v);
	getVar(mb, varid) = NULL;
}

@+ MAL constants
Constants are stored in the symbol table and referenced
by a variable identifier.
This means that per MAL instruction, we may end up with
MAXARG entries in the symbol table. This may lead to long
searches for variables.
An optimization strategy deployed in the current
implementation is to look around for
a similar (constant) definition and to reuse its identifier.
This avoids an exploding symbol table with a lot
of temporary variables (as in tst400cHuge)

But then the question becomes how far to search?
Searching through all variables is only useful when the list remains short
or when the constant-variable-name is easily derivable from its literal
value and a hash-based index leads you quickly to it.

For the time being, we use a MAL system parameter, MAL_VAR_WINDOW,
to indicate the number of symbol table entries to consider.
Setting it to >= MAXARG will at least capture repeated use of a constant
within a single function call or repeated use within a small block
of code.

The final step is to prepare a GDK value record, from which
the internal representation can be obtained during
MAL interpretation.

The constant values are linked together to improve searching them.
This start of the constant list is kept in the MalBlk.

Conversion of a constant to another type is limited to
well-known coercion rules. Errors are reported and the
nil value is set.
@c
/**
 * Converts the constant in vr to the MAL type type.  Conversion is done
 * in the vr struct.
 * Returns 0 on success, non-zero otherwise.
 */
int
convertConstant(malType type, ValPtr vr)
{
	if( vr->vtype == type)
		return 0;
	if( vr->vtype == TYPE_str){
#ifdef STRUCT_ALIGNED
		int ll = 0;
		ptr d = NULL;

		ATOMfromstr(type, &d, &ll, vr->val.sval);
		if (d == NULL) {
			showException(SYNTAX, "convertConstant", "parse error in '%s'", vr->val.sval);
			VALinit(vr, type, ATOMnilptr(type));
			return 1;
		}
		VALset(vr, type, d);
		if (ATOMextern(type) == 0)
			GDKfree(d);
#else
		showException(SYNTAX, "convertConstant", "missing implementation");
#endif
		return vr->vtype != type;
	}
	
	switch (type) {
	case TYPE_any:
#ifdef DEBUG_MAL_INSTR
		showException(SYNTAX, "convertConstant", "missing type");
#endif
		assert(0);
	case TYPE_bit:
	case TYPE_chr:
	case TYPE_sht:
	case TYPE_int:
	case TYPE_void:
	case TYPE_oid:
	case TYPE_flt:
	case TYPE_dbl:
	case TYPE_lng:
		VALconvert(type,vr);
		return vr->vtype != type;
	case TYPE_str:
		{ str w=0;
		  if( vr->vtype == TYPE_void){
			vr->vtype = type;
			vr->val.sval = GDKstrdup(str_nil);
			return 0;
		  }
		  if( vr->vtype == TYPE_chr){
			w= GDKstrdup("a");
			*w = vr->val.cval[0];
		  } else
			ATOMformat(vr->vtype, VALptr(vr), &w);
			assert(w != NULL);
			vr->vtype= TYPE_str;
			vr->len = strlen(w);
			vr->val.sval= w;
		  /* VALset(vr, type, w); does not use TYPE-str */
		}
		return vr->vtype != type;

	case TYPE_bat:
		/* BAT variables can only be set to nil */
		vr->vtype = type;
		vr->val.bval = 0;
		return 0;
	case TYPE_ptr:
		/* all coercions should be avoided to protect against memory probing */
		/*
		if (vr->vtype == TYPE_void) {
			vr->vtype = type;
			vr->val.pval = 0;
			return 0;
		}
		if (ATOMcmp(vr->vtype, ATOMnilptr(vr->vtype), VALptr(vr)) == 0) {
			vr->vtype = type;
			vr->val.pval = 0;
			return 0;
		}
		if (vr->vtype == TYPE_int) {
			char buf[BUFSIZ];
			int ll = 0;
			ptr d = NULL;

			snprintf(buf, BUFSIZ, "%d", vr->val.ival);
			(*BATatoms[type].atomFromStr) (buf, &ll, &d);
			if( d==0 ){
				VALinit(vr, type, BATatoms[type].atomNull);
				return 1;
			}
			VALset(vr, type, d);
			if (ATOMextern(type) == 0 )
				GDKfree(d);
		}
		*/
		return vr->vtype != type;
@-
Extended types are always represented as string literals
and converted to the internal storage structure.
Beware that the typeFromStr routines generate storage space
for the new value. This should be garbage collected at the
end.
@c
	default:{
		int ll = 0;
		ptr d = NULL;
		str s;

		if( isaBatType(type)){
			VALinit(vr, TYPE_bat, ATOMnilptr(TYPE_bat));
			break;
		}
		/* see if an atomFromStr() function is available */
		if (BATatoms[type].atomFromStr == 0) {
			s = getTypeName(type);
			showException(SYNTAX, "convertConstant", "no string coercion for '%s'", s);
			GDKfree(s);
			break;
		}

		/* if the value we're converting from is nil, the to
		 * convert to value will also be nil */
		if (ATOMcmp(vr->vtype, ATOMnilptr(vr->vtype), VALptr(vr)) == 0) {
			VALinit(vr, type, ATOMnilptr(type));
			break;
		}

		/* if what we're converting from is not a string */
		if (vr->vtype != TYPE_str) {
			/* an extern type */
			str w = 0;

			/* dump the non-string atom as string in w */
			ATOMformat(vr->vtype, VALptr(vr), &w);
			/* and try to parse it from string as the desired type */
			ATOMfromstr(type, &d, &ll, w);
			if (d == 0) {
				showException(SYNTAX, "convertConstant", "parse error in '%s'", w);
				VALinit(vr, type, ATOMnilptr(type));
				GDKfree(w);
				return 1;
			}
			VALset(vr, type, d);
			if (ATOMextern(type) == 0)
				GDKfree(d);
			GDKfree(w);
		} else { /* what we're converting from is a string */
#ifdef STRUCT_ALIGNED
			ATOMfromstr(type, &d, &ll, vr->val.sval);
			if (d == NULL) {
				showException(SYNTAX, "convertConstant", "parse error in '%s'", vr->val.sval);
				VALinit(vr, type, ATOMnilptr(type));
				return 1;
			}
			VALset(vr, type, d);
			if (ATOMextern(type) == 0)
				GDKfree(d);
#else
			showException(SYNTAX, "convertConstant", "missing implementation");
#endif
		}
	}
	}
	return vr->vtype != type;
}

#define MAL_VAR_WINDOW  4*MAXARG
int
fndConstant(MalBlkPtr mb, ValPtr cst)
{
	int i, k;
	ptr p = VALget(cst);

	k = mb->vtop - MAL_VAR_WINDOW;
	if (k < 0)
		k = 0;
	for (i = mb->vtop - 1; i >= k; i--) {
		VarPtr v = getVar(mb, i);

		if (v && v->isaconstant &&
			v->type == cst->vtype &&
			ATOMcmp(cst->vtype, VALget(&v->value), p) == 0)
			return i;
	}
	return -1;
}

int
cpyConstant(MalBlkPtr mb, VarPtr vr)
{
	int i;
	ValRecord cst;

	VALcopy(&cst, &vr->value);

	i = defConstant(mb, vr->type, &cst);
	return i;
}

int
defConstant(MalBlkPtr mb, int type, ValPtr cst)
{
	int i, k;
	ValPtr vr;

	if (cst->vtype != type && !isaBatType(type) && !isPolyType(type)){
		int otype= cst->vtype;
		i= convertConstant(type, cst);
		if( i ) {
			str ft,tt;
			ft= getTypeName(otype);
			tt= getTypeName(type);
			showException(SYNTAX, "defConstant", "constant coercion error from %s to %s", ft,tt);
			GDKfree(ft);
			GDKfree(tt);
			mb->errors++;
		} else
			assert(cst->vtype== type);
	}
	k= fndConstant(mb,cst);
	if( k >= 0 )
		return k;
	k = newTmpVariable(mb, type);
	isConstant(mb, k) = 1;
	setFixed(mb, k);
	vr = &getVarConstant(mb, k);
	*vr = *cst;
	/*memcpy((char *) vr, cst, sizeof(ValRecord));*/
	return k;
}

@- Argument handling
The number of arguments for procedures is currently limited.
Furthermore, we should assure that no variable is referenced
before being assigned.
Failure to obey should mark the instruction as type-error.
@c
InstrPtr
pushArgument(MalBlkPtr mb, InstrPtr p, int varid)
{
	p->argv[p->argc++] = varid;
	if (p->argc == p->maxarg) {
		InstrPtr pn;
		int pc = 0;
		int space = (p->maxarg - 1) * sizeof(int) + sizeof(InstrRecord);
		pn = GDKmalloc(space + MAXARG * sizeof(int));
		memcpy((char *) pn, (char *) p, space);
		pn->maxarg = p->maxarg + MAXARG;
		pc = getPC(mb, p);
		if (pc >= 0)
			mb->stmt[pc] = pn;

		GDKfree(p);
		p = pn;
	}
	return p;
}

InstrPtr
setArgument(MalBlkPtr mb, InstrPtr p, int idx, int varid)
{
	int i;

	p = pushArgument(mb, p, varid);	/* make space */
	for (i = p->argc - 1; i > idx; i--)
		getArg(p, i) = getArg(p, i - 1);
	getArg(p, i) = varid;
	return p;
}

InstrPtr
pushReturn(MalBlkPtr mb, InstrPtr p, int varid)
{
	assert(p->retc);
	if (p->argv[p->retc - 1] == -1) {
		p->argv[p->retc - 1] = varid;
		return p;
	}
	p = pushArgument(mb, p, varid);
	p->retc++;
	return p;
}

@-
Store the information of a destination variable in the signature structure of
each instruction. This code is largely equivalent to pushArgument,
but it is more efficient in searching and collecting the information.
[todo]
@c
InstrPtr
pushArgumentId(MalBlkPtr mb, InstrPtr p, str name)
{
	int v;

	v = findVariable(mb, name);
	if (v < 0)
		v = newVariable(mb, name, getTypeIndex(name, -1, TYPE_any));
	else
		GDKfree(name);
	return pushArgument(mb, p, v);
}

@-
The alternative is to remove arguments from an instruction record.
This is typically part of instruction constructions.
@c
void
delArgument(InstrPtr p, int idx)
{
	int i;

	for (i = idx; i < p->argc - 1; i++)
		p->argv[i] = p->argv[i + 1];
	p->argc--;
	if (idx < p->retc)
		p->retc--;
}

void
setVarType(MalBlkPtr mb, int i, int tpe)
{
	VarPtr v;
	v = mb->var[i];

	v->type = tpe;
	v->gdktype = tpe <= TYPE_str ? tpe : (tpe == TYPE_any ? TYPE_void : findGDKtype(tpe));
}

@-
Cleaning a variable type by setting it to TYPE_any
possibly invalidates all other type derivations in the program.
Beware of the exception variables. They are globally known.
@c
void
clrAllTypes(MalBlkPtr mb)
{
	int i;
	InstrPtr p;

	p= getInstrPtr(mb,0);

	for(i=p->argc; i<mb->vtop; i++)
	if( !mb->var[i]->isudftype &&
		mb->var[i]->isused &&
		!mb->var[i]->isaconstant &&
		!isExceptionVariable(mb->var[i]->name)){
		setVarType(mb,i,TYPE_any);
		setVarCleanup(mb,i) = FALSE;
		mb->var[i]->gdktype= TYPE_void;
		mb->var[i]->fixtype= 0;
	}
	for(i=1; i<mb->stop-1; i++){
		p= getInstrPtr(mb,i);
		switch(p->token){
		case RAISEsymbol:
		case CATCHsymbol:
		case RETURNsymbol:
		case LEAVEsymbol:
		case YIELDsymbol:
		case EXITsymbol:
		case NOOPsymbol:
			break;
		case ENDsymbol:
			return;
		default:
			p->token= ASSIGNsymbol;
			p->typechk= TYPE_UNKNOWN;
			p->fcn= 0;
			p->blk= NULL;
		}
	}
}

void
setArgType(MalBlkPtr mb, InstrPtr p, int i, int tpe)
{
	if (p->argv[i] >= mb->vsize) {
		GDKwarning("setArgType:array bound error\n");
		return;
	}
	mb->var[getArg(p, i)]->type = tpe;
}

void
setReturnArgument(InstrPtr p, int i)
{
	setDestVar(p, i);
}

malType
destinationType(MalBlkPtr mb, InstrPtr p)
{
	if (p->argc > 0)
		return getVarType(mb, getDestVar(p));
	return TYPE_any;
}

@-
For polymorphic instructions we should keep around the
maximal index to later allocate sufficient space
for type resolutions maps.
Beware, that we only consider the instruction polymorphic
if it has an index or belongs to the signature.
In other cases it merely has to be filled.
@c
INLINE void
setPolymorphic(InstrPtr p, int tpe, int force)
{
	int c1 = 0, c2 = 0;

	if (force == FALSE && tpe == TYPE_any)
		return;
	if (isaBatType(tpe)) {
		if (getHeadIndex(tpe) > 0)
			c1 = getHeadIndex(tpe);
		else if (getHeadType(tpe) == TYPE_any)
			c1 = 1;
	}
	if (getTailIndex(tpe) > 0)
		c2 = getTailIndex(tpe);
	else if (getTailType(tpe) == TYPE_any)
		c2 = 1;
	c1 = c1 > c2 ? c1 : c2;
	if (c1 > 0 && c1 >= p->polymorphic)
		p->polymorphic = c1 + 1;

}

@-
Instructions are simply appended to a MAL block.
It is also the place to collect information to speed-up use later on.
@c
void
pushInstruction(MalBlkPtr mb, InstrPtr p)
{
	int i;

	i = mb->stop;
	if (i + 1 >= mb->ssize) {
		int space = (mb->ssize + STMT_INCREMENT) * sizeof(InstrPtr);
		InstrPtr *newblk = (InstrPtr *) GDKzalloc(space);

		if (newblk == NULL) {
			mb->errors++;
			showException(MAL, "pushInstruction", "out of memory (requested: %d bytes)", space);
			return;
		}
		memcpy(newblk, mb->stmt, mb->stop * sizeof(InstrPtr));

		mb->ssize += STMT_INCREMENT;
		GDKfree(mb->stmt);
		mb->stmt = newblk;
	}
@-
If the destination variable has not been set, introduce a temporary
variable to hold the result instead.
@c
/*
	if (p->argv[0] < 0)
		p->argv[0] = newTmpVariable(mb, TYPE_any);
*/
	assert(p->argv[0]>=0);
	if (mb->stmt[i]) {
		/* if( getModuleId(mb->stmt[i] ) )
		   printf("Garbage collect statement %s.%s\n",
		   getModuleId(mb->stmt[i]), getFunctionId(mb->stmt[i])); */
		freeInstruction(mb->stmt[i]);
	}
	mb->stmt[i] = p;

	mb->stop++;
}

@-
The END instruction has an optional name, which is only checked
during parsing;
@c
void
pushEndInstruction(MalBlkPtr mb)
{
	InstrPtr p;

	p = newInstruction(mb, ENDsymbol);
	p->argc = 0;
	p->retc = 0;
	p->argv[0] = 0;
	pushInstruction(mb, p);
}

@-
Property value setting.
@c
void
setVarProperty(MalBlkPtr mb, int i, str name, str op, ValPtr cst)
{
	bit t = TRUE;

	if (getProps(mb,i) == NULL)
		getProps(mb,i) = newPropertySet();

	if (cst == NULL)
		setProperty(getProps(mb,i), name, "", TYPE_bit, &t);

	else
		setProperty(getProps(mb,i), name, op, cst->vtype, VALget(cst));
}

@+ Reverse programming
Since MAL programs can be created on the fly by linked-in query
compilers, or transformed by optimizers, it becomes
mandatory to be able to produce textual correct MAL programs
from its internal representation.

No guarantee is given to produce the exact input for a reversed
MAL program, except that the output can be fed back for
interpretation. Provided, the code did not produce an error.

The hiddenInstruction operator assumes a sufficiently large block
to leave information on the signature behind.
@c
#define advance(X)  while(*(X))(X)++;

str
typechkName(int i)
{
	switch (i) {
	default:
	case TYPE_ERROR:
		return " error";
	case TYPE_UNKNOWN:
		return " unknown";
	case TYPE_DYNAMIC:
		return " dynamic";
	case TYPE_BIND:
		return " bind";
	case TYPE_RESOLVED:
		return "";
	}
}
str
recognizedCall(MalBlkPtr mb, InstrPtr p, str s)
{
	int i;
	str tpe;

	if( p->retc > 1)
		*s++= '(';
	for (i = 0; i < p->retc; i++)
		if (p->argv[i] >= 0) {
			str nme;
			char nmebuf[PATHLENGTH];
			tpe = getTypeName(getArgType(mb, p, i));
			if (isTmpVar(mb, getArg(p, i)) || isTypeVar(mb, getArg(p, i))) {
				snprintf(nmebuf, PATHLENGTH, "%c%d", TMPMARKER, getVarTmp(mb, getArg(p, i)));
				nme = nmebuf;
			} else
				nme = getArgName(mb, p, i);
			sprintf(s, "%s:%s%s", (nme ? nme : "nil"), tpe, (i<p->retc-1?", ":""));
			advance(s);
			GDKfree(tpe);
		}
	if( p->retc > 1)
		*s++= ')';
	sprintf(s," := %s.%s(", getModuleId(p),getFunctionId(p));
	advance(s);
	for (i = p->retc; i < p->argc; i++)
		if (p->argv[i] >= 0) {
			str nme;
			char nmebuf[PATHLENGTH];

			tpe = getTypeName(getArgType(mb, p, i));
			if (isTmpVar(mb, getArg(p, i)) || isTypeVar(mb, getArg(p, i))) {
				snprintf(nmebuf, PATHLENGTH, "%c%d", TMPMARKER, getVarTmp(mb, getArg(p, i)));
				nme = nmebuf;
			} else
				nme = getArgName(mb, p, i);
			sprintf(s, "%s:%s%s", (nme ? nme : "nil"), tpe, (i<p->argc-1?", ":""));
			advance(s);
			GDKfree(tpe);
		}
	advance(s);
	*s++= ')';
	*s=0;
	return s;
}

str
hiddenInstructionArgs(MalBlkPtr mb, InstrPtr p, str s)
{
	int i;
	str tpe;

	sprintf(s, "\t# %d %s%s ", getPC(mb, p), ((p->blk && p->blk->binding) ? p->blk->binding : ""), typechkName(p->typechk));
	advance(s);
	for (i = 0; i < p->argc; i++)
		if (p->argv[i] >= 0) {
			str nme;
			char nmebuf[PATHLENGTH];

			if (i == p->retc) {
				sprintf(s, "<-");
				advance(s);
			}
			tpe = getTypeName(getArgType(mb, p, i));
			if (isTmpVar(mb, getArg(p, i)) || isTypeVar(mb, getArg(p, i))) {
				snprintf(nmebuf, PATHLENGTH, "%c%d", TMPMARKER, getVarTmp(mb, getArg(p, i)));
				nme = nmebuf;
			} else
				nme = getArgName(mb, p, i);
			sprintf(s, "(%s:%s)", (nme ? nme : "nil"), tpe);
			advance(s);
			GDKfree(tpe);
		}
	advance(s);
	if (p->jump)
		sprintf(s, " jump %d", p->jump);
	advance(s);
	return s;
}

@-
It receives the space to store the definition
The MAL profiler dumps some performance data at the
beginning of each line.

@= performanceData
#ifdef MALprofiler
    if( mb->profiler ){
		int pc= getPC(mb,p);
        double avg= (mb->profiler[pc].ticks+0.0)/mb->profiler[pc].counter;
        sprintf(t,"[%7ld, %5.2f] ",mb->profiler[pc].counter,avg);
    }
    advance(t);
#endif
@-

@= showParam
        tpe= getTypeName(getArgType(mb,p,i));
		if( flg & LIST_MAL_PROPS ){
			ps= getProps(mb,getArg(p,i));
			pstring= propertySet2str(ps);
		} else pstring= GDKstrdup("");
        advance(t);
        sprintf(t,"%s:%s%s",getArgName(mb,p,i),tpe,pstring);
        advance(t);
        if( i<p->@1-1) sprintf(t,",");
        if(pstring) { GDKfree(pstring); pstring=0;}
        GDKfree(tpe);
@c
str
fcnClass(InstrPtr p)
{
	return operatorName(p->token);
}

str
fcnDefinition(MalBlkPtr mb, InstrPtr p, str s, int flg)
{
	int i;
	str t, tpe, pstring;
	PropertySet ps = 0;

	ps = getProps(mb,getArg(p, 0));
	pstring = propertySet2str(ps);
	t = s;
	sprintf(t, "%s%s ", (flg ? "" : "#"), fcnClass(p));

	advance(t);
	if (getModuleId(p))
		sprintf(t, "%s.", getModuleId(p));
	else
		sprintf(t, "user.");
	advance(t);
	if( pstring )
		sprintf(t, "%s%s(", getFunctionId(p),pstring);
	else sprintf(t, "%s(", getFunctionId(p));
	for (i = p->retc; i < p->argc; i++) {
	@:showParam(argc)@}
	advance(t);
	if (p->varargs & VARARGS)
		sprintf(t, "...");
	advance(t);
	if (p->retc == 1) {
		tpe = getTypeName(getArgType(mb, p, 0));
		sprintf(t, "):%s", tpe);
		GDKfree(tpe);
		advance(t);
	} else {
		sprintf(t, ") (");
		t += 3;
		for (i = 0; i < p->retc; i++) {
		@:showParam(retc)@}
		if (p->varargs & VARRETS)
			sprintf(t, "...");
		advance(t);
		*t++ = ')';
	}
	if (mb->binding)
		sprintf(t, " address %s;", mb->binding);
	else
		sprintf(t, ";");
#ifdef DEBUG_MAL_INSTR
	if (flg & LIST_MAL_TYPE) {
		advance(t);
		hiddenInstructionArgs(mb, p, t);
/*
		advance(t);
		if( mb->typefixed) sprintf(t," typefixed");
		if( mb->flowfixed) sprintf(t," flowfixed");
*/
	}
#endif
	return s;
}

@-
@= tabulate
    for(;tab>0;tab--) *t++= ' ';
    *t= 0;
    advance(t);
@-
Variables and MAL blocks, and instructions can be associated with a
property list. At least for debugging purposes, the latest known value
should be displayed.
@= propertyList
    {char *tmp= propertySet2str(ps); strcat(t,tmp); GDKfree(tmp);}
    advance(t);
@c

str
operatorName(int i)
{
	switch (i) {
	case ASSIGNsymbol:
		return ":=";
	case BARRIERsymbol:
		return "barrier";
	case REDOsymbol:
		return "redo";
	case LEAVEsymbol:
		return "leave";
	case EXITsymbol:
		return "exit";
	case RETURNsymbol:
		return "return";
	case YIELDsymbol:
		return "yield";
	case CATCHsymbol:
		return "catch";
	case RAISEsymbol:
		return "raise";
	case ENDsymbol:
		return "end";
	case FUNCTIONsymbol:
		return "function";
	case FACTORYsymbol:
		return "factory";
	case COMMANDsymbol:
		return "command";
	case PATTERNsymbol:
		return "pattern";
	}
	return "Undefined";
}


str
instruction2str(MalBlkPtr mb, InstrPtr p, int flg)
{
	int i, tab = 4;
	size_t len = 0;
	str s, t, nme;
	int low, high;
	char nmebuf[PATHLENGTH];
	PropertySet ps = 0;
	str pstring = 0;

	len = 8196;
	s = GDKmalloc(len);
	if (flg ) {
		if( p->token<0){
			s[0] = '#';
			s[1] = 0;
			t = s+1;
		}else{
			s[0] = 0;
			t = s;
		}
	} else {
		s[0] = '#';
		if (p->typechk == TYPE_UNKNOWN) {
			s[1] = '!';	/* error */
			s[2] = 0;
			t = s + 2;
		} else {
			s[1] = 0;
			t = s + 1;
		}
	}
	/* @:performanceData@ */
	if (isTmpVar(mb, getArg(p, 0))) {
		if (isVarUsed(mb, getDestVar(p))) {
			snprintf(nmebuf, PATHLENGTH, "%c%d", TMPMARKER, getVarTmp(mb, getArg(p, 0)));
		} else
			nmebuf[0] = 0;
		nme = nmebuf;
	} else
		nme = getArgName(mb, p, 0);
	advance(t);
	if (p->token == REMsymbol) {
		/* do nothing */
	} else if (p->barrier) {
		if (p->barrier == LEAVEsymbol || 
			p->barrier == REDOsymbol || 
			p->barrier == RETURNsymbol || 
			p->barrier == YIELDsymbol || 
			p->barrier == RAISEsymbol) {
			@:tabulate@
		}
		sprintf(t, "%s ", operatorName(p->barrier));
		advance(t);
	} else if (!functionStart(p) && !functionExit(p))
		@:tabulate@
	switch (p->token<0?-p->token:p->token) {
	case NOOPsymbol:
	case FCNcall:
	case FACcall:
	case PATcall:
	case CMDcall:
	case ASSIGNsymbol:
		if (p->argc <= 1 && getFunctionId(p) == NULL) {
			if( flg & LIST_MAL_PROPS ){
				ps = getProps(mb,getArg(p, 0));
				pstring = propertySet2str(ps);
			} else pstring = GDKstrdup("");

			if (getVar(mb, getArg(p, 0))->isudftype) {
				str tpe = getTypeName(getVarType(mb, getArg(p, 0)));

				sprintf(t, "%s:%s%s ", nme, tpe, pstring);
				GDKfree(tpe);
			} else
				sprintf(t, "%s%s", nme, pstring);
			advance(t);
			if (pstring)
				GDKfree(pstring);
		} else {
			for (i = 0; i < p->retc; i++) 
				if( !getVarTmp(mb, getArg(p,i)) ||
					isVarUsed(mb, getArg(p,i)) ) 	break;

			if( i == p->retc) goto nolhs; 

			/* display multi-assignment */
			if (p->retc > 1)
				*t++ = '(';

			for (i = 0; i < p->retc; i++) {
				if( flg & LIST_MAL_PROPS ){
					ps = getProps(mb,getArg(p, i));
					pstring = propertySet2str(ps);
				} else pstring= GDKstrdup("");
				if (getVar(mb, getArg(p, i))->isudftype) {
					str tpe = getTypeName(getVarType(mb, getArg(p, i)));

					sprintf(t, "%s:%s%s ", getArgName(mb, p, i), tpe, pstring);
					GDKfree(tpe);
				} else
					sprintf(t, "%s%s", getArgName(mb, p, i), pstring);
				if (pstring)
					GDKfree(pstring);
				advance(t);
				if (i < p->retc - 1)
					*t++ = ',';
			}
			if (p->retc > 1)
				*t++ = ')';
			else
				*t++ = ' ';

			if (p->argc > p->retc || getFunctionId(p)) {
				sprintf(t, ":= ");
				t += 3;
			}
			*t = 0;
		nolhs:;
		}
		break;
	case ENDsymbol:
		sprintf(t, "end %s", getFunctionId(getInstrPtr(mb, 0)));
		break;
	case COMMANDsymbol:
	case FUNCTIONsymbol:
	case FACTORYsymbol:
	case PATTERNsymbol:
		return fcnDefinition(mb, p, s, flg);
	case REMsymbol:
		if(getVar(mb, getArg(p, 0))->value.val.sval) 
			sprintf(t, "#%s ", getVar(mb, getArg(p, 0))->value.val.sval);
		else
			sprintf(t, "# ");
		break;
	default:
		sprintf(t, " ?%d? ", p->token);
	}
	advance(t);
	low = p->retc;
	high = p->argc;
	if (getModuleId(p))
		sprintf(t, "%s.", getModuleId(p));
	advance(t);
	if (getFunctionId(p)) {
		sprintf(t, "%s(", getFunctionId(p));
	} else if (p->argc > p->retc + 1)
		sprintf(t, "(");

	for (i = low; i < high; i++) {
		advance(t);
		if (i + 1 == high && p->varargs & VARARGS) {
			sprintf(t, "...");
			break;
		}
		if (isConstant(mb, getArg(p, i))) {
			str cv = NULL;

			VALformat(&cv, &getVar(mb, getArg(p, i))->value);
			if (strlen(cv) > ((size_t) len) - (t - s)) {
				char *ns = (char *) GDKmalloc(len = strlen(cv) + len + 2);

				*t = 0;
				strcpy(ns, s);
				t = ns + (t - s);
				GDKfree(s);
				s = ns;
			}
			strcat(t, cv);
			GDKfree(cv);
			advance(t);
		} else {
			if( ! isTypeVar(mb,getArg(p,i)) ){
				if (isTmpVar(mb, getArg(p, i))) {
					if( ! isTypeVar(mb,getArg(p,i)) )
						sprintf(t, "%c%d", TMPMARKER, getVarTmp(mb, getArg(p, i)));
					advance(t);
				} else
				sprintf(t, "%s", mb->var[getArg(p, i)]->name);
			} 
		}
@-
Dump the type and value information.
@c
		advance(t);
		if (!isTmpVar(mb, getArg(p, i)) && idcmp("bat", getArgName(mb, p, i)) == 0) {
			str hprop = 0, tprop = 0;
			str d1 = getTypeName(getHeadType(getArgType(mb, p, i)));
			str d2 = getTypeName(getTailType(getArgType(mb, p, i)));

			sprintf(t, ":bat[:%s%s,:%s%s]", d1, hprop, d2, tprop);
			GDKfree(d1);
			GDKfree(d2);
			advance(t);
		} else if ( isTypeVar(mb, getArg(p, i)) || 
				  ( isConstant(mb, getArg(p, i)) &&
					( getVar(mb, getArg(p, i))->isudftype ||
					ATOMcmp(getArgType(mb,p,i), 
							ATOMnilptr(getArgType(mb,p,i)), 
							VALptr(&getVar(mb, getArg(p, i))->value) ) == 0

					) )) {
			char *tnme = getTypeName(getArgType(mb, p, i));

			sprintf(t, ":%s", tnme);
			GDKfree(tnme);
			advance(t);
		} 
		if (i + 1 < high)
			sprintf(t, ",");
	}
	advance(t);
	if (getFunctionId(p) || p->argc > p->retc + 1)
		sprintf(t, ")");
	advance(t);
	if (p->token != REMsymbol)
		sprintf(t, ";");
	if (flg & LIST_MAL_TYPE) {
		advance(t);
		t = hiddenInstructionArgs(mb, p, t);
	}
	advance(t);
	/* sprintf(t,"\n"); */
	if (t > s + len)
		GDKfatal("instruction2str:");
	return s;
}

str
function2str(MalBlkPtr mb, int flg)
{
	str ps, *txt;
	int i, *len, totlen = 0;

	txt = GDKmalloc(sizeof(str) * mb->stop);
	len = GDKmalloc(sizeof(int) * mb->stop);
	for (i = 0; i < mb->stop; i++) {
		txt[i] = instruction2str(mb, getInstrPtr(mb, i), flg);
		totlen += len[i] = strlen(txt[i]);
	}
	ps = GDKmalloc(totlen + mb->stop + 1);
	totlen = 0;
	for (i = 0; i < mb->stop; i++) {
		strncpy(ps + totlen, txt[i], len[i]);
		ps[totlen + len[i]] = '\n';
		ps[totlen + len[i] + 1] = 0;
		totlen += len[i] + 1;
		GDKfree(txt[i]);
	}
	GDKfree(len);
	GDKfree(txt);
	return ps;
}

void
promptInstruction(stream *fd, MalBlkPtr mb, InstrPtr p, int flg)
{
	str ps;

	if (fd == 0)
		GDKfatal("printInstruction:no file\n");
	ps = instruction2str(mb, p, flg);
	/* ps[strlen(ps)-1] = 0; remove '\n' */
	stream_printf(fd, "%s", ps);
	GDKfree(ps);
}

void
printInstruction(stream *fd, MalBlkPtr mb, InstrPtr p, int flg)
{
	promptInstruction(fd, mb, p, flg);
	stream_printf(fd, "\n");
}

void
printSignature(stream *fd, Symbol s, int flg)
{
	InstrPtr p;
	str txt = GDKzalloc(BLOCK);

	p = getSignature(s);
	(void) fcnDefinition(s->def, p, txt, flg);
	stream_printf(fd, "%s\n", txt);
	GDKfree(txt);
}

void showMalBlkHistory(MalBlkPtr mb)
{
	MalBlkPtr m=mb;
	InstrPtr p,sig;
	int j=0;
	str msg;

	sig = getInstrPtr(mb,0);
	while(m){
		p= getInstrPtr(m,m->stop-1);
		if( p->token == REMsymbol){
			msg= instruction2str(m,p, FALSE);
			stream_printf(GDKout,"%s.%s[%2d] %s\n", 
				getModuleId(sig), getFunctionId(sig),j++,msg+3);
			GDKfree(msg);
		} else {
			stream_printf(GDKout,"%s.%s[%2d]\n", 
				getModuleId(sig), getFunctionId(sig),j++);
		}
		m= m->history;
	}
}
@}
