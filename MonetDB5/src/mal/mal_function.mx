@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2006 CWI.
@' All Rights Reserved.

@a M. Kersten
@v 0.0
@+ MAL functions
MAL comes with a standard functional abstraction scheme.
MAL functions are represented by MAL instruction lists, enclosed
by a @code{function} and @code{exit} statement. The @code{function}
designates its signature, i.e. it lists the arguments and their types.
The @code{exit} statement marks the end of this sequence. 
Its argument is the function name.

An illustrative example is:
@example
function helloWorld(msg:str):str;
    io.print(msg);
    return msg;
end hellowWorld;
@end example

The type checker ensures that all variables are assigned
a value before they are used as arguments. Moreover, variables
introduced within guarded blocks may not be used elsewhere.

Input variables changed in the process preferably also appear in
the target list, i.e. the instruction models the input/output flow.
This greatly simplifies future optimization decisions.
@menu
* Function Clones::
* Commands and Patterns::
@end menu
@{
@-
The information maintained for each MAL function should both
be geared towards fast execution and to ease symbolic debugging.
@h
#ifndef _MAL_FCN_H
#define _MAL_FCN_H

#include "mal_module.h"

/* #define DEBUG_MAL_FCN */
/* #define DEBUG_CLONE */

mal_export Symbol   newFunction(str nme,int kind);
mal_export void     renameFunction(str oldmod, str oldfcn,str modnme, str new);
mal_export void	    clearFcn(MalBlkPtr m);
mal_export int      getPC(MalBlkPtr mb, InstrPtr p);

mal_export InstrPtr newCall(Module scope, str fcnname, int kind);
mal_export Symbol cloneFunction(Module scope, Symbol proc, MalBlkPtr mb, InstrPtr p);

mal_export Symbol   getFunctionSymbol(Module scope, InstrPtr p);
mal_export void chkFlow(MalBlkPtr mb);
mal_export void chkDeclarations(MalBlkPtr mb,int reset);
mal_export int getBarrierEnvelop(MalBlkPtr mb);
mal_export int isLoopBarrier(MalBlkPtr mb, int pc);
mal_export int getBlockExit(MalBlkPtr mb,int pc);
mal_export int getBlockBegin(MalBlkPtr mb,int pc);
mal_export void setLifespan(MalBlkPtr mb);
mal_export void debugLifespan(MalBlkPtr mb);

mal_export void printFunction(stream *fd, MalBlkPtr mb, int listing);

#include "mal_exception.h"

#define MAXDEPTH 32
#endif /*  _MAL_FCN_H*/
@-
The MAL function blocks are constructed incrementally while parsing the source.
The function kind determines its semantics. It is taken from the list
FUNCTION, FACTORY, COMMAND, PATTERN.
@c
#include "mal_function.h"
#include "mal_resolve.h"	/* for isPolymorphic() & chkProgram() */
#include "mal_interpreter.h"	/* for showErrors() */
#include "mal_namespace.h"

Symbol newFunction(str nme,int kind){
	Symbol s;
	InstrPtr p;

	s = newSymbol(nme,kind);
	p = newInstruction(NULL,kind);
	setFunctionId(p, nme);  /* name already in namespace */
	setDestVar(p, newVariable(s->def,GDKstrdup(nme),TYPE_any));
	pushInstruction(s->def,p);
	return s;
}
InstrPtr newCall(Module scope, str fcnname, int kind){
	InstrPtr p;
	p= newInstruction(NULL,kind);
	setModuleScope(p, scope);
	setFunctionId(p, putName(fcnname,strlen(fcnname)));
	return p;
}
@-
Optimizers may be interested in the function definition
for obtaining properties. Rather then polution of the
instruction record with a scope reference, we use a lookup function until it
becomes a performance hindrance.
@c
Symbol  getFunctionSymbol(Module scope, InstrPtr p){
	Module m;
	Symbol s;

	for(m= findModule(scope,moduleName(p)); m; m= m->outer)
		if(idcmp(m->name, moduleName(p))==0 ) {
				s= m->subscope[(int)(getSubScope(functionName(p)))];
				for(; s; s= s->peer)
				if( getSignature(s)->fcn == p->fcn) return s;
		}

	GDKerror("getFunctionSymbol:internal error\n");
	return 0;
} 
@-
Remame all incarnations of a function.
@c
void renameFunction(str oldmod, str oldfcn, str modnme, str name){
	Module root,scope;
	Symbol s,prev;
	InstrPtr p;
	root= scope= getClient()->nspace;
	while( scope != NULL){
		if( oldmod && strcmp(oldmod, scope->name) ){
			scope= scope->outer;
			continue;
		}
	    s= scope->subscope[(int)(*oldfcn)];
	    prev= NULL;
	    while(s != NULL){
	        if( idcmp(s->name,oldfcn) == 0) break;
	        prev= s;
	        s= s->skip;
	    }
	    if( s) {
	        if( prev == 0){
	            scope->subscope[(int)(*oldfcn)]= s->skip;
	        } else {
	            prev->peer= s->skip;
	        }
	        while(s){
	            prev= s->peer; 
	            s->peer= NULL;
	            s->name= GDKstrdup(name);
	            p= getInstrPtr(s->def,0);
	            setModuleId(p,putName(modnme,strlen(modnme)));
	            setFunctionId(p,putName(name,strlen(name)));
	            insertSymbol(root,s);
	            s= prev;
	        }
	        return;
	    }
	    scope=scope->outer;
	}
}
@- Flow of control
The nesting of (BARRIER, CATCH) and EXIT statements with their associated
flow of control primitives LEAVE, REDO and RAISE should form a valid
hierarchy. Failure to comply is considered a structural error
and leads to flagging the function as erroneous.

Check barrier should ensure that both exit-points of a block for the
variable referenced in 'pp' exists. In addition, we should ensure
proper weaveing of the begin-end pairs. This can simply be checked by
counting the begin/end pairs. It should balance for every block.
Currently, the barrier control variables should be of type bit,
sht, int, or lng. A number zero is interpreted as end of the barrier
block.

To speed-up interpretation of the control statements, we could also
include the program-counter in the instruction record. However, this implies
that any subsequent change to a program, i.e. by the optimizers,
should be followed by a call to recalculate the PC.
For the time being it will be a linear scan.

@c
int getPC(MalBlkPtr mb, InstrPtr p)
{   int i;
	for( i=0;i<mb->stop; i++)
	if( getInstrPtr(mb,i)==p) return i;
	return -1;
}
@-
Checking the control flow structure is done by a single pass over the
MAL program after the program has been type-checked.
It should inspect all BARRIER and CATCH blocks for proper structure.
If the flow is correct and not dependent on an undefined typed instruction
we avoid doing this check any further.
@c
#define DEPTH 128

void chkFlow(MalBlkPtr mb)
{   int i,j,k, v,lastInstruction;
	int  pc[DEPTH];
	int  var[DEPTH];
	InstrPtr stmt[DEPTH];
	int btop=0;
	int retseen=0;
	int fixed=1;    
	InstrPtr p;

	lastInstruction = mb->stop-1;
	for(i= 0; i<mb->stop; i++){
		p= getInstrPtr(mb,i);
		switch( p->barrier){
		case BARRIERsymbol:
		case CATCHsymbol:
			if(btop== DEPTH){
			    GDKerror("Too many nested MAL blocks\n");
			    mb->errors++;
			    return;
			}
			pc[btop]= i;
			v= var[btop]= getDestVar(p);
			stmt[btop]=p;

			for(j=btop-1;j>=0;j--)
			if( v==var[j]){
			    GDKerror("recursive %s[%d] shields %s[%d]\n",
			        getVarName(mb,v), pc[j],
			        getFcnName(mb),pc[i]);
			    mb->errors++;
			    return;
			}

			if( getVarType(mb,v) != TYPE_bit && 
			    getVarType(mb,v)!= TYPE_any &&
			    getVarType(mb,v) != TYPE_sht && 
			    getVarType(mb,v)!= TYPE_oid && 
			    !isaBatType(getVarType(mb,v)) &&
			    getVarType(mb,v)!= TYPE_chr && 
			    getVarType(mb,v)!= TYPE_lng && 
			    getVarType(mb,v) != TYPE_int &&
			    getVarType(mb,v) != TYPE_str ){
			    GDKerror("barrier '%s' should be of type bit or number in %s[%d]\n",
			    getVarName(mb, v), getFcnName(mb), i);
			}
			btop++;
			if( p->typechk != TYPE_RESOLVED) fixed =0;
			break;
		case EXITsymbol:
			v= getDestVar(p);
			if( btop>0 && var[btop-1] != v){
			    mb->errors++;
			    GDKerror("exit-label '%s' doesnot match '%s' in %s[%d]\n",
			    getVarName(mb,v),
			    getVarName(mb,var[btop-1]),
			    getFcnName(mb),i);
			}
			if(btop==0){
			    GDKerror("exit-label '%s' without begin-label in %s[%d]\n",
			    getVarName(mb,v), getFcnName(mb),i);
			    mb->errors++;
			    continue;
			}
			/* search the matching block */
			for(j=btop-1;j>=0;j--)
			if( var[j]==v) break;
			if(j>=0) btop= j; else btop--;

			/* retrofit LEAVE/REDO instructions */
			stmt[btop]->jump= i;
			for(k=pc[btop]; k<i; k++){
			    InstrPtr p1= getInstrPtr(mb,k);
			    if( getDestVar(p1)==v ) {
			        /* handle assignments with leave/redo option*/
			        if(p1->barrier== LEAVEsymbol )
			            p1->jump= i;
			        if( p1->barrier==REDOsymbol )
			            p1->jump= pc[btop]+1;
			    }
			}
			if( p->typechk != TYPE_RESOLVED) fixed =0;
			break;
		case LEAVEsymbol:
		case REDOsymbol:
			v= getDestVar(p);
			for(j=btop-1;j>=0;j--)
			if( var[j]==v) break;
			if(j<0){
			    GDKerror("label '%s' not in guarded block in %s[%d]\n",
			    getVarName(mb,v),getFcnName(mb),i);
			    mb->errors++;
			} else
			if( p->typechk != TYPE_RESOLVED) fixed =0;
			break;
		case YIELDsymbol:
			{ InstrPtr ps= getInstrPtr(mb,0);
			if( ps->token != FACTORYsymbol){
			    GDKerror("yield misplaced\n!");
			    mb->errors++;
			} }
		case RETURNsymbol:
			{   InstrPtr ps= getInstrPtr(mb,0);
			    int i;
			    if( ps->retc != p->retc){
			        GDKerror("invalid return target\n!");
			        mb->errors++;
			    } else
			    if(ps->typechk == TYPE_RESOLVED)
			    for(i=0;i<p->retc; i++){
	                if( getArgType(mb,ps,i) != getArgType(mb,p,i) ){
	                    GDKerror("%s type mismatch at type %d\n",
	                        (p->barrier==RETURNsymbol?"RETURN":"YIELD"),
			                                getArgType(mb,p,i));
	                    mb->errors++;
	                }
	            }
			    if(ps->typechk != TYPE_RESOLVED) fixed =0;
			}
			retseen = 1;
			break;
	    case ENDsymbol:
			lastInstruction = lastInstruction < mb->stop?i:lastInstruction;
			break;
	    case RAISEsymbol:
	        break;
		default:
			if( isaSignature(p) ){
				if( p->token == REMsymbol){
					/* do nothing */
				} else if( i) {
					str msg=instruction2str(mb,p,TRUE);
					GDKerror("SYNTAX ERROR: signature misplaced\n!%s\n",msg);
					GDKfree(msg);
					mb->errors++;
				}
			} 
		}
	}
	if( lastInstruction < mb->stop-1 ){
		GDKerror("SYNTAX ERROR: instructions after END \n");
#ifdef DEBUG_MAL_FCN
		printFunction(GDKout, mb, LIST_MAL_ALL);
#endif
		mb->errors++;
	}
	for(btop--; btop>=0;btop--){
		GDKerror("begin '%s' without exit in %s[%d]\n",
			getVarName(mb,var[btop]),getFcnName(mb),i);
		mb->errors++;
	}
	p= getInstrPtr(mb,0);
	if( !isaSignature(p)){
		GDKerror("SYNTAX ERROR: signature missing\n");
		mb->errors++;
	}
	if( retseen == 0){
		if( getArgType(mb,p,0)!= TYPE_void &&
			(p->token==FUNCTIONsymbol || p->token==FACTORYsymbol)){
			GDKerror("%s missing in %s.%s\n", 
				(p->token== FUNCTIONsymbol?"return":"yield"),
				moduleId(p), functionId(p));
			mb->errors++;
		}
	}
@-
In interactive mode we should avoid early garbage collection of values.
This can be controlled by the clean up control at the instruction level
and marking all non-temporary variables as being (potentially) used.
@c
	if( mb->stop == 3) /* interactive use */
	{   int i;
	    for(i=0;i<3; i++){
			getInstrPtr(mb,i)->gc = 0;
	    }
	}
	if( mb->errors == 0 )
		mb->flowfixed = fixed; /* we might not have to come back here */
}
@-
A code may contain temporary names for marking barrier blocks.
Since they are introduced by the compiler, the parser should locate
them itself when encountering the LEAVE,EXIT,REDO.
The starting position is mostly the last statement entered.
Purposely, the nameless envelops searches the name of the last
unclosed block. All others are ignored.
@c
int getBarrierEnvelop(MalBlkPtr mb){
	int pc;
	InstrPtr p;
	for(pc= mb->stop-2 ; pc>=0; pc--){
		p= getInstrPtr(mb,pc);
		if( blockExit(p)){
			int l= p->argv[0];
			for(; pc>=0;pc--){
			    p= getInstrPtr(mb,pc);
			    if( blockStart(p) && p->argv[0]==l) break;
			}
			continue;
		}
		if( blockStart(p) ) return p->argv[0];
	}
	return newTmpVariable(mb,TYPE_any);
}
@}
@- Lifespan analysis
Optimizers may be interested in the characteristic of the
barrier blocks for making a decision.
The variables have a lifespan in the code blocks, denoted by properties
beginLifespan,endLifespan. The beginLifespan denotes the intruction where
it receives its first value, the endLifespan the last instruction in which 
it was used as operand or target.

If, however, the last use lies within a BARRIER block, we can not be sure
about its end of life status, because a block redo may implictly
revive it. For these situations we associate the endLifespan with
the block exit.

In many cases, we have to determine if the lifespan interferes with 
a optimization decision being prepared.
The lifespan is calculated once at the beginning of the optimizer sequence.
It should either be maintained to reflect the most accurate situation while
optimizing the code base. In particular it means that any move/remove/addition
of an instruction calls for either a recalculation or delta propagation.
Unclear what will be the best strategy. For the time being we just recalc.

@{
Also take care of the nested block structure. Because the span should
fall within a single block. This is handled by the chkflow already.
@c
void
debugLifespan(MalBlkPtr mb)
{
	int i;

	for (i = 0; i < mb->vtop; i++) {
		VarPtr v = getVar(mb, i);

		if (isTmpVar(mb, i))
			printf("%c%d %d - %d scope=%d,%d\n", TMPMARKER, v->tmpindex, v->beginLifespan, v->endLifespan, v->scope, v->depth);

		else
			printf("%s %d - %d scope= %d,%d\n", v->name, v->beginLifespan, v->endLifespan, v->scope, v->depth);
	}
}
void
setLifespan(MalBlkPtr mb)
{
	int pc, k;
	InstrPtr p;

	for (k = 0; k < mb->vtop; k++) {
		VarPtr v = getVar(mb, k);

		v->lastUpdate = v->beginLifespan = v->endLifespan = 0;
	}
	for (pc = 0; pc < mb->stop; pc++) {
		p = getInstrPtr(mb, pc);
		for (k = 0; k < p->argc; k++) {
			VarPtr v = getVar(mb, p->argv[k]);

			if (v->beginLifespan == 0)
				v->beginLifespan = pc;
			if (k < p->retc)
				v->lastUpdate= pc;
			if (pc > v->endLifespan) {
				/* end only if the beginLifspan falls in the same blk */
				/* otherwise it is the corresponding exit. */
				v->endLifespan = pc;
			}
		}
	}
	/* debugLifespan(mb); */
}

@c
int
isLoopBarrier(MalBlkPtr mb, int pc){
	InstrPtr p;
	int varid;
	p= getInstrPtr(mb,pc);
	if( p->barrier != BARRIERsymbol)
		return 0;
	varid= getArg(p,0);
	for(pc++; pc< mb->stop; pc++){
		p= getInstrPtr(mb,pc);
		if( p->barrier == REDOsymbol && getArg(p,0)== varid)
			return 1;
		if( p->barrier == EXITsymbol && getArg(p,0)== varid)
			break;
	}
	return 0;
}
@-
Searching the beginning or end of an instruction block.
@c
int
getBlockBegin(MalBlkPtr mb,int pc){
	InstrPtr p;
	int varid=0,i;

	for(i= pc; i< mb->stop; i++){
		p= getInstrPtr(mb,i);
		if( p->barrier == EXITsymbol ){
			varid= getArg(p,0);
			break;
		}
	}
	if( i==mb->stop) return 0;

	for(; pc> 0; pc--){
		p= getInstrPtr(mb,pc);
		if( (p->barrier == BARRIERsymbol || p->barrier == CATCHsymbol) &&
		    getArg(p,0)== varid)
			return pc;
	}
	return 0;
}
int
getBlockExit(MalBlkPtr mb,int pc){
	InstrPtr p;
	int varid;
	p= getInstrPtr(mb,pc);
	if( p->barrier != BARRIERsymbol && p->barrier != CATCHsymbol)
		return 0;
	varid= getArg(p,0);
	for(pc++; pc< mb->stop; pc++){
		p= getInstrPtr(mb,pc);
		if( p->barrier == EXITsymbol && getArg(p,0)== varid)
			return pc;
	}
	return 0;
}
@- Variable declaration
Variables are implicitly declared upon first use.
This feature may become a source of runtime errors and
complicates the analyse during optimization.
Therefore, in line with the flow of control check,
we make sure that all variables are properly initialized
before being used. Since barrier blocks may be skipped at
runtime, they actually introduce a separate scope.
Variables declared within a block may not be used outside it.

In many situation chkFlow and chkDeclarations should be called
together. Moreover, an erroneous chkFlow most likely implies
errors in the declarations as well.

Since in interactive mode each statement is handled separately,
we have to remember the scope assigned to a variable.
@c
void chkDeclarations(MalBlkPtr mb,int reset){
	int pc,i, k,l;
	InstrPtr p;
	short s, blks[MAXDEPTH], top= 0, blkId=1;
	str nme;

	blks[top] = 1;
	blks[++top]= 0;
	if( reset) 
	for(i=0; i<mb->vtop; i++){
		getVarDepth(mb,i)=0;
		getVarScope(mb,i)=0;
	}

	/* all signature variables are declared at outer level */
	p= getInstrPtr(mb,0);
	for(k=p->retc;k<p->argc; k++){
		getVarScope(mb,p->argv[k])= 1;
	    getVarDepth(mb,p->argv[k])= 0;
	}
	/* and the function name as well */
	if( functionName(p) == NULL){
		GDKerror("Function name missing in signature\n");
		return;
	}
	nme= functionName(p);
		
	/* printFunction(GDKout,mb, LIST_MAL_ALL);*/

	for(pc=1;pc<mb->stop; pc++){
		p= getInstrPtr(mb,pc);
		if( p->token == IGNOREsymbol) continue;
		for(k=p->retc;k<p->argc; k++) {
			l=getArg(p,k);
			if( isConstant(mb, l) || isTypeVar(mb,l) ){
				/* ok defined */
			} else 
			if( (s = getVarScope(mb,l) ) ==0 ) {
					GDKerror("'%s' may not be used before being set in %s[%d]\n",
						getVarName(mb,l), nme,pc);
						mb->errors++;
			} else 
			if( getVarDepth(mb,l) >= top){
						GDKerror("'%s' may not be used before being set in %s[%d]\n",
							getVarName(mb,l), nme,pc);
						mb->errors++;
			}
		}
		for(k=0; k<p->retc; k++){
			l= getArg(p,k);
			if( getVarScope(mb, l) == 0){
				if( (p->barrier== RETURNsymbol || p->barrier== YIELDsymbol) &&
					getVarType(mb,l) != TYPE_void  && p->retc==p->argc){
			            GDKerror("'%s' returns before being initialized",
							getVarName(mb,l));
						mb->errors++;
				}
			    getVarScope(mb, l) = blks[top-1];
			    getVarDepth(mb, l) = top-1;
			} else {
			    /* is the block still active ? */
			    s = getVarScope(mb,l);
			    for( i=0; i< top; i++)
			    if( blks[i] == s ) break;
			    if( i< top && blks[i]!= s && !isTmpVar(mb, l)){
			            GDKerror("'%s' used outside declaration scope in %s[%d]\n",
			            getVarName(mb,l), nme,pc);
			        mb->errors++;
			    }
			}
		}
		if( p->barrier){
			if( blockStart(p)){
				blkId++;
				if( top <MAXDEPTH-2){
					blks[top]= blkId;
					blks[++top]= 0;
				} else {
					GDKerror("too deeply nested  MAL program\n");
					mb->errors++;
					return;
				}
			}
			if( blockExit(p) && top > 0) {
			    top--;
			    blks[top]= 0;
			}
		}
	}
}
@}
@-
@node Function Clones, Commands and Patterns, Function definitions, Function definitions
@- Function Clones
MAL supports functions defined with type variables, i.e.
polymorphic functions. The type variable is denoted
by @code{any} and an optional index.
Each time a polymorphic  MAL function is called, the
symbol table is first inspected for the matching strongly typed
version.  If non exists, a copy of
the polymorphic routine is generated, whereafter the type
variables are replaced with their concrete types.
The function body is immediately type checked and, if
no errors occured, added to the symbol table.

The generic type variable @code{any} designates an unknown type, which may
be filled at type resolution time. Unlike indexed polymorphic type 
arguments, @code{any} type arguments match possibly with different 
concrete types.


An example of a parameterised function is shown below:
@example
function helloWorld(msg:any_1):any_1;
	io.print(msg);
return msg;
@end example
The type variables ensure that the return type equals the
argument type. Type variables can be used at any place
where a type name is permitted. 
Beware that polymorphic type variables are propagated
throughout the function body. This may invalidate 
type resolutions taken @ref{Type resolution}.

This version of @code{helloWorld} can also be used for
other arguments types, i.e. @code{bit,sht,lng,flt,dbl,...}.
For example, calling @code{helloWorld(3.14:flt)} echoes
a float value.

@node Commands and Patterns, Factory definitions, Function Clones, Function definitions
@- Commands and patterns
The MAL function body can also be implemented with a C-function.
They are introduced to the MAL type checker by providing their
signature and an @code{address} qualifier for linkage.

We distinguish both @code{command} and @code{pattern} MAL blocks.
They differ in the information accessible at run time. The @code{command}
variant calls the underlying C-function, passing pointers to the arguments
on the MAL runtime stack. The @code{pattern} command is passed pointers
to the MAL definitin, the runtime stack, and the instruction itself.
It can be used to analyse the types of the arguments directly.

For example, the definitions below link the kernel routine @code{BKCinsert_bun}
with the function @code{bat.insert()}. 
It does not fully specify the result type.
The @code{io.print()} pattern applies to any BAT argument list, 
provided they match on the head column type.
@example
command bat.insert(b:bat[:any_1,:any_2], ht:any_1, tt:any_2) :bat[:any_1,:any_2]
address BKCinsert_bun;

pattern io.print(b1:bat[:any_1,:any]...):int
address IOtable;
@end example

The internal representation of the MAL functions is rather traditional,
using C-structure to collect the necessary information.
Moreover, we assume that MAL functions are relatively small, up to
a few hundred of instructions. This assumption makes us to rely on
linear scans as it comes to locating information of interest.
@{

Patterns should not be cloned, because the alternative interpretations
are handled by the underlying code fragments.
@c
void replaceTypeVar(MalBlkPtr mb, InstrPtr p, int v, malType t){
	int j,i,x,y;
#ifdef DEBUG_MAL_FCN
	stream_printf(GDKout,"replace type _%d by type %s\n",v,
		getTypeName(t));
#endif
	for(j=0; j<mb->stop; j++){
	    p= getInstrPtr(mb,j);
#ifdef DEBUG_MAL_FCN
		printInstruction(GDKout,mb,p,LIST_MAL_ALL);
#endif 
	if( p->polymorphic)
	for(i=0;i<p->argc; i++)
	if( isPolymorphic(x= getArgType(mb,p,i))) {
		if( isaBatType(x)){
			int head,tail;
			int hx,tx;
			head = getHeadType(x);
			tail = getTailType(x);
			hx = getHeadIndex(x);
			tx = getTailIndex(x);
			if(v && hx == v && head == TYPE_any){
			    hx =0;
			    head =t;
			}
			if(v && tx == v && tail == TYPE_any){
			    tx= 0;
			    tail = t;
			}
			y= newBatType(head,tail);
			setAnyHeadIndex(y,hx);
			setAnyTailIndex(y,tx);
			setArgType(mb,p,i,y);
#ifdef DEBUG_MAL_FCN
		stream_printf(GDKout," %d replaced %s->%s \n",i,getTypeName(x),getTypeName(y));
#endif 
		} else
		if( isaColType(x)){
			int tail;
			int tx;
			tail = getTailType(x);
			tx = getTailIndex(x);
			if(v && tx == v && tail == TYPE_any){
			    tx= 0;
			    tail = t;
			}
			y= newColType(tail);
			setAnyTailIndex(y,tx);
			setArgType(mb,p,i,y);
#ifdef DEBUG_MAL_FCN
		stream_printf(GDKout," %d replaced %s->%s \n",i,getTypeName(x),getTypeName(y));
#endif 
		} else
		if(v>0 &&  getTailIndex(x) == v){
#ifdef DEBUG_MAL_FCN
		stream_printf(GDKout," replace x= %s polymorphic\n",getTypeName(x));
#endif 
			setArgType(mb,p,i,t);
		} 
#ifdef DEBUG_MAL_FCN
		else 
		stream_printf(GDKout," non x= %s %d\n",getTypeName(x),getTailIndex(x));
#endif 
	}
#ifdef DEBUG_MAL_FCN
		printInstruction(GDKout,mb,p,LIST_MAL_ALL);
#endif 
	}
}
@-
Upon cloning a function we should remove all the polymorphic flags.
Otherwise we may end up with a recursive clone.
@c
Symbol  cloneFunction(Module scope, Symbol proc, MalBlkPtr mb, InstrPtr p){
	Symbol new;
	int i,v;
	InstrPtr pp;

#ifdef DEBUG_CLONE
	stream_printf(GDKout,"clone the function %s to scope %s\n",
			proc->name,scope->name);
	printInstruction(GDKout,mb, p,LIST_MAL_ALL);
#endif
	new= newFunction(putName(proc->name,strlen(proc->name)), 
	            getSignature(proc)->token );
	new->def = copyMalBlk(proc->def);
	/* now change the definition of the original proc */
/*
printf("CLONED VERSION\n");
printFunction(GDKout, new->def, LIST_MAL_ALL);
*/
	/* check for errors after fixation , TODO*/
	pp = getSignature(new);
	for(i=0;i<pp->argc;i++)
	if( isPolymorphic(v= getArgType(new->def,pp,i)) ){
		int t = getArgType(mb,p,i);

		if( isaBatType(t) ){
			if( getHeadIndex(v) )
	            replaceTypeVar(new->def, pp, getHeadIndex(v), getHeadType(t));
			if( getTailIndex(v) )
	            replaceTypeVar(new->def, pp, getTailIndex(v), getTailType(t));
		} else
		if( isaColType(t) ){
			if( getTailIndex(v) )
				replaceTypeVar(new->def, pp, getTailIndex(v), getTailType(t));
		} else
			replaceTypeVar(new->def, pp, getTailIndex(v), t);
	} 
#ifdef DEBUG_MAL_FCN
	else stream_printf(GDKout,"%d remains %s\n",i, getTypeName(v));
#endif
	/* include the function at the proper place in the scope */
	insertSymbol(scope,new);
	/* clear polymorphic and type to force analysis*/
	for(i=0;i<new->def->stop;i++) {
		pp= getInstrPtr(new->def,i);
	    pp->typechk= TYPE_UNKNOWN;
		pp->polymorphic= 0;
	}
	/* clear type fixations */
	for(i=0;i< new->def->vtop; i++)
		new->def->var[i]->fixtype=0;
/*
printf("FUNCTION TO BE CHECKED\n");
printFunction(GDKout, new->def, LIST_MAL_ALL);
*/
	/* check for errors after fixation , TODO*/
	/* beware, we should now ignore any cloning */
	if(proc->def->errors == 0) {
		chkProgram(scope,new->def);
		if( new->def->errors){
			str err;
			GDKerror("Error in cloned function\n");
			err= function2str(new->def,LIST_MAL_ALL);
			GDKerror("%s",err);
			GDKfree(err);
			showErrors();
		}
	}
#ifdef DEBUG_CLONE
	stream_printf(GDKout,"newly cloned function added to %s %d \n",scope->name,i);
	printFunction(GDKout,new->def, LIST_MAL_ALL);
#endif
	return new;
}
@-
For commands we do not have to clone the routine. We merely have to
assure that the type-constraints are obeyed. The resulting type
is returned.
@c
void printFunction(stream *fd, MalBlkPtr mb, int flg){
	int i;
	for(i=0;i<mb->stop;i++)
	printInstruction(fd,mb, getInstrPtr(mb,i),flg);
}
@}
