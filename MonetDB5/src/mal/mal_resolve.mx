@/
@/
The contents of this file are subject to the MonetDB Public License
Version 1.1 (the "License"); you may not use this file except in
compliance with the License. You may obtain a copy of the License at
http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html

Software distributed under the License is distributed on an "AS IS"
basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations
under the License.

The Original Code is the MonetDB Database System.

The Initial Developer of the Original Code is CWI.
Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
Copyright August 2008-2011 MonetDB B.V.
All Rights Reserved.
@

@f mal_scenario
@a M. Kersten
@v 0.0
@+ Session Scenarios
In MonetDB multiple languages, optimizers, and execution engines can
be combined at run time to satisfy a wide user-community.
Such an assemblage of components is called a @emph{scenario}
and consists of a @emph{reader}, @emph{parser}, @emph{optimizer},
@emph{tactic scheduler} and @emph{engine}. These hooks allow
for both linked-in and external components.

The languages supported are SQL, XQuery, 
and the Monet Assembly Language (MAL).
The default scenario handles MAL instructions, which is used
to illustrate the behavior of the scenario steps.

The MAL reader component handles interaction with
a front-end to obtain a string for subsequent compilation and
execution. The reader uses the common stream package to read
data in large chunks, if possible. In interactive mode the lines
are processed one at a time. 

The MAL parser component turns the string into
an internal representation of the MAL program. 
During this phase semantic checks are performed, such that
we end up with a type correct program.

The code block is subsequently sent to an MAL optimizer.
In the default case the program is left untouched. For other languages, 
the optimizer deploys language specific code transformations,
e.g., foreign-key optimizations in joins and remote query execution.
All optimization information is statically derived from the
code blocks and possible catalogues maintained for the query language
at hand. Optimizers leave advice and their findings in properties
in the symbol table, see @ref{Property Management}.

Once the program has thus been refined, the
MAL scheduler prepares for execution using tactical optimizations.
For example, it may parallelize the code, generate an ad-hoc
user-defined function, or prepare for efficient replication management.
In the default case, the program is handed over to the MAL interpreter
without any further modification.

The final stage is to choose an execution paradigm,
i.e. interpretative (default), compilation of an ad-hoc user
defined function, dataflow driven interpretation,
or vectorized pipe-line execution by a dedicated engine.

A failure encountered in any of the steps terminates the scenario
cycle. It returns to the user for a new command.

@+ Scenario management
Scenarios are captured in modules; they can be dynamically loaded
and remain active until the system is brought to a halt.
The first time a scenario @sc{xyz} is used, the system looks for a scenario
initialization routine @sc{xyzinitSystem()} and executes it. 
It is typically used to prepare the server for language specific interactions.
Thereafter its components are set to those required by
the scenario and the client initialization takes place.

When the last user interested in a particular scenario leaves the
scene, we activate its finalization routine calling @sc{xyzexitSystem()}.
It typically perform cleanup, backup and monitoring functions.

A scenario is interpreted in a strictly linear fashion,
i.e. performing a symbolic optimization before scheduling decisions
are taken.
The routines associated with each state in
the scenario may patch the code so as to assure that subsequent
execution can use a different scenario, e.g., to handle dynamic
code fragments.

@{
The state of execution is maintained in the scenario record for
each individual client. Sharing this information between clients
should be dealt with in the implementation of the scenario managers.
Upon need, the client can postpone a session scenario by 
pushing a new one(language, optimize, tactic, 
processor). Propagation of the state information is
encapsulated a scenario2scenario() call. Not all transformations
may be legal.

@+ Scenario administration
Administration of scenarios follows the access rules 
defined for code modules in general.

@h

#ifndef _MAL_SCENARIO_H
#define _MAL_SCENARIO_H

#include "mal_import.h"

#define MAL_SCENARIO_READER 0
#define MAL_SCENARIO_PARSER  1
#define MAL_SCENARIO_OPTIMIZE 2
#define MAL_SCENARIO_SCHEDULER 3
#define MAL_SCENARIO_ENGINE 4
#define MAL_SCENARIO_INITCLIENT 5
#define MAL_SCENARIO_EXITCLIENT 6

/*#define MAL_SCENARIO_DEBUG*/
@-
The scenario descriptions contains all information to
implement the scenario. Each client gets a copy.
An exception or error detected while parsing is turned
into an exception and aborts the scenario.
@h
#define MAXSCEN 128

typedef struct SCENARIO {
	str name, language;
	str initSystem;
	MALfcn initSystemCmd;
	str exitSystem;
	MALfcn exitSystemCmd;
	str initClient;
	MALfcn initClientCmd;
	str exitClient;
	MALfcn exitClientCmd;
	str reader;
	MALfcn readerCmd;
	void *readerState;
	str parser;
	MALfcn parserCmd;
	void *parserState;
	str optimizer;
	MALfcn optimizerCmd;
	void *optimizerState;
	str tactics;
	MALfcn tacticsCmd;
	void *tacticsState;
	str engine;
	MALfcn engineCmd;
	void *engineState;
	struct SCENARIO *next;
} *Scenario;

mal_export str setScenario(Client c, str nme);
mal_export str runScenario(Client c);
mal_export str fillScenario(Client c, Scenario scen);
mal_export void clrScenario(Client c);
mal_export str getScenarioLanguage(Client c);
mal_export Scenario getFreeScenario(void);

mal_export str defaultScenario(Client c);	/* used in src/mal/mal_session.c */
mal_export void exitScenario(Client c);	/* used in src/mal/mal_session.c */
mal_export str initScenario(Client c, Scenario s);

mal_export void showCurrentScenario(void);
mal_export void showScenarioByName(stream *f, str s);
mal_export void showScenario(stream *f, Scenario s);
mal_export void showAllScenarios(stream *f);
mal_export void resetScenario(Client c);

mal_export Scenario findScenario(str nme);
mal_export void updateScenario(str scen, str nme, MALfcn fcn);

#endif /* _MAL_SCENARIO_H */
@-
@c
#include "mal_config.h"
#include "mal_scenario.h"
#include "mal_linker.h"		/* for getAddress() */
#include "mal_client.h"
#include "mal_authorize.h"
#include "mal_exception.h"

#ifdef HAVE_SYS_TIMES_H
# include <sys/times.h>
#endif

struct SCENARIO scenarioRec[MAXSCEN] = {
	{"mal", "mal",
	 0, 0,			/* hardwired MALinit*/
	 0, 0,			/* implicit */
	 "MALinitClient", (MALfcn) &MALinitClient,
	 "MALexitClient", (MALfcn) &MALexitClient,
	 "MALreader", (MALfcn) &MALreader, 0,
	 "MALparser", (MALfcn) &MALparser, 0,
	 "MALoptimizer", 0, 0,			
	 0, 0, 0,
	 "MALengine", (MALfcn) &MALengine, 0, 0},
	{0,0,			/* name */
	 0, 0,			/* init */
	 0, 0,			/* exit */
	 0, 0,			/* initClient */
	 0, 0,			/* exitClient */
	 0, 0, 0,		/* reader */
	 0, 0, 0,		/* parser */
	 0, 0, 0,		/* optimizer */
	 0, 0, 0,		/* scheduler */
	 0, 0, 0, 0		/* engine */
	 }
};

@-
Currently each user can define a new scenario, provided we have a free slot.
Scenarios not hardwired can always be dropped.
@c
Scenario
getFreeScenario()
{
	int i;
	Scenario scen = NULL;

	mal_set_lock(mal_contextLock, "Scenario");
	for (i = 0; i < MAXSCEN && scenarioRec[i].name; i++)
		;

	if (i == MAXSCEN) {
		showException(MAL,"freeScenario", "no scenario space left (%d); adjust MAXSCEN and recompile", MAXSCEN);
	} else {
		scen = scenarioRec + i;
	}
	mal_unset_lock(mal_contextLock, "Scenario");

	return scen;
}

@-
A scenario is initialized only once per session. 
All other requests are silently ignored. 
After initialization, all state functions should have been set.
Initialization includes searching for the scenario startup file in
the etc/MonetDB directory. This creates a dependency, because the
malInclude also needs a scenario. To break this cycle, the system should
call once the routine default scenario for each client first.
@c
str
initScenario(Client c, Scenario s)
{
	str l = s->language;
	str msg = MAL_SUCCEED;

	if (s->initSystemCmd)
		return(fillScenario(c, s));
	/* prepare for conclicts */
	mal_set_lock(mal_contextLock, "Scenario");
	if (s->initSystem && s->initSystemCmd == 0) {
		s->initSystemCmd = (MALfcn) getAddress(l, l, s->initSystem,1);
		if (s->initSystemCmd) {
			msg = (*s->initSystemCmd) (c);
		} else {
			char buf[BUFSIZ];
			snprintf(buf,BUFSIZ,"%s.init", l);
			msg = createException(MAL, buf, "Scenario not initialized"); 
		}
	}
	if (msg) {
		mal_unset_lock(mal_contextLock, "Scenario");
		return msg;
	}

	if (s->exitSystem && s->exitSystemCmd == 0) 
		s->exitSystemCmd = (MALfcn) getAddress(l, l, s->exitSystem,1);
	if (s->initClient && s->initClientCmd == 0) 
		s->initClientCmd = (MALfcn) getAddress(l, l, s->initClient,1);
	if (s->exitClient && s->exitClientCmd == 0) 
		s->exitClientCmd = (MALfcn) getAddress(l, l, s->exitClient,1);
	if (s->reader && s->readerCmd == 0) 
		s->readerCmd = (MALfcn) getAddress(l, l, s->reader,1);
	if (s->parser && s->parserCmd == 0) 
		s->parserCmd = (MALfcn) getAddress(l, l, s->parser,1);
	if (s->optimizer && s->optimizerCmd == 0) 
		s->optimizerCmd = (MALfcn) getAddress(l, l, s->optimizer,1);
	if (s->tactics && s->tacticsCmd == 0) 
		s->tacticsCmd = (MALfcn) getAddress(l, l, s->tactics,1);
	if (s->engine && s->engineCmd == 0) 
		s->engineCmd = (MALfcn) getAddress(l, l, s->engine,1);
	mal_unset_lock(mal_contextLock, "Scenario");
	return(fillScenario(c, s));
}

str
defaultScenario(Client c)
{
	return initScenario(c, scenarioRec);
}

@-
The Monet debugger provides an option to inspect the scenarios currently
defined.

@c
static void
print_scenarioCommand(stream *f, str cmd, MALfcn funcptr)
{
    if (cmd) 
	mnstr_printf(f," \"%s%s\",", cmd, (funcptr?"":"?"));
    else 
	mnstr_printf(f," nil,");
}

void
showScenario(stream *f, Scenario scen)
{
	mnstr_printf(f, "[ \"%s\",", scen->name);
	print_scenarioCommand(f, scen->initSystem, scen->initSystemCmd);
	print_scenarioCommand(f, scen->exitSystem, scen->exitSystemCmd);
	print_scenarioCommand(f, scen->initClient, scen->initClientCmd);
	print_scenarioCommand(f, scen->exitClient, scen->exitClientCmd);
	print_scenarioCommand(f, scen->parser, scen->parserCmd);
	print_scenarioCommand(f, scen->optimizer, scen->optimizerCmd);
	print_scenarioCommand(f, scen->tactics, scen->tacticsCmd);
	print_scenarioCommand(f, scen->engine, scen->engineCmd);
	mnstr_printf(f, "]\n");
}

Scenario
findScenario(str nme)
{
	int i;
	Scenario scen = scenarioRec;

	for (i = 0; i < MAXSCEN && scen->name; i++, scen++)
		if (strcmp(scen->name, nme) == 0)
			return scen;
	return NULL;
}

@-
Functions may become resolved only after the corresponding module
has been loaded. This should be announced as part of the module
prelude code.
Beware that after the update, we also have to adjust the client records.
They contain a copy of the functions addresses.
@c
void
updateScenario(str nme, str fnme, MALfcn fcn)
{
	int phase = -1;
	Scenario scen = findScenario(nme);

	if (scen->initSystem && strcmp(scen->initSystem, fnme) == 0) 
		scen->initSystemCmd = fcn;
	if (scen->exitSystem && strcmp(scen->exitSystem, fnme) == 0) 
		scen->exitSystemCmd = fcn;
	if (scen->initClient && strcmp(scen->initClient, fnme) == 0) {
		scen->initClientCmd = fcn;
		phase = MAL_SCENARIO_INITCLIENT;
	}
	if (scen->exitClient && strcmp(scen->exitClient, fnme) == 0) {
		scen->exitClientCmd = fcn;
		phase = MAL_SCENARIO_EXITCLIENT;
	}
	if (scen->reader && strcmp(scen->reader, fnme) == 0) {
		scen->readerCmd = fcn;
		phase = MAL_SCENARIO_READER;
	}
	if (scen->parser && strcmp(scen->parser, fnme) == 0) {
		scen->parserCmd = fcn;
		phase = MAL_SCENARIO_PARSER;
	}
	if (scen->optimizer && strcmp(scen->optimizer, fnme) == 0) {
		scen->optimizerCmd = fcn;
		phase = MAL_SCENARIO_OPTIMIZE;
	}
	if (scen->tactics && strcmp(scen->tactics, fnme) == 0) {
		scen->tacticsCmd = fcn;
		phase = MAL_SCENARIO_SCHEDULER;
	}
	if (scen->engine && strcmp(scen->engine, fnme) == 0) {
		scen->engineCmd = fcn;
		phase = MAL_SCENARIO_ENGINE;
	}
	if (phase != -1) {
		Client c1;

    		for(c1 = mal_clients; c1 < mal_clients+MAL_MAXCLIENTS; c1++) 
    			if (c1->scenario && 
			    strcmp(c1->scenario, scen->name) == 0)
				c1->phase[phase] = fcn;
			if (c1->oldscenario && 
			    strcmp(c1->oldscenario, scen->name) == 0)
				c1->oldphase[phase] = fcn;
	}
}

void
showScenarioByName(stream *f, str nme)
{
	Scenario scen = findScenario(nme);

	if (scen)
		showScenario(f, scen);
}

void
showAllScenarios(stream *f)
{
	int i;
	Scenario scen = scenarioRec;

	for (i = 0; i < MAXSCEN && scen->name; i++, scen++)
		showScenario(f, scen);
}

str getScenarioLanguage(Client c){
	Scenario scen= findScenario(c->scenario);
	if( scen) return scen->language;
	return "mal";
}
@-
Changing the scenario for a particular client invalidates the
state maintained for the previous scenario. The old scenario is
retained in the client record to facilitate propagation of 
state information, or to simply switch back to the previous one.
Before we initialize a scenario the client scenario is reset to
the MAL scenario. This implies that all scenarios are initialized
using the same scenario. After the scenario initialization file 
has been processed, the scenario phases are replaced with the
proper ones.

@-
All client records should be initialized with a default
scenario, i.e. the first described in the scenario table.
@c
str
fillScenario(Client c, Scenario scen)
{
	c->scenario = scen->name;

	c->phase[MAL_SCENARIO_READER] = scen->readerCmd;
	c->phase[MAL_SCENARIO_PARSER] = scen->parserCmd;
	c->phase[MAL_SCENARIO_OPTIMIZE] = scen->optimizerCmd;
	c->phase[MAL_SCENARIO_SCHEDULER] = scen->tacticsCmd;
	c->phase[MAL_SCENARIO_ENGINE] = scen->engineCmd;
	c->phase[MAL_SCENARIO_INITCLIENT] = scen->initClientCmd;
	c->phase[MAL_SCENARIO_EXITCLIENT] = scen->exitClientCmd;
	c->state[MAL_SCENARIO_READER] = 0;
	c->state[MAL_SCENARIO_PARSER] = 0;
	c->state[MAL_SCENARIO_OPTIMIZE] = 0;
	c->state[MAL_SCENARIO_SCHEDULER] = 0;
	c->state[MAL_SCENARIO_ENGINE] = 0;
	c->state[MAL_SCENARIO_INITCLIENT] = 0;
	c->state[MAL_SCENARIO_EXITCLIENT] = 0;
	return(MAL_SUCCEED);
}

void
clrScenario(Client c)
{
	if (c->scenario == 0)
		return;
	c->scenario = 0;
	c->phase[MAL_SCENARIO_READER] = 0;
	c->phase[MAL_SCENARIO_PARSER] = 0;
	c->phase[MAL_SCENARIO_OPTIMIZE] = 0;
	c->phase[MAL_SCENARIO_SCHEDULER] = 0;
	c->phase[MAL_SCENARIO_ENGINE] = 0;
	c->phase[MAL_SCENARIO_INITCLIENT] = 0;
	c->phase[MAL_SCENARIO_EXITCLIENT] = 0;
	c->state[MAL_SCENARIO_READER] = 0;
	c->state[MAL_SCENARIO_PARSER] = 0;
	c->state[MAL_SCENARIO_OPTIMIZE] = 0;
	c->state[MAL_SCENARIO_SCHEDULER] = 0;
	c->state[MAL_SCENARIO_ENGINE] = 0;
	c->state[MAL_SCENARIO_INITCLIENT] = 0;
	c->state[MAL_SCENARIO_EXITCLIENT] = 0;
}

@-
Setting a new scenario calls for saving the previous state
and execution of the initClientScenario routine.
@c
str
setScenario(Client c, str nme)
{
	int i;
	str msg;
	Scenario scen = scenarioRec;

	scen = findScenario(nme);
	if (scen == NULL)
		throw(MAL, "setScenario", SCENARIO_NOT_FOUND " '%s'", nme);

	if (c->scenario) {
		c->oldscenario = c->scenario;
		for (i = 0; i < 7; i++) {
			c->oldstate[i] = c->state[i];
			c->oldphase[i] = c->phase[i];
		}
	}
	for (i = 0; i < 7; i++)
		c->state[i] = 0;

	msg = initScenario(c, scen);
	if (msg) {
		/* error occurred, reset the scenario , assume default always works */
		c->scenario = c->oldscenario;
		for (i = 0; i < 7; i++) {
			c->state[i] = c->oldstate[i];
			c->phase[i] = c->oldphase[i];
			c->oldstate[i] = NULL;
			c->oldphase[i] = NULL;
		}
		c->oldscenario = NULL;
		return msg;
	}
	return MAL_SUCCEED;
}

@-
After finishing a session in a scenario, we should reset the
state of the previous one. But also call the exitClient
to garbage collect any scenario specific structures.
@c
str
getCurrentScenario(Client c)
{
	return c->scenario;
}

void
resetScenario(Client c)
{
	int i;
	Scenario scen = scenarioRec;

	if (c->scenario == 0)
		return;

	scen = findScenario(c->scenario);
	if (scen != NULL && scen->exitClientCmd)
		(*scen->exitClientCmd) (c);

	c->scenario = c->oldscenario;
	for (i = 0; i < 7; i++) {
		c->state[i] = c->oldstate[i];
		c->phase[i] = c->oldphase[i];
	}
	c->oldscenario = 0;
}

void
exitScenario(Client c)
{
	Scenario scen = scenarioRec;

	if (c->scenario == 0)
		return;
	scen = findScenario(c->scenario);
	if (scen->exitSystemCmd)
		(*scen->exitSystemCmd) (c);
	c->scenario = NULL;
}

@}
@- 
The building blocks of scenarios are routines obeying a strict
name signature. They require exclusive access to the client
record. Any specific information should be accessible from
there, e.g., access to a scenario specific state descriptor.
The client scenario initialization and finalization brackets
are  @sc{xyzinitClient()} and @sc{xyzexitClient()}.

The @sc{xyzparser(Client c)} contains the parser for language XYZ
and should fill the MAL program block associated with the client record.
The latter may have been initialized with variables. 
Each language parser may require a catalog with information
on the translation of language specific datastructures into their BAT
equivalent.

The @sc{xyzoptimizer(Client c)} contains language specific optimizations
using the MAL intermediate code as a starting point.

The @sc{xyztactics(Client c)} synchronizes the program execution with the
state of the machine, e.g., claiming resources, the history of the client 
or alignment of the request with concurrent actions (e.g., transaction
coordination).

The @sc{xyzengine(Client c)} contains the applicable back-end engine.
The default is the MAL interpreter, which provides good balance
between speed and ability to analysis its behavior.

@-
@{
@c
static str 
runPhase(Client c, int phase)
{
	str msg = MAL_SUCCEED;
	if (c->phase[c->stage = phase]) 
	    msg = (str) (*c->phase[phase])(c); 
	return msg;
}

@-
Access control enforcement. Except for the server owner
running a scenario should be explicitly permitted.
@c
static str
runScenarioBody(Client c)
{
	str msg= MAL_SUCCEED;
	lng start;
#ifdef HAVE_TIMES
	struct tms t0,t1;
#endif


	c->exception_buf_initialized = 1;
	if (setjmp( c->exception_buf) < 0) 
		c->mode = FINISHING;
#ifdef HAVE_TIMES
	times(&t0);
#endif
	while (c->mode > FINISHING || msg != MAL_SUCCEED) {
		if (msg != MAL_SUCCEED){
/* we should actually show it [postponed]
			mnstr_printf(c->fdout,"!%s\n",msg);
*/
			if (msg != M5OutOfMemory)
				GDKfree(msg);
			msg = MAL_SUCCEED;
		}
		if (!c->state[0] &&
		    (msg = runPhase(c, MAL_SCENARIO_INITCLIENT)) != MAL_SUCCEED)
			continue;
		if (c->mode <= FINISHING || 
		    (msg = runPhase(c, MAL_SCENARIO_READER)) != MAL_SUCCEED)
			continue;
		c->lastcmd= time(0);
		start= GDKusec();
		if (c->mode <= FINISHING ||
		    (msg = runPhase(c, MAL_SCENARIO_PARSER)) != MAL_SUCCEED)
			continue;
		if (c->mode <= FINISHING || 
		    (msg = runPhase(c, MAL_SCENARIO_OPTIMIZE)) != MAL_SUCCEED)
			continue;
		if (c->mode <= FINISHING || 
                    (msg = runPhase(c, MAL_SCENARIO_SCHEDULER)) != MAL_SUCCEED)
			continue;
		if (c->mode <= FINISHING || 
		    (msg = runPhase(c, MAL_SCENARIO_ENGINE)) != MAL_SUCCEED)
			continue;
		c->actions++;
		start = GDKusec()-start;
		c->totaltime += start;
#ifdef HAVE_TIMES
		times(&t1);
		c->workload.tms_utime += t1.tms_utime-t0.tms_utime;
		c->workload.tms_cutime += t1.tms_cutime-t0.tms_cutime;
		c->workload.tms_stime += t1.tms_stime-t0.tms_stime;
		c->workload.tms_cstime += t1.tms_cstime-t0.tms_cstime;
		t0 = t1;
#endif
	}
	if (c->phase[MAL_SCENARIO_EXITCLIENT])
		(*c->phase[MAL_SCENARIO_EXITCLIENT]) (c);
	c->exception_buf_initialized = 0;
	return msg;
}

str
runScenario(Client c)
{
	str msg = MAL_SUCCEED;

	if (c == 0 || c->phase[MAL_SCENARIO_READER] == 0) 
		return msg;
	msg = runScenarioBody(c);
	if (msg != MAL_SUCCEED && 
	    strcmp(msg,"MALException:client.quit:Server stopped."))
		mnstr_printf(c->fdout,"!%s\n",msg);
	return msg;
}

@-
@}
The contents of this file are subject to the MonetDB Public License
Version 1.1 (the "License"); you may not use this file except in
compliance with the License. You may obtain a copy of the License at
http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html

Software distributed under the License is distributed on an "AS IS"
basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations
under the License.

The Original Code is the MonetDB Database System.

The Initial Developer of the Original Code is CWI.
Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
Copyright August 2008-2011 MonetDB B.V.
All Rights Reserved.
@

@a M. Kersten
@v 1.0
@+ Type Resolution
Given the interpretative nature of many of the MAL instructions,
when and where type resolution takes place is a critical design issue.
Performing it too late, i.e. at each instruction call, leads to 
performance problems if we derive the same information over and over again.
However, many built-in operators have polymorphic typed signatures, 
so we cannot escape it altogether.

Consider the small illustrative MAL program:
@example
function sample(nme:str, val:any_1):bit;
   c := 2 * 3;
   b := bbp.bind(nme);  #find a BAT
   h := algebra.select(b,val,val);
   t := aggr.count(h);
   x := io.print(t);
   y := io.print(val);
end sample;
@end example
@-
The function definition is polymorphic typed on the 2nd argument,
it becomes a concrete type upon invocation. The system could attempt
a type check, but quickly runs into assumptions that generally do not hold.
The first assignment can be type checked during parsing
and a symbolic optimizer could even evaluate the expression once. 
Looking up a BAT in the buffer pool leads to
an element @sc{:bat[@emph{ht,tt}]} where @emph{ht} and @emph{tt}
are runtime dependent types, which means that the selection operation can
not be type-checked immediately. It is an example of an embedded
polypmorphic statement, which requires intervention of the user/optimizer
to make the type explicit before the type resolver becomes active.
The operation @sc{count} can be checked, if it is given a BAT argument. 
This assumes that we can infer that 'h' is indeed a BAT, which requires 
assurance that @sc{algebra.select} produces one. However, there are
no rules to avoid addition of new operators, or to differentiate among
different implementations based on the argument types.
Since @sc{print(t)} contains an undetermined typed
argument we should postpone typechecking as well.
The last print statement can be checked upon function invocation.

Life becomes really complex if the body contains a loop with 
variable types. For then we also have to keep track of the original
state of the function. Or alternatively, type checking should consider
the runtime stack rather than the function definition itself.

These examples give little room to achieve our prime objective, i.e.
a fast and early type resolution scheme. Any non-polymorphic function
can be type checked and marked type-safe upon completion.
Type checking polymorphic functions are post-poned until a concrete
type instance is known. It leads to a clone, which can be type checked
and is entered into the symbol table.
@{
The type resolution status is marked in each instruction.
TYPE_RESOLVED implies that the type of the instruction is fully
resolved, it is marked TYPE_DYNAMIC otherwise.

@h
#ifndef _MAL_RESOLVE_H
#define _MAL_RESOLVE_H

#include "mal_exception.h"
#include "mal_function.h"
#include "mal_exception.h"

/*
#define DEBUG_MAL_RESOLVE 1 
*/
#define MAXTYPEVAR  10

mal_export void chkProgram(Module s, MalBlkPtr mb);
mal_export void chkInstruction(Module s, MalBlkPtr mb, InstrPtr p);
mal_export void chkTypes(Module s, MalBlkPtr mb, int silent);
mal_export void typeChecker(Module scope, MalBlkPtr mb, InstrPtr p, int silent);
mal_export InstrPtr dynamicTypeChecker(Module scope,MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
mal_export int fcnBinder(Module scope, MalBlkPtr mb, InstrPtr p);

extern void typeMismatch(MalBlkPtr mb, InstrPtr p, int lhs, int rhs,int silent);
extern str traceFcnName;
mal_export void expandMacro(MalBlkPtr mb, InstrPtr p, MalBlkPtr mc);

#endif /*  _MAL_RESOLVE_H*/
@- Function call resolution
Search the first definition of the operator in the current module
and check the parameter types.
For a polymorphic MAL function we make a fully instantiated clone.
It will be prepended to the symbol list as it is more restrictive.
This effectively overloads the MAL procedure.

@c
#include "mal_config.h"
#include "mal_resolve.h"
#include "mal_namespace.h"

malType getPolyType(malType t, int *polytype);
int updateTypeMap(int formal, int actual, int polytype[MAXTYPEVAR]);
int typeKind(MalBlkPtr mb, InstrPtr p, int i);

#define MAXMALARG 256

str traceFcnName= "____";
int tracefcn;
int polyVector[MAXTYPEVAR];
void polyInit(){
	int i;
	for(i=0;i<MAXTYPEVAR;i++) polyVector[i]= TYPE_any;
}

malType findFunctionType(Module scope, MalBlkPtr mb, InstrPtr p,int silent){
	Module m;
	Symbol s;
	InstrPtr sig;
	int i,k, unmatched = 0, s1;
	/* int foundbutwrong=0;*/
	int polytype[MAXTYPEVAR];
	int *returntype;
@-
Within a module find the subscope to locate the element in its list
of symbols. A skiplist is used to speed up the search for the
definition of the function.

For the implementation we should be aware that over 90% of the
functions in the kernel have just a few arguments and a single
return value.
A point of concern is that polymorphic arithmetic operations
lead to an explosion in the symbol table. This increase the
loop to find a candidate.

Consider to collect the argument type into a separate structure, because
it will be looked up multiple types to resolve the instruction.[todo]
Simplify polytype using a map into the concrete argument table.
@c
	m= scope;
	s= m->subscope[(int)(getSubScope(getFunctionId(p)))];
	if( s == 0) return -1;
	while(s != NULL){   /* single scope element check */
	if( getFunctionId(p) != s->name  ){
		s= s->skip; continue;
	}
@-
Perform a strong type-check on the actual arguments. If it turns
out to be a polymorphic MAL function, we have to clone it. 
Provided the actual/formal parameters are compliant throughout
the function call.

Also look out for variable argument lists. This means that we
have to keep two iterators, one for the caller (i) and one for
the callee (k). Since a variable argument only occurs as the last one,
we simple avoid an increment when running out of formal arguments.

A call of the form (X1,..., Xi) := f(Y1,....,Yn) can be matched against
the function signature (B1,...,Bk):= f(A1,...,Am) where i==k , n<=m
and type(Ai)=type(Yi). Furthermore, the variables Xi obtain their type
from Bi (or type(Bi)==type(Xi)).
@c
	sig = getSignature(s); 
	unmatched = 0;

#ifdef DEBUG_MAL_RESOLVE
	if(tracefcn) {
	mnstr_printf(GDKout,"-->resolving\n");
	printInstruction(GDKout,mb,0,p,LIST_MAL_ALL);
	mnstr_printf(GDKout,"++> test against signature\n");
	printInstruction(GDKout,s->def,0,getSignature(s),LIST_MAL_ALL);
	mnstr_printf(GDKout," %s \n", sig->polymorphic?"polymorphic":"");
	}
#endif
@-
The simple case could be taken care of separately to speedup processing
However, it turned out not to make a big difference.
The first time we encounter a polymorphic argument in the
signature.
Subsequently, the polymorphic arguments update this table
and check for any type mismatches that might occur.
There are at most 2 type variables involved per argument
due to the limited type nesting permitted.
Note, each function returns at least one value.
@c
	if( sig->polymorphic ){
	int limit = sig->polymorphic;
	if( ! (sig->argc== p->argc ||
		(sig->argc<p->argc && sig->varargs & (VARARGS | VARRETS) )) 
	){
		s= s->peer; continue;
	}
	if( sig->retc != p->retc && !(sig->varargs & VARRETS)) {
		s= s->peer;
		continue;
	}
/*  if(polyVector[0]==0) polyInit();
	memcpy(polytype,polyVector, 2*sig->argc*sizeof(int)); */

	for(k=0; k< limit; k++) polytype[k] = TYPE_any;
@-
Most polymorphic functions don;t have a variable argument
list. So we save some instructions factoring this caise out.
Be careful, the variable number of return arguments should
be considered as well.
@c
	i= p->retc;
	/* first handle the variable argument list */
	for(k=sig->retc; i<p->argc; k++, i++){
		int actual = getArgType(mb,p,i);
		int formal = getArgType(s->def,sig,k);
		if (k == sig->argc-1 && sig->varargs & VARARGS)
			k--;
@-
Take care of variable argument lists. 
They are allowed as the last in the signature only.
Furthermore, for patterns if the formal type is 'any' then all remaining arguments 
are acceptable and detailed type analysis becomes part of the pattern 
implementation.
In all other cases the type should apply to all remaining arguments.
@c
		if (formal == actual)
			continue;
		if( updateTypeMap(formal, actual, polytype)){
			unmatched= i; 
		   break;
		}
		formal= getPolyType(formal,polytype);
@-
Collect the polymorphic types and resolve them.
If it fails, we know this isn;t the function we are
looking for.
@c
		if( resolveType( formal,actual) == -1 ){
			unmatched= i;
			break;
		}
	}
@-
The last argument/result type could be a polymorphic variable list. 
It should only be allowed for patterns, where it can deal with the stack.
If the type is specified as :any then any mix of arguments is allowed.
If the type is a new numbered type variable then the first element
in the list determines the required type of all.
@c
	  if( sig->varargs ) {
		if( sig->token != PATTERNsymbol )
			unmatched = i;
		else {
			/* resolve the arguments */
			for(; i<p->argc; i++){
				/* the type of the last one has already been set */
				int actual = getArgType(mb,p,i);
				int formal = getArgType(s->def,sig,k);
				if (k == sig->argc-1 && sig->varargs & VARARGS)
					k--;

				formal= getPolyType(formal,polytype);
				if( formal == actual || formal == TYPE_any) 
					continue;
				if( resolveType( formal,actual) == -1 ){
					unmatched= i;
					break;
				}
			}
		}
	  }
   } else {
@-
We have to check the argument types to determine a
possible match for the non-polymorphic case.
@c
		if( sig->argc != p->argc ||
			sig->retc != p->retc) {
			s= s->peer;
			continue;
		}
		for(i=p->retc;i<p->argc;i++){
			int actual = getArgType(mb,p,i);
			int formal = getArgType(s->def,sig,i);
			if( resolveType(formal,actual) == -1 ){
#ifdef DEBUG_MAL_RESOLVE
			mnstr_printf(GDKout,"unmatched %d formal %s actual %s\n",
				i, getTypeName(formal), getTypeName(actual));
#endif
				unmatched= i;
				break;
			}
		}
	}
@-
It is possible that you may have to coerce the value to another type.
We assume that coercions are explicit at the MAL
level. (e.g. var2:= var0:int). This avoids repeated type analysis
just before you execute a function.
An optimizer may at a later stage automatically insert such coercion requests.
@c
#ifdef DEBUG_MAL_RESOLVE
	if(tracefcn) {
		 mnstr_printf(GDKout,"finished %s.%s unmatched=%d polymorphic=%d %d\n",
			getModuleId(sig), getFunctionId(sig), unmatched, sig->polymorphic,p==sig);
		if( sig->polymorphic){
			int l;
			for(l=0;l<2*p->argc;l++) 
			if( polytype[l] != TYPE_any)
			mnstr_printf(GDKout,"poly %d %s\n",l,getTypeName(polytype[l]));
		}
		mnstr_printf(GDKout,"-->resolving\n");
		printInstruction(GDKout,mb,0,p,LIST_MAL_ALL);
		mnstr_printf(GDKout,"++> test against signature\n");
		printInstruction(GDKout,s->def,0,getSignature(s),LIST_MAL_ALL);
		mnstr_printf(GDKout,"\nmismatch unmatched %d test %s poly %s\n",
			unmatched, getTypeName(getArgType(mb,p,unmatched)),
			getTypeName(getArgType(s->def,sig,unmatched)));
	}
#endif
	if( unmatched) { s= s->peer; continue; }
@-
At this stage we know all arguments are type compatible with the
signature. 
We should assure that also the target variables have the proper types
or can inherit them from the signature. The result type vector should be
build separately first, because we may encounter an error later on.

If any of the arguments refer to a constraint type, any_x, then
the resulting type can not be determined.
@c
	s1 = 0;
	returntype= (int*) alloca(p->retc * sizeof(int));
	if( sig->polymorphic)
	for(k=i=0; i < p->retc; k++, i++){
		int actual = getArgType(mb,p,i);
		int formal = getArgType(s->def,sig,k);

		if (k== sig->retc-1 && sig->varargs & VARRETS) k--;

		s1= getPolyType(formal, polytype);

		returntype[i]= resolveType(s1,actual);
		if( returntype[i]== -1 ){
			s1= -1;
			break;
		}
	} else 
	/* check for non-polymorphic return */
	for( k = i=0; i < p->retc; i++){
		int actual = getArgType(mb,p,i);
		int formal = getArgType(s->def,sig,i);

		if (k== sig->retc-1 && sig->varargs & VARRETS) k--;

		if( actual== formal)
			returntype[i]= actual;
		else {
			returntype[i]= resolveType(formal,actual);
			if( returntype[i]== -1 ){
				s1= -1;
				break;
			}
		}
	}
	if(s1<0 ){
		/* if(getSignature(s)->token !=PATTERNsymbol) foundbutwrong++;*/
		s= s->peer; continue;
	}
@-
If the return types are correct, copy them in place. 
Beware that signatures should be left untouched, which
means that we may not overwrite any formal argument.
Using the knowledge dat the arguments occupy the header
of the symbol stack, it is easy to filter such errors.
Also mark all variables that are subject to garbage control.
Beware, this is not yet effectuated in the interpreter.
@c
	p->typechk= TYPE_RESOLVED;
	for(i=0;i<p->retc;i++) {
		int ts= returntype[i];
		if( isVarConstant(mb, getArg(p,i)) ){
			showScriptException( mb, getPC(mb,p), TYPE, "Assignment to constant");
			p->typechk= TYPE_UNKNOWN;
			mb->errors++;
			return -3;
		}
		if( !isVarFixed(mb,getArg(p,i)) && ts>=0) {
			setVarType(mb, getArg(p,i),ts);
			setVarFixed(mb, getArg(p,i));
		}
		@:prepostProcess(ts,i,mb)@
	}
@-
Also the arguments may contain constants
to be garbage collected.
@c
	for(i=p->retc;i<p->argc;i++) 
	if ( findGDKtype(getArgType(mb,p,i)) == TYPE_str ||
		 getArgType(mb,p,i) == TYPE_bat ||
		 isaBatType(getArgType(mb,p,i)) ||
	    (!isPolyType(getArgType(mb,p,i)) && getArgType(mb,p,i)< TYPE_any && 
             getArgType(mb,p,i)>=0 && ATOMstorage(getArgType(mb,p,i)) == TYPE_str)){
		getInstrPtr(mb,0)->gc |= GARBAGECONTROL;
		p->gc |= GARBAGECONTROL;
	}
@-
It may happen that an argument was still untyped and as a result of
the polymorphism matching became strongly typed. This should be
reflected in the symbol table. 
@c
	s1= returntype[0];  /* for those interested */
	/* foundbutwrong = 0;*/
@-
If the call refers to a polymorphic function, we
clone it to arrive at a bounded instance. Polymorphic patterns and
commands are responsible for type resolution themselves.
Note that cloning pre-supposes that the function being cloned
does not contain errors detected earlier in the process,
nor does it contain polymorphic actual arguments.
@c
	if( sig->polymorphic){ 
		int cnt=0;
		for(k=i=p->retc;i<p->argc;i++){
			int actual = getArgType(mb,p,i);
			if( isAnyExpression(actual)) cnt++;
		}
		if(cnt==0 && s->kind!= COMMANDsymbol && s->kind!=PATTERNsymbol ){
			s = cloneFunction(scope, s, mb,p);
			if( s->def->errors) return -3;
		}
	}
@-
We found the proper function. Copy some properties. In particular,
determine the calling strategy, i.e. FCNcall, CMDcall, FACcall, PATcall
Beware that polymorphic functions may produce type-incorrect clones.
This piece of code may be shared by the separate binder
@= bindFunction
	if (s->def->errors) {
		p->typechk = TYPE_UNKNOWN;
		mb->errors++;
		return -3;
	}
	if (p->token == ASSIGNsymbol) {
		switch (getSignature(s)->token) {
			case COMMANDsymbol:
				p->token = CMDcall;
				p->fcn = getSignature(s)->fcn;  /* C implementation mandatory */
				if (p->fcn == NULL) {
					showScriptException(mb, getPC(mb, p), TYPE,
							"object code for command %s.%s missing",
							p->modname, p->fcnname);
					p->typechk = TYPE_UNKNOWN;
					mb->errors++;
					return -3;
				}
				break;
			case PATTERNsymbol:
				p->token = PATcall;
				p->fcn = getSignature(s)->fcn;  /* C implementation optional */
				break;
			case FACTORYsymbol:
				p->token = FACcall;
				p->fcn = getSignature(s)->fcn;  /* C implementation optional */
				break;
			case FUNCTIONsymbol:
				p->token = FCNcall;
				if (getSignature(s)->fcn)
					p->fcn = getSignature(s)->fcn; /* C implementation optional */
				break;
			default: {
				if (!silent)
					showScriptException(mb, getPC(mb, p), MAL,
							"MALresolve: unexpected token type");
				mb->errors++;
				return -3;
			}
		}
		p->blk = s->def;
	}
@-
@c
	@:bindFunction@
@-
Since we now know the storage type of the receiving variable, we can
set the garbage collection flag.
@= prepostProcess
	if (findGDKtype(@1) == TYPE_bat ||
		 isaBatType(@1) ||
		findGDKtype(@1) == TYPE_str ||
	    (!isPolyType(@1) && @1< TYPE_any && 
             @1>=0 && ATOMstorage(@1) == TYPE_str)){
		getInstrPtr(@3,0)->gc |= GARBAGECONTROL;
		setVarCleanup(mb,getArg(p,@2));
		p->gc|= GARBAGECONTROL;
	}
@c
#ifdef DEBUG_MAL_RESOLVE
	if(tracefcn) {
		printInstruction(GDKout,mb,0mp,LIST_MAL_ALL);
		mnstr_printf(GDKout,"Finished matching\n");
	}
#endif
	return s1;
	} /* while */
@-
We haven;t found the correct function.  To ease debugging, we may reveal
that we found an instruction with the proper arguments, but that clashes
with one of the target variables.
@c
	/* foundbutwrong has not been changed, commented out code above
	if( foundbutwrong && !silent){
		showScriptException(mb, getPC(mb, p), TYPE,
			"type conflict in assignment");
	}
	*/
	return -3;
}

@- Type resolution algorithm.
Every actual argument of a function call should be type compatible
with the formal argument, and the function result type should be
compatible with the destination variable.
In both cases the 'receiving' variable may not be fully qualified,
i.e. of type 'any'. The type resolution algorithm creates the concrete
type for subsequent use.
@h
mal_export int resolveType(int dsttype, int srctype);
@c
int resolveType(int dsttype, int srctype){  
#ifdef DEBUG_MAL_RESOLVE
	if( tracefcn){
		mnstr_printf(GDKout,"resolveType dst %s (%d) %s(%d)\n",
			getTypeName(dsttype), dsttype,
			getTypeName(srctype),srctype);
	}
#endif
	if( dsttype == srctype) return dsttype;
	if( dsttype == TYPE_any) return srctype;
	if( srctype == TYPE_any) return dsttype;
@-
A bat reference can be coerced to bat type.
@c
	if(isaBatType(srctype) && dsttype == TYPE_bat) return srctype;
	if(isaBatType(dsttype) && srctype == TYPE_bat) return dsttype;
	if( isaBatType(dsttype) && isaBatType(srctype) ){
		int h1,t1,h2,t2,h3,t3;
		h1= getHeadType(dsttype);
		h2= getHeadType(srctype);
		if( h1 == h2) h3= h1; else
		if( h1 == TYPE_any) h3= h2; else
		if( h2 == TYPE_any) h3= h1; 
		else {
#ifdef DEBUG_MAL_RESOLVE
			if(tracefcn) mnstr_printf(GDKout,"Head can not be resolved \n");
#endif
			return -1;
		}
		t1= getTailType(dsttype);
		t2= getTailType(srctype);
		if( t1 == t2) t3= t1; else
		if( t1 == TYPE_any) t3= t2; else
		if( t2 == TYPE_any) t3= t1;
		else {
#ifdef DEBUG_MAL_RESOLVE
			if(tracefcn) mnstr_printf(GDKout,"Tail can not be resolved \n");
#endif
			return -1;
		}
#ifdef DEBUG_MAL_RESOLVE
		if( tracefcn){
			int i1=getHeadIndex(dsttype);
			int i2= getTailIndex(dsttype);
		mnstr_printf(GDKout,"resolved to bat[:%s,:%s] bat[:%s,:%s]->bat[%s:%d,%s:%d]\n",
			getTypeName(h1),getTypeName(t1),
			getTypeName(h2),getTypeName(t2),
			getTypeName(h3),i1,getTypeName(t3),i2
			);
		}
#endif
		return newBatType(h3,t3);
	}
#ifdef DEBUG_MAL_RESOLVE
	if(tracefcn) mnstr_printf(GDKout,"Can not be resolved \n");
#endif
	return -1;
}

@-
We try to clear the type check flag by looking up the
functions. Errors are simply ignored at this point of the game,
because they may be resolved as part of the calling sequence.
@c
void typeMismatch(MalBlkPtr mb, InstrPtr p, int lhs, int rhs, int silent){
	str n1;
	str n2;

	if (!silent) {
		n1 = getTypeName(lhs);
		n2 = getTypeName(rhs);
		showScriptException(mb, getPC(mb, p), TYPE, 
				"type mismatch %s := %s", n1, n2);
		GDKfree(n1);
		GDKfree(n2);
	}
	mb->errors++;
	p->typechk= TYPE_UNKNOWN;
}
@-
A function search should inspect all modules unless a specific module
is given. Preference is given to the lower scopes.
The type check is set to TYPE_UNKNOWN first to enforce a proper
analysis. This way it forms a cheap mechanism to resolve
the type after a change by an optimizer.
If we can not find the function, the type check returns unsuccesfully.
In this case we should issue an error message to the user.

A re-check after the optimizer call should reset the token
to assignment.
@c
void typeChecker(Module scope, MalBlkPtr mb, InstrPtr p,int silent){
	int s1= -1, i,k, olderrors;
	Module m=0;

	p->typechk= TYPE_UNKNOWN;
	olderrors= mb->errors;
	if( p->fcn && p->token>= FCNcall && p->token<= PATcall){
		p->token= ASSIGNsymbol;
		p->fcn = NULL;
		p->blk = NULL;
	}

	if( isaSignature(p) ) {
		for(k=0;k<p->argc;k++)
			setVarFixed(mb,getArg(p,k));
		for(k=p->retc;k<p->argc;k++){
			@:prepostProcess(getArgType(mb,p,k),k,mb)@
		}
		p->typechk= TYPE_RESOLVED;
		for(k=0; k<p->retc;k++)
			p->typechk = MIN(p->typechk,typeKind(mb,p,0));
		return;
	}
	if( getFunctionId(p) && getModuleId(p)){
#ifdef DEBUG_MAL_RESOLVE
		tracefcn= idcmp(getFunctionId(p),traceFcnName)==0;
#endif
		m= findModule(scope,getModuleId(p));
		s1= findFunctionType(m,mb,p,silent);
		if( s1>= 0) return;
@-
Could not find a function that statisfies the constraints.
If the instruction is just a function header we may continue.
Likewise, the function and module may refer to string variables
known only at runtime.

In all other cases we should generate a message, but only if we know
that the error was not caused by checking the definition
of a polymorphic function or the module or function name are variables,
In those cases, the detailed analysis is performed upon an actual call.
@c
		if( ! isaSignature(p) && !getInstrPtr(mb,0)->polymorphic )  {
			mb->errors++;
			if( !silent) {
				char errsig[BUFSIZ];

				instructionCall(mb,p,errsig,errsig,BUFSIZ);
				showScriptException(mb,getPC(mb,p),TYPE,
						"'%s%s%s' undefined in: %s", 
						(getModuleId(p)?getModuleId(p):""),
						(getModuleId(p)?".":""),
						getFunctionId(p), errsig);
			} else
				mb->errors= olderrors;
			p->typechk= TYPE_UNKNOWN;
		} else p->typechk= TYPE_RESOLVED;
		return;
	}
@- Assignment 
When we arrive here the operator is an assignment.
The language should also recognize (a,b):=(1,2);
This is achieved by propagation of the rhs types to the lhs
variables.
@c
	if( getFunctionId(p) ) return;
	if( p->retc >= 1 && p->argc > p->retc && p->argc != 2 * p->retc){
		if ( !silent)
			showScriptException( mb, getPC(mb,p), TYPE,
				"Multiple assignment mismatch");
		mb->errors++;
	} else
		p->typechk= TYPE_RESOLVED;
	for(k=0,i= p->retc; k<p->retc && i<p->argc; i++,k++){
		int rhs = getArgType(mb,p,i);
		int lhs = getArgType(mb,p,k);

		if( rhs != TYPE_void){
			s1= resolveType(lhs,rhs);
			if( s1== -1 ){
				typeMismatch(mb,p,lhs,rhs,silent);
				return;
			}
		} else 
@-
The language permits assignment of 'nil' to any variable,
using the target type.
@c
		if( lhs != TYPE_void && lhs != TYPE_any){
			ValRecord cst;
			cst.vtype= TYPE_void;
			cst.val.oval= void_nil;
			
			rhs= isaBatType(lhs)?TYPE_bat:lhs;
			p->argv[i]= defConstant(mb, rhs, &cst);
			rhs= lhs;
		} 

		if( !isVarFixed(mb,getArg(p,k))) {
			setVarType(mb,getArg(p,k),rhs);
			setVarFixed(mb,getArg(p,k));
		}
		@:prepostProcess(s1,i,mb)@
		@:prepostProcess(s1,k,mb)@
	}
	/* the case where we have no rhs */
	if (p->barrier && p->retc == p->argc)
	for( k=0; k<p->retc; k++){
		int tpe = getArgType(mb,p,k);
		if (findGDKtype(tpe) == TYPE_bat ||
			findGDKtype(tpe) == TYPE_str ||
			(!isPolyType(tpe) && tpe< TYPE_any && ATOMstorage(tpe) == TYPE_str))
			setVarCleanup(mb,getArg(p,k));
	}
}
@-
Typechecking instructions can be delegated to runtime. In particular, 
MAL allows module and function names to be represented by string variables.
The dynamic type checker uses these names and calls for a strong type
check. 
Since the typechecker has side-effects on the symbol table, 
subsequent replacements can not produce differently typed results.
This makes it possible to pass function names as arguments or to
collect them from a function table. The underlying signature remains
the same.
@c
InstrPtr dynamicTypeChecker(Module scope, MalBlkPtr mb, MalStkPtr stk, InstrPtr p){
	InstrPtr pci;
	int i;

	mnstr_printf(GDKout,"Start dynamic type check on:\n");
	printInstruction(GDKout, mb, 0, p,LIST_MAL_ALL);

	pci = copyInstruction(p);
	if( getFunctionId(pci) && (i=findVariable(mb,getFunctionId(pci))) != -1){
		if( getVarType(mb,i) != TYPE_str)
			setFunctionId(pci, 0);
		else 
			setFunctionId(pci,putName( stk->stk[i].val.sval,
						strlen(stk->stk[i].val.sval)));
	}
	if( getModuleId(pci) && (i=findVariable(mb,getModuleId(pci))) != -1){
		if( getVarType(mb,i) != TYPE_str)
				setModuleId(pci, NULL);
		else {
				setModuleScope(pci, findModule(scope, stk->stk[i].val.sval));
		}
	}
	typeChecker(scope, mb,pci,FALSE);
#ifdef DEBUG_MAL_RESOLVE
	mnstr_printf(GDKout,"type checked version:\n");
	printInstruction(GDKout, mb, 0, pci,LIST_MAL_ALL);
#endif

	return pci;
}
@- Function binder
In some cases the front-end may already assure type correctness
of the MAL instruction generated (e.g. the SQL front-end)
In that case we merely have to locate the function address and
finalize the code for execution. Beware that we should be able to
distinguish the function by module name, function name, and
number of arguments only. Whether this is sufficient remains
to be seen. 
@c
int fcnBinder(Module scope, MalBlkPtr mb, InstrPtr p){
	Module m=0;
	Symbol s;
	int silent=FALSE;

	if( p->token != ASSIGNsymbol) return 0;
	if( getModuleId(p)== NULL || getFunctionId(p)== NULL) return 0;
	for(m= findModule(scope,getModuleId(p)); m; m= m->outer)
	if( m->name == getModuleId(p) ) {
		s= m->subscope[(int)(getSubScope(getFunctionId(p)))];
		for(; s; s= s->peer)
		if( getFunctionId(p)==s->name &&
			p->argc == getSignature(s)->argc ){
			/* found it */
			@:bindFunction@
		}
	}
	return 0;
}
@-
After the parser finishes, we have to look for semantic errors,
such as flow of control problems and possible typeing conflicts.
The nesting of BARRIER and CATCH statements with their associated
flow of control primitives LEAVE and RETRY should form a valid
hierarchy. Failure to comply is considered a structural error
and leads to flagging the function as erroneous.
Also check general conformaty of the ML block structure.
It should start with a signature and finish with and ENDsymbol
@-
Type checking a program is limited to those instructions that are
not resolved yet. Once the program is completely checked, further calls
should be ignored. This should be separately administered for the flow
as well, because a dynamically typed instruction should later on not
lead to a re-check when it was already fully analysed.
@c
void chkTypes(Module s, MalBlkPtr mb, int silent){
	InstrPtr p=0;
	int i, chk=0;

	for(i=0;i<mb->stop;i++) {
		p= getInstrPtr(mb,i);
		if(p== NULL) continue;
		typeChecker(s,mb,p,silent);

		if( getFunctionId(p) ){
			if(p->fcn != NULL && p->typechk== TYPE_RESOLVED) chk++;
		} else
		if( p->typechk== TYPE_RESOLVED) chk++;
	}
}
@-
Type checking an individual instruction is dangerous,
because it ignores data flow and declarations issues.
It is only to be used in isolated cases.
@c
void chkInstruction(Module s, MalBlkPtr mb, InstrPtr p){
	typeChecker(s,mb,p, FALSE);
}
void chkProgram(Module s, MalBlkPtr mb)
{
/* it is not ready yet, too fragile
		mb->typefixed = mb->stop == chk; ignored END */
/*	if( mb->flowfixed == 0)*/

	chkTypes(s,mb, FALSE);
	chkFlow(mb);
	chkDeclarations(mb);
	/* malGarbageCollector(mb);*/
}
@- Polymorphic type analysis
MAL provides for type variables of the form any$N. This feature
supports polymorphic types, but also complicates the subsequent
analysis. A variable typed with any$N not occuring in the function
header leads to a dynamic typed statement. In principle we have
to type check the function upon each call.
@c
int typeKind(MalBlkPtr mb, InstrPtr p, int i){
	malType t= getArgType(mb,p,i);
	if(t == TYPE_any || isAnyExpression(t) ) {
		return TYPE_UNKNOWN;
	}
	return TYPE_RESOLVED;
}
@-
For a polymorphic commands we do not generate a cloned version.
It suffices to determine the actual return value taking into
account the type variable constraints.
@c
malType getPolyType(malType t,int *polytype){
	int hi,ti;
	int head, tail;

	ti = getTailIndex(t);
	if( !isaBatType(t) && ti > 0 )
		return polytype[ti];

	tail= ti == 0? getTailType(t): polytype[ti];
	if( isaBatType(t)){
		hi = getHeadIndex(t);
		head= hi == 0 ? getHeadType(t): polytype[hi];
		return newBatType(head,tail);
	}
	return tail;
}
@-
Each argument is checked for binding of polymorphic arguments.
This routine assumes that the type index is indeed smaller than maxarg. 
(The parser currently enforces a single digit from 1-9 )
The polymorphic type 'any', i.e. any_0, does never constraint an operation
it can match with all polymorphic types.
The routine returns the instanciated formal type for subsequent
type resolution.
@c
int updateTypeMap(int formal, int actual, int polytype[MAXTYPEVAR])
{
	int h,t,ret=0;

	if( formal== TYPE_bat && isaBatType(actual) ) return 0;
#ifdef DEBUG_MAL_RESOLVE
	mnstr_printf(GDKout,"updateTypeMap:");
	mnstr_printf(GDKout,"formal %s ", getTypeName(formal));
	mnstr_printf(GDKout,"actual %s\n", getTypeName(actual));
#endif

	if( (h=getTailIndex(formal))  ){
		if( isaBatType(actual) && !isaBatType(formal) && 
		   (polytype[h]== TYPE_any || polytype[h]== actual)){
			polytype[h]= actual;
			ret=0;
			goto updLabel;
		}
		t= getTailType(actual);
		if( t != polytype[h]){
			if( polytype[h]== TYPE_bat && isaBatType(actual))
				ret= 0;
			else
			if( polytype[h] == TYPE_any ) polytype[h]=  t;
			else {
				ret= -1;
				goto updLabel;
			}
		}
	}
	if( isaBatType(formal)){
		if(!isaBatType(actual) && actual!= TYPE_bat) return -1;
		if( (h=getHeadIndex(formal)) ){
			t= actual == TYPE_bat? actual: getHeadType(actual);
			if( t!= polytype[h]){
				if( polytype[h] == TYPE_any) polytype[h]= t;
				else {
					ret= -1;
					goto updLabel;
				}
			}
		}
	} 
updLabel:
#ifdef DEBUG_MAL_RESOLVE
	mnstr_printf(GDKout,"updateTypeMap returns: %d\n",ret);
#endif
	return ret;
}
@-
A completely different mechanism would have been to hardcode some of the mostly
occurring type checks. For example, the type checker for the instruction
bat.insert(b:bat[:any$1,:any$2],h:any$1,t:any$2):bat[:any$1,:any$2].
The disadvantage is an abundance of code and less efficient instruction
cache hits.

@}
