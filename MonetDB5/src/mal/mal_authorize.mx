@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2005 CWI.
@' All Rights Reserved.

@f mal_authorize
@a M. Kersten
@+ User authorization
The inner core of the system provides a basic authorization 
scheme. Authorization is coupled with running a scenario
or accessing the content of variable boxes.
A user may only run a scenario if this is explicitly permitted.

It can be used by routines as a first
line of defense against unauthorized access. They could 
augment it with their own persistent information for further
control.

The owner of the server and database is he who was able to
start the server in the first place. It puts him in a special
position. He may change the authorization information and view
the permission tables.
All other users are only allowed to change their password.

The implementation is straight forward.
It keeps a persistent BAT @code{user} around, which associates a
user id with a corresponding (encoded) password to their 
permissible scenarios.

@{

The implementation is straightforward. A memory mapped
BAT keeps the information for fast access. 
The guest accounts 'user' without password 
and monetdb/monetdb are  being added upon creation of this BAT.
This allows all known functionality to work.

The identity of the owner is not copied into this table purposely.

@h
#ifndef _MAL_AUTHORIZE_H
#define _MAL_AUTHORIZE_H

/* #define _DEBUG_AUTH_*/
#include "mal.h"
#include "mal_exception.h"
#include "mal_instruction.h"
#include "mal_client.h"

mal_export str MALinitClient(Client cntxt);
mal_export str introduceUser(str nme, str passwd, str scen );
mal_export str dropAllFromUser(str nme);
mal_export str dropUser(str nme, str scen );
mal_export int checkAuthorization(str nme, str passwd, str scen );
mal_export int isServerOwner(Client c);
mal_export str setNewPassword(str nme, str passwd, str newpasswd);
mal_export bat getAllPermissions();
mal_export bat getAllPasswords();

mal_export void setServerOwner(str o, str p);
mal_export void loadPermissions();
#endif /* _MAL_AUTHORIZE_H */
@-
@c
#include "mal_authorize.h"

static str owner=0;
static str passw=0;

void
setServerOwner(str o, str p){
	str u;
	if( owner || passw)
		GDKfatal("Attempt to reset server owner identity\n");
	if( o == NULL) {
		u= cuserid(NULL);
		if( u) owner= GDKstrdup(u);
	} else owner = 0;
	passw = p?p:"";
#ifdef _DEBUG_AUTH_
	printf("serverOwner=%s\n",owner);
#endif
	assert(owner != NULL);
}

@-
Localize the authorization table in the database.
If it does not exist, it is prepared.
Loading the users table can only start after the
GDK kernel has been initialized.
@c
static BAT *auth, *authrev;
static BAT *pass, *passrev;

void
loadPermissions(){
    BAT *b;

	if( auth ) return;
    b = BATdescriptor(BBPindex("users"));
    if (b== NULL){
		b = BATnew(TYPE_str, TYPE_str, 256);
		if (b == NULL)
			GDKfatal("mal: could not allocate user table.");

		BATkey(b, TRUE);
		BBPrename(b->batCacheid, "users");
		BATmode(b, PERSISTENT);
		BATcommit(b);
	}
	auth= b;
	authrev= BATmirror(b);
    b = BATdescriptor(BBPindex("password"));
    if (b== NULL){
		b = BATnew(TYPE_str, TYPE_str, 256);
		if (b == NULL)
			GDKfatal("mal: could not allocate user table.");

		BATkey(b, TRUE);
		BBPrename(b->batCacheid, "password");
		BATmode(b, PERSISTENT);
		BATcommit(b);
	}
	pass= b;
	passrev= BATmirror(b);
}

str
MALinitClient(Client c){
#ifdef _DEBUG_AUTH_
	printf("authorize %s:%s %s\n", c->user, c->password, c->scenario);
#endif
	if( strcmp(c->user,owner) == 0 &&
		strcmp( (c->password?c->password:""),passw) == 0 )
		return MAL_SUCCEED;
	return throwMessage("mal.authorize","Access not allowed");
}

str 
introduceUser(str nme, str passwd, str scen )
{
#ifdef _DEBUG_AUTH_
	printf("add user %s %s %s\n", nme,passwd,scen);
#endif
	loadPermissions();
	BUNins(pass, nme, passwd);
	BUNins(auth, nme, scen);
	return MAL_SUCCEED;
}

str
dropUser(str nme, str scen )
{
	BAT *b;
#ifdef _DEBUG_AUTH_
	printf("del user %s %s\n", nme,scen);
#endif
	b= BATselect(BATmirror(auth),nme,nme);
	b= BATselect(BATmirror(b),scen,scen);
	BATdel(auth,b);
	b= BATselect(BATmirror(auth),nme,nme);
	if( BATcount(b) == 0){
		b= BATselect(passrev,nme,nme);
		BATdel(passrev,b);
	}
	return MAL_SUCCEED;
}

str
dropAllFromUser(str nme)
{
	BAT *b;
#ifdef _DEBUG_AUTH_
	printf("del user %s \n", nme);
#endif
	b= BATselect(authrev,nme,nme);
	BATdel(authrev,b);
	b= BATselect(passrev,nme,nme);
	BATdel(passrev,b);
	return MAL_SUCCEED;
}

int
checkAuthorization(str nme, str passwd, str scen )
{
	BAT *b;
#ifdef _DEBUG_AUTH_
	printf("check user %s %s %s\n", nme,passwd,scen);
#endif
	b= BATselect(authrev,nme,nme);
	b= BATselect(BATmirror(b),scen,scen);
	if( BATcount(b) == 0) return FALSE;

	b= BATselect(passrev,nme,nme);
	b= BATselect(BATmirror(b),passwd,passwd);
	if( BATcount(b) == 0) return FALSE;
	return TRUE;
}

int
isServerOwner(Client c){
	return strcmp(c->user, cuserid(NULL)) == 0;
}

str
setNewPassword(str nme, str passwd, str newpasswd)
{
	BAT *b;
	printf("new password %s %s %s\n", nme,passwd,newpasswd);
#ifdef _DEBUG_AUTH_
#endif
	b= BATselect(passrev,nme,nme);
	b= BATselect(BATmirror(b),passwd,passwd);
	if( BATcount(b) == 0) 
		return throwMessage("clients.newPassword","Permission denied");

	BATdel(passrev,b);
	BUNins(pass,nme,newpasswd);
	return MAL_SUCCEED;
}

@-
The information can be obtained by the dba for inspection
@c
bat
getAllPermissions()
{
	BAT *b;
#ifdef _DEBUG_AUTH_
	printf("get authorizations \n");
#endif
	if( auth ){
		b= BATcopy(auth);
		BBPkeepref(b->batCacheid);
		return b->batCacheid;
	}
	return 0;
}
bat
getAllPasswords()
{
	BAT *b;
#ifdef _DEBUG_AUTH_
	printf("get authorizations \n");
#endif
	if( auth ){
		b= BATcopy(pass);
		BBPkeepref(b->batCacheid);
		return b->batCacheid;
	}
	return 0;
}
@}
