@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2006 CWI.
@' All Rights Reserved.

@f mal_authorize
@a M. Kersten, F. Groffen
@v 0.2
@+ Authorisation adminstration management
Authorisation of users is a key concept in protecting the server from
malicious and unauthorised users.  This file contains a number of
functions that administrate a set of BATs backing the authorisation
tables.

The implementation is based on three persistent BATs, which keep the
usernames, passwords and allowed scenarios for users of the server.

@h
#ifndef _MAL_AUTHORIZE_H
#define _MAL_AUTHORIZE_H

/* #define _DEBUG_AUTH_*/
#include "mal.h"
#include "mal_exception.h"
#include "mal_instruction.h"
#include "mal_client.h"

mal_export str AUTHcheckCredentials(oid *ret, str *user, str *passwd, str *challenge, str *algo, str *scenario);
mal_export str AUTHcheckUser(int *ret, str *user, str *passwd);
mal_export str AUTHaddUser(oid *ret, str *user, str *pass, bat *scenarios);
mal_export str AUTHremoveUser(str *username);
mal_export str AUTHchangeUsername(str *olduser, str *newuser);
mal_export str AUTHchangePassword(str *oldpass, str *passwd);
mal_export str AUTHsetPassword(str *username, str *passwd);
mal_export str AUTHaddScenario(str *username, str *scenario);
mal_export str AUTHremoveScenario(str *username, str *scenario);
mal_export str AUTHresolveUser(str *ret, oid *uid);
mal_export str AUTHgetUsername(str *ret);
mal_export str AUTHgetUsers(bat *ret, bat *scenarios);

mal_export str AUTHrequireAdmin(void);
mal_export str AUTHrequirteAdminOrUser(str *username);
mal_export str AUTHinitTables(void);

@-
Authorisation is based on a password.  The passwords are stored cyphered
in a BAT.  Access to this BAT should be prohibited from the MAL level,
but still, the passwords in it are to be stored cyphered with an
algorithm that has a decypher.  The database administrator can unlock
the BAT that stores the password (the vault) by supplying the master
password which is the key for the cypher algorithm.  The BAT will never
contain decyphered passwords, as they will be decyphered on the fly when
needed.  A locked vault means noone can log into the system, hence, the
vault needs to be unlocked as part of the server startup ritual.
@h
mal_export str AUTHunlockVault(str *password);

@-
To avoid the passwords from being sent over the wire in plain text
format, MAPI starts with sending a challenge with salt.  This salt
should be appended to the plain text password before it is hashed in
order to make the password unreadable for eavesdroppers.  The hash
algorithm used is specified by the client, and can be chosen from a
comma separated list offered by the server through the challenge
(protocol >=6).
@h
mal_export str AUTHgetHashAlgorithms(str *ret);

/* convenience macros */
#define throwIC(X, Y) throw("InvalidCredentialsException", X, Y);
#define throwICf(X, Y, A) throwf("InvalidCredentialsException", X, Y, A);

#endif /* _MAL_AUTHORIZE_H */
@-
@c
#include "mal_authorize.h"
#ifdef HAVE_UNISTD_H
#include <unistd.h>
#endif
#ifdef HAVE_CRYPT_H
#include <crypt.h>
#else
#if defined(HAVE_CRYPT) && defined(__MINGW32__)
_CRTIMP char * __cdecl crypt(const char *key, const char *salt);
#endif
#endif
#ifdef HAVE_OPENSSL
#include <openssl/sha.h>
#include <openssl/md5.h>
#endif


static str AUTHdecypherValue(str *ret, str *value);
static str AUTHcypherValue(str *ret, str *value);
static str AUTHhashPassword(str *ret, str *algo, str *passwd, str *challenge);

static BAT *user = NULL;
static BAT *pass = NULL;
static BAT *scen = NULL;

/**
 * Requires the current client to be the admin user.  If not the case,
 * this function returns an InvalidCredentialsException.
 */
str
AUTHrequireAdmin() {
	oid id = MCgetClient()->user;

	if (id != 0) {
		char u[BUFSIZ]="";
		str user = u;
		str tmp;
		
		rethrow("requireAdmin", tmp, AUTHresolveUser(&user, &id));
		throwICf("requireAdmin", "Access denied for user '%s'", user)
	}

	return(MAL_SUCCEED);
}

/**
 * Requires the current client to be the admin user, or the user with
 * the given username.  If not the case, this function returns an
 * InvalidCredentialsException.
 */
str
AUTHrequireAdminOrUser(str *username) {
	oid id = MCgetClient()->user;
	char u[BUFSIZ]= "";
	str user = u;
	str tmp= MAL_SUCCEED;

	/* root?  then all is well */
	if (id == 0) return(MAL_SUCCEED);

	rethrow("requireAdminOrUser", tmp, AUTHresolveUser(&user, &id));
	if (username == NULL || *username == NULL || strcmp(*username, user) != 0) {
		throwICf("requireAdminOrUser", "Access denied for user '%s'", user);
	}

	return(MAL_SUCCEED);
}

@-
Localize the authorization tables in the database.  The authorization
tables are a set of aligned BATs that store username, password (hashed)
and scenario permissions.
If the BATs do not exist, they are created, and the monetdb/monetdb
administrator account is added.  Initialising the authorization tables
can only be done after the GDK kernel has been initialized.
@c
void
AUTHcommit() {
	BAT *b = BATnew(TYPE_void, TYPE_str, 3);
	assert(b);

	assert(user);
	BUNappend(b, BATgetId(user), FALSE);
	assert(pass);
	BUNappend(b, BATgetId(pass), FALSE);
	assert(pass);
	BUNappend(b, BATgetId(scen), FALSE);
	TMsubcommit(b);
	BBPreclaim(b);
}

str
AUTHinitTables() {
	bat bid;
	BAT *b;
	int isNew = 1;

	/* skip loading if already loaded */
	if (user != NULL && pass != NULL && scen != NULL)
		return(MAL_SUCCEED);

	/* if one is not NULL here, something is seriously screwed up */
	assert (user == NULL);
	assert (pass == NULL);
	assert (scen == NULL);

	/* load/create users BAT */
	bid = BBPindex("M5system_auth_user");
	if (!bid) {
		b = BATnew(TYPE_oid, TYPE_str, 256);
		if (b == NULL)
			throwMal("initTables", "could not allocate user table");

		BATkey(BATmirror(b), TRUE);
		BBPrename(BBPcacheid(b), "M5system_auth_user");
		BATmode(b, PERSISTENT);
	} else {
		b = BATdescriptor(bid);
		isNew = 0;
	}	
	assert(b);
	user = b;

	/* load/create password BAT */
	bid = BBPindex("M5system_auth_passwd");
	if (!bid) {
		b = BATnew(TYPE_oid, TYPE_str, 256);
		if (b == NULL)
			throwMal("initTables", "could not allocate password table");

		BBPrename(BBPcacheid(b), "M5system_auth_passwd");
		BATmode(b, PERSISTENT);
	} else {
		b = BATdescriptor(bid);
		isNew = 0;
	}
	assert(b);
	pass = b;

	/* load/create scenario BAT */
	bid = BBPindex("M5system_auth_scen");
	if (!bid) {
		b = BATnew(TYPE_oid, TYPE_str, 256);
		if (b == NULL)
			throwMal("initTables", "could not allocate scenario table");

		BATkey(b, TRUE);
		BBPrename(BBPcacheid(b), "M5system_auth_scen");
		BATmode(b, PERSISTENT);
	} else {
		b = BATdescriptor(bid);
		isNew = 0;
	}
	assert(b);
	scen = b;

	if (isNew == 1) {
		/* insert the monetdb/monetdb administrator account on a
		 * complete fresh and new auth tables system */
		str user = "monetdb";
		str pass = "monetdb";
		bat b = bat_nil;
		str tmp;
		oid uid;

		rethrow("initTables", tmp, AUTHaddUser(&uid, &user, &pass, &b));
		if (uid != 0)
			throwMal("initTables", "authorisation BATs not empty, but they were just created !?!?!?");
		AUTHcommit();
	}

	return(MAL_SUCCEED);
}

/**
 * Check if the user/password combination aligns with
 * a given uid.
*/

str
AUTHcheckUser(
	int *ret,
	str *username,
	str *passwd)
{

	/* to be filled */
	(void) username; (void) passwd;
	*ret =1;
	return MAL_SUCCEED;
}

/**
 * Checks the credentials supplied and throws an exception if invalid.
 * The user id of the authenticated user is returned upon success.
 */
str
AUTHcheckCredentials(
		oid *uid,
		str *username,
		str *passwd,
		str *challenge,
		str *algo,
		str *scenario)
{
	str tmp;
	str pwd;
	str hash;
	BAT *b;
	BUN p, q;
	oid *id;

	rethrow("checkCredentials", tmp, AUTHrequireAdminOrUser(username));
	assert(user);
	assert(pass);
	assert(scen);

	if (*username == NULL || strNil(*username))
		throwIC("checkCredentials", "Invalid credentials for unknown user");

	p = BUNfnd(BATmirror(user), *username);
	if (p == NULL) {
		/* DO NOT reveal that the user doesn't exist here! */
		throwICf("checkCredentials", "Invalid credentials for user '%s'",
				*username);
	}
	id = (oid*)(BUNhead(user, p));

	/* a NULL password is impossible (since we should be dealing with
	 * hashes here) so we can bail out immediately
	 */
	if (*passwd == NULL || strNil(*passwd)) {
		/* DO NOT reveal that the password is NULL here! */
		throwICf("checkCredentials", "Invalid credentials for user '%s'",
				*username);
	}

	/* find the corresponding password to the user */
	q = BUNfnd(pass, id);
	assert (q != NULL);
	tmp = (str)BUNtail(pass, q);
	assert (tmp != NULL);
	/* decypher the password (we lose the original tmp here) */
	rethrow("checkCredentials", tmp, AUTHdecypherValue(&pwd, &tmp));
	/* generate the hash as the client should have done */
	rethrow("checkCredentials", tmp, AUTHhashPassword(&hash, algo, &pwd, challenge));
	/* and now we have it, compare it to what was given to us */
	if (strcmp(*passwd, hash) != 0) {
		/* of course we DO NOT print the password here */
		throwICf("checkCredentials", "Invalid credentials for user '%s'",
				*username);
	}

	/* now see if the scenario is permitted (if restrictions for that
	 * apply)
	 */
	b = BATselect(scen, id, id);
	if (b && BATcount(b) > 0) {
		if (*scenario == NULL || strNil(*scenario)) {
			/* of course we DO NOT tell the exact reason here again */
			throwICf("checkCredentials", "Invalid credentials for user '%s'",
					*username);
		}

		/* ok, there are some tuples that we have to consider */
		BATloop(b, p, q) {
			tmp = (str)BUNtail(b, p);
			assert (tmp != NULL);
			if (strcmp(*scenario, tmp) == 0) {
				/* YAY!  fun!  party!  We are granted access! */
				*uid = *id;
				return(MAL_SUCCEED);
			}
		}

		/* uh oh... that we made it till here means it's wrong */
		throwICf("checkCredentials", "Invalid credentials for user '%s'",
				*username);
	} else {
		/* no scenario restriction applies, so everything is good */
		*uid = *id;
		return(MAL_SUCCEED);
	}
}

/**
 * Adds the given user with password to the administration.  The scens
 * BAT contains all scenarios allowed for the user.  If NULL or empty,
 * no restrictions for a scenario applies.  The return value of this
 * function is the user id of the added user.
 */
str
AUTHaddUser(oid *uid, str *username, str *passwd, bat *scenarios) {
	BUN p, q;
	BAT *b;
	oid *id;
	str tmp;
	str hash;

	rethrow("addUser", tmp, AUTHrequireAdmin());
	assert(user);
	assert(pass);
	assert(scen);
	
	/* some pre-condition checks */
	if (*username == NULL || strNil(*username))
		throwIllArg("addUser", "username cannot be nil");
	if (*passwd == NULL || strNil(*passwd))
		throwIllArg("addUser", "password cannot be nil");

	/* ensure that the username is not already there */
	p = BUNfnd(BATmirror(user), *username);
	if (p != NULL)
		throwMalf("addUser", "user '%s' already exists", *username);
	
	/* we assume the BATs are still aligned */
	rethrow("addUser", tmp, AUTHcypherValue(&hash, passwd));
	/* needs force, as SQL makes a view over user */
	BUNappend(user, *username, TRUE);
	BUNappend(pass, hash, FALSE);	/* should always be private! */
	/* retrieve the oid of the just inserted user */
	p = BUNfnd(BATmirror(user), *username);
	assert (p != NULL);
	id = (oid*)(BUNhead(user, p));

	if (*scenarios != bat_nil) {
		b = BATdescriptor(*scenarios);
		if (b == NULL) {
			BATundo(user);
			BATundo(pass);
			throwIllArg("addUser", "invalid BAT!");
		}
		if (b->htype != TYPE_str) {
			BATundo(user);
			BATundo(pass);
			throwIllArg("addUser", "BAT should have str head");
		}

		/* associate scenarios given in the BAT with the user */
		if (BATcount(b) > 0) {
			BATloop(b, p, q) {
				/* needs force, as sql makes a view over it */
				BUNins(scen, id, BUNhead(b, p), TRUE);
			}
		}
	}

	/* make the stuff persistent */
	AUTHcommit();

	*uid = *id;
	return(MAL_SUCCEED);
}

/**
 * Removes the given user from the administration.  All scenarios (if
 * any) and the password are removed as well.
 */
str
AUTHremoveUser(str *username) {
	BUN p;
	BAT *b;
	oid id;
	str tmp;

	rethrow("removeUser", tmp, AUTHrequireAdmin());
	assert(user);
	assert(pass);
	assert(scen);

	/* pre-condition check */
	if (*username == NULL || strNil(*username))
		throwIllArg("removeUser", "username cannot be nil");

	/* ensure that the username exists */
	p = BUNfnd(BATmirror(user), *username);
	if (p == NULL)
		throwMalf("removeUser", "no such user: '%s'", *username);
	id = *(oid*)(BUNhead(user, p));

	/* find the name of the administrator and see if it equals username */
	if (id == MCgetClient()->user)
		throwMal("removeUser", "cannot remove yourself");

	/* now, we got the oid, start removing the related tuples */
	b = BATmirror(BATselect(BATmirror(user), &id, &id));
	assert(BATcount(b) != 0);
	BATdel(user, b, TRUE);
	b = BATmirror(BATselect(BATmirror(pass), &id, &id));
	assert(BATcount(b) != 0);
	BATdel(pass, b, FALSE);
	b = BATmirror(BATselect(BATmirror(scen), &id, &id));
	BATdel(scen, b, TRUE);

	/* make the stuff persistent */
	AUTHcommit();

	return(MAL_SUCCEED);
}

/**
 * Changes the username of the user indicated by olduser into newuser.
 * If the username is already in use, an exception is thrown and nothing
 * is modified.
 */
str
AUTHchangeUsername(str *olduser, str *newuser) {
	BUN p, q;
	str tmp;

	rethrow("addUser", tmp, AUTHrequireAdminOrUser(olduser));

	/* precondition checks */
	if (*olduser == NULL || strNil(*olduser))
		throwIllArg("changeUsername", "old username should not be nil");
	if (*newuser == NULL || strNil(*newuser))
		throwIllArg("changeUsername", "new username should not be nil");

	/* see if the olduser is valid */
	p = BUNfnd(BATmirror(user), *olduser);
	if (p == NULL)
		throwMalf("changeUsername", "user '%s' does not exist", *olduser);
	/* ... and if the newuser is not there yet */
	q = BUNfnd(BATmirror(user), *newuser);
	if (q != NULL)
		throwMalf("changeUsername", "user '%s' already exists", *newuser);

	/* ok, just do it! (with force, because sql makes view over it) */
	BUNinplace(BATmirror(user), p, *newuser, BUNhead(user, p), TRUE);
	AUTHcommit();

	return(MAL_SUCCEED);
}

/**
 * Changes the password of the current user to the given password.  The
 * old password must match the one stored before the new password is
 * set.
 */
str
AUTHchangePassword(str *oldpass, str *passwd) {
	BUN p;
	str tmp;
	str hash;
	oid id;

	/* precondition checks */
	if (*oldpass == NULL || strNil(*oldpass))
		throwIllArg("changePassword", "old password should not be nil");
	if (*passwd == NULL || strNil(*passwd))
		throwIllArg("changePassword", "password should not be nil");

	/* check the old password */
	id = MCgetClient()->user;
	p = BUNfnd(pass, &id);
	assert(p != NULL);
	tmp = BUNtail(pass, p);
	assert (tmp != NULL);
	if (strcmp(tmp, *oldpass) != 0)
		throwIC("changePassword", "Access denied");

	/* cypher the password */
	rethrow("setPassword", tmp, AUTHcypherValue(&hash, passwd));
	/* ok, just overwrite the password field for this user */
	BUNinplace(pass, p, BUNhead(pass, p), &hash, FALSE);
	AUTHcommit();

	return(MAL_SUCCEED);
}

/**
 * Changes the password of the given user to the given password.  This
 * function can be used by the administrator to reset the password for a
 * user.  Note that for the administrator to change its own password, it
 * cannot use this function for obvious reasons.
 */
str
AUTHsetPassword(str *username, str *passwd) {
	BUN p;
	str tmp;
	str hash;
	oid id;

	rethrow("setPassword", tmp, AUTHrequireAdmin());

	/* precondition checks */
	if (*username == NULL || strNil(*username))
		throwIllArg("setPassword", "username should not be nil");
	if (*passwd == NULL || strNil(*passwd))
		throwIllArg("setPassword", "password should not be nil");

	id = MCgetClient()->user;
	/* find the name of the administrator and see if it equals username */
	p = BUNfnd(user, &id);
	assert (p != NULL);
	tmp = BUNtail(user, p);
	assert (tmp != NULL);
	if (strcmp(tmp, *username) == 0)
		throwIC("setPassword", "The administrator cannot set its own password, use changePassword instead");

	/* see if the user is valid */
	p = BUNfnd(BATmirror(user), *username);
	if (p == NULL)
		throwMalf("setPassword", "no such user '%s'", *username);
	id = *(oid*)BUNhead(user, p);

	/* cypher the password */
	rethrow("setPassword", tmp, AUTHcypherValue(&hash, passwd));
	/* ok, just overwrite the password field for this user */
	p = BUNfnd(pass, &id);
	assert (p != NULL);
	BUNinplace(pass, p, BUNhead(pass, p), &hash, FALSE);
	AUTHcommit();

	return(MAL_SUCCEED);
}

/**
 * Adds the given scenario to the list of allowed scenarios for the
 * given user.  Note that this can result in unexpected behaviour when
 * there where previously no scenarios defined for the user (which means
 * all scenarios are permitted).
 */
str
AUTHaddScenario(str *username, str *scenario) {
	BUN p;
	str tmp;
	oid *id;
	BAT *b;

	rethrow("addScenario", tmp, AUTHrequireAdmin());

	/* precondition checks */
	if (*username == NULL || strNil(*username))
		throwIllArg("addScenario", "username should not be nil");
	if (*scenario == NULL || strNil(*scenario))
		throwIllArg("addScenario", "scenario should not be nil");

	/* see if the user is valid */
	p = BUNfnd(BATmirror(user), *username);
	if (p == NULL)
		throwMalf("addScenario", "user '%s' does not exist", *username);
	id = (oid*)BUNhead(user, p);

	/* see if this scenario is not already there */
	b = BATselect(BATmirror(scen), id, id);
	b = BATselect(BATmirror(b), *scenario, *scenario);
	if (BATcount(b) == 1)
		throwMalf("addScenario", "scenario '%s' already exists for user", *scenario);
	if (BATcount(b) > 1)
		throwMalf("addScenario", "inconsistent authorisation administration, scenario '%s' multiple times defined", *scenario);

	/* add the scenario for this user, use force as sql makes view over it */
	BUNins(scen, BUNhead(user, p), *scenario, TRUE);
	AUTHcommit();

	return(MAL_SUCCEED);
}

/**
 * Removes the given scenario from the list of allowed scenarios for the
 * given user.  Note that removing the last allowed scenario results in
 * the opposite effect: it will allow any scenario to be used.
 */
str
AUTHremoveScenario(str *username, str *scenario) {
	BUN p;
	BAT *b;
	oid *id;
	str tmp;

	rethrow("removeScenario", tmp, AUTHrequireAdmin());

	/* precondition checks */
	if (*username == NULL || strNil(*username))
		throwIllArg("removeScenario", "username should not be nil");
	if (*scenario == NULL || strNil(*scenario))
		throwIllArg("removeScenario", "scenario should not be nil");

	/* see if the user is valid */
	p = BUNfnd(BATmirror(user), *username);
	if (p == NULL)
		throwMalf("removeScenario", "user '%s' does not exist", *username);
	id = (oid*)BUNhead(user, p);

	/* see if the scenario is valid for this user */
	b = BATselect(BATmirror(scen), id, id);
	b = BATselect(BATmirror(b), *scenario, *scenario);
	if (BATcount(b) == 0)
		throwMalf("removeScenario", "scenario '%s' not found for user", *scenario);
	if (BATcount(b) > 1)
		throwMalf("removeScenario", "inconsistent authorisation administration, scenario '%s' multiple times defined", *scenario);

	/* ok, remove it */
	BATdel(scen, BATmirror(b), TRUE);
	AUTHcommit();

	return(MAL_SUCCEED);
}

/**
 * Resolves the given user id and returns the associated username.  If
 * the id is invalid, an exception is thrown.  The given pointer to the
 * username char buffer should be NULL if this function is supposed to
 * allocate memory for it.  If the pointer is pointing to an already
 * allocated buffer, it is supposed to be of size BUFSIZ.
 */
str
AUTHresolveUser(str *username, oid *uid) {
	BUN p;

	if (uid == NULL || *uid == oid_nil)
		throwIllArg("resolveUser", "userid should not be nil");
	
	p = BUNfnd(user, uid);
	if (p == NULL)
		throwMalf("resolveUser", "No such user with id: " OIDFMT, *uid);

	assert (username != NULL);

	if (*username == NULL) {
		*username = GDKstrdup((str)(BUNtail(user, p)));
	} else {
		snprintf(*username, BUFSIZ, "%s", (str)(BUNtail(user, p)));
	}

	return(MAL_SUCCEED);
}

/**
 * Returns the username of the current user.
 */
str
AUTHgetUsername(str *username) {
	BUN p;
	oid id;

	id = MCgetClient()->user;
	p = BUNfnd(user, &id);
	if (p == NULL) {
		GDKfatal("Internal error: user id that doesn't exist: " OIDFMT,
				MCgetClient()->user);
	}

	*username = BUNtail(user, p);
	return(MAL_SUCCEED);
}

/**
 * Returns a BAT with user names in the tail, and user ids in the head.
 * Only those users are returned that have access to all of the given
 * scenarios.
 */
str
AUTHgetUsers(bat *ret, bat *scenarios) {
	BAT *b, *r;
	str tmp;

	rethrow("getUsers", tmp, AUTHrequireAdmin());

	if (*scenarios != bat_nil) {
		b = BATdescriptor(*scenarios);
		if (b == NULL)
			throwIllArg("getUsers", "invalid BAT!");
		if (b->htype != TYPE_str)
			throwIllArg("getUsers", "BAT should have str head");

		if (BATcount(b) == 0) {
			/* we can simply copy the whole users table, as there is no
			 * selection */
			r = BATcopy(user, user->htype, user->ttype, FALSE);
		} else {
			BAT *t1;
			BAT *t2;
			
			/* we have to do some work in order to return the requested
			 * rows; only those that have the given scenario(s) (all of
			 * them) */

			/* all users with no scenarios are always in the return
			 * list, we find them by "inversing" the list of users
			 * *with* a scenario */
			t1 = BATkdiff(user, BATkunique(scen));
			
			/* find users with one or more scenarios in the given BAT */
			t2 = BATjoin(
					VIEWcombine(BATkunique(BATjoin(scen, b, BATcount(scen)))),
					user,
					BATcount(user)
				);

			/* the final result is the union of both (we can discard the
			 * tail, as they *should* be equal when the heads are equal
			 * too... */
			r = BATkunion(t1, t2);
		}
		BBPunfix(*scenarios);
	} else {
		r = BATcopy(user, user->htype, user->ttype, FALSE);
		BBPunfix(*scenarios);
	}

	*ret = BBPcacheid(r);
	return(NULL);
}


/*=== the vault ===*/

/* yep, the vault key is just stored in memory */
static str vaultKey = NULL;

/**
 * Unlocks the vault with the given password.  Since the password is
 * just the decypher key, it is not possible to directly check whether
 * the given password is correct.  If incorrect, however, all decypher
 * operations will probably fail or return an incorrect decyphered
 * value.
 */
str
AUTHunlockVault(str *password) {
	str tmp;

	rethrow("unlockVault", tmp, AUTHrequireAdmin());

	if (password == NULL || strNil(*password))
		throwIllArg("unlockVault", "password should not be nil");

	/* even though I think this function should be called only once, it
	 * is not of real extra efforts to avoid a mem-leak if it is used
	 * multiple times
	 */
	if (vaultKey != NULL)
		GDKfree(vaultKey);

	vaultKey = GDKstrdup(*password);
	return(MAL_SUCCEED);
}

/**
 * Decyphers a given value, using the vaultKey.  The returned value
 * might be incorrect if the vaultKey is incorrect or unset.  If the
 * cypher algorithm fails or detects an invalid password, it might throw
 * an exception.  The ret string is GDKmalloced, and should be GDKfreed
 * by the caller.
 */
static str
AUTHdecypherValue(str *ret, str *value) {
	/* Cyphering and decyphering can be done using many algorithms.
	 * Future requirements might want a stronger cypher than the XOR
	 * cypher chosen here.  It is left up to the implementor how to do
	 * that once those algoritms become available.  It could be
	 * #ifdef-ed or on if-basis depending on whether the cypher
	 * algorithm is a compile, or runtime option.  When necessary, this
	 * function could be extended with an extra argument that indicates
	 * the cypher algorithm.
	 */
	
	/* this is the XOR decypher implementation */
	str r = GDKmalloc(sizeof(char) * (strlen(*value) + 1));
	str w = r;
	str s = *value;
	int escaped = 0;
	/* we default to some garbage key, just to make password unreadable
	 * (a space would only uppercase the password) */
	int keylen = 0;

	if (vaultKey == NULL)
		throwMal("decypherValue", "The vault is still locked!");

	keylen = strlen(vaultKey);

	/* XOR all characters.  If we encounter a 'one' char after the XOR
	 * operation, it is an escape, so replace it with the next char. */
	for (; *s != '\0'; s++) {
		if (*s == '\1' && escaped == 0) {
			escaped = 1;
			continue;
		} else if (escaped != 0) {
			*s -= 1;
			escaped = 0;
		}
		*w = *s ^ vaultKey[(w - r) % keylen];
		w++;
	}
	*w = '\0';

	*ret = r;
	return(MAL_SUCCEED);
}

/**
 * Cyphers the given string using the vaultKey.  If the cypher algorithm
 * fails or detects an invalid password, it might throw an exception.
 * The ret string is GDKmalloced, and should be GDKfreed by the caller.
 */
static str
AUTHcypherValue(str *ret, str *value) {
	/* this is the XOR cypher implementation */
	str r = GDKmalloc(sizeof(char) * (strlen(*value) * 2 + 1));
	str w = r;
	str s = *value;
	/* we default to some garbage key, just to make password unreadable
	 * (a space would only uppercase the password) */
	int keylen = 0;

	if (vaultKey == NULL)
		throwMal("decypherValue", "The vault is still locked!");

	keylen = strlen(vaultKey);

	/* XOR all characters.  If we encounter a 'zero' char after the XOR
	 * operation, escape it with an 'one' char. */
	for (; *s != '\0'; s++) {
		*w = *s ^ vaultKey[(s - *value) % keylen];
		if (*w == '\0') {
			*w++ = '\1';
			*w = '\1';
		} else if (*w == '\1') {
			*w++ = '\1';
			*w = '\2';
		}
		w++;
	}
	*w = '\0';

	*ret = r;
	return(MAL_SUCCEED);
}

/**
 * Returns a comma separated list of supported hash algorithms.  The
 * returned string is GDKmalloced and should be GDKfreed.
 */
str
AUTHgetHashAlgorithms(str *ret) {
	/* currently, two "hashes" are available, crypt and plain.  The
	 * former is the UNIX crypt implementation, the latter is no hash at
	 * all, as the name already suggests.  Future implementations could
	 * include better hashes such as MD5, SHA-1, etc.
	 * The return string should in such case more dynamically be built,
	 * instead of hardcoded like here.
	 */
	str t = alloca(sizeof(char) * BUFSIZ);
	*t = '\0';
#ifdef HAVE_OPENSSL
	strcat(t, "SHA1,MD5,");
#endif
#ifdef HAVE_CRYPT
	strcat(t, "crypt,");
#endif
	strcat(t, "plain");

	*ret = GDKstrdup(t);
	return(MAL_SUCCEED);
}

/**
 * Returns the hash for the given password, challenge and algorithm.
 * The hash calculated using the given algorithm over the password
 * concatenated with the challenge.
 */
static str
AUTHhashPassword(str *ret, str *algo, str *password, str *challenge) {
	if (strcmp(*algo, "plain") == 0) {
		/* The plain text algorithm, doesn't really hash at all.  It's
		 * the easiest algorithm, as it just appends the challenge to
		 * the password and returns it.
		 */
		*ret = GDKmalloc(sizeof(char) * (strlen(*password) + strlen(*challenge) + 1));
		sprintf(*ret, "%s%s", *password, *challenge);
		return(MAL_SUCCEED);
#ifdef HAVE_OPENSSL
	} else if (strcmp(*algo, "SHA1") == 0) {
		/* The SHA-1 RSA hash algorithm is a 160 bit hash.  In order to
		 * use in a string, a hexadecimal representation of the bit
		 * sequence is used.
		 */
		unsigned char md[20]; /* should be SHA_DIGEST_LENGTH */
		int len = strlen(*password) + strlen(*challenge);
		char key[len];
		strcpy(key, *password);
		strncat(key, *challenge, strlen(*challenge));
		SHA1((unsigned char*)key, len, md);
		*ret = GDKmalloc(sizeof(char) * (20 * 2 + 1));
		sprintf(*ret, "%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"
				"%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x",
				md[0], md[1], md[2], md[3], md[4],
				md[5], md[6], md[7], md[8], md[9],
				md[10], md[11], md[12], md[13], md[14],
				md[15], md[16], md[17], md[18], md[19]
			);
		return(MAL_SUCCEED);
	} else if (strcmp(*algo, "MD5") == 0) {
		/* The MD5 hash algorithm is a 128 bit hash.  In order to
		 * use in a string, a hexadecimal representation of the bit
		 * sequence is used.
		 */
		unsigned char md[16]; /* should be MD5_DIGEST_LENGTH */
		int len = strlen(*password) + strlen(*challenge);
		char key[len];
		strcpy(key, *password);
		strncat(key, *challenge, strlen(*challenge));
		MD5((unsigned char*)key, len, md);
		*ret = GDKmalloc(sizeof(char) * (16 * 2 + 1));
		sprintf(*ret, "%02x%02x%02x%02x%02x%02x%02x%02x"
				"%02x%02x%02x%02x%02x%02x%02x%02x",
				md[0], md[1], md[2], md[3],
				md[4], md[5], md[6], md[7],
				md[8], md[9], md[10], md[11],
				md[12], md[13], md[14], md[15]
			);
		return(MAL_SUCCEED);
#endif
#ifdef HAVE_CRYPT
	} else if (strcmp(*algo, "crypt") == 0) {
		/* The crypt hash algorithm uses UNIX crypt, a modification of
		 * DES which uses a 2-char wide salt.  Because crypt only cares
		 * about the first eight characters of the given password, the
		 * challenge may not be taken into account at all.  As salt, the
		 * last two characters of the challenge are used.
		 */
		char key[8]; /* NULL termination is not necessary */
		char salt[3]; /* NULL termination is a necessity! */
		str hash;
		int len;

		/* prepare the key */
		len = strlen(*password);
		if (len >= 8) {
			strncpy(key, *password, 8);
		} else {
			/* pad with the challenge, we know it is always 8+ chars */
			strncpy(key, *password, len);
			strncpy(key + len, *challenge, 8 - len);
		}

		/* prepare the salt */
		len = strlen(*challenge);
		salt[0] = *challenge[len - 2];
		salt[1] = *challenge[len - 1];
		salt[2] = '\0';

		/* call crypt to do the work */
		hash = crypt(key, salt);
		assert (hash != NULL);
		*ret = GDKstrdup(hash);
		return(MAL_SUCCEED);
#endif
	} else {
		throwMalf("hashPassword", "unsupported hash type: '%s'", algo);
	}
}
@}
