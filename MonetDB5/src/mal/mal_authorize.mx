@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2006 CWI.
@' All Rights Reserved.

@f mal_authorize
@a M. Kersten, F. Groffen
@v 0.2
@+ Authorisation adminstration management
Authorisation of users is a key concept in protecting the server from
malicious and unauthorised users.  This file contains a number of
functions that administrate a set of BATs backing the authorisation
tables.

The implementation is based on three persistent BATs, which keep the
usernames, passwords and allowed scenarios for users of the server.

@h
#ifndef _MAL_AUTHORIZE_H
#define _MAL_AUTHORIZE_H

/* #define _DEBUG_AUTH_*/
#include "mal.h"
#include "mal_exception.h"
#include "mal_instruction.h"
#include "mal_client.h"

mal_export str AUTHcheckCredentials(oid *uid, str *user, str *passwd, str *scenario);
mal_export str AUTHaddUser(oid *uid, str *user, str *pass, bat *scenarios);
mal_export str AUTHremoveUser(str *username);
mal_export str AUTHchangeUsername(str *olduser, str *newuser);
mal_export str AUTHchangePassword(str *oldpass, str *passwd);
mal_export str AUTHsetPassword(str *username, str *passwd);
mal_export str AUTHaddLanguage(str *username, str *scenario);
mal_export str AUTHremoveLanguage(str *username, str *scenario);
mal_export str AUTHresolveUser(str *username, oid *uid);
mal_export str AUTHgetUsername(str *username);

mal_export str AUTHrequireAdmin();
mal_export str AUTHrequirteAdminOrUser(str *username);
mal_export str AUTHinitTables();

/* convenience macros */
#define throwIC(X, Y) throw("InvalidCredentialsException", X, Y);
#define throwICf(X, Y, A) throwf("InvalidCredentialsException", X, Y, A);

#endif /* _MAL_AUTHORIZE_H */
@-
@c
#include "mal_authorize.h"

/**
 * Requires the current client to be the admin user.  If not the case,
 * this function returns an InvalidCredentialsException.
 */
str
AUTHrequireAdmin() {
	oid id = getClient()->user;

	if (id != 0) {
		char u[BUFSIZ];
		str user = u;
		str tmp;
		
		rethrow("requireAdmin", tmp, AUTHresolveUser(&user, &id));
		throwICf("requireAdmin", "Access denied for user '%s'", user)
	}

	return(MAL_SUCCEED);
}

/**
 * Requires the current client to be the admin user, or the user with
 * the given username.  If not the case, this function returns an
 * InvalidCredentialsException.
 */
str
AUTHrequireAdminOrUser(str *username) {
	oid id = getClient()->user;
	char u[BUFSIZ];
	str user = u;
	str tmp;

	/* root?  then all is well */
	if (id == 0) return(MAL_SUCCEED);

	rethrow("requireAdminOrUser", tmp, AUTHresolveUser(&user, &id));
	if (username == NULL || *username == NULL || strcmp(*username, user) != 0) {
		throwICf("requireAdminOrUser", "Access denied for user '%s'", user);
	}

	return(MAL_SUCCEED);
}

@-
Localize the authorization tables in the database.  The authorization
tables are a set of aligned BATs that store username, password (hashed)
and scenario permissions.
If the BATs do not exist, they are created, and the monetdb/monetdb
administrator account is added.  Initialising the authorization tables
can only be done after the GDK kernel has been initialized.
@c
static BAT *user = NULL, *userrev = NULL;
static BAT *pass = NULL;
static BAT *scen = NULL;

str
AUTHinitTables() {
	BAT *b;
	int isNew = 1;

	/* skip loading if already loaded */
	if (user != NULL && pass != NULL && scen != NULL)
		return(MAL_SUCCEED);

	/* if one is not NULL here, something is seriously screwed up */
	assert (user == NULL);
	assert (pass == NULL);
	assert (scen == NULL);

	/* load/create users BAT */
	b = BATdescriptor(BBPindex("M5system_auth_user"));
	if (b == NULL) {
		b = BATnew(TYPE_oid, TYPE_str, 256);
		if (b == NULL)
			throwMal("initTables", "could not allocate user table");

		BATkey(BATmirror(b), TRUE);
		BBPrename(b->batCacheid, "M5system_auth_user");
		BATmode(b, PERSISTENT);
		BATcommit(b);
	} else {
		isNew = 0;
	}
	user = b;
	userrev = BATmirror(b);

	/* load/create password BAT */
	b = BATdescriptor(BBPindex("M5system_auth_passwd"));
	if (b == NULL) {
		b = BATnew(TYPE_oid, TYPE_str, 256);
		if (b == NULL)
			throwMal("initTables", "could not allocate password table");

		BBPrename(b->batCacheid, "M5system_auth_passwd");
		BATmode(b, PERSISTENT);
		BATcommit(b);
	} else {
		isNew = 0;
	}
	pass = b;

	/* load/create scenario BAT */
	b = BATdescriptor(BBPindex("M5system_auth_scen"));
	if (b == NULL) {
		b = BATnew(TYPE_oid, TYPE_str, 256);
		if (b == NULL)
			throwMal("initTables", "could not allocate scenario table");

		BATkey(b, TRUE);
		BBPrename(b->batCacheid, "M5system_auth_scen");
		BATmode(b, PERSISTENT);
		BATcommit(b);
	} else {
		isNew = 0;
	}
	scen = b;

	if (isNew == 1) {
		/* insert the monetdb/monetdb administrator account on a
		 * complete fresh and new auth tables system */
		str user = "monetdb";
		str pass = "monetdb";
		bat b = bat_nil;
		str tmp;
		oid uid;

		rethrow("initTables", tmp, AUTHaddUser(&uid, &user, &pass, &b));
		if (uid != 0)
			throwMal("initTables", "authorisation BATs not empty, but they were just created !?!?!?");
	}

	return(MAL_SUCCEED);
}

/**
 * Checks the credentials supplied and throws an exception if invalid.
 * The user id of the authenticated user is returned upon success.
 */
str
AUTHcheckCredentials(oid *uid, str *username, str *passwd, str *scenario) {
	str tmp;
	BAT *b;
	BUN p, q;
	oid *id;

	rethrow("checkCredentials", tmp, AUTHrequireAdminOrUser(username));

	if (*username == NULL || strNil(*username))
		throwIC("checkCredentials", "Invalid credentials for unknown user");

	p = BUNfnd(userrev, *username);
	if (p == NULL) {
		/* DO NOT reveal that the user doesn't exist here! */
		throwICf("checkCredentials", "Invalid credentials for user '%s'",
				*username);
	}
	id = (oid*)(BUNtail(userrev, p));

	/* a NULL password is impossible (since we should be dealing with
	 * hashes here) so we can bail out immediately
	 */
	if (*passwd == NULL || strNil(*passwd)) {
		/* DO NOT reveal that the password is NULL here! */
		throwICf("checkCredentials", "Invalid credentials for user '%s'",
				*username);
	}

	/* find the corresponding password to the user */
	q = BUNfnd(pass, id);
	assert (q != NULL);
	tmp = (str)BUNtail(pass, q);
	assert (tmp != NULL);
	/* and now we have it, compare it to what was given to us */
	if (strcmp(*passwd, tmp) != 0) {
		/* of course we DO NOT print the password here */
		throwICf("checkCredentials", "Invalid credentials for user '%s'",
				*username);
	}

	/* now see if the scenario is permitted (if restrictions for that
	 * apply)
	 */
	b = BATselect(scen, id, id);
	if (BATcount(b) > 0) {
		if (*scenario == NULL || strNil(*scenario)) {
			/* of course we DO NOT tell the exact reason here again */
			throwICf("checkCredentials", "Invalid credentials for user '%s'",
					*username);
		}

		/* ok, there are some tuples that we have to consider */
		BATloop(b, p, q) {
			tmp = (str)BUNtail(b, p);
			assert (tmp != NULL);
			if (strcmp(*scenario, tmp) == 0) {
				/* YAY!  fun!  party!  We are granted access! */
				*uid = *id;
				return(MAL_SUCCEED);
			}
		}

		/* uh oh... that we made it till here means it's wrong */
		throwICf("checkCredentials", "Invalid credentials for user '%s'",
				*username);
	} else {
		/* no scenario restriction applies, so everything is good */
		*uid = *id;
		return(MAL_SUCCEED);
	}
}

/**
 * Adds the given user with password to the administration.  The scens
 * BAT contains all scenarios allowed for the user.  If NULL or empty,
 * no restrictions for a scenario applies.  The return value of this
 * function is the user id of the added user.
 */
str
AUTHaddUser(oid *uid, str *username, str *passwd, bat *scenarios) {
	BUN p, q;
	BAT *b;
	oid *id;
	str tmp;

	rethrow("addUser", tmp, AUTHrequireAdmin());
	
	/* some pre-condition checks */
	if (*username == NULL || strNil(*username))
		throwIllArg("addUser", "username cannot be nil");
	if (*passwd == NULL || strNil(*passwd))
		throwIllArg("addUser", "password cannot be nil");

	/* ensure that the username is not already there */
	p = BUNfnd(userrev, *username);
	if (p != NULL)
		throwMalf("addUser", "user '%s' already exists", *username);
	
	/* we assume the BATs are still aligned */
	BUNappend(user, *username, 0);
	BUNappend(pass, *passwd, 0);
	/* retrieve the oid of the just inserted user */
	p = BUNfnd(userrev, *username);
	assert (p != NULL);
	id = (oid*)(BUNtail(userrev, p));

	if (*scenarios != bat_nil) {
		b = BATdescriptor(*scenarios);
		if (b == NULL) {
			BATundo(user);
			BATundo(pass);
			throwIllArg("addUser", "invalid BAT!");
		}
		if (b->htype != TYPE_str) {
			BATundo(user);
			BATundo(pass);
			throwIllArg("addUser", "BAT should have str head");
		}

		/* associate scenarios given in the BAT with the user */
		if (BATcount(b) > 0) {
			BATloop(b, p, q) {
				BUNins(scen, id, BUNhead(b, p));
			}
		}
	}

	/* make the stuff persistent */
	BATcommit(user);
	BATcommit(pass);
	BATcommit(scen);

	*uid = *id;
	return(MAL_SUCCEED);
}

/**
 * Removes the given user from the administration.  All scenarios (if
 * any) and the password are removed as well.
 */
str
AUTHremoveUser(str *username) {
	BUN p;
	BAT *b;
	oid *id;
	str tmp;

	rethrow("addUser", tmp, AUTHrequireAdmin());

	/* pre-condition check */
	if (*username == NULL || strNil(*username))
		throwIllArg("addUser", "username cannot be nil");

	/* ensure that the username exists */
	p = BUNfnd(userrev, *username);
	if (p == NULL)
		throwMalf("addUser", "no such user: '%s'", *username);
	id = (oid*)(BUNtail(userrev, p));

	/* now, we got the oid, start removing the related tuples */
	b = BATselect(user, id, id);
	BATdel(user, b);
	b = BATselect(pass, id, id);
	BATdel(pass, b);
	b = BATselect(scen, id, id);
	BATdel(scen, b);

	/* make the stuff persistent */
	BATcommit(user);
	BATcommit(pass);
	BATcommit(scen);

	return(MAL_SUCCEED);
}

/**
 * Changes the username of the user indicated by olduser into newuser.
 * If the username is already in use, an exception is thrown and nothing
 * is modified.
 */
str
AUTHchangeUsername(str *olduser, str *newuser) {
	BUN p, q;
	str tmp;

	rethrow("addUser", tmp, AUTHrequireAdminOrUser(olduser));

	/* precondition checks */
	if (*olduser == NULL || strNil(*olduser))
		throwIllArg("changeUsername", "old username should not be nil");
	if (*newuser == NULL || strNil(*newuser))
		throwIllArg("changeUsername", "new username should not be nil");

	/* see if the olduser is valid */
	p = BUNfnd(userrev, *olduser);
	if (p == NULL)
		throwMalf("changeUsername", "user '%s' does not exist", *olduser);
	/* ... and if the newuser is not there yet */
	q = BUNfnd(userrev, *newuser);
	if (q != NULL)
		throwMalf("changeUsername", "user '%s' already exists", *newuser);

	/* ok, just do it! */
	BUNinplace(userrev, p, *newuser, BUNtail(userrev, p), 0);
	BATcommit(user);

	return(MAL_SUCCEED);
}

/**
 * Changes the password of the current user to the given password.  The
 * old password must match the one stored before the new password is
 * set.
 */
str
AUTHchangePassword(str *oldpass, str *passwd) {
	BUN p;
	str tmp;
	oid id;

	/* precondition checks */
	if (*oldpass == NULL || strNil(*oldpass))
		throwIllArg("changePassword", "old password should not be nil");
	if (*passwd == NULL || strNil(*passwd))
		throwIllArg("changePassword", "password should not be nil");

	/* In the future a check could be here to see if the password is a
	 * valid hash.  Using an invalid hash (like prepending a ! in front
	 * of it) could be used to 'disable' accounts. */

	/* check the old password */
	id = getClient()->user;
	p = BUNfnd(pass, &id);
	tmp = BUNtail(pass, p);
	assert (tmp != NULL);
	if (strcmp(tmp, *oldpass) != 0)
		throwIC("changePassword", "Access denied");

	/* ok, just overwrite the password field for this user */
	BUNinplace(pass, p, BUNhead(pass, p), *passwd, 0);
	BATcommit(pass);

	return(MAL_SUCCEED);
}

/**
 * Changes the password of the given user to the given password.  This
 * function can be used by the administrator to reset the password for a
 * user.  Note that for the administrator to change its own password, it
 * cannot use this function for obvious reasons.
 */
str
AUTHsetPassword(str *username, str *passwd) {
	BUN p;
	str tmp;
	oid id;

	rethrow("setPassword", tmp, AUTHrequireAdmin());

	/* precondition checks */
	if (*username == NULL || strNil(*username))
		throwIllArg("setPassword", "username should not be nil");
	if (*passwd == NULL || strNil(*passwd))
		throwIllArg("setPassword", "password should not be nil");

	/* In the future a check could be here to see if the password is a
	 * valid hash.  Using an invalid hash (like prepending a ! in front
	 * of it) could be used to 'disable' accounts. */

	id = getClient()->user;
	/* find the name of the administrator and see if it equals username */
	p = BUNfnd(user, &id);
	assert (p != NULL);
	tmp = BUNtail(user, p);
	assert (tmp != NULL);
	if (strcmp(tmp, *username) == 0)
		throwIC("setPassword", "The administrator cannot set its own password, use changePassword instead");
	
	/* see if the user is valid */
	p = BUNfnd(userrev, *username);
	if (p == NULL)
		throwMalf("changePassword", "user '%s' does not exist", *username);

	/* ok, just overwrite the password field for this user */
	p = BUNfnd(pass, &id);
	assert (p != NULL);
	BUNinplace(pass, p, BUNhead(pass, p), *passwd, 0);
	BATcommit(pass);

	return(MAL_SUCCEED);
}

/**
 * Adds the given scenario to the list of allowed scenarios for the
 * given user.  Note that this can result in unexpected behaviour when
 * there where previously no scenarios defined for the user (which means
 * all scenarios are permitted).
 */
str
AUTHaddLanguage(str *username, str *scenario) {
	BUN p;
	str tmp;

	rethrow("addUser", tmp, AUTHrequireAdmin());

	/* precondition checks */
	if (*username == NULL || strNil(*username))
		throwIllArg("addLanguage", "username should not be nil");
	if (*scenario == NULL || strNil(*scenario))
		throwIllArg("addLanguage", "scenario should not be nil");

	/* see if the user is valid */
	p = BUNfnd(userrev, *username);
	if (p == NULL)
		throwMalf("addLanguage", "user '%s' does not exist", *username);

	/* add the scenario for this user */
	BUNins(scen, BUNtail(userrev, p), *scenario);
	BATcommit(scen);

	return(MAL_SUCCEED);
}

/**
 * Removes the given scenario from the list of allowed scenarios for the
 * given user.  Note that removing the last allowed scenario results in
 * the opposite effect: it will allow any scenario to be used.
 */
str
AUTHremoveLanguage(str *username, str *scenario) {
	BUN p;
	BAT *b;
	str tmp;

	rethrow("addUser", tmp, AUTHrequireAdmin());

	/* precondition checks */
	if (*username == NULL || strNil(*username))
		throwIllArg("addLanguage", "username should not be nil");
	if (*scenario == NULL || strNil(*scenario))
		throwIllArg("addLanguage", "scenario should not be nil");

	/* see if the user is valid */
	p = BUNfnd(userrev, *username);
	if (p == NULL)
		throwMalf("addLanguage", "user '%s' does not exist", *username);

	/* see if the scenario is valid for this user */
	b = BATselect(scen, BUNtail(userrev, p), BUNtail(userrev, p));
	b = BATselect(BATmirror(b), *scenario, *scenario);
	if (BATcount(b) == 0)
		throwMalf("removeLanguage", "scenario '%s' not found for user", *scenario);
	if (BATcount(b) > 1)
		throwMalf("removeLanguage", "inconsistent authorisation administration, scenario '%s' multiple times defined", *scenario);

	/* ok, remove it */
	BATdel(scen, BATmirror(b));
	BATcommit(scen);

	return(MAL_SUCCEED);
}

/**
 * Resolves the given user id and returns the associated username.  If
 * the id is invalid, an exception is thrown.  The given pointer to the
 * username char buffer should be NULL if this function is supposed to
 * allocate memory for it.  If the pointer is pointing to an already
 * allocated buffer, it is supposed to be of size BUFSIZ.
 */
str
AUTHresolveUser(str *username, oid *uid) {
	BUN p;

	if (uid == NULL || *uid == oid_nil)
		throwIllArg("resolveUser", "userid should not be nil");
	
	p = BUNfnd(user, uid);
	if (p == NULL)
		throwMalf("resolveUser", "No such user with id: " OIDFMT, *uid);

	assert (username != NULL);

	if (*username == NULL) {
		*username = GDKstrdup((str)(BUNtail(user, p)));
	} else {
		snprintf(*username, BUFSIZ, "%s", (str)(BUNtail(user, p)));
	}

	return(MAL_SUCCEED);
}

/**
 * Returns the username of the current user.
 */
str
AUTHgetUsername(str *username) {
	BUN p;
	oid id;

	id = getClient()->user;
	p = BUNfnd(user, &id);
	if (p == NULL) {
		GDKfatal("Internal error: user id that doesn't exist: " OIDFMT, getClient()->user);
	}

	*username = BUNtail(user, p);
	return(MAL_SUCCEED);
}
@}
