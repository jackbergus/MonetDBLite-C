@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2006 CWI.
@' All Rights Reserved.

@f mal_authorize
@a M. Kersten, F. Groffen
@+ User authorization
The inner core of the system provides a basic authorization scheme. 
Authorization is coupled with running a scenario
or accessing the content of variable boxes.
A user may only use those resources if it is explicitly permitted.

The authorization scheme can be used by routines as a first
line of defense against unauthorized access. They could 
augment it with their own persistent information for further
control.

The owner of the server and database is he who was able to
start the server in the first place. It puts him in a special
position. He may change the authorization information and view
the permission tables. He is also the owner of system provided
boxes, e.g. @code{const} and @code{statistics}.
All other users are only allowed to change their password.

The implementation is straight forward.
It keeps a persistent BAT @code{user} around, which associates a
user id with a corresponding (encoded) password to their 
permissible scenarios. These tables can be inspected by the
system owner and any linked in code to refine the scheme.

@{

The implementation is straightforward. A persistent memory mapped
BAT keeps the information for fast access. 
The guest accounts 'user' without password 
and monetdb/monetdb are  being added upon creation of this BAT.
This allows all known functionality to work.

The identity of the server owner is not copied into this table purposely.

@h
#ifndef _MAL_AUTHORIZE_H
#define _MAL_AUTHORIZE_H

/* #define _DEBUG_AUTH_*/
#include "mal.h"
#include "mal_exception.h"
#include "mal_instruction.h"
#include "mal_client.h"

mal_export str AUTHcheckCredentials(str *user, str *passwd, str *language);
mal_export str AUTHaddUser(str *user, str *pass, bat *langs);
mal_export str AUTHremoveUser(str *username);
mal_export str AUTHchangeUsername(str *olduser, str *newuser);
mal_export str AUTHchangePassword(str *username, str *passwd);
mal_export str AUTHaddLanguage(str *username, str *language);
mal_export str AUTHremoveLanguage(str *username, str *language);

mal_export str MALinitClient(Client cntxt);
mal_export int isServerOwner(Client c);
mal_export str setNewPassword(str nme, str passwd, str newpasswd);
mal_export bat getAllPermissions();
mal_export bat getAllPasswords();

mal_export void setServerOwner(str o, str p);
mal_export void initAuthTables();

/* convenience macros */
#define throwIC(X, Y) throw("InvalidCredentialsException", X, Y);
#define throwICf(X, Y, A) throwf("InvalidCredentialsException", X, Y, A);

#endif /* _MAL_AUTHORIZE_H */
@-
@c
#include "mal_authorize.h"

static str owner = NULL;
static str passw = NULL;

void
setServerOwner(str o, str p) {
	if (owner || passw)
		GDKfatal("Attempt to reset server owner identity");
	owner = o ? o : "user";
	passw = p ? p : "";
#ifdef _DEBUG_AUTH_
	printf("serverOwner=%s\n",owner);
#endif
	assert(owner != NULL);
}

@-
Localize the authorization tables in the database.  The authorization
tables are a set of aligned BATs that store username, password (hashed)
and language permissions.
If the BATs do not exist, they are created, and the monetdb/monetdb
administrator account is added.  Initializing the authorization tables
can only be done after the GDK kernel has been initialized.
@c
static BAT *user = NULL, *userrev;
static BAT *pass = NULL, *passrev;
static BAT *lang = NULL, *langrev;

void
initAuthTables() {
	BAT *b;
	int isNew = 1;

	/* skip loading if already loaded */
	if (user != NULL && pass != NULL && lang != NULL)
		return;

	/* if one is not NULL here, something is seriously screwed up */
	assert (user == NULL);
	assert (pass == NULL);
	assert (lang == NULL);

	/* load/create users BAT */
	b = BATdescriptor(BBPindex("M5system_auth_user"));
	if (b == NULL) {
		b = BATnew(TYPE_void, TYPE_str, 256);
		if (b == NULL)
			GDKfatal("mal_authorize: could not allocate user table");

		BATkey(BATmirror(b), TRUE);
		BBPrename(b->batCacheid, "M5system_auth_user");
		BATmode(b, PERSISTENT);
		BATcommit(b);
	} else {
		isNew = 0;
	}
	user = b;
	userrev = BATmirror(b);

	/* load/create password BAT */
	b = BATdescriptor(BBPindex("M5system_auth_passwd"));
	if (b == NULL) {
		b = BATnew(TYPE_void, TYPE_str, 256);
		if (b == NULL)
			GDKfatal("mal_authorize: could not allocate password table");

		BBPrename(b->batCacheid, "M5system_auth_passwd");
		BATmode(b, PERSISTENT);
		BATcommit(b);
	} else {
		isNew = 0;
	}
	pass = b;
	passrev = BATmirror(b);

	/* load/create language BAT */
	b = BATdescriptor(BBPindex("M5system_auth_lang"));
	if (b == NULL) {
		b = BATnew(TYPE_oid, TYPE_str, 256);
		if (b == NULL)
			GDKfatal("mal_authorize: could not allocate language table");

		BATkey(b, TRUE);
		BBPrename(b->batCacheid, "M5system_auth_lang");
		BATmode(b, PERSISTENT);
		BATcommit(b);
	} else {
		isNew = 0;
	}
	lang = b;
	langrev = BATmirror(b);
	(void) langrev; /* silence compiler */

	if (isNew == 1) {
		/* insert the monetdb/monetdb administrator account on a
		 * complete fresh and new auth tables system */
		str user = "monetdb";
		str pass = "monetdb";
		bat b = bat_nil;
		str tmp;

		tmp = AUTHaddUser(&user, &pass, &b);
		if (tmp != MAL_SUCCEED)
			GDKfatal(tmp);
	}
}

/**
 * Checks the credentials supplied and returns an exception if invalid.
 */
str
AUTHcheckCredentials(str *username, str *passwd, str *language) {
	str tmp;
	BAT *b;
	BUN p, q;
	
	initAuthTables();

	if (*username == NULL || strNil(*username))
		throwIC("checkCredentials", "Invalid credentials for unknown user");

	p = BUNfnd(userrev, *username);
	if (p == NULL) {
		/* DO NOT reveal that the user doesn't exist here! */
		throwICf("checkCredentials", "Invalid credentials for user '%s'",
				*username);
	}

	/* a NULL password is impossible (since we should be dealing with
	 * hashes here) so we can bail out immediately
	 */
	if (*passwd == NULL || strNil(*passwd)) {
		/* DO NOT reveal that the password is NULL here! */
		throwICf("checkCredentials", "Invalid credentials for user '%s'",
				*username);
	}

	/* find the corresponding password to the user */
	q = BUNfnd(pass, BUNtail(userrev, p));
	assert (q != NULL);
	tmp = (str)BUNtail(pass, q);
	assert (tmp != NULL);
	/* and now we have it, compare it to what was given to us */
	if (strcmp(*passwd, tmp) != 0) {
		/* of course we DO NOT print the password here */
		throwICf("checkCredentials", "Invalid credentials for user '%s'",
				*username);
	}

	/* now see if the language is permitted (if restrictions for that
	 * apply)
	 */
	b = BATselect(lang, BUNtail(userrev, p), BUNtail(userrev, p));
	if (BATcount(b) > 0) {
		if (*language == NULL || strNil(*language)) {
			/* of course we DO NOT tell the exact reason here again */
			throwICf("checkCredentials", "Invalid credentials for user '%s'",
					*username);
		}

		/* ok, there are some tuples that we have to consider */
		BATloop(b, p, q) {
			tmp = (str)BUNtail(b, p);
			assert (tmp != NULL);
			if (strcmp(*language, tmp) == 0) {
				/* YAY!  fun!  party!  We are granted access! */
				return(MAL_SUCCEED);
			}
		}

		/* uh oh... that we made it till here means it's wrong */
		throwICf("checkCredentials", "Invalid credentials for user '%s'",
				*username);
	} else {
		/* no language restriction applies, so everything is good */
		return(MAL_SUCCEED);
	}
}

/**
 * Adds the given user with password to the administration.  The langs
 * BAT contains all languages allowed for the user.  If NULL or empty,
 * no restrictions for a language applies.
 */
str
AUTHaddUser(str *username, str *passwd, bat *langs) {
	BUN p, q;
	BAT *b;
	
	/* some pre-condition checks */
	if (*username == NULL || strNil(*username))
		throwIllArg("addUser", "username cannot be nil");
	if (*passwd == NULL || strNil(*passwd))
		throwIllArg("addUser", "password cannot be nil");

	/* ensure that the username is not already there */
	p = BUNfnd(userrev, *username);
	if (p != NULL)
		throwMalf("addUser", "user '%s' already exists", *username);
	
	/* we assume the BATs are still aligned */
	BUNappend(user, *username, 0);
	BUNappend(pass, *passwd, 0);

	if (*langs != bat_nil) {
		b = BATdescriptor(*langs);
		if (b == NULL) {
			BATundo(user);
			BATundo(pass);
			throwIllArg("addUser", "invalid BAT!");
		}
		if (b->htype != TYPE_str) {
			BATundo(user);
			BATundo(pass);
			throwIllArg("addUser", "BAT should have str head");
		}

		/* associate langs given in the BAT with the user */
		if (BATcount(b) > 0) {
			oid *id;

			p = BUNfnd(userrev, *username);
			assert (p != NULL);
			id = (oid*)(BUNtail(userrev, p));
			BATloop(b, p, q) {
				BUNins(lang, id, BUNhead(b, p));
			}
		}
	}

	/* make the stuff persistent */
	BATcommit(user);
	BATcommit(pass);
	BATcommit(lang);

	return(MAL_SUCCEED);
}

/**
 * Removes the given user from the administration.  All languages (if
 * any) and the password are removed as well.
 */
str
AUTHremoveUser(str *username) {
	BUN p;
	BAT *b;
	oid *id;
	
	/* pre-condition check */
	if (*username == NULL || strNil(*username))
		throwIllArg("addUser", "username cannot be nil");

	/* ensure that the username exists */
	p = BUNfnd(userrev, *username);
	if (p == NULL)
		throwMalf("addUser", "no such user: '%s'", *username);
	id = (oid*)(BUNtail(userrev, p));

	/* now, we got the oid, start removing the related tuples */
	b = BATselect(user, id, id);
	BATdel(user, b);
	b = BATselect(pass, id, id);
	BATdel(pass, b);
	b = BATselect(lang, id, id);
	BATdel(lang, b);

	/* make the stuff persistent */
	BATcommit(user);
	BATcommit(pass);
	BATcommit(lang);

	return(MAL_SUCCEED);
}

/**
 * Changes the username of the user indicated by olduser into newuser.
 * If the username is already in use, an exception is thrown and nothing
 * is modified.
 */
str
AUTHchangeUsername(str *olduser, str *newuser) {
	BUN p, q;

	/* precondition checks */
	if (*olduser == NULL || strNil(*olduser))
		throwIllArg("changeUsername", "old username should not be nil");
	if (*newuser == NULL || strNil(*newuser))
		throwIllArg("changeUsername", "new username should not be nil");

	/* see if the olduser is valid */
	p = BUNfnd(userrev, *olduser);
	if (p == NULL)
		throwMalf("changeUsername", "user '%s' does not exist", *olduser);
	/* ... and if the newuser is not there yet */
	q = BUNfnd(userrev, *newuser);
	if (q != NULL)
		throwMalf("changeUsername", "user '%s' already exists", *newuser);

	/* ok, just do it! */
	BUNinplace(userrev, p, *newuser, BUNtail(userrev, p), 0);
	BATcommit(user);

	return(MAL_SUCCEED);
}

/**
 * Changes the password of the given user to the given password.  Note
 * that no check is being performed, and the password is just
 * overwritten with the new value.  Recall that determining whether this
 * is legal from the user point of view is up to the caller of this
 * function.
 */
str
AUTHchangePassword(str *username, str *passwd) {
	BUN p, q;

	/* precondition checks */
	if (*username == NULL || strNil(*username))
		throwIllArg("changePassword", "username should not be nil");
	if (*passwd == NULL || strNil(*passwd))
		throwIllArg("changePassword", "password should not be nil");

	/* In the future a check could be here to see if the password is a
	 * valid hash.  Using an invalid hash (like prepending a ! in front
	 * of it) could be used to 'disable' accounts. */

	/* see if the user is valid */
	p = BUNfnd(userrev, *username);
	if (p == NULL)
		throwMalf("changePassword", "user '%s' does not exist", *username);

	/* ok, just overwrite the password field for this user */
	q = BUNfnd(pass, BUNtail(userrev, p));
	assert (q != NULL);
	BUNinplace(pass, q, BUNhead(pass, p), *passwd, 0);
	BATcommit(pass);

	return(MAL_SUCCEED);
}

/**
 * Adds the given language to the list of allowed languages for the
 * given user.  Note that this can result in unexpected behaviour when
 * there where previously no languages defined for the user (which means
 * all languages are permitted).
 */
str
AUTHaddLanguage(str *username, str *language) {
	BUN p;

	/* precondition checks */
	if (*username == NULL || strNil(*username))
		throwIllArg("addLanguage", "username should not be nil");
	if (*language == NULL || strNil(*language))
		throwIllArg("addLanguage", "language should not be nil");

	/* see if the user is valid */
	p = BUNfnd(userrev, *username);
	if (p == NULL)
		throwMalf("addLanguage", "user '%s' does not exist", *username);

	/* add the language for this user */
	BUNins(lang, BUNtail(userrev, p), *language);
	BATcommit(lang);

	return(MAL_SUCCEED);
}

/**
 * Removes the given language from the list of allowed languages for the
 * given user.  Note that removing the last allowed language results in
 * the opposite effect: it will allow any language to be used.
 */
str
AUTHremoveLanguage(str *username, str *language) {
	BUN p;
	BAT *b;

	/* precondition checks */
	if (*username == NULL || strNil(*username))
		throwIllArg("addLanguage", "username should not be nil");
	if (*language == NULL || strNil(*language))
		throwIllArg("addLanguage", "language should not be nil");

	/* see if the user is valid */
	p = BUNfnd(userrev, *username);
	if (p == NULL)
		throwMalf("addLanguage", "user '%s' does not exist", *username);

	/* see if the language is valid for this user */
	b = BATselect(lang, BUNtail(userrev, p), BUNtail(userrev, p));
	b = BATselect(BATmirror(b), *language, *language);
	if (BATcount(b) == 0)
		throwMalf("removeLanguage", "language '%s' not found for user", *language);
	if (BATcount(b) > 1)
		throwMalf("removeLanguage", "inconsistent authorisation administration, language '%s' multiple times defined", *language);

	/* ok, remove it */
	BATdel(lang, BATmirror(b));
	BATcommit(lang);

	return(MAL_SUCCEED);
}

str
MALinitClient(Client c) {
#ifdef _DEBUG_AUTH_
	printf("authorize %s:%s %s\n", c->user, c->password, c->scenario);
#endif
	/* don't do authorisation right now, because it doesn't work at all
	 * but for a hard-coded user "user" with password "" */
	if (1 == 1) return MAL_SUCCEED;
	
	if (owner == NULL || c->user == NULL)
		return MAL_SUCCEED; /* avoid missing info */

	/*
	if (strcmp(c->user, owner) == 0 &&
		(passw == NULL ||
		 strcmp((c->password ? c->password : ""), passw) == 0))
		return MAL_SUCCEED;
	*/

	return throwMessage("mal.authorize", "Access denied");
}

int
isServerOwner(Client c){
#ifdef _DEBUG_AUTH_
	printf("isServerOwner? %s/%s\n",c->user,c->password);
#endif
	return strcmp(c->user, "user") == 0;
}

str
setNewPassword(str nme, str passwd, str newpasswd)
{
	BAT *b;
	printf("new password %s %s %s\n", nme,passwd,newpasswd);
#ifdef _DEBUG_AUTH_
#endif
	b= BATselect(passrev,nme,nme);
	b= BATselect(BATmirror(b),passwd,passwd);
	if( BATcount(b) == 0) 
		return throwMessage("clients.newPassword","Permission denied");

	BATdel(passrev,b);
	BUNins(pass,nme,newpasswd);
	BATcommit(pass);
	return MAL_SUCCEED;
}

@-
The information can be obtained by the dba for inspection
@c
bat
getAllPermissions()
{
	BAT *b;
#ifdef _DEBUG_AUTH_
	printf("get authorizations \n");
#endif
	if( user ){
		b= BATcopy(user);
		BBPkeepref(b->batCacheid);
		return b->batCacheid;
	}
	return 0;
}
bat
getAllPasswords()
{
	BAT *b;
#ifdef _DEBUG_AUTH_
	printf("get authorizations \n");
#endif
	if( user ){
		b= BATcopy(pass);
		BBPkeepref(b->batCacheid);
		return b->batCacheid;
	}
	return 0;
}
@}
