@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2006 CWI.
@' All Rights Reserved.

@f mal_authorize
@a M. Kersten, F. Groffen
@v 0.2
@+ Authorisation adminstration management
Authorisation of users is a key concept in protecting the server from
malicious and unauthorised users.  This file contains a number of
functions that administrate a set of BATs backing the authorisation
tables.

The implementation is based on three persistent BATs, which keep the
usernames, passwords and allowed scenarios for users of the server.

@h
#ifndef _MAL_AUTHORIZE_H
#define _MAL_AUTHORIZE_H

/* #define _DEBUG_AUTH_*/
#include "mal.h"
#include "mal_exception.h"
#include "mal_instruction.h"
#include "mal_client.h"

mal_export str AUTHcheckCredentials(oid *uid, str *user, str *passwd, str *challenge, str *algo, str *scenario);
mal_export str AUTHaddUser(oid *uid, str *user, str *pass, bat *scenarios);
mal_export str AUTHremoveUser(str *username);
mal_export str AUTHchangeUsername(str *olduser, str *newuser);
mal_export str AUTHchangePassword(str *oldpass, str *passwd);
mal_export str AUTHsetPassword(str *username, str *passwd);
mal_export str AUTHaddScenario(str *username, str *scenario);
mal_export str AUTHremoveScenario(str *username, str *scenario);
mal_export str AUTHresolveUser(str *username, oid *uid);
mal_export str AUTHgetUsername(str *username);

mal_export str AUTHrequireAdmin();
mal_export str AUTHrequirteAdminOrUser(str *username);
mal_export str AUTHinitTables();

@-
Authorisation is based on a password.  The passwords are stored cyphered
in a BAT.  Access to this BAT should be prohibited from the MAL level,
but still, the passwords in it are to be stored cyphered with an
algorithm that has a decypher.  The database administrator can unlock
the BAT that stores the password (the vault) by supplying the master
password which is the key for the cypher algorithm.  The BAT will never
contain decyphered passwords, as they will be decyphered on the fly when
needed.  A locked vault means noone can log into the system, hence, the
vault needs to be unlocked as part of the server startup ritual.
@h
mal_export str AUTHunlockVault(str *password);
static str AUTHdecypherValue(str *ret, str *value);
static str AUTHcypherValue(str *ret, str *value);

@-
To avoid the passwords from being sent over the wire in plain text
format, MAPI starts with sending a challenge with salt.  This salt
should be appended to the plain text password before it is hashed in
order to make the password unreadable for eavesdroppers.  The hash
algorithm used is specified by the client, and can be chosen from a
comma separated list offered by the server through the challenge
(protocol >=6).
@h
mal_export str AUTHgetHashAlgorithms(str *ret);
static str AUTHhashPassword(str *ret, str *algo, str *passwd, str *challenge);

/* convenience macros */
#define throwIC(X, Y) throw("InvalidCredentialsException", X, Y);
#define throwICf(X, Y, A) throwf("InvalidCredentialsException", X, Y, A);

#endif /* _MAL_AUTHORIZE_H */
@-
@c
#include "mal_authorize.h"
#ifdef HAVE_OPENSSL
#include <openssl/sha.h>
#include <openssl/md5.h>
#endif

/**
 * Requires the current client to be the admin user.  If not the case,
 * this function returns an InvalidCredentialsException.
 */
str
AUTHrequireAdmin() {
	oid id = MCgetClient()->user;

	if (id != 0) {
		char u[BUFSIZ];
		str user = u;
		str tmp;
		
		rethrow("requireAdmin", tmp, AUTHresolveUser(&user, &id));
		throwICf("requireAdmin", "Access denied for user '%s'", user)
	}

	return(MAL_SUCCEED);
}

/**
 * Requires the current client to be the admin user, or the user with
 * the given username.  If not the case, this function returns an
 * InvalidCredentialsException.
 */
str
AUTHrequireAdminOrUser(str *username) {
	oid id = MCgetClient()->user;
	char u[BUFSIZ];
	str user = u;
	str tmp;

	/* root?  then all is well */
	if (id == 0) return(MAL_SUCCEED);

	rethrow("requireAdminOrUser", tmp, AUTHresolveUser(&user, &id));
	if (username == NULL || *username == NULL || strcmp(*username, user) != 0) {
		throwICf("requireAdminOrUser", "Access denied for user '%s'", user);
	}

	return(MAL_SUCCEED);
}

@-
Localize the authorization tables in the database.  The authorization
tables are a set of aligned BATs that store username, password (hashed)
and scenario permissions.
If the BATs do not exist, they are created, and the monetdb/monetdb
administrator account is added.  Initialising the authorization tables
can only be done after the GDK kernel has been initialized.
@c
static BAT *user = NULL, *userrev = NULL;
static BAT *pass = NULL;
static BAT *scen = NULL;

str
AUTHinitTables() {
	BAT *b;
	int isNew = 1;

	/* skip loading if already loaded */
	if (user != NULL && pass != NULL && scen != NULL)
		return(MAL_SUCCEED);

	/* if one is not NULL here, something is seriously screwed up */
	assert (user == NULL);
	assert (pass == NULL);
	assert (scen == NULL);

	/* load/create users BAT */
	b = BATdescriptor(BBPindex("M5system_auth_user"));
	if (b == NULL) {
		b = BATnew(TYPE_oid, TYPE_str, 256);
		if (b == NULL)
			throwMal("initTables", "could not allocate user table");

		BATkey(BATmirror(b), TRUE);
		BBPrename(b->batCacheid, "M5system_auth_user");
		BATmode(b, PERSISTENT);
	} else {
		isNew = 0;
	}
	user = b;
	userrev = BATmirror(b);

	/* load/create password BAT */
	b = BATdescriptor(BBPindex("M5system_auth_passwd"));
	if (b == NULL) {
		b = BATnew(TYPE_oid, TYPE_str, 256);
		if (b == NULL)
			throwMal("initTables", "could not allocate password table");

		BBPrename(b->batCacheid, "M5system_auth_passwd");
		BATmode(b, PERSISTENT);
	} else {
		isNew = 0;
	}
	pass = b;

	/* load/create scenario BAT */
	b = BATdescriptor(BBPindex("M5system_auth_scen"));
	if (b == NULL) {
		b = BATnew(TYPE_oid, TYPE_str, 256);
		if (b == NULL)
			throwMal("initTables", "could not allocate scenario table");

		BATkey(b, TRUE);
		BBPrename(b->batCacheid, "M5system_auth_scen");
		BATmode(b, PERSISTENT);
	} else {
		isNew = 0;
	}
	scen = b;

	if (isNew == 1) {
		/* insert the monetdb/monetdb administrator account on a
		 * complete fresh and new auth tables system */
		str user = "monetdb";
		str pass = "monetdb";
		bat b = bat_nil;
		str tmp;
		oid uid;

		rethrow("initTables", tmp, AUTHaddUser(&uid, &user, &pass, &b));
		if (uid != 0)
			throwMal("initTables", "authorisation BATs not empty, but they were just created !?!?!?");
	}

	return(MAL_SUCCEED);
}

/**
 * Checks the credentials supplied and throws an exception if invalid.
 * The user id of the authenticated user is returned upon success.
 */
str
AUTHcheckCredentials(
		oid *uid,
		str *username,
		str *passwd,
		str *challenge,
		str *algo,
		str *scenario)
{
	str tmp;
	str pwd;
	str hash;
	BAT *b;
	BUN p, q;
	oid *id;

	rethrow("checkCredentials", tmp, AUTHrequireAdminOrUser(username));

	if (*username == NULL || strNil(*username))
		throwIC("checkCredentials", "Invalid credentials for unknown user");

	p = BUNfnd(userrev, *username);
	if (p == NULL) {
		/* DO NOT reveal that the user doesn't exist here! */
		throwICf("checkCredentials", "Invalid credentials for user '%s'",
				*username);
	}
	id = (oid*)(BUNtail(userrev, p));

	/* a NULL password is impossible (since we should be dealing with
	 * hashes here) so we can bail out immediately
	 */
	if (*passwd == NULL || strNil(*passwd)) {
		/* DO NOT reveal that the password is NULL here! */
		throwICf("checkCredentials", "Invalid credentials for user '%s'",
				*username);
	}

	/* find the corresponding password to the user */
	q = BUNfnd(pass, id);
	assert (q != NULL);
	tmp = (str)BUNtail(pass, q);
	assert (tmp != NULL);
	/* decypher the password (we lose the original tmp here) */
	rethrow("checkCredentials", tmp, AUTHdecypherValue(&pwd, &tmp));
	/* generate the hash as the client should have done */
	rethrow("checkCredentials", tmp, AUTHhashPassword(&hash, algo, &pwd, challenge));
	/* and now we have it, compare it to what was given to us */
	if (strcmp(*passwd, hash) != 0) {
		/* of course we DO NOT print the password here */
		throwICf("checkCredentials", "Invalid credentials for user '%s'",
				*username);
	}

	/* now see if the scenario is permitted (if restrictions for that
	 * apply)
	 */
	b = BATselect(scen, id, id);
	if (BATcount(b) > 0) {
		if (*scenario == NULL || strNil(*scenario)) {
			/* of course we DO NOT tell the exact reason here again */
			throwICf("checkCredentials", "Invalid credentials for user '%s'",
					*username);
		}

		/* ok, there are some tuples that we have to consider */
		BATloop(b, p, q) {
			tmp = (str)BUNtail(b, p);
			assert (tmp != NULL);
			if (strcmp(*scenario, tmp) == 0) {
				/* YAY!  fun!  party!  We are granted access! */
				*uid = *id;
				return(MAL_SUCCEED);
			}
		}

		/* uh oh... that we made it till here means it's wrong */
		throwICf("checkCredentials", "Invalid credentials for user '%s'",
				*username);
	} else {
		/* no scenario restriction applies, so everything is good */
		*uid = *id;
		return(MAL_SUCCEED);
	}
}

/**
 * Adds the given user with password to the administration.  The scens
 * BAT contains all scenarios allowed for the user.  If NULL or empty,
 * no restrictions for a scenario applies.  The return value of this
 * function is the user id of the added user.
 */
str
AUTHaddUser(oid *uid, str *username, str *passwd, bat *scenarios) {
	BUN p, q;
	BAT *b;
	oid *id;
	str tmp;
	str hash;

	rethrow("addUser", tmp, AUTHrequireAdmin());
	
	/* some pre-condition checks */
	if (*username == NULL || strNil(*username))
		throwIllArg("addUser", "username cannot be nil");
	if (*passwd == NULL || strNil(*passwd))
		throwIllArg("addUser", "password cannot be nil");

	/* ensure that the username is not already there */
	p = BUNfnd(userrev, *username);
	if (p != NULL)
		throwMalf("addUser", "user '%s' already exists", *username);
	
	/* we assume the BATs are still aligned */
	BUNappend(user, *username, 0);
	rethrow("addUser", tmp, AUTHcypherValue(&hash, passwd));
	BUNappend(pass, hash, 0);
	/* retrieve the oid of the just inserted user */
	p = BUNfnd(userrev, *username);
	assert (p != NULL);
	id = (oid*)(BUNtail(userrev, p));

	if (*scenarios != bat_nil) {
		b = BATdescriptor(*scenarios);
		if (b == NULL) {
			BATundo(user);
			BATundo(pass);
			throwIllArg("addUser", "invalid BAT!");
		}
		if (b->htype != TYPE_str) {
			BATundo(user);
			BATundo(pass);
			throwIllArg("addUser", "BAT should have str head");
		}

		/* associate scenarios given in the BAT with the user */
		if (BATcount(b) > 0) {
			BATloop(b, p, q) {
				BUNins(scen, id, BUNhead(b, p));
			}
		}
	}

	/* make the stuff persistent */
	TMcommit();

	*uid = *id;
	return(MAL_SUCCEED);
}

/**
 * Removes the given user from the administration.  All scenarios (if
 * any) and the password are removed as well.
 */
str
AUTHremoveUser(str *username) {
	BUN p;
	BAT *b;
	oid *id;
	str tmp;

	rethrow("addUser", tmp, AUTHrequireAdmin());

	/* pre-condition check */
	if (*username == NULL || strNil(*username))
		throwIllArg("addUser", "username cannot be nil");

	/* ensure that the username exists */
	p = BUNfnd(userrev, *username);
	if (p == NULL)
		throwMalf("addUser", "no such user: '%s'", *username);
	id = (oid*)(BUNtail(userrev, p));

	/* now, we got the oid, start removing the related tuples */
	b = BATselect(user, id, id);
	BATdel(user, b);
	b = BATselect(pass, id, id);
	BATdel(pass, b);
	b = BATselect(scen, id, id);
	BATdel(scen, b);

	/* make the stuff persistent */
	TMcommit();

	return(MAL_SUCCEED);
}

/**
 * Changes the username of the user indicated by olduser into newuser.
 * If the username is already in use, an exception is thrown and nothing
 * is modified.
 */
str
AUTHchangeUsername(str *olduser, str *newuser) {
	BUN p, q;
	str tmp;

	rethrow("addUser", tmp, AUTHrequireAdminOrUser(olduser));

	/* precondition checks */
	if (*olduser == NULL || strNil(*olduser))
		throwIllArg("changeUsername", "old username should not be nil");
	if (*newuser == NULL || strNil(*newuser))
		throwIllArg("changeUsername", "new username should not be nil");

	/* see if the olduser is valid */
	p = BUNfnd(userrev, *olduser);
	if (p == NULL)
		throwMalf("changeUsername", "user '%s' does not exist", *olduser);
	/* ... and if the newuser is not there yet */
	q = BUNfnd(userrev, *newuser);
	if (q != NULL)
		throwMalf("changeUsername", "user '%s' already exists", *newuser);

	/* ok, just do it! */
	BUNinplace(userrev, p, *newuser, BUNtail(userrev, p), 0);
	TMcommit();

	return(MAL_SUCCEED);
}

/**
 * Changes the password of the current user to the given password.  The
 * old password must match the one stored before the new password is
 * set.
 */
str
AUTHchangePassword(str *oldpass, str *passwd) {
	BUN p;
	str tmp;
	oid id;

	/* precondition checks */
	if (*oldpass == NULL || strNil(*oldpass))
		throwIllArg("changePassword", "old password should not be nil");
	if (*passwd == NULL || strNil(*passwd))
		throwIllArg("changePassword", "password should not be nil");

	/* In the future a check could be here to see if the password is a
	 * valid hash.  Using an invalid hash (like prepending a ! in front
	 * of it) could be used to 'disable' accounts. */

	/* check the old password */
	id = MCgetClient()->user;
	p = BUNfnd(pass, &id);
	tmp = BUNtail(pass, p);
	assert (tmp != NULL);
	if (strcmp(tmp, *oldpass) != 0)
		throwIC("changePassword", "Access denied");

	/* ok, just overwrite the password field for this user */
	BUNinplace(pass, p, BUNhead(pass, p), *passwd, 0);
	TMcommit();

	return(MAL_SUCCEED);
}

/**
 * Changes the password of the given user to the given password.  This
 * function can be used by the administrator to reset the password for a
 * user.  Note that for the administrator to change its own password, it
 * cannot use this function for obvious reasons.
 */
str
AUTHsetPassword(str *username, str *passwd) {
	BUN p;
	str tmp;
	oid id;

	rethrow("setPassword", tmp, AUTHrequireAdmin());

	/* precondition checks */
	if (*username == NULL || strNil(*username))
		throwIllArg("setPassword", "username should not be nil");
	if (*passwd == NULL || strNil(*passwd))
		throwIllArg("setPassword", "password should not be nil");

	/* In the future a check could be here to see if the password is a
	 * valid hash.  Using an invalid hash (like prepending a ! in front
	 * of it) could be used to 'disable' accounts. */

	id = MCgetClient()->user;
	/* find the name of the administrator and see if it equals username */
	p = BUNfnd(user, &id);
	assert (p != NULL);
	tmp = BUNtail(user, p);
	assert (tmp != NULL);
	if (strcmp(tmp, *username) == 0)
		throwIC("setPassword", "The administrator cannot set its own password, use changePassword instead");
	
	/* see if the user is valid */
	p = BUNfnd(userrev, *username);
	if (p == NULL)
		throwMalf("changePassword", "user '%s' does not exist", *username);

	/* ok, just overwrite the password field for this user */
	p = BUNfnd(pass, &id);
	assert (p != NULL);
	BUNinplace(pass, p, BUNhead(pass, p), *passwd, 0);
	TMcommit();

	return(MAL_SUCCEED);
}

/**
 * Adds the given scenario to the list of allowed scenarios for the
 * given user.  Note that this can result in unexpected behaviour when
 * there where previously no scenarios defined for the user (which means
 * all scenarios are permitted).
 */
str
AUTHaddScenario(str *username, str *scenario) {
	BUN p;
	str tmp;

	rethrow("addUser", tmp, AUTHrequireAdmin());

	/* precondition checks */
	if (*username == NULL || strNil(*username))
		throwIllArg("addScenario", "username should not be nil");
	if (*scenario == NULL || strNil(*scenario))
		throwIllArg("addScenario", "scenario should not be nil");

	/* see if the user is valid */
	p = BUNfnd(userrev, *username);
	if (p == NULL)
		throwMalf("addScenario", "user '%s' does not exist", *username);

	/* add the scenario for this user */
	BUNins(scen, BUNtail(userrev, p), *scenario);
	TMcommit();

	return(MAL_SUCCEED);
}

/**
 * Removes the given scenario from the list of allowed scenarios for the
 * given user.  Note that removing the last allowed scenario results in
 * the opposite effect: it will allow any scenario to be used.
 */
str
AUTHremoveScenario(str *username, str *scenario) {
	BUN p;
	BAT *b;
	str tmp;

	rethrow("addUser", tmp, AUTHrequireAdmin());

	/* precondition checks */
	if (*username == NULL || strNil(*username))
		throwIllArg("removeScenario", "username should not be nil");
	if (*scenario == NULL || strNil(*scenario))
		throwIllArg("removeScenario", "scenario should not be nil");

	/* see if the user is valid */
	p = BUNfnd(userrev, *username);
	if (p == NULL)
		throwMalf("removeScenario", "user '%s' does not exist", *username);

	/* see if the scenario is valid for this user */
	b = BATselect(scen, BUNtail(userrev, p), BUNtail(userrev, p));
	b = BATselect(BATmirror(b), *scenario, *scenario);
	if (BATcount(b) == 0)
		throwMalf("removeScenario", "scenario '%s' not found for user", *scenario);
	if (BATcount(b) > 1)
		throwMalf("removeScenario", "inconsistent authorisation administration, scenario '%s' multiple times defined", *scenario);

	/* ok, remove it */
	BATdel(scen, BATmirror(b));
	TMcommit();

	return(MAL_SUCCEED);
}

/**
 * Resolves the given user id and returns the associated username.  If
 * the id is invalid, an exception is thrown.  The given pointer to the
 * username char buffer should be NULL if this function is supposed to
 * allocate memory for it.  If the pointer is pointing to an already
 * allocated buffer, it is supposed to be of size BUFSIZ.
 */
str
AUTHresolveUser(str *username, oid *uid) {
	BUN p;

	if (uid == NULL || *uid == oid_nil)
		throwIllArg("resolveUser", "userid should not be nil");
	
	p = BUNfnd(user, uid);
	if (p == NULL)
		throwMalf("resolveUser", "No such user with id: " OIDFMT, *uid);

	assert (username != NULL);

	if (*username == NULL) {
		*username = GDKstrdup((str)(BUNtail(user, p)));
	} else {
		snprintf(*username, BUFSIZ, "%s", (str)(BUNtail(user, p)));
	}

	return(MAL_SUCCEED);
}

/**
 * Returns the username of the current user.
 */
str
AUTHgetUsername(str *username) {
	BUN p;
	oid id;

	id = MCgetClient()->user;
	p = BUNfnd(user, &id);
	if (p == NULL) {
		GDKfatal("Internal error: user id that doesn't exist: " OIDFMT,
				MCgetClient()->user);
	}

	*username = BUNtail(user, p);
	return(MAL_SUCCEED);
}


/*=== the vault ===*/

/* yep, the vault key is just stored in memory */
static str vaultKey = NULL;

/**
 * Unlocks the vault with the given password.  Since the password is
 * just the decypher key, it is not possible to directly check whether
 * the given password is correct.  If incorrect, however, all decypher
 * operations will probably fail or return an incorrect decyphered
 * value.
 */
str
AUTHunlockVault(str *password) {
	str tmp;

	rethrow("unlockVault", tmp, AUTHrequireAdmin());

	if (password == NULL || strNil(*password))
		throwIllArg("unlockVault", "password should not be nil");

	/* even though I think this function should be called only once, it
	 * is not of real extra efforts to avoid a mem-leak if it is used
	 * multiple times
	 */
	if (vaultKey != NULL) GDKfree(vaultKey);

	vaultKey = GDKstrdup(*password);
	return(MAL_SUCCEED);
}

/**
 * Decyphers a given value, using the vaultKey.  The returned value
 * might be incorrect if the vaultKey is incorrect or unset.  If the
 * cypher algorithm fails or detects an invalid password, it might throw
 * an exception.  The ret string is GDKmalloced, and should be GDKfreed
 * by the caller.
 */
static str
AUTHdecypherValue(str *ret, str *value) {
	/* Cyphering and decyphering can be done using many algorithms.
	 * Future requirements might want a stronger cypher than the XOR
	 * cypher chosen here.  It is left up to the implementor how to do
	 * that once those algoritms become available.  It could be
	 * #ifdef-ed or on if-basis depending on whether the cypher
	 * algorithm is a compile, or runtime option.  When necessary, this
	 * function could be extended with an extra argument that indicates
	 * the cypher algorithm.
	 */
	
	/* this is the XOR decypher implementation */
	str r = GDKmalloc(sizeof(char) * (strlen(*value) + 1));
	str w = r;
	str s = *value;
	int escaped = 0;
	/* we default to some garbage key, just to make password unreadable
	 * (a space would only uppercase the password) */
	str key = vaultKey == NULL ? "Xas632jsi2whjds8" : vaultKey;
	int keylen = strlen(key);

	/* XOR all characters.  If we encounter a 'one' char after the XOR
	 * operation, it is an escape, so replace it with the next char. */
	for (; *s != '\0'; *s++) {
		*w = *s ^ key[(s - *value) % keylen];
		if (*w == '\1' && escaped == 0) {
			escaped = 1;
			continue;
		} else if (escaped != 0) {
			*w -= 1;
			escaped = 0;
		}
		*w++;
	}
	*w = '\0';

	*ret = r;
	return(MAL_SUCCEED);
}

/**
 * Cyphers the given string using the vaultKey.  If the cypher algorithm
 * fails or detects an invalid password, it might throw an exception.
 * The ret string is GDKmalloced, and should be GDKfreed by the caller.
 */
static str
AUTHcypherValue(str *ret, str *value) {
	/* this is the XOR cypher implementation */
	str r = GDKmalloc(sizeof(char) * (strlen(*value) * 2 + 1));
	str w = r;
	str s = *value;
	/* we default to some garbage key, just to make password unreadable
	 * (a space would only uppercase the password) */
	str key = vaultKey == NULL ? "Xas632jsi2whjds8" : vaultKey;
	int keylen = strlen(key);

	/* XOR all characters.  If we encounter a 'zero' char after the XOR
	 * operation, escape it with an 'one' char. */
	for (; *s != '\0'; *s++) {
		*w = *s ^ key[(s - *value) % keylen];
		if (*w == '\0') {
			*w++ = '\1';
			*w = '\1';
		} else if (*w == '\1') {
			*w++ = '\1';
			*w = '\2';
		}
		*w++;
	}
	*w = '\0';

	*ret = r;
	return(MAL_SUCCEED);
}

/**
 * Returns a comma separated list of supported hash algorithms.  The
 * returned string is GDKmalloced and should be GDKfreed.
 */
str
AUTHgetHashAlgorithms(str *ret) {
	/* currently, two "hashes" are available, crypt and plain.  The
	 * former is the UNIX crypt implementation, the latter is no hash at
	 * all, as the name already suggests.  Future implementations could
	 * include better hashes such as MD5, SHA-1, etc.
	 * The return string should in such case more dynamically be built,
	 * instead of hardcoded like here.
	 */
	str t = alloca(sizeof(char) * BUFSIZ);
	*t = '\0';
#ifdef HAVE_OPENSSL
	strcat(t, "SHA1,MD5,");
#endif
#ifdef HAVE_CRYPT
	strcat(t, "crypt,");
#endif
	strcat(t, "plain");

	*ret = GDKstrdup(t);
	return(MAL_SUCCEED);
}

/**
 * Returns the hash for the given password, challenge and algorithm.
 * The hash calculated using the given algorithm over the password
 * concatenated with the challenge.
 */
static str
AUTHhashPassword(str *ret, str *algo, str *password, str *challenge) {
	if (strcmp(*algo, "plain") == 0) {
		/* The plain text algorithm, doesn't really hash at all.  It's
		 * the easiest algorithm, as it just appends the challenge to
		 * the password and returns it.
		 */
		*ret = GDKmalloc(sizeof(char) * (strlen(*password) + strlen(*challenge) + 1));
		sprintf(*ret, "%s%s", *password, *challenge);
		return(MAL_SUCCEED);
#ifdef HAVE_OPENSSL
	} else if (strcmp(*algo, "SHA1") == 0) {
		/* The SHA-1 RSA hash algorithm is a 160 bit hash.  In order to
		 * use in a string, a hexadecimal representation of the bit
		 * sequence is used.
		 */
		unsigned char md[20]; /* should be SHA_DIGEST_LENGTH */
		int len = strlen(*password) + strlen(*challenge);
		char key[len];
		strcpy(key, *password);
		strncat(key, *challenge, strlen(*challenge));
		SHA1((unsigned char*)key, len, md);
		*ret = GDKmalloc(sizeof(char) * (20 * 2 + 1));
		sprintf(*ret, "%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"
				"%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x",
				md[0], md[1], md[2], md[3], md[4],
				md[5], md[6], md[7], md[8], md[9],
				md[10], md[11], md[12], md[13], md[14],
				md[15], md[16], md[17], md[18], md[19]
			);
		return(MAL_SUCCEED);
	} else if (strcmp(*algo, "MD5") == 0) {
		/* The MD5 hash algorithm is a 128 bit hash.  In order to
		 * use in a string, a hexadecimal representation of the bit
		 * sequence is used.
		 */
		unsigned char md[16]; /* should be MD5_DIGEST_LENGTH */
		int len = strlen(*password) + strlen(*challenge);
		char key[len];
		strcpy(key, *password);
		strncat(key, *challenge, strlen(*challenge));
		MD5((unsigned char*)key, len, md);
		*ret = GDKmalloc(sizeof(char) * (16 * 2 + 1));
		sprintf(*ret, "%02x%02x%02x%02x%02x%02x%02x%02x"
				"%02x%02x%02x%02x%02x%02x%02x%02x",
				md[0], md[1], md[2], md[3],
				md[4], md[5], md[6], md[7],
				md[8], md[9], md[10], md[11],
				md[12], md[13], md[14], md[15]
			);
		return(MAL_SUCCEED);
#endif
#ifdef HAVE_CRYPT
	} else if (strcmp(*algo, "crypt") == 0) {
		/* The crypt hash algorithm uses UNIX crypt, a modification of
		 * DES which uses a 2-char wide salt.  Because crypt only cares
		 * about the first eight characters of the given password, the
		 * challenge may not be taken into account at all.  As salt, the
		 * last two characters of the challenge are used.
		 */
		char key[8]; /* NULL termination is not necessary */
		char salt[3]; /* NULL termination is a necessity! */
		str hash;
		int len;

		/* prepare the key */
		len = strlen(*password);
		if (len >= 8) {
			strncpy(key, *password, 8);
		} else {
			/* pad with the challenge, we know it is always 8+ chars */
			strncpy(key, *password, len);
			strncpy(key + len, *challenge, 8 - len);
		}

		/* prepare the salt */
		len = strlen(*challenge);
		salt[0] = *challenge[len - 2];
		salt[1] = *challenge[len - 1];
		salt[2] = '\0';

		/* call crypt to do the work */
		hash = crypt(key, salt);
		assert (hash != NULL);
		*ret = GDKstrdup(hash);
		return(MAL_SUCCEED);
#endif
	} else {
		throwMalf("hashPassword", "unsupported hash type: '%s'", algo);
	}
}
@}
