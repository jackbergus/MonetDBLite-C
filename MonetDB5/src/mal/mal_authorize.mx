@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2006 CWI.
@' All Rights Reserved.

@f mal_authorize
@a M. Kersten, F. Groffen
@+ User authorization
The inner core of the system provides a basic authorization scheme. 
Authorization is coupled with running a scenario
or accessing the content of variable boxes.
A user may only use those resources if it is explicitly permitted.

The authorization scheme can be used by routines as a first
line of defense against unauthorized access. They could 
augment it with their own persistent information for further
control.

The owner of the server and database is he who was able to
start the server in the first place. It puts him in a special
position. He may change the authorization information and view
the permission tables. He is also the owner of system provided
boxes, e.g. @code{const} and @code{statistics}.
All other users are only allowed to change their password.

The implementation is straight forward.
It keeps a persistent BAT @code{user} around, which associates a
user id with a corresponding (encoded) password to their 
permissible scenarios. These tables can be inspected by the
system owner and any linked in code to refine the scheme.

@{

The implementation is straightforward. A persistent memory mapped
BAT keeps the information for fast access. 
The guest accounts 'user' without password 
and monetdb/monetdb are  being added upon creation of this BAT.
This allows all known functionality to work.

The identity of the server owner is not copied into this table purposely.

@h
#ifndef _MAL_AUTHORIZE_H
#define _MAL_AUTHORIZE_H

/* #define _DEBUG_AUTH_*/
#include "mal.h"
#include "mal_exception.h"
#include "mal_instruction.h"
#include "mal_client.h"

mal_export str AUTHcheckCredentials(str *user, str *passwd, str *language);
mal_export str MALinitClient(Client cntxt);
mal_export str introduceUser(str nme, str passwd, str scen );
mal_export str dropAllFromUser(str nme);
mal_export str dropUser(str nme, str scen );
mal_export int checkAuthorization(str nme, str passwd, str scen );
mal_export int isServerOwner(Client c);
mal_export str setNewPassword(str nme, str passwd, str newpasswd);
mal_export bat getAllPermissions();
mal_export bat getAllPasswords();

mal_export void setServerOwner(str o, str p);
mal_export void initAuthTables();

/* convenience macros */
#define throwIC(X, Y) throw("InvalidCredentialsException", X, Y);
#define throwICf(X, Y, A) throwf("InvalidCredentialsException", X, Y, A);

#endif /* _MAL_AUTHORIZE_H */
@-
@c
#include "mal_authorize.h"

static str owner = NULL;
static str passw = NULL;

void
setServerOwner(str o, str p) {
	if (owner || passw)
		GDKfatal("Attempt to reset server owner identity");
	owner = o ? o : "user";
	passw = p ? p : "";
#ifdef _DEBUG_AUTH_
	printf("serverOwner=%s\n",owner);
#endif
	assert(owner != NULL);
}

@-
Localize the authorization tables in the database.  The authorization
tables are a set of aligned BATs that store username, password (hashed)
and language permissions.
If the BATs do not exist, they are created.  Initializing the
authorization tables can only be done after the GDK kernel has been
initialized.
@c
static BAT *user = NULL, *userrev;
static BAT *pass = NULL, *passrev;
static BAT *lang = NULL, *langrev;

void
initAuthTables() {
	BAT *b;
	int isNew = 1;

	/* skip loading if already loaded */
	if (user != NULL && pass != NULL && lang != NULL)
		return;

	/* if one is not NULL here, something is seriously screwed up */
	assert (user == NULL);
	assert (pass == NULL);
	assert (lang == NULL);

	/* load/create users BAT */
	b = BATdescriptor(BBPindex("M5system_auth_user"));
	if (b == NULL) {
		b = BATnew(TYPE_void, TYPE_str, 256);
		if (b == NULL)
			GDKfatal("mal_authorize: could not allocate user table.");

		BATkey(b, TRUE);
		BBPrename(b->batCacheid, "M5system_auth_user");
		BATmode(b, PERSISTENT);
		BATcommit(b);
	} else {
		isNew = 0;
	}
	user = b;
	userrev = BATmirror(b);

	/* load/create password BAT */
	b = BATdescriptor(BBPindex("M5system_auth_passwd"));
	if (b == NULL) {
		b = BATnew(TYPE_void, TYPE_str, 256);
		if (b == NULL)
			GDKfatal("mal_authorize: could not allocate password table.");

		BATkey(b, TRUE);
		BBPrename(b->batCacheid, "M5system_auth_passwd");
		BATmode(b, PERSISTENT);
		BATcommit(b);
	} else {
		isNew = 0;
	}
	pass = b;
	passrev = BATmirror(b);

	/* load/create language BAT */
	b = BATdescriptor(BBPindex("M5system_auth_lang"));
	if (b == NULL) {
		b = BATnew(TYPE_oid, TYPE_str, 256);
		if (b == NULL)
			GDKfatal("mal_authorize: could not allocate language table.");

		BATkey(b, TRUE);
		BBPrename(b->batCacheid, "M5system_auth_lang");
		BATmode(b, PERSISTENT);
		BATcommit(b);
	} else {
		isNew = 0;
	}
	lang = b;
	langrev = BATmirror(b);

	if (isNew == 1) {
		/* insert the monetdb/monetdb administrator account on a
		 * complete fresh and new auth tables system */
		BUNappend(user, "monetdb", 0);
		BUNappend(pass, "monetdb", 0);
		BATcommit(user);
		BATcommit(pass);
	}
}

/**
 * Checks the credentials supplied and returns an exception if invalid.
 */
str
AUTHcheckCredentials(str *user, str *passwd, str *language) {
	str tmp;
	BAT *b;
	BUN p, q;
	
	initAuthTables();

	if (*user == NULL)
		throwIC("checkCredentials", "Invalid credentials for unknown user");

	p = BUNfnd(userrev, *user);
	if (p == NULL) {
		/* DO NOT reveal that the user doesn't exist here! */
		throwICf("checkCredentials", "Invalid credentials for user '%s'",
				*user);
	}

	/* a NULL password is impossible (since we should be dealing with
	 * hashes here) so we can bail out immediately
	 */
	if (*passwd == NULL) {
		/* DO NOT reveal that the password is NULL here! */
		throwICf("checkCredentials", "Invalid credentials for user '%s'",
				*user);
	}

	/* find the corresponding password to the user */
	q = BUNfnd(pass, BUNtail(userrev, p));
	assert (q != NULL);
	tmp = (str)BUNtail(pass, q);
	assert (tmp != NULL);
	/* and now we have it, compare it to what was given to us */
	if (strcmp(*passwd, tmp) != 0) {
		/* of course we DO NOT print the password here */
		throwICf("checkCredentials", "Invalid credentials for user '%s'",
				*user);
	}

	/* now see if the language is permitted (if restrictions for that
	 * apply)
	 */
	b = BATselect(lang, BUNtail(userrev, p), BUNtail(userrev, p));
	if (BATcount(b) > 0) {
		if (*language == NULL) {
			/* of course we DO NOT tell the exact reason here again */
			throwICf("checkCredentials", "Invalid credentials for user '%s'",
					*user);
		}

		/* ok, there are some tuples that we have to consider */
		BATloop(b, p, q) {
			tmp = (str)BUNtail(b, p);
			assert (tmp != NULL);
			if (strcmp(*language, tmp) == 0) {
				/* YAY!  fun!  party!  We are granted access! */
				return(MAL_SUCCEED);
			}
		}

		/* uh oh... that we made it till here means it's wrong */
		throwICf("checkCredentials", "Invalid credentials for user '%s'",
				*user);
	} else {
		/* no language restriction applies, so everything is good */
		return(MAL_SUCCEED);
	}
}

str
MALinitClient(Client c) {
#ifdef _DEBUG_AUTH_
	printf("authorize %s:%s %s\n", c->user, c->password, c->scenario);
#endif
	/* don't do authorisation right now, because it doesn't work at all
	 * but for a hard-coded user "user" with password "" */
	if (1 == 1) return MAL_SUCCEED;
	
	if (owner == NULL || c->user == NULL)
		return MAL_SUCCEED; /* avoid missing info */

	/*
	if (strcmp(c->user, owner) == 0 &&
		(passw == NULL ||
		 strcmp((c->password ? c->password : ""), passw) == 0))
		return MAL_SUCCEED;
	*/

	return throwMessage("mal.authorize", "Access denied");
}

str 
introduceUser(str nme, str passwd, str scen )
{
#ifdef _DEBUG_AUTH_
	printf("add user %s %s %s\n", nme,passwd,scen);
#endif
	initAuthTables();
	BUNins(pass, nme, passwd);
	BUNins(user, nme, scen);
	BATcommit(pass);
	BATcommit(user);
	return MAL_SUCCEED;
}

str
dropUser(str nme, str scen )
{
	BAT *b;
#ifdef _DEBUG_AUTH_
	printf("del user %s %s\n", nme,scen);
#endif
	b= BATselect(BATmirror(user),nme,nme);
	b= BATselect(BATmirror(b),scen,scen);
	BATdel(user,b);
	b= BATselect(BATmirror(user),nme,nme);
	if( BATcount(b) == 0){
		b= BATselect(passrev,nme,nme);
		BATdel(passrev,b);
		BATcommit(pass);
	}
	return MAL_SUCCEED;
}

str
dropAllFromUser(str nme)
{
	BAT *b;
#ifdef _DEBUG_AUTH_
	printf("del user %s \n", nme);
#endif
	b= BATselect(userrev,nme,nme);
	BATdel(userrev,b);
	b= BATselect(passrev,nme,nme);
	BATdel(passrev,b);
	BATcommit(pass);
	BATcommit(user);
	return MAL_SUCCEED;
}

int
checkAuthorization(str nme, str passwd, str scen )
{
	BAT *b;
#ifdef _DEBUG_AUTH_
	printf("check user %s %s %s\n", nme,passwd,scen);
#endif
	b= BATselect(userrev,nme,nme);
	b= BATselect(BATmirror(b),scen,scen);
	if( BATcount(b) == 0) return FALSE;

	b= BATselect(passrev,nme,nme);
	b= BATselect(BATmirror(b),passwd,passwd);
	if( BATcount(b) == 0) return FALSE;
	return TRUE;
}

int
isServerOwner(Client c){
#ifdef _DEBUG_AUTH_
	printf("isServerOwner? %s/%s\n",c->user,c->password);
#endif
	return strcmp(c->user, "user") == 0;
}

str
setNewPassword(str nme, str passwd, str newpasswd)
{
	BAT *b;
	printf("new password %s %s %s\n", nme,passwd,newpasswd);
#ifdef _DEBUG_AUTH_
#endif
	b= BATselect(passrev,nme,nme);
	b= BATselect(BATmirror(b),passwd,passwd);
	if( BATcount(b) == 0) 
		return throwMessage("clients.newPassword","Permission denied");

	BATdel(passrev,b);
	BUNins(pass,nme,newpasswd);
	BATcommit(pass);
	return MAL_SUCCEED;
}

@-
The information can be obtained by the dba for inspection
@c
bat
getAllPermissions()
{
	BAT *b;
#ifdef _DEBUG_AUTH_
	printf("get authorizations \n");
#endif
	if( user ){
		b= BATcopy(user);
		BBPkeepref(b->batCacheid);
		return b->batCacheid;
	}
	return 0;
}
bat
getAllPasswords()
{
	BAT *b;
#ifdef _DEBUG_AUTH_
	printf("get authorizations \n");
#endif
	if( user ){
		b= BATcopy(pass);
		BBPkeepref(b->batCacheid);
		return b->batCacheid;
	}
	return 0;
}
@}
