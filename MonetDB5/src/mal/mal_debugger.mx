@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2007 CWI.
@' All Rights Reserved.

@a M.L. Kersten
@* The MAL Debugger

In practice it is hard to write a correct MAL program the
first time around. Instead, it is more often constructed by
trial-and-error. As long as there are syntax and semantic errors
the MAL compiler provides a sufficient handle to proceed. Once
it passes the compiler we have to resort to a debugger to
assess its behavior.

Note, the MAL debugger described here can be used in conjunction
with the textual interface client @emph{mclient} only.
The JDBC protocol does not permit passing through information that
'violates' the protocol.
@menu
* Program Debugging ::
* Handling Breakpoints::
* Profile Switches::
* Program Inspection::
* Runtime Inspection::
* Debugger Attachment::
@end menu
@node Program Debugging, Handling Breakpoints, The MAL Debugger, The MAL Debugger
@+ Program Debugging
To ease debugging and performance monitoring, the MAL interpreter
comes with a gdb-like debugger.
An illustrative session elicits the functionality offered.

@example
>function test(i:int):str;
>	io.print(i);
>	i:= i*2;
>	b:= bat.new(:int,:int);
>	bat.insert(b,1,i);
>	io.print(b);
>	return test:= "ok";
>end test;
>user.test(1);
[ 1 ]
#-----------------#
# h     t         # name
# int   int       # type
#-----------------#
[ 1,      2       ]
@end example

The debugger can be entered at any time using the call mdb.start().
An overview of the available commands is readily available.
@example
>mdb.start();
#mdb !end main;
mdb>help
	next             -- Advance to next statement
	continue         -- Continue program being debugged
	catch            -- Catch the next exception 
	break [<var>]    -- set breakpoint on current instruction or <var>
	delete [<var>]   -- remove break/trace point <var>
	debug <int>      -- set kernel debugging mask
	dot [<int>] [<file>]  -- generate the dependency graph
	step             -- advance to next MAL instruction
	module           -- display a module signatures
	atom             -- show atom list
	finish           -- finish current call
	exit             -- terminate executionr
	quit             -- turn off debugging
	list <obj>       -- list current program block
	List <obj>       -- list with type information
	var  <obj>       -- print symbol table for module
	optimizer <obj>  -- display program after optimizer step
	print <var>      -- display value of a variable
	print <var> <cnt>[<first>] -- display BAT chunk
	info <var>       -- display bat variable properties
	run              -- restart current procedure
	where            -- print stack trace
	down             -- go down the stack
	up               -- go up the stack
	trace <var>      -- trace assignment to variables
	set @verb{ { }timer,flow,io,memory@verb{ } } -- set trace switches
	unset            -- turn off switches
	help             -- this message
mdb>
@end example

The term @sc{<obj>} is an abbreviation for a 
MAL operation @sc{<mod>.<fcn>}, optionally extended with
a version number, i.e. @sc{[<nr>]}.
The @sc{var} denotes a variable in the current stack frame.
Debugger commands may be abbreviated.

We walk our way through a debugging session, highlighting the
effects of the debugger commands.
The call to mdb.start() has been encapsulated in a complete
MAL function, as shown by issuing the list command.
A more detailed listing shows the binding to the C-routine
and the result of type resolution.
@example
>mdb.start();
#end main;
mdb>l
function user.main():int;
	mdb.start();
end main;
mdb>L
function user.main():int;       # 0  (main:int)
	mdb.start();        # 1 MDBstart (_1:void)
end main;       # 2
@end example
The user module is the default place for function defined at
the console. The modules loaded can be shown typeing the
command 'module' (or 'm'  for short). 
The function signatures become visible using the module and optionally
the function name.
@example
mdb>m alarm
#command alarm.alarm(secs:int,action:str):void address ALARMsetalarm;
#command alarm.ctime():str address ALARMctime;
#command alarm.epilogue():void address ALARMepilogue;
#command alarm.epoch():int address ALARMepoch;
#command alarm.prelude():void address ALARMprelude;
#command alarm.sleep(secs:int):void address ALARMsleep;
#command alarm.time():int address ALARMtime;
#command alarm.timers():bat[:str,:str] address ALARMtimers;
#command alarm.usec():lng address ALARMusec;
mdb>m alarm.sleep
#command alarm.sleep(secs:int):void address ALARMsleep;
mdb>
@end example
The debugger mode is left with a <return>.
Any subsequent MAL instruction re-activates the debugger to
await for commands. The default operation is to step through
the execution using the 'next' ('n') or 'step' ('s) commands,
as shown below.
@example
>user.test(1);
#    user.test(1);
mdb>n
#    io.print(i);
mdb>
[ 1 ]
#    i := calc.*(i,2);
mdb>
#    b := bat.new(:int,:int);
mdb>
@end example
The last instruction shown is next to be executed. The result can be
shown using a print statement, which contains the location of
the variable on the stack frame, its name, its value and type.
The complete stack frame becomes visible with 'values' ('v')
command:
@example
#    bat.insert(b,1,i);
mdb>
#    io.print(b);
mdb>v
#Stack for 'test' size=32 top=11
#[0] test        = nil:str
#[1] i   = 4:int
#[2] _2  = 0:int   unused
#[3] _3  = 2:int  constant
#[4] b   = <tmp_1226>:bat[:int,:int]   count=1 lrefs=1 refs=0
#[5] _5  = 0:int   type variable
#[6] _6  = nil:bat[:int,:int]   unused
#[7] _7  = 1:int  constant
#[8] _8  = 0:int   unused
#[9] _9  = "ok":str  constant
@end example
The variables marked 'unused' have been introduced as temporary variables,
but which are not referenced in the remainder of the program.
It also illustrates basic BAT properties, a complete description of which
can be obtained using the 'info' ('i') command.
A sample of the BAT content can be printed passing tuple indices, e.g.
'print b 10 10' prints the second batch of ten tuples.

@node Handling Breakpoints, Profile Switches, Program Debugging, The MAL Debugger
@+ Handling Breakpoints
A powerful mechanism for debugging a program is to set breakpoints
during the debugging session.
The breakpoints are designated by a target variable name,
a [module.]function name, or a MAL line number (#<number>).

The snippet below illustrates the reaction to set a break point
on assignment to variable 'i'. 
@example
>mdb.start();
#end main;
mdb>
>user.test(1);
#    user.test(1);
mdb>break i
breakpoint on 'i' not set
mdb>n
#    io.print(i);
mdb>break i
mdb>c
[ 1 ]
#    i := calc.*(i,2);
mdb>
@end example

The breakpoints remain in effect over multiple function calls.
They can be removed with the @sc{delete} statement.
A list of all remaining breakpoints is obtained with @sc{breakpoints}.

The interpreter can be instructed to call the debugger as soon as an exception
is raised. Simply add the instruction @sc{mdb.setCatch(true)}.

@node Profile Switches, Program Inspection, Handling Breakpoints,  The MAL Debugger
@+ Profile Switches
Switches control the level of detail output shown while debugging
or tracing program execution.
They are toggled with the @sc{set} and @sc{unset} command.
The following switches are currently supported:
@table @sc
@item timer
activates a listing of all instructions being executed.
It is measured in wall-clock time.
@item flow
shows the total byte size of all BAT target results and input arguments.
It is a good indicator on the amount of data being processed.
@item memory
keeps track on growing memory needs.
@item io
keeps track on the amount of physical IO
and is used to detect operators consuming excessive amounts of space.
@end table

The snippet below shows setting the @sc{memory} and @sc{timer}
switch. The switches take effect at the next instruction.
@example
mdb>set timer
mdb>set flow
mdb>c
[ 3 ]
#    26 usec#   0  0#    io.print(i=3)
#     6 usec#   0  0#    i := calc.*(i=6, _3=2)
#    10 usec#   0  0#    b := bat.new(_5=0, _6=0)
#     7 usec#   0  8#    bat.insert(b=<tmp_167>bat[:int,:int]@verb{ { }1@verb{ } }, _8=1, i=6)
#-----------------#
# h     t         # name
# int   int       # type
#-----------------#
[ 1,      6       ]
#    41 usec#   0  8#    io.print(b=<tmp_167>bat[:int,:int]@verb{ { }1@verb{ } })
#     7 usec#   0  0#    return test := "ok";
#   211 usec#   0  0#    user.test(_2=3)

@end example
@node Program Inspection, Runtime Inspection, Profile Switches,  The MAL Debugger
@+ Program Inspection 
The debugger commands available for inspection of the program and
symbol tables are:
@table @sc
@item list (List) [<mod>.<fcn>['['<nr>']']]
A listing of the current MAL block, or one designated
by the <mod>.<fcn> is produced.
The @sc{[<nr>]} extension provides access to an element
in the MAL block history.
The alternative name 'List' also produces the type information.
@item optimizer  [<mod>.<fcn>['['<nr>']']]
Gives an overview of the optimizer actions in the history of the MAL block.
Intermediate results can be accessed using the list command.
@item atoms
Lists the atoms currently known
@item modules [<mod>]
Lists the modules currently known. An optional <mod> argument
produces a list of all signatures within the module identified.
@item dot [<mod>.<fcn>['['<nr>']']] [<file>]
A dataflow diagram can be produced using the @sc{dot} command.
It expects a function identifier with an optional history index
and produces a file for the Linux program @sc{dot},
which can produce a nice, multi-page graph to illustrate plan
complexity.
@end table

@example
mdb>dot user.test
@end example
This example produces the @sc{user-tst.dot} in the current
working directory. The program call
@example
dot -Tps user-tst-0.dot -o user-tst-0.ps
@end example
creates a postscript file with the graphs. With the Adobe reader professional
you can break it up into multiple pages. An alternative
is the program available from 
 @sc{http://www.tug.org/tex-archive/support/poster/poster.c}
The result is shown in the figure below:

Since the flow graphs become rather complex, an optional variable
list limits its size.[TODO]

@node Runtime Inspection, Debugger Attachment, Program Inspection,  The MAL Debugger
@+ Runtime Inspection and Reflection
Part of the debugger functionality can also be used directly with
MAL instructions. 
The execution trace of a snippet of code can be visualized 
encapsulation with @sc{mdb.setTrace(true)} and @sc{mdb.setTrace(false)}.
Likewise, the performance can be monitored with the command @sc{mdb.setTimer(on/off)}.
Using a boolean argument makes it easy to control the (performance) trace
at run time. The following snippet shows the effect of patching
the test case.
@example
>function test(i:int):str;
>	mdb.setTrace(true);
>	io.print(i);
>	i:= i*2;
>	b:= bat.new(:int,:int);
>	bat.insert(b,1,i);
>	io.print(b);
>	mdb.setTrace(false);
>	return test:= "ok";
>end test;
>user.test(1);
#    mdb.setTrace(_3=true)
[ 1 ]
#    io.print(i=1)
#    i := calc.*(i=2, _5=2)
#    b := bat.new(_7=0, _8=0)
#    bat.insert(b=<tmp_1226>, _10=1, i=2)
#-----------------#
# h     t         # name
# int   int       # type
#-----------------#
[ 1,      2       ]
#    io.print(b=<tmp_1226>)
#   261 usec!    user.test(_2=1)
>
@end example

The command @sc{mdb.setTimer()} toggles the performance traceing flag. 
The argument is a boolen to designate its state. 
The primary output of the timer switch is statistics in micro-seconds,
the memory tracer shows the arena increment, and the IO tracer
shows in- and out-blocks.
The time spent on preparing the trace information is excluded
from the report.
For more detailed timing information the Linux
tool @emph{valgrind} may be of help.

The routines @sc{mdb.setFlow()}, @sc{mdb.setMemory()}, and @sc{mdb.setIO()} 
(de-)activate the other switches.
@example
>function test(i:int):str;
>	mdb.setTimer(true);
>	io.print(i);
>	i:= i*2;
>	b:= bat.new(:int,:int);
>	bat.insert(b,1,i);
>	io.print(b);
>	mdb.setTimer(false);
>	return test:= "ok";
>end test;
>user.test(1);
#     6 usec#    mdb.setTimer(_3=true)
[ 1 ]
#    43 usec#    io.print(i=1)
#     5 usec#    i := calc.*(i=2, _5=2)
#    24 usec#    b := bat.new(_7=0, _8=0)
#    10 usec#    bat.insert(b=<tmp_1226>, _10=1, i=2)
#-----------------#
# h     t         # name
# int   int       # type
#-----------------#
[ 1,      2       ]
#   172 usec#    io.print(b=<tmp_1226>)
#   261 usec#    user.test(_2=1)
@end example

It is also possible to activate the debugger from within a program 
using @sc{mdb.start()}. It remains in this mode until 
you either issue a quit command, or the command mdb.stop() instruction is
encountered. 
The debugger is only activated when the user can direct its execution
from the client interface. Otherwise, there is no proper input channel
and the debugger will run in trace mode.

The program listing functionality of the debugger is 
also captured in the MAL debugger module. The current code
block can be listed using @sc{mdb.list()} and @sc{mdb.List()}.
An arbitrary code block can be shown with  @sc{mdb.list}(@emph{module},@emph{function})
and @sc{mdb.List}(@emph{module},@emph{function}).
A BAT representation of the current function is return by @sc{mdb.getDefinition()}@.

The symbol table and stack content, if available, can be shown with
the operations @sc{mdb.var()} and @sc{mdb.list}(@emph{module},@emph{function})
Access to the stack frames may be helpful in the context of exception handling.
The operation @sc{mdb.getStackDepth()} gives the depth and individual
elements can be accessed as BATs using @sc{mdb.getStackFrame(@emph{n})}.
The top stack frame is accessed using @sc{mdb.getStackFrame()}.

@node Debugger Attachment, The MAL Profiler, Runtime Inspection,  The MAL Debugger
@+ Debugger Attachment
Debugging a running MAL process is simplified with a few
hooks in the kernel. It is illustrated with a short example.

First open a client connection with the user using MAL as
preferred language. Then the state of the system can be inspected,
in particular, the clients active can be looked up.
@example
> b:= clients.getLogins();
> c:= clients.getUsers();
> io.print(b,c);
@end example
Locate the process you are interested in and obtain its identifier,
say N (the first column in the list above).
The next step is to gracefully put the running process into
debugging mode without jeopardizing the application running.
@example
> clients.suspend(N);
@end example
As soon as the next MAL instruction of process N starts 
the target process is put to sleep and the debugger gains
control. You can now inspect the execution context.
The control ends when you leave the debugger with a 'quit' command.

@{
@- Compilation control
Being able to debug comes at a price.
It should be possible to turn off the feature at compile time.

@h
#ifndef _MAL_DEBUGGER_H
#define _MAL_DEBUGGER_H

#include "mal_scenario.h"
#include "mal_client.h"

#define MAL_DEBUGGER		/* debugger is active */

#define MAXBREAKS 32

mal_export int MDBdelay;	/* do not immediately react */
typedef struct {
	MalBlkPtr brkBlock[MAXBREAKS];
	int		brkPc[MAXBREAKS];
	int		brkVar[MAXBREAKS];
	str		brkMod[MAXBREAKS];
	str		brkFcn[MAXBREAKS];
	char	brkCmd[MAXBREAKS];
	str		brkRequest[MAXBREAKS];
	int		brkTop;
} mdbStateRecord, *mdbState;

typedef struct MDBSTATE{
	MalBlkPtr mb;
	MalStkPtr stk;
	InstrPtr p;
	int pc;
} MdbState;

mal_export void mdbSetBreakpoint(Client cntxt, MalBlkPtr mb, int pc, char cmd);
mal_export void mdbClrBreakRequest(Client cntxt, str name);
mal_export void mdbShowBreakpoints(Client cntxt);
mal_export void mdbCommand(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p, int pc);
mal_export int mdbSession(void);
mal_export void mdbStep(Client cntxt, MalBlkPtr mb, MalStkPtr stk, int pc);
mal_export void mdbHelp(stream *f);
mal_export void printStackElm(stream *f, MalBlkPtr mb, VarPtr n, ValPtr v, int index, size_t cnt, int first, int lifespan);
mal_export void printBATelm(stream *f, int i, size_t cnt, size_t first);
mal_export void printStack(stream *f, MalBlkPtr mb, MalStkPtr s, int lifespan);
mal_export void printBatInfo(stream *f, VarPtr n, ValPtr v);
mal_export void printBatProperties(stream *f, VarPtr n, ValPtr v, str props);
mal_export void printTraceCall(stream *out, MalBlkPtr mb, MalStkPtr stk, int pc, int flags);
mal_export str call2str(MalBlkPtr mb, MalStkPtr stk, int pc, int flags);

mal_export str runMALDebugger(Symbol s);
mal_export void printBBPinfo(stream *out);

mal_export void optimizerDebug(MalBlkPtr mb, str name, int actions, lng usec);
mal_export str debugOptimizers(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
#endif /* _MAL_DEBUGGER_h */
@+ Debugger framework
Before the interpreter is allowed to proceed we give control
to the user to alter the trace/debugger options.
@c
#include "mal_config.h"
#include "mal_readline.h"
#include "mal_debugger.h"
#include "mal_atom.h"		/* for showAtoms() */
#include "mal_interpreter.h"	/* for getArgReference() */
#include "mal_linker.h"		/* for getAddress() */
#include "mal_module.h"		/* for showModuleStatistics() */
#include "mal_parser.h"
#include "mal_namespace.h"


int MDBdelay;			/* do not immediately react */

#define skipBlanc(c,X)    while(*(X) && isspace((int)*X)){ X++; }
#define skipNonBlanc(c,X) while(*(X) && !isspace((int) *X)){ X++; }
#define skipWord(c,X) 	  while(*(X) && isalnum((int) *X)){X++;} skipBlanc(c,X);
@-
Each client has its own breakpoint administration, kept in a global table.
Although a little space consumptive, it is the easiest to maintain
and much less expensive as reserving debugger space in each instruction.
@c
mdbStateRecord mdbTable[MAL_MAXCLIENTS];

char
isBreakpoint(Client cntxt, MalBlkPtr mb, InstrPtr p, int pc)
{
	int i, j;

	for (i = 0; i < mdbTable[cntxt->idx].brkTop; i++) {
		if( mdbTable[cntxt->idx].brkBlock[i] != mb) 
			continue;
		if( mdbTable[cntxt->idx].brkPc[i] == pc )
			return mdbTable[cntxt->idx].brkCmd[i];

		if( mdbTable[cntxt->idx].brkMod[i] && getModuleId(p) &&
		    mdbTable[cntxt->idx].brkFcn[i] && getFunctionId(p) &&
			strcmp(mdbTable[cntxt->idx].brkMod[i], getModuleId(p))==0 &&
			strcmp(mdbTable[cntxt->idx].brkFcn[i], getFunctionId(p))==0)
			return mdbTable[cntxt->idx].brkCmd[i];

		if( mdbTable[cntxt->idx].brkVar[i] >= 0 )
		for (j = 0; j < p->retc; j++)
			if (mdbTable[cntxt->idx].brkVar[i] == getArg(p,j))
				return mdbTable[cntxt->idx].brkCmd[i];
	}
	return 0;
}

@-
Break points can be set on assignment to a specific variable,
specific operation, or a instruction line
@c
void
mdbSetBreakRequest(Client cntxt, MalBlkPtr mb, str request, char cmd)
{
	int i;
	str modnme, fcnnme;
	mdbState mdb = mdbTable + cntxt->idx;
	Symbol sym;

	/* set breakpoint on specific line */
	if( *request == '#' ){
		i= atoi(request+1);
		if( i<0 || i>= mb->stop)
			stream_printf(cntxt->fdout, "breakpoint on #%d (<%d) not set\n", 
				i, mb->stop);
		else  {
			mdb->brkBlock[mdb->brkTop] = mb;
			mdb->brkPc[mdb->brkTop] = i;
			mdb->brkVar[mdb->brkTop] = -1;
			mdb->brkMod[mdb->brkTop] = 0;
			mdb->brkFcn[mdb->brkTop] = 0;
			mdb->brkRequest[mdb->brkTop] = GDKstrdup(request);
			mdb->brkCmd[mdb->brkTop] = cmd;
			if (mdb->brkTop + 1 < MAXBREAKS)
				mdb->brkTop++;
		}
		return;
	}

	/* check for a [module.]function request */
	fcnnme= strchr(request,'.');
	if( fcnnme){
		modnme= request;
		*fcnnme= 0;
		fcnnme++;
		sym= findSymbolInModule(
				findModule(cntxt->nspace,getName(modnme,strlen(modnme))),
				fcnnme);
		mdb->brkBlock[mdb->brkTop] = sym? sym->def: mb;
		mdb->brkPc[mdb->brkTop] = -1;
		mdb->brkVar[mdb->brkTop] = -1;
		mdb->brkMod[mdb->brkTop] = putName(modnme,strlen(modnme));
		mdb->brkFcn[mdb->brkTop] = putName(fcnnme,strlen(fcnnme));
		fcnnme--; *fcnnme= '.';
		mdb->brkRequest[mdb->brkTop] = GDKstrdup(request);
		mdb->brkCmd[mdb->brkTop] = cmd;
		if (mdb->brkTop + 1 < MAXBREAKS)
			mdb->brkTop++;
		return;
	} 
	/* the final step is to break on a variable */
	i= findVariable(mb,request);
	if( i< 0)
		stream_printf(cntxt->fdout, "breakpoint on %s not set\n", request);
	else {
		mdb->brkBlock[mdb->brkTop] = mb;
		mdb->brkPc[mdb->brkTop] = -1;
		mdb->brkVar[mdb->brkTop] = i;
		mdb->brkMod[mdb->brkTop] = 0;
		mdb->brkFcn[mdb->brkTop] = 0;
		mdb->brkRequest[mdb->brkTop] = GDKstrdup(request);
		mdb->brkCmd[mdb->brkTop] = cmd;
		if (mdb->brkTop + 1 < MAXBREAKS)
			mdb->brkTop++;
	}
}

@-
A breakpoint should be set once for each combination
@c
void
mdbSetBreakpoint(Client cntxt, MalBlkPtr mb, int pc, char cmd)
{
	mdbState mdb = mdbTable + cntxt->idx;
	char buf[20];

	snprintf(buf,20,"#%d",pc);
	mdb->brkBlock[mdb->brkTop] = mb;
	mdb->brkPc[mdb->brkTop] = pc;
	mdb->brkVar[mdb->brkTop] = -1;
	mdb->brkMod[mdb->brkTop] = 0;
	mdb->brkFcn[mdb->brkTop] = 0;
	mdb->brkRequest[mdb->brkTop] = GDKstrdup(buf);
	mdb->brkCmd[mdb->brkTop] = cmd;
	if (mdb->brkTop + 1 < MAXBREAKS)
		mdb->brkTop++;
}

void
mdbShowBreakpoints(Client cntxt)
{
	int i;
	mdbState mdb = mdbTable + cntxt->idx;

	for (i = 0; i < mdb->brkTop; i++)
		stream_printf(cntxt->fdout, "breakpoint on '%s'\n", mdb->brkRequest[i]);
}

void
mdbClrBreakpoint(Client cntxt, int pc)
{
	int i, j = 0;
	mdbState mdb = mdbTable + cntxt->idx;

	for (i = 0; i < mdb->brkTop; i++) {
		mdb->brkBlock[j] = mdb->brkBlock[i];
		mdb->brkPc[j] = mdb->brkPc[i];
		mdb->brkVar[j] = mdb->brkVar[i];
		mdb->brkMod[j] = mdb->brkMod[i];
		mdb->brkFcn[j] = mdb->brkFcn[i];
		mdb->brkRequest[j] = mdb->brkRequest[i];
		mdb->brkCmd[j] = mdb->brkCmd[i];
		if (mdb->brkPc[i] != pc)
			j++;
		else {
			GDKfree(mdb->brkRequest[i]);
			mdb->brkRequest[i] = 0;
		}

	}
	mdb->brkTop = j;
}

void
mdbClrBreakRequest(Client cntxt, str request)
{
	int i, j = 0;
	mdbState mdb = mdbTable + cntxt->idx;

	for (i=0; i < mdb->brkTop; i++) {
		mdb->brkBlock[j] = mdb->brkBlock[i];
		mdb->brkPc[j] = mdb->brkPc[i];
		mdb->brkVar[j] = mdb->brkVar[i];
		mdb->brkMod[j] = mdb->brkMod[i];
		mdb->brkFcn[j] = mdb->brkFcn[i];
		mdb->brkRequest[j] = mdb->brkRequest[i];
		mdb->brkCmd[j] = mdb->brkCmd[i];
		if (strcmp(mdb->brkRequest[i], request))
			j++;
		else {
			GDKfree(mdb->brkRequest[i]);
			mdb->brkRequest[i] = 0;
		}
	}
	mdb->brkTop = j;
}

@-
The instruction call stack is the most common command.
Prepare a string for an instruction call. 
We rely on the buffersize of instruction2str.
@c
str
call2str(MalBlkPtr mb, MalStkPtr stk, int pc, int flags)
{
	int k,len;
	str msg,w;
	str s;
	InstrPtr p;

	p= getInstrPtr(mb,pc);
	msg = instruction2str(mb, p, FALSE);
	s = strchr(msg, '(');
	if (p->retc > 1 && s) {
		s = strchr(s + 1, '(');
	}
	if (s) {
		s++;
		*s = 0;
		len = strlen(msg);
		for (k = p->retc; k < p->argc; k++) {
			VarPtr v = getVar(mb, getArg(p, k));
			ValPtr val = &stk->stk[getArg(p, k)];

			if (v->tmpindex == 0)
				sprintf(msg+len, "%s=", v->name);
			else
				sprintf(msg+len, "%c%d=", TMPMARKER, v->tmpindex);
			w = 0;
			ATOMformat(val->vtype, VALptr(val), &w);
			strcat(msg,w);
			if( ATOMcmp(val->vtype, ATOMnilptr(val->vtype), VALptr(val))==0){
				str tpe= getTypeName(v->type);
				strcat(msg,":");
				strcat(msg,tpe);
				GDKfree(tpe);
			}
			/* in performance monitoring mode we show more details */
			if( (flags || malProfileMode) && isaBatType(v->type)){
				str tpe= getTypeName(v->type);
				BAT *b;
				strcat(msg,tpe);
				b= BATdescriptor(val->val.ival);
				if( b){
					len= strlen(msg);
					sprintf(msg+len,"{%d}",(int)BATcount(b));
					BBPunfix(b->batCacheid);
				}
				GDKfree(tpe);
			}
			GDKfree(w);
			if (k < p->argc - 1)
				strcat(msg,", ");
			len= strlen(msg);
		}
		strcat(msg,")");
	} 
	return msg;
}

void
printCall(Client cntxt, MalBlkPtr mb, MalStkPtr stk, int pc)
{
	str msg;
	msg = call2str(mb, stk, pc, cntxt->flags);
	stream_printf(cntxt->fdout, "%s at %s.%s[%d]\n", msg, 
		getModuleId(getInstrPtr(mb,0)),
		getFunctionId(getInstrPtr(mb,0)),pc);
	GDKfree(msg);
}

@-
Beware, the printTraceCall is a rather expensive routine and obscures
the actual timing. We therefore compensate the global timing maintained
@c
void
printTraceCall(stream *out, MalBlkPtr mb, MalStkPtr stk, int pc, int flags)
{
	str msg;
	msg= call2str(mb,stk,pc,flags);
	stream_printf(out, "%s\n", msg);
	GDKfree(msg);
}

@+ MAL parser
The debugger structure is inherited from GDB.
The routine mdbCommand is called with p=0 after finishing a mal- function call
and before continuing at the next level of invocation.
The commands are self-explanatory.

The prompt string sent to the user indicates the debugger mode.
@c
#define MDBstatus(X) if(cntxt->fdout) \
	stream_printf(cntxt->fdout,"#MonetDB Debugger %s\n", (X?"on":"off"));

static MalBlkPtr
mdbLocateMalBlk(MalBlkPtr mb, str b, stream *out){
	MalBlkPtr m=mb;
	char *h=0;
	int idx=0;

	if( *b == '['){
		idx= atoi(b+1);
		return getMalBlkHistory(mb,idx);
	} else
	if( isdigit((int) *b)){
		return getMalBlkHistory(mb,atoi(b));
	} else
	if (*b != 0) {
		char *fcnname = strchr(b, '.');
		Symbol fsym;
		if (fcnname == NULL ) {
			stream_printf(out, "<mod>.<fcn>[<nr>] expected\n", b);
			return NULL;
		}
		*fcnname = 0;
		fcnname++;
		if( (h= strchr(fcnname,'[')) ){
			*h=0; idx= atoi(h+1);
		} 
		fsym= findSymbolInModule(
			findModule(MCgetClient()->nspace, getName(b,strlen(b))),
			fcnname);
		if (fsym == 0) {
			stream_printf(out, "'%s.%s' not found\n", b,fcnname);
			return NULL;
		}
		m= fsym->def;
	} 
	if( m->history== NULL){
		stream_printf(out,"No history available\n");
		return NULL;
	} 
	return m;
}

void
mdbCommand(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p, int pc)
{
	int m = 1;
	char *b, *c;
	stream *out = cntxt->fdout;
	/* int listing = cntxt->listing;*/
	char *oldprompt = cntxt->prompt;
	int oldpromptlength = cntxt->promptlength;

	if (p != NULL) {
		if (cntxt != mal_clients) 
			/* help MapiClients with fake prompt */
			stream_printf(out,"mdb>");
		printTraceCall(out,mb,stk,pc,cntxt->flags);
	}
	if (cntxt == mal_clients) {
		cntxt->prompt = "mdb>";
		cntxt->promptlength = 4;
	}
	do {
		int r;

		if (cntxt->phase[MAL_SCENARIO_READER]) {
			b= (char*) (*cntxt->phase[MAL_SCENARIO_READER]) (cntxt);
			if( b != 0)
				break;
		} else {
			/* switch to mdb streams */
			r= readConsole(cntxt);
			if( r <= 0)
				break;
		}
		b = CURRENT(cntxt);

		/* terminate the line with zero */
		c = strchr(b, '\n');
		if (c) {
			*c = 0;
			cntxt->fdin->pos += (c - b) + 1;
		} else {
			cntxt->fdin->pos = cntxt->fdin->len;
		}

		skipBlanc(cntxt, b);
		switch (*b) {
		case 0:
			m = 0;
			break;
		case 'a':
			if (strncmp("atom", b, 1) == 0)
				showAtoms(out);
			break;
		case 'c':
			if (strncmp("catch", b, 3) == 0) {
				/* catch the next exception */
				stk->cmd = 'C';
				break;
			}
			if (strncmp("call", b, 3) == 0) {
				showException(MAL,"mdb.command", "call instruction not yet implemented");
				break;
			}
			stk->cmd = 'c';
			skipWord(cntxt, b);
			m = 0;
			break;
		case 'e':
		{
			/* terminate the execution for ordinary functions only */
			if (strncmp("exit", b, 4) == 0) {
		case 'x':
				if (!(getInstrPtr(mb, 0)->token == FACcall)) {
					stk->cmd = 'x';
					cntxt->prompt = oldprompt;
					cntxt->promptlength = oldpromptlength;
				}
			}
			return;
		}
		case 'q':
		{
			MalStkPtr su;

			/* return from this debugger */
			for (su = stk; su; su = su->up)
				su->cmd = 0;
			cntxt->itrace = 0;
			cntxt->flags = 0;
			/* MDBstatus(0); */
			cntxt->prompt = oldprompt;
			cntxt->promptlength = oldpromptlength;
			return;
		}
		case 'f':	/* finish */
		case 'n':	/* next */
		case 's':	/* step */
			if (strncmp("scenarios", b, 9) == 0) {
				showAllScenarios(out);
				continue;
			} else if (strncmp("scenario", b, 3) == 0) {
				showScenarioByName(out, cntxt->scenario);
				continue;
			} else if (strncmp("scope", b, 3) == 0) {
				/* used to inspect the identifier distribution */
				showModuleStatistics(out, cntxt->nspace);
				continue;
			} else if (strncmp("set", b, 3) == 0) {
				skipWord(cntxt, b);
				skipBlanc(cntxt, b);
				if( strncmp("flow",b,1) == 0)
					cntxt->flags |= flowFlag;
				if( strncmp("memory",b,1) == 0){
					struct mallinfo memory;
					cntxt->flags |= memoryFlag;
					memory = MT_mallinfo();
					stream_printf(out,"arena %d ordblks %d smblks %d "
						" hblkhd %d hblks %d fsmblks %d uordblks %d\n",
						memory.arena,
						memory.ordblks,
						memory.smblks,
						memory.hblkhd,
						memory.hblks,
						memory.fsmblks,
						memory.uordblks
					);
				}
				if (strncmp("timer", b, 1) == 0) {
					cntxt->flags |= timerFlag;
					cntxt->timer = GDKusec();
					stk->cmd = 0;
				}
				if (strncmp("io", b, 1) == 0) {
#ifdef HAVE_SYS_RESOURCE_H
					struct  rusage resource;        
#endif
					cntxt->flags |=ioFlag ;
#ifdef HAVE_SYS_RESOURCE_H
					getrusage(RUSAGE_SELF, &resource);
					stream_printf(out, "#maxrss %d ixrss=%d idrss=%d isrss=%d" 
									" minflt=%d majflt=%d nswap=%d inblock=%d oublock=%d\n", 
									resource.ru_maxrss, resource.ru_ixrss, 
									resource.ru_idrss, resource.ru_isrss,
									resource.ru_minflt, resource.ru_majflt, 
									resource.ru_nswap, resource.ru_inblock, 
									resource.ru_oublock);
#endif
				}
				continue;
			}
			stk->cmd = *b;
			m = 0;
			break;
		case 'm':	/* display a module */
		{
			str modname, fcnname;
			Module fsym;
			Symbol fs;
			int i;

			skipWord(cntxt, b);
			skipBlanc(cntxt,b);
			if (*b) {
				modname = b;
				fcnname = strchr(b, '.');
				if (fcnname) {
					*fcnname = 0;
					fcnname++;
				}
				fsym = findModule(cntxt->nspace, putName(modname, strlen(modname)));

				if (fsym == cntxt->nspace && strcmp(modname,"user") ) {
					stream_printf(out, "module '%s' not found\n", modname);
					continue;
				}
				for (i = 0; i < MAXSCOPE; i++) {
					fs = fsym->subscope[i];
					while (fs != NULL) {
						if (fcnname == NULL)
							printSignature(out, fs, 0);
						else if (strcmp(fcnname, getFcnName(fs->def)) == 0)
							printSignature(out, fs, 0);
						fs = fs->peer;
					}
				}
				continue;
			} else
				showModules(out, cntxt->nspace);
		}
			break;
		case 'T':	/* debug type resolver for a function call */
			if (strncmp("Trace", b, 5) == 0) {
				char *w;
				skipWord(cntxt, b);
				skipBlanc(cntxt, b);
				if ( (w =strchr(b, '\n')) )
					*w = 0;
				traceFcnName = GDKstrdup(b);
			}
			break;
		case 't':	/* trace a variable toggle */
			if (strncmp("trace", b, 5) == 0) {
				char *w;
				skipWord(cntxt, b);
				skipBlanc(cntxt, b);
				if ( (w= strchr(b, '\n')) )
					*w = 0;
				mdbSetBreakRequest(cntxt, mb, b, 't');
			} 
			break;
		case 'v':	/* show the symbol table and bindings */
		case 'V':{
			str modname, fcnname;
			Module fsym;
			Symbol fs;
			int i, lifespan = *b== 'V';

			skipWord(cntxt, b);
			if (*b != 0) {
				modname = b;
				fcnname = strchr(b, '.');
				if (fcnname == NULL) {
					fsym = findModule(cntxt->nspace, putName(modname, strlen(modname)));
					if (fsym == 0) {
						stream_printf(out, "%s module not found\n", modname);
						continue;
					}
					for (i = 0; i < MAXSCOPE; i++) {
						fs = fsym->subscope[i];
						while (fs != NULL) {
							printStack(out, fs->def, 0, lifespan);
							fs = fs->peer;
						}
					}
					continue;
				}
				*fcnname = 0;
				fcnname++;
				fsym = findModule(cntxt->nspace, putName(modname, strlen(modname)));
				if (fsym == 0) {
					stream_printf(out, "%s module not found\n", modname);
					continue;
				}
				/* display the overloaded symbol definition */
				for (i = 0; i < MAXSCOPE; i++) {
					fs = fsym->subscope[i];
					while (fs != NULL) {
						if (strcmp(fs->name, fcnname) == 0)
							printStack(out, fs->def, 0,lifespan);
						fs = fs->peer;
					}
				}
			} else
				printStack(out, mb, stk,lifespan);
			break;
		}
		case 'b':
			if (strncmp(b, "bbp",3) == 0) {
				int i,limit;

				skipWord(cntxt, b);
				i = BBPindex(b);
				if( i)
					limit=i+1;
				else {
					limit= BBPsize;
					i=1;
				}
				/* the 'dense' qualification only shows entries with a hard ref */
				for (; i < limit; i++)
					if (BBP_logical(i) && BBP_cache(i) ) {
						if( *b=='d' && BBP_refs(i)==0) continue;
						stream_printf(out, "[%d] %s lref = %d ref= %d ", 
							i, BBP_logical(i), BBP_lrefs(i), BBP_refs(i));
						stream_printf(out, " dirty=%d", BATdirty(BBP_cache(i)));
						if( *BBP_logical(i) =='.')
							stream_printf(out, " zombie ");
						if( BBPstatus(i) & BBPLOADED)
							stream_printf(out, " loaded ");
						if( BBPstatus(i) & BBPSWAPPED)
							stream_printf(out, " swapped ");
						if( BBPstatus(i) & BBPTMP)
							stream_printf(out, " tmp ");
						if( BBPstatus(i) & BBPDELETED)
							stream_printf(out, " deleted ");
						if( BBPstatus(i) & BBPEXISTING)
							stream_printf(out, " existing ");
						if( BBPstatus(i) & BBPNEW)
							stream_printf(out, " new ");
						if( BBPstatus(i) & BBPPERSISTENT)
							stream_printf(out, " persistent ");
						stream_printf(out, "\n");
					}
				continue;
			}
			if (strncmp(b, "breakpoints",11) == 0) {
				mdbShowBreakpoints(cntxt);
				continue;
			}
			if (strncmp(b, "break", 5) == 0)
				b += 4;
			if (isspace((int) b[1])) {
				skipWord(cntxt, b);
				if (*b && !isspace((int) *b))
					/* set breakpoints by name */
					mdbSetBreakRequest(cntxt, mb, b, 's');
				else
					/* set breakpoint at current instruction */
					mdbSetBreakpoint(cntxt, mb, pc, 's');
				continue;
			}
			continue;
		case 'd':
			if( strncmp(b, "debug", 5) == 0){
				skipWord(cntxt, b);
				GDKdebug = atol(b);
				stream_printf(out,"Set debug mask to %d\n",GDKdebug);
				break;
			}
			if (strncmp(b, "down", 2) == 0 && stk->down != NULL) {
				stream_printf(out, "%sgo down the stack\n", "#mdb ");
				stk = stk->down;
				mb = stk->blk;
				break;
			}
			if( strncmp(b, "dot", 3) == 0){
				/* produce the dot file for graphical display */
				/* its argument is the optimizer level followed by filename*/
				MalBlkPtr mdot;
				char fname[2*PATHLENGTH]="";
				char name[PATHLENGTH];

				skipWord(cntxt, b);
				skipBlanc(cntxt, b);
				mdot= mdbLocateMalBlk(mb,b,out);
				if( mdot == NULL)
					mdot= mb;
				/* optional file */
				snprintf(name,PATHLENGTH,"/%s-%s.dot",
					getModuleId(getInstrPtr(mdot,0)),
					getFunctionId(getInstrPtr(mdot,0)));
				if( *b == 0){
					strcat(fname,name+1);
				} else
				if( cntxt->cwd && *b !='/'){
					strcpy(fname,cntxt->cwd);
					strcat(fname,name);
				} else 
					strcat(fname,name+1);
				stream_printf(out,"#dot to %s\n",fname);
				showFlowGraph(mdot,0,fname);
				break;
			}
			skipWord(cntxt, b);
			/* get rid of break point */
			if (*b && !isspace((int) *b)) {
				mdbClrBreakRequest(cntxt, b);
			} else {
				mdbClrBreakpoint(cntxt, pc);
			}
			continue;
		case 'I':
		case 'i':
		{
			int i;
			char *t;

			/* the user wants information about variables */
			if( *b == 'I'){
				skipWord(cntxt, b);
				for(i=0; i< mb->vtop; i++)
					printBatProperties(out, getVar(mb, i), stk->stk + i, b);
				continue;
			}
			skipWord(cntxt, b);
			t = b;
			skipNonBlanc(cntxt, t);
			*t = 0;
			/* search the symbol */
			i = findVariable(mb, b);
			if (i < 0) {
				stream_printf(out, "%s Symbol not found\n", "#mdb ");
			} else {
				printBatInfo(out, getVar(mb, i), stk->stk + i);
			}
			continue;
		}
		case 'P':
		case 'p':
		{
			size_t size = 0, first = 0;
			int i;
			char *t;
			char upper= *b;

			skipWord(cntxt, b);
			t = b;
			skipNonBlanc(cntxt, t);
			*t = 0;
			/* you can identify a start and length */
			t++;
			skipBlanc(cntxt, t);
			if (isdigit((int) *t)) {
				size = atol(t);
				skipWord(cntxt, t);
				if (isdigit((int) *t))
					first = atol(t);
			}
			if( upper == 'P'){
				for( i= 0; i<mb->vtop; i++)
				if (isaBatType(getVarType(mb,i)) )
					printBATelm(out, i, size, first);
				continue;
			}
			/* search the symbol */
			i = findVariable(mb, b);
			if (i < 0) {
				i = BBPindex(b);
				if (i != 0)
					printBATelm(out, i, size, first);
				else
					stream_printf(out, "%s Symbol not found\n", "#mdb ");
				continue;
			}
			printStackElm(out, mb, getVar(mb, i), stk->stk + i, i, size, first,0);
			continue;
		}
		case 'S':
			dumpNamespaceStatistics(out, 1);
			break;
		case 'u':
			if( strncmp("unset",b,5)){
				skipWord(cntxt, b);
				skipBlanc(cntxt, b);
				if( strncmp("flow",b,1) == 0)
					cntxt->flags &= ~flowFlag;
				if( strncmp("memory",b,1) == 0)
					cntxt->flags &= ~memoryFlag;
				if (strncmp("timer", b, 1) == 0)
					cntxt->flags &= ~timerFlag;
				if (strncmp("io", b, 1) == 0) 
					cntxt->flags &= ~ioFlag;
				continue;
			}
			if (stk->up == NULL)
				break;
			stream_printf(out, "%s go up the stack\n", "#mdb ");
			stk = stk->up;
			mb = stk->blk;
			printCall(cntxt, mb, stk, pc);
			continue;
		case 'w':
		{
			MalStkPtr w;
			MalBlkPtr mw = mb;
			int pci = pc;	/*  how to find enclosing pc */

			for (w = stk; w != NULL; w = w->up) {
				mw = w->blk;
				printCall(cntxt, mw, w, pci);
				if (w->up)
					pci = w->up->pcup;
			}
			continue;
		}
@-
While debugging it should be possible to inspect the symbol
table using the 'module.function' name. The default is to list all
signatures satisfying the pattern.
@c
		case 'L':
		case 'l':	/* list the current MAL block or module */
		{
			Module fsym;
			Symbol fs;
			int i, lstng;

			lstng= (*b == 'L' ? LIST_MAL_ALL : LIST_MAL_INSTR | LIST_MAL_PROPS);
			skipWord(cntxt, b);
			if (*b != 0) {
				MalBlkPtr m= mdbLocateMalBlk(mb,b,out);
				if( m == NULL && !strchr(b,'.') && 
					!strchr(b,'[') && !isdigit((int)*b)){
					/* optionally dump the complete module */
					fsym = findModule(cntxt->nspace, putName(b, strlen(b)));
					if (fsym == 0) {
						stream_printf(out, "'%s' not found\n", b);
						continue;
					}
					for (i = 0; i < MAXSCOPE; i++) {
						fs = fsym->subscope[i];
						while (fs != NULL) {
							printFunction(out, fs->def, lstng);
							fs = fs->peer;
						}
					}
					continue;
				}
				if( m) 
					printFunction(out, m, lstng);
			} else 
				printFunction(out, mb, lstng);
			continue;
		}
		case 'h':
			if (strncmp("help", b, 2) == 0) 
				mdbHelp(out);
			/* assume history */
		case 'o':
		case 'O':	/* optimizer and scheduler steps */
		{
			MalBlkPtr mdot=mb;
			skipWord(cntxt, b);
			skipBlanc(cntxt, b);
			if (*b) {
				mdot=mdbLocateMalBlk(mb,b,out);
				if(mdot != NULL)
					showMalBlkHistory(mdot);
			} else
				showMalBlkHistory(mb);
			break;
		}
		case 'r':	/* reset program counter */
			stream_printf(out, "%s restart with current stack\n", "#mdb ");
			stk->cmd = 'r';
			break;
		default:
			stream_printf(out, "%s debugger command expected\n", "#mdb ");
			mdbHelp(out);
		}
	} while (m);
	cntxt->prompt = oldprompt;
	cntxt->promptlength = oldpromptlength;
}

static int mdbSessionActive;
int mdbSession(){
	return mdbSessionActive;
}
@-
It may be relevant to trap against dangerous situations, such
as underlying types not being aligned with what is expected
at the MAL level. Since such tests can be quite expensive
it should be used with care.
@c
void
mdbSanityCheck(Client cntxt, MalBlkPtr mb, MalStkPtr stk, int pc)
{
	int i;
	VarPtr n;
	ValPtr v;
	str nme,nmeOnStk;

	(void) stk;
	(void) pc;
	(void) mb;
	for (i=1; i < mb->vtop; i++){
		n= getVar(mb,i);
		v= stk->stk+i;
		if (isaBatType(n->type) && v->val.ival) {
			BAT *b;

			b = BATdescriptor(v->val.ival);
			if (b) {
				nme = getTypeName(n->type);
				nmeOnStk = getTypeName(newBatType(b->htype, b->ttype));
				if (strcmp(nme, nmeOnStk)) {
					printTraceCall(cntxt->fdout,mb,stk,pc,cntxt->flags);
					stream_printf(cntxt->fdout, "!ERROR: %s != :%s\n",
						nme, nmeOnStk);
					stk->cmd='n';
				}
				BBPunfix(b->batCacheid);
				GDKfree(nme);
			}
		}
	}
}

void
mdbStep(Client cntxt, MalBlkPtr mb, MalStkPtr stk, int pc)
{
	InstrPtr p;
	char ch;

	mdbSessionActive= 1; /* for name completion */
	/* mdbSanityCheck(cntxt, mb, stk, pc); expensive */
	/* process should sleep */
	if( cntxt->itrace == 'S'){
		MdbState state;
		state.mb= mb;
		state.stk= stk;
		state.p = getInstrPtr(mb,pc);
		state.pc= pc;
		cntxt->mdb= &state;
		fprintf(stderr,"#Process put to sleep\n");
		cntxt->itrace= 'W';
		while(cntxt->itrace== 'W')
			MT_sleep_ms(cntxt->delay);
		fprintf(stderr,"#Process woke up\n");
		return;
	}

	switch (stk->cmd) {
	case 'c':
		p = getInstrPtr(mb, pc);
		ch= isBreakpoint(cntxt,mb, p, pc);
		if( ch == 't'){
			if (cntxt != mal_clients) 
				/* help MapiClients with fake prompt */
				stream_printf(cntxt->fdout,"mdb>");
			printTraceCall(cntxt->fdout,mb,stk,pc,cntxt->flags);
		} else if( ch )
			mdbCommand(cntxt, mb, stk, p, pc);
		break;
	case 's':
	case 'n':
		p = getInstrPtr(mb, pc);
		mdbCommand(cntxt, mb, stk, p, pc);
		break;
	case 'C':
		mdbSessionActive= 0; /* for name completion */
	}
	if( mb->errors) {
		MalStkPtr su;

		/* return from this debugger */
		for (su = stk; su; su = su->up)
			su->cmd = 0;
		stk->cmd = 'x';	/* will force a graceful termination */
	}
	if( mdbSessionActive== 0) return;
	showErrors();
	if (cntxt->flags & timerFlag)
		cntxt->timer = GDKusec();
	mdbSessionActive= 0; /* for name completion */
}

@-
It would come in handy if at any time you could activate
the debugger on a specific function. This calls for the
creation of a minimal execution environment first.
@c
str
runMALDebugger(Symbol s)
{
	Client c = MCgetClient();

	c->itrace = 'n';
	runMAL(c, s->def, 1, 0, 0, 0);
	return MAL_SUCCEED;
}

@+ Utilities
Dumping a stack on a file is primarilly used for debugging.
Printing the stack requires access to both the symbol table and
the stackframes in most cases.
Beware that a stack frame need not be initialized with null values.
It has been zeroed upon creation.

The routine  can also be used to inspect the symbol table of
arbitrary functions.
@c
void
printStack(stream *f, MalBlkPtr mb, MalStkPtr s,int lifespan)
{
	int i = 0;

	if (s) {
		stream_printf(f, "#Stack '%s' size=%d top=%d\n",
				getInstrPtr(mb, 0)->fcnname, s->stksize, s->stktop);
		for (; i < mb->vtop; i++)
			printStackElm(f, mb, getVar(mb, i), s->stk + i, i, 0, 0,lifespan);
	} else
		for (; i < mb->vtop; i++)
			printStackElm(f, mb, getVar(mb, i), 0, i, 0, 0,lifespan);
}

void
printBATelm(stream *f, int i, size_t cnt, size_t first)
{
	BAT *b, *bs;
	str tpe ,nme;

	b = BATdescriptor(i);
	if (b) {
		nme= BATgetId(b); 
		tpe = getTypeName(newBatType(b->htype, b->ttype));
		/* ignore ref count of this call */
		stream_printf(f, "[%d] %s %s count=%d lrefs=%d refs=%d \n", 
				i, nme, tpe, 
				BATcount(b), BBP_lrefs(ABS(b->batCacheid)), 
				BBP_refs(ABS(b->batCacheid)) - 1);
		/* perform property checking */
		if( b->H != b->T)
			BATpropcheck(BATmirror(b),BATPROPS_QUICK);
		BATpropcheck(b,BATPROPS_QUICK);
		if( cnt){
			if (cnt < BATcount(b)) {
				stream_printf(f, "Sample %d out of %d\n", cnt, BATcount(b));
			}
			/* cut out a portion of the BAT for display */
			bs = BATslice(b, first, first + cnt);

			if (bs == NULL)
				stream_printf(f, "Failed to take chunk\n");
			else
				BATmultiprintf(f, 2, &bs, TRUE, 0, TRUE);
			BBPunfix(bs->batCacheid);
		}

		BBPunfix(b->batCacheid);
		GDKfree(tpe);
	}
}

void
printStackElm(stream *f, MalBlkPtr mb, VarPtr n, ValPtr v, int index, size_t cnt, int first, int lifespan)
{
	str nme, nmeOnStk;
	char nmebuf[PATHLENGTH];

	(void) mb;		/* fool the compiler */
	if (n->tmpindex) {
		snprintf(nmebuf, PATHLENGTH, "%c%d", TMPMARKER, n->tmpindex);
		nme = nmebuf;
	} else
		nme = n->name;
	if( lifespan) {
		stream_printf(f, "#[%d,%d:%d,%d](%d)  ", index, 
			getBeginLifespan(mb,index),
			getEndLifespan(mb,index),
			getLastUpdate(mb,index),
			getScope(mb,index));
		if( isVarGarbage(mb,index) )
			stream_printf(f,"G ");
		stream_printf(f, " %s\t= ", nme);
	} else stream_printf(f, "#[%d] %s\t= ", index, nme);
	/* if (n->type == TYPE_void)
		stream_printf(f, "nil");
	else */ if (v)
		ATOMprint(v->vtype, VALptr(v), f);

	nme = getTypeName(n->type);
	stream_printf(f, ":%s", nme);
	if( lifespan && n->isudftype)
		stream_printf(f," udftype");
	nmeOnStk = v ? getTypeName(v->vtype) : GDKstrdup(nme);
	if (strcmp(nmeOnStk, nme)) {
		if (isaBatType(n->type)) {
			BAT *b;

			b = BATdescriptor(v->val.ival);
			if (b) {
				nmeOnStk = getTypeName(newBatType(b->htype, b->ttype));
				if (strcmp(nme, nmeOnStk))
					stream_printf(f, " != :%s", nmeOnStk);
				BBPunfix(b->batCacheid);
			}
		} else if (!(isaBatType(n->type) && strcmp(nmeOnStk, "BAT") == 0))
			stream_printf(f, " != %s", nmeOnStk);
	}
	stream_printf(f, " %s", (n->isaconstant ? " constant" : ""));
	stream_printf(f, " %s", (n->isused==0 ? " not used" : ""));
	stream_printf(f, " %s", (n->isatypevar ? " type variable" : ""));
	GDKfree(nme);
	GDKfree(nmeOnStk);

	if (cnt && isaBatType(n->type) && v && v->val.ival) {
		BAT *b, *bs;

		b = BATdescriptor(v->val.ival);
		if (b == NULL) {
			stream_printf(f, "Could not access descriptor\n");
			return;
		}
		stream_printf(f, "\n");
		if (cnt <= BATcount(b)) {
			stream_printf(f, "Sample %d out of %d\n", cnt, BATcount(b));
		}
		/* cut out a portion of the BAT for display */
		bs = BATslice(b, first, first + cnt);

		if (bs == NULL)
			stream_printf(f, "Failed to take chunk\n");
		else
			BATmultiprintf(f, 2, &bs, TRUE, 0, TRUE);
		BBPunfix(bs->batCacheid);

		BBPunfix(b->batCacheid);
	} else if (isaBatType(n->type) && v) {
		BAT *b;

		b = BATdescriptor(v->val.ival);
		if (b) {
			/* ignore ref count of this call */
			stream_printf(f, " count=%d lrefs=%d refs=%d", 
				BATcount(b), BBP_lrefs(ABS(b->batCacheid)), 
				BBP_refs(ABS(b->batCacheid)) - 1);
			BBPunfix(b->batCacheid);
		}
	} 
	if( n->props){
		nme= propertySet2str(n->props);
		stream_printf(f,"%s",nme);
		GDKfree(nme);
	}
	stream_printf(f, "\n");
}

void
printBatInfo(stream *f, VarPtr n, ValPtr v)
{
	if (isaBatType(n->type) && v->val.ival) {
		int bid;
		int ret;
		MALfcn fcn;

		fcn = getAddress("bat","bat","BKCinfo", 0);
		if (fcn) {
			BAT *b;

			bid = v->val.ival;
			stream_printf(f, "Show info for %d\n", bid);
			(*fcn) (&ret, &bid);
			b = BATdescriptor(ret);
			if (b == NULL) {
				stream_printf(f, "Could not access descriptor\n");
				return;
			}
			BATmultiprintf(f, 2, &b, TRUE, 0, TRUE);
			BBPunfix(b->batCacheid);
		}
	}
}

void
printBatProperties(stream *f, VarPtr n, ValPtr v, str props)
{
	if (isaBatType(n->type) && v->val.ival) {
		int bid;
		int ret;
		MALfcn fcn;
		BUN p;

		fcn = getAddress("bat","bat","BKCinfo", 0);
		if (fcn) {
			BAT *b;

			bid = v->val.ival;
			stream_printf(f, "BAT %d %s= ", bid,props);
			(*fcn) (&ret, &bid);
			b = BATdescriptor(ret);
			if (b == NULL) {
				stream_printf(f, "Could not access descriptor\n");
				return;
			}
			p= BUNfnd(b,props);
			if( p) {
				stream_printf(f," %s\n", (str) BUNtail(b,p));
			} else stream_printf(f," not found\n");
			BBPunfix(b->batCacheid);
		}
	}
}

@-
The memory positions for the BATs is useful information to
asses for memory fragmentation.
@= heapinfo
hp= b->@1;
if(hp && hp->base){
	stream_printf(GDKout,"\t@1=%d size=%d\n",hp->base, hp->size);}
@= hashinfo
h= b->@1;
if(h && h->mask){
	    stream_printf(GDKout,"\t@1=%d size=%d\n",h, sizeof(*h));
	    stream_printf(GDKout,"\t@1link=%d size=%d\n",h->link,
	            (h->mask+h->lim+1)*sizeof(int));
}
@-
The memProfileVector routine produces a character string to represent
the usage of memory by BAT information. The characters are interpreted
as follows:
.=unused, X=completely used, [0-9]=small elements within the granule
More then 9 elements makes it full.
@= setVector
	start= (((long)@1)-min)/granule;
	lim= (((long)@1)-min + @2)/granule;
	stream_printf(GDKout,"start %d lim %d\n",start,lim);

@c
str
memProfileVector(int cells)
{
	str v = GDKmalloc(cells + 1);
	int i;
#ifdef HAVE_SBRK
	long max = (long) sbrk(0);
	long min = 0;
	long granule = 0;
#endif

	if (cells <= 0) {
		showException(MAL,"memProfileVector", "positive argument expected");
		return GDKstrdup("");
	}
	v = GDKmalloc(cells + 1);
	if (v == 0)
		GDKfatal("memProfileVector:malloc failure\n");

	for (i = 0; i < cells; i++)
		v[i] = '.';
	v[i] = 0;

	for (i = 1; i < BBPsize; i++)
		if (BBP_status(i) & BBPLOADED) {
			BAT *b = BATdescriptor(i);
			Heap *hp;
			Hash *h;
#ifdef HAVE_SBRK
			long start, lim;
#endif

			stream_printf(GDKout, "\tdesc=%d size=%d\n", b, sizeof(*b));
			hp = b->batBuns;
			stream_printf(GDKout, "\tbuns=%d size=%d\n", hp->base, hp->size);
#ifdef HAVE_SBRK
			if (min == 0) {
				min = (long) b;
				max = min + GDKmem_heapsize();
				granule = (max - min) / cells;
				stream_printf(GDKout, "granule %dK\n", granule / 1024);
			}
			@:setVector(b, sizeof(*b))@
			@:setVector(hp->base, hp->size)@
#endif

			@:heapinfo(hheap)@
			@:heapinfo(theap)@
			@:hashinfo(hhash)@
			@:hashinfo(thash)@
			BBPunfix(b->batCacheid);
		}
	return v;
}

void
printBBPinfo(stream *out)
{
	str v;

	stream_printf(out, "#BBP memory layout\n");
	stream_printf(out, "#heap maximum =%d/M\n", GDKmem_heapsize() / (1024 * 1024));
	v = memProfileVector(32);
	stream_printf(out, "#%s\n", v);
	GDKfree(v);
#ifdef GDK_VM_KEEPHISTO
	stream_printf(out, "#BBP VM history available\n");
#else
	stream_printf(out, "#BBP VM history not available\n");
#endif
}

@-
Some utilities for the debugger
@c
void
mdbHelp(stream *f)
{
	stream_printf(f, "next             -- Advance to next statement\n");
	stream_printf(f, "continue         -- Continue program being debugged\n");
	stream_printf(f, "catch            -- Catch the next exception \n");
	stream_printf(f, "break [<var>]    -- set breakpoint on current instruction or <var>\n");
	stream_printf(f, "delete [<var>]   -- remove break/trace point <var>\n");
	stream_printf(f, "debug <int>      -- set kernel debugging mask\n");
	stream_printf(f, "dot [<int>] [<file>]  -- generate the dependency graph\n");
	stream_printf(f, "step             -- advance to next MAL instruction\n");
	stream_printf(f, "module           -- display a module signatures\n");
	stream_printf(f, "atom             -- show atom list\n");
	stream_printf(f, "finish           -- finish current call\n");
	stream_printf(f, "exit             -- terminate executionr\n");
	stream_printf(f, "quit             -- turn off debugging\n");
	stream_printf(f, "list <obj>       -- list current program block\n");
	stream_printf(f, "List <obj>       -- list with type information\n");
	stream_printf(f, "var  <obj>       -- print symbol table for module\n");
	stream_printf(f, "optimizer <obj>  -- display program after optimizer step\n");
	stream_printf(f, "print <var>      -- display value of a variable\n");
	stream_printf(f, "print <var> <cnt>[<first>] -- display BAT chunk\n");
	stream_printf(f, "info <var>       -- display bat variable properties\n");
	stream_printf(f, "run              -- restart current procedure\n");
	stream_printf(f, "where            -- print stack trace\n");
	stream_printf(f, "down             -- go down the stack\n");
	stream_printf(f, "up               -- go up the stack\n");
	stream_printf(f, "trace <var>      -- trace assignment to variables\n");
	stream_printf(f, "set {timer,flow,io,memory} -- set trace switches\n");
	stream_printf(f, "unset            -- turn off switches\n");
	stream_printf(f, "help             -- this message\n");
}

@+ Optimizer debugging
The modular approach to optimize a MAL program brings with it the
need to check individual steps. Two options come to mind. If in
debug mode we could stop after each optimizer action for inspection.
Alternatively, we keep a history of all MAL program versions for
aposteriori analysis.
The latter is implemented first.

A global stack is used for simplity, later we may have to
make it thread safe by assigning it to a client record.
@c
int isInvariant(MalBlkPtr mb, int pcf, int pcl, int varid);

str
debugOptimizers(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	Client cntxt = MCgetClient();

	(void) stk;

	cntxt->debugOptimizer = cntxt->debugOptimizer ? FALSE : TRUE;
	if (pci)
		removeInstruction(mb, pci);
	return MAL_SUCCEED;
}

@}
