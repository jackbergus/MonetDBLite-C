@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2006 CWI.
@' All Rights Reserved.

@a M.L. Kersten
@* The MAL Debugger

In practice it is hard to write a correct MAL program the
first time around. Instead, it is more often constructed by
trial-and-error. As long as there are syntax and semantic errors
the MAL compiler provides a sufficient handle to proceed. Once
it passes the compiler we have to resort to a debugger to
assess its behavior.

@menu
* Program Debugging ::
* Handling Breakpoints::
* Runtime Inspection::
@end menu
@node Program Debugging, Handling Breakpoints, The MAL Debugger, The MAL Debugger
@+ Program Debugging
To ease debugging and performance monitoring, the MAL interpreter
comes with a gdb-like debugger.
An illustrative session elicits the functionality offered.

@example
>function test(i:int):str;
>	io.print(i);
>	i:= i*2;
>	b:= bbp.new(:int,:int);
>	bat.insert(b,1,i);
>	io.print(b);
>	return test:= "ok";
>end test;
>user.test(1);
[ 1 ]
#-----------------#
# h     t         # name
# int   int       # type
#-----------------#
[ 1,      2       ]
@end example

The debugger can be entered at any time using the call mdb.start().
An overview of the available commands is readily available.
@example
>mdb.start();
#mdb !end main;
mdb>help
next       -- Advance to next statement
continue   -- Continue program being debugged
break      -- set breakpoint on current instruction
break <var>    -- break on assignment to <var>
delete <var>   -- remove break point <var>
debug <mask>   -- set the runtime debugging mask
step       -- advance to next MAL instruction
module     -- display the module signatures
finish     -- finish current call
flow		-- trace memory flow
io		-- trace io flow
exit       -- terminate current call
quit       -- turn off debugging
list <fcn> -- list current program block
List <fcn> -- list with type information
var  <fcn>  -- print symbol table for module
optimizer <idx>  -- display program after optimizer step
optimizer <file> <idx>  -- safe program after optimizer step on a file
print <var>    -- display value of a variable
print <var> <cnt>[<first>] -- display BAT chunk
info <var>     -- display bat variable properties
run        -- restart current procedure
where      -- print stack trace
down       -- go down the stack
up         -- go up the stack
timer      -- produce micro-second response time
memory     -- produce memory consumption data
io         -- produce page activity trace
help       -- this message
mdb>
@end example

We walk our way through a debugging session, highlighting the
effects of the debugger commands.
The call to mdb.start() has been encapsulated in a complete
MAL function, as shown by issuing the list command.
A more detailed listing shows the binding to the C-routine
and the result of type resolution.
@example
>mdb.start();
#end main;
mdb>l
function user.main():int;
	mdb.start();
end main;
mdb>L
function user.main():int;       # 0  (main:int)
	mdb.start();        # 1 MDBstart (_1:void)
end main;       # 2
@end example
The user module is the default place for function defined at
the console. The modules loaded can be shown typeing the
command 'modules' or 'module'(or 'm'  for short). 
The former merely enumerates the module names, the latter also shows 
the names of the function in each.
The function signatures become visible using the module and optionally
the function name.
@example
mdb>m alarm
#command alarm.alarm(secs:int,action:str):void address ALARMsetalarm;
#command alarm.ctime():str address ALARMctime;
#command alarm.epilogue():void address ALARMepilogue;
#command alarm.epoch():int address ALARMepoch;
#command alarm.prelude():void address ALARMprelude;
#command alarm.sleep(secs:int):void address ALARMsleep;
#command alarm.time():int address ALARMtime;
#command alarm.timers():bat[:str,:str] address ALARMtimers;
#command alarm.usec():lng address ALARMusec;
mdb>m alarm.sleep
#command alarm.sleep(secs:int):void address ALARMsleep;
mdb>
@end example
The debugger mode is left with a <return>.
Any subsequent MAL instruction re-activates the debugger to
await for commands. The default operation is to step through
the execution using the 'next' ('n') or 'step' ('s) commands,
as shown below.
@example
>user.test(1);
#    user.test(1);
mdb>n
#    io.print(i);
mdb>
[ 1 ]
#    i := calc.*(i,2);
mdb>
#    b := bbp.new(:int,:int);
mdb>
@end example
The last instruction show is ready to be executed, which means
the calculation has already been finished. The value assigned
to a variable can be
shown using a print statement, which contains the location of
the variable on the stack frame, its name, its value and type.
The complete stack frame becomes visible with 'values' ('v')
command:
@example
#    bat.insert(b,1,i);
mdb>
#    io.print(b);
mdb>v
#Stack for 'test' size=32 top=11
#[0] test        = nil:str
#[1] i   = 4:int
#[2] _2  = 0:int   unused
#[3] _3  = 2:int  constant
#[4] b   = <tmp_1226>:bat[:int,:int]   count=1 lrefs=1 refs=0
#[5] _5  = 0:int   type variable
#[6] _6  = nil:bat[:int,:int]   unused
#[7] _7  = 1:int  constant
#[8] _8  = 0:int   unused
#[9] _9  = "ok":str  constant
@end example
The variables marked 'unused' have been introduced as temporary variables,
but which are not referenced in the remainder of the program.
It also illustrates basic BAT properties, a complete description of which
can be obtained using the 'info' ('i') command.
A sample of the BAT content can be printed passing tuple indices, e.g.
'print b 10 10' prints the second batch of ten tuples.

@node Handling Breakpoints, Runtime Inspection, Program Debugging, The MAL Debugger
@+ Handling Breakpoints
A powerful mechanism for debugging a program is to set breakpoints
during the debugging session.
The breakpoints are designated by a target variable name,
a [module.]operator name, or a MAL line number (#<number>).
As soon as the variable recieves a new value  or the operation
is called the debugger is activated.

The snippet below illustrates the reaction to set a break point
on assignment to variable 'i'. 
@example
>mdb.start();
#end main;
mdb>
>user.test(1);
#    user.test(1);
mdb>break i
breakpoint on 'i' not set
mdb>n
#    io.print(i);
mdb>break i
mdb>c
[ 1 ]
#    i := calc.*(i,2);
mdb>
@end example

The breakpoints remain in effect over multiple function calls.
They can be removed with the @code{delete} statement.
A list of all remaining breakpoints is obtained with @code{breakpoints}.

The interpreter can be instructed to call the debugger as soon as an exception
is raised. Simply add the instruction @code{mdb.setCatch(true)}.
@node Runtime Inspection, The MAL Profiler, Handling Breakpoints,  The MAL Debugger
@+ Runtime Inspection and Reflection
Part of the debugger functionality can also be used directly with
MAL instructions.
The execution trace of a snippet of code can be visualized 
encapsulation with @code{mdb.setTrace(true)} and @code{mdb.setTrace(false)}.
Likewise, the performance can be monitored with the command @code{mdb.setTimer(on/off)}.
Using a boolean argument makes it easy to control the (performance) trace
at run time. The following snippet shows the effect of patching
the test case.
@example
>function test(i:int):str;
>	mdb.setTrace(true);
>	io.print(i);
>	i:= i*2;
>	b:= bbp.new(:int,:int);
>	bat.insert(b,1,i);
>	io.print(b);
>	mdb.setTrace(false);
>	return test:= "ok";
>end test;
>user.test(1);
#    mdb.setTrace(_3=true)
[ 1 ]
#    io.print(i=1)
#    i := calc.*(i=2, _5=2)
#    b := bbp.new(_7=0, _8=0)
#    bat.insert(b=<tmp_1226>, _10=1, i=2)
#-----------------#
# h     t         # name
# int   int       # type
#-----------------#
[ 1,      2       ]
#    io.print(b=<tmp_1226>)
#   261 usec!    user.test(_2=1)
>
@end example

The commands mdb.setTimer() toggle the performance traceing flag. 
The argument is an integer to designate the action, i.e.
0 turns off the tracer otherwise it turns it on.

The primary output of the timer is statistics in micro-seconds,
the memory tracer shows the arena increment, and the IO tracer
shows in- and out-blocks.
The time spent on preparing the trace information is excluded
from the report.
For more detailed timing information the Linux
tool @emph{valgrind} may be of help.

The routines mdb.setMemory(), and mdb.setIO() extend the timer
trace with an overview of the changes in the memory usage and
IO activity.
@example
>function test(i:int):str;
>	mdb.setTimer(true);
>	io.print(i);
>	i:= i*2;
>	b:= bbp.new(:int,:int);
>	bat.insert(b,1,i);
>	io.print(b);
>	mdb.setTimer(false);
>	return test:= "ok";
>end test;
>user.test(1);
#     6 usec#    mdb.setTimer(_3=true)
[ 1 ]
#    43 usec#    io.print(i=1)
#     5 usec#    i := calc.*(i=2, _5=2)
#    24 usec#    b := bbp.new(_7=0, _8=0)
#    10 usec#    bat.insert(b=<tmp_1226>, _10=1, i=2)
#-----------------#
# h     t         # name
# int   int       # type
#-----------------#
[ 1,      2       ]
#   172 usec#    io.print(b=<tmp_1226>)
#   261 usec#    user.test(_2=1)
@end example

It is also possible to activate the debugger from within a program 
using @code{mdb.start()}. It remains in this mode until 
you either issue a quit command, or the command mdb.stop() instruction is
encountered. 
The debugger is only activated when the user can direct its execution
from the client interface. Otherwise, there is no proper input channel
and the debugger will run in trace mode.

The program listing functionality of the debugger is 
also captured in the MAL debugger module. The current code
block can be listed using @code{mdb.list()} and @code{mdb.List()}.
An arbitrary code block can be shown with  @code{mdb.list}(@emph{module},@emph{function})
and @code{mdb.List}(@emph{module},@emph{function}).
A BAT representation of the current function is return by @code{mdb.getDefinition()}@.

The symbol table and stack content, if available, can be shown with
the operations @code{mdb.var()} and @code{mdb.list}(@emph{module},@emph{function})
Access to the stack frames may be helpful in the context of exception handling.
The operation @code{mdb.getStackDepth()} gives the depth and individual
elements can be accessed as BATs using @code{mdb.getStackFrame(@emph{n})}.
The top stack frame is accessed using @code{mdb.getStackFrame()}.
@{
@- Compilation control
Being able to debug comes at a price.
It should be possible to turn off the feature at compile time.

@h
#ifndef _MAL_DEBUGGER_H
#define _MAL_DEBUGGER_H

#include "mal_scenario.h"
#include "mal_client.h"

#define MAL_DEBUGGER		/* debugger is active */

#define MAXBREAKS 32

mal_export int MDBdelay;	/* do not immediately react */
typedef struct {
	MalBlkPtr brkBlock[MAXBREAKS];
	int		brkPc[MAXBREAKS];
	int		brkVar[MAXBREAKS];
	str		brkMod[MAXBREAKS];
	str		brkFcn[MAXBREAKS];
	char	brkCmd[MAXBREAKS];
	str		brkRequest[MAXBREAKS];
	int		brkTop;
} mdbStateRecord, *mdbState;

mal_export void mdbSetBreakpoint(Client cntxt, MalBlkPtr mb, int pc, char cmd);
mal_export void mdbClrBreakRequest(Client cntxt, str name);
mal_export void mdbShowBreakpoints(Client cntxt);
mal_export void mdbCommand(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p, int pc);
mal_export int mdbSession(void);
mal_export void mdbStep(Client cntxt, MalBlkPtr mb, MalStkPtr stk, int pc);
mal_export void mdbHelp(stream *f);
mal_export void printStackElm(stream *f, MalBlkPtr mb, VarPtr n, ValPtr v, int index, size_t cnt, int first, int lifespan);
mal_export void printBATelm(stream *f, int i, size_t cnt, size_t first);
mal_export void printStack(stream *f, MalBlkPtr mb, MalStkPtr s, int lifespan);
mal_export void printBatInfo(stream *f, VarPtr n, ValPtr v);
mal_export void printBatProperties(stream *f, VarPtr n, ValPtr v, str props);
mal_export void printTraceCall(Client cntxt, MalBlkPtr mb, MalStkPtr stk, int pc);
mal_export str call2str(Client cntxt, MalBlkPtr mb, MalStkPtr stk, int pc);

mal_export str runMALDebugger(Symbol s);
mal_export void printBBPinfo(stream *out);

mal_export void resetOptimizerDebugger(void);
mal_export void optimizerDebug(MalBlkPtr mb, str name, int actions, lng usec);
mal_export str optimizeMALBlock(MalBlkPtr mb);
mal_export void showOptimizerStep(str fnme, int i, int flg);
mal_export void showOptimizerHistory(void);
mal_export str debugOptimizers(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
#endif /* _MAL_DEBUGGER_h */
@+ Debugger framework
Before the interpreter is allowed to proceed we give control
to the user to alter the trace/debugger options.
@c
#include "mal_readline.h"
#include "mal_debugger.h"
#include "mal_atom.h"		/* for showAtoms() */
#include "mal_interpreter.h"	/* for getArgReference() */
#include "mal_linker.h"		/* for getAddress() */
#include "mal_module.h"		/* for showModuleStatistics() */
#include "mal_parser.h"
#include "mal_namespace.h"


int MDBdelay;			/* do not immediately react */

#define skipBlanc(c,X)    while(*(X) && isspace((int)*X)){ X++; }
#define skipNonBlanc(c,X) while(*(X) && !isspace((int) *X)){ X++; }
#define skipWord(c,X) 	  skipNonBlanc(c,X); skipBlanc(c,X);
@-
Each client has its own breakpoint administration, kept in a global table.
Although a little space consumptive, it is the easiest to maintain
and much less expensive as reserving debugger space in each instruction.
@c
mdbStateRecord mdbTable[MAL_MAXCLIENTS];

char
isBreakpoint(Client cntxt, MalBlkPtr mb, InstrPtr p, int pc)
{
	int i, j;

	for (i = 0; i < mdbTable[cntxt->idx].brkTop; i++) {
		if( mdbTable[cntxt->idx].brkBlock[i] != mb) 
			continue;
		if( mdbTable[cntxt->idx].brkPc[i] == pc )
			return mdbTable[cntxt->idx].brkCmd[i];

		if( mdbTable[cntxt->idx].brkMod[i] && getModuleId(p) &&
		    mdbTable[cntxt->idx].brkFcn[i] && getFunctionId(p) &&
			strcmp(mdbTable[cntxt->idx].brkMod[i], getModuleId(p))==0 &&
			strcmp(mdbTable[cntxt->idx].brkFcn[i], getFunctionId(p))==0)
			return mdbTable[cntxt->idx].brkCmd[i];

		if( mdbTable[cntxt->idx].brkVar[i] >= 0 )
		for (j = 0; j < p->retc; j++)
			if (mdbTable[cntxt->idx].brkVar[i] == getArg(p,j))
				return mdbTable[cntxt->idx].brkCmd[i];
	}
	return 0;
}

@-
Break points can be set on assignment to a specific variable,
specific operation, or a instruction line
@c
void
mdbSetBreakRequest(Client cntxt, MalBlkPtr mb, str request, char cmd)
{
	int i;
	str modnme, fcnnme;
	mdbState mdb = mdbTable + cntxt->idx;
	Symbol sym;

	/* set breakpoint on specific line */
	if( *request == '#' ){
		i= atoi(request+1);
		if( i<0 || i>= mb->stop)
			stream_printf(cntxt->fdout, "breakpoint on #%d (<%d) not set\n", 
				i, mb->stop);
		else  {
			mdb->brkBlock[mdb->brkTop] = mb;
			mdb->brkPc[mdb->brkTop] = i;
			mdb->brkVar[mdb->brkTop] = -1;
			mdb->brkMod[mdb->brkTop] = 0;
			mdb->brkFcn[mdb->brkTop] = 0;
			mdb->brkRequest[mdb->brkTop] = GDKstrdup(request);
			mdb->brkCmd[mdb->brkTop] = cmd;
			if (mdb->brkTop + 1 < MAXBREAKS)
				mdb->brkTop++;
		}
		return;
	}

	/* check for a [module.]function request */
	fcnnme= strchr(request,'.');
	if( fcnnme){
		modnme= request;
		*fcnnme= 0;
		fcnnme++;
		sym= findMALSymbol(modnme,fcnnme);
		mdb->brkBlock[mdb->brkTop] = sym? sym->def: mb;
		mdb->brkPc[mdb->brkTop] = -1;
		mdb->brkVar[mdb->brkTop] = -1;
		mdb->brkMod[mdb->brkTop] = putName(modnme,strlen(modnme));
		mdb->brkFcn[mdb->brkTop] = putName(fcnnme,strlen(fcnnme));
		fcnnme--; *fcnnme= '.';
		mdb->brkRequest[mdb->brkTop] = GDKstrdup(request);
		mdb->brkCmd[mdb->brkTop] = cmd;
		if (mdb->brkTop + 1 < MAXBREAKS)
			mdb->brkTop++;
		return;
	} 
	/* the final step is to break on a variable */
	i= findVariable(mb,request);
	if( i< 0)
		stream_printf(cntxt->fdout, "breakpoint on %s not set\n", request);
	else {
		mdb->brkBlock[mdb->brkTop] = mb;
		mdb->brkPc[mdb->brkTop] = -1;
		mdb->brkVar[mdb->brkTop] = i;
		mdb->brkMod[mdb->brkTop] = 0;
		mdb->brkFcn[mdb->brkTop] = 0;
		mdb->brkRequest[mdb->brkTop] = GDKstrdup(request);
		mdb->brkCmd[mdb->brkTop] = cmd;
		if (mdb->brkTop + 1 < MAXBREAKS)
			mdb->brkTop++;
	}
}

@-
A breakpoint should be set once for each combination
@c
void
mdbSetBreakpoint(Client cntxt, MalBlkPtr mb, int pc, char cmd)
{
	mdbState mdb = mdbTable + cntxt->idx;
	char buf[20];

	snprintf(buf,20,"#%d",pc);
	mdb->brkBlock[mdb->brkTop] = mb;
	mdb->brkPc[mdb->brkTop] = pc;
	mdb->brkVar[mdb->brkTop] = -1;
	mdb->brkMod[mdb->brkTop] = 0;
	mdb->brkFcn[mdb->brkTop] = 0;
	mdb->brkRequest[mdb->brkTop] = GDKstrdup(buf);
	mdb->brkCmd[mdb->brkTop] = cmd;
	if (mdb->brkTop + 1 < MAXBREAKS)
		mdb->brkTop++;
}

void
mdbShowBreakpoints(Client cntxt)
{
	int i;
	mdbState mdb = mdbTable + cntxt->idx;

	for (i = 0; i < mdb->brkTop; i++)
		stream_printf(cntxt->fdout, "breakpoint on '%s'\n", mdb->brkRequest[i]);
}

void
mdbClrBreakpoint(Client cntxt, int pc)
{
	int i, j = 0;
	mdbState mdb = mdbTable + cntxt->idx;

	for (i = 0; i < mdb->brkTop; i++) {
		mdb->brkBlock[j] = mdb->brkBlock[i];
		mdb->brkPc[j] = mdb->brkPc[i];
		mdb->brkVar[j] = mdb->brkVar[i];
		mdb->brkMod[j] = mdb->brkMod[i];
		mdb->brkFcn[j] = mdb->brkFcn[i];
		mdb->brkRequest[j] = mdb->brkRequest[i];
		mdb->brkCmd[j] = mdb->brkCmd[i];
		if (mdb->brkPc[i] != pc)
			j++;
		else {
			GDKfree(mdb->brkRequest[i]);
			mdb->brkRequest[i] = 0;
		}

	}
	mdb->brkTop = j;
}

void
mdbClrBreakRequest(Client cntxt, str request)
{
	int i, j = 0;
	mdbState mdb = mdbTable + cntxt->idx;

	for (i=0; i < mdb->brkTop; i++) {
		mdb->brkBlock[j] = mdb->brkBlock[i];
		mdb->brkPc[j] = mdb->brkPc[i];
		mdb->brkVar[j] = mdb->brkVar[i];
		mdb->brkMod[j] = mdb->brkMod[i];
		mdb->brkFcn[j] = mdb->brkFcn[i];
		mdb->brkRequest[j] = mdb->brkRequest[i];
		mdb->brkCmd[j] = mdb->brkCmd[i];
		if (strcmp(mdb->brkRequest[i], request))
			j++;
		else {
			GDKfree(mdb->brkRequest[i]);
			mdb->brkRequest[i] = 0;
		}
	}
	mdb->brkTop = j;
}

@-
The instruction call stack is the most common command.
Prepare a string for an instruction call. 
We rely on the buffersize of instruction2str.
@c
str
call2str(Client cntxt, MalBlkPtr mb, MalStkPtr stk, int pc)
{
	int k,len;
	str msg,w;
	str s;
	InstrPtr p;

	p= getInstrPtr(mb,pc);
	msg = instruction2str(mb, p, FALSE);
	s = strchr(msg, '(');
	if (p->retc > 1 && s) {
		s = strchr(s + 1, '(');
	}
	if (s) {
		s++;
		*s = 0;
		len = strlen(msg);
		for (k = p->retc; k < p->argc; k++) {
			VarPtr v = getVar(mb, getArg(p, k));
			ValPtr val = &stk->stk[getArg(p, k)];

			if (v->tmpindex == 0)
				sprintf(msg+len, "%s=", v->name);
			else
				sprintf(msg+len, "%c%d=", TMPMARKER, v->tmpindex);
			w = 0;
			ATOMformat(val->vtype, VALptr(val), &w);
			strcat(msg,w);
			if( ATOMcmp(val->vtype, ATOMnilptr(val->vtype), VALptr(val))==0){
				str tpe= getTypeName(v->type);
				strcat(msg,":");
				strcat(msg,tpe);
				GDKfree(tpe);
			}
			/* in timer mode we show more details */
			if( cntxt->timerFlag && isaBatType(v->type)){
				str tpe= getTypeName(v->type);
				BAT *b;
				strcat(msg,tpe);
				b= BATdescriptor(val->val.ival);
				if( b){
					len= strlen(msg);
					sprintf(msg+len,"{%d}",(int)BATcount(b));
					BBPunfix(b->batCacheid);
				}
				GDKfree(tpe);
			}
			GDKfree(w);
			if (k < p->argc - 1)
				strcat(msg,", ");
			len= strlen(msg);
		}
		strcat(msg,")");
	} 
	return msg;
}

void
printCall(Client cntxt, MalBlkPtr mb, MalStkPtr stk, int pc)
{
	str msg;
	msg = call2str(cntxt,mb, stk, pc);
	stream_printf(cntxt->fdout, "%s at %s.%s[%d]\n", msg, 
		getModuleId(getInstrPtr(mb,0)),
		getFunctionId(getInstrPtr(mb,0)),pc);
	GDKfree(msg);
}

@-
Beware, the printTraceCall is a rather expensive routine and obscures
the actual timing. We therefore compensate the global timing maintained
@c
void
printTraceCall(Client cntxt, MalBlkPtr mb, MalStkPtr stk, int pc)
{
	str msg;
	msg= call2str(cntxt,mb,stk,pc);
	stream_printf(cntxt->fdout, "%s\n", msg);
	GDKfree(msg);
}

@+ MAL parser
The debugger structure is inherited from GDB.
The routine mdbCommand is called with p=0 after finishing a mal- function call
and before continuing at the next level of invocation.
The commands are self-explanatory.

The prompt string sent to the user indicates the debugger mode.
@c
#define MDBstatus(X) if(cntxt->fdout) \
	stream_printf(cntxt->fdout,"#MonetDB Debugger %s\n", (X?"on":"off"));

void
mdbCommand(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p, int pc)
{
	int m = 1;
	char *b, *c;
	stream *out = cntxt->fdout;
	/* int listing = cntxt->listing;*/
	char *oldprompt = cntxt->prompt;
	int oldpromptlength = cntxt->promptlength;

	if (p != NULL) {
		if (cntxt != mal_clients) 
			/* help MapiClients with fake prompt */
			stream_printf(out,"mdb>");
		/* printInstruction(out, mb, p, listing);*/
		printTraceCall(cntxt,mb,stk,pc);
	}
	if (cntxt == mal_clients) {
		cntxt->prompt = "mdb>";
		cntxt->promptlength = 4;
	}
	do {
		if (cntxt->phase[READER]) {
			if ((*cntxt->phase[READER]) (cntxt)) {
				break;
			}
		} else if (readConsole(cntxt) <= 0) {
			break;
		}
		b = CURRENT(cntxt);

		/* terminate the line with zero */
		c = strchr(b, '\n');
		if (c) {
			*c = 0;
			cntxt->fdin->pos += (c - b) + 1;
		} else {
			cntxt->fdin->pos = cntxt->fdin->len;
		}

		skipBlanc(cntxt, b);
		switch (*b) {
		case 0:
			m = 0;
			break;
		case 'a':
			if (strncmp("atoms", b, 5) == 0)
				showAtoms(out);
			break;
		case 'c':
			if (strncmp("catch", b, 5) == 0) {
				/* catch the next exception */
				stk->cmd = 'C';
				break;
			}
			if (strncmp("call", b, 4) == 0) {
				GDKerror("call instruction not yet implemented\n");
				break;
			}
			stk->cmd = 'c';
			skipWord(cntxt, b);
			m = 0;
			break;
		case 'h':
			mdbHelp(out);
			break;
		case 'e':
		{
			/* terminate the execution for ordinary functions only */
			if (strncmp("exit", b, 4) == 0) {
		case 'x':
				if (!(getInstrPtr(mb, 0)->token == FACcall)) {
					stk->cmd = 'x';
					cntxt->prompt = oldprompt;
					cntxt->promptlength = oldpromptlength;
				}
			}
			return;
		}
		case 'q':
		{
			MalStkPtr su;

			/* return from this debugger */
			for (su = stk; su; su = su->up)
				su->cmd = 0;
			cntxt->itrace = 0;
			cntxt->timerFlag = 0;
			/* MDBstatus(0); */
			cntxt->prompt = oldprompt;
			cntxt->promptlength = oldpromptlength;
			return;
		}
		case 'f':	/* finish */
			if( strncmp("flow",b,4) == 0){
				skipWord(cntxt, b);
				cntxt->flowFlag = (sht) atol(b);
				break;
			}
		case 'n':	/* next */
		case 's':	/* step */
			if (strncmp("scenarios", b, 3) == 0) {
				showAllScenarios(out);
			} else if (strncmp("scenario", b, 3) == 0) {
				showScenarioByName(out, cntxt->scenario);
			} else if (strncmp("scope", b, 3) == 0) {
				showModuleStatistics(out, cntxt->nspace);
				break;
			}
			stk->cmd = *b;
			m = 0;
			break;
		case 'm':	/* display a module */
		{
			str modname, fcnname;
			Module fsym;
			Symbol fs;
			int i;

			if (strncmp("modules", b, 7) == 0) {
				showModules(out, cntxt->nspace);
				continue;
			}
			if( strncmp("memory",b,6) == 0){
				skipWord(cntxt, b);
				cntxt->memoryFlag = (sht) atol(b);
				cntxt->memory= MT_mallinfo();
				stream_printf(out,"arena %d ordblks %d smblks %d "
					" hblkhd %d hblks %d fsmblks %d uordblks %d\n",
					cntxt->memory.arena,
					cntxt->memory.ordblks,
					cntxt->memory.smblks,
					cntxt->memory.hblkhd,
					cntxt->memory.hblks,
					cntxt->memory.fsmblks,
					cntxt->memory.uordblks
				);
				continue;
			}

			skipWord(cntxt, b);
			if (*b) {
				modname = b;
				fcnname = strchr(b, '.');
				if (fcnname) {
					*fcnname = 0;
					fcnname++;
				}
				fsym = findModule(cntxt->nspace, putName(modname, strlen(modname)));

				if (fsym == cntxt->nspace && strcmp(modname,"user") ) {
					stream_printf(out, "module '%s' not found\n", modname);
					continue;
				}
				for (i = 0; i < MAXSCOPE; i++) {
					fs = fsym->subscope[i];
					while (fs != NULL) {
						if (fcnname == NULL)
							printSignature(out, fs, 0);
						else if (strcmp(fcnname, getFcnName(fs->def)) == 0)
							printSignature(out, fs, 0);
						fs = fs->peer;
					}
				}
				continue;
			}
		}
			break;
		case 'T':	/* debug type resolver for a function call */
			if (strncmp("Trace", b, 5) == 0) {
				char *w;
				skipWord(cntxt, b);
				skipBlanc(cntxt, b);
				if ( (w =strchr(b, '\n')) )
					*w = 0;
				traceFcnName = GDKstrdup(b);
			}
			break;
		case 't':	/* trace a variable toggle */
			if (strncmp("trace", b, 5) == 0) {
				char *w;
				skipWord(cntxt, b);
				skipBlanc(cntxt, b);
				if ( (w= strchr(b, '\n')) )
					*w = 0;
				mdbSetBreakRequest(cntxt, mb, b, 't');
			} else
			if (strncmp("timer", b, 5) == 0) {
				skipWord(cntxt, b);
				switch( *b){
				case '0': cntxt->timerFlag = 0; break;
				case '1': cntxt->timerFlag = 1; break;
				default: cntxt->timerFlag = ! cntxt->timerFlag;
				}
				if( cntxt->timer == 0)
					cntxt->timer = GDKusec();
				stk->cmd = 0;
			}
			break;
		case 'v':	/* show the symbol table and bindings */
		case 'V':{
			str modname, fcnname;
			Module fsym;
			Symbol fs;
			int i, lifespan = *b== 'V';

			skipWord(cntxt, b);
			if (*b != 0) {
				modname = b;
				fcnname = strchr(b, '.');
				if (fcnname == NULL) {
					fsym = findModule(cntxt->nspace, putName(modname, strlen(modname)));
					if (fsym == 0) {
						stream_printf(out, "%s module not found\n", modname);
						continue;
					}
					for (i = 0; i < MAXSCOPE; i++) {
						fs = fsym->subscope[i];
						while (fs != NULL) {
							printStack(out, fs->def, 0, lifespan);
							fs = fs->peer;
						}
					}
					continue;
				}
				*fcnname = 0;
				fcnname++;
				fsym = findModule(cntxt->nspace, putName(modname, strlen(modname)));
				if (fsym == 0) {
					stream_printf(out, "%s module not found\n", modname);
					continue;
				}
				/* display the overloaded symbol definition */
				for (i = 0; i < MAXSCOPE; i++) {
					fs = fsym->subscope[i];
					while (fs != NULL) {
						if (strcmp(fs->name, fcnname) == 0)
							printStack(out, fs->def, 0,lifespan);
						fs = fs->peer;
					}
				}
			} else
				printStack(out, mb, stk,lifespan);
			break;
		}
		case 'b':
			if (strncmp(b, "bbp",3) == 0) {
				int i,limit;

				skipWord(cntxt, b);
				i = BBPindex(b);
				if( i)
					limit=i+1;
				else {
					limit= BBPsize;
					i=1;
				}
				for (; i < limit; i++)
					if (BBP_logical(i) && BBP_cache(i)) {
						stream_printf(out, "[%d] %s lref = %d ref= %d ", 
							i, BBP_logical(i), BBP_lrefs(i), BBP_refs(i));
						stream_printf(out, " dirty=%d", BATdirty(BBP_cache(i)));
						if( *BBP_logical(i) =='.')
							stream_printf(out, " zombie ");
						if( BBPstatus(i) & BBPLOADED)
							stream_printf(out, " loaded ");
						if( BBPstatus(i) & BBPSWAPPED)
							stream_printf(out, " swapped ");
						if( BBPstatus(i) & BBPTMP)
							stream_printf(out, " tmp ");
						if( BBPstatus(i) & BBPDELETED)
							stream_printf(out, " deleted ");
						if( BBPstatus(i) & BBPEXISTING)
							stream_printf(out, " existing ");
						if( BBPstatus(i) & BBPNEW)
							stream_printf(out, " new ");
						if( BBPstatus(i) & BBPPERSISTENT)
							stream_printf(out, " persistent ");
						stream_printf(out, "\n");
					}
				continue;
			}
			if (strncmp(b, "breakpoints",11) == 0) {
				mdbShowBreakpoints(cntxt);
				continue;
			}
			if (strncmp(b, "break", 5) == 0)
				b += 4;
			if (isspace((int) b[1])) {
				skipWord(cntxt, b);
				if (*b && !isspace((int) *b))
					/* set breakpoints by name */
					mdbSetBreakRequest(cntxt, mb, b, 's');
				else
					/* set breakpoint at current instruction */
					mdbSetBreakpoint(cntxt, mb, pc, 's');
				continue;
			}
			continue;
		case 'd':
			if( strncmp(b, "debug", 5) == 0){
				skipWord(cntxt, b);
				GDKdebug = atol(b);
				stream_printf(out,"Set debug mask to %d\n",GDKdebug);
				break;
			}
			if (strncmp(b, "down", 2) == 0 && stk->down != NULL) {
				stream_printf(out, "%sgo down the stack\n", "#mdb ");
				stk = stk->down;
				mb = stk->blk;
				break;
			}
			skipWord(cntxt, b);
			/* get rid of break point */
			if (*b && !isspace((int) *b)) {
				mdbClrBreakRequest(cntxt, b);
			} else {
				mdbClrBreakpoint(cntxt, pc);
			}
			continue;
		case 'I':
		case 'i':
		{
			int i;
			char *t;

			if (strncmp("io", b, 2) == 0) {
				skipWord(cntxt, b);
				cntxt->ioFlag = (sht) atol(b);
#ifdef HAVE_SYS_RESOURCE_H
				getrusage(RUSAGE_SELF, &cntxt->resource);
				stream_printf(out, "#maxrss %d ixrss=%d idrss=%d isrss=%d" " minflt=%d majflt=%d nswap=%d inblock=%d oublock=%d\n", cntxt->resource.ru_maxrss, cntxt->resource.ru_ixrss, cntxt->resource.ru_idrss, cntxt->resource.ru_isrss,
					      cntxt->resource.ru_minflt, cntxt->resource.ru_majflt, cntxt->resource.ru_nswap, cntxt->resource.ru_inblock, cntxt->resource.ru_oublock);
#endif
				continue;
			}
			/* the user wants information about variables */
			if( *b == 'I'){
				skipWord(cntxt, b);
				for(i=0; i< mb->vtop; i++)
					printBatProperties(out, getVar(mb, i), stk->stk + i, b);
				continue;
			}
			skipWord(cntxt, b);
			t = b;
			skipNonBlanc(cntxt, t);
			*t = 0;
			/* search the symbol */
			i = findVariable(mb, b);
			if (i < 0) {
				stream_printf(out, "%s Symbol not found\n", "#mdb ");
			} else {
				printBatInfo(out, getVar(mb, i), stk->stk + i);
			}
			continue;
		}
		case 'P':
		case 'p':
		{
			size_t size = 0, first = 0;
			int i;
			char *t;
			char upper= *b;

			skipWord(cntxt, b);
			t = b;
			skipNonBlanc(cntxt, t);
			*t = 0;
			/* you can identify a start and length */
			t++;
			skipBlanc(cntxt, t);
			if (isdigit((int) *t)) {
				size = atol(t);
				skipWord(cntxt, t);
				if (isdigit((int) *t))
					first = atol(t);
			}
			if( upper == 'P'){
				for( i= 0; i<mb->vtop; i++)
				if (isaBatType(getVarType(mb,i)) )
					printBATelm(out, i, size, first);
				continue;
			}
			/* search the symbol */
			i = findVariable(mb, b);
			if (i < 0) {
				i = BBPindex(b);
				if (i != 0)
					printBATelm(out, i, size, first);
				else
					stream_printf(out, "%s Symbol not found\n", "#mdb ");
				continue;
			}
			printStackElm(out, mb, getVar(mb, i), stk->stk + i, i, size, first,0);
			continue;
		}
		case 'S':
			dumpNamespaceStatistics(out, 1);
			break;
		case 'u':
			if (stk->up == NULL)
				break;
			stream_printf(out, "%s go up the stack\n", "#mdb ");
			stk = stk->up;
			mb = stk->blk;
			printCall(cntxt, mb, stk, pc);
			continue;
		case 'w':
		{
			MalStkPtr w;
			MalBlkPtr mw = mb;
			int pci = pc;	/*  how to find enclosing pc */

			for (w = stk; w != NULL; w = w->up) {
				mw = w->blk;
				printCall(cntxt, mw, w, pci);
				if (w->up)
					pci = w->up->pcup;
			}
			continue;
		}
@-
While debugging it should be possible to inspect the symbol
table using the 'module.function' name. The default is to list all
signatures satisfying the pattern.
@c
		case 'L':
		case 'l':	/* list the current code block */
		{
			str modname, fcnname;
			Module fsym;
			Symbol fs;
			int i, lstng;

			lstng = /* listing | */ (*b == 'L' ? LIST_MAL_ALL : LIST_MAL_INSTR);
			skipWord(cntxt, b);
			if (*b != 0) {
				modname = b;
				fcnname = strchr(b, '.');
				if (fcnname == NULL) {
					fsym = findModule(cntxt->nspace, putName(modname, strlen(modname)));
					if (fsym == 0) {
						stream_printf(out, "%s module not found\n", modname);
						continue;
					}
					for (i = 0; i < MAXSCOPE; i++) {
						fs = fsym->subscope[i];
						while (fs != NULL) {
							printFunction(out, fs->def, lstng);
							fs = fs->peer;
						}
					}
					continue;
				}
				*fcnname = 0;
				fcnname++;
				fsym = findModule(cntxt->nspace, putName(modname, strlen(modname)));
				if (fsym == 0) {
					stream_printf(out, "%s module not found\n", modname);
					continue;
				}
				/* display the overloaded symbol definition */
				if (displayModule(out, fsym, fcnname, lstng) == 0) {
					stream_printf(out, "%sSymbol '%s.%s' not found\n", "#mdb ", modname, fcnname);
				}
			} else {
				printFunction(out, mb, lstng);
			}
			continue;
		}
		case 'o':
		case 'O':	/* optimizer steps */
		{
			int flg = *b == 'o' ? LIST_MAL_INSTR : LIST_MAL_ALL;
			int idx;

			skipWord(cntxt, b);
			if (*b) {
				if( !isdigit(*b) ){
					char fname[1024],*f = fname;
					/* dump to file */
					while(!isspace(*b) && f< fname+1022) *f++= *b++;
					*f= 0;
					skipWord(cntxt,b);
					idx = atoi(b);
					showOptimizerStep(fname, idx, flg);
				} else {
					idx = atoi(b);
					showOptimizerStep(NULL, idx, flg);
				}
			} else
				showOptimizerHistory();
			break;
		}
		case 'r':	/* reset program counter */
			stream_printf(out, "%s restart with current stack\n", "#mdb ");
			stk->cmd = 'r';
			break;
		default:
			stream_printf(out, "%s debugger command expected\n", "#mdb ");
			mdbHelp(out);
		}
	} while (m);
	cntxt->prompt = oldprompt;
	cntxt->promptlength = oldpromptlength;
}

static int mdbSessionActive;
int mdbSession(){
	return mdbSessionActive;
}

void
mdbStep(Client cntxt, MalBlkPtr mb, MalStkPtr stk, int pc)
{
	InstrPtr p;
	char ch;

	mdbSessionActive= 1; /* for name completion */
	switch (stk->cmd) {
	case 'c':
		p = getInstrPtr(mb, pc);
		ch= isBreakpoint(cntxt,mb, p, pc);
		if( ch == 't'){
			if (cntxt != mal_clients) 
				/* help MapiClients with fake prompt */
				stream_printf(cntxt->fdout,"mdb>");
			printTraceCall(cntxt,mb,stk,pc);
		} else if( ch )
			mdbCommand(cntxt, mb, stk, p, pc);
		break;
	case 's':
	case 'n':
		p = getInstrPtr(mb, pc);
		mdbCommand(cntxt, mb, stk, p, pc);
		break;
	case 'C':
		mdbSessionActive= 0; /* for name completion */
	}
	if( mb->errors) {
		MalStkPtr su;

		/* return from this debugger */
		for (su = stk; su; su = su->up)
			su->cmd = 0;
		stk->cmd = 'x';	/* will force a graceful termination */
	}
	if( mdbSessionActive== 0) return;
	showErrors();
	if (cntxt->timerFlag)
		cntxt->timer = GDKusec();
	mdbSessionActive= 0; /* for name completion */
}

@-
It would come in handy if at any time you could activate
the debugger on a specific function. This calls for the
creation of a minimal execution environment first.
@c
str
runMALDebugger(Symbol s)
{
	Client c = MCgetClient();

	c->itrace = 'n';
	runMAL(c, s->def, 1, 0, 0, 0);
	return MAL_SUCCEED;
}

@+ Utilities
Dumping a stack on a file is primarilly used for debugging.
Printing the stack requires access to both the symbol table and
the stackframes in most cases.
Beware that a stack frame need not be initialized with null values.
It has been zeroed upon creation.

The routine  can also be used to inspect the symbol table of
arbitrary functions.
@c
void
printStack(stream *f, MalBlkPtr mb, MalStkPtr s,int lifespan)
{
	int i = 0;

	if (s) {
		stream_printf(f, "#Stack '%s' size=%d top=%d\n",
				getInstrPtr(mb, 0)->fcnname, s->stksize, s->stktop);
		for (; i < mb->vtop; i++)
			printStackElm(f, mb, getVar(mb, i), s->stk + i, i, 0, 0,lifespan);
	} else
		for (; i < mb->vtop; i++)
			printStackElm(f, mb, getVar(mb, i), 0, i, 0, 0,lifespan);
}

void
printBATelm(stream *f, int i, size_t cnt, size_t first)
{
	BAT *b, *bs;
	str tpe ,nme;

	b = BATdescriptor(i);
	if (b) {
		nme= BATgetId(b); 
		tpe = getTypeName(newBatType(b->htype, b->ttype));
		/* ignore ref count of this call */
		stream_printf(f, "[%d] %s %s count=%d lrefs=%d refs=%d \n", 
				i, nme, tpe, 
				BATcount(b), BBP_lrefs(ABS(b->batCacheid)), 
				BBP_refs(ABS(b->batCacheid)) - 1);
		/* perform property checking */
		if( b->H != b->T)
			BATpropcheck(BATmirror(b),BATPROPS_QUICK);
		BATpropcheck(b,BATPROPS_QUICK);
		if( cnt){
			if (cnt < BATcount(b)) {
				stream_printf(f, "Sample %d out of %d\n", cnt, BATcount(b));
			}
			/* cut out a portion of the BAT for display */
			bs = BATslice(b, first, first + cnt);

			if (bs == NULL)
				stream_printf(f, "Failed to take chunk\n");
			else
				BATmultiprintf(f, 2, &bs, TRUE, 0, TRUE);
			BBPunfix(bs->batCacheid);
		}

		BBPunfix(b->batCacheid);
		GDKfree(tpe);
	}
}

void
printStackElm(stream *f, MalBlkPtr mb, VarPtr n, ValPtr v, int index, size_t cnt, int first, int lifespan)
{
	str nme, nmeOnStk;
	char nmebuf[PATHLENGTH];

	(void) mb;		/* fool the compiler */
	if (n->tmpindex) {
		snprintf(nmebuf, PATHLENGTH, "%c%d", TMPMARKER, n->tmpindex);
		nme = nmebuf;
	} else
		nme = n->name;
	if( lifespan) {
		stream_printf(f, "#[%d,%d:%d,%d]  ", index, 
			n->beginLifespan, n->endLifespan,n->lastUpdate);
		if( isVarGarbage(mb,index) )
			stream_printf(f,"G ");
		stream_printf(f, " %s\t= ", nme);
	} else stream_printf(f, "#[%d] %s\t= ", index, nme);
	if (n->type == TYPE_void)
		stream_printf(f, "nil");
	else if (v)
		ATOMprint(v->vtype, VALptr(v), f);

	nme = getTypeName(n->type);
	stream_printf(f, ":%s", nme);
	if( lifespan && n->isudftype)
		stream_printf(f," udftype");
	nmeOnStk = v ? getTypeName(v->vtype) : GDKstrdup(nme);
	if (strcmp(nmeOnStk, nme)) {
		if (isaBatType(n->type)) {
			BAT *b;

			b = BATdescriptor(v->val.ival);
			if (b) {
				nmeOnStk = getTypeName(newBatType(b->htype, b->ttype));
				if (strcmp(nme, nmeOnStk))
					stream_printf(f, " != :%s", nmeOnStk);
				BBPunfix(b->batCacheid);
			}
		} else if (!(isaBatType(n->type) && strcmp(nmeOnStk, "BAT") == 0))
			stream_printf(f, " != %s", nmeOnStk);
	}
	stream_printf(f, " %s", (n->isaconstant ? " constant" : ""));
	stream_printf(f, " %s", (n->isused==0 ? " not used" : ""));
	stream_printf(f, " %s", (n->isatypevar ? " type variable" : ""));
	GDKfree(nme);
	GDKfree(nmeOnStk);

	if (cnt && isaBatType(n->type) && v && v->val.ival) {
		BAT *b, *bs;

		b = BATdescriptor(v->val.ival);
		if (b == NULL) {
			stream_printf(f, "Could not access descriptor\n");
			return;
		}
		stream_printf(f, "\n");
		if (cnt <= BATcount(b)) {
			stream_printf(f, "Sample %d out of %d\n", cnt, BATcount(b));
		}
		/* cut out a portion of the BAT for display */
		bs = BATslice(b, first, first + cnt);

		if (bs == NULL)
			stream_printf(f, "Failed to take chunk\n");
		else
			BATmultiprintf(f, 2, &bs, TRUE, 0, TRUE);
		BBPunfix(bs->batCacheid);

		BBPunfix(b->batCacheid);
	} else if (isaBatType(n->type) && v) {
		BAT *b;

		b = BATdescriptor(v->val.ival);
		if (b) {
			/* ignore ref count of this call */
			stream_printf(f, " count=%d lrefs=%d refs=%d", 
				BATcount(b), BBP_lrefs(ABS(b->batCacheid)), 
				BBP_refs(ABS(b->batCacheid)) - 1);
			BBPunfix(b->batCacheid);
		}
	} else if (cnt && isaColType(n->type) && v && v->val.ival) {
		stream_printf(f, "Operation not yet implemented for :col types\n");
	}
	if( n->props){
		nme= propertySet2str(n->props);
		stream_printf(f,"%s",nme);
		GDKfree(nme);
	}
	stream_printf(f, "\n");
}

void
printBatInfo(stream *f, VarPtr n, ValPtr v)
{
	if (isaBatType(n->type) && v->val.ival) {
		int bid;
		int ret;
		MALfcn fcn;

		fcn = getAddress("bat","bat","BKCinfo", 0);
		if (fcn) {
			BAT *b;

			bid = v->val.ival;
			stream_printf(f, "Show info for %d\n", bid);
			(*fcn) (&ret, &bid);
			b = BATdescriptor(ret);
			if (b == NULL) {
				stream_printf(f, "Could not access descriptor\n");
				return;
			}
			BATmultiprintf(f, 2, &b, TRUE, 0, TRUE);
			BBPunfix(b->batCacheid);
		}
	}
}

void
printBatProperties(stream *f, VarPtr n, ValPtr v, str props)
{
	if (isaBatType(n->type) && v->val.ival) {
		int bid;
		int ret;
		MALfcn fcn;
		BUN p;

		fcn = getAddress("bat","bat","BKCinfo", 0);
		if (fcn) {
			BAT *b;

			bid = v->val.ival;
			stream_printf(f, "BAT %d %s= ", bid,props);
			(*fcn) (&ret, &bid);
			b = BATdescriptor(ret);
			if (b == NULL) {
				stream_printf(f, "Could not access descriptor\n");
				return;
			}
			p= BUNfnd(b,props);
			if( p) {
				stream_printf(f," %s\n", (str) BUNtail(b,p));
			} else stream_printf(f," not found\n");
			BBPunfix(b->batCacheid);
		}
	}
}

@-
The memory positions for the BATs is useful information to
asses for memory fragmentation.
@= heapinfo
hp= b->@1;
if(hp && hp->base){
	stream_printf(GDKout,"\t@1=%d size=%d\n",hp->base, hp->size);}
@= hashinfo
h= b->@1;
if(h && h->mask){
	    stream_printf(GDKout,"\t@1=%d size=%d\n",h, sizeof(*h));
	    stream_printf(GDKout,"\t@1link=%d size=%d\n",h->link,
	            (h->mask+h->lim+1)*sizeof(int));
}
@-
The memProfileVector routine produces a character string to represent
the usage of memory by BAT information. The characters are interpreted
as follows:
.=unused, X=completely used, [0-9]=small elements within the granule
More then 9 elements makes it full.
@= setVector
	start= (((long)@1)-min)/granule;
	lim= (((long)@1)-min + @2)/granule;
	stream_printf(GDKout,"start %d lim %d\n",start,lim);

@c
str
memProfileVector(int cells)
{
	str v = GDKmalloc(cells + 1);
	int i;
#ifdef HAVE_SBRK
	long max = (long) sbrk(0);
	long min = 0;
	long granule = 0;
#endif

	if (cells <= 0) {
		GDKerror("memProfileVector:positive argument expected\n");
		return GDKstrdup("");
	}
	v = GDKmalloc(cells + 1);
	if (v == 0)
		GDKfatal("memProfileVector:malloc failure\n");

	for (i = 0; i < cells; i++)
		v[i] = '.';
	v[i] = 0;

	for (i = 1; i < BBPsize; i++)
		if (BBP_status(i) & BBPLOADED) {
			BAT *b = BATdescriptor(i);
			Heap *hp;
			Hash *h;
#ifdef HAVE_SBRK
			long start, lim;
#endif

			stream_printf(GDKout, "\tdesc=%d size=%d\n", b, sizeof(*b));
			hp = b->batBuns;
			stream_printf(GDKout, "\tbuns=%d size=%d\n", hp->base, hp->size);
#ifdef HAVE_SBRK
			if (min == 0) {
				min = (long) b;
				max = min + GDKmem_heapsize();
				granule = (max - min) / cells;
				stream_printf(GDKout, "granule %dK\n", granule / 1024);
			}
			@:setVector(b, sizeof(*b))@
			@:setVector(hp->base, hp->size)@
#endif

			@:heapinfo(hheap)@
			@:heapinfo(theap)@
			@:hashinfo(hhash)@
			@:hashinfo(thash)@
			BBPunfix(b->batCacheid);
		}
	return v;
}

void
printBBPinfo(stream *out)
{
	str v;

	stream_printf(out, "#BBP memory layout\n");
	stream_printf(out, "#heap maximum =%d/M\n", GDKmem_heapsize() / (1024 * 1024));
	v = memProfileVector(32);
	stream_printf(out, "#%s\n", v);
	GDKfree(v);
#ifdef GDK_VM_KEEPHISTO
	stream_printf(out, "#BBP VM history available\n");
#else
	stream_printf(out, "#BBP VM history not available\n");
#endif
}

@-
Some utilities for the debugger
@c
void
mdbHelp(stream *f)
{
	stream_printf(f, "next       -- Advance to next statement\n");
	stream_printf(f, "continue   -- Continue program being debugged\n");
	stream_printf(f, "catch      -- Catch the next exception \n");
	stream_printf(f, "break      -- set breakpoint on current instruction\n");
	stream_printf(f, "break <var>    -- break on assignment to <var>\n");
	stream_printf(f, "delete <var>   -- remove break/trace point <var>\n");
	stream_printf(f, "debug <int>    -- set kernel debugging mask\n");
	stream_printf(f, "step       -- advance to next MAL instruction\n");
	stream_printf(f, "modules    -- show module list\n");
	stream_printf(f, "module     -- display a module signatures\n");
	stream_printf(f, "atoms      -- show atom list\n");
	stream_printf(f, "finish     -- finish current call\n");
	stream_printf(f, "exit       -- terminate executionr\n");
	stream_printf(f, "quit       -- turn off debugging\n");
	stream_printf(f, "list <fcn> -- list current program block\n");
	stream_printf(f, "List <fcn> -- list with type information\n");
	stream_printf(f, "var  <fcn>  -- print symbol table for module\n");
	stream_printf(f, "optimizer <idx>  -- display program after optimizer step\n");
	stream_printf(f, "print <var>    -- display value of a variable\n");
	stream_printf(f, "print <var> <cnt>[<first>] -- display BAT chunk\n");
	stream_printf(f, "info <var>     -- display bat variable properties\n");
	stream_printf(f, "run        -- restart current procedure\n");
	stream_printf(f, "where      -- print stack trace\n");
	stream_printf(f, "down       -- go down the stack\n");
	stream_printf(f, "up         -- go up the stack\n");
	stream_printf(f, "timer {0,1}-- produce micro-second response time [default=0]\n");
	stream_printf(f, "trace <var>-- trace assignment to variables\n");
	stream_printf(f, "io         -- produce page activity trace \n");
	stream_printf(f, "flow       -- produce memory flow trace \n");
	stream_printf(f, "help       -- this message\n");
}

@+ Optimizer debugging
The modular approach to optimize a MAL program brings with it the
need to check individual steps. Two options come to mind. If in
debug mode we could stop after each optimizer action for inspection.
Alternatively, we keep a history of all MAL program versions for
aposteriori analysis.

The latter is implemented first.
@{
A global stack is used for simplity, later we may have to
make it thread safe by assigning it to a client record.
@c
int isInvariant(MalBlkPtr mb, int pcf, int pcl, int varid);

str
debugOptimizers(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	Client cntxt = MCgetClient();

	(void) stk;

	cntxt->debugOptimizer = cntxt->debugOptimizer ? FALSE : TRUE;
	if (pci)
		removeInstruction(mb, pci);
	return MAL_SUCCEED;
}

#define MAXSTEPS 64
struct {
	str title;
	int actions;
	lng usec;
	MalBlkPtr mb;
} optimizerHistory[MAXSTEPS];
static int optTop;

void
optimizerDebug(MalBlkPtr mb, str name, int actions, lng usec)
{
	if (optTop + 1 == MAXSTEPS){
		/* drop oldest */
		int i;
		if( optimizerHistory[0].title)
			GDKfree(optimizerHistory[0].title);
		if( optimizerHistory[0].mb)
			freeMalBlk(optimizerHistory[0].mb);
		for(i=0;i<optTop; i++){
		optimizerHistory[i].title = optimizerHistory[i+1].title;
		optimizerHistory[i].actions = optimizerHistory[i+1].actions;
		optimizerHistory[i].usec = optimizerHistory[i+1].usec;
		optimizerHistory[i].mb = optimizerHistory[i+1].mb;
		}
		optTop--;
	}
	optimizerHistory[optTop].title = GDKstrdup(name);
	optimizerHistory[optTop].actions = actions;
	optimizerHistory[optTop].usec = usec;
	if( actions)
		optimizerHistory[optTop].mb = copyMalBlk(mb);
	optTop++;
}

void
resetOptimizerDebugger()
{
	int i;

	if (optTop) {
		/* garbage collect */
		for (i = 0; i < optTop; i++) {
			freeMalBlk(optimizerHistory[i].mb);
			GDKfree(optimizerHistory[i].title);
		}
	}
	optTop = 0;
}

void
showOptimizerStep(str fnme, int i, int flg)
{
	stream *out;
	if( fnme == 0 || *fnme== 0)
		out= GDKout;
	else {
		out= open_wastream(fnme);
		if( out == NULL){
			stream_printf(GDKout,"Could not create file '%s'\n",fnme);
			return;
		}
		stream_printf(GDKout,"Result saved on '%s'\n",fnme);
	}
	if (i < optTop && optimizerHistory[i].mb) {
		stream_printf(out, "#result after %s\n", optimizerHistory[i].title);
		printFunction(out, optimizerHistory[i].mb, flg);
		if(fnme) stream_close(out);
	}
}
void
showOptimizerHistory()
{
	int i;
	stream *fd = GDKout;

	for (i = 0; i < optTop; i++)
		if( optimizerHistory[i].mb)
			stream_printf(fd, "[%d] %s  %s.%s\tactions=%2d time " LLFMT " usec\n",
				i, optimizerHistory[i].title,
				getModuleId(getInstrPtr(optimizerHistory[i].mb,0)),
				getFunctionId(getInstrPtr(optimizerHistory[i].mb,0)),
				optimizerHistory[i].actions, 
				optimizerHistory[i].usec);
		else
			stream_printf(fd, "[%d] %s  \t\tactions=%2d time " LLFMT " usec\n",
				i, optimizerHistory[i].title,
				optimizerHistory[i].actions, 
				optimizerHistory[i].usec);
}

@}
