@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
@' Copyright August 2008-2009 MonetDB B.V.
@' All Rights Reserved.

@f mal_sabaoth
@a Fabian Groffen
@+ Cluster support
The cluster facilitation currently only deals with (de-)registering of
services offered by the local server to other servers.
The name of this module is inspired by the Armada setting of anchient
times and origanisational structures.  Sabaoth, stands for ``Lord of
Hosts'' in an army setting as found in the Bible's New Testament.  This
module allows an army of Mservers to be aware of each other on a local
machine and redirect to each other when necessary.
@- Implementation

@h

#ifndef _MAL_SABAOTH_DEF
#define _MAL_SABAOTH_DEF

#include <mal.h>
#include <mal_exception.h>
@-

@c
@{
#include "mal_config.h"
#include "mal_sabaoth.h"
#include <stdio.h> /* fseek, rewind */
#include <unistd.h>	/* unlink and friends */
#include <sys/types.h>
#include <sys/stat.h>
#include <errno.h>
#include <string.h> /* for getting error messages */
#include <assert.h>

#if defined(_MSC_VER) && _MSC_VER >= 1400
#define close _close
#endif

/** the directory where the databases are (aka dbfarm) */
str _sabaoth_internal_dbfarm = NULL;
/** the database which is "active" */
str _sabaoth_internal_dbname = NULL;

static str getFarmPath(str *ret, size_t size, str extra) {
	if (_sabaoth_internal_dbfarm == NULL)
		throw(MAL, "sabaoth.assert", SABAOTH_NOT_INITIALIZED);

	if (extra == NULL) {
		snprintf(*ret, size, "%s", _sabaoth_internal_dbfarm);
	} else {
		snprintf(*ret, size, "%s%c%s", _sabaoth_internal_dbfarm, DIR_SEP, extra);
	}

	return(MAL_SUCCEED);
}

static str getDBPath(str *ret, size_t size, str extra) {
	if (_sabaoth_internal_dbfarm == NULL)
		throw(MAL, "sabaoth.assert", SABAOTH_NOT_INITIALIZED);
	if (_sabaoth_internal_dbname == NULL)
		throw(MAL, "sabaoth.assert", SABAOTH_USE_RESTRICTION);

	if (extra == NULL) {
		snprintf(*ret, size, "%s%c%s",
				_sabaoth_internal_dbfarm,
				DIR_SEP,
				_sabaoth_internal_dbname);
	} else {
		snprintf(*ret, size, "%s%c%s%c%s",
				_sabaoth_internal_dbfarm,
				DIR_SEP,
				_sabaoth_internal_dbname,
				DIR_SEP,
				extra);
	}

	return(MAL_SUCCEED);
}

@h
mal_export void SABAOTHinit(str dbfarm, str dbname);
@c
/**
 * Initialises this Sabaoth instance to use the given dbfarm and dbname.
 * dbname may be NULL to indicate that there is no active database.  The
 * arguments are copied for internal use.
 */
void SABAOTHinit(str dbfarm, str dbname) {
	size_t len;

	assert(dbfarm != NULL);

	if (_sabaoth_internal_dbfarm != NULL)
		GDKfree(_sabaoth_internal_dbfarm);
	if (_sabaoth_internal_dbname != NULL)
		GDKfree(_sabaoth_internal_dbname);

	len = strlen(dbfarm);
	_sabaoth_internal_dbfarm = GDKstrdup(dbfarm);
	/* remove trailing slashes, newlines and spaces */
	len--;
	while (len > 0 && (
				_sabaoth_internal_dbfarm[len] == '/' ||
				_sabaoth_internal_dbfarm[len] == '\n' ||
				_sabaoth_internal_dbfarm[len] == ' '))
	{
		_sabaoth_internal_dbfarm[len] = '\0';
		len--;
	}

	if (dbname == NULL) {
		_sabaoth_internal_dbname = NULL;
	} else {
		_sabaoth_internal_dbname = GDKstrdup(dbname);
	}
}

@h
mal_export str SABAOTHmarchScenario(int *ret, str *lang);
@c
#define SCENARIOFILE ".scen"
/**
 * Writes the given language to the scenarios file.  If the file doesn't
 * exist, it is created.  Multiple invocations of this function for the
 * same language are ignored.
 */
str SABAOTHmarchScenario(int *ret, str *lang) {
	FILE *f;
	str buf = alloca(sizeof(char) * 256);	/* should be enough for now */
	size_t len;
	str path = alloca(sizeof(char) * (PATHLENGTH + 1));
	str tmp;
	(void)ret;

	rethrow("sabaoth.marchScenario", tmp,
			getDBPath(&path, PATHLENGTH, SCENARIOFILE));
	if ((f = fopen(path, "a+")) != NULL) {
		if ((len = fread(buf, 1, 255, f)) > 0) {
			str p;

			buf[len] = '\0';
			/* find newlines and evaluate string */
			while ((p = strchr(buf, '\n')) != NULL) {
				*p = '\0';
				if (strcmp(buf, *lang) == 0) {
					(void)fclose(f);
					return(MAL_SUCCEED);
				}
				buf = p;
			}
		}
		/* append to the file */
		fprintf(f, "%s\n", *lang);
		(void)fflush(f);
		(void)fclose(f);
		return(MAL_SUCCEED);
	}
	throw(IO, "sabaoth.marchScenario", RUNTIME_FILE_NOT_FOUND, path);
}

@h
mal_export str SABAOTHretreatScenario(int *ret, str *lang);
@c
/**
 * Removes the given language from the scenarios file.  If the scenarios
 * file is empty (before or) after removing the language, the file is
 * removed.
 */
str SABAOTHretreatScenario(int *ret, str *lang) {
	FILE *f;
	str buf = alloca(sizeof(char) * 256);	/* should be enough for now */
	size_t len;
	str path = alloca(sizeof(char) * (PATHLENGTH + 1));
	str tmp;
	(void)ret;

	rethrow("sabaoth.retreatScenario", tmp,
			getDBPath(&path, PATHLENGTH, SCENARIOFILE));
	if ((f = fopen(path, "a+")) != NULL) {
		if ((len = fread(buf, 1, 255, f)) > 0) {
			str p;
			FILE *tmp = tmpfile();
			int written = 0;

			buf[len] = '\0';
			/* find newlines and evaluate string */
			while ((p = strchr(buf, '\n')) != NULL) {
				*p = '\0';
				if (strcmp(buf, *lang) != 0) {
					fprintf(tmp, "%s\n", buf);
					written = 1;
				}
				buf = p;
			}
			if (written != 0) {
				buf = alloca(sizeof(char) * 256);
				/* no idea how to "move" a file by it's fd (sounds
				 * impossible anyway) and tmpnam is so much "DO NOT USE"
				 * that I decided to just copy over the file again... */
				rewind(f);
				fflush(tmp);
				rewind(tmp);
				len = fread(buf, 1, 256, tmp);
				if (fwrite(buf, 1, len, f) < len)
					throw(IO, "sabaoth.retreatScenario", RUNTIME_STREAM_WRITE);
				fflush(f);
				fclose(f);
				fclose(tmp); /* this should remove it automagically */
				return(MAL_SUCCEED);
			} else {
				(void)fclose(f);
				unlink(path);
				return(MAL_SUCCEED);
			}
		} else if (len == 0) {
			(void)fclose(f);
			unlink(path);
			return(MAL_SUCCEED);
		} else { /* some error */
			str err = strerror(errno);
			(void)fclose(f);
			throw(IO, "sabaoth.retreatScenario", RUNTIME_STREAM_WRITE " %s",err);
		}
	}
	throw(IO, "sabaoth.retreatScenario", RUNTIME_FILE_NOT_FOUND, path);
}

@h
mal_export str SABAOTHmarchConnection(int *ret, str *host, int *port);
@c
#define CONNECTIONFILE ".conn"
/**
 * Writes an URI to the connection file based on the given arguments.
 * If the file doesn't exist, it is created.  Multiple invocations of
 * this function for the same arguments are NOT ignored.
 */
str SABAOTHmarchConnection(int *ret, str *host, int *port) {
	FILE *f;
	str path = alloca(sizeof(char) * (PATHLENGTH + 1));
	str tmp;
	sabdb *stats;

	(void)ret;

	rethrow("sabaoth.marchConnection", tmp,
			getDBPath(&path, PATHLENGTH, CONNECTIONFILE));
	if ((f = fopen(path, "a")) != NULL) {
		/* append to the file */
		fprintf(f, "mapi:monetdb://%s:%i/\n", *host, *port);
		(void)fflush(f);
		(void)fclose(f);
		/* (some) people tend to like (very) noisy programs, hence to
		 * please them, announce that we're now available from outside */
		printf("# Listening for connection requests on "
				"mapi:monetdb://%s:%i/\n", *host, *port);
		/* emit a warning if we are in maintenance mode */
		rethrow("sabaoth.getMyStatus", tmp,
				SABAOTHgetMyStatus(&stats));
		if (stats->locked == 1)
			fprintf(stderr, "#warning: database is running in "
					"maintenance mode\n");
		SABAOTHfreeStatus(&stats);
		return(MAL_SUCCEED);
	}
	throw(IO, "sabaoth.marchConnection", RUNTIME_FILE_NOT_FOUND, path);
}

@h
mal_export str SABAOTHgetLocalConnection(str *ret);
@c
/**
 * Returns the connection string for the current database, or nil when
 * there is none.  If there are multiple connections defined, only the
 * first is returned.
 */
str SABAOTHgetLocalConnection(str *ret) {
	FILE *f;
	str path = alloca(sizeof(char) * (PATHLENGTH + 1));
	char data[8096];
	str tmp;

	rethrow("sabaoth.getLocalConnection", tmp,
			getDBPath(&path, PATHLENGTH, CONNECTIONFILE));

	data[8095] = '\0';
	if ((f = fopen(path, "r")) != NULL) {
		if (fgets(data, 8095, f) != NULL) {
			if (*data != '\0' && data[strlen(data) - 1] == '\n')
				data[strlen(data) - 1] = '\0';
			*ret = GDKstrdup(data);
			(void)fclose(f);
			return(MAL_SUCCEED);
		}
		(void)fclose(f);
	}

	*ret = GDKstrdup(str_nil);
	return(MAL_SUCCEED);
}

@h
mal_export str SABAOTHwildRetreat(int *ret);
@c
/**
 * Removes all known publications of available services.  The function
 * name is a nostalgic phrase from "Defender of the Crown" from the
 * Commodore Amiga age.
 */
str SABAOTHwildRetreat(int *ret) {
	str path = alloca(sizeof(char) * (PATHLENGTH + 1));
	str tmp;
	(void)ret;

	rethrow("sabaoth.wildRetreat", tmp,
			getDBPath(&path, PATHLENGTH, SCENARIOFILE));
	unlink(path);
	rethrow("sabaoth.wildRetreat", tmp,
			getDBPath(&path, PATHLENGTH, CONNECTIONFILE));
	unlink(path);

	return(MAL_SUCCEED);
}

@h
mal_export str SABAOTHregisterStart(int *ret);
@c
#define UPLOGFILE ".uplog"
/**
 * Writes a start attempt to the sabaoth start/stop log.  Examination of
 * the log at a later stage might reveal crashes of the server.
 */
str SABAOTHregisterStart(int *ret) {
	/* The sabaoth uplog is in fact a simple two column table that
	 * contains a start time and a stop time.  Start times are followed
	 * by a tab character, while stop times are followed by a newline.
	 * This allows to detect crashes, while sabaoth only appends to the
	 * uplog.
	 */

	FILE *f;
	str path = alloca(sizeof(char) * (PATHLENGTH + 1));
	str tmp;
	(void)ret;

	rethrow("sabaoth.registerStart", tmp,
			getDBPath(&path, PATHLENGTH, UPLOGFILE));
	if ((f = fopen(path, "a")) != NULL) {
		/* append to the file */
		fprintf(f, LLFMT "\t", (lng)time(NULL));
		(void)fflush(f);
		(void)fclose(f);
		return(MAL_SUCCEED);
	}
	throw(IO, "sabaoth.registerStart", RUNTIME_FILE_NOT_FOUND, path);
}

@h
mal_export str SABAOTHregisterStop(int *ret);
@c
/**
 * Writes a start attempt to the sabaoth start/stop log.  Examination of
 * the log at a later stage might reveal crashes of the server.
 */
str SABAOTHregisterStop(int *ret) {
	/* The sabaoth uplog is in fact a simple two column table that
	 * contains a start time and a stop time.  Start times are followed
	 * by a tab character, while stop times are followed by a newline.
	 * This allows to detect crashes, while sabaoth only appends to the
	 * uplog.
	 */

	FILE *f;
	str path = alloca(sizeof(char) * (PATHLENGTH + 1));
	str tmp;
	(void)ret;

	rethrow("sabaoth.registerStop", tmp,
			getDBPath(&path, PATHLENGTH, UPLOGFILE));
	if ((f = fopen(path, "a")) != NULL) {
		/* append to the file */
		fprintf(f, LLFMT "\n", (lng)time(NULL));
		(void)fflush(f);
		(void)fclose(f);
		return(MAL_SUCCEED);
	}
	throw(IO, "sabaoth.registerStop", RUNTIME_FILE_NOT_FOUND, path);
}

@h

typedef struct Ssablist {
	str val;                 /* list value */
	struct Ssablist* next;   /* pointer to the next available value*/
} sablist;

typedef enum {
	SABdbIllegal = 0,
	SABdbRunning,
	SABdbCrashed,
	SABdbInactive
} SABdbState;

typedef struct Ssabdb {
	str dbname;              /* database name */
	str path;                /* full path to database */
	int locked;              /* whether this database is under maintenance */
	SABdbState state;        /* current database state */
	sablist* scens;          /* scenarios available for this database */
	sablist* conns;          /* connections available for this database */
	struct Ssabdb* next;     /* next database */
} sabdb;

mal_export str SABAOTHgetMyStatus(sabdb** ret);
@c
/**
 * Returns the status as NULL terminated sabdb struct list for the
 * current database.  Since the current database should always exist,
 * this function never returns NULL.
 */
str SABAOTHgetMyStatus(sabdb** ret) {
	str err;
	if (_sabaoth_internal_dbname == NULL)
		throw(MAL, "sabaoth.assert", SABAOTH_USE_RESTRICTION);
	err = SABAOTHgetStatus(ret, _sabaoth_internal_dbname);
	if (err != NULL)
		return(err);
	if (*ret == NULL)
		throw(MAL, "sabaoth.assert", SABAOTH_SEARCH_FAILED "%s", _sabaoth_internal_dbname);
	return(MAL_SUCCEED);
}

@h
/* Caching strategies (might be nice) should create a new struct with
 * the last modified time_t of the files involved, such that a stat is
 * sufficient to see if reparsing is necessary.  The gdk_lock always has
 * to be checked to detect crashes.
 */

mal_export str SABAOTHgetStatus(sabdb** ret, str dbname);
#define MAINTENANCEFILE ".maintenance"
@c
/**
 * Returns a list of populated sabdb structs.  If dbname == NULL, the
 * list contains sabdb structs for all found databases in the dbfarm.
 * Otherwise, at most one sabdb struct is returned for the database from
 * the dbfarm that matches dbname.
 * If no database could be found, an empty list is returned.  Each list
 * is terminated by a NULL entry.
 */
str SABAOTHgetStatus(sabdb** ret, str dbname) {
	DIR *d;
	struct dirent *e;
	str buf = alloca(sizeof(char) * (PATHLENGTH + 1));
	str data = alloca(sizeof(char) * 8096);
	str path = alloca(sizeof(char) * (PATHLENGTH + 1));
	str p;
	FILE *f;
	int fd;
	struct stat statbuf;

	sabdb *sdb, *top;
	sdb = top = *ret = NULL;

	buf[PATHLENGTH] = '\0';
	/* scan the parent for directories */
	rethrow("sabaoth.getStatus", p,
			getFarmPath(&path, PATHLENGTH, NULL));
	d = opendir(path);
	if (d == NULL)
		throw(IO, "sabaoth.getStatus", RUNTIME_DIR_ERROR " %s: %s",
				path, strerror(errno));
	while ((e = readdir(d)) != NULL) {
		if (dbname != NULL && strcmp(e->d_name, dbname) != 0)
			continue;
		if (strcmp(e->d_name, "..") == 0 || strcmp(e->d_name, ".") == 0)
			continue;

		snprintf(buf, PATHLENGTH, "%s/%s/%s", path, e->d_name, UPLOGFILE);
		if (stat(buf, &statbuf) == -1)
			continue;

		if (sdb == NULL) {
			top = sdb = GDKmalloc(sizeof(sabdb));
		} else {
			sdb = sdb->next = GDKmalloc(sizeof(sabdb));
		}
		sdb->next = NULL;

		/* store the database name */
		snprintf(buf, PATHLENGTH, "%s/%s", path, e->d_name);
		sdb->path = GDKstrdup(buf);
		sdb->dbname = sdb->path + strlen(sdb->path) - strlen(e->d_name);

		/* add scenarios that are supported */
		sdb->scens = NULL;
		snprintf(buf, PATHLENGTH, "%s/%s/%s", path, e->d_name, SCENARIOFILE);
		if ((f = fopen(buf, "r")) != NULL) {
			sablist* np = NULL;
			while (fgets(data, 8095, f) != NULL) {
				if (*data != '\0' && data[strlen(data) - 1] == '\n')
					data[strlen(data) - 1] = '\0';
				if (sdb->scens == NULL) {
					sdb->scens = GDKmalloc(sizeof(sablist));
					sdb->scens->val = GDKstrdup(data);
					sdb->scens->next = NULL;
					np = sdb->scens;
				} else {
					np = np->next = GDKmalloc(sizeof(sablist));
					np->val = GDKstrdup(data);
					np->next = NULL;
				}
			}
			(void)fclose(f);
		}

		/* add how this server can be reached */
		sdb->conns = NULL;
		snprintf(buf, PATHLENGTH, "%s/%s/%s", path, e->d_name, CONNECTIONFILE);
		if ((f = fopen(buf, "r")) != NULL) {
			sablist* np = NULL;
			while (fgets(data, 8095, f) != NULL) {
				if (*data != '\0' && data[strlen(data) - 1] == '\n')
					data[strlen(data) - 1] = '\0';
				if (sdb->conns == NULL) {
					sdb->conns = GDKmalloc(sizeof(sablist));
					sdb->conns->val = GDKstrdup(data);
					sdb->conns->next = NULL;
					np = sdb->conns;
				} else {
					np = np->next = GDKmalloc(sizeof(sablist));
					np->val = GDKstrdup(data);
					np->next = NULL;
				}
			}
			(void)fclose(f);
		}

		/* check the state of the server by looking at its gdk lock:
		 * - if we can lock it, the server has crashed or isn't running
		 * - if we can't open it because it's locked, the server is
		 *   running
		 * - to distinguish between a crash and proper shutdown, consult
		 *   the uplog
		 */
		snprintf(buf, PATHLENGTH, "%s/%s/%s", path, e->d_name, ".gdk_lock");
		if (_sabaoth_internal_dbname != NULL &&
				strcmp(_sabaoth_internal_dbname, e->d_name) == 0)
		{
			/* if we are the mserver that is running this database,
			 * don't touch the lock! */
			sdb->state = SABdbRunning;
		} else if ((fd = MT_lockf(buf, F_TLOCK, 4, 1)) == -2) {
			/* Locking failed; this can be because the lockfile couldn't
			 * be created.  Probably there is no Mserver running for
			 * that case also.
			 */
			sdb->state = SABdbInactive;
		} else if (fd == -1) {
			/* lock denied, so Mserver is running */
			sdb->state = SABdbRunning;
		} else {
			char *log = alloca(sizeof(char) * (PATHLENGTH + 1));
			log[PATHLENGTH] = '\0';

			/* locking succeed, check for a crash in the uplog */
			snprintf(log, PATHLENGTH, "%s/%s/%s", path, e->d_name, UPLOGFILE);
			if ((f = fopen(log, "r")) != NULL) {
				(void)fseek(f, -1, SEEK_END);
				if (fread(data, 1, 1, f) != 1) {
					/* the log is corrupt/wrong, assume no crash */
					sdb->state = SABdbInactive;
				} else if (data[0] == '\n') {
					sdb->state = SABdbInactive;
				} else { /* should be \t */
					sdb->state = SABdbCrashed;
				}
				(void)fclose(f);
			} else {
				/* no uplog file? assume no crash */
				sdb->state = SABdbInactive;
			}

			/* release the lock */
			close(fd);
		}
		snprintf(buf, PATHLENGTH, "%s/%s/%s", path, e->d_name, MAINTENANCEFILE);
		f = fopen(buf, "r");
		if (f != NULL) {
			(void)fclose(f);
			sdb->locked = 1;
		} else {
			sdb->locked = 0;
		}
	}
	(void)closedir(d);

	*ret = top;
	return(MAL_SUCCEED);
}

@h
mal_export str SABAOTHfreeStatus(sabdb** ret);
@c
/**
 * Frees up the sabdb structure returned by getStatus.
 */
str SABAOTHfreeStatus(sabdb** ret) {
	sabdb *p, *q;
	sablist *r, *s;

	if (*ret == NULL)
		return(MAL_SUCCEED);

	p = *ret;
	while (p != NULL) {
		if (p->path != NULL)
			GDKfree(p->path);
		r = p->scens;
		while (r != NULL) {
			if (r->val != NULL)
				GDKfree(r->val);
			s = r->next;
			GDKfree(r);
			r = s;
		}
		r = p->conns;
		while (r != NULL) {
			if (r->val != NULL)
				GDKfree(r->val);
			s = r->next;
			GDKfree(r);
			r = s;
		}
		q = p->next;
		GDKfree(p);
		p = q;
	}

	return(MAL_SUCCEED);
}

@h
typedef struct Ssabuplog {
	int startcntr;     /* the number of start attempts */
	int stopcntr;      /* the number of successful stop attempts */
	int crashcntr;     /* startcntr - stopcntr (for convenience) */
	time_t avguptime;  /* number of seconds up when not crashing */
	time_t maxuptime;  /* longest uptime when not crashing */
	time_t minuptime;  /* shortest uptime when not crashing */
	time_t lastcrash;  /* time of last crash, -1 if none */
	time_t laststart;  /* time of last start */
	int crashavg1;     /* if there was a crash in the last start attempt */
	double crashavg10; /* average of crashes in the last 10 start attempts */
	double crashavg30; /* average of crashes in the last 30 start attempts */
} sabuplog;

mal_export str SABAOTHgetUplogInfo(sabuplog *ret, sabdb *db);
@c
/**
 * Parses the .uplog file for the given database, and fills ret with the
 * parsed information.
 */
str SABAOTHgetUplogInfo(sabuplog *ret, sabdb *db) {
	str path = alloca(sizeof(char) * (PATHLENGTH + 1));
	str log = alloca(sizeof(char) * (PATHLENGTH + 1));
	str tmp;
	char data[24];
	char *p;
	DIR *d;
	struct dirent *e;
	FILE *f;
	time_t start, stop, up;
	int avg10[10];
	int avg30[30];
	int i=0;

	memset(avg10, 0, sizeof(int) * 10);
	memset(avg30, 0, sizeof(int) * 30);

	/* clear the struct */
	memset(ret, 0, sizeof(sabuplog));
	ret->minuptime = -1;
	ret->lastcrash = -1;

	/* scan the parent for directories */
	rethrow("sabaoth.getStatus", tmp,
			getFarmPath(&path, PATHLENGTH, NULL));
	d = opendir(path);
	if (d == NULL)
		throw(IO, "sabaoth.getUplogInfo", RUNTIME_DIR_ERROR " %s: %s",
				path, strerror(errno));
	while ((e = readdir(d)) != NULL) {
		if (strcmp(e->d_name, db->dbname) != 0)
			continue;

		snprintf(log, PATHLENGTH, "%s/%s/%s", path, e->d_name, UPLOGFILE);
		log[PATHLENGTH] = '\0';
		if ((f = fopen(log, "r")) != NULL) {
			int c;
			start = stop = up = 0;
			p = data;
			while ((c = (char)fgetc(f)) != EOF) {
				*p = (char)c;
				switch (*p) {
					case '\t':
						/* start attempt */
						ret->startcntr++;
						if (start != 0)
							ret->lastcrash = start;
						memmove(&avg10[0], &avg10[1], sizeof(int) * 9);
						memmove(&avg30[0], &avg30[1], sizeof(int) * 29);
						avg10[9] = avg30[29] = ret->crashavg1 = 
							(start != 0 ? 1 : 0);
						*p = '\0';
						ret->laststart = start = (time_t)atol(data);
						p = data;
					break;
					case '\n':
						/* successful stop */
						ret->stopcntr++;
						*p = '\0';
						stop = (time_t)atol(data);
						p = data;
						i = (int) (stop - start);
						if (i > ret->maxuptime)
							ret->maxuptime = i;
						if (ret->minuptime == -1 || ret->minuptime > stop - start)
							ret->minuptime = stop - start;
						up += i;
						start = 0;
					break;
					default:
						/* timestamp */
						p++;
					break;
				}
			}
			if (start != 0 && db->state != SABdbRunning)
				ret->lastcrash = start;
			memmove(&avg10[0], &avg10[1], sizeof(int) * 9);
			memmove(&avg30[0], &avg30[1], sizeof(int) * 29);
			avg10[9] = avg30[29] = ret->crashavg1 =
				(start != 0 ? (db->state != SABdbRunning ? 1 : 0) : 0);
			ret->crashcntr =
				ret->startcntr - (db->state == SABdbRunning ? 1 : 0) -
				ret->stopcntr;
			for (i = 0; i < 10; i++)
				ret->crashavg10 += avg10[i];
			ret->crashavg10 = ret->crashavg10 / 10.0;
			for (i = 0; i < 30; i++)
				ret->crashavg30 += avg30[i];
			ret->crashavg30 = ret->crashavg30 / 30.0;

			if (ret->stopcntr > 0) {
				ret->avguptime = (time_t)(((double)up / (double)ret->stopcntr) + 0.5);
			} else {
				ret->avguptime = 0;
				ret->minuptime = 0;
				ret->maxuptime = 0;
			}
			(void)fclose(f);
		} else {
			(void)closedir(d);
			throw(IO, "sabaoth.getUplogInfo", RUNTIME_FILE_NOT_FOUND " %s: %s",
					log, strerror(errno));
		}

		break;
	}
	(void)closedir(d);

	return(MAL_SUCCEED);
}
@}

@h
#endif
