@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2006 CWI.
@' All Rights Reserved.

@f mal_exception
@a F. Groffen, M. Kersten
@v 1.0

@+ Exception handling
MAL comes with an exception handling mechanism, similar in style
as found in modern programming languages.
Exceptions are considered rare situations that alter
the flow of control to a place where they can be handled.
After the exceptional case has been handled the following options exist
a) continue where it went wrong, b) retry the failed instruction,
c) leave the block where the exception was handled,
or d) pass the exception to an enclosing call.
The current implementation of the MAL interpreter only supports c) and d).

@- Exception control
The exception handling keywords are: @code{catch} and @code{raise}
The @code{catch}  marks a point in the dataflow where
an exception raised can be dealt with. Any statement between the
point where it is raised and the catch block is ignored.
Moreover, the @code{ catch} ... @code{ exit} block is ignored when
no errors have occurred in the preceeding dataflow structure.
Within the catch block, the exception variable can be manipulated
without constraints.

An exception message is linked with a exception variable of
type string. If this variable is defined in the receiving block,
the exception message can be delivered. Otherwise, it
implicitly raises the exception in the surrounding scope.

After an exception has been dealt with the catch block can be left
at the normal @code{exit} with the option @code{leave} or
continue after the failed instruction using a @code{redo}.
The latter case assumes the catched code block has been able to provide
an alternative for the failed instruction.

Both @code{leave} and @code{redo} are conditional flow of control modifiers,
which trigger on a non-empty string variable.
An exception raised within a catch-block terminates
the function and returns control to the enclosing environment.

The argument to the catch statement is a target list,
which holds the exception variables you are interested in.

The snippet below illustrates how an exception raised
in the function @code{io.read} is catched using the exception variable IOerror.
After dealing with it locally, it raises a new exception @code{ FATALerror}
for the enclosing call.

@example
	io.write("Welcome");
	...
catch IOerror:str;
	print("input error on reading password");
raise FATALerror:= "Can't handle it";
exit IOerror;
@end example

Since @code{catch} is a flow control modifier it can be attached to any
assignment statement. This statement is executed whenever there is no
exception outstanding, but will be ignored when control is moved
to the block otherwise.

@- Builtin exceptions 
The policy implemented in the MAL modules, and recognized by
the interpreter, is to return a string value by default.
A NULL return value indicates succesful execution; otherwise
the string encodes information to analyse the error occurred.

This string pattern is strictly formatted and easy to analyse.
It starts with the name of the exception variable to
be set, followed by an indication where the exception was
raise, i.e. the function name and the program counter,
and concludes with specific information needed to interpret 
and handle the exception.

For example, the exception string 
@code{ 'MALexception:Admin.main[2]:address of function missing'}
denotes an exception raised while typechecking a MAL program.

The exceptions captured within the kernel are marked as 'GDKerror'.
At that level there is no knowledge about the MAL context, which
makes interpretation difficult for the average programmer.
Exceptions in the MAL language layer are denoted by 'MALerror',
and query language exceptiosn fall in their own class, e.g. 'SQLerror'.
Exceptions can be cascaded to form a trail of exceptions recognized
during the exection.

@{
@f mal_errors
@+ Error Handling
Internationalization and consistent error reporting is helped by a
central place of all kernel error messages. 
They are split into @code{fatal}, code{errors} and @code{warnings}.
The second category is the system component in which it is raised.

The first attempt: grep on src/MAL module.

@-
@f mal_exception
@h
#ifndef _MAL_EXCEPTION_H
#define _MAL_EXCEPTION_H
#include "mal_instruction.h"

/* These are the exceptions known, adding new ones here requires to also
 * add the "full" name to the exceptionNames array below */
enum exception {
	MAL=0,
	ILLARG,
	OUTOFBNDS,
	IO,
	INVCRED,
	ASSERT,
	STKOF,
	SYNTAX,
	TYPE,
	LOADER,
	PARSE,
	ARITH,
	PERMD,
	SQL
};

#define MAL_SUCCEED ((str) 0) /* no error */

#define throw \
	return createException
#define rethrow(FCN, TMP, PRV) \
	if ((TMP = PRV) != MAL_SUCCEED) return(TMP);

mal_export str	createException(enum exception, str, str, ...);
mal_export str	createScriptException(MalBlkPtr, int, enum exception, str, str, ...);
mal_export enum exception	getExceptionType(str);
mal_export str	getExceptionPlace(str);
mal_export str	getExceptionMessage(str);
mal_export str	exceptionToString(enum exception);

#endif /*  _MAL_EXCEPTION_H*/

@-
@c
#include "mal_exception.h"

static char *exceptionNames[] = {
/* 0 */	"MALException",
/* 1 */	"IllegalArgumentException",
/* 2 */	"OutOfBoundsException",
/* 3 */	"IOException",
/* 4 */	"InvalidCredentialsException",
/* 5 */	"AssertionException",
/* 6 */	"StackOverflowException",
/* 7 */	"SyntaxException",
/* 8 */	"TypeException",
/* 9 */	"LoaderException",
/*10 */	"ParseException",
/*11 */	"ArithmeticException",
/*12 */	"PermissionDeniedException",
/*13 */	"SQLException",
/*EOE*/	NULL
};

@-
The linked libraries should use the throwException to signal
an erroneous situation.
@c
/**
 * Returns an exception string for the given type of exception, function
 * and additional formatting parameters.  This function will crash the
 * system or return bogus when the exception enum is not aligned with
 * the exceptionNames array.
 */
str
createException(enum exception type, str fcn, str format, ...)
{
	char message[GDKMAXERRLEN];
	int len;
	va_list ap;

	len = snprintf(message, GDKMAXERRLEN - 1, "%s:%s:",
			exceptionNames[type], fcn);
	va_start(ap, format);
	len += vsnprintf(message + len, GDKMAXERRLEN - 1 - len, format, ap);
	va_end(ap);
	message[len] = '\0';

	return(GDKstrdup(message));
}

/**
 * Returns an exception string for the use of MAL scripts.  These
 * exceptions are newline terminated, and determine module and function
 * from the given MalBlkPtr.  An old exception can be given, such that
 * this exception is chained to the previous one.  Conceptually this is
 * a complete horror and I hope it's not used in new code, as that
 * clearly indicates a(nother) design error.
 * This function will crash the system or return bogus when the
 * exception enum is not aligned with the exceptionNames array.
 */
str
createScriptException(MalBlkPtr mb, int pc, enum exception type, str prev, str format, ...)
{
	char buf[GDKMAXERRLEN];
	size_t i;
	str s, fcn;
	va_list ap;

	s = mb ? getModName(mb) : "unknown";
	fcn = mb ? getFcnName(mb) : "unknown";
	i = 0;

	if (prev)
		i += snprintf(buf + i, GDKMAXERRLEN - 1 - i, "%s", prev);
	i += snprintf(buf + i, GDKMAXERRLEN - 1 - i, "%s:%s.%s[%d]:",
			exceptionNames[type], s, fcn, pc);
	va_start(ap, format);
	i += vsnprintf(buf + i, GDKMAXERRLEN - 1 - i, format, ap);
	va_end(ap);
	buf[i] = '\0';

	if (buf[i - 1] != '\n' && i < GDKMAXERRLEN - 1) {
		buf[i] = '\n';
		buf[i + 1] = '\0';
	}

	return GDKstrdup(buf);
}

/**
 * Returns the exception number for the given exception string.  If no
 * exception could be found in the string, MAL is returned indicating a
 * generic MALException.
 */
enum exception
getExceptionType(str exception)
{
	enum exception ret = MAL;
	str s;
	int i;

	if ((s = strchr(exception, ':')) != NULL)
		*s = '\0';

	for (i = 0; exceptionNames[i] != NULL; i++) {
		if (strcmp(exceptionNames[i], exception) == 0) {
			ret = i;
			break;
		}
	}

	/* restore original string */
	if (s != NULL)
		*s = ':';

	return(ret);
}

/**
 * Returns the location the exception was raised, if known.  It depends
 * on the how the exception was created, what the location looks like.
 * The returned string is mallocced with GDKmalloc, and hence needs to
 * be GDKfreed.
 */
str
getExceptionPlace(str exception)
{
	str ret;
	str s, t;

	if ((s = strchr(exception, ':')) != NULL &&
			(t = strchr(s + 1, ':')) != NULL)
	{
		*t = '\0';
		ret = GDKstrdup(s + 1);
		*t = ':';
		return(ret);
	} else {
		return(GDKstrdup("(unknown)"));
	}
}

/**
 * Returns the informational message of the exception given.
 */
str
getExceptionMessage(str exception)
{
	str s, t;

	if ((s = strchr(exception, ':')) != NULL) {
		/* skip the place, if there */
		if ((t = strchr(s + 1, ':')) != NULL)
			s = t;
		return(s + 1);
	} else {
		return(exception);
	}
}

/**
 * Returns the string representation of the given exception.  This is
 * the string as used when creating an exception of the same type.
 */
str
exceptionToString(enum exception e)
{
	return(exceptionNames[e]);
}

@}
