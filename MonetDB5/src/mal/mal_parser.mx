@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@' 
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@' 
@' The Original Code is the Monet Database System.

@a M. L. Kersten
@v 1.1

@-
@{
@+ The Parser Implementation
The parser (and its target language) are designed for speed of analysis.
For, parsing is a dominant cost-factor in applications interfering with
MonetDB. For the language design it meant that look-ahead and ambiguity
is avoided where-ever possible without compromising readability and
to ease debugging.

The syntax layout of a MAL program consists of a module name,
a list of include commands, a list of function/ pattern/ command/ factory
definitions and concludes with the statements to be executed as
the main body of the program.  All components are optional.

The program may be decorated with comments, which starts with a # and
runs till the end of the current line. Comments are retained
in the code block for debugging, but can be removed with an optimizer to reduce space
and interpretation overhead.

@+ The lexical analyzer
The implementation of the lexical analyzer is straightforward:
the input is taken from a client input buffer. It is assumed that
this buffer contains the complete MIL structure to be parsed.
@h
#ifndef _MAL_PARSER_H
#define _MAL_PARSER_H

#include "mal_import.h"

#define MAXERRORS 250

#define CURRENT(c) (c->fdin->buf + c->fdin->pos + c->yycur)
#define currChar(X) (*CURRENT(X))
#define peekChar(X) (*((X)->fdin->buf + (X)->fdin->pos + (X)->yycur+1))
#define nextChar(X) X->yycur++
#define prevChar(X) if(X->yycur) X->yycur--

mal_export void initParser();   /* needed in src/mal/mal.c */
mal_export int parseMAL(Client cntxt, Symbol curPrg);
mal_export void echoInput(Client cntxt);
mal_export void debugParser(int i);
mal_export str parseError(Client cntxt, str msg);
mal_export void advance(Client cntxt, int length);
mal_export void skipSpace(Client cntxt);
mal_export void skipToEnd(Client cntxt);
mal_export int idLength(Client cntxt);
mal_export str idCopy(Client cntxt, int len);
mal_export int cstLength(Client cntxt, int *type);
mal_export int stringLength(Client cntxt);
mal_export str charCst(Client cntxt);
mal_export int operatorLength(Client cntxt);
mal_export str operatorCopy(Client cntxt, int length);
mal_export int keyphrase1(Client cntxt, str kw);
mal_export int keyphrase2(Client cntxt, str kw);
mal_export int MALkeyword(Client cntxt, str kw, int length);
mal_export str lastline(Client cntxt);
mal_export long position(Client cntxt);

#endif /* _MAL_PARSER_H */

@- lexical utilities
Before a line is parsed we check for a request to echo it.
This command should be executed at the beginning of a parse
request and each time we encounter EOL.
@c
#include "mal_parser.h"
#include "mal_resolve.h"
#include "mal_linker.h"
#include "mal_atom.h"       /* for malAtomDefinition(), malAtomArray(), malAtomProperty() */
#include "mal_interpreter.h"    /* for showErrors() */
#include "mal_instruction.h"    /* for pushEndInstruction(), findVariableLength() */
#include "mal_namespace.h"

#define FATALINPUT MAXERRORS+1
#define NL(X) ((X)=='\n' || (X)=='\r')


void echoInput(Client cntxt)
{
	if (cntxt->listing & LIST_INPUT) { 
		char *c = CURRENT(cntxt); 
		stream_printf(cntxt->fdout,"#");
		while (*c && !NL(*c)) {
			stream_printf(cntxt->fdout, "%c", *c++);
		}

		stream_printf(cntxt->fdout, "\n");
		stream_flush(cntxt->fdout);
	}
}

INLINE void 
skipSpace(Client cntxt)
{
	char *s= &currChar(cntxt);
	for (;;) {
		switch (*s++) {
		case ' ':
		case '\t':
		case '\n':
		case '\r':
			nextChar(cntxt);
			break;
		default:
			return;
		}
	}
}

INLINE void 
advance(Client cntxt, int length)
{
	cntxt->yycur += length;
	skipSpace(cntxt);
}

@-
The most recurring situation is to recognize identifiers.
This process is split into a few steps to simplify subsequent
construction and comparison.
IdLength searches the end of an identifier without changing
the cursor into the input pool.
IdCopy subsequently prepares a GDK string for inclusion in the
instruction datastructures.

@c
short opCharacter[256];
short idCharacter[256];
short idCharacter2[256];

void 
initParser()
{
	int i;

	for (i = 0; i < 256; i++){
        idCharacter2[i]= isalpha(i) || isdigit(i);
		idCharacter[i] = isalpha(i);
    }
	for (i = 0; i < 256; i++)
	switch(i){
	case '-': case '!': case '\\': case '$': case '%':
	case '^': case '*': case '~': case '+': case '&':
	case '|': case '<': case '>': case '=': case '/':
	case ':': 
		opCharacter[i]=1; 
	}
	idCharacter['_']=1;
	idCharacter2['_']=1;
	idCharacter[TMPMARKER]=1;
	idCharacter2[TMPMARKER]=1;
}

#undef isdigit
#define isdigit(X)  ((X)>='0' && (X)<='9')

int 
idLength(Client cntxt)
{
	str s = CURRENT(cntxt),t=s;

	if (!idCharacter[(int) (*s)])
		return 0;
	s++;
	while (idCharacter2[(int) (*s)] ) 
		s++;
	return s-t;
}
@-
Simple type identifiers can not be marked with a type variable.
@c
int 
typeidLength(Client cntxt)
{
	int l;
	str s = CURRENT(cntxt);

	if (!idCharacter[(int) (*s)])
		return 0;
	l = 1;
	s++;
	idCharacter[TMPMARKER] = 0;
	while (idCharacter[(int) (*s)] || isdigit(*s)) {
		s++;
		l++;
	}
	idCharacter[TMPMARKER]=1;
	return l;
}
str idCopy(Client cntxt, int length){
	str s= GDKmalloc(length+1);
    memcpy(s, CURRENT(cntxt),(size_t) length);
	s[length]=0;
	advance(cntxt,length);
	return s;
}

int 
MALkeyword(Client cntxt, str kw, int length)
{
	int i;

	/* avoid double test or use lowercase only. */
	if (currChar(cntxt) == *kw &&
		strncmp(CURRENT(cntxt), kw, length) == 0 &&
		!idCharacter[(int) (CURRENT(cntxt)[length])] &&
		!isdigit((int) (CURRENT(cntxt)[length])) ) {
		advance(cntxt, length);
		return 1;
	}
	 /* check for captialized versions */
	for (i = 0; i < length; i++)
		if (tolower(CURRENT(cntxt)[i]) != kw[i])
			return 0;
	if (!idCharacter[(int) (CURRENT(cntxt)[length])] &&
		!isdigit((int) (CURRENT(cntxt)[length])) ) {
		advance(cntxt,length);
		return 1;
	}
	return 0;
}
@-
Keyphrase testing is limited to a few characters only
(check manually). To speed this up we use a pipelined and
inline macros.
@c
INLINE int 
keyphrase1(Client cntxt, str kw)
{
	if (currChar(cntxt) == *kw) {
		advance(cntxt,1);
		return 1;
	}
	return 0;
}

INLINE int 
keyphrase2(Client cntxt, str kw)
{
	if (CURRENT(cntxt)[0] == kw[0] && CURRENT(cntxt)[1] == kw[1]) {
		advance(cntxt,2);
		return 1;
	}
	return 0;
}
@-
A similar approach is used for string literals.
Beware, string lengths returned include the
brackets and escapes. They are eaten away in strCopy.
We should provide the C-method to split strings and
concatenate them upon retrieval[todo]
@c
int 
stringLength(Client cntxt)
{
	int l=0;
	int quote =0;
	str s = CURRENT(cntxt);

	if( *s != '"') 
		return 0;
	s++;
	while( *s ){
		if( quote ){ 
			l++; 
			s++;
			quote=0;
		} else {
			if( *s == '"' ) break;
			quote= *s == '\\';
			l++;
			s++;
		}
	}
	return l+2;
}
@-
Beware, the idcmp routine uses a short cast to compare multiple bytes
at once. This may cause problems when the net string length is zero.
@c
str strCopy(Client cntxt, int length){
	str s;
	int i= length-1;

	if( i-2 <sizeof(short)) 
		i = sizeof(short);
	s = GDKmalloc(i);
	*(short*)s = 0;
	if (s == 0) 
		GDKfatal("FATAL:strCopy:");
	memcpy(s, CURRENT(cntxt) + 1, (size_t) (length - 2) );
	s[length-2] = 0;
	advance(cntxt,length);
	return s;
}
@-
And a similar approach is used for operator names.
A lookup table is considered, because it generally is
faster then a non-dense switch.
@c
int 
operatorLength(Client cntxt)
{
	int l=0;
	str s;

	for (s = CURRENT(cntxt); *s; s++) {
		if( opCharacter[(int)(*s)] ) 
			l++; 
		else 
			return l;
	}
	return l;
}

str 
operatorCopy(Client cntxt, int length)
{
	return idCopy(cntxt,length);
}
@-
For error reporting we may have to find the start of the previous line,
which, ofcourse, is easy given the client buffer.
The remaining functions are self-explanatory.
@c
str 
lastline(Client cntxt)
{
	str s = CURRENT(cntxt);
	if (NL(*s))
		s++;
	while (s && s > cntxt->fdin->buf && !NL(*s))
		s--;
	if (NL(*s))
		s++;
	return s;
}

long 
position(Client cntxt)
{   
	str s = lastline(cntxt);
	return (long) (CURRENT(cntxt) - s);
}

@-
Upon encountering an error we skip to the nearest semicolon,
or comment terminated by a new line
@c
INLINE void 
skipToEnd(Client cntxt)
{	char c;
	while( (c= *CURRENT(cntxt)) != ';' && c) nextChar(cntxt);
	if(c) nextChar(cntxt);
}
@-
The lexical analyser for numeric constants is a little more complex.
Aside from getting its length, we need an indication of its type.
We could also rebuild the constant directly, but that is already
handled by newConstant. So be lazy for the time being.
@c
int cstLength(Client cntxt, int *type)
{   
	int i = 0;
	int hex=0;
	str s = CURRENT(cntxt);

	*type = TYPE_int;
	if (*s == '-') {
		i++;
		s++;
	}
	if( *s == '0' && (s[1] == 'x' || s[1] == 'X')){
		/* deal with hex */
		hex= TRUE;
		i+=2;
		s+=2;
	}
	if( !isdigit(*s) && !hex) {
		if (*s != '.') 
			goto parseTFN;
	} 
	while (isdigit((int)*s) || (hex && isalpha((int)*s)) ) {
		if( hex  && !((tolower(*s) >= 'a' && tolower(*s) <= 'f') 
			|| isdigit(*s)) ) return i;
		i++;
		s++;
	}
	if( hex) return i;
	if (*s == '.' && isdigit(*(s+1)) ) {
		i++;
		s++;
		while (isdigit(*s)) {
			i++;
			s++;
		}
		*type = TYPE_flt;
	}
	if (*s == 'e' || *s == 'E') {
		i++;
		s++;
		if (*s == '-' || *s == '+')
			s++;
		*type = TYPE_dbl;
		while (isdigit(*s)) {
			i++;
			s++;
		}
	}
	if (*s == '@') {
		i++;
		s++;
		*type = TYPE_oid;
		while (isdigit(*s)) {
			i++;
			s++;
		}
	}
	if (*s == 'L') {
		if (*type == TYPE_int)
			*type = TYPE_lng;
		if (*type == TYPE_flt)
			*type = TYPE_dbl;
		i++;
		s++;
	}
	if (*s == 'L') {
		i++;
		if (*type == TYPE_int)
			*type = TYPE_lng;
		s++;
	}
	return i;
parseTFN:
	if( *s=='f' && strncmp(s,"false",5)==0 && !isalnum((int)*(s+5)) &&
			*(s+5)!= '_'){
		*type = TYPE_bit;
		return 5;
	}
	if( *s== 't' && strncmp(s,"true",4)==0 && !isalnum((int)*(s+4)) &&
			*(s+4)!= '_'){
		*type = TYPE_bit;
		return 4;
	}
	if( *s== 'n' && strncmp(s,"nil",3)==0 && !isalnum((int)*(s+3)) &&
			*(s+3)!= '_'){
		*type = TYPE_void;
		return 3;
	}
	return 0;
}

#define cstCopy(C,I)  idCopy(C,I)

@- Type qualifier
Types are recognized as identifiers preceded by a colon.
They may be extended with a property list
and 'any' types can be marked with an alias.
The type qualifier parser returns the encoded type 
as a short 32-bit integer. 
The syntax structure is

@multitable @columnfractions 0.15 0.8
@item typeQualifier  
@tab : typeName propQualifier 
@item typeName       
@tab : scalarType | collectionType | anyType
@item scalarType     
@tab :  ':' @code{ identifier} 
@item collectionType 
@tab :  ':' @code{ bat} ['[' col ',' col ']'] 
@item anyType        
@tab :  ':' @code{ any} [typeAlias] 
@item col            
@tab :  scalarType | anyType 
@item propQualifier  
@tab :  ['@{' property '@}']
@end multitable

The type ANY matches any type specifier.
Appending it with an alias turns it into a type variable.
The type alias is \$DIGIT (1-9) and can be used to relate types
by type equality. 
The type variable are defined within the context of a function
scope.
Additional information, such as a repetition factor,
encoding tables, or type dependency should be modelled as properties.
@c
int 
typeAlias(Client cntxt, int tpe)
{
	int t;

	if (currChar(cntxt) != '$' || tpe !=TYPE_any)
		return -1;
	nextChar(cntxt);
	if (!isdigit((int) currChar(cntxt))) {
		parseError(cntxt, "[1-9] expected\n");
		return -1;
	}
	t = currChar(cntxt) - '0';
	advance(cntxt,1);
	return t;
}
@-
The simple type analysis currently assumes a proper type identifier.
We should change getTypeIndex to return a failure instead.
@c
int 
simpleTypeId(Client cntxt)
{
	int l, tpe;

	nextChar(cntxt);
	l = typeidLength(cntxt);
	if (l == 0) {
		parseError(cntxt, "Type identifier expected\n");
		return -1;
	}
	tpe = getTypeIndex(CURRENT(cntxt), l, -1);
	if (tpe < 0) {
		parseError(cntxt, "Type identifier expected\n");
		return -1;
	}
	advance(cntxt, l);
	return tpe;
}

int 
parseTypeId(Client cntxt, int defaultType)
{   
	int i = TYPE_any, ht, tt, kh = 0, kt = 0;
	char *s= CURRENT(cntxt);

	if ( strncmp(s, ":bat[", 5) == 0) {
		/* parse :bat[:type,:type] */
		 advance(cntxt,5);
		if( currChar(cntxt) ==':') {
			ht = simpleTypeId(cntxt);
			kh = typeAlias(cntxt,ht);
		} else ht = TYPE_any;

		if (currChar(cntxt) != ',') {
			parseError(cntxt, "',' expected\n");
			return i;
		} 
		nextChar(cntxt); /* skip , */
		skipSpace(cntxt);
		if( currChar(cntxt) ==':') {
			tt = simpleTypeId(cntxt);
			kt = typeAlias(cntxt,tt);
		} else tt= TYPE_any;

		i = newBatType(ht, tt);
		if (kh > 0)
			setAnyHeadIndex(i, kh);
		if (kt > 0)
			setAnyTailIndex(i, kt);

		if (currChar(cntxt) != ']')
			parseError(cntxt, "']' expected\n");
		nextChar(cntxt); /* skip ']' */
		skipSpace(cntxt);
		return i;
	}  
	if (strncmp(s, ":col[", 5) == 0) {
		/* parse :col[:type] */
		advance(cntxt,5);
		if( currChar(cntxt) ==':') { 
			ht = simpleTypeId(cntxt);
			kh = typeAlias(cntxt,ht);
		} else ht = TYPE_any;

		i = newColType(ht);
		if (kh > 0)
			setAnyHeadIndex(i, kh);
		if (currChar(cntxt) != ']')
			parseError(cntxt, "']' expected\n");
		nextChar(cntxt); /* skip ']' */
		skipSpace(cntxt);
		return i;
	}  
	if( strncmp(s,":bat",4)==0 && !idCharacter[(int) s[4]]) {
		advance(cntxt,4);
		return TYPE_bat;
	} 
	if( strncmp(s,":col",4)==0 && !idCharacter[(int) s[4]]) {
		/* parse default for :col[:any] */
		advance(cntxt,4);
		return newColType(TYPE_any);
	} 
	if( currChar(cntxt) ==':'){
		ht = simpleTypeId(cntxt);
		kt = typeAlias(cntxt,ht);
		if( kt > 0)
			setAnyTailIndex(ht,kt);
		return ht;
	} 
	parseError(cntxt,"<type identifier> expected\n");
	return defaultType;
}

INLINE int typeElm(Client cntxt, int def)
{
	if (currChar(cntxt) != ':')
		return def;	/* no type qualifier */
	return parseTypeId(cntxt,def);
}
@-
Character constants may be escaped.
@c
str charCst(Client cntxt) 
{
	int i;
	str v = CURRENT(cntxt);

	if (*v != '\'')
		return 0;
	v++;
	i = 1;
	if (*v == '\\') {
		v++;
		i++;
		if (isdigit(*v)) {
			i++;
			v++;
		}
		if (isdigit(*v)) {
			i++;
			v++;
		}
		if (isdigit(*v)) {
			i++;
			v++;
		}
	} else {
		v++;
	}
	if (*v != '\'')
		return (str) parseError(cntxt, "'\'' expected\n");
	v = strCopy(cntxt, i + 2);
	return v;
}
@+ The Parser
The client is responsible to collect the
input for parsing in a single string before calling the parser.
Once the input is available parsing runs in a critial section for
a single client thread.

The parser uses the rigid structure of the language to speedup
analysis. In particular, each input line is translated into
a MAL instruction record as quickly as possible. Its context is
manipulated during the parsing process, by keeping the  curPrg,
curBlk, and curInstr variables.

The language statements of the parser are gradually introduced, with
the overall integration framework last.
The convention is to return a zero when an error has been
reported or when the structure can not be recognized.
Furthermore, we assume that blancs have been skipped before entering
recognition of a new token.

@- Module statement.
The module and import commands have immediate effect.
The module statement switches the location for symbol table update
to a specific named area. The effect is that all definitions may become
globally known (?) and symbol table should be temporarilly locked
for updates by concurrent users.

@multitable @columnfractions 0.15 0.8
@item moduleStmt      
@tab :  @code{atom} ident [':'ident]
@item
@tab | @code{module} ident
@end multitable

@-
An atom statement does not introduce a new module.
@c
str 
parseAtom(Client cntxt) 
{
	str modnme = 0;
	int l, tpe;
	char *nxt= CURRENT(cntxt);

	if ( (l =idLength(cntxt)) <= 0)
		return parseError(cntxt, "atom name expected\n");

	/* parse: ATOM id:type */
	modnme = putName(nxt, l);
	advance(cntxt,l);
	if (currChar(cntxt) != ':')
		tpe= TYPE_int;	/* no type qualifier */
	else tpe = parseTypeId(cntxt, TYPE_int);
	malAtomDefinition(modnme, tpe);
	cntxt->nspace = fixModule(cntxt->nspace, modnme);
	cntxt->nspace->isAtomModule = TRUE;
	@:helpInfo(cntxt->nspace->help) @
	return "";
}

str parseModule(Client cntxt) 
{
	str modnme = 0;
	int l;
	char *nxt;

	nxt= CURRENT(cntxt);
	if ((l = idLength(cntxt)) <= 0)
		return parseError(cntxt, "<module path> expected\n");
	modnme = putName(nxt, l);
	advance(cntxt,l);
	cntxt->nspace = fixModule(cntxt->nspace, modnme);
	@:helpInfo(cntxt->nspace->help)@
	return "";
}
@- Include statement
An include statement is immediately taken into effect. This
calls for temporary switching the input for a particular client.
The administration for this is handled by malInclude.
No listing is produced, because module sources are assumed to
be debugged upfront already.
@multitable @columnfractions 0.15 0.8
@item includeStmt     
@tab : @code{include} identifier 
@item
@tab | @code{include} string_literal
@end multitable

@c
str
parseInclude(Client cntxt)
{
	str modnme = 0;
	int x;
	char *nxt;

	if (!MALkeyword(cntxt,"include",7)) 
		return 0;
	nxt= CURRENT(cntxt);

	if ( (x = idLength(cntxt)) >0 ||  (x = stringLength(cntxt))>0){
		modnme= putName(nxt,x);
		advance(cntxt,x);
	} else
		return parseError(cntxt,"<module path> expected\n");

	if (currChar(cntxt) != ';') {
		parseError(cntxt,"';' expected\n");
		skipToEnd(cntxt);
		return "";
	}
	skipToEnd(cntxt);

	malInclude(cntxt, modnme, modnme, 0);
	return "";
}
@- Definition
The definition statements share a lot in common, which calls for factoring
out the code in a few text macros. Upon encountering a definition, we
initialize a MAL instruction container. We should also check for
non-terminated definitions.

@multitable @columnfractions 0.15 0.8
@item program         
@tab : ( definition [helpinfo] | statement ) *

@item definition      
@tab : moduleStmt | includeStmt 
@item
@tab  |  commandStmt | patternStmt 
@item
@tab  | functionStmt | factoryStmt
@item
@tab  | includeStmt
@end multitable

Beware, a function signature f(a1..an):(b1..bn) is parsed in such a way that
the symbol table and stackframe contains the sequence
f,a1..an,b1..bn. This slightly complicates the implementation
of the return statement.

Note, the function name could be mod.fcn, which calls for storing
the function definition in a particular module instead of the current one.
@= fcnHeader
	l = operatorLength(cntxt);
	if (l == 0)
		l = idLength(cntxt);
	if (l == 0)
		return (MalBlkPtr) parseError(cntxt,
				"<identifier> | <operator> expected\n");

	fnme= putName( ((char *) CURRENT(cntxt)),l);
	advance(cntxt,l);

	if (currChar(cntxt) == '.') {
		nextChar(cntxt); /* skip '.' */
		modnme = fnme;
		l= operatorLength(cntxt);
		if (l == 0)
			l = idLength(cntxt);
		if (l == 0)
			return (MalBlkPtr) parseError(cntxt,
					"<identifier> | <operator> expected\n");
		fnme= putName( ((char *) CURRENT(cntxt)),l);
		advance(cntxt,l);
	} 
	if (currChar(cntxt) != '(') 
		return (MalBlkPtr)parseError(cntxt, "function header '(' expected\n");
 	advance(cntxt,1);

	/* temporary suspend capturing statements in main block */
	if( cntxt->backup && curBlk && curBlk->errors==0) 
		GDKfatal("mal_parser: unexpected recursion\n");
	cntxt->backup = cntxt->curprg;
	cntxt->curprg = newFunction(fnme, kind);

	curPrg = cntxt->curprg;	
	curBlk = curPrg->def;
	curBlk->flowfixed= 0;
	curBlk->typefixed= 0;
	curInstr = getInstrPtr(curBlk,0);
	if( modnme == 0){
		setModuleScope(curInstr, cntxt->nspace);
	} else {
		setModuleId(curInstr, putName(modnme,strlen(modnme)) );
	}

	/* get calling parameters */
	ch= currChar(cntxt);
	while( ch !=')' && ch && !NL(ch)){
		@:binding(1)@
		/* the last argument may be variable length */
		if( MALkeyword(cntxt,"...",3) ){
			curInstr->varargs++;
            setPolymorphic(curInstr,TYPE_any,FALSE);
			break;
		}
		if ((ch = currChar(cntxt)) != ',') {
			if (ch == ')')
				break;
			return (MalBlkPtr) parseError(cntxt,"',' expected\n");
		} else 
			nextChar(cntxt); /* skip ',' */
		skipSpace(cntxt);
		ch = currChar(cntxt);
	}
	if (currChar(cntxt) != ')') {
		freeInstruction(curInstr);
		return (MalBlkPtr) parseError(cntxt,"')' expected\n");
	}
	advance(cntxt,1); /* skip ')' */
/*
The return type is either a single type or multiple return type structure.
We simply keep track of the number of arguments added and
during the final phase reshuffle the return values to the beginning (?)
*/
	if (currChar(cntxt)== ':'){
		type = typeElm(cntxt, TYPE_any);
		setPolymorphic(curInstr,type,TRUE);
		setVarType(curBlk,curInstr->argv[0],type);
		@:propList(curInstr->argv[0])@
	} else 
	if( keyphrase1(cntxt,"(")){ /* deal with compound return */
		int retc= curInstr->argc, i1,i2=0;
		int maxarg;
		int *newarg;
		/* parse multi-target result */
		/* skipSpace(cntxt);*/
		ch= currChar(cntxt);
		while( ch !=')' && ch && !NL(ch)){
			int varid=0;
			int type= TYPE_any;
			@:binding(0)@
			if( (ch=currChar(cntxt)) != ',') {
				 if( ch==')') break;
				 return (MalBlkPtr) parseError(cntxt, "',' expected\n");
			} else {
				nextChar(cntxt); /* skip ',' */ 
			}
			skipSpace(cntxt);
			ch = currChar(cntxt);
		}
		/* re-arrange the parameters, results first*/
		maxarg= curInstr->maxarg;
		newarg= (int*)GDKmalloc(maxarg*sizeof(int));
		for(i1= retc; i1<curInstr->argc; i1++)
			newarg[i2++]= curInstr->argv[i1];
		curInstr->retc= curInstr->argc-retc;
		for(i1= 1; i1<retc; i1++)
			newarg[i2++]= curInstr->argv[i1];
		curInstr->argc= i2;
		for(; i2<maxarg; i2++) newarg[i2]= 0;
		for(i1=0; i1<maxarg; i1++) 
			curInstr->argv[i1] = newarg[i1];
		GDKfree(newarg);
		if (currChar(cntxt) != ')') {
			freeInstruction(curInstr);
			return (MalBlkPtr) parseError(cntxt, "')' expected\n");
		}
		nextChar(cntxt); /* skip ')' */
	} else { /* default */
		setVarType(curBlk,0,TYPE_void);
	}
@-
The common theme in definitions is to parse the argument list.
@multitable @columnfractions .15 .8
@item header          
@tab :  hdrName '(' params ')' result 
@item result          
@tab :  paramType | '(' params ')'
@item params          
@tab :  binding [',' binding]* 
@item binding         
@tab :  identifier typeName [propQualifier]
@end multitable
@
@= binding
	l = idLength(cntxt);
	if( l>0) {
		varid = findVariableLength(curBlk, CURRENT(cntxt), l);
		if( varid < 0){
			varid = newVariable(curBlk,idCopy(cntxt,l),TYPE_any);
			type= typeElm(cntxt,TYPE_any);
            if( isPolymorphic(type) )
                setPolymorphic(curInstr,type,TRUE);
            setVarType(curBlk,varid,type);
            @:propList(varid)@
		} else 
        if( @1){
            parseError(cntxt,"Argument defined twice\n");
			typeElm(cntxt,getVarType(curBlk,varid));
            @:propList(varid)@
        } else {
            advance(cntxt,l);
			type= typeElm(cntxt,getVarType(curBlk,varid));
            if( type != getVarType(curBlk,varid))
                parseError(cntxt,"Incompatible argument type\n");
            if( isPolymorphic(type) )
                setPolymorphic(curInstr,type,TRUE);
            setVarType(curBlk,varid,type);
            @:propList(varid)@
        }
	} else if( currChar(cntxt)== ':' ){
		type= typeElm(cntxt,TYPE_any);
        varid = newTmpVariable(curBlk,type);
        if( isPolymorphic(type) )
            setPolymorphic(curInstr,type,TRUE);
        setVarType(curBlk,varid,type);
        @:propList(varid)@
	} else 
        parseError(cntxt,"argument expected\n");
	curInstr= pushArgument(curBlk,curInstr, varid);
@-
@}
MAL variables are statically/dynamically typed.
Function and procedure arguments should always be typed.
We do not permit polymorphism at this interpretation level.

The type information maintained simplifies analysis of 
BAT results. If the underlying type is not known, then it
may be replaced once during execution of a MAL instruction
typically as a side-effect of calling a bat-returning function.

We should also allow for variable argument lists. However, they
may only appear in patterns, because the calling context is necessary
to resolve the actual argument list. Furthermore, we can not 
assume much about its type structure.
@-
Variables are extended with a property list to enable
optimizers to make decisions. (See the section on properties).
@{
@-
@= propList
	if( keyphrase1(cntxt,"{")) {
		do {
			str pname,opname;
			int i,lt,lo;

			l = idLength(cntxt);
			if(l==0) 
				break;
			pname= idCopy(cntxt,l);
			if( curBlk->var[@1]->props== NULL)
				 curBlk->var[@1]->props= newPropertySet();
			/* localize value , simplified version */
			lo= operatorLength(cntxt);
			if( lo > 0) 
				opname= operatorCopy(cntxt,lo);
			else opname= GDKstrdup("");
			if((i= cstLength(cntxt,&lt))){
				char *nxt= CURRENT(cntxt);
				switch(lt){
				case TYPE_sht:
				case TYPE_int:{
					int l= strtol(nxt, NULL,10);
					int ival= (int)l;
					setVarProperty(curBlk,@1,pname, opname, lt, &ival);
					break;
					}
				case TYPE_lng:{
					lng l= strtol(nxt, NULL,10);
					setVarProperty(curBlk,@1,pname,  opname,lt, &l);
					break;
					}
				case TYPE_dbl:
				case TYPE_flt:{
					double l= strtod(nxt,NULL);
					setVarProperty(curBlk,@1,pname, opname, lt, &l);
					break;
					}
				case TYPE_bit:{
					bit bval;
					if( strncmp(nxt,"true",4)==0 && i==4)
						bval= TRUE;
					else
					if( strncmp(nxt,"false",5)==0 && i==4)
						bval= FALSE;
					else
					if( strncmp(nxt,"TRUE",4)==0 && i==4)
						bval= TRUE;
					else
					if( strncmp(nxt,"FALSE",4)==0 && i==4)
						bval= FALSE;
					setVarProperty(curBlk,@1,pname, opname, lt, &bval);
					break;
					}
				}
				advance(cntxt,i);
			} else if( currChar(cntxt)=='\'' ){
				str val = charCst(cntxt);
				setVarProperty(curBlk,@1,pname, opname, TYPE_chr, val);
			} else if( (i= stringLength(cntxt)) > 0){
				str val= strCopy(cntxt,i);
				setVarProperty(curBlk,@1,pname, opname, TYPE_str, val);
			} else{ bit t= TRUE;
				setVarProperty(curBlk,@1,pname, opname, TYPE_bit, &t);
			}
			GDKfree(pname); 
			GDKfree(opname); 
			skipSpace(cntxt);
		} while( keyphrase1(cntxt,","));
		if( !keyphrase1(cntxt,"}") )
			/* return (MalBlkPtr) */
			parseError(cntxt,"'}' expected\n");
	}
@-
Each procedure definition opens a structure in which the
information is gathered. The enclosing module is statically
determined.

A proc-header translates into a single MAL instruction.
Since no recursive rules are included, we can stick to
using a single global variable to accummulate the
properties.

The external commands and rules come with a short
help information.

@= helpInfo
	skipSpace(cntxt);
	if( MALkeyword(cntxt,"comment",7)){
		if( (l= stringLength(cntxt))){
			@1 = strCopy(cntxt,l);
		} else {
			parseError(cntxt,"<string> expected\n");
		}
	} else 
	if (currChar(cntxt) != ';')
		parseError(cntxt,"';' expected\n");
	skipToEnd(cntxt);
@c
MalBlkPtr parseCommandPattern(Client cntxt, int kind){
	MalBlkPtr curBlk = 0;
	Symbol curPrg = 0;
	InstrPtr curInstr=0;
	int l;
	str fnme=0, modnme=0;
	char ch;

	int varid=0;
	int type= TYPE_any;

	@:fcnHeader@
	getInstrPtr(curBlk,0)->token= kind;
	curPrg->kind = kind;
	modnme= modnme? modnme:cntxt->nspace->name;
	insertSymbol(findModule(cntxt->nspace, 
			putName(modnme,strlen(modnme))), curPrg);
	trimMalBlk(curBlk);
	chkProgram(cntxt->nspace,curBlk);
	if( cntxt->backup){
		cntxt->curprg = cntxt->backup;
		cntxt->backup = 0;
	}
	skipSpace(cntxt);
@- Short-cut function calls
Most functions are (dynamically) linked with the kernel as
commands or pattern definitions.  This enables for fast execution.

In addition we allow functions to be bound to both
a linked C-function and a MAL specification block.
It the function address is not available, the interpreter
will use the MAL block instead.
This scheme is intended for just-in-time compilation.

[note, command and patterns do not have a MAL block]
@c
	if( MALkeyword(cntxt,"address",7)){
		str nme;
		int i;
		i = idLength(cntxt);
		if( i==0){
			parseError(cntxt,"<identifier> expected\n");
			return 0;
		}
		cntxt->blkmode=0;
		nme = idCopy(cntxt,i);
		if( moduleId(curInstr)) freeModuleName(curInstr);
		setModuleScope(curInstr, 
			findModule(cntxt->nspace, putName(modnme,strlen(modnme))) );
		curInstr->fcn = getAddress(modnme, nme, 0);
		curBlk->binding = nme;
		if( cntxt->nspace->isAtomModule) 
			malAtomProperty(curBlk, curInstr);
	} else {
		return (MalBlkPtr) parseError(cntxt,"'address' expected\n");
	}
	@:helpInfo(curBlk->help)@
	showErrors();
	if(curBlk && cntxt->listing) 
		printFunction(GDKout, curBlk, cntxt->listing);
	return curBlk;
}

MalBlkPtr parseFunction(Client cntxt, int kind){
	MalBlkPtr curBlk = 0;
	Symbol curPrg = 0;
	InstrPtr curInstr=0;
	int l;
	str fnme=0, modnme=0;
	char ch;

	int varid=0;
	int type= TYPE_any;

	@:fcnHeader@
	skipSpace(cntxt);
	if( MALkeyword(cntxt,"address",7)){
		str nme;
		int i;
		skipSpace(cntxt);
		i = idLength(cntxt);
		if( i==0){
			parseError(cntxt,"<identifier> expected\n");
			return 0;
		}
		nme = idCopy(cntxt,i);
		curInstr->fcn = getAddress(modnme,nme,0);
		skipSpace(cntxt);
	}
	/* block is terminated at the END statement */
	@:helpInfo(curBlk->help)@
	return curBlk;
}

@-
Functions and  factories end with a labeled end-statement. 
The routine below checks for misalignment of the closing statements.
Any instruction parsed after the function block is considered an
error.
@c
int parseEnd(Client cntxt)
{   MalBlkPtr curBlk = 0;
	Symbol curPrg = 0;
	int l,showit=0;

	if( MALkeyword(cntxt,"end",3) ){
		curPrg = cntxt->curprg;
		curBlk = curPrg->def;   
		l = idLength(cntxt);
		if(l==0) l= operatorLength(cntxt);
		if( (l== strlen(curPrg->name) &&
			 strncmp(CURRENT(cntxt), curPrg->name, l)==0) || l==0) {
			/* its ok */
		} else {
			parseError(cntxt,"non matching end label, overruled\n");
		}
		
		advance(cntxt,l);
		pushEndInstruction(curBlk);
		insertSymbol(cntxt->nspace, cntxt->curprg);
		trimMalBlk(cntxt->curprg->def);
		cntxt->blkmode =0;
		curBlk->typefixed=0;
		chkProgram(cntxt->nspace, cntxt->curprg->def);
		if( cntxt->backup){
			cntxt->curprg = cntxt->backup;
			cntxt->backup = 0;
		}
		showit= TRUE;
		skipToEnd(cntxt);
		if(showit && cntxt->listing) 
			printFunction(GDKout, curBlk, cntxt->listing);
		showErrors();
		return 1;
	}
	return 0;
}
@-
Most instructions are simple assignments, possibly
modified with a barrier/catch tag.
@multitable @columnfractions .15 .8
@item statement       
@tab :  tag varlist [':=' expr ] propQualifier
@item tag             
@tab :  @code{ return} | @code{ barrier} | @code{ catch}
@item
@tab |  @code{ leave} | @code{ redo} | 
@item expr            
@tab :  fcncall 
@item
@tab : [factor  operator] factor 
@item varlist         
@tab :  variable 
@item
@tab |  @verb{'{' variable {',' variable}* ')' } 
@item variable        
@tab :  identifier propQualifier 
@item factor          
@tab :  constant | var 
@end multitable

The basic types are also predefined as a variable.
This makes it easier to communicate types to MAL patterns.

@= GETvariable
if ((varid = findVariableLength(curBlk, CURRENT(cntxt), l)) == -1){
	arg = idCopy(cntxt,l); 
	varid = newVariable(curBlk,arg,TYPE_any);
} else
	advance(cntxt,l); 
@-
@c
void 
parseAssign(Client cntxt, int cntrl) 
{   
	InstrPtr curInstr;
	MalBlkPtr curBlk;
	Symbol curPrg;
	int i=0, lt,l,type=TYPE_any, varid= -1;
	int idx;
	str arg=0; 

	curPrg = cntxt->curprg;
	curBlk = curPrg->def;
	curInstr = newInstruction(cntrl?cntrl:ASSIGNsymbol);

	/* start the parsing by recognition of the lhs of an assignment */
	if( currChar(cntxt) == '('){
		/* parsing multi-assignment */
		advance(cntxt,1);
		curInstr->argc=0; /*reset to handle pushArg correctly !! */
		curInstr->retc=0;
		while( currChar(cntxt)  != ')' && currChar(cntxt)) {
			l= idLength(cntxt);
			if( l==0) {
				 parseError(cntxt,"<identifier> expected\n"); 
				 pushInstruction(curBlk,curInstr);
				 return;
			}
			@:GETvariable@
            if( currChar(cntxt)==':') {
                getVar(curBlk,varid)->isudftype = 1;
                type = typeElm(cntxt,getVarType(curBlk,varid));
                setPolymorphic(curInstr, type, FALSE); 
                setVarType(curBlk,varid,type);
            }
			@:propList(varid)@
			setVarInitialized(curBlk,varid);
			curInstr= pushArgument(curBlk,curInstr, varid);
			curInstr->retc++;
			if( currChar(cntxt) == ')') 
				break;
			if( currChar(cntxt) == ',') 
				keyphrase1(cntxt,",");
		}
		advance(cntxt,1); /* skip ')' */
	} else { 
		/* are we dealing with a simple assignment? */
		l= idLength(cntxt);
		if( l==0){
			/* we haven't seen a target variable */
			/* flow of control statements may end here. */
			/* shouldn;t allow for nameless controls todo*/
			if( cntrl == LEAVEsymbol || cntrl == REDOsymbol ||
				cntrl == RETURNsymbol || cntrl == EXITsymbol ){	
				pushInstruction(curBlk,curInstr);
 				curInstr->argv[0]= getBarrierEnvelop(curBlk);
				skipToEnd(cntxt);
				return;
				 }
			pushInstruction(curBlk,curInstr);
			parseError(cntxt,"<identifier> expected\n"); 
		   		return;
			}  
		/* Check if we are dealing with module.fcn call*/
		if( CURRENT(cntxt)[l]=='.') {
			curInstr->argv[0]= newTmpVariable(curBlk,TYPE_any);
			goto FCNcallparse;
		}

		/* Get target variable details*/
		@:GETvariable@
		if( !(currChar(cntxt)==':' && CURRENT(cntxt)[1]=='=') ){
			if( currChar(cntxt)==':') {
                getVar(curBlk,varid)->isudftype = 1;
                type = typeElm(cntxt,getVarType(curBlk,varid));
                setPolymorphic(curInstr, type, FALSE);
                setVarType(curBlk,varid,type);
            }
		} 
		@:propList(varid)@
		setVarInitialized(curBlk,varid);
		curInstr->argv[0]= varid;
	}
	/* look for assignment operator */
	if( !keyphrase2(cntxt,":=") ){
	  	/* no assignment !! a control variable is allowed */
		if (curInstr->barrier)
			curInstr->token= NOOPsymbol;
		if (currChar(cntxt) != ';')
			parseError(cntxt,"';' expected\n");
		goto part3;
	} 
	if (currChar(cntxt) == '('){
			/* parse multi assignment */
		advance(cntxt,1);
		@:parseArguments()@ /* parseAssign() -> void */
		skipToEnd(cntxt);
		pushInstruction(curBlk,curInstr);
		return;
	}
@-
At this stage the LHS part has been parsed and the destination
variables have been set. Next step is to parse the expression,
which starts with an operand.
This code is used in both positions of the expression
@= term
	str v = NULL;

	if( (i= cstLength(cntxt,&lt))){
		int cstidx = -1,csttpe= TYPE_any;

		cstidx = fndConstant(curBlk,((char*)CURRENT(cntxt)),i);
		if( cstidx >= 0){
			advance(cntxt,i);
            if( currChar(cntxt)==':') {
                csttpe = typeElm(cntxt,getVarType(curBlk,cstidx));
                if(csttpe == getVarType(curBlk,cstidx) ){
                    getVar(curBlk,cstidx)->isudftype = TRUE;
                } else {
                    cstidx = newConstant(curBlk,csttpe,
                        GDKstrdup(getVarLiteral(curBlk,cstidx)),TRUE);
                    setPolymorphic(curInstr,csttpe, FALSE);
                    getVar(curBlk,cstidx)->isudftype = TRUE;
                }
            } else
            if( lt != getVarType(curBlk,cstidx)){
                    cstidx = newConstant(curBlk,lt,
                        GDKstrdup(getVarLiteral(curBlk,cstidx)),TRUE);
                    setPolymorphic(curInstr,lt, FALSE);
            } 
            curInstr = pushArgument(curBlk,curInstr,cstidx);
            @1;
		} else { 
            /* add a new constant */
            int flag;
            v= cstCopy(cntxt,i);
            flag= currChar(cntxt)==':';
            csttpe = typeElm(cntxt,lt);
            cstidx = newConstant(curBlk,csttpe,v,TRUE);
            setPolymorphic(curInstr,csttpe, FALSE);
            getVar(curBlk,cstidx)->isudftype = flag;
            curInstr = pushArgument(curBlk,curInstr,cstidx);
            @1;
        }
	} else if ( currChar(cntxt)=='\'' && (v = charCst(cntxt)) ){
		lt = typeElm(cntxt,TYPE_chr);
		setPolymorphic(curInstr,lt, FALSE);
		i = newConstant(curBlk,lt,v,TRUE);
		curInstr = pushArgument(curBlk,curInstr,i);
		@1;
	} else if( currChar(cntxt)=='"' &&  (i = stringLength(cntxt)) ){
		v = strCopy(cntxt,i);
		lt = typeElm(cntxt,TYPE_str);
		setPolymorphic(curInstr,lt, FALSE);
		i = newConstant(curBlk,lt,v,FALSE);
		curInstr = pushArgument(curBlk,curInstr,i);
		@1;
	} else if( (i= idLength(cntxt))){
		if( (idx=findVariableLength(curBlk,CURRENT(cntxt),i)) == -1){
			v= idCopy(cntxt,i);
			i= typeElm(cntxt,TYPE_any);
			setPolymorphic(curInstr,i, FALSE);
			idx = newVariable(curBlk, v, i);
			setVarInitialized(curBlk,idx);
			@:propList(idx)@
		} else {
			advance(cntxt,i);
			i = typeElm(cntxt,getVarType(curBlk,idx));
			setPolymorphic(curInstr,i,FALSE);
			@:propList(idx)@
		}
		curInstr= pushArgument(curBlk,curInstr,idx);
	} else if (currChar(cntxt) == ':'){
		i = typeElm(cntxt,TYPE_any);
		setPolymorphic(curInstr,i,FALSE);
		idx = newTypeVariable(curBlk, i );
		@:propList(idx)@
		curInstr = pushArgument(curBlk,curInstr,idx);
		@1;
	}
@-
The parameter of parseArguments is the return value of the enclosing function.
@= parseArguments
while( currChar(cntxt)!= ')'){
	@:term()@ 
	 else { 
		idx = 0;
		parseError(cntxt,"<factor> expected\n");
		pushInstruction(curBlk,curInstr);
		return @1;
	}
	if (currChar(cntxt) == ',') 
		advance(cntxt,1);
	else if (currChar(cntxt) != ')') {
		parseError(cntxt,"',' expected\n");
		cntxt->yycur--; /* keep it */
		break;
	}
}
if (currChar(cntxt) == ')') 
	advance(cntxt,1);
@-
We have so far the LHS part of an assignment. The remainder is
either a simple term expression, a multi assignent, or the start 
of a function call.
@c
	if( (l=idLength(cntxt)) && CURRENT(cntxt)[l] == '.') {
FCNcallparse:
		/* continue with parseing a function/operator call */
		arg= putName(CURRENT(cntxt),l);
		advance(cntxt,l+1); /* skip '.' too */
		setModuleId(curInstr,arg);
        i = idLength(cntxt);
        if( i==0) i= operatorLength(cntxt);
        if( i ) {
             setFunctionId(curInstr, putName(((char*)CURRENT(cntxt)),i));
            advance(cntxt,i);
        } else {
             parseError(cntxt,"<functionname> expected\n");
             pushInstruction(curBlk,curInstr);
             return;
        }
		skipSpace(cntxt);
		if (currChar(cntxt) != '(') {
			parseError(cntxt,"'(' expected\n");
			pushInstruction(curBlk,curInstr);
			return;
		}
		advance(cntxt,1);
		@:parseArguments()@ /* parseAssign() -> void */
		skipSpace(cntxt);
		if( currChar(cntxt)!=';')
		parseError(cntxt,"';' expected\n");
		goto part3;
	}
@-
Handle the ordinary assignments and expressions
@c
	{@:term(goto part2)@}
part2:  /* consume <operator><term> part of expression */
	if( (i= operatorLength(cntxt)) ){
		/* simple arithmetic operator expression */
		setFunctionId(curInstr, putName(((char*)CURRENT(cntxt)),i));
		advance(cntxt,i);
		curInstr->modname= putName("calc",4);
		if( (l = idLength(cntxt))) {
			@:GETvariable@
			curInstr= pushArgument(curBlk,curInstr,varid); 
			goto part3;
		} 
		{@:term(goto part3)@}
		parseError(cntxt,"<term> expected\n");
		pushInstruction(curBlk,curInstr);
		return;
	} else  {
		skipSpace(cntxt);
        if( currChar(cntxt) == '(')
			parseError(cntxt,"module name missing\n");
        else
		if( currChar(cntxt) != ';' && currChar(cntxt) != '#')
			parseError(cntxt,"operator expected\n");
	}
part3:
	skipToEnd(cntxt);
	pushInstruction(curBlk,curInstr);
}
#define BRKONERR if( curPrg->def->errors>=MAXERRORS) return curPrg->def->errors;
int parseMAL(Client cntxt, Symbol curPrg){
	int cntrl=0;
	/*Symbol curPrg= cntxt->curprg;*/
	char c;

	echoInput(cntxt);
	/* here the work takes place */
	while( (c=currChar(cntxt)) ){
		switch( c){
		case '\n': case '\r': case '\f': 
			nextChar(cntxt);
			echoInput(cntxt);
			continue;
		case ';': case '\t': case ' ': 
			nextChar(cntxt);
			continue;
		case '#': 
		{ /* keep the full line comments */
			char start[256], *e=start, c; 
			MalBlkPtr curBlk= curPrg->def;
			InstrPtr curInstr;

			*e=0;
			nextChar(cntxt);
			while ((c = currChar(cntxt))) {
				if( e < start+256-1) *e++= c;
				nextChar(cntxt);
				if (c == '\n' || c == '\r') {
					*e = 0;
					if( e > start) e--;
					/* prevChar(cntxt);*/
					break;
				}
			}
			if( e> start) *e=0;
			if( e>start && curBlk->stop > 0){
@-
Keep the comment lines as un-used constants.
This implies that a deadcode optimizer will remove
the information.
@c
				curInstr= newInstruction(REMsymbol);
				pushInstruction(curBlk,curInstr);
				getArg(curInstr,0)= newConstant(curBlk,
					TYPE_str,GDKstrdup(start),FALSE);
				setVarUsed(curBlk,getArg(curInstr,0),FALSE);
			}
			echoInput(cntxt);
		}
			  continue;
		case 'A': case 'a':
			  if( MALkeyword(cntxt,"atom",4) &&
				   parseAtom(cntxt)!=0) break;
			  goto allLeft;
		case 'b': case 'B':
			  if( MALkeyword(cntxt,"barrier",7)) {
				 cntxt->blkmode++;
				 cntrl = BARRIERsymbol; 
			  }
			  goto allLeft;
		case 'C': case 'c': 
			  if( MALkeyword(cntxt,"command",7) ) {
				 parseCommandPattern(cntxt, COMMANDsymbol);
				 continue;
			  }
			  if( MALkeyword(cntxt,"catch",5)){
				 cntrl= CATCHsymbol;
				 goto allLeft;
			  }
			  goto allLeft;
		case 'E': case 'e': 
			  if( MALkeyword(cntxt,"exit",4)){
				 if(cntxt->blkmode>0) cntxt->blkmode--;
				 cntrl= EXITsymbol;
			  } else if( parseEnd(cntxt)) {
					break;
			  }
			  goto allLeft;
		case 'F': case 'f': 
			  if( MALkeyword(cntxt,"function",8) ){
				 cntxt->blkmode++;
				 if( parseFunction(cntxt, FUNCTIONsymbol)) 
					break;
			  } else if( MALkeyword(cntxt,"factory",7) ){
				 cntxt->blkmode++;
				 parseFunction(cntxt, FACTORYsymbol);
				 break;
			  }
			  goto allLeft;
		case 'H': case 'h':
			  if( MALkeyword(cntxt,"handler",5)) { 
				skipToEnd(cntxt); 
				 cntxt->blkmode++;
				 break; 
			  }
		case 'i': if( parseInclude(cntxt)) continue;
			goto allLeft;
		case 'L': case 'l': 
			  if( MALkeyword(cntxt,"leave",5))
				 cntrl= LEAVEsymbol;
			  goto allLeft;
		case 'M': case 'm': 
			  if( MALkeyword(cntxt,"map",3)) {
				 cntrl = MAPsymbol; 
			  } else
			  if( MALkeyword(cntxt,"module",6) &&
				 parseModule(cntxt)!= 0) break;
			  goto allLeft;
		case 'P': case 'p': 
			  if( MALkeyword(cntxt,"pattern",7) ) {
				 parseCommandPattern(cntxt, PATTERNsymbol);
				 continue;
			  }
			  goto allLeft;
		case 'R': case 'r': 
			  if( MALkeyword(cntxt,"redo",4)){
				 cntrl= REDOsymbol;
				 goto allLeft;
			  }
			  if( MALkeyword(cntxt,"raise",5)){
				 cntrl= RAISEsymbol;
				 goto allLeft;
			  }
			  if( MALkeyword(cntxt,"return",6)){
				 cntrl= RETURNsymbol;
			  }
			  goto allLeft;
		case 'T': case 't':
			  if( MALkeyword(cntxt,"thread",6)){
				 cntrl= THREADsymbol;
			  }
			  goto allLeft;
		case 'Y': case 'y':
			if( MALkeyword(cntxt,"yield",5)){
				 cntrl= YIELDsymbol;
				 goto allLeft;
			}
		default: allLeft:
			parseAssign(cntxt,cntrl);
			cntrl =0;
			BRKONERR;
		}
	}
	return curPrg->def->errors;
}
@- Error display
Display the error information for the current client.
An arrow and state number is printed at the "appropriate" place. 
If no lookahead character is a used and the next character is a newline,
we should also copy the input.
@c
str parseError(Client cntxt, str msg)
{   
	Symbol curPrg;
	MalBlkPtr curBlk;
	char buf[10*1024];
	char *s=buf, *t, *l = lastline(cntxt);
	long i;

	curPrg = cntxt->curprg;
	curBlk = curPrg->def;
	if(curBlk) 
		curBlk->errors++;

	/* accidental %s directives in the lastline can
	   crash the vfsprintf later => escape them */
	for(t=l; *t && *t!='\n'; t++) {
		if (*t == '%') 
			*s++ = '%'; 
		*s++ = *t;
	}
	*s++ = '\n';
	*s++ = '!';
	/* produce the position marker*/
	i = position(cntxt) + strlen(GDKERROR)-1;
	for(; i > 0; i--) {
	   *s++ = ((l && *(l+1) && *l++ != '\t'))?' ':'\t';
	}
	*s++ = '^'; 
	*s = 0;

	if (msg == 0)
		msg = "can't help you here, sorry.\n";
	if( strlen(msg)+strlen(buf) < 1020)
		snprintf(s,1020,"%s", msg);
	skipToEnd(cntxt);
	GDKerror(buf);
	return 0;
}
@}
