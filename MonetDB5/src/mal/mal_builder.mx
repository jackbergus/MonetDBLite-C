@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2007 CWI.
@' All Rights Reserved.

@f mal_builder
@a M. Kersten
@v 1.0

@* The MAL builder
The MAL builder library containst the primitives to simplify construction 
of programs by compilers. It has grown out of the MonetDB/SQL code generator.
The strings being passed as arguments are copied in the process.

@{
@h
#ifndef _MAL_BUILDER_
#define _MAL_BUILDER_

#include "mal.h"
#include "mal_function.h"
#include "mal_namespace.h"

mal_export InstrPtr newStmt(MalBlkPtr mb, char *module, char *name);
mal_export InstrPtr newStmt1(MalBlkPtr mb, str module, char *name);
mal_export InstrPtr newStmt2(MalBlkPtr mb, str module, char *name);
mal_export InstrPtr newStmtId(MalBlkPtr mb, char *id, char *module, char *name);
mal_export InstrPtr newAssignment(MalBlkPtr mb);
mal_export InstrPtr newComment(MalBlkPtr mb, const char *val);
mal_export InstrPtr newFcnCall(MalBlkPtr mb, char *mod, char *fcn);
mal_export InstrPtr pushInt(MalBlkPtr mb, InstrPtr q, int val);
mal_export InstrPtr pushWrd(MalBlkPtr mb, InstrPtr q, wrd val);
mal_export InstrPtr pushBte(MalBlkPtr mb, InstrPtr q, bte val);
mal_export InstrPtr pushChr(MalBlkPtr mb, InstrPtr q, char val);
mal_export InstrPtr pushOid(MalBlkPtr mb, InstrPtr q, oid val);
mal_export InstrPtr pushVoid(MalBlkPtr mb, InstrPtr q);
mal_export InstrPtr pushLng(MalBlkPtr mb, InstrPtr q, long val);
mal_export InstrPtr pushDbl(MalBlkPtr mb, InstrPtr q, double val);
mal_export InstrPtr pushFlt(MalBlkPtr mb, InstrPtr q, float val);
mal_export InstrPtr pushStr(MalBlkPtr mb, InstrPtr q, const char *val);
mal_export InstrPtr pushBit(MalBlkPtr mb, InstrPtr q, int val);
mal_export InstrPtr pushNil(MalBlkPtr mb, InstrPtr q, int tpe);
mal_export InstrPtr pushNilType(MalBlkPtr mb, InstrPtr q, char *tpe);
mal_export InstrPtr pushZero(MalBlkPtr mb, InstrPtr q, int tpe);
mal_export InstrPtr pushValue(MalBlkPtr mb, InstrPtr q, ValPtr cst);

#endif /* _MAL_BUILDER_ */

@c
#include "mal_config.h"
#include "mal_builder.h"
InstrPtr
newAssignment(MalBlkPtr mb)
{
	InstrPtr q = newInstruction(mb,ASSIGNsymbol);

	getArg(q,0)= newTmpVariable(mb,TYPE_any);
	pushInstruction(mb, q);
	return q;
}

InstrPtr
newStmt(MalBlkPtr mb, char *module, char *name)
{
	InstrPtr q = newInstruction(mb,ASSIGNsymbol);

	setModuleId(q, (module) ? putName(module, strlen(module)) : NULL);
	setFunctionId(q, (name) ? putName(name, strlen(name)) : NULL);
	setDestVar(q, newTmpVariable(mb, TYPE_any));
	pushInstruction(mb, q);
	return q;
}
InstrPtr
newStmt1(MalBlkPtr mb, str module, char *name)
{
	InstrPtr q = newInstruction(mb,ASSIGNsymbol);

	setModuleId(q, module);
	setFunctionId(q, (name) ? putName(name, strlen(name)) : NULL);
	setDestVar(q, newTmpVariable(mb, TYPE_any));
	pushInstruction(mb, q);
	return q;
}
InstrPtr
newStmt2(MalBlkPtr mb, str module, char *name)
{
	InstrPtr q = newInstruction(mb,ASSIGNsymbol);

	setModuleId(q, module);
	setFunctionId(q, name);
	setDestVar(q, newTmpVariable(mb, TYPE_any));
	pushInstruction(mb, q);
	return q;
}
InstrPtr
newStmtId(MalBlkPtr mb, char *id, char *module, char *name)
{
	InstrPtr q = newInstruction(mb,ASSIGNsymbol);

	setModuleId(q, (module) ? putName(module, strlen(module)) : NULL);
	setFunctionId(q, (name) ? putName(name, strlen(name)) : NULL);
	setDestVar(q, newVariable(mb, GDKstrdup(id), TYPE_any));
	pushInstruction(mb, q);

	return q;
}

InstrPtr
newFcnCall(MalBlkPtr mb, char *mod, char *fcn)
{
	InstrPtr q = newAssignment(mb);

	setModuleId(q, putName(mod, strlen(mod)));
	setFunctionId(q, putName(fcn, strlen(fcn)));
	return q;
}

InstrPtr
newComment(MalBlkPtr mb, const char *val)
{
	InstrPtr q = newInstruction(NULL,REMsymbol);
	ValRecord cst;

	cst.vtype= TYPE_str;
	cst.val.sval= GDKstrdup(val);
	cst.len= strlen(cst.val.sval);
	getArg(q,0) = defConstant(mb,TYPE_str,&cst);
	/* mark the constant for not being copied to the stack */
	isConstant(mb,getArg(q,0)) = - isConstant(mb,getArg(q,0));
	pushInstruction(mb, q);
	return q;
}

InstrPtr
pushInt(MalBlkPtr mb, InstrPtr q, int val)
{
	int _t;
	ValRecord cst;

	cst.vtype= TYPE_int;
	cst.val.ival= val;
	_t = defConstant(mb, TYPE_int,&cst);
	return pushArgument(mb, q, _t);
}

InstrPtr
pushWrd(MalBlkPtr mb, InstrPtr q, wrd val)
{
	int _t;
	ValRecord cst;

	cst.vtype= TYPE_wrd;
	cst.val.wval= val;
	_t = defConstant(mb, TYPE_wrd,&cst);
	return pushArgument(mb, q, _t);
}

InstrPtr
pushBte(MalBlkPtr mb, InstrPtr q, bte val)
{
	int _t;
	ValRecord cst;

	cst.vtype= TYPE_bte;
	cst.val.btval= val;
	_t = defConstant(mb, TYPE_bte,&cst);
	return pushArgument(mb, q, _t);
}

InstrPtr
pushChr(MalBlkPtr mb, InstrPtr q, char val)
{
	int _t;
	ValRecord cst;

	cst.vtype= TYPE_chr;
	cst.val.cval[0]= val;
	cst.val.cval[1]= 0;
	cst.val.cval[2]= 0;
	cst.val.cval[3]= 0;
	_t = defConstant(mb, TYPE_chr,&cst);
	return pushArgument(mb, q, _t);
}

InstrPtr
pushOid(MalBlkPtr mb, InstrPtr q, oid val)
{
	int _t;
	ValRecord cst;

	cst.vtype= TYPE_oid;
	cst.val.oval= val;
	_t = defConstant(mb,TYPE_oid,&cst);
	return pushArgument(mb, q, _t);
}

InstrPtr
pushVoid(MalBlkPtr mb, InstrPtr q)
{
	int _t;
	ValRecord cst;

	cst.vtype= TYPE_void;
	cst.val.oval= oid_nil;
	_t = defConstant(mb,TYPE_void,&cst);
	return pushArgument(mb, q, _t);
}

InstrPtr
pushLng(MalBlkPtr mb, InstrPtr q, long val)
{
	int _t;
	ValRecord cst;

	cst.vtype= TYPE_lng;
	cst.val.oval= val;
	_t = defConstant(mb,TYPE_lng,&cst);
	return pushArgument(mb, q, _t);
}

InstrPtr
pushDbl(MalBlkPtr mb, InstrPtr q, double val)
{
	int _t;
	ValRecord cst;

	cst.vtype= TYPE_dbl;
	cst.val.dval= val;
	_t = defConstant(mb,TYPE_dbl,&cst);
	return pushArgument(mb, q, _t);
}

InstrPtr
pushFlt(MalBlkPtr mb, InstrPtr q, float val)
{
	int _t;
	ValRecord cst;

	cst.vtype= TYPE_flt;
	cst.val.fval= val;
	_t = defConstant(mb,TYPE_flt,&cst);
	return pushArgument(mb, q, _t);
}

InstrPtr
pushStr(MalBlkPtr mb, InstrPtr q, const char *Val)
{
	int _t;
	ValRecord cst;
	char *val = (char*)Val;

	cst.vtype= TYPE_str;
	cst.val.sval= val;
	cst.len= strlen(cst.val.sval);
	_t = defConstant(mb,TYPE_str,&cst);

	if (getConstant(mb,_t).val.sval == val) 
		getConstant(mb,_t).val.sval = GDKstrdup(val);
	return pushArgument(mb, q, _t);
}

InstrPtr
pushBit(MalBlkPtr mb, InstrPtr q, int val)
{
	int _t;
	ValRecord cst;

	cst.vtype= TYPE_bit;
	cst.val.cval[0]= val;
	cst.val.cval[1]= 0;
	cst.val.cval[2]= 0;
	cst.val.cval[3]= 0;
	_t = defConstant(mb,TYPE_bit,&cst);

	return pushArgument(mb, q, _t);
}

InstrPtr
pushNil(MalBlkPtr mb, InstrPtr q, int tpe)
{
	int _t;
	ValRecord cst;

	cst.vtype=TYPE_void;
	cst.val.oval= oid_nil;
	if( !isaBatType(tpe) ){
		convertConstant(tpe, &cst);
		_t = defConstant(mb,tpe,&cst);
	} else
		_t = newTmpVariable(mb,tpe);

	return pushArgument(mb, q, _t);
}

InstrPtr
pushNilType(MalBlkPtr mb, InstrPtr q, char *tpe)
{
	int _t,idx;
	ValRecord cst;

	idx= getTypeIndex(tpe, -1, TYPE_any);
	cst.vtype=TYPE_void;
	cst.val.oval= oid_nil;
	convertConstant(idx, &cst);
	_t = defConstant(mb,idx,&cst);

	return pushArgument(mb, q, _t);
}

InstrPtr
pushZero(MalBlkPtr mb, InstrPtr q, int tpe)
{
	int _t;
	ValRecord cst;

	cst.vtype=TYPE_int;
	cst.val.ival= 0;
	convertConstant(tpe, &cst);
	_t = defConstant(mb,tpe,&cst);

	return pushArgument(mb, q, _t);
}

InstrPtr
pushValue(MalBlkPtr mb, InstrPtr q, ValPtr vr)
{
	int _t;
	ValRecord cst;
	VALcopy(&cst, vr);

	_t = defConstant(mb,cst.vtype,&cst);
	return pushArgument(mb, q, _t);
}
@}
