@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2007 CWI.
@' All Rights Reserved.

@f mal_compiler
@a M. L. Kersten
@+ MAL compilation
Compilation of a bunch of MAL procedures can be used
to remove the overhead of the interpreter and reduce
the footprint.
It is particularly useful in embedded and static
applications.

The current translation scheme is choosen for
simplicity and is particularly aimed at
removing the MAL interpreter overhead only.
The best result is most likely obtained after
the other MAL optimizers have performed their job.
This may involve code in-lining steps specifically
geared at producing C later on.

To illustrate the process consider the MAL function 
below (actual a fragment of tst903 from the test suite).
It contains most of the language features.

@example
function tst903();
    b:= bat.new(:void,:lng);
    barrier (go,i):= language.newRange(0:lng);
        k:= mmath.rand();
        l:= calc.lng(k);
        bat.insert(b,nil,l);
        redo (go,i):= language.nextElement(1:lng,1000000:lng);
    exit (go,i);
end tst903;
mal.compiler("user","tst903","mal01");
@end example

The C code is derived in a few steps. First the variables
are collected from the symbol table and turned into an
initialized C variable. Thereafter, we simple produce
function calls for each MAL instruction and plug in
the required flow of control statements.
Notice that each instruction may produce an exception,
which should be catched. 

Of course the resulting code is not optimal, e.g.
the following portion for the example is produced:
@example
str MCCuser_tst903(void *tst903)
{
        BID *b= 0; /* bat[:void,:lng] */
        void *V2= 0; /* void */
        lng V3 = 0;
        bit go = 0;
        lng i = 0;
        lng V6 = 0;
        int k = 0;
        lng l = 0;
        void *V9= 0; /* void */
        void *V10= 0; /* void */
        lng V11 = 1;
        lng V12 = 1000000;
        str Xmsg = MAL_SUCCEED;
        if( Xmsg = CMDBATnew(&b,&V2,&V3) ) return Xmsg;
        if( Xmsg = RNGnewRange_lng(&go,&i,&V6) ) return Xmsg;
        if(  go == 0 ||go== bit_nil ) goto EXIT_7;
BARRIER_3:
        if( Xmsg = MATHrandint(&k) ) return Xmsg;
        if( Xmsg = CALCint2lng(&l,&k) ) return Xmsg;
        if( Xmsg = BKCinsert_bun(&V9,&b,&V10,&l) ) return Xmsg;
        if( Xmsg = RNGnextElement_lng(&go,&i,&V11,&V12) ) return Xmsg;
        if( !( go == 0 ||go== bit_nil) ) goto BARRIER_3;
EXIT_7: ;
}
@end example
This models a for-loop over an integer range and
contains an expensive coercion.
One way to improve code generation is to associate
a code string to each MAL signature, and make
exception handling explicit.

@- Limitations
The current implementation only handles translation
of command calls and multiplex statements over commands.
Patterns should be handled differently, e.g.  CMDBATnew
in the example above would make this program not
executable.
@mal
module compiler;
pattern MALtoC(mod:str, fcn:str, alias:str):void
address MCdynamicCompiler
comment "MAL to C compiler for functions";
@{
@h
#ifndef _MAL_COMPILER_H_
#define _MAL_COMPILER_H_
#include "mal.h"
#include "mal_client.h"

#define DEBUG_MAL_COMPILER

#ifdef WIN32
#ifndef LIBMAL_COMPILER
#define mal_compiler_export extern __declspec(dllimport)
#else
#define mal_compiler_export extern __declspec(dllexport)
#endif
#else
#define mal_compiler_export extern
#endif

mal_compiler_export str MCdynamicCompiler(MalBlkPtr mb, MalStkPtr stk, InstrPtr p);

#endif /* _MAL_COMPILER_H_ */
@-
@c
#include "mal_config.h"
#include "mal_compiler.h"
#include "mal_interpreter.h"
#include "mal_function.h"

static char *mccPrelude[] = {
	"/* MAL to C compiler\n",
	"   Copyright (c) 2001-2007, CWI.\n",
	"   All rights reserved.\n",
	"*/\n",
	"#include \"mal_config.h\"\n",
	"#include \"mal.h\"\n",
	"#include \"mal_interpreter.h\"\n",
	"#include \"mal_function.h\"\n",
	"#define BID int\n",	/* the interface works on BAT ids */
	0
};
void
mccVar(stream *f, MalBlkPtr mb, int i)
{
	if (isTmpVar(mb, i))
		stream_printf(f, "T%d", mb->var[i]->tmpindex);
	else
		stream_printf(f, "%s", mb->var[i]->name);
}

void
mccArg(stream *f, MalBlkPtr mb, int i)
{
	stream_printf(f, "&");
	mccVar(f, mb, i);
}

void
mccValue(stream *f, MalBlkPtr mb, int i)
{
	int (*tostr) (str *, int *, ptr);
	str buf = 0, c;
	int sz = 0;
	ValPtr val;

	val = &getConstant(mb, i);
	if (val->vtype == TYPE_str) {
		stream_printf(f, "\"%s\"", val->val.sval);
	} else {
		tostr = BATatoms[val->vtype].atomToStr;
		(*tostr) (&buf, &sz, VALptr(val));
		c = strchr(buf, '@');
		if (c && *(c + 1) == '0')
			*c = 0;
		stream_printf(f, "%s", buf);
		GDKfree(buf);
	}
}

void
mccType(stream *f, MalBlkPtr mb, int i)
{
	str tpe;

	tpe = getTypeName(getVarType(mb, i));
	if (strcmp(tpe, "void") == 0) {
		stream_printf(f, "void *");
	} else if (isaBatType(getVarType(mb, i))) {
		stream_printf(f, "int *");
	} else {
		stream_printf(f, "%s *", tpe);
	}
	GDKfree(tpe);
}

void
mccInit(stream *f, MalBlkPtr mb)
{
	int i, j;
	InstrPtr p;

	for (i = 0; mccPrelude[i]; i++)
		stream_printf(f, "%s", mccPrelude[i]);
	p = getInstrPtr(mb, 0);
	stream_printf(f, "str MCC%s_%s(", getModuleId(p), getFunctionId(p));
	if (p->argc > 0) {
		mccType(f, mb, i);
		mccVar(f, mb, getArg(p, 0));
		for (j = 1; j < p->argc; j++) {
			stream_printf(f, ",");
			mccType(f, mb, i);
			mccVar(f, mb, getArg(p, j));
		}
	}
	stream_printf(f, ")\n{\n");
}

void
mccVariables(stream *f, MalBlkPtr mb)
{
	int i;
	str tpe, v;

	for (i = 1; i < mb->vtop; i++) {
		tpe = getTypeName(getVarType(mb, i));
		v = getVarName(mb, i);
		if (isTmpVar(mb, i))
			*v = 'V';
		if (getVarType(mb, i) == TYPE_void) {
			stream_printf(f, "\tvoid *");
			mccVar(f, mb, i);
			stream_printf(f, "= 0; /* %s */\n", tpe);
		} else if (isaBatType(getVarType(mb, i))) {
			stream_printf(f, "\tBID *");
			mccVar(f, mb, i);
			stream_printf(f, "= 0; /* %s */\n", tpe);
		} else {
			stream_printf(f, "\t%s ", tpe);
			mccVar(f, mb, i);
			stream_printf(f, " = ");
			mccValue(f, mb, i);
			stream_printf(f, ";\n");
		}
		GDKfree(tpe);
	}
	/* if( isTmpVar(mb,i) ) GDKfree(v); */
	stream_printf(f, "\tstr Xmsg = MAL_SUCCEED;\n");
}

void
mccEntry(stream *f, MalBlkPtr mb, int i)
{
	switch (getVarType(mb, i)) {
	case TYPE_void:
		stream_printf(f, "1");
		break;
	case TYPE_bit:
		mccVar(f, mb, i);
		stream_printf(f, " == 0 ||");
		mccVar(f, mb, i);
		stream_printf(f, "== bit_nil");
		break;
	case TYPE_chr:
		mccVar(f, mb, i);
		stream_printf(f, "== chr_nil");
		break;
	case TYPE_sht:
		mccVar(f, mb, i);
		stream_printf(f, " < 0 ||");
		mccVar(f, mb, i);
		stream_printf(f, "== sht_nil");
		break;
	case TYPE_int:
		mccVar(f, mb, i);
		stream_printf(f, " < 0 ||");
		mccVar(f, mb, i);
		stream_printf(f, "== int_nil");
		break;
	case TYPE_lng:
		mccVar(f, mb, i);
		stream_printf(f, " < 0 ||");
		mccVar(f, mb, i);
		stream_printf(f, "== lng_nil");
		break;
	case TYPE_flt:
	case TYPE_dbl:
		mccVar(f, mb, i);
		stream_printf(f, " < 0 ||");
		mccVar(f, mb, i);
		stream_printf(f, "== dbl_nil");
		break;
	case TYPE_oid:
		mccVar(f, mb, i);
		stream_printf(f, "== oid_nil");
		break;
	case TYPE_str:
		stream_printf(f, " strlen(");
		mccVar(f, mb, i);
		stream_printf(f, ") == 0 ||");
		mccVar(f, mb, i);
		stream_printf(f, "== str_nil");
		break;
	default:
		stream_printf(f, "/* Unknown barrier :%d */", getVarType(mb, i));
	}
}

@-
Before we generate code, we should check existence of
CATCH blocks. If they do not exist, then any exception
terminates the function. Otherwise, we jump to the first one.
@c
void
mccCall(stream *f, MalBlkPtr mb, InstrPtr p, int *catch, int *ctop){
	int j;
	if (p->blk && p->blk->binding) {
		stream_printf(f, "\tif( Xmsg = ");
		stream_printf(f, "%s(", p->blk->binding);
		mccArg(f, mb, getArg(p, 0));
		for (j = 1; j < p->argc; j++) {
			stream_printf(f, ",");
			mccArg(f, mb, getArg(p, j));
		}
		stream_printf(f, ") )");
		if (*ctop > 0)
			stream_printf(f, " goto CATCH_%d;\n", catch[--*ctop]);
		else
			stream_printf(f, " return Xmsg;\n");
	}
}
int
mccInstruction(stream *f, MalBlkPtr mb, InstrPtr p, int i, int *catch, int *ctop)
{
	int errors = 0;
	int j;

	if (p->barrier == EXITsymbol)
		stream_printf(f, "EXIT_%d: ;\n", i);

	if (p->barrier == CATCHsymbol) {
		stream_printf(f, "CATCH_%d:\n", i);
		stream_printf(f, "if( ");
		mccVar(f, mb, getArg(p, 0));
		stream_printf(f, " == MAL_SUCCEED) goto EXIT_%d;\n", p->jump);
		return errors;
	}

	mccCall(f,mb,p,catch,ctop);
	if (p->barrier)
		switch (p->barrier) {
		case BARRIERsymbol:
			stream_printf(f, "\tif(  ");
			mccEntry(f, mb, getArg(p, 0));
			stream_printf(f, " ) goto EXIT_%d;\n", p->jump);
			stream_printf(f, "BARRIER_%d:\n", i + 1);
			break;
		case RETURNsymbol:
			for (j = 0; j < p->retc; j++) {
				stream_printf(f, "\tVALcopy(&");
				mccVar(f, mb, getArg(getInstrPtr(mb, 0), j));
				stream_printf(f, ", &");
				mccVar(f, mb, getArg(p, j));
				stream_printf(f, ");\n");
			}
			stream_printf(f, "\treturn Xmsg;\n");
		case CATCHsymbol:
		case EXITsymbol:
			break;
		case LEAVEsymbol:
		case REDOsymbol:
			stream_printf(f, "\tif( !( ");
			mccEntry(f, mb, getArg(p, 0));
			stream_printf(f, ") ) goto BARRIER_%d;\n", p->jump);
			break;
		default:
			stream_printf(f, "/* case not yet covered: %d */\n", p->barrier);
		}
	return errors;
}

@-
Multiplex script calls are expanded to their code base.
@c
void
mccMultiplex(stream *f, MalBlkPtr mb, InstrPtr p)
{
	int pc = getPC(mb, p);
	InstrPtr pn;

	pn = copyInstruction(p);
	if (getFunctionId(pn))
		GDKfree(pn->fcnname);
	if (getModuleId(pn))
		setModuleId(p,NULL);
	setModuleId(pn, NULL);
	setFunctionId(pn, GDKstrdup(getConstant(mb, pn->argv[pn->retc]).val.sval));
	delArgument(pn, pn->retc);
	typeChecker(MCgetClient()->nspace, mb, pn, TRUE);

	stream_printf(f, "{\tlng mloop;\n\tptr h,t;\n");
	stream_printf(f, "init todo\n");
	stream_printf(f, "\tif(mloop>0)\n\tdo{\n");
	stream_printf(f, "TODO\n");
	mccInstruction(f, mb, pn, pc, 0, 0);
	stream_printf(f, "\t} while(mloop > 0 );\n");
	stream_printf(f, "}\n");

	freeInstruction(pn);
}

void
mccJoinPath(stream *f, MalBlkPtr mb, InstrPtr p){
	int i;
	(void)mb;
	stream_printf(f,"\t{ BID *j%d[]={",getArg(p,0));
	mccArg(f, mb, getArg(p, p->retc));
	for(i=p->retc+1;i<p->argc; i++){
		stream_printf(f,",");
		mccArg(f, mb, getArg(p, i));
	}
	stream_printf(f,"};\t");
	mccVar(f, mb, getArg(p,0));
	stream_printf(f,"= ALGjoinPathBody(%d,&j%d); ", p->argc-p->retc, getArg(p,0));
	stream_printf(f,"};\n");
}

void
mccProject(stream *f, MalBlkPtr mb, InstrPtr p, int *catch, int *ctop){
	int j;
	stream_printf(f, "\tif( Xmsg = ALGprojectCstBody(");
	mccArg(f, mb, getArg(p, 0));
	for (j = 1; j < p->argc; j++) {
		stream_printf(f, ",");
		mccArg(f, mb, getArg(p, j));
	}
	stream_printf(f,",%d",getArgType(mb,p,2));
	stream_printf(f, ") )");
	if (*ctop > 0)
		stream_printf(f, " goto CATCH_%d;\n", catch[--*ctop]);
	else
		stream_printf(f, " return Xmsg;\n");
}

void
mccBody(stream *f, MalBlkPtr mb)
{
	int i;
	InstrPtr p;
	int *catch, ctop = 0, errors = 0;

	catch = (int *) alloca(mb->stop);

	for (i = 1; i < mb->stop; i++) {
		p = getInstrPtr(mb, i);
		if (p->barrier == CATCHsymbol)
			catch[ctop++] = i;
	}

	for (i = 1; i < mb->stop; i++) {
		p = getInstrPtr(mb, i);
@-
Unfortunately, we can only compile commands now.
Patterns require simulation of the context. The best
approach would be to provide alternative implementations
directly.
A simple extension would be to also compile the dependent
functions.
@c
		if (p->token != CMDcall && getFunctionId(p)) {
			if (getModuleId(p) && getFunctionId(p) && 
				idcmp(getModuleId(p), "multiplex") == 0 && 
				idcmp(getFunctionId(p), "script") == 0) {
				mccMultiplex(f, mb, p);
				continue;
			}
			if (getModuleId(p) && getFunctionId(p) && 
				idcmp(getModuleId(p), "algebra") == 0 && 
				idcmp(getFunctionId(p), "joinPath") == 0) {
				mccJoinPath(f, mb, p);
				continue;
			}
			if (getModuleId(p) && getFunctionId(p) && 
				idcmp(getModuleId(p), "algebra") == 0 && 
				idcmp(getFunctionId(p), "project") == 0) {
				mccProject(f, mb, p, catch, &ctop);
				continue;
			}
			GDKwarning("call to %s.%s can not be handled correctly\n", 
				getModuleId(p), getFunctionId(p));
			errors++;
		}
		errors += mccInstruction(f, mb, p, i, catch, &ctop);
	}
	if (errors)
		showErrors();
}

void
mccExit(stream *f)
{
	stream_printf(f, "}\n");
	(void) stream_close(f);
}

@-
The compiler is called with arguments to designate
the routine be expanded and the designated file.
@c

str
mccGenerate(MalBlkPtr mb, str alias)
{
	char buf[1024];
	stream *f;

	snprintf(buf, 1024, "%s/%s.c", monet_cwd, alias);
	f = open_wastream(buf);
	if (f == NULL)
		throw(IO, "optimizer.MCcompiler", "Could not access file");
	mccInit(f, mb);
	mccVariables(f, mb);
	mccBody(f, mb);
	mccExit(f);
	return MAL_SUCCEED;
}

@-
The static compiler assumes constant values for the module
and function name,
The dynamic version takes variables from the runtime stack.
@c
str
MCdynamicCompiler(MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	Module s;
	Symbol t;
	str alias;
	str nme, fcn, msg = MAL_SUCCEED;

	(void) mb;
	printf("Calling the dynamic compiler\n");
	nme = *(str *) getArgReference(stk, p, 1);
	fcn = *(str *) getArgReference(stk, p, 2);
	alias = *(str *) getArgReference(stk, p, 3);

#ifdef DEBUG_MAL_COMPILER
	printf("MCdynamicCompiler: %s.%s\n", nme, fcn);
#endif

	s = findModule(MCgetClient()->nspace, nme);
	if( s){
		t= findSymbolInModule(s,fcn);
		if(t== 0)
			throw(MAL,"mal_compiler","Could not find function");
		msg= mccGenerate(t->def,alias);
	}
	return msg;
}

@}
