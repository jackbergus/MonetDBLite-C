@f x100
@t The Monet x100 approach
@a Martin Kersten
@v 0.1

@* The x100 approach
The x100 module uses a vectorized instruction set to process relational table
operations. Unlike the BAT primitives, the vectors are presummed to fit
in the cache, creation of intermediates is avoided, and programming logic 
is simplified to avoid branch mispredictions.

This module contains the Monet V5.0 execution model using the TPC-H
query 1 example, which is phrased in SQL as:
@T
\begin{verbatim}
select l_returnflag, l_linestatus, 
	sum(l_quantity) as sum_qty,
	sum(l_extendedprice * (1-l_discount)) as sum_base_price,
	sum(l_extendedprice * (1-l_discount))*(1+l_tax) as sum_charge,
	sum(l_quantity) as avg_qty,
	avg(l_extendedprice) as avg_price,
	avg(l_discount) as avg_disc,
	count(*) as count_order
from	lineitem
where
	l_shipdate <= date '1998-12-01' - interval '[DELTA]' day(3)
group by l_returnflag, l_linestatus
order by l_returnlag, l_linestatus;
\end{verbatim}
@

The output of the SQL front-end to Monet V5 becomes:
@T
\begin{verbatim}
# Monet Mil to Mal compiler
# Copyright (c) 2001-2006, CWI. All rights reserved.

# Predefined code segment
#The compiler can not guarantee an accurate compilation,
#because MIL unlike MAL is a dynamically typed language.
#A few guidelines to maximize usefullness.
#- make the type of variables explicit, in particular 'nil'
#- upon advice of M2m to remap identifiers, change it in your program directly
#- positional arguments, ie $1,$2,..., can not be compiled in isolation
#
#
#Perhaps someone will develop a complete MIL interpreter
#on top of the MAL kernel in the future
#s14 := mvc_bind(myc, "sys", "lineitem", "l_shipdate", 0); #lineitem
	myc:= bbp.bind("myc");
	s14 := mvc_bind(myc,"sys","lineitem","l_shipdate",0);
#s16 := date("1998-12-01");
	s16 := date("1998-12-01");
#s17 := 7776000;
	s17 := 7776000;
#s15 := date_sub_sec_interval(s16,s17);
	s15 := date_sub_sec_interval(s16,s17);
#s13 := s14.uselect(date(nil), s15);
	aa_a := date(nil);
	s13 := uselect(s14,aa_a,s15);
#s12 := s13.reverse();
	s12 := reverse(s13,);
#s11 := s12.reverse().mark(oid(0)).reverse();# lineitem
	ba_a := oid(0);
	ca_a := reverse(s12,);
	da_a := mark(ca_a,ba_a);
	s11 := reverse(da_a,);
#s18 := mvc_bind(myc, "sys", "lineitem", "l_returnflag", 0); #lineitem
	s18 := mvc_bind(myc,"sys","lineitem","l_returnflag",0);
#s10 := s11.join(s18);
	s10 := join(s11,s18);
#s9 := s10.group();
	s9 := group(s10,);
#s20 := mvc_bind(myc, "sys", "lineitem", "l_linestatus", 0); #lineitem
	s20 := mvc_bind(myc,"sys","lineitem","l_linestatus",0);
#s19 := s11.join(s20);
	s19 := join(s11,s20);
#s8 := s9.group(s19);
	s8 := group(s9,s19);
#s7 := s8.tunique().mirror();
	ea_a := tunique(s8,);
	s7 := mirror(ea_a,);
#s6 := s7.join(s11);
	s6 := join(s7,s11);
#s5 := s6.join(s18);
	s5 := join(s6,s18);
#s4 := s5.reverse().sort().reverse();
	fa_a := reverse(s5,);
	ga_a := sort(fa_a,);
	s4 := reverse(ga_a,);
#s22 := s7.join(s11);
	s22 := join(s7,s11);
#s21 := s22.join(s20);
	s21 := join(s22,s20);
#s3 := s4.CTrefine(s21);
	s3 := refine(s4,s21);
#s25 := s11.join(s18);
	s25 := join(s11,s18);
#s24 := s7.join(s25);
	s24 := join(s7,s25);
#s27 := s11.join(s20);
	s27 := join(s11,s20);
#s26 := s7.join(s27);
	s26 := join(s7,s27);
#s31 := mvc_bind(myc, "sys", "lineitem", "l_quantity", 0); #lineitem
	s31 := mvc_bind(myc,"sys","lineitem","l_quantity",0);
#s30 := s11.join(s31);
	s30 := join(s11,s31);
#s29 := {sum}(s30, s8, s7);
	s29 := group.sum(s30,s8,s7);
#s35 := mvc_bind(myc, "sys", "lineitem", "l_extendedprice", 0); #lineitem
	s35 := mvc_bind(myc,"sys","lineitem","l_extendedprice",0);
#s34 := s11.join(s35);
	s34 := join(s11,s35);
#s33 := {sum}(s34, s8, s7);
	s33 := group.sum(s34,s8,s7);
#s39 := s11.join(s35);
	s39 := join(s11,s35);
#s42 := 1;
	s42 := 1;
#s41 := flt(s42);
	s41 := flt(s42);
#s44 := mvc_bind(myc, "sys", "lineitem", "l_discount", 0); #lineitem
	s44 := mvc_bind(myc,"sys","lineitem","l_discount",0);
#s43 := s11.join(s44);
	s43 := join(s11,s44);
#s45 := [s43 ~ s41];
	ha_a:= zipper(s43,s41);
	s45 := ha_a;
#s40 := [-](s45,s43);
	s40 := multiplex.tactics("-",s45,s43);
#s38 := [*](s39,s40);
	s38 := multiplex.tactics("*",s39,s40);
#s37 := {sum}(s38, s8, s7);
	s37 := group.sum(s38,s8,s7);
#s50 := s11.join(s35);
	s50 := join(s11,s35);
#s53 := 1;
	s53 := 1;
#s52 := flt(s53);
	s52 := flt(s53);
#s54 := s11.join(s44);
	s54 := join(s11,s44);
#s55 := [s54 ~ s52];
	ia_a:= zipper(s54,s52);
	s55 := ia_a;
#s51 := [-](s55,s54);
	s51 := multiplex.tactics("-",s55,s54);
#s49 := [*](s50,s51);
	s49 := multiplex.tactics("*",s50,s51);
#s58 := 1;
	s58 := 1;
#s57 := flt(s58);
	s57 := flt(s58);
#s60 := mvc_bind(myc, "sys", "lineitem", "l_tax", 0); #lineitem
	s60 := mvc_bind(myc,"sys","lineitem","l_tax",0);
#s59 := s11.join(s60);
	s59 := join(s11,s60);
#s61 := [s59 ~ s57];
	ja_a:= zipper(s59,s57);
	s61 := ja_a;
#s56 := [+](s61,s59);
	s56 := multiplex.tactics("+",s61,s59);
#s48 := [*](s49,s56);
	s48 := multiplex.tactics("*",s49,s56);
#s47 := {sum}(s48, s8, s7);
	s47 := group.sum(s48,s8,s7);
#s64 := s11.join(s31);
	s64 := join(s11,s31);
#s63 := {avg}(s64, s8, s7);
	s63 := group.avg(s64,s8,s7);
#s67 := s11.join(s35);
	s67 := join(s11,s35);
#s66 := {avg}(s67, s8, s7);
	s66 := group.avg(s67,s8,s7);
#s70 := s11.join(s44);
	s70 := join(s11,s44);
#s69 := {avg}(s70, s8, s7);
	s69 := group.avg(s70,s8,s7);
#s72 := {count}(s8, s8, s7);
	s72 := group.count(s8,s8,s7);
#
#Identifer 'CTrefine' mapped to 'refine'
\end{verbatim}
@
This output can be handled directly by the interpreter, materializeing all results.
Two other approaches are possible as well. First, we could compile this code to
a simple C program. It merely requires compilation patterns for 
@T
@
and an ordering of how they should be applied. 

Alternatively, we could instruct a front-end to produce code for the x100 module.
For this purpose we assume the new types Operator and Expr to exist as an atoms.
@T
hi_date   := date(2003,1,3);
hd        := int(hi_date);
fone	  := flt(1.0);

op_scan := x100.newScan(1,1000LL);
returnflag:= x100.addScanParam(op_scan, "l_returnflag");
linestatus:= x100.addScanParam(op_scan, "l_linestatus");
quantity  := x100.addScanParam(op_scan, "l_quantity");
extendedprice  := x100.addScanParam(op_scan, "l_extendedprice");
discount  := x100.addScanParam(op_scan, "l_discount");
tax       := x100.addScanParam(op_scan, "l_tax");
shipdate  := x100.addScanParam(op_scan, "l_shipdate");

f4		:= x100.newFunction("*",fone,discount);
discountprice	:= x100.NewFunction("-",f4,extendedprice);

shipdate     	:= x100.newFunction("<=",shipdate,hd);
discount-one    := x100.newFunction("-",fone,discount);
sum_qty	 	:= x100.newFunction("sum", quantity);
sum_base_price	:= x100.newFunction("sum", extendedprice);
sum_disc_price	:= x100.newFunction("sum", discountprice);
f6		 := x100.newFunction("+", tax,fone);
sumcharge	 := x100.newFunction("*", f6,discountprice);
discount3	 := x100.newFunction("sum",discount);
count		 := x100.newFunction("count");

aggr	:= x100.Aggr(op_select,2,returnflag,linestatus, sum_qty,
		sum_base_price,sum_desc_price, sum_charge, discount3, count);

flt_count:= x100.newFunction("flt",count);
avg_qty		:= x100.newFunction("/",sum_qty,flt_count);
avg_price	:= x100.newFunction("/",sum_base_price,flt_count);
avg_disc	:= x100.newFunction("/",sum_disc_price,flt_count);

result	:= x100.Result(aggr, ???,  sum_charge,
	avg_qty, avg_price, avg_disc, count);
x100.execute(result);

@+ Squeezing performance
Manually squeezing the query leads to a reduction of 51 instructions instead
of 73 (= 30% gain). Most of them involve repeated joins.

@+ Compilation issues
To understand the performance implications of compilation, it would be
good to analyse how a simple compiler would generate code for a basic
MIL block. We take the same query as above and extract the following patterns
that should be supported.
@T
\begin{verbatim}
1;
7776000;
bbp.bind("myc");
date("1998-12-01");
date(nil);
date_sub_sec_interval(s16,s17);
flt(s58);
group.avg(s70,s8,s7);
group.count(s8,s8,s7);
group(s10,);
group(s9,s19);
group.sum(s48,s8,s7);
join(s7,s27);
mark(ca_a,ba_a);
mirror(ea_a,);
multiplex.tactics("*",s39,s40);
multiplex.tactics("-",s45,s43);
multiplex.tactics("+",s61,s59);
mvc_bind(myc,"sys","lineitem","l_discount",0);
oid(0);
refine(s4,s21);
reverse(ga_a,);
reverse(s5,);
sort(fa_a,);
tunique(s8,);
uselect(s14,aa_a,s15);
zipper(s59,s57);
\end(verbatim}
@
Ideally, we just provide simple patterns to be generated by the compiler,
using the underlying C-compiler to squeeze the code for best performance.
Several coding strategies can be followed. A naive approach is to just
introduce as many cursors on the underlying table and to 'walk your way
through the database'.

@+ x100 Algebra statements
The syntax representation is very difficult to comprehend. A user would
immediately decompose into subexpressions of convenient size;

@T
\begin{verbatim}
# Test 1 x100 algebra expression
Project(Aggr(Select(Scan(%MEMCHUNK,%IOCHUNK,
	[l_returnflag=Column("L.returnflag"), l_linestatus=Column("L.linestatus"),
	 l_quantity=Column("L.quantity"), l_extendedprice=Column("L.extendedprice"),
	 l_discount=Column("L.discount"), l_tax=Column("L.tax", l_shipdate=Column("L.shipdate"))
              <=(l_shipdate,%DATE)),
         TRUE, 2,
        [l1 = l_returnflag, l2 = l_linestatus
         sum_qty = sum(l_quantity),
         sum_base_price = sum(l_extendedprice),
         sum_disc_price = sum(discountprice = (1.0-l_discount)*l_extendedprice),
         sum_charge = sum((tax+1.0)*discountprice),
         sum_disc = sum(discount),
         count = count()])
    [l1, l2, sum_qty, sum_base_price, sum_disc_price, sum_charge,
     avg_qty = sum_qty/flt_count = flt(count),
     avg_price = sum_base_price/flt_count,
     avg_disc = sum_disc/flt_count,
     count]
\end{verbatim}
The squeeze sorted version obtained from the SQL->MAL compiler would produce
\begin{verbatim}

# A Manually Squeezed q1
# remove superflous assignments, e.g. jj:= fcn(x); jk:= jj;
# sort operation. First collect all functions depending on constants
	s16 := date("1998-12-01");
	s17 := 7776000;
	aa_a := date(nil);
	ba_a := oid(0);
	s42 := flt(1);
	myc:= bbp.bind("myc");
# collect all functions that depend on a constant variables only
	s15 := date_sub_sec_interval(s16,s17);
# collect all functions that depend on anything known sofar
	s14 := mvc_bind(myc,"sys","lineitem","l_shipdate",0);
	s18 := mvc_bind(myc,"sys","lineitem","l_returnflag",0);
	s20 := mvc_bind(myc,"sys","lineitem","l_linestatus",0);
	s31 := mvc_bind(myc,"sys","lineitem","l_quantity",0);
	s35 := mvc_bind(myc,"sys","lineitem","l_extendedprice",0);
	s44 := mvc_bind(myc,"sys","lineitem","l_discount",0);
	s60 := mvc_bind(myc,"sys","lineitem","l_tax",0);
	s13 := uselect(s14,aa_a,s15);
	s12 := reverse(s13);
	ca_a := reverse(s12);
	da_a := mark(ca_a,ba_a);
	s11 := reverse(da_a);
	s10 := join(s11,s18);
	s19 := join(s11,s20);
	s9 := group(s10);
	s8 := group(s9,s19);
	ea_a := tunique(s8);
	s7 := mirror(ea_a);
	s6 := join(s7,s11);
	s5 := join(s6,s18);
	fa_a := reverse(s5);
	ga_a := sort(fa_a);
	s4 := reverse(ga_a);
	s21 := join(s6,s20);
	s24 := join(s7,s10);
	s26 := join(s7,s19);
	#s3 := refine(s4,s21);
	s30 := join(s11,s31);
	s34 := join(s11,s35);
	s43 := join(s11,s44);
	s59 := join(s11,s60);
	s45 := zipper(s43,s41);
	s55 := zipper(s43,s42);
	s61 := zipper(s59,s41);
	s40 := multiplex.tactics("-",s45,s43);
	s38 := multiplex.tactics("*",s34,s40);
	s51 := multiplex.tactics("-",s55,s43);
	s49 := multiplex.tactics("*",s34,s51);
	s56 := multiplex.tactics("+",s61,s59);
	s48 := multiplex.tactics("*",s49,s56);
# group by first operand
	s29 := group.sum(s30,s8,s7);
	s33 := group.sum(s34,s8,s7);
	s37 := group.sum(s38,s8,s7);
	s47 := group.sum(s48,s8,s7);
	s63 := group.avg(s30,s8,s7);
	s66 := group.avg(s34,s8,s7);
	s69 := group.avg(s43,s8,s7);
	s72 := group.count(s8,s8,s7);
\end{verbatim}


#test 2 algebra expression
Aggr(FetchJoin(FetchJoin(Project(Array([I = Dimension(%i), M = Dimension(%m), C
= Dimension(%c), D = Dimension(%d)]),
                                 [ IDX1 = +(I, *(%i, M)),
                                   IDX2 = +(I, *(%i, +(C, *(%c, D)))),
                                   IDX3 = +(M, *(%m, +(C, *(%c, D)))) ]),
                         IDX1, [X = samples.x]),
               IDX2, [MU = stddist.mu, S2 = stddist.s2])
     [IDX3], [sum(/(*(XMU = -(X,MU), XMU), S2))])
