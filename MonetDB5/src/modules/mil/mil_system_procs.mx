@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2006 CWI.
@' All Rights Reserved.

@f mil_system_procs
@a Martin Kersten
@* MIL algebra extensions
MonetDB 5 supports running MIL programs compiled by M2m.
The resulting code needs PROC definitions of version 4, which
are assembled in this package.

Most of the version 4 code is heavily dependent on the 
meta-information administration. This can not easily be
converted automatically. Instead, the PROCs supported
are introduced selectively.

The code is manually patched to reflect the different
return values for replace()
@mal
module mil_sys_procs;

function dir(b:bat[:int,:str]):void;
	nme := bbp.getNames();
	ht := bbp.getHeadType();
	tt := bbp.getTailType();
	cnt := bbp.getCount();
	heat := bbp.getHeat();
	aa_a := bat.setColumn(heat,"heat");
	dirty := bbp.getDirty();
	ba_a := bat.setColumn(dirty,"dirty");
	status := bbp.getStatus();
	ca_a := bat.setColumn(status,"status");
	kind := bbp.getKind();
	da_a := bat.setColumn(kind,"kind");
	refcnt := bbp.getRefCount();
	ea_a := bat.setColumn(refcnt,"refcnt");
	lrefcnt := bbp.getLRefCount();
	fa_a := bat.setColumn(lrefcnt,"lrefcnt");
	ga_a := bat.setColumn(b,"name");
	ha_a := bat.reverse(b);
	ia_a := algebra.sort(ha_a);
	ja_a := bat.reverse(ia_a);
	ka_a := algebra.semijoin(ht,b);
	la_a := algebra.semijoin(tt,b);
	ma_a := algebra.semijoin(cnt,b);
	na_a := io.table(1,ja_a,ka_a,la_a,ma_a,heat,dirty,status,kind,refcnt,lrefcnt);
end dir;
function dir():void;
	oa_a := bbp.getNames();
	nme := algebra.copy(oa_a);
	BAT_WRITE:= 0;
	pa_a := bat.access(nme,BAT_WRITE);
	qa_a := bat.setColumn(nme,"name");
	ra_a := calc.int(nil);
	sa_a := bat.reverse(nme);
	ta_a := algebra.select(sa_a,ra_a,-1);
	ua_a := batcalc.*(ta_a,-1);
	rev := bat.reverse(ua_a);
	va_a := bat.replace(nme,rev);
	wa_a := mil_sys_procs.dir(nme);
end dir;
function dir(substr:str):void;
	xa_a := bbp.getNames();
	nme := algebra.like(xa_a,substr);
	BAT_WRITE:= 0;
	ya_a := bat.access(nme,BAT_WRITE);
	ab_a := bat.setColumn(nme,"name");
	bb_a := calc.int(nil);
	cb_a := bat.reverse(nme);
	db_a := algebra.select(cb_a,bb_a,-1);
	eb_a := batcalc.*(db_a,-1);
	rev := bat.reverse(eb_a);
	fb_a := bat.replace(nme,rev);
	gb_a := mil_sys_procs.dir(nme);
end dir;
function ls():void;
	nme := bbp.getNames();
	hb_a := bbp.getKind();
	ib_a := algebra.select(hb_a,"pers");
	prs := algebra.semijoin(nme,ib_a);
	jb_a := calc.int(nil);
	kb_a := bat.reverse(nme);
	lb_a := algebra.select(kb_a,jb_a,-1);
	mb_a := batcalc.*(lb_a,-1);
	rev := bat.reverse(mb_a);
	BAT_WRITE:= 0;
	nb_a := bat.access(prs,BAT_WRITE);
	ob_a := bat.setColumn(prs,"name");
	pb_a := bat.replace(prs,rev);
	qb_a := mil_sys_procs.dir(prs);
end ls;
function ls(substr:str):void;
	nme := bbp.getNames();
	rb_a := bbp.getKind();
	sb_a := algebra.select(rb_a,"pers");
	prs := algebra.semijoin(nme,sb_a);
	tb_a := calc.int(nil);
	ub_a := bat.reverse(nme);
	vb_a := algebra.select(ub_a,tb_a,-1);
	wb_a := batcalc.*(vb_a,-1);
	rev := bat.reverse(wb_a);
	BAT_WRITE:= 0;
	xb_a := bat.access(prs,BAT_WRITE);
	yb_a := bat.setColumn(prs,"name");
	ac_a := bat.replace(prs,rev);
	bc_a := algebra.like(prs,substr);
	cc_a := mil_sys_procs.dir(prs);
end ls;
@- Original code
The original code has been patched to reflect the differences
in return types and calls to get*Type.
@mil
    proc dir(bat[int,str] b) : void {
        var nme := view_bbp_name();
        var ht  := view_bbp_htype();
        var tt  := view_bbp_ttype();
        var cnt  := view_bbp_count();

	var heat :=  view_bbp_heat(); heat.col_name("heat");
	var dirty :=  view_bbp_dirty(); dirty.col_name("dirty");
	var status :=  view_bbp_status(); status.col_name("status");
	var kind :=  view_bbp_kind(); kind.col_name("kind");
	var refcnt :=  view_bbp_refcnt(); refcnt.col_name("refcnt");
	var lrefcnt :=  view_bbp_lrefcnt(); lrefcnt.col_name("lrefcnt");


	b.col_name("name");
        table(1, b.reverse().sort().reverse(),
                ht.semijoin(b),
                tt.semijoin(b),
                cnt.semijoin(b),
		heat, dirty,status,kind,refcnt,lrefcnt);
    }
    PROC dir() : void {
        var nme := view_bbp_name().copy();
	nme.access(BAT_WRITE);
	nme.col_name("name");
	var rev := [*](nme.reverse().select(int(nil),-1),-1).reverse();
	dir(nme.replace(rev));
    }
    PROC dir(str substr) : void {
        var nme := view_bbp_name().like(substr);
	nme.access(BAT_WRITE);
	nme.col_name("name");
        var rev := [*](nme.reverse().select(int(nil),-1),-1).reverse();
        dir(nme.replace(rev));
    }
    PROC ls() : void {
        var nme := view_bbp_name();
        var prs := nme.semijoin(view_bbp_kind().select("pers"));
        var rev := [*](nme.reverse().select(int(nil),-1),-1).reverse();
        prs.access(BAT_WRITE);
	prs.col_name("name");
	prs.replace(rev);
	dir(prs);
    }
    PROC ls(str substr) : void {
        var nme := view_bbp_name();
        var prs := nme.semijoin(view_bbp_kind().select("pers"));
        var rev := [*](nme.reverse().select(int(nil),-1),-1).reverse();
        prs.access(BAT_WRITE);
	prs.col_name("name");
	prs.replace(rev);
        dir(prs.like(substr));
    }
@-
Dummy C code
@c
