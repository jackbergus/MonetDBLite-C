@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2006 CWI.
@' All Rights Reserved.

@f mil_algebra_procs
@a Martin Kersten
@* MIL algebra extensions
MonetDB 5 supports running MIL programs compiled by M2m.
The resulting code needs PROC definitions of version 4, which
are assembled in this package.

We removed the ADDHELP functionality, because
M5 does not use the same catalog infrastructure 
Several procs were removed, because they seemed
to be unnecessary or complicates the handling in M5 
(polymorphic anonymous types)


The mal code was produced using
	M2m --trace=0 mil_algebra_procs.mil
[The trace flag removes the comment lines]

This files contains a patch of the sort_ht operation
to allow for proper cloning
@mal
module mil_algebra_procs;

function clear(b:bat[:any_1,:any_2]):bat[:any_1,:any_2];
	bat.delete(b);
	return b;
end clear;
function unique(b:bat[:any_1,:any_2]):bat[:any_1,:any_2];
	algebra.sunique(b);
	return b;
end unique;
function diff(b1:bat[:any_1,:any_2], b2:bat[:any_1,:any_2]):bat[:any_1,:any_2];
	return ca_a :=algebra.sdiff(b1,b2);
end diff;
function intersect(b1:bat[:any_1,:any_2], b2:bat[:any_1,:any_2]):bat[:any_1,:any_2];
	return da_a :=algebra.sintersect(b1,b2);
end intersect;
function union(b1:bat[:any_1,:any_2], b2:bat[:any_1,:any_2]):bat[:any_1,:any_2];
	return ea_a :=algebra.sunion(b1,b2);
end union;
function project(b:bat[:any_1,:any]):bat[:any_1,:void];
	return fa_a :=algebra.project(b,nil);
end project;
function outerjoin(left:bat[:any_1,:any_2], right:bat[:any_2,:any_3]):bat[:any_1,:any_3];
	ga_a := calc.lng(nil);
	return ha_a :=algebra.outerjoin(left,right,ga_a);
end outerjoin;

function avg(b:bat[:any_1,:sht]):dbl;
	cnt := aggr.count(b);
barrier	oe_a := calc.==(cnt,0);
	return pe_a :=calc.dbl(nil);
exit	oe_a;
	qe_a := aggr.sum(b);
	re_a := calc.dbl(qe_a);
	se_a := calc.dbl(cnt);
	return te_a :=calc./(re_a,se_a);
end avg;
function avg(b:bat[:any_1,:int]):dbl;
	cnt := aggr.count(b);
barrier	ue_a := calc.==(cnt,0);
	return ve_a :=calc.dbl(nil);
exit	ue_a;
	we_a := aggr.sum(b);
	xe_a := calc.dbl(we_a);
	ye_a := calc.dbl(cnt);
	return af_a :=calc./(xe_a,ye_a);
end avg;
function avg(b:bat[:any_1,:lng]):dbl;
	cnt := aggr.count(b);
barrier	bf_a := calc.==(cnt,0);
	return cf_a :=calc.dbl(nil);
exit	bf_a;
	df_a := aggr.sum(b);
	ef_a := calc.dbl(df_a);
	ff_a := calc.dbl(cnt);
	return gf_a :=calc./(ef_a,ff_a);
end avg;
function avg(b:bat[:any_1,:flt]):dbl;
	cnt := aggr.count(b);
barrier	hf_a := calc.==(cnt,0);
	return if_a :=calc.dbl(nil);
exit	hf_a;
	jf_a := aggr.sum(b);
	kf_a := calc.dbl(jf_a);
	lf_a := calc.dbl(cnt);
	return mf_a :=calc./(kf_a,lf_a);
end avg;
function avg(b:bat[:any_1,:dbl]):dbl;
	cnt := aggr.count(b);
barrier	nf_a := calc.==(cnt,0);
	return of_a :=calc.dbl(nil);
exit	nf_a;
	pf_a := aggr.sum(b);
	qf_a := calc.dbl(pf_a);
	rf_a := calc.dbl(cnt);
	return sf_a := calc./(qf_a,rf_a);
end avg;
@- Original code
@mil

    proc sum( bat[any,sht] b ) : sht { return sum_sht(b); }
    proc prod( bat[any,sht] b ) : sht { return prod_sht(b); }


    proc sum( bat[any,int] b ) : int { return sum_int(b); }
    proc prod( bat[any,int] b ) : int { return prod_int(b); }


    proc sum( bat[any,lng] b ) : lng { return sum_lng(b); }
    proc prod( bat[any,lng] b ) : lng { return prod_lng(b); }


    proc sum( bat[any,flt] b ) : flt { return sum_flt(b); }
    proc prod( bat[any,flt] b ) : flt { return prod_flt(b); }


    proc sum( bat[any,dbl] b ) : dbl { return sum_dbl(b); }
    proc prod( bat[any,dbl] b ) : dbl { return prod_dbl(b); }


    proc avg(BAT[any, sht] b) : dbl {
	var cnt := count(b);
        if (cnt = 0) 
	    return dbl(nil);
	return dbl(sum_lng(b))/dbl(cnt);
    }
#    ADDHELP("avg", "manegold", "May 14 2003",
#            "Gives the average of all tail values.", "algebra");




    proc avg(BAT[any, int] b) : dbl {
	var cnt := count(b);
        if (cnt = 0) 
	    return dbl(nil);
	return dbl(sum_lng(b))/dbl(cnt);
    }
#    ADDHELP("avg", "manegold", "May 14 2003",
#            "Gives the average of all tail values.", "algebra");


    proc avg(BAT[any, lng] b) : dbl {
	var cnt := count(b);
        if (cnt = 0) 
	    return dbl(nil);
	return dbl(sum(b))/dbl(cnt);
    }
#    ADDHELP("avg", "manegold", "May 14 2003",
#            "Gives the average of all tail values.", "algebra");

    proc avg(BAT[any, flt] b) : dbl {
	var cnt := count(b);
        if (cnt = 0) 
	    return dbl(nil);
	return dbl(sum(b))/dbl(cnt);
    }
#    ADDHELP("avg", "manegold", "May 14 2003",
#            "Gives the average of all tail values.", "algebra");


    proc avg(BAT[any, dbl] b) : dbl {
	var cnt := count(b);
        if (cnt = 0) 
	    return dbl(nil);
	return dbl(sum(b))/dbl(cnt);
    }
#    ADDHELP("avg", "manegold", "May 14 2003",
#            "Gives the average of all tail values.", "algebra");


    proc count_no_nil(BAT[any,any] b) : int {
		return count(b,TRUE);
    }
#    ADDHELP("count_no_nil", "manegold", "Jun 03 2003",
#    "short-cut for count(b,TRUE)", "algebra");

@-
Dummy C code
@c
