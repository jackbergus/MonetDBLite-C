@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2006 CWI.
@' All Rights Reserved.

@f mil_utils
@a Martin Kersten
@v 0.1
@* MIL support box
This module implements the links necessary to run
a MIL program against the version 5 kernel.
In particular, this calls for name resolution into
either a global variable, or access to a BAT.
The box contains all constants defined in the original
MIL modules.

The mil module provides a box abstraction
to store for global MIL constants.
Between sessions the value of the constants 
is saved on disk in the form of a simple 
MAL program, which is scanned and made 
available by opening the box. A future 
implementation should provide transaction 
support over the box, which would permit 
multiple clients to exchange (scalar) 
information easily.
@mal
module mil_utils;

pattern mil.open():void
address MILopen
comment "Locate and open the MIL constant box";
pattern mil.close():void
address MILclose
comment "Close the MIL constant box ";
pattern mil.destroy():void
address MILdestroy
comment "Destroy the MIL box";
pattern mil.take(name:str):any_1
address MILtake
comment "Locate and take the typed value";
pattern mil.deposit(name:str,val:any_1) :void 		
address MILdeposit
comment "Enter a new value into the box";

pattern mil.releaseAll():void 
address MILreleaseAll
comment "Release all constants";
pattern mil.release(name:str) :void 		
address MILrelease
comment "Release a new constant value";
pattern mil.toString(name:str):str 
address MILtoString
comment "Get the string representation 
	of an element in the box";
pattern mil.discard(name:str) :void 		
address MILdiscard
comment "Release the const from the box";
command mil.iterator() (:lng,:str)
address MILnewIterator
comment "Locate next element in the box";
command mil.hasMoreElements()(:lng,:str)
address MILhasMoreElements
comment "Locate next element in the box";


command prelude():void 
address MILutils_prelude
comment "Initialize the const box";


@-
To simplify backward compatibility we introduce here a series
of operators that behave differently in the M5 context.
Note that we can not always simply rely on the overloading scheme,
either way we define the resolution order 'mil'-'bat' there
will be cases not accounted for. 
If MIL is intended, the compiler writer/user should explicitly
use the mil module denotation.
@mal
command mil.sort( b:bat[:any_1,:any_2]) :bat[:any_1,:any_2]
address ALGhsort
comment "Returns a BAT copy sorted on the head column.";

@mal
command mil.insert(b:bat[:any_1,:any_2], h:any_1, t:any_2) :bat[:any_1,:any_2]
address MILinsert_bun
comment "Insert one BUN[h,t] in a BAT.";
command mil.insert(b:bat[:void,:any_2], h:oid, t:any_2) :bat[:oid,:any_2]
address MILinsert_bun;
@-
Compatibility code wrappers
@c
#include "mal.h"
#include "bat5.h"
#include "mil_utils.h"
#include "mal_utils.h"
#include "streams.h"

#include "mal.h"
#include "mal_client.h"
#include "mal_interpreter.h"
#include "mal_authorize.h"

#ifdef _MIL_UTILS_H
#define _MIL_UTILS_H
mal_export str MILline(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
mal_export str MILhasMoreElements(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
mal_export str MILnewIterator(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
mal_export str MILtoString(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
mal_export str MILdiscard(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
mal_export str MILreleaseAll(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
mal_export str MILrelease(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
mal_export str MILtake(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
mal_export str MILdeposit(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
mal_export str MILdestroy(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
mal_export str MILclose(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
mal_export str MILopen(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
mal_export str MILutils_prelude();
mal_export str MILinsert_bun(int *r, int *bid, ptr h, ptr t);
mal_export str MILinsert_void_bun(int *r, int *bid, ptr t);
#endif

str
MILinsert_void_bun(int *r, int *bid, ptr t)
{
	*r = *bid;
	return BKCinsert_void_bun(r, bid, t);
}

str
MILinsert_bun(int *r, int *bid, ptr h, ptr t)
{
	*r = *bid;
	return BKCinsert_bun(r, bid, h, t);
}

@-
Version 4 contains a series of predefined constants.
They are stored in a BOX for retrieval.
@mal
mil_utils.prelude();

#theta join operator encoding
EQ :=0;
LT :=-1;
LE :=-2;
GT :=1;
GE :=2;

STORE_MEM :=0;
STORE_MMAP :=1;
STORE_COMPR :=2;

BUF_NORMAL :=0;
BUF_RANDOM :=1;
BUF_SEQUENTIAL :=2;
BUF_WILLNEED :=3;
BUF_DONTNEED :=4;
EBUSY :=16;

BAT_READ   := 1; # allow only read access.
BAT_APPEND := 2; # allow reads and insertions.
BAT_WRITE  := 0; # allow reads, insertions, and updates.

M_E :=2.7182818284590452354LL;
M_LOG2E :=1.4426950408889634074LL;
M_LOG10E :=0.43429448190325182765LL;
M_LN2 :=0.69314718055994530942LL;
M_LN10 :=2.30258509299404568402LL;
M_PI :=3.14159265358979323846LL;
M_PI_2 :=1.57079632679489661923LL;
M_PI_4 :=0.78539816339744830962LL;
M_1_PI :=0.31830988618379067154LL;
M_2_PI :=0.63661977236758134308LL;
M_2_SQRTPI :=1.12837916709551257390LL;
M_SQRT2 :=1.41421356237309504880LL;
M_SQRT1_2 :=0.70710678118654752440LL;

mil.deposit("EQ",EQ);
mil.deposit("LT",LT);
mil.deposit("LE",LE);
mil.deposit("GT",GT);
mil.deposit("GE",GE);
mil.deposit("STORE_MEM",STORE_MEM);
mil.deposit("STORE_MMAP",STORE_MMAP);
mil.deposit("STORE_COMPR",STORE_COMPR);
mil.deposit("BUF_NORMAL",BUF_NORMAL);
mil.deposit("BUF_RANDOM",BUF_RANDOM);
mil.deposit("BUF_SEQUENTIAL",BUF_SEQUENTIAL);
mil.deposit("BUF_WILLNEED",BUF_WILLNEED);
mil.deposit("BUF_DONTNEED",BUF_DONTNEED);
mil.deposit("EBUSY",EBUSY);
mil.deposit("BAT_READ",BAT_READ);
mil.deposit("BAT_APPEND",BAT_APPEND);
mil.deposit("BAT_WRITE",BAT_WRITE);
mil.deposit("M_E",M_E);
mil.deposit("M_LOG2E",M_LOG2E);
mil.deposit("M_LOG10E",M_LOG10E);
mil.deposit("M_LN2",M_LN2);
mil.deposit("M_LN10",M_LN10);
mil.deposit("M_PI",M_PI);
mil.deposit("M_PI_2",M_PI_2);
mil.deposit("M_PI_4",M_PI_4);
mil.deposit("M_1_PI",M_1_PI);
mil.deposit("M_2_PI",M_2_PI);
mil.deposit("M_2_SQRTPI",M_2_SQRTPI);
mil.deposit("M_SQRT2",M_SQRT2);
mil.deposit("M_SQRT1_2",M_SQRT1_2);
@-
@{
@+ Implementation
@h
#ifndef _ITERATOR_H
#define _ITERATOR_H
#endif /* _ITERATOR_H */
@- Module initializaton
The content of this box my only be changed by the Administrator.
@= authorize
	{
		str tmp = NULL;
		rethrow("mil_utils.@1", tmp, AUTHrequireAdmin());
	}
@-
@= insertBox
	msg = @2;
	insertToBox(box,@1,msg);
	GDKfree(msg);
@c

str
MILutils_prelude()
{
	Box box;

	@:authorize(prelude)@
	box = openBox("mil");
	if (box == 0)
		return throwMessage("mil_utils.prelude", "failed to open box");
	/* if the box was already filled we can skip initialization */
	if (box->sym->vtop == 0) {
		/* old bat.mx and algebra.mx constants */
	}
	return MAL_SUCCEED;
}

@- Operator implementation
@c
str
MILopen(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	(void) mb;
	(void) stk;
	(void) pci;		/* fool compiler */
	if (openBox("mil.open") != 0)
		return MAL_SUCCEED;
	return throwMessage("mil.open", "failed to open box");
}

str
MILclose(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	(void) mb;
	(void) stk;
	(void) pci;		/* fool compiler */
	if (closeBox("mil", TRUE) == 0)
		return MAL_SUCCEED;
	return throwMessage("mil.close", "failed to close box");
}

str
MILdestroy(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	Box box;

	(void) mb;
	(void) stk;
	(void) pci;		/* fool compiler */
	@:OpenBox(destroy)@
	destroyBox("mil");
	return MAL_SUCCEED;
}

@-
Access to a box calls for resolving the first parameter
to a named box.
@= OpenBox
	box= findBox("mil");
	if( box ==0) 
	return throwMessage("mil.@1","box is not open");
@-
@c
str
MILdeposit(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	str name;
	ValPtr v;
	Box box;
	(void) mb;

	@:authorize(@1)@
	@:OpenBox(deposit)@
	name = (str) getArgValue(stk, pci, 1);
	v = &stk->stk[pci->argv[2]];
	if (depositBox(box, name, v))
		return throwException(MALEXCEPTION, "mil.deposit", "failed to deposit '%s' into box", name);
	return MAL_SUCCEED;
}

@-
We first have to take the element from the constant box.
If we fail, the name could refer to a BAT
@c
str
MILtake(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	str name;
	Box box;
	ValPtr v;
	int tpe;

	@:OpenBox(take)@
	name = *(str *) getArgReference(stk, pci, 1);
	tpe = (int) getArgType(mb, pci, 0);
	(void) tpe;
	v = &stk->stk[pci->argv[0]];
	if (takeBox(box, name, v, tpe)) {
		return throwException(MALEXCEPTION, "mil.take", "failed to take '%s' from box", name);
	}
	/* also keep the copy in the variable */
	VALcopy(&stk->stk[pci->argv[1]], v);
	return MAL_SUCCEED;
}

str
MILrelease(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	str name;
	Box box;

	(void) stk;		/* fool compiler */

	@:OpenBox(release)@
	name = (str) getArgValue(stk, pci, 1);
	releaseBox(box, name);
	(void) mb;
	return MAL_SUCCEED;
}

str
MILreleaseAll(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	Box box;

	(void) mb;
	(void) stk;
	(void) pci;		/* fool compiler */
	@:OpenBox(release)@
	releaseAllBox(box);
	return MAL_SUCCEED;
}

str
MILdiscard(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	str name;
	Box box;

	(void) mb;		/* fool compiler */
	@:OpenBox(discard)@
	name = (str) getArgValue(stk, pci, 1);
	if (discardBox(box, name) == 0)
		return throwException(MALEXCEPTION, "mil.discard", "failed to discard '%s' from box", name);
	return MAL_SUCCEED;
}

str
MILtoString(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	Box box;
	int i, len = 0;
	ValPtr v;
	str nme, s = 0;

	(void) mb;		/* fool compiler */
	@:OpenBox(toString)@
	nme = (str) getArgValue(stk, pci, 1);
	i = findVariable(box->sym, nme);
	if (i < 0)
		return throwException(MALEXCEPTION, "mil.toString", "failed to take '%s' from box", nme);

	v = &box->val->stk[i];
	garbageElement(&stk->stk[pci->argv[0]]);

	if (v->vtype == TYPE_str)
		s = v->val.sval;
	else
		(*BATatoms[v->vtype].atomToStr) (&s, &len, v);
	if (s == NULL)
		return throwMessage("mil.toString", "illegal value");
	VALset(&stk->stk[pci->argv[0]], TYPE_str, s);

	/* if( VALconvert(TYPE_str,v, TRUE) == ILLEGALVALUE) 
	   return throwMessage("mil.toString","illegal value");
	   VALcopy(&stk->stk[pci->argv[0]], v); */
	return MAL_SUCCEED;
}

str
MILnewIterator(lng *cursor, str *v)
{
	Box box;

	@:OpenBox(iterator)@
	*cursor = 0;
	*v= getBoxName(box,*cursor);
	*cursor = 1;
	return MAL_SUCCEED;
}

str
MILhasMoreElements(lng *cursor, str *v)
{
	Box box;

	@:OpenBox(iterator)@
	if( *cursor >= box->sym->vtop){
		*cursor = -1;
		return MAL_SUCCEED;
	}
	*v= getBoxName(box,*cursor);
	*cursor = *cursor + 1;
	return MAL_SUCCEED;
}

str
MILline(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	str nme;
	int len;

	(void) mb;		/* fool compiler */
	nme = (str) getArgValue(stk, pci, 1);
	mal_unquote(nme);
	len = strlen(nme);
	stream_printf(GDKout, "#%s%s", nme, (nme[len - 1] == '\n' ? "" : "\n"));
	return MAL_SUCCEED;
}

@}
