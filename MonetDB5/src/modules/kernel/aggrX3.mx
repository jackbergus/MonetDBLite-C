@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2005 CWI.
@' All Rights Reserved.

@f aggrX3
@a S. Manegold 
@v 1.0
@* Aggregates Module

This module contains some efficient aggregate functions that compute their 
result in one scan, rather than in the iterative manner of the generic 
MIL aggregrate implementations.

The implementation code is derived from the original 'aggr' module. 
It uses a complete type-specific code expansion to avoid any type-checking
in the inner-most loops.
Where feasible, it replaced (expansive) hash-lookup by significantly cheaper positional
void-lookups (if the head-column of the group-extend BAT ("e") is "void") or at least by 
(also positional) array lookups (in case the group-ids span a reasonably small range);

In addition to the 2-parameter {}(BAT[oid,any::1] b, BAT[oid,any] e)
functions, there are now also 3-parameter {}(BAT[void,any::1] b,
BAT[void,oid] g, BAT[oid,any] e) functions, that require b & g to be
head-aligned, and do the fetchjoin(reverse(g),b) on-the-fly;

The routines should not be stored in their own module, but
added to the 'group' module. This can be achieved by setting
the module.

@mal
module aggr;
@= sumprod_signatures
command sum(b:bat[:void,:@1], e:bat[:void,:any_1]) :bat[:void,:@2] 
address AX3aggrX3_sum_@1_@2
comment "Sum over grouped tail sum on @1";

command sum(b:bat[:void,:@1],g:bat[:void,:oid],e:bat[:oid,:any_1])
		:bat[:void,:@2]
address AX3aggrX3_sum3_@1_@2
comment "Grouped tail sum on @1";
command sum(b:bat[:void,:@1],g:bat[:void,:oid],e:bat[:void,:any_1])
		:bat[:void,:@2]
address AX3aggrX3_sum3_@1_@2
comment "Grouped tail sum on @1";

command product(b:bat[:void,:@1], e:bat[:oid,:any_1]) :bat[:void,:@2] 
address AX3aggrX3_prod3_@1_@2
comment "Product over grouped tail @1";

command product(b:bat[:oid,:@1], g:bat[:oid,:oid], e:bat[:oid,:any_1])
		:bat[:oid,:@2] 
address AX3aggrX3_prod3_@1_@2
comment "Product over grouped tail on @1";
command product(b:bat[:void,:@1], g:bat[:void,:oid], e:bat[:void,:any_1])
		:bat[:void,:@2] 
address AX3aggrX3_prod3_@1_@2
comment "Product over grouped on @1";
@mal
@:sumprod_signatures(sht,sht)@
@:sumprod_signatures(sht,int)@
@:sumprod_signatures(sht,lng)@
@:sumprod_signatures(int,int)@
@:sumprod_signatures(int,lng)@
@:sumprod_signatures(lng,lng)@
@:sumprod_signatures(flt,flt)@
@:sumprod_signatures(flt,dbl)@
@:sumprod_signatures(dbl,dbl)@

@= sum_avg_signatures
command avg(b:bat[:oid,:@1], e:bat[:oid,:any_1]) :bat[:oid,:dbl] 
address AX3aggrX3_avg_@1
comment "Grouped tail average on @1";
command avg(b:bat[:void,:@1], e:bat[:void,:any_1]) :bat[:oid,:dbl] 
address AX3aggrX3_avg_@1
comment "Grouped tail average on @1";

command avg(b:bat[:oid,:@1], g:bat[:oid,:oid], e:bat[:oid,:any_1]):bat[:oid,:dbl] 
address AX3aggrX3_avg3_@1
comment "Grouped tail average on @1";
command avg(b:bat[:void,:@1], g:bat[:void,:oid], e:bat[:void,:any_1])
		:bat[:oid,:dbl] 
address AX3aggrX3_avg3_@1
comment "Grouped tail average on @1";

@mal
@:sum_avg_signatures(sht)@
@:sum_avg_signatures(int)@
@:sum_avg_signatures(lng)@
@:sum_avg_signatures(flt)@
@:sum_avg_signatures(dbl)@

# we may have to extend the signatures to all possible {void,oid} combos
command min(b:bat[:void,:any_1], e:bat[:void,:any_2]) :bat[:void,:any_1] 
address AX3aggrX3_min
comment "Grouped tail minimum";
command min(b:bat[:oid,:any_1], e:bat[:oid,:any_2]) :bat[:oid,:any_1] 
address AX3aggrX3_min;

command max(b:bat[:void,:any_1], e:bat[:void,:any_2]) :bat[:void,:any_1] 
address AX3aggrX3_max
comment "Grouped tail maximum";
command max(b:bat[:oid,:any_1], e:bat[:oid,:any_2]) :bat[:oid,:any_1] 
address AX3aggrX3_max;

command min(b:bat[:void,:any_1],g:bat[:void,:oid],e:bat[:oid,:any_2]):bat[:void,:any_1]
address AX3aggrX3_min3
comment "Grouped tail minimum";
command min(b:bat[:void,:any_1],g:bat[:void,:oid],e:bat[:void,:any_2]):bat[:void,:any_1]
address AX3aggrX3_min3;

command max(b:bat[:void,:any_1], g:bat[:void,:oid], e:bat[:oid,:any_2]) 
            :bat[:void,:any_1] 
address AX3aggrX3_max3
comment "Grouped tail maximum";
command max(b:bat[:void,:any_1], g:bat[:void,:oid], e:bat[:void,:any_2]) 
            :bat[:void,:any_1] 
address AX3aggrX3_max3;

command count(b:bat[:void,:any_1], e:bat[:void,:any_2], ignorenils:bit)
	:bat[:void,:int] 
address AX3aggrX3_count
comment "Grouped count";
command count(b:bat[:oid,:any_1], e:bat[:oid,:any_2], ignorenils:bit)
	:bat[:oid,:int] 
address AX3aggrX3_count;

command count(b:bat[:void,:any_1], g:bat[:void,:oid], e:bat[:oid,:any_2], 
	    nonils:bit) :bat[:void,:int] 
address AX3aggrX3_count3
comment "grouped count";
command count(b:bat[:void,:any_1], g:bat[:void,:oid], e:bat[:void,:any_2], 
	    nonils:bit) :bat[:void,:int] 
address AX3aggrX3_count3;

command size(b:bat[:void,:bit], e:bat[:void,:any_1]) :bat[:void,:int] 
address AX3aggrX3_size
comment "Grouped count of true values";

#The MIL procs 2 arguments
command count(b:bat[:void,:any_1], e:bat[:oid,:any_2]) :bat[:void,:int] 
address AX3aggrX3_count2Nils
comment "Grouped count";
command count(b:bat[:void,:any_1], e:bat[:void,:any_2]) :bat[:void,:int] 
address AX3aggrX3_count2Nils;

command count_no_nil(b:bat[:oid,:any_1],e:bat[:oid,:any_1]):bat[:oid,:int]
address AX3count_no_nil2;
command count_no_nil(b:bat[:void,:any_1],e:bat[:void,:any_1]):bat[:oid,:int]
address AX3count_no_nil2;

#The MIL procs 3 arguments
command count(b:bat[:void,:any_1],g:bat[:oid,:oid], e:bat[:oid,:any_2])
	:bat[:void,:int] 
address AX3aggrX3_count3Nils
comment "Grouped count";
command count(b:bat[:void,:any_1],g:bat[:oid,:oid], e:bat[:void,:any_2])
	:bat[:void,:int] 
address AX3aggrX3_count3Nils;

command count_no_nil(b:bat[:oid,:any_1],g:bat[:oid,:oid],e:bat[:oid,:any_1])
	:bat[:oid,:int]
address AX3count_no_nil3;
command count_no_nil(b:bat[:void,:any_1],g:bat[:void,:oid],e:bat[:void,:any_1])
	:bat[:oid,:int]
address AX3count_no_nil3;
@{
@{
@+ Implementation
These implementations need just one scan and a simple hash-maintained data
structure to compute a group of common aggregates.
@c
#include <gdk.h>
#include <gdk_scanselect.h>	/* for type-specific HT_bunfastins_nocheck_noinc(), until they're moved to gdk.mx */

/*
with group OIDs spanning a range of less than SMALL_AGGR_MAX (the actual
number of groups might be even less, in case there are "holes" in the group
OID range), we use a simple array as temporary sum/cnt table on order to
benefit from positional lookups; with size of sum <= 8 bytes and size of
cnt == 4 bytes, we stay below 16 KBytes, i.e., within (almost) any L1 cache
*/
#define SMALL_AGGR_MAX 1024

@-
The macro CHKrange is just for array-lookups, analogously to BUNfntVOID &
HASHfnd_oid for void- and hash-lookups, respectively
@c
#define CHKrange(r, bn, h)	r = (BUN)(((*(oid*)h >= min) && (*(oid*)h <= max))?h:NULL)

@- Result initialization
@c
/*	init_result
	@1:	tail-type:	sht/int/lng/flt/dbl / any / void
*/
@= init_result
{
	REGISTER BUN _p = BUNlast(bn);
	REGISTER int _bunsize = BUNsize(bn);
	REGISTER int _cnt = BATcount(e);

	bn->tsorted = bn->hsorted = 0;
	min = max = (oid) 0;
	ALIGNsetH(bn, e);
	/* set all sums/avgs/counts to zero; for prod, zero is 1 */
	/* where necessary, calculate min/max oid with minimal effort */
	if (e->htype == TYPE_void) {
		oid nil = oid_nil;
		(void) nil;	/* silence compiler about unused variable */
		ALGODEBUG THRprintf(GDKout, "init_result(@1): e->htype == TYPE_void, e->hseqbase=" SZFMT "\n", (size_t) e->hseqbase);
		BATloopFast(e, p, q, xx) {
			void@1_bunfastins_nocheck_noinc(bn, _p, &nil, &zero);
			_p += _bunsize;
		}
		BATseqbase(bn,e->hseqbase);
	} else if (BAThordered(e)&1) {
		min = *(oid*)BUNhloc(e, BUNfirst(e));
		BATloopFast(e, p, q, xx) {
			oid@1_bunfastins_nocheck_noinc(bn, _p, BUNhloc(e,p), &zero);
			_p += _bunsize;
		}
		if (_cnt)
			max = *(oid*)BUNhloc(e, BUNlast(e)-BUNsize(e));
		ALGODEBUG THRprintf(GDKout, "init_result(@1): BAThordered(e)&1, min=" SZFMT ", max=" SZFMT "\n", (size_t) min, (size_t) max);
	} else {
		oid i;
		min = max = *(oid*)BUNhloc(e, BUNfirst(e));
		BATloopFast(e, p, q, xx) {
			oid@1_bunfastins_nocheck_noinc(bn, _p, BUNhloc(e,p), &zero);
			_p += _bunsize;
			i = *(oid*)BUNhloc(e, p);
			if (i < min)
				min = i;
			else if (i > max)
				max = i;
		}
		ALGODEBUG THRprintf(GDKout, "init_result(@1): min=" SZFMT ", max=" SZFMT "\n", (size_t) min, (size_t) max);
	}
	bn->batBuns->free = _p - bn->batBuns->base;
	BATsetcount(bn, bn->batBuns->free/_bunsize);
	if (!bn->batDirty)
		bn->batDirty = TRUE;
}
@- Sum, Product & Average
@c
/*	aggrX3_sum
		e-void-head	e-oid-head	e-oid-head
		void-lookup	hash-lookup	array-lookup

	@1:	0		0		1		use sums-array?
	@2:	0		1		0		do BATprepareHash?
	@3:	BUNfndVOID	HASHfnd_oid	CHKrange	lookup
	@4:	var		loc		loc		e/bn-head-access

	@5:	"BUNhloc(b,p)"	for  (oid) b-head-type,		b-head access
		"&bhsb; bhsb++" for (void) b-head-type

	@6:		sht / int / lng / flt / dbl		b/bn-tail-type
	@7:	"loc" for fixsized b/bn-tail-type,		b/bn-tail-access
		"var" for varsized b/bn-tail-type		(only loc used currently)

	@8:	BUNt@7(bn,r)	BUNt@7(bn,r)	&sums[(*(oid*)h)-min]
								*dst: sum in-place or in sums-array ?
	@9:	result type
*/
@= aggrX3_sum
	ALGODEBUG THRprintf(GDKout, "aggrX3_sum(@1,@2,@3,@4,@5,@6,@7,@8,@9);\n");
	if (@1) {
		/* create tmp. sums array */
		size_t i;
		sums = (@9*) GDKmalloc(range*sizeof(@9));
		for (i = 0; i < range; i++)
			sums[i] = zero;
	}
	if (@2 && BATprepareHash(bn)) {
		if (@1)
			GDKfree(sums);
		BBPreclaim(bn);
		return GDK_FAIL;
	}

	/* scan b, and add values to sums in-place or in sums-array */
	bhsb = b->hseqbase - 1;
	BATloopFast(b, p, q, xx) {
		@6 *t = (@6*) BUNt@7(b,p);
		oid *h = (oid*) @5;

		@3(r, bn, h);
		if (r) {
			@9 *dst = (@9*) @8;
			if (*dst != @9_nil) {
				if (*t == @6_nil) {
					*dst = @9_nil;
				} else {
					*dst += *t;
				}
			}
		}
	}
	if (@1) {
		/* copy sums array to final result */
		BATloopFast(bn, p, q, xx) {
			oid h = (*(oid*) BUNh@4(bn,p)) - min;
			*(@9*)BUNt@7(bn, p) = sums[h];
		}
		GDKfree(sums);
	}
@
@c
/*	aggrX3_prod
		e-void-head	e-oid-head	e-oid-head
		void-lookup	hash-lookup	array-lookup

	@1:	0		0		1		use prods-array?
	@2:	0		1		0		do BATprepareHash?
	@3:	BUNfndVOID	HASHfnd_oid	CHKrange	lookup
	@4:	var		loc		loc		e/bn-head-access

	@5:	"BUNhloc(b,p)"	for  (oid) b-head-type,		b-head access
		"&bhsb; bhsb++" for (void) b-head-type

	@6:		sht / int / lng / flt / dbl		b/bn-tail-type
	@7:	"loc" for fixsized b/bn-tail-type,		b/bn-tail-access
		"var" for varsized b/bn-tail-type		(only loc used currently)

	@8:	BUNt@7(bn,r)	BUNt@7(bn,r)	&prods[(*(oid*)h)-min]
								*dst: prod in-place or in prods-array ?
	@9:	result type
*/
@= aggrX3_prod
	ALGODEBUG THRprintf(GDKout, "aggrX3_prod(@1,@2,@3,@4,@5,@6,@7,@8,@9);\n");
	if (@1) {
		/* create tmp. prods array */
		size_t i;
		prods = (@9*) GDKmalloc(range*sizeof(@9));
		for (i = 0; i < range; i++)
			prods[i] = zero;
	}
	if (@2 && BATprepareHash(bn)) {
		if (@1)
			GDKfree(prods);
		BBPreclaim(bn);
		return GDK_FAIL;
	}
	/* scan b, and mul values to prods in-place or in prods-array */
	bhsb = b->hseqbase - 1;
	BATloopFast(b, p, q, xx) {
		@6 *t = (@6*) BUNt@7(b,p);
		oid *h = (oid*) @5;

		@3(r, bn, h);
		if (r) {
			@9 *dst = (@9*) @8;
			if (*dst != @9_nil) {
				if (*t == @6_nil) {
					*dst = @9_nil;
				} else {
					*dst *= *t;
				}
			}
		}
	}
	if (@1) {
		/* copy prods array to final result */
		BATloopFast(bn, p, q, xx) {
			oid h = (*(oid*) BUNh@4(bn,p)) - min;
			*(@9*)BUNt@7(bn, p) = prods[h];
		}
		GDKfree(prods);
	}
@
@c
/*	aggrX3_avg
		e-void-head	e-oid-head	e-oid-head
		void-lookup	hash-lookup	array-lookup

	@1:	0		0		1		use sums-array?
	@2:	0		1		0		do BATprepareHash?
	@3:	BUNfndVOID	HASHfnd_oid	CHKrange	lookup
	@4:	var		loc		loc		e/bn-head-access

	@5:	"BUNhloc(b,p)"	for  (oid) b-head-type,		b-head access
		"&bhsb; bhsb++" for (void) b-head-type

	@6:		sht / int / lng / flt / dbl		b/bn-tail-type
	@7:	"loc" for fixsized b/bn-tail-type,		b/bn-tail-access
		"var" for varsized b/bn-tail-type		(only loc used currently)

	@8:	BUNt@7(bn,r)	BUNt@7(bn,r)	&sums[(*(oid*)h)-min]
								*dst: sum in-place or in sums-array ?

	@9:	     BUNindex(bn,r)-off		(*(oid*)h)-min	index in cnt array
*/
@= aggrX3_avg
	ALGODEBUG THRprintf(GDKout, "aggrX3_avg(@1,@2,@3,@4,@5,@6,@7,@8,@9);\n");
	if (@1) {
		/* create tmp. sums array */
		size_t i;
		sums = (dbl*) GDKmalloc(range*sizeof(dbl));
		for (i = 0; i < range; i++)
			sums[i] = zero;
	}
	if (@2 && BATprepareHash(bn)) {
		if (@1)
			GDKfree(sums);
		BBPreclaim(bn);
		return GDK_FAIL;
	}
	cnt = (size_t*) GDKmalloc(slots*sizeof(cnt[0]));
	memset(cnt, 0, slots*sizeof(cnt[0]));
	/* scan b, adding sums, and incrementing counts */
	bhsb = b->hseqbase - 1;
	BATloopFast(b, p, q, xx) {
		@6 *t = (@6*) BUNt@7(b,p);
		oid *h = (oid*) @5;

		@3(r, bn, h);
		if (r) {
			dbl *dst = (dbl*) @8;
			if (*dst != dbl_nil) {
				if (*t == @6_nil) {
					*dst = dbl_nil;
				} else {
					*dst += *t;
				}
				cnt[@9]++;
			}
		}
	}
	/* postprocess by dividing sums by counts */
	if (@1) {
		/* sums in sums-array */
		BATloopFast(bn, p, q, xx) {
			oid h = (*(oid*) BUNh@4(bn,p)) - min;
			dbl *dst = (dbl*) BUNt@7(bn, p);
			if (cnt[h] == 0 || sums[h] == dbl_nil) {
				*dst = dbl_nil;
			} else {
				*dst = (dbl) (sums[h]/cnt[h]);
			}
		}
		GDKfree(sums);
	} else {
		/* sums in-place */
		size_t yy = 0;
		BATloopFast(bn, p, q, xx) {
			dbl *dst = (dbl*) BUNt@7(bn, p);
			if (cnt[yy] == 0) {
				*dst = dbl_nil;
			} else if (*dst != dbl_nil) {
				*dst = (dbl) (*dst / cnt[yy]);
			}
			yy++;
		}

	}
	GDKfree(cnt);
@c

/*	arithsum
	@6:		sht / int / lng / flt / dbl	b/bn-tail-type
	@7:	"loc" for fixsized b/bn-tail-type,	b/bn-tail-access
		"var" for varsized b/bn-tail-type	(only loc used currently)
	@9:	result type
*/
@= arithsum
int
CMDaggrX3_sum_@1_@3(BAT **ret, BAT *b, BAT *e)
{
	BAT *bn = BATnew(e->htype, TYPE_@3, BATcount(e));
	@3 zero = (@3) 0, *sums;
	BUN p, q, r;
	int xx;
	size_t range;
	oid min, max;
	oid bhsb;

	if( bn == NULL)
		return GDK_FAIL;
	ALGODEBUG THRprintf(GDKout, "CMDaggrX3_sum_@1_@3[@2](b=%s,e=%s);\n",
		BATgetId(b), BATgetId(e));
	/* init: set all sums to zero and calculate min/max oid */
	@:init_result(@3)@
	range = max - min + 1;

	/* scan b, and calculate sums */
	if (e->htype == TYPE_void) {
		/* void lookup */
		if (b->htype == TYPE_void) {
			@:aggrX3_sum(0,0,BUNfndVOID,var,&bhsb;bhsb++,@1,@2,BUNt@2(bn,r),@3)@
		} else {
			@:aggrX3_sum(0,0,BUNfndVOID,var,BUNhloc(b,p),@1,@2,BUNt@2(bn,r),@3)@
		}
	/* e->htype == TYPE_oid */
	} else if (range > SMALL_AGGR_MAX) {
		/* hash lookup */
		if (b->htype == TYPE_void) {
			@:aggrX3_sum(0,1,HASHfnd_oid,loc,&bhsb;bhsb++,@1,@2,BUNt@2(bn,r),@3)@
		} else {
			@:aggrX3_sum(0,1,HASHfnd_oid,loc,BUNhloc(b,p),@1,@2,BUNt@2(bn,r),@3)@
		}
	} else {
		/* array lookup */
		if (b->htype == TYPE_void) {
			@:aggrX3_sum(1,0,CHKrange,loc,&bhsb;bhsb++,@1,@2,&sums[(*(oid*)h)-min],@3)@
		} else {
			@:aggrX3_sum(1,0,CHKrange,loc,BUNhloc(b,p),@1,@2,&sums[(*(oid*)h)-min],@3)@
		}
	}

	*ret = bn;
	return GDK_SUCCEED;
}
@c

/*	arithprod
	@6:		sht / int / lng / flt / dbl	b/bn-tail-type
	@7:	"loc" for fixsized b/bn-tail-type,	b/bn-tail-access
		"var" for varsized b/bn-tail-type	(only loc used currently)
	@9:	result type
*/
@= arithprod
int
CMDaggrX3_prod_@1_@3(BAT **ret, BAT *b, BAT *e)
{
	BAT *bn = BATnew(e->htype, TYPE_@3, BATcount(e));
	@3 zero = (@3) 1, *prods;
	BUN p, q, r;
	int xx;
	size_t range;
	oid min, max;
	oid bhsb;

	if( bn == NULL)
		return GDK_FAIL;
	ALGODEBUG THRprintf(GDKout, "CMDaggrX3_prod_@1_@3[@2](b=%s,e=%s);\n",
		BATgetId(b), BATgetId(e));
	/* init: set all prods to zero and calculate min/max oid */
	@:init_result(@3)@
	range = max - min + 1;

	/* scan b, and calculate prods */
	if (e->htype == TYPE_void) {
		/* void lookup */
		if (b->htype == TYPE_void) {
			@:aggrX3_prod(0,0,BUNfndVOID,var,&bhsb;bhsb++,@1,@2,BUNt@2(bn,r),@3)@
		} else {
			@:aggrX3_prod(0,0,BUNfndVOID,var,BUNhloc(b,p),@1,@2,BUNt@2(bn,r),@3)@
		}
	/* e->htype == TYPE_oid */
	} else if (range > SMALL_AGGR_MAX) {
		/* hash lookup */
		if (b->htype == TYPE_void) {
			@:aggrX3_prod(0,1,HASHfnd_oid,loc,&bhsb;bhsb++,@1,@2,BUNt@2(bn,r),@3)@
		} else {
			@:aggrX3_prod(0,1,HASHfnd_oid,loc,BUNhloc(b,p),@1,@2,BUNt@2(bn,r),@3)@
		}
	} else {
		/* array lookup */
		if (b->htype == TYPE_void) {
			@:aggrX3_prod(1,0,CHKrange,loc,&bhsb;bhsb++,@1,@2,&prods[(*(oid*)h)-min],@3)@
		} else {
			@:aggrX3_prod(1,0,CHKrange,loc,BUNhloc(b,p),@1,@2,&prods[(*(oid*)h)-min],@3)@
		}
	}

	*ret = bn;
	return GDK_SUCCEED;
}
@c

/*	arithsumprod
	@6:		sht / int / lng / flt / dbl	b/bn-tail-type
	@7:	"loc" for fixsized b/bn-tail-type,	b/bn-tail-access
		"var" for varsized b/bn-tail-type	(only loc used currently)
	@9:	result type
*/
@= arithsumprod
@:arithsum(@1,@2,@3)@
@:arithprod(@1,@2,@3)@
@c
@:arithsumprod(sht,loc,sht)@
@:arithsumprod(sht,loc,int)@
@:arithsumprod(sht,loc,lng)@
@:arithsumprod(int,loc,int)@
@:arithsumprod(int,loc,lng)@
@:arithsumprod(lng,loc,lng)@
@:arithsumprod(flt,loc,flt)@
@:arithsumprod(flt,loc,dbl)@
@:arithsumprod(dbl,loc,dbl)@

/*	arithavg
	@6:		sht / int / lng / flt / dbl	b/bn-tail-type
	@7:	"loc" for fixsized b/bn-tail-type,	b/bn-tail-access
		"var" for varsized b/bn-tail-type	(only loc used currently)
*/
@= arithavg
int
CMDaggrX3_avg_@1(BAT **ret, BAT *b, BAT *e)
{
	BAT *bn = BATnew(e->htype, TYPE_dbl, BATcount(e));
	int xx;
	size_t off;
	size_t *cnt;
	size_t slots, range;
	oid min, max;
	dbl zero = (dbl) 0, *sums;
	BUN p, q, r;
	oid bhsb;

	if( bn == NULL)
		return GDK_FAIL;
	off = BUNindex(bn,BUNfirst(bn));

	ALGODEBUG THRprintf(GDKout, "CMDaggrX3_avg_@1[@2](b=%s,e=%s);\n",
		BATgetId(b),BATgetId(e));
	/* init: set all sums & counts to zero and calculate min/max oid */
	@:init_result(dbl)@
	range = max - min + 1;

	/* scan b, calculate sums & counts, derive averages */
	if (e->htype == TYPE_void) {
		/* void lookup */
		slots = BATcount(e);
		if (b->htype == TYPE_void) {
			@:aggrX3_avg(0,0,BUNfndVOID,var,&bhsb;bhsb++,@1,@2,BUNt@2(bn,r),BUNindex(bn,r)-off)@
		} else {
			@:aggrX3_avg(0,0,BUNfndVOID,var,BUNhloc(b,p),@1,@2,BUNt@2(bn,r),BUNindex(bn,r)-off)@
		}
	/* e->htype == TYPE_oid */
	} else if (range > SMALL_AGGR_MAX) {
		/* hash lookup */
		slots = BATcount(e);
		if (b->htype == TYPE_void) {
			@:aggrX3_avg(0,1,HASHfnd_oid,loc,&bhsb;bhsb++,@1,@2,BUNt@2(bn,r),BUNindex(bn,r)-off)@
		} else {
			@:aggrX3_avg(0,1,HASHfnd_oid,loc,BUNhloc(b,p),@1,@2,BUNt@2(bn,r),BUNindex(bn,r)-off)@
		}
	} else {
		/* array lookup */
		slots = range;
		if (b->htype == TYPE_void) {
			@:aggrX3_avg(1,0,CHKrange,loc,&bhsb;bhsb++,@1,@2,&sums[(*(oid*)h)-min],(*(oid*)h)-min)@
		} else {
			@:aggrX3_avg(1,0,CHKrange,loc,BUNhloc(b,p),@1,@2,&sums[(*(oid*)h)-min],(*(oid*)h)-min)@
		}
	}

	*ret = bn;
	return GDK_SUCCEED;
}
@c
@:arithavg(sht,loc)@
@:arithavg(int,loc)@
@:arithavg(lng,loc)@
@:arithavg(flt,loc)@
@:arithavg(dbl,loc)@

@- "Extremes" (Min & Max)
@c
/*	aggrX3_minmax_ptr
		e-void-head	e-oid-head	e-oid-head
		void-lookup	hash-lookup	array-lookup

	@1:	</>		</>		</>		compare operator: <(min) or >(max)
	@2:	0		1		0		do BATprepareHash?
	@3:	BUNfndVOID	HASHfnd_oid	CHKrange	lookup
	@4:	var		loc		loc		e/bn-head-access

	@5:	"BUNhloc(b,p)"	for  (oid) b-head-type,		b-head access
		"&bhsb; bhsb++" for (void) b-head-type

	@6:		sht / int / lng / any			b/bn-tail-storage-type
	@7:	"loc" for fixsized b/bn-tail-type,		b/bn-tail-access
		"var" for varsized b/bn-tail-type

	@8:	     BUNindex(bn,r)-off		(*(oid*)h)-min	index in extremes array
	@9:		max/min					initial result value
*/
@= aggrX3_minmax_ptr
	ALGODEBUG THRprintf(GDKout, "aggrX3_minmax_ptr(@1,@2,@3,@4,@5,@6,@7,@8,@9);\n");
	if (@2 && BATprepareHash(e)) {
		GDKfree(extremes);
		BBPreclaim(e);
		return GDK_FAIL;
	}
	/* init: create extremes and set all to the zero pointer */
	extremes = (ptr*) GDKmalloc(slots*sizeof(ptr));
	memset(extremes, 0, slots*sizeof(ptr));
	/* scan b and replace totals by the extreme value (just pointers to vals in b) */
	bhsb = b->hseqbase - 1;
	BATloopFast(b, p, q, xx) {
		ptr t = BUNt@7(b,p);
		oid *h = (oid*) @5;

		@3(r, bn, h);
		if (r) {
			ptr *val = &extremes[@8];
			if (*val != nil) {
				if ((*cmp)(t,nil) == 0) {
					*val = nil;
				} else if (*val == NULL || (*cmp)(t,*val) @1 0) {
					*val = t;
				}
			}
		}
	}
	/* insert the extreme values into the result */
	BATloopFast(bn, r, q, xx) {
		oid *h = (oid*)BUNh@4(bn,r);
		ptr val = extremes[@8];
		(void) h;	/* silence compiler about unused variable */
		/* trick: using a void head-type, only the tail are (over)written */
		ATOMput(bn->ttype, bn->theap, BUNtloc(bn,r), val?val:nil);
	}
@c
/*	aggrX3_minmax_oid
		e-void-head	e-oid-head	e-oid-head
		void-lookup	hash-lookup	array-lookup

	@1:	</>		</>		</>		compare operator: <(min) or >(max)
	@2:	0		1		0		do BATprepareHash?
	@3:	BUNfndVOID	HASHfnd_oid	CHKrange	lookup
	@4:	var		loc		loc		e/bn-head-access

	@5:	"BUNhloc(b,p)"	for  (oid) b-head-type,		b-head access
		"&bhsb; bhsb++" for (void) b-head-type

	@6:		sht / int / lng / any			b/bn-tail-storage-type
	@7:	"loc" for fixsized b/bn-tail-type,		b/bn-tail-access
		"var" for varsized b/bn-tail-type

	@8:	     BUNindex(bn,r)-off		(*(oid*)h)-min	index in extremes array
	@9:		max/min					initial result value
*/
@= aggrX3_minmax_oid
	ALGODEBUG THRprintf(GDKout, "aggrX3_minmax_oid(@1,@2,@3,@4,@5,@6,@7,@8,@9);\n");
	if (@2 && BATprepareHash(e)) {
		GDKfree(extremes);
		BBPreclaim(e);
		return GDK_FAIL;
	}
	/* init: create extremes and set all to the zero pointer */
	extremes = (oid*) GDKmalloc(slots*sizeof(oid));
	{ size_t i = 0; for (; i < slots; i++ ) extremes[i] = GDK_oid_@9; }
	/* scan b and replace totals by the extreme value (just pointers to vals in b) */
	bhsb = b->hseqbase - 1;
	BATloopFast(b, p, q, xx) {
		ptr t = BUNt@7(b,p);
		oid *h = (oid*) @5;

		@3(r, bn, h);
		if (r) {
			oid *val = &extremes[@8];
			if (*val != *(oid*)nil) {
				if ((*cmp)(t,nil) == 0) {
					*val = *(oid*)nil;
				} else if ((*cmp)(t,val) @1 0) {
					*val = *(oid*)t;
				}
			}
		}
	}
	/* insert the extreme values into the result */
	BATloopFast(bn, r, q, xx) {
		oid *h = (oid*)BUNh@4(bn,r);
		oid val = extremes[@8];
		(void) h;	/* silence compiler about unused variable */
		/* trick: using a void head-type, only the tail are (over)written */
		ATOMput(bn->ttype, bn->theap, BUNtloc(bn,r), &val);
	}
@c

/*	extreme_typed
	@1:	min/max
	@2:	 < / >
	@3:	b/bn-tail-storage-type			sht/int/lng/any
	@4:	"loc" for fixsized b/bn-tail-type,	b/bn-tail-access
		"var" for varsized b/bn-tail-type
	@5:	ptr/oid					void/any
	@6:	max/min					initial result value
*/
@= extreme_typed
static int
aggrX3_@1_@3_@4_@5(BAT **ret, BAT *b, BAT *e)
{
	BAT *bn = BATnew(e->htype, BATttype(b), BATcount(e));
	int (*cmp)(ptr,ptr);
	ptr nil;
	int xx;
	size_t off;
	@5 *extremes = NULL;
	BUN p, q, r;
	size_t slots, range;
	oid min, max;
	oid bhsb;

	if( bn == NULL)
		return GDK_FAIL;
	cmp = BATatoms[bn->ttype].atomCmp;
	nil =  ATOMnilptr(bn->ttype);
	off =  BUNindex(bn,BUNfirst(bn));
	*ret = NULL;

	ALGODEBUG THRprintf(GDKout, "aggrX3_@1_@3_@4_@5[@2,@6](b=%s,e=%s);\n",
		BATgetId(b),BATgetId(e));
	/* init: prepare the result bat;
	 * trick: by using "tail-type" void, we only write the head column, here */
	@:init_result(void)@
	range = max - min + 1;

	/* scan b and replace totals by the extreme value (just pointers to vals in b) */
	slots = BATcount(e);
	if (e->htype == TYPE_void) {
		/* void lookup */
		if (b->htype == TYPE_void) {
			@:aggrX3_minmax_@5(@2,0,BUNfndVOID,var,&bhsb; bhsb++,@3,@4,BUNindex(bn,r)-off,@6)@
		} else {
			@:aggrX3_minmax_@5(@2,0,BUNfndVOID,var,BUNhloc(b,p),@3,@4,BUNindex(bn,r)-off,@6)@
		}
	/* e->htype == TYPE_oid */
	} else if (range > SMALL_AGGR_MAX) {
		/* hash lookup */
		if (b->htype == TYPE_void) {
			@:aggrX3_minmax_@5(@2,1,HASHfnd_oid,loc,&bhsb; bhsb++,@3,@4,BUNindex(bn,r)-off,@6)@
		} else {
			@:aggrX3_minmax_@5(@2,1,HASHfnd_oid,loc,BUNhloc(b,p),@3,@4,BUNindex(bn,r)-off,@6)@
		}
	} else {
		/* array lookup */
		slots = range;
		if (b->htype == TYPE_void) {
			@:aggrX3_minmax_@5(@2,0,CHKrange,loc,&bhsb; bhsb++,@3,@4,(*(oid*)h)-min,@6)@
		} else {
			@:aggrX3_minmax_@5(@2,0,CHKrange,loc,BUNhloc(b,p),@3,@4,(*(oid*)h)-min,@6)@
		}
	}
	*ret = bn;
bunins_failed:
	if (extremes)
		GDKfree(extremes);
	return *ret?GDK_SUCCEED:GDK_FAIL;
}
@c
/*	extreme
	@1:	min/max
	@2:	 < / >
	@3:	max/min
*/
@= extreme
@:extreme_typed(@1,@2,chr,loc,ptr,@3)@
@:extreme_typed(@1,@2,sht,loc,ptr,@3)@
@:extreme_typed(@1,@2,int,loc,ptr,@3)@
@:extreme_typed(@1,@2,lng,loc,ptr,@3)@
@:extreme_typed(@1,@2,any,loc,ptr,@3)@
@:extreme_typed(@1,@2,any,var,ptr,@3)@
@:extreme_typed(@1,@2,any,var,oid,@3)@

int
CMDaggrX3_@1(BAT **ret, BAT *b, BAT *e)
{
	int rtrn, tt = ATOMstorage(b->ttype);

	ALGODEBUG THRprintf(GDKout, "CMDaggrX3_@1[@2,@3](b=%s,e=%s);\n",
		BATgetId(b),BATgetId(e));
	if (b->ttype == TYPE_void) {
		rtrn = aggrX3_@1_any_var_oid(ret, b, e);
	} else if (tt == TYPE_chr) {
		rtrn = aggrX3_@1_chr_loc_ptr(ret, b, e);
	} else if (tt == TYPE_sht) {
		rtrn = aggrX3_@1_sht_loc_ptr(ret, b, e);
	} else if (b->ttype != TYPE_bat && (tt == TYPE_int || tt == TYPE_flt)) {
		/* ensure use of ATOMput for TYPE_bat */
		rtrn = aggrX3_@1_int_loc_ptr(ret, b, e);
	} else if (tt == TYPE_dbl || tt == TYPE_lng) {
		rtrn = aggrX3_@1_lng_loc_ptr(ret, b, e);
	} else if (b->tvarsized) {
		rtrn = aggrX3_@1_any_var_ptr(ret, b, e);
	} else {
		rtrn = aggrX3_@1_any_loc_ptr(ret, b, e);
	}
	return rtrn;
}
@c
@:extreme(min,<,max)@
@:extreme(max,>,min)@

@- Count
@c
/*	aggrX3_count
		e-void-head	e-oid-head	e-oid-head
		void-lookup	hash-lookup	array-lookup

	@1:	0		0		1		use cnt-array?
	@2:	0		1		0		do BATprepareHash?
	@3:	BUNfndVOID	HASHfnd_oid	CHKrange	lookup
	@4:	var		loc		loc		e/bn-head-access

	@5:	"BUNhloc(b,p)"	for  (oid) b-head-type,		b-head access
		"&bhsb; bhsb++" for (void) b-head-type

	@6:	BUNtloc(bn,r)	BUNtloc(bn,r)	&cnt[(*(oid*)h)-min]
								*dst: count in-place or in cnt-array ?
*/
@= aggrX3_count
	ALGODEBUG THRprintf(GDKout, "aggrX3_count(@1,@2,@3,@4,@5,@6);\n");
	if (@1) {
		/* create tmp. cnt array */
		cnt = (int*) GDKmalloc(range*sizeof(int));
		memset(cnt, 0, range*sizeof(int));
	}
	if (@2 && BATprepareHash(bn)) {
		if (@1)
			GDKfree(cnt);
		BBPreclaim(bn);
		return GDK_FAIL;
	}
	/* scan b, and increment counts in-place or in cnt-array */
	bhsb = b->hseqbase-1;
	btt = b->ttype;
	if (*ignore_nils) {
		switch(ATOMstorage(btt)) {
		case TYPE_chr:
			@:aggrX3_count_loop(@1,@2,@3,@4,@5,@6,if (!simple_EQ(BUNtloc(b,p),bt_nil,chr)))@
		case TYPE_sht:
			@:aggrX3_count_loop(@1,@2,@3,@4,@5,@6,if (!simple_EQ(BUNtloc(b,p),bt_nil,sht)))@
		case TYPE_int:
			@:aggrX3_count_loop(@1,@2,@3,@4,@5,@6,if (!simple_EQ(BUNtloc(b,p),bt_nil,int)))@
		case TYPE_lng:
			@:aggrX3_count_loop(@1,@2,@3,@4,@5,@6,if (!simple_EQ(BUNtloc(b,p),bt_nil,lng)))@
		case TYPE_flt:
			@:aggrX3_count_loop(@1,@2,@3,@4,@5,@6,if (!simple_EQ(BUNtloc(b,p),bt_nil,flt)))@
		case TYPE_dbl:
			@:aggrX3_count_loop(@1,@2,@3,@4,@5,@6,if (!simple_EQ(BUNtloc(b,p),bt_nil,dbl)))@
		default:
			if (b->tvarsized) {
				@:aggrX3_count_loop(@1,@2,@3,@4,@5,@6,if (!atom_EQ(BUNtvar(b,p),bt_nil,btt)))@
			  } else {
				@:aggrX3_count_loop(@1,@2,@3,@4,@5,@6,if (!atom_EQ(BUNtloc(b,p),bt_nil,btt)))@
			  }
		}
	} else {
		switch(ATOMstorage(btt)) {
		case TYPE_chr:
			@:aggrX3_count_loop(@1,@2,@3,@4,@5,@6,)@
		case TYPE_sht:
			@:aggrX3_count_loop(@1,@2,@3,@4,@5,@6,)@
		case TYPE_int:
			@:aggrX3_count_loop(@1,@2,@3,@4,@5,@6,)@
		case TYPE_lng:
			@:aggrX3_count_loop(@1,@2,@3,@4,@5,@6,)@
		case TYPE_flt:
			@:aggrX3_count_loop(@1,@2,@3,@4,@5,@6,)@
		case TYPE_dbl:
			@:aggrX3_count_loop(@1,@2,@3,@4,@5,@6,)@
		default:
			if (b->tvarsized) {
				@:aggrX3_count_loop(@1,@2,@3,@4,@5,@6,)@
			} else {
				@:aggrX3_count_loop(@1,@2,@3,@4,@5,@6,)@
			}
		}
	}
	if (@1) {
		/* copy cnt array to final result */
		BATloopFast(bn, p, q, xx) {
			oid h = (*(oid*) BUNh@4(bn,p)) - min;
			*(int*)BUNtloc(bn, p) = cnt[h];
		}
		GDKfree(cnt);
	}
@c
/*	aggrX3_count_loop
	@7:	if (!atom_EQ(BUNt{loc,var}(b,p),bt_nil,btt))		b-tail nil check
		if (!simple_EQ(BUNtloc(b,p),bt_nil,{chr,sht,int,flt,lng,dbl}))
*/
@= aggrX3_count_loop
	ALGODEBUG THRprintf(GDKout, "aggrX3_count_loop(@1,@2,@3,@4,@5,@6,@7);\n");
	BATloopFast(b, p, q, xx) {
		oid *h = (oid*) @5;

		@3(r, bn, h);
		if (r) {
			@7 {
				int *dst = (int*) @6;
				(*dst)++;
			}
		}
	}
	break;
@c
int
CMDaggrX3_count(BAT **ret, BAT *b, BAT *e, bit *ignore_nils)
{
	BAT *bn = BATnew(e->htype, TYPE_int, BATcount(e));
	int zero = 0, *cnt;
	BUN p, q, r;
	int xx;
	size_t range;
	oid min, max;
	oid bhsb;
	int btt;
	ptr bt_nil = ATOMnilptr(b->ttype);

	if (bn == NULL)
		return GDK_FAIL;

	ALGODEBUG THRprintf(GDKout, "CMDaggrX3_count(b=%s,e=%s);\n", 
		BATgetId(b),BATgetId(e));

	/* init: set all counts to zero and calculate min/max oid */
	@:init_result(int)@
	range = max - min + 1;

	/* scan b, and calculate counts */
	if (e->htype == TYPE_void) {
		/* void lookup */
		if (b->htype == TYPE_void) {
			@:aggrX3_count(0,0,BUNfndVOID,var,&bhsb;bhsb++,BUNtloc(bn,r))@
		} else {
			@:aggrX3_count(0,0,BUNfndVOID,var,BUNhloc(b,p),BUNtloc(bn,r))@
		}
		/* e->htype == TYPE_oid */
	} else if (range > SMALL_AGGR_MAX) {
		/* hash lookup */
		if (b->htype == TYPE_void) {
			@:aggrX3_count(0,1,HASHfnd_oid,loc,&bhsb;bhsb++,BUNtloc(bn,r))@
		} else {
			@:aggrX3_count(0,1,HASHfnd_oid,loc,BUNhloc(b,p),BUNtloc(bn,r))@
		}
	} else {
		/* array lookup */
		if (b->htype == TYPE_void) {
			@:aggrX3_count(1,0,CHKrange,loc,&bhsb;bhsb++,&cnt[(*(oid*)h)-min])@
		} else {
			@:aggrX3_count(1,0,CHKrange,loc,BUNhloc(b,p),&cnt[(*(oid*)h)-min])@
		}
	}

	*ret = bn;
	return GDK_SUCCEED;
}

@- Size
@c
int
CMDaggrX3_size(BAT **ret, BAT *b, BAT *e)
{
	BAT *bn = BATnew(e->htype, TYPE_int, BATcount(e));
	int zero = 0;
	BUN p, q, r;
	int xx;

	if (bn == NULL)
		return GDK_FAIL;
	/* init: set all sums to zero */
	bn->tsorted = bn->hsorted = 0;
	ALIGNsetH(bn, e);
	BATloopFast(e, p, q, xx) {
		if (BUNfastins(bn, BUNhead(e, p), &zero) == NULL) {
			BBPreclaim(bn);
			return GDK_FAIL;
		}
	}
	/* scan b, and add increment totals for true values */
	if (BATprepareHash(bn)) {
		BBPreclaim(bn);
		return GDK_FAIL;
	}
	BATloopFast(b, p, q, xx) {
		if (*(bit *) BUNtloc(b, p) == TRUE) {
			oid *h = (oid *) BUNhead(b, p);

			BUNfndOID(r, bn, h);
			if (r) {
				int *dst = (int *) BUNtloc(bn, r);

				(*dst)++;
			}
		}
	}
	*ret = bn;
	return GDK_SUCCEED;
}

@- Sum, Product & Average
@c
/*	aggrX3_sum3
		e-void-head	e-oid-head	e-oid-head
		void-lookup	hash-lookup	array-lookup

	@1:	0		0		1		use sums-array?
	@2:	0		1		0		do BATprepareHash?
	@3:	BUNfndVOID	HASHfnd_oid	CHKrange	lookup
	@4:	var		loc		loc		e/bn-head-access

	@5:	"BUNhloc(b,p)"	for  (oid) b-head-type,		b-head access
		"&bhsb; bhsb++" for (void) b-head-type

	@6:		sht / int / lng / flt / dbl		b/bn-tail-type

#	not used any more as the result-type needs an argument
#	@7:	"loc" for fixsized b/bn-tail-type,		b/bn-tail-access
#		"var" for varsized b/bn-tail-type		(only loc used currently)

	@7:	BUNt@7(bn,r)	BUNt@7(bn,r)	&sums[(*(oid*)h)-min]
								*dst: sum in-place or in sums-array ?
	@8:	<empty> / if (w >= base && w < end)		check head (oid) ranges in case b & g
								are not void-headed and aligned
	@9:	result type
*/
@= aggrX3_sum3
	ALGODEBUG THRprintf(GDKout, "aggrX3_sum3(@1,@2,@3,@4,@5,@6,@7,@8,@9);\n");
	if (@1) {
		/* create tmp. sums array */
		size_t i;
		sums = (@9*) GDKmalloc(range*sizeof(@9));
		for (i = 0; i < range; i++)
			sums[i] = zero;
	}
	if (@2 && BATprepareHash(bn)) {
		if (@1)
			GDKfree(sums);
		BBPreclaim(bn);
		return GDK_FAIL;
	}
	/* scan b & g, and add values to sums in-place or in sums-array */
	base = BUNindex(g, BUNfirst(g));
	offset = (ssize_t) (base - g->hseqbase);
	end = base + BATcount(g);
	(void) end;		/* keep compilers happy */
	bhsb = b->hseqbase;
	BATloopFast(b, p, q, xx) {
		@6 *t = (@6*) BUNtloc(b,p);
		oid v = *(oid*) @5;

		w = offset + v;
		@8 {
			oid *h = (oid*) BUNtloc(g, BUNptr(g, w));

			@3(r, bn, (oid*)h);
			if (r) {
				@9 *dst = (@9*) @7;
				if (*dst != @9_nil) {
					if (*t == @6_nil) {
						*dst = @9_nil;
					} else {
						*dst += *t;
					}
				}
			}
		}
	}
	if (@1) {
		/* copy sums array to final result */
		BATloopFast(bn, p, q, xx) {
			oid h = (*(oid*) BUNh@4(bn,p)) - min;
			*(@9*)BUNtloc(bn, p) = sums[h];
		}
		GDKfree(sums);
	}
@
@c
/*	aggrX3_prod3
		e-void-head	e-oid-head	e-oid-head
		void-lookup	hash-lookup	array-lookup

	@1:	0		0		1		use prods-array?
	@2:	0		1		0		do BATprepareHash?
	@3:	BUNfndVOID	HASHfnd_oid	CHKrange	lookup
	@4:	var		loc		loc		e/bn-head-access

	@5:	"BUNhloc(b,p)"	for  (oid) b-head-type,		b-head access
		"&bhsb; bhsb++" for (void) b-head-type

	@6:		sht / int / lng / flt / dbl		b/bn-tail-type

#	not used any more as the result-type needs an argument
#	@7:	"loc" for fixsized b/bn-tail-type,		b/bn-tail-access
#		"var" for varsized b/bn-tail-type		(only loc used currently)

	@7:	BUNt@7(bn,r)	BUNt@7(bn,r)	&prods[(*(oid*)h)-min]
								*dst: prod in-place or in prods-array ?
	@8:	<empty> / if (w >= base && w < end)		check head (oid) ranges in case b & g
								are not void-headed and aligned
	@9:	result type
*/
@= aggrX3_prod3
	ALGODEBUG THRprintf(GDKout, "aggrX3_prod3(@1,@2,@3,@4,@5,@6,@7,@8,@9);\n");
	if (@1) {
		/* create tmp. prods array */
		size_t i;
		prods = (@9*) GDKmalloc(range*sizeof(@9));
		for (i = 0; i < range; i++)
			prods[i] = zero;
	}
	if (@2 && BATprepareHash(bn)) {
		if (@1)
			GDKfree(prods);
		BBPreclaim(bn);
		return GDK_FAIL;
	}
	/* scan b & g, and add values to prods in-place or in prods-array */
	base = BUNindex(g, BUNfirst(g));
	offset = (ssize_t) (base - g->hseqbase);
	end = base + BATcount(g);
	(void) end;		/* keep compilers happy */
	bhsb = b->hseqbase;
	BATloopFast(b, p, q, xx) {
		@6 *t = (@6*) BUNtloc(b,p);
		oid v = *(oid*) @5;

		w = offset + v;
		@8 {
			oid *h = (oid*) BUNtloc(g, BUNptr(g, w));

			@3(r, bn, (oid*)h);
			if (r) {
				@9 *dst = (@9*) @7;
				if (*dst != @9_nil) {
					if (*t == @6_nil) {
						*dst = @9_nil;
					} else {
						*dst *= *t;
					}
				}
			}
		}
	}
	if (@1) {
		/* copy prods array to final result */
		BATloopFast(bn, p, q, xx) {
			oid h = (*(oid*) BUNh@4(bn,p)) - min;
			*(@9*)BUNtloc(bn, p) = prods[h];
		}
		GDKfree(prods);
	}
@
@c
/*	aggrX3_avg3
		e-void-head	e-oid-head	e-oid-head
		void-lookup	hash-lookup	array-lookup

	@1:	0		0		1		use sums-array?
	@2:	0		1		0		do BATprepareHash?
	@3:	BUNfndVOID	HASHfnd_oid	CHKrange	lookup
	@4:	var		loc		loc		e/bn-head-access

	@5:	"BUNhloc(b,p)"	for  (oid) b-head-type,		b-head access
		"&bhsb; bhsb++" for (void) b-head-type

	@6:		sht / int / lng / flt / dbl		b/bn-tail-type
	@7:	"loc" for fixsized b/bn-tail-type,		b/bn-tail-access
		"var" for varsized b/bn-tail-type		(only loc used currently)

	@8:	BUNt@7(bn,r)	BUNt@7(bn,r)	&sums[(*(oid*)h)-min]
								*dst: sum in-place or in sums-array ?

	@9:	     BUNindex(bn,r)-off		(*(oid*)h)-min	index in cnt array
*/
@= aggrX3_avg3
	ALGODEBUG THRprintf(GDKout, "aggrX3_avg3(@1,@2,@3,@4,@5,@6,@7,@8,@9);\n");
	if (@1) {
		/* create tmp. sums array */
		size_t i;
		sums = (dbl*) GDKmalloc(range*sizeof(dbl));
		for (i = 0; i < range; i++)
			sums[i] = zero;
	}
	if (@2 && BATprepareHash(bn)) {
		if (@1)
			GDKfree(sums);
		BBPreclaim(bn);
		return GDK_FAIL;
	}
	cnt = (size_t*) GDKmalloc(slots*sizeof(cnt[0]));
	memset(cnt, 0, slots*sizeof(cnt[0]));
	/* scan b & g, adding sums, and incrementing counts */
	base = BUNindex(g, BUNfirst(g));
	offset = (ssize_t) (base - g->hseqbase);
	end = base + BATcount(g);
	(void) end;		/* keep compilers happy */
	bhsb = b->hseqbase;
	BATloopFast(b, p, q, xx) {
		@6 *t = (@6*) BUNt@7(b,p);
		oid v = *(oid*) @5;

		w = offset + v;
		if (w >= base && w < end) {
			oid *h = (oid*) BUNtloc(g, BUNptr(g, w));

			@3(r, bn, (oid*)h);
			if (r) {
				dbl *dst = (dbl*) @8;
				if (*dst != dbl_nil) {
					if (*t == @6_nil) {
						*dst = dbl_nil;
					} else {
						*dst += *t;
					}
					cnt[@9]++;
				}
			}
		}
	}
	/* postprocess by dividing sums by counts */
	if (@1) {
		/* sums in sums-array */
		BATloopFast(bn, p, q, xx) {
			oid h = (*(oid*) BUNh@4(bn,p)) - min;
			dbl *dst = (dbl*) BUNt@7(bn, p);
			if (cnt[h] == 0 || sums[h] == dbl_nil) {
				*dst = dbl_nil;
			} else {
				*dst = sums[h]/cnt[h];
			}
		}
		GDKfree(sums);
	} else {
		/* sums in-place */
		size_t yy = 0;
		BATloopFast(bn, p, q, xx) {
			dbl *dst = (dbl*) BUNt@7(bn, p);
			if (cnt[yy] == 0) {
				*dst = dbl_nil;
			} else if (*dst != dbl_nil) {
				*dst /= cnt[yy];
			}
			yy++;
		}

	}
	GDKfree(cnt);
@c

/*	arithsum3
	@6:	sht / int / lng / flt / dbl		b/bn-tail-type

#	not used any more
#	@7:	"loc" for fixsized b/bn-tail-type,	b/bn-tail-access
#		"var" for varsized b/bn-tail-type	(only loc used currently)

	@9:	result type
*/
@= arithsum3

static int
aggrX3_sum3_@1_@2_EarrayBvoidGvoid (BAT *bn, BAT *b, BAT *g, BAT *e, size_t range, oid min, oid max)
{
	@2 zero = (@2) 0, *sums;
	BUN p, q, r;
	int xx;
	oid bhsb;
	size_t base, end, w;
	ssize_t offset;

	ALGODEBUG THRprintf(GDKout, "aggrX3_sum3_@1_@2_EarrayBvoidGvoid(bn=%s,b=%s,g=%s,e=%s,range=" SZFMT ",min=" SZFMT ",max=" SZFMT ");\n",
			    BATgetId(bn),BATgetId(b),BATgetId(g),BATgetId(e),
				range,(size_t) min,(size_t) max);
	@:aggrX3_sum3(1,0,CHKrange,loc,&bhsb;bhsb++,@1,&sums[(*(oid*)h)-min],,@2)@
	return GDK_SUCCEED;
}

int
CMDaggrX3_sum3_@1_@2(BAT **ret, BAT *b, BAT *g, BAT *e)
{
	BAT *bn = BATnew(e->htype, TYPE_@2, BATcount(e));
	@2 zero = (@2) 0, *sums;
	BUN p, q, r;
	int xx;
	size_t range;
	oid min, max;
	oid bhsb;
	size_t base, end, w;
	ssize_t offset;

	if( bn == NULL)
		return GDK_FAIL;
	ALGODEBUG THRprintf(GDKout, "CMDaggrX3_sum3_@1_@2(b=%s,g=%s,e=%s);\n",
		BATgetId(b),BATgetId(g), BATgetId(e));
/*	ERRORcheck((BATcount(b)!=BATcount(g)), "CMDaggrX3_sum3_@1: BATs b & g must be of equal size.\n");	*/
	ERRORcheck((g->htype == TYPE_void) && (g->hseqbase == oid_nil) && (BATcount(g) > 0), "CMDaggrX3_sum3_@1: head of BAT g must not be nil.\n");

	if((g->hseqbase == oid_nil) || (!BAThdense(g)) || (!(BAThordered(b)&1)) || (!g->hkey)) {
		return CMDaggrX3_sum_@1_@2(ret, BATjoin(BATmirror(g),b,oid_nil), e);
	}

	*ret = bn;

	/* init: set all sums to zero and calculate min/max oid */
	@:init_result(@2)@
	range = max - min + 1;

	/* scan b & g, and calculate sums */
	if (e->htype == TYPE_void) {
		/* void lookup */
		if (b->htype == TYPE_void) {
			if ((g->htype == TYPE_void)&&(BATcount(b)==BATcount(g))&&(b->hseqbase==g->hseqbase)) {
				@:aggrX3_sum3(0,0,BUNfndVOID,var,&bhsb;bhsb++,@1,BUNtloc(bn,r),,@2)@
			} else {
				@:aggrX3_sum3(0,0,BUNfndVOID,var,&bhsb;bhsb++,@1,BUNtloc(bn,r),if (w >= base && w < end),@2)@
			}
		} else {
			@:aggrX3_sum3(0,0,BUNfndVOID,var,BUNhloc(b,p),@1,BUNtloc(bn,r),if (w >= base && w < end),@2)@
		}
	/* e->htype == TYPE_oid */
	} else if (range > SMALL_AGGR_MAX) {
		/* hash lookup */
		if (b->htype == TYPE_void) {
			if ((g->htype == TYPE_void)&&(BATcount(b)==BATcount(g))&&(b->hseqbase==g->hseqbase)) {
				@:aggrX3_sum3(0,1,HASHfnd_oid,loc,&bhsb;bhsb++,@1,BUNtloc(bn,r),,@2)@
			} else {
				@:aggrX3_sum3(0,1,HASHfnd_oid,loc,&bhsb;bhsb++,@1,BUNtloc(bn,r),if (w >= base && w < end),@2)@
			}
		} else {
			@:aggrX3_sum3(0,1,HASHfnd_oid,loc,BUNhloc(b,p),@1,BUNtloc(bn,r),if (w >= base && w < end),@2)@
		}
	} else {
		/* array lookup */
		if (b->htype == TYPE_void) {
			if ((g->htype == TYPE_void)&&(BATcount(b)==BATcount(g))&&(b->hseqbase==g->hseqbase)) {
				return aggrX3_sum3_@1_@2_EarrayBvoidGvoid (bn, b, g, e, range, min, max);
			} else {
				@:aggrX3_sum3(1,0,CHKrange,loc,&bhsb;bhsb++,@1,&sums[(*(oid*)h)-min],if (w >= base && w < end),@2)@
			}
		} else {
			@:aggrX3_sum3(1,0,CHKrange,loc,BUNhloc(b,p),@1,&sums[(*(oid*)h)-min],if (w >= base && w < end),@2)@
		}
	}

	return GDK_SUCCEED;
}
@c

/*	arithprod3
	@6:	sht / int / lng / flt / dbl		b/bn-tail-type

#	not used any more
#	@7:	"loc" for fixsized b/bn-tail-type,	b/bn-tail-access
#		"var" for varsized b/bn-tail-type	(only loc used currently)

	@9:	result type
*/
@= arithprod3

static int
aggrX3_prod3_@1_@2_EarrayBvoidGvoid (BAT *bn, BAT *b, BAT *g, BAT *e, size_t range, oid min, oid max)
{
	@2 zero = (@2) 1, *prods;
	BUN p, q, r;
	int xx;
	oid bhsb;
	size_t base, end, w;
	ssize_t offset;

	ALGODEBUG THRprintf(GDKout, "aggrX3_prod3_@1_@2_EarrayBvoidGvoid(bn=%s,b=%s,g=%s,e=%s,range=" SZFMT ",min=" SZFMT ",max=" SZFMT ");\n",
				    BATgetId(bn),BATgetId(b),BATgetId(g),BATgetId(e),
					range,(size_t) min,(size_t) max);
	@:aggrX3_prod3(1,0,CHKrange,loc,&bhsb;bhsb++,@1,&prods[(*(oid*)h)-min],,@2)@

	return GDK_SUCCEED;
}

int
CMDaggrX3_prod3_@1_@2(BAT **ret, BAT *b, BAT *g, BAT *e)
{
	BAT *bn = BATnew(e->htype, TYPE_@2, BATcount(e));
	@2 zero = (@2) 1, *prods;
	BUN p, q, r;
	int xx;
	size_t range;
	oid min, max;
	oid bhsb;
	size_t base, end, w;
	ssize_t offset;

	if( bn == NULL)
		return GDK_FAIL;
	ALGODEBUG THRprintf(GDKout, "CMDaggrX3_prod3_@1_@2(b=%s,g=%s,e=%s);\n",
		BATgetId(b),BATgetId(g),BATgetId(e));
/*	ERRORcheck((BATcount(b)!=BATcount(g)), "CMDaggrX3_prod3_@1: BATs b & g must be of equal size.\n");	*/
	ERRORcheck((g->htype == TYPE_void) && (g->hseqbase == oid_nil) && (BATcount(g) > 0), "CMDaggrX3_prod3_@1: head of BAT g must not be nil.\n");

	if((g->hseqbase == oid_nil) || (!BAThdense(g)) || (!(BAThordered(b)&1)) || (!g->hkey)) {
		return CMDaggrX3_prod_@1_@2(ret, BATjoin(BATmirror(g),b,oid_nil), e);
	}

	*ret = bn;

	/* init: set all prods to zero and calculate min/max oid */
	@:init_result(@2)@
	range = max - min + 1;

	/* scan b & g, and calculate prods */
	if (e->htype == TYPE_void) {
		/* void lookup */
		if (b->htype == TYPE_void) {
			if ((g->htype == TYPE_void)&&(BATcount(b)==BATcount(g))&&(b->hseqbase==g->hseqbase)) {
				@:aggrX3_prod3(0,0,BUNfndVOID,var,&bhsb;bhsb++,@1,BUNtloc(bn,r),,@2)@
			} else {
				@:aggrX3_prod3(0,0,BUNfndVOID,var,&bhsb;bhsb++,@1,BUNtloc(bn,r),if (w >= base && w < end),@2)@
			}
		} else {
			@:aggrX3_prod3(0,0,BUNfndVOID,var,BUNhloc(b,p),@1,BUNtloc(bn,r),if (w >= base && w < end),@2)@
		}
	/* e->htype == TYPE_oid */
	} else if (range > SMALL_AGGR_MAX) {
		/* hash lookup */
		if (b->htype == TYPE_void) {
			if ((g->htype == TYPE_void)&&(BATcount(b)==BATcount(g))&&(b->hseqbase==g->hseqbase)) {
				@:aggrX3_prod3(0,1,HASHfnd_oid,loc,&bhsb;bhsb++,@1,BUNtloc(bn,r),,@2)@
			} else {
				@:aggrX3_prod3(0,1,HASHfnd_oid,loc,&bhsb;bhsb++,@1,BUNtloc(bn,r),if (w >= base && w < end),@2)@
			}
		} else {
			@:aggrX3_prod3(0,1,HASHfnd_oid,loc,BUNhloc(b,p),@1,BUNtloc(bn,r),if (w >= base && w < end),@2)@
		}
	} else {
		/* array lookup */
		if (b->htype == TYPE_void) {
			if ((g->htype == TYPE_void)&&(BATcount(b)==BATcount(g))&&(b->hseqbase==g->hseqbase)) {
				return aggrX3_prod3_@1_@2_EarrayBvoidGvoid (bn, b, g, e, range, min, max);
			} else {
				@:aggrX3_prod3(1,0,CHKrange,loc,&bhsb;bhsb++,@1,&prods[(*(oid*)h)-min],if (w >= base && w < end),@2)@
			}
		} else {
			@:aggrX3_prod3(1,0,CHKrange,loc,BUNhloc(b,p),@1,&prods[(*(oid*)h)-min],if (w >= base && w < end),@2)@
		}
	}

	return GDK_SUCCEED;
}
@c

/*	arithsumprod3
	@6:	sht / int / lng / flt / dbl		b/bn-tail-type

#	not used any more
#	@7:	"loc" for fixsized b/bn-tail-type,	b/bn-tail-access
#		"var" for varsized b/bn-tail-type	(only loc used currently)

	@9:	result type
*/
@= arithsumprod3
@:arithsum3(@1,@2)@
@:arithprod3(@1,@2)@
@c

@:arithsumprod3(sht,sht)@
@:arithsumprod3(sht,int)@
@:arithsumprod3(sht,lng)@
@:arithsumprod3(int,int)@
@:arithsumprod3(int,lng)@
@:arithsumprod3(lng,lng)@
@:arithsumprod3(flt,flt)@
@:arithsumprod3(flt,dbl)@
@:arithsumprod3(dbl,dbl)@

/*	arithavg3
	@6:		sht / int / lng / flt / dbl	b/bn-tail-type
	@7:	"loc" for fixsized b/bn-tail-type,	b/bn-tail-access
		"var" for varsized b/bn-tail-type	(only loc used currently)
	@9:	result type
*/
@= arithavg3
int
CMDaggrX3_avg3_@1(BAT **ret, BAT *b, BAT *g, BAT *e)
{
	BAT *bn = BATnew(e->htype, TYPE_dbl, BATcount(e));
	int xx;
	size_t off;
	size_t *cnt;
	size_t range;
	oid min, max;
	dbl zero = (dbl) 0, *sums;
	size_t slots;
	BUN p, q, r;
	oid bhsb;
	size_t base, end, w;
	ssize_t offset;

	if( bn == NULL)
		return GDK_FAIL;
	off = BUNindex(bn,BUNfirst(bn));

	ALGODEBUG THRprintf(GDKout, "CMDaggrX3_avg3_@1[@2](b=%s,g=%s,e=%s);\n",
		BATgetId(b),BATgetId(g),BATgetId(e));
/*	ERRORcheck((BATcount(b)!=BATcount(g)), "CMDaggrX3_avg3_@1: BATs b & g must be of equal size.\n");	*/
	ERRORcheck((g->htype == TYPE_void) && (g->hseqbase == oid_nil) && (BATcount(g) > 0), "CMDaggrX3_avg3_@1: head of BAT g must not be nil.\n");

	if((g->hseqbase == oid_nil) || (!BAThdense(g)) || (!(BAThordered(b)&1)) || (!g->hkey)) {
		return CMDaggrX3_avg_@1(ret, BATjoin(BATmirror(g),b,oid_nil), e);
	}

	/* init: set all sums & counts to zero and calculate min/max oid */
	@:init_result(dbl)@
	range = max - min + 1;

	/* scan b & g, calculate sums & counts, derive averages */
	if (e->htype == TYPE_void) {
		/* void lookup */
		slots = BATcount(e);
		if (b->htype == TYPE_void) {
			@:aggrX3_avg3(0,0,BUNfndVOID,var,&bhsb;bhsb++,@1,@2,BUNt@2(bn,r),BUNindex(bn,r)-off)@
		} else {
			@:aggrX3_avg3(0,0,BUNfndVOID,var,BUNhloc(b,p),@1,@2,BUNt@2(bn,r),BUNindex(bn,r)-off)@
		}
	/* e->htype == TYPE_oid */
	} else if (range > SMALL_AGGR_MAX) {
		/* hash lookup */
		slots = BATcount(e);
		if (b->htype == TYPE_void) {
			@:aggrX3_avg3(0,1,HASHfnd_oid,loc,&bhsb;bhsb++,@1,@2,BUNt@2(bn,r),BUNindex(bn,r)-off)@
		} else {
			@:aggrX3_avg3(0,1,HASHfnd_oid,loc,BUNhloc(b,p),@1,@2,BUNt@2(bn,r),BUNindex(bn,r)-off)@
		}
	} else {
		/* array lookup */
		slots = range;
		if (b->htype == TYPE_void) {
			@:aggrX3_avg3(1,0,CHKrange,loc,&bhsb;bhsb++,@1,@2,&sums[(*(oid*)h)-min],(*(oid*)h)-min)@
		} else {
			@:aggrX3_avg3(1,0,CHKrange,loc,BUNhloc(b,p),@1,@2,&sums[(*(oid*)h)-min],(*(oid*)h)-min)@
		}
	}

	*ret = bn;
	return GDK_SUCCEED;
}
@c
@:arithavg3(sht,loc)@
@:arithavg3(int,loc)@
@:arithavg3(lng,loc)@
@:arithavg3(flt,loc)@
@:arithavg3(dbl,loc)@

@- "Extremes" (Min & Max)
@c
/*	aggrX3_minmax3_ptr
		e-void-head	e-oid-head	e-oid-head
		void-lookup	hash-lookup	array-lookup

	@1:	</>		</>		</>		compare operator: <(min) or >(max)
	@2:	0		1		0		do BATprepareHash?
	@3:	BUNfndVOID	HASHfnd_oid	CHKrange	lookup
	@4:	var		loc		loc		e/bn-head-access

	@5:	"BUNhloc(b,p)" for  (oid) b-head-type,		b-head access
		"&bhsb; bhsb++" for (void) b-head-type

	@6:	(u)chr / sht / int / lng / any		b/bn-tail-storage-type
	@7:	"loc" for fixsized b/bn-tail-type,		b/bn-tail-access
		"var" for varsized b/bn-tail-type

	@8:	     BUNindex(bn,r)-off		(*(oid*)h)-min	index in extremes array
	@9:		max/min					initial result value
*/
@= aggrX3_minmax3_ptr
	ALGODEBUG THRprintf(GDKout, "aggrX3_minmax3_ptr(@1,@2,@3,@4,@5,@6,@7,@8,@9);\n");
	if (@2 && BATprepareHash(e)) {
		BBPreclaim(e);
		return GDK_FAIL;
	}
	/* init: create extremes and set all to the zero pointer */
	extremes = (ptr*) GDKmalloc(slots*sizeof(ptr));
	memset(extremes, 0, slots*sizeof(ptr));
	/* scan b & g and replace totals by the extreme value (just pointers to vals in b) */
	base = BUNindex(g, BUNfirst(g));
	offset = (ssize_t) (base - g->hseqbase);
	end = base + BATcount(g);
	bhsb = b->hseqbase;
	BATloopFast(b, p, q, xx) {
		ptr t = BUNt@7(b,p);
		oid v = *(oid*) @5;

		w = offset + v;
		if (w >= base && w < end) {
			oid *h = (oid*) BUNtloc(g, BUNptr(g, w));

			@3(r, bn, (oid*)h);
			if (r) {
				ptr *val = &extremes[@8];
				if (*val != nil) {
					if ((*cmp)(t,nil) == 0) {
						*val = nil;
					} else if (*val == NULL || (*cmp)(t,*val) @1 0) {
						*val = t;
					}
				}
			}
		}
	}
	/* insert the extreme values into the result */
	BATloopFast(bn, r, q, xx) {
		oid *h = (oid*)BUNh@4(bn,r);
		ptr val = extremes[@8];
		(void) h;	/* silence compiler about unused variable */
		ATOMput(bn->ttype, bn->theap, BUNtloc(bn,r), val?val:nil);
	}
@c
/*	aggrX3_minmax3_oid
		e-void-head	e-oid-head	e-oid-head
		void-lookup	hash-lookup	array-lookup

	@1:	</>		</>		</>		compare operator: <(min) or >(max)
	@2:	0		1		0		do BATprepareHash?
	@3:	BUNfndVOID	HASHfnd_oid	CHKrange	lookup
	@4:	var		loc		loc		e/bn-head-access

	@5:	"BUNhloc(b,p)" for  (oid) b-head-type,		b-head access
		"&bhsb; bhsb++" for (void) b-head-type

	@6:	(u)chr / sht / int / lng / any		b/bn-tail-storage-type
	@7:	"loc" for fixsized b/bn-tail-type,		b/bn-tail-access
		"var" for varsized b/bn-tail-type

	@8:	     BUNindex(bn,r)-off		(*(oid*)h)-min	index in extremes array
	@9:		max/min					initial result value
*/
@= aggrX3_minmax3_oid
	ALGODEBUG THRprintf(GDKout, "aggrX3_minmax3_oid(@1,@2,@3,@4,@5,@6,@7,@8,@9);\n");
	if (@2 && BATprepareHash(e)) {
		BBPreclaim(e);
		return GDK_FAIL;
	}
	/* init: create extremes and set all to the zero pointer */
	extremes = (oid*) GDKmalloc(slots*sizeof(oid));
	{ size_t i = 0; for (; i < slots; i++ ) extremes[i] = GDK_oid_@9; }
	/* scan b & g and replace totals by the extreme value (just pointers to vals in b) */
	base = BUNindex(g, BUNfirst(g));
	offset = (ssize_t) (base - g->hseqbase);
	end = base + BATcount(g);
	bhsb = b->hseqbase;
	BATloopFast(b, p, q, xx) {
		ptr t = BUNt@7(b,p);
		oid v = *(oid*) @5;

		w = offset + v;
		if (w >= base && w < end) {
			oid *h = (oid*) BUNtloc(g, BUNptr(g, w));

			@3(r, bn, (oid*)h);
			if (r) {
				oid *val = &extremes[@8];
				if (*val != *(oid*)nil) {
					if ((*cmp)(t,nil) == 0) {
						*val = *(oid*)nil;
					} else if ((*cmp)(t,val) @1 0) {
						*val = *(oid*)t;
					}
				}
			}
		}
	}
	/* insert the extreme values into the result */
	BATloopFast(bn, r, q, xx) {
		oid *h = (oid*)BUNh@4(bn,r);
		oid val = extremes[@8];
		(void) h;	/* silence compiler about unused variable */
		ATOMput(bn->ttype, bn->theap, BUNtloc(bn,r), &val);
	}
@c

/*	extreme_typed
	@1:	min/max
	@2:	 < / >
	@3:	b/bn-tail-storage-type			(u) chr/sht/int/lng/any
	@4:	"loc" for fixsized b/bn-tail-type,	b/bn-tail-access
		"var" for varsized b/bn-tail-type
	@5:	ptr/oid					void/any
	@6:	max/min					initial result value
*/
@= extreme3_typed
static int
aggrX3_@13_@3_@4_@5(BAT **ret, BAT *b, BAT *g, BAT *e)
{
	BAT *bn = BATnew(e->htype, BATttype(b), BATcount(e));
	int (*cmp)(ptr,ptr);
	ptr nil;
	int xx;
	size_t off;
	@5 *extremes = NULL;
	BUN p, q, r;
	size_t slots, range;
	oid min, max;
	oid bhsb;
	size_t base, end, w;
	ssize_t offset;

	if(bn == NULL)
		return GDK_FAIL;
	cmp = BATatoms[bn->ttype].atomCmp;
	nil = ATOMnilptr(bn->ttype);
	off = BUNindex(bn,BUNfirst(bn));
	*ret = NULL;

	ALGODEBUG THRprintf(GDKout, "aggrX3_@1_@3_@4_@5[@2,@6](b=%s,g=%s,e=%s);\n",
		BATgetId(b),BATgetId(g),BATgetId(e));
/*	ERRORcheck((BATcount(b)!=BATcount(g)), "aggrX3_@13_@3_@4: BATs b & g must be of equal size.\n");	*/
	ERRORcheck((g->htype == TYPE_void) && (g->hseqbase == oid_nil) && (BATcount(g) > 0), "aggrX3_@13_@3_@4_@5: head of BAT g must not be nil.\n");

	if((g->hseqbase == oid_nil) || (!BAThdense(g)) || (!(BAThordered(b)&1)) || (!g->hkey)) {
		return aggrX3_@1_@3_@4_@5(ret, BATjoin(BATmirror(g),b,oid_nil), e);
	}

	/* init: prepare the result bat;
	 * trick: by using "tail-type" void, we only write the head column, here */
	@:init_result(void)@
	range = max - min + 1;

	/* scan b & g and replace totals by the extreme value (just pointers to vals in b) */
	slots = BATcount(e);
	if (e->htype == TYPE_void) {
		/* void lookup */
		if (b->htype == TYPE_void) {
			@:aggrX3_minmax3_@5(@2,0,BUNfndVOID,var,&bhsb; bhsb++,@3,@4,BUNindex(bn,r)-off,@6)@
		} else {
			@:aggrX3_minmax3_@5(@2,0,BUNfndVOID,var,BUNhloc(b,p),@3,@4,BUNindex(bn,r)-off,@6)@
		}
	/* e->htype == TYPE_oid */
	} else if (range > SMALL_AGGR_MAX) {
		/* hash lookup */
		if (b->htype == TYPE_void) {
			@:aggrX3_minmax3_@5(@2,1,HASHfnd_oid,loc,&bhsb; bhsb++,@3,@4,BUNindex(bn,r)-off,@6)@
		} else {
			@:aggrX3_minmax3_@5(@2,1,HASHfnd_oid,loc,BUNhloc(b,p),@3,@4,BUNindex(bn,r)-off,@6)@
		}
	} else {
		/* array lookup */
		slots = range;
		if (b->htype == TYPE_void) {
			@:aggrX3_minmax3_@5(@2,0,CHKrange,loc,&bhsb; bhsb++,@3,@4,(*(oid*)h)-min,@6)@
		} else {
			@:aggrX3_minmax3_@5(@2,0,CHKrange,loc,BUNhloc(b,p),@3,@4,(*(oid*)h)-min,@6)@
		}
	}
	*ret = bn;
bunins_failed:
	if (extremes)
		GDKfree(extremes);
	return *ret?GDK_SUCCEED:GDK_FAIL;
}
@c
/*	extreme
	@1:	min/max
	@2:	 < / >
*/
@= extreme3
@:extreme3_typed(@1,@2,chr,loc,ptr,@3)@
@:extreme3_typed(@1,@2,sht,loc,ptr,@3)@
@:extreme3_typed(@1,@2,int,loc,ptr,@3)@
@:extreme3_typed(@1,@2,lng,loc,ptr,@3)@
@:extreme3_typed(@1,@2,any,loc,ptr,@3)@
@:extreme3_typed(@1,@2,any,var,ptr,@3)@
@:extreme3_typed(@1,@2,any,var,oid,@3)@

int
CMDaggrX3_@13(BAT **ret, BAT *b, BAT *g, BAT *e)
{
	int rtrn, tt = ATOMstorage(b->ttype);
	ALGODEBUG THRprintf(GDKout, "CMDaggrX3_@1[@2](b=%s,g=%s,e=%s);\n",
		BATgetId(b),BATgetId(g),BATgetId(e));
/*	ERRORcheck((BATcount(b)!=BATcount(g)), "aggrX3_@13: BATs b & g must be of equal size.\n");	*/
	ERRORcheck((g->htype == TYPE_void) && (g->hseqbase == oid_nil) && (BATcount(g) > 0), "aggrX3_@13: head of BAT g must not be nil.\n");

	if((g->hseqbase == oid_nil) || (!BAThdense(g)) || (!(BAThordered(b)&1)) || (!g->hkey)) {
		return CMDaggrX3_@1(ret, BATjoin(BATmirror(g),b,oid_nil), e);
	}

	if (b->ttype == TYPE_void) {
		rtrn = aggrX3_@13_any_var_oid(ret, b, g, e);
	} else if (tt == TYPE_chr) {
		rtrn = aggrX3_@13_chr_loc_ptr(ret, b, g, e);
	} else if (tt == TYPE_sht) {
		rtrn = aggrX3_@13_sht_loc_ptr(ret, b, g, e);
	} else if (b->ttype != TYPE_bat && (tt == TYPE_int || tt == TYPE_flt)) {
		/* ensure use of ATOMput for TYPE_bat */
		rtrn = aggrX3_@13_int_loc_ptr(ret, b, g, e);
	} else if (tt == TYPE_dbl || tt == TYPE_lng) {
		rtrn = aggrX3_@13_lng_loc_ptr(ret, b, g, e);
	} else if (b->tvarsized) {
		rtrn = aggrX3_@13_any_var_ptr(ret, b, g, e);
	} else {
		rtrn = aggrX3_@13_any_loc_ptr(ret, b, g, e);
	}
	return rtrn;
}
@c
@:extreme3(min,<,max)@
@:extreme3(max,>,min)@

@- Count
@c
/*	aggrX3_count3
		e-void-head	e-oid-head	e-oid-head
		void-lookup	hash-lookup	array-lookup

	@1:	0		0		1		use cnt-array?
	@2:	0		1		0		do BATprepareHash?
	@3:	BUNfndVOID	HASHfnd_oid	CHKrange	lookup
	@4:	var		loc		loc		e/bn-head-access

	@5:	"BUNhloc(b,p)" for  (oid) b-head-type,		b-head access
		"&bhsb; bhsb++" for (void) b-head-type

	@6:	BUNtloc(bn,r)	BUNtloc(bn,r)	&cnt[(*(oid*)h)-min]
								*dst: count in-place or in cnt-array ?
*/
@= aggrX3_count3
	ALGODEBUG THRprintf(GDKout, "aggrX3_count3(@1,@2,@3,@4,@5,@6);\n");
	if (@1) {
		/* create tmp. cnt array */
		cnt = (int*) GDKmalloc(range*sizeof(int));
		memset(cnt, 0, range*sizeof(int));
	}
	if (@2 && BATprepareHash(bn)) {
		if (@1)
			GDKfree(cnt);
		BBPreclaim(bn);
		return GDK_FAIL;
	}
	/* scan b & g, and increment counts in-place or in cnt-array */
	base = BUNindex(g, BUNfirst(g));
	offset = (ssize_t) (base - g->hseqbase);
	end = base + BATcount(g);
	bhsb = b->hseqbase;
	btt = b->ttype;
	if (*ignore_nils) {
		switch(ATOMstorage(btt)) {
		case TYPE_chr:
			@:aggrX3_count3_loop(@1,@2,@3,@4,@5,@6,if (!simple_EQ(BUNtloc(b,p),bt_nil,chr)))@
		case TYPE_sht:
			@:aggrX3_count3_loop(@1,@2,@3,@4,@5,@6,if (!simple_EQ(BUNtloc(b,p),bt_nil,sht)))@
		case TYPE_int:
			@:aggrX3_count3_loop(@1,@2,@3,@4,@5,@6,if (!simple_EQ(BUNtloc(b,p),bt_nil,int)))@
		case TYPE_lng:
			@:aggrX3_count3_loop(@1,@2,@3,@4,@5,@6,if (!simple_EQ(BUNtloc(b,p),bt_nil,lng)))@
		case TYPE_flt:
			@:aggrX3_count3_loop(@1,@2,@3,@4,@5,@6,if (!simple_EQ(BUNtloc(b,p),bt_nil,flt)))@
		case TYPE_dbl:
			@:aggrX3_count3_loop(@1,@2,@3,@4,@5,@6,if (!simple_EQ(BUNtloc(b,p),bt_nil,dbl)))@
		default:
			if (b->tvarsized) {
				@:aggrX3_count3_loop(@1,@2,@3,@4,@5,@6,if (!atom_EQ(BUNtvar(b,p),bt_nil,btt)))@
			} else {
				@:aggrX3_count3_loop(@1,@2,@3,@4,@5,@6,if (!atom_EQ(BUNtloc(b,p),bt_nil,btt)))@
			}
		}
	} else {
		switch(ATOMstorage(btt)) {
		case TYPE_chr:
			@:aggrX3_count3_loop(@1,@2,@3,@4,@5,@6,)@
		case TYPE_sht:
			@:aggrX3_count3_loop(@1,@2,@3,@4,@5,@6,)@
		case TYPE_int:
			@:aggrX3_count3_loop(@1,@2,@3,@4,@5,@6,)@
		case TYPE_lng:
			@:aggrX3_count3_loop(@1,@2,@3,@4,@5,@6,)@
		case TYPE_flt:
			@:aggrX3_count3_loop(@1,@2,@3,@4,@5,@6,)@
		case TYPE_dbl:
			@:aggrX3_count3_loop(@1,@2,@3,@4,@5,@6,)@
		default:
			if (b->tvarsized) {
				@:aggrX3_count3_loop(@1,@2,@3,@4,@5,@6,)@
			} else {
				@:aggrX3_count3_loop(@1,@2,@3,@4,@5,@6,)@
			}
		}
	}
	if (@1) {
		/* copy cnt array to final result */
		BATloopFast(bn, p, q, xx) {
			oid h = (*(oid*) BUNh@4(bn,p)) - min;
			*(int*)BUNtloc(bn, p) = cnt[h];
		}
		GDKfree(cnt);
	}
@c
/*	aggrX3_count3_loop
	@7:	if (!atom_EQ(BUNt{loc,var}(b,p),bt_nil,btt))		b-tail nil check
		if (!simple_EQ(BUNtloc(b,p),bt_nil,{chr,sht,int,flt,lng,dbl}))
*/
@= aggrX3_count3_loop
	ALGODEBUG THRprintf(GDKout, "aggrX3_count3_loop(@1,@2,@3,@4,@5,@6,@7);\n");
	BATloopFast(b, p, q, xx) {
		oid v = *(oid*) @5;

		w = offset + v;
		if (w >= base && w < end) {
			oid *h = (oid*) BUNtloc(g, BUNptr(g, w));

			@3(r, bn, (oid*)h);
			if (r) {
				@7 {
					int *dst = (int*) @6;
					(*dst)++;
				}
			}
		}
	}
	break;
@c
int
CMDaggrX3_count3(BAT **ret, BAT *b, BAT *g, BAT *e, bit *ignore_nils)
{
	BAT *bn = BATnew(e->htype, TYPE_int, BATcount(e));
	int zero = 0, *cnt;
	BUN p, q, r;
	int xx;
	size_t range;
	oid min, max;
	oid bhsb;
	size_t base, end, w;
	ssize_t offset;
	int btt;
	ptr bt_nil = ATOMnilptr(b->ttype);

	if (bn == NULL)
		return GDK_FAIL;

	ALGODEBUG THRprintf(GDKout, "CMDaggrX3_count3(b=%s,g=%s,e=%s);\n", 
		BATgetId(b),BATgetId(g),BATgetId(e));

/*	ERRORcheck((BATcount(b)!=BATcount(g)), "CMDaggrX3_count3: BATs b & g must be of equal size.\n");	*/
	ERRORcheck((g->htype == TYPE_void) && (g->hseqbase == oid_nil) && (BATcount(g) > 0), "CMDaggrX3_count3: head of BAT g must not be nil.\n");

	if ((g->hseqbase == oid_nil) || (!BAThdense(g)) || (!(BAThordered(b) & 1)) || (!g->hkey)) {
		return CMDaggrX3_count(ret, BATjoin(BATmirror(g), b, oid_nil), e, ignore_nils);
	}

	/* init: set all counts to zero and calculate min/max oid */
	@:init_result(int)@
	range = max - min + 1;

	/* scan b & g, and calculate counts */
	if (e->htype == TYPE_void) {
		/* void lookup */
		if (b->htype == TYPE_void) {
			@:aggrX3_count3(0,0,BUNfndVOID,var,&bhsb;bhsb++,BUNtloc(bn,r))@
		} else {
			@:aggrX3_count3(0,0,BUNfndVOID,var,BUNhloc(b,p),BUNtloc(bn,r))@
		}
		/* e->htype == TYPE_oid */
	} else if (range > SMALL_AGGR_MAX) {
		/* hash lookup */
		if (b->htype == TYPE_void) {
			@:aggrX3_count3(0,1,HASHfnd_oid,loc,&bhsb;bhsb++,BUNtloc(bn,r))@
		} else {
			@:aggrX3_count3(0,1,HASHfnd_oid,loc,BUNhloc(b,p),BUNtloc(bn,r))@
		}
	} else {
		/* array lookup */
		if (b->htype == TYPE_void) {
			@:aggrX3_count3(1,0,CHKrange,loc,&bhsb;bhsb++,&cnt[(*(oid*)h)-min])@
		} else {
			@:aggrX3_count3(1,0,CHKrange,loc,BUNhloc(b,p),&cnt[(*(oid*)h)-min])@
		}
	}

	*ret = bn;
	return GDK_SUCCEED;
}

@- Wrapper
The remainder is a wrapper around the V4 code base.


@c
#include "mal.h"
#include "mal_exception.h"
@-
@= AX3sum
mal_export str AX3aggrX3_sum_@1_@3(int *retid, int *bid, int *eid);
str AX3aggrX3_sum_@1_@3(int *retid, int *bid, int *eid){
	BAT *b, *e;
	BAT *bn;

    if( (b= BATdescriptor(*bid)) == NULL ){
        return throwMessage("bbp.sum", "Cannot access descriptor");
    }
    if( (e= BATdescriptor(*eid)) == NULL ){
		BBPunfix(b->batCacheid);
        return throwMessage("bbp.sum", "Cannot access descriptor");
    }
	if( CMDaggrX3_sum_@1_@3(&bn,b,e) == GDK_SUCCEED){
		BBPunfix(b->batCacheid);
		BBPunfix(e->batCacheid);
		BBPincref(*retid = bn->batCacheid,TRUE);
		BBPunfix(*retid);
		return MAL_SUCCEED;
	}
	BBPunfix(b->batCacheid);
	BBPunfix(e->batCacheid);
	return throwMessage("aggrX3_sum.@4","GDKerror");
}
@-

@= AX3prod
mal_export str AX3aggrX3_prod_@1_@3(int *retid, int *bid, int *eid);
str AX3aggrX3_prod_@1_@3(int *retid, int *bid, int *eid){
	BAT *b, *e, *bn;

    if( (b= BATdescriptor(*bid)) == NULL ){
        return throwMessage("bbp.prod", "Cannot access descriptor");
    }
    if( (e= BATdescriptor(*eid)) == NULL ){
		BBPunfix(b->batCacheid);
        return throwMessage("bbp.prod", "Cannot access descriptor");
    }
	if( CMDaggrX3_prod_@1_@3(&bn,b,e) == GDK_SUCCEED){
		BBPunfix(b->batCacheid);
		BBPunfix(e->batCacheid);
		BBPincref(*retid = bn->batCacheid,TRUE);
		BBPunfix(*retid);
		return MAL_SUCCEED;
	}
	BBPunfix(b->batCacheid);
	BBPunfix(e->batCacheid);
	return throwMessage("aggrX3_sum.@4","GDKerror");
}
@-
@= AX3sumprod
	@:AX3sum(@1,@2,@3)@
	/* product here */
	@:AX3prod(@1,@2,@3)@
@c

@:AX3sumprod(sht,tloc,sht)@
@:AX3sumprod(sht,tloc,int)@
@:AX3sumprod(sht,tloc,lng)@
@:AX3sumprod(int,tloc,int)@
@:AX3sumprod(int,tloc,lng)@
@:AX3sumprod(lng,tloc,lng)@
@:AX3sumprod(flt,tloc,flt)@
@:AX3sumprod(flt,tloc,dbl)@
@:AX3sumprod(dbl,tloc,dbl)@

@-
@= AX3arithavg
mal_export str AX3aggrX3_avg_@1(int *retid, int *bid, int *eid);
str AX3aggrX3_avg_@1(int *retid, int *bid, int *eid){
	BAT *b, *e, *bn;

    if( (b= BATdescriptor(*bid)) == NULL ){
        return throwMessage("bbp.avg", "Cannot access descriptor");
    }
    if( (e= BATdescriptor(*eid)) == NULL ){
		BBPunfix(b->batCacheid);
        return throwMessage("bbp.avg", "Cannot access descriptor");
    }
	if( CMDaggrX3_avg_@1(&bn,b,e) == GDK_SUCCEED){
		BBPunfix(b->batCacheid);
		BBPunfix(e->batCacheid);
		BBPincref(*retid = bn->batCacheid,TRUE);
		BBPunfix(*retid);
		return MAL_SUCCEED;
	}
	BBPunfix(b->batCacheid);
	BBPunfix(e->batCacheid);
	return throwMessage("aggrX3_avg.@1","GDKerror");
}
@c
@:AX3arithavg(sht,loc)@
@:AX3arithavg(int,loc)@
@:AX3arithavg(lng,loc)@
@:AX3arithavg(flt,loc)@
@:AX3arithavg(dbl,loc)@


@- "Extremes" (Min & Max)
@= AX3extreme
mal_export str AX3aggrX3_@1(int *ret, int *bid, int *eid);
str AX3aggrX3_@1(int *ret, int *bid, int *eid){
	BAT *b, *e, *bn;
    if( (b= BATdescriptor(*bid)) == NULL ){
        return throwMessage("bbp.avg", "Cannot access descriptor");
    }
    if( (e= BATdescriptor(*eid)) == NULL ){
		BBPunfix(b->batCacheid);
        return throwMessage("bbp.avg", "Cannot access descriptor");
    }

	if( CMDaggrX3_@1(&bn,b,e) == GDK_SUCCEED){
		BBPunfix(b->batCacheid);
		BBPunfix(e->batCacheid);
		BBPincref(*ret = bn->batCacheid,TRUE);
		BBPunfix(*ret);
		return MAL_SUCCEED;
	}
	BBPunfix(b->batCacheid);
	BBPunfix(e->batCacheid);
	return throwMessage("aggrX3_@1","GDKerror");
}
@c
@:AX3extreme(min,<)@
@:AX3extreme(max,>)@

@- Count
@c
mal_export str AX3aggrX3_count(int *retid, int *bid, int *eid, bit *ignore_nils);
str
AX3aggrX3_count(int *retid, int *bid, int *eid, bit *ignore_nils)
{
	BAT *b, *e, *bn;

	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("bbp.avg", "Cannot access descriptor");
	}
	if ((e = BATdescriptor(*eid)) == NULL) {
		BBPunfix(b->batCacheid);
		return throwMessage("bbp.avg", "Cannot access descriptor");
	}

	if (CMDaggrX3_count(&bn, b, e, ignore_nils) == GDK_SUCCEED) {
		BBPincref(*retid = bn->batCacheid, TRUE);
		BBPunfix(*retid);
		return MAL_SUCCEED;
	}
	BBPunfix(b->batCacheid);
	BBPunfix(e->batCacheid);
	return throwMessage("aggrX3_count", "GDKerror");
}

@- Size
@c
mal_export str AX3aggrX3_size(int *retid, int *bid, int *eid);
str
AX3aggrX3_size(int *retid, int *bid, int *eid)
{
	BAT *b, *e;
	BAT *bn;

	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("bbp.avg", "Cannot access descriptor");
	}
	if ((e = BATdescriptor(*eid)) == NULL) {
		BBPunfix(b->batCacheid);
		return throwMessage("bbp.avg", "Cannot access descriptor");
	}
	if (CMDaggrX3_size(&bn, b, e) == GDK_SUCCEED) {
		BBPunfix(b->batCacheid);
		BBPunfix(e->batCacheid);
		BBPincref(*retid = bn->batCacheid, TRUE);
		BBPunfix(*retid);
		return MAL_SUCCEED;
	}
	BBPunfix(b->batCacheid);
	BBPunfix(e->batCacheid);
	return throwMessage("aggrX3_size", "GDKerror");
}

@- Sum & Average & Prod	
@= AX3arithsum3
mal_export str AX3aggrX3_sum3_@1_@2(int *retid,int *bid, int *gid, int *eid);
str AX3aggrX3_sum3_@1_@2(int *retid,int *bid, int *gid, int *eid){
	BAT *b,*g, *e;
	BAT *bn;

    if( (b= BATdescriptor(*bid)) == NULL ){
        return throwMessage("bbp.avg", "Cannot access descriptor");
    }
    if( (e= BATdescriptor(*eid)) == NULL ){
		BBPunfix(b->batCacheid);
        return throwMessage("bbp.avg", "Cannot access descriptor");
    }
    if( (g= BATdescriptor(*gid)) == NULL ){
		BBPunfix(e->batCacheid);
		BBPunfix(b->batCacheid);
        return throwMessage("bbp.avg", "Cannot access descriptor");
    }
	if( CMDaggrX3_sum3_@1_@2(&bn,b,g,e) == GDK_SUCCEED){
		BBPunfix(b->batCacheid);
		BBPunfix(e->batCacheid);
		BBPunfix(g->batCacheid);
		BBPincref(*retid = bn->batCacheid,TRUE);
		BBPunfix(*retid);
		return MAL_SUCCEED;
	}
	BBPunfix(b->batCacheid);
	BBPunfix(e->batCacheid);
	BBPunfix(g->batCacheid);
	return throwMessage("aggrX3_sum3","GDKerror");
}
@-
@= AX3prod3
mal_export str AX3aggrX3_prod3_@1_@2(int *retid,int *bid, int *gid, int *eid);
str AX3aggrX3_prod3_@1_@2(int *retid,int *bid, int *gid, int *eid){
	BAT *b,*g, *e;
	BAT *bn;

    if( (b= BATdescriptor(*bid)) == NULL ){
        return throwMessage("bbp.avg", "Cannot access descriptor");
    }
    if( (e= BATdescriptor(*eid)) == NULL ){
		BBPunfix(b->batCacheid);
        return throwMessage("bbp.avg", "Cannot access descriptor");
    }
    if( (g= BATdescriptor(*gid)) == NULL ){
		BBPunfix(e->batCacheid);
		BBPunfix(b->batCacheid);
        return throwMessage("bbp.avg", "Cannot access descriptor");
	}
	if( CMDaggrX3_prod3_@1_@2(&bn,b,g,e) == GDK_SUCCEED){
		BBPunfix(b->batCacheid);
		BBPunfix(e->batCacheid);
		BBPunfix(g->batCacheid);
		BBPincref(*retid = bn->batCacheid,TRUE);
		BBPunfix(*retid);
		return MAL_SUCCEED;
	}
	BBPunfix(b->batCacheid);
	BBPunfix(e->batCacheid);
	BBPunfix(g->batCacheid);
	return throwMessage("aggrX3_prod3","GDKerror");
}
@-
@= AX3sumprod3
@:AX3arithsum3(@1,@2)@
@:AX3prod3(@1,@2)@
@c

@:AX3sumprod3(sht,sht)@
@:AX3sumprod3(sht,int)@
@:AX3sumprod3(sht,lng)@
@:AX3sumprod3(int,int)@
@:AX3sumprod3(int,lng)@
@:AX3sumprod3(lng,lng)@
@:AX3sumprod3(flt,flt)@
@:AX3sumprod3(flt,dbl)@
@:AX3sumprod3(dbl,dbl)@

@= AX3arithavg3
mal_export str AX3aggrX3_avg3_@1(int *retid,int *bid, int *gid, int *eid);
str AX3aggrX3_avg3_@1(int *retid,int *bid, int *gid, int *eid){
	BAT *b,*g,*e;
	BAT *bn;

    if( (b= BATdescriptor(*bid)) == NULL ){
        return throwMessage("bbp.avg", "Cannot access descriptor");
    }
    if( (e= BATdescriptor(*eid)) == NULL ){
		BBPunfix(b->batCacheid);
        return throwMessage("bbp.avg", "Cannot access descriptor");
    }
    if( (g= BATdescriptor(*gid)) == NULL ){
		BBPunfix(e->batCacheid);
		BBPunfix(b->batCacheid);
        return throwMessage("bbp.avg", "Cannot access descriptor");
	}
	if( CMDaggrX3_avg3_@1(&bn,b,g,e) == GDK_SUCCEED){
		BBPunfix(b->batCacheid);
		BBPunfix(e->batCacheid);
		BBPunfix(g->batCacheid);
		BBPincref(*retid = bn->batCacheid,TRUE);
		BBPunfix(*retid);
		return MAL_SUCCEED;
	}
	BBPunfix(b->batCacheid);
	BBPunfix(e->batCacheid);
	BBPunfix(g->batCacheid);
	return throwMessage("aggrX3_prod3","GDKerror");
}
@c
@:AX3arithavg3(sht,loc)@
@:AX3arithavg3(int,loc)@
@:AX3arithavg3(lng,loc)@
@:AX3arithavg3(flt,loc)@
@:AX3arithavg3(dbl,loc)@

@- "Extremes" (Min & Max)
@c
@= AX3extreme3
mal_export str AX3aggrX3_@13(int *ret,int *bid, int *gid, int *eid);
str AX3aggrX3_@13(int *ret,int *bid, int *gid, int *eid){
	BAT *b,*g,*e, *bn;

    if( (b= BATdescriptor(*bid)) == NULL ){
        return throwMessage("bbp.avg", "Cannot access descriptor");
    }
    if( (e= BATdescriptor(*eid)) == NULL ){
		BBPunfix(b->batCacheid);
        return throwMessage("bbp.avg", "Cannot access descriptor");
    }
    if( (g= BATdescriptor(*gid)) == NULL ){
		BBPunfix(e->batCacheid);
		BBPunfix(b->batCacheid);
        return throwMessage("bbp.avg", "Cannot access descriptor");
	}
	if( CMDaggrX3_@13(&bn,b,g,e) == GDK_SUCCEED){
		BBPunfix(b->batCacheid);
		BBPunfix(e->batCacheid);
		BBPunfix(g->batCacheid);
		BBPincref(*ret = bn->batCacheid,TRUE);
		BBPunfix(*ret);
		return MAL_SUCCEED;
	}
	BBPunfix(b->batCacheid);
	BBPunfix(e->batCacheid);
	BBPunfix(g->batCacheid);
	return throwMessage("aggrX3_prod3","GDKerror");
}
@c
@:AX3extreme3(min,<)@
@:AX3extreme3(max,>)@

mal_export str AX3aggrX3_count3(int *retid, int *bid, int *gid, int *eid, bit *ignore_nils);
str
AX3aggrX3_count3(int *retid, int *bid, int *gid, int *eid, bit *ignore_nils)
{
	BAT *b, *g, *e;
	BAT *bn;

	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("bbp.count", "Cannot access descriptor");
	}
	if ((e = BATdescriptor(*eid)) == NULL) {
		BBPunfix(b->batCacheid);
		return throwMessage("bbp.count", "Cannot access descriptor");
	}
	if ((g = BATdescriptor(*gid)) == NULL) {
		BBPunfix(e->batCacheid);
		BBPunfix(b->batCacheid);
		return throwMessage("bbp.count", "Cannot access descriptor");
	}
	if (CMDaggrX3_count3(&bn, b, g, e, ignore_nils) == GDK_SUCCEED) {
		BBPunfix(b->batCacheid);
		BBPunfix(e->batCacheid);
		BBPunfix(g->batCacheid);
		BBPincref(*retid = bn->batCacheid, TRUE);
		BBPunfix(*retid);
		return MAL_SUCCEED;
	}
	BBPunfix(b->batCacheid);
	BBPunfix(e->batCacheid);
	BBPunfix(g->batCacheid);
	return throwMessage("aggrX3_prod3", "GDKerror");
}
@-
The remainder contains the few MIL proc translations 
@c
mal_export str AX3aggrX3_count3Nils(int *retid, int *bid, int *gid, int *eid);
str
AX3aggrX3_count3Nils(int *retid, int *bid, int *gid, int *eid)
{
	bit ignore_nils = 0;
	return AX3aggrX3_count3(retid, bid, gid, eid, &ignore_nils);
}

mal_export str AX3count_no_nil3(int *retid, int *bid, int *gid, int *eid);
str 
AX3count_no_nil3(int *retid, int *bid, int *gid, int *eid)
{
	bit ignore_nils = TRUE;
	return AX3aggrX3_count3(retid, bid, gid, eid, &ignore_nils);
}

mal_export str AX3aggrX3_count2Nils(int *retid, int *bid, int *eid);
str
AX3aggrX3_count2Nils(int *retid, int *bid, int *eid)
{
	bit ignore_nils = 0;
	return AX3aggrX3_count(retid, bid, eid, &ignore_nils);
}

mal_export str AX3count_no_nil2(int *retid, int *bid, int *eid);
str
AX3count_no_nil2(int *retid, int *bid, int *eid)
{
	bit ignore_nils = TRUE;
	return AX3aggrX3_count(retid, bid, eid, &ignore_nils);
}
@-
@}
