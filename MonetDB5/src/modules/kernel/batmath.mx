@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2006 CWI.
@' All Rights Reserved.

@f batmath
@a M.L. Kersten
@+ BAT math calculator

@{
@= tstBat
if( bn== NULL) {*ret= 0;
	throw(MAL, "batcalc.@1", "can not create bat");}

@+ Scientific routines
The mmath functions are also overloaded to provide for
the fast execution of expanded code blocks.
The common set of math functions is supported.
@= scienceFcn
	command @1(x:bat[:oid,:dbl])  :bat[:oid,:dbl] 
	address CMDsciencevoid_@1;
@= scienceFcnBinary
	command @1(x:bat[:oid,:dbl],y:@2):bat[:oid,:dbl] 
	address CMDscience_@1;
@-
@mal
module batmath;
	@:scienceFcn(asin)@
	@:scienceFcn(acos)@
	@:scienceFcn(atan)@
	@:scienceFcn(cos)@
	@:scienceFcn(sin)@
	@:scienceFcn(tan)@
	@:scienceFcn(cosh)@
	@:scienceFcn(sinh)@
	@:scienceFcn(tanh)@
	@:scienceFcn(exp)@
	@:scienceFcn(log)@
	@:scienceFcn(log10)@
	@:scienceFcn(sqrt)@
	@:scienceFcn(ceil)@
	@:scienceFcn(fabs)@
	@:scienceFcn(floor)@
@-
	round is not binary...
	@:scienceFcnBinary(round,int)@
@mal
	@:scienceFcnBinary(fmod,dbl)@
	@:scienceFcnBinary(atan2,dbl)@
	@:scienceFcnBinary(pow,dbl)@
@- Implementation
@h
#ifdef _BATMATH_H
#define _BATMATH_H
#define NULLTST

#endif  /* _BATMATH_H */
@- Implementations of scientific functions
@c
#include "mal_config.h"
#include "gdk.h"
#include "math.h"
#include "mal_exception.h"
#include "batmath.h"

#ifdef WIN32
#ifndef LIBBATMATH
#define batmath_export extern __declspec(dllimport)
#else
#define batmath_export extern __declspec(dllexport)
#endif
#else
#define batmath_export extern
#endif

BAT *
BATMATHresult(BAT *b, int tpe)
{
	BAT *bn;

	if (BAThvoid(b)) {
		bn = BATnew(TYPE_void, tpe, BATcount(b));
		BATseqbase(bn, b->hseqbase);
	} else
		bn = BATnew(b->htype, tpe, BATcount(b));
	return bn;
}

@-
@= scienceFcnImpl
batmath_export str CMDsciencevoid_@1(int *ret, int *bid);
str CMDsciencevoid_@1(int *ret, int *bid){
	BAT *b,*bn;
	@2 *o;
	BUN p,q;
	size_t xx;

	if( (b= BATdescriptor(*bid)) == NULL ){
		throw(MAL, "batcalc.@1", "Cannot access descriptor");
	}
	if( BUNsize(b) != sizeof(@2)){
		BBPreleaseref(b->batCacheid);
		throw(MAL, "batcalc.@1","Unexpected type");
	}

	bn= BATMATHresult(b, TYPE_dbl);
	@:tstBat(CMDscience_@1)@
	o = (@2*) BUNtail(bn, BUNfirst(bn));

	xx= BUNsize(b);
	p = BUNtail(b, BUNfirst(b));
	q = BUNtail(b, BUNlast(b));

	while(p<q){
		*o++ = *(@2*)p== dbl_nil? dbl_nil: @1(*(@2*)p);
		p+= xx;
	}
	*ret= bn->batCacheid;
	BBPkeepref(*ret);
	BBPreleaseref(b->batCacheid);
	return MAL_SUCCEED;
}
@= scienceBinaryImpl
batmath_export str CMDscience_@1(int *ret, int *bid, @2 *d);
str CMDscience_@1(int *ret, int *bid, @2 *d){
	BAT *b,*bn;
	@2 *o;
	BUN p,q;
	size_t xx;

	if( (b= BATdescriptor(*bid)) == NULL ){
		throw(MAL, "batcalc.@1", "Cannot access descriptor");
	}
	if( BUNsize(b) != sizeof(@2)){
		BBPreleaseref(b->batCacheid);
		throw(MAL, "batcalc.@1","Unexpected type");
	}

	bn= BATMATHresult(b, TYPE_dbl);
	@:tstBat(CMDscience_@1)@
	o = (@2*) BUNtail(bn, BUNfirst(bn));

	xx= BUNsize(b);
	p = BUNtail(b, BUNfirst(b));
	q = BUNtail(b, BUNlast(b));

	while(p<q){
		*o++ = *(@2*)p== dbl_nil? dbl_nil: @1(*(@2*)p,*d);
		p+=xx;
	}

	if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ); 
	*ret= bn->batCacheid;
	BBPkeepref(*ret);
	BBPreleaseref(b->batCacheid);
	return MAL_SUCCEED;
}
@c
@:scienceFcnImpl(asin,dbl)@
@:scienceFcnImpl(acos,dbl)@
@:scienceFcnImpl(atan,dbl)@
@:scienceFcnImpl(cos,dbl)@
@:scienceFcnImpl(sin,dbl)@
@:scienceFcnImpl(tan,dbl)@
@:scienceFcnImpl(cosh,dbl)@
@:scienceFcnImpl(sinh,dbl)@
@:scienceFcnImpl(tanh,dbl)@
@:scienceFcnImpl(exp,dbl)@
@:scienceFcnImpl(log,dbl)@
@:scienceFcnImpl(log10,dbl)@
@:scienceFcnImpl(sqrt,dbl)@
@:scienceFcnImpl(ceil,dbl)@
@:scienceFcnImpl(fabs,dbl)@
@:scienceFcnImpl(floor,dbl)@
@-
	round is not binary...
	@:scienceBinaryImpl(round,int)@
@c
@:scienceBinaryImpl(fmod,dbl)@
@:scienceBinaryImpl(atan2,dbl)@
@:scienceBinaryImpl(pow,dbl)@

@}
