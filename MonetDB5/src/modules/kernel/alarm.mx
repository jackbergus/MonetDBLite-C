@/
The contents of this file are subject to the MonetDB Public License
Version 1.1 (the "License"); you may not use this file except in
compliance with the License. You may obtain a copy of the License at
http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html

Software distributed under the License is distributed on an "AS IS"
basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations
under the License.

The Original Code is the MonetDB Database System.

The Initial Developer of the Original Code is CWI.
Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
Copyright August 2008-2010 MonetDB B.V.
All Rights Reserved.
@

@f alarm
@a M.L. Kersten, P. Boncz

@+ Timers and Timed Interrupts
This module handles various signaling/timer functionalities.
The Monet interface supports two timer commands: @emph{ alarm} and @emph{ sleep}.
Their argument is the number of seconds to wait before the timer goes off.
The @emph{ sleep} command blocks till the alarm goes off.
The @emph{ alarm} command continues directly, executes off a MIL
string when it goes off.
The parameterless routines @emph{ time} and @emph{ ctime} provide access to
the cpu clock.They return an integer and string, respectively.
@{
@mal
module alarm;

command sleep(secs:int):void 
address ALARMsleep 
comment "sleep X secs";
command alarm(secs:int, action:str):void 
address ALARMsetalarm 
comment "execute action in X secs";
command timers{unsafe}() :bat[:str,:str] 
address ALARMtimers
comment "give a list of all active timers";
command usec{unsafe}() :lng 
address ALARMusec
comment "return cpu microseconds info";
command time{unsafe}() :int 
address ALARMtime 
comment "time in millisecs";
command epoch{unsafe}() :int 
address ALARMepoch 
comment "current time as unix epoch";
command ctime{unsafe}() :str 
address ALARMctime 
comment "current time as a string";
command prelude():void
address ALARMprelude 
comment "Initialize alarm module";
command epilogue():void
address ALARMepilogue 
comment "Finalize alarm module";

alarm.prelude();

@* Implementation
@+ The Clock Interrupt Generator
A clock event generator, called @%timer@, has been added to the database kernel.
It accepts a message @%CLKalarm(sec, usec)@, which generates an alarm
after the time indicated.
The timer maintains a small stack of timing events sorted in priority of firing.
The top contains the next timer event to go off.
The timer is disabled when no timer events are outstanding.
@h
#include <mal.h>
#include <signal.h>
#define MAXtimer                200

typedef struct {
	str action;		/* MIL action (as a string) */
	MT_Sema sema;		/* barrier */
	time_t alarm_time;	/* time when the alarm goes off */
} monet_timer_t;

@c
#include "mal_config.h"
#include "alarm.h"
#include <time.h>

#ifdef WIN32
#ifndef LIBALARM
#define alarm_export extern __declspec(dllimport)
#else
#define alarm_export extern __declspec(dllexport)
#endif
#else
#define alarm_export extern
#endif

alarm_export str ALARMprelude(void);
alarm_export str ALARMepilogue(void);
alarm_export str ALARMusec(lng *ret);
alarm_export str ALARMsleep(int *res, int *secs);
alarm_export str ALARMsetalarm(int *res, int *secs, str *action);
alarm_export str ALARMtimers(int *res);
alarm_export str ALARMctime(str *res);
alarm_export str ALARMepoch(int *res);
alarm_export str ALARMtime(int *res);

static monet_timer_t timer[MAXtimer];
static int timerTop = 0;

@
@-
The timer is awakened by a clock interrupt. The interrupt granularity
is OS-dependent. The timer should be initialized as long as there
are outstanding timer events.
@c
#ifdef SIGALRM
static void
CLKinitTimer(int sec, int usec)
{
	int i = sec - time(0);

	(void) usec;

	alarm(i);
}
#endif
@-
A new alarm is pushed onto the stack using @%CLKalarm@.
The parameter is the real-time value to be approximated.
@c
#ifdef SIGALRM
static void
CLKalarm(time_t t, str action)
{
	int j;
	int k;


	if (timerTop == MAXtimer) {
		GDKerror("CLKalarm: timer stack overflow\n");
		return;
	}
	for (j = 0; j < timerTop; j++) {
		if (timer[j].alarm_time > t)
			break;
	}
	for (k = timerTop; k > j; k--) {
		timer[k] = timer[k - 1];
	}
	timer[k].alarm_time = t;
	if (action) {
		timer[k].action = GDKstrdup(action);
	} else {
		timer[k].action = 0;
		MT_init_sema(timer[k].sema, 0, "timersema");
	}
	if (k == timerTop++) {
		CLKinitTimer(t, 0);	/* set it sooner */
	}
}
#endif
@-
Once a timer interrupt occurs, we should inspect the timer queue and
emit a notify signal.
@c
#ifdef SIGALRM
/* HACK to pacify compiler */
#if (defined(__INTEL_COMPILER) && (SIZEOF_VOID_P > SIZEOF_INT))
#undef  SIG_ERR			/*((__sighandler_t)-1 ) */
#define SIG_ERR   ((__sighandler_t)-1L)
#endif
static RETSIGTYPE
CLKsignal(int nr)
{
	/* int restype; */
	int k = timerTop;
	int t;

	(void) nr;

	if (signal(SIGALRM, CLKsignal) == SIG_ERR) {
		GDKsyserror("CLKsignal: call failed\n");
	}

	if (timerTop == 0) {
		return;
	}
	t = time(0);
	while (k-- && t >= timer[k].alarm_time) {
		if (timer[k].action) {
			/* monet_eval(timer[k].action, &restype); */
			GDKfree(timer[k].action);
		} else {
			MT_up_sema(timer[k].sema, "CLKsignal");
		}
		timerTop--;
	}
	if (timerTop > 0) {
		CLKinitTimer(timer[timerTop - 1].alarm_time, 0);
	}
}
#endif

bat *
CLKprelude(void)
{
#ifdef SIGALRM
	(void) signal(SIGALRM, CLKsignal);
#endif
	return NULL;
}

void
CLKepilogue(void)
{
	int k;

#if (defined(SIGALRM) && defined(SIG_IGN))
/* HACK to pacify compiler */
#if (defined(__INTEL_COMPILER) && (SIZEOF_VOID_P > SIZEOF_INT))
#undef  SIG_IGN			/*((__sighandler_t)1 ) */
#define SIG_IGN   ((__sighandler_t)1L)
#endif
	(void) signal(SIGALRM, SIG_IGN);
#endif
	for (k = 0; k < timerTop; k++) {
		if (timer[k].action)
			GDKfree(timer[k].action);
	}
}


int
CMDsleep(int *secs)
{

	if (*secs < 0) {
		GDKerror("CMDsleep: negative delay\n");
		return GDK_FAIL;
	} else {
#ifdef __CYGWIN__
		/* CYGWIN cannot handle SIGALRM with sleep */
		lng t = GDKusec() + (*secs)*1000000;
		
		while (GDKusec() < t)
			;
#else
		MT_sleep_ms(*secs * 1000);
#endif
	}
	return GDK_SUCCEED;
}

int
CMDalarm(int *secs, str action)
{
	if (*secs < 0) {
		GDKerror("CMDalarm: negative delay\n");
		return GDK_FAIL;
	} else {
#ifndef SIGALRM
		(void)action;
		GDKerror("CMDalarm: not implemented\n");
		return GDK_FAIL;
#else
		CLKalarm(time(0) + *secs, action);
#endif
	}
	return GDK_SUCCEED;
}

@-
Problem with CMDtimers is that they use static buffers that
may be overwritten under parallel processing.
Therefore, the code below is dangerous (!) and the re-entrant code
should be used.  However, on Windows where ctime_r is not available,
ctime is actually thread-safe.
@c
int
CMDtimers(BAT **retval)
{
	char buf[27];
	int k;

	*retval = BATnew(TYPE_str, TYPE_str, timerTop);
	if (*retval == NULL)
		return GDK_FAIL;
	BATroles(*retval, "alarm", "action");
	for (k = 0; k < timerTop; k++) {
		time_t t = timer[k].alarm_time;

#ifdef HAVE_CTIME_R3
		ctime_r(&t, buf, sizeof(buf));
#else
#ifdef HAVE_CTIME_R
		ctime_r(&t, buf);
#else
		strncpy(buf, ctime(&t), sizeof(buf));
#endif
#endif
		BUNins(*retval, buf, timer[k].action ? timer[k].action : "barrier", FALSE);
	}
	return GDK_SUCCEED;
}

int
CMDctime(str *retval)
{
	time_t t = time(0);
	char *base, *c;

#ifdef HAVE_CTIME_R3
	char buf[26];

	ctime_r(&t, buf, sizeof(buf));
	base = buf;
#else
#ifdef HAVE_CTIME_R
	char buf[26];

	ctime_r(&t, buf);
	base = buf;
#else
	base = ctime(&t);
#endif
#endif
	if (base == NULL) {
		/* very unlikely to happen... */
		GDKerror("CMDctime: failed to format time\n");
		return GDK_FAIL;
	}
	c = strchr(base, '\n');
	if (c)
		*c = 0;
	*retval = GDKstrdup(base);
	return GDK_SUCCEED;
}

int
CMDepoch(int *retval)		/* XXX should be lng */
{
	*retval = (int) time(0);
	return GDK_SUCCEED;
}

/* should return lng */
int
CMDusec(lng *retval)
{
	*retval = GDKusec();
	return GDK_SUCCEED;
}

int
CMDtime(int *retval)
{
	*retval = GDKms();
	return GDK_SUCCEED;
}

@- Wrapping
Wrapping the Version 4 code base
@c
#include "mal.h"
#include "mal_exception.h"

void
ALARMinitTimer(int sec, int usec)
{
	(void) sec;
	(void) usec;
#ifdef SIGALRM
	CLKinitTimer(sec, usec);
#endif
}

#ifdef SIGALRM
str
ALARMalarm(int t, str *action)
{
	CLKalarm(t, *action);
	return MAL_SUCCEED;
}
#endif

str
ALARMprelude()
{
#ifdef SIGALRM
	(void) signal(SIGALRM, (void (*)()) CLKsignal);
#endif
	return MAL_SUCCEED;
}

str
ALARMepilogue()
{
	CLKepilogue();
	return MAL_SUCCEED;
}

str
ALARMusec(lng *ret)
{
	CMDusec(ret);
	return MAL_SUCCEED;
}

str
ALARMsleep(int *res, int *secs)
{
	(void) res;		/* fool compilers */
	CMDsleep(secs);
	return MAL_SUCCEED;
}

str
ALARMsetalarm(int *res, int *secs, str *action)
{
	(void) res;
	(void) secs;
	(void) action;		/* foolc compiler */
	throw(MAL, "alarm.setalarm", PROGRAM_NYI);
}

str
ALARMtimers(int *res)
{
	(void) res;		/* fool compiler */
	throw(MAL, "alarm.timers", PROGRAM_NYI);
}

str
ALARMctime(str *res)
{
	CMDctime(res);
	return MAL_SUCCEED;
}

str
ALARMepoch(int *res)
{
	CMDepoch(res);
	return MAL_SUCCEED;
}

str
ALARMtime(int *res)
{
	CMDtime(res);
	return MAL_SUCCEED;
}

@}
