@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2007 CWI.
@' All Rights Reserved.

@f status
@a M.L. Kersten, P. Boncz, N.Nes
@v 2.0
@+ System state information 
This document introduces a series of bats  and operations that provide access
to information stored within the Monet Version 5 internal data structures.
In all cases, pseudo BAT operation returns a transient BAT that
should be garbage collected after being used.

The main performance drain would be to use a pseudo BAT directly to
successively access it components. This can be avoided by first assigning
the pseudo BAT to a variable.
@{
@mal
module status;

command cpuStatistics() :bat[:str,:int] 
address SYScpuStatistics
comment "Global cpu usage information";
command memStatistics():bat[:str,:int] 
address SYSmemStatistics
comment "Global memory usage information";
command ioStatistics():bat[:str,:int] 
address SYSioStatistics
comment "Global IO activity information";
#command memMap() :void 
#address SYSmemMap
#comment "Print a map of all memory that is in use";
@-

For each 64KB block in the first 3GB of the virtual memory @emph{mem_printmap()} 
prints a character:
@multitable @columnfractions 0.05 0.7
@item 0-9 
@tab - thread stack space of thread <num>
@item B 
@tab - in use for a large BAT heap 
   (i.e. anonymous virtual memory).
@item b 
@tab - free (last usage was B)
@item S 
@tab - in use for a malloc block
@item s 
@tab - free (last usage was S)
@item P 
@tab - in use for the BBP array 
   (i.e. anonymous virtual memory)
@item p 
@tab - free (last usage was P)
@item M 
@tab - in use as memory mapped region
@item m 
@tab - free (last usage was M)
@item C 
@tab - in use as MIL context buffer 
   (i.e. anonymous virtual memory)
@item c 
@tab - free (last usage was M)
@end multitable

On Linux, the malloc library appears to be using anonymous virtual memory, 
which goes undetected.  If you want to see all your memory in the map, 
lower the gdk_mmap threshold in monetdb5.conf to a low value (say 64KB).
@-
@mal
command vmStatistics(minsize:lng) :bat[:str,:lng] 
address SYSvm_usage
comment "Get a split-up of how much virtual memory blocks are in use.";
command memUsage(minsize:lng) :bat[:str,:lng] 
address SYSmem_usage
comment "Get a split-up of how much memory blocks are in use.";
@-
Some explanation of what mem_usage() and vm_usage() display:
@verbatim
> m:= status.memUsage(1024:lng); io.print(m);
#------------------------------#
# BAT:                 tmp_42  #
# (str)                (lng)   #
#------------------------------#
[ "buns/car_category",  400012 ] 100.000 string offsets
[ "buns/car_town",      400012 ] idem
[ "buns/car_class",     400012 ] idem
[ "tail/car_category",  266244 ] string tail heap
[ "tail/car_town",      266244 ] idem
[ "tail/car_class",     266244 ] idem
[ "_tot/buns",         1322996 ] the three bun heaps
[ "_tot/tail",          967762 ] the three tail heaps
[ "_tot/head",           70984 ] negligable
[ "_tot/bbp",            98866 ] BBP metadata structure
[ "_tot/mil",           102400 ] MIL interpreter stack space
[ "_tot/found",        2590144 ] buns+head+tail+bbp+mil
[ "_tot/malloc_heap",  2956048 ] in malloc heap
[ "_tot/malloc",       2956048 ] total consumed via malloc
[ "_tot/valloc",        201266 ] total consumed via virtualalloc
[ "_tot/mem",          3157314 ] total RAM+swap-file consumption

>
> v:= status.vmStatistics(1024:lng); io.print(v);
#------------------------------#
# BAT:               tmp_42    #
# (str)              (lng)     #
#------------------------------#
[ "_tot/bbp",        50331648  ] 50MB reserved (100KB claimed)
[ "_tot/mil",        16777216  ] 16MB reserved (100KB claimed)
[ "_tot/found",      67108864  ] bbp+mil
[ "_tot/vm",         71244560  ] total address space consumption
>
@end verbatim
@+ MAL runtime status 
@mal
command batStatistics( ):bat[:str,:str] 
address SYSgdkEnv
comment "Show distribution of bats by kind";
command getThreads( ):bat[:int,:str] 
address SYSgdkThread
comment "Produce overview of active threads";

command mem_cursize() :lng 
address SYSgetmem_cursize
comment "the amount of physical swapspace in KB that is currently in use";

command mem_maxsize() :lng 
address SYSgetmem_maxsize
comment "the maximum usable amount of physical swapspace in KB (target only)";

command mem_maxsize(v:lng) :void 
address set_mem_maxsize
comment "set the maximum usable amount of physical swapspace in KB";

command vm_cursize() :lng 
address SYSgetvm_cursize
comment "the amount of logical VM space in KB that is currently in use";

command vm_maxsize() :lng 
address SYSgetvm_maxsize
comment "the maximum usable amount of logical VM space in KB (target only)";

command vm_maxsize(v:lng) :void 
address SYSsetvm_maxsize
comment "set the maximum usable amount of physical swapspace in KB";

command getDatabases():bat[:str,:str]
address SYSgetDatabases
comment "Produce a list of known databases in the current dbfarm";

command getPorts(lang:str):bat[:str,:int]
address SYSgetPorts
comment "Produce a list of default ports for a specific language";
@+ Implementation Code
@h
#ifndef _SYS_H_
#define _SYS_H_

#ifdef WIN32
#ifndef LIBSTATUS
#define status_export extern __declspec(dllimport)
#else
#define status_export extern __declspec(dllexport)
#endif
#else
#define status_export extern
#endif

status_export str SYSgetDatabases(int *ret);
status_export str SYSgetPorts(int *ret, str *lang);
status_export int set_mem_maxsize(lng *num);

#endif
@-

@include kprelude.mx
@c
#include "mal_config.h"
#include "gdk.h"
#include <stdarg.h>
#include <time.h>
#include "mal_exception.h"
#include "status.h"
#ifdef HAVE_UNISTD_H
#include <unistd.h>
#endif

#ifdef HAVE_SYS_TIMES_H
#include <sys/times.h>
#endif

#ifndef NATIVE_WIN32
# ifndef HZ
#  if !defined(HAVE_SYSCONF) || !defined(_SC_CLK_TCK)
#   define HZ CLK_TCK
#  endif
# endif
#endif

#if defined(_MSC_VER) && _MSC_VER >= 1400
#define access _access
#endif

extern lng GDKcur_cursize(void);
status_export str SYSgetmem_cursize(lng *num);
str
SYSgetmem_cursize(lng *num)
{
	*num = GDKmem_cursize();
	return MAL_SUCCEED;
}

status_export str SYSgetmem_maxsize(lng *num);
str
SYSgetmem_maxsize(lng *num)
{
	*num = GDK_mem_maxsize;
	return MAL_SUCCEED;
}


status_export str SYSgetvm_cursize(lng *num);
str
SYSgetvm_cursize(lng *num)
{
	*num = GDKvm_cursize();
	return MAL_SUCCEED;
}

status_export str SYSgetvm_maxsize(lng *num);
str
SYSgetvm_maxsize(lng *num)
{
	*num = GDK_vm_maxsize;
	return MAL_SUCCEED;
}

status_export str SYSsetvm_maxsize(lng *num);
str
SYSsetvm_maxsize(lng *num)
{
	GDK_vm_maxsize = (size_t) *num;
	return MAL_SUCCEED;
}

/*
str memMap() {
        MT_alloc_print();
        return MAL_SUCCEED;
}
*/
@- Performance
To obtain a good impression of the Monet performance we need timing information.
The most detailed information is best obtained with the system profiler.

However, the direct approach is to enable the user to read the timers maintained
internally. This is done with the CPU, IO, MEMORY, and BBP command which
displays the elapsed time in seconds, user- and system-cpu time in milliseconds
since its last invocation and the amount of space in use.  The process
identifier is used to differentiate among the possible processes.

Note that in multi threaded mode the routine prints the elapsed
time since the beginning of each process.
@c
#ifndef NATIVE_WIN32
static time_t clk = 0;
static struct tms state;
#endif

status_export str SYScpuStatistics(int *ret);
str
SYScpuStatistics(int *ret)
{
#ifndef NATIVE_WIN32
	struct tms newst;
#endif
	int i;
	BAT *b;
#if !defined(NATIVE_WIN32) && !defined(HZ) && defined(HAVE_SYSCONF) && defined(_SC_CLK_TCK)
	static int HZ;

	if (HZ == 0)
			HZ = sysconf(_SC_CLK_TCK);
#endif

	b = BATnew(TYPE_str, TYPE_int, 32);
	if (b == 0)
		throw(MAL, "catalog.gdkCpu", "Failed to create BAT");
#ifndef NATIVE_WIN32
	if (clk == 0) {
		clk = time(0);
		times(&state);
	}
	times(&newst);
	/* store counters, ignore errors */
	i = (int) (time(0) - clk);
	b = BUNins(b, "elapsed", &i, FALSE);
	i = newst.tms_utime * 1000 / HZ;
	b = BUNins(b, "user", &i, FALSE);
	i = (newst.tms_utime - state.tms_utime) * 1000 / HZ;
	b = BUNins(b, "elapuser", &i, FALSE);
	i = newst.tms_stime * 1000 / HZ;
	b = BUNins(b, "system", &i, FALSE);
	i = (newst.tms_stime - state.tms_stime) * 1000 / HZ;
	b = BUNins(b, "elapsystem", &i, FALSE);

	state = newst;
#else
	i = int_nil;
	b = BUNins(b, "elapsed", &i, FALSE);
	b = BUNins(b, "user", &i, FALSE);
	b = BUNins(b, "elapuser", &i, FALSE);
	b = BUNins(b, "system", &i, FALSE);
	b = BUNins(b, "elapsystem", &i, FALSE);
#endif
	if (!(b->batDirty&2)) b = BATsetaccess(b, BAT_READ);
	@:Pseudo(gdk,cpu)@
	return MAL_SUCCEED;
}

@-
Same observations as to SYScpuStatistics()
@c
static char *memincr = NULL;
status_export str SYSmemStatistics(int *ret);
str
SYSmemStatistics(int *ret)
{
	struct mallinfo m;
	BAT *b;
	int i;

	m = MT_mallinfo();

	b = BATnew(TYPE_str, TYPE_int, 32);
	if (b == 0)
		throw(MAL, "catalog.memStatistics", "Failed to create BAT");

	/* store counters, ignore errors */
	if (memincr == NULL) {
		memincr = MT_heapbase;
	}
	i = (MT_heapcur() - memincr);

	memincr = MT_heapcur();
	b = BUNins(b, "memincr", &i, FALSE);
	i = m.arena;
	b = BUNins(b, "arena", &i, FALSE);
	i = m.ordblks;
	b = BUNins(b, "ordblks", &i, FALSE);
	i = m.smblks;
	b = BUNins(b, "smblks", &i, FALSE);
	i = m.hblkhd;
	b = BUNins(b, "hblkhd", &i, FALSE);
	i = m.hblks;
	b = BUNins(b, "hblks", &i, FALSE);
	i = m.usmblks;
	b = BUNins(b, "usmblks", &i, FALSE);
	i = m.fsmblks;
	b = BUNins(b, "fsmblks", &i, FALSE);
	i = m.uordblks;
	b = BUNins(b, "uordblks", &i, FALSE);
	i = m.fordblks;
	b = BUNins(b, "fordblks", &i, FALSE);
	if (!(b->batDirty&2)) b = BATsetaccess(b, BAT_READ);
	@:Pseudo(gdk,mem)@
	return MAL_SUCCEED;
}

@-
To avoid complains about signed/unsigned comparisons between lng & size_t,
we cast  lng *num  to  size_t sze,
after checking that there is no under-/overflow.
@c
@= num2sze
	size_t sze;
	if (*num < 0) {
		GDKerror("set_@1: new size must not be < 0!\n");
		return GDK_FAIL;
	}
#if SIZEOF_SIZE_T == SIZEOF_INT
{
	lng size_t_max = 2 * (lng)INT_MAX;
	if (*num > size_t_max) {
		GDKerror("set_@1: new size must not be > " LLFMT "!\n", size_t_max);
		return GDK_FAIL;
	}
}
#endif
	sze = (size_t)*num;
@c
int
get_mem_bigsize(lng *num)
{
	*num = GDK_mem_bigsize;
	return GDK_SUCCEED;
}

int
set_mem_bigsize(lng *num)
{
	@:num2sze(mem_bigsize)@
	GDK_mem_bigsize = MAX(32768, sze);
	return GDK_SUCCEED;
}

int
get_mem_cursize(lng *num)
{
	*num = GDKmem_cursize();
	return GDK_SUCCEED;
}

int
get_mem_maxsize(lng *num)
{
	*num = GDK_mem_maxsize;
	return GDK_SUCCEED;
}

int
set_mem_maxsize(lng *num)
{
	@:num2sze(mem_maxsize)@
	if (sze < GDK_mem_bigsize)
		set_mem_bigsize(num);
	GDK_mem_maxsize = MAX(GDK_mem_bigsize, sze);
	return GDK_SUCCEED;
}

int
get_vm_cursize(lng *num)
{
	*num = GDKvm_cursize();
	return GDK_SUCCEED;
}

int
get_vm_minsize(lng *num)
{
	*num = GDK_vm_minsize;
	return GDK_SUCCEED;
}

int
set_vm_minsize(lng *num)
{
	@:num2sze(vm_minsize)@
	if (sze < GDK_mem_bigsize)
		set_mem_bigsize(num);
	GDK_vm_minsize = MAX(GDK_mem_bigsize, sze);
	return GDK_SUCCEED;
}

int
get_vm_maxsize(lng *num)
{
	*num = GDK_vm_maxsize;
	return GDK_SUCCEED;
}

int
set_vm_maxsize(lng *num)
{
	@:num2sze(vm_maxsize)@
	if (sze < GDK_vm_minsize)
		set_vm_minsize(num);
	GDK_vm_maxsize = MAX(GDK_vm_minsize, sze);
	return GDK_SUCCEED;
}


@= heap
	if (@2) {
		sz = HEAP@1size(@3);
		if (sz > *minsize) {
			sprintf(buf, "@4/%s", s);
			BUNins(bn, buf, &sz, FALSE);
		}
		@4 += sz; tot += sz;
	}
@c

status_export str SYSmem_usage(int *ret, lng *minsize);
str
SYSmem_usage(int *ret, lng *minsize)
{
	lng hbuns = 0, tbuns = 0, hhsh = 0, thsh = 0, hind = 0, tind = 0, head = 0, tail = 0, tot = 0, n = 0, sz;
	BAT *bn = BATnew(TYPE_str, TYPE_lng, 2 * BBPsize);
	struct mallinfo m;
	char buf[1024];
	bat i;

	if (bn == NULL)
		throw(MAL, "status.memory","Could not create BAT");
	BBPlock("SYSmem_usage");
	for (i = 1; i < BBPsize; i++) {
		BAT *b = BBP_cache(i);
		str s;

		if (!BBPvalid(i))
			continue;

		s = BBPname(i);
		sz = 0;
		if (BBP[i].cache)
			sz += sizeof(BATstore);
		if (BBP[i].nme[0])
			n += strLen(BBP[i].nme[0]);
		if (BBP[i].nme[1])
			n += strLen(BBP[i].nme[1]);
		if (BBP[i].path)
			n += strLen(BBP[i].path);
		if (b)
			sz += sizeof(BAT);	/* mirror */

		if (sz > *minsize) {
			sprintf(buf, "desc/%s", s);
			BUNins(bn, buf, &sz, FALSE);
		}
		tot += (lng) sz;

		if (b == NULL || isVIEW(b)) {
			continue;
		}
		@:heap(mem,1,&b->H->heap,hbuns)@
		@:heap(mem,1,&b->T->heap,tbuns)@
		@:heap(mem,b->H->hash,b->H->hash->heap,hhsh)@
		@:heap(mem,b->T->hash,b->T->hash->heap,thsh)@
		@:heap(mem,b->H->vheap,b->H->vheap,head)@
		@:heap(mem,b->T->vheap,b->T->vheap,tail)@
	}
	/* totals per category */
	BUNins(bn, "_tot/hbuns", &hbuns, FALSE);
	BUNins(bn, "_tot/tbuns", &tbuns, FALSE);
	BUNins(bn, "_tot/head", &head, FALSE);
	BUNins(bn, "_tot/tail", &tail, FALSE);
	BUNins(bn, "_tot/hhsh", &hhsh, FALSE);
	BUNins(bn, "_tot/thsh", &thsh, FALSE);
	BUNins(bn, "_tot/hind", &hind, FALSE);
	BUNins(bn, "_tot/tind", &tind, FALSE);

	/* special area 1: BBP rec */
	sz = BBPlimit * sizeof(BBPrec) + n;
	BUNins(bn, "_tot/bbp", &sz, FALSE);
	tot += sz;

	/* this concludes all major traceable Monet memory usages */
	tot += sz;
	BUNins(bn, "_tot/found", &tot, FALSE);

	/* now look at what the global statistics report (to see if it coincides)
	 */

	/* how much *used* bytes in heap? */
	m = MT_mallinfo();
	sz = (size_t) (m.usmblks + m.uordblks + m.hblkhd);
	BUNins(bn, "_tot/malloc", &tot, FALSE);

	/* measure actual heap size, includes wasted fragmented space and anon mmap space used by malloc() */
	sz = GDKvm_heapsize();
	BUNins(bn, "_tot/heap", &sz, FALSE);

	tot = GDKmem_cursize();

	/* allocated swap area memory that is not plain malloc() */
	sz = MAX(0, sz - tot);
	BUNins(bn, "_tot/valloc", &sz, FALSE);

	/* swap-area memory is in either GDKvmalloc or heap */
	BUNins(bn, "_tot/swapmem", &tot, FALSE);

	BBPunlock("SYSmem_usage");
	if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ);
	*ret = bn->batCacheid;
	return MAL_SUCCEED;
}


status_export str SYSvm_usage(int *ret, lng *minsize);
str
SYSvm_usage(int *ret, lng *minsize)
{
	lng hbuns = 0, tbuns = 0, hhsh = 0, thsh = 0, hind = 0, tind = 0, head = 0, tail = 0, tot = 0, sz;
	BAT *bn = BATnew(TYPE_str, TYPE_lng, 2 * BBPsize);
	char buf[1024];
	bat i;

	if (bn == NULL)
		throw(MAL, "status.usage","Could not create BAT");
	BBPlock("SYSvm_usage");
	for (i = 1; i < BBPsize; i++) {
		BAT *b;
		str s;

		if (!BBPvalid(i))
			continue;

		s = BBPname(i);
 		b = BBP_cache(i);
		if (b == NULL || isVIEW(b)) {
			continue;
		}
		@:heap(vm,1,&b->H->heap,hbuns)@
		@:heap(vm,1,&b->T->heap,tbuns)@
		@:heap(vm,b->H->hash,b->H->hash->heap,hhsh)@
		@:heap(vm,b->T->hash,b->T->hash->heap,thsh)@
		@:heap(vm,b->H->vheap,b->H->vheap,head)@
		@:heap(vm,b->T->vheap,b->T->vheap,tail)@
	}
	/* totals per category */
	BUNins(bn, "_tot/hbuns", &hbuns, FALSE);
	BUNins(bn, "_tot/tbuns", &tbuns, FALSE);
	BUNins(bn, "_tot/head", &head, FALSE);
	BUNins(bn, "_tot/tail", &tail, FALSE);
	BUNins(bn, "_tot/hhsh", &hhsh, FALSE);
	BUNins(bn, "_tot/thsh", &thsh, FALSE);
	BUNins(bn, "_tot/hind", &hind, FALSE);
	BUNins(bn, "_tot/tind", &tind, FALSE);

	/* special area 1: BBP rec */
	sz = BBPmaxsize * sizeof(BBPrec);
	BUNins(bn, "_tot/bbp", &sz, FALSE);
	tot += sz;


	/* this concludes all major traceable Monet virtual memory usages */
	tot += sz;
	BUNins(bn, "_tot/found", &tot, FALSE);

	/* all VM is either GDKmmap or GDKvmalloc (possibly redirected GDKmalloc), *plus* the heap */
	sz = GDKvm_cursize();
	BUNins(bn, "_tot/vm", &sz, FALSE);

	BBPunlock("SYSvm_usage");
	if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ);
	*ret = bn->batCacheid;
	return MAL_SUCCEED;
}

@-
Additional information on the process utilization is given by
the io command. The following information is obtained.

@T
\begin{tabular}{| l| l|}\hline
maxrss     &the maximum resident set size utilized (in kilobytes).\\
minflt     &the number of page faults serviced without any I/O\\
	 &activity; here I/O activity is avoided by "reclaiming" a\\

	 &activity; here I/O activity is avoided by "reclaiming" a\\
	 &page frame from the list of pages awaiting reallocation.\\
majflt     &the number of page faults serviced that required I/O\\
	 &activity.\\
nswap      &the number of times a process was "swapped" out of main\\
	 &memory\\
inblock    &the number of times the file system had to perform input.\\
oublock    &the number of times the file system had to perform output.\\
nvcsw      &the number of times a context switch resulted due to a\\
	 &process voluntarily giving up the processor before its\\
	 &time slice was completed (usually to await availability of\\
	 &a resource).\\
nivcsw     &the number of times a context switch resulted due to a\\
	 &higher priority process becoming runnable or because the\\
	 &current process exceeded its time slice.\\
\end{tabular}
@
The resource statistics are collected in a BAT. It can then
be queried. A default listing is produced by the command @%usagecmd@.
(which should be moved to Monet)

The BAT grows. It should be compacted.
@c
#ifdef HAVE_SYS_RESOURCE_H
# include <sys/resource.h>
#endif

status_export str SYSioStatistics(int *ret);
str
SYSioStatistics(int *ret)
{
#ifndef NATIVE_WIN32
	struct rusage ru;
#endif
	int i;
	BAT *b;

#ifndef NATIVE_WIN32
	getrusage(RUSAGE_SELF, &ru);
#endif
	b = BATnew(TYPE_str, TYPE_int, 32);
	if (b == 0)
		throw(MAL, "catalog.ioStatistics", "Failed to create BAT");

#ifndef NATIVE_WIN32
	/* store counters, ignore errors */
	i = ru.ru_maxrss;
	BUNins(b, "maxrss", &i, FALSE);
	i = ru.ru_minflt;
	BUNins(b, "minflt", &i, FALSE);
	i = ru.ru_majflt;
	BUNins(b, "majflt", &i, FALSE);
	i = ru.ru_nswap;
	BUNins(b, "nswap", &i, FALSE);
	i = ru.ru_inblock;
	BUNins(b, "inblock", &i, FALSE);
	i = ru.ru_oublock;
	BUNins(b, "oublock", &i, FALSE);
	i = ru.ru_nvcsw;
	BUNins(b, "nvcsw", &i, FALSE);
	i = ru.ru_nivcsw;
	BUNins(b, "ninvcsw", &i, FALSE);
#else
	i = int_nil;
	BUNins(b, "maxrss", &i, FALSE);
	BUNins(b, "minflt", &i, FALSE);
	BUNins(b, "majflt", &i, FALSE);
	BUNins(b, "nswap", &i, FALSE);
	BUNins(b, "inblock", &i, FALSE);
	BUNins(b, "oublock", &i, FALSE);
	BUNins(b, "nvcsw", &i, FALSE);
	BUNins(b, "ninvcsw", &i, FALSE);
#endif

	if (!(b->batDirty&2)) b = BATsetaccess(b, BAT_READ);
	@:Pseudo(gdk,io)@
	return MAL_SUCCEED;
}

status_export str SYSgdkEnv(int *ret);
str
SYSgdkEnv(int *ret)
{
	int pbat = 0;
	int pdisk = 0;
	int pheat = 0;
	bat i;
	int tmp = 0, per = 0;
	BAT *b;

	b = BATnew(TYPE_str, TYPE_int, 32);
	if (b == 0)
		throw(MAL, "status.gdkEnv","Could not create BAT");

	for (i = 1; i < BBPsize; i++) {
		if (BBPvalid(i)) {
			pbat++;
			if (BBP_cache(i)) {
				pheat += BBP_lastused(i);
				if (BBP_cache(i)->batPersistence == PERSISTENT)
					per++;
				else
					tmp++;
			} else {
				pdisk++;
			}
		}
	}
	b = BUNins(b, "bats", &pbat, FALSE);
	b = BUNins(b, "tmpbats", &tmp, FALSE);
	b = BUNins(b, "perbats", &per, FALSE);
	b = BUNins(b, "ondisk", &pdisk, FALSE);
	b = BUNins(b, "todisk", &BBPout, FALSE);
	b = BUNins(b, "fromdisk", &BBPin, FALSE);
	if (!(b->batDirty&2)) b = BATsetaccess(b, BAT_READ);
	@:Pseudo(gdk,env)@
	return MAL_SUCCEED;
}

status_export str SYSgdkThread(int *ret);
str
SYSgdkThread(int *ret)
{
	BAT *b;
	int i;

	b = BATnew(TYPE_int, TYPE_str, THREADS);
	if (b == 0)
		throw(MAL, "catalog.gdkThread", "Failed to create BAT");

	for (i = 0; i < THREADS; i++)
		if (GDKthreads[i].pid) {
			BUNins(b, &GDKthreads[i].tid, GDKthreads[i].name, FALSE);
		}
	if (!(b->batDirty&2)) b = BATsetaccess(b, BAT_READ);
	@:Pseudo(gdk,thread)@
	return MAL_SUCCEED;
}
@-
Collect the database and their access permissions for inspection.
Note, this code base should be changed for the Windows setting.
@c
#ifndef F_OK
#define F_OK 0
#endif
str SYSgetDatabases(int *ret)
{
	BAT *b;
	DIR *d, *db;
	struct dirent *e;
	char buf[PATHLENGTH];
	FILE *f;
	int uid,pid;
	
	b = BATnew(TYPE_str, TYPE_str, 50);
	/* scan the parent for directories */
	d= opendir("..");
	while ( (e=readdir(d)) != NULL){
		if( *e->d_name == '.') continue;
		snprintf(buf,PATHLENGTH,"..%c%s",DIR_SEP,e->d_name);
		db= opendir(buf);
		if( db != NULL) {
			snprintf(buf,PATHLENGTH,"..%c%s%c.gdk_lock",DIR_SEP,e->d_name,DIR_SEP);
			f= fopen(buf,"r");
			if( f  && fgets(buf,PATHLENGTH,f) != NULL){
				sscanf(buf,"USR=%d PID=%d %s", &uid,&pid,buf);
				/* w00t! for platform independence! (NOT!) */
				snprintf(buf,PATHLENGTH,"/proc/%d",pid);
				fclose(f);
			} else
				snprintf(buf,PATHLENGTH,"..%c%s%c.mguardian.pid",DIR_SEP,e->d_name,DIR_SEP);
			/* not water-proof, PID can exist, and be alive, but not an
			   mserver, need to check process name */
			BUNins(b,e->d_name,(access(buf,F_OK)?"sleeping":"running"), FALSE);
			closedir(db);
		} 
	}
	(void) closedir(d);
	if (!(b->batDirty&2)) b = BATsetaccess(b, BAT_READ);
	@:Pseudo(databases,mode)@
	return MAL_SUCCEED;
}

str SYSgetPorts(int *ret, str *lang)
{
	BAT *b;
	DIR *d, *db;
	struct dirent *e;
	char buf[PATHLENGTH];
	FILE *f;
	int port;
	str llang;
	
	/* if lang is NULL, default to "mal" */
	llang = (lang == NULL ? "mal" : *lang);
	b = BATnew(TYPE_str, TYPE_int, 50);
	/* scan the parent for directories */
	d= opendir("..");
	while ( (e=readdir(d)) != NULL){
		if( *e->d_name == '.') continue;
		snprintf(buf,PATHLENGTH,"..%c%s",DIR_SEP,e->d_name);
		db= opendir(buf);
		if( db != NULL) {
			snprintf(buf,PATHLENGTH,"..%c%s%c.%s.port",DIR_SEP,e->d_name,DIR_SEP,llang);
			f= fopen(buf,"r");
			if( f  && fgets(buf,PATHLENGTH,f) != NULL){
				port= (int) strtol(buf,NULL,10);
				fclose(f);
			} else port = 0;
			BUNins(b, e->d_name, (ptr)(port==0? &int_nil: &port), FALSE);
			closedir(db);
		} 
	}
	(void) closedir(d);
	if (!(b->batDirty&2)) b = BATsetaccess(b, BAT_READ);
	@:Pseudo(databases,port)@
	return MAL_SUCCEED;
}
@}
