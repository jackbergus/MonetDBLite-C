@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2006 CWI.
@' All Rights Reserved.
@a stefan manegold
@+
The microbenchmark routines are primarilly used to create a
simple database for testing the performance of core routines.
It was originally developed in the context of the Radix Cluster
activities.

@f microbenchmark
@mal
module microbenchmark;

command uniform(base:oid, size:int, domain:int):bat[:oid,:int]
address MBMuniform
comment "Create a BAT with uniform integer distribution";

command normal(base:oid, size:int, domain:int, stddev:int, mean:int):bat[:oid,:int]
address MBMnormal
comment "Create a BAT with a normal integer distribution";
@+ Experimentation Gimmicks
@- Data Generation
@h
#ifdef _MBM_H_
#include <mal.h>

mal_export str MBMuniform(int *ret, oid *base, int *size, int *domain);
mal_export str MBMnormal(int *ret, oid *base, int *size, int *domain, int *stddev, int *mean);

#endif /* _MBM_H_ */
@c
#include <mal.h>
#include <math.h>
#include <mal_exception.h>

int
BATuniform(BAT **bn, oid *base, int *size, int *domain)
{
	size_t n = (size_t) * size, i, r;
	BAT *b = NULL;
	char *firstbun;
	int bunsize;		/* initialized in BATloopFast */
	oid bs = *base;
	int j = 0;
	BUN p, q;

	if (*size < 0) {
		GDKerror("BATuniform: size must not be negative");
		return GDK_FAIL;
	}

	b = BATnew(TYPE_oid, TYPE_int, n);
	if (b == NULL)
		return GDK_FAIL;
	if (n == 0) {
		b->tsorted = GDK_SORTED;
		b->hsorted = GDK_SORTED;
		b->hdense = TRUE;
		BATseqbase(b, *base);
		BATkey(b, TRUE);
		BATkey(BATmirror(b), TRUE);
		*bn = b;
		return GDK_SUCCEED;
	}

	firstbun = (char *) BUNfirst(b);
	/* preset b->batBuns->free to make BATloopFast work */
	b->batBuns->free = n * BUNsize(b);
	BATsetcount(b, n);
	/* create BUNs with uniform distribution */
	BATloopFast(b, p, q, bunsize) {
		*(oid *) BUNhloc(b, p) = bs ++;

		*(int *) BUNtloc(b, p) = j;
		if (++j >= *domain)
			j = 0;
	}
	/* mix BUNs randomly */
	for (r = i = 0; i < n; i++) {
		size_t idx = i + ((r += rand()) % (n - i));
		int val;

		p = (BUN) (firstbun + i * bunsize);	/* fast version of BUNptr */
		q = (BUN) (firstbun + idx * bunsize);
		val = *(int *) BUNtloc(b, p);
		*(int *) BUNtloc(b, p) = *(int *) BUNtloc(b, q);
		*(int *) BUNtloc(b, q) = val;
	}
	b->tsorted = FALSE;
	b->hdense = TRUE;
	BATseqbase(b, *base);
	BATkey(b, TRUE);
	*bn = b;
	return GDK_SUCCEED;
}


int
BATnormal(BAT **bn, oid *base, int *size, int *domain, int *stddev, int *mean)
{
	size_t n = (size_t) * size, i;
	unsigned int r = (unsigned int) n;
	size_t d = (size_t) * domain;
	BAT *b = NULL;
	char *firstbun;
	int bunsize;
	BUN p, q;
	int m = *mean, s = *stddev;
	oid bs = *base;
	int *itab;
	flt *ftab, tot = 0.0;

	if (*size < 0) {
		GDKerror("BATnormal: size must not be negative");
		return GDK_FAIL;
	}

        b = BATnew(TYPE_oid, TYPE_int, n);
	if (b == NULL)
		return GDK_FAIL;
	if (n == 0) {
		b->tsorted = GDK_SORTED;
		b->hsorted = GDK_SORTED;
		b->hdense = TRUE;
		BATseqbase(b, *base);
		BATkey(b, TRUE);
		BATkey(BATmirror(b), TRUE);
		*bn = b;
		return GDK_SUCCEED;
	}

	firstbun = (char *) BUNfirst(b);
	itab = (int *) GDKmalloc(d * sizeof(int));
	ftab = (flt *) itab;

	/* assert(0 <= *mean && *mean < *size); */

	/* created inverted table */
	for (i = 0; i < d; i++) {
		dbl tmp = (dbl) ((i - m) * (i - m));

		tmp = pow(M_E, -tmp / (2 * s * s)) / sqrt(2 * M_PI * s * s);
		ftab[i] = (flt) tmp;
		tot += ftab[i];
	}
	for (tot = (flt) (1.0 / tot), i = 0; i < d; i++) {
		itab[i] = (int) ((flt) n * ftab[i] * tot);
		r -= itab[i];
	}
	itab[m] += r;

	/* preset b->batBuns->free to make BATloopFast work */
	b->batBuns->free = n * BUNsize(b);
	BATsetcount(b, n);
	/* create BUNs with normal distribution */
	BATloopFast(b, p, q, bunsize) {
		*(oid *) BUNhloc(b, p) = bs ++;

		while (itab[r] == 0)
			r++;
		itab[r]--;
		*(int *) BUNtloc(b, p) = (int) r;
	}
	GDKfree(itab);

	/* mix BUNs randomly */
	for (r = 0, i = 0; i < n; i++) {
		size_t idx = i + ((r += rand()) % (n - i));
		int val;

		p = (BUN) (firstbun + i * bunsize);	/* fast version of BUNptr */
		q = (BUN) (firstbun + idx * bunsize);
		val = *(int *) BUNtloc(b, p);
		*(int *) BUNtloc(b, p) = *(int *) BUNtloc(b, q);
		*(int *) BUNtloc(b, q) = val;
	}
	b->tsorted = FALSE;
	b->hdense = TRUE;
	BATseqbase(b, *base);
	BATkey(b, TRUE);
	*bn = b;
	return GDK_SUCCEED;
}
@-
The M5 wrapper code
@c

str
MBMuniform(int *ret, oid *base, int *size, int *domain){
	BAT *bn;
	
	BATuniform(&bn, base, size, domain);
	if( bn ){
		if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ);
		BBPkeepref(*ret= bn->batCacheid);
	} else throwMessage("microbenchmark","uniform");
	return MAL_SUCCEED;
}

str
MBMnormal(int *ret, oid *base, int *size, int *domain, int *stddev, int *mean){
	BAT *bn;
	BATnormal(&bn, base, size, domain, stddev, mean);
	if( bn ){
		if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ);
		BBPkeepref(*ret= bn->batCacheid);
	} else throwMessage("microbenchmark","uniform");
	return MAL_SUCCEED;
}
