@mal
module microbenchmark;
command uniform(base:oid,size:int,domain:int):bat[:oid,:int]
address MBuniform
comment "tobe filled";

@+ Experimentation Gimmicks
@- Data Generation
@c

int
BATuniform(BAT **bn, oid *base, int *size, int *domain)
{
	size_t n = (size_t) * size, i, r;
	BAT *b = NULL;
	char *firstbun;
	int bunsize;		/* initialized in BATloopFast */
	oid bs = *base;
	int j = 0;
	BUN p, q;

	if (*size < 0) {
		GDKerror("BATuniform: size must not be negative");
		return GDK_FAIL;
	}

	b = BATnew(TYPE_oid, TYPE_int, n);
	if (b == NULL)
		return GDK_FAIL;
	if (n == 0) {
		b->tsorted = GDK_SORTED;
		b->hsorted = GDK_SORTED;
		b->hdense = TRUE;
		BATseqbase(b, *base);
		BATkey(b, TRUE);
		BATkey(BATmirror(b), TRUE);
		*bn = b;
		return GDK_SUCCEED;
	}

	firstbun = (char *) BUNfirst(b);
	/* preset b->batBuns->free to make BATloopFast work */
	b->batBuns->free = n * BUNsize(b);
	BATsetcount(b, n);
	/* create BUNs with uniform distribution */
	BATloopFast(b, p, q, bunsize) {
		*(oid *) BUNhloc(b, p) = bs ++;

		*(int *) BUNtloc(b, p) = j;
		if (++j >= *domain)
			j = 0;
	}
	/* mix BUNs randomly */
	for (r = i = 0; i < n; i++) {
		size_t idx = i + ((r += rand()) % (n - i));
		int val;

		p = (BUN) (firstbun + i * bunsize);	/* fast version of BUNptr */
		q = (BUN) (firstbun + idx * bunsize);
		val = *(int *) BUNtloc(b, p);
		*(int *) BUNtloc(b, p) = *(int *) BUNtloc(b, q);
		*(int *) BUNtloc(b, q) = val;
	}
	b->tsorted = FALSE;
	b->hdense = TRUE;
	BATseqbase(b, *base);
	BATkey(b, TRUE);
	*bn = b;
	return GDK_SUCCEED;
}


int
BATnormal(BAT **bn, oid *base, int *size, int *domain, int *stddev, int *mean)
{
	size_t n = (size_t) * size, i;
	unsigned int r = (unsigned int) n;
	size_t d = (size_t) * domain;
	BAT *b = NULL;
	char *firstbun;
	int bunsize;
	BUN p, q;
	int m = *mean, s = *stddev;
	oid bs = *base;
	int *itab;
	flt *ftab, tot = 0.0;

	if (*size < 0) {
		GDKerror("BATnormal: size must not be negative");
		return GDK_FAIL;
	}

        b = BATnew(TYPE_oid, TYPE_int, n);
	if (b == NULL)
		return GDK_FAIL;
	if (n == 0) {
		b->tsorted = GDK_SORTED;
		b->hsorted = GDK_SORTED;
		b->hdense = TRUE;
		BATseqbase(b, *base);
		BATkey(b, TRUE);
		BATkey(BATmirror(b), TRUE);
		*bn = b;
		return GDK_SUCCEED;
	}

	firstbun = (char *) BUNfirst(b);
	itab = (int *) GDKmalloc(d * sizeof(int));
	ftab = (flt *) itab;

	/* assert(0 <= *mean && *mean < *size); */

	/* created inverted table */
	for (i = 0; i < d; i++) {
		dbl tmp = (dbl) ((i - m) * (i - m));

		tmp = pow(M_E, -tmp / (2 * s * s)) / sqrt(2 * M_PI * s * s);
		ftab[i] = (flt) tmp;
		tot += ftab[i];
	}
	for (tot = (flt) (1.0 / tot), i = 0; i < d; i++) {
		itab[i] = (int) ((flt) n * ftab[i] * tot);
		r -= itab[i];
	}
	itab[m] += r;

	/* preset b->batBuns->free to make BATloopFast work */
	b->batBuns->free = n * BUNsize(b);
	BATsetcount(b, n);
	/* create BUNs with normal distribution */
	BATloopFast(b, p, q, bunsize) {
		*(oid *) BUNhloc(b, p) = bs ++;

		while (itab[r] == 0)
			r++;
		itab[r]--;
		*(int *) BUNtloc(b, p) = (int) r;
	}
	GDKfree(itab);

	/* mix BUNs randomly */
	for (r = 0, i = 0; i < n; i++) {
		size_t idx = i + ((r += rand()) % (n - i));
		int val;

		p = (BUN) (firstbun + i * bunsize);	/* fast version of BUNptr */
		q = (BUN) (firstbun + idx * bunsize);
		val = *(int *) BUNtloc(b, p);
		*(int *) BUNtloc(b, p) = *(int *) BUNtloc(b, q);
		*(int *) BUNtloc(b, q) = val;
	}
	b->tsorted = FALSE;
	b->hdense = TRUE;
	BATseqbase(b, *base);
	BATkey(b, TRUE);
	*bn = b;
	return GDK_SUCCEED;
}

str
MBuniform(int *ret, oid *base, int *size, int *domain){
	BAT *bn;
	
	BATuniform(&bn, base, size, domain)
	if( bn )
		*ret= bn->batCacheid;
	else throwMessage("microbenchmark","uniform");
	return MAL_SUCCEED;
}
