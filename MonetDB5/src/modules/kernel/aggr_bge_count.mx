@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
@' Copyright August 2008-2009 MonetDB B.V.
@' All Rights Reserved.

@f aggr_bge_count
@a S. Manegold 
@v 1.0
@+ Aggregates Module

@{

@+ Implementation
These implementations need just one scan and a simple hash-maintained data
structure to compute a group of common aggregates.
@c
#include "mal_config.h"
#include <gdk.h>
#include <gdk_scanselect.h>	/* for type-specific HT_bunfastins_nocheck_noinc(), until they're moved to gdk.mx */
#include "aggr.h"
#include "aggr_be_count.h"

@- Result initialization
/*	init_result
	@1:	tail-type:	bte/sht/int/wrd/lng/flt/dbl / any / void
*/
@include aggr_ri.mx

@- Count
@c
/*	aggrX3_count3
		e-void-head	e-oid-head	e-oid-head	e-oid-head
		void-lookup	array-lookup	scan-lookup	hash-lookup

	@1:	0		1		0		0		use cnt-array?
	@2:	0		0		0		1		do BATprepareHash?
	@3:	BUNfndVOID	CHKrange	SCANfndOID	HASHfnd_oid	lookup
	@4:	var		loc		loc		loc		e/bn-head-access

	@5:	"BUNhloc(b,p)" for  (oid) b-head-type,		b-head access
		"&bhsb; bhsb++" for (void) b-head-type

	@6:	BUNtloc(bn,r)	BUNtloc(bn,r)	&cnt[(*(oid*)h)-min]
								*dst: count in-place or in cnt-array ?
*/
@= aggrX3_count3
	ALGODEBUG THRprintf(GDKout, "#aggrX3_count3(@1,@2,@3,@4,@5,@6);\n");
	if (@1 && range > 0) {
		/* create tmp. cnt array */
		cnt = (wrd*) GDKzalloc(range*sizeof(wrd));
		if (cnt == NULL) {
			GDKerror("aggrX3_count3(@1,@2,@3,@4,@5,@6,@6): cnt = GDKzalloc("OIDFMT"*"SZFMT") failed", range, sizeof(wrd));
			BBPreclaim(bn);
			return GDK_FAIL;
		}
	}
	if (@2 && BATprepareHash(bn)) {
		GDKerror("aggrX3_count3(@1,@2,@3,@4,@5,@6,@6): BATprepareHash(bn) failed");
		if (@1 && cnt)
			GDKfree(cnt);
		BBPreclaim(bn);
		return GDK_FAIL;
	}
	/* scan b & g, and increment counts in-place or in cnt-array */
	base = BUNfirst(g);
	offset = (ssize_t) base - (ssize_t) g->hseqbase;
	end = base + BATcount(g);
	bhsb = b->hseqbase;
	btt = b->ttype;
	if (*ignore_nils && !b->T->nonil) {
		switch(ATOMstorage(btt)) {
		case TYPE_chr:
			@:aggrX3_count3_loop(@1,@2,@3,@4,@5,@6,if (!simple_EQ(BUNtloc(bi,p),bt_nil,chr)))@
		case TYPE_bte:
			@:aggrX3_count3_loop(@1,@2,@3,@4,@5,@6,if (!simple_EQ(BUNtloc(bi,p),bt_nil,bte)))@
		case TYPE_sht:
			@:aggrX3_count3_loop(@1,@2,@3,@4,@5,@6,if (!simple_EQ(BUNtloc(bi,p),bt_nil,sht)))@
		case TYPE_int:
			@:aggrX3_count3_loop(@1,@2,@3,@4,@5,@6,if (!simple_EQ(BUNtloc(bi,p),bt_nil,int)))@
		case TYPE_lng:
			@:aggrX3_count3_loop(@1,@2,@3,@4,@5,@6,if (!simple_EQ(BUNtloc(bi,p),bt_nil,lng)))@
		case TYPE_flt:
			@:aggrX3_count3_loop(@1,@2,@3,@4,@5,@6,if (!simple_EQ(BUNtloc(bi,p),bt_nil,flt)))@
		case TYPE_dbl:
			@:aggrX3_count3_loop(@1,@2,@3,@4,@5,@6,if (!simple_EQ(BUNtloc(bi,p),bt_nil,dbl)))@
		default:
			if (b->tvarsized) {
				@:aggrX3_count3_loop(@1,@2,@3,@4,@5,@6,if (!atom_EQ(BUNtvar(bi,p),bt_nil,btt)))@
			} else {
				@:aggrX3_count3_loop(@1,@2,@3,@4,@5,@6,if (!atom_EQ(BUNtloc(bi,p),bt_nil,btt)))@
			}
		}
	} else {
		switch(ATOMstorage(btt)) {
		case TYPE_chr:
			@:aggrX3_count3_loop(@1,@2,@3,@4,@5,@6,)@
		case TYPE_bte:
			@:aggrX3_count3_loop(@1,@2,@3,@4,@5,@6,)@
		case TYPE_sht:
			@:aggrX3_count3_loop(@1,@2,@3,@4,@5,@6,)@
		case TYPE_int:
			@:aggrX3_count3_loop(@1,@2,@3,@4,@5,@6,)@
		case TYPE_lng:
			@:aggrX3_count3_loop(@1,@2,@3,@4,@5,@6,)@
		case TYPE_flt:
			@:aggrX3_count3_loop(@1,@2,@3,@4,@5,@6,)@
		case TYPE_dbl:
			@:aggrX3_count3_loop(@1,@2,@3,@4,@5,@6,)@
		default:
			if (b->tvarsized) {
				@:aggrX3_count3_loop(@1,@2,@3,@4,@5,@6,)@
			} else {
				@:aggrX3_count3_loop(@1,@2,@3,@4,@5,@6,)@
			}
		}
	}
	if (@1 && cnt) {
		/* copy cnt array to final result */
		BATloop(bn, p, q) {
			oid h = (*(oid*) BUNh@4(bni,p)) - min;
			*(wrd*)BUNtloc(bni, p) = cnt[h];
		}
		GDKfree(cnt);
	}
@c
/*	aggrX3_count3_loop
	@7:	if (!atom_EQ(BUNt{loc,var}(b,p),bt_nil,btt))		b-tail nil check
		if (!simple_EQ(BUNtloc(b,p),bt_nil,{chr,bte,sht,int,flt,lng,dbl}))
*/
@= aggrX3_count3_loop
	ALGODEBUG THRprintf(GDKout, "#aggrX3_count3_loop(@1,@2,@3,@4,@5,@6,@7);\n");
	BATloop(b, p, q) {
		oid v = *(oid*) @5;

		w = (BUN) (offset + v);
		if (w >= base && w < end) {
			oid *h = (oid*) BUNtail(gi, w);

			@3(r, bni, (oid*)h);
			if (r != BUN_NONE) {
				@7 {
					wrd *dst = (wrd*) @6;
					(*dst)++;
				}
			}
		}
	}
	break;
@h
int
CMDaggrX3_count3(BAT **ret, BAT *b, BAT *g, BAT *e, bit *ignore_nils);
@c
int
CMDaggrX3_count3(BAT **ret, BAT *b, BAT *g, BAT *e, bit *ignore_nils)
{
	BATiter bni, bi = bat_iterator(b), gi = bat_iterator(g);
	BAT *bn;
	wrd zero = 0, *cnt = NULL;
	BUN p, q, r;
	oid range = 0;
	oid min = 0, max = 0;
	oid bhsb;
	BUN base, end, w;
	ssize_t offset;
	int btt;
	ptr bt_nil = ATOMnilptr(b->ttype);

	ALGODEBUG THRprintf(GDKout, "#CMDaggrX3_count3(b=%s,g=%s,e=%s);\n", 
		BATgetId(b),BATgetId(g),BATgetId(e));

/*	ERRORcheck((BATcount(b)!=BATcount(g)), "CMDaggrX3_count3: BATs b & g must be of equal size.\n");	*/
	ERRORcheck((g->htype == TYPE_void) && (g->hseqbase == oid_nil) && (BATcount(g) > 0), "CMDaggrX3_count3: head of BAT g must not be nil.\n");

	if ((g->hseqbase == oid_nil) || (!BAThdense(g)) || (!(BAThordered(b) & 1)) || (!g->hkey)) {
		BAT *gb = BATjoin(BATmirror(g), b, BUN_NONE);
		int rtrn = CMDaggrX3_count(ret, gb, e, ignore_nils);
		BBPunfix(gb->batCacheid);
		return rtrn;
	}

	if (e->htype == TYPE_void && 
	    b->htype == TYPE_void && 
	    g->htype == TYPE_void && 
	    g->ttype == TYPE_void &&
	    BATcount(b) == BATcount(e) &&
	    (!ignore_nils || b->T->nonil)) {
		/* simply return counts with one */
		wrd one = 1;
		bn = BATconst(b, TYPE_wrd, &one);
		*ret = bn;
		return GDK_SUCCEED;
	}
 	bn = BATnew(e->htype, TYPE_wrd, BATcount(e));
	bni = bat_iterator(bn);
	if( bn == NULL) {
		GDKerror("CMDaggrX3_count3(): BATnew() failed");
		return GDK_FAIL;
	}

	/* init: set all counts to zero and calculate min/max oid */
	@:init_result(wrd)@
	bn->T->nonil = 1;
	range = max - min + 1;

	/* scan b & g, and calculate counts */
	if (e->htype == TYPE_void) {
		/* void lookup */
		if (b->htype == TYPE_void) {
			@:aggrX3_count3(0,0,BUNfndVOID,var,&bhsb;bhsb++,BUNtloc(bni,r))@
		} else {
			@:aggrX3_count3(0,0,BUNfndVOID,var,BUNhloc(bi,p),BUNtloc(bni,r))@
		}
		/* e->htype == TYPE_oid */
	} else if (range <= SMALL_AGGR_MAX) {
		/* array lookup */
		if (b->htype == TYPE_void) {
			@:aggrX3_count3(1,0,CHKrange,loc,&bhsb;bhsb++,&cnt[(*(oid*)h)-min])@
		} else {
			@:aggrX3_count3(1,0,CHKrange,loc,BUNhloc(bi,p),&cnt[(*(oid*)h)-min])@
		}
	} else if (BATcount(e) <= SCAN_AGGR_MAX) {
		/* scan lookup */
		SCAN_aggr_init;
		if (b->htype == TYPE_void) {
			@:aggrX3_count3(0,0,SCANfndOID,loc,&bhsb;bhsb++,BUNtloc(bni,r))@
		} else {
			@:aggrX3_count3(0,0,SCANfndOID,loc,BUNhloc(bi,p),BUNtloc(bni,r))@
		}
	} else {
		/* hash lookup */
		if (b->htype == TYPE_void) {
			@:aggrX3_count3(0,1,HASHfnd_oid,loc,&bhsb;bhsb++,BUNtloc(bni,r))@
		} else {
			@:aggrX3_count3(0,1,HASHfnd_oid,loc,BUNhloc(bi,p),BUNtloc(bni,r))@
		}
	}

	*ret = bn;
	return GDK_SUCCEED;
}

@}
