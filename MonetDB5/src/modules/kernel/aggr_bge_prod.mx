@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
@' Copyright August 2008-2010 MonetDB B.V.
@' All Rights Reserved.

@f aggr_bge_prod
@a S. Manegold 
@v 1.0
@+ Aggregates Module

@{

@+ Implementation
These implementations need just one scan and a simple hash-maintained data
structure to compute a group of common aggregates.
@c
#include "mal_config.h"
#include <gdk.h>
#include <gdk_scanselect.h>	/* for type-specific HT_bunfastins_nocheck_noinc(), until they're moved to gdk.mx */
#include "aggr.h"
#include "aggr_be_prod.h"

@- Result initialization
/*	init_result
	@1:	tail-type:	bte/sht/int/wrd/lng/flt/dbl / any / void
*/
@include aggr_ri.mx

@- Product
@c
/*	aggrX3_prod3
		e-void-head	e-oid-head	e-oid-head	e-oid-head
		void-lookup	array-lookup	scan-lookup	hash-lookup

	@1:	0		1		0		0		use prods-array?
	@2:	0		0		0		1		do BATprepareHash?
	@3:	BUNfndVOID	CHKrange	SCANfndOID	HASHfnd_oid	lookup
	@4:	var		loc		loc		loc		e/bn-head-access

	@5:	"BUNhloc(b,p)"	for  (oid) b-head-type,		b-head access
		"&bhsb; bhsb++" for (void) b-head-type

	@6:	bte / sht / int / wrd / lng / flt / dbl		b/bn-tail-type

#	not used any more as the result-type needs an argument
#	@7:	"loc" for fixsized b/bn-tail-type,		b/bn-tail-access
#		"var" for varsized b/bn-tail-type		(only loc used currently)

	@7:	BUNt@7(bn,r)	BUNt@7(bn,r)	&prods[(*(oid*)h)-min]
								*dst: prod in-place or in prods-array ?
	@8:	<empty> / if (w >= base && w < end)		check head (oid) ranges in case b & g
								are not void-headed and aligned
	@9:	result type
	@[10]:		r-off		(*(oid*)h)-min	index in hit array
*/
@= aggrX3_prod3
	ALGODEBUG THRprintf(GDKout, "#aggrX3_prod3(@1,@2,@3,@4,@5,@6,@7,@8,@9,@[10]);\n");
	if (@1 && range > 0) {
		/* create tmp. prods array */
		oid i;
		prods = (@9*) GDKmalloc(range*sizeof(@9));
		if (prods == NULL) {
			GDKerror("aggrX3_prod3(@1,@2,@3,@4,@5,@6,@6,@7,@8,@9,@[10]): prods = GDKmalloc("OIDFMT"*"SZFMT") failed", range, sizeof(@9));
			BBPreclaim(bn);
			return GDK_FAIL;
		}
		for (i = 0; i < range; i++)
			prods[i] = zero;
	}
	if (@2 && BATprepareHash(bn)) {
		GDKerror("aggrX3_prod3(@1,@2,@3,@4,@5,@6,@6,@7,@8,@9,@[10]): BATprepareHash(bn) failed");
		if (@1 && prods)
			GDKfree(prods);
		BBPreclaim(bn);
		return GDK_FAIL;
	}
	hit = (bit*) GDKzalloc(slots*sizeof(bit));
	if (hit == NULL) {
		GDKerror("aggrX3_prod3(@1,@2,@3,@4,@5,@6,@7,@8,@9,@[10]): hit = GDKzalloc("OIDFMT"*"SZFMT") failed", slots, sizeof(bit));
		if (@1 && prods)
			GDKfree(prods);
		BBPreclaim(bn);
		return GDK_FAIL;
	}
	/* scan b & g, and add values to prods in-place or in prods-array */
	base = BUNfirst(g);
	offset = (ssize_t) base - (ssize_t) g->hseqbase;
	end = base + BATcount(g);
	(void) end;		/* keep compilers happy */
	bhsb = b->hseqbase;
	BATpreload_(b,USE_HEAD|USE_TAIL,BUF_SEQUENTIAL);
	BATpreload_(g,USE_TAIL,BUF_WILLNEED);
	if (b->T->nonil) {
		BATloop(b, p, q) {
			@6 *t = (@6*) BUNtloc(bi,p);
			oid v = *(oid*) @5;

			w = (BUN) (offset + v);
			@8 {
				oid *h = (oid*) BUNtail(gi, w);

				@3(r, bni, (oid*)h);
				if (r != BUN_NONE) {
					@9 *dst = (@9*) @7;
					*dst *= (@9) *t;
					hit[@[10]] = 1;
				}
			}
		}
	} else {
		BATloop(b, p, q) {
			@6 *t = (@6*) BUNtloc(bi,p);
			oid v = *(oid*) @5;

			w = (BUN) (offset + v);
			@8 {
				oid *h = (oid*) BUNtail(gi, w);

				@3(r, bni, (oid*)h);
				if (r != BUN_NONE) {
					@9 *dst = (@9*) @7;
					if (*dst != @9_nil) {
						if (*t == @6_nil) {
							*dst = @9_nil;
						} else {
							*dst *= (@9) *t;
							hit[@[10]] = 1;
						}
					}
				}
			}
		}
	}
	_BATpreload(b,USE_HEAD|USE_TAIL,BUF_SEQUENTIAL);
	_BATpreload(g,USE_TAIL,BUF_WILLNEED);
	if (@1) {
	    if (prods) {
		/* copy prods array to final result */
		BATpreload_(bn,USE_HEAD|USE_TAIL,BUF_SEQUENTIAL);
		BATloop(bn, p, q) {
			oid h = (*(oid*) BUNh@4(bni,p)) - min;
			@9 *dst = (@9*)BUNtloc(bni, p);
			if (hit[h] == 0) {
				*dst = @9_nil;
			} else {
				*dst = prods[h];
			}
		}
		_BATpreload(bn,USE_HEAD|USE_TAIL,BUF_SEQUENTIAL);
		GDKfree(prods);
	    }
	} else {
		BUN yy = 0;
		BATpreload_(bn,USE_HEAD|USE_TAIL,BUF_SEQUENTIAL);
		BATloop(bn, p, q) {
			@9 *dst = (@9*)BUNtloc(bni, p);
			if (hit[yy] == 0) {
				*dst = @9_nil;
			}
			yy++;
		}
		_BATpreload(bn,USE_HEAD|USE_TAIL,BUF_SEQUENTIAL);
	}
	if (hit)
		GDKfree(hit);
@
@c

/*	arithprod3
	@6:	bte / sht / int / wrd / lng / flt / dbl		b/bn-tail-type

#	not used any more
#	@7:	"loc" for fixsized b/bn-tail-type,	b/bn-tail-access
#		"var" for varsized b/bn-tail-type	(only loc used currently)

	@9:	result type
*/
@= arithprod3_h
int
CMDaggrX3_prod3_@1_@2(BAT **ret, BAT *b, BAT *g, BAT *e);
@= arithprod3_c

static int
aggrX3_prod3_@1_@2_EarrayBvoidGvoid (BAT *bn, BAT *b, BAT *g, BAT *e, oid range, oid min, oid max)
{
	@2 zero = (@2) 1, *prods = NULL;
	bit *hit = NULL;
	BUN slots = range;
	BUN p, q, r;
	oid bhsb;
	BUN base, end, w;
	ssize_t offset;
	BATiter bni = bat_iterator(bn), bi = bat_iterator(b), gi = bat_iterator(g);

	ALGODEBUG THRprintf(GDKout, "#aggrX3_prod3_@1_@2_EarrayBvoidGvoid(bn=%s,b=%s,g=%s,e=%s,range=" OIDFMT ",min=" OIDFMT ",max=" OIDFMT ");\n",
					BATgetId(bn),BATgetId(b),BATgetId(g),BATgetId(e),
					range,min,max);
	@:aggrX3_prod3(1,0,CHKrange,loc,&bhsb;bhsb++,@1,&prods[(*(oid*)h)-min],,@2,(*(oid*)h)-min)@

	return GDK_SUCCEED;
}

int
CMDaggrX3_prod3_@1_@2(BAT **ret, BAT *b, BAT *g, BAT *e)
{
	BAT *bn;
	BATiter bni, bi = bat_iterator(b), gi = bat_iterator(g);
	@2 zero = (@2) 1, *prods = NULL;
	bit *hit = NULL;
	BUN slots, off;
	BUN p, q, r;
	oid range;
	oid min, max;
	oid bhsb;
	BUN base, end, w;
	ssize_t offset;

	ALGODEBUG THRprintf(GDKout, "#CMDaggrX3_prod3_@1_@2(b=%s,g=%s,e=%s);\n",
		BATgetId(b),BATgetId(g),BATgetId(e));
/*	ERRORcheck((BATcount(b)!=BATcount(g)), "CMDaggrX3_prod3_@1: BATs b & g must be of equal size.\n");	*/
	ERRORcheck((g->htype == TYPE_void) && (g->hseqbase == oid_nil) && (BATcount(g) > 0), "CMDaggrX3_prod3_@1: head of BAT g must not be nil.\n");

	if((g->hseqbase == oid_nil) || (!BAThdense(g)) || (!(BAThordered(b)&1)) || (!g->hkey)) {
		BAT *gb = BATjoin(BATmirror(g),b,BUN_NONE);
		int rtrn = CMDaggrX3_prod_@1_@2(ret, gb, e);
		BBPunfix(gb->batCacheid);
		return rtrn;
	}

	bn = BATnew(e->htype, TYPE_@2, BATcount(e));
	if( bn == NULL) {
		GDKerror("CMDaggrX3_prod3_@1_@2(): BATnew() failed");
		return GDK_FAIL;
	}
	bni = bat_iterator(bn);
	off = BUNfirst(bn);
	*ret = bn;

	/* init: set all prods to zero and calculate min/max oid */
	@:init_result(@2)@
	range = max - min + 1;

	/* scan b & g, and calculate prods */
	slots = BATcount(e);
	if (slots == 0) {
		/* empty extend => empty result */
		*ret = bn;
		return GDK_SUCCEED;
	}
	if (e->htype == TYPE_void) {
		/* void lookup */
		if (b->htype == TYPE_void) {
			if ((g->htype == TYPE_void)&&(BATcount(b)==BATcount(g))&&(b->hseqbase==g->hseqbase)) {
				@:aggrX3_prod3(0,0,BUNfndVOID,var,&bhsb;bhsb++,@1,BUNtloc(bni,r),,@2,r-off)@
			} else {
				@:aggrX3_prod3(0,0,BUNfndVOID,var,&bhsb;bhsb++,@1,BUNtloc(bni,r),if (w >= base && w < end),@2,r-off)@
			}
		} else {
			@:aggrX3_prod3(0,0,BUNfndVOID,var,BUNhloc(bi,p),@1,BUNtloc(bni,r),if (w >= base && w < end),@2,r-off)@
		}
	/* e->htype == TYPE_oid */
	} else if (range <= SMALL_AGGR_MAX) {
		/* array lookup */
		slots = range;
		if (b->htype == TYPE_void) {
			if ((g->htype == TYPE_void)&&(BATcount(b)==BATcount(g))&&(b->hseqbase==g->hseqbase)) {
				return aggrX3_prod3_@1_@2_EarrayBvoidGvoid (bn, b, g, e, range, min, max);
			} else {
				@:aggrX3_prod3(1,0,CHKrange,loc,&bhsb;bhsb++,@1,&prods[(*(oid*)h)-min],if (w >= base && w < end),@2,(*(oid*)h)-min)@
			}
		} else {
			@:aggrX3_prod3(1,0,CHKrange,loc,BUNhloc(bi,p),@1,&prods[(*(oid*)h)-min],if (w >= base && w < end),@2,(*(oid*)h)-min)@
		}
	} else if (BATcount(e) <= SCAN_AGGR_MAX) {
		/* scan lookup */
		SCAN_aggr_init;
		if (b->htype == TYPE_void) {
			if ((g->htype == TYPE_void)&&(BATcount(b)==BATcount(g))&&(b->hseqbase==g->hseqbase)) {
				@:aggrX3_prod3(0,0,SCANfndOID,loc,&bhsb;bhsb++,@1,BUNtloc(bni,r),,@2,r-off)@
			} else {
				@:aggrX3_prod3(0,0,SCANfndOID,loc,&bhsb;bhsb++,@1,BUNtloc(bni,r),if (w >= base && w < end),@2,r-off)@
			}
		} else {
			@:aggrX3_prod3(0,0,SCANfndOID,loc,BUNhloc(bi,p),@1,BUNtloc(bni,r),if (w >= base && w < end),@2,r-off)@
		}
	} else {
		/* hash lookup */
		if (b->htype == TYPE_void) {
			if ((g->htype == TYPE_void)&&(BATcount(b)==BATcount(g))&&(b->hseqbase==g->hseqbase)) {
				@:aggrX3_prod3(0,1,HASHfnd_oid,loc,&bhsb;bhsb++,@1,BUNtloc(bni,r),,@2,r-off)@
			} else {
				@:aggrX3_prod3(0,1,HASHfnd_oid,loc,&bhsb;bhsb++,@1,BUNtloc(bni,r),if (w >= base && w < end),@2,r-off)@
			}
		} else {
			@:aggrX3_prod3(0,1,HASHfnd_oid,loc,BUNhloc(bi,p),@1,BUNtloc(bni,r),if (w >= base && w < end),@2,r-off)@
		}
	}

	return GDK_SUCCEED;
}
@
@= arithprod3_hc
@:arithprod3_@1(@2,@3)@
@= arithprod3
@:arithprod3_hc(@1,bte,bte)@
@:arithprod3_hc(@1,bte,sht)@
@:arithprod3_hc(@1,bte,int)@
@:arithprod3_hc(@1,bte,wrd)@
@:arithprod3_hc(@1,bte,lng)@
@:arithprod3_hc(@1,sht,sht)@
@:arithprod3_hc(@1,sht,int)@
@:arithprod3_hc(@1,sht,wrd)@
@:arithprod3_hc(@1,sht,lng)@
@:arithprod3_hc(@1,int,int)@
@:arithprod3_hc(@1,int,wrd)@
@:arithprod3_hc(@1,int,lng)@
@:arithprod3_hc(@1,wrd,wrd)@
@:arithprod3_hc(@1,wrd,lng)@
@:arithprod3_hc(@1,lng,wrd)@
@:arithprod3_hc(@1,lng,lng)@
@:arithprod3_hc(@1,flt,flt)@
@:arithprod3_hc(@1,flt,dbl)@
@:arithprod3_hc(@1,dbl,dbl)@
@h
@:arithprod3(h)@
@c
@:arithprod3(c)@

@}
