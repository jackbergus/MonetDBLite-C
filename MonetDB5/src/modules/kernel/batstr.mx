@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
@' Copyright August 2008-2010 MonetDB B.V.
@' All Rights Reserved.

@f batstr
@a M.L. Kersten
@+ String multiplexes
[TODO: property propagations]
The collection of routines provided here are map operations
for the atom string primitives. 

In line with the batcalc module, we assume that
if two bat operands are provided that they are already
aligned on the head. Moreover, the head of the BATs
are limited to :void, which can be cheaply realized using
the GRPsplit operation.
@{
@mal
module batstr;

command batstr.length( s:bat[:oid,:str] ) :bat[:oid,:int]
address STRbatLength
comment "Return the length of a string.";

command batstr.nbytes( s:bat[:oid,:str] ) :bat[:oid,:int]
address STRbatBytes
comment "Return the string length in bytes.";

command batcalc.==( l:bat[:oid,:str], r:bat[:oid,:str]) :bat[:oid,:bit]
address STRbatEqual
comment "Equate a bat of strings against each other";
command batcalc.==( l:bat[:oid,:str], r:str) :bat[:oid,:bit]
address STRbatEqualCst
comment "Equate a bat of strings against a singleton";

command batcalc.!=( l:bat[:oid,:str], r:bat[:oid,:str]) :bat[:oid,:bit]
address STRbatNotEqual
comment "Equate a bat of strings against each other";
command batcalc.!=( l:bat[:oid,:str], r:str) :bat[:oid,:bit]
address STRbatNotEqualCst
comment "Equate a bat of strings against a singleton";

command batstr.toLower( s:bat[:oid,:str] ) :bat[:oid,:str]
address STRbatLower
comment "Convert a string to lower case.";
command batstr.toUpper( s:bat[:oid,:str] ) :bat[:oid,:str]
address STRbatUpper
comment "Convert a string to upper case.";

command batstr.trim( s:bat[:oid,:str] ) :bat[:oid,:str]
address STRbatStrip
comment "Strip whitespaces around a string.";
command batstr.ltrim( s:bat[:oid,:str] ) :bat[:oid,:str]
address STRbatLtrim
comment "Strip whitespaces from start of a string.";
command batstr.rtrim( s:bat[:oid,:str] ) :bat[:oid,:str]
address STRbatRtrim
comment "Strip whitespaces from end of a string.";

command batstr.startsWith(s:bat[:oid,:str],prefix:bat[:oid,:str]):bat[:oid,:bit]
address STRbatPrefix
comment "Prefix check.";
command batstr.startsWith(s:bat[:oid,:str],prefix:str):bat[:oid,:bit]
address STRbatPrefixcst
comment "Prefix check.";

command batstr.endsWith( s:bat[:oid,:str], suffix:bat[:oid,:str] ) :bat[:oid,:bit]
address STRbatSuffix
comment "Suffix check.";
command batstr.endsWith( s:bat[:oid,:str], suffix:str ) :bat[:oid,:bit]
address STRbatSuffixcst
comment "Suffix check.";

command batstr.search( s:bat[:oid,:str], c:bat[:oid,:str] ) :bat[:oid,:int]
address STRbatstrSearch
comment "Search for a substring. Returns position, -1 if not found.";
command batstr.search( s:bat[:oid,:str], c:str ) :bat[:oid,:int]
address STRbatstrSearchcst
comment "Search for a substring. Returns position, -1 if not found.";

command batstr.r_search( s:bat[:oid,:str], c:bat[:oid,:str] ) :bat[:oid,:int]
address STRbatRstrSearch
comment "Reverse search for a substring. Returns position, -1 if not found.";
command batstr.r_search( s:bat[:oid,:str], c:str ) :bat[:oid,:int]
address STRbatRstrSearchcst
comment "Reverse search for a substring. Returns position, -1 if not found.";

command batcalc.+( l:bat[:oid,:str], r:bat[:oid,:str]) :bat[:oid,:str]
address STRbatConcat
comment "Concatenate two strings.";
command batcalc.+( l:bat[:oid,:str], r:str) :bat[:oid,:str]
address STRbatConcatcst
comment "Concatenate a string to a bat of strings.";
command batcalc.+( l:str, r:bat[:oid,:str]) :bat[:oid,:str]
address STRcstConcatbat
comment "Concatenate two strings.";

command batstr.string(b:bat[:oid,:str],offset:bat[:oid,:int]) :bat[:oid,:str]
address STRbatTail
comment "Return the tail s[offset..n] of a string s[0..n].";
command batstr.string(b:bat[:oid,:str],offset:int) :bat[:oid,:str]
address STRbatTailcst
comment "Return the tail s[offset..n] of a string s[0..n].";

command batstr.chrAt( s:bat[:oid,:str], index:bat[:oid,:int]) :bat[:oid,:chr]
address STRbatChrAt
comment "String array lookup operation.";
command batstr.chrAt( s:bat[:oid,:str], index:int) :bat[:oid,:chr]
address STRbatChrAtcst
comment "String array lookup operation.";

command batstr.substring( s:bat[:oid,:str], start:bat[:oid,:int], 
	index:bat[:oid,:int]) :bat[:oid,:str]
address STRbatsubstring
comment "Substring extraction using [start,start+length]";

command batstr.substring( s:bat[:oid,:str], start:int, index:int)
	:bat[:oid,:str]
address STRbatsubstringcst
comment "Substring extraction using [start,start+length]";

command batstr.unicodeAt(s:bat[:oid,:str], index:bat[:oid,:int]) :bat[:oid,:int]
address STRbatWChrAt
comment "get a unicode character (as an int) from a string position.";
command batstr.unicodeAt(s:bat[:oid,:str], index:int) :bat[:oid,:int]
address STRbatWChrAtcst
comment "get a unicode character (as an int) from a string position.";

command batstr.substitute(s:bat[:oid,:str],src:str,dst:str,rep:bit):bat[:oid,:str]
address STRbatSubstitutecst
comment "Substitute first occurrence of 'src' by
	'dst'.  Iff repeated = true this is
	repeated while 'src' can be found in the
	result string. In order to prevent
	recursion and result strings of unlimited
	size, repeating is only done iff src is
	not a substring of dst.";

command batstr.like_uselect(s:bat[:oid,:str],pat:str):bat[:oid,:void]
address STRbatlike_uselect2
comment "Perform SQL like operation against a string bat";

command batstr.like_uselect(s:bat[:oid,:str],pat:str,esc:str):bat[:oid,:void]
address STRbatlike_uselect
comment "Perform SQL like operation against a string bat";

command batstr.replace(s:bat[:oid,:str],pat:str,s2:str):bat[:oid,:str]
address STRbatreplace
comment "Insert a string into another";

@+ Implementation
@c
#include "mal_config.h"
#include <gdk.h>
#include "ctype.h"
#include <string.h>
#include "mal_exception.h"
#include "str.h"

#ifdef HAVE_LANGINFO_H
#include <langinfo.h>
#endif
#ifdef HAVE_ICONV_H
#include <iconv.h>
#endif

#ifdef WIN32
#ifndef LIBBATSTR
#define batstr_export extern __declspec(dllimport)
#else
#define batstr_export extern __declspec(dllexport)
#endif
#else
#define batstr_export extern
#endif

#define prepareOperand(X,Y,Z) \
	if( (X= BATdescriptor(*Y)) == NULL ) \
		throw(MAL, "batstr." Z, RUNTIME_OBJECT_MISSING);
#define prepareOperand2(X,Y,A,B,Z) \
	if( (X= BATdescriptor(*Y)) == NULL ) \
		throw(MAL, "batstr." Z, RUNTIME_OBJECT_MISSING); \
	if( (A= BATdescriptor(*B)) == NULL ){\
		BBPreleaseref(X->batCacheid); \
		throw(MAL, "batstr."Z, RUNTIME_OBJECT_MISSING); \
	}
#define prepareResult(X,Y,T,Z) \
	X= BATnew(Y->htype,T,BATcount(Y)); \
	if( X == NULL){ \
		BBPreleaseref(Y->batCacheid); \
		throw(MAL, "batstr." Z, MAL_MALLOC_FAIL); \
	} \
	if( Y->htype== TYPE_void) \
		BATseqbase(X, Y->hseqbase); \
	X->hsorted=Y->hsorted; \
	X->tsorted=0; 
#define prepareResult2(X,Y,A,T,Z) \
	X= BATnew(Y->htype,T,BATcount(Y)); \
	if( Y->htype== TYPE_void) \
		BATseqbase(X, Y->hseqbase); \
	if( X == NULL){ \
		BBPreleaseref(Y->batCacheid); \
		BBPreleaseref(A->batCacheid); \
		throw(MAL, "batstr." Z, MAL_MALLOC_FAIL); \
	} \
	X->hsorted=Y->hsorted; \
	X->tsorted=0; 
#define finalizeResult(X,Y,Z) \
	if (!((Y)->batDirty&2)) (Y) = BATsetaccess((Y), BAT_READ); \
	*X = (Y)->batCacheid; \
	BBPkeepref(*(X));\
	BBPreleaseref(Z->batCacheid);

@= BATint
batstr_export str STRbat@1(int *ret, int *l);
str STRbat@1(int *ret, int *l)
{   
	BATiter bi;
	BAT *bn, *b;
	BUN p,q;
	@3 x;
	int y, *yp = &y;

	prepareOperand(b,l,"@1");
	prepareResult(bn,b,TYPE_int,"@1");

	bi = bat_iterator(b);

	BATpreload(b, BUF_SEQUENTIAL);
	BATloop(b, p, q) {
		ptr h = BUNhead(bi,p);
		x = (@3) BUNtail(bi,p);
		if (x== 0 || strcmp(x,@3_nil)== 0) {
			y= int_nil;
			bn->T->nonil = 0;
		} else 
			@2(yp,x);
		bunfastins(bn, h, yp);
	}
	finalizeResult(ret,bn,b);
	return MAL_SUCCEED;
bunins_failed:
	BBPreleaseref(b->batCacheid);
	BBPunfix(bn->batCacheid);
	throw(MAL, "batstr.@1", OPERATION_FAILED " During bulk operation");
}

@c
@:BATint(Length,strLength,str)@
@:BATint(Bytes,strBytes,str)@

@= BATstr
batstr_export str STRbat@1(int *ret, int *l);
str STRbat@1(int *ret, int *l)
{   
	BATiter bi;
	BAT *bn, *b;
	BUN p,q;
	@3 x;

	prepareOperand(b,l,"@1");
	prepareResult(bn,b,TYPE_str,"@1");

	bi = bat_iterator(b);

	BATpreload(b, BUF_SEQUENTIAL);
	BATloop(b, p, q) {
		ptr h = BUNhead(bi,p);
		str y = (str)str_nil, *yp = &y;

		x = (@3) BUNtail(bi,p);
		if (x != 0 && strcmp(x,@3_nil) != 0) 
			@2(yp,x);
		bunfastins(bn, h, y);
		if (y != str_nil)
			GDKfree(y);
	}
	bn->T->nonil = 0;
	finalizeResult(ret,bn,b);
	return MAL_SUCCEED;
bunins_failed:
	BBPreleaseref(b->batCacheid);
	BBPunfix(bn->batCacheid);
	throw(MAL, "batstr.@1", OPERATION_FAILED " During bulk operation");
}
@c
@:BATstr(Lower,strLower,str)@
@:BATstr(Upper,strUpper,str)@
@:BATstr(Strip,strStrip,str)@
@:BATstr(Ltrim,strLtrim,str)@
@:BATstr(Rtrim,strRtrim,str)@

@-
@c
@= STRbatcstcmp
batstr_export str STRbat@2Cst(int *ret, int *l, str *cst);
str
STRbat@2Cst(int *ret, int *l, str *cst)
{
	BATiter bi;
	BAT *bn, *b;
	BUN p, q;
	str x;
	bit y;
	int isnil = 0;

	prepareOperand(b, l, "@1");
	prepareResult(bn, b, TYPE_bit, "@1");

	bi = bat_iterator(b);
	
	if (strcmp(*cst, str_nil) == 0) 
		isnil = 1;
	BATpreload(b, BUF_SEQUENTIAL);
	BATloop(b, p, q) {
		ptr h = BUNhead(bi, p);

		x = (str) BUNtail(bi, p);
		if (isnil || x == 0 || strcmp(x, str_nil) == 0) {
			y = bit_nil;
			bn->T->nonil = 0;
		} else
			y = strcmp(x, *cst) @1 0;
		bunfastins(bn, h, &y);
	}
	bn->tsorted = (BATtordered(b)&1)?@3:0;
	finalizeResult(ret, bn, b);
	return MAL_SUCCEED;
bunins_failed:
	BBPreleaseref(b->batCacheid);
	BBPunfix(bn->batCacheid);
	throw(MAL, "batstr.@1", OPERATION_FAILED " During bulk operation");
}
@c
@:STRbatcstcmp(==,Equal,GDK_SORTED_REV)@
@:STRbatcstcmp(!=,NotEqual,GDK_SORTED)@

@-
A general assumption in all cases is the bats are synchronized on their
head column. This is not checked and may be mis-used to deploy the
implementation for shifted window arithmetic as well.
@= chkSize
	if( BATcount(@1) != BATcount(@2) )
	throw(MAL, "batstr.@3", ILLEGAL_ARGUMENT " Requires bats of identical size");
@c
@= STRbatcmp
batstr_export str STRbat@2(int *ret, int *l, int *r);
str
STRbat@2(int *ret, int *l, int *r)
{
	BATiter lefti, righti;
	BAT *bn, *left, *right;
	BUN p, q;

	prepareOperand2(left, l, right, r, "@1");
	@:chkSize(left,right,CMDcompare@1)@
	prepareResult2(bn, left, right, TYPE_bit, "@1");

	lefti = bat_iterator(left);
	righti = bat_iterator(right);

	BATpreload(left, BUF_SEQUENTIAL);
	BATpreload(right, BUF_SEQUENTIAL);
	BATloop(left, p, q) {
		bit y = TRUE;
		ptr h = BUNhead(lefti, p);
		ptr tl = BUNtail(lefti, p);
		ptr tr = BUNtail(righti, p);

		if (tl == 0 || tr == 0 || !(strcmp(tl, tr) @1 0))
			y = FALSE;
		bunfastins(bn, h, &y);
	}
	bn->T->nonil = 0;
	BBPreleaseref(right->batCacheid);
	bn->tsorted = (BATtordered(left)&BATtordered(right)&1)?@3:0;
	finalizeResult(ret, bn, left);
	return MAL_SUCCEED;

bunins_failed:
	BBPreleaseref(left->batCacheid);
	BBPreleaseref(right->batCacheid);
	BBPunfix(*ret);
	throw(MAL, "batstr.@1", OPERATION_FAILED " During bulk operation");
}
@c
@:STRbatcmp(==,Equal,GDK_SORTED_REV)@
@:STRbatcmp(!=,NotEqual,GDK_SORTED)@

@= binarySTR
batstr_export str STRbat@1(int *ret, int *l, int *r);
str STRbat@1(int *ret, int *l, int *r)
{   
	BATiter lefti, righti;
	BAT *bn, *left, *right;
	BUN p,q;
	@2 v, *vp= &v;

	prepareOperand2(left,l,right,r,@5);
	@:chkSize(left,right,CMDcompare@1)@
	prepareResult2(bn,left,right,TYPE_@2,@5);

	lefti = bat_iterator(left);
	righti = bat_iterator(right);

	BATpreload(left, BUF_SEQUENTIAL);
	BATpreload(right, BUF_SEQUENTIAL);
	BATloop(left, p, q) {
		ptr h = BUNhead(lefti,p);
		ptr tl = BUNtail(lefti,p);
		ptr tr = BUNtail(righti,p);
		@4(vp, tl, tr);
		bunfastins(bn, h, vp);
		@7;
	}
	bn->T->nonil = 0;
	BBPreleaseref(right->batCacheid);
	finalizeResult(ret,bn,left);
	return MAL_SUCCEED;

bunins_failed:
	BBPreleaseref(left->batCacheid);
	BBPreleaseref(right->batCacheid);
	BBPunfix(*ret);
	throw(MAL, "batstr." @5, OPERATION_FAILED " During bulk operation");
}

batstr_export str STRbat@1cst(int *ret, int *l, @3 *cst);
str STRbat@1cst(int *ret, int *l, @3 *cst)
{   
	BATiter lefti;
	BAT *bn, *left;
	BUN p,q;
	@2 v, *vp= &v;

	prepareOperand(left,l,@5);
	prepareResult(bn,left,TYPE_@2,@5);

	lefti = bat_iterator(left);

	BATpreload(left, BUF_SEQUENTIAL);
	BATloop(left, p, q) {
		ptr h = BUNhead(lefti,p);
		ptr tl = BUNtail(lefti,p);
		@4(vp, tl, cst);
		bunfastins(bn, h, vp);
		@7;
	}
	bn->T->nonil = 0;
	finalizeResult(ret,bn,left);
	return MAL_SUCCEED;

bunins_failed:
	BBPreleaseref(left->batCacheid);
	BBPreleaseref(*ret);
	throw(MAL, "batstr"@5, OPERATION_FAILED " During bulk operation");
}
@= binarySTRstr
batstr_export str STRbat@1(int *ret, int *l, int *r);
str STRbat@1(int *ret, int *l, int *r)
{   
	BATiter lefti, righti;
	BAT *bn, *left, *right;
	BUN p,q;
	@2 v, *vp= &v;

	prepareOperand2(left,l,right,r,@5);
	@:chkSize(left,right,CMDcompare@1)@
	prepareResult2(bn,left,right,TYPE_@2,@5);

	lefti = bat_iterator(left);
	righti = bat_iterator(right);

	BATpreload(left, BUF_SEQUENTIAL);
	BATpreload(right, BUF_SEQUENTIAL);
	BATloop(left, p, q) {
		ptr h = BUNhead(lefti,p);
		str tl = (str) BUNtail(lefti,p);
		str tr = (str) BUNtail(righti,p);
		@4(vp, &tl, &tr);
		bunfastins(bn, h, @6);
		@7;
	}
	bn->T->nonil = 0;
	BBPreleaseref(right->batCacheid);
	finalizeResult(ret,bn,left);
	return MAL_SUCCEED;

bunins_failed:
	BBPreleaseref(left->batCacheid);
	BBPreleaseref(right->batCacheid);
	BBPunfix(*ret);
	throw(MAL, "batstr." @5, OPERATION_FAILED " During bulk operation");
}

batstr_export str STRbat@1cst(int *ret, int *l, @3 *cst);
str STRbat@1cst(int *ret, int *l, @3 *cst)
{   
	BATiter lefti;
	BAT *bn, *left;
	BUN p,q;
	@2 v, *vp= &v;

	prepareOperand(left,l,@5);
	prepareResult(bn,left,TYPE_@2,@5);

	lefti = bat_iterator(left);

	BATpreload(left, BUF_SEQUENTIAL);
	BATloop(left, p, q) {
		ptr h = BUNhead(lefti,p);
		str tl = (str) BUNtail(lefti,p);
		@4(vp, &tl, cst);
		bunfastins(bn, h, @6);
		@7;
	}
	bn->T->nonil = 0;
	finalizeResult(ret,bn,left);
	return MAL_SUCCEED;

bunins_failed:
	BBPreleaseref(left->batCacheid);
	BBPunfix(*ret);
	throw(MAL, "batstr"@5, OPERATION_FAILED " During bulk operation");
}

batstr_export str STRcst@1bat(int *ret, @3 *cst, int *r);
str STRcst@1bat(int *ret, @3 *cst, int *r)
{   
	BATiter righti;
	BAT *bn, *right;
	BUN p,q;
	@2 v, *vp= &v;

	prepareOperand(right,r,@5);
	prepareResult(bn,right,TYPE_@2,@5);

	righti = bat_iterator(right);

	BATpreload(right, BUF_SEQUENTIAL);
	BATloop(right, p, q) {
		ptr h = BUNhead(righti,p);
		str tr = (str) BUNtail(righti,p);
		@4(vp, cst, &tr);
		bunfastins(bn, h, @6);
		@7;
	}
	bn->T->nonil = 0;
	finalizeResult(ret,bn,right);
	return MAL_SUCCEED;

bunins_failed:
	BBPreleaseref(right->batCacheid);
	BBPunfix(*ret);
	throw(MAL, "batstr"@5, OPERATION_FAILED " During bulk operation");
}
@c
@:binarySTRstr(Prefix,bit,str,STRPrefix,"prefix",vp,)@
@:binarySTRstr(Suffix,bit,str,STRSuffix,"suffix",vp,)@
@:binarySTRstr(strSearch,int,str,STRstrSearch,"search",vp,)@
@:binarySTRstr(RstrSearch,int,str,STRReverseStrSearch,"r_search",vp,)@
@:binarySTRstr(Concat,str,str,STRConcat,"+",v,GDKfree(v))@
@:binarySTR(Tail,str,int,strTail,"tail",v,GDKfree(v))@
@:binarySTR(WChrAt,int,int,strWChrAt,"chrAt",vp,)@
@:binarySTR(ChrAt,chr,int,strChrAt,"chrAt",vp,)@

batstr_export str STRbatSubstitutecst(int *ret, int *l, str *arg2, str *arg3, bit *rep);
str
STRbatSubstitutecst(int *ret, int *l, str *arg2, str *arg3, bit *rep)
{
	BATiter bi;
	BAT *bn, *b;
	BUN p, q;
	str x, *xp = &x;

	prepareOperand(b, l, "subString");
	prepareResult(bn, b, TYPE_int, "subString");

	bi = bat_iterator(b);

	BATpreload(b, BUF_SEQUENTIAL);
	BATloop(b, p, q) {
		ptr h = BUNhead(bi, p);
		str y = (str)str_nil, *yp = &y;

		x = (str) BUNtail(bi, p);
		if (x != 0 && strcmp(x, str_nil) != 0)
			STRSubstitute(yp, xp, arg2, arg3, rep);
		bunfastins(bn, h, y);
		if (y != str_nil)
			GDKfree(yp);
	}
	bn->T->nonil = 0;
	finalizeResult(ret, bn, b);
	return MAL_SUCCEED;
bunins_failed:
	BBPreleaseref(b->batCacheid);
	BBPreleaseref(bn->batCacheid);
	throw(MAL, "batstr.subString", OPERATION_FAILED " During bulk operation");
}

@-
The pattern matching routine is optimized for SQL pattern structures.
@c
#define percent "\001"
#define underscore "\002"
batstr_export str STRbatlike_uselect(int *ret, int *bid, str *pat, str *esc);
str
STRbatlike_uselect(int *ret, int *bid, str *pat, str *esc)
{
	BATiter bi;
	BAT *b,*bn;
	BUN p, q;
	oid o = oid_nil;

	if( (b= BATdescriptor(*bid)) == NULL)
		throw(MAL, "batstr.like", RUNTIME_OBJECT_MISSING);
	bn= BATnew(BAThtype(b),TYPE_void, BATcount(b)/10+5);
	BATseqbase(BATmirror(b),o);
	bn->hsorted = b->hsorted;
	bn->tsorted = b->tsorted;

	bi = bat_iterator(b);

	BATpreload(b, BUF_SEQUENTIAL);
	BATloop(b, p, q) {
		ptr h = BUNhead(bi, p);
		ptr t = BUNtail(bi, p);

		if (STRlike((str) t, *pat, *esc)) 
			bunfastins(bn, h, &o);
	}
	bn->T->nonil = 0;
bunins_failed:
	if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ); 
	*ret = bn->batCacheid;
	BBPkeepref(bn->batCacheid);
	BBPreleaseref(b->batCacheid);
	return MAL_SUCCEED;
}
batstr_export str STRbatlike_uselect2(int *ret, int *bid, str *pat);
str
STRbatlike_uselect2(int *ret, int *bid, str *pat)
{
	str esc="";
	return STRbatlike_uselect(ret,bid,pat,&esc);
}
@-
The substring functions require slightly different arguments
@c
batstr_export str STRbatsubstringcst(int *ret, int *bid, int *start, int *length);
str
STRbatsubstringcst(int *ret, int *bid, int *start, int *length)
{
	BATiter bi;
	BAT *b,*bn;
	BUN p, q;
	str res;
	oid o=oid_nil;
	char *msg = MAL_SUCCEED;

	if( (b= BATdescriptor(*bid)) == NULL)
		throw(MAL, "batstr.substring",RUNTIME_OBJECT_MISSING);
	bn= BATnew(BAThtype(b),TYPE_str, BATcount(b)/10+5);
	BATseqbase(BATmirror(b),o);
	bn->hsorted = b->hsorted;
	bn->tsorted = b->tsorted;

	bi = bat_iterator(b);
	BATpreload(b, BUF_SEQUENTIAL);
	BATloop(b, p, q) {
		ptr h = BUNhead(bi, p);
		str t =  (str) BUNtail(bi, p);

		if ((msg=STRsubstring(&res, &t, start, length))) 
			goto bunins_failed;
		bunfastins(bn, h, (ptr)res);
		GDKfree(res);
	}
	bn->T->nonil = 0;
bunins_failed:
	if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ); 
	*ret = bn->batCacheid;
	BBPkeepref(bn->batCacheid);
	BBPreleaseref(b->batCacheid);
	return msg;
}

batstr_export str STRbatsubstring(int *ret, int *l, int *r, int *t);
str STRbatsubstring(int *ret, int *l, int *r, int *t)
{   
	BATiter lefti, starti, lengthi;
	BAT *bn, *left, *start, *length;
	BUN p,q;
	str v, *vp= &v;

	if( (left= BATdescriptor(*l)) == NULL ) 
		throw(MAL, "batstr.substring" , RUNTIME_OBJECT_MISSING); 
	if( (start= BATdescriptor(*r)) == NULL ){
		BBPreleaseref(left->batCacheid); 
		throw(MAL, "batstr.substring", RUNTIME_OBJECT_MISSING);
	}
	if( (length= BATdescriptor(*t)) == NULL ){
		BBPreleaseref(left->batCacheid); 
		BBPreleaseref(start->batCacheid); 
		throw(MAL, "batstr.substring", RUNTIME_OBJECT_MISSING);
	}
	@:chkSize(left,start,CMDbatsubstring)@
	@:chkSize(left,length,CMDbatsubstring)@
	bn= BATnew(left->htype,TYPE_str,BATcount(left)); 
	if( left->htype== TYPE_void)
		BATseqbase(bn, left->hseqbase); 
	if( bn == NULL){
		BBPreleaseref(left->batCacheid);
		BBPreleaseref(start->batCacheid);
		BBPreleaseref(length->batCacheid);
		throw(MAL, "batstr.substring", MAL_MALLOC_FAIL);
	}
	bn->hsorted= left->hsorted; 
	bn->tsorted=0; 

	lefti = bat_iterator(left);
	starti = bat_iterator(start);
	lengthi = bat_iterator(length);
	BATpreload(left, BUF_SEQUENTIAL);
	BATloop(left, p, q) {
		ptr h = BUNhead(lefti,p);
		str tl = (str) BUNtail(lefti,p);
		int *t1 = (int *) BUNtail(starti,p);
		int *t2 = (int *) BUNtail(lengthi,p);
		STRsubstring(vp, &tl, t1, t2);
		bunfastins(bn, h, *vp);
		GDKfree(*vp);
	}
	bn->T->nonil = 0;
	BBPreleaseref(start->batCacheid);
	BBPreleaseref(length->batCacheid);
	finalizeResult(ret,bn,left);
	return MAL_SUCCEED;

bunins_failed:
	BBPreleaseref(left->batCacheid);
	BBPreleaseref(start->batCacheid);
	BBPreleaseref(length->batCacheid);
	BBPunfix(*ret);
	throw(MAL, "batstr.substring", OPERATION_FAILED " During bulk operation");
}

batstr_export str STRbatreplace(int *ret, int *l, str *pat, str *s2);
str STRbatreplace(int *ret, int *l, str *pat, str *s2)
{   
	BATiter li;
	BAT *bn, *left;
	BUN p,q;
	str v, *vp= &v;

	if( (left= BATdescriptor(*l)) == NULL ) 
		throw(MAL, "batstr.replace" , RUNTIME_OBJECT_MISSING); 
	bn= BATnew(left->htype,TYPE_str,BATcount(left)); 
	if (left->htype== TYPE_void)
		BATseqbase(bn, left->hseqbase); 
	if (bn == NULL){
		BBPreleaseref(left->batCacheid);
		throw(MAL, "batstr.replace", MAL_MALLOC_FAIL);
	}
	bn->hsorted= left->hsorted; 
	bn->tsorted=0; 

	li = bat_iterator(left);
	BATpreload(left, BUF_SEQUENTIAL);
	BATloop(left, p, q) {
		ptr h = BUNhead(li,p);
		str tl = (str) BUNtail(li,p);
		STRreplace(vp, &tl, pat, s2);
		bunfastins(bn, h, *vp);
		GDKfree(*vp);
	}
	bn->T->nonil = 0;
	finalizeResult(ret,bn,left);
	return MAL_SUCCEED;

bunins_failed:
	BBPreleaseref(left->batCacheid);
	BBPunfix(*ret);
	throw(MAL, "batstr.replace", OPERATION_FAILED " During bulk operation");
}


@}
