@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2006 CWI.
@' All Rights Reserved.

@f batstr
@a M.L. Kersten
@* String multiplexes
[TODO: property propagations]
The collection of routines provided here are map operations
for the atom string primitives. 

In line with the batcalc module, we assume that
if two bat operands are provided that they are already
aligned on the head. Moreover, the head of the BATs
are limited to :void, which can be cheaply realized using
the GRPsplit operation.
@mal
command batcalc.length( s:bat[:void,:str] ) :bat[:void,:int]
address STRbatLength
comment "Return the length of a string.";

command batcalc.bytes( s:bat[:void,:str] ) :bat[:void,:int]
address STRbatBytes
comment "Return the string length in bytes.";

command batcalc.match(b:bat[:void,:str], pat:str):bat[:void,:bit]
address STRbatmatchCst
comment "POSIX pattern matching against a string BAT";

command batcalc.==( l:bat[:oid,:str], r:bat[:oid,:str]) :bat[:oid,:bit]
address STRbatEqual;
command batcalc.==( l:bat[:void,:str], r:bat[:void,:str]) :bat[:void,:bit]
address STRbatEqual
comment "Equate a bat of strings against each other";
command batcalc.==( l:bat[:oid,:str], r:str) :bat[:oid,:bit]
address STRbatEqualCst;
command batcalc.==( l:bat[:void,:str], r:str) :bat[:void,:bit]
address STRbatEqualCst
comment "Equate a bat of strings against a singleton";

command batcalc.!=( l:bat[:oid,:str], r:bat[:oid,:str]) :bat[:oid,:bit]
address STRbatNotEqual;
command batcalc.!=( l:bat[:void,:str], r:bat[:oid,:str]) :bat[:void,:bit]
address STRbatNotEqual
comment "Equate a bat of strings against each other";
command batcalc.!=( l:bat[:oid,:str], r:bat[:oid,:str]) :bat[:oid,:bit]
address STRbatNotEqual;
command batcalc.!=( l:bat[:void,:str], r:bat[:void,:str]) :bat[:void,:bit]
address STRbatNotEqual
comment "Equate a bat of strings against each other";
command batcalc.!=( l:bat[:void,:str], r:str) :bat[:void,:bit]
address STRbatNotEqualCst
comment "Equate a bat of strings against a singleton";

command batcalc.toLower( s:bat[:void,:str] ) :bat[:void,:str]
address STRbatLower
comment "Convert a string to lower case.";
command batcalc.toUpper( s:bat[:void,:str] ) :bat[:void,:str]
address STRbatUpper
comment "Convert a string to upper case.";

command batcalc.trim( s:bat[:void,:str] ) :bat[:void,:str]
address STRbatStrip
comment "Strip whitespaces around a string.";
command batcalc.ltrim( s:bat[:void,:str] ) :bat[:void,:str]
address STRbatLtrim
comment "Strip whitespaces from start of a string.";
command batcalc.rtrim( s:bat[:void,:str] ) :bat[:void,:str]
address STRbatRtrim
comment "Strip whitespaces from end of a string.";

command batcalc.startsWith(s:bat[:void,:str],prefix:bat[:void,:str]):bat[:void,:bit]
address STRbatPrefix
comment "Prefix check.";
command batcalc.startsWith(s:bat[:void,:str],prefix:str):bat[:void,:bit]
address STRbatPrefixcst
comment "Prefix check.";

command batcalc.endsWith( s:bat[:void,:str], suffix:bat[:void,:str] ) :bat[:void,:bit]
address STRbatSuffix
comment "Suffix check.";
command batcalc.endsWith( s:bat[:void,:str], suffix:str ) :bat[:void,:bit]
address STRbatSuffixcst
comment "Suffix check.";

command batcalc.search( s:bat[:void,:str], c:bat[:void,:str] ) :bat[:void,:int]
address STRbatstrSearch
comment "Search for a substring. Returns position, -1 if not found.";
command batcalc.search( s:bat[:void,:str], c:str ) :bat[:void,:int]
address STRbatstrSearchcst
comment "Search for a substring. Returns position, -1 if not found.";

command batcalc.r_search( s:bat[:void,:str], c:bat[:void,:str] ) :bat[:void,:int]
address STRbatRstrSearch
comment "Reverse search for a substring. Returns position, -1 if not found.";
command batcalc.r_search( s:bat[:void,:str], c:str ) :bat[:void,:int]
address STRbatRstrSearchcst
comment "Reverse search for a substring. Returns position, -1 if not found.";

command batcalc.+( l:bat[:void,:str], r:bat[:void,:str]) :bat[:void,:str]
address STRbatConcat
comment "Concatenate two strings.";
command batcalc.+( l:bat[:void,:str], r:str) :bat[:void,:str]
address STRbatConcatcst
comment "Concatenate a string to a bat of strings.";
command batcalc.+( l:str, r:bat[:void,:str]) :bat[:void,:str]
address STRcstConcatbat
comment "Concatenate two strings.";

command batcalc.string(b:bat[:void,:str],offset:bat[:void,:int]) :bat[:void,:str]
address STRbatTail
comment "Return the tail s[offset..n] of a string s[0..n].";
command batcalc.string(b:bat[:void,:str],offset:int) :bat[:void,:str]
address STRbatTailcst
comment "Return the tail s[offset..n] of a string s[0..n].";

command batcalc.chrAt( s:bat[:void,:str], index:bat[:void,:int]) :bat[:void,:chr]
address STRbatChrAt
comment "String array lookup operation.";
command batcalc.chrAt( s:bat[:void,:str], index:int) :bat[:void,:chr]
address STRbatChrAtcst
comment "String array lookup operation.";

command batcalc.substring( s:bat[:void,:str], start:bat[:void,:int], 
	index:bat[:void,:int]) :bat[:void,:str]
address STRbatsubstring
comment "Substring extraction using [start,start+length]";

command batcalc.substring( s:bat[:void,:str], start:int, index:int)
	:bat[:void,:str]
address STRbatsubstringcst
comment "Substring extraction using [start,start+length]";

command batcalc.unicodeAt(s:bat[:void,:str], index:bat[:void,:int]) :bat[:void,:int]
address STRbatWChrAt
comment "get a unicode character (as an int) from a string position.";
command batcalc.unicodeAt(s:bat[:void,:str], index:int) :bat[:void,:int]
address STRbatWChrAtcst
comment "get a unicode character (as an int) from a string position.";

command batcalc.substitute(s:bat[:void,:str],src:str,dst:str,rep:bit):bat[:void,:str]
address STRbatSubstitutecst
comment "Substitute first occurrence of 'src' by
	'dst'.  Iff repeated = true this is
	repeated while 'src' can be found in the
	result string. In order to prevent
	recursion and result strings of unlimited
	size, repeating is only done iff src is
	not a substring of dst.";

command batcalc.like(s:bat[:any_1,:str],pat:str,esc:str):bat[:any_1,:void]
address STRbatlike;
command batcalc.like(s:bat[:void,:str],pat:str,esc:str):bat[:oid,:void]
address STRbatlike
comment "Perform SQL like operation against a string bat";
command batcalc.like(s:bat[:any_1,:str],pat:str):bat[:any_1,:void]
address STRbatlike2;
command batcalc.like(s:bat[:void,:str],pat:str):bat[:oid,:void]
address STRbatlike2
comment "Perform SQL like operation against a string bat";
@+ Implementation
@c
#include <gdk.h>
#include "ctype.h"
#include <string.h>
#include "mal_exception.h"
#include "str.h"
#ifdef HAVE_REGEX_H
#include <regex.h>
#endif

#ifdef HAVE_LANGINFO_H
#include <langinfo.h>
#endif
#ifdef HAVE_ICONV_H
#include <iconv.h>
#endif

#ifdef WIN32
#ifndef LIBBATSTR
#define batstr_export extern __declspec(dllimport)
#else
#define batstr_export extern __declspec(dllexport)
#endif
#else
#define batstr_export extern
#endif

#define prepareOperand(X,Y,Z) \
	if( (X= BATdescriptor(*Y)) == NULL ) \
		return throwMessage("batstr." Z, "Cannot access descriptor");
#define prepareOperand2(X,Y,A,B,Z) \
	if( (X= BATdescriptor(*Y)) == NULL ) \
		return throwMessage("batstr." Z, "Cannot access descriptor"); \
	if( (A= BATdescriptor(*B)) == NULL ){\
		BBPreleaseref(X->batCacheid); \
		return throwMessage("batstr."Z, "Cannot access descriptor"); \
	}
#define prepareResult(X,Y,T,Z) \
	X= BATnew(Y->htype,T,BATcount(Y)); \
	if( Y->htype== TYPE_void) \
		BATseqbase(X, Y->hseqbase); \
	if( X == NULL){ \
		BBPreleaseref(Y->batCacheid); \
		return throwMessage("batstr." Z, "no space available "); \
	} \
	X->hsorted=Y->hsorted; \
	X->tsorted=0; 
#define prepareResult2(X,Y,A,T,Z) \
	X= BATnew(Y->htype,T,BATcount(Y)); \
	if( Y->htype== TYPE_void) \
		BATseqbase(X, Y->hseqbase); \
	if( X == NULL){ \
		BBPreleaseref(Y->batCacheid); \
		BBPreleaseref(A->batCacheid); \
		return throwMessage("batstr." Z, "no space available "); \
	} \
	X->hsorted=Y->hsorted; \
	X->tsorted=0; 
#define finalizeResult(X,Y,Z) \
	if (!((Y)->batDirty&2)) (Y) = BATsetaccess((Y), BAT_READ); \
	*X = (Y)->batCacheid; \
	BBPkeepref(*(X));\
	BBPreleaseref(Z->batCacheid);

batstr_export str STRbatsubstringcst(int *ret, int *bid, int *start, int *length);
batstr_export str STRbatsubstring(int *ret, int *bid, int *start, int *length);

@= BATint
batstr_export str STRbat@1(int *ret, int *l);
str STRbat@1(int *ret, int *l)
{   BAT *bn, *b;
	BUN p,q;
	int xx;
	@3 x;
	int y, *yp = &y;

	prepareOperand(b,l,"@1");
	prepareResult(bn,b,TYPE_int,"@1");

	BATloopFast(b, p, q, xx) {
		ptr h = BUNhead(b,p);
		x= (@3) BUNtail(b,p);
		if(x== 0 || *x == 0 || strcmp(x,@3_nil)== 0)
			y= int_nil;
		else @2(yp,x);
		bunfastins(bn, h, yp);
	}
	finalizeResult(ret,bn,b);
	return MAL_SUCCEED;
bunins_failed:
	BBPreleaseref(b->batCacheid);
	BBPunfix(bn->batCacheid);
	return throwMessage("batstr.@1", "bunins failed");
}

@c
@:BATint(Length,strLength,str)@
@:BATint(Bytes,strBytes,str)@

@= BATstr
batstr_export str STRbat@1(int *ret, int *l);
str STRbat@1(int *ret, int *l)
{   BAT *bn, *b;
	BUN p,q;
	int xx;
	@3 x;
	@4 y, *yp = &y;

	prepareOperand(b,l,"@1");
	prepareResult(bn,b,TYPE_@4,"@1");

	BATloopFast(b, p, q, xx) {
		ptr h = BUNhead(b,p);
		x= (@3) BUNtail(b,p);
		if(x== 0 || *x == 0 || strcmp(x,@3_nil)== 0)
			y = (@4)@4_nil;
		else @2(yp,x);
		bunfastins(bn, h, *yp);
	}
	finalizeResult(ret,bn,b);
	return MAL_SUCCEED;
bunins_failed:
	BBPreleaseref(b->batCacheid);
	BBPunfix(bn->batCacheid);
	return throwMessage("batstr.@1", "bunins failed");
}
@c
@:BATstr(Lower,strLower,str,str)@
@:BATstr(Upper,strUpper,str,str)@
@:BATstr(Strip,strStrip,str,str)@
@:BATstr(Ltrim,strLtrim,str,str)@
@:BATstr(Rtrim,strRtrim,str,str)@

@-
@c
@= STRbatcstcmp
batstr_export str STRbat@2Cst(int *ret, int *l, str *cst);
str
STRbat@2Cst(int *ret, int *l, str *cst)
{
	BAT *bn, *b;
	BUN p, q;
	int xx;
	str x;
	bit y;

	prepareOperand(b, l, "@1");
	prepareResult(bn, b, TYPE_bit, "@1");
	BATloopFast(b, p, q, xx) {
		ptr h = BUNhead(b, p);

		x = (str) BUNtail(b, p);
		if (x == 0 || *x == 0 || strcmp(x, str_nil) == 0)
			y = bit_nil;
		else
			y = strcmp(x, *cst) @1 0;
		bunfastins(bn, h, &y);
	}
	bn->tsorted = (BATtordered(b)&1)?@3:0;
	finalizeResult(ret, bn, b);
	return MAL_SUCCEED;
bunins_failed:
	BBPreleaseref(b->batCacheid);
	BBPunfix(bn->batCacheid);
	return throwMessage("batstr.@1", "bunins failed");
}
@c
@:STRbatcstcmp(==,Equal,GDK_SORTED_REV)@
@:STRbatcstcmp(!=,NotEqual,GDK_SORTED)@

@-
A general assumption in all cases is the bats are synchronized on their
head column. This is not checked and may be mis-used to deploy the
implementation for shifted window arithmetic as well.
@= chkSize
	if( BATcount(@1) != BATcount(@2) )
	return throwMessage("batcalc.@3", "requires bats of identical size");
@c
@= STRbatcmp
batstr_export str STRbat@2(int *ret, int *l, int *r);
str
STRbat@2(int *ret, int *l, int *r)
{
	BAT *bn, *left, *right;
	BUN o, p, q;
	int xx, yy;

	prepareOperand2(left, l, right, r, "@1");
	@:chkSize(left,right,CMDcompare@1)@
	prepareResult2(bn, left, right, TYPE_bit, "@1");

	o = BUNfirst(left);
	p = BUNfirst(right);
	q = BUNlast(right);
	xx = BUNsize(left);
	yy = BUNsize(right);
	while (p < q) {
		bit y = TRUE;
		ptr h = BUNhead(left, o);
		ptr tl = BUNtail(left, o);
		ptr tr = BUNtail(right, p);

		if (tl == 0 || tr == 0 || !(strcmp(tl, tr) @1 0))
			y = FALSE;
		bunfastins(bn, h, &y);
		o += xx;
		p += yy;
	}
	BBPreleaseref(right->batCacheid);
	bn->tsorted = (BATtordered(left)&BATtordered(right)&1)?@3:0;
	finalizeResult(ret, bn, left);
	return MAL_SUCCEED;

bunins_failed:
	BBPreleaseref(left->batCacheid);
	BBPreleaseref(right->batCacheid);
	BBPunfix(*ret);
	return throwMessage("batstr.@1", "bunins failed");
}
@c
@:STRbatcmp(==,Equal,GDK_SORTED_REV)@
@:STRbatcmp(!=,NotEqual,GDK_SORTED)@

@= binarySTR
batstr_export str STRbat@1(int *ret, int *l, int *r);
str STRbat@1(int *ret, int *l, int *r)
{   BAT *bn, *left, *right;
	BUN o,p,q;
	int xx,yy;
	@2 v, *vp= &v;

	prepareOperand2(left,l,right,r,@5);
	@:chkSize(left,right,CMDcompare@1)@
	prepareResult2(bn,left,right,TYPE_@2,@5);

	o = BUNfirst(left);
	p = BUNfirst(right);
	q = BUNlast(right);
	xx = BUNsize(left);
	yy = BUNsize(right);
	while(p<q) {
		ptr h = BUNhead(left,o);
		ptr tl = BUNtail(left,o);
		ptr tr = BUNtail(right,p);
		@4(vp, tl, tr);
		bunfastins(bn, h, vp);
		o += xx;
		p += yy;
	}
	BBPreleaseref(right->batCacheid);
	finalizeResult(ret,bn,left);
	return MAL_SUCCEED;

bunins_failed:
	BBPreleaseref(left->batCacheid);
	BBPreleaseref(right->batCacheid);
	BBPunfix(*ret);
	return throwMessage("batstr." @5, "bunins failed");
}

batstr_export str STRbat@1cst(int *ret, int *l, @3 *cst);
str STRbat@1cst(int *ret, int *l, @3 *cst)
{   BAT *bn, *left;
	BUN p,q;
	int xx;
	@2 v, *vp= &v;

	prepareOperand(left,l,@5);
	prepareResult(bn,left,TYPE_@2,@5);

	p = BUNfirst(left);
	q = BUNlast(left);
	xx = BUNsize(left);
	while(p<q) {
		ptr h = BUNhead(left,p);
		ptr tl = BUNtail(left,p);
		@4(vp, tl, cst);
		bunfastins(bn, h, vp);
		p += xx;
	}
	finalizeResult(ret,bn,left);
	return MAL_SUCCEED;

bunins_failed:
	BBPreleaseref(left->batCacheid);
	BBPreleaseref(*ret);
	return throwMessage("batstr"@5, "bunins failed");
}
@= binarySTRstr
batstr_export str STRbat@1(int *ret, int *l, int *r);
str STRbat@1(int *ret, int *l, int *r)
{   BAT *bn, *left, *right;
	BUN o,p,q;
	int xx,yy;
	@2 v, *vp= &v;

	prepareOperand2(left,l,right,r,@5);
	@:chkSize(left,right,CMDcompare@1)@
	prepareResult2(bn,left,right,TYPE_@2,@5);

	o = BUNfirst(left);
	p = BUNfirst(right);
	q = BUNlast(right);
	xx = BUNsize(left);
	yy = BUNsize(right);
	while(p<q) {
		ptr h = BUNhead(left,o);
		str tl = (str) BUNtail(left,o);
		str tr = (str) BUNtail(right,p);
		@4(vp, &tl, &tr);
		bunfastins(bn, h, @6);
		o += xx;
		p += yy;
	}
	BBPreleaseref(right->batCacheid);
	finalizeResult(ret,bn,left);
	return MAL_SUCCEED;

bunins_failed:
	BBPreleaseref(left->batCacheid);
	BBPreleaseref(right->batCacheid);
	BBPunfix(*ret);
	return throwMessage("batstr." @5, "bunins failed");
}

batstr_export str STRbat@1cst(int *ret, int *l, @3 *cst);
str STRbat@1cst(int *ret, int *l, @3 *cst)
{   BAT *bn, *left;
	BUN p,q;
	int xx;
	@2 v, *vp= &v;

	prepareOperand(left,l,@5);
	prepareResult(bn,left,TYPE_@2,@5);

	p = BUNfirst(left);
	q = BUNlast(left);
	xx = BUNsize(left);
	while(p<q) {
		ptr h = BUNhead(left,p);
		str tl = (str) BUNtail(left,p);
		@4(vp, &tl, cst);
		bunfastins(bn, h, @6);
		p += xx;
	}
	finalizeResult(ret,bn,left);
	return MAL_SUCCEED;

bunins_failed:
	BBPreleaseref(left->batCacheid);
	BBPunfix(*ret);
	return throwMessage("batstr"@5, "bunins failed");
}

batstr_export str STRcst@1bat(int *ret, @3 *cst, int *r);
str STRcst@1bat(int *ret, @3 *cst, int *r)
{   BAT *bn, *right;
	BUN p,q;
	int xx;
	@2 v, *vp= &v;

	prepareOperand(right,r,@5);
	prepareResult(bn,right,TYPE_@2,@5);

	p = BUNfirst(right);
	q = BUNlast(right);
	xx = BUNsize(right);
	while(p<q) {
		ptr h = BUNhead(right,p);
		str tr = (str) BUNtail(right,p);
		@4(vp, cst, &tr);
		bunfastins(bn, h, @6);
		p += xx;
	}
	finalizeResult(ret,bn,right);
	return MAL_SUCCEED;

bunins_failed:
	BBPreleaseref(right->batCacheid);
	BBPunfix(*ret);
	return throwMessage("batstr"@5, "bunins failed");
}
@c
@:binarySTRstr(Prefix,bit,str,STRPrefix,"prefix",vp)@
@:binarySTRstr(Suffix,bit,str,STRSuffix,"suffix",vp)@
@:binarySTRstr(strSearch,int,str,STRstrSearch,"search",vp)@
@:binarySTRstr(RstrSearch,int,str,STRReverseStrSearch,"r_search",vp)@
@:binarySTRstr(Concat,str,str,STRConcat,"+",v)@
@:binarySTR(Tail,str,int,strTail,"tail")@
@:binarySTR(WChrAt,int,int,strWChrAt,"chrAt")@
@:binarySTR(ChrAt,chr,int,strChrAt,"chrAt")@

batstr_export str STRbatSubstitutecst(int *ret, int *l, str *arg2, str *arg3, bit *rep);
str
STRbatSubstitutecst(int *ret, int *l, str *arg2, str *arg3, bit *rep)
{
	BAT *bn, *b;
	BUN p, q;
	int xx;
	str x, *xp = &x;
	str y, *yp = &y;

	prepareOperand(b, l, "subString");
	prepareResult(bn, b, TYPE_int, "subString");

	BATloopFast(b, p, q, xx) {
		ptr h = BUNhead(b, p);

		x = (str) BUNtail(b, p);
		if (x == 0 || *x == 0 || strcmp(x, str_nil) == 0)
			y = (str)str_nil;
		else
			STRSubstitute(yp, xp, arg2, arg3, rep);
		bunfastins(bn, h, yp);
	}
	finalizeResult(ret, bn, b);
	return MAL_SUCCEED;
bunins_failed:
	BBPreleaseref(b->batCacheid);
	BBPreleaseref(bn->batCacheid);
	return throwMessage("batstr.subString", "bunins failed");
}

batstr_export str STRbatmatchCst(int *ret, int *bid, str *pat);
str
STRbatmatchCst(int *ret, int *bid, str *pat)
{
#ifdef HAVE_REGEX_H
	regex_t prg;
	BAT *b, *bn;
	int tpe, xx;
	BUN p, q;
	bit bnil = bit_nil;
	ptr nilptr;
	int error = regcomp(&prg, *pat, REG_EXTENDED | REG_NOSUB);

	if (error < 0)
		return throwMessage("str.match", "Compilation of regular expression failed");

	prepareOperand(b, bid, "match");
	bn = BATnew(BAThtype(b), TYPE_bit, BATcount(b));

	tpe = BATttype(b);
	nilptr = ATOMnilptr(tpe);
	BATloopFast(b, p, q, xx) {
		ptr h = BUNhead(b, p);
		ptr t = BUNtail(b, p);

		if (ATOMcmp(tpe, t, nilptr) == 0) {
			bunfastins(bn, h, &bnil);
		} else {
			bit match = regexec(&prg, t, 0, 0, 0) == 0;

			bunfastins(bn, h, &match);
		}
	}
bunins_failed:
	bn->hsorted = b->hsorted;
	bn->tsorted = 0;
	if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ); 
	*ret = bn->batCacheid;
	BBPkeepref(bn->batCacheid);
	BBPreleaseref(b->batCacheid);
	return MAL_SUCCEED;
#else
	(void) ret;
	(void) bid;
	(void) pat;
	return throwMessage("str.match", "No implementation available");
#endif
}
@-
The pattern matching routine is optimized for SQL pattern structures.
@c
#define percent "\001"
#define underscore "\002"
batstr_export str STRbatlike(int *ret, int *bid, str *pat, str *esc);
str
STRbatlike(int *ret, int *bid, str *pat, str *esc){
	BAT *b,*bn;
	BUN p, q;
	int xx;
	oid o= oid_nil;
	if( (b= BATdescriptor(*bid)) == NULL)
		return throwMessage("batstr.like","Can not find BAT");
	bn= BATnew(BAThtype(b),TYPE_void, BATcount(b)/10+5);
	BATseqbase(BATmirror(b),o);
	bn->hsorted = b->hsorted;
	bn->tsorted = b->tsorted;

	BATloopFast(b, p, q, xx) {
		ptr h = BUNhead(b, p);
		ptr t = BUNtail(b, p);

		if ( STRlike((str) t, *pat, *esc) )
			bunfastins(bn, h,&o);
	}
bunins_failed:
	if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ); 
	*ret = bn->batCacheid;
	BBPkeepref(bn->batCacheid);
	BBPreleaseref(b->batCacheid);
	return MAL_SUCCEED;
}
batstr_export str STRbatlike2(int *ret, int *bid, str *pat);
str
STRbatlike2(int *ret, int *bid, str *pat){
	str esc="";
	return STRbatlike(ret,bid,pat,&esc);
}
@-
The substring functions require slightly different arguments
@c
str
STRbatsubstringcst(int *ret, int *bid, int *start, int *length){
	BAT *b,*bn;
	BUN p, q;
	int xx;
	str res;
	oid o=oid_nil;

	if( (b= BATdescriptor(*bid)) == NULL)
		return throwMessage("batstr.like","Can not find BAT");
	bn= BATnew(BAThtype(b),TYPE_void, BATcount(b)/10+5);
	BATseqbase(BATmirror(b),o);
	bn->hsorted = b->hsorted;
	bn->tsorted = b->tsorted;

	BATloopFast(b, p, q, xx) {
		ptr h = BUNhead(b, p);
		str t =  (str) BUNtail(b, p);

		if ( STRsubstring(&res, &t, start, length) )
			bunfastins(bn, h, (ptr)&res);
	}
bunins_failed:
	if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ); 
	*ret = bn->batCacheid;
	BBPkeepref(bn->batCacheid);
	BBPreleaseref(b->batCacheid);
	return MAL_SUCCEED;
}
batstr_export str STRbatsubstring(int *ret, int *l, int *r, int *t);
str STRbatsubstring(int *ret, int *l, int *r, int *t)
{   BAT *bn, *left, *start, *length;
	BUN os,ol,ps,qs;
	int xx,yy,zz;
	str v, *vp= &v;

	if( (left= BATdescriptor(*l)) == NULL ) 
		return throwMessage("batstr.substring" , "Cannot access descriptor"); 
	if( (start= BATdescriptor(*r)) == NULL ){
		BBPreleaseref(left->batCacheid); 
		return throwMessage("batstr.substring", "Cannot access descriptor");
	}
	if( (length= BATdescriptor(*t)) == NULL ){
		BBPreleaseref(left->batCacheid); 
		BBPreleaseref(start->batCacheid); 
		return throwMessage("batstr.substring", "Cannot access descriptor");
	}
	@:chkSize(left,start,CMDbatsubstring)@
	@:chkSize(left,length,CMDbatsubstring)@
	bn= BATnew(left->htype,TYPE_str,BATcount(left)); 
	if( left->htype== TYPE_void)
		BATseqbase(bn, left->hseqbase); 
	if( bn == NULL){
		BBPreleaseref(left->batCacheid);
		BBPreleaseref(start->batCacheid);
		BBPreleaseref(length->batCacheid);
		return throwMessage("batstr.substring", "no space available ");
	}
	bn->hsorted= left->hsorted; 
	bn->tsorted=0; 

	ps = BUNfirst(left);
	qs = BUNlast(left);
	os = BUNfirst(start);
	ol = BUNfirst(length);
	xx = BUNsize(left);
	yy = BUNsize(start);
	zz = BUNsize(length);
	while(ps<qs) {
		ptr h = BUNhead(left,ol);
		str tl = (str) BUNtail(left,ps);
		int *t1 = (int *) BUNtail(start,os);
		int *t2 = (int *) BUNtail(length,ol);
		STRsubstring(vp, &tl, t1, t2);
		bunfastins(bn, h, vp);
		ps += xx;
		os += yy;
		ol += zz;
	}
	BBPreleaseref(start->batCacheid);
	BBPreleaseref(length->batCacheid);
	finalizeResult(ret,bn,left);
	return MAL_SUCCEED;

bunins_failed:
	BBPreleaseref(left->batCacheid);
	BBPreleaseref(start->batCacheid);
	BBPreleaseref(length->batCacheid);
	BBPunfix(*ret);
	return throwMessage("batstr.substring" , "bunins failed");
}
@}
