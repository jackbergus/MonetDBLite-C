@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2005 CWI.
@' All Rights Reserved.

@f batstr
@a M.L. Kersten
@* String multiplexes
[TODO: property propagations]
The collection of routines provided here are map operations
for the atom string primitives. 

In line with the batcalc module, we assume that
if two bat operands are provided that they are already
aligned on the head. Moreover, the head of the BATs
are limited to :void, which can be cheaply realized using
the GRPsplit operation.
@mal
module batstr;
command str(b:bat[:void,:str]):bat[:void,:str]
address STRbattostr
comment "Identity mapping for string bats";

command length( s:bat[:void,:str] ) :bat[:void,:int]
address STRbatLength
comment "Return the length of a string.";

command bytes( s:bat[:void,:str] ) :bat[:void,:int]
address STRbatBytes
comment "Return the string length in bytes.";

command match(b:bat[:void,:str], pat:str):bat[:void,:bit]
address STRbatmatchCst
comment "POSIX pattern matching against a string BAT";

command ==( l:bat[:void,:str], r:bat[:void,:str]) :bat[:void,:bit]
address STRbatEqual
comment "Equate a bat of strings against each other";
command ==( l:bat[:void,:str], r:str) :bat[:void,:bit]
address STRbatEqualCst
comment "Equate a bat of strings against a singleton";

command toLower( s:bat[:void,:str] ) :bat[:void,:str]
address STRbatLower
comment "Convert a string to lower case.";
command toUpper( s:bat[:void,:str] ) :bat[:void,:str]
address STRbatUpper
comment "Convert a string to upper case.";

command trim( s:bat[:void,:str] ) :bat[:void,:str]
address STRbatStrip
comment "Strip whitespaces around a string.";
command ltrim( s:bat[:void,:str] ) :bat[:void,:str]
address STRbatLtrim
comment "Strip whitespaces from start of a string.";
command rtrim( s:bat[:void,:str] ) :bat[:void,:str]
address STRbatRtrim
comment "Strip whitespaces from end of a string.";

command startsWith(s:bat[:void,:str],prefix:bat[:void,:str]):bat[:void,:bit]
address STRbatPrefix
comment "Prefix check.";
command startsWith(s:bat[:void,:str],prefix:str):bat[:void,:bit]
address STRbatPrefixcst
comment "Prefix check.";

command endsWith( s:bat[:void,:str], suffix:bat[:void,:str] ) :bat[:void,:bit]
address STRbatSuffix
comment "Suffix check.";
command endsWith( s:bat[:void,:str], suffix:str ) :bat[:void,:bit]
address STRbatSuffixcst
comment "Suffix check.";

command search( s:bat[:void,:str], c:bat[:void,:str] ) :bat[:void,:int]
address STRbatstrSearch
comment "Search for a substring. Returns position, -1 if not found.";
command search( s:bat[:void,:str], c:str ) :bat[:void,:int]
address STRbatstrSearchcst
comment "Search for a substring. Returns position, -1 if not found.";

command r_search( s:bat[:void,:str], c:bat[:void,:str] ) :bat[:void,:int]
address STRbatRstrSearch
comment "Reverse search for a substring. Returns position, -1 if not found.";
command r_search( s:bat[:void,:str], c:str ) :bat[:void,:int]
address STRbatRstrSearchcst
comment "Reverse search for a substring. Returns position, -1 if not found.";

command +( l:bat[:void,:str], r:bat[:void,:str]) :bat[:void,:str]
address STRbatConcat
comment "Concatenate two strings.";
command +( l:bat[:void,:str], r:str) :bat[:void,:str]
address STRbatConcatcst
comment "Concatenate a string to a bat of strings.";

command string(b:bat[:void,:str],offset:bat[:void,:int]) :bat[:void,:str]
address STRbatTail
comment "Return the tail s[offset..n] of a string s[0..n].";
command string(b:bat[:void,:str],offset:int) :bat[:void,:str]
address STRbatTailcst
comment "Return the tail s[offset..n] of a string s[0..n].";

command chrAt( s:bat[:void,:str], index:bat[:void,:int]) :bat[:void,:chr]
address STRbatChrAt
comment "String array lookup operation.";
command chrAt( s:bat[:void,:str], index:int) :bat[:void,:chr]
address STRbatChrAtcst
comment "String array lookup operation.";

command unicodeAt(s:bat[:void,:str], index:bat[:void,:int]) :bat[:void,:int]
address STRbatWChrAt
comment "get a unicode character (as an int) from a string position.";
command unicodeAt(s:bat[:void,:str], index:int) :bat[:void,:int]
address STRbatWChrAtcst
comment "get a unicode character (as an int) from a string position.";

command string(s:bat[:void,:str],offset:int,count:int):bat[:void,:str]
address STRbatSubStringcst
comment "Return substring s[offset..offset+count] of a string s[0..n]";

command substitute(s:bat[:void,:str],src:str,dst:str,rep:bit):bat[:void,:str]
address STRbatSubstitutecst
comment "Substitute first occurrence of 'src' by
	'dst'.  Iff repeated = true this is
	repeated while 'src' can be found in the
	result string. In order to prevent
	recursion and result strings of unlimited
	size, repeating is only done iff src is
	not a substring of dst.";

command like(s:bat[:any_1,:str],pat:str,esc:str):bat[:any_1,:void]
address STRbatlike
comment "Perform SQL like operation against a string bat";
command like(s:bat[:any_1,:str],pat:str):bat[:any_1,:void]
address STRbatlike2
comment "Perform SQL like operation against a string bat";
@+ Implementation
@c
#include <gdk.h>
#include "ctype.h"
#include <string.h>
#include "mal_exception.h"
#include "str.h"
#ifdef HAVE_REGEX_H
#include <regex.h>
#endif

#ifdef HAVE_LANGINFO_H
#include <langinfo.h>
#endif
#ifdef HAVE_ICONV_H
#include <iconv.h>
#endif

#define prepareOperand(X,Y,Z) \
	if( (X= BATdescriptor(*Y)) == NULL ) \
	    return throwMessage("batstr." Z, "Cannot access descriptor");
#define prepareOperand2(X,Y,A,B,Z) \
	if( (X= BATdescriptor(*Y)) == NULL ) \
	    return throwMessage("batstr." Z, "Cannot access descriptor"); \
	if( (A= BATdescriptor(*B)) == NULL ){\
		BBPunfix(X->batCacheid); \
	    return throwMessage("batstr."Z, "Cannot access descriptor"); \
	}
#define prepareResult(X,Y,T,Z) \
	X= BATnew(Y->htype,T,BATcount(Y)); \
	if( Y->htype== TYPE_void) \
		BATseqbase(X, Y->hseqbase); \
	Y->hsorted=X->hsorted; \
	if( X == NULL){ \
	    BBPunfix(Y->batCacheid); \
	    return throwMessage("batstr." Z, "no space available "); \
	}
#define prepareResult2(X,Y,A,T,Z) \
	X= BATnew(Y->htype,T,BATcount(Y)); \
	if( Y->htype== TYPE_void) \
		BATseqbase(X, Y->hseqbase); \
	Y->hsorted=X->hsorted; \
	if( X == NULL){ \
	    BBPunfix(Y->batCacheid); \
	    BBPunfix(A->batCacheid); \
	    return throwMessage("batstr." Z, "no space available "); \
	}
#define finalizeResult(X,Y,Z) \
	BBPincref(*X = Y->batCacheid,TRUE);\
	BBPunfix(*X);\
	BBPunfix(Z->batCacheid);
@= BATint
mal_export str STRbat@1(int *ret, int *l);
str STRbat@1(int *ret, int *l)
{   BAT *bn, *b;
	BUN p,q;
	int xx;
	@3 x;
	int y, *yp = &y;

	prepareOperand(b,l,"@1");
	prepareResult(bn,b,TYPE_int,"@1");

	BATloopFast(b, p, q, xx) {
	    ptr h = BUNhead(b,p);
	    x= (@3) BUNtail(b,p);
		if(x== 0 || *x == 0 || strcmp(x,@3_nil)== 0)
			y= int_nil;
		else @2(yp,x);
	    bunfastins(bn, h, yp);
	}
	finalizeResult(ret,bn,b);
	return MAL_SUCCEED;
bunins_failed:
	BBPunfix(b->batCacheid);
	BBPunfix(bn->batCacheid);
	return throwMessage("batstr.==", "bunins failed");
}

@c
@:BATint(Length,strLength,str)@
@:BATint(Bytes,strBytes,str)@

@= BATstr
mal_export str STRbat@1(int *ret, int *l);
str STRbat@1(int *ret, int *l)
{   BAT *bn, *b;
	BUN p,q;
	int xx;
	@3 x;
	@4 y, *yp = &y;

	prepareOperand(b,l,"@1");
	prepareResult(bn,b,TYPE_@4,"@1");

	BATloopFast(b, p, q, xx) {
	    ptr h = BUNhead(b,p);
	    x= (@3) BUNtail(b,p);
		if(x== 0 || *x == 0 || strcmp(x,@3_nil)== 0)
			y= @4_nil;
		else @2(yp,x);
	    bunfastins(bn, h, *yp);
	}
	finalizeResult(ret,bn,b);
	return MAL_SUCCEED;
bunins_failed:
	BBPunfix(b->batCacheid);
	BBPunfix(bn->batCacheid);
	return throwMessage("batstr.==", "bunins failed");
}
@c
@:BATstr(Lower,strLower,str,str)@
@:BATstr(Upper,strUpper,str,str)@
@:BATstr(Strip,strStrip,str,str)@
@:BATstr(Ltrim,strLtrim,str,str)@
@:BATstr(Rtrim,strRtrim,str,str)@

@-
@c
mal_export str STRbatEqualCst(int *ret, int *l, str *cst);
str
STRbatEqualCst(int *ret, int *l, str *cst)
{
	BAT *bn, *b;
	BUN p, q;
	int xx;
	str x;
	bit y;

	prepareOperand(b, l, "==");
	prepareResult(bn, b, TYPE_bit, "==");
	BATloopFast(b, p, q, xx) {
		ptr h = BUNhead(b, p);

		x = (str) BUNtail(b, p);
		if (x == 0 || *x == 0 || strcmp(x, str_nil) == 0)
			y = bit_nil;
		else
			y = strcmp(x, *cst) == 0;
		bunfastins(bn, h, &y);
	}
	finalizeResult(ret, bn, b);
	return MAL_SUCCEED;
      bunins_failed:
	BBPunfix(b->batCacheid);
	BBPunfix(bn->batCacheid);
	return throwMessage("batstr.==", "bunins failed");
}

@-
A general assumption in all cases is the bats are synchronized on their
head column. This is not checked and may be mis-used to deploy the
implementation for shifted window arithmetic as well.
@= chkSize
	if( BATcount(@1) != BATcount(@2) )
	return throwMessage("batcalc.@3", "requires bats of identical size");
@c
mal_export str STRbatEqual(int *ret, int *l, int *r);
str
STRbatEqual(int *ret, int *l, int *r)
{
	BAT *bn, *left, *right;
	BUN o, p, q;
	int xx, yy;

	prepareOperand2(left, l, right, r, "==");
	@:chkSize(left,right,CMDcompare@1)@
	prepareResult2(bn, left, right, TYPE_bit, "==");

	o = BUNfirst(left);
	p = BUNfirst(right);
	q = BUNlast(right);
	xx = BUNsize(left);
	yy = BUNsize(right);
	while (p < q) {
		bit y = TRUE;
		ptr h = BUNhead(left, o);
		ptr tl = BUNtail(left, o);
		ptr tr = BUNtail(right, p);

		if (tl == 0 || tr == 0 || strcmp(tl, tr) != 0)
			y = FALSE;
		bunfastins(bn, h, &y);
		o += xx;
		p += yy;
	}
	BBPunfix(right->batCacheid);
	finalizeResult(ret, bn, left);
	return MAL_SUCCEED;

      bunins_failed:
	BBPunfix(left->batCacheid);
	BBPunfix(right->batCacheid);
	BBPunfix(*ret);
	return throwMessage("batstr.==", "bunins failed");
}

@= binarySTR
mal_export str STRbat@1(int *ret, int *l, int *r);
str STRbat@1(int *ret, int *l, int *r)
{   BAT *bn, *left, *right;
	BUN o,p,q;
	int xx,yy;
	@2 v, *vp= &v;

	prepareOperand2(left,l,right,r,@5);
	@:chkSize(left,right,CMDcompare@1)@
	prepareResult2(bn,left,right,TYPE_@2,@5);

	o = BUNfirst(left);
	p = BUNfirst(right);
	q = BUNlast(right);
	xx = BUNsize(left);
	yy = BUNsize(right);
	while(p<q) {
	    ptr h = BUNhead(left,o);
	    ptr tl = BUNtail(left,o);
	    ptr tr = BUNtail(right,p);
		@4(vp, tl, tr);
		bunfastins(bn, h, vp);
		o += xx;
		p += yy;
	}
	BBPunfix(right->batCacheid);
	finalizeResult(ret,bn,left);
	return MAL_SUCCEED;

bunins_failed:
	BBPunfix(left->batCacheid);
	BBPunfix(right->batCacheid);
	BBPunfix(*ret);
	return throwMessage("batstr." @5, "bunins failed");
}

mal_export str STRbat@1cst(int *ret, int *l, @3 *cst);
str STRbat@1cst(int *ret, int *l, @3 *cst)
{   BAT *bn, *left;
	BUN p,q;
	int xx;
	@2 v, *vp= &v;

	prepareOperand(left,l,@5);
	prepareResult(bn,left,TYPE_@2,@5);

	p = BUNfirst(left);
	q = BUNlast(left);
	xx = BUNsize(left);
	while(p<q) {
	    ptr h = BUNhead(left,p);
	    ptr tl = BUNtail(left,p);
		@4(vp, tl, cst);
		bunfastins(bn, h, vp);
		p += xx;
	}
	finalizeResult(ret,bn,left);
	return MAL_SUCCEED;

bunins_failed:
	BBPunfix(left->batCacheid);
	BBPunfix(*ret);
	return throwMessage("batstr"@5, "bunins failed");
}
@= binarySTRstr
mal_export str STRbat@1(int *ret, int *l, int *r);
str STRbat@1(int *ret, int *l, int *r)
{   BAT *bn, *left, *right;
	BUN o,p,q;
	int xx,yy;
	@2 v, *vp= &v;

	prepareOperand2(left,l,right,r,@5);
	@:chkSize(left,right,CMDcompare@1)@
	prepareResult2(bn,left,right,TYPE_@2,@5);

	o = BUNfirst(left);
	p = BUNfirst(right);
	q = BUNlast(right);
	xx = BUNsize(left);
	yy = BUNsize(right);
	while(p<q) {
	    ptr h = BUNhead(left,o);
	    str tl = (str) BUNtail(left,o);
	    str tr = (str) BUNtail(right,p);
		@4(vp, &tl, &tr);
		bunfastins(bn, h, @6);
		o += xx;
		p += yy;
	}
	BBPunfix(right->batCacheid);
	finalizeResult(ret,bn,left);
	return MAL_SUCCEED;

bunins_failed:
	BBPunfix(left->batCacheid);
	BBPunfix(right->batCacheid);
	BBPunfix(*ret);
	return throwMessage("batstr." @5, "bunins failed");
}

mal_export str STRbat@1cst(int *ret, int *l, @3 *cst);
str STRbat@1cst(int *ret, int *l, @3 *cst)
{   BAT *bn, *left;
	BUN p,q;
	int xx;
	@2 v, *vp= &v;

	prepareOperand(left,l,@5);
	prepareResult(bn,left,TYPE_@2,@5);

	p = BUNfirst(left);
	q = BUNlast(left);
	xx = BUNsize(left);
	while(p<q) {
	    ptr h = BUNhead(left,p);
	    str tl = (str) BUNtail(left,p);
		@4(vp, &tl, cst);
		bunfastins(bn, h, @6);
		p += xx;
	}
	finalizeResult(ret,bn,left);
	return MAL_SUCCEED;

bunins_failed:
	BBPunfix(left->batCacheid);
	BBPunfix(*ret);
	return throwMessage("batstr"@5, "bunins failed");
}
@c
@:binarySTRstr(Prefix,bit,str,STRPrefix,"prefix",vp)@
@:binarySTRstr(Suffix,bit,str,STRSuffix,"suffix",vp)@
@:binarySTRstr(strSearch,int,str,STRstrSearch,"search",vp)@
@:binarySTRstr(RstrSearch,int,str,STRReverseStrSearch,"r_search",vp)@
@:binarySTRstr(Concat,str,str,STRConcat,"+",v)@
@:binarySTR(Tail,str,int,strTail,"tail")@
@:binarySTR(WChrAt,int,int,strWChrAt,"chrAt")@
@:binarySTR(ChrAt,chr,int,strChrAt,"chrAt")@

mal_export str STRbattostr(int *ret, int *bid);
str
STRbattostr(int *ret, int *bid)
{
	BBPincref(*ret = *bid, TRUE);
	return MAL_SUCCEED;
}

mal_export str STRbatSubStringcst(int *ret, int *l, int *offset, int *length);
str
STRbatSubStringcst(int *ret, int *l, int *offset, int *length)
{
	BAT *bn, *b;
	BUN p, q;
	int xx;
	str x, *xp = &x;
	str y, *yp = &y;

	prepareOperand(b, l, "subString");
	prepareResult(bn, b, TYPE_int, "subString");

	BATloopFast(b, p, q, xx) {
		ptr h = BUNhead(b, p);

		x = (str) BUNtail(b, p);
		if (x == 0 || *x == 0 || strcmp(x, str_nil) == 0)
			y = str_nil;
		else
			STRSubString(yp, xp, offset, length);
		bunfastins(bn, h, yp);
	}
	finalizeResult(ret, bn, b);
	return MAL_SUCCEED;
      bunins_failed:
	BBPunfix(b->batCacheid);
	BBPunfix(bn->batCacheid);
	return throwMessage("batstr.subString", "bunins failed");
}

mal_export str STRbatSubstitutecst(int *ret, int *l, str *arg2, str *arg3, bit *rep);
str
STRbatSubstitutecst(int *ret, int *l, str *arg2, str *arg3, bit *rep)
{
	BAT *bn, *b;
	BUN p, q;
	int xx;
	str x, *xp = &x;
	str y, *yp = &y;

	prepareOperand(b, l, "subString");
	prepareResult(bn, b, TYPE_int, "subString");

	BATloopFast(b, p, q, xx) {
		ptr h = BUNhead(b, p);

		x = (str) BUNtail(b, p);
		if (x == 0 || *x == 0 || strcmp(x, str_nil) == 0)
			y = str_nil;
		else
			STRSubstitute(yp, xp, arg2, arg3, rep);
		bunfastins(bn, h, yp);
	}
	finalizeResult(ret, bn, b);
	return MAL_SUCCEED;
      bunins_failed:
	BBPunfix(b->batCacheid);
	BBPunfix(bn->batCacheid);
	return throwMessage("batstr.subString", "bunins failed");
}

mal_export str STRbatmatchCst(int *ret, int *bid, str *pat);
str
STRbatmatchCst(int *ret, int *bid, str *pat)
{
#ifdef HAVE_REGEX_H
	regex_t prg;
	BAT *b, *bn;
	int tpe, xx;
	BUN p, q;
	ptr nilptr;
	int error = regcomp(&prg, *pat, REG_EXTENDED | REG_NOSUB);

	if (error < 0)
		return throwMessage("str.match", "Compilation of regular expression failed");

	prepareOperand(b, bid, "match");
	bn = BATnew(BAThtype(b), TYPE_bit, BATcount(b));

	tpe = BATttype(b);
	nilptr = ATOMnilptr(tpe);
	BATloopFast(b, p, q, xx) {
		ptr h = BUNhead(b, p);
		ptr t = BUNtail(b, p);

		if (ATOMcmp(tpe, t, nilptr) == 0) {
			bunfastins(bn, h, t);
		} else {
			bit match = regexec(&prg, t, 0, 0, 0) == 0;

			bunfastins(bn, h, &match);
		}
	}
bunins_failed:
	BBPincref(*ret = bn->batCacheid, TRUE);
	BBPunfix(bn->batCacheid);
	BBPunfix(b->batCacheid);
	return MAL_SUCCEED;
#else
	(void) ret;
	(void) bid;
	(void) pat;
	return throwMessage("str.match", "No implementation available");
#endif
}
@-
The pattern matching routine is optimized for SQL pattern structures.
@c
#define percent "\001"
#define underscore "\002"
str
STRbatlike(int *ret, int *bid, str *pat, str *esc){
	BAT *b,*bn;
	BUN p, q;
	int xx;
	oid o= oid_nil;
	if( (b= BATdescriptor(*bid)) == NULL)
		return throwMessage("batstr.like","Can not find BAT");
	bn= BATnew(BAThtype(b),TYPE_void, BATcount(b)/10+5);
	BATseqbase(BATmirror(b),o);

	BATloopFast(b, p, q, xx) {
		ptr h = BUNhead(b, p);
		ptr t = BUNtail(b, p);

		if ( STRlike((str) t, *pat, *esc) )
			bunfastins(bn, h,&o);
	}
bunins_failed:
	BBPincref(*ret = bn->batCacheid, TRUE);
	BBPunfix(bn->batCacheid);
	BBPunfix(b->batCacheid);
	return MAL_SUCCEED;
}
str
STRbatlike2(int *ret, int *bid, str *pat){
	str esc="";
	return STRbatlike(ret,bid,pat,&esc);
}

@}
