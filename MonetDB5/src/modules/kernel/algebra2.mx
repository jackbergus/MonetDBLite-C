@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2007 CWI.
@' All Rights Reserved.

@f algebra2
@a Arjen P. de Vries, S. Manegold
@v 1.0
@t Work around internal select and join algorithm selection
@+ Introduction

Too many bugs.[ Unclear if this still holds]
The module is a copy of modules/contrib/malalgebra and heavily used
by Pathfinder.
The commands are added to the algebra module, because it is considered
a natural extension of the operations provided there.
@{
@mal

@= join
command algebra.@1join( left:bat[:any_1,:any_2], right:bat[:any_2,:any_3])
	:bat[:any_1,:any_3] 
address AL2@1join
comment "Hook directly into the '@1join' implementation of the join.";
@= leftjoin
command algebra.left@1join(left:bat[:any_1,:any_2], 
			right:bat[:any_2,:any_3] ) :bat[:any_1,:any_3] 
address AL2@1join
comment "Hook directly into the 'left@1join' implementation of the join.
prefix 'left' means that left and right input are not swapped during 
processing, and hence, the order of the left input's head in maintained 
in the result.";
@mal
@:join(fetch)@
@:join(merge)@
@:join(hash)@
@:leftjoin()@
@:leftjoin(fetch)@
@:leftjoin(merge)@
@:leftjoin(hash)@

command algebra.leftjoin(left:bat[:any_1,:any_2], 
			right:bat[:any_2,:any_3] ) :bat[:any_1,:any_3] 
address ALGjoin
comment "Hook directly into the 'left@1join' implementation of the join.
prefix 'left' means that left and right input are not swapped during 
processing, and hence, the order of the left input's head in maintained 
in the result.";

command algebra.leftthetajoin(left:bat[:any_1,:any_2],
			right:bat[:any_2,:any_3], mode:int ) :bat[:any_1,:any_3] 
address AL2leftthetajoin
comment "Hook directly into the 'leftthetajoin' implementation of the join.
prefix 'left' means that left and right input are not swapped during 
processing, and hence, the order of the left input's head in maintained 
in the result.";

command algebra.nlthetajoin(left:bat[:any_1,:any_2],
	right:bat[:any_2,:any_3], mode:int, estimate:lng) :bat[:any_1,:any_3] 
address AL2nlthetajoin
comment "Hook directly into the 'nested-loop-thetajoin' implementation 
	of the join. prefix 'left' means that left and right input are not 
	swapped during processing, and hence, the order of the left input's 
	head in maintained in the result.
	Also, for each left tuple, all matching right tuples will appear in 
	their order of appearrance in the right BAT. This property is handy 
for XQuery processing.";


@= select
command algebra.ord_@1select( b:bat[:any_1,:any_2], low:any_2,high:any_2 ) 
		:bat[:any_1, @2] 
address AL2ord_@1select
comment "Like standard '@1select(b, low, high);', but preserves the 
	order of the input BAT; (for the time being) this means, only 
	the scan-based select algorithm is used.";

command algebra.ord_@1select( b:bat[:any_1,:any_2], low:any_2, 
		high:any_2,l_in:bit,h_in:bit) :bat[:any_1, @2] 
address AL2ord_@1select_
comment "Like standard '@1select(b, low, high, l_in, h_in);', but 
		preserves the order of the input BAT (for the time being) 
		this means, only the scan-based select algorithm is used.";

command algebra.ord_@1select(b:bat[:any_1,:any_2], value:any_2) :bat[:any_1, @2] 
address AL2ord_@1select1
comment "Like standard '@1select(b, value)', but preserves the order of 
	the input BAT; (for the time being) this means, only the scan-based 
		select algorithm is used.";
@mal
@:select(,:any_2)@
@:select(u,:void)@


@- 
old stuff
@= sum
command {_csum}(BAT[oid,@1] b) : BAT[oid,@1] 
address CMDclustered_sum_@1
comment "grouped tail sum";

@:sum(sht)@
@:sum(int)@
@:sum(lng)@
@:sum(flt)@
@:sum(dbl)@

@= milsum
  PROC {csum}( BAT[oid,@1] b): BAT[oid,@1] {
	IF ( b.ordered() )
	  RETURN {_csum}( b );
	ELSE
	  RETURN {sum}( b );
  }
  ADDHELP("{csum}", "arjen", "Jul 18 2000",
	  "Choose a different implementation if b is sorted on head.", 
	  mod());

@:milsum(sht)@
@:milsum(int)@
@:milsum(lng)@
@:milsum(flt)@
@:milsum(dbl)@

@* Implementation Code
@h
#ifndef __MALALGEBRA_H__
#define __MALALGEBRA_H__
#include "gdk.h"

/* nothing much */

#endif /* __MALALGEBRA_H__ */

@c
#include "mal_config.h"
#include "algebra2.h"

/* don't reorder! */
BAT *
BATmalleftjoin(BAT *l, BAT *r)
{
	return BATleftjoin(l, r, oid_nil);
}

BAT *
BATmalfetchjoin(BAT *l, BAT *r)
{
	int rfetch = (BAThdense(r) && ATOMstorage(l->ttype) <= ATOMstorage(TYPE_oid));
	int lfetch = (BATtdense(l) && ATOMstorage(r->htype) <= ATOMstorage(TYPE_oid));

	if (lfetch && !(rfetch && BATcount(l) < BATcount(r))) {
		return BATmirror(BATfetchjoin(BATmirror(r), BATmirror(l), oid_nil));
	} else if (rfetch) {
		return BATfetchjoin(l, r, oid_nil);
	}
	GDKerror("BATmalfetchjoin: Cannot perform fetchjoin: neither left tail nor right head are dense OID columns.\n");
	return NULL;
}

/* don't reorder! */
BAT *
BATmalleftfetchjoin(BAT *l, BAT *r)
{
	int rfetch = (BAThdense(r) && ATOMstorage(l->ttype) <= ATOMstorage(TYPE_oid));

	if (rfetch) {
		return BATleftfetchjoin(l, r, oid_nil);
	}
	GDKerror("BATmalleftfetchjoin: Cannot perform leftfetchjoin: right head is no dense OID column.\n");
	return NULL;
}

BAT *
BATmalhashjoin(BAT *l, BAT *r)
{
	size_t lsize = l->batBuns->size + (l->hheap ? l->hheap->size : 0) + (l->theap ? l->theap->size : 0);
	size_t rsize = r->batBuns->size + (r->hheap ? r->hheap->size : 0) + (r->theap ? r->theap->size : 0);

	if (rsize < lsize) {
		return BATmirror(BAThashjoin(BATmirror(r), BATmirror(l), oid_nil));
	}
	return BAThashjoin(l, r, oid_nil);
}

/* don't reorder! */
BAT *
BATmallefthashjoin(BAT *l, BAT *r)
{
	return BAThashjoin(l, r, oid_nil);
}

BAT *
BATmalmergejoin(BAT *l, BAT *r)
{
	if (!((BATtordered(l) & 1) || (BAThordered(r) & 1))) {
		GDKerror("BATmalmergejoin: Cannot perform mergejoin: neither left tail nor right head is ordered.\n");
		return NULL;
	}
/*
 * Stefan: There is no reason not to perform a mergejoin on voids, is there?
 *
  if ( (l->ttype==TYPE_void) || (r->htype==TYPE_void) ) {
	GDKerror( "BATmalmergejoin: Cannot perform mergejoin on void fields.\n" );
	return NULL;
  }
*/
	return BATmergejoin(l, r, oid_nil);
}

/* don't reorder! */
BAT *
BATmalleftmergejoin(BAT *l, BAT *r)
{
	if (!(BAThordered(r) & 1)) {
		GDKerror("BATmalleftmergejoin: Cannot perform leftmergejoin: right head is ordered.\n");
		return NULL;
	}
	return BATleftmergejoin(l, r, oid_nil);
}

BAT *
BATmalindexjoin(BAT *l, BAT *r)
{
	if (l->ttype == TYPE_void && r->htype == TYPE_void) {
		GDKerror("BATmalindexjoin: Cannot perform indexjoin on void columns.\n");
		return NULL;
	}
	return BATindexjoin(l, r, oid_nil);
}

/* don't reorder! */
BAT *
BATmalleftindexjoin(BAT *l, BAT *r)
{
	if (r->htype == TYPE_void) {
		GDKerror("BATmalleftindexjoin: Cannot perform leftindexjoin: right head must not be void.\n");
		return NULL;
	}
	return BATleftindexjoin(l, r, oid_nil);
}

@= joincmd
int CMD@1join(BAT **result, BAT *left, BAT* right) {
  ERRORcheck(left == NULL, "@1-join: invalid left operand"); 
  ERRORcheck(right == NULL, "@1-join: invalid right operand"); 
  ERRORcheck(TYPEerror(left->ttype, right->htype), "@1-join: type conflict\n"); 
  return (*result = (BAT*) BATmal@1join(left, right))?GDK_SUCCEED:GDK_FAIL;
}
@c
@:joincmd(left)@
@:joincmd(fetch)@
@:joincmd(leftfetch)@
@:joincmd(merge)@
@:joincmd(leftmerge)@
@:joincmd(hash)@
@:joincmd(lefthash)@

int
CMDleftthetajoin(BAT **result, BAT *l, BAT *r, int *mode)
{
	return (*result = BATleftthetajoin(l, r, *mode, MIN(BATcount(l), BATcount(r)))) ? GDK_SUCCEED : GDK_FAIL;
}

int
CMDnlthetajoin(BAT **result, BAT *l, BAT *r, int *mode, lng *estimate)
{
	return (*result = BATnlthetajoin(l, r, *mode, (size_t) * estimate)) ? GDK_SUCCEED : GDK_FAIL;
}

@= selectcmd
int CMDord_@1select1(BAT **result, BAT* b, ptr value) {
	return (*result = BAT_select_(b, value, 0, TRUE, TRUE, @2, TRUE))?GDK_SUCCEED:GDK_FAIL;
}
int CMDord_@1select(BAT **result, BAT *b, ptr low, ptr high) {
	return (*result = BAT_select_(b, low, high, TRUE, TRUE, @2, TRUE))?GDK_SUCCEED:GDK_FAIL;
}
int CMDord_@1select_(BAT **result, BAT *b, ptr low, ptr high, bit* l_in, bit* h_in) {
	int tt = b->ttype;
	ptr nil = ATOMnilptr(tt);
	if (*l_in == bit_nil && ATOMcmp(tt, low, nil)) {
		GDKerror("CMDord_@1select: flag 'l_in' must not be NIL, unless boundary 'low' is NIL\n");
		return GDK_FAIL;
	}
	if (*h_in == bit_nil && ATOMcmp(tt, high, nil)) {
		GDKerror("CMDord_@1select: flag 'h_in' must not be NIL, unless boundary 'high' is NIL\n");
		return GDK_FAIL;
	}
	return (*result = BAT_select_(b, low, high, *l_in, *h_in, @2, TRUE))?GDK_SUCCEED:GDK_FAIL;
}
@c
@:selectcmd(,TRUE)@
@:selectcmd(u,FALSE)@


@= sumcmd
int CMDclustered_sum_@1(BAT **ret, BAT *b ) {
	BAT *bn = BATnew(b->htype, BATttype(b), BATcount(b));	
	BUN p, q;
	int xx;
	oid cur;
	@1 sum = 0;

	bn->hsorted = b->hsorted;
	bn->tsorted = 0;
	if (BATcount(b))
 		cur = *(oid*)BUNhead(b,BUNfirst(b));
	BATloopFast(b, p, q, xx) {
		oid *h = (oid*) BUNhead(b,p);
		@1 *t = (@1*) BUNtail(b,p);

		if (cur != *h){
			BUNfastins(bn, &cur, &sum );
			cur = *h;
			sum = 0;
		}
		sum += *t;
	}
	if (BATcount(b))
		BUNfastins(bn, &cur, &sum );

	*ret = bn;
	return GDK_SUCCEED;
}
@c
@:sumcmd(sht)@
@:sumcmd(int)@
@:sumcmd(lng)@
@:sumcmd(flt)@
@:sumcmd(dbl)@

@}
@-
@include ../mal/prelude.mx
@-
@c
#include "algebra.h"
#include "algebra2.h"

@= joincmdMAL
algebra_export str AL2@1join(int *ret, int *lid, int *rid );
str AL2@1join(int *ret, int *lid, int *rid ){
	BAT *bn,*left, *right;
	if( (left= BATdescriptor(*lid)) == NULL ){
		return throwMessage("algebra.@1join", "Cannot access descriptor");
	}

	if( (right= BATdescriptor(*rid)) == NULL ){
		BBPreleaseref(left->batCacheid);
		return throwMessage("algebra.@1join", "Cannot access descriptor");
	}
  	bn = (BAT*) BATmal@1join(left, right);
	BBPreleaseref(left->batCacheid);
	BBPreleaseref(right->batCacheid);
	if( bn == NULL)
		return throwMessage("@1join","failed");
	*ret = bn->batCacheid;
	BBPkeepref(*ret);
	return MAL_SUCCEED;
}
@c
@:joincmdMAL(left)@
@:joincmdMAL(fetch)@
@:joincmdMAL(leftfetch)@
@:joincmdMAL(merge)@
@:joincmdMAL(leftmerge)@
@:joincmdMAL(hash)@
@:joincmdMAL(lefthash)@
@:joincmdMAL(index)@
@:joincmdMAL(leftindex)@

algebra_export str AL2leftthetajoin(int *ret, int *lid, int *rid, int *mode);
str
AL2leftthetajoin(int *ret, int *lid, int *rid, int *mode)
{
	BAT *bn, *l, *r;

	if ((l = BATdescriptor(*lid)) == NULL) {
		return throwMessage("algebra.@1join", "Cannot access descriptor");
	}
	if ((r = BATdescriptor(*rid)) == NULL) {
		BBPreleaseref(l->batCacheid);
		return throwMessage("algebra.@1join", "Cannot access descriptor");
	}
	bn = BATleftthetajoin(l, r, *mode, MIN(BATcount(l), BATcount(r)));
	BBPreleaseref(l->batCacheid);
	BBPreleaseref(r->batCacheid);

	if (bn == NULL)
		return throwMessage("algebra2.leftthetajoin", "failed");
	*ret = bn->batCacheid;
	BBPkeepref(*ret);
	return MAL_SUCCEED;
}

algebra_export str AL2nlthetajoin(int *ret, int *lid, int *rid, int *mode, lng *estimate);
str
AL2nlthetajoin(int *ret, int *lid, int *rid, int *mode, lng *estimate)
{
	BAT *bn, *l, *r;

	if ((l = BATdescriptor(*lid)) == NULL) {
		return throwMessage("algebra.@1join", "Cannot access descriptor");
	}
	if ((r = BATdescriptor(*rid)) == NULL) {
		BBPreleaseref(l->batCacheid);
		return throwMessage("algebra.@1join", "Cannot access descriptor");
	}
	bn = BATnlthetajoin(l, r, *mode, (size_t) * estimate);
	BBPreleaseref(l->batCacheid);
	BBPreleaseref(r->batCacheid);
	if (bn == NULL)
		return throwMessage("algebra2.thetajoin", "failed");
	*ret = bn->batCacheid;
	BBPkeepref(*ret);
	return MAL_SUCCEED;
}

@= selectcmdMAL
algebra_export str AL2ord_@1select1(int *ret, int * bid, ptr *value);
str AL2ord_@1select1(int *ret, int * bid, ptr *value) {
	BAT *bn, *b;
	if( (b= BATdescriptor(*bid)) == NULL ){
		 return throwMessage("algebra2.select", "Cannot access descriptor");
	}

	bn = BAT_select_(b, *value, 0, TRUE, TRUE, @2, TRUE);
	BBPreleaseref(b->batCacheid);
	if( bn == NULL)
		return throwMessage("ord_@1select","failed");
	*ret = bn->batCacheid;
	BBPkeepref(*ret);
	return MAL_SUCCEED;
}
algebra_export str AL2ord_@1select(int *ret, int *bid, ptr *low, ptr *high);
str AL2ord_@1select(int *ret, int *bid, ptr *low, ptr *high) {
	BAT *bn, *b;
	if( (b= BATdescriptor(*bid)) == NULL ){
		 return throwMessage("algebra2.@1select", "Cannot access descriptor");
	}
	bn = BAT_select_(b, *low, *high, TRUE, TRUE, @2, TRUE);
	BBPreleaseref(b->batCacheid);
	if( bn == NULL)
		return throwMessage("ord_@1select","failed");
	*ret = bn->batCacheid;
	BBPkeepref(*ret);
	return MAL_SUCCEED;
}
algebra_export str AL2ord_@1select_(int *ret, int *bid, ptr *lval, ptr *hval, bit *l_in, bit *h_in);
str AL2ord_@1select_(int *ret, int *bid, ptr *lval, ptr *hval, bit *l_in, bit *h_in){
	ptr low=*lval, high= *hval;
	int tt ;
	ptr nil ;
	BAT *bn, *b;
	if( (b= BATdescriptor(*bid)) == NULL ){
		 return throwMessage("algebra2.@1select", "Cannot access descriptor");
	}
	tt = b->ttype;
	nil = ATOMnilptr(tt);

	if (*l_in == bit_nil && ATOMcmp(tt, low, nil)) 
		return throwMessage("AL2ord_@1select",
			"flag 'l_in' must not be NIL, unless boundary 'low' is NIL\n");
	if (*h_in == bit_nil && ATOMcmp(tt, high, nil)) 
		return throwMessage("AL2ord_@1select",
			"flag 'h_in' must not be NIL, unless boundary 'high' is NIL\n");
	bn = BAT_select_(b, low, high, *l_in, *h_in, @2, TRUE);
	BBPreleaseref(b->batCacheid);
	if( bn == NULL)
		return throwMessage("ord_@1select","failed");
	*ret = bn->batCacheid;
	BBPkeepref(*ret);
	return MAL_SUCCEED;
}
@c
@:selectcmdMAL(, TRUE)@
@:selectcmdMAL(u, FALSE)@


@= jointest_void
VAR @1result_void := @1join( l, r );
@
@= jointest_oid
VAR @1result_oid := @1join( [oid](l), [oid](r.reverse()).reverse() );
@
@= compresults
@:jointest_@2(@1)
IF( not( isnil(@1result_@2) ) ) {
  Ndiff := diff( result_@2, @1result_@2 ).count();
  printf( "Algorithm @1 leads to %d different answers.\n", Ndiff );
  IF (Ndiff>0) {
	Ntestfailed :+= 1;
	print(result_@2);
	print(@1result_@2);
	print(diff(result_@2,@1result_@2));
	print(diff(@1result_@2,result_@2));
  }
}
@
@mil

PROC test_malalgebra() : void {   
	#
	# Simple test of some algorithms against the baseline
	#
	VAR Ndiff, l, r;

	var dj := new( void, oid ); var tf := new( void, int );
	dj.insert( nil, 0@0 );  tf.insert( nil, 10 );
	dj.insert( nil, 0@0 );  tf.insert( nil, 20 );
	dj.insert( nil, 0@0 );  tf.insert( nil, 30 );
	dj.insert( nil, 1@0 );  tf.insert( nil, 30 );
	dj.insert( nil, 1@0 );  tf.insert( nil, 20 );
	dj.insert( nil, 1@0 );  tf.insert( nil, 10 );
	dj.insert( nil, 2@0 );  tf.insert( nil, 20 );
	dj.insert( nil, 2@0 );  tf.insert( nil, 30 );
	dj.insert( nil, 2@0 );  tf.insert( nil, 10 );
	dj.seqbase(0@0);        tf.seqbase(0@0);

	l := dj.reverse();
	r := tf;

	var Ntestfailed := 0;

	@:jointest_oid()@
	@:compresults(hash,oid)@
	@:compresults(fetch,oid)@
	@:compresults(merge,oid)@
	@:compresults(left,oid)@
	@:compresults(lefthash,oid)@
	@:compresults(leftfetch,oid)@
	@:compresults(leftmerge,oid)@

	@:jointest_void()@
	@:compresults(hash,void)@
	@:compresults(fetch,void)@
	@:compresults(merge,void)@
	@:compresults(left,void)@
	@:compresults(lefthash,void)@
	@:compresults(leftfetch,void)@
	@:compresults(leftmerge,void)@

	printf( "RESULT: %d tests failed.\n", Ntestfailed );
}
