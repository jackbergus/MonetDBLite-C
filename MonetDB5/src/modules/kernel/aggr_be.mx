@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
@' Copyright August 2008-2009 MonetDB B.V.
@' All Rights Reserved.

@f aggr_be
@a S. Manegold 
@v 1.0
@+ Aggregates Module

@{

@+ Implementation
These implementations need just one scan and a simple hash-maintained data
structure to compute a group of common aggregates.
@c
#include "mal_config.h"
#include <gdk.h>
#include <gdk_scanselect.h>	/* for type-specific HT_bunfastins_nocheck_noinc(), until they're moved to gdk.mx */
#include "aggr.h"

@- Result initialization
/*	init_result
	@1:	tail-type:	bte/sht/int/wrd/lng/flt/dbl / any / void
*/
@include aggr_ri.mx

@- Sum, Product & Average
@c
/*	aggrX3_sum
		e-void-head	e-oid-head	e-oid-head	e-oid-head
		void-lookup	array-lookup	scan-lookup	hash-lookup

	@1:	0		1		0		0		use sums-array?
	@2:	0		0		0		1		do BATprepareHash?
	@3:	BUNfndVOID	CHKrange	SCANfndOID	HASHfnd_oid	lookup
	@4:	var		loc		loc		loc		e/bn-head-access

	@5:	"BUNhloc(b,p)"	for  (oid) b-head-type,		b-head access
		"&bhsb; bhsb++" for (void) b-head-type

	@6:	bte / sht / int / wrd / lng / flt / dbl		b/bn-tail-type
	@7:	"loc" for fixsized b/bn-tail-type,		b/bn-tail-access
		"var" for varsized b/bn-tail-type		(only loc used currently)

	@8:	BUNt@7(bn,r)	BUNt@7(bn,r)	&sums[(*(oid*)h)-min]
								*dst: sum in-place or in sums-array ?
	@9:	result type
	@[10]:		r-off		(*(oid*)h)-min	index in hit array
*/
@= aggrX3_sum
	ALGODEBUG THRprintf(GDKout, "#aggrX3_sum(@1,@2,@3,@4,@5,@6,@7,@8,@9,@[10]);\n");
	if (@1 && range > 0) {
		/* create tmp. sums array */
		oid i;
		sums = (@9*) GDKmalloc(range*sizeof(@9));
		if (sums == NULL) {
			GDKerror("aggrX3_sum(@1,@2,@3,@4,@5,@6,@7,@8,@9,@[10]): sums = GDKmalloc("OIDFMT"*"SZFMT") failed", range, sizeof(@9));
			BBPreclaim(bn);
			return GDK_FAIL;
		}
		for (i = 0; i < range; i++)
			sums[i] = zero;
	}
	if (@2 && BATprepareHash(bn)) {
		GDKerror("aggrX3_sum(@1,@2,@3,@4,@5,@6,@7,@8,@9,@[10]): BATprepareHash(bn) failed");
		if (@1 && sums)
			GDKfree(sums);
		BBPreclaim(bn);
		return GDK_FAIL;
	}
	if (slots > 0) {
		hit = (bit*) GDKmalloc(slots*sizeof(bit));
		if (hit == NULL) {
			GDKerror("aggrX3_sum(@1,@2,@3,@4,@5,@6,@7,@8,@9,@[10]): hit = GDKmalloc("OIDFMT"*"SZFMT") failed", slots, sizeof(bit));
			if (@1 && sums)
				GDKfree(sums);
			BBPreclaim(bn);
			return GDK_FAIL;
		}
		memset(hit, 0, slots*sizeof(bit));
	}

	/* scan b, and add values to sums in-place or in sums-array */
	bhsb = b->hseqbase - 1;
	if (b->T->nonil) {
		BATloop(b, p, q) {
			@6 *t = (@6*) BUNt@7(bi,p);
			oid *h = (oid*) @5;

			@3(r, bni, h);
			if (r != BUN_NONE) {
				@9 *dst = (@9*) @8;
				*dst += (@9) *t;
				hit[@[10]] = 1;
			}
		}
	} else {
		BATloop(b, p, q) {
			@6 *t = (@6*) BUNt@7(bi,p);
			oid *h = (oid*) @5;

			@3(r, bni, h);
			if (r != BUN_NONE) {
				@9 *dst = (@9*) @8;
				if (*dst != @9_nil) {
					if (*t == @6_nil) {
						*dst = @9_nil;
					} else {
						*dst += (@9) *t;
						hit[@[10]] = 1;
					}
				}
			}
		}
	}
	if (@1) {
	    if (sums) {
		/* copy sums array to final result */
		BATloop(bn, p, q) {
			oid h = (*(oid*) BUNh@4(bni,p)) - min;
			@9 *dst = (@9*)BUNt@7(bni, p);
			if (hit[h] == 0) {
				*dst = @9_nil;
			} else {
				*dst = sums[h];
			}
		}
		GDKfree(sums);
	    } 
	} else {
		BUN yy = 0;
		BATloop(bn, p, q) {
			@9 *dst = (@9*)BUNt@7(bni, p);
			if (hit[yy] == 0) {
				*dst = @9_nil;
			}
			yy++;
		}
	}
	if (hit)
		GDKfree(hit);
@
@c
/*	aggrX3_prod
		e-void-head	e-oid-head	e-oid-head	e-oid-head
		void-lookup	array-lookup	scan-lookup	hash-lookup

	@1:	0		1		0		0		use prods-array?
	@2:	0		0		0		1		do BATprepareHash?
	@3:	BUNfndVOID	CHKrange	SCANfndOID	HASHfnd_oid	lookup
	@4:	var		loc		loc		loc		e/bn-head-access

	@5:	"BUNhloc(b,p)"	for  (oid) b-head-type,		b-head access
		"&bhsb; bhsb++" for (void) b-head-type

	@6:	bte / sht / int / wrd / lng / flt / dbl		b/bn-tail-type
	@7:	"loc" for fixsized b/bn-tail-type,		b/bn-tail-access
		"var" for varsized b/bn-tail-type		(only loc used currently)

	@8:	BUNt@7(bn,r)	BUNt@7(bn,r)	&prods[(*(oid*)h)-min]
								*dst: prod in-place or in prods-array ?
	@9:	result type
	@[10]:		r-off		(*(oid*)h)-min	index in hit array
*/
@= aggrX3_prod
	ALGODEBUG THRprintf(GDKout, "#aggrX3_prod(@1,@2,@3,@4,@5,@6,@7,@8,@9,@[10]);\n");
	if (@1 && range > 0) {
		/* create tmp. prods array */
		oid i;
		prods = (@9*) GDKmalloc(range*sizeof(@9));
		if (prods == NULL) {
			GDKerror("aggrX3_prod(@1,@2,@3,@4,@5,@6,@7,@8,@9,@[10]): prods = GDKmalloc("OIDFMT"*"SZFMT") failed", range, sizeof(@9));
			BBPreclaim(bn);
			return GDK_FAIL;
		}
		for (i = 0; i < range; i++)
			prods[i] = zero;
	}
	if (@2 && BATprepareHash(bn)) {
		GDKerror("aggrX3_prod(@1,@2,@3,@4,@5,@6,@7,@8,@9,@[10]): BATprepareHash(bn) failed");
		if (@1 && prods)
			GDKfree(prods);
		BBPreclaim(bn);
		return GDK_FAIL;
	}
	if (slots > 0) {
		hit = (bit*) GDKmalloc(slots*sizeof(bit));
		if (hit == NULL) {
			GDKerror("aggrX3_prod(@1,@2,@3,@4,@5,@6,@7,@8,@9,@[10]): hit = GDKmalloc("OIDFMT"*"SZFMT") failed", slots, sizeof(bit));
			if (@1 && prods)
				GDKfree(prods);
			BBPreclaim(bn);
			return GDK_FAIL;
		}
		memset(hit, 0, slots*sizeof(bit));
	}
	/* scan b, and mul values to prods in-place or in prods-array */
	bhsb = b->hseqbase - 1;
	if (b->T->nonil) {
		BATloop(b, p, q) {
			@6 *t = (@6*) BUNt@7(bi,p);
			oid *h = (oid*) @5;

			@3(r, bni, h);
			if (r != BUN_NONE) {
				@9 *dst = (@9*) @8;
				*dst *= (@9) *t;
				hit[@[10]] = 1;
			}
		}
	} else {
		BATloop(b, p, q) {
			@6 *t = (@6*) BUNt@7(bi,p);
			oid *h = (oid*) @5;

			@3(r, bni, h);
			if (r != BUN_NONE) {
				@9 *dst = (@9*) @8;
				if (*dst != @9_nil) {
					if (*t == @6_nil) {
						*dst = @9_nil;
					} else {
						*dst *= (@9) *t;
						hit[@[10]] = 1;
					}
				}
			}
		}
	}
	if (@1) {
	    if (prods) {
		/* copy prods array to final result */
		BATloop(bn, p, q) {
			oid h = (*(oid*) BUNh@4(bni,p)) - min;
			@9 *dst = (@9*)BUNt@7(bni, p);
			if (hit[h] == 0) {
				*dst = @9_nil;
			} else {
				*dst = prods[h];
			}
		}
		GDKfree(prods);
	    }
	} else {
		BUN yy = 0;
		BATloop(bn, p, q) {
			@9 *dst = (@9*)BUNt@7(bni, p);
			if (hit[yy] == 0) {
				*dst = @9_nil;
			}
			yy++;
		}
	}
	if (hit)
		GDKfree(hit);
@
@c
/*	aggrX3_avg
		e-void-head	e-oid-head	e-oid-head	e-oid-head
		void-lookup	array-lookup	scan-lookup	hash-lookup

	@1:	0		1		0		0		use sums-array?
	@2:	0		0		0		1		do BATprepareHash?
	@3:	BUNfndVOID	CHKrange	SCANfndOID	HASHfnd_oid	lookup
	@4:	var		loc		loc		loc		e/bn-head-access

	@5:	"BUNhloc(b,p)"	for  (oid) b-head-type,		b-head access
		"&bhsb; bhsb++" for (void) b-head-type

	@6:	bte / sht / int / wrd / lng / flt / dbl		b/bn-tail-type
	@7:	"loc" for fixsized b/bn-tail-type,		b/bn-tail-access
		"var" for varsized b/bn-tail-type		(only loc used currently)

	@8:	BUNt@7(bn,r)	BUNt@7(bn,r)	&sums[(*(oid*)h)-min]
								*dst: sum in-place or in sums-array ?

	@9:		r-off		(*(oid*)h)-min	index in cnt array
*/
@= aggrX3_avg
	ALGODEBUG THRprintf(GDKout, "#aggrX3_avg(@1,@2,@3,@4,@5,@6,@7,@8,@9);\n");
	if (@1 && range > 0) {
		/* create tmp. sums array */
		oid i;
		sums = (dbl*) GDKmalloc(range*sizeof(dbl));
		if (sums == NULL) {
			GDKerror("aggrX3_avg(@1,@2,@3,@4,@5,@6,@7,@8,@9): sums = GDKmalloc("OIDFMT"*"SZFMT") failed", range, sizeof(dbl));
			BBPreclaim(bn);
			return GDK_FAIL;
		}
		for (i = 0; i < range; i++)
			sums[i] = zero;
	}
	if (@2 && BATprepareHash(bn)) {
		GDKerror("aggrX3_avg(@1,@2,@3,@4,@5,@6,@7,@8,@9): BATprepareHash(bn) failed");
		if (@1 && sums)
			GDKfree(sums);
		BBPreclaim(bn);
		return GDK_FAIL;
	}
	if (slots > 0) {
		cnt = (BUN*) GDKmalloc(slots*sizeof(cnt[0]));
		if (cnt == NULL) {
			GDKerror("aggrX3_avg(@1,@2,@3,@4,@5,@6,@7,@8,@9): cnt = GDKmalloc("OIDFMT"*"SZFMT") failed", slots, sizeof(cnt[0]));
			if (@1 && sums)
				GDKfree(sums);
			BBPreclaim(bn);
			return GDK_FAIL;
		}
		memset(cnt, 0, slots*sizeof(cnt[0]));
	}
	/* scan b, adding sums, and incrementing counts */
	bhsb = b->hseqbase - 1;
	if (b->T->nonil) {
		BATloop(b, p, q) {
			@6 *t = (@6*) BUNt@7(bi,p);
			oid *h = (oid*) @5;

			@3(r, bni, h);
			if (r != BUN_NONE) {
				dbl *dst = (dbl*) @8;
				*dst += *t;
				cnt[@9]++;
			}
		}
	} else {
		BATloop(b, p, q) {
			@6 *t = (@6*) BUNt@7(bi,p);
			oid *h = (oid*) @5;

			@3(r, bni, h);
			if (r != BUN_NONE) {
				dbl *dst = (dbl*) @8;
				if (*dst != dbl_nil) {
					if (*t == @6_nil) {
						*dst = dbl_nil;
					} else {
						*dst += *t;
					}
					cnt[@9]++;
				}
			}
		}
	}
	/* postprocess by dividing sums by counts */
	if (@1) {
	    if (sums) {
		/* sums in sums-array */
		BATloop(bn, p, q) {
			oid h = (*(oid*) BUNh@4(bni,p)) - min;
			dbl *dst = (dbl*) BUNt@7(bni, p);
			if (cnt[h] == 0 || sums[h] == dbl_nil) {
				*dst = dbl_nil;
			} else {
				*dst = (dbl) (sums[h]/cnt[h]);
			}
		}
		GDKfree(sums);
	    }
	} else {
		/* sums in-place */
		BUN yy = 0;
		BATloop(bn, p, q) {
			dbl *dst = (dbl*) BUNt@7(bni, p);
			if (cnt[yy] == 0) {
				*dst = dbl_nil;
			} else if (*dst != dbl_nil) {
				*dst = (dbl) (*dst / cnt[yy]);
			}
			yy++;
		}

	}
	if (cnt)
		GDKfree(cnt);
@c

/*	arithsum
	@6:	bte / sht / int / wrd / lng / flt / dbl	b/bn-tail-type
	@7:	"loc" for fixsized b/bn-tail-type,	b/bn-tail-access
		"var" for varsized b/bn-tail-type	(only loc used currently)
	@9:	result type
*/
@= arithsum_h
int
CMDaggrX3_sum_@1_@3(BAT **ret, BAT *b, BAT *e);
@= arithsum_c
int
CMDaggrX3_sum_@1_@3(BAT **ret, BAT *b, BAT *e)
{
	BAT *bn = BATnew(e->htype, TYPE_@3, BATcount(e));
	BATiter bni = bat_iterator(bn), bi = bat_iterator(b);
	@3 zero = (@3) 0, *sums = NULL;
	bit *hit = NULL;
	BUN slots, off;
	BUN p, q, r;
	oid range;
	oid min, max;
	oid bhsb;

	if( bn == NULL) {
		GDKerror("CMDaggrX3_sum_@1_@3(): BATnew() failed");
		return GDK_FAIL;
	}
	off = BUNfirst(bn);
	ALGODEBUG THRprintf(GDKout, "#CMDaggrX3_sum_@1_@3[@2](b=%s,e=%s);\n",
		BATgetId(b), BATgetId(e));
	/* init: set all sums to zero and calculate min/max oid */
	@:init_result(@3)@
	range = max - min + 1;

	/* scan b, and calculate sums */
	slots = BATcount(e);
	if (e->htype == TYPE_void) {
		/* void lookup */
		if (b->htype == TYPE_void) {
			@:aggrX3_sum(0,0,BUNfndVOID,var,&bhsb;bhsb++,@1,@2,BUNt@2(bni,r),@3,r-off)@
		} else {
			@:aggrX3_sum(0,0,BUNfndVOID,var,BUNhloc(bi,p),@1,@2,BUNt@2(bni,r),@3,r-off)@
		}
	/* e->htype == TYPE_oid */
	} else if (range <= SMALL_AGGR_MAX) {
		/* array lookup */
		slots = range;
		if (b->htype == TYPE_void) {
			@:aggrX3_sum(1,0,CHKrange,loc,&bhsb;bhsb++,@1,@2,&sums[(*(oid*)h)-min],@3,(*(oid*)h)-min)@
		} else {
			@:aggrX3_sum(1,0,CHKrange,loc,BUNhloc(bi,p),@1,@2,&sums[(*(oid*)h)-min],@3,(*(oid*)h)-min)@
		}
	} else if (BATcount(e) <= SCAN_AGGR_MAX) {
		/* scan lookup */
		SCAN_aggr_init;
		if (b->htype == TYPE_void) {
			@:aggrX3_sum(0,0,SCANfndOID,loc,&bhsb;bhsb++,@1,@2,BUNt@2(bni,r),@3,r-off)@
		} else {
			@:aggrX3_sum(0,0,SCANfndOID,loc,BUNhloc(bi,p),@1,@2,BUNt@2(bni,r),@3,r-off)@
		}
	} else {
		/* hash lookup */
		if (b->htype == TYPE_void) {
			@:aggrX3_sum(0,1,HASHfnd_oid,loc,&bhsb;bhsb++,@1,@2,BUNt@2(bni,r),@3,r-off)@
		} else {
			@:aggrX3_sum(0,1,HASHfnd_oid,loc,BUNhloc(bi,p),@1,@2,BUNt@2(bni,r),@3,r-off)@
		}
	}

	*ret = bn;
	return GDK_SUCCEED;
}
@c

/*	arithprod
	@6:	bte / sht / int / wrd / lng / flt / dbl	b/bn-tail-type
	@7:	"loc" for fixsized b/bn-tail-type,	b/bn-tail-access
		"var" for varsized b/bn-tail-type	(only loc used currently)
	@9:	result type
*/
@= arithprod_h
int
CMDaggrX3_prod_@1_@3(BAT **ret, BAT *b, BAT *e);
@= arithprod_c
int
CMDaggrX3_prod_@1_@3(BAT **ret, BAT *b, BAT *e)
{
	BAT *bn = BATnew(e->htype, TYPE_@3, BATcount(e));
	BATiter bni = bat_iterator(bn), bi = bat_iterator(b);
	@3 zero = (@3) 1, *prods = NULL;
	bit *hit = NULL;
	BUN slots, off;
	BUN p, q, r;
	oid range;
	oid min, max;
	oid bhsb;

	if( bn == NULL) {
		GDKerror("CMDaggrX3_prod_@1_@3(): BATnew() failed");
		return GDK_FAIL;
	}
	off = BUNfirst(bn);
	ALGODEBUG THRprintf(GDKout, "#CMDaggrX3_prod_@1_@3[@2](b=%s,e=%s);\n",
		BATgetId(b), BATgetId(e));
	/* init: set all prods to zero and calculate min/max oid */
	@:init_result(@3)@
	range = max - min + 1;

	/* scan b, and calculate prods */
	slots = BATcount(e);
	if (e->htype == TYPE_void) {
		/* void lookup */
		if (b->htype == TYPE_void) {
			@:aggrX3_prod(0,0,BUNfndVOID,var,&bhsb;bhsb++,@1,@2,BUNt@2(bni,r),@3,r-off)@
		} else {
			@:aggrX3_prod(0,0,BUNfndVOID,var,BUNhloc(bi,p),@1,@2,BUNt@2(bni,r),@3,r-off)@
		}
	/* e->htype == TYPE_oid */
	} else if (range <= SMALL_AGGR_MAX) {
		/* array lookup */
		slots = range;
		if (b->htype == TYPE_void) {
			@:aggrX3_prod(1,0,CHKrange,loc,&bhsb;bhsb++,@1,@2,&prods[(*(oid*)h)-min],@3,(*(oid*)h)-min)@
		} else {
			@:aggrX3_prod(1,0,CHKrange,loc,BUNhloc(bi,p),@1,@2,&prods[(*(oid*)h)-min],@3,(*(oid*)h)-min)@
		}
	} else if (BATcount(e) <= SCAN_AGGR_MAX) {
		/* scan lookup */
		SCAN_aggr_init;
		if (b->htype == TYPE_void) {
			@:aggrX3_prod(0,0,SCANfndOID,loc,&bhsb;bhsb++,@1,@2,BUNt@2(bni,r),@3,r-off)@
		} else {
			@:aggrX3_prod(0,0,SCANfndOID,loc,BUNhloc(bi,p),@1,@2,BUNt@2(bni,r),@3,r-off)@
		}
	} else {
		/* hash lookup */
		if (b->htype == TYPE_void) {
			@:aggrX3_prod(0,1,HASHfnd_oid,loc,&bhsb;bhsb++,@1,@2,BUNt@2(bni,r),@3,r-off)@
		} else {
			@:aggrX3_prod(0,1,HASHfnd_oid,loc,BUNhloc(bi,p),@1,@2,BUNt@2(bni,r),@3,r-off)@
		}
	}

	*ret = bn;
	return GDK_SUCCEED;
}
@c

/*	arithsumprod
	@6:	bte / sht / int / wrd / lng / flt / dbl	b/bn-tail-type
	@7:	"loc" for fixsized b/bn-tail-type,	b/bn-tail-access
		"var" for varsized b/bn-tail-type	(only loc used currently)
	@9:	result type
*/
@= arithsumprod_hc
@:arithsum_@1(@2,@3,@4)@
@:arithprod_@1(@2,@3,@4)@
@= arithsumprod
@:arithsumprod_hc(@1,bte,loc,bte)@
@:arithsumprod_hc(@1,bte,loc,sht)@
@:arithsumprod_hc(@1,bte,loc,int)@
@:arithsumprod_hc(@1,bte,loc,wrd)@
@:arithsumprod_hc(@1,bte,loc,lng)@
@:arithsumprod_hc(@1,sht,loc,sht)@
@:arithsumprod_hc(@1,sht,loc,int)@
@:arithsumprod_hc(@1,sht,loc,wrd)@
@:arithsumprod_hc(@1,sht,loc,lng)@
@:arithsumprod_hc(@1,int,loc,int)@
@:arithsumprod_hc(@1,int,loc,wrd)@
@:arithsumprod_hc(@1,int,loc,lng)@
@:arithsumprod_hc(@1,wrd,loc,wrd)@
@:arithsumprod_hc(@1,wrd,loc,lng)@
@:arithsumprod_hc(@1,lng,loc,wrd)@
@:arithsumprod_hc(@1,lng,loc,lng)@
@:arithsumprod_hc(@1,flt,loc,flt)@
@:arithsumprod_hc(@1,flt,loc,dbl)@
@:arithsumprod_hc(@1,dbl,loc,dbl)@
@h
@:arithsumprod(h)@
@c
@:arithsumprod(c)@

/*	arithavg
	@6:	bte / sht / int / wrd / lng / flt / dbl	b/bn-tail-type
	@7:	"loc" for fixsized b/bn-tail-type,	b/bn-tail-access
		"var" for varsized b/bn-tail-type	(only loc used currently)
*/
@= arithavg_h
int
CMDaggrX3_avg_@1(BAT **ret, BAT *b, BAT *e);
@= arithavg_c
int
CMDaggrX3_avg_@1(BAT **ret, BAT *b, BAT *e)
{
	BAT *bn = BATnew(e->htype, TYPE_dbl, BATcount(e));
	BATiter bni = bat_iterator(bn), bi = bat_iterator(b);
	BUN off;
	BUN *cnt = NULL;
	BUN slots;
	oid range;
	oid min, max;
	dbl zero = (dbl) 0, *sums = NULL;
	BUN p, q, r;
	oid bhsb;

	if( bn == NULL) {
		GDKerror("CMDaggrX3_avg_@1(): BATnew() failed");
		return GDK_FAIL;
	}
	off = BUNfirst(bn);

	ALGODEBUG THRprintf(GDKout, "#CMDaggrX3_avg_@1[@2](b=%s,e=%s);\n",
		BATgetId(b),BATgetId(e));
	/* init: set all sums & counts to zero and calculate min/max oid */
	@:init_result(dbl)@
	range = max - min + 1;

	/* scan b, calculate sums & counts, derive averages */
	slots = BATcount(e);
	if (e->htype == TYPE_void) {
		/* void lookup */
		if (b->htype == TYPE_void) {
			@:aggrX3_avg(0,0,BUNfndVOID,var,&bhsb;bhsb++,@1,@2,BUNt@2(bni,r),r-off)@
		} else {
			@:aggrX3_avg(0,0,BUNfndVOID,var,BUNhloc(bi,p),@1,@2,BUNt@2(bni,r),r-off)@
		}
	/* e->htype == TYPE_oid */
	} else if (range <= SMALL_AGGR_MAX) {
		/* array lookup */
		slots = range;
		if (b->htype == TYPE_void) {
			@:aggrX3_avg(1,0,CHKrange,loc,&bhsb;bhsb++,@1,@2,&sums[(*(oid*)h)-min],(*(oid*)h)-min)@
		} else {
			@:aggrX3_avg(1,0,CHKrange,loc,BUNhloc(bi,p),@1,@2,&sums[(*(oid*)h)-min],(*(oid*)h)-min)@
		}
	} else if (BATcount(e) <= SCAN_AGGR_MAX) {
		/* scan lookup */
		SCAN_aggr_init;
		if (b->htype == TYPE_void) {
			@:aggrX3_avg(0,0,SCANfndOID,loc,&bhsb;bhsb++,@1,@2,BUNt@2(bni,r),r-off)@
		} else {
			@:aggrX3_avg(0,0,SCANfndOID,loc,BUNhloc(bi,p),@1,@2,BUNt@2(bni,r),r-off)@
		}
	} else {
		/* hash lookup */
		if (b->htype == TYPE_void) {
			@:aggrX3_avg(0,1,HASHfnd_oid,loc,&bhsb;bhsb++,@1,@2,BUNt@2(bni,r),r-off)@
		} else {
			@:aggrX3_avg(0,1,HASHfnd_oid,loc,BUNhloc(bi,p),@1,@2,BUNt@2(bni,r),r-off)@
		}
	}

	*ret = bn;
	return GDK_SUCCEED;
}
@= arithavg_hc
@:arithavg_@1(@2,@3)@
@= arithavg
@:arithavg_hc(@1,bte,loc)@
@:arithavg_hc(@1,sht,loc)@
@:arithavg_hc(@1,int,loc)@
@:arithavg_hc(@1,wrd,loc)@
@:arithavg_hc(@1,lng,loc)@
@:arithavg_hc(@1,flt,loc)@
@:arithavg_hc(@1,dbl,loc)@
@h
@:arithavg(h)@
@c
@:arithavg(c)@

@- "Extremes" (Min & Max)
@c
/*	aggrX3_minmax_ptr
		e-void-head	e-oid-head	e-oid-head	e-oid-head
		void-lookup	array-lookup	scan-lookup	hash-lookup

	@1:	</>		</>		</>		</>		compare operator: <(min) or >(max)
	@2:	0		0		0		1		do BATprepareHash?
	@3:	BUNfndVOID	CHKrange	SCANfndOID	HASHfnd_oid	lookup
	@4:	var		loc		loc		loc		e/bn-head-access

	@5:	"BUNhloc(b,p)"	for  (oid) b-head-type,		b-head access
		"&bhsb; bhsb++" for (void) b-head-type

	@6:		sht / int / lng / any			b/bn-tail-storage-type
	@7:	"loc" for fixsized b/bn-tail-type,		b/bn-tail-access
		"var" for varsized b/bn-tail-type

	@8:		r-off		(*(oid*)h)-min	index in extremes array
	@9:		max/min					initial result value
*/
@= aggrX3_minmax_ptr
	ALGODEBUG THRprintf(GDKout, "#aggrX3_minmax_ptr(@1,@2,@3,@4,@5,@6,@7,@8,@9);\n");
	if (@2 && BATprepareHash(e)) {
		GDKerror("aggrX3_minmax_ptr(@1,@2,@3,@4,@5,@6,@7,@8,@9): BATprepareHash(e) failed");
		BBPreclaim(e);
		return GDK_FAIL;
	}
	/* init: create extremes and set all to the zero pointer */
	if (slots > 0) {
		extremes = (ptr*) GDKmalloc(slots*sizeof(ptr));
		if (extremes == NULL) {
			GDKerror("aggrX3_minmax_ptr(@1,@2,@3,@4,@5,@6,@7,@8,@9): extremes = GDKmalloc("OIDFMT"*"SZFMT") failed", slots, sizeof(ptr));
			BBPreclaim(bn);
			return GDK_FAIL;
		}
		memset(extremes, 0, slots*sizeof(ptr));
	}
	/* scan b and replace totals by the extreme value (just pointers to vals in b) */
	bhsb = b->hseqbase - 1;
	if (b->T->nonil) {
		BATloop(b, p, q) {
			ptr t = BUNt@7(bi,p);
			oid *h = (oid*) @5;

			@3(r, bni, h);
			if (r != BUN_NONE) {
				ptr *val = &extremes[@8];
				if (*val == NULL || (*cmp)(t,*val) @1 0) {
					*val = t;
				}
			}
		}
	} else {
		BATloop(b, p, q) {
			ptr t = BUNt@7(bi,p);
			oid *h = (oid*) @5;

			@3(r, bni, h);
			if (r != BUN_NONE) {
				ptr *val = &extremes[@8];
				if (*val != nil) {
					if ((*cmp)(t,nil) == 0) {
						*val = nil;
					} else if (*val == NULL || (*cmp)(t,*val) @1 0) {
						*val = t;
					}
				}
			}
		}
	}
	/* insert the extreme values into the result */
	BATloop(bn, r, q) {
		oid *h = (oid*)BUNh@4(bni,r);
		ptr val = extremes[@8];
		(void) h;	/* silence compiler about unused variable */
		/* trick: using a void head-type, only the tail are (over)written */
		ATOMput(bn->ttype, bn->theap, BUNtloc(bni,r), val?val:nil);
	}
@c
/*	aggrX3_minmax_oid
		e-void-head	e-oid-head	e-oid-head	e-oid-head
		void-lookup	array-lookup	scan-lookup	hash-lookup

	@1:	</>		</>		</>		</>		compare operator: <(min) or >(max)
	@2:	0		0		0		1		do BATprepareHash?
	@3:	BUNfndVOID	CHKrange	SCANfndOID	HASHfnd_oid	lookup
	@4:	var		loc		loc		loc		e/bn-head-access

	@5:	"BUNhloc(b,p)"	for  (oid) b-head-type,		b-head access
		"&bhsb; bhsb++" for (void) b-head-type

	@6:		sht / int / lng / any			b/bn-tail-storage-type
	@7:	"loc" for fixsized b/bn-tail-type,		b/bn-tail-access
		"var" for varsized b/bn-tail-type

	@8:		r-off		(*(oid*)h)-min	index in extremes array
	@9:		max/min					initial result value
*/
@= aggrX3_minmax_oid
	ALGODEBUG THRprintf(GDKout, "#aggrX3_minmax_oid(@1,@2,@3,@4,@5,@6,@7,@8,@9);\n");
	if (@2 && BATprepareHash(e)) {
		GDKerror("aggrX3_minmax_oid(@1,@2,@3,@4,@5,@6,@7,@8,@9): BATprepareHash(e) failed");
		BBPreclaim(e);
		return GDK_FAIL;
	}
	/* init: create extremes and set all to the zero pointer */
	if (slots > 0) {
		extremes = (oid*) GDKmalloc(slots*sizeof(oid));
		if (extremes == NULL) {
			GDKerror("aggrX3_minmax_oid(@1,@2,@3,@4,@5,@6,@7,@8,@9): extremes = GDKmalloc("OIDFMT"*"SZFMT") failed", slots, sizeof(oid));
			BBPreclaim(bn);
			return GDK_FAIL;
		}
		{ BUN i = 0; for (; i < slots; i++ ) extremes[i] = GDK_oid_@9; }
		hit = (bit*) GDKmalloc(slots*sizeof(bit));
		if (hit == NULL) {
			GDKerror("aggrX3_minmax_oid(@1,@2,@3,@4,@5,@6,@7,@8,@9): hit = GDKmalloc("OIDFMT"*"SZFMT") failed", slots, sizeof(bit));
			GDKfree(extremes);
			BBPreclaim(bn);
			return GDK_FAIL;
		}
		memset(hit, 0, slots*sizeof(bit));
	}
	/* scan b and replace totals by the extreme value (just pointers to vals in b) */
	bhsb = b->hseqbase - 1;
	if (b->T->nonil) {
		BATloop(b, p, q) {
			ptr t = BUNt@7(bi,p);
			oid *h = (oid*) @5;

			@3(r, bni, h);
			if (r != BUN_NONE) {
				oid *val = &extremes[@8];
				if ((*cmp)(t,val) @1 0) {
					*val = *(oid*)t;
					hit[@8] = 1;
				}
			}
		}
	} else {
		BATloop(b, p, q) {
			ptr t = BUNt@7(bi,p);
			oid *h = (oid*) @5;

			@3(r, bni, h);
			if (r != BUN_NONE) {
				oid *val = &extremes[@8];
				if (*val != *(oid*)nil) {
					if ((*cmp)(t,nil) == 0) {
						*val = *(oid*)nil;
					} else if ((*cmp)(t,val) @1 0) {
						*val = *(oid*)t;
						hit[@8] = 1;
					}
				}
			}
		}
	}
	/* insert the extreme values into the result */
	BATloop(bn, r, q) {
		oid *h = (oid*)BUNh@4(bni,r);
		oid val = hit[@8] ? extremes[@8] : *(oid*)nil;
		(void) h;	/* silence compiler about unused variable */
		/* trick: using a void head-type, only the tail are (over)written */
		ATOMput(bn->ttype, bn->theap, BUNtloc(bni,r), &val);
	}
@c

/*	extreme_typed
	@1:	min/max
	@2:	 < / >
	@3:	b/bn-tail-storage-type			sht/int/lng/any
	@4:	"loc" for fixsized b/bn-tail-type,	b/bn-tail-access
		"var" for varsized b/bn-tail-type
	@5:	ptr/oid					void/any
	@6:	max/min					initial result value
*/
@= extreme_typed
static int
aggrX3_@1_@3_@4_@5(BAT **ret, BAT *b, BAT *e)
{
	BAT *bn = BATnew(e->htype, BATttype(b), BATcount(e));
	BATiter bni = bat_iterator(bn), bi = bat_iterator(b);
	int (*cmp)(ptr,ptr);
	ptr nil;
	BUN off;
	@5 *extremes = NULL;
	bit *hit = NULL;
	BUN p, q, r;
	BUN slots;
	oid range;
	oid min, max;
	oid bhsb;

	if( bn == NULL) {
		GDKerror("aggrX3_@1_@3_@4_@5(): BATnew() failed");
		return GDK_FAIL;
	}
	cmp = BATatoms[bn->ttype].atomCmp;
	nil =  ATOMnilptr(bn->ttype);
	off =  BUNfirst(bn);
	*ret = NULL;

	ALGODEBUG THRprintf(GDKout, "#aggrX3_@1_@3_@4_@5[@2,@6](b=%s,e=%s);\n",
		BATgetId(b),BATgetId(e));
	/* init: prepare the result bat;
	 * trick: by using "tail-type" void, we only write the head column, here */
	@:init_result(void)@
	range = max - min + 1;

	/* scan b and replace totals by the extreme value (just pointers to vals in b) */
	slots = BATcount(e);
	if (e->htype == TYPE_void) {
		/* void lookup */
		if (b->htype == TYPE_void) {
			@:aggrX3_minmax_@5(@2,0,BUNfndVOID,var,&bhsb; bhsb++,@3,@4,r-off,@6)@
		} else {
			@:aggrX3_minmax_@5(@2,0,BUNfndVOID,var,BUNhloc(bi,p),@3,@4,r-off,@6)@
		}
	/* e->htype == TYPE_oid */
	} else if (range <= SMALL_AGGR_MAX) {
		/* array lookup */
		slots = range;
		if (b->htype == TYPE_void) {
			@:aggrX3_minmax_@5(@2,0,CHKrange,loc,&bhsb; bhsb++,@3,@4,(*(oid*)h)-min,@6)@
		} else {
			@:aggrX3_minmax_@5(@2,0,CHKrange,loc,BUNhloc(bi,p),@3,@4,(*(oid*)h)-min,@6)@
		}
	} else if (BATcount(e) <= SCAN_AGGR_MAX) {
		/* scan lookup */
		SCAN_aggr_init;
		if (b->htype == TYPE_void) {
			@:aggrX3_minmax_@5(@2,0,SCANfndOID,loc,&bhsb;bhsb++,@3,@4,r-off,@6)@
		} else {
			@:aggrX3_minmax_@5(@2,0,SCANfndOID,loc,BUNhloc(bi,p),@3,@4,r-off,@6)@
		}
	} else {
		/* hash lookup */
		if (b->htype == TYPE_void) {
			@:aggrX3_minmax_@5(@2,1,HASHfnd_oid,loc,&bhsb; bhsb++,@3,@4,r-off,@6)@
		} else {
			@:aggrX3_minmax_@5(@2,1,HASHfnd_oid,loc,BUNhloc(bi,p),@3,@4,r-off,@6)@
		}
	}
	*ret = bn;
bunins_failed:
	if (extremes)
		GDKfree(extremes);
	if (hit)
		GDKfree(hit);
	return *ret?GDK_SUCCEED:GDK_FAIL;
}
@c
/*	extreme
	@1:	min/max
	@2:	 < / >
	@3:	max/min
*/
@= extreme_h
int
CMDaggrX3_@1(BAT **ret, BAT *b, BAT *e);
@= extreme_c
@:extreme_typed(@1,@2,chr,loc,ptr,@3)@
@:extreme_typed(@1,@2,bte,loc,ptr,@3)@
@:extreme_typed(@1,@2,sht,loc,ptr,@3)@
@:extreme_typed(@1,@2,int,loc,ptr,@3)@
@:extreme_typed(@1,@2,lng,loc,ptr,@3)@
@:extreme_typed(@1,@2,any,loc,ptr,@3)@
@:extreme_typed(@1,@2,any,var,ptr,@3)@
@:extreme_typed(@1,@2,any,var,oid,@3)@

int
CMDaggrX3_@1(BAT **ret, BAT *b, BAT *e)
{
	int rtrn, tt = ATOMstorage(b->ttype);

	ALGODEBUG THRprintf(GDKout, "#CMDaggrX3_@1[@2,@3](b=%s,e=%s);\n",
		BATgetId(b),BATgetId(e));
	if (b->ttype == TYPE_void) {
		rtrn = aggrX3_@1_any_var_oid(ret, b, e);
	} else if (tt == TYPE_chr) {
		rtrn = aggrX3_@1_chr_loc_ptr(ret, b, e);
	} else if (tt == TYPE_bte) {
		rtrn = aggrX3_@1_bte_loc_ptr(ret, b, e);
	} else if (tt == TYPE_sht) {
		rtrn = aggrX3_@1_sht_loc_ptr(ret, b, e);
	} else if (b->ttype != TYPE_bat && (tt == TYPE_int || tt == TYPE_flt)) {
		/* ensure use of ATOMput for TYPE_bat */
		rtrn = aggrX3_@1_int_loc_ptr(ret, b, e);
	} else if (tt == TYPE_dbl || tt == TYPE_lng) {
		rtrn = aggrX3_@1_lng_loc_ptr(ret, b, e);
	} else if (b->tvarsized) {
		rtrn = aggrX3_@1_any_var_ptr(ret, b, e);
	} else {
		rtrn = aggrX3_@1_any_loc_ptr(ret, b, e);
	}
	return rtrn;
}
@h
@:extreme_h(min,<,max)@
@:extreme_h(max,>,min)@
@c
@:extreme_c(min,<,max)@
@:extreme_c(max,>,min)@

@- Count
@c
/*	aggrX3_count
		e-void-head	e-oid-head	e-oid-head	e-oid-head
		void-lookup	array-lookup	scan-lookup	hash-lookup

	@1:	0		1		0		0		use cnt-array?
	@2:	0		0		0		1		do BATprepareHash?
	@3:	BUNfndVOID	CHKrange	SCANfndOID	HASHfnd_oid	lookup
	@4:	var		loc		loc		loc		e/bn-head-access

	@5:	"BUNhloc(b,p)"	for  (oid) b-head-type,		b-head access
		"&bhsb; bhsb++" for (void) b-head-type

	@6:	BUNtloc(bn,r)	BUNtloc(bn,r)	&cnt[(*(oid*)h)-min]
								*dst: count in-place or in cnt-array ?
*/
@= aggrX3_count
	ALGODEBUG THRprintf(GDKout, "#aggrX3_count(@1,@2,@3,@4,@5,@6);\n");
	if (@1 && range > 0) {
		/* create tmp. cnt array */
		cnt = (wrd*) GDKmalloc(range*sizeof(wrd));
		if (cnt == NULL) {
			GDKerror("aggrX3_count(@1,@2,@3,@4,@5,@6): cnt = GDKmalloc("OIDFMT"*"SZFMT") failed", range, sizeof(wrd));
			BBPreclaim(bn);
			return GDK_FAIL;
		}
		memset(cnt, 0, range*sizeof(wrd));
	}
	if (@2 && BATprepareHash(bn)) {
		GDKerror("aggrX3_count(@1,@2,@3,@4,@5,@6): BATprepareHash(bn) failed");
		if (@1 && cnt)
			GDKfree(cnt);
		BBPreclaim(bn);
		return GDK_FAIL;
	}
	/* scan b, and increment counts in-place or in cnt-array */
	bhsb = b->hseqbase-1;
	btt = b->ttype;
	if (*ignore_nils && !b->T->nonil) {
		switch(ATOMstorage(btt)) {
		case TYPE_chr:
			@:aggrX3_count_loop(@1,@2,@3,@4,@5,@6,if (!simple_EQ(BUNtloc(bi,p),bt_nil,chr)))@
		case TYPE_bte:
			@:aggrX3_count_loop(@1,@2,@3,@4,@5,@6,if (!simple_EQ(BUNtloc(bi,p),bt_nil,bte)))@
		case TYPE_sht:
			@:aggrX3_count_loop(@1,@2,@3,@4,@5,@6,if (!simple_EQ(BUNtloc(bi,p),bt_nil,sht)))@
		case TYPE_int:
			@:aggrX3_count_loop(@1,@2,@3,@4,@5,@6,if (!simple_EQ(BUNtloc(bi,p),bt_nil,int)))@
		case TYPE_lng:
			@:aggrX3_count_loop(@1,@2,@3,@4,@5,@6,if (!simple_EQ(BUNtloc(bi,p),bt_nil,lng)))@
		case TYPE_flt:
			@:aggrX3_count_loop(@1,@2,@3,@4,@5,@6,if (!simple_EQ(BUNtloc(bi,p),bt_nil,flt)))@
		case TYPE_dbl:
			@:aggrX3_count_loop(@1,@2,@3,@4,@5,@6,if (!simple_EQ(BUNtloc(bi,p),bt_nil,dbl)))@
		default:
			if (b->tvarsized) {
				@:aggrX3_count_loop(@1,@2,@3,@4,@5,@6,if (!atom_EQ(BUNtvar(bi,p),bt_nil,btt)))@
			  } else {
				@:aggrX3_count_loop(@1,@2,@3,@4,@5,@6,if (!atom_EQ(BUNtloc(bi,p),bt_nil,btt)))@
			  }
		}
	} else {
		switch(ATOMstorage(btt)) {
		case TYPE_chr:
			@:aggrX3_count_loop(@1,@2,@3,@4,@5,@6,)@
		case TYPE_bte:
			@:aggrX3_count_loop(@1,@2,@3,@4,@5,@6,)@
		case TYPE_sht:
			@:aggrX3_count_loop(@1,@2,@3,@4,@5,@6,)@
		case TYPE_int:
			@:aggrX3_count_loop(@1,@2,@3,@4,@5,@6,)@
		case TYPE_lng:
			@:aggrX3_count_loop(@1,@2,@3,@4,@5,@6,)@
		case TYPE_flt:
			@:aggrX3_count_loop(@1,@2,@3,@4,@5,@6,)@
		case TYPE_dbl:
			@:aggrX3_count_loop(@1,@2,@3,@4,@5,@6,)@
		default:
			if (b->tvarsized) {
				@:aggrX3_count_loop(@1,@2,@3,@4,@5,@6,)@
			} else {
				@:aggrX3_count_loop(@1,@2,@3,@4,@5,@6,)@
			}
		}
	}
	if (@1 && cnt) {
		/* copy cnt array to final result */
		BATloop(bn, p, q) {
			oid h = (*(oid*) BUNh@4(bni,p)) - min;
			*(wrd*)BUNtloc(bni, p) = cnt[h];
		}
		GDKfree(cnt);
	}
@c
/*	aggrX3_count_loop
	@7:	if (!atom_EQ(BUNt{loc,var}(b,p),bt_nil,btt))		b-tail nil check
		if (!simple_EQ(BUNtloc(b,p),bt_nil,{chr,bte,sht,int,flt,lng,dbl}))
*/
@= aggrX3_count_loop
	ALGODEBUG THRprintf(GDKout, "#aggrX3_count_loop(@1,@2,@3,@4,@5,@6,@7);\n");
	BATloop(b, p, q) {
		oid *h = (oid*) @5;

		@3(r, bni, h);
		if (r != BUN_NONE) {
			@7 {
				wrd *dst = (wrd*) @6;
				(*dst)++;
			}
		}
	}
	break;
@h
int
CMDaggrX3_count(BAT **ret, BAT *b, BAT *e, bit *ignore_nils);
@c
int
CMDaggrX3_count(BAT **ret, BAT *b, BAT *e, bit *ignore_nils)
{
	BATiter bni, bi = bat_iterator(b);
	BAT *bn;
	wrd zero = 0, *cnt = NULL;
	BUN p, q, r;
	oid range;
	oid min, max;
	oid bhsb;
	int btt;
	ptr bt_nil = ATOMnilptr(b->ttype);

	ALGODEBUG THRprintf(GDKout, "#CMDaggrX3_count(b=%s,e=%s);\n", 
		BATgetId(b),BATgetId(e));

	if (e->htype == TYPE_void && 
	    e->ttype == TYPE_void &&
	    b->htype == TYPE_void && 
	    BATcount(b) == BATcount(e) &&
	    (!ignore_nils || b->T->nonil)) {
		/* simply return counts with one */
		wrd one = 1;
		bn = BATconst(b, TYPE_wrd, &one);
		*ret = bn;
		return GDK_SUCCEED;
	}

 	bn = BATnew(e->htype, TYPE_wrd, BATcount(e));
	bni = bat_iterator(bn);
	if( bn == NULL) {
		GDKerror("CMDaggrX3_count(): BATnew() failed");
		return GDK_FAIL;
	}

	/* init: set all counts to zero and calculate min/max oid */
	@:init_result(wrd)@
	range = max - min + 1;

	/* scan b, and calculate counts */
	if (e->htype == TYPE_void) {
		/* void lookup */
		if (b->htype == TYPE_void) {
			@:aggrX3_count(0,0,BUNfndVOID,var,&bhsb;bhsb++,BUNtloc(bni,r))@
		} else {
			@:aggrX3_count(0,0,BUNfndVOID,var,BUNhloc(bi,p),BUNtloc(bni,r))@
		}
		/* e->htype == TYPE_oid */
	} else if (range <= SMALL_AGGR_MAX) {
		/* array lookup */
		if (b->htype == TYPE_void) {
			@:aggrX3_count(1,0,CHKrange,loc,&bhsb;bhsb++,&cnt[(*(oid*)h)-min])@
		} else {
			@:aggrX3_count(1,0,CHKrange,loc,BUNhloc(bi,p),&cnt[(*(oid*)h)-min])@
		}
	} else if (BATcount(e) <= SCAN_AGGR_MAX) {
		/* scan lookup */
		SCAN_aggr_init;
		if (b->htype == TYPE_void) {
			@:aggrX3_count(0,0,SCANfndOID,loc,&bhsb;bhsb++,BUNtloc(bni,r))@
		} else {
			@:aggrX3_count(0,0,SCANfndOID,loc,BUNhloc(bi,p),BUNtloc(bni,r))@
		}
	} else {
		/* hash lookup */
		if (b->htype == TYPE_void) {
			@:aggrX3_count(0,1,HASHfnd_oid,loc,&bhsb;bhsb++,BUNtloc(bni,r))@
		} else {
			@:aggrX3_count(0,1,HASHfnd_oid,loc,BUNhloc(bi,p),BUNtloc(bni,r))@
		}
	}

	*ret = bn;
	return GDK_SUCCEED;
}

@- Size
@h
int
CMDaggrX3_size(BAT **ret, BAT *b, BAT *e);
@c
int
CMDaggrX3_size(BAT **ret, BAT *b, BAT *e)
{
	BAT *bn = BATnew(e->htype, TYPE_wrd, BATcount(e));
	BATiter bni = bat_iterator(bn), bi = bat_iterator(b), ei = bat_iterator(e);
	wrd zero = 0;
	BUN p, q, r;

	if( bn == NULL) {
		GDKerror("CMDaggrX3_size(): BATnew() failed");
		return GDK_FAIL;
	}
	/* init: set all sums to zero */
	bn->tsorted = bn->hsorted = 0;
	ALIGNsetH(bn, e);
	BATloop(e, p, q) {
		if (BUNfastins(bn, BUNhead(ei, p), &zero) == NULL) {
			BBPreclaim(bn);
			return GDK_FAIL;
		}
	}
	/* scan b, and add increment totals for true values */
	if (BATprepareHash(bn)) {
		GDKerror("CMDaggrX3_size(): BATprepareHash(bn) failed");
		BBPreclaim(bn);
		return GDK_FAIL;
	}
	BATloop(b, p, q) {
		if (*(bit *) BUNtloc(bi, p) == TRUE) {
			oid *h = (oid *) BUNhead(bi, p);

			BUNfndOID(r, bni, h);
			if (r != BUN_NONE) {
				wrd *dst = (wrd *) BUNtloc(bni, r);

				(*dst)++;
			}
		}
	}
	*ret = bn;
	return GDK_SUCCEED;
}

@}
