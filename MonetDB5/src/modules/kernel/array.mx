@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2005 CWI.
@' All Rights Reserved.

@f array
@a A.R. van Ballegooij
@* Basic array support

The array support library constructs the index arrays essential
for the Relational Algebra Model language.
The grid filler operation assumes that there is enough space.
The shift variant multiplies all elements with a constant factor.
It is a recurring operation for the RAM front-end and will save
an additional copying.

The optimization is captured in a contraction macro.


@mal
module array;

command grid(i:int,j:int,k:int,l:int) :bat[:void,:int] 
address ARRAYgrid
comment  "Generates an index BAT, (grpcount,grpsize,clustersize,offset)";

command grid(i:int,j:int,k:int,l:int,s:int) :bat[:void,:int] 
address ARRAYgridShift
comment  "Generates an index BAT, (grpcount,grpsize,clustersize,offset)
and shift all elements with a factor s";

command grid(b:bat[:void,:int],i:int,j:int,k:int,l:int) :bat[:void,:int] 
address ARRAYgridBAT
comment  "Fills an index BAT, (grpcount,grpsize,clustersize,offset)";

command grid(b:bat[:void,:int],i:int,j:int,k:int,l:int,s:int) :bat[:void,:int] 
address ARRAYgridBAT
comment  "Fills an index BAT, (grpcount,grpsize,clustersize,offset)
and shift all elemenets with a factor s";

#command *(b:bat[:void,:int],c:bat[:void,:int]):bat[:void,:int]
#address ARRAYmultiply_int_int
#comment "Calculate the array product";

command product(b:bat[:void,:any_1],c:bat[:void,:any_2]):bat[:any_1,:any_2]
address ARRAYproduct
comment "Produce an array product";

command project(b:bat[:void,:any],i:int):bat[:void,:int]
address ARRAYproject
comment "Fill an array representation with constants ";

pattern print(a:bat[:any_1,:any],b:bat[:any_1,:int]...) :void 
address ARRAYprint
comment "Prints an array, using 1 value bat and N aligned index bats";

@{
@- Implementation
@include ../mal/prelude.mx
@h

/*============================================================================*/
#ifndef __array_h__
#define __array_h__

#include <gdk.h>
#include <algebra.h>		/* to include BATmin and BATmax */

#define new_int_bat(b,s) {(b)=BATnew(TYPE_void,TYPE_int,(s)); \
                          if(b) BATseqbase((b),0);                  }
#define add_ints(b,n)    {(b)->batBuns->free+=(n)*sizeof(int);\
			  (b)->batCount+=n;	              \
                          BATkey(BATmirror((b)),0);           \
                          (b)->tsorted = 0;                   }
#define get_int_ptr(b)   ((int*)(BUNfirst((b))))

/* The maximum number of dimensions that the print-function can handle... */
#define MAX_ARRAY_DIM 16

#endif
/*============================================================================*/
@c
/*============================================================================*/
#include "array.h"
#include "gdk.h"
#include <math.h>
#include <time.h>

mal_export str ARRAYgrid(int *ret, int *groups, int *groupsize, int *clustersize
, int *offset);
mal_export str ARRAYgridShift(int *ret, int *groups, int *groupsize, int *clustersize, int *offset, int *shift);
mal_export str ARRAYgridBAT(int *ret, int *bid, int *groups, int *groupsize, int
 *clustersize, int *offset);
mal_export str ARRAYgridBATshift(int *ret, int *bid, int *groups, int *groupsize
, int *clustersize, int *offset, int *shift);
mal_export str ARRAYproduct(int *ret, int *bid, int *rid);
mal_export str ARRAYproject(int *ret, int *bid, int *cst);
mal_export str ARRAYprint(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);

/*----------------------------------------------------------------------------*/

int
fillgrid(BAT **out, int *groups, int *groupsize, int *clustersize, int *offset, int *shift)
{
	register int *ptr;
	int i = *groups;
	int n = *groupsize + *offset;
	int r = *clustersize;
	int o = *offset;
	int s = *shift;

#ifdef EXCESSIVE_DEBUGGING
	fprintf(stderr, "[grid] (%d,%d,%d,%d)", i, n, r, o);
#endif

	ptr = get_int_ptr(*out);

	while (i-- > 0) {
		register int ni = o;

		while (ni < n) {
			register int ri = r;

			while (ri-- > 0)
				(*(ptr ++)) = ni * s;
			ni++;
		}
	}

#ifdef EXCESSIVE_DEBUGGING
	fprintf(stderr, "- done\n");
#endif

	return GDK_SUCCEED;
}

int
grid(BAT **out, int *groups, int *groupsize, int *clustersize, int *offset)
{
	int i = *groups;
	int n = *groupsize + *offset;
	int r = *clustersize;
	int o = *offset;
	int s = 1;

#ifdef EXCESSIVE_DEBUGGING
	fprintf(stderr, "[grid] (%d,%d,%d,%d)", i, n, r, o);
#endif

	new_int_bat(*out, (i * (n - o) * r));
	if (*out == 0)
		return GDK_FAIL;
	add_ints(*out, (i * (n - o) * r));
	return fillgrid(out, groups, groupsize, clustersize, offset, &s);
}

int
gridShift(BAT **out, int *groups, int *groupsize, int *clustersize, int *offset, int *shift)
{
	int i = *groups;
	int n = *groupsize + *offset;
	int r = *clustersize;
	int o = *offset;

#ifdef EXCESSIVE_DEBUGGING
	fprintf(stderr, "[grid] (%d,%d,%d,%d)", i, n, r, o);
#endif

	new_int_bat(*out, (i * (n - o) * r));
	if (*out == 0)
		return GDK_FAIL;
	add_ints(*out, (i * (n - o) * r));
	return fillgrid(out, groups, groupsize, clustersize, offset, shift);
}

/*---------------------------------------------------------------------------*/
/*
   memory-hungry function;
   it internally builds the index to be able to print the array in-order.
*/

int
print_array(BAT *val, ...)
{
	va_list ap;
	BAT *tmp, *batptr[MAX_ARRAY_DIM];
	int *minvector;
	int *idxvector;
	int *maxvector;
	int *lenvector;
	oid *arrayindex;
	int i, dims;
	size_t j, c;
	stream *st = GDKout;
	int type_id = BATttype(val);

	va_start(ap, val);
	dims = 0;
	while ((tmp = va_arg(ap, BAT *)) != NULL) {
		if (dims == MAX_ARRAY_DIM) {
			GDKerror("print_array: Error, too high dimensionality.\n");
			goto exit_err_none;
		}
		batptr[dims++] = tmp;
	}
	if (dims == 0) {
		GDKerror("print_array: Error, no index bats provided.\n");
		goto exit_err_none;
	}
	va_end(ap);

#ifdef EXCESSIVE_DEBUGGING
	fprintf(stderr, "[PRINT_ARRAY] Dims = %d\n", dims);
#endif

	minvector = GDKmalloc(sizeof(ptr) * dims);
	idxvector = GDKmalloc(sizeof(int) * dims);
	maxvector = GDKmalloc(sizeof(ptr) * dims);
	lenvector = GDKmalloc(sizeof(ptr) * dims);

	c = 1;
	j = BATcount(val);
	for (i = 0; i < dims; i++) {
		if (BATttype(batptr[i]) != TYPE_int) {
			GDKerror("print_array: Index %d error, not int type\n", i);
			goto exit_err_part;
		}
		if (BATcount(batptr[i]) != j) {
			GDKerror("print_array: Index %d error, count doesn't match\n", i);
			goto exit_err_part;
		}

		BATmin(batptr[i], &(minvector[i]));
		BATmax(batptr[i], &(maxvector[i]));
		lenvector[i] = maxvector[i] - minvector[i] + 1;
		c *= lenvector[i];
#ifdef EXCESSIVE_DEBUGGING
		fprintf(stderr, "[PRINT_ARRAY] Axis %d = %d..%d\n", i, minvector[i], maxvector[i]);
#endif
	}

	if (c != j) {
		GDKerror("print_array: array size does not match array count\n");
		goto exit_err_part;
	}
	arrayindex = GDKmalloc(sizeof(oid) * c);

	/* Iterate over the first index BAT.              */
	/* And fetch additional indices (for a given oid) */
	/* building the full M-D structure (of oid's).    */
	{
		register BUN p, q;

		p = BUNfirst(batptr[0]);
		q = BUNlast(batptr[0]);
		while (p < q) {
			register oid *o = (oid *) BUNhead(batptr[0], p);
			register int offset;

			offset = *((int *) BUNtail(batptr[0], p)) - minvector[0];
			for (i = 1; i < dims; i++) {
				register BUN p = BUNfnd(batptr[i], o);

				if (p == NULL) {
					GDKerror("print_array: Index %d missing for oid %d.\n", i, *o);
					goto exit_err_full;
				}
				offset = (offset * lenvector[i]) + ((*((int *) p)) - minvector[i]);
			}
			arrayindex[offset] = *o;
			p = BUNnext(batptr[0], p);
		}
	}

	/* Iterate over all valid indices             */
	/* (note: normalized to [0..l-1] ranges !)    */
	/* And print the values within the 'correct'  */
	/* bracket structure...                       */
#ifdef EXCESSIVE_DEBUGGING
	fprintf(stderr, "[PRINT_ARRAY] ");
#endif
	for (i = 0; i < dims; i++)
		idxvector[i] = 0;
	while (idxvector[dims - 1] < lenvector[dims - 1]) {
		int offset;

		for (i = 0; i < dims; i++) {
			if (idxvector[i] != 0) {
#ifdef EXCESSIVE_DEBUGGING
				fprintf(stderr, ",");
#endif
				stream_printf(st, ",");
				break;
			}
		}
		i = 0;
		while (idxvector[i] == 0 && i < dims) {
#ifdef EXCESSIVE_DEBUGGING
			fprintf(stderr, "[");
#endif
			stream_printf(st, "[");
			i++;
		}
		for (offset = idxvector[0], i = 1; i < dims; i++) {
			offset = (offset * lenvector[i]) + idxvector[i];
		}
		{
			register BUN p = BUNfnd(val, &arrayindex[offset]);

			if (p == NULL) {
				GDKerror("print_array: Value missing for oid %d.\n", arrayindex[offset]);
				goto exit_err_full;
			}
#ifdef EXCESSIVE_DEBUGGING
			fprintf(stderr, "%d\@0", arrayindex[offset]);
#endif
			ATOMprint(type_id, BUNtail(val, p), st);
			if (stream_errnr(st))
				goto exit_err_full;
		}
		i = 0;
		while ((++idxvector[i]) == lenvector[i] && i < dims) {
#ifdef EXCESSIVE_DEBUGGING
			fprintf(stderr, "]");
#endif
			stream_printf(st, "]");
			if (i < dims - 1) {
				idxvector[i] = 0;
				i++;
			}
		}
	}
#ifdef EXCESSIVE_DEBUGGING
	fprintf(stderr, "\n");
#endif
	stream_printf(st, "\n");

	/* Exit strategies... */
	GDKfree(arrayindex);
	GDKfree(maxvector);
	GDKfree(idxvector);
	GDKfree(minvector);
	GDKfree(lenvector);
	return GDK_SUCCEED;

      exit_err_full:
	GDKfree(arrayindex);
      exit_err_part:
	GDKfree(maxvector);
	GDKfree(idxvector);
	GDKfree(minvector);
	GDKfree(lenvector);
      exit_err_none:
	return GDK_FAIL;
}

/*============================================================================*/
@mil

PROC cons(int n,any::1 v) : bat[void,any::1] {
    return project(grid(1,n,1,0),v);
}
ADDHELP("cons", "A.R. van Ballegooij", "Sep 20 2003",
"generates a bat with a constant column", "array");

PROC concat(bat[oid,any::1] a,bat[oid,any::1] b,int o) : bat[oid,any::1] {
    return access(insert(access(copy(a),BAT_WRITE),
                  reverse([oid]([+]([int](reverse(b)),o))))
          ,BAT_READ);
}
ADDHELP("concat", "A.R. van Ballegooij", "Sep 20 2003",
"Adds 'offset' two second arrays indexes and merges tables", "array");

if (mod() = "main"){
	print("Array module loaded...");
}
@+
The M5 wrapper code
@c
#include "mal.h"
str
ARRAYgrid(int *ret, int *groups, int *groupsize, int *clustersize, int *offset)
{
	BAT *bn;

	if (grid(&bn, groups, groupsize, clustersize, offset) == GDK_FAIL)
		return throwMessage("array.grid", "Failed to create the grid\n");
	BBPincref(*ret = bn->batCacheid, TRUE);
	BBPunfix(*ret);
	return MAL_SUCCEED;
}

str
ARRAYgridShift(int *ret, int *groups, int *groupsize, int *clustersize, int *offset, int *shift)
{
	BAT *bn;

	if (gridShift(&bn, groups, groupsize, clustersize, offset, shift) == GDK_FAIL)
		return throwMessage("array.grid", "Failed to create the grid\n");
	BBPincref(*ret = bn->batCacheid, TRUE);
	BBPunfix(*ret);
	return MAL_SUCCEED;
}

str
ARRAYgridBAT(int *ret, int *bid, int *groups, int *groupsize, int *clustersize, int *offset)
{
	BAT *bn;
	int shift = 1;

	if ((bn = BATdescriptor(*bid)) == NULL) {
		return throwMessage("array.grid", "Cannot access descriptor");
	}

	if (fillgrid(&bn, groups, groupsize, clustersize, offset, &shift) == GDK_FAIL)
		return throwMessage("array.grid", "Failed to create the grid\n");
	BBPincref(*ret = bn->batCacheid, TRUE);
	BBPunfix(*ret);
	return MAL_SUCCEED;
}

str
ARRAYgridBATshift(int *ret, int *bid, int *groups, int *groupsize, int *clustersize, int *offset, int *shift)
{
	BAT *bn;

	if ((bn = BATdescriptor(*bid)) == NULL) {
		return throwMessage("array.grid", "Cannot access descriptor");
	}
	if (fillgrid(&bn, groups, groupsize, clustersize, offset, shift) == GDK_FAIL)
		return throwMessage("array.grid", "Failed to create the grid\n");
	BBPincref(*ret = bn->batCacheid, TRUE);
	BBPunfix(*ret);
	return MAL_SUCCEED;
}

@-
@= arraymultiply
mal_export str ARRAYmultiply_@1_@2(int *ret, int *bid, int *rid);
str
ARRAYmultiply_@1_@2(int *ret, int *bid, int *rid){
	BAT *bn, *b, *r;
	BUN p,q, s,t;
	int x1,x2;
	@2 val;
	oid o= oid_nil;

    if( (b= BATdescriptor(*bid)) == NULL ){
         return throwMessage("array.*", "Cannot access descriptor");
    }
    if( (r= BATdescriptor(*rid)) == NULL ){
		BBPunfix(b->batCacheid);
         return throwMessage("array.*", "Cannot access descriptor");
    }
	bn= BATnew(TYPE_void, TYPE_@2, BATcount(b)*BATcount(r));
	BATseqbase(bn,0);

	BATloopFast(b,p,q,x1){
		BATloopFast(r,s,t,x2){
			val = (*(@1*) BUNtail(b,p)) * (*(@1*)BUNtail(r,s));
			BUNfastins(bn,&o,&val);
		}
	}
	BBPincref( *ret= bn->batCacheid, TRUE);
	BBPunfix(*ret);
	BBPunfix(b->batCacheid);
	BBPunfix(r->batCacheid);
	return MAL_SUCCEED;
}
@c
@:arraymultiply(sht,lng)@
@:arraymultiply(sht,int)@
@:arraymultiply(int,int)@
@:arraymultiply(int,lng)@
@:arraymultiply(lng,lng)@

str
ARRAYproduct(int *ret, int *bid, int *rid)
{
	BAT *bn, *b, *r;
	BUN p, q, s, t;
	int x1, x2;

	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("array.product", "Cannot access descriptor");
	}
	if ((r = BATdescriptor(*rid)) == NULL) {
		BBPunfix(b->batCacheid);
		return throwMessage("array.product", "Cannot access descriptor");
	}
	if (BATcount(b) > BATcount(r) || (BATcount(b) % BATcount(r)) != BATcount(b)) {
		BBPunfix(b->batCacheid);
		BBPunfix(r->batCacheid);
		return throwMessage("array.product", "Illegal argument bounds");
	}
	bn = BATnew(b->ttype, r->ttype, BATcount(r));

	BATloopFast(r, s, t, x2) {
		BATloopFast(b, p, q, x1) {
			BUNfastins(bn, BUNtail(b, p), BUNtail(r, s));
			s += x2;
		}
		s -= x2;
	}
	BBPincref(*ret = bn->batCacheid, TRUE);
	BBPunfix(*ret);
	BBPunfix(b->batCacheid);
	BBPunfix(r->batCacheid);
	return MAL_SUCCEED;
}

str
ARRAYproject(int *ret, int *bid, int *cst)
{
	BAT *bn, *b;
	int *ptr, i;

	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("array.project", "Cannot access descriptor");
	}
	new_int_bat(bn, BATcount(b));
	if (bn == 0)
		return throwMessage("array.project", "failed to create array\n");
	add_ints(bn, i = BATcount(b));
	ptr = get_int_ptr(bn);

	while (i-- > 0)
		(*(ptr ++)) = *cst;
	BBPincref(*ret = bn->batCacheid, TRUE);
	BBPunfix(*ret);
	return MAL_SUCCEED;
}

str
ARRAYprint(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	(void) mb;
	(void) stk;
	(void) pci;
	return throwMessage("array.print", "not supported yet\n");
}
