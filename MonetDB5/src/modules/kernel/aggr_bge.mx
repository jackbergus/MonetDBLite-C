@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
@' Copyright August 2008-2009 MonetDB B.V.
@' All Rights Reserved.

@f aggr_bge
@a S. Manegold 
@v 1.0
@+ Aggregates Module

@{

@+ Implementation
These implementations need just one scan and a simple hash-maintained data
structure to compute a group of common aggregates.
@c
#include "mal_config.h"
#include <gdk.h>
#include <gdk_scanselect.h>	/* for type-specific HT_bunfastins_nocheck_noinc(), until they're moved to gdk.mx */
#include "aggr.h"
#include "aggr_be.h"

@- Result initialization
/*	init_result
	@1:	tail-type:	bte/sht/int/wrd/lng/flt/dbl / any / void
*/
@include aggr_ri.mx

@- Sum, Product & Average
@c
/*	aggrX3_sum3
		e-void-head	e-oid-head	e-oid-head	e-oid-head
		void-lookup	array-lookup	scan-lookup	hash-lookup

	@1:	0		1		0		0		use sums-array?
	@2:	0		0		0		1		do BATprepareHash?
	@3:	BUNfndVOID	CHKrange	SCANfndOID	HASHfnd_oid	lookup
	@4:	var		loc		loc		loc		e/bn-head-access

	@5:	"BUNhloc(b,p)"	for  (oid) b-head-type,		b-head access
		"&bhsb; bhsb++" for (void) b-head-type

	@6:	bte / sht / int / wrd / lng / flt / dbl		b/bn-tail-type

#	not used any more as the result-type needs an argument
#	@7:	"loc" for fixsized b/bn-tail-type,		b/bn-tail-access
#		"var" for varsized b/bn-tail-type		(only loc used currently)

	@7:	BUNt@7(bn,r)	BUNt@7(bn,r)	&sums[(*(oid*)h)-min]
								*dst: sum in-place or in sums-array ?
	@8:	<empty> / if (w >= base && w < end)		check head (oid) ranges in case b & g
								are not void-headed and aligned
	@9:	result type
	@[10]:		r-off		(*(oid*)h)-min	index in hit array
*/
@= aggrX3_sum3
	ALGODEBUG THRprintf(GDKout, "#aggrX3_sum3(@1,@2,@3,@4,@5,@6,@7,@8,@9,@[10]);\n");
	if (@1 && range > 0) {
		/* create tmp. sums array */
		oid i;
		sums = (@9*) GDKmalloc(range*sizeof(@9));
		if (sums == NULL) {
			GDKerror("aggrX3_sum3(@1,@2,@3,@4,@5,@6,@6,@7,@8,@9,@[10]): sums = GDKmalloc("OIDFMT"*"SZFMT") failed", range, sizeof(@9));
			BBPreclaim(bn);
			return GDK_FAIL;
		}
		for (i = 0; i < range; i++)
			sums[i] = zero;
	}
	if (@2 && BATprepareHash(bn)) {
		GDKerror("aggrX3_sum3(@1,@2,@3,@4,@5,@6,@6,@7,@8,@9,@[10]): BATprepareHash(bn) failed");
		if (@1 && sums)
			GDKfree(sums);
		BBPreclaim(bn);
		return GDK_FAIL;
	}
	if (slots > 0) {
		hit = (bit*) GDKmalloc(slots*sizeof(bit));
		if (hit == NULL) {
			GDKerror("aggrX3_sum3(@1,@2,@3,@4,@5,@6,@7,@8,@9,@[10]): hit = GDKmalloc("OIDFMT"*"SZFMT") failed", slots, sizeof(bit));
			if (@1 && sums)
				GDKfree(sums);
			BBPreclaim(bn);
			return GDK_FAIL;
		}
		memset(hit, 0, slots*sizeof(bit));
	}
	/* scan b & g, and add values to sums in-place or in sums-array */
	base = BUNfirst(g);
	offset = (ssize_t) base - (ssize_t) g->hseqbase;
	end = base + BATcount(g);
	(void) end;		/* keep compilers happy */
	bhsb = b->hseqbase;
	if (b->T->nonil) {
		BATloop(b, p, q) {
			@6 *t = (@6*) BUNtloc(bi,p);
			oid v = *(oid*) @5;

			w = (BUN) (offset + v);
			@8 {
				oid *h = (oid*) BUNtail(gi, w);

				@3(r, bni, (oid*)h);
				if (r != BUN_NONE) {
					@9 *dst = (@9*) @7;
					*dst += (@9) *t;
					hit[@[10]] = 1;
				}
			}
		}
	} else {
		BATloop(b, p, q) {
			@6 *t = (@6*) BUNtloc(bi,p);
			oid v = *(oid*) @5;

			w = (BUN) (offset + v);
			@8 {
				oid *h = (oid*) BUNtail(gi, w);

				@3(r, bni, (oid*)h);
				if (r != BUN_NONE) {
					@9 *dst = (@9*) @7;
					if (*dst != @9_nil) {
						if (*t == @6_nil) {
							*dst = @9_nil;
						} else {
							*dst += (@9) *t;
							hit[@[10]] = 1;
						}
					}
				}
			}
		}
	}
	if (@1) {
	   if (sums) {
		/* copy sums array to final result */
		BATloop(bn, p, q) {
			oid h = (*(oid*) BUNh@4(bni,p)) - min;
			@9 *dst = (@9*)BUNtloc(bni, p);
			if (hit[h] == 0) {
				*dst = @9_nil;
			} else {
				*dst = sums[h];
			}
		}
		GDKfree(sums);
	    }
	} else {
		BUN yy = 0;
		BATloop(bn, p, q) {
			@9 *dst = (@9*)BUNtloc(bni, p);
			if (hit[yy] == 0) {
				*dst = @9_nil;
			}
			yy++;
		}
	}
	if (hit)
		GDKfree(hit);
@
@c
/*	aggrX3_prod3
		e-void-head	e-oid-head	e-oid-head	e-oid-head
		void-lookup	array-lookup	scan-lookup	hash-lookup

	@1:	0		1		0		0		use prods-array?
	@2:	0		0		0		1		do BATprepareHash?
	@3:	BUNfndVOID	CHKrange	SCANfndOID	HASHfnd_oid	lookup
	@4:	var		loc		loc		loc		e/bn-head-access

	@5:	"BUNhloc(b,p)"	for  (oid) b-head-type,		b-head access
		"&bhsb; bhsb++" for (void) b-head-type

	@6:	bte / sht / int / wrd / lng / flt / dbl		b/bn-tail-type

#	not used any more as the result-type needs an argument
#	@7:	"loc" for fixsized b/bn-tail-type,		b/bn-tail-access
#		"var" for varsized b/bn-tail-type		(only loc used currently)

	@7:	BUNt@7(bn,r)	BUNt@7(bn,r)	&prods[(*(oid*)h)-min]
								*dst: prod in-place or in prods-array ?
	@8:	<empty> / if (w >= base && w < end)		check head (oid) ranges in case b & g
								are not void-headed and aligned
	@9:	result type
	@[10]:		r-off		(*(oid*)h)-min	index in hit array
*/
@= aggrX3_prod3
	ALGODEBUG THRprintf(GDKout, "#aggrX3_prod3(@1,@2,@3,@4,@5,@6,@7,@8,@9,@[10]);\n");
	if (@1 && range > 0) {
		/* create tmp. prods array */
		oid i;
		prods = (@9*) GDKmalloc(range*sizeof(@9));
		if (prods == NULL) {
			GDKerror("aggrX3_prod3(@1,@2,@3,@4,@5,@6,@6,@7,@8,@9,@[10]): prods = GDKmalloc("OIDFMT"*"SZFMT") failed", range, sizeof(@9));
			BBPreclaim(bn);
			return GDK_FAIL;
		}
		for (i = 0; i < range; i++)
			prods[i] = zero;
	}
	if (@2 && BATprepareHash(bn)) {
		GDKerror("aggrX3_prod3(@1,@2,@3,@4,@5,@6,@6,@7,@8,@9,@[10]): BATprepareHash(bn) failed");
		if (@1 && prods)
			GDKfree(prods);
		BBPreclaim(bn);
		return GDK_FAIL;
	}
	if (slots > 0) {
		hit = (bit*) GDKmalloc(slots*sizeof(bit));
		if (hit == NULL) {
			GDKerror("aggrX3_prod3(@1,@2,@3,@4,@5,@6,@7,@8,@9,@[10]): hit = GDKmalloc("OIDFMT"*"SZFMT") failed", slots, sizeof(bit));
			if (@1 && prods)
				GDKfree(prods);
			BBPreclaim(bn);
			return GDK_FAIL;
		}
		memset(hit, 0, slots*sizeof(bit));
	}
	/* scan b & g, and add values to prods in-place or in prods-array */
	base = BUNfirst(g);
	offset = (ssize_t) base - (ssize_t) g->hseqbase;
	end = base + BATcount(g);
	(void) end;		/* keep compilers happy */
	bhsb = b->hseqbase;
	if (b->T->nonil) {
		BATloop(b, p, q) {
			@6 *t = (@6*) BUNtloc(bi,p);
			oid v = *(oid*) @5;

			w = (BUN) (offset + v);
			@8 {
				oid *h = (oid*) BUNtail(gi, w);

				@3(r, bni, (oid*)h);
				if (r != BUN_NONE) {
					@9 *dst = (@9*) @7;
					*dst *= (@9) *t;
					hit[@[10]] = 1;
				}
			}
		}
	} else {
		BATloop(b, p, q) {
			@6 *t = (@6*) BUNtloc(bi,p);
			oid v = *(oid*) @5;

			w = (BUN) (offset + v);
			@8 {
				oid *h = (oid*) BUNtail(gi, w);

				@3(r, bni, (oid*)h);
				if (r != BUN_NONE) {
					@9 *dst = (@9*) @7;
					if (*dst != @9_nil) {
						if (*t == @6_nil) {
							*dst = @9_nil;
						} else {
							*dst *= (@9) *t;
							hit[@[10]] = 1;
						}
					}
				}
			}
		}
	}
	if (@1) {
	    if (prods) {
		/* copy prods array to final result */
		BATloop(bn, p, q) {
			oid h = (*(oid*) BUNh@4(bni,p)) - min;
			@9 *dst = (@9*)BUNtloc(bni, p);
			if (hit[h] == 0) {
				*dst = @9_nil;
			} else {
				*dst = prods[h];
			}
		}
		GDKfree(prods);
	    }
	} else {
		BUN yy = 0;
		BATloop(bn, p, q) {
			@9 *dst = (@9*)BUNtloc(bni, p);
			if (hit[yy] == 0) {
				*dst = @9_nil;
			}
			yy++;
		}
	}
	if (hit)
		GDKfree(hit);
@
@c
/*	aggrX3_avg3
		e-void-head	e-oid-head	e-oid-head	e-oid-head
		void-lookup	array-lookup	scan-lookup	hash-lookup

	@1:	0		1		0		0		use sums-array?
	@2:	0		0		0		1		do BATprepareHash?
	@3:	BUNfndVOID	CHKrange	SCANfndOID	HASHfnd_oid	lookup
	@4:	var		loc		loc		loc		e/bn-head-access

	@5:	"BUNhloc(b,p)"	for  (oid) b-head-type,		b-head access
		"&bhsb; bhsb++" for (void) b-head-type

	@6:	bte / sht / int / wrd / lng / flt / dbl		b/bn-tail-type
	@7:	"loc" for fixsized b/bn-tail-type,		b/bn-tail-access
		"var" for varsized b/bn-tail-type		(only loc used currently)

	@8:	BUNt@7(bn,r)	BUNt@7(bn,r)	&sums[(*(oid*)h)-min]
								*dst: sum in-place or in sums-array ?

	@9:		r-off		(*(oid*)h)-min	index in cnt array
*/
@= aggrX3_avg3
	ALGODEBUG THRprintf(GDKout, "#aggrX3_avg3(@1,@2,@3,@4,@5,@6,@7,@8,@9);\n");
	if (@1 && range > 0) {
		/* create tmp. sums array */
		oid i;
		sums = (dbl*) GDKmalloc(range*sizeof(dbl));
		if (sums == NULL) {
			GDKerror("aggrX3_avg3(@1,@2,@3,@4,@5,@6,@6,@7,@8,@9): sums = GDKmalloc("OIDFMT"*"SZFMT") failed", range, sizeof(dbl));
			BBPreclaim(bn);
			return GDK_FAIL;
		}
		for (i = 0; i < range; i++)
			sums[i] = zero;
	}
	if (@2 && BATprepareHash(bn)) {
		GDKerror("aggrX3_avg3(@1,@2,@3,@4,@5,@6,@6,@7,@8,@9): BATprepareHash(bn) failed");
		if (@1 && sums)
			GDKfree(sums);
		BBPreclaim(bn);
		return GDK_FAIL;
	}
	if (slots > 0) {
		cnt = (BUN*) GDKmalloc(slots*sizeof(cnt[0]));
		if (cnt == NULL) {
			GDKerror("aggrX3_avg3(@1,@2,@3,@4,@5,@6,@7,@8,@9): cnt = GDKmalloc("OIDFMT"*"SZFMT") failed", slots, sizeof(cnt[0]));
			if (@1 && sums)
				GDKfree(sums);
			BBPreclaim(bn);
			return GDK_FAIL;
		}
		memset(cnt, 0, slots*sizeof(cnt[0]));
	}
	/* scan b & g, adding sums, and incrementing counts */
	base = BUNfirst(g);
	offset = (ssize_t) base - (ssize_t) g->hseqbase;
	end = base + BATcount(g);
	(void) end;		/* keep compilers happy */
	bhsb = b->hseqbase;
	if (b->T->nonil) {
		BATloop(b, p, q) {
			@6 *t = (@6*) BUNt@7(bi,p);
			oid v = *(oid*) @5;

			w = (BUN) (offset + v);
			if (w >= base && w < end) {
				oid *h = (oid*) BUNtail(gi, w);

				@3(r, bni, (oid*)h);
				if (r != BUN_NONE) {
					dbl *dst = (dbl*) @8;
					*dst += *t;
					cnt[@9]++;
				}
			}
		}
	} else {
		BATloop(b, p, q) {
			@6 *t = (@6*) BUNt@7(bi,p);
			oid v = *(oid*) @5;

			w = (BUN) (offset + v);
			if (w >= base && w < end) {
				oid *h = (oid*) BUNtail(gi, w);

				@3(r, bni, (oid*)h);
				if (r != BUN_NONE) {
					dbl *dst = (dbl*) @8;
					if (*dst != dbl_nil) {
						if (*t == @6_nil) {
							*dst = dbl_nil;
						} else {
							*dst += *t;
						}
						cnt[@9]++;
					}
				}
			}
		}
	}
	/* postprocess by dividing sums by counts */
	if (@1) {
	    if (sums) {
		/* sums in sums-array */
		BATloop(bn, p, q) {
			oid h = (*(oid*) BUNh@4(bni,p)) - min;
			dbl *dst = (dbl*) BUNt@7(bni, p);
			if (cnt[h] == 0 || sums[h] == dbl_nil) {
				*dst = dbl_nil;
			} else {
				*dst = sums[h]/cnt[h];
			}
		}
		GDKfree(sums);
	    }
	} else {
		/* sums in-place */
		BUN yy = 0;
		BATloop(bn, p, q) {
			dbl *dst = (dbl*) BUNt@7(bni, p);
			if (cnt[yy] == 0) {
				*dst = dbl_nil;
			} else if (*dst != dbl_nil) {
				*dst /= cnt[yy];
			}
			yy++;
		}

	}
	if (cnt)
		GDKfree(cnt);
@c

/*	arithsum3
	@6:	bte / sht / int / wrd / lng / flt / dbl		b/bn-tail-type

#	not used any more
#	@7:	"loc" for fixsized b/bn-tail-type,	b/bn-tail-access
#		"var" for varsized b/bn-tail-type	(only loc used currently)

	@9:	result type
*/
@= arithsum3_h
int
CMDaggrX3_sum3_@1_@2(BAT **ret, BAT *b, BAT *g, BAT *e);
@= arithsum3_c

static int
aggrX3_sum3_@1_@2_EarrayBvoidGvoid (BAT *bn, BAT *b, BAT *g, BAT *e, oid range, oid min, oid max)
{
	@2 zero = (@2) 0, *sums = NULL;
	bit *hit = NULL;
	BUN slots = range;
	BUN p, q, r;
	oid bhsb;
	BUN base, end, w;
	ssize_t offset;
	BATiter bni = bat_iterator(bn), bi = bat_iterator(b), gi = bat_iterator(g);

	ALGODEBUG THRprintf(GDKout, "#aggrX3_sum3_@1_@2_EarrayBvoidGvoid(bn=%s,b=%s,g=%s,e=%s,range=" OIDFMT ",min=" OIDFMT ",max=" OIDFMT ");\n",
				BATgetId(bn),BATgetId(b),BATgetId(g),BATgetId(e),
				range,min,max);
	@:aggrX3_sum3(1,0,CHKrange,loc,&bhsb;bhsb++,@1,&sums[(*(oid*)h)-min],,@2,(*(oid*)h)-min)@
	return GDK_SUCCEED;
}

int
CMDaggrX3_sum3_@1_@2(BAT **ret, BAT *b, BAT *g, BAT *e)
{
	BAT *bn;
	BATiter bni, bi = bat_iterator(b), gi = bat_iterator(g);
	@2 zero = (@2) 0, *sums = NULL;
	bit *hit = NULL;
	BUN slots, off;
	BUN p, q, r;
	oid range;
	oid min, max;
	oid bhsb;
	BUN base, end, w;
	ssize_t offset;

	ALGODEBUG THRprintf(GDKout, "#CMDaggrX3_sum3_@1_@2(b=%s,g=%s,e=%s);\n",
		BATgetId(b),BATgetId(g), BATgetId(e));
/*	ERRORcheck((BATcount(b)!=BATcount(g)), "CMDaggrX3_sum3_@1: BATs b & g must be of equal size.\n");	*/
	ERRORcheck((g->htype == TYPE_void) && (g->hseqbase == oid_nil) && (BATcount(g) > 0), "CMDaggrX3_sum3_@1: head of BAT g must not be nil.\n");

	if((g->hseqbase == oid_nil) || (!BAThdense(g)) || (!(BAThordered(b)&1)) || (!g->hkey)) {
		BAT *gb = BATjoin(BATmirror(g),b,BUN_NONE);
		int rtrn = CMDaggrX3_sum_@1_@2(ret, gb, e);
		BBPunfix(gb->batCacheid);
		return rtrn;
	}

	bn = BATnew(e->htype, TYPE_@2, BATcount(e));
	if( bn == NULL) {
		GDKerror("CMDaggrX3_sum3_@1_@2(): BATnew() failed");
		return GDK_FAIL;
	}
	bni = bat_iterator(bn);
	off = BUNfirst(bn);

	*ret = bn;

	/* init: set all sums to zero and calculate min/max oid */
	@:init_result(@2)@
	range = max - min + 1;

	/* scan b & g, and calculate sums */
	slots = BATcount(e);
	if (e->htype == TYPE_void) {
		/* void lookup */
		if (b->htype == TYPE_void) {
			if ((g->htype == TYPE_void)&&(BATcount(b)==BATcount(g))&&(b->hseqbase==g->hseqbase)) {
				@:aggrX3_sum3(0,0,BUNfndVOID,var,&bhsb;bhsb++,@1,BUNtloc(bni,r),,@2,r-off)@
			} else {
				@:aggrX3_sum3(0,0,BUNfndVOID,var,&bhsb;bhsb++,@1,BUNtloc(bni,r),if (w >= base && w < end),@2,r-off)@
			}
		} else {
			@:aggrX3_sum3(0,0,BUNfndVOID,var,BUNhloc(bi,p),@1,BUNtloc(bni,r),if (w >= base && w < end),@2,r-off)@
		}
	/* e->htype == TYPE_oid */
	} else if (range <= SMALL_AGGR_MAX) {
		/* array lookup */
		slots = range;
		if (b->htype == TYPE_void) {
			if ((g->htype == TYPE_void)&&(BATcount(b)==BATcount(g))&&(b->hseqbase==g->hseqbase)) {
				return aggrX3_sum3_@1_@2_EarrayBvoidGvoid (bn, b, g, e, range, min, max);
			} else {
				@:aggrX3_sum3(1,0,CHKrange,loc,&bhsb;bhsb++,@1,&sums[(*(oid*)h)-min],if (w >= base && w < end),@2,(*(oid*)h)-min)@
			}
		} else {
			@:aggrX3_sum3(1,0,CHKrange,loc,BUNhloc(bi,p),@1,&sums[(*(oid*)h)-min],if (w >= base && w < end),@2,(*(oid*)h)-min)@
		}
	} else if (BATcount(e) <= SCAN_AGGR_MAX) {
		/* scan lookup */
		SCAN_aggr_init;
		if (b->htype == TYPE_void) {
			if ((g->htype == TYPE_void)&&(BATcount(b)==BATcount(g))&&(b->hseqbase==g->hseqbase)) {
				@:aggrX3_sum3(0,0,SCANfndOID,loc,&bhsb;bhsb++,@1,BUNtloc(bni,r),,@2,r-off)@
			} else {
				@:aggrX3_sum3(0,0,SCANfndOID,loc,&bhsb;bhsb++,@1,BUNtloc(bni,r),if (w >= base && w < end),@2,r-off)@
			}
		} else {
			@:aggrX3_sum3(0,0,SCANfndOID,loc,BUNhloc(bi,p),@1,BUNtloc(bni,r),if (w >= base && w < end),@2,r-off)@
		}
	} else {
		/* hash lookup */
		if (b->htype == TYPE_void) {
			if ((g->htype == TYPE_void)&&(BATcount(b)==BATcount(g))&&(b->hseqbase==g->hseqbase)) {
				@:aggrX3_sum3(0,1,HASHfnd_oid,loc,&bhsb;bhsb++,@1,BUNtloc(bni,r),,@2,r-off)@
			} else {
				@:aggrX3_sum3(0,1,HASHfnd_oid,loc,&bhsb;bhsb++,@1,BUNtloc(bni,r),if (w >= base && w < end),@2,r-off)@
			}
		} else {
			@:aggrX3_sum3(0,1,HASHfnd_oid,loc,BUNhloc(bi,p),@1,BUNtloc(bni,r),if (w >= base && w < end),@2,r-off)@
		}
	}

	return GDK_SUCCEED;
}
@c

/*	arithprod3
	@6:	bte / sht / int / wrd / lng / flt / dbl		b/bn-tail-type

#	not used any more
#	@7:	"loc" for fixsized b/bn-tail-type,	b/bn-tail-access
#		"var" for varsized b/bn-tail-type	(only loc used currently)

	@9:	result type
*/
@= arithprod3_h
int
CMDaggrX3_prod3_@1_@2(BAT **ret, BAT *b, BAT *g, BAT *e);
@= arithprod3_c

static int
aggrX3_prod3_@1_@2_EarrayBvoidGvoid (BAT *bn, BAT *b, BAT *g, BAT *e, oid range, oid min, oid max)
{
	@2 zero = (@2) 1, *prods = NULL;
	bit *hit = NULL;
	BUN slots = range;
	BUN p, q, r;
	oid bhsb;
	BUN base, end, w;
	ssize_t offset;
	BATiter bni = bat_iterator(bn), bi = bat_iterator(b), gi = bat_iterator(g);

	ALGODEBUG THRprintf(GDKout, "#aggrX3_prod3_@1_@2_EarrayBvoidGvoid(bn=%s,b=%s,g=%s,e=%s,range=" OIDFMT ",min=" OIDFMT ",max=" OIDFMT ");\n",
					BATgetId(bn),BATgetId(b),BATgetId(g),BATgetId(e),
					range,min,max);
	@:aggrX3_prod3(1,0,CHKrange,loc,&bhsb;bhsb++,@1,&prods[(*(oid*)h)-min],,@2,(*(oid*)h)-min)@

	return GDK_SUCCEED;
}

int
CMDaggrX3_prod3_@1_@2(BAT **ret, BAT *b, BAT *g, BAT *e)
{
	BAT *bn;
	BATiter bni, bi = bat_iterator(b), gi = bat_iterator(g);
	@2 zero = (@2) 1, *prods = NULL;
	bit *hit = NULL;
	BUN slots, off;
	BUN p, q, r;
	oid range;
	oid min, max;
	oid bhsb;
	BUN base, end, w;
	ssize_t offset;

	ALGODEBUG THRprintf(GDKout, "#CMDaggrX3_prod3_@1_@2(b=%s,g=%s,e=%s);\n",
		BATgetId(b),BATgetId(g),BATgetId(e));
/*	ERRORcheck((BATcount(b)!=BATcount(g)), "CMDaggrX3_prod3_@1: BATs b & g must be of equal size.\n");	*/
	ERRORcheck((g->htype == TYPE_void) && (g->hseqbase == oid_nil) && (BATcount(g) > 0), "CMDaggrX3_prod3_@1: head of BAT g must not be nil.\n");

	if((g->hseqbase == oid_nil) || (!BAThdense(g)) || (!(BAThordered(b)&1)) || (!g->hkey)) {
		BAT *gb = BATjoin(BATmirror(g),b,BUN_NONE);
		int rtrn = CMDaggrX3_prod_@1_@2(ret, gb, e);
		BBPunfix(gb->batCacheid);
		return rtrn;
	}

	bn = BATnew(e->htype, TYPE_@2, BATcount(e));
	if( bn == NULL) {
		GDKerror("CMDaggrX3_prod3_@1_@2(): BATnew() failed");
		return GDK_FAIL;
	}
	bni = bat_iterator(bn);
	off = BUNfirst(bn);
	*ret = bn;

	/* init: set all prods to zero and calculate min/max oid */
	@:init_result(@2)@
	range = max - min + 1;

	/* scan b & g, and calculate prods */
	slots = BATcount(e);
	if (e->htype == TYPE_void) {
		/* void lookup */
		if (b->htype == TYPE_void) {
			if ((g->htype == TYPE_void)&&(BATcount(b)==BATcount(g))&&(b->hseqbase==g->hseqbase)) {
				@:aggrX3_prod3(0,0,BUNfndVOID,var,&bhsb;bhsb++,@1,BUNtloc(bni,r),,@2,r-off)@
			} else {
				@:aggrX3_prod3(0,0,BUNfndVOID,var,&bhsb;bhsb++,@1,BUNtloc(bni,r),if (w >= base && w < end),@2,r-off)@
			}
		} else {
			@:aggrX3_prod3(0,0,BUNfndVOID,var,BUNhloc(bi,p),@1,BUNtloc(bni,r),if (w >= base && w < end),@2,r-off)@
		}
	/* e->htype == TYPE_oid */
	} else if (range <= SMALL_AGGR_MAX) {
		/* array lookup */
		slots = range;
		if (b->htype == TYPE_void) {
			if ((g->htype == TYPE_void)&&(BATcount(b)==BATcount(g))&&(b->hseqbase==g->hseqbase)) {
				return aggrX3_prod3_@1_@2_EarrayBvoidGvoid (bn, b, g, e, range, min, max);
			} else {
				@:aggrX3_prod3(1,0,CHKrange,loc,&bhsb;bhsb++,@1,&prods[(*(oid*)h)-min],if (w >= base && w < end),@2,(*(oid*)h)-min)@
			}
		} else {
			@:aggrX3_prod3(1,0,CHKrange,loc,BUNhloc(bi,p),@1,&prods[(*(oid*)h)-min],if (w >= base && w < end),@2,(*(oid*)h)-min)@
		}
	} else if (BATcount(e) <= SCAN_AGGR_MAX) {
		/* scan lookup */
		SCAN_aggr_init;
		if (b->htype == TYPE_void) {
			if ((g->htype == TYPE_void)&&(BATcount(b)==BATcount(g))&&(b->hseqbase==g->hseqbase)) {
				@:aggrX3_prod3(0,0,SCANfndOID,loc,&bhsb;bhsb++,@1,BUNtloc(bni,r),,@2,r-off)@
			} else {
				@:aggrX3_prod3(0,0,SCANfndOID,loc,&bhsb;bhsb++,@1,BUNtloc(bni,r),if (w >= base && w < end),@2,r-off)@
			}
		} else {
			@:aggrX3_prod3(0,0,SCANfndOID,loc,BUNhloc(bi,p),@1,BUNtloc(bni,r),if (w >= base && w < end),@2,r-off)@
		}
	} else {
		/* hash lookup */
		if (b->htype == TYPE_void) {
			if ((g->htype == TYPE_void)&&(BATcount(b)==BATcount(g))&&(b->hseqbase==g->hseqbase)) {
				@:aggrX3_prod3(0,1,HASHfnd_oid,loc,&bhsb;bhsb++,@1,BUNtloc(bni,r),,@2,r-off)@
			} else {
				@:aggrX3_prod3(0,1,HASHfnd_oid,loc,&bhsb;bhsb++,@1,BUNtloc(bni,r),if (w >= base && w < end),@2,r-off)@
			}
		} else {
			@:aggrX3_prod3(0,1,HASHfnd_oid,loc,BUNhloc(bi,p),@1,BUNtloc(bni,r),if (w >= base && w < end),@2,r-off)@
		}
	}

	return GDK_SUCCEED;
}
@c

/*	arithsumprod3
	@6:	bte / sht / int / wrd / lng / flt / dbl		b/bn-tail-type

#	not used any more
#	@7:	"loc" for fixsized b/bn-tail-type,	b/bn-tail-access
#		"var" for varsized b/bn-tail-type	(only loc used currently)

	@9:	result type
*/
@= arithsumprod3_hc
@:arithsum3_@1(@2,@3)@
@:arithprod3_@1(@2,@3)@
@= arithsumprod3
@:arithsumprod3_hc(@1,bte,bte)@
@:arithsumprod3_hc(@1,bte,sht)@
@:arithsumprod3_hc(@1,bte,int)@
@:arithsumprod3_hc(@1,bte,wrd)@
@:arithsumprod3_hc(@1,bte,lng)@
@:arithsumprod3_hc(@1,sht,sht)@
@:arithsumprod3_hc(@1,sht,int)@
@:arithsumprod3_hc(@1,sht,wrd)@
@:arithsumprod3_hc(@1,sht,lng)@
@:arithsumprod3_hc(@1,int,int)@
@:arithsumprod3_hc(@1,int,wrd)@
@:arithsumprod3_hc(@1,int,lng)@
@:arithsumprod3_hc(@1,wrd,wrd)@
@:arithsumprod3_hc(@1,wrd,lng)@
@:arithsumprod3_hc(@1,lng,wrd)@
@:arithsumprod3_hc(@1,lng,lng)@
@:arithsumprod3_hc(@1,flt,flt)@
@:arithsumprod3_hc(@1,flt,dbl)@
@:arithsumprod3_hc(@1,dbl,dbl)@
@h
@:arithsumprod3(h)@
@c
@:arithsumprod3(c)@

/*	arithavg3
	@6:	bte / sht / int / wrd / lng / flt / dbl	b/bn-tail-type
	@7:	"loc" for fixsized b/bn-tail-type,	b/bn-tail-access
		"var" for varsized b/bn-tail-type	(only loc used currently)
	@9:	result type
*/
@= arithavg3_h
int
CMDaggrX3_avg3_@1(BAT **ret, BAT *b, BAT *g, BAT *e);
@= arithavg3_c
int
CMDaggrX3_avg3_@1(BAT **ret, BAT *b, BAT *g, BAT *e)
{
	BAT *bn;
	BATiter bni, bi = bat_iterator(b), gi = bat_iterator(g);
	BUN off;
	BUN *cnt = NULL;
	oid range;
	oid min, max;
	dbl zero = (dbl) 0, *sums = NULL;
	BUN slots;
	BUN p, q, r;
	oid bhsb;
	BUN base, end, w;
	ssize_t offset;

	ALGODEBUG THRprintf(GDKout, "#CMDaggrX3_avg3_@1[@2](b=%s,g=%s,e=%s);\n",
		BATgetId(b),BATgetId(g),BATgetId(e));
/*	ERRORcheck((BATcount(b)!=BATcount(g)), "CMDaggrX3_avg3_@1: BATs b & g must be of equal size.\n");	*/
	ERRORcheck((g->htype == TYPE_void) && (g->hseqbase == oid_nil) && (BATcount(g) > 0), "CMDaggrX3_avg3_@1: head of BAT g must not be nil.\n");

	if((g->hseqbase == oid_nil) || (!BAThdense(g)) || (!(BAThordered(b)&1)) || (!g->hkey)) {
		BAT *gb = BATjoin(BATmirror(g),b,BUN_NONE);
		int rtrn = CMDaggrX3_avg_@1(ret, gb, e);
		BBPunfix(gb->batCacheid);
		return rtrn;
	}

	bn = BATnew(e->htype, TYPE_dbl, BATcount(e));
	if( bn == NULL) {
		GDKerror("CMDaggrX3_avg3_@1(): BATnew() failed");
		return GDK_FAIL;
	}
	bni = bat_iterator(bn);
	off = BUNfirst(bn);

	/* init: set all sums & counts to zero and calculate min/max oid */
	@:init_result(dbl)@
	range = max - min + 1;

	/* scan b & g, calculate sums & counts, derive averages */
	slots = BATcount(e);
	if (e->htype == TYPE_void) {
		/* void lookup */
		if (b->htype == TYPE_void) {
			@:aggrX3_avg3(0,0,BUNfndVOID,var,&bhsb;bhsb++,@1,@2,BUNt@2(bni,r),r-off)@
		} else {
			@:aggrX3_avg3(0,0,BUNfndVOID,var,BUNhloc(bi,p),@1,@2,BUNt@2(bni,r),r-off)@
		}
	/* e->htype == TYPE_oid */
	} else if (range <= SMALL_AGGR_MAX) {
		/* array lookup */
		slots = range;
		if (b->htype == TYPE_void) {
			@:aggrX3_avg3(1,0,CHKrange,loc,&bhsb;bhsb++,@1,@2,&sums[(*(oid*)h)-min],(*(oid*)h)-min)@
		} else {
			@:aggrX3_avg3(1,0,CHKrange,loc,BUNhloc(bi,p),@1,@2,&sums[(*(oid*)h)-min],(*(oid*)h)-min)@
		}
	} else if (BATcount(e) <= SCAN_AGGR_MAX) {
		/* scan lookup */
		SCAN_aggr_init;
		if (b->htype == TYPE_void) {
			@:aggrX3_avg3(0,0,SCANfndOID,loc,&bhsb;bhsb++,@1,@2,BUNt@2(bni,r),r-off)@
		} else {
			@:aggrX3_avg3(0,0,SCANfndOID,loc,BUNhloc(bi,p),@1,@2,BUNt@2(bni,r),r-off)@
		}
	} else {
		/* hash lookup */
		if (b->htype == TYPE_void) {
			@:aggrX3_avg3(0,1,HASHfnd_oid,loc,&bhsb;bhsb++,@1,@2,BUNt@2(bni,r),r-off)@
		} else {
			@:aggrX3_avg3(0,1,HASHfnd_oid,loc,BUNhloc(bi,p),@1,@2,BUNt@2(bni,r),r-off)@
		}
	}

	*ret = bn;
	return GDK_SUCCEED;
}
@= arithavg3_hc
@:arithavg3_@1(@2,@3)@
@= arithavg3
@:arithavg3_hc(@1,bte,loc)@
@:arithavg3_hc(@1,sht,loc)@
@:arithavg3_hc(@1,int,loc)@
@:arithavg3_hc(@1,wrd,loc)@
@:arithavg3_hc(@1,lng,loc)@
@:arithavg3_hc(@1,flt,loc)@
@:arithavg3_hc(@1,dbl,loc)@
@h
@:arithavg3(h)@
@c
@:arithavg3(c)@

@- "Extremes" (Min & Max)
@c
/*	aggrX3_minmax3_ptr
		e-void-head	e-oid-head	e-oid-head	e-oid-head
		void-lookup	array-lookup	scan-lookup	hash-lookup

	@1:	</>		</>		</>		</>		compare operator: <(min) or >(max)
	@2:	0		0		0		1		do BATprepareHash?
	@3:	BUNfndVOID	CHKrange	SCANfndOID	HASHfnd_oid	lookup
	@4:	var		loc		loc		loc		e/bn-head-access

	@5:	"BUNhloc(b,p)" for  (oid) b-head-type,		b-head access
		"&bhsb; bhsb++" for (void) b-head-type

	@6:	chr / sht / int / lng / any		b/bn-tail-storage-type
	@7:	"loc" for fixsized b/bn-tail-type,		b/bn-tail-access
		"var" for varsized b/bn-tail-type

	@8:		r-off		(*(oid*)h)-min	index in extremes array
	@9:		max/min					initial result value
*/
@= aggrX3_minmax3_ptr
	ALGODEBUG THRprintf(GDKout, "#aggrX3_minmax3_ptr(@1,@2,@3,@4,@5,@6,@7,@8,@9);\n");
	if (@2 && BATprepareHash(e)) {
		GDKerror("aggrX3_minmax3_ptr(@1,@2,@3,@4,@5,@6,@6,@7,@8,@9): BATprepareHash(e) failed");
		BBPreclaim(e);
		return GDK_FAIL;
	}
	/* init: create extremes and set all to the zero pointer */
	if (slots > 0) {
		extremes = (ptr*) GDKmalloc(slots*sizeof(ptr));
		if (extremes == NULL) {
			GDKerror("aggrX3_minmax3_ptr(@1,@2,@3,@4,@5,@6,@7,@8,@9): extremes = GDKmalloc("OIDFMT"*"SZFMT") failed", slots, sizeof(ptr));
			BBPreclaim(bn);
			return GDK_FAIL;
		}
		memset(extremes, 0, slots*sizeof(ptr));
	}
	/* scan b & g and replace totals by the extreme value (just pointers to vals in b) */
	base = BUNfirst(g);
	offset = (ssize_t) base - (ssize_t) g->hseqbase;
	end = base + BATcount(g);
	bhsb = b->hseqbase;
	if (b->T->nonil) {
		BATloop(b, p, q) {
			ptr t = BUNt@7(bi,p);
			oid v = *(oid*) @5;

			w = (BUN) (offset + v);
			if (w >= base && w < end) {
				oid *h = (oid*) BUNtail(gi, w);

				@3(r, bni, (oid*)h);
				if (r != BUN_NONE) {
					ptr *val = &extremes[@8];
					if (*val == NULL || (*cmp)(t,*val) @1 0) {
						*val = t;
					}
				}
			}
		}
	} else {
		BATloop(b, p, q) {
			ptr t = BUNt@7(bi,p);
			oid v = *(oid*) @5;

			w = (BUN) (offset + v);
			if (w >= base && w < end) {
				oid *h = (oid*) BUNtail(gi, w);

				@3(r, bni, (oid*)h);
				if (r != BUN_NONE) {
					ptr *val = &extremes[@8];
					if (*val != nil) {
						if ((*cmp)(t,nil) == 0) {
							*val = nil;
						} else if (*val == NULL || (*cmp)(t,*val) @1 0) {
							*val = t;
						}
					}
				}
			}
		}
	}
	/* insert the extreme values into the result */
	BATloop(bn, r, q) {
		oid *h = (oid*)BUNh@4(bni,r);
		ptr val = extremes[@8];
		(void) h;	/* silence compiler about unused variable */
		ATOMput(bn->ttype, bn->theap, BUNtloc(bni,r), val?val:nil);
	}
@c
/*	aggrX3_minmax3_oid
		e-void-head	e-oid-head	e-oid-head	e-oid-head
		void-lookup	array-lookup	scan-lookup	hash-lookup

	@1:	</>		</>		</>		</>		compare operator: <(min) or >(max)
	@2:	0		0		0		1		do BATprepareHash?
	@3:	BUNfndVOID	CHKrange	SCANfndOID	HASHfnd_oid	lookup
	@4:	var		loc		loc		loc		e/bn-head-access

	@5:	"BUNhloc(b,p)" for  (oid) b-head-type,		b-head access
		"&bhsb; bhsb++" for (void) b-head-type

	@6:	chr / sht / int / lng / any		b/bn-tail-storage-type
	@7:	"loc" for fixsized b/bn-tail-type,		b/bn-tail-access
		"var" for varsized b/bn-tail-type

	@8:		r-off		(*(oid*)h)-min	index in extremes array
	@9:		max/min					initial result value
*/
@= aggrX3_minmax3_oid
	ALGODEBUG THRprintf(GDKout, "#aggrX3_minmax3_oid(@1,@2,@3,@4,@5,@6,@7,@8,@9);\n");
	if (@2 && BATprepareHash(e)) {
		GDKerror("aggrX3_minmax3_oid(@1,@2,@3,@4,@5,@6,@6,@7,@8,@9): BATprepareHash(e) failed");
		BBPreclaim(e);
		return GDK_FAIL;
	}
	/* init: create extremes and set all to the zero pointer */
	if (slots > 0) {
		extremes = (oid*) GDKmalloc(slots*sizeof(oid));
		if (extremes == NULL) {
			GDKerror("aggrX3_minmax3_oid(@1,@2,@3,@4,@5,@6,@7,@8,@9): extremes = GDKmalloc("OIDFMT"*"SZFMT") failed", slots, sizeof(oid));
			BBPreclaim(bn);
			return GDK_FAIL;
		}
		{ BUN i = 0; for (; i < slots; i++ ) extremes[i] = GDK_oid_@9; }
		hit = (bit*) GDKmalloc(slots*sizeof(bit));
		if (hit == NULL) {
			GDKerror("aggrX3_minmax3_oid(@1,@2,@3,@4,@5,@6,@7,@8,@9): hit = GDKmalloc("OIDFMT"*"SZFMT") failed", slots, sizeof(bit));
			GDKfree(extremes);
			BBPreclaim(bn);
			return GDK_FAIL;
		}
		memset(hit, 0, slots*sizeof(bit));
	}
	/* scan b & g and replace totals by the extreme value (just pointers to vals in b) */
	base = BUNfirst(g);
	offset = (ssize_t) base - (ssize_t) g->hseqbase;
	end = base + BATcount(g);
	bhsb = b->hseqbase;
	if (b->T->nonil) {
		BATloop(b, p, q) {
			ptr t = BUNt@7(bi,p);
			oid v = *(oid*) @5;

			w = (BUN) (offset + v);
			if (w >= base && w < end) {
				oid *h = (oid*) BUNtail(gi, w);

				@3(r, bni, (oid*)h);
				if (r != BUN_NONE) {
					oid *val = &extremes[@8];
					if ((*cmp)(t,val) @1 0) {
						*val = *(oid*)t;
						hit[@8] = 1;
					}
				}
			}
		}
	} else {
		BATloop(b, p, q) {
			ptr t = BUNt@7(bi,p);
			oid v = *(oid*) @5;

			w = (BUN) (offset + v);
			if (w >= base && w < end) {
				oid *h = (oid*) BUNtail(gi, w);

				@3(r, bni, (oid*)h);
				if (r != BUN_NONE) {
					oid *val = &extremes[@8];
					if (*val != *(oid*)nil) {
						if ((*cmp)(t,nil) == 0) {
							*val = *(oid*)nil;
						} else if ((*cmp)(t,val) @1 0) {
							*val = *(oid*)t;
							hit[@8] = 1;
						}
					}
				}
			}
		}
	}
	/* insert the extreme values into the result */
	BATloop(bn, r, q) {
		oid *h = (oid*)BUNh@4(bni,r);
		oid val = hit[@8] ? extremes[@8] : *(oid*)nil;
		(void) h;	/* silence compiler about unused variable */
		ATOMput(bn->ttype, bn->theap, BUNtloc(bni,r), &val);
	}
@c

/*	extreme_typed
	@1:	min/max
	@2:	 < / >
	@3:	b/bn-tail-storage-type			chr/bte/sht/int/lng/any
	@4:	"loc" for fixsized b/bn-tail-type,	b/bn-tail-access
		"var" for varsized b/bn-tail-type
	@5:	ptr/oid					void/any
	@6:	max/min					initial result value
*/
@= extreme3_typed
static int
aggrX3_@13_@3_@4_@5(BAT **ret, BAT *b, BAT *g, BAT *e)
{
	BAT *bn;
	BATiter bni, bi = bat_iterator(b), gi = bat_iterator(g);
	int (*cmp)(ptr,ptr);
	ptr nil;
	BUN off;
	@5 *extremes = NULL;
	bit *hit = NULL;
	BUN p, q, r;
	BUN slots;
	oid range;
	oid min, max;
	oid bhsb;
	BUN base, end, w;
	ssize_t offset;

	*ret = NULL;

	ALGODEBUG THRprintf(GDKout, "#aggrX3_@1_@3_@4_@5[@2,@6](b=%s,g=%s,e=%s);\n",
		BATgetId(b),BATgetId(g),BATgetId(e));
/*	ERRORcheck((BATcount(b)!=BATcount(g)), "aggrX3_@13_@3_@4: BATs b & g must be of equal size.\n");	*/
	ERRORcheck((g->htype == TYPE_void) && (g->hseqbase == oid_nil) && (BATcount(g) > 0), "aggrX3_@13_@3_@4_@5: head of BAT g must not be nil.\n");

	if((g->hseqbase == oid_nil) || (!BAThdense(g)) || (!(BAThordered(b)&1)) || (!g->hkey)) {
		BAT *gb = BATjoin(BATmirror(g),b,BUN_NONE);
		int rtrn = CMDaggrX3_@1(ret, gb, e);
		BBPunfix(gb->batCacheid);
		return rtrn;
	}

	bn = BATnew(e->htype, BATttype(b), BATcount(e));
	if( bn == NULL) {
		GDKerror("aggrX3_@13_@3_@4_@5(): BATnew() failed");
		return GDK_FAIL;
	}
	bni = bat_iterator(bn);
	cmp = BATatoms[bn->ttype].atomCmp;
	nil = ATOMnilptr(bn->ttype);
	off = BUNfirst(bn);

	/* init: prepare the result bat;
	 * trick: by using "tail-type" void, we only write the head column, here */
	@:init_result(void)@
	range = max - min + 1;

	/* scan b & g and replace totals by the extreme value (just pointers to vals in b) */
	slots = BATcount(e);
	if (e->htype == TYPE_void) {
		/* void lookup */
		if (b->htype == TYPE_void) {
			@:aggrX3_minmax3_@5(@2,0,BUNfndVOID,var,&bhsb; bhsb++,@3,@4,r-off,@6)@
		} else {
			@:aggrX3_minmax3_@5(@2,0,BUNfndVOID,var,BUNhloc(bi,p),@3,@4,r-off,@6)@
		}
	/* e->htype == TYPE_oid */
	} else if (range <= SMALL_AGGR_MAX) {
		/* array lookup */
		slots = range;
		if (b->htype == TYPE_void) {
			@:aggrX3_minmax3_@5(@2,0,CHKrange,loc,&bhsb; bhsb++,@3,@4,(*(oid*)h)-min,@6)@
		} else {
			@:aggrX3_minmax3_@5(@2,0,CHKrange,loc,BUNhloc(bi,p),@3,@4,(*(oid*)h)-min,@6)@
		}
	} else if (BATcount(e) <= SCAN_AGGR_MAX) {
		/* scan lookup */
		SCAN_aggr_init;
		if (b->htype == TYPE_void) {
			@:aggrX3_minmax3_@5(@2,0,SCANfndOID,loc,&bhsb;bhsb++,@3,@4,r-off,@6)@
		} else {
			@:aggrX3_minmax3_@5(@2,0,SCANfndOID,loc,BUNhloc(bi,p),@3,@4,r-off,@6)@
		}
	} else {
		/* hash lookup */
		if (b->htype == TYPE_void) {
			@:aggrX3_minmax3_@5(@2,1,HASHfnd_oid,loc,&bhsb; bhsb++,@3,@4,r-off,@6)@
		} else {
			@:aggrX3_minmax3_@5(@2,1,HASHfnd_oid,loc,BUNhloc(bi,p),@3,@4,r-off,@6)@
		}
	}
	*ret = bn;
bunins_failed:
	if (extremes)
		GDKfree(extremes);
	if (hit)
		GDKfree(hit);
	return *ret?GDK_SUCCEED:GDK_FAIL;
}
@c
/*	extreme
	@1:	min/max
	@2:	 < / >
*/
@= extreme3_h
int
CMDaggrX3_@13(BAT **ret, BAT *b, BAT *g, BAT *e);
@= extreme3_c
@:extreme3_typed(@1,@2,chr,loc,ptr,@3)@
@:extreme3_typed(@1,@2,bte,loc,ptr,@3)@
@:extreme3_typed(@1,@2,sht,loc,ptr,@3)@
@:extreme3_typed(@1,@2,int,loc,ptr,@3)@
@:extreme3_typed(@1,@2,lng,loc,ptr,@3)@
@:extreme3_typed(@1,@2,any,loc,ptr,@3)@
@:extreme3_typed(@1,@2,any,var,ptr,@3)@
@:extreme3_typed(@1,@2,any,var,oid,@3)@

int
CMDaggrX3_@13(BAT **ret, BAT *b, BAT *g, BAT *e)
{
	int rtrn, tt = ATOMstorage(b->ttype);
	ALGODEBUG THRprintf(GDKout, "#CMDaggrX3_@1[@2](b=%s,g=%s,e=%s);\n",
		BATgetId(b),BATgetId(g),BATgetId(e));
/*	ERRORcheck((BATcount(b)!=BATcount(g)), "aggrX3_@13: BATs b & g must be of equal size.\n");	*/
	ERRORcheck((g->htype == TYPE_void) && (g->hseqbase == oid_nil) && (BATcount(g) > 0), "aggrX3_@13: head of BAT g must not be nil.\n");

	if((g->hseqbase == oid_nil) || (!BAThdense(g)) || (!(BAThordered(b)&1)) || (!g->hkey)) {
		BAT *gb = BATjoin(BATmirror(g),b,BUN_NONE);
		rtrn = CMDaggrX3_@1(ret, gb, e);
		BBPunfix(gb->batCacheid);
		return rtrn;
	}

	if (b->ttype == TYPE_void) {
		rtrn = aggrX3_@13_any_var_oid(ret, b, g, e);
	} else if (tt == TYPE_chr) {
		rtrn = aggrX3_@13_chr_loc_ptr(ret, b, g, e);
	} else if (tt == TYPE_bte) {
		rtrn = aggrX3_@13_bte_loc_ptr(ret, b, g, e);
	} else if (tt == TYPE_sht) {
		rtrn = aggrX3_@13_sht_loc_ptr(ret, b, g, e);
	} else if (b->ttype != TYPE_bat && (tt == TYPE_int || tt == TYPE_flt)) {
		/* ensure use of ATOMput for TYPE_bat */
		rtrn = aggrX3_@13_int_loc_ptr(ret, b, g, e);
	} else if (tt == TYPE_dbl || tt == TYPE_lng) {
		rtrn = aggrX3_@13_lng_loc_ptr(ret, b, g, e);
	} else if (b->tvarsized) {
		rtrn = aggrX3_@13_any_var_ptr(ret, b, g, e);
	} else {
		rtrn = aggrX3_@13_any_loc_ptr(ret, b, g, e);
	}
	return rtrn;
}
@h
@:extreme3_h(min,<,max)@
@:extreme3_h(max,>,min)@
@c
@:extreme3_c(min,<,max)@
@:extreme3_c(max,>,min)@

@- Count
@c
/*	aggrX3_count3
		e-void-head	e-oid-head	e-oid-head	e-oid-head
		void-lookup	array-lookup	scan-lookup	hash-lookup

	@1:	0		1		0		0		use cnt-array?
	@2:	0		0		0		1		do BATprepareHash?
	@3:	BUNfndVOID	CHKrange	SCANfndOID	HASHfnd_oid	lookup
	@4:	var		loc		loc		loc		e/bn-head-access

	@5:	"BUNhloc(b,p)" for  (oid) b-head-type,		b-head access
		"&bhsb; bhsb++" for (void) b-head-type

	@6:	BUNtloc(bn,r)	BUNtloc(bn,r)	&cnt[(*(oid*)h)-min]
								*dst: count in-place or in cnt-array ?
*/
@= aggrX3_count3
	ALGODEBUG THRprintf(GDKout, "#aggrX3_count3(@1,@2,@3,@4,@5,@6);\n");
	if (@1 && range > 0) {
		/* create tmp. cnt array */
		cnt = (wrd*) GDKmalloc(range*sizeof(wrd));
		if (cnt == NULL) {
			GDKerror("aggrX3_count3(@1,@2,@3,@4,@5,@6,@6): cnt = GDKmalloc("OIDFMT"*"SZFMT") failed", range, sizeof(wrd));
			BBPreclaim(bn);
			return GDK_FAIL;
		}
		memset(cnt, 0, range*sizeof(wrd));
	}
	if (@2 && BATprepareHash(bn)) {
		GDKerror("aggrX3_count3(@1,@2,@3,@4,@5,@6,@6): BATprepareHash(bn) failed");
		if (@1 && cnt)
			GDKfree(cnt);
		BBPreclaim(bn);
		return GDK_FAIL;
	}
	/* scan b & g, and increment counts in-place or in cnt-array */
	base = BUNfirst(g);
	offset = (ssize_t) base - (ssize_t) g->hseqbase;
	end = base + BATcount(g);
	bhsb = b->hseqbase;
	btt = b->ttype;
	if (*ignore_nils && !b->T->nonil) {
		switch(ATOMstorage(btt)) {
		case TYPE_chr:
			@:aggrX3_count3_loop(@1,@2,@3,@4,@5,@6,if (!simple_EQ(BUNtloc(bi,p),bt_nil,chr)))@
		case TYPE_bte:
			@:aggrX3_count3_loop(@1,@2,@3,@4,@5,@6,if (!simple_EQ(BUNtloc(bi,p),bt_nil,bte)))@
		case TYPE_sht:
			@:aggrX3_count3_loop(@1,@2,@3,@4,@5,@6,if (!simple_EQ(BUNtloc(bi,p),bt_nil,sht)))@
		case TYPE_int:
			@:aggrX3_count3_loop(@1,@2,@3,@4,@5,@6,if (!simple_EQ(BUNtloc(bi,p),bt_nil,int)))@
		case TYPE_lng:
			@:aggrX3_count3_loop(@1,@2,@3,@4,@5,@6,if (!simple_EQ(BUNtloc(bi,p),bt_nil,lng)))@
		case TYPE_flt:
			@:aggrX3_count3_loop(@1,@2,@3,@4,@5,@6,if (!simple_EQ(BUNtloc(bi,p),bt_nil,flt)))@
		case TYPE_dbl:
			@:aggrX3_count3_loop(@1,@2,@3,@4,@5,@6,if (!simple_EQ(BUNtloc(bi,p),bt_nil,dbl)))@
		default:
			if (b->tvarsized) {
				@:aggrX3_count3_loop(@1,@2,@3,@4,@5,@6,if (!atom_EQ(BUNtvar(bi,p),bt_nil,btt)))@
			} else {
				@:aggrX3_count3_loop(@1,@2,@3,@4,@5,@6,if (!atom_EQ(BUNtloc(bi,p),bt_nil,btt)))@
			}
		}
	} else {
		switch(ATOMstorage(btt)) {
		case TYPE_chr:
			@:aggrX3_count3_loop(@1,@2,@3,@4,@5,@6,)@
		case TYPE_bte:
			@:aggrX3_count3_loop(@1,@2,@3,@4,@5,@6,)@
		case TYPE_sht:
			@:aggrX3_count3_loop(@1,@2,@3,@4,@5,@6,)@
		case TYPE_int:
			@:aggrX3_count3_loop(@1,@2,@3,@4,@5,@6,)@
		case TYPE_lng:
			@:aggrX3_count3_loop(@1,@2,@3,@4,@5,@6,)@
		case TYPE_flt:
			@:aggrX3_count3_loop(@1,@2,@3,@4,@5,@6,)@
		case TYPE_dbl:
			@:aggrX3_count3_loop(@1,@2,@3,@4,@5,@6,)@
		default:
			if (b->tvarsized) {
				@:aggrX3_count3_loop(@1,@2,@3,@4,@5,@6,)@
			} else {
				@:aggrX3_count3_loop(@1,@2,@3,@4,@5,@6,)@
			}
		}
	}
	if (@1 && cnt) {
		/* copy cnt array to final result */
		BATloop(bn, p, q) {
			oid h = (*(oid*) BUNh@4(bni,p)) - min;
			*(wrd*)BUNtloc(bni, p) = cnt[h];
		}
		GDKfree(cnt);
	}
@c
/*	aggrX3_count3_loop
	@7:	if (!atom_EQ(BUNt{loc,var}(b,p),bt_nil,btt))		b-tail nil check
		if (!simple_EQ(BUNtloc(b,p),bt_nil,{chr,bte,sht,int,flt,lng,dbl}))
*/
@= aggrX3_count3_loop
	ALGODEBUG THRprintf(GDKout, "#aggrX3_count3_loop(@1,@2,@3,@4,@5,@6,@7);\n");
	BATloop(b, p, q) {
		oid v = *(oid*) @5;

		w = (BUN) (offset + v);
		if (w >= base && w < end) {
			oid *h = (oid*) BUNtail(gi, w);

			@3(r, bni, (oid*)h);
			if (r != BUN_NONE) {
				@7 {
					wrd *dst = (wrd*) @6;
					(*dst)++;
				}
			}
		}
	}
	break;
@h
int
CMDaggrX3_count3(BAT **ret, BAT *b, BAT *g, BAT *e, bit *ignore_nils);
@c
int
CMDaggrX3_count3(BAT **ret, BAT *b, BAT *g, BAT *e, bit *ignore_nils)
{
	BATiter bni, bi = bat_iterator(b), gi = bat_iterator(g);
	BAT *bn;
	wrd zero = 0, *cnt = NULL;
	BUN p, q, r;
	oid range = 0;
	oid min = 0, max = 0;
	oid bhsb;
	BUN base, end, w;
	ssize_t offset;
	int btt;
	ptr bt_nil = ATOMnilptr(b->ttype);

	ALGODEBUG THRprintf(GDKout, "#CMDaggrX3_count3(b=%s,g=%s,e=%s);\n", 
		BATgetId(b),BATgetId(g),BATgetId(e));

/*	ERRORcheck((BATcount(b)!=BATcount(g)), "CMDaggrX3_count3: BATs b & g must be of equal size.\n");	*/
	ERRORcheck((g->htype == TYPE_void) && (g->hseqbase == oid_nil) && (BATcount(g) > 0), "CMDaggrX3_count3: head of BAT g must not be nil.\n");

	if ((g->hseqbase == oid_nil) || (!BAThdense(g)) || (!(BAThordered(b) & 1)) || (!g->hkey)) {
		BAT *gb = BATjoin(BATmirror(g), b, BUN_NONE);
		int rtrn = CMDaggrX3_count(ret, gb, e, ignore_nils);
		BBPunfix(gb->batCacheid);
		return rtrn;
	}

	if (e->htype == TYPE_void && 
	    b->htype == TYPE_void && 
	    g->htype == TYPE_void && 
	    g->ttype == TYPE_void &&
	    BATcount(b) == BATcount(e) &&
	    (!ignore_nils || b->T->nonil)) {
		/* simply return counts with one */
		wrd one = 1;
		bn = BATconst(b, TYPE_wrd, &one);
		*ret = bn;
		return GDK_SUCCEED;
	}
 	bn = BATnew(e->htype, TYPE_wrd, BATcount(e));
	bni = bat_iterator(bn);
	if( bn == NULL) {
		GDKerror("CMDaggrX3_count3(): BATnew() failed");
		return GDK_FAIL;
	}

	/* init: set all counts to zero and calculate min/max oid */
	@:init_result(wrd)@
	bn->T->nonil = 1;
	range = max - min + 1;

	/* scan b & g, and calculate counts */
	if (e->htype == TYPE_void) {
		/* void lookup */
		if (b->htype == TYPE_void) {
			@:aggrX3_count3(0,0,BUNfndVOID,var,&bhsb;bhsb++,BUNtloc(bni,r))@
		} else {
			@:aggrX3_count3(0,0,BUNfndVOID,var,BUNhloc(bi,p),BUNtloc(bni,r))@
		}
		/* e->htype == TYPE_oid */
	} else if (range <= SMALL_AGGR_MAX) {
		/* array lookup */
		if (b->htype == TYPE_void) {
			@:aggrX3_count3(1,0,CHKrange,loc,&bhsb;bhsb++,&cnt[(*(oid*)h)-min])@
		} else {
			@:aggrX3_count3(1,0,CHKrange,loc,BUNhloc(bi,p),&cnt[(*(oid*)h)-min])@
		}
	} else if (BATcount(e) <= SCAN_AGGR_MAX) {
		/* scan lookup */
		SCAN_aggr_init;
		if (b->htype == TYPE_void) {
			@:aggrX3_count3(0,0,SCANfndOID,loc,&bhsb;bhsb++,BUNtloc(bni,r))@
		} else {
			@:aggrX3_count3(0,0,SCANfndOID,loc,BUNhloc(bi,p),BUNtloc(bni,r))@
		}
	} else {
		/* hash lookup */
		if (b->htype == TYPE_void) {
			@:aggrX3_count3(0,1,HASHfnd_oid,loc,&bhsb;bhsb++,BUNtloc(bni,r))@
		} else {
			@:aggrX3_count3(0,1,HASHfnd_oid,loc,BUNhloc(bi,p),BUNtloc(bni,r))@
		}
	}

	*ret = bn;
	return GDK_SUCCEED;
}

@}
