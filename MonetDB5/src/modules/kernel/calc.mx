@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2006 CWI.
@' All Rights Reserved.

@f calc
@a N.J. Nes, P. Boncz, M. Kersten, A. de Vries
@v 2.0
@* Basic arithmetic 
This module is an extended version of the V4 arithmetic module.
It implements the arithmetic operations on the built-in types,
@emph{chr}, @emph{sht}, @emph{int}, @emph{flt}, @emph{dbl} and @emph{lng}.
All combinations are implemented. Limited combinations are implemented
for @emph{bit}, @emph{oid} and @emph{str}. 

@table @code
@item[binary operators]
The implemented operators are first of all all comparison that return a 
TRUE/FALSE value (@emph{bit} values), i.e. 
@emph{<=}, @emph{<}, @emph{==}, @emph{!=}, @emph{>=}, and @emph{>=}.

The module also implements the operators @emph{+}, @emph{-}, @emph{*} and @emph{/}. 
The rules for the return types operators is as follows.
If one of the input types is a floating point the result will be a
floating point.  The largest type of the input types is taken. 

The @emph{max} and @emph{min} functions return the maximum and minimum of 
the two input parameters.

@item[unary operators]
This module also implements the unary @emph{abs}() function, which calculates 
the absolute value of the given input parameter, as well as the @emph{-} unary
operator. 

The @emph{inv} unary operation calculates the inverse of the input value. 
An error message is given when the input value is zero.

@item[bitwise operators]
For integers there are some additional operations. The @emph{\%} operator
implements the congruent modulo operation. The @emph{<<} and @emph{>>} 
are the left and right bit shift. The @emph{or}, @emph{and}, @emph{xor} and 
@emph{not} for integers are implemented as bitwise boolean operations. 

@item[boolean operators]
The @emph{or}, @emph{and}, @emph{xor} and @emph{not} for the bit atomic type 
in MIL (this corresponds to what is normally called boolean)
are implemented as the logic operations.

@item[random numbers]
This module also contains the rand and srand functions. The @emph{srand}() 
function initializes the random number generator using a seed value. The 
subsequent calls to @emph{rand}() are pseudo random numbers (with the same 
seed the sequence can be repeated).
@end table

The general interpretation for the NIL value is "unknown".
This semantics mean that any operation that receives at least one NIL 
value, will produce a NIL value in the output for sure.

The only exception to this rule are the "==" and "!=" equality 
test routines (it would otherwise become rather difficult to test 
whether a value is nil). 

The collection of type conversion routines are included here as well.

The definitions shown are limited to the Mx macros.
This should be sufficient to understand the functionality
at the cost of precision.
In most situations the macros are expanded using the
built-in type set (int,lng,sht,bit,oid,flt,...) 
@= mal_isnil
	command isnil(v:@1) :bit 
	address CALCisnil_@1
	comment "is a value nil?";
	command isnotnil(v:@1) :bit 
	address CALCisnotnil_@1
	comment "is a value not equal to nil?";
@-
[Mx bug, space required here]

@{
@mal
module calc;

	@:mal_isnil(chr)@
	@:mal_isnil(bit)@
	@:mal_isnil(sht)@
	@:mal_isnil(int)@
	@:mal_isnil(oid)@
	@:mal_isnil(flt)@
	@:mal_isnil(lng)@
	@:mal_isnil(dbl)@
	@:mal_isnil(str)@
	@:mal_isnil(bat)@
command isnil(v:void) :bit 
address CALCisnil_void
comment "is a value nil?";
command isnotnil(v:void) :bit 
address CALCisnotnil_void
comment "is a value not equal to nil?";
@}
@+ Comparison operations
The @emph{eq_ops} and @emph{cmp_ops} Mx macro implements the interface to the
arithmetic comparisons. Note that comparison operators with different
operand types are already supported in the kernel, but are not nearly as fast,
(because they have to convert values on the fly).  
The code expansion is organized such that
the least interesting one is pushed onto the symbol table stack first.

@= eq_ops
		command ==(left:@1, right:@2) :bit 
		address CALCcompEQ@1@2;
		command !=(left:@1, right:@2) :bit 
		address CALCcompNEQ@1@2;
@= cmp_ops
		@:eq_ops(@1,@2)@

		command <(left:@1, right:@2) :bit 
		address CALCcompLT@1@2;
		command <=(left:@1, right:@2) :bit 
		address CALCcompLE@1@2;
		command >=(left:@1, right:@2) :bit 
		address CALCcompGE@1@2;
		command >(left:@1, right:@2) :bit 
		address CALCcompGT@1@2;
		command between(val:@1, low:@1, high:@1) :bit 
		address CALCcompBetween@1;
@{
@mal

		@:cmp_ops(oid,oid)@
		@:cmp_ops(flt,flt)@
		@:cmp_ops(flt,dbl)@
		@:cmp_ops(dbl,dbl)@

		@:cmp_ops(chr,chr)@
		@:cmp_ops(chr,sht)@
		@:cmp_ops(chr,int)@
		@:cmp_ops(chr,lng)@

		@:eq_ops(bit,bit)@
		@:eq_ops(bit,chr)@
		@:eq_ops(bit,sht)@
		@:eq_ops(bit,int)@
		@:eq_ops(bit,lng)@

		@:cmp_ops(sht,chr)@
		@:cmp_ops(sht,sht)@
		@:cmp_ops(sht,int)@
		@:cmp_ops(sht,lng)@

		@:cmp_ops(int,chr)@
		@:cmp_ops(int,sht)@
		@:cmp_ops(int,int)@
		@:cmp_ops(int,lng)@

		@:cmp_ops(lng,chr)@
		@:cmp_ops(lng,sht)@
		@:cmp_ops(lng,int)@
		@:cmp_ops(lng,lng)@

		@:cmp_ops(str,str)@
@}
@+ Arithmetic computation 
The operators @{ +, -, *, /, % @} are handled here.
The macro expects three parameters, two input atomic types and a result type. 
@mal
command %(left:chr, right:int) :int 
address CALCbinarycheckMODchrint;
command %(left:sht, right:int) :int 
address CALCbinarycheckMODshtint;
command %(left:int, right:int) :int 
address CALCbinarycheckMODintint;
command %(left:lng, right:int) :int 
address CALCbinarycheckMODlngint;
command %(left:lng, right:lng) :lng 
address CALCbinarycheckMODlnglng;
command %(left:int, right:chr) :chr 
address CALCbinarycheckMODintchr;
command %(left:int, right:sht) :sht 
address CALCbinarycheckMODintsht;

command +(l:str,r:str):str
address CALCstrConcat
comment "Concatenate two strings";
command +(l:str,r:int):str
address CALCstrConcatInt
comment "Concatenate two strings";

@= mal_calc_ops
		command +(left:@1, right:@2) :@3 
		address CALCbinaryADD@1@2; 
		command -(left:@1, right:@2) :@3 
		address CALCbinarySUB@1@2;
		command *(left:@1, right:@2) :@3 
		address CALCbinaryMUL@1@2;
		command /(left:@1, right:@2) :@3 
		address CALCbinarycheckDIV@1@2;
@{
@-
The coercions described below ensure that there is never any information loss.
@mal

	@:mal_calc_ops(flt,chr,flt)@
	@:mal_calc_ops(flt,sht,flt)@
	@:mal_calc_ops(flt,int,flt)@
	@:mal_calc_ops(flt,lng,flt)@
	@:mal_calc_ops(flt,flt,flt)@
	@:mal_calc_ops(flt,dbl,dbl)@

	@:mal_calc_ops(dbl,chr,dbl)@
	@:mal_calc_ops(dbl,sht,dbl)@
	@:mal_calc_ops(dbl,int,dbl)@
	@:mal_calc_ops(dbl,lng,dbl)@
	@:mal_calc_ops(dbl,flt,dbl)@
	@:mal_calc_ops(dbl,dbl,dbl)@

	@:mal_calc_ops(oid,oid,oid)@

	@:mal_calc_ops(chr,chr,chr)@
	@:mal_calc_ops(chr,sht,sht)@
	@:mal_calc_ops(chr,int,int)@
	@:mal_calc_ops(chr,lng,lng)@
	@:mal_calc_ops(chr,flt,flt)@
	@:mal_calc_ops(chr,dbl,dbl)@

	@:mal_calc_ops(sht,chr,sht)@
	@:mal_calc_ops(sht,sht,sht)@
	@:mal_calc_ops(sht,int,int)@
	@:mal_calc_ops(sht,lng,lng)@
	@:mal_calc_ops(sht,flt,flt)@
	@:mal_calc_ops(sht,dbl,dbl)@

	@:mal_calc_ops(int,chr,int)@
	@:mal_calc_ops(int,sht,int)@
	@:mal_calc_ops(int,int,int)@
	@:mal_calc_ops(int,lng,lng)@
	@:mal_calc_ops(int,flt,flt)@
	@:mal_calc_ops(int,dbl,dbl)@

	@:mal_calc_ops(lng,chr,lng)@
	@:mal_calc_ops(lng,sht,lng)@
	@:mal_calc_ops(lng,int,lng)@
	@:mal_calc_ops(lng,lng,lng)@
	@:mal_calc_ops(lng,flt,flt)@
	@:mal_calc_ops(lng,dbl,dbl)@
@}
@+ Binary  operations { max, min, }
@= mal_binary_ops
		command max(l:@1, r:@1) :@1 
		address CALCbinaryMAX@2; 
		command min(l:@1, r:@1) :@1 
		address CALCbinaryMIN@2;
@{
@-
@mal
	@:mal_binary_ops(chr,chr)@
	@:mal_binary_ops(sht,sht)@
	@:mal_binary_ops(int,int)@
	@:mal_binary_ops(oid,oid)@
	@:mal_binary_ops(flt,flt)@
	@:mal_binary_ops(lng,lng)@
	@:mal_binary_ops(dbl,dbl)@
@}
@+ Unary operations { abs, inv }
The unary operators include coercion routines for built-in types
@= mal_unary_ops
		command abs(x:@1) :@1 
		address CALCunary@1ABS 
		comment "absolute value";
		command inv(x:@1) :@1 
		address CALCunarycheck@1INV 	
		comment "inverse value (1/x)";
		command -(x:@1) :@1 
		address CALCunary@1NEG 
		comment "negative value";
		command length(x:@1):int
		address CALClength@1;
@{
@-
@mal
	@:mal_unary_ops(dbl)@
	@:mal_unary_ops(flt)@
	@:mal_unary_ops(chr)@
	@:mal_unary_ops(sht)@
	@:mal_unary_ops(int)@
	@:mal_unary_ops(lng)@
	command length(x:str):int
	address CALClengthstr;
@}
@-
Coercion functions are typical used in multiplex calls.
@= mal_coercion
		command @1(x:@2):@1 
		address CALC@22@1 
		comment "coercion @2 to @1";
@{
@= scalar_coercion
	@:mal_coercion(@1,oid)@
	@:mal_coercion(@1,bit)@
	@:mal_coercion(@1,chr)@
	@:mal_coercion(@1,sht)@
	@:mal_coercion(@1,int)@
	@:mal_coercion(@1,lng)@
	@:mal_coercion(@1,flt)@
	@:mal_coercion(@1,dbl)@
@mal
	@:scalar_coercion(bit)@
	@:scalar_coercion(chr)@
	@:scalar_coercion(lng)@
	@:scalar_coercion(int)@
	@:scalar_coercion(sht)@

	@:mal_coercion(oid,oid)@
	@:mal_coercion(oid,lng)@
	@:mal_coercion(oid,sht)@
	@:mal_coercion(oid,int)@
	@:mal_coercion(oid,flt)@
	@:mal_coercion(oid,dbl)@

	@:mal_coercion(flt,flt)@
	@:mal_coercion(flt,dbl)@
	@:mal_coercion(flt,sht)@
	@:mal_coercion(flt,int)@
	@:mal_coercion(flt,lng)@

	@:mal_coercion(dbl,dbl)@
	@:mal_coercion(dbl,flt)@
	@:mal_coercion(dbl,sht)@
	@:mal_coercion(dbl,int)@
	@:mal_coercion(dbl,lng)@

	@:mal_coercion(str,sht)@
	@:mal_coercion(str,int)@
	@:mal_coercion(str,lng)@
	@:mal_coercion(str,flt)@
	@:mal_coercion(str,dbl)@

	@:mal_coercion(chr,chr)@
	@:mal_coercion(chr,sht)@
	@:mal_coercion(chr,int)@
	@:mal_coercion(chr,lng)@
@}
@+ Boolean operations { or, xor, and, not }
@mal
command or(left:bit, right:bit) :bit 
address CALCbinaryORbit;
command and(left:bit, right:bit) :bit 
address CALCbinaryANDbit;
command xor(left:bit, right:bit) :bit 
address CALCbinaryXORbit;
command not(left:bit) :bit 
address CALCunarybitNOT ;

pattern ifthenelse(b:bit,t:any_1,f:any_1):any_1 
address CALCswitchbit;

@+ Bitwise operations
Cardinal numerical types (inclusing @emph{chr} can be regarded as a bit
array. Specific operations work with this interpretation.
@= mal_bitwise_ops
		command or(left:@1, right:@1) :@1 
		address CALCbinaryOR@1@1;
		command and(left:@1, right:@1) :@1 
		address CALCbinaryAND@1@1;
		command xor(left:@1, right:@1) :@1 
		address CALCbinaryXOR@1@1;
		command not(left:@1) :@1 
		address CALCunary@1NOT;
		command <<(left:@1,right:int) :@1 
		address CALCbinaryLSH@1int;
		command >>(left:@1, right:int) :@1 
		address CALCbinaryRSH@1int;
@{
@mal
	@:mal_bitwise_ops(chr)@
	@:mal_bitwise_ops(sht)@
	@:mal_bitwise_ops(int)@
	@:mal_bitwise_ops(lng)@
@}
@+ Type coercions
The Monet kernel contains a few built-in atomic types together
with useful functions. 
Those accessible at the MAL command level are introduced below.

@= convertCmd
		command @1(v:str):@1 
		address CALCstr2@1;
		command str(v:@1):str 
		address CALC@12str;
		command @1(v:void) :@1 
		address CALCnil2@1;

@{
@mal
@:convertCmd(oid)@
@:convertCmd(sht)@
@:convertCmd(int)@
@:convertCmd(bat)@
@:convertCmd(lng)@
@:convertCmd(flt)@
@:convertCmd(dbl)@
@:convertCmd(bit)@
@:convertCmd(ptr)@
@:convertCmd(chr)@

command bat(v:str):bat[:any_1,:any_2] 
address CALCstr2bat;
command str(v:bat[:any_1,:any_2]):str 
address CALCbat2str;
command bat(v:void) :bat[:any_1,:any_2] 
address CALCnil2bat;

#command bat(b:bat):bat[:any_1,:any_2]
#address CALCBAT2bat;
#command bat(b:bat[:any_1,:any_2]):bat
#address CALCbat2BAT;

command str(v:void) :str 
address CALCnil2str;
command str(v:str) :str 
address CALCstr2str;

command void(v:void) :void 
address CALCnil2void;
command void(v:int) :void 
address CALCint2void;
command void(v:sht) :void 
address CALCsht2void;
command void(v:lng) :void 
address CALClng2void;

command setoid(v:int)
address intSetoidImpl;
command setoid(v:lng)
address lngSetoidImpl;
command setoid(v:oid)
address oidSetoidImpl;

command getBATidentifier(b:bat[:any_1,:any_2]):bat
address CALCbat2batid
comment "Coerce bat to BAT identifier";
command getBAT(b:bat):bat[:any_1,:any_2]
address CALCbatid2bat
comment "Coerce bat to BAT identifier";

@}
@-
We should also deal with superflous operations, such as int(v:int).
This is a noop operation that should ideally be filtered out with
the code squeezer. [TODO]
@+ OID utility functions
@mal
command newoid() :oid 
address CALCnewoidBase
comment "Generate a new oid. Equivalent to newoid(0,1)";

command newoid(incr:lng) :oid 
address CALCnewoidInclng;
command newoid(incr:int) :oid 
address CALCnewoidInc
comment "Reserves a range of consecutive unique OIDs; returns the lowest 
		in range.  equivalent to newoid(0,incr)";

command setoid(base:oid) :oid 
address CALCsetoidInc
comment "Sets the oid range of consecutive unique OIDs; returns the 
		lowest in range.";

command setoid() :oid 
address CALCsetoidBase
comment "Equivalent to setoid(1:oid).";
@{
@+ Example script 
The following example MIL script will do each operation in the
calc module. It can be used for testing and the M2m compiler.

@mil
setoid(oid(20000000));
chr1 := 'a';
chr2 := 'c';
sht1 := sht(2);
sht2 := sht(5);
int1 := 5;
int2 := 2;
flt1 := 2.5;
flt2 := 5.4;
dbl1 := dbl(-2.500001);	       # may also need string since float is default
dbl2 := dbl(54.00456789);      # real and is less significant	
lng1 := lng("-9000000000000"); # string needed because lng doesn't fit in an
lng2 := lng("5400456789");     # int
oid1 := oid(int1);
oid2 := oid(int2);

@:mil_comp_ops('a','z')@
@:mil_comp_ops(sht1,sht2)@
@:mil_comp_ops(int1,int2)@
@:mil_comp_ops(flt1,flt2)@
@:mil_comp_ops(dbl1,dbl2)@
@:mil_comp_ops("abcde","abcdf")@

@:mil_calc_ops(chr1,chr2)@
@:mil_calc_ops(chr1,sht2)@
@:mil_calc_ops(chr1,int2)@
@:mil_calc_ops(chr1,lng2)@
@:mil_calc_ops(chr1,flt2)@
@:mil_calc_ops(chr1,dbl2)@

@:mil_calc_ops(sht1,chr2)@
@:mil_calc_ops(sht1,sht2)@
@:mil_calc_ops(sht1,int2)@
@:mil_calc_ops(sht1,lng2)@
@:mil_calc_ops(sht1,flt2)@
@:mil_calc_ops(sht1,dbl2)@

@:mil_calc_ops(int1,chr2)@
@:mil_calc_ops(int1,sht2)@
@:mil_calc_ops(int1,int2)@
@:mil_calc_ops(int1,lng2)@
@:mil_calc_ops(int1,flt2)@
@:mil_calc_ops(int1,dbl2)@

@:mil_calc_ops(lng1,chr2)@
@:mil_calc_ops(lng1,sht2)@
@:mil_calc_ops(lng1,int2)@
@:mil_calc_ops(lng1,lng2)@
@:mil_calc_ops(lng1,flt2)@
@:mil_calc_ops(lng1,dbl2)@

@:mil_calc_ops(flt1,chr2)@
@:mil_calc_ops(flt1,sht2)@
@:mil_calc_ops(flt1,int2)@
@:mil_calc_ops(flt1,lng2)@
@:mil_calc_ops(flt1,flt2)@
@:mil_calc_ops(flt1,dbl2)@

@:mil_calc_ops(dbl1,chr2)@
@:mil_calc_ops(dbl1,sht2)@
@:mil_calc_ops(dbl1,int2)@
@:mil_calc_ops(dbl1,lng2)@
@:mil_calc_ops(dbl1,flt2)@
@:mil_calc_ops(dbl1,dbl2)@

@:mil_calc_ops(oid1,oid2)@

max(sht1,sht2).print;
max(int1,int2).print;
max(lng1,lng2).print;
max(flt1,flt2).print;
max(dbl1,dbl2).print;

min(sht1,sht2).print;
min(int1,int2).print;
min(flt1,flt2).print;
min(dbl1,dbl2).print;
min(lng1,lng2).print;

abs(sht2).print;
abs(int2).print;
abs(flt2).print;
abs(dbl2).print;
abs(lng2).print;

@:mil_calc_ops(oid1,oid2)@
max(oid1,oid2).print;
min(oid1,oid2).print;

inv(sht2).print;
inv(int2).print;
inv(flt2).print;
inv(dbl2).print;
inv(lng2).print;

(int1% int2).print;
(int1<<int2).print;
(int1>>int2).print;

(int1 or  int2).print;
(int1 and int2).print;
(int1 xor int2).print;
not(int2).print;

bit1 := true;
bit2 := false;
(bit1 or  bit2).print;
(bit1 and bit2).print;
(bit1 xor bit2).print;
not(bit2).print;

srand( 1234 );
rand().print;
quit;
@-
The @emph{comp_ops} implements the mil example script comparison 
operations.  It gets two parameters which are the operants for the operations.

@= mil_comp_ops
 (@1 < @2).print;  (@2 < @1).print;  (@1 < @1).print;
(@1 <= @2).print; (@2 <= @1).print; (@1 <= @1).print;
 (@1 = @2).print;  (@2 = @1).print;  (@1 = @1).print;
(@1 >= @2).print; (@2 >= @1).print; (@1 >= @1).print;
 (@1 > @2).print;  (@2 > @1).print;  (@1 > @1).print;
@

The @emph{calc_ops} implements the mil example script arithmetic 
operations.  It gets two parameters which are the operants for the operations.

@= mil_calc_ops
(@1 + @2).print;
(@1 - @2).print;
(@1 * @2).print;
(@1 / @2).print;
@

@{
@* Implementation
The implementation below differs from the pre-V5 implementation in
that all strings and pointers are passed by reference, rather than
by value. Since it is unclear in the module implementation whether
such references are static or refer to dynamic allocated space,
we have to be conservative. All deallocation calls should be prepared
and handled by the environment.
For this module this won't be a problem, because we do not change
the string representations.
@h
#ifndef __calc_H__
#define __calc_H__

#include "gdk.h"

#endif /* __calc_H__ */
@}

@c
#include "mal_config.h"
#include "calc.h"
#include "stdlib.h"
#include "mal.h"
#include "mal_exception.h"
#include "mal_interpreter.h"

#ifdef WIN32
#ifndef LIBCALC
#define calc_export extern __declspec(dllimport)
#else
#define calc_export extern __declspec(dllexport)
#endif
#else
#define calc_export extern
#endif

/* third param indicates return value if one of the params is nil */
@:c_comp_ops(<,LT)@
@:c_comp_ops(<=,LE)@
@:c_comp_ops(==,EQ)@
@:c_comp_ops(!=,NEQ)@
@:c_comp_ops(>=,GE)@
@:c_comp_ops(>,GT)@

/* the normal implementation of an operator is to just stick the
   operator between the operands */
#define OP(l,op,r)	((l) op (r))
@:c_calc_ops(chr,chr,chr)@
@:c_calc_ops(chr,sht,sht)@
@:c_calc_ops(chr,int,int)@
@:c_calc_ops(chr,lng,lng)@
@:c_calc_ops(chr,flt,flt)@
@:c_calc_ops(chr,dbl,dbl)@

@:c_calc_ops(sht,chr,sht)@
@:c_calc_ops(sht,sht,sht)@
@:c_calc_ops(sht,int,int)@
@:c_calc_ops(sht,lng,lng)@
@:c_calc_ops(sht,flt,flt)@
@:c_calc_ops(sht,dbl,dbl)@

@:c_calc_ops(int,chr,int)@
@:c_calc_ops(int,sht,int)@
@:c_calc_ops(int,int,int)@
@:c_calc_ops(int,lng,lng)@
@:c_calc_ops(int,flt,flt)@
@:c_calc_ops(int,dbl,dbl)@

@:c_calc_ops(lng,chr,lng)@
@:c_calc_ops(lng,sht,lng)@
@:c_calc_ops(lng,int,lng)@
@:c_calc_ops(lng,lng,lng)@
@:c_calc_ops(lng,flt,flt)@
@:c_calc_ops(lng,dbl,dbl)@

@:c_calc_ops(flt,chr,flt)@
@:c_calc_ops(flt,sht,flt)@
@:c_calc_ops(flt,int,flt)@
@:c_calc_ops(flt,lng,flt)@
@:c_calc_ops(flt,flt,flt)@
@:c_calc_ops(flt,dbl,dbl)@

@:c_calc_ops(dbl,chr,dbl)@
@:c_calc_ops(dbl,sht,dbl)@
@:c_calc_ops(dbl,int,dbl)@
@:c_calc_ops(dbl,lng,dbl)@
@:c_calc_ops(dbl,flt,dbl)@
@:c_calc_ops(dbl,dbl,dbl)@

@:c_calc_ops(oid,oid,oid)@

#define calc_abs(s) ((s)>0)?(s):-(s)
@:calc_unop(ABS,calc_abs,chr)@
@:calc_unop(ABS,calc_abs,sht)@
@:calc_unop(ABS,calc_abs,int)@
@:calc_unop(ABS,calc_abs,flt)@
@:calc_unop(ABS,calc_abs,dbl)@
@:calc_unop(ABS,calc_abs,lng)@

#define calc_inv(s) (1/(s))
@:check_unop(INV,calc_inv,chr)@
@:check_unop(INV,calc_inv,sht)@
@:check_unop(INV,calc_inv,int)@
@:check_unop(INV,calc_inv,flt)@
@:check_unop(INV,calc_inv,dbl)@
@:check_unop(INV,calc_inv,lng)@

#define calc_neg(s) (-(s))
@:calc_unop(NEG,calc_neg,chr)@
@:calc_unop(NEG,calc_neg,sht)@
@:calc_unop(NEG,calc_neg,int)@
@:calc_unop(NEG,calc_neg,flt)@
@:calc_unop(NEG,calc_neg,dbl)@
@:calc_unop(NEG,calc_neg,lng)@
@-
@= calc_length
calc_export str CALClength@1(int *res , @1 *a );
str CALClength@1(int *res , @1 *a ) {
   *res = sizeof(*a);
   return(MAL_SUCCEED);
}
@c

@:calc_length(chr)@
@:calc_length(sht)@
@:calc_length(int)@
@:calc_length(flt)@
@:calc_length(dbl)@
@:calc_length(lng)@

calc_export str CALClengthstr(int *res , str *a );
str CALClengthstr(int *res , str *a ) {
   *res = strlen(*a);
   return(MAL_SUCCEED);
}
@:any_binary_minmax(MIN,<=)@
@:any_binary_minmax(MAX,>)@

@-
@= calc_macrobinop
calc_export str CALCbinary@1@3(@3 *res , @3 *a, @3 *b );
str CALCbinary@1@3(@3 *res , @3 *a, @3 *b ) {
#ifdef DEBUG
	printf( "CALCbinary@1@3\n");
#endif
   if (*a == @3_nil || *b == @3_nil) {
	*res = @3_nil;
   } else {
   	*res = @2 (*a,*b);
   }
   return(MAL_SUCCEED);
}
@c
#define calc_max(s1,s2) ((s1)>(s2))?(s1):(s2)
@:calc_macrobinop(MAX,calc_max,chr)@
@:calc_macrobinop(MAX,calc_max,sht)@
@:calc_macrobinop(MAX,calc_max,int)@
@:calc_macrobinop(MAX,calc_max,oid)@
@:calc_macrobinop(MAX,calc_max,flt)@
@:calc_macrobinop(MAX,calc_max,dbl)@
@:calc_macrobinop(MAX,calc_max,lng)@

#define calc_min(s1,s2) ((s1)<(s2))?(s1):(s2)
@:calc_macrobinop(MIN,calc_min,chr)@
@:calc_macrobinop(MIN,calc_min,sht)@
@:calc_macrobinop(MIN,calc_min,int)@
@:calc_macrobinop(MIN,calc_min,oid)@
@:calc_macrobinop(MIN,calc_min,flt)@
@:calc_macrobinop(MIN,calc_min,dbl)@
@:calc_macrobinop(MIN,calc_min,lng)@

@:check_binop(MOD,%,chr,int,int,int,"Modulo zero is not possible")@
@:check_binop(MOD,%,sht,sht,sht,sht,"Modulo zero is not possible")@
@:check_binop(MOD,%,sht,int,int,int,"Modulo zero is not possible")@
@:check_binop(MOD,%,int,int,int,int,"Modulo zero is not possible")@
@:check_binop(MOD,%,lng,lng,lng,lng,"Modulo zero is not possible")@
@:check_binop(MOD,%,lng,int,int,lng,"Modulo zero is not possible")@
@:check_binop(MOD,%,int,chr,chr,int,"Modulo zero is not possible")@
@:check_binop(MOD,%,int,sht,sht,int,"Modulo zero is not possible")@

/* a % b when a and/or b are float (double) doesn't exist, so provide
   an alternative way of calculating the result */
#undef OP
#define OP(l,op,r)	((l) - (dbl) ((lng) ((l) / (r))) * (r))
@:check_binop(MOD,%,dbl,dbl,dbl,dbl,"Modulo zero is not possible")@
@:check_binop(MOD,%,flt,flt,flt,flt,"Modulo zero is not possible")@

@:c_bitwise_ops(chr)@
@:c_bitwise_ops(sht)@
@:c_bitwise_ops(int)@
@:c_bitwise_ops(lng)@

@:c_shift_ops(chr)@
@:c_shift_ops(sht)@
@:c_shift_ops(int)@

calc_export str CALCstrConcat(str *ret, str *l, str *r);
str
CALCstrConcat(str *ret, str *l, str *r)
{
	str s;

	s = GDKmalloc(strlen(*l) + strlen(*r) + 1);
	strcpy(s, *l);
	strcat(s, *r);
	*ret = s;
	return MAL_SUCCEED;
}

calc_export str CALCstrConcatInt(str *ret, str *l, int *r);
str
CALCstrConcatInt(str *ret, str *l, int *r)
{
	str s;
	int len = strlen(*l) + 32;

	s = GDKmalloc(len);
	snprintf(s, len, "%s%d", *l, *r);
	*ret = s;
	return MAL_SUCCEED;
}

calc_export str CALCbinaryRSHlngint(lng *ret, lng *val, int *shift);
str
CALCbinaryRSHlngint(lng *ret, lng *val, int *shift)
{
	if (*val == lng_nil || *shift == int_nil) {
		*ret = lng_nil;
	} else {
		*ret = *val >> *shift;
	}
	return MAL_SUCCEED;
}

calc_export str CALCbinaryLSHlngint(lng *ret, lng *val, int *shift);
str
CALCbinaryLSHlngint(lng *ret, lng *val, int *shift)
{
	if (*val == lng_nil || *shift == int_nil) {
		*ret = lng_nil;
	} else {
		*ret = *val << *shift;
	}
	return MAL_SUCCEED;
}

calc_export str CALCbinaryANDbit(bit *retval, bit *v1, bit *v2);
str
CALCbinaryANDbit(bit *retval, bit *v1, bit *v2)
{
	if (*v1 == FALSE || *v2 == FALSE) {
		*retval = FALSE;
	} else if (*v1 == bit_nil || *v2 == bit_nil) {
		*retval = bit_nil;
	} else {
		*retval = TRUE;
	}
	return MAL_SUCCEED;
}

calc_export str CALCbinaryORbit(bit *retval, bit *v1, bit *v2);
str
CALCbinaryORbit(bit *retval, bit *v1, bit *v2)
{
	if (*v1 && *v1 != bit_nil) {
		*retval = TRUE;
	} else if (*v2 && *v2 != bit_nil) {
		*retval = TRUE;
	} else if (*v1 == bit_nil || *v2 == bit_nil) {
		*retval = bit_nil;
	} else {
		*retval = *v1 || *v2;
	}
	return MAL_SUCCEED;
}

calc_export str CALCbinaryXORbit(bit *retval, bit *v1, bit *v2);
str
CALCbinaryXORbit(bit *retval, bit *v1, bit *v2)
{
	if (*v1 == bit_nil || *v2 == bit_nil) {
		*retval = bit_nil;
	} else {
		*retval = ((*v1 && *v2 == FALSE) || (*v1 == FALSE && *v2));
	}
	return MAL_SUCCEED;
}

calc_export str CALCunarybitNOT(bit *retval, bit *value);
str
CALCunarybitNOT(bit *retval, bit *value)
{
	if (*value == bit_nil) {
		*retval = bit_nil;
	} else {
		*retval = (*value) ? FALSE : TRUE;
	}
	return MAL_SUCCEED;
}

/*
calc_export str CALCswitchbit(ptr retval, bit *b, ptr v1, ptr v2);
str
*/
calc_export str CALCswitchbit(MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
str 
CALCswitchbit(MalBlkPtr mb, MalStkPtr stk, InstrPtr P)
{
	ptr p;
	ptr retval = getArgReference(stk,P,0);
	bit b = *(bit*) getArgReference(stk,P,1);
	int t1 = getArgType(mb, P, 2);
	int t2 = getArgType(mb, P, 3);

	if (t1 != t2)
		throw(MAL, "ifthenelse", "types should match\n");

	if (b == bit_nil) {
		p = ATOMnilptr(t1);
		throw(MAL, "ifthenelse", "cannot switch on nil value\n");
	} else if (b) {
		p = getArgReference(stk,P,2);
	} else {
		p = getArgReference(stk,P,3);
	}
	if (ATOMextern(t1)) {
		*(ptr **) retval = ATOMdup(t1, *(ptr**)p);
	} else {
		memcpy(retval, p, ATOMsize(t1));
	}
	return MAL_SUCCEED;
}


@-
The @emph{c_comp} and @emph{c_comp_ops} macros implement the mil comparison 
operations.

@= any_binary_minmax
calc_export str CALCbinary@1any(ptr ret, ptr v1, int t, ptr v2);
str CALCbinary@1any(ptr ret, ptr v1, int t, ptr v2){
	int (*cmp)(ptr,ptr) = BATatoms[t].atomCmp;
	ptr src, nil = ATOMnilptr(t);
	if ((*cmp)(v1, nil) == 0 || (*cmp)(v2, nil) == 0) {
		src = nil;
	} else {
		src = ((*cmp)(v1, v2) @2 0)?v1:v2;
	}
	if (ATOMextern(t)) {
		int s = ATOMlen(t, src);
		str buf = *(str*) ret = (char*) GDKmalloc(s);
		memcpy(buf, src, s);
	} else {
		memcpy(ret, src, ATOMsize(t));
	}
	return MAL_SUCCEED;
}

@= c_comp_op
calc_export str CALCcomp@4@2@3(bit *retval, @2 *v1, @3 *v2);
str CALCcomp@4@2@3(bit *retval, @2 *v1, @3 *v2){
	if (*v1 == @2_nil || *v2 == @3_nil) {
		*retval = bit_nil;
	} else {
		*retval = *v1 @1 *v2;	
	}
	return MAL_SUCCEED;
}
@= c_comp_ops
		@:c_comp_op(@1,oid,oid,@2)@
		@:c_comp_op(@1,flt,flt,@2)@
		@:c_comp_op(@1,flt,dbl,@2)@
		@:c_comp_op(@1,dbl,dbl,@2)@

		@:c_comp_op(@1,chr,chr,@2)@
		@:c_comp_op(@1,chr,sht,@2)@
		@:c_comp_op(@1,chr,int,@2)@
		@:c_comp_op(@1,chr,lng,@2)@

		@:c_comp_op(@1,bit,bit,@2)@
		@:c_comp_op(@1,bit,chr,@2)@
		@:c_comp_op(@1,bit,sht,@2)@
		@:c_comp_op(@1,bit,int,@2)@
		@:c_comp_op(@1,bit,lng,@2)@

		@:c_comp_op(@1,sht,chr,@2)@
		@:c_comp_op(@1,sht,sht,@2)@
		@:c_comp_op(@1,sht,int,@2)@
		@:c_comp_op(@1,sht,lng,@2)@

		@:c_comp_op(@1,int,chr,@2)@
		@:c_comp_op(@1,int,sht,@2)@
		@:c_comp_op(@1,int,int,@2)@
		@:c_comp_op(@1,int,lng,@2)@

		@:c_comp_op(@1,lng,chr,@2)@
		@:c_comp_op(@1,lng,sht,@2)@
		@:c_comp_op(@1,lng,int,@2)@
		@:c_comp_op(@1,lng,lng,@2)@

calc_export str CALCcomp@2strstr(bit *retval, str *s1, str *s2);
str CALCcomp@2strstr(bit *retval, str *s1, str *s2){
	if (strNil(*s1) || strNil(*s2)) {
		*retval = bit_nil; 
	} else {
		*retval = (strcmp(*s1,*s2) @1 0);
	}
	return MAL_SUCCEED;
}
calc_export str CALCcomp@2any(bit *retval, ptr *v1, int tpe, ptr *v2);
str CALCcomp@2any(bit *retval, ptr *v1, int tpe, ptr *v2){
	int (*cmp)(ptr,ptr) = BATatoms[tpe].atomCmp;
	ptr nil = ATOMnilptr(tpe);

	if ((*cmp)(*v1, nil) == 0 || (*cmp)(*v2, nil) == 0) {
		*retval = bit_nil; 
	} else {
		*retval = ((*cmp)( *v1, *v2) @1 0);
	}
	return MAL_SUCCEED;
}
@c
@:c_between_op(chr)@
@:c_between_op(sht)@
@:c_between_op(int)@
@:c_between_op(oid)@
@:c_between_op(flt)@
@:c_between_op(dbl)@
@:c_between_op(lng)@
calc_export str CALCcompBetweenstr(bit *retval, str *val, str *low, str *high);
str
CALCcompBetweenstr(bit *retval, str *val, str *low, str *high)
{
	int val_nil = strNil(*val);
	int low_nil = strNil(*low);
	int high_nil = strNil(*high);

	if (val_nil || (low_nil && high_nil)) {
		*retval = bit_nil;
	} else if (low_nil) {
		*retval = (strcmp(*val, *high) <= 0);
	} else if (high_nil) {
		*retval = (strcmp(*low, *val) <= 0);
	} else {
		*retval = (strcmp(*low, *val) <= 0 && strcmp(*val, *high) <= 0);
	}
	return MAL_SUCCEED;
}

calc_export str CALCcompBetweenany(bit *retval, ptr *val, int tpe, ptr *low, ptr *high);
str
CALCcompBetweenany(bit *retval, ptr *val, int tpe, ptr *low, ptr *high)
{
	int (*cmp) (ptr, ptr) = BATatoms[tpe].atomCmp;
	ptr nilptr = ATOMnilptr(tpe);
	int val_nil = ((*cmp) (*val, nilptr) == 0);
	int low_nil = ((*cmp) (*low, nilptr) == 0);
	int high_nil = ((*cmp) (*high, nilptr) == 0);

	if (val_nil || (low_nil && high_nil)) {
		*retval = bit_nil;
	} else if (low_nil) {
		*retval = ((*cmp) (*val, *high) <= 0);
	} else if (high_nil) {
		*retval = ((*cmp) (*low, *val) <= 0);
	} else {
		*retval = ((*cmp) (*low, *val) <= 0 && (*cmp) (*val, *high) <= 0);
	}
	return MAL_SUCCEED;
}

@= c_isnil
calc_export str CALCisnil_@1(bit *retval, @1 *val);
str CALCisnil_@1(bit *retval, @1 *val) {
	*retval = (*val == @1_nil);
	return MAL_SUCCEED;
}
calc_export str CALCisnotnil_@1(bit *retval, @1 *val);
str CALCisnotnil_@1(bit *retval, @1 *val) {
	*retval = (*val != @1_nil);
	return MAL_SUCCEED;
}
calc_export str CALCnil2@1(@1 *retval, ptr val);
str CALCnil2@1(@1 *retval, ptr val){
	(void) val;/* fool compiler */
	memcpy(retval, ATOMnilptr(TYPE_@1), ATOMsize(TYPE_@1));
	return MAL_SUCCEED;
}
@c
@:c_isnil(bit)@
@:c_isnil(chr)@
@:c_isnil(sht)@
@:c_isnil(int)@
@:c_isnil(oid)@
@:c_isnil(flt)@
@:c_isnil(lng)@
@:c_isnil(dbl)@
@:c_isnil(ptr)@
@:c_isnil(bat)@

calc_export str CALCisnil_str(bit *retval, str *val);
str
CALCisnil_str(bit *retval, str *val)
{
	*retval = strcmp(*val, ATOMnilptr(TYPE_str)) == 0;
	return MAL_SUCCEED;
}

calc_export str CALCisnotnil_str(bit *retval, str *val);
str
CALCisnotnil_str(bit *retval, str *val)
{
	*retval = strcmp(*val, ATOMnilptr(TYPE_str));
	return MAL_SUCCEED;
}

calc_export str CALCstr2nil(str *retval, str *val);
str
CALCstr2nil(str *retval, str *val)
{
	(void) val;		/* fool compiler */
	*retval = GDKstrdup(ATOMnilptr(TYPE_str));
	return MAL_SUCCEED;
}

calc_export str CALCisnil_any(bit *retval, ptr *val, int tpe);
str
CALCisnil_any(bit *retval, ptr *val, int tpe)
{
	ptr nilval = ATOMnilptr(tpe);

	*retval = (ATOMcmp(tpe, nilval, *val) == 0);
	return MAL_SUCCEED;
}

calc_export str CALCisnil_void(bit *retval, oid *val);
str
CALCisnil_void(bit *retval, oid *val)
{
	*retval = (*val == oid_nil);
	return MAL_SUCCEED;
}

calc_export str CALCisnotnil_void(bit *retval, oid *val);
str
CALCisnotnil_void(bit *retval, oid *val)
{
	*retval = (*val != oid_nil);
	return MAL_SUCCEED;
}

@= c_between_op
calc_export str CALCcompBetween@1(bit *retval, @1 *v, @1 *low, @1 *high);
str CALCcompBetween@1(bit *retval, @1 *v, @1 *low, @1 *high){
	if (*v == @1_nil || (*low == @1_nil && *high == @1_nil)) {
		*retval = bit_nil;
	} else if (*low == @1_nil) {
		*retval = (*v <= *high);
	} else if (*high == @1_nil) {
		*retval = (*low <= *v);
	} else {
		*retval = (*low <= *v) && (*v <= *high);	
	}
	return MAL_SUCCEED;
}
@-
The @emph{c_calc_ops} implement the arithmetic operations on the given type.
The @emph{c_calc_ops} macro gets three arguments, two input types and a 
result type. 

@= c_calc_ops
@:calc_binop(ADD,+,@1,@2,@3)@
@:calc_binop(SUB,-,@1,@2,@3)@
@:calc_binop(MUL,*,@1,@2,@3)@
@:check_binop(DIV,/,@1,@2,@3,@3,"Division by zero")@
@

@= calc_unop
calc_export str CALCunary@3@1(@3 *res , @3 *a );
str CALCunary@3@1(@3 *res , @3 *a ) {
#ifdef DEBUG
	printf( "CALCunary@3@1\n");
#endif
   if (*a == @3_nil) {
	   *res = @3_nil;
   } else {   
	   *res = @2 (*a);
   }
   return(MAL_SUCCEED);
}
@

@= check_unop
calc_export str CALCunarycheck@3@1(@3 *res , @3 *a );
str CALCunarycheck@3@1(@3 *res , @3 *a ) {
#ifdef DEBUG
	printf( "CALCunary@3@1\n");
#endif
	if (*a == 0 ){
		throw(MAL, "calc.@3", "Illegal reference");
	} else if ( *a == @3_nil) {
		*res = @3_nil;
	} else {
		*res = @2 (*a);
	}
	return(MAL_SUCCEED);
}
@

@= calc_binop
calc_export str CALCbinary@1@3@4(@5 *res, @3 *a, @4 *b );
str CALCbinary@1@3@4(@5 *res, @3 *a, @4 *b ) {
#ifdef DEBUG
	printf( "CALCbinary@1@3@4\n");
#endif
   if (*a == @3_nil || *b == @4_nil) {
	*res = @5_nil;
   } else {
   	*res = ((@5)(*a)) @2 ((@5)(*b));
   }
   return(MAL_SUCCEED);
}
@

/*
	1: function name suffix (_MOD,_DIV etc)
	2: operator (%,/ etc)
	3: type argument 1
	4: type argument 2
	5: result type 
	6: intermediate type (sometimes the result is a smaller type (%))
	7: Error message when something goes wrong.
*/
@= check_binop
calc_export str CALCbinarycheck@1@3@4(@5 *res, @3 *a, @4 *b );
str CALCbinarycheck@1@3@4(@5 *res, @3 *a, @4 *b ) {
#ifdef DEBUG
	printf( "CALCbinarycheck@1@3@4\n");
#endif
   if (*b == 0) {
	throw(MAL, "calc.@2", @7);
   } else if (*a == @3_nil || *b == @4_nil) {
	*res = @5_nil;
   } else {
	*res = (@5) OP((@6)*a,@2,(@6)*b);
   }
   return(MAL_SUCCEED);
}
@


@= c_bitwise_ops
@:calc_binop(OR,|,@1,@1,@1)@
@:calc_binop(AND,&,@1,@1,@1)@
@:calc_binop(XOR,^,@1,@1,@1)@
@:calc_unop(NOT,~,@1)@

@= c_shift_ops
@:calc_binop(LSH,<<,@1,int,@1)@
@:calc_binop(RSH,>>,@1,int,@1)@

@+ The Coercion implementation
Coercions generally do not check on information loss
@-
@= mal_coercion_impl
calc_export str CALC@22@1(@1 *res, @2 *a);
str CALC@22@1(@1 *res, @2 *a)
{
	if (*a == @2_nil @3)
		*res= @1_nil;
	else
		*res= @4;
	return MAL_SUCCEED;
}
@-
@c
@:mal_coercion_impl(bit,bit, , *a != 0)@
@:mal_coercion_impl(bit,oid, , *a != 0)@
@:mal_coercion_impl(bit,chr, , *a != 0)@
@:mal_coercion_impl(bit,sht, , *a != 0)@
@:mal_coercion_impl(bit,int, , *a != 0)@
@:mal_coercion_impl(bit,lng, , *a != 0)@
@:mal_coercion_impl(bit,flt, , *a != 0)@
@:mal_coercion_impl(bit,dbl, , *a != 0)@

@:mal_coercion_impl(lng,oid,, (lng) *a)@
@:mal_coercion_impl(lng,chr,, (lng) *a)@
@:mal_coercion_impl(lng,bit,, (lng) *a)@
@:mal_coercion_impl(lng,sht,, (lng) *a)@
@:mal_coercion_impl(lng,int,, (lng) *a)@
@:mal_coercion_impl(lng,lng,, (lng) *a)@
@:mal_coercion_impl(lng,flt,, (lng) *a)@
@:mal_coercion_impl(lng,dbl,, (lng) *a)@

@:mal_coercion_impl(sht,oid, , (sht) *a)@
@:mal_coercion_impl(sht,bit, , (sht) *a)@
@:mal_coercion_impl(sht,chr, , (sht) *a)@
@:mal_coercion_impl(sht,sht, , (sht) *a)@
@:mal_coercion_impl(sht,int, , (sht) *a)@
@:mal_coercion_impl(sht,lng, , (sht) *a)@
@:mal_coercion_impl(sht,flt, , (sht) *a)@
@:mal_coercion_impl(sht,dbl, , (sht) *a)@

@:mal_coercion_impl(int,oid, , (int) *a)@
@:mal_coercion_impl(int,bit, , (int) *a)@
@:mal_coercion_impl(int,chr, , (int) *a)@
@:mal_coercion_impl(int,sht, , (int) *a)@
@:mal_coercion_impl(int,int, , (int) *a)@
@:mal_coercion_impl(int,lng, , (int) *a)@
@:mal_coercion_impl(int,flt, , (int) *a)@
@:mal_coercion_impl(int,dbl, , (int) *a)@

@:mal_coercion_impl(oid,bit, || *a < 0 , (oid) *a)@
@:mal_coercion_impl(oid,chr, || *a < 0 , (oid) *a)@
@:mal_coercion_impl(oid,oid, , (oid) *a)@
@:mal_coercion_impl(oid,lng, || *a < 0 , (oid) *a)@
@:mal_coercion_impl(oid,sht, || *a < 0 , (oid) *a)@
@:mal_coercion_impl(oid,int, || *a < 0 , (oid) *a)@
@:mal_coercion_impl(oid,flt, || *a < 0 , (oid) *a)@
@:mal_coercion_impl(oid,dbl, || *a < 0 , (oid) *a)@

@:mal_coercion_impl(flt,flt, , (flt) *a)@
@:mal_coercion_impl(flt,dbl, , (flt) *a)@
@:mal_coercion_impl(flt,sht, , (flt) *a)@
@:mal_coercion_impl(flt,chr, , (flt) *a)@
@:mal_coercion_impl(flt,int, , (flt) *a)@
@:mal_coercion_impl(flt,lng, , (flt) *a)@

@:mal_coercion_impl(dbl,dbl, , (dbl) *a)@
@:mal_coercion_impl(dbl,flt, , (dbl) *a)@
@:mal_coercion_impl(dbl,sht, , (dbl) *a)@
@:mal_coercion_impl(dbl,int, , (dbl) *a)@
@:mal_coercion_impl(dbl,chr, , (dbl) *a)@
@:mal_coercion_impl(dbl,lng, , (dbl) *a)@

@:mal_coercion_impl(chr,bit, , (chr) *a)@
@:mal_coercion_impl(chr,chr, , (chr) *a)@
@:mal_coercion_impl(chr,oid, , (chr) *a)@
@:mal_coercion_impl(chr,flt, , (chr) *a)@
@:mal_coercion_impl(chr,dbl, , (chr) *a)@
@:mal_coercion_impl(chr,sht, , (chr) *a)@
@:mal_coercion_impl(chr,int, , (chr) *a)@
@:mal_coercion_impl(chr,lng, , (chr) *a)@

calc_export str CALCbat2BAT(int *res, bat *bid);
str CALCbat2BAT(int *res, bat *bid){
	*res= *bid;
	BBPincref(*res, TRUE);
	return MAL_SUCCEED;
}
calc_export str CALCBAT2bat(bat *res, int *bid);
str CALCBAT2bat(int *res, bat *bid){
	*res= *bid;
	return MAL_SUCCEED;
}
@-
The conversion routines are relatively easy to define.
@= convertImpl

calc_export str CALCstr2@1(@1 *ret, str *val);
str CALCstr2@1(@1 *ret, str *val){
	int l = sizeof(@1);
	(void) @1FromStr(*val, &l, &ret);
	return MAL_SUCCEED;
}
calc_export str CALC@12str(str *ret, @1 *val);
str CALC@12str(str *ret, @1 *val){
	int l=0;

	if( *val == @1_nil)
		*ret= GDKstrdup(str_nil);
	else {
		if(*ret) l=strlen(*ret);
		(void) @1ToStr(ret,&l,val);
	}
	return MAL_SUCCEED;
}
str @1FromvoidImpl(@1 *ret, void *val){
	(void) val; /* fool compiler */
	memcpy(ret, ATOMnilptr(TYPE_@1), ATOMsize(TYPE_@1));
	return MAL_SUCCEED;
}
@-
Strings have to be dealt with differently, because
we recieve a pointer to the string directly.
To make it work properly, we need a call be reference
in those places where we leave a result behind.
@c
str
voidFromStrImpl(void *ret, str val)
{
	(void) val;		/* fool compiler */
	memcpy(ret, ATOMnilptr(TYPE_void), ATOMsize(TYPE_void));
	return MAL_SUCCEED;
}

calc_export str CALCnil2str(str *ret, void *val);
str
CALCnil2str(str *ret, void *val)
{
	(void) val;		/* fool compiler */
	*ret = GDKstrdup(str_nil);
	return MAL_SUCCEED;
}

calc_export str CALCstr2str(str *ret, str *val);
str
CALCstr2str(str *ret, str *val)
{
	if(*val) 
		*ret = GDKstrdup(*val);
	else *ret = 0;
	return MAL_SUCCEED;
}

calc_export str CALCstr2oid(oid *ret, str *val);
str
CALCstr2oid(oid *ret, str *val)
{
	int l = strlen(*val);

	(void) OIDfromStr(*val, &l, (ptr) ret);
	return MAL_SUCCEED;
}

calc_export str CALCoid2str(str *ret, oid *val);
str
CALCoid2str(str *ret, oid *val)
{
	int l = sizeof(oid);

	(void) OIDtoStr(ret, &l, val);
	return MAL_SUCCEED;
}

calc_export str CALCnil2void(oid *ret, ptr *val);
str
CALCnil2void(oid *ret, ptr *val)
{
	(void) val;		/* fool compiler */
	*ret = oid_nil;
	return MAL_SUCCEED;
}

calc_export str CALClng2void(oid *ret, lng *val);
str
CALClng2void(oid *ret, lng *val)
{
	*ret = (oid) *val;
	return MAL_SUCCEED;
}

calc_export str CALCsht2void(oid *ret, sht *val);
str
CALCsht2void(oid *ret, sht *val)
{
	*ret = *val;
	return MAL_SUCCEED;
}

calc_export str CALCint2void(oid *ret, int *val);
str
CALCint2void(oid *ret, int *val)
{
	*ret = *val;
	return MAL_SUCCEED;
}

calc_export str oidFromoidImpl(oid *ret, oid *val);
str
oidFromoidImpl(oid *ret, oid *val)
{
	*ret = *val;
	return MAL_SUCCEED;
}

calc_export str oidFromvoidImpl(oid *ret, void *val);
str
oidFromvoidImpl(oid *ret, void *val)
{
	(void) val;		/* fool compiler */
	memcpy(ret, ATOMnilptr(TYPE_oid), ATOMsize(TYPE_oid));
	return MAL_SUCCEED;
}

calc_export str CALCbat2batid(int *ret, int *bid);
str
CALCbat2batid(bat *ret, int *bid)
{
	BAT *b;

	if( *bid == bat_nil){
		*ret= bat_nil;
		return MAL_SUCCEED;
	}
	b = BATdescriptor(*bid);
	if (b == 0)
		throw(MAL, "calc.getBAT", "Bat does not exist");
	*ret = b->batCacheid;
	BBPkeepref(b->batCacheid);
	return MAL_SUCCEED;
}

calc_export str CALCbatid2bat(int *bid, int *ret);
str
CALCbatid2bat(int *bid, int *ret)
{
	BAT *b;

	if( *ret == bat_nil){
		*bid= bat_nil;
		return MAL_SUCCEED;
	}
	b = BATdescriptor(*ret);
	if (b == 0)
		throw(MAL, "calc.:bat", "Bat does not exist");
	*bid = b->batCacheid;
	BBPkeepref(*bid);
	return MAL_SUCCEED;
}

@:convertImpl(sht)@
@:convertImpl(int)@
@:convertImpl(lng)@
@:convertImpl(flt)@
@:convertImpl(dbl)@
@:convertImpl(bit)@
@:convertImpl(ptr)@
@:convertImpl(bat)@
@:convertImpl(chr)@

@-
@= setoidCode
calc_export str @1SetoidImpl(str *ret, @1 *v);
str @1SetoidImpl(str *ret, @1 *v){
	(void) ret; /* fool compiler */
	OIDbase((oid) *v);
	return MAL_SUCCEED;
}
@c
@:setoidCode(oid)@
@:setoidCode(lng)@
@:setoidCode(int)@

@-
Type conversion template. Only allowed then no information is lost.

@= coercionImpl
calc_export str @1From@2Impl(@1 *res, @2 *val);
str @1From@2Impl(@1 *res, @2 *val){
	*res = (@1) *val;
	return MAL_SUCCEED;
}
@c
@:coercionImpl(lng,oid)@
@:coercionImpl(lng,int)@
@:coercionImpl(lng,sht)@
@:coercionImpl(lng,bit)@
@:coercionImpl(int,sht)@
@:coercionImpl(int,bit)@
@:coercionImpl(dbl,flt)@
@:coercionImpl(oid,lng)@
@:coercionImpl(oid,int)@
@:coercionImpl(oid,sht)@

calc_export str shtFromlngImpl(sht *res, lng *val);
str
shtFromlngImpl(sht *res, lng *val)
{
	/* perform a range check !! */
	if (*val < 0 || *val > 255)
		throw(MAL, "calc.coercion", "error lng->sht");
	*res = (sht) *val;
	return MAL_SUCCEED;
}

calc_export str shtFromintImpl(sht *res, int *val);
str
shtFromintImpl(sht *res, int *val)
{
	/* perform a range check !! */
	if (*val < 0 || *val > 255)
		throw(MAL, "calc.coercion", "error int->sht");
	*res = *val;
	return MAL_SUCCEED;
}

@+ Value, Types and Variables
The routines below implement the OID utility functions.
@c
calc_export str CALCnewoidBase(oid *res);
str
CALCnewoidBase(oid *res)
{
	*res = OIDnew(1);
	return MAL_SUCCEED;
}

calc_export str CALCnewoidInc(oid *res, int *inc);
str
CALCnewoidInc(oid *res, int *inc)
{
	if (*inc <= 0)
		*res = OIDnew(1);
	else {
		*res = OIDnew(*inc);
	}
	return MAL_SUCCEED;
}

calc_export str CALCnewoidInclng(oid *res, lng *inc);
str
CALCnewoidInclng(oid *res, lng *inc)
{
	if (*inc <= 0)
		*res = OIDnew(1);
	else {
		*res = OIDnew((size_t) *inc);
	}
	return MAL_SUCCEED;
}

calc_export str CALCsetoidBase(oid *res);
str
CALCsetoidBase(oid *res)
{
	*res = OIDbase(1);
	return MAL_SUCCEED;
}

calc_export str CALCsetoidInc(oid *res, oid *inc);
str
CALCsetoidInc(oid *res, oid *inc)
{
	*res = OIDbase(*inc);
	return MAL_SUCCEED;
}
@}
