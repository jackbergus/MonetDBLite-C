@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2006 CWI.
@' All Rights Reserved.

@f batcalc
@a M.L. Kersten
@* BAT calculator
[TODO: property propagation]
Many applications require extension of the basic calculator and
mathematic functions to work on BAT arguments. Although the
MAL multiplex module contains a command ('multiplex.script')
to generate the necessary code, it is often much more efficient to 
use one of the dedidacted batcalc functions introduced below.

The operators supported are limited to the built-in fixed length
atoms, because they permit ease of storage of the operation result.
Variable sized atoms, especially user defined, may require more
administrative activities.
Furthermore, the operands involved are assumed to be aligned
to assure the fastest possible join evaluation.

Optimal processing performance is further obtained when the operators
can work as 'accumulators', for then we do not pay the price
of space allocation for a new intermediate. It may imply a BATcopy
before the accummulator function is being called.
A new BAT is of course created when the result of a function does not fit 
the accumulator.

The implementation does not take into account possible overflows
caused by the operators. However, the operators respect the NIL
semantics and division by zero produces a NIL.

In addition to arithmetic and comparison operators, casting and
mathematical functions are directly supported.

@+ NULL semantics
The batcalc arithmetic is already constraint to BATs of equal size.
Another improvement can be obtained when we do not have to check
for NULLs in each and every basic operation +,-,/,* and comparisons.
This variant can be obtained using a compile time flag (NULLTST) for the time
being. If it turns out to be effective, we will derive a new
version of batcalc.
Preliminary experiments show that ignoring the NULLS saves about 15\%
for larger instructions.
@mal
module batcalc;

@+ Basic arithmetic
The first group of functions provide abstractions over the
binary operators +,/,-,*, and %. Both on (BAT,BAT) and (BAT,CST)
operands. We also support the type enlargement and auto coercions,
because they avoid expensive BAT copying.
BAT initialization takes a reference void bat, or the required size.
@{
Actullay, the initialization group should belong to the BAT module,
because it is a contraction of a BATnew and a series of inserts.
@}
@= initGrp
	command init(bsize:sht,v:@1):bat[:void,:@1]
	address CMD@1init_sht
	comment "Initialize a void BAT with a tail constant";

	command init(bsize:int,v:@1):bat[:void,:@1]
	address CMD@1init_int
	comment "Initialize a void BAT with a tail constant";

	command init(bsize:lng,v:@1):bat[:void,:@1]
	address CMD@1init_lng
	comment "Initialize a void BAT with a tail constant";

	command init(b:bat[:any_1,:any],v:@1):bat[:any_1,:@1]
	address CMDbat@1init
	comment "Initialize a BAT with a tail constant";
@-
@mal
	@:initGrp(oid)@
	@:initGrp(int)@
	@:initGrp(sht)@
	@:initGrp(lng)@
	@:initGrp(dbl)@
	@:initGrp(flt)@
	@:initGrp(bit)@
@= calcGrp

	command @1(a:bat[:any_1,:@4], b:bat[:any_1,:@5], c:bat[:any_1,:@2]):bat[:any_1,:@4]
	address CMDbataccum@3_@2_@4_@5
	comment "Binary BAT calculator function with accumulator BAT result";

	command @1(a:bat[:any_1,:@4], cst:@4, b:bat[:any_1,:@5]):bat[:any_1,:@4]
	address CMDbataccum@3cst2_@2_@4_@5
	comment "(BAT,Constant) calculator function with accumulator BAT result";

	command @1(a:bat[:any_1,:@4], b:bat[:any_1,:@4], cst:@5) :bat[:any_1,:@4]
	address CMDbataccum@3cst_@2_@4_@5
	comment "(BAT,Constant) calculator function with accumulator BAT result";

	command @1(b:bat[:any_1,:@4], cst:@5) :bat[:any_1,:@2] 
	address CMDbat@3cst_@2_@4_@5;

	command @1(cst:@4, b:bat[:any_1,:@5]) :bat[:any_1,:@2] 
	address CMDcst@3bat_@2_@4_@5;

	command @1(b:bat[:any_1,:@4], c:bat[:any_1,:@5]) :bat[:any_1,:@2] 
	address CMDbat@3_@2_@4_@5
	comment "Binary BAT calculator function with new BAT result";

	command @1(b:bat[:void,:@4], c:bat[:oid,:@5]) :bat[:oid,:@2] 
	address CMDbat@3_@2_@4_@5
	comment "Binary BAT calculator function with new BAT result";
@{
@-
We need instantiations for the accumulator code,
but should limit modulo functions to integer-based types.
The calc group contains the operator, the desired result typ, its
C qualifier and the operands
@mal
	@:calcGrp(%,oid,MOD,oid,oid)@
	@:calcGrp(%,sht,MOD,sht,sht)@
	@:calcGrp(%,int,MOD,int,int)@
	@:calcGrp(%,lng,MOD,lng,lng)@
	@:calcGrp(xor,oid,XOR,oid,oid)@
	@:calcGrp(xor,sht,XOR,sht,sht)@
	@:calcGrp(xor,int,XOR,int,int)@
	@:calcGrp(xor,lng,XOR,lng,lng)@
	@:calcGrp(and,oid,AND,oid,oid)@
	@:calcGrp(and,sht,AND,sht,sht)@
	@:calcGrp(and,int,AND,int,int)@
	@:calcGrp(and,lng,AND,lng,lng)@
	@:calcGrp(or,oid,OR,oid,oid)@
	@:calcGrp(or,sht,OR,sht,sht)@
	@:calcGrp(or,int,OR,int,int)@
	@:calcGrp(or,lng,OR,lng,lng)@

	@:calcGrp(/,dbl,DIV,dbl,dbl)@
	@:calcGrp(/,flt,DIV,flt,flt)@
	@:calcGrp(/,lng,DIV,int,sht)@
	@:calcGrp(/,lng,DIV,sht,int)@
	@:calcGrp(/,lng,DIV,lng,sht)@
	@:calcGrp(/,lng,DIV,sht,lng)@
	@:calcGrp(/,lng,DIV,sht,sht)@
	@:calcGrp(/,lng,DIV,lng,int)@
	@:calcGrp(/,lng,DIV,int,lng)@
	@:calcGrp(/,lng,DIV,int,int)@
	@:calcGrp(/,int,DIV,sht,sht)@
	@:calcGrp(/,int,DIV,int,sht)@
	@:calcGrp(/,int,DIV,sht,int)@
	@:calcGrp(/,sht,DIV,sht,sht)@
	@:calcGrp(/,lng,DIV,lng,lng)@
	@:calcGrp(/,int,DIV,int,int)@

	@:calcGrp(*,dbl,MUL,dbl,dbl)@
	@:calcGrp(*,flt,MUL,flt,flt)@
	@:calcGrp(*,lng,MUL,int,sht)@
	@:calcGrp(*,lng,MUL,sht,int)@
	@:calcGrp(*,lng,MUL,lng,sht)@
	@:calcGrp(*,lng,MUL,sht,lng)@
	@:calcGrp(*,lng,MUL,sht,sht)@
	@:calcGrp(*,lng,MUL,lng,int)@
	@:calcGrp(*,lng,MUL,int,lng)@
	@:calcGrp(*,lng,MUL,int,int)@
	@:calcGrp(*,int,MUL,sht,sht)@
	@:calcGrp(*,int,MUL,int,sht)@
	@:calcGrp(*,int,MUL,sht,int)@
	@:calcGrp(*,sht,MUL,sht,sht)@
	@:calcGrp(*,lng,MUL,lng,lng)@
	@:calcGrp(*,int,MUL,int,int)@

	@:calcGrp(-,dbl,SUB,dbl,dbl)@
	@:calcGrp(-,flt,SUB,flt,flt)@
	@:calcGrp(-,lng,SUB,int,sht)@
	@:calcGrp(-,lng,SUB,sht,int)@
	@:calcGrp(-,lng,SUB,lng,sht)@
	@:calcGrp(-,lng,SUB,sht,lng)@
	@:calcGrp(-,lng,SUB,lng,lng)@
	@:calcGrp(-,lng,SUB,int,lng)@
	@:calcGrp(-,lng,SUB,int,int)@
	@:calcGrp(-,int,SUB,sht,sht)@
	@:calcGrp(-,int,SUB,int,sht)@
	@:calcGrp(-,int,SUB,sht,int)@
	@:calcGrp(-,sht,SUB,sht,sht)@
	@:calcGrp(-,lng,SUB,lng,int)@
	@:calcGrp(-,int,SUB,int,int)@

	@:calcGrp(+,dbl,ADD,dbl,dbl)@
	@:calcGrp(+,flt,ADD,flt,flt)@
	@:calcGrp(+,lng,ADD,int,sht)@
	@:calcGrp(+,lng,ADD,sht,int)@
	@:calcGrp(+,lng,ADD,lng,sht)@
	@:calcGrp(+,lng,ADD,sht,lng)@
	@:calcGrp(+,lng,ADD,lng,int)@
	@:calcGrp(+,lng,ADD,int,lng)@
	@:calcGrp(+,lng,ADD,int,int)@
	@:calcGrp(+,int,ADD,int,int)@
	@:calcGrp(+,int,ADD,sht,sht)@
	@:calcGrp(+,int,ADD,int,sht)@
	@:calcGrp(+,sht,ADD,sht,sht)@
	@:calcGrp(+,lng,ADD,lng,lng)@
	@:calcGrp(+,int,ADD,sht,int)@


@-
@}
@= unary
	command -(b:bat[:any_1,:@1]):bat[:any_1,:@1] 
	address CMDunaryMIN
	comment "Unary minus over the tail of the bat";
	
	command --(b:bat[:any_1,:@1]):bat[:any_1,:@1] 
	address CMDunaryMINMIN
	comment "Unary minus over the tail of the bat";

	command ++(b:bat[:any_1,:@1]):bat[:any_1,:@1] 
	address CMDunaryPLUSPLUS
	comment "Unary minus over the tail of the bat";

	#command -(a:bat[:any_1,:@1],b:bat[:any_1,:@1])
	#		:bat[:any_1,:@1] 
	#address CMDunaryAccumMIN 
	#comment "Unary - over the tail of the bat";

	#command --(a:bat[:any_1,:@1],b:bat[:any_1,:@1])
	#		:bat[:any_1,:@1] 
	#address CMDunaryAccumMINMIN 
	#comment "Unary -- over the tail of the bat";
	#
	#command ++(a:bat[:any_1,:@1],b:bat[:any_1,:@1])
	#		:bat[:any_1,:@1] 
	#address CMDunaryAccumPLUSPLUS 
	#comment "Unary ++ over the tail of the bat";
@{
@mal
@:unary(oid)@
@:unary(int)@
@:unary(lng)@
@:unary(sht)@
@:unary(flt)@
@:unary(dbl)@
@}
@+ Comparison routines
The command signatures are similar to those above, producing a bit result.
@= comparison
	command @1(b:bat[:any_1,:@2], c:bat[:any_1,:@2]) :bat[:any_1,:bit]
	address CMDcmp@3;
	command @1(a:bat[:any_1,:bit], b:bat[:any_1,:@2], c:bat[:any_1,:@2])
	:bat[:any_1,:bit]
	address CMDcmpaccum@3;
	command @1(b:bat[:any_1,:@2],cst:@2) :bat[:any_1,:bit]
	address CMDcmp@3cst;
	command @1(a:bat[:any_1,:bit], b:bat[:any_1,:@2],cst:@2) :bat[:any_1,:bit]
	address CMDcmpaccum@3cst;


@= compareGrp
	@:comparison(<,@1,LT)@
	@:comparison(==,@1,EQ)@
	@:comparison(!=,@1,NEQ)@
	@:comparison(>,@1,GT)@
	@:comparison(<=,@1,LE)@
	@:comparison(>=,@1,GE)@
@mal
	@:compareGrp(bit)@
	@:compareGrp(dbl)@
	@:compareGrp(flt)@
	@:compareGrp(oid)@
	@:compareGrp(sht)@
	@:compareGrp(int)@
	@:compareGrp(lng)@

	@:comparison(and,bit,AND)@
	@:comparison(or,bit,OR)@

command ==( left:bat[:void,:any_1], right:bat[:oid,:any_1]) :bat[:void,:bit]
address CMDcmpEQ;
command ==( left:bat[:oid,:any_1], right:bat[:void,:any_1]) :bat[:void,:bit]
address CMDcmpEQ;
command ==( left:bat[:void,:any_1], right:bat[:void,:any_1]) :bat[:void,:bit]
address CMDcmpEQ;

@}
@+ Boolean operations
The command signature can mostly be borrowed from the arithmetic.

@mal
command not(b:bat[:any_1,:bit]):bat[:any_1,:bit] 
address CMDbitbatNOT
comment "Return a new BAT with the negated tail";

command not(a:bat[:any_1,:bit], b:bat[:any_1,:bit]):bat[:any_1,:bit] 
address CMDbitbataccumNOT
comment "Return a BAT with the negated tail";

command ifthenelse(b:bat[:any_1,:bit], e:any_2, t:bat[:any_1,:any_2])
	:bat[:any_1,:any_2] 
address CMDifThenElseCst1
comment "If-then-else operation to assemble a 
	conditional result ";

command ifthenelse(b:bat[:any_1,:bit], t:bat[:any_1,:any_2], e:any_2)
	:bat[:any_1,:any_2] 
address CMDifThenElseCst2
comment "If-then-else operation to assemble a conditional result ";

command ifthen(b:bat[:any_1,:bit], t:bat[:any_1,:any_2]) :bat[:any_1,:any_2] 
address CMDifThen
comment "Ifthen operation to assemble a conditional result ";

command ifthenelse(b:bat[:any_3,:bit], t:bat[:any_1,:any_2], 
		e:bat[:any_1,:any_2]) :bat[:any_1,:any_2] 
address CMDifThenElse
comment "If-then-else operation to assemble a conditional result ";

@-
@= ifthenGrp
command project(v:@1,b:bat[:any_2,:any_1]) :bat[:@1,:any_1] 
address CMDprojecthead_@1
comment "Fill the head with a constant, e.g. [0~b]";
command project(b:bat[:any_2,:any_1],v:@1) :bat[:any_2,:@1] 
address CMDprojecttail_@1
comment "Fill the tail with a constant, e.g. [0~b]";

command ifthen(b:bat[:any_1,:bit], v:@1) :bat[:any_1,:@1] 
address CMDifThenCst_@1
comment "Ifthen operation to assemble a conditional result ";

command ifthenelse(b:bat[:any_1,:bit], v:@1,w:@1) :bat[:any_1,:@1] 
address CMDifThenElseCst_@1
comment "Ifthen operation to assemble a conditional result ";
@{
@mal
	@:ifthenGrp(bit)@
	@:ifthenGrp(chr)@
	@:ifthenGrp(str)@
	@:ifthenGrp(oid)@
	@:ifthenGrp(int)@
	@:ifthenGrp(sht)@
	@:ifthenGrp(lng)@
	@:ifthenGrp(flt)@
	@:ifthenGrp(dbl)@
@}
@+ Coercion routines
The coercion routines over BATs can not easily speed up using
an accumulator approach, because they often require different storage space. 
Nevertheless, the implementation provided here are much faster compared
to theVersion 4.3 implementation.

@= coercion
	command @2(b:bat[:any_1,:@1]):bat[:any_1,:@2] 
	address CMDconvert@1_@2
	comment "Coerce an @1 tail to a bat with @2 tail.";
@{
@-
@= coerceList
	@:coercion(@1,dbl)@
	@:coercion(@1,flt)@
	@:coercion(@1,sht)@
	@:coercion(@1,int)@
	@:coercion(@1,oid)@
	@:coercion(@1,lng)@
@mal
	@:coerceList(sht)@
	@:coerceList(int)@
	@:coerceList(lng)@
	@:coerceList(flt)@
	@:coerceList(dbl)@

	@:coercion(bit,lng)@
	@:coercion(bit,sht)@
	@:coercion(bit,int)@

command int(b:bat[:any_1,:str]):bat[:any_1,:int] 
address CMDconvertstr_int
comment "Coerce an str tail to a bat with a int tail.";

command oid(b:bat[:oid,:oid]):bat[:oid,:oid] 
address CMDconvertOIDclass
comment "Identity mapping";

command int(b:bat[:any_1,:oid]):bat[:any_1,:int] 
address CMDconvertoid_int
comment "Coerce an oid tail to a bat with int tail.";
command lng(b:bat[:any_1,:oid]):bat[:any_1,:lng] 
address CMDconvertoid_lng
comment "Coerce an oid tail to a bat with lng tail.";
command sht(b:bat[:any_1,:oid]):bat[:any_1,:sht] 
address CMDconvertoid_sht
comment "Coerce an oid tail to a bat with sht tail.";

command oid(b:bat[:any_1,:int]):bat[:any_1,:oid] 
address CMDconvertint_oid
comment "Materialize the int into an oid";

command oid(b:bat[:void,:int]):bat[:void,:oid] 
address CMDconvertvoid_int_oid
comment "Materialize the int into an oid";

command oid(b:bat[:void,:oid]):bat[:void,:oid] 
address CMDconvertvoid_oid_oid
comment "Materialize the oid into an oid";

command str(b:bat[:any_1,:str]):bat[:any_1,:str]
address CMDconvertstr_str;
command bit(b:bat[:any_1,:str]):bat[:any_1,:bit]
address CMDconvertstr_bit;

command identity(b:bat[:any_1,:any_2]):bat[:any_1,:any_2]
address CMDconvertvoid_oid_oid;
command identity(b:bat[:void,:any_1]):bat[:oid,:any_1]
address CMDconvertvoid_oid_oid;

command materialize(b:bat[:any_1,:any_2]):bat[:any_1,:any_2]
address CMDmaterialize;
command materialize(b:bat[:void,:any_1]):bat[:oid,:any_1]
address CMDmaterialize
comment "Materialize the void column";

command reuse(b:bat[:any_1,:any_2]):bat[:any_1,:any_2]
address CMDreuse;
@-
@}
@{
@- Implementation
@h
#include "gdk.h"
#include "math.h"
#include "mal_exception.h"

#ifdef WIN32
#ifndef LIBBATCALC
#define batcalc_export extern __declspec(dllimport)
#else
#define batcalc_export extern __declspec(dllexport)
#endif
#else
#define batcalc_export extern
#endif

#define NULLTST
@-
The accumulator operators are relatively straight forward,
when the target BAT is known and we only have to deal with
fixed-sized types. 
@= batinit
	s@1= BUNsize(@2);
	p@1= (str) (BUNfirst(@2)+@2->tloc);
@-
@= accum
	while( p1 < hend ){
		/* this code is better as x?nil:y  */
#ifdef NULLTST
		if(*(@3 *)p2 == @3_nil || *(@4*)p3 == @4_nil)
			*(@1*)p1= @1_nil;
		else 
#endif
			*(@1*)p1= (@1) (* (@3*) p2 @2 *(@4 *) p3);
		p1= (ptr)( ((char*)p1) + s1);
		p2= (ptr)( ((char*)p2) + s2);
		p3= (ptr)( ((char*)p3) + s3);
	}
@= accumDIV
	while( p1 < hend ){
		/* this code is better as x?nil:y  */
		if (*(@4*)p3 == 0) {
				res = throwMessage("batcalc.@1", "Division by zero");
			break;
		} else
#ifdef NULLTST
		if (*(@3 *)p2 == @3_nil || *(@4*)p3 == @4_nil)
			*(@1*)p1= @1_nil;
		else 
#endif
			*(@1*)p1= (@1)(* (@3*) p2 @2 *(@4 *) p3);
		p1= (ptr)( ((char*)p1) + s1);
		p2= (ptr)( ((char*)p2) + s2);
		p3= (ptr)( ((char*)p3) + s3);
	}
@-
This code could be further improved by factoring
out occurrences of the nil-tst on the constant provided.
This has been left out.
@= accumCst
	while( p1 < hend ){
#ifdef NULLTST
		if(*(@3 *)p2 == @3_nil || *(@4*)cst == @4_nil)
			*(@1*)p1= @1_nil;
		else 
#endif
			*(@1*)p1 = *(@3*) p2 @2 *(@4 *) cst;
		p1= (ptr)( ((char *)p1) + s1);
		p2= (ptr)( ((char *)p2) + s2);
	}
@= accumCstLeft
	while( p1 < hend ){
#ifdef NULLTST
		if(*(@3 *)p2 == @3_nil || *(@4*)cst == @4_nil)
			*(@1*)p1= @1_nil;
		else 
#endif
			*(@1*)p1 = *(@3*) cst @2 *(@4 *) p2;
		p1= (ptr)( ((char *)p1) + s1);
		p2= (ptr)( ((char *)p2) + s2);
	}
@= accumCstDIV
	while( p1 < hend ){
		if(*(@3*)cst == 0) { 
				res = throwMessage("batcalc.@1", "Division by zero");
			break;
		} else 
#ifdef NULLTST
		if(*(@3*)cst == @3_nil || *(@4 *)p2 == @4_nil)
			*(@1*)p1 = @1_nil;
		else 
#endif
			*(@1*)p1 = *(@3 *) cst @2 *(@4*) p2;
		p1= (ptr)( ((char *)p1) + s1);
		p2= (ptr)( ((char *)p2) + s2);
	}
@-
A general assumption in all cases is the bats are synchronized on their
head column. This is not checked and may be mis-used to deploy the
implementation for shifted window arithmetic as well.
@= chkSize
	if( BATcount(@1) != BATcount(@2) )
	return throwMessage("batcalc.@3", "requires bats of identical size");
@= tstBat
if( bn== NULL) {*ret= 0; 
	return throwMessage("batcalc.@1", "can not create bat");}
@-
The code block below heavily uses the MX code expansion involved,
but in essence the structure is relatively simple.
The BAT loops to cover the cases for arithmetic are
collected in bataccum<operator>. Initialization of the
two primary command structures are dealt with in the CMD* alternatives.
The similar code base is produced for dealing with a constant argument. 
@= loopImpl
{	size_t s1,s2,s3;
	ptr p1,p2,p3, hend;

	@:batinit(1,dst)@
	@:batinit(2,left)@
	@:batinit(3,right)@
	hend = (str) BUNlast(dst);
	if( '@1' == '/'){ 
		while( p1 < hend ){
			/* this code is better as x?nil:y  */
			if (*(@5*)p3== 0) {
					res = throwMessage("batcalc.@1", "Division by zero");
				break;
				
			} else 
#ifdef NULLTST
			if (*(@4 *)p2 == @4_nil || *(@5*)p3 == @5_nil)
				*(@3*)p1= @3_nil;
			else 
#endif
				*(@3*)p1= (@3)(* (@4*) p2 / *(@5 *) p3);
			p1= (ptr)( ((char*)p1) + s1);
			p2= (ptr)( ((char*)p2) + s2);
			p3= (ptr)( ((char*)p3) + s3);
		}
	} else {
		while( p1 < hend ){
			/* this code is better as x?nil:y  */
#ifdef NULLTST
			if(*(@4 *)p2 == @4_nil || *(@5*)p3 == @5_nil)
				*(@3*)p1= @3_nil;
			else 
#endif
				*(@3*)p1= (@3) (* (@4*) p2 @1 *(@5 *) p3);
			p1= (ptr)( ((char*)p1) + s1);
			p2= (ptr)( ((char*)p2) + s2);
			p3= (ptr)( ((char*)p3) + s3);
		}
	}
}
@= arithmeticImpl
batcalc_export str CMDbat@2_@3_@4_@5(int *ret, int *l, int *r);
str CMDbat@2_@3_@4_@5(int *ret, int *l, int *r)
{	BAT *dst, *left, *right;
	char *res = MAL_SUCCEED;

	if( (left= BATdescriptor(*l)) == NULL ){
		return throwMessage("batcalc.@1", "Cannot access descriptor");
	}
	if( (right= BATdescriptor(*r)) == NULL ){
		BBPreleaseref(left->batCacheid);
		return throwMessage("batcalc.@1", "Cannot access descriptor");
	}
	@:chkSize(left,right,CMDbat@2)@

	if (left->ttype == TYPE_@3)
		dst= BATwcopy(left);
	else
		dst= BATwcopy(right);
	if( dst == NULL){
		BBPreleaseref(left->batCacheid);
		BBPreleaseref(right->batCacheid);
		return throwMessage("batcalc.@1", "no copy available ");
	}
	@:loopImpl(@1,@2,@3,@4,@5)@
	BBPreleaseref(left->batCacheid);
	BBPreleaseref(right->batCacheid);
	BATkey(BATmirror(dst),0);           
	dst->tsorted = 0;
	if (!(dst->batDirty&2)) dst = BATsetaccess(dst, BAT_READ); \
	*ret = dst->batCacheid;
	BBPkeepref(*ret);
	return res;
}

batcalc_export str CMDbataccum@2_@3_@4_@5(int *ret, int *d, int *l, int *r);
str CMDbataccum@2_@3_@4_@5(int *ret, int *d, int *l, int *r)
{	BAT *dst, *left, *right;
	char *res = MAL_SUCCEED;

	if( (dst= BATdescriptor(*d)) == NULL ){
		return throwMessage("batcalc.@1", "Cannot access descriptor");
	}
	if( (left= BATdescriptor(*l)) == NULL ){
		BBPreleaseref(dst->batCacheid);
		return throwMessage("batcalc.@1", "Cannot access descriptor");
	}
	if( (right= BATdescriptor(*r)) == NULL ){
		BBPreleaseref(dst->batCacheid);
		BBPreleaseref(left->batCacheid);
		return throwMessage("batcalc.@1", "Cannot access descriptor");
	}

	@:chkSize(dst,left,CMDbataccum@2)@
	@:chkSize(dst,right,CMDbataccum@2)@

	@:loopImpl(@1,@2,@3,@4,@5)@
	BATkey(BATmirror(dst),0);           
	dst->tsorted = 0;
	if (!(dst->batDirty&2)) dst = BATsetaccess(dst, BAT_READ); \
	*ret = dst->batCacheid;
	BBPkeepref(dst->batCacheid);
	BBPreleaseref(left->batCacheid);
	BBPreleaseref(right->batCacheid);
	return res;
}

batcalc_export str CMDbataccum@2cst_@3_@4_@5(int *ret, int *r, int *l, void *cst);
str CMDbataccum@2cst_@3_@4_@5(int *ret, int *r, int *l, void *cst)
{	BAT *dst, *left;
	size_t s1,s2;
	ptr p1,p2, hend;
	char *res = MAL_SUCCEED;

	if( (dst= BATdescriptor(*r)) == NULL ){
		return throwMessage("batcalc.@1", "Cannot access descriptor");
	}
	if( (left= BATdescriptor(*l)) == NULL ){
		BBPreleaseref(dst->batCacheid);
		return throwMessage("batcalc.@1", "Cannot access descriptor");
	}
	@:chkSize(dst,left,CMDbataccum@2)@
	@:batinit(1,dst)@
	@:batinit(2,left)@
	hend = (str) BUNlast(dst);

	if( '@1'== '/') {
		if (*(@5*)cst == 0) {
			res = throwMessage("batcalc.@1", "Division by zero");
		} else {
			@:accumCst(@3,@1,@4,@5)@ 
		}
	} else {
		@:accumCst(@3,@1,@4,@5)@ 
	}
	if (!(dst->batDirty&2)) dst = BATsetaccess(dst, BAT_READ); \
	dst->tsorted = 0;
	*ret = dst->batCacheid;
	BBPkeepref(dst->batCacheid);
	BBPreleaseref(left->batCacheid);
	return res;
}
batcalc_export str CMDbataccum@2cst2_@3_@4_@5(int *ret, int *r, void *cst, int *l);
str CMDbataccum@2cst2_@3_@4_@5(int *ret, int *r, void *cst, int *l)
{	BAT *dst, *left;
	size_t s1,s2;
	ptr p1,p2, hend;
	char *res = MAL_SUCCEED;

	if( (dst= BATdescriptor(*r)) == NULL ){
		return throwMessage("batcalc.@1", "Cannot access descriptor");
	}
	if( (left= BATdescriptor(*l)) == NULL ){
		BBPreleaseref(dst->batCacheid);
		return throwMessage("batcalc.@1", "Cannot access descriptor");
	}
	@:chkSize(dst,left,CMDbataccum@2)@
	@:batinit(1,dst)@
	@:batinit(2,left)@
	hend = (str) BUNlast(dst);

	if( '@1'== '/') {
		@:accumCstDIV(@3,@1,@4,@5)@ 
	} else {
		@:accumCstLeft(@3,@1,@4,@5)@ 
	}
	if (!(dst->batDirty&2)) dst = BATsetaccess(dst, BAT_READ); \
	dst->tsorted = 0;
	*ret = dst->batCacheid;
	BBPkeepref(dst->batCacheid);
	BBPreleaseref(left->batCacheid);
	return res;
}

batcalc_export str CMDbat@2cst_@3_@4_@5(int *ret, int *l, void *cst);
str CMDbat@2cst_@3_@4_@5(int *ret, int *l, void *cst)
{	BAT *dst, *left;
	size_t s1,s2;
	ptr p1,p2, hend;
	char *res = MAL_SUCCEED;

	if( (left= BATdescriptor(*l)) == NULL ){
		return throwMessage("batcalc.@1", "Cannot access descriptor");
	}
	dst= newBATresult(left, TYPE_@3);
	if( dst == NULL){
		BBPreleaseref(left->batCacheid);
		return throwMessage("batcalc.@1", "no copy available ");
	}
	copyHead(dst,left);

	@:batinit(1,dst)@
	@:batinit(2,left)@

	hend = ((str) BUNlast(dst)) + (s1*BATcount(left));

	if( '@1'== '/') {
		if (*(@5*)cst == 0) {
				res = throwMessage("batcalc.@1", "Division by zero");
		} else {
			@:accumCst(@3,@1,@4,@5)@ 
		}
	} else {
		@:accumCst(@3,@1,@4,@5)@ 
	}
	dst->batBuns->free = BATcount(left) * s1;
	BATsetcount(dst, BATcount(left));
	dst->tsorted = 0;
	if (!(dst->batDirty&2)) dst = BATsetaccess(dst, BAT_READ); \
	*ret = dst->batCacheid;
	BBPkeepref(dst->batCacheid);
	BBPreleaseref(left->batCacheid);
	return res;
}
batcalc_export str CMDcst@2bat_@3_@4_@5(int *ret, void *cst, int *l);
str CMDcst@2bat_@3_@4_@5(int *ret, void *cst, int *l)
{	BAT *dst, *left;
	size_t s1,s2;
	ptr p1,p2, hend;
	char *res = MAL_SUCCEED;

	if( (left= BATdescriptor(*l)) == NULL ){
		return throwMessage("batcalc.@1", "Cannot access descriptor");
	}
	dst= newBATresult(left, TYPE_@3);
	if( dst == NULL){
		BBPreleaseref(left->batCacheid);
		return throwMessage("batcalc.@1", "no copy available ");
	}
	copyHead(dst,left);

	@:batinit(1,dst)@
	@:batinit(2,left)@

	hend = ((str) BUNlast(dst)) + (s1*BATcount(left));

	if( '@1'== '/') {
		@:accumCstDIV(@3,@1,@4,@5)@ 
	} else {
		@:accumCstLeft(@3,@1,@4,@5)@ 
	}
	dst->batBuns->free = BATcount(left) * s1;
	BATsetcount(dst, BATcount(left));
	dst->tsorted = 0;
	if (!(dst->batDirty&2)) dst = BATsetaccess(dst, BAT_READ); \
	*ret = dst->batCacheid;
	BBPkeepref(dst->batCacheid);
	BBPreleaseref(left->batCacheid);
	return res;
}
@= initImpl
void bat@1filler(BAT *dst, @1 cst, size_t cap){
	size_t s1;
	ptr p1, hend;
	dst->batBuns->free = cap * BUNsize(dst);
	BATsetcount(dst, cap);
	hend = (str) BUNlast(dst);
	@:batinit(1,dst)@
	while( p1 < hend ){
#ifdef NULLTST
		if((@1)cst == @1_nil)
			*(@1*)p1= @1_nil;
		else 
#endif
			*(@1*)p1 = (@1) cst;
		p1= (ptr)( ((char *)p1) + s1);
	}
	BATkey(BATmirror(dst),0);           
	dst->tsorted = GDK_SORTED;
	BBPkeepref(dst->batCacheid);
}
batcalc_export str CMDbat@1init(int *ret, int *l, @1 *cst);
str CMDbat@1init(int *ret, int *l, @1 *cst) {
	BAT *left, *dst;
	if( (left= BATdescriptor(*l)) == NULL ){
		return throwMessage("batcalc.@1", "Cannot access descriptor");
	}
	dst= newBATresult(left, TYPE_@1);
	if( dst == NULL){
		BBPreleaseref(left->batCacheid);
		return throwMessage("batcalc.@1", "no space available ");
	}
	copyHead(dst,left);
	BATseqbase(dst,0);
	bat@1filler(dst,*cst, (size_t) BATcount(left));
	BBPreleaseref(left->batCacheid);
	if (!(dst->batDirty&2)) dst = BATsetaccess(dst, BAT_READ); \
	*ret = dst->batCacheid;
	return MAL_SUCCEED;
}
batcalc_export str CMD@1init_int(int *ret, int *size, @1 *cst);
str CMD@1init_int(int *ret, int *size, @1 *cst) {
	BAT *dst;
	size_t s= *size;
	dst= BATnew(TYPE_void, TYPE_@1, s);
	if( dst == NULL){
		return throwMessage("batcalc.@1", "no space available ");
	}
	BATseqbase(dst,0);
	bat@1filler(dst,*cst,s);
	if (!(dst->batDirty&2)) dst = BATsetaccess(dst, BAT_READ); \
	*ret = dst->batCacheid;
	return MAL_SUCCEED;
}
batcalc_export str CMD@1init_lng(int *ret, lng *size, @1 *cst);
str CMD@1init_lng(int *ret, lng *size, @1 *cst) {
	BAT *dst;
	size_t s= (size_t) *size;
	dst= BATnew(TYPE_void, TYPE_@1, s);
	if( dst == NULL){
		return throwMessage("batcalc.@1", "no space available ");
	}
	BATseqbase(dst,0);
	bat@1filler(dst,*cst,s);
	if (!(dst->batDirty&2)) dst = BATsetaccess(dst, BAT_READ); \
	*ret = dst->batCacheid;
	return MAL_SUCCEED;
}
batcalc_export str CMD@1init_sht(int *ret, sht *size, @1 *cst);
str CMD@1init_sht(int *ret, sht *size, @1 *cst){
	BAT *dst;
	size_t s= *size;
	dst= BATnew(TYPE_void, TYPE_@1, s);
	if( dst == NULL){
		return throwMessage("batcalc.@1", "no space available ");
	}
	BATseqbase(dst,0);
	bat@1filler(dst,*cst,s);
	if (!(dst->batDirty&2)) dst = BATsetaccess(dst, BAT_READ); \
	*ret = dst->batCacheid;
	return MAL_SUCCEED;
}
@c
#include "batcalc.h"

#define BATwcopy(b) BATcopy(b, b->htype, b->ttype, TRUE)
BAT *
newBATresult(BAT *b, int tpe)
{
	BAT *bn;

	if (BAThvoid(b)) {
		bn = BATnew(TYPE_void, tpe, BATcount(b));
		BATseqbase(bn, b->hseqbase);
	} else
		bn = BATnew(b->htype, tpe, BATcount(b));
	bn->hsorted = b->hsorted;
	bn->tsorted = b->tsorted;
	return bn;
}

void
copyHead(BAT *dst, BAT *org)
{
	if (BAThvoid(org)) {
		BATseqbase(dst, org->hseqbase);
	} else { /* works for fixed size only now, need to use a VIEW of the
		    original in case of varsized atoms */
		size_t s1,s2;
		ptr p1,p2,hend;
		int atomsize = ATOMsize(dst->htype);

		s1 = BUNsize(dst);
		p1 = (str) (BUNfirst(dst)+dst->hloc);
		s2 = BUNsize(org);
		p2 = (str) (BUNfirst(org)+org->hloc);
		hend = (str) BUNlast(org);
		switch(atomsize){
		case 1:
			while( p2<hend) {
				*(chr*)p1 = *(chr*)p2;
				p1= (ptr)( ((char*)p1) + s1);
				p2= (ptr)( ((char*)p2) + s2);
			}
		case 2:
			while( p2<hend) {
				*(sht*)p1 = *(sht*)p2;
				p1= (ptr)( ((char*)p1) + s1);
				p2= (ptr)( ((char*)p2) + s2);
			}
		case 4:
			while( p2<hend) {
				*(int*)p1 = *(int*)p2;
				p1= (ptr)( ((char*)p1) + s1);
				p2= (ptr)( ((char*)p2) + s2);
			}
		case 8:
			while( p2<hend) {
				*(lng*)p1 = *(lng*)p2;
				p1= (ptr)( ((char*)p1) + s1);
				p2= (ptr)( ((char*)p2) + s2);
			}
		default:
			while( p2<hend) {
				memcpy(p1,p2,atomsize);
				p1= (ptr)( ((char*)p1) + s1);
				p2= (ptr)( ((char*)p2) + s2);
			}
		}
	}
}

@:initImpl(oid)@
@:initImpl(int)@
@:initImpl(sht)@
@:initImpl(lng)@
@:initImpl(dbl)@
@:initImpl(flt)@
@:initImpl(bit)@

@= arithGrpImpl
@:arithmeticImpl(@1,@2,flt,flt,flt)@
@:arithmeticImpl(@1,@2,dbl,dbl,dbl)@
@:arithmeticImpl(@1,@2,oid,oid,oid)@

@:arithmeticImpl(@1,@2,int,int,sht)@
@:arithmeticImpl(@1,@2,int,sht,int)@
@:arithmeticImpl(@1,@2,int,sht,sht)@
@:arithmeticImpl(@1,@2,sht,sht,sht)@

@:arithmeticImpl(@1,@2,lng,lng,lng)@
@:arithmeticImpl(@1,@2,lng,sht,lng)@
@:arithmeticImpl(@1,@2,lng,lng,sht)@
@:arithmeticImpl(@1,@2,lng,sht,sht)@
@:arithmeticImpl(@1,@2,lng,sht,int)@
@:arithmeticImpl(@1,@2,lng,int,sht)@
@:arithmeticImpl(@1,@2,lng,int,lng)@
@:arithmeticImpl(@1,@2,lng,lng,int)@

@:arithmeticImpl(@1,@2,lng,int,int)@
@:arithmeticImpl(@1,@2,int,int,int)@

@c
@:arithGrpImpl(/,DIV)@
@:arithGrpImpl(*,MUL)@
@:arithGrpImpl(-,SUB)@
@:arithGrpImpl(+,ADD)@

@-  Modulo arithmetic
The Modulo function doesn;t work on all types. Therefore we 
define here the necessary implementations separately by copying
the arithmeticImpl block and removing elements not required.
@c
@= numeric_funcs
batcalc_export str bataccum@1_@3_@4_@5(BAT *dst, BAT *left, BAT *right);
str bataccum@1_@3_@4_@5(BAT *dst, BAT *left, BAT *right)
{	size_t s1,s2,s3;
	ptr p1,p2,p3, hend;

	@:batinit(1,dst)@
	@:batinit(2,left)@
	@:batinit(3,right)@
	hend = (str) BUNlast(dst);
	switch(BATttype(dst)){
	case TYPE_oid: @:accum(oid,@2,oid,oid)@ break;
	case TYPE_sht: @:accum(sht,@2,sht,sht)@ break;
	case TYPE_int: @:accum(int,@2,int,int)@ break;
	case TYPE_lng: @:accum(lng,@2,lng,lng)@ break;
	default: return throwMessage("batcalc.@1", "unexpected type");
	}
	return MAL_SUCCEED;
}

batcalc_export str CMDbat@1_@3_@4_@5(int *ret, int *l, int *r);
str CMDbat@1_@3_@4_@5(int *ret, int *l, int *r)
{	BAT *dst, *left, *right;
	str msg;

	if( (left= BATdescriptor(*l)) == NULL ){
		return throwMessage("batcalc.@1", "Cannot access descriptor");
	}
	if( (right= BATdescriptor(*r)) == NULL ){
		BBPreleaseref(left->batCacheid);
		return throwMessage("batcalc.@1", "Cannot access descriptor");
	}

	@:chkSize(left,right,CMDbat@1)@

	if (left->ttype == TYPE_@3)
		dst= BATwcopy(left);
	else
		dst= BATwcopy(right);
	if( dst == NULL){
		return throwMessage("batcalc.@1", "no copy available ");
	}
	dst->tsorted = 0;
	msg= bataccum@1_@3_@4_@5(dst,left,right);
	if (!(dst->batDirty&2)) dst = BATsetaccess(dst, BAT_READ); \
	*ret = dst->batCacheid;
	BBPkeepref(*ret);
	BBPreleaseref(left->batCacheid);
	BBPreleaseref(right->batCacheid);
	return msg;
}

batcalc_export str CMDbataccum@1_@3_@4_@5(int *ret, int *d, int *l, int *r);
str CMDbataccum@1_@3_@4_@5(int *ret, int *d, int *l, int *r)
{	BAT *dst, *left, *right;
	str msg;

	if( (dst= BATdescriptor(*d)) == NULL ){
		return throwMessage("batcalc.@1", "Cannot access descriptor");
	}
	if( (left= BATdescriptor(*l)) == NULL ){
		BBPreleaseref(dst->batCacheid);
		return throwMessage("batcalc.@1", "Cannot access descriptor");
	}
	if( (right= BATdescriptor(*r)) == NULL ){
		BBPreleaseref(dst->batCacheid);
		BBPreleaseref(left->batCacheid);
		return throwMessage("batcalc.@1", "Cannot access descriptor");
	}

	@:chkSize(dst,left,CMDbataccum@1)@
	@:chkSize(dst,right,CMDbataccum@1)@

	msg= bataccum@1_@3_@4_@5(dst,left,right);
	dst->tsorted = 0;
	if (!(dst->batDirty&2)) dst = BATsetaccess(dst, BAT_READ); \
	*ret = dst->batCacheid;
	BBPkeepref(dst->batCacheid);
	BBPreleaseref(left->batCacheid);
	BBPreleaseref(right->batCacheid);
	return msg;
}
batcalc_export str CMDbataccum@1cst_@3_@4_@5(int *ret, int *r, int *l, void *cst);
str CMDbataccum@1cst_@3_@4_@5(int *ret, int *r, int *l, void *cst)
{	BAT *dst, *left;
	size_t s1,s2;
	ptr p1,p2, hend;

	if( (dst= BATdescriptor(*r)) == NULL ){
		return throwMessage("batcalc.@1", "Cannot access descriptor");
	}
	if( (left= BATdescriptor(*l)) == NULL ){
		BBPreleaseref(dst->batCacheid);
		return throwMessage("batcalc.@1", "Cannot access descriptor");
	}
	@:chkSize(dst,left,CMDbataccum@1)@
	@:batinit(1,dst)@
	@:batinit(2,left)@
	hend = (str) BUNlast(dst);

	switch(BATttype(left)){
	case TYPE_oid: @:accumCst(oid,@2,oid,oid)@ break;
	case TYPE_sht: @:accumCst(sht,@2,sht,sht)@ break;
	case TYPE_int: @:accumCst(int,@2,int,int)@ break;
	case TYPE_lng: @:accumCst(lng,@2,lng,lng)@ break;
	default : return throwMessage("batcalc.@1", "unexpected type");
	}
	if (!(dst->batDirty&2)) dst = BATsetaccess(dst, BAT_READ); \
	*ret = dst->batCacheid;
	BBPkeepref(dst->batCacheid);
	BBPreleaseref(left->batCacheid);
	return MAL_SUCCEED;
}

batcalc_export str CMDbataccum@1cst2_@3_@4_@5(int *ret, int *r, void *cst, int *l);
str CMDbataccum@1cst2_@3_@4_@5(int *ret, int *r, void *cst, int *l)
{	BAT *dst, *left;
	size_t s1,s2;
	ptr p1,p2, hend;

	if( (dst= BATdescriptor(*r)) == NULL ){
		return throwMessage("batcalc.@1", "Cannot access descriptor");
	}
	if( (left= BATdescriptor(*l)) == NULL ){
		BBPreleaseref(dst->batCacheid);
		return throwMessage("batcalc.@1", "Cannot access descriptor");
	}
	@:chkSize(dst,left,CMDbataccum@1)@
	@:batinit(1,dst)@
	@:batinit(2,left)@
	hend = (str) BUNlast(dst);

	switch(BATttype(left)){
	case TYPE_oid: @:accumCstLeft(oid,@2,oid,oid)@ break;
	case TYPE_sht: @:accumCstLeft(sht,@2,sht,sht)@ break;
	case TYPE_int: @:accumCstLeft(int,@2,int,int)@ break;
	case TYPE_lng: @:accumCstLeft(lng,@2,lng,lng)@ break;
	default : return throwMessage("batcalc.@1", "unexpected type");
	}
	if (!(dst->batDirty&2)) dst = BATsetaccess(dst, BAT_READ); \
	*ret = dst->batCacheid;
	BBPkeepref(dst->batCacheid);
	BBPreleaseref(left->batCacheid);
	return MAL_SUCCEED;
}
batcalc_export str CMDbat@1cst_@3_@4_@5(int *ret, int *l, void *cst);
str CMDbat@1cst_@3_@4_@5(int *ret, int *l, void *cst)
{	BAT *dst, *left;
	size_t s1,s2;
	ptr p1,p2, hend;
	char *res = MAL_SUCCEED;

	if( (left= BATdescriptor(*l)) == NULL ){
		return throwMessage("batcalc.@1", "Cannot access descriptor");
	}
	dst= newBATresult(left, TYPE_@3);
	if( dst == 0){
		BBPreleaseref(left->batCacheid);
		return throwMessage("batcalc.@1", "no copy available");
	}
	copyHead(dst,left);

	@:batinit(1,dst)@
	@:batinit(2,left)@
	hend = ((str) BUNlast(dst)) + (s1*BATcount(left));

	if( '@2'== '/') {
		if (*(@5*)cst == 0) {
				res = throwMessage("batcalc.@1", "Division by zero");
		} else {
			@:accumCst(@3,@2,@4,@5)@ 
		}
	} else {
		@:accumCst(@3,@2,@4,@5)@ 
	}
	dst->batBuns->free = BATcount(left) * s1;
	BATsetcount(dst, BATcount(left));
	dst->tsorted = 0;
	if (!(dst->batDirty&2)) dst = BATsetaccess(dst, BAT_READ); \
	*ret = dst->batCacheid;
	BBPkeepref(dst->batCacheid);
	BBPreleaseref(left->batCacheid);
	return res;
}
batcalc_export str CMDcst@1bat_@3_@4_@5(int *ret,void *cst, int *l);
str CMDcst@1bat_@3_@4_@5(int *ret,void *cst, int *l)
{	BAT *dst, *left;
	size_t s1,s2;
	ptr p1,p2, hend;
	char *res = MAL_SUCCEED;

	if( (left= BATdescriptor(*l)) == NULL ){
		return throwMessage("batcalc.@1", "Cannot access descriptor");
	}
	dst= newBATresult(left, TYPE_@3);
	if( dst == 0){
		BBPreleaseref(left->batCacheid);
		return throwMessage("batcalc.@1", "no copy available");
	}
	copyHead(dst,left);

	@:batinit(1,dst)@
	@:batinit(2,left)@
	hend = ((str) BUNlast(dst)) + (s1*BATcount(left));

	if( '@2'== '/') {
		@:accumCstDIV(@3,@2,@4,@5)@ 
	} else {
		@:accumCstLeft(@3,@2,@4,@5)@ 
	}
	dst->batBuns->free = BATcount(left) * s1;
	BATsetcount(dst, BATcount(left));
	dst->hsorted = BAThordered(left);
	dst->tsorted = 0;
	if (!(dst->batDirty&2)) dst = BATsetaccess(dst, BAT_READ); \
	*ret = dst->batCacheid;
	BBPkeepref(dst->batCacheid);
	BBPreleaseref(left->batCacheid);
	return res;
}
@c
@:numeric_funcs(MOD,%,oid,oid,oid)@
@:numeric_funcs(MOD,%,int,int,int)@
@:numeric_funcs(MOD,%,lng,lng,lng)@
@:numeric_funcs(MOD,%,sht,sht,sht)@
@:numeric_funcs(XOR,^,oid,oid,oid)@
@:numeric_funcs(XOR,^,int,int,int)@
@:numeric_funcs(XOR,^,lng,lng,lng)@
@:numeric_funcs(XOR,^,sht,sht,sht)@
@:numeric_funcs(AND,&,oid,oid,oid)@
@:numeric_funcs(AND,&,int,int,int)@
@:numeric_funcs(AND,&,lng,lng,lng)@
@:numeric_funcs(AND,&,sht,sht,sht)@
@:numeric_funcs(OR,|,oid,oid,oid)@
@:numeric_funcs(OR,|,int,int,int)@
@:numeric_funcs(OR,|,lng,lng,lng)@
@:numeric_funcs(OR,|,sht,sht,sht)@

@- Implementation of unary operations
@= accumUnary
	while( p1 < hend ){
		/* this code is better as x?nil:y  */
#ifdef NULLTST
		if(*(@1 *)p2 == @1_nil )
			*(@1*)p1= @1_nil;
		else 
#endif
			*(@1*)p1= (@1) (@2 *(@1 *) p2);
		p1= (ptr)( ((char *)p1) + s1);
		p2= (ptr)( ((char *)p2) + s2);
	}
@-
Unary accummulators are only indirectly called. They can not
always be defined without signature clashes, eg. -(batA,batC).
@= unary_impl
batcalc_export str CMDunaryAccum@1(int *ret,int *did, int *bid);
str CMDunaryAccum@1(int *ret,int *did, int *bid){
	BAT *b,*dst;
	size_t s1,s2;
	ptr p1,p2, hend;
	
	if( (dst= BATdescriptor(*did)) == NULL ){
		return throwMessage("batcalc.@1", "Cannot access descriptor");
	}
	if( (b= BATdescriptor(*bid)) == NULL ){
		BBPreleaseref(dst->batCacheid);
		return throwMessage("batcalc.@1", "Cannot access descriptor");
	}
	@:batinit(1,dst)@
	@:batinit(2,b)@
	hend = (str) BUNlast(dst);
	switch(BATttype(dst)){
	case TYPE_oid: @:accumUnary(oid,@2)@ break;
	case TYPE_sht: @:accumUnary(sht,@2)@ break;
	case TYPE_int: @:accumUnary(int,@2)@ break;
	case TYPE_lng: @:accumUnary(lng,@2)@ break;
	case TYPE_flt: @:accumUnary(flt,@2)@ break;
	case TYPE_dbl: @:accumUnary(dbl,@2)@ break;
	default: return throwMessage("batcalc.MIN", "unexpected type");
	}
	if (!(dst->batDirty&2)) dst = BATsetaccess(dst, BAT_READ); \
	*ret= dst->batCacheid;
	BBPkeepref(dst->batCacheid);
	BBPreleaseref(b->batCacheid);
	return MAL_SUCCEED;
}
batcalc_export str CMDunary@1(int *ret, int *bid);
str CMDunary@1(int *ret, int *bid){
	BAT *b,*dst;
	str msg;
	
	if( (b= BATdescriptor(*bid)) == NULL ){
		return throwMessage("batcalc.@1", "Cannot access descriptor");
	}
	dst= BATwcopy(b);
	if( dst == NULL){
		BBPreleaseref(b->batCacheid);
		return throwMessage("batcalc.unary", "no copy available ");
	}
	msg= CMDunaryAccum@1(ret,&dst->batCacheid,bid);
	BBPreleaseref(dst->batCacheid);
	BBPreleaseref(b->batCacheid);
	return msg;
}
@c
@:unary_impl(MIN,-)@
@:unary_impl(MINMIN,--)@
@:unary_impl(PLUSPLUS,++)@

@- Implementation of comparisons
The structure of this code is copied from the arithmetic scheme.
@= cmpLoop
	while( p2 < hend ){
		/* this code is better as x?nil:y */
#ifdef NULLTST
		if (*(@1*)p2 == @1_nil || *(@1*)p3 == @1_nil)
			*(bit*)p1= bit_nil;
		else 
#endif
			*(bit*)p1 = ((*(@1*)p2) @2 (*(@1*)p3));
		p1= (ptr)( ((char *)p1) + s1);
		p2= (ptr)( ((char *)p2) + s2);
		p3= (ptr)( ((char *)p3) + s3);
	}
@-
@= cmpLoopCst
	while( p1 < hend ){
#ifdef NULLTST
		if(*(@1 *)p2 == @1_nil || *(@1*)cst == @1_nil)
			*(bit*)p1= bit_nil;
		else 
#endif
			*(bit*)p1 = *(@1*) p2 @2 *(@1 *) cst;
		p1= (ptr)( ((char *)p1) + s1);
		p2= (ptr)( ((char *)p2) + s2);
	}
@= compareImpl
batcalc_export str compareaccum@1(BAT *dst, BAT *left, BAT *right);
str compareaccum@1(BAT *dst, BAT *left, BAT *right){
	size_t s1,s2,s3;
	ptr p1,p2,p3, hend;

	@:batinit(1,dst)@
	@:batinit(2,left)@
	@:batinit(3,right)@
	hend = (str) BUNlast(left);

	switch(BATttype(left)){
	case TYPE_bit: @:cmpLoop(bit,@2)@ break;
	case TYPE_flt: @:cmpLoop(flt,@2)@ break;
	case TYPE_dbl: @:cmpLoop(dbl,@2)@ break;
	case TYPE_oid: @:cmpLoop(oid,@2)@ break;
	case TYPE_sht: @:cmpLoop(sht,@2)@ break;
	case TYPE_int: @:cmpLoop(int,@2)@ break;
	case TYPE_lng: @:cmpLoop(lng,@2)@ break;
	default: return throwMessage("batcalc.@1", "unexpected type");
	}
	return MAL_SUCCEED;
}
batcalc_export str CMDcmp@1(int *ret, int *l, int *r);
str CMDcmp@1(int *ret, int *l, int *r)
{	BAT *dst, *left, *right;
	size_t s1,xx;
	ptr p1;
	bit bn= bit_nil;
	BUN p,q;
	str msg;

	if( (left= BATdescriptor(*l)) == NULL ){
		return throwMessage("batcalc.@1", "Cannot access descriptor");
	}
	if( (right= BATdescriptor(*r)) == NULL ){
		BBPreleaseref(left->batCacheid);
		return throwMessage("batcalc.@1", "Cannot access descriptor");
	}

	@:chkSize(left,right,CMDcompare@1)@

	dst= newBATresult(left, TYPE_bit);

	s1= BUNsize(dst);
	p1= BUNfirst(dst);
	 
	BATloopFast(left,p,q,xx){
		ptr h= BUNhead(left,p);
		bunfastins_nocheck(dst,p1,h,&bn,s1);
		p1= (ptr)( ((char*)p1) + s1);
	}
bunins_failed:
	dst->hsorted= BAThordered(left);
	dst->tsorted= 0;
	msg = compareaccum@1(dst,left,right);
	if (!(dst->batDirty&2)) dst = BATsetaccess(dst, BAT_READ); \
	*ret = dst->batCacheid;
	BBPkeepref(*ret);
	BBPreleaseref(left->batCacheid);
	BBPreleaseref(right->batCacheid);
	return msg;
}

batcalc_export str CMDcmpaccum@1(int *ret, int *d, int *l, int *r);
str CMDcmpaccum@1(int *ret, int *d, int *l, int *r)
{	BAT *dst, *left, *right;
	str msg;

	if( (dst= BATdescriptor(*d)) == NULL ){
		return throwMessage("batcalc.@1", "Cannot access descriptor");
	}
	if( (left= BATdescriptor(*l)) == NULL ){
		BBPreleaseref(dst->batCacheid);
		return throwMessage("batcalc.@1", "Cannot access descriptor");
	}
	if( (right= BATdescriptor(*r)) == NULL ){
		BBPreleaseref(dst->batCacheid);
		BBPreleaseref(left->batCacheid);
		return throwMessage("batcalc.@1", "Cannot access descriptor");
	}

	@:chkSize(dst,left,CMDcompareaccum@1)@
	@:chkSize(dst,right,CMDcompareaccum@1)@

	msg= compareaccum@1(dst,left,right);
	dst->tsorted= 0;
	if (!(dst->batDirty&2)) dst = BATsetaccess(dst, BAT_READ); \
	*ret = dst->batCacheid;
	BBPkeepref(dst->batCacheid);
	BBPreleaseref(left->batCacheid);
	BBPreleaseref(right->batCacheid);
	return msg;
}
@= cmpCstImpl
batcalc_export str CMDcmpaccum@1cst(int *ret, int *r, int *l, void *cst);
str CMDcmpaccum@1cst(int *ret, int *r, int *l, void *cst)
{	BAT *dst, *left;
	size_t s1,s2;
	ptr p1,p2, hend;

	if( (dst= BATdescriptor(*r)) == NULL ){
		return throwMessage("batcalc.@1", "Cannot access descriptor");
	}
	if( (left= BATdescriptor(*l)) == NULL ){
		BBPreleaseref(dst->batCacheid);
		return throwMessage("batcalc.@1", "Cannot access descriptor");
	}
	@:chkSize(dst,left,CMDbataccum@1)@
	@:batinit(1,dst)@
	@:batinit(2,left)@
	hend = (str) BUNlast(dst);

	switch(BATttype(left)){
	case TYPE_bit: @:cmpLoopCst(bit,@2)@ break;
	case TYPE_flt: @:cmpLoopCst(flt,@2)@ break;
	case TYPE_dbl: @:cmpLoopCst(dbl,@2)@ break;
	case TYPE_oid: @:cmpLoopCst(oid,@2)@ break;
	case TYPE_sht: @:cmpLoopCst(sht,@2)@ break;
	case TYPE_int: @:cmpLoopCst(int,@2)@ break;
	case TYPE_lng: @:cmpLoopCst(lng,@2)@ break;
	default :return throwMessage("batcalc.@1","unexpected type");
	}
	dst->tsorted= 0;
	if (!(dst->batDirty&2)) dst = BATsetaccess(dst, BAT_READ); \
	*ret = dst->batCacheid;
	BBPkeepref(dst->batCacheid);
	BBPreleaseref(left->batCacheid);
	return MAL_SUCCEED;
}

batcalc_export str CMDcmp@1cst(int *ret, int *l, void *cst);
str CMDcmp@1cst(int *ret, int *l, void *cst)
{	BAT *dst, *left;
	size_t s1,xx;
	ptr p1;
	bit bn= bit_nil;
	BUN p,q;
	str msg;

	if( (left= BATdescriptor(*l)) == NULL ){
		return throwMessage("batcalc.@1", "Cannot access descriptor");
	}

	dst= newBATresult(left, TYPE_bit);

	s1= BUNsize(dst);
	p1= BUNfirst(dst);
	 
	BATloopFast(left,p,q,xx){
		ptr h= BUNhead(left,p);
		bunfastins_nocheck(dst,p1,h,&bn,s1);
		p1= (ptr)( ((char*)p1) + s1);
	}
bunins_failed:
	dst->hsorted= BAThordered(left);
	dst->tsorted= 0;
	msg= CMDcmpaccum@1cst(ret,&dst->batCacheid,l,cst);
	BBPreleaseref(dst->batCacheid);
	BBPreleaseref(left->batCacheid);
	return msg;
}

@-
@c
@:compareImpl(GE,>=)@
@:compareImpl(LE,<=)@
@:compareImpl(GT,>)@
@:compareImpl(LT,<)@
@:compareImpl(EQ,==)@
@:compareImpl(NEQ,!=)@
@:cmpCstImpl(GE,>=)@
@:cmpCstImpl(LE,<=)@
@:cmpCstImpl(GT,>)@
@:cmpCstImpl(LT,<)@
@:cmpCstImpl(EQ,==)@
@:cmpCstImpl(NEQ,!=)@

@- Implementations of boolean operators
The code base is straightforward.
@-
The expanded code for the binary and boolean operations.
@c
@:compareImpl(AND,&&)@
@:compareImpl(OR,||)@
@:cmpCstImpl(AND,&&)@
@:cmpCstImpl(OR,||)@

batcalc_export str CMDbitbataccumNOT(int *ret, int *d, int *l);
str
CMDbitbataccumNOT(int *ret, int *d, int *l)
{
	BAT *dst, *left;
	size_t s1, s2;
	ptr p1, p2, hend;

	if ((dst = BATdescriptor(*d)) == NULL) {
		return throwMessage("batcalc.@1", "Cannot access descriptor");
	}
	if ((left = BATdescriptor(*l)) == NULL) {
		BBPreleaseref(dst->batCacheid);
		return throwMessage("batcalc.@1", "Cannot access descriptor");
	}

	@:chkSize(dst,left,CMDbitbataccum@1)@
	@:batinit(1,left);
	@:batinit(2,dst);
	hend = (str) BUNlast(left);
	while (p1 < hend) {
		/* this code is better as x?nil:y */
		if (*(bit *) p1 == bit_nil)
			*(bit *) p2 = bit_nil;
		else
			*(bit *) p2 = !*(bit *) p1;
		p2 = (ptr) (((char *) p2) + s2);
		p1 = (ptr) (((char *) p1) + s1);
	}

	*ret = dst->batCacheid;
	dst->tsorted = 0;
	BBPkeepref(dst->batCacheid);
	BBPreleaseref(left->batCacheid);
	return MAL_SUCCEED;
}

batcalc_export str CMDbitbatNOT(int *ret, int *l);
str
CMDbitbatNOT(int *ret, int *l)
{
	str res;
	BAT *dst, *left;
	size_t s1, xx;
	int d;
	ptr p1;
	bit bn = bit_nil;
	BUN p, q;

	if ((left = BATdescriptor(*l)) == NULL) {
		return throwMessage("batcalc.@1", "Cannot access descriptor");
	}

	dst= newBATresult(left, TYPE_bit);

	s1 = BUNsize(dst);
	p1 = BUNfirst(dst);

	BATloopFast(left, p, q, xx) {
		ptr h = BUNhead(left, p);

		bunfastins_nocheck(dst, p1, h, &bn, s1);
		p1 = (ptr) (((char *) p1) + s1);
	}
	  bunins_failed:
	dst->hsorted = BAThordered(left);
	dst->tsorted = 0;
	if (!(dst->batDirty&2)) dst = BATsetaccess(dst, BAT_READ); \
	d = dst->batCacheid;
	BBPreleaseref(left->batCacheid);
	res = CMDbitbataccumNOT(ret, &d, l);
	BBPunfix(d);
	return res;
}

@- Implementation of coercions
The coercion code can not be improved much, because we do not have
the space to re-use. Therefore, the code block is actually a hardwired
version of a bunstream() operation. It runs, however, about 5-times
faster then [lng](b) in Version 4.

@-
The different coercion implementations exploit the fact
that many coercions are simply space enlargers.
The others effectively may loose information.
@= Idempotent
batcalc_export str CMDconvert@1_@1(int *ret, int *bid);
str CMDconvert@1_@1(int *ret, int *bid){
	BAT *b, *bn;
	if( (b= BATdescriptor(*bid)) == NULL ){
		return throwMessage("batcalc.convert", "Cannot access descriptor");
	}

	bn= BATwcopy(b);
	@:tstBat(CMDconvert@1_@1)@
	if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ); \
	*ret= bn->batCacheid;
	BBPkeepref(*ret);
	BBPreleaseref(b->batCacheid);
	return MAL_SUCCEED;
}
@-
@= Enlarge
batcalc_export str CMDconvert@1_@2Enlarge(int *ret, int *bid);
str CMDconvert@1_@2Enlarge(int *ret, int *bid){
	BAT *b,*bn;
	int xx;
	BUN p,q;
	@1 x;
	ptr p1; int s1;

	if( (b= BATdescriptor(*bid)) == NULL ){
		return throwMessage("batcalc.convert", "Cannot access descriptor");
	}

	if( b->htype!= TYPE_void) 
		return CMDconvert@1_@2(ret,bid);
	bn= newBATresult(b, TYPE_@2);
	@:tstBat(CMDconvert@1_@2)@

	@:batinit(1,bn)@
	BATloopFast(b, p, q, xx) {
		x= *(@1 *) BUNtail(b,p);
		if( x== @1_nil)
			*(@2 *)p1 = @2_nil;
		else *(@2 *) p1 = (@2) x;
		p1 = (ptr) (((char *) p1)+s1);
		(bn)->batBuns->free += s1;
		(bn)->batCount ++;
	}
	if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ); \
	 *ret= bn->batCacheid;
	BBPkeepref(*ret);
	BBPreleaseref(b->batCacheid);
	return MAL_SUCCEED;
}
@= General
batcalc_export str CMDconvert@1_@2(int *ret, int *bid);
str CMDconvert@1_@2(int *ret, int *bid){
	BAT *b,*bn;
	int xx;
	BUN p,q;
	@1 x;
	@2 y;

	if( (b= BATdescriptor(*bid)) == NULL ){
		return throwMessage("batcalc.convert", "Cannot access descriptor");
	}

	bn= newBATresult(b, TYPE_@2);
	@:tstBat(CMDconvert@1)@

	BATloopFast(b, p, q, xx) {
		ptr h = BUNhead(b,p);
		x= *(@1 *) BUNtail(b,p);
		y= x== @1_nil? @2_nil: (@2) x;
		bunfastins(bn, h, &y);
	}
bunins_failed:
	bn->tsorted = 0;
	if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ); \
	*ret= bn->batCacheid;
	BBPkeepref(*ret);
	BBPreleaseref(b->batCacheid);
	return MAL_SUCCEED;
}
@-
The lengthly list of coercions options could have been generated.
@c
@:Idempotent(sht)@
@:Idempotent(int)@
@:Idempotent(lng)@
@:Idempotent(flt)@
@:Idempotent(dbl)@
@:Idempotent(str)@
@:Idempotent(chr)@

@:General(sht,oid)@
@:General(sht,int)@
@:Enlarge(sht,int)@
@:General(sht,lng)@
@:Enlarge(sht,lng)@
@:General(sht,flt)@
@:Enlarge(sht,flt)@
@:General(sht,dbl)@
@:Enlarge(sht,dbl)@

@:General(int,sht)@
@:General(int,oid)@
@:General(int,lng)@
@:Enlarge(int,lng)@
@:General(int,flt)@
@:Enlarge(int,flt)@
@:General(int,dbl)@
@:Enlarge(int,dbl)@

@:General(oid,sht)@
@:General(oid,int)@
@:General(oid,lng)@


@:General(bit,sht)@
@:General(bit,int)@
@:General(bit,lng)@

@:General(lng,sht)@
@:General(lng,int)@
@:General(lng,oid)@
@:General(lng,flt)@
@:Enlarge(lng,flt)@
@:General(lng,dbl)@
@:Enlarge(lng,dbl)@

@:General(flt,sht)@
@:General(flt,int)@
@:General(flt,lng)@
@:General(flt,oid)@
@:General(flt,dbl)@
@:Enlarge(flt,dbl)@

@:General(dbl,sht)@
@:General(dbl,int)@
@:General(dbl,lng)@
@:General(dbl,flt)@
@:Enlarge(dbl,flt)@
@:General(dbl,oid)@

@h
batcalc_export str CMDconvertstr_int(int *ret, int *bid);
@c
str
CMDconvertstr_int(int *ret, int *bid)
{
	BAT *b, *bn;
	int xx;
	BUN p, q;
	str x;
	int y;

	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("batcalc.convert", "Cannot access descriptor");
	}

	bn = newBATresult(b, TYPE_int);
	@:tstBat(CMDconvertstr_int)@

	BATloopFast(b, p, q, xx) {
		ptr h = BUNhead(b, p);

		x = (str) BUNtail(b, p);
		y = x == str_nil ? int_nil : strtol(x, NULL, 0);
		bunfastins(bn, h, &y);
	}
	  bunins_failed:
	bn->tsorted = 0;
	if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ); \
	*ret = bn->batCacheid;
	BBPkeepref(*ret);
	BBPreleaseref(b->batCacheid);
	return MAL_SUCCEED;
}

@h
batcalc_export str CMDconvertOIDclass(int *ret, int *bid);
@c
str
CMDconvertOIDclass(int *ret, int *bid)
{
	BAT *b;

	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("batcalc.convert", "Cannot access descriptor");
	}
	if (!(b->batDirty&2)) b = BATsetaccess(b, BAT_READ); \
	*ret = b->batCacheid;
	BBPkeepref(*ret);
	return MAL_SUCCEED;
}

/* You don;t have to materialize the oids.
This is taken care upon access */
@h
batcalc_export str CMDconvertvoid_oid_oid(int *ret, int *bid);
@c
str
CMDconvertvoid_oid_oid(int *ret, int *bid)
{
	BAT *b;

	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("batcalc.convert", "Cannot access descriptor");
	}
	if (!(b->batDirty&2)) b = BATsetaccess(b, BAT_READ); \
	*ret = b->batCacheid;
	BBPkeepref(*ret);
	return MAL_SUCCEED;
}
@h
batcalc_export str CMDmaterialize(int *ret, int *bid);
@c
str
CMDmaterialize(int *ret, int *bid)
{
	BAT *b, *bn;

	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("batcalc.materialize", "Cannot access descriptor");
	}
	if( b->htype == TYPE_void){
		bn= BATmaterialize(b, BATcount(b));
		if( bn == NULL)
			return throwMessage("batcalc.materialize", "Materialization failed");
		if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ);
		*ret = bn->batCacheid;
		BBPkeepref(*ret);
	} else {
		*ret = b->batCacheid;
		BBPkeepref(*ret);
	}
	return MAL_SUCCEED;
}

@h
batcalc_export str CMDconvertvoid_int_oid(int *ret, int *bid);
@c
str
CMDconvertvoid_int_oid(int *ret, int *bid)
{
#if SIZEOF_OID == SIZEOF_INT
	BAT *b, *bn;

	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("batcalc.convert", "Cannot access descriptor");
	}
	bn = BATwcopy(b);
	BATmirror(bn)->htype = bn->ttype = TYPE_oid;
	/* simply recast the BAT  without doing anything */
	if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ); \
	*ret = bn->batCacheid;
	BBPkeepref(*ret);
	BBPreleaseref(b->batCacheid);
	return MAL_SUCCEED;
#else
	BAT *b, *bn;
	int xx;
	BUN p, q;
	oid x;

	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("batcalc.convert", "Cannot access descriptor");
	}
	bn = BATnew(TYPE_void, TYPE_oid, BATcount(b));
	BATseqbase(bn, b->hseqbase);
	@:tstBat(CMDconvertvoid_int_oid)@
	x = b->hseqbase;

	BATloopFast(b, p, q, xx) {
		oid t = *(int *) BUNtail(b, p);

		bunfastins(bn, &x, &t);
		x++;
	}
	  bunins_failed:
	bn->hsorted = b->hsorted;
	bn->tsorted = 0;
	if (!(bn->batDirty&2)) 
		bn = BATsetaccess(bn, BAT_READ);
	*ret = bn->batCacheid;
	BBPkeepref(*ret);
	BBPreleaseref(b->batCacheid);
	return MAL_SUCCEED;
#endif

}
batcalc_export str CMDconvertstr_bit(int *ret, int *bid);
str
CMDconvertstr_bit(int *ret, int *bid)
{
	BAT *b, *bn;
	int xx;
	BUN p, q;
	str x;
	bit y;

	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("batcalc.convert", "Cannot access descriptor");
	}

	bn = newBATresult(b, TYPE_bit);

	BATloopFast(b, p, q, xx) {
		ptr h = BUNhead(b, p);

		x = (str) BUNtail(b, p);
		if( strcmp(x,"true")== 0 || strcmp(x,"TRUE")== 0)
			y= TRUE;
		else
		if( strcmp(x,"false")== 0 || strcmp(x,"FALSE")== 0)
			y= FALSE;
		else
			y = bit_nil;
		bunfastins(bn, h, &y);
	}
  bunins_failed:
	bn->tsorted = 0;
	if (!(bn->batDirty&2))
		bn = BATsetaccess(bn, BAT_READ); 
	*ret = bn->batCacheid;
	BBPkeepref(*ret);
	BBPreleaseref(b->batCacheid);
	return MAL_SUCCEED;
}
@- IfThenElse
The conditional multiplex operations .
@c
batcalc_export str CMDifThen(int *ret, int *iid, int *tid);
str
CMDifThen(int *ret, int *iid, int *tid)
{
	BAT *ib, *tb, *bn;
	int xx;
	BUN p, q, p1;
	ptr nilptr;
	size_t s1;

	if ((ib = BATdescriptor(*iid)) == NULL) {
		return throwMessage("batcalc.ifThen", "Cannot access descriptor");
	}
	if ((tb = BATdescriptor(*tid)) == NULL) {
		BBPreleaseref(ib->batCacheid);
		return throwMessage("batcalc.ifThen", "Cannot access descriptor");
	}
	@:chkSize(ib,tb,CMDifThen)@

	nilptr = ATOMnilptr(BATttype(tb));
	bn = BATnew(BAThtype(ib), BATttype(tb), BATcount(ib));
	s1= BUNsize(bn);
	p1= BUNfirst(bn);
	@:tstBat(CMDifThen)@

	BATloopFast(ib, p, q, xx) {
		ptr h = BUNhead(ib, p);
		ptr t = BUNtail(ib, p);

		if (*(bit *) t == bit_nil) {
			t = nilptr;
		} else if (*(bit *) t) {
			int idx = BUNindex(ib, p);
			t = BUNtail(tb, BUNptr(tb, idx));
		} else {
			continue;
		}
		bunfastins_nocheck(bn, p1, h, t, s1);
		p1= (ptr)( ((char*)p1) + s1);
	}
	  bunins_failed:
	bn->tsorted = 0;
	if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ); \
	*ret = bn->batCacheid;
	BBPkeepref(*ret);
	BBPreleaseref(ib->batCacheid);
	BBPreleaseref(tb->batCacheid);
	return MAL_SUCCEED;
}

@-
The constant versions are typed by the parser
@= ifthencstImpl
batcalc_export str CMDifThenCst_@1(int *ret, int *iid, ptr *eid);
str CMDifThenCst_@1(int *ret, int *iid, ptr *eid){
	BAT *ib, *bn;
	int xx;
	BUN p,q, p1;
	ptr nilptr;
	size_t s1;

	if( (ib= BATdescriptor(*iid)) == NULL ){
		return throwMessage("batcalc.ifThen", "Cannot access descriptor");
	}

	nilptr = ATOMnilptr(TYPE_@1);
	bn= BATnew(BAThtype(ib),TYPE_@1,BATcount(ib));
	s1= BUNsize(bn);
	p1= BUNfirst(bn);
	@:tstBat(CMDifThenCst_@1)@
	BATloopFast(ib, p, q, xx) {
		ptr h = BUNhead(ib,p);
		ptr t = BUNtail(ib,p);

		if( *(bit*) t== bit_nil) {
			t = nilptr;
		} else if( *(bit*) t ) {
			t = eid;
		} else {
			continue;
		} 
		bunfastins_nocheck(bn, p1, h, t, s1);
		p1= (ptr)( ((char*)p1) + s1);
	}
bunins_failed:
	bn->tsorted = 0;
	if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ); \
	*ret= bn->batCacheid;
	BBPkeepref(bn->batCacheid);
	BBPreleaseref(ib->batCacheid);
	return MAL_SUCCEED;
}
batcalc_export str CMDifThenElseCst_@1(int *ret, int *iid, ptr *tid, ptr *eid);
str CMDifThenElseCst_@1(int *ret, int *iid, ptr *tid, ptr *eid){
	BAT *ib, *bn;
	int xx;
	BUN p,q, p1;
	@1 nilval = (@1)@1_nil;
	size_t s1;

	if( (ib= BATdescriptor(*iid)) == NULL ){
		return throwMessage("batcalc.ifThen", "Cannot access descriptor");
	}

	bn= BATnew(BAThtype(ib),TYPE_@1,BATcount(ib));
	s1= BUNsize(bn);
	p1= BUNfirst(bn);
	@:tstBat(CMDifThenElseCst_@1)@
	BATloopFast(ib, p, q, xx) {
		ptr h = BUNhead(ib,p);
		ptr t = BUNtail(ib,p);

		if( *(bit*) t== bit_nil) {
			t = &nilval;
		} else if( *(bit*) t ) {
			t = tid;
		} else {
			t = eid;
		} 
		bunfastins_nocheck(bn, p1, h, t, s1);
		p1= (ptr)( ((char*)p1) + s1);
	}
bunins_failed:
	bn->tsorted = 0;
	if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ); \
	*ret= bn->batCacheid;
	BBPkeepref(bn->batCacheid);
	BBPreleaseref(ib->batCacheid);
	return MAL_SUCCEED;
}
batcalc_export str CMDprojecthead_@1(int *ret,ptr *val, int *iid);
str CMDprojecthead_@1(int *ret,ptr *val, int *iid){
	BAT *ib, *bn;
	int xx;
	BUN p,q;

	if( (ib= BATdescriptor(*iid)) == NULL ){
		return throwMessage("batcalc.project", "Cannot access descriptor");
	}

	bn= BATnew(TYPE_@1,BAThtype(ib),BATcount(ib));
	@:tstBat(fillhead_@1)@
	BATloopFast(ib, p, q, xx) {
		ptr v = BUNtail(ib,p);
		bunfastins(bn, val,v);
	}
bunins_failed:
	if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ); \
	*ret= bn->batCacheid;
	BBPkeepref(bn->batCacheid);
	BBPreleaseref(ib->batCacheid);
	return MAL_SUCCEED;
}
batcalc_export str CMDprojecttail_@1(int *ret,int *iid, ptr *val);
str CMDprojecttail_@1(int *ret,int *iid, ptr *val){
	BAT *ib, *bn;
	int xx;
	BUN p,q;

	if( (ib= BATdescriptor(*iid)) == NULL ){
		return throwMessage("batcalc.project", "Cannot access descriptor");
	}

	bn= BATnew(BAThtype(ib),TYPE_@1,BATcount(ib));
	@:tstBat(filltail_@1)@
	BATloopFast(ib, p, q, xx) {
		ptr v = BUNhead(ib,p);
		bunfastins(bn,v, val);
	}
bunins_failed:
	if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ); \
	*ret= bn->batCacheid;
	BBPkeepref(bn->batCacheid);
	BBPreleaseref(ib->batCacheid);
	return MAL_SUCCEED;
}
@-

@c
@:ifthencstImpl(int)@
@:ifthencstImpl(sht)@
@:ifthencstImpl(lng)@
@:ifthencstImpl(oid)@
@:ifthencstImpl(flt)@
@:ifthencstImpl(dbl)@
@:ifthencstImpl(str)@
@:ifthencstImpl(chr)@
@:ifthencstImpl(bit)@

batcalc_export str CMDifThenElse(int *ret, int *iid, int *tid, int *eid);
str
CMDifThenElse(int *ret, int *iid, int *tid, int *eid)
{
	BAT *ib, *tb, *eb, *bn;
	int xx;
	BUN p, q, p1;
	ptr nilptr;
	size_t s1;

	if ((ib = BATdescriptor(*iid)) == NULL) {
		return throwMessage("batcalc.ifThenElse", "Cannot access descriptor");
	}
	if ((tb = BATdescriptor(*tid)) == NULL) {
		BBPreleaseref(ib->batCacheid);
		return throwMessage("batcalc.ifThenElse", "Cannot access descriptor");
	}
	if ((eb = BATdescriptor(*eid)) == NULL) {
		BBPreleaseref(ib->batCacheid);
		BBPreleaseref(tb->batCacheid);
		return throwMessage("batcalc.ifThenElse", "Cannot access descriptor");
	}
	@:chkSize(ib,tb,CMDifThenElse)@
	@:chkSize(ib,eb,CMDifThenElse)@

	nilptr = ATOMnilptr(BATttype(tb));
	bn = BATnew(BAThtype(ib), BATttype(tb), BATcount(ib));
	s1= BUNsize(bn);
	p1= BUNfirst(bn);
	@:tstBat(ifThenElse)@
	BATloopFast(ib, p, q, xx) {
		ptr h = BUNhead(ib, p);
		ptr t = BUNtail(ib, p);
		int idx = BUNindex(ib, p);

		if (*(bit *) t == bit_nil) {
			t = nilptr;
		} else if (*(bit *) t) {
			t = BUNtail(tb, BUNptr(tb, idx));
		} else {
			t = BUNtail(eb, BUNptr(eb, idx));
		}
		bunfastins_nocheck(bn, p1, h, t, s1);
		p1= (ptr)( ((char*)p1) + s1);
	}
	  bunins_failed:
	bn->tsorted = 0;
	if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ); \
	*ret = bn->batCacheid;
	BBPkeepref(bn->batCacheid);
	BBPreleaseref(ib->batCacheid);
	BBPreleaseref(tb->batCacheid);
	BBPreleaseref(eb->batCacheid);
	return MAL_SUCCEED;
}

batcalc_export str CMDifThenElseCst1(int *ret, int *iid, ptr *val, int *eid);
str
CMDifThenElseCst1(int *ret, int *iid, ptr *val, int *eid)
{
	BAT *ib, *eb, *bn;
	int xx;
	BUN p, q, p1;
	ptr nilptr;
	int tpe;
	size_t s1;

	if ((ib = BATdescriptor(*iid)) == NULL) {
		return throwMessage("batcalc.ifThenElse", "Cannot access descriptor");
	}
	if ((eb = BATdescriptor(*eid)) == NULL) {
		BBPreleaseref(ib->batCacheid);
		return throwMessage("batcalc.ifThenElse", "Cannot access descriptor");
	}
	@:chkSize(ib,eb,CMDifThenElse)@

	tpe = BATttype(eb);
	nilptr = ATOMnilptr(tpe);
	bn = BATnew(BAThtype(ib), tpe, BATcount(ib));
	s1= BUNsize(bn);
	p1= BUNfirst(bn);
	@:tstBat(CMDifThenElseCst1)@
	BATloopFast(ib, p, q, xx) {
		ptr h = BUNhead(ib, p);
		ptr t = BUNtail(ib, p);

		if (*(bit *) t == bit_nil) {
			t = nilptr;
		} else if (*(bit *) t) {
			t = val;
		} else {
			int idx = BUNindex(ib, p);
			t = BUNtail(eb, BUNptr(eb, idx));
		}
		bunfastins_nocheck(bn, p1, h, t, s1);
		p1= (ptr)( ((char*)p1) + s1);
	}
	  bunins_failed:
	bn->tsorted = 0;
	if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ); \
	*ret = bn->batCacheid;
	BBPkeepref(bn->batCacheid);
	BBPreleaseref(ib->batCacheid);
	BBPreleaseref(eb->batCacheid);
	return MAL_SUCCEED;
}

batcalc_export str CMDifThenElseCst2(int *ret, int *iid, int *tid, ptr *val);
str
CMDifThenElseCst2(int *ret, int *iid, int *tid, ptr *val)
{
	BAT *ib, *tb, *bn;
	int xx;
	BUN p, q, p1;
	ptr nilptr;
	int tpe;
	size_t s1;

	if ((ib = BATdescriptor(*iid)) == NULL) {
		return throwMessage("batcalc.ifThenElse", "Cannot access descriptor");
	}
	if ((tb = BATdescriptor(*tid)) == NULL) {
		BBPreleaseref(ib->batCacheid);
		return throwMessage("batcalc.ifThenElse", "Cannot access descriptor");
	}
	@:chkSize(ib,tb,CMDifThenElse)@

	tpe = BATttype(tb);
	nilptr = ATOMnilptr(tpe);
	bn = BATnew(BAThtype(ib), tpe, BATcount(ib));
	s1= BUNsize(bn);
	p1= BUNfirst(bn);
	@:tstBat(CMDifThenElseCst2)@
	BATloopFast(ib, p, q, xx) {
		ptr h = BUNhead(ib, p);
		ptr t = BUNtail(ib, p);

		if (*(bit *) t == bit_nil) {
			t = nilptr;
		} else if (*(bit *) t) {
			int idx = BUNindex(ib, p);
			t = BUNtail(tb, BUNptr(tb, idx));
		} else {
			t = val;
		}
		bunfastins_nocheck(bn, p1, h, t, s1);
		p1= (ptr)( ((char*)p1) + s1);
	}
	  bunins_failed:
	bn->tsorted = 0;
	if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ); \
	*ret = bn->batCacheid;
	BBPkeepref(bn->batCacheid);
	BBPreleaseref(ib->batCacheid);
	BBPreleaseref(tb->batCacheid);
	return MAL_SUCCEED;
}

batcalc_export str CMDreuse(int *ret, int *bid)
{
	BAT *b,*bn;
	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("batcalc.reuse", "Cannot access descriptor");
	}
	if( b->batPersistence != TRANSIENT || b->batRestricted != BAT_WRITE){
		bn= BATnewstorage(b->htype,b->ttype,BATcount(b));
		/* fake the necessary inserts */
		BATsetcount(bn,BATcount(b));
		BBPkeepref(bn->batCacheid);
		BBPreleaseref(b->batCacheid);
		*ret= bn->batCacheid;
	} else {
		*ret= *bid;
		BBPkeepref(*ret);
	}
	return MAL_SUCCEED;
}

@+ Test environment
Here follows a sample of the code that can easily
be derived from MAL.

int catchError(str msg){ return 0;}

BAT *cmd000(BAT *A2, BAT *A3){
/* dump the symbol table */
	BAT *rB=0;
	BUN rBq;
	lng mloop=0;
	lng h=0,t=0;
	lng B2=0;
	lng B3=0;
	lng cr=0;
	int limit=0;
	str exception=0;

/* ensure access, handled by MAL layer as well */
	BBPincref(A2->batCacheid,TRUE);
	BBPincref(A3->batCacheid,TRUE);

/*d:= new(lng,lng); */
	rB= BATnew(TYPE_lng,TYPE_lng,BATcount(A2));
/* barrier mloop:= bunStream(b,h,t); */
Lmloop:
	/* expanded code for bunStream  init should be factored out of loop*/
	limit= BUNindex(A2, BUNlast(A2));
	if(mloop >=limit) {mloop=0; goto Emloop;}
	rBq= BUNptr(A2,mloop);
	h= *(lng*) BUNhead(A2,rBq);
	t= *(lng*) BUNtail(A2,rBq);
	mloop++;

/* B2:= find(b,h); */
	B2= *(lng*) BUNfnd(A2,&h);
/* B3:= find(c,h); */
	B3= *(lng*) BUNfnd(A3,&h);
/* cr:= B2+B3; */
	if( B2== lng_nil || B3== lng_nil) 
		cr= lng_nil;
	else	cr= B2+B2;
/* insert(d,h,cr);*/
	BUNfastins(rB,&h,&cr);
/* catch GDKerror; */
CGDKerror:;
	if( !catchError("GDKerror")) goto EGDKerror;
/* leave mloop; */
	goto Emloop;
/* end GDKerror */
EGDKerror:;
/* redo Lmloop; */
	goto Lmloop;
/* end mloop */
Emloop:;
/* garbage collect and adjust referenceing */
	BBPunfix(A2->batCacheid);
	BBPunfix(A3->batCacheid);
	return rB;
}
@}
