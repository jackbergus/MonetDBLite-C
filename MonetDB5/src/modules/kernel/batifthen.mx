@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2008 CWI.
@' All Rights Reserved.
@f batifthen
@a M.L. Kersten
@+ BAT if-then-else multiplex expressions.
The assembled code for IF-THEN-ELSE multiplex operations.
Again we assume that the BAT arguments are aligned.
@{
@-
@= ifthenGrp
command batcalc.ifthen(b:bat[:oid,:bit], t:bat[:oid,:@1]) :bat[:oid,:@1] 
address CMDifThen_@1
comment "If-then operation to assemble a conditional result ";

command batcalc.ifthen(b:bat[:oid,:bit], v:@1) :bat[:oid,:@1] 
address CMDifThenCst_@1
comment "Ifthen operation to assemble a conditional result ";

command batcalc.ifthenelse(b:bat[:oid,:bit], v:@1, w:@1) :bat[:oid,:@1] 
address CMDifThenElseCst_@1
comment "Ifthen operation to assemble a conditional result ";

command batcalc.ifthenelse(b:bat[:oid,:bit], t:bat[:oid,:@1], 
		e:bat[:oid,:@1]) :bat[:oid,:@1] 
address CMDifThenElse_@1
comment "If-then-else operation to assemble a conditional result ";

command batcalc.ifthenelse(b:bat[:oid,:bit], e:@1, t:bat[:oid,:@1])
	:bat[:oid,:@1] 
address CMDifThenElseCst1_@1
comment "If-then-else operation to assemble a conditional result ";

command batcalc.ifthenelse(b:bat[:oid,:bit], t:bat[:any_1,:@1], e:@1)
	:bat[:oid,:@1] 
address CMDifThenElseCst2_@1
comment "If-then-else operation to assemble a conditional result ";
@mal
	@:ifthenGrp(bit)@
	@:ifthenGrp(chr)@
	@:ifthenGrp(bte)@
	@:ifthenGrp(sht)@
	@:ifthenGrp(int)@
	@:ifthenGrp(lng)@
	@:ifthenGrp(oid)@
	@:ifthenGrp(flt)@
	@:ifthenGrp(dbl)@
	@:ifthenGrp(str)@
@- Implementation
@include kprelude.mx
@h
#ifndef _BATIFTHEN_
#define _BATIFTHEN_
#include "gdk.h"
#include "math.h"
#include "mal_exception.h"

#ifdef WIN32
#ifndef LIBBATIFTHEN
#define batifthen_export extern __declspec(dllimport)
#else
#define batifthen_export extern __declspec(dllexport)
#endif
#else
#define batifthen_export extern
#endif
#endif /* _BATIFTHEN_ */
@-
A general assumption in all cases is the bats are synchronized on their
head column. This is not checked and may be mis-used to deploy the
implementation for shifted window arithmetic as well.
@= chkSize
	if( BATcount(@1) != BATcount(@2) )
	throw(MAL, "batcalc.@3", "requires bats of identical size");
@= wrapup
    if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ);
    *ret= bn->batCacheid;
    BBPkeepref(*ret);
    BBPreleaseref(b->batCacheid);
    return MAL_SUCCEED;

@= void_wrapup
	if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ);
	if (b->htype != bn->htype) {
		BAT *r = VIEWcreate(b,bn);

		BBPreleaseref(bn->batCacheid);
		bn = r;
	}
	BBPkeepref(*ret = bn->batCacheid);
	BBPreleaseref(b->batCacheid);
	return MAL_SUCCEED;

@- IfThenElse
The conditional multiplex operations .
@-
The constant versions are typed by the parser
String arguments call for an extra type casting. In combination
with type resolution and runtime checks it provides a dense
definitoin.
@= ifthenImpl
batifthen_export str CMDifThen_@1(int *ret, int *bid, int *tid);
str
CMDifThen_@1(int *ret, int *bid, int *tid) 
{
	BATiter bi, tbi;
	BAT *b, *tb, *bn;
	@1 nilval=  (@1) @1_nil, *val;
	BUN p,q;
	bit *t;

	@:getBATdescriptor(bid,b,"batcalc.ifThen")@
	@:getBATdescriptor(tid,tb,"batcalc.ifThen",BBPreleaseref(b->batCacheid))@
	@:chkSize(b,tb,CMDifThen)@
	@:resBAT(@1,"batcalc.ifThen")@

	bi = bat_iterator(b);
	tbi = bat_iterator(tb);
	t = (bit*)Tloc(b,BUNfirst(b));

	BATloop(b, p, q) {
		if (*t == bit_nil) {
			BUNfastins(bn, BUNhead(bi,p), (ptr) & nilval);
			bn->T->nonil = 0;
		} else if (*t) {
			val = (@1*) BUNtail(tbi,p);
			BUNfastins(bn, BUNhead(bi,p), val);
		}
		t++;
	}
	BBPreleaseref(tb->batCacheid);
	bn->T->nonil = (b->T->nonil && tb->T->nonil);
	@:wrapup@
}

batifthen_export str CMDifThenCst_@1(int *ret, int *bid, @1 *tid);
str CMDifThenCst_@1(int *ret, int *bid, @1 *tid)
{
	BATiter bi;
	BAT *b, *bn;
	@1 nilval= (@1) @1_nil;
	BUN p,q;
	bit *t;

	@:getBATdescriptor(bid,b,"batcalc.ifThen")@
	@:resBAT(@1,"batcalc.ifThen")@

	bi = bat_iterator(b);
	t = (bit*)Tloc(b,BUNfirst(b));

	BATloop(b, p, q) {
		if (*t == bit_nil) 
			BUNfastins(bn, BUNhead(bi,p), (ptr) & nilval);
		else if (*t) 
			BUNfastins(bn, BUNhead(bi,p), (ptr) tid);
		t++;
	}
	bn->T->nonil = (b->T->nonil && *tid != nilval);
	@:wrapup@
}

@= ifthenelseImpl
batifthen_export str CMDifThenElseCst_@1(int *ret, int *bid, @1 *tid, @1 *eid);
str CMDifThenElseCst_@1(int *ret, int *bid, @1 *tid, @1 *eid)
{
	BAT *b, *bn;
	@1 nilval= (@1) @1_nil, *dst;
	bit *t;
	BUN cnt, p;

	@:getBATdescriptor(bid,b,"batcalc.ifThenElse")@
	@:voidresultBAT(TYPE_@1,"batcalc.ifThenElse")@
	bn->tsorted = FALSE;
    	BATkey(BATmirror(bn), FALSE);

	cnt = BATcount(b);
	t = (bit*)Tloc(b,BUNfirst(b));
	dst = (@1*)Tloc(bn, BUNfirst(bn));

	for (p=0; p<cnt; p++) {
		if (t[p] == bit_nil) 
			dst[p] = nilval;
		else if (t[p]) 
			dst[p] = *tid;
		else
			dst[p] = *eid;
	}
	bn->T->nonil = (b->T->nonil && *tid != nilval && *eid != nilval);
	BATsetcount(bn, p);
	@:void_wrapup@
}

batifthen_export str CMDifThenElse_@1(int *ret, int *bid, int *tid, int *eid);
str
CMDifThenElse_@1(int *ret, int *bid, int *tid, int *eid)
{
	BAT *b, *tb, *eb, *bn;
	@1 nilval= (@1) @1_nil, *dst, *tbv, *ebv;
	bit *t;
	BUN cnt, p;

	@:getBATdescriptor(bid,b,"batcalc.ifThenElse")@
	@:getBATdescriptor(tid,tb,"batcalc.ifThenElse",BBPreleaseref(b->batCacheid);)@
	@:getBATdescriptor(eid,eb,"batcalc.ifThenElse", BBPreleaseref(b->batCacheid); BBPreleaseref(tb->batCacheid);)@
	@:chkSize(b,tb,ifThenElse)@
	@:chkSize(b,eb,ifThenElse)@
	@:voidresultBAT(TYPE_@1,"batcalc.ifThenElse")@
	bn->tsorted = FALSE;
    	BATkey(BATmirror(bn), FALSE);

	cnt = BATcount(b);
	t = (bit*) Tloc(b, BUNfirst(b));
	dst = (@1*)Tloc(bn, BUNfirst(bn));
	tbv = (@1*)Tloc(tb, BUNfirst(tb));
	ebv = (@1*)Tloc(eb, BUNfirst(eb));

	for (p=0; p<cnt; p++) {
		if (t[p] == bit_nil) 
			dst[p] = nilval;
		else if (t[p]) 
			dst[p] = tbv[p];
		else
			dst[p] = ebv[p];
	}
	bn->T->nonil = (b->T->nonil && tb->T->nonil && eb->T->nonil);
	BATsetcount(bn, p);
	BBPreleaseref(tb->batCacheid);
	BBPreleaseref(eb->batCacheid);
	@:void_wrapup@
}

batifthen_export str CMDifThenElseCst1_@1(int *ret, int *bid, @1 *val, int *eid);
str
CMDifThenElseCst1_@1(int *ret, int *bid, @1 *val, int *eid)
{
	BAT *b, *eb, *bn;
	@1 nilval= (@1) @1_nil, *dst, *ebv;
	bit *t;
	BUN cnt, p;

	@:getBATdescriptor(bid,b,"batcalc.ifThenElse")@
	@:getBATdescriptor(eid,eb,"batcalc.ifThenElse", BBPreleaseref(b->batCacheid);)@
	@:chkSize(b,eb,ifThenElse)@
	@:voidresultBAT(TYPE_@1,"batcalc.ifThenElse")@
	bn->tsorted = FALSE;
    	BATkey(BATmirror(bn), FALSE);

	cnt = BATcount(b);
	t = (bit*) Tloc(b,BUNfirst(b));
	dst = (@1*)Tloc(bn, BUNfirst(bn));
	ebv = (@1*)Tloc(eb, BUNfirst(eb));

	for (p=0; p<cnt; p++) {
		if (t[p] == bit_nil) 
			dst[p] = nilval;
		else if (t[p]) 
			dst[p] = *val;
		else
			dst[p] = ebv[p];
	}
	bn->T->nonil = (b->T->nonil && eb->T->nonil && *val != nilval);
	BATsetcount(bn, p);
	BBPreleaseref(eb->batCacheid);
	@:void_wrapup@
}

batifthen_export str CMDifThenElseCst2_@1(int *ret, int *bid, int *tid, @1 *val);
str
CMDifThenElseCst2_@1(int *ret, int *bid, int *tid, @1 *val)
{
	BAT *b, *tb, *bn;
	@1 nilval= (@1) @1_nil, *dst, *tbv;
	bit *t;
	BUN cnt, p;

	@:getBATdescriptor(bid,b,"batcalc.ifThenElse")@
	@:getBATdescriptor(tid,tb,"batcalc.ifThenElse",BBPreleaseref(b->batCacheid);)@
	@:chkSize(b,tb,ifThenElse)@
	@:voidresultBAT(TYPE_@1,"batcalc.ifThenElse")@
	bn->tsorted = FALSE;
    	BATkey(BATmirror(bn), FALSE);

	cnt = BATcount(b);
	t = (bit*) Tloc(b,BUNfirst(b));
	dst = (@1*)Tloc(bn, BUNfirst(bn));
	tbv = (@1*)Tloc(tb, BUNfirst(tb));
	
	for (p=0; p<cnt; p++) {
		if (t[p] == bit_nil) 
			dst[p] = nilval;
		else if (t[p]) 
			dst[p] = tbv[p];
		else 
			dst[p] = *val;
	}
	bn->T->nonil = (b->T->nonil && tb->T->nonil && *val != nilval);
	BATsetcount(bn, p);
	BBPreleaseref(tb->batCacheid);
	@:void_wrapup@
}
@:ifthenImpl(@1)@
@c
#include "mal_config.h"
#include "batifthen.h"

@:ifthenelseImpl(bit)@
@:ifthenelseImpl(chr)@
@:ifthenelseImpl(bte)@
@:ifthenelseImpl(sht)@
@:ifthenelseImpl(int)@
@:ifthenelseImpl(lng)@
@:ifthenelseImpl(flt)@
@:ifthenelseImpl(dbl)@

@= ifthenelseDefault
batifthen_export str CMDifThenElseCst_@1(int *ret, int *bid, @1 *tid, @1 *eid);
str CMDifThenElseCst_@1(int *ret, int *bid, @1 *tid, @1 *eid)
{
	BATiter bi;
	BAT *b, *bn;
	BUN p,q;
	@1 nilval= (@1) @1_nil, *nilptr = &nilval;
	bit *t;

	@:getBATdescriptor(bid,b,"batcalc.ifThenElse")@
	@:resultBAT(@1,"batcalc.ifThenElse")@
	bn->tsorted = FALSE;
    	BATkey(BATmirror(bn), FALSE);

	bi = bat_iterator(b);
	t = (bit*)Tloc(b,BUNfirst(b));

#if @2
	tid = *(@1**)tid;
	eid = *(@1**)eid;
	nilptr = (@1*)nilval;
#endif
	BATloop(b, p, q) {
		if (*t == bit_nil) 
			BUNfastins(bn, BUNhead(bi,p), (ptr)nilptr);
		else if (*t) 
			BUNfastins(bn, BUNhead(bi,p), (ptr) tid);
		else
			BUNfastins(bn, BUNhead(bi,p), (ptr) eid);
		t++;
	}
	bn->T->nonil = (b->T->nonil && *tid != nilval && *eid != nilval);
	@:wrapup@
}

batifthen_export str CMDifThenElse_@1(int *ret, int *bid, int *tid, int *eid);
str
CMDifThenElse_@1(int *ret, int *bid, int *tid, int *eid)
{
	BATiter bi, tbi, ebi;
	BAT *b, *tb, *eb, *bn;
	@1 nilval= (@1) @1_nil, *nilptr = &nilval;
	BUN p,q;
	bit *t;

	@:getBATdescriptor(bid,b,"batcalc.ifThenElse")@
	@:getBATdescriptor(tid,tb,"batcalc.ifThenElse",BBPreleaseref(b->batCacheid);)@
	@:getBATdescriptor(eid,eb,"batcalc.ifThenElse", BBPreleaseref(b->batCacheid); BBPreleaseref(tb->batCacheid);)@
	@:chkSize(b,tb,ifThenElse)@
	@:chkSize(b,eb,ifThenElse)@
	@:resultBAT(@1,"batcalc.ifThenElse")@
	bn->tsorted = FALSE;
    	BATkey(BATmirror(bn), FALSE);

	bi = bat_iterator(b);
	tbi = bat_iterator(tb);
	ebi = bat_iterator(eb);

	t = (bit*) Tloc(b, BUNfirst(b));

#if @2
	nilptr = (@1*)nilval;
#endif
	BATloop(b, p, q) {
		if (*t == bit_nil) 
			BUNfastins(bn, BUNhead(bi,p), (ptr)nilptr);
		else if (*t) 
			BUNfastins(bn, BUNhead(bi,p), BUNtail(tbi, p));
		else
			BUNfastins(bn, BUNhead(bi,p), BUNtail(ebi, p));
		t++;
	}
	bn->T->nonil = (b->T->nonil && tb->T->nonil && eb->T->nonil);
	BBPreleaseref(tb->batCacheid);
	BBPreleaseref(eb->batCacheid);
	@:wrapup@
}

batifthen_export str CMDifThenElseCst1_@1(int *ret, int *bid, @1 *val, int *eid);
str
CMDifThenElseCst1_@1(int *ret, int *bid, @1 *val, int *eid)
{
	BATiter bi, ebi;
	BAT *b, *eb, *bn;
	@1 nilval= (@1) @1_nil, *nilptr = &nilval;
	BUN p,q;
	bit *t;

	@:getBATdescriptor(bid,b,"batcalc.ifThenElse")@
	@:getBATdescriptor(eid,eb,"batcalc.ifThenElse", BBPreleaseref(b->batCacheid);)@
	@:chkSize(b,eb,ifThenElse)@
	@:resultBAT(@1,"batcalc.ifThenElse")@
	bn->tsorted = FALSE;
    	BATkey(BATmirror(bn), FALSE);

	bi = bat_iterator(b);
	ebi = bat_iterator(eb);

	t = (bit*) Tloc(b,BUNfirst(b));

#if @2
	val = *(@1**)val;
	nilptr = (@1*)nilval;
#endif
	BATloop(b, p, q) {
		if (*t == bit_nil) 
			BUNfastins(bn, BUNhead(bi,p), (ptr)nilptr);
		else if (*t) 
			BUNfastins(bn, BUNhead(bi,p), (ptr) val);
		else
			BUNfastins(bn, BUNhead(bi,p), BUNtail(ebi, p));
		t++;
	}
	bn->T->nonil = (b->T->nonil && eb->T->nonil && *val != nilval);
	BBPreleaseref(eb->batCacheid);
	@:wrapup@
}

batifthen_export str CMDifThenElseCst2_@1(int *ret, int *bid, int *tid, @1 *val);
str
CMDifThenElseCst2_@1(int *ret, int *bid, int *tid, @1 *val)
{
	BATiter bi, tbi;
	BAT *b, *tb, *bn;
	@1 nilval= (@1) @1_nil, *nilptr = &nilval;
	BUN p,q;
	bit *t;

	@:getBATdescriptor(bid,b,"batcalc.ifThenElse")@
	@:getBATdescriptor(tid,tb,"batcalc.ifThenElse",BBPreleaseref(b->batCacheid);)@
	@:chkSize(b,tb,ifThenElse)@
	@:resultBAT(@1,"batcalc.ifThenElse")@
	bn->tsorted = FALSE;
    	BATkey(BATmirror(bn), FALSE);

	bi = bat_iterator(b);
	tbi = bat_iterator(tb);

	t = (bit*) Tloc(b,BUNfirst(b));
	
#if @2
	val = *(@1**)val;
	nilptr = (@1*)nilval;
#endif
	BATloop(b, p, q) {
		if (*t == bit_nil)
			BUNfastins(bn, BUNhead(bi,p), (ptr)nilptr);
		else if (*t) 
			BUNfastins(bn, BUNhead(bi,p), BUNtail(tbi, p));
		else
			BUNfastins(bn, BUNhead(bi,p), val);
		t++;
	}
	bn->T->nonil = (b->T->nonil && tb->T->nonil && *val != nilval);
	BBPreleaseref(tb->batCacheid);
	@:wrapup@
}
@:ifthenImpl(@1)@
@c
@:ifthenelseDefault(oid,0)@
@:ifthenelseDefault(str,1)@
@}
