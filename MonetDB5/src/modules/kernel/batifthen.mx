@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2007 CWI.
@' All Rights Reserved.
@f batifthen
@a M.L. Kersten
@+ BAT if-then-else multiplex expressions.
The assembled code for IF-THEN-ELSE multiplex operations.
Again we assume that the BAT arguments are aligned.
@{
@-
@= ifthenGrp
command batcalc.ifthen(b:bat[:oid,:bit], t:bat[:oid,:@1]) :bat[:oid,:@1] 
address CMDifThen_@1
comment "If-then operation to assemble a conditional result ";

command batcalc.ifthen(b:bat[:oid,:bit], v:@1) :bat[:oid,:@1] 
address CMDifThenCst_@1
comment "Ifthen operation to assemble a conditional result ";

command batcalc.ifthenelse(b:bat[:oid,:bit], v:@1,w:@1) :bat[:oid,:@1] 
address CMDifThenElseCst_@1
comment "Ifthen operation to assemble a conditional result ";

command batcalc.ifthenelse(b:bat[:oid,:bit], t:bat[:oid,:@1], 
		e:bat[:oid,:@1]) :bat[:oid,:@1] 
address CMDifThenElse_@1
comment "If-then-else operation to assemble a conditional result ";

command batcalc.ifthenelse(b:bat[:oid,:bit], e:@1, t:bat[:oid,:@1])
	:bat[:oid,:@1] 
address CMDifThenElseCst1_@1
comment "If-then-else operation to assemble a conditional result ";

command batcalc.ifthenelse(b:bat[:oid,:bit], t:bat[:any_1,:@1], e:@1)
	:bat[:oid,:@1] 
address CMDifThenElseCst2_@1
comment "If-then-else operation to assemble a conditional result ";
@mal
	@:ifthenGrp(bit)@
	@:ifthenGrp(chr)@
	@:ifthenGrp(str)@
	@:ifthenGrp(oid)@
	@:ifthenGrp(int)@
	@:ifthenGrp(sht)@
	@:ifthenGrp(lng)@
	@:ifthenGrp(flt)@
	@:ifthenGrp(dbl)@
@- Implementation
@include kprelude.mx
@h
#ifndef _BATIFTHEN_
#define _BATIFTHEN_
#include "gdk.h"
#include "math.h"
#include "mal_exception.h"

#ifdef WIN32
#ifndef LIBBATIFTHEN
#define batifthen_export extern __declspec(dllimport)
#else
#define batifthen_export extern __declspec(dllexport)
#endif
#else
#define batifthen_export extern
#endif
#endif /* _BATIFTHEN_ */
@-
A general assumption in all cases is the bats are synchronized on their
head column. This is not checked and may be mis-used to deploy the
implementation for shifted window arithmetic as well.
@= chkSize
	if( BATcount(@1) != BATcount(@2) )
	throw(MAL, "batcalc.@3", "requires bats of identical size");
@= wrapup
    if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ);
    *ret= bn->batCacheid;
    BBPkeepref(*ret);
    BBPreleaseref(b->batCacheid);
    return MAL_SUCCEED;
@= resBAT
	if (BAThvoid(b)) {
		bn = BATnew(TYPE_oid, TYPE_@1, BATcount(b));
		BATseqbase(bn, b->hseqbase);
	} else {
		bn = BATnew(b->htype, TYPE_@1, BATcount(b));
	}
	if( bn== NULL) {
		@3
		throw(MAL, @2, "can not create bat");
	}
	bn->hsorted = b->hsorted;
	bn->tsorted = FALSE;
	BATkey(bn, BAThkey(b));
	BATkey(BATmirror(bn), FALSE);

@- IfThenElse
The conditional multiplex operations .
@-
The constant versions are typed by the parser
String arguments call for an extra type casting. In combination
with type resolution and runtime checks it provides a dense
definitoin.
@= ifthencstImpl
batifthen_export str CMDifThen_@1(int *ret, int *bid, int *tid);
str
CMDifThen_@1(int *ret, int *bid, int *tid) 
{
	BATiter bi, tbi;
	BAT *b, *tb, *bn;
	@1 nilval=  (@1) @1_nil, *val;
	BUN p,q;
	bit *t;

	@:getBATdescriptor(bid,b,"batcalc.ifThen")@
	@:getBATdescriptor(tid,tb,"batcalc.ifThen",BBPreleaseref(b->batCacheid))@
	@:chkSize(b,tb,CMDifThen)@

	bn= BATnew(ATOMtype(b->htype),TYPE_@1,BATcount(b));
	if( bn == 0 )
		throw(MAL, "batcalc.ifThen","Can not create BAT");
	bn->hsorted= b->hsorted;
	bn->tsorted= b->tsorted;

	bi = bat_iterator(b);
	tbi = bat_iterator(tb);

	t = (bit*)Tloc(b,BUNfirst(b));

	BATloop(b, p, q) {
		if (*t == bit_nil) 
			BUNfastins(bn, BUNhead(bi,p), (ptr) & nilval);
		else if (*t) {
			val = (@1*) BUNtail(tbi,p);
			BUNfastins(bn, BUNhead(bi,p), val);
		}
		t++;
	}
	BBPreleaseref(tb->batCacheid);
	@:wrapup@
}

batifthen_export str CMDifThenCst_@1(int *ret, int *bid, @1 *tid);
str CMDifThenCst_@1(int *ret, int *bid, @1 *tid)
{
	BATiter bi;
	BAT *b, *bn;
	@1 nilval= (@1) @1_nil;
	BUN p,q;
	bit *t;

	@:getBATdescriptor(bid,b,"batcalc.ifThen")@
	@:resBAT(@1,"batcalc.ifThen")@
	bn->hsorted= b->hsorted;
	bn->tsorted= b->tsorted;

	bi = bat_iterator(b);
	t = (bit*)Tloc(b,BUNfirst(b));

	BATloop(b, p, q) {
		if (*t == bit_nil) 
			BUNfastins(bn, BUNhead(bi,p), (ptr) & nilval);
		else if (*t) 
			BUNfastins(bn, BUNhead(bi,p), (ptr) tid);
		t++;
	}
	@:wrapup@
}
batifthen_export str CMDifThenElseCst_@1(int *ret, int *bid, @1 *tid, @1 *eid);
str CMDifThenElseCst_@1(int *ret, int *bid, @1 *tid, @1 *eid)
{
	BATiter bi;
	BAT *b, *bn;
	BUN p,q;
	@1 nilval= (@1) @1_nil;
	bit *t;

	@:getBATdescriptor(bid,b,"batcalc.ifThenElse")@
	@:resBAT(@1,"batcalc.ifThenElse")@

	bi = bat_iterator(b);
	t = (bit*)Tloc(b,BUNfirst(b));

	BATloop(b, p, q) {
		if (*t == bit_nil) 
			BUNfastins(bn, BUNhead(bi,p), (ptr) & nilval);
		else if (*t) 
			BUNfastins(bn, BUNhead(bi,p), (ptr) tid);
		else
			BUNfastins(bn, BUNhead(bi,p), (ptr) eid);
		t++;
	}
	@:wrapup@
}

batifthen_export str CMDifThenElse_@1(int *ret, int *bid, int *tid, int *eid);
str
CMDifThenElse_@1(int *ret, int *bid, int *tid, int *eid)
{
	BATiter bi, tbi, ebi;
	BAT *b, *tb, *eb, *bn;
	@1 nilval= (@1) @1_nil;
	BUN p,q;
	bit *t;

	@:getBATdescriptor(bid,b,"batcalc.ifThenElse")@
	@:getBATdescriptor(tid,tb,"batcalc.ifThenElse",BBPreleaseref(b->batCacheid);)@
	@:getBATdescriptor(eid,eb,"batcalc.ifThenElse", BBPreleaseref(b->batCacheid); BBPreleaseref(tb->batCacheid);)@
	@:chkSize(b,tb,ifThenElse)@
	@:chkSize(b,eb,ifThenElse)@
	@:resBAT(@1,"batcalc.ifThenElse")@

	bi = bat_iterator(b);
	tbi = bat_iterator(tb);
	ebi = bat_iterator(eb);

	t = (bit*) Tloc(b, BUNfirst(b));

	BATloop(b, p, q) {
		if (*t == bit_nil) 
			BUNfastins(bn, BUNhead(bi,p), (ptr) &nilval);
		else if (*t) 
			BUNfastins(bn, BUNhead(bi,p), BUNtail(tbi, p));
		else
			BUNfastins(bn, BUNhead(bi,p), BUNtail(ebi, p));
		t++;
	}
	BBPreleaseref(tb->batCacheid);
	BBPreleaseref(eb->batCacheid);
	@:wrapup@
}

batifthen_export str CMDifThenElseCst1_@1(int *ret, int *bid, @1 *val, int *eid);
str
CMDifThenElseCst1_@1(int *ret, int *bid, @1 *val, int *eid)
{
	BATiter bi, ebi;
	BAT *b, *eb, *bn;
	@1 nilval= (@1) @1_nil;
	BUN p,q;
	bit *t;

	@:getBATdescriptor(bid,b,"batcalc.ifThenElse")@
	@:getBATdescriptor(eid,eb,"batcalc.ifThenElse", BBPreleaseref(b->batCacheid);)@
	@:chkSize(b,eb,ifThenElse)@
	@:resBAT(@1,"batcalc.ifThenElse")@

	bi = bat_iterator(b);
	ebi = bat_iterator(eb);

	t = (bit*) Tloc(b,BUNfirst(b));

	if (ATOMvarsized(TYPE_@1))
		val = *(@1**)val;
	BATloop(b, p, q) {
		if (*t == bit_nil) 
			BUNfastins(bn, BUNhead(bi,p), (ptr) &nilval);
		else if (*t) 
			BUNfastins(bn, BUNhead(bi,p), (ptr) val);
		else
			BUNfastins(bn, BUNhead(bi,p), BUNtail(ebi, p));
		t++;
	}
	BBPreleaseref(eb->batCacheid);
	@:wrapup@
}

batifthen_export str CMDifThenElseCst2_@1(int *ret, int *bid, int *tid, @1 *val);
str
CMDifThenElseCst2_@1(int *ret, int *bid, int *tid, @1 *val)
{
	BATiter bi, tbi;
	BAT *b, *tb, *bn;
	@1 nilval= (@1) @1_nil;
	BUN p,q;
	bit *t;

	@:getBATdescriptor(bid,b,"batcalc.ifThenElse")@
	@:getBATdescriptor(tid,tb,"batcalc.ifThenElse",BBPreleaseref(b->batCacheid);)@
	@:chkSize(b,tb,ifThenElse)@
	@:resBAT(@1,"batcalc.ifThenElse")@

	if (ATOMvarsized(TYPE_@1))
		val = *(@1**)val;
	bi = bat_iterator(b);
	tbi = bat_iterator(tb);

	t = (bit*) Tloc(b,BUNfirst(b));

	BATloop(b, p, q) {
		if (*t == bit_nil) 
			BUNfastins(bn, BUNhead(bi,p), (ptr) &nilval);
		else if (*t) 
			BUNfastins(bn, BUNhead(bi,p), BUNtail(tbi, p));
		else
			BUNfastins(bn, BUNhead(bi,p), val);
		t++;
	}
	BBPreleaseref(tb->batCacheid);
	@:wrapup@
}
@c
#include "mal_config.h"
#include "batifthen.h"

@:ifthencstImpl(int)@
@:ifthencstImpl(sht)@
@:ifthencstImpl(lng)@
@:ifthencstImpl(oid)@
@:ifthencstImpl(flt)@
@:ifthencstImpl(dbl)@
@:ifthencstImpl(str)@
@:ifthencstImpl(chr)@
@:ifthencstImpl(bit)@
@}
