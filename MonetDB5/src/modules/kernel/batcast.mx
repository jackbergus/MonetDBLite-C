@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2007 CWI.
@' All Rights Reserved.

@f batcast
@a M.L. Kersten
@+ BAT Coercion Routines
The coercion routines over BATs can not easily be speed up using
an accumulator approach, because they often require different storage space. 
Nevertheless, the implementation provided here are much faster compared
to the Version 4.* implementation.

The coercion routines are build for speed. They are not protected
against overflow.
@{
@= idempotent
	command batcalc.@1(b:bat[:any_1,:@1]):bat[:any_1,:@1] 
	address CMDconvert_@1;
@= coercion
	command batcalc.@2(b:bat[:any_1,:@1]):bat[:any_1,:@2] 
	address CMDconvert_@1_@2
	comment "Coerce an @1 tail to a bat with @2 tail.";
	command batcalc.@2(b:bat[:void,:@1]):bat[:void,:@2] 
	address CMDconvert_void_@1_@2
	comment "Coerce an @1 tail to a bat with @2 tail.";
@mal
	@:idempotent(bit)@
	@:idempotent(chr)@
	@:idempotent(sht)@
	@:idempotent(int)@
	@:idempotent(oid)@
	@:idempotent(lng)@
	@:idempotent(flt)@
	@:idempotent(dbl)@
	@:idempotent(str)@

	@:coercion(sht,oid)@
	@:coercion(sht,int)@
	@:coercion(sht,lng)@
	@:coercion(sht,flt)@
	@:coercion(sht,dbl)@

	@:coercion(int,sht)@
	@:coercion(int,oid)@
	@:coercion(int,lng)@
	@:coercion(int,flt)@
	@:coercion(int,dbl)@

	@:coercion(lng,oid)@
	@:coercion(lng,sht)@
	@:coercion(lng,int)@
	@:coercion(lng,flt)@
	@:coercion(lng,dbl)@

	@:coercion(oid,sht)@
	@:coercion(oid,int)@
	@:coercion(oid,lng)@
	@:coercion(oid,flt)@
	@:coercion(oid,dbl)@

	@:coercion(flt,sht)@
	@:coercion(flt,int)@
	@:coercion(flt,lng)@
	@:coercion(flt,dbl)@

	@:coercion(dbl,sht)@
	@:coercion(dbl,int)@
	@:coercion(dbl,lng)@
	@:coercion(dbl,flt)@

	@:coercion(bit,sht)@
	@:coercion(bit,int)@
	@:coercion(bit,lng)@

	@:coercion(sht,bit)@
	@:coercion(int,bit)@
	@:coercion(lng,bit)@
	@:coercion(str,bit)@

	@:coercion(str,int)@
@-
@include kprelude.mx
@- Implementation
@h
#include "gdk.h"
#include "math.h"
#include "mal_exception.h"

#ifdef WIN32
#ifndef LIBBATCAST
#define batcast_export extern __declspec(dllimport)
#else
#define batcast_export extern __declspec(dllexport)
#endif
#else
#define batcast_export extern
#endif

@- Implementation of coercions

The different coercion implementations exploit the fact
that many coercions are simply space enlargers.
The others effectively may loose information, which calls
for a more expensive operation based on the conversion
routines in the GDK kernel.

@= Idempotent
batcast_export str CMDconvert_@1(int *ret, int *bid);
str CMDconvert_@1(int *ret, int *bid){
	BAT *b, *bn;
	@:getBATdescriptor(bid, b, "batcalc.@1")@

	bn= BATcopy(b, b->htype, b->ttype, 2);
	@:tstBAT("batcalc.@1")@
	*ret= bn->batCacheid;
	BBPkeepref(*ret);
	BBPreleaseref(b->batCacheid);
	return MAL_SUCCEED;
}
@= wrapup
	if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ);
	*ret= bn->batCacheid;
	BATkey(BATmirror(bn), FALSE);
	bn->tsorted = 0;
	BBPkeepref(*ret);
	BBPreleaseref(b->batCacheid);
	return MAL_SUCCEED;
@-
The void case is geared at speed.
Test against overflow in a reduce situation.
@= Mapping
batcast_export str CMDconvert_void_@1_@2(int *ret, int *bid);
str CMDconvert_void_@1_@2(int *ret, int *bid){
	BAT *b,*bn;
	@1 *p,*q;
	@2 *o;
	size_t xx;

	@:getBATdescriptor(bid, b, "batcalc.@2")@
	@:resultBAT(@2,"batcalc.@2")@
	o= (@2*)BUNtail(bn,BUNfirst(bn));
	p= (@1*)BUNtail(b,BUNfirst(b));
	q= (@1*)BUNtail(b,BUNlast(b));
	xx= BUNsize(b);
	while(p<q){
		*o = *p== @1_nil ?  @2_nil: (@2) *p;
		p= (@1 *) ((char*)p+xx); o++;
	}
	(bn)->batBuns->free += BATcount(b)*sizeof(@2);
	BATsetcount(bn, BATcount(b));
	@:wrapup@
}
@= GeneralFixed
batcast_export str CMDconvert_@1_@2(int *ret, int *bid);
str CMDconvert_@1_@2(int *ret, int *bid){
	BAT *b,*bn;
	size_t xx;
	@2 y;
	char *p, *q, *h;

	@:getBATdescriptor(bid, b, "batcalc.@2")@
	@:resultBAT(@2,"batcalc.@2")@
	h= (char*) BUNhead(b,BUNfirst(b));
	p= (char*) BUNfirst(b);
	q= (char*) BUNlast(b);
	xx= BUNsize(b);

	while(p<q){
		@1 *r = (@1*)BUNtail(b,p);
		y= (*r == @1_nil) ? @2_nil: (@2)(*r);
		bunfastins(bn, h, &y);
		p+= xx; h+=xx;
	}
bunins_failed:
	@:wrapup@
}
@-
Handling string coercion
		ATOMfromstr( TYPE_@1, &v, &len, (char*)Tbase(b)+*(var_t*)p);
@= ConvertToStr
		@1ToStr(&dst,&len, (ptr) r);
		bunfastins(bn, h, (ptr)dst);
		if( dst) GDKfree(dst);
@= ConvertFromStr
		v= NULL; len=0;
		ATOMfromstr( TYPE_@1, &v, &len, (char*)Tbase(b)+*(var_t*)p);
		bunfastins(bn, h, v);
		if(ATOMextern(TYPE_@1) )
			GDKfree(v);
@= GeneralStr
batcast_export str CMDconvert_@1_str(int *ret, int *bid);
str CMDconvert_@1_str(int *ret, int *bid){
	BAT *b,*bn;
	size_t xx;
	char *p,*q,*h;
	str dst=0;
	int len=0;

	@:getBATdescriptor(bid, b, "batcalc.@2")@
	@:resultBAT(str,"batcalc.@2")@
	h= (char*) BUNhead(b,BUNfirst(b));
	p= (char*) BUNfirst(b);
	q= (char*) BUNlast(b);
	xx= BUNsize(b);

	while(p<q){
		@1 *r = (@1*)BUNtail(b,p);
		@:ConvertToStr(@1)@
		p+=xx; h+= xx;
	}
bunins_failed:
	@:wrapup@
}
batcast_export str CMDconvert_void_@1_str(int *ret, int *bid);
str CMDconvert_void_@1_str(int *ret, int *bid){
	return CMDconvert_@1_str(ret,bid);
}

batcast_export str CMDconvert_str_@1(int *ret, int *bid);
str CMDconvert_str_@1(int *ret, int *bid){
	BAT *b,*bn;
	int xx;
	char *p,*q,*h;
	ptr v;
	int len;

	@:getBATdescriptor(bid, b, "batcalc.@1")@
	@:resultBAT(@1,"batcalc.@1")@
	h= (char *) BUNhead(b,BUNfirst(b));
	p= (ptr) BUNtloc(b,BUNfirst(b));
	q= (char *) BUNtloc(b,BUNlast(b));
	xx= BUNsize(b);

	while(p<q){
		@:ConvertFromStr(@1)@
		p+=xx; h+= xx;
	}
bunins_failed:
	@:wrapup@
}
batcast_export str CMDconvert_void_str_@1(int *ret, int *bid);
str CMDconvert_void_str_@1(int *ret, int *bid){
	return CMDconvert_str_@1(ret,bid);
}
@-
The lengthly list of coercions options could have been generated.
@c
#include "mal_config.h"
#include "batcast.h"

int	oidToStr(char **dst, int *len, oid *src  ){
		return OIDtoStr(dst,len, src);
}
	@:Idempotent(bit)@
	@:Idempotent(chr)@
	@:Idempotent(sht)@
	@:Idempotent(int)@
	@:Idempotent(oid)@
	@:Idempotent(lng)@
	@:Idempotent(flt)@
	@:Idempotent(dbl)@
	@:Idempotent(str)@

	@:GeneralStr(bit)@
	@:GeneralStr(chr)@
	@:GeneralStr(sht)@
	@:GeneralStr(int)@
	@:GeneralStr(lng)@
	@:GeneralStr(flt)@
	@:GeneralStr(dbl)@

@-
The reduction coding is still to be provided.
@= CoercionEnlarge
	@:GeneralFixed(@1,@2)@
	@:Mapping(@1,@2)@
@= CoercionReduce
	@:GeneralFixed(@1,@2)@
	@:Mapping(@1,@2)@
@-
Write out all combinations to ease subsequent
code fine tuning
@c
	@:CoercionEnlarge(sht,oid)@
	@:CoercionEnlarge(sht,int)@
	@:CoercionEnlarge(sht,lng)@
	@:CoercionEnlarge(sht,flt)@
	@:CoercionEnlarge(sht,dbl)@

	@:CoercionReduce(int,sht)@
	@:CoercionEnlarge(int,oid)@
	@:CoercionEnlarge(int,lng)@
	@:CoercionEnlarge(int,flt)@
	@:CoercionEnlarge(int,dbl)@

	@:CoercionReduce(lng,oid)@
	@:CoercionReduce(lng,sht)@
	@:CoercionReduce(lng,int)@
	@:CoercionEnlarge(lng,flt)@
	@:CoercionEnlarge(lng,dbl)@

	@:CoercionReduce(oid,sht)@
	@:CoercionReduce(oid,int)@
	@:CoercionEnlarge(oid,lng)@
	@:CoercionEnlarge(oid,flt)@
	@:CoercionEnlarge(oid,dbl)@

	@:CoercionReduce(flt,sht)@
	@:CoercionReduce(flt,int)@
	@:CoercionReduce(flt,lng)@
	@:CoercionEnlarge(flt,dbl)@

	@:CoercionReduce(dbl,sht)@
	@:CoercionReduce(dbl,int)@
	@:CoercionReduce(dbl,lng)@
	@:CoercionReduce(dbl,flt)@

	@:CoercionEnlarge(bit,sht)@
	@:CoercionEnlarge(bit,int)@
	@:CoercionEnlarge(bit,lng)@

	@:CoercionReduce(sht,bit)@
	@:CoercionReduce(int,bit)@
	@:CoercionReduce(lng,bit)@
@}
