@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2006 CWI.
@' All Rights Reserved.

@f batcast
@a M.L. Kersten
@+ BAT Coercion Routines
The coercion routines over BATs can not easily be speed up using
an accumulator approach, because they often require different storage space. 
Nevertheless, the implementation provided here are much faster compared
to the Version 4.* implementation.

The coercion routines are build for speed. They are not protected
against overflow.

@= coercion
	command batcalc.@2(b:bat[:any_1,:@1]):bat[:any_1,:@2] 
	address CMDconvert_@1_@2
	comment "Coerce an @1 tail to a bat with @2 tail.";
	command batcalc.@2(b:bat[:void,:@1]):bat[:void,:@2] 
	address CMDconvert_void_@1_@2
	comment "Coerce an @1 tail to a bat with @2 tail.";
@{
@-
@= Coercion
	@:coercion(@1,sht)@
	@:coercion(@1,int)@
	@:coercion(@1,oid)@
	@:coercion(@1,lng)@
	@:coercion(@1,dbl)@
	@:coercion(@1,flt)@
	@:coercion(@1,str)@
@mal
	@:Coercion(sht)@
	@:Coercion(int)@
	@:Coercion(lng)@
	@:Coercion(flt)@
	@:Coercion(dbl)@
	@:Coercion(str)@

	@:coercion(bit,sht)@
	@:coercion(bit,int)@
	@:coercion(bit,lng)@

	@:coercion(oid,sht)@
	@:coercion(oid,int)@
	@:coercion(oid,lng)@

	@:coercion(oid,oid)@
	@:coercion(chr,chr)@

	@:coercion(sht,bit)@
	@:coercion(int,bit)@
	@:coercion(lng,bit)@
	@:coercion(str,bit)@
@-
@{
@include kprelude.mx
@- Implementation
@h
#include "gdk.h"
#include "math.h"
#include "mal_exception.h"

#ifdef WIN32
#ifndef LIBBATCAST
#define batcast_export extern __declspec(dllimport)
#else
#define batcast_export extern __declspec(dllexport)
#endif
#else
#define batcast_export extern
#endif

@- Implementation of coercions

The different coercion implementations exploit the fact
that many coercions are simply space enlargers.
The others effectively may loose information, which calls
for a more expensive operation based on the conversion
routines in the GDK kernel.

@= tstBat
if( bn== NULL) {*ret= 0; 
	return throwMessage("batcalc.@1", "can not create bat");}

@= Idempotent
batcast_export str CMDconvert_@1(int *ret, int *bid);
str CMDconvert_@1(int *ret, int *bid){
	BAT *b, *bn;
	@:getBATdescriptor(ret, bid, b, "batcalc.convert")@

	bn= BATrcopy(b);
	@:tstBat(CMDconvert_@1)@
	*ret= bn->batCacheid;
	BBPkeepref(*ret);
	BBPreleaseref(b->batCacheid);
	return MAL_SUCCEED;
}
@-
The void case is geared at speed.
Test against overflow in a reduce situation.
@= Mapping
batcast_export str CMDconvert_void_@1_@2(int *ret, int *bid);
str CMDconvert_void_@1_@2(int *ret, int *bid){
	BAT *b,*bn;
	@1 *p,*q;
	@2 *o;

	if( TYPE_@1 == TYPE_@2)
		return CMDconvert_@1(ret,bid);
	@:getBATdescriptor(ret, bid, b, "batcalc.convert")@

	bn= newBATcresult(b, TYPE_@2);
	@:tstBat(CMDconvert_@1_@2)@
	o= (@2*)BUNtail(bn,BUNfirst(bn));
	p= (@1*)BUNtail(b,BUNfirst(b));
	q= (@1*)BUNtail(b,BUNlast(b));
	if(sizeof(@1) != BUNsize(b)  ){
		size_t xx= BUNsize(b);
		while(p<q){
			*o = *p== @1_nil ?  @2_nil: (@2) *p;
			p= (@1 *) ((char*)p+xx); o++;
		}
	} else {
		while(p<q){
			*o = *p== @1_nil ?  @2_nil: (@2) *p;
			p++; o++;
		}
	}
bunins_failed:
	(bn)->batBuns->free += BATcount(b)*sizeof(@2);
	BATsetcount(bn, BATcount(b));
	if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ);
	*ret= bn->batCacheid;
	BBPkeepref(*ret);
	BBPreleaseref(b->batCacheid);
	return MAL_SUCCEED;
}
@= GeneralFixed
batcast_export str CMDconvert_@1_@2(int *ret, int *bid);
str CMDconvert_@1_@2(int *ret, int *bid){
	BAT *b,*bn;
	size_t xx;
	@2 y;
	char *p, *q, *h;

	if( TYPE_@1 == TYPE_@2)
		return CMDconvert_@1(ret,bid);
	@:getBATdescriptor(ret, bid, b, "batcalc.convert")@

	bn= newBATcresult(b, TYPE_@2);
	@:tstBat(CMDconvert_@1)@

	h= (char*) BUNhead(b,BUNfirst(b));
	p= (char*) BUNtail(b,BUNfirst(b));
	q= (char*) BUNtail(b,BUNlast(b));
	xx= BUNsize(b);

	while(p<q){
		y= *(@1*)p== @1_nil? @2_nil: (@2) *(@1*)p;
		bunfastins(bn, h, &y);
		p+= xx; h+=xx;
	}
bunins_failed:
	bn->tsorted = 0;
	if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ); \
	*ret= bn->batCacheid;
	BBPkeepref(*ret);
	BBPreleaseref(b->batCacheid);
	return MAL_SUCCEED;
}
@= GeneralToStr
batcast_export str CMDconvert_@1_str(int *ret, int *bid);
str CMDconvert_@1_str(int *ret, int *bid){
	BAT *b,*bn;
	size_t xx;
	char *p,*q,*h;
	str dst=0;
	int len=0;

	@:getBATdescriptor(ret, bid, b, "batcalc.convert")@
	bn= newBATcresult(b, TYPE_str);
	@:tstBat(CMDconvert_@1)@

	h= (char*) BUNhead(b,BUNfirst(b));
	p= (char*) BUNtail(b,BUNfirst(b));
	q= (char*) BUNtail(b,BUNlast(b));
	xx= BUNsize(b);

	while(p<q){
		@1ToStr(&dst,&len, (ptr) p);
		bunfastins(bn, h, (ptr)dst);
		if( dst) GDKfree(dst);
		p+=xx; h+= xx;
	}
bunins_failed:
	bn->tsorted = 0;
	if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ); \
	*ret= bn->batCacheid;
	BBPkeepref(*ret);
	BBPreleaseref(b->batCacheid);
	return MAL_SUCCEED;
}
batcast_export str CMDconvert_void_@1_str(int *ret, int *bid);
str CMDconvert_void_@1_str(int *ret, int *bid){
	return CMDconvert_@1_str(ret,bid);
}
@= GeneralFromStr
batcast_export str CMDconvert_str_@1(int *ret, int *bid);
str CMDconvert_str_@1(int *ret, int *bid){
	BAT *b,*bn;
	int xx;
	char * t,*h,*e;
	ptr v;
	int len;

	@:getBATdescriptor(ret, bid, b, "batcalc.convert")@
	bn= newBATcresult(b, TYPE_@1);
	@:tstBat(CMDconvert_str_@1)@

	h= (ptr) BUNhloc(b,BUNfirst(b));
	t= (ptr) BUNtloc(b,BUNfirst(b));
	e= (ptr) BUNhloc(b,BUNlast(b));
	xx= BUNsize(b);

	while(h<e){
		v= NULL; len=0;
		ATOMfromstr( TYPE_@1, &v, &len, (char*)Tbase(b)+*(var_t*)t);
		bunfastins(bn, h, v);
		if(ATOMextern(TYPE_@1) )
			GDKfree(v);
		t+=xx; h+= xx;
	}
bunins_failed:
	bn->tsorted = 0;
	if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ); \
	*ret= bn->batCacheid;
	BBPkeepref(*ret);
	BBPreleaseref(b->batCacheid);
	return MAL_SUCCEED;
}
batcast_export str CMDconvert_void_str_@1(int *ret, int *bid);
str CMDconvert_void_str_@1(int *ret, int *bid){
	return CMDconvert_str_@1(ret,bid);
}
@-
The lengthly list of coercions options could have been generated.
@c
#include "batcast.h"

#define BATwcopy(b) BATcopy(b, b->htype, b->ttype, TRUE)
#define BATrcopy(b) BATcopy(b, b->htype, b->ttype, 2)

static BAT *
newBATcresult(BAT *b, int tpe)
{
	BAT *bn;

	if (BAThvoid(b)) {
		bn = BATnew(TYPE_void, tpe, BATcount(b));
		BATseqbase(bn, b->hseqbase);
	} else
		bn = BATnew(b->htype, tpe, BATcount(b));
	bn->hsorted = b->hsorted;
	bn->tsorted = b->tsorted;
	return bn;
}
@-
@= CoercionImpl
	@:GeneralFixed(@1,oid)@
	@:GeneralFixed(@1,int)@
	@:GeneralFixed(@1,lng)@
	@:GeneralFixed(@1,flt)@
	@:GeneralFixed(@1,dbl)@
	@:Mapping(@1,oid)@
	@:Mapping(@1,int)@
	@:Mapping(@1,lng)@
	@:Mapping(@1,flt)@
	@:Mapping(@1,dbl)@
	@:GeneralToStr(@1)@
	@:GeneralFromStr(@1)@
@c

int	oidToStr(char **dst, int *len, oid *src  ){
		return OIDtoStr(dst,len, src);
}
@:Idempotent(bit)@
@:Idempotent(sht)@
@:Idempotent(int)@
@:Idempotent(lng)@
@:Idempotent(flt)@
@:Idempotent(dbl)@
@:Idempotent(str)@
@:Idempotent(oid)@
@:Idempotent(chr)@

@:CoercionImpl(sht)@
@:CoercionImpl(int)@
@:CoercionImpl(oid)@
@:CoercionImpl(lng)@
@:CoercionImpl(flt)@
@:CoercionImpl(dbl)@

@:GeneralFixed(sht,sht)@
@:GeneralFixed(int,sht)@
@:GeneralFixed(oid,sht)@
@:GeneralFixed(lng,sht)@
@:GeneralFixed(flt,sht)@
@:GeneralFixed(dbl,sht)@
@:Mapping(sht,sht)@
@:Mapping(int,sht)@
@:Mapping(lng,sht)@
@:Mapping(oid,sht)@
@:Mapping(flt,sht)@
@:Mapping(dbl,sht)@

@:GeneralFixed(bit,sht)@
@:GeneralFixed(bit,int)@
@:GeneralFixed(bit,lng)@
@:Mapping(bit,sht)@
@:Mapping(bit,int)@
@:Mapping(bit,lng)@

@:GeneralFixed(sht,bit)@
@:GeneralFixed(int,bit)@
@:GeneralFixed(lng,bit)@
@:Mapping(sht,bit)@
@:Mapping(int,bit)@
@:Mapping(lng,bit)@

@:GeneralFixed(chr,chr)@
@:Mapping(chr,chr)@

@:GeneralFromStr(bit)@

batcast_export str CMDconvert_void_str_str(int *ret, int *bid);
str CMDconvert_void_str_str(int *ret, int *bid){
	return CMDconvert_str(ret,bid);
}
batcast_export str CMDconvert_str_str(int *ret, int *bid);
str CMDconvert_str_str(int *ret, int *bid){
	return CMDconvert_str(ret,bid);
}
@}
