@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
@' Copyright August 2008-2010 MonetDB B.V.
@' All Rights Reserved.

@f batmmath
@a M.L. Kersten
@+ BAT math calculator
This module contains the multiplex versions of the linked
in mathematical functions.
@{
@= tstBat
if( bn== NULL) {*ret= 0;
	throw(MAL, "batcalc.@1", MAL_MALLOC_FAIL);}

@+ Scientific routines
The mmath functions are also overloaded to provide for
the fast execution of expanded code blocks.
The common set of math functions is supported.
@= scienceFcn
	command @1(x:bat[:oid,:dbl])  :bat[:oid,:dbl] 
	address CMDscience_bat_dbl_@1;
	command @1(x:bat[:oid,:flt])  :bat[:oid,:flt] 
	address CMDscience_bat_flt_@1;
@= scienceFcnBinary
	command @1(x:bat[:oid,:dbl],y:dbl):bat[:oid,:dbl] 
	address CMDscience_bat_cst_@1_dbl;
	command @1(x:bat[:oid,:flt],y:flt):bat[:oid,:flt] 
	address CMDscience_bat_cst_@1_flt;
@-
@mal
module batmmath;
	@:scienceFcn(asin)@
	@:scienceFcn(acos)@
	@:scienceFcn(atan)@
	@:scienceFcn(cos)@
	@:scienceFcn(sin)@
	@:scienceFcn(tan)@
	@:scienceFcn(cosh)@
	@:scienceFcn(sinh)@
	@:scienceFcn(tanh)@
	@:scienceFcn(exp)@
	@:scienceFcn(log)@
	@:scienceFcn(log10)@
	@:scienceFcn(sqrt)@
	@:scienceFcn(ceil)@
	@:scienceFcn(fabs)@
	@:scienceFcn(floor)@
@-
	round is not binary...
	@:scienceFcnBinary(round,int)@
@mal
	@:scienceFcnBinary(fmod)@
	@:scienceFcnBinary(atan2)@
	@:scienceFcnBinary(pow)@
@- Implementation
@include kprelude.mx

@h
#ifdef _BATMATH_H
#define _BATMATH_H

#endif  /* _BATMATH_H */
@- Implementations of scientific functions
@c
#include "mal_config.h"
#include "gdk.h"
#include "math.h"
#include "mal_exception.h"
#include "batmmath.h"

#ifdef WIN32
#ifndef LIBBATMMATH
#define batmmath_export extern __declspec(dllimport)
#else
#define batmmath_export extern __declspec(dllexport)
#endif
#else
#define batmmath_export extern
#endif

@-
@= scienceFcnImpl
batmmath_export str CMDscience_bat_@2_@1(int *ret, int *bid);
str CMDscience_bat_@2_@1(int *ret, int *bid)
{
	BAT *b,*bn;
	@2 *o, *p, *q;

	@:getBATdescriptor(bid,b,"batcalc.@1")@
	@:voidresultBAT(TYPE_@2,"batcalc.@1")@

	o = (@2*) Tloc(bn, BUNfirst(bn));
	p = (@2*) Tloc(b, BUNfirst(b));
	q = (@2*) Tloc(b, BUNlast(b));

	BATaccessBegin(b, USE_TAIL, MMAP_SEQUENTIAL);
	if (b->T->nonil){
		for(;p<q; o++, p++)
			*o = (@2) @1(*p);
	} else
		for(;p<q; o++, p++){
			*o = *p == @2_nil? @2_nil: (@2) @1(*p);
		}
	BATaccessEnd(b, USE_TAIL, MMAP_SEQUENTIAL);
	BATsetcount(bn, BATcount(b));
	bn->tsorted = 0;
	BATkey(BATmirror(bn),0);           
	
	if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ); 

	if (b->htype != bn->htype) {
		BAT *r = VIEWcreate(b,bn);

		BBPreleaseref(bn->batCacheid);
		bn = r;
	}
	BBPkeepref(*ret = bn->batCacheid);
	BBPreleaseref(b->batCacheid);
	return MAL_SUCCEED;
}
@= scienceBinaryImpl
batmmath_export str CMDscience_bat_cst_@1_@2(int *ret, int *bid, @2 *d);
str CMDscience_bat_cst_@1_@2(int *ret, int *bid, @2 *d)
{
	BAT *b,*bn;
	@2 *o, *p, *q;

	@:getBATdescriptor(bid,b,"batcalc.@1")@
	@:voidresultBAT(TYPE_@2,"batcalc.@1")@

	o = (@2*) Tloc(bn, BUNfirst(bn));
	p = (@2*) Tloc(b, BUNfirst(b));
	q = (@2*) Tloc(b, BUNlast(b));

	BATaccessBegin(b, USE_TAIL, MMAP_SEQUENTIAL);
	if (b->T->nonil){
		for(;p<q; o++, p++)
			*o = (@2) @1(*p,*d);
	} else
		for(;p<q; o++, p++){
			*o = *p == @2_nil? @2_nil: (@2) @1(*p,*d);
		}
	BATaccessEnd(b, USE_TAIL, MMAP_SEQUENTIAL);

	BATsetcount(bn, BATcount(b));
	bn->tsorted = 0;
	BATkey(BATmirror(bn),0);           

	if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ); 

	if (b->htype != bn->htype) {
		BAT *r = VIEWcreate(b,bn);

		BBPreleaseref(bn->batCacheid);
		bn = r;
	}
	BBPkeepref(*ret = bn->batCacheid);
	BBPreleaseref(b->batCacheid);
	return MAL_SUCCEED;
}
@= scienceImpl
@:scienceFcnImpl(@1,dbl)@
@:scienceFcnImpl(@1,flt)@
@c
@:scienceImpl(asin)@
@:scienceImpl(acos)@
@:scienceImpl(atan)@
@:scienceImpl(cos)@
@:scienceImpl(sin)@
@:scienceImpl(tan)@
@:scienceImpl(cosh)@
@:scienceImpl(sinh)@
@:scienceImpl(tanh)@
@:scienceImpl(exp)@
@:scienceImpl(log)@
@:scienceImpl(log10)@
@:scienceImpl(sqrt)@
@:scienceImpl(ceil)@
@:scienceImpl(fabs)@
@:scienceImpl(floor)@
@-
	round is not binary...
	@:scienceBinaryImpl(round,int)@
@c
@:scienceBinaryImpl(fmod,dbl)@
@:scienceBinaryImpl(fmod,flt)@
@:scienceBinaryImpl(atan2,dbl)@
@:scienceBinaryImpl(atan2,flt)@
@:scienceBinaryImpl(pow,dbl)@
@:scienceBinaryImpl(pow,flt)@

@}
