@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2005 CWI.
@' All Rights Reserved.

@f bat
@v 2.0
@a Peter Boncz, M.L. Kersten
@* Binary Association Tables
This module contains the commands and patterns to manage Binary
Association Tables (BATs). The relational operations you can execute
on BATs have the form of a neat algebra, described in algebra.mx

But a database system needs more that just this algebra, since often it
is crucial to do table-updates (this would not be permitted in a strict
algebra).

All commands needed for BAT updates, property management, basic I/O, 
persistence, and storage options can be found in this module.

All parameters to the modules are passed by reference.
In particular, this means that string values are passed to the module
layer as (str *)
and we have to de-reference them before entering the gdk library.
(Actual a design error in gdk to differentiate passing int/str)
This calls for knowledge on the underlying BAT types`s
@{
@= derefStr
{ if( @1->@2type >= TYPE_str  && ATOMstorage(@1->@2type) >= TYPE_str)
 { if(@3== 0 || *(str*)@3==0) @3= str_nil;
   else @3 = *(str *)@3; 
}}
@-
The code speaks for itself
@}
@mal

module bat;

#command bat(ht:int, tt:int) :bat[:any_1,:any_2] 
#address BKCnewBat
#comment "Creates a new empty transient BAT with head- and tail-types 
#        as indicated.";
#
#command bat(ht:int, tt:int, size:int) :bat[:any_1,:any_2] 
#address BKCnewBATint
#comment "Creates a new empty BAT, allocating 'size' elements.";
#
#command bat(ht:int, tt:int, size:lng) :bat[:any_1,:any_2] 
#address BKCnewBATlng
#comment "Creates a new empty BAT, allocating 'size' elements.";

command reverse(b:bat[:any_1,:any_2]) :bat[:any_2,:any_1] 
address BKCreverse
comment "Returns the reverse view of a BAT (head is tail and tail is head).
        BEWARE  no copying is involved; input and output refer to the 
        same object!";

command mirror(b:bat[:any_1,:any]) :bat[:any_1,:any_1] 
address BKCmirror
comment "Returns the head-mirror image of a BAT (two head columns).";
command mirror(b:bat[:void,:any]) :bat[:void,:void] 
address BKCmirror
comment "Returns the head-mirror image of a BAT (two head columns).";

#command convert(b:bat[:any_1,:any_2] ) :bat[:any_1,:any_2] 
#address BKCconvert
#comment "Convert the contents of a BAT from little-endian to big-endian 
#        and vice versa. THIS command SHOULD NOT BE USED FROM MAL!
#	DANGEROUS! DEBUGGING PURPOSES ONLY!";

#command sort(b:bat[:any_1,:any_2]) :bat[:any_1,:any_2] 
#address BKCsort
#comment "Sorts the BAT itself on the head, in place. ";

command revert(b:bat[:any_1,:any_2]) :bat[:any_1,:any_2] 
address BKCrevert
comment "Puts all BUNs in a BAT in reverse order.  (Belongs to the 
        BAT sequence module)";

@+ BAT properties
Properties of BATs not necessarily require loading the BAT completely.
The BAT identifier can be used to access the descriptors.
These properties can be inspected with the 
@emph{info(BAT[:any_1,:any_2]) :bat[str,str] } command:
@verbatim
> car_age.info.print;
#---------------------------------#
# BAT:               tmp_31       #
# (str)              (str)        #
#---------------------------------#
[ "batId",           "car_age"    ] # logical bat name
[ "batCacheid",      "26"         ] # BBP index
[ "batParentid",     "0"          ] # set if a BAT is a view
[ "head",            "void"       ] # physical head-type
[ "tail",            "int"        ] # physical tail-type
[ "batPersistence",  "persistent" ] # transient/session/persistent
[ "batRestricted",   "updatable"  ] # read-only/append-only/updatable
[ "batDirty",        "clean"      ] # clean/dirty
[ "batRefcnt",       "1"          ] # physical refcount
[ "batLRefcnt",      "1"          ] # logical refcount (total)
[ "batPlevel",       "1"          ] # logical refcount (persistent part)
[ "batSet",          "0"          ] # [head,tail] combinations are unique
[ "batCopiedtodisk", "1"          ] # has been saved or not
@end verbatim

Per column, a number of properties are kept. We only show the head-properties; the tail properties
have the first character of their named replaced by 't' (@emph{sorted}, @emph{tdense}, etc.):
@verbatim
[ "hsorted",         "1"          ] # column is known to be sorted
[ "hdense",          "1"          ] # column is known to be densely ascended
[ "hseqbase",        "0@0"        ] # if densely ascending first value
@end verbatim

As described in the @[<a href="www/gdk.html#mod_1_3_0">GDK Technical Reference</a>@,
BATs store their data in one to five heaps, of which at least one called @emph{batBuns}
is present always. For each column type that is @emph{variable-sized} - like @emph{str} - another
heap might be present (@emph{hheap} and @emph{theap}). 

@verbatim
[ "batBuns.free",    "400004"     ] # occupied size in bytes
[ "batBuns.size",    "400012"     ] # allocated size in bytes
[ "batBuns.maxsize", "400012"     ] # reserver virtual memory in bytes
[ "batBuns.storage", "malloced"   ] # malloced/mmap/priv
@end verbatim

Properties steer the algorithms that Monet uses to execute algebra command. For instance,
the @emph{find(bat[:any_1,:any_2] b, :any_1) :any_2} that looks up a tail value by head,
uses binary search if and only if the head column is sorted (in other cases, hash-lookup
and scan are execution options).

Sometimes new (extension) code contains bugs in the property management, leaving false
properties on produced BATs. You can imagine that later on, this leads to additional
bugs, as e,g, the binary search algorithms will yield erroneous results on a non-sorted
sequence.

@mal
command info ( b:bat[:any_1,:any_2]) :bat[:str,:str] 
address BKCinfo
comment "Produce a BAT containing info about a BAT in [attribute,value] format. 
        It contains all properties of the BAT record. See the BAT documentation 
        in GDK for more information.";

command getCapacity(b:bat[:any_1,:any_2]):lng 
address BKCgetCapacity
comment "Returns the current allocation size (in max number of elements) of a BAT.";

command getHeadType(b:bat[:any_1,:any_2] ) :str 
address BKCgetHeadType
comment "Returns the type of the head column of a BAT, as an integer type number.";

command getTailType( b:bat[:any_1,:any_2] ) :str 
address BKCgetTailType 
comment "Returns the type of the tail column of a BAT, as an integer type number.";

command getRole ( bid:bat[:any_1,:any_2] ) :str 
address BKCgetRole
comment "Returns the rolename of the head column of a BAT.";

command setKey( b:bat[:any_1,:any_2], mode:bit) :bat[:any_1,:any_2] 
address BKCsetkey
comment "Sets the 'key' property of the head column to 'mode'. In 'key' mode, 
        the kernel will silently block insertions that cause a duplicate 
        entries in the head column. KNOWN BUG:when 'key' is set to TRUE, this 
	function does not automatically eliminate duplicates. 
        Use b := b.kunique;";

command isaKey( b:bat[:any_1,:any_2]) :bit 
address BKCgetKey
comment "return whether the head column of a BAT is unique (key).";

command setSet( b:bat[:any_1,:any_2], mode:bit) :bat[:any_1,:any_2] 
address BKCsetSet
comment "Sets the 'set' property on this BAT to 'mode'. In 'set' mode, 
        the kernel will silently block insertions that cause a duplicate 
        BUN [head,tail] entries in the BAT.  KNOWN BUG:when 'set' is set 
        to TRUE, this function does not automatically eliminate duplicates. 
        Use b := b.sunique; Returns the BAT itself.";

command isaSet( b:bat[:any_1,:any_1]) :bit 
address BKCisaSet
comment "return whether the BAT mode is set to unique.";

command setAccess( b:bat[:any_1,:any_2], mode:str) :bat[:any_1,:any_2]
address BKCsetAccess
comment "Try to change the update access priviliges 
	to this BAT. Mode:
	 r[ead-only]      - allow only read access.
	 a[append-only]   - allow reads and update.
	 w[riteable]      - allow all operations.
	BATs are updatable by default. On making a BAT read-only, 
        all subsequent updates fail with an error message.Returns 
        the BAT itself.";
#command access( b:bat[:any_1,:any_2], mode:int) :bat[:any_1,:any_2]
#address BKCaccess;

command setAppendMode( b:bat[:any_1,:any_2]) :bat[:any_1,:any_2]
address BKCsetAppendMode
comment "Change access privilige of BAT to append only";

command setReadMode( b:bat[:any_1,:any_2]) :bat[:any_1,:any_2]
address BKCsetReadMode
comment "Change access privilige of BAT to read only";

command setWriteMode( b:bat[:any_1,:any_2]) :bat[:any_1,:any_2]
address BKCsetWriteMode
comment "Change access privilige of BAT to read and write";

command getAccess( b:bat[:any_1,:any_2]):str 
address BKCgetAccess
comment "return the access mode attached to this BAT as a character.";

command hasAppendMode( b:bat[:any_1,:any_2]):bit 
address BKChasAppendMode
comment "return true if to this BAT is append only.";

command hasWriteMode( b:bat[:any_1,:any_2]):bit 
address BKChasWriteMode
comment "return true if to this BAT is read and write.";

command hasReadMode( b:bat[:any_1,:any_2]):bit 
address BKChasReadMode
comment "return true if to this BAT is read only.";


command getSequenceBase( b:bat[:void,:any_1]):oid 
address BKCgetSequenceBase
comment "Get the sequence base for the void column of a BAT.";
command getSequenceBase( b:bat[:oid,:any_1]):oid 
address BKCgetSequenceBase;

command setSequenceBase( b:bat[:void,:any_1], seqbase:oid):bat[:void,:any_1]
address BKCsetSequenceBase
comment "Set the sequence base for the void column of a BAT.";
command setSequenceBase( b:bat[:oid,:any_1], seqbase:oid):bat[:void,:any_1]
address BKCsetSequenceBase;
command setSequenceBase( b:bat[:void,:any_1], seqbase:void):bat[:void,:any_1]
address BKCsetSequenceBaseNil;


command setSorted(b:bat[:any_1,:any_2]) :bit 
address BKCsetSorted
comment "Assure BAT is ordered on the head.";

command isSorted(b:bat[:any_1,:any_2]) :bit 
address BKCisSorted
comment "Returns whether a BAT is ordered on head or not.";
command isSortedReverse(b:bat[:any_1,:any_2]) :bit 
address BKCisSortedReverse
comment "Returns whether a BAT is ordered on head or not.";

command getBatSize(b:bat[:any_1,:any_2]) :int 
address BKCbatsize
comment "A version of BATsize that does not require loading the BAT.";

@- BAT updates
Update commands come in many disguises.  Note that we don;t return
the BAT id, but merely a success/failure code.
@mal
command insert(b:bat[:any_1,:oid], src:bat[:any_1,:void]) :void
address BKCinsert_bat
comment "Insert all BUNs of the second BAT into the first. This case 
        should be removed, because it is a hack for SQL";

command insert(b:bat[:void,:any_2], src:bat[:oid,:any_2]) :void
address BKCinsert_bat
comment "Insert all BUNs of the second BAT into the first. This case 
        should be removed, because it is a hack for SQL";

command insert(b:bat[:oid,:any_2], src:bat[:void,:any_2]) :void
address BKCinsert_bat
comment "Insert all BUNs of the second BAT into the first. This case 
        should be removed, because it is a hack for SQL";

command insert(b:bat[:any_1,:any_2], src:bat[:any_1,:any_2]):void
address BKCinsert_bat
comment "Insert all BUNs of the second BAT into the first.";

command insert(b:bat[:any_1,:any_2], h:any_1, t:any_2) :void
address BKCinsert_bun
comment "Insert one BUN[h,t] in a BAT.";
command insert(b:bat[:int,:int], h:int, t:int) :void
address BKCinsert_bun_int_int;
command insert(b:bat[:oid,:any_2], h:oid, t:any_2) :void
address BKCinsert_bun_oid_any;
command insert(b:bat[:void,:any_2], h:oid, t:any_2) :void
address BKCinsert_bun_oid_any;
command insert(b:bat[:void,:str], h:oid, t:str) :void
address BKCinsert_bun_oid_str;
command insert(b:bat[:oid,:str], h:oid, t:str) :void
address BKCinsert_bun_oid_str;

command insert(b:bat[:void,:any_1], v:any_1):void
address BKCinsert_void_bun
comment "Insert a value in a 'void' bat";

command insert(b:bat[:any_1,:bat], v:any_1, z:bat[:any_3,:any_4]):void
address BKCinsert_bun;
command insert(b:bat[:void,:bat], z:bat[:any_1,:any_2]):void
address BKCinsert_void_bun
comment "Insert a value in a 'void' bat";

command replace(b:bat[:any_1, :any_2], src:bat[:any_1,:any_2]) :void
address BKCreplace_bat
comment "Perform replace for all BUNs of the second BAT into the first.";

command replace(b:bat[:any_1, :any_2], h:any_1, t:any_2) :void
address BKCreplace_bun
comment "Replace the tail value of one BUN that has some head value.";
command replace(b:bat[:void, :any_2], h:oid, t:any_2) :void
address BKCreplace_bun;

# The SQL append/replace commands

command append( i:bat[:oid,:any_1], u:bat[:oid,:any_1]) :void
address BKCoid_bat_append_oid_bat_wrap
comment "append the content of u to i (renumbers u-oids' to unique numbers)";

command append(i:bat[:oid,:any_1], u:any_1):void
address BKCoid_bat_append_val_wrap
comment "append the value u to i";

command append( i:bat[:void,:any_1], u:bat[:void,:any_1] ) :void
address BKCbat_append_void_bat_wrap
comment "append the content of u to i";

command append( i:bat[:void,:any_1], u:any_1) :void
address BKCbat_append_val_wrap
comment "append the value u to i";

command append( i:bat[:void,:oid], u:bat[:oid,:void]) :void
address BKCbat_append_oid_bat_wrap
comment "append the content of u to i";

command append( i:bat[:void,:any_1], u:bat[:oid,:any_1]) :void
address BKCbat_append_oid_bat_wrap
comment "append the content of u to i";

command append(i:bat[:oid,:void], u:bat[:oid,:void]) :void
address BKCbat_append_oidvoid_bat_wrap
comment "Special case append for empty bats, works around impossible 
        void,void case";

command replace( o:bat[:void,:any_1], d:bat[:oid,:any_1]) :void
address BKCbat_replace_oid_bat_wrap
comment "inplace replace values on the given locations";

#end SQL enhancement
@-
Destroying a BAT should also involve removing references
maintained in the MAL program structure.
Therefore it is moved to the bbp module
@mal
#command destroy(b:bat[:any_1,:any_2]):void
#address BKCdestroy;
#command destroy(b:bat[:any_1,:any_2],now:bit):void
#address BKCdestroyImmediate;
#command destroy(s:str,immediately:bit):void 
#address BKCdestroy_bat
#comment "Schedule bat for removal upon session 

command delete(b:bat[:any_1, :any_2], h:any_1, t:any_2) :void
address BKCdelete_bun
comment "Delete one specific BUN.";

command delete(b:bat[:void, :any_2], h:oid, t:any_2) :void
address BKCdelete_bun;

command delete(b:bat[:any_1, :any_2], h:any_1) :void
address BKCdelete
comment "Delete all BUNs with a certain head value.";
command delete(b:bat[:void, :any_2], h:oid) :void
address BKCdelete;

command delete(b:bat[:any_1, :any_2]) :void
address BKCdelete_all
comment "Delete all BUNs in a BAT.";

#command delete(b:bat[:any_1, :any_2], src:bat[:any_1,:any]) :void
#address BKCdelete_bat
#comment "Delete from the first BAT all BUNs with a head value that 
        #is in the second.";

command delete(b:bat[:any_1, :any_2], src:bat[:any_1,:any_2]) :void
address BKCdelete_bat_bun
comment "Delete from the first BAT all BUNs with a corresponding BUN 
        in the second.";

command getAlpha(b:bat[:any_1,:any_2]) :bat[:any_1,:any_2] 
address BKCgetAlpha
comment "Obtain the list of BUNs added";
command getDelta(b:bat[:any_1,:any_2]) :bat[:any_1,:any_2] 
address BKCgetDelta
comment "Obtain the list of BUNs deleted";
@- BAT I/O, Persistency
The BAT Buffer Pool (BBP) manages all known BATs. It administers
their logical and physical names and a reference count. BATs can
either be @emph{persistent} or @emph{transient}. The BBP also manages
swapping on a BAT level:a BAT is either loaded entirely or not.
MAL variables of type @emph{bat} can either be loaded or not. When
the Monet server is started, all BATs are swapped out. If an unloaded
bat-variable is used as an operand in a command, it is automatically
loaded.  The BBP applies a simple but effective LRU based swapping
algorithm. BATs have a @emph{heat}, which drops over time, and is
increased when a BAT is used by some command.  If the size of the
allocated arena gets to be large, BATs may be swapped out.

Note, we should move old-fashioned mil operator definitions
into a separate module.

@mal
command setName ( b:bat[:any_1,:any_2] , s:str) :void
address BKCsetName
comment "Give a logical name to a BAT. ";

command getName ( b:bat[:any_1,:any_2]) :str 
address BKCgetBBPname
comment "Gives back the logical name of a BAT.";

command setRole( b:bat[:any_1,:any_2], h:str, t:str) :void
address BKCsetRole
comment "Give a logical name to the columns of a BAT.";

command setColumn( b:bat[:any_1,:any_2], t:str) :void
address BKCsetColumn
comment "Give a logical name to the tail column of a BAT.";
command setColumn( b:bat[:any_1,:any_2], h:str, t:str) :void
address BKCsetColumns
comment "Give both columns of a BAT a new name.";


command isTransient( b:bat[:any_1,:any_2]) :bit 
address BKCisTransient;
command setTransient( b:bat[:any_1,:any_2]) :void
address BKCsetTransient
comment "Make the BAT transient.  Returns 
	boolean which indicates if the
BAT administration has indeed changed.";

command isPersistent( b:bat[:any_1,:any_2]) :bit 
address BKCisPersistent;
command setPersistent( b:bat[:any_1,:any_2],f:bit) :void
address BKCpersists
comment "Backward compatibility";
command setPersistent( b:bat[:any_1,:any_2]) :void
address BKCsetPersistent
comment "Make the BAT persistent.  Returns boolean which indicates 
        if the BAT administration has indeed changed.";

command save(nme:bat[:any_1,:any_2]) :void
address BKCsave2;

command save(nme:str) :bit 
address BKCsave
comment "Save a BAT to storage, if it was loaded and dirty.  
        Returns whether IO was necessary.  Please realize that 
	calling this function violates the atomic commit protocol!!";


command load(name:str) :bat[:any_1,:any_2] 
address BKCload
comment "Load a particular BAT from disk";

command unload(name:str) :bit 
address BKCunload
comment "Swapout a BAT to disk. Transient BATs can also be swapped out.     
        Returns whether the unload indeed happened. ";

command isCached(b:bat[:any_1,:any_2]):bit 
address BKCisCached
comment "Bat is stored in main memory.";

command getHeat(b:bat[:any_1,:any_2]) :lng 
address BKCheat
comment "Return the current BBP heat (LRU stamp)";

command setCold(b:bat[:any_1,:any_1]) :void 
address BKCcoldBAT
comment "Makes a BAT very cold for the BBP. The chance of being choses 
        for swapout is big, afterwards.";
command setHot(b:bat[:any_1,:any_2]) :void 
address BKChotBAT
comment "Makes a BAT very hot for the BBP. The chance of being chosen for 
        swapout is small, afterwards.";

@- Heap Specific Commands
BATs are stored in memory in a number of Heap objects. A heap is nothing
more than a contiguous range of memory. Bats are saved to disk by just writing
away their image. This approach without pointer swizzling makes it possible
to either load an image into an alloced range of memory (STORE_MEM), or
memory-map (STORE_MMAP) an image into virtual memory.

The heap images of a BAT are stored in the @emph{$MONETHOME/dbfarm/$DB/bat/}
directory.  For each bat X, the following heaps are stored:
@table @code
@item[X.buns] 
    an array with all the fixed-size parts of all BUNs.
@item[X.hheap] 
    if the head column contains a variable sized atoms (e.g. str),
then the fixed-size part of a BUN contains an integer byte-offset into
the heap. String values themself are stored in this the X.hheap.
@item[X.theap] 
    similar to X.hheap, but for the tail column.
@item[X.desc] 
the BAT descriptor. Stores most of the properties of a BAT.
@end table

Each of these heaps can be compressed using the Unix @emph{compress}
utility forming a X.ext.Z file. Monet will automatically decompress it
upon load. Compressed heaps cannot be memory mapped.

@
For more technical information on BATs, we refer to the
@[<a href="http://www.cwi.nl/~monet/www/scw/gdk/470_pseudo.html">GDK</a>@
documentation.
@mal
command setMemoryMap(b:bat[:any_1,:any_2], buns_mode:int, hheap_mode:int, 
		theap_mode:int) :bit 
address BKCmmap
comment "For each individual heap, you can change the allocation mode 
        to either STORE_MEM or STORE_MMAP. Passing an int(nil) means:
        no change.  Changing a dirty STORE_MEM heap into STORE_MMAP, 
	will cause a BAT save (this has to happen before the heap can 
        be mapped into virtual memory). These modes are persistent. ";

command setMemoryMap(b:bat[:any_1,:any_2], mode:int):bit 
address BKCmmap2
comment "Alias for mmap(b,mode,mode,mode, mode,mode)";

command setMemoryAdvise(b:bat[:any_1,:any_2], buns_mode:int, hheap_mode:int, 
		theap_mode:int) :bit 
address BKCmadvise
comment "Modern Operating Systems allow users to influence the buffer 
        management policy of virtual memory. This is a crucial feature 
        for database systems, and eliminates the need to reimplement 
	the OS in a database buffer manager.  The supported flags are 
        BUF_NORMAL (the normal adaptive kernel algorithm),
	BUF_RANDOM (no page prefetching), 
	BUF_SEQUENTIAL (prefetch and swapout),
	BUF_WILLNEED (load everything with prefetch), 
	BUF_DONTNEED (swapout).
	These buffer management modes are not persistent. 
	Returns the BAT operated upon.";

command setMemoryAdvise(b:bat[:any_1,:any_2], mode:int):bit 
address BKCmadvise2
comment "alias for madvise(b,mode,mode,mode, mode,mode)";

command setHash(b:bat[:any_1,:any_2],prop:bit):bit 
address BKCsetHash;

@- Synced BATs
The binary model of Monet has important advantages when working in
main-memory. Tables are thin and very efficiently processed. The binary
model gives rise, however, to a larger-than-normal number of join
and semijoin operations. Relations are split up in vertical parts that
are very much related to each other. Then, for instance, multiple
similar semijoins occur on different vertical parts. By equipping the
kernel with knowledge about the correspondence of these parts, we
can greatly limit the amount of work to be done.

When two BATs effectively contain the same sequence of head elements,
we call them 'synced'. This is implemented by storing a very large
OID for each column. An update to the column destroys this OID.
By comparing two OIDs the Monet kernel can very quickly decide that
two columns are exactly equal. All BAT algebra operations propagate
these 'sync' OIDs with their own propagation rules.
@mal
command isSynced (b1:bat[:any_1,:any_2], b2:bat[:any_3,:any_4]) :bit 
address BKCisSynced
comment "Tests whether two BATs are synced or not. ";

@- Constants
The following constants have not been integrated in the code base
@mal
#Constants have been added to mal/const.mx prelude
#    STORE_MEM   := 0;     # load into GDKmalloced memory
#    STORE_MMAP  := 1;     # mmap() into virtual memory
#    STORE_COMPR := 2;     # currently not implemented this way
#    BUF_NORMAL    := 0;   # No further special treatment
#    BUF_RANDOM    := 1;   # Expect random page references
#    BUF_SEQUENTIAL:= 2;   # Expect sequential page references
#    BUF_WILLNEED  := 3;   # Will need these pages
#    BUF_DONTNEED  := 4;   # Don't need these pages

@{
@{
@* Implementation Code
In Version 5, we are not going to support recursive BATs.
It is up to the programmer to translate a bat into a
bat-name or batCacheid

@-
At this stage of the game, we should translate
the arguments of BATnew into types.
Beware, a void column type is turned into a virtual oid type immediately
by setting the sequential base.
@+ Minimum and Maximum
The routines @`BATmin_@5(b) and @`BATmax_@5(b) compute the minimum and
maximum value of the tail column of a BAT.
They are defined in the algebra.mx module.

Aggregate values are calculated just before they are requested by
the user. They are not maintained continuously, because we expect
them to be used sparsely.
@-
@= atomaggr
    if (s > 0 && !(BATtordered(b)&1)) {
        char* nil = BATatoms[t].atomNull;
        BUN p,q;
        int xx;
        BATloopFast(b, p, q, xx) {
            x = (ptr) BUNt@2(b, p);
            if (@3_CMP(x, nil, @4) == 0) {
                v = nil; break;
            }
            if (@3_@5(x, v, @4)) {
                v = x;
            }
        }
    }
    if (aggr) {
       memcpy(aggr, x=v, ATOMsize(t));
    } else {
       /* alloc new space and copy the atom into it */
       s = ATOMlen(t, v);
       memcpy(x = (ptr) GDKmalloc(s), v, s);
   }
@= voidaggr
    if (aggr) {
        *(oid *) aggr = *(oid *) (x=v);
    } else {
        /* alloc new space and copy the atom into it */
        memcpy(x = (ptr) GDKmalloc(sizeof(oid)), v, s);
    }
@= aggrmin
    v = (s == 0)?ATOMnilptr(t):BUNtail(b, BUNfirst(b));
    @:@5aggr(@1,@2,@3,@4,LT)@
@= aggrmax
    v = (s == 0)?ATOMnilptr(t):BUNtail(b, BUNlast(b)-BUNsize(b));
    @:@5aggr(@1,@2,@3,@4,GT)@

@h
#ifndef _BAT_H_
#define _BAT_H_

#include <gdk.h>
#include <mal.h>


mal_export char *BKCsetRole(int *r, int *bid, char **hname, char **tname);
mal_export char *BKCdestroyImmediate(signed char *r, int *bid);
mal_export char *BKCnewBATint(int *res, int *ht, int *tt, int *cap);
mal_export char *BKCgetAlpha(int *r, int *bid);
mal_export char *BKCgetDelta(int *r, int *bid);
mal_export char *BKCinsert_void_bun(int *r, int *bid, ptr t);
mal_export char *BKCinsert_bun(int *r, int *bid, ptr h, ptr t);
mal_export char * BKCinsert_bun_oid_any(int *r, int *bid, ptr h, ptr t);
mal_export char * BKCinsert_bun_int_int(int *r, int *bid, int *h, int *t);
mal_export char * BKCinsert_bun_oid_str(int *r, int *bid, ptr h, ptr t);
mal_export char *BKCdelete(int *r, int *bid, ptr h);
mal_export char *BKCdelete_bat(int *r, int *bid, int *bnid);
mal_export char *BKCdelete_bun(int *r, int *bid, ptr h, ptr t);
mal_export char *BKCdestroy(signed char *r, int *bid);
mal_export char *BKCbat_append_void_bat_wrap(int *r, int *bid, int *uid);
mal_export char * BKCbat_append_val_wrap(int *r, int *bid, ptr u);
mal_export str BKCnewBATlng(int *res, int *ht, int *tt);
mal_export str BKCnewBat(int *res, int *ht, int *tt);
mal_export str BKCreverse(int *ret, int *bid);
mal_export str BKCmirror(int *ret, int *bid);
mal_export str BKCconvert(int *ret, int *bid);
mal_export str BKCrevert(int *ret, int *bid);
mal_export str BKCsort(int *ret, int *bid);
mal_export str BKCsort_rev(int *ret, int *bid);
mal_export str BKCinsert_bat(int *r, int *bid, int *sid);
mal_export str BKCreplace_bun(int *r, int *bid, ptr h, ptr t);
mal_export str BKCreplace_bat(int *r, int *bid, int *sid);
mal_export str BKCdelete_all(int *r, int *bid);
mal_export str BKCdelete_bat_bun(int *r, int *bid, int *sid);
mal_export str BKCdelete_bat(int *r, int *bid, int *sid);
mal_export str BKCdestroy_bat(bit *r, str *input);
mal_export str BKCbat_append_oid_bat_wrap(int *r, int *bid, int *uid);
mal_export str BKCbat_append_oidvoid_bat_wrap(int *r, int *bid, int *uid);
mal_export str BKCoid_bat_append_oid_bat_wrap(int *res, int *bid, int *uid);
mal_export str BKCoid_bat_append_val_wrap(int *r, int *bid, ptr u);
mal_export str BKCbat_replace_oid_bat_wrap(int *r, int *bod, int *did);
mal_export str BKCgetCapacity(lng *res, int *bid);
mal_export str BKCgetHeadType(str *res, int *bid);
mal_export str BKCgetTailType(str *res, int *bid);
mal_export str BKCgetRole(str *res, int *bid);
mal_export str BKCsetkey(int *res, int *bid, bit *param);
mal_export str BKCsetSet(int *res, int *bid, bit *param);
mal_export str BKCisaSet(int *res, int *bid);
mal_export str BKCsetSorted(bit *res, int *bid);
mal_export str BKCisSorted(bit *res, int *bid);
mal_export str BKCisSortedReverse(bit *res, int *bid);
mal_export str BKCgetKey(bit *ret, int *bid);
mal_export str BKCpersists(int *r, int *bid, bit *flg);
mal_export str BKCsetPersistent(int *r, int *bid);
mal_export str BKCisPersistent(bit *res, int *bid);
mal_export str BKCsetTransient(int *r, int *bid);
mal_export str BKCisTransient(bit *res, int *bid);
mal_export str BKCaccess(int *res, int *bid, int *m);
mal_export str BKCsetAccess(int *res, int *bid, str *param);
mal_export str BKCgetAccess(str *res, int *bid);
mal_export str BKCinfo(int *retval, int *bid);
mal_export str BKCbatsize(int *tot, int *bid);
mal_export str BKCbatsize_str(int *tot, str batname);
mal_export str BKCisSynced(bit *ret, int *bid1, int *bid2);
mal_export str BKCsetColumn(int *r, int *bid, str *tname);
mal_export str BKCsetColumns(int *r, int *bid, str *hname, str *tname);
mal_export str BKCsetName(int *r, int *bid, str *s);
mal_export str BKCgetBBPname(str *ret, int *bid);
mal_export str BKCunload(bit *res, str *input);
mal_export str BKCisCached(int *res, int *bid);
mal_export str BKCload(int *res, str *input);
mal_export str BKChot(int *res, str *input);
mal_export str BKCcold(int *res, str *input);
mal_export str BKCcoldBAT(int *res, int *bid);
mal_export str BKCheat(int *res, str *input);
mal_export str BKChotBAT(int *res, int *bid);
mal_export str BKCsave(bit *res, str *input);
mal_export str BKCsave2(int *r, int *bid);
mal_export str BKCmmap(int *res, int *bid, int *bns, int *hhp, int *thp);
mal_export str BKCmmap2(int *res, int *bid, int *bns);
mal_export str BKCmadvise(int *res, int *bid, int *bns, int *hhp, int *thp);
mal_export str BKCmadvise2(int *res, int *bid, int *mode);
mal_export str BKCaccbuild(int *ret, int *bid, str *acc, ptr *param);
mal_export str BKCaccbuild_std(int *ret, int *bid, int *acc);
mal_export str BKCsetHash(bit *ret, int *bid, bit *prop);
mal_export str BKCsetSequenceBase(int *r, int *bid, oid *o);
mal_export str BKCsetSequenceBaseNil(int *r, int *bid, oid *o);
mal_export str BKCgetSequenceBase(oid *r, int *bid);

mal_export ssize_t void_replace_bat(BAT *b, BAT *u);
#endif /*_BAT_H_*/

@c
#include "bat.h"
#include <stream.h>
#include "mal_exception.h"
@-
@= batconvert
	(BAT@2type(@1) == TYPE_bat)?(BUN)&((BAT*)@2)->batCacheid:(BUN)@2

@+ Information Functions
@c

int
CMDnew_lng(BAT **ret, int *ht, int *tt, lng *cap)
{
	if (*cap < 0)
		*cap = 0;
	*ret = BATnew(*ht, *tt, (size_t) * cap);
	return (*ret) ? GDK_SUCCEED : GDK_FAIL;
}

int
CMDnew(BAT **ret, int *ht, int *tt, int *cap)
{
	if (*cap < 0)
		*cap = 0;
	*ret = BATnew(*ht, *tt, (size_t) * cap);
	if (*ret)
		(*ret)->batDirty |= 2;
	return (*ret) ? GDK_SUCCEED : GDK_FAIL;
}

int
CMDnew_default(BAT **ret, int *ht, int *tt)
{
	int default_size = 0;

	return CMDnew(ret, ht, tt, &default_size);
}

int
CMDreverse(BAT **ret, BAT *b)
{
	*ret = BATmirror(b);
	BBPfix(b->batCacheid);
	return GDK_SUCCEED;
}

int
CMDmirror(BAT **ret, BAT *b)
{
	BAT *v = *ret = VIEWcombine(b);

	if (b->batRestricted == BAT_WRITE) {
		*ret = BATrcopy(v);
		BBPreclaim(v);
	}
	return (*ret) ? GDK_SUCCEED : GDK_FAIL;
}

int
CMDconvert(BAT **ret, BAT *b)
{
	if (BATconvert(*ret = b, CONV_HTON) == NULL)
		BBPfix(b->batCacheid);
	return GDK_SUCCEED;
}

int
CMDrevert(BAT **ret, BAT *b)
{
	if (BATrevert(*ret = b) == NULL)
		return GDK_FAIL;
	BBPfix(b->batCacheid);
	return GDK_SUCCEED;
}

int
CMDorder(BAT **ret, BAT *b)
{
	if (BATorder(*ret = b) == NULL)
		return GDK_FAIL;
	BBPfix(b->batCacheid);
	return GDK_SUCCEED;
}

int
CMDorder_rev(BAT **ret, BAT *b)
{
	if (BATorder_rev(*ret = b) == NULL)
		return GDK_FAIL;
	BBPfix(b->batCacheid);
	return GDK_SUCCEED;
}

int
CMDinsert_bun(BAT **r, BAT *b, ptr h, ptr t)
{
	if (BUNins(*r = b, @:batconvert(b,h)@, @:batconvert(b,t)@) == NULL)
		return GDK_FAIL;
	BBPfix(b->batCacheid);
	return GDK_SUCCEED;
}

int
CMDinsert_bat(BAT **r, BAT *b, BAT *s)
{
	if (BATins(*r = b, s) == NULL)
		return GDK_FAIL;
	BBPfix(b->batCacheid);
	return GDK_SUCCEED;
}

int
CMDreplace_bun(BAT **r, BAT *b, ptr h, ptr t)
{
	if (BUNreplace(*r = b, @:batconvert(b,h)@, @:batconvert(b,t)@) == NULL)
		return GDK_FAIL;
	BBPfix(b->batCacheid);
	return GDK_SUCCEED;
}

int
CMDreplace_bat(BAT **r, BAT *b, BAT *s)
{
	if (BATreplace(*r = b, s) == NULL)
		return GDK_FAIL;
	BBPfix(b->batCacheid);
	return GDK_SUCCEED;
}

int
CMDdelete_bun(BAT **r, BAT *b, ptr h, ptr t)
{
	if (BUNdel(*r = b, h, t) == NULL)
		return GDK_FAIL;
	BBPfix(b->batCacheid);
	return GDK_SUCCEED;
}

int
CMDdelete_head(BAT **r, BAT *b, ptr h)
{
	if (BUNdelHead(*r = b, @:batconvert(b,h)@) == NULL)
		return GDK_FAIL;
	BBPfix(b->batCacheid);
	return GDK_SUCCEED;
}

int
CMDdelete_all(BAT **r, BAT *b)
{
	if (BATclear(*r = b) == NULL)
		return GDK_FAIL;
	BBPfix(b->batCacheid);
	return GDK_SUCCEED;
}

int
CMDdelete_bat_bun(BAT **r, BAT *b, BAT *s)
{
	if (BATdel(*r = b, s) == NULL)
		return GDK_FAIL;
	BBPfix(b->batCacheid);
	return GDK_SUCCEED;
}

int
CMDdelete_bat_head(BAT **r, BAT *b, BAT *s)
{
	if (BATdelHead(*r = b, s) == NULL)
		return GDK_FAIL;
	BBPfix(b->batCacheid);
	return GDK_SUCCEED;
}


@-
The next collection of operators fill a hole in the MonetDB kernel libraries.
It provide handy operations on void-BATs.
@c
size_t
void_append_bat(BAT *b, BAT *u)
{
	size_t sz = BUNsize(u);
	size_t old = u->hseqbase;
	size_t sbase = b->hseqbase + BATcount(b);

	BATseqbase(u, sbase);
	BATins(b, u);
	BATseqbase(u, old);
	return sz;
}

size_t
void_insert_bat(BAT *b, BAT *u)
{
	size_t nr = 0;
	BUN r, s;
	oid nil = oid_nil;

	BATloop(u, r, s) {
		BUNins(b, (ptr) &nil, BUNtail(u, r));
		nr++;
	}
	return nr;
}

int
void_inplace(BAT *b, oid id, ptr val)
{
	int res = GDK_SUCCEED;
	BUN p = NULL;
	BUN oldInserted = b->batInserted;

	assert(b->htype == TYPE_void);
	assert(b->hseqbase != oid_nil);
	assert(BATcount(b) > (id -b->hseqbase));

	b->batInserted = NULL;
	BUNfndVOID(p, b, (ptr) &id);

	assert(p >= b->batInserted);	/* we don't want delete/ins */
	assert(!b->batRestricted);
	if (!BUNinplace(b, p, (ptr) &id, val))
		 res = GDK_FAIL;

	b->batInserted = oldInserted;
	return res;
}

int
bat_inplace(BAT **res, BAT *b, oid *id, ptr val )
{
	int ret = void_inplace(b,*id,val);
	*res = b;
	BBPfix(b->batCacheid);
	return ret;
}
 
ssize_t
void_replace_bat(BAT *b, BAT *u)
{
	size_t nr = 0;
	BUN r, s;

	BATloop(u, r, s) {
		oid updid = *(oid *) BUNhead(u, r);
		ptr val = BUNtail(u, r);

		if (void_inplace(b, updid, val) == GDK_FAIL)
			return -1;
		nr++;
	}
	return nr;
}

int
bat_append_void_bat_wrap(BAT **res, BAT *i, BAT *u)
{
	*res = i;
	void_append_bat(i, u);
	BBPfix(i->batCacheid);
	return GDK_SUCCEED;
}

int
bat_append_oid_bat_wrap(BAT **res, BAT *i, BAT *u)
{
	*res = i;
	void_insert_bat(i, u);
	BBPfix(i->batCacheid);
	return GDK_SUCCEED;
}

int
bat_append_oidvoid_bat_wrap(BAT **res, BAT *i, BAT *u)
{
	/*(void)u; fake usage to fool compilers in case assertions are disabled
	   assert (!BATcount(i));
	 */
	*res = i;
	void_insert_bat(i, u);
	BBPfix(i->batCacheid);
	return GDK_SUCCEED;
}

static oid
oid_max(BAT *i)
{
	oid o = 0;

	if (BATcount(i))
		o = *(oid *) BUNhead(i, BUNlast(i) - BUNsize(i));
	if (!BAThordered(i)) {
		BUN r, s;
		int d;

		BATloopFast(i, r, s, d) {
			oid v = *(oid *) BUNhead(i, r);

			if (v > o)
				o = v;
		}
	}
	return o;
}

int
oid_bat_append_oid_bat_wrap(BAT **res, BAT *i, BAT *u)
{
	BUN r, s;
	oid o;

	assert(i->htype == TYPE_oid && (BATcount(u) == 0 || u->htype == TYPE_oid || u->htype == TYPE_void));

	o = oid_max(i);
	o++;
	BATloop(u, r, s) {
		oid h = *(oid *) BUNhead(u, r) + o;

		BUNins(i, &h, BUNtail(u, r));
	}
	*res = i;
	BBPfix(i->batCacheid);
	return GDK_SUCCEED;
}

int
oid_bat_append_val_wrap(BAT **res, BAT *i, ptr t)
{
	oid o;

	assert(i->htype == TYPE_oid);
	o = oid_max(i);
	o++;
	*res = i;
	BUNins(i, (ptr) &o, @:batconvert(i,t)@
	    );
	BBPfix(i->batCacheid);
	return GDK_SUCCEED;
}


int
bat_append_val_wrap(BAT **res, BAT *i, ptr t)
{
	oid h = i->hseqbase + BATcount(i);

	*res = i;
	BUNins(i, (ptr) &h, @:batconvert(i,t)@
	    );
	BBPfix(i->batCacheid);
	return GDK_SUCCEED;
}

int
bat_replace_oid_bat_wrap(BAT **res, BAT *o, BAT *d)
{
	*res = o;
	if (void_replace_bat(o, d) < 0)
		return GDK_FAIL;
	BBPfix(o->batCacheid);
	return GDK_SUCCEED;
}


/* descriptors may be unloaded by BBPtrim, so secure them with a hotfix while in use */
static BAT *
lock_desc(bat bid)
{
	BBPfix(bid);
	return (BAT *) BBPgetdesc(bid);
}

static void
unlock_desc(bat bid)
{
	BBPunfix(bid);
}

int
CMDcapacity(lng *res, int *bid)
{
	if (BBPcheck((bat) *bid, "CMDcapacity")) {
		BAT *b = lock_desc((bat) *bid);

		if (b == NULL) {
			*res = lng_nil;
		} else {
			*res = (lng) BATcapacity(b);
		}
		unlock_desc(*bid);
	}
	return GDK_SUCCEED;
}

int
CMDhead(str *res, int *bid)
{
	if (BBPcheck((bat) *bid, "CMDhead")) {
		str ret = str_nil;
		BAT *b = lock_desc((bat) *bid);

		if (b) {
			ret = *bid > 0 ? ATOMname(b->htype) : ATOMname(b->ttype);
		}
		*res = GDKstrdup(ret);
		unlock_desc(*bid);
	} else {
		*res = GDKstrdup(str_nil);
	}
	return GDK_SUCCEED;
}

int
CMDtail(str *res, int *bid)
{
	if (BBPcheck((bat) *bid, "CMDtail")) {
		str ret = str_nil;
		BAT *b = lock_desc((bat) *bid);

		if (b) {
			ret = *bid > 0 ? ATOMname(b->ttype) : ATOMname(b->htype);
		}
		*res = GDKstrdup(ret);
		unlock_desc(*bid);
	} else {
		*res = GDKstrdup(str_nil);
	}
	return GDK_SUCCEED;
}

int
CMDsetkey(BAT **result, BAT *input, bit *param)
{
	BATkey(*result = input, *param ? BOUND2BTRUE : FALSE);
	BBPfix(input->batCacheid);
	return GDK_SUCCEED;
}

int
CMDsetset(BAT **result, BAT *input, bit *param)
{
	BATset(*result = input, *param ? BOUND2BTRUE : FALSE);
	BBPfix(input->batCacheid);
	return GDK_SUCCEED;
}

int
CMDordered(bit *result, BAT *input)
{
	*result = BATordered(input) ? 1 : 0;
	return GDK_SUCCEED;
}

int
CMDordered_rev(bit *result, BAT *input)
{
	*result = BATordered_rev(input) ? 1 : 0;
	return GDK_SUCCEED;
}

int
CMDgetkey(bit *ret, BAT *b)
{
	/* we must take care of the special case of a nil column (TYPE_void,seqbase=nil)
	 * such nil columns never set hkey (and BUNins will never invalidate it if set) yet
	 * a nil column of a BAT with <= 1 entries does not contain doubles => return TRUE.
	 */
	if (BATcount(b) <= 1) {
		*ret = TRUE;
	} else {
		if (!b->hkey) {
			BATpropcheck(b, BATPROPS_ALL);
		}
		*ret = b->hkey ? TRUE : FALSE;
	}
	return GDK_SUCCEED;
}

int
CMDpersists(BAT **r, BAT *input, bit *param)
{
	BATmode(*r = input, (*param == TRUE) ? PERSISTENT : (*param == FALSE) ? TRANSIENT : SESSION);
	BBPfix(input->batCacheid);
	return GDK_SUCCEED;
}

int
CMDdestroy(bit *res, str input )
{
	int bid = BBPindex(input);

	*res = FALSE;
	if (bid) {
		BBPfix(bid);
		if (BBPindex(input) == bid) {
			BAT *b = (BAT*)BBPgetdesc(ABS(bid));

			BATmode(b, TRANSIENT);
			*res = TRUE;
		}
		BBPunfix(bid);
	}
	return GDK_SUCCEED;
}

int
CMDsetaccess(BAT **r, BAT *input, int *param)
{
	bat oldCacheid = input->batCacheid;

	*r = BATsetaccess(input, *param);
	if ((*r)->batCacheid == oldCacheid) {
		BBPfix(oldCacheid);
	}
	return GDK_SUCCEED;
}

int
CMDgetaccess(int *r, BAT *input)
{
	*r = BATgetaccess(input);
	return GDK_SUCCEED;
}

static char *
pre(str s1, str s2)
{
	static char buf[64];

	snprintf(buf, 64, "%s%s", s1, s2);
	return buf;
}
static char *
local_itoa(ssize_t i)
{
	static char buf[32];

	snprintf(buf, 32, SSZFMT, i);
	return buf;
}
static char *
local_utoa(size_t i)
{
	static char buf[32];

	snprintf(buf, 32, SZFMT, i);
	return buf;
}

#define COLLISION 6

void
HASHinfo(BAT *bn, Hash *h, str s)
{
	hash_t i;
	hash_t j;
	size_t cnt[COLLISION + 2];
	size_t largebuckets = 0;
	size_t largetot = 0;
	char buf[32];

	BUNins(bn, pre(s, "type"), ATOMname(h->type));
	BUNins(bn, pre(s, "mask"), local_utoa(h->mask));
	BUNins(bn, pre(s, "lim"), local_utoa(h->lim));

	for (i = 0; i <= COLLISION + 1; i++) {
		cnt[i] = 0;
	}
	for (i = 0; i <= h->mask; i++) {
		if (h->hash[i] == HASH_MAX) {
			cnt[0]++;
		} else if (h->hash[i] > h->lim) {
			GDKerror("HASHinfo: hash consistency problem %d\n", i);
		} else if ((j = HASHlist(h, h->hash[i])) <= COLLISION + 1) {
			cnt[j]++;
		} else {
			largebuckets++;
			largetot += j;
		}
	}

	for (i = 0; i <= COLLISION + 1; i++)
		if (cnt[i]) {
			BUNins(bn, pre(s, local_utoa(i)), local_utoa(cnt[i]));
		}
	snprintf(buf, 32, SZFMT " on " SZFMT, largetot, largebuckets);
	BUNins(bn, pre(s, "collision"), buf);
}

static void
infoHeap(BAT *bn, Heap *hp, str nme)
{
	char buf[1024], *p = buf;

	if (!hp)
		return;
	while (*nme)
		*p++ = *nme++;
	strcpy(p, "free");
	BUNins(bn, buf, local_utoa(hp->free));
	strcpy(p, "size");
	BUNins(bn, buf, local_utoa(hp->size));
	strcpy(p, "maxsize");
	BUNins(bn, buf, local_utoa(hp->maxsize));
	strcpy(p, "storage");
	BUNins(bn, buf, (hp->base == NULL) ? "absent" : (hp->storage == STORE_MMAP) ? (hp->filename ? "memory mapped" : "anonymous vm") : (hp->storage == STORE_PRIV) ? "private map" : "malloced");
	strcpy(p, "filename");
	BUNins(bn, buf, hp->filename ? hp->filename : "no file");
}

static char *
oidtostr(oid i)
{
	int len = 32;
	static char bf[32];
	char *p = bf;

	(void) OIDtoStr(&p, &len, &i);
	return bf;
}

int
CMDinfo(BAT **retval, BAT *b)
{
	BAT *bn;
	char mode[1024], *access;

	if (!(bn = BATnew(TYPE_str, TYPE_str, 128)))
		return GDK_FAIL;
	*retval = bn;

	if (b->batPersistence == PERSISTENT) {
		strcpy(mode, "persistent");
	} else if (b->batPersistence == SESSION) {
		strcpy(mode, "session");
	} else if (b->batPersistence == TRANSIENT) {
		strcpy(mode, "transient");
	} else {
		strcpy(mode, "unknown");
	}

	switch (b->batRestricted) {
	case BAT_READ:
		access = "read-only";
		break;
	case BAT_WRITE:
		access = "updatable";
		break;
	case BAT_APPEND:
		access = "append-only";
		break;
	default:
		access = "unknown";
	}

	BUNins(bn, "version", local_itoa(b->GDKversion));
	BUNins(bn, "batId", BATgetId(b));
	BUNins(bn, "batCacheid", local_itoa(b->batCacheid));
	BUNins(bn, "batParentid", local_itoa(b->batParentid));
	BUNins(bn, "batSharecnt", local_itoa(b->batSharecnt));
	BUNins(bn, "head", ATOMname(b->htype));
	BUNins(bn, "tail", ATOMname(b->ttype));
	BUNins(bn, "batPersistence", mode);
	BUNins(bn, "batRestricted", access);
	BUNins(bn, "batRefcnt", local_itoa(BBP_refs(b->batCacheid)));
	BUNins(bn, "batLRefcnt", local_itoa(BBP_lrefs(b->batCacheid)));
	BUNins(bn, "batDirty", BATdirty(b) ? "dirty" : "clean");
	BUNins(bn, "batSet", local_itoa(b->batSet));
	BUNins(bn, "void_tid", local_itoa(b->void_tid));
	BUNins(bn, "void_cnt", local_itoa(b->void_cnt));

	BUNins(bn, "hsorted", local_itoa(BAThordered(b)));
	BUNins(bn, "hident", b->hident);
	BUNins(bn, "hdense", local_itoa(BAThdense(b)));
	BUNins(bn, "hseqbase", oidtostr(b->hseqbase));
	BUNins(bn, "hkey", local_itoa(b->hkey));
	BUNins(bn, "hloc", local_itoa(b->hloc));
	BUNins(bn, "hvarsized", local_itoa(b->hvarsized));
	BUNins(bn, "halign", local_utoa(b->halign));
	BUNins(bn, "hnosorted", local_utoa(b->H->nosorted));
	BUNins(bn, "hnosorted_rev", local_utoa(b->H->nosorted_rev));
	BUNins(bn, "hnodense", local_utoa(b->H->nodense));
	BUNins(bn, "hnokey[0]", local_utoa(b->H->nokey[0]));
	BUNins(bn, "hnokey[1]", local_utoa(b->H->nokey[1]));

	BUNins(bn, "tident", b->tident);
	BUNins(bn, "tdense", local_itoa(BATtdense(b)));
	BUNins(bn, "tseqbase", oidtostr(b->tseqbase));
	BUNins(bn, "tsorted", local_itoa(BATtordered(b)));
	BUNins(bn, "tkey", local_itoa(b->tkey));
	BUNins(bn, "tloc", local_itoa(b->tloc));
	BUNins(bn, "tvarsized", local_itoa(b->tvarsized));
	BUNins(bn, "talign", local_utoa(b->talign));
	BUNins(bn, "tnosorted", local_utoa(b->T->nosorted));
	BUNins(bn, "tnosorted_rev", local_utoa(b->T->nosorted_rev));
	BUNins(bn, "tnodense", local_utoa(b->T->nodense));
	BUNins(bn, "tnokey[0]", local_utoa(b->T->nokey[0]));
	BUNins(bn, "tnokey[1]", local_utoa(b->T->nokey[1]));

	BUNins(bn, "batInserted", local_utoa(BUNindex(b, b->batInserted)));
	BUNins(bn, "batDeleted", local_utoa(BUNindex(b, b->batDeleted)));
	BUNins(bn, "batFirst", local_utoa(BUNindex(b, b->batFirst)));
	BUNins(bn, "top", local_utoa(BUNindex(b, (BUN) ((char *) Bunbase(b) + b->batBuns->free))));
	BUNins(bn, "batStamp", local_itoa(b->batStamp));
	BUNins(bn, "lastUsed", local_itoa(BBP_lastused(b->batCacheid)));
	BUNins(bn, "curStamp", local_itoa(BBPcurstamp()));
	BUNins(bn, "batCopiedtodisk", local_itoa(b->batCopiedtodisk));
	BUNins(bn, "batDirtydesc", b->batDirtydesc ? "dirty" : "clean");

	BUNins(bn, "batDirtybuns", b->batDirtybuns ? "dirty" : "clean");
	infoHeap(bn, b->batBuns, "batBuns.");

	BUNins(bn, "hheapdirty", b->hheapdirty ? "dirty" : "clean");
	infoHeap(bn, b->hheap, "hheap.");

	BUNins(bn, "theapdirty", b->theapdirty ? "dirty" : "clean");
	infoHeap(bn, b->theap, "theap.");

	/* dump index information */
	if (b->hhash) {
		HASHinfo(bn, b->hhash, "hhash->");
	}
	if (b->thash) {
		HASHinfo(bn, b->thash, "thash->");
	}
	return GDK_SUCCEED;
}

#define ROUND_UP(x,y) ((y)*(((x)+(y)-1)/(y)))

int
CMDbatsize(lng *tot, BAT *b)
{
	size_t blksize = MT_pagesize();
	size_t size = ROUND_UP(sizeof(BATstore), blksize);

	if (!VIEWparent(b)) {
		size_t cnt = BATcapacity(b);

		size += ROUND_UP(b->batBuns->size, blksize);
		if (b->hheap)
			size += ROUND_UP(b->hheap->size, blksize);
		if (b->theap)
			size += ROUND_UP(b->theap->size, blksize);
		if (b->hhash)
			size += ROUND_UP(sizeof(hash_t) * cnt, blksize);
		if (b->thash)
			size += ROUND_UP(sizeof(hash_t) * cnt, blksize);
	}
	*tot = size;
	return GDK_SUCCEED;
}

int
CMDbatsize_str(lng *tot, str batname)
{
	bat bid = BBPindex(batname);
	BAT *b = bid ? (BAT *) BBPgetdesc(bid) : NULL;

	if (b == NULL) {
		GDKerror("CMDbatsize_str: %s no such bat.\n", batname);
		return GDK_FAIL;
	}
	return CMDbatsize(tot, b);
}

@+ Synced BATs
@c
int
CMDsynced(bit *ret, BAT *b1, BAT *b2)
{
	*ret = ALIGNsynced(b1, b2) ? 1 : 0;
	return GDK_SUCCEED;
}

@+ BBP Management, IO
@c
int
CMDroles(BAT **r, BAT *b, str hname, str tname)
{
	BATroles(*r = b, hname, tname);
	BBPfix(b->batCacheid);
	return GDK_SUCCEED;
}

int
CMDcol_name(BAT **r, BAT *b, str tname)
{
	BATcol_name(*r = b, tname);
	BBPfix(b->batCacheid);
	return GDK_SUCCEED;
}

int
CMDrename(bit *retval, BAT *b, str s)
{
	int ret;
	int c;
	char *t = s;

	for ( ; (c = *t) != 0; t++) {
		if (c != '_' && !GDKisalnum(c)) {
			GDKerror("CMDrename: identifier expected: %s\n", s);
			return GDK_FAIL;
		}
	}

	ret = BATname(b, s);
	*retval = FALSE;
	if (ret == 1) {
		GDKerror("CMDrename: identifier expected: %s\n", s);
		return GDK_FAIL;
	} else if (ret == BBPRENAME_ILLEGAL) {
		GDKerror("CMDrename: illegal temporary name: '%s'\n", s);
		return GDK_FAIL;
	} else if (ret == BBPRENAME_LONG) {
		GDKerror("CMDrename: name too long: '%s'\n", s);
		return GDK_FAIL;
	} else if (ret != BBPRENAME_ALREADY) {
		*retval = TRUE;
	}
	return GDK_SUCCEED;
}

int
CMDname(str *retval, BAT *b)
{
	*retval = GDKstrdup(BBPname(b->batCacheid));
	return GDK_SUCCEED;
}

int
CMDunload(bit *res, str input)
{
	bat bid = ABS(BBPindex(input));

	*res = FALSE;
	if (bid > 0) {
		BAT *b;

		BBPfix(bid);
		b = BBP_cache(bid);
		if (b) {
			if (b->batPersistence == SESSION)
				BATmode(b, TRANSIENT);
			BBPcold(bid);	/* will trigger unload of also persistent bats */
		}
		*res = BBPunfix(bid) == 0;
	}
	return GDK_SUCCEED;
}

int
CMDhot(str input)
{
	BBPhot(BBPindex(input));
	return GDK_SUCCEED;
}

int
CMDcold(str input)
{
	BBPcold(BBPindex(input));
	return GDK_SUCCEED;
}

int
CMDheat(int *res, str input)
{
	int bid = BBPindex(input);

	if (bid) {
		*res = BBP_lastused(bid) & 0x7fffffff;
	}
	return GDK_SUCCEED;
}

int
CMDsave(bit *res, str input)
{
	bat bid = BBPindex(input);
	BAT *b;

	*res = FALSE;
	if (bid) {
		BBPfix(bid);
		b = BBP_cache(bid);
		if (b && BATdirty(b)) {
			if (BBPsave(b) == 0)
				*res = TRUE;
		}
		BBPunfix(bid);
	}
	return GDK_SUCCEED;
}


@= change_heap
{
	if (@2) {
		int mode = (@2)->storage;

		if (mode == STORE_MMAP && (@2)->filename == NULL)
			mode = STORE_MEM;
		if (mode == STORE_PRIV)
			mode = STORE_MMAP;
		if (*@1 == int_nil || *@1 == mode) {
			*@1 = -1;
		}
	}
}
@c
int
CMDmmap(BAT **r, BAT *b, int *bns, int *hhp, int *thp)
{
	@:change_heap(bns,b->batBuns)@
	@:change_heap(hhp,b->hheap)@
	@:change_heap(thp,b->theap)@
	if (BATmmap(*r = b, *bns, *hhp, *thp) == 0) {
		BBPfix(b->batCacheid);
		return GDK_SUCCEED;
	}
	return GDK_FAIL;
}

int
CMDmadvise(BAT **r, BAT *b, int *bns, int *hhp, int *thp)
{
	BBPfix(b->batCacheid);
	return BATmadvise(*r = b, (*bns == int_nil) ? -1 : *bns, (*hhp == int_nil) ? -1 : *hhp, (*thp == int_nil) ? -1 : *thp) ? GDK_FAIL : GDK_SUCCEED;
}

/* ITERATIONS ARE DEFINED ELSEWHERE */

int
CMDget_seqbase(oid *o, BAT *b)
{
	*o = b->hseqbase;
	return GDK_SUCCEED;
}

int
CMDset_seqbase(BAT **r, BAT *b, oid *o)
{
	BATseqbase(*r = b, *o);
	BBPfix(b->batCacheid);
	return GDK_SUCCEED;
}

@- Wrapping
The remainder contains the wrapper code over the version 4
@+ Information Functions
In most cases we pass a BAT identifier, which should be unified
with a BAT descriptor. Upon failure we can simply abort the function.

@c

char *
BKCnewBATint(int *res, int *ht, int *tt, int *cap)
{
	BAT *b;

	if (CMDnew(&b, ht, tt, cap) == GDK_SUCCEED) {
		BBPincref(*res = b->batCacheid, TRUE);
		BBPunfix(*res);
		return MAL_SUCCEED;
	}
	return throwMessage("bat.new", "GDKerror in BAT construction");
}

str
BKCnewBATlng(int *res, int *ht, int *tt)
{
	BAT *b;
	lng cap = 0;

	if (CMDnew_lng(&b, ht, tt, &cap) == GDK_SUCCEED) {
		BBPincref(*res = b->batCacheid, TRUE);
		BBPunfix(*res);
		return MAL_SUCCEED;
	}
	return throwMessage("bat.new", "GDKerror in BAT construction");

}

str
BKCnewBat(int *res, int *ht, int *tt)
{
	int cap = 0;

	return BKCnewBATint(res, ht, tt, &cap);
}

str
BKCreverse(int *ret, int *bid)
{
	BAT *b, *bn = NULL;

	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("bat.reverse", "Cannot access descriptor");
	}

	CMDreverse(&bn, b);
	BBPunfix(b->batCacheid);
	if (bn) {
		*ret = bn->batCacheid;
		BBPincref(bn->batCacheid, TRUE);
		BBPunfix(bn->batCacheid);
		return MAL_SUCCEED;
	}
	return throwMessage("bat.reverse", "GDKerror");
}

str
BKCmirror(int *ret, int *bid)
{
	BAT *b, *bn = NULL;

	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("bat.mirror", "Cannot access descriptor");
	}
	if (CMDmirror(&bn, b) == GDK_SUCCEED) {
		BBPincref(*ret = bn->batCacheid, TRUE);
		BBPunfix(*ret);
		BBPunfix(b->batCacheid);
		return MAL_SUCCEED;
	}
	*ret = 0;
	BBPunfix(b->batCacheid);
	return throwMessage("bat.mirror", "GDKerror");
}

str
BKCconvert(int *ret, int *bid)
{
	BAT *b, *bn = NULL;

	(void) ret;
	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("bat.convert", "Cannot access descriptor");
	}
	CMDconvert(&bn, b);
	BBPincref(bn->batCacheid, TRUE);
	BBPunfix(bn->batCacheid);
	BBPunfix(b->batCacheid);
	return MAL_SUCCEED;
}

str
BKCrevert(int *ret, int *bid)
{
	BAT *b, *bn = NULL;

	(void) ret;
	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("bat.revert", "Cannot access descriptor");
	}
	if (CMDrevert(&bn, b) == GDK_SUCCEED) {
		BBPincref(bn->batCacheid, TRUE);
		BBPunfix(bn->batCacheid);
		BBPunfix(b->batCacheid);
		return MAL_SUCCEED;
	}
	BBPunfix(b->batCacheid);
	return throwMessage("bat.revert", "GDKerror");
}

str
BKCsort(int *ret, int *bid)
{
	BAT *b, *bn = NULL;

	(void) ret;
	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("bat.order", "Cannot access descriptor");
	}
	if (CMDorder(&bn, b) == GDK_SUCCEED) {
		BBPunfix(b->batCacheid);
		BBPincref(bn->batCacheid, TRUE);
		BBPunfix(bn->batCacheid);
		return MAL_SUCCEED;
	}
	BBPunfix(b->batCacheid);
	return throwMessage("bat.order", "GDKerror");
}

str
BKCsort_rev(int *ret, int *bid)
{
	BAT *b, *bn = NULL;

	(void) ret;
	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("bat.order_rev", "Cannot access descriptor");
	}
	if (CMDorder_rev(&bn, b) == GDK_SUCCEED) {
		BBPincref(bn->batCacheid, TRUE);
		BBPunfix(bn->batCacheid);
		BBPunfix(b->batCacheid);
		return MAL_SUCCEED;
	}
	BBPunfix(b->batCacheid);
	return throwMessage("bat.order", "GDKerror");
}

@-
Insertions into the BAT may involve void types (=no storage required)
These cases should actually be captured during BUNins, because they
may emerge internally as well.
@= void_insertbun
if (b->@1type == TYPE_void && *(oid*) @1 != oid_nil &&
    *(oid*) @1 != (b->@1seqbase + BUNgetpos(b, BUNlast(b))))
{
printf("val %d seqbase %d pos %d\n", *(oid*)@1,
	b->@1seqbase,  BUNgetpos(b, BUNlast(b)) );
      return throwMessage("bat.insert", " insert non-nil values in a void column.");
}
@c
char *
BKCinsert_void_bun(int *r, int *bid, ptr t)
{
	BAT *b;
	oid h = oid_nil;

	(void) r;
	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("bat.insert", "Cannot access descriptor");
	}
	@:derefStr(b,t,t)@
	BUNins(b, (ptr) &h, @:batconvert(b,t)@
	    );
/*	BBPincref(*r = b->batCacheid, TRUE); */
	BBPunfix(b->batCacheid);
	return MAL_SUCCEED;
}

char *
BKCinsert_bun(int *r, int *bid, ptr h, ptr t)
{
	BAT *b;
	(void) r;

	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("bat.insert", "Cannot access descriptor");
	}
	@:derefStr(b,h,h)@
	@:derefStr(b,t,t)@
	BUNins(b, @:batconvert(b,h)@, @:batconvert(b,t)@);
/*	BBPincref(*r = b->batCacheid, TRUE);*/
	BBPunfix(b->batCacheid);
	return MAL_SUCCEED;
}
char *
BKCinsert_bun_oid_any(int *r, int *bid, ptr h, ptr t)
{
	BAT *b;
	(void) r;

	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("bat.insert", "Cannot access descriptor");
	}
	/* tail is not(!) a string */
	BUNins(b, h, @:batconvert(b,t)@);
/*	BBPincref(*r = b->batCacheid, TRUE);*/
	BBPunfix(b->batCacheid);
	return MAL_SUCCEED;
}
char *
BKCinsert_bun_int_int(int *r, int *bid, int *h, int *t)
{
	BAT *b;
	(void) r;

	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("bat.insert", "Cannot access descriptor");
	}
	BUNins(b, h, t);
/*	BBPincref(*r = b->batCacheid, TRUE);*/
	BBPunfix(b->batCacheid);
	return MAL_SUCCEED;
}
char *
BKCinsert_bun_oid_str(int *r, int *bid, ptr h, ptr t)
{
	BAT *b;
	(void) r;

	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("bat.insert", "Cannot access descriptor");
	}
	@:derefStr(b,t,t)@
	BUNins(b, h, @:batconvert(b,t)@);
/*	BBPincref(*r = b->batCacheid, TRUE);*/
	BBPunfix(b->batCacheid);
	return MAL_SUCCEED;
}

str
BKCinsert_bat(int *r, int *bid, int *sid)
{
	BAT *b, *s, *bn = NULL;

	(void) r;
	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("bat.insert", "Cannot access descriptor");
	}
	(void) r;
	if ((s = BATdescriptor(*sid)) == NULL) {
		BBPunfix(b->batCacheid);
		return throwMessage("bat.insert", "Cannot access descriptor");
	}
	CMDinsert_bat(&bn, b, s);
	BBPunfix(b->batCacheid);
	BBPunfix(s->batCacheid);
/*	BBPincref(bn->batCacheid, TRUE); */
	BBPunfix(bn->batCacheid);
	return MAL_SUCCEED;
}

str
BKCreplace_bun(int *r, int *bid, ptr h, ptr t)
{
	BAT *b, *bn = NULL;

	(void) r;
	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("bat.replace", "Cannot access descriptor");
	}
	@:derefStr(b,h,h)@
	@:derefStr(b,t,t)@
	CMDreplace_bun(&bn, b, h, t);
/*	BBPincref(*r = bn->batCacheid, TRUE); */
	BBPunfix(b->batCacheid);
	return MAL_SUCCEED;
}

str
BKCreplace_bat(int *r, int *bid, int *sid)
{
	BAT *b, *s, *bn = NULL;

	(void) r;
	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("bat.replace", "Cannot access descriptor");
	}
	if ((s = BATdescriptor(*sid)) == NULL) {
		BBPunfix(b->batCacheid);
		return throwMessage("bat.replace", "Cannot access descriptor");
	}
	if (CMDreplace_bat(&bn, b, s) == GDK_SUCCEED) {
/*		BBPincref(bn->batCacheid, TRUE); */
		BBPunfix(bn->batCacheid);
		BBPunfix(b->batCacheid);
		BBPunfix(s->batCacheid);
		return MAL_SUCCEED;
	}
	BBPunfix(b->batCacheid);
	BBPunfix(s->batCacheid);
	return throwMessage("bat.replace_bat", "GDKerror");
}

char *
BKCdelete_bun(int *r, int *bid, ptr h, ptr t)
{
	BAT *b, *bn = NULL;

	(void) r;
	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("bat.delete", "Cannot access descriptor");
	}
	@:derefStr(b,h,h)@
	@:derefStr(b,t,t)@
	if (CMDdelete_bun(&bn, b, h, t) == GDK_SUCCEED) {
		BBPunfix(b->batCacheid);
		return MAL_SUCCEED;
	}
/*	BBPincref(*r = b->batCacheid, TRUE); */
	BBPunfix(b->batCacheid);
	return throwMessage("bat.delete_buns", "GDKerror");
}

char *
BKCdelete(int *r, int *bid, ptr h)
{
	BAT *b, *bn = NULL;

	(void) r;
	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("bat.delete", "Cannot access descriptor");
	}
	@:derefStr(b,h,h)@
	if (CMDdelete_head(&bn, b, h) == GDK_SUCCEED) {
		BBPunfix(b->batCacheid);
		return MAL_SUCCEED;
	}
/*	BBPincref(*r = b->batCacheid, TRUE); */
	BBPunfix(b->batCacheid);
	return throwMessage("bat.delete", "GDKerror");
}

str
BKCdelete_all(int *r, int *bid)
{
	BAT *b, *bn = NULL;

	(void) r;
	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("bat.delete", "Cannot access descriptor");
	}
	if (CMDdelete_all(&bn, b) == GDK_SUCCEED) {
		BBPunfix(b->batCacheid);
		return MAL_SUCCEED;
	}
/*	BBPincref(*r = b->batCacheid, TRUE); */
	BBPunfix(b->batCacheid);
	return throwMessage("bat.delete", "GDKerror");
}

str
BKCdelete_bat_bun(int *r, int *bid, int *sid)
{
	BAT *b, *s, *bn = NULL;

	(void) r;
	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("bat.delete", "Cannot access descriptor");
	}
	if ((s = BATdescriptor(*sid)) == NULL) {
		BBPunfix(b->batCacheid);
		return throwMessage("bat.delete", "Cannot access descriptor");
	}
	if (CMDdelete_bat_bun(&bn, b, s) == GDK_SUCCEED) {
		BBPunfix(b->batCacheid);
		BBPunfix(s->batCacheid);
		return MAL_SUCCEED;
	}
/*	BBPincref(*r = b->batCacheid, TRUE); */
	BBPunfix(b->batCacheid);
	BBPunfix(s->batCacheid);
	return throwMessage("bat.delete_bat_buns", "GDKerror");
}

str
BKCdelete_bat(int *r, int *bid, int *sid)
{
	BAT *b, *s, *bn = NULL;

	(void) r;
	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("bat.delete", "Cannot access descriptor");
	}
	if ((s = BATdescriptor(*sid)) == NULL) {
		BBPunfix(b->batCacheid);
		return throwMessage("bat.delete", "Cannot access descriptor");
	}
	if (CMDdelete_bat_head(&bn, b, s) == GDK_SUCCEED) {
		BBPunfix(b->batCacheid);
		BBPunfix(s->batCacheid);
		return MAL_SUCCEED;
	}
/*	BBPincref(*r = b->batCacheid, TRUE); */
	BBPunfix(b->batCacheid);
	BBPunfix(s->batCacheid);
	return throwMessage("bat.delete_bats", "GDKerror");
}

str
BKCdestroy_bat(bit *r, str *input)
{
	CMDdestroy(r, *input);
	return MAL_SUCCEED;
}

char *
BKCdestroyImmediate(signed char*r, int *bid)
{
	BAT *b;
	char buf[512];

	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("bat.destroy", "Cannot access descriptor");
	}
	BBPlogical(b->batCacheid, buf);
	CMDdestroy(r, buf);
	BBPunfix(b->batCacheid);
	return MAL_SUCCEED;
}

char *
BKCdestroy(signed char *r, int *bid)
{
	BAT *b;

	(void) r;
	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("bat.destroy", "Cannot access descriptor");
	}
	*bid = 0;
	BATmode(b, TRANSIENT);
	BBPunfix(b->batCacheid);
	return MAL_SUCCEED;
}

/* The SQL frontend uses void-head bats */
size_t
void_delete_bat(BAT *b, BAT *d, int delta)
{
	size_t nr = 0;
	BUN r, s;
	ptr nil = ATOMnilptr(b->ttype);

	if (delta) {
		for (r = d->batInserted; r < BUNlast(d); r = BUNnext(d, r)) {
			oid delid = *(oid *) BUNtail(d, r);

			void_inplace(b, delid, nil);
			nr++;
		}
	} else {
		BATloop(d, r, s) {
			oid delid = *(oid *) BUNtail(d, r);

			void_inplace(b, delid, nil);
			nr++;
		}
	}
	return nr;
}

size_t
void_insert_delta(BAT *b, BAT *u)
{
	size_t nr = 0;
	BUN r;
	oid nil = oid_nil;

	for (r = u->batInserted; r < BUNlast(u); r = BUNnext(u, r)) {
		BUNins(b, (ptr) &nil, BUNtail(u, r));
		nr++;
	}
	return nr;
}

size_t
void_replace_delta(BAT *b, BAT *u)
{
	size_t nr = 0;
	BUN r;

	for (r = u->batInserted; r < BUNlast(u); r = BUNnext(u, r)) {
		oid updid = *(oid *) BUNhead(u, r);
		ptr val = BUNtail(u, r);

		void_inplace(b, updid, val);
		nr++;
	}
	return nr;
}

char *
BKCbat_append_void_bat_wrap(int *r, int *bid, int *uid)
{
	BAT *i, *u;

	(void) r;
	if ((i = BATdescriptor(*bid)) == NULL) {
		return throwMessage("bat.append", "Cannot access descriptor");
	}
	if ((u = BATdescriptor(*uid)) == NULL) {
		BBPunfix(i->batCacheid);
		return throwMessage("bat.append", "Cannot access descriptor");
	}
	i = BATsetaccess(i, 0);
	if (u->htype == TYPE_void)
		void_append_bat(i, u);
	else
		void_insert_bat(i, u);
/*	BBPincref(i->batCacheid, TRUE); */
	BBPunfix(i->batCacheid);
	BBPunfix(u->batCacheid);
	return MAL_SUCCEED;
}

str
BKCbat_append_oid_bat_wrap(int *r, int *bid, int *uid)
{
	BAT *i, *u;

	(void) r;
	if ((i = BATdescriptor(*bid)) == NULL) {
		return throwMessage("bat.append", "Cannot access descriptor");
	}
	if ((u = BATdescriptor(*uid)) == NULL) {
		BBPunfix(i->batCacheid);
		return throwMessage("bat.append", "Cannot access descriptor");
	}
	i = BATsetaccess(i, 0);
	void_insert_bat(i, u);
/*	BBPincref(i->batCacheid, TRUE); */
	BBPunfix(i->batCacheid);
	BBPunfix(u->batCacheid);
	return MAL_SUCCEED;
}

str
BKCbat_append_oidvoid_bat_wrap(int *r, int *bid, int *uid)
{
	BAT *i, *u;

	(void) r;
	if ((i = BATdescriptor(*bid)) == NULL) {
		return throwMessage("bat.append", "Cannot access descriptor");
	}
	if ((u = BATdescriptor(*uid)) == NULL) {
		BBPunfix(i->batCacheid);
		return throwMessage("bat.append", "Cannot access descriptor");
	}
	i = BATsetaccess(i, 0);
	void_insert_bat(i, u);
/*	BBPincref(i->batCacheid, TRUE); */
	BBPunfix(i->batCacheid);
	BBPunfix(u->batCacheid);
	return MAL_SUCCEED;
}

str
BKCoid_bat_append_oid_bat_wrap(int *res, int *bid, int *uid)
{
	BUN r = 0, s;
	oid o;
	BAT *i, *u;

	(void) res;
	if ((i = BATdescriptor(*bid)) == NULL) {
		return throwMessage("bat.append", "Cannot access descriptor");
	}
	if ((u = BATdescriptor(*uid)) == NULL) {
		BBPunfix(i->batCacheid);
		return throwMessage("bat.append", "Cannot access descriptor");
	}

	assert(i->htype == TYPE_oid && (BATcount(u) == 0 || u->htype == TYPE_oid));

	i = BATsetaccess(i, 0);
	o = oid_max(i);
	o++;
	BATloop(u, r, s) {
		oid h = *(oid *) BUNhead(u, r) + o;

		BUNins(i, &h, BUNtail(u, r));
	}
/*	BBPincref(i->batCacheid, TRUE); */
	BBPunfix(i->batCacheid);
	BBPunfix(u->batCacheid);
	return MAL_SUCCEED;
}

@-
For BUN inserts we do not call for change in access mode.
This would be too costly
@c
str
BKCoid_bat_append_val_wrap(int *r, int *bid, ptr u)
{
	oid o;
	BAT *i;

	(void) r;
	if ((i = BATdescriptor(*bid)) == NULL) {
		return throwMessage("bat.append", "Cannot access descriptor");
	}

	assert(i->htype == TYPE_oid);
	o = oid_max(i);
	o++;
	@:derefStr(i,t,u)@
	BUNins(i, (ptr) &o, u);
/*	BBPincref(i->batCacheid, TRUE); */
	BBPunfix(i->batCacheid);
	return MAL_SUCCEED;
}


char *
BKCbat_append_val_wrap(int *r, int *bid, ptr u)
{
	BAT *i;
	oid h;

	(void) r;
	if ((i = BATdescriptor(*bid)) == NULL) {
		return throwMessage("bat.append", "Cannot access descriptor");
	}
	h = i->hseqbase + BATcount(i);
	@:derefStr(i,t,u)@
	i = BATsetaccess(i, 0);
	BUNins(i, (ptr) &h, u);
/*	BBPincref(i->batCacheid, TRUE); */
	BBPunfix(i->batCacheid);
	return MAL_SUCCEED;
}

str
BKCbat_replace_oid_bat_wrap(int *r, int *bod, int *did)
{
	BAT *o, *d;

	(void) r;
	if ((o = BATdescriptor(*bod)) == NULL) {
		return throwMessage("bat.replace", "Cannot access descriptor");
	}
	if ((d = BATdescriptor(*did)) == NULL) {
		BBPunfix(o->batCacheid);
		return throwMessage("bat.replace", "Cannot access descriptor");
	}
	o = BATsetaccess(o, 0);
	void_replace_bat(o, d);
/*	BBPincref(o->batCacheid, TRUE); */
	BBPunfix(o->batCacheid);
	BBPunfix(d->batCacheid);
	return MAL_SUCCEED;
}

/*end of SQL enhancement */

char *
BKCgetAlpha(int *r, int *bid)
{
	BAT *b, *c;

	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("bat.getInserted", "Cannot access descriptor");
	}
	BBPincref(b->batCacheid, TRUE);
	c = BATalpha(b);
	*r = c->batCacheid;
	BBPunfix(b->batCacheid);
	return MAL_SUCCEED;
}

char *
BKCgetDelta(int *r, int *bid)
{
	BAT *b, *c;

	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("bat.getDeleted", "Cannot access descriptor");
	}
	BBPincref(b->batCacheid, TRUE);
	c = BATdelta(b);
	*r = c->batCacheid;
	BBPunfix(b->batCacheid);
	return MAL_SUCCEED;
}

str
BKCgetCapacity(lng *res, int *bid)
{
	CMDcapacity(res, bid);
	return MAL_SUCCEED;
}

str
BKCgetHeadType(str *res, int *bid)
{
	CMDhead(res, bid);
	return MAL_SUCCEED;
}

str
BKCgetTailType(str *res, int *bid)
{
	CMDtail(res, bid);
	return MAL_SUCCEED;
}

str
BKCgetRole(str *res, int *bid)
{
	BAT *b;

	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("bat.getType", "Cannot access descriptor");
	}
	*res = GDKstrdup((*bid > 0) ? b->hident : b->tident);
	BBPunfix(b->batCacheid);
	return MAL_SUCCEED;
}

str
BKCsetkey(int *res, int *bid, bit *param)
{
	BAT *b, *bn = NULL;

	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("bat.setKey", "Cannot access descriptor");
	}
	CMDsetkey(&bn, b, param);
	*res = b->batCacheid;
	BBPunfix(b->batCacheid);
	return MAL_SUCCEED;
}

str
BKCsetSet(int *res, int *bid, bit *param)
{
	BAT *b, *bn = NULL;

	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("bat.setSet", "Cannot access descriptor");
	}
	CMDsetset(&bn, b, param);
	*res = b->batCacheid;
	BBPunfix(b->batCacheid);
	return MAL_SUCCEED;
}

str
BKCisaSet(int *res, int *bid)
{
	BAT *b;

	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("bat.isaSet", "Cannot access descriptor");
	}
	*res = b->batSet;
	BBPunfix(b->batCacheid);
	return MAL_SUCCEED;
}

str
BKCsetSorted(bit *res, int *bid)
{
	BAT *b;

	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("bat.isSorted", "Cannot access descriptor");
	}
	CMDordered(res, b);
	*res = BATordered(b) ? 1 : 0;
	BBPunfix(b->batCacheid);
	return MAL_SUCCEED;
}

str
BKCisSorted(bit *res, int *bid)
{
	BAT *b;

	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("bat.isSorted", "Cannot access descriptor");
	}
	*res = BATordered(b) ? 1 : 0;
	BBPunfix(b->batCacheid);
	return MAL_SUCCEED;
}

str
BKCisSortedReverse(bit *res, int *bid)
{
	BAT *b;

	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("bat.isSorted", "Cannot access descriptor");
	}
	*res = BATordered_rev(b) ? 1 : 0;
	BBPunfix(b->batCacheid);
	return MAL_SUCCEED;
}

@-
We must take care of the special case of a nil column (TYPE_void,seqbase=nil)
such nil columns never set hkey (and BUNins will never invalidate it if set) yet
a nil column of a BAT with <= 1 entries does not contain doubles => return TRUE.
@c

str
BKCgetKey(bit *ret, int *bid)
{
	BAT *b;

	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("bat.setPersistence", "Cannot access descriptor");
	}
	CMDgetkey(ret, b);
	BBPunfix(b->batCacheid);
	return MAL_SUCCEED;
}

str
BKCpersists(int *r, int *bid, bit *flg)
{
	BAT *b;

	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("bat.setPersistence", "Cannot access descriptor");
	}
	CMDpersists(&b, b, flg);
	BBPunfix(b->batCacheid);
	BBPunfix(b->batCacheid);
	*r = 0;
	return MAL_SUCCEED;
}

str
BKCsetPersistent(int *r, int *bid)
{
	bit flag= TRUE;
	return BKCpersists(r,bid, &flag);
}

str
BKCisPersistent(bit *res, int *bid)
{
	BAT *b;

	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("bat.setPersistence", "Cannot access descriptor");
	}
	*res = (b->batPersistence == PERSISTENT) ? TRUE : FALSE;
	BBPunfix(b->batCacheid);
	return MAL_SUCCEED;
}

str
BKCsetTransient(int *r, int *bid)
{
	BAT *b;

	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("bat.setTransient", "Cannot access descriptor");
	}
	BATmode(b, TRANSIENT);
	*r = 0;
	BBPunfix(b->batCacheid);
	return MAL_SUCCEED;
}

str
BKCisTransient(bit *res, int *bid)
{
	BAT *b;

	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("bat.setTransient", "Cannot access descriptor");
	}
	*res = b->batPersistence == TRANSIENT;
	BBPunfix(b->batCacheid);
	return MAL_SUCCEED;
}

@-
@= accessMode
mal_export str BKCset@1(int *res, int *bid) ;
str BKCset@1(int *res, int *bid) {
	BAT *b, *bn = NULL;
	int param=@2;
    if( (b= BATdescriptor(*bid)) == NULL ){
        return throwMessage("bat.set@1", "Cannot access descriptor");
    }
	CMDsetaccess(&bn,b,&param);
	BBPincref(*res =bn->batCacheid,TRUE);
	BBPunfix(bn->batCacheid);
	BBPunfix(b->batCacheid);
	return MAL_SUCCEED;
}
mal_export str BKChas@1(bit *res, int *bid);
str BKChas@1(bit *res, int *bid) {
	BAT *b;
    if( (b= BATdescriptor(*bid)) == NULL ){
        return throwMessage("bat.set@1", "Cannot access descriptor");
    }
	*res = BATgetaccess(b)=='@3';
	BBPunfix(b->batCacheid);
	return MAL_SUCCEED;
}
@-
@c
@:accessMode(WriteMode,0,w)@
@:accessMode(ReadMode,1,r)@
@:accessMode(AppendMode,2,a)@

str
BKCaccess(int *res, int *bid, int *m)
{
	BAT *b, *bn = NULL;

	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("bat.setAccess", "Cannot access descriptor");
	}
	CMDsetaccess(&bn, b, m);
	BBPincref(*res = b->batCacheid, TRUE);
	BBPunfix(b->batCacheid);
	return MAL_SUCCEED;
}

str
BKCsetAccess(int *res, int *bid, str *param)
{
	BAT *b, *bn = NULL;
	int m;

	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("bat.setAccess", "Cannot access descriptor");
	}
	switch (*param[0]) {
	case 'r':
		m = 1;
		break;
	case 'a':
		m = 2;
		break;
	case 'w':
		m = 0;
		break;
	default:
		*res = 0;
		return throwMessage("bat.setAccess", " illegal access mode");
	}
	CMDsetaccess(&bn, b, &m);
	BBPincref(*res = b->batCacheid, TRUE);
	BBPunfix(b->batCacheid);
	return MAL_SUCCEED;
}

str
BKCgetAccess(str *res, int *bid)
{
	BAT *b;

	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("bat.getAccess", "Cannot access descriptor");
	}
	switch (BATgetaccess(b)) {
	case 1:
		*res = GDKstrdup("read");
		break;
	case 2:
		*res = GDKstrdup("append");
		break;
	case 0:
		*res = GDKstrdup("write");
		break;
	}
	BBPunfix(b->batCacheid);
	return MAL_SUCCEED;
}

@- Property management
All property operators should ensure exclusive access to the BAT
descriptor.
Where necessary use the primary view to access the properties
@c
str
BKCinfo(int *retval, int *bid)
{
	BAT *bn = NULL, *b;

	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("bat.getInfo", "Cannot access descriptor");
	}
	if (b == 0)
		return throwMessage("BKCinfo", "no such bat.\n");
	if (CMDinfo(&bn, b) == GDK_SUCCEED) {
		*retval = bn->batCacheid;
		BBPunfix(*bid);
		return MAL_SUCCEED;
	}
	BBPunfix(*bid);
	BBPunfix(b->batCacheid);
	return throwMessage("BKCinfo", "GDKerror");
}

#define ROUND_UP(x,y) ((y)*(((x)+(y)-1)/(y)))

str
BKCbatsize(int *tot, int *bid)
{
	BAT *b;

	(void) tot;
	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("bat.batsize", "Cannot access descriptor");
	}
	BBPunfix(b->batCacheid);
	return throwMessage("bat.batsize", "Not yet implemented");
}

str
BKCbatsize_str(int *tot, str batname)
{
	bat bid = BBPindex(batname);

	if (bid == 0) {
		return throwMessage("BKCbatsizes", "no such bat.\n");
	}
	return BKCbatsize(tot, &bid);
}

@+ Synced BATs
@c
str
BKCisSynced(bit *ret, int *bid1, int *bid2)
{
	BAT *b1, *b2;

	if ((b1 = BATdescriptor(*bid1)) == NULL) {
		return throwMessage("bat.isSynced", "Cannot access descriptor");
	}
	if ((b2 = BATdescriptor(*bid2)) == NULL) {
		BBPunfix(b1->batCacheid);
		return throwMessage("bat.isSynced", "Cannot access descriptor");
	}
	CMDsynced(ret, b1, b2);
	BBPunfix(b1->batCacheid);
	BBPunfix(b2->batCacheid);
	return MAL_SUCCEED;
}

@+ Role Management
@c
char *
BKCsetRole(int *r, int *bid, char **hname, char **tname)
{
	BAT *b;

	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("bat.setRole", "Cannot access descriptor");
	}
	if (*hname == 0)
		return throwMessage("bat.setRole", "head name missing");
	if (*tname == 0)
		return throwMessage("bat.setRole", "tail name missing");
	BATroles(b, *hname, *tname);
	BBPunfix(b->batCacheid);
	*r = 0;
	return MAL_SUCCEED;
}

str
BKCsetColumn(int *r, int *bid, str *tname)
{
	BAT *b;

	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("bat.setColumn", "Cannot access descriptor");
	}
	if (*tname == 0)
		return throwMessage("bat.setColumn", "column name missing");
	BATroles(b, b->hident, *tname);
	BBPunfix(b->batCacheid);
	*r =0;
	return MAL_SUCCEED;
}

str
BKCsetColumns(int *r, int *bid, str *hname, str *tname)
{
	BAT *b;

	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("bat.setColumns", "Cannot access descriptor");
	}
	BATroles(b, *hname, *tname);
	BBPunfix(b->batCacheid);
	BBPunfix(b->batCacheid);
	*r =0;
	return MAL_SUCCEED;
}


str
BKCsetName(int *r, int *bid, str *s)
{
	BAT *b;
	bit res, *rp = &res;

	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("bat.setName", "Cannot access descriptor");
	}
	CMDrename(rp, b, *s);
	BBPunfix(b->batCacheid);
	*r = 0;
	return MAL_SUCCEED;
}

str
BKCgetBBPname(str *ret, int *bid)
{
	BAT *b;

	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("bat.getName", "Cannot access descriptor");
	}
	*ret = GDKstrdup(BBPname(b->batCacheid));
	BBPunfix(b->batCacheid);
	return MAL_SUCCEED;
}

str
BKCunload(bit *res, str *input)
{
	CMDunload(res, *input);
	return MAL_SUCCEED;
}

str
BKCisCached(int *res, int *bid)
{
	BAT *b;

	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("bat.isCached", "Cannot access descriptor");
	}
	*res = 0;
	BBPunfix(b->batCacheid);
	return throwMessage("bat.isCached", "not yet implemented");
}

str
BKCload(int *res, str *input)
{
	bat bid = BBPindex(*input);

	*res = bid;
	if (bid) {
		BBPincref(bid, TRUE);
		return MAL_SUCCEED;
	}
	return throwMessage("bat.unload", " file name missing");
}

str
BKChot(int *res, str *input)
{
	(void) res;		/* fool compiler */
	BBPhot(BBPindex(*input));
	return MAL_SUCCEED;
}

str
BKCcold(int *res, str *input)
{
	(void) res;		/* fool compiler */
	BBPcold(BBPindex(*input));
	return MAL_SUCCEED;
}

str
BKCcoldBAT(int *res, int *bid)
{
	BAT *b;

	(void) res;
	(void) bid;		/* fool compiler */
	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("bat.isCached", "Cannot access descriptor");
	}
	BBPcold(b->batCacheid);
	BBPunfix(b->batCacheid);
	return MAL_SUCCEED;
}

str
BKCheat(int *res, str *input)
{
	int bid = BBPindex(*input);

	if (bid) {
		*res = BBP_lastused(bid) & 0x7fffffff;
	}
	return throwMessage("bat", "heat not yet implemented\n");
}

str
BKChotBAT(int *res, int *bid)
{
	BAT *b;

	(void) res;
	(void) bid;		/* fool compiler */
	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("bat.isCached", "Cannot access descriptor");
	}
	BBPhot(b->batCacheid);
	BBPunfix(b->batCacheid);
	return MAL_SUCCEED;
}

str
BKCsave(bit *res, str *input)
{
	CMDsave(res, *input);
	return MAL_SUCCEED;
}

str
BKCsave2(int *r, int *bid)
{
	BAT *b;

	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("bat.save", "Cannot access descriptor");
	}

	if (b && BATdirty(b))
		BBPsave(b);
	BBPunfix(b->batCacheid);
	*r = 0;
	return MAL_SUCCEED;
}

@c
str
BKCmmap(int *res, int *bid, int *bns, int *hhp, int *thp)
{
	BAT *b, *bn = NULL;

	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("bat.mmap", "Cannot access descriptor");
	}
	if (CMDmmap(&bn, b, bns, hhp, thp) == GDK_SUCCEED) {
		*res = TRUE;
		BBPunfix(b->batCacheid);
		return MAL_SUCCEED;
	}
	*res = FALSE;
	BBPunfix(b->batCacheid);
	return throwMessage("bat.mmap", " failed");
}

str
BKCmmap2(int *res, int *bid, int *bns)
{
	return BKCmmap(res, bid, bns, bns, bns);
}

str
BKCmadvise(int *res, int *bid, int *bns, int *hhp, int *thp)
{
	BAT *b;

	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("bat.madvice", "Cannot access descriptor");
	}
	*res = BATmadvise(b, (*bns == int_nil) ? -1 : *bns, (*hhp == int_nil) ? -1 : *hhp, (*thp == int_nil) ? -1 : *thp);
	BBPunfix(b->batCacheid);
	if (*res)
		return throwMessage("bat.madvise", " failed");
	return MAL_SUCCEED;
}

str
BKCmadvise2(int *res, int *bid, int *mode)
{
	return BKCmadvise(res, bid, mode, mode, mode);
}

@+ Accelerator Control
@c
str
BKCaccbuild(int *ret, int *bid, str *acc, ptr *param)
{
	(void) bid;
	(void) acc;
	(void) param;
	*ret = TRUE;
	return throwMessage("Accelerator", "Obsolete functionality");
}

str
BKCaccbuild_std(int *ret, int *bid, int *acc)
{
	(void) bid;
	(void) acc;
	*ret = TRUE;
	return throwMessage("Accelerator", "Obsolete functionality");
}


str
BKCsetHash(bit *ret, int *bid, bit *prop)
{
	BAT *b;

	(void) ret;
	(void) prop;		/* fool compiler */
	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("bat.setHash", "Cannot access descriptor");
	}
	BAThash(b, 0);
	BBPunfix(b->batCacheid);
	return MAL_SUCCEED;
}

str
BKCsetSequenceBase(int *r, int *bid, oid *o)
{
	BAT *b;

	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("bat.setSequenceBase", "Cannot access descriptor");
	}
	BATseqbase(b, *o);
	BBPincref(*r = b->batCacheid, TRUE);
	BBPunfix(b->batCacheid);
	return MAL_SUCCEED;
}

str
BKCsetSequenceBaseNil(int *r, int *bid, oid *o)
{
	oid ov = oid_nil;

	(void) o;
	return BKCsetSequenceBase(r, bid, &ov);
}

str
BKCgetSequenceBase(oid *r, int *bid)
{
	BAT *b;

	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("bat.setSequenceBase", "Cannot access descriptor");
	}
	*r = b->hseqbase;
	BBPunfix(b->batCacheid);
	return MAL_SUCCEED;
}

@}
