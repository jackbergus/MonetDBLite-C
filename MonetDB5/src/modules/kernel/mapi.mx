@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2005 CWI.
@' All Rights Reserved.

@f mapi
@a N.J. Nes P. Boncz, S. Mullender
@v 1.1
@+ MonetDB's Internet Interface
This module contains a simple interface for setting up
internet connections and to initialize a client session.
Without loading this interface, Monet runs in administrator
mode. The information about activitated listeners can be
obtained with the 'inspect' module.

Clients may initialize a private listener to implement
specific services. For example, in an OLTP environment
it may make sense to have a listener for each transaction
type, which simply parses a sequence of transaction parameters.

The information about open listeners is maintain in global tables.
They behave as views on the actual state.
No protection is currently possible against malicious users changing them.

Authorization of access to the server is handled as part
of the client record initialization phase. Currently this part
is still lacking the necessary functionality.

The client can use between blocked and unblocked interaction.
The former is preferred, since it will give the best performance.
This property is indicated in the start-up sequence by passing
the authentiaction string  "<username>:<password>:lang:blocked".
An unblocked stream is obtained using "<username>:<password>:lang",
which is also backward compatible for older applications.
@mal
module mapi;

command listen():int
address MAPIlisten_default
comment "Start a Mapi server with the default settings.";
command listen(port:int):int
address MAPIlisten_port
comment "Start a Mapi server with the default settings.";
command listen(port:int, maxusers:int):int
address MAPIlisten2
comment "Start a Mapi server.";

command listen(port:int, maxusers:int, cmd:str):int
address MAPIlisten3
comment "Start the Mapi listener on <port> for <maxusers>. 
	For a new client connection MAL procedure <cmd>(Stream s_in, Stream s_out)
	is called.If no <cmd> is specified a new client thread is forked.";

command listen_ssl(port:int, maxusers:int,
	keyfile:str,certfile:str, cmd:str):int
address MAPIlistenSSL
comment "Start the Mapi listener on <port> for <maxusers> using SSL. 
	<keyfile> and <certfile> give the path names for files with the 
	server key and certificates in PEM format. For a new client connection 
	MAL procedure <cmd>(Stream s_in, Stream s_out) is called.
	If no <cmd> is specified a new client thread is forked.";

command stop(id:int):bit
address MAPIstop
comment "Terminate a specific client identified
		 by index in the client table.";
command stop(name:str):bit
address MAPIstopClient
comment "Terminate all sessions of by a client";

command suspend(sessionkey:lng,timeout:lng):void
address MAPIsuspend
comment "Suspend a client interactiont using a
		 user-supplied session key.  The session
		 is broken when the timer (in seconds)
		 for the reconnect expires.";

command resume(sessionkey:lng):void
address MAPIresume
comment "Resume the interaction with a specific client thread";

command trace(nme:str, flag:bit):void
address MAPItrace2
comment "Trace (on/off) receipt of all messages from a specific user";
command trace(flag:bit):void
address MAPItrace
comment "Trace (on/off) receipt of messages for all users";

command malclient(in:stream, out:stream):void
address MAPIclient
comment "Start a Mapi client.";

@{
command prelude()
address mapi_prelude;
command epilogue()
address mapi_epilogue;

@h
#ifndef MAPI_H
#define MAPI_H
/* #define DEBUG_MAPI */

#include "mal_client.h"
#include "mal_session.h"
#include "mal_exception.h"

#define NEW_ARRAY( type, size )	(type*)GDKmalloc((size)*sizeof(type))
#define STREQ(a, b) 		(strcmp(a, b)==0)

#define MAPIPORT		50000
#define MAPISSLPORT		40000
#define MAPIMAXUSERS 		5

mal_export str MAPIlistenThread(int *Sock);
mal_export str MAPIlisten(int *Port, str *Usockfile, int *Maxusers, str *Cmd);
mal_export bat * mapi_prelude(void);
mal_export void mapi_epilogue(void);
mal_export str MAPIlistenSSL(int *Port, int *Maxusers, str keyfile, str certfile, str cmd);
mal_export str MAPIlisten_default(int *ret);
mal_export str MAPIlisten2(int *ret, int *port, int *maxusers);
mal_export str MAPIlisten3(int *ret, int *port, int *maxusers, str *cmd);
mal_export str MAPIlisten_port(int *ret, int *pid);
mal_export str MAPIstop(int *ret, int *id);
mal_export str MAPIstopClient(int *ret, str *nme);
mal_export str MAPIsuspendClient(int *ret, int *skey, int *timeout);
mal_export str MAPIresumeClient(int *ret, int *skey);
mal_export str MAPItrace2(int *ret, str *nme, int *flg);
mal_export str MAPItrace(int *res, int *flg);
mal_export str MAPIsuspend(int *res, int *skey, int *timeout);
mal_export str MAPIresume(int *res, int *skey);

#endif /* MAPI_H */
@c
#include "mapi.h"

#include  <sys/types.h>
#ifdef HAVE_SYS_SOCKET_H
# include <sys/socket.h>
#endif
#ifdef HAVE_WIN32
# include <winsock.h>
#endif
#ifdef HAVE_SYS_UN_H
#include <sys/un.h>
#endif

#define SOCKPTR struct sockaddr *
#if HAVE_SOCKLEN_T
#define SOCKLEN socklen_t
#else
#define SOCKLEN int
#endif

#ifdef NATIVE_WIN32
#define s_close(s)	closesocket(s)
#else
#define s_close(s)	close(s)
#endif

#ifdef HAVE_OPENSSL
#include <openssl/ssl.h>
#include <openssl/err.h>
#endif


static char *threadcommand;
static int usock = -1;

str
MAPIlistenThread(int *Sock)
{
	char *msg = 0;
	char *cmd = threadcommand;

	(void)usock;
	do {
		int retval;
		struct timeval tv;
		fd_set fds;
		int msgsock;
		int sock = *Sock;

		FD_ZERO(&fds);
		if (sock >= 0)
			FD_SET(sock, &fds);
#ifdef HAVE_SYS_UN_H
		if (usock >= 0)
			FD_SET(usock, &fds);
#endif
		/* Wait up to 0.5 seconds. */
		tv.tv_sec = 0;
		tv.tv_usec = 500;

		/* temporarily use msgsock to record the larger of sock and usock */
		msgsock = sock;
#ifdef HAVE_SYS_UN_H
		if (usock > sock)
			msgsock = usock;
#endif
		retval = select(msgsock + 1, &fds, NULL, NULL, &tv);
		if (retval == 0) {
			/* nothing interesting has happened */
			continue;
		}
		if (retval < 0) {
			if (MT_geterrno() != EINTR) {
				msg = "select failed\n";
				goto error;
			}
			continue;
		}
		if (sock >= 0 && FD_ISSET(sock, &fds)) {
			if ((msgsock = accept(sock, (SOCKPTR) 0, (SOCKLEN *) 0)) < 0) {
				if (MT_geterrno() != EINTR) {
					msg = "accept failed\n";
					goto error;
				}
				continue;
			}
#ifdef HAVE_SYS_UN_H
		} else if (usock >= 0 && FD_ISSET(usock, &fds)) {
			if ((msgsock = accept(usock, (SOCKPTR) 0, (SOCKLEN *) 0)) < 0) {
				if (MT_geterrno() != EINTR) {
					msg = "accept failed\n";
					goto error;
				}
				continue;
			}
#endif
		} else
			continue;
#ifdef DEBUG_MAPI
		printf("mapi:accepted\n");
		fflush(stdout);
#endif
		if (cmd == NULL) {
			int i = 0;
			char *name = (char *) GDKmalloc(BLOCK), *user = name, *s;
			char *challenge;
			int blocked = 0;
			stream *fdin = socket_rastream(msgsock, "Server mapi read");
			stream *fdout = socket_wastream(msgsock, "Server mapi write");
			bstream *bs;

			assert(name);
			memset(name, 0, BLOCK);
			if (fdin == 0 || stream_errnr(fdin)) {
				GDKsyserror("MAPIlisten:fdin problems\n");
				continue;
			}
			/* write challenge string, the challenge is currently empty (disabled) */
			challenge = "::mserver_mal:4\n";
			/* temporarily misuse name */
			snprintf(name, BLOCK, "%2d%s", (unsigned int) strlen(challenge), challenge);
			stream_write(fdout, name, strlen(name), 1);
			/* get user name */
			*user = 0;
			stream_read(fdin, user, 1, 1);
			for (i = 0; !stream_errnr(fdin) && i < BLOCK && *user != '\n'; i++) {
				user++;
				stream_read(fdin, user, 1, 1);
			}
			if (stream_errnr(fdin)) {
				GDKsyserror("MAPIlisten: fdin problems\n");
				stream_close(fdin);
				stream_destroy(fdin);
				continue;
			}
			*user = 0;

			/* in embedded mode we allow just one client */
			if (GDKembedded && countClients() > 1) {
				stream_close(fdin);
				stream_destroy(fdin);
				continue;
			}
#ifdef DEBUG_MAPI
			printf("mapi:Client accepted %s\n", name);
			fflush(stdout);
#endif
			s = strrchr(name, ':');
			blocked = s && strncmp(s, ":blocked", 8) == 0;
			if (blocked) {
				/* printf("mapi:use blocked mode\n");fflush(stdout); */
				*s = 0;
				fdin = block_stream(stream_rstream(fdin));
				fdout = block_stream(socket_wstream(msgsock, "Server mapi write"));
			} else {
				fdout = socket_wastream(msgsock, "Server mapi write");
			}

			if (fdout == 0) {
				GDKsyserror("MAPIlisten:fdout problems\n");
				continue;
			}
#ifdef DEBUG_MAPI
			THRprintf(GDKerr, "MAPIlisten:client accepted %d\n", msgsock);
			THRprintf(GDKerr, "MAPIlisten:client string %s\n", name);
#endif
			bs = bstream_create(fdin, blocked ? 128 * BLOCK : 0);

			if (blocked)
				bs->eof = 1;
			scheduleClient(name, bs, fdout);
		} else {
			/* in M4 it is possible to execute a command directly */
		}
	} while (1);
	  error:
	return throwMessage("mapi.listen", msg);
}

str
MAPIlisten(int *Port, str *Usockfile, int *Maxusers, str *Cmd)
{
	struct sockaddr_in server;
	int sock = -1;
	int *Sock = GDKmalloc(sizeof(int));

#ifdef HAVE_SYS_UN_H
	struct sockaddr_un userver;
#endif
	SOCKLEN length = 0;
	int on = 1;
	int i = 0;
	MT_Id pid, *pidp = &pid;
	int port;
	int maxusers;
	char msg[512], *cmd, *usockfile, host[512];

	port = *Port;
	if (Usockfile == NULL || *Usockfile == 0 || strcmp(*Usockfile, str_nil) == 0)
		usockfile = NULL;
	else {
#ifdef HAVE_SYS_UN_H
		usockfile = GDKstrdup(*Usockfile);
#else
		usockfile = NULL;
		GDKwarning("MAPIlisten: Unix domain sockets are not supported\n");
#endif
	}
	maxusers = *Maxusers;
	cmd = Cmd ? GDKstrdup(*Cmd) : NULL;

	port = (port ? port : MAPIPORT);
	maxusers = (maxusers ? maxusers : MAPIMAXUSERS);

	if (port <= 0 && usockfile == NULL)
		return throwMessage("mapi.listen", "no port or socket file specified\n");

	if (port > 0) {
		sock = socket(AF_INET, SOCK_STREAM, 0);
		if (sock < 0)
			return throwMessage("mapi.listen", "creation of stream socket failed\n");
@-
Set server port and allow network connections from any workstation.
Bind the socket to the server port.
The port id should be obtained from the Homes file.
@c
		server.sin_family = AF_INET;
		server.sin_addr.s_addr = INADDR_ANY;
		server.sin_port = htons((unsigned short) ((port) & 0xFFFF));
		for (i = 0; i < 8; i++)
			server.sin_zero[i] = 0;

		setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, (char *) &on, sizeof on);

		length = (SOCKLEN) sizeof(server);
		if (bind(sock, (SOCKPTR) & server, length) < 0)
			return throwMessage("mapi.listen", "binding to stream socket failed\n");
@-
Get the new information for the server socket and start listening.
@c
		if (getsockname(sock, (SOCKPTR) & server, &length) < 0)
			return throwMessage("mapi.listen", "Failed getting socket name\n");
		listen(sock, maxusers);
	}
#ifdef HAVE_SYS_UN_H
	if (usockfile) {
		usock = socket(AF_UNIX, SOCK_STREAM, 0);
		if (usock < 0) {
			unlink(usockfile);
			return throwMessage("mapi.listen", "creation of Unix socket failed\n");
		}
		userver.sun_family = AF_UNIX;
		strncpy(userver.sun_path, usockfile, sizeof(userver.sun_path));

		length = (SOCKLEN) sizeof(userver);
		if (bind(usock, (SOCKPTR) & userver, length) < 0) {
			unlink(usockfile);
			return throwMessage("mapi.listen", "binding to Unix socket file failed\n");
		}
		listen(usock, maxusers);
	}
#endif

#ifdef DEBUG_MAPI
	THRprintf(GDKerr, "MAPIlisten:Network started at %d\n", port);
#endif
	threadcommand = cmd;
	*Sock = sock;

	if (MT_create_thread(pidp, (void (*)(void *)) MAPIlistenThread, Sock) < 0) {
		return throwMessage("mapi.listen", "starting thread failed");
	}
#ifdef HAVE_SYS_UN_H
	if (usockfile)
		unlink(usockfile);
#endif
	gethostname(host, (int) 512);
	snprintf(msg, (int) 512, "#Ready to accept connections on %s:%d\n", host, port);
	stream_printf(GDKout, "%s", msg);
	return MAL_SUCCEED;
}

#ifdef HAVE_OPENSSL
static char *
ssl_error(const char *name, int err, int ret)
{
	char *errstr, *s;
	char buf[120];
	unsigned long e;

	switch (err) {
	case SSL_ERROR_ZERO_RETURN:
		errstr = "TLS/SSL connection has been closed";
		break;
	case SSL_ERROR_WANT_READ:
		errstr = "The operation did not complete (read)";
		break;
	case SSL_ERROR_WANT_WRITE:
		errstr = "The operation did not complete (write)";
		break;
	case SSL_ERROR_WANT_X509_LOOKUP:
		errstr = "The operation did not complete (X509 lookup)";
		break;
	case SSL_ERROR_WANT_CONNECT:
		errstr = "The operation did not complete (connect)";
		break;
	case SSL_ERROR_SYSCALL:
		e = ERR_get_error();
		if (e == 0) {
			if (ret == 0) {
				errstr = "EOF occurred in violation of protocol";
			} else if (ret == -1) {
				/* the underlying BIO reported an I/O error */
				errstr = "I/O error";
			} else {	/* possible? */
				errstr = "Some I/O error occurred";
			}
		} else {
			errstr = ERR_error_string(e, buf);
		}
		break;
	case SSL_ERROR_SSL:
		e = ERR_get_error();
		if (e != 0)
			errstr = ERR_error_string(e, buf);
		else {		/* possible? */
			errstr = "A failure in the SSL library occurred";
		}
		break;
	default:
		errstr = "Invalid error code";
	}
	s = GDKmalloc(strlen(errstr) + strlen(name) + 4);
	sprintf(s, "%s: %s\n", name, errstr);	/* we allocated enough, so it fits */
	return s;
}

static MT_Lock *mutex_buf;

static void
locking_function(int mode, int n, const char *file, int line)
{
	(void) file;
	(void) line;
	if (mode & CRYPTO_LOCK)
		MT_set_lock(mutex_buf[n], "locking_function");
	else
		MT_unset_lock(mutex_buf[n], "locking_function");
}

static unsigned long
id_function(void)
{
	return (unsigned long) MT_getpid();
}
#endif /* HAVE_OPENSSL */

bat *
mapi_prelude(void)
{
#ifdef HAVE_OPENSSL
	int i, nlocks;

	nlocks = CRYPTO_num_locks();
	mutex_buf = GDKmalloc(nlocks * sizeof(*mutex_buf));
	if (mutex_buf == NULL) {
		GDKsyserror("mapi_prelude: failed to allocate %d mutexes\n", nlocks);
		return NULL;
	}
	for (i = 0; i < nlocks; i++)
		mutex_buf[i] = MT_create_lock();
	CRYPTO_set_locking_callback(locking_function);
	CRYPTO_set_id_callback(id_function);
#endif
	return NULL;
}

void
mapi_epilogue(void)
{
#ifdef HAVE_OPENSSL
	if (mutex_buf) {
		int i, nlocks;

		nlocks = CRYPTO_num_locks();
		CRYPTO_set_id_callback(NULL);
		CRYPTO_set_locking_callback(NULL);
		for (i = 0; i < nlocks; i++)
			MT_destroy_lock(mutex_buf[i]);
		GDKfree(mutex_buf);
		mutex_buf = NULL;
	}
#endif /* HAVE_OPENSSL */
}

str
MAPIlistenSSL(int *Port, int *Maxusers, str keyfile, str certfile, str cmd)
{
#ifdef HAVE_OPENSSL
	struct sockaddr_in server;
	int sock = -1;
	SOCKLEN length = 0;
	int on = 1;
	int msgsock;
	int i = 0;

	int port;
	int maxusers;
	SSL_CTX *ctx = NULL;
	SSL *ssl = NULL;
	char *msg;

	if (!port)
		port = MAPISSLPORT;
	if (!maxusers)
		maxusers = MAPIMAXUSERS;

	ctx = SSL_CTX_new(SSLv23_method());
	if (ctx == NULL) {
		msg = "creation of SSL context failed\n";
		goto fail;
	}
	if (SSL_CTX_set_cipher_list(ctx, "ALL:!LOW") == 0) {
		msg = "SSL_CTX_set_cipher_list failed\n";
		goto fail;
	}
	if (keyfile && *keyfile && certfile && *certfile) {
		if (SSL_CTX_use_PrivateKey_file(ctx, keyfile, SSL_FILETYPE_PEM) < 1) {
			msg = "SSL_CTX_use_PrivateKey_file failed\n";
			goto fail;
		}
		if (SSL_CTX_use_certificate_chain_file(ctx, certfile) < 1) {
			msg = "SSL_CTX_use_certificate_chain_file failed\n";
			goto fail;
		}
	}
	if (keyfile)
		GDKfree(keyfile);
	if (certfile)
		GDKfree(certfile);

	SSL_CTX_set_verify(ctx, SSL_VERIFY_NONE, NULL);

	sock = socket(AF_INET, SOCK_STREAM, 0);
	if (sock < 0) {
		GDKsyserror("MAPIlistenSSL:creation of stream socket failed\n");
		goto fail;
	}
@-
Set server port and allow network connections from any workstation.
Bind the socket to the server port.
The port id should be obtained from the Homes file.
@c
	server.sin_family = AF_INET;
	server.sin_addr.s_addr = INADDR_ANY;
	server.sin_port = htons((unsigned short) ((port) & 0xFFFF));
	for (i = 0; i < 8; i++)
		server.sin_zero[i] = 0;

	setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, (char *) &on, sizeof on);

	length = (SOCKLEN) sizeof(server);
	if (bind(sock, (SOCKPTR) & server, length) < 0) {
		GDKsyserror("MAPIlistenSSL:binding to stream socket (%d) failed\n", port);
		goto fail;
	}
@-
Get the new information for the server socket and start listening.
@c
	if (getsockname(sock, (SOCKPTR) & server, &length) < 0) {
		msg = "getting socket name\n";
		goto fail;
	}
	listen(sock, maxusers);

#ifdef DEBUG_MAPI
	THRprintf(GDKerr, "MAPIlistenSSL:Network started at %d\n", port);
#endif
	do {
		int retval;
		struct timeval tv;
		fd_set fds;

		FD_ZERO(&fds);
		FD_SET(sock, &fds);
		/* Wait up to 0.5 seconds. */
		tv.tv_sec = 0;
		tv.tv_usec = 500;

		retval = select(sock + 1, &fds, &fds, &fds, &tv);
		if (retval == 0) {
			/* nothing interesting has happened */
			continue;
		}
		if (retval < 0) {
			GDKsyserror("MAPIlistenSSL:select failed\n");
			goto fail;
		}
		if ((msgsock = accept(sock, (SOCKPTR) 0, (SOCKLEN *) 0)) < 0) {
			if (MT_geterrno() != EINTR) {
				msg = "accept failed\n";
				goto fail;
			}
			continue;
		}
		if ((ssl = SSL_new(ctx)) == 0) {
			msg = "SSL_new failed\n";
			goto fail;
		}

		if (!SSL_set_fd(ssl, msgsock)) {
			msg = "SSL_set_fd failed\n";
			goto fail;
		}

		for (;;) {
			int ret, err;
			char *errstr;

			ret = SSL_accept(ssl);
			err = SSL_get_error(ssl, ret);
			switch (err) {
			case SSL_ERROR_WANT_READ:
			case SSL_ERROR_WANT_WRITE:
				/* try again */
				continue;
			case SSL_ERROR_NONE:
				/* successful connect */
				break;
			case SSL_ERROR_WANT_CONNECT:
			case SSL_ERROR_WANT_ACCEPT:
			case SSL_ERROR_WANT_X509_LOOKUP:
			default:
				/* some error occurred */
				errstr = ssl_error("MAPIlistenSSL", err, ret);
				GDKsyserror(errstr);
				GDKfree(errstr);
				SSL_free(ssl);
				close(msgsock);
				goto end_loop;
			}
			break;
		}

		if (cmd == NULL) {
			int i = 0;
			char *name = (char *) GDKmalloc(BLOCK), *user = name, *s;
			char *mp;
			int blocked = 0;
			stream *fdin = ssl_rastream(ssl, "Server mapi read");
			stream *fdout = NULL;
			Client c;

			assert(name);
			memset(name, 0, BLOCK);
			if (fdin == 0 || stream_errnr(fdin)) {
				GDKsyserror("MAPIlistenSSL:fdin problems\n");
				if (fdin)
					stream_destroy(fdin);
				continue;
			}
			/* get user name */
			stream_read(fdin, user, 1, 1);
			for (i = 0; i < BLOCK && *user != '\n' && !stream_errnr(fdin); i++) {
				user++;
				stream_read(fdin, user, 1, 1);
			}
			if (stream_errnr(fdin)) {
				GDKsyserror("MAPIlistenSSL: fdin problems\n");
				stream_close(fdin);
				stream_destroy(fdin);
				continue;
			}
			*user = 0;
#ifdef DEBUG_MAPI
			THRprintf(GDKerr, "mapi:Client accepted %s\n", name);
			fflush(stdout);
#endif
			s = strrchr(name, ':');
			blocked = s && strncmp(s, ":blocked", 8) == 0;
			if (blocked) {
				/* printf("mapi:use blocked mode\n");fflush(stdout); */
				*s = 0;
				fdin = block_stream(stream_rstream(fdin));
				fdout = block_stream(ssl_wstream(SSL_dup(ssl), "Server mapi write"));
			} else {
				fdout = ssl_wastream(SSL_dup(ssl), "Server mapi write");
			}

			if (fdout == 0) {
				GDKsyserror("MAPIlistenSSL:fdout problems\n");
				continue;
			}
			*user = 0;
#ifdef DEBUG_MAPI
			THRprintf(GDKerr, "MAPIlisten:client accepted %d\n", msgsock);
#endif
			bs = bstream_create(fdin, blocked ? 128 * BLOCK : 0);

			if (blocked)
				bs->eof = 1;
			scheduleClient(name, bs, fdout);
		}
end_loop:;
	} while (1);
	SSL_CTX_free(ctx);
	close(sock);
	if (cmd)
		GDKfree(cmd);
	return GDK_SUCCEED;
	  fail:;
	if (sock >= 0)
		close(sock);
	if (ctx)
		SSL_CTX_free(ctx);
	if (cmd)
		GDKfree(cmd);
	return throwMessage("MAPIlistenSSL", msg);
#else
	(void) Port;
	(void) Maxusers;
	(void) keyfile;
	(void) certfile;
	(void) cmd;
	return throwMessage("MAPIlistenSSL", "No SSL support\n");
#endif /* HAVE_OPENSSL */
}

int
stream_read_until(str *res, stream *S, str stop)
{
	stream *s = *(stream **) S;
	int slen = strlen(stop);
	int len = 0;
	char buf[BUFSIZ + 1], *start = buf;

	while (stream_read(s, start, 1, 1) > 0) {
		if (start - buf >= slen - 1 && strncmp(start - slen + 1, stop, slen) == 0) {
/*
				start = start-slen+1;
*/
			start++;
			break;
		}
		start++;
	}

	if (stream_errnr(s))
		return GDK_FAIL;

	len = start - buf;
	if (len > 0) {
		*res = NEW_ARRAY(char, len + 1);

		buf[len] = '\0';
		memcpy(*res, buf, len + 1);
	} else {
		*res = GDKstrdup("");
	}
	return GDK_SUCCEED;
}

@- Wrappers
The Monet Version 5 wrappers are collected here
@c
str
MAPIlisten_default(int *ret)
{
	int port = MAPIPORT;
	int maxusers = MAPIMAXUSERS;

	(void) ret;
	return MAPIlisten(&port, 0, &maxusers, 0);
}

str
MAPIlisten2(int *ret, int *port, int *maxusers)
{
	(void) ret;
	return MAPIlisten(port, 0, maxusers, 0);
}

str
MAPIlisten3(int *ret, int *port, int *maxusers, str *cmd)
{
	(void) ret;
	return MAPIlisten(port, 0, maxusers, cmd);
}

str
MAPIlisten_port(int *ret, int *pid)
{
	int port = *pid;
	int maxusers = MAPIMAXUSERS;

	(void) ret;
	return MAPIlisten(&port, 0, &maxusers, 0);
}

@-
An internet connection may be terminated from the server console.
And killing the administrator this way is prohibited.
@c
str
MAPIstop(int *ret, int *id)
{
	(void) ret;		/* fool compiler */
	return stopClientIndex(getClient(), *id);
}

str
MAPIstopClient(int *ret, str *nme)
{
	(void) ret;		/* fool compiler */
	return stopClient(getClient(), *nme);
}

str
MAPIsuspendClient(int *ret, int *skey, int *timeout)
{
	(void) ret;		/* fool compiler */
	return suspendClient(getClient(), *skey, *timeout);
}

str
MAPIresumeClient(int *ret, int *skey)
{
	(void) ret;		/* fool compiler */
	return resumeClient(getClient(), *skey);
}

@-
It is advisable to trace the interactions of clients on the server
side. At least as far as it concerns requests received.
The kernel supports this 'spying' behavior with a file descriptor
field in the client record.
@c
str
MAPItrace2(int *ret, str *nme, int *flg)
{
	(void) ret;		/* fool compiler */
	(void) traceClient(*nme, *flg);
	return MAL_SUCCEED;
}

str
MAPItrace(int *res, int *flg)
{
	(void) res;		/* fool compiler */
	(void) traceAllClients(*flg);
	return MAL_SUCCEED;
}

str
MAPIsuspend(int *res, int *skey, int *timeout)
{
	(void) res;
	(void) timeout;
	(void) skey;		/* fool compiler */
	return MAL_SUCCEED;
}

str
MAPIresume(int *res, int *skey)
{
	(void) res;
	(void) skey;		/* fool compiler */
	return MAL_SUCCEED;
}

str
MAPIclient(int *res, stream **In, stream **Out) 
{
	int i = 0;
	char *name = (char *) GDKmalloc(BLOCK), *user = name, *s;
	char *challenge;
	int blocked = 0;
	bstream *bs;
	stream *fdin = *In, *fdout = *Out;

	(void) res;
	assert(name);
	memset(name, 0, BLOCK);

	/* write challenge string, the challenge is currently empty (disabled) */
	challenge = "::mserver_mal:4\n";

	/* temporarily misuse name */
	snprintf(name, BLOCK, "%2d%s", (unsigned int) strlen(challenge), challenge);
	stream_write(fdout, name, strlen(name), 1);
	/* get user name */
	*user = 0;
	stream_read(fdin, user, 1, 1);
	for (i = 0; !stream_errnr(fdin) && i < BLOCK && *user != '\n'; i++) {
		user++;
		stream_read(fdin, user, 1, 1);
	}
	if (stream_errnr(fdin)) {
		return throwException(MALEXCEPTION, "MAPIclient",
			"fdin write problems\n");
	}
	*user = 0;
	/* in embedded mode we allow just one client */
#ifdef DEBUG_MAPI
	printf("mapi:Client accepted %s\n", name);
	fflush(stdout);
#endif
	s = strrchr(name, ':');
	blocked = s && strncmp(s, ":blocked", 8) == 0;
	if (blocked) {
		/* printf("mapi:use blocked mode\n");fflush(stdout); */
		*s = 0;
		fdin = block_stream(stream_rstream(fdin));
		fdout = block_stream(stream_wstream(fdout));
	}
#ifdef DEBUG_MAPI
	THRprintf(GDKerr, "MAPIlisten:client accepted %d\n", msgsock);
	THRprintf(GDKerr, "MAPIlisten:client string %s\n", name);
#endif
	bs = bstream_create(fdin, blocked ? 128 * BLOCK : 0);

	if (blocked)
		bs->eof = 1;
	scheduleClient(name, bs, fdout);
	return MAL_SUCCEED;
}
@}
