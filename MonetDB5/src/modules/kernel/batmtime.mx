@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2008 CWI.
@' All Rights Reserved.

@f batmtime
@a M.L. Kersten
@+ Time/Date multiplexes
[TODO: property propagations]
The collection of routines provided here are map operations
for the atom time and date primitives. 

In line with the batcalc module, we assume that
if two bat operands are provided that they are already
aligned on the head. Moreover, the head of the BATs
are limited to :void, which can be cheaply realized using
the GRPsplit operation.
@{
@= compareOp
command batcalc.@2( l:bat[:oid,:@1], r:bat[:oid,:@1]) :bat[:oid,:bit]
address MTIME@1bat_@3;
command batcalc.@2( l:bat[:void,:@1], r:bat[:void,:@1]) :bat[:void,:bit]
address MTIME@1bat_@3
comment "Compare a bat of @1 against each other";
command batcalc.@2( l:bat[:oid,:@1], r:@1) :bat[:oid,:bit]
address MTIME@1bat_@3cst;
command batcalc.@2( l:bat[:void,:@1], r:@1) :bat[:void,:bit]
address MTIME@1bat_@3cst
comment "Compare a bat of @1 against a singleton";

@= compareGrp
@:compareOp(@1,==,EQ)@
@:compareOp(@1,!=,NEQ)@
@:compareOp(@1,<,LT)@
@:compareOp(@1,<=,LE)@
@:compareOp(@1,>,GT)@
@:compareOp(@1,>=,GE)@

@mal
@:compareGrp(date)@
@:compareGrp(daytime)@
@:compareGrp(timestamp)@

@+ Implementation
@c
#include "mal_config.h"
#include <gdk.h>
#include "ctype.h"
#include "mal_exception.h"
#include "mtime.h"
#include "batmtime.h"

#define prepareOperand(X,Y,Z) \
	if( (X= BATdescriptor(*Y)) == NULL ) \
		throw(MAL, "batstr." Z, "Cannot access descriptor");
#define prepareOperand2(X,Y,A,B,Z) \
	if( (X= BATdescriptor(*Y)) == NULL ) \
		throw(MAL, "batstr." Z, "Cannot access descriptor"); \
	if( (A= BATdescriptor(*B)) == NULL ){\
		BBPreleaseref(X->batCacheid); \
		throw(MAL, "batstr."Z, "Cannot access descriptor"); \
	}
#define prepareResult(X,Y,T,Z) \
	X= BATnew(Y->htype,T,BATcount(Y)); \
	if( Y->htype== TYPE_void) \
		BATseqbase(X, Y->hseqbase); \
	if( X == NULL){ \
		BBPreleaseref(Y->batCacheid); \
		throw(MAL, "batstr." Z, "no space available "); \
	} \
	X->hsorted=Y->hsorted; \
	X->tsorted=0; 
#define prepareResult2(X,Y,A,T,Z) \
	X= BATnew(Y->htype,T,BATcount(Y)); \
	if( Y->htype== TYPE_void) \
		BATseqbase(X, Y->hseqbase); \
	if( X == NULL){ \
		BBPreleaseref(Y->batCacheid); \
		BBPreleaseref(A->batCacheid); \
		throw(MAL, "batstr." Z, "no space available "); \
	} \
	X->hsorted=Y->hsorted; \
	X->tsorted=0; 
#define finalizeResult(X,Y,Z) \
	if (!((Y)->batDirty&2)) (Y) = BATsetaccess((Y), BAT_READ); \
	*X = (Y)->batCacheid; \
	BBPkeepref(*(X));\
	BBPreleaseref(Z->batCacheid);
@-
A general assumption in all cases is the bats are synchronized on their
head column. This is not checked and may be mis-used to deploy the
implementation for shifted window arithmetic as well.
@= chkSize
	if( BATcount(@1) != BATcount(@2) )
	throw(MAL, "batcalc.@3", "requires bats of identical size");

@= implDef
batmtime_export str MTIME@1bat_@2(int *ret, int *l, int *r);
batmtime_export str MTIME@1bat_@2cst(int *ret, int *l, @1 *cst);

@= implCmpOp
str MTIME@1bat_@3(int *ret, int *l, int *r)
{   
	BATiter lefti, righti;
	BAT *bn, *left, *right;
	BUN p,q;

	prepareOperand2(left,l,right,r,"batcalc.@2");
	@:chkSize(left,right,CMDcompare@1)@
	prepareResult2(bn,left,right,TYPE_bit,"batcalc.@2");

	p = BUNfirst(right);
	q = BUNlast(right);
	lefti = bat_iterator(left);
	righti = bat_iterator(right);

	for(;p<q; p++) {
		bit y = TRUE;
		ptr h = BUNhead(lefti, p);
		ptr tl = BUNtail(lefti, p);
		ptr tr = BUNtail(righti, p);

		MTIME@1_@3(&y, (@1*)tl, (@1*)tr);
		bunfastins(bn, h, &y);
	}
	bn->T->nonil = 0;
	BBPreleaseref(right->batCacheid);
	finalizeResult(ret,bn,left);
	return MAL_SUCCEED;

bunins_failed:
	BBPreleaseref(left->batCacheid);
	BBPreleaseref(right->batCacheid);
	BBPunfix(*ret);
	throw(MAL, "batcalc.@2", "bunins failed");
}

str MTIME@1bat_@3cst(int *ret, int *l, @1 *cst)
{   
	BATiter lefti;
	BAT *bn, *left;
	BUN p,q;

	prepareOperand(left,l,"batcalc.@2");
	prepareResult(bn,left,TYPE_bit,"batcalc.@2");

	p  = BUNfirst(left);
	q  = BUNlast(left);
	lefti = bat_iterator(left);

	for(;p<q; p++) {
		bit y = TRUE;
		ptr h = BUNhead(lefti, p);
		ptr tl = BUNtail(lefti, p);

		MTIME@1_@3(&y, (@1*)tl, cst);
		bunfastins(bn, h, &y);
	}
    	bn->H->nonil = left->H->nonil;
	finalizeResult(ret,bn,left);
	return MAL_SUCCEED;

bunins_failed:
	BBPreleaseref(left->batCacheid);
	BBPunfix(*ret);
	throw(MAL, "batcalc.@2", "bunins failed");
}
@-
The implementation section.

@= implCmpGrpDef
@:implDef(@1,EQ)@
@:implDef(@1,NEQ)@
@:implDef(@1,LT)@
@:implDef(@1,LE)@
@:implDef(@1,GT)@
@:implDef(@1,GE)@

@= implCmpGrp
@:implCmpOp(@1,==,EQ)@
@:implCmpOp(@1,!=,NEQ)@
@:implCmpOp(@1,<,LT)@
@:implCmpOp(@1,<=,LE)@
@:implCmpOp(@1,>,GT)@
@:implCmpOp(@1,>=,GE)@

@h
#ifdef WIN32
#ifndef LIBBATMTIME
#define batmtime_export extern __declspec(dllimport)
#else
#define batmtime_export extern __declspec(dllexport)
#endif
#else
#define batmtime_export extern
#endif

@:implCmpGrpDef(date)@
@:implCmpGrpDef(daytime)@
@:implCmpGrpDef(timestamp)@
@c
@:implCmpGrp(daytime)@
@:implCmpGrp(date)@
@:implCmpGrp(timestamp)@
@}
