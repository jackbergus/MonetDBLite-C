@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2006 CWI.
@' All Rights Reserved.

@f batmtime
@a M.L. Kersten
@* Time/Date multiplexes
[TODO: property propagations]
The collection of routines provided here are map operations
for the atom time and date primitives. 

In line with the batcalc module, we assume that
if two bat operands are provided that they are already
aligned on the head. Moreover, the head of the BATs
are limited to :void, which can be cheaply realized using
the GRPsplit operation.
@= compareOp
command batcalc.@2( l:bat[:void,:@1], r:bat[:void,:@1]) :bat[:void,:bit]
address MTIME@1bat_@3
comment "Compare a bat of @1 against each other";
command batcalc.@2( l:bat[:void,:@1], r:@1) :bat[:void,:bit]
address MTIME@1bat_@3cst
comment "Compare a bat of @1 against a singleton";

@= compareGrp
@:compareOp(@1,==,EQ)@
@:compareOp(@1,!=,NEQ)@
@:compareOp(@1,<,LT)@
@:compareOp(@1,<=,LE)@
@:compareOp(@1,>,GT)@
@:compareOp(@1,>=,GE)@

@mal
@:compareGrp(date)@
@:compareGrp(daytime)@
@:compareGrp(timestamp)@

@+ Implementation
@c
#include <gdk.h>
#include "ctype.h"
#include "mal_exception.h"
#include "mtime.h"

#define prepareOperand(X,Y,Z) \
	if( (X= BATdescriptor(*Y)) == NULL ) \
		return throwMessage("batstr." Z, "Cannot access descriptor");
#define prepareOperand2(X,Y,A,B,Z) \
	if( (X= BATdescriptor(*Y)) == NULL ) \
		return throwMessage("batstr." Z, "Cannot access descriptor"); \
	if( (A= BATdescriptor(*B)) == NULL ){\
		BBPreleaseref(X->batCacheid); \
		return throwMessage("batstr."Z, "Cannot access descriptor"); \
	}
#define prepareResult(X,Y,T,Z) \
	X= BATnew(Y->htype,T,BATcount(Y)); \
	if( Y->htype== TYPE_void) \
		BATseqbase(X, Y->hseqbase); \
	if( X == NULL){ \
		BBPreleaseref(Y->batCacheid); \
		return throwMessage("batstr." Z, "no space available "); \
	} \
	X->hsorted=Y->hsorted; \
	X->tsorted=0; 
#define prepareResult2(X,Y,A,T,Z) \
	X= BATnew(Y->htype,T,BATcount(Y)); \
	if( Y->htype== TYPE_void) \
		BATseqbase(X, Y->hseqbase); \
	if( X == NULL){ \
		BBPreleaseref(Y->batCacheid); \
		BBPreleaseref(A->batCacheid); \
		return throwMessage("batstr." Z, "no space available "); \
	} \
	X->hsorted=Y->hsorted; \
	X->tsorted=0; 
#define finalizeResult(X,Y,Z) \
	if (!((Y)->batDirty&2)) (Y) = BATsetaccess((Y), BAT_READ); \
	*X = (Y)->batCacheid; \
	BBPkeepref(*(X));\
	BBPreleaseref(Z->batCacheid);
@-
A general assumption in all cases is the bats are synchronized on their
head column. This is not checked and may be mis-used to deploy the
implementation for shifted window arithmetic as well.
@= chkSize
	if( BATcount(@1) != BATcount(@2) )
	return throwMessage("batcalc.@3", "requires bats of identical size");

@= implDef
mal_export str MTIME@1bat_@3(int *ret, int *l, @1 *r);
mal_export str MTIME@1bat_@3cst(int *ret, int *l, @1 *cst);

@= implCmpOp
str MTIME@1bat_@3(int *ret, int *l, int *r)
{   BAT *bn, *left, *right;
	BUN o,p,q;
	int xx,yy;
	bit v, *vp = &v;

	prepareOperand2(left,l,right,r,"batcalc.@2");
	@:chkSize(left,right,CMDcompare@1)@
	prepareResult2(bn,left,right,TYPE_bit,"batcalc.@2");

	o = BUNfirst(left);
	p = BUNfirst(right);
	q = BUNlast(right);
	xx = BUNsize(left);
	yy = BUNsize(right);
	while(p<q) {
		ptr h = BUNhead(left,o);
		@1 *tl = (@1*)BUNtail(left,o);
		@1 *tr = (@1*)BUNtail(right,p);
		MTIME@1_@3(vp, tl, tr);
		bunfastins(bn, h, vp);
		o += xx;
		p += yy;
	}
	BBPreleaseref(right->batCacheid);
	finalizeResult(ret,bn,left);
	return MAL_SUCCEED;

bunins_failed:
	BBPreleaseref(left->batCacheid);
	BBPreleaseref(right->batCacheid);
	BBPunfix(*ret);
	return throwMessage("batcalc.@2", "bunins failed");
}

str MTIME@1bat_@3cst(int *ret, int *l, @1 *cst)
{   BAT *bn, *left;
	BUN p,q;
	int xx;
	bit v, *vp= &v;

	prepareOperand(left,l,"batcalc.@2");
	prepareResult(bn,left,TYPE_bit,"batcalc.@2");

	p = BUNfirst(left);
	q = BUNlast(left);
	xx = BUNsize(left);
	while(p<q) {
		ptr h = BUNhead(left,p);
		@1 *tl = (@1*) BUNtail(left,p);
		MTIME@1_@3(vp, tl, cst);
		bunfastins(bn, h, vp);
		p += xx;
	}
	finalizeResult(ret,bn,left);
	return MAL_SUCCEED;

bunins_failed:
	BBPreleaseref(left->batCacheid);
	BBPreleaseref(*ret);
	return throwMessage("batcalc.$2", "bunins failed");
}
@-
The implementation section.

@= implCmpGrpDef
@:implDef(@1,EQ)@
@:implDef(@1,NEQ)@
@:implDef(@1,LT)@
@:implDef(@1,LE)@
@:implDef(@1,GT)@
@:implDef(@1,GE)@

@= implCmpGrp
@:implCmpOp(@1,==,EQ)@
@:implCmpOp(@1,!=,NEQ)@
@:implCmpOp(@1,<,LT)@
@:implCmpOp(@1,<=,LE)@
@:implCmpOp(@1,>,GT)@
@:implCmpOp(@1,>=,GE)@

@h
@:implCmpGrpDef(date)@
@:implCmpGrpDef(daytime)@
@:implCmpGrpDef(timestamp)@
@c
@:implCmpGrp(daytime)@
@:implCmpGrp(date)@
@:implCmpGrp(timestamp)@
@}
