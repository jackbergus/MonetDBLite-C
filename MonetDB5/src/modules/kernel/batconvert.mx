@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2006 CWI.
@' All Rights Reserved.

@f batconvert
@a M.L. Kersten
@+ BAT Coercion Routines
The coercion routines over BATs can not easily be speed up using
an accumulator approach, because they often require different storage space. 
Nevertheless, the implementation provided here are much faster compared
to the Version 4.* implementation.

@= coercion
	command batcalc.@2(b:bat[:any_1,:@1]):bat[:any_1,:@2] 
	address CMDconvert@1_@2
	comment "Coerce an @1 tail to a bat with @2 tail.";
@{
@-
@= coerceList
	@:coercion(@1,dbl)@
	@:coercion(@1,flt)@
	@:coercion(@1,sht)@
	@:coercion(@1,int)@
	@:coercion(@1,oid)@
	@:coercion(@1,lng)@
@mal
	@:coerceList(sht)@
	@:coerceList(int)@
	@:coerceList(lng)@
	@:coerceList(flt)@
	@:coerceList(dbl)@

	@:coercion(bit,lng)@
	@:coercion(bit,sht)@
	@:coercion(bit,int)@

command batcalc.int(b:bat[:any_1,:str]):bat[:any_1,:int] 
address CMDconvertstr_int
comment "Coerce an str tail to a bat with a int tail.";

command batcalc.oid(b:bat[:oid,:oid]):bat[:oid,:oid] 
address CMDconvertOIDclass
comment "Identity mapping";

command batcalc.int(b:bat[:any_1,:oid]):bat[:any_1,:int] 
address CMDconvertoid_int
comment "Coerce an oid tail to a bat with int tail.";

command batcalc.lng(b:bat[:any_1,:oid]):bat[:any_1,:lng] 
address CMDconvertoid_lng
comment "Coerce an oid tail to a bat with lng tail.";

command batcalc.sht(b:bat[:any_1,:oid]):bat[:any_1,:sht] 
address CMDconvertoid_sht
comment "Coerce an oid tail to a bat with sht tail.";

command batcalc.oid(b:bat[:any_1,:int]):bat[:any_1,:oid] 
address CMDconvertint_oid
comment "Materialize the int into an oid";

command batcalc.oid(b:bat[:void,:int]):bat[:void,:oid] 
address CMDconvertvoid_int_oid
comment "Materialize the int into an oid";

command batcalc.oid(b:bat[:void,:oid]):bat[:void,:oid] 
address CMDconvertvoid_oid_oid
comment "Materialize the oid into an oid";

command batcalc.str(b:bat[:any_1,:str]):bat[:any_1,:str]
address CMDconvertstr_str;

command batcalc.bit(b:bat[:any_1,:str]):bat[:any_1,:bit]
address CMDconvertstr_bit;
@-
@{
@- Implementation
@h
#include "gdk.h"
#include "math.h"
#include "mal_exception.h"

#ifdef WIN32
#ifndef LIBBATCALC
#define batcalc_export extern __declspec(dllimport)
#else
#define batcalc_export extern __declspec(dllexport)
#endif
#else
#define batcalc_export extern
#endif

@- Implementation of coercions
The coercion code can not be improved much, because we do not have
the space to re-use. Therefore, the code block is actually a hardwired
version of a bunstream() operation. It runs, however, about 5-times
faster then [lng](b) in Version 4.

@-
The different coercion implementations exploit the fact
that many coercions are simply space enlargers.
The others effectively may loose information.

A general assumption in all cases is the bats are synchronized on their
head column. This is not checked and may be mis-used to deploy the
implementation for shifted window arithmetic as well.
@= chkSize
	if( BATcount(@1) != BATcount(@2) )
	return throwMessage("batcalc.@3", "requires bats of identical size");

@= tstBat
if( bn== NULL) {*ret= 0; 
	return throwMessage("batcalc.@1", "can not create bat");}

@= batinit
	s@1= BUNsize(@2);
	p@1= (str) (BUNfirst(@2)+@2->tloc);

@= Idempotent
batcalc_export str CMDconvert@1_@1(int *ret, int *bid);
str CMDconvert@1_@1(int *ret, int *bid){
	BAT *b, *bn;
	if( (b= BATdescriptor(*bid)) == NULL ){
		return throwMessage("batcalc.convert", "Cannot access descriptor");
	}

	bn= BATrcopy(b);
	@:tstBat(CMDconvert@1_@1)@
	*ret= bn->batCacheid;
	BBPkeepref(*ret);
	BBPreleaseref(b->batCacheid);
	return MAL_SUCCEED;
}
@-
@= Enlarge
batcalc_export str CMDconvert@1_@2Enlarge(int *ret, int *bid);
str CMDconvert@1_@2Enlarge(int *ret, int *bid){
	BAT *b,*bn;
	@1 *p,*q;
	@2 *o;

	if( (b= BATdescriptor(*bid)) == NULL ){
		return throwMessage("batcalc.convert", "Cannot access descriptor");
	}
	if( b->htype!= TYPE_void) 
		return CMDconvert@1_@2(ret,bid);

	bn= newBATcresult(b, TYPE_@2);
	@:tstBat(CMDconvert@1_@2)@

	o= (@2*) BUNtail(bn,BUNfirst(bn));
	p= (@1*) BUNtail(b,BUNfirst(b));
	q= (@1*) BUNtail(b,BUNlast(b));
	while(p<q){
		if( *p == @1_nil)
			*o = @2_nil;
		else *o = (@2) *p;
		p++; o++;
	}
	(bn)->batBuns->free += BATcount(b)*sizeof(@2);
	BATsetcount(bn, BATcount(b));
	if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ);
	*ret= bn->batCacheid;
	BBPkeepref(*ret);
	BBPreleaseref(b->batCacheid);
	return MAL_SUCCEED;
}
@= General
batcalc_export str CMDconvert@1_@2(int *ret, int *bid);
str CMDconvert@1_@2(int *ret, int *bid){
	BAT *b,*bn;
	int xx;
	@1 *p,*q;
	@2 y, *o;
	ptr t,h,e;

	if( (b= BATdescriptor(*bid)) == NULL ){
		return throwMessage("batcalc.convert", "Cannot access descriptor");
	}

	bn= newBATcresult(b, TYPE_@2);
	@:tstBat(CMDconvert@1)@

	h= (ptr) BUNhead(b,BUNfirst(b));
	t= (ptr) BUNtail(b,BUNfirst(b));
	e= (ptr) BUNhead(b,BUNlast(b));
	xx= BUNsize(b);

	p= (@1*) BUNtail(b,BUNfirst(b));
	q= (@1*) BUNtail(b,BUNlast(b));
	if( b->htype == TYPE_void){
		o= (@2*) BUNtail(bn,BUNfirst(bn));
		while(p<q){
			if( *p == @1_nil)
				*o = @2_nil;
			else *o = (@2) *p;
			p++; o++;
		}
		(bn)->batBuns->free += BATcount(b)*sizeof(@2);
		BATsetcount(bn, BATcount(b));
	} else {
		while(h<e){
			y= *(@1*)t== @1_nil? @2_nil: (@2) (*(@1*)t);
			bunfastins(bn, h, &y);
			t+=xx; h+= xx;
		}
	}
bunins_failed:
	bn->tsorted = 0;
	if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ); \
	*ret= bn->batCacheid;
	BBPkeepref(*ret);
	BBPreleaseref(b->batCacheid);
	return MAL_SUCCEED;
}
@-
The lengthly list of coercions options could have been generated.
@c
#include "batconvert.h"

#define BATwcopy(b) BATcopy(b, b->htype, b->ttype, TRUE)
#define BATrcopy(b) BATcopy(b, b->htype, b->ttype, 2)

static BAT *
newBATcresult(BAT *b, int tpe)
{
	BAT *bn;

	if (BAThvoid(b)) {
		bn = BATnew(TYPE_void, tpe, BATcount(b));
		BATseqbase(bn, b->hseqbase);
	} else
		bn = BATnew(b->htype, tpe, BATcount(b));
	bn->hsorted = b->hsorted;
	bn->tsorted = b->tsorted;
	return bn;
}


@:Idempotent(sht)@
@:Idempotent(int)@
@:Idempotent(lng)@
@:Idempotent(flt)@
@:Idempotent(dbl)@
@:Idempotent(str)@
@:Idempotent(chr)@

@:General(sht,oid)@
@:General(sht,int)@
@:Enlarge(sht,int)@
@:General(sht,lng)@
@:Enlarge(sht,lng)@
@:General(sht,flt)@
@:Enlarge(sht,flt)@
@:General(sht,dbl)@
@:Enlarge(sht,dbl)@

@:General(int,sht)@
@:General(int,oid)@
@:General(int,lng)@
@:Enlarge(int,lng)@
@:General(int,flt)@
@:Enlarge(int,flt)@
@:General(int,dbl)@
@:Enlarge(int,dbl)@

@:General(oid,sht)@
@:General(oid,int)@
@:General(oid,lng)@


@:General(bit,sht)@
@:General(bit,int)@
@:General(bit,lng)@

@:General(lng,sht)@
@:General(lng,int)@
@:General(lng,oid)@
@:General(lng,flt)@
@:Enlarge(lng,flt)@
@:General(lng,dbl)@
@:Enlarge(lng,dbl)@

@:General(flt,sht)@
@:General(flt,int)@
@:General(flt,lng)@
@:General(flt,oid)@
@:General(flt,dbl)@
@:Enlarge(flt,dbl)@

@:General(dbl,sht)@
@:General(dbl,int)@
@:General(dbl,lng)@
@:General(dbl,flt)@
@:Enlarge(dbl,flt)@
@:General(dbl,oid)@

@h
batcalc_export str CMDconvertstr_int(int *ret, int *bid);
@c
str
CMDconvertstr_int(int *ret, int *bid)
{
	BAT *b, *bn;
	int xx;
	BUN p, q;
	str x;
	int y;

	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("batcalc.convert", "Cannot access descriptor");
	}

	bn = newBATcresult(b, TYPE_int);
	@:tstBat(CMDconvertstr_int)@

	BATloopFast(b, p, q, xx) {
		ptr h = BUNhead(b, p);

		x = (str) BUNtail(b, p);
		y = x == str_nil ? int_nil : strtol(x, NULL, 0);
		bunfastins(bn, h, &y);
	}
	  bunins_failed:
	bn->tsorted = 0;
	if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ); \
	*ret = bn->batCacheid;
	BBPkeepref(*ret);
	BBPreleaseref(b->batCacheid);
	return MAL_SUCCEED;
}

@h
batcalc_export str CMDconvertOIDclass(int *ret, int *bid);
@c
str
CMDconvertOIDclass(int *ret, int *bid)
{
	BAT *b;

	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("batcalc.convert", "Cannot access descriptor");
	}
	if (!(b->batDirty&2)) b = BATsetaccess(b, BAT_READ); \
	*ret = b->batCacheid;
	BBPkeepref(*ret);
	return MAL_SUCCEED;
}

/* You don;t have to materialize the oids.
This is taken care upon access */
@h
batcalc_export str CMDconvertvoid_oid_oid(int *ret, int *bid);
@c
str
CMDconvertvoid_oid_oid(int *ret, int *bid)
{
	BAT *b;

	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("batcalc.convert", "Cannot access descriptor");
	}
	if (!(b->batDirty&2)) b = BATsetaccess(b, BAT_READ); \
	*ret = b->batCacheid;
	BBPkeepref(*ret);
	return MAL_SUCCEED;
}

@h
batcalc_export str CMDconvertvoid_int_oid(int *ret, int *bid);
@c
str
CMDconvertvoid_int_oid(int *ret, int *bid)
{
#if SIZEOF_OID == SIZEOF_INT
	BAT *b, *bn;

	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("batcalc.convert", "Cannot access descriptor");
	}
	bn = BATrcopy(b);
	BATmirror(bn)->htype = bn->ttype = TYPE_oid;
	/* simply recast the BAT  without doing anything */
	*ret = bn->batCacheid;
	BBPkeepref(*ret);
	BBPreleaseref(b->batCacheid);
	return MAL_SUCCEED;
#else
	BAT *b, *bn;
	int xx;
	BUN p, q;
	oid x;

	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("batcalc.convert", "Cannot access descriptor");
	}
	bn = BATnew(TYPE_void, TYPE_oid, BATcount(b));
	BATseqbase(bn, b->hseqbase);
	@:tstBat(CMDconvertvoid_int_oid)@
	x = b->hseqbase;

	BATloopFast(b, p, q, xx) {
		oid t = *(int *) BUNtail(b, p);

		bunfastins(bn, &x, &t);
		x++;
	}
	  bunins_failed:
	bn->hsorted = b->hsorted;
	bn->tsorted = 0;
	if (!(bn->batDirty&2)) 
		bn = BATsetaccess(bn, BAT_READ);
	*ret = bn->batCacheid;
	BBPkeepref(*ret);
	BBPreleaseref(b->batCacheid);
	return MAL_SUCCEED;
#endif

}
batcalc_export str CMDconvertstr_bit(int *ret, int *bid);
str
CMDconvertstr_bit(int *ret, int *bid)
{
	BAT *b, *bn;
	int xx;
	BUN p, q;
	str x;
	bit y;

	if ((b = BATdescriptor(*bid)) == NULL) {
		return throwMessage("batcalc.convert", "Cannot access descriptor");
	}

	bn = newBATcresult(b, TYPE_bit);

	BATloopFast(b, p, q, xx) {
		ptr h = BUNhead(b, p);

		x = (str) BUNtail(b, p);
		if( strcmp(x,"true")== 0 || strcmp(x,"TRUE")== 0)
			y= TRUE;
		else
		if( strcmp(x,"false")== 0 || strcmp(x,"FALSE")== 0)
			y= FALSE;
		else
			y = bit_nil;
		bunfastins(bn, h, &y);
	}
  bunins_failed:
	bn->tsorted = 0;
	if (!(bn->batDirty&2))
		bn = BATsetaccess(bn, BAT_READ); 
	*ret = bn->batCacheid;
	BBPkeepref(*ret);
	BBPreleaseref(b->batCacheid);
	return MAL_SUCCEED;
}
@}
