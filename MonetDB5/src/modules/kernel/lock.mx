@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2006 CWI.
@' All Rights Reserved.

@f lock
@v 1.0
@a Peter Boncz
@* Lightweight Lock Module
This module provides simple SMP lock and thread functionality
as already present in the MonetDB system.

@+ Locks
@mal
atom lock:ptr;

command create() :lock 
address LCKcreate
comment "Create an unset lock";
command set(l:lock) 
address LCKset
comment "Try to set a lock. If set, block till it is freed";
command try(l:lock) :int 
address LCKtry
comment "Try a lock. If free set it, if not return EBUSY";
command unset(l:lock) 
address LCKunset
comment "Unset a lock";
command destroy(l:lock) 
address LCKdestroy
comment "Destroy a lock";
command tostr(l:lock) 
address lockToStr
comment "Overloaded atom function";

@{
@* Implementation
@c
#include <gdk.h>
#include "mal_exception.h"
typedef ptr lock;
typedef ptr monet_lock;

#ifdef WIN32
#ifndef LIBLOCK
#define lock_export extern __declspec(dllimport)
#else
#define lock_export extern __declspec(dllexport)
#endif
#else
#define lock_export extern
#endif

int
create_lock(monet_lock *l)
{
	*l = (monet_lock) GDKmalloc(sizeof(MT_Lock));
	if (*l == NULL || *l == ptr_nil) return GDK_FAIL;
	MT_lock_init((MT_Lock*) *l);
	return GDK_SUCCEED;
}

int
set_lock(monet_lock *l)
{
	if (*l == NULL || *l == ptr_nil) return GDK_FAIL;
	MT_lock_set((MT_Lock*) *l, "set_lock");
	return GDK_SUCCEED;
}

int
try_lock(int *res, monet_lock *l)
{
	if (*l == NULL || *l == ptr_nil) return GDK_FAIL;
	*res = MT_lock_try((MT_Lock*) *l) ? EBUSY : 0;
	return GDK_SUCCEED;
}

int
unset_lock(monet_lock *l)
{
	if (*l == NULL || *l == ptr_nil) return GDK_FAIL;
	MT_lock_unset((MT_Lock*) *l, "unset_lock");
	return GDK_SUCCEED;
}

int
destroy_lock(monet_lock *l)
{
	if (*l == NULL || *l == ptr_nil) return GDK_FAIL;
	MT_lock_destroy((MT_Lock*) *l);
	GDKfree(*l);
	return GDK_SUCCEED;
}


@}
@-
The old code base is wrapped to ease update propagation.
@c
#include "mal.h"
lock_export int lockToStr(char **dst, int *len, ptr *src);
int
lockToStr(char **dst, int *len, ptr *src)
{
	(void) len;		/* fool compiler */
	(void) src;		/* fool compiler */
	if (src == ptr_nil) {
		strcpy(*dst, "nil");
		return 3;
	}
	/* sprintf(*dst,"%o", (ptr)*src); */
	sprintf(*dst, "redo lockToStr");
	return strlen(*dst);
}

lock_export str LCKcreate(monet_lock *l);
str
LCKcreate(monet_lock *l)
{
	create_lock(l);
	return MAL_SUCCEED;
}

lock_export str LCKset(int *res, monet_lock *l);
str
LCKset(int *res, monet_lock *l)
{
	set_lock(l);
	*res = 1;
	return MAL_SUCCEED;
}

lock_export str LCKtry(int *res, monet_lock *l);
str
LCKtry(int *res, monet_lock *l)
{
	try_lock(res, l);
	return MAL_SUCCEED;
}

lock_export str LCKunset(int *res, monet_lock *l);
str
LCKunset(int *res, monet_lock *l)
{
	unset_lock(l);
	*res = 1;
	return MAL_SUCCEED;
}

lock_export str LCKdestroy(int *res, monet_lock *l);
str
LCKdestroy(int *res, monet_lock *l)
{
	destroy_lock(l);
	*res = 1;
	return MAL_SUCCEED;
}

@}
