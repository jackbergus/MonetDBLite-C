@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2006 CWI.
@' All Rights Reserved.

@f mdb
@a Martin Kersten
@v 1
@* The debugger interface
This module provides access to the functionality offered
by the MonetDB debugger and interpreter status.
It is primarilly used in interactive sessions to activate
the debugger at a given point. Furthermore, the instructions
provide the necessary handle to generate information
for post-mortum analysis.

@+ Primary debugging commands
To enable ease of debugging and performance monitoring, the MAL interpreter
comes with a hardwired gdb-like text-based debugger.
A limited set of instructions can be included in the programs themselves,
but beware that debugging has a global effect. Any concurrent user
will be affected by breakpoints being set.
@mal
module mdb;

pattern start():void 
address MDBstart
comment "Start interactive debugger";

pattern stop():void
address MDBstop
comment "Stop the interactive debugger";

pattern inspect(mod:str,fcn:str):void
address MDBinspect
comment "Run the debugger on a specific function";

pattern setTrace(b:bit):void
address MDBsetTrace
comment "Turn on/off tracing of current routine";

pattern setCatch(b:bit):void
address MDBsetCatch
comment "Turn on/off catching exceptions";

pattern setTimer(b:bit):void
address MDBsetTimer
comment "Turn on/off performance timer for debugger";

@+ Decoding exceptions
The exception message produced by the modules
adhere to the structure:
<variable>:<context>:<reason>.
These components can be extracted for further analysis.
@mal
command getException(s:str):str
address MDBgetExceptionVariable
comment "Extract the variable name from the exception message";

command getReason(s:str):str
address MDBgetExceptionReason
comment "Extract the reason from the exception message";

command getContext(s:str):str
address MDBgetExceptionContext
comment "Extract the context string from the exception message";

@+ Display operation code
Part of the debugger operations can also be used independently.
A key tool for analysis of the MAL code is being able to dump
any routine, module. For queries, it is also illustrative to display
the flow graph. [TODO]
@mal
pattern list():void 
address MDBlist
comment "Dump the current routine on standard out.";
pattern list(M:str,F:str):void 
address MDBlist3
comment "Dump the routine M.F on standard out.";

pattern List():void 
address MDBlistDetail
comment "Dump the current routine on standard out.";
pattern List(M:str,F:str):void 
address MDBlist3Detail
comment "Dump the routine M.F on standard out.";

pattern var():void 
address MDBvar
comment "Dump the symboltable of current routine on standard out.";
pattern var(M:str,F:str):void 
address MDBvar3
comment "Dump the symboltable of routine M.F on standard out.";

@+ Interpreter runtime status
The prime scheme to inspect the MAL interpreter status is to use
the MAL debugger directly. However, in case of automatic exception handling
it helps to be able to obtain BAT versions of the critical information,
such as stack frame table, stack trace,
and the instruction(s) where an exception occurred.
The inspection typically occurs in the exception handling part of the
MAL block.

Beware, a large class of internal errors can not easily captured this way.
For example, bus-errors and segmentation faults lead to premature
termination of the process. Similar, creation of the post-mortum
information may fail due to an inconsistent state or insufficient resources.
@mal
pattern getStackDepth():int 
address MDBStkDepth
comment "Return the depth of the calling stack.";

pattern getStackFrame(i:int):bat[:str,:str] 
address MDBgetStackFrameN;
pattern getStackFrame():bat[:str,:str] 
address MDBgetStackFrame
comment "Collect variable binding of current (n-th) stack frame.";
pattern getStackTrace():bat[:void,:str]
address MDBStkTrace;

pattern getDefinition():bat[:void,:str] 
address MDBgetDefinition
comment "Returns a string representation of the current function 
	with typing information attached";

@-
@{
@+ Implementation
@include prelude.mx
@h
#ifdef _MDB_H
#endif /* _MDB_H */
@c
#include "gdk.h"
#include <stdarg.h>
#include <time.h>
#include "mal_resolve.h"
#include "mal_client.h"
#include "mal_exception.h"
#include "mal_debugger.h"
#include "mal_interpreter.h"
#include "mal_namespace.h"

#ifdef _MSC_VER
#ifndef LIBMDB
#define mdb_export extern __declspec(dllimport)
#else
#define mdb_export extern __declspec(dllexport)
#endif
#else
#define mdb_export extern
#endif

mdb_export str MDBstart(MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
mdb_export str MDBstop(MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
mdb_export str MDBinspect(MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
mdb_export str MDBsetTrace(MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
mdb_export str MDBsetCatch(MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
mdb_export str MDBsetTimer(MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
mdb_export str MDBgetExceptionVariable(str *ret, str *msg);
mdb_export str MDBgetExceptionReason(str *ret, str *msg);
mdb_export str MDBgetExceptionContext(str *ret, str *msg);
mdb_export str MDBlist(MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
mdb_export str MDBlist3(MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
mdb_export str MDBlistDetail(MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
mdb_export str MDBlist3Detail(MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
mdb_export str MDBvar(MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
mdb_export str MDBvar3(MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
mdb_export str MDBStkDepth(MalBlkPtr mb, MalStkPtr s, InstrPtr p);
mdb_export str MDBgetStackFrameN(MalBlkPtr m, MalStkPtr s, InstrPtr p);
mdb_export str MDBgetStackFrame(MalBlkPtr m, MalStkPtr s, InstrPtr p);
mdb_export str MDBStkTrace(MalBlkPtr m, MalStkPtr s, InstrPtr p);
mdb_export str MDBgetDefinition(MalBlkPtr m, MalStkPtr stk, InstrPtr p);

@-
The primary debugger controls
@c
#define MDBstatus(X) \
	if( stk->cmd && X==0 ) \
		stream_printf(cntxt->fdout,"#Monet Debugger off\n"); \
	else if(stk->cmd==0 && X) \
		stream_printf(cntxt->fdout,"#Monet Debugger on\n");

str
MDBtoggle(MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	Client cntxt = MCgetClient();
	int b = 0;

	(void) mb;		/* still unused */
	if (p->argc == 1) {
		/* Toggle */
		stk->cmd = stk->cmd ? 0 : 's';
		cntxt->itrace = cntxt->itrace ? 0 : 's';
		if (stk->cmd)
			MDBdelay = 1;	/* wait for real command */
		if (stk->up)
			stk->up->cmd = 0;
		return MAL_SUCCEED;
	}
	if (p->argc > 1) {
		b = *(int *) getArgReference(stk, p, 1);
	} else
		b = stk->cmd;
	if (b)
		MDBdelay = 1;	/* wait for real command */
	MDBstatus(b);
	stk->cmd = b ? 'n' : 0;
	if (stk->up)
		stk->up->cmd = b ? 'n' : 0;
	cntxt->itrace = b ? 'n' : 0;
	return MAL_SUCCEED;
}

str
MDBstart(MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	Client cntxt = MCgetClient();

	stk->cmd = 'n';
	cntxt->itrace = 'n';
	cntxt->debugOptimizer= TRUE;
	(void) mb;
	(void) p;
	return MAL_SUCCEED;
}

str
MDBstop(MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	Client cntxt = MCgetClient();

	stk->cmd = 0;
	cntxt->itrace = 0;
	cntxt->debugOptimizer= FALSE;
	(void) mb;
	(void) p;
	return MAL_SUCCEED;
}

void
MDBtraceFlag(Client cntxt, MalStkPtr stk, int b)
{
	if (b) {
		cntxt->timer = GDKusec();
		stk->cmd = b;
		cntxt->itrace = b;
	} else {
		cntxt->timer = 0;
		stk->cmd = 0;
		cntxt->itrace = 0;
	}
}

str
MDBsetTrace(MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	int b;

	(void) mb;		/* still unused */
	b = *(chr *) getArgReference(stk, p, 1);
	MDBtraceFlag(MCgetClient(), stk, (b? (int) 't':0));
	return MAL_SUCCEED;
}

str
MDBsetCatch(MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	int b;
	Client cntxt= MCgetClient();

	(void) mb;		/* still unused */
	b = *(chr *) getArgReference(stk, p, 1);
	stk->cmd = cntxt->itrace = (b? (int) 'C':0);
	return MAL_SUCCEED;
}

str
MDBsetTimer(MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	Client cntxt = MCgetClient();
	int b;

	(void) mb;		/* still unused */
	b = *(chr *) getArgReference(stk, p, 1);
	cntxt->timer = b ? GDKusec() : 0;
	return MAL_SUCCEED;
}

str
MDBinspect(MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	str modnme;
	str fcnnme;
	Module scope = NULL;
	Symbol s = NULL;
	Client c = MCgetClient();

	if (stk != 0) {
		modnme = (str) getArgValue(stk, p, 1);
		fcnnme = (str) getArgValue(stk, p, 2);
	} else {
		modnme = getArgDefault(mb, p, 1);
		fcnnme = getArgDefault(mb, p, 2);
	}

	scope = findModule(c->nspace, putName(modnme, strlen(modnme)));

	if (scope)
		s = findSymbolInModule(scope, putName(fcnnme, strlen(fcnnme)));

	if (s == NULL)
		return throwMessage("mdb.inspect", "Could not find function");
	return runMALDebugger(s);
}

@+ Variables and stack information
The variable information can be turned into a BAT for inspection as well.
@c

static int
getStkDepth(MalStkPtr s)
{
	int i = 0;

	while (s != 0) {
		i++;
		s = s->up;
	}
	return i;
}

str
MDBStkDepth(MalBlkPtr mb, MalStkPtr s, InstrPtr p)
{
	int *ret = (int *) getArgReference(s, p, 0);

	(void) mb;		/* fool compiler */
	*ret = getStkDepth(s);
	return MAL_SUCCEED;
}

str
MDBgetFrame(BAT *b, MalBlkPtr mb, MalStkPtr s, int depth)
{
	ValPtr v;
	int i;
	char *buf = 0;

	if (depth > 0)
		return MDBgetFrame(b, mb, s->up, depth - 1);
	if (s != 0)
		for (i = 0; i < s->stktop; i++, v++) {
			v = &s->stk[i];
			ATOMformat(v->vtype, VALget(v), &buf);
			BUNins(b, getVarName(mb, i), buf, FALSE);
		}
	return MAL_SUCCEED;
}

str
MDBgetStackFrame(MalBlkPtr m, MalStkPtr s, InstrPtr p)
{
	int *ret = (int *) getArgReference(s, p, 0);
	BAT *b = BATnew(TYPE_str, TYPE_str, 256);

	if (b == 0)
		return throwMessage("mdb.getStackFrame", "Failed to create BAT");
	@:Pseudo(view,stk,frame)@
	return MDBgetFrame(b, m, s, 0);
}

str
MDBgetStackFrameN(MalBlkPtr m, MalStkPtr s, InstrPtr p)
{
	int n, *ret = (int *) getArgReference(s, p, 0);
	BAT *b = BATnew(TYPE_str, TYPE_str, 256);

	n = *(int *) getArgReference(s, p, 1);
	if (n < 0 || n >= getStkDepth(s))
		return throwMessage("mdb.getStackFrame", "Illegal depth.");
	@:Pseudo(view,stk,frame)@
	return MDBgetFrame(b, m, s, n);
}

str
MDBStkTrace(MalBlkPtr m, MalStkPtr s, InstrPtr p)
{
	BAT *b = BATnew(TYPE_int, TYPE_str, 256);
	str msg;
	char buf[8192];
	int *ret = (int *) getArgReference(s, p, 0);
	int k = 0,pc;

	msg = call2str(MCgetClient(),s->blk, s, pc=getPC(m, p));
	snprintf(buf,8192,"%s at %s.%s[%d]", msg+5,
		getModuleId(getInstrPtr(m,0)),
		getFunctionId(getInstrPtr(m,0)), pc);
	BUNins(b, &k, buf, FALSE);
	GDKfree(msg);

	for (s = s->up, k++; s != NULL; s = s->up, k++) {
		msg = call2str(MCgetClient(),s->blk, s, s->pcup);
		snprintf(buf,8192,"%s at %s.%s[%d]", msg+5,
			getModuleId(getInstrPtr(s->blk,0)),
			getFunctionId(getInstrPtr(s->blk,0)), s->pcup);
		BUNins(b, &k, buf, FALSE);
		GDKfree(msg);
	}
	if (!(b->batDirty&2)) b = BATsetaccess(b, BAT_READ);
	@:Pseudo(view,stk,trace)@
	return MAL_SUCCEED;
}

@+ Display routines
@c
str
MDBlist(MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	Client c = MCgetClient();

	(void) p;
	(void) stk;
	printFunction(c->fdout, mb, LIST_INPUT);
	return MAL_SUCCEED;
}

str
MDBlist3(MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	str modnme = (str) getArgValue(stk, p, 1);
	str fcnnme = (str) getArgValue(stk, p, 2);
	Symbol s = NULL;
	Client c = MCgetClient();

	s = findMALSymbol(putName(modnme, strlen(modnme)), putName(fcnnme, strlen(fcnnme)));
	if (s == NULL)
		GDKerror("mdb.list:Could not find %s.%s\n", modnme, fcnnme);
	else
		printFunction(c->fdout, s->def, LIST_INPUT);
	(void) mb;		/* fool compiler */
	return NULL;
}

str
MDBlistDetail(MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	Client c = MCgetClient();

	(void) p;
	(void) stk;
	printFunction(c->fdout, mb, LIST_MAL_ALL);
	return MAL_SUCCEED;
}

str
MDBlist3Detail(MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	str modnme = (str) getArgValue(stk, p, 1);
	str fcnnme = (str) getArgValue(stk, p, 2);
	Symbol s = NULL;
	Client c = MCgetClient();

	s = findMALSymbol(putName(modnme, strlen(modnme)), putName(fcnnme, strlen(fcnnme)));
	if (s == NULL)
		GDKerror("mdb.list:Could not find %s.%s\n", modnme, fcnnme);
	else
		printFunction(c->fdout, s->def, LIST_MAL_ALL);
	(void) mb;		/* fool compiler */
	return NULL;
}

str
MDBvar(MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	Client c = MCgetClient();

	(void) p;
	(void) stk;
	printStack(c->fdout, mb, stk,0);
	return MAL_SUCCEED;
}

str
MDBvar3(MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	str modnme = (str) getArgValue(stk, p, 1);
	str fcnnme = (str) getArgValue(stk, p, 2);
	Symbol s = NULL;
	Client c = MCgetClient();

	s = findMALSymbol(putName(modnme, strlen(modnme)), putName(fcnnme, strlen(fcnnme)));
	if (s == NULL)
		GDKerror("mdb.var:Could not find %s.%s\n", modnme, fcnnme);
	else
		printStack(c->fdout, s->def, (s->def == mb ? stk : 0),0);
	(void) mb;
	return NULL;
}

@-
It is illustrative to dump the code when you
have encountered an error.
@c
str
MDBgetDefinition(MalBlkPtr m, MalStkPtr stk, InstrPtr p)
{
	int i, *ret = (int *) getArgReference(stk, p, 0);
	str ps;
	BAT *b = BATnew(TYPE_int, TYPE_str, 256);

	if (b == 0)
		return throwMessage("mdb.getDefinition", "Failed to create BAT");

	for (i = 0; i < m->stop; i++) {
		ps = instruction2str(m, getInstrPtr(m, i), 1);
		BUNins(b, &i, ps, FALSE);
		GDKfree(ps);
	}
	if (!(b->batDirty&2)) b = BATsetaccess(b, BAT_READ);
	@:Pseudo(view,fcn,stmt)@

	return MAL_SUCCEED;
}

str
MDBgetExceptionVariable(str *ret, str *msg)
{
	str tail;

	tail = strchr(*msg, ':');
	if (tail == 0)
		return throwMessage("mdb.getExceptionVariable", "Could not find it");

	*tail = 0;
	*ret = GDKstrdup(*msg);
	*tail = ':';
	return MAL_SUCCEED;
}

str
MDBgetExceptionContext(str *ret, str *msg)
{
	str tail, tail2;

	tail = strchr(*msg, ':');
	if (tail == 0)
		return throwMessage("mdb.getExceptionContext", "Could not find it");
	tail2 = strchr(tail + 1, ':');
	if (tail2 == 0)
		return throwMessage("mdb.getExceptionContext", "Could not find it");

	*tail2 = 0;
	*ret = GDKstrdup(tail + 1);
	*tail2 = ':';
	return MAL_SUCCEED;
}

str
MDBgetExceptionReason(str *ret, str *msg)
{
	str tail;

	tail = strchr(*msg, ':');
	if (tail == 0)
		return throwMessage("mdb.getExceptionReason", "Could not find it");
	tail = strchr(tail + 1, ':');
	if (tail == 0)
		return throwMessage("mdb.getExceptionReason", "Could not find it");

	*ret = GDKstrdup(tail + 1);
	return MAL_SUCCEED;
}

@}
