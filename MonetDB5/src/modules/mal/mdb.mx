@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
@' Copyright August 2008- MonetDB B.V.
@' All Rights Reserved.

@f mdb
@a Martin Kersten
@v 1
@+ MAL debugger interface
This module provides access to the functionality offered
by the MonetDB debugger and interpreter status.
It is primarilly used in interactive sessions to activate
the debugger at a given point. Furthermore, the instructions
provide the necessary handle to generate information
for post-mortum analysis.

To enable ease of debugging and performance monitoring, the MAL interpreter
comes with a hardwired gdb-like text-based debugger.
A limited set of instructions can be included in the programs themselves,
but beware that debugging has a global effect. Any concurrent user
will be affected by breakpoints being set.

The prime scheme to inspect the MAL interpreter status is to use
the MAL debugger directly. However, in case of automatic exception handling
it helps to be able to obtain BAT versions of the critical information,
such as stack frame table, stack trace,
and the instruction(s) where an exception occurred.
The inspection typically occurs in the exception handling part of the
MAL block.

Beware, a large class of internal errors can not easily captured this way.
For example, bus-errors and segmentation faults lead to premature
termination of the process. Similar, creation of the post-mortum
information may fail due to an inconsistent state or insufficient resources.

@mal
module mdb;

pattern start():void 
address MDBstart
comment "Start interactive debugger";
pattern start(clientid:int):void 
address MDBstart
comment "Start interactive debugger on a client";
pattern start(mod:str,fcn:str):void 
address MDBstartFactory
comment "Start interactive debugger on a running factory";

pattern stop():void
address MDBstop
comment "Stop the interactive debugger";

pattern inspect(mod:str,fcn:str):void
address MDBinspect
comment "Run the debugger on a specific function";

command modules():bat[:int,:str] 
address CMDmodules
comment "List available modules";

pattern setTrace(b:bit):void
address MDBsetTrace
comment "Turn on/off tracing of current routine";

pattern setTrace(b:str):void
address MDBsetVarTrace
comment "Turn on/off tracing of a variable ";

pattern setCatch(b:bit):void
address MDBsetCatch
comment "Turn on/off catching exceptions";

pattern setThread(b:bit):void
address MDBsetThread
comment "Turn on/off thread identity for debugger";

pattern setTimer(b:bit):void
address MDBsetTimer
comment "Turn on/off performance timer for debugger";

pattern setMemoryTrace(b:bit):void
address MDBsetBigfoot
comment "Turn on/off memory foot print tracer for debugger";

pattern setFlow(b:bit):void
address MDBsetFlow
comment "Turn on/off memory flow debugger";

command setMemory(b:bit):void
address MDBsetMemory
comment "Turn on/off memory statistics tracing.";

pattern setIO(b:bit):void
address MDBsetIO
comment "Turn on/off io statistics tracing";

pattern setCount(b:bit):void
address MDBsetCount
comment "Turn on/off bat count statistics tracing";

command getDebug():int
address MDBgetDebug
comment "Get the kernel debugging bit-set.
See the MonetDB configuration file for details";

command setDebug(flg:str):int
address MDBsetDebugStr
comment "Set the kernel debugging bit-set and return its previous value.
The recognized options are: threads, memory, properties,
io, transactions, modules, algorithms, estimates, xproperties";
command setDebug(flg:int):int
address MDBsetDebug
comment "Set the kernel debugging bit-set and return its previous value.";

command getException(s:str):str
address MDBgetExceptionVariable
comment "Extract the variable name from the exception message";
command getReason(s:str):str
address MDBgetExceptionReason
comment "Extract the reason from the exception message";
command getContext(s:str):str
address MDBgetExceptionContext
comment "Extract the context string from the exception message";

pattern list():void
address MDBlist
comment "Dump the current routine on standard out.";
pattern listMapi():void
address MDBlistMapi
comment "Dump the current routine on standard out with Mapi prefix.";
pattern list(M:str,F:str):void
address MDBlist3
comment "Dump the routine M.F on standard out.";
pattern List():void 
address MDBlistDetail
comment "Dump the current routine on standard out.";
pattern List(M:str,F:str):void 
address MDBlist3Detail
comment "Dump the routine M.F on standard out.";
pattern var():void 
address MDBvar
comment "Dump the symboltable of current routine on standard out.";
pattern var(M:str,F:str):void 
address MDBvar3
comment "Dump the symboltable of routine M.F on standard out.";
pattern lifespan(M:str,F:str):void
address MDBlifespan
comment "Dump the current routine lifespan information on standard out.";

pattern grab(id:int):void
address MDBgrabClient
comment "Stop and debug another client process.";

pattern dot(M:str,F:str,s:str):void 
address MDBshowFlowGraph
comment "Dump the data flow of the function 
	M.F in a format recognizable by the 
	command 'dot' on the file s";

pattern getStackDepth():int 
address MDBStkDepth
comment "Return the depth of the calling stack.";

pattern getStackFrame(i:int):bat[:str,:str] 
address MDBgetStackFrameN;
pattern getStackFrame():bat[:str,:str] 
address MDBgetStackFrame
comment "Collect variable binding of current (n-th) stack frame.";
pattern getStackTrace():bat[:void,:str]
address MDBStkTrace;

pattern dump()
address MDBdump
comment "Dump instruction, stacktrace, and stack";

pattern getDefinition():bat[:void,:str] 
address MDBgetDefinition
comment "Returns a string representation of the current function 
	with typing information attached";

@-
@{
@+ Implementation
@include prelude.mx
@h
#ifndef _MDB_H
#define _MDB_H
#endif /* _MDB_H */
@c
#include "mal_config.h"
#include "gdk.h"
#include <stdarg.h>
#include <time.h>
#include "mal_resolve.h"
#include "mal_linker.h"
#include "mal_client.h"
#include "mal_exception.h"
#include "mal_debugger.h"
#include "mal_interpreter.h"
#include "mal_namespace.h"

#ifdef WIN32
#ifndef LIBMDB
#define mdb_export extern __declspec(dllimport)
#else
#define mdb_export extern __declspec(dllexport)
#endif
#else
#define mdb_export extern
#endif

mdb_export str MDBstart(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
mdb_export str MDBstartFactory(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
mdb_export str MDBstop(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
mdb_export str MDBinspect(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
mdb_export str CMDmodules(int *bid);
mdb_export str MDBsetTrace(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
mdb_export str MDBsetVarTrace(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
mdb_export str MDBgetDebug(int *ret);
mdb_export str MDBsetDebug(int *ret, int *flg);
mdb_export str MDBsetDebugStr(int *ret, str *nme);
mdb_export str MDBsetCatch(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
mdb_export str MDBsetTimer(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
mdb_export str MDBsetThread(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
mdb_export str MDBsetBigfoot(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
mdb_export str MDBsetFlow(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
mdb_export str MDBsetMemory(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
mdb_export str MDBsetIO(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
mdb_export str MDBsetCount(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
mdb_export str MDBgetExceptionVariable(str *ret, str *msg);
mdb_export str MDBgetExceptionReason(str *ret, str *msg);
mdb_export str MDBgetExceptionContext(str *ret, str *msg);
mdb_export str MDBlist(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
mdb_export str MDBlistMapi(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
mdb_export str MDBshowFlowGraph(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
mdb_export str MDBlist3(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
mdb_export str MDBlistDetail(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
mdb_export str MDBlist3Detail(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
mdb_export str MDBlifespan(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
mdb_export str MDBvar(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
mdb_export str MDBvar3(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
mdb_export str MDBStkDepth(Client cntxt, MalBlkPtr mb, MalStkPtr s, InstrPtr p);
mdb_export str MDBgetStackFrameN(Client cntxt, MalBlkPtr m, MalStkPtr s, InstrPtr p);
mdb_export str MDBgetStackFrame(Client cntxt, MalBlkPtr m, MalStkPtr s, InstrPtr p);
mdb_export str MDBStkTrace(Client cntxt, MalBlkPtr m, MalStkPtr s, InstrPtr p);
mdb_export str MDBgetDefinition(Client cntxt, MalBlkPtr m, MalStkPtr stk, InstrPtr p);
mdb_export str MDBgrabClient(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
mdb_export str MDBdump(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
mdb_export str MDBdummy(int *ret);

@-
The primary debugger controls
@c
#define MDBstatus(X) \
	if( stk->cmd && X==0 ) \
		stream_printf(cntxt->fdout,"#Monet Debugger off\n"); \
	else if(stk->cmd==0 && X) \
		stream_printf(cntxt->fdout,"#Monet Debugger on\n");

str
MDBtoggle(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	int b = 0;

	(void) mb;		/* still unused */
	if (p->argc == 1) {
		/* Toggle */
		stk->cmd = stk->cmd ? 0 : 's';
		cntxt->itrace = cntxt->itrace ? 0 : 's';
		if (stk->cmd)
			MDBdelay = 1;	/* wait for real command */
		if (stk->up)
			stk->up->cmd = 0;
		return MAL_SUCCEED;
	}
	if (p->argc > 1) {
		b = *(int *) getArgReference(stk, p, 1);
	} else
		b = stk->cmd;
	if (b)
		MDBdelay = 1;	/* wait for real command */
	MDBstatus(b);
	stk->cmd = b ? 'n' : 0;
	if (stk->up)
		stk->up->cmd = b ? 'n' : 0;
	cntxt->itrace = b ? 'n' : 0;
	return MAL_SUCCEED;
}

str
MDBstart(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	Client c;
	int pid;

	if( p->argc == 2){
		/* debug running process */
		pid = *(int *) getArgReference(stk, p, 1);
		if( pid< 0 || pid > MAL_MAXCLIENTS || mal_clients[pid].mode <= FINISHING)
			throw(MAL, "mdb.start", "Illegal process id");
		c= mal_clients+pid;
		/* make client aware of being debugged */
		cntxt= c;
	} else
		stk->cmd = 'n';
	cntxt->itrace = 'n';
	cntxt->debugOptimizer= TRUE;
	(void) mb;
	(void) p;
	return MAL_SUCCEED;
}

str
MDBstartFactory(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	(void) cntxt;
	(void) mb;
	(void) stk;
	(void) p;
		throw(MAL, "mdb.start", "Debugging factory not yet available");
}

str
MDBstop(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	stk->cmd = 0;
	cntxt->itrace = 0;
	cntxt->debugOptimizer= FALSE;
	stream_printf(cntxt->fdout,"mdb>#EOD\n");
	(void) mb;
	(void) p;
	return MAL_SUCCEED;
}

void
MDBtraceFlag(Client cntxt, MalStkPtr stk, int b)
{
	if (b) {
		cntxt->timer = GDKusec();
		stk->cmd = b;
		cntxt->itrace = b;
	} else {
		cntxt->timer = 0;
		stk->cmd = 0;
		cntxt->itrace = 0;
	}
}

str
MDBsetTrace(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	int b;

	(void) cntxt;
	(void) mb;		/* still unused */
	b = *(chr *) getArgReference(stk, p, 1);
	MDBtraceFlag(cntxt, stk, (b? (int) 't':0));
	return MAL_SUCCEED;
}

str
MDBsetVarTrace(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	str v;

	(void) cntxt;
	v = *(str *) getArgReference(stk, p, 1);
	mdbSetBreakRequest(cntxt, mb, v, 't');
	stk->cmd = 'c';
	cntxt->itrace = 'c';
	return MAL_SUCCEED;
}

str
MDBgetDebug(int *ret)
{
    *ret = GDKdebug;
    return MAL_SUCCEED;
}

str
MDBsetDebug(int *ret, int *flg)
{
    *ret = GDKdebug;
    GDKdebug = *flg;
    return MAL_SUCCEED;
}
str
MDBsetDebugStr(int *ret, str *flg)
{
    *ret = GDKdebug;
	if( strcmp("threads",*flg)==0)
		GDKdebug |= GRPthreads;
	if( strcmp("memory",*flg)==0)
		GDKdebug |= GRPmemory;
	if( strcmp("properties",*flg)==0)
		GDKdebug |= GRPproperties;
	if( strcmp("io",*flg)==0)
		GDKdebug |= GRPio;
	if( strcmp("transactions",*flg)==0)
		GDKdebug |= GRPtransactions;
	if( strcmp("modules",*flg)==0)
		GDKdebug |= GRPmodules;
	if( strcmp("algorithms",*flg)==0)
		GDKdebug |= GRPalgorithms;
	if( strcmp("performance",*flg)==0)
		GDKdebug |= GRPperformance;
	if( strcmp("xproperties",*flg)==0)
		GDKdebug |= GRPxproperties;
    return MAL_SUCCEED;
}

str
MDBsetCatch(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	int b;

	(void) mb;		/* still unused */
	b = *(chr *) getArgReference(stk, p, 1);
	stk->cmd = cntxt->itrace = (b? (int) 'C':0);
	return MAL_SUCCEED;
}

str
MDBsetTimer(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	bit *flag= (bit*) getArgReference(stk,pci,1);

	(void) mb;
	if( *flag)
		cntxt->flags |= timerFlag;
	else
		cntxt->flags &= ~timerFlag;
	cntxt->timer= GDKusec();
	return MAL_SUCCEED;
}

str
MDBsetThread(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	bit *flag= (bit*) getArgReference(stk,pci,1);

	(void) mb;
	if( *flag)
		cntxt->flags |= threadFlag;
	else
		cntxt->flags &= ~threadFlag;
	return MAL_SUCCEED;
}

str
MDBsetBigfoot(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	bit *flag= (bit*) getArgReference(stk,pci,1);

	(void) mb;
	if( *flag)
		cntxt->flags |= bigfootFlag;
	else
		cntxt->flags &= ~bigfootFlag;
	return MAL_SUCCEED;
}

str
MDBsetFlow(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	bit *flag= (bit*) getArgReference(stk,pci,1);

	(void) mb;
	if( *flag)
		cntxt->flags |= flowFlag;
	else
		cntxt->flags &= ~flowFlag;
	return MAL_SUCCEED;
}

str
MDBsetMemory(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	bit *flag= (bit*) getArgReference(stk,pci,1);

	(void) mb;

	if( *flag)
		cntxt->flags |= memoryFlag;
	else
		cntxt->flags &= ~memoryFlag;
	return MAL_SUCCEED;
}

str
MDBsetIO(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	bit *flag= (bit*) getArgReference(stk,pci,1);

	(void) mb;

	if( *flag)
		cntxt->flags |= ioFlag;
	else
		cntxt->flags &= ~ioFlag;
	return MAL_SUCCEED;
}

str
MDBsetCount(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	bit *flag= (bit*) getArgReference(stk,pci,1);

	(void) mb;
	if( *flag)
		cntxt->flags |= cntFlag;
	else
		cntxt->flags &= ~cntFlag;
	return MAL_SUCCEED;
}

str
MDBinspect(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	str modnme;
	str fcnnme;
	Symbol s = NULL;

	(void) cntxt;
	if (stk != 0) {
		modnme = (str) getArgValue(stk, p, 1);
		fcnnme = (str) getArgValue(stk, p, 2);
	} else {
		modnme = getArgDefault(mb, p, 1);
		fcnnme = getArgDefault(mb, p, 2);
	}

	s = findSymbol(putName(modnme, strlen(modnme)), putName(fcnnme, strlen(fcnnme)));

	if (s == NULL)
		throw(MAL, "mdb.inspect", "Could not find function");
	return runMALDebugger(cntxt, s);
}

@+ Variables and stack information
The variable information can be turned into a BAT for inspection as well.
@c

static int
getStkDepth(MalStkPtr s)
{
	int i = 0;

	while (s != 0) {
		i++;
		s = s->up;
	}
	return i;
}

str
MDBStkDepth(Client cntxt, MalBlkPtr mb, MalStkPtr s, InstrPtr p)
{
	int *ret = (int *) getArgReference(s, p, 0);

	(void) cntxt;
	(void) mb;		/* fool compiler */
	*ret = getStkDepth(s);
	return MAL_SUCCEED;
}

str
MDBgetFrame(BAT *b, Client cntxt, MalBlkPtr mb, MalStkPtr s, int depth)
{
	ValPtr v;
	int i;
	char *buf = 0;

	if (depth > 0)
		return MDBgetFrame(b, cntxt, mb, s->up, depth - 1);
	if (s != 0)
		for (i = 0; i < s->stktop; i++, v++) {
			v = &s->stk[i];
			ATOMformat(v->vtype, VALget(v), &buf);
			BUNins(b, getVarName(mb, i), buf, FALSE);
		}
	return MAL_SUCCEED;
}

str
MDBgetStackFrame(Client cntxt, MalBlkPtr m, MalStkPtr s, InstrPtr p)
{
	int *ret = (int *) getArgReference(s, p, 0);
	BAT *b = BATnew(TYPE_str, TYPE_str, 256);

	if (b == 0)
		throw(MAL, "mdb.getStackFrame", "Failed to create BAT");
	@:Pseudo(view,stk,frame)@
	return MDBgetFrame(b, cntxt, m, s, 0);
}

str
MDBgetStackFrameN(Client cntxt, MalBlkPtr m, MalStkPtr s, InstrPtr p)
{
	int n, *ret = (int *) getArgReference(s, p, 0);
	BAT *b = BATnew(TYPE_str, TYPE_str, 256);

	n = *(int *) getArgReference(s, p, 1);
	if (n < 0 || n >= getStkDepth(s))
		throw(MAL, "mdb.getStackFrame", "Illegal depth.");
	@:Pseudo(view,stk,frame)@
	return MDBgetFrame(b, cntxt, m, s, n);
}

str
MDBStkTrace(Client cntxt, MalBlkPtr m, MalStkPtr s, InstrPtr p)
{
	BAT *b = BATnew(TYPE_int, TYPE_str, 256);
	str msg;
	char *buf;
	int *ret = (int *) getArgReference(s, p, 0);
	int k = 0,pc;
	size_t len,l;

	(void) cntxt;
	msg = call2str(s->blk, s, pc=getPC(m, p),cntxt->flags);
	len = strlen(msg);
	buf = (char*) GDKmalloc(len +1024);
	snprintf(buf,len+1024,"%s at %s.%s[%d]", msg,
		getModuleId(getInstrPtr(m,0)),
		getFunctionId(getInstrPtr(m,0)), pc);
	BUNins(b, &k, buf, FALSE);
	GDKfree(msg);

	for (s = s->up, k++; s != NULL; s = s->up, k++) {
		msg = call2str(s->blk, s, s->pcup,cntxt->flags);
		l = strlen(msg);
		if (l>len){
			GDKfree(buf);
			len=l;
			buf = (char*) GDKmalloc(len +1024);
		}
		snprintf(buf,len+1024,"%s at %s.%s[%d]", msg,
			getModuleId(getInstrPtr(s->blk,0)),
			getFunctionId(getInstrPtr(s->blk,0)), s->pcup);
		BUNins(b, &k, buf, FALSE);
		GDKfree(msg);
	}
	GDKfree(buf);
	if (!(b->batDirty&2)) b = BATsetaccess(b, BAT_READ);
	@:Pseudo(view,stk,trace)@
	return MAL_SUCCEED;
}

@+ Display routines
@c
str
MDBlifespan(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	Lifespan span= newLifespan(mb);
	str modnme;
	str fcnnme;
	Symbol s = NULL;

	(void) cntxt;
	if (stk != 0) {
		modnme = (str) getArgValue(stk, p, 1);
		fcnnme = (str) getArgValue(stk, p, 2);
	} else {
		modnme = getArgDefault(mb, p, 1);
		fcnnme = getArgDefault(mb, p, 2);
	}

	s = findSymbol(putName(modnme, strlen(modnme)), putName(fcnnme, strlen(fcnnme)));

	if (s == NULL)
		throw(MAL, "mdb.inspect", "Could not find function");
	setLifespan(s->def,span);
	debugLifespan(s->def,span);
	GDKfree(span);
	(void) p;
	(void) stk;
	return MAL_SUCCEED;
}

str
MDBlist(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	(void) p;
	(void) stk;
	printFunction(cntxt->fdout, mb, 0,  LIST_MAL_INSTR | LIST_MAL_UDF );
	return MAL_SUCCEED;
}

str
MDBlistMapi(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	(void) p;
	(void) stk;
	printFunction(cntxt->fdout, mb, 0,  LIST_MAL_INSTR | LIST_MAL_UDF | LIST_MAPI);
	return MAL_SUCCEED;
}

str
MDBlist3(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	str modnme = (str) getArgValue(stk, p, 1);
	str fcnnme = (str) getArgValue(stk, p, 2);
	Symbol s = NULL;

	s = findSymbol(getName(modnme,strlen(modnme)), putName(fcnnme, strlen(fcnnme)));
	if (s == NULL)
		showException(MAL,"mdb.list","Could not find %s.%s", modnme, fcnnme);
	else
		printFunction(cntxt->fdout, s->def, 0,  LIST_MAL_INSTR | LIST_MAL_UDF );
	(void) mb;		/* fool compiler */
	return MAL_SUCCEED;
}

str
MDBlistDetail(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	(void) p;
	(void) stk;
	printFunction(cntxt->fdout, mb, 0, LIST_MAL_INSTR | LIST_MAL_UDF | LIST_MAL_PROPS | LIST_MAL_DETAIL);
	return MAL_SUCCEED;
}

str
MDBlist3Detail(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	str modnme = (str) getArgValue(stk, p, 1);
	str fcnnme = (str) getArgValue(stk, p, 2);
	Symbol s = NULL;

	s = findSymbol(getName(modnme,strlen(modnme)), putName(fcnnme, strlen(fcnnme)));
	if (s == NULL)
		showException(MAL,"mdb.list","Could not find %s.%s", modnme, fcnnme);
	else
		printFunction(cntxt->fdout, s->def, 0,  LIST_MAL_INSTR | LIST_MAL_UDF | LIST_MAL_PROPS | LIST_MAL_DETAIL);
	(void) mb;		/* fool compiler */
	return NULL;
}

str
MDBvar(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	(void) p;
	(void) stk;
	printStack(cntxt->fdout, mb, stk);
	return MAL_SUCCEED;
}

str
MDBvar3(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	str modnme = (str) getArgValue(stk, p, 1);
	str fcnnme = (str) getArgValue(stk, p, 2);
	Symbol s = NULL;

	s = findSymbol(getName(modnme,strlen(modnme)), putName(fcnnme, strlen(fcnnme)));
	if (s == NULL)
		showException(MAL,"mdb.var","Could not find %s.%s", modnme, fcnnme);
	else
		printStack(cntxt->fdout, s->def, (s->def == mb ? stk : 0));
	(void) mb;
	return NULL;
}

@-
It is illustrative to dump the code when you
have encountered an error.
@c
str
MDBgetDefinition(Client cntxt, MalBlkPtr m, MalStkPtr stk, InstrPtr p)
{
	int i, *ret = (int *) getArgReference(stk, p, 0);
	str ps;
	BAT *b = BATnew(TYPE_int, TYPE_str, 256);

	(void) cntxt;
	if (b == 0)
		throw(MAL, "mdb.getDefinition", "Failed to create BAT");

	for (i = 0; i < m->stop; i++) {
		ps = instruction2str(m,0, getInstrPtr(m, i), 1);
		BUNins(b, &i, ps, FALSE);
		GDKfree(ps);
	}
	if (!(b->batDirty&2)) b = BATsetaccess(b, BAT_READ);
	@:Pseudo(view,fcn,stmt)@

	return MAL_SUCCEED;
}

str
MDBgetExceptionVariable(str *ret, str *msg)
{
	str tail;

	tail = strchr(*msg, ':');
	if (tail == 0)
		throw(MAL, "mdb.getExceptionVariable", "Could not find it");

	*tail = 0;
	*ret = GDKstrdup(*msg);
	*tail = ':';
	return MAL_SUCCEED;
}

str
MDBgetExceptionContext(str *ret, str *msg)
{
	str tail, tail2;

	tail = strchr(*msg, ':');
	if (tail == 0)
		throw(MAL, "mdb.getExceptionContext", "Could not find it");
	tail2 = strchr(tail + 1, ':');
	if (tail2 == 0)
		throw(MAL, "mdb.getExceptionContext", "Could not find it");

	*tail2 = 0;
	*ret = GDKstrdup(tail + 1);
	*tail2 = ':';
	return MAL_SUCCEED;
}

str
MDBgetExceptionReason(str *ret, str *msg)
{
	str tail;

	tail = strchr(*msg, ':');
	if (tail == 0)
		throw(MAL, "mdb.getExceptionReason", "Could not find it");
	tail = strchr(tail + 1, ':');
	if (tail == 0)
		throw(MAL, "mdb.getExceptionReason", "Could not find it");

	*ret = GDKstrdup(tail + 1);
	return MAL_SUCCEED;
}


str
MDBshowFlowGraph(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	str fname;
	str modnme;
	str fcnnme;
	Symbol s = NULL;

	(void)cntxt;
	if (stk != 0) {
		modnme = (str) getArgValue(stk, p, 1);
		fcnnme = (str) getArgValue(stk, p, 2);
		fname = (str) getArgValue(stk, p, 3);
	} else {
		modnme = getArgDefault(mb, p, 1);
		fcnnme = getArgDefault(mb, p, 2);
		fname = getArgDefault(mb, p, 3);
	}

	s = findSymbol(getName(modnme,strlen(modnme)), putName(fcnnme, strlen(fcnnme)));

	if (s == NULL) {
		char buf[1024];
		snprintf(buf,1024, "Could not find %s.%s\n", modnme, fcnnme);
		throw(MAL, "mdb.dot", buf);
	}
	showFlowGraph(s->def, stk, fname);
	return MAL_SUCCEED;
}
@-
Grab a client process by exchange of streams
@c
str
MDBgrabClient(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	Client c;
	ClientRec old;
	int *id = (int*) getArgReference(stk,pci,1);

	(void) mb;
	old= *cntxt;

	if( *id<0 || *id>= MAL_MAXCLIENTS)
		throw(MAL,"clients.grab","No client process");
	fprintf(stderr,"grab %d\n",*id);
	c= mal_clients+ *id;
	if( c == 0)
		throw(MAL,"clients.grab","No client process");
	/* suspend target */
	c->itrace='S';
	while( c->itrace == 'S' ){
		MT_sleep_ms(10);
	}
	cntxt->fdin= c->fdin;
	cntxt->fdin->pos= c->fdin->len;
	cntxt->fdout= c->fdout;
	cntxt->yycur= c->yycur;
	cntxt->prompt= c->prompt;
	cntxt->promptlength= c->promptlength;
	c->fdin= old.fdin;
	c->fdin->pos= old.fdin->len;
	c->fdout= old.fdout;
	c->yycur= old.yycur;
	c->prompt= old.prompt;
	c->promptlength= old.promptlength;
	c->itrace = 0;
	fprintf(stderr,"exchanged descriptors\n");
	return MAL_SUCCEED;
}
str MDBdump(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	(void) cntxt;
	mdbDump(cntxt,mb,stk,pci);
	return MAL_SUCCEED;
}
str MDBdummy(int *ret){
	(void) ret;
	throw(MAL, "mdb.dummy", "Dummy routine called");
}

@- CMDmodules
Obtains a list of modules by looking at what files are present in the
module directory.


@c
BAT *
TBL_getdir(void)
{
	BAT *b = BATnew(TYPE_int, TYPE_str, 100);
	int i = 0;

	char *mod_path;
	size_t extlen = strlen(MAL_EXT);
	size_t len;
	struct dirent *dent;
	DIR *dirp = NULL;

	mod_path = GDKgetenv("monet_mod_path");
	if (mod_path == NULL)
		return b;
	while (*mod_path == PATH_SEP)
		mod_path++;
	if (*mod_path == 0)
		return b;

	while (mod_path || dirp) {
		if (dirp == NULL) {
			char *cur_dir;
			char *p;
			size_t l;

			if ((p = strchr(mod_path, PATH_SEP)) != NULL) {
				l = p - mod_path;
			} else {
				l = strlen(mod_path);
			}
			cur_dir = GDKmalloc(l + 1);
			strncpy(cur_dir, mod_path, l);
			cur_dir[l] = 0;
			if ((mod_path = p) != NULL) {
				while (*mod_path == PATH_SEP)
					mod_path++;
			}
			dirp = opendir(cur_dir);
			GDKfree(cur_dir);
			if (dirp == NULL)
				continue;
		}
		if ((dent = readdir(dirp)) == NULL) {
			closedir(dirp);
			dirp = NULL;
			continue;
		}
		len = strlen(dent->d_name);
		if (len < extlen || strcmp(dent->d_name + len - extlen, MAL_EXT) != 0)
			continue;
		dent->d_name[len - extlen] = 0;
		BUNins(b, &i, dent->d_name, FALSE);
		i++;
	}
	return b;
}

str
CMDmodules(int *bid)
{
	BAT *b = TBL_getdir();

	if (b) {
		*bid = b->batCacheid;
		BBPkeepref(*bid);
	}
	return MAL_SUCCEED;
}

@}
