@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2008 CWI.
@' All Rights Reserved.

@f mdb
@a Martin Kersten
@v 1
@+ MAL debugger interface
This module provides access to the functionality offered
by the MonetDB debugger and interpreter status.
It is primarilly used in interactive sessions to activate
the debugger at a given point. Furthermore, the instructions
provide the necessary handle to generate information
for post-mortum analysis.

To enable ease of debugging and performance monitoring, the MAL interpreter
comes with a hardwired gdb-like text-based debugger.
A limited set of instructions can be included in the programs themselves,
but beware that debugging has a global effect. Any concurrent user
will be affected by breakpoints being set.

The prime scheme to inspect the MAL interpreter status is to use
the MAL debugger directly. However, in case of automatic exception handling
it helps to be able to obtain BAT versions of the critical information,
such as stack frame table, stack trace,
and the instruction(s) where an exception occurred.
The inspection typically occurs in the exception handling part of the
MAL block.

Beware, a large class of internal errors can not easily captured this way.
For example, bus-errors and segmentation faults lead to premature
termination of the process. Similar, creation of the post-mortum
information may fail due to an inconsistent state or insufficient resources.

@mal
module mdb;

pattern start():void 
address MDBstart
comment "Start interactive debugger";
pattern start(clientid:int):void 
address MDBstart
comment "Start interactive debugger on a client";
pattern start(mod:str,fcn:str):void 
address MDBstartFactory
comment "Start interactive debugger on a running factory";

pattern stop():void
address MDBstop
comment "Stop the interactive debugger";

pattern inspect(mod:str,fcn:str):void
address MDBinspect
comment "Run the debugger on a specific function";

pattern setTrace(b:bit):void
address MDBsetTrace
comment "Turn on/off tracing of current routine";

pattern setTrace(b:str):void
address MDBsetVarTrace
comment "Turn on/off tracing of a variable ";

pattern setCatch(b:bit):void
address MDBsetCatch
comment "Turn on/off catching exceptions";

command setTimer(b:bit):void
address MDBsetTimer
comment "Turn on/off performance timer for debugger";

command setBigfoot(b:bit):void
address MDBsetBigfoot
comment "Turn on/off memory foot print for debugger";


command setFlow(b:bit):void
address MDBsetFlow
comment "Turn on/off memory flow debugger";

command setMemory(b:bit):void
address MDBsetMemory
comment "Turn on/off memory statistics tracing.";

command setIO(b:bit):void
address MDBsetIO
comment "Turn on/off io statistics tracing";

command getDebug():int
address MDBgetDebug
comment "Get the kernel debugging bit-set.
See the MonetDB configuration file for details";

command setDebug(flg:str):int
address MDBsetDebugStr
comment "Set the kernel debugging bit-set and return its previous value.
The recognized options are: threads, memory, properties,
io, transactions, modules, algorithms, estimates, xproperties";
command setDebug(flg:int):int
address MDBsetDebug
comment "Set the kernel debugging bit-set and return its previous value.";

command getException(s:str):str
address MDBgetExceptionVariable
comment "Extract the variable name from the exception message";
command getReason(s:str):str
address MDBgetExceptionReason
comment "Extract the reason from the exception message";
command getContext(s:str):str
address MDBgetExceptionContext
comment "Extract the context string from the exception message";

pattern list():void
address MDBlist
comment "Dump the current routine on standard out.";
pattern listMapi():void
address MDBlistMapi
comment "Dump the current routine on standard out with Mapi prefix.";
pattern list(M:str,F:str):void
address MDBlist3
comment "Dump the routine M.F on standard out.";
pattern List():void 
address MDBlistDetail
comment "Dump the current routine on standard out.";
pattern List(M:str,F:str):void 
address MDBlist3Detail
comment "Dump the routine M.F on standard out.";
pattern var():void 
address MDBvar
comment "Dump the symboltable of current routine on standard out.";
pattern var(M:str,F:str):void 
address MDBvar3
comment "Dump the symboltable of routine M.F on standard out.";

command grab(id:int):void
address MDBgrabClient
comment "Stop and debug another client process.";

pattern dot(M:str,F:str,s:str):void 
address MDBshowFlowGraph
comment "Dump the data flow of the function 
	M.F in a format recognizable by the 
	command 'dot' on the file s";

pattern getStackDepth():int 
address MDBStkDepth
comment "Return the depth of the calling stack.";

pattern getStackFrame(i:int):bat[:str,:str] 
address MDBgetStackFrameN;
pattern getStackFrame():bat[:str,:str] 
address MDBgetStackFrame
comment "Collect variable binding of current (n-th) stack frame.";
pattern getStackTrace():bat[:void,:str]
address MDBStkTrace;

pattern dump()
address MDBdump
comment "Dump instruction, stacktrace, and stack";

pattern getDefinition():bat[:void,:str] 
address MDBgetDefinition
comment "Returns a string representation of the current function 
	with typing information attached";

@-
@{
@+ Implementation
@include prelude.mx
@h
#ifndef _MDB_H
#define _MDB_H
#endif /* _MDB_H */
@c
#include "mal_config.h"
#include "gdk.h"
#include <stdarg.h>
#include <time.h>
#include "mal_resolve.h"
#include "mal_client.h"
#include "mal_exception.h"
#include "mal_debugger.h"
#include "mal_interpreter.h"
#include "mal_namespace.h"

#ifdef WIN32
#ifndef LIBMDB
#define mdb_export extern __declspec(dllimport)
#else
#define mdb_export extern __declspec(dllexport)
#endif
#else
#define mdb_export extern
#endif

mdb_export str MDBstart(MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
mdb_export str MDBstartFactory(MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
mdb_export str MDBstop(MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
mdb_export str MDBinspect(MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
mdb_export str MDBsetTrace(MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
mdb_export str MDBsetVarTrace(MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
mdb_export str MDBgetDebug(int *ret);
mdb_export str MDBsetDebug(int *ret, int *flg);
mdb_export str MDBsetDebugStr(int *ret, str *nme);
mdb_export str MDBsetCatch(MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
mdb_export str MDBsetTimer(int *ret, bit *flag);
mdb_export str MDBsetBigfoot(int *ret, bit *flag);
mdb_export str MDBsetFlow(int *ret, bit *flag);
mdb_export str MDBsetMemory(int *ret, bit *flag);
mdb_export str MDBsetIO(int *ret, bit *flag);
mdb_export str MDBgetExceptionVariable(str *ret, str *msg);
mdb_export str MDBgetExceptionReason(str *ret, str *msg);
mdb_export str MDBgetExceptionContext(str *ret, str *msg);
mdb_export str MDBlist(MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
mdb_export str MDBlistMapi(MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
mdb_export str MDBshowFlowGraph(MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
mdb_export str MDBlist3(MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
mdb_export str MDBlistDetail(MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
mdb_export str MDBlist3Detail(MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
mdb_export str MDBvar(MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
mdb_export str MDBvar3(MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
mdb_export str MDBStkDepth(MalBlkPtr mb, MalStkPtr s, InstrPtr p);
mdb_export str MDBgetStackFrameN(MalBlkPtr m, MalStkPtr s, InstrPtr p);
mdb_export str MDBgetStackFrame(MalBlkPtr m, MalStkPtr s, InstrPtr p);
mdb_export str MDBStkTrace(MalBlkPtr m, MalStkPtr s, InstrPtr p);
mdb_export str MDBgetDefinition(MalBlkPtr m, MalStkPtr stk, InstrPtr p);
mdb_export str MDBgrabClient(int *ret, int *id);
mdb_export str MDBdump(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
mdb_export str MDBdummy(int *ret);

@-
The primary debugger controls
@c
#define MDBstatus(X) \
	if( stk->cmd && X==0 ) \
		stream_printf(cntxt->fdout,"#Monet Debugger off\n"); \
	else if(stk->cmd==0 && X) \
		stream_printf(cntxt->fdout,"#Monet Debugger on\n");

str
MDBtoggle(MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	Client cntxt = MCgetClient();
	int b = 0;

	(void) mb;		/* still unused */
	if (p->argc == 1) {
		/* Toggle */
		stk->cmd = stk->cmd ? 0 : 's';
		cntxt->itrace = cntxt->itrace ? 0 : 's';
		if (stk->cmd)
			MDBdelay = 1;	/* wait for real command */
		if (stk->up)
			stk->up->cmd = 0;
		return MAL_SUCCEED;
	}
	if (p->argc > 1) {
		b = *(int *) getArgReference(stk, p, 1);
	} else
		b = stk->cmd;
	if (b)
		MDBdelay = 1;	/* wait for real command */
	MDBstatus(b);
	stk->cmd = b ? 'n' : 0;
	if (stk->up)
		stk->up->cmd = b ? 'n' : 0;
	cntxt->itrace = b ? 'n' : 0;
	return MAL_SUCCEED;
}

str
MDBstart(MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	Client c,cntxt = MCgetClient();
	int pid;

	if( p->argc == 2){
		/* debug running process */
		pid = *(int *) getArgReference(stk, p, 1);
		if( pid< 0 || pid > MAL_MAXCLIENTS || mal_clients[pid].mode <= FINISHING)
			throw(MAL, "mdb.start", "Illegal process id");
		c= mal_clients+pid;
		/* make client aware of being debugged */
		cntxt= c;
	} else
		stk->cmd = 'n';
	cntxt->itrace = 'n';
	cntxt->debugOptimizer= TRUE;
	(void) mb;
	(void) p;
	return MAL_SUCCEED;
}

str
MDBstartFactory(MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	(void) mb;
	(void) stk;
	(void) p;
		throw(MAL, "mdb.start", "Debugging factory not yet available");
}

str
MDBstop(MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	Client cntxt = MCgetClient();

	stk->cmd = 0;
	cntxt->itrace = 0;
	cntxt->debugOptimizer= FALSE;
	stream_printf(cntxt->fdout,"mdb>#EOD\n");
	(void) mb;
	(void) p;
	return MAL_SUCCEED;
}

void
MDBtraceFlag(Client cntxt, MalStkPtr stk, int b)
{
	if (b) {
		cntxt->timer = GDKusec();
		stk->cmd = b;
		cntxt->itrace = b;
	} else {
		cntxt->timer = 0;
		stk->cmd = 0;
		cntxt->itrace = 0;
	}
}

str
MDBsetTrace(MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	int b;

	(void) mb;		/* still unused */
	b = *(chr *) getArgReference(stk, p, 1);
	MDBtraceFlag(MCgetClient(), stk, (b? (int) 't':0));
	return MAL_SUCCEED;
}
str
MDBsetVarTrace(MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	str v;
	v = *(str *) getArgReference(stk, p, 1);
	mdbSetBreakRequest(MCgetClient(), mb, v, 't');
	stk->cmd = 'c';
	MCgetClient()->itrace = 'c';
	return MAL_SUCCEED;
}

str
MDBgetDebug(int *ret)
{
    *ret = GDKdebug;
    return MAL_SUCCEED;
}

str
MDBsetDebug(int *ret, int *flg)
{
    *ret = GDKdebug;
    GDKdebug = *flg;
    return MAL_SUCCEED;
}
str
MDBsetDebugStr(int *ret, str *flg)
{
    *ret = GDKdebug;
	if( strcmp("threads",*flg)==0)
		GDKdebug |= GRPthreads;
	if( strcmp("memory",*flg)==0)
		GDKdebug |= GRPmemory;
	if( strcmp("properties",*flg)==0)
		GDKdebug |= GRPproperties;
	if( strcmp("io",*flg)==0)
		GDKdebug |= GRPio;
	if( strcmp("transactions",*flg)==0)
		GDKdebug |= GRPtransactions;
	if( strcmp("modules",*flg)==0)
		GDKdebug |= GRPmodules;
	if( strcmp("algorithms",*flg)==0)
		GDKdebug |= GRPalgorithms;
	if( strcmp("performance",*flg)==0)
		GDKdebug |= GRPperformance;
	if( strcmp("xproperties",*flg)==0)
		GDKdebug |= GRPxproperties;
    return MAL_SUCCEED;
}

str
MDBsetCatch(MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	int b;
	Client cntxt= MCgetClient();

	(void) mb;		/* still unused */
	b = *(chr *) getArgReference(stk, p, 1);
	stk->cmd = cntxt->itrace = (b? (int) 'C':0);
	return MAL_SUCCEED;
}

str
MDBsetTimer(int *ret, bit *flag)
{
	Client cntxt = MCgetClient();

	(void) ret;
	if( *flag)
		cntxt->flags |= timerFlag;
	else
		cntxt->flags &= ~timerFlag;
	cntxt->timer= GDKusec();
	return MAL_SUCCEED;
}

str
MDBsetBigfoot(int *ret, bit *flag)
{
	Client cntxt = MCgetClient();

	(void) ret;
	if( *flag)
		cntxt->flags |= bigfootFlag;
	else
		cntxt->flags &= ~bigfootFlag;
	return MAL_SUCCEED;
}

str
MDBsetFlow(int *ret, bit *flag)
{
	Client cntxt = MCgetClient();

	(void) ret;
	if( *flag)
		cntxt->flags |= flowFlag;
	else
		cntxt->flags &= ~flowFlag;
	return MAL_SUCCEED;
}

str
MDBsetMemory(int *ret, bit *flag)
{
	Client cntxt = MCgetClient();
	(void) ret;

	if( *flag)
		cntxt->flags |= memoryFlag;
	else
		cntxt->flags &= ~memoryFlag;
	return MAL_SUCCEED;
}

str
MDBsetIO(int *ret, bit *flag)
{
	Client cntxt = MCgetClient();
	(void) ret;

	if( *flag)
		cntxt->flags |= ioFlag;
	else
		cntxt->flags &= ~ioFlag;
	return MAL_SUCCEED;
}

str
MDBinspect(MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	str modnme;
	str fcnnme;
	Symbol s = NULL;

	if (stk != 0) {
		modnme = (str) getArgValue(stk, p, 1);
		fcnnme = (str) getArgValue(stk, p, 2);
	} else {
		modnme = getArgDefault(mb, p, 1);
		fcnnme = getArgDefault(mb, p, 2);
	}

	s = findSymbol(putName(modnme, strlen(modnme)), putName(fcnnme, strlen(fcnnme)));

	if (s == NULL)
		throw(MAL, "mdb.inspect", "Could not find function");
	return runMALDebugger(s);
}

@+ Variables and stack information
The variable information can be turned into a BAT for inspection as well.
@c

static int
getStkDepth(MalStkPtr s)
{
	int i = 0;

	while (s != 0) {
		i++;
		s = s->up;
	}
	return i;
}

str
MDBStkDepth(MalBlkPtr mb, MalStkPtr s, InstrPtr p)
{
	int *ret = (int *) getArgReference(s, p, 0);

	(void) mb;		/* fool compiler */
	*ret = getStkDepth(s);
	return MAL_SUCCEED;
}

str
MDBgetFrame(BAT *b, MalBlkPtr mb, MalStkPtr s, int depth)
{
	ValPtr v;
	int i;
	char *buf = 0;

	if (depth > 0)
		return MDBgetFrame(b, mb, s->up, depth - 1);
	if (s != 0)
		for (i = 0; i < s->stktop; i++, v++) {
			v = &s->stk[i];
			ATOMformat(v->vtype, VALget(v), &buf);
			BUNins(b, getVarName(mb, i), buf, FALSE);
		}
	return MAL_SUCCEED;
}

str
MDBgetStackFrame(MalBlkPtr m, MalStkPtr s, InstrPtr p)
{
	int *ret = (int *) getArgReference(s, p, 0);
	BAT *b = BATnew(TYPE_str, TYPE_str, 256);

	if (b == 0)
		throw(MAL, "mdb.getStackFrame", "Failed to create BAT");
	@:Pseudo(view,stk,frame)@
	return MDBgetFrame(b, m, s, 0);
}

str
MDBgetStackFrameN(MalBlkPtr m, MalStkPtr s, InstrPtr p)
{
	int n, *ret = (int *) getArgReference(s, p, 0);
	BAT *b = BATnew(TYPE_str, TYPE_str, 256);

	n = *(int *) getArgReference(s, p, 1);
	if (n < 0 || n >= getStkDepth(s))
		throw(MAL, "mdb.getStackFrame", "Illegal depth.");
	@:Pseudo(view,stk,frame)@
	return MDBgetFrame(b, m, s, n);
}

str
MDBStkTrace(MalBlkPtr m, MalStkPtr s, InstrPtr p)
{
	BAT *b = BATnew(TYPE_int, TYPE_str, 256);
	str msg;
	char buf[8192];
	int *ret = (int *) getArgReference(s, p, 0);
	int k = 0,pc;

	msg = call2str(s->blk, s, pc=getPC(m, p),MCgetClient()->flags);
	snprintf(buf,8192,"%s at %s.%s[%d]", msg+5,
		getModuleId(getInstrPtr(m,0)),
		getFunctionId(getInstrPtr(m,0)), pc);
	BUNins(b, &k, buf, FALSE);
	GDKfree(msg);

	for (s = s->up, k++; s != NULL; s = s->up, k++) {
		msg = call2str(s->blk, s, s->pcup,MCgetClient()->flags);
		snprintf(buf,8192,"%s at %s.%s[%d]", msg+5,
			getModuleId(getInstrPtr(s->blk,0)),
			getFunctionId(getInstrPtr(s->blk,0)), s->pcup);
		BUNins(b, &k, buf, FALSE);
		GDKfree(msg);
	}
	if (!(b->batDirty&2)) b = BATsetaccess(b, BAT_READ);
	@:Pseudo(view,stk,trace)@
	return MAL_SUCCEED;
}

@+ Display routines
@c
str
MDBlist(MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	Client c = MCgetClient();

	(void) p;
	(void) stk;
	printFunction(c->fdout, mb, LIST_MAL_INSTR | LIST_MAL_PROPS);
	return MAL_SUCCEED;
}

str
MDBlistMapi(MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	Client c = MCgetClient();

	(void) p;
	(void) stk;
	printFunction(c->fdout, mb, LIST_MAL_INSTR | LIST_MAL_PROPS | LIST_MAPI);
	return MAL_SUCCEED;
}

str
MDBlist3(MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	str modnme = (str) getArgValue(stk, p, 1);
	str fcnnme = (str) getArgValue(stk, p, 2);
	Symbol s = NULL;
	Client c = MCgetClient();

	s = findSymbol(getName(modnme,strlen(modnme)), putName(fcnnme, strlen(fcnnme)));
	if (s == NULL)
		showException(MAL,"mdb.list","Could not find %s.%s", modnme, fcnnme);
	else
		printFunction(c->fdout, s->def, LIST_MAL_INSTR | LIST_MAL_PROPS);
	(void) mb;		/* fool compiler */
	return MAL_SUCCEED;
}

str
MDBlistDetail(MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	Client c = MCgetClient();

	(void) p;
	(void) stk;
	printFunction(c->fdout, mb, LIST_MAL_ALL);
	return MAL_SUCCEED;
}

str
MDBlist3Detail(MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	str modnme = (str) getArgValue(stk, p, 1);
	str fcnnme = (str) getArgValue(stk, p, 2);
	Symbol s = NULL;
	Client c = MCgetClient();

	s = findSymbol(getName(modnme,strlen(modnme)), putName(fcnnme, strlen(fcnnme)));
	if (s == NULL)
		showException(MAL,"mdb.list","Could not find %s.%s", modnme, fcnnme);
	else
		printFunction(c->fdout, s->def, LIST_MAL_ALL);
	(void) mb;		/* fool compiler */
	return NULL;
}

str
MDBvar(MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	Client c = MCgetClient();

	(void) p;
	(void) stk;
	printStack(c->fdout, mb, stk);
	return MAL_SUCCEED;
}

str
MDBvar3(MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	str modnme = (str) getArgValue(stk, p, 1);
	str fcnnme = (str) getArgValue(stk, p, 2);
	Symbol s = NULL;
	Client c = MCgetClient();

	s = findSymbol(getName(modnme,strlen(modnme)), putName(fcnnme, strlen(fcnnme)));
	if (s == NULL)
		showException(MAL,"mdb.var","Could not find %s.%s", modnme, fcnnme);
	else
		printStack(c->fdout, s->def, (s->def == mb ? stk : 0));
	(void) mb;
	return NULL;
}

@-
It is illustrative to dump the code when you
have encountered an error.
@c
str
MDBgetDefinition(MalBlkPtr m, MalStkPtr stk, InstrPtr p)
{
	int i, *ret = (int *) getArgReference(stk, p, 0);
	str ps;
	BAT *b = BATnew(TYPE_int, TYPE_str, 256);

	if (b == 0)
		throw(MAL, "mdb.getDefinition", "Failed to create BAT");

	for (i = 0; i < m->stop; i++) {
		ps = instruction2str(m, getInstrPtr(m, i), 1);
		BUNins(b, &i, ps, FALSE);
		GDKfree(ps);
	}
	if (!(b->batDirty&2)) b = BATsetaccess(b, BAT_READ);
	@:Pseudo(view,fcn,stmt)@

	return MAL_SUCCEED;
}

str
MDBgetExceptionVariable(str *ret, str *msg)
{
	str tail;

	tail = strchr(*msg, ':');
	if (tail == 0)
		throw(MAL, "mdb.getExceptionVariable", "Could not find it");

	*tail = 0;
	*ret = GDKstrdup(*msg);
	*tail = ':';
	return MAL_SUCCEED;
}

str
MDBgetExceptionContext(str *ret, str *msg)
{
	str tail, tail2;

	tail = strchr(*msg, ':');
	if (tail == 0)
		throw(MAL, "mdb.getExceptionContext", "Could not find it");
	tail2 = strchr(tail + 1, ':');
	if (tail2 == 0)
		throw(MAL, "mdb.getExceptionContext", "Could not find it");

	*tail2 = 0;
	*ret = GDKstrdup(tail + 1);
	*tail2 = ':';
	return MAL_SUCCEED;
}

str
MDBgetExceptionReason(str *ret, str *msg)
{
	str tail;

	tail = strchr(*msg, ':');
	if (tail == 0)
		throw(MAL, "mdb.getExceptionReason", "Could not find it");
	tail = strchr(tail + 1, ':');
	if (tail == 0)
		throw(MAL, "mdb.getExceptionReason", "Could not find it");

	*ret = GDKstrdup(tail + 1);
	return MAL_SUCCEED;
}


str
MDBshowFlowGraph(MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	str fname;
	str modnme;
	str fcnnme;
	Symbol s = NULL;

	if (stk != 0) {
		modnme = (str) getArgValue(stk, p, 1);
		fcnnme = (str) getArgValue(stk, p, 2);
		fname = (str) getArgValue(stk, p, 3);
	} else {
		modnme = getArgDefault(mb, p, 1);
		fcnnme = getArgDefault(mb, p, 2);
		fname = getArgDefault(mb, p, 3);
	}

	s = findSymbol(getName(modnme,strlen(modnme)), putName(fcnnme, strlen(fcnnme)));

	if (s == NULL) {
		char buf[1024];
		snprintf(buf,1024, "Could not find %s.%s\n", modnme, fcnnme);
		throw(MAL, "mdb.dot", buf);
	}
	showFlowGraph(s->def, stk, fname);
	return MAL_SUCCEED;
}
@-
Grab a client process by exchange of streams
@c
str
MDBgrabClient(int *ret, int *id){
	Client this,c;
	ClientRec old;
	this= MCgetClient();
	old= *this;

	if( *id<0 || *id>= MAL_MAXCLIENTS)
		throw(MAL,"clients.grab","No client process");
	fprintf(stderr,"grab %d\n",*id);
	c= mal_clients+ *id;
	if( c == 0)
		throw(MAL,"clients.grab","No client process");
	/* suspend target */
	c->itrace='S';
	while( c->itrace == 'S' ){
		MT_sleep_ms(10);
	}
	this->fdin= c->fdin;
	this->fdin->pos= c->fdin->len;
	this->fdout= c->fdout;
	this->yycur= c->yycur;
	this->prompt= c->prompt;
	this->promptlength= c->promptlength;
	c->fdin= old.fdin;
	c->fdin->pos= old.fdin->len;
	c->fdout= old.fdout;
	c->yycur= old.yycur;
	c->prompt= old.prompt;
	c->promptlength= old.promptlength;
	c->itrace = 0;
	fprintf(stderr,"exchanged descriptors\n");
	(void) ret;
	return MAL_SUCCEED;
}
str MDBdump(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	mdbDump(mb,stk,pci);
	return MAL_SUCCEED;
}
str MDBdummy(int *ret){
	(void) ret;
	throw(MAL, "mdb.dummy", "Dummy routine called");
}
@}
