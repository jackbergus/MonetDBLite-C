@/
The contents of this file are subject to the MonetDB Public License
Version 1.1 (the "License"); you may not use this file except in
compliance with the License. You may obtain a copy of the License at
http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html

Software distributed under the License is distributed on an "AS IS"
basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations
under the License.

The Original Code is the MonetDB Database System.

The Initial Developer of the Original Code is CWI.
Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
Copyright August 2008-2010 MonetDB B.V.
All Rights Reserved.
@

@f attach
@a Martin Kersten
@v 0.1
@+ Attach
The attach module provides a mechanism to easily share a (readonly)
BATs between two mservers.

The module is intended to support cheap attachment of BATs identified
using several protocols, but for the moment we assume a single Linux
cluster with NSF.
In this context the bind() creates a symbolic link. 

Beware that the argument to the patterns is the full path to 
the base of the BAT. Depending on their type we need to
establish attachment to head,tail, hheap and theap.
The count argument is needed, because it can not be derived from the
file structure itself.

@mal
module attach;

pattern bind(nme:str,cnt:lng,low:oid,hgh:oid):bat[:any_1,:any_2]
address ATTbindPartition
comment "Find a cheap way to make a BAT partition accessible locally";

pattern bind(nme:str,cnt:lng):bat[:any_1,:any_2]
address ATTbind
comment "Find a cheap way to make the BAT nme accessible locally";

command location(b:bat[:any_1,:any_2]):str
address ATTlocation
comment "Locate the base of a particulat BAT in the dbfarm";
@{
@-
@+ Implementation
@h
#ifndef _ATTACH_H
#define _ATTACH_H
#include "mal.h"
#include "mal_client.h"
#include "mal_interpreter.h"

#ifdef WIN32
#ifndef LIBATTACH
#define attach_export extern __declspec(dllimport)
#else
#define attach_export extern __declspec(dllexport)
#endif
#else
#define attach_export extern
#endif

attach_export str ATTbind(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
attach_export str ATTbindPartition(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
attach_export str ATTlocation(str *ret, int *bid);
#endif /* _ATTACH_H */
@- Module initializaton
@c
#include "mal_config.h"
#include "attach.h"

@- Operator implementation

@= linkHeap
	lstat(@3,&st);
	GDKfilepath(path, BATDIR, BBP_physical(bn->batCacheid), "@4");
	GDKcreatedir(path);
	mnstr_printf( GDKerr,"#symlink %s ->%s\n",@3,path);
	if (symlink(@3, path) < 0) {
		msg = createException(MAL,"attach.bind","cannot link '%s' -> '%s'\n",path,@3);
		HEAPfree(&bn->@1->@2);
		GDKfree(bs);
		return msg;
	}
	bn->@1->@2.free = bn->@1->@2.size = (size_t) st.st_size;
	bn->@1->@2.storage = (bn->@1->@2.size < REMAP_PAGE_MAXSIZE) ? STORE_MEM : STORE_MMAP;
	HEAPload(&bn->@1->@2, BBP_physical(bn->batCacheid), "@4", TRUE);

@= linkvHeap
	lstat(@2,&st);
	GDKfilepath(path, BATDIR, BBP_physical(bn->batCacheid), "@3");
	GDKcreatedir(path);
	mnstr_printf( GDKerr,"#symlink %s ->%s\n",@2,path);
	if (symlink(@2, path) < 0) {
		msg = createException(MAL,"attach.bind","cannot link '%s' -> '%s'\n",path,@2);
		HEAPfree(bn->@1->vheap);
		GDKfree(bs);
		return msg;
	}
	if (bn->@1->vheap == 0)
		bn->@1->vheap = (Heap*) GDKzalloc(sizeof(Heap));
	bn->@1->vheap->parentid = bn->batCacheid;
	bn->@1->vheap->free = bn->@1->vheap->size = (size_t) st.st_size;
	bn->@1->vheap->storage = (bn->@1->vheap->size < REMAP_PAGE_MAXSIZE) ? STORE_MEM : STORE_MMAP;
	HEAPload(bn->@1->vheap, BBP_physical(bn->batCacheid), "@3", TRUE);

@c
str
ATTbind(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
#ifdef WIN32
	(void) cntxt;
	(void) mb;
	(void) stk;
	(void) pci;
	throw(MAL, "attach.bind", "Not available on Windows");
#else
	int *ret = (int*) getArgReference(stk, pci, 0);
	str nme = *(str*) getArgReference(stk, pci, 1);
	BUN cap = 0, cnt = (BUN) *(lng*) getArgReference(stk, pci, 2);
	char bufhead[BUFSIZ];
	char buftail[BUFSIZ];
	char bufhheap[BUFSIZ];
	char buftheap[BUFSIZ];
	char path[BUFSIZ];
	int ht,tt;
	BAT *bn = 0;
	BATstore *bs;
	struct stat st;
	str msg= MAL_SUCCEED;

	(void) cntxt;
	/* more protocols for the future */
	if ( strncmp(nme,"file:/",6) ) {
		// throw(MAL, "attach.bind", "Protocol unknown");
	} else nme += 6;
	
	ht = getHeadType(getArgType(mb,pci,0));
	tt = getTailType(getArgType(mb,pci,0));

	snprintf(bufhead,BUFSIZ,"%s.head", nme);
	if (ht != TYPE_void && lstat(bufhead, &st) < 0) {
		if ( ht == TYPE_oid){
			ht= TYPE_void;
		} else{
			IODEBUG{
				mnstr_printf(GDKerr,"#attach.bind:Heap %s not found\n",nme);
			}
			throw(MAL,"attach.bind","head heap not found:%s",nme);
		}
	}

	snprintf(buftail,BUFSIZ,"%s.tail", nme);
	if (tt != TYPE_void && lstat(buftail, &st) < 0){
		if ( ht == TYPE_oid){
			tt= TYPE_void;
		} else
			throw(MAL,"attach.bind","tail heap not found");
	}

	bs =  BATcreatedesc(ht, tt, cnt);
    if (bs == NULL)
		throw(MAL,"attach.bind",MAL_MALLOC_FAIL);
	bn = &bs->B;
	BATsetdims(bn);
	BATmode(bn, TRANSIENT);
	bn->batCopiedtodisk = 1;
	bn->hsorted = 0;
	bn->tsorted = 0;

	snprintf(bufhheap,BUFSIZ,"%s.hheap", nme);
	if (ht != TYPE_void && bn->hvarsized && lstat(bufhheap, &st) < 0)
		throw(MAL,"attach.bind","hhead heap not found");

	snprintf(buftheap,BUFSIZ,"%s.theap", nme);
	if (tt != TYPE_void && bn->tvarsized && lstat(buftheap, &st) < 0)
		throw(MAL,"attach.bind","theap heap not found");

	if (ht != TYPE_void ) {
		@:linkHeap(H,heap,bufhead,head)@
		cap = ((BUN) st.st_size / ATOMsize(ht));
		if( cap){
			/* strings may be variable with references.
			   this may lead to underspecified capacity.
			*/
			BATsetcapacity(bn, cap<cnt? cnt:cap);
			BATsetcount(bn, cnt);
		}
		if ( bn->tvarsized){
			@:linkvHeap(T,bufhheap,hheap)@
		}
	} else {
		bn->hseqbase = 0;
		BATkey(bn, TRUE);
	}
	if (tt != TYPE_void ) {
		@:linkHeap(T,heap,buftail,tail)@
		cap = ((BUN) st.st_size / ATOMsize(tt));
		if( cap){
			BATsetcapacity(bn, cap<cnt? cnt:cap);
			BATsetcount(bn, cnt);
		}
		if ( bn->tvarsized){
			@:linkvHeap(T,buftheap,theap)@
		}
	} else {
		bn->tseqbase = 0;
		BATkey(BATmirror(bn), TRUE);
	}
    BBPcacheit(bs, 1);
	BATsetaccess(bn, BAT_READ);
    if (cap > 1) {
        BATpropcheck(bn, BATPROPS_ALL);
        BATpropcheck(BATmirror(bn), BATPROPS_ALL);
	}

	BBPkeepref(*ret= bn->batCacheid);
	return MAL_SUCCEED;
#endif
}

str
ATTbindPartition(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	int *ret,bid;
	BAT *b, *view;
	str msg= MAL_SUCCEED;
	BUN low,hgh;

	msg = ATTbind(cntxt,mb,stk,pci);
	if ( msg == MAL_SUCCEED){
		ret = getArgReference(stk,pci,0);
		bid = *(int*) getArgReference(stk,pci,0);
		low = (BUN) *(oid*) getArgReference(stk,pci,3);
		hgh = (BUN) *(oid*) getArgReference(stk,pci,4);

		if ((b = BATdescriptor(bid)) == NULL)
			throw(MAL, "attach.bind", INTERNAL_BAT_ACCESS);
		view = VIEWcreate_(b, b, TRUE);
		VIEWbounds(b, view, (BUN) low, hgh );
		BATseqbase(view, low);
		BBPkeepref(*ret = view->batCacheid);
		BBPunfix(b->batCacheid);
	}
	return msg;
}

str ATTlocation(str *ret, int *bid)
{
	BAT *b = BBPquickdesc(*bid, FALSE);
	char path[BUFSIZ], *s;

	if ( b == NULL )
		throw(MAL,"attach.location",RUNTIME_OBJECT_UNDEFINED);

	snprintf(path,BUFSIZ,"%s%c%s%c",GDKgetenv("gdk_dbfarm"),DIR_SEP,GDKgetenv("gdk_dbname"),DIR_SEP);
	GDKfilepath(path+strlen(path), BATDIR, ( b->T->heap.filename ? b->T->heap.filename: b->H->heap.filename), 0);
	s= strrchr(path,'.');
	if( s) *s = 0;
	*ret = GDKstrdup(path);
	return MAL_SUCCEED;
}

@}
