@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
@' Copyright August 2008- MonetDB B.V.
@' All Rights Reserved.

@f rdf
@a L.Sidirourgos

@* The RDF module For MonetDB5 (aka. MonetDB/RDF)

@mal
module rdf;

command shred(location:str, graphname:str):bat[:void, :bat]
address RDFParser
comment "look behind you!"

command printTriples(b:bat[:void, :bat], order:int):void
address RDFPrintTriples
comment "print triples of a graph for debug purposes. Order is: 1=SPO, 2=SOP, 3=PSO, 4=POS, 5=OPS, 6=OSP";

@h
#ifndef _RDF_H_
#define _RDF_H_

#ifdef WIN32
#ifndef LIBRDF
#define rdf_export extern __declspec(dllimport)
#else
#define rdf_export extern __declspec(dllexport)
#endif
#else
#define rdf_export extern
#endif

/* internal debug messages */
#define _DEBUG_RDF_SHRD
#define _DEBUG_RDF

rdf_export str RDFParser(int *retval, str *location, str *graphname);

typedef enum {
	S_SPO, P_SPO, O_SPO, /* spo */
	S_SOP, P_SOP, O_SOP, /* sop */
	S_PSO, P_PSO, O_PSO, /* pso */
	S_POS, P_POS, O_POS, /* pos */
	S_OSP, P_OSP, O_OSP, /* osp */
	S_OPS, P_OPS, O_OPS, /* ops */
	MAP_LEX
} graphBATType;

#define N_GRAPH_BAT (MAP_LEX+1)

#endif /* _RDF_H_ */

@c
#include "mal_config.h"
#include "mal_exception.h"
#include <gdk.h>
#include "rdf.h"

@= printTriples
if ((s = BATdescriptor(g[S_@1])) == NULL) {
	BBPunfix(graph->batCacheid);
	throw(MAL, "rdf.printTriples", "BAT S_@1 is missing");
}
if ((p = BATdescriptor(g[P_@1])) == NULL) {
	BBPunfix(graph->batCacheid);
	BBPunfix(s->batCacheid);
	throw(MAL, "rdf.printTriples", "BAT P_@1 is missing");
}
if ((o = BATdescriptor(g[O_@1])) == NULL) {
	BBPunfix(graph->batCacheid);
	BBPunfix(s->batCacheid);
	BBPunfix(p->batCacheid);
	throw(MAL, "rdf.printTriples", "BAT O_@1 is missing");
}
if ((m = BATdescriptor(g[MAP_LEX])) == NULL) {
	BBPunfix(graph->batCacheid);
	BBPunfix(s->batCacheid);
	BBPunfix(p->batCacheid);
	BBPunfix(o->batCacheid);
	throw(MAL, "rdf.printTriples", "BAT MAP_LEX is missing");
}

@c
str
RDFPrintTriples (int retval, bat *Graph, int *order) {
	BAT *print_bats[3];
	BAT *graph = NULL, *s = NULL, *p = NULL, *o = NULL, *m = NULL;
	bat *g;
	(void) retval;

	if ((graph = BATdescriptor(*Graph)) == NULL) {
		throw(MAL, "rdf.printTriples", "BAT graph is missing");
	}
	g = (bat *) Tloc(graph, BUNfirst(graph));

	switch (*order) {
		case 1:
			stream_printf(GDKout, "\tOrder = [Subject, Property, Object]\n");
			@:printTriples(SPO)@
			break;
		case 2:
			stream_printf(GDKout, "\tOrder = [Subject, Object, Property]\n");
			@:printTriples(SOP)@
			break;
		case 3:
			stream_printf(GDKout, "\tOrder = [Property, Subject, Object]\n");
			@:printTriples(PSO)@
			break;
		case 4:
			stream_printf(GDKout, "\tOrder = [Property, Object, Subject]\n");
			@:printTriples(POS)@
			break;
		case 5:
			stream_printf(GDKout, "\tOrder = [Object, Property, Subject]\n");
			@:printTriples(OPS)@
			break;
		case 6:
			stream_printf(GDKout, "\tOrder = [Object, Subject, Property]\n");
			@:printTriples(OSP)@
			break;
		default:
			BBPunfix(graph->batCacheid);
			throw(MAL, "rdf.printTriples", "Unknown order parameter");
	}

	print_bats[0] =  BATleftfetchjoin(s, m, BATcount(s));
	print_bats[1] =  BATleftfetchjoin(p, m, BATcount(p));
	print_bats[2] =  BATleftfetchjoin(o, m, BATcount(o));
	BATmultiprintf(GDKout, 4, print_bats, TRUE, 0, 0);
	/* cleaning */
	BBPunfix(s->batCacheid);
	BBPunfix(p->batCacheid);
	BBPunfix(o->batCacheid);
	BBPunfix(m->batCacheid);
	BBPunfix(graph->batCacheid);
	BBPreclaim(print_bats[0]);
	BBPreclaim(print_bats[1]);
	BBPreclaim(print_bats[2]);

	return MAL_SUCCEED;
}
