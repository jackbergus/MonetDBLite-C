@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2007 CWI.
@' All Rights Reserved.

@f mat
@a Martin Kersten
@v 1
@+ Multiple association tables
A MAT is a convenient way to deal with scaleability. 
It combines the definitions of several, type compatible
BATs under a single name. 
This view is only materialized when the operations
can not deal with the components individually,
or the incremental operation is not supported.

The module is supported by the mal_mergetable optimizer.

The primitives below are chosen to accomodate the SQL
front-end to produce reasonable efficient code.
@mal
module mat;

pattern new(b:bat[:any_1,:any_2]...):bat[:any_1,:any_2]
address MATnew
comment "Define a Merge Association Table (MAT) ";

pattern pack(b:bat[:any_1,:any_2]...):bat[:any_1,:any_2]
address MATpack
comment "Materialize the MAT into the first BAT";

pattern print(b:bat[:any_1,:any_2]...):void
address MATprint;

pattern newIterator(grp:bat[:any_1,:any_2]...):bat[:any_1,:any_2]
address MATnewIterator
comment "Create an iterator over a MAT";

pattern hasMoreElements(grp:bat[:any_1,:any_2]...):bat[:any_1,:any_2]
address MAThasMoreElements
comment "Find the next element in the merge table";

command info(g:str, e:str):bat[:any_1,:any_2]
address MATinfo
comment "retrieve the definition from the partition catalogue";
@-
@{
@+ Implementation
@include prelude.mx
@h
#ifdef _INSPECT_H
#endif /* _INSPECT_H */
@c
#include "mal_config.h"
#include <stdarg.h>
#include "mal_resolve.h"
#include "mal_exception.h"
#include "mal_interpreter.h"

#ifdef WIN32
#ifndef LIBMAT
#define mat_export extern __declspec(dllimport)
#else
#define mat_export extern __declspec(dllexport)
#endif
#else
#define mat_export extern
#endif

mat_export str MATnew(MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
mat_export str MATpack(MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
mat_export str MATnewIterator(MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
mat_export str MAThasMoreElements(MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
mat_export str MATdummy(int *ret, str *grp);
mat_export str MATinfo(int *ret, str *grp, str *elm);
mat_export str MATprint(MalBlkPtr mb, MalStkPtr stk, InstrPtr p);

@- 
Mal symbol table and environment analysis.
@c

str
MATnew(MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	(void) mb; (void) stk; (void) p;
	return MAL_SUCCEED;
}
str
MATnewIterator(MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	int *ret = (int*) getArgReference(stk,p,0);
	(void) mb; 
	if( p->argc == 1){
		*ret = 0;
	} else
		*ret= *(int*) getArgReference(stk,p,1);
	return MAL_SUCCEED;
}
str
MAThasMoreElements(MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	int *ret = (int*) getArgReference(stk,p,0);
	int i, idx = *ret;

	(void) mb; 
	for(i=1; i< p->argc; i++)
	if( *(int*) getArgReference(stk,p,i) == idx){
		i++;
		break;
	}
	if( i < p->argc)
		*ret= *(int*) getArgReference(stk,p,i);
	else
		*ret = 0;
	(void) mb; 
	return MAL_SUCCEED;
}
@-
The pack operation could be quite expensive, because it
may create a really large BAT.
For the experiments we materialize the BAT in the first
component. 
@c
str
MATpack(MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	int i,*ret;
	BAT *b, *bn;

	bn= BATdescriptor(stk->stk[getArg(p,1)].val.ival);
	if( bn == NULL)
		throw(MAL, "mat.pack","Could access BAT");
	if (BAThrestricted(bn) || BATtrestricted(bn)) {
		b = BATcopy(bn, bn->htype, bn->ttype, 1);
		BBPunfix(bn->batCacheid);
		bn = b;
	}
	for(i=2; i<p->argc; i++){
		b= BATdescriptor(stk->stk[getArg(p,i)].val.ival);
		if( b == NULL)
			throw(MAL, "mat.pack","Could not access component");
		if( BATcount(b) )
			BATins(bn,b,FALSE);
		BBPunfix(b->batCacheid);
	}
	(void) mb;
	ret= (int*) getArgReference(stk,p,0);
	*ret= bn->batCacheid;
	BBPkeepref(bn->batCacheid);
	return MAL_SUCCEED;
}

str
MATprint(MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	(void) mb; (void) stk; (void) p;
	return MAL_SUCCEED;
}

str
MATdummy(int *ret, str *grp){
	(void) grp; (void) ret;
	return MAL_SUCCEED;
}
str
MATinfo(int *ret, str *grp, str *elm){
	(void) grp; (void) elm; (void) ret;
	return MAL_SUCCEED;
}
@}
