@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
@' Copyright August 2008-2009 MonetDB B.V.
@' All Rights Reserved.

@f mat
@a Martin Kersten
@v 1
@+ Multiple association tables
A MAT is a convenient way to deal represent horizontal fragmented
tables. It combines the definitions of several, type compatible
BATs under a single name. 
It is produced by the mitosis optimizer and the operations
are the target of the mergetable optimizer.

The MAT is materialized when the operations
can not deal with the components individually,
or the incremental operation is not supported.
Normally all mat.new() operations are removed by the
mergetable optimizer.
In case a mat.new() is retained in the code, then it will
behaves as a mat.pack();

The primitives below are chosen to accomodate the SQL
front-end to produce reasonable efficient code.
@mal
module mat;

pattern new(b:bat[:any_1,:any_2]...):bat[:any_1,:any_2]
address MATnew
comment "Define a Merge Association Table (MAT). Faal back to the pack operation
when this is called ";

pattern pack(b:bat[:any_1,:any_2]...):bat[:any_1,:any_2]
address MATpack
comment "Materialize the MAT into a BAT";

pattern pack(:any_2...):bat[:void,:any_2]
address MATpackValues
comment "Materialize the MAT (of values) into a BAT";

pattern print(b:bat[:any_1,:any_2]...):void
address MATprint;

pattern newIterator(grp:bat[:any_1,:any_2]...):bat[:any_1,:any_2]
address MATnewIterator
comment "Create an iterator over a MAT";

pattern hasMoreElements(grp:bat[:any_1,:any_2]...):bat[:any_1,:any_2]
address MAThasMoreElements
comment "Find the next element in the merge table";

command info(g:str, e:str):bat[:any_1,:any_2]
address MATinfo
comment "retrieve the definition from the partition catalogue";

@-
The aggregates do not include the -nonil variant, because this
should be handled by aggregation over the partitions before.
@= mataggr
command count(b:@1...):@1
address MATcount
comment "Sum the result of a partitioned count check for NULL";
command min(b:@1...):@1
address MATmin
comment "Get the minimum from the MAT list";
command max(b:@1...):@1
address MATmax
comment "Get the maximum from the MAT list";
@mal
@:mataggr(bte)@
@:mataggr(wrd)@
@:mataggr(int)@
@:mataggr(lng)@
@:mataggr(flt)@
@:mataggr(dbl)@

@-
@{
@+ Implementation
@include prelude.mx
@h
#ifndef _INSPECT_H
#define _INSPECT_H 
#include <stdarg.h>
#include "mal_resolve.h"
#include "mal_exception.h"
#include "mal_interpreter.h"

#ifdef WIN32
#ifndef LIBMAT
#define mat_export extern __declspec(dllimport)
#else
#define mat_export extern __declspec(dllexport)
#endif
#else
#define mat_export extern
#endif

mat_export str MATnew(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
mat_export str MATpack(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
mat_export str MATpackInternal(MalStkPtr stk, InstrPtr p,int first);
mat_export str MATpackValues(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
mat_export str MATnewIterator(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
mat_export str MAThasMoreElements(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
mat_export str MATdummy(int *ret, str *grp);
mat_export str MATinfo(int *ret, str *grp, str *elm);
mat_export str MATprint(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
mat_export str MATcount(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
mat_export str MATmin(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
mat_export str MATmax(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
#endif /* _INSPECT_H */
@- 
Mal symbol table and environment analysis.
@c
#include "mal_config.h"
#include "mat.h"

str
MATnew(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	(void) cntxt; (void) mb; 
	return MATpackInternal(stk,p,1);
}
str
MATnewIterator(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	int *ret = (int*) getArgReference(stk,p,0);
	(void) cntxt;
	(void) mb; 
	if( p->argc == 1){
		*ret = 0;
	} else
		*ret= *(int*) getArgReference(stk,p,1);
	return MAL_SUCCEED;
}
str
MAThasMoreElements(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	int *ret = (int*) getArgReference(stk,p,0);
	int i, idx = *ret;

	(void) cntxt;
	(void) mb; 
	for(i=1; i< p->argc; i++)
	if( *(int*) getArgReference(stk,p,i) == idx){
		i++;
		break;
	}
	if( i < p->argc)
		*ret= *(int*) getArgReference(stk,p,i);
	else
		*ret = 0;
	(void) mb; 
	return MAL_SUCCEED;
}
@-
The pack is an ordinary multi BAT insert. Oid synchronistion
between pieces should be ensured by the code generators.
The pack operation could be quite expensive, because it
may create a really large BAT.
@c
str
MATpackInternal(MalStkPtr stk, InstrPtr p,int first)
{
	int i,*ret;
	BAT *b, *bn;
	BUN cap=0;

	b= BATdescriptor(stk->stk[getArg(p,first)].val.ival);
	if( b == NULL)
		throw(MAL, "mat.pack", RUNTIME_OBJECT_MISSING);
	bn = BATcopy(b, b->htype, b->ttype, TRUE);
	if( bn == NULL)
		throw(MAL, "mat.pack", MAL_MALLOC_FAIL);
	BBPunfix(b->batCacheid);

	for(i = first+1; i < p->argc; i++){
		b= BATdescriptor(stk->stk[getArg(p,i)].val.ival);
		cap += BATcount(b);
		BBPunfix(b->batCacheid);
	}
	bn = BATextend(bn, cap);
	for( i = first+1; i < p->argc; i++){
		b= BATdescriptor(stk->stk[getArg(p,i)].val.ival);
		if( b == NULL)
			throw(MAL, "mat.pack", RUNTIME_OBJECT_MISSING);
		/* use the right oid ranges, don't change the input */
		BATins(bn,b,FALSE);
		BBPunfix(b->batCacheid);
	}
	ret= (int*) getArgReference(stk,p,0);
	BBPkeepref(*ret = bn->batCacheid);
	return MAL_SUCCEED;
}

str
MATpack(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	(void) cntxt;
	(void) mb;
	return MATpackInternal(stk,p,1);
}

str
MATpackValues(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	int i,*ret, type, first = 1;
	BAT *bn;

	(void) cntxt;
	type = getArgType(mb,p,first);
	bn = BATnew(TYPE_void, type, p->argc);
	if( bn == NULL)
		throw(MAL, "mat.pack", MAL_MALLOC_FAIL);

	for(i = first; i < p->argc; i++)
		BUNappend(bn, getArgReference(stk, p, i), TRUE);
	ret= (int*) getArgReference(stk,p,0);
	BBPkeepref(*ret = bn->batCacheid);
	return MAL_SUCCEED;
}

str
MATprint(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	(void) cntxt; (void) mb; (void) stk; (void) p;
	return MAL_SUCCEED;
}

str
MATdummy(int *ret, str *grp){
	(void) grp; (void) ret;
	return MAL_SUCCEED;
}
str
MATinfo(int *ret, str *grp, str *elm){
	(void) grp; (void) elm; (void) ret;
	return MAL_SUCCEED;
}

@= MATcount
{
	@1 a@1 = 0;
	for( i = p->retc; i<p->argc; i++)
	if ( ATOMcmp(t, ATOMnilptr(t), (@1*)getArgReference(stk,p,i)) == 0){
		* (@1 *) getArgReference(stk,p,0) = @1_nil;
		return MAL_SUCCEED;
	} else
		a@1 += *(@1*) getArgReference(stk,p,i);
	* (@1 *) getArgReference(stk,p,0) = a@1;
}
@c
str
MATcount(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	int i,t;
	(void) cntxt;

	t = getArgType(mb,p,0);
	switch(ATOMstorage(t)) {
	case TYPE_chr: @:MATcount(chr)@ break;
	case TYPE_bte: @:MATcount(bte)@ break;
	case TYPE_sht: @:MATcount(sht)@ break;
	case TYPE_int: @:MATcount(int)@ break;
	case TYPE_flt: @:MATcount(flt)@ break;
	case TYPE_dbl: @:MATcount(dbl)@ break;
	case TYPE_lng: @:MATcount(lng)@ break;
	default:
		throw(MAL, "mat.sum", PROGRAM_NYI);
	}
	return MAL_SUCCEED;
}

@= MATaggr
{
	int (*cmp)(ptr,ptr) = BATatoms[t].atomCmp;
	@1 a@1 = * (@1 *) getArgReference(stk,p,1);

	for( i = p->retc+1; i<p->argc; i++)
	if ( ATOMcmp(t, ATOMnilptr(t), (@1*)getArgReference(stk,p,i)) == 0){
		* (@1 *) getArgReference(stk,p,0) = @1_nil;
		return MAL_SUCCEED;
	} else
		a@1 = ((*cmp)(&a@1, (@1*)getArgReference(stk,p,i)) @2 0)? 
			a@a: *(@1*)getArgReference(stk,p,i);
	* (@1 *) getArgReference(stk,p,0) = a@1;
}
@= MATaggrBody
str
MAT@1(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	int i,t;
	(void) cntxt;

	t = getArgType(mb,p,0);
	switch(ATOMstorage(t)) {
	case TYPE_chr: @:MATaggr(chr,@2)@ break;
	case TYPE_bte: @:MATaggr(bte,@2)@ break;
	case TYPE_sht: @:MATaggr(sht,@2)@ break;
	case TYPE_int: @:MATaggr(int,@2)@ break;
	case TYPE_flt: @:MATaggr(flt,@2)@ break;
	case TYPE_dbl: @:MATaggr(dbl,@2)@ break;
	case TYPE_lng: @:MATaggr(lng,@2)@ break;
	default:
		throw(MAL, "mat.@1", PROGRAM_NYI);
	}
	return MAL_SUCCEED;
}
@:MATaggrBody(min,<=)@
@:MATaggrBody(max,>)@

@}
