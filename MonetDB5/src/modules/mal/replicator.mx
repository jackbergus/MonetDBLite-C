@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
@' Copyright August 2008-2009 MonetDB B.V.
@' All Rights Reserved.

@f replicator
@a Martin Kersten
@v 1.0
@+ Database replication
The replication module supports distribution of updates over SQL
databases at multiple sites using a simple master-slave protocol using a
MAL-based update log.  Note that the current replication approach does
not support replication of schema changes, such as added tables or
columns.  Setup the full catalog before transitioning a database to a
replication master. 
Run the script sql/replication.sql to create the tables for managing the slaves.

To configure a database to become a replication master, set its "master"
property to true using monetdb(1).  This property is translated by
merovingian(1) into the replication_master GDK environment setting.
With this setting, the database will log all update actions in a
replication logfile, allowing slaves to replicate.

The next step is to create a snapshot of the master to be replicated to
one or more slaves.  For this, the msqldump(1) tool can be used.  
A dump made on a replication master includes administrative data
for the slave to contact the master in the form of a pre-initialized 
table.
Alternatively, the DBA can make a safe copy from the corresponding dbfarm
directory.

To initiate a slave, simply load a master snapshot.  If the master was
able to properly fully qualify itself, the snapshot dump includes a
a function to retrieve the replication master identity.
After loading the dump, the slave will not automatically start
replicating, until the database is restarted or the command CALL
'slave_start(master());' is executed.  A database that has a slave
configuration will automatically attempt to continue replicating during
startup.
Note that replication is implemented push-based, that is, the master makes a
call-back to the requesting slave to deliver its updates using an independent
client connection with its own user name and password credentials.
A master can be told to temporarily stop sending updates using the 
command 'CALL slave_stop(master());'.

A freshly initialised slave starts replicating off of the
master starting from the tag maintained by the master for each slave.
The master can be optionally forced to start at a particular tag.

The replication scheme allows a slave to be cloned e.g. by copying the
dbfarm of the slave to another database without problems.  No
configuration on the copied slave needs to be changed for it to
successfully replicate off of the master.

@- Behind the scene
Under the replication scheme an optimizer becomes active.
It looks for updates on the persistent SQL tables and prepares
for producing the log files.
For this to take place the environment variable
replication_master must be set to 'yes'. 

@verbatim
function query():void
  tag:= master.open();
  ...
  sql.append("schema","table","col",b:[:oid,:int]);
  master.append("schema","table","col",b,tag);
  ...
  t := mtime.current_timestamp();
  master.close();
end query;
@end verbatim

At runtime this leads to buffers being filled with the statements
required for the slaves to catch up. 
Each query block is stored in its own buffer and sent at
the end of the query block. This separates the concurrent 
actions on the database at the master and leads to a serial
execution of the replication operations within the slave.

They are stored in a file "dbfarm/db/master/tag_%d" with the 
following structure:
@verbatim
slave.init("uri");
function slave.tag1();
  slave.open(1,"2009-08-16 18:57:58.000":timestamp);
  tag1_b := bat.new(:oid,:int);
  ...
  bat.insert(tag1_b,3:oid,232:int); #example update
  ...
  sql.append("schema","table","col",tag1_b,tag);
  slave.close(1,"2009-08-16 18:57:58.000":timestamp);
  tag1_b:= nil;
end tag1;
slave.tag1();
slave.drop("tag1");
@end verbatim

Grouping the operations within temporary functions
makes it easy to skip its execution when we detect
that it has been executed before. The slave.open()
simply checks the replicas administration table
and issues an assertion if necessary.

The operations are executed in the serial order as on the master,
which should lead to the same optimistic transactional behavior.
All queries are considered running in auto-commit mode, because
the SQL frontend does not provide the hook (yet) for better transaction
boundary control.

Local updates on the replicated tables are forbidden, but it is not
enforced.

@- Log file management
The log records are grouped into chunks, each represented by
a file. Those files are the units for re-submission and the scheme
is set up to be idempotent. 
The log files will ultimately polute your database and have to
be (re)moved. This is considered a responsibility for the DBA,
for it involves making a checkpoint or securely storing the logs
into an archive. 

The current implementation assumes that all log files are known,
e.g. they can be zapped to zero length, but may not be completely
removed.

@{
@mal
module master;

command open():int
address MASTERopen
comment "Create a replication record";

command close(tag:int):void
address MASTERclose
comment "Close the replication record";

pattern append(s:str, t:str, c:str, :any_1, tag:int):void
address MASTERappendValue
comment "Dump the scalar on the MAL log");

pattern append(s:str, t:str, c:str, b:bat[:oid,:any_1], tag:int):void
address MASTERappend
comment "Dump the BAT on the MAL log");

pattern delete(s:str, t:str, b:bat[:oid,:any_1], tag:int):void
address MASTERdelete
comment "Dump the BAT with deletions on the MAL log");

command replay(uri:str, usr:str, pw:str, tag:int):void
address MASTERreplay
comment "Start the replication log replayer thread feeding
the slave with the necessary log records. It simply pumps the
data until running out for log info.";

pattern start(uri:str):void
address MASTERstart
comment "Restart sending the missing transactions for slave uri";
pattern start(uri:str, tag:int):void
address MASTERstart
comment "Restart sending the missing transactions for slave uri";

command stop(uri:str):void
address MASTERstart
comment "Stop sending the missing transactions for slave uri";

command getName():str
address MASTERgetName
comment "Return the name of the server if it is a master, otherwise
pick the first name from the replicas table";

module slave;

pattern init( uri:str)
address SLAVEinit
comment "Determine the master client record for early abort ";

command open(tag:int,d:timestamp)
address SLAVEopen
comment "Marks the start of a replication record. It checks the replicas
table for existence of the tag. If so, it aborts the attempt to reapply.";

command close(tag:int, d:timestamp)
address SLAVEclose
comment "End of replication record. Add the tag to the replicas table
using the SQL transaction semantics.";

command drop(tag:str)
address SLAVEdrop
comment "Remove the replica function from the module";
@-
@+ Implementation code 
@h
#ifndef _REPLICATOR_H
#define _REPLICATOR_H

#include "mal.h"
#include "mal_instruction.h"
#include "mal_interpreter.h"
#include "mal_namespace.h"
#include <mapilib/Mapi.h>
#include "remote.h"
#include "mtime.h"

#define _DEBUG_REPLICATOR_

#ifdef WIN32
#ifndef LIBREPLICATOR
#define replicator_export extern __declspec(dllimport)
#else
#define replicator_export extern __declspec(dllexport)
#endif
#else
#define replicator_export extern
#endif

replicator_export int MASTERroleEnabled();
replicator_export str MASTERopen(int *ret);
replicator_export str MASTERstop(int *ret, str *uri);
replicator_export str MASTERclose(int *ret, int *tag);
replicator_export str MASTERstart(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
replicator_export str MASTERappendValue(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
replicator_export str MASTERappend(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
replicator_export str MASTERdelete(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
replicator_export str MASTERreplay(int  *ret, str *uri, str *usr, str *pw, int *tag);
replicator_export str MASTERgetName(str *ret);

replicator_export str SLAVEinit(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
replicator_export str SLAVEopen(int *ret, int *tag, timestamp *t);
replicator_export str SLAVEclose(int *ret, int *tag, timestamp *t);
replicator_export str SLAVEdrop(int *ret, str *tag);
#endif /* _REPLICATOR_H */
@-
The active slaves are administered in a persistent table.
@c
#include "mal_config.h"
#include "replicator.h"
#include "mal_client.h"
#include <mal_sabaoth.h> 

@-
The start of the query is marked with a replica tag.
It also designates the local buffer to collect the update
requests before they are shipped to the log.
The tag is returned for marking all related updates.
The final code should contain a loop to determine the last replicator tag.
@c
#define MASTER "master"
#define SLAVE "slave"
#define REPLICA "/log_%d"
#define REPLICABLOCK 1000

static MT_Lock repLck;
static int replicationTag;
static stream *repFile;

static struct MASTERRECORD{
	char *buf;
	int limit, top;
	int tag;
} *master;
static int mtop = 0 , mlimit = 0;

int
MASTERroleEnabled()
{
	return replicationTag > 0;
}

static int MASTERgetBuffer(int tag){
	int i;

	for ( i = 0; i < mtop ; i++)
	if ( master[i].tag == tag)
		return i;
	for ( i = 0; i < mlimit ; i++)
	if ( master[i].tag == 0)
		break;
	if ( i == 0){
		master = GDKzalloc(sizeof(struct MASTERRECORD) * (mlimit +32));
		mlimit = 32;
	} else
	if ( i == mlimit){
		master = GDKrealloc(master, sizeof(struct MASTERRECORD) * (mlimit +32));
		mlimit += 32;
	}
	mtop = i >= mtop ? i+1: mtop;
	if ( master[i].buf == 0){
		master[i].buf = (char*) GDKzalloc(2*1024);
		master[i].limit = 2*1024;
		master[i].top = 0;
	}
	master[i].tag = tag;
	return i;
}
@-
For the time being, we assume that all chunks are kept in the
master directory. A better scheme is to find the last chunk
by reading the directory itself.
@c
str MASTERopen(int *ret){
	char buf[BUFSIZ];
	FILE *fp = 0;
	timestamp stamp;
	str val=0;
	int i,l,len;
	
	if ( replicationTag == 0)
		MT_lock_init(&repLck,"replicator");
	mal_set_lock(repLck,"replicator");
	if ( repFile == NULL){
		mkdir(MASTER,0755); /* ensure existance of the replica pool */
		if ( replicationTag == 0){
			/* find the last one already in the pool, using the REPLICABLOCK */
			do {
				if (fp) {
					replicationTag += REPLICABLOCK;
					fclose(fp);
				}
				snprintf(buf, BUFSIZ, MASTER REPLICA, replicationTag);
				fp = fopen(buf,"r");
			} while (fp);
		}
		snprintf(buf, BUFSIZ, MASTER REPLICA, replicationTag);
		repFile = open_wastream(buf);
		if ( repFile == NULL || stream_errnr(repFile) ){
			mal_unset_lock(repLck,RUNTIME_STREAM_FAILED);
			throw(MAL,"master.start",RUNTIME_STREAM_FAILED);
		}
	}
	/* get a replica buffer */
	replicationTag++;
	i = MASTERgetBuffer(replicationTag);
	/* prepare the MAL redo record */
	MTIMEepoch(&stamp);
	ATOMformat(TYPE_timestamp, (ptr) &stamp, &val);
	len = master[i].limit - master[i].top -1;
	while ( (l = snprintf(master[i].buf + master[i].top, len ,
			"function slave.tag_%d(tag:int,stamp:timestamp);\nslave.open(tag,\"%s\":timestamp);\n",
				replicationTag, val)) == len){
		master[i].buf = (char*) GDKrealloc(master[i].buf, master[i].limit + 1024);
		if ( master[i].buf == NULL)
			throw(MAL,"replicator.open",MAL_MALLOC_FAIL);
		master[i].limit += 1024;
		len = master[i].limit - master[i].top -1;
	}
	master[i].top += l;
	master[i].buf[master[i].top] = 0;
	mal_unset_lock(repLck,RUNTIME_STREAM_FAILED);

	*ret = replicationTag ;
	return MAL_SUCCEED;
}

str MASTERclose(int *ret, int *tag){
	timestamp stamp;
	str val=0;
	int i,l,len;
	char buf[BUFSIZ];

	(void) ret;
	i = MASTERgetBuffer(*tag);
	mal_set_lock(repLck,"replicator");
	MTIMEepoch(&stamp);
	ATOMformat(TYPE_timestamp, (ptr) &stamp, &val);
	snprintf(buf,BUFSIZ,"tag_%d",*tag);
	len = master[i].limit - master[i].top -1;
	while ( (l = snprintf(master[i].buf + master[i].top, len, 
		"slave.close(tag,stamp);\nsql.commit();\nend tag_%d;\nslave.tag_%d(%d,\"%s\":timestamp);\nslave.drop(\"%s\");\n",
		*tag,*tag,*tag,val,buf)) == len){
		master[i].buf = (char*) GDKrealloc(master[i].buf, master[i].limit + 1024);
		if ( master[i].buf == NULL)
			throw(MAL,"replicator.close",MAL_MALLOC_FAIL);
	}
	master[i].top += l;
	master[i].buf[master[i].top] = 0;
	GDKfree(val);
	stream_printf(repFile,"%s", master[i].buf);
	stream_flush(repFile);
	master[i].buf[0]=0;
	master[i].top = 0;
	master[i].top = 0;
	if ( stream_errnr(repFile) ){
		mal_unset_lock(repLck,"replicator");
		throw(MAL,"replicator.close",RUNTIME_STREAM_FAILED);
	}
	if ( replicationTag % REPLICABLOCK  == 0){
		close_stream(repFile);
		repFile = NULL;
	}
	mal_unset_lock(repLck,"replicator");
	return MAL_SUCCEED;
}

static str
MASTERdump( BAT *b, str buf, int type, int tag){
	BATiter bi;
	BUN p,q;
	char *headv = 0, *tailv= 0;
	str head = getTypeName(getHeadType(type));
	str tail = getTypeName(getTailType(type));
	int i, l, len;
	
	i = MASTERgetBuffer(tag);
	bi = bat_iterator(b);
	BATloop(b,p,q){
		ATOMformat(getHeadType(type), BUNhead(bi, p), &headv);
		ATOMformat(getTailType(type), BUNtail(bi, p), &tailv);
		len = master[i].limit - master[i].top -1;
		if ( getTailType(type) <=TYPE_str &&
			getHeadType(type) <= TYPE_str) {
			while ( (l = snprintf(master[i].buf + master[i].top, len ,"bat.insert(%s, %s:%s, %s:%s);\n",
						buf, headv, head, tailv, tail)) >= len){
				master[i].buf = (char*) GDKrealloc(master[i].buf, master[i].limit + 1024);
				if ( master[i].buf == NULL)
					throw(MAL,"replicator.dump",MAL_MALLOC_FAIL);
				master[i].limit += 1024;
				len = master[i].limit - master[i].top -1;
			}
		} else
		if ( getTailType(type) >TYPE_str  &&
			getHeadType(type) > TYPE_str) {
			while ( (l = snprintf(master[i].buf + master[i].top, len , "bat.insert(%s, \"%s\":%s, \"%s\":%s);\n",
						buf, headv, head, tailv, tail)) >= len){
				master[i].buf = (char*) GDKrealloc(master[i].buf, master[i].limit + 1024);
				if ( master[i].buf == NULL)
					throw(MAL,"replicator.dump",MAL_MALLOC_FAIL);
				master[i].limit += 1024;
				len = master[i].limit - master[i].top -1;
			}
		} else
		if ( getTailType(type) >TYPE_str ) {
			while ( (l = snprintf(master[i].buf + master[i].top, len , "bat.insert(%s, %s:%s, \"%s\":%s);\n",
						buf, headv, head, tailv, tail)) == len){
				master[i].buf = (char*) GDKrealloc(master[i].buf, master[i].limit + 1024);
				if ( master[i].buf == NULL)
					throw(MAL,"replicator.dump",MAL_MALLOC_FAIL);
				master[i].limit += 1024;
				len = master[i].limit - master[i].top -1;
			}
		} else{
			while ( (l = snprintf(master[i].buf + master[i].top, len , "bat.insert(%s, \"%s\":%s, %s:%s);\n",
						buf, headv, head, tailv, tail)) == len){
				master[i].buf = (char*) GDKrealloc(master[i].buf, master[i].limit + 1024);
				if ( master[i].buf == NULL)
					throw(MAL,"replicator.dump",MAL_MALLOC_FAIL);
				master[i].limit += 1024;
				len = master[i].limit - master[i].top -1;
			}
		}
		master[i].top += l;
		master[i].buf[master[i].top] = 0;
	}
	GDKfree(tail);
	GDKfree(head);
	return MAL_SUCCEED;
}

str
MASTERappendValue(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	int tag = *(int*) getArgReference(stk,pci,5);
	InstrPtr q;
	str val= NULL;
	int i,l,len;

#ifdef _DEBUG_REPLICATOR_
	(void) cntxt;
#endif
	if ( repFile == NULL)
		throw(MAL,"replicator.append", RUNTIME_FILE_NOT_FOUND);

	i = MASTERgetBuffer(tag);
	q= copyInstruction(pci);
	q->argc--;
	setModuleId(q,putName("sql",3));
	
	val = instruction2str(mb,stk,q,LIST_MAL_CALL);
	freeInstruction(q);

	len = master[i].limit - master[i].top -1;
	while ( (l = snprintf(master[i].buf + master[i].top, len , "%s\n", val) >= len ) ){
		master[i].buf = (char*) GDKrealloc(master[i].buf, master[i].limit + 1024);
		if ( master[i].buf == NULL)
			throw(MAL,"replicator.append",MAL_MALLOC_FAIL);
		master[i].limit += 1024;
		len = master[i].limit - master[i].top -1;
	}
	master[i].top += strlen(val);
	master[i].buf[master[i].top] = 0;
	GDKfree(val);
	return MAL_SUCCEED;
}

str
MASTERappend(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	str *schema = (str*) getArgReference(stk,pci,1);
	str *table = (str*) getArgReference(stk,pci,2);
	str *col = (str*) getArgReference(stk,pci,3);
	int *bid = (int*) getArgReference(stk,pci,4);
	int tag = *(int*) getArgReference(stk,pci,5);
	BAT *b;
	char buf[BUFSIZ];
	int type = getArgType(mb, pci, 4);
	str head = getTypeName(getHeadType(type));
	str tail = getTypeName(getTailType(type));
	int i, l, len;
	str msg;

#ifdef _DEBUG_REPLICATOR_
	(void) cntxt;
#endif
	if ( repFile == NULL)
		throw(MAL,"replicator.append", RUNTIME_FILE_NOT_FOUND);
	b = BATdescriptor(*bid);
	if ( b == NULL)
		throw(MAL,"replicator.append", RUNTIME_OBJECT_MISSING);

	i = MASTERgetBuffer(tag);
	/* create the temporary bat */
	len = master[i].limit - master[i].top -1;
	while ( (l = snprintf(master[i].buf + master[i].top, len , "tag_%d_%s:=bat.new(:%s,:%s);\n",
				tag, getArgName(mb,pci,4), head, tail)) >= len ){
		master[i].buf = (char*) GDKrealloc(master[i].buf, master[i].limit + 1024);
		if ( master[i].buf == NULL)
			throw(MAL,"replicator.append",MAL_MALLOC_FAIL);
		master[i].limit += 1024;
		len = master[i].limit - master[i].top -1;
	}
	master[i].top += l;
	master[i].buf[master[i].top] = 0;

	/* fill it */
	snprintf(buf,BUFSIZ,"tag_%d_%s", tag, getArgName(mb,pci,4));
	msg = MASTERdump(b,buf,type, tag);
	if (msg != MAL_SUCCEED)
		return msg;

	/* execute the original append */
	len = master[i].limit - master[i].top -1;
	while ( (l = snprintf(master[i].buf + master[i].top, len , "sql.append(\"%s\",\"%s\",\"%s\",%s);\ntag_%d_%s := nil;\n",
		*schema, *table, *col, buf,tag, getArgName(mb,pci,4)) ) >= len){
		master[i].buf = (char*) GDKrealloc(master[i].buf, master[i].limit + 1024);
		if ( master[i].buf == NULL)
			throw(MAL,"replicator.append",MAL_MALLOC_FAIL);
		master[i].limit += 1024;
		len = master[i].limit - master[i].top -1;
	}
	master[i].top += l;
	master[i].buf[master[i].top] = 0;
	GDKfree(head);
	GDKfree(tail);
	return MAL_SUCCEED;
}

str
MASTERdelete(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	str *schema = (str*) getArgReference(stk,pci,1);
	str *table = (str*) getArgReference(stk,pci,2);
	int *bid = (int*) getArgReference(stk,pci,3);
	int tag = *(int*) getArgReference(stk,pci,4);
	BAT *b;
	char buf[BUFSIZ];
	int type = getArgType(mb, pci, 3);
	str head = getTypeName(getHeadType(type));
	str tail = getTypeName(getTailType(type));
	str msg;
	int i, l, len;

#ifdef _DEBUG_REPLICATOR_
	(void) cntxt;
#endif
	if ( repFile == NULL)
		throw(MAL,"replicator.delete", RUNTIME_FILE_NOT_FOUND);
	b = BATdescriptor(*bid);
	if ( b == NULL)
		throw(MAL,"replicator.delete", RUNTIME_OBJECT_MISSING);

	i = MASTERgetBuffer(tag);
	/* create the temporary bat */
	len = master[i].limit - master[i].top -1;
	while ( (l = snprintf(master[i].buf + master[i].top, len , "tag_%d_%s:=bat.new(:%s,:%s);\n",
				tag, getArgName(mb,pci,3), head, tail)) == len ){
		master[i].buf = (char*) GDKrealloc(master[i].buf, master[i].limit + 1024);
		if ( master[i].buf == NULL)
			throw(MAL,"replicator.delete",MAL_MALLOC_FAIL);
		master[i].limit += 1024;
		len = master[i].limit - master[i].top -1;
	}
	master[i].top += l;
	master[i].buf[master[i].top] = 0;

	/* fill it */
	snprintf(buf,BUFSIZ,"tag_%d_%s", tag, getArgName(mb,pci,3));
	msg = MASTERdump(b,buf,type, tag);
	if (msg != MAL_SUCCEED)
		return msg;

	/* execute the original append */
	len = master[i].limit - master[i].top -1;
	while ( (l = snprintf(master[i].buf + master[i].top, len , "sql.delete(\"%s\",\"%s\",%s);\ntag_%d_%s := nil;\n",
			*schema, *table, buf, tag, getArgName(mb,pci,4))) == len){
		master[i].buf = (char*) GDKrealloc(master[i].buf, master[i].limit + 1024);
		if ( master[i].buf == NULL)
			throw(MAL,"replicator.delete",MAL_MALLOC_FAIL);
		master[i].limit += 1024;
		len = master[i].limit - master[i].top -1;
	}
	master[i].top += l;
	master[i].buf[master[i].top] = 0;
	GDKfree(head);
	GDKfree(tail);
	return MAL_SUCCEED;
}

@-
Replaying the MAL logs is straightforward. We perform a remote
operation execution on the master to initiate a quick dump of the
missing operations. The master keeps a [persistent] structure
with the status of all completed logfiles being sent to slaves.

The replay should be performed in an independent thread to enable
the slave to continue processing. Furthermore we assume that
all log files still exist (but may be zapped)
The slave is initialized by echoing the master uri.
This makes it possible to later easily close the connection.
We might refine it to read local log files too.
@c
static struct MASTERrecord{
	str uri;
	int idx;	/* for its forced termination */
	time_t last_connect;
	time_t last_disconnect;
	int tag;	/* next one to sent */
	Mapi m;
} masterstatus[MAL_MAXCLIENTS];

#define _DEBUG_REPLICATOR_
static void
MASTERreplayThread(void *arg)
{
	struct MASTERrecord *mr = (struct MASTERrecord *) arg;
	char buf[BUFSIZ+1];
	MapiHdl hdl;
	bstream *in;
	stream *s;
#ifdef _DEBUG_REPLICATOR_
	stream_printf(GDKout,"#replay thread started %s\n",mr->uri);
#endif

	mr->last_connect = time(0);
	mr->last_disconnect = 0;
	buf[BUFSIZ] = 0;
	snprintf(buf, BUFSIZ,"slave.init(\"%s\");\n",mr->uri);
	hdl = mapi_query(mr->m, buf);
	if (hdl)
		mapi_close_handle(hdl);
	do {
		snprintf(buf, BUFSIZ, MASTER REPLICA, (mr->tag / REPLICABLOCK) *REPLICABLOCK);
		s= open_rstream(buf);
		if ( stream_errnr(s) )
			break;
		in = bstream_create(s, BUFSIZ);
		if (in == NULL ) 
			break;
		while ( in && in->eof == 0){
			if (bstream_read(in, BUFSIZ) <= 0 )
				break;
#ifdef _DEBUG_REPLICATOR_
			stream_printf(GDKout,"#sent:%s\n", in->buf);
#endif
			/* sent the data to the server */
			/* FIXME: just write, don't look at the response */
			hdl = mapi_query(mr->m, in->buf);
			if (hdl)
				mapi_close_handle(hdl);
		} 
@-
Upon succesful transmission we update the log file tag for the slage
@c
		mr->tag += REPLICABLOCK;
	} while (1); /* stop when you run out of log files */

	mr->last_connect = time(0);
	mapi_disconnect(mr->m);
	mapi_destroy(mr->m);
	mr->m = 0;
#ifdef _DEBUG_REPLICATOR_
	stream_printf(GDKout,"#replay thread finished %s %d\n",mr->uri, mr->tag);
#endif
}

str MASTERreplay(int  *ret, str *uri, str *usr, str *pw, int *tag)
{
	struct MASTERrecord *mr = masterstatus;
	MT_Id tid;

	(void) ret;

#ifdef _DEBUG_REPLICATOR_
	printf("#replay the log to  %s %s %s %d\n", *uri, *usr, *pw, *tag);
#endif
	for( mr= masterstatus; mr->uri && mr < masterstatus+ MAL_MAXCLIENTS-1; mr++)
		if ( strcmp(mr->uri,*uri) == 0) {
			if ( *tag >= 0)
				mr->tag = *tag;
			break;
		}
	if ( mr->uri == NULL){
		mr->uri = GDKstrdup(*uri);
		mr->tag = 0;
	}
	
	mr->m = mapi_mapiuri(*uri, *usr, *pw, "mal");
	if (mapi_error(mr->m))
		throw(MAL, "master.replay", "unable to connect: %s", mapi_error_str(mr->m));

	if (mapi_reconnect(mr->m) != MOK) {
		throw(IO, "master.replay", OPERATION_FAILED 
				": an error occurred during connect to '%s': %s",
				*uri, mapi_error_str(mr->m));
	}
	MT_create_thread(&tid, MASTERreplayThread,(void*) mr);
	return MAL_SUCCEED;
}

str MASTERstart(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	str *uri= (str*) getArgReference(stk,pci,1);
	int tag = -1;
	str usr = "monetdb";
	str pw = "monetdb";

	(void) cntxt;
	(void) mb;
	if ( pci->argc ==2)
		tag= *(int*) getArgReference(stk,pci,2);

	return MASTERreplay(getArgReference(stk,pci,0),uri,&usr,&pw,&tag);
}

@-
The master can be stopped by closing its client record.
Its identity is obtained using the slave routines.
@c
str MASTERstop(int *ret, str *uri){
	struct MASTERrecord *mr;
	(void) ret;
	(void) uri;
	for( mr= masterstatus; mr->uri && mr < masterstatus+ MAL_MAXCLIENTS-1; mr++)
	if ( strcmp(mr->uri, *uri) == 0){
		if ( mr->idx ){
			/* soft termination at next MAL instruction */
			mal_clients[mr->idx].itrace ='x';
			mal_clients[mr->idx].mode = FINISHING;
		}
	}
	return MAL_SUCCEED;
}

str MASTERgetName(str *ret)
{
	struct MASTERrecord *mr;

	if( GDKgetenv("replication_master") ){
		SABAOTHgetLocalConnection(ret);
		return MAL_SUCCEED;
	}
		
	for( mr= masterstatus; mr->uri && mr < masterstatus+ MAL_MAXCLIENTS-1; mr++)
		*ret = GDKstrdup(mr->uri);

	throw(MAL,"master.getName","No master name found");
}
@-
We should assure that only operations we haven't seen are
being executed. This is based on the tag assigned to each
replicator block. 
@c
str SLAVEinit(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	struct MASTERrecord *mr;
	str *uri = (str*) getArgReference(stk,pci,1);
	(void) mb;
	/* find the corresponding master record */
	for( mr= masterstatus; mr->uri && mr < masterstatus+ MAL_MAXCLIENTS-1; mr++)
	if ( strcmp(mr->uri, *uri) == 0){
		mr->idx= cntxt->idx;
		break;
	}
	return MAL_SUCCEED;
}

str SLAVEopen(int *ret, int *tag, timestamp *t){
	(void) ret;
	(void) t;
	if ( *tag < replicationTag)
		throw(MAL,"slave.open","Operation ignored");
	return MAL_SUCCEED;
}

str SLAVEclose(int *ret, int *tag, timestamp *t){
	(void) ret;
	(void) t;
	replicationTag = *tag;
	return MAL_SUCCEED;
}

str
SLAVEdelete(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	str *schema = (str*) getArgReference(stk,pci,1);
	str *table = (str*) getArgReference(stk,pci,2);
	int *bid = (int*) getArgReference(stk,pci,3);
	int tag = *(int*) getArgReference(stk,pci,4);

	(void) cntxt;
	(void) mb;
	(void) schema;
	(void) table;
	(void) bid;
	(void) tag;
	return MAL_SUCCEED;
}

str
SLAVEdrop(int *ret, str *tag)
{
	Symbol prg;
	Module mod;
	prg = findSymbol(NULL, getName("slave",5), *tag);
	mod = findModule(NULL, getName("slave",5));
	if ( prg == NULL || mod == NULL)
		throw(MAL,"slave.drop","Symbol not found");
	deleteSymbol(mod,prg);
	(void) ret;
	return MAL_SUCCEED;
}

@}
