@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
@' Copyright August 2008-2009 MonetDB B.V.
@' All Rights Reserved.

@f replicator
@a Martin Kersten
@v 1.0
@+ Database replication
[NOT COMPLETED]
The replicator module supports distribution of the SQL database
over multiple sites using a master slave protocol.

The replicator assumes that both database have the same catalog information.
There is no automatic propagation of CREATE, DROP, nor ALTER statements. 
Moreover, the master database should be accessible through Merovingian.

The lean and mean replication scheme implementation works as follows.
The plan is extended by the optimizer to retrieve
the latest database version identifier using a back call to the master
issueing a sql.getVersion(), which should mark the current transaction
time. (is is db wide or per table/group?)

If the version is newer then what we know (stored as an argumen
This overloaded bind synchronises the local copy using a
straightforward algorithm. It contacts the master to obtain
the last known version id for the BAT. If it is out of sink,
the complete BAT is transmitted. 

Consider the plan derived from "select count(*) from tables;".
The snippet below illustrates the code to be produced by the
replicator optimizer.

@verbatim
function octopussy.tentacle_1();
	remote.create("master", "localhost",50000,"master","monetdb","monetdb");
	replicator.setMaster("master");	# marker
	oldversion: =replicator.setVersion(20090106);	# version at compile time 
	id:rmtobj:= remote.exec("mastername","sql","getVersion");
	version:lng := remote.get("master",id);

#	_1:bat[:oid,:sht]  := sql.bind("tmp","_tables","type",0);
	sch:rmtobj:= remote.put("master","tmp");
	tab:rmtobj:= remote.put("master","_tables");
	col:rmtobj:= remote.put("master","type");
	acc:rmtobj:= remote.put("master",0);
	ov:rmtobj := remote.put("master",oldversion);
	nv:rmtobj := remote.put("master",version);
	copy:rmtobj := remote.exec("master","sql","getBATversion",sch,tab,col,acc,ov,nv);
	_1:bat[:oid,:sht]  := remote.get("master",copy);
	...
@end verbatim
The next level of improvement is to keep the accumulated delta
lists at sql. This would require something like :
@verbatim
	ins:rmtobj := remote.exec("master","sql","getBATinsert",sch,tab,col,acc,ov,nv);
	insert1:bat[:oid,:sht]  := remote.get("master",ins);
	del:rmtobj := remote.exec("master","sql","getBATdelete",sch,tab,col,acc,ov,nv);
	delete1:bat[:oid,:sht]  := remote.get("master",del);
	# now we have a problem, because _1 is not been initalized 
	_1:bat[:oid,:sht] := replicator.bind("tmp","_tables","type",0);
	bat.append(_1,insert1);
	bat.delete(_1,insert1);
@end verbatim
 the base is needed to initialize _1 only the firt time as
a persistent bat.

@mal
module replicator;

command setMaster(master:str):void
address REPsetMaster
comment "Mark the source of this database";

command setVersion(version:lng):lng
address REPsetVersion
comment "Keep the latest version in the symbol table as a constant";

pattern bind(nme:str,tab:str,col:str,acc:int,ov:lng,nv:lng):bat[:any_1,:any_2]
address REPbind
comment "Create a named persistent BAT if it was not known";

pattern bind_dbat(nme:str,tab:str,acc:int,ov:lng,nv:lng):bat[:any_1,:any_2]
address REPbind
comment "Create a named persistent BAT if it was not known";
@-
@{
@+ Implementation code 
@h
#ifndef _REPLICATOR_H
#define _REPLICATOR_H

#include "mal.h"
#include "mal_instruction.h"
#include "mal_interpreter.h"
#include "mal_namespace.h"

#define _DEBUG_REPLICATOR_

#ifdef WIN32
#ifndef LIBREPLICATOR
#define replicator_export extern __declspec(dllimport)
#else
#define replicator_export extern __declspec(dllexport)
#endif
#else
#define replicator_export extern
#endif

replicator_export str REPsetMaster(int *ret, str *nme);
replicator_export str REPsetVersion(int *ret, lng *version);
replicator_export str REPbind(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
replicator_export str REPbind_dbat(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
#endif /* _REPLICATOR_H */
@c
#include "mal_config.h"
#include "replicator.h"
#include <mapilib/Mapi.h>
#include "remote.h"

str
REPbind(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	int *ret = (int*) getArgReference(stk,pci,0);
	str *schema = (str*) getArgReference(stk,pci,1);
	str *table = (str*) getArgReference(stk,pci,2);
	str *col = (str*) getArgReference(stk,pci,3);
	int *acc = (int*) getArgReference(stk,pci,4);
	str msg= MAL_SUCCEED;
	BAT *b;
	char buf[BUFSIZ];

#ifdef _DEBUG_REPLICATOR_
	stream_printf(cntxt->fdout,"#sync master %s.%s.%s\n",*schema, *table, *col);
#else
	(void) cntxt;
#endif
	(void) mb;
	snprintf(buf,BUFSIZ,"%s_%s_%s_%d", *schema, *table, *col, *acc);
	*ret= BBPindex(buf);
	if (*ret == 0){
		int tpe= getArgType(mb,pci,0);
		b= BATnew(getHeadType(tpe),getTailType(tpe),0);
		if ( b== NULL)
			throw(MAL,"replicator.bind","Could not create BAT");
		BBPkeepref(*ret = b->batCacheid);
	}
	return msg;
}

str
REPbind_dbat(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	int *ret = (int*) getArgReference(stk,pci,0);
	str *schema = (str*) getArgReference(stk,pci,1);
	str *table = (str*) getArgReference(stk,pci,2);
	int *acc = (int*) getArgReference(stk,pci,4);
	str msg= MAL_SUCCEED;
	BAT *b;
	char buf[BUFSIZ];

#ifdef _DEBUG_REPLICATOR_
	stream_printf(cntxt->fdout,"#sync master %s.%s.%s\n",*schema, *table);
#else
	(void) cntxt;
#endif
	(void) mb;
	snprintf(buf,BUFSIZ,"%s_%s_%d", *schema, *table, *acc);
	*ret= BBPindex(buf);
	if (*ret == 0){
		int tpe= getArgType(mb,pci,0);
		b= BATnew(getHeadType(tpe),getTailType(tpe),0);
		if ( b== NULL)
			throw(MAL,"replicator.bind","Could not create BAT");
		BBPkeepref(*ret = b->batCacheid);
	}
	return msg;
}
str REPsetMaster(int *ret, str *nme){
	(void) ret;
	(void) nme;
	return MAL_SUCCEED;
}
str REPsetVersion(int *ret, lng *version){
	(void) ret;
	(void) version;
	return MAL_SUCCEED;
}
@}
