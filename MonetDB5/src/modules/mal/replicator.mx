@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
@' Copyright August 2008-2009 MonetDB B.V.
@' All Rights Reserved.

@f replicator
@a Martin Kersten
@v 1.0
@+ Database replication
The replication module supports distribution of updates over SQL databases
at multiple sites using a simple master-slave protocol using
a MAL-based update log.

A master-slave system is set up as follows. The master database
is initialized with the catalog and optionally loaded.
The script src/sql/replicas.sql is executed to prepare it
for the replication algorithms and define the commands
to modify the role of the database instance.

The next step is to clone the database using the monetdb tool. [todo]
Alternatively, copy the complete dbfarm/<db> directory to
the machine hosting the slave. 

The replication is based on the assumption that the database catalog
is shared between all instances. 
There is no automatic propagation of CREATE, DROP, nor ALTER statements
issued at the host.

The query plan is extended by the optimizer to initiate calls to build
a replicator log file (in master mode) or trap update attempts
on the replicated tables. [todo, how to know which tables are violated?
or property of sql catalog using readonly tables]

The master node replication optimizer changes the query plans
by injection of two statements;

@verbatim
function query():void
  tag:= master.open();
  ...
  sql.append("schema","table","col",b:[:oid,:int]);
  master.append("schema","table","col",b,tag);
  ...
  t := mtime.current_timestamp();
  master.close();
end query;
@end verbatim

At runtime this leads to buffers being filled with the statements
required for the slaves. They are stored in 
a file "dbfarm/db/master/tag_%d" with the following
structure:
@verbatim
function slave.tag0();
  slave.open(0,"2009-08-16 18:57:58.000":timestamp);
  tag0_b := bat.new(:oid,:int);
  ...
  bat.insert(tag0_b,3:oid,232:int); #example update
  ...
  sql.append("schema","table","col",tag0_b,tag);
  slave.close(0,"2009-08-16 18:57:58.000":timestamp);
  tag0_b:= nil;
end tag0;
slave.tag0();
slave.drop("tag0");
@end verbatim

Grouping the operations within temporary functions
makes it easy to skip its execution when we detect
that it has been executed before. The slave.open()
simply checks the replicas administration table
and issues an assertion if necessary.

Each query block is stored in its own buffer and sent at
the end of the query block. This separates the concurrent 
actions on the database at the master and leads to a serial
execution of the replication operations within the slave.

A slave processes all the logs it finds in the dbfarm/<db>/slave
directory. 

The operations are executed in the serial order as on the master,
which should lead to the same optimistic transactional behavior.
All queries are considered running in auto-commit mode, because
the SQL frontend does not provide the hook (yet) for better transaction
boundary control.

Updates on the replicated tables are forbidden  [to be checked]

@{
@mal
module master;

command open():int
address MASTERopen
comment "Create a replication record";

command close(tag:int):void
address MASTERclose
comment "Close the replication record";

pattern append(s:str, t:str, c:str, :any_1, tag:int):void
address MASTERappendValue
comment "Dump the scalar on the MAL log");

pattern append(s:str, t:str, c:str, b:bat[:oid,:any_1], tag:int):void
address MASTERappend
comment "Dump the BAT on the MAL log");

pattern delete(s:str, t:str, b:bat[:oid,:any_1], tag:int):void
address MASTERdelete
comment "Dump the BAT with deletions on the MAL log");

pattern replay(uri:str, usr:str, pw:str, tag:int):str
address MASTERreplay
comment "Start the replication log replayer thread feeding
the slave with the necessary log records. It simply pumps the
data until running out for log info.";

module slave;

command open(tag:int,d:timestamp)
address SLAVEopen
comment "Marks the start of a replication record. It checks the replicas
table for existence of the tag. If so, it aborts the attempt to reapply.";

command close(tag:int, d:timestamp)
address SLAVEclose
comment "End of replication record. Add the tag to the replicas table
using the SQL transaction semantics.";

command drop(tag:str)
address SLAVEdrop
comment "Remove the replica function from the module";
@-
@+ Implementation code 
@h
#ifndef _REPLICATOR_H
#define _REPLICATOR_H

#include "mal.h"
#include "mal_instruction.h"
#include "mal_interpreter.h"
#include "mal_namespace.h"
#include <mapilib/Mapi.h>
#include "remote.h"
#include "mtime.h"

#define _DEBUG_REPLICATOR_

#ifdef WIN32
#ifndef LIBREPLICATOR
#define replicator_export extern __declspec(dllimport)
#else
#define replicator_export extern __declspec(dllexport)
#endif
#else
#define replicator_export extern
#endif

replicator_export str MASTERopen(int *ret);
replicator_export str MASTERclose(int *ret, int *tag);
replicator_export str MASTERappendValue(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
replicator_export str MASTERappend(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
replicator_export str MASTERdelete(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
replicator_export str MASTERreplay(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);

replicator_export str SLAVEopen(int *ret, int *tag, timestamp *t);
replicator_export str SLAVEclose(int *ret, int *tag, timestamp *t);
replicator_export str SLAVEdrop(int *ret, str *tag);
#endif /* _REPLICATOR_H */
@c
#include "mal_config.h"
#include "replicator.h"
#include "mal_client.h"

@-
The start of the query is marked with a replica tag.
It also designates the local buffer to collect the update
requests before they are shipped to the log.
The tag is returned for marking all related updates.
The final code should contain a loop to determine the last replicator tag.
@c
#define MASTER "master"
#define SLAVE "slave"
#define REPLICA "/log_%d"
#define REPLICABLOCK 1000

static MT_Lock repLck;
static int repTag;
static stream *repFile;

static struct MASTERRECORD{
	char *buf;
	int limit, top;
	int tag;
} *master;
static int mtop = 0 , mlimit = 0;

static int MASTERgetBuffer(int tag){
	int i;

	for ( i = 0; i < mtop ; i++)
	if ( master[i].tag == tag)
		return i;
	for ( i = 0; i < mlimit ; i++)
	if ( master[i].tag == 0)
		break;
	if ( i == 0){
		master = GDKzalloc(sizeof(struct MASTERRECORD) * (mlimit +32));
		mlimit = 32;
	} else
	if ( i == mlimit){
		master = GDKrealloc(master, sizeof(struct MASTERRECORD) * (mlimit +32));
		mlimit += 32;
	}
	mtop = i >= mtop ? i+1: mtop;
	if ( master[i].buf == 0){
		master[i].buf = (char*) GDKzalloc(2*1024);
		master[i].limit = 2*1024;
		master[i].top = 0;
	}
	master[i].tag = tag;
	return i;
}

str MASTERopen(int *ret){
	char buf[BUFSIZ];
	FILE *fp = 0;
	timestamp stamp;
	str val=0;
	int i,l,len;
	
	if ( repTag == 0)
		MT_lock_init(&repLck,"replicator");
	mal_set_lock(repLck,"replicator");
	if ( repFile == NULL){
		mkdir(MASTER,0755); /* ensure existance of the replica pool */
		if ( repTag == 0){
			/* find the last one already in the pool, using the REPLICABLOCK */
			do {
				if (fp) {
					repTag += REPLICABLOCK;
					fclose(fp);
				}
				snprintf(buf, BUFSIZ, MASTER REPLICA, repTag);
				fp = fopen(buf,"r");
			} while (fp);
		}
		snprintf(buf, BUFSIZ, MASTER REPLICA, repTag);
		repFile = open_wastream(buf);
		if ( repFile == NULL || stream_errnr(repFile) ){
			mal_unset_lock(repLck,RUNTIME_STREAM_FAILED);
			throw(MAL,"master.start",RUNTIME_STREAM_FAILED);
		}
	}
	/* get a replica buffer */
	repTag++;
	i = MASTERgetBuffer(repTag);
	/* prepare the MAL redo record */
	MTIMEepoch(&stamp);
	ATOMformat(TYPE_timestamp, (ptr) &stamp, &val);
	len = master[i].limit - master[i].top -1;
	while ( (l = snprintf(master[i].buf + master[i].top, len ,
			"function slave.tag_%d();\nslave.open(%d,\"%s\":timestamp);\n",repTag,repTag,val)) == len){
		master[i].buf = (char*) GDKrealloc(master[i].buf, master[i].limit + 1024);
		if ( master[i].buf == NULL)
			throw(MAL,"replicator.open",MAL_MALLOC_FAIL);
		master[i].limit += 1024;
		len = master[i].limit - master[i].top -1;
	}
	master[i].top += l;
	master[i].buf[master[i].top] = 0;
	mal_unset_lock(repLck,RUNTIME_STREAM_FAILED);

	*ret = repTag ;
	return MAL_SUCCEED;
}

str MASTERclose(int *ret, int *tag){
	timestamp stamp;
	str val=0;
	int i,l,len;
	char buf[BUFSIZ];

	(void) ret;
	i = MASTERgetBuffer(*tag);
	mal_set_lock(repLck,"replicator");
	MTIMEepoch(&stamp);
	ATOMformat(TYPE_timestamp, (ptr) &stamp, &val);
	snprintf(buf,BUFSIZ,"tag_%d",*tag);
	len = master[i].limit - master[i].top -1;
	while ( (l = snprintf(master[i].buf + master[i].top, len, 
		"slave.close(%d,\"%s\":timestamp);\nend tag_%d;\nslave.tag_%d();\nslave.drop(\"%s\");\n",
		*tag,val,*tag,*tag,buf)) == len){
		master[i].buf = (char*) GDKrealloc(master[i].buf, master[i].limit + 1024);
		if ( master[i].buf == NULL)
			throw(MAL,"replicator.close",MAL_MALLOC_FAIL);
	}
	master[i].top += l;
	master[i].buf[master[i].top] = 0;
	GDKfree(val);
	stream_printf(repFile,"%s", master[i].buf);
	stream_flush(repFile);
	master[i].buf[0]=0;
	master[i].top = 0;
	master[i].top = 0;
	if ( stream_errnr(repFile) ){
		mal_unset_lock(repLck,"replicator");
		throw(MAL,"replicator.close",RUNTIME_STREAM_FAILED);
	}
	if ( repTag % REPLICABLOCK  == 0){
		close_stream(repFile);
		repFile = NULL;
	}
	mal_unset_lock(repLck,"replicator");
	return MAL_SUCCEED;
}

static str
MASTERdump( BAT *b, str buf, int type, int tag){
	BATiter bi;
	BUN p,q;
	char *headv = 0, *tailv= 0;
	str head = getTypeName(getHeadType(type));
	str tail = getTypeName(getTailType(type));
	int i, l, len;
	
	i = MASTERgetBuffer(tag);
	bi = bat_iterator(b);
	BATloop(b,p,q){
		ATOMformat(getHeadType(type), BUNhead(bi, p), &headv);
		ATOMformat(getTailType(type), BUNtail(bi, p), &tailv);
		len = master[i].limit - master[i].top -1;
		if ( getTailType(type) <=TYPE_str &&
			getHeadType(type) <= TYPE_str) {
			while ( (l = snprintf(master[i].buf + master[i].top, len ,"bat.insert(%s, %s:%s, %s:%s);\n",
						buf, headv, head, tailv, tail)) >= len){
				master[i].buf = (char*) GDKrealloc(master[i].buf, master[i].limit + 1024);
				if ( master[i].buf == NULL)
					throw(MAL,"replicator.dump",MAL_MALLOC_FAIL);
				master[i].limit += 1024;
				len = master[i].limit - master[i].top -1;
			}
		} else
		if ( getTailType(type) >TYPE_str  &&
			getHeadType(type) > TYPE_str) {
			while ( (l = snprintf(master[i].buf + master[i].top, len , "bat.insert(%s, \"%s\":%s, \"%s\":%s);\n",
						buf, headv, head, tailv, tail)) >= len){
				master[i].buf = (char*) GDKrealloc(master[i].buf, master[i].limit + 1024);
				if ( master[i].buf == NULL)
					throw(MAL,"replicator.dump",MAL_MALLOC_FAIL);
				master[i].limit += 1024;
				len = master[i].limit - master[i].top -1;
			}
		} else
		if ( getTailType(type) >TYPE_str ) {
			while ( (l = snprintf(master[i].buf + master[i].top, len , "bat.insert(%s, %s:%s, \"%s\":%s);\n",
						buf, headv, head, tailv, tail)) == len){
				master[i].buf = (char*) GDKrealloc(master[i].buf, master[i].limit + 1024);
				if ( master[i].buf == NULL)
					throw(MAL,"replicator.dump",MAL_MALLOC_FAIL);
				master[i].limit += 1024;
				len = master[i].limit - master[i].top -1;
			}
		} else{
			while ( (l = snprintf(master[i].buf + master[i].top, len , "bat.insert(%s, \"%s\":%s, %s:%s);\n",
						buf, headv, head, tailv, tail)) == len){
				master[i].buf = (char*) GDKrealloc(master[i].buf, master[i].limit + 1024);
				if ( master[i].buf == NULL)
					throw(MAL,"replicator.dump",MAL_MALLOC_FAIL);
				master[i].limit += 1024;
				len = master[i].limit - master[i].top -1;
			}
		}
		master[i].top += l;
		master[i].buf[master[i].top] = 0;
	}
	GDKfree(tail);
	GDKfree(head);
	return MAL_SUCCEED;
}

str
MASTERappendValue(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	int tag = *(int*) getArgReference(stk,pci,5);
	InstrPtr q;
	str val= NULL;
	int i,l,len;

#ifdef _DEBUG_REPLICATOR_
	(void) cntxt;
#endif
	if ( repFile == NULL)
		throw(MAL,"replicator.append", RUNTIME_FILE_NOT_FOUND);

	i = MASTERgetBuffer(tag);
	q= copyInstruction(pci);
	q->argc--;
	setModuleId(q,putName("sql",3));
	
	val = instruction2str(mb,stk,q,LIST_MAL_CALL);
	freeInstruction(q);

	len = master[i].limit - master[i].top -1;
	while ( (l = snprintf(master[i].buf + master[i].top, len , "%s\n", val) >= len ) ){
		master[i].buf = (char*) GDKrealloc(master[i].buf, master[i].limit + 1024);
		if ( master[i].buf == NULL)
			throw(MAL,"replicator.append",MAL_MALLOC_FAIL);
		master[i].limit += 1024;
		len = master[i].limit - master[i].top -1;
	}
	master[i].top += strlen(val);
	master[i].buf[master[i].top] = 0;
	GDKfree(val);
	return MAL_SUCCEED;
}

str
MASTERappend(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	str *schema = (str*) getArgReference(stk,pci,1);
	str *table = (str*) getArgReference(stk,pci,2);
	str *col = (str*) getArgReference(stk,pci,3);
	int *bid = (int*) getArgReference(stk,pci,4);
	int tag = *(int*) getArgReference(stk,pci,5);
	BAT *b;
	char buf[BUFSIZ];
	int type = getArgType(mb, pci, 4);
	str head = getTypeName(getHeadType(type));
	str tail = getTypeName(getTailType(type));
	int i, l, len;
	str msg;

#ifdef _DEBUG_REPLICATOR_
	(void) cntxt;
#endif
	if ( repFile == NULL)
		throw(MAL,"replicator.append", RUNTIME_FILE_NOT_FOUND);
	b = BATdescriptor(*bid);
	if ( b == NULL)
		throw(MAL,"replicator.append", RUNTIME_OBJECT_MISSING);

	i = MASTERgetBuffer(tag);
	/* create the temporary bat */
	len = master[i].limit - master[i].top -1;
	while ( (l = snprintf(master[i].buf + master[i].top, len , "tag_%d_%s:=bat.new(:%s,:%s);\n",
				tag, getArgName(mb,pci,4), head, tail)) >= len ){
		master[i].buf = (char*) GDKrealloc(master[i].buf, master[i].limit + 1024);
		if ( master[i].buf == NULL)
			throw(MAL,"replicator.append",MAL_MALLOC_FAIL);
		master[i].limit += 1024;
		len = master[i].limit - master[i].top -1;
	}
	master[i].top += l;
	master[i].buf[master[i].top] = 0;

	/* fill it */
	snprintf(buf,BUFSIZ,"tag_%d_%s", tag, getArgName(mb,pci,4));
	msg = MASTERdump(b,buf,type, tag);
	if (msg != MAL_SUCCEED)
		return msg;

	/* execute the original append */
	len = master[i].limit - master[i].top -1;
	while ( (l = snprintf(master[i].buf + master[i].top, len , "sql.append(\"%s\",\"%s\",\"%s\",%s);\ntag_%d_%s := nil;\n",
		*schema, *table, *col, buf,tag, getArgName(mb,pci,4)) ) >= len){
		master[i].buf = (char*) GDKrealloc(master[i].buf, master[i].limit + 1024);
		if ( master[i].buf == NULL)
			throw(MAL,"replicator.append",MAL_MALLOC_FAIL);
		master[i].limit += 1024;
		len = master[i].limit - master[i].top -1;
	}
	master[i].top += l;
	master[i].buf[master[i].top] = 0;
	GDKfree(head);
	GDKfree(tail);
	return MAL_SUCCEED;
}

str
MASTERdelete(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	str *schema = (str*) getArgReference(stk,pci,1);
	str *table = (str*) getArgReference(stk,pci,2);
	int *bid = (int*) getArgReference(stk,pci,3);
	int tag = *(int*) getArgReference(stk,pci,4);
	BAT *b;
	char buf[BUFSIZ];
	int type = getArgType(mb, pci, 3);
	str head = getTypeName(getHeadType(type));
	str tail = getTypeName(getTailType(type));
	str msg;
	int i, l, len;

#ifdef _DEBUG_REPLICATOR_
	(void) cntxt;
#endif
	if ( repFile == NULL)
		throw(MAL,"replicator.delete", RUNTIME_FILE_NOT_FOUND);
	b = BATdescriptor(*bid);
	if ( b == NULL)
		throw(MAL,"replicator.delete", RUNTIME_OBJECT_MISSING);

	i = MASTERgetBuffer(tag);
	/* create the temporary bat */
	len = master[i].limit - master[i].top -1;
	while ( (l = snprintf(master[i].buf + master[i].top, len , "tag_%d_%s:=bat.new(:%s,:%s);\n",
				tag, getArgName(mb,pci,3), head, tail)) == len ){
		master[i].buf = (char*) GDKrealloc(master[i].buf, master[i].limit + 1024);
		if ( master[i].buf == NULL)
			throw(MAL,"replicator.delete",MAL_MALLOC_FAIL);
		master[i].limit += 1024;
		len = master[i].limit - master[i].top -1;
	}
	master[i].top += l;
	master[i].buf[master[i].top] = 0;

	/* fill it */
	snprintf(buf,BUFSIZ,"tag_%d_%s", tag, getArgName(mb,pci,3));
	msg = MASTERdump(b,buf,type, tag);
	if (msg != MAL_SUCCEED)
		return msg;

	/* execute the original append */
	len = master[i].limit - master[i].top -1;
	while ( (l = snprintf(master[i].buf + master[i].top, len , "sql.delete(\"%s\",\"%s\",%s);\ntag_%d_%s := nil;\n",
			*schema, *table, buf, tag, getArgName(mb,pci,4))) == len){
		master[i].buf = (char*) GDKrealloc(master[i].buf, master[i].limit + 1024);
		if ( master[i].buf == NULL)
			throw(MAL,"replicator.delete",MAL_MALLOC_FAIL);
		master[i].limit += 1024;
		len = master[i].limit - master[i].top -1;
	}
	master[i].top += l;
	master[i].buf[master[i].top] = 0;
	GDKfree(head);
	GDKfree(tail);
	return MAL_SUCCEED;
}

@-
Replaying the MAL logs is straightforward. We perform a remote
operation execution on the master to initiate a quick dump of the
missing operations.
@c
str MASTERreplay(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	str *uri= (str*)getArgReference(stk,pci,1);
	str *usr= (str*)getArgReference(stk,pci,2);
	str *pw= (str*)getArgReference(stk,pci,3);
	int *tag= (int*)getArgReference(stk,pci,4), t= *tag;
	str scen="mal";
	char buf[BUFSIZ+1];
	bstream *in;
	stream *s;
	MapiHdl hdl;
	Mapi m;

	(void) cntxt;
	(void) mb;

#define _DEBUG_REPLICATOR_
#ifdef _DEBUG_REPLICATOR_
	printf("replay the log to  %s %s %s %d\n", *uri, *usr, *pw, *tag);
#endif
	m = mapi_mapiuri(*uri, *usr, *pw, scen);
	if (mapi_error(m))
		throw(MAL, "replicator.masterreplay", "unable to connect: %s",
				mapi_error_str(m));

	if (mapi_reconnect(m) != MOK) {
		throw(IO, "replicator.masterreplay", OPERATION_FAILED 
				": an error occurred during connect to '%s': %s",
				*uri, mapi_error_str(m));
	}

	buf[BUFSIZ] = 0;
	do {
		snprintf(buf, BUFSIZ, MASTER REPLICA, (t / REPLICABLOCK) *REPLICABLOCK);
		/* copy it */
		in = bstream_create(  (s= open_rstream(buf)), BUFSIZ);
		if (s == NULL || in == NULL)
			break;
		do {
			if (bstream_read(in, BUFSIZ) <= 0 )
				break;
#ifdef _DEBUG_REPLICATOR_
			printf("sent:%s\n", in->buf);
#endif
			/* sent the data to the server */
			/* FIXME: just write, don't look at the response */
			hdl = mapi_query(m, in->buf);
			if (hdl)
				mapi_close_handle(hdl);
		} while (in->eof == 0);

		t += REPLICABLOCK;
	} while (t < *tag); /* fake exit */

	mapi_disconnect(m);
	mapi_destroy(m);
	return MAL_SUCCEED;
}

@-
We should assure that only operations we haven't seen are
being executed. This is based on the tag assigned to each
replicator block. The main issue to deal with is that
blocks may arrive out of order, i.e. reflecting the
concurrent behavior at the master.
This calls for a persistent table with all tags.
@c
str SLAVEopen(int *ret, int *tag, timestamp *t){
	(void) ret;
	(void) t;
	if ( *tag < repTag)
		throw(MAL,"slave.open","Operation ignored");
	return MAL_SUCCEED;
}

str SLAVEclose(int *ret, int *tag, timestamp *t){
	(void) ret;
	(void) t;
	repTag = *tag;
	return MAL_SUCCEED;
}

str
SLAVEdelete(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	str *schema = (str*) getArgReference(stk,pci,1);
	str *table = (str*) getArgReference(stk,pci,2);
	int *bid = (int*) getArgReference(stk,pci,3);
	int tag = *(int*) getArgReference(stk,pci,4);

	(void) cntxt;
	(void) mb;
	(void) schema;
	(void) table;
	(void) bid;
	(void) tag;
	return MAL_SUCCEED;
}

str
SLAVEdrop(int *ret, str *tag)
{
	Symbol prg;
	Module mod;
	prg = findSymbol(NULL, getName("slave",5), *tag);
	mod = findModule(NULL, getName("slave",5));
	if ( prg == NULL || mod == NULL)
		throw(MAL,"slave.drop","Symbol not found");
	deleteSymbol(mod,prg);
	(void) ret;
	return MAL_SUCCEED;
}

@}
