@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
@' Copyright August 2008- MonetDB B.V.
@' All Rights Reserved.

@f replicator
@a Martin Kersten
@v 1.0
@+ Database replication
The replicator module supports distribution of the SQL database
over multiple sites using a master slave protocol.

The replicator assumes that both database have the same catalog information.
There is no automatic propagation of CREATE, DROP, nor ALTER statements. 
Moreover, the master database should be accessible through Merovingian.

The lean and mean replication scheme implementation works as follows.
The plan is extended by the optimizer to retrieve
the latest database version identifier using a back call to the master
issueing a sql.getVersion(), which should mark the current transaction
time. (is is db wide or per table/group?)

If the version is newer then what we know (stored as an argumen
This overloaded bind synchronises the local copy using a
straightforward algorithm. It contacts the master to obtain
the last known version id for the BAT. If it is out of sink,
the complete BAT is transmitted. 

Consider the plan derived from "select count(*) from tables;"
and that this one should be executed on a remote host.
@verbatim
function octopussy.tentacle_1();
	replicator.setMaster("master");	# marker
	oldversion: =replicator.setVersion(20090106);	# version at compile time 
	remote.create("master", "localhost",50000,"master","monetdb","monetdb"
	id:rmtobj:= remote.exec("mastername","sql","getVersion");
	version:lng := remote.get("master",id);
	replicator.synchronise("master",oldversion,newversion);

	_1:bat[:oid,:sht]  := sql.bind("tmp","_tables","type",0);
    _6:bat[:oid,:oid]  := sql.bind_dbat("tmp","_tables",1);
@end verbatim
synchronise should walk through the plan and localise all bind operations.
For each we simply perform an upcall to get the complete BAT  (first attempt)
In the end we overwrite the oldversion in the symbol table (!)

The next level of improvement is to keep the accumulated delta
lists at sql. Then we could perform an upcall to fetch those
and merge them with the local ones. For this, the master need
to know the version range covered.

A negative version id can be used to indicate a complete
resync, a positive (range) the deltas needed.


@mal
module replicator;

command setMaster(master:str):void
address REPsetMaster
comment "Mark the source of this database";

command setVersion(version:lng):lng
address REPsetVersion
comment "Keep the latest version in the symbol table as a constant";

pattern synchronise(master:str, version:lng):lng
address REPsynchronise
comment "Synchronize the local tables with the master";
@-
@{
@+ Implementation code 
@h
#ifndef _REPLICATOR_H
#define _REPLICATOR_H

#include "mal.h"
#include "mal_instruction.h"
#include "mal_interpreter.h"
#include "mal_namespace.h"

#define _DEBUG_REPLICATOR_

#ifdef WIN32
#ifndef LIBREPLICATOR
#define replicator_export extern __declspec(dllimport)
#else
#define replicator_export extern __declspec(dllexport)
#endif
#else
#define replicator_export extern
#endif

replicator_export str REPsetMaster(int *ret, str *nme);
replicator_export str REPsetVersion(int *ret, lng *version);
replicator_export str REPsynchronise(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
#endif /* _REPLICATOR_H */
@c
#include "mal_config.h"
#include "replicator.h"
#include <mapilib/Mapi.h>
#include "remote.h"

str
REPsynchronise(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	str *master = (str*) getArgReference(stk,pci,1);
	lng *version = (lng*) getArgReference(stk,pci,2);
	connection c;
	str msg = MAL_SUCCEED;
	str sqlRef = getName("sql",3);
	str bindRef = getName("bind",4);
	InstrPtr p;
	int i;

#ifdef _DEBUG_REPLICATOR_
	stream_printf(cntxt->fdout,"#sync master %s version %d\n",*master, *version);
#else
	(void) cntxt;
#endif
	(void) mb;

	/* lookup conn */
    rethrow("replicator.bind", msg, RMTfindconn(&c, *master));

	/* localise all bind calls */
	for (i =0; i<mb->stop; i++){
		p= getInstrPtr(mb,i);
		if ( getModuleId(p) == sqlRef &&
			 getFunctionId(p) == bindRef){
			/* synchronise this BAT */
		}
	}
	return msg;
}
str REPsetMaster(int *ret, str *nme){
	(void) ret;
	(void) nme;
	throw(MAL,"replicator.setMaster","nyi");
}
str REPsetVersion(int *ret, lng *version){
	(void) ret;
	(void) version;
	throw(MAL,"replicator.setVersion","nyi");
}
@}
