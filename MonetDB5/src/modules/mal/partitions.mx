@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2006 CWI.
@' All Rights Reserved.

@f partitions
@v 0.0
@a M.L.Kersten
@* BAT Partition Manager
In real-life database applications the BATs tend to grow beyond
the memory size. This leads to a heavy IO dominated behavior,
which can partly be avoided by breaking up the query into a sequence
of subqueries using a map-reduce strategy.
The BAT partition manager (BPT) module is designed to 
support this strategy using range- and hash-partitioning.

Consider we want to reorganize R:bat[:void,:int] into three range partitions,
based on splitting on the head. Two partitions are stable
and the third partition is reserved for appends.
The following MAL program illustrates the snippet of actions needed:
@example
	bpm.open();
	Ralias:= bpm.deposit("myversion",R);
	R1:= bpm.rangePartition(Ralias,nil:oid,100:oid,nil:int,nil:int);
	R2:= bpm.rangePartition(Ralias,101:oid,200:oid,nil:int,nil:int);
	R3:= bpm.rangePartition(Ralias,201:oid,nil:oid,nil:int,nil:int);
	bpm.close();
@end example
The command @code{pbm.deposit} accepts any BAT and
registers it as one with a partitioned copy.
The default constraint is to allow only pair-wise disjoint
partitions. It flags attempts to overlap partitions as errors. 
The remainder are the  partition definitions based
of slices from the table using a simple range condition.
The partitions share the persistency properties.

Beware that now there are four components R, R1, R2, and R3.
Once the partition has been succesful and the box is closed
it is possible to remove the content from R. The BAT R should
not be destroyed, because its identity is the handle to access
the partitions later on. The call @code{bpm.disgard(R)} removes all
the partitions.

The partition manager supports hash-based partitioning.
It accepts two arguments, which denote the number of hash buckets
on the head and tail respectively.
@example
	bpm.open();
	Ralias:= bpm.deposit("myHashVersion",R);
	bpm.hashPartition(Ralias,5,2);
	bpm.close();
@end example
This example leads to 10 partitions.
Repartition automatically occurs when a new hash size is given.

It should not come as a surprise, that a combination of
hashing and range is also provided using the
commands @code{bpm.hashRangePartition()} and @code{bpm.rangeHashPartition()}.

@- Using partitions
The partitioned BAT can be used in two ways. A query plan can be
rewritten into a generator over the partitions, or it can be
used by optimizers to derived all subqueries first.

The former is illustrated with the snippet to select part of
a partitioned BAT.
@example
	bpm.open();
	R:bat[:void,:int]:= bpm.take("myversion");
	tu:= bat.new(:void,:int);
barrier (idx,Rp):= partitions.newIterator(R);
	...
	t:= algebra.select(Rp,0,100);
	tu:= algebra.union(tu,t);
	...
	redo (idx,Rp):= partitions.hasMoreElements(R);
exit (idx,b);
	bpm.close();
@end example

The partitioned BATs are particularly useful during query
optimization. However, it only works if the BAT identifier
can be determined. For SQL it can be simply looked up in
the catalog as part of the preparatory optimizer step.
The same problem handled by an optimizer produces the plan:
@example
	bpm.open();
	Ralias:bat[:void,:int]:= bpm.take("myversion"); # get the partition alias
	R0:= bpm.take(Ralias,0); # get a specific partition
	tu:= algebra.select(R0,0,100);
	R1:= bpm.take("myversion",1);
	t1:= algebra.select(R0,0,100);
	tu:= algebra.union(tu,t1);
	R2:= bpm.take("myversion",2);
	t2:= algebra.select(R0,0,100);
	tu:= algebra.union(tu,t2);
@end example

A more interesting version is to make
the range information again visible in
the intermediate plan. This can be used by optimizers
for symbolic evaluation.
@example
	bpm.open();
	Ralias:bat[:void,:int]:= bpm.take("myversion"); # get the partition alias
	R0:= bpm.take(Ralias, 0@0, 100@0, nil:int,nil:int); 
	tu:= algebra.select(R0,0,100);
	R1:= bpm.take(Ralias, 101@0, 200@0, nil:int,nil:int); 
	t1:= algebra.select(R1,0,100);
	tu:= algebra.union(tu,t1);
	R2:= bpm.take(Ralias, 201@0, nil:oid, nil:int,nil:int); 
	t2:= algebra.select(R2,0,100);
	tu:= algebra.union(tu,t2);
@end example

The select operation could be overloaded in the BPT to
improve processing further.

- Partition management
The content of the partitions is preferrable updated in bulk.
This calls for accumulation of insertions/deletions in pending
update BATs, as already performed in the SQL code generator.
Once the transaction is commited, the updates are propagated
(in parallel) to all partitions.
@example
	bpm.open();
	R:bat[:void,:int] := bpm.take("myversion"); # get the partition alias
	bpm.insert(R, Rinsert);	# handle pending inserts
	bpm.delete(R, Rdelete);	# handle pending deletes
	bpm.close();
@end example

The lifetime of a partitioned table is inherited from its components. 
How to detect that a temporary BAT is removed from the BBP?

BEWARE, it is not protected against concurrent access yet.
@mal
module partitions;

command open():void
address BPTopen
comment "Locate and open the partition box";
command close():void
address BPTclose
comment "Save and close the partition box ";
command destroy():void
address BPTdestroy
comment "Destroy the partition box";

command take(idx:int):bat[:void,:any_1]
address BPTtake
comment "Take a partition from the box";

command deposit(b:bat[:void,:any_1]) :void
address BPTdeposit
comment "Enter a new BAT into the partition box";
command deposit(b:bat[:void,:any_1],p:bat[:void,:any_1]) :void
address BPTdeposit2
comment "Enter a new partition to a group into the partition box";
command deposit(b:str,p:str,cap:int) :void
address BPTdepositPartition
comment "Enter a new BAT into the partition box";

pattern releaseAll():void
address BPTreleaseAll
comment "Release all partitions in the box";
pattern release(b:bat[:void,:any_1]) :void
address BPTrelease
comment "Release a single BAT with its partitions from the  box";

pattern toString(idx:int):str
address BPTtoString
comment "Get the string representation of an element in the box";

command discard(name:bat[:void,:any_1]) :void
address BPTdiscard
comment "Release a BAT variable from the box";

command newIterator()(:int)
address BPTnewIteratorBase
comment "Create an iterator over the partition box";
command hasMoreElements()(:int)
address BPThasMoreElementsBase
comment "Locate next element in the partition box";

command newIterator(b:bat[:void,:any_1]) (:int,:bat[:void,:any_1])
address BPTnewIterator
comment "Create an iterator over the BAT partitions.";

command newIterator(b:bat[:void,:any_1],first:oid,last:oid)
		(:int,:bat[:void,:any_1])
address BPTnewIteratorRng
comment "Create an iterator over the BAT partitions.";

command hasMoreElements(b:bat[:void,:any_1]) (:int, :bat[:void,:any_1])
address BPThasMoreElements
comment "Localize the next partition for processing.";

command hasMoreElements(b:bat[:void,:any_1],first:oid,last:oid) (:int, :bat[:void,:any_1])
address BPThasMoreElementsRng
comment "Localize the next partition for processing.";

command getLastPartition(b:bat[:void,:any_1]):bat[:void,:any_1]
address BPTgetLastPartition
comment "Obtain the last partition for update";

command getRange(b:bat[:void,:any_1])(first:oid,last:oid)
address BPTgetRange
comment "Obtain the oid range for a partition";

@-
The insert/delete/replace operations on the BATs are overloaded for
the partitioned version. Insertions are added to the last partition.
Deletion takes place in all versions and will actually shrink
the oid range. 
Rebalancing the partitions content is considered a separate action.

The partition capacity can be set to limit the number
of insertions. As soon as the capacity is exhausted,
a new bat is allocated.

@mal
command setCapacity(b:bat[:void,:any_1], s:int):void
address BPTsetCapacity
comment "Limit the content of all remaining BATs";

command insert(b:bat[:void,:any_1],h:void,t:any_1):bat[:void,:any_1]
address BPTinsert
comment "Add a tuple to the last partition";
command insert(b:bat[:void,:any_1],t:any_1):bat[:void,:any_1]
address BPTinsert_void_bun
comment "Add a tuple to the last partition";

command insert(b:bat[:void,:any_1],p:bat[:void,:any_1]):bat[:void,:any_1]
address BPTinsertBAT
comment "Add a BAT as a partition to the end of the list.";

command delete(b:bat[:void,:any_1],h:oid):bat[:void,:any_1]
address BPTdelete_oid
comment "Delete a tuple from the BAT group";

command delete(b:bat[:void,:any_1],p:bat[:void,:any_1]):bat[:void,:any_1]
address BPTdeleteBAT
comment "Delete a BAT from the partition";

command compress(b:bat[:void,:any_1]):bat[:void,:any_1]
address BPTcompress
comment "Compress the group to remove oid holes";

command dump()
address BPTdump;

command prelude()
address BPTprelude;

command epilogue()
address BPTepilogue;

partitions.prelude();
@-
@{

@+ BAT Partition Iterator Implementation
The implementation is organized around a shared box, which should
be saved between session. It is up to other layers to ensure that BATs
being deleted are also removed from the partition box to avoid
mis-represented information.

The datastructures for the partition table are dynamic arrays
indexed by an integer, which is also returned to the environment
as a handle.
@h
#ifndef _MAL_BPT
#define _MAL_BPT
#include "mal.h"
#include "mal_client.h"
#include "mal_interpreter.h"


#endif
@c
#include "mal_config.h"
#include "partitions.h"
#include "bat5.h"

#ifdef WIN32
#ifndef LIBPARTITIONS
#define partitions_export extern __declspec(dllimport)
#else
#define partitions_export extern __declspec(dllexport)
#endif
#else
#define partitions_export extern
#endif

partitions_export int BPTfindGrp(int bid);
partitions_export void BPTresize(int size);
partitions_export str BPTdump(void);
partitions_export str BPTprelude(int *ret);
partitions_export str BPTepilogue(int *ret);
partitions_export str BPTopen(void);
partitions_export str BPTclose(void);
partitions_export str BPTdestroy(void);
partitions_export str BPTtake(int *ret, int *idx);
partitions_export int BPTfindGrp(int bid);
partitions_export int BPTfindPartition(int bid, int pid);
partitions_export str BPTdeposit(int *ret, int *bid);
partitions_export str BPTdeposit2(int *ret, int *bid, int *pid);
partitions_export str BPTdepositPartition(int *ret, str *bnme, str *pnme, int *cap);
partitions_export str BPTgetRange(oid *first, oid *last, int *bid);
partitions_export str BPTgetLastPartition(int *ret, int *bid);
partitions_export str BPTdiscard(int *ret, int *bid);
partitions_export str BPTdiscardAll(int *ret);
partitions_export str BPTtoString(int *ret, int *bid);
partitions_export str BPTreleaseAll(int *ret, int *bid);
partitions_export str BPTrelease(int *ret, int *bid);
partitions_export str BPTnewIteratorBase(int *ret);
partitions_export str BPThasMoreElementsBase(int *ret);
partitions_export str BPTnewIterator(int *res, int *pid, int *bid);
partitions_export str BPTnewIteratorRng(int *res, int *pid, int *bid, oid *first, oid *
last);
partitions_export str BPThasMoreElements(int *res, int *pid, int *bid);
partitions_export str BPThasMoreElementsRng(int *res, int *pid, int *bid, oid *first, oid *last);
partitions_export str BPTsetCapacity(int *ret, int *bid, int *val);
partitions_export str BPTinsert_void_bun(int *ret, int *bid, ptr val);
partitions_export str BPTinsert(int *ret, int *bid, ptr h, ptr t);
partitions_export str BPTinsertBAT(int *ret, int *bid, int *bnid);
partitions_export str BPTdelete_oid(int *ret, int *bid, oid *h);
partitions_export str BPTcompress(int *ret, int *bid);
partitions_export str BPTdeleteBAT(int *ret, int *bid, int *bnid);

typedef struct {
	bat bid;		/* group bat identifier */
	int pid;		/* group element identifier */
	oid first;		/* lowest oid stored */
	oid last;		/* largest oid stored or nil */
	int next;		/* next one in the list */
	int prev;		/* previous one in the list */
	int cap;		/* maximum capacity */
} Partition;

static Partition *partitions = NULL;
static int ptop, plimit;

#define INCREMENT 1024
void
BPTresize(int size)
{
	Partition *p;

	if( size <= plimit) return;
	p = GDKmalloc(size * sizeof(Partition));
	if (partitions) {
		if (ptop > size)
			GDKfatal("assertion error in BPTresize");
		memcpy(p, partitions, sizeof(Partition) * ptop);
		GDKfree(partitions);
	}
	partitions = p;
	partitions[0].bid = -1;
	partitions[0].pid = -1;
	partitions[0].prev = -1;
	partitions[0].next = -1;
	plimit = size;
}

static void
BPTfree()
{
	if (partitions) {
		GDKfree(partitions);
		partitions = NULL;	
	}
}

str
BPTdump()
{
	stream *fd = GDKout;
	int i;

	stream_printf(fd, "ptop=%d plimit=%d\n", ptop, plimit);
	for (i = 0; i < ptop; i++)
		stream_printf(fd, "[%d] bid=%d pid=%d f=%d, l=%d prv=%d nxt=%d cap=%d\n", i, partitions[i].bid, partitions[i].pid, partitions[i].first, partitions[i].last, partitions[i].prev, partitions[i].next, partitions[i].cap);
	return MAL_SUCCEED;
}

@- Box administration
The box currently does not carry any client protection.
This should later be added or being provided by the BAT
access.
@c
str
BPTprelude(int *ret)
{
/*
	Box box;

	box = openBox("partitions");
	if (box == 0)
		throw(MAL, "partitions.prelude", "Failed to open box");
*/
	(void) ret;

	BPTresize(INCREMENT);
	return MAL_SUCCEED;
}

str
BPTepilogue(int *ret)
{
	*ret = closeBox("partitions", 0);
	BPTfree();
	if (*ret != 0)
		throw(MAL, "partitions.prelude", "Failed to open box");
	return MAL_SUCCEED;
}


str
BPTopen()
{
	if (openBox("partitions") != 0)
		return MAL_SUCCEED;
	throw(MAL, "partitions.open", "Failed to open partitions box");
}

str
BPTclose()
{
	stream *f;
	str boxfile, boxfilebak;
	Box box;
	int i;

	box = openBox("partitions");
	f = prepareSaveBox(box, &boxfile, &boxfilebak);
	if (f != NULL) {
		/* save the info */
		for (i = 0; i < ptop; i++)
			if (partitions[i].bid != -1) {
				BAT *b = (BAT *) BBPgetdesc(partitions[i].pid);

				if (b && b->batPersistence & PERSISTENT)
					stream_printf(f, "%s.deposit(\"%s\",\"%s\",%d);\n", box->name, BBPname(partitions[i].bid), BBPname(partitions[i].pid), partitions[i].cap);
			}
		stream_close(f);
		(void) rename(boxfilebak, boxfile);
		GDKfree(boxfile);
		GDKfree(boxfilebak);
	}
	return MAL_SUCCEED;
}

str
BPTdestroy()
{
	destroyBox("partitions");
	return MAL_SUCCEED;
}

str
BPTtake(int *ret, int *idx)
{
	if (*idx < 0 || *idx >= ptop)
		throw(MAL, "partitions.take", "Index out of range");
	*ret = partitions[*idx].pid;
	BBPincref(*ret, TRUE);
	return MAL_SUCCEED;
}

@-
Administration of new partitions.
@c
int
BPTfindGrp(int bid)
{
	int i;

	for (i = 0; i < ptop; i++)
		if (partitions[i].bid == bid) {
			while (partitions[i].prev >= 0)
				i = partitions[i].prev;
			return i;
		}
	return -1;
}

int
BPTfindPartition(int bid, int pid)
{
	int i;

	for (i = 0; i < ptop; i++)
		if (partitions[i].bid == bid && partitions[i].pid == pid)
			return i;
	return -1;
}

str
BPTdeposit(int *ret, int *bid)
{
	int idx, i;
	BAT *b;

	b = BATdescriptor(*bid);
	if (b == NULL)
		throw(MAL, "partitions.deposit", "Can not access descriptor");
	idx = BPTfindGrp(*bid);
	if (idx != -1)
		throw(MAL, "partitions.deposit", "Duplicate group definition");
	if (ptop == plimit)
		BPTresize(plimit + INCREMENT);
	for (i = 0; i <= ptop; i++)
		if (partitions[i].bid == -1)
			break;
	partitions[i].bid = *bid;
	partitions[i].pid = *bid;
	partitions[i].first = b->hseqbase;
	partitions[i].last = b->hseqbase + BATcount(b);
	partitions[i].prev = -1;
	partitions[i].next = -1;
	partitions[i].cap = -1;
	if (i >= ptop) {
		ptop = i + 1;
		partitions[ptop].bid = -1;
		partitions[ptop].next = -1;
		partitions[ptop].prev = -1;
	}
	BBPunfix(*bid);
	(void) ret;
	return MAL_SUCCEED;
}

str
BPTdeposit2(int *ret, int *bid, int *pid)
{
	int idx, i;
	BAT *b;

	b = BATdescriptor(*pid);
	if (b == NULL)
		throw(MAL, "partitions.deposit", "Can not access descriptor");

	idx = BPTfindGrp(*bid);
	if (idx == -1) {
		BBPunfix(b->batCacheid);
		throw(MAL, "partitions.deposit", "BAT group unknown");
	}

	while (partitions[idx].next >= 0)
		idx = partitions[idx].next;
	if (b->hseqbase < partitions[idx].last && partitions[idx].last != oid_nil) {
		BBPunfix(b->batCacheid);
		throw(MAL, "partitions.deposit", "Partition already known");
	}

	if (ptop == plimit)
		BPTresize(plimit + INCREMENT);
	for (i = 0; i <= ptop; i++)
		if (partitions[i].bid == -1)
			break;
	partitions[i].bid = *bid;
	partitions[i].pid = *pid;
	partitions[i].first = b->hseqbase;
	partitions[i].last = b->hseqbase + BATcount(b);
	partitions[i].cap = -1;
	partitions[i].prev = idx;
	partitions[idx].next = i;
	if (i >= ptop) {
		ptop = i + 1;
		partitions[ptop].bid = -1;
		partitions[ptop].next = -1;
		partitions[ptop].prev = -1;
	}
	BBPunfix(*pid);
	(void) ret;
	return MAL_SUCCEED;
}

str
BPTdepositPartition(int *ret, str *bnme, str *pnme, int *cap)
{
	BAT *b, *bn;
	str msg;
	int idx;

	idx = BBPindex(*bnme);
	if (idx == 0)
		throw(MAL, "partitions.deposit", "Can not access descriptor");
	b = BATdescriptor(idx);
	if (b == NULL)
		throw(MAL, "partitions.deposit", "Can not access descriptor");

	idx = BBPindex(*pnme);
	if (idx == 0)
		throw(MAL, "partitions.deposit", "Can not access descriptor");
	bn = BATdescriptor(idx);
	if (bn == NULL) {
		BBPunfix(b->batCacheid);
		throw(MAL, "partitions.deposit", "Can not access descriptor");
	}
	msg = BPTdeposit2(ret, &b->batCacheid, &bn->batCacheid);
	if (msg) {
		BBPunfix(b->batCacheid);
		BBPunfix(bn->batCacheid);
		return msg;
	}
	idx = BPTfindPartition(b->batCacheid, bn->batCacheid);
	partitions[idx].first = bn->hseqbase;
	partitions[idx].last = bn->hseqbase + BATcount(bn) - 1;
	partitions[idx].cap = *cap;
	BBPunfix(b->batCacheid);
	BBPunfix(bn->batCacheid);
	return MAL_SUCCEED;
}

str
BPTgetRange(oid *first, oid *last, int *bid)
{
	int i;

	for (i = 0; i < ptop; i++)
		if (partitions[i].pid == *bid) {
			*first = partitions[i].first;
			*last = partitions[i].last;
			return MAL_SUCCEED;
		}
	throw(MAL, "partitions.getRange", "Partition not known");
}

str
BPTgetLastPartition(int *ret, int *bid)
{
	int i;

	for (i = 0; i < ptop; i++)
		if (partitions[i].bid == *bid && partitions[i].next == -1) {
			*ret = partitions[i].pid;
			return MAL_SUCCEED;
		}
	throw(MAL, "partitions.getLastPartition", "Partition not known");
}

str
BPTdiscard(int *ret, int *bid)
{
	int i;

	for (i = 0; i < ptop; i++)
		if (partitions[i].bid == *bid || partitions[i].pid == *bid) {
			partitions[i].bid = -1;
			partitions[i].pid = -1;
		}
	(void) ret;
	return MAL_SUCCEED;
}

str
BPTdiscardAll(int *ret)
{
	GDKfree(partitions);
	partitions = 0;
	BPTresize(INCREMENT);
	(void) ret;
	return MAL_SUCCEED;
}

str
BPTtoString(int *ret, int *bid)
{
	(void) ret;
	(void) bid;
	throw(MAL, "partitions.toString", "not yet implemented");
}

str
BPTreleaseAll(int *ret, int *bid)
{
	(void) ret;
	(void) bid;
	throw(MAL, "partitions.release", "not yet implemented");
}

str
BPTrelease(int *ret, int *bid)
{
	(void) ret;
	(void) bid;
	throw(MAL, "partitions.release", "not yet implemented");
}

@-
We start with the large chunk iterator.
The definition of the control statements require the same
control variables, which means that the BATview is accessible
to determine how far to advance when the next chunk is retrieved.
The number of elements in the chunk is limited by the granule
size.
@c
str
BPTnewIteratorBase(int *ret)
{
	*ret = 0;
	if (*ret == ptop)
		*ret = -1;
	return MAL_SUCCEED;
}

str
BPThasMoreElementsBase(int *ret)
{
	do {
		*ret = *ret + 1;
		if (*ret >= ptop) {
			*ret = -1;
			return MAL_SUCCEED;
		}
	} while (partitions[*ret].bid == -1);
	return MAL_SUCCEED;
}

str
BPTnewIterator(int *res, int *pid, int *bid)
{
	int i;

	for (i = 0; i < ptop; i++)
		if (partitions[i].bid == *bid) {
			*res = i;
			*pid = partitions[i].pid;
			BBPincref(*pid, TRUE);
			return MAL_SUCCEED;
		}
	throw(MAL, "partitions.newIterator", "Group not found");
}

str
BPTnewIteratorRng(int *res, int *pid, int *bid, oid *first, oid *last)
{
	int i;

	for (i = 0; i < ptop; i++)
		if (partitions[i].bid == *bid && !(partitions[i].last < *first || partitions[i].first > *last)) {
			*res = i;
			*pid = partitions[i].pid;
			BBPincref(*pid, TRUE);
			return MAL_SUCCEED;
		}
	throw(MAL, "partitions.newIterator", "Group not found");
}

str
BPThasMoreElements(int *res, int *pid, int *bid)
{
	if (partitions[*res].next != 0 && partitions[*res].bid == *bid) {
		*res = partitions[*res].next;
		if( *res >=0)
			*pid = partitions[*res].pid;
		BBPincref(*pid, TRUE);
		return MAL_SUCCEED;
	}
	*res = -1;
	return MAL_SUCCEED;
}

str
BPThasMoreElementsRng(int *res, int *pid, int *bid, oid *first, oid *last)
{
	int i;

	for (i = *res + 1; i < ptop; i++)
		if (partitions[i].bid == *bid && !(partitions[i].last < *first || partitions[i].first > *last)) {
			*res = i;
			*pid = partitions[i].pid;
			BBPincref(*pid, TRUE);
			return MAL_SUCCEED;
		}
	*res = -1;
	return MAL_SUCCEED;
}

@-
Data management of the partitioned BATs.
@c
static int
BPTgetlastindex(int bid)
{
	int i;

	for (i = 0; i < ptop; i++)
		if ((partitions[i].bid == bid || partitions[i].pid == bid) && partitions[i].next == -1)
			return i;
	return -1;
}
static int
BPTgetfirstindex(int bid)
{
	int i;

	for (i = 0; i < ptop; i++)
		if ((partitions[i].bid == bid || partitions[i].pid == bid) && partitions[i].prev == -1)
			return i;
	return -1;
}
static int
getpartitionsize(int idx)
{
	return (int) partitions[idx].last - (int) partitions[idx].first + 1;
}
static int
addPartition(int idx)
{
	int i;
	BAT *b, *bn;

	b = BATdescriptor(partitions[idx].pid);
	if (b == 0)
		return -1;
	bn = BATnew(b->htype, b->ttype, BATcount(b));
	if (bn == 0)
		return -1;

	partitions[idx].last = partitions[idx].first + BATcount(b);
	for (i = 0; i <= ptop; i++)
		if (partitions[i].bid == -1)
			break;
	partitions[i].bid = partitions[idx].bid;
	partitions[i].pid = bn->batCacheid;
	partitions[i].last = partitions[i].first = partitions[idx].last;
	partitions[i].cap = partitions[idx].cap;
	partitions[i].next = -1;

	if (i >= ptop) {
		ptop = i + 1;
		partitions[ptop].bid = -1;
		partitions[ptop].next = -1;
		partitions[ptop].prev = -1;
	}

	partitions[idx].next = i;

	BATseqbase(bn, partitions[i].first);
	BBPkeepref(bn->batCacheid);
	BBPunfix(b->batCacheid);
	return i;
}

str
BPTsetCapacity(int *ret, int *bid, int *val)
{
	int i;

	(void) ret;
	i = BPTgetlastindex(*bid);
	if (i >= 0) {
		partitions[i].cap = *val;
		return MAL_SUCCEED;
	}
	throw(MAL, "partitions.setCapacity", "BAT group not found");
}

str
BPTinsert_void_bun(int *ret, int *bid, ptr val)
{
	int i;

	i = BPTgetlastindex(*bid);
	if (i >= 0) {
		if (partitions[i].cap != -1 && partitions[i].cap < getpartitionsize(i))
			i = addPartition(i);
		partitions[i].last++;
		if (i >= 0)
			return BKCinsert_void_bun(ret, &partitions[i].pid, val);
	}
	throw(MAL, "partitions.insert", "BAT group not found");
}

str
BPTinsert(int *ret, int *bid, ptr h, ptr t)
{
	int i;

	i = BPTgetlastindex(*bid);
	if (i >= 0) {
		if (partitions[i].cap != -1 && partitions[i].cap <= getpartitionsize(i))
			i = addPartition(i);
		if (i >= 0)
			return BKCinsert_bun(ret, &partitions[i].pid, h, t);
	}
	throw(MAL, "partitions.insert", "BAT group not found");
}

str
BPTinsertBAT(int *ret, int *bid, int *bnid)
{
	(void) ret;
	(void) bid;
	(void) bnid;
	throw(MAL, "partitions.insert", "BAT insert not yet implemented");
}

@-
A deletion over a BAT group may create holes between the groups comprising,
which is solved by upgrading the hbase of the descriptors.
@c
str
BPTdelete_oid(int *ret, int *bid, oid *h)
{
	int i;

	i = BPTgetlastindex(*bid);
	if (i < 0)
		throw(MAL, "partitions.delete", "BAT group not found");

	for (; i >= 0; i = partitions[i].prev) {
		if (*h >= partitions[i].first)
			return BKCdelete(ret, &partitions[i].pid, h);
		if (partitions[i].prev < 0)
			return MAL_SUCCEED;
	}
	throw(MAL, "partitions.delete", "Element not found in BAT group");
}

str
BPTcompress(int *ret, int *bid)
{
	BAT *b;
	int i;
	oid o = 0;

	(void) ret;
	i = BPTgetfirstindex(*bid);
	if (i < 0)
		throw(MAL, "partitions.commpress", "BAT group not found");
	b = BATdescriptor(i);
	if (b == 0)
		throw(MAL, "partitions.commpress", "BAT group not found");
	for (; i >= 0; i = partitions[i].next) {
		partitions[i].first = o;
		b = BATdescriptor(partitions[i].pid);
		if (b == 0)
			throw(MAL, "partitions.compress", "Internal error in BAT group");
		b->hseqbase = partitions[i].first;
		o = partitions[i].last += BATcount(b) - 1;
		BBPunfix(b->batCacheid);
	}
	return MAL_SUCCEED;
}

str
BPTdeleteBAT(int *ret, int *bid, int *bnid)
{
	int i;
	BAT *b;

	(void) ret;
	i = BPTgetlastindex(*bid);
	for (; i >= 0; i = partitions[i].prev) {
		if (partitions[i].pid == *bnid) {
			/* remove a complete BAT */
			if (partitions[i].next >= 0)
				partitions[partitions[i].next].prev = partitions[i].prev;
			if (partitions[i].prev >= 0)
				partitions[partitions[i].prev].next = partitions[i].next;
			return MAL_SUCCEED;
		}
		b = BATdescriptor(partitions[i].pid);
		if (partitions[i].first <= b->hseqbase && b->hseqbase <= partitions[i].last)
			BKCdelete_bat(ret, &partitions[i].pid, bnid);
		BBPunfix(b->batCacheid);
	}
	throw(MAL, "partitions.delete", "BAT delete not yet implemented");
}

@}
