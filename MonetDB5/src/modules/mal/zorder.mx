@/
The contents of this file are subject to the MonetDB Public License
Version 1.1 (the "License"); you may not use this file except in
compliance with the License. You may obtain a copy of the License at
http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html

Software distributed under the License is distributed on an "AS IS"
basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations
under the License.

The Original Code is the MonetDB Database System.

The Initial Developer of the Original Code is CWI.
Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
Copyright August 2008-2010 MonetDB B.V.
All Rights Reserved.
@

@f zorder
@a Martin Kersten
@* Z-order
This module provides the primitives to implement 2-dim Z-order functionality. 
Arrays stored in Z-order have a better locality of reference for many
operations. Slicing part of the array amounts to deriving a BAT with
the z-order indices required, whereafter a simple semijoin would be
sufficient to fetch the values.

The encoding produces OIDs, which makes it easy to align 
any void headed BAT as a sorted Z-ordered representation.
This gives both fast point access and clustered slicing.

@mal
module zorder;

command encode(x:int,y:int):oid
address ZORDencode_int_oid
comment "Derive the z-order index from a value pair";

command encode(x:bat[:oid,:int],y:bat[:oid,:int]):bat[:oid,:oid]
address ZORDbatencode_int_oid
comment "Derive the z-order index from a value pair";

command decode(z:oid)(x:int,y:int)
address ZORDdecode_int_oid
comment "Derive the z-order pair";

command decode(z:bat[:oid,:oid])(:bat[:oid,:int],:bat[:oid,:int])
address ZORDbatdecode_int_oid
comment "Derive the z-order pair";

command decode_x(z:oid)(x:int)
address ZORDdecode_int_oid_x
comment "Derive the z-order x-coordinate";

command decode_x(z:bat[:oid,:oid]):bat[:oid,:int]
address ZORDbatdecode_int_oid_x
comment "Derive the z-order x-coordinate";

command decode_y(z:oid)(y:int)
address ZORDdecode_int_oid_y
comment "Derive the z-order y-coordinate";

command decode_y(z:bat[:oid,:oid]):bat[:oid,:int]
address ZORDbatdecode_int_oid_y
comment "Derive the z-order y-coordinate";

command sql_slice(xb:int, yb:int, xt:int, yt:int ):bat[:str,:bat]
address ZORDsql_slice_int
comment "Wrapper of the function zorder.slice() for SQL function";

command slice(xb:int, yb:int, xt:int, yt:int ):bat[:oid,:oid]
address ZORDslice_int
comment "Extract the Z-order indices between two points";
@{
@h
#ifndef _ZORDER_H
#define _ZORDER_H


#ifdef WIN32
#if !defined(LIBMAL) && !defined(LIBATOMS) && !defined(LIBKERNEL) && !defined(LIBMAL) && !defined(LIBOPTIMIZER) && !defined(LIBSCHEDULER) && !defined(LIBMONETDB5)
#define zorder_export extern __declspec(dllimport)
#else
#define zorder_export extern __declspec(dllexport)
#endif
#else
#define zorder_export extern
#endif

zorder_export str ZORDencode_int_oid(oid *z, int *x, int *y);
zorder_export str ZORDbatencode_int_oid(int *z, int *x, int *y);
zorder_export str ZORDdecode_int_oid(int *x, int *y, oid *z);
zorder_export str ZORDdecode_int_oid_x(int *x, oid *z);
zorder_export str ZORDdecode_int_oid_y(int *y, oid *z);
zorder_export str ZORDbatdecode_int_oid(int *x, int *y, int *z);
zorder_export str ZORDbatdecode_int_oid_x(int *x, int *z);
zorder_export str ZORDbatdecode_int_oid_y(int *y, int *z);
zorder_export str ZORDslice_int(int *r, int *xb, int *yb, int *xt, int *yt);
zorder_export str ZORDsql_slice_int(int *r, int *xb, int *yb, int *xt, int *yt);

#endif /* _ZORDER_H */

@c
#include "mal_config.h"
#include "mal.h"
#include "mal_exception.h"
#include "zorder.h"

@= Zcode
static inline @2 Zencode_@1_@2(@1 x, @1 y)
{
	@2 v = 0;
	int i,mask=1;
	for ( i = 0; i < (int) (8 * sizeof(@2)/2) ; i++) {
		v |= ((x & 1) * mask);
		x>>=1;
		mask <<= 1;
		v |= ((y & 1) * mask);
		y>>=1;
		mask <<= 1;
	}
	return v;
}

static inline void Zdecode_@1_@2(@1 *x, @1 *y, @2 *z)
{
	@1 xv = 0, yv=0, mask =1;
	@2 zv = *z;
	int i;
	for ( i = 0; i < (int) (8 * sizeof(@2)); i+= 2) {
		xv |= ((zv & 1) * mask);
		zv >>= 1;
		yv |= ((zv & 1) * mask);
		zv >>= 1;
		mask <<=1;
	}
	*x = xv;
	*y = yv;
}
static inline void Zdecode_@1_@2_x(@1 *x, @2 *z)
{
	@1 xv = 0, mask =1;
	@2 zv = *z;
	int i;
	for ( i = 0; i < (int) (8 * sizeof(@2)); i+= 2) {
		xv |= ((zv & 1) * mask);
		zv >>= 2;
		mask <<=1;
	}
	*x = xv;
}
static inline void Zdecode_@1_@2_y(@1 *y, @2 *z)
{
	@1 yv=0, mask =1;
	@2 zv = *z;
	int i;
	for ( i = 0; i < (int) (8 * sizeof(@2)); i+= 2) {
		zv >>= 1;
		yv |= ((zv & 1) * mask);
		zv >>= 1;
		mask <<=1;
	}
	*y = yv;
}
@c
@:Zcode(int,oid)@

str 
ZORDencode_int_oid(oid *z, int *x, int *y)
{
	*z = Zencode_int_oid(*x,*y);
	return MAL_SUCCEED;
}

str 
ZORDdecode_int_oid(int *x, int *y, oid *z)
{
	Zdecode_int_oid(x,y,z);
	return MAL_SUCCEED;
}

str 
ZORDdecode_int_oid_x(int *x, oid *z)
{
	Zdecode_int_oid_x(x,z);
	return MAL_SUCCEED;
}

str 
ZORDdecode_int_oid_y(int *y, oid *z)
{
	Zdecode_int_oid_y(y,z);
	return MAL_SUCCEED;
}

str
ZORDbatencode_int_oid(int *zbid, int *xbid, int *ybid)
{
	BAT *bx, *by,*bz;
	int *p, *q, *r;
	oid *z;

	bx = BATdescriptor(*xbid);
	by = BATdescriptor(*ybid);
	if ( bx == 0 || by == 0){
		if ( bx ) BBPunfix(bx->batCacheid);
		if ( by ) BBPunfix(by->batCacheid);
		throw(OPTIMIZER, "zorder.encode", RUNTIME_OBJECT_MISSING);
	}
	if ( BATcount(bx) != BATcount(by)){
		BBPunfix(bx->batCacheid);
		BBPunfix(by->batCacheid);
		throw(OPTIMIZER, "zorder.encode", ILLEGAL_ARGUMENT);
	}
	
	bz = BATnew(TYPE_void, TYPE_oid, BATcount(bx));
	if (bz == 0){
		BBPunfix(bx->batCacheid);
		BBPunfix(by->batCacheid);
		throw(OPTIMIZER, "zorder.encode", MAL_MALLOC_FAIL);
	}
	p = (int *) Tloc(bx, BUNfirst(bx));
	q = (int *) Tloc(bx, BUNlast(bx));
	r = (int *) Tloc(by, BUNfirst(by));
	z = (oid *) Tloc(bz, BUNfirst(bz));

	BATaccessBegin(bx, USE_TAIL, MMAP_SEQUENTIAL);
	BATaccessBegin(by, USE_TAIL, MMAP_SEQUENTIAL);
	if ( bx->T->nonil && by->T->nonil){
		for ( ; p<q; z++,p++,r++)
			*z = Zencode_int_oid( *p, *r );
	} else
	if ( bx->T->nonil ){
		for ( ; p<q; z++,p++,r++)
		if ( *r == int_nil)
			*z = oid_nil;
		else
			*z = Zencode_int_oid( *p, *r );
	} else
	if ( by->T->nonil ){
		for ( ; p<q; z++,p++,r++)
		if ( *p == int_nil)
			*z = oid_nil;
		else
			*z = Zencode_int_oid( *p, *r );
	} else {
		for ( ; p<q; z++,p++,r++)
		if ( *r == int_nil)
			*z = oid_nil;
		else
		if ( *p == int_nil)
			*z = oid_nil;
		else
			*z = Zencode_int_oid( *p, *r );
	}

	BATaccessEnd(bx, USE_TAIL, MMAP_SEQUENTIAL);
	BATaccessEnd(by, USE_TAIL, MMAP_SEQUENTIAL);
	BBPunfix(bx->batCacheid);
	BBPunfix(by->batCacheid);

	if (!(bz->batDirty&2)) 
		bz = BATsetaccess(bz, BAT_READ);
	BATsetcount(bz, BATcount(bx));
	BATseqbase(bz, bx->hseqbase);
	bz->hsorted = 1;
	bz->tsorted = 0;
	bz->H->nonil = 1;
	bz->T->nonil = bx->T->nonil && by->T->nonil;

	if (bx->htype != bz->htype) {
        BAT *r = VIEWcreate(bx,bz);
        BBPreleaseref(bz->batCacheid);
        bz = r;
    }

	BBPkeepref(*zbid = bz->batCacheid);
	return MAL_SUCCEED;
}

str
ZORDbatdecode_int_oid(int *xbid, int *ybid, int *zbid)
{
	BAT *bx, *by,*bz;
	oid *z, *q;
	int *x, *y;

	bz = BATdescriptor(*zbid);
	if ( bz == 0 )
		throw(OPTIMIZER, "zorder.decode", RUNTIME_OBJECT_MISSING);
	
	bx = BATnew(TYPE_void, TYPE_int, BATcount(bz));
	by = BATnew(TYPE_void, TYPE_int, BATcount(bz));
	if ( bx == 0 || by == 0 ){
		if ( bx ) BBPunfix(bx->batCacheid);
		if ( by ) BBPunfix(by->batCacheid);
		BBPunfix(bz->batCacheid);
		throw(OPTIMIZER, "zorder.decode", RUNTIME_OBJECT_MISSING);
	}
	
	z = (oid *) Tloc(bz, BUNfirst(bz));
	q = (oid *) Tloc(bz, BUNlast(bz));
	x = (int *) Tloc(bx, BUNfirst(bx));
	y = (int *) Tloc(by, BUNfirst(by));

	BATaccessBegin(bz, USE_TAIL, MMAP_SEQUENTIAL);
	if ( bz->T->nonil ){
		for ( ; z<q; z++,x++,y++)
			Zdecode_int_oid(x,y,z);
	} else {
		for ( ; z<q; z++,x++,y++)
		if ( *z == oid_nil) {
			*x = int_nil;
			*y = int_nil;
		} else
			Zdecode_int_oid( x,y,z);
	} 

	BATaccessEnd(bz, USE_TAIL, MMAP_SEQUENTIAL);

	if (!(bx->batDirty&2)) 
		bx = BATsetaccess(bx, BAT_READ);
	BATsetcount(bx, BATcount(bz));
	BATseqbase(bx, bz->hseqbase);
	bx->hsorted = 1;
	bx->tsorted = 0;
	bx->H->nonil = 1;
	bx->T->nonil = bz->T->nonil;

	if (bx->htype != bz->htype) {
        BAT *r = VIEWcreate(bz,bx);
        BBPreleaseref(bx->batCacheid);
        bx = r;
    }

	if (!(by->batDirty&2)) 
		by = BATsetaccess(by, BAT_READ);
	BATsetcount(by, BATcount(bz));
	BATseqbase(by, bz->hseqbase);
	by->hsorted = 1;
	by->tsorted = 0;
	by->H->nonil = 1;
	by->T->nonil = bz->T->nonil;

	if (by->htype != bz->htype) {
        BAT *r = VIEWcreate(bz,by);
        BBPreleaseref(by->batCacheid);
        by = r;
    }

	BBPunfix(bz->batCacheid);
	BBPkeepref(*xbid = bx->batCacheid);
	BBPkeepref(*ybid = by->batCacheid);
	return MAL_SUCCEED;
}

str
ZORDbatdecode_int_oid_x(int *xbid, int *zbid)
{
	BAT *bx,*bz;
	oid *z, *q;
	int *x;

	bz = BATdescriptor(*zbid);
	if ( bz == 0 )
		throw(OPTIMIZER, "zorder.decode", RUNTIME_OBJECT_MISSING);
	
	bx = BATnew(TYPE_void, TYPE_int, BATcount(bz));
	if ( bx == 0 ){
		BBPunfix(bz->batCacheid);
		throw(OPTIMIZER, "zorder.decode", RUNTIME_OBJECT_MISSING);
	}
	
	z = (oid *) Tloc(bz, BUNfirst(bz));
	q = (oid *) Tloc(bz, BUNlast(bz));
	x = (int *) Tloc(bx, BUNfirst(bx));

	BATaccessBegin(bz, USE_TAIL, MMAP_SEQUENTIAL);
	if ( bz->T->nonil ){
		for ( ; z<q; z++,x++)
			Zdecode_int_oid_x(x,z);
	} else {
		for ( ; z<q; z++,x++)
		if ( *z == oid_nil) {
			*x = int_nil;
		} else
			Zdecode_int_oid_x(x,z);
	} 

	BATaccessEnd(bz, USE_TAIL, MMAP_SEQUENTIAL);

	if (!(bx->batDirty&2)) 
		bx = BATsetaccess(bx, BAT_READ);
	BATsetcount(bx, BATcount(bz));
	BATseqbase(bx, bz->hseqbase);
	bx->hsorted = 1;
	bx->tsorted = 0;
	bx->H->nonil = 1;
	bx->T->nonil = bz->T->nonil;

	if (bx->htype != bz->htype) {
        BAT *r = VIEWcreate(bz,bx);
        BBPreleaseref(bx->batCacheid);
        bx = r;
    }

	BBPunfix(bz->batCacheid);
	BBPkeepref(*xbid = bx->batCacheid);
	return MAL_SUCCEED;
}

str
ZORDbatdecode_int_oid_y(int *ybid, int *zbid)
{
	BAT *by,*bz;
	oid *z, *q;
	int *y;

	bz = BATdescriptor(*zbid);
	if ( bz == 0 )
		throw(OPTIMIZER, "zorder.decode", RUNTIME_OBJECT_MISSING);
	
	by = BATnew(TYPE_void, TYPE_int, BATcount(bz));
	if ( by == 0 ){
		BBPunfix(bz->batCacheid);
		throw(OPTIMIZER, "zorder.decode", RUNTIME_OBJECT_MISSING);
	}
	
	z = (oid *) Tloc(bz, BUNfirst(bz));
	q = (oid *) Tloc(bz, BUNlast(bz));
	y = (int *) Tloc(by, BUNfirst(by));

	BATaccessBegin(bz, USE_TAIL, MMAP_SEQUENTIAL);
	if ( bz->T->nonil ){
		for ( ; z<q; z++,y++)
			Zdecode_int_oid_y(y,z);
	} else {
		for ( ; z<q; z++,y++)
		if ( *z == oid_nil) {
			*y = int_nil;
		} else
			Zdecode_int_oid_y(y,z);
	} 

	BATaccessEnd(bz, USE_TAIL, MMAP_SEQUENTIAL);

	if (!(by->batDirty&2)) 
		by = BATsetaccess(by, BAT_READ);
	BATsetcount(by, BATcount(bz));
	BATseqbase(by, bz->hseqbase);
	by->hsorted = 1;
	by->tsorted = 0;
	by->H->nonil = 1;
	by->T->nonil = bz->T->nonil;

	if (by->htype != bz->htype) {
        BAT *r = VIEWcreate(bz,by);
        BBPreleaseref(by->batCacheid);
        by = r;
    }

	BBPunfix(bz->batCacheid);
	BBPkeepref(*ybid = by->batCacheid);
	return MAL_SUCCEED;
}

zorder_export 
str ZORDslice_int(int *r, int *xb, int *yb, int *xt, int *yt)
{
	BAT *bn;
	int i,j;
	oid zv;

	bn = BATnew(TYPE_void, TYPE_oid, 0);
	BATseqbase(bn, 0);
	if( bn == 0)
		throw(OPTIMIZER, "zorder.slice", MAL_MALLOC_FAIL);
	/* use the expensive road, could be improved by bit masking */
	for ( i= *xb; i < *xt; i++)
	{
		for (j= *yb; j < *yt; j++){
			zv= Zencode_int_oid(i,j);
			BUNappend(bn, &zv, FALSE);
		}
	}

	if (!(bn->batDirty&2)) 
		bn = BATsetaccess(bn, BAT_READ);
	BBPkeepref(*r = bn->batCacheid);
	return MAL_SUCCEED;
}

zorder_export 
str ZORDsql_slice_int(int *r, int *xb, int *yb, int *xt, int *yt)
{
    int slice_ret;
	BAT *t = BATnew(TYPE_str, TYPE_bat, 1);
    str bla;

    rethrow("ZORDsql_slice_int", bla, 
            ZORDslice_int(&slice_ret, xb, yb, xt, yt));

	BUNins(t, "z", &slice_ret, FALSE);
    BBPdecref(slice_ret, TRUE);
	*r = t->batCacheid;
	BBPkeepref(*r);
	return MAL_SUCCEED;
}
@}
