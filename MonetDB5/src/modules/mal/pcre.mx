@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2008 CWI.
@' All Rights Reserved.

@f pcre
@a N. Nes
@+ PCRE library interface
The  PCRE library is a set of functions that implement regular 
expression pattern matching using the same syntax  and  semantics  as  Perl,
with  just  a  few  differences.  The  current  implementation of PCRE
(release 4.x) corresponds approximately with Perl 5.8, including  support
for  UTF-8  encoded  strings.   However,  this support has to be
explicitly enabled; it is not the default.
@{
@mal
atom pcre:ptr;
command tostr()   address pcre_tostr;
command fromstr() address pcre_fromstr;
command nequal()  address pcre_nequal;
command hash()    address pcre_hash;
command null()    address pcre_null;
command put()     address pcre_put;
command del()     address pcre_del;
command length()  address pcre_length;
command heap()    address pcre_heap;

command compile(pat:str ) :pcre 
address PCREcompile_wrap
comment "compile a pattern";

command match(pat:pcre, s:str) :bit 
address PCREexec_wrap
comment "match a pattern";

command index(pat:pcre, s:str) :int 
address PCREindex
comment "match a pattern, return matched position (or 0 when not found)";

command select(pat:str, strs:bat[:any_1,:str]) :bat[:any_1,:str] 
address PCREselect
comment "Select tuples based on the pattern";

command uselect(pat:str, strs:bat[:any_1,:str]) :bat[:any_1,:void] 
address PCREuselect
comment "Select tuples based on the pattern, only returning the head";

command match(s:str, pat:str):bit
address PCREmatch
comment "POSIX pattern matching against a string";

command patindex(pat:str, s:str) :int
address PCREpatindex
comment "Location of the first POSIX pattern matching against a string";

command replace(origin:str,pat:str,repl:str,flags:str):str
address PCREreplace_wrap
comment "Replace _all_ matches of \"pattern\" in \"origin_str\" with \"replacement\".
	 Parameter \"flags\" accept these flags: 'i', 'm', 's', and 'x'.
	   'e': if present, an empty string is considered to be a valid match
	   'i': if present, the match operates in case-insensitive mode. 
		Otherwise, in case-sensitive mode.
	 'm': if present, the match operates in multi-line mode.
	   's': if present, the match operates in \"dot-all\"
	   The specifications of the flags can be found in \"man pcreapi\"
	   The flag letters may be repeated.
	   No other letters than 'e', 'i', 'm', 's' and 'x' are allowed in \"flags\".
	   Returns the replaced string, or if no matches found, the original string.";

command replace(orig:bat[:any_1,:str],pat:str,repl:str,flag:str):bat[:any_1,:str]
address PCREreplace_bat_wrap;

command pcre_quote(s:str):str 
address PCREquote
comment "Return a PCRE pattern string that matches the argument exactly.";

command sql2pcre(pat:str,esc:str):str
address PCREsql2pcre
comment "Convert a SQL like pattern with the given escape character into a PCRE pattern.";

command like(s:str, pat:str, esc:str):bit 
address PCRElike3;

command like(s:str, pat:str):bit 
address PCRElike2;

command like(s:bat[:any_1,:str], pat:str, esc:str):bat[:any_1,:void] 
address PCRElike_uselect_pcre;

pattern prelude() :void 
address pcre_init
comment "Initialize pcre";

pcre.prelude();
@-
@verbatim
ftp://ftp.csx.cam.ac.uk/pub/software/programming/pcre
@end verbatim

@+ Implementation
@include prelude.mx
@c
#include "mal_config.h"
#include "mal.h"
#include "mal_exception.h"


#ifdef WIN32
#ifndef LIBPCRE
#define pcre_export extern __declspec(dllimport)
#else
#define pcre_export extern __declspec(dllexport)
#endif
#else
#define pcre_export extern
#endif

#ifndef HAVE_LIBPCRE
#define pcre str
#else
#include <pcre.h>
#endif

pcre_export str PCREquote(str *r, str *v);
pcre_export str PCREselect(int *res, str *pattern, int *bid);
pcre_export str PCREuselect(int *res, str *pattern, int *bid);
pcre_export str PCREmatch(bit *ret, str *val, str *pat);
pcre_export str PCREindex(int *ret, pcre *pat, str *val);
pcre_export str PCREpatindex(int *ret, str *pat, str *val);
pcre_export str PCREfromstr(str instr, int *l, pcre ** val);

pcre_export str PCREreplace_wrap(str *res, str *or, str *pat, str *repl, str *flags);
pcre_export str PCREreplace_bat_wrap(int *res, int *or, str *pat, str *repl, str *flags);

pcre_export str PCREcompile_wrap(pcre ** res, str *pattern);
pcre_export str PCREexec_wrap(bit *res, pcre * pattern, str *s);
pcre_export int pcre_tostr(str *tostr, int *l, pcre * p);
pcre_export int pcre_fromstr(str instr, int *l, pcre ** val);
pcre_export int pcre_nequal(pcre * l, pcre * r);
pcre_export hash_t pcre_hash(pcre * b);
pcre_export pcre * pcre_null(void);
pcre_export void pcre_del(Heap *h, var_t *index);
pcre_export int pcre_length(pcre * p);
pcre_export void pcre_heap(Heap *heap, size_t capacity);
pcre_export var_t pcre_put(Heap *h, var_t *bun, pcre * val);
pcre_export str PCRElike3(bit *ret, str *s, str *pat, str *esc);
pcre_export str PCRElike2(bit *ret, str *s, str *pat);
pcre_export str PCRElike_uselect_pcre(int *ret, int *b, str *pat, str *esc);
pcre_export str pcre_init(void);

#ifndef HAVE_LIBPCRE

str
pcre_compile_wrap(pcre ** res, str pattern)
{
	(void) res;
	(void) pattern;

	throw(MAL, "pcre_compile", "not available as required version of libpcre was not found by configure.\n");
}

str
pcre_exec_wrap(bit *res, pcre * pattern, str s)
{
	(void) res;
	(void) pattern;
	(void) s;
	throw(MAL, "pcre_exec", "not available as required version of libpcre was not found by configure.\n");
}

str
pcre_index(int *res, pcre * pattern, str s)
{
	(void) res;
	(void) pattern;
	(void) s;
	throw(MAL, "pcre_index", "not available as required version of libpcre was not found by configure.\n");
}

str
pcre_select(BAT **res, str pattern, BAT *strs)
{
	(void) res, (void) pattern;
	(void) strs;

	throw(MAL, "pcre_select", "not available as required version of libpcre was not found by configure.\n");
}

str
pcre_uselect(BAT **res, str pattern, BAT *strs)
{
	(void) res, (void) pattern;
	(void) strs;

	throw(MAL,  "pcre_uselect", "not available as required version of libpcre was not found by configure.\n");
}

str
pcre_replace(str *res, str origin_str, str pattern, str replacement, str flags)
{
	(void) res;
	(void) origin_str;
	(void) pattern;
	(void) replacement;
	(void) flags;
	throw(MAL, "pcre_replace","not available as required version of libpcre was not found by configure.\n");
}

str
pcre_replace_bat(BAT **res, BAT *origin_strs, str pattern, str replacement, str flags)
{
	(void) res;
	(void) origin_strs;
	(void) pattern;
	(void) replacement;
	(void) flags;
	throw(MAL, "pcre_replace_bat","not available as required version of libpcre was not found by configure.");
}

str 
pcre_init(void)
{
	return NULL;
}

void
pcre_exit(void)
{
}

int
pcre_match_with_flags(bit *ret, str val, str pat, str flags)
{
	(void) ret;
	(void) val;
	(void) pat;
    (void)flags;
	GDKerror("pcre_match_with_flags() not available as required version of libpcre was not found by configure.\n");
	return GDK_FAIL;
}

str
pcre_match(bit *ret, str val, str pat)
{
	(void) ret;
	(void) val;
	(void) pat;
	throw(MAL, "pcre_match", "not available as required version of libpcre was not found by configure.\n");
}

#else

#include <pcre.h>

#define m2p(p) (pcre*)(((size_t*)p)+1)
#define p2m(p) (pcre*)(((size_t*)p)-1)

void *
my_pcre_malloc(size_t s)
{
	char *r = GDKmalloc(s + sizeof(size_t));
	size_t *sz = (size_t *) r;

	*sz = s + sizeof(size_t);
	return (void *) (sz + 1);
}

void
my_pcre_free(void *blk)
{
	size_t *sz = (size_t *) blk;

	sz -= 1;
	GDKfree((void *) sz);
}

str
pcre_compile_wrap(pcre ** res, str pattern)
{
	pcre *r;
	const char err[BUFSIZ], *err_p = err;
	int errpos = 0;

	if ((r = pcre_compile(pattern, PCRE_UTF8 | PCRE_MULTILINE, &err_p, &errpos, NULL)) == NULL) {
		throw(MAL,"pcre.compile",
			"failed with\n'%s'\nat %d in\n'%s'.\n",
				err_p, errpos, pattern);
	}
	*(pcre **) res = p2m(r);
	return MAL_SUCCEED;
}

str
pcre_exec_wrap(bit *res, pcre * pattern, str s)
{
	if (pcre_exec(m2p(pattern), NULL, s, strlen(s), 0, 0, NULL, 0) >= 0) {
		*res = TRUE;
		return MAL_SUCCEED;
	} 
	*res = FALSE;
	throw(MAL, "pcre.exec","failed to execute pattern match");
}

str
pcre_index(int *res, pcre * pattern, str s)
{
	int v[2];

	v[0] = v[1] = *res = 0;
	if (pcre_exec(m2p(pattern), NULL, s, strlen(s), 0, 0, v, 2) >= 0) {
		*res = v[1];
	}
	return MAL_SUCCEED;
}

str
pcre_select(BAT **res, str pattern, BAT *strs)
{
	BATiter strsi = bat_iterator(strs);
	const char err[BUFSIZ], *err_p = err;
	int errpos = 0;
	BAT *r;
	BUN p, q;
	pcre *re = NULL;

	if (strs->htype == TYPE_void)
		r = BATnew(TYPE_oid, TYPE_str, BATcount(strs));
	else
		r = BATnew(strs->htype, TYPE_str, BATcount(strs));
	if ((re = pcre_compile(pattern, PCRE_UTF8 | PCRE_MULTILINE, &err_p, &errpos, NULL)) == NULL) {
		throw(MAL, "pcre_select", "pcre compile of pattern (%s) failed at %d with\n'%s'.",
			pattern, errpos, err_p);
	}
	BATloop(strs, p, q) {
		str s = BUNtail(strsi, p);

		if (pcre_exec(re, NULL, s, strlen(s), 0, 0, NULL, 0) >= 0) {
			BUNins(r, BUNhead(strsi, p), s, FALSE);
		}
	}
	if (!(r->batDirty&2)) r = BATsetaccess(r, BAT_READ);
	my_pcre_free(re);
	*res = r;
	return MAL_SUCCEED;
}

str
pcre_uselect(BAT **res, str pattern, BAT *strs)
{
	BATiter strsi = bat_iterator(strs);
	const char err[BUFSIZ], *err_p = err;
	int errpos = 0;
	BAT *r;
	BUN p, q;
	pcre *re = NULL;

	if (strs->htype == TYPE_void)
		r = BATnew(TYPE_oid, TYPE_void, BATcount(strs));
	else
		r = BATnew(strs->htype, TYPE_void, BATcount(strs));
	if ((re = pcre_compile(pattern, PCRE_UTF8 | PCRE_MULTILINE, &err_p, &errpos, NULL)) == NULL) {
		throw(MAL, "pcre_uselect", "pcre compile of pattern (%s) failed at %d with\n'%s'.",
			pattern, errpos, err_p);
	}
	BATloop(strs, p, q) {
		str s = BUNtail(strsi, p);

		if (pcre_exec(re, NULL, s, strlen(s), 0, 0, NULL, 0) >= 0) {
			BUNins(r, BUNhead(strsi, p), NULL, FALSE);
		}
	}
	my_pcre_free(re);
	if (!(r->batDirty&2)) r = BATsetaccess(r, BAT_READ);
	*res = r;
	return MAL_SUCCEED;
}

#define MAX_NR_CAPTURES  1024 /* Maximal number of captured substrings in one original string */

str
pcre_replace(str *res, str origin_str, str pattern, str replacement, str flags)
{
	const char err[BUFSIZ], *err_p = err, *err_p2 = err;
	pcre *pcre_code = NULL;
	pcre_extra *extra;
	str tmpres;
	int i, j, k, len, errpos = 0, offset = 0;
	int compile_options = PCRE_UTF8, exec_options = PCRE_NOTEMPTY;
	int *ovector, ovecsize;
	int len_origin_str = strlen(origin_str);
	int len_replacement = strlen(replacement);
	int capture_offsets[MAX_NR_CAPTURES * 2], ncaptures = 0, len_del = 0;
	
	for (i = 0; i < (int)strlen(flags); i++) {
		if (flags[i] == 'e') {
			exec_options -= PCRE_NOTEMPTY;
			stream_printf(GDKout, "exec_options %d, PCRE_NOTEMPTY %d\n",
					exec_options, PCRE_NOTEMPTY);
		} else if (flags[i] == 'i') {
			compile_options |= PCRE_CASELESS;
		} else if (flags[i] == 'm') {
			compile_options |= PCRE_MULTILINE;
		} else if (flags[i] == 's') {
			compile_options |= PCRE_DOTALL;
		} else if (flags[i] == 'x') {
			compile_options |= PCRE_EXTENDED;
		} else {
			throw(MAL,"pcre_replace","unsupported flag character '%c'\n", flags[i]);
		}
	}

	if ((pcre_code = pcre_compile(pattern, compile_options, &err_p, &errpos, NULL)) == NULL) {
		throw(MAL,"pcre_replace","pcre compile of pattern (%s) failed at %d with\n'%s'.\n", pattern, errpos, err_p);
	}

	/* Since the compiled pattern is going to be used several times, it is
	 * worth spending more time analyzing it in order to speed up the time
	 * taken for matching.
	 */
	extra = pcre_study(pcre_code, 0, &err_p2);
	pcre_fullinfo(pcre_code, extra, PCRE_INFO_CAPTURECOUNT, &i);
	ovecsize = (i + 1) * 3;
	if ((ovector = (int *) GDKmalloc(sizeof(int) * ovecsize)) == NULL) {
		my_pcre_free(pcre_code);
		throw(MAL, "pcre_replace","not enough memory\n");
	}
	
	i = 0;
	do {
		j = pcre_exec(pcre_code, extra, origin_str, len_origin_str, 
						offset, exec_options, ovector, ovecsize);
		if (j > 0){
			capture_offsets[i] = ovector[0];
			capture_offsets[i+1] = ovector[1];
			ncaptures++;
			i += 2;
			len_del += (ovector[1] - ovector[0]);
			offset = ovector[1];
		}
	} while((j > 0) && (offset < len_origin_str) && (ncaptures < MAX_NR_CAPTURES));
	
	if (ncaptures > 0){
		tmpres = GDKmalloc(len_origin_str - len_del + (len_replacement * ncaptures) + 1);
		if (!tmpres) {
			my_pcre_free(pcre_code);
			GDKfree(ovector);
			throw(MAL, "pcre_replace","not enough memory\n");
		}

		j = k = 0;

		/* possibly copy the substring before the first captured substring */
		strncpy(tmpres, origin_str, capture_offsets[j]); 
		k = capture_offsets[j];
		j++;

		for (i = 0; i < ncaptures - 1; i++) {
			strncpy(tmpres+k, replacement, len_replacement);
			k += len_replacement;
			/* copy the substring between two captured substrings */
			len = capture_offsets[j+1] - capture_offsets[j];
			strncpy(tmpres+k, origin_str+capture_offsets[j], len);
			k += len;
			j += 2;
		}

		/* replace the last captured substring */
		strncpy(tmpres+k, replacement, len_replacement);
		k += len_replacement;
		/* possibly copy the substring after the last captured substring */
		len = len_origin_str - capture_offsets[j];
		strncpy(tmpres+k, origin_str+capture_offsets[j], len);
		k += len;
		tmpres[k] = '\0';
	} else { /* no captured substrings, return the original string*/
		tmpres = GDKstrdup(origin_str);
	}

	my_pcre_free(pcre_code);
	GDKfree(ovector);
	*res = tmpres;
	return MAL_SUCCEED;
}

str
pcre_replace_bat(BAT **res, BAT *origin_strs, str pattern, str replacement, str flags)
{
	BATiter origin_strsi = bat_iterator(origin_strs);
	const char err[BUFSIZ], *err_p = err, *err_p2 = err;
	int i, j, k, len, errpos = 0, offset = 0;
	int compile_options = PCRE_UTF8, exec_options = PCRE_NOTEMPTY;
	pcre *pcre_code = NULL;
	pcre_extra *extra;
	BAT *tmpbat;
	BUN p, q;
	int *ovector, ovecsize;
	int len_origin_str, len_replacement = strlen(replacement);
	int capture_offsets[MAX_NR_CAPTURES * 2], ncaptures = 0, len_del = 0;
	str origin_str, replaced_str;

	for (i = 0; i < (int)strlen(flags); i++) {
		if (flags[i] == 'e') {
			exec_options |= (~PCRE_NOTEMPTY);
		} else if (flags[i] == 'i') {
			compile_options |= PCRE_CASELESS;
		} else if (flags[i] == 'm') {
			compile_options |= PCRE_MULTILINE;
		} else if (flags[i] == 's') {
			compile_options |= PCRE_DOTALL;
		} else if (flags[i] == 'x') {
			compile_options |= PCRE_EXTENDED;
		} else {
			throw(MAL,"pcre_replace_bat",
				"\"flags\" contains invalid character '%c'\n", flags[i]);
		}
	}

	if ((pcre_code = pcre_compile(pattern, compile_options, &err_p, &errpos, NULL)) == NULL) {
		throw(MAL,"pcre_replace_bat",
			"pcre compile of pattern (%s) failed at %d with\n'%s'.\n", pattern, errpos, err_p);
	}

	/* Since the compiled pattern is ging to be used several times, it is worth spending 
	 * more time analyzing it in order to speed up the time taken for matching.
	 */
	extra = pcre_study(pcre_code, 0, &err_p2);
	pcre_fullinfo(pcre_code, extra, PCRE_INFO_CAPTURECOUNT, &i);
	ovecsize = (i + 1) * 3;
	if ((ovector = (int *) GDKzalloc(sizeof(int) * ovecsize)) == NULL) {
		my_pcre_free(pcre_code);
		throw(MAL, "pcre_replace_bat","not enough memory");
	}
	
	tmpbat = BATnew(origin_strs->htype, TYPE_str, BATcount(origin_strs));
	BATloop(origin_strs, p, q) {
		origin_str = BUNtail(origin_strsi, p);
		len_origin_str = strlen(origin_str);
		i = ncaptures = len_del = offset = 0;
		do {
			j = pcre_exec(pcre_code, extra, origin_str, len_origin_str, offset,
					exec_options, ovector, ovecsize);
			if (j > 0){
				capture_offsets[i] = ovector[0];
				capture_offsets[i+1] = ovector[1];
				ncaptures++;
				i += 2;
				len_del += (ovector[1] - ovector[0]);
				offset = ovector[1];
			}
		} while((j > 0) && (offset < len_origin_str) && (ncaptures < MAX_NR_CAPTURES));
	
		if (ncaptures > 0){
			replaced_str = GDKmalloc(len_origin_str - len_del + (len_replacement * ncaptures) + 1);
			if (!replaced_str) {
				my_pcre_free(pcre_code);
				GDKfree(ovector);
				throw(MAL, "pcre_replace_bat","not enough memory\n");
			}

			j = k = 0;

			/* copy eventually the substring before the first captured
			 * substring */
			strncpy(replaced_str, origin_str, capture_offsets[j]); 
			k = capture_offsets[j];
			j++;

			for (i = 0; i < ncaptures - 1; i++) {
				strncpy(replaced_str+k, replacement, len_replacement);
				k += len_replacement;
				/* copy the substring between two captured substrings */
				len = capture_offsets[j+1] - capture_offsets[j];
				strncpy(replaced_str+k, origin_str+capture_offsets[j], len);
				k += len;
				j += 2;
			}

			/* replace the last captured substring */
			strncpy(replaced_str+k, replacement, len_replacement);
			k += len_replacement;
			/* copy eventually the substring after the last captured substring */
			len = len_origin_str - capture_offsets[j];
			strncpy(replaced_str+k, origin_str+capture_offsets[j], len);
			k += len;
			replaced_str[k] = '\0';
			BUNins(tmpbat, BUNhead(origin_strsi, p), replaced_str, FALSE);
			GDKfree(replaced_str);
		} else { /* no captured substrings, copy the original string into new bat */
			BUNins(tmpbat, BUNhead(origin_strsi, p), origin_str, FALSE);
		}
	}

	my_pcre_free(pcre_code);
	GDKfree(ovector);
	if (origin_strs->htype == TYPE_void) {
		*res = BATseqbase(tmpbat, origin_strs->hseqbase);
	} else {
		*res = tmpbat;
	}
	return MAL_SUCCEED;
}

str 
pcre_init(void)
{
	pcre_malloc = my_pcre_malloc;
	pcre_free = my_pcre_free;
	return NULL;
}

void
pcre_exit(void)
{
}

str
pcre_match_with_flags(int *ret, str val, str pat, str flags)
{
	const char err[BUFSIZ], *err_p = err;
	int errpos = 0;
	int options = PCRE_UTF8, i;
	pcre *re;

	for (i = 0; i < (int)strlen(flags); i++) {
		if (flags[i] == 'i') {
			options |= PCRE_CASELESS;
		} else if (flags[i] == 'm') {
			options |= PCRE_MULTILINE;
		} else if (flags[i] == 's') {
			options |= PCRE_DOTALL;
		} else if (flags[i] == 'x') {
			options |= PCRE_EXTENDED;
		} else {
			throw(MAL, "pcre_match", "unsupported flag character '%c'\n", flags[i]);
		}
	}

	if ((re = pcre_compile(pat, options, &err_p, &errpos, NULL)) == NULL) {
		throw(MAL, "pcre_match", "Compilation of regular expression (%s) failed at %d with '%s'", pat, errpos, err_p);
	}
	*ret = pcre_exec(re, NULL, val, strlen(val), 0, 0, NULL, 0);
	return MAL_SUCCEED;
}

str
pcre_match(bit *ret, str val, str pat)
{
	str msg;
	int errpos = 0;

	if ((msg = pcre_match_with_flags(&errpos, val, pat, "")) != MAL_SUCCEED) 
		return msg;

	if (errpos >= 0)
		*ret = TRUE;
	else if (errpos == -1)
		*ret = FALSE;
	else 
		throw(MAL, "pcre_match", "Matching of regular expression (%s) failed with %d", pat, errpos);
	return msg;
}

#endif

static int
pcre_quote(str *res, str s)
{
	str p;

	*res = p = GDKmalloc(strlen(s) * 2 + 1); /* certainly long enough */
	if (p == NULL)
		return GDK_FAIL;
	/* quote all non-alphanumeric ASCII characters (i.e. leave
	   non-ASCII and alphanumeric alone) */
	while (*s) {
		if (!((*s & 0x80) != 0 ||
		      ('a' <= *s && *s <= 'z') ||
		      ('A' <= *s && *s <= 'Z') ||
		      ('0' <= *s && *s <= '9')))
			*p++ = '\\';
		*p++ = *s++;
	}
	*p = 0;
	return GDK_SUCCEED;
}

int
pcre_tostr(str *tostr, int *l, pcre * p)
{
	(void) tostr;
	(void) l;
	(void) p;
	return GDK_FAIL;
}

int
pcre_fromstr(str instr, int *l, pcre ** val)
{
	(void) instr;
	(void) l;
	(void) val;
	return GDK_FAIL;
}

int
pcre_nequal(pcre * l, pcre * r)
{
	if (l != r)
		return 0;
	else
		return 1;
}

hash_t
pcre_hash(pcre * b)
{
	return *(sht *) b;
}

pcre *
pcre_null(void)
{
	static sht nullval, *r;

	nullval = ~(sht) 0;
	r = &nullval;
	return ((pcre *) (r));
}

void
pcre_del(Heap *h, var_t *idx)
{
	HEAP_free(h, *idx);
}

#define pcresize(val) ((size_t*)val)[0]

var_t
pcre_put(Heap *h, var_t *bun, pcre * val)
{
	char *base;

	*bun = HEAP_malloc(h, pcresize(val));
	base = h->base;
	if (*bun)
		memcpy(&base[*bun], (char *) val, pcresize(val));
	return *bun;
}

int
pcre_length(pcre * p)
{
	return (pcresize(p));
}

void
pcre_heap(Heap *heap, size_t capacity)
{
	HEAP_initialize(heap, capacity, 0, (int) sizeof(var_t));
}

/* change SQL LIKE pattern into PCRE pattern */
int
sql2pcre(str *r, str pat, str esc_str) 
{
	/* change the SQL wilcards into PCRE wildcards */
	int len = (int) strlen(pat);
	int escaped = 0;
	int hasWildcard = 0;
	char *ppat = GDKmalloc(len*2+3 /* 3 = "^'the translated regexp'$0" */);
	int esc = esc_str[0]; /* should change to utf8_convert() */
	int specials = 0;

	*r = ppat;
	/*
	# the escape character can be a char which is special in a PCRE
	# if the user used the "+" char as escape and has "++" in
	# its pattern, then replacing this with "+" is not correct
	# but should be "\+"
	*/
	if (*esc_str && strchr( ".+*()[]", esc) != NULL) 
		specials = 1; 

	*ppat ++ = '^';
	while (*pat) {
		int c = *pat++;

		if (c == esc) {
			if (escaped) {
				if (specials) { /* change ++ into \\+ */
					*ppat++ = esc;
				} else { /* do not escape simple escape symbols */
					ppat[-1] = esc;
				}
				escaped = 0;
			} else {
				*ppat++ = '\\';
				escaped = 1;
			}
			/* not optimal but functional */
			hasWildcard = 1; 
		} else if (strchr( ".?+*()[]\\", c) != NULL) {
			*ppat++ = '\\';
			*ppat++ = c;
			/* not optimal but functional */
			hasWildcard = 1; 
			escaped = 0;
		} else if (c == '%' && !escaped) {
			*ppat++ = '.';
			*ppat++ = '*';
			hasWildcard = 1;
		} else if (c == '_' && !escaped) {
			*ppat++ = '.';
			hasWildcard = 1;
		} else {
			*ppat++ = c;
			escaped = 0;
		}
	}
	/* no wildcard or escape character at end of string */
	if (!hasWildcard || escaped) {
		GDKfree(*r);
		*r = GDKstrdup(str_nil);
		if (escaped)
			return GDK_FAIL; 
	} else {
		*ppat++ = '$';
		*ppat = 0;
	}
	return GDK_SUCCEED; 
}

/* change SQL PATINDEX pattern into PCRE pattern */
int
pat2pcre(str *r, str pat) 
{
	int len = (int) strlen(pat);
	char *ppat = GDKmalloc(len*2+3 /* 3 = "^'the translated regexp'$0" */);
	int start = 0;

	*r = ppat;
	while (*pat) {
		int c = *pat++;

		if (strchr( ".+*()\\", c) != NULL) {
			*ppat++ = '\\';
			*ppat++ = c;
		} else if (c == '%') {
			if (start && *pat) {
				*ppat++ = '.';
				*ppat++ = '*';
			}
			start++;
		} else if (c == '_') {
			*ppat++ = '.';
		} else {
			*ppat++ = c;
		}
	}
	*ppat = 0;
	return GDK_SUCCEED; 
}
@+ Wrapping
@c
#include "mal.h"
str
PCREfromstr(str instr, int *l, pcre ** val)
{
	(void) instr;
	(void) l;
	(void) val;
	return NULL;
}

str
PCREreplace_wrap(str *res, str *or, str *pat, str *repl, str *flags){
	return pcre_replace(res,*or,*pat,*repl,*flags);
}

str
PCREreplace_bat_wrap(int *res, int *bid, str *pat, str *repl, str *flags){
	BAT *b,*bn = NULL;
	str msg;
	if ((b = BATdescriptor(*bid)) == NULL)
		throw(MAL, "pcre.replace", "Cannot access descriptor");

	msg = pcre_replace_bat(&bn,b,*pat,*repl,*flags);
	if( msg == MAL_SUCCEED){
		*res= bn->batCacheid;
		BBPkeepref(*res);
	}
	BBPunfix(b->batCacheid);
	return msg;
}

str
PCREcompile_wrap(pcre ** res, str *pattern)
{
	return pcre_compile_wrap(res, *pattern);
}

str
PCREexec_wrap(bit *res, pcre * pattern, str *s)
{
#ifndef HAVE_LIBPCRE
	(void) res;
	(void) pattern;
	(void) s;
	throw(MAL, "pcre.select", "Library missing");
#else
	return pcre_exec_wrap(res, pattern, *s);
#endif
}

str
PCREselect(int *res, str *pattern, int *bid)
{
#ifndef HAVE_LIBPCRE
	(void) res;
	(void) pattern;
	(void) bid;
	throw(MAL, "pcre.select", "Library missing");
#else
	BAT *bn = NULL, *strs;
	str msg;

	if ((strs = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "pcre.select", "Cannot access descriptor");
	}

	if ((msg = pcre_select(&bn, *pattern, strs)) != MAL_SUCCEED) {
		BBPunfix(strs->batCacheid);
		return msg;
	}  

	*res = bn->batCacheid;
	BBPkeepref(bn->batCacheid);
	BBPunfix(strs->batCacheid);
	return msg;
#endif
}

str
PCREuselect(int *res, str *pattern, int *bid)
{
#ifndef HAVE_LIBPCRE
	(void) res;
	(void) pattern;
	(void) bid;
	throw(MAL, "pcre.select", "Library missing");
#else
	BAT *bn = NULL, *strs;
	str msg;

	if ((strs = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "pcre.select", "Cannot access descriptor");
	}

	if ((msg = pcre_uselect(&bn, *pattern, strs)) != MAL_SUCCEED) {
		BBPunfix(strs->batCacheid);
		return msg;
	}  

	*res = bn->batCacheid;
	BBPkeepref(bn->batCacheid);
	BBPunfix(strs->batCacheid);
	return msg;
#endif
}

str
PCREmatch(bit *ret, str *val, str *pat)
{
	return pcre_match(ret, *val, *pat);
}

str
PCREindex(int *res, pcre * pattern, str *s)
{
	return pcre_index(res, pattern, *s);
}


str
PCREpatindex(int *ret, str *pat, str *val)
{
	pcre *re = NULL;
	char *ppat, *msg;
	
	if (pat2pcre(&ppat, *pat) <0)
		throw(MAL, "pcre.sql2pcre", "Pattern convert failed");
	if ((msg = pcre_compile_wrap(&re, ppat)) != NULL)
		return msg;
	GDKfree(ppat);
	msg = PCREindex(ret, re, val);
	GDKfree(re);
	return msg;
}

str
PCREquote(str *ret, str *val)
{
	if (pcre_quote(ret, *val) <0)
		throw(MAL, "pcre.quote", "Quote failed");
	return MAL_SUCCEED;
}


str
PCREsql2pcre(str *ret, str *pat, str *esc)
{
	if (sql2pcre(ret, *pat, *esc) <0)
		throw(MAL, "pcre.sql2pcre", "Pattern convert failed");
	return MAL_SUCCEED;
} 

str
PCRElike3(bit *ret, str *s, str *pat, str *esc)
{
	char *ppat = NULL;
	str r = PCREsql2pcre(&ppat, pat, esc);

	if (!r) {
		if (strcmp(ppat, (char*)str_nil) == 0) {
			*ret = FALSE;
			if (strcmp(*s, *pat) == 0)
				*ret = TRUE;
		} else {
			r = PCREmatch(ret, s, &ppat);
		}
	}
	if (ppat)
		GDKfree(ppat);
	return r;
}

str
PCRElike2(bit *ret, str *s, str *pat)
{
	char *esc = "\\";

	return PCRElike3(ret, s, pat, &esc);
}

str
PCRElike_uselect_pcre(int *ret, int *b, str *pat, str *esc)
{
	char *ppat = NULL;
	str r = PCREsql2pcre(&ppat, pat, esc);

	if (!r) {
		if (strcmp(ppat, (char*)str_nil) == 0) {
			BAT *bp = BATdescriptor(*b);
			BAT *res = BATuselect(bp, *pat, *pat);
			
			*ret = res->batCacheid;
			BBPkeepref(res->batCacheid);
			BBPreleaseref(bp->batCacheid);
			r = MAL_SUCCEED;
		} else {
			r = PCREuselect(ret, &ppat, b);
		}
	}
	if (ppat)
		GDKfree(ppat);
	return r;
}  
@}
