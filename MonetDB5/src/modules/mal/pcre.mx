@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2006 CWI.
@' All Rights Reserved.

@f pcre
@a N. Nes
@t PCRE - Perl-compatible regular expressions
@v 0.1
@T
The  PCRE library is a set of functions that implement regular expres-
sion pattern matching using the same syntax  and  semantics  as  Perl,
with  just  a  few  differences.  The  current  implementation of PCRE
(release 4.x) corresponds approximately with Perl 5.8, including  sup-
port  for  UTF-8  encoded  strings.   However,  this support has to be
explicitly enabled; it is not the default.

\begin{center}
ftp://ftp.csx.cam.ac.uk/pub/software/programming/pcre
\end{center}
@include prelude.mx

@+ Module Definition
@mal
atom pcre:ptr;
command tostr()   address pcre_tostr;
command fromstr() address pcre_fromstr;
command nequal()  address pcre_nequal;
command hash()    address pcre_hash;
command null()    address pcre_null;
command put()     address pcre_put;
command del()     address pcre_del;
command length()  address pcre_length;
command heap()    address pcre_heap;

command compile(pat:str ) :pcre 
address PCREcompile_wrap
comment "compile a pattern";

command match(pat:pcre, s:str) :bit 
address PCREexec_wrap
comment "match a pattern";

command select(pat:str, strs:bat[:any_1,:str]) :bat[:any_1,:str] 
address PCREselect
comment "Select tuples based on the pattern";

command uselect(pat:str, strs:bat[:any_1,:str]) :bat[:any_1,:void] 
address PCREuselect
comment "Select tuples based on the pattern, only returning the head";

command match(s:str, pat:str):bit
address PCREmatch
comment "POSIX pattern matching against a string";

command replace(origin:str,pat:str,repl:str,flags:str):str
address PCREreplace_wrap
comment "Replace _all_ matches of \"pattern\" in \"origin_str\" with
	   \"replacement\".\n\
	 Parameter \"flags\" accept these flags: 'i', 'm', 's', and 'x'.\n
	   'e': if present, an empty string is considered to be a valid match
	   'i': if present, the match operates in case-insensitive mode. Otherwise, in\n
			case-sensitive mode.\n\
	 'm': if present, the match operates in multi-line mode.\n
	   's': if present, the match operates in \"dot-all\"
	   The specifications of the flags can be found in \"man pcreapi\"\n
	   The flag letters may be repeated.\n
	   No other letters than 'e', 'i', 'm', 's' and 'x' are allowed in \"flags\".\n
	   Returns the replaced string, or if no matches found, the original string.";

command replace(orig:bat[:any_1,:str],pat:str,repl:str,flag:str):bat[:any_1,:str]
address PCREreplace_bat_wrap;

command sql2pcre(pat:str,esc:str):str
address PCREsql2pcre
comment "Convert a SQL like pattern with the given escape character into a PCRE pattern.";

command like(s:str, pat:str, esc:str):bit 
address PCRElike3;

command like(s:str, pat:str):bit 
address PCRElike2;

command like(s:bat[:any_1,:str], pat:str, esc:str):bat[:any_1,:bit] 
address PCRElike_uselect_pcre;

pattern prelude():void 
address pcre_init
comment "Initialize pcre";

pcre.prelude();

@+ Implementation
@c
#include "mal.h"
#include "mal_exception.h"


#ifndef HAVE_LIBPCRE

#define pcre str
mal_export str PCREreplace_wrap(str *res, str *or, str *pat, str *repl, str *flags);
mal_export str PCREreplace_bat_wrap(int *res, int *or, str *pat, str *repl, str *flags);
mal_export str PCREcompile_wrap(pcre ** res, str *pattern);
mal_export str PCREexec_wrap(bit *res, pcre * pattern, str *s);
mal_export str PCREselect(int *res, str *pattern, int *bid);
mal_export str PCREmatch(bit *ret, str *val, str *pat);
mal_export str PCREfromstr(str instr, int *l, pcre ** val);
mal_export str PCREcompile_wrap(pcre ** res, str *pattern);
mal_export str PCREexec_wrap(bit *res, pcre * pattern, str *s);
mal_export str PCREselect(int *res, str *pattern, int *bid);
mal_export str PCREmatch(bit *ret, str *val, str *pat);
mal_export int pcre_tostr(str *tostr, int *l, pcre * p);
mal_export int pcre_fromstr(str instr, int *l, pcre ** val);
mal_export int pcre_nequal(pcre * l, pcre * r);
mal_export hash_t pcre_hash(pcre * b);
mal_export pcre * pcre_null(void);
mal_export void pcre_del(Heap *h, var_t *index);
mal_export int pcre_length(pcre * p);
mal_export void pcre_heap(Heap *heap, size_t capacity);
mal_export str PCREuselect(int *res, str *pattern, int *bid);
mal_export var_t pcre_put(Heap *h, var_t *bun, pcre * val);

int
pcre_compile_wrap(pcre ** res, str pattern)
{
	(void) res;
	(void) pattern;

	return GDK_FAIL;
}

int
pcre_exec_wrap(bit *res, pcre * pattern, str s)
{
	(void) res;
	(void) pattern;
	(void) s;

	return GDK_FAIL;
}

int
pcre_select(BAT **res, str pattern, BAT *strs)
{
	(void) res, (void) pattern;
	(void) strs;

	return GDK_FAIL;
}

int
pcre_uselect(BAT **res, str pattern, BAT *strs)
{
	(void) res, (void) pattern;
	(void) strs;

	return GDK_FAIL;
}

int
pcre_replace(str *res, str origin_str, str pattern, str replacement, str flags)
{
	(void) res;
	(void) origin_str;
	(void) pattern;
	(void) replacement;
	(void) flags;
	GDKerror("pcre_replace() not available as required version of libpcre was not found by configure.\n");
	return GDK_FAIL;
}

int
pcre_replace_bat(BAT **res, BAT *origin_strs, str pattern, str replacement, str flags)
{
	(void) res;
	(void) origin_strs;
	(void) pattern;
	(void) replacement;
	(void) flags;
	GDKerror("pcre_replace_bat() not available as required version of libpcre was not found by configure.\n");
	return GDK_FAIL;
}

str 
pcre_init(void)
{
	return NULL;
}

void
pcre_exit(void)
{
}

str
pcre_match(bit *ret, str *val, str *pat)
{
	(void) ret;
	(void) val;
	(void) pat;
	return throwMessage("pcre.select", "Library missing\n");
}
#else

#include <regex.h>
#include <pcre.h>

mal_export str PCREreplace_wrap(str *res, str *or, str *pat, str *repl, str *flags);
mal_export str PCREreplace_bat_wrap(int *res, int *or, str *pat, str *repl, str *flags);
mal_export str PCREcompile_wrap(pcre ** res, str *pattern);
mal_export str PCREexec_wrap(bit *res, pcre * pattern, str *s);
mal_export str PCREselect(int *res, str *pattern, int *bid);
mal_export str PCREmatch(bit *ret, str *val, str *pat);
mal_export str PCREfromstr(str instr, int *l, pcre ** val);
mal_export str PCREcompile_wrap(pcre ** res, str *pattern);
mal_export str PCREexec_wrap(bit *res, pcre * pattern, str *s);
mal_export str PCREselect(int *res, str *pattern, int *bid);
mal_export str PCREmatch(bit *ret, str *val, str *pat);
mal_export int pcre_tostr(str *tostr, int *l, pcre * p);
mal_export int pcre_fromstr(str instr, int *l, pcre ** val);
mal_export int pcre_nequal(pcre * l, pcre * r);
mal_export hash_t pcre_hash(pcre * b);
mal_export pcre * pcre_null(void);
mal_export void pcre_del(Heap *h, var_t *index);
mal_export int pcre_length(pcre * p);
mal_export void pcre_heap(Heap *heap, size_t capacity);

#define m2p(p) (pcre*)(((sht*)p)+1)
#define p2m(p) (pcre*)(((sht*)p)-1)

void *
my_pcre_malloc(size_t s)
{
	char *r = GDKmalloc(s + sizeof(sht));
	sht *sz = (sht *) r;

	*sz = s + sizeof(sht);
	return (void *) (sz + 1);
}

void
my_pcre_free(void *blk)
{
	sht *sz = (sht *) blk;

	sz -= 1;
	GDKfree((void *) sz);
}

int
pcre_compile_wrap(pcre ** res, str pattern)
{
	pcre *r;
	const char err[BUFSIZ], *err_p = err;
	int errpos = 0;

	if ((r = pcre_compile(pattern, PCRE_UTF8, &err_p, &errpos, NULL)) == NULL) {
		return GDK_FAIL;
	}
	*(pcre **) res = p2m(r);
	return GDK_SUCCEED;
}

int
pcre_exec_wrap(bit *res, pcre * pattern, str s)
{
	if (pcre_exec(m2p(pattern), NULL, s, strlen(s), 0, 0, NULL, 0) >= 0) {
		*res = TRUE;
	} else {
		*res = FALSE;
	}
	return GDK_SUCCEED;
}

int
pcre_select(BAT **res, str pattern, BAT *strs)
{
	const char err[BUFSIZ], *err_p = err;
	int errpos = 0;
	BAT *r;
	BUN p, q;
	pcre *re = NULL;

	if (strs->htype == TYPE_void)
		r = BATnew(TYPE_oid, TYPE_str, BATcount(strs));
	else
		r = BATnew(strs->htype, TYPE_str, BATcount(strs));
	if ((re = pcre_compile(pattern, PCRE_UTF8, &err_p, &errpos, NULL)) == NULL) {
		GDKerror("pcre_select: pcre compile of pattern (%s) failed at %d with\n'%s'.\n",
			pattern, errpos, err_p);
		return GDK_FAIL;
	}
	BATloop(strs, p, q) {
		str s = BUNtail(strs, p);

		if (pcre_exec(re, NULL, s, strlen(s), 0, 0, NULL, 0) >= 0) {
			BUNins(r, BUNhead(strs, p), s, FALSE);
		}
	}
	if (!(r->batDirty&2)) r = BATsetaccess(r, BAT_READ);
	my_pcre_free(re);
	*res = r;
	return GDK_SUCCEED;
}

int
pcre_uselect(BAT **res, str pattern, BAT *strs)
{
	const char err[BUFSIZ], *err_p = err;
	int errpos = 0;
	BAT *r;
	BUN p, q;
	pcre *re = NULL;

	if (strs->htype == TYPE_void)
		r = BATnew(TYPE_oid, TYPE_void, BATcount(strs));
	else
		r = BATnew(strs->htype, TYPE_void, BATcount(strs));
	if ((re = pcre_compile(pattern, PCRE_UTF8, &err_p, &errpos, NULL)) == NULL) {
		GDKerror("pcre_uselect: pcre compile of pattern (%s) failed at %d with\n'%s'.\n",
			pattern, errpos, err_p);
		return GDK_FAIL;
	}
	BATloop(strs, p, q) {
		str s = BUNtail(strs, p);

		if (pcre_exec(re, NULL, s, strlen(s), 0, 0, NULL, 0) >= 0) {
			BUNins(r, BUNhead(strs, p), NULL, FALSE);
		}
	}
	my_pcre_free(re);
	if (!(r->batDirty&2)) r = BATsetaccess(r, BAT_READ);
	*res = r;
	return GDK_SUCCEED;
}

#define MAX_NR_CAPTURES  1024 /* Maximal number of captured substrings in one original string */

int
pcre_replace(str *res, str origin_str, str pattern, str replacement, str flags)
{
	const char err[BUFSIZ], *err_p = err, *err_p2 = err;
	pcre *pcre_code = NULL;
	pcre_extra *extra;
	str tmpres;
	int i, j, k, len, errpos = 0, offset = 0;
	int compile_options = PCRE_UTF8, exec_options = PCRE_NOTEMPTY;
	int *ovector, ovecsize;
	int len_origin_str = strlen(origin_str);
	int len_replacement = strlen(replacement);
	int capture_offsets[MAX_NR_CAPTURES * 2], ncaptures = 0, len_del = 0;
	
	for (i = 0; i < (int)strlen(flags); i++) {
		if (flags[i] == 'e') {
			exec_options -= PCRE_NOTEMPTY;
			stream_printf(GDKout, "exec_options %d, PCRE_NOTEMPTY %d\n",
					exec_options, PCRE_NOTEMPTY);
		} else if (flags[i] == 'i') {
			compile_options |= PCRE_CASELESS;
		} else if (flags[i] == 'm') {
			compile_options |= PCRE_MULTILINE;
		} else if (flags[i] == 's') {
			compile_options |= PCRE_DOTALL;
		} else if (flags[i] == 'x') {
			compile_options |= PCRE_EXTENDED;
		} else {
			GDKerror("pcre_replace: \"flags\" contains invalid character '%c'\n", flags[i]);
			return GDK_FAIL;
		}
	}

	if ((pcre_code = pcre_compile(pattern, compile_options, &err_p, &errpos, NULL)) == NULL) {
		GDKerror("pcre_replace: pcre compile of pattern (%s) failed at %d with\n'%s'.\n", pattern, errpos, err_p);
		return GDK_FAIL;
	}

	/* Since the compiled pattern is going to be used several times, it is
	 * worth spending more time analyzing it in order to speed up the time
	 * taken for matching.
	 */
	extra = pcre_study(pcre_code, 0, &err_p2);
	pcre_fullinfo(pcre_code, extra, PCRE_INFO_CAPTURECOUNT, &i);
	ovecsize = (i + 1) * 3;
	if ((ovector = (int *) GDKmalloc(sizeof(int) * ovecsize)) == NULL) {
		GDKerror("pcre_replace: not enough memory\n");
		my_pcre_free(pcre_code);
		return GDK_FAIL;
	}
	
	i = 0;
	do {
		j = pcre_exec(pcre_code, extra, origin_str, len_origin_str, 
						offset, exec_options, ovector, ovecsize);
		if (j > 0){
			capture_offsets[i] = ovector[0];
			capture_offsets[i+1] = ovector[1];
			ncaptures++;
			i += 2;
			len_del += (ovector[1] - ovector[0]);
			offset = ovector[1];
		}
	} while((j > 0) && (offset < len_origin_str) && (ncaptures < MAX_NR_CAPTURES));
	
	if (ncaptures > 0){
		tmpres = GDKmalloc(len_origin_str - len_del + (len_replacement * ncaptures) + 1);
		if (!tmpres) {
			GDKerror("pcre_replace: not enough memory\n");
			my_pcre_free(pcre_code);
			GDKfree(ovector);
			return GDK_FAIL;
		}

		j = k = 0;

		/* possibly copy the substring before the first captured substring */
		strncpy(tmpres, origin_str, capture_offsets[j]); 
		k = capture_offsets[j];
		j++;

		for (i = 0; i < ncaptures - 1; i++) {
			strncpy(tmpres+k, replacement, len_replacement);
			k += len_replacement;
			/* copy the substring between two captured substrings */
			len = capture_offsets[j+1] - capture_offsets[j];
			strncpy(tmpres+k, origin_str+capture_offsets[j], len);
			k += len;
			j += 2;
		}

		/* replace the last captured substring */
		strncpy(tmpres+k, replacement, len_replacement);
		k += len_replacement;
		/* possibly copy the substring after the last captured substring */
		len = len_origin_str - capture_offsets[j];
		strncpy(tmpres+k, origin_str+capture_offsets[j], len);
		k += len;
		tmpres[k] = '\0';
	} else { /* no captured substrings, return the original string*/
		tmpres = GDKstrdup(origin_str);
	}

	my_pcre_free(pcre_code);
	GDKfree(ovector);
	*res = tmpres;
	return GDK_SUCCEED;
}

int
pcre_replace_bat(BAT **res, BAT *origin_strs, str pattern, str replacement, str flags)
{
	const char err[BUFSIZ], *err_p = err, *err_p2 = err;
	int i, j, k, len, errpos = 0, offset = 0;
	int compile_options = PCRE_UTF8, exec_options = PCRE_NOTEMPTY;
	pcre *pcre_code = NULL;
	pcre_extra *extra;
	BAT *tmpbat;
	BUN p, q;
	int *ovector, ovecsize;
	int len_origin_str, len_replacement = strlen(replacement);
	int capture_offsets[MAX_NR_CAPTURES * 2], ncaptures = 0, len_del = 0;
	str origin_str, replaced_str;

	for (i = 0; i < (int)strlen(flags); i++) {
		if (flags[i] == 'e') {
			exec_options |= (~PCRE_NOTEMPTY);
		} else if (flags[i] == 'i') {
			compile_options |= PCRE_CASELESS;
		} else if (flags[i] == 'm') {
			compile_options |= PCRE_MULTILINE;
		} else if (flags[i] == 's') {
			compile_options |= PCRE_DOTALL;
		} else if (flags[i] == 'x') {
			compile_options |= PCRE_EXTENDED;
		} else {
			GDKerror("pcre_replace_bat: \"flags\" contains invalid character '%c'\n", flags[i]);
			return GDK_FAIL;
		}
	}

	if ((pcre_code = pcre_compile(pattern, compile_options, &err_p, &errpos, NULL)) == NULL) {
		GDKerror("pcre_replace_bat: pcre compile of pattern (%s) failed at %d with\n'%s'.\n", pattern, errpos, err_p);
		return GDK_FAIL;
	}

	/* Since the compiled pattern is ging to be used several times, it is worth spending 
	 * more time analyzing it in order to speed up the time taken for matching.
	 */
	extra = pcre_study(pcre_code, 0, &err_p2);
	pcre_fullinfo(pcre_code, extra, PCRE_INFO_CAPTURECOUNT, &i);
	ovecsize = (i + 1) * 3;
	if ((ovector = (int *) GDKzalloc(sizeof(int) * ovecsize)) == NULL) {
		GDKerror("pcre_replace_bat: not enough memory\n");
		my_pcre_free(pcre_code);
		return GDK_FAIL;
	}
	
	tmpbat = BATnew(origin_strs->htype, TYPE_str, BATcount(origin_strs));
	BATloop(origin_strs, p, q) {
		origin_str = BUNtail(origin_strs, p);
		len_origin_str = strlen(origin_str);
		i = ncaptures = len_del = offset = 0;
		do {
			j = pcre_exec(pcre_code, extra, origin_str, len_origin_str, offset,
					exec_options, ovector, ovecsize);
			if (j > 0){
				capture_offsets[i] = ovector[0];
				capture_offsets[i+1] = ovector[1];
				ncaptures++;
				i += 2;
				len_del += (ovector[1] - ovector[0]);
				offset = ovector[1];
			}
		} while((j > 0) && (offset < len_origin_str) && (ncaptures < MAX_NR_CAPTURES));
	
		if (ncaptures > 0){
			replaced_str = GDKmalloc(len_origin_str - len_del + (len_replacement * ncaptures) + 1);
			if (!replaced_str) {
				GDKerror("pcre_replace_bat: not enough memory\n");
				my_pcre_free(pcre_code);
				GDKfree(ovector);
				return GDK_FAIL;
			}

			j = k = 0;

			/* copy eventually the substring before the first captured
			 * substring */
			strncpy(replaced_str, origin_str, capture_offsets[j]); 
			k = capture_offsets[j];
			j++;

			for (i = 0; i < ncaptures - 1; i++) {
				strncpy(replaced_str+k, replacement, len_replacement);
				k += len_replacement;
				/* copy the substring between two captured substrings */
				len = capture_offsets[j+1] - capture_offsets[j];
				strncpy(replaced_str+k, origin_str+capture_offsets[j], len);
				k += len;
				j += 2;
			}

			/* replace the last captured substring */
			strncpy(replaced_str+k, replacement, len_replacement);
			k += len_replacement;
			/* copy eventually the substring after the last captured substring */
			len = len_origin_str - capture_offsets[j];
			strncpy(replaced_str+k, origin_str+capture_offsets[j], len);
			k += len;
			replaced_str[k] = '\0';
			BUNins(tmpbat, BUNhead(origin_strs, p), replaced_str, FALSE);
			GDKfree(replaced_str);
		} else { /* no captured substrings, copy the original string into new bat */
			BUNins(tmpbat, BUNhead(origin_strs, p), origin_str, FALSE);
		}
	}

	my_pcre_free(pcre_code);
	GDKfree(ovector);
	if (origin_strs->htype == TYPE_void) {
		*res = BATseqbase(tmpbat, origin_strs->hseqbase);
	} else {
		*res = tmpbat;
	}
	return GDK_SUCCEED;
}

str 
pcre_init(void)
{
	pcre_malloc = &my_pcre_malloc;
	pcre_free = &my_pcre_free;
	return NULL;
}

void
pcre_exit(void)
{
}

str
pcre_match(bit *ret, str *val, str *pat)
{
	regex_t prg;
	int error = regcomp(&prg, *pat, REG_EXTENDED | REG_NOSUB);

	if (error < 0)
		return throwMessage("pcre.match", "Compilation of regular expression failed");
	error = regexec(&prg, *val, 0, 0, 0);
	*ret = (error == 0);
	return MAL_SUCCEED;
}
#endif

int
pcre_tostr(str *tostr, int *l, pcre * p)
{
	(void) tostr;
	(void) l;
	(void) p;
	return GDK_FAIL;
}

int
pcre_fromstr(str instr, int *l, pcre ** val)
{
	(void) l;
	return pcre_compile_wrap(val, instr);
}

int
pcre_nequal(pcre * l, pcre * r)
{
	if (l != r)
		return 0;
	else
		return 1;
}

hash_t
pcre_hash(pcre * b)
{
	return *(sht *) b;
}

pcre *
pcre_null(void)
{
	static sht nullval, *r;

	nullval = ~(sht) 0;
	r = &nullval;
	return ((pcre *) (r));
}

void
pcre_del(Heap *h, var_t *index)
{
	HEAP_free(h, *index);
}

#define pcresize(val) ((sht*)val)[0]

var_t
pcre_put(Heap *h, var_t *bun, pcre * val)
{
	char *base;

	*bun = HEAP_malloc(h, pcresize(val));
	base = h->base;
	if (*bun)
		memcpy(&base[*bun], (char *) val, pcresize(val));
	return *bun;
}

int
pcre_length(pcre * p)
{
	return (pcresize(p));
}

void
pcre_heap(Heap *heap, size_t capacity)
{
	HEAP_initialize(heap, capacity, 0, (int) sizeof(var_t));
}

/* change SQL LIKE pattern into PCRE pattern */
int
sql2pcre(str *r, str pat, str esc_str) 
{
	/* change the SQL wilcards into PCRE wildcards */
	int len = strlen(pat);
	int escaped = 0;
	int hasWildcard = 0;
	char *ppat = GDKmalloc(MAX(3,len*2)+1);
	int esc = esc_str[0]; /* should change to utf8_convert() */
	int specials = 0;

	*r = ppat;
	/*
	# the escape character can be a char which is special in a PCRE
	# if the user used the "+" char as escape and has "++" in
	# its pattern, then replacing this with "+" is not correct
	# but should be "\+"
	*/
	if (*esc_str && strchr( ".+*()[]", esc) != NULL) 
		specials = 1; 

	*ppat ++ = '^';
	while (*pat) {
		int c = *pat++;

		if (c == esc) {
			if (escaped) {
				if (specials) { /* change ++ into \\+ */
					*ppat++ = esc;
				} else { /* do not escape simple escape symbols */
					ppat[-1] = esc;
				}
				escaped = 0;
			} else {
				*ppat++ = '\\';
				escaped = 1;
			}
			/* not optimal but functional */
			hasWildcard = 1; 
		} else if (strchr( ".+*()[]\\", c) != NULL) {
			*ppat++ = '\\';
			*ppat++ = c;
			/* not optimal but functional */
			hasWildcard = 1; 
			escaped = 0;
		} else if (c == '%' && !escaped) {
			*ppat++ = '.';
			*ppat++ = '*';
			hasWildcard = 1;
		} else if (c == '_' && !escaped) {
			*ppat++ = '.';
			hasWildcard = 1;
		} else {
			*ppat++ = c;
			escaped = 0;
		}
	}
	/* no wildcard or escape character at end of string */
	if (!hasWildcard || escaped) {
		GDKfree(*r);
		*r = GDKstrdup(str_nil);
		if (escaped)
			return GDK_FAIL; 
	} else {
		*ppat++ = '$';
		*ppat = 0;
	}
	return GDK_SUCCEED; 
}
@+ Wrapping
@c
#include "mal.h"
str
PCREfromstr(str instr, int *l, pcre ** val)
{
	(void) instr;
	(void) l;
	(void) val;
	return NULL;
}

str
PCREreplace_wrap(str *res, str *or, str *pat, str *repl, str *flags){
	pcre_replace(res,*or,*pat,*repl,*flags);
	return MAL_SUCCEED;
}

str
PCREreplace_bat_wrap(int *res, int *bid, str *pat, str *repl, str *flags){
	BAT *b,*bn = NULL;
	if ((b = BATdescriptor(*bid)) == NULL)
		return throwMessage("pcre.replace", "Cannot access descriptor");

	pcre_replace_bat(&bn,b,*pat,*repl,*flags);
	*res= bn->batCacheid;
	BBPkeepref(*res);
	BBPunfix(b->batCacheid);
	return MAL_SUCCEED;
}

str
PCREcompile_wrap(pcre ** res, str *pattern)
{
	pcre_compile_wrap(res, *pattern);
	return MAL_SUCCEED;
}

str
PCREexec_wrap(bit *res, pcre * pattern, str *s)
{
#ifndef HAVE_LIBPCRE
	(void) res;
	(void) pattern;
	(void) s;
	return throwMessage("pcre.select", "Library missing");
#else
	pcre_exec_wrap(res, pattern, *s);
#endif
	return MAL_SUCCEED;
}

str
PCREselect(int *res, str *pattern, int *bid)
{
#ifndef HAVE_LIBPCRE
	(void) res;
	(void) pattern;
	(void) bid;
	return throwMessage("pcre.select", "Library missing");
#else
	BAT *bn, *strs;
	const char err[BUFSIZ], *err_p = err;
	int errpos = 0;
	BUN p, q;
	pcre *re = NULL;

	if ((strs = BATdescriptor(*bid)) == NULL) {
		return throwMessage("pcre.select", "Cannot access descriptor");
	}

	if (strs->htype == TYPE_void)
		bn = BATnew(TYPE_oid, TYPE_str, BATcount(strs));
	else
		bn = BATnew(strs->htype, TYPE_str, BATcount(strs));
	re = pcre_compile(*pattern, PCRE_UTF8, &err_p, &errpos, NULL);
	if (re == NULL)
		return throwMessage("pcre.select", "Pcre compile of pattern failed\n");

	BATloop(strs, p, q) {
		str s = BUNtail(strs, p);

		if (pcre_exec(re, NULL, s, strlen(s), 0, 0, NULL, 0) >= 0) {
			BUNins(bn, BUNhead(strs, p), s, FALSE);
		}
	}
	my_pcre_free(re);
	if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ);
	*res = bn->batCacheid;
	BBPkeepref(bn->batCacheid);
	BBPunfix(strs->batCacheid);
#endif
	return MAL_SUCCEED;
}

str
PCREuselect(int *res, str *pattern, int *bid)
{
#ifndef HAVE_LIBPCRE
	(void) res;
	(void) pattern;
	(void) bid;
	return throwMessage("pcre.select", "Library missing");
#else
	BAT *bn, *strs;
	const char err[BUFSIZ], *err_p = err;
	int errpos = 0;
	BUN p, q;
	pcre *re = NULL;

	if ((strs = BATdescriptor(*bid)) == NULL) {
		return throwMessage("pcre.select", "Cannot access descriptor");
	}
	if (strs->htype == TYPE_void)
		bn = BATnew(TYPE_oid, TYPE_void, BATcount(strs));
	else
		bn = BATnew(strs->htype, TYPE_void, BATcount(strs));
	re = pcre_compile(*pattern, PCRE_UTF8, &err_p, &errpos, NULL);
	if (re == NULL) {
		BBPunfix(strs->batCacheid);
		throwMessage("pcre.select", "Pcre compile of pattern failed");
		return GDK_FAIL;
	}

	BATloop(strs, p, q) {
		str s = BUNtail(strs, p);

		if (pcre_exec(re, NULL, s, strlen(s), 0, 0, NULL, 0) >= 0) {
			BUNins(bn, BUNhead(strs, p), NULL, FALSE);
		}
	}
	my_pcre_free(re);
	if (!(bn->batDirty&2)) bn = BATsetaccess(bn, BAT_READ);
	*res = bn->batCacheid;
	BBPkeepref(bn->batCacheid);
	BBPunfix(strs->batCacheid);
	return MAL_SUCCEED;
#endif
}

str
PCREmatch(bit *ret, str *val, str *pat)
{
	return pcre_match(ret, val, pat);
}

str
PCREsql2pcre(str *ret, str *pat, str *esc)
{
	if (sql2pcre(ret, *pat, *esc) == GDK_FAIL)
		throwMessage("pcre.sql2pcre", "Pattern convert failed");
	return MAL_SUCCEED;
} 

str
PCRElike3(bit *ret, str *s, str *pat, str *esc)
{
	char *ppat = NULL;
	str r = PCREsql2pcre(&ppat, pat, esc);

	if (!r) {
		if (strcmp(ppat,str_nil) == 0) {
			*ret = FALSE;
			if (strcmp(*s, *pat) == 0)
				*ret = TRUE;
		} else {
			r = pcre_match(ret, s, &ppat);
		}
	}
	if (ppat)
		GDKfree(ppat);
	return r;
}

str
PCRElike2(bit *ret, str *s, str *pat)
{
	char *esc = "\\";

	return PCRElike3(ret, s, pat, &esc);
}

str
PCRElike_uselect_pcre(int *ret, int *b, str *pat, str *esc)
{
	char *ppat = NULL;
	str r = PCREsql2pcre(&ppat, pat, esc);

	if (!r) {
		if (strcmp(ppat,str_nil) == 0) {
			BAT *bp = BATdescriptor(*b);
			BAT *res = BATuselect(bp, *pat, *pat);
			
			*ret = res->batCacheid;
			BBPkeepref(res->batCacheid);
			BBPreleaseref(bp->batCacheid);
			r = MAL_SUCCEED;
		} else {
			r = PCREuselect(ret, &ppat, b);
		}
	}
	if (ppat)
		GDKfree(ppat);
	return r;
}  

