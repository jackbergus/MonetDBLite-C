@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2005 CWI.
@' All Rights Reserved.

@f pcre
@a N. Nes
@t PCRE - Perl-compatible regular expressions
@v 0.1
@T
       The  PCRE library is a set of functions that implement regular expres-
       sion pattern matching using the same syntax  and  semantics  as  Perl,
       with  just  a  few  differences.  The  current  implementation of PCRE
       (release 4.x) corresponds approximately with Perl 5.8, including  sup-
       port  for  UTF-8  encoded  strings.   However,  this support has to be
       explicitly enabled; it is not the default.

\begin{center}
       ftp://ftp.csx.cam.ac.uk/pub/software/programming/pcre
\end{center}
@include prelude.mx

@+ Module Definition
@mal
atom pcre:ptr;
command tostr()   address pcre_tostr;
command fromstr() address pcre_fromstr;
command nequal()  address pcre_nequal;
command hash()    address pcre_hash;
command null()    address pcre_null;
command put()     address pcre_put;
command del()     address pcre_del;
command length()  address pcre_length;
command heap()    address pcre_heap;

command compile(pat:str ) :pcre 
address PCREcompile_wrap
comment "compile a pattern";

command match(pat:pcre, s:str) :bit 
address PCREexec_wrap
comment "match a pattern";

command select(pat:str, strs:bat[:any$1,:str]) :bat[:any$1,:str] 
address PCREselect
comment "Select tuples based on the pattern";

command uselect(pat:str, strs:bat[:any$1,:str]) :bat[:any$1,:void] 
address PCREuselect
comment "Select tuples based on the pattern, only returning the head";

command match(s:str, pat:str):bit
address PCREmatch
comment "POSIX pattern matching against a string";

@+ Implementation

@c
#include "mal.h"
#include "mal_exception.h"

#ifndef HAVE_LIBPCRE

#define pcre str

int
pcre_compile_wrap(pcre ** res, str pattern)
{
	(void) res;
	(void) pattern;
	return GDK_FAIL;
}

int
pcre_exec_wrap(bit *res, pcre * pattern, str s)
{
	(void) res;
	(void) pattern;
	(void) s;
	return GDK_FAIL;
}

int
pcre_select(BAT **res, str pattern, BAT *strs)
{
	(void) res, (void) pattern;
	(void) strs;
	return GDK_FAIL;
}

int
pcre_uselect(BAT **res, str pattern, BAT *strs)
{
	(void) res, (void) pattern;
	(void) strs;
	return GDK_FAIL;
}

bat *
pcre_init(void)
{
	return NULL;
}

void
pcre_exit(void)
{
}

str
pcre_match(bit *ret, str *val, str *pat)
{
	(void) ret;
	(void) val;
	(void) pat;
	return throwMessage("pcre_select", "library missing\n");
}
#else

#include <regex.h>
#include <pcre.h>

#define m2p(p) (pcre*)(((sht*)p)+1)
#define p2m(p) (pcre*)(((sht*)p)-1)

void *
my_pcre_malloc(size_t s)
{
	char *r = GDKmalloc(s + sizeof(sht));
	sht *sz = (sht *) r;

	*sz = s + sizeof(sht);
	return (void *) (sz + 1);
}

void
my_pcre_free(void *blk)
{
	sht *sz = (sht *) blk;

	sz -= 1;
	GDKfree((void *) sz);
}

int
pcre_compile_wrap(pcre ** res, str pattern)
{
	pcre *r;
	const char err[BUFSIZ], *err_p = err;
	int errpos = 0;

	if ((r = pcre_compile(pattern, PCRE_UTF8, &err_p, &errpos, NULL)) == NULL) {
		return GDK_FAIL;
	}
	*(pcre **) res = p2m(r);
	return GDK_SUCCEED;
}

int
pcre_exec_wrap(bit *res, pcre * pattern, str s)
{
	if (pcre_exec(m2p(pattern), NULL, s, strlen(s), 0, 0, NULL, 0) >= 0) {
		*res = TRUE;
	} else {
		*res = FALSE;
	}
	return GDK_SUCCEED;
}


bat *
pcre_init(void)
{
	pcre_malloc = &my_pcre_malloc;
	pcre_free = &my_pcre_free;
	return NULL;
}

void
pcre_exit(void)
{
}

str
pcre_match(bit *ret, str *val, str *pat)
{
	regex_t prg;
	int error = regcomp(&prg, *pat, REG_EXTENDED | REG_NOSUB);

	if (error < 0)
		return throwMessage("pcre.match", "Compilation of regular expression failed");
	error = regexec(&prg, *val, 0, 0, 0);
	*ret = (error == 0);
	return MAL_SUCCEED;
}
#endif

int
pcre_tostr(str *tostr, int *l, pcre * p)
{
	(void) tostr;
	(void) l;
	(void) p;
	return GDK_FAIL;
}

int
pcre_fromstr(str instr, int *l, pcre ** val)
{
	(void) l;
	return pcre_compile_wrap(val, instr);
}

int
pcre_nequal(pcre * l, pcre * r)
{
	if (l != r)
		return 0;
	else
		return 1;
}

hash_t
pcre_hash(pcre * b)
{
	return *(sht *) b;
}

pcre *
pcre_null(void)
{
	static sht nullval, *r;

	nullval = ~(sht) 0;
	r = &nullval;
	return ((pcre *) (r));
}

void
pcre_del(Heap *h, var_t *index)
{
	HEAP_free(h, *index);
}

#define pcresize(val) ((sht*)val)[0]

var_t
pcre_put(Heap *h, var_t *bun, pcre * val)
{
	char *base;

	*bun = HEAP_malloc(h, pcresize(val));
	base = h->base;
	if (*bun)
		memcpy(&base[*bun], (char *) val, pcresize(val));
	return *bun;
}

int
pcre_length(pcre * p)
{
	return (pcresize(p));
}

void
pcre_heap(Heap *heap, size_t capacity)
{
	HEAP_initialize(heap, capacity, 0, (int) sizeof(var_t));
}

@+ Wrapping
@c
#include "mal.h"
str
PCREfromstr(str instr, int *l, pcre ** val)
{
	(void) instr;
	(void) l;
	(void) val;
	return NULL;
}

str
PCREcompile_wrap(pcre ** res, str *pattern)
{
	pcre_compile_wrap(res, *pattern);
	return MAL_SUCCEED;
}

str
PCREexec_wrap(bit *res, pcre * pattern, str *s)
{
#ifndef HAVE_LIBPCRE
	(void) res;
	(void) pattern;
	(void) s;
	return throwMessage("pcre_select", "library missing\n");
#else
	pcre_exec_wrap(res, pattern, *s);
#endif
	return MAL_SUCCEED;
}

str
PCREselect(int *res, str *pattern, int *bid)
{
#ifndef HAVE_LIBPCRE
	(void) res;
	(void) pattern;
	(void) bid;
	return throwMessage("pcre_select", "library missing\n");
#else
	BAT *bn, *strs;
	const char err[BUFSIZ], *err_p = err;
	int errpos = 0;
	BUN p, q;
	pcre *re = NULL;

	if ((strs = BATdescriptor(*bid)) == NULL) {
		return throwMessage("pcre.select", "Cannot access descriptor");
	}

	if (strs->htype == TYPE_void)
		bn = BATnew(TYPE_oid, TYPE_str, BATcount(strs));
	else
		bn = BATnew(strs->htype, TYPE_str, BATcount(strs));
	re = pcre_compile(*pattern, PCRE_UTF8, &err_p, &errpos, NULL);
	if (re == NULL)
		return throwMessage("pcre_select", "pcre compile of pattern failed\n");

	BATloop(strs, p, q) {
		str s = BUNtail(strs, p);

		if (pcre_exec(re, NULL, s, strlen(s), 0, 0, NULL, 0) >= 0) {
			BUNins(bn, BUNhead(strs, p), s);
		}
	}
	my_pcre_free(re);
	BBPincref(*res = bn->batCacheid, TRUE);
	BBPunfix(bn->batCacheid);
	BBPunfix(strs->batCacheid);
#endif
	return MAL_SUCCEED;
}

str
PCREuselect(int *res, str *pattern, int *bid)
{
#ifndef HAVE_LIBPCRE
	(void) res;
	(void) pattern;
	(void) bid;
	return throwMessage("pcre_select", "library missing\n");
#else
	BAT *bn, *strs;
	const char err[BUFSIZ], *err_p = err;
	int errpos = 0;
	BUN p, q;
	pcre *re = NULL;

	if ((strs = BATdescriptor(*bid)) == NULL) {
		return throwMessage("pcre.select", "Cannot access descriptor");
	}
	if (strs->htype == TYPE_void)
		bn = BATnew(TYPE_oid, TYPE_void, BATcount(strs));
	else
		bn = BATnew(strs->htype, TYPE_void, BATcount(strs));
	re = pcre_compile(*pattern, PCRE_UTF8, &err_p, &errpos, NULL);
	if (re == NULL) {
		BBPunfix(strs->batCacheid);
		throwMessage("pcre_select", "pcre compile of pattern failed\n");
		return GDK_FAIL;
	}

	BATloop(strs, p, q) {
		str s = BUNtail(strs, p);

		if (pcre_exec(re, NULL, s, strlen(s), 0, 0, NULL, 0) >= 0) {
			BUNins(bn, BUNhead(strs, p), NULL);
		}
	}
	my_pcre_free(re);
	BBPincref(*res = bn->batCacheid, TRUE);
	BBPunfix(bn->batCacheid);
	BBPunfix(strs->batCacheid);
	return MAL_SUCCEED;
#endif
}

str
PCREmatch(bit *ret, str *val, str *pat)
{
	return pcre_match(ret, val, pat);
}
