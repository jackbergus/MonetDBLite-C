stdout of test 'mserver00` in directory 'src/modules/mal` itself:


# 23:07:54 >  
# 23:07:54 >  Mtimeout -timeout 60 mserver5 "--config=/ufs/mk/monet5/src/mal/Tests/All.conf" --debug=10 --set "monet_mod_path=/ufs/mk/monet5/Linux/lib/MonetDB5:/ufs/mk/opensource/MonetDB/Linux/lib/MonetDB" --set "gdk_dbfarm=/ufs/mk/monet5/Linux/var/MonetDB5/dbfarm" --set "sql_logdir=/ufs/mk/monet5/Linux/var/MonetDB5/dblogs" --set mapi_port=37461 --set monet_prompt= --trace --dbname=mTests_src_modules_kernel  mapi00.mal < /dev/null
# 23:07:54 >  

# Monet Database Server V4.99.19
# Copyright (c) 1993-2006, CWI. All rights reserved.
# Compiled for x86_64-redhat-linux-gnu/64bit with 64bit OIDs; dynamically linked.
# config:/ufs/mk/monet5/src/mal/Tests/All.conf
# dbfarm:/ufs/mk/monet5/Linux/var/MonetDB5/dbfarm
# dbname:mTests_src_modules_kernel
# Visit http://monetdb.cwi.nl/ for further information.
## Attempt to establish a client connection to yourself.
#
#z:= inspect.getEnvironment();
#ps:= algebra.find(z,"mapi_port");
#port:= calc.int(ps);
#hs:= algebra.find(z,"host");
#
## hardcoded, as access control currently works, and client.getInfo # doesn't
##u:= clients.getInfo();
##usr:= algebra.find(u,"user");
##pwd:= algebra.find(u,"password");
##lang:= algebra.find(u,"scenario");
#usr := "monetdb";
#pwd := "monetdb";
#lang := "mal";
#
## setup the session
#mid:= mapi.connect(hs,port,usr,pwd,lang);
#io.print(mid);
## retrieve data from the 'remote' site
## testing t:=1+3;
#mapi.query(mid, "t:= 1+3; io.print(t,\"hello\");");
#i:= mapi.get_row_count(mid);
#io.printf("rowcount %d\n",i);
#mapi.fetch_row(mid);
#i:= mapi.get_field_count(mid);
#io.printf("fieldcount %d\n",i);
#i:= mapi.fetch_field(mid,0);
#io.printf("field 0 %d\n",i);
#s:str:= mapi.fetch_field(mid,1);
#io.printf("field 1 %s\n",s);
#
#mapi.query(mid,"r:= bat.new(:oid,:int);");
#io.printf("shipped first query\n");
#mapi.query(mid,"bat.insert(r, 1@0,311);");
#mapi.query(mid,"bat.insert(r,2@0,433);");
#b:bat[:oid,:int]:= mapi.rpc(mid,"io.print(r);");
#io.print(b);
#
## use the BAT fetch operation
##b:bat[:oid,:int]:= mapi.receive(mid,"remotename");
#
#msg:str := mapi.rpc(mid,"io.print(\"hello world\");");
#io.print(msg);
#o:oid := mapi.rpc(mid,"io.print(34@0);");
#io.print(o);
#o:oid := mapi.rpc(mid,"io.print(nil:oid);");
#io.print(o);
#
##needs type checks
##(k:int,s:str):= mapi.rpc(mid,"io.print(nil:int,\"done\");");
##io.print(k,s);
#
## what is the relationship between local/remote namespace
## mapi.send(key,"a",a);
## c:= mapi.join(key,a,b);
## mapi.rpc(key,"z:=algebra.join(a,b);");
## c:= mapi.receive(key,"c")
#
##patterns
##pat:= "a:= algebra.select(b,?,?);");
##qry:=  str.replace(pat,"?",i,j);
##mapi.query(key,pat,i,j);
#
##how to ship a routine
##fcn:= manual.definition(manual,help);
#
## how to remote MAL execution
## remotedb:= mapi.connect(...)
## algebra.join@remotedb(a,b) using remote objects
## c:= mapi.rpc(remotedb,algebra,join,a,b)
#
## the remainder should be tested 
#catch MapiException:str;
#	io.printf("foutje:%s\n",MapiException);
#exit MapiException;
#mapi.disconnect(mid);
#
function user.main():void;              #  0 main:void {G}
# Attempt to establish a client connection to yourself. 
    z := inspect.getEnvironment();      #  2 z:bat[:str,:str] {G}
    ps := algebra.find(z,"mapi_port");  #  3 ps:str := ALGfind(z:bat[:str,:str], _4:str) {G}
    port := calc.int(ps);               #  4 port:int := CALCstr2int(ps:str) 
    hs := algebra.find(z,"host");       #  5 hs:str := ALGfind(z:bat[:str,:str], _7:str) {G}
# hardcoded, as access control currently works, and client.getInfo # doesn't 
#u:= clients.getInfo();
#usr:= algebra.find(u,"user");
#pwd:= algebra.find(u,"password");
#lang:= algebra.find(u,"scenario");
    usr := "monetdb";                   # 11 usr:str := _14:str {G}
    pwd := "monetdb";                   # 12 pwd:str := _14:str {G}
    lang := "mal";                      # 13 lang:str := _17:str {G}
# setup the session 
    mid := mapi.connect(hs,port,usr,pwd,lang);# 15 mid:int := SERVERconnect(hs:str, port:int, usr:str, pwd:str, lang:str) 
    io.print(mid);                      # 16 _20:void := IOprint_val(mid:int) 
# retrieve data from the 'remote' site 
# testing t:=1+3; 
    mapi.query(mid,"t:= 1+3; io.print(t,\"hello\");");# 19 _23:int := SERVERquery(mid:int, _24:str) 
    i := mapi.get_row_count(mid);       # 20 i:int := SERVERget_row_count(mid:int) 
    io.printf("rowcount %d\n",i);       # 21 _26:void := IOprint_formatted_int(_27:str, i:int) 
    mapi.fetch_row(mid);                # 22 _28:int := SERVERfetch_row(mid:int) 
    i := mapi.get_field_count(mid);     # 23 i:int := SERVERget_field_count(mid:int) 
    io.printf("fieldcount %d\n",i);     # 24 _29:void := IOprint_formatted_int(_30:str, i:int) 
    i := mapi.fetch_field(mid,0);       # 25 i:int := SERVERfetch_field_int(mid:int, _31:int) 
    io.printf("field 0 %d\n",i);        # 26 _32:void := IOprint_formatted_int(_33:str, i:int) 
    s:str  := mapi.fetch_field(mid,1);  # 27 s:str := SERVERfetch_field_str(mid:int, _35:int) {G}
    io.printf("field 1 %s\n",s);        # 28 _36:void := IOprint_formatted_str(_37:str, s:str) 
    mapi.query(mid,"r:= bat.new(:oid,:int);");# 29 _38:int := SERVERquery(mid:int, _39:str) 
    io.printf("shipped first query\n"); # 30 _40:void := IOprint_str(_41:str) 
    mapi.query(mid,"bat.insert(r, 1@0,311);");# 31 _42:int := SERVERquery(mid:int, _43:str) 
    mapi.query(mid,"bat.insert(r,2@0,433);");# 32 _44:int := SERVERquery(mid:int, _45:str) 
    b:bat[:oid,:int]  := mapi.rpc(mid,"io.print(r);");# 33 b:bat[:oid,:int] := SERVERmapi_rpc_bat(mid:int, _47:str) {G}
    io.print(b);                        # 34 _48:void := IOprint_val(b:bat[:oid,:int]) 
# use the BAT fetch operation 
#b:bat[:oid,:int]:= mapi.receive(mid,"remotename"); 
    msg:str  := mapi.rpc(mid,"io.print(\"hello world\");");# 37 msg:str := SERVERmapi_rpc_single_row(mid:int, _52:str) {G}
    io.print(msg);                      # 38 _53:void := IOprint_val(msg:str) 
    o:oid  := mapi.rpc(mid,"io.print(34@0);");# 39 o:oid := SERVERmapi_rpc_single_row(mid:int, _55:str) 
    io.print(o);                        # 40 _56:void := IOprint_val(o:oid) 
    o:oid  := mapi.rpc(mid,"io.print(nil:oid);");# 41 o:oid := SERVERmapi_rpc_single_row(mid:int, _57:str) 
    io.print(o);                        # 42 _58:void := IOprint_val(o:oid) 
#needs type checks 
#(k:int,s:str):= mapi.rpc(mid,"io.print(nil:int,\"done\");"); 
#io.print(k,s); 
# what is the relationship between local/remote namespace 
# mapi.send(key,"a",a); 
# c:= mapi.join(key,a,b); 
# mapi.rpc(key,"z:=algebra.join(a,b);"); 
# c:= mapi.receive(key,"c") 
#patterns 
#pat:= "a:= algebra.select(b,?,?);"); 
#qry:=  str.replace(pat,"?",i,j); 
#mapi.query(key,pat,i,j); 
#how to ship a routine 
#fcn:= manual.definition(manual,help); 
# how to remote MAL execution 
# remotedb:= mapi.connect(...) 
# algebra.join@remotedb(a,b) using remote objects 
# c:= mapi.rpc(remotedb,algebra,join,a,b) 
# the remainder should be tested  
catch MapiException:str ;               # 62 MapiException:str {J64}
    io.printf("foutje:%s\n",MapiException);# 63 _79:void := IOprint_formatted_str(_80:str, MapiException:str) 
exit MapiException:str ;                # 64 MapiException:str 
    mapi.disconnect(mid);               # 65 _81:void := SERVERdisconnect(mid:int) 
end main;	# 66  
[ 1 ]
rowcount 1
fieldcount 2
field 0 4
field 1 hello
shipped first query
#-----------------#
# h	t	  # name
# oid	int	  # type
#-----------------#
[ 1@0,	  311	  ]
[ 2@0,	  433	  ]
[ "hello world" ]
[ 34@0 ]
[ nil ]

# 23:07:54 >  
# 23:07:54 >  Done.
# 23:07:54 >  

