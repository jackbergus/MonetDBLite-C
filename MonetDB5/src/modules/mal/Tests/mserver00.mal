# Attempt to establish a client connection to yourself.

z:= inspect.getEnvironment();
ps:= algebra.find(z,"mapi_port");
port:= calc.int(ps);
hs:= algebra.find(z,"host");

# hardcoded, as access control currently works, and client.getInfo # doesn't
#u:= clients.getInfo();
#usr:= algebra.find(u,"user");
#pwd:= algebra.find(u,"password");
#lang:= algebra.find(u,"scenario");
usr := "monetdb";
pwd := "monetdb";
lang := "mal";

# setup the session
mid:= mserver.connect(hs,port,usr,pwd,lang);
io.print(mid);
# retrieve data from the 'remote' site
# testing t:=1+3;
t0:= alarm.usec();
mserver.query(mid, "t:= 1+3; io.print(t);");
t1:= alarm.usec();
t1:= t1-t0;
io.print(t1);

t0:= alarm.usec();
mserver.query(mid,"r:= bat.new(:oid,:int);");
mserver.query(mid,"bat.insert(r, 1@0,311);");
mserver.query(mid,"bat.insert(r,2@0,433);");
b:bat[:oid,:int]:= mserver.rpc(mid,"io.print(r);");
t1:= alarm.usec();
t1:= t1-t0;
#io.print(b);
io.print(t1);

# use the BAT fetch operation
#b:bat[:oid,:int]:= mserver.receive(mid,"remotename");

msg:str := mserver.rpc(mid,"io.print(\"hello world\");");
io.print(msg);
o:oid := mserver.rpc(mid,"io.print(34@0);");
io.print(o);
o:oid := mserver.rpc(mid,"io.print(nil:oid);");
io.print(o);

#needs type checks
#(k:int,s:str):= mserver.rpc(mid,"io.print(nil:int,\"done\");");
#io.print(k,s);

# what is the relationship between local/remote namespace
# mserver.send(key,"a",a);
# c:= mserver.join(key,a,b);
# mserver.rpc(key,"z:=algebra.join(a,b);");
# c:= mserver.receive(key,"c")

#patterns
#pat:= "a:= algebra.select(b,?,?);");
#qry:=  str.replace(pat,"?",i,j);
#mserver.query(key,pat,i,j);

#how to ship a routine
#fcn:= manual.definition(manual,help);

# how to remote MAL execution
# remotedb:= mserver.connect(...)
# algebra.join@remotedb(a,b) using remote objects
# c:= mserver.rpc(remotedb,algebra,join,a,b)

# the remainder should be tested 
catch MapiException:str;
	io.printf("foutje:%s\n",MapiException);
exit MapiException;
