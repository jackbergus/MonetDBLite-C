@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2006 CWI.
@' All Rights Reserved.
@f armada
@a Fabian Groffen
@+ Armada box
Implementation of the Armada model on M5.

The Armada model is a reference model for an evolving database system.
It allows to distribute meta-data on actual data distribution over a
number of participating sites, without fully replicating, nor by using a
central controlling entity.

The Armada module is implemented as a box; it contains a number of BATs
that describe the current state of the local mserver.  A few utility
functions allow for inspection, modification and querying of the trail
administration in the box.
@mal
include inet;

module armada;

#pattern open():void
#address ARMADAopen
#comment "Locate and open the Armada box";
#
#pattern close():void
#address ARMADAclose
#comment "Close the Armada box";
#
#pattern destroy():void
#address ARMADAdestroy
#comment "Destroy the Armada box (irreversible, use with caution!)";

command prelude()
address ARMADAprelude
comment "Initialise the armada module";

command epilogue()
address ARMADAepilogue
comment "Release the resources held by the armada module";


command addStep(func:str, site:inet):int
address ARMADAaddStep
comment "Adds a new step with func and site and returns its internal id";

command findStep(func:str, site:inet):int
address ARMADAfindStep
comment "Returns the internal step id for the given func and site or -1 if not found";

command addTrail(pre:int, step:int):int
address ARMADAaddTrail
comment "Adds a new trail based on the pre trail and step step, and returns the internal id";

command addTrail(steps:bat[:str,:str]):int
address ARMADAaddTrailBAT
comment "Adds the steps stored in the given BAT as trail and returns the internal id";

command getStep(step:int):str
address ARMADAgetStep
comment "Returns the string representation of the step with the given id";

command getTrail(trail:int):str
address ARMADAgetTrail
comment "Returns the string representation of the trail with the given id";

armada.prelude();

@- Implementation

@h

#ifndef _ARMADA_DEF
#define _ARMADA_DEF

#include "mal.h"
#include "mal_client.h"
#include "mal_interpreter.h"

#endif
@-

@c
#include "armada.h"
#include "mal_exception.h"
#include <inet.h>

mal_export str ARMADAprelude(int *ret);
mal_export str ARMADAepilogue(int *ret);

mal_export str ARMADAaddStep(int *ret, str *func, inet *site);
mal_export str ARMADAfindStep(int *ret, str *func, inet *site);
mal_export str ARMADAaddTrail(int *ret, int *pre, int *step);
mal_export str ARMADAaddTrailBAT(int *ret, int *steps);
mal_export str ARMADAgetStep(str *ret, int *step);
mal_export str ARMADAgetTrail(str *ret, int *trail);

static void ARMADAinit();
static void ARMADAexit();
static void ARMADAcommit();


str
ARMADAprelude(int *ret)
{
	(void)ret;
	ARMADAinit();

	return MAL_SUCCEED;
}

str
ARMADAepilogue(int *ret)
{
	(void)ret;
	ARMADAcommit();
	ARMADAexit();

	return MAL_SUCCEED;
}


BAT *ARMADA_func_site;
BAT *ARMADA_step_pre;
int  ARMADA_loaded;

/**
 * Creates a BAT with the given name, head and tail types and makes it
 * persistent.
 */
static BAT *
ARMADA_create(str hnme, str tnme, int ht, int tt)
{
	BAT *b;
	char buf[128];

	snprintf(buf, 128, "armada_%s_%s", hnme, tnme);
	b = BATdescriptor(BBPindex(buf));
	if (b)
		return b;

	b = BATnew(ht, tt, 256);
	if (b == NULL)
		GDKfatal("ARMADA_create: could not allocate.");

	BATkey(b, TRUE);
	BBPrename(b->batCacheid, buf);
	BATmode(b, PERSISTENT);
	BATcommit(b);
	return b;
}

/**
 * Loads or creates the Armada BATs, so that they can be used.
 */
static void
ARMADAinit()
{
	mal_set_lock(mal_contextLock, "armada");
	/* TODO: TYPE_lng -> TYPE_inet ??? */
	ARMADA_func_site = ARMADA_create("func", "site", TYPE_str, TYPE_lng);
	ARMADA_step_pre  = ARMADA_create("step", "pre", TYPE_int, TYPE_int);
	ARMADA_loaded    = 1;	/* yes, we have the BATs loaded */
	mal_unset_lock(mal_contextLock, "armada");
}

/**
 * Instructs the BBP to reclaim the Armada BATs.
 */
static void
ARMADAexit()
{
	mal_set_lock(mal_contextLock, "armada");
	if (ARMADA_loaded != 0) {
		/* the BATs *should* be there... */
		assert (ARMADA_func_site != NULL);
		assert (ARMADA_step_pre != NULL);

		BBPreclaim(ARMADA_func_site);
		BBPreclaim(ARMADA_step_pre);
		ARMADA_func_site = NULL;
		ARMADA_step_pre  = NULL;
		ARMADA_loaded    = 0;	/* BATs are unloaded now */
	}
	mal_unset_lock(mal_contextLock, "armada");
}

/**
 * Commits the Armada BATs and saves them to disk.  If this goes wrong
 * in the middle, I fear bad things are going to happen.
 */
static void
ARMADAcommit()
{
	mal_set_lock(mal_contextLock, "armada");
	if (ARMADA_loaded != 0) {
		/* the BATs *should* be there... */
		assert (ARMADA_func_site != NULL);
		assert (ARMADA_step_pre != NULL);

		BATcommit(ARMADA_func_site);
		BATsave(ARMADA_func_site);

		BATcommit(ARMADA_step_pre);
		BATsave(ARMADA_step_pre);
	}
	mal_unset_lock(mal_contextLock, "armada");
}

/**
 * Adds a new step to the Armada administration.  The id (position) of
 * the added step is returned.  All steps stored need to be unique.  If
 * the step already exists, it is not added, and the id of the already
 * existing step is returned.
 */
str
ARMADAaddStep(int *ret, str *func, inet *site) {
	BUN p;

	if (ARMADA_loaded == 0)
		throw("ArmadaException", "addStep", "Armada BATs not loaded");

	assert (ARMADA_func_site != NULL);

	/* see if the func/site already exists */
	p = BUNlocate(ARMADA_func_site, *func, site);
	if (!p) {
		/* apparently not, so let's add it */
		BUNins(ARMADA_func_site, *func, site);
		/* and look up the just added BUN */
		p = BUNlocate(ARMADA_func_site, *func, site);
	}
	*ret = BUNgetpos(ARMADA_func_site, p);

	return(MAL_SUCCEED);
}

/**
 * Returns the id (position) of the step with function func and site
 * site, if it exists.  Otherwise, -1 is returned.
 */
str
ARMADAfindStep(int *ret, str *func, inet *site) {
	BUN p;

	if (ARMADA_loaded == 0)
		throw("ArmadaException", "findStep", "Armada BATs not loaded");

	assert (ARMADA_func_site != NULL);

	/* lookup func/site and set retval appropriately */
	p = BUNlocate(ARMADA_func_site, *func, site);
	if (!p) {
		*ret = -1;
	} else {
		*ret = BUNgetpos(ARMADA_func_site, p);
	}

	return(MAL_SUCCEED);
}

/**
 * Adds a new trail based on the given parent trail and local step.
 */
str
ARMADAaddTrail(int *ret, int *pre, int *step) {
	BUN p;

	if (ARMADA_loaded == 0)
		throw("ArmadaException", "addTrail", "Armada BATs not loaded");

	assert (ARMADA_func_site != NULL);
	assert (ARMADA_step_pre != NULL);

	/* see if the step already exists */
	p = BUNfnd(ARMADA_step_pre, step);
	if (!p) {
		/* apparently not, so let's add it if the pre step is indeed
		 * existent */
		if (*pre != int_nil) {
			/* TODO: find out if this is not a leak; I suspect it is
			 *       somehow */
			p = BUNfnd(ARMADA_step_pre, pre);
			if (!p)
				throw("ArmadaException", "addTrail", "pointing to non-existant predecessor step");
		}
		BUNins(ARMADA_step_pre, step, pre);
		/* and look up the just added BUN */
		p = BUNlocate(ARMADA_step_pre, step, pre);
	} else {
		/* check that the pre matches... */
		if (*(int*)BUNtail(ARMADA_step_pre, p) != *pre)
			throw("ArmadaException", "addTrail", "step already exists, but with different predecessor");
	}
	*ret = BUNgetpos(ARMADA_step_pre, p);

	return(MAL_SUCCEED);
}

/**
 * Adds a new trail based on the given BAT with trail steps.  The first
 * BUN in the BAT is taken as the oldest step in the trail.  The BAT is
 * considered to have the functions in the head, and the sites in the
 * tail.
 */
str
ARMADAaddTrailBAT(int *ret, int *bat) {
	BAT *steps;
	BUN p, q;
	str func;
	inet site;
	str tmp;
	int idx, lastStep;

	if (ARMADA_loaded == 0)
		throw("ArmadaException", "addTrail", "Armada BATs not loaded");
	if ((steps = BATdescriptor(*bat)) == NULL)
		throw("ArmadaException", "addTrail", "steps BAT cannot be nil");

	/* Walk through the given BAT and add the steps to the
	 * administration.  Note, when this fails in the middle, we don't
	 * have a backup strategy.
	 */
	lastStep = int_nil;
	BATloop(steps, p, q) {
		func = (str)BUNhead(steps, p);
		site = *(inet*)BUNtail(steps, p);
		rethrow("addTrail", tmp, ARMADAaddStep(&idx, &func, &site));
		/* Now we have the id of the step, we can check whether it
		 * already is in the step/pre BAT, and add it otherwise.
		 * Failure here indicates an Armada inconsistency.
		 */
		rethrow("addTrail", tmp, ARMADAaddTrail(&idx, &lastStep, &idx));
		
		lastStep = idx;
	}

	*ret = lastStep;
	return(MAL_SUCCEED);
}

/**
 * Returns a string containing a serialised version of the step id.
 */
str
ARMADAgetStep(str *ret, int *step)
{
	BUN p;
	str func;
	inet site;
	int slen;
	str sstr;

	if (ARMADA_loaded == 0)
		throw("ArmadaException", "getStep", "Armada BATs not loaded");

	assert (ARMADA_func_site != NULL);

	if (*step < 0 || *step >= BATcount(ARMADA_func_site))
		throwf("ArmadaException", "getStep", "step id out of range: %d", *step);

	p = BUNfirst(ARMADA_func_site) + (BUNsize(ARMADA_func_site) * *step);
	func = (str)BUNhead(ARMADA_func_site, p);
	site = *(inet*)BUNtail(ARMADA_func_site, p);

	if (strNil(func)) func = "%";
	slen = 0;
	sstr = NULL;
	slen = INETtoString(&sstr, &slen, &site);

	/* What's the contract of ret here?  Should it contain enough space?
	 * Then we don't know how much (missing len).  Should it always be
	 * malloced?  Should it be freed when not NULL?  Always mallocing
	 * here for now.
	 */
	*ret = GDKmalloc(sizeof(str) *
			(1 + strlen(func) + 2 + slen + 1 + 1));
	sprintf(*ret, "[%s, %s]", func, sstr);
	return(MAL_SUCCEED);
}

/**
 * Returns a string containing a serialised version of the trail id.
 */
str
ARMADAgetTrail(str *ret, int *trail)
{
	BUN p;
	int idx;
	str tmp;
	str buf;
	str stepBuf;

	if (ARMADA_loaded == 0)
		throw("ArmadaException", "getTrail", "Armada BATs not loaded");

	assert (ARMADA_step_pre != NULL);

	if (*trail < 0 || *trail >= BATcount(ARMADA_step_pre))
		throwf("ArmadaException", "getTrail", "trail id out of range: %d", *trail);

	/* The step_pre BAT is actually representing a tree, where the pre
	 * is just a pointer to the id of the predecessor trail, which
	 * itself is just formed of a step and it's predecessor trail again.
	 * We go chasing pointers this way as long as we don't encounter a
	 * predecessor that is nil.
	 */

	idx = *trail;
	buf = NULL;
	do {
		p = BUNfirst(ARMADA_step_pre) + (BUNsize(ARMADA_step_pre) * idx);
		rethrow("getTrail", tmp, ARMADAgetStep(&stepBuf, &idx));
		/* ok, hopelessly inefficient implementation here, but who cares
		 * (for now, hopefully) */
		if (buf == NULL) {
			buf = stepBuf;
		} else {
			str oldBuf = buf;
			buf = GDKmalloc(sizeof(str) *
					(strlen(stepBuf) + 1 + strlen(oldBuf) + 1));
			sprintf(buf, "%s.%s", stepBuf, oldBuf);
			GDKfree(stepBuf);
			GDKfree(oldBuf);
		}
		idx = *(int*)BUNtail(ARMADA_step_pre, p);
	} while (idx != int_nil);

	*ret = buf;
	return(MAL_SUCCEED);
}
