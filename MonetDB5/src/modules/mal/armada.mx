@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2006 CWI.
@' All Rights Reserved.

@f armada
@a Fabian Groffen
@+ Armada box
Implementation of the Armada model on M5.

The Armada model is a reference model for an evolving database system.
It allows to distribute meta-data on actual data distribution over a
number of participating sites, without fully replicating, nor by using a
central controlling entity.

The Armada module is implemented as a box; it contains a number of BATs
that describe the current state of the local mserver.  A few utility
functions allow for inspection, modification and querying of the trail
administration in the box.
@mal
module armada;

#pattern open():void
#address ARMADAopen
#comment "Locate and open the Armada box";
#
#pattern close():void
#address ARMADAclose
#comment "Close the Armada box";
#
#pattern destroy():void
#address ARMADAdestroy
#comment "Destroy the Armada box (irreversible, use with caution!)";

command prelude()
address ARMADAprelude
comment "Initialise the armada module";

command epilogue()
address ARMADAepilogue
comment "Release the resources held by the armada module";


command addStep(func:str, site:oid):int
address ARMADAaddStep
comment "Adds a new step with func and site and returns its internal id";

command findStep(func:str, site:oid):int
address ARMADAfindStep
comment "Returns the internal step id for the given func and site or -1 if not found";

command addTrail(pre:int, step:int):int
address ARMADAaddTrail
comment "Adds a new trail based on the pre trail and step step, and returns the internal id";

command addTrail(steps:bat[:str,:oid]):int
address ARMADAaddTrailBAT
comment "Adds the steps stored in the given BAT as trail and returns the internal id";

command getStep(step:int):str
address ARMADAgetStep
comment "Returns the string representation of the step with the given id";

command getTrail(trail:int):str
address ARMADAgetTrail
comment "Returns the string representation of the trail with the given id";

command addSite(host:inet, port:int, chain:str, key:str):oid
address ARMADAaddSite
comment "Adds a new site and returns its oid";

command findSite(host:inet, port:int, chain:str):oid
address ARMADAfindSite
comment "Returns the oid for the given site";

armada.prelude();

@- Implementation

@h

#ifndef _ARMADA_DEF
#define _ARMADA_DEF

#include <mal.h>
#include <mal_client.h>
#include <mal_interpreter.h>

#endif
@-

@c
#include "armada.h"
#include <mal_exception.h>
#include <inet.h>

#ifdef WIN32
#ifndef LIBARMADA
#define armada_export extern __declspec(dllimport)
#else
#define armada_export extern __declspec(dllexport)
#endif
#else
#define armada_export extern
#endif

armada_export str ARMADAprelude(int *ret);
armada_export str ARMADAepilogue(int *ret);

armada_export str ARMADAaddStep(int *ret, str *func, oid *site);
armada_export str ARMADAfindStep(int *ret, str *func, oid *site);
armada_export str ARMADAaddTrail(int *ret, int *pre, int *step);
armada_export str ARMADAaddTrailBAT(int *ret, int *steps);
armada_export str ARMADAgetStep(str *ret, int *step);
armada_export str ARMADAgetTrail(str *ret, int *trail);
armada_export str ARMADAaddSite(oid *ret, inet *host, int *port, str *chain, str *key);
armada_export str ARMADAfindSite(oid *ret, inet *host, int *port, str *chain);

static void ARMADAinit(void);
static void ARMADAexit(void);
static void ARMADAcommit(void);


str
ARMADAprelude(int *ret)
{
	(void)ret;
	ARMADAinit();

	return MAL_SUCCEED;
}

str
ARMADAepilogue(int *ret)
{
	(void)ret;
	ARMADAcommit();
	ARMADAexit();

	return MAL_SUCCEED;
}


BAT *ARMADA_func_site;
BAT *ARMADA_step_pre;
BAT *ARMADA_site_host;
BAT *ARMADA_site_port;
BAT *ARMADA_site_chain;
BAT *ARMADA_site_key;
int  ARMADA_loaded;

/**
 * Creates a BAT with the given name, head and tail types and makes it
 * persistent.
 */
static BAT *
ARMADA_create(str hnme, str tnme, int ht, int tt)
{
	BAT *b;
	char buf[128];

	snprintf(buf, 128, "armada_%s_%s", hnme, tnme);
	b = BATdescriptor(BBPindex(buf));
	if (b)
		return b;

	b = BATnew(ht, tt, 256);
	if (b == NULL)
		GDKfatal("ARMADA_create: could not allocate.");

	BATkey(b, TRUE);
	BBPrename(b->batCacheid, buf);
	BATmode(b, PERSISTENT);
	BATcommit(b);
	return b;
}

/**
 * Loads or creates the Armada BATs, so that they can be used.
 */
static void
ARMADAinit()
{
	mal_set_lock(mal_contextLock, "armada");
	ARMADA_func_site  = ARMADA_create("func", "site",  TYPE_str, TYPE_oid);
	ARMADA_step_pre   = ARMADA_create("step", "pre",   TYPE_int, TYPE_int);
	ARMADA_site_host  = ARMADA_create("site", "host",  TYPE_oid, ATOMindex("inet"));
	ARMADA_site_port  = ARMADA_create("site", "port",  TYPE_oid, TYPE_int);
	ARMADA_site_chain = ARMADA_create("site", "chain", TYPE_oid, TYPE_str);
	ARMADA_site_key   = ARMADA_create("site", "key",   TYPE_oid, TYPE_str);
	ARMADA_loaded     = 1;	/* yes, we have the BATs loaded */
	mal_unset_lock(mal_contextLock, "armada");
}

/**
 * Instructs the BBP to reclaim the Armada BATs.
 */
static void
ARMADAexit()
{
	mal_set_lock(mal_contextLock, "armada");
	if (ARMADA_loaded != 0) {
		/* the BATs *should* be there... */
		assert (ARMADA_func_site != NULL);
		assert (ARMADA_step_pre != NULL);
		assert (ARMADA_site_host != NULL);
		assert (ARMADA_site_port != NULL);
		assert (ARMADA_site_chain != NULL);
		assert (ARMADA_site_key != NULL);

		BBPreclaim(ARMADA_func_site);
		BBPreclaim(ARMADA_step_pre);
		BBPreclaim(ARMADA_site_host);
		BBPreclaim(ARMADA_site_port);
		BBPreclaim(ARMADA_site_chain);
		BBPreclaim(ARMADA_site_key);
		ARMADA_func_site  = NULL;
		ARMADA_step_pre   = NULL;
		ARMADA_site_host  = NULL;
		ARMADA_site_port  = NULL;
		ARMADA_site_chain = NULL;
		ARMADA_site_key   = NULL;
		ARMADA_loaded     = 0;	/* BATs are unloaded now */
	}
	mal_unset_lock(mal_contextLock, "armada");
}

/**
 * Commits the Armada BATs and saves them to disk.  If this goes wrong
 * in the middle, I fear bad things are going to happen.
 */
static void
ARMADAcommit()
{
	mal_set_lock(mal_contextLock, "armada");
	if (ARMADA_loaded != 0) {
		/* the BATs *should* be there... */
		assert (ARMADA_func_site != NULL);
		assert (ARMADA_step_pre != NULL);
		assert (ARMADA_site_host != NULL);
		assert (ARMADA_site_port != NULL);
		assert (ARMADA_site_chain != NULL);
		assert (ARMADA_site_key != NULL);

		BATcommit(ARMADA_func_site);
		BATcommit(ARMADA_step_pre);
		BATcommit(ARMADA_site_host);
		BATcommit(ARMADA_site_port);
		BATcommit(ARMADA_site_chain);
		BATcommit(ARMADA_site_key);

		BATsave(ARMADA_func_site);
		BATsave(ARMADA_step_pre);
		BATsave(ARMADA_site_host);
		BATsave(ARMADA_site_port);
		BATsave(ARMADA_site_chain);
		BATsave(ARMADA_site_key);
	}
	mal_unset_lock(mal_contextLock, "armada");
}

/**
 * Adds a new site to the Armada administration and returns its oid.  If
 * there already exists a site with the given values and exception is
 * thrown.
 */
str
ARMADAaddSite(oid *ret, inet *host, int *port, str *chain, str *key) {
	str tmp;
	oid id;
	
	if (ARMADA_loaded == 0)
		throw("ArmadaException", "addSite", "Armada BATs not loaded");
	if (host == NULL || in_isnil(host))
		throw("ArmadaException", "addSite", "host cannot be nil");
	if (port == NULL || *port == int_nil)
		throw("ArmadaException", "addSite", "port cannot be nil");
	if (chain == NULL || strcmp(*chain, str_nil) == 0)
		throw("ArmadaException", "addSite", "chain cannot be nil");
	if (chain == NULL || strcmp(*key, str_nil) == 0)
		throw("ArmadaException", "addSite", "key cannot be nil");
	rethrow("addSite", tmp, ARMADAfindSite(&id, host, port, chain));
	if (id != oid_nil)
		throw("ArmadaException", "addSite", "Site already exists (possibly with a different key)");

	mal_set_lock(mal_contextLock, "armada");
	/* TODO: get the oid and use it with BUNins, then return that oid */
	BUNappend(ARMADA_site_host, host, FALSE);
	BUNappend(ARMADA_site_port, port, FALSE);
	BUNappend(ARMADA_site_chain, *chain, FALSE);
	BUNappend(ARMADA_site_key, *key, FALSE);
	mal_unset_lock(mal_contextLock, "armada");

	rethrow("addSite", tmp, ARMADAfindSite(ret, host, port, chain));

	return(MAL_SUCCEED);
}

/**
 * Returns the site oid for the site with the given characteristics.  If
 * the site is not known, oid_nil is returned.
 */
str
ARMADAfindSite(oid *ret, inet *host, int *port, str *chain) {
	BUN p;

	*ret = oid_nil;
	if (
			(p = BUNfnd(BATmirror(ARMADA_site_host), host)) != NULL &&
			(p = BUNfnd(BATmirror(ARMADA_site_port), port)) != NULL &&
			(p = BUNfnd(BATmirror(ARMADA_site_chain), *chain)) != NULL
	) {
		*ret = *((oid*)BUNhead(ARMADA_site_chain, p));
	}

	return(MAL_SUCCEED);
}

/**
 * Adds a new step to the Armada administration.  The id (position) of
 * the added step is returned.  All steps stored need to be unique.  If
 * the step already exists, it is not added, and the id of the already
 * existing step is returned.
 */
str
ARMADAaddStep(int *ret, str *func, oid *site) {
	BUN p;

	if (ARMADA_loaded == 0)
		throw("ArmadaException", "addStep", "Armada BATs not loaded");

	assert (ARMADA_func_site != NULL);

	/* see if the func/site already exists */
	p = BUNlocate(ARMADA_func_site, *func, site);
	if (!p) {
		/* apparently not, so let's add it */
		BUNins(ARMADA_func_site, *func, site, FALSE);
		/* and look up the just added BUN */
		p = BUNlocate(ARMADA_func_site, *func, site);
	}
	*ret = BUNgetpos(ARMADA_func_site, p);

	return(MAL_SUCCEED);
}

/**
 * Returns the id (position) of the step with function func and site
 * site, if it exists.  Otherwise, -1 is returned.
 */
str
ARMADAfindStep(int *ret, str *func, oid *site) {
	BUN p;

	if (ARMADA_loaded == 0)
		throw("ArmadaException", "findStep", "Armada BATs not loaded");

	assert (ARMADA_func_site != NULL);

	/* lookup func/site and set retval appropriately */
	p = BUNlocate(ARMADA_func_site, *func, site);
	if (!p) {
		*ret = -1;
	} else {
		*ret = BUNgetpos(ARMADA_func_site, p);
	}

	return(MAL_SUCCEED);
}

/**
 * Adds a new trail based on the given parent trail and local step.
 */
str
ARMADAaddTrail(int *ret, int *pre, int *step) {
	BUN p;

	if (ARMADA_loaded == 0)
		throw("ArmadaException", "addTrail", "Armada BATs not loaded");

	assert (ARMADA_func_site != NULL);
	assert (ARMADA_step_pre != NULL);

	/* see if the step already exists */
	p = BUNfnd(ARMADA_step_pre, step);
	if (!p) {
		/* apparently not, so let's add it if the pre step is indeed
		 * existent */
		if (*pre != int_nil) {
			/* TODO: find out if this is not a leak; I suspect it is
			 *       somehow */
			p = BUNfnd(ARMADA_step_pre, pre);
			if (!p)
				throw("ArmadaException", "addTrail", "pointing to non-existant predecessor step");
		}
		BUNins(ARMADA_step_pre, step, pre, FALSE);
		/* and look up the just added BUN */
		p = BUNlocate(ARMADA_step_pre, step, pre);
	} else {
		/* check that the pre matches... */
		if (*(int*)BUNtail(ARMADA_step_pre, p) != *pre)
			throw("ArmadaException", "addTrail", "step already exists, but with different predecessor");
	}
	*ret = BUNgetpos(ARMADA_step_pre, p);

	return(MAL_SUCCEED);
}

/**
 * Adds a new trail based on the given BAT with trail steps.  The first
 * BUN in the BAT is taken as the oldest step in the trail.  The BAT is
 * considered to have the functions in the head, and the sites in the
 * tail.
 */
str
ARMADAaddTrailBAT(int *ret, int *bat) {
	BAT *steps;
	BUN p, q;
	str func;
	oid site;
	str tmp;
	int idx, lastStep;

	if (ARMADA_loaded == 0)
		throw("ArmadaException", "addTrail", "Armada BATs not loaded");
	if ((steps = BATdescriptor(*bat)) == NULL)
		throw("ArmadaException", "addTrail", "steps BAT cannot be nil");

	/* Walk through the given BAT and add the steps to the
	 * administration.  Note, when this fails in the middle, we don't
	 * have a backup strategy.
	 */
	lastStep = int_nil;
	BATloop(steps, p, q) {
		func = (str)BUNhead(steps, p);
		site = *(oid*)BUNtail(steps, p);
		rethrow("addTrail", tmp, ARMADAaddStep(&idx, &func, &site));
		/* Now we have the id of the step, we can check whether it
		 * already is in the step/pre BAT, and add it otherwise.
		 * Failure here indicates an Armada inconsistency.
		 */
		rethrow("addTrail", tmp, ARMADAaddTrail(&idx, &lastStep, &idx));
		
		lastStep = idx;
	}

	*ret = lastStep;
	return(MAL_SUCCEED);
}

/**
 * Returns a string containing a serialised version of the step id.
 */
str
ARMADAgetStep(str *ret, int *step)
{
	BUN p;
	str func;
	oid site;

	if (ARMADA_loaded == 0)
		throw("ArmadaException", "getStep", "Armada BATs not loaded");

	assert (ARMADA_func_site != NULL);

	if (*step < 0 || *step >= BATcount(ARMADA_func_site))
		throwf("ArmadaException", "getStep", "step id out of range: %d", *step);

	p = BUNfirst(ARMADA_func_site) + (BUNsize(ARMADA_func_site) * *step);
	func = (str)BUNhead(ARMADA_func_site, p);
	site = *(oid*)BUNtail(ARMADA_func_site, p);

	if (strNil(func)) func = "#";

	/* What's the contract of ret here?  Should it contain enough space?
	 * Then we don't know how much (missing len).  Should it always be
	 * malloced?  Should it be freed when not NULL?  Always mallocing
	 * here for now.
	 */
	*ret = GDKmalloc(sizeof(str) *
			(1 + strlen(func) + 2 + 19 + 1 + 1));
	sprintf(*ret, "[%s, " OIDFMT "]", func, site);
	return(MAL_SUCCEED);
}

/**
 * Returns a string containing a serialised version of the trail id.
 */
str
ARMADAgetTrail(str *ret, int *trail)
{
	BUN p;
	int idx;
	str tmp;
	str buf;
	str stepBuf;

	if (ARMADA_loaded == 0)
		throw("ArmadaException", "getTrail", "Armada BATs not loaded");

	assert (ARMADA_step_pre != NULL);

	if (*trail < 0 || *trail >= BATcount(ARMADA_step_pre))
		throwf("ArmadaException", "getTrail", "trail id out of range: %d", *trail);

	/* The step_pre BAT is actually representing a tree, where the pre
	 * is just a pointer to the id of the predecessor trail, which
	 * itself is just formed of a step and it's predecessor trail again.
	 * We go chasing pointers this way as long as we don't encounter a
	 * predecessor that is nil.
	 */

	idx = *trail;
	buf = NULL;
	do {
		p = BUNfirst(ARMADA_step_pre) + (BUNsize(ARMADA_step_pre) * idx);
		rethrow("getTrail", tmp, ARMADAgetStep(&stepBuf, &idx));
		/* ok, hopelessly inefficient implementation here, but who cares
		 * (for now, hopefully) */
		if (buf == NULL) {
			buf = stepBuf;
		} else {
			str oldBuf = buf;
			buf = GDKmalloc(sizeof(str) *
					(strlen(stepBuf) + 1 + strlen(oldBuf) + 1));
			sprintf(buf, "%s.%s", stepBuf, oldBuf);
			GDKfree(stepBuf);
			GDKfree(oldBuf);
		}
		idx = *(int*)BUNtail(ARMADA_step_pre, p);
	} while (idx != int_nil);

	*ret = buf;
	return(MAL_SUCCEED);
}
