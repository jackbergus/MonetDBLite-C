@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2006 CWI.
@' All Rights Reserved.
@f armada
@a Fabian Groffen
@+ Armada box
Implementation of the Armada model on M5.

The Armada model is a reference model for an evolving database system.
It allows to distribute meta-data on actual data distribution over a
number of participating sites, without fully replicating, nor by using a
central controlling entity.

The Armada module is implemented as a box; it contains a number of BATs
that describe the current state of the local mserver.  A few utility
functions allow for inspection, modification and querying of the trail
administration in the box.
@mal
module armada;

#pattern open():void
#address ARMADAopen
#comment "Locate and open the Armada box";
#
#pattern close():void
#address ARMADAclose
#comment "Close the Armada box";
#
#pattern destroy():void
#address ARMADAdestroy
#comment "Destroy the Armada box (irreversible, use with caution!)";

command prelude()
address ARMADAprelude
comment "Initialise the armada module";

command epilogue()
address ARMADAepilogue
comment "Release the resources held by the armada module";


command addStep(func:str, site:str):int
address ARMADAaddStep
comment "Adds a new step with func and site and returns its internal id";

command findStep(func:str, site:str):int
address ARMADAfindStep
comment "Returns the internal step id for the given func and site or -1 if not found";

command addTrail(pre:int, step:int):int
address ARMADAaddTrail
comment "Adds a new trail based on the pre trail and step step, and returns the internal id";

command addTrail(steps:bat[:str,:str]):int
address ARMADAaddTrailBAT
comment "Adds the steps stored in the given BAT as trail and returns the internal id";

armada.prelude();

@- Implementation

@h

#ifndef _ARMADA_DEF
#define _ARMADA_DEF

#include "mal.h"
#include "mal_client.h"
#include "mal_interpreter.h"

#endif
@-

@c
#include "armada.h"
#include "mal_exception.h"

mal_export str ARMADAprelude(int *ret);
mal_export str ARMADAepilogue(int *ret);

mal_export str ARMADAaddStep(int *ret, str *func, str *site);
mal_export str ARMADAfindStep(int *ret, str *func, str *site);
mal_export str ARMADAaddTrail(int *ret, int *pre, int *step);
mal_export str ARMADAaddTrailBAT(int *ret, int *steps);

static void ARMADAinit();
static void ARMADAexit();


str
ARMADAprelude(int *ret)
{
	(void)ret;
	ARMADAinit();

	return MAL_SUCCEED;
}

str
ARMADAepilogue(int *ret)
{
	(void)ret;
	ARMADAexit();

	return MAL_SUCCEED;
}


BAT *ARMADA_func_site;
BAT *ARMADA_step_pre;
int  ARMADA_loaded;

/**
 * Creates a BAT with the given name, head and tail types and makes it
 * persistent.
 */
static BAT *
ARMADA_create(str hnme, str tnme, int ht, int tt)
{
	BAT *b;
	char buf[128];

	snprintf(buf, 128, "armada_%s_%s", hnme, tnme);
	b = BATdescriptor(BBPindex(buf));
	if (b)
		return b;

	b = BATnew(ht, tt, 256);
	if (b == NULL)
		GDKfatal("ARMADA_create: could not allocate.");

	BATkey(b, TRUE);
	BBPrename(b->batCacheid, buf);
	BATmode(b, PERSISTENT);
	BATcommit(b);
	return b;
}

/**
 * Loads or creates the Armada BATs, so that they can be used.
 */
static void
ARMADAinit()
{
	mal_set_lock(mal_contextLock, "armada");
	ARMADA_func_site = ARMADA_create("func", "site", TYPE_str, TYPE_str);
	ARMADA_step_pre  = ARMADA_create("step", "pre", TYPE_oid, TYPE_oid);
	ARMADA_loaded    = 1;	/* yes, we have the BATs loaded */
	mal_unset_lock(mal_contextLock, "armada");
}

/**
 * Instructs the BBP to reclaim the Armada BATs.
 */
static void
ARMADAexit()
{
	mal_set_lock(mal_contextLock, "armada");
	if (ARMADA_loaded != 0) {
		/* the BATs *should* be there... */
		assert (ARMADA_func_site != NULL);
		assert (ARMADA_step_pre != NULL);

		BBPreclaim(ARMADA_func_site);
		BBPreclaim(ARMADA_step_pre);
		ARMADA_func_site = NULL;
		ARMADA_step_pre  = NULL;
		ARMADA_loaded    = 0;	/* BATs are unloaded now */
	}
	mal_unset_lock(mal_contextLock, "armada");
}

/**
 * Commits the Armada BATs and saves them to disk.  If this goes wrong
 * in the middle, I fear bad things are going to happen.
 */
static void
ARMADAcommit()
{
	mal_set_lock(mal_contextLock, "armada");
	if (ARMADA_loaded != 0) {
		/* the BATs *should* be there... */
		assert (ARMADA_func_site != NULL);
		assert (ARMADA_step_pre != NULL);

		BATcommit(ARMADA_func_site);
		BATsave(ARMADA_func_site);

		BATcommit(ARMADA_step_pre);
		BATsave(ARMADA_step_pre);
	}
	mal_unset_lock(mal_contextLock, "armada");
}

/**
 * Adds a new step to the Armada administration.  The id (position) of
 * the added step is returned.  All steps stored need to be unique.  If
 * the step already exists, it is not added, and the id of the already
 * existing step is returned.
 */
str
ARMADAaddStep(int *ret, str *func, str *site) {
	BUN p;

	if (ARMADA_loaded == 0)
		throw("ArmadaException", "addStep", "Armada BATs not loaded");

	assert (ARMADA_func_site != NULL);

	/* see if the func/site already exists */
	p = BUNlocate(ARMADA_func_site, func, site);
	if (!p) {
		/* apparently not, so let's add it */
		BUNins(ARMADA_func_site, func, site);
		/* and look up the just added BUN */
		p = BUNlocate(ARMADA_func_site, func, site);
	}
	*ret = BUNgetpos(ARMADA_func_site, p);

	return(MAL_SUCCEED);
}

/**
 * Returns the id (position) of the step with function func and site
 * site, if it exists.  Otherwise, -1 is returned.
 */
str
ARMADAfindStep(int *ret, str *func, str *site) {
	BUN p;

	if (ARMADA_loaded == 0)
		throw("ArmadaException", "findStep", "Armada BATs not loaded");

	assert (ARMADA_func_site != NULL);

	/* lookup func/site and set retval appropriately */
	p = BUNlocate(ARMADA_func_site, func, site);
	if (!p) {
		*ret = -1;
	} else {
		*ret = BUNgetpos(ARMADA_func_site, p);
	}

	return(MAL_SUCCEED);
}

/**
 * Adds a new trail based on the given parent trail and local step.
 */
str
ARMADAaddTrail(int *ret, int *pre, int *step) {
	BUN p;

	if (ARMADA_loaded == 0)
		throw("ArmadaException", "addTrail", "Armada BATs not loaded");

	assert (ARMADA_func_site != NULL);
	assert (ARMADA_step_pre != NULL);

	/* see if the step already exists */
	p = BUNfnd(ARMADA_step_pre, step);
	if (!p) {
		/* apparently not, so let's add it if the pre step is indeed
		 * existant */
		if (*pre != int_nil) {
			/* TODO: find out if this is not a leak; I suspect it is
			 *       somehow */
			p = BUNfnd(BATmirror(ARMADA_step_pre), pre);
			if (!p)
				throw("ArmadaException", "addTrail", "pointing to non-existant predecessor step");
		}
		BUNins(ARMADA_step_pre, step, pre);
		/* and look up the just added BUN */
		p = BUNlocate(ARMADA_step_pre, step, pre);
	} else {
		/* check that the pre matches... */
		if (*(int*)BUNtail(ARMADA_step_pre, p) != *pre)
			throw("ArmadaException", "addTrail", "step already exists, but with different predecessor");
	}
	*ret = BUNgetpos(ARMADA_step_pre, p);

	return(MAL_SUCCEED);
}

/**
 * Adds a new trail based on the given BAT with trail steps.  The first
 * BUN in the BAT is taken as the oldest step in the trail.  The BAT is
 * considered to have the functions in the head, and the sites in the
 * tail.
 */
str
ARMADAaddTrailBAT(int *ret, int *bat) {
	BAT *steps;
	BUN p, q;
	str *func, *site, tmp;
	int idx, lastStep;

	if (ARMADA_loaded == 0)
		throw("ArmadaException", "addTrail", "Armada BATs not loaded");
	if ((steps = BATdescriptor(*bat)) == NULL)
		throw("ArmadaException", "addTrail", "steps BAT cannot be nil");

	/* Walk through the given BAT and add the steps to the
	 * administration.  Note, when this fails in the middle, we don't
	 * have a backup strategy.
	 */
	lastStep = int_nil;
	BATloop(steps, p, q) {
		func = (str*)BUNhead(steps, p);
		site = (str*)BUNtail(steps, p);
		rethrow("addTrail", tmp, ARMADAaddStep(&idx, func, site));
		/* Now we have the id of the step, we can check whether it
		 * already is in the step/pre BAT, and add it otherwise.
		 * Failure here indicates an Armada inconsistency.
		 */
		rethrow("addTrail", tmp, ARMADAaddTrail(&idx, &idx, &lastStep));
		
		lastStep = idx;
	}

	*ret = lastStep;
	return(MAL_SUCCEED);
}
