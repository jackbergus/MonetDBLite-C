@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2008 CWI.
@' All Rights Reserved.

@f batExtensions
@v 2.0
@a M.L.Kersten
@+ BAT Extensions
The kernel libraries are unaware of the MAL runtime semantics.
This calls for declaring some operations in the MAL module section
and register them in the kernel modules explicitly.

A good example of this borderline case are BAT creation operations,
which require a mapping of the type identifier to the underlying
implementation type.

Another example concerns the (un)pack operations, which direct
access the runtime stack to (push)pull the values needed.
@mal

pattern bat.new(ht:any_1, tt:any_2, b:bat[:any_3,:any_4]) :bat[:any_1,:any_2] 	
address CMDBATclone
comment "Creates a new empty transient BAT by cloning another";
pattern bat.new(ht:any_1, tt:any_2) :bat[:any_1,:any_2] 	
address CMDBATnew
comment "Creates a new empty transient BAT,
	with head- and tail-types as indicated.";
pattern bat.new(ht:any_1, tt:any_2, size:int) :bat[:any_1,:any_2] 	
address CMDBATnewint
comment "Creates a new BAT with sufficient space.";
pattern bat.new(ht:any_1, tt:any_2, size:lng) :bat[:any_1,:any_2] 	
address CMDBATnew
comment "Creates a new BAT and allocate space.";
pattern bat.new(ht:oid, tt:any_2, size:int) :bat[:oid,:any_2] 	
address CMDBATnewint;
pattern bat.new(ht:oid, tt:any_2, size:lng) :bat[:oid,:any_2] 	
address CMDBATnew;

pattern bat.new(b:bat[:any_1,:any_2] ) :bat[:any_1,:any_2] 	
address CMDBATnewDerived;
pattern bat.new(b:bat[:any_1,:any_2], size:lng) :bat[:any_1,:any_2] 	
address CMDBATnewDerived;
command bat.new(nme:str):bat[:any_1,:any_2]
address CMDBATderivedByName
comment "Localize a bat by name and produce a variant";

command bat.reduce(b:bat[:any_1,:any_2]):bat[:any_1,:any_2]
address CMDBATreduce
comment "Designate a BAT for which auxillary structures can be dropped";
command bat.flush(b:bat[:any_1,:any_2]):void
address CMDBATflush
comment "Designate a BAT as not needed anymore";
pattern bat.setGarbage(b:bat[:any_1,:any_2]):void
address CMDBATsetGarbage
comment "Designate a BAT as garbage";

pattern bat.unpack(b:bat[:any_1,:any_2])(h:any_1,t:any_2)
address CMDbatunpack
comment "Extract the first tuple from a bat";
pattern bat.pack(h:any_1,t:any_2):bat[:any_1,:any_2]
address CMDbatpack
comment "Pack a pair into a BAT";

pattern bat.setBase(b:bat[:any_1,:any_2],c:bat[:any_1,:any_2]...):void
address CMDsetBase
comment "Give the non-empty BATs consecutive oid bases";
                                                                                
@{
@{
@include prelude.mx
@+ Implementation section
In most cases we pass a BAT identifier, which should be unified
with a BAT descriptor. Upon failure we can simply abort the function.

@c
#include "mal_config.h"
#include "mal_box.h"
#include "mal_client.h"
#include "mal_interpreter.h"
#include "bat5.h"
#include "algebra.h"

#ifdef WIN32
#ifndef LIBBATEXTENSIONS
#define be_export extern __declspec(dllimport)
#else
#define be_export extern __declspec(dllexport)
#endif
#else
#define be_export extern
#endif

be_export str CMDBATsetGarbage(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
be_export str CMDBATflush(int *res, int *bid);
be_export str CMDBATreduce(int *ret, int *bid);
be_export str CMDBATclone(MalBlkPtr m, MalStkPtr s, InstrPtr p);
be_export str CMDBATnew(MalBlkPtr m, MalStkPtr s, InstrPtr p);
be_export str CMDBATnewDerived(MalBlkPtr m, MalStkPtr s, InstrPtr p);
be_export str CMDBATderivedByName(int *ret, str *nme);
be_export str CMDBATnewint(MalBlkPtr m, MalStkPtr s, InstrPtr p);
be_export str CMDBBPproject(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
be_export str CMDBBPprojectNil(int *ret, int *bid);
be_export str CMDbatunpack(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
be_export str CMDbatpack(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
be_export str CMDsetBase(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);

@-
Access to a box calls for resolving the first parameter
to a named box. The bbp box is automatically opened.
@c
#define OpenBox(X) \
	box= findBox("bbp");\
	if(box == 0 )\
		box= openBox("bbp");\
	if( box ==0) \
		throw(MAL, "bbp." X,"box is not open");


@- Operator implementation
A BAT designated as garbage can be removed, provided we
do not keep additional references in the stack frame
Be careful here not to remove persistent BATs.
Note that we clear the dirty bit to ensure that
the BAT is not written back to store before being freed.
@c
str
CMDBATsetGarbage(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	int *bid;
	BAT *b;

	(void) mb;
	bid = (int *) getArgValue(stk, pci, 1);
	if ((b = BATdescriptor(*bid)) == NULL) 
		throw(MAL, "bbp.setGarbage", "Cannot access descriptor");

	b->batDirty= FALSE;
	BBPunfix(b->batCacheid);
	if (*bid)
		BBPdecref(*bid,TRUE);
	*bid = 0;
	return MAL_SUCCEED;
}

str
CMDBATflush(int *ret, int *bid)
{
	BAT *b;

	if ((b = BATdescriptor(*bid)) == NULL) 
		throw(MAL, "bbp.flush", "Cannot access descriptor");

	/* use memory advice to release the BAT */
	/* TO BE PROVIDED */
	BBPunfix(b->batCacheid);
	if (*bid)
		BBPdecref(*bid,TRUE);
	*ret = 0;
	return MAL_SUCCEED;
}

str
CMDBATreduce(int *ret, int *bid)
{
	BAT *b;
	int old= GDKdebug;

	if ((b = BATdescriptor(*bid)) == NULL) 
		throw(MAL, "bbp.reduce", "Cannot access descriptor");

	/* reduce memory footprint by dropping hashes 
	of non-persistent bats */
	if( !isVIEW(b) && b->batSharecnt==0){
#ifdef TRACE_ADVICE
		if(b->hhash)
			printf("found hhash %s %d\n",BBP_logical(b->batCacheid), (int)(BATcount(b) * sizeof(hash_t)));
		if(b->thash)
			printf("found thash %s %d\n",BBP_logical(b->batCacheid), (int)(BATcount(b) * sizeof(hash_t)));
#endif
		/* disable DeadBeef production */
		GDKdebug &= ~33554432;
		HASHdestroy(b);
	}
	BBPkeepref(*ret=b->batCacheid);
	GDKdebug = old;
	return MAL_SUCCEED;
}

@+ BAT enhancements
The code to enhance the kernel.
@c
str
CMDBATclone(MalBlkPtr m, MalStkPtr s, InstrPtr p)
{
	BAT *b, *bn;
	int bid = 0, cap, ht, tt;
	int *res;

	(void) m;

	bid = *(int *) getArgReference(s, p, 3);
	if ((b = BATdescriptor(bid)) == NULL) {
		throw(MAL, "bbp.new", "Cannot access descriptor");
	}
	res = (int *) getArgReference(s, p, 0);
	ht = getArgType(m, p, 1);
	tt = getArgType(m, p, 2);
	cap = BATcount(b) + 64;
@-
Cloning should include copying of the properties.
@c
	BBPunfix(b->batCacheid);
	bn= BATnew(ht,tt,cap);
	if( bn == NULL){
		BBPunfix(b->batCacheid);
		throw(MAL,"bat.new","Cannot create BAT");
	}
	if( b->hseqbase)
		BATseqbase(bn, b->hseqbase);
	bn->hkey= b->hkey;
	bn->tkey= b->tkey;
	bn->hsorted= b->hsorted;
	bn->tsorted= b->tsorted;
	BBPkeepref(*res = bn->batCacheid);
	return MAL_SUCCEED;
}

str
CMDBATnew(MalBlkPtr m, MalStkPtr s, InstrPtr p)
{
	int ht, tt;
	lng cap = 0;
	int *res;

	res = (int *) getArgReference(s, p, 0);
	ht = getArgType(m, p, 1);
	tt = getArgType(m, p, 2);
	if (p->argc > 3)
		cap = *(lng*) getArgReference(s, p, 3);

	if (ht == TYPE_any || tt == TYPE_any)
		throw(MAL, "bbp.new", "Explicit type required");
	if (isaBatType(ht))
		ht = TYPE_bat;
	if (isaBatType(tt))
		tt = TYPE_bat;
	return (str) BKCnewBATlng(res, &ht, &tt, &cap);
}

str
CMDBATnewDerived(MalBlkPtr m, MalStkPtr s, InstrPtr p)
{
	int bid, ht, tt;
	int cap = 0;
	int *res;
	BAT *b;
	str msg;
	oid o;

	(void) m;
	res = (int *) getArgReference(s, p, 0);
	bid = *(int *) getArgReference(s, p, 1);
	if ((b = BATdescriptor(bid)) == NULL) {
		throw(MAL, "bbp.new", "Cannot access descriptor");
	}

	if (bid > 0) {
		ht = b->htype;
		tt = b->ttype;
	} else {
		tt = b->htype;
		ht = b->ttype;
	}

	if (p->argc > 2)
		cap = *(int *) getArgReference(s, p, 2);
	else
		cap = BATcount(b);
	o = b->hseqbase;
	BBPunfix(b->batCacheid);

	res = (int *) getArgReference(s, p, 0);
	msg = (str) BKCnewBATint(res, &ht, &tt, &cap);
	if (msg == MAL_SUCCEED && ht == TYPE_void) {
		b = BATdescriptor(*res);
		BATseqbase(b, o);
		BBPunfix(b->batCacheid);
	}

	return msg;
}

str
CMDBATderivedByName(int *ret, str *nme)
{
	BAT *bn;
	int bid;

	bid = BBPindex(*nme);
	if (bid <= 0 || (bn = BATdescriptor(bid)) == 0)
		throw(MAL, "bbp.new", "Referenced BAT not found");
	BBPincref(*ret = bn->batCacheid, TRUE);
	BBPunfix(bid);
	return MAL_SUCCEED;
}

str
CMDBATnewint(MalBlkPtr m, MalStkPtr s, InstrPtr p)
{
	int ht, tt;
	int cap = 0;
	int *res;

	res = (int *) getArgReference(s, p, 0);
	ht = getArgType(m, p, 1);
	tt = getArgType(m, p, 2);
	cap = *(int *) getArgReference(s, p, 3);
	res = (int *) getArgReference(s, p, 0);

	return (str) BKCnewBATint(res, &ht, &tt, &cap);
}

str
CMDBBPproject(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	int *result, *bid, tt;
	ptr *p;
	BAT *b, *bn;

	result = (int *) getArgReference(stk, pci, 0);
	bid = (int *) getArgReference(stk, pci, 1);
	p = (ptr *) getArgReference(stk, pci, 2);
	tt = getArgType(mb, pci, 2);
	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "bbp.project", "Cannot access descriptor");
	}

	if (tt >= TYPE_str) {
		if (p == 0 || *(str *) p == 0)
			p = (ptr *) str_nil;
		else
			p = *(ptr **) p;
	}
	bn = BATconst(b, tt, p);
	BBPunfix(b->batCacheid);
	if (bn) {
		*result = bn->batCacheid;
		BBPkeepref(bn->batCacheid);
		return MAL_SUCCEED;
	}
	throw(MAL, "bbp.project", "Cannot create the constant BAT");
}

str
CMDBBPprojectNil(int *ret, int *bid)
{
	BAT *b, *bn;

	if ((b = BATdescriptor(*bid)) == NULL) {
		throw(MAL, "bbp.project", "Cannot access descriptor");
	}

	bn = BATconst(b, TYPE_void, (ptr) &int_nil);
	BBPunfix(b->batCacheid);
	if (bn) {
		*ret = bn->batCacheid;
		BBPkeepref(bn->batCacheid);
		return MAL_SUCCEED;
	}
	throw(MAL, "bbp.project", "Cannot create the constant BAT");
}

str
CMDbatunpack(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	BAT *b;
	int bid;
	BUN p;
	ValPtr head, tail;

	bid = *(int *) getArgValue(stk, pci, 2);

	if ((b = BATdescriptor(bid)) == NULL) {
		throw(MAL, "bbp.unpack", "Cannot access descriptor");
	}

	head = &stk->stk[pci->argv[0]];
	tail = &stk->stk[pci->argv[1]];
	p = BUNfirst(b);
	if (p < BUNlast(b)) {
		BATiter bi = bat_iterator(b);
		VALinit(head, getArgType(mb, pci, 0), BUNhead(bi, p));
		VALinit(tail, getArgType(mb, pci, 1), BUNtail(bi, p));
	}

	BBPunfix(b->batCacheid);
	return MAL_SUCCEED;
}

str
CMDbatpack(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	BAT *b;
	int *ret;
	int ht, tt;
	size_t cap = 0;

	ht = getArgType(mb, pci, 1);
	tt = getArgType(mb, pci, 2);
	ret = (int *) getArgReference(stk, pci, 0);

	if (ht == TYPE_any || tt == TYPE_any)
		throw(MAL, "bbp.new", "Explicit type required");
	if (isaBatType(ht))
		ht = TYPE_bat;
	if (isaBatType(tt))
		tt = TYPE_bat;
	b = BATnew(ht, tt, cap);
	BUNins(b, (ptr) getArgValue(stk, pci, 1), getArgValue(stk, pci, 2), FALSE);
	if (!(b->batDirty&2)) b = BATsetaccess(b, BAT_READ);
	*ret = b->batCacheid;
	BBPkeepref(*ret);
	return MAL_SUCCEED;
}

str
CMDsetBase(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	int i;
	oid o= 0;
	BAT *b;
	(void) mb;
	for( i= pci->retc; i < pci->argc; i++){
		b= BATdescriptor(*(int*) getArgReference(stk,pci,i));
		if( b == NULL)
			throw(MAL,"bat.setBase","Can not access BAT");
		BATseqbase(b,o);
		o= o + (oid) BATcount(b);
		BBPunfix(b->batCacheid);
	}
	return MAL_SUCCEED;
}
