@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2005 CWI.
@' All Rights Reserved.

@f multitable
@a Martin Kersten
@v 1
@* Multiple Association Tables.
A persistent Multiple Association Tables (MAT) 
is an union view over a set of BATs. 
A MAT is a convenient way to deal with scaleability. 
This view is only materialized when the operations
can not deal with the components individually.

The module is supported by the mal_multitable optimizer.

The persistent MATs are administered in a BOX using
the standard interface to manage its content.

The primitives below are chosen to accomodate the SQL
front-end to produce reasonable efficient code.
@mal
module mat;

pattern new(b:bat[:any_1,:any_2]...):bat[:any_1,:any_2]
address MATnew
comment "Define a Merge Association Table (MAT) ";

pattern pack(b:bat[:any_1,:any_2]...):bat[:any_1,:any_2]
address MATpack
comment "Materialize the MAT into a single BAT";

pattern print(b:bat[:any_1,:any_2]...):void
address MATprint;

command take(g:str, e:str):bat[:any_1,:any_2]
address MATtake
comment "retrieve the definition from the partition catalogue";
@-
@{
@+ Implementation
@include prelude.mx
@h
#ifdef _INSPECT_H
#endif /* _INSPECT_H */
@c
#include <stdarg.h>
#include "mal_resolve.h"
#include "mal_exception.h"
#include "mal_interpreter.h"

mal_export str MATnew(MalBlkPtr mb, MalStkPtr stk, InstrPtr p);

@- 
Mal symbol table and environment analysis.
@c

str
MATnew(MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	(void) mb; (void) stk; (void) p;
	return MAL_SUCCEED;
}
@-
The pack operation could be quite expensive, because it
may create a really large BAT.
@c
str
MATpack(MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	int i,*ret,tpe;
	BAT *b, *bn;
	tpe= getArgType(mb,p,0);

	bn= BATnew(getHeadType(tpe),getTailType(tpe), 0);
	if( bn == NULL)
		return throwMessage("mat.pack","Could not allocate storage");
	for(i=1; i<p->argc; i++){
		b= BATdescriptor(stk->stk[getArg(p,i)].val.ival);
		if( b == NULL)
			return throwMessage("mat.pack","Could not access component");
		BATins(bn,b);
		BBPunfix(b->batCacheid);
	}
	(void) mb;
	ret= (int*) getArgReference(stk,p,0);
	BBPincref( (*ret= bn->batCacheid), TRUE);
	BBPunfix(bn->batCacheid);
	return MAL_SUCCEED;
}

str
MATprint(MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	(void) mb; (void) stk; (void) p;
	return MAL_SUCCEED;
}

str
MATtake(int *ret, str *grp, str *elm){
	(void) grp; (void) elm; (void) ret;
	return MAL_SUCCEED;
}
@}
