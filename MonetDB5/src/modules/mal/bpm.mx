@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2007 CWI.
@' All Rights Reserved.

@f bpm
@v 0.3
@a M.L.Kersten
@* BAT Partition Manager
In real-life database applications the BATs tend to grow beyond
the memory size. This leads to a heavy IO dominated behavior,
which can partly be avoided by breaking up the query into a sequence
of subqueries using a map-reduce strategy.
The BAT partition manager (BPM) module is designed to 
support this strategy using range- and hash-partitioning.

Consider we want to reorganize R:bat[:oid,:int] into three partitions,
based on splitting by tail value. 
The following MAL program illustrates the snippet of actions needed:
@example
	bpm.open();
	Ralias:= bpm.deposit("myversion",R:bat[:oid,:int]);
	bpm.rangePartition(Ralias,nil:int,100);
	bpm.rangePartition(Ralias,101,200);
	bpm.close();
@end example
The command @sc{bpm.deposit} registers a BAT as one 
for which a partitioned copy is required.
The first partition call breaks the orginal BAT into
two pieces: (nil:int,100) and (101,nil:int).
The second call breaks the latter into (101,200)
and (201,nil:int).
The BAT partitions share the persistency properties.
Partitioning on the head simple calls for a reverse operation
on the source BAT first. Beware that subsequent updates may
materialize the header.

The partitions are given an index number by which they can be
more easily retrieved.
This number remains stable until a new partitioning command
is issued.

The partition manager also supports hash-based partitioning.
Its argument is the number of hash bucket bits.
example
	bpm.open();
	Rrev:= bat.reverse(R:bat[:oid,:int]);
	Ralias:= bpm.deposit("myHashVersion",Rev);	# creates side effects
	bpm.hashPartition(Ralias,2);
	bpm.close();
@end example
This example creates a hash-partition based on the head.

The design is based on the assumption that partitions
are reasonably large. This helps to limit plan explosion.
(or a scheduler should step in)

@- Derived partitioning
A relational front-end would benefit from derived horizontal
fragmentation. It would enable grouping together related
fragments on the same site. 
Assume a relation R(A,B) which is already partitioned on A
the derived fragmentation on the head is enforced with
@example
bpm.derivePartition(B,A);
@end example
@- Using partitions
The partitioned BAT can be used in two ways. A query plan can be
rewritten into a generator over the partitions, or it can be
used by optimizers to derived all subqueries first for
symbolic evaluation.

The former is illustrated with the snippet to select part of
a partitioned BAT. In this example we collect the partial
results in the accumulator BAT tu.
@example
	bpm.open();
	Ralias:= bpm.take("myversion",:bat[:oid,:int]);
	tu:= bat.new(:oid,:int);
barrier (idx,Rp):= bpm.newIterator(Ralias);
	...
	t:= algebra.select(Rp,0,100);
	tu:= algebra.union(tu,t);
	...
	redo (idx,Rp):= bpm.hasMoreElements(Ralias);
exit (idx,b);
	bpm.close();
@end example

The partitioned BATs are particularly useful during query
optimization. However, it only works if the BAT identifier
can be determined at compile time. For SQL it can be simply looked up in
the catalog as part of the preparatory optimizer step.
The same problem handled by an optimizer produces the plan:
@example
	bpm.open();
	R:= bpm.take("myversion",:bat[:oid,:int]); # get the partition alias
	optimizer.bpm();
	T:= algebra.select(R,0,100);
@end example
is translated into to obtain the
@example
	bpm.open();
	Ralias:= bpm.take("myversion",:bat[:oid,:int]);
	R0:= bpm.take(Ralias, 0); #get first partition
	R1:= bpm.take(Ralias, 1); #get second partition
	R2:= bpm.take(Ralias, 2); #get third partition
	R:= mat.new(R0,R1,R2);
	T:= algebra.select(R,0,100);
	optimizer.multitable();
@end example
It is up to the @sc{mat} optimizer to decide about
further plan expansion or an iterator approach.

@- Partition updates
The content of the partitions is preferrable updated in bulk.
This calls for accumulation of insertions/deletions in pending
update BATs, as already performed in the SQL code generator.
Once the transaction is commited, the updates are propagated
(in parallel) to all partitions.
@example
	bpm.open();
	Ralias := bpm.take("myversion",:bat[:oid,:int]); 
	bpm.insert(Ralias, Rinsert);	# handle pending inserts
	bpm.delete(Ralias, Rdelete);	# handle pending deletes
	bpm.replace(Ralias, Rold, Rnew);	# handle pending updates
	bpm.close();
@end example
The @sc{replace} operator works on the assumption that
the head of @sc{Rold} and @sc{Rnew} is unique.

It remains possible to retrieve a partition and directly
insert elements, but then it is up to the compiler to
ensure that the boundery conditions are met.

@- Partitioned results
In many situations, you would like to keep the partial results
as a partitioned BAT again.
The easiest solution is to remember the partitions as temporary 
variables during optimization, e.g. as properties of all fragment variables.

However, a persistent partitioned BAT can also be created first,
whose partitions are empty. Subsequently, we insert the temporary results. 
Depending on the fragmentation criteria, pieces may align
with the pieces known, or lead to a redistribution of the
buns to the correct bats.

The previous plan for this becomes
@example
	bpm.open();
	Tmp := bpm.take("tmp",:bat[:oid,:int]);
	bpm.rangePartition(Tmp,nil,100);
	bpm.rangePartition(Tmp,101,200);

	Ralias:= bpm.take("myversion",:bat[:oid,:int]); # get the partition alias
	R0:= bpm.take(Ralias, 0);
	T0:= algebra.select(R0,0,100);
	bpm.deposit(Tmp,T0);

	R1:= bpm.take(Ralias, 1);
	T1:= algebra.select(R1,0,100);
	bpm.deposit(Tmp,T1);

	R2:= bpm.take(Ralias, 2);
	T2:= algebra.select(R2,0,100);
	bpm.deposit(Tmp,T2);
@end example
The rationale for this approach is that re-distribution
of temporary results are hidden behind the @sc{bpm} interface.
The only decision that should be taken by the optimizer is
the fragmentation criteria for the temporary results.

For temporary results the range bounds need not be
stored in the bpm. Instead, the mat approach could
be used to reduce the plan size.
@example
	bpm.open();
	Ralias:= bpm.take("myversion",:bat[:oid,:int]); # get the partition alias
	R0{hlow=nil:oid,hhigh=nil:oid,tlow=nil:int,thigh=100}:= bpm.take(Ralias, 0);
	T0:=algebra.select(R0,0,100);

	R1{hlow=nil:oid,hhigh=nil:oid,tlow=101,thigh=200}:= bpm.take(Ralias, 1);
	T1:= algebra.select(R1,0,100);

	R2{hlow=nil:oid,hhigh=nil:oid,tlow=201,thigh=nil:int}:=  bpm.take(Ralias, 2);
	R:= mat.new(T0,T1,T2);
	T2:=algebra.select(R2,0,100);
@end example

@- Partition selection
The select operation can be overloaded in the BPM to
improve processing further. For example, the operation
@example
	t := bpm.select(Ralias,0,100);
@end example
extracts portions of all three partitions and creates 
a non-partitioned result BAT. 
There is no information on the partitions involved in this operation
for the optimizer.


The lifetime of a partitioned table is inherited from its components. 
How to detect that a temporary BAT is removed from the BBP?

@mal
module bpm;

command open():void
address BPMopen
comment "Locate and open the BAT partition box";

command close():void
address BPMclose
comment "Save and close the BAT partition box ";

command destroy():void
address BPMdestroy
comment "Destroy the BAT partition box";

command deposit(nme:str,b:bat[:oid,:any_2]) :bat[:oid,:any_2]
address BPMdeposit
comment "Create a new partitioned BAT by name";

@-
The partitioning is handled inside the module.
If the alias BAT denotes an existing partition, it is
further broken into pieces.
@mal
command rangePartition(pb:bat[:any_1,:any_2], rl:any_2, rh:any_2):void
address BPMrange
comment "Create a range partition on a BAT";

command rangePartition(pb:bat[:any_1,:any_2], pv:bat[:oid,:any_2]):void
address BPMrangeVector
comment "Create the partitions based on a range vector";
command splitPartition(pb:bat[:any_1,:any_2], val:any_2):void
address BPMsplitpartition
comment "Create a range partition on a BAT";

command addPartition(nme:str,b:bat[:any_1,:any_2]) :bat[:any_1,:any_2]
address BPMaddPartition
comment "Add a new partition to the chain for name";

command addPartition(nme:str,b:bat[:any_1,:any_2],hl:any_1,hh:any_1, 
	tl:any_2, th:any_2) :bat[:any_1,:any_2]
address BPMaddPartitionDim
comment "Add a new partition to the chain for name and set its dimensions";

command hashPartition(pb:bat[:any_1,:any_2], slots:int):void
address BPMhash
comment "Create a hash partition on a BAT";
command derivePartition(pb:bat[:any_1,:any_2], 
	src:bat[:any_1,:any_2]):bat[:any_1,:any_2]
address BPMderived
comment "Create a derived fragmentation over the head using src.";

command take(pb:str):bat[:any_1,:any_2]
address BPMtake
comment "Retrieve the alias given the name of a partitioned BAT";
command take(alias:bat[:any_1,:any_2],index:int) :bat[:any_1,:any_2]
address BPMtakePartition
comment "Retrieve a single component of a partitioned BAT by index";

command insert(pb:bat[:any_1,:any_2],b:bat[:any_1,:any_2]) :void
address BPMinsert
comment "Insert elements into the BAT partitions";
command delete(pb:bat[:any_1,:any_2],b:bat[:any_1,:any_2]) :void
address BPMdelete
comment "Delete elements from the BAT partitions";
command replace(pb:bat[:any_1,:any_2],old:bat[:any_1,:any_2],
		nwe:bat[:any_1,:any_2]) :void
address BPMreplace
comment "Replace the content of the BAT partitions";

command getNames():bat[:oid,:str]
address BPMgetNames
comment "Retrieve the names of all known partitioned BATs";

command discard(alias:bat[:any_1,:any_2]) :void
address BPMdiscard
comment "Release a partitioned BAT from the box";
command discard() :void
address BPMdiscardAll
comment "Release all partitioned BATs";

@-
In most situations we would like to iterator over
the components of a single partitioned BAT. 
Wherever possible skipping elements that don't qualify
the bounds given for the head.
@mal
pattern newIterator(grp:bat[:any_1,:any_2]) :bat[:any_1,:any_2]
address BPMnewIterator
comment "Create an iterator over the BAT partitions.";

pattern newIterator(grp:bat[:any_1,:any_2],first:any_2,last:any_2)
		:bat[:any_1,:any_2]
address BPMnewIteratorRng
comment "Create an iterator over the BAT partitions overlapping with range.";

pattern newIterator(pb:bat[:any_1,:any_2], first:any_1,last:any_1,
		vlow:any_2, vhgh:any_2) :bat[:oid,:any_2]
address BPMnewIteratorRng4
comment "Create an iterator over the BAT partitions.";

pattern hasMoreElements(grp:bat[:any_1,:any_2]) :bat[:any_1,:any_2]
address BPMhasMoreElements
comment "Localize the next partition for processing.";

pattern hasMoreElements(pb:bat[:any_1,:any_2], 
		low:any_2, hgh:any_2) :bat[:any_1,:any_2]
address BPMhasMoreElementsRng
comment "Localize the next partition overlapping with range.";

pattern hasMoreElements(pb:bat[:any_1,:any_2], first:any_1,last:any_1,
		vlow:any_2, vhgh:any_2) :bat[:any_1,:any_2]
address BPMhasMoreElementsRng4
comment "Localize the next partition for processing.";

command getDimension(b:bat[:any_1,:any_2])(first:any_1,last:any_1, 
	vlow:any_2, vhgh:any_2)
address BPMgetDimension
comment "Obtain the partition boundary values.";

command dump(alias:bat[:any_1,:any_2])
address BPMdumpAlias
comment "Give the details of the partition tree";
command dump()
address BPMdump;

command mapName() :bat[:int,:str] 
address BPMmapName;
command mapBid() :bat[:int,:bat] 
address BPMmapBid;
command mapAlias() :bat[:int,:bat] 
address BPMmapAlias;
command mapNxt() :bat[:int,:int] 
address BPMmapNxt;
command mapPrv() :bat[:int,:int] 
address BPMmapPrv;
command mapTlowLng() :bat[:int,:lng] 
address BPMmapTlowLng;
command mapTlowDbl() :bat[:int,:dbl] 
address BPMmapTlowDbl;
command mapThghLng() :bat[:int,:lng] 
address BPMmapThghLng;
command mapThghDbl() :bat[:int,:dbl] 
address BPMmapThghDbl;

command savePartitions() 
address BPMsavePartitions;


command prelude()
address BPMprelude;

command epilogue()
address BPMepilogue;
bpm.prelude();
@-
@{
@include ../kernel/kprelude.mx
@+ BAT Partition Manager Implementation
The implementation is organized around a shared box, which should
be saved between session. It is up to other layers to ensure that BATs
being deleted are also removed from the partition box to avoid
mis-represented information.

The internal data structure is used as a cache for improved access.
@h
#ifndef _MAL_BPM
#define _MAL_BPM
#include "mal.h"
#include "mal_client.h"
#include "mal_interpreter.h"
#include "algebra.h"

#define _DEBUG_BPM_

#ifdef WIN32
#ifndef LIBBPM
#define bpm_export extern __declspec(dllimport)
#else
#define bpm_export extern __declspec(dllexport)
#endif
#else
#define bpm_export extern
#endif

bpm_export str BPMopen(void);
bpm_export str BPMclose(int *ret);
bpm_export str BPMdestroy(int *ret);
bpm_export str BPMdeposit(bat *ret, str *nme, bat *src);

bpm_export str BPMrange(bat *ret, bat *bid, ptr low, ptr hgh);
bpm_export str BPMsplitpartition(bat *ret, bat *bid, ptr val);
bpm_export str BPMrangeVector(bat *ret, bat *bid, bat *pv);
bpm_export str BPMaddPartition(bat *ret, str *nme, bat *src);
bpm_export str BPMaddPartitionDim(bat *ret, str *nme, bat *src, ptr hl, ptr hh, ptr tl, ptr th);
bpm_export str BPMhash(bat *ret, bat *bid, int *slots);
bpm_export str BPMderived(bat *ret, bat *bid, bat *src);

bpm_export str BPMtake(bat *ret, str *nme);
bpm_export str BPMtakePartition(bat *ret, bat *bid, int *idx);

bpm_export str BPMinsert(bat *ret, bat *bid, bat *ins);
bpm_export str BPMdelete(bat *ret, bat *bid, bat *del);
bpm_export str BPMreplace(bat *ret, bat *bid, bat *ins, bat *del);

bpm_export str BPMgetNames(bat *bid);
bpm_export str BPMdiscard(int *ret, bat *bid);
bpm_export str BPMdiscardAll(int *ret);

bpm_export str BPMnewIterator(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
bpm_export str BPMnewIteratorRng(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
bpm_export str BPMnewIteratorRng4(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);

bpm_export str BPMhasMoreElements(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
bpm_export str BPMhasMoreElementsRng(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
bpm_export str BPMhasMoreElementsRng4(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);

bpm_export str BPMgetDimension(ptr *first, ptr *last,
	ptr *vlow, ptr *vhgh, bat *bid);
bpm_export str BPMdump(int *ret);
bpm_export str BPMdumpAlias(int *ret, bat *bid);

bpm_export str BPMmapName(int *ret);
bpm_export str BPMmapBid(int *ret);
bpm_export str BPMmapAlias(int *ret);
bpm_export str BPMmapNxt(int *ret);
bpm_export str BPMmapPrv(int *ret);
bpm_export str BPMmapTlowLng(int *ret);
bpm_export str BPMmapTlowDbl(int *ret);
bpm_export str BPMmapThghLng(int *ret);
bpm_export str BPMmapThghDbl(int *ret);

bpm_export str BPMsavePartitions(int *ret);

bpm_export str BPMprelude(int *ret);
bpm_export str BPMepilogue(int *ret);
#endif
@-
The partition manager uses its private memory mapped catalog of persistent BATs.
The handle returned is a BAT that represents the whole group.
They are further administered  by type
@c
#include "mal_config.h"
#include "bpm.h"
#include "bat5.h"

@-
Every partition is the result of at most four operations:
range/hash partition on head/tail.
The consolidated properties are administered for use
by the compiler/optimizer.
For range-based partitions it simply means the range bounds,
for hash-based partitions we need the hash bucket properties.

@c
#define	RANGE	1
#define HASH	2

typedef struct PARTITIONREC {
	char *name;		/* propably inherit from alias */
	bat alias;		/* partition BAT alias */
	bat bid;		/* partition BAT */

	ValRecord hlow,hhgh; /* head range */
	ValRecord tlow,thgh; /* tail range */
	int hbits, tbits; /* linear hashing bits */
	int nxt, prv;	/* list of all partitions*/
} *Partition, PartitionRec;

static void BPMprintRecord(stream *f, Partition p){
	stream_printf(f,"partition: %s alias %d bid %d ",
		p->name, p->alias, p->bid);
/*	stream_printf(f,"hbits %d tbits %d ", p->hbits,p->tbits); */
	stream_printf(f,"tlow "); VALprint(f,&p->tlow);
	stream_printf(f," thgh "); VALprint(f,&p->thgh);
	stream_printf(f," nxt %d prv %d\n", p->nxt,p->prv);
}
@-
The number of partitioned BATs is considered low and
a straight forward array with linear search seems
sufficient to find the alias versions. The first entry
is not used for defensive code reasons.
@c
static Partition bpmcat= 0;
static int bpmcatsize, bpmcattop;

static int getPartitionName(str nme){
	int i;
	for(i=0; i< bpmcattop; i++)
		if( bpmcat[i].alias && strcmp(bpmcat[i].name,nme)==0)
			return i;
	return 0;
}

/* Return cat. index for partition for alias als with bat bid */
static int getPartitionIndex(bat als, bat bid){
	int i;
	for(i=1;i<bpmcattop; i++)
		if( bpmcat[i].alias== als) {
			while( bpmcat[i].nxt && bpmcat[i].bid != bid)
				i=  bpmcat[i].nxt;
			while( bpmcat[i].prv && bpmcat[i].bid != bid)
				i=  bpmcat[i].prv;
			if( bpmcat[i].bid != bid)
				return 0;
			return i;
		}
	return 0;
}

/* Return cat. index of the first partition in the chain for alias als */
static int getAliasIndex(bat als){
	int i;
	for(i=1;i<bpmcattop; i++)
		if ( bpmcat[i].alias == als) {
			while ( bpmcat[i].prv )
				i=  bpmcat[i].prv;
			return i;
		}
	return 0;
}


static Partition getAlias(bat als){
	return bpmcat + getAliasIndex(als);
}

/* Return cat. index for a partition without info which alias it belongs */
static int getPartitionIndexNoAlias(bat bid){
	int i;
	for(i=1;i<bpmcattop; i++)
		if( bpmcat[i].bid == bid) 
			return i;
	return 0;
}


/* NOT USED YET
static void delAlias(bat bid){
	int i;
	i= getPartitionIndex(bid,0);
	(void) i;
}
*/

static int getFreeAlias(){
	int i;

	mal_set_lock(mal_contextLock, "bpm");
	for(i=1;i<bpmcattop; i++)
		if( bpmcat[i].alias == 0) {
			mal_unset_lock(mal_contextLock, "bpm");
			return i;
		}
	if( bpmcattop >= bpmcatsize){
		/* reallocate the catalog */
		bpmcatsize +=1024;
		bpmcat = (Partition) GDKrealloc(bpmcat, sizeof(PartitionRec)* bpmcatsize);

	}
	bpmcattop++;
	mal_unset_lock(mal_contextLock, "bpm");
	return i;
}

@- Box administration
The box currently does not carry any client protection.
This should later be added or being provided by the BAT access.

The partition catalog is saved between sessions as a collection
of BATs.
@= openCat
@c
str
BPMopen_org()
{
	if(bpmcat) return MAL_SUCCEED;
    mal_set_lock(mal_contextLock, "bpm");
	/* read the partition table structure, post-poned */
	bpmcat= (Partition) GDKzalloc(sizeof(PartitionRec)*1024);
	bpmcatsize= 1024;
	bpmcattop= 1; /* first one never used */
    mal_unset_lock(mal_contextLock, "bpm");
	return MAL_SUCCEED;
}

@= loadBPMbat
	idx= BBPindex("bpm_@1");
        if ((b = BATdescriptor(idx)) == NULL) 
                throw(MAL, "loadPartitions", "Cannot access descriptor");
	BATloop(b, p, q) {
		i = *(int *)BUNhead(b,p);
		k = *(@2 *) BUNtail(b,p);
		bpmcat[i].@1 = k;	
	}
	BBPunfix(b->batCacheid);

@= openBPMbat
	idx= BBPindex("bpm_@2");
        if ((@1 = BATdescriptor(idx)) == NULL) 
                throw(MAL, "loadPartitions", "Cannot access descriptor");

@= BPMunfix
	BBPunfix(bnxt->batCacheid);
	BBPunfix(bprv->batCacheid);
	BBPunfix(bll->batCacheid);
	BBPunfix(bld->batCacheid);
	BBPunfix(bhl->batCacheid);
	BBPunfix(bhd->batCacheid);

@c
str
BPMloadPartitions()
{	
	int i,mc,k,tp;
	bat idx;
	BAT *b, *bm, *pb;
	BAT *bnxt, *bprv, *bld, *bll, *bhd, *bhl;
	BUN p,q,r;
	str nm;
	ptr val;
	size_t cnt,c;
	
	idx= BBPindex("bpm_name");

        if ((b = BATdescriptor(idx)) == NULL) {
                throw(MAL, "loadPartitions", "Cannot access descriptor");
        }
	bm = BATmirror(b);
	
	if (BATcount(b))
		cnt=*(size_t *)BATmax(bm,(ptr)&c);
	else cnt=0;

	mc= (cnt+1)/1024  +1;      
       	bpmcatsize= 1024*mc;
	bpmcat= (Partition) GDKzalloc(sizeof(PartitionRec)*bpmcatsize);
	bpmcattop= cnt+1; /* first one never used */

#ifdef _DEBUG_BPM_
	stream_printf(GDKout,"Stored partitions %ld\n",cnt);
	stream_printf(GDKout,"Catalog size %d, top %d\n",bpmcatsize,bpmcattop);

#endif

	for( i=1; i<bpmcattop; i++)
		bpmcat[i].alias=0;

	BATloop(b, p, q) {
		i = *(int *)BUNhead(b,p);
		nm = (str) BUNtail(b,p);
		bpmcat[i].name = GDKstrdup(nm);	
	}
	BBPunfix(b->batCacheid);

	@:loadBPMbat(alias,int)@
	@:loadBPMbat(bid,int)@

	@:openBPMbat(bnxt,nxt)@
	@:openBPMbat(bprv,prv)@
	@:openBPMbat(bll,tlowlng)@
	@:openBPMbat(bld,tlowdbl)@
	@:openBPMbat(bhl,thghlng)@
	@:openBPMbat(bhd,thghdbl)@

/*  Initialize the remaining fields */
	for( i=1; i<bpmcattop; i++)
	   if( bpmcat[i].alias) {
		if ((pb = BATdescriptor(bpmcat[i].bid)) == NULL) {
			@:BPMunfix@
                	throw(MAL, "loadPartitions", "Cannot access partitioned bat");}
		r= BUNfnd(bprv,&i);
		if (r)
			bpmcat[i].prv= *(int *) BUNtail(bprv,r);
		else {	
			@:BPMunfix@
			throw(MAL, "load partitions", "broken partition chain:prv");
		}
		r= BUNfnd(bnxt,&i);
		if (r)
			bpmcat[i].nxt= *(int *) BUNtail(bnxt,r);
		else {
			@:BPMunfix@	
			throw(MAL, "load partitions", "broken partition chain:nxt");
		}
		
		tp=pb->ttype;
		switch (tp) {
			case TYPE_int:
			case TYPE_lng:
			case TYPE_sht: 	r= BUNfnd(bll,&i); 
					if (r){
					   val= BUNtail(bll,r);
					   VALset(&bpmcat[i].tlow, tp, val); 
					} else 
					   VALset(&bpmcat[i].tlow, tp, ATOMnil(tp) );

				 	q= BUNfnd(bhl,&i);
					if (q){
					   val= BUNtail(bhl,q);
					   VALset(&bpmcat[i].thgh, tp, val); 
					} else 
					   VALset(&bpmcat[i].thgh, tp, ATOMnil(tp) );

					break;
			case TYPE_dbl:
			case TYPE_flt:	r= BUNfnd(bld,&i);
					if (r){
					   val= BUNtail(bld,r);
					   VALset(&bpmcat[i].tlow, tp, val); 
					} else 
					   VALset(&bpmcat[i].tlow, tp, ATOMnil(tp) );

				 	q= BUNfnd(bhd,&i);
					if (q){
					   val= BUNtail(bhd,q);
					   VALset(&bpmcat[i].thgh, tp, val); 
					} else 
					   VALset(&bpmcat[i].thgh, tp, ATOMnil(tp) );

 			}
		VALset(&bpmcat[i].hlow, b->htype, ATOMnil(b->htype) );
		VALset(&bpmcat[i].hhgh, b->htype, ATOMnil(b->htype) );
		bpmcat[i].hbits= bpmcat[i].tbits= 0;
	}

	@:BPMunfix@
	return MAL_SUCCEED;
}


str
BPMopen()
{
	bat idx;

	if(bpmcat) return MAL_SUCCEED;
    mal_set_lock(mal_contextLock, "bpm");
	idx= BBPindex("bpm_name");
	if (idx == 0){		/*no stored part. structure */
		bpmcat= (Partition) GDKzalloc(sizeof(PartitionRec)*1024);
		bpmcatsize= 1024;
		bpmcattop= 1; /* first one never used */
	} else  	/* read the partition table structure */
		BPMloadPartitions();

    mal_unset_lock(mal_contextLock, "bpm");
	return MAL_SUCCEED;
}


@-
The remainder contains the implementation.
@c
str
BPMclose(int *ret)
{
	(void) ret;
    mal_set_lock(mal_contextLock, "bpm");
	/* save the partition table structure */
    mal_unset_lock(mal_contextLock, "bpm");
	throw(MAL, "bpm.close","NYI");
}

str
BPMdestroy(int *ret)
{
	(void) ret;
    mal_set_lock(mal_contextLock, "bpm");
	/* remove a partition table */
    mal_unset_lock(mal_contextLock, "bpm");
	throw(MAL, "bpm.destroy","NYI");
}
@-
Before you enter a BAT for partitioning
we should assure it is not already partitioned.
@c
str
BPMdeposit(bat *ret, str *nme, bat *src)
{
	BAT *b,*bn,*ba;
	int i;
	Partition p;

	BPMopen();

	/* test for duplicate names */
	i= getPartitionName(*nme);
	if( i)
		throw(MAL,"pbm.deposit","Duplicate partitioned BAT");
	/* get target bat */
	@:getBATdescriptor(src,b,"bpm.deposit");

	i= getAliasIndex(b->batCacheid);
	if( i != 0){
		BBPunfix(b->batCacheid);
		throw(MAL,"pbm.deposit","Duplicate partitioned BAT");
	}
	/* we can enter a new partition */
	/* create persistent alias bat*/
	ba= BATnew( b->htype,b->ttype,1024); 
	if( ba == 0){
		BBPunfix(b->batCacheid);
		throw(MAL,"pbm.deposit","Can not create partitioned BAT");
	}

	bn= BATcopy(b, b->htype,b->ttype,1);
	if( bn == 0){
		BBPunfix(b->batCacheid);
		throw(MAL,"pbm.deposit","Can not create partitioned BAT");
	}

	i= getFreeAlias();
	p= bpmcat+i;
	p->name= GDKstrdup(*nme);
	BBPkeepref(p->alias= ba->batCacheid);
	BBPkeepref(p->bid= bn->batCacheid);
	BBPincref(ba->batCacheid,TRUE);
	*ret= ba->batCacheid;

	/* default range */
	VALset(&p->hlow, b->htype, ATOMnil(b->htype) );
	VALset(&p->hhgh, b->htype, ATOMnil(b->htype) );
	VALset(&p->tlow, b->ttype, ATOMnil(b->ttype) );
	VALset(&p->thgh, b->ttype, ATOMnil(b->ttype) );

	/* default hash */
	p->hbits= p->tbits= 0;

	p->nxt = p->prv = 0;

#ifdef _DEBUG_BPM_
	stream_printf(GDKout,"Enter the partition '%s' at %d\n",*nme,i);
	BPMprintRecord(GDKout,p);
#endif

	BBPunfix(b->batCacheid);
	return MAL_SUCCEED;
}

@-
Given a particular partition, split it into two
pieces based on the val referenced
@c
str
BPMsplitpartition(bat *ret, bat *bid, ptr val)
{
	BAT *b,*bn, *bdiff;
	int is,i;
	Partition ps, p;

	BPMopen();

	is= getPartitionIndexNoAlias(*bid);
	if( is == 0)
		throw(MAL,"pbm.split","Partitioned BAT not found");
	ps = bpmcat + is;
	@:getBATdescriptor(&ps->bid,b,"bpm.splitPartition");

	/* TO DO val should be between tlow and thigh */

	/* we can enter a new partition */
	bn= BAT_select_(b, val, (ptr) &(ps->thgh), TRUE, FALSE, TRUE, FALSE);

	if( bn == 0){
		BBPunfix(b->batCacheid);
		throw(MAL,"pbm.split","Can not create new partition");
	}
	BBPkeepref(*ret= bn->batCacheid);

	i= getFreeAlias();
	p= bpmcat+i;
	p->name= GDKstrdup(ps->name);
	p->alias= ps->alias;
	p->bid= bn->batCacheid;

	/* link to the partition chain */
	p->nxt= ps->nxt;
	ps->nxt = i;
	p->prv = is;
	bpmcat[p->nxt].prv = i;

	/* for now assume only partitioning on tail. Range on head remains as in the orig. */
	VALset(&p->hlow, b->htype, &ps->hlow );
	VALset(&p->hhgh, b->htype, &ps->hhgh  );
	VALset(&p->tlow, b->ttype, val );
	VALset(&p->thgh, b->ttype, &ps->thgh );

	VALset(&ps->thgh, b->ttype, val );

	/* default hash */
	p->hbits= ps->hbits;
	p->tbits= ps->tbits;

	
#ifdef _DEBUG_BPM_
	stream_printf(GDKout,"New partition '%s' at %d\n",p->name,i);
	BPMprintRecord(GDKout,p);
#endif

	bdiff = BATkdiff(b,bn); /* assume unique heads */
	BBPkeepref( ps->bid = bdiff->batCacheid);

	BBPunfix(b->batCacheid);
/*	BBPunfix(bn->batCacheid);*/
	return MAL_SUCCEED;
}

@-
Range partitioning simply runs through all partitions
and creates new ones, keeping the partitions in order.
The 'critical' part is to detect overlap of the range
and the bounds of the partition.
@c
str
BPMrange(bat *ret, bat *bid, ptr low, ptr hgh){
	BAT *b;
	int i, tpe, r, *sb;
	int (*cmp) (ptr, ptr);
	ptr nilptr, tmp;
	int low_nil, hgh_nil;
	Partition p;

	BPMopen();

	p= getAlias(*bid);
	if( p==0){
		throw(MAL, "bpm.range","Partition not known");
	}
	@:getBATdescriptor(&p->bid,b,"bpm.range")@

	/* get the comparison function */
	tpe= *bid >0? b->ttype:b->htype;
	cmp= BATatoms[tpe].atomCmp;
	nilptr = ATOMnilptr(tpe);
	low_nil = ((*cmp) (low, nilptr) == 0);
	hgh_nil = ((*cmp) (hgh, nilptr) == 0);

	BBPunfix(b->batCacheid);	/* don't need it anymore */

	if (!low_nil && !hgh_nil && (*cmp)(hgh, low) < 0 ) {
		tmp = low; low = hgh; hgh = tmp;	
	}

	for( i= getAliasIndex(*bid); i ; i= bpmcat[i].nxt){
		sb = &bpmcat[i].bid;
		@:getBATdescriptor(sb,b,"bpm.range")@

		/* overlap by excluding outliers */
		if( *bid > 0 ){
			if( ((*cmp) ((ptr)&bpmcat[i].thgh, nilptr)!=0 &&
			     (*cmp) ((ptr) &bpmcat[i].thgh, low) < 0) ||
			    ((*cmp) ((ptr)&bpmcat[i].tlow, nilptr)!=0 &&
			     (*cmp) ((ptr) &bpmcat[i].tlow, hgh) > 0) 
			){
				/* this fragment need not be split */
			} else {
				/* break the fragment */

				if (!low_nil && 
				    ((*cmp)((ptr)&bpmcat[i].tlow, nilptr)==0 ||
				    (*cmp)((ptr) &bpmcat[i].tlow, low) < 0)  &&
				    ((*cmp) ((ptr)&bpmcat[i].thgh, nilptr)==0 ||
				    (*cmp)((ptr) &bpmcat[i].thgh, low) > 0) ) {
				
					BPMsplitpartition(&r,sb,low);
					sb=&r;
				}
				
				if (!hgh_nil && 
				   ((*cmp)((ptr)&bpmcat[i].tlow, nilptr)==0 ||
				    (*cmp)((ptr) &bpmcat[i].tlow, hgh) < 0)  &&
				    ((*cmp) ((ptr)&bpmcat[i].thgh, nilptr)==0 ||
				    (*cmp)((ptr) &bpmcat[i].thgh, hgh) > 0) )
				BPMsplitpartition(&r,sb,hgh);	

#ifdef _DEBUG_BPM_
				stream_printf(GDKout, "break fragment %d\n",i);
#endif
			}
		} else {
			/* use reversed bat */
			if( (*cmp) ((ptr) &bpmcat[i].hhgh, low) < 0 ||
				(*cmp) ((ptr) &bpmcat[i].hlow, hgh) > 0 
			){
				/* this fragment need not be split */
			} else {
#ifdef _DEBUG_BPM_
				stream_printf(GDKout, "break fragment %d\n",i);
#endif
				/* break the fragment */
			}
		}
		BBPunfix(b->batCacheid);
	}
	*ret= 0;
	return MAL_SUCCEED;
}
@-
The vector approach could either use a single column
of ordered split points, or a double column with (low,hgh)
value pairs. (STILL TO BE DECIDED)
We should ensure that the range vector is sorted first.
@c

str
BPMrangeVector(bat *ret, bat *bid, bat *pv)
{
	BAT *b, *bpv, *bnew, *b0;
	BUN cur,q;
	int i,inew,tpe, k=0,j;
	int tlow_nil, thgh_nil;
	Partition pprev, p, pnew;
	int (*cmp) (ptr, ptr);
	ptr nilptr, val;
	ptr * v;

	BPMopen();

/*	i= getPartitionIndexNoAlias(*bid); */
	i= getAliasIndex(*bid);
	if( i == 0)
		throw(MAL,"bpm.rangeVector","Partitioned BAT not found");
	if(bpmcat[i].nxt)
		throw(MAL,"bpm.rangeVector","Applies only on a single BAT");
	p = bpmcat + i;
	@:getBATdescriptor(&p->bid,b,"bpm.rangeVector");

	@:getBATdescriptor(pv,bpv,"bpm.range")@
	if( bpv == 0){
		BBPunfix(b->batCacheid);
		throw(MAL,"bpm.range","Cannot access BAT");
	}

	tpe= p->bid >0? b->ttype:b->htype;
	cmp= BATatoms[tpe].atomCmp;
	nilptr = ATOMnilptr(tpe);
	
	tlow_nil = ((*cmp)((ptr)&bpmcat[i].tlow, nilptr)==0);
	thgh_nil = ((*cmp)((ptr)&bpmcat[i].thgh, nilptr)==0);

	v= (ptr *) GDKzalloc(sizeof(ptr)*(BATcount(bpv)+2));
	/*if (! tlow_nil)  */
	v[k++]=(ptr)&bpmcat[i].tlow;
		 
	BATloop(bpv,cur,q){
		val= BUNtail(bpv,cur);
		/* check for overlap: tlow <= val < thgh */
		if ((*cmp) (val, nilptr) != 0 && 
		   (tlow_nil || 
		    (!tlow_nil && (*cmp)(val,(ptr)&p->tlow)>=0)) &&
		   (thgh_nil || 
		    (!thgh_nil && (*cmp)(val,(ptr)&p->thgh)<0)))
		v[k++]=val;
	}
	/*if (! thgh_nil) */
	v[k++]=(ptr)&bpmcat[i].thgh;

	pprev=p;
	/*to do check when it is necessary */
	for( j=1;j<k-1;j++){
		/*new partition [v[j], v[j+1]) */
		bnew= BAT_select_(b, v[j], v[j+1], TRUE, FALSE, TRUE, FALSE);
		if( bnew == 0)
			throw(MAL,"pbm.split","Can not create new partition");
		inew= getFreeAlias();
		pnew= bpmcat+inew;
		BBPkeepref(pnew->bid= bnew->batCacheid);
		pnew->name= GDKstrdup(p->name);
		pnew->alias= p->alias;

		/* link to the partition chain */
		pnew->nxt= pprev->nxt;
		pprev->nxt = inew;
		pnew->prv = pprev-bpmcat;
		bpmcat[pnew->nxt].prv = inew;

		VALset(&pnew->hlow, b->htype, &p->hlow );
		VALset(&pnew->hhgh, b->htype, &p->hhgh  );
		VALset(&pnew->tlow, b->ttype, v[j] );
		VALset(&pnew->thgh, b->ttype, v[j+1] );
	
		/* default hash */
		pnew->hbits= pnew->tbits= 0;
		pprev=pnew;
	}

	/*first partition [tlow, v[0]) replaces the original bid */
	b0= BAT_select_(b, v[0], v[1], TRUE, FALSE, TRUE, FALSE);
	if( b0 == 0){
		BBPunfix(b->batCacheid);
		BBPunfix(bpv->batCacheid);
		GDKfree(v);
		throw(MAL,"pbm.split","Can not create new partition");
	}
	BBPkeepref( p->bid=  b0->batCacheid);
	VALset(&p->thgh, b0->ttype, v[1]);
	
	BBPunfix(b->batCacheid);
	BBPunfix(bpv->batCacheid);

	GDKfree(v);
	*ret= 0;
	return MAL_SUCCEED;
}


str
BPMaddPartition(bat *ret, str *nme, bat *src)
{
	BAT *b,*bn;
	int i,j;
	Partition p;

	BPMopen();

	/* test for new name */
	i= getPartitionName(*nme);
	if( i==0)
		return BPMdeposit(ret,nme,src);

	@:getBATdescriptor(src,b,"bpm.deposit");

	j= getPartitionIndexNoAlias(b->batCacheid);
	if( j != 0){
		BBPunfix(b->batCacheid);
		throw(MAL,"bpm.addPartition","Duplicate partitioned BAT");
	}
	/* we can add a new partition in the chain with name nme */
	bn= BATcopy(b, b->htype,b->ttype,1);
	if( bn == 0){
		BBPunfix(b->batCacheid);
		throw(MAL,"bpm.addPartition","Cannot add partition");
	}
	BBPkeepref(*ret= bn->batCacheid);

	j= getFreeAlias();
	p= bpmcat+j;
	p->name= GDKstrdup(*nme);
	p->bid= bn->batCacheid;
	p->nxt = 0;

	while( bpmcat[i].nxt) i=  bpmcat[i].nxt;
	p->prv = i;
	bpmcat[i].nxt = j;
	p->alias = bpmcat[i].alias;

	/* default range */
	VALset(&p->hlow, b->htype, ATOMnil(b->htype) );
	VALset(&p->hhgh, b->htype, ATOMnil(b->htype) );
	VALset(&p->tlow, b->ttype, ATOMnil(b->ttype) );
	VALset(&p->thgh, b->ttype, ATOMnil(b->ttype) );

	/* default hash */
	p->hbits= p->tbits= 0;

#ifdef _DEBUG_BPM_
	stream_printf(GDKout,"Added partition '%s' at %d\n",*nme,j);
	BPMprintRecord(GDKout,p);
#endif

	BBPunfix(b->batCacheid);
	return MAL_SUCCEED;
}


str
BPMaddPartitionDim(bat *ret, str *nme, bat *src, ptr hl, ptr hh, ptr tl, ptr th)
{
	int i;
	BAT *b;
	bat bt;
	Partition p;

	BPMaddPartition(ret,nme,src);
	bt=*ret;
	if( bt ==0){
		throw(MAL,"bpm.addPartitionDim","Partition not created");
	}
	
	i= getPartitionIndexNoAlias(bt);
	p= bpmcat+i;
	@:getBATdescriptor(&bt,b,"bpm.addpartitiondim");

	/* default range */
	VALset(&p->hlow, b->htype, hl );
	VALset(&p->hhgh, b->htype, hh );
	VALset(&p->tlow, b->ttype, tl );
	VALset(&p->thgh, b->ttype, th );

	BBPunfix(b->batCacheid);
	return MAL_SUCCEED;
}


str
BPMhash(bat *ret, bat *bid, int *bits)
{
	BAT *b;
	BPMopen();
	@:getBATdescriptor(bid,b,"bpm.hash")@
	/* get hash slot administration */
	(void) b;
	(void) bits;
	*ret= 0;
	throw(MAL, "bpm.hash","NYI");
}
str
BPMderived(bat *ret, bat *bid, bat *src)
{
	BAT *b;
	BPMopen();
	@:getBATdescriptor(bid,b,"bpm.derived")@
	/* partition into two direction */
	(void) b;
	(void) src;
	*ret= 0;
	throw(MAL, "bpm.derived","NYI");
}
@-
Takeing out partitions.
@c
str
BPMtake(bat *ret, str *nme)
{
	int i;
	BPMopen();
	i= getPartitionName(*nme);
	if( i== 0){
		throw(MAL,"pbm.take","Partitioned BAT does not exist");
	}
	*ret = bpmcat[i].alias;
	return MAL_SUCCEED;
}
str
BPMtakePartition(bat *ret, bat *bid, int *index)
{
	int i,j;

	BPMopen();
	i= getAliasIndex(*bid);
	if( i== 0){
		throw(MAL,"pbm.take","Partitioned BAT does not exist");
	}

	for(j=1;i && j<*index;j++,i=bpmcat[i].nxt);
	if(i== 0){
		throw(MAL,"pbm.takePartition","No partition number %d",*index);
	} 
	*ret =bpmcat[i].bid;
	BBPincref(bpmcat[i].bid,TRUE);
	return MAL_SUCCEED;
}

@- Updates
The update operations simply loop through the partitions
and apply the results. We can optimize this by inspection
of the range tables, but that is considered relevant in a distributed
case.
The updates are merely convenient operators, because ideally
the optimizer already filters out the partitions of interest.
@c
str
BPMinsert(bat *ret, bat *bid, bat *ins)
{
	int i;
	str msg= MAL_SUCCEED;
	Partition p;

	BPMopen();
	p= getAlias(*bid);
	if( p== 0)
		throw(MAL,"bpm.insert","Can not access partitioned BAT");
	/* distributed the content */
	for(i= p->bid ; i && msg== MAL_SUCCEED; i= bpmcat[i].nxt){
		msg=BKCinsert_bat(ret,&bpmcat[i].bid,ins);
	}
	*ret= 0;
	return msg;
}

str
BPMdelete(bat *ret, bat *bid, bat *del)
{
	int i;
	Partition p;
	str msg= MAL_SUCCEED;

	BPMopen();
	p= getAlias(*bid);
	if( p== 0)
		throw(MAL,"bpm.insert","Can not access partitioned BAT");
	/* distributed the content */
	for( i= getAliasIndex(*bid); i && msg== MAL_SUCCEED; i= bpmcat[i].nxt){
		msg=BKCdelete_bat(ret,&bpmcat[i].bid,del);
	}
	*ret= 0;
	return msg;
}

str
BPMreplace(bat *ret, bat *bid, bat *ins, bat *del)
{
	int i;
	Partition p;
	str msg= MAL_SUCCEED;

	BPMopen();
	p= getAlias(*bid);
	if( p== 0)
		throw(MAL,"bpm.insert","Can not alias BAT");
	/* distributed the content */
	for( i = getAliasIndex(*bid) ; i && msg== MAL_SUCCEED; i= bpmcat[i].nxt){
		msg=BKCdelete_bat(ret,&bpmcat[i].bid,del);
		if( msg == MAL_SUCCEED)
			msg=BKCinsert_bat(ret,&bpmcat[i].bid,ins);
	}
	*ret= 0;
	return msg;
}

str
BPMgetNames(bat *ret)
{
	BAT *b;
	int i,j;
	sht *m;

	BPMopen();
	b = BATnew(TYPE_int, TYPE_str, BBPsize);
	if (b == 0)
        	throw(MAL, "catalog.bbpNames", "failed to create BAT");
	
	m= (sht *) GDKzalloc(sizeof(sht)*bpmcattop);
	for(i=1; i<bpmcattop; i++)
		if (!m[i]) {
			BUNins(b, &i, bpmcat[i].name,TRUE);
			for(j=i;j;j=bpmcat[j].nxt) m[j]=1;
			for(j=bpmcat[i].prv;j;j=bpmcat[j].prv) m[j]=1;
		}
	
	BBPkeepref(*ret = b->batCacheid);
	if (!(b->batDirty&2)) 
		b = BATsetaccess(b, BAT_READ);
	GDKfree(m);
	return MAL_SUCCEED;
}

str
BPMdiscard(int *ret, bat *bid)
{
	int i,r;
	str msg= MAL_SUCCEED;

	BPMopen();
	i= getAliasIndex(*bid);
	if( i== 0)
		throw(MAL,"bpm.discard","Can not alias BAT");
	/* discard the content */
	for( ; i && msg== MAL_SUCCEED; i= bpmcat[i].nxt){
		BBPdecref(bpmcat[i].bid,TRUE);	
	/*	msg= BKCdestroy(&r, &bpmcat[i].bid); */
		msg= BKCsetTransient(&r,&bpmcat[i].bid);
		bpmcat[i].alias = 0;	/* free entry */
		GDKfree(bpmcat[i].name);
	}
	BBPdecref(*bid,TRUE);	
	msg= BKCsetTransient(&r,bid);

	*ret =0;
	return MAL_SUCCEED;
}

str
BPMdiscardAll(int *ret)
{
	int i,r,al;
	str msg= MAL_SUCCEED;

	BPMopen();

	for( i=1; i<bpmcattop; i++)
	   if((al=bpmcat[i].alias)){
		 if (BBP_lrefs(al) > 0) {
			BBPdecref(al,TRUE);	
			msg= BKCsetTransient(&r,&al);
		}
		BBPdecref(bpmcat[i].bid,TRUE);	
		msg= BKCsetTransient(&r,&bpmcat[i].bid);
		bpmcat[i].alias = 0;	
		GDKfree(bpmcat[i].name);
	}

	*ret =0;
	return MAL_SUCCEED;
}

@- Iterations
We start with the large chunk iterator.
The definition of the control statements require the same
control variables, which means that the BATview is accessible
to determine how far to advance when the next chunk is retrieved.
The number of elements in the chunk is limited by the granule
size.

Iterations over partitioned BATs can be valued constrainted.
@c
str
BPMnewIterator(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	bat *ret, *bid;
	Partition p;
	(void) mb;

	ret= (bat *)getArgReference(stk, pci, 0);
	bid= (bat *)getArgReference(stk, pci, 1);
	
	BPMopen();
	p= getAlias(*bid);
	
	if( p== 0)
		throw(MAL,"bpm.newIterator","Can not alias BAT");

	*ret = p->bid;
	BBPincref(p->bid,TRUE);
	return MAL_SUCCEED;
}

str
BPMnewIteratorRng(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	bat *ret, *bid;
	Partition p;
	BAT *b;
	int i, tpe, low_nil, hgh_nil;
	int (*cmp) (ptr, ptr);
	ptr nilptr, low, hgh;
	(void) mb;

	ret= (bat *)getArgReference(stk, pci, 0);
	bid= (bat *)getArgReference(stk, pci, 1);
	low= (ptr) getArgReference(stk, pci, 2);
	hgh= (ptr) getArgReference(stk, pci, 3);

	BPMopen();
	p= getAlias(*bid);
	
	if( p==0)
		throw(MAL,"bpm.newIterator","Can not alias BAT");
	@:getBATdescriptor(&p->bid,b,"bpm.newIterator")@

	/* get the comparison function */
	tpe= p->bid >0? b->ttype:b->htype;
	cmp= BATatoms[tpe].atomCmp;
	nilptr = ATOMnilptr(tpe);
	low_nil = ((*cmp) (low, nilptr) == 0);
	hgh_nil = ((*cmp) (hgh, nilptr) == 0);

	BBPunfix(b->batCacheid);	/* don't need it anymore */

	for( i= getAliasIndex(*bid); i ; i= bpmcat[i].nxt){
		@:getBATdescriptor(&bpmcat[i].bid,b,"bpm.range")@

		/* determine overlap by excluding outliers */
		if( bpmcat[i].bid > 0 ){
			if (((*cmp) ((ptr)&bpmcat[i].thgh, nilptr)!=0 &&
			     !low_nil && 
			     (*cmp) ((ptr) &bpmcat[i].thgh, low) <= 0 ) ||
			    ((*cmp) ((ptr)&bpmcat[i].tlow, nilptr)!=0 &&
			     !hgh_nil &&
			     (*cmp) ((ptr) &bpmcat[i].tlow, hgh) > 0) 
			){
				/* this fragment is not needed*/
			} else {
#ifdef _DEBUG_BPM_
				stream_printf(GDKout, "got matching fragment %d\n",i);
#endif
				BBPkeepref(*ret= b->batCacheid);
				return MAL_SUCCEED;
			}
		} else {
				/* use reversed bat */
			if (((*cmp) ((ptr)&bpmcat[i].hhgh, nilptr)!=0 &&
			     !low_nil && 
			     (*cmp) ((ptr) &bpmcat[i].hhgh, low) <= 0 ) ||
			    ((*cmp) ((ptr)&bpmcat[i].hlow, nilptr)!=0 &&
			     !hgh_nil &&
			     (*cmp) ((ptr) &bpmcat[i].hlow, hgh) > 0) 
			){
				/* this fragment is not needed*/
			} else {
#ifdef _DEBUG_BPM_
				stream_printf(GDKout, "got matching fragment %d\n",i);
#endif
				BBPkeepref(*ret= b->batCacheid);
				return MAL_SUCCEED;
			}
		}
		BBPunfix(b->batCacheid);
	}
	*ret= 0;
	return MAL_SUCCEED;
}


str
BPMnewIteratorRng4(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	(void) mb;
	(void) stk;
	(void) pci;
	throw(MAL, "bpm.newIterator","NYI");
}

@-
For the iteration we assume that the bid is already
a correct element in the paritition list.

@c
str
BPMhasMoreElements(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	bat *ret, *bid;
	int i,idx;
	(void) mb;

	ret= (bat *)getArgReference(stk, pci, 0);
	bid= (bat *)getArgReference(stk, pci, 1);

	BPMopen();
	i= getPartitionIndex(*bid, *ret);
	idx= bpmcat[i].nxt;
	if( idx == 0){
		*ret= 0;
		return MAL_SUCCEED;
	}

	*ret = bpmcat[idx].bid;
	BBPincref(bpmcat[idx].bid,TRUE);

	return MAL_SUCCEED;
}

str
BPMhasMoreElementsRng(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	bat *ret, *bid;
	BAT *b;
	int i, tpe, low_nil, hgh_nil;
	int (*cmp) (ptr, ptr);
	ptr nilptr, low, hgh;
	(void) mb;

	ret= (bat *)getArgReference(stk, pci, 0);
	bid= (bat *)getArgReference(stk, pci, 1);
	low= (ptr) getArgReference(stk, pci, 2);
	hgh= (ptr) getArgReference(stk, pci, 3);

	BPMopen();

	/* get last returned partition */
	i= getPartitionIndex(*bid, *ret);
	if(i==0)
		throw(MAL,"bpm.hasMoreElements","No more partitions");
	@:getBATdescriptor(&bpmcat[i].bid,b,"bpm.newIterator")@

	/* get the comparison function */
	tpe= bpmcat[i].bid >0? b->ttype:b->htype;
	cmp= BATatoms[tpe].atomCmp;
	nilptr = ATOMnilptr(tpe);
	low_nil = ((*cmp) (low, nilptr) == 0);
	hgh_nil = ((*cmp) (hgh, nilptr) == 0);

	BBPunfix(b->batCacheid);	/* don't need it anymore */

	for( i= bpmcat[i].nxt; i ; i= bpmcat[i].nxt){
		@:getBATdescriptor(&bpmcat[i].bid,b,"bpm.range")@

		/* determine overlap by excluding outliers */
		if( bpmcat[i].bid > 0 ){
			if (((*cmp) ((ptr)&bpmcat[i].thgh, nilptr)!=0 &&
			     !low_nil && 
			     (*cmp) ((ptr) &bpmcat[i].thgh, low) < 0 ) ||
			    ((*cmp) ((ptr)&bpmcat[i].tlow, nilptr)!=0 &&
			     !hgh_nil &&
			     (*cmp) ((ptr) &bpmcat[i].tlow, hgh) > 0) 
			){
				/* this fragment is not needed*/
			} else {
#ifdef _DEBUG_BPM_
				stream_printf(GDKout, "got matching fragment %d\n",i);
#endif
				BBPkeepref(*ret= b->batCacheid);
				return MAL_SUCCEED;
			}
		} else {
				/* use reversed bat */
			if (((*cmp) ((ptr)&bpmcat[i].hhgh, nilptr)!=0 &&
			     !low_nil && 
			     (*cmp) ((ptr) &bpmcat[i].hhgh, low) < 0 ) ||
			    ((*cmp) ((ptr)&bpmcat[i].hlow, nilptr)!=0 &&
			     !hgh_nil &&
			     (*cmp) ((ptr) &bpmcat[i].hlow, hgh) > 0) 
			){
				/* this fragment is not needed*/
			} else {
#ifdef _DEBUG_BPM_
				stream_printf(GDKout, "got matching fragment %d\n",i);
#endif
				BBPkeepref(*ret= b->batCacheid);
				return MAL_SUCCEED;
			}
		}
		BBPunfix(b->batCacheid);
	}
	*ret= 0;
	return MAL_SUCCEED;

}


str
BPMhasMoreElementsRng4(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	(void) mb;
	(void) stk;
	(void) pci;
	throw(MAL, "bpm.newIterator","NYI");
}

str
BPMgetDimension(ptr *first, ptr *last, ptr *vlow, ptr *vhgh, int *bid)
{
	(void) first;
	(void) last;
	(void) vlow;
	(void) vhgh;
	(void) bid;
	throw(MAL, "bpm.getDimension","NYI");
}

str
BPMdump(int *ret)
{
	int i;
	for( i=1; i<bpmcattop; i++)
	if( bpmcat[i].alias)
		BPMprintRecord(GDKout, bpmcat+i);
	(void) ret;
	return MAL_SUCCEED;
}
str
BPMdumpAlias(int *ret, bat *bid)
{
	Partition p;
	int i;
	p= getAlias(*bid);
	if(p == 0)
		throw(MAL,"bpm.dump", "Partitioned BAT does not exist");

	for( i= getAliasIndex(*bid); i; i= bpmcat[i].nxt)
	if( bpmcat[i].bid)
		BPMprintRecord(GDKout, bpmcat+i);
	(void) ret;
	return MAL_SUCCEED;
}

@= getBPMbat
if (idx == 0) {
	b = BATnew(TYPE_int, TYPE_@2, bpmcattop);
	if (b == 0)
	throw(MAL, "bpm.map@1", "failed to create BAT");
	idx= b->batCacheid;
	msg= BKCsetName(&r,(int *)&idx, &nm);
	if( msg != MAL_SUCCEED) return msg;
		
}else {
	BKCdelete_all(&r,&idx);
	b = BATdescriptor(idx);
	if (b == 0)
	throw(MAL, "bpm.map@1", "failed to get bpm_@1 BAT");
}
@c

str
BPMmapName(int *ret)
{
	BAT *b;
	bat idx;
	int i,r;
	str msg = MAL_SUCCEED, nm="bpm_name";

	idx= BBPindex(nm);
	@:getBPMbat(Name,str)@

	for(i=1; i< bpmcattop; i++)
		if( bpmcat[i].alias)
	 		BUNins(b, &i, bpmcat[i].name, FALSE);

	msg= BKCsetPersistent(&r,(int *)&idx);
	if( msg != MAL_SUCCEED) return msg;
		
/* Which is preferable?	BATmode(b,PERSISTENT);*/

	*ret = b->batCacheid;
	BBPkeepref(*ret);
	return MAL_SUCCEED;
}

str
BPMmapBid(int *ret)
{
	BAT *b;
	bat idx;
	int i,r;
	str msg = MAL_SUCCEED, nm="bpm_bid";

	idx= BBPindex(nm);
	@:getBPMbat(Bid,int)@

	for(i=1; i< bpmcattop; i++)
		if( bpmcat[i].alias)
	 		BUNins(b, &i, &bpmcat[i].bid, FALSE);

	msg= BKCsetPersistent(&r,(int *)&idx);
	if( msg != MAL_SUCCEED) return msg;

	*ret = b->batCacheid;
	BBPkeepref(*ret);
	return MAL_SUCCEED;
}

str
BPMmapAlias(int *ret)
{
	BAT *b;
	bat idx;
	int i,r;
	str msg = MAL_SUCCEED, nm="bpm_alias";

	idx= BBPindex(nm);
	@:getBPMbat(Alias,int)@

	for(i=1; i< bpmcattop; i++)
		if( bpmcat[i].alias)
	 		BUNins(b, &i, &bpmcat[i].alias, FALSE);

	msg= BKCsetPersistent(&r,(int *)&idx);
	if( msg != MAL_SUCCEED) return msg;
		
	*ret = b->batCacheid;
	BBPkeepref(*ret);
	return MAL_SUCCEED;
}

str
BPMmapNxt(int *ret)
{
	BAT *b;
	bat idx;
	int i,r;
	str msg = MAL_SUCCEED, nm="bpm_nxt";

	idx= BBPindex(nm);
	@:getBPMbat(Nxt,int)@

	for(i=1; i< bpmcattop; i++)
		if( bpmcat[i].alias)
	 		BUNins(b, &i, &bpmcat[i].nxt, FALSE);
		
	msg= BKCsetPersistent(&r,(int *)&idx);
	if( msg != MAL_SUCCEED) return msg;

	*ret = b->batCacheid;
	BBPkeepref(*ret);
	return MAL_SUCCEED;
}


str
BPMmapPrv(int *ret)
{
	BAT *b;
	bat idx;
	int i,r;
	str msg = MAL_SUCCEED, nm="bpm_prv";

	idx= BBPindex(nm);
	@:getBPMbat(Prv,int)@

	for(i=1; i< bpmcattop; i++)
		if( bpmcat[i].alias)
	 		BUNins(b, &i, &bpmcat[i].prv, FALSE);

	msg= BKCsetPersistent(&r,(int *)&idx);
	if( msg != MAL_SUCCEED) return msg;
		
	*ret = b->batCacheid;
	BBPkeepref(*ret);
	return MAL_SUCCEED;
}

int nilval(ValPtr v)
{
	int tpe; 
	int (*cmp) (ptr, ptr);
	ptr nilptr;

	tpe= v->vtype;
	cmp= BATatoms[tpe].atomCmp;
	nilptr = ATOMnilptr(tpe);
	if ((*cmp) ((ptr)v, nilptr)==0) return 1;
	else return 0;
}

str
BPMmapTlowLng(int *ret)
{
	BAT *b;
	int i,t,r;
	lng val;
	ValPtr v;
	bat idx;
	str msg = MAL_SUCCEED, nm="bpm_tlowlng";

	idx= BBPindex(nm);
	@:getBPMbat(TlowLng,lng)@

	for(i=1; i< bpmcattop; i++)
		if( bpmcat[i].alias){
			v= &bpmcat[i].tlow;
			if (!nilval(v)){
				t= v->vtype;
				switch  (ATOMstorage(t)) {
					case TYPE_int: 	val= *(int *)VALget(v);
							BUNins(b, &i, &val, FALSE);
							break;
			    		case TYPE_sht: 	val= *(sht *)VALget(v);
							BUNins(b, &i, &val, FALSE);
							break;
					case TYPE_lng: 	val= *(lng *)VALget(v);
							BUNins(b, &i, &val, FALSE);
					}
			}
		}

	msg= BKCsetPersistent(&r,(int *)&idx);
	if( msg != MAL_SUCCEED) return msg;

	*ret = b->batCacheid;
	BBPkeepref(*ret);
	return MAL_SUCCEED;
}


str
BPMmapTlowDbl(int *ret)
{
	BAT *b;
	int i,t,r;
	dbl val;
	ValPtr v;
	bat idx;
	str msg = MAL_SUCCEED, nm="bpm_tlowdbl";

	idx= BBPindex(nm);
	@:getBPMbat(TlowDbl,dbl)@	

	for(i=1; i< bpmcattop; i++)
		if( bpmcat[i].alias){
			v= &bpmcat[i].tlow;
			if (!nilval(v)){
			t= v->vtype;
			switch  (ATOMstorage(t)) {
				case TYPE_dbl: 	val= *(dbl *)VALget(v);
						BUNins(b, &i, &val, FALSE);
						break;
			    	case TYPE_flt: 	val= *(flt *)VALget(v);
						BUNins(b, &i, &val, FALSE);
						break;
			}}
		
		}

	msg= BKCsetPersistent(&r,(int *)&idx);
	if( msg != MAL_SUCCEED) return msg;

	*ret = b->batCacheid;
	BBPkeepref(*ret);
	return MAL_SUCCEED;
}

str
BPMmapThghLng(int *ret)
{
	BAT *b;
	int i,t,r;
	lng val;
	ValPtr v;
	bat idx;
	str msg = MAL_SUCCEED, nm="bpm_thghlng";

	idx= BBPindex(nm);
	@:getBPMbat(ThghLng,lng)@

	for(i=1; i< bpmcattop; i++)
		if( bpmcat[i].alias){
			v= &bpmcat[i].thgh;
			if (!nilval(v)){
				t= v->vtype;
				switch  (ATOMstorage(t)) {
					case TYPE_int: 	val= *(int *)VALget(v);
							BUNins(b, &i, &val, FALSE);
							break;
			    		case TYPE_sht: 	val= *(sht *)VALget(v);
							BUNins(b, &i, &val, FALSE);
							break;
					case TYPE_lng: 	val= *(lng *)VALget(v);
							BUNins(b, &i, &val, FALSE);
					}
			}
		}

	msg= BKCsetPersistent(&r,(int *)&idx);
	if( msg != MAL_SUCCEED) return msg;

	*ret = b->batCacheid;
	BBPkeepref(*ret);
	return MAL_SUCCEED;
}


str
BPMmapThghDbl(int *ret)
{
	BAT *b;
	int i,t,r;
	dbl val;
	ValPtr v;
	bat idx;
	str msg = MAL_SUCCEED, nm="bpm_thghdbl";

	idx= BBPindex(nm);
	@:getBPMbat(ThghDbl,dbl)@	

	for(i=1; i< bpmcattop; i++)
		if( bpmcat[i].alias){
			v= &bpmcat[i].thgh;
			if (!nilval(v)){
			t= v->vtype;
			switch  (ATOMstorage(t)) {
				case TYPE_dbl: 	val= *(dbl *)VALget(v);
						BUNins(b, &i, &val, FALSE);
						break;
			    	case TYPE_flt: 	val= *(flt *)VALget(v);
						BUNins(b, &i, &val, FALSE);
						break;
			}}
		
		}

	msg= BKCsetPersistent(&r,(int *)&idx);
	if( msg != MAL_SUCCEED) return msg;

	*ret = b->batCacheid;
	BBPkeepref(*ret);
	return MAL_SUCCEED;
}


str
BPMsavePartitions(int *r)
{	
	int i,len;
	bat bt,idx;
	BAT *tr;
	str nm;
	str msg=MAL_SUCCEED;


	/* store bat names to be comitted */
	tr = BATnew(TYPE_void, TYPE_str, bpmcattop+10);
	BATseqbase(tr,0);

	for(i=1; i< bpmcattop; i++)
		if( bpmcat[i].alias){
		   if (bpmcat[i].prv==0){ 
			/* save alias bat */
			bt = bpmcat[i].alias;
			len = strlen(bpmcat[i].name) + 5;
		        nm = GDKmalloc(len);
		        snprintf(nm, len, "bpm_%s",bpmcat[i].name);
			printf("Alias Name %s\n",nm);
		
			/* Check if the name exists already */
			idx= BBPindex(nm);
			if (idx == 0) {
				msg= BKCsetName(r,(int *) &bt,(str *) &nm);
				if( msg != MAL_SUCCEED) return msg;
			} else {
				if (bt!=idx)
				throw(MAL, "bpm.savePartitions", "Inconsistency in alias names");
			}
			msg= BKCsetPersistent(r,(int *)&bt);
			if( msg != MAL_SUCCEED) return msg;
			BUNappend(tr, BBPname(bt), FALSE);
			}

			bt=bpmcat[i].bid;
                                                                              
			len = strlen(bpmcat[i].name) + 30;
		        nm = GDKmalloc(len);
		        snprintf(nm, len, "bpm_%s%d",bpmcat[i].name, i);
			printf("Name %s\n",nm);
		
			/* Check if the name exists already */
			idx= BBPindex(nm);
			if (idx == 0) {
				msg= BKCsetName(r,(int *) &bt,(str *) &nm);
				if( msg != MAL_SUCCEED) return msg;
			} else {
				if (bt!=idx)
				throw(MAL, "bpm.savePartitions", "Inconsistency in partition names");
			}
	
			msg= BKCsetPersistent(r, (int *)&bt);
			if( msg != MAL_SUCCEED) return msg;
			BUNappend(tr, BBPname(bt), FALSE);
		}
	
	BPMmapName(&bt);
	BUNappend(tr, BBPname(bt), FALSE);
	BPMmapAlias(&bt);
	BUNappend(tr, BBPname(bt), FALSE);
	BPMmapBid(&bt);
	BUNappend(tr, BBPname(bt), FALSE);
	BPMmapNxt(&bt);
	BUNappend(tr, BBPname(bt), FALSE);
	BPMmapPrv(&bt);
	BUNappend(tr, BBPname(bt), FALSE);
	BPMmapTlowLng(&bt);
	BUNappend(tr, BBPname(bt), FALSE);
	BPMmapTlowDbl(&bt);
	BUNappend(tr, BBPname(bt), FALSE);
	BPMmapThghLng(&bt);
	BUNappend(tr, BBPname(bt), FALSE);
	BPMmapThghDbl(&bt);
	BUNappend(tr, BBPname(bt), FALSE);

	TMsubcommit(tr);
	BBPreclaim(tr);

	return MAL_SUCCEED;
}


@c
str
BPMprelude(int *ret)
{
    mal_set_lock(mal_contextLock, "bpm.prelude");
	*ret =0;
    mal_unset_lock(mal_contextLock, "bpm.prelude");
	return MAL_SUCCEED;
}
@-
In the epilogue phase we should discard any temporary MAT.
@c
str
BPMepilogue(int *ret)
{
	/* TODO: Make sure these are used. This is needed by icc only. And 
	   should be removed once the implementation matures.
	 */
	*ret =0;
	return MAL_SUCCEED;
}
