@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2006 CWI.
@' All Rights Reserved.

@f pbm
@v 0.2
@a M.L.Kersten
@* BAT Partition Manager
In real-life database applications the BATs tend to grow beyond
the memory size. This leads to a heavy IO dominated behavior,
which can partly be avoided by breaking up the query into a sequence
of subqueries using a map-reduce strategy.
The BAT partition manager (BPM) module is designed to 
support this strategy using range- and hash-partitioning.

Consider we want to reorganize R:bat[:void,:int] into three range partitions,
based on splitting on the head. Two partitions are stable
and the third partition is reserved for appends.
The following MAL program illustrates the snippet of actions needed:
@example
	bpm.open();
	bpm.deposit("myversion",R);	# creates side effects
	Ralias:= bpm.take("myversion",:bat[:void,:int]);
	bpm.rangePartition(Ralias,nil:oid,100:oid,nil:int,nil:int);
	bpm.rangePartition(Ralias,101:oid,200:oid,nil:int,nil:int);
	bpm.rangePartition(Ralias,201:oid,nil:oid,nil:int,nil:int);
	bpm.close();
@end example
The command @code{pbm.deposit} registers a BAT as one to be partitioned.
The remainder are the  partition definitions based
of slices from the table using a simple range condition.
The partitions share the persistency properties.

Beware that now there are four components R, R1, R2, and R3.
The BAT R is is turned into an empty bat, its content is
taken over by the bpm and broken into pieces.
The BAT R can be destroyed, because its partitioned version is retrieved
using the bpm name. The call @code{bpm.discard(Ralias)} removes all
partitions.

The partition manager also supports hash-based partitioning.
It accepts two arguments, which denote the number of hash buckets
on the head and tail respectively.
@example
	bpm.open();
	bpm.deposit("myHashVersion",R);	# creates side effects
	Ralias:= bpm.take("myHashVersion",:bat[:void,:int]);
	bpm.hashPartition(Ralias,5,2);
	bpm.close();
@end example
This example leads to 10 partitions.
Re-partitioning automatically occurs when a new hash size is given.

It should not come as a surprise, that a combination of
hashing and range is also provided using the
commands @code{bpm.hashRangePartition()} and @code{bpm.rangeHashPartition()}.

@- Using partitions
The partitioned BAT can be used in two ways. A query plan can be
rewritten into a generator over the partitions, or it can be
used by optimizers to derived all subqueries first.

The former is illustrated with the snippet to select part of
a partitioned BAT. In this example we collect the partial
results in the accumulator BAT tu.
@example
	bpm.open();
	R:= bpm.take("myversion",:bat[:void,:int]);
	tu:= bat.new(:void,:int);
barrier (idx,Rp):= bpm.newIterator(R);
	...
	t:= algebra.select(Rp,0,100);
	tu:= algebra.union(tu,t);
	...
	redo (idx,Rp):= bpm.hasMoreElements(R);
exit (idx,b);
	bpm.close();
@end example

The partitioned BATs are particularly useful during query
optimization. However, it only works if the BAT identifier
can be determined at compiler time. For SQL it can be simply looked up in
the catalog as part of the preparatory optimizer step.
The same problem handled by an optimizer produces the plan:
@example
	bpm.open();
	R:= bpm.take("myversion",:bat[:void,:int]); 
	R0:= bpm.take(R,0);	# get a specific partition
	tu:= algebra.select(R0,0,100);
	R1:= bpm.take(R,1);
	t1:= algebra.select(R0,0,100);
	tu:= algebra.union(tu,t1);
	R2:= bpm.take(R,2);
	t2:= algebra.select(R0,0,100);
	tu:= algebra.union(tu,t2);
@end example

A more interesting version is to make
the range information again visible in
the intermediate plan. This can be used by optimizers
for symbolic evaluation.
@example
	bpm.open();
	R:= bpm.take("myversion",:bat[:void,:int]);
	R0:= bpm.take(R, 0@0, 100@0, nil:int,nil:int); 
	tu:= algebra.select(R0,0,100);
	R1:= bpm.take(R, 101@0, 200@0, nil:int,nil:int); 
	t1:= algebra.select(R1,0,100);
	tu:= algebra.union(tu,t1);
	R2:= bpm.take(R, 201@0, nil:oid, nil:int,nil:int); 
	t2:= algebra.select(R2,0,100);
	tu:= algebra.union(tu,t2);
@end example

@- Partition selection
The select operation can be overloaded in the BPM to
improve processing further. For example, the operation
@example
	t := bpm.select(Ralias,0,100);
@end example
extracts portions of all three partitions and creates 
a partitioned result BAT. 
There is no information on the partitions involved in this operation
for the optimizer.

@- Partition updates
The content of the partitions is preferrable updated in bulk.
This calls for accumulation of insertions/deletions in pending
update BATs, as already performed in the SQL code generator.
Once the transaction is commited, the updates are propagated
(in parallel) to all partitions.
@example
	bpm.open();
	R := bpm.take("myversion",:bat[:void,:int]); # get the partition alias
	bpm.insert(R, Rinsert);	# handle pending inserts
	bpm.delete(R, Rdelete);	# handle pending deletes
	bpm.deposit(R, Rinsert);# handle pending inserts
	bpm.close();
@end example

The @code{bpm.deposit(R,Rinsert)} takes over the content
of the bat Rinsert, leaving a null BAT behind.
This does not hold for the insert and delete cases.

@- Partitioned results
In many situations, you would like to keep the partial results
as a partitioned BAT again.
The easiest solution is to create a partitioned BAT first,
whose partiotions are empty. Subsequently, we insert the
temporary results. 
Depending on the fragmentation criteria, pieces may align
with the pieces known, or lead to a redistribution of the
buns to the correct bats.

The previous plan for this becomes
@example
	bpm.open();
	Tmp := bpm.take("tmp",:bat[:void,:int]);
	bpm.rangePartition(Tmp,nil:oid,100:oid,nil:int,nil:int);
	bpm.rangePartition(Tmp,101:oid,200:oid,nil:int,nil:int);
	bpm.rangePartition(Tmp,201:oid,nil:oid,nil:int,nil:int);

	Ralias:= bpm.take("myversion",:bat[:void,:int]); # get the partition alias
	R0:= bpm.take(Ralias, 0@0, 100@0, nil:int,nil:int); 
	T0:= algebra.select(R0,0,100);
	bpm.deposit(Tmp,T0);

	R1:= bpm.take(Ralias, 101@0, 200@0, nil:int,nil:int); 
	T1:= algebra.select(R1,0,100);
	bpm.deposit(Tmp,T1);

	R2:= bpm.take(Ralias, 201@0, nil:oid, nil:int,nil:int); 
	T2:= algebra.select(R2,0,100);
	bpm.deposit(Tmp,T2);
@end example
The rationale for this approach is that re-distribution
of temporary results are hidden behind the pbm interface.
The only decision that should be taken by the optimizer is
the fragmentation criteria for the temporary results.
If you align the fragments of the target, it means

A disadvantage of the scheme is that we don't know much
about plan sizes. That is where a scheduler may step in
and reorganize the plan based on the new fragmentation
situation.

The lifetime of a partitioned table is inherited from its components. 
How to detect that a temporary BAT is removed from the BBP?

BEWARE, it is not protected against concurrent access yet.
@mal
module pbm;

command open():void
address PBMopen
comment "Locate and open the BAT partition box";

command close():void
address PBMclose
comment "Save and close the BAT partition box ";

command destroy():void
address PBMdestroy
comment "Destroy the BAT partition box";


command deposit(nme:str,b:bat[:any_1,:any_2]) :bat[:any_1,:any_2]
address PBMdeposit
comment "Turn an existing BAT into a MAT";

@-
The partitioning is handled inside the module.
If the alias denotes an existing partition, it is
further broken down into pieces.
@mal
command rangePartition(grp:bat[:any_1,:any_2], 
		ll:any_1, lh:any_1, rl:any_2, rh:any_2):bat[:any_1,:any_2]
address PBMrange
comment "Create a range partition on a BAT";
command hashPartition(grp:bat[:any_1,:any_2], slots:int):void
address PBMhash
comment "Create a hash partition on a BAT";
command rangeHashPartition(src:bat[:any_1,:any_2],
		ll:any_1, lh:any_1, slots:int):void
address PBMrangeHash
comment "Create a range and hash index partition on a BAT";
command hashRangePartition(src:bat[:any_1,:any_2],
		slots:int, rl:any_2, lh:any_2):void
address PBMhashRange
comment "Create a range and hash index partition on a BAT";

command take(grp:str, ll:any_1, lh:any_1, slot:int):bat[:any_1,:any_2]
address PBMtakeRangeHash
comment "Retrieve a single component of a MAT by range and hash index";
command take(grp:str, slot:int, rl:any_2, rh:any_2):bat[:any_1,:any_2]
address PBMtakeHashRange
comment "Retrieve a single component of a MAT by hash index and range";
command take(grp:str, ll:any_1, lh:any_1, rl:any_2, rh:any_2):bat[:any_1,:any_2]
address PBMtakeRange
comment "Retrieve a single component of a MAT by range";
command take(grp:str,hh:int,th:int):bat[:any_1,:any_2]
address PBMtakeHash
comment "Retrieve a single component of a MAT by hash indices";
command take(grp:str,idx:int):bat[:any_1,:any_2]
address PBMtakePartition
comment "Retrieve a single component of a MAT by index";

command getNames():bat[:void,:str]
address PBMgetAllComponents
comment "Retrieve the names of all known MATs";

command getBaseNames():bat[:void,:str]
address PBMgetBaseNames
comment "Retrieve the names of the underlying BATs";

command releaseAll(nme:str):void
address PBMreleaseAll
comment "Release a MAT definitions";
command discard() :void
address PBMdiscardAll
comment "Release all MAT variable from the box";
command discard(name:str) :void
address PBMdiscard
comment "Release a MAT variable from the box";
command discard(nme:str, b:bat[:void,:any_1]) :void
address PBMdiscardComponent
comment "Release a single BAT from a MAT";

command newIterator()(:int,:str)
address PBMnewIteratorBase
comment "Create an iterator over the partition box";
command hasMoreElements()(:int,:str)
address PBMhasMoreElementsBase
comment "Locate next element in the partition box";

@-
In most situations we would like to iterator over
the components of a single MAT. 
Wherever possible skipping elements that don't qualify
the bounds given for the head.
@mal
command newIterator(grp:bat[:any_1,:any_2):bat[:any_1,:any_2]
address PBMnewIterator
comment "Create an iterator over the MAT partitions.";

command newIterator(grp:str,first:oid,last:oid)
		:bat[:any_1,:any_2]
address PBMnewIteratorRng
comment "Create an iterator over the MAT partitions.";

command hasMoreElements(grp:str) :bat[:any_2,:any_1]
address PBMhasMoreElements
comment "Localize the next partition for processing.";

command hasMoreElements(grp:str,first:oid,last:oid) :bat[:any_1,:any_2]
address PBMhasMoreElementsRng
comment "Localize the next partition for processing.";

command getLast(grp:str):bat[:any_1,:any_2]
address PBMgetLast
comment "Obtain the last partition for update";

command getRange(b:bat[:void,:any_1])(first:oid,last:oid)
address PBMgetRange
comment "Obtain the oid range for a partition";

@-
The properties of the MATs require the caller to know
the underlying type already.
@mal
command getHeadLow(b:bat[:any_1,:any_2]):any_1
address PBMgetHeadLow
comment "Obtain the low value of the partition head");

command getHeadHigh(b:bat[:any_1,:any_2]):any_1
address PBMgetHeadHigh
comment "Obtain the low value of the partition head");

command getTailLow(b:bat[:any_1,:any_2]):any_2
address PBMgetTailLow
comment "Obtain the low value of the partition head");

command getTailHigh(b:bat[:any_1,:any_2]):any_2
address PBMgetTailHigh
comment "Obtain the low value of the partition head");

command dump()
address PBMdump;

command prelude()
address PBMprelude;

command epilogue()
address PBMepilogue;

pbm.prelude();
@-
@{

@+ BAT Partition Manager Implementation
The implementation is organized around a shared box, which should
be saved between session. It is up to other layers to ensure that BATs
being deleted are also removed from the partition box to avoid
mis-represented information.

The internal data structure is used as a cache for improved access.
@h
#ifndef _MAL_PBM
#define _MAL_PBM
#include "mal.h"
#include "mal_client.h"
#include "mal_interpreter.h"

#ifdef WIN32
#ifndef LIBBPM
#define bpm_export extern __declspec(dllimport)
#else
#define bpm_export extern __declspec(dllexport)
#endif
#else
#define bpm_export extern
#endif

typedef struct {
	str grp;		/* group name */
	str elm;		/* element name */
	bat bid;		/* element bat identifier */
@-
For the common case of :bat[:void,:any_1] we keep the boundaries
around for fast matching.
@h
	oid first;		/* lowest oid stored */
	oid last;		/* largest oid stored or nil */

	int next;		/* next one in the MAT list */
	int prev;		/* previous one in the MAT list */
} MATrecord, *MAT;

bpm_export MAT partitions ;
bpm_export int ptop, plimit;

bpm_export int PBMfindGrp(int bid);
bpm_export void PBMresize(int size);
bpm_export str PBMdump();
bpm_export str PBMprelude(int *ret);
bpm_export str PBMepilogue(int *ret);
bpm_export str PBMopen();
bpm_export str PBMclose();
bpm_export str PBMdestroy();
bpm_export str PBMtakeMAT(int *ret, str *grp);
bpm_export str PBMtake(int *ret, str *grp, str *elm);
bpm_export str PBMtakePartition(int *ret, str *grp, int *bid);
bpm_export str PBMgetComponents(int *ret, str *grp);
bpm_export str PBMgetAllComponents(int *ret);
bpm_export int PBMfindGrp(int bid);
bpm_export int PBMfindMAT(str grp);
bpm_export int PBMfindMATcomponent(str grp, str elm);
bpm_export str PBMdeposit(int *ret, str *grp, str *elm, int *bid);
bpm_export str PBMdepositByIndex(int *ret, str *grp, str *elm,int *idx);
bpm_export str PBMdepositByName(int *ret, str *grp, str *elm);
bpm_export str PBMgetRange(oid *first, oid *last, int *bid);
bpm_export str PBMgetLast(int *ret, str *grp);
bpm_export str PBMdiscard(int *ret, str *grp);
bpm_export str PBMdiscardAll(int *ret);
bpm_export str PBMreleaseAll(int *ret, int *bid);
bpm_export str PBMdiscardComponent(int *ret, str *grp, int *bid);
bpm_export str PBMnewIteratorBase(int *ret, str *grp, str *elm);
bpm_export str PBMhasMoreElementsBase(int *ret, str *nme, str *elm);
bpm_export str PBMnewIterator(int *res, str *grp);
bpm_export str PBMnewIteratorRng(int *res, str *grp, oid *first, oid *last);
bpm_export str PBMhasMoreElements(int *res, str *grp );
bpm_export str PBMhasMoreElementsRng(int *res, str *grp, oid *first, oid *last);
#endif
@-
The partition manager uses its private catalog of persistent BATs.
Each partitioned BAT is reference incremented to assure the base
table can always be retrieved.
The catalog is protected with the mal_contextLock.
@c
#include "pbm.h"

static BAT *pbmName;	/* bat[:bat,:str] */
static BAT *pbmGrp;		/* bat[:bat,:bat] */
static BAT *pbmTailLow[TYPE_any]; /*bat[:bat,:type_i]
static BAT *pbmTailHigh[TYPE_any]; /*bat[:bat,:type_i]
static BAT *pbmHeadLow[TYPE_any]; /*bat[:bat,:type_i]
static BAT *pbmHeadHigh[TYPE_any]; /*bat[:bat,:type_i]
static BAT *pbmHeadSlots; /*bat[:bat,:int]
static BAT *pbmTailSlots; /*bat[:bat,:int]

str
PBMdump()
{
	stream *fd = GDKout;
	ptr p,q;
	BATloop(pbmName,p,q){
		str nme= (str) BUNtail(pbmName,p);
		stream_printf(fd,"MAT %s",nme);
		/* localize MAT details */
		stream_printf(fd,"\n");
	}
	return MAL_SUCCEED;
}

@- Box administration
The box currently does not carry any client protection.
This should later be added or being provided by the BAT access.
@c
str
PBMprelude(int *ret)
{
	int i;
	/* bind all global variables */
    mal_set_lock(mal_contextLock, "bpm");
	pbmName = BBPbind("pbmName");
	pbmGrp= BBPbind("pbmGrp");
	pbmHeadSlots= BBPbind("pbmHeadSlots");
	pbmTailSlots= BBPbind("pbmTailSlots");
	for( i= 0; i< TYPE_any; i++){
		char buf[PATHLENGTH];
		snprintf(buf,PATHLENGTH,"pbmTailLow_%d",i);
		pbmTailLow[i]= BATdescriptor(BBPindex(buf));
		snprintf(buf,PATHLENGTH,"pbmHeadLow_%d",i);
		pbmHeadLow[i]= BATdescriptor(BBPindex(buf));
		snprintf(buf,PATHLENGTH,"pbmTailHead_%d",i);
		pbmTailHead[i]= BATdescriptor(BBPindex(buf));
		snprintf(buf,PATHLENGTH,"pbmHeadHead_%d",i);
		pbmHeadHead[i]= BATdescriptor(BBPindex(buf));
	}
    mal_unset_lock(mal_contextLock, "bpm");
	return MAL_SUCCEED;
}
@-
In the epilogue phase we should discard any temporary MAT.
@c
str
PBMepilogue(int *ret)
{
	*ret = closeBox("partitions", 0);
	PBMfree();
	if (*ret != 0)
		return throwMessage("pbm.prelude", "failed to open box");
	return MAL_SUCCEED;
}


str
PBMopen()
{
	if (openBox("pbm") != 0)
		return MAL_SUCCEED;
	return throwMessage("pbm.open", "failed to open pbm box");
}

str
PBMclose()
{
	stream *f;
	str boxfile, boxfilebak;
	Box box;
	BAT *b;
	int i;

	box = openBox("pbm");
	f = prepareSaveBox(box, &boxfile, &boxfilebak);
	if (f != NULL) {
		/* save the info */
		for (i = 0; i < ptop; i++)
			if (partitions[i].bid != -1) {
				b = (BAT *) BBPgetdesc(partitions[i].bid);
				if (b && b->batPersistence & PERSISTENT)
					stream_printf(f, "pbm.deposit(\"%s\",\"%s\",%d);\n", 
						partitions[i].grp,
						partitions[i].elm,
						partitions[i].bid);
			}
		stream_close(f);
		GDKfree(boxfile);
		GDKfree(boxfilebak);
	}
	return MAL_SUCCEED;
}

str
PBMdestroy()
{
	destroyBox("partitions");
	return MAL_SUCCEED;
}
@-
Taking out a BAT should be protective, i.e. check for their existence.
Taking out a MAT leads to a forced union before returning.
The intend is to use an optimizer to avoid this if possible.
@c
str
PBMtake(int *ret, str *grp, str *elm)
{
	BAT *b;
	int i;
	for( i=0; i< plimit; i++)
	if( partitions[i].grp &&
		 strcmp(partitions[i].grp, *grp)== 0 &&
		strcmp(partitions[i].elm, *elm)== 0) 
		break;
	if( i== plimit )
		return throwMessage("pbm.take", "MAT partition not found");
	b= BBPdescriptor(partitions[i].bid);
	if( b== NULL)
		return throwMessage("pbm.take", "MAT partition not accessible");
	*ret = partitions[i].bid;
	BBPkeepref(*ret);
	return MAL_SUCCEED;
}
str
PBMtakePartition(int *ret, str *grp, int *idx)
{
	BAT *b;
	int i;
	i= PBMfindMAT(*grp);
	if( i< 0)
		return throwMessage("pbm.take","MAT not found");
	for( ; i>=0 && *idx>0; i= partitions[i].next)
		*idx= *idx-1;
	if( i< 0)
		return throwMessage("pbm.take","MAT component not found");
	b= BBPdescriptor(partitions[i].bid);
	if( b== NULL)
		return throwMessage("pbm.take", "MAT partition not accessible");
	*ret = partitions[i].bid;
	BBPkeepref(*ret);
	return MAL_SUCCEED;
}
@-
Administration of new partitions.
@c
int
PBMfindGrp(int bid)
{
	return -1;
}

@-
Find the header of a group
@c
int
PBMfindMAT(str grp)
{
	return -1;
}
int
PBMfindMATcomponent(str grp, str elm)
{
	return -1;
}

str
PBMdeposit(int *ret, str *grp, str *elm, int *bid)
{
	int idx, i,j;
	BAT *b;

	i= PBMfindMATcomponent(*grp,*elm);
	if( i >=0 )
		return throwMessage("pbm.deposit", "MAT component already known");
	b = BATdescriptor(*bid);
	if (b == NULL)
		return throwMessage("pbm.deposit", "Can not access descriptor");
	idx = PBMfindMAT(*grp);
	if (ptop == plimit)
		PBMresize(plimit + INCREMENT);
	for (i = 0; i <= ptop; i++)
		if (partitions[i].bid == -1)
			break;
	partitions[i].grp = GDKstrdup(*grp);
	partitions[i].elm = GDKstrdup(*elm);
	partitions[i].bid = *bid;
	partitions[i].first = b->hseqbase;
	partitions[i].last = b->hseqbase + BATcount(b);
	partitions[i].prev = -1;
	partitions[i].next = -1;
	if (i >= ptop) {
		ptop = i + 1;
		partitions[ptop].bid = -1;
		partitions[ptop].next = -1;
		partitions[ptop].prev = -1;
	}
	if( idx >=0){
		for(j=idx; partitions[j].next>=0; j= partitions[j].next) ;
		partitions[j].next = i;
		partitions[i].prev = j;
	}
	BBPunfix(*bid);
	(void) ret;
	return MAL_SUCCEED;
}

str
PBMdepositByName(int *ret, str *grp, str *elm)
{
	int idx;
	BAT *b;

	idx= PBMfindMATcomponent(*grp,*elm);
	if( idx >=0 )
		return throwMessage("pbm.deposit", "MAT already known");
	b = BATdescriptor(partitions[idx].bid);
	if (b == NULL)
		return throwMessage("pbm.deposit", "Can not access descriptor");

	PBMdeposit(ret,grp,elm,&partitions[idx].bid);
	BBPunfix(partitions[idx].bid);
	(void) ret;
	return MAL_SUCCEED;
}

str
PBMgetRange(oid *first, oid *last, int *bid)
{
	int i;

	for (i = 0; i < ptop; i++)
		if (partitions[i].bid == *bid) {
			*first = partitions[i].first;
			*last = partitions[i].last;
			return MAL_SUCCEED;
		}
	return throwMessage("pbm.getRange", "MAT not known");
}

str
PBMgetLast(int *ret, str *grp)
{
	int i;

	i= PBMfindMAT(*grp);
	if( i < 0)
		return throwMessage("pbm.getLast", "MAT not known");
	for (; partitions[i].next>=0 ; i= partitions[i].next)
		;
	*ret = partitions[i].bid;
	return MAL_SUCCEED;
}

str
PBMdiscard(int *ret, str *grp)
{
	int i;

	for (i = 0; i<ptop; i++)
	if(	partitions[i].grp &&
		strcmp(partitions[i].grp, *grp)== 0 )
			PBMfreePartition(i);
	(void) ret;
	return MAL_SUCCEED;
}

str
PBMdiscardAll(int *ret)
{
	int i;
	for(i=0; i<ptop; i++)
	if( partitions[i].grp)
			PBMfreePartition(i);
	GDKfree(partitions);
	partitions = 0;
	plimit = -1;
	PBMresize(INCREMENT);
	(void) ret;
	return MAL_SUCCEED;
}

@-
releasing the MAT does not remove its components.
@c
str
PBMreleaseAll(int *ret, int *bid)
{
	(void) ret;
	(void) bid;
	return throwMessage("pbm.release", "not yet implemented");
}

str
PBMdiscardComponent(int *ret, str *grp, int *bid)
{
	(void) ret;
	(void) bid;
	(void) grp;
	return throwMessage("pbm.release", "not yet implemented");
}
@-
We start with the large chunk iterator.
The definition of the control statements require the same
control variables, which means that the BATview is accessible
to determine how far to advance when the next chunk is retrieved.
The number of elements in the chunk is limited by the granule
size.
@c
str
PBMnewIteratorBase(int *ret, str *grp, str *elm)
{
	*ret = 0;
	if (*ret == ptop)
		*ret = -1;
	else {
		*grp= GDKstrdup(partitions[0].grp);
		*elm= GDKstrdup(partitions[0].elm);
	}
	return MAL_SUCCEED;
}

str
PBMhasMoreElementsBase(int *ret, str *nme, str *elm)
{
	do {
		*ret = *ret + 1;
		if (*ret >= ptop) {
			*ret = -1;
			return MAL_SUCCEED;
		}
		*nme= GDKstrdup(partitions[*ret].grp);
		*elm= GDKstrdup(partitions[*ret].elm);
	} while (partitions[*ret].bid == -1);
	return MAL_SUCCEED;
}

str
PBMnewIterator(int *res, str *grp)
{
	int idx;

	idx= PBMfindMAT(*grp);
	if(idx<0)
		return throwMessage("pbm.newIterator","Could not find MAT");
	*res = partitions[idx].bid;
	BBPincref(*res, TRUE);
	return MAL_SUCCEED;
}

str
PBMnewIteratorRng(int *res, str *grp, oid *first, oid *last)
{
	int i;

	i= PBMfindMAT(*grp);
	if( i<0)
		return throwMessage("pbm.newIterator","Could not find MAT");
	for (; i>=0 ; i= partitions[i].next)
	if (!(partitions[i].last < *first || partitions[i].first > *last)) {
			*res = partitions[i].bid;
			BBPincref(*res, TRUE);
		}
	return MAL_SUCCEED;
}

str
PBMhasMoreElements(int *res, str *grp)
{
	int i;
	for(i=0; i<ptop; i++)
	if( partitions[i].bid == *res &&
		partitions[i].grp &&
		strcmp(partitions[i].grp,*grp)== 0){
		*res= partitions[i].bid;
		BBPincref(*res, TRUE);
		return MAL_SUCCEED;
	}
	*res = -1;
	return MAL_SUCCEED;
}

str
PBMhasMoreElementsRng(int *res, str *grp, oid *first, oid *last)
{
	int i;
	for(i= PBMfindMAT(*grp); i>=0 ; i = partitions[i].next)
		if( !(partitions[i].last < *first || partitions[i].first > *last)) {
			*res = partitions[i].bid;
			BBPincref(*res, TRUE);
			return MAL_SUCCEED;
		}
	*res = -1;
	return MAL_SUCCEED;
}
@}
