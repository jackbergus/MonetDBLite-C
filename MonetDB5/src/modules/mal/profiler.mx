@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
@' Copyright August 2008-2009 MonetDB B.V.
@' All Rights Reserved.

@f profiler
@a Martin Kersten
@+ Performance profiler
A key issue in developing fast programs using the Monet database
back-end requires a keen eye on where performance is lost.
Although performance tracking and measurements are highly
application dependent, a simple to use tool makes life
a lot easier.

Activation of the performance monitor has a global effect,
i.e. all concurrent actions on the kernel are traced,
but the events are only sent to the client initiated 
the profiler thread.

@- Monet Event Logger
The Monet Event Logger generates records of each event of
interest indicated by a log filter, i.e. a pattern over
module and function names. 

The log record contents is derived from counters being
(de-)activated. 
A complete list of recognized counters is shown below.

@- Execution tracing
Tracing is a special kind of profiling, where the information
gathered is not sent to a remote system, but stored in the database
itself. Each profile event is given a separate BAT

@verbatim
# thread and time since start
profiler.activate("tick");	
# cpu time in nano-seconds 
profiler.activate("cpu");	
# memory allocation information
profiler.activate("memory");
# IO activity
profiler.activate("io"); 
# Module,function,program counter
profiler.activate("pc"); 
# actual MAL instruction executed
profiler.activate("statement");	
@end verbatim
@-
The profiler event can be handled in several ways.
The default strategy is to ship the event record immediately over a stream
to a performance monitor.
An alternative strategy is preparation of off-line performance analysis.

To reduce the  interference of performance measurement with
the experiments, the user can use an event cache, which is
emptied explicitly upon need.
@mal
module profiler;

command activate(name:str):void
address CMDactivateProfiler
comment "Make the specified counter active.";

command deactivate(name:str):void
address CMDdeactivateProfiler
comment "Deactivate the counter";

pattern openStream():void 
address CMDopenProfilerStream
comment "Sent the events to output stream";
pattern openStream(fnme:str):void
address CMDsetProfilerFile
comment "Send the log events to a file, stdout or console";
pattern openStream(host:str, port:int):void
address CMDsetProfilerStream
comment "Send the log events to a stream ";
command closeStream():void 
address CMDcloseProfilerStream
comment "Stop sending the event records";

pattern setAll():void
address CMDsetAllProfiler
comment "Short cut for setFilter(*,*).";
pattern setNone():void
address CMDsetNoneProfiler
comment "Short cut for clrFilter(*,*).";

pattern setFilter(mod:str,fcn:str):void
address CMDsetFilterProfiler
comment "Generate an event record for all 
	function calls that satisfy the regular 
	expression mod.fcn. A wildcard (*) can 
	be used as name to identify all";

pattern setFilter(v:any):void
address CMDsetFilterVariable
comment "Generate an event record for
	every instruction where v is used.";

pattern clrFilter(mod:str,fcn:str):void
address CMDclrFilterProfiler
comment "Clear the performance trace bit 
	of the selected functions.";

pattern clrFilter(v:any):void
address CMDsetFilterVariable
comment "Stop tracing the variable" ;

pattern setStartPoint(mod:str,fcn:str):void
address CMDstartPointProfiler
comment "Start performance tracing at mod.fcn";
pattern setEndPoint(mod:str,fcn:str)
address CMDendPointProfiler
comment "End performance tracing after mod.fcn";

pattern start():void
address CMDstartProfiler
comment "Start performance tracing";

command noop():void
address CMDnoopProfiler
comment "Fetch any pending performance events";

pattern stop():void
address CMDstopProfiler
comment "Stop performance tracing";

command reset():void
address CMDclearTrace
comment "Clear the profiler traces";

command dumpTrace():void
address CMDdumpTrace
comment "List the events collected";

command getTrace(e:str):bat[:int,:any_1]
address CMDgetTrace
comment "Get the trace details of a specific event";

pattern getEvent()(:lng,:lng,:lng)
address CMDgetEvent
comment "Retrieve the performance indicators of the previous instruction";

command cleanup():void
address CMDcleanup
comment "Remove the temporary tables for profiling";

command getDiskReads():lng
address CMDgetDiskReads
comment "Obtain the number of physical reads";
command getDiskWrites():lng
address CMDgetDiskWrites
comment "Obtain the number of physical reads";

command getUserTime():lng
address CMDgetUserTime
comment "Obtain the user timing information.";
command getSystemTime():lng
address CMDgetSystemTime
comment "Obtain the user timing information.";

pattern getFootprint():lng
address CMDgetFootprint
comment "Get the memory footprint and reset it";
pattern getMemory():lng
address CMDgetMemory
comment "Get the amount of memory claimed and reset it";
@{
@-
@+ Implementation
The commands merely encapsulate the functionality provided by
mal_profiler, which should be explicitly compiled with the kernel, because
its generates a noticable overhead.
@h
#include "gdk.h"
#include <stdarg.h>
#include <time.h>
#include "mal_stack.h"
#include "mal_resolve.h"
#include "mal_exception.h"
#include "mal_client.h"
#include "mal_profiler.h"
#include "mal_interpreter.h"

@-
Using the Monet Performance Profiler is constrained by the mal_profiler.
@c
#include "mal_config.h"
#include "profiler.h"
#include "mal_client.h"

#ifdef WIN32
#ifndef LIBPROFILER
#define profiler_export extern __declspec(dllimport)
#else
#define profiler_export extern __declspec(dllexport)
#endif
#else
#define profiler_export extern
#endif

profiler_export str CMDactivateProfiler(int *res, str *name);
profiler_export str CMDdeactivateProfiler(int *res, str *name);
profiler_export str CMDsetFilterProfiler(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
profiler_export str CMDsetAllProfiler(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pc);
profiler_export str CMDsetFilterVariable(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pc);
profiler_export str CMDclrFilterVariable(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pc);
profiler_export str CMDclrFilterProfiler(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
profiler_export str CMDsetNoneProfiler(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
profiler_export str CMDsetProfilerFile(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
profiler_export str CMDsetProfilerStream (Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
profiler_export str CMDstartPointProfiler(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
profiler_export str CMDendPointProfiler(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
profiler_export str CMDstopProfiler(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
profiler_export str CMDstartProfiler(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
profiler_export str CMDnoopProfiler(int *res);
profiler_export str CMDclearTrace(int *res);
profiler_export str CMDdumpTrace(int *res);
profiler_export str CMDgetTrace(int *res, str *ev);
profiler_export str CMDopenProfilerStream(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
profiler_export str CMDcloseProfilerStream(int *res);
profiler_export str CMDcleanup(int *ret);
profiler_export str CMDgetEvent(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
profiler_export str CMDclearEvent(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
profiler_export str CMDgetDiskReads(lng *ret);
profiler_export str CMDgetDiskWrites(lng *ret);
profiler_export str CMDgetUserTime(lng *ret);
profiler_export str CMDgetSystemTime(lng *ret);
profiler_export str CMDgetMemory( Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
profiler_export str CMDgetFootprint( Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);

#define checkProfiler(X) \
	if( ! profilerAvailable()) \
	throw(MAL, "profiler." X,\
	":Monet not compiled for performance monitoring");


str
CMDactivateProfiler(int *res, str *name)
{
	(void) res;		/* fool compiler */
	checkProfiler("activate");
	activateCounter(*name);
	return MAL_SUCCEED;
}

str
CMDdeactivateProfiler(int *res, str *name)
{
	(void) res;		/* fool compiler */
	checkProfiler("deactivate");
	deactivateCounter(*name);
	return MAL_SUCCEED;
}

str
CMDsetFilterProfiler(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	str *mod = (str*) getArgReference(stk,pci,1);
	str *fcn = (str*) getArgReference(stk,pci,2);
	(void) mb;		/* fool compiler */
	checkProfiler("setFilter");
	setFilter(cntxt->nspace, *mod, *fcn);
	return MAL_SUCCEED;
}

str
CMDsetAllProfiler(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pc)
{
	str x = GDKstrdup("*");
	str y = GDKstrdup("*");

	(void) mb;		/* fool compiler */
	(void) stk;
	(void) pc;
	checkProfiler("setFilter");
	setFilter(cntxt->nspace, x, y);
	GDKfree(x);
	GDKfree(y);
	return MAL_SUCCEED;
}

str
CMDsetFilterVariable(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pc)
{
	(void) cntxt;
	(void) stk;
	setFilterVariable(mb,getArg(pc,1));
	return MAL_SUCCEED;
}

str
CMDclrFilterVariable(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pc)
{
	(void) cntxt;
	(void) stk;
	clrFilterVariable(mb,getArg(pc,1));
	return MAL_SUCCEED;
}

str
CMDopenProfilerStream(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pc)
{
	(void) cntxt;
	(void) mb;
	(void) stk;
	(void) pc;
	return openProfilerStream();
}
str
CMDcloseProfilerStream(int *res)
{
	(void) res;
	return closeProfilerStream();
}

str
CMDclrFilterProfiler(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	str *mod = (str*) getArgReference(stk,pci,1);
	str *fcn = (str*) getArgReference(stk,pci,2);
	(void) mb;		/* fool compiler */
	checkProfiler("clrFilter");
	clrFilter(cntxt->nspace, *mod, *fcn);
	return MAL_SUCCEED;
}

str
CMDsetNoneProfiler(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	str x = GDKstrdup("");
	str y = GDKstrdup("");

	(void) mb;		/* fool compiler */
	(void) stk;
	(void) pci;
	checkProfiler("clrFilter");
	clrFilter(cntxt->nspace, x, y);
	return MAL_SUCCEED;
}

str
CMDsetProfilerFile(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	str *fnme = (str*) getArgReference(stk,pci,1);
	(void) mb;		/* fool compiler */
	checkProfiler("setProfiler");
	setLogFile(cntxt->nspace, *fnme);
	return MAL_SUCCEED;
}

str
CMDsetProfilerStream (Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	str *host = (str*) getArgReference(stk,pci,1);
	int *port = (int*) getArgReference(stk,pci,2);
	(void) mb;		/* fool compiler */
	checkProfiler("setProfiler");
	setLogStream(cntxt->nspace, *host, *port);
	return MAL_SUCCEED;
}

str
CMDstartPointProfiler(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	str *mod = (str*) getArgReference(stk,pci,1);
	str *fcn = (str*) getArgReference(stk,pci,2);
	(void) mb;		/* fool compiler */
	checkProfiler("startPoint");
	setStartPoint(cntxt->nspace, *mod, *fcn);
	return MAL_SUCCEED;
}

str
CMDendPointProfiler(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	str *mod = (str*) getArgReference(stk,pci,1);
	str *fcn = (str*) getArgReference(stk,pci,2);
	(void) mb;		/* fool compiler */
	checkProfiler("endPoint");
	setStartPoint(cntxt->nspace, *mod, *fcn);
	return MAL_SUCCEED;
}

str
CMDstopProfiler(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	(void) mb;
	(void) stk;
	(void) pci;

	checkProfiler("stop");
	stream_printf(cntxt->fdout, "# Performance profiling stopped\n");
	stopProfiling();
	return MAL_SUCCEED;
}

str
CMDstartProfiler(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	(void) mb;
	(void) stk;
	(void) pci;

	checkProfiler("start");
	stream_printf(cntxt->fdout, "# Start performance profiling\n");
	startProfiling();
	return MAL_SUCCEED;
}
str
CMDnoopProfiler(int *res)
{
	(void) res;		/* fool compiler */
	checkProfiler("noop");
	return MAL_SUCCEED;
}

@-
Tracing an active system.
@c
str
CMDclearTrace(int *res)
{
	(void) res;		/* fool compiler */
	checkProfiler("stop");
	clearTrace();
	return MAL_SUCCEED;
}

str
CMDdumpTrace(int *res)
{
	(void) res;		/* fool compiler */
	checkProfiler("dump");
	throw(MAL, "profiler.dump", "not yet implemented");
}

str
CMDgetTrace(int *res, str *ev)
{
	BAT *bn;

	(void) res;		/* fool compiler */
	checkProfiler("dump");
	bn = getTrace(*ev);
	if (bn) {
		BBPincref(*res = bn->batCacheid, TRUE);
		return MAL_SUCCEED;
	}
	throw(MAL, "getTrace", "Failed to find event profile");
}

str
CMDcleanup(int *ret){
	(void) ret;
	cleanupProfiler();
	return MAL_SUCCEED;
}

str
CMDgetEvent( Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	lng *clk, *reads, *writes, pc;
	clk = (lng *) getArgReference(stk,pci,0);
	reads = (lng *) getArgReference(stk,pci,1);
	writes = (lng *) getArgReference(stk,pci,2);

	(void) cntxt;
	if( mb->profiler == 0)
		throw(MAL,"profiler.getEvent","Monitor not active");

	pc= getPC(mb,pci)-1; /* take previous instruction */
	*clk = mb->profiler[pc].ticks;
	*reads = mb->profiler[pc].ibytes;
	*writes = mb->profiler[pc].obytes;
	return MAL_SUCCEED;
}
str
CMDgetDiskReads(lng *ret)
{
	*ret= getDiskReads();
	return MAL_SUCCEED;
}
str
CMDgetDiskWrites(lng *ret)
{
	*ret= getDiskWrites();
	return MAL_SUCCEED;
}
str
CMDgetUserTime(lng *ret)
{
	*ret= getUserTime();
	return MAL_SUCCEED;
}
str
CMDgetSystemTime(lng *ret)
{
	*ret= getUserTime();
	return MAL_SUCCEED;
}

str
CMDgetFootprint( Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	lng *l= getArgReference(stk,pci,0);

	(void) mb;
	*l = cntxt->bigfoot;
	cntxt->bigfoot= 0;
	cntxt->vmfoot= 0;
	return MAL_SUCCEED;
}
str
CMDgetMemory( Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci){
	lng *l= getArgReference(stk,pci,0);

	(void) mb;
	*l = cntxt->memory;
	cntxt->memory= 0;
	return MAL_SUCCEED;
}
@}
