@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2007 CWI.
@' All Rights Reserved.

@f remote
@a Fabian Groffen
@+ Remote querying functionality
Communication with other mservers at the MAL level is a
delicate task.  However, it is indispensable for any
distributed functionality on MonetDB.  This module provides
an abstract way to store and retrieve objects on a remote
site.  Additionally, functions on a remote site can be
executed.  This yields in three primitive functions that
form the basis for distribution methods: get, put and exec.

The get method simply retrieves a remote object, and returns
it locally.  Objects can be anything, values, BATs, functions,
etc.  The same holds for the put method, but the other way
around.  A local object can be stored on a remote site.  Upon
a successful store, the put method returns the identifier on
the remote site.  With this identifier the object can be
addressed, e.g. using the exec method to execute a function
that was just stored before.

The get and put methods are symmetric.  Performing a get on an
identifier that was returned by put, will result in an equal
object to the one that was put.  After such operation an
expensive copy of the original object is made.

The choice to let exec only execute functions was made to avoid
problems to decide what should be returned to the caller.  With
a function it is clear and simple to return that what the
function being called would return.  Any extra output (e.g.
io.print calls) may cause havoc in the system.

This leads to the final contract of this module.  The methods
should be used correctly, by obeying their contract.  Failing
to do so will result in errors and undefined behaviour.

The first argument to all three functions is the name of the
connection the operation has to be performed on.  A connection
has to be created before it can be used.  During creation of
such connection, details like credentials, hostname and
database can be given.  Currently, connections are stored in
memory and not made persistent.  This could be changed in the
future to allow created connections to exist over server
restarts.

@mal
module remote;

command prelude():void
address RMTprelude
comment "Initialise the remote module";

command epilogue():void
address RMTepilogue
comment "Release the resources held by the remote module";


#remote.prelude();
@-

@- Implementation

@h

#ifndef _REMOTE_DEF
#define _REMOTE_DEF

#ifdef WIN32
#ifndef LIBREMOTE
#define remote_export extern __declspec(dllimport)
#else
#define remote_export extern __declspec(dllexport)
#endif
#else
#define remote_export extern
#endif

remote_export str RMTprelude(int *ret);
remote_export str RMTepilogue(int *ret);

#endif
@-

@c
#include "mal_config.h"
#include <mal.h>
#include <mal_exception.h>
#include <mal_interpreter.h>
#include <Mapi.h>
#include "remote.h"	/* for the implementation of the functions */

typedef struct _connection {
	char               name[16];  /* name of the connection,
                                     15 chars should be enough for everyone */
	Mapi               mconn;     /* the Mapi handle for the connection */
	struct _connection *next;     /* the next connection in the list */
} *connection;

static connection connections = NULL;

static str RMTfindconn(connection *ret, str conn) {
	connection c = connections;

	/* conn should be passed as valid variable here */


	/* just make sure the return isn't garbage */
	*ret = NULL;

	/* walk through the list */
	while (c != NULL) {
		if (strcmp(c->name, conn) == 0) {
			/* ok found, ensure it is connected */
			if (mapi_ping(c->mconn) != MOK && mapi_reconnect(c->mconn) != MOK) {
				throw(IO, "remote.<findconn>", "an error occurred during "
						"(re)connect of connection '%s': %s",
						conn, mapi_error_str(c->mconn));
				/* TODO: throw away connection? */
			}
			*ret = c;
			return(MAL_SUCCEED);
		}
	}

	throw(MAL, "remote.<findconn>", "no such connection with name '%s'", *conn);
}

static str RMTquery(MapiHdl *ret, str func, Mapi conn, str query) {
	MapiHdl mhdl;

	*ret = NULL;
	mhdl = mapi_query(conn, query);
	if (mhdl) {
		if (mapi_result_error(mhdl) != NULL) {
			str err = createException(MAL, func, "%s",
					getExceptionMessage(mapi_result_error(mhdl)));
			mapi_close_handle(mhdl);
			return(err);
		}
	} else {
		if (mapi_result_error(mhdl) != NULL) {
			throw(IO, func, "an error occurred on connection %s: %s",
					conn, mapi_result_error(mhdl));
		} else {
			throw(MAL, func, "remote function invocation didn't return a result");
		}
	}

	*ret = mhdl;
	return(MAL_SUCCEED);
}

str RMTprelude(int *ret) {
	(void)ret;

	return(MAL_SUCCEED);
}

str RMTepilogue(int *ret) {
	connection c = connections, t;

	(void)ret;

	/* free connections list */
	while (c != NULL) {
		t = c;
		c = c->next;
		mapi_destroy(t->mconn);
		GDKfree(t);
	}
	/* not sure, but better be safe than sorry */
	connections = NULL;

	return(MAL_SUCCEED);
}

@mal
pattern serveget(ident:str):void
address RMTserveget
comment "Prints a description of the given identifier";
@h
remote_export str RMTserveget(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
@c
/**
 * serveget prints a descriptive string for the given identifier ident.
 * This method is used by get() to retrieve an object.  serveget prints
 * a single tuple with information on the object.  The first column in
 * the tuple is the MAL type of the object.  Depending on this, the
 * other columns are filled in.  For scalar data types, the second
 * column represents the value of the scalar as a string, e.g.
 * [ "int", 1 ]
 * More complex types that need to be fetched afterwards just get extra
 * information where available, e.g. to describe a BAT with oid head and
 * str tail and one BUN:
 * [ "bat", "oid", "str", 1 ]
 */
str RMTserveget(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci) {
	int i;
	str name;
	VarPtr n;
	ValPtr v;
	char ret[256];
	Client c = MCgetClient();

	name = (str)getArgValue(stk, pci, 1);
	i = findVariable(mb, name);
	if (i < 0)
		throw(MAL, "remote.serveget", "no such symbol '%s'", name);

	n = getVar(mb, i);
	v = stk->stk + i;
	if (n->type == TYPE_any || isAnyExpression(n->type)) {
		/* TODO: deal with functions */
		throw(MAL, "remote.serveget", "cannot deal with '%s' type",
				getTypeName(n->type));
	} else if (isaBatType(n->type)) {
		char head[10], tail[10];
		BAT *b;

		if (getHeadIndex(n->type) > 0) {
			sprintf(head, "any%c%d", TMPMARKER, getHeadIndex(n->type));
		} else if (getHeadType(n->type) == TYPE_any) {
			sprintf(head, "any");
		} else {
			sprintf(head, "%s", ATOMname(getHeadType(n->type)));
		}
		if (getTailIndex(n->type) > 0) {
			sprintf(tail, "any%c%d", TMPMARKER, getTailIndex(n->type));
		} else if (getTailType(n->type) == TYPE_any) {
			sprintf(tail, "any");
		} else {
			sprintf(tail, "%s", ATOMname(getTailType(n->type)));
		}

		if ((b = BATdescriptor(v->val.ival)) == NULL)
			throw(MAL, "remote.serveget",
					"invalid BAT descriptor for '%s'", name);
		snprintf(ret, 255, "[ \"bat\",\t\"%s\",\t\"%s\",\t" SZFMT "\t]",
				head, tail, BATcount(b));
		BBPunfix(b->batCacheid);
	} else {
		str val = NULL;
		if (ATOMvarsized(n->type)) {
			ATOMformat(n->type, *(str *)v, &val);
		} else {
			ATOMformat(n->type, v, &val);
		}
		snprintf(ret, 255, "[ \"%s\",\t%s\t]", ATOMname(n->type), val);
		GDKfree(val);
	}
	ret[255] = '\0';

	stream_printf(c->fdout, "%s\n", ret);

	return(MAL_SUCCEED);
}

@mal
pattern get(conn:str, ident:str):any
address RMTget
comment "Retrieves and returns the object referenced by ident from conn";
@h
remote_export str RMTget(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
@c
/**
 * get fetches the object referenced by ident over connection conn.
 */
str RMTget(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci) {
	str ident, conn, type, tmp;
	ValPtr v;
	int vtype;
	char qbuf[512];
	connection c;
	Mapi mconn;
	MapiHdl mhdl;

	(void)mb;

	conn = (str)getArgValue(stk, pci, 1);
	if (conn == NULL || strcmp(conn, (str)str_nil) == 0)
		throw(ILLARG, "remote.get", "connection name is NULL or nil");
	ident = (str)getArgValue(stk, pci, 2);
	if (isIdentifier(ident) < 0)
		throw(ILLARG, "remote.get", "identifier expected, got '%s'", ident);

	/* lookup conn, set mconn if valid */
	rethrow("remote.get", tmp, RMTfindconn(&c, conn));
	mconn = c->mconn;

	snprintf(qbuf, 511, "remote.serveget(\"%s\");", ident);
	rethrow("remote.get", tmp, RMTquery(&mhdl, "remote.get", mconn, qbuf));

	if (mapi_get_row_count(mhdl) != 1) {
		int c = mapi_get_row_count(mhdl);
		mapi_close_handle(mhdl);
		throw(MAL, "remote.get", "unexpected number of rows (%d), expecting 1", c);
	}
	mapi_fetch_row(mhdl); /* should succeed */
	type = mapi_fetch_field(mhdl, 0); /* should be there */
	if (type == NULL) {
		mapi_close_handle(mhdl);
		throw(MAL, "remote.get", "missing first column in tuple");
	}

	/* get the return value */
	v = &stk->stk[getArg(pci, 0)];

	vtype = getTypeIndex(type, strlen(type), -1);
	if (vtype == TYPE_bat) {
		int h, t, s;
		ptr l, r;
		lng len;
		str val, var;
		BAT *b;

		/* no checks on the existence of the values */
		val = mapi_fetch_field(mhdl, 1);
		h = getTypeIndex(val, strlen(val), -1);
		val = mapi_fetch_field(mhdl, 2);
		t = getTypeIndex(val, strlen(val), -1);
		vtype = newBatType(h, t);
		val = mapi_fetch_field(mhdl, 3);
		len = atol(val);
		mapi_close_handle(mhdl);

#if SIZEOF_SIZE_T == 4
		if ((lng)(len & 0x80000000FFFFFFFF) != len)
			throw(MAL, "remote.get", "remote BAT is too big for this "
					"32-bits (configured) system");
#endif
		/* FIXME: len < 0 ???? */

		snprintf(qbuf, 511, "io.print(%s);", ident);
		rethrow("remote.get", tmp, RMTquery(&mhdl, "remote.get", mconn, qbuf));

		if (mapi_get_row_count(mhdl) != len) {
			int rc = mapi_get_row_count(mhdl);
			mapi_close_handle(mhdl);
			throw(MAL, "remote.get", "expected " LLFMT " tuples, "
					"will get only %d", len, rc);
		}
		b = BATnew(h, t, len);

		/* some checks maybe ... */
		while (len-- > 0) {
			mapi_fetch_row(mhdl);
			val = mapi_fetch_field(mhdl, 0); /* should be there */
			var = mapi_fetch_field(mhdl, 1);
			if (ATOMvarsized(h)) {
				l = (ptr)val;
			} else {
				s = 0;
				l = NULL;
				ATOMfromstr(h, &l, &s, val);
			}
			if (ATOMvarsized(t)) {
				r = (ptr)val;
			} else {
				s = 0;
				r = NULL;
				ATOMfromstr(t, &r, &s, var);
			}
			BUNins(b, l, r, FALSE);
			if (!ATOMvarsized(h)) GDKfree(l);
			if (!ATOMvarsized(t)) GDKfree(r);
		}

		/* adjust the return type */
		v->vtype = vtype;
		v->val.ival = b->batCacheid;
	} else if (vtype == TYPE_any) {
		mapi_close_handle(mhdl);
		throw(MAL, "remote.get", "can't handle variables of type 'any'");
	} else {
		/* we risk getting something we don't understand here */
		ptr p = NULL;
		str val;
		int len = 0;

		/* no checks on the existence of the value */
		val = mapi_fetch_field(mhdl, 1);

		if (ATOMvarsized(vtype)) {
			VALset(v, vtype, GDKstrdup(val));
		} else {
			ATOMfromstr(vtype, &p, &len, val);
			if (p != NULL) {
				VALset(v, vtype, p);
				if (ATOMextern(vtype) == 0)
					GDKfree(p);
			} else {
				char tval[512];
				snprintf(tval, 511, "%s", val);
				tval[511] = '\0';
				mapi_close_handle(mhdl);
				throw(MAL, "remote.get", "unable to parse value '%s'", tval);
			}
		}
	}

	mapi_close_handle(mhdl);

	return(MAL_SUCCEED);
}

@mal
command getnextid():void
address RMTgetnextid
comment "Prints the next unique local identifier";
@h
remote_export str RMTgetnextid(int *ret);
@c
static unsigned int _remote_object_counter = 0;
/**
 * getnextid prints the next unique local identifier as a tuple with one
 * column, e.g.:
 * [ "remote_put_object_1" ]
 * This method is used by put() to store an object.  The identifiers
 * generated by getnextid are based on a simple and naive strategy of
 * having a prefix and a counter that result in a hopefully unique
 * identifier.  The current prefix is "remote_put_object_" which should
 * reduce possible conflicts to a minimum.
 */
str RMTgetnextid(int *ret) {
	Client c = MCgetClient();

	stream_printf(c->fdout, "[ \"remote_put_object_%d\"\t]\n",
			_remote_object_counter++);

	*ret = 0;
	return(MAL_SUCCEED);
}

@mal
pattern put(conn:str, object:any):str
address RMTput
comment "Stores object on host and returns its identifier on host";
@h
remote_export str RMTput(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
@c
/**
 * stores the given object on the remote host.  The identifier of the
 * object on the remote host is returned for later use.
 */
str RMTput(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci) {
	str ident, conn, type;
	int i, bid;
	connection c;
	ValPtr v;
	Mapi mconn;
	MapiHdl mhdl;

	conn = (str)getArgValue(stk, pci, 1);
	if (conn == NULL || strcmp(conn, (str)str_nil) == 0)
		throw(ILLARG, "remote.put", "connection name is NULL or nil");

	/* lookup conn, set mconn if valid */
	rethrow("remote.put", type, RMTfindconn(&c, conn));
	mconn = c->mconn;

	/* get a free identifier on the remote host */
	rethrow("remote.put", type, RMTquery(&mhdl, "remote.put", mconn, "remote.getnextid();"));
	if (mapi_get_row_count(mhdl) != 1) {
		int c = mapi_get_row_count(mhdl);
		mapi_close_handle(mhdl);
		throw(MAL, "remote.put", "unexpected number of rows (%d), expecting 1", c);
	}
	mapi_fetch_row(mhdl); /* should succeed */
	ident = mapi_fetch_field(mhdl, 0); /* should be there */
	if (ident == NULL) {
		mapi_close_handle(mhdl);
		throw(MAL, "remote.put", "missing first column in tuple");
	}
	mapi_close_handle(mhdl);

	/* depending on the input object generate actions to store the
	 * object remotely*/
	i = getArgType(mb, pci, 2);
	if (i == TYPE_any || isAnyExpression(i)) {
		/* TODO: functions */
		throw(MAL, "remote.put", "cannot deal with '%s' type",
				getTypeName(i));
	} else if (isaBatType(i)) {
		/* naive approach using bat.new() and bat.insert() calls */
		char head[10], tail[10];
		char qbuf[512]; /* FIXME: this should be dynamic */
		BAT *b;
		BUN p, q;
		str headv, tailv;

		if (getHeadIndex(i) > 0) {
			sprintf(head, "any%c%d", TMPMARKER, getHeadIndex(i));
		} else if (getHeadType(i) == TYPE_any) {
			sprintf(head, "any");
		} else {
			sprintf(head, "%s", ATOMname(getHeadType(i)));
		}
		if (getTailIndex(i) > 0) {
			sprintf(tail, "any%c%d", TMPMARKER, getTailIndex(i));
		} else if (getTailType(i) == TYPE_any) {
			sprintf(tail, "any");
		} else {
			sprintf(tail, "%s", ATOMname(getTailType(i)));
		}

		bid = *(int *)getArgReference(stk, pci, 2);
		if ((b = BATdescriptor(bid)) == NULL)
			throw(MAL, "remote.put", "cannot access BAT descriptor");

		qbuf[511] = '\0';
		snprintf(qbuf, 511, "%s := bat.new(:%s, :%s, " SZFMT ");",
				ident, head, tail, BATcount(b));

		rethrow("remote.put", type, RMTquery(&mhdl, "remote.put", mconn, qbuf));
		mapi_close_handle(mhdl);

		headv = tailv = NULL;
		BATloop(b, p, q) {
			ATOMformat(getHeadType(i), BUNhead(b, p), &headv);
			ATOMformat(getTailType(i), BUNtail(b, p), &tailv);
			snprintf(qbuf, 511, "bat.insert(%s, %s:%s, %s:%s);",
					ident, headv, head, tailv, tail);
			rethrow("remote.put", type, RMTquery(&mhdl, "remote.put", mconn, qbuf));
			/* we leak headv and tailv here if an exception is thrown */
			mapi_close_handle(mhdl);
		}
		GDKfree(headv);
		GDKfree(tailv);
		BBPunfix(b->batCacheid);
	} else {
		str val = NULL;
		char qbuf[512]; /* FIXME: this should be dynamic */
		ptr v = (ptr)getArgReference(stk, pci, 2);
		if (ATOMvarsized(i)) {
			ATOMformat(i, *(str *)v, &val);
		} else {
			ATOMformat(i, v, &val);
		}
		snprintf(qbuf, 511, "%s := %s:%s;\n", ident, val, ATOMname(i));
		qbuf[511] = '\0';
		GDKfree(val);
		rethrow("remote.put", type, RMTquery(&mhdl, "remote.put", mconn, qbuf));
		mapi_close_handle(mhdl);
	}

	/* return the identifier */
	v = &stk->stk[getArg(pci, 0)];
	v->vtype = TYPE_str;
	v->val.sval = GDKstrdup(ident);
	return(MAL_SUCCEED);
}

@mal
pattern exec(conn:str, ident:str...):any
address RMTexec
comment "Executes function ident on host using the given arguments and returns its result";
@h
remote_export str RMTexec(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
@c
str RMTexec(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci) {
	(void)mb;
	(void)stk;
	(void)pci;
	return(MAL_SUCCEED);
}

@mal
command create(conn:str, host:str, port:int, dbname:str, user:str, passwd:str):void
address RMTcreate
comment "Creates a new connection conn using the given details";
@h
remote_export str RMTcreate(
		int *ret,
		str *conn,
		str *host,
		int *port,
		str *dbname,
		str *user,
		str *passwd);
@c
str RMTcreate(
		int *ret,
		str *conn,
		str *host,
		int *port,
		str *dbname,
		str *user,
		str *passwd)
{
	connection c;
	int s;

	if (conn == NULL || *conn == NULL || strcmp(*conn, (str)str_nil) == 0)
		throw(ILLARG, "remote.create", "connection name is NULL or nil");
	if ((s = strlen(*conn)) > 15)
		throw(ILLARG, "remote.create", "connection name may not exceed 15 characters");
	if (host == NULL || *host == NULL || strcmp(*host, (str)str_nil) == 0)
		throw(ILLARG, "remote.create", "hostname is NULL or nil");
	if (port == NULL || *port <= 0)
		throw(ILLARG, "remote.create", "port is NULL or <= 0");
	if (dbname == NULL || *dbname == NULL)
		throw(ILLARG, "remote.create", "database name is NULL");
	if (user == NULL || *user == NULL || strcmp(*user, (str)str_nil) == 0)
		throw(ILLARG, "remote.create", "username is NULL or nil");
	if (passwd == NULL || *passwd == NULL || strcmp(*passwd, (str)str_nil) == 0)
		throw(ILLARG, "remote.create", "password is NULL or nil");


	/* find a free slot, start with special case of connections not
	 * being set */
	if (connections == NULL) {
		connections = GDKmalloc(sizeof(struct _connection));
		c = connections;
	} else {
		/* ok, it's set, so find the last element in the list */
		connection t = c = connections;
		do {
			/* at the same time also check if this connection name
			 * already exists */
			if (strcmp(c->name, *conn) == 0)
				throw(MAL, "remote.create", "a connection with name "
						"'%s' already exists", *conn);
			t = c;
			c = c->next;
		} while (c != NULL);
		c = t->next = GDKmalloc(sizeof(struct _connection));
	}
	memcpy(c->name, *conn, s + 1 /* \0 */);
	c->mconn = mapi_mapi(*host, *port, *user, *passwd, "mal",
			(strcmp(*dbname, (str)str_nil) == 0 ? NULL : *dbname));
	c->next = NULL;

	/* just make sure the return isn't garbage */
	*ret = 0;

	return(MAL_SUCCEED);
}

@mal
command destroy(conn:str):void
address RMTdestroy
comment "Destroys a previously created connection";
@h
remote_export str RMTdestroy(int *ret, str *conn);
@c
str RMTdestroy(int *ret, str *conn) {
	connection c = connections, t;

	if (conn == NULL || *conn == NULL || strcmp(*conn, (str)str_nil) == 0)
		throw(ILLARG, "remote.destroy", "connection name is NULL or nil");


	/* just make sure the return isn't garbage */
	*ret = 0;

	/* walk through the list */
	t = NULL;
	while (c != NULL) {
		if (strcmp(c->name, *conn) == 0) {
			/* ok, delete it... */
			if (t == NULL) { /* the top */
				t = c->next;
				mapi_destroy(c->mconn);
				GDKfree(c);
				connections = t;
			} else {
				/* connect the grand child to the grand parent */
				t->next = c->next;
				/* and kill the parent in the middle */
				mapi_destroy(c->mconn);
				GDKfree(c);
			}

			return(MAL_SUCCEED);
		}
	}

	throw(MAL, "remote.destroy", "no such connection with name '%s'", *conn);
}

