@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2007 CWI.
@' All Rights Reserved.

@f remote
@a Fabian Groffen
@+ Remote querying functionality
Communication with other mservers at the MAL level is a
delicate task.  However, it is indispensable for any
distributed functionality on MonetDB.  This module provides
an abstract way to store and retrieve objects on a remote
site.  Additionally, functions on a remote site can be
executed.  This yields in three primitive functions that
form the basis for distribution methods: get, put and exec.

The get method simply retrieves a remote object, and returns
it locally.  Objects can be anything, values, BATs, functions,
etc.  The same holds for the put method, but the other way
around.  A local object can be stored on a remote site.  Upon
a successful store, the put method returns the identifier on
the remote site.  With this identifier the object can be
addressed, e.g. using the exec method to execute a function
that was just stored before.

The get and put methods are symmetric.  Performing a get on an
identifier that was returned by put, will result in an equal
object to the one that was put.  After such operation an
expensive copy of the original object is made.

The choice to let exec only execute functions was made to avoid
problems to decide what should be returned to the caller.  With
a function it is clear and simple to return that what the
function being called would return.  Any extra output (e.g.
io.print calls) may cause havoc in the system.

This leads to the final contract of this module.  The methods
should be used correctly, by obeying their contract.  Failing
to do so will result in errors and undefined behaviour.

@mal
module remote;

command prelude() :void
address RMTprelude
comment "Initialise the remote module";

command epilogue() :void
address RMTepilogue
comment "Release the resources held by the remote module";


pattern put(host:str, object:any):str
address RMTput
comment "Stores object on host and returns its identifier on host";

pattern exec(host:str, ident:str...):any
address RMTexec
comment "Executes function ident on host using the given arguments and returns its result";

#remote.prelude();
@-

@- Implementation

@h

#ifndef _REMOTE_DEF
#define _REMOTE_DEF

#ifdef WIN32
#ifndef LIBREMOTE
#define remote_export extern __declspec(dllimport)
#else
#define remote_export extern __declspec(dllexport)
#endif
#else
#define remote_export extern
#endif

remote_export str RMTprelude(int *ret);
remote_export str RMTepilogue(int *ret);

remote_export str RMTput(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
remote_export str RMTexec(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);

#endif
@-

@c
#include "mal_config.h"
#include <mal.h>
#include <mal_exception.h>
#include <mal_interpreter.h>
#include <Mapi.h>
#include "remote.h"	/* for the implementation of the functions */

str RMTprelude(int *ret) {
	(void)ret;

	return(MAL_SUCCEED);
}

str RMTepilogue(int *ret) {
	(void)ret;

	return(MAL_SUCCEED);
}

@mal
pattern serveget(ident:str):void
address RMTserveget
comment "Prints a description of the given identifier";
@h
remote_export str RMTserveget(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
@c
/**
 * serveget prints a descriptive string for the given identifier ident.
 * This method is used by get() to retrieve an object.  serveget prints
 * a single tuple with information on the object.  The first column in
 * the tuple is the MAL type of the object.  Depending on this, the
 * other columns are filled in.  For scalar data types, the second
 * column represents the value of the scalar as a string, e.g.
 * [ "int", "1" ]
 * More complex types that need to be fetched afterwards just get extra
 * information where available, e.g. to describe a BAT with oid head and
 * str tail:
 * [ "bat", "oid", "str" ]
 */
str RMTserveget(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci) {
	int i;
	str name;
	VarPtr n;
	ValPtr v;
	char ret[256];
	Client c = MCgetClient();

	name = (str)getArgValue(stk, pci, 1);
	i = findVariable(mb, name);
	if (i < 0)
		throw(MAL, "remote.serveget", "no such symbol '%s'", name);

	n = getVar(mb, i);
	v = stk->stk + i;
	if (n->type == TYPE_any || isAnyExpression(n->type)) {
		/* TODO: deal with functions */
		throw(MAL, "remote.serveget", "cannot deal with '%s' type", getTypeName(n->type));
	} else if (isaBatType(n->type)) {
		char head[10], tail[10];
		if (getHeadIndex(n->type) > 0) {
			sprintf(head, "any%c%d", TMPMARKER, getHeadIndex(n->type));
		} else if (getHeadType(n->type) == TYPE_any) {
			sprintf(head, "any");
		} else {
			sprintf(head, "%s", ATOMname(getHeadType(n->type)));
		}
		if (getTailIndex(n->type) > 0) {
			sprintf(tail, "any%c%d", TMPMARKER, getTailIndex(n->type));
		} else if (getTailType(n->type) == TYPE_any) {
			sprintf(tail, "any");
		} else {
			sprintf(tail, "%s", ATOMname(getTailType(n->type)));
		}

		snprintf(ret, 255, "[ \"bat\",\t\"%s\",\t\"%s\"\t]", head, tail);
	} else {
		str val = NULL;
		ATOMformat(n->type, v, &val);
		snprintf(ret, 255, "[ \"%s\",\t\"%s\"\t]", ATOMname(n->type), val);
	}
	ret[255] = '\0';

	stream_printf(c->fdout, "%s\n", ret);

	return(MAL_SUCCEED);
}

@mal
pattern get(conn:str, ident:str):any
address RMTget
comment "Retrieves and returns the object referenced by ident from conn";
@h
remote_export str RMTget(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
@c
/**
 * get fetches the object referenced by ident over connection conn.
 */
str RMTget(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci) {
	str ident, conn, type;
	ValPtr v;
	char qbuf[512];
	Mapi mconn;
	MapiHdl mhdl;

	(void)mb;

	conn = (str)getArgValue(stk, pci, 1);
	ident = (str)getArgValue(stk, pci, 2);
	if (isIdentifier(ident) < 0)
		throw(MAL, "remote.get", "identifier expected, got '%s'", ident);

	/* lookup conn, set mconn if valid */
	mconn = NULL; /* FIXME */
	/* ensure it is connected */
	if (mapi_reconnect(mconn) != MOK) {
		throw(IO, "remote.get", "an error occurred during (re)connect "
				"of connection %s: %s", conn, mapi_error_str(mconn));
		mapi_disconnect(mconn);
		/* TODO: throw away connection? */
	}

	snprintf(qbuf, 511, "remote.serveget(\"%s\");", ident);
	mhdl = mapi_query(mconn, qbuf);
	if (mhdl) {
		int vtype;

		if (mapi_get_row_count(mhdl) != 1) {
			int c = mapi_get_row_count(mhdl);
			mapi_close_handle(mhdl);
			throw(MAL, "remote.get", "unexpected number of rows (%d), expecting 1", c);
		}
		mapi_fetch_row(mhdl); /* should succeed */
		type = mapi_fetch_field(mhdl, 0); /* should be there */
		if (type == NULL) {
			mapi_close_handle(mhdl);
			throw(MAL, "remote.get", "missing first column in tuple");
		}

		/* get the return value */
		v = &stk->stk[getArg(pci, 0)];

		vtype = getTypeIndex(type, strlen(type), -1);
		if (vtype == TYPE_bat) {
			int h, t;
			str val;
			/* no checks on the existence of the values */
			val = mapi_fetch_field(mhdl, 1);
			h = getTypeIndex(val, strlen(val), -1);
			val = mapi_fetch_field(mhdl, 2);
			t = getTypeIndex(val, strlen(val), -1);
			vtype = newBatType(h, t);

			/* adjust the return type */
			v->vtype = vtype;
			/* TODO: get the BAT, etc. */
			/* v->val.ival = bid; */
			mapi_close_handle(mhdl);
			throw(MAL, "remote.get", "fetching BATs not yet implemented!");
		} else if (vtype == TYPE_any) {
			mapi_close_handle(mhdl);
			throw(MAL, "remote.get", "can't handle variables of type 'any'");
		} else {
			/* we risk getting something we don't understand here */
			ptr p = NULL;
			str val;

			/* no checks on the existence of the value */
			val = mapi_fetch_field(mhdl, 1);

			ATOMfromstr(vtype, &p, 0, val);
			if (p != NULL) {
				VALset(v, vtype, p);
				if (ATOMextern(vtype) == 0)
					GDKfree(p);
			} else {
				char tval[512];
				snprintf(tval, 511, "%s", val);
				tval[511] = '\0';
				mapi_close_handle(mhdl);
				throw(MAL, "remote.get", "unable to parse value '%s'", tval);
			}
		}

		mapi_close_handle(mhdl);
	} else {
		if (mapi_result_error(mhdl) != NULL) {
			throw(IO, "remote.get", "an error occurred on connection %s: %s",
					conn, mapi_result_error(mhdl));
		} else {
			throw(MAL, "remote.get", "remote.serveget invocation didn't return a result");
		}
	}

	return(MAL_SUCCEED);
}

str RMTput(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci) {
	(void)mb;
	(void)stk;
	(void)pci;
	return(MAL_SUCCEED);
}

str RMTexec(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci) {
	(void)mb;
	(void)stk;
	(void)pci;
	return(MAL_SUCCEED);
}
