@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2008 CWI.
@' All Rights Reserved.

@f remote
@a Fabian Groffen
@+ Remote querying functionality
Communication with other mservers at the MAL level is a
delicate task.  However, it is indispensable for any
distributed functionality on MonetDB.  This module provides
an abstract way to store and retrieve objects on a remote
site.  Additionally, functions on a remote site can be
executed.  This yields in three primitive functions that
form the basis for distribution methods: get, put and exec.

The get method simply retrieves a remote object, and returns
it locally.  Objects can be simple values, strings or BATs.
The same holds for the put method, but the other way
around.  A local object can be stored on a remote site.  Upon
a successful store, the put method returns the remote
identifier for the stored object.  With this identifier the
object can be addressed, e.g. using the get method to retrieve
the object that was stored again.

The get and put methods are symmetric.  Performing a get on an
identifier that was returned by put, will result in an equal
object to the one that was put.  After such operation an
(expensive) copy of the original object is made.

The choice to let exec only execute functions was made to avoid
problems to decide what should be returned to the caller.  With
a function it is clear and simple to return that what the
function being called would return.  Any extra output (e.g.
io.print calls) may cause havoc in the system, but are currently
known to be ignored.

This leads to the final contract of this module.  The methods
should be used correctly, by obeying their contract.  Failing
to do so will result in errors and possibly undefined behaviour.

It is impossible to get and put functions directly, as the
semantical meaning of such operation is unclear.  A function
cannot be assigned to a variable (such as get() would do).
Storing a function on a remote site with put() could lead to
conflicts if a function with the same name already exists there,
let alone if the module the function comes from is accessible.
Finally, C-implemented functions, such as io.print() cannot be
stored for obvious reasons and would require even more
complicated (byte?) code shipping and remote compilation to
make it work.  As an alternative, a user can serialise local
script-functions to strings and use those in an exec call to
a remote function that can parse the string to turn it into a
function.  Of course this also works the other way around using
an exec of the serialise function on the remote host for the
remote function to acquire the string representation of the
function locally.

The first argument to all three functions is the name of the
connection the operation has to be performed on.  A connection
has to be created before it can be used.  During creation of
such connection, details like credentials, hostname and
database can be given.  Currently, connections are stored in
memory and not made persistent.  This could be changed in the
future to allow created connections to exist over server
restarts.

@mal
module remote;

command prelude():void
address RMTprelude
comment "Initialise the remote module";

command epilogue():void
address RMTepilogue
comment "Release the resources held by the remote module";


#remote.prelude();
@-

@- Implementation

@h

#ifndef _REMOTE_DEF
#define _REMOTE_DEF

#ifdef WIN32
#ifndef LIBREMOTE
#define remote_export extern __declspec(dllimport)
#else
#define remote_export extern __declspec(dllexport)
#endif
#else
#define remote_export extern
#endif

remote_export str RMTprelude(int *ret);
remote_export str RMTepilogue(int *ret);

#endif
@-

@c
#include "mal_config.h"
#include <mal.h>
#include <mal_exception.h>
#include <mal_interpreter.h>
#include <mal_function.h> /* for printFunction */
#include <mapilib/Mapi.h>
#include "remote.h"	/* for the implementation of the functions */

typedef struct _connection {
	char               name[16];  /* name of the connection,
                                     15 chars should be enough for everyone */
	Mapi               mconn;     /* the Mapi handle for the connection */
	struct _connection *next;     /* the next connection in the list */
} *connection;

static connection connections = NULL;

/**
 * Helper function to return a connection matching a given string, or an
 * error if it does not exist.  Before the connection is returned, it is
 * made sure that it is usable.  If the connection cannot be made
 * useable, an error is returned.
 */
static INLINE str RMTfindconn(connection *ret, str conn) {
	connection c = connections;

	/* conn should be passed as valid variable here */


	/* just make sure the return isn't garbage */
	*ret = NULL;

	/* walk through the list */
	while (c != NULL) {
		if (strcmp(c->name, conn) == 0) {
			/* ok found, ensure it is connected */
			if (mapi_ping(c->mconn) != MOK && mapi_reconnect(c->mconn) != MOK) {
				throw(IO, "remote.<findconn>", "an error occurred during "
						"(re)connect of connection '%s': %s",
						conn, mapi_error_str(c->mconn));
				/* TODO: throw away connection? */
			}
			*ret = c;
			return(MAL_SUCCEED);
		}
	}

	throw(MAL, "remote.<findconn>", "no such connection with name '%s'", *conn);
}

/**
 * Helper function to execute a query over the given connection,
 * returning the result handle.  If communication fails in one way or
 * another, an error is returned.
 */
static INLINE str RMTquery(MapiHdl *ret, str func, Mapi conn, str query) {
	MapiHdl mhdl;

	*ret = NULL;
	mhdl = mapi_query(conn, query);
	if (mhdl) {
		if (mapi_result_error(mhdl) != NULL) {
			str err = createException(
					getExceptionType(mapi_result_error(mhdl)),
					func,
					"%s", getExceptionMessage(mapi_result_error(mhdl)));
			mapi_close_handle(mhdl);
			return(err);
		}
	} else {
		if (mapi_result_error(mhdl) != NULL) {
			throw(IO, func, "an error occurred on connection %s: %s",
					conn, mapi_result_error(mhdl));
		} else {
			throw(IO, func, "remote function invocation didn't return a result");
		}
	}

	*ret = mhdl;
	return(MAL_SUCCEED);
}

/**
 * Helper function to place the given object on the remote host via the
 * given connection.  An id will be fetched from the remote host, and
 * set in ret if no problems occur, on which an error is returned.  The
 * id can be used to reference the object put on the remote host.
 */
static INLINE str RMTinternalput(str *ret, Mapi mconn, int type, ptr value) {
	str tmp;
	str ident;
	MapiHdl mhdl = NULL;

	/* get a free identifier on the remote host */
	rethrow("remote.put", tmp, RMTquery(&mhdl, "remote.put", mconn, "remote.getnextid();"));
	mapi_fetch_row(mhdl); /* should succeed */
	tmp = mapi_fetch_field(mhdl, 0); /* should be there */
	if (tmp == NULL) {
		mapi_close_handle(mhdl);
		throw(MAL, "remote.put", "missing first column in tuple");
	}
	/* allocate on the stack as not to leak when we error lateron */
	ident = alloca(sizeof(char) * (strlen(tmp) + 1));
	memcpy(ident, tmp, strlen(tmp) + 1);
	mapi_close_handle(mhdl);

	/* depending on the input object generate actions to store the
	 * object remotely*/
	if (type == TYPE_any || isAnyExpression(type)) {
		throw(MAL, "remote.put", "cannot deal with '%s' type",
				getTypeName(type));
	} else if (isaBatType(type)) {
		BATiter bi;
		/* naive approach using bat.new() and bat.insert() calls */
		char head[10], tail[10];
		char qbuf[512]; /* FIXME: this should be dynamic */
		int bid;
		BAT *b;
		BUN p, q;
		str headv, tailv;

		if (getHeadIndex(type) > 0) {
			sprintf(head, "any%c%d", TMPMARKER, getHeadIndex(type));
		} else if (getHeadType(type) == TYPE_any) {
			sprintf(head, "any");
		} else {
			sprintf(head, "%s", ATOMname(getHeadType(type)));
		}
		if (getTailIndex(type) > 0) {
			sprintf(tail, "any%c%d", TMPMARKER, getTailIndex(type));
		} else if (getTailType(type) == TYPE_any) {
			sprintf(tail, "any");
		} else {
			sprintf(tail, "%s", ATOMname(getTailType(type)));
		}

		bid = *(int *)value;
		if ((b = BATdescriptor(bid)) == NULL)
			throw(MAL, "remote.put", "cannot access BAT descriptor");

		qbuf[511] = '\0';
		snprintf(qbuf, 511, "%s := bat.new(:%s, :%s, " SZFMT ");",
				ident, head, tail, BATcount(b));

		rethrow("remote.put", tmp, RMTquery(&mhdl, "remote.put", mconn, qbuf));
		mapi_close_handle(mhdl);

		headv = tailv = NULL;
		bi = bat_iterator(b);
		BATloop(b, p, q) {
			ATOMformat(getHeadType(type), BUNhead(bi, p), &headv);
			ATOMformat(getTailType(type), BUNtail(bi, p), &tailv);
			snprintf(qbuf, 511, "bat.insert(%s, %s:%s, %s:%s);",
					ident, headv, head, tailv, tail);
			rethrow("remote.put", tmp, RMTquery(&mhdl, "remote.put", mconn, qbuf));
			/* we leak headv and tailv here if an exception is thrown */
			mapi_close_handle(mhdl);
		}
		GDKfree(headv);
		GDKfree(tailv);
		BBPunfix(b->batCacheid);
	} else {
		str val = NULL;
		char qbuf[512]; /* FIXME: this should be dynamic */
		if (ATOMvarsized(type)) {
			ATOMformat(type, *(str *)value, &val);
		} else {
			ATOMformat(type, value, &val);
		}
		snprintf(qbuf, 511, "%s := %s:%s;\n", ident, val, ATOMname(type));
		qbuf[511] = '\0';
		GDKfree(val);
		rethrow("remote.put", tmp, RMTquery(&mhdl, "remote.put", mconn, qbuf));
		mapi_close_handle(mhdl);
	}

	*ret = GDKstrdup(ident);
	return(MAL_SUCCEED);
}

/**
 * Helper function to return a remote object via the given connection as
 * a local object.
 */
static INLINE str RMTinternalget(Mapi mconn, str ident, ValPtr v) {
	str type, tmp;
	int vtype;
	char qbuf[512];
	MapiHdl mhdl;

	snprintf(qbuf, 511, "remote.serveget(\"%s\");", ident);
	rethrow("remote.get", tmp, RMTquery(&mhdl, "remote.get", mconn, qbuf));

	mapi_fetch_row(mhdl); /* should succeed */
	type = mapi_fetch_field(mhdl, 0); /* should be there */
	if (type == NULL) {
		mapi_close_handle(mhdl);
		throw(MAL, "remote.get", "missing first column in tuple");
	}

	vtype = getTypeIndex(type, strlen(type), -1);
	if (vtype == TYPE_bat) {
		int h, t, s;
		ptr l, r;
		lng len;
		str val, var;
		BAT *b;

		/* no checks on the existence of the values */
		val = mapi_fetch_field(mhdl, 1);
		h = getTypeIndex(val, strlen(val), -1);
		val = mapi_fetch_field(mhdl, 2);
		t = getTypeIndex(val, strlen(val), -1);
		vtype = newBatType(h, t);
		val = mapi_fetch_field(mhdl, 3);
		len = atol(val);
		mapi_close_handle(mhdl);

#if SIZEOF_SIZE_T == 4
		if ((lng)(len & 0x80000000FFFFFFFF) != len)
			throw(MAL, "remote.get", "remote BAT is too big for this "
					"32-bits (configured) system");
#endif
		/* FIXME: len < 0 ???? */

		snprintf(qbuf, 511, "io.print(%s);", ident);
		rethrow("remote.get", tmp, RMTquery(&mhdl, "remote.get", mconn, qbuf));

		b = BATnew(h, t, len);

		/* some checks maybe ... */
		while (len-- > 0) {
			mapi_fetch_row(mhdl);
			val = mapi_fetch_field(mhdl, 0); /* should be there */
			var = mapi_fetch_field(mhdl, 1);
			if (ATOMvarsized(h)) {
				l = (ptr)val;
			} else {
				s = 0;
				l = NULL;
				ATOMfromstr(h, &l, &s, val);
			}
			if (ATOMvarsized(t)) {
				r = (ptr)var;
			} else {
				s = 0;
				r = NULL;
				ATOMfromstr(t, &r, &s, var);
			}
			BUNins(b, l, r, FALSE);
			if (!ATOMvarsized(h)) GDKfree(l);
			if (!ATOMvarsized(t)) GDKfree(r);
		}

		/* adjust the return type */
		v->vtype = vtype;
		v->val.ival = b->batCacheid;
	} else if (vtype == TYPE_any) {
		mapi_close_handle(mhdl);
		throw(MAL, "remote.get", "can't handle variables of type 'any'");
	} else {
		/* we risk getting something we don't understand here */
		ptr p = NULL;
		str val;
		int len = 0;

		/* no checks on the existence of the value */
		val = mapi_fetch_field(mhdl, 1);

		if (ATOMvarsized(vtype)) {
			VALset(v, vtype, GDKstrdup(val));
		} else {
			ATOMfromstr(vtype, &p, &len, val);
			if (p != NULL) {
				VALset(v, vtype, p);
				if (ATOMextern(vtype) == 0)
					GDKfree(p);
			} else {
				char tval[512];
				snprintf(tval, 511, "%s", val);
				tval[511] = '\0';
				mapi_close_handle(mhdl);
				throw(MAL, "remote.get", "unable to parse value '%s'", tval);
			}
		}
	}

	mapi_close_handle(mhdl);

	return(MAL_SUCCEED);
}

str RMTprelude(int *ret) {
	(void)ret;

	return(MAL_SUCCEED);
}

str RMTepilogue(int *ret) {
	connection c = connections, t;

	(void)ret;

	/* free connections list */
	while (c != NULL) {
		t = c;
		c = c->next;
		mapi_destroy(t->mconn);
		GDKfree(t);
	}
	/* not sure, but better be safe than sorry */
	connections = NULL;

	return(MAL_SUCCEED);
}

@mal
pattern serveget(ident:str):void
address RMTserveget
comment "Prints a description of the given identifier";
@h
remote_export str RMTserveget(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
@c
/**
 * serveget prints a descriptive string for the given identifier ident.
 * This method is used by get() to retrieve an object.  serveget prints
 * a single tuple with information on the object.  The first column in
 * the tuple is the MAL type of the object.  Depending on this, the
 * other columns are filled in.  For scalar data types, the second
 * column represents the value of the scalar as a string, e.g.
 * [ "int", 1 ]
 * More complex types that need to be fetched afterwards just get extra
 * information where available, e.g. to describe a BAT with oid head and
 * str tail and one BUN:
 * [ "bat", "oid", "str", 1 ]
 */
str RMTserveget(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci) {
	int i;
	str name;
	VarPtr n;
	ValPtr v;
	char ret[256];
	Client c = MCgetClient();

	name = (str)getArgValue(stk, pci, 1);
	i = findVariable(mb, name);
	if (i < 0)
		throw(MAL, "remote.serveget", "no such object '%s'", name);

	n = getVar(mb, i);
	v = stk->stk + i;
	if (n->type == TYPE_any || isAnyExpression(n->type)) {
		throw(MAL, "remote.serveget", "cannot deal with '%s' type",
				getTypeName(n->type));
	} else if (isaBatType(n->type)) {
		char head[10], tail[10];
		BAT *b;

		if (getHeadIndex(n->type) > 0) {
			sprintf(head, "any%c%d", TMPMARKER, getHeadIndex(n->type));
		} else if (getHeadType(n->type) == TYPE_any) {
			sprintf(head, "any");
		} else {
			sprintf(head, "%s", ATOMname(getHeadType(n->type)));
		}
		if (getTailIndex(n->type) > 0) {
			sprintf(tail, "any%c%d", TMPMARKER, getTailIndex(n->type));
		} else if (getTailType(n->type) == TYPE_any) {
			sprintf(tail, "any");
		} else {
			sprintf(tail, "%s", ATOMname(getTailType(n->type)));
		}

		if ((b = BATdescriptor(v->val.ival)) == NULL)
			throw(MAL, "remote.serveget",
					"invalid BAT descriptor for '%s'", name);
		snprintf(ret, 255, "[ \"bat\",\t\"%s\",\t\"%s\",\t" SZFMT "\t]",
				head, tail, BATcount(b));
		BBPunfix(b->batCacheid);
	} else {
		str val = NULL;
		if (ATOMvarsized(n->type)) {
			ATOMformat(n->type, *(str *)v, &val);
		} else {
			ATOMformat(n->type, v, &val);
		}
		snprintf(ret, 255, "[ \"%s\",\t%s\t]", ATOMname(n->type), val);
		GDKfree(val);
	}
	ret[255] = '\0';

	stream_printf(c->fdout, "%s\n", ret);

	return(MAL_SUCCEED);
}

@mal
pattern get(conn:str, ident:str):any
address RMTget
comment "Retrieves and returns the object referenced by ident from conn";
@h
remote_export str RMTget(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
@c
/**
 * get fetches the object referenced by ident over connection conn.
 */
str RMTget(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci) {
	str conn, ident, tmp;
	connection c;

	(void)mb;

	conn = (str)getArgValue(stk, pci, 1);
	if (conn == NULL || strcmp(conn, (str)str_nil) == 0)
		throw(ILLARG, "remote.get", "connection name is NULL or nil");
	ident = (str)getArgValue(stk, pci, 2);
	if (isIdentifier(ident) < 0)
		throw(ILLARG, "remote.get", "identifier expected, got '%s'", ident);

	/* lookup conn, set mconn if valid */
	rethrow("remote.get", tmp, RMTfindconn(&c, conn));

	/* perform the get */
	rethrow("remote.get", tmp, RMTinternalget(c->mconn,
				ident, &stk->stk[getArg(pci, 0)]));

	return(MAL_SUCCEED);
}

@mal
pattern getnextid():void
address RMTgetnextid
comment "Prints the next unique local identifier";
@h
remote_export str RMTgetnextid(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
@c
static unsigned int _remote_object_counter = 0;
/**
 * getnextid prints the next unique local identifier as a tuple with one
 * column, e.g.:
 * [ "remote_put_object_1" ]
 * This method is used by put() to store an object.  The identifiers
 * generated by getnextid are based on a simple and naive strategy of
 * having a prefix and a counter that result in a hopefully unique
 * identifier.  The current prefix is "remote_put_object_" which should
 * reduce possible conflicts to a minimum.
 */
str RMTgetnextid(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	int *ret= (int*) getArgReference(stk,pci,0);
	Client c = MCgetClient();
	(void) mb;

	stream_printf(c->fdout, "[ \"remote_put_object_%d\"\t]\n",
			_remote_object_counter++);

	*ret = 0;
	return(MAL_SUCCEED);
}

@mal
pattern put(conn:str, object:any):str
address RMTput
comment "Stores object on host and returns its identifier on host";
@h
remote_export str RMTput(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
@c
/**
 * stores the given object on the remote host.  The identifier of the
 * object on the remote host is returned for later use.
 */
str RMTput(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci) {
	str conn, tmp, ident;
	connection c;
	ValPtr v;

	conn = (str)getArgValue(stk, pci, 1);
	if (conn == NULL || strcmp(conn, (str)str_nil) == 0)
		throw(ILLARG, "remote.put", "connection name is NULL or nil");

	/* lookup conn */
	rethrow("remote.put", tmp, RMTfindconn(&c, conn));

	/* put the thing */
	rethrow("remote.put", tmp, RMTinternalput(&ident,
				c->mconn,
				getArgType(mb, pci, 2),
				getArgReference(stk, pci, 2)));

	/* return the identifier */
	v = &stk->stk[getArg(pci, 0)];
	v->vtype = TYPE_str;
	v->val.sval = ident;
	return(MAL_SUCCEED);
}

@mal

# ideally we would like to do this, however that's unfortunately
# impossible since variadic stuff doesn't work in functions
#function exec(conn:str, ident:str...):any;
#	id := remote.exec(conn, ident, ...);
#	ret := remote.get(conn, id);
#	return(ret);
#end exec;

pattern exec(conn:str, mod:str, func:str...):any
address RMTexec
comment "Executes function mod.func over conn using the given arguments and returns its result";
@h
remote_export str RMTexec(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
@c
/**
 * exec executes the function with its given arguments on the remote
 * host, returning the function's return value.  exec is more of a
 * convenience wrapper than a primitive.  It basically first ships all
 * arguments to the remote server using put calls.  It continues by
 * calling the function with the given arguments, and assiging the
 * return value to a variable.  This variable is finally returned using
 * a get call.  The exec method exists because the middle action (actual
 * calling of the function on the remote site) is not possible using get
 * or put calls.
 */
str RMTexec(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci) {
	str conn, mod, func, ident, arg, tmp;
	int i, len;
	connection c;
	char qbuf[512];	/* FIXME: make this dynamic */
	MapiHdl mhdl;

	(void)mb;

	conn = (str)getArgValue(stk, pci, 1);
	if (conn == NULL || strcmp(conn, (str)str_nil) == 0)
		throw(ILLARG, "remote.exec", "connection name is NULL or nil");
	mod = (str)getArgValue(stk, pci, 2);
	if (mod == NULL || strcmp(mod, (str)str_nil) == 0)
		throw(ILLARG, "remote.exec", "module name is NULL or nil");
	func = (str)getArgValue(stk, pci, 3);
	if (func == NULL || strcmp(func, (str)str_nil) == 0)
		throw(ILLARG, "remote.exec", "function name is NULL or nil");

	/* lookup conn */
	rethrow("remote.exec", tmp, RMTfindconn(&c, conn));

	/* get a free identifier on the remote host */
	mhdl = NULL;
	rethrow("remote.exec", tmp, RMTquery(&mhdl, "remote.exec", c->mconn, "remote.getnextid();"));
	mapi_fetch_row(mhdl); /* should succeed */
	ident = mapi_fetch_field(mhdl, 0); /* should be there */
	if (ident == NULL) {
		mapi_close_handle(mhdl);
		throw(MAL, "remote.exec", "missing first column in tuple");
	}

	/* build the function invocation string in qbuf */
	len = 0;
	len += snprintf(&qbuf[len], 511 - len, "%s := %s.%s(", ident, mod, func);
	mapi_close_handle(mhdl);

	/* handle the arguments to the function */
	assert(pci->argc >= 3); /* ret, conn, func, ... */

	/* put the arguments one by one, and dynamically build the
	 * invocation string */
	for (i = 4; i < pci->argc; i++) {
		rethrow("remote.exec", tmp, RMTinternalput(&arg,
					c->mconn,
					getArgType(mb, pci, i),
					getArgReference(stk, pci, i)));
		len += snprintf(&qbuf[len], 511 - len, "%s%s",
				(i > 4 ? ", " : ""), arg);
	}

	/* finish end execute the invocation string */
	len += snprintf(&qbuf[len], 511 - len, ");");
	rethrow("remote.exec", tmp, RMTquery(&mhdl, "remote.exec", c->mconn, qbuf));
	mapi_close_handle(mhdl);  /* we don't care at all about what it outputs */

	/* get the rident value, and return it */
	rethrow("remote.exec", tmp, RMTinternalget(c->mconn,
				ident, &stk->stk[getArg(pci, 0)]));

	return(MAL_SUCCEED);
}

@mal
command create(conn:str, host:str, port:int, dbname:str, user:str, passwd:str):void
address RMTcreate
comment "Creates a new connection conn using the given details";
@h
remote_export str RMTcreate(
		int *ret,
		str *conn,
		str *host,
		int *port,
		str *dbname,
		str *user,
		str *passwd);
@c
str RMTcreate(
		int *ret,
		str *conn,
		str *host,
		int *port,
		str *dbname,
		str *user,
		str *passwd)
{
	connection c;
	int s;

	if (conn == NULL || *conn == NULL || strcmp(*conn, (str)str_nil) == 0)
		throw(ILLARG, "remote.create", "connection name is NULL or nil");
	if ((s = strlen(*conn)) > 15)
		throw(ILLARG, "remote.create", "connection name may not exceed 15 characters");
	if (host == NULL || *host == NULL || strcmp(*host, (str)str_nil) == 0)
		throw(ILLARG, "remote.create", "hostname is NULL or nil");
	if (port == NULL || *port <= 0)
		throw(ILLARG, "remote.create", "port is NULL or <= 0");
	if (dbname == NULL || *dbname == NULL)
		throw(ILLARG, "remote.create", "database name is NULL");
	if (user == NULL || *user == NULL || strcmp(*user, (str)str_nil) == 0)
		throw(ILLARG, "remote.create", "username is NULL or nil");
	if (passwd == NULL || *passwd == NULL || strcmp(*passwd, (str)str_nil) == 0)
		throw(ILLARG, "remote.create", "password is NULL or nil");


	/* find a free slot, start with special case of connections not
	 * being set */
	if (connections == NULL) {
		connections = GDKmalloc(sizeof(struct _connection));
		c = connections;
	} else {
		/* ok, it's set, so find the last element in the list */
		connection t = c = connections;
		do {
			/* at the same time also check if this connection name
			 * already exists */
			if (strcmp(c->name, *conn) == 0)
				throw(MAL, "remote.create", "a connection with name "
						"'%s' already exists", *conn);
			t = c;
			c = c->next;
		} while (c != NULL);
		c = t->next = GDKmalloc(sizeof(struct _connection));
	}
	memcpy(c->name, *conn, s + 1 /* \0 */);
	c->mconn = mapi_mapi(*host, *port, *user, *passwd, "mal",
			(strcmp(*dbname, (str)str_nil) == 0 ? NULL : *dbname));
	c->next = NULL;

	/* just make sure the return isn't garbage */
	*ret = 0;

	return(MAL_SUCCEED);
}

@mal
command destroy(conn:str):void
address RMTdestroy
comment "Destroys a previously created connection";
@h
remote_export str RMTdestroy(int *ret, str *conn);
@c
str RMTdestroy(int *ret, str *conn) {
	connection c = connections, t;

	if (conn == NULL || *conn == NULL || strcmp(*conn, (str)str_nil) == 0)
		throw(ILLARG, "remote.destroy", "connection name is NULL or nil");


	/* just make sure the return isn't garbage */
	*ret = 0;

	/* walk through the list */
	t = NULL;
	while (c != NULL) {
		if (strcmp(c->name, *conn) == 0) {
			/* ok, delete it... */
			if (t == NULL) { /* the top */
				t = c->next;
				mapi_destroy(c->mconn);
				GDKfree(c);
				connections = t;
			} else {
				/* connect the grand child to the grand parent */
				t->next = c->next;
				/* and kill the parent in the middle */
				mapi_destroy(c->mconn);
				GDKfree(c);
			}

			return(MAL_SUCCEED);
		}
	}

	throw(MAL, "remote.destroy", "no such connection with name '%s'", *conn);
}

/* vim: set foldmethod=syntax: */

