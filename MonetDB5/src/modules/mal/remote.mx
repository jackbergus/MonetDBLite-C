@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2008 CWI.
@' All Rights Reserved.

@f remote
@a Fabian Groffen
@+ Remote querying functionality
Communication with other mservers at the MAL level is a delicate task.
However, it is indispensable for any distributed functionality.  This
module provides an abstract way to store and retrieve objects on a
remote site.  Additionally, functions on a remote site can be executed
using objects available in the remote session context.  This yields in
three primitive functions that form the basis for distribution methods:
get, put and exec.

The get method simply retrieves a copy of a remote object.  Objects can
be simple values, strings or BATs.  The same holds for the put method,
but the other way around.  A local object can be stored on a remote
site.  Upon a successful store, the put method returns the remote
identifier for the stored object.  With this identifier the object can
be addressed, e.g. using the get method to retrieve the object that was
stored using put.

The get and put methods are symmetric.  Performing a get on an
identifier that was returned by put, results in an object with the same
value as the one that was put.  The result of such an operation is
equivalent to making an (expensive) copy of the original object.

The choice to let exec only execute functions was made to avoid problems
to decide what should be returned to the caller.  With a function it is
clear and simple to return that what the function signature prescribes.
Any extra output (e.g.  io.print calls) may cause havoc in the system,
but are currently known to be ignored.

This leads to the final contract of this module.  The methods should be
used correctly, by obeying their contract.  Failing to do so will result
in errors and possibly undefined behaviour.

It is impossible to get and put MAL functions directly, as the
semantical meaning of such operation is unclear.  A function cannot be
assigned to a variable (such as get would do).  Storing a function on
a remote site with put could lead to conflicts if a function with the
same name already exists there, let alone if the module the function
comes from is accessible.  Finally, C-implemented functions, such as
io.print() cannot be remotely stored for obvious reasons and would
require even more complicated (byte?) code shipping and remote
compilation to make it work.  

A straw-man's solution is to serialize local MAL function to a string
and use those in an exec call to remotely parse it into a function
again.  Of course this also works the other way around using an exec of
the serialised function on the remote host for the remote function to
acquire the string representation of the function locally.  All possible
name space conflicts that may arise should be handled explicitly.

The first argument to all three functions is the name of the connection
the operation has to be performed on.  A connection has to be created
before it can be used, otherwise a MALexception is being raised.
During creation of such connection, details like credentials, hostname
and database can be given.  Currently, connections are stored in memory
and not made persistent.  This could be changed in the future to allow
created connections to be remembered over server restarts.

@mal
module remote;

command prelude():void
address RMTprelude
comment "Initialise the remote module.";

command epilogue():void
address RMTepilogue
comment "Release the resources held by the remote module.";

command create(conn:str, host:str, port:int, dbname:str, user:str, passwd:str):void
address RMTcreate
comment "Creates a new connection using host name, port, database name,
user name and password given details.";

command destroy(conn:str):void
address RMTdestroy
comment "Destroys a previously created connection.";

pattern get(conn:str, ident:rmtobj):any
address RMTget
comment "Retrieves a copy of a remote object.";

pattern put(conn:str, object:any):rmtobj
address RMTput
comment "Copy an object to a remote site and returns its identifier.";

pattern exec(conn:str, mod:str, func:str):rmtobj
address RMTexec
comment "Remotely executes function mod.func using the argument list
and returns the handle to its result";
pattern exec(conn:str, mod:str, func:str, :rmtobj...):rmtobj
address RMTexec
comment "Remotely executes function mod.func using the argument list
of remote objects and returns the handle to its result";

@h

#ifndef _REMOTE_DEF
#define _REMOTE_DEF

#ifdef WIN32
#ifndef LIBREMOTE
#define remote_export extern __declspec(dllimport)
#else
#define remote_export extern __declspec(dllexport)
#endif
#else
#define remote_export extern
#endif
@c
#include "mal_config.h"
#include <mal.h>
#include <mal_exception.h>
#include <mal_interpreter.h>
#include <mal_function.h> /* for printFunction */
#include <mapilib/Mapi.h>
#include "remote.h"	/* for the implementation of the functions */

@-
TODO: thread safe or not?  Technically, these methods need to be
serialised per connection, hence a scheduler that interleaves e.g.
multiple get calls, simply violates this constraint.  If parallelism to
the same site is desired, a user could create a second connection.
@- Implementation
@h
typedef struct _connection {
	char               name[16];  /* name of the connection,
	                                 15 chars should be enough for everyone */
	Mapi               mconn;     /* the Mapi handle for the connection */
	size_t             nextid;    /* id counter */
	struct _connection *next;     /* the next connection in the list */
} *connection;

remote_export str RMTprelude(int *ret);
remote_export str RMTepilogue(int *ret);

@-

@c
static connection connections = NULL;

/**
 * Helper function to return a connection matching a given string, or an
 * error if it does not exist.  Before the connection is returned, it is
 * made sure that it is usable.  If the connection cannot be made
 * useable, an error is returned.  Since this function is internal, it
 * doesn't check the argument conn, as it should have been checked
 * already.
 */
static INLINE str
RMTfindconn(connection *ret, str conn) {
	connection c = connections;

	/* just make sure the return isn't garbage */
	*ret = NULL;

	/* walk through the list */
	while (c != NULL) {
		if (strcmp(c->name, conn) == 0) {
			/* ok found, ensure it is connected */
			if (mapi_ping(c->mconn) != MOK && mapi_reconnect(c->mconn) != MOK) {
				throw(IO, "remote.<findconn>", "an error occurred during "
						"(re)connect of connection '%s': %s",
						conn, mapi_error_str(c->mconn));
				/* TODO: throw away connection? */
			}
			*ret = c;
			return(MAL_SUCCEED);
		}
	}

	throw(MAL, "remote.<findconn>", "no such connection with name '%s'", conn);
}

/**
 * Little helper function that returns a GDKmalloced string containing a
 * valid identifier that is supposed to be unique in the connection's
 * remote context.  Since this function is internal, it doesn't check
 * the argument conn, as it should have been checked already.
 */
static INLINE str /*synchronized*/
RMTgetNextId(str *ret, connection conn) {
	char buf[128];
	snprintf(buf, 128, "remote_%s_id_" SZFMT, conn->name, conn->nextid++);
	*ret = GDKstrdup(buf);
	return(MAL_SUCCEED);
}

/**
 * Helper function to execute a query over the given connection,
 * returning the result handle.  If communication fails in one way or
 * another, an error is returned.  Since this function is internal, it
 * doesn't check the input arguments func, conn and query, as they
 * should have been checked already.
 */
static INLINE str
RMTquery(MapiHdl *ret, str func, Mapi conn, str query) {
	MapiHdl mhdl;

	*ret = NULL;
	mhdl = mapi_query(conn, query);
	if (mhdl) {
		if (mapi_result_error(mhdl) != NULL) {
			str err = createException(
					getExceptionType(mapi_result_error(mhdl)),
					func,
					"%s", getExceptionMessage(mapi_result_error(mhdl)));
			mapi_close_handle(mhdl);
			return(err);
		}
	} else {
		if (mapi_error(conn) != MOK) {
			throw(IO, func, "an error occurred on connection: %s",
					mapi_error_str(conn));
		} else {
			throw(MAL, func, "remote function invocation didn't return a result");
		}
	}

	*ret = mhdl;
	return(MAL_SUCCEED);
}

str RMTprelude(int *ret) {
	(void)ret;

	return(MAL_SUCCEED);
}

str RMTepilogue(int *ret) {
	connection c = connections, t;

	(void)ret;

	/* free connections list */
	while (c != NULL) {
		t = c;
		c = c->next;
		mapi_destroy(t->mconn);
		GDKfree(t);
	}
	/* not sure, but better be safe than sorry */
	connections = NULL;

	return(MAL_SUCCEED);
}

@h
remote_export str RMTget(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
@c
/**
 * get fetches the object referenced by ident over connection conn.
 */
str RMTget(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci) {
	str conn, ident, tmp;
	connection c;
	char qbuf[512];
	MapiHdl mhdl;
	int rtype;
	ValPtr v;

	(void)cntxt;
	(void)mb;

	conn = (str)getArgValue(stk, pci, 1);
	if (conn == NULL || strcmp(conn, (str)str_nil) == 0)
		throw(ILLARG, "remote.get", "connection name is NULL or nil");
	ident = (str)getArgValue(stk, pci, 2);
	if (isIdentifier(ident) < 0)
		throw(ILLARG, "remote.get", "identifier expected, got '%s'", ident);

	/* lookup conn, set mconn if valid */
	rethrow("remote.get", tmp, RMTfindconn(&c, conn));

	rtype = getArgType(mb, pci, 0);
	v = &stk->stk[getArg(pci, 0)];

	if (rtype == TYPE_any || isAnyExpression(rtype)) {
		throw(MAL, "remote.get", "cannot deal with any (%s) type",
				getTypeName(rtype));
	}

	if (isaBatType(rtype)) {
		int h, t, s;
		ptr l, r;
		lng len;
		str val, var;
		BAT *b;

		snprintf(qbuf, 511, "user.remote_internal_servegetbat(\"%s\", %s);",
				getTypeName(rtype), ident);
		rethrow("remote.get", tmp,
				RMTquery(&mhdl, "remote.get", c->mconn, qbuf));
		mapi_fetch_row(mhdl); /* should succeed */
		val = mapi_fetch_field(mhdl, 0);
		if (val == NULL) {
			mapi_close_handle(mhdl);
			throw(MAL, "remote.get", "missing first column in tuple");
		}
		len = atol(val);

#if SIZEOF_SIZE_T == 4
		if ((lng)(len & 0x80000000FFFFFFFF) != len)
			throw(MAL, "remote.get", "remote BAT is too big for this "
					"32-bits (configured) system");
#endif
		/* FIXME: len < 0 ???? */

		assert(0 <= len && len <= (lng)GDK_oid_max);
		h = getHeadType(rtype);
		t = getTailType(rtype);
		b = BATnew(h, t, (size_t)len);

		while (len-- > 0) {
			if (mapi_fetch_row(mhdl) == 0) {
				mapi_close_handle(mhdl);
				throw(MAL, "remote.get",
						"expected %d more rows in result", len + 1);
			}
			val = mapi_fetch_field(mhdl, 0); /* should both be there */
			var = mapi_fetch_field(mhdl, 1);
			if (ATOMvarsized(h)) {
				l = (ptr)(val == NULL ? str_nil : val);
			} else {
				s = 0;
				l = NULL;
				if (val == NULL)
					val = "nil";
				ATOMfromstr(h, &l, &s, val);
			}
			if (ATOMvarsized(t)) {
				r = (ptr)(var == NULL ? str_nil : var);
			} else {
				s = 0;
				r = NULL;
				if (var == NULL)
					var = "nil";
				ATOMfromstr(t, &r, &s, var);
			}

			BUNins(b, l, r, FALSE);

			if (!ATOMvarsized(h)) GDKfree(l);
			if (!ATOMvarsized(t)) GDKfree(r);
		}

		v->val.ival = b->batCacheid;
	} else {
		ptr p = NULL;
		str val;
		int len = 0;

		snprintf(qbuf, 511, "user.remote_internal_serveget(\"%s\", %s);",
				getTypeName(rtype), ident);
		rethrow("remote.get", tmp,
				RMTquery(&mhdl, "remote.get", c->mconn, qbuf));
		mapi_fetch_row(mhdl); /* should succeed */
		val = mapi_fetch_field(mhdl, 0);

		if (ATOMvarsized(rtype)) {
			VALset(v, rtype, GDKstrdup(val == NULL ? str_nil : val));
		} else {
			ATOMfromstr(rtype, &p, &len, val == NULL ? "nil" : val);
			if (p != NULL) {
				VALset(v, rtype, p);
				if (ATOMextern(rtype) == 0)
					GDKfree(p);
			} else {
				char tval[512];
				snprintf(tval, 511, "%s", val);
				tval[511] = '\0';
				mapi_close_handle(mhdl);
				throw(MAL, "remote.get", "unable to parse value '%s'", tval);
			}
		}
	}

	mapi_close_handle(mhdl);

	return(MAL_SUCCEED);
}

@h
remote_export str RMTput(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
@c
/**
 * stores the given object on the remote host.  The identifier of the
 * object on the remote host is returned for later use.
 */
str RMTput(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci) {
	str conn, tmp;
	str ident;
	connection c;
	ValPtr v;
	int type;
	ptr value;
	MapiHdl mhdl = NULL;

	(void)cntxt;

	conn = (str)getArgValue(stk, pci, 1);
	if (conn == NULL || strcmp(conn, (str)str_nil) == 0)
		throw(ILLARG, "remote.put", "connection name is NULL or nil");

	/* lookup conn */
	rethrow("remote.put", tmp, RMTfindconn(&c, conn));

	/* put the thing */
	type = getArgType(mb, pci, 2);
	value = getArgReference(stk, pci, 2);

	/* get a free identifier for the remote host */
	RMTgetNextId(&tmp, c);
	/* allocate on the stack as not to leak when we error lateron */
	ident = alloca(sizeof(char) * (strlen(tmp) + 1));
	memcpy(ident, tmp, strlen(tmp) + 1);
	GDKfree(tmp); /* FIXME, this is inefficient... */

	/* depending on the input object generate actions to store the
	 * object remotely*/
	if (type == TYPE_any || isAnyExpression(type)) {
		throw(MAL, "remote.put", "cannot deal with '%s' type",
				getTypeName(type));
	} else if (isaBatType(type)) {
		BATiter bi;
		/* naive approach using bat.new() and bat.insert() calls */
		char head[10], tail[10];
		char qbuf[512]; /* FIXME: this should be dynamic */
		int bid;
		BAT *b;
		BUN p, q;
		str headv, tailv;

		if (getHeadIndex(type) > 0) {
			sprintf(head, "any%c%d", TMPMARKER, getHeadIndex(type));
		} else if (getHeadType(type) == TYPE_any) {
			sprintf(head, "any");
		} else {
			sprintf(head, "%s", ATOMname(getHeadType(type)));
		}
		if (getTailIndex(type) > 0) {
			sprintf(tail, "any%c%d", TMPMARKER, getTailIndex(type));
		} else if (getTailType(type) == TYPE_any) {
			sprintf(tail, "any");
		} else {
			sprintf(tail, "%s", ATOMname(getTailType(type)));
		}

		bid = *(int *)value;
		if ((b = BATdescriptor(bid)) == NULL)
			throw(MAL, "remote.put", "cannot access BAT descriptor");

		qbuf[511] = '\0';
		snprintf(qbuf, 511, "%s := bat.new(:%s, :%s, " SZFMT ");",
				ident, head, tail, BATcount(b));

		rethrow("remote.put", tmp, RMTquery(&mhdl, "remote.put", c->mconn, qbuf));
		mapi_close_handle(mhdl);

		headv = tailv = NULL;
		bi = bat_iterator(b);
		BATloop(b, p, q) {
			ATOMformat(getHeadType(type), BUNhead(bi, p), &headv);
			ATOMformat(getTailType(type), BUNtail(bi, p), &tailv);
			snprintf(qbuf, 511, "bat.insert(%s, %s:%s, %s:%s);",
					ident, headv, head, tailv, tail);
			rethrow("remote.put", tmp, RMTquery(&mhdl, "remote.put", c->mconn, qbuf));
			/* we leak headv and tailv here if an exception is thrown */
			mapi_close_handle(mhdl);
		}
		GDKfree(headv);
		GDKfree(tailv);
		BBPunfix(b->batCacheid);
	} else {
		str val = NULL;
		char qbuf[512]; /* FIXME: this should be dynamic */
		if (ATOMvarsized(type)) {
			ATOMformat(type, *(str *)value, &val);
		} else {
			ATOMformat(type, value, &val);
		}
		snprintf(qbuf, 511, "%s := %s:%s;\n", ident, val, ATOMname(type));
		qbuf[511] = '\0';
		GDKfree(val);
		rethrow("remote.put", tmp, RMTquery(&mhdl, "remote.put", c->mconn, qbuf));
		mapi_close_handle(mhdl);
	}

	/* return the identifier */
	v = &stk->stk[getArg(pci, 0)];
	v->vtype = TYPE_str;
	v->val.sval = GDKstrdup(ident);
	return(MAL_SUCCEED);
}

@h
remote_export str RMTexec(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
@c
/**
 * exec executes the function with its given arguments on the remote
 * host, returning the function's return value.  exec is purposely kept
 * very spartan.  All arguments need to handles to previously put()
 * values.  It calls the function with the given arguments at the remote
 * site, and returns the handle which stores the return value of the
 * remotely executed function.  This return value can be retrieved using
 * a get call.
 */
str RMTexec(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci) {
	str conn, mod, func, ident, tmp;
	int i, len;
	connection c;
	char qbuf[512];	/* FIXME: make this dynamic */
	MapiHdl mhdl;

	(void)cntxt;
	(void)mb;

	conn = (str)getArgValue(stk, pci, 1);
	if (conn == NULL || strcmp(conn, (str)str_nil) == 0)
		throw(ILLARG, "remote.exec", "connection name is NULL or nil");
	mod = (str)getArgValue(stk, pci, 2);
	if (mod == NULL || strcmp(mod, (str)str_nil) == 0)
		throw(ILLARG, "remote.exec", "module name is NULL or nil");
	func = (str)getArgValue(stk, pci, 3);
	if (func == NULL || strcmp(func, (str)str_nil) == 0)
		throw(ILLARG, "remote.exec", "function name is NULL or nil");

	/* lookup conn */
	rethrow("remote.exec", tmp, RMTfindconn(&c, conn));

	/* get a free identifier on the remote host */
	RMTgetNextId(&tmp, c);
	i = (int)strlen(tmp) + 1;
	ident = alloca(sizeof(char) * i);
	memcpy(ident, tmp, i);
	GDKfree(tmp);

	/* build the function invocation string in qbuf */
	len = 0;
	len += snprintf(&qbuf[len], 511 - len, "%s := %s.%s(", ident, mod, func);

	/* handle the arguments to the function */
	assert(pci->argc >= 3); /* ret, conn, func, ... */

	/* put the arguments one by one, and dynamically build the
	 * invocation string */
	for (i = 4; i < pci->argc; i++) {
		/* all arguments are of type rmtobj, at least we blindly trust
		 * the parser that it makes sure, we can cast to a string
		 * pointer as long as rmtobj is nothing more than that */
		len += snprintf(&qbuf[len], 511 - len, "%s%s",
				(i > 4 ? ", " : ""),
				*((str *)getArgReference(stk, pci, i)));
	}

	/* finish end execute the invocation string */
	len += snprintf(&qbuf[len], 511 - len, ");");
	rethrow("remote.exec", tmp, RMTquery(&mhdl, "remote.exec", c->mconn, qbuf));
	mapi_close_handle(mhdl);  /* we don't care at all about what it outputs */

	/* return the rident */
	VALset(&stk->stk[getArg(pci, 0)],
			stk->stk[getArg(pci, 0)].vtype, GDKstrdup(ident));
	return(MAL_SUCCEED);
}

@h
remote_export str RMTcreate(
		int *ret,
		str *conn,
		str *host,
		int *port,
		str *dbname,
		str *user,
		str *passwd);
@c
#define serveget "\
    function user.remote_internal_servegetbat(type:str, o:bat[:any_1,:any_2]):void;\n\
        t := inspect.getType(o);\n\
        barrier ifpart := type == t;\n\
			len := aggr.count(o);\n\
			io.print(len);\n\
            io.print(o);\n\
        exit ifpart;\n\
		barrier ifpart := calc.isnil(type);\n\
			io.printf(\"!MALException:user.serveget:nil type doesn't match anything\n\");\n\
		exit ifpart;\n\
		barrier ifpart := type != t;\n\
			io.printf(\"!MALException:user.serveget:object type (%s) \", t);\n\
			io.printf(\"does not match required type (%s)\n\", type);\n\
		exit ifpart;\n\
    end user.remote_internal_servegetbat;\n\
    function user.remote_internal_serveget(type:str, o:any):void;\n\
        t := inspect.getType(o);\n\
        barrier ifpart := type == t;\n\
            io.print(o);\n\
        exit ifpart;\n\
		barrier ifpart := calc.isnil(type);\n\
			io.printf(\"!MALException:user.serveget:nil type doesn't match anything\n\");\n\
		exit ifpart;\n\
		barrier ifpart := type != t;\n\
			io.printf(\"!MALException:user.serveget:object type (%s) \", t);\n\
			io.printf(\"does not match required type (%s)\n\", type);\n\
		exit ifpart;\n\
    end user.remote_internal_serveget;\n\
"
str RMTcreate(
		int *ret,
		str *conn,
		str *host,
		int *port,
		str *dbname,
		str *user,
		str *passwd)
{
	connection c;
	int s;
	MapiHdl mhdl;
	str tmp;

	if (conn == NULL || *conn == NULL || strcmp(*conn, (str)str_nil) == 0)
		throw(ILLARG, "remote.create", "connection name is NULL or nil");
	if ((s = (int) strlen(*conn)) > 15)
		throw(ILLARG, "remote.create", "connection name may not exceed 15 characters");
	if (host == NULL || *host == NULL || strcmp(*host, (str)str_nil) == 0)
		throw(ILLARG, "remote.create", "hostname is NULL or nil");
	if (port == NULL || *port <= 0)
		throw(ILLARG, "remote.create", "port is NULL or <= 0");
	if (dbname == NULL || *dbname == NULL)
		throw(ILLARG, "remote.create", "database name is NULL");
	if (user == NULL || *user == NULL || strcmp(*user, (str)str_nil) == 0)
		throw(ILLARG, "remote.create", "username is NULL or nil");
	if (passwd == NULL || *passwd == NULL || strcmp(*passwd, (str)str_nil) == 0)
		throw(ILLARG, "remote.create", "password is NULL or nil");


	/* find a free slot, start with special case of connections not
	 * being set */
	if (connections == NULL) {
		connections = GDKmalloc(sizeof(struct _connection));
		c = connections;
	} else {
		/* ok, it's set, so find the last element in the list */
		connection t = c = connections;
		do {
			/* at the same time also check if this connection name
			 * already exists */
			if (strcmp(c->name, *conn) == 0)
				throw(MAL, "remote.create", "a connection with name "
						"'%s' already exists", *conn);
			t = c;
			c = c->next;
		} while (c != NULL);
		c = t->next = GDKmalloc(sizeof(struct _connection));
	}
	memcpy(c->name, *conn, s + 1 /* \0 */);
	c->mconn = mapi_mapi(*host, *port, *user, *passwd, "mal",
			(strcmp(*dbname, (str)str_nil) == 0 ? NULL : *dbname));
	c->nextid = 0;
	c->next = NULL;

	if (mapi_reconnect(c->mconn) != MOK)
		throw(IO, "remote.create", "an error occurred during "
				"connect of connection '%s': %s",
				conn, mapi_error_str(c->mconn));
	/* TODO: throw away connection? */

	/* initialise remote helper function */
	rethrow("remote.create", tmp,
			RMTquery(&mhdl, "remote.create", c->mconn, serveget));
	mapi_close_handle(mhdl);

	/* just make sure the return isn't garbage */
	*ret = 0;

	return(MAL_SUCCEED);
}

@h
remote_export str RMTdestroy(int *ret, str *conn);
@c
str RMTdestroy(int *ret, str *conn) {
	connection c = connections, t;

	if (conn == NULL || *conn == NULL || strcmp(*conn, (str)str_nil) == 0)
		throw(ILLARG, "remote.destroy", "connection name is NULL or nil");


	/* just make sure the return isn't garbage */
	*ret = 0;

	/* walk through the list */
	t = NULL;
	while (c != NULL) {
		if (strcmp(c->name, *conn) == 0) {
			/* ok, delete it... */
			if (t == NULL) { /* the top */
				t = c->next;
				mapi_destroy(c->mconn);
				GDKfree(c);
				connections = t;
			} else {
				/* connect the grand child to the grand parent */
				t->next = c->next;
				/* and kill the parent in the middle */
				mapi_destroy(c->mconn);
				GDKfree(c);
			}

			return(MAL_SUCCEED);
		}
	}

	throw(MAL, "remote.destroy", "no such connection with name '%s'", *conn);
}
@h
#endif
@}
