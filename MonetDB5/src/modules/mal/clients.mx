@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2005 CWI.
@' All Rights Reserved.

@f clients
@a Martin Kersten
@v 0.1
@* Client management

This module contains the primitives to inspect and adjust
the client records maintained during a session.
A rudimentary authorization scheme should be provided[todo].
@mal
module clients;

command setListing(flg:int):int
address CLTsetListing
comment "Turn on/off echo of MAL instructions:
	2 - show mal instruction,
	4 - show type resolutoin, 
	8 - show binding information";

command setDebug(flg:int):void
address CLTsetDebug
comment "Set the debugging bitset. See configuration file and documentation";

#command setPassword(s:str)
#address CLTsetPassword
#comment "Change the password for the client";

command setHistory(s:str)
address CLTsetHistory
comment "Designate console history file";

command getUsers( ):bat[:int,:str] 
address CLTusers
comment "Pseudo bat of users logged in";
command getLogins( ):bat[:int,:str] 
address CLTLogin
comment "Pseudo bat of client login time";

command getId():int
address CLTgetClientId
comment "return a number that unique represents the current client";
command getInfo( ):bat[:int,:str] 
address CLTInfo
comment "Pseudo bat with client attributes";

command getScenario():str 
address CLTgetScenario
comment "Retrieve current scenario name";
command setScenario(msg:str):str 
address CLTsetScenario
comment "Switch to other scenario handler, return previous one";

command quit():void
address CLTquit
comment "Terminate the session for this client"';

@+ User administration
These commands (except newPassword) can only be executed by the server owner.
@mal
command addUser(nme:str, pw:str, sc:str):void
address CLTaddUser
comment "Give a user permission to access a scenario";
command delUser(nme:str):void
address CLTdelUserAll
comment "Retract a user any permission ";
command delUser(nme:str,sc:str):void
address CLTdelUser
comment "Retract a user permission to access a scenario";

command newPassword(old:str,new:str)
address CLTnewPassword
comment "Change the password for the current user";
command newPassword(usr:str, old:str,new:str)
address CLTnewPasswordRoot
comment "Change the password for a user";

command checkPermission(usr:str,pw:str,sc:str):bit
address CLTcheckAuthorization
comment "Check permission for a user";
command getPasswords():bat[:str,:str]
address CLTgetPasswords
comment "Retrieve the complete password table";
command getPermissions():bat[:str,:str]
address CLTgetPermissions
comment "Return the table with external users";

@-
@{
@include prelude.mx
@+ Monet client data
Portions of the client record can be directly obtained for
backward compatibility. The routine clientInfo provides more
detailed information.
@h
#ifndef _CLIENTS_H
#define _CLIENTS_H
#include "mal.h"

mal_export str CLTsetListing(int *ret, int *flag);
mal_export str CLTgetClientId(int *ret);
mal_export str CLTgetScenario(str *ret);
mal_export str CLTsetScenario(str *ret, str *nme);
mal_export str CLTusers(int *ret);
mal_export str CLTsetDebug(int *ret, int *flg);
mal_export str CLTsetHistory(int *ret, str *fname);
mal_export str CLTclearDebug(int *ret, int *flg);
mal_export str CLTquit(int *ret);
mal_export str CLTLogin(int *ret);
mal_export str CLTInfo(int *ret);

mal_export str CLTaddUser(int *ret, str *usr, str *pw, str *sc);
mal_export str CLTdelUserAll(int *ret, str *usr);
mal_export str CLTdelUser(int *ret, str *usr, str *sc);
mal_export str CLTnewPassword(int *ret, str *old, str *new);
mal_export str CLTnewPasswordRoot(int *ret, str *usr, str *old, str *new);
mal_export str CLTgetPermissions(int *ret);
mal_export str CLTgetPasswords(int *ret);
mal_export str CLTgetAuthorization(int *ret, str *usr);
mal_export str CLTcheckAuthorization(bit *ret,str *usr, str *pw, str *sc);

#endif /* _CLIENTS_H */
@- Module initializaton
The content of this clients table my only be changed by the Administrator
or the client himself
@= authorize
	if (!isServerOwner(getClient())
		return throwMessage("clients.@1", "unauthorized access to 'clients' box");
@-
@c
#include "clients.h"
#include "mal_scenario.h"
#include "mal_instruction.h"
#include "mal_client.h"
#include "mal_authorize.h"

#ifdef HAVE_LIBREADLINE
#include <readline/readline.h>
#include <readline/history.h>
#endif

str
CLTsetListing(int *ret, int *flag)
{
	Client c;

	(void) ret;		/*fool compiler */
	c = getClient();
	*ret = c->listing;
	c->listing = *flag;
	return MAL_SUCCEED;
}

str
CLTgetClientId(int *ret)
{
	Client c = getClient();

	*ret = c - mal_clients;
	return MAL_SUCCEED;
}

str
CLTgetScenario(str *ret)
{
	Client c = getClient();

	if (c->scenario)
		*ret = GDKstrdup(c->scenario);
	else
		*ret = GDKstrdup("nil");
	return MAL_SUCCEED;
}

str
CLTsetScenario(str *ret, str *nme)
{
	Client c = getClient();
	str msg = MAL_SUCCEED;

	msg = setScenario(c, *nme);
	*ret = 0;
	if (msg == NULL)
		*ret = GDKstrdup(c->scenario);
	return msg;
}

static char *
local_itoa(int i)
{
	static char buf[32];

	sprintf(buf, "%d", i);
	return buf;
}

str
CLTInfo(int *ret)
{
	Client c = getClient();
	BAT *b = BATnew(TYPE_str, TYPE_str, 12);

	if (b == 0)
		return throwMessage("catalog.clientInfo", "failed to create BAT");

	BUNins(b, "user", c->user);
	BUNins(b, "password", (c->password ? c->password : ""));
	BUNins(b, "permission", local_itoa(c->permission));
	BUNins(b, "scenario", c->scenario);
	BUNins(b, "timer", local_itoa((int) c->timer));
	BUNins(b, "trace", local_itoa(c->itrace));
	@:Pseudo(client,info,)@
	return MAL_SUCCEED;
}

str
CLTLogin(int *ret)
{
	BAT *b = BATnew(TYPE_int, TYPE_str, 12);
	int i;
	char s[26];

	if (b == 0)
		return throwMessage("catalog.clientLogin", "failed to create BAT");
	for (i = 0; i < MAL_MAXCLIENTS; i++) {
		Client c = mal_clients+i;
		if (c->mode >= CLAIMED && c->user) {
			time_t logintime = (time_t) c->login;
			struct tm localt;

#ifdef HAVE_LOCALTIME_R
			(void) localtime_r(&logintime, &localt);
#else
			/* race condition: return value could be
			 * overwritten in parallel thread before
			 * assignment complete */
			localt = *localtime(&logintime);
#endif

#ifdef HAVE_ASCTIME_R3
			asctime_r(&localt, s, sizeof(s));
#else
#ifdef HAVE_ASCTIME_R
			asctime_r(&localt, s);
#else
			/* race condition: return value could be
			 * overwritten in parallel thread before copy
			 * complete, however on Windows, asctime is
			 * thread-safe */
			strncpy(s, asctime(&localt), 26);
#endif
#endif
			s[24] = 0;
			BUNins(b, &i, s);
		}
	}
	@:Pseudo(client,login,)@
	return MAL_SUCCEED;
}

@-
Produce a list of clients currently logged in
@c
str
CLTusers(int *ret)
{
	BAT *b = BATnew(TYPE_int, TYPE_str, 12);
	int i;

	if (b == 0)
		return throwMessage("clients.users", "failed to create BAT");
	for (i = 0; i < MAL_MAXCLIENTS; i++) {
		Client c = mal_clients+i;
		if (c->mode >= CLAIMED && c->user)
			b = BUNins(b, &i, c->user);
	}
	@:Pseudo(client,users,)@
	return MAL_SUCCEED;
}

str
CLTsetDebug(int *ret, int *flg)
{
	(void) ret;
	(void) flg;		/*fool compiler */
	return throwMessage("clients.setDebug", "not yet implemented");
}

str
CLTsetHistory(int *ret, str *fname)
{
	Client c= getClient();
	(void) ret;
	if( c->history){
#ifdef HAVE_LIBREADLINE
		write_history(c->history);
#endif
		GDKfree(c->history);
	}
	if( *fname == str_nil)
		c->history = NULL;
	else {
		c->history = GDKstrdup(*fname);
#ifdef HAVE_LIBREADLINE
		read_history(c->history);
#endif
	}
	return MAL_SUCCEED;
}

str
CLTclearDebug(int *ret, int *flg)
{
	(void) ret;
	(void) flg;		/*fool compiler */
	return throwMessage("clients.clearDebug", "not yet implemented");
}

str
CLTquit(int *ret)
{
	Client c = getClient();

	(void) ret;		/* fool compiler */
	c->mode = FINISHING;
	return MAL_SUCCEED;
}


str CLTaddUser(int *ret, str *usr, str *pw, str *sc){
	(void) ret;
	return introduceUser(*usr,*pw,*sc);
}
str CLTdelUserAll(int *ret, str *usr){
	(void) ret;
	return dropAllFromUser(*usr);
}
str CLTdelUser(int *ret, str *usr, str *sc){
	(void) ret;
	return dropUser(*usr,*sc);
}
str CLTnewPassword(int *ret, str *old, str *new){
	Client c = getClient();
	(void) ret;
	return setNewPassword(c->user, *old, *new);
}
str CLTnewPasswordRoot(int *ret, str *usr, str *old, str *new){
	Client c = getClient();
	(void) ret;
	if( strcmp(c->user, cuserid(NULL))== 0)
		return setNewPassword(*usr, *old, *new);
	return throwMessage("clients.newpassword","Not allowed");
}
str CLTgetPermissions(int *ret){
	Client c = getClient();
	if( strcmp(c->user, cuserid(NULL))== 0){
		*ret = getAllPermissions();
		return MAL_SUCCEED;
	}
	printf("user %s owner %s\n",c->user, cuserid(NULL));
	return throwMessage("clients.getAuthorizations","Not allowed");
}
str CLTgetPasswords(int *ret){
	Client c = getClient();
	if( strcmp(c->user, cuserid(NULL))== 0){
		*ret = getAllPasswords();
		return MAL_SUCCEED;
	}
	printf("user %s owner %s\n",c->user, cuserid(NULL));
	return throwMessage("clients.getAuthorizations","Not allowed");
}

str CLTcheckAuthorization(bit *ret,str *usr, str *pw, str *sc){
	Client c = getClient();
	if( strcmp(c->user, cuserid(NULL))== 0){
		*ret = checkAuthorization(*usr, *pw ,*sc);
		return MAL_SUCCEED;
	}
	return throwMessage("clients.checkAuthorizations","Not allowed");
}

@}
