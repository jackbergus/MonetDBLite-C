@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
@' Copyright August 2008-2009 MonetDB B.V.
@' All Rights Reserved.

@f clients
@a Martin Kersten, Fabian Groffen
@v 0.2
@+ Client Management
Each online client is represented with an entry in the clients table.
The client may inspect his record at run-time and partially change its
properties.
The administrator sees all client records and has the right to
adjust global properties.
@mal
module clients;

pattern setListing(flag:int):int
address CLTsetListing
comment "Turn on/off echo of MAL instructions:
	2 - show mal instruction,
	4 - show details of type resolutoin, 
	8 - show binding information.";

pattern setHistory(s:str)
address CLTsetHistory
comment "Designate console history file for readline.";

pattern getId():int
address CLTgetClientId
comment "Return a number that uniquely represents the current client.";

pattern getInfo( ):bat[:str,:str] 
address CLTInfo
comment "Pseudo bat with client attributes.";

pattern getScenario():str 
address CLTgetScenario
comment "Retrieve current scenario name.";
pattern setScenario(msg:str):str 
address CLTsetScenario
comment "Switch to other scenario handler, return previous one.";

pattern quit():void
address CLTquit
comment "Terminate the client session.";

pattern quit(idx:int):void
address CLTquit
comment "Terminate the session for a single client using a soft error.
It is the privilige of the console user.";

@-
Administrator operations
@mal
command getLogins( ):bat[:int,:str] 
address CLTLogin
comment "Pseudo bat of client login time.";

command getLastCommand( ):bat[:int,:str] 
address CLTLastCommand
comment "Pseudo bat of client's last command time.";

command getActions( ):bat[:int,:int] 
address CLTActions
comment "Pseudo bat of client's command counts.";

command getTime( ):bat[:int,:lng] 
address CLTTime
comment "Pseudo bat of client's total time usage(in usec).";

command getUsers( ):bat[:int,:str] 
address CLTusers
comment "Pseudo bat of users logged in.";

pattern stop(id:int)
address CLTstop
comment "Stop the query execution at the next eligble statement.";

pattern suspend(id:int):void
address CLTsuspend
comment "Put a client process to sleep for some time.
It will simple sleep for a second at a time, until
the awake bit has been set in its descriptor";
command wakeup(id:int):void
address CLTwakeup
comment "Wakeup a client process";

command shutdown(forced:bit):void
address CLTshutdown
comment "Close all client connections. If forced=false the
clients are moved into FINISHING mode, which means that
the process stops at the next cycle of the scenario.
If forced=true all client processes are immediately killed";
@-
@{
@include prelude.mx
@+ Monet client data
Portions of the client record can be directly obtained for
backward compatibility. The routine clientInfo provides more
detailed information.
@h
#ifndef _CLIENTS_H
#define _CLIENTS_H
#include "mal.h"
#include "mal_interpreter.h"

#ifdef WIN32
#ifndef LIBCLIENTS
#define clients_export extern __declspec(dllimport)
#else
#define clients_export extern __declspec(dllexport)
#endif
#else
#define clients_export extern
#endif

clients_export str CLTsetListing(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
clients_export str CLTgetClientId(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
clients_export str CLTgetScenario(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
clients_export str CLTsetScenario(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
clients_export str CLTchangeUsername(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
clients_export str CLTusers(int *ret);
clients_export str CLTsetHistory(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
clients_export str CLTquit(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
clients_export str CLTLogin(int *ret);
clients_export str CLTLastCommand(int *ret);
clients_export str CLTActions(int *ret);
clients_export str CLTTime(int *ret);
clients_export str CLTInfo(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
clients_export str CLTstop(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
clients_export str CLTsuspend(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
clients_export str CLTwakeup(int *ret, int *id);

clients_export str CLTgetUsername(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
clients_export str CLTaddUser(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
clients_export str CLTremoveUser(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
clients_export str CLTchangePassword(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
clients_export str CLTsetPassword(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
clients_export str CLTcheckPermission(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
clients_export str CLTaddScenario(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
clients_export str CLTremoveScenario(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
clients_export str CLTgetUsers(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
clients_export str CLTshutdown(int *ret, bit *forced);

#endif /* _CLIENTS_H */
@c
#include "mal_config.h"
#include "clients.h"
#include "mal_scenario.h"
#include "mal_instruction.h"
#include "mal_client.h"
#include "mal_authorize.h"

#ifdef HAVE_LIBREADLINE
#include <readline/readline.h>
#include <readline/history.h>
#endif

str
CLTsetListing(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	(void) mb;
	*(int*) getArgReference(stk,pci,0) = cntxt->listing;
	cntxt->listing = *(int*) getArgReference(stk,pci,1);
	return MAL_SUCCEED;
}

str
CLTgetClientId(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	(void) mb;
	assert(cntxt - mal_clients <= INT_MAX);
	*(int*) getArgReference(stk,pci,0) = (int) (cntxt - mal_clients);
	return MAL_SUCCEED;
}

str
CLTgetScenario(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	(void) mb;
	if (cntxt->scenario)
		*(str *) getArgReference(stk,pci,0) = GDKstrdup(cntxt->scenario);
	else
		*(str *) getArgReference(stk,pci,0) = GDKstrdup("nil");
	return MAL_SUCCEED;
}

str
CLTsetScenario(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	str msg = MAL_SUCCEED;

	(void) mb;
	msg = setScenario(cntxt, *(str *) getArgReference(stk,pci,1));
	*(str *) getArgReference(stk,pci,0) = 0;
	if (msg == NULL)
		*(str *) getArgReference(stk,pci,0) = GDKstrdup(cntxt->scenario);
	return msg;
}

static char *
local_itoa(int i)
{
	static char buf[32];

	sprintf(buf, "%d", i);
	return buf;
}

void
CLTtimeConvert(time_t l, char *s){
			struct tm localt;

#ifdef HAVE_LOCALTIME_R
			(void) localtime_r(&l, &localt);
#else
			/* race condition: return value could be
			 * overwritten in parallel thread before
			 * assignment complete */
			localt = *localtime(&l);
#endif

#ifdef HAVE_ASCTIME_R3
			asctime_r(&localt, s, 26);
#else
#ifdef HAVE_ASCTIME_R
			asctime_r(&localt, s);
#else
			/* race condition: return value could be
			 * overwritten in parallel thread before copy
			 * complete, however on Windows, asctime is
			 * thread-safe */
			strncpy(s, asctime(&localt), 26);
#endif
#endif
			s[24] = 0;
}

str
CLTInfo(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	int *ret=  (int *) getArgReference(stk,pci,0);
	BAT *b = BATnew(TYPE_str, TYPE_str, 12);
	char s[26];

	(void) mb;
	if (b == 0)
		throw(MAL, "clients.info", MAL_MALLOC_FAIL);

	BUNins(b, "user", local_itoa((int)cntxt->user), FALSE);
	BUNins(b, "password", "", FALSE); /* FIXME: get rid of this */
	BUNins(b, "scenario", cntxt->scenario, FALSE);
	BUNins(b, "timer", local_itoa((int) cntxt->timer), FALSE);
	BUNins(b, "trace", local_itoa(cntxt->itrace), FALSE);
	BUNins(b, "listing", local_itoa(cntxt->listing), FALSE);
	BUNins(b, "debug", local_itoa(cntxt->debug), FALSE);
	CLTtimeConvert((time_t) cntxt->login,s);
	BUNins(b, "login", s, FALSE);
	CLTtimeConvert((time_t) cntxt->delay,s);
	BUNins(b, "delay", s, FALSE);
	if (!(b->batDirty&2)) b = BATsetaccess(b, BAT_READ);
	@:Pseudo(client,info,)@
	return MAL_SUCCEED;
}

str
CLTLogin(int *ret)
{
	BAT *b = BATnew(TYPE_int, TYPE_str, 12);
	int i;
	char s[26];

	if (b == 0)
		throw(MAL, "clients.getLogins", MAL_MALLOC_FAIL);
	for (i = 0; i < MAL_MAXCLIENTS; i++) {
		Client c = mal_clients+i;
		if (c->mode >= CLAIMED && c->user != oid_nil) {
			CLTtimeConvert((time_t) c->login,s);
			BUNins(b, &i, s, FALSE);
		}
	}
	if (!(b->batDirty&2)) b = BATsetaccess(b, BAT_READ);
	@:Pseudo(client,login,)@
	return MAL_SUCCEED;
}

str
CLTLastCommand(int *ret)
{
	BAT *b = BATnew(TYPE_int, TYPE_str, 12);
	int i;
	char s[26];

	if (b == 0)
		throw(MAL, "clients.getLastCommand", MAL_MALLOC_FAIL);
	for (i = 0; i < MAL_MAXCLIENTS; i++) {
		Client c = mal_clients+i;
		if (c->mode >= CLAIMED && c->user != oid_nil) {
			CLTtimeConvert((time_t) c->lastcmd,s);
			BUNins(b, &i, s, FALSE);
		}
	}
	if (!(b->batDirty&2)) b = BATsetaccess(b, BAT_READ);
	@:Pseudo(client,lastcommand,)@
	return MAL_SUCCEED;
}

str
CLTActions(int *ret)
{
	BAT *b = BATnew(TYPE_int, TYPE_int, 12);
	int i;

	if (b == 0)
		throw(MAL, "clients.getActions", MAL_MALLOC_FAIL);
	for (i = 0; i < MAL_MAXCLIENTS; i++) {
		Client c = mal_clients+i;
		if (c->mode >= CLAIMED && c->user != oid_nil) {
			BUNins(b, &i, &c->actions, FALSE);
		}
	}
	if (!(b->batDirty&2)) b = BATsetaccess(b, BAT_READ);
	@:Pseudo(client,actions,)@
	return MAL_SUCCEED;
}
str
CLTTime(int *ret)
{
	BAT *b = BATnew(TYPE_int, TYPE_lng, 12);
	int i;

	if (b == 0)
		throw(MAL, "clients.getTime", MAL_MALLOC_FAIL);
	for (i = 0; i < MAL_MAXCLIENTS; i++) {
		Client c = mal_clients+i;
		if (c->mode >= CLAIMED && c->user != oid_nil) {
			BUNins(b, &i, &c->totaltime, FALSE);
		}
	}
	if (!(b->batDirty&2)) b = BATsetaccess(b, BAT_READ);
	@:Pseudo(client,usec,)@
	return MAL_SUCCEED;
}

@-
Produce a list of clients currently logged in
@c
str
CLTusers(int *ret)
{
	BAT *b = BATnew(TYPE_int, TYPE_str, 12);
	int i;

	if (b == 0)
		throw(MAL, "clients.users", MAL_MALLOC_FAIL);
	for (i = 0; i < MAL_MAXCLIENTS; i++) {
		Client c = mal_clients+i;
		if (c->mode >= CLAIMED && c->user != oid_nil)
			b = BUNins(b, &i, local_itoa((int)c->user), FALSE);
	}
	if (!(b->batDirty&2)) b = BATsetaccess(b, BAT_READ);
	@:Pseudo(client,users,)@
	return MAL_SUCCEED;
}

str
CLTsetHistory(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	str* fname = (str *) getArgReference(stk,pci,1);
	(void) mb;

	if( cntxt->history){
#ifdef HAVE_LIBREADLINE
		write_history(cntxt->history);
#endif
		GDKfree(cntxt->history);
	}
	if( *fname == str_nil)
		cntxt->history = NULL;
	else {
		cntxt->history = GDKstrdup(*fname);
#ifdef HAVE_LIBREADLINE
		read_history(cntxt->history);
#endif
	}
	return MAL_SUCCEED;
}

str
CLTquit(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	int id;
	(void) mb;		/* fool compiler */
	
	if ( pci->argc==2 && cntxt->idx != 0)
		throw(MAL, "client.quit", INVCRED_ACCESS_DENIED,"");
	if ( pci->argc==2)
		id = *(int*) getArgReference(stk,pci,1);
	else id =cntxt->idx;

	if (id == 0 && cntxt->fdout != GDKout )
		throw(MAL, "client.quit", INVCRED_ACCESS_DENIED);
	if ( cntxt->idx == mal_clients[id].idx)
		mal_clients[id].mode = FINISHING;
	/* the console should be finished with an exception */
	if (id == 0)
		throw(MAL,"client.quit",SERVER_STOPPED);
	return MAL_SUCCEED;
}

str
CLTstop(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	int id=  *(int *) getArgReference(stk,pci,1);
	(void) mb;
	if ( cntxt->user == mal_clients[id].user || 
		mal_clients[0].user == cntxt->user){
		mal_clients[id].itrace = 'x';
	}
	/* this forces the designated client to stop at the next instruction */
    return MAL_SUCCEED;
}

str
CLTsuspend(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	int *id=  (int *) getArgReference(stk,pci,1);
	(void) cntxt;
	(void) mb;
    return MCsuspendClient(*id,0);
}
str
CLTwakeup(int *ret, int *id)
{
    (void) ret;     /* fool compiler */
    return MCawakeClient(*id);
}

@+ User administration
These commands (except changePassword, changeUsername and
checkPermission) can only be executed by the administrator.

@mal
command md5sum(pw:str):str
address CLTmd5sum
comment "Return hex string representation of the MD5 hash of the given string";
@c
str CLTmd5sum(str *ret, str *pw) {
	str tmp;
	int len = (int) strlen(*pw);
	
	rethrow("md5sum", tmp, AUTHMD5Sum(ret, pw, &len));
	return(MAL_SUCCEED);
}

@mal
command sha1sum(pw:str):str
address CLTsha1sum
comment "Return hex string representation of the SHA-1 hash of the given string";
@c
str CLTsha1sum(str *ret, str *pw) {
	str tmp;
	int len = (int) strlen(*pw);
	
	rethrow("sha1sum", tmp, AUTHSHA1Sum(ret, pw, &len));
	return(MAL_SUCCEED);
}

@mal
command ripemd160sum(pw:str):str
address CLTripemd160sum
comment "Return hex string representation of the RIPEMD160 hash of the given string";
@c
str CLTripemd160sum(str *ret, str *pw) {
	str tmp;
	int len = (int) strlen(*pw);
	
	rethrow("ripemd160sum", tmp, AUTHRIPEMD160Sum(ret, pw, &len));
	return(MAL_SUCCEED);
}

@mal
command sha2sum(pw:str, bits:int):str
address CLTsha2sum
comment "Return hex string representation of the SHA-2 hash with bits of the given string";
@c
str CLTsha2sum(str *ret, str *pw, int *bits) {
	str tmp;
	int len = (int) strlen(*pw);
	
	rethrow("sha2sum", tmp, AUTHSHA2Sum(ret, pw, &len, bits));
	return(MAL_SUCCEED);
}

@mal
command backendsum(pw:str):str
address CLTbackendsum
comment "Return hex string representation of the currently used hash of the given string";
@c
str CLTbackendsum(str *ret, str *pw) {
	str tmp;
	int len = (int) strlen(*pw);
	
	rethrow("sha2sum", tmp, AUTHBackendSum(ret, pw, &len));
	return(MAL_SUCCEED);
}

@mal
pattern addUser(nme:str, pw:str, scen:bat[:str,:any_1]):oid
address CLTaddUser
comment "Allow user with password access to the given scenarios";
@c
str CLTaddUser(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci) {
	oid *ret = (oid *)getArgReference(stk, pci, 0);
	str *usr = (str *)getArgReference(stk, pci, 1);
	str *pw = (str *)getArgReference(stk, pci, 2);
	bat *sc = (bat *)getArgReference(stk, pci, 3);
	str tmp;

	(void)mb;
	
	rethrow("addUser", tmp, AUTHaddUser(ret, &cntxt, usr, pw, sc));
	return(MAL_SUCCEED);
}

@mal
pattern removeUser(nme:str):void
address CLTremoveUser
comment "Remove the given user from the system";
@c
str CLTremoveUser(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci) {
	str tmp;
	str *usr;
	(void)mb;

	usr = (str *)getArgReference(stk, pci, 1);

	rethrow("removeUser", tmp, AUTHremoveUser(&cntxt, usr));
	return(MAL_SUCCEED);
}

@mal
pattern getUsername():str
address CLTgetUsername
comment "Return the username of the currently logged in user";
@c
str CLTgetUsername(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci) {
	str *ret = (str *)getArgReference(stk, pci, 0);
	str tmp;
	(void)mb;

	rethrow("getUsername", tmp, AUTHgetUsername(ret, &cntxt));
	return(MAL_SUCCEED);
}

@mal
pattern getPasswordHash(user:str):str
address CLTgetPasswordHash
comment "Return the password hash of the given user";
@c
str CLTgetPasswordHash(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci) {
	str *ret = (str *)getArgReference(stk, pci, 0);
	str *user = (str *)getArgReference(stk, pci, 1);
	str tmp;

	(void)mb;

	rethrow("getPasswordHash", tmp, AUTHgetPasswordHash(ret, &cntxt, user));
	return(MAL_SUCCEED);
}

@mal
pattern changeUsername(old:str, new:str):void
address CLTchangeUsername
comment "Change the username of the user into the new string";
@c
str CLTchangeUsername(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci) {
	str *old = (str *)getArgReference(stk, pci, 1);
	str *new = (str *)getArgReference(stk, pci, 2);
	str tmp;

	(void)mb;

	rethrow("changeUsername", tmp, AUTHchangeUsername(&cntxt, old, new));
	return(MAL_SUCCEED);
}

@mal
pattern changePassword(old:str, new:str):void
address CLTchangePassword
comment "Change the password for the current user";
@c
str CLTchangePassword(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci) {
	str *old = (str *)getArgReference(stk, pci, 1);
	str *new = (str *)getArgReference(stk, pci, 2);
	str tmp;

	(void)mb;

	rethrow("changePassword", tmp, AUTHchangePassword(&cntxt, old, new));
	return(MAL_SUCCEED);
}

@mal
pattern setPassword(user:str, pass:str):void
address CLTsetPassword
comment "Set the password for the given user";
@c
str CLTsetPassword(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci) {
	str *usr = (str *)getArgReference(stk, pci, 1);
	str *new = (str *)getArgReference(stk, pci, 2);
	str tmp;

	(void)mb;

	rethrow("setPassword", tmp, AUTHsetPassword(&cntxt, usr, new));
	return(MAL_SUCCEED);
}

@mal
pattern checkPermission(usr:str, pw:str, sc:str):void
address CLTcheckPermission
comment "Check permission for a user, requires hashed password (backendsum)";
@c
str CLTcheckPermission(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci) {
	str *usr = (str *)getArgReference(stk, pci, 1);
	str *pw = (str *)getArgReference(stk, pci, 2);
	str *sc = (str *)getArgReference(stk, pci, 3);
	str tmp;
	str ch = "";
	str algo = "SHA1";
	oid id;
	str pwd;
	int len = (int) strlen(*pw);

	(void)mb;

	rethrow("checkPermission", tmp,
			AUTHSHA1Sum(&pwd, pw, &len));
	rethrow("checkPermission", tmp,
			AUTHcheckCredentials(&id, &cntxt, usr, &pwd, &ch, &algo, sc));
	GDKfree(pwd);
	return(MAL_SUCCEED);
}

@mal
pattern addScenario(usr:str, sc:str):void
address CLTaddScenario
comment "add the given scenario to the allowed scenarios for the given user";
@c
str CLTaddScenario(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci) {
	str *usr = (str *)getArgReference(stk, pci, 1);
	str *sc = (str *)getArgReference(stk, pci, 2);
	str tmp;

	(void)mb;

	rethrow("addScenario", tmp, AUTHaddScenario(&cntxt, usr, sc));
	return(MAL_SUCCEED);
}

@mal
pattern removeScenario(usr:str, sc:str):void
address CLTremoveScenario
comment "remove the given scenario from the allowed scenarios for the given user";
@c
str CLTremoveScenario(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci) {
	str *usr = (str *)getArgReference(stk, pci, 1);
	str *sc = (str *)getArgReference(stk, pci, 2);
	str tmp;

	(void)mb;

	rethrow("removeScenario", tmp, AUTHremoveScenario(&cntxt, usr, sc));
	return(MAL_SUCCEED);
}

@mal
pattern getUsers(s:bat[:str,:any_1]):bat[:oid,:str]
address CLTgetUsers
comment "return a BAT with user id and name available in the system with access to the given scenario(s)";
@c
str CLTgetUsers(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci) {
	bat *ret = (bat *)getArgReference(stk, pci, 0);
	bat *scens = (bat *)getArgReference(stk, pci, 1);
	BAT *r = NULL;
	str tmp;

	(void)mb;

	rethrow("getUsers", tmp, AUTHgetUsers(&r, &cntxt, scens));
	BBPkeepref(*ret = r->batCacheid);
	return(MAL_SUCCEED);
}

str CLTshutdown(int *ret, bit *forced) {
	(void) ret;
	(void) forced;
	throw(MAL,"clients.shutdown", PROGRAM_NYI);
}
@}
