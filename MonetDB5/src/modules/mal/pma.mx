@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
@' Copyright August 2008-2009 MonetDB B.V.
@' All Rights Reserved.

@f pma
@a N.Tang and P.Boncz
@+ PMA Organized BAT
The database columns have high maintance cost for inserting/deleting items,
while keeping some specific columns sorted. Basically, to insert/delete an
item to a sorted column in size n will render O(n) items to move. With PMA,
however, normal insertion/deletion have only O(log^n) amortized item movement.
PMA leaves gaps between items, to ensure that to operate on a particular item,
only a few items around the particular item are required to move.

Different from traditional PMA, our PMA fnd function returns a range which
may contains some items with equivalent values. This design is to facilitate
the relational table sorting in multiple columns (i.e. attribute), e.g., to
sort a table of students on age first, and then on their names.

@mal
module pma;

command new(tpe:int, sze:int) :bat[:oid,:any_1]
address PMAnew
comment "create a new empty PMA-organized BAT (PMA for short)";

@= pma_mal
command ins(b:bat[:oid,:@1], pos:oid, val:@1) :oid
address PMAins_@1
comment "insert a value into a PMA at some position";

command bulkins(b:bat[:oid,:@1], pos:oid, bi:bat[:oid,:@1]) :oid
address PMAbulkins_@1
comment "insert a bat into a PMA at some position";

command del(b:bat[:oid,:@1], pos:oid) :void
address PMAdel_@1
comment "delete a value from a PMA BAT at some position";

command bulkdel(b:bat[:oid,:@1], lo:oid, hi:oid) :void
address PMAbulkdel_@1
comment "delete all values from a range lo to hi";

command fnd(b:bat[:oid, :@1], lo:oid, hi:oid, val:@1) (:oid,:oid)
address PMAfnd_@1
comment "look up the range where a value occurs in a PMA";

command testins(b:bat[:oid,:@1], num:int) :void
address PMAtestins_@1
comment "test the function of insertion"

command testdel(b:bat[:oid,:@1]) :void
address PMAtestdel_@1
comment "test the function of deletion"

@mal
@:pma_mal(bte)@
@:pma_mal(sht)@
@:pma_mal(int)@
@:pma_mal(lng)@
@:pma_mal(flt)@
@:pma_mal(dbl)@
@(
StM: disabled as the code clearly cannot handle type str (yet?)
@:pma_mal(str)@
@)

@+ PMA API
@h
#ifndef _PMA_H_
#define _PMA_H_

#ifdef WIN32
#ifndef LIBPMA
#define pma_export extern __declspec(dllimport)
#else
#define pma_export extern __declspec(dllexport)
#endif
#else
#define pma_export extern
#endif

#include <gdk.h>
#include <gdk_atoms.h>
pma_export str PMAnew(bat *res, int *tpe, int *sz);
@= pma_decl
pma_export str PMAins_@1(oid *pos_res, bat *b, oid *pos, @1 *val);
pma_export str PMAbulkins_@1(oid *pos_res, bat *b, oid *pos, bat *bi);
pma_export str PMAdel_@1(void *dummy, bat *b, oid *pos);
pma_export str PMAbulkdel_@1(void *dummy, bat *b, oid *lo, oid *hi);
pma_export str PMAfnd_@1(oid *lo_res, oid *hi_res, bat *b, oid *lo, oid *hi, @1 *val);
pma_export str PMAtestins_@1(void *dummy, bat *b, int *val);
pma_export str PMAtestdel_@1(void *dummy, bat *b);
@h
@:pma_decl(bte)@
@:pma_decl(sht)@
@:pma_decl(int)@
@:pma_decl(lng)@
@:pma_decl(flt)@
@:pma_decl(dbl)@
@(
StM: disabled as the code clearly cannot handle type str (yet?)
@:pma_decl(str)@
@)
#endif	/* _PMA_H_ */

@+ PMA implementation
@c
#include "mal_config.h"
#include "mal_exception.h"
#include <gdk_utils.h>
#include "pma.h"
#include <math.h>

#define Dmax 1
#define Dmin 0.1
#define TaoMin 0.5
#define RouMax 0.2

#define PMA_SHT 4
#define PMA_SEG 16

@= fillnill
{	@1 *cur = (@1 *) Tloc(b, BUNfirst(b));
	for (i = 0; i < cnt; i++) cur[i] = @2;
	break;
}

@c
pma_export str
PMAnew(bat *res, int *tpe, int *sz) {
	BAT *b;
	wrd cnt, i;
	if (*tpe < 0)
		return "PMAnew: illegal type";
	if (ATOMstorage(*tpe) == TYPE_void || ATOMstorage(*tpe) > TYPE_lng)
		return "PMAnew: type not supported (yet?)";
	for (cnt = PMA_SEG; cnt < *sz; cnt <<= 1);	/* figure out the size */
	b = BATnew(TYPE_void, *tpe, cnt);
	if (b) {
@(
StM: disabled as the code clearly cannot handle other than fixed-size linear types (yet?)
		var_t nil_off;
@)
		switch(ATOMstorage(*tpe)) {
		case TYPE_chr: @:fillnill(chr, chr_nil)@
		case TYPE_bte: @:fillnill(bte, bte_nil)@
		case TYPE_sht: @:fillnill(sht, sht_nil)@
		case TYPE_int: @:fillnill(int, int_nil)@
		case TYPE_lng: @:fillnill(lng, lng_nil)@
		case TYPE_flt: @:fillnill(flt, flt_nil)@
		case TYPE_dbl: @:fillnill(dbl, dbl_nil)@
		case TYPE_ptr: @:fillnill(ptr, ptr_nil)@
		default:	
			BBPunfix(b->batCacheid);
			return "PMAnew: type not supported (yet?)";
@(
StM: disabled as the code clearly cannot handle other than fixed-size linear types (yet?)
			       BUNins(b, NULL, (ptr)str_nil, FALSE);
                	       nil_off = *(var_t*) Tloc(b, BUNfirst(b));
		               @:fillnill(wrd, nil_off)@
@)
		}
		BATsetcount(b, cnt);
		b->tsorted = 0;
		BATkey(BATmirror(b), FALSE);
		BBPkeepref(*res = b->batCacheid);
		return MAL_SUCCEED;
	}
	return "PMAnew: allocation failed";
}

@= pma_impl
pma_export str
PMAins_@1(oid *pos_res, bat *bid, oid *pos, @1 *val) {
	bit fgw, fg;
	oid i, j, k, lt, rt, ht, sz , psz, cnt, lv, wsz, snum, scl, scr, wbeg, wend, mpos;
	dbl dens, dent, step, dstep, slen;
	BAT *b;
	@1 *base;

	b =  BATdescriptor(*bid);
	if (b == NULL) return "PMAins: illegal bat parameter";
	base = (@1*) Tloc(b, BUNfirst(b));
	sz = PMA_SEG;
	psz = BATcount(b);
	for (ht = 0; psz > sz; sz <<= 1) ht++;
	if (psz != sz) return "PMAins: illegal bat size";
	if (ht == 0) {
		dent = TaoMin;
		step = 0;
	} else {
		dent = Dmax;
		step = (Dmax - TaoMin) / ht;
	}
	fgw = FALSE;
	lv = cnt = 0;
	mpos = *pos;
	if (*pos == psz) mpos--;	/* new value is largest, and the last bat cell is not empty */
	snum = mpos >> PMA_SHT;	/* segment number of $pos */
	while (!fgw) {	/* search a window to insert the new value, in a bottom-up fashion */
		wsz = PMA_SEG << lv;
		if (lv == 0) {
			scl = snum << PMA_SHT;
			scr = scl + wsz;
		} else {
			wbeg = (snum >> lv) << lv << PMA_SHT;
			scl = wbeg;
			scr = wbeg + (wsz >> 1);
			if (mpos < wbeg + (wsz >> 1)) {
				scl += (wsz >> 1);
				scr += (wsz >> 1);
			}
		}
		for (i = scl; i < scr; i++) {
			if (base[i] != @1_nil) cnt++;
		}
		dens = (dbl)(cnt + 1) / wsz;
		lv++;
		if (dens <= dent) fgw = TRUE;	/* find an appropriate window */
		else if (lv > ht) break;		/* current BAT has no space */
		else              dent -= step;	/* scan the parent window */
	}
	lv--;
	fg = FALSE;
	if (fgw){
		if (*pos == psz) {
			wbeg = (snum >> lv) << lv << PMA_SHT;
			for (i = j = wbeg; i < *pos; i++) {
				if (base[i] == @1_nil) {
					fg = TRUE;
				} else if (fg || i > j + 1) {
					j = (j + i) >> 1;
					base[j] = base[i];
					base[i] = (@1)@1_nil;
					fg = FALSE;
				} else {
					j = i;
				}
			}
			*pos_res = (j + *pos) >> 1;
		} else {
			if (lv == 0) {	/* the botttom segment [scl, scr) has space */
				for (i = mpos; i >= scl; i--) {
					if (base[i]==@1_nil) fg = TRUE;
					else if (fg)         break;	/* not a hole and have space between i to mpos */
					if (i == scl)        break;
				}
				if (i != scl)                     lt = i;		/* find a hole */
				else if (base[scl]==@1_nil || fg) lt = scl;		/* all left parts are holes, with consecutive elements */
				else                              lt = mpos;	/* no space on the left */
				for (i = mpos, fg = FALSE; i < scr; i++) {
					if (base[i] == @1_nil) fg = TRUE;
					else if (fg)           break;
				}
				if (i < scr)                    rt = i;
				else if (base[scr-1] == @1_nil) rt = scr-1;	/* consecutive elements, with all right parts are holes */
				else                            rt = mpos;	/* no space on the right */
				if (lt == rt) {
					assert(base[lt] == @1_nil);	/* since there must have space in this segment */
				} else {
					if (base[lt] != @1_nil && lt != mpos) lt++;
					for (i = lt; i < mpos; i++) {
						if (base[i] != @1_nil) {
							j = (i + lt) >> 1;
							base[j] = base[i];
							base[i] = (@1)@1_nil;
							lt = j;
						}
					}
					for (i = rt - 1; i >= mpos; i--) {
						if (base[i] != @1_nil) {
							j = (i + rt) >> 1;
							if (base[j] != @1_nil) j++;
							base[j] = base[i];
							base[i] = (@1)@1_nil;
							rt = j;
						}
						if (i == mpos) break;
					}
				}
				*pos_res = (lt + rt) >> 1;
				if (base[*pos_res] != @1_nil) (*pos_res)++;
			} else {	/* rebalance */
				/* An implicit rebalance consists of two scans, one to the left and one the right
				 * of the insertion point until we find a region of the appropriate density
				 */
				wbeg = (snum >> lv) << lv << PMA_SHT;
				wend = wbeg + wsz - 1;
				if (mpos >= wbeg + (wsz>>1)) {	/* rebalance on the left */
					for (i = j = wbeg; i < mpos; i++) {
						if (base[i] == @1_nil) {
							fg = TRUE;
						} else if (fg || i > j + 1) {
							j = (j + i) >> 1;
							base[j] = base[i];
							base[i] = (@1)@1_nil;
							fg = FALSE;
						} else {
							j = i;
						}
					}
				} else {	/* rebalance on the right */
					for (i = j = wend; i >= mpos; i--) {
						if (base[i] == @1_nil) {
							fg = TRUE;
						} else if (fg || j > i + 1) {
							j = (j + i) >> 1;
							if (j == i) j++;
							base[j] = base[i];
							base[i] = (@1)@1_nil;
							fg = FALSE;
						} else {
							j = i;
						}
						if (i == mpos) break;
					}
				}
				*pos_res = (j + mpos) >> 1;
			}
		}
	} else {	/* extend to a double sized new PMA-managed BAT */
		psz <<= 1;
		if ((b = BATextend(b, (BUN)psz)) == NULL) return "PMAins: BATextend fails";
		BATsetcount(b, psz);
		b->tsorted = 0;
		BATkey(BATmirror(b), FALSE);
		BBPkeepref(*bid = b->batCacheid);
		base = (@1*) Tloc(b, BUNfirst(b));
		dstep = (dbl)psz / (cnt + 1);
		slen = ceil(dstep);
		for (k = psz - 1; k >= (psz>>1); k--) base[k] = (@1)@1_nil;
		if (cnt * slen + 1 > psz) slen--;
		j = psz - 1;
		i = (psz>>1) - 1;
		if (*pos == psz>>1) {
			*pos_res = j;
			for (k = 1; k < slen; k++) base[j-k] = (@1)@1_nil;
			j -= slen;
			for (; (int)i >= 0; i--) {
				if (base[i] != @1_nil) {
					base[j] = base[i];
					base[i] = (@1)@1_nil;
					for (k = 1; k < slen; k++) base[j-k] = (@1)@1_nil;
					j -= slen;
				}
				if (i == 0 || j <= slen || j < i) break;
			}
		} else {
			for (; i >= mpos; i--) {
				if (j <= i) break;
				if (base[i] != @1_nil) {
					base[j] = base[i];
					base[i] = (@1)@1_nil;
					for (k = 1; k < slen; k++) base[j-k] = (@1)@1_nil;
					j -= slen;
				}
				if (i == mpos) break;
			}
			*pos_res = j;
			for (k = 1; k < slen; k++) 	base[j-k] = (@1)@1_nil;
			j -= slen;
			assert(j + slen > i);
			for (; (int)i >= 0; i--) {
				if (j < i + slen) break;
				if (base[i] != @1_nil) {
					base[j] = base[i];
					base[i] = (@1)@1_nil;
					for (k = 1; k < slen; k++) base[j-k] = (@1)@1_nil;
					j -= slen;
				}
				if (i == 0) break;
			}
		}
	}
	/* check only, for debugging */
	/*for (i = *pos_res; (int)i >= 0; i--) {
		if (base[i] == @1_nil) continue;
		else if (base[i] > *val) { printf("PMAins before: %d\n", (int)i); assert(0); }
		else if (base[i] < *val) break;
		if (i == 0) break;
	}
	for (i++; i < psz; i++) {
		if (base[i] == @1_nil) continue;
		else if (base[i] < *val) { printf("PMAfnd after: %d\n", (int)i); assert(0); }
		else if (base[i] > *val) break;
	}*/
	/* ~check only, for debugging */
	assert(base[*pos_res] == @1_nil);
	base[*pos_res] = *val;
	return MAL_SUCCEED;
}

pma_export str
PMAdel_@1(void *dummy, bat *bid, oid *pos) {
	bit fg, fgw;
	oid i, j, ht, sz, wsz, psz, wbeg, lv, snum, scl, scr, cnt;
	dbl dens, dent, step, dstep;
	int tpe, nsz, slen;
	bat ret;
	BAT *b, *bn;
	@1 *base, *basen;
	(void)dummy;
	b = BATdescriptor(*bid);
	if (b == NULL) return "PMAdel: illegal bat parameter";
	psz = BATcount(b);
	sz = PMA_SEG;
	for(ht = 0; psz > sz; sz <<= 1) ht++;
	if (psz != sz) return "PMAdel: illegal bat size";
	base = (@1 *) Tloc(b, BUNfirst(b));
	if (base[*pos] == @1_nil) return MAL_SUCCEED;
	base[*pos] = (@1)@1_nil;
	dent = Dmin;
	(ht == 0) ? (step = 0) : (step = (RouMax - Dmin) / ht);
	fgw = FALSE;
	lv = cnt = 0;
	snum = *pos >> PMA_SHT;
	while (!fgw && lv <= ht) {
		wsz = PMA_SEG << lv;
		if (lv == 0) {
			wbeg = 0;
			scl = snum << PMA_SHT;
			scr = scl + wsz;
		} else {
			scl = wbeg = (snum >> lv) << lv << PMA_SHT;
			scr = wbeg + (wsz >> 1);
			if (*pos < wbeg + (wsz >> 1)) {
				scl += (wsz >> 1);
				scr += (wsz >> 1);
			}
		}
		for (i = scl; i < scr; i++) {
			if (base[i] != @1_nil) cnt++;
		}
		dens = (dbl)cnt / wsz;
		lv++;
		(dens > dent) ? (fgw = TRUE) : (dent += step);
	}
	if (!fgw) {	/* the whole PMA is required to be rebalanced */
		if (cnt == 0) {	/* an empty PMA */
			BATdelete(b);
			bid = NULL;
		} else if (psz != PMA_SEG){	/* shrink this PMA into half size */
			tpe = TYPE_@1;
			psz >>= 1;
			nsz = psz;
			PMAnew(&ret, &tpe, &nsz);
			*bid = ret;
			bn = BATdescriptor(ret);
			basen = (@1*)Tloc(bn, BUNfirst(bn));
			dstep = (dbl)psz / cnt;
			slen = ceil(dstep);
			if ((cnt - 1) * slen + 1 > psz) slen--;
			for (i = j = 0; i < sz; i++) {
				if (base[i] != @1_nil) {
					basen[j] = base[i];
					j += slen;
				}
			}
			BATdelete(b);
		} /* else: only 1 segment, simply delete the element */
	} else {	/* a window is required to be rebalanced */
		fg = FALSE;
		if (*pos >= wbeg + (wsz>>1)) {	/* rebalance from the beginning of the window */
			for (i = j = wbeg; i < wbeg + wsz; i++) {
				if (base[i] == @1_nil) {
					fg = TRUE;
				} else if (fg) {
					j = (j + i) >> 1;
					base[j] = base[i];
					base[i] = (@1)@1_nil;
					fg = FALSE;
				} else {
					j = i;
				}
			}
		} else {	/* rebalance from the end of the window */
			for (i = j = wbeg + wsz - 1; i >= wbeg; i--) {
				if (base[i] == @1_nil) {
					fg = TRUE;
				} else if (fg) {
					j = (j + i) >> 1;
					base[j] = base[i];
					base[i] = (@1)@1_nil;
					fg = FALSE;
				} else {
					j = i;
				}
				if (i == 0) break;
			}
		}
	}
	return MAL_SUCCEED;
}

pma_export str
PMAbulkdel_@1(void *dummy, bat *bid, oid *lo, oid *hi) {
	oid i, j, k, ht, lv, snum, wbeg, wsz, sz, psz, cnt, icnt, scl, scr;
	bit fg, fgw;
	dbl dens, dent, step, dstep;
	int tpe, nsz, slen;
	bat ret;
	BAT *b, *bn;
	@1 *base, *basen;
	b = BATdescriptor(*bid);
	psz = BATcount(b);
	if (b == NULL) return "PMAdel: illegal bat parameter";
	if (*lo > *hi || *hi > psz) return MAL_SUCCEED;
	if (*lo == *hi) return PMAdel_@1(dummy, bid, hi);
	sz = PMA_SEG;
	for(ht = 0; psz > sz; sz <<= 1) ht++;
	if (psz != sz) return "PMAdel: illegal bat size";
	(ht == 0) ? (step = 0) : (step = (RouMax - Dmin) / ht);
	base = (@1 *) Tloc(b, BUNfirst(b));
	icnt = 0;
	for (i = *lo; i <= *hi; i++) {
		if (base[i] != @1_nil) {
			base[i] = (@1)@1_nil;
			icnt++;
		}
	}
	if (icnt == 0) return MAL_SUCCEED;
	snum = *lo >> PMA_SHT;
	lv = 0;
	dent = Dmin;
	while (TRUE) {
		wsz = PMA_SEG << lv;
		wbeg = (snum >> lv) << lv << PMA_SHT;
		if (wbeg + wsz > *hi) break;
		lv++;
		dent += step;
	}
	cnt = 0;
	for (i = wbeg; i < *lo; i++) {
		if (base[i] != @1_nil) cnt++;
	}
	j = wbeg + wsz;
	for (i = *hi + 1; i < j; i++) {
		if (base[i] != @1_nil) cnt++;
	}
	dens = (dbl)cnt / wsz;
	fgw = (dens > dent ? TRUE : FALSE);
	lv++;
	while (!fgw && lv <= ht) {
		wsz = PMA_SEG << lv;
		scl = wbeg = (snum >> lv) << lv << PMA_SHT;
		scr = wbeg + (wsz >> 1);
		if (*lo < wbeg + (wsz >> 1)) {
			scl += wsz >> 1;
			scr += wsz >> 1;
		}
		for (i = scl; i < scr; i++) {
			if (base[i] != @1_nil) cnt++;
		}
		dens = (dbl)cnt / wsz;
		lv++;
		(dens > dent) ? (fgw = TRUE) : (dent += step);
	}
	lv--;
	if (!fgw) {	// the whole PMA is required to be rebalanced
		if (cnt == 0) {	// an empty PMA
			BATdelete(b);
			bid = NULL;
		} else if (psz != PMA_SEG){	// shrink this PMA into half size
			tpe = TYPE_@1;
			psz >>= 1;
			nsz = psz;
			PMAnew(&ret, &tpe, &nsz);
			*bid = ret;
			bn = BATdescriptor(ret);
			basen = (@1*)Tloc(bn, BUNfirst(bn));
			dstep = (dbl)psz / cnt;
			slen = ceil(dstep);
			if ((cnt - 1) * slen + 1 > psz) slen--;
			for (i = j = 0; i < sz; i++) {
				if (base[i] != @1_nil) {
					basen[j] = base[i];
					j += slen;
				}
			}
			BATdelete(b);
		} // else: only 1 segment, simply delete the element
	} else {	// a window is required to be rebalanced
		fg = FALSE;
		if (*lo >= wbeg + (wsz >> 1)) {	// rebalance from the beginning of the window
			k = wbeg + wsz;
			for (i = j = wbeg; i < k; i++) {
				if (base[i] == @1_nil) {
					fg = TRUE;
				} else if (fg) {
					j = (j + i) >> 1;
					base[j] = base[i];
					base[i] = (@1)@1_nil;
					fg = FALSE;
				} else {
					j = i;
				}
			}
		} else {	// rebalance from the end of the window
			for (i = j = wbeg + wsz - 1; i >= wbeg; i--) {
				if (base[i] == @1_nil) {
					fg = TRUE;
				} else if (fg) {
					j = (j + i) >> 1;
					base[j] = base[i];
					base[i] = (@1)@1_nil;
					fg = FALSE;
				} else {
					j = i;
				}
				if (i == 0) break;
			}
		}
	}
	return MAL_SUCCEED;
}

pma_export str
PMAfnd_@1(oid *lo_res, oid *hi_res, bat *bid, oid *lo, oid *hi, @1 *val) {
	BAT* b = BATdescriptor(*bid);
	oid i, md, h, l;
	@1 *base;
	if (b == NULL) return "PMAfnd: illegal bat parameter";
	if (*lo > *hi) return "PMAfnd: illegal search parameter (low > high)";
	base = (@1*) Tloc(b, BUNfirst(b));
	if (*lo == *hi) md = *lo;
	h = *hi;
	l = *lo;
	while (l <= h) {
		md = l + ((h - l) >> 1);
		if (md == l) {
			if (l < h && (base[l] == @1_nil || base[l] <= *val) ) md = h;
			/* if (l<h && (base[l]==@1_nil || base[l]<*val) && (base[h]==@1_nil || base[h]<=*val)) md = h;*/
			break;
		}
		if (base[md] == @1_nil) {
			for (i = md - 1; i >= l; i--) {
				if (base[i] != @1_nil || i == l) break;
			}
			if (base[i] != @1_nil) {
				if (base[i] == *val) {
					md = i;
					break;
				} else if (base[i] > *val) {
					h = i;
					if (i > l && (base[i-1] == @1_nil || base[i-1] > *val)) h--;
				} else {
					l = i;
					if (i < h) l++;
				}
				continue;
			}
			/* now, all elements from l to md are empty */
			for (i = md; i <= h; i++) {
				if (base[i] != @1_nil || i == h) break;
			}
			if (base[i] != @1_nil) {
				if (base[i] == *val) {
					md = i;
					break;
				} else if (base[i] > *val) {
					h = i;
					if (i > l && (base[i-1] == @1_nil || base[i-1] > *val)) h--;
				} else {
					l = i;
					if (l < h) l++;
				}
				continue;
			} else {	/* all elements from md to h are empty */
				md = l;
				break;
			}
		} else {
			if (base[md] < *val) {
				l = md + 1;
			} else if (base[md] > *val) {
				h = md;
				if (base[h-1] == @1_nil || base[h-1] > *val) h--;
			} else {
				break;
			}
		}
	}
	if (base[md] == @1_nil) {
		*lo_res = *hi_res = md;
	} else if (base[md] != *val) {
		*lo_res = *hi_res = md;
		if (base[md] != @1_nil && base[md] <= *val) *lo_res = *hi_res = md + 1;
	} else {	/* scan the adjacent elements of md */
		*lo_res = *hi_res = md;
		for (i = md; i >= l; i--) {
			if (base[i] == @1_nil)    continue;
			else if (base[i] == *val) *lo_res = i;
			else if (base[i] < *val)  break;
			else                      return "PMAfnd: the PMA should be ordered";
			if (i == l) break;
		}
		for (i = md + 1; i <= h; i++) {
			if (base[i] == @1_nil)    continue;
			else if (base[i] == *val) *hi_res = i;
			else if (base[i] > *val)  break;
			else                      return "PMAfnd: the PMA should be ordered";
		}
	}
	return MAL_SUCCEED;
}

pma_export str
PMAbulkins_@1(oid *pos_res, bat *bid, oid *pos, bat *ibid) {
	bit fgw, fg;
	int tpe, size;
	oid i, j, k, ht, sz, isz, psz, cnt, icnt, lv, wsz, snum, scl, scr, wbeg, mpos, cur;
	dbl dens, dent, step, dstep, slen;
	bat ret;
	BAT *b, *bi, *bn;
	@1 *base, *basei, *basen;
	b =  BATdescriptor(*bid);
	bi =  BATdescriptor(*ibid);
	if (b == NULL || bi == NULL) return "PMAins: illegal bat parameter";
	base = (@1*) Tloc(b, BUNfirst(b));
	basei = (@1*) Tloc(bi, BUNfirst(bi));
	isz = BATcount(bi);
	icnt = 0;
	for (i = 0; i < isz; i++) {
		if (basei[i] != @1_nil) icnt++;	/* figure out #-elements to be inserted */
	}
	if (icnt == 0) return MAL_SUCCEED;
	sz = PMA_SEG;
	psz = BATcount(b);
	for (ht = 0; psz > sz; sz <<= 1) ht++;
	if (psz != sz) return "PMAins: illegal bat size";
	if (ht == 0) {
		dent = TaoMin;
		step = 0;
	} else {
		dent = Dmax;
		step = (Dmax - TaoMin) / ht;
	}
	fgw = FALSE;
	lv = cnt = 0;
	mpos = *pos;
	if (*pos == psz) mpos--;	/* new value is largest, and the last bat cell is not empty */
	snum = mpos >> PMA_SHT;	/* segment number of $pos */
	while (!fgw) {	/* search a window to insert the new value, in a bottom-up fashion */
		wsz = PMA_SEG << lv;
		if (lv == 0) {
			scl = snum << PMA_SHT;
			scr = scl + wsz;
		} else {
			wbeg = (snum >> lv) << lv << PMA_SHT;
			scl = wbeg;
			scr = wbeg + (wsz >> 1);
			if (mpos < wbeg + (wsz >> 1)) {
				scl += (wsz >> 1);
				scr += (wsz >> 1);
			}
		}
		for (i = scl; i < scr; i++) {
			if (base[i] != @1_nil) cnt++;
		}
		dens = (dbl)(cnt + icnt) / wsz;
		lv++;
		if (dens <= dent) fgw = TRUE;	/* find an appropriate window */
		else if (lv > ht) break;		/* current BAT has no space */
		else              dent -= step;	/* scan the parent window */
	}
	lv--;
	if (fgw){
		wbeg = (snum >> lv) << lv << PMA_SHT;
		fg = FALSE;
		dstep = (dbl)wsz / (cnt + icnt);
		slen = ceil(dstep);
		if ((cnt + icnt) * slen > wsz) slen--;
		for (i = cur = wbeg; i < *pos; i++) {
			if (base[i] == @1_nil) {
				if (!fg) {	/* the first hole */
					fg = TRUE;
					cur = i;
				}
			} else {
				if (fg && (i - cur >= slen)) {
					base[cur] = base[i];
					base[i] = (@1)@1_nil;
					cur += slen;
				} else {
					cur = i;
					fg = FALSE;
				}
			}
		}
		if (base[cur] != @1_nil) k = cur + slen;
		else k = cur;
		fg = FALSE;
		for (i = wbeg + wsz - 1; i >= *pos; i--) {
			if (base[i] == @1_nil) {
				if (!fg) {	/* the first hole */
					fg = TRUE;
					cur = i;
				}
			} else {
				if (fg && (cur - i >= slen)) {
					base[cur] = base[i];
					base[i] = (@1)@1_nil;
					cur -= slen;
				} else {
					cur = i;
					fg = FALSE;
				}
			}
			if (i == *pos) break;
		}
		*pos_res = k;
		for (i = 0; i < isz; i++) {
			if (basei[i] != @1_nil) {
				assert(base[k] == @1_nil);
				base[k] = basei[i];
				k += slen;
			}
		}
	} else {	/* creat a bat large enough to store cnt + icnt */
		size = BATcount(b);
		while (TaoMin * size < cnt + icnt) size <<= 1;
		dstep = (dbl)size / (cnt + icnt);
		slen = ceil(dstep);
		if ((cnt + icnt) * slen > size) slen--;
		tpe = TYPE_@1;
		PMAnew(&ret, &tpe, &size);
		bn =  BATdescriptor(ret);
		*bid = ret;
		basen = (@1*) Tloc(bn, BUNfirst(bn));
		sz = BATcount(b);
		isz = BATcount(bi);
		for (i = j = 0; i < *pos; i++) {
			if (base[i] != @1_nil) {
				basen[j] = base[i];
				j += slen;
			}
		}
		*pos_res = j;
		for (k = 0; k < isz; k++) {
			if (basei[k] != @1_nil) {
				basen[j] = basei[k];
				j += slen;
			}
		}
		for (; i < sz; i++) {
			if (base[i] != @1_nil) {
				basen[j] = base[i];
				j += slen;
			}
		}
		BATdelete(b);
	}
	BATdelete(bi);
	return MAL_SUCCEED;
}

pma_export str
PMAtestins_@1(void *dummy, bat *bid, int *num) {
	BAT *b;
	oid lo, hi, lo_res, hi_res, pos_res;
	int val, i;
	(void)dummy;
	b = BATdescriptor(*bid);
	if (b == NULL) return "PMAfnd: illegal bat parameter";
	for (i = 0; i < *num; i++) {
		lo = 0;
		hi = BATcount(b) - 1;
		val = rand();
		printf("loop %d: %d\n", i, val);
		PMAfnd_@1(&lo_res, &hi_res, bid, &lo, &hi, (@1*)&val);
		PMAins_@1(&pos_res, bid, &hi_res, (@1*)&val);
	}
	return MAL_SUCCEED;
}

pma_export str
PMAtestdel_@1(void *dummy, bat *bid) {
	oid sz, pos;
	BAT *b;
	while (1) {
		b = BATdescriptor(*bid);
		if (b == NULL) return "PMAfnd: illegal bat parameter";
		sz = BATcount(b);
		if (sz == PMA_SEG) break;
		pos = rand() % sz;
		PMAdel_@1(dummy, bid, &pos);
	}
	return MAL_SUCCEED;
}
@c
@:pma_impl(bte)@
@:pma_impl(sht)@
@:pma_impl(int)@
@:pma_impl(lng)@
@:pma_impl(flt)@
@:pma_impl(dbl)@
@(
StM: disabled as the code clearly cannot handle type str (yet?)
@:pma_impl(str)@
@)
