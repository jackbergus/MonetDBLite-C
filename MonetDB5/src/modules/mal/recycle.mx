@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2008 CWI.
@' All Rights Reserved.

@a M. Ivanova, M. Kersten
@f recycle
@- The Recycler
Just the interface to the recycler.
@{
@-
The Recycler should be a variation of the interpreter
which inspects the variable table for alternative results.
@mal
module recycle;

pattern start():void
address RECYCLEstart
comment "Initialize recycler for the current block";

pattern stop():void
address RECYCLEstop
comment "Cleans recycler bookkeeping";

command dump():void
address RECYCLEdump
comment "Dump summary of recycle table for potential re-use benefits";

pattern setRetainPolicy(p:int...):void
address RECYCLEsetRetain
comment "Set recycler retainment policy:
1- nothing to be done
2- requires a minmal cut off time argument
   a negative start triggers adaptive learning 
3- size cost model 
4- volumetric cost model (time x size) ";

pattern setReusePolicy(p:int...):void
address RECYCLEsetReuse
comment "Set recycler reuse policy";

pattern setCachePolicy(p:int...):void
address RECYCLEsetCache
comment "Set recycler cache policy:
1- do nothing
2- LRU scheme with additional cache limit set.";

command shutdown():void
address RECYCLEshutdownWrap
comment "Clear the recycle cache";
@h
#ifndef _RECYCLE_
#define _RECYCLE_

#include "mal.h"
#include "mal_instruction.h"

#ifdef WIN32
#ifndef LIBRECYCLE
#define recycle_export extern __declspec(dllimport)
#else
#define recycle_export extern __declspec(dllexport)
#endif
#else
#define recycle_export extern
#endif

recycle_export str RECYCLEdump(int *ret);
recycle_export str RECYCLEstart(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
recycle_export str RECYCLEstop(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
recycle_export str RECYCLEsetRetain(MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
recycle_export str RECYCLEsetReuse(MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
recycle_export str RECYCLEsetCache(MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
recycle_export str RECYCLEshutdownWrap(int *ret);

#endif
@-
@c
#include "mal_config.h"
#include "mal_interpreter.h"
#include "mal_function.h"
#include "mal_recycle.h"
#include "recycle.h"

@-
The recycler is started when the first function is called for its support.
Upon exit of the last function, the content of the recycle cache is destroyed.
@c
str
RECYCLEstart(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{

	(void) pci;
	(void) stk;

	if( recycleVersion == 0){	
		MT_lock_init(&recycleLock,"recycle");
		recycleVersion =1 ;
	}
	if( mb->version )
		/* upgrade to a new version by dropping old info */
		RECYCLEversion(mb);
	else{
		mal_set_lock(recycleLock,"recycle");
		mb->version= recycleVersion;
		recycleClaim++;
		mal_unset_lock(recycleLock,"recycle");
	}
#ifdef _DEBUG_RECYCLE_
	stream_printf(GDKout,"RECYCLEstart version %d\n",recycleVersion);
#endif
	return MAL_SUCCEED;
}


str
RECYCLEstop(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	(void) mb;
	(void) stk;
	(void) pci;
	if( recycleBlk == 0)
		return MAL_SUCCEED;
	mal_set_lock(recycleLock,"recycle");
	recycleBlk->version = 0;
	recycleClaim--;
	mal_unset_lock(recycleLock,"recycle");
	return MAL_SUCCEED;
}


str
RECYCLEdump(int *ret)
{
	int i;

	(void) ret;
	stream_printf(GDKout,"#Recycler  catalog\n");
	stream_printf(GDKout,"#retain= %d time =%d sze= %d alpha= %4.3f\n",
		retainPolicy, recycleTime, recycleVolume, recycleAlpha);
	stream_printf(GDKout,"#reuse= %d\n", reusePolicy);
	stream_printf(GDKout,"#rcache= %d\n", recycleCacheLimit);

	/* and dump the statistics */
	if (recycleBlk)
	for(i=0; i< recycleBlk->stop; i++){
		stream_printf(GDKout,"#%4d lru= %d cnt= %3d ticks=%4d  vol= %4d %s\n", i,
			recycleBlk->profiler[i].clk,
			recycleBlk->profiler[i].counter,
			recycleBlk->profiler[i].ticks,
			recycleBlk->profiler[i].ibytes+recycleBlk->profiler[i].obytes,
			instruction2str(recycleBlk,getInstrPtr(recycleBlk,i),TRUE));
	}
	return MAL_SUCCEED;
}

str
RECYCLEsetRetain(MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	(void) mb;
	retainPolicy = * (int*) getArgReference(stk, p,1);
	if( p->argc >= 2)
	switch(retainPolicy){
	case RETAIN_VOL:
		if( p->argc >= 3)
			recycleVolume = * (int*) getArgReference(stk, p,3);
	case RETAIN_TIME:
	case RETAIN_ADAPT:
		recycleTime = * (int*) getArgReference(stk, p,2);
		break;
	case RETAIN_SIZE:
		recycleVolume = * (int*) getArgReference(stk, p,2);
	}
	if(p->argc >3)
		recycleAlpha = 1.0/  *(int*) getArgReference(stk, p,4);
	(void)retainPolicy;
	return MAL_SUCCEED;
}

str
RECYCLEsetReuse(MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	(void) mb;
	reusePolicy = * (int*) getArgReference(stk, p,1);
	(void)reusePolicy;
	return MAL_SUCCEED;
}

str
RECYCLEsetCache(MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	(void) mb;
	rcachePolicy = * (int*) getArgReference(stk, p,1);
	if( rcachePolicy && p->argc >= 2)
		recycleCacheLimit = * (int*) getArgReference(stk, p,2);
	(void)recycleCacheLimit;
	return MAL_SUCCEED;
}
@-
At the end of the session we have to cleanup the recycle cache.
@c
str
RECYCLEshutdownWrap(int *ret){
	(void) ret;
	RECYCLEshutdown();
	return MAL_SUCCEED;
}
@}
