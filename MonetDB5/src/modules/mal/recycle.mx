@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2008 CWI.
@' All Rights Reserved.

@a M. Ivanova, M. Kersten
@f recycle
@- The Recycler
Just the interface to the recycler.
@{
@-
The Recycler should be a variation of the interpreter
which inspects the variable table for alternative results.
@mal
module recycle;

pattern start():void
address RECYCLEstart
comment "Initialize recycler for the current block";

pattern stop():void
address RECYCLEstop
comment "Cleans recycler bookkeeping";

pattern dump():void
address RECYCLEdump
comment "Dump summary of recycle table for potential re-use benefits";

pattern setRetainPolicy(p:int...):void
address RECYCLEsetRetain
comment "Set recycler retainment policy:
0- RETAIN_NONE: baseline, keeps stat, no retain, no reuse
1- RETAIN_ALL: infinite case, retain all
2- RETAIN_TIME: time-based semantics, retain if beneficial
3- RETAIN_SIZE: size cost model
4- RETAIN_VOL: volumetric cost model (time x size )
5- RETAIN_ADAP: adaptive temporal";

command getRetainPolicy():int
address RECYCLEgetRetain;

pattern setReusePolicy(p:int...):void
address RECYCLEsetReuse
comment "Set recycler reuse policy";

command getReusePolicy():int
address RECYCLEgetReuse;

pattern setCachePolicy(p:int...):void
address RECYCLEsetCache
comment "Set recycler cache policy:
0- RCACHE_ALL: baseline, do nothing
1- RCACHE_LRU: throw LRU by setting the limit
2- RCACHE_CREDIT: credit-based LRU scheme
3- RCACHE_MEMLRU: reduce the storage overhead
4- RCACHE_MEMCRD: reduce the storage overhead 
optional arguments are [ instruction-, [memory -]] limit";

command getCachePolicy():int
address RECYCLEgetCache;

pattern reset():void
address RECYCLEresetCMD
comment "Reset off all recycled variables";

command shutdown():void
address RECYCLEshutdownWrap
comment "Clear the recycle cache";

command restore():void
address RECYCLErestore
comment "Restore the recycle cache to the start of the call";


command monitor(f:int):void
address RECYCLEmonitor
comment "start/stop the monitoring (printing) of the recycler info (storage size used and number of statements retained)";

pattern prelude():void
address RECYCLEprelude
comment "Called at the start of a recycle controlled function";

pattern epilogue():void
address RECYCLEepilogue
comment "Called at the start of a recycle controlled function";
@h
#ifndef _RECYCLE_
#define _RECYCLE_

#include "mal.h"
#include "mal_instruction.h"

#ifdef WIN32
#ifndef LIBRECYCLE
#define recycle_export extern __declspec(dllimport)
#else
#define recycle_export extern __declspec(dllexport)
#endif
#else
#define recycle_export extern
#endif

recycle_export str RECYCLEdump(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
recycle_export str RECYCLEstart(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
recycle_export str RECYCLEstop(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
recycle_export str RECYCLEsetRetain(MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
recycle_export str RECYCLEsetReuse(MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
recycle_export str RECYCLEresetCMD(MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
recycle_export str RECYCLEsetCache(MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
recycle_export str RECYCLEgetRetain(int *p);
recycle_export str RECYCLEgetReuse(int *p);
recycle_export str RECYCLEgetCache(int *p);
recycle_export str RECYCLEshutdownWrap(int *ret);
recycle_export str RECYCLEmonitor(int *d, int *p);
recycle_export str RECYCLEprelude(MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
recycle_export str RECYCLEepilogue(MalBlkPtr mb, MalStkPtr stk, InstrPtr p);

#endif
@-
@c
#include "mal_config.h"
#include "mal_interpreter.h"
#include "mal_function.h"
#include "mal_recycle.h"
#include "recycle.h"

@-
The recycler is started when the first function is called for its support.
Upon exit of the last function, the content of the recycle cache is destroyed.
@c
str
RECYCLEstart(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{

	(void) pci;
	(void) stk;

	if( recycleVersion == 0){	
		MT_lock_init(&recycleLock,"recycle");
		recycleVersion =1 ;
	}
	if( mb->version )
		/* upgrade to a new version by dropping old info */
		RECYCLEversion(mb);
	else{
		mal_set_lock(recycleLock,"recycle");
		mb->version= recycleVersion;
		recycleClaim++;
		mal_unset_lock(recycleLock,"recycle");
	}
	return MAL_SUCCEED;
}


str
RECYCLEstop(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	(void) mb;
	(void) stk;
	(void) pci;
	if( recycleBlk == 0)
		return MAL_SUCCEED;
	mal_set_lock(recycleLock,"recycle");
	recycleBlk->version = 0;
	recycleClaim--;
	mal_unset_lock(recycleLock,"recycle");
	return MAL_SUCCEED;
}


str
RECYCLEresetCMD(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	RECYCLEreset(mb,stk,pci);
	return MAL_SUCCEED;
}

str
RECYCLEdump(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	int i;
	Client cntxt= MCgetClient();

	(void) mb;
	(void) stk;
	(void) pci;
	stream_printf(cntxt->fdout,"#Recycler  catalog\n");
	stream_printf(cntxt->fdout,"#retain= %d time =%d sze= %d alpha= %4.3f\n",
		retainPolicy, recycleTime, recycleVolume, recycleAlpha);
	stream_printf(cntxt->fdout,"#reuse= %d\n", reusePolicy);
	stream_printf(cntxt->fdout,"#rcache= %d limit= %d \n", rcachePolicy, recycleCacheLimit);
	stream_printf(cntxt->fdout,"#hard stmt = %d hard var = %d hard mem= %d\n",
		 HARDLIMIT_STMT, HARDLIMIT_VAR, HARDLIMIT_MEM);
	stream_printf(cntxt->fdout,"#recycled = %d statements = %d saved time(ms)= %8.2f memory(KB)= %d\n",
		 recycled, statements, savedTime/1000.0,recyclerUsedMemory);

	/* and dump the statistics */
	if (recycleBlk)
	for(i=0; i< recycleBlk->stop; i++){
		stream_printf(cntxt->fdout,"# %4d lru= %8d cnt= %8d ticks= %9d  rd= %9d  wr= %9d %s\n", i,
			recycleBlk->profiler[i].clk,
			recycleBlk->profiler[i].counter,
			recycleBlk->profiler[i].ticks,
			recycleBlk->profiler[i].ibytes,
			recycleBlk->profiler[i].obytes,
			instruction2str(recycleBlk,getInstrPtr(recycleBlk,i),TRUE));
	}
	return MAL_SUCCEED;
}

str
RECYCLEsetRetain(MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	(void) mb;
	retainPolicy = * (int*) getArgReference(stk, p,1);
	if( p->argc >= 2)
	switch(retainPolicy){
	case RETAIN_VOL:
		if( p->argc >= 3)
			recycleVolume = * (int*) getArgReference(stk, p,3);
	case RETAIN_TIME:
	case RETAIN_ADAPT:
		recycleTime = * (int*) getArgReference(stk, p,2);
		break;
	case RETAIN_SIZE:
		recycleVolume = * (int*) getArgReference(stk, p,2);
	}
	if(p->argc >3)
		recycleAlpha = 1.0/  *(int*) getArgReference(stk, p,4);
	return MAL_SUCCEED;
}

str
RECYCLEsetReuse(MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	(void) mb;
	reusePolicy = * (int*) getArgReference(stk, p,1);
	return MAL_SUCCEED;
}

str
RECYCLEsetCache(MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	(void) mb;
	rcachePolicy = * (int*) getArgReference(stk, p, 1);
	if( rcachePolicy && p->argc >= 2)
		recycleCacheLimit = * (int*) getArgReference(stk, p, 2);
	if( rcachePolicy && p->argc >= 3)
		recycleMemory= * (int*) getArgReference(stk, p, 3);
	return MAL_SUCCEED;
}

str 
RECYCLEgetRetain(int *p)
{
	*p = retainPolicy;
	return MAL_SUCCEED;
}

str 
RECYCLEgetReuse(int *p)
{
	*p = reusePolicy;
	return MAL_SUCCEED;
}

str 
RECYCLEgetCache(int *p)
{
	*p = rcachePolicy;
	return MAL_SUCCEED;
}

@-
At the end of the session we have to cleanup the recycle cache.
@c
str
RECYCLEshutdownWrap(int *ret){
	(void) ret;
	RECYCLEshutdown();
	return MAL_SUCCEED;
}
str 
RECYCLEmonitor(int *ret, int *p)
{
	(void) ret;
	monitorRecycler = *p;
	return MAL_SUCCEED;
}

str 
RECYCLEprelude(MalBlkPtr mb, MalStkPtr stk, InstrPtr p){
	(void) stk;
	(void) p;
	RECYCLEversion(mb);
	return MAL_SUCCEED;
}
str 
RECYCLEepilogue(MalBlkPtr mb, MalStkPtr stk, InstrPtr p){
	(void) mb;
	(void) stk;
	(void) p;
	return MAL_SUCCEED;
}
@}
