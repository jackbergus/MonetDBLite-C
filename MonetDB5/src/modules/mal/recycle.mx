@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2008 CWI.
@' All Rights Reserved.

@a M. Ivanova, M. Kersten
@f recycle
@- The Recycler
Just the interface to the recycler.
@{
@-
The Recycler should be a variation of the interpreter
which inspects the variable table for alternative results.
@mal
module recycle;

pattern start():void
address RECYCLEstart
comment "Initialize recycler for the current block";

pattern stop():void
address RECYCLEstop
comment "Cleans recycler bookkeeping";

pattern dump():void
address RECYCLEdumpWrap
comment "Dump summary of recycle table for potential re-use benefits";

pattern dump(n:str):void
address RECYCLEdumpWrap
comment "Dump summary of recycle table into a file";

pattern setRetainPolicy(p:int...):void
address RECYCLEsetRetain
comment "Set recycler retainment policy:
0- RETAIN_NONE: baseline, keeps stat, no retain, no reuse
1- RETAIN_ALL: infinite case, retain all
2- RETAIN_TIME: time-based semantics, retain if beneficial
3- RETAIN_SIZE: size cost model
4- RETAIN_VOL: volumetric cost model (time x size )
5- RETAIN_ADAP: adaptive temporal";

command getRetainPolicy():int
address RECYCLEgetRetain;

pattern setReusePolicy(p:int...):void
address RECYCLEsetReuse
comment "Set recycler reuse policy";

command getReusePolicy():int
address RECYCLEgetReuse;

pattern setCachePolicy(p:int...):void
address RECYCLEsetCache
comment "Set recycler cache policy:
0- RCACHE_ALL: baseline, do nothing
1- RCACHE_LRU: throw LRU by setting the limit
2- RCACHE_CREDIT: credit-based LRU scheme
3- RCACHE_MEMLRU: reduce the storage overhead
4- RCACHE_MEMCRD: reduce the storage overhead 
optional arguments are [ instruction-, [memory -]] limit";

command getCachePolicy():int
address RECYCLEgetCache;

pattern reset(bid:bat):void
address RECYCLEresetCMD
comment "Reset off all recycled variables";

command shutdown():void
address RECYCLEshutdownWrap
comment "Clear the recycle cache";

command monitor(f:int):void
address RECYCLEmonitor
comment "start/stop the monitoring (printing) of the recycler info (storage size used and number of statements retained)";

command log(nm:str):void
address RECYCLElog
comment "Set the name of recycle log file";

pattern prelude():void
address RECYCLEprelude
comment "Called at the start of a recycle controlled function";

pattern epilogue():void
address RECYCLEepilogue
comment "Called at the start of a recycle controlled function";
@h
#ifndef _RECYCLE_
#define _RECYCLE_

#include "mal.h"
#include "mal_instruction.h"

#ifdef WIN32
#ifndef LIBRECYCLE
#define recycle_export extern __declspec(dllimport)
#else
#define recycle_export extern __declspec(dllexport)
#endif
#else
#define recycle_export extern
#endif

recycle_export str RECYCLEdumpWrap(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
recycle_export str RECYCLEstart(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
recycle_export str RECYCLEstop(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
recycle_export str RECYCLEsetRetain(MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
recycle_export str RECYCLEsetReuse(MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
recycle_export str RECYCLEresetCMD(MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
recycle_export str RECYCLEsetCache(MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
recycle_export str RECYCLEgetRetain(int *p);
recycle_export str RECYCLEgetReuse(int *p);
recycle_export str RECYCLEgetCache(int *p);
recycle_export str RECYCLEshutdownWrap(int *ret);
recycle_export str RECYCLEmonitor(int *d, int *p);
recycle_export str RECYCLElog(int *d, str *nm);
recycle_export str RECYCLEprelude(MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
recycle_export str RECYCLEepilogue(MalBlkPtr mb, MalStkPtr stk, InstrPtr p);

#endif
@-
@c
#include "mal_config.h"
#include "mal_interpreter.h"
#include "mal_function.h"
#include "mal_recycle.h"
#include "recycle.h"

str recycleLog = NULL; 
int recycled0 = 0;
lng time0 = 0; /*start time of query */
@-
The recycler is started when the first function is called for its support.
Upon exit of the last function, the content of the recycle cache is destroyed.
@c
str
RECYCLEstart(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{

	(void) pci;
	(void) stk;

	if( recycleVersion == 0){	
		MT_lock_init(&recycleLock,"recycle");
		recycleVersion =1 ;
	}
	if( mb->version )
		/* upgrade to a new version by dropping old info */
		RECYCLEversion(mb);
	else{
		mal_set_lock(recycleLock,"recycle");
		mb->version= recycleVersion;
		recycleClaim++;
		mal_unset_lock(recycleLock,"recycle");
	}
	return MAL_SUCCEED;
}


str
RECYCLEstop(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	(void) mb;
	(void) stk;
	(void) pci;
	if( recycleBlk == 0)
		return MAL_SUCCEED;
	mal_set_lock(recycleLock,"recycle");
	recycleBlk->version = 0;
	recycleClaim--;
	mal_unset_lock(recycleLock,"recycle");
	return MAL_SUCCEED;
}


str
RECYCLEresetCMD(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	RECYCLEreset(mb,stk,pci);
	return MAL_SUCCEED;
}

void
RECYCLEdump(stream *s)
{
	int i, incache;

	stream_printf(s,"#Recycler  catalog\n");
	stream_printf(s,"#retain= %d time =%d sze= %d alpha= %4.3f\n",
		retainPolicy, recycleTime, recycleVolume, recycleAlpha);
	stream_printf(s,"#reuse= %d\n", reusePolicy);
	stream_printf(s,"#rcache= %d limit= %d memlimit=%d\n", rcachePolicy, recycleCacheLimit, recycleMemory);
	stream_printf(s,"#hard stmt = %d hard var = %d hard mem= %d\n",
		 HARDLIMIT_STMT, HARDLIMIT_VAR, HARDLIMIT_MEM);
	incache = recycleBlk? recycleBlk->stop-1:0;
	stream_printf(s,"#recycled = %d incache= %d executed = %d saved time(ms)= %8.2f memory(KB)= %d\n",
		 recycled, incache,statements, savedTime/1000.0,recyclerUsedMemory);
	stream_printf(s,"#Cache search time= %d(usec)\n",recycleSearchTime);

	/* and dump the statistics */
	if (recycleBlk){
        stream_printf(s,"# CL\t   lru\t\tcnt\t ticks\t rd\t wr\t Instr\n");
	for(i=1; i< recycleBlk->stop; i++){
		stream_printf(s,"%4d\t%d\t%d\t%d\t%d\t%d\t%s\n", i,
			recycleBlk->profiler[i].clk,
			recycleBlk->profiler[i].counter,
			recycleBlk->profiler[i].ticks,
			recycleBlk->profiler[i].ibytes,
			recycleBlk->profiler[i].obytes,
			instruction2str(recycleBlk,getInstrPtr(recycleBlk,i),TRUE));
	}
	}
}


str
RECYCLEdumpWrap(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	Client cntxt= MCgetClient();
	stream *s = cntxt->fdout;
	str fname;

	(void) mb;
	if (pci->argc >1){
		fname = * (str*) getArgReference(stk, pci,1);
		s = open_wastream(fname);
		if (s == NULL || stream_errnr(s)) {
        	        GDKerror("could not open file %s.\n", fname);
			s = cntxt->fdout;
		}
	}
	RECYCLEdump(s);
	if( s != cntxt->fdout)
		close_stream(s);
	return MAL_SUCCEED;
}

@-
Called to collect statistics at the end of each query.
@c
void
RECYCLErunningStat(MalBlkPtr mb)
{	
	static int q=0;
	stream *s;
	InstrPtr p;
	int potrec=0, i;

	if (recycleLog == NULL) 
		s = MCgetClient()->fdout;
	else {
		s = append_wastream(recycleLog);
		if (s == NULL || stream_errnr(s)) {
        	        GDKerror("could not open file %s.\n", recycleLog);
			s = MCgetClient()->fdout;
		}
	}

	for(i=0; i< mb->stop; i++){
		p = mb->stmt[i];
		if ( RECYCLEinterest(mb,p) ) potrec++;
	}

	stream_printf(s,"%d\t %d\t %d\t %d\t %8.2f\t",++q, mb->stop, potrec,
		recycled-recycled0,(GDKusec()-time0)/1000.0);
	stream_printf(s,"%d\t %d\t %d\t %d\n",
		recycled,recycleBlk?recycleBlk->stop-1:0,statements,recyclerUsedMemory);
	if( s != MCgetClient()->fdout)
		close_stream(s);
}


str
RECYCLEsetRetain(MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	(void) mb;
	retainPolicy = * (int*) getArgReference(stk, p,1);
	if( p->argc > 2)
	switch(retainPolicy){
	case RETAIN_VOL:
		if( p->argc > 3)
			recycleVolume = * (int*) getArgReference(stk, p,3);
	case RETAIN_TIME:
	case RETAIN_ADAPT:
		recycleTime = * (int*) getArgReference(stk, p,2);
		break;
	case RETAIN_SIZE:
		recycleVolume = * (int*) getArgReference(stk, p,2);
	}
	if(p->argc >4)
		recycleAlpha = 1.0/  *(int*) getArgReference(stk, p,4);
	return MAL_SUCCEED;
}

str
RECYCLEsetReuse(MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	(void) mb;
	reusePolicy = * (int*) getArgReference(stk, p,1);
	return MAL_SUCCEED;
}

str
RECYCLEsetCache(MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	(void) mb;
	rcachePolicy = * (int*) getArgReference(stk, p, 1);
	if( rcachePolicy && p->argc > 2)
		recycleCacheLimit = * (int*) getArgReference(stk, p, 2);
	if( rcachePolicy && p->argc > 3)
		recycleMemory= * (int*) getArgReference(stk, p, 3);
	return MAL_SUCCEED;
}

str 
RECYCLEgetRetain(int *p)
{
	*p = retainPolicy;
	return MAL_SUCCEED;
}

str 
RECYCLEgetReuse(int *p)
{
	*p = reusePolicy;
	return MAL_SUCCEED;
}

str 
RECYCLEgetCache(int *p)
{
	*p = rcachePolicy;
	return MAL_SUCCEED;
}

@-
At the end of the session we have to cleanup the recycle cache.
@c
str
RECYCLEshutdownWrap(int *ret){
	(void) ret;
	RECYCLEshutdown();
	return MAL_SUCCEED;
}
str 
RECYCLEmonitor(int *ret, int *p)
{
	(void) ret;
	monitorRecycler = *p;
	return MAL_SUCCEED;
}

str 
RECYCLElog(int *ret, str *nm)
{
	stream *s;
	(void) ret;
	recycleLog = GDKstrdup(*nm);
	s = open_wastream(recycleLog);
        if (s){
        	stream_printf(s,"# Q\t InstrQ\t PotRecQ RecQ\t TimeQ(ms)\tRecTot\tincache\tInstrTot\tmemory(KB)\n");
                close_stream(s);
	}

	return MAL_SUCCEED;
}

str 
RECYCLEprelude(MalBlkPtr mb, MalStkPtr stk, InstrPtr p){
	(void) stk;
	(void) p;
	RECYCLEversion(mb);
	recycleRecent = -1;
	recycled0 = recycled; 
	time0 = GDKusec();
	return MAL_SUCCEED;
}
str 
RECYCLEepilogue(MalBlkPtr mb, MalStkPtr stk, InstrPtr p){
	(void) mb;
	(void) stk;
	(void) p;
	if (monitorRecycler == 2 ) RECYCLErunningStat(mb);
	return MAL_SUCCEED;
}
@}
