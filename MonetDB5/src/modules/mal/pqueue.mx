@/
The contents of this file are subject to the MonetDB Public License
Version 1.1 (the "License"); you may not use this file except in
compliance with the License. You may obtain a copy of the License at
http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html

Software distributed under the License is distributed on an "AS IS"
basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations
under the License.

The Original Code is the MonetDB Database System.

The Initial Developer of the Original Code is CWI.
Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
Copyright August 2008-2011 MonetDB B.V.
All Rights Reserved.
@

@f pqueue
@a Nikos Mamoulis, Niels Nes
@v 2.0
@+ Priority queues

This module includes functions for accessing and updating a pqueue.
A pqueue is an (oid,any) bat. The tail is used as a comparison key.
The first element of the pqueue is the smallest one in a min-pqueue
or the largest one in a max-pqueue. 
Each element is larger than (smaller than) or equal to 
its parent which is defined by (position/2) if position is odd or 
(position-1)/2 if position is even (positions are from 0 to n-1).
The head of the bat is used to keep track of the object-ids which are
organized in the heap with respect to their values (tail column).
@{

@+ Module Definition 
@mal
module pqueue;

command init(a:bat[:void,:any_1],maxsize:wrd):bat[:oid,:any_1] 
address PQinit
comment "Creates an empty pqueue of bat a's tailtype with maximum size maxsize";

@= mel_minmax
command enqueue_@2(h:bat[:oid,:@1], id:oid, value:@1) 
address PQenqueue_@1@2
comment "Inserts element (oid,@1) in the @2-pqueue";

command topreplace_@2(h:bat[:oid,:@1], id:oid, value:@1) 
address PQtopreplace_@1@2
comment "Replaces top element with input and updates @2-pqueue";

command dequeue_@2(h:bat[:oid,:@1]) 
address PQdequeue_@1@2
comment "Removes top element of the @2-pqueue and updates it";

command topn_@2(t:bat[:oid,:@1], n:wrd) :bat[:oid,:oid] 
address PQtopn_@1@2
comment "Return the topn elements of the bat t using a @2-pqueue";

command topn_@2(t:bat[:void,:@1], n:wrd) :bat[:oid,:oid] 
address PQtopn_@1@2
comment "Return the topn elements of the bat t using a @2-pqueue";

command utopn_@2(t:bat[:oid,:@1], n:wrd) :bat[:oid,:oid] 
address PQutopn_@1@2
comment "Return the unique topn elements of the bat t using a @2-pqueue";

command utopn_@2(t:bat[:void,:@1], n:wrd) :bat[:oid,:oid] 
address PQutopn_@1@2
comment "Return the unique topn elements of the bat t using a @2-pqueue";

@= mel_minmax_any
pattern topreplace_@1(h:bat[:oid,:any_1], id:oid, value:any_1) 
address PQtopreplace_any@1
comment "Replaces top element with input and updates @1-pqueue";

pattern enqueue_@1(h:bat[:oid,:any_1], id:oid, value:any_1) 
address PQenqueue_any@1
comment "Inserts element (oid,any) in the @1-pqueue";

command dequeue_@1(h:bat[:oid,:any_1]) 
address PQdequeue_any@1
comment "Removes top element of the @1-pqueue and updates it";

command topn_@1(t:bat[:oid,:any_1], n:wrd) :bat[:oid,:oid] 
address PQtopn_any@1
comment "Return the topn elements of the bat t using a @1-pqueue";

command topn_@1(t:bat[:void,:any_1], n:wrd) :bat[:oid,:oid] 
address PQtopn_any@1
comment "Return the topn elements of the bat t using a @1-pqueue";

command utopn_@1(t:bat[:oid,:any_1], n:wrd) :bat[:oid,:oid] 
address PQutopn_any@1
comment "Return the unique topn elements of the bat t using a @1-pqueue";

command utopn_@1(t:bat[:void,:any_1], n:wrd) :bat[:oid,:oid] 
address PQutopn_any@1
comment "Return the unique topn elements of the bat t using a @1-pqueue";

command topn_@1(a:bat[:oid,:oid], t:bat[:oid,:any_1], n:wrd) :bat[:oid,:oid] 
address PQtopn2_any@1
comment "Return the topn elements of the bat t using a @1-pqueue";

command topn_@1(a:bat[:oid,:oid], t:bat[:void,:any_1], n:wrd) :bat[:oid,:oid] 
address PQtopn2_any@1
comment "Return the topn elements of the bat t using a @1-pqueue";

command utopn_@1(a:bat[:oid,:oid], t:bat[:oid,:any_1], n:wrd) :bat[:oid,:oid] 
address PQutopn2_any@1
comment "Return the unique topn elements of the bat t using a @1-pqueue";

command utopn_@1(a:bat[:oid,:oid], t:bat[:void,:any_1], n:wrd) :bat[:oid,:oid] 
address PQutopn2_any@1
comment "Return the unique topn elements of the bat t using a @1-pqueue";

@= mel_pqueue_any
  @:mel_minmax_any(min)@
  @:mel_minmax_any(max)@
@mal
@:mel_pqueue_any()@

@= mel_pqueue
  @:mel_minmax(@1,min)@
  @:mel_minmax(@1,max)@
@mal

@:mel_pqueue(chr)@
@:mel_pqueue(bte)@
@:mel_pqueue(sht)@
@:mel_pqueue(int)@
@:mel_pqueue(oid)@
@:mel_pqueue(wrd)@
@:mel_pqueue(ptr)@
@:mel_pqueue(lng)@
@:mel_pqueue(flt)@
@:mel_pqueue(dbl)@

@+ Implementation
@h
#ifndef _PQUEUE_
#define _PQUEUE_

#include "mal.h"

#ifdef WIN32
#if !defined(LIBMAL) && !defined(LIBATOMS) && !defined(LIBKERNEL) && !defined(LIBMAL) && !defined(LIBOPTIMIZER) && !defined(LIBSCHEDULER) && !defined(LIBMONETDB5)
#define pqueue_export extern __declspec(dllimport)
#else
#define pqueue_export extern __declspec(dllexport)
#endif
#else
#define pqueue_export extern
#endif

pqueue_export str PQinit(int *ret, int *bid, wrd *maxsize);

#endif /* _PQUEUE */
@c
#include "monetdb_config.h"
#include "pqueue.h"
#include "mal_exception.h"
#include "mal_interpreter.h"

/*returns the parent of a pqueue position*/
static inline BUN parent(BUN posel)
{
  if (posel%2) /*odd*/
	return posel/2;
  else
	return (posel-1)/2;
}

/*initialize pqueue*/
static int
do_pqueue_init(BAT **h, BAT *b, BUN maxsize)
{
	*h = BATnew(TYPE_oid, b->ttype, maxsize);
	if (*h == NULL)
		return GDK_FAIL;
	(*h)->batDirty |= 2;
	return GDK_SUCCEED;
}

int 
pqueue_init(BAT **h, BAT *b, wrd *maxsize)
{
	return do_pqueue_init(h, b, (BUN) *maxsize);
}

#define ht_swap(tpe,cur,ins) {					\
	  oid htmp = *(oid*)BUNhloc(hi,cur); 			\
	  tpe ttmp = *(tpe*)BUNtloc(hi,cur);			\
	  *(oid*)BUNhloc(hi,cur) = *(oid*)BUNhloc(hi,ins);	\
	  *(tpe*)BUNtloc(hi,cur) = *(tpe*)BUNtloc(hi,ins);	\
	  *(oid*)BUNhloc(hi,ins) = htmp; 			\
	  *(tpe*)BUNtloc(hi,ins) = ttmp;			\
}

#define any_swap(cur,ins,ts) {					\
	  unsigned int i;					\
	  char ch;						\
          /* only swap the locations (ie var_t's) */		\
	  char *c1 = BUNtloc(hi,cur), *c2 = BUNtloc(hi,ins);	\
	  oid htmp = *(oid*)BUNhloc(hi,cur); 			\
	  *(oid*)BUNhloc(hi,cur) = *(oid*)BUNhloc(hi,ins);	\
	  *(oid*)BUNhloc(hi,ins) = htmp; 			\
	  for(i=0;i<ts;i++) {					\
		ch= c1[i]; c1[i]=c2[i]; c2[i]=ch;		\
	  }							\
}

@= pqueueimpl_minmax
/*enqueue an element*/
int pqueue_enqueue_@1@2(BAT *h,
		 oid *idx, 
		 @3 *el)
{
  BATiter hi = bat_iterator(h);
  BUN ins,cur;

  BUN hbase = BUNfirst(h);
  BUN p, posel = BATcount(h); /*last position*/
 
  BUNins(h, (ptr)idx, (ptr)el, FALSE);
  ins = hbase+posel;
  
  while(posel >0) {
	p=parent(posel);
	cur = hbase+p;
	if (*(@3 *)BUNtloc(hi,ins) @4 *(@3 *)BUNtloc(hi,cur)) {
	  /* swap element with its parent */
	  ht_swap(@3,cur,ins);
	  ins = cur;
	  posel = parent(posel);
	}
	else break;
  }
  h->hsorted = h->tsorted = FALSE;
  
  return GDK_SUCCEED;
}

/* moves down the root element */
/* used by dequeue (see below) */
static int pqueue_movedowntop_@1@2(BAT *h)
{
  BATiter hi = bat_iterator(h);
  BUN swp, cur, hbase = BUNfirst(h);
  BUN swap, num_elems = BATcount(h);
  BUN posel = 0;

  cur = hbase;
  
  /*while posel is not a leaf and pqueue[posel].tail > any of childen*/
  while (posel*2+1 < num_elems) { /*there exists a left son*/
	if (posel*2+2< num_elems) { /*there exists a right son*/
	  if (*(@3 *)BUNtloc(hi,hbase+(posel*2+1)) @4
	      *(@3 *)BUNtloc(hi,hbase+(posel*2+2)))
		swap = posel*2+1;
	  else
		swap = posel*2+2;
	} else
		swap = posel*2+1;

	swp = hbase+swap;

	if (*(@3 *)BUNtloc(hi,swp) @4 *(@3 *)BUNtloc(hi,cur)) {
	  /*swap elements*/
	  ht_swap(@3,cur,swp);
	  cur = swp;
	  posel = swap;
	} else 
		break;
  }

  return GDK_SUCCEED;
}

/* removes the root element, puts the last element as root and moves it down */
int pqueue_dequeue_@1@2(BAT *h)
{
  BATiter hi = bat_iterator(h);
  BUN hbase;
  BUN num_elements;

  if (!(num_elements = BATcount(h))) {
    /* pqueue_dequeue: Cannot dequeue from empty queue */
    return GDK_FAIL;
  }

  hbase = BUNfirst(h);

  /* copy last element to the first position*/
  ht_swap(@1,hbase, hbase+(num_elements-1));

  /*delete last element*/
  BUNdelete(h, hbase+(num_elements-1), FALSE);

  pqueue_movedowntop_@1@2(h);
  return GDK_SUCCEED;
}

/* replaces the top element with the input if it is larger (smaller) and
 * updates the heap */
int pqueue_topreplace_@1@2(BAT *h,
		 oid *idx,
		 @3 *el)
{
  BATiter hi = bat_iterator(h);
  BUN hbase;

  hbase = BUNfirst(h);

  if (*(@3 *)BUNtloc(hi,hbase) @4 *el) {
	*(oid*)BUNhloc(hi,hbase) = *idx;
	*(@3*)BUNtloc(hi,hbase) = *el;
	pqueue_movedowntop_@1@2(h);
  }
  
  return GDK_SUCCEED;
}

/* TopN, based on @2-pqueue */

static BAT *
heap2bat_@1@2( BAT *h )
{
	BAT *r, *n = BATnew(TYPE_oid, TYPE_oid, BATcount(h));
	BUN f = BUNfirst(h);
	oid *o = (oid*)Hloc(h, f), oo = *o;
	@1 *v = (@1*)Tloc(h, f), ov = *v;
	
	for(f = BUNfirst(h); f < BUNlast(h); f = BUNfirst(h)) {
		o = (oid*)Hloc(h, f);
		v = (@1*)Tloc(h, f);
		if (ov != *v) {
			oo = *o;
			ov = *v;
		}
		BUNins(n, o, &oo, FALSE);
  		pqueue_dequeue_@1@2(h);
	}
	r = BATrevert(n);
	return r;
}

int pqueue_topn_void@1@2(BAT **H, BAT *t, wrd *N)
{
  BAT *h = NULL;
  BATiter ti = bat_iterator(t);
  @1 *v;
  BUN i, n = BATcount(t);
  oid idx = t->hseqbase;

  if (*N != wrd_nil && *N >= 0 && *N <= (wrd) BUN_MAX && (BUN) *N < n)
	  n = (BUN) *N;
  if (do_pqueue_init(&h,t,n) == GDK_FAIL)
	  return GDK_FAIL;
  v = (@1*)BUNtail(ti,BUNfirst(t));

  for(i=0; i<n; i++, idx++, v++) {
	pqueue_enqueue_@1@2(h, &idx, v); 
  }
  n = BATcount(t);
  for(; i<n; i++, idx++, v++) {
	pqueue_topreplace_@1@2(h, &idx, v); 
  }
  *H = heap2bat_@1@2(h);
  BBPunfix(h->batCacheid);
  return GDK_SUCCEED;
}

int pqueue_topn_@1@2(BAT **H, BAT *t, wrd *N)
{
  BAT *h = NULL;
  BATiter ti = bat_iterator(t);
  BUN i, n = BATcount(t);
  BUN p = BUNfirst(t);

  if (*N != wrd_nil && *N >= 0 && *N <= (wrd) BUN_MAX && (BUN) *N < n)
	  n = (BUN) *N;
  if (do_pqueue_init(&h,t,n) == GDK_FAIL)
	  return GDK_FAIL;

  for(i=0; i<n; i++, p++) {
	pqueue_enqueue_@1@2(h, (oid*)BUNhloc(ti,p), (@1*)BUNtloc(ti,p)); 
  }
  n = BATcount(t);
  for(; i<n; i++, p++) {
	pqueue_topreplace_@1@2(h, (oid*)BUNhloc(ti,p), (@1*)BUNtloc(ti,p)); 
  }
  *H = heap2bat_@1@2(h);
  BBPunfix(h->batCacheid);
  return GDK_SUCCEED;
}

/* TopN (unique values), based on @2-pqueue */

int pqueue_utopn_void@1@2(BAT **H, BAT *t, wrd *N)
{
  BAT *duplicates = NULL, *b;
  BATiter ti = bat_iterator(t);
  @1 *v;
  BUN i, j, n, cnt = BATcount(t), p;
  oid idx = t->hseqbase;

  n = cnt;
  if (*N != wrd_nil && *N >= 0 && *N <= (wrd) BUN_MAX)
          n = (BUN) *N;
  if (do_pqueue_init(H,t,n) == GDK_FAIL)
	  return GDK_FAIL;
  duplicates = BATnew(TYPE_oid, TYPE_oid, n);
  if (duplicates == NULL) {
	  BBPunfix((*H)->batCacheid);
	  return GDK_FAIL;
  }
  v = (@1*)BUNtail(ti,BUNfirst(t));

  for(i=0, j=0; j < cnt && i<n; j++, idx++, v++) {
	if ((p = BUNfnd(BATmirror(*H), v)) == BUN_NONE) {
		pqueue_enqueue_@1@2(*H, &idx, v); 
	        HASHdestroy(*H);
		BUNins(duplicates, &idx, &idx, FALSE);
		i++;
	} else {
		BUNins(duplicates, Hloc(*H, p), &idx, FALSE);
	}
  }
  for(; j<cnt; j++, idx++, v++) {
        if (*(@3 *)Tloc(*H,BUNfirst(*H)) @4= *v) {
		if ((p = BUNfnd(BATmirror(*H), v)) == BUN_NONE) {
			oid o_idx = *(oid*)Hloc(*H, BUNfirst(*H));
			BUNdelHead(duplicates, &o_idx, TRUE);
			pqueue_topreplace_@1@2(*H, &idx, v); 
	        	HASHdestroy(*H);
			BUNins(duplicates, &idx, &idx, FALSE);
		} else {
			BUNins(duplicates, Hloc(*H, p), &idx, FALSE);
		}
	}
  }
  b = heap2bat_@1@2(*H);
  BBPunfix((*H)->batCacheid); *H = b;
  b = VIEWcombine(*H);
  BBPunfix((*H)->batCacheid); *H = b;
  b = BATleftjoin(*H, duplicates, BATcount(duplicates));
  BBPunfix((*H)->batCacheid);
  BBPunfix(duplicates->batCacheid);
  *H = BATmirror(b);
  return GDK_SUCCEED;
}

int pqueue_utopn_@1@2(BAT **H, BAT *t, wrd *N)
{
  BAT *duplicates = NULL, *b;
  BATiter ti = bat_iterator(t);
  @1 *v;
  BUN i, j, n, cnt = BATcount(t), p;
  oid *idx;

  n = cnt;
  if (*N != wrd_nil && *N >= 0 && *N <= (wrd) BUN_MAX)
          n = (BUN) *N;
  if (do_pqueue_init(H,t,n) == GDK_FAIL)
	  return GDK_FAIL;
  duplicates = BATnew(TYPE_oid, TYPE_oid, n);
  if (duplicates == NULL) {
	  BBPunfix((*H)->batCacheid);
	  return GDK_FAIL;
  }
  v = (@1*)BUNtail(ti,BUNfirst(t));
  idx = (oid*)BUNhead(ti,BUNfirst(t));

  for(i=0, j=0; j < cnt && i<n; j++, idx++, v++) {
	if ((p = BUNfnd(BATmirror(*H), v)) == BUN_NONE) {
		pqueue_enqueue_@1@2(*H, idx, v); 
	        HASHdestroy(*H);
		BUNins(duplicates, idx, idx, FALSE);
		i++;
	} else {
		BUNins(duplicates, Hloc(*H, p), idx, FALSE);
	}
  }
  for(; j<cnt; j++, idx++, v++) {
        if (*(@3 *)Tloc(*H,BUNfirst(*H)) @4= *v) {
		if ((p = BUNfnd(BATmirror(*H), v)) == BUN_NONE) {
			oid o_idx = *(oid*)Hloc(*H, BUNfirst(*H));
			BUNdelHead(duplicates, &o_idx, TRUE);
			pqueue_topreplace_@1@2(*H, idx, v); 
	        	HASHdestroy(*H);
			BUNins(duplicates, idx, idx, FALSE);
		} else {
			BUNins(duplicates, Hloc(*H, p), idx, FALSE);
		}
	}
  }
  b = heap2bat_@1@2(*H);
  BBPunfix((*H)->batCacheid); *H = b;
  b = VIEWcombine(*H);
  BBPunfix((*H)->batCacheid); *H = b;
  b = BATleftjoin(*H, duplicates, BATcount(duplicates));
  BBPunfix((*H)->batCacheid); 
  BBPunfix(duplicates->batCacheid);
  *H = BATmirror(b);
  return GDK_SUCCEED;
}
@c
@= pqueueimpl
  @:pqueueimpl_minmax(@1,min,@1,<)@
  @:pqueueimpl_minmax(@1,max,@1,>)@
@c
@:pqueueimpl(chr)@
@:pqueueimpl(bte)@
@:pqueueimpl(sht)@
@:pqueueimpl(int)@
@:pqueueimpl(oid)@
@:pqueueimpl(wrd)@
@:pqueueimpl(ptr)@
@:pqueueimpl(lng)@
@:pqueueimpl(flt)@
@:pqueueimpl(dbl)@

/* The fallback case, non optimized */

@= pqueueimpl_any
/*enqueue an element*/
int pqueue_enqueue_any@1(BAT *h, oid *idx, ptr el, int tpe)
{
  BATiter hi = bat_iterator(h);
  BUN hbase;
  BUN ins,cur;
  BUN p, posel;
  unsigned short ts;

  hbase = BUNfirst(h);

  posel = BATcount(h); /*last position*/
  BUNins(h, (ptr)idx, (ptr)el, FALSE);
  ts = Tsize(h);
  ins = hbase+posel;
  
  while(posel >0) {
	p=parent(posel);
	cur = hbase+p;
	if (atom_CMP(BUNtail(hi,ins), BUNtail(hi,cur), tpe) @2 0 ) {
	  /* swap element with its parent */
	  any_swap(cur,ins,ts);
	  ins = cur;
	  posel = parent(posel);
	}
	else break;
  }
  h->hsorted = h->tsorted = FALSE;
  
  return GDK_SUCCEED;
}

/* moves down the root element */
/* used by dequeue (see below) */
static int pqueue_movedowntop_any@1(BAT *h)
{
  BATiter hi = bat_iterator(h);
  BUN hbase;
  BUN swp,cur;
  int tpe = BATttype(h);
  BUN swap, num_elems;
  BUN posel;
  unsigned short ts = Tsize(h);

  hbase = BUNfirst(h);

  cur = hbase;
  num_elems = BATcount(h);
  posel = 0;
  
  /*while posel is not a leaf and pqueue[posel].tail > any of childen*/
  while (posel*2+1 < num_elems) { /*there exists a left son*/
	if (posel*2+2< num_elems) { /*there exists a right son*/
	  if (atom_CMP(
		BUNtail(hi,hbase+(posel*2+1)),
		BUNtail(hi,hbase+(posel*2+2)), tpe) @2 0 ) {
		swap = posel*2+1;
	  } else {
		swap = posel*2+2;
	  }
	} else
		swap = posel*2+1;

	swp = hbase+swap;

	if (atom_CMP( BUNtail(hi,swp), BUNtail(hi,cur), tpe) @2 0 ) {
		/*swap elements*/
		any_swap(cur,swp,ts);
	  	cur = swp;
	  	posel = swap;
	} else 
		break;
  }
  h->hsorted = h->tsorted = FALSE;

  return GDK_SUCCEED;
}

/* removes the root element, puts the last element as root and moves it down */
int pqueue_dequeue_any@1(BAT *h)
{
  BATiter hi = bat_iterator(h);
  BUN hbase;
  BUN num_elements;
  unsigned short ts = Tsize(h);

  if (!(num_elements = BATcount(h))) {
	/* pqueue_dequeue: Cannot dequeue from empty queue */
	return GDK_FAIL;
  }

  hbase = BUNfirst(h);

  /* copy last element to the first position*/
  any_swap(hbase, hbase+(num_elements-1), ts);

  /*delete last element*/
  BUNdelete(h, hbase+(num_elements-1), FALSE);

  pqueue_movedowntop_any@1(h);
  return GDK_SUCCEED;
}

/* replaces the top element with the input if it is larger (smaller) and
 * updates the heap */
int pqueue_topreplace_any@1(BAT *h, oid *idx, ptr el, int tpe)
{
  BATiter hi = bat_iterator(h);
  BUN hbase = BUNfirst(h);

  if (atom_CMP(BUNtail(hi,hbase), el, tpe) @2 0) {
	BUNinplace(h, hbase, idx, el, 0);
	* (oid *) BUNhloc(hi, hbase) = *idx;
	pqueue_movedowntop_any@1(h);
    	h->hsorted = h->tsorted = FALSE;
  }
  
  return GDK_SUCCEED;
}

static BAT *
heap2bat_any@1( BAT *h )
{
  	BATiter hi = bat_iterator(h);
	BAT *r, *n = BATnew(TYPE_oid, TYPE_oid, BATcount(h));
	BUN f = BUNfirst(h);
	oid *o = (oid*)Hloc(h, f), oo = *o;
	ptr v = (ptr)BUNtail(hi, f), ov = v;
	int tpe = h->ttype;
	
	for(f = BUNfirst(h); f < BUNlast(h); f = BUNfirst(h)) {
		o = (oid*)Hloc(h, f);
		v = (ptr)BUNtail(hi, f);
		if (atom_CMP(ov,v, tpe) != 0) {
			oo = *o;
			ov = v;
		}
		BUNins(n, o, &oo, FALSE);
  		pqueue_dequeue_any@1(h);
	}
	r = BATrevert(n);
	return r;
}

int pqueue_topn_voidany@1(BAT **H, BAT *t, wrd *N)
{
  BAT *h = NULL;
  BATiter ti = bat_iterator(t);
  BUN i, n = BATcount(t);
  oid idx = t->hseqbase;
  BUN p = BUNfirst(t);
  int tpe = BATttype(t);

  if (*N != wrd_nil && *N >= 0 && *N <= (wrd) BUN_MAX && (BUN) *N < n)
   	n = (BUN) *N;
  if (do_pqueue_init(&h,t,n) == GDK_FAIL)
	  return GDK_FAIL;

  for(i=0; i<n; i++, idx++, p++) {
	pqueue_enqueue_any@1(h, &idx, BUNtail(ti,p), tpe); 
  }
  n = BATcount(t);
  for(; i<n; i++, idx++, p++) {
	pqueue_topreplace_any@1(h, &idx, BUNtail(ti,p), tpe); 
  }
  *H = heap2bat_any@1(h);
  BBPunfix(h->batCacheid);
  return GDK_SUCCEED;
}

int pqueue_topn_any@1(BAT **H, BAT *t, wrd *N)
{
  BAT *h = NULL;
  BATiter ti = bat_iterator(t);
  BUN i, n = BATcount(t);
  BUN p = BUNfirst(t);
  int tpe = BATttype(t);

  if (*N != wrd_nil && *N >= 0 && *N <= (wrd) BUN_MAX && (BUN) *N < n)
   	n = (BUN) *N;
  if (do_pqueue_init(&h,t,n) == GDK_FAIL)
	  return GDK_FAIL;

  for(i=0; i<n; i++, p++) {
	pqueue_enqueue_any@1(h, (oid*)BUNhloc(ti,p), BUNtail(ti,p), tpe); 
  }
  n = BATcount(t);
  for(; i<n; i++, p++) {
	pqueue_topreplace_any@1(h, (oid*)BUNhloc(ti,p), BUNtail(ti,p), tpe); 
  }
  *H = heap2bat_any@1(h);
  BBPunfix(h->batCacheid);
  return GDK_SUCCEED;
}

int pqueue_utopn_voidany@1(BAT **H, BAT *t, wrd *N)
{
  BAT *duplicates = NULL, *b;
  BATiter hi, ti = bat_iterator(t);
  BUN i, j, n, cnt = BATcount(t), p;
  BUN q = BUNfirst(t);
  ptr v;
  oid idx = t->hseqbase;
  int tpe = BATttype(t);

  n = cnt;
  if (*N != wrd_nil && *N >= 0 && *N <= (wrd) BUN_MAX)
          n = (BUN) *N;
  if (do_pqueue_init(H,t,n) == GDK_FAIL)
	  return GDK_FAIL;
  duplicates = BATnew(TYPE_oid, TYPE_oid, n);
  if (duplicates == NULL) {
	  BBPunfix((*H)->batCacheid);
	  return GDK_FAIL;
  }
  hi = bat_iterator(*H);

  for(i=0, j=0; j < cnt && i<n; j++, idx++, q++) {
	v = BUNtail(ti,q);
	if ((p = BUNfnd(BATmirror(*H), v)) == BUN_NONE) {
		pqueue_enqueue_any@1(*H, &idx, v, tpe); 
	        HASHdestroy(*H);
		BUNins(duplicates, &idx, &idx, FALSE);
		i++;
	} else {
		BUNins(duplicates, Hloc(*H, p), &idx, FALSE);
	}
  }
  for(; j<cnt; j++, idx++, q++) {
	v = BUNtail(ti,q);
	if (atom_CMP(BUNtail(hi,BUNfirst(*H)), v, tpe) @2= 0) {
		if ((p = BUNfnd(BATmirror(*H), v)) == BUN_NONE) {
			oid o_idx = *(oid*)Hloc(*H, BUNfirst(*H));
			BUNdelHead(duplicates, &o_idx, TRUE);
			pqueue_topreplace_any@1(*H, &idx, v, tpe); 
	        	HASHdestroy(*H);
			BUNins(duplicates, &idx, &idx, FALSE);
		} else {
			BUNins(duplicates, Hloc(*H, p), &idx, FALSE);
		}
	}
  }
  b = heap2bat_any@1(*H);
  BBPunfix((*H)->batCacheid); *H = b;
  b = VIEWcombine(*H);
  BBPunfix((*H)->batCacheid); *H = b;
  b = BATleftjoin(*H, duplicates, BATcount(duplicates));
  BBPunfix((*H)->batCacheid); 
  BBPunfix(duplicates->batCacheid);
  *H = BATmirror(b);
  return GDK_SUCCEED;
}

int pqueue_utopn_any@1(BAT **H, BAT *t, wrd *N)
{
  BAT *duplicates = NULL, *b;
  BATiter hi, ti = bat_iterator(t);
  BUN i, j, n, cnt = BATcount(t), p;
  BUN q = BUNfirst(t);
  oid *idx;
  ptr v;
  int tpe = BATttype(t);

  n = cnt;
  if (*N != wrd_nil && *N >= 0 && *N <= (wrd) BUN_MAX)
          n = (BUN) *N;
  if (do_pqueue_init(H,t,n) == GDK_FAIL)
	  return GDK_FAIL;
  duplicates = BATnew(TYPE_oid, TYPE_oid, n);
  if (duplicates == NULL) {
	  BBPunfix((*H)->batCacheid);
	  return GDK_FAIL;
  }
  hi = bat_iterator(*H);

  idx = (oid*)BUNhead(ti,BUNfirst(t));
  for(i=0, j=0; j < cnt && i<n; j++, idx++, q++) {
	v = BUNtail(ti,q);
	if ((p = BUNfnd(BATmirror(*H), v)) == BUN_NONE) {
		pqueue_enqueue_any@1(*H, idx, v, tpe); 
	        HASHdestroy(*H);
		BUNins(duplicates, idx, idx, FALSE);
		i++;
	} else {
		BUNins(duplicates, Hloc(*H, p), idx, FALSE);
	}
  }
  for(; j<cnt; j++, idx++, q++) {
	v = BUNtail(ti,q);
	if (atom_CMP(BUNtail(hi,BUNfirst(*H)), v, tpe) @2= 0) {
		if ((p = BUNfnd(BATmirror(*H), v)) == BUN_NONE) {
			oid o_idx = *(oid*)Hloc(*H, BUNfirst(*H));
			BUNdelHead(duplicates, &o_idx, TRUE);
			pqueue_topreplace_any@1(*H, idx, v, tpe); 
	        	HASHdestroy(*H);
			BUNins(duplicates, idx, idx, FALSE);
		} else {
			BUNins(duplicates, Hloc(*H, p), idx, FALSE);
		}
	}
  }
  b = heap2bat_any@1(*H);
  BBPunfix((*H)->batCacheid); *H = b;
  b = VIEWcombine(*H);
  BBPunfix((*H)->batCacheid); *H = b;
  b = BATleftjoin(*H, duplicates, BATcount(duplicates));
  BBPunfix((*H)->batCacheid); 
  BBPunfix(duplicates->batCacheid);
  *H = BATmirror(b);
  return GDK_SUCCEED;
}

@c
@:pqueueimpl_any(min,<)@
@:pqueueimpl_any(max,>)@

@-
The M5 wrapper code
@c
str
PQinit(int *ret, int *bid, wrd *maxsize){
	BAT *b,*bn;
	if( (b= BATdescriptor(*bid)) == NULL)
		throw(MAL, "pqueue.init", RUNTIME_OBJECT_MISSING);
	pqueue_init(&bn,b,maxsize);
	BBPreleaseref(b->batCacheid);
	*ret = bn->batCacheid;
	BBPkeepref(bn->batCacheid);
	return MAL_SUCCEED;
}
@-
@= PQimpl1
pqueue_export str PQenqueue_@1@2(int *ret, int *bid, oid *idx, @1 *el);
str
PQenqueue_@1@2(int *ret, int *bid, oid *idx, @1 *el){
	BAT *b;
	if( (b= BATdescriptor(*bid)) == NULL)
		throw(MAL, "pqueue.enqueue", RUNTIME_OBJECT_MISSING);
	pqueue_enqueue_@1@2(b,idx,el);
	(void) ret;
	return MAL_SUCCEED;
}

pqueue_export str PQtopreplace_@1@2(int *ret, int *bid, oid *idx, @1 *el);
str
PQtopreplace_@1@2(int *ret, int *bid, oid *idx, @1 *el){
	BAT *b;
	if( (b= BATdescriptor(*bid)) == NULL)
		throw(MAL, "pqueue.init", RUNTIME_OBJECT_MISSING);
	pqueue_topreplace_@1@2(b,idx,el);
	(void) ret;
	return MAL_SUCCEED;
}

@= PQimpl2
pqueue_export str PQmovedowntop_@1@2(int *ret, int *bid);
str
PQmovedowntop_@1@2(int *ret, int *bid){
	BAT *b;
	if( (b= BATdescriptor(*bid)) == NULL)
		throw(MAL, "pqueue.movedowntop", RUNTIME_OBJECT_MISSING);
	pqueue_movedowntop_@1@2(b);
	(void) ret;
	return MAL_SUCCEED;
}

pqueue_export str PQdequeue_@1@2(int *ret, int *bid);
str
PQdequeue_@1@2(int *ret, int *bid){
	BAT *b;
	if( (b= BATdescriptor(*bid)) == NULL)
		throw(MAL, "pqueue.init", RUNTIME_OBJECT_MISSING);
	if( pqueue_dequeue_@1@2(b) == GDK_FAIL)
		throw(MAL, "pqueue.dequeue",OPERATION_FAILED "Cannot dequeue from empty queue");
	(void) ret;
	return MAL_SUCCEED;
}

pqueue_export str PQtopn_@1@2(int *ret, int *bid, wrd *N);
str
PQtopn_@1@2(int *ret, int *bid, wrd *N){
	BAT *b,*bn = NULL;
	if( (b= BATdescriptor(*bid)) == NULL)
		throw(MAL, "pqueue.topN", RUNTIME_OBJECT_MISSING);
	if ((b->htype == TYPE_void ? pqueue_topn_void@1@2(&bn,b,N) : pqueue_topn_@1@2(&bn,b,N)) == GDK_SUCCEED && bn) {
		*ret= bn->batCacheid;
		BBPkeepref(*ret);
		BBPreleaseref(b->batCacheid);
		return MAL_SUCCEED;
	}
	BBPreleaseref(b->batCacheid);
	throw(MAL, "pqueue.topN", MAL_MALLOC_FAIL);
}
pqueue_export str PQutopn_@1@2(int *ret, int *bid, wrd *N);
str
PQutopn_@1@2(int *ret, int *bid, wrd *N){
	BAT *b,*bn = NULL;
	if( (b= BATdescriptor(*bid)) == NULL)
		throw(MAL, "pqueue.topN", RUNTIME_OBJECT_MISSING);
	if ((b->htype == TYPE_void ? pqueue_utopn_void@1@2(&bn,b,N) : pqueue_utopn_@1@2(&bn,b,N)) == GDK_SUCCEED && bn) {
		*ret= bn->batCacheid;
		BBPkeepref(*ret);
		BBPreleaseref(b->batCacheid);
		return MAL_SUCCEED;
	}
	BBPreleaseref(b->batCacheid);
	throw(MAL, "pqueue.topN", MAL_MALLOC_FAIL);
}
pqueue_export str PQtopn2_@1@2(int *ret, int *aid, int *bid, wrd *N);
str
PQtopn2_@1@2(int *ret, int *aid, int *bid, wrd *N)
{
	BUN n, i,j;
	BAT *a, *b,*bn = NULL;
	if ((a=BATdescriptor(*aid)) == NULL || (b=BATdescriptor(*bid)) == NULL)
		throw(MAL, "pqueue.topN", RUNTIME_OBJECT_MISSING);

	n = BATcount(a);
  	if (*N != wrd_nil && *N >= 0 && *N <= (wrd) BUN_MAX && (BUN) *N < n)
		  n = (BUN) *N;
	bn = BATnew(TYPE_oid, TYPE_oid, n);
	for(i=0; i<n; ) {
		oid ov = * (oid *) Tloc(a, i);
		for (j = i; j < n && * (oid *) Tloc(a, j) == ov; j++)
			;
		if (j == i+1) {
			BUNins(bn, Hloc(a,i), &ov, FALSE);
		} else {
			BAT *s = BATslice(b, i, j), *sbn = NULL;
			wrd nn = n-i;

			if ((b->htype == TYPE_void ? pqueue_topn_void@1@2(&sbn,s,&nn) : pqueue_topn_@1@2(&sbn,s,&nn)) == GDK_SUCCEED && sbn) {
				BATins(bn, sbn, FALSE);
				BBPunfix(sbn->batCacheid);
				BBPunfix(s->batCacheid);
			}
		}
		i = j;
	}
	if (bn) {
		*ret= bn->batCacheid;
		BBPkeepref(*ret);
		BBPreleaseref(b->batCacheid);
		BBPreleaseref(a->batCacheid);
		return MAL_SUCCEED;
	}
	BBPreleaseref(b->batCacheid);
	BBPreleaseref(a->batCacheid);
	throw(MAL, "pqueue.topN", MAL_MALLOC_FAIL);
}

pqueue_export str PQutopn2_@1@2(int *ret, int *aid, int *bid, wrd *N);
str
PQutopn2_@1@2(int *ret, int *aid, int *bid, wrd *N)
{
	BUN n, i,j;
	BAT *a, *b,*bn = NULL;

	if ((a=BATdescriptor(*aid)) == NULL || (b=BATdescriptor(*bid)) == NULL)
		throw(MAL, "pqueue.topN", RUNTIME_OBJECT_MISSING);
	n = BATcount(a);
  	if (*N != wrd_nil && *N >= 0 && *N <= (wrd) BUN_MAX && (BUN) *N < n)
		  n = (BUN) *N;
	bn = BATnew(TYPE_oid, TYPE_oid, n);
	for(i=0; i<n; ) {
		oid ov = * (oid *) Tloc(a, i);
		for (j = i; j < n && * (oid *) Tloc(a, j) == ov; j++)
			;
		if (j == i+1) {
			BUNins(bn, Hloc(a,i), &ov, FALSE);
		} else {
			BAT *s = BATslice(b, i, j), *sbn = NULL;
			wrd nn = n-i;

			if ((b->htype == TYPE_void ? pqueue_utopn_void@1@2(&sbn,s,&nn) : pqueue_utopn_@1@2(&sbn,s,&nn)) == GDK_SUCCEED && sbn) {
				BATins(bn, sbn, FALSE);
				BBPunfix(sbn->batCacheid);
				BBPunfix(s->batCacheid);
			}
		}
		i = j;
	}
	if (bn) {
		*ret= bn->batCacheid;
		BBPkeepref(*ret);
		BBPreleaseref(b->batCacheid);
		BBPreleaseref(a->batCacheid);
		return MAL_SUCCEED;
	}
	BBPreleaseref(b->batCacheid);
	BBPreleaseref(a->batCacheid);
	throw(MAL, "pqueue.utopN", MAL_MALLOC_FAIL);
}
@= PQminmax1
 @:PQimpl1(@1,min)@
 @:PQimpl1(@1,max)@
@= PQminmax2
 @:PQimpl2(@1,min)@
 @:PQimpl2(@1,max)@
@= PQminmax
 	@:PQminmax1(@1)@
 	@:PQminmax2(@1)@
@c
	@:PQminmax(bte)@
	@:PQminmax(chr)@
	@:PQminmax(sht)@
	@:PQminmax(int)@
	@:PQminmax(oid)@
	@:PQminmax(ptr)@
	@:PQminmax(wrd)@
	@:PQminmax(lng)@
	@:PQminmax(flt)@
	@:PQminmax(dbl)@
	@:PQimpl2(any,min)@
	@:PQimpl2(any,max)@

@= PQany
/* int PQenqueue_any@1(BAT *h, oid *idx, ptr el, int tpe)*/
pqueue_export str PQenqueue_any@1(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
str  PQenqueue_any@1(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	int tpe;
	BAT *h;
	oid *idx;
	ptr el;
	(void) cntxt;

	if( p->argc != 4 || 
		getArgType(mb,p,1) != TYPE_bat || 
		getArgType(mb,p,2) != TYPE_oid) 
		throw(MAL, "enqueue_@1", SEMANTIC_TYPE_MISMATCH);
	tpe = getArgType(mb,p,3);

	h = BATdescriptor(*(bat*) getArgReference(stk,p,1));
	if (!h)
		throw(MAL, "enqueue_@1", RUNTIME_OBJECT_MISSING);
	idx = (oid*) getArgReference(stk,p,2);
	el = (ptr) getArgReference(stk,p,3);
		
	pqueue_enqueue_any@1(h, idx, el, tpe);
	return MAL_SUCCEED;
}

/* int pqueue_topreplace_any@1(BAT *h, oid *idx, ptr el, int tpe) */
pqueue_export str PQtopreplace_any@1(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
str  PQtopreplace_any@1(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	int tpe;
	BAT *h;
	oid *idx;
	ptr el;

	(void) cntxt;

	if( p->argc != 4 || 
	    getArgType(mb,p,1) != TYPE_bat || 
	    getArgType(mb,p,2) != TYPE_oid) 
		throw(MAL, "topreplace_@1", SEMANTIC_TYPE_MISMATCH);
	tpe = getArgType(mb,p,3);

	h = BATdescriptor(*(bat*) getArgReference(stk,p,1));
	if (!h)
		throw(MAL, "topreplace_@1", RUNTIME_OBJECT_MISSING);
	idx = (oid*) getArgReference(stk,p,2);
	el = (ptr) getArgReference(stk,p,3);
		
	pqueue_topreplace_any@1(h, idx, el, tpe);
	return MAL_SUCCEED;
}
@c
	@:PQany(min)@
	@:PQany(max)@
@}
