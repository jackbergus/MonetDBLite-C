@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2006 CWI.
@' All Rights Reserved.

@f inspect
@a Martin Kersten
@v 1
@* Inspection at runtime
This module introduces a series of commands that provide access
to information stored within the interpreter data structures.
In all cases, the pseudo BAT operation returns a transient BAT that
should be garbage collected after being used.

The main performance drain would be to use a pseudo BAT directly to
successively access it components. This can be avoided by first assigning
the pseudo BAT to a variable.

@+ Module inspection
Each module forms a separately named scope. Modules visible to a user
are relevant for resolving function names.
Inspection is organized for two purposes, for interactive use
and as a bases for reflective code. The latter needs BATs
to work with. The former merely dumps the result in a table
for the front-ends to consume.
@mal
module inspect;

command getDefinition(mod:str,fcn:str) :bat[:str,:str] 
address INSPECTgetDefinition
comment "Returns a string representation of a specific function";
command getSignature(mod:str,fcn:str) :bat[:str,:str] 
address INSPECTgetSignature
comment "Returns the function signature(s)";
command getAddress(mod:str,fcn:str) :bat[:str,:str] 
address INSPECTgetAddress
comment "Returns the function signature(s)";
command getComment(mod:str,fcn:str) :bat[:str,:str]
address INSPECTgetComment
comment "Returns the function help information.";
command getSource(mod:str,fcn:str):str
address INSPECTgetSource
comment "Return the original input for a function";

@-
The symbol table can be accessed as if it was a relational
table.
The individual attributes should be collected together,
since the underlying implementation assumes that the symbol
table is static
@mal
command getKind():bat[:void,:str]
address INSPECTgetkind
comment "Obtain the instruction kind";
command getModule():bat[:void,:str]
address INSPECTgetAllModules
comment "Obtain the function name";
command getFunction():bat[:void,:str]
address INSPECTgetAllFunctions
comment "Obtain the function name";
command getSignatures():bat[:void,:str]
address INSPECTgetAllSignatures
comment "Obtain the function signatures";
command getAddresses():bat[:void,:str]
address INSPECTgetAllAddresses
comment "Obtain the function address";


pattern getSize():lng
address INSPECTgetSize
comment "Return the storage size for the current function (in bytes)";
command getSize(mod:str):bat[:str,:lng]
address INSPECTgetModuleSize
comment "Return the storage size for a module (in bytes)";
command getSize(mod:str,fcn:str):lng
address INSPECTgetFunctionSize
comment "Return the storage size for a function (in bytes)";

pattern getType(v:bat[:any_1,:any_2]) (ht:str, tt:str)
address INSPECTtypeName
comment "Return the internal type of a variable (expression)";
pattern getType(v:any_1) :str 
address INSPECTtypeName
comment "Return the type of a variable (expression)";

command getTypeName(v:int):str 
address INSPECTtypename;
command getTypeIndex(v:str):int 
address INSPECTtypeIndex;


command getAtomNames():bat[:int,:str] 
address INSPECTatom_names
comment "Collect a BAT with the atom names";
command getAtomSuperNames():bat[:int,:str] 
address INSPECTatom_sup_names
comment "Collect a BAT with the atom names";
command getAtomSizes():bat[:int,:int] 
address INSPECTatom_sizes
comment "Collect a BAT with the atom sizes";

command getEnvironment():bat[:str,:str]
address INSPECTgetEnvironment
comment "Collect the environment variables";
@+ Online help system
All procedural abstractions may contain a string with commentary text.
This information is retained in the symbol table for subsequent use.
It can be extracted into a BAT for inspection, such as providing
an online help facility.
@mal
module manual;

command completion(text:str)
address MANUALcompletion
comment "Produces the wordcompletion table.";
command help(text:str)
address MANUALhelp
comment "Produces the help table for the pattern.";
command search(text:str)
address MANUALsearch
comment "Search the manual for entries matching the keyword";

@- Manual construction
The manual operations ease offline inspection of all function definitions.
It purposely generates an XML organized file, because we expect external
tools to massage it further for presentation. The envisioned 
tagging structure becomes
@-
@mal
command create(file:str,mod:str)
address MANUALcreate2
comment "Generate a synopsis of a module";
command create(file:str,mod:str,recursive:int)
address MANUALcreate
comment "Generate a recursive module synopsis";
command create(mod:str)
address MANUALcreate1
comment "Generate a synopsis of a module";
command create()
address MANUALcreate0
comment "Produces a XML-formatted manual over all modules loaded.";
command createOverview()
address MANUALcreateOverview
comment "Produces an overview of all functions grouped by module.";
command createHelp()
address MANUALcreateHelp
comment "Produces a manual with help lines grouped by module.";
@-
@{
@+ Implementation
@include prelude.mx
@h
#ifdef _INSPECT_H
#endif /* _INSPECT_H */
@c
#include "gdk.h"
#include <stdarg.h>
#include <time.h>
#include "mal_resolve.h"
#include "mal_client.h"
#include "mal_exception.h"
#include "mal_debugger.h"
#include "mal_interpreter.h"
#include "mal_namespace.h"

mal_export str INSPECTgetModuleIds(int *ret);
mal_export str INSPECTsymbolFind(int *ret, int kind);
mal_export str INSPECTfactoryNames(int *ret);
mal_export str INSPECTgetFunctionIds(int *ret);
mal_export str INSPECTpatternNames(int *ret);
mal_export str INSPECTcommandNames(int *ret);
mal_export str INSPECTgetFunction(int *ret);
mal_export str INSPECTgetModule(int *ret);
mal_export str INSPECTgetkind(int *ret);
mal_export str INSPECTgetaddress(int *ret);
mal_export str INSPECTgetAllSignatures(int *ret);
mal_export str INSPECTgetAllAddresses(int *ret);
mal_export str INSPECTgetDefinition(int *ret, str *nme, str *fcn);
mal_export str INSPECTgetSignature(int *ret, str *mod, str *fcn);
mal_export str INSPECTgetAddress(int *ret, str *mod, str *fcn);
mal_export str INSPECTgetComment(int *ret, str *mod, str *fcn);
mal_export str INSPECTgetSource(str *ret, str *mod, str *fcn);
mal_export str INSPECTgetModuleSize(int *ret, str *mod);
mal_export str INSPECTgetFunctionSize(lng *ret, str *mod, str *fcn);
mal_export str INSPECTgetSize(MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
mal_export str INSPECTgetEnvironment(int *ret);
mal_export str INSPECTsymbolType(int *ret, str *mod, str *fcn);
mal_export str INSPECTatom_names(int *ret);
mal_export str INSPECTatom_sup_names(int *ret);
mal_export str INSPECTatom_sizes(int *ret);
mal_export str INSPECTshowFunction(MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
mal_export str INSPECTshowFunction3(MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
mal_export str INSPECTtypename(str *ret, int *tpe);
mal_export str INSPECTtype(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
mal_export str MANUALcreate(int *ret, str *fname, str *mod, int *recursive);
mal_export str MANUALcreate2(int *ret, str *fname, str *mod, int *recursive);
mal_export str MANUALcreate1(int *ret, str *mod);
mal_export str MANUALcreate0(int *ret);
mal_export str MANUALsearch(int *ret, str *mod);
mal_export str MANUALcompletion(int *ret, str *text);
mal_export str MANUALhelp(int *ret, str *text);

@+ Symbol table 
Mal symbol table and environment analysis.
@c

str
INSPECTgetModuleIds(int *ret)
{
	Client c;
	Module s;
	int i = 0;
	BAT *b = BATnew(TYPE_void, TYPE_str, 256);

	if (b == 0)
		return throwMessage("inspect.getModuleIds", "failed to create BAT");
	c = MCgetClient();

	for (s = c->nspace; s; s = s->outer, i++)
		BUNins(b, (ptr) &int_nil, s->name);

	if (!(b->batDirty&2)) b = BATsetaccess(b, BAT_READ);
	@:Pseudo(view,scope,names)@

	return MAL_SUCCEED;
}

str
INSPECTsymbolFind(int *ret, int kind)
{
	Client c;
	Module s;
	Symbol t;
	int i;
	BAT *b = BATnew(TYPE_str, TYPE_str, 256);

	if (b == 0)
		return throwMessage("inspect.symbolFind", "failed to create BAT");
	c = MCgetClient();
	s = c->nspace;
	while (s) {
		for (i = 0; s && i < MAXSCOPE; i++)
			if (s->subscope[i]) {
				for (t = s->subscope[i]; t; t = t->peer) {
					InstrPtr sig = getSignature(t);

					if (kind && kind != sig->token)
						continue;
					BUNins(b, getModuleId(sig), getFunctionId(sig));
				}
			}
		s = s->outer;
	}
	if (!(b->batDirty&2)) b = BATsetaccess(b, BAT_READ);
	@:Pseudo(view,symbol,name)@

	return MAL_SUCCEED;
}

str
INSPECTfactoryNames(int *ret)
{
	return INSPECTsymbolFind(ret, FACTORYsymbol);
}

str
INSPECTgetFunctionIds(int *ret)
{
	return INSPECTsymbolFind(ret, FUNCTIONsymbol);
}

str
INSPECTpatternNames(int *ret)
{
	return INSPECTsymbolFind(ret, PATTERNsymbol);
}

str
INSPECTcommandNames(int *ret)
{
	return INSPECTsymbolFind(ret, COMMANDsymbol);
}

@-
Collect symbol table information in a series of BATs for analysis
and display. Note, the elements are aligned using a counter,
which makes it susceptable for intermediate updates
@c

str
INSPECTgetAllFunctions(int *ret)
{
	Client c;
	Module s;
	Symbol t;
	int i;
	oid k = 0;
	BAT *b = BATnew(TYPE_oid, TYPE_str, 256);

	if (b == 0)
		return throwMessage("inspect.getgetFunctionId", "failed to create BAT");
	BATseqbase(b, k);
	c = MCgetClient();
	s = c->nspace;
	while (s) {
		for (i = 0; s && i < MAXSCOPE; i++)
			if (s->subscope[i]) {
				for (t = s->subscope[i]; t; t = t->peer) {
					InstrPtr sig = getSignature(t);

					BUNins(b, &k, getFunctionId(sig));
					k++;
				}
			}
		s = s->outer;
	}
	if (!(b->batDirty&2)) b = BATsetaccess(b, BAT_READ);
	@:Pseudo(view,symbol,function)@

	return MAL_SUCCEED;
}

str
INSPECTgetAllModules(int *ret)
{
	Client c;
	Module s;
	Symbol t;
	int i;
	oid k = 0;
	BAT *b = BATnew(TYPE_oid, TYPE_str, 256);

	if (b == 0)
		return throwMessage("inspect.getmodule", "failed to create BAT");
	BATseqbase(b, k);
	c = MCgetClient();
	s = c->nspace;
	while (s) {
		for (i = 0; s && i < MAXSCOPE; i++)
			if (s->subscope[i]) {
				for (t = s->subscope[i]; t; t = t->peer) {
					InstrPtr sig = getSignature(t);

					BUNins(b, &k, getModuleId(sig));
					k++;
				}
			}
		s = s->outer;
	}
	if (!(b->batDirty&2)) b = BATsetaccess(b, BAT_READ);
	@:Pseudo(view,symbol,module)@

	return MAL_SUCCEED;
}

str
INSPECTgetkind(int *ret)
{
	Client c;
	Module s;
	Symbol t;
	int i;
	oid k = 0;
	BAT *b = BATnew(TYPE_oid, TYPE_str, 256);

	if (b == 0)
		return throwMessage("inspect.get@1", "failed to create BAT");
	BATseqbase(b, k);
	c = MCgetClient();
	s = c->nspace;
	while (s) {
		for (i = 0; s && i < MAXSCOPE; i++)
			if (s->subscope[i]) {
				for (t = s->subscope[i]; t; t = t->peer) {
					InstrPtr sig = getSignature(t);
					str kind = operatorName(sig->token);

					BUNins(b, &k, kind);
					k++;
				}
			}
		s = s->outer;
	}
	if (!(b->batDirty&2)) b = BATsetaccess(b, BAT_READ);
	@:Pseudo(view,symbol,kind)@

	return MAL_SUCCEED;
}

str
INSPECTgetaddress(int *ret)
{
	Client c;
	Module s;
	Symbol t;
	int i;
	oid k = 0;
	BAT *b = BATnew(TYPE_oid, TYPE_str, 256);

	if (b == 0)
		return throwMessage("inspect.get@1", "failed to create BAT");
	BATseqbase(b, k);
	c = MCgetClient();
	s = c->nspace;
	while (s) {
		for (i = 0; s && i < MAXSCOPE; i++)
			if (s->subscope[i]) {
				for (t = s->subscope[i]; t; t = t->peer) {
					str kind = t->def->binding;

					if (kind == 0)
						kind = "";
					BUNins(b, &k, &kind);
					k++;
				}
			}
		s = s->outer;
	}
	if (!(b->batDirty&2)) b = BATsetaccess(b, BAT_READ);
	@:Pseudo(view,symbol, address)@

	return MAL_SUCCEED;
}


str
INSPECTgetAllSignatures(int *ret)
{
	Client c;
	Module s;
	Symbol t;
	int i;
	oid k = 0;
	BAT *b = BATnew(TYPE_oid, TYPE_str, 256);
	char sig[4096],*a;

	if (b == 0)
		return throwMessage("inspect.get@1", "failed to create BAT");
	BATseqbase(b, k);
	c = MCgetClient();
	s = c->nspace;
	while (s) {
		for (i = 0; s && i < MAXSCOPE; i++)
			if (s->subscope[i]) {
				for (t = s->subscope[i]; t; t = t->peer) {
					fcnDefinition(t->def, getSignature(t), sig, 0);
					a= strstr(sig,"address");
					if(a) *a = 0;
					BUNins(b, &k, strchr(sig, '('));
					k++;
				}
			}
		s = s->outer;
	}
	if (!(b->batDirty&2)) b = BATsetaccess(b, BAT_READ);
	@:Pseudo(view, symbol,address)@

	return MAL_SUCCEED;
}
str
INSPECTgetAllAddresses(int *ret)
{
	Client c;
	Module s;
	Symbol t;
	int i;
	oid k = 0;
	BAT *b = BATnew(TYPE_oid, TYPE_str, 256);
	char sig[4096],*a;

	if (b == 0)
		return throwMessage("inspect.get@1", "failed to create BAT");
	BATseqbase(b, k);
	c = MCgetClient();
	s = c->nspace;
	while (s) {
		for (i = 0; s && i < MAXSCOPE; i++)
			if (s->subscope[i]) {
				for (t = s->subscope[i]; t; t = t->peer) {
					fcnDefinition(t->def, getSignature(t), sig, 0);
					a= strstr(sig,"address");
					if( a)
						for( a=a+7; isspace((int) *a); a++)
							;
					BUNins(b, &k, (a? a: "nil"));
					k++;
				}
			}
		s = s->outer;
	}
	if (!(b->batDirty&2)) b = BATsetaccess(b, BAT_READ);
	@:Pseudo(view, symbol,address)@

	return MAL_SUCCEED;
}

str
INSPECTgetDefinition(int *ret, str *mod, str *fcn)
{
	Symbol s;
	char buf[BUFSIZ];
	BAT *b = BATnew(TYPE_str, TYPE_str, 256);

	if (b == 0)
		return throwMessage("inspect.getDefinition", "failed to create BAT");

	snprintf(buf,BUFSIZ,"%s.%s",*mod,*fcn);
	s = findMALSymbol(putName(*mod, strlen(*mod)), putName(*fcn, strlen(*fcn)));
	while (s) {
		int i;
		str ps;

		for (i = 0; i < s->def->stop; i++) {
			ps = instruction2str(s->def, getInstrPtr(s->def, i), 0);
			BUNins(b, buf, ps + 1);
			GDKfree(ps);
		}
		s = s->peer;
	}
	if (!(b->batDirty&2)) b = BATsetaccess(b, BAT_READ);
	@:Pseudo(view,fcn,stmt)@

	return MAL_SUCCEED;
}

str
INSPECTgetSignature(int *ret, str *mod, str *fcn)
{
	Symbol s;
	char buf[BUFSIZ];
	str ps, tail;
	BAT *b = BATnew(TYPE_str, TYPE_str, 12);

	if (b == 0)
		return throwMessage("inspect.getSignature", "failed to create BAT");

	s = findMALSymbol(putName(*mod, strlen(*mod)), putName(*fcn, strlen(*fcn)));
	if (s == 0)
		return throwMessage("inspect.getSignature", "failed to find <module>.<function>");

	snprintf(buf,BUFSIZ,"%s.%s",*mod,*fcn);
	while (s != NULL) {
		if (idcmp(s->name, *fcn) == 0) {
			char *c;

			ps = instruction2str(s->def, getSignature(s), 0);
			c = strchr(ps, '(');
			if (c == 0)
				continue;
			tail= strstr(c,"address");
			if( tail)
				*tail = 0;
			if (tail && strchr(tail, ';'))
				*strchr(tail, ';') = 0;
			BUNins(b, buf, c);
			GDKfree(ps);
		}
		s = s->peer;
	}

	if (!(b->batDirty&2)) b = BATsetaccess(b, BAT_READ);
	@:Pseudo(view,input,result)@
	return MAL_SUCCEED;
}
str
INSPECTgetAddress(int *ret, str *mod, str *fcn)
{
	Symbol s;
	char buf[BUFSIZ];
	str ps, tail;
	BAT *b = BATnew(TYPE_str, TYPE_str, 12);

	if (b == 0)
		return throwMessage("inspect.getAddress", "failed to create BAT");

	s = findMALSymbol(putName(*mod, strlen(*mod)), putName(*fcn, strlen(*fcn)));
	if (s == 0)
		return throwMessage("inspect.getAddress", "failed to find <module>.<function>");

	snprintf(buf,BUFSIZ,"%s.%s",*mod,*fcn);
	while (s != NULL) {
		if (idcmp(s->name, *fcn) == 0) {
			char *c;

			ps = instruction2str(s->def, getSignature(s), 0);
			c = strchr(ps, '(');
			if (c == 0)
				continue;
			tail= strstr(c,"address");
			if( tail){
				*tail = 0;
				for( tail=tail+7; isspace((int) *tail); tail++)  ;
			}
			if (tail && strchr(tail, ';'))
				*strchr(tail, ';') = 0;
			BUNins(b, buf, (tail? tail: "nil"));
			GDKfree(ps);
		}
		s = s->peer;
	}

	if (!(b->batDirty&2)) b = BATsetaccess(b, BAT_READ);
	@:Pseudo(view,input,result)@
	return MAL_SUCCEED;
}
str
INSPECTgetComment(int *ret, str *mod, str *fcn)
{
	Symbol s;
	char buf[BUFSIZ];
	BAT *b = BATnew(TYPE_str, TYPE_str, 12);

	if (b == 0)
		return throwMessage("inspect.getSignature", "failed to create BAT");

	s = findMALSymbol(putName(*mod, strlen(*mod)), putName(*fcn, strlen(*fcn)));
	if (s == 0)
		return throwMessage("inspect.getSignature", "failed to find <module>.<function>");

	snprintf(buf,BUFSIZ,"%s.%s",*mod,*fcn);
	while (s != NULL) {
		if (idcmp(s->name, *fcn) == 0) {
			BUNins(b, buf, s->def->help);
		}
		s = s->peer;
	}

	if (!(b->batDirty&2)) b = BATsetaccess(b, BAT_READ);
	@:Pseudo(view,input,result)@
	return MAL_SUCCEED;
}
str
INSPECTgetSource(str *ret, str *mod, str *fcn)
{
	Symbol s;
	char *buf;
	int len,lim;

	s = findMALSymbol(putName(*mod, strlen(*mod)), putName(*fcn, strlen(*fcn)));
	if (s == 0)
		return throwMessage("inspect.getSignature", 
			"Failed to find <module>.<function>");

	buf= (char*) GDKmalloc(BUFSIZ);
	snprintf(buf,BUFSIZ,"%s.%s",*mod,*fcn);
	s = findMALSymbol(putName(*mod, strlen(*mod)), putName(*fcn, strlen(*fcn)));
	buf[0]=0;
	len= 0;
	lim= BUFSIZ;

	while (s) {
		int i;
		str ps;

		for (i = 0; i < s->def->stop; i++) {
			ps = instruction2str(s->def, getInstrPtr(s->def, i), 0);
			if( strlen(ps) >= lim-len){
				/* expand the buffer */
				char *bn;
				bn= GDKmalloc(lim+BUFSIZ);
				strcpy(bn,buf);
				GDKfree(buf);
				buf=bn;
				lim+= BUFSIZ;
			}
			strcat(buf+len,ps+1);
			len+= strlen(ps)-1;
			buf[len++]='\n';
			buf[len]=0;
			GDKfree(ps);
		}
		s = s->peer;
	}
	*ret= buf;
	return MAL_SUCCEED;
}

str
INSPECTsymbolType(int *ret, str *mod, str *fcn)
{
	Symbol s;
	BAT *b = BATnew(TYPE_str, TYPE_str, 256);

	if (b == 0)
		return throwMessage("inspect.getType", "failed to create BAT");

	s = findMALSymbol(*mod, *fcn);
	if (s == 0)
		return throwMessage("inspect.getSignature", "failed to find <module>.<function>");
	while (s != NULL) {
		if (idcmp(s->name, *fcn) == 0) {
			str t = getTypeName(getDestType(s->def, getSignature(s)));

			BUNins(b, s->name, t);
			GDKfree(t);
		}
		s = s->peer;
	}
	if (!(b->batDirty&2)) b = BATsetaccess(b, BAT_READ);
	@:Pseudo(view,fcn,type)@
	return MAL_SUCCEED;
}

str
INSPECTatom_names(int *ret)
{
	int i;
	BAT *b = BATnew(TYPE_int, TYPE_str, 256);

	if (b == 0)
		return throwMessage("inspect.getAtomNames", "failed to create BAT");

	for (i = 0; i < GDKatomcnt; i++)
		BUNins(b, &i, ATOMname(i));

	if (!(b->batDirty&2)) b = BATsetaccess(b, BAT_READ);
	@:Pseudo(view,atom,name)@

	return MAL_SUCCEED;
}
str
INSPECTgetEnvironment(int *ret)
{
	BAT *b;

	b= BATcopy(GDKenv);
	if (b == 0)
		return throwMessage("inspect.getEnvironment", "failed to create BAT");


	@:Pseudo(view,env,name)@

	return MAL_SUCCEED;
}

str
INSPECTatom_sup_names(int *ret)
{
	int i, k;
	BAT *b = BATnew(TYPE_int, TYPE_str, 256);

	if (b == 0)
		return throwMessage("inspect.getAtomSuperNames", "failed to create BAT");

	for (i = 0; i < GDKatomcnt; i++) {
		for (k = BATatoms[i].storage; k > TYPE_str; k = BATatoms[k].storage)
			;
		BUNins(b, &i, ATOMname(k));
	}

	if (!(b->batDirty&2)) b = BATsetaccess(b, BAT_READ);
	@:Pseudo(view,atom,sup_name)@

	return MAL_SUCCEED;
}

str
INSPECTatom_sizes(int *ret)
{
	int i;
	size_t s;
	BAT *b = BATnew(TYPE_int, TYPE_int, 256);

	if (b == 0)
		return throwMessage("inspect.getAtomSizes", "failed to create BAT");

	for (i = 0; i < GDKatomcnt; i++) {
		s = ATOMsize(i);
		BUNins(b, &i, &s);
	}

	if (!(b->batDirty&2)) b = BATsetaccess(b, BAT_READ);
	@:Pseudo(view,atom,size)@

	return MAL_SUCCEED;
}

/* calculate to trimmed storage space */
lng
INSPECTcalcSize(MalBlkPtr mb){
	lng size,args=0,i;
	InstrPtr p;

	for(i=0;i<mb->stop; i++){
		p= getInstrPtr(mb,i);
		args += (p->argc-1)* sizeof(*p->argv);
	}
	size = (sizeof(InstrRecord) +sizeof(InstrPtr)) * mb->stop;
	size += (sizeof(VarRecord)+ sizeof(InstrPtr)) * mb->vtop;
	size += args;
	return size;
}

str
INSPECTgetSize(MalBlkPtr mb, MalStkPtr stk, InstrPtr p){
	lng *ret = (lng*) getArgReference(stk,p,0);
	*ret= INSPECTcalcSize(mb);
	return MAL_SUCCEED;
}
str
INSPECTgetModuleSize(int *ret, str *mod)
{
	Symbol s;
	Module m;
	int i;
	lng total=0;
	BAT *b = BATnew(TYPE_str, TYPE_lng, 256);

	if (b == 0)
		return throwMessage("inspect.getSize", "failed to create BAT");

	m = findModule(MCgetClient()->nspace, putName(*mod, strlen(*mod)));
	if (m == 0)
		return throwMessage("inspect.getSize", 
				"failed to find <module>.<function>");

	for( i=0; i<MAXSCOPE; i++){
		s= m->subscope[i];
		while (s != NULL) {
			lng size;
			total+= (size = INSPECTcalcSize(s->def));
			BUNins(b, s->name, &size);
			s = s->peer;
		}
	}
	BUNins(b, *mod, &total);

	if (!(b->batDirty&2)) b = BATsetaccess(b, BAT_READ);
	@:Pseudo(view,input,result)@
	return MAL_SUCCEED;
}
str
INSPECTgetFunctionSize(lng *ret, str *mod, str *fcn)
{
	Symbol s;

	s = findMALSymbol(putName(*mod, strlen(*mod)), putName(*fcn, strlen(*fcn)));
	if (s == 0)
		return throwMessage("inspect.getSize", 
			"failed to find <module>.<function>");
	*ret= INSPECTcalcSize(s->def);
	return MAL_SUCCEED;
}
@+ Display routines
@c
str
INSPECTshowFunction(MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	Client c = MCgetClient();

	(void) p;
	(void) stk;
	printFunction(c->fdout, mb, LIST_INPUT);
	return MAL_SUCCEED;
}

str
INSPECTshowFunction3(MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	str modnme = getArgName(mb, p, 1);
	str fcnnme = getArgName(mb, p, 2);
	Module scope = NULL;
	Symbol s = NULL;
	Client c = MCgetClient();

	scope = findModule(c->nspace, modnme);

	if (scope)
		s = findSymbolInModule(scope, putName(fcnnme, strlen(fcnnme)));

	if (s == NULL){
		char buf[BUFSIZ];
		snprintf(buf,BUFSIZ,"Could not find %s.%s\n", modnme, fcnnme);
		return throwMessage("inspect.showSource",buf);
	} else
		printFunction(c->fdout, s->def, LIST_INPUT);
	(void) stk;		/* fool compiler */
	return MAL_SUCCEED;
}

str
INSPECTtypename(str *ret, int *tpe)
{
	*ret = getTypeName(*tpe);
	return MAL_SUCCEED;
}
str
INSPECTtypeIndex(int *ret, str *tpe)
{
	*ret = getTypeIndex(*tpe, strlen(*tpe), TYPE_any);
	return MAL_SUCCEED;
}

str
INSPECTtypeName(MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	str *hn, *tn =0;

	hn = (str *) getArgReference(stk, pci, 0);
	if( pci->retc== 2){
		tn = (str *) getArgReference(stk, pci, 1);
		*hn = getTypeName(getHeadType(getArgType(mb, pci, 2)));
		*tn = getTypeName(getTailType(getArgType(mb, pci, 2)));
	} else
		*hn = getTypeName(getArgType(mb, pci, 1));
	return MAL_SUCCEED;
}

str
MANUALcreate(int *ret, str *fname, str *mod, int *recursive)
{
	stream *fs;

	(void) ret;		/* fool compiler */
	fs = open_wastream(*fname);
	if (fs == NULL)
		return throwMessage("manual.create", "Could not open file\n");
	dumpManualHeader(fs);
	dumpManual(fs, findModule(MCgetClient()->nspace, *mod), *recursive);
	dumpManualFooter(fs);
	return MAL_SUCCEED;
}

str
MANUALcreate2(int *ret, str *fname, str *mod, int *recursive)
{
	int r = 0;

	(void) recursive;	/* fool compiler */
	return MANUALcreate(ret, fname, mod, &r);
}

str
MANUALcreate1(int *ret, str *mod)
{
	(void) ret;		/* fool compiler */
	dumpManualHeader(GDKout);
	dumpManual(GDKout, findModule(MCgetClient()->nspace, *mod), 0);
	dumpManualFooter(GDKout);
	return MAL_SUCCEED;
}

str
MANUALcreate0(int *ret)
{
	(void) ret;		/* fool compiler */
	dumpManualHeader(GDKout);
	dumpManual(GDKout, MCgetClient()->nspace, 1);
	dumpManualFooter(GDKout);
	return MAL_SUCCEED;
}
str
MANUALcreateOverview(int *ret)
{
	(void) ret;		/* fool compiler */
	dumpManualOverview(GDKout, MCgetClient()->nspace, 1);
	return MAL_SUCCEED;
}
str
MANUALcreateHelp(int *ret)
{
	(void) ret;		/* fool compiler */
	dumpManualHelp(GDKout, MCgetClient()->nspace, 1);
	return MAL_SUCCEED;
}
str
MANUALcreateTags(int *ret)
{
	(void) ret;		/* fool compiler */
	dumpHelpTable(GDKout, MCgetClient()->nspace, 0,0);
	return MAL_SUCCEED;
}

str
MANUALcompletion(int *ret, str *text)
{
	(void) ret;		/* fool compiler */
	dumpHelpTable(GDKout, MCgetClient()->nspace, *text,1);
	return MAL_SUCCEED;
}

str
MANUALhelp(int *ret, str *text)
{
	char **msg;
	int i;

	(void) ret;		/* fool compiler */
	msg= getHelp(MCgetClient()->nspace,*text,1);
	if( msg && msg[0] ){
		for(i=0; msg[i];i++){
			mal_unquote(msg[i]);
			stream_printf(GDKout,"%s\n",msg[i]);
			GDKfree(msg[i]);
		}
	}
	if( msg) 
		GDKfree(msg);
	return MAL_SUCCEED;
}

str
MANUALsearch(int *ret, str *pat)
{
	char **msg;
	int i;
	(void) ret;
	msg= getHelpMatch(*pat);
	if( msg && msg[0] ){
		for(i=0; msg[i];i++){
			mal_unquote(msg[i]);
			stream_printf(GDKout,"%s\n",msg[i]+1);
			GDKfree(msg[i]);
		}
	}
	if( msg) 
		GDKfree(msg);
	return MAL_SUCCEED;
}

@}
