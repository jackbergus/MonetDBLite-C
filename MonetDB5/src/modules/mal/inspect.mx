@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
@' Copyright August 2008- MonetDB B.V.
@' All Rights Reserved.

@f inspect
@a Martin Kersten
@v 1
@+ Inspection 
This module introduces a series of commands that provide access
to information stored within the interpreter data structures.
It's primary use is debugging.
In all cases, the pseudo BAT operation is returned that
should be garbage collected after being used.

The main performance drain would be to use a pseudo BAT directly to
successively access it components. This can be avoided by first assigning
the pseudo BAT to a variable.

@mal
module inspect;

command getDefinition(mod:str,fcn:str) :bat[:str,:str] 
address INSPECTgetDefinition
comment "Returns a string representation of a specific function.";
command getSignature(mod:str,fcn:str) :bat[:str,:str] 
address INSPECTgetSignature
comment "Returns the function signature(s).";
command getAddress(mod:str,fcn:str) :bat[:str,:str] 
address INSPECTgetAddress
comment "Returns the function signature(s).";
command getComment(mod:str,fcn:str) :bat[:str,:str]
address INSPECTgetComment
comment "Returns the function help information.";
command getSource(mod:str,fcn:str):str
address INSPECTgetSource
comment "Return the original input for a function.";

pattern getKind():bat[:oid,:str]
address INSPECTgetkind
comment "Obtain the instruction kind.";
pattern getModule():bat[:oid,:str]
address INSPECTgetAllModules
comment "Obtain the function name.";
pattern getFunction():bat[:oid,:str]
address INSPECTgetAllFunctions
comment "Obtain the function name.";
pattern getSignatures():bat[:oid,:str]
address INSPECTgetAllSignatures
comment "Obtain the function signatures.";
pattern getAddresses():bat[:oid,:str]
address INSPECTgetAllAddresses
comment "Obtain the function address.";


pattern getSize():lng
address INSPECTgetSize
comment "Return the storage size for the current function (in bytes).";
pattern getSize(mod:str):bat[:str,:lng]
address INSPECTgetModuleSize
comment "Return the storage size for a module (in bytes).";
command getSize(mod:str,fcn:str):lng
address INSPECTgetFunctionSize
comment "Return the storage size for a function (in bytes).";

pattern getType(v:bat[:any_1,:any_2]) (ht:str, tt:str)
address INSPECTtypeName
comment "Return the internal type of a variable (expression).";
pattern getType(v:any_1) :str 
address INSPECTtypeName
comment "Return the type of a variable (expression).";

command getTypeName(v:int):str 
address INSPECTtypename
comment "Get the type name associated with a type id.";
pattern getTypeIndex(v:bat[:any_1,:any_2]) (ht:int, tt:int)
address INSPECTtypeIndex
comment "Return the type index of a BAT head and tail.";
pattern getTypeIndex(v:any_1):int 
address INSPECTtypeIndex
comment "Return the type index of a variable. For BATs, return
the type index for its tail.";

pattern equalType(l:any, r:any):bit
address INSPECTequalType
comment "Return true if both operands are of the same type";
command getAtomNames():bat[:int,:str] 
address INSPECTatom_names
comment "Collect a BAT with the atom names.";
command getAtomSuper():bat[:int,:str] 
address INSPECTatom_sup_names
comment "Collect a BAT with the atom names.";
command getAtomSizes():bat[:int,:int] 
address INSPECTatom_sizes
comment "Collect a BAT with the atom sizes.";

command getEnvironment():bat[:str,:str]
address INSPECTgetEnvironment
comment "Collect the environment variables.";
@-
@{
@+ Implementation
@include prelude.mx
@h
#ifdef _INSPECT_H
#endif /* _INSPECT_H */
@c
#include "mal_config.h"
#include "gdk.h"
#include <stdarg.h>
#include <time.h>
#include "mal_resolve.h"
#include "mal_client.h"
#include "mal_exception.h"
#include "mal_debugger.h"
#include "mal_interpreter.h"
#include "mal_namespace.h"

#ifdef WIN32
#ifndef LIBINSPECT
#define inspect_export extern __declspec(dllimport)
#else
#define inspect_export extern __declspec(dllexport)
#endif
#else
#define inspect_export extern
#endif

inspect_export str INSPECTgetFunction(int *ret);
inspect_export str INSPECTgetModule(int *ret);
inspect_export str INSPECTgetkind(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
inspect_export str INSPECTgetAllSignatures(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
inspect_export str INSPECTgetAllModules(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
inspect_export str INSPECTgetAllFunctions(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
inspect_export str INSPECTgetAllAddresses(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
inspect_export str INSPECTgetDefinition(int *ret, str *nme, str *fcn);
inspect_export str INSPECTgetSignature(int *ret, str *mod, str *fcn);
inspect_export str INSPECTgetAddress(int *ret, str *mod, str *fcn);
inspect_export str INSPECTgetComment(int *ret, str *mod, str *fcn);
inspect_export str INSPECTgetSource(str *ret, str *mod, str *fcn);
inspect_export str INSPECTgetModuleSize(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
inspect_export str INSPECTgetFunctionSize(lng *ret, str *mod, str *fcn);
inspect_export str INSPECTgetSize(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
inspect_export str INSPECTgetEnvironment(int *ret);
inspect_export str INSPECTsymbolType(int *ret, str *mod, str *fcn);
inspect_export str INSPECTatom_names(int *ret);
inspect_export str INSPECTatom_sup_names(int *ret);
inspect_export str INSPECTatom_sizes(int *ret);
inspect_export str INSPECTshowFunction(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
inspect_export str INSPECTshowFunction3(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p);
inspect_export str INSPECTtypename(str *ret, int *tpe);
inspect_export str INSPECTtype(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
inspect_export str INSPECTtypeName(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
inspect_export str INSPECTtypeIndex(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);
inspect_export str INSPECTequalType(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci);

@+ Symbol table 
Mal symbol table and environment analysis.

Collect symbol table information in a series of BATs for analysis
and display. Note, the elements are aligned using a counter,
which makes it susceptable for intermediate updates
@c

str
INSPECTgetAllFunctions(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	Module s;
	Symbol t;
	int i;
	oid k = 0;
	BAT *b = BATnew(TYPE_oid, TYPE_str, 256);
	int *ret = (int *) getArgReference(stk,pci,0);

	(void) mb;
	if (b == 0)
		throw(MAL, "inspect.getgetFunctionId", "failed to create BAT");
	BATseqbase(b, k);
	s = cntxt->nspace;
	while (s) {
		for (i = 0; s && i < MAXSCOPE; i++)
			if (s->subscope[i]) {
				for (t = s->subscope[i]; t; t = t->peer) {
					InstrPtr sig = getSignature(t);

					BUNins(b, &k, getFunctionId(sig), FALSE);
					k++;
				}
			}
		s = s->outer;
	}
	if (!(b->batDirty&2)) b = BATsetaccess(b, BAT_READ);
	@:Pseudo(view,symbol,function)@

	return MAL_SUCCEED;
}

str
INSPECTgetAllModules(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	Module s;
	Symbol t;
	int i;
	oid k = 0;
	BAT *b = BATnew(TYPE_oid, TYPE_str, 256);
	int *ret = (int *) getArgReference(stk,pci,0);

	(void) mb;
	if (b == 0)
		throw(MAL, "inspect.getmodule", "failed to create BAT");
	BATseqbase(b, k);
	s = cntxt->nspace;
	while (s) {
		for (i = 0; s && i < MAXSCOPE; i++)
			if (s->subscope[i]) {
				for (t = s->subscope[i]; t; t = t->peer) {
					InstrPtr sig = getSignature(t);

					BUNins(b, &k, getModuleId(sig), FALSE);
					k++;
				}
			}
		s = s->outer;
	}
	if (!(b->batDirty&2)) b = BATsetaccess(b, BAT_READ);
	@:Pseudo(view,symbol,module)@

	return MAL_SUCCEED;
}

str
INSPECTgetkind(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	Module s;
	Symbol t;
	int i;
	oid k = 0;
	BAT *b = BATnew(TYPE_oid, TYPE_str, 256);
	int *ret = (int *) getArgReference(stk,pci,0);

	(void)mb;
	if (b == 0)
		throw(MAL, "inspect.get@1", "failed to create BAT");
	BATseqbase(b, k);
	s = cntxt->nspace;
	while (s) {
		for (i = 0; s && i < MAXSCOPE; i++)
			if (s->subscope[i]) {
				for (t = s->subscope[i]; t; t = t->peer) {
					InstrPtr sig = getSignature(t);
					str kind = operatorName(sig->token);

					BUNins(b, &k, kind, FALSE);
					k++;
				}
			}
		s = s->outer;
	}
	if (!(b->batDirty&2)) b = BATsetaccess(b, BAT_READ);
	@:Pseudo(view,symbol,kind)@

	return MAL_SUCCEED;
}


str
INSPECTgetAllSignatures(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	Module s;
	Symbol t;
	int i;
	oid k = 0;
	BAT *b = BATnew(TYPE_oid, TYPE_str, 256);
	char sig[BLOCK],*a;
	int *ret = (int *) getArgReference(stk,pci,0);

	(void)mb;

	if (b == 0)
		throw(MAL, "inspect.get@1", "failed to create BAT");
	BATseqbase(b, k);
	s = cntxt->nspace;
	while (s) {
		for (i = 0; s && i < MAXSCOPE; i++)
			if (s->subscope[i]) {
				for (t = s->subscope[i]; t; t = t->peer) {
					fcnDefinition(t->def, getSignature(t), sig, 0,sig,BLOCK);
					a= strstr(sig,"address");
					if(a) *a = 0;
					BUNins(b, &k, strchr(sig, '('), FALSE);
					k++;
				}
			}
		s = s->outer;
	}
	if (!(b->batDirty&2)) b = BATsetaccess(b, BAT_READ);
	@:Pseudo(view, symbol,address)@

	return MAL_SUCCEED;
}
str
INSPECTgetAllAddresses(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	Module s;
	Symbol t;
	int i;
	oid k = 0;
	BAT *b = BATnew(TYPE_oid, TYPE_str, 256);
	char sig[BLOCK],*a;
	int *ret = (int *) getArgReference(stk,pci,0);

	(void)mb;

	if (b == 0)
		throw(MAL, "inspect.get@1", "failed to create BAT");
	BATseqbase(b, k);
	s = cntxt->nspace;
	while (s) {
		for (i = 0; s && i < MAXSCOPE; i++)
			if (s->subscope[i]) {
				for (t = s->subscope[i]; t; t = t->peer) {
					fcnDefinition(t->def, getSignature(t), sig, 0,sig,BLOCK);
					a= strstr(sig,"address");
					if( a)
						for( a=a+7; isspace((int) *a); a++)
							;
					BUNins(b, &k, (a? a: "nil"), FALSE);
					k++;
				}
			}
		s = s->outer;
	}
	if (!(b->batDirty&2)) b = BATsetaccess(b, BAT_READ);
	@:Pseudo(view, symbol,address)@

	return MAL_SUCCEED;
}

str
INSPECTgetDefinition(int *ret, str *mod, str *fcn)
{
	Symbol s;
	char buf[BUFSIZ];
	BAT *b;

	s = findSymbol(getName(*mod,strlen(*mod)), putName(*fcn, strlen(*fcn)));
	if (s == 0)
		throw(MAL, "inspect.getDefinition", 
				"failed to find <module>.<function>");

	b = BATnew(TYPE_str, TYPE_str, 256);
	if (b == 0)
		throw(MAL, "inspect.getDefinition", "failed to create BAT");

	snprintf(buf,BUFSIZ,"%s.%s",*mod,*fcn);
	while (s) {
		int i;
		str ps;

		for (i = 0; i < s->def->stop; i++) {
			ps = instruction2str(s->def,0, getInstrPtr(s->def, i), 0);
			BUNins(b, buf, ps + 1, FALSE);
			GDKfree(ps);
		}
		s = s->peer;
	}
	if (!(b->batDirty&2)) b = BATsetaccess(b, BAT_READ);
	@:Pseudo(view,fcn,stmt)@

	return MAL_SUCCEED;
}

str
INSPECTgetSignature(int *ret, str *mod, str *fcn)
{
	Symbol s;
	char buf[BUFSIZ];
	str ps, tail;
	BAT *b;

	s = findSymbol(getName(*mod,strlen(*mod)), putName(*fcn, strlen(*fcn)));
	if (s == 0)
		throw(MAL, "inspect.getSignature", 
				"failed to find <module>.<function>");
	b = BATnew(TYPE_str, TYPE_str, 12);
	if (b == 0)
		throw(MAL, "inspect.getSignature", "failed to create BAT");

	snprintf(buf,BUFSIZ,"%s.%s",*mod,*fcn);
	while (s != NULL) {
		if (idcmp(s->name, *fcn) == 0) {
			char *c, *w;

			ps = instruction2str(s->def, 0, getSignature(s), 0);
			c = strchr(ps, '(');
			if (c == 0)
				continue;
			tail= strstr(c,"address");
			if( tail)
				*tail = 0;
			if (tail && (w=strchr(tail, ';')) )
				*w = 0;
			BUNins(b, buf, c, FALSE);
			GDKfree(ps);
		}
		s = s->peer;
	}

	if (!(b->batDirty&2)) b = BATsetaccess(b, BAT_READ);
	@:Pseudo(view,input,result)@
	return MAL_SUCCEED;
}
str
INSPECTgetAddress(int *ret, str *mod, str *fcn)
{
	Symbol s;
	char buf[BUFSIZ];
	str ps, tail;
	BAT *b;

	s = findSymbol( getName(*mod,strlen(*mod)), putName(*fcn, strlen(*fcn)));
	if (s == 0)
		throw(MAL, "inspect.getAddress", "failed to find <module>.<function>");
	b = BATnew(TYPE_str, TYPE_str, 12);
	if (b == 0)
		throw(MAL, "inspect.getAddress", "failed to create BAT");

	snprintf(buf,BUFSIZ,"%s.%s",*mod,*fcn);
	while (s != NULL) {
		if (idcmp(s->name, *fcn) == 0) {
			char *c,*w;

			ps = instruction2str(s->def, 0, getSignature(s), 0);
			c = strchr(ps, '(');
			if (c == 0)
				continue;
			tail= strstr(c,"address");
			if( tail){
				*tail = 0;
				for( tail=tail+7; isspace((int) *tail); tail++)  ;
			}
			if (tail && (w=strchr(tail, ';')) )
				*w = 0;
			BUNins(b, buf, (tail? tail: "nil"), FALSE);
			GDKfree(ps);
		}
		s = s->peer;
	}

	if (!(b->batDirty&2)) b = BATsetaccess(b, BAT_READ);
	@:Pseudo(view,input,result)@
	return MAL_SUCCEED;
}
str
INSPECTgetComment(int *ret, str *mod, str *fcn)
{
	Symbol s;
	char buf[BUFSIZ];
	BAT *b;

	s = findSymbol( getName(*mod,strlen(*mod)), putName(*fcn, strlen(*fcn)));
	if (s == 0)
		throw(MAL, "inspect.getComment", "failed to find <module>.<function>");
	b = BATnew(TYPE_str, TYPE_str, 12);
	if (b == 0)
		throw(MAL, "inspect.getSignature", "failed to create BAT");

	snprintf(buf,BUFSIZ,"%s.%s",*mod,*fcn);
	while (s != NULL) {
		if (idcmp(s->name, *fcn) == 0) {
			BUNins(b, buf, s->def->help, FALSE);
		}
		s = s->peer;
	}

	if (!(b->batDirty&2)) b = BATsetaccess(b, BAT_READ);
	@:Pseudo(view,input,result)@
	return MAL_SUCCEED;
}
str
INSPECTgetSource(str *ret, str *mod, str *fcn)
{
	Symbol s;
	char *buf;
	size_t len,lim;

	s = findSymbol( getName(*mod,strlen(*mod)), putName(*fcn, strlen(*fcn)));
	if (s == 0)
		throw(MAL, "inspect.getSource", 
			"Failed to find <module>.<function>");

	buf= (char*) GDKmalloc(BUFSIZ);
	snprintf(buf,BUFSIZ,"%s.%s",*mod,*fcn);
	buf[0]=0;
	len= 0;
	lim= BUFSIZ;

	while (s) {
		int i;
		str ps;

		for (i = 0; i < s->def->stop; i++) {
			ps = instruction2str(s->def, 0, getInstrPtr(s->def, i), 0);
			if( strlen(ps) >= lim-len){
				/* expand the buffer */
				char *bn;
				bn= GDKmalloc(lim+BUFSIZ);
				strcpy(bn,buf);
				GDKfree(buf);
				buf=bn;
				lim+= BUFSIZ;
			}
			strcat(buf+len,ps+1);
			len+= strlen(ps)-1;
			buf[len++]='\n';
			buf[len]=0;
			GDKfree(ps);
		}
		s = s->peer;
	}
	*ret= buf;
	return MAL_SUCCEED;
}

str
INSPECTsymbolType(int *ret, str *mod, str *fcn)
{
	Symbol s;
	BAT *b;

	s = findSymbol( getName(*mod,strlen(*mod)), putName(*fcn, strlen(*fcn)));
	if (s == 0)
		throw(MAL, "inspect.getSignature", 
			"failed to find <module>.<function>");
	b = BATnew(TYPE_str, TYPE_str, 256);
	if (b == 0)
		throw(MAL, "inspect.getType", "failed to create BAT");
	while (s != NULL) {
		if (idcmp(s->name, *fcn) == 0) {
			str t = getTypeName(getDestType(s->def, getSignature(s)));

			BUNins(b, s->name, t, FALSE);
			GDKfree(t);
		}
		s = s->peer;
	}
	if (!(b->batDirty&2)) b = BATsetaccess(b, BAT_READ);
	@:Pseudo(view,fcn,type)@
	return MAL_SUCCEED;
}

str
INSPECTatom_names(int *ret)
{
	int i;
	BAT *b = BATnew(TYPE_int, TYPE_str, 256);

	if (b == 0)
		throw(MAL, "inspect.getAtomNames", "failed to create BAT");

	for (i = 0; i < GDKatomcnt; i++)
		BUNins(b, &i, ATOMname(i), FALSE);

	if (!(b->batDirty&2)) b = BATsetaccess(b, BAT_READ);
	@:Pseudo(view,atom,name)@

	return MAL_SUCCEED;
}
str
INSPECTgetEnvironment(int *ret)
{
	BAT *b;

	b= GDKenv;
	if (b == 0)
		throw(MAL, "inspect.getEnvironment", "failed to create BAT");

	BBPfix(*ret = b->batCacheid);
	return MAL_SUCCEED;
}

str
INSPECTatom_sup_names(int *ret)
{
	int i, k;
	BAT *b = BATnew(TYPE_int, TYPE_str, 256);

	if (b == 0)
		throw(MAL, "inspect.getAtomSuper", "failed to create BAT");

	for (i = 0; i < GDKatomcnt; i++) {
		for (k = BATatoms[i].storage; k > TYPE_str; k = BATatoms[k].storage)
			;
		BUNins(b, &i, ATOMname(k), FALSE);
	}

	if (!(b->batDirty&2)) b = BATsetaccess(b, BAT_READ);
	@:Pseudo(view,atom,sup_name)@

	return MAL_SUCCEED;
}

str
INSPECTatom_sizes(int *ret)
{
	int i;
	int s;
	BAT *b = BATnew(TYPE_int, TYPE_int, 256);

	if (b == 0)
		throw(MAL, "inspect.getAtomSizes", "failed to create BAT");

	for (i = 0; i < GDKatomcnt; i++) {
		s = ATOMsize(i);
		BUNins(b, &i, &s, FALSE);
	}

	if (!(b->batDirty&2)) b = BATsetaccess(b, BAT_READ);
	@:Pseudo(view,atom,size)@

	return MAL_SUCCEED;
}

/* calculate to trimmed storage space */
static lng
INSPECTcalcSize(MalBlkPtr mb){
	lng size,args=0,i;
	InstrPtr p;

	for(i=0;i<mb->stop; i++){
		p= getInstrPtr(mb,i);
		args += (p->argc-1)* sizeof(*p->argv);
	}
	size = (sizeof(InstrRecord) +sizeof(InstrPtr)) * mb->stop;
	size += (sizeof(VarRecord)+ sizeof(InstrPtr)) * mb->vtop;
	size += args;
	return size;
}

str
INSPECTgetSize(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p){
	lng *ret = (lng*) getArgReference(stk,p,0);


	*ret= INSPECTcalcSize(mb);
	(void) cntxt;
	(void) mb;
	return MAL_SUCCEED;
}
str
INSPECTgetModuleSize(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	Symbol s;
	Module m;
	int i;
	lng total=0;
	BAT *b = BATnew(TYPE_str, TYPE_lng, 256);
	int *ret= (int*) getArgReference(stk,pci,0);
	str *mod= (str*) getArgReference(stk,pci,1);

	(void) mb;
	if (b == 0)
		throw(MAL, "inspect.getSize", "failed to create BAT");

	m = findModule(cntxt->nspace, putName(*mod, strlen(*mod)));
	if (m == 0)
		throw(MAL, "inspect.getSize", 
				"failed to find <module>.<function>");

	for( i=0; i<MAXSCOPE; i++){
		s= m->subscope[i];
		while (s != NULL) {
			lng size;
			total+= (size = INSPECTcalcSize(s->def));
			BUNins(b, s->name, &size, FALSE);
			s = s->peer;
		}
	}
	BUNins(b, *mod, &total, FALSE);

	if (!(b->batDirty&2)) b = BATsetaccess(b, BAT_READ);
	@:Pseudo(view,input,result)@
	return MAL_SUCCEED;
}

str
INSPECTgetFunctionSize(lng *ret, str *mod, str *fcn)
{
	Symbol s;

	s = findSymbol( getName(*mod,strlen(*mod)), putName(*fcn, strlen(*fcn)));
	if (s == 0)
		throw(MAL, "inspect.getSize", 
			"failed to find <module>.<function>");
	*ret= INSPECTcalcSize(s->def);
	return MAL_SUCCEED;
}
@+ Display routines
@c
str
INSPECTshowFunction(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	(void) p;
	printFunction(cntxt->fdout, mb, stk, LIST_INPUT);
	return MAL_SUCCEED;
}

str
INSPECTshowFunction3(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr p)
{
	str modnme = getArgName(mb, p, 1);
	str fcnnme = getArgName(mb, p, 2);
	Symbol s = NULL;

	s = findSymbol(getName(modnme,strlen(modnme)), putName(fcnnme, strlen(fcnnme)));

	if (s == NULL){
		char buf[BUFSIZ];
		snprintf(buf,BUFSIZ,"Could not find %s.%s\n", modnme, fcnnme);
		throw(MAL, "inspect.showSource",buf);
	} else
		printFunction(cntxt->fdout, s->def, stk, LIST_INPUT);
	return MAL_SUCCEED;
}

str
INSPECTtypename(str *ret, int *tpe)
{
	*ret = getTypeName(*tpe);
	return MAL_SUCCEED;
}
str
INSPECTtypeIndex(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	int *ret;

	(void) cntxt;
	if( pci->retc== 2){
		ret = (int *) getArgReference(stk, pci, 0);
		*ret = getHeadType(getArgType(mb, pci, 2));
		ret = (int *) getArgReference(stk, pci, 1);
		*ret = getTailType(getArgType(mb, pci, 2));
	}else {
		ret = (int *) getArgReference(stk, pci, 0);
		*ret = getTailType(getArgType(mb, pci, 1));
	}
	return MAL_SUCCEED;
}
str
INSPECTequalType(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	int *ret;
	(void) stk;
	(void) cntxt;
	ret = (int *) getArgReference(stk, pci, 0);
	*ret = getArgType(mb,pci,1)== getArgType(mb,pci,2);
	return MAL_SUCCEED;
}

str
INSPECTtypeName(Client cntxt, MalBlkPtr mb, MalStkPtr stk, InstrPtr pci)
{
	str *hn, *tn =0;

	hn = (str *) getArgReference(stk, pci, 0);

	(void) cntxt;
	if( pci->retc== 2){
		tn = (str *) getArgReference(stk, pci, 1);
		*hn = getTypeName(getHeadType(getArgType(mb, pci, 2)));
		*tn = getTypeName(getTailType(getArgType(mb, pci, 2)));
	} else
		*hn = getTypeName(getArgType(mb, pci, 1));
	return MAL_SUCCEED;
}


@}
