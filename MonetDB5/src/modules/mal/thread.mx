@' The contents of this file are subject to the MonetDB Public
@' License Version 1.0 (the "License"); you may not use this file
@' except in compliance with the License. You may obtain a copy of
@' the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.0.html
@'
@' Software distributed under the License is distributed on an "AS
@' IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
@' implied. See the License for the specific language governing
@' rights and limitations under the License.
@'
@' The Original Code is the Monet Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2006 CWI.
@' All Rights Reserved.

@f thread
@a M.L. Kersten
@v 1.0
@* Thread management
The MAL interpreter can be cloned to obtain parallel running threads.
Such threads share the stackframe of the caller for data exchange.
The consequence is that a thread may only terminate when it is
not the parent of one or more children
administered on a stack-frame variable.

A thread block encountered in a MAL program leads to at most
one thread instance. This is detected by setting the thread
variable to the process id. The thread block is skipped when it
has already been set.

A thread can be separated from its parent using the command
thread.exec(arguments). The thread identity is being returned.
A process can wait for all children using thread.wait().
A thread can be killed upon request, but may leave the system
in an inconsistent state. Preferably, a soft kill is given
which appears in the process as request to terminate the
interpreter loop.

[Most of the instructions are not yet implemented]
@mal
module thread;

pattern wait():void 
address CMDthreadWait
comment "Wait for all children to be finished";

pattern suspend(pid:int):void 
address CMDthreadSuspend
comment "suspend a processing thread";

pattern wait(pid:int...):void 
address CMDthreadWaitList
comment "Wait for all threads to be finished";

pattern isDead(pid:int):bit 
address CMDthreadIsDead
comment "Check availability of a child thread";

pattern kill(pid:int):void 
address CMDthreadKill
comment "Kill a specific thread";

pattern terminate(pid:int):void
address CMDthreadTerminate
comment "Attempt a soft kill of a thread";

pattern exec(arg:any ...):int
address CMDthreadExec
comment "Run a function independently";
@{
@-
@c
@+ The Module implementation
@h
#ifndef _MAL_ATOMS
#define _MAL_ATOMS
#include "mal_resolve.h"
#include "mal_stack.h"

#include "mal_interpreter.h"
#include "mal_exception.h"
#define DEBUG_MAL_ATOMS 1
#endif /*  _MAL_ATOMS */

@c
#include "thread.h"
#ifdef _MSC_VER
#ifndef LIBTHREAD
#define thread_export extern __declspec(dllimport)
#else
#define thread_export extern __declspec(dllexport)
#endif
#else
#define thread_export extern
#endif

thread_export str
CMDthreadWait(MalBlkPtr m, MalStkPtr s, InstrPtr p);
str
CMDthreadWait(MalBlkPtr m, MalStkPtr s, InstrPtr p)
{
	(void) m;
	(void) p;		/* fool compiler */
	(void) waitForChildren(s);
	return MAL_SUCCEED;
}

thread_export str
CMDthreadSuspend(MalBlkPtr m, MalStkPtr s, InstrPtr p);
str
CMDthreadSuspend(MalBlkPtr m, MalStkPtr s, InstrPtr p)
{
	(void) s;
	(void) m;
	(void) p;		/* fool compiler */
	return throwMessage("thread.suspend", "not yet implemented\n");
}

thread_export str
CMDthreadWaitList(MalBlkPtr m, MalStkPtr s, InstrPtr p);
str
CMDthreadWaitList(MalBlkPtr m, MalStkPtr s, InstrPtr p)
{
	(void) m;
	(void) s;
	(void) p;		/* fool compiler */
	return throwMessage("thread.wait", "not yet implemented\n");
}

thread_export str
CMDthreadIsDead(MalBlkPtr m, MalStkPtr s, InstrPtr p);
str
CMDthreadIsDead(MalBlkPtr m, MalStkPtr s, InstrPtr p)
{
	(void) m;
	(void) s;
	(void) p;		/* fool compiler */
	return throwMessage("thread.isDead", "not yet implemented\n");
}

thread_export str
CMDthreadKill(MalBlkPtr m, MalStkPtr s, InstrPtr p);
str
CMDthreadKill(MalBlkPtr m, MalStkPtr s, InstrPtr p)
{
	(void) m;
	(void) s;
	(void) p;		/* fool compiler */
	return throwMessage("thread.kill", "not yet implemented\n");
}

thread_export str
CMDthreadTerminate(MalBlkPtr m, MalStkPtr s, InstrPtr p);
str
CMDthreadTerminate(MalBlkPtr m, MalStkPtr s, InstrPtr p)
{
	(void) m;
	(void) s;
	(void) p;		/* fool compiler */
	return throwMessage("thread.terminate", "not yet implemented\n");
}

thread_export str
CMDthreadExec(MalBlkPtr m, MalStkPtr s, InstrPtr p);
str
CMDthreadExec(MalBlkPtr m, MalStkPtr s, InstrPtr p)
{
	(void) m;
	(void) s;
	(void) p;		/* fool compiler */
	return throwMessage("thread.exec", "not yet implemented\n");
}

@}
