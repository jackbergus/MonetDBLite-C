
/* BEGIN -------------------Validation --------------------------------------------------------------*/
@= validate_operations
@:validate_operation_Zero(@1,@2)@
@:validate_operation_One(@1,@2)@
@:validate_operation_Two(@1,@2)@
@:validate_operation_Three(@1,@2)@
@

@= validate_init_1
	BAT *b,*c,*w;
	BUN fst_bn, lst_bn, bn;
	int bs;
	size_t count[6] = {0,0,0,0,0,0};

	/* initialization */
	*res = FALSE;
	if ((b = BATdescriptor(*bid)) == NULL) 
		throw(MAL, "crackers.@2crack_validate", "Cannot access descriptor");

	bs = BUNsize(b);
	fst_bn = BUNfirst(b);
	lst_bn = BUNlast(b);
	bn = fst_bn;
@

@= validate_init_2
	if (low > hgh) {
		BBPunfix(b->batCacheid);
		throw(MAL, "crackers.@2crack_validate", "illegal range");
	}
@

@= validate_checkUnordered
        while (bn < lst_bn @2 @3 ) {
                bn += bs;
                count[@1]++;
        }
@

@= validate_checkOrdered
{	oid hd = 0;
	while (bn < lst_bn && hd <= *(oid*)BUNhloc(b, bn) @2 @3 ) {
		hd = *(oid*)BUNhloc(b, bn);
		bn += bs;
		count[@1]++;
	}	
}
@

@= validate_check_1
	@:validate_check@5(@2, && *(@1*)BUNtloc(b, bn) @3 @4 )@
@

@= validate_check_2
	@:validate_check@7(@2, && *(@1*)BUNtloc(b, bn) @3 @4 , && *(@1*)BUNtloc(b, bn) @5 @6 )@
@

@= validate_end
	count[0] = BATcount(b);
	if (bn < lst_bn) {
		@3;
		c = BATslice(b, BUNindex(b, fst_bn), BUNindex(b, bn));
		w = BATslice(b, BUNindex(b, bn), BUNindex(b, lst_bn));
		printf("correct:\n");
		BATprint(c);
		printf("wrong:\n");
		BATprint(w);
		BBPunfix(w->batCacheid);
		BBPunfix(c->batCacheid);
		BBPunfix(b->batCacheid);
		throw(MAL, "crackers.@2crack_validate", "Invalid crack");
	}
	assert(bn == lst_bn);
	assert(count[0] == count[1] + count[2] + count[3] + count[4] + count[5]);
	BBPunfix(b->batCacheid);
	*res = TRUE;
	return MAL_SUCCEED;
@

@= validate_operation_Zero
crackers_export str CRKcrack@2Zero_validate_@1 (bit *res, int *bid, @1 *_mid);
str
CRKcrack@2Zero_validate_@1 (bit *res, int *bid, @1 *_mid){
	@1 mid=*_mid;
	@:validate_init_1(@1,z)@

	@:validate_check_1(@1,1,<=,mid,@2)@
	@:validate_check_1(@1,2,> ,mid,@2)@

	@:validate_end(@1,z,\
		printf("|b|="SZFMT" ; |tail<=%f|="SZFMT", |tail>%f|="SZFMT" !\n",\
		       count[0], (dbl)mid, count[1], (dbl)mid, count[2]);\
	)@
}
@

@= validate_operation_One
crackers_export str CRKcrack@2One_validate_@1 (int *res, int *bid, @1 *_mid);
str
CRKcrack@2One_validate_@1 (int *res, int *bid, @1 *_mid){
	@1 mid=*_mid;
	@:validate_init_1(@1,)@

	@:validate_check_1(@1,1,< ,mid,@2)@
	@:validate_check_1(@1,2,==,mid,@2)@
	@:validate_check_1(@1,3,> ,mid,@2)@
	
	@:validate_end(@1,,\
		printf("|b|="SZFMT" ; |tail<%f|="SZFMT", |tail==%f|="SZFMT", |tail>%f|="SZFMT" !\n",\
		       count[0], (dbl)mid, count[1], (dbl)mid, count[2], (dbl)mid, count[3]);\
	)@
}
@

@= validate_operation_Two
crackers_export str CRKcrack@2Two_validate_@1 (bit *res, int *bid, @1 *_low, @1 *_hgh);
str
CRKcrack@2Two_validate_@1 (bit *res, int *bid, @1 *_low, @1 *_hgh){
	@1 low=*_low, hgh=*_hgh;
	@:validate_init_1(@1,)@
	@:validate_init_2(@1,)@

	@:validate_check_1(@1,1,< ,low,@2)@
	@:validate_check_1(@1,2,==,low,@2)@
	@:validate_check_2(@1,3,> ,low,< ,hgh,@2)@
	@:validate_check_1(@1,4,==,hgh,@2)@
	@:validate_check_1(@1,5,> ,hgh,@2)@

	@:validate_end(@1,,\
		printf("|b|="SZFMT" ; |tail<%f|="SZFMT", |tail==%f|="SZFMT", |%f<tail<%f|="SZFMT", |tail==%f|="SZFMT", |tail>%f|="SZFMT" !\n",\
		       count[0], (dbl)low, count[1], (dbl)low, count[2], (dbl)low, (dbl)hgh, count[3], (dbl)hgh, count[4], (dbl)hgh, count[5]);\
	)@
}
@

@= validate_operation_Three
crackers_export str CRKcrack@2Three_validate_@1 (bit *res, int *bid, @1 *_low, @1 *_hgh);
str
CRKcrack@2Three_validate_@1 (bit *res, int *bid, @1 *_low, @1 *_hgh){
	@1 low=*_low, hgh=*_hgh;
	@:validate_init_1(@1,z)@
	@:validate_init_2(@1,z)@

	@:validate_check_1(@1,1,<=,low,@2)@
	@:validate_check_1(@1,2,<=,hgh,@2)@
	@:validate_check_1(@1,3,> ,hgh,@2)@

	@:validate_end(@1,z,\
		printf("|b|="SZFMT" ; |tail<=%f|="SZFMT", |%f<tail<=%f|="SZFMT", |tail>%f|="SZFMT" !\n",\
		       count[0], (dbl)low, count[1], (dbl)low, (dbl)hgh, count[2], (dbl)hgh, count[3]);\
	)@
}
@

@c
@:validate_operations(chr,Unordered)@
@:validate_operations(sht,Unordered)@
@:validate_operations(int,Unordered)@
@:validate_operations(lng,Unordered)@
@:validate_operations(flt,Unordered)@
@:validate_operations(dbl,Unordered)@
@:validate_operations(chr,Ordered)@
@:validate_operations(sht,Ordered)@
@:validate_operations(int,Ordered)@
@:validate_operations(lng,Ordered)@
@:validate_operations(flt,Ordered)@
@:validate_operations(dbl,Ordered)@
@:validate_operations(date,Ordered)@ /*Fix**/
@:validate_operations(date,Unordered)@ /*Fix**/
@}

@= verifyIndex
str
verifyCrackerIndex_@1(int *bid){
        BAT *c, *b;
	int position = -1;
	BUN crkt, idxh, idxt, idxFirst, crkFirst, crkLast, bnd, cur;
	int xx, zz;
	struct Node * hghIndexNode;
	bit prevIncl;
	@1 prevVal;
	int tuples=0, indexEntries=0;
	int i;

	for (i = 0; i < maxCrackMap; i++)
                if (CrackerIndex[i].bid == *bid){
                        position = i;
			break;	
		}

	if ((c = BATdescriptor(CrackerIndex[position].cid)) == NULL)
		throw(MAL, "crackers.mergeInsertions_@1", "Cannot access cracker index");
	if ((b = BATdescriptor(CrackerIndex[position].cbid)) == NULL){
		BBPunfix(c->batCacheid);
		throw(MAL, "crackers.mergeInsertions_@1", "Cannot access cracker BAT");
	}
	
	xx = BUNsize(b);
	zz = BUNsize(c);
	
	idxFirst = BUNfirst(c);
	crkFirst = BUNfirst(b);
	crkLast  = BUNtloc(b, BUNlast(b));
	crkt     = BUNtloc(b, BUNfirst(b));

	hghIndexNode = findNodeH_@1(*(@1*)crkt, TRUE, CrackerIndex[position].Tree, c, idxFirst, zz, NULL);
	if (hghIndexNode == NULL){
		BBPunfix(c->batCacheid);
        	BBPunfix(b->batCacheid);
        	return MAL_SUCCEED;
	}

	indexEntries++;
	cur = idxFirst + ((hghIndexNode->position) * zz);
	idxh = BUNhloc(c, cur);
	idxt = BUNtloc(c, cur);
	bnd  = BUNtloc(b, crkFirst + (*(lng*)idxh - hghIndexNode->hols) * xx);

	if (crkt > bnd)
		printf("\n Error: cracker index and column are not aligned. Checked %d tuples and %d index entries \n reader pointer is beyond index...", tuples, indexEntries);
	while(crkt <= bnd){

		if (@2_LT(crkt,idxt,@3@1) ||(@2_EQ(crkt,idxt,@3@1) && hghIndexNode->inclusive == FALSE)){
			crkt+=xx;
			tuples++;
		} else {
			printf("\n Error: cracker index and column are not aligned. Checked %d tuples and %d index entries \n", tuples, indexEntries);
			BBPunfix(c->batCacheid);
			BBPunfix(b->batCacheid);
			return MAL_SUCCEED;
		}
	}
	crkt+=hghIndexNode->hols * xx;

	prevVal  = *(@1*)idxt;
	prevIncl = hghIndexNode->inclusive;

	while (crkt < crkLast){
		if ((hghIndexNode = findNodeH_@1(*(@1*)crkt, TRUE, CrackerIndex[position].Tree, c, idxFirst, zz, NULL)) == NULL)
			break;
		indexEntries++;
		cur = idxFirst + ((hghIndexNode->position) * zz);
		idxh = BUNhloc(c, cur);
		idxt = BUNtloc(c, cur);
		bnd  = BUNtloc(b, crkFirst + (*(lng*)idxh - hghIndexNode->hols) * xx);

		if (crkt > bnd){
			printf("\n Error: cracker index and column are not aligned. Checked %d tuples and %d index entries \n reader pointer is beyond index...", tuples, indexEntries);
				BBPunfix(c->batCacheid);
				BBPunfix(b->batCacheid);
				return MAL_SUCCEED;
		}
		while(crkt <= bnd){

			if ( (@2_LT(crkt,idxt,@3@1) ||(@2_EQ(crkt,idxt,@3@1) && hghIndexNode->inclusive == FALSE)) &&
			     (@2_GT(crkt,&prevVal,@3@1) ||(@2_EQ(crkt,&prevVal,@3@1) && prevIncl == TRUE)) ){
				crkt+=xx;
				tuples++;
			} else {
			printf("\n Error: cracker index and column are not aligned. Checked %d tuples and %d index entries \n", tuples, indexEntries);
				BBPunfix(c->batCacheid);
				BBPunfix(b->batCacheid);
				return MAL_SUCCEED;
			}
		}
		crkt+=hghIndexNode->hols * xx;
		prevVal  = *(@1*)idxt;
		prevIncl = hghIndexNode->inclusive;
	}
	
	if (hghIndexNode == NULL){
		while(crkt < crkLast){
                        if (@2_GT(crkt,&prevVal,@3@1) ||(@2_EQ(crkt,&prevVal,@3@1) && prevIncl == TRUE)){
                                crkt+=xx;
				tuples++;
			} else {
			printf("\n Error: cracker index and column are not aligned. Checked %d tuples and %d index entries \n", tuples, indexEntries);
                                BBPunfix(c->batCacheid);
                                BBPunfix(b->batCacheid);
                                return MAL_SUCCEED;
                        }
		}
	}
	
	BBPunfix(c->batCacheid);
        BBPunfix(b->batCacheid);
	return MAL_SUCCEED;
}

crackers_export str CRKverifyCrackerIndex_@1(int *k, int *bid);
str
CRKverifyCrackerIndex_@1(int *k, int *bid){
	(void) k;		
	return verifyCrackerIndex_@1(bid);
}
@

@c
@:verifyIndex(chr,simple,)@
@:verifyIndex(sht,simple,)@
@:verifyIndex(int,simple,)@
@:verifyIndex(lng,simple,)@
@:verifyIndex(flt,simple,)@
@:verifyIndex(dbl,simple,)@
@:verifyIndex(date,atom,TYPE_)@

/* END -------------------Validation --------------------------------------------------------------*/
