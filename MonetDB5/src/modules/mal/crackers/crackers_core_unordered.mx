@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2008 CWI.
@' All Rights Reserved.

@f crackers_core_unordered
@a Martin Kersten, Stratos Idreos, Stefan Manegold
@d March 2006 - July 2007
@* Core Cracking (unordered)


@+ Interface
 

@- Type expansion

@= TypeSwitch
@:@1(chr,simple,,@2)@
@:@1(sht,simple,,@2)@
@:@1(int,simple,,@2)@
@:@1(lng,simple,,@2)@
@:@1(flt,simple,,@2)@
@:@1(dbl,simple,,@2)@
@:@1(date,atom,TYPE_,@2)@
@


@- Header file

@h
#ifndef _CRACKERS_CORE_UNORDERED_H_
#define _CRACKERS_CORE_UNORDERED_H_

#ifdef LIBCRACKERS
/* Signatures shared within the crackers module/library */
@:TypeSwitch(operations,_decl)@
#endif

/* Exported signatures */
@:TypeSwitch(CoreUnorderedFunctions_decl,)@

#endif /* _CRACKERS_CORE_UNORDERED_H */
@


@- Exported signatures

@= CoreUnorderedFunctions_decl
crackers_export str CRKcrackUnorderedZero_@1 (int *res, int *bid, @1 *mid);
crackers_export str CRKcrackUnorderedThree_@1 (int *res, int *bid, @1 *low, @1 *hgh);
@


@- Signatures shared within the crackers module/library

@= operations
@:crackInTwoUnorderedPieces@4(@1,LE,LE,GT,@2,@3)@
@:crackInTwoUnorderedPieces@4(@1,RE,LT,GE,@2,@3)@
@:crackInThreeUnorderedPieces@4(@1,LO,RE,LE,GT,LE,GT,@2,@3)@
@:crackInThreeUnorderedPieces@4(@1,LE,RE,LT,GE,LE,GT,@2,@3)@
@:crackInThreeUnorderedPieces@4(@1,LO,RO,LE,GT,LT,GE,@2,@3)@
@:crackInThreeUnorderedPieces@4(@1,LE,RO,LT,GE,LT,GE,@2,@3)@
@

@= crackInTwoUnorderedPieces_decl
str CRKcrackUnorderedZero_@2_@1( BAT *b, @1 mval, oid first, oid last, oid *pos);
@

@= crackInThreeUnorderedPieces_decl
str CRKcrackUnorderedThree_@2_@3_@1( BAT *b, @1 low, @1 hgh, oid first, oid last, oid *posl, oid *posh);
@


@{
@+ Implementation


@- C file

@c
#include "mal_config.h"
#include "crackers.h"

/* Functions shared within the crackers module/library */
@:TypeSwitch(operations,_impl)@

/* Exported functions */
@:TypeSwitch(CoreUnorderedFunctions_impl,)@
@


@- Exported functions

@= CoreUnorderedFunctions_impl
str
CRKcrackUnorderedZero_@1 (int *res, int *bid, @1 *mid){
        BAT *b;
        str msg;
	oid pos;

        if ((b = BATdescriptor(*bid)) == NULL)
                throw(MAL, "crackers.crack_zeroUnordered", "Cannot access descriptor");

        /* set bounds for the iterator */
       /* if( sizeof(struct SCRATCH{ oid hdummy; @1 tdummy; } ) != BUNsize(b) )
                throw(MAL, "crackers.crack_zeroUnordered", "Need more clever mapping ");
	*/
        msg = CRKcrackUnorderedZero_LE_@1( b, *mid,(size_t) 0, BATcount(b)-1, &pos);

        BBPkeepref(b->batCacheid);
        *res = *bid;
        return msg;
}

str
CRKcrackUnorderedThree_@1 (int *res, int *bid, @1 *low, @1 *hgh){
        BAT *b;
        str msg;
	oid posl, posh;

        if (*(@1 *) low > *(@1 *) hgh)
                throw(MAL, "crackers.crack_threeUnordered", "illegal range");
        if ((b = BATdescriptor(*bid)) == NULL)
                throw(MAL, "crackers.crack_threeUnordered", "Cannot access descriptor");

        /* set bounds for the iterator */
        /*if( sizeof(struct SCRATCH{ oid hdummy; @1 tdummy; } ) != BUNsize(b) )
                throw(MAL, "crackers.crack_threeUnordered", "Need more clever mapping ");
	*/
        msg = CRKcrackUnorderedThree_LO_RE_@1( b, *low, *hgh, 0, BATcount(b)-1,&posl, &posh);

        BBPkeepref(b->batCacheid);
        *res = *bid;
        return msg;
}
@


@- Functions shared within the crackers module/library

@= crackInTwoUnorderedPieces_impl
str
CRKcrackUnorderedZero_@2_@1( BAT *b, @1 mval, oid first, oid last, oid *pos){
        @1  *ft, *lt, *t0;
	oid *fh, *lh;
        oid hdummy;
        @1 tdummy;
	

        /* set bounds for the iterator */
        t0 = (@1 *)Tloc(b, BUNfirst(b));
        ft = (@1 *)Tloc(b, BUNfirst(b) + first);
        lt = (@1 *)Tloc(b, BUNfirst(b) + last);
        fh = (oid*)Hloc(b, BUNfirst(b) + first);
        lh = (oid*)Hloc(b, BUNfirst(b) + last);

        while(ft<lt) {
                if (@5_@3(ft, &mval,@6@1)){
                        ft++; fh++;
		}
                else {
                        while( @5_@4(lt, &mval,@6@1) && lt>ft){
                                lt--; lh--;
			}
                        @:shuffle(@1,ft,lt,fh,lh)@
                        lt--;lh--;
                        ft++;fh++;
                }
        }

	if (lt == ft) {
		if (@5_@4(lt, &mval,@6@1))
			*pos = (oid)(lt - t0) - (oid)1; /*works for empty left piece also*/
		else{
			*pos = (oid)(lt - t0); 
			if (*pos==last) /*empty right piece*/
				*pos = *pos + (oid)1;
		}
	}
	else
		*pos = (oid)(lt - t0); 
		
        return MAL_SUCCEED;
}
@

@= crackInThreeUnorderedPieces_impl
str
CRKcrackUnorderedThree_@2_@3_@1( BAT *b, @1 low, @1 hgh, oid first, oid last, oid *posl, oid *posh){
        @1  *ft, *lt, *tmax, *t0;
	oid *fh, *lh, *hmax;
        oid hdummy;
        @1 tdummy;
	BUN firstBUN;

        /* set bounds for the iterator */
	firstBUN = BUNfirst(b);
        t0   = (@1*)Tloc(b, firstBUN);
        ft   = (@1*)Tloc(b, firstBUN + first);
        tmax = (@1 *)Tloc(b, firstBUN + last);
        fh   = (oid*)Hloc(b, firstBUN + first);
        hmax = (oid*)Hloc(b, firstBUN + last);
        while( @8_@7(tmax, &hgh,@9@1) && tmax>ft){
                tmax--;hmax--;
	}

	if (tmax == ft){
		if (@8_@7(tmax, &hgh,@9@1)){ /*left and middle are empty*/
			*posl =  1;
			*posh = -1;
		}
		else if (@8_@5(tmax, &low,@9@1))  /*result is one bun*/
			*posl = *posh = tmax-t0;
		else{
			*posl = tmax-t0 - (oid)1; 
			*posh = tmax-t0; 
		}
		return MAL_SUCCEED;
	}

        lt = tmax;lh=hmax;
        while( @8_@5(lt, &low,@9@1) && lt>ft){
                /* move all high values into their final place */
                if( @8_@7(lt, &hgh,@9@1)){
                        @:shuffle(@1,lt,tmax,lh,hmax)@
                        tmax--;hmax--;
                }
                lt--;lh--;
        }
	if (lt == ft){/*left piece is empty*/
		if (@8_@7(lt, &hgh,@9@1)){
			@:shuffle(@1,lt,tmax,lh,hmax)@
			*posl = lt-t0;
		}
		else if (@8_@5(lt, &low,@9@1))
			*posl = lt-t0;
		else
			*posl = lt-t0 + (oid)1;
		*posh = tmax-t0;
		return MAL_SUCCEED;
	}
        /* lt point to the first <=low, all values >hg are beyond tmax */

        /* perform Zero crack first */
        while(ft<=lt) {
                if (@8_@4(ft, &low,@9@1)){
                        ft++;fh++;
		}
                else {
                        @:shuffle(@1,ft,lt,fh,lh)@
                        while( @8_@5(lt, &low,@9@1) && lt>ft){
                                if(@8_@7(lt, &hgh,@9@1) ){
                                        @:shuffle(@1,lt,tmax,lh,hmax)@
                                        tmax--;hmax--;
                                }
                                lt--;lh--;
                        }
                }
        }
	if (ft ==  (@1*)Tloc(b, firstBUN +last+1)){ /*right and middle are empty*/
		*posl = -1;
		*posh = -1;
		return MAL_SUCCEED;
	}	
	if (tmax == lt){ /*then middle piece is empty*/
		*posl = lt - t0 + (oid)1;
		*posh = tmax - t0;
		return MAL_SUCCEED;
	}
	*posl = ft - t0;
	*posh = tmax - t0;

	return MAL_SUCCEED;
}
@


@- Local support functions and macros

@= shuffle
        tdummy = *@2;
        *@2 = *@3;
        *@3 = tdummy;

        hdummy = *@4;
        *@4 = *@5;
        *@5 = hdummy;
@

@}
