@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2008 CWI.
@' All Rights Reserved.

@f crackers_core_unordered
@a Martin Kersten, Stratos Idreos, Stefan Manegold
@d March 2006 - July 2007
@* Core Cracking (unordered)


@+ Interface
 

@- Type expansion

@= TypeSwitch
@:@1(chr,simple,,@2)@
@:@1(sht,simple,,@2)@
@:@1(int,simple,,@2)@
@:@1(lng,simple,,@2)@
@:@1(flt,simple,,@2)@
@:@1(dbl,simple,,@2)@
@:@1(date,atom,TYPE_,@2)@
@


@- Header file

@h
#ifndef _CRACKERS_CORE_UNORDERED_H_
#define _CRACKERS_CORE_UNORDERED_H_

#ifdef LIBCRACKERS
/* Signatures shared within the crackers module/library */
@:TypeSwitch(operations,_decl)@
#endif

/* Exported signatures */
@:TypeSwitch(CoreUnorderedFunctions_decl,)@

#endif /* _CRACKERS_CORE_UNORDERED_H */
@


@- Exported signatures

@= CoreUnorderedFunctions_decl
crackers_export str CRKcrackUnorderedZero_@1 (int *res, int *bid, @1 *mid);
crackers_export str CRKcrackUnorderedThree_@1 (int *res, int *bid, @1 *low, @1 *hgh);
@


@- Signatures shared within the crackers module/library

@= operations
@:crackInTwoUnorderedPieces@4(@1,LE,LE,GT,@2,@3)@
@:crackInTwoUnorderedPieces@4(@1,RE,LT,GE,@2,@3)@
@:crackInThreeUnorderedPieces@4(@1,LO,RE,LE,GT,LE,GT,@2,@3)@
@:crackInThreeUnorderedPieces@4(@1,LE,RE,LT,GE,LE,GT,@2,@3)@
@:crackInThreeUnorderedPieces@4(@1,LO,RO,LE,GT,LT,GE,@2,@3)@
@:crackInThreeUnorderedPieces@4(@1,LE,RO,LT,GE,LT,GE,@2,@3)@
@

@= crackInTwoUnorderedPieces_decl
str CRKcrackUnorderedZero_@2_@1( BAT *b, @1 mval, lng first, lng last, lng *pos);
@

@= crackInThreeUnorderedPieces_decl
str CRKcrackUnorderedThree_@2_@3_@1( BAT *b, @1 low, @1 hgh, lng first, lng last, lng *posl, lng *posh);
@


@{
@+ Implementation


@- C file

@c
#include "mal_config.h"
#include "crackers.h"

/* Functions shared within the crackers module/library */
@:TypeSwitch(operations,_impl)@

/* Exported functions */
@:TypeSwitch(CoreUnorderedFunctions_impl,)@
@


@- Exported functions

@= CoreUnorderedFunctions_impl
str
CRKcrackUnorderedZero_@1 (int *res, int *bid, @1 *mid){
        BAT *b;
        str msg;
	lng pos;

        if ((b = BATdescriptor(*bid)) == NULL)
                throw(MAL, "crackers.crack_zeroUnordered", "Cannot access descriptor");

        /* set bounds for the iterator */
        if( sizeof(struct SCRATCH{ oid hdummy; @1 tdummy; } ) != BUNsize(b) )
                throw(MAL, "crackers.crack_zeroUnordered", "Need more clever mapping ");

        msg = CRKcrackUnorderedZero_LE_@1( b, *mid,(size_t) 0, BATcount(b)-1, &pos);

        BBPkeepref(b->batCacheid);
        *res = *bid;
        return msg;
}

str
CRKcrackUnorderedThree_@1 (int *res, int *bid, @1 *low, @1 *hgh){
        BAT *b;
        str msg;
	lng posl, posh;

        if (*(@1 *) low > *(@1 *) hgh)
                throw(MAL, "crackers.crack_threeUnordered", "illegal range");
        if ((b = BATdescriptor(*bid)) == NULL)
                throw(MAL, "crackers.crack_threeUnordered", "Cannot access descriptor");

        /* set bounds for the iterator */
        if( sizeof(struct SCRATCH{ oid hdummy; @1 tdummy; } ) != BUNsize(b) )
                throw(MAL, "crackers.crack_threeUnordered", "Need more clever mapping ");

        msg = CRKcrackUnorderedThree_LO_RE_@1( b, *low, *hgh, 0, BATcount(b)-1,&posl, &posh);

        BBPkeepref(b->batCacheid);
        *res = *bid;
        return msg;
}
@


@- Functions shared within the crackers module/library

@= crackInTwoUnorderedPieces_impl
str
CRKcrackUnorderedZero_@2_@1( BAT *b, @1 mval, lng first, lng last, lng *pos){
        ptr vm, vl;
        int xx;
        oid hdummy;
        @1 tdummy;

        /* set bounds for the iterator */
        xx = BUNsize(b);

        vm = BUNtloc(b, BUNptr(b,first));
        vl= BUNtloc(b,BUNptr(b,last));

        while(vm<vl) {
                if (@5_@3(vm, &mval,@6@1))
                        vm = (ptr) ((char *) vm + xx);
                else {
                        while( @5_@4(vl, &mval,@6@1) && vl>vm)
                                vl = (ptr) ((char *) vl - xx);
                        @:shuffle(@1,vm,vl)@
                        vl = (ptr) ((char *) vl - xx);
                        vm = (ptr) ((char *) vm + xx);
                }
        }

	if (vl == vm) {
		if (@5_@4(vl, &mval,@6@1))
			*pos = BUNindex(b,(ptr) ((char *) vl - xx)); /*works for empty left piece also*/
		else{
			*pos = BUNindex(b,vl);
			if (BUNindex(b,vl)==(size_t)last) /*empty right piece*/
				*pos = *pos+1;
		}
	}
	else
		*pos = BUNindex(b,vl);
		
        return MAL_SUCCEED;
}
@

@= crackInThreeUnorderedPieces_impl
str
CRKcrackUnorderedThree_@2_@3_@1( BAT *b, @1 low, @1 hgh, lng first, lng last, lng *posl, lng *posh){
        ptr vm, vl, hmax;
        int xx;
        oid hdummy;
        @1 tdummy;

        /* set bounds for the iterator */
        xx = BUNsize(b);

        vm = BUNtloc(b, BUNptr(b,first));
        hmax = BUNtloc(b,BUNptr(b,last));
        while( @8_@7(hmax, &hgh,@9@1) && hmax>vm)
                hmax= (ptr)((char*) hmax - xx);

	if (hmax == vm){
		if (@8_@7(hmax, &hgh,@9@1)){ /*left and middle are empty*/
			*posl =  1;
			*posh = -1;
		}
		else if (@8_@5(hmax, &low,@9@1))  /*result is one bun*/
			*posl = *posh = BUNindex(b,hmax);
		else{
			*posl = BUNindex(b,(ptr) ((char *) hmax + xx));
			*posh = BUNindex(b,hmax);
		}
		return MAL_SUCCEED;
	}

        vl = hmax;
        while( @8_@5(vl, &low,@9@1) && vl>vm){
                /* move all high values into their final place */
                if( @8_@7(vl, &hgh,@9@1)){
                        @:shuffle(@1,vl,hmax)@
                        hmax= (ptr)((char*) hmax - xx);
                }
                vl= (ptr)((char*) vl - xx);
        }
	if (vl == vm){/*left piece is empty*/
		if (@8_@7(vl, &hgh,@9@1)){
			@:shuffle(@1,vl,hmax)@
			*posl = BUNindex(b,vl);
		}
		else if (@8_@5(vl, &low,@9@1))
			*posl = BUNindex(b,vl);
		else
			*posl = BUNindex(b,(ptr) ((char *) vl + xx));
		*posh = BUNindex(b,hmax);
		return MAL_SUCCEED;
	}
        /* vl point to the first <=low, all values >hg are beyond hmax */

        /* perform Zero crack first */
        while(vm<=vl) {
                if (@8_@4(vm, &low,@9@1))
                        vm = (ptr) ((char *) vm + xx);
                else {
                        @:shuffle(@1,vm,vl)@
                        while( @8_@5(vl, &low,@9@1) && vl>vm){
                                if(@8_@7(vl, &hgh,@9@1) ){
                                        @:shuffle(@1,vl,hmax)@
                                        hmax= (ptr)((char*) hmax - xx);
                                }
                                vl = (ptr) ((char *) vl - xx);
                        }
                }
        }
	if (vm ==  BUNtloc(b,BUNptr(b,last+1))){ /*right and middle are empty*/
		*posl = -1;
		*posh = -1;
		return MAL_SUCCEED;
	}	
	if (hmax == vl){ /*then middle piece is empty*/
		*posl = BUNindex(b,(ptr) ((char *) vl + xx));
		*posh = BUNindex(b,hmax);
		return MAL_SUCCEED;
	}
	*posl = BUNindex(b,vm);
	*posh = BUNindex(b,hmax);

	return MAL_SUCCEED;
}
@


@- Local support functions and macros

@= shuffle
        tdummy= *(@1*) @2;
        *(@1*) @2= *(@1*) @3;
        *(@1*) @3= tdummy;

        hdummy= *(oid*)((char*)@2 - b->tloc);
        *(oid*)((char*)@2 - b->tloc) = *(oid*)((char*)@3 - b->tloc);
        *(oid*)((char*)@3 - b->tloc) = hdummy;
@

@}
