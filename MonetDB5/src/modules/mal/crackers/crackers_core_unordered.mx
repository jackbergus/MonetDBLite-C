@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2008 CWI.
@' All Rights Reserved.

@f crackers_core_unordered
@a Martin Kersten, Stratos Idreos, Stefan Manegold
@d March 2006 - July 2007
@* Core Cracking (unordered)


@+ Interface
 

@- Type expansion

@= TypeSwitch
@:@1(chr,simple,,@2)@
@:@1(sht,simple,,@2)@
@:@1(int,simple,,@2)@
@:@1(lng,simple,,@2)@
@:@1(flt,simple,,@2)@
@:@1(dbl,simple,,@2)@
@:@1(date,atom,TYPE_,@2)@
@

@= TypeSwitch_2
@:@1(int,,simple,,int,@2)@
@:@1(dbl,,simple,,dbl,@2)@
@:@1(date,,atom,TYPE_,loc,@2)@
@

@= TypeSwitch_4
/* TODO: add the rest of the type combinations once code is stable */
@:@1(int,int,simple,,,@2)@
@:@1(int,date,simple,,,@2)@
@:@1(dbl,date,simple,,,@2)@
@:@1(dbl,int,simple,,,@2)@
@:@1(dbl,dbl,simple,,,@2)@

@:@1(date,int,atom,TYPE_,,@2)@
@:@1(date,lng,atom,TYPE_,,@2)@
@:@1(date,dbl,atom,TYPE_,,@2)@
@:@1(date,date,atom,TYPE_,,@2)@
@

@- Header file

@h
#ifndef _CRACKERS_CORE_UNORDERED_H_
#define _CRACKERS_CORE_UNORDERED_H_

#ifdef LIBCRACKERS
/* Signatures shared within the crackers module/library */
@:TypeSwitch(operations,_decl)@
@:TypeSwitch_4(operationsSideways,_decl)@
@:TypeSwitch_2(operationsSideways_str,_decl)@
#endif

/* Exported signatures */
@:TypeSwitch(CoreUnorderedFunctions_decl,)@

#endif /* _CRACKERS_CORE_UNORDERED_H */
@


@- Exported signatures

@= CoreUnorderedFunctions_decl
crackers_export str CRKcrackUnorderedZero_@1 (int *res, int *bid, @1 *mid);
crackers_export str CRKcrackUnorderedThree_@1 (int *res, int *bid, @1 *low, @1 *hgh);
@


@- Signatures shared within the crackers module/library

@= operations
@:crackInTwoUnorderedPieces@4(@1,LE,LE,GT,@2,@3)@
@:crackInTwoUnorderedPieces@4(@1,RE,LT,GE,@2,@3)@
@:crackInThreeUnorderedPieces@4(@1,LO,RE,LE,GT,LE,GT,@2,@3)@
@:crackInThreeUnorderedPieces@4(@1,LE,RE,LT,GE,LE,GT,@2,@3)@
@:crackInThreeUnorderedPieces@4(@1,LO,RO,LE,GT,LT,GE,@2,@3)@
@:crackInThreeUnorderedPieces@4(@1,LE,RO,LT,GE,LT,GE,@2,@3)@
@

@= crackInTwoUnorderedPieces_decl
str CRKcrackUnorderedZero_@2_@1( BAT *b, @1 mval, oid first, oid last, oid *pos);
str CRKcrackUnorderedZero2_@2_@1( BAT *b, @1 mval, oid first, oid last, oid *pos, int indexPosition, BAT * index);
@

@= crackInThreeUnorderedPieces_decl
str CRKcrackUnorderedThree_@2_@3_@1( BAT *b, @1 low, @1 hgh, oid first, oid last, oid *posl, oid *posh);
str CRKcrackUnorderedThree2_@2_@3_@1( BAT *b, @1 low, @1 hgh, oid first, oid last, oid *posl, oid *posh);
@

@= operationsSideways
@:crackInTwoUnorderedPiecesSideways@6(@1,@2,LE,LE,GT,@3,@4)@
@:crackInTwoUnorderedPiecesSideways@6(@1,@2,RE,LT,GE,@3,@4)@
@:crackInThreeUnorderedPiecesSideways@6(@1,@2,LO,RE,LE,GT,LE,GT,@3,@4)@
@:crackInThreeUnorderedPiecesSideways@6(@1,@2,LE,RE,LT,GE,LE,GT,@3,@4)@
@:crackInThreeUnorderedPiecesSideways@6(@1,@2,LO,RO,LE,GT,LT,GE,@3,@4)@
@:crackInThreeUnorderedPiecesSideways@6(@1,@2,LE,RO,LT,GE,LT,GE,@3,@4)@
@

@= operationsSideways_str
@:crackInTwoUnorderedPiecesSideways_str@6(@1,,LE,LE,GT,@3,@4)@
@:crackInTwoUnorderedPiecesSideways_str@6(@1,,RE,LT,GE,@3,@4)@
@:crackInThreeUnorderedPiecesSideways_str@6(@1,,LO,RE,LE,GT,LE,GT,@3,@4)@
@:crackInThreeUnorderedPiecesSideways_str@6(@1,,LE,RE,LT,GE,LE,GT,@3,@4)@
@:crackInThreeUnorderedPiecesSideways_str@6(@1,,LO,RO,LE,GT,LT,GE,@3,@4)@
@:crackInThreeUnorderedPiecesSideways_str@6(@1,,LE,RO,LT,GE,LT,GE,@3,@4)@
@

@= crackInTwoUnorderedPiecesSideways_decl
str CRKcrackUnorderedZeroSideways_@3_@1_@2( BAT *b, @1 mval, oid first, oid last, oid *pos);
@

@= crackInTwoUnorderedPiecesSideways_str_decl
str CRKcrackUnorderedZeroSideways_@3_@1_str( BAT *b, @1 mval, oid first, oid last, oid *pos);
@

@= crackInThreeUnorderedPiecesSideways_decl
str CRKcrackUnorderedThreeSideways_@3_@4_@1_@2( BAT *b, @1 low, @1 hgh, oid first, oid last, oid *posl, oid *posh);
@

@= crackInThreeUnorderedPiecesSideways_str_decl
str CRKcrackUnorderedThreeSideways_@3_@4_@1_str( BAT *b, @1 low, @1 hgh, oid first, oid last, oid *posl, oid *posh);
@

@{
@+ Implementation


@- C file

@c
#include "mal_config.h"
#include "crackers.h"

/* Functions shared within the crackers module/library */
@:TypeSwitch(operations,_impl)@
@:TypeSwitch_4(operationsSideways,_impl)@
@:TypeSwitch_2(operationsSideways_str,_impl)@

/* Exported functions */
@:TypeSwitch(CoreUnorderedFunctions_impl,)@
@


@- Exported functions

@= CoreUnorderedFunctions_impl
str
CRKcrackUnorderedZero_@1 (int *res, int *bid, @1 *mid){
        BAT *b;
        str msg;
	oid pos;

        if ((b = BATdescriptor(*bid)) == NULL)
                throw(MAL, "crackers.crack_zeroUnordered", "Cannot access descriptor");

        /* set bounds for the iterator */
       /* if( sizeof(struct SCRATCH{ oid hdummy; @1 tdummy; } ) != BUNsize(b) )
                throw(MAL, "crackers.crack_zeroUnordered", "Need more clever mapping ");
	*/
        msg = CRKcrackUnorderedZero_LE_@1( b, *mid,(size_t) 0, BATcount(b)-1, &pos);

        BBPkeepref(b->batCacheid);
        *res = *bid;
        return msg;
}

str
CRKcrackUnorderedThree_@1 (int *res, int *bid, @1 *low, @1 *hgh){
        BAT *b;
        str msg;
	oid posl, posh;

        if (*(@1 *) low > *(@1 *) hgh)
                throw(MAL, "crackers.crack_threeUnordered", "illegal range");
        if ((b = BATdescriptor(*bid)) == NULL)
                throw(MAL, "crackers.crack_threeUnordered", "Cannot access descriptor");

        /* set bounds for the iterator */
        /*if( sizeof(struct SCRATCH{ oid hdummy; @1 tdummy; } ) != BUNsize(b) )
                throw(MAL, "crackers.crack_threeUnordered", "Need more clever mapping ");
	*/
        msg = CRKcrackUnorderedThree_LO_RE_@1( b, *low, *hgh, 0, BATcount(b)-1,&posl, &posh);

        BBPkeepref(b->batCacheid);
        *res = *bid;
        return msg;
}
@


@- Functions shared within the crackers module/library

@= crackInTwoUnorderedPieces_impl
str
CRKcrackUnorderedZero_@2_@1( BAT *b, @1 mval, oid first, oid last, oid *pos){
        @1  *ft, *lt, *t0;
	oid *fh, *lh;
        oid hdummy;
        @1 tdummy;
	

        /* set bounds for the iterator */
        t0 = (@1 *)Tloc(b, BUNfirst(b));
        ft = (@1 *)Tloc(b, BUNfirst(b) + first);
        lt = (@1 *)Tloc(b, BUNfirst(b) + last);
        fh = (oid*)Hloc(b, BUNfirst(b) + first);
        lh = (oid*)Hloc(b, BUNfirst(b) + last);

        while(ft<lt) {
                if (@5_@3(ft, &mval,@6@1)){
                        ft++; fh++;
		}
                else {
                        while( @5_@4(lt, &mval,@6@1) && lt>ft){
                                lt--; lh--;
			}
                        @:shuffle(@1,ft,lt,fh,lh)@
                        lt--;lh--;
                        ft++;fh++;
                }
        }

	if (lt == ft) {
		if (@5_@4(lt, &mval,@6@1)){
			if (lt==t0) 
				*pos = BUNfirst(b);
			else	
				*pos = (lt - t0) - 1; /*works for empty left piece also*/
		}
		else{
			*pos = lt - t0; 
			if (*pos==last) /*empty right piece*/
				*pos = *pos + 1;
		}
	}
	else{
		if (lt > t0)
			*pos = lt - t0;
		else
			*pos = BUNfirst(b);
	}		
		
        return MAL_SUCCEED;
}

str
CRKcrackUnorderedZero2_@2_@1( BAT *b, @1 mval, oid first, oid last, oid *pos, int indexPosition, BAT *index){
        @1  *ft, *lt, *t0, *sample, *leftBoundt, *rightBoundt;
	oid *fh, *lh, *leftBoundh, *rightBoundh;
        oid hdummy;
        @1 tdummy;

	oid sizeBAT, sizePiece;
	@1 mid;

	sizeBAT   = BATcount(b);
	sizePiece = last - first;

	/* if the to be processed tuples are not a significant part of 
		the BAT the perform a simple crack */
	if (sizePiece < sizeBAT/10)
		return CRKcrackUnorderedZero_@2_@1( b, mval, first, last, pos);

	printf("\n perform organic crack \n");

        /* set bounds for the iterator */
        t0 = (@1 *)Tloc(b, BUNfirst(b));
        leftBoundt  = ft = (@1 *)Tloc(b, BUNfirst(b) + first);
        rightBoundt = lt = (@1 *)Tloc(b, BUNfirst(b) + last);
        leftBoundh  = fh = (oid*)Hloc(b, BUNfirst(b) + first);
        rightBoundh = lh = (oid*)Hloc(b, BUNfirst(b) + last);

	sample = ft + 10;
	mid=*ft;ft++;
	for (;ft<sample;ft++)
		mid+=*ft;
	mid = mid/10;
        ft = (@1 *)Tloc(b, BUNfirst(b) + first);
		
        while(ft<lt) {
		if (@5_@3(ft, &mval,@6@1)){
			if (*ft < mid){
				leftBoundt++;
				leftBoundh++;
				if (ft>leftBoundt){ 
					@:shuffle(@1,ft,leftBoundt,fh,leftBoundh)@
				}
			} 

			ft++; fh++;
		}
                else {
                        while( @5_@4(lt, &mval,@6@1) && lt>ft){
				if (*lt >= mid){
					rightBoundt--;
					rightBoundh--;
					if (lt<rightBoundt){ 
						@:shuffle(@1,lt,rightBoundt,lh,rightBoundh)@
					}
				} 

                                lt--; lh--;
			}
                        @:shuffle(@1,ft,lt,fh,lh)@

			if (*ft < mid){
				leftBoundt++;
				leftBoundh++;
				if (ft>leftBoundt){ 
					@:shuffle(@1,ft,leftBoundt,fh,leftBoundh)@
				}
			} 
			if (*lt >= mid){
				rightBoundt--;
				rightBoundh--;
				if (lt<rightBoundt){ 
					@:shuffle(@1,lt,rightBoundt,lh,rightBoundh)@
				}
			} 

                        lt--;lh--;
                        ft++;fh++;
                }
        }


	if (ft > leftBoundt){
		addCrackerIndex_@1(indexPosition, &mid,  TRUE, leftBoundt-t0, index);
	}
	if (lt < rightBoundt){
		addCrackerIndex_@1(indexPosition, &mid, TRUE,  (rightBoundt-t0)-1, index);
	}
	if (lt == ft) {
		if (@5_@4(lt, &mval,@6@1)){
			if (lt==t0) 
				*pos = BUNfirst(b);
			else	
				*pos = (lt - t0) - 1; /*works for empty left piece also*/
		}
		else{
			*pos = lt - t0; 
			if (*pos==last) /*empty right piece*/
				*pos = *pos + 1;
		}
	}
	else{
		if (lt > t0)
			*pos = lt - t0;
		else
			*pos = BUNfirst(b);
	}		
	
        return MAL_SUCCEED;
}
@

@= crackInThreeUnorderedPieces_impl
str
CRKcrackUnorderedThree_@2_@3_@1( BAT *b, @1 low, @1 hgh, oid first, oid last, oid *posl, oid *posh){
        @1  *ft, *lt, *tmax, *t0;
	oid *fh, *lh, *hmax;
        oid hdummy;
        @1 tdummy;
	BUN firstBUN;

        /* set bounds for the iterator */
	firstBUN = BUNfirst(b);
        t0   = (@1*)Tloc(b, firstBUN);
        ft   = (@1*)Tloc(b, firstBUN + first);
        tmax = (@1 *)Tloc(b, firstBUN + last);
        fh   = (oid*)Hloc(b, firstBUN + first);
        hmax = (oid*)Hloc(b, firstBUN + last);
        while( @8_@7(tmax, &hgh,@9@1) && tmax>ft){
                tmax--;hmax--;
	}

	if (tmax == ft){
		if (@8_@7(tmax, &hgh,@9@1)){ /*left and middle are empty*/
			*posl =  1;
			*posh = -1;
		}
		else if (@8_@5(tmax, &low,@9@1))  /*result is one bun*/
			*posl = *posh = tmax-t0;
		else{
			*posl = (tmax-t0) - 1; 
			*posh = tmax-t0; 
		}
		return MAL_SUCCEED;
	}

        lt = tmax;lh=hmax;
        while( @8_@5(lt, &low,@9@1) && lt>ft){
                /* move all high values into their final place */
                if( @8_@7(lt, &hgh,@9@1)){
                        @:shuffle(@1,lt,tmax,lh,hmax)@
                        tmax--;hmax--;
                }
                lt--;lh--;
        }
	if (lt == ft){/*left piece is empty*/
		if (@8_@7(lt, &hgh,@9@1)){
			@:shuffle(@1,lt,tmax,lh,hmax)@
			*posl = lt-t0;
		}
		else if (@8_@5(lt, &low,@9@1))
			*posl = lt-t0;
		else
			*posl = (lt-t0) + 1;
		*posh = tmax-t0;
		return MAL_SUCCEED;
	}
        /* lt point to the first <=low, all values >hg are beyond tmax */

        /* perform Zero crack first */
        while(ft<=lt) {
                if (@8_@4(ft, &low,@9@1)){
                        ft++;fh++;
		}
                else {
                        @:shuffle(@1,ft,lt,fh,lh)@
                        while( @8_@5(lt, &low,@9@1) && lt>ft){
                                if(@8_@7(lt, &hgh,@9@1) ){
                                        @:shuffle(@1,lt,tmax,lh,hmax)@
                                        tmax--;hmax--;
                                }
                                lt--;lh--;
                        }
                }
        }
	if (ft ==  (@1*)Tloc(b, firstBUN +last+1)){ /*right and middle are empty*/
		*posl = -1;
		*posh = -1;
		return MAL_SUCCEED;
	}	
	if (tmax == lt){ /*then middle piece is empty*/
		*posl = (lt - t0) + 1;
		*posh = tmax - t0;
		return MAL_SUCCEED;
	}
	*posl = ft - t0;
	*posh = tmax - t0;

	return MAL_SUCCEED;
}

str
CRKcrackUnorderedThree2_@2_@3_@1( BAT *b, @1 low, @1 hgh, oid first, oid last, oid *posl, oid *posh){
        @1  *ft, *lt, *tmax, *t0;
	oid *fh, *lh, *hmax;
        oid hdummy;
        @1 tdummy;
	BUN firstBUN;

        /* set bounds for the iterator */
	firstBUN = BUNfirst(b);
        t0   = (@1*)Tloc(b, firstBUN);
        ft   = (@1*)Tloc(b, firstBUN + first);
        tmax = (@1 *)Tloc(b, firstBUN + last);
        fh   = (oid*)Hloc(b, firstBUN + first);
        hmax = (oid*)Hloc(b, firstBUN + last);
        while( @8_@7(tmax, &hgh,@9@1) && tmax>ft){
                tmax--;hmax--;
	}

	if (tmax == ft){
		if (@8_@7(tmax, &hgh,@9@1)){ /*left and middle are empty*/
			*posl =  1;
			*posh = -1;
		}
		else if (@8_@5(tmax, &low,@9@1))  /*result is one bun*/
			*posl = *posh = tmax-t0;
		else{
			*posl = (tmax-t0) - 1; 
			*posh = tmax-t0; 
		}
		return MAL_SUCCEED;
	}

        lt = tmax;lh=hmax;
        while( @8_@5(lt, &low,@9@1) && lt>ft){
                /* move all high values into their final place */
                if( @8_@7(lt, &hgh,@9@1)){
                        @:shuffle(@1,lt,tmax,lh,hmax)@
                        tmax--;hmax--;
                }
                lt--;lh--;
        }
	if (lt == ft){/*left piece is empty*/
		if (@8_@7(lt, &hgh,@9@1)){
			@:shuffle(@1,lt,tmax,lh,hmax)@
			*posl = lt-t0;
		}
		else if (@8_@5(lt, &low,@9@1))
			*posl = lt-t0;
		else
			*posl = (lt-t0) + 1;
		*posh = tmax-t0;
		return MAL_SUCCEED;
	}
        /* lt point to the first <=low, all values >hg are beyond tmax */

        /* perform Zero crack first */
        while(ft<=lt) {
                if (@8_@4(ft, &low,@9@1)){
                        ft++;fh++;
		}
                else {
                        @:shuffle(@1,ft,lt,fh,lh)@
                        while( @8_@5(lt, &low,@9@1) && lt>ft){
                                if(@8_@7(lt, &hgh,@9@1) ){
                                        @:shuffle(@1,lt,tmax,lh,hmax)@
                                        tmax--;hmax--;
                                }
                                lt--;lh--;
                        }
                }
        }
	if (ft ==  (@1*)Tloc(b, firstBUN +last+1)){ /*right and middle are empty*/
		*posl = -1;
		*posh = -1;
		return MAL_SUCCEED;
	}	
	if (tmax == lt){ /*then middle piece is empty*/
		*posl = (lt - t0) + 1;
		*posh = tmax - t0;
		return MAL_SUCCEED;
	}
	*posl = ft - t0;
	*posh = tmax - t0;

	return MAL_SUCCEED;
}
@


@- Local support functions and macros

@= shuffle
        tdummy = *@2;
        *@2 = *@3;
        *@3 = tdummy;

        hdummy = *@4;
        *@4 = *@5;
        *@5 = hdummy;
@

@= shuffleSideways
	hdummy = *(@1*) @3;
	*(@1*) @3= *(@1*) @4;
        *(@1*) @4= hdummy;

	tdummy= *(@2*) @5;
        *(@2*) @5= *(@2*) @6;
        *(@2*) @6 = tdummy;
@

@= crackInTwoUnorderedPiecesSideways_impl
str
CRKcrackUnorderedZeroSideways_@3_@1_@2( BAT *b, @1 mval, oid first, oid last, oid *pos){
        @1 *vm, *vl, *h0;
        @2 *vmt, *vlt;
        @1 hdummy;
        @2 tdummy;
	BUN firstBUN;
        /* set bounds for the iterator */

	firstBUN = BUNfirst(b);
        h0  = (@1*)Hloc(b, firstBUN);
        vm  = (@1*)Hloc(b, firstBUN+first);
        vl  = (@1*)Hloc(b, firstBUN+last );
        vmt = (@2*)Tloc(b, firstBUN+first);
        vlt = (@2*)Tloc(b, firstBUN+last );

        while(vm<vl) {
                if (@6_@4(vm, &mval,@7@1)){
                        vm  ++; 
			vmt ++;
		}
                else {
                        while( @6_@5(vl, &mval,@7@1) && vl>vm){
                                vl  --; 
				vlt --;
			}
                        @:shuffleSideways(@1,@2,vm,vl,vmt,vlt)@
                        vl  --;
			vlt --;
                        vm  ++;
			vmt ++;
                }
        }

	if (vl == vm) {
		if (@6_@5(vl, &mval,@7@1))
			*pos = (vl - h0) - 1; /*works for empty left piece also*/
		else{
			*pos = vl - h0;
			if (*pos==last) /*empty right piece*/
				*pos = *pos+(oid)1;
		}
	}
	else
		*pos = vl - h0;
		
        return MAL_SUCCEED;
}
@

@= crackInThreeUnorderedPiecesSideways_impl
str
CRKcrackUnorderedThreeSideways_@3_@4_@1_@2( BAT *b, @1 low, @1 hgh, oid first, oid last, oid *posl, oid *posh){
        @1 *vm, *vl, *hmax, *h0;
        @2 *vmt, *vlt, *hmaxt;
        @1 hdummy;
        @2 tdummy;
	BUN firstBUN;

        /* set bounds for the iterator */
	firstBUN = BUNfirst(b);
        h0    = (@1*)Hloc(b, firstBUN);

        vm    = (@1*)Hloc(b, firstBUN+first);
        hmax  = (@1*)Hloc(b, firstBUN+last);
        vmt   = (@2*)Tloc(b, firstBUN+first);
        hmaxt = (@2*)Tloc(b, firstBUN+last);
        while( @9_@8(hmax, &hgh,@[10]@1) && hmax>vm){
                hmax--; hmaxt--;
	}

	if (hmax == vm){
		if (@9_@8(hmax, &hgh,@[10]@1)){ /*left and middle are empty*/
			*posl =  1;
			*posh =  0;/*-1;*/
		}
		else if (@9_@6(hmax, &low,@[10]@1))  /*result is one bun*/
			*posl = *posh = hmax - h0;
		else{
			*posl = (hmax - h0) + (oid)1;
			*posh = hmax - h0;
		}
		return MAL_SUCCEED;
	}

        vl = hmax; vlt = hmaxt;
        while( @9_@6(vl, &low,@[10]@1) && vl>vm){
                /* move all high values into their final place */
                if( @9_@8(vl, &hgh,@[10]@1)){
                        @:shuffleSideways(@1,@2,vl,hmax,vlt,hmaxt)@
                        hmax--;hmaxt--;
                }
                vl--; vlt--;
        }
	if (vl == vm){ /* Left piece is empty */
		if (@9_@8(vl, &hgh,@[10]@1)){
			@:shuffleSideways(@1,@2,vl,hmax,vlt,hmaxt)@
                        hmax--;hmaxt--;
			*posl = vl - h0;
		}
		else if (@9_@6(vl, &low,@[10]@1))
			*posl = vl - h0;
		else
			*posl = (vl - h0) + (oid)1;
		*posh = hmax - h0;
		return MAL_SUCCEED;
	}
        /* vl point to the first <=low, all values >hg are beyond hmax */

        /* perform Zero crack first */
        while(vm<=vl) {
                if (@9_@5(vm, &low,@[10]@1)){
                        vm ++; vmt ++;
                } else {
                        @:shuffleSideways(@1,@2,vm,vl,vmt,vlt)@
                        while( @9_@6(vl, &low,@[10]@1) && vl>vm){
                                if(@9_@8(vl, &hgh,@[10]@1) ){
                                        @:shuffleSideways(@1,@2,vl,hmax,vlt,hmaxt)@
                                        hmax--; hmaxt--;
                                }
                                vl --; vlt --;
                        }
                }
        }
	if (vm == (@1*)Hloc(b,firstBUN+last+1)){ /* Right and middle are empty */
		*posl = (oid)-1;
		*posh = (oid)-1;
		return MAL_SUCCEED;
	}	
	if (hmax == vl){ /* Middle piece is empty */
		*posl = (vl - h0)  + (oid)1;
		*posh = hmax - h0;
		return MAL_SUCCEED;
	}
	*posl = vm - h0;
	*posh = hmax - h0;

	return MAL_SUCCEED;
}
@


@= crackInTwoUnorderedPiecesSideways_str_impl
str
CRKcrackUnorderedZeroSideways_@3_@1_str( BAT *b, @1 mval, oid first, oid last, oid *pos){
        @1 *vm, *vl, *h0;
        var_t *vmt, *vlt;
        @1 hdummy;
        var_t tdummy;
	BUN firstBUN;
        /* set bounds for the iterator */

	firstBUN = BUNfirst(b);
        h0  = (@1*)Hloc(b, firstBUN);
        vm  = (@1*)Hloc(b, firstBUN+first);
        vl  = (@1*)Hloc(b, firstBUN+last );
        vmt = (var_t*)Tloc(b, firstBUN+first);
        vlt = (var_t*)Tloc(b, firstBUN+last );

        while(vm<vl) {
                if (@6_@4(vm, &mval,@7@1)){
                        vm  ++; 
			vmt ++;
		}
                else {
                        while( @6_@5(vl, &mval,@7@1) && vl>vm){
                                vl  --; 
				vlt --;
			}
                        @:shuffleSideways(@1,var_t,vm,vl,vmt,vlt)@
                        vl  --;
			vlt --;
                        vm  ++;
			vmt ++;
                }
        }

	if (vl == vm) {
		if (@6_@5(vl, &mval,@7@1))
			*pos = (vl - h0) - 1; /*works for empty left piece also*/
		else{
			*pos = vl - h0;
			if (*pos==last) /*empty right piece*/
				*pos = *pos+(oid)1;
		}
	}
	else
		*pos = vl - h0;
		
        return MAL_SUCCEED;
}
@

@= crackInThreeUnorderedPiecesSideways_str_impl
str
CRKcrackUnorderedThreeSideways_@3_@4_@1_str( BAT *b, @1 low, @1 hgh, oid first, oid last, oid *posl, oid *posh){
        @1 *vm, *vl, *hmax, *h0;
        var_t *vmt, *vlt, *hmaxt;
        @1 hdummy;
        var_t tdummy;
	BUN firstBUN;

        /* set bounds for the iterator */
	firstBUN = BUNfirst(b);
        h0    = (@1*)Hloc(b, firstBUN);

        vm    = (@1*)Hloc(b, firstBUN+first);
        hmax  = (@1*)Hloc(b, firstBUN+last);
        vmt   = (var_t*)Tloc(b, firstBUN+first);
        hmaxt = (var_t*)Tloc(b, firstBUN+last);
        while( @9_@8(hmax, &hgh,@[10]@1) && hmax>vm){
                hmax--; hmaxt--;
	}

	if (hmax == vm){
		if (@9_@8(hmax, &hgh,@[10]@1)){ /*left and middle are empty*/
			*posl =  1;
			*posh =  0;/*-1;*/
		}
		else if (@9_@6(hmax, &low,@[10]@1))  /*result is one bun*/
			*posl = *posh = hmax - h0;
		else{
			*posl = (hmax - h0) + (oid)1;
			*posh = hmax - h0;
		}
		return MAL_SUCCEED;
	}

        vl = hmax; vlt = hmaxt;
        while( @9_@6(vl, &low,@[10]@1) && vl>vm){
                /* move all high values into their final place */
                if( @9_@8(vl, &hgh,@[10]@1)){
                        @:shuffleSideways(@1,var_t,vl,hmax,vlt,hmaxt)@
                        hmax--;hmaxt--;
                }
                vl--; vlt--;
        }
	if (vl == vm){ /* Left piece is empty */
		if (@9_@8(vl, &hgh,@[10]@1)){
			@:shuffleSideways(@1,var_t,vl,hmax,vlt,hmaxt)@
			*posl = vl - h0;
		}
		else if (@9_@6(vl, &low,@[10]@1))
			*posl = vl - h0;
		else
			*posl = (vl - h0) + (oid)1;
		*posh = hmax - h0;
		return MAL_SUCCEED;
	}
        /* vl point to the first <=low, all values >hg are beyond hmax */

        /* perform Zero crack first */
        while(vm<=vl) {
                if (@9_@5(vm, &low,@[10]@1)){
                        vm ++; vmt ++;
                } else {
                        @:shuffleSideways(@1,var_t,vm,vl,vmt,vlt)@
                        while( @9_@6(vl, &low,@[10]@1) && vl>vm){
                                if(@9_@8(vl, &hgh,@[10]@1) ){
                                        @:shuffleSideways(@1,var_t,vl,hmax,vlt,hmaxt)@
                                        hmax--; hmaxt--;
                                }
                                vl --; vlt --;
                        }
                }
        }
	if (vm == (@1*)Hloc(b,firstBUN+last+1)){ /* Right and middle are empty */
		*posl = 0;/*-1;*/
		*posh = 0;/*-1;*/
		return MAL_SUCCEED;
	}	
	if (hmax == vl){ /* Middle piece is empty */
		*posl = (vl - h0)  + (oid)1;
		*posh = hmax - h0;
		return MAL_SUCCEED;
	}
	*posl = vm - h0;
	*posh = hmax - h0;

	return MAL_SUCCEED;
}
@

@}
