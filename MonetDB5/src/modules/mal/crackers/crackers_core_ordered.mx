@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
@' Copyright August 2008- MonetDB B.V.
@' All Rights Reserved.

@f crackers_core_ordered
@a Martin Kersten, Stratos Idreos, Stefan Manegold
@d March 2006 - July 2007
@* Core cracking (ordered)


@+ Interface
 

@- Type expansion

@= TypeSwitch
@:@1(chr,simple,)@
@:@1(sht,simple,)@
@:@1(int,simple,)@
@:@1(lng,simple,)@
@:@1(flt,simple,)@
@:@1(dbl,simple,)@
@:@1(date,atom,TYPE_)@
@


@- Header file

@h
#ifndef _CRACKERS_CORE_ORDERED_H_
#define _CRACKERS_CORE_ORDERED_H_

/* Exported signatures */
@:TypeSwitch(CoreOrderedFunctions_decl)@

#endif /* _CRACKERS_CORE_ORDERED_H */
@


@- Exported signatures

@= CoreOrderedFunctions_decl
crackers_export str CRKcrackOrderedZero_@1 (int *res, int *bid, @1 *mid);
crackers_export str CRKcrackOrderedOne_@1 (int *res, int *bid, @1 *mid);
crackers_export str CRKcrackOrderedThree_@1 (int *res, int *bid, @1 *low, @1 *hgh);
@




@{
@+ Implementation


@- C file

@c
#include "mal_config.h"
#include "crackers.h"

/* Local support functions and macros */
@:TypeSwitch(operationsOrdered)@

/* Exported functions */
@:TypeSwitch(CoreOrderedFunctions_impl)@
@


@- Exported functions

@= CoreOrderedFunctions_impl
str
CRKcrackOrderedZero_@1 (int *res, int *bid, @1 *mid){
        BAT *b;
        str msg;
	oid pos;

        if ((b = BATdescriptor(*bid)) == NULL) 
                throw(MAL, "crackers.crack_zeroOrdered", "Cannot access descriptor");

        msg = CRKcrackOrderedZero_LE_@1(b,*mid, 0, BATcount(b)-1,&pos);

        BBPkeepref(b->batCacheid);
        *res = *bid;
        return msg;
}

str
CRKcrackOrderedOne_@1 (int *res, int *bid, @1 *mid){
        BAT *b;
	str msg;

        if ((b = BATdescriptor(*bid)) == NULL) 
                throw(MAL, "crackers.crack_oneOrdered", "Cannot access descriptor");

	msg = CRKcrackOrderedThree_LE_RE_@1(b,*mid,*mid, 0, BATcount(b)-1);
        BBPkeepref(b->batCacheid);
        *res = *bid;
        return msg;
}

str
CRKcrackOrderedThree_@1 (int *res, int *bid, @1 *low, @1 *hgh){
	BAT *b;
	str msg;
	oid posl,posh;

	if ((b = BATdescriptor(*bid)) == NULL) 
		throw(MAL, "crackers.crack_threeOrdered", "Cannot access descriptor");

        msg = CRKcrackOrderedThreeL_LO_RE_@1(b,*low,*hgh, 0, BATcount(b)-1,&posl, &posh);
	BBPkeepref(b->batCacheid);
	*res = *bid;
	return msg;
}
@


@- Local support functions and macros

@= operationsOrdered
@:crackInTwoOrderedPieces(@1,LE,<=,>)@
@(
@:crackInTwoOrderedPieces(@1,RE,<,>=)@
@)

@:crackInThreeOrderedPieces(@1,LE,RE,<,>=,<=,>)@
@(
@:crackInThreeOrderedPieces(@1,LE,RO,<,>=,<,>=)@
@:crackInThreeOrderedPieces(@1,LO,RE,<=,>,<=,>)@
@:crackInThreeOrderedPieces(@1,LO,RO,<=,>,<,>=)@
@)

@:crackInThreeOrderedPiecesL(@1,LO,RE,<=,>,<=,>)@
@(
@:crackInThreeOrderedPiecesL(@1,LE,RE,<,>=,<=,>)@
@:crackInThreeOrderedPiecesL(@1,LO,RO,<=,>,<,>=)@
@:crackInThreeOrderedPiecesL(@1,LE,RO,<,>=,<,>=)@
@)
@

@= moveOrdered
	while (@1 @6 ){
		@2 @4= 1;
		@3 @4= 1;
		@5
	}
@

@= OThree
	while (*tmpt @5){
		tmpt @2= 1;
		tmph @2= 1;
	}
	
	while (tmpt @3 ht){
		if ( *tmpt @4){
			if (*ct @5){
				scr_h[hil] = *ch;
				scr_t[hil] = *ct;				
				hil++;	
			}
			*ch = *tmph;
			*ct = *tmpt;
			ch @2= 1;
			ct @2= 1;
		
		}
		else{
			scr_h[mids] = *tmph;
			scr_t[mids] = *tmpt;				
			mids--;	
		}
		tmpt @2= 1;
		tmph @2= 1;
		while (tmpt @3 ht && *tmpt @5){
			tmpt @2= 1;
			tmph @2= 1;
		}
	}
	tmph = hh;
	tmpt = ht;
	ct @2= (scrH-mids)+hil;
	for(; tmpt @7 ct; tmph @6=1, tmpt @6=1){
		if (*tmpt @5){
			*hh = *tmph;
			*ht = *tmpt;
			hh @6= 1;
			ht @6= 1;
		}
	}
	i=hil-1;
	while(1){
		if (*tmpt @5){
			*hh = *tmph;
			*ht = *tmpt;
			hh @6= 1;
			ht @6= 1;
		}	
		*tmph = scr_h[i];
		*tmpt = scr_t[i];
		tmpt @6= 1;
		tmph @6= 1;
		
		i--;
		if (i==0) {
			if (*tmpt @5){
                        	*hh = *tmph;
                     		*ht = *tmpt;
                        	hh @6= 1;
                        	ht @6= 1;
                	}
                	*tmph = scr_h[i];
                	*tmpt = scr_t[i];
                	tmpt @6= 1;
                	tmph @6= 1;
		
			break;
		}
	}

	i = mids + 1;
	for (; i <= scrH; i++){
		 if (*tmpt @5){
                        *hh = *tmph;
                        *ht = *tmpt;
                        hh @6= 1;
                        ht @6= 1;
                }
		*tmph = scr_h[i];
		*tmpt = scr_t[i];
		tmph @6= 1;
		tmpt @6= 1;
	}
@

@= crackInThreeOrderedPieces
static str
CRKcrackOrderedThree_@2_@3_@1(BAT *b, @1 low, @1 hgh, oid idx_first, oid idx_last){
	oid *hh, *tmph, *ch, *fh;
	@1  *ht, *tmpt, *ct, *ft, *s, *t;
	oid *scr_h;
	@1  *scr_t;
	oid scr_size = idx_last - idx_first +1;
	oid hghShrinked = 0, lowShrinked = 0, scrH, hil, mids, probe, j;
	oid i;
	BUN first;

	first = BUNfirst(b);
	tmph = (oid*)Hloc(b, first + idx_first);
	tmpt = (@1 *)Tloc(b, first + idx_first);
	hh   = (oid*)Hloc(b, first + idx_last);
	ht   = (@1 *)Tloc(b, first + idx_last);

	@:moveOrdered(*tmpt @4 low,tmph,tmpt,+,lowShrinked++;,&& tmpt<=ht)@
	@:moveOrdered(*ht @7 hgh ,hh,ht,-,hghShrinked++;,&& ht<=tmpt)@

	if (lowShrinked == idx_last - idx_first +1) return MAL_SUCCEED;
	if (hghShrinked == idx_last - idx_first +1) return MAL_SUCCEED;

	scrH = scr_size-1;	
	hil = 0; mids = scrH;
	ch = tmph; ct = tmpt;
	scr_h = (oid*) GDKmalloc(scr_size * sizeof(oid));
	scr_t = (@1 *) GDKmalloc(scr_size * sizeof(@1 ));

	probe = 25;
	t = tmpt;
	s = tmpt+(2*probe);
	j=0;
	for (;t<s;t+=1)
		j += *t @4 low;

	if (j > probe){
		ch = tmph; ct = tmpt;
		@:OThree(@1,+,<=,@4 low,@7 hgh,-,>=)@
	}
	else{
		ch = hh; ct = ht;
		fh = tmph; ft = tmpt;
		tmph = hh; tmpt = ht;
		hh = fh; ht = ft;
		@:OThree(@1,-,>=,@7 hgh,@4 low,+,<=)@
	}
	GDKfree(scr_h);
	GDKfree(scr_t);
	
	return MAL_SUCCEED;
}
@

@= crackInThreeOrderedPiecesL
static str
CRKcrackOrderedThreeL_@2_@3_@1(BAT *b, @1 low, @1 hgh, oid idx_first, oid idx_last, oid *posl, oid *posh){
	oid *lh, *hh, *tmph, *fh, *mh;
	@1 *lt, *ht, *tmpt, *ft, *mt, *t, *s, *t0;
	oid *scr_h,*mscr_h;
	@1  *scr_t,*mscr_t;
	oid scr_size = idx_last - idx_first +1;
	oid hghShrinked = 0, lowShrinked = 0, scrH, hp, hil, mids, mmids, j, probe;
	oid pos1, pos2;
	BUN first;

	first = BUNfirst(b);
	t0   = (@1 *)Tloc(b, first);

	lh = (oid*)Hloc(b, first + idx_first);
	lt = (@1 *)Tloc(b, first + idx_first);
	hh   = (oid*)Hloc(b, first + idx_last);
	ht   = (@1 *)Tloc(b, first + idx_last);

	@:moveOrdered(*lt @4 low,lh,lt,+,lowShrinked++;,&& lt<=ht)@
	@:moveOrdered(*ht @7 hgh ,hh,ht,-,hghShrinked++;,&& ht>=lt)@

	/* These are different cases. For now just make sure that the result will be empty.
	   TODO : when the index will learn from empty results return the appropriate information*/
	
	if (lowShrinked == scr_size) {
		*posl = -1;
		*posh = -1;
		return MAL_SUCCEED;
	}
	if (hghShrinked == scr_size){
		*posl =  1;
		*posh = -1;
		return MAL_SUCCEED;
	}
	/*Middle piece is empty and lt = ht + 1*/
	if (lowShrinked + hghShrinked == scr_size){
		*posl = (oid) (lt - t0);
		*posh = (oid) (ht - t0);
		return MAL_SUCCEED;
	}

	scrH = scr_size-1;	
	hp = 0; hil = 0; mids = scrH; mmids = 0;
	scr_h  = (oid*) GDKmalloc(scr_size * sizeof(oid));
	scr_t  = (@1 *) GDKmalloc(scr_size * sizeof(@1 ));
	mscr_h = (oid*) GDKmalloc(scr_size * sizeof(oid));
	mscr_t = (@1 *) GDKmalloc(scr_size * sizeof(@1 ));

	probe = 100;
	t = lt;
	s = lt+(2*probe);
	j=0;
	for (;t<s;t+=1)
		j += *t @4 low;
	if (j > probe){
		tmph = lh;
		tmpt = lt;	
		@:OThreeLateCopying(@1,+,<=,@4 low,@7 hgh,-,>=,@5,@6)@
		*posl = pos1;
		*posh = pos2;
	}
	else{
		tmph = hh;
		tmpt = ht;	
		fh = lh; ft = lt;
		lh = hh; lt = ht;
		hh = fh; ht = ft;
		@:OThreeLateCopying(@1,-,>=,@7 hgh,@4 low,+,<=,@5,@6)@
		*posl = pos2;
		*posh = pos1;
	}
	
	GDKfree(scr_h);
	GDKfree(scr_t);
	return MAL_SUCCEED;
}
@

@= OThreeLateCopying
{
	@1 *tmp1, *tmp2;
	oid i;

	while (*tmpt @5){
		tmpt @2= 1;
		tmph @2= 1;
	}
	tmp1 = lt;
	while (tmpt @3 ht){
		if ( *tmpt @4){
			if (*lt @5){
				scr_h[hil] = *lh;
				scr_t[hil] = *lt;				
				hil++;	
			}
			if (*lt @8 low && *lt @9 hgh){
				scr_h[mids] = *lh;
				scr_t[mids] = *lt;				
				mids--;	
			}
			*lh = *tmph;
			*lt = *tmpt;
			lh @2= 1;
			lt @2= 1;
		}
		hp++;
		tmpt @2= 1;
		tmph @2= 1;
		while (*tmpt @5 && tmpt @3 ht){
			tmpt @2= 1;
			tmph @2= 1;
		}
	}
	
	pos1 = (oid) (lt - t0); 

	tmph = hh;
	tmpt = ht;
	tmp2 = lt;
	tmp1 @2= hp+hil;
	for(; tmpt @7 tmp1; tmph @6=1, tmpt @6=1){
		if (*tmpt @5 ){
			*hh = *tmph;
			*ht = *tmpt;
			hh @6= 1;
			ht @6= 1;
		}
		if (*tmpt @8 low && *tmpt @9 hgh){
			mscr_h[mmids] = *tmph;
			mscr_t[mmids] = *tmpt;				
			mmids++;	
		}
	}
	i= hil-1;
	while (1){
		if (*tmpt @5){
			*hh = *tmph;
			*ht = *tmpt;
			hh @6= 1;
			ht @6= 1;
		}	
		if (*tmpt @8 low && *tmpt @9 hgh){
			mscr_h[mmids] = *tmph;
			mscr_t[mmids] = *tmpt;				
			mmids++;	
		}
		*tmph = scr_h[i];
		*tmpt = scr_t[i];
		tmpt @6= 1;
		tmph @6= 1;

		i--;
		if (i==0){
			if (*tmpt @5){
				*hh = *tmph;
				*ht = *tmpt;
				hh @6= 1;
				ht @6= 1;
			}	
			if (*tmpt @8 low && *tmpt @9 hgh){
				mscr_h[mmids] = *tmph;
				mscr_t[mmids] = *tmpt;				
				mmids++;	
			}
			*tmph = scr_h[i];
			*tmpt = scr_t[i];
			tmpt @6= 1;
			tmph @6= 1;

			break;
		}
	}

	pos2 = (oid) (tmpt - t0); 

	i = 0;
	for (; i < mmids; i++){
		 if (*tmpt @5 ){
                        *hh = *tmph;
                        *ht = *tmpt;
                        hh @6= 1;
                        ht @6= 1;
                }
		if (*tmpt @8 low && *tmpt @9 hgh){
			mscr_h[mmids] = *tmph;
			mscr_t[mmids] = *tmpt;				
			mmids++;	
		}
		*tmph = mscr_h[i];
		*tmpt = mscr_t[i];
		tmph @6= 1;
		tmpt @6= 1;
	}
	tmp2 @2= scrH-mids;
	/*todo check as in the zero case*/
	mh = tmph;
	mt = tmpt;
	for(; tmpt @7 tmp2; tmph @6=1, tmpt @6=1){
		if (*tmpt @5 ){
                        *hh = *tmph;
                        *ht = *tmpt;
                        hh @6= 1;
                        ht @6= 1;
                }
		if (*tmpt @8 low && *tmpt @9 hgh){
			if (mt != tmpt){
				*mh = *tmph;
                        	*mt = *tmpt;
			}
                        mh @6= 1;
                        mt @6= 1;
		}
	}

        i = mids+1;
        for (; i <= scrH; i++){
                 if (*tmpt @5 ){
                        *hh = *tmph;
                        *ht = *tmpt;
                        hh @6= 1;
                        ht @6= 1;
                }
                if (*tmpt @8 low && *tmpt @9 hgh){
	        	*mh = *tmph;
                        *mt = *tmpt;
                        mh @6= 1;
                        mt @6= 1;
                }
                *tmph = scr_h[i];
                *tmpt = scr_t[i];
                tmph @6= 1;
                tmpt @6= 1;
        }
}
@

@= OrderedZero
		while (tmpt @3 ht){
			while (*tmpt @4 mid){
				tmpt @2=1;
				tmph @2=1;
			}
			if (*ct @4 mid){
				scr_h[hil] = *ch;
				scr_t[hil] = *ct;				
				hil++;	
			}
			*ch = *tmph;
			*ct = *tmpt;
			ch @2= 1;
			ct @2= 1;
			
			tmpt @2= 1;
			tmph @2= 1;
		}
		tmph @5= 2;
		tmpt @5= 2;
	
		/* Take the position where the last BUN of the left piece is. */
		*pos = (oid) (ct - t0) @7; 

		ct  @2= hil;
		/* Extreme case where all lows(or all but one, or all but two) where in the hgh partition 
                   (or opposite depending how we move) */
		if (ct @6 tmpt ){
			if (ct == tmpt || ct == tmpt @2 1) {
				i=hil;
				while(1){
					if (*tmpt @4 mid){
						*hh = *tmph;
						*ht = *tmpt;
						hh @5= 1;
						ht @5= 1;
					}	
					tmpt @5= 1;
					tmph @5= 1;
				
					i--;
					if (i==0){
						if (*tmpt @4 mid){
                                                	*hh = *tmph;
                                                	*ht = *tmpt;
                                                	hh @5= 1;
                                                	ht @5= 1;
                                        	}
                                        	tmpt @5= 1;
                                        	tmph @5= 1;					

						break;
					}
				}
				i=hil-1;
				while(1){
					*hh = scr_h[i];
					*ht = scr_t[i];
					ht @5= 1;
					hh @5= 1;
			
					i--;
					if (i==0){
						*hh = scr_h[i];
                                        	*ht = scr_t[i];
                                        	ht @5= 1;
                                        	hh @5= 1;
						break;
					}
				}
			}
			else{
				i=hil-1;
				while(1){
					*hh = scr_h[i];
					*ht = scr_t[i];
					ht @5= 1;
					hh @5= 1;
					
					i--;
                                        if (i==0){
						*hh = scr_h[i];
                                        	*ht = scr_t[i];
                                        	ht @5= 1;
                                        	hh @5= 1;
						break;
					}
				}
			}
			return MAL_SUCCEED;
		}

		for(; tmpt @6 ct; tmph @5=1, tmpt @5=1){
			if (*tmpt @4 mid){
				*hh = *tmph;
				*ht = *tmpt;
				hh @5= 1;
				ht @5= 1;
			}
		}
		i=hil-1;
		while(1){
			if (*tmpt @4 mid){
				*hh = *tmph;
				*ht = *tmpt;
				hh @5= 1;
				ht @5= 1;
			}	
			*tmph = scr_h[i];
			*tmpt = scr_t[i];
			tmpt @5= 1;
			tmph @5= 1;

			i--;
			if(i==0){
				if (*tmpt @4 mid){
        	                        *hh = *tmph;
                	                *ht = *tmpt;
                        	        hh @5= 1;
          	                      	ht @5= 1;
                	        }
                        	*tmph = scr_h[i];
               		        *tmpt = scr_t[i];
                        	tmpt @5= 1;
                        	tmph @5= 1;

				break;
			}
		}
@

@= crackInTwoOrderedPieces
static str
CRKcrackOrderedZero_@2_@1(BAT *b, @1 mid, oid idx_first, oid idx_last, oid *pos){
	oid *hh, *tmph, *fh, *ch;
	@1  *ht, *tmpt, *ft, *ct, *t, *s, *t0;
	oid *scr_h;
	@1  *scr_t;
	oid hghShrinked = 0, lowShrinked = 0;
	oid j=0, hil=0, scr_size, probe = 25;
	oid i;
	BUN first;

	first = BUNfirst(b);
	t0   = (@1 *)Tloc(b, first);

	tmph = (oid*)Hloc(b, first + idx_first);
	tmpt = (@1 *)Tloc(b, first + idx_first);
	hh   = (oid*)Hloc(b, first + idx_last);
	ht   = (@1 *)Tloc(b, first + idx_last);

	@:moveOrdered(*tmpt @3 mid,tmph,tmpt,+,lowShrinked++;,&& tmpt<=ht)@
	@:moveOrdered(*ht @4 mid,hh,ht,-,hghShrinked++;,&& ht>=tmpt)@
	if (lowShrinked == idx_last - idx_first + 1) {
		*pos = idx_last + 1;
		return MAL_SUCCEED;
	}
	if (hghShrinked == idx_last - idx_first + 1){
		*pos = idx_first-1;
		return MAL_SUCCEED;
	}
	
	if (ht == tmpt + 1){
		oid dh = *tmph;
		@1  dt = *tmpt;
		*tmph = *hh;
		*tmpt = *ht;

		*pos = (oid) (tmpt - t0); 

		*hh = dh;
		*ht = dt;

		return MAL_SUCCEED;
	}

	if (ht == tmpt - 1){
		*pos = (oid) (ht - t0); 
		return MAL_SUCCEED;
	}	

	scr_size = (idx_last - idx_first +1 -lowShrinked -hghShrinked);
	if (scr_size >=2) scr_size = scr_size/2;
	scr_h = (oid*) GDKmalloc(scr_size * sizeof(oid));
	scr_t = (@1 *) GDKmalloc(scr_size * sizeof(@1 ));
	t = tmpt;
	s = tmpt+(2*probe);
	for (;t<s;t+=1)
		j+=*t @3 mid;
	
	if (j > probe){
		ch = tmph; ct = tmpt;
		@:OrderedZero(@1,+,<=,@4,-,>=, -1)@
	}
	else{
		ch =hh; ct = ht;
		fh = tmph, ft = tmpt;
		tmph =hh; tmpt = ht;
		hh = fh; ht = ft;
		@:OrderedZero(@1,-,>=,@3,+,<=)@
	}
	GDKfree(scr_h);
	GDKfree(scr_t);
	return MAL_SUCCEED;
}
@

@]
