@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2008 CWI.
@' All Rights Reserved.

@f crackers_core_ordered
@a Martin Kersten, Stratos Idreos, Stefan Manegold
@d March 2006 - July 2007
@* Core cracking (ordered)


@+ Interface
 

@- Type expansion

@= TypeSwitch
@:@1(chr,simple,)@
@:@1(sht,simple,)@
@:@1(int,simple,)@
@:@1(lng,simple,)@
@:@1(flt,simple,)@
@:@1(dbl,simple,)@
@:@1(date,atom,TYPE_)@
@


@- Header file

@h
#ifndef _CRACKERS_CORE_ORDERED_H_
#define _CRACKERS_CORE_ORDERED_H_

/* Exported signatures */
@:TypeSwitch(CoreOrderedFunctions_decl)@

#endif /* _CRACKERS_CORE_ORDERED_H */
@


@- Exported signatures

@= CoreOrderedFunctions_decl
crackers_export str CRKcrackOrderedZero_@1 (int *res, int *bid, @1 *mid);
crackers_export str CRKcrackOrderedOne_@1 (int *res, int *bid, @1 *mid);
crackers_export str CRKcrackOrderedThree_@1 (int *res, int *bid, @1 *low, @1 *hgh);
@




@{
@+ Implementation


@- C file

@c
#include "mal_config.h"
#include "crackers.h"

/* Local support functions and macros */
@:TypeSwitch(operationsOrdered)@

/* Exported functions */
@:TypeSwitch(CoreOrderedFunctions_impl)@
@


@- Exported functions

@= CoreOrderedFunctions_impl
str
CRKcrackOrderedZero_@1 (int *res, int *bid, @1 *mid){
        BAT *b;
        str msg;
	lng pos;

        if ((b = BATdescriptor(*bid)) == NULL) 
                throw(MAL, "crackers.crack_zeroOrdered", "Cannot access descriptor");

        msg = CRKcrackOrderedZero_LE_@1(b,*mid, 0, BATcount(b)-1,&pos);

        BBPkeepref(b->batCacheid);
        *res = *bid;
        return msg;
}

str
CRKcrackOrderedOne_@1 (int *res, int *bid, @1 *mid){
        BAT *b;
	str msg;

        if ((b = BATdescriptor(*bid)) == NULL) 
                throw(MAL, "crackers.crack_oneOrdered", "Cannot access descriptor");

	msg = CRKcrackOrderedThree_LE_RE_@1(b,*mid,*mid, 0, BATcount(b)-1);
        BBPkeepref(b->batCacheid);
        *res = *bid;
        return msg;
}

str
CRKcrackOrderedThree_@1 (int *res, int *bid, @1 *low, @1 *hgh){
	BAT *b;
	str msg;
	lng posl,posh;

	if ((b = BATdescriptor(*bid)) == NULL) 
		throw(MAL, "crackers.crack_threeOrdered", "Cannot access descriptor");

        msg = CRKcrackOrderedThreeL_LO_RE_@1(b,*low,*hgh, 0, BATcount(b)-1,&posl, &posh);
	BBPkeepref(b->batCacheid);
	*res = *bid;
	return msg;
}
@


@- Local support functions and macros

@= operationsOrdered
@:crackInTwoOrderedPieces(@1,LE,<=,>)@
@(
@:crackInTwoOrderedPieces(@1,RE,<,>=)@
@)

@:crackInThreeOrderedPieces(@1,LE,RE,<,>=,<=,>)@
@(
@:crackInThreeOrderedPieces(@1,LE,RO,<,>=,<,>=)@
@:crackInThreeOrderedPieces(@1,LO,RE,<=,>,<=,>)@
@:crackInThreeOrderedPieces(@1,LO,RO,<=,>,<,>=)@
@)

@:crackInThreeOrderedPiecesL(@1,LO,RE,<=,>,<=,>)@
@(
@:crackInThreeOrderedPiecesL(@1,LE,RE,<,>=,<=,>)@
@:crackInThreeOrderedPiecesL(@1,LO,RO,<=,>,<,>=)@
@:crackInThreeOrderedPiecesL(@1,LE,RO,<,>=,<,>=)@
@)
@

@= moveOrdered
	while (@1 @6 ){
		@2 @4= xx;
		@3 @4= xx;
		@5
	}
@

@= OThree
	while (*(@1*)tmpt @5){
		tmpt @2= xx;
		tmph @2= xx;
	}
	
	while (tmpt @3 ht){
		if ( *(@1*)tmpt @4){
			if (*(@1*)ct @5){
				scr_h[hil] = *(oid*)ch;
				scr_t[hil] = *(@1* )ct;				
				hil++;	
			}
			*(oid*)ch = *(oid*)tmph;
			*(@1 *)ct = *(@1 *)tmpt;
			ch @2= xx;
			ct @2= xx;
		
		}
		else{
			scr_h[mids] = *(oid*)tmph;
			scr_t[mids] = *(@1* )tmpt;				
			mids--;	
		}
		tmpt @2= xx;
		tmph @2= xx;
		while (tmpt @3 ht && *(@1*)tmpt @5){
			tmpt @2= xx;
			tmph @2= xx;
		}
	}
	tmph = hh;
	tmpt = ht;
	ct @2= xx*((scrH-mids)+hil);
	for(; tmpt @7 ct; tmph @6=xx, tmpt @6=xx){
		if (*(@1*)tmpt @5){
			*(oid*)hh = *(oid*)tmph;
			*(@1 *)ht = *(@1 *)tmpt;
			hh @6= xx;
			ht @6= xx;
		}
	}
	for (i= hil-1; i >= 0; i--){
		if (*(@1*)tmpt @5){
			*(oid*)hh = *(oid*)tmph;
			*(@1 *)ht = *(@1 *)tmpt;
			hh @6= xx;
			ht @6= xx;
		}	
		*(oid*)tmph = scr_h[i];
		*(@1 *)tmpt = scr_t[i];
		tmpt @6= xx;
		tmph @6= xx;
	}
	i = mids + 1;
	for (; i <= scrH; i++){
		 if (*(@1*)tmpt @5){
                        *(oid*)hh = *(oid*)tmph;
                        *(@1 *)ht = *(@1 *)tmpt;
                        hh @6= xx;
                        ht @6= xx;
                }
		*(oid*)tmph = scr_h[i];
		*(@1 *)tmpt = scr_t[i];
		tmph @6= xx;
		tmpt @6= xx;
	}
@

@= crackInThreeOrderedPieces
static str
CRKcrackOrderedThree_@2_@3_@1(BAT *b, @1 low, @1 hgh, int idx_first, int idx_last){
	BUN hh, ht, tmpt, tmph, ch, ct, t, s, fh, ft;
	oid *scr_h;
	@1  *scr_t;
	int scr_size = idx_last - idx_first +1;
	int hghShrinked = 0, lowShrinked = 0, scrH, hil, mids, probe, j;
	int xx = BUNsize(b);
	int i;

	tmph = BUNhloc(b, BUNptr(b, idx_first));
	tmpt = BUNtloc(b, BUNptr(b, idx_first));
	ht = BUNtloc(b, BUNptr(b, idx_last));
	hh = BUNhloc(b, BUNptr(b, idx_last));

	@:moveOrdered(*(@1*)tmpt @4 low,tmph,tmpt,+,lowShrinked++;,&& tmpt<=ht)@
	@:moveOrdered(*(@1*)ht @7 hgh ,hh,ht,-,hghShrinked++;,&& ht<=tmpt)@

	if (lowShrinked == idx_last - idx_first +1) return MAL_SUCCEED;
	if (hghShrinked == idx_last - idx_first +1) return MAL_SUCCEED;

	scrH = scr_size-1;	
	hil = 0; mids = scrH;
	ch = tmph; ct = tmpt;
	scr_h = (oid*) GDKmalloc(scr_size * sizeof(oid));
	scr_t = (@1 *) GDKmalloc(scr_size * sizeof(@1 ));

	probe = 25;
	t = tmpt;
	s = tmpt+(2*probe*xx);
	j=0;
	for (;t<s;t+=xx)
		j += *(@1*)t @4 low;

	if (j > probe){
		ch = tmph; ct = tmpt;
		@:OThree(@1,+,<=,@4 low,@7 hgh,-,>=)@
	}
	else{
		ch = hh; ct = ht;
		fh = tmph; ft = tmpt;
		tmph = hh; tmpt = ht;
		hh = fh; ht = ft;
		@:OThree(@1,-,>=,@7 hgh,@4 low,+,<=)@
	}
	GDKfree(scr_h);
	GDKfree(scr_t);
	
	return MAL_SUCCEED;
}
@

@= crackInThreeOrderedPiecesL
static str
CRKcrackOrderedThreeL_@2_@3_@1(BAT *b, @1 low, @1 hgh, lng idx_first, lng idx_last, lng *posl, lng *posh){
	BUN lh, lt, hh, ht, tmpt, tmph, t, s, fh, ft, mh, mt;
	oid *scr_h,*mscr_h;
	@1  *scr_t,*mscr_t;
	int scr_size = idx_last - idx_first +1;
	int hghShrinked = 0, lowShrinked = 0, scrH, hp, hil, mids, mmids, j, probe;
	int xx = BUNsize(b);
	lng pos1, pos2;

	lh = BUNhloc(b, BUNptr(b, idx_first));
	lt = BUNtloc(b, BUNptr(b, idx_first));
	ht = BUNtloc(b, BUNptr(b, idx_last));
	hh = BUNhloc(b, BUNptr(b, idx_last));

	@:moveOrdered(*(@1*)lt @4 low,lh,lt,+,lowShrinked++;,&& lt<=ht)@
	@:moveOrdered(*(@1*)ht @7 hgh ,hh,ht,-,hghShrinked++;,&& ht>=lt)@

	/* These are different cases. For now just make sure that the result will be empty.
	   TODO : when the index will learn from empty results return the appropriate information*/
	
	if (lowShrinked == scr_size) {
		*posl = -1;
		*posh = -1;
		return MAL_SUCCEED;
	}
	if (hghShrinked == scr_size){
		*posl =  1;
		*posh = -1;
		return MAL_SUCCEED;
	}
	/*Middle piece is empty and lt = ht + 1*/
	if (lowShrinked + hghShrinked == scr_size){
		*posl =  BUNindex(b,lt);
		*posh =  BUNindex(b,ht);
		return MAL_SUCCEED;
	}

	scrH = scr_size-1;	
	hp = 0; hil = 0; mids = scrH; mmids = 0;
	scr_h = (oid*) GDKmalloc(scr_size * sizeof(oid));
	scr_t = (@1 *) GDKmalloc(scr_size * sizeof(@1 ));
	mscr_h = (oid*) GDKmalloc(scr_size * sizeof(oid));
	mscr_t = (@1 *) GDKmalloc(scr_size * sizeof(@1 ));

	probe = 100;
	t = lt;
	s = lt+(2*probe*xx);
	j=0;
	for (;t<s;t+=xx)
		j += *(@1*)t @4 low;
	if (j > probe){
		tmph = lh;
		tmpt = lt;	
		@:OThreeLateCopying(@1,+,<=,@4 low,@7 hgh,-,>=,@5,@6)@
		*posl = pos1;
		*posh = pos2;
	}
	else{
		tmph = hh;
		tmpt = ht;	
		fh = lh; ft = lt;
		lh = hh; lt = ht;
		hh = fh; ht = ft;
		@:OThreeLateCopying(@1,-,>=,@7 hgh,@4 low,+,<=,@5,@6)@
		*posl = pos2;
		*posh = pos1;
	}
	
	GDKfree(scr_h);
	GDKfree(scr_t);
	return MAL_SUCCEED;
}
@

@= OThreeLateCopying
{
	BUN tmp1, tmp2;
	int i;

	while (*(@1*)tmpt @5){
		tmpt @2= xx;
		tmph @2= xx;
	}
	tmp1 = lt;
	while (tmpt @3 ht){
		if ( *(@1*)tmpt @4){
			if (*(@1*)lt @5){
				scr_h[hil] = *(oid*)lh;
				scr_t[hil] = *(@1* )lt;				
				hil++;	
			}
			if (*(@1*)lt @8 low && *(@1*)lt @9 hgh){
				scr_h[mids] = *(oid*)lh;
				scr_t[mids] = *(@1* )lt;				
				mids--;	
			}
			*(oid*)lh = *(oid*)tmph;
			*(@1 *)lt = *(@1 *)tmpt;
			lh @2= xx;
			lt @2= xx;
		}
		hp++;
		tmpt @2= xx;
		tmph @2= xx;
		while (*(@1*)tmpt @5 && tmpt @3 ht){
			tmpt @2= xx;
			tmph @2= xx;
		}
	}
	
	pos1 = BUNindex(b,lt);

	tmph = hh;
	tmpt = ht;
	tmp2 = lt;
	tmp1 @2= xx*(hp+hil);
	for(; tmpt @7 tmp1; tmph @6=xx, tmpt @6=xx){
		if (*(@1*)tmpt @5 ){
			*(oid*)hh = *(oid*)tmph;
			*(@1 *)ht = *(@1 *)tmpt;
			hh @6= xx;
			ht @6= xx;
		}
		if (*(@1*)tmpt @8 low && *(@1*)tmpt @9 hgh){
			mscr_h[mmids] = *(oid*)tmph;
			mscr_t[mmids] = *(@1* )tmpt;				
			mmids++;	
		}
	}
	for (i= hil-1; i >= 0; i--){
		if (*(@1*)tmpt @5){
			*(oid*)hh = *(oid*)tmph;
			*(@1 *)ht = *(@1 *)tmpt;
			hh @6= xx;
			ht @6= xx;
		}	
		if (*(@1*)tmpt @8 low && *(@1*)tmpt @9 hgh){
			mscr_h[mmids] = *(oid*)tmph;
			mscr_t[mmids] = *(@1* )tmpt;				
			mmids++;	
		}
		*(oid*)tmph = scr_h[i];
		*(@1 *)tmpt = scr_t[i];
		tmpt @6= xx;
		tmph @6= xx;
	}

	pos2 = BUNindex(b,tmpt);

	i = 0;
	for (; i < mmids; i++){
		 if (*(@1*)tmpt @5 ){
                        *(oid*)hh = *(oid*)tmph;
                        *(@1 *)ht = *(@1 *)tmpt;
                        hh @6= xx;
                        ht @6= xx;
                }
		if (*(@1*)tmpt @8 low && *(@1*)tmpt @9 hgh){
			mscr_h[mmids] = *(oid*)tmph;
			mscr_t[mmids] = *(@1* )tmpt;				
			mmids++;	
		}
		*(oid*)tmph = mscr_h[i];
		*(@1 *)tmpt = mscr_t[i];
		tmph @6= xx;
		tmpt @6= xx;
	}
	tmp2 @2= xx*(scrH-mids);
	/*todo check as in the zero case*/
	mh= tmph;
	mt = tmpt;
	for(; tmpt @7 tmp2; tmph @6=xx, tmpt @6=xx){
		if (*(@1*)tmpt @5 ){
                        *(oid*)hh = *(oid*)tmph;
                        *(@1 *)ht = *(@1 *)tmpt;
                        hh @6= xx;
                        ht @6= xx;
                }
		if (*(@1*)tmpt @8 low && *(@1*)tmpt @9 hgh){
			if (mt != tmpt){
				*(oid*)mh = *(oid*)tmph;
                        	*(@1 *)mt = *(@1 *)tmpt;
			}
                        mh @6= xx;
                        mt @6= xx;
		}
	}

        i = mids+1;
        for (; i <= scrH; i++){
                 if (*(@1*)tmpt @5 ){
                        *(oid*)hh = *(oid*)tmph;
                        *(@1 *)ht = *(@1 *)tmpt;
                        hh @6= xx;
                        ht @6= xx;
                }
                if (*(@1*)tmpt @8 low && *(@1*)tmpt @9 hgh){
	        	*(oid*)mh = *(oid*)tmph;
                        *(@1 *)mt = *(@1 *)tmpt;
                        mh @6= xx;
                        mt @6= xx;
                }
                *(oid*)tmph = scr_h[i];
                *(@1 *)tmpt = scr_t[i];
                tmph @6= xx;
                tmpt @6= xx;
        }
}
@

@= OrderedZero
		while (tmpt @3 ht){
			while (*(@1*)tmpt @4 mid){
				tmpt @2=xx;
				tmph @2=xx;
			}
			if (*(@1*)ct @4 mid){
				scr_h[hil] = *(oid*)ch;
				scr_t[hil] = *(@1* )ct;				
				hil++;	
			}
			*(oid*)ch = *(oid*)tmph;
			*(@1 *)ct = *(@1 *)tmpt;
			ch @2= xx;
			ct @2= xx;
			
			tmpt @2= xx;
			tmph @2= xx;
		}
		tmph @5= 2*xx;
		tmpt @5= 2*xx;
	
		/* Take the position where the last BUN of the left piece is. */
		*pos = BUNindex(b,ct @7);

		ct  @2= xx*hil;
		/* Extreme case where all lows(or all but one, or all but two) where in the hgh partition 
                   (or opposite depending how we move) */
		if (ct @6 tmpt ){
			if (ct == tmpt || ct == tmpt @2 xx) {
				for (i=hil; i >=0 ; i--){
					if (*(@1*)tmpt @4 mid){
						*(oid*)hh = *(oid*)tmph;
						*(@1 *)ht = *(@1 *)tmpt;
						hh @5= xx;
						ht @5= xx;
					}	
					tmpt @5= xx;
					tmph @5= xx;
				}
				for (i=hil-1; i >=0 ; i--){
					*(oid*)hh = scr_h[i];
					*(@1 *)ht = scr_t[i];
					ht @5= xx;
					hh @5= xx;
				}

			}
			else{
				for (i=hil-1; i >=0 ; i--){
					*(oid*)hh = scr_h[i];
					*(@1 *)ht = scr_t[i];
					ht @5= xx;
					hh @5= xx;
				}
			}
			return MAL_SUCCEED;
		}

		for(; tmpt @6 ct; tmph @5=xx, tmpt @5=xx){
			if (*(@1*)tmpt @4 mid){
				*(oid*)hh = *(oid*)tmph;
				*(@1 *)ht = *(@1 *)tmpt;
				hh @5= xx;
				ht @5= xx;
			}
		}
		for (i=hil-1; i >=0 ; i--){
			if (*(@1*)tmpt @4 mid){
				*(oid*)hh = *(oid*)tmph;
				*(@1 *)ht = *(@1 *)tmpt;
				hh @5= xx;
				ht @5= xx;
			}	
			*(oid*)tmph = scr_h[i];
			*(@1 *)tmpt = scr_t[i];
			tmpt @5= xx;
			tmph @5= xx;
		}
@

@= crackInTwoOrderedPieces
static str
CRKcrackOrderedZero_@2_@1(BAT *b, @1 mid, lng idx_first, lng idx_last, lng *pos){
	BUN hh, ht, tmpt, tmph, fh, ft;
	BUN ch, ct, t, s;
	oid *scr_h;
	@1  *scr_t;
	lng hghShrinked = 0, lowShrinked = 0;
	int xx = BUNsize(b);
	int j=0, hil=0, scr_size, probe = 25;
	int i;

	tmph = BUNhloc(b, BUNptr(b, idx_first));
	tmpt = BUNtloc(b, BUNptr(b, idx_first));
	ht = BUNtloc(b, BUNptr(b, idx_last));
	hh = BUNhloc(b, BUNptr(b, idx_last));

	@:moveOrdered(*(@1*)tmpt @3 mid,tmph,tmpt,+,lowShrinked++;,&& tmpt<=ht)@
	@:moveOrdered(*(@1*)ht @4 mid,hh,ht,-,hghShrinked++;,&& ht>=tmpt)@
	if (lowShrinked == idx_last - idx_first + 1) {
			*pos = idx_last+1;
			return MAL_SUCCEED;
	}
	if (hghShrinked == idx_last - idx_first + 1){
			*pos = idx_first-1;
			return MAL_SUCCEED;
	}
	
	if (ht == tmpt + xx){
		oid dh = *(oid*)tmph;
		@1  dt = *(@1 *)tmpt;
		*(oid*)tmph = *(oid*)hh;
		*(@1 *)tmpt = *(@1 *)ht;

		*pos = BUNindex(b,tmpt);

		*(oid*)hh = dh;
		*(@1 *)ht = dt;

		return MAL_SUCCEED;
	}

	if (ht == tmpt - xx){
		*pos = BUNindex(b,ht);
		return MAL_SUCCEED;
	}	

	scr_size = (idx_last - idx_first +1 -lowShrinked -hghShrinked);
	if (scr_size >=2) scr_size = scr_size/2;
	scr_h = (oid*) GDKmalloc(scr_size * sizeof(oid));
	scr_t = (@1 *) GDKmalloc(scr_size * sizeof(@1 ));
	t = tmpt;
	s = tmpt+(2*probe*xx);
	for (;t<s;t+=xx)
		j+=*(@1*)t @3 mid;
	
	if (j > probe){
		ch = tmph; ct = tmpt;
		@:OrderedZero(@1,+,<=,@4,-,>=, -xx)@
	}
	else{
		ch =hh; ct = ht;
		fh = tmph, ft = tmpt;
		tmph =hh; tmpt = ht;
		hh = fh; ht = ft;
		@:OrderedZero(@1,-,>=,@3,+,<=)@
	}
	GDKfree(scr_h);
	GDKfree(scr_t);
	return MAL_SUCCEED;
}
@

@]
