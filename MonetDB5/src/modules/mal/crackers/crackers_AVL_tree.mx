@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2007 CWI.
@' All Rights Reserved.

@f crackers_AVL_tree
@a Martin Kersten, Stratos Idreos, Stefan Manegold
@d March 2006 - July 2007
@* AVL Tree

AVL-tree implementation for the cracker index


@+ Interface
 

@- Type expansion

@= TypeSwitch
@:@1(chr,simple,)@
@:@1(sht,simple,)@
@:@1(int,simple,)@
@:@1(lng,simple,)@
@:@1(flt,simple,)@
@:@1(dbl,simple,)@
@:@1(date,atom,TYPE_)@
@


@- Header file

@h
#ifndef _CRACKERS_AVL_TREE_H_
#define _CRACKERS_AVL_TREE_H_

#ifdef LIBCRACKERS
/* Signatures shared within the crackers module/library */
@:AVLtreeSharedFunctions_decl_0@
@:TypeSwitch(AVLtreeSharedFunctions_decl_1)@
#endif

#endif /* _CRACKERS_AVL_TREE_H */
@


@- Signatures shared within the crackers module/library

@= AVLtreeSharedFunctions_decl_0
int Height(struct Node * x);
struct Node * SingleRotateLeft(int m, struct Node * node);
struct Node * SingleRotateRight(int m, struct Node * node);
struct Node * DoubleRotateLeft(int m, struct Node * node);
struct Node * DoubleRotateRight(int m, struct Node * node);
struct Node * findPreviousPieceWalkingBack(struct Node * node);
struct Node * findNextPiece(struct Node * node);
void FreeAVLTree(struct Node * current);
void printAVLTree(struct Node * current, BAT *b, BUN base, int xx);
@

@= AVLtreeSharedFunctions_decl_1
bit GetLow_@1(@1  x, bit inclusive, struct Node * current, BAT *b, BUN base, int xx, lng *p1, lng *p2, lng previous, lng next);
bit GetHgh_@1(@1  x, bit inclusive, struct Node * current, BAT *b, BUN base, int xx, lng *p1, lng *p2, lng previous, lng next);
struct Node * InsertTree_@1(int m, int indexPosition, @1 value, bit inclusive, lng crackPosition, struct Node * current, BAT * b, BUN base, int xx);
struct Node * findNodeH_@1(@1  x, bit inclusive, struct Node * current, BAT *b, BUN base, int xx, struct Node * next);
struct Node * findNodeL_@1(@1  x, bit inclusive, struct Node * current, BAT *b, BUN base, int xx, struct Node * prev);
void PartiallyLazyFreeAVLTree_@1(struct Node * current, @1 value, BAT *b, BUN base, int xx);
@


@{
@+ Implementation


@- C file

@c
#include "mal_config.h"
#include "crackers.h"

/* Local support functions and macros */
@:AVLtreeLocalFunctions@

/* Functions shared within the crackers module/library */
@:AVLtreeSharedFunctions_impl_0@
@:TypeSwitch(AVLtreeSharedFunctions_impl_1)@
@


@-Functions shared within the crackers module/library

@= AVLtreeSharedFunctions_impl_0
int
Height(struct Node * x){
        if( x == NULL )
                return -1;
        else
                return x->height;
}

struct Node *
SingleRotateLeft(int m, struct Node * node){
        struct Node * l, *lr;
	int nodeLh,nodeRh,lh;

        l = node->left;
	lr = l->right;
        node->left = l->right;
        l->right = node;

	if (node->previous == NULL)
		l->previous = NULL;
	else {
		l->previous = node->previous;
		l->isPreviousSmaller = node->isPreviousSmaller;
        }

	node->previous = l;
	node->isPreviousSmaller = TRUE;
	if (lr != NULL) {
		lr->previous = node;
		lr->isPreviousSmaller = FALSE;
	}
	if (node->head == TRUE){
		node->head = FALSE;
		l->head = TRUE;
		CrackerIndex[m].Tree = l;
	}

	nodeLh = Height(node->left);
	nodeRh = Height(node->right);
	lh = Height(l->left);

	node->height = (nodeLh > nodeRh ? nodeLh : nodeRh) + 1;
        l->height = (lh > node->height ? lh : node->height) + 1;

        return l;
}

struct Node *
SingleRotateRight(int m, struct Node * node){
        struct Node * r, *rl;
	int nodeLh,nodeRh,rh;

        r = node->right;
	rl =  r->left;

        node->right = r->left;
        r->left = node;

	if (node->previous == NULL)
		r->previous = NULL;
	else {
		r->previous = node->previous;
		r->isPreviousSmaller = node->isPreviousSmaller;
	}
	node->previous = r;
	node->isPreviousSmaller = FALSE;

	if (rl != NULL){
		rl->previous = node;
		rl->isPreviousSmaller = TRUE;
	}

	if (node->head == TRUE){
		node->head = FALSE;
		r->head = TRUE;
		CrackerIndex[m].Tree = r;
	}

	nodeLh = Height(node->left);
	nodeRh = Height(node->right);
	rh = Height(r->right);

	node->height = (nodeLh > nodeRh ? nodeLh : nodeRh) + 1;
        r->height = (rh > node->height ? rh : node->height) + 1;

        return r;
}

struct Node *
DoubleRotateLeft(int m, struct Node * node){
            node->left = SingleRotateRight(m, node->left);
            return SingleRotateLeft(m, node);
}

struct Node *
DoubleRotateRight(int m, struct Node * node){
            node->right = SingleRotateLeft(m, node->right);
            return SingleRotateRight(m, node);
}

struct Node *
findPreviousPieceWalkingBack(struct Node * node){
	struct Node * res = NULL, *current = node;

	if (current->left != NULL)
                res= getP(current->left);
	if (res != NULL)
		return res;

	/* If nothing in the current branch we have to move back */
	while (res == NULL) {
		if (current->previous == NULL)
			return NULL;
		while  (current->isPreviousSmaller == FALSE){
			current = current->previous;
			if (current->previous == NULL)
                        	return NULL;
		}
		current = current->previous;

		if (current->deleted == FALSE)
			res = current;
		else if (current->left != NULL)
                	res= getP(current->left);
	}
	
	return res;
}

struct Node *
findNextPiece(struct Node * node){
	struct Node * res = NULL, *current = node;

	if (current->right != NULL)
                res= getN(current->right);
	if (res != NULL)
		return res;

	/* if nothing in the current branch we have to move back */
	while (res == NULL) {
		if (current->previous == NULL)
			return NULL;
		while  (current->isPreviousSmaller == TRUE){
			current = current->previous;
			if (current->previous == NULL)
                        	return NULL;
		}
		current = current->previous;

		if (current->deleted == FALSE)
			res = current;
		else if (current->right != NULL)
                	res= getN(current->right);
	}
	
	return res;
}

void
FreeAVLTree(struct Node * current){

	if (current->left != NULL)
		FreeAVLTree(current->left);

	if (current->right != NULL)
		FreeAVLTree(current->right);

	GDKfree(current);
		
	return;
}

void
printAVLTree(struct Node * current, BAT *b, BUN base, int xx){
	BUN cur;

	cur = base + ((current->position) * xx);
	if (current->deleted == FALSE) {
		printf("\n "LLFMT", %d  Hols:"LLFMT" ", *(lng*)BUNhloc(b, cur), *(int*)BUNtloc(b, cur), current->hols );
	} else
		printf("\n DELETED "LLFMT", %d  Hols:"LLFMT" ", *(lng*)BUNhloc(b, cur), *(int*)BUNtloc(b, cur), current->hols );
	
	if (current->left != NULL)
                printAVLTree(current->left, b, base, xx);

        if (current->right != NULL)
                printAVLTree(current->right, b, base, xx);

        return;

}
@

@= AVLtreeSharedFunctions_impl_1
bit
GetLow_@1(@1  x, bit inclusive, struct Node * current, BAT *b, BUN base, int xx, lng *p1, lng *p2, lng previous, lng next){
	BUN cur, curValue;

	cur = base + ((current->position) * xx);
	curValue = BUNtloc(b, cur);

	if (current->deleted == TRUE){
		if ( @2_EQ(&x,curValue,@3@1) || @2_LT(&x,curValue,@3@1) ){	
			if (current->left == NULL){
        	                *p1 = previous;
                	        *p2 = getNextPosition(current, b, base,  xx, next);
                       	 	return 0;
                	} else
                        	/* check for the left one */
                        	return GetLow_@1(x, inclusive, current->left, b, base, xx, p1, p2, previous, getNextPosition(current, b, base,  xx, next));
		}
		if (current->right == NULL){
               	 	*p1 = getPreviousPosition(current, b, base,  xx, previous);
			*p2 = next;
			return 0;
		} else 	
			return GetLow_@1(x, inclusive, current->right, b, base, xx, p1, p2, getPreviousPosition(current, b, base,  xx, previous), next);
	}

	if ( @2_EQ(&x,curValue,@3@1) && (inclusive == FALSE || (inclusive == TRUE && current->inclusive == TRUE)) ){
		*p1 = *(lng*)BUNhloc(b, cur);	
		return 1;
	}	

       	if ( @2_LT(&x,curValue,@3@1) || @2_EQ(&x,curValue,@3@1) ){

		if (current->left == NULL){
			/* crack from the begining of the bat */
                	*p1 = previous;
			*p2 = *(lng*)BUNhloc(b, cur);
			return 0;
		} else
			/* check for the left one */
      			return GetLow_@1(x, inclusive, current->left, b, base, xx, p1, p2, previous, *(lng*)BUNhloc(b, cur));
			
	}

	if (current->right == NULL){
		/* crack until the end of the bat */
                *p1 = *(lng*)BUNhloc(b, cur);
		*p2 = next;
		return 0;
	} else 	
		/* check for the right one */
		return GetLow_@1(x, inclusive, current->right, b, base, xx, p1, p2, *(lng*)BUNhloc(b, cur), next);
}

bit
GetHgh_@1(@1  x, bit inclusive, struct Node * current, BAT *b, BUN base, int xx, lng *p1, lng *p2, lng previous, lng next){
        BUN cur, curValue;	

	cur = base + ((current->position) * xx);
	curValue = BUNtloc(b, cur);

	if (current->deleted == TRUE){
		if ( @2_EQ(&x,curValue,@3@1) || @2_GT(&x,curValue,@3@1) ){
			 if (current->right == NULL){
                       	 	*p1 = getPreviousPosition(current, b, base,  xx, previous);
                        	*p2 = next;
                        	return 0;
                	} else
                        	return GetHgh_@1(x, inclusive, current->right, b, base, xx, p1, p2, getPreviousPosition(current, b, base,  xx, previous), next);
		}
		if (current->left == NULL){
               	 	*p1 = previous;
                	*p2 = getNextPosition(current, b, base,  xx, next);
               	 	return 0;
	        } else
                	return GetHgh_@1(x, inclusive, current->left, b, base, xx, p1, p2, previous, getNextPosition(current, b, base,  xx, next));

	}

	if ( @2_EQ(&x,curValue,@3@1) && (inclusive == FALSE || (inclusive == TRUE && current->inclusive == FALSE))){
		*p2 = *(lng*)BUNhloc(b, cur);	
		return 1;
	}	

	if ( @2_GT(&x,curValue,@3@1) || @2_EQ(&x,curValue,@3@1) ){

		if (current->right == NULL){
			/* crack until the end of the BAT if this was the last index entry but the needed value is still bigger */
			*p1 = *(lng*)BUNhloc(b, cur);
                	*p2 = next;
			return 0;
		} else
			/* check for the right one */
      			return GetHgh_@1(x, inclusive, current->right, b, base, xx, p1, p2, *(lng*)BUNhloc(b, cur), next);
	}

	/* then it is smaller than the current value */
	if (current->left == NULL){
		/* crack from the beginning of the bat until here */
		*p1 = previous;
               	*p2 = *(lng*)BUNhloc(b, cur);
		return 0;
	} else	
		/* check for the left one */	
		return GetHgh_@1(x, inclusive, current->left, b, base, xx, p1, p2, previous, *(lng*)BUNhloc(b, cur));	
}

struct Node *
InsertTree_@1(int m, int indexPosition, @1 value, bit inclusive, lng crackPosition, struct Node * current, BAT * b, BUN base, int xx){
	BUN cur, curValue, curPosition, Lchild, LchildValue, Rchild, RchildValue;
	int lh, rh;
	bit use;
	struct Node *temp;

	if (current == NULL){
        	current = (struct Node *)GDKmalloc(sizeof(struct Node));
                current->position = indexPosition;
                current->inclusive = inclusive;
		current->height = 0;
                current->left = NULL;
		current->right = NULL;
		current->head = FALSE;
		current->deleted = FALSE;
		current->previous = NULL;
		current->isPreviousSmaller = FALSE;
		current->hols = 0;
		goto end;
        }

	cur = base + ((current->position) * xx);
        curValue = BUNtloc(b, cur);

	/* reuse if possible nodes that have been deleted with lazy deletion */
	use = FALSE;
	if (current->deleted == TRUE){
		if (current->left != NULL && current->right != NULL){
			Lchild = base + (((getPreviousNodeAny(current))->position) * xx);
                        LchildValue = BUNtloc(b, Lchild);
			Rchild = base + (((getNextNodeAny(current))->position) * xx);
                        RchildValue = BUNtloc(b, Rchild);
			
			if ( ( @2_LT(&value,RchildValue,@3@1) || (@2_EQ(&value,RchildValue,@3@1) && 
			       inclusive == TRUE && current->right->inclusive == FALSE) )  &&
			     ( @2_GT(&value,LchildValue,@3@1) || (@2_EQ(&value,LchildValue,@3@1) && 
 			       inclusive == FALSE && current->left->inclusive == TRUE) ) )
				use = TRUE;			
		} else
		if (current->left != NULL && current->right == NULL){
			Lchild = base + (((getPreviousNodeAny(current))->position) * xx);
                        LchildValue = BUNtloc(b, Lchild);

			if ( @2_GT(&value,LchildValue,@3@1) || (@2_EQ(&value,LchildValue,@3@1) && 
			     inclusive == FALSE && current->left->inclusive == TRUE) )
				use = TRUE;
		} else
		if (current->left == NULL && current->right != NULL){
			Rchild = base + (((getNextNodeAny(current))->position) * xx);
                        RchildValue = BUNtloc(b, Rchild);
			
			if ( @2_LT(&value,RchildValue,@3@1) || (@2_EQ(&value,RchildValue,@3@1) && 
			     inclusive == TRUE && current->right->inclusive == FALSE) )
				use = TRUE;
		} else
		if (current->left == NULL && current->right == NULL)
				use = TRUE;

		if (use == TRUE){
        		curPosition = BUNhloc(b, cur);
			*(lng*)curPosition = crackPosition;
                        *(@1*)curValue = value;
			current->inclusive = inclusive;
                        current->deleted = FALSE;
                        return NULL;
		}
	}

        if ( @2_LT(&value,curValue,@3@1) || (@2_EQ(&value,curValue,@3@1) && inclusive == TRUE && current->inclusive == FALSE) ){

		if ( (temp = InsertTree_@1(m, indexPosition, value, inclusive, crackPosition, current->left, b, base, xx)) == NULL )
                	return NULL;

		current->left = temp;
		temp->previous = current;
		temp->isPreviousSmaller = FALSE;

                if ( Height(current->left) - Height(current->right) == 2 ){
		        Lchild = base + ((current->left->position) * xx);
        		LchildValue = BUNtloc(b, Lchild);

                    	if ( @2_LT(&value,LchildValue,@3@1) || (@2_EQ(&value,LchildValue,@3@1) && 
			     inclusive == TRUE && current->left->inclusive == FALSE) )
                        	current = SingleRotateLeft(m, current);
                    	else
                        	current = DoubleRotateLeft(m, current);
		}
        } else
        if ( @2_GT(&value,curValue,@3@1) || (@2_EQ(&value,curValue,@3@1) && inclusive == FALSE && current->inclusive == TRUE) ){

		if ( (temp = InsertTree_@1(m, indexPosition, value, inclusive, crackPosition, current->right, b, base, xx)) == NULL )
			return NULL;

                current->right = temp;
		temp->previous = current;
		temp->isPreviousSmaller = TRUE;


                if ( Height(current->right) - Height(current->left) == 2 ){
			Rchild = base + ((current->right->position) * xx);
                        RchildValue = BUNtloc(b, Rchild);

                        if ( @2_GT(&value,RchildValue,@3@1) || (@2_EQ(&value,RchildValue,@3@1) && 
			     inclusive == FALSE && current->right->inclusive == TRUE) )
                        	current = SingleRotateRight(m, current);
                    	else
                        	current = DoubleRotateRight(m, current);
		}
        }

	end:;
	lh = Height(current->left);
	rh = Height(current->right);
		
        current->height = (lh > rh? lh : rh) + 1;
        return current;
}

struct Node *
findNodeH_@1(@1  x, bit inclusive, struct Node * current, BAT *b, BUN base, int xx, struct Node * next){
        BUN cur,curValue;	

	cur = base + ((current->position) * xx);
	curValue = BUNtloc(b, cur);

	if ( @2_EQ(&x,curValue,@3@1) && (inclusive == FALSE || (inclusive == TRUE && current->inclusive == FALSE)) )
		return (current->deleted == TRUE) ? getNextNode(current, next) : current;

        if( @2_GT(&x,curValue,@3@1) || @2_EQ(&x,curValue,@3@1) ){

		if (current->right == NULL)
			return next;
		else
      			return findNodeH_@1(x, inclusive, current->right, b, base, xx, next);
	}

	if (current->left == NULL)
		return (current->deleted == TRUE) ? getNextNode(current, next) : current;
	else		
		return findNodeH_@1(x, inclusive, current->left, b, base, xx, (current->deleted == TRUE) ? getNextNode(current, next) : current);	
}

struct Node *
findNodeL_@1(@1  x, bit inclusive, struct Node * current, BAT *b, BUN base, int xx, struct Node * prev){
	BUN cur,curValue;

	cur = base + ((current->position) * xx);
	curValue = BUNtloc(b, cur);

	if ( @2_EQ(&x,curValue,@3@1) && (inclusive == FALSE || (inclusive == TRUE && current->inclusive == TRUE)) )
		return (current->deleted == TRUE) ? getPreviousNode(current, prev) : current;

        if( @2_LT(&x,curValue,@3@1) || @2_EQ(&x,curValue,@3@1) ){

		if (current->left == NULL)
			return prev;
		else
			return findNodeL_@1(x, inclusive, current->left, b, base, xx, prev);
	}

	if (current->right == NULL)
		return (current->deleted == TRUE) ? getPreviousNode(current, prev) : current;
	else
		return findNodeL_@1(x, inclusive, current->right, b, base, xx, (current->deleted == TRUE) ? getPreviousNode(current, prev) : current);
}

void
PartiallyLazyFreeAVLTree_@1(struct Node * current, @1 value, BAT *b, BUN base, int xx){
	BUN cur,curValue;

        cur = base + ((current->position) * xx);
        curValue = BUNtloc(b, cur);

	if (current->left != NULL)
		PartiallyLazyFreeAVLTree_@1(current->left, value, b, base, xx);

	if (current->right != NULL)
		PartiallyLazyFreeAVLTree_@1(current->right, value, b, base, xx);

	if( @2_LT(&value,curValue,@3@1) || (@2_EQ(&value,curValue,@3@1) && current->inclusive == FALSE) )
		current->deleted = TRUE;
	return;
}
@


@- Local support functions and macros

@= AVLtreeLocalFunctions
/* Get the previous node in the tree (in terms of value), the result can be any node, deleted or no */
static struct Node *
getPreviousNodeAny(struct Node * current){
	struct Node *res = NULL;

	if (current->left !=NULL){
		res = current->left;
		while(res->right != NULL)
			res = res->right;
	}

	return res;	
}

/* Get the next node in the tree (in terms of value), the result can be any node, deleted or no */
static struct Node *
getNextNodeAny(struct Node * current){
        struct Node *res = NULL;

        if (current->right !=NULL){
                res = current->right;
                while(res->left != NULL)
                        res = res->left;
        }

        return res;
}

static struct Node *
getP(struct Node * current){
        struct Node *res = NULL;

	if (current->right != NULL)
		res = getP(current->right);
	if (res == NULL){
		if (current->deleted == FALSE)
			res = current;
		else
		if (current->left != NULL)
			res = getP(current->left);
	}
	return res;
}

static struct Node *
getN(struct Node * current){
        struct Node *res = NULL;

	if (current->left != NULL)
		res = getN(current->left);
	if (res == NULL){
		if (current->deleted == FALSE)
			res = current;
		else
		if (current->right != NULL)
			res = getN(current->right);
	}
	return res;
}

/* Get the previous node in the tree (in terms of value), the result can be only a non deleted node */
static struct Node *
getPreviousNode(struct Node * current, struct Node * previous){
        struct Node *res = NULL;

	if (current->left != NULL)
		res= getP(current->left);
	if (res == NULL)
		return previous;
        return res;

}

/* Get the next node in the tree (in terms of value), the result can be only a non deleted node */
static struct Node *
getNextNode(struct Node * current, struct Node * next){
        struct Node *res = NULL;

	if (current->right != NULL)
		res= getN(current->right);
	if (res == NULL)
		return next;
        return res;
}

static lng
getPreviousPosition(struct Node * current, BAT *b, BUN base, int xx, lng previous){
        struct Node *res = NULL;

	if (current->left != NULL)
		res= getP(current->left);
	if (res == NULL)
		return previous;
        return *(lng*)BUNhloc(b,base + ((res->position) * xx));

}

static lng
getNextPosition(struct Node * current, BAT *b, BUN base, int xx, lng next){
        struct Node *res = NULL;

	if (current->right != NULL)
		res= getN(current->right);
	if (res == NULL)
		return next;
        return *(lng*)BUNhloc(b,base + ((res->position) * xx));
}
@

@}
