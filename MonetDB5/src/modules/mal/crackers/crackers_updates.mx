@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-July 2008 CWI.
@' Copyright August 2008-2009 MonetDB B.V.
@' All Rights Reserved.

@f crackers_updates
@a Martin Kersten, Stratos Idreos, Stefan Manegold
@d March 2006 - July 2007
@* Cracker Updates


@+ Interface


@- Type expansion

@= TypeSwitch
@:@1(chr,simple,)@
@:@1(sht,simple,)@
@:@1(int,simple,)@
@:@1(lng,simple,)@
@:@1(flt,simple,)@
@:@1(dbl,simple,)@
@:@1(date,atom,TYPE_)@
@


@- Header file
 
@h
#ifndef _CRACKERS_UPDATES_H_
#define _CRACKERS_UPDATES_H_

/* Signatures shared within the crackers module/library */
@:UpdatesSharedFunctions_decl_0@
@:TypeSwitch(UpdatesSharedFunctions_decl_1)@

/* Exported signatures */
@:UpdatesFunctions_decl_0@
@:TypeSwitch(UpdatesFunctions_decl_1)@

#endif /* _CRACKERS_UPDATES_H */
@


@- Exported signatures
 
@= UpdatesFunctions_decl_0
crackers_export str CRKsizeCrackerInsertions(int *k, int *bid);
crackers_export str CRKsizeCrackerDeletions(int *k, int *bid);
crackers_export str CRKprintCrackerInsertions(int *k, int *bid);
crackers_export str CRKprintCrackerDeletions(int *k, int *bid);
crackers_export str CRKmergeInsertions_Forget(int *k, int *bid, int *new);
crackers_export str CRKextendCrackerBAT(int *k, int *bid, lng positions);
crackers_export str CRKmergeInsertionsB_OnNeed(int *k, int *bid, int *new);
crackers_export str CRKmergeInsertionsB_OnNeedGradually(int *k, int *bid, int *new);
crackers_export str CRKmergeInsertionsB_OnNeedGraduallyRipple(int *k, int *bid, int *new);
crackers_export str CRKmergeDeletions_OnNeed(int *k, int *bid, int *new);
crackers_export str CRKmergeDeletions_OnNeedGradually(int *k, int *bid, int *new);
crackers_export str CRKmergeDeletions_OnNeedGraduallyRipple(int *k, int *bid, int *new);
@

@= UpdatesFunctions_decl_1
crackers_export str CRKmergeInsertions_PartiallyForget_@1(int *k, int *bid, int *new);
crackers_export str CRKmergeInsertionsB_Force_@1(int *k, int *bid, int *new);
@


@- Signatures shared within the crackers module/library

@= UpdatesSharedFunctions_decl_0
str appendInsertions(int *new, int position);
@

@= UpdatesSharedFunctions_decl_1
/* mergeInsertionOperations */
str mergeInsertionsB_@1(int *bid, int *new, oid startPosition, oid endPosition);
str mergeInsertionsBGradually_@1(int *bid, int *new, oid startPosition, oid endPosition);
str mergeInsertionsBRipple_@1(BAT *b, BAT *u, oid startPosition, oid endPosition, @1 *hgh, bit inclusive, int position);
str mergeDeletions_@1(int *bid, int *del, oid startPosition, oid endPosition);
str mergeDeletionsGradually_@1(int *bid, int *del, oid startPosition, oid endPosition);
str mergeDeletionsGraduallyRipple_@1(int *bid, int *del, oid startPosition, oid endPosition, @1 *lowV, bit inclusiveL, @1 *hghV, bit inclusiveH);
@


@{
@+ Implementation

 
@- C file

@c
#include "mal_config.h"
#include "crackers.h"

/* Local support functions and macros */
@:UpdatesLocal@

/* Functions shared within the crackers module/library */
@:UpdatesSharedFunctions_impl_0@
@:TypeSwitch(UpdatesSharedFunctions_impl_1)@

/* Exported functions */
@:UpdatesFunctions_impl_0@
@:updatesOnNeed(,0)@
@:updatesOnNeed(Gradually,1)@
@:updatesOnNeed(GraduallyRipple,2)@
@:TypeSwitch(UpdatesFunctions_impl_1)@
@


@- Exported functions

@= UpdatesFunctions_impl_0
str
CRKsizeCrackerDeletions(int *k, int *bid){
        (void)k;
        sizeCrackerDeletions(*bid);
        return MAL_SUCCEED;
}

str
CRKsizeCrackerInsertions(int *k, int *bid){
	(void)k;
	sizeCrackerInsertions(*bid);

	return MAL_SUCCEED;
}

str
CRKprintCrackerDeletions(int *k, int *bid){
	(void)k;
	printCrackerDeletions(*bid);

	return MAL_SUCCEED;
}

str
CRKprintCrackerInsertions(int *k, int *bid){
	(void)k;
	printCrackerInsertions(*bid);

	return MAL_SUCCEED;
}

str
CRKmergeInsertions_Forget(int *k, int *bid, int *new){
	(void) k;
	appendCrackerBAT(bid,new);
	removeCrackerIndex(bid);

	return MAL_SUCCEED;
}

str
CRKextendCrackerBAT(int *k, int *bid, lng positions){
	BAT *b;
	int position = existsCrackerIndex(*bid);
	(void) k;

	if (position == -1)
                throw(MAL, "crackers.CRKextendCrackerBAT", "Cannot find cracker index");
	if ((b = BATdescriptor(CrackerIndex[position].cbid)) == NULL)
                throw(MAL, "crackers.CRKextendCrackerBAT", "Cannot access cracker BAT");

	if (BATextend(b, (BUN)positions) == NULL)
                throw(MAL, "crackers.CRKextendCrackerBAT", "Failed to extend the cracker BAT");	

	BBPunfix(b->batCacheid);

	return MAL_SUCCEED;
}
@

@= updatesOnNeed
str
CRKmergeInsertionsB_OnNeed@1(int *k, int *bid, int *new){
	int position = existsCrackerIndex(*bid);
        (void) k;

	if (position == -1)
		throw(MAL, "crackers.CRKmergeInsertionsB_OnNeed@1", "Cannot find cracker index");

	appendInsertions(new,position);
	CrackerIndex[position].mergeInsertions = @2;
	CrackerIndex[position].deleteNodes = FALSE;	

        return MAL_SUCCEED;
}

str
CRKmergeInsertions_OnNeed@1(int *k, int *bid, int *new, bit *deleteNodes){
	int position = existsCrackerIndex(*bid);
        (void) k;

	if (position == -1)
		throw(MAL, "crackers.CRKmergeInsertions_OnNeed@1", "Cannot find cracker index");

	appendInsertions(new,position);
	CrackerIndex[position].mergeInsertions = @2;
	CrackerIndex[position].deleteNodes = *deleteNodes;	

        return MAL_SUCCEED;
}

str
CRKmergeDeletions_OnNeed@1(int *k, int *bid, int *del){
	int position = existsCrackerIndex(*bid);
        (void) k;

	if (position == -1)
		throw(MAL, "crackers.CRKmergeDeletions_OnNeed@1", "Cannot find cracker index");

	appendDeletions(del,position);
	CrackerIndex[position].mergeDeletions = @2;

        return MAL_SUCCEED;
}
@

@= UpdatesFunctions_impl_1
str
CRKmergeInsertions_PartiallyForget_@1(int *k, int *bid, int *new){
	BAT *c, *u;
	@1 min;
	@1 *inst, *insLast;
	int position = -1;
	int i;

	(void) k;

	if ((u = BATdescriptor(*new)) == NULL)
		throw(MAL, "crackers.mergeInsertions_PartiallyForget_@1", "Cannot access insertions");

	if (BATcount(u) == 0)
		return MAL_SUCCEED;

	for (i = 0; i < maxCrackMap; i++)
        	if (CrackerIndex[i].bid == *bid){
                	position = i;	
			break;
		}

	/*if (position == -1) return; Trying to erase an index that does not exist*/

	if ((c = BATdescriptor(CrackerIndex[position].cid)) == NULL){
                BBPunfix(u->batCacheid);
                throw(MAL, "crackers.CRKmergeInsertions_PartiallyForget_@1", "Cannot access cracker index");
        }

	/* get the min value */
	inst    = (@1*)Tloc(u,BUNfirst(u));
	insLast = (@1*)Tloc(u,BUNlast(u));
	min = *inst;
	for(inst+=1;inst < insLast; inst++)
		if (@2_GT(&min,inst,@3@1))
			min = *inst;

	/* Partially delete tree with lazy deletion */
	PartiallyLazyFreeAVLTree_@1(CrackerIndex[position].Tree, min, c, BUNfirst(c));

	appendCrackerBAT(bid,new);

	BBPunfix(c->batCacheid);
	BBPunfix(u->batCacheid);

	return MAL_SUCCEED;
}

str
CRKmergeInsertionsB_Force_@1(int *k, int *bid, int *new){
	oid startPosition = 0;
	oid endPosition;
	int endPositionStatus   = -1;
	@1 *hgh;
	bit inclusive = TRUE;

	@:mergeInsertionsFromTheEndBodyI(@1,@2,@3)@

	(void)k;
	next = BUNlast(b) - (oid)1;
	hgh = (@1*)Tloc(b,next);
	@:mergeInsertionsFromTheEndBodyCG(@1,@2,@3)@
	@:mergeInsertionsFromTheEndBodyII(@1,@2,@3)@

        BATsetcount(b, BUNlast(b) + insertions);

	BBPunfix(c->batCacheid);
	BBPunfix(u->batCacheid);
	BBPunfix(b->batCacheid);

 	return MAL_SUCCEED;
}
@


@- Functions shared within the crackers module/library

@= UpdatesSharedFunctions_impl_0
/* used both for selection and sideways cracking */
str
appendInsertions(int *new, int position){
	BAT *u, *c;

       	if ((u = BATdescriptor(*new)) == NULL)
      		 throw(MAL, "crackers.appendInsertions", "Cannot access insertions BAT");

	if (CrackerIndex[position].iid < 0 ){
		BATmode(u,PERSISTENT);
		u->batRestricted= BAT_WRITE;
		CrackerIndex[position].iid = u->batCacheid;
		BBPkeepref(u->batCacheid);
	} else {
       		if ((c = BATdescriptor(CrackerIndex[position].iid)) == NULL)
      		 	throw(MAL, "crackers.appendInsertions", "Cannot access cracker insertions BAT");
		
		c = BATins(c, u,TRUE);

		BBPunfix(c->batCacheid);
		BBPunfix(u->batCacheid);
	}

        return MAL_SUCCEED;
}
@

@= UpdatesSharedFunctions_impl_1
/* mergeInsertionOperations */
str
mergeInsertionsB_@1(int *bid, int *new, oid startPosition, oid endPosition){
	@1 *hgh;
	bit inclusive = TRUE;
	int endPositionStatus   = 0;
	@:mergeInsertionsFromTheEndBodyI(@1,@2,@3)@

	next = BUNlast(b) - 1;
	hgh  = (@1*)Tloc(b,next);

	@:mergeInsertionsFromTheEndBodyCG(@1,@2,@3)@
        @:mergeInsertionsFromTheEndBodyII(@1,@2,@3)@

        BATsetcount(b, BUNlast(b) + insertions);
	BBPunfix(c->batCacheid);
	BBPunfix(u->batCacheid);
	BBPunfix(b->batCacheid);

        return MAL_SUCCEED;
}

str
mergeInsertionsBGradually_@1(int *bid, int *new, oid startPosition, oid endPosition){
	/* First merge then shrink the insertions column */
	@1 *hgh;
	bit inclusive = TRUE;
	int endPositionStatus   = 0;
	@:mergeInsertionsFromTheEndBodyI(@1,@2,@3)@

	next = BUNlast(b) - 1;
	hgh = (@1*)Tloc(b,next);
	
	@:mergeInsertionsFromTheEndBodyCG(@1,@2,@3)@
	@:mergeInsertionsFromTheEndBodyII(@1,@2,@3)@

        BATsetcount(b, BUNlast(b) + insertions);
	endPosition++;
	@:shrinkInsertions(@1)@

        BBPunfix(c->batCacheid);
        BBPunfix(u->batCacheid);
        BBPunfix(b->batCacheid);

        return MAL_SUCCEED;
}

str
mergeInsertionsBRipple_@1(BAT *b, BAT *u, oid startPosition, oid endPosition, @1 *hgh, bit inclusive, int position){
        BAT *ripple;
        BUN rnext;
        oid *rh;
	@1 *rt, *insLast;	
	oid toRippleBuns;
	oid exceedBuns = 0;
	struct Node * NextNode;
	bit fromTheEnd = FALSE;
	oid i;
	oid consumedRipple = 0, consumedInsertions = 0, values, usedHoles = 0;
	struct Node *rippleNode = NULL;

        BAT *c;
	BUN idxFirst, cur, crkFirst, insFirst, next, write;
	oid *insh, *crkh;
	@1 *inst, *crkt, *crkLast, *curVal;
	oid *curPos;
	struct Node *IndexNode = NULL;
	oid prevPos, prevcrsize, insertions, remainingIns, buns, needed;
	struct Node *prevNode =NULL;
	@1  *startT, *endT;
	oid *startH, *endH;

	/* abort if there are no insertions to merge */	
	if (BATcount(u) == 0) {
		return MAL_SUCCEED;
	}

	if ((c = BATdescriptor(CrackerIndex[position].cid)) == NULL){
		throw(MAL, "crackers.mergeInsertions_@1", "Cannot access cracker index");
	}

	/*if (endPositionStatus == -1){
		endPosition = BATcount(u) - 1;
		endPositionStatus = 0;
	}*/
	insertions = endPosition - startPosition + 1;

	/* sort in place the insertions bat */
	if (u->tsorted == FALSE){
		u->batRestricted = BAT_WRITE;
		BATmirror(BATorder(BATmirror(u)));
	}

	remainingIns = insertions;
	prevcrsize = BATcount(b);
	insFirst = BUNfirst(u);	

	/* make room for the new tuples */
	if ( insertions > BATcapacity(b) - BATcount(b) ){
		BUN ncap;
		BUN grows;
		needed = insertions - (BATcapacity(b) - BATcount(b));
                ncap = BATcapacity(b) + needed;
                grows = BATgrows(b);
                if (ncap > grows)
                        grows = ncap;
                if (BATextend(b, grows) == NULL)
                        throw(MAL, "crackers.mergeInsertions_@1", "Failed to make room for the new values");
        }
	
	insh 	 = (oid*)Hloc(u, insFirst + endPosition);
	inst 	 = (@1 *)Tloc(u, insFirst + endPosition);
	idxFirst = BUNfirst(c);
	crkFirst = BUNfirst(b);
	prevPos = prevcrsize - 1;

	insLast = (@1*)Tloc(u,BUNlast(u));	
	toRippleBuns = endPosition - startPosition +1;
	ripple = BATnew(TYPE_oid, TYPE_@1, toRippleBuns);

        /* Find out buns that should be rippled. Take this values out in a temporary BAT */

	/* first find the piece where the biggest insertions should be placed */
        if ( (NextNode = findNodeH_@1(*(@1*)hgh, inclusive, CrackerIndex[position].Tree, c, idxFirst, NULL)) != NULL ){

		prevNode = NextNode;
		cur     = idxFirst + NextNode->position;
                curPos  = (oid*)Hloc(c, cur);

		/* prevPos should not be changed! 
		   mergeInsertionsFromTheEndBodyII expects it to point in the position from where merging will start */
		prevPos = *curPos;

		/* merging will start from this bun */		
		next = crkFirst + (*curPos) ;

		/* use hols if any at the end of the result area */
		if (NextNode->hols > 0){
			rippleNode = NextNode;
			if (NextNode->hols >= insertions)
				goto rippled;
			else 
			if (NextNode->hols < insertions)
				toRippleBuns -= NextNode->hols; 
			
		}

		rh = (oid*)Hloc(ripple, BUNfirst(ripple));
		rt = (@1 *)Tloc(ripple, BUNfirst(ripple));

                rnext   = crkFirst + (*curPos) + 1;

		NextNode->deleted = TRUE; /* TODO: consider not deleting this piece and instead extend it... */

                crkh = (oid*)Hloc(b,rnext);
                crkt = (@1 *)Tloc(b,rnext);
		crkLast = (@1*)Tloc(b,BUNlast(b));

		/* find out how many buns until we get into the next chunk. Variable buns holds this information*/ 
		if  ((NextNode =findNextPiece(NextNode)) == NULL)
			buns = values = BATcount(b) - prevPos - 1;
		else {
			cur    = idxFirst + NextNode->position;
               		curPos = (oid*)Hloc(c, cur);
                	rnext   = crkFirst + (*curPos)  + 1;
                	buns   = (*curPos) - prevPos;
			values = buns - NextNode->hols;
		}
		/* move values out. If we get into the next piece then we simply delete it */
		for (i=0; i<toRippleBuns; i++){
		
			if (i == buns && crkt < crkLast){
				NextNode->deleted = TRUE;
				if  ((NextNode =findNextPiece(NextNode)) == NULL)
					buns = values = BATcount(b) - prevPos - 1;
				else {
					cur    = idxFirst + NextNode->position;
               				curPos = (oid*)Hloc(c, cur);
                			rnext  = crkFirst + (*curPos) + 1;
                			buns   = (*curPos) - prevPos;
					values = buns - NextNode->hols;
				}
			}

			/* do not ripple if this is a hole */
			if (i< values){
				*rh = *crkh;
				*rt = *crkt;
				rh++; rt++; 
			} else { 
				if (NextNode!=NULL)
					NextNode->hols --;
				usedHoles++;
			}
			crkh++; crkt++;	

			/* we consumed all values until the end of the column. nothing more to ripple */
			if (crkt >= crkLast){
				i++;
				exceedBuns = toRippleBuns - i;
				break;
			}
		}
		if (i == buns && NextNode != NULL) {
			NextNode->deleted = TRUE;
			/*printf("\n have to delete piece "LLFMT"  \n", *(oid*)curPos);*/
		}
		BATsetcount(ripple, i-usedHoles);
	} else {
		/* then we do not have to ripple. We simply start merging from the end of the cracker column */
		exceedBuns = toRippleBuns;
		next = BUNlast(b) - 1;
		/* prevPos has been correctly set in mergeInsertionsFromTheEndBodyI pointing at the last bun of the cracker column */
		fromTheEnd = TRUE;
	}
	rippled:;

	if (fromTheEnd){
		@:mergeInsertionsFromTheEndBodyCG(@1,@2,@3)@
	}
        @:mergeInsertionsFromTheEndBodyII(@1,@2,@3)@
		
	if (exceedBuns > 0){
       	 	BATsetcount(b, BUNlast(b) + exceedBuns);
        }

	if (rippleNode != NULL){
		if (rippleNode->hols > insertions)
			rippleNode->hols -= insertions;
		else
		if (rippleNode->hols <= insertions)
			rippleNode->hols = 0;
	}
	endPosition++;

	/* now we have to merge the rippled values with the remaining insertions */
	if (BATcount(ripple) > 0){
		/* do not ripple values that are marked as pending deletions */
		if (CrackerIndex[position].mergeDeletions > 0){
			BAT *deletes, *ripBAT;
			if (CrackerIndex[position].did < 0) goto merge;			
			if ((deletes = BATdescriptor(CrackerIndex[position].did)) == NULL)
		                return "Cannot access the deletions BAT";	
			if (BATcount(deletes)==0) {
				BBPunfix(deletes->batCacheid);
				goto merge;
			}

			ripple->hsorted = FALSE;
			ripple->tsorted = FALSE;
			ripple->tdense = FALSE;
			ripple->hdense = FALSE;

			/* this is just to bypass a bug and shuold be removed from here */
			deletes->hsorted = FALSE;
			deletes->tsorted = FALSE;
			deletes->tdense = FALSE;
			deletes->hdense = FALSE;

			ripBAT = BATsintersect(ripple,deletes);

			if (BATcount(ripBAT)>0){
				ripple = BATdel(ripple,ripBAT,TRUE);
				deletes = BATdel(deletes,ripBAT,TRUE);
			} 

                      	BBPunfix(deletes->batCacheid);
                        BBPunfix(ripBAT->batCacheid);
		}
		merge:;
		if (BATcount(ripple)==0)
                        goto EmptyRipple;

		ripple->tsorted = FALSE;		
		ripple->batRestricted = BAT_WRITE;
		BATmirror(BATorder(BATmirror(ripple)));
		
		/* merge */
		rh    = (oid*)Hloc(ripple, BUNfirst(ripple));
		rt    = (@1 *)Tloc(ripple, BUNfirst(ripple));
		crkh  = (oid*)Hloc(u,insFirst+startPosition);
		crkt  = (@1 *)Tloc(u,insFirst+startPosition);
		insh  = (oid*)Hloc(u,insFirst+endPosition);
		inst  = (@1 *)Tloc(u,insFirst+endPosition);

		crkLast = (@1*)Tloc(ripple,BUNlast(ripple));
		while(rt < crkLast && inst < insLast){
			if (@2_LE(rt,inst,@3@1)){	
				*crkh = *rh;
				*crkt = *rt;
				rh++; rt++; consumedRipple++;
			} else {
				*crkh = *insh;
				*crkt = *inst;
				insh++; inst++; consumedInsertions++;
			}
			crkh++; crkt++;
		}
		
		if (rt < crkLast && inst == insLast){
			BUN i;
			for(i = 0; i<BATcount(ripple)-(BUN)consumedRipple; i++){
				*crkh = *rh;
                                *crkt = *rt;
				 rh++; rt++;crkh++; crkt++;
			}
		} else	
		if (rt == crkLast && inst < insLast){
			BUN i;
			for(i = 0; i<BATcount(u)-(BUN)endPosition -(BUN)consumedInsertions; i++){
                                *crkh = *insh;
                                *crkt = *inst;
                                 insh++; inst++;crkh++; crkt++;
                        }
		}
		/* if some of the insertions went at the end of the cracker column, then the pending insertions has less values now */
                BATsetcount(u, BUNlast(u) - (insertions - BATcount(ripple)));
	} else {
		EmptyRipple:;
		@:shrinkInsertions(@1)@
	}

        BBPunfix(c->batCacheid);
	BBPunfix(ripple->batCacheid);

        return MAL_SUCCEED;
}

str
mergeDeletions_@1(int *bid, int *del, oid startPosition, oid endPosition){
	@:mergeDeletionsBody(@1,@2,@3)@

	BBPunfix(c->batCacheid);
	BBPunfix(u->batCacheid);
	BBPunfix(b->batCacheid);

        return MAL_SUCCEED;
}

str
mergeDeletionsGradually_@1(int *bid, int *del, oid startPosition, oid endPosition){
        @:mergeDeletionsBody(@1,@2,@3)@

	@:shrinkDeletions(@1)@

        BBPunfix(c->batCacheid);
        BBPunfix(u->batCacheid);
        BBPunfix(b->batCacheid);

        return MAL_SUCCEED;
}

str
mergeDeletionsGraduallyRipple_@1(int *bid, int *del, oid startPosition, oid endPosition, @1 *lowV, bit inclusiveL, @1 *hghV, bit inclusiveH){
        BAT *c, *u, *b, *crackerPieceO, *deletesPieceO,  *crackerPieceV, *deletesPieceV;
	BAT *positionsO, *positionsV, *positions, *crackerSlice, *deletesSlice;
	BUN idxFirst, crk, crkFirst, delFirst, low, hgh;
	@1 *delt, *lowVal, *hghVal;
	oid *pos, *posLast;
	oid *hghPos=NULL;
	int position = -1;
	oid deletions, remainingDel, buns;
	oid *startH;
        @1  *startT;
        oid *endH;
	@1  *endT;


	struct Node *lowNode, *hghNode, *temp, *stopNode;
	oid LposCr=0,HposCr=0, LposDe, HposDe, deletesForCurrentPiece=0, deletedFromCurrentPiece;
	oid holSize, holPiece, notFound = 0, prevPos, notFoundHere;
	int i;


	for (i = 0; i < maxCrackMap; i++)
                if (CrackerIndex[i].bid == *bid){
                        position = i;
			break;	
		}

        if ((u = BATdescriptor(*del)) == NULL)
                throw(MAL, "crackers.mergeDeletions_@1", "Cannot access insertions BAT");

	/* abort if there are no deletions to merge */	
	if (BATcount(u) == 0) {
		BBPunfix(u->batCacheid);
		return MAL_SUCCEED;
	}

	if ((c = BATdescriptor(CrackerIndex[position].cid)) == NULL){
		BBPunfix(u->batCacheid);
		throw(MAL, "crackers.mergeDeletions_@1", "Cannot access cracker index");
	}
	if ((b = BATdescriptor(CrackerIndex[position].cbid)) == NULL){
		BBPunfix(u->batCacheid);
		BBPunfix(c->batCacheid);
		throw(MAL, "crackers.mergeDeletions_@1", "Cannot access cracker BAT");
	}

	/*if (endPositionStatus == -1){
		endPosition = BATcount(u) - 1;
		endPositionStatus = 0;
	}*/
	deletions = endPosition - startPosition + 1;

	remainingDel = deletions;
	delFirst = BUNfirst(u);	

	delt 	 = (@1*)Tloc(u, delFirst + startPosition);
	idxFirst = BUNfirst(c);
	crkFirst = BUNfirst(b);

	lowNode  = findNodeL_@1(*lowV, inclusiveL, CrackerIndex[position].Tree, c, idxFirst, NULL); 
	stopNode = findNodeH_@1(*hghV, inclusiveH, CrackerIndex[position].Tree, c, idxFirst, NULL); 

	LposDe = startPosition;
	HposDe = 0;
	b->batRestricted= BAT_READ;
	u->batRestricted= BAT_READ;

	if (lowNode != NULL)
		prevPos = *(oid*)Hloc(c,(idxFirst + lowNode->position)) + 1;
	else 
		prevPos = 0;

	while (1){
		if (lowNode == NULL){
			hghNode = NULL;
			temp = CrackerIndex[position].Tree;
			if (temp->deleted == FALSE)
				hghNode = temp;
			while (temp->left != NULL){
				temp = temp->left;
				if (temp->deleted == FALSE)
					hghNode = temp;
			}
		} else
			hghNode = findNextPiece(lowNode);

		/* find deletes that belong in this piece */
		if (lowNode != NULL && hghNode != NULL){
	                low    = idxFirst + lowNode->position;
                	lowVal = (@1*)Tloc(c, low);

	                hgh    = idxFirst + hghNode->position;
                	hghVal = (@1 *)Tloc(c, hgh);
        	        hghPos = (oid*)Hloc(c, hgh);

	                deletesForCurrentPiece = 0;
        	        while((@2_GT(delt,lowVal,@3@1) || (@2_EQ(delt,lowVal,@3@1) && lowNode->inclusive == TRUE))  &&
                	      (@2_LT(delt,hghVal,@3@1) || (@2_EQ(delt,hghVal,@3@1) && hghNode->inclusive == FALSE)) &&
			      remainingDel > deletesForCurrentPiece ){

                        	delt++;
	                        deletesForCurrentPiece++;
        	        }

      		        LposCr = prevPos;
        	        HposCr = *hghPos;
		} else
		if (lowNode == NULL && hghNode != NULL){
			hgh    = idxFirst + hghNode->position;
       		        hghVal = (@1 *)Tloc(c, hgh);
        	        hghPos = (oid*)Hloc(c, hgh);
	
           	        deletesForCurrentPiece = 0;
	                while( (@2_LT(delt,hghVal,@3@1) || (@2_EQ(delt,hghVal,@3@1) && hghNode->inclusive == FALSE)) &&
			       remainingDel > deletesForCurrentPiece){
                	        delt++;
                       		deletesForCurrentPiece++;
	                }

			LposCr = 0;
        	        HposCr = *hghPos;
		} else
		if (lowNode != NULL && hghNode == NULL){
			low    = idxFirst + lowNode->position ;
			deletesForCurrentPiece = remainingDel;
			LposCr = prevPos;
                        HposCr = BATcount(b)-1;
		}

		if (hghNode != NULL)
			holPiece = hghNode->hols;
		else
			holPiece = 0;

		HposCr -= holPiece;

		deletedFromCurrentPiece = 0;
		holSize = deletions - remainingDel - notFound;
		if (deletesForCurrentPiece != 0){
			HposDe = LposDe + deletesForCurrentPiece;
			crackerSlice = BATslice(b, LposCr, HposCr+1);
			deletesSlice = BATslice(u, LposDe, HposDe);
			crackerPieceO = BATmirror(BATmark(crackerSlice,(oid)0));
			deletesPieceO = VIEWhead(deletesSlice);
			positionsO = BATjoin(crackerPieceO,deletesPieceO,BATcount(deletesPieceO));

			crackerPieceV = BATmirror(BATmark(BATmirror(crackerSlice),(oid)0));
			deletesPieceV = VIEWhead(BATmirror(deletesSlice));
			positionsV = BATjoin(crackerPieceV,deletesPieceV,BATcount(deletesPieceV));

			positions = BATkintersect(positionsO, positionsV);

			if (BATcount(positions) > 0){
				positions->batRestricted = BAT_WRITE;
				BATorder(positions);


				/* fill in the hols */
				pos     = (oid*)Hloc(positions, BUNfirst(positions));
				posLast = (oid*)Hloc(positions, BUNlast(positions)-1);
				crk = crkFirst + HposCr;
				buns =  HposCr - LposCr;
				
				while(pos<=posLast){
					if (*posLast != buns){
						startH = (oid*)Hloc(b,crkFirst+(LposCr+(*pos)));
						startT = (@1 *)Tloc(b,crkFirst+(LposCr+(*pos)));
						endH  = (oid*)Hloc(b,crk);
						endT  = (@1 *)Tloc(b,crk);
						memcpy(startH, endH, sizeof(oid));
						memcpy(startT, endT, sizeof(@1));
						pos++;
					} else 
						posLast--;
					
	
					crk--; buns--;
				}

				/* values requested to be deleted may not exist */
				deletedFromCurrentPiece = BATcount(positions);
				if ( (notFoundHere = deletesForCurrentPiece - deletedFromCurrentPiece) > 0)
					notFound += notFoundHere;
				BBPunfix(positions->batCacheid);
			}

			BBPunfix(crackerSlice->batCacheid); crackerSlice = NULL;
			BBPunfix(crackerPieceO->batCacheid); crackerPieceO = NULL;
			BBPunfix(deletesSlice->batCacheid); deletesSlice = NULL;
			BBPunfix(deletesPieceO->batCacheid); deletesPieceO = NULL;
			BBPunfix(positionsO->batCacheid); positionsO = NULL;
			BBPunfix(positionsV->batCacheid); positionsV = NULL; 
			BBPunfix(crackerPieceV->batCacheid); crackerPieceV = NULL;
			BBPunfix(deletesPieceV->batCacheid); deletesPieceV = NULL;
			positions = NULL;
		}

		/* this will work both if we delete or no (then deletesForCurrentPiece=0) */
		buns = HposCr - LposCr + 1 - deletedFromCurrentPiece;

		/* no need to to shift if nothing has been deleted from previous pieces */
		if (holSize > 0 && buns > 0){
			if (holSize >= buns){
				startH = (oid*)Hloc(b,crkFirst+(LposCr-holSize));
				startT = (@1 *)Tloc(b,crkFirst+(LposCr-holSize));
				endH   = (oid*)Hloc(b,crkFirst+LposCr);
				endT   = (@1 *)Tloc(b,crkFirst+LposCr);
				memcpy(startH, endH, buns*sizeof(oid));
				memcpy(startT, endT, buns*sizeof(@1));
			}
			else{
				startH = (oid*)Hloc(b,crkFirst+(LposCr-holSize));
				startT = (@1 *)Tloc(b,crkFirst+(LposCr-holSize));
				endH   = (oid*)Hloc(b, crkFirst+(LposCr+(buns-holSize)));
				endT   = (@1 *)Tloc(b, crkFirst+(LposCr+(buns-holSize)));
				memcpy(startH, endH, holSize*sizeof(oid));
				memcpy(startT, endT, holSize*sizeof(@1));
			}
		}
		if (buns == 0 && lowNode != NULL) lowNode->deleted = TRUE; /* deleted all values in current piece*/
		remainingDel -= deletesForCurrentPiece;
		deletions += holPiece;

		/* stop the ripple once at the end of the last piece */
		if (hghNode != NULL){
			if (hghNode == stopNode)
				break;
			if (HposDe > startPosition)
				LposDe = HposDe;
			hghNode ->hols = 0;
			lowNode = hghNode;
			prevPos = *hghPos+1;
			*hghPos = *hghPos - holSize - deletedFromCurrentPiece - holPiece;
		} else
			break;
	}

	if (hghNode == NULL){
	        BATsetcount(b, BUNlast(b) - (deletions -remainingDel) + notFound);
	} else
		hghNode->hols = deletions-remainingDel - notFound;
	
	 @:shrinkDeletions(@1)@

	BBPunfix(c->batCacheid);
	BBPunfix(u->batCacheid);
	BBPunfix(b->batCacheid);
        return MAL_SUCCEED;
}
@


@- Local support functions and macros

@= UpdatesLocal
static void
printCrackerDeletions(int bid){
	int i = existsCrackerIndex(bid);
	if (i == -1)
		fprintf(stderr, " the crack index does not exist \n");
	if (CrackerIndex[i].did > 0)
		BATprint(BATdescriptor(CrackerIndex[i].did));
}

static void
printCrackerInsertions(int bid){
	int i = existsCrackerIndex(bid);
	if (i == -1)
		fprintf(stderr, " the crack index does not exist \n");
	if (CrackerIndex[i].iid > 0)
		BATprint(BATdescriptor(CrackerIndex[i].iid));
}

static void
sizeCrackerDeletions(int bid){
        BAT *u;
        int i = existsCrackerIndex(bid);

        if (i == -1)
                fprintf(stderr, " the crack index does not exist \n");
        if (CrackerIndex[i].did > 0){
                u = BATdescriptor(CrackerIndex[i].did);
                printf("\n pending deletions size: "BUNFMT"\n",BATcount(u));
                BBPunfix(u->batCacheid);
        }
        else
                printf("\n pending deletions size: 0 \n");
}

static void
sizeCrackerInsertions(int bid){
	BAT *u;

	int i = existsCrackerIndex(bid);
	if (i == -1)
		fprintf(stderr, " the crack index does not exist \n");
	if (CrackerIndex[i].iid > 0){
		u = BATdescriptor(CrackerIndex[i].iid);
		printf("\n pending insertions size: "BUNFMT" \n",BATcount(u));
		BBPunfix(u->batCacheid);
	}
	else
		printf("\n pending insertions size: 0 \n");
}

static str
removeCrackerIndex(int *bid){
	BAT *c;
	int position = -1;
	int i;

	for (i = 0; i < maxCrackMap; i++)
        	if (CrackerIndex[i].bid == *bid){
                	position = i;	
			break;
		}
	/*if (position == -1) return; Trying to erase an index that does not exist*/

	/* Destroy index BAT */
        if ((c = BATdescriptor(CrackerIndex[position].cid)) == NULL) {
                fprintf(stderr,"crackers.AddIndex: Cannot access crack index");
		return "FAILED";
        }

	BBPunfix(c->batCacheid);
	BBPreclaim(c);
	CrackerIndex[position].cid = -1;
	CrackerIndex[position].reCreate = 1;

	/* Delete Tree */
	FreeAVLTree(CrackerIndex[position].Tree);
	CrackerIndex[position].Tree = NULL;
	
	return MAL_SUCCEED;
}

static str
appendCrackerBAT(int * bid, int * new){
        BAT *c, *u;
	int position = -1;
	int i;

	for (i = 0; i < maxCrackMap; i++)
                if (CrackerIndex[i].bid == *bid){
                        position = i;
			break;	
		}

        if ((c = BATdescriptor(CrackerIndex[position].cbid)) == NULL)
                throw(MAL, "bat.append", "Cannot access descriptor");

        if ((u = BATdescriptor(*new)) == NULL) {
                BBPreleaseref(c->batCacheid);
                throw(MAL, "bat.append", "Cannot access descriptor");
        }
	
	if (BATcount(u) == 0) {
		BBPunfix(c->batCacheid);
		BBPunfix(u->batCacheid);
		return MAL_SUCCEED;
	}

        BATappend(c, u, TRUE);

	BBPunfix(c->batCacheid);
	BBPunfix(u->batCacheid);

	return MAL_SUCCEED;
}

static str
appendDeletions(int *del, int position){
	BAT *u, *c;

       	if ((u = BATdescriptor(*del)) == NULL)
      		 throw(MAL, "crackers.appendDeletions", "Cannot access deletions BAT");

	if (CrackerIndex[position].did < 0 ){
		BATmode(u,PERSISTENT);
		u->batRestricted= BAT_WRITE;
		CrackerIndex[position].did = u->batCacheid;
		BBPkeepref(u->batCacheid);
	} else {
       		if ((c = BATdescriptor(CrackerIndex[position].did)) == NULL)
      		 	throw(MAL, "crackers.appendDeletions", "Cannot access cracker deletions BAT");
		
		c = BATins(c,u, TRUE);

		BBPunfix(c->batCacheid);
		BBPunfix(u->batCacheid);
	}

        return MAL_SUCCEED;
}
@


@= mergeInsertionsFromTheEndBodyI
        BAT *c, *u, *b;
	BUN idxFirst, cur, crkFirst, insFirst, next, write;
	oid *curPos;
	oid *insh, *crkh;
	@1  *inst, *crkt, *curVal;
	int position = -1;
	struct Node *IndexNode = NULL;
	oid prevPos, prevcrsize, insertions, remainingIns, buns, needed;
	struct Node *prevNode =NULL;
	oid *startH, *endH;
	@1  *startT, *endT;

	{
		int i;
		for (i = 0; i < maxCrackMap; i++)
			if (CrackerIndex[i].bid == *bid){
				position = i;
				break;	
			}
	}

        if ((u = BATdescriptor(*new)) == NULL)
                throw(MAL, "crackers.mergeInsertions_@1", "Cannot access insertions BAT");

	/* abort if there are no insertions to merge */	
	if (BATcount(u) == 0) {
		BBPunfix(u->batCacheid);
		return MAL_SUCCEED;
	}

	if ((c = BATdescriptor(CrackerIndex[position].cid)) == NULL){
		BBPunfix(u->batCacheid);
		throw(MAL, "crackers.mergeInsertions_@1", "Cannot access cracker index");
	}
	if ((b = BATdescriptor(CrackerIndex[position].cbid)) == NULL){
		BBPunfix(u->batCacheid);
		BBPunfix(c->batCacheid);
		throw(MAL, "crackers.mergeInsertions_@1", "Cannot access cracker BAT");
	}
	if (endPositionStatus == -1){
		endPosition = BATcount(u) - 1;
		endPositionStatus = 0;
	}
	insertions = endPosition - startPosition + 1;

	/* sort in place the insertions bat */
	if (u->tsorted == FALSE){
		u->batRestricted = BAT_WRITE;
		BATmirror(BATorder(BATmirror(u)));
	}

	remainingIns = insertions;
	prevcrsize = BATcount(b);
	insFirst = BUNfirst(u);	

	/* make room for the new tuples */
	if ( insertions > BATcapacity(b) - BATcount(b) ){
		BUN ncap;
		BUN grows;
		needed = insertions - (BATcapacity(b) - BATcount(b));
                ncap = BATcapacity(b) + needed;
                grows = BATgrows(b);
                if (ncap > grows)
                        grows = ncap;

                if (BATextend(b, grows) == NULL)
                        throw(MAL, "crackers.mergeInsertions_@1", "Failed to make room for the new values");
        }
	
	insh 	 = (oid*)Hloc(u, insFirst + endPosition);
	inst 	 = (@1 *)Tloc(u, insFirst + endPosition);
	idxFirst = BUNfirst(c);
	crkFirst = BUNfirst(b);
	prevPos = prevcrsize - 1;
@

@= mergeLoop
	if ( IndexNode == NULL )
		goto mergeDone;

	/* First position after the last value of this piece. 
           Here we will start moving values we shift from the begginning of the piece */
		
	write  = next + 1 - (prevNode==NULL?0:prevNode->hols);

	cur    = idxFirst + (IndexNode->position);
        curPos = (oid*)Hloc(c, cur);
	curVal = (@1 *)Tloc(c, cur);

	buns   = prevPos - (*curPos) - (prevNode==NULL?0:prevNode->hols); /* find out how many values this piece has */

	/* prevPos takes the correct value for the next iteration */
	prevPos = *curPos;

	/* next takes the corect value for the next iteration. This is the position of the last value of the previous piece */
	next   = crkFirst + (*curPos);
	
	/* First insert any pending insertions that belong to this piece */
	crkh = (oid*)Hloc(b,write+(remainingIns-1));
	crkt = (@1 *)Tloc(b,write+(remainingIns-1));
	while(  remainingIns > 0 &&
		(@2_GT(inst,curVal,@3@1) || (@2_EQ(inst,curVal,@3@1) && IndexNode->inclusive == TRUE)) ){
		*crkh = *insh;
		*crkt = *inst;
		crkh--; crkt--; insh--; inst--; remainingIns--;
	}

	if (remainingIns == 0)
               	goto mergeDone;

	/* Then we shift values from the beggining of the piece */
	if (buns > remainingIns){
		startH = (oid*)Hloc(b,write);
		startT = (@1 *)Tloc(b,write);
		endH   = (oid*)Hloc(b,next+1);
		endT   = (@1 *)Tloc(b,next+1);
	
		memcpy(startH, endH, remainingIns*sizeof(oid));
		memcpy(startT, endT, remainingIns*sizeof(@1));
	
	}
	else{
		startH = (oid*)Hloc(b,write+remainingIns-buns);
		startT = (@1 *)Tloc(b,write+remainingIns-buns);
		endH   = (oid*)Hloc(b,next+1);
		endT   = (@1 *)Tloc(b,next+1);
	
		memcpy(startH, endH, buns*sizeof(oid));
		memcpy(startT, endT, buns*sizeof(@1));
	
	}	

	/* we always update the index to be +remainingIns since even if we move 
           buns values we put them remainingIns positions ahead */
	*curPos =  *curPos + remainingIns;
	prevNode = IndexNode;
@

@= mergeInsertionsFromTheEndBodyCG
	/* merge for the last piece only */
	if ( remainingIns > 0) {
		/* get the last piece */
		IndexNode = findNodeL_@1(*hgh, inclusive, CrackerIndex[position].Tree, c, idxFirst, NULL);
		@:mergeLoop(@1,@2,@3)@
	}
@

@= mergeInsertionsFromTheEndBodyII
	/* Here the actual merging happens. Starting from the piece where next belongs we continuously 
	   insert and shift until there are no more insertions or pieces */
	while ( remainingIns > 0) {
		IndexNode = findPreviousPieceWalkingBack(prevNode);
		@:mergeLoop(@1,@2,@3)@
	}

	mergeDone:;

	/* We reached the first piece. If there are more insertions then they all go here */
	if (IndexNode == NULL && remainingIns > 0){
		
		crkh = (oid*)Hloc(b,next + 1 - (prevNode==NULL?0:prevNode->hols) + (remainingIns-1));
                crkt = (@1 *)Tloc(b,next + 1 - (prevNode==NULL?0:prevNode->hols) + (remainingIns-1));
                while(  remainingIns > 0  ){
                        *crkh = *insh;
                        *crkt = *inst;
                        crkh--; crkt--; insh--; inst--; remainingIns--;
		}
	}
@

@= shrinkInsertions
	if (startPosition == 0 && (BUN)endPosition == BATcount(u)){
        	BATmode(u, TRANSIENT);
                CrackerIndex[position].iid = -1;
        } else  if ((BUN)endPosition == BATcount(u)){
                BATsetcount(u,insFirst + startPosition);
        } else {
		oid *startH = (oid*)Hloc(u,insFirst+startPosition);
		@1  *startT = (@1 *)Tloc(u,insFirst+startPosition);
		oid *endH   = (oid*)Hloc(u,insFirst+endPosition);
		@1  *endT   = (@1 *)Tloc(u,insFirst+endPosition);
		memmove(startH, endH, (BATcount(u)-endPosition)*sizeof(oid));
		memmove(startT, endT, (BATcount(u)-endPosition)*sizeof(@1));

   		BATsetcount(u, insFirst + (startPosition + (BATcount(u) - endPosition)));
	}
@

@= shrinkDeletions
	endPosition += 1;
{
	BAT *shrinkSLice  = BATslice(u,startPosition,endPosition);
	BAT *shrinkCopy = BATcopy(shrinkSLice, shrinkSLice->htype, shrinkSLice->ttype, TRUE);

	u = BATdel(u, shrinkCopy, TRUE);

	BBPunfix(shrinkSLice->batCacheid);
	BBPunfix(shrinkCopy->batCacheid);
}
@

@= mergeDeletionsBody
        BAT *c, *u, *b, *crackerPieceO, *deletesPieceO,  *crackerPieceV, *deletesPieceV;
	BAT *positionsO, *positionsV, *positions, *crackerSlice, *deletesSlice;
	BUN idxFirst, crk, crkFirst, delFirst, low, hgh;
	@1 *delt, *hghVal, *lowVal;
	oid *pos, *posLast;
	oid *hghPos=NULL;
	int position = -1;
	oid deletions, remainingDel, buns;
	struct Node *lowNode, *hghNode, *temp;
	oid LposCr=0,HposCr=0, LposDe, HposDe, deletesForCurrentPiece=0, deletedFromCurrentPiece;
	oid holSize, holPiece, notFound = 0, prevPos, notFoundHere;
	int i;
	@1  *startT, *endT;
	oid *startH, *endH;

	for (i = 0; i < maxCrackMap; i++)
                if (CrackerIndex[i].bid == *bid){
                        position = i;
			break;	
		}

        if ((u = BATdescriptor(*del)) == NULL)
                throw(MAL, "crackers.mergeDeletions_@1", "Cannot access insertions BAT");

	/* abort if there are no deletions to merge */	
	if (BATcount(u) == 0) {
		BBPunfix(u->batCacheid);
		return MAL_SUCCEED;
	}

	if ((c = BATdescriptor(CrackerIndex[position].cid)) == NULL){
		BBPunfix(u->batCacheid);
		throw(MAL, "crackers.mergeDeletions_@1", "Cannot access cracker index");
	}
	if ((b = BATdescriptor(CrackerIndex[position].cbid)) == NULL){
		BBPunfix(u->batCacheid);
		BBPunfix(c->batCacheid);
		throw(MAL, "crackers.mergeDeletions_@1", "Cannot access cracker BAT");
	}

	deletions = endPosition - startPosition + 1;

	remainingDel = deletions;
	delFirst = BUNfirst(u);	

	delt 	 = (@1*)Tloc(u, delFirst + startPosition);
	idxFirst = BUNfirst(c);
	crkFirst = BUNfirst(b);

	lowNode = findNodeL_@1(*delt, TRUE, CrackerIndex[position].Tree, c, idxFirst, NULL);
	LposDe = startPosition;
	HposDe = 0;
	b->batRestricted= BAT_READ;
	u->batRestricted= BAT_READ;
	if (lowNode != NULL)
		prevPos = *(oid*)Hloc(c,(idxFirst + (lowNode->position) )) + 1;
	else 
		prevPos = 0;
	while (1){
		if (lowNode == NULL){
			hghNode = NULL;
			temp = CrackerIndex[position].Tree;
			if (temp->deleted == FALSE)
				hghNode = temp;
			while (temp->left != NULL){
				temp = temp->left;
				if (temp->deleted == FALSE)
					hghNode = temp;
			}
		} else
			hghNode = findNextPiece(lowNode);


		/* find deletes that belong in this piece */
		if (lowNode != NULL && hghNode != NULL){
	                low    = idxFirst + lowNode->position;
                	lowVal = (@1*)Tloc(c, low);

	                hgh    = idxFirst + hghNode->position;
                	hghVal = (@1 *)Tloc(c, hgh);
        	        hghPos = (oid*)Hloc(c, hgh);

	                deletesForCurrentPiece = 0;
        	        while((@2_GT(delt,lowVal,@3@1) || (@2_EQ(delt,lowVal,@3@1) && lowNode->inclusive == TRUE))  &&
                	      (@2_LT(delt,hghVal,@3@1) || (@2_EQ(delt,hghVal,@3@1) && hghNode->inclusive == FALSE)) &&
			      remainingDel > deletesForCurrentPiece ){

                        	delt++;
	                        deletesForCurrentPiece++;
        	        }

      		        LposCr = prevPos;
        	        HposCr = *hghPos;
		} else
		if (lowNode == NULL && hghNode != NULL){
			hgh    = idxFirst + hghNode->position;
       		        hghVal = (@1 *)Tloc(c, hgh);
        	        hghPos = (oid*)Hloc(c, hgh);
	
           	        deletesForCurrentPiece = 0;
	                while( (@2_LT(delt,hghVal,@3@1) || (@2_EQ(delt,hghVal,@3@1) && hghNode->inclusive == FALSE)) &&
			       remainingDel > deletesForCurrentPiece){
                	        delt++;
                       		deletesForCurrentPiece++;
	                }

			LposCr = 0;
        	        HposCr = *hghPos;
		} else
		if (lowNode != NULL && hghNode == NULL){
			low    = idxFirst + lowNode->position;
			deletesForCurrentPiece = remainingDel;
			LposCr = prevPos;
                        HposCr = BATcount(b)-1;
		}

		if (hghNode != NULL)
			holPiece = hghNode->hols;
		else
			holPiece = 0;

		HposCr -= holPiece;

		deletedFromCurrentPiece = 0;
		holSize = deletions - remainingDel - notFound;
		if (deletesForCurrentPiece != 0){
			HposDe = LposDe + deletesForCurrentPiece;
			crackerSlice = BATslice(b, LposCr, HposCr+1);
			deletesSlice = BATslice(u, LposDe, HposDe);

			crackerPieceO = BATmirror(BATmark(crackerSlice,(oid)0));

			deletesPieceO = VIEWhead(deletesSlice);
			positionsO = BATjoin(crackerPieceO,deletesPieceO,BATcount(deletesPieceO));

			crackerPieceV = BATmirror(BATmark(BATmirror(crackerSlice),(oid)0));
			deletesPieceV = VIEWhead(BATmirror(deletesSlice));
			positionsV = BATjoin(crackerPieceV,deletesPieceV,BATcount(deletesPieceV));

			positions = BATkintersect(positionsO, positionsV);
			if (BATcount(positions) > 0){
				positions->batRestricted = BAT_WRITE;
				BATorder(positions);

				/* fill in the hols */
				pos = (oid*)Hloc(positions, BUNfirst(positions));
				posLast = (oid*)Hloc(positions, BUNlast(positions)-1);
				crk  = crkFirst + HposCr;
				buns = HposCr - LposCr;
				while(pos<=posLast){
					if (*posLast != buns){
						startH = (oid*)Hloc(b,crkFirst+(LposCr+(*pos)));
						startT = (@1 *)Tloc(b,crkFirst+(LposCr+(*pos)));
						endH  = (oid*)Hloc(b,crk);
						endT  = (@1 *)Tloc(b,crk);
						memcpy(startH, endH, sizeof(oid));
						memcpy(startT, endT, sizeof(@1));
						pos++;
					} else
						posLast--;
					crk--; buns--;
				}

				deletedFromCurrentPiece = BATcount(positions);
				if ( (notFoundHere = deletesForCurrentPiece - deletedFromCurrentPiece) > 0)
					notFound += notFoundHere;
				BBPunfix(positions->batCacheid);
			}

			BBPunfix(crackerSlice->batCacheid); crackerSlice = NULL;
			BBPunfix(crackerPieceO->batCacheid); crackerPieceO = NULL;
			BBPunfix(deletesSlice->batCacheid); deletesSlice = NULL;
			BBPunfix(deletesPieceO->batCacheid); deletesPieceO = NULL;
			BBPunfix(positionsO->batCacheid); positionsO = NULL;
			BBPunfix(positionsV->batCacheid); positionsV = NULL; 
			BBPunfix(crackerPieceV->batCacheid); crackerPieceV = NULL;
			BBPunfix(deletesPieceV->batCacheid); deletesPieceV = NULL;
			positions = NULL;
		}

		/* this will work both if we delete or no (then deletesForCurrentPiece=0) */
		buns = HposCr - LposCr + 1 - deletedFromCurrentPiece;
		/* no need to to shift if nothing has been deleted from previous pieces */
		if (holSize > 0 && buns > 0){
			if (holSize >= buns){
				startH = (oid*)Hloc(b,crkFirst+(LposCr-holSize));
				startT = (@1 *)Tloc(b,crkFirst+(LposCr-holSize));
				endH  = (oid*)Hloc(b,crkFirst+LposCr);
				endT  = (@1 *)Tloc(b,crkFirst+LposCr);
				memcpy(startH, endH, buns*sizeof(oid));
				memcpy(startT, endT, buns*sizeof(@1));
			}
			else{
				startH = (oid*)Hloc(b,crkFirst+(LposCr-holSize));
				startT = (@1 *)Tloc(b,crkFirst+(LposCr-holSize));
				endH  = (oid*)Hloc(b,crkFirst+(LposCr+(buns-holSize)));
				endT  = (@1 *)Tloc(b,crkFirst+(LposCr+(buns-holSize)));
				memcpy(startH, endH, holSize*sizeof(oid));
				memcpy(startT, endT, holSize*sizeof(@1));
			}
		}
		if (buns == 0 && lowNode != NULL) lowNode->deleted = TRUE; /* deleted all values in current piece*/
		remainingDel -= deletesForCurrentPiece;
		deletions += holPiece;
		if (hghNode != NULL){
			if (HposDe > startPosition)
				LposDe = HposDe;
			hghNode ->hols = 0;
			lowNode = hghNode;
			prevPos = *hghPos+1;
			*hghPos = *hghPos - holSize - deletedFromCurrentPiece - holPiece;

		} else
			break;
	}

        BATsetcount(b, BUNlast(b) - (deletions-remainingDel) + notFound);
@

@}
