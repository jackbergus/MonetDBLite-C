@' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2007 CWI.
@' All Rights Reserved.

@f crackers_updates
@a Martin Kersten, Stratos Idreos, Stefan Manegold
@d March 2006 - July 2007
@* Cracker Updates


@+ Interface


@- Type expansion

@= TypeSwitch
@:@1(chr,simple,)@
@:@1(sht,simple,)@
@:@1(int,simple,)@
@:@1(lng,simple,)@
@:@1(flt,simple,)@
@:@1(dbl,simple,)@
@:@1(date,atom,TYPE_)@
@


@- Header file
 
@h
#ifndef _CRACKERS_UPDATES_H_
#define _CRACKERS_UPDATES_H_

/* Signatures shared within the crackers module/library */
@:UpdatesSharedFunctions_decl_0@
@:TypeSwitch(UpdatesSharedFunctions_decl_1)@

/* Exported signatures */
@:UpdatesFunctions_decl_0@
@:TypeSwitch(UpdatesFunctions_decl_1)@

#endif /* _CRACKERS_UPDATES_H */
@


@- Exported signatures
 
@= UpdatesFunctions_decl_0
crackers_export str CRKsizeCrackerInsertions(int *k, int *bid);
crackers_export str CRKsizeCrackerDeletions(int *k, int *bid);
crackers_export str CRKprintCrackerInsertions(int *k, int *bid);
crackers_export str CRKprintCrackerDeletions(int *k, int *bid);
crackers_export str CRKmergeInsertions_Forget(int *k, int *bid, int *new);
crackers_export str CRKextendCrackerBAT(int *k, int *bid, lng positions);
crackers_export str CRKmergeInsertionsB_OnNeed(int *k, int *bid, int *new);
crackers_export str CRKmergeInsertionsB_OnNeedGradually(int *k, int *bid, int *new);
crackers_export str CRKmergeInsertionsB_OnNeedGraduallyRipple(int *k, int *bid, int *new);
crackers_export str CRKmergeDeletions_OnNeed(int *k, int *bid, int *new);
crackers_export str CRKmergeDeletions_OnNeedGradually(int *k, int *bid, int *new);
crackers_export str CRKmergeDeletions_OnNeedGraduallyRipple(int *k, int *bid, int *new);
@

@= UpdatesFunctions_decl_1
crackers_export str CRKmergeInsertions_PartiallyForget_@1(int *k, int *bid, int *new);
crackers_export str CRKmergeInsertionsB_Force_@1(int *k, int *bid, int *new);
@


@- Signatures shared within the crackers module/library

@= UpdatesSharedFunctions_decl_0
str appendInsertions(int *new, int position);
@

@= UpdatesSharedFunctions_decl_1
/* mergeInsertionOperations */
str mergeInsertionsB_@1(int *bid, int *new, lng startPosition, lng endPosition);
str mergeInsertionsBGradually_@1(int *bid, int *new, lng startPosition, lng endPosition);
str mergeInsertionsBRipple_@1(BAT *b, BAT *u, lng startPosition, lng endPosition, @1 *hgh, bit inclusive, int position);
str mergeDeletions_@1(int *bid, int *del, lng startPosition, lng endPosition);
str mergeDeletionsGradually_@1(int *bid, int *del, lng startPosition, lng endPosition);
str mergeDeletionsGraduallyRipple_@1(int *bid, int *del, lng startPosition, lng endPosition, @1 *lowV, bit inclusiveL, @1 *hghV, bit inclusiveH);
@


@{
@+ Implementation

 
@- C file

@c
#include "mal_config.h"
#include "crackers.h"

/* Local support functions and macros */
@:UpdatesLocal@

/* Functions shared within the crackers module/library */
@:UpdatesSharedFunctions_impl_0@
@:TypeSwitch(UpdatesSharedFunctions_impl_1)@

/* Exported functions */
@:UpdatesFunctions_impl_0@
@:updatesOnNeed(,0)@
@:updatesOnNeed(Gradually,1)@
@:updatesOnNeed(GraduallyRipple,2)@
@:TypeSwitch(UpdatesFunctions_impl_1)@
@


@- Exported functions

@= UpdatesFunctions_impl_0
str
CRKsizeCrackerDeletions(int *k, int *bid){
        (void)k;
        sizeCrackerDeletions(*bid);
        return MAL_SUCCEED;
}

str
CRKsizeCrackerInsertions(int *k, int *bid){
	(void)k;
	sizeCrackerInsertions(*bid);

	return MAL_SUCCEED;
}

str
CRKprintCrackerDeletions(int *k, int *bid){
	(void)k;
	printCrackerDeletions(*bid);

	return MAL_SUCCEED;
}

str
CRKprintCrackerInsertions(int *k, int *bid){
	(void)k;
	printCrackerInsertions(*bid);

	return MAL_SUCCEED;
}

str
CRKmergeInsertions_Forget(int *k, int *bid, int *new){
	(void) k;
	appendCrackerBAT(bid,new);
	removeCrackerIndex(bid);

	return MAL_SUCCEED;
}

str
CRKextendCrackerBAT(int *k, int *bid, lng positions){
	BAT *b;
	int position = existsCrackerIndex(*bid);
	(void) k;

	if (position == -1)
                throw(MAL, "crackers.CRKextendCrackerBAT", "Cannot find cracker index");
	if ((b = BATdescriptor(CrackerIndex[position].cbid)) == NULL)
                throw(MAL, "crackers.CRKextendCrackerBAT", "Cannot access cracker BAT");

	if (BATextend(b, positions) == NULL)
                throw(MAL, "crackers.CRKextendCrackerBAT", "Failed to extend the cracker BAT");	
	
	BBPunfix(b->batCacheid);

	return MAL_SUCCEED;
}
@

@= updatesOnNeed
str
CRKmergeInsertionsB_OnNeed@1(int *k, int *bid, int *new){
	int position = existsCrackerIndex(*bid);
        (void) k;

	if (position == -1)
		throw(MAL, "crackers.CRKmergeInsertionsB_OnNeed@1", "Cannot find cracker index");

	appendInsertions(new,position);
	CrackerIndex[position].mergeInsertions = @2;
	CrackerIndex[position].deleteNodes = FALSE;	

        return MAL_SUCCEED;
}

str
CRKmergeInsertions_OnNeed@1(int *k, int *bid, int *new, bit *deleteNodes){
	int position = existsCrackerIndex(*bid);
        (void) k;

	if (position == -1)
		throw(MAL, "crackers.CRKmergeInsertions_OnNeed@1", "Cannot find cracker index");

	appendInsertions(new,position);
	CrackerIndex[position].mergeInsertions = @2;
	CrackerIndex[position].deleteNodes = *deleteNodes;	

        return MAL_SUCCEED;
}

str
CRKmergeDeletions_OnNeed@1(int *k, int *bid, int *del){
	int position = existsCrackerIndex(*bid);
        (void) k;

	if (position == -1)
		throw(MAL, "crackers.CRKmergeDeletions_OnNeed@1", "Cannot find cracker index");

	appendDeletions(del,position);
	CrackerIndex[position].mergeDeletions = @2;

        return MAL_SUCCEED;
}
@

@= UpdatesFunctions_impl_1
str
CRKmergeInsertions_PartiallyForget_@1(int *k, int *bid, int *new){
	BAT *c, *u;
	@1 min;
	BUN inst, insLast;
	int xx, position = -1;
	int i;

	(void) k;

	if ((u = BATdescriptor(*new)) == NULL)
		throw(MAL, "crackers.mergeInsertions_PartiallyForget_@1", "Cannot access insertions");

	if (BATcount(u) == 0)
		return MAL_SUCCEED;

	for (i = 0; i < maxCrackMap; i++)
        	if (CrackerIndex[i].bid == *bid){
                	position = i;	
			break;
		}

	/*if (position == -1) return; Trying to erase an index that does not exist*/

	if ((c = BATdescriptor(CrackerIndex[position].cid)) == NULL){
                BBPunfix(u->batCacheid);
                throw(MAL, "crackers.CRKmergeInsertions_PartiallyForget_@1", "Cannot access cracker index");
        }

	/* get the min value */
	xx = BUNsize(u);
	inst = BUNtloc(u,BUNfirst(u));
	insLast = BUNtloc(u,BUNlast(u));
	min = *(@1*)inst;
	for(inst+=xx;inst < insLast; inst+=xx)
		if (@2_GT(&min,inst,@3@1))
			min = *(@1*)inst;

	/* Partially delete tree with lazy deletion */
	PartiallyLazyFreeAVLTree_@1(CrackerIndex[position].Tree, min, c, BUNfirst(c), BUNsize(c));

	appendCrackerBAT(bid,new);

	BBPunfix(c->batCacheid);
	BBPunfix(u->batCacheid);

	return MAL_SUCCEED;
}

str
CRKmergeInsertionsB_Force_@1(int *k, int *bid, int *new){
	lng startPosition = 0;
	lng endPosition   = -1;
	@1 *hgh;
	bit inclusive = TRUE;

	@:mergeInsertionsFromTheEndBodyI(@1,@2,@3)@

	(void)k;
	next = BUNlast(b) - xx;
	hgh = (@1*)BUNtloc(b,next);
	@:mergeInsertionsFromTheEndBodyCG(@1,@2,@3)@
	@:mergeInsertionsFromTheEndBodyII(@1,@2,@3)@

	crkLast = BUNlast(b) + insertions * xx;
	b->batBuns->free = crkLast - b->batBuns->base;
        BATsetcount(b, b->batBuns->free/xx);

	BBPunfix(c->batCacheid);
	BBPunfix(u->batCacheid);
	BBPunfix(b->batCacheid);

 	return MAL_SUCCEED;
}
@


@- Functions shared within the crackers module/library

@= UpdatesSharedFunctions_impl_0
/* used both for selection and sideways cracking */
str
appendInsertions(int *new, int position){
	BAT *u, *c;

       	if ((u = BATdescriptor(*new)) == NULL)
      		 throw(MAL, "crackers.appendInsertions", "Cannot access insertions BAT");

	if (CrackerIndex[position].iid < 0 ){
		BATmode(u,PERSISTENT);
		u->batRestricted= BAT_WRITE;
		CrackerIndex[position].iid = u->batCacheid;
		BBPkeepref(u->batCacheid);
	} else {
       		if ((c = BATdescriptor(CrackerIndex[position].iid)) == NULL)
      		 	throw(MAL, "crackers.appendInsertions", "Cannot access cracker insertions BAT");
		
		c = BATins(c, u,TRUE);

		BBPunfix(c->batCacheid);
		BBPunfix(u->batCacheid);
	}

        return MAL_SUCCEED;
}
@

@= UpdatesSharedFunctions_impl_1
/* mergeInsertionOperations */
str
mergeInsertionsB_@1(int *bid, int *new, lng startPosition, lng endPosition){
	@1 *hgh;
	bit inclusive = TRUE;
	@:mergeInsertionsFromTheEndBodyI(@1,@2,@3)@

	next = BUNlast(b) - xx;
	hgh = (@1*)BUNtloc(b,next);
	@:mergeInsertionsFromTheEndBodyCG(@1,@2,@3)@
	@:mergeInsertionsFromTheEndBodyII(@1,@2,@3)@

	crkLast = BUNlast(b) + insertions * xx;
	b->batBuns->free = crkLast - b->batBuns->base;
        BATsetcount(b, b->batBuns->free/xx);

	BBPunfix(c->batCacheid);
	BBPunfix(u->batCacheid);
	BBPunfix(b->batCacheid);

        return MAL_SUCCEED;
}

str
mergeInsertionsBGradually_@1(int *bid, int *new, lng startPosition, lng endPosition){
	/* First merge then shrink the insertions column */
	@1 *hgh;
	bit inclusive = TRUE;
	@:mergeInsertionsFromTheEndBodyI(@1,@2,@3)@

	next = BUNlast(b) - xx;
	hgh = (@1*)BUNtloc(b,next);
	
	@:mergeInsertionsFromTheEndBodyCG(@1,@2,@3)@
	@:mergeInsertionsFromTheEndBodyII(@1,@2,@3)@

	crkLast = BUNlast(b) + insertions * xx;
	b->batBuns->free = crkLast - b->batBuns->base;
        BATsetcount(b, b->batBuns->free/xx);
	endPosition++;

	@:shrinkInsertions(@1)@

        BBPunfix(c->batCacheid);
        BBPunfix(u->batCacheid);
        BBPunfix(b->batCacheid);

        return MAL_SUCCEED;
}

str
mergeInsertionsBRipple_@1(BAT *b, BAT *u, lng startPosition, lng endPosition, @1 *hgh, bit inclusive, int position){
        BAT *ripple;
        BUN rh, rt, rnext, insLast;
	lng toRippleBuns;
	lng exceedBuns = 0;
	struct Node * NextNode;
	bit fromTheEnd = FALSE;
	int i;
	lng consumedRipple = 0, consumedInsertions = 0, values, usedHoles = 0;
	struct Node *rippleNode = NULL;

        BAT *c;
	BUN insh, inst, crkh, crkt, idxFirst, cur, curVal, curPos, crkFirst, crkLast, insFirst, next, write;
	int xx, zz;
	struct Node *IndexNode = NULL;
	lng prevPos, prevcrsize, insertions, remainingIns, buns, needed;
	struct Node *prevNode =NULL;

	/* abort if there are no insertions to merge */	
	if (BATcount(u) == 0) {
		return MAL_SUCCEED;
	}

	if ((c = BATdescriptor(CrackerIndex[position].cid)) == NULL){
		throw(MAL, "crackers.mergeInsertions_@1", "Cannot access cracker index");
	}

	if (endPosition == -1)
		endPosition = BATcount(u) - 1;
	insertions = endPosition - startPosition + 1;

	/* sort in place the insertions bat */
	if (u->tsorted == FALSE){
		u->batRestricted = BAT_WRITE;
		BATmirror(BATorder(BATmirror(u)));
	}

	remainingIns = insertions;
	prevcrsize = BATcount(b);
	xx = BUNsize(b);
	zz = BUNsize(c);
	insFirst = BUNfirst(u);	

	/* make room for the new tuples */
	needed = insertions - (((b)->batBuns->size - (b)->batBuns->free) / xx);
	if ( needed > 0 ){
                size_t ncap = BATcapacity(b) + needed;
                size_t grows = BATgrows(b);
                if (ncap > grows)
                        grows = ncap;
                if (BATextend(b, grows) == NULL)
                        throw(MAL, "crackers.mergeInsertions_@1", "Failed to make room for the new values");
        }
	
	insh 	 = BUNhloc(u, insFirst + endPosition*xx);
	inst 	 = BUNtloc(u, insFirst + endPosition*xx);
	idxFirst = BUNfirst(c);
	crkFirst = BUNfirst(b);
	prevPos = prevcrsize - 1;

	insLast = BUNtloc(u,BUNlast(u));	
	toRippleBuns = endPosition - startPosition +1;
	ripple = BATnew(TYPE_oid, TYPE_@1, toRippleBuns);

        /* Find out buns that should be rippled. Take this values out in a temporary BAT */

	/* first find the piece where the biggest insertions should be placed */
        if ( (NextNode = findNodeH_@1(*(@1*)hgh, inclusive, CrackerIndex[position].Tree, c, idxFirst, zz, NULL)) != NULL ){

		prevNode = NextNode;
		cur     = idxFirst + (NextNode->position) * zz;
                curPos  = BUNhloc(c, cur);

		/* prevPos should not be changed! 
		   mergeInsertionsFromTheEndBodyII expects it to point in the position from where merging will start */
		prevPos = *(lng*)curPos;

		/* merging will start from this bun */		
		next = crkFirst + (*(lng*)curPos) * xx;

		/* use hols if any at the end of the result area */
		if (NextNode->hols > 0){
			rippleNode = NextNode;
			if (NextNode->hols >= insertions)
				goto rippled;
			else 
			if (NextNode->hols < insertions)
				toRippleBuns -= NextNode->hols; 
			
		}

		rh = BUNhloc(ripple, BUNfirst(ripple));
		rt = BUNtloc(ripple, BUNfirst(ripple));

                rnext   = crkFirst + (*(lng*)curPos) * xx + xx;

		NextNode->deleted = TRUE; /* TODO: consider not deleting this piece and instead extend it... */

                crkh = BUNhloc(b,rnext);
                crkt = BUNtloc(b,rnext);
		crkLast = BUNtloc(b,BUNlast(b));

		/* find out how many buns until we get into the next chunk. Variable buns holds this information*/ 
		if  ((NextNode =findNextPiece(NextNode)) == NULL)
			buns = values = BATcount(b) - prevPos - 1;
		else {
			cur    = idxFirst + (NextNode->position) * zz;
               		curPos = BUNhloc(c, cur);
                	rnext   = crkFirst + (*(lng*)curPos) * xx + xx;
                	buns   = (*(lng*)curPos) - prevPos;
			values = buns - NextNode->hols;
		}
		/* move values out. If we get into the next piece then we simply delete it */
		for (i=0; i<toRippleBuns; i++){
		
			if (i == buns && crkt < crkLast){
				NextNode->deleted = TRUE;
				if  ((NextNode =findNextPiece(NextNode)) == NULL)
					buns = values = BATcount(b) - prevPos - 1;
				else {
					cur    = idxFirst + (NextNode->position)*zz;
               				curPos = BUNhloc(c, cur);
                			rnext  = crkFirst + (*(lng*)curPos)*xx + xx;
                			buns   = (*(lng*)curPos) - prevPos;
					values = buns - NextNode->hols;
				}
			}

			/* do not ripple if this is a hole */
			if (i< values){
				*(oid*)rh = *(oid*)crkh;
				*(@1 *)rt = *(@1 *)crkt;
				rh+=xx; rt+=xx; 
			} else { 
				if (NextNode!=NULL)
					NextNode->hols --;
				usedHoles++;
			}
			crkh+=xx; crkt+=xx;	

			/* we consumed all values until the end of the column. nothing more to ripple */
			if (crkt >= crkLast){
				i++;
				exceedBuns = toRippleBuns - i;
				break;
			}
		}
		if (i == buns && NextNode != NULL) {
			NextNode->deleted = TRUE;
			/*printf("\n have to delete piece "LLFMT"  \n", *(lng*)curPos);*/
		}
		ripple->batBuns->free = BUNfirst(ripple) + (i-usedHoles)*xx - ripple->batBuns->base;	
		BATsetcount(ripple, i-usedHoles);
	} else {
		/* then we do not have to ripple. We simply start merging from the end of the cracker column */
		exceedBuns = toRippleBuns;
		next = BUNlast(b) - xx;
		/* prevPos has been correctly set in mergeInsertionsFromTheEndBodyI pointing at the last bun of the cracker column */
		fromTheEnd = TRUE;
	}
	rippled:;

	if (fromTheEnd){
		@:mergeInsertionsFromTheEndBodyCG(@1,@2,@3)@
	}
        @:mergeInsertionsFromTheEndBodyII(@1,@2,@3)@
		
	if (exceedBuns > 0){
		crkLast = BUNlast(b) + exceedBuns * xx;
		b->batBuns->free = crkLast - b->batBuns->base;
       	 	BATsetcount(b, b->batBuns->free/xx);
        }

	if (rippleNode != NULL){
		if (rippleNode->hols > insertions)
			rippleNode->hols -= insertions;
		else
		if (rippleNode->hols <= insertions)
			rippleNode->hols = 0;
	}
	endPosition++;

	/* now we have to merge the rippled values with the remaining insertions */
	if (BATcount(ripple) > 0){
		/* do not ripple values that are marked as pending deletions */
		if (CrackerIndex[position].mergeDeletions > 0){
			BAT *deletes, *ripBAT;
			if (CrackerIndex[position].did < 0) goto merge;			
			if ((deletes = BATdescriptor(CrackerIndex[position].did)) == NULL)
		                return "Cannot access the deletions BAT";	
			if (BATcount(deletes)==0) {
				BBPunfix(deletes->batCacheid);
				goto merge;
			}

			ripple->hsorted = FALSE;
			ripple->tsorted = FALSE;
			ripple->tdense = FALSE;
			ripple->hdense = FALSE;

			/* this is just to bypass a bug and shuold be removed from here */
			deletes->hsorted = FALSE;
			deletes->tsorted = FALSE;
			deletes->tdense = FALSE;
			deletes->hdense = FALSE;

			ripBAT = BATsintersect(ripple,deletes);

			if (BATcount(ripBAT)>0){
				ripple = BATdel(ripple,ripBAT,TRUE);
				deletes = BATdel(deletes,ripBAT,TRUE);
			} 

                      	BBPunfix(deletes->batCacheid);
                        BBPunfix(ripBAT->batCacheid);
		}
		merge:;
		if (BATcount(ripple)==0)
                        goto EmptyRipple;

		ripple->tsorted = FALSE;		
		ripple->batRestricted = BAT_WRITE;
		BATmirror(BATorder(BATmirror(ripple)));
		
		/* merge */
		rh    = BUNhloc(ripple, BUNfirst(ripple));
		rt    = BUNtloc(ripple, BUNfirst(ripple));
		crkh  = BUNhloc(u,insFirst+startPosition*xx);
		crkt  = BUNtloc(u,insFirst+startPosition*xx);
		insh  = BUNhloc(u,insFirst+endPosition*xx);
		inst  = BUNtloc(u,insFirst+endPosition*xx);

		crkLast = BUNtloc(ripple,BUNlast(ripple));
		while(rt < crkLast && inst < insLast){
			if (@2_LE(rt,inst,@3@1)){	
				*(oid*)crkh = *(oid*)rh;
				*( @1*)crkt = *( @1*)rt;
				rh+=xx; rt+=xx; consumedRipple++;
			} else {
				*(oid*)crkh = *(oid*)insh;
				*( @1*)crkt = *( @1*)inst;
				insh+=xx; inst+=xx; consumedInsertions++;
			}
			crkh+=xx; crkt+=xx;
		}
		
		if (rt < crkLast && inst == insLast){
			int i;
			for(i = 0; (size_t)i<BATcount(ripple)-(size_t)consumedRipple; i++){
				*(oid*)crkh = *(oid*)rh;
                                *( @1*)crkt = *( @1*)rt;
				 rh+=xx; rt+=xx;crkh+=xx; crkt+=xx;
			}
		} else	
		if (rt == crkLast && inst < insLast){
			int i;
			for(i = 0; (size_t)i<BATcount(u)-(size_t)endPosition -(size_t)consumedInsertions; i++){
                                *(oid*)crkh = *(oid*)insh;
                                *( @1*)crkt = *( @1*)inst;
                                 insh+=xx; inst+=xx;crkh+=xx; crkt+=xx;
                        }
		}
		/* if some of the insertions went at the end of the cracker column, then the pending insertions has less values now */
		crkLast = BUNlast(u) - (insertions - BATcount(ripple))*xx;
               	u->batBuns->free = crkLast - u->batBuns->base;
                BATsetcount(u, u->batBuns->free/xx);
	} else {
		EmptyRipple:;
		@:shrinkInsertions(@1)@
	}

        BBPunfix(c->batCacheid);
	BBPunfix(ripple->batCacheid);

        return MAL_SUCCEED;
}

str
mergeDeletions_@1(int *bid, int *del, lng startPosition, lng endPosition){
	@:mergeDeletionsBody(@1,@2,@3)@

	BBPunfix(c->batCacheid);
	BBPunfix(u->batCacheid);
	BBPunfix(b->batCacheid);

        return MAL_SUCCEED;
}

str
mergeDeletionsGradually_@1(int *bid, int *del, lng startPosition, lng endPosition){
        @:mergeDeletionsBody(@1,@2,@3)@

	@:shrinkDeletions(@1)@

        BBPunfix(c->batCacheid);
        BBPunfix(u->batCacheid);
        BBPunfix(b->batCacheid);

        return MAL_SUCCEED;
}

str
mergeDeletionsGraduallyRipple_@1(int *bid, int *del, lng startPosition, lng endPosition, @1 *lowV, bit inclusiveL, @1 *hghV, bit inclusiveH){
        BAT *c, *u, *b, *crackerPieceO, *deletesPieceO,  *crackerPieceV, *deletesPieceV;
	BAT *positionsO, *positionsV, *positions, *crackerSlice, *deletesSlice;
	BUN delt, idxFirst, crk, crkFirst, crkLast, delFirst, low, lowVal, hgh, hghPos=NULL, hghVal, pos, posLast;
	int xx, zz, pp, position = -1;
	lng deletions, remainingDel, buns;

	struct Node *lowNode, *hghNode, *temp, *stopNode;
	lng LposCr=0,HposCr=0, LposDe, HposDe, deletesForCurrentPiece=0, deletedFromCurrentPiece;
	lng holSize, holPiece, notFound = 0, prevPos, notFoundHere;
	int i;


	for (i = 0; i < maxCrackMap; i++)
                if (CrackerIndex[i].bid == *bid){
                        position = i;
			break;	
		}

        if ((u = BATdescriptor(*del)) == NULL)
                throw(MAL, "crackers.mergeDeletions_@1", "Cannot access insertions BAT");

	/* abort if there are no deletions to merge */	
	if (BATcount(u) == 0) {
		BBPunfix(u->batCacheid);
		return MAL_SUCCEED;
	}

	if ((c = BATdescriptor(CrackerIndex[position].cid)) == NULL){
		BBPunfix(u->batCacheid);
		throw(MAL, "crackers.mergeDeletions_@1", "Cannot access cracker index");
	}
	if ((b = BATdescriptor(CrackerIndex[position].cbid)) == NULL){
		BBPunfix(u->batCacheid);
		BBPunfix(c->batCacheid);
		throw(MAL, "crackers.mergeDeletions_@1", "Cannot access cracker BAT");
	}

	if (endPosition == -1)
		endPosition = BATcount(u) - 1;

	deletions = endPosition - startPosition + 1;

	remainingDel = deletions;
	xx = BUNsize(b);
	zz = BUNsize(c);
	delFirst = BUNfirst(u);	

	delt 	 = BUNtloc(u, delFirst + startPosition*xx);
	idxFirst = BUNfirst(c);
	crkFirst = BUNfirst(b);

	lowNode = findNodeL_@1(*lowV, inclusiveL, CrackerIndex[position].Tree, c, idxFirst, zz, NULL); 
	stopNode = findNodeH_@1(*hghV, inclusiveH, CrackerIndex[position].Tree, c, idxFirst, zz, NULL); 

	LposDe = startPosition;
	HposDe = 0;
	b->batRestricted= BAT_READ;
	u->batRestricted= BAT_READ;

	if (lowNode != NULL)
		prevPos = *(lng*)BUNhloc(c,(idxFirst + (lowNode->position) * zz)) + 1;
	else 
		prevPos = 0;

	while (1){
		if (lowNode == NULL){
			hghNode = NULL;
			temp = CrackerIndex[position].Tree;
			if (temp->deleted == FALSE)
				hghNode = temp;
			while (temp->left != NULL){
				temp = temp->left;
				if (temp->deleted == FALSE)
					hghNode = temp;
			}
		} else
			hghNode = findNextPiece(lowNode);

		/* find deletes that belong in this piece */
		if (lowNode != NULL && hghNode != NULL){
	                low    = idxFirst + (lowNode->position) * zz;
                	lowVal = BUNtloc(c, low);

	                hgh    = idxFirst + (hghNode->position) * zz;
                	hghVal = BUNtloc(c, hgh);
        	        hghPos = BUNhloc(c, hgh);

	                deletesForCurrentPiece = 0;
        	        while((@2_GT(delt,lowVal,@3@1) || (@2_EQ(delt,lowVal,@3@1) && lowNode->inclusive == TRUE))  &&
                	      (@2_LT(delt,hghVal,@3@1) || (@2_EQ(delt,hghVal,@3@1) && hghNode->inclusive == FALSE)) &&
			      remainingDel > deletesForCurrentPiece ){

                        	delt+=xx;
	                        deletesForCurrentPiece++;
        	        }

      		        LposCr = prevPos;
        	        HposCr = *(lng*)hghPos;
		} else
		if (lowNode == NULL && hghNode != NULL){
			hgh    = idxFirst + (hghNode->position) * zz;
       		        hghVal = BUNtloc(c, hgh);
        	        hghPos = BUNhloc(c, hgh);
	
           	        deletesForCurrentPiece = 0;
	                while( (@2_LT(delt,hghVal,@3@1) || (@2_EQ(delt,hghVal,@3@1) && hghNode->inclusive == FALSE)) &&
			       remainingDel > deletesForCurrentPiece){
                	        delt+=xx;
                       		deletesForCurrentPiece++;
	                }

			LposCr = 0;
        	        HposCr = *(lng*)hghPos;
		} else
		if (lowNode != NULL && hghNode == NULL){
			low    = idxFirst + (lowNode->position) * zz;
			deletesForCurrentPiece = remainingDel;
			LposCr = prevPos;
                        HposCr = BATcount(b)-1;
		}

		if (hghNode != NULL)
			holPiece = hghNode->hols;
		else
			holPiece = 0;

		HposCr -= holPiece;

		deletedFromCurrentPiece = 0;
		holSize = deletions - remainingDel - notFound;
		if (deletesForCurrentPiece != 0){
			HposDe = LposDe + deletesForCurrentPiece;
			crackerSlice = BATslice(b, LposCr, HposCr+1);
			deletesSlice = BATslice(u, LposDe, HposDe);
			crackerPieceO = BATmirror(BATmark(crackerSlice,(oid)0));
			deletesPieceO = VIEWhead(deletesSlice);
			positionsO = BATjoin(crackerPieceO,deletesPieceO,BATcount(deletesPieceO));

			crackerPieceV = BATmirror(BATmark(BATmirror(crackerSlice),(oid)0));
			deletesPieceV = VIEWhead(BATmirror(deletesSlice));
			positionsV = BATjoin(crackerPieceV,deletesPieceV,BATcount(deletesPieceV));

			positions = BATkintersect(positionsO, positionsV);

			if (BATcount(positions) > 0){
				positions->batRestricted = BAT_WRITE;
				BATorder(positions);


				/* fill in the hols */
				pp = BUNsize(positions);
				pos = BUNhloc(positions, BUNfirst(positions));
				posLast = BUNhloc(positions, BUNlast(positions)-pp);
				crk = crkFirst + HposCr*xx;
				buns =  HposCr - LposCr;
				
				while(pos<=posLast){
					if (*(oid*)posLast != (size_t)buns){
						memcpy(crkFirst+(LposCr+(*(oid*)pos))*xx, crk, xx);
						pos+=pp;
					} else 
						posLast-=pp;
					
	
					crk-=xx; buns--;
				}

				/* values requested to be deleted may not exist */
				deletedFromCurrentPiece = BATcount(positions);
				if ( (notFoundHere = deletesForCurrentPiece - deletedFromCurrentPiece) > 0)
					notFound += notFoundHere;
				BBPunfix(positions->batCacheid);
			}

			BBPunfix(crackerSlice->batCacheid); crackerSlice = NULL;
			BBPunfix(crackerPieceO->batCacheid); crackerPieceO = NULL;
			BBPunfix(deletesSlice->batCacheid); deletesSlice = NULL;
			BBPunfix(deletesPieceO->batCacheid); deletesPieceO = NULL;
			BBPunfix(positionsO->batCacheid); positionsO = NULL;
			BBPunfix(positionsV->batCacheid); positionsV = NULL; 
			BBPunfix(crackerPieceV->batCacheid); crackerPieceV = NULL;
			BBPunfix(deletesPieceV->batCacheid); deletesPieceV = NULL;
			positions = NULL;
		}

		/* this will work both if we delete or no (then deletesForCurrentPiece=0) */
		buns = HposCr - LposCr + 1 - deletedFromCurrentPiece;

		/* no need to to shift if nothing has been deleted from previous pieces */
		if (holSize > 0 && buns > 0){
			if (holSize >= buns)
				memcpy(crkFirst+(LposCr-holSize)*xx, crkFirst+LposCr*xx, buns*xx);
			else
				memcpy(crkFirst+(LposCr-holSize)*xx, crkFirst+(LposCr+(buns-holSize))*xx, holSize*xx);
		}
		if (buns == 0 && lowNode != NULL) lowNode->deleted = TRUE; /* deleted all values in current piece*/
		remainingDel -= deletesForCurrentPiece;
		deletions += holPiece;

		/* stop the ripple once at the end of the last piece */
		if (hghNode != NULL){
			if (hghNode == stopNode)
				break;
			if (HposDe > startPosition)
				LposDe = HposDe;
			hghNode ->hols = 0;
			lowNode = hghNode;
			prevPos = *(lng*)hghPos+1;
			*(lng*)hghPos = *(lng*)hghPos - holSize - deletedFromCurrentPiece - holPiece;
		} else
			break;
	}

	if (hghNode == NULL){
		crkLast = BUNlast(b) - (deletions -remainingDel)*xx + notFound*xx;
		b->batBuns->free = crkLast - b->batBuns->base;
	        BATsetcount(b, b->batBuns->free/xx);
	} else
		hghNode->hols = deletions-remainingDel - notFound;
	
	 @:shrinkDeletions(@1)@

	BBPunfix(c->batCacheid);
	BBPunfix(u->batCacheid);
	BBPunfix(b->batCacheid);
        return MAL_SUCCEED;
}
@


@- Local support functions and macros

@= UpdatesLocal
static void
printCrackerDeletions(int bid){
	int i = existsCrackerIndex(bid);
	if (i == -1)
		fprintf(stderr, " the crack index does not exist \n");
	if (CrackerIndex[i].did > 0)
		BATprint(BATdescriptor(CrackerIndex[i].did));
}

static void
printCrackerInsertions(int bid){
	int i = existsCrackerIndex(bid);
	if (i == -1)
		fprintf(stderr, " the crack index does not exist \n");
	if (CrackerIndex[i].iid > 0)
		BATprint(BATdescriptor(CrackerIndex[i].iid));
}

static void
sizeCrackerDeletions(int bid){
        BAT *u;
        int i = existsCrackerIndex(bid);

        if (i == -1)
                fprintf(stderr, " the crack index does not exist \n");
        if (CrackerIndex[i].did > 0){
                u = BATdescriptor(CrackerIndex[i].did);
                printf("\n pending deletions size: "SZFMT"\n",BATcount(u));
                BBPunfix(u->batCacheid);
        }
        else
                printf("\n pending deletions size: 0 \n");
}

static void
sizeCrackerInsertions(int bid){
	BAT *u;

	int i = existsCrackerIndex(bid);
	if (i == -1)
		fprintf(stderr, " the crack index does not exist \n");
	if (CrackerIndex[i].iid > 0){
		u = BATdescriptor(CrackerIndex[i].iid);
		printf("\n pending insertions size: "SZFMT" \n",BATcount(u));
		BBPunfix(u->batCacheid);
	}
	else
		printf("\n pending insertions size: 0 \n");
}

static str
removeCrackerIndex(int *bid){
	BAT *c;
	int position = -1;
	int i;

	for (i = 0; i < maxCrackMap; i++)
        	if (CrackerIndex[i].bid == *bid){
                	position = i;	
			break;
		}
	/*if (position == -1) return; Trying to erase an index that does not exist*/

	/* Destroy index BAT */
        if ((c = BATdescriptor(CrackerIndex[position].cid)) == NULL) {
                fprintf(stderr,"crackers.AddIndex: Cannot access crack index");
		return "FAILED";
        }

	BBPunfix(c->batCacheid);
	BBPreclaim(c);
	CrackerIndex[position].cid = -1;
	CrackerIndex[position].reCreate = 1;

	/* Delete Tree */
	FreeAVLTree(CrackerIndex[position].Tree);
	CrackerIndex[position].Tree = NULL;
	
	return MAL_SUCCEED;
}

static str
appendCrackerBAT(int * bid, int * new){
        BAT *c, *u;
	int position = -1;
	int i;

	for (i = 0; i < maxCrackMap; i++)
                if (CrackerIndex[i].bid == *bid){
                        position = i;
			break;	
		}

        if ((c = BATdescriptor(CrackerIndex[position].cbid)) == NULL)
                throw(MAL, "bat.append", "Cannot access descriptor");

        if ((u = BATdescriptor(*new)) == NULL) {
                BBPreleaseref(c->batCacheid);
                throw(MAL, "bat.append", "Cannot access descriptor");
        }
	
	if (BATcount(u) == 0) {
		BBPunfix(c->batCacheid);
		BBPunfix(u->batCacheid);
		return MAL_SUCCEED;
	}

        BATappend(c, u, TRUE);

	BBPunfix(c->batCacheid);
	BBPunfix(u->batCacheid);

	return MAL_SUCCEED;
}

static str
appendDeletions(int *del, int position){
	BAT *u, *c;

       	if ((u = BATdescriptor(*del)) == NULL)
      		 throw(MAL, "crackers.appendDeletions", "Cannot access deletions BAT");

	if (CrackerIndex[position].did < 0 ){
		BATmode(u,PERSISTENT);
		u->batRestricted= BAT_WRITE;
		CrackerIndex[position].did = u->batCacheid;
		BBPkeepref(u->batCacheid);
	} else {
       		if ((c = BATdescriptor(CrackerIndex[position].did)) == NULL)
      		 	throw(MAL, "crackers.appendDeletions", "Cannot access cracker deletions BAT");
		
		c = BATins(c,u, TRUE);

		BBPunfix(c->batCacheid);
		BBPunfix(u->batCacheid);
	}

        return MAL_SUCCEED;
}
@


@= mergeInsertionsFromTheEndBodyI
        BAT *c, *u, *b;
	BUN insh, inst, crkh, crkt, idxFirst, cur, curVal, curPos, crkFirst, crkLast, insFirst, next, write;
	int xx, zz, position = -1;
	struct Node *IndexNode = NULL;
	lng prevPos, prevcrsize, insertions, remainingIns, buns, needed;
	struct Node *prevNode =NULL;

	{
		int i;
		for (i = 0; i < maxCrackMap; i++)
			if (CrackerIndex[i].bid == *bid){
				position = i;
				break;	
			}
	}

        if ((u = BATdescriptor(*new)) == NULL)
                throw(MAL, "crackers.mergeInsertions_@1", "Cannot access insertions BAT");

	/* abort if there are no insertions to merge */	
	if (BATcount(u) == 0) {
		BBPunfix(u->batCacheid);
		return MAL_SUCCEED;
	}

	if ((c = BATdescriptor(CrackerIndex[position].cid)) == NULL){
		BBPunfix(u->batCacheid);
		throw(MAL, "crackers.mergeInsertions_@1", "Cannot access cracker index");
	}
	if ((b = BATdescriptor(CrackerIndex[position].cbid)) == NULL){
		BBPunfix(u->batCacheid);
		BBPunfix(c->batCacheid);
		throw(MAL, "crackers.mergeInsertions_@1", "Cannot access cracker BAT");
	}
	if (endPosition == -1)
		endPosition = BATcount(u) - 1;
	insertions = endPosition - startPosition + 1;

	/* sort in place the insertions bat */
	if (u->tsorted == FALSE){
		u->batRestricted = BAT_WRITE;
		BATmirror(BATorder(BATmirror(u)));
	}

	remainingIns = insertions;
	prevcrsize = BATcount(b);
	xx = BUNsize(b);
	zz = BUNsize(c);
	insFirst = BUNfirst(u);	

	/* make room for the new tuples */
	needed = insertions - (((b)->batBuns->size - (b)->batBuns->free) / xx);
	if ( needed > 0 ){
                size_t ncap = BATcapacity(b) + needed;
                size_t grows = BATgrows(b);
                if (ncap > grows)
                        grows = ncap;
                if (BATextend(b, grows) == NULL)
                        throw(MAL, "crackers.mergeInsertions_@1", "Failed to make room for the new values");
        }
	
	insh 	 = BUNhloc(u, insFirst + endPosition*xx);
	inst 	 = BUNtloc(u, insFirst + endPosition*xx);
	idxFirst = BUNfirst(c);
	crkFirst = BUNfirst(b);
	prevPos = prevcrsize - 1;
@

@= mergeLoop
	if ( IndexNode == NULL )
		goto mergeDone;

	/* First position after the last value of this piece. 
           Here we will start moving values we shift from the begginning of the piece */
		
	write  = next + xx - (prevNode==NULL?0:prevNode->hols)*xx;

	cur    = idxFirst + (IndexNode->position) * zz;
        curPos = BUNhloc(c, cur);
	curVal = BUNtloc(c, cur);

	buns   = prevPos - (*(lng*)curPos) - (prevNode==NULL?0:prevNode->hols); /* find out how many values this piece has */

	/* prevPos takes the correct value for the next itteration */
	prevPos = *(lng*)curPos;

	/* next takes the corect value for the next itteration. This is the position of the last value of the previous piece */
	next   = crkFirst + (*(lng*)curPos) * xx;
	
	/* First insert any pending insertions that belong to this piece */
	crkh = BUNhloc(b,write+(remainingIns-1)*xx);
	crkt = BUNtloc(b,write+(remainingIns-1)*xx);
	while(  remainingIns > 0 &&
		(@2_GT(inst,curVal,@3@1) || (@2_EQ(inst,curVal,@3@1) && IndexNode->inclusive == TRUE)) ){
		*(oid*)crkh = *(oid*)insh;
		*(@1 *)crkt = *(@1 *)inst;
		crkh-=xx; crkt-=xx; insh-=xx; inst-=xx; remainingIns--;
	}

	if (remainingIns == 0)
               	goto mergeDone;

	/* Then we shift values from the beggining of the piece */
	if (buns > remainingIns)
		memcpy(write, next+xx, remainingIns*xx);
	 else
		memcpy( write+ (remainingIns-buns)*xx, next+xx, buns*xx);
		
	/* we always update the index to be +remainingIns since even if we move 
           buns values we put them remainingIns positions ahead */
	*(lng*)curPos =  *(lng*)curPos + remainingIns;
	prevNode = IndexNode;
@

@= mergeInsertionsFromTheEndBodyCG
	/* merge for the last piece only */
	if ( remainingIns > 0) {
		/* get the last piece */
		IndexNode = findNodeL_@1(*(@1*)hgh, inclusive, CrackerIndex[position].Tree, c, idxFirst, zz, NULL);
		@:mergeLoop(@1,@2,@3)@
	}
@

@= mergeInsertionsFromTheEndBodyII
	/* Here the actual merging happens. Starting from the piece where next belongs we continuously 
	   insert and shift until there are no more insertions or pieces */
	while ( remainingIns > 0) {
		IndexNode = findPreviousPieceWalkingBack(prevNode);
		@:mergeLoop(@1,@2,@3)@
	}

	mergeDone:;

	/* We reached the first piece. If there are more insertions then they all go here */
	if (IndexNode == NULL && remainingIns > 0){
		
		crkh = BUNhloc(b,next + xx - (prevNode==NULL?0:prevNode->hols)*xx + (remainingIns-1)*xx);
                crkt = BUNtloc(b,next + xx - (prevNode==NULL?0:prevNode->hols)*xx + (remainingIns-1)*xx);
                while(  remainingIns > 0  ){
                        *(oid*)crkh = *(oid*)insh;
                        *(@1 *)crkt = *(@1 *)inst;
                        crkh-=xx; crkt-=xx; insh-=xx; inst-=xx; remainingIns--;
		}
	}
@

@= shrinkInsertions
	if (startPosition == 0 && (size_t)endPosition == BATcount(u)){
        	BATmode(u, TRANSIENT);
                CrackerIndex[position].iid = -1;
        } else  if ((size_t)endPosition == BATcount(u)){
                crkLast = insFirst + startPosition*xx;
                u->batBuns->free = crkLast - u->batBuns->base;
                BATsetcount(u, u->batBuns->free/xx);
        } else {
		crkh  = insFirst+startPosition*xx;
		insh  = insFirst+endPosition*xx;
		memmove(crkh,insh, (BATcount(u)-endPosition)*xx);

		crkLast = insFirst + (startPosition + (BATcount(u) - endPosition))*xx;
		u->batBuns->free = crkLast - u->batBuns->base;
   		BATsetcount(u, u->batBuns->free/xx);
	}
@

@= shrinkDeletions
	endPosition += 1;
{
	BAT *shrinkSLice  = BATslice(u,startPosition,endPosition);
	BAT *shrinkCopy = BATcopy(shrinkSLice, shrinkSLice->htype, shrinkSLice->ttype, TRUE);

	u = BATdel(u, shrinkCopy, TRUE);

	BBPunfix(shrinkSLice->batCacheid);
	BBPunfix(shrinkCopy->batCacheid);
}
@

@= mergeDeletionsBody
        BAT *c, *u, *b, *crackerPieceO, *deletesPieceO,  *crackerPieceV, *deletesPieceV;
	BAT *positionsO, *positionsV, *positions, *crackerSlice, *deletesSlice;
	BUN delt, idxFirst, crk, crkFirst, crkLast, delFirst, low, lowVal, hgh, hghPos=NULL, hghVal, pos, posLast;
	int xx, zz, pp, position = -1;
	lng deletions, remainingDel, buns;
	struct Node *lowNode, *hghNode, *temp;
	lng LposCr=0,HposCr=0, LposDe, HposDe, deletesForCurrentPiece=0, deletedFromCurrentPiece;
	lng holSize, holPiece, notFound = 0, prevPos, notFoundHere;
	int i;

	for (i = 0; i < maxCrackMap; i++)
                if (CrackerIndex[i].bid == *bid){
                        position = i;
			break;	
		}

        if ((u = BATdescriptor(*del)) == NULL)
                throw(MAL, "crackers.mergeDeletions_@1", "Cannot access insertions BAT");

	/* abort if there are no deletions to merge */	
	if (BATcount(u) == 0) {
		BBPunfix(u->batCacheid);
		return MAL_SUCCEED;
	}

	if ((c = BATdescriptor(CrackerIndex[position].cid)) == NULL){
		BBPunfix(u->batCacheid);
		throw(MAL, "crackers.mergeDeletions_@1", "Cannot access cracker index");
	}
	if ((b = BATdescriptor(CrackerIndex[position].cbid)) == NULL){
		BBPunfix(u->batCacheid);
		BBPunfix(c->batCacheid);
		throw(MAL, "crackers.mergeDeletions_@1", "Cannot access cracker BAT");
	}

	if (endPosition == -1)
		endPosition = BATcount(u) - 1;

	deletions = endPosition - startPosition + 1;

	remainingDel = deletions;
	xx = BUNsize(b);
	zz = BUNsize(c);
	delFirst = BUNfirst(u);	

	delt 	 = BUNtloc(u, delFirst + startPosition*xx);
	idxFirst = BUNfirst(c);
	crkFirst = BUNfirst(b);

	lowNode = findNodeL_@1(*(@1*)delt, TRUE, CrackerIndex[position].Tree, c, idxFirst, zz, NULL);
	LposDe = startPosition;
	HposDe = 0;
	b->batRestricted= BAT_READ;
	u->batRestricted= BAT_READ;
	if (lowNode != NULL)
		prevPos = *(lng*)BUNhloc(c,(idxFirst + (lowNode->position) * zz)) + 1;
	else 
		prevPos = 0;
	while (1){
		if (lowNode == NULL){
			hghNode = NULL;
			temp = CrackerIndex[position].Tree;
			if (temp->deleted == FALSE)
				hghNode = temp;
			while (temp->left != NULL){
				temp = temp->left;
				if (temp->deleted == FALSE)
					hghNode = temp;
			}
		} else
			hghNode = findNextPiece(lowNode);


		/* find deletes that belong in this piece */
		if (lowNode != NULL && hghNode != NULL){
	                low    = idxFirst + (lowNode->position) * zz;
                	lowVal = BUNtloc(c, low);

	                hgh    = idxFirst + (hghNode->position) * zz;
                	hghVal = BUNtloc(c, hgh);
        	        hghPos = BUNhloc(c, hgh);

	                deletesForCurrentPiece = 0;
        	        while((@2_GT(delt,lowVal,@3@1) || (@2_EQ(delt,lowVal,@3@1) && lowNode->inclusive == TRUE))  &&
                	      (@2_LT(delt,hghVal,@3@1) || (@2_EQ(delt,hghVal,@3@1) && hghNode->inclusive == FALSE)) &&
			      remainingDel > deletesForCurrentPiece ){

                        	delt+=xx;
	                        deletesForCurrentPiece++;
        	        }

      		        LposCr = prevPos;
        	        HposCr = *(lng*)hghPos;
		} else
		if (lowNode == NULL && hghNode != NULL){
			hgh    = idxFirst + (hghNode->position) * zz;
       		        hghVal = BUNtloc(c, hgh);
        	        hghPos = BUNhloc(c, hgh);
	
           	        deletesForCurrentPiece = 0;
	                while( (@2_LT(delt,hghVal,@3@1) || (@2_EQ(delt,hghVal,@3@1) && hghNode->inclusive == FALSE)) &&
			       remainingDel > deletesForCurrentPiece){
                	        delt+=xx;
                       		deletesForCurrentPiece++;
	                }

			LposCr = 0;
        	        HposCr = *(lng*)hghPos;
		} else
		if (lowNode != NULL && hghNode == NULL){
			low    = idxFirst + (lowNode->position) * zz;
			deletesForCurrentPiece = remainingDel;
			LposCr = prevPos;
                        HposCr = BATcount(b)-1;
		}

		if (hghNode != NULL)
			holPiece = hghNode->hols;
		else
			holPiece = 0;

		HposCr -= holPiece;

		deletedFromCurrentPiece = 0;
		holSize = deletions - remainingDel - notFound;
		if (deletesForCurrentPiece != 0){
			HposDe = LposDe + deletesForCurrentPiece;
			crackerSlice = BATslice(b, LposCr, HposCr+1);
			deletesSlice = BATslice(u, LposDe, HposDe);

			crackerPieceO = BATmirror(BATmark(crackerSlice,(oid)0));

			deletesPieceO = VIEWhead(deletesSlice);
			positionsO = BATjoin(crackerPieceO,deletesPieceO,BATcount(deletesPieceO));

			crackerPieceV = BATmirror(BATmark(BATmirror(crackerSlice),(oid)0));
			deletesPieceV = VIEWhead(BATmirror(deletesSlice));
			positionsV = BATjoin(crackerPieceV,deletesPieceV,BATcount(deletesPieceV));

			positions = BATkintersect(positionsO, positionsV);
			if (BATcount(positions) > 0){
				positions->batRestricted = BAT_WRITE;
				BATorder(positions);

				/* fill in the hols */
				pp = BUNsize(positions);
				pos = BUNhloc(positions, BUNfirst(positions));
				posLast = BUNhloc(positions, BUNlast(positions)-pp);
				crk = crkFirst + HposCr*xx;
				buns =  HposCr - LposCr;
				while(pos<=posLast){
					if (*(oid*)posLast != (size_t)buns){
						memcpy(crkFirst+(LposCr+(*(oid*)pos))*xx, crk, xx);
						pos+=pp;
					} else
						posLast-=pp;
					crk-=xx; buns--;
				}

				deletedFromCurrentPiece = BATcount(positions);
				if ( (notFoundHere = deletesForCurrentPiece - deletedFromCurrentPiece) > 0)
					notFound += notFoundHere;
				BBPunfix(positions->batCacheid);
			}

			BBPunfix(crackerSlice->batCacheid); crackerSlice = NULL;
			BBPunfix(crackerPieceO->batCacheid); crackerPieceO = NULL;
			BBPunfix(deletesSlice->batCacheid); deletesSlice = NULL;
			BBPunfix(deletesPieceO->batCacheid); deletesPieceO = NULL;
			BBPunfix(positionsO->batCacheid); positionsO = NULL;
			BBPunfix(positionsV->batCacheid); positionsV = NULL; 
			BBPunfix(crackerPieceV->batCacheid); crackerPieceV = NULL;
			BBPunfix(deletesPieceV->batCacheid); deletesPieceV = NULL;
			positions = NULL;
		}

		/* this will work both if we delete or no (then deletesForCurrentPiece=0) */
		buns = HposCr - LposCr + 1 - deletedFromCurrentPiece;
		/* no need to to shift if nothing has been deleted from previous pieces */
		if (holSize > 0 && buns > 0){
			if (holSize >= buns)
				memcpy(crkFirst+(LposCr-holSize)*xx, crkFirst+LposCr*xx, buns*xx);
			else
				memcpy(crkFirst+(LposCr-holSize)*xx, crkFirst+(LposCr+(buns-holSize))*xx, holSize*xx);
		}
		if (buns == 0 && lowNode != NULL) lowNode->deleted = TRUE; /* deleted all values in current piece*/
		remainingDel -= deletesForCurrentPiece;
		deletions += holPiece;
		if (hghNode != NULL){
			if (HposDe > startPosition)
				LposDe = HposDe;
			hghNode ->hols = 0;
			lowNode = hghNode;
			prevPos = *(lng*)hghPos+1;
			*(lng*)hghPos = *(lng*)hghPos - holSize - deletedFromCurrentPiece - holPiece;

		} else
			break;
	}

	crkLast = BUNlast(b) - (deletions-remainingDel)*xx + notFound*xx;
	b->batBuns->free = crkLast - b->batBuns->base;
        BATsetcount(b, b->batBuns->free/xx);
@

@}
