

/* BEGIN -----------------------------------AVL Tree--------------------------------------------------------------------------*/

@c
static int maxAVLIndices = 0;

typedef struct {
	int		bid;
	struct Node 	*Tree;	
} AVLIndexNode;

static AVLIndexNode *AVLIndex;

int
existsAVLIndex(int bid){
        int i;

        for (i = 0; i < maxAVLIndices; i++)
                if (AVLIndex[i].bid == bid)
                        return i;
        return -1;
}

@= NewAVLIndex
int
newAVLIndex_@1(int bid){
        int i, freemap = -1, units = 1024;

        for (i = 0; i < maxAVLIndices; i++)
                if (AVLIndex[i].bid == -1)
                        freemap = i;

        if (freemap != -1) {
                AVLIndex[freemap].bid = bid;
                return freemap;
        }

        if (i == maxAVLIndices) {
                AVLIndexNode *x;

                if (maxAVLIndices > 0)
                        units = (int) (1.2 * maxAVLIndices);
                x = (AVLIndexNode *) GDKmalloc(sizeof(AVLIndexNode) * units);
                memset(x, 0, sizeof(AVLIndexNode) * units);
                if (AVLIndex) {
                        fprintf(stderr, "reallocate index \n");
                        memcpy(x, AVLIndex, sizeof(AVLIndexNode) * i);
                        GDKfree(AVLIndex);
                }
                AVLIndex = x;
                maxAVLIndices = units;
        }

        AVLIndex[i].bid = bid;
        AVLIndex[i].Tree = NULL;
        return i;
}
@

@c
@:NewAVLIndex(chr)@
@:NewAVLIndex(sht)@
@:NewAVLIndex(int)@
@:NewAVLIndex(lng)@
@:NewAVLIndex(flt)@
@:NewAVLIndex(dbl)@
@:NewAVLIndex(date)@

@= AVLIndexOperations
struct Node *
InsertAVLIndex_@1(int m, int indexPosition, @1 value,  struct Node * current, BAT * b, BUN base, int xx){	
	BUN cur, curValue, Lchild, LchildValue, Rchild, RchildValue;
	int lh, rh;
	struct Node *temp;

	if (current == NULL){
        	current = (struct Node *)GDKmalloc(sizeof(struct Node));
                current->position = indexPosition;
                current->inclusive = TRUE;
		current->height = 0;
                current->left = NULL;
		current->right = NULL;
		current->head = FALSE;
		current->deleted = FALSE;
		current->previous = NULL;
		current->isPreviousSmaller = FALSE;
		current->hols = 0;
		goto end;
        }

	cur = base + ((current->position) * xx);
        curValue = BUNtloc(b, cur);

        if ( @2_LT(&value,curValue,@3@1) || @2_EQ(&value,curValue,@3@1) ){
		if ( (temp = InsertAVLIndex_@1(m, indexPosition, value,  current->left, b, base, xx)) == NULL )
                	return NULL;

		current->left = temp;
		temp->previous = current;
		temp->isPreviousSmaller = FALSE;

                if ( Height(current->left) - Height(current->right) == 2 ){
		        Lchild = base + ((current->left->position) * xx);
        		LchildValue = BUNtloc(b, Lchild);

                    	if ( @2_LT(&value,LchildValue,@3@1) || @2_EQ(&value,LchildValue,@3@1) )
                        	current = SingleRotateLeft(m, current);
                    	else
                        	current = DoubleRotateLeft(m, current);
		}
        } else {
		if ( (temp = InsertAVLIndex_@1(m, indexPosition, value, current->right, b, base, xx)) == NULL )
			return NULL;

                current->right = temp;
		temp->previous = current;
		temp->isPreviousSmaller = TRUE;


                if ( Height(current->right) - Height(current->left) == 2 ){
			Rchild = base + ((current->right->position) * xx);
                        RchildValue = BUNtloc(b, Rchild);

                        if ( @2_GT(&value,RchildValue,@3@1) )
                        	current = SingleRotateRight(m, current);
                    	else
                        	current = DoubleRotateRight(m, current);
		}
        }

	end:;
	lh = Height(current->left);
	rh = Height(current->right);
		
        current->height = (lh > rh? lh : rh) + 1;
        return current;
}

void
addAVLIndex_@1(int m,  lng position, BAT * b){
        BUN base;
        int xx = BUNsize(b);

        if (position == 0){
                AVLIndex[m].Tree = (struct Node *)GDKmalloc(sizeof(struct Node));
                AVLIndex[m].Tree->position = position;
                AVLIndex[m].Tree->inclusive = TRUE;
                AVLIndex[m].Tree->height = 0;
                AVLIndex[m].Tree->left = NULL;
                AVLIndex[m].Tree->right = NULL;
                AVLIndex[m].Tree->head = TRUE;
                AVLIndex[m].Tree->deleted = FALSE;
                AVLIndex[m].Tree->previous = NULL;

                return;
        }

        base = BUNhloc(b, BUNfirst(b));
        InsertAVLIndex_@1(m, position, *(@1*)BUNtloc(b,base+position*xx),  AVLIndex[m].Tree, b, base, xx);
}

crackers_export str CRKmakeAVLIndex_@1(int *k, int *bid);
str
CRKmakeAVLIndex_@1(int *k, int *bid){
	BUN last, cur;
	int indexPos;
	int xx;
	lng curPos;
	BAT *b;

	(void) k;
        if ((b = BATdescriptor(*bid)) == NULL)
		throw(MAL, "crackers.make AVL index", "Cannot access descriptor");

	indexPos = newAVLIndex_@1(*bid);
	cur = BUNfirst(b);
	last = BUNlast(b);
	xx = BUNsize(b);
	curPos = 0;
	while (cur < last){
		addAVLIndex_@1(indexPos,curPos,b);
		cur+=xx;
		curPos++;
	}
	
	BBPunfix(b->batCacheid);
	return MAL_SUCCEED;
}

crackers_export str CRKInsertAVLIndex_@1(int *k, int *bid, int *uid);
str
CRKInsertAVLIndex_@1(int *k, int *bid, int *uid){
	BUN last, cur;
	int indexPos;
	int xx;
	lng curPos;
	BAT *b, *u;

	(void) k;
	indexPos = existsAVLIndex(*bid);
	if (indexPos == -1)	
		throw(MAL, "crackers.insert AVL index", "No AVL index present for this BAT");

        if ((b = BATdescriptor(*bid)) == NULL)
		throw(MAL, "crackers.insert AVL index", "Cannot access descriptor");

        if ((u = BATdescriptor(*uid)) == NULL)
		throw(MAL, "crackers.insert AVL index", "Cannot access update descriptor");

	cur = BUNfirst(u);
	last = BUNlast(u);
	xx = BUNsize(b);
	curPos = BATcount(b)-BATcount(u);
	while (cur < last){
		addAVLIndex_@1(indexPos,curPos,b);
		cur+=xx;
		curPos++;
	}
	
	BBPunfix(b->batCacheid);
	BBPunfix(u->batCacheid);
	return MAL_SUCCEED;
}

lng 
findQualifyingValuesAVLIndex_@1(@1 *low, @1 *hgh, bit *inclusiveLow, bit *inclusiveHgh, lng resSize, BAT *b, BUN first, int xx, struct Node * cur, BUN resh, BUN rest, @1 prevL){
	BUN rh = resh, rt = rest;
	lng size = resSize;
	
	@1 value = *(@1*)BUNtloc(b,first+cur->position*xx);
	if (cur->deleted == FALSE){
		if ( (@2_GT(&value,low,@3@1) && @2_LT(&value,hgh,@3@1)) ||
		     (@2_EQ(&value,low,@3@1) && *inclusiveLow == TRUE) ||	
		     (@2_EQ(&value,hgh,@3@1) && *inclusiveHgh == TRUE) ){
			*(oid*)rh = (oid)cur->position;
       	         	*(@1 *)rt = *(@1*)BUNtloc(b,first+cur->position*xx);
	       	         rh+=xx; rt+=xx;
        	        size++;	
		}
	}

	if (cur->left != NULL &&  @2_GT(&value,low,@3@1) && @2_LT(&prevL,hgh,@3@1) )
		size = findQualifyingValuesAVLIndex_@1(low, hgh, inclusiveLow, inclusiveHgh, size, b, first, xx, cur->left, rh, rt, prevL);
	if (cur->right != NULL && (@2_LT(&value,hgh,@3@1) || (@2_EQ(&value,hgh,@3@1) && *inclusiveHgh == TRUE)))
		size = findQualifyingValuesAVLIndex_@1(low, hgh, inclusiveLow, inclusiveHgh, size, b, first, xx, cur->right, rh, rt, value);

	return size;
}

crackers_export str CRKAVLIndexSelectBounds_@1(int *vid, int *bid, @1 *low, @1 *hgh, bit *inclusiveLow, bit *inclusiveHgh);
str
CRKAVLIndexSelectBounds_@1(int *vid, int *bid, @1 *low, @1 *hgh, bit *inclusiveLow, bit *inclusiveHgh){
	BAT *b, *result;
	int indexPos;
	struct Node *cur;
	int xx;
	lng  resSize;
	BUN first, resLast, resh, rest;

	indexPos = existsAVLIndex(*bid);
        if (indexPos == -1)
                throw(MAL, "crackers.insert AVL index", "No AVL index present for this BAT");
	
        if ((b = BATdescriptor(*bid)) == NULL)
		throw(MAL, "crackers.insert AVL index", "Cannot access descriptor");

	result = BATnew(TYPE_oid, TYPE_@1, (*(@1*)hgh-*(@1*)low)*2);

	/* find the node that we should start searching from */
	cur = AVLIndex[indexPos].Tree;
	first = BUNfirst(b);
	xx = BUNsize(b);

	while( @2_LT(BUNtloc(b,first+cur->position*xx),low,@3@1) && cur != NULL )		
		cur = cur->right;

	resSize = 0;
	/*if NULL then result is empty */
	if (cur == NULL){
		resLast = BUNfirst(result);
		result->batBuns->free =  resLast - result->batBuns->base;
                BATsetcount(result, 0);
		BBPkeepref(result->batCacheid);
		*vid = result->batCacheid;
		BBPunfix(b->batCacheid);

		return MAL_SUCCEED;
	}

	resh = BUNhloc(result, BUNfirst(result));
	rest = BUNtloc(result, BUNfirst(result));
	if (@2_EQ(low,BUNtloc(b,first+cur->position*xx),@3@1) && *inclusiveLow == TRUE){
		while (@2_EQ(low,BUNtloc(b,first+cur->position*xx),@3@1) && cur != NULL){
			if (cur->deleted == FALSE){
				*(oid*)resh = (oid)cur->position;
				*(@1 *)rest = *(@1 *)BUNtloc(b,first+cur->position*xx);
				resh+=xx; rest+=xx;
				resSize++;
			}
			cur = cur->right;
		}
	} else
	if (@2_EQ(low,BUNtloc(b,first+cur->position*xx),@3@1) && *inclusiveLow == FALSE){
		while(@2_EQ(low,BUNtloc(b,first+cur->position*xx),@3@1) && cur != NULL)
			cur = cur->right;
	} 

	if (cur != NULL)       
		resSize = findQualifyingValuesAVLIndex_@1(low, hgh, inclusiveLow, inclusiveHgh, resSize, b, first, xx, cur, resh, rest, *(@1*)BUNtloc(b,first+cur->position));


	resLast = BUNfirst(result) + xx*resSize;
        result->batBuns->free =  resLast - result->batBuns->base;
        BATsetcount(result, resSize);
        BBPkeepref(result->batCacheid);
        *vid = result->batCacheid;
        BBPunfix(b->batCacheid);


	return MAL_SUCCEED;
}

/* Locate and mark as deleted a node in the AVL tree, starting from a given node */
struct Node *
LocateDelete_@1(struct Node *cur, oid id, @1 *value, BAT *b, BUN first, int xx){
	struct Node * current = cur;
	if ( @2_GT(BUNtloc(b, first + current->position*xx),value,@3@1) )
		return current->right != NULL ? LocateDelete_@1(current->right, id, value, b, first, xx): NULL;	
	else
	if ( @2_LT(BUNtloc(b, first + current->position*xx),value,@3@1) )
		return current->left != NULL ? LocateDelete_@1(current->left, id, value, b, first, xx): NULL;	
	else
	if ( @2_EQ(BUNtloc(b, first + current->position*xx),value,@3@1) ){
		if ( (oid)current->position ==  id ){
			current->deleted = TRUE;
			return current;
		}
		else {
			while(1){
				if (current->right != NULL)
					current= current->right;
				if ( @2_EQ(BUNtloc(b, first + current->position*xx),value,@3@1) ){
			                if ( (oid)current->position ==  id ){
						current->deleted = TRUE;
               		 		        return current;
					} else
						continue;
				} else {
					return current;
				}
			}
		}
	}

	return NULL;
}

crackers_export str CRKdeleteFromAVL_@1(int *k, int *bid, int *uid);
/* delete from the AVL tree a collection of values */
str
CRKdeleteFromAVL_@1(int *k, int *bid, int *uid){
	BAT *b, *u;
	lng indexPos;
	BUN delt, delh, delLast, first;
	int xx;
	
	(void)k;
	
	indexPos = existsAVLIndex(*bid);
        if (indexPos == -1)
                throw(MAL, "crackers.delete from AVL index", "No AVL index present for this BAT");

        if ((b = BATdescriptor(*bid)) == NULL)
                throw(MAL, "crackers.delete from AVL index", "Cannot access descriptor");


	if ((u = BATdescriptor(*uid)) == NULL)
                throw(MAL, "crackers.delete from AVL index", "Cannot access deletions BAT");

        if (BATcount(u) == 0){
                BBPunfix(u->batCacheid);
                return MAL_SUCCEED; /* no qualifying values in the insertions */
        }

        /* if necessary, sort in place the insertions bat */
        if (u->tsorted == FALSE){
                u->batRestricted = BAT_WRITE;
                BATmirror(BATorder(BATmirror(u)));
        }

	first = BUNfirst(b);
	xx = BUNsize(b);
	delt = BUNtloc(u, BUNfirst(u));
	delh = BUNhloc(u, BUNfirst(u));
	delLast = BUNtloc(u, BUNlast(u));
	while (delt < delLast){
		LocateDelete_@1(AVLIndex[indexPos].Tree, *(oid*)delh, (@1*)delt, b, first, xx);
		delt+=xx; delh+=xx;
	}
	
	BATmode(u, TRANSIENT);
	BBPunfix(b->batCacheid);
	BBPunfix(u->batCacheid);
	
	return MAL_SUCCEED;
}
@

@c
@:AVLIndexOperations(chr,simple,)@
@:AVLIndexOperations(sht,simple,)@
@:AVLIndexOperations(int,simple,)@
@:AVLIndexOperations(lng,simple,)@
@:AVLIndexOperations(flt,simple,)@
@:AVLIndexOperations(dbl,simple,)@
@:AVLIndexOperations(date,atom,TYPE_)@

/* END ----------------------------- Comparison with AVL-tree index---------------------------------------------------------------- */
