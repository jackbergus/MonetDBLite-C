' The contents of this file are subject to the MonetDB Public License
@' Version 1.1 (the "License"); you may not use this file except in
@' compliance with the License. You may obtain a copy of the License at
@' http://monetdb.cwi.nl/Legal/MonetDBLicense-1.1.html
@'
@' Software distributed under the License is distributed on an "AS IS"
@' basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
@' License for the specific language governing rights and limitations
@' under the License.
@'
@' The Original Code is the MonetDB Database System.
@'
@' The Initial Developer of the Original Code is CWI.
@' Portions created by CWI are Copyright (C) 1997-2007 CWI.
@' All Rights Reserved.

@f crackers_joins
@a Martin Kersten, Stratos Idreos, Stefan Manegold
@d March 2006 - July 2007
@* Cracker Joins 


@+ Interface


@- Type expansion

@= TypeSwitch_1
@:@1(int,simple,,int)@
@

@- Header file

@h
#ifndef _CRACKERS_JOINS_H_
#define _CRACKERS_JOINS_H_
/* Exported signatures */
@:TypeSwitch_1(JoinFunctions_decl1)@
crackers_export str CRKbatCount(lng *count, int *bid);
crackers_export str CRKmaterializeH(int *res, int *bid);

/* #define DEBUG_CRACKERS_JOIN 		to enable debug trace */
/* #define TIMER_CRACKERS_JOIN 		to enable timing pieces */
#endif /* _CRACKERS_JOINS_H */
@

@- Exported signatures

@= JoinFunctions_decl1
crackers_export str CRKsimpleJoin_@1(int *res, int *bidL1, int *bidL2, int *bidR1, int *bidR2);
crackers_export str CRKcrackJoin_@1(int *res, int *bidL1, int *bidL2, int *bidR1, int *bidR2);
crackers_export str CRKcrackHashJoin_@1(int *res, int *bidL1, int *bidL2, int *bidR1, int *bidR2);
crackers_export str CRKcacheConsciousCrackHashJoin_@1(int *res, int *bidL1, int *bidL2, int *bidR1, int *bidR2);
crackers_export str CRKFullAlignment_@1(int *res, int *bidL, int *bidR1, int *bidR2);
crackers_export str CRKAlreadyAlignedJoin_@1(int *res, int *bidL, int *bidR1, int *bidR2);
crackers_export str CRKAlignJoin_@1(int *res, int *bidL, int *bidR1, int *bidR2);
crackers_export str CRKOnePassJoin_@1(int *res, int *bidL, int *bidR1, int *bidR2);
crackers_export str CRKbandJoin_@1(int *resid, int *bidL, int *bidR, @1 *c1, @1 *c2, bit *inclusiveLow, bit *inclusiveHgh);
crackers_export str CRKsortBandJoin_@1(int *resid, int *bidL, int *bidR, @1 *c1, @1 *c2, bit *inclusiveLow, bit *inclusiveHgh);
@


@{
@+ Implementation


@- C file

@c
#include "mal_config.h"
#include "crackers.h"

/* Local support functions and macros */

@= hashjoin
	{
                hash_t yy;

                BATloop(l, p, q) {
                        v = BUN@3(li, p);
                        if (@1_EQ(v, nil, @2)) {
                                continue; /* skip nil */
                        }
                        HASHloop_@2(ri, r->H->hash, yy, v) {
                                bunfastins(bn, BUNhead(li, p), BUNtail(ri, yy));
                        }
                }
                /* set sorted flags by hand, because we used BUNfastins() */
                bn->hsorted = BAThordered(l);
                bn->tsorted = FALSE;
                break;
	}

@c

void
CRKjoin(BAT *bn, BAT *l, BAT *r) {
	ptr v, nil = ATOMnilptr(r->htype);
	BUN p, q;
	int any;
	BATiter li = bat_iterator(l);
        BATiter ri = bat_iterator(r);

	BATmmap_pin(r);
	if (BATprepareHash(r))
		return;
	switch (any = ATOMstorage(l->ttype)) {
#ifndef NOEXPAND_CHR
	case TYPE_chr:
		@:hashjoin(simple,chr,tloc)@
#endif
#ifndef NOEXPAND_BTE
	case TYPE_bte:
		@:hashjoin(simple,bte,tloc)@
#endif
#ifndef NOEXPAND_SHT
	case TYPE_sht:
		@:hashjoin(simple,sht,tloc)@
#endif
#if !defined(NOEXPAND_INT) || !defined(NOEXPAND_FLT)
	case TYPE_int:
	case TYPE_flt:
		@:hashjoin(simple,int,tloc)@
#endif
#if !defined(NOEXPAND_DBL) || !defined(NOEXPAND_LNG)
	case TYPE_dbl:
	case TYPE_lng:
		@:hashjoin(simple,lng,tloc)@
#endif
	default:
		@:hashjoin(atom,any,tail)@
	}

      bunins_failed: /* blindly assume bunins does NOT fail*/
	BATmmap_unpin(r);
	return;
}

/* Exported functions */
@:TypeSwitch_1(JoinFunctionns_impl_1)@

str CRKbatCount(lng *count, int *bid){
	BAT *b=BATdescriptor(*bid);
	*count = BATcount(b);
	BBPunfix(b->batCacheid);	
	return MAL_SUCCEED;
}

str CRKmaterializeH(int *res, int *bid){
	BAT *b=BATdescriptor(*bid);
	b=BATmaterializeh(b);
	BBPunfix(b->batCacheid);	
	(void)res;
	return MAL_SUCCEED;
}
@


@- Exported functions

@= JoinTwoPieces
	viewHeadLeft = VIEWhead_(mapLeft,  BAT_READ);
	viewHeadRight = VIEWhead_(mapRight,  BAT_READ);

	viewLeft  = BATslice(viewHeadLeft, prevPosLeft+1,  curPosLeft +1);
        BBPunfix(viewHeadLeft->batCacheid);

        viewRight = BATslice(viewHeadRight, prevPosRight+1, curPosRight+1);
        BBPunfix(viewHeadRight->batCacheid);

	markedViewLeft  = (BAT*)BATmark(viewLeft,prevPosLeft+1);
        BBPunfix(viewLeft->batCacheid);

        markedViewRight = (BAT*)BATmark(viewRight,prevPosRight+1);
        BBPunfix(viewRight->batCacheid);

	TJ1=GDKusec();
	if (curPosLeft - prevPosLeft > 0 && curPosRight - prevPosRight > 0) {
		if ( curPosLeft - prevPosLeft < curPosRight - prevPosRight ){ 
			CRKjoin(BATmirror(res), BATmirror(markedViewRight), markedViewLeft);
		}
		else{ 
			CRKjoin(res, BATmirror(markedViewLeft), markedViewRight);
		}
	}
	TJ2=GDKusec();
	TJtotal += TJ2 - TJ1;

	BBPunfix(markedViewRight->batCacheid);
	BBPunfix(markedViewLeft->batCacheid);
@

@= dumpIndex
#ifdef DEBUG_CRACKERS_JOIN
	printf("\n @1 \n");
	printAVLTree(CrackerIndex[mapLpos].Tree, indexLeft, baseLeft, bunSizeLeft);
	printf("\n Index Right \n");
	printAVLTree(CrackerIndex[mapRpos].Tree, indexRight, baseRight, bunSizeRight);
#endif

@= JoinTwoSuperPiecesReuseHashTables
	@:dumpIndex(Index Left)@
	/* Exploit existing views if possible */
	if (prevNodeLeft != NULL){
		if (prevNodeLeft->slice != -1){
			temp = prevNodeLeft;
			existsHashTableLeft = TRUE;
			while (temp->indexPosition != curPosLeft){
				if (temp->slice != prevNodeLeft->slice)
					existsHashTableLeft = FALSE;
				if (temp->nextValue==NULL)
					break;
				temp=temp->nextValue;
			}
		}
	}
	if (existsHashTableLeft == FALSE){
		viewHeadLeft = VIEWhead_(mapLeft,  BAT_READ);
		viewLeft  = BATslice(viewHeadLeft, prevPosLeft+1,  curPosLeft +1);
	        BBPunfix(viewHeadLeft->batCacheid);
		markedViewLeft  = (BAT*)BATmark(viewLeft,prevPosLeft+1);
	        BBPunfix(viewLeft->batCacheid);
	}
	else {
		if ((markedViewLeft = BATdescriptor(prevNodeLeft->slice)) == NULL)
		        	throw(MAL, "crackers.crackHashJoin", "Cannot access slice");
	}

	if (prevNodeRight != NULL){
                if (prevNodeRight->slice != -1){
			temp = prevNodeRight;
			existsHashTableRight = TRUE;
			while (temp->indexPosition != curPosRight){
				if (temp->slice != prevNodeRight->slice)
					existsHashTableRight = FALSE;
				if (temp->nextValue==NULL)
					break;
				temp=temp->nextValue;
			}
		}
	}
	if (existsHashTableRight == FALSE){
		viewHeadRight = VIEWhead_(mapRight,  BAT_READ);
	        viewRight = BATslice(viewHeadRight, prevPosRight+1, curPosRight+1);
	        BBPunfix(viewHeadRight->batCacheid);
        	markedViewRight = (BAT*)BATmark(viewRight,prevPosRight+1);
	        BBPunfix(viewRight->batCacheid);
	}else{
		if ((markedViewRight = BATdescriptor(prevNodeRight->slice)) == NULL)
			throw(MAL, "crackers.crackHashJoin", "Cannot access slice");
	}
#ifdef DEBUG_CRACKERS_JOIN
	printf("\n Left \n");
	BATprint(markedViewLeft);
	printf("\n Right \n");
	BATprint(markedViewRight);
#endif
	TJ1=GDKusec();
	if (curPosLeft - prevPosLeft > 0 && curPosRight - prevPosRight > 0) {
		if (existsHashTableLeft == FALSE && existsHashTableRight == TRUE){
			CRKjoin(res, BATmirror(markedViewLeft), markedViewRight);
		}else 
		if (existsHashTableLeft == TRUE && existsHashTableRight == FALSE){
			CRKjoin(BATmirror(res), BATmirror(markedViewRight), markedViewLeft);
		}else{
			if  (curPosLeft - prevPosLeft > curPosRight - prevPosRight){ 
				CRKjoin(BATmirror(res), BATmirror(markedViewRight), markedViewLeft);
				if (prevNodeLeft != NULL && existsHashTableLeft == FALSE){
					temp = prevNodeLeft;
					while (temp->indexPosition != curPosLeft){
						temp->slice = markedViewLeft->batCacheid;
						if (temp->nextValue==NULL)
							break;
						temp=temp->nextValue;
					}
					BBPincref(markedViewLeft->batCacheid,TRUE);
				}				
			}else{ 
				CRKjoin(res, BATmirror(markedViewLeft), markedViewRight);
				if (prevNodeRight != NULL && existsHashTableRight == FALSE){
					temp = prevNodeRight;
					while (temp->indexPosition != curPosRight){
						temp->slice = markedViewRight->batCacheid;
						if (temp->nextValue==NULL)
							break;
						temp=temp->nextValue;
					}
					BBPincref(markedViewRight->batCacheid,TRUE);
				}
				
			}
		}
		BBPunfix(markedViewRight->batCacheid);
		BBPunfix(markedViewLeft->batCacheid);
	}
	TJ2=GDKusec();
	TJtotal += TJ2 - TJ1;

#ifdef DEBUG_CRACKERS_JOIN
	printf("\n Res \n");
	BATprint(res);
	@:dumpIndex(Index Left)@
#endif
@
@= JoinTwoPiecesReuseHashTables
	@:dumpIndex(Index Left)@
	/* Exploit existing views if possible */
	if (prevNodeLeft != NULL){
		if (prevNodeLeft->slice != -1){
			if ((markedViewLeft = BATdescriptor(prevNodeLeft->slice)) == NULL)
		        	throw(MAL, "crackers.crackHashJoin", "Cannot access slice");
			else
				existsHashTableLeft = TRUE;
		}
	}
	if (existsHashTableLeft == FALSE){
		viewHeadLeft = VIEWhead_(mapLeft,  BAT_READ);
		viewLeft  = BATslice(viewHeadLeft, prevPosLeft+1,  curPosLeft +1);
	        BBPunfix(viewHeadLeft->batCacheid);
		markedViewLeft  = (BAT*)BATmark(viewLeft,prevPosLeft+1);
	        BBPunfix(viewLeft->batCacheid);
	}
#ifdef TIMER_CRACKERS_JOIN
	 else
		printf("\n found hash table left \n"); */
#endif

	if (prevNodeRight != NULL){
                if (prevNodeRight->slice != -1){
                        if ((markedViewRight = BATdescriptor(prevNodeRight->slice)) == NULL)
                        	throw(MAL, "crackers.crackHashJoin", "Cannot access slice");
			else
				existsHashTableRight = TRUE;
		}
	}
	if (existsHashTableRight == FALSE){
		viewHeadRight = VIEWhead_(mapRight,  BAT_READ);
	        viewRight = BATslice(viewHeadRight, prevPosRight+1, curPosRight+1);
	        BBPunfix(viewHeadRight->batCacheid);
        	markedViewRight = (BAT*)BATmark(viewRight,prevPosRight+1);
	        BBPunfix(viewRight->batCacheid);
	}
#ifdef TIMER_CRACKERS_JOIN
	else
		printf("\n found hash table right \n");
#endif

#ifdef DEBUG_CRACKERS_JOIN
	printf("\n Left \n");
	BATprint(markedViewLeft);
	printf("\n Right \n");
	BATprint(markedViewRight);
#endif

#ifdef DEBUG_CRACKERS_JOIN
	TJ1=GDKusec();
#endif
	if (curPosLeft - prevPosLeft > 0 && curPosRight - prevPosRight > 0) {
		if (existsHashTableLeft == FALSE && existsHashTableRight == TRUE){
			CRKjoin(res, BATmirror(markedViewLeft), markedViewRight);
		}else 
		if (existsHashTableLeft == TRUE && existsHashTableRight == FALSE){
			CRKjoin(BATmirror(res), BATmirror(markedViewRight), markedViewLeft);
		}else{
			if  (curPosLeft - prevPosLeft > curPosRight - prevPosRight){ 
				CRKjoin(BATmirror(res), BATmirror(markedViewRight), markedViewLeft);
				if (prevNodeLeft != NULL && existsHashTableLeft == FALSE){
					prevNodeLeft->slice = markedViewLeft->batCacheid;
					BBPincref(markedViewLeft->batCacheid,TRUE);
				}				
			}else{ 
				CRKjoin(res, BATmirror(markedViewLeft), markedViewRight);
				if (prevNodeRight != NULL && existsHashTableRight == FALSE){
					prevNodeRight->slice = markedViewRight->batCacheid;
					BBPincref(markedViewRight->batCacheid,TRUE);
				}
				
			}
		}
		BBPunfix(markedViewRight->batCacheid);
		BBPunfix(markedViewLeft->batCacheid);
	}
#ifdef DEBUG_CRACKERS_JOIN
	TJ2=GDKusec();
	TJtotal += TJ2 - TJ1;
#endif
#ifdef DEBUG_CRACKERS_JOIN
	printf("\n Res \n");
	BATprint(res);
	@:dumpIndex(Index Left)@
#endif
@

@= SinglePassJoin
	existsHashTableRight = FALSE;

	if (prevNodeRight != NULL){
                if (prevNodeRight->slice != -1){
			temp = prevNodeRight;
			existsHashTableRight = TRUE;
			while (temp->indexPosition != curPosRight){
				if (temp->slice != prevNodeRight->slice)
					existsHashTableRight = FALSE;
				if (temp->nextValue==NULL)
					break;
				temp=temp->nextValue;
			}
		
		}
	}
	if (existsHashTableRight == FALSE){
		viewHeadRight = VIEWhead_(mapRight,  BAT_READ);
	       	viewRight = BATslice(viewHeadRight, prevPosRight, curPosRight+1);
	       	BBPunfix(viewHeadRight->batCacheid);
		markedViewRight = (BAT*)BATmark(viewRight,prevPosRight);
		BBPunfix(viewRight->batCacheid);


	}else{
		if ((markedViewRight = BATdescriptor(prevNodeRight->slice)) == NULL)
			throw(MAL, "crackers.AlignedJoin", "Cannot access slice");
			
	}

#ifdef DEBUG_CRACKERS_JOIN
	printf("\n Left \n");
	BATprint(viewLeft);
	printf("\n Right \n");
	BATprint(markedViewRight);
#endif

	if (BATcount(markedViewRight) <= BATcount(partitionLeft)){
		CRKjoin(res, partitionLeft, markedViewRight);
		if (existsHashTableRight == FALSE){
			if (prevNodeRight != NULL){
				BBPincref(markedViewRight->batCacheid,TRUE);
			
				temp = prevNodeRight;
				while (temp->indexPosition != curPosRight){
					temp->slice = markedViewRight->batCacheid;
					if (temp->nextValue==NULL)
						break;
					temp=temp->nextValue;
				}
			}
		}
	}else
		CRKjoin(BATmirror(res), BATmirror(markedViewRight), BATmirror(partitionLeft));

	BBPunfix(markedViewRight->batCacheid);
	BBPunfix(partitionLeft->batCacheid);

#ifdef DEBUG_CRACKERS_JOIN
	printf("\n Res \n");
	BATprint(res);
	@:dumpIndex(Index Left)@
#endif
@
@= AlignJoin
	existsHashTableRight = FALSE;
	viewLeft  = BATslice(mapLeft, prevPosLeft,  curPosLeft +1);

	if (prevNodeRight != NULL){
                if (prevNodeRight->slice != -1){
			temp = prevNodeRight;
			existsHashTableRight = TRUE;
			while (temp->indexPosition != curPosRight){
				if (temp->slice != prevNodeRight->slice)
					existsHashTableRight = FALSE;
				if (temp->nextValue==NULL)
					break;
				temp=temp->nextValue;
			}
		
		}
	}
	if (existsHashTableRight == FALSE){
		viewHeadRight = VIEWhead_(mapRight,  BAT_READ);
	       	viewRight = BATslice(viewHeadRight, prevPosRight, curPosRight+1);
	       	BBPunfix(viewHeadRight->batCacheid);
		markedViewRight = (BAT*)BATmark(viewRight,prevPosRight);
		BBPunfix(viewRight->batCacheid);


	}else{
		if ((markedViewRight = BATdescriptor(prevNodeRight->slice)) == NULL)
			throw(MAL, "crackers.AlignedJoin", "Cannot access slice");
			
	}

#ifdef DEBUG_CRACKERS_JOIN
	printf("\n Left \n");
	BATprint(viewLeft);
	printf("\n Right \n");
	BATprint(markedViewRight);
#endif

	if (BATcount(viewLeft)> 0 && BATcount(markedViewRight) > 0){ 
		if (BATcount(markedViewRight) <= BATcount(viewLeft)){
			CRKjoin(res, viewLeft, markedViewRight);
			if (existsHashTableRight == FALSE){
				if (prevNodeRight != NULL){
					BBPincref(markedViewRight->batCacheid,TRUE);
				
					temp = prevNodeRight;
					while (temp->indexPosition != curPosRight){
						temp->slice = markedViewRight->batCacheid;
						if (temp->nextValue==NULL)
							break;
						temp=temp->nextValue;
					}
				}
			}
		}else
			CRKjoin(BATmirror(res), BATmirror(markedViewRight), BATmirror(viewLeft));
	}
	BBPunfix(markedViewRight->batCacheid);
	BBPunfix(viewLeft->batCacheid);

#ifdef DEBUG_CRACKERS_JOIN
	printf("\n Res \n");
	BATprint(res);
	@:dumpIndex(Index Left)@
#endif
@
@= JoinTwoPiecesReuseHashTablesRight
	@:dumpIndex(Index Left)@
	/* Exploit existing views if possible */
	viewLeft  = BATslice(mapLeft, prevPosLeft+1,  curPosLeft +1);

	if (prevNodeRight != NULL){
                if (prevNodeRight->slice != -1){
			temp = prevNodeRight;
			existsHashTableRight = TRUE;
			while (temp->indexPosition != curPosRight){
				if (temp->slice != prevNodeRight->slice)
					existsHashTableRight = FALSE;
				if (temp->nextValue==NULL)
					break;
				temp=temp->nextValue;
			}
		
		}
	}
	if (existsHashTableRight == FALSE){
		viewHeadRight = VIEWhead_(mapRight,  BAT_READ);
	       	viewRight = BATslice(viewHeadRight, prevPosRight+1, curPosRight+1);
	       	BBPunfix(viewHeadRight->batCacheid);
		markedViewRight = (BAT*)BATmark(viewRight,prevPosRight+1);
		BBPunfix(viewRight->batCacheid);


	}else{
		if ((markedViewRight = BATdescriptor(prevNodeRight->slice)) == NULL)
			throw(MAL, "crackers.AlignedJoin", "Cannot access slice");
			
	}

#ifdef DEBUG_CRACKERS_JOIN
	printf("\n Left \n");
	BATprint(viewLeft);
	printf("\n Right \n");
	BATprint(markedViewRight);
#endif
	TJ1=GDKusec();

	if (curPosLeft - prevPosLeft > 0 && curPosRight - prevPosRight > 0){ 
		CRKjoin(res, viewLeft, markedViewRight);
		if (existsHashTableRight == FALSE){
			if (prevNodeRight != NULL){
				BBPincref(markedViewRight->batCacheid,TRUE);
			
				temp = prevNodeRight;
				while (temp->indexPosition != curPosRight){
					temp->slice = markedViewRight->batCacheid;
					if (temp->nextValue==NULL)
						break;
					temp=temp->nextValue;
				}
			}
		}
	}

	BBPunfix(markedViewRight->batCacheid);
	BBPunfix(viewLeft->batCacheid);

	TJ2=GDKusec();
	TJtotal += TJ2 - TJ1;
#ifdef DEBUG_CRACKERS_JOIN
	printf("\n Res \n");
	BATprint(res);
	@:dumpIndex(Index Left)@
#endif
@

@= MoveToNextPiece
#ifdef DEBUG_CRACKERS_JOIN
	printf("Move @2 \n"); 
#endif
	prevPos@2 = curPos@2;
	curNode@2 = findNextPiece(curNode@2);
	if (curNode@2 == NULL){
#ifdef DEBUG_CRACKERS_JOIN
		printf(" Skip the rest of the opposite(@2) pieces because @2 pieces are done \n"); 
#endif
		break;
	}				
	curTuple@2 = base@2 + curNode@2->position;
        curValue@2 =  *(@1 *)Tloc(index@2, curTuple@2);
        curPos@2   =  *(oid*)Hloc(index@2, curTuple@2);
@


@= addPartialResult
	curViewTupleHead = (oid*)Hloc(b,BUNfirst(b)+vl);

#ifdef DEBUG_CRACKERS_JOIN
	printf("\n adding tuples "OIDFMT" to "OIDFMT" \n",vl,vh);
	BATprint(b);
#endif

	for (j=vl;j<vh+1;j++){
		*currentResTupleHead = *currentTupleLeftHead;	
		*currentResTupleTail = *curViewTupleHead;	

		curViewTupleHead ++;
		currentResTupleHead ++;
		currentResTupleTail ++;
	}


	resCount += (vh-vl) + 1;
@

@= sortInsertPartialResult
	*currentResTupleHead = *currentTupleLeftHead;
	*currentResTupleTail = *(oid*)Hloc(BATRight, currentTupleRight);
	
	currentTupleRight   ++;
        currentResTupleHead ++;
        currentResTupleTail ++;
	resCount++;

        if (currentTupleRight == BUNlast(BATRight))
		goto next;
@

@= crackDoubleSidedBound
	if (*inclusiveLow == TRUE && *inclusiveHgh == TRUE)
		CRKcrackUnorderedThree_LE_RE_@1(b,low,hgh, @2, @3, &vl, &vh);
	if (*inclusiveLow == TRUE && *inclusiveHgh == FALSE)
		CRKcrackUnorderedThree_LE_RO_@1(b,low,hgh, @2, @3, &vl, &vh);
	if (*inclusiveLow == FALSE && *inclusiveHgh == TRUE)
		CRKcrackUnorderedThree_LO_RE_@1(b,low,hgh, @2, @3, &vl, &vh);
	if (*inclusiveLow == FALSE && *inclusiveHgh == FALSE)
		CRKcrackUnorderedThree_LO_RO_@1(b,low,hgh, @2, @3, &vl, &vh);
				
	/*if (vl != -1 && vh != -1){*/
		if (vl>0) _vl=vl-1; else _vl=vl;		
		addCrackerIndex_@1(m,&low,*inclusiveLow,_vl,c);
		addCrackerIndex_@1(m,&hgh,HBound,vh,c);
	
@

@= crackSingleSidedBoundLeft
	if (*inclusiveLow == TRUE)
		CRKcrackUnorderedZero_RE_@1(b,low, cl1, ch1,&vl);
	else
		CRKcrackUnorderedZero_LE_@1(b,low, cl1, ch1,&vl);
	if (vl < cl1){
		gapL = -1;
	}
	if (vl > ch1){
		vl--;
		gapL = -1;
	}
	vl++; 
@

@= crackSingleSidedBoundRight
	if (*inclusiveHgh == TRUE)
		CRKcrackUnorderedZero_LE_@1(b,hgh, cl2, ch2,&vh);
	else
		CRKcrackUnorderedZero_RE_@1(b,hgh, cl2, ch2,&vh);

	if (vh < cl2)
		gapH = -1;
	if (vh > ch2){
		gapH = -1;
		vh--;
	}
@


@= JoinFunctionns_impl_1
str CRKsimpleJoin_@1(int *resid, int *bidL1, int *bidL2, int *bidR1, int *bidR2){
	lng TJtotal = 0, TJ1, TJ2;
	int tapeLpos, mapLpos;
	struct Node *curNodeLeft; 
	BAT *indexLeft, *mapLeft, *viewLeft, *markedViewLeft, *viewHeadLeft;
	BUN curTupleLeft, baseLeft;
	oid curPosLeft, prevPosLeft;
	@1  curValueLeft;

	int tapeRpos, mapRpos;
	struct Node *curNodeRight; 
	BAT *indexRight, *mapRight, *viewRight, *markedViewRight, *viewHeadRight;
	BUN curTupleRight, baseRight;
	oid curPosRight, prevPosRight;
        @1  curValueRight;

	BAT *res;

	/* Get the cracker tape for the set of the left 
	   map or create one if it does not exist */
        tapeLpos = existsCrackerIndexSideways(*bidL1, -1);
        if (tapeLpos == -1)
                tapeLpos = CreateTape_@1(*bidL1);

        /* Get the left map */
        mapLpos = existsCrackerIndexSideways(*bidL1, *bidL2);

	/* Align the map based on the position of its cursor in the cracker tape */
        Sync_@1_@1(tapeLpos, mapLpos);

        /* Take the index of the map */
        if ((indexLeft = BATdescriptor(CrackerIndex[mapLpos].cid)) == NULL)
                throw(MAL, "crackers.simpleJoin", "Cannot access crack index");

        /* Take the map */
        if ((mapLeft = BATdescriptor(CrackerIndex[mapLpos].cbid)) == NULL)
                throw(MAL, "crackers.simpleJoin", "Cannot access crack index");

	/* Get the piece that holds the lowest values */
	curNodeLeft = getFirstNode(CrackerIndex[mapLpos].Tree);

	baseLeft      = BUNfirst(indexLeft);

	/* Get the cracker tape for the set of the right map or 
		create one if it does not exist */
        tapeRpos = existsCrackerIndexSideways(*bidR1, -1);
        if (tapeRpos == -1)
                tapeRpos = CreateTape_@1(*bidR1);

        /* Get the right map */
        mapRpos = existsCrackerIndexSideways(*bidR1, *bidR2);

        /* Align the map based on the position of its cursor in the cracker tape */
        Sync_@1_@1(tapeRpos, mapRpos);

        /* Take the index of the map */
        if ((indexRight = BATdescriptor(CrackerIndex[mapRpos].cid)) == NULL)
                throw(MAL, "crackers.simpleJoin", "Cannot access crack index");

        /* Take the map */
        if ((mapRight = BATdescriptor(CrackerIndex[mapRpos].cbid)) == NULL)
                throw(MAL, "crackers.simpleJoin", "Cannot access crack index");

        /* Get the piece that holds the lowest values */
        curNodeRight = getFirstNode(CrackerIndex[mapRpos].Tree);

        baseRight      = BUNfirst(indexRight);

	res = BATnew(TYPE_oid,TYPE_oid,5*BATcount(mapRight));

	prevPosLeft = prevPosRight = -1;

	curTupleLeft = baseLeft + curNodeLeft->position;
        curValueLeft =  *(@1*)Tloc(indexLeft, curTupleLeft);
        curPosLeft   = *(oid*)Hloc(indexLeft, curTupleLeft);

        curTupleRight = baseRight + curNodeRight->position;
        curValueRight =  *(@1*)Tloc(indexRight, curTupleRight);
        curPosRight   = *(oid*)Hloc(indexRight, curTupleRight);

	@:JoinTwoPieces()@
	
	while (1){

		if (curValueLeft < curValueRight || 
		((curValueLeft == curValueRight) && (curNodeLeft->inclusive == FALSE) && (curNodeRight->inclusive == TRUE))){
			@:MoveToNextPiece(@1,Left)@
		}
		else if (curValueRight < curValueLeft ||
                ((curValueLeft == curValueRight) && (curNodeRight->inclusive == FALSE) && (curNodeLeft->inclusive == TRUE))){
			@:MoveToNextPiece(@1,Right)@
		}
		else if ((curValueLeft == curValueRight) && (curNodeLeft->inclusive == curNodeRight->inclusive)){
			@:MoveToNextPiece(@1,Left)@
			@:MoveToNextPiece(@1,Right)@
		}

		@:JoinTwoPieces()@

	}
	
        *resid = res->batCacheid;
        BBPkeepref(*resid);

        BBPunfix(indexLeft->batCacheid);
        BBPunfix(indexRight->batCacheid);
        BBPunfix(mapLeft->batCacheid);
        BBPunfix(mapRight->batCacheid);
	return MAL_SUCCEED;
}	

str CRKcrackJoin_@1(int *resid, int *bidL1, int *bidL2, int *bidR1, int *bidR2){
	lng T1=GDKusec(), TJtotal = 0, TJ1, TJ2, T2, TCtotal = 0, TC1, TC2;
	int tapeLpos, mapLpos;
	struct Node *curNodeLeft; 
	BAT *indexLeft, *mapLeft, *viewLeft, *markedViewLeft, *viewHeadLeft;
	BUN curTupleLeft, baseLeft;
	oid curPosLeft, prevPosLeft;
	@1  curValueLeft;
	bit crackedLeft;

	int tapeRpos, mapRpos;
	struct Node *curNodeRight; 
	BAT *indexRight, *mapRight, *viewRight, *markedViewRight, *viewHeadRight;
	BUN curTupleRight, baseRight;
	oid curPosRight, prevPosRight;
        @1  curValueRight;
	bit crackedRight;

	BAT *res;
	oid newPosition=0;

	lng crackedOperationsLeft = 0 , crackedOperationsRight = 0, joinsDone = 0;

	/* Get the cracker tape for the set of the left map or create one if it does not exist */
        tapeLpos = existsCrackerIndexSideways(*bidL1, -1);
        if (tapeLpos == -1)
                tapeLpos = CreateTape_@1(*bidL1);

        /* Get the left map */
        mapLpos = existsCrackerIndexSideways(*bidL1, *bidL2);

	/* Align the map based on the position of its cursor in the cracker tape */
        Sync_@1_@1(tapeLpos, mapLpos);

        /* Take the index of the map */
        if ((indexLeft = BATdescriptor(CrackerIndex[mapLpos].cid)) == NULL)
                throw(MAL, "crackers.simpleJoin", "Cannot access crack index");

        /* Take the map */
        if ((mapLeft = BATdescriptor(CrackerIndex[mapLpos].cbid)) == NULL)
                throw(MAL, "crackers.simpleJoin", "Cannot access crack index");

	/* Get the piece that holds the lowest values */
	curNodeLeft = getFirstNode(CrackerIndex[mapLpos].Tree);

	baseLeft      = BUNfirst(indexLeft);

	/* Get the cracker tape for the set of the right map or create one if it does not exist */
        tapeRpos = existsCrackerIndexSideways(*bidR1, -1);
        if (tapeRpos == -1)
                tapeRpos = CreateTape_@1(*bidR1);

        /* Get the right map */
        mapRpos = existsCrackerIndexSideways(*bidR1, *bidR2);

        /* Align the map based on the position of its cursor in the cracker tape */
        Sync_@1_@1(tapeRpos, mapRpos);

        /* Take the index of the map */
        if ((indexRight = BATdescriptor(CrackerIndex[mapRpos].cid)) == NULL)
                throw(MAL, "crackers.simpleJoin", "Cannot access crack index");

        /* Take the map */
        if ((mapRight = BATdescriptor(CrackerIndex[mapRpos].cbid)) == NULL)
                throw(MAL, "crackers.simpleJoin", "Cannot access crack index");
#ifdef DEBUG_CRACKERS_JOIN
	printf("maps\n");
	BATprint(mapLeft);
	BATprint(mapRight);
#endif

        /* Get the piece that holds the lowest values */
        curNodeRight = getFirstNode(CrackerIndex[mapRpos].Tree);

        baseRight      = BUNfirst(indexRight);

	res = BATnew(TYPE_oid,TYPE_oid,5*BATcount(mapRight));
	
	prevPosLeft = prevPosRight = -1;

	while (1){

#ifdef DEBUG_CRACKERS_JOIN
	printf(" new loop maps\n");
	BATprint(mapLeft);
	BATprint(mapRight);
#endif
		crackedLeft = crackedRight = FALSE;


		curTupleLeft = baseLeft + curNodeLeft->position;
       		curValueLeft =  *(@1 *)Tloc(indexLeft, curTupleLeft);
        	curPosLeft   =  *(oid*)Hloc(indexLeft, curTupleLeft);

        	curTupleRight = baseRight + curNodeRight->position;
        	curValueRight = *(@1 *)Tloc(indexRight, curTupleRight);
        	curPosRight   = *(oid*)Hloc(indexRight, curTupleRight);

#ifdef DEBUG_CRACKERS_JOIN
		printf(" leftVal %d rightVal %d \n", curValueLeft, curValueRight);
		printf(" prevPosLeft %lld curPosLeft %lld \n", prevPosLeft,curPosLeft);
		printf(" prevPosRight %lld curPosRight %lld \n", prevPosRight,curPosRight);
#endif

		if (curValueLeft < curValueRight || 
		((curValueLeft == curValueRight) && (curNodeLeft->inclusive == FALSE) && (curNodeRight->inclusive == TRUE))){

#ifdef DEBUG_CRACKERS_JOIN
			printf("crack Right \n");
#endif

			crackedOperationsRight++;

			TC1=GDKusec();	
			if (curNodeLeft->inclusive == TRUE)
		                CRKcrackUnorderedZeroSideways_RE_@1_@1(mapRight, curValueLeft, prevPosRight+1, curPosRight, &newPosition);
        		else 
                		CRKcrackUnorderedZeroSideways_LE_@1_@1(mapRight, curValueLeft, prevPosRight+1, curPosRight, &newPosition);
#ifdef DEBUG_CRACKERS_JOIN
			printf("newPos %lld \n",newPosition);
#endif

			TC2=GDKusec();	
			TCtotal+=TC2-TC1;

			if (newPosition != curPosRight){
				addCrackerIndex_@1(mapRpos, &curValueLeft, curNodeLeft->inclusive, newPosition, indexRight);
				AddToTape_@1(mapRpos, @1_nil, curValueLeft, curNodeLeft->inclusive, curNodeLeft->inclusive);
				curPosRight = newPosition;
				crackedRight = TRUE;
			}
		}
		else if (curValueRight < curValueLeft ||
                ((curValueLeft == curValueRight) && (curNodeRight->inclusive == FALSE) && (curNodeLeft->inclusive == TRUE))){

#ifdef DEBUG_CRACKERS_JOIN
			printf("crack Left \n");
#endif

			crackedOperationsLeft++;

			TC1=GDKusec();	
			if (curNodeRight->inclusive == TRUE)
		                CRKcrackUnorderedZeroSideways_RE_@1_@1(mapLeft, curValueRight, prevPosLeft+1, curPosLeft, &newPosition);
        		else 
                		CRKcrackUnorderedZeroSideways_LE_@1_@1(mapLeft, curValueRight, prevPosLeft+1, curPosLeft, &newPosition);

#ifdef DEBUG_CRACKERS_JOIN
			printf("newPos %lld \n",newPosition);
#endif

			TC2=GDKusec();	
			TCtotal+=TC2-TC1;
			if (newPosition != curPosLeft){
				addCrackerIndex_@1(mapLpos, &curValueRight, curNodeRight->inclusive, newPosition, indexLeft);
				AddToTape_@1(mapLpos, @1_nil, curValueRight, curNodeRight->inclusive, curNodeRight->inclusive);
				curPosLeft = newPosition;
				crackedLeft = TRUE;
			}
		}

		@:JoinTwoPieces()@
		joinsDone++;

		prevPosLeft = curPosLeft;
		if (crackedLeft == FALSE)
			curNodeLeft = findNextPiece(curNodeLeft);
				
		prevPosRight = curPosRight;
		if (crackedRight == FALSE)
        		curNodeRight = findNextPiece(curNodeRight);
		
		if (curNodeLeft == NULL || curNodeRight == NULL)
			break;
	}

	while(1){
		crackedLeft = crackedRight = FALSE;

		if (curNodeLeft == NULL)
			curPosLeft  = BATcount(mapLeft)-1;
		else {
			curTupleLeft = baseLeft + curNodeLeft->position;
        	        curValueLeft = *(@1 *)Tloc(indexLeft, curTupleLeft);
	                curPosLeft   = *(oid*)Hloc(indexLeft, curTupleLeft);
		}
		if (curNodeRight == NULL)
			curPosRight  = BATcount(mapRight)-1;
		else {
			curTupleRight = baseRight + curNodeRight->position;
   	             	curValueRight = *(@1 *)Tloc(indexRight, curTupleRight);
        	        curPosRight   = *(oid*)Hloc(indexRight, curTupleRight);	
		}
		
#ifdef DEBUG_CRACKERS_JOIN
		printf(" leftVal %d rightVal %d \n", curValueLeft, curValueRight);
		printf(" prevPosLeft %lld curPosLeft %lld \n", prevPosLeft,curPosLeft);
		printf(" prevPosRight %lld curPosRight %lld \n", prevPosRight,curPosRight);
#endif

		if (curNodeLeft != NULL && curNodeRight == NULL){	
			crackedOperationsRight++;

			TC1=GDKusec();	
			if (curNodeLeft->inclusive == TRUE)
		                CRKcrackUnorderedZeroSideways_RE_@1_@1(mapRight, curValueLeft, prevPosRight+1, curPosRight, &newPosition);
        		else 
                		CRKcrackUnorderedZeroSideways_LE_@1_@1(mapRight, curValueLeft, prevPosRight+1, curPosRight, &newPosition);

#ifdef DEBUG_CRACKERS_JOIN
			printf("newPos %lld \n",newPosition);
#endif

			TC2=GDKusec();	
			TCtotal+=TC2-TC1;
			if (newPosition < curPosRight){
				addCrackerIndex_@1(mapRpos, &curValueLeft, curNodeLeft->inclusive, newPosition, indexRight);
				AddToTape_@1(mapRpos, @1_nil, curValueLeft, curNodeLeft->inclusive, curNodeLeft->inclusive);
				curPosRight = newPosition;
				crackedRight = TRUE;
			}
			else {  /* this means that there is no chance to join with the future pieces of the other side */

#ifdef DEBUG_CRACKERS_JOIN
				printf("skippiing the rest of the pieces left");
#endif

				@:JoinTwoPieces()@
				joinsDone++;
				break;
			}
		}
		else if (curNodeLeft == NULL && curNodeRight != NULL){

			crackedOperationsLeft++;

			TC1=GDKusec();	
			if (curNodeRight->inclusive == TRUE)
		                CRKcrackUnorderedZeroSideways_RE_@1_@1(mapLeft, curValueRight, prevPosLeft+1, curPosLeft, &newPosition);
        		else 
                		CRKcrackUnorderedZeroSideways_LE_@1_@1(mapLeft, curValueRight, prevPosLeft+1, curPosLeft, &newPosition);

#ifdef DEBUG_CRACKERS_JOIN
			printf("newPos %lld \n",newPosition);
#endif

			TC2=GDKusec();	
			TCtotal+=TC2-TC1;
			if (newPosition < curPosLeft){
				addCrackerIndex_@1(mapLpos, &curValueRight, curNodeRight->inclusive, newPosition, indexLeft);
				AddToTape_@1(mapLpos, @1_nil, curValueRight, curNodeRight->inclusive, curNodeRight->inclusive);
				curPosLeft = newPosition;
				crackedLeft = TRUE;
			}
			else {

#ifdef DEBUG_CRACKERS_JOIN
				printf("skipping the rest of the pieces right");
#endif

				@:JoinTwoPieces()@
				joinsDone++;
				break;
			}
		}
		else if (curNodeLeft == NULL && curNodeRight == NULL){

#ifdef DEBUG_CRACKERS_JOIN
			printf(" into the last piece for both maps \n");
#endif

			@:JoinTwoPieces()@
			joinsDone++;
			break;
		}			

		@:JoinTwoPieces()@
		joinsDone++;

		prevPosLeft = curPosLeft;
		if (crackedLeft == FALSE && curNodeLeft != NULL)
			curNodeLeft = findNextPiece(curNodeLeft);
				
		prevPosRight = curPosRight;
		if (crackedRight == FALSE && curNodeRight != NULL)
        		curNodeRight = findNextPiece(curNodeRight);
	}
	
        *resid = res->batCacheid;
        BBPkeepref(*resid);

        BBPunfix(indexLeft->batCacheid);
        BBPunfix(indexRight->batCacheid);
        BBPunfix(mapLeft->batCacheid);
        BBPunfix(mapRight->batCacheid);

	T2=GDKusec();

	printf(" Total  %lld Join %lld Crack %lld Rest  %lld Cracks %lld Left %lld Right %lld Joins %lld \n", 
			T2-T1, TJtotal, TCtotal, ((T2-T1)-TJtotal)-TCtotal, crackedOperationsLeft + crackedOperationsRight, 
			crackedOperationsLeft, crackedOperationsRight, joinsDone);

	return MAL_SUCCEED;
}	

str CRKcacheConsciousCrackHashJoin_@1(int *resid, int *bidL1, int *bidL2, int *bidR1, int *bidR2){

	lng T1=GDKusec(), TJtotal = 0, TJ1, TJ2, T2, TCtotal = 0, TC1, TC2;
	
	oid cacheSize, cacheThreshold;

	int tapeLpos, mapLpos;
	struct Node *curNodeLeft, *prevNodeLeft; 
	BAT *indexLeft, *mapLeft, *viewLeft, *markedViewLeft, *viewHeadLeft;
	BUN baseLeft;
	oid curPosLeft, prevPosLeft, cprevPosLeft;
	@1  curValueLeft;
	bit existsHashTableLeft;

	int tapeRpos, mapRpos;
	struct Node *curNodeRight, *prevNodeRight; 
	BAT *indexRight, *mapRight, *viewRight, *markedViewRight, *viewHeadRight;
	BUN baseRight;
	oid curPosRight, prevPosRight, cprevPosRight;
        @1  curValueRight;
	bit existsHashTableRight;

	BAT *res;
	oid newPosition=0;

	oid sizeLeft, sizeRight;
	oid iterations = 0;

	struct Node *temp;
	
	cacheSize 	  = 524288;
	cacheThreshold    = (cacheSize / 2) / (16+sizeof(@1));

	/* Get the cracker tape for the set of the left map or create one if it does not exist */
        tapeLpos = existsCrackerIndexSideways(*bidL1, -1);
        if (tapeLpos == -1)
                tapeLpos = CreateTape_@1(*bidL1);

        /* Get the left map */
        mapLpos = existsCrackerIndexSideways(*bidL1, *bidL2);

	/* Align the map based on the position of its cursor in the cracker tape */
        Sync_@1_@1(tapeLpos, mapLpos);

        /* Take the index of the map */
        if ((indexLeft = BATdescriptor(CrackerIndex[mapLpos].cid)) == NULL)
                throw(MAL, "crackers.simpleJoin", "Cannot access crack index");

        /* Take the map */
        if ((mapLeft = BATdescriptor(CrackerIndex[mapLpos].cbid)) == NULL)
                throw(MAL, "crackers.simpleJoin", "Cannot access crack index");

	/* Get the piece that holds the lowest values */
	curNodeLeft = getFirstNode(CrackerIndex[mapLpos].Tree);

	baseLeft      = BUNfirst(indexLeft);

	/* Get the cracker tape for the set of the right map or create one if it does not exist */
        tapeRpos = existsCrackerIndexSideways(*bidR1, -1);
        if (tapeRpos == -1)
                tapeRpos = CreateTape_@1(*bidR1);

        /* Get the right map */
        mapRpos = existsCrackerIndexSideways(*bidR1, *bidR2);

        /* Align the map based on the position of its cursor in the cracker tape */
        Sync_@1_@1(tapeRpos, mapRpos);

        /* Take the index of the map */
        if ((indexRight = BATdescriptor(CrackerIndex[mapRpos].cid)) == NULL)
                throw(MAL, "crackers.simpleJoin", "Cannot access crack index");

        /* Take the map */
        if ((mapRight = BATdescriptor(CrackerIndex[mapRpos].cbid)) == NULL)
                throw(MAL, "crackers.simpleJoin", "Cannot access crack index");
	
        /* Get the piece that holds the lowest values */
        curNodeRight = getFirstNode(CrackerIndex[mapRpos].Tree);

        baseRight      = BUNfirst(indexRight);

	res = BATnew(TYPE_oid,TYPE_oid,5*BATcount(mapRight));
	
	prevPosLeft   = prevPosRight   = -1;
	prevNodeLeft  = prevNodeRight  = NULL;

	while (curNodeLeft != NULL && curNodeRight != NULL){
	
		iterations++;

		cprevPosRight = prevPosRight;
		cprevPosLeft  = prevPosLeft;


		existsHashTableLeft = existsHashTableRight = FALSE;

       		curValueLeft = *(@1 *)Tloc(indexLeft, baseLeft + curNodeLeft->position);
        	curPosLeft   = curNodeLeft->indexPosition; 

        	curValueRight = *(@1 *)Tloc(indexRight, baseRight + curNodeRight->position);
        	curPosRight   = curNodeRight->indexPosition;
		
		sizeLeft  = curPosLeft  - prevPosLeft;
		sizeRight = curPosRight - prevPosRight;
		
		if (sizeLeft < cacheThreshold && sizeRight > cacheThreshold) {
				while (curValueLeft > curValueRight ||
                			((curValueLeft == curValueRight) && 
						(curNodeRight->inclusive == FALSE) && (curNodeLeft->inclusive == TRUE))){ 
					if (curNodeRight->nextValue == NULL) goto cont;
					cprevPosRight = curPosRight;
					curNodeRight = curNodeRight->nextValue;
					curValueRight = *(@1 *)Tloc(indexRight, baseRight + curNodeRight->position);
					curPosRight   = curNodeRight->indexPosition;
				}
			while (sizeLeft < cacheThreshold){

				if (curNodeLeft->nextValue == NULL) goto cont;
 				cprevPosLeft = curPosLeft;
				curNodeLeft = curNodeLeft->nextValue;
				curValueLeft = *(@1 *)Tloc(indexLeft, baseLeft + curNodeLeft->position);
				curPosLeft   = curNodeLeft->indexPosition; 
				sizeLeft  = curPosLeft - prevPosLeft;
				while (curValueLeft > curValueRight ||
                			((curValueLeft == curValueRight) && 
						(curNodeRight->inclusive == FALSE) && (curNodeLeft->inclusive == TRUE))){ 
					if (curNodeRight->nextValue == NULL) goto cont;
					cprevPosRight = curPosRight;
					curNodeRight = curNodeRight->nextValue;
					curValueRight = *(@1 *)Tloc(indexRight, baseRight + curNodeRight->position);
					curPosRight   = curNodeRight->indexPosition;
				}
				
			}
		}else if (sizeRight < cacheThreshold){
			while (curValueRight > curValueLeft ||
				((curValueLeft == curValueRight) && 
					(curNodeLeft->inclusive == FALSE) && (curNodeRight->inclusive == TRUE))){ 
				if (curNodeLeft->nextValue == NULL) goto cont;
				cprevPosLeft = curPosLeft;
				curNodeLeft = curNodeLeft->nextValue;
				curValueLeft = *(@1 *)Tloc(indexLeft, baseLeft + curNodeLeft->position);
				curPosLeft   = curNodeLeft->indexPosition; 
			}
			while (sizeRight < cacheThreshold){
				if (curNodeRight->nextValue == NULL) goto cont;
				cprevPosRight = curPosRight;
				curNodeRight = curNodeRight->nextValue;
				curValueRight = *(@1 *)Tloc(indexRight, baseRight + curNodeRight->position);
				curPosRight   = curNodeRight->indexPosition;
				sizeRight  = curPosRight - prevPosRight;
				while (curValueRight > curValueLeft ||
                			((curValueLeft == curValueRight) && 
						(curNodeLeft->inclusive == FALSE) && (curNodeRight->inclusive == TRUE))) { 
					if (curNodeLeft->nextValue == NULL) goto cont;
					cprevPosLeft = curPosLeft;
					curNodeLeft = curNodeLeft->nextValue;
					curValueLeft = *(@1 *)Tloc(indexLeft, baseLeft + curNodeLeft->position);
					curPosLeft   = curNodeLeft->indexPosition; 
				}
			}
		}
		
		cont:;
			TC1=GDKusec();	
		if (curValueLeft < curValueRight || 
		((curValueLeft == curValueRight) && (curNodeLeft->inclusive == FALSE) && (curNodeRight->inclusive == TRUE))){

			if (curNodeLeft->inclusive == TRUE)
		                CRKcrackUnorderedZeroSideways_RE_@1_@1(mapRight, curValueLeft, cprevPosRight+1, curPosRight, &newPosition);
        		else 
                		CRKcrackUnorderedZeroSideways_LE_@1_@1(mapRight, curValueLeft, cprevPosRight+1, curPosRight, &newPosition);

			if (newPosition == cprevPosRight){
				curPosRight = cprevPosRight;
				curNodeRight = findPreviousPieceWalkingBack(curNodeRight);
			}else if (newPosition != curPosRight){
				curNodeRight = addCrackerIndex_@1(mapRpos, &curValueLeft, curNodeLeft->inclusive, newPosition, indexRight);
				AddToTape_@1(mapRpos, @1_nil, curValueLeft, curNodeLeft->inclusive, curNodeLeft->inclusive);
				curPosRight = newPosition;
			}
		}
		else if (curValueRight < curValueLeft ||
                ((curValueLeft == curValueRight) && (curNodeRight->inclusive == FALSE) && (curNodeLeft->inclusive == TRUE))){
			if (curNodeRight->inclusive == TRUE)
		                CRKcrackUnorderedZeroSideways_RE_@1_@1(mapLeft, curValueRight, cprevPosLeft+1, curPosLeft, &newPosition);
        		else 
                		CRKcrackUnorderedZeroSideways_LE_@1_@1(mapLeft, curValueRight, cprevPosLeft+1, curPosLeft, &newPosition);

			if (newPosition == cprevPosLeft){
				curPosLeft = cprevPosLeft;
				curNodeLeft = findPreviousPieceWalkingBack(curNodeLeft);
			}else if (newPosition != curPosLeft){
				curNodeLeft = addCrackerIndex_@1(mapLpos, &curValueRight, curNodeRight->inclusive, newPosition, indexLeft);
				AddToTape_@1(mapLpos, @1_nil, curValueRight, curNodeRight->inclusive, curNodeRight->inclusive);
				curPosLeft = newPosition;
				
			}
		}
			TC2=GDKusec();	
			TCtotal+=TC2-TC1;

		@:JoinTwoSuperPiecesReuseHashTables()@

		prevNodeLeft  = curNodeLeft;
		curNodeLeft = curNodeLeft->nextValue;

		prevNodeRight  = curNodeRight;
		curNodeRight = curNodeRight->nextValue;

		prevPosLeft  = prevNodeLeft->indexPosition;
		prevPosRight = prevNodeRight->indexPosition;
	}

	while(1){
		iterations++;
		existsHashTableLeft = existsHashTableRight = FALSE;
		
		prevPosLeft   = prevNodeLeft->indexPosition;
		prevPosRight  = prevNodeRight->indexPosition;

		if (curNodeLeft == NULL)
			curPosLeft  = BATcount(mapLeft)-1;
		else {
        	        curValueLeft = *(@1 *)Tloc(indexLeft, baseLeft + curNodeLeft->position);
	                curPosLeft   = curNodeLeft->indexPosition;
		}
		if (curNodeRight == NULL)
			curPosRight  = BATcount(mapRight)-1;
		else {
   	             	curValueRight = *(@1 *)Tloc(indexRight, baseRight + curNodeRight->position);
        	        curPosRight   = curNodeRight->indexPosition;
		}
		
		sizeLeft  = curPosLeft  - prevPosLeft;
		sizeRight = curPosRight - prevPosRight;

		if (sizeLeft < cacheThreshold && curNodeLeft != NULL) {
			while (sizeLeft < cacheThreshold){
				if (curNodeLeft->nextValue == NULL)  {
					if ( (BATcount(mapLeft)-1)- prevPosLeft <cacheThreshold){
						curPosLeft  = BATcount(mapLeft)-1;
						curNodeLeft = NULL;
					}
					break;
				}
				curNodeLeft = curNodeLeft->nextValue;
				curPosLeft   = curNodeLeft->indexPosition; 
        	        	curValueLeft = *(@1 *)Tloc(indexLeft, baseLeft + curNodeLeft->position);
				sizeLeft  = curPosLeft - prevPosLeft;
			}
		}else if (sizeRight < cacheThreshold && curNodeRight != NULL){
			while (sizeRight < cacheThreshold){
				if (curNodeRight->nextValue == NULL) {
					if ( (BATcount(mapRight)-1)- prevPosRight <cacheThreshold){
						curPosRight  = BATcount(mapRight)-1;
						curNodeRight = NULL;
					}
					break;
				}
				curNodeRight = curNodeRight->nextValue;
				curPosRight   = curNodeRight->indexPosition;
   	             		curValueRight = *(@1 *)Tloc(indexRight, baseRight + curNodeRight->position);
				sizeRight  = curPosRight - prevPosRight;
			}
		}
		
		if (curNodeLeft != NULL && curNodeRight == NULL){	
			TC1=GDKusec();	
			if (curNodeLeft->inclusive == TRUE)

		                CRKcrackUnorderedZeroSideways_RE_@1_@1(mapRight, curValueLeft, prevPosRight+1, curPosRight, &newPosition);
        		else 
                		CRKcrackUnorderedZeroSideways_LE_@1_@1(mapRight, curValueLeft, prevPosRight+1, curPosRight, &newPosition);

			TC2=GDKusec();	
			TCtotal+=TC2-TC1;
			if (newPosition < curPosRight && newPosition != prevPosRight){
			TC1=GDKusec();	
				curNodeRight = addCrackerIndex_@1(mapRpos, &curValueLeft, curNodeLeft->inclusive, newPosition, indexRight);
				AddToTape_@1(mapRpos, @1_nil, curValueLeft, curNodeLeft->inclusive, curNodeLeft->inclusive);
				curPosRight = newPosition;
			TC2=GDKusec();	
			TCtotal+=TC2-TC1;
			}
			else {  /* this means that there is no chance to join with the future pieces of the other side */

				@:JoinTwoSuperPiecesReuseHashTables()@

				break;
			}
		}
		else if (curNodeLeft == NULL && curNodeRight != NULL){

			TC1=GDKusec();	
			if (curNodeRight->inclusive == TRUE)
		                CRKcrackUnorderedZeroSideways_RE_@1_@1(mapLeft, curValueRight, prevPosLeft+1, curPosLeft, &newPosition);
        		else 
                		CRKcrackUnorderedZeroSideways_LE_@1_@1(mapLeft, curValueRight, prevPosLeft+1, curPosLeft, &newPosition);

			TC2=GDKusec();	
			TCtotal+=TC2-TC1;
			if (newPosition < curPosLeft && newPosition != prevPosLeft){
			TC1=GDKusec();	
				curNodeLeft = addCrackerIndex_@1(mapLpos, &curValueRight, curNodeRight->inclusive, newPosition, indexLeft);
				AddToTape_@1(mapLpos, @1_nil, curValueRight, curNodeRight->inclusive, curNodeRight->inclusive);
				curPosLeft = newPosition;
				
			TC2=GDKusec();	
			TCtotal+=TC2-TC1;
			}
			else {
				@:JoinTwoSuperPiecesReuseHashTables()@
				break;
			}
		}

		@:JoinTwoSuperPiecesReuseHashTables()@
		if (curNodeLeft == NULL && curNodeRight == NULL)
			break;

		prevNodeLeft  = curNodeLeft;
		curNodeLeft = curNodeLeft->nextValue;
	
		prevNodeRight  = curNodeRight;
		curNodeRight = curNodeRight->nextValue;
	}
	
        *resid = res->batCacheid;
        BBPkeepref(*resid);

        BBPunfix(indexLeft->batCacheid);
        BBPunfix(indexRight->batCacheid);
        BBPunfix(mapLeft->batCacheid);
        BBPunfix(mapRight->batCacheid);

	T2=GDKusec();

	printf(" Total  %lld Join %lld Crack %lld Rest  %lld  iterations "OIDFMT" \n", 
			T2-T1, TJtotal, TCtotal, ((T2-T1)-TJtotal)-TCtotal, iterations);
	return MAL_SUCCEED;

}	

str CRKcrackHashJoin_@1(int *resid, int *bidL1, int *bidL2, int *bidR1, int *bidR2){
#ifdef TIMER_CRACKERS_JOIN
	lng T1=GDKusec(), TJtotal = 0, TJ1, TJ2, T2, TCtotal = 0, TC1, TC2;
	lng crackedOperationsLeft = 0 , crackedOperationsRight = 0, joinsDone = 0;
#endif
	int tapeLpos, mapLpos;
	struct Node *curNodeLeft, *prevNodeLeft, *newprevNodeLeft = NULL; 
	BAT *indexLeft, *mapLeft, *viewLeft, *markedViewLeft, *viewHeadLeft;
	BUN curTupleLeft, baseLeft;
	oid curPosLeft, prevPosLeft;
	@1  curValueLeft;
	bit crackedLeft, existsHashTableLeft;

	int tapeRpos, mapRpos;
	struct Node *curNodeRight, *prevNodeRight, *newprevNodeRight = NULL; 
	BAT *indexRight, *mapRight, *viewRight, *markedViewRight, *viewHeadRight;
	BUN curTupleRight, baseRight;
	oid curPosRight, prevPosRight;
        @1  curValueRight;
	bit crackedRight, existsHashTableRight;

	BAT *res;
	oid newPosition=0;


	/* Get the cracker tape for the set of the left map or create one if it does not exist */
        tapeLpos = existsCrackerIndexSideways(*bidL1, -1);
        if (tapeLpos == -1)
                tapeLpos = CreateTape_@1(*bidL1);

        /* Get the left map */
        mapLpos = existsCrackerIndexSideways(*bidL1, *bidL2);

	/* Align the map based on the position of its cursor in the cracker tape */
        Sync_@1_@1(tapeLpos, mapLpos);

        /* Take the index of the map */
        if ((indexLeft = BATdescriptor(CrackerIndex[mapLpos].cid)) == NULL)
                throw(MAL, "crackers.simpleJoin", "Cannot access crack index");

        /* Take the map */
        if ((mapLeft = BATdescriptor(CrackerIndex[mapLpos].cbid)) == NULL)
                throw(MAL, "crackers.simpleJoin", "Cannot access crack index");

	/* Get the piece that holds the lowest values */
	curNodeLeft = getFirstNode(CrackerIndex[mapLpos].Tree);

	baseLeft      = BUNfirst(indexLeft);

	/* Get the cracker tape for the set of the right map or create one if it does not exist */
        tapeRpos = existsCrackerIndexSideways(*bidR1, -1);
        if (tapeRpos == -1)
                tapeRpos = CreateTape_@1(*bidR1);

        /* Get the right map */
        mapRpos = existsCrackerIndexSideways(*bidR1, *bidR2);

        /* Align the map based on the position of its cursor in the cracker tape */
        Sync_@1_@1(tapeRpos, mapRpos);

        /* Take the index of the map */
        if ((indexRight = BATdescriptor(CrackerIndex[mapRpos].cid)) == NULL)
                throw(MAL, "crackers.simpleJoin", "Cannot access crack index");

        /* Take the map */
        if ((mapRight = BATdescriptor(CrackerIndex[mapRpos].cbid)) == NULL)
                throw(MAL, "crackers.simpleJoin", "Cannot access crack index");
	
#ifdef DEBUG_CRACKERS_JOIN
	printf("maps\n");
	BATprint(mapLeft);
	BATprint(mapRight);
#endif
	

        /* Get the piece that holds the lowest values */
        curNodeRight = getFirstNode(CrackerIndex[mapRpos].Tree);

        baseRight      = BUNfirst(indexRight);

	res = BATnew(TYPE_oid,TYPE_oid,5*BATcount(mapRight));
	
	prevPosLeft   = prevPosRight   = -1;
	prevNodeLeft  = prevNodeRight  = NULL;

#ifdef DEBUG_CRACKERS_JOIN
	printf("\n New Join Index Left \n");
	@:dumpIndex(Index Left)@
#endif
	while (curNodeLeft != NULL && curNodeRight != NULL){

#ifdef DEBUG_CRACKERS_JOIN
	printf(" new loop maps\n");
	BATprint(mapLeft);
	BATprint(mapRight);
#endif
		crackedLeft = crackedRight = FALSE;
		existsHashTableLeft = existsHashTableRight = FALSE;


		curTupleLeft = baseLeft + curNodeLeft->position;
       		curValueLeft = *(@1 *)Tloc(indexLeft, curTupleLeft);
        	curPosLeft   = *(oid*)Hloc(indexLeft, curTupleLeft);

        	curTupleRight = baseRight + curNodeRight->position;
        	curValueRight = *(@1 *)Tloc(indexRight, curTupleRight);
        	curPosRight   = *(oid*)Hloc(indexRight, curTupleRight);

#ifdef DEBUG_CRACKERS_JOIN
		printf(" leftVal %d rightVal %d \n", curValueLeft, curValueRight);
		printf(" prevPosLeft %lld curPosLeft %lld \n", prevPosLeft,curPosLeft);
		printf(" prevPosRight %lld curPosRight %lld \n", prevPosRight,curPosRight);
#endif

		if (curValueLeft < curValueRight || 
		((curValueLeft == curValueRight) && (curNodeLeft->inclusive == FALSE) && (curNodeRight->inclusive == TRUE))){

#ifdef DEBUG_CRACKERS_JOIN
			printf("crack Right \n");
#endif

#ifdef TIMER_CRACKERS_JOIN
			crackedOperationsRight++;
			TC1=GDKusec();	
#endif
			if (curNodeLeft->inclusive == TRUE)
		                CRKcrackUnorderedZeroSideways_RE_@1_@1(mapRight, curValueLeft, prevPosRight+1, curPosRight, &newPosition);
        		else 
                		CRKcrackUnorderedZeroSideways_LE_@1_@1(mapRight, curValueLeft, prevPosRight+1, curPosRight, &newPosition);
#ifdef DEBUG_CRACKERS_JOIN
			printf("newPos %lld \n",newPosition);
#endif


			if (newPosition != curPosRight){
				newprevNodeRight = addCrackerIndex_@1(mapRpos, &curValueLeft, curNodeLeft->inclusive, newPosition, indexRight);
				AddToTape_@1(mapRpos, @1_nil, curValueLeft, curNodeLeft->inclusive, curNodeLeft->inclusive);
				curPosRight = newPosition;
				crackedRight = TRUE;
			}

#ifdef TIMER_CRACKERS_JOIN
			TC2=GDKusec();	
			TCtotal+=TC2-TC1;
#endif
		}
		else if (curValueRight < curValueLeft ||
                ((curValueLeft == curValueRight) && (curNodeRight->inclusive == FALSE) && (curNodeLeft->inclusive == TRUE))){

#ifdef DEBUG_CRACKERS_JOIN
			printf("crack Left \n");
#endif

#ifdef TIMER_CRACKERS_JOIN
			crackedOperationsLeft++;

			TC1=GDKusec();	
#endif
			if (curNodeRight->inclusive == TRUE)
		                CRKcrackUnorderedZeroSideways_RE_@1_@1(mapLeft, curValueRight, prevPosLeft+1, curPosLeft, &newPosition);
        		else 
                		CRKcrackUnorderedZeroSideways_LE_@1_@1(mapLeft, curValueRight, prevPosLeft+1, curPosLeft, &newPosition);

#ifdef DEBUG_CRACKERS_JOIN
			printf("newPos %lld \n",newPosition);
#endif

			if (newPosition != curPosLeft){
				newprevNodeLeft = addCrackerIndex_@1(mapLpos, &curValueRight, curNodeRight->inclusive, newPosition, indexLeft);
				AddToTape_@1(mapLpos, @1_nil, curValueRight, curNodeRight->inclusive, curNodeRight->inclusive);
				curPosLeft = newPosition;
				crackedLeft = TRUE;
			}
#ifdef TIMER_CRACKERS_JOIN
			TC2=GDKusec();	
			TCtotal+=TC2-TC1;
#endif
		}

		@:JoinTwoPiecesReuseHashTables()@
#ifdef TIMER_CRACKERS_JOIN
		joinsDone++;
#endif
		prevPosLeft   = curPosLeft;
		if (crackedLeft == FALSE){
			prevNodeLeft  = curNodeLeft;
			curNodeLeft = curNodeLeft->nextValue;/*findNextPiece(curNodeLeft);*/
		} else prevNodeLeft = newprevNodeLeft;

		prevPosRight   = curPosRight;
		if (crackedRight == FALSE){
			prevNodeRight  = curNodeRight;
        		curNodeRight = curNodeRight->nextValue;/*findNextPiece(curNodeRight);*/
		} else prevNodeRight = newprevNodeRight;
	}

	while(1){
		crackedLeft = crackedRight = FALSE;
		existsHashTableLeft = existsHashTableRight = FALSE;

		if (curNodeLeft == NULL)
			curPosLeft  = BATcount(mapLeft)-1;
		else {
			curTupleLeft = baseLeft + curNodeLeft->position;
        	        curValueLeft = *(@1 *)Tloc(indexLeft, curTupleLeft);
	                curPosLeft   = *(oid*)Hloc(indexLeft, curTupleLeft);
		}
		if (curNodeRight == NULL)
			curPosRight  = BATcount(mapRight)-1;
		else {
			curTupleRight = baseRight + curNodeRight->position;
   	             	curValueRight = *(@1 *)Tloc(indexRight, curTupleRight);
        	        curPosRight   = *(oid*)Hloc(indexRight, curTupleRight);	
		}
		
#ifdef DEBUG_CRACKERS_JOIN
		printf(" leftVal %d rightVal %d \n", curValueLeft, curValueRight);
		printf(" prevPosLeft %lld curPosLeft %lld \n", prevPosLeft,curPosLeft);
		printf(" prevPosRight %lld curPosRight %lld \n", prevPosRight,curPosRight);
#endif

		if (curNodeLeft != NULL && curNodeRight == NULL){	
#ifdef DEBUG_CRACKERS_JOIN
			printf("crack Right \n");
#endif
#ifdef TIMER_CRACKERS_JOIN
			crackedOperationsRight++;

			TC1=GDKusec();	
#endif
			if (curNodeLeft->inclusive == TRUE)
		                CRKcrackUnorderedZeroSideways_RE_@1_@1(mapRight, curValueLeft, prevPosRight+1, curPosRight, &newPosition);
        		else 
                		CRKcrackUnorderedZeroSideways_LE_@1_@1(mapRight, curValueLeft, prevPosRight+1, curPosRight, &newPosition);

#ifdef DEBUG_CRACKERS_JOIN
			printf("newPos %lld \n",newPosition);
#endif
#ifdef TIMER_CRACKERS_JOIN

			TC2=GDKusec();	
			TCtotal+=TC2-TC1;
#endif
			if (newPosition < curPosRight){
				newprevNodeRight = addCrackerIndex_@1(mapRpos, &curValueLeft, curNodeLeft->inclusive, newPosition, indexRight);
				AddToTape_@1(mapRpos, @1_nil, curValueLeft, curNodeLeft->inclusive, curNodeLeft->inclusive);
				curPosRight = newPosition;
				crackedRight = TRUE;
			}
			else {  /* this means that there is no chance to join with the future pieces of the other side */

#ifdef DEBUG_CRACKERS_JOIN
				printf("skippiing the rest of the pieces left");
#endif

				@:JoinTwoPiecesReuseHashTables()@

#ifdef TIMER_CRACKERS_JOIN
				joinsDone++;
#endif
				break;
			}
		}
		else if (curNodeLeft == NULL && curNodeRight != NULL){
#ifdef DEBUG_CRACKERS_JOIN
			printf("crack Left \n");
#endif

#ifdef TIMER_CRACKERS_JOIN
			crackedOperationsLeft++;

			TC1=GDKusec();	
#endif
			if (curNodeRight->inclusive == TRUE)
		                CRKcrackUnorderedZeroSideways_RE_@1_@1(mapLeft, curValueRight, prevPosLeft+1, curPosLeft, &newPosition);
        		else 
                		CRKcrackUnorderedZeroSideways_LE_@1_@1(mapLeft, curValueRight, prevPosLeft+1, curPosLeft, &newPosition);

#ifdef DEBUG_CRACKERS_JOIN
			printf("newPos %lld \n",newPosition);
#endif

#ifdef TIMER_CRACKERS_JOIN
			TC2=GDKusec();	
			TCtotal+=TC2-TC1;
#endif
			if (newPosition < curPosLeft){
				newprevNodeLeft = addCrackerIndex_@1(mapLpos, &curValueRight, curNodeRight->inclusive, newPosition, indexLeft);
				AddToTape_@1(mapLpos, @1_nil, curValueRight, curNodeRight->inclusive, curNodeRight->inclusive);
				curPosLeft = newPosition;
				crackedLeft = TRUE;
			}
			else {

#ifdef DEBUG_CRACKERS_JOIN
				printf("skipping the rest of the pieces right");
#endif

				@:JoinTwoPiecesReuseHashTables()@
#ifdef TIMER_CRACKERS_JOIN
				joinsDone++;
#endif
				break;
			}
		}
		else if (curNodeLeft == NULL && curNodeRight == NULL){

#ifdef DEBUG_CRACKERS_JOIN
			printf(" into the last piece for both maps \n");
#endif

			@:JoinTwoPiecesReuseHashTables()@

#ifdef TIMER_CRACKERS_JOIN
			joinsDone++;
#endif
			break;
		}			

		@:JoinTwoPiecesReuseHashTables()@
#ifdef TIMER_CRACKERS_JOIN
		joinsDone++;
#endif

		prevPosLeft   = curPosLeft;
		if (crackedLeft == FALSE){
			prevNodeLeft  = curNodeLeft;
			curNodeLeft = findNextPiece(curNodeLeft);
		}else prevNodeLeft = newprevNodeLeft; 

		prevPosRight   = curPosRight;
		if (crackedRight == FALSE){
			prevNodeRight  = curNodeRight;
        		curNodeRight = findNextPiece(curNodeRight);
		} else prevNodeRight = newprevNodeRight;
	}
	
        *resid = res->batCacheid;
        BBPkeepref(*resid);

        BBPunfix(indexLeft->batCacheid);
        BBPunfix(indexRight->batCacheid);
        BBPunfix(mapLeft->batCacheid);
        BBPunfix(mapRight->batCacheid);

#ifdef TIMER_CRACKERS_JOIN
	T2=GDKusec();

	printf(" Total  %lld Join %lld Crack %lld Rest  %lld Cracks %lld Left %lld Right %lld Joins %lld \n", 
			T2-T1, TJtotal, TCtotal, ((T2-T1)-TJtotal)-TCtotal, crackedOperationsLeft + crackedOperationsRight, 
			crackedOperationsLeft, crackedOperationsRight, joinsDone);
#endif

	return MAL_SUCCEED;

}	

str cacheConsciousAlignJoinStep(BAT *mapLeft, BAT *mapRight, struct Node *curNodeRight, oid startPos, oid endPos, BAT *indexRight, BUN baseRight, BAT * indexLeft, int mapLpos, oid cacheThreshold, struct Node *firstNodeRight, struct Node *lastNodeRight, BAT *res){
	oid newPosition=0;
	struct Node *temp, *prevNodeRight;
	BAT * viewHeadRight=NULL, *viewRight=NULL, *viewLeft=NULL, *markedViewRight=NULL;
	bit existsHashTableRight;

	oid prevPosRight, curPosRight, prevPosLeft, curPosLeft;

	@1 bound = *(@1*)Tloc(indexRight, baseRight + curNodeRight->position);

/*	
printf("\nalign Join\n");
printf("\n fL "OIDFMT" lL "OIDFMT" ",startPos, endPos);
if (firstNodeRight==NULL) printf(" fR  0 ");
else printf(" fR  "OIDFMT" ", firstNodeRight->indexPosition);
if (lastNodeRight==NULL) printf(" lR  End ");
else printf(" lR  "OIDFMT" ", lastNodeRight->indexPosition);
printf(" cur  "OIDFMT"  \n", curNodeRight->indexPosition);
*/
	if (curNodeRight->inclusive == TRUE)
	
		CRKcrackUnorderedZero_RE_@1(mapLeft, bound, startPos, endPos, &newPosition);
        else
		CRKcrackUnorderedZero_LE_@1(mapLeft, bound, startPos, endPos, &newPosition);
	
	if (newPosition != (startPos==0?0:startPos-1) && newPosition != endPos){

		addCrackerIndex_@1(mapLpos, &bound, curNodeRight->inclusive, newPosition, indexLeft);

		if (newPosition != (startPos==0?0:startPos-1)){
			 
			prevNodeRight = firstNodeRight; 
			prevPosRight = (prevNodeRight==NULL)?0:prevNodeRight->indexPosition+1;
			curPosRight  = curNodeRight->indexPosition;
			prevPosLeft  = startPos;
			curPosLeft   = newPosition;
			if (curPosRight - (prevPosRight+1) < cacheThreshold ||
				curPosLeft - (prevPosLeft+1) < cacheThreshold || 
				curNodeRight->left == NULL){

				@:AlignJoin()@
			}else{
				cacheConsciousAlignJoinStep(mapLeft, mapRight, curNodeRight->left, startPos, newPosition, indexRight, baseRight, indexLeft, mapLpos, cacheThreshold, prevNodeRight, curNodeRight, res);
			}
		}
		if (newPosition != endPos){

			prevNodeRight = curNodeRight; 
			prevPosRight = curNodeRight->indexPosition+1;
			curPosRight  = (lastNodeRight ==NULL)?BATcount(mapRight)-1: lastNodeRight->indexPosition;
			prevPosLeft  = newPosition+1;
			curPosLeft   = endPos;

			if (curPosRight - (prevPosRight+1) < cacheThreshold ||
				curPosLeft - (prevPosLeft+1) < cacheThreshold || 
				curNodeRight->right == NULL){

				@:AlignJoin()@
			}else{
				cacheConsciousAlignJoinStep(mapLeft, mapRight, curNodeRight->right, newPosition+1, endPos, indexRight, baseRight, indexLeft, mapLpos, cacheThreshold, curNodeRight, lastNodeRight, res);
			}
		}
	}
	return MAL_SUCCEED;
}

str CRKAlignJoin_@1(int *resid, int *bidL,  int *bidR1, int *bidR2){
	int mapLpos;
	BAT *indexLeft, *mapLeft;

	int tapeRpos, mapRpos;
	BAT *indexRight, *mapRight;
	BUN baseRight;
	oid cacheSize, cacheThreshold;

	BAT *res;

	cacheSize 	  = 524288;
	cacheThreshold    = (cacheSize / 2) / (16+sizeof(@1));

	/*TODO if left is an intermediate result, use this as a map and create an index */
	/* Get the cracker tape for the set of the left map or create one if it does not exist */

        /* Get the left map */
        mapLpos = newCrackerIndex_@1(*bidL, *bidL);

        /* Take the index of the map */
        if ((indexLeft = BATdescriptor(CrackerIndex[mapLpos].cid)) == NULL)
                throw(MAL, "crackers.fullAllignment", "Cannot access crack index left");


        /* Take the map */
        if ((mapLeft = BATdescriptor(*bidL)) == NULL)
                throw(MAL, "crackers.fullAllignement", "Cannot access crack map left");

	mapLeft->batRestricted= BAT_READ;

	/* Get the cracker tape for the set of the right map or create one if it does not exist */
        tapeRpos = existsCrackerIndexSideways(*bidR1, -1);
        if (tapeRpos == -1)
                tapeRpos = CreateTape_@1(*bidR1);

        /* Get the right map */
        mapRpos = existsCrackerIndexSideways(*bidR1, *bidR2);

        /* Align the map based on the position of its cursor in the cracker tape */
        Sync_@1_@1(tapeRpos, mapRpos);

        /* Take the index of the map */
        if ((indexRight = BATdescriptor(CrackerIndex[mapRpos].cid)) == NULL)
                throw(MAL, "crackers.fullAllignment", "Cannot access crack index right");

        /* Take the map */
        if ((mapRight = BATdescriptor(CrackerIndex[mapRpos].cbid)) == NULL)
                throw(MAL, "crackers.fullAllignement", "Cannot access crack map right");

        baseRight      = BUNfirst(indexRight);

	res = BATnew(TYPE_oid,TYPE_oid,5*BATcount(mapRight));

	cacheConsciousAlignJoinStep(mapLeft, mapRight, CrackerIndex[mapRpos].Tree, 0, BATcount(mapLeft)-1, indexRight, baseRight, indexLeft, mapLpos, cacheThreshold, NULL,NULL,res);



        *resid = res->batCacheid;
        BBPkeepref(*resid);

        BBPunfix(indexLeft->batCacheid);
        BBPunfix(indexRight->batCacheid);
        BBPunfix(mapLeft->batCacheid);
        BBPunfix(mapRight->batCacheid);

	/* Remove map created for the intermediate result */
	BBPdecref(CrackerIndex[mapLpos].cid,TRUE);
	CrackerIndex[mapLpos].cid=-1;
	CrackerIndex[mapLpos].cbid=-1;
	CrackerIndex[mapLpos].bid=-1;

	return MAL_SUCCEED;
}	

str SinglePassJoinPutTuple_@1(@1 *value, oid *id, struct Node *current, BUN baseLeft, BAT * indexLeft, BAT *firstPieceBAT, struct Node *prevNode){

	@1 *bound;  
	if (current == NULL){
		if (prevNode == NULL)
			BUNins(firstPieceBAT, id, value, FALSE);
		else		
			BUNins(prevNode->partition, id, value, FALSE);

		return MAL_SUCCEED;
	}

	bound = (@1*)Tloc(indexLeft, baseLeft + current->position);

	if (@2_GT(value,bound,@1) ||
		(@2_EQ(value,bound,@1) && current->inclusive==TRUE))

		SinglePassJoinPutTuple_@1(value, id, current->right, baseLeft, indexLeft, firstPieceBAT, current);
	else
		SinglePassJoinPutTuple_@1(value, id, current->left,  baseLeft, indexLeft, firstPieceBAT, prevNode);
		
	return MAL_SUCCEED;
}

str CRKOnePassJoin_@1(int *resid, int *bidL,  int *bidR1, int *bidR2){
	int mapLpos;
	BAT *indexLeft, *mapLeft;

	int tapeRpos, mapRpos;
	BAT *indexRight, *mapRight;
	BUN baseRight, baseLeft;
	oid cacheSize, cacheThreshold;

	BAT *res, *newBAT, *firstPieceBAT=NULL, *partitionLeft, *viewRight, *markedViewRight, *viewHeadRight;

	bit existsHashTableRight;

	struct Node *temp, *prevNodeRight, *newEntry, *curNodeRight, *prevNodeLeft;
	oid prevPosRight, nextPosRight, curPosRight;

	@1  *curLeftValue;
	oid *curLeftId;
	oid i;

	lng t1,t2;
	
	cacheSize 	  = 524288;
	cacheThreshold    = (cacheSize / 2) / (16+sizeof(@1));

	/*TODO if left is an intermediate result, use this as a map and create an index */
	/* Get the cracker tape for the set of the left map or create one if it does not exist */

        /* Get the left map */
        mapLpos = newCrackerIndex_@1(*bidL, *bidL);

        /* Take the index of the map */
        if ((indexLeft = BATdescriptor(CrackerIndex[mapLpos].cid)) == NULL)
                throw(MAL, "crackers.fullAllignment", "Cannot access crack index left");

        /* Take the map */
        if ((mapLeft = BATdescriptor(*bidL)) == NULL)
                throw(MAL, "crackers.fullAllignement", "Cannot access crack map left");

	/* Get the cracker tape for the set of the right map or create one if it does not exist */
        tapeRpos = existsCrackerIndexSideways(*bidR1, -1);
        if (tapeRpos == -1)
                tapeRpos = CreateTape_@1(*bidR1);

        /* Get the right map */
        mapRpos = existsCrackerIndexSideways(*bidR1, *bidR2);

        /* Align the map based on the position of its cursor in the cracker tape */
        Sync_@1_@1(tapeRpos, mapRpos);

        /* Take the index of the map */
        if ((indexRight = BATdescriptor(CrackerIndex[mapRpos].cid)) == NULL)
                throw(MAL, "crackers.fullAllignment", "Cannot access crack index right");

        /* Take the map */
        if ((mapRight = BATdescriptor(CrackerIndex[mapRpos].cbid)) == NULL)
                throw(MAL, "crackers.fullAllignement", "Cannot access crack map right");

        baseRight      = BUNfirst(indexRight);

	res = BATnew(TYPE_oid,TYPE_oid,5*BATcount(mapRight));

	/*First go through the right index and identify the pieces to be used for partitioning the left input */
	temp = getFirstNode(CrackerIndex[mapRpos].Tree); 
	prevPosRight=0;
	prevNodeRight = NULL;
	t1=GDKusec();
	while (temp!=NULL){
		nextPosRight = (temp->nextValue==NULL)?BATcount(mapRight)-1:temp->nextValue->indexPosition;
		if (nextPosRight - prevPosRight > cacheThreshold){
			newBAT = BATnew(TYPE_oid,TYPE_@1,temp->indexPosition-prevPosRight);
			BATsetcount(newBAT,0);
			if (prevPosRight == 0)
				firstPieceBAT = newBAT; 
			else{
				newEntry = addCrackerIndex_@1(mapLpos, (@1*)Tloc(indexRight, baseRight + prevNodeRight->position), prevNodeRight->inclusive, 0, indexLeft);
				newEntry->partition = newBAT;	
			}
			prevNodeRight = temp;
			prevPosRight=temp->indexPosition;
		}

		temp=temp->nextValue;
	}
	/*insert last piece*/
	newEntry = addCrackerIndex_@1(mapLpos, (@1*)Tloc(indexRight, baseRight + prevNodeRight->position), prevNodeRight->inclusive, 0, indexLeft);
	newEntry->partition = BATnew(TYPE_oid,TYPE_@1,BATcount(mapRight)-1-prevPosRight);
	t2=GDKusec();

	printf("\n preparing the index %lld \n", t2-t1);
/*
	printf("\n Left \n");
	printAVLTree(CrackerIndex[mapLpos].Tree, indexLeft, BUNfirst(indexLeft));
	printf("\n Right \n");
	printAVLTree(CrackerIndex[mapRpos].Tree, indexRight, baseRight);

*/

	t1=GDKusec();
	/* now we go through the left input and put every tuple in the proper partition */
	curLeftValue = (@1 *)Tloc(mapLeft,BUNfirst(mapLeft));
	curLeftId    = (oid*)Hloc(mapLeft,BUNfirst(mapLeft));
        baseLeft     = BUNfirst(indexLeft);
	for(i=0;i<BATcount(mapLeft);i++){
		SinglePassJoinPutTuple_@1(curLeftValue, curLeftId, CrackerIndex[mapLpos].Tree,  baseLeft, indexLeft, firstPieceBAT, NULL);
		curLeftValue++;
		curLeftId++;
	}	

	t2=GDKusec();
	printf("\n filling in the partitions %lld \n", t2-t1);

/*
	i=0;
	temp  = getFirstNode(CrackerIndex[mapLpos].Tree); 
	if (BATcount(firstPieceBAT) > 0){
		printf("\nBAT "OIDFMT" size "OIDFMT "\n",i, BATcount(firstPieceBAT));
				
	}
	i=1;
	while(temp!=NULL){
		printf("\nBAT "OIDFMT" size  "OIDFMT" \n",i,BATcount(temp->partition));
		temp=temp->nextValue;
		i++;
	}

*/





	t1=GDKusec();
	/* The final step is to go through all pieces and perform the joins */
	prevNodeRight 	= NULL;
	prevNodeLeft 	= NULL;
	curNodeRight  	= getFirstNode(CrackerIndex[mapRpos].Tree); 
	temp  		= getFirstNode(CrackerIndex[mapLpos].Tree); 

	while(temp!=NULL){
		curLeftValue = (@1 *)Tloc(indexLeft, baseLeft + temp->position);
		while(@2_GT(curLeftValue,(@1*)Tloc(indexRight, baseRight + curNodeRight->position),@1)){
			if (curNodeRight->nextValue == NULL) break;
			curNodeRight = curNodeRight->nextValue;
		}

		partitionLeft = (prevNodeLeft == NULL)?firstPieceBAT:prevNodeLeft->partition;
		if (BATcount(partitionLeft) > 0){
			prevPosRight = (prevNodeRight == NULL)?0:prevNodeRight->indexPosition;
			curPosRight  = (curNodeRight==NULL)?BATcount(mapRight)-1:curNodeRight->indexPosition;			
			@:SinglePassJoin()@
		}else
			BBPunfix(partitionLeft->batCacheid);

		prevNodeRight = curNodeRight;
		curNodeRight = curNodeRight->nextValue;
		prevNodeLeft = temp;
		temp=temp->nextValue;
	}

	partitionLeft = (prevNodeLeft == NULL)?firstPieceBAT:prevNodeLeft->partition;
	if (BATcount(partitionLeft) > 0){
		prevPosRight = (prevNodeRight == NULL)?0:prevNodeRight->indexPosition;
		curPosRight  = BATcount(mapRight)-1;			
		@:SinglePassJoin()@
	}else
		BBPunfix(partitionLeft->batCacheid);

	t2=GDKusec();
	printf("\n doing the join  %lld \n", t2-t1);

        *resid = res->batCacheid;
        BBPkeepref(*resid);

        BBPunfix(indexLeft->batCacheid);
        BBPunfix(indexRight->batCacheid);
        BBPunfix(mapLeft->batCacheid);
        BBPunfix(mapRight->batCacheid);

	/* Remove map created for the intermediate result */
	BBPdecref(CrackerIndex[mapLpos].cid,TRUE);
	CrackerIndex[mapLpos].cid=-1;
	CrackerIndex[mapLpos].cbid=-1;
	CrackerIndex[mapLpos].bid=-1;

	return MAL_SUCCEED;
}	
str CRKAlreadyAlignedJoin_@1(int *resid, int *bidL1,  int *bidR1, int *bidR2){
	lng T1=GDKusec(), TJtotal = 0, TJ1, TJ2, T2;
	int  mapLpos;
	struct Node *curNodeLeft; 
	BAT *indexLeft, *mapLeft, *viewLeft;
	BUN baseLeft;
	oid curPosLeft, prevPosLeft;
	@1  curValueLeft;

	int tapeRpos, mapRpos;
	struct Node *curNodeRight, *prevNodeRight; 
	BAT *indexRight, *mapRight, *viewRight, *markedViewRight=NULL, *viewHeadRight;
	BUN baseRight;
	oid curPosRight, prevPosRight;
        @1  curValueRight;

	bit existsHashTableRight=FALSE;
	BAT *res;
	lng joinsDone = 0;

	struct Node *temp;

        /* Get the left map */
        mapLpos = existsCrackerIndex(*bidL1);

        /* Take the index of the map */
        if ((indexLeft = BATdescriptor(CrackerIndex[mapLpos].cid)) == NULL)
                throw(MAL, "crackers.Join", "Cannot access crack index left");

        /* Take the map */
        if ((mapLeft = BATdescriptor(CrackerIndex[mapLpos].cbid)) == NULL)
                throw(MAL, "crackers.Join", "Cannot access crack map left");

	/* Get the piece that holds the lowest values */
	curNodeLeft = getFirstNode(CrackerIndex[mapLpos].Tree);

	baseLeft      = BUNfirst(indexLeft);

	/* Get the cracker tape for the set of the right map or create one if it does not exist */
        tapeRpos = existsCrackerIndexSideways(*bidR1, -1);
        if (tapeRpos == -1)
                tapeRpos = CreateTape_@1(*bidR1);

        /* Get the right map */
        mapRpos = existsCrackerIndexSideways(*bidR1, *bidR2);

        /* Align the map based on the position of its cursor in the cracker tape */
        Sync_@1_@1(tapeRpos, mapRpos);

        /* Take the index of the map */
        if ((indexRight = BATdescriptor(CrackerIndex[mapRpos].cid)) == NULL)
                throw(MAL, "crackers.Join", "Cannot access crack index right");

        /* Take the map */
        if ((mapRight = BATdescriptor(CrackerIndex[mapRpos].cbid)) == NULL)
                throw(MAL, "crackers.Join", "Cannot access crack map right");
	
#ifdef DEBUG_CRACKERS_JOIN
	printf("maps\n");
	BATprint(mapLeft);
	BATprint(mapRight);
#endif

        /* Get the piece that holds the lowest values */
        curNodeRight = getFirstNode(CrackerIndex[mapRpos].Tree);

        baseRight      = BUNfirst(indexRight);

	res = BATnew(TYPE_oid,TYPE_oid,5*BATcount(mapRight));
	
	prevPosLeft   = prevPosRight   = -1;
	prevNodeRight  = NULL;

	@:dumpIndex(New Join Index Left)@
	/* the left has no index and it all falls into the first piece of the right */
	if (curNodeLeft == NULL){
        	curValueRight = *(@1 *)Tloc(indexRight, baseRight + curNodeRight->position);
        	curPosRight   = curNodeRight->indexPosition;

		curValueLeft =  *(@1*)Hloc(mapLeft,BUNfirst(mapLeft));
		if (curValueRight > curValueLeft ||
                	((curValueLeft == curValueRight) && (curNodeRight->inclusive == FALSE))){
			curPosLeft   = BATcount(mapLeft)-1;
			@:JoinTwoPiecesReuseHashTablesRight()@
			joinsDone++;
			goto done;
		}
	}

	while (curNodeLeft != NULL && curNodeRight != NULL){

		existsHashTableRight = FALSE;

       		curValueLeft = *(@1 *)Tloc(indexLeft,baseLeft + curNodeLeft->position);
        	curPosLeft   = curNodeLeft->indexPosition;

        	curValueRight = *(@1 *)Tloc(indexRight, baseRight + curNodeRight->position);
        	curPosRight   = curNodeRight->indexPosition;
		
#ifdef DEBUG_CRACKERS_JOIN
		printf(" leftVal %d rightVal %d \n", curValueLeft, curValueRight);
		printf(" prevPosLeft %lld curPosLeft %lld \n", prevPosLeft,curPosLeft);
		printf(" prevPosRight %lld curPosRight %lld \n", prevPosRight,curPosRight);
#endif

		while (curValueRight < curValueLeft){

#ifdef DEBUG_CRACKERS_JOIN
			printf("\n skiping right \n");
#endif
			if (curNodeRight->nextValue == NULL){
				curPosRight  = BATcount(mapRight)-1;
				goto last;
			}
        		curNodeRight = curNodeRight->nextValue;

        		curValueRight = *(@1 *)Tloc(indexRight, baseRight + curNodeRight->position);
        		curPosRight   = curNodeRight->indexPosition;
		}

		@:JoinTwoPiecesReuseHashTablesRight()@
		joinsDone++;

		prevPosLeft   = curPosLeft;
		curNodeLeft = curNodeLeft->nextValue;

		prevPosRight   = curPosRight;
		prevNodeRight  = curNodeRight;
        	curNodeRight = curNodeRight->nextValue;
	}

	/* handle last pieces or the case where the left has no index and it all falls to the last piece of the right */
	curPosLeft   = BATcount(mapLeft)-1;
	curPosRight  = BATcount(mapRight)-1;
	last:;
	@:JoinTwoPiecesReuseHashTablesRight()@
	joinsDone++;

	done:;
        *resid = res->batCacheid;
        BBPkeepref(*resid);

        BBPunfix(indexLeft->batCacheid);
        BBPunfix(indexRight->batCacheid);
        BBPunfix(mapLeft->batCacheid);
        BBPunfix(mapRight->batCacheid);

	/* Remove map created for the intermediate result */
	BBPdecref(CrackerIndex[mapLpos].cid,TRUE);
	BBPdecref(CrackerIndex[mapLpos].cbid,TRUE);
	CrackerIndex[mapLpos].cid=-1;
	CrackerIndex[mapLpos].cbid=-1;
	CrackerIndex[mapLpos].bid=-1;

	T2=GDKusec();

	printf(" Total  %lld Join %lld Rest  %lld Joins %lld \n", 
			T2-T1, TJtotal, (T2-T1)-TJtotal,joinsDone);

	return MAL_SUCCEED;
}	

str CRKbandJoin_@1(int *resid, int *bidL, int *bidR, @1 *c1, @1 *c2, bit *inclusiveLow, bit *inclusiveHgh){
	BAT *BATLeft, *b, *c, *res;
	int m;
	@1 currentValue;
	BUN currentTupleLeft; 
	oid *currentResTupleHead, *currentResTupleTail, *curViewTupleHead, *currentTupleLeftHead;
	oid numberOfTuplesLeft;
	bit HBound;	
	@1 low, hgh;
	oid vl=0, vh=0, posl, posh, _vl;
	oid cl1=0, ch1=0, cl2=0, ch2=0;
	int foundLow, foundHgh;
	oid resCount=0;
	int gapL=0,gapH=0;
	oid i,j;
	
	if (*inclusiveHgh == TRUE) HBound = FALSE;
	else	HBound = TRUE; 				

	if ((BATLeft = BATdescriptor(*bidL)) == NULL)
        	throw(MAL, "crackers.thetajoin", "Cannot access descriptor");

	if ((b = BATdescriptor(*bidR)) == NULL)
        	throw(MAL, "crackers.thetajoin", "Cannot access descriptor");

	m = newCrackerIndex_@1(*bidR,b->batCacheid);

        if ((c = BATdescriptor(CrackerIndex[m].cid)) == NULL)
        	throw(MAL, "crackers.thetajoin", "Cannot access cracker index");

	res = BATnew(TYPE_oid,TYPE_oid,5*(*c1+*c2)*BATcount(b));
	currentResTupleHead = (oid*)Hloc(res,BUNfirst(res));
	currentResTupleTail = (oid*)Tloc(res,BUNfirst(res));

	numberOfTuplesLeft = BATcount(BATLeft);
	currentTupleLeft   = BUNfirst(BATLeft);

	currentValue = *(@1*)Tloc(BATLeft, currentTupleLeft);
	currentTupleLeftHead = (oid*)Hloc(BATLeft, currentTupleLeft);
	low  = currentValue - *c1;			
	hgh  = currentValue + *c2;			

	posl = BUNfirst(b);
	posh = BUNlast(b)-1;

	@:crackDoubleSidedBound(@1,posl,posh)@
	@:addPartialResult()@
	currentTupleLeft ++;

	for(i=1;i<numberOfTuplesLeft;i++){
		currentValue = *(@1*)Tloc(BATLeft, currentTupleLeft);
		currentTupleLeftHead = (oid*)Hloc(BATLeft, currentTupleLeft);
		low  = currentValue - *c1;			
		hgh  = currentValue + *c2;			


		foundLow = GetLow_@1(low, *inclusiveLow, CrackerIndex[m].Tree, c, BUNfirst(c), 
					&cl1, &ch1, 0, BUNlast(b)-1);

		foundHgh = GetHgh_@1(hgh, *inclusiveHgh, CrackerIndex[m].Tree, c,  BUNfirst(c), 
					&cl2, &ch2, 0, BUNlast(b)-1);

		if (cl1 != 0) cl1++;
		if (cl2 != 0) cl2++;

		if (foundLow == 0 || foundHgh == 0){
			if (foundLow == 0 && foundHgh == 0){
				if (cl1 == cl2){
					@:crackDoubleSidedBound(@1,cl1,ch2)@
				} else {
					@:crackSingleSidedBoundLeft(@1)@
					@:crackSingleSidedBoundRight(@1)@
					if (vl>0) _vl=vl-1; else _vl=vl;		
					if (gapL>0) addCrackerIndex_@1(m,&low,*inclusiveLow,_vl,c);
					if (gapH>0) addCrackerIndex_@1(m,&hgh,HBound,vh,c);
				}
			} else
			if (foundLow == 0){
				@:crackSingleSidedBoundLeft(@1)@
				if (vl>0) _vl=vl-1; else _vl=vl;		
				if (gapL>0) addCrackerIndex_@1(m,&low,*inclusiveLow,_vl,c);
				vh = ch2;
			} else
			if (foundHgh == 0){
				@:crackSingleSidedBoundRight(@1)@
				if (gapH>0) addCrackerIndex_@1(m,&hgh,HBound,vh,c);
				vl = cl1;
			}	 	
		} else {
			vl = cl1;
			vh = ch2;
		}

		@:addPartialResult()@
		currentTupleLeft ++;
	}

	BATsetcount(res,resCount);
        *resid = res->batCacheid;
        BBPkeepref(*resid);
        BBPunfix(b->batCacheid);
        BBPunfix(c->batCacheid);
        BBPunfix(BATLeft->batCacheid);
	return MAL_SUCCEED;
}
	
str CRKsortBandJoin_@1(int *resid, int *bidL, int *bidR, @1 *c1, @1 *c2, bit *inclusiveLow, bit *inclusiveHgh){
	BAT *BATLeft, *BATRight, *res;
	@1 currentValue;
	BUN currentTupleLeft, currentTupleRight; 
	oid *currentResTupleHead, *currentResTupleTail, *currentTupleLeftHead;
	oid numberOfTuplesLeft;
	@1 low, hgh;
	oid resCount=0;
	oid i;

	if ((BATLeft = BATdescriptor(*bidL)) == NULL)
        	throw(MAL, "crackers.thetajoin", "Cannot access descriptor");

	if ((BATRight = BATdescriptor(*bidR)) == NULL)
        	throw(MAL, "crackers.thetajoin", "Cannot access descriptor");

	res = BATnew(TYPE_oid,TYPE_oid,5*(*c1+*c2)*BATcount(BATRight));
	currentResTupleHead = (oid*)Hloc(res,BUNfirst(res));
	currentResTupleTail = (oid*)Tloc(res,BUNfirst(res));

	numberOfTuplesLeft = BATcount(BATLeft);
	currentTupleLeft   = BUNfirst(BATLeft);

	/* sort in place the right bat */
        if (BATRight->tsorted == FALSE){
                BATRight->batRestricted = BAT_WRITE;
                BATmirror(BATorder(BATmirror(BATRight)));
        }

	for(i=0;i<numberOfTuplesLeft;i++){
		currentValue = *(@1*)Tloc(BATLeft, currentTupleLeft);
		currentTupleLeftHead = (oid*)Hloc(BATLeft, currentTupleLeft);
		low  = currentValue - *c1;			
		hgh  = currentValue + *c2;			
		
		currentTupleRight = SORTfndfirst_@1(BATRight,&low);
		if (currentTupleRight == BUNlast(BATRight))
			goto next;
	
		if ((*(@1*)Tloc(BATRight, currentTupleRight) == low)&&(*inclusiveLow == TRUE)){
			@:sortInsertPartialResult()@
			while (*(@1*)Tloc(BATRight, currentTupleRight) == low){
				@:sortInsertPartialResult()@
			}
		}

		while (*(@1*)Tloc(BATRight, currentTupleRight) < hgh){
			@:sortInsertPartialResult()@
                }
	
		if (*inclusiveHgh == TRUE){
			while (*(@1*)Tloc(BATRight, currentTupleRight) == hgh){
				@:sortInsertPartialResult()@
                	}
		}

		next:;
		currentTupleLeft ++;
	}

	BATsetcount(res,resCount);
        *resid = res->batCacheid;
        BBPkeepref(*resid);
        BBPunfix(BATRight->batCacheid);
        BBPunfix(BATLeft->batCacheid);
	return MAL_SUCCEED;
}

void cacheConsciousAlignStep(BAT *mapLeft, struct Node *curNodeRight, oid startPos, oid endPos, BAT *indexRight, BUN baseRight, BAT * indexLeft, int mapLpos, oid cacheThreshold, oid RightStartPos, oid RightEndPos){
	oid newPosition=0;
	@1 bound = *(@1*)Tloc(indexRight, baseRight + curNodeRight->position);
	
	if (curNodeRight->inclusive == TRUE)
		CRKcrackUnorderedZero_RE_@1(mapLeft, bound, startPos, endPos, &newPosition);
        else
		CRKcrackUnorderedZero_LE_@1(mapLeft, bound, startPos, endPos, &newPosition);

	if (newPosition != (startPos==0?0:startPos-1) && newPosition != endPos){
		addCrackerIndex_@1(mapLpos, &bound, curNodeRight->inclusive, newPosition, indexLeft);
		if (newPosition != (startPos==0?0:startPos-1) && curNodeRight->left != NULL 
				&&  curNodeRight->indexPosition - RightStartPos >cacheThreshold)
			cacheConsciousAlignStep(mapLeft, curNodeRight->left, startPos, newPosition, indexRight, baseRight, indexLeft, mapLpos, cacheThreshold, RightStartPos, curNodeRight->indexPosition);

		if (newPosition != endPos && curNodeRight->right != NULL
				&&  RightEndPos - curNodeRight->indexPosition-1 >cacheThreshold)
			cacheConsciousAlignStep(mapLeft, curNodeRight->right, newPosition+1, endPos, indexRight, baseRight, indexLeft, mapLpos, cacheThreshold, curNodeRight->indexPosition+1, RightEndPos);
	}
}

void alignStep(BAT *mapLeft, struct Node *curNodeRight, oid startPos, oid endPos, BAT *indexRight, BUN baseRight, BAT * indexLeft, int mapLpos){
	oid newPosition=0;
	@1 bound = *(@1*)Tloc(indexRight, baseRight + curNodeRight->position);
	
	if (curNodeRight->inclusive == TRUE)
		CRKcrackUnorderedZero_RE_@1(mapLeft, bound, startPos, endPos, &newPosition);
        else
		CRKcrackUnorderedZero_LE_@1(mapLeft, bound, startPos, endPos, &newPosition);

	if (newPosition != (startPos==0?0:startPos-1) && newPosition != endPos){
		addCrackerIndex_@1(mapLpos, &bound, curNodeRight->inclusive, newPosition, indexLeft);
		if (newPosition != (startPos==0?0:startPos-1) && curNodeRight->left != NULL)
			alignStep(mapLeft, curNodeRight->left, startPos, newPosition, indexRight, baseRight, indexLeft, mapLpos);
		if (newPosition != endPos && curNodeRight->right != NULL)
			alignStep(mapLeft, curNodeRight->right, newPosition+1, endPos, indexRight, baseRight, indexLeft, mapLpos);
	}
}

str CRKFullAlignment_@1(int *res, int *bidL, int *bidR1, int *bidR2){
	int mapLpos;
	BAT *indexLeft, *mapLeft;

	int tapeRpos, mapRpos;
	BAT *indexRight, *mapRight;
	BUN baseRight;
	oid cacheSize, cacheThreshold;
	
	(void)res;


	cacheSize 	  = 524288;
	cacheThreshold    = (cacheSize / 2) / (16+sizeof(@1));

	/*TODO if left is an intermediate result, use this as a map and create an index */
	/* Get the cracker tape for the set of the left map or create one if it does not exist */

        /* Get the left map */
        mapLpos = newCrackerIndex_@1(*bidL, *bidL);

        /* Take the index of the map */
        if ((indexLeft = BATdescriptor(CrackerIndex[mapLpos].cid)) == NULL)
                throw(MAL, "crackers.fullAllignment", "Cannot access crack index left");


        /* Take the map */
        if ((mapLeft = BATdescriptor(CrackerIndex[mapLpos].cbid)) == NULL)
                throw(MAL, "crackers.fullAllignement", "Cannot access crack map left");

	mapLeft->batRestricted= BAT_READ;

	/* Get the cracker tape for the set of the right map or create one if it does not exist */
        tapeRpos = existsCrackerIndexSideways(*bidR1, -1);
        if (tapeRpos == -1)
                tapeRpos = CreateTape_@1(*bidR1);

        /* Get the right map */
        mapRpos = existsCrackerIndexSideways(*bidR1, *bidR2);

        /* Align the map based on the position of its cursor in the cracker tape */
        Sync_@1_@1(tapeRpos, mapRpos);

        /* Take the index of the map */
        if ((indexRight = BATdescriptor(CrackerIndex[mapRpos].cid)) == NULL)
                throw(MAL, "crackers.fullAllignment", "Cannot access crack index right");

        /* Take the map */
        if ((mapRight = BATdescriptor(CrackerIndex[mapRpos].cbid)) == NULL)
                throw(MAL, "crackers.fullAllignement", "Cannot access crack map right");

        baseRight      = BUNfirst(indexRight);

#ifdef DEBUG_CRACKERS_JOIN
	if (CrackerIndex[mapRpos].Tree == NULL) 
		printf("\n head is null \n");
#endif

	cacheConsciousAlignStep(mapLeft, CrackerIndex[mapRpos].Tree, 0, BATcount(mapLeft)-1, indexRight, baseRight, indexLeft, mapLpos, cacheThreshold, 0, BATcount(mapRight)-1);

#ifdef DEBUG_CRACKERS_JOIN
	printf("\n Left \n");
	printAVLTree(CrackerIndex[mapLpos].Tree, indexLeft, BUNfirst(indexLeft));
	printf("\n Right \n");
	printAVLTree(CrackerIndex[mapRpos].Tree, indexRight, baseRight);
#endif

	BBPunfix(indexLeft->batCacheid);
	BBPkeepref(mapLeft->batCacheid);
	BBPunfix(indexRight->batCacheid);
	BBPunfix(mapRight->batCacheid);
        return MAL_SUCCEED;

}
@


@}



